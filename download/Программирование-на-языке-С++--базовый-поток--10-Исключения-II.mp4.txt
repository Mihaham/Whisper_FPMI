[00:00.000 --> 00:08.000]  Познакомились с понятием исключений, обработкой исключений
[00:08.000 --> 00:12.280]  C++, грубо говоря, какой новый способ обработки ошибок
[00:12.280 --> 00:16.080]  и способ сообщения о них предоставляет C++ по сравнению
[00:16.080 --> 00:17.920]  с его предшественниками языком C.
[00:17.920 --> 00:22.000]  Прежде чем двигаться дальше, давайте разберем исторический
[00:22.000 --> 00:23.000]  анекдот.
[00:23.000 --> 00:27.920]  Иногда, точнее раньше, я довольно часто у студентов
[00:27.920 --> 00:31.720]  видел следующий код, соответственно, раз он встречается довольно
[00:31.720 --> 00:35.080]  часто, то давайте его обсудим на предмет того, почему так
[00:35.080 --> 00:38.160]  писать не стоит, ну и в чем тут проблема.
[00:38.160 --> 00:41.600]  Смотрите, что здесь происходит.
[00:41.600 --> 00:45.540]  Вот, допустим, кто-то написал следующий код, он написал
[00:45.540 --> 00:48.880]  функцию f, дальше вызывает функцию g, ну и по всей видимости
[00:48.880 --> 00:50.800]  он считает, что функция g, она какая-то потенциально
[00:50.800 --> 00:51.800]  опасная.
[00:51.800 --> 00:53.720]  Ну а раз она потенциально опасная, то соответственно
[00:53.720 --> 00:57.520]  нужно, и при этом я не хочу, чтобы, и при этом я хочу
[00:57.640 --> 01:00.160]  эту ошибку как-то, не знаю, обработать, как-то сообщить
[01:00.160 --> 01:02.840]  о том, что функция g потенциально может брать исключение,
[01:02.840 --> 01:05.160]  и соответственно, для этого я оборачиваю вызов функции
[01:05.160 --> 01:08.680]  g в блок try, дальше, ну так как я потенциально не знаю,
[01:08.680 --> 01:10.800]  что я хочу поймать, точнее, что может выбросить функцию
[01:10.800 --> 01:12.840]  g, ну и вообще, в принципе, мне не важно, что выбросило
[01:12.840 --> 01:14.960]  функцию g, мне хочется эту ошибку просто как-то обработать
[01:14.960 --> 01:16.760]  и дальше выбросить ее дальше.
[01:16.760 --> 01:20.720]  В целом, этот код плюс-минус бесполезен.
[01:20.720 --> 01:21.720]  Почему?
[01:21.720 --> 01:23.680]  Потому что о чем говорит этот код?
[01:23.680 --> 01:26.640]  Этот код говорит о том, что я не знаю, как находясь
[01:26.640 --> 01:30.280]  внутри функции f, исправить ошибку, или когда я нахожусь
[01:30.280 --> 01:33.600]  внутри функции f, и если при этом функции g, что-то пошло
[01:33.600 --> 01:38.160]  не так, то никаких дополнительных действий, например, по очистке
[01:38.160 --> 01:40.840]  памяти, по воздействию каких-то ресурсов обратным
[01:40.840 --> 01:42.280]  перспективным системе, мне делать не нужно.
[01:42.280 --> 01:44.440]  То есть, в принципе, функция f тут явно сообщает о том,
[01:44.440 --> 01:48.120]  что в целом исправить ошибку я не могу, и каких-то
[01:48.120 --> 01:51.200]  дополнительных действий в случае возникновения ошибки
[01:51.200 --> 01:52.200]  делать мне не нужно.
[01:53.040 --> 01:58.520]  Но чтобы это сказать, этот код является довольно-таки
[01:58.520 --> 01:59.520]  избыточным.
[01:59.520 --> 02:00.520]  Почему?
[02:00.520 --> 02:02.600]  Потому что если мы просто-напросто опустим все блоки try и catch,
[02:02.600 --> 02:04.320]  то мы получим ровно тот же самый результат.
[02:04.320 --> 02:06.760]  То есть, если функция f дойдет до вызова функции g, и при
[02:06.760 --> 02:09.680]  вызове функции g возникнет исключение, то в случае,
[02:09.680 --> 02:11.680]  если f это исключение не обрабатывает, то исключение
[02:11.680 --> 02:13.640]  просто-напросто вылетает из функции f.
[02:13.640 --> 02:16.560]  То есть, мы получаем ровно тот же самый эффект, что
[02:16.560 --> 02:17.560]  и на слайде выше.
[02:17.560 --> 02:18.560]  Понятно?
[02:18.560 --> 02:22.040]  Поэтому просто ловить исключение для того, чтобы
[02:22.040 --> 02:24.200]  его поймать, так делать не нужно.
[02:24.200 --> 02:26.800]  Исключение все-таки нужно ловить только тогда, когда
[02:26.800 --> 02:29.160]  вы знаете, как исправить ошибку, либо тогда, когда
[02:29.160 --> 02:31.480]  вам действительно нужно сделать какие-то дополнительные
[02:31.480 --> 02:35.640]  действия для того, чтобы как-то исключение в дальнейшем
[02:35.640 --> 02:38.920]  либо обработать, либо сделать так, чтобы избежать утечек
[02:38.920 --> 02:39.920]  памяти и того подобного.
[02:39.920 --> 02:45.440]  В экстремальном случае этого кейса я видел вот такой
[02:45.440 --> 02:46.440]  пример.
[02:47.400 --> 02:52.360]  Смотрите, функция f бросает исключение, но по какой-то
[02:52.360 --> 02:57.440]  причине кому-то почему-то очень хочется заключить
[02:57.440 --> 03:02.040]  этот throw x в блок try, дальше поймать его в киче и бросить
[03:02.040 --> 03:03.040]  дальше.
[03:03.040 --> 03:08.720]  Грубо говоря, я сгенерировал исключение, дальше его обработал
[03:08.720 --> 03:09.720]  и бросил дальше.
[03:09.720 --> 03:12.160]  Ну, смотрите, если вы хотите выбросить исключение, то
[03:12.160 --> 03:14.000]  пожалуйста, просто его бросайте.
[03:14.000 --> 03:15.760]  Не нужно никаким образом дополнительно обрабатывать
[03:15.840 --> 03:17.720]  функции, которая сама генерировал исключение.
[03:17.720 --> 03:19.920]  Если функция сама генерировала исключение, значит, что
[03:19.920 --> 03:23.280]  она сделала всё что могла и исключение теперь
[03:23.280 --> 03:25.040]  и всё, что остается ей отлететь дальше.
[03:25.040 --> 03:26.920]  Этот код бесполезен уже полностью.
[03:26.920 --> 03:27.920]  Почему?
[03:27.920 --> 03:30.140]  Потому что, по сути, вы бросаете исключение, подбрасываете
[03:30.140 --> 03:33.200]  его вверх, ловите снова и дальше бросаете уже туда,
[03:33.200 --> 03:34.200]  куда надо.
[03:34.200 --> 03:37.800]  Такой код абсолютно точно является не Invest츠нным, would
[03:37.800 --> 03:40.000]  Если вы хотите бросить исключение, то просто его
[03:40.000 --> 03:41.000]  бросайте.
[03:41.000 --> 03:42.900]  Если вы не знаете, как обработать исключение или вам не
[03:42.900 --> 03:44.920]  нужно делать никаких дополнительных действий по обработке
[03:44.920 --> 03:48.440]  исключения, который потенциально может выбрать и другая функция, то не пишите
[03:48.440 --> 03:51.600]  никакого обработчика. То есть пусть исключение летит дальше, пусть его
[03:51.600 --> 03:54.960]  обрабатывает следующая функция, которая потенциально сможет это сделать.
[03:54.960 --> 04:01.080]  Окей? Хорошо. Ну давайте тогда перейдем
[04:01.080 --> 04:06.600]  к продолжению разговора про исключение. И сегодня у нас план примерно следующий.
[04:06.600 --> 04:11.080]  Ну вот мы в прошлый раз познакомились с таким базовыми основами обработки
[04:11.080 --> 04:14.480]  исключений, ну вообще работы с исключениями. Вот сегодня давайте поговорим про то,
[04:14.480 --> 04:18.880]  как исключения взаимодействуют с другими аспектами языка C++, ну в частности там с
[04:18.880 --> 04:22.200]  конструкторами, деструкторами, со стандартной билетекой. Ну и вообще говоря,
[04:22.200 --> 04:27.440]  вновь вернемся к вопросу, а вот каким образом нам жить вот в этом мире полным
[04:27.440 --> 04:31.000]  исключений. То есть как можно ли на что-то полагаться, можно ли полагаться на то,
[04:31.000 --> 04:34.960]  что что-то ошибок вызывать не будет, можно ли полагаться на то, что если ошибка
[04:34.960 --> 04:38.800]  вдруг возникла, то можно будет корректно продолжить работу и так далее.
[04:38.800 --> 04:43.000]  Начнем с исключения в конструкторах и деструкторах. Вот давайте посмотрим на
[04:43.000 --> 04:48.320]  следующий пример. У меня есть некоторый класс A, у которого есть два поля.
[04:48.320 --> 04:53.320]  Поле-вектор и поле-обычный указатель, который потенциально может указывать на
[04:53.320 --> 04:56.320]  динамическую область памяти. Ну и действительно смотрим на конструктор, в
[04:56.320 --> 05:00.280]  конструкторе у меня создается вектор из 100 элементов и выделяется динамическая
[05:00.280 --> 05:04.720]  память, которая сохраняется в указатель PTR. Ну и даже по какой-то причине в
[05:04.720 --> 05:07.440]  конструкторе мне нужно вызвать некоторую функцию, в которой потенциально можно
[05:07.440 --> 05:10.520]  бросить исключение. Ну не знаю, допустим она там по-своему как-то выделяет память,
[05:10.520 --> 05:15.080]  или допустим она открывает какое-то соединение по сети, но и соответственно
[05:15.080 --> 05:18.120]  понятное дело, что это может там закончиться, а потенциально это может
[05:18.120 --> 05:22.040]  закончиться неуспехом, что в итоге приведет к выбросу исключения. Вот.
[05:22.040 --> 05:24.440]  Ну деструктор при этом у меня написан корректно, то есть в деструкторе я просто
[05:24.440 --> 05:29.600]  насущаю ресурс, который выделил в конструкторе. Что тут может пойти не так? Как
[05:29.600 --> 05:45.440]  вы думаете? Ну да, действительно, смотрите. Действительно, я вызываю
[05:45.440 --> 05:48.560]  конструктор А. В конструкторе А происходит создание вектора, то есть у меня был
[05:48.560 --> 05:52.160]  создан вектор из 100 элементов, дальше я выделал память с помощью Нью Инс,
[05:52.160 --> 05:58.000]  сохранил ее в указатель PTR, дальше вызываю функцию F, и в общем произошло исключение.
[05:58.080 --> 06:02.520]  И тут возникает вопрос. С одной стороны, с одной стороны у меня есть нормально
[06:02.520 --> 06:06.320]  написанный деструктор, mars, он приведет, ну еслиager,
[06:06.320 --> 06:09.420]  в итоге будет, вызвание деструктор, все приведет к тому, что вектор будет
[06:09.420 --> 06:13.200]  уничтожен, и память будет очищена. Так у меня есть строчка deletePtr.
[06:13.440 --> 06:17.680]  С другой стороны, как будто бы деструктор у меня не завершил работу корректно.
[06:17.680 --> 06:20.760]  То есть я попытался вызвать деструктор..ой, конструктор, то есть я
[06:20.760 --> 06:26.780]  создал, попытался создать объект А, но вот коплавка его произошла некорректно,
[06:26.780 --> 06:28.780]  Вот если создание объекта А произошло некорректно,
[06:28.780 --> 06:30.780]  то могу ли я полагаться на то, что для объекта А
[06:30.780 --> 06:32.780]  будет вызван деструктор, или не могу?
[06:32.780 --> 06:34.780]  Вот как вы думаете? Представьте себе следующую ситуацию.
[06:34.780 --> 06:36.780]  Даже абстрагируясь вот этого примера,
[06:36.780 --> 06:38.780]  я решил создать какой-то объект.
[06:38.780 --> 06:40.780]  Объект типа А. Но по какой-то причине
[06:40.780 --> 06:42.780]  при создании объекта А
[06:42.780 --> 06:44.780]  произошла ошибка.
[06:44.780 --> 06:46.780]  Как вы думаете, имеет ли право компилятор
[06:48.780 --> 06:50.780]  вызвать деструктор для этого объекта?
[06:52.780 --> 06:54.780]  Нет. А почему?
[06:56.780 --> 06:58.780]  Угу.
[07:02.780 --> 07:04.780]  Да, смотрите. Если во время создания объекта А
[07:04.780 --> 07:06.780]  было вызвано исключение,
[07:06.780 --> 07:08.780]  то понятное дело, что, скорее всего,
[07:08.780 --> 07:10.780]  объект был создан не полностью.
[07:10.780 --> 07:12.780]  А если объект был создан не полностью,
[07:12.780 --> 07:14.780]  то, значит, возможно, у него как-то неправильно
[07:14.780 --> 07:16.780]  проницелизировано поля.
[07:16.780 --> 07:18.780]  То есть объект находится, возможно, в несогласованном состоянии.
[07:18.780 --> 07:20.780]  Но раз объект находится в несогласованном состоянии,
[07:20.780 --> 07:22.780]  то и деструктор для него вызывать некорректно.
[07:22.780 --> 07:24.780]  Почему? Потому что
[07:24.780 --> 07:26.780]  естественно деструктор полагает,
[07:26.780 --> 07:28.780]  то, что все поля у него созданы корректно,
[07:28.780 --> 07:30.780]  что вся память выделлена и так далее.
[07:30.780 --> 07:32.780]  Но если в конструкторе вызванное исключение,
[07:32.780 --> 07:34.780]  то не все поля могут быть корректным образом проницелизированы.
[07:34.780 --> 07:36.780]  Поэтому не все поля, а там нужно удалять
[07:36.780 --> 07:38.780]  ими таким образом, каким прописано в деструкторе.
[07:38.780 --> 07:40.780]  Согласны?
[07:40.780 --> 07:42.780]  Что делать?
[07:42.780 --> 07:44.780]  Решений. Да, соответственно, проблема
[07:44.780 --> 07:46.780]  что проект glam not move, то объект
[07:46.780 --> 07:48.780]  считается создан он, а раз объект не считается
[07:48.780 --> 07:50.780]  создан, то и для него
[07:50.780 --> 07:52.780]  деструктора вызвана не будет.
[07:52.780 --> 07:54.780]  Что делать?
[07:54.780 --> 07:56.780]  Потенциальным решением может стать
[07:56.780 --> 07:58.780]  использование try-catch блока.
[07:58.780 --> 08:00.780]  Если я понимаю, что функция f
[08:00.780 --> 08:02.780]  потенциально может бросить исключение,
[08:02.780 --> 08:04.780]  я могу просто функцию f заключить в блок try
[08:04.780 --> 08:06.780]  и дальше написать соответствующий блок catch,
[08:06.780 --> 08:08.780]  который ловит произвольные исключения.
[08:08.780 --> 08:10.780]  И в этом блоке catch,
[08:10.780 --> 08:12.780]  так как я понимаю, что создание a
[08:12.780 --> 08:14.780]  не может завершиться корректно,
[08:14.780 --> 08:16.780]  я просто уничтожаю ptr и бросаю исключение дальше.
[08:16.780 --> 08:18.780]  Обратите внимание, что
[08:18.780 --> 08:20.780]  для вектора
[08:20.780 --> 08:22.780]  для вектора мне деструктор вызывать
[08:22.780 --> 08:24.780]  не обязательно.
[08:24.780 --> 08:26.780]  Почему?
[08:26.780 --> 08:28.780]  Потому что если
[08:28.780 --> 08:30.780]  уже был создан какой-то объект, у которого уже есть
[08:30.780 --> 08:32.780]  деструктор, то есть, смотрите, в данном контексте
[08:32.780 --> 08:34.780]  у меня вектор уже создан корректно.
[08:34.780 --> 08:36.780]  То есть вектор – это уже существующий объект, который есть где-то в памяти.
[08:36.780 --> 08:38.780]  Поэтому
[08:38.780 --> 08:40.780]  для него деструктора вызывать явно не нужно,
[08:40.780 --> 08:42.780]  деструктор для него будет вызван автоматически.
[08:42.780 --> 08:44.780]  Все поля, которые уже были
[08:44.780 --> 08:46.780]  созданы, если эти поля являются полями классами,
[08:46.780 --> 08:48.780]  то для каждого из таких
[08:48.780 --> 08:50.780]  полей будет вызван корректно деструктор.
[08:50.780 --> 08:52.780]  В этом заключается еще одно преимущество
[08:52.780 --> 08:54.780]  использования RAI классов
[08:54.780 --> 08:56.780]  по сравнению с использованием обычных вторых указателей.
[08:56.780 --> 08:58.780]  Грубо говоря,
[08:58.780 --> 09:00.780]  если мы вместо динамического выделения массива
[09:00.780 --> 09:02.780]  или динамического выделения памяти используем вектор
[09:02.780 --> 09:04.780]  или используем умные указатели,
[09:04.780 --> 09:06.780]  unique ptr, char ptr, то
[09:06.780 --> 09:08.780]  за очищение отвечают именно эти классы,
[09:08.780 --> 09:10.780]  и нам об этом не нужно думать даже в контексте
[09:10.780 --> 09:12.780]  исключений.
[09:14.780 --> 09:16.780]  Соответственно, с вектором все будет нормально, объект вектора
[09:16.780 --> 09:18.780]  создан корректно, значит, для него корректно
[09:18.780 --> 09:20.780]  будет вызван деструктор.
[09:20.780 --> 09:22.780]  Ну и соответственно, пример.
[09:22.780 --> 09:24.780]  Правильнее всего данный
[09:24.780 --> 09:26.780]  класс был бы написать вот так,
[09:26.780 --> 09:28.780]  надо написать вектор, дальше
[09:28.780 --> 09:30.780]  написать unique ptr, который указывает лишь на единичный
[09:30.780 --> 09:32.780]  элемент int,
[09:32.780 --> 09:34.780]  ну и создать вектор из 100 элементов,
[09:34.780 --> 09:36.780]  создать указатель на
[09:36.780 --> 09:38.780]  нулевой элемент. Даже если f бросит
[09:38.780 --> 09:40.780]  исключение, то
[09:40.780 --> 09:42.780]  корректно вызовется деструктор
[09:42.780 --> 09:44.780]  для v, корректно вызовется деструктор для ptr,
[09:44.780 --> 09:46.780]  и кроме того, нам не нужно прописывать
[09:46.780 --> 09:48.780]  деструкторы, конструкторы, конструкторы
[09:48.780 --> 09:50.780]  копирования, конструкции перемещения, все будет
[09:50.780 --> 09:52.780]  создано автоматически.
[09:52.780 --> 09:54.780]  Вот, кстати, это является прекрасной демонстрацией
[09:54.780 --> 09:56.780]  правила нуля. То есть мы написали
[09:56.780 --> 09:58.780]  целиково полностью,
[09:58.780 --> 10:00.780]  которая зависит от
[10:00.780 --> 10:02.780]  классов, которые поддерживают идиом ураи,
[10:02.780 --> 10:04.780]  то есть на основе вектора, на основе unique ptr,
[10:04.780 --> 10:06.780]  и нам не пришлось писать ни конструкторов,
[10:06.780 --> 10:08.780]  ни деструкторов. И кроме того, нам
[10:08.780 --> 10:10.780]  практически не нужно задумывать об исключениях,
[10:10.780 --> 10:12.780]  почему? Потому что если вдруг исключение возникнет,
[10:12.780 --> 10:14.780]  то объекты корректно уничтожатся, ну согласно
[10:14.780 --> 10:16.780]  их вызовам деструкторов. Понятно?
[10:20.780 --> 10:22.780]  Так.
[10:22.780 --> 10:24.780]  Давайте посмотрим на другой
[10:24.780 --> 10:26.780]  пример. Ну хорошо, разобрали исключения
[10:26.780 --> 10:28.780]  в конструкторах. То есть если резюмировать исключения
[10:28.780 --> 10:30.780]  в конструкторах, ну если мы пишем,
[10:30.780 --> 10:32.780]  если мы все реализуем на
[10:32.780 --> 10:34.780]  самостоятельном выделении ресурсов,
[10:34.780 --> 10:36.780]  то нам необходимо помнить о проблеме
[10:36.780 --> 10:38.780]  вызова, точнее о проблеме
[10:38.780 --> 10:40.780]  возникновения исключения в конструкторах, и нам нужно
[10:40.780 --> 10:42.780]  в этой ситуации обрабатывать самостоятельно.
[10:42.780 --> 10:44.780]  Теперь представьте себе, что мы пишем
[10:44.780 --> 10:46.780]  деструктор.
[10:46.780 --> 10:48.780]  Как вы думаете, что
[10:48.780 --> 10:50.780]  произойдет, если
[10:50.780 --> 10:52.780]  в деструкторе в какой-то момент
[10:52.780 --> 10:54.780]  произойдет исключение?
[10:54.780 --> 10:56.780]  Ну вот представьте себе,
[10:56.780 --> 10:58.780]  что у меня есть тот же самый класс A,
[10:58.780 --> 11:00.780]  и класс A по какой-то причине
[11:00.780 --> 11:02.780]  вызывает, ну перед тем как освободить
[11:02.780 --> 11:04.780]  память, конструктор вызывает
[11:04.780 --> 11:06.780]  некоторую опасную функцию F.
[11:06.780 --> 11:08.780]  Ну я думаю, вы понимаете, что если
[11:08.780 --> 11:10.780]  конструктор завершится некорректно, то, соответственно,
[11:10.780 --> 11:12.780]  все те операции, которые следуют в конце,
[11:12.780 --> 11:14.780]  то есть по очистке памяти и так далее, они
[11:14.780 --> 11:16.780]  выполнены не будут, поэтому возникнет утечка памяти.
[11:16.780 --> 11:18.780]  Ну соответственно, по этой причине
[11:18.780 --> 11:20.780]  я вызов функции, помещаю второй catch block,
[11:20.780 --> 11:22.780]  вызываю delete, пробрасываю исключение дальше.
[11:24.780 --> 11:26.780]  Ну при этом, как и раньше, если у меня есть
[11:26.780 --> 11:28.780]  какие-то поля, которые относятся к объектам
[11:28.780 --> 11:30.780]  классом, то есть если у меня есть
[11:30.780 --> 11:32.780]  вектор, то для вектора деструктор будет вызван
[11:32.780 --> 11:34.780]  корректно, будет вызван автоматически, поэтому
[11:34.780 --> 11:36.780]  с ним ничего делать не нужно.
[11:36.780 --> 11:38.780]  Вот. Но вот с деструкторами,
[11:38.780 --> 11:40.780]  в контексте деструкторов,
[11:40.780 --> 11:42.780]  исключение приводит
[11:42.780 --> 11:44.780]  к еще одной
[11:44.780 --> 11:46.780]  не очень приятной и не очень очевидной проблеме.
[11:46.780 --> 11:48.780]  Давайте о ней поговорим.
[11:52.780 --> 11:54.780]  Дело в том, ну давайте
[11:54.780 --> 11:56.780]  посмотрим на пример и попробуем
[11:56.780 --> 11:58.780]  понять, а что тут вообще происходит. Вот признай
[11:58.780 --> 12:00.780]  себе, что у меня есть некоторая функция H,
[12:00.780 --> 12:02.780]  есть
[12:02.780 --> 12:04.780]  класс A, у которого
[12:04.780 --> 12:06.780]  потенциально опасный деструктор. Ну представьте
[12:06.780 --> 12:08.780]  себе, что класс A написан ровно так, как написано
[12:08.780 --> 12:10.780]  на предыдущем слайде. То есть у него есть деструктор,
[12:10.780 --> 12:12.780]  который потенциально может бросить исключение.
[12:12.780 --> 12:14.780]  Вот. Соответственно, я написал
[12:14.780 --> 12:16.780]  класс A, деструктор может бросить исключение
[12:16.780 --> 12:18.780]  и дальше, после того, как я создал
[12:18.780 --> 12:20.780]  A, вызываю функцию
[12:20.780 --> 12:22.780]  же, которая тоже может бросить исключение.
[12:22.780 --> 12:24.780]  Можете ли вы предложить сценарий,
[12:24.780 --> 12:26.780]  при котором
[12:26.780 --> 12:28.780]  произойдет большая проблема?
[12:34.780 --> 12:36.780]  Еще раз?
[12:40.780 --> 12:42.780]  Не поймем, где
[12:42.780 --> 12:44.780]  ошибка.
[12:48.780 --> 12:50.780]  Так, окей, да, ну
[12:50.780 --> 12:52.780]  есть такая проблема. Действительно, если мы
[12:52.780 --> 12:54.780]  вызываем функцию H, ну представьте себе,
[12:54.780 --> 12:56.780]  что мы вызываем функцию H,
[12:56.780 --> 12:58.780]  функцию H помещаем в
[12:58.780 --> 13:00.780]  try sketchBlock
[13:00.780 --> 13:02.780]  sketchBlock
[13:04.780 --> 13:06.780]  Вот.
[13:06.780 --> 13:08.780]  Потенциально мы не можем понять,
[13:08.780 --> 13:10.780]  а где возникла проблема.
[13:10.780 --> 13:12.780]  Есть объект A, есть вызов
[13:12.780 --> 13:14.780]  функции же, ну и тут
[13:14.780 --> 13:16.780]  какие-то еще
[13:16.780 --> 13:18.780]  операторы.
[13:18.780 --> 13:20.780]  Действительно,
[13:20.780 --> 13:22.780]  если мы неправильно пишем,
[13:22.780 --> 13:24.780]  если мы пишем код как-то не так, то
[13:24.780 --> 13:26.780]  в целом мы не можем понять, где у нас
[13:26.780 --> 13:28.780]  возникла ошибка. То есть ошибка возникла в классе A,
[13:28.780 --> 13:30.780]  ошибка возникла в классе G.
[13:30.780 --> 13:32.780]  В целом, если мы
[13:32.780 --> 13:34.780]  грамотно проектируем нашу программу,
[13:34.780 --> 13:36.780]  то мы все-таки для каждой ошибки пишем свой
[13:36.780 --> 13:38.780]  тип ошибки, свой класс ошибки.
[13:38.780 --> 13:40.780]  То есть те ошибки, которые
[13:40.780 --> 13:42.780]  бросает класс A, они относят
[13:42.780 --> 13:44.780]  к одному типу, те ошибки, которые бросает
[13:44.780 --> 13:46.780]  G, относятся к другому типу.
[13:46.780 --> 13:48.780]  В целом, с этой проблемой
[13:48.780 --> 13:50.780]  мы как-то победить можем.
[13:50.780 --> 13:52.780]  Надо, например, для каждого из типов ошибки
[13:52.780 --> 13:54.780]  завести свой собственный класс и, соответственно,
[13:54.780 --> 13:56.780]  ловить соответствующий класс в блоке catch.
[13:56.780 --> 13:58.780]  И мы можем проверять, какая последовательность
[13:58.780 --> 14:00.780]  вызовов привела к данной ошибке.
[14:00.780 --> 14:02.780]  Проблема есть, но на самом деле
[14:02.780 --> 14:04.780]  это не самое страшное, что может произойти.
[14:10.780 --> 14:12.780]  Давайте немного подскажу
[14:12.780 --> 14:14.780]  и скажу следующее.
[14:14.780 --> 14:16.780]  Проблема произойдет тогда,
[14:16.780 --> 14:18.780]  когда исключение будет
[14:18.780 --> 14:20.780]  бросаться из функции G.
[14:20.780 --> 14:22.780]  Давайте подумаем, что будет происходить,
[14:22.780 --> 14:24.780]  если вдруг в какой-то момент
[14:24.780 --> 14:26.780]  из функции G вылетело исключение.
[14:34.780 --> 14:36.780]  Да, смотрите, что произойдет.
[14:38.780 --> 14:40.780]  Из функции G вылетает исключение.
[14:40.780 --> 14:42.780]  То есть тут генерируется какое-то исключение.
[14:42.780 --> 14:44.780]  Что происходит, когда
[14:44.780 --> 14:46.780]  функция генерирует исключение?
[14:48.780 --> 14:50.780]  Функция совершает работу и
[14:50.780 --> 14:52.780]  вызываются деструкторы для всех элементов,
[14:52.780 --> 14:54.780]  которые находятся в этой функции.
[14:54.780 --> 14:56.780]  Согласны?
[14:56.780 --> 14:58.780]  То есть создание, точнее,
[14:58.780 --> 15:00.780]  генерация исключения здесь приводит к тому,
[15:00.780 --> 15:02.780]  что у меня будет вызван деструктор A.
[15:02.780 --> 15:04.780]  То есть генерируется исключение из G,
[15:06.780 --> 15:08.780]  потом
[15:10.780 --> 15:12.780]  вызывается
[15:12.780 --> 15:14.780]  деструктор A.
[15:14.780 --> 15:16.780]  А что произойдет дальше?
[15:16.780 --> 15:18.780]  Нет, ну а дальше
[15:18.780 --> 15:20.780]  как устроен деструктор A?
[15:20.780 --> 15:22.780]  Мы с вами сказали, что деструктор A
[15:22.780 --> 15:24.780]  потенциально может бросить исключение.
[15:24.780 --> 15:26.780]  Теперь на третьем шаге
[15:26.780 --> 15:28.780]  происходит
[15:34.780 --> 15:36.780]  исключение
[15:36.780 --> 15:38.780]  в деструкторе A.
[15:38.780 --> 15:40.780]  То есть теперь у меня двойная проблема.
[15:40.780 --> 15:42.780]  И G вылетело исключение,
[15:42.780 --> 15:44.780]  и при вызове деструктора A
[15:44.780 --> 15:46.780]  тоже вылетело исключение.
[15:46.780 --> 15:48.780]  То есть что получается?
[15:50.780 --> 15:52.780]  Получается, что из функции H
[15:52.780 --> 15:54.780]  вылетело сразу два исключения.
[15:54.780 --> 15:56.780]  Понятно?
[15:56.780 --> 15:58.780]  Одно из исключений появилось
[15:58.780 --> 16:00.780]  изначально, когда я вызывал функцию G,
[16:00.780 --> 16:02.780]  а второе исключение появилось как
[16:02.780 --> 16:04.780]  следствие вызова деструктора A.
[16:04.780 --> 16:06.780]  То есть вот вызвался деструктор A,
[16:06.780 --> 16:08.780]  допустим в функции F тоже что-то пошло не так,
[16:08.780 --> 16:10.780]  и соответственно вызвалось исключение.
[16:10.780 --> 16:12.780]  То есть возникла проблема
[16:12.780 --> 16:14.780]  двойного исключения,
[16:14.780 --> 16:16.780]  то есть функция завершилась,
[16:16.780 --> 16:18.780]  и при этом из этой функции вылетело два исключения.
[16:18.780 --> 16:20.780]  Значит,
[16:20.780 --> 16:22.780]  ну вот.
[16:22.780 --> 16:24.780]  То есть G бросает исключение, начинается раскручивание стека,
[16:24.780 --> 16:26.780]  вызывается диструктор для A,
[16:26.780 --> 16:28.780]  и в нем снова бросается исключение.
[16:28.780 --> 16:30.780]  В итоге из функции H
[16:30.780 --> 16:32.780]  вылетает сразу два исключения.
[16:32.780 --> 16:34.780]  По стандарту языка C++
[16:34.780 --> 16:36.780]  если из функции,
[16:36.780 --> 16:38.780]  если в функцию покидает сразу несколько исключений,
[16:38.780 --> 16:40.780]  то это приводит к
[16:40.780 --> 16:59.780]  то это приводит к неопределенному поведению. Это неопределенное поведение может возникнуть только в том случае, если у вас есть функция,
[16:59.780 --> 17:07.780]  внутри которой может возникнуть исключение, и при этом эта функция создает объекты, которые потенциально в деструкторе могут бросить исключение.
[17:07.780 --> 17:16.780]  То есть исключение в деструкторах потенциально приводит к неопределенному поведению в том смысле, что если вдруг деструктор был вызван в результате раскрутки стека,
[17:16.780 --> 17:22.780]  то в результате совершения какой-то другой ошибки, то к вызывающую функцию покинут сразу несколько исключений.
[17:22.780 --> 17:29.780]  Поэтому с исключением в деструкторах мы поступаем очень просто. Мы просто-напросто не допускаем исключений в деструкторах.
[17:30.780 --> 17:37.780]  Основное правило такое. Пишите деструктор так, чтобы из него не вылетало никаких исключений.
[17:37.780 --> 17:43.780]  Это золотой стандарт программирования на C++.
[17:43.780 --> 17:53.780]  То есть даже если деструктор потенциально вызывает какие-то опасные функции, то постарайтесь сделать все возможное, чтобы эти исключения никак не покидали сам деструктор.
[17:53.780 --> 18:01.780]  Либо обработайте исключения, либо напишите сообщение, что деструктор потенциально завершился неуспешно и так далее.
[18:01.780 --> 18:13.780]  У нас же должно быть только так, чтобы у нас одновременно не могли бросить два исключения, но это не гарантирует, что у нас и там, и там одновременно не брать.
[18:13.780 --> 18:23.780]  В плане, оно может броситься в А, но если мы так можем построить программу, то если оно бросилось в А, то оно дальше не бросится, и наоборот.
[18:23.780 --> 18:26.780]  То есть это как-бы излишне интересно.
[18:26.780 --> 18:36.780]  Я сейчас не совсем понял идею, то есть ваш предложение...
[18:36.780 --> 18:38.780]  Тут?
[18:54.780 --> 18:57.780]  Да, окей, я понял, о чем вы говорите, смотрите.
[18:57.780 --> 19:01.780]  Во-первых, деструктор А и функции G могут бросить разные исключения.
[19:01.780 --> 19:08.780]  То есть они могут сигнализировать о разных ошибках, ну и естественно хотелось бы, чтобы и первая и вторая ошибка в итоге дошли до конечного пользователя.
[19:08.780 --> 19:14.780]  Значит, так сделать нельзя просто потому, что C++ не поддерживает несколько летящих исключений из одной функции.
[19:14.780 --> 19:21.780]  То, про что вы говорите, на самом деле, оно более близко к истине о том, как это может быть устроено в C++.
[19:21.780 --> 19:24.780]  Давайте чуть подробнее расскажу.
[19:24.780 --> 19:29.780]  На самом деле, действительно, деструктор может быть более гибкий.
[19:29.780 --> 19:32.780]  Вот в каком смысле.
[19:32.780 --> 19:42.780]  В C++ есть специальная функция std.uncode.exceptions.
[19:45.780 --> 19:51.780]  Эта функция возвращает текущее количество с генерированных исключений.
[19:51.780 --> 19:55.780]  Грубо говоря, если у вас в данный момент в программе летит сразу три исключения.
[19:55.780 --> 19:58.780]  Во-первых, непонятно, как вы так написали программу.
[19:58.780 --> 20:00.780]  В общем, так или иначе.
[20:00.780 --> 20:03.780]  Допустим, в какой-то момент у вас летит три исключения.
[20:03.780 --> 20:06.780]  И в деструкторе А вы можете это проверить.
[20:06.780 --> 20:08.780]  Допустим, вы можете проверить.
[20:08.780 --> 20:19.780]  Если std.uncode.exceptions больше нуля,
[20:19.780 --> 20:22.780]  то в этом случае вы говорите, что генерировать исключения нельзя.
[20:22.780 --> 20:28.780]  Иначе, если никаких исключений в этот момент не сгенерированы, то можно бросить исключения.
[20:28.780 --> 20:31.780]  В целом, можно написать вот так.
[20:31.780 --> 20:36.780]  Сразу я говорю, что то, как я написал здесь, опять же, не очень корректно.
[20:36.780 --> 20:41.780]  То есть, я рекомендую зайти на страницу.
[20:41.780 --> 20:44.780]  Давайте еще раз напишу.
[20:51.780 --> 20:55.780]  Обратите внимание на последний символ exception.
[20:55.780 --> 20:59.780]  Потому что есть функция std.uncode.exceptions, а есть std.uncode.exceptions.
[20:59.780 --> 21:01.780]  Вот std.uncode.exceptions.
[21:01.780 --> 21:05.780]  Она сейчас, по-моему, задеприкечена C++, то есть ее использовать нельзя.
[21:05.780 --> 21:08.780]  Std.uncode.exceptions использовать можно и нужно.
[21:08.780 --> 21:12.780]  И пример того, как правильно использовать std.uncode.exceptions, там показан.
[21:12.780 --> 21:17.780]  Там может возникнуть ситуация, при которой вы вызываете функцию.
[21:17.780 --> 21:20.780]  Дальше в destructor destructor вызывает другую функцию,
[21:20.780 --> 21:23.780]  которая генерирует исключения. Дальше другая функция тоже генерирует исключения.
[21:23.780 --> 21:28.780]  В теории может быть такое, что из нескольких разных функций летит исключение.
[21:28.780 --> 21:32.780]  И поэтому получается, что исключений больше одного.
[21:32.780 --> 21:34.780]  Поэтому в destructor нужно проверять.
[21:34.780 --> 21:37.780]  Если destructor был вызван для функции, в которой уже сгенерируется исключение,
[21:37.780 --> 21:40.780]  то бросать исключения не нужно.
[21:40.780 --> 21:43.780]  Если destructor вызван в функции, которая на самом деле не сгенерирует исключения,
[21:43.780 --> 21:45.780]  то исключения бросать нужно.
[21:45.780 --> 21:48.780]  Как дополнительный материал, можете почитать.
[21:48.780 --> 21:52.780]  Но в целом рекомендации не бросать исключений вполне на практике достаточно.
[21:52.780 --> 22:02.780]  Нет. Перегрузки деструкторов в C++ нет. Деструктор всегда только один.
[22:13.780 --> 22:16.780]  Такого не работает.
[22:16.780 --> 22:20.780]  Но вы можете понять, происходит ли сейчас раскрутка стека или нет.
[22:20.780 --> 22:22.780]  Вы можете по этой функции.
[22:22.780 --> 22:26.780]  Если происходит раскрутка стека, то вы действуете одним способом.
[22:26.780 --> 22:28.780]  Если не происходит, то действуете другим способом.
[22:28.780 --> 22:33.780]  В теории вы можете написать clean1 и clean2.
[22:33.780 --> 22:38.780]  И вызвать ту или иную функцию в зависимости от того, по какому пути вы идете.
[22:38.780 --> 22:42.780]  Хорошо. В общем, исключение в деструкторах плохо.
[22:42.780 --> 22:44.780]  А исключение в конструкторах норм.
[22:44.780 --> 22:49.780]  Но там надо тоже думать о том, как правильно очистить память при необходимости.
[22:49.780 --> 22:51.780]  Хорошо.
[22:51.780 --> 22:56.780]  Ну вот, собственно, у меня есть замечание про это,
[22:56.780 --> 22:59.780]  что на самом деле в C++ можно так делать.
[22:59.780 --> 23:02.780]  Но об этом можно посчитать дополнительным образом.
[23:02.780 --> 23:05.780]  Так, есть ли вопросы?
[23:05.780 --> 23:08.780]  Окей, тогда следующий важный пункт,
[23:08.780 --> 23:11.780]  про который нужно обязательно поговорить в контексте исключений,
[23:11.780 --> 23:14.780]  это гарантия безопасности исключений.
[23:14.780 --> 23:17.780]  Давайте начнем.
[23:17.780 --> 23:24.780]  Вот, с прошлого раза, как мы стали изучать исключения,
[23:24.780 --> 23:27.780]  ну, как я уже сказал, мы стали изучать исключения,
[23:27.780 --> 23:30.780]  полный исключений, полный ошибок и так далее.
[23:30.780 --> 23:35.780]  И вообще говоря, в этом нестабильном мире хотелось бы хоть на что-то полагаться.
[23:35.780 --> 23:37.780]  Хотелось бы полагаться хоть на какие-то инварианты,
[23:37.780 --> 23:39.780]  которые сохраняются даже если код написан,
[23:39.780 --> 23:41.780]  ну, не то что с ошибками,
[23:41.780 --> 23:45.780]  даже если в коде возникают какие-то непредвиденные обстоятельства.
[23:45.780 --> 23:49.780]  И поэтому для того, чтобы формализовать понятие о безопасном коде,
[23:49.780 --> 23:52.780]  формируем, например, код.
[23:52.780 --> 23:53.780]  Вот.
[23:53.780 --> 23:57.780]  И поэтому для того, чтобы формализовать понятие о безопасном коде,
[23:57.780 --> 24:00.780]  формализовать понятие о том, на что можно полагаться,
[24:00.780 --> 24:02.780]  на что нельзя полагаться,
[24:02.780 --> 24:06.780]  есть такие понятия как гарантии безопасности исключений.
[24:06.780 --> 24:08.780]  Причем, таких гарантий существует три.
[24:08.780 --> 24:11.780]  И давайте про них, про каждую поговорим отдельно.
[24:11.780 --> 24:13.780]  Всего гарантии три.
[24:13.780 --> 24:15.780]  Первая из них это гарантия отсутствия исключений,
[24:15.780 --> 24:18.780]  в смысле, самая простая с точки зрения понимания,
[24:18.780 --> 24:21.780]  ну, и самая сложная с точки зрения оформления.
[24:21.780 --> 24:23.780]  Дальше есть базовая гарантия безопасности,
[24:23.780 --> 24:25.780]  есть строгая гарантия безопасности.
[24:25.780 --> 24:28.780]  Давайте про каждую из них отдельно поговорим.
[24:28.780 --> 24:30.780]  Ну, гарантия отсутствия исключений самая простая,
[24:30.780 --> 24:32.780]  для понимания опять же, потому что
[24:32.780 --> 24:34.780]  гарантия отсутствия исключений говорит том,
[24:34.780 --> 24:37.780]  что вызов данной функции или вызов данной операции
[24:37.780 --> 24:39.780]  не приводит к генерации исключений.
[24:39.780 --> 24:40.780]  Окей?
[24:40.780 --> 24:43.780]  То есть, если вы читаете, ну, в общем, для чего это нужно,
[24:43.780 --> 24:46.780]  то есть вы, например, читаете документацию по языку C++,
[24:46.780 --> 24:49.780]  ну, допустим, вот заходите в какую, допустим, на страницу vector,
[24:49.780 --> 24:51.780]  и смотрите его отдельные операции.
[24:51.780 --> 24:55.780]  На каждой странице, если вы обратите внимание, есть несколько пунктов.
[24:55.780 --> 24:58.780]  Первая – это как вызывается функция, вторая – что она возвращает.
[24:58.780 --> 25:03.780]  Дальше комплексити, то есть какова сложность данной операции.
[25:03.780 --> 25:06.780]  Плюс дополнительно есть еще такой подраздел как exception safety,
[25:06.780 --> 25:09.780]  то есть безопасность относительно исключений.
[25:09.780 --> 25:11.780]  Одна из гарантий безопасности, которую вы можете встретить,
[25:11.780 --> 25:13.780]  это гарантия отсутствия исключений.
[25:13.780 --> 25:15.780]  Гарантия отсутствия исключений, еще раз повторю,
[25:15.780 --> 25:18.780]  это гарантия, что данная операция никогда не приводит к выбросу исключения.
[25:18.780 --> 25:20.780]  То есть данная операция всегда завершается корректно,
[25:20.780 --> 25:25.780]  на данную операцию, вы можете полагать, она всегда работает как часы.
[25:25.780 --> 25:31.780]  Например, операция стека, точнее, операция запроса размеров в стеке,
[25:31.780 --> 25:33.780]  она всегда завершается корректно. Почему?
[25:33.780 --> 25:35.780]  Потому что это просто операция доступа к полю.
[25:35.780 --> 25:38.780]  То есть она просто возвращает значение поля size,
[25:38.780 --> 25:42.780]  и, естественно, она никогда не приводит к ошибке.
[25:42.780 --> 25:46.780]  В то же время, операция копирования, то есть в то же время конструктор копирования,
[25:46.780 --> 25:48.780]  естественно, не может вам дать гарантию отсутствия исключений.
[25:48.780 --> 25:50.780]  Почему? Потому что копирование стека,
[25:50.780 --> 25:56.780]  оно обязательно приводит к тому, что вы перевыделяете память для нового стека,
[25:56.780 --> 25:59.780]  а выделение памяти – это уже как минимум повод задумываться над тем,
[25:59.780 --> 26:02.780]  что операция потенциально может завершиться неуспешно.
[26:02.780 --> 26:04.780]  Понятно? Окей.
[26:06.780 --> 26:09.780]  Дальше. Базовая гарантия безопасности.
[26:09.780 --> 26:11.780]  Что такое базовая гарантия безопасности?
[26:11.780 --> 26:15.780]  Функция удовлетворяет базовой гарантии безопасности, если происходит следующее.
[26:15.780 --> 26:21.780]  То есть вы вызываете операцию, и при этом, если операция представляет вам базовую гарантию безопасности,
[26:21.780 --> 26:24.780]  она не гарантирует, что данная операция всегда завершится успешно.
[26:24.780 --> 26:28.780]  Нет, иногда данная операция может завершиться неуспешно, в том смысле, что она может бросить исключение.
[26:28.780 --> 26:31.780]  Но базовая гарантия безопасности гарантирует следующее,
[26:31.780 --> 26:34.780]  что если из операции вылетело исключение,
[26:34.780 --> 26:38.780]  и при этом вы это исключение обработаете,
[26:38.780 --> 26:40.780]  то вы можете дальше корректно пользоваться программой.
[26:40.780 --> 26:44.780]  Дальше корректно пользоваться программой означает,
[26:44.780 --> 26:48.820]  структура данных осталась в корректном состоянии, то есть как бы программа тоже
[26:48.820 --> 26:51.740]  осталась в корректном состоянии, то есть у вас нет ни утечек памяти, ничего такого,
[26:51.740 --> 26:55.980]  но при этом в каком состоянии оказалась структура данных, вы сказать не можете.
[26:55.980 --> 27:05.980]  Ну то есть, например, у вас есть какой-то класс A, и у класса A, точнее у объекта класса A,
[27:05.980 --> 27:10.780]  вы вызываете метод f. Вот метод f, который потенциально бросает исключение.
[27:11.780 --> 27:16.780]  Вот функция f обладает базовой гарантией безопасности, если после обработки этого исключения
[27:20.780 --> 27:25.780]  вы можете дальше корректно пользоваться программой, вы можете дальше корректно пользоваться объектом A,
[27:25.780 --> 27:30.780]  но при этом в каком состоянии окажется A после вызова функции f, мы сказать достоверно не можем.
[27:30.780 --> 27:34.780]  Понятно? То есть A находится в каком-то корректном состоянии, но в корректном состоянии
[27:34.780 --> 27:38.780]  значит, что у него соблюдаются варианты класса. Ну какие варианты класса могут быть?
[27:38.780 --> 27:43.780]  Например, если мы работаем с вектором, то варианты класса – это size меньше чем capacity,
[27:43.780 --> 27:50.780]  и при этом capacity содержит как раз количество выделенной памяти, а size содержит количество элементов,
[27:50.780 --> 27:54.780]  которые реально находятся в векторе. Окей? То есть объект находится в согласовом состоянии,
[27:54.780 --> 27:59.780]  то есть там все корректно, и может корректно продолжать пользоваться, никаких утечек памяти не произошло,
[27:59.780 --> 28:03.780]  но в каком состоянии оказался, мы сказать не можем. Ну, например, если бы вектор, представьте,
[28:03.780 --> 28:09.780]  у меня есть вектор, у него, допустим, изначально размер равен 10, а capacity равен 20.
[28:09.780 --> 28:19.780]  Вот, я вызвал v.pushback, вот, и если бы pushback обладал только базовые гарантии безопасности,
[28:19.780 --> 28:23.780]  то мы бы сказали следующее, что я могу дальше продолжить пользоваться вектором,
[28:23.780 --> 28:26.780]  то есть дальше делать в него pushback, делать size и так далее.
[28:26.780 --> 28:28.780]  Да, ну представьте, что тут вылетело исключение.
[28:28.780 --> 28:32.780]  Но при этом сказать, какой у него в данный момент размер, или сказать,
[28:32.780 --> 28:38.780]  какой у него в данный момент capacity, я не могу. Окей? Нормально?
[28:38.780 --> 28:44.780]  Вот, это базовая гарантия безопасности. То есть программой можно дальше пользоваться,
[28:44.780 --> 28:47.780]  программа может дальше работать, но вот перед тем, как дальше работать, нужно проверить,
[28:47.780 --> 28:51.780]  что же там на самом деле происходит, то есть какой размер вектора, какой там capacity,
[28:51.780 --> 28:55.780]  какие там элементы векторе сохранили, то есть может какие-то элементы были удалены,
[28:55.780 --> 29:00.780]  или может какие-то элементы были добавлены все-таки. Окей? Хорошо.
[29:00.780 --> 29:05.780]  Ну и, наконец, строгая гарантия безопасности говорит про следующее.
[29:05.780 --> 29:09.780]  Вот если тут, я не мог сказать, то есть я мог сказать лишь то,
[29:09.780 --> 29:12.780]  что вектор можно корректно пользоваться, то есть никаких техник данных не произошло,
[29:12.780 --> 29:16.780]  то вот тут, в случае строгой гарантии безопасности, я могу точно сказать,
[29:16.780 --> 29:21.780]  что если операция завершилась неуспешно, то вектор находится ровно в том же состоянии,
[29:21.780 --> 29:25.780]  что и до вызова этого метода. То есть тут я могу с точной уверенностью сказать,
[29:25.780 --> 29:30.780]  что тут size по-прежнему равен 10, capacity по-прежнему равен 20, ну и, точнее так, давайте так скажем,
[29:30.780 --> 29:37.780]  что вот этот вектор в точности совпадает с вот этим вот вектором. Окей?
[29:37.780 --> 29:42.780]  То есть строгой гарантией безопасности, это по сути то же самое, что и базовая гарантия безопасности,
[29:42.780 --> 29:47.780]  то есть программой можно продолжить корректно пользоваться, но при этом дополнительно
[29:47.780 --> 29:52.780]  строгая гарантия безопасности говорит в том, что система находится ровно в том же состоянии,
[29:52.780 --> 29:57.780]  что и до вызова проблемного метода или что до вызова проблемной операции, понятно?
[29:57.780 --> 30:01.780]  То есть ну грубо говоря, строгая гарантия безопасности говорит в том, что грубо говоря,
[30:01.780 --> 30:05.780]  операция происходит атомарно, то есть она происходит либо полностью, то есть происходит изменение
[30:05.780 --> 30:08.780]  корректно, либо операция как будто бы не происходила вообще.
[30:09.780 --> 30:11.780]  Вот.
[30:11.780 --> 30:20.660]  так ну и давайте я предлагаю посмотреть на примеры и
[30:20.660 --> 30:26.780]  обсудить какой код является безопасным кой код безопасным не является ну
[30:26.780 --> 30:34.140]  давайте посмотрим все на примере вектора да давайте предлагаю посмотреть на
[30:34.140 --> 30:39.860]  примере вектора и обсудить реализацию
[30:40.460 --> 30:46.380]  операции при свавене. Сразу скажу, что
[30:46.380 --> 30:50.060]  операция при свавене реализована с некоторыми допущениями, с некоторыми
[30:50.060 --> 30:54.220]  ошибками, которые нельзя просто взять и перенести в домашнюю, но концепции
[30:54.220 --> 30:59.620]  связанные с ограничением безопасности мы обсудим. Значит, давайте для начала
[30:59.620 --> 31:06.900]  посмотрим на гарантию отсутствия исключений.
[31:06.900 --> 31:10.220]  Допустим, я пишу вектор, у вектора естественно есть указатель на выделенные данные, у
[31:10.220 --> 31:15.260]  вектора есть размер, то есть количество элементов, которые реально хранится в векторе,
[31:15.260 --> 31:18.500]  ну и плюс капасти от количества реальных выделенных ячеек памяти
[31:18.500 --> 31:23.660]  для хранения элементов. Какие операции могут похвастаться строгой гарантией
[31:23.660 --> 31:27.780]  безопасности? Строгой гарантией, простите, гарантией отсутствия исключений.
[31:27.780 --> 31:30.820]  Гарантия отсутствия исключений могут похвастаться методы, такие методы, как, например, свап.
[31:30.820 --> 31:33.980]  Ну, я думаю, вы понимаете, что при вызове метода свап ничего плохого не
[31:33.980 --> 31:39.260]  происходит. Почему? Потому что свап просто-напросто меняет местами
[31:39.260 --> 31:43.740]  чиселки сайса capacity и меняет местами указатель на буфер.
[31:43.740 --> 31:45.740]  Да.
[31:45.740 --> 31:49.740]  Слаб у нас перелезен на перемещающие присваивания.
[31:49.740 --> 31:56.740]  Здесь, например, есть сычевый клад, который написан без noexcept, перемещающий присваивания.
[31:56.740 --> 31:58.740]  Но это саб, получается, теряется в гаранде.
[31:58.740 --> 32:02.740]  Это да, про noexcept в перемещающих методах мы поговорим.
[32:02.740 --> 32:05.740]  Вот, смотрите, тут никаких проблем не будет.
[32:05.740 --> 32:10.740]  Почему? Потому что size – это число, capacity – это число, указатель – это число.
[32:10.740 --> 32:14.740]  При обмене двух чисел и при обмене двух указателей ничего плохого не происходит.
[32:14.740 --> 32:19.740]  Поэтому вот этот вот саб абсолютно безопасен с точки зрения исключений.
[32:19.740 --> 32:20.740]  Согласны?
[32:20.740 --> 32:21.740]  Окей.
[32:21.740 --> 32:24.740]  Теперь давайте посмотрим на операцию перемещающего присваивания.
[32:24.740 --> 32:27.740]  Операция перемещающего присваивания тоже абсолютно безопасна.
[32:27.740 --> 32:29.740]  По крайней мере, вот эта вот реализация абсолютно безопасна.
[32:29.740 --> 32:30.740]  По какой причине?
[32:30.740 --> 32:31.740]  Смотрите.
[32:31.740 --> 32:34.740]  Ну, понятное дело, тут я проверяю на самом присваивании.
[32:34.740 --> 32:36.740]  Дальше 22 строчки я вызываю delete-буфер.
[32:36.740 --> 32:40.740]  Давайте обсудим, может ли delete-буфер привести потенциально к проблемам.
[32:40.740 --> 32:42.740]  Ну, смотрите, вообще говоря, сама по себе очистка памяти,
[32:42.740 --> 32:45.740]  то есть вызов, точнее возврат памяти операционной системы, он безопасен.
[32:45.740 --> 32:48.740]  То есть гарантируется, что там никаких проблем не возникнет.
[32:48.740 --> 32:51.740]  Но вот что еще на самом деле вызывает delete?
[32:51.740 --> 32:53.740]  Да, delete вызывает деструкторы.
[32:53.740 --> 32:56.740]  А как мы с вами говорили, деструкторы, они потенциально тоже могут бросить исключения.
[32:56.740 --> 32:57.740]  Это совсем плохо.
[32:57.740 --> 33:00.740]  И, соответственно, первое допущение, которое мы тут делаем,
[33:00.740 --> 33:04.740]  и вообще допущение, которое делается практически во всех классах стандартной библиотеки,
[33:04.740 --> 33:08.740]  то, что деструкторы не вызывают исключений, окей?
[33:08.740 --> 33:12.740]  То есть мы автоматически предполагаем, что деструкторы всегда завершаются корректно.
[33:12.740 --> 33:14.740]  Поэтому если мы предполагаем, что деструктор завершается корректно.
[33:14.740 --> 33:17.740]  Кстати, я про это не сказал, ну, кажется, это было на слайдах.
[33:17.740 --> 33:22.740]  Вот именно по той причине, что вызывать исключения в диструкторах плохо,
[33:22.740 --> 33:24.740]  Все диструкторы по умолчанию всегда помечены noexcept.
[33:24.740 --> 33:25.740]  Окей?
[33:25.740 --> 33:28.740]  То есть даже если вы для диструктора не писали noexcept,
[33:28.740 --> 33:30.740]  считается, что деструктор помечен noexcept.
[33:30.740 --> 33:33.740]  Поэтому можем считать, что 22 строчка тоже завершится корректно.
[33:33.740 --> 33:37.020]  корректно, никаких проблем не будет. Ну а дальше, по сути, я тут использую
[33:37.020 --> 33:41.420]  операцию Exchange, напомню, как работает Exchange. Exchange берет первый аргумент,
[33:41.420 --> 33:47.460]  точнее, эта функция берет второй аргумент, записывает первый аргумент, а старое
[33:47.460 --> 33:50.140]  значение первого аргумента возвращает в качестве результата. То есть, грубо
[33:50.140 --> 33:57.140]  говоря, давайте еще раз интуитивно напомним, как работает Exchange.
[33:57.140 --> 34:07.140]  Exchange x и y работает так. r записывается в x, а x записывается в z.
[34:07.140 --> 34:14.140]  Ну и так как Exchange просто реализован на обменах между,
[34:14.140 --> 34:17.660]  по крайней мере, данный Exchange реализован чисто на обменах целых чисел и указателей, то
[34:17.660 --> 34:20.260]  естественно, никаких проблем тут не возникнет. То есть, абсолютно, полностью
[34:20.260 --> 34:23.860]  корректно и безопасно написанная перемещающая пресваивание.
[34:23.860 --> 34:29.740]  Давайте посмотрим на более осмысленные примеры и посмотрим на
[34:29.740 --> 34:33.500]  операцию копирующего пресваивания. Операция копирующего пресваивания
[34:33.500 --> 34:36.900]  принимает другой вектор, я тут проверяю на смысл пресваивания и дальше
[34:36.900 --> 34:40.380]  делаю следующее. Ну, казалось бы, с алкогерпинской точки зрения, все написано
[34:40.380 --> 34:44.740]  корректно. Сначала я копирую размер, потом я в capacity записываю тоже другой
[34:44.740 --> 34:52.980]  размер. Дальше что я делаю? Дальше я удаляю старые данные, выделяю память для
[34:52.980 --> 34:58.100]  новых данных и дальше в цикле копирую данные из другого массива в свой
[34:58.100 --> 35:02.220]  массив. Ну, тут я опускаю момент то, что на самом деле вектор, он использует
[35:02.220 --> 35:07.300]  не пресваивание, использует размещающий new. В общем, это давайте оставим за скобками.
[35:07.300 --> 35:12.260]  Давайте посмотрим на то, безопасен ли этот код с хоть какой-то точки зрения.
[35:12.260 --> 35:15.420]  То есть, обладает ли он гарантией отсутствия исключения, обладает ли он
[35:15.420 --> 35:19.020]  гарантии базовой гарантии исключения и отсутствия базовой гарантии
[35:19.020 --> 35:23.780]  безопасности исключения или строк гарантии безопасности. Какие есть предложения?
[35:23.780 --> 35:35.420]  Давайте вообще в принципе просмотрим этот код полностью и посмотрим на те
[35:35.420 --> 35:38.420]  моменты, которые потенциально могут бросить исключения. Давайте начнем с первой
[35:38.420 --> 35:41.740]  строчки. Понятно дело, что тут просто происходит
[35:41.740 --> 35:44.660]  присваивание целых чисел. При присваивании целых чисел ничего плохого
[35:44.660 --> 35:47.460]  произойти не может. То есть, это примитивный тип, с примитивным типом ничего плохого не
[35:47.460 --> 35:52.260]  происходит. Дальше тут вызывается дилит, точнее вызывается очистка памяти, ну и плюс
[35:52.260 --> 35:55.260]  вызов деструкторов. Как мы с вами обсудили вызов деструкторов, ну мы предполагаем,
[35:55.260 --> 36:01.500]  что вызов деструкторов ни к чему плохого не приведет. Дальше, вот в 39 строчке.
[36:01.500 --> 36:04.500]  Действительно, как правильно отметили, в 39 строчке потенциально может возникнуть
[36:04.500 --> 36:08.780]  проблема bed-lock. То есть, мы тут выделяем память, памяти может не хватить, new может
[36:08.780 --> 36:13.100]  бросить исключения. Какая еще на самом деле проблема существует в 309 строчке?
[36:13.100 --> 36:18.380]  Да, смотрите, new помимо того, что выделяет память, еще приводит к тому, что
[36:18.380 --> 36:23.580]  вызывают конструкторы. То есть, тут вызывается capacity раз конструктор
[36:23.580 --> 36:28.420]  по умолчанию. Я же не знаю, чем на самом деле является тип T, согласны?
[36:28.420 --> 36:32.700]  Поэтому тип T, точнее конструктор по умолчанию для T, теоретически может тоже
[36:32.700 --> 36:36.340]  бросить исключение. Вот, поэтому в 39 строчке исключение может возникнуть по
[36:36.340 --> 36:39.340]  двум причинам. Первое не хватает памяти, второе исключение возникло в
[36:39.340 --> 36:44.500]  конструкторе по умолчанию. Согласны? Хорошо. Давайте дальше. Цикл тут понятно, тут
[36:44.500 --> 36:50.900]  ничего плохого не происходит, а внутри цикла в 41 строчке. Да, тут уже вызывается
[36:50.900 --> 36:55.940]  операция присваивания для типа T. Опять же, я не знаю, как
[36:55.940 --> 36:59.860]  устроен тип T, я поэтому не могу гарантировать вам, что для типа T
[36:59.860 --> 37:03.540]  операция присваивания будет работать безопасно. Поэтому операция
[37:03.540 --> 37:07.140]  присваивания, чисто в теории, может привести к проблемам, может привести к
[37:07.140 --> 37:10.900]  ошибкам. Вот, я нашел сразу три места, где потенциально можно бросить
[37:10.900 --> 37:14.900]  исключение. То есть данная функция не является, не предоставляет гарантию
[37:14.900 --> 37:19.180]  отсутствия исключений совсем. Ну, может быть, она предоставляет базовую
[37:19.180 --> 37:23.420]  гарантию безопасности или строгую гарантию безопасности, как вы думаете? То есть, окей, я
[37:23.420 --> 37:26.820]  понял, что функция потенциально бросает исключение. Вот, ну, если функция бросает
[37:26.820 --> 37:30.060]  исключение, то еще есть шанс, что она предоставит мне, ну там, не знаю, строгую гарантию
[37:30.060 --> 37:33.380]  безопасности, да, то что исключение возникнет, но при этом вектор останется в том
[37:33.380 --> 37:38.940]  же самом состоянии, что и до вызова операции присваивания. Верно это или нет?
[37:38.940 --> 37:41.940]  Почему?
[37:44.220 --> 37:48.260]  Во, да, смотрите, эта функция не предоставляет мне строгой гарантии
[37:48.260 --> 37:53.580]  безопасности. Почему? Потому что я тут в 38-ой строчке очистил массив, то есть
[37:53.580 --> 37:57.620]  очистил память, которую хранит в себе вектор, а потом в 39-ой строчке у меня
[37:57.620 --> 38:00.900]  потенциально бросается исключение. Вот, представьте себе, что в 39-ой строчке вылетело
[38:00.900 --> 38:06.060]  исключение, и что произошло? У меня вектор очистил свою память и при этом
[38:06.060 --> 38:10.780]  возникло исключение, то есть пользователь после обработки своего исключения в
[38:10.780 --> 38:16.700]  операции присваивания, он получит вектор, у которого вообще нет памяти, да, понятно?
[38:16.700 --> 38:20.700]  Поэтому, ну, понятное дело, что вектор с памятью и вектор без памяти, два
[38:20.700 --> 38:24.340]  абсолютно разных вектора, вот, поэтому строгой гарантии точно нет. А базовая
[38:24.340 --> 38:45.820]  гарантия есть? А где тут зануление? Так, ничего, есть базовая гарантия или нет?
[38:45.820 --> 38:57.260]  Почему? Да, смотрите, на самом деле эта реализация не предоставляет даже базовой
[38:57.260 --> 39:01.100]  гарантии безопасности. Почему? Потому что тут вектор, ну, вот, если в 39-ой
[39:01.100 --> 39:04.860]  строчке возникло исключение, то вектор просто нагло врет о своем состоянии.
[39:04.860 --> 39:11.980]  Ну вот, представьте себе, что у меня был вектор, у которого там был какой-то
[39:11.980 --> 39:17.540]  size и был какой-то capacity. Вот, дальше я сказал, что вектор равен, там, допустим,
[39:17.540 --> 39:26.820]  вектору из ста элементов. Вот, что произошло? Я выставил size равной сотне,
[39:26.820 --> 39:32.620]  capacity равной сотне, дальше в 38-ой строчке очистил буфер,
[39:32.620 --> 39:37.260]  удалил память, а дальше у меня возникло исключение. Ну, допустим, я это исключение
[39:37.260 --> 39:41.260]  как-то тут обработал, и дальше продолжаю пользоваться вектором. Что произошло?
[39:41.260 --> 39:47.460]  Вектор говорит, а у меня размер 100 и вместимость 100, а на самом деле ничего нет.
[39:47.460 --> 39:53.260]  Понятно? Ну, вектор находится не в корректном состоянии, он врет, он говорит, что у меня
[39:53.260 --> 39:56.260]  capacity 100, а на самом деле у него вообще ничего не выделено, на самом деле вообще нет памяти,
[39:56.260 --> 40:06.140]  потому что мы для него вызвали delete. Понятно? Да? Ну, смотрите,
[40:06.140 --> 40:11.060]  буфер равно newT, как работает, сначала вызывается new, потом результат вызван
[40:11.060 --> 40:15.260]  new, записывается в буфер. Если new вызвал исключение, то присваивание, естественно,
[40:15.260 --> 40:21.340]  произойдет. То есть в буфере останется старое значение, то есть буфер будет указывать на уже
[40:21.340 --> 40:32.900]  удаленные данные. Понятно? Давайте попробуем как-то переписать код, так чтобы этот код
[40:32.900 --> 40:37.500]  удовлетворял хотя бы, ну, смотрите, вообще такой код он не очень хорош, почему? Потому что он
[40:37.500 --> 40:42.900]  не удовлетворяет ни одной из гарантий безопасности, он вообще не безопасен, то есть как бы и он исключение
[40:42.900 --> 40:46.700]  допускает, и если исключение произошло, то вообще все, как бы вектором пользоваться нельзя, он вообще
[40:46.700 --> 40:51.220]  не корректен, ну, вообще непонятно, как что с этим вектором делать. Давайте попробуем реализовать хотя
[40:51.220 --> 40:57.340]  бы базовую гарантию безопасности. Я утверждаю, что вот этот код обладает базовой гарантией
[40:57.340 --> 41:10.620]  безопасности. Давайте посмотрим на него и осознаем почему. Давайте прокомментируем,
[41:10.620 --> 41:17.380]  что тут происходит. В этой версии операции присваивания я сначала удаляю буфер, потом в буфер
[41:17.380 --> 41:23.860]  записываю nullptr, в size и capacity тоже записываю по нулям, а дальше выделяю память и записываю
[41:23.860 --> 41:31.060]  в буфер. Смотрите, что тут происходит. Допустим, тут в 58-ой строчке при вызове new, либо по причине
[41:31.060 --> 41:34.620]  того, что конструктор умолчания бросил исключение, либо по причине того, что new бросил исключение,
[41:34.620 --> 41:39.180]  ну так или иначе у меня возникло 58-ой строчка исключения. Что в итоге произойдет? В каком состоянии
[41:39.180 --> 41:48.220]  будет вектор? Да, смотрите, если тут произошла ошибка, то у меня вектор окажется в следующем
[41:48.220 --> 41:54.740]  состоянии. Size у него будет равен нулю, capacity у него будет равен нулю, а сам указатель буфер
[41:54.740 --> 42:04.180]  будет указывать на null. То есть у меня вектор окажется в полностью согласованном состоянии.
[42:04.180 --> 42:08.780]  То есть у него размер равен нулю, вместимость равна нулю, то есть никакая память не выделена,
[42:08.780 --> 42:12.780]  и память действительно никуда не указывает, то есть она указывает в нулевую позицию. Понятно?
[42:12.780 --> 42:18.180]  Вот. То есть изначально у меня был какой-то вектор, так как операция прислания завершилась
[42:18.180 --> 42:23.620]  неуспешно, то вектор оказался в каком-то валидном состоянии, но не в таком как раньше. А это ровно и
[42:23.620 --> 42:28.820]  есть определение базовой гарантии безопасности. Понятно? То есть вектор оказался в каком-то
[42:28.820 --> 42:33.180]  хорошем в том смысле, что согласованном состоянии, но при этом не в том же состоянии, что и раньше.
[42:33.180 --> 42:45.100]  Нормально? Давайте попробуем допилить этот код и сделать из кода, который гарантирует,
[42:45.100 --> 42:48.380]  который дает базовую гарантию безопасности, код, который дает строгую гарантию безопасности.
[42:48.380 --> 43:01.540]  Вот он. Я утверждаю, что данный код обладает строгой гарантией безопасности. Снова давайте
[43:01.540 --> 43:12.420]  дам время посмотреть, обдумать и потом прокомментирую. Да. Я сравниваю не два вектора,
[43:12.420 --> 43:18.380]  я сравниваю указатели. Сравнение указателей корректно. Именно поэтому проверка на самопредсвоение
[43:18.380 --> 43:25.220]  реализована так. Потому что сравнение векторов может быть во-первых долгим, а во-вторых опасно
[43:25.220 --> 43:37.660]  быть на самом деле, вряд ли может, но все равно. Что тут происходит? Давайте разбираться. Смотрите,
[43:37.660 --> 43:45.580]  первым делом я выделяю память для хранения новых данных, то есть new buffer. Смотрите,
[43:45.580 --> 43:52.300]  если с этой операции что-то пошло не так, то, ну как бы и ладно, из-за присваивания вылетело
[43:52.300 --> 43:57.460]  исключение, у меня вектор остался ровно в том же состоянии. Потому что до 72 строчки я вектор
[43:57.460 --> 44:04.060]  вообще никак не менял. Понятно? Раз я вектор вообще никак не менял, то соответственно и вектор окажется
[44:04.060 --> 44:10.140]  в том же состоянии, что и до вызова операции присваивания. Дальше. Давайте я пока уберу вот
[44:10.140 --> 44:19.500]  этот вот try-catch и посмотрим на вот этот вот цикл. Смотрите, если я с этим циклом ничего делать не
[44:19.500 --> 44:38.220]  буду, то что может произойти? Какая неприятная история? Да, смотрите, тут возможность следующей
[44:38.220 --> 44:42.900]  неприятности. Понятное дело, что тут используется операция присваивания. Но операция присваивания,
[44:42.900 --> 44:45.900]  так как я использую операцию присваивания для какого-то типа T, но про этот тип T, естественно,
[44:45.900 --> 44:49.420]  заранее я ничего не знаю. Поэтому операция присваивания для типа T потенциально может
[44:49.420 --> 44:55.860]  просить исключение. И вот если тут возникнет исключение, то будет проблема связанная с тем,
[44:55.860 --> 45:02.700]  что исключение вылетит, но при этом я же уже выделил память для нового буфера. И эта память у меня
[45:02.700 --> 45:12.660]  утечет. Чтобы избежать вытечки памяти, я добавляю вот этот try-catch блок. И что я говорю? Я говорю,
[45:12.660 --> 45:17.940]  что я пытаюсь скопировать все данные из other буфер в new буфер, и если в какой-то момент что-то
[45:17.940 --> 45:22.460]  пошло не так, то есть если при каком-то копировании что-то пошло не так, то я просто-напросто вызываю
[45:22.460 --> 45:28.100]  catch, то я ловлю произвольное исключение, очищаю память, которую выделал ранее, и бросаю исключение
[45:28.100 --> 45:32.740]  дальше. Понятно? То есть если в каком-то этапе копирования у меня что-то пошло не так, то я
[45:32.740 --> 45:36.140]  могу все откатить обратно. В том смысле, что я могу удалить память, которую я уже выделил,
[45:36.140 --> 45:40.820]  но так как я, смотрите, вот тут нигде вообще не изменял данные исходного вектора, то есть нигде не
[45:40.820 --> 45:44.780]  изменял исходный буфер, нигде не менял исходный size и capacity, то вектор останется по-прежнему в
[45:44.780 --> 45:50.660]  корректном состоянии. И только в случае, если и выделение памяти, и копирование произойдет
[45:50.660 --> 46:00.700]  успешно, только после этого я со спокойной совестью могу изменять данные вектора. То есть я удаляю
[46:00.700 --> 46:07.140]  буфер, говорю, что буфер теперь это новый буфер, size это новый size и capacity это новый size. Все.
[46:07.140 --> 46:14.900]  Нормально? То есть я сначала сделал все изменения, а потом с помощью только безопасных операций
[46:14.900 --> 46:18.980]  применил эти самые изменения. То есть когда я делал изменения в векторе, у меня ничего не
[46:18.980 --> 46:24.700]  менялось, поэтому ничего и после выброса исключений не изменится. А когда я начал делать безопасные
[46:24.700 --> 46:28.260]  операции, я тоже спокойно менял состояние вектора, потому что раз это операция безопасная, то и
[46:28.260 --> 46:36.420]  исключений тут нигде не возникнет. В качестве бонуса могу показать еще одну реализацию
[46:36.560 --> 46:40.900]  операции присваивания, которые обладают строгой гарантией безопасности и которые используют так
[46:40.900 --> 47:03.120]  называемый copy and swap and idiom. Идиом и копия и swap и
[47:03.120 --> 47:09.720]  Добавить строгую гарантию безопасности, а вот так, чтобы исправить дублирование кода, можно воспользоваться следующим трюком.
[47:09.720 --> 47:12.720]  Тут я проверяю на самоприсваивание.
[47:12.720 --> 47:14.720]  Надо проверить адрес.
[47:14.720 --> 47:16.720]  Я проверяю самоприсваивание.
[47:16.720 --> 47:18.720]  А дальше делаю следующее.
[47:18.720 --> 47:21.720]  Я предполагаю, что у меня уже реализован конструктор копирования.
[47:21.720 --> 47:25.720]  Давайте я с помощью копирования создам временный объект из Adr.
[47:25.720 --> 47:29.720]  То есть я путем копирования создаю временный объект, то есть временную копию Adr.
[47:29.720 --> 47:32.720]  А дальше к этой временной копии применяю уже реализованный метод swap.
[47:32.720 --> 47:33.720]  Что происходит?
[47:33.720 --> 47:37.720]  Вся логика копирования у меня уходит в конструктор копирования.
[47:37.720 --> 47:40.720]  Вся копирование отходит на конструктор копирования.
[47:40.720 --> 47:45.720]  Если в этом конструкторе копирования что-то пошло не так, то ничего не произошло потому что у меня исходный объект никак не изменился.
[47:45.720 --> 47:50.720]  Но если копирование произошло успешно полностью, то я могу взять этот вот временный объект
[47:50.720 --> 47:55.720]  и забрать все его данные себе, а свои данные дати этому временному объекту.
[47:55.720 --> 47:56.720]  Что тогда произойдет?
[47:56.720 --> 47:58.720]  Этот временный объект получит мои данные, их уничтожит...
[47:58.720 --> 48:02.560]  это временный объект, для него потом вызовется деструктор. Все мои данные, они будут уничтожены.
[48:02.560 --> 48:05.800]  А те данные, которые скопировал вот этот вот конструктор копирования, я заберу себе,
[48:05.800 --> 48:11.880]  поэтому получу полноценную копию атер. Таким образом, я убиваю двух зайцев и избавляюсь от дублирования кода,
[48:11.880 --> 48:17.480]  и получаю строгую гарантию безопасности. Да.
[48:17.480 --> 48:24.320]  А вот будут ли какие-то идеи и отличия, если мы будем, допустим, наоборот, делать что-то временное объекта,
[48:24.320 --> 48:31.920]  а потом, где он здесь, стрелочка, свап, вот время. Нет, нет, ну то есть, можно написать вот так,
[48:31.920 --> 48:41.240]  автокопии равно адр, и дальше просто написать свап, копии. Можно написать вот так, ну,
[48:41.240 --> 48:47.200]  идей вообще ни в чем отличия не будет, то есть, как бы то же самое. Вот. Просто вот так вот
[48:47.200 --> 48:59.520]  можно писать в одну строчку. Так. Вопросы есть? Хорошо. Поговорили про гарантию безопасности.
[48:59.520 --> 49:05.320]  Теперь давайте внезапно вернемся к вопросу, а для чего же на самом деле нужен noexcept?
[49:05.320 --> 49:11.280]  Ну вот, в прошлый раз я сказал, что noexcept нужен для того, чтобы пометить функции,
[49:11.280 --> 49:16.120]  которые точно не бросают исключений, вот. Поэтому если функция там точно не бросает исключений,
[49:16.120 --> 49:22.080]  то, соответственно, я могу на это полагаться, бла-бла-бла. В общем, на самом деле, когда мы вызываем
[49:22.080 --> 49:25.920]  какие-то функции, вряд ли мы опираемся на вот это вот ключевое слово noexcept. Ну то есть, на самом
[49:25.920 --> 49:30.120]  деле, мы, конечно, можем заглянуть в документацию, посмотреть на функцию, объявленную функцией noexcept
[49:30.120 --> 49:34.600]  или нет. Ну, скорее всего, мы либо как-то заранее интуитивно понимаем, может ли функция брать
[49:34.600 --> 49:38.520]  исключения или нет, ну, либо, скорее всего, просто обсчитаем документацию, документация написана,
[49:38.520 --> 49:43.560]  бросает ли функции исключения или нет. Так вот, зачем же на самом деле нужно помещать некоторые
[49:43.560 --> 49:49.560]  функции noexcept и к чему это привозит? Так вот, внезапно, вот, возможно, эта информация кого-то
[49:49.560 --> 49:55.040]  шокирует, но noexcept нужен больше не для безопасности, а noexcept нужен больше для производительности.
[49:55.040 --> 50:03.520]  Вот. Давайте я об этом поговорю. Давайте я про это скажу. А, ну да, окей. Давайте я про это скажу.
[50:03.520 --> 50:12.320]  Смотрите, вот, вот лейтмотивом нашего курса по sup++, ну, вообще, как бы таким краеугольным
[50:12.320 --> 50:21.120]  камнем sup++ является постоянная борьба между безопасностью кода и его эффективностью, да,
[50:21.120 --> 50:27.960]  то есть, например, почему sup++ настолько небезопасный, да, что аж там, кому-то ЦРУ, да, там говорят, что все,
[50:27.960 --> 50:32.280]  не надо использовать sup++, потому что он супер небезопасный, потому что там работа с памятью и так далее.
[50:32.280 --> 50:39.000]  Вот. Почему sup++ небезопасный? Вот как раз sup++ небезопасный по причине того, что он эффективный,
[50:39.260 --> 50:44.960]  точнее наоборот, он эффективный, потому что небезопасный. В чем тут связь? Ну, смотрите,
[50:44.960 --> 50:48.880]  из-за чего возникают вот эти вот самые проблемы с безопасностью? Проблемы с безопасностью возникают
[50:48.880 --> 50:51.900]  тогда, когда у нас, когда мы educational thinking на таком Idol listeners Yue Sasha California Soto2021 surface.
[50:51.900 --> 50:53.920]  Я понятиvo неопределенное поведение, вот. З Gladys pumpkin converた, separtoradesame мы выходим за
[50:53.920 --> 50:56.640]  oso 2025. Исходим за границей массива. Но это неопределенное поведение. Мы, допустим,
[50:56.640 --> 50:59.040]  Una.יבいや طоб mommyodylu выделилиconduct, но ее не очистили. Это неопределенное поведение,
[50:59.040 --> 51:02.520]  там мы два раза очporte до одну и ту же память. Это неопределенное поведение. Я и так далее,
[51:02.520 --> 51:04.520]  В чем причина вот этого неопределенного поведения?
[51:04.520 --> 51:09.520]  Вот неопределенное поведение — это, по сути, вот такие вот дыры в стандарте C++,
[51:09.520 --> 51:13.520]  которые C++ на самом деле оставляет осознанно просто-напросто для того,
[51:13.520 --> 51:18.520]  чтобы разработчики компиляторов могли полагаться на то, что этого никогда не происходит.
[51:18.520 --> 51:21.520]  А если этого никогда не происходит, то и в принципе проверок на то,
[51:21.520 --> 51:25.520]  что это потенциально может произойти, делать не нужно.
[51:25.520 --> 51:27.520]  Ну, пример такой вот жизненный.
[51:27.520 --> 51:31.520]  Вот вы пишете задачу на контесте, вам в контесте сказано, что вам на вход подают положительные числа.
[51:31.520 --> 51:34.920]  Сказано, плюс gesagt, что надеALLY у вас есть положительные числа.
[51:36.480 --> 51:39.520]  Соответственно что вы делаете? Вы просто пишите программу в предположении,
[51:39.520 --> 51:41.520]  что у вас на вход подают положительные числа.
[51:41.520 --> 51:44.520]  Вам никак не нужно дополнительно обрабатывать ситуацию,
[51:44.520 --> 51:46.520]  если вам на giờ подали отрицательные числа.
[51:46.520 --> 51:49.520]  Ну, потому что если вам было сказано, что на вход подают положительные числа…
[51:49.520 --> 51:54.520]  А если соответственно подаются отрицательные числа, то вам нужно сделать что-то еще.
[51:54.520 --> 51:56.520]  В этом случае ваша программа была бы менее эффективной.
[51:56.520 --> 51:58.520]  Потому что вам бы пришлось рассматривать некоторые дополнительные случаи и вот Halard
[51:58.520 --> 52:00.720]  и вот эти постоянные проверки на лFA
[52:00.720 --> 52:03.420]  замедлили вашу программу да, а когда вам в условии
[52:03.420 --> 52:05.040]  прям четко и ясно сказано, что вам наход connectors
[52:05.040 --> 52:06.600]  подают столько положительные числа, вы просто
[52:06.600 --> 52:08.100]  забиваете на другие случаи и пишите вот
[52:08.100 --> 52:09.740]  в предположении что вам наход Commission под kommen
[52:09.740 --> 52:12.320]  положительные числа, разработчики компили mostrar
[52:12.320 --> 52:14.140] etty ровно так же, statistics плюс
[52:14.140 --> 52:15.760]  плюс написано, то что并 не написано,
[52:15.760 --> 52:16.800]  что нужно делать если вдруг
[52:16.800 --> 52:18.680]  мы вышли за границы массива или что
[52:18.680 --> 52:20.040]  нужно делать если вдруг мы обращаемся к
[52:20.040 --> 52:21.480]  не инициализированный переменной,
[52:21.480 --> 52:23.300]  то разработчик they пока полны волны
[52:23.300 --> 52:25.480]  поступать так как им удобно, что значит
[52:25.480 --> 52:27.000]  как им удобно стрpoчки компиляторы
[52:27.000 --> 52:28.640]  поступают так, как это будет так Nambo
[52:28.640 --> 52:33.120]  эффективно конкретно в их реализации. Именно поэтому возникает вот такая вот
[52:33.120 --> 52:36.200]  история, что мы забиваем на безопасность, то есть мы предполагаем, что такого не
[52:36.200 --> 52:41.000]  происходит, но при этом получаем дополнительную эффективность.
[52:41.000 --> 52:45.920]  Если же в какой-то момент возникает необходимость в какой-то
[52:45.920 --> 52:49.200]  безопасности, допустим, вот почему, например, нет неопределенного поведения
[52:49.200 --> 52:52.200]  какого-нибудь Java и Python, ну потому что на все такие ситуации, выход за
[52:52.200 --> 52:56.000]  границы массива, обращение к неинициализированной памяти, там вообще, по-моему, нет
[52:56.000 --> 52:58.920]  неинициализированной памяти, в общем, при обращении к переменам всегда
[52:58.920 --> 53:02.240]  происходит дополнительная проверка, то есть сама система, сам компилятор или
[53:02.240 --> 53:05.880]  сам интерпретатор проверяет, а действительно ли эта память доступна,
[53:05.880 --> 53:09.240]  действительно ли там что-то лежит и так далее. И вот на это уходят дополнительные
[53:09.240 --> 53:13.080]  ресурсы. И вот возникает вот такая вот проблема. С одной стороны, хочется писать
[53:13.080 --> 53:16.520]  безопасный код, но безопасный код, как правило, связан с дополнительной
[53:16.520 --> 53:20.120]  нагрузкой, с дополнительными проверками. С другой стороны, хочется писать
[53:20.120 --> 53:23.040]  эффективный код, но если мы пишем эффективный код, тогда он придется избавляться от
[53:23.040 --> 53:28.360]  дополнительных проверок, чтобы код делал ровно то, чего мы хотим. Вот, и вот
[53:28.360 --> 53:36.280]  таким вот, как назвать, ну таким вот аватаром, который приводит все в
[53:36.280 --> 53:41.800]  баланс, в C++ является слово noexcept. Вот noexcept говорит следующее, что этот код
[53:41.800 --> 53:45.320]  не только эффективный, но этот код еще и безопасный, то есть компилятор может
[53:45.320 --> 53:48.360]  полагаться на то, что при вызове этого метода или при вызове этой операции
[53:48.360 --> 53:51.360]  ничего плохого не произойдет, поэтому можно выбирать наиболее эффективную
[53:51.360 --> 53:57.880]  версию. Вот, давайте обсудим. Давайте приведу пример. Как noexcept позволяет
[53:57.880 --> 54:14.760]  ускорить код, ускорить код программ? Так, пу-пу-пу, в общем, пример, ладно, я хотел показать другой пример, давайте его на
[54:14.760 --> 54:24.800]  доске обсудим. Смотрите, ключевое место, в котором необходимо писать noexcept
[54:24.800 --> 54:41.000]  всегда, ладно, давайте на том примере. Место, где стоит всегда писать noexcept,
[54:41.000 --> 54:48.240]  является перемещающий конструктор или перемещающий присваивание. Вот по
[54:48.240 --> 54:51.680]  следующей причине. Давайте посмотрим на этот код. Код realoket, который
[54:51.680 --> 54:55.000]  просто-напросто переведеляет память для вектора, то есть как бы если
[54:55.000 --> 54:58.440]  меня попросили выделить памяти больше чем ноль, то я выделяю эту память, вот
[54:58.440 --> 55:02.080]  создаю новый буфер, создаю новый размер и так далее. Вот данный код является
[55:02.080 --> 55:06.360]  примером кода, который является неэффективным и небезопасным. Вот, почему?
[55:06.960 --> 55:11.120]  Этот код является неэффективным и небезопасным, потому что, во-первых, тут
[55:11.120 --> 55:14.520]  потенциально может возникнуть исключение, то есть при копировании данных
[55:14.520 --> 55:17.720]  возникает исключение, и соответственно, что при этом происходит? Если тут
[55:17.720 --> 55:20.920]  возникнет исключение, то я потеряю вот эту вот динамически выделенную память и
[55:20.920 --> 55:25.360]  соответственно у меня произойдет утечка памяти, да, понятно. С другой стороны, эта
[55:25.360 --> 55:28.520]  реализация не является эффективной, по какой причине? Она не является эффективной,
[55:28.520 --> 55:33.520]  потому что тут я использую копирование, да, то есть смотрите, у меня есть, у меня есть
[55:33.520 --> 55:42.520]  старые данные, то есть вот у меня есть старые данные, вот, я хочу перевыделить память,
[55:42.520 --> 55:48.720]  допустим, перевыделить память большего размера, я хочу перенести старые данные в
[55:48.720 --> 55:55.640]  новый массив. Вот. А что, если вы в качестве вот этих вот данных, которые мне нужно
[55:55.640 --> 56:02.560]  перевести в новый массив? Что если этими данными окажутся какие-то длинные строчки,
[56:02.560 --> 56:07.440]  или какие-то другие длинные вектора? Что при этом произойдет? Ну, при этом будет вот этот
[56:07.440 --> 56:10.760]  каждый элемент будет копироваться в новый буфер, а копирование будет занимать очень большое время,
[56:10.760 --> 56:22.000]  согласны? Да? Вот. Поэтому, что на самом деле бы хотелось сделать? Ну, какая есть альтератива
[56:22.000 --> 56:27.480]  копирования? Да, то есть, если у меня есть какой-то, ну, если у меня был какой-то старый буфер,
[56:27.480 --> 56:31.560]  мне нужно какие-то данные перенести старого буфера в новый буфер, ну, при перевыделении памяти
[56:31.560 --> 56:36.360]  вектора, то, естественно, разумным вариантом был бы применить перемещение, ну, то есть каждому
[56:36.360 --> 56:46.280]  элементу применить функцию sdmove. Ну, давайте разбираться по порядку. Вот. Хорошо. Допустим,
[56:46.280 --> 56:51.440]  я решил пока забить на эффективность, да, и решил написать вот этот вот, переписать тот же самый
[56:51.440 --> 56:59.560]  код, но с использованием, ну, скажем так, техник безопасности. На это что я делаю? Я выделяю память,
[56:59.560 --> 57:04.120]  дальше говорю, что у меня новый размер вектора равен вот такому, вот такой величине, и дальше я
[57:04.120 --> 57:09.360]  помещаю вот этот вот код, в котором потенциально может что-то пойти не так, я помещаю его в блок
[57:09.360 --> 57:14.560]  try-catch. То есть, я произвожу копирование элементов, то есть, я копирую элементы из старого буфера в
[57:14.560 --> 57:20.760]  новый буфер, вот. И в случае, если что-то пошло не так, то я, ну, ловлю это самое произвольное
[57:20.760 --> 57:24.960]  исключение, которое произошло, удаляю память, которая была выделена, и бросаю исключение дальше.
[57:24.960 --> 57:29.360]  То есть, в этот момент, то есть, как бы, ну, сказал, ну, окей, жаль, да, то есть, копирование произошло
[57:29.360 --> 57:36.800]  неуспешно, поэтому оставайся со старым буфером. Нормально? Да? Вот. То есть, данная реализация
[57:36.800 --> 57:41.080]  является безопасной, но при этом по-прежнему является неэффективной, да, почему? Потому что у меня
[57:41.080 --> 57:46.080]  тут используется копирование, вот, ну, то есть, а при копировании данных у меня, при копировании
[57:46.080 --> 57:49.000]  данных у меня, ну, потенциально, копирование данных потенциально занимает большое время, то есть,
[57:49.000 --> 57:54.520]  если я вдруг работаю там со строками, с факторами и так далее, вот. Давайте посмотрим на следующий
[57:54.520 --> 58:01.080]  код и зададимся следующим вопросом. Хорошо, вот я понял, что предыдущий код, он безопасный,
[58:01.080 --> 58:05.520]  ну, он обладает строгой гарантией безопасности, но при этом не является эффективным. Почему? Потому
[58:05.520 --> 58:11.080]  что вот тут вот в 38 строчке происходит копирование. Давайте я вот согласно вот этому плану перейду
[58:11.080 --> 58:18.040]  от копирования к перемещению. Вот. То есть, напишу вот такой код. То есть, вместо того, чтобы копировать
[58:18.040 --> 58:25.360]  элементы, буду их перемещать. То есть, что я буду делать? То есть, вот, пусть у меня есть буфер,
[58:25.360 --> 58:35.240]  вот есть элемент тут, тут, тут, и что я буду делать? Перемещу первый элемент, перемещу второй элемент,
[58:35.240 --> 58:45.320]  перемещу третий элемент и четвертый. Перемещение потенциально работает быстрее, чем копирование,
[58:45.320 --> 58:51.400]  ну, там для строк и векторов это точно верно. Вот. Ну и плюс так, я все поместил в тройкач блок,
[58:51.400 --> 58:55.720]  кажется, что код абсолютно, точнее, код обладает строгой гарантией безопасности, то есть,
[58:55.720 --> 59:06.560]  во-первых, он и эффективный, и безопасный. Так это или нет? Ну, смотрите, если, смотрите,
[59:06.560 --> 59:10.160]  если у меня перемещения нет, то вот этот код будет работать как копирование. Ну, давайте
[59:10.160 --> 59:14.680]  предположим, что у типа T, да, то есть, у элементов, которые хранит вектор, конструктор перемещает,
[59:14.680 --> 59:18.000]  точнее, перемещающие присваивания все-таки есть. Ну, там для большинства типа перемещающие
[59:18.000 --> 59:23.760]  присваивания оно все-таки присутствует. Вот. В чем принципиальная проблема? Почему этот код на самом
[59:23.760 --> 59:31.320]  деле не является безопасным? Ну, казалось бы, да, он эффективный почему-то, потому что я перемещаю,
[59:31.320 --> 59:37.280]  ну, разумно. Вот. Но он не является, с другой стороны, он является безопасным, ну, просто потому,
[59:37.280 --> 59:45.120]  что я поместил весь код вызова присваивания в try-catch. Да, если у меня перемещение произошло
[59:45.120 --> 59:50.800]  неуспешно, то я просто-напросто удаляю новый буфер и бросаю исключение дальше. Почему этот
[59:50.800 --> 59:57.440]  код не обладает строгой гарантией безопасности? А в каком случае могут потеряться данные?
[59:57.440 --> 01:00:07.880]  Вот. Да, смотрите. Смотрите, в чем потенциальная проблема. Снова. У меня есть буфер, в котором изначально
[01:00:07.880 --> 01:00:18.600]  были данные. Я в тыкле-фор начал их поочередно перемещать. Взял первый элемент, переместил.
[01:00:18.600 --> 01:00:26.480]  Взял второй элемент, переместил. Начал перемещать третий элемент, но тут возникло исключение.
[01:00:26.480 --> 01:00:41.840]  Что произошло? Да, смотрите. У меня в результате перемещения второго элемента возникло исключение.
[01:00:41.840 --> 01:00:51.120]  Я это исключение поймал в кэтчблоке, удалил новый буфер и завершил операцию реаллокации.
[01:00:51.120 --> 01:00:59.400]  Что произошло? У меня буфер изменился, согласны? Раньше в нем были два элемента,
[01:00:59.400 --> 01:01:03.400]  ну первые два элемента в нем были, а теперь первых двух элементов нет. Точнее, они находятся в так
[01:01:03.400 --> 01:01:08.040]  называемом moved from state. Эти элементы были перемещены, значит они хранят, скорее всего,
[01:01:08.040 --> 01:01:13.680]  они хранят какие-то нулевые указатели. Хотя раньше они хранили какие-то реальные объекты. Понятно?
[01:01:13.680 --> 01:01:20.240]  Это момент понятен? То есть раньше, когда я копировал, вот, если я производил копирование,
[01:01:20.240 --> 01:01:24.480]  то все окей. Раз я производил копирование, то эти элементы остались на месте. Я мог спокойно удалить
[01:01:24.480 --> 01:01:27.960]  новый буфер, ну тогда, соответственно, после удаления у меня исходный буфер оставался в
[01:01:27.960 --> 01:01:35.840]  прежнем состоянии. Если же я начинаю перемещать, то я лишаюсь способности к написанию безопасного кода.
[01:01:35.840 --> 01:01:44.360]  Вот, то есть возникла вот эта вот самая вилка, в которой, с одной стороны, я хочу написать
[01:01:44.360 --> 01:01:50.160]  оптимальный код, который бы перемещал элементы, но с другой стороны, я теряю безопасность. Почему?
[01:01:50.160 --> 01:01:54.640]  Потому что если я элементы перемещаю, и в какой-то момент при перемещении возникла ошибка, то у меня
[01:01:54.640 --> 01:02:01.440]  исходный буфер остался в невоидном состоянии. Как победить эту проблему? Давайте я предложу такой
[01:02:01.440 --> 01:02:12.560]  вариант. Вот. Мое предложение такое. Давайте я буду перемещать, то есть вот у меня есть буфер,
[01:02:12.560 --> 01:02:26.000]  есть новый буфер. Давайте я буду перемещать элементы, то есть перемещу вот этот элемент, перемещу вот этот
[01:02:26.000 --> 01:02:32.280]  элемент, перемещу вот этот элемент, а при перемещении вот этого элемента возникла ошибка. Ну смотрите,
[01:02:32.280 --> 01:02:36.720]  что у меня произошло? Так как я эти элементы перемещал, у меня буфер оказался не в том состоянии,
[01:02:36.720 --> 01:02:41.560]  который был раньше. Согласны? Ну давайте я верну его в исходное состояние, сделаю код безопасным.
[01:02:41.560 --> 01:02:47.480]  То есть перемещение не удалось, ну давайте откатим все обратно. Давайте перемещаю обратно, перемещаю
[01:02:47.480 --> 01:02:56.760]  обратно, перемещаю обратно. В чем проблема? Да, перемещаю обратно, и тут новая ошибка. Что делаем дальше?
[01:02:56.760 --> 01:03:02.280]  Ну окей, туда не получилось, давайте обратно перемещать. Вот. И так далее. То есть понимаете,
[01:03:02.280 --> 01:03:08.240]  в чем проблема? Если я начинаю перемещать, то я вообще не могу гарантировать, вообще не могу
[01:03:08.240 --> 01:03:13.200]  дать строгую гарантию безопасности, потому что перемещение, оно всегда оставляет мне какой-то
[01:03:13.200 --> 01:03:17.760]  из векторов, точнее, какой-то из массивов в промежуточном состоянии. И если я пытаюсь из этого
[01:03:17.760 --> 01:03:21.680]  промежуточного состояния вернуться в какое-то исходное состояние, то мне снова придется вызывать
[01:03:21.680 --> 01:03:36.840]  перемещение, ну а перемещение опять же может бросить исключение. Понятно? Да. А кто вам такое сказал?
[01:03:37.320 --> 01:03:46.120]  Давайте я напишу специальный тип. Класс Type. Напишу класс Type. И у класса Type напишу такое перемещающее
[01:03:46.120 --> 01:04:00.920]  присваивание. Вот так. Type, оператор Type, амперсант, амперсант. И напишу тут такой код. Если
[01:04:00.920 --> 01:04:16.160]  ранд, не знаю, процент 0 равно 0, то throw. А иначе не throw. То есть, ты представляешь себе, что операция
[01:04:16.160 --> 01:04:21.280]  перемещения, она зависит от каких-то внешних обстоятельств. То есть, по каким-то причинам,
[01:04:21.280 --> 01:04:24.920]  в некоторых ситуациях она бросает исключение, в других ситуациях не бросает. Например, она зависит
[01:04:24.920 --> 01:04:39.320]  от какого-то рандома. То есть, тут я вообще не могу дать никаких гарантий на то, что перемещение завершится
[01:04:39.320 --> 01:04:46.720]  успешно. Понятно? То есть, перемещение, оно оптимально, то есть, оно эффективно, но, к сожалению,
[01:04:46.720 --> 01:04:57.800]  не дает мне написать безопасный код. Вот, в этом проблема. Так, поэтому, что у нас получается? У нас
[01:04:57.800 --> 01:05:03.200]  получается следующее. Если я хочу написать код, написать код реаллокации, который бы следовал,
[01:05:03.200 --> 01:05:09.880]  который бы удовлетворял строгой гарантии безопасности, то я должен использовать копирующее
[01:05:09.880 --> 01:05:15.120]  присваивание. Этот код безопасный, но не эффективный. Если я хочу получить эффективный код, то я
[01:05:15.120 --> 01:05:21.440]  использую перемещение. Вот оно, перемещение. Но при этом код становится небезопасным. Вот, вот
[01:05:21.440 --> 01:05:28.960]  этот самый баланс. При чем тут noexcept? А noexcept тут при том. Смотрите, помните, я говорил про то,
[01:05:28.960 --> 01:05:37.280]  что когда мы обсуждали симматику перемещения, я говорил про то, что все операции,
[01:05:37.280 --> 01:05:44.240]  копирующие, перемещающие присваивание и все конструкторы перемещения, то есть, все
[01:05:44.240 --> 01:05:53.120]  перемещающие операции должны быть помечены noexcept. Для чего? Смотрите. На самом деле,
[01:05:53.120 --> 01:06:03.080]  на самом деле, стандарты BGC++, помимо функции std move, есть еще функция move if noexcept. И она устроена
[01:06:03.080 --> 01:06:14.560]  очень хитро. std move if noexcept действует следующим образом. Она говорит, она работает как std move
[01:06:14.560 --> 01:06:20.120]  в случае, если перемещение помещено как noexcept, а если перемещение не помещено как noexcept,
[01:06:20.120 --> 01:06:27.000]  она просто-напросто возвращает копию. Понятно? Move if noexcept устроена следующим образом. Она
[01:06:27.000 --> 01:06:32.920]  возвращает исходный объект, если перемещение не помещено как noexcept и работает как
[01:06:32.920 --> 01:06:39.080]  move, если перемещение помещено как noexcept. Вот. Для чего нужно перемещение, на самом деле,
[01:06:39.080 --> 01:06:44.080]  помещать noexcept? Перемещение нужно помещать noexcept, чтобы у вас код был одновременно и безопасным,
[01:06:44.080 --> 01:06:49.640]  и эффективным. Потому что если вы перемещение пометили как noexcept, то тогда компилятор,
[01:06:49.640 --> 01:06:53.280]  но еще и стандартная пилотека, точно уверена, что при перемещении ничего плохого не может
[01:06:53.280 --> 01:07:00.440]  произойти. А раз при перемещении ничего плохого не может произойти, то я могу абсолютно спокойно,
[01:07:00.440 --> 01:07:11.560]  ну допустим при реалокации, вызывать перемещение. То есть тут, тут, тут, тут и так далее. Окей?
[01:07:11.560 --> 01:07:23.920]  Вот. То есть noexcept позволяет общить другому коду о том, что меня вызывать абсолютно безопасно.
[01:07:23.920 --> 01:07:29.880]  Раз меня вызывать абсолютно безопасно, то эту операцию, эту функцию можно вызывать в контексте
[01:07:29.880 --> 01:07:35.280]  максимальной эффективности. Вот пример. Если я буду вызывать перемещение, то это будет
[01:07:35.280 --> 01:07:42.840]  работать небезопасно, но если я гарантирую, что у меня перемещение noexcept, то тогда я говорю,
[01:07:42.840 --> 01:07:47.640]  пожалуйста, делай перемещение, и можешь не думать о проблемах с безопасностью. Окей?
[01:07:47.640 --> 01:07:56.920]  Вот в этом примере. Давайте еще раз. Смотрите, если я просто...
[01:07:56.920 --> 01:08:06.200]  Ну смотрите, если, ну смотрите, в предыдущем примере, если я не был, если я не уверен в том,
[01:08:06.200 --> 01:08:10.600]  что перемещение работает безопасно, тогда проблема в следующем. Вот. Я начинаю перемещать,
[01:08:10.600 --> 01:08:14.400]  перемещать, перемещать, и вдруг, допустим, на последнем элементе перемещение зафейлилось.
[01:08:14.400 --> 01:08:23.320]  Допустим, я ставлю ровно в таком состоянии. Вот. Допустим, перемещение устроено так,
[01:08:23.320 --> 01:08:28.800]  что оно в какой-то случайный момент решает бросить исключение, суету навести. Вот. По какой-то
[01:08:28.800 --> 01:08:32.480]  причине. То есть мы же не знаем, как... Смотрите, у нас же вектор реализован для произвольного типа
[01:08:32.480 --> 01:08:36.880]  T. Я же не знаю, какой там пользователь подаст типа T. Но вдруг он реализует как-то неправильно
[01:08:36.880 --> 01:08:41.960]  операцию перемещения, или просто перемещение устроено так, что, допустим, перемещение выделяет
[01:08:41.960 --> 01:08:48.280]  память у него. Вот. Тогда она может покинуть исключение. Поэтому, в случае, если тут произойдет
[01:08:48.280 --> 01:08:53.520]  что-то не так, то мне либо придется возвращать все обратно, а, как мы поняли, это невозможно. Почему?
[01:08:53.520 --> 01:08:56.760]  Потому что, если я буду начинать возвращать все обратно, то при возврате обратно снова может
[01:08:56.760 --> 01:09:01.280]  произойти вот такая вот ситуация. Вот. Поэтому вернуть все обратно я не могу. Поэтому мне придется
[01:09:01.280 --> 01:09:05.000]  смириться с тем, что вот я останусь, что у меня все останется на полупытии, и строгой гарантии не
[01:09:05.000 --> 01:09:09.240]  будет. Вот. То есть строгую гарантию, то есть одновременно и строгую гарантию безопасности,
[01:09:09.240 --> 01:09:13.320]  и эффективность я могу гарантировать только в том случае, если у меня перемещение не
[01:09:13.320 --> 01:09:20.080]  бросает исключений. И вот для этих ситуаций есть функция moveNoExcept. Еще раз, да, moveNoExcept,
[01:09:20.080 --> 01:09:24.560]  если видит, что перемещение безопасно, оно просто-напросто делает перемещение, и все работает
[01:09:24.560 --> 01:09:29.800]  эффективно. Если moveNoExcept видит, что перемещение безопасно, то он вместо перемещения делает
[01:09:29.800 --> 01:09:34.040]  копирование. Вот. Ну а копирование уже тоже дает строгую гарантию безопасности.
[01:09:34.040 --> 01:09:52.680]  А как, смотрите, а как компилятору понять, безопасно это или нет? Еще раз, компилятор смотрит верно
[01:09:52.680 --> 01:09:57.520]  лишь, что перемещение помещено как NoExcept. Вот как раз такой разговор про что? Когда мы пишем
[01:09:57.520 --> 01:10:03.520]  конструктор перемещения, ну или перемещающий присваивание, мы же пишем его вот так. Адр. И
[01:10:03.520 --> 01:10:11.400]  дальше необходимо писать NoExcept. Вот вы можете самостоятельно провести, ну давайте я семинаристу
[01:10:11.400 --> 01:10:16.240]  попрошу, в общем, можете провести эксперимент. Вы можете реализовать, ну вот взять, да, возьмите,
[01:10:16.240 --> 01:10:20.920]  кстати, проведите такой эксперимент. Вот вы все писали наверняка класс строки свой, да, класс
[01:10:20.920 --> 01:10:25.840]  стринг. Вот возьмите там свой класс строки, и в конструкторе перемещения и в перемещающей
[01:10:25.840 --> 01:10:30.880]  присваивании уберите слово NoExcept. Вот. И попробуйте добавить кучу элементов в std-вектор.
[01:10:30.880 --> 01:10:38.440]  Попробуйте добавить кучу строк, ну кучу не нулевых строк в std-вектор. Вот. NoExcept и без NoExcept.
[01:10:38.440 --> 01:10:42.440]  Вы увидите, что если вы не пишете NoExcept, то у вас вектор работает супер медленно. Если вы
[01:10:42.440 --> 01:10:46.760]  работаете с NoExcept, то вектор будет работать быстро. Почему? Потому что если вы не написали NoExcept,
[01:10:46.760 --> 01:10:52.760]  то вектор переключается в режим копирования. Вот. Если вы пишете NoExcept, то вектор работает в
[01:10:52.760 --> 01:11:11.520]  режиме перемещения. Окей? Нормально? Задайте какие-нибудь вопросы. Так, ну окей. Так,
[01:11:11.520 --> 01:11:15.080]  ну про ирак и исключения, я надеюсь, вы говорили про, вы в общем все это говорили
[01:11:15.080 --> 01:11:23.640]  в семинарах. Ну и в целом тогда у меня про исключение все. Всем спасибо и до встречи на следующей неделе.
