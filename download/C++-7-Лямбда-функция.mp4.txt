[00:00.000 --> 00:11.000]  Прошлый раз не успели, а именно, ну вы можете вслух там не разговаривать, пожалуйста, хотя бы,
[00:11.000 --> 00:19.000]  а именно, enable shared from this. Мы в прошлый раз почти все сказали про умные указатели,
[00:19.000 --> 00:25.000]  что нужно было для первого знакомства. Как я уже сказал, следующей вашей задачей будет реализовать
[00:25.000 --> 00:31.000]  shared ptr после nord.map, но это будет задача вам выдана только недели через, видимо,
[00:31.000 --> 00:38.000]  две от текущего момента. Или может уже даже и на следующий, кстати. Может, кстати, и на следующий уже успеем.
[00:38.000 --> 00:46.000]  Потому что проблем... дедлайнов пока не установлено. Потому что проблема с shared ptr какая?
[00:46.000 --> 00:54.000]  Мы должны в нем научиться поддерживать нестандартный аллокатор и нестандартный дилитер.
[00:54.000 --> 01:01.000]  Но, к сожалению, мы пока не знаем, как это делать, чтобы их не делать шаблонами параметрами класса.
[01:01.000 --> 01:05.000]  Вот эту проблему мы пока отложим. В остальном, про shared ptr мы вроде все поняли.
[01:05.000 --> 01:08.000]  А почему мы не хотим делать шаблонами параметрами класса?
[01:08.000 --> 01:13.000]  Ну, потому что это очень неудобно, чтобы типом shared ptr, части типа shared ptr было аллокатор.
[01:13.000 --> 01:18.000]  Вообще, разработчики, ну, комитет по стандартизации, они такие ребята...
[01:18.000 --> 01:22.000]  В общем, им свойственно ошибаться, как и людям.
[01:22.000 --> 01:28.000]  Они поняли, что с контейнерами, конечно, это все классно, что аллокатор является частью типа.
[01:28.000 --> 01:32.000]  Но делать с shared ptr аллокатор частью типа — это какой-то перебор.
[01:32.000 --> 01:38.000]  Если просто в shared ptr от разных аллокаторов нельзя было бы друг другу присваивать, то это было бы совсем неудобно.
[01:38.000 --> 01:45.000]  Поэтому для shared ptr они решили аллокатор не делать частью типа, но это... и дилитер не делать частью типа тоже.
[01:45.000 --> 01:49.000]  Но это не очень просто. Поэтому мы пока отложим эту проблему.
[01:49.000 --> 01:58.000]  Подождите, то есть мы хотим, чтобы несколько shared ptr с разными аллокаторами и дилитерами умели ссылаться на друг друга?
[01:58.000 --> 02:00.000]  С разными типами причем, да.
[02:00.000 --> 02:04.000]  Да, а каким из дилитеров тогда будет уничтожаться?
[02:04.000 --> 02:08.000]  Нет, нет, нет. У разных shared ptr на один тот же объект, один и тот же дилитер.
[02:08.000 --> 02:11.000]  Shared ptr и shared и объект аллокатора и объект дилитера.
[02:11.000 --> 02:18.000]  Но мы можем присвоить одному shared ptr и другой shared ptr с другим аллокатором, и этот shared ptr подменит себя на тот.
[02:18.000 --> 02:20.000]  Это какой параграф?
[02:20.000 --> 02:24.000]  Чего? Это никакой параграф, это мы уходим от повествования.
[02:24.000 --> 02:31.000]  Мы откладываем эту проблему пока. Мы не хотим делать аллокатор частью типа shared ptr, но пока не умеем этого делать.
[02:31.000 --> 02:35.000]  А потом окажется, что можно.
[02:35.000 --> 02:38.000]  Ну, мы научимся просто это делать.
[02:38.000 --> 02:42.000]  Вот, кстати, может там тоже шторы закрыты? А, они и так закрыты, ну ладно.
[02:42.000 --> 02:49.000]  Так вот, enable shared from this, это пункт 13-5. Ой, 12-5, виноват.
[02:51.000 --> 02:57.000]  Какая проблема у нас осталась? Мы хотим научиться получать shared ptr на себя.
[02:59.000 --> 03:03.000]  Возможно, мне надо светлую тему сделать.
[03:03.000 --> 03:05.000]  Что значит на себя?
[03:09.000 --> 03:19.000]  В плане, был бы только shared ptr, мы строили же указатель, а потом сразу кидали на него, то есть...
[03:23.000 --> 03:31.000]  Я пытаюсь сделать светлую тему, но, к сожалению, это долго будет ее делать.
[03:32.000 --> 03:34.000]  Ладно, не буду делать светлую тему.
[03:34.000 --> 03:35.000]  Черт!
[03:35.000 --> 03:38.000]  Черт! Да, стало еще хуже.
[03:40.000 --> 03:44.000]  О! Класс!
[03:46.000 --> 03:47.000]  Размечтался!
[03:49.000 --> 03:51.000]  Ладно, хорошо, оставим так.
[03:51.000 --> 03:53.000]  Ну, короче, да.
[04:05.000 --> 04:06.000]  Нет.
[04:21.000 --> 04:22.000]  Класс!
[04:25.000 --> 04:28.000]  А чего, все это время можно было читать текст отсюда?
[04:28.000 --> 04:29.000]  Да.
[04:29.000 --> 04:35.000]  А не просто слушать, как и я набираю этого.
[04:39.000 --> 04:45.000]  Так, у нас есть следующая проблема. Вот у меня есть какая-то структура.
[04:45.000 --> 04:47.000]  Ну, структура.
[04:48.000 --> 04:53.000]  И я хочу из ее методов научиться получать shared ptr на объект этой структуры.
[04:59.000 --> 05:12.000]  Вот, ну тут мне, может быть, нужно иногда вернуть shared ptr на себя.
[05:14.000 --> 05:19.000]  Такое бывает, такое бывает, кстати, не так редко, как может показаться,
[05:19.000 --> 05:24.000]  когда вы пишете объектно ориентированный код и хотите кому-то вернуть указатель на себя,
[05:24.000 --> 05:28.000]  но при этом не хотите, чтобы это был сишный ptr.
[05:29.000 --> 05:32.000]  То есть как, представьте, что у вас все на shared ptr написано.
[05:32.000 --> 05:38.000]  В том числе ваш объект вашего класса, он сам, вы имеете к нему доступ через shared ptr.
[05:38.000 --> 05:42.000]  И вы хотите shared ptr на этот объект куда-то вернуть наружу.
[05:43.000 --> 05:46.000]  Но вы знаете, что вы были созданы через shared ptr.
[05:46.000 --> 05:51.000]  И если вы вернете наружу сишный ptr, то чувак, к которому вы его вернете,
[05:51.000 --> 05:54.000]  он будет думать о том, как вас удалять.
[05:54.000 --> 05:58.000]  Ну типа это что, это сишный ptr, значит его освобождать надо, непонятно.
[05:58.000 --> 06:05.000]  Вы хотите, чтобы был shared ptr, но вы не можете вернуть shared ptr.
[06:05.000 --> 06:11.000]  Я, к сожалению, из-за переустановки системы угрохнулся автодополнитель ВИМИ,
[06:11.000 --> 06:20.000]  поэтому пока буду снова по дедовски, так сказать, скрепа дедовски, без автодополнения.
[06:20.000 --> 06:28.000]  Но, тем не менее, я не могу написать вот так std shared ptr.
[06:28.000 --> 06:31.000]  Ну, я не могу сказать std make shared, например.
[06:31.000 --> 06:33.000]  Понятно, почему.
[06:33.000 --> 06:35.000]  Atess от this.
[06:35.000 --> 06:39.000]  Ну, синтоксически-то это корректно, это даже скомпилируется.
[06:39.000 --> 06:41.000]  Так мы два раза вернем.
[06:41.000 --> 06:45.000]  Но мы создадим классическую проблему, мы создали второй shared ptr, но то же самое.
[06:45.000 --> 06:47.000]  Возможно.
[06:47.000 --> 06:56.000]  Нет, если мы уже были как shared ptr созданы, то мы обязательно создадим второй shared ptr на то же самое.
[06:56.000 --> 07:03.000]  А если мы изначально не были созданы через shared ptr, то мы тем более не должны создавать shared ptr на себя,
[07:03.000 --> 07:07.000]  потому что shared ptr в конце будет считать, что он обязан удалить нас.
[07:07.000 --> 07:13.000]  Но если мы были не через shared ptr созданы, то мы и не должны создавать на себя shared ptr.
[07:13.000 --> 07:16.000]  Ну иначе как, иначе это бред полный.
[07:16.000 --> 07:24.000]  В связи с этим есть специальный, ну я не знаю, стоит ли назвать его костылем.
[07:24.000 --> 07:30.000]  Есть такой класс в стандартной библиотеке, называется enable shared from this.
[07:30.000 --> 07:32.000]  Как им пользоваться?
[07:32.000 --> 07:41.000]  Надо написать struct atess публичный наследник std enable shared from this.
[07:41.000 --> 07:46.000]  Но это шаблонный класс, а шаблонный параметр у него как раз s.
[07:46.000 --> 07:50.000]  Чего?
[07:50.000 --> 07:55.000]  Да, это ожидаемая реакция, так и было задумано.
[07:55.000 --> 07:58.000]  Это должно вызвать некоторые, что?
[07:58.000 --> 08:03.000]  Зачем? s-то не шаблонное, это enable shared from this шаблонный.
[08:03.000 --> 08:08.000]  То есть мы наследуемся к классу, у которого мы шаблонный аргумент.
[08:08.000 --> 08:09.000]  Да.
[08:14.000 --> 08:16.000]  Кого это шокирует?
[08:22.000 --> 08:26.000]  Кому кажется, что это что-то странное и так не должно работать?
[08:34.000 --> 08:39.000]  На самом деле то, что вы можете, пожалуйста, вслух не разговаривать между собой,
[08:39.000 --> 08:42.000]  потому что мне очень тяжело громко кричать все это время.
[08:42.000 --> 08:48.000]  Вот эта штука называется CRTP.
[08:48.000 --> 08:52.000]  Это некоторый паттерн объектно-ориентированного программирования,
[08:52.000 --> 09:03.000]  который расшифровывается как curiously recursive или recurrent, не помню, template pattern.
[09:03.000 --> 09:10.000]  Это именно такой паттерн, когда класс является наследником кого-то,
[09:10.000 --> 09:16.000]  класс является наследником шаблонного родителя, у которого шаблонный параметр – это он сам.
[09:17.000 --> 09:19.000]  Вот.
[09:24.000 --> 09:29.000]  Если тебя не смущает, ну тут есть три уровня.
[09:29.000 --> 09:33.000]  Первый уровень вас вообще ничего не смущает, потому что вы ничего не понимаете.
[09:33.000 --> 09:37.000]  Второй уровень вы что-то понимаете и вас начинает смущать, как же это так работает,
[09:37.000 --> 09:40.000]  но третий уровень вы все-таки понимаете, что это не проблема и будет работать.
[09:40.000 --> 09:43.000]  Ты на каком уровне, на первом или на третьем?
[09:46.000 --> 09:51.000]  Я понимаю, видимо, что ему придется не помыть, когда он состоит в объекте и пошедший.
[09:51.000 --> 09:56.000]  Значит, давайте я отвечу тем, кто находится на первом уровне, на возникающую…
[09:56.000 --> 09:58.000]  Можно просто ответ на задание.
[09:58.000 --> 10:00.000]  Давайте, только быстро.
[10:00.000 --> 10:08.000]  Что если мы при создании шаблонного класса enableShare.js обратимся к какому-то статическому целью, которое было в OBS.
[10:08.000 --> 10:13.000]  То есть, таким образом мы хотим отэннивировать штуку, которая зависит от enableShare.js from this,
[10:13.000 --> 10:17.000]  но эта штука как-то будет воспользоваться спричатой зависимостью между…
[10:17.000 --> 10:20.000]  Ничего не понимаю, все нормально будет, почему?
[10:20.000 --> 10:26.000]  Пусть у нас, то есть, еще раз, почему эта шаблонная штука не замыкается на спричатой зависимости?
[10:26.000 --> 10:30.000]  Это значит, ты находишься на первом уровне, если у тебя такие вопросы есть.
[10:30.000 --> 10:33.000]  Еще раз, что у нас делать, чтобы он просто по классу конструмирует…
[10:33.000 --> 10:35.000]  Да, да.
[10:35.000 --> 10:40.000]  Если этот код зависит от какого-то поля, которое было в OBS.
[10:41.000 --> 10:43.000]  Ну и что?
[10:43.000 --> 10:45.000]  Если это поле, то, например, статическое.
[10:45.000 --> 10:47.000]  Тем более тогда и что?
[10:47.000 --> 10:49.000]  Если это поле, то, например, статическое.
[10:49.000 --> 10:51.000]  Мне кажется, это очень длинный разговор.
[10:51.000 --> 10:56.000]  Давай, пожалуйста, я расскажу то, что собирался рассказать, а если тебя это не устроит, то ты в перерыве спросишь.
[10:58.000 --> 11:05.000]  Я утверждаю, что это не проблема никакая, не для компилятора, не для runtime, потому что что на самом деле означает шаблон?
[11:05.000 --> 11:07.000]  Что такое enableShare.js from this?
[11:07.000 --> 11:11.000]  Это просто такой шаблонный класс, в котором где-то фигурирует T как метапеременная.
[11:11.000 --> 11:15.000]  Что означает enableShare.js from this с шаблонным параметром S?
[11:15.000 --> 11:19.000]  Это значит, что просто в качестве T нужно формально подставить S.
[11:19.000 --> 11:22.000]  Это никак не мешает ничему.
[11:22.000 --> 11:27.000]  Я просто генерирую код класса enableShare.js from this с шаблонным параметром S.
[11:27.000 --> 11:29.000]  Просто подставляя S вместо T.
[11:29.000 --> 11:31.000]  Это никакая не проблема.
[11:31.000 --> 11:36.000]  Если, конечно, enableShare.js from this в себе попытается хранить сам объект S, это будет странно.
[11:36.000 --> 11:41.000]  Но если он будет себе хранить указатели или ссылки тока, то это никакая не проблема.
[11:46.000 --> 11:48.000]  Сейчас мы перешли на второй.
[11:50.000 --> 11:52.000]  В комбе enableShare.js from this.
[11:52.000 --> 12:05.000]  У enableShare.js будет поле, которое будет равняться, например, статическое поле, которое будет равняться, например, S.
[12:05.000 --> 12:07.000]  Что такое точка?
[12:07.000 --> 12:08.000]  Что такое S?
[12:08.000 --> 12:10.000]  С – это тип, у него нельзя точку брать.
[12:10.000 --> 12:12.000]  Если это статическое поле, то можно.
[12:12.000 --> 12:14.000]  Нет, нельзя.
[12:14.000 --> 12:16.000]  Два двоеточия можно брать.
[12:16.000 --> 12:18.000]  Двоеточие – двоеточие.
[12:18.000 --> 12:20.000]  Хорошо, никакой проблемы.
[12:20.000 --> 12:22.000]  Эта статическая штука могла бы унаследоваться.
[12:22.000 --> 12:24.000]  Что значит унаследоваться?
[12:24.000 --> 12:26.000]  Статическая штука?
[12:26.000 --> 12:27.000]  Давай, пожалуйста, потом.
[12:27.000 --> 12:28.000]  Очень сложно.
[12:28.000 --> 12:30.000]  Очень долго, точнее.
[12:30.000 --> 12:34.000]  Мы сейчас реализуем enableShare.js from this, если что.
[12:34.000 --> 12:36.000]  Это быстро.
[12:38.000 --> 12:40.000]  Так вот.
[12:42.000 --> 12:45.000]  А, да, собственно, что умеет этот enableShare.js from this?
[12:45.000 --> 12:48.000]  Он умеет делать главную вещь.
[12:48.000 --> 12:50.000]  Share it from this.
[12:54.000 --> 13:00.000]  Благодаря тому, что мы унаследовались от enableShare.js from this, у нас появился метод share it from this,
[13:00.000 --> 13:04.000]  который возвращает sharedPointer на нас,
[13:04.000 --> 13:10.000]  не создавая новое семейство sharedPointer.
[13:10.000 --> 13:14.000]  Как должен быть такой класс реализован?
[13:14.000 --> 13:16.000]  Давайте его реализуем.
[13:16.000 --> 13:18.000]  Let's write typeNameT.
[13:18.000 --> 13:22.000]  Ну, я буду писать struct понятным причинам.
[13:22.000 --> 13:26.000]  enableShare it from this.
[13:28.000 --> 13:32.000]  А что у него будет в полях для начала?
[13:36.000 --> 13:38.000]  Ваши предложения.
[13:46.000 --> 13:50.000]  Ну, не shared, а weak.
[13:50.000 --> 13:52.000]  Потому что
[13:52.000 --> 13:54.000]  если он уничтожил,
[13:54.000 --> 13:57.000]  ну, наличие enableShare it from this
[13:57.000 --> 13:59.000]  не влияет на счетчик.
[13:59.000 --> 14:05.000]  Да, если бы у нас S оставался последним из магикан, что называется, объектом,
[14:05.000 --> 14:10.000]  то получился, поскольку он наследник enableShare it from this, enableShare it from this хранит sharedPointer на него,
[14:10.000 --> 14:12.000]  то это он никогда бы не удалился, что ли?
[14:12.000 --> 14:13.000]  Ну нет, это странно.
[14:13.000 --> 14:15.000]  У нас будет weakPointer.
[14:15.000 --> 14:17.000]  На T.
[14:17.000 --> 14:19.000]  Ptr.
[14:19.000 --> 14:21.000]  Вот.
[14:21.000 --> 14:23.000]  Как мы его будем инициализировать?
[14:23.000 --> 14:27.000]  Ну, от чего мы вообще создаваться умеем?
[14:31.000 --> 14:35.000]  Ну, наверное, от указателя на T.
[14:35.000 --> 14:37.000]  Или нет?
[14:37.000 --> 14:39.000]  Сейчас, подождите, давайте подумаем.
[14:39.000 --> 14:45.000]  Давайте поймем, вот
[14:45.000 --> 14:47.000]  когда нас создают,
[14:47.000 --> 14:49.000]  когда S создаётся,
[14:49.000 --> 14:51.000]  как это происходит?
[14:51.000 --> 14:53.000]  Это создаётся через sharedPtr, то есть происходит
[14:53.000 --> 14:55.000]  newS
[14:57.000 --> 14:59.000]  от чего-то.
[14:59.000 --> 15:01.000]  И это передаётся в
[15:01.000 --> 15:09.000]  в конструктор sharedPtr.
[15:09.000 --> 15:11.000]  В конструкторе sharedPtr
[15:11.000 --> 15:13.000]  мы получаем pointer
[15:13.000 --> 15:15.000]  на T
[15:15.000 --> 15:17.000]  и
[15:17.000 --> 15:19.000]  значит создаём sharedPtr
[15:19.000 --> 15:21.000]  из него.
[15:21.000 --> 15:23.000]  Хорошо, мы пока не понимаем,
[15:23.000 --> 15:25.000]  как будет создаваться enableShare it from this.
[15:25.000 --> 15:27.000]  Ну, мы понимаем, как будет работать
[15:27.000 --> 15:29.000]  enableShare it from this.
[15:29.000 --> 15:31.000]  Он будет просто возвращать sharedPtr.
[15:31.000 --> 15:33.000]  Зачем я пишу std?
[15:33.000 --> 15:35.000]  Я могу просто писать.
[15:35.000 --> 15:37.000]  Нет, ладно, буду писать std.
[15:37.000 --> 15:39.000]  std sharedPtr
[15:39.000 --> 15:41.000]  на T
[15:41.000 --> 15:43.000]  sharedFromThis
[15:43.000 --> 15:45.000]  ну, наверное,
[15:45.000 --> 15:47.000]  const
[15:47.000 --> 15:49.000]  без
[15:49.000 --> 15:51.000]  всё, просто sharedFromThis, const.
[15:51.000 --> 15:53.000]  Что он делает?
[15:53.000 --> 15:55.000]  Он может
[15:55.000 --> 15:57.000]  неявный каст сделать,
[15:57.000 --> 15:59.000]  просто написать
[15:59.000 --> 16:01.000]  pointer.
[16:01.000 --> 16:03.000]  Ну, мы просто, да, вернём
[16:03.000 --> 16:05.000]  sharedPtr.
[16:05.000 --> 16:07.000]  Ну, на самом деле метод
[16:07.000 --> 16:09.000]  вот так называется, ptr.log.
[16:09.000 --> 16:11.000]  Log — это метод
[16:11.000 --> 16:13.000]  у weakPtr, который возвращает
[16:13.000 --> 16:15.000]  sharedPtr от него. Кажется, я его
[16:15.000 --> 16:17.000]  называл в прошлый раз.
[16:17.000 --> 16:19.000]  Ну,
[16:19.000 --> 16:21.000]  окей, он так называется.
[16:21.000 --> 16:23.000]  В этом нет ничего откровенного.
[16:23.000 --> 16:25.000]  Да.
[16:25.000 --> 16:27.000]  Я хочу, чтобы выяснить
[16:27.000 --> 16:29.000]  use case вообще вот этого
[16:29.000 --> 16:31.000]  структуры S, потому что
[16:31.000 --> 16:33.000]  мне лично непонятно вообще
[16:33.000 --> 16:35.000]  как она используется, какую задачу
[16:35.000 --> 16:37.000]  мы сейчас совершаем. Что нам хочется
[16:37.000 --> 16:39.000]  сделать?
[16:39.000 --> 16:41.000]  У тебя есть какой-то
[16:41.000 --> 16:43.000]  объект,
[16:43.000 --> 16:45.000]  который был создан через
[16:45.000 --> 16:47.000]  make.shared. И этот объект,
[16:47.000 --> 16:49.000]  ну, я не знаю, что бы это ни было,
[16:49.000 --> 16:51.000]  какой-то объект там,
[16:51.000 --> 16:53.000]  какое-нибудь хранилище, не знаю,
[16:53.000 --> 16:55.000]  был создан через sharedPtr.
[16:55.000 --> 16:57.000]  И вся программа, во всей программе
[16:57.000 --> 16:59.000]  у тебя хранится куча счетчиков
[16:59.000 --> 17:01.000]  на этот объект, ну, не куча
[17:01.000 --> 17:03.000]  счетчиков, куча sharedPtr на этот объект,
[17:03.000 --> 17:05.000]  все там, все компоненты используют этот
[17:05.000 --> 17:07.000]  объект посредством sharedPtr.
[17:07.000 --> 17:09.000]  Вот. В этом компоненте
[17:09.000 --> 17:11.000]  у тебя есть какой-то метод,
[17:11.000 --> 17:13.000]  который тебе возвращает
[17:13.000 --> 17:15.000]  указатель на хранилище.
[17:15.000 --> 17:17.000]  Этим хранилищ, он,
[17:17.000 --> 17:19.000]  например, может тебе вернуть указатель,
[17:19.000 --> 17:21.000]  ну, у тебя может быть какое-нибудь еще другое
[17:21.000 --> 17:23.000]  хранилище, может быть, это самое хранилище.
[17:23.000 --> 17:25.000]  И вот у тебя в этом хранилище есть метод
[17:25.000 --> 17:27.000]  получить указатель на
[17:27.000 --> 17:29.000]  что-нибудь, на хранилище.
[17:29.000 --> 17:31.000]  И он, например, иногда
[17:31.000 --> 17:33.000]  возвращает указатель на какую-нибудь другую штуку,
[17:33.000 --> 17:35.000]  которая является хранилищем, а иногда
[17:35.000 --> 17:37.000]  на себя. И все это sharedPtr
[17:37.000 --> 17:39.000]  и он должен вернуть sharedPtr
[17:39.000 --> 17:41.000]  на не читая, являющийся хранилищем.
[17:41.000 --> 17:43.000]  При этом он сам является хранилищем.
[17:43.000 --> 17:45.000]  Вернуть, например,
[17:45.000 --> 17:47.000]  получить хранилище
[17:47.000 --> 17:49.000]  сообщений. И это
[17:49.000 --> 17:51.000]  хранилище там. Вот оно само.
[17:51.000 --> 17:53.000]  Ну, возможно
[17:53.000 --> 17:55.000]  мне, конечно, надо какой-нибудь более конкретный
[17:55.000 --> 17:57.000]  пример привести.
[17:57.000 --> 17:59.000]  Нет, код я не буду
[17:59.000 --> 18:01.000]  писать, сорян, очень долго будет.
[18:01.000 --> 18:03.000]  Я могу
[18:03.000 --> 18:05.000]  попробовать прислать тебе
[18:05.000 --> 18:07.000]  код чего-нибудь
[18:07.000 --> 18:09.000]  реального. Можно на Stack Overflow,
[18:09.000 --> 18:11.000]  думаю, найти конкретный пример этого.
[18:13.000 --> 18:15.000]  Да, можно скачать
[18:15.000 --> 18:17.000]  утекший архив кода Яндекса
[18:17.000 --> 18:19.000]  и найти там enableSharedFromThis.
[18:19.000 --> 18:21.000]  Они там есть, точно, я уверен.
[18:23.000 --> 18:25.000]  Ну, на самом деле
[18:25.000 --> 18:27.000]  придумывать
[18:27.000 --> 18:29.000]  какой-то практический
[18:29.000 --> 18:31.000]  пример
[18:33.000 --> 18:35.000]  здесь не обязательно. Проблема
[18:35.000 --> 18:37.000]  и без практического примера
[18:37.000 --> 18:39.000]  понятна.
[18:39.000 --> 18:41.000]  Нельзя создать sharedPtr
[18:41.000 --> 18:43.000]  на себя, иначе это будет
[18:43.000 --> 18:45.000]  убе. Нам надо как-то уметь
[18:45.000 --> 18:47.000]  обрабатывать эту ситуацию, чтобы shared
[18:47.000 --> 18:49.000]  возвращать на вис.
[18:49.000 --> 18:51.000]  Зачем это может пригодиться?
[18:51.000 --> 18:53.000]  Вот.
[18:53.000 --> 18:55.000]  А как
[18:55.000 --> 18:57.000]  теперь нам
[18:57.000 --> 18:59.000]  сделать, чтоб все корректно работало?
[19:01.000 --> 19:03.000]  А нам надо
[19:03.000 --> 19:05.000]  нам хочется понять, как
[19:05.000 --> 19:07.000]  вообще этот ptr инициализируется и чем?
[19:07.000 --> 19:09.000]  И в какой момент? Вот этот вот ptr.
[19:09.000 --> 19:11.000]  Да, он должен быть
[19:11.000 --> 19:13.000]  проинициализирован каким-то sharedPtr.
[19:13.000 --> 19:15.000]  Откуда возьмется этот sharedPtr?
[19:15.000 --> 19:17.000]  Вот это невероятно хороший вопрос.
[19:17.000 --> 19:19.000]  Вот, ответ.
[19:19.000 --> 19:21.000]  А просто сам конструктор
[19:21.000 --> 19:23.000]  sharedPtr должен
[19:23.000 --> 19:25.000]  учесть этот случай.
[19:27.000 --> 19:29.000]  То есть, смотрите.
[19:31.000 --> 19:33.000]  Вот в классе
[19:33.000 --> 19:35.000]  sharedPtr.
[19:37.000 --> 19:39.000]  Кстати, я тут точку поставил,
[19:39.000 --> 19:41.000]  поставил. Вот почему это одна из
[19:41.000 --> 19:43.000]  последних задач. Бла-бла-бла-бла.
[19:43.000 --> 19:45.000]  А как нам
[19:45.000 --> 19:47.000]  обработать случай? Ну, паблик,
[19:47.000 --> 19:49.000]  наверное. Как нам обработать
[19:49.000 --> 19:51.000]  случай, когда мы создаемся от
[19:51.000 --> 19:53.000]  t звездочки?
[19:55.000 --> 19:57.000]  Да нет, зачем?
[19:57.000 --> 19:59.000]  Вот мы создаем
[19:59.000 --> 20:01.000]  sharedPtr от ptr.
[20:01.000 --> 20:03.000]  Ну, мы
[20:03.000 --> 20:05.000]  тут что-то делаем. У нас тут есть, значит,
[20:05.000 --> 20:07.000]  слушайте, ну там, короче,
[20:07.000 --> 20:09.000]  у нас есть ptr,
[20:09.000 --> 20:11.000]  sizeT,
[20:11.000 --> 20:13.000]  sizeT звездочка,
[20:13.000 --> 20:15.000]  count. Я не буду,
[20:15.000 --> 20:17.000]  там у нас еще есть на самом деле
[20:17.000 --> 20:19.000]  control блок, есть sharedCount,
[20:19.000 --> 20:21.000]  count. Все это я не буду сейчас повторять.
[20:21.000 --> 20:23.000]  Мы проинциализировали ptr,
[20:23.000 --> 20:25.000]  проинциализировали count,
[20:25.000 --> 20:27.000]  new sizeT
[20:27.000 --> 20:29.000]  от единицы.
[20:29.000 --> 20:31.000]  И
[20:31.000 --> 20:33.000]  вот здесь вот
[20:33.000 --> 20:35.000]  мы должны сделать еще одну важную
[20:35.000 --> 20:37.000]  вещь. Мы должны
[20:37.000 --> 20:39.000]  если
[20:39.000 --> 20:41.000]  t наследник enableSharedFromThis,
[20:41.000 --> 20:43.000]  то у enableSharedFromThis,
[20:43.000 --> 20:45.000]  у t нужно проставить
[20:45.000 --> 20:47.000]  вот это вот поле ptr равное
[20:47.000 --> 20:49.000]  нам.
[20:49.000 --> 20:51.000]  И в constexpr.
[20:51.000 --> 20:53.000]  Что?
[20:55.000 --> 20:57.000]  std is
[20:57.000 --> 20:59.000]  base of
[20:59.000 --> 21:01.000]  v.
[21:01.000 --> 21:03.000]  Понятно, почему v, да?
[21:03.000 --> 21:05.000]  Is base of v от чего?
[21:05.000 --> 21:07.000]  От
[21:07.000 --> 21:09.000]  сначала base,
[21:09.000 --> 21:11.000]  потом derived, сначала
[21:11.000 --> 21:13.000]  база,
[21:13.000 --> 21:15.000]  enableSharedFromThis
[21:19.000 --> 21:21.000]  от t
[21:21.000 --> 21:23.000]  запятая t,
[21:23.000 --> 21:25.000]  ну нам
[21:25.000 --> 21:27.000]  нужно будет forward declaration,
[21:27.000 --> 21:29.000]  потому что
[21:29.000 --> 21:31.000]  непонятно, что enableSharedFromThis.
[21:31.000 --> 21:33.000]  Так,
[21:33.000 --> 21:35.000]  я все еще не научился
[21:35.000 --> 21:37.000]  в ВИМе нормально копировать текст.
[21:37.000 --> 21:39.000]  Вот,
[21:39.000 --> 21:41.000]  если вот это,
[21:41.000 --> 21:43.000]  то что?
[21:43.000 --> 21:45.000]  То нужно
[21:51.000 --> 21:53.000]  ptr,
[21:53.000 --> 21:55.000]  стрелочка, ну это конечно будет некрасиво,
[21:55.000 --> 21:57.000]  в общем.
[21:57.000 --> 21:59.000]  Ну,
[21:59.000 --> 22:01.000]  это поле,
[22:01.000 --> 22:03.000]  оно называется как-то вот,
[22:03.000 --> 22:05.000]  вот как-то так.
[22:05.000 --> 22:07.000]  Что?
[22:07.000 --> 22:09.000]  Вот, видишь, не помогает твоя конструкция.
[22:09.000 --> 22:11.000]  Помогало достаточно долгое время,
[22:11.000 --> 22:13.000]  прошу заметить.
[22:13.000 --> 22:15.000]  Мы не тестировали,
[22:15.000 --> 22:17.000]  мы не делали A-B тестирование, но, возможно,
[22:17.000 --> 22:19.000]  без нее тоже так бы было.
[22:19.000 --> 22:21.000]  Так вот.
[22:21.000 --> 22:23.000]  Ну, примерно это надо сделать,
[22:23.000 --> 22:25.000]  только вот так надо сделать.
[22:25.000 --> 22:27.000]  Кого?
[22:35.000 --> 22:37.000]  ptr это
[22:39.000 --> 22:41.000]  наследник?
[22:41.000 --> 22:43.000]  enableSharedFromThis,
[22:43.000 --> 22:45.000]  а значит у него есть все поля enableSharedFromThis.
[22:45.000 --> 22:47.000]  Конечно,
[22:47.000 --> 22:49.000]  нам нужно другом стать,
[22:49.000 --> 22:51.000]  нам нужно стать friend enableSharedFromThis,
[22:51.000 --> 22:53.000]  разумеется.
[22:55.000 --> 22:57.000]  Да это коалиция просто,
[22:57.000 --> 22:59.000]  они все друзья там, они все заодно,
[22:59.000 --> 23:01.000]  понимаете, все эти чуваки.
[23:01.000 --> 23:03.000]  Friend
[23:03.000 --> 23:05.000]  class
[23:05.000 --> 23:07.000]  sharedptr
[23:09.000 --> 23:11.000]  шаблонный причем.
[23:11.000 --> 23:13.000]  А, нет,
[23:13.000 --> 23:15.000]  нам нужно friend иметь sharedptr
[23:15.000 --> 23:17.000]  только от…
[23:17.000 --> 23:19.000]  не совсем, у нас же еще родители
[23:19.000 --> 23:21.000]  наследники могут быть.
[23:21.000 --> 23:23.000]  Ну, давайте
[23:23.000 --> 23:25.000]  посчитать для простоты, что вот так пока.
[23:25.000 --> 23:27.000]  А для не…
[23:27.000 --> 23:29.000]  Ну, да,
[23:29.000 --> 23:31.000]  возможно, шаблонный друг нужен, я, кстати,
[23:31.000 --> 23:33.000]  не уверен, может быть, и так достаточно будет, надо подумать.
[23:33.000 --> 23:35.000]  Но если что шаблонного друга сделаем?
[23:35.000 --> 23:37.000]  Почему наш ptr обязан иметь в ptr?
[23:37.000 --> 23:39.000]  Потому что он наследник
[23:39.000 --> 23:41.000]  enableSharedFromThis.
[23:41.000 --> 23:43.000]  Вот, все.
[23:43.000 --> 23:45.000]  То есть, на самом деле,
[23:45.000 --> 23:47.000]  в конструкторах sharedptr мы просто
[23:47.000 --> 23:49.000]  инициализируем этот
[23:49.000 --> 23:51.000]  weekptr
[23:51.000 --> 23:53.000]  и тем самым этот enableSharedFromThis
[23:53.000 --> 23:55.000]  знает,
[23:55.000 --> 23:57.000]  откуда брать
[23:57.000 --> 23:59.000]  ptr.
[23:59.000 --> 24:01.000]  Все, в общем, по сути, мы все реализовали.
[24:11.000 --> 24:13.000]  Значит, господин
[24:13.000 --> 24:15.000]  Сватеев был первым. Как это работает?
[24:15.000 --> 24:17.000]  Не, ну это какой-то слишком общий вопрос.
[24:17.000 --> 24:19.000]  Да, да.
[24:19.000 --> 24:21.000]  Ну,
[24:21.000 --> 24:23.000]  как это будет
[24:23.000 --> 24:25.000]  работать? Подождите, давайте я вам
[24:25.000 --> 24:27.000]  покажу код просто. Вот, смотрите, я говорю,
[24:27.000 --> 24:29.000]  sharedptr
[24:29.000 --> 24:31.000]  от s
[24:31.000 --> 24:33.000]  ps
[24:33.000 --> 24:35.000]  равно
[24:35.000 --> 24:37.000]  от new s.
[24:37.000 --> 24:39.000]  В этот момент
[24:39.000 --> 24:41.000]  создается объект
[24:41.000 --> 24:43.000]  s. Но создавая…
[24:43.000 --> 24:45.000]  Когда создается объект s, сначала должен создаться объект
[24:45.000 --> 24:47.000]  enableSharedFromThis от s.
[24:47.000 --> 24:49.000]  Ну,
[24:49.000 --> 24:51.000]  он создается просто по умолчанию.
[24:51.000 --> 24:53.000]  Тут конструктор, который ничего не делает,
[24:53.000 --> 24:55.000]  но weekptr инициализируется пустым.
[24:55.000 --> 24:57.000]  А дальше
[24:57.000 --> 24:59.000]  создается
[24:59.000 --> 25:01.000]  сама s, тоже ничего
[25:01.000 --> 25:03.000]  не происходит. А потом создается sharedptr.
[25:03.000 --> 25:05.000]  sharedptr
[25:05.000 --> 25:07.000]  в своем конструкторе видит, что тип,
[25:07.000 --> 25:09.000]  который ему дали, это наследник enableSharedFromThis,
[25:09.000 --> 25:11.000]  все это
[25:11.000 --> 25:13.000]  инициализирует и попадает в этот if.
[25:13.000 --> 25:15.000]  В нем
[25:15.000 --> 25:17.000]  он понимает, что нужно
[25:17.000 --> 25:19.000]  инициализировать поле этого enableSharedFromThis
[25:19.000 --> 25:21.000]  с собой, что и делает.
[25:21.000 --> 25:23.000]  Все, после чего
[25:23.000 --> 25:25.000]  у s можно вызывать sharedFromThis.
[25:31.000 --> 25:33.000]  Кстати, да,
[25:33.000 --> 25:35.000]  еще use case.
[25:37.000 --> 25:39.000]  Даже не еще, а, наверное, главный
[25:39.000 --> 25:41.000]  use case, который я не сказал,
[25:41.000 --> 25:43.000]  который я не придумал тогда.
[25:43.000 --> 25:45.000]  Представьте, что в STS имеете дело не по указателю,
[25:45.000 --> 25:47.000]  а по ссылке. Но вам кто-то дал,
[25:47.000 --> 25:49.000]  вы уже ссылку на эту S получили.
[25:49.000 --> 25:51.000]  А вернуть вы хотите
[25:51.000 --> 25:53.000]  pointer на нее обратно, sharedptr.
[25:53.000 --> 25:55.000]  Как вам это получить? Никак, только через enable,
[25:55.000 --> 25:57.000]  только через sharedFromThis.
[25:57.000 --> 25:59.000]  Но если вы в STS имеете дело
[25:59.000 --> 26:01.000]  по ссылке.
[26:01.000 --> 26:03.000]  Как вам pointer sharedptr на нее
[26:03.000 --> 26:05.000]  отдать куда-то? Никак, вы же не можете новость
[26:05.000 --> 26:07.000]  создать, вам нужно sharedFromThis от нее вызвать.
[26:07.000 --> 26:09.000]  Смотрите,
[26:09.000 --> 26:11.000]  это только работает из-за того, что
[26:11.000 --> 26:13.000]  у нас есть конструктор sharedptr.
[26:13.000 --> 26:15.000]  Да?
[26:15.000 --> 26:17.000]  А иначе это не имеет смысл? Нет,
[26:17.000 --> 26:19.000]  если я взял
[26:19.000 --> 26:21.000]  какой-то
[26:21.000 --> 26:23.000]  sx
[26:23.000 --> 26:25.000]  с
[26:25.000 --> 26:27.000]  вот,
[26:27.000 --> 26:29.000]  я хочу сделать,
[26:29.000 --> 26:31.000]  чтобы мне вернул эту штуку
[26:31.000 --> 26:33.000]  ссылку на... Будет exception.
[26:33.000 --> 26:35.000]  Ну вот,
[26:35.000 --> 26:37.000]  а я хочу, чтобы она вернула на sharedptr.
[26:37.000 --> 26:39.000]  Нельзя так делать.
[26:39.000 --> 26:41.000]  Нельзя возвращать sharedptr на то,
[26:41.000 --> 26:43.000]  что не было изначально создано через sharedptr.
[26:45.000 --> 26:47.000]  Вот именно ты не хочешь,
[26:47.000 --> 26:49.000]  потому что если бы ты так сделал, это было бы уб,
[26:49.000 --> 26:51.000]  это было бы хуже чем exception.
[26:51.000 --> 26:53.000]  Ты можешь сделать просто
[26:53.000 --> 26:55.000]  обычный указатель.
[26:55.000 --> 26:57.000]  Ну, значит,
[26:57.000 --> 26:59.000]  не пользуйся обычными указателями.
[27:01.000 --> 27:03.000]  Я не понимаю, в чем твоя проблема.
[27:03.000 --> 27:05.000]  А,
[27:05.000 --> 27:07.000]  ну,
[27:07.000 --> 27:09.000]  ты s по ссылке имеешь,
[27:09.000 --> 27:11.000]  а тебе нужно отдать куда-то sharedptr
[27:11.000 --> 27:13.000]  на нее. Как ты это сделаешь?
[27:13.000 --> 27:15.000]  Никак, только через shared
[27:15.000 --> 27:17.000]  from this.
[27:17.000 --> 27:19.000]  Сейчас мы не хотим
[27:19.000 --> 27:21.000]  для s запретить
[27:21.000 --> 27:23.000]  создание на стеке.
[27:23.000 --> 27:25.000]  Можем и запретить, да.
[27:25.000 --> 27:27.000]  Ну, например, да,
[27:27.000 --> 27:29.000]  это может быть нужно, для s
[27:29.000 --> 27:31.000]  запрещено может быть создание на стеке.
[27:31.000 --> 27:33.000]  А str так не делает?
[27:37.000 --> 27:39.000]  Но я хочу сказать,
[27:39.000 --> 27:41.000]  что sharedptr не обязательно занимается
[27:41.000 --> 27:43.000]  управлением sharedptr. Вообще говоря,
[27:43.000 --> 27:45.000]  может быть нестандартный дилитер.
[27:45.000 --> 27:47.000]  У тебя sharedptr может
[27:47.000 --> 27:49.000]  в своем дилитере делать не освобождение
[27:49.000 --> 27:51.000]  памяти, а закрытие соединения.
[27:51.000 --> 27:53.000]  Например, этот объект s
[27:53.000 --> 27:55.000]  это tcp-соединение.
[27:55.000 --> 27:57.000]  Tcp-соединение в начале должно быть
[27:57.000 --> 27:59.000]  начато handshake сделано, а в конце
[27:59.000 --> 28:01.000]  должно быть послано конец соединения.
[28:01.000 --> 28:03.000]  И пока еще кто-то пользуется
[28:03.000 --> 28:05.000]  этим соединением, мы все шарим
[28:05.000 --> 28:07.000]  вот этот вот pointer. Как только
[28:07.000 --> 28:09.000]  кто-то последний раз,
[28:09.000 --> 28:11.000]  как только оно умирает, sharedptr
[28:11.000 --> 28:13.000]  в своем диструкторе вызовет вот этот
[28:13.000 --> 28:15.000]  дилитер, который пошлет конец соединения.
[28:15.000 --> 28:17.000]  А еще мы не хотим
[28:17.000 --> 28:19.000]  запрещать, кажется, конструирование
[28:19.000 --> 28:21.000]  на стеке для s. Это зависит от того,
[28:21.000 --> 28:23.000]  в каком сценарии. Может быть, для каких-то
[28:23.000 --> 28:25.000]  s хотим.
[28:25.000 --> 28:27.000]  Господа, мы ведем дискуссию, но, к сожалению,
[28:27.000 --> 28:29.000]  дискуссию я вынужден остановить,
[28:29.000 --> 28:31.000]  потому что это
[28:31.000 --> 28:33.000]  надолго.
[28:33.000 --> 28:35.000]  Давайте дальше.
[28:35.000 --> 28:37.000]  В общем, все, sharedptr
[28:37.000 --> 28:39.000]  sharedptr... А что я встал-то?
[28:39.000 --> 28:41.000]  Я же дальше буду код писать, не буду вставать.
[28:41.000 --> 28:43.000]  Короче, это все, что я хотел
[28:43.000 --> 28:45.000]  рассказать про sharedptr сегодня.
[28:45.000 --> 28:47.000]  Ну и вот,
[28:47.000 --> 28:49.000]  наше первое знакомство
[28:49.000 --> 28:51.000]  с sharedptr. Вы поняли,
[28:51.000 --> 28:53.000]  что там все не так просто, как
[28:53.000 --> 28:55.000]  могло бы казаться в самом начале.
[28:55.000 --> 28:57.000]  И у нас следующая тема.
[28:57.000 --> 28:59.000]  Тема тоже не длинная,
[28:59.000 --> 29:01.000]  тоже, я бы не сказал, что сложная,
[29:01.000 --> 29:03.000]  но очень полезная
[29:03.000 --> 29:05.000]  и важная.
[29:05.000 --> 29:07.000]  Ты там ногой провод дергаешь?
[29:07.000 --> 29:09.000]  Я не знаю, нет.
[29:09.000 --> 29:11.000]  Как только ты отворачиваешь,
[29:11.000 --> 29:15.000]  доска становится вот такой, да.
[29:15.000 --> 29:17.000]  Может быть, не я там, а кто-то там?
[29:17.000 --> 29:19.000]  Я не знаю.
[29:19.000 --> 29:21.000]  Я не знаю.
[29:21.000 --> 29:23.000]  Я не знаю.
[29:23.000 --> 29:25.000]  Может быть, не я там, а кто-то другой
[29:25.000 --> 29:27.000]  провод задевает.
[29:29.000 --> 29:31.000]  Следующая тема, лямбда функции.
[29:43.000 --> 29:45.000]  Давайте назову просто лямбда.
[29:45.000 --> 29:47.000]  Лямбда.
[29:51.000 --> 29:53.000]  Чего?
[29:53.000 --> 29:55.000]  Что?
[29:55.000 --> 29:57.000]  Что? Еще раз, я ничего
[29:57.000 --> 29:59.000]  не слышу.
[30:07.000 --> 30:09.000]  А, ну да, естественно.
[30:11.000 --> 30:13.000]  Это, скорее всего, потому что я
[30:13.000 --> 30:15.000]  написал правильно, а потом что-то удалилось.
[30:15.000 --> 30:17.000]  Нет?
[30:17.000 --> 30:19.000]  Я так и написал с самого начала.
[30:19.000 --> 30:21.000]  Это очень странно.
[30:21.000 --> 30:23.000]  Да, неприятно.
[30:33.000 --> 30:35.000]  Все, короче,
[30:35.000 --> 30:37.000]  живем с этим.
[30:37.000 --> 30:39.000]  Глава тринадцатая.
[30:39.000 --> 30:41.000]  Лямбда функции
[30:43.000 --> 30:45.000]  и
[30:47.000 --> 30:49.000]  элементы
[30:51.000 --> 30:53.000]  fp.
[30:53.000 --> 30:55.000]  fp это
[30:55.000 --> 30:57.000]  functional programming, да.
[30:57.000 --> 30:59.000]  Чуть-чуть функционального программирования.
[30:59.000 --> 31:01.000]  Вот.
[31:01.000 --> 31:03.000]  Ну, функциональное программирование у нас будет такое
[31:03.000 --> 31:05.000]  на минималочках.
[31:05.000 --> 31:07.000]  Хотя сегодня вам как раз
[31:07.000 --> 31:09.000]  Федя придет рассказывать про Ranges.
[31:09.000 --> 31:11.000]  И вот Ranges это такой
[31:11.000 --> 31:13.000]  ну,
[31:13.000 --> 31:15.000]  можно сказать,
[31:15.000 --> 31:17.000]  в каком-то смысле
[31:17.000 --> 31:19.000]  от голоса функционального
[31:19.000 --> 31:21.000]  программирования все плюс-плюс.
[31:21.000 --> 31:23.000]  Ладно, я не буду сейчас рассказывать, что такое функциональное
[31:23.000 --> 31:25.000]  программирование, пока мы просто
[31:27.000 --> 31:29.000]  изучим.
[31:29.000 --> 31:31.000]  А, вам уже рассказывали, что такое функциональное программирование.
[31:33.000 --> 31:35.000]  Как обычно,
[31:37.000 --> 31:39.000]  идея и простые примеры.
[31:41.000 --> 31:43.000]  Вот, на самом деле,
[31:43.000 --> 31:45.000]  все то, что мы сейчас с вами
[31:45.000 --> 31:47.000]  проходим, что муфсимантика,
[31:47.000 --> 31:49.000]  ну, муфсимантика нам нужна будет теперь
[31:49.000 --> 31:51.000]  во всех темах.
[31:51.000 --> 31:53.000]  Shared pointers это
[31:53.000 --> 31:55.000]  штука, которая
[31:55.000 --> 31:57.000]  на практике пользуется очень часто.
[31:57.000 --> 31:59.000]  И
[31:59.000 --> 32:01.000]  она вам еще очень много где пригодится,
[32:01.000 --> 32:03.000]  если вы будете промышленной разработкой заниматься.
[32:03.000 --> 32:05.000]  Лямбда функции, впрочем, тоже.
[32:05.000 --> 32:07.000]  Лямбда функции это такая тема, которая маленькая да удальненькая.
[32:09.000 --> 32:11.000]  И знать надо обязательно.
[32:11.000 --> 32:13.000]  Ну, современному
[32:13.000 --> 32:15.000]  разработчику не значить, как лямбда функции
[32:15.000 --> 32:17.000]  это позор.
[32:17.000 --> 32:19.000]  Это все.
[32:19.000 --> 32:21.000]  Да.
[32:23.000 --> 32:25.000]  А, так вот.
[32:25.000 --> 32:27.000]  Ну, я не знаю, что с этим делать.
[32:31.000 --> 32:33.000]  Да.
[32:33.000 --> 32:35.000]  Попробуй.
[32:39.000 --> 32:41.000]  Вот именно, что не длинный он там.
[32:41.000 --> 32:43.000]  У нас просто
[32:43.000 --> 32:45.000]  подожди, а тут что-то подключено, а вот это
[32:45.000 --> 32:47.000]  что такое? Нет, я боюсь, это не надо выключать.
[32:47.000 --> 32:49.000]  Подожди,
[32:49.000 --> 32:51.000]  я боюсь, не надо это выдирать из розетки, иначе
[32:51.000 --> 32:53.000]  все сломается.
[32:53.000 --> 32:55.000]  Там...
[32:59.000 --> 33:01.000]  Итак, ну, что такое
[33:01.000 --> 33:03.000]  лямбда функции?
[33:03.000 --> 33:05.000]  Ну, я думаю, вы все знаете, как обычно,
[33:05.000 --> 33:07.000]  что это такое.
[33:07.000 --> 33:09.000]  Кто пользовался лямбда функциями
[33:09.000 --> 33:11.000]  в своей жизни хоть раз?
[33:11.000 --> 33:13.000]  Меньше суток назад.
[33:13.000 --> 33:15.000]  Ну, в общем, вот.
[33:17.000 --> 33:19.000]  Ну, вот.
[33:19.000 --> 33:21.000]  Так что...
[33:21.000 --> 33:23.000]  Что тут, собственно, рассказывать?
[33:23.000 --> 33:25.000]  Можно с этого начинать вообще?
[33:25.000 --> 33:27.000]  Может, в первый семястр эту тему перенести?
[33:27.000 --> 33:29.000]  Ну, да ладно.
[33:31.000 --> 33:33.000]  Ну, да, какой стандартный
[33:33.000 --> 33:35.000]  сценарий? Вот вы
[33:35.000 --> 33:37.000]  хотите
[33:37.000 --> 33:39.000]  что-то отсортировать?
[33:41.000 --> 33:43.000]  Ну, давайте я
[33:43.000 --> 33:45.000]  вектор.
[33:45.000 --> 33:47.000]  Да банально вектор, вот у меня будет
[33:47.000 --> 33:49.000]  вектор сейчас.
[33:49.000 --> 33:51.000]  V равно 1, 2, 3,
[33:51.000 --> 33:53.000]  4, 5, 6, 7, 8.
[33:53.000 --> 33:55.000]  Заметьте, я уже не пишу
[33:55.000 --> 33:57.000]  шаблонные параметры, потому что, как мы знаем,
[33:57.000 --> 33:59.000]  начиная с 17
[33:59.000 --> 34:01.000]  можно их не писать.
[34:03.000 --> 34:05.000]  Вот. И я хочу это отсортировать.
[34:07.000 --> 34:09.000]  V.begin, V.end, но с каким-нибудь
[34:09.000 --> 34:11.000]  странным
[34:11.000 --> 34:13.000]  условием сортировки, ну, например,
[34:13.000 --> 34:15.000]  по возрастанию
[34:15.000 --> 34:17.000]  модуля.
[34:17.000 --> 34:19.000]  Вот. Тогда я что делаю? Я пишу квадратные
[34:19.000 --> 34:21.000]  скобочки.
[34:21.000 --> 34:23.000]  Дальше
[34:23.000 --> 34:25.000]  аргументы.
[34:25.000 --> 34:27.000]  Int x,
[34:27.000 --> 34:29.000]  int y.
[34:31.000 --> 34:33.000]  Дальше
[34:33.000 --> 34:35.000]  return.
[34:35.000 --> 34:37.000]  Ну,
[34:37.000 --> 34:39.000]  abs от x
[34:39.000 --> 34:41.000]  меньше, чем abs от y.
[34:43.000 --> 34:45.000]  Фигурная скобка закрылась, круглая
[34:45.000 --> 34:47.000]  скобка закрылась, точка запятой.
[34:47.000 --> 34:49.000]  Вот это
[34:49.000 --> 34:51.000]  expression, на самом деле, правильно?
[34:51.000 --> 34:53.000]  Ну, то есть вот это вот выражение, вот это вот
[34:53.000 --> 34:55.000]  начиная с квадратных скобок, так некоторые
[34:55.000 --> 34:57.000]  expression.
[34:59.000 --> 35:01.000]  Я думаю, он не по этому поводу.
[35:05.000 --> 35:07.000]  Который мы передаем в
[35:07.000 --> 35:09.000]  stdsort в качестве
[35:09.000 --> 35:11.000]  параметра обычного.
[35:11.000 --> 35:13.000]  stdsort в качестве
[35:13.000 --> 35:15.000]  параметра ожидает объект компаратора.
[35:15.000 --> 35:17.000]  То есть вот этот вот
[35:17.000 --> 35:19.000]  expression он
[35:19.000 --> 35:21.000]  корректный объект компаратора.
[35:21.000 --> 35:23.000]  Замечательный вопрос.
[35:23.000 --> 35:25.000]  Как раз вот его ты и хотел задать.
[35:25.000 --> 35:27.000]  А какой тип у этого expression?
[35:27.000 --> 35:29.000]  Ну, мы с вами,
[35:29.000 --> 35:31.000]  во-первых, знаем, что
[35:31.000 --> 35:33.000]  тип, для того чтобы узнать тип,
[35:33.000 --> 35:35.000]  есть decal type. А давайте попробуем
[35:35.000 --> 35:37.000]  так и сделать. Вот я сейчас напишу
[35:37.000 --> 35:39.000]  значит стандартный.
[35:45.000 --> 35:47.000]  Что я сейчас сделаю?
[35:47.000 --> 35:49.000]  Я скажу
[35:49.000 --> 35:51.000]  вот так.
[35:53.000 --> 35:55.000]  И скажу
[35:55.000 --> 35:57.000]  c
[35:57.000 --> 35:59.000]  от decal type.
[36:01.000 --> 36:03.000]  Ну, я хочу, чтобы компилятор
[36:03.000 --> 36:05.000]  сказал мне, какой тип у этой штуки.
[36:09.000 --> 36:11.000]  Это runtime
[36:11.000 --> 36:13.000]  определение типа. А я хочу compile time
[36:13.000 --> 36:15.000]  определение типа.
[36:17.000 --> 36:19.000]  Так, у меня лишние скобочки
[36:19.000 --> 36:21.000]  здесь.
[36:21.000 --> 36:23.000]  Есть различные разницы между runtime
[36:23.000 --> 36:25.000]  и compile time? Конечно, потому что
[36:25.000 --> 36:27.000]  в compile, в runtime что
[36:27.000 --> 36:29.000]  ты увидишь, это некоторую строку,
[36:29.000 --> 36:31.000]  которую компилятор, который компилятор
[36:31.000 --> 36:33.000]  внутри в структуре typeinfo
[36:33.000 --> 36:35.000]  называет этот тип. Для inta это будет i, например.
[36:37.000 --> 36:39.000]  А здесь ты увидишь тип, как он в языке.
[36:41.000 --> 36:43.000]  Тип, как в коде он был.
[36:43.000 --> 36:45.000]  Я хочу получить
[36:45.000 --> 36:47.000]  е, конечно же. Да, я говорю
[36:47.000 --> 36:49.000]  вот так. Все, у меня
[36:49.000 --> 36:51.000]  скобки сходятся и сходятся.
[36:51.000 --> 36:53.000]  И сейчас я узнаю, какой тип у этого
[36:53.000 --> 36:55.000]  выражения, потому что компилятор скажет, не могу
[36:55.000 --> 36:57.000]  инстанцировать c с таким шаблонным параметром
[36:57.000 --> 36:59.000]  и тут-то он испалится с каким шаблонным
[36:59.000 --> 37:01.000]  параметром. Смотрите.
[37:05.000 --> 37:07.000]  Lambda. Ой, подождите,
[37:07.000 --> 37:09.000]  мне нужно в cpp.
[37:11.000 --> 37:13.000]  g++
[37:13.000 --> 37:15.000]  c++d, c++17
[37:15.000 --> 37:17.000]  Lambda с cpp.
[37:17.000 --> 37:19.000]  Что?
[37:19.000 --> 37:21.000]  А, потому что я
[37:21.000 --> 37:23.000]  эти файлы, кажется, создал
[37:23.000 --> 37:25.000]  в своей домашней директории. Вот черт.
[37:25.000 --> 37:27.000]  Так, ладно. Значит,
[37:27.000 --> 37:29.000]  Lambda я вот сюда.
[37:31.000 --> 37:33.000]  Так, и shardptr заодно сразу
[37:33.000 --> 37:35.000]  сюда.
[37:35.000 --> 37:37.000]  Хорошо.
[37:37.000 --> 37:39.000]  Вот.
[37:41.000 --> 37:43.000]  Вот.
[37:43.000 --> 37:45.000]  А...
[37:47.000 --> 37:49.000]  Хорошо.
[37:53.000 --> 37:55.000]  Да.
[37:55.000 --> 37:57.000]  А это потому что у меня
[37:57.000 --> 37:59.000]  g++ старый.
[37:59.000 --> 38:01.000]  Я же переустановил систему
[38:01.000 --> 38:03.000]  и у меня теперь же cc9 всего лишь.
[38:03.000 --> 38:05.000]  Мне надо накатывать новый, но я пока не успел.
[38:05.000 --> 38:07.000]  Блин, с Мексикой не получилось побороться.
[38:07.000 --> 38:09.000]  А...
[38:09.000 --> 38:11.000]  Что, опять Мексика?
[38:11.000 --> 38:13.000]  Все, так.
[38:13.000 --> 38:15.000]  c++2, это кодовое название
[38:15.000 --> 38:17.000]  c++20.dot.com вышел.
[38:17.000 --> 38:19.000]  Что за первая ошибка, которая
[38:19.000 --> 38:21.000]  отгестила?
[38:21.000 --> 38:23.000]  Ну, Lambda expression в
[38:23.000 --> 38:25.000]  unrelated-контексте.
[38:25.000 --> 38:27.000]  Ну, это значит, что
[38:27.000 --> 38:29.000]  выражение, которое не вычисляется.
[38:29.000 --> 38:31.000]  Под декл-тайпом у тебя
[38:31.000 --> 38:33.000]  не вычисляющееся выражение.
[38:33.000 --> 38:35.000]  Как и под сайзовом.
[38:39.000 --> 38:41.000]  Ну, было запрещено раньше писать
[38:41.000 --> 38:43.000]  Lambda выражение вот здесь, потому что
[38:43.000 --> 38:45.000]  компилятор не хотел генерировать Lambda.
[38:47.000 --> 38:49.000]  Ну, а сейчас можно.
[38:51.000 --> 38:53.000]  Чтобы компилятору сделать Lambda,
[38:53.000 --> 38:55.000]  ему нужно сгенерировать специальный тип.
[38:55.000 --> 38:57.000]  Для этого типа ему нужно определить.
[38:57.000 --> 38:59.000]  Ему, короче, нужно генерировать кучу кода.
[38:59.000 --> 39:01.000]  А если это не вычисляющееся выражение,
[39:01.000 --> 39:03.000]  то компилятор не должен был этим заниматься.
[39:03.000 --> 39:05.000]  И не разрешено было писать Lambda в
[39:05.000 --> 39:07.000]  не вычисляемых контекстах.
[39:07.000 --> 39:09.000]  Сейчас стало можно.
[39:11.000 --> 39:13.000]  Так.
[39:13.000 --> 39:15.000]  Это не касается нашей сегодняшней темы.
[39:15.000 --> 39:17.000]  Мы сейчас обсуждаем вот это.
[39:17.000 --> 39:19.000]  У нас сейчас вот этот вот разговор.
[39:19.000 --> 39:21.000]  Мы хотели увидеть, какой тип у Lambda.
[39:21.000 --> 39:23.000]  Вот что мы увидели.
[39:23.000 --> 39:25.000]  На самом деле компилятор не говорит нам,
[39:25.000 --> 39:27.000]  какой у нее тип.
[39:27.000 --> 39:29.000]  Он говорит нечто...
[39:29.000 --> 39:31.000]  Если вы компилируете с
[39:31.000 --> 39:33.000]  каким-нибудь новым G++
[39:33.000 --> 39:35.000]  или с C-Lang, то возможно вы увидите...
[39:35.000 --> 39:37.000]  У меня, к сожалению, даже C-Lang сегодня не установлен.
[39:37.000 --> 39:39.000]  То возможно вы увидите
[39:39.000 --> 39:41.000]  какое-нибудь другое,
[39:41.000 --> 39:43.000]  более развернутое название этого типа.
[39:43.000 --> 39:45.000]  Но
[39:45.000 --> 39:47.000]  в любом случае это будет какой-то специальный тип,
[39:47.000 --> 39:49.000]  название которого
[39:49.000 --> 39:51.000]  очень содержит много
[39:51.000 --> 39:53.000]  странных символов.
[39:53.000 --> 39:55.000]  Ну, там название может быть в стиле
[39:55.000 --> 39:57.000]  там
[39:57.000 --> 39:59.000]  два знака подчеркивания,
[39:59.000 --> 40:01.000]  Lambda, два знака подчеркивания,
[40:01.000 --> 40:03.000]  Main, что-нибудь int
[40:03.000 --> 40:05.000]  и какая-нибудь куча букв. Ну, вот какой-нибудь специальный тип.
[40:11.000 --> 40:13.000]  Нет, компилятор сделает так,
[40:13.000 --> 40:15.000]  что названия Lambda, которые генерируют,
[40:15.000 --> 40:17.000]  не пересекаются с вашими названиями.
[40:17.000 --> 40:19.000]  Это, я думаю, он умеет обеспечивать.
[40:19.000 --> 40:21.000]  Нет, а если я напишу ZecalPy,
[40:21.000 --> 40:23.000]  как они здесь типа полкиются?
[40:23.000 --> 40:25.000]  Да, все будет нормально.
[40:27.000 --> 40:29.000]  Вот, сейчас мы
[40:29.000 --> 40:31.000]  к этому придем.
[40:31.000 --> 40:33.000]  Так вот, смотрите.
[40:33.000 --> 40:35.000]  Что?
[40:35.000 --> 40:37.000]  А, правильно.
[40:41.000 --> 40:43.000]  Так вот, ну ладно.
[40:45.000 --> 40:47.000]  Эээ...
[40:49.000 --> 40:51.000]  Сейчас.
[40:51.000 --> 40:53.000]  На этот раз у меня с собой есть распечатанная
[40:53.000 --> 40:55.000]  штука.
[41:01.000 --> 41:03.000]  Да.
[41:09.000 --> 41:11.000]  Как можно
[41:11.000 --> 41:13.000]  было бы использовать Lambda?
[41:13.000 --> 41:15.000]  Ну, я мог бы, например,
[41:15.000 --> 41:17.000]  создать Lambda
[41:17.000 --> 41:19.000]  как объект.
[41:19.000 --> 41:21.000]  То есть, я могу вот эту вот штуку...
[41:23.000 --> 41:25.000]  Ну, давайте я скопирую эту строчку.
[41:25.000 --> 41:27.000]  И вот здесь вот
[41:27.000 --> 41:29.000]  напишу
[41:29.000 --> 41:31.000]  авто
[41:31.000 --> 41:33.000]  f равно вот такая штука.
[41:37.000 --> 41:39.000]  Это теперь некоторый объект.
[41:39.000 --> 41:41.000]  f это некоторый объект.
[41:41.000 --> 41:43.000]  Вот.
[41:43.000 --> 41:45.000]  Сказать, какой у него настоящий тип,
[41:45.000 --> 41:47.000]  я не могу.
[41:47.000 --> 41:49.000]  Вот здесь мне, кроме авто,
[41:49.000 --> 41:51.000]  по сути, и нечего сказать.
[41:51.000 --> 41:53.000]  Я могу разве что сказать
[41:53.000 --> 41:55.000]  там.
[41:55.000 --> 41:57.000]  Ну, я могу еще DecalType сказать,
[41:57.000 --> 41:59.000]  если бы знал DecalType от чего
[41:59.000 --> 42:01.000]  брать. Ну, в общем,
[42:01.000 --> 42:03.000]  точный тип я здесь
[42:03.000 --> 42:05.000]  не в состоянии назвать, потому что компилятор его сам
[42:05.000 --> 42:07.000]  генерирует для меня.
[42:07.000 --> 42:09.000]  Это же не может быть тот вывод DecalType,
[42:09.000 --> 42:11.000]  который у нас был, подставить.
[42:11.000 --> 42:13.000]  Он однозначно установлен, для всех компиляторов
[42:13.000 --> 42:15.000]  одинаковый должен быть тип. Что значит одинаковый?
[42:15.000 --> 42:17.000]  Ну, в данной ситуации...
[42:17.000 --> 42:19.000]  Что ты называешь разными типами?
[42:19.000 --> 42:21.000]  Одинаковый с точки зрения строки...
[42:21.000 --> 42:23.000]  Не зависит от компилятора.
[42:23.000 --> 42:25.000]  Что такое тип?
[42:25.000 --> 42:27.000]  Понятие типа, оно
[42:27.000 --> 42:29.000]  теряет смысл, когда ты переходишь между...
[42:29.000 --> 42:31.000]  Если одинаковые параметры будут в функции одинаковые,
[42:31.000 --> 42:33.000]  тип возвращаемого значения,
[42:33.000 --> 42:35.000]  то это будет одно и то же?
[42:35.000 --> 42:37.000]  Что такое одно и то же?
[42:37.000 --> 42:39.000]  Какие типы называются разными?
[42:41.000 --> 42:43.000]  Нет, конечно, компилятор
[42:43.000 --> 42:45.000]  не обещает вам ничего про строку,
[42:45.000 --> 42:47.000]  которую он там запишет.
[42:47.000 --> 42:49.000]  Если вы спрашиваете, гарантируют ли все компиляторы мира,
[42:49.000 --> 42:51.000]  что они нагенерируют один и тот же набор
[42:51.000 --> 42:53.000]  символов в своем внутреннем названии
[42:53.000 --> 42:55.000]  класса, нет, конечно, не гарантируют
[42:55.000 --> 42:57.000]  и не должны. Это какая-то дурацкая
[42:57.000 --> 42:59.000]  затея.
[43:01.000 --> 43:03.000]  А это, конечно, они гарантируют,
[43:03.000 --> 43:05.000]  потому что это то, что на них стандарт
[43:05.000 --> 43:07.000]  накладывает.
[43:17.000 --> 43:19.000]  Спроси у разработчиков G++.
[43:23.000 --> 43:25.000]  Спроси у разработчиков G++, почему они
[43:25.000 --> 43:27.000]  именно такое сообщение об ошибке решили вывести,
[43:27.000 --> 43:29.000]  а не другое?
[43:29.000 --> 43:31.000]  Можно спросить, почему
[43:31.000 --> 43:33.000]  здесь именно такой текст? То, что тут
[43:33.000 --> 43:35.000]  написано, это просто то,
[43:35.000 --> 43:37.000]  как G++ сообщает вам об ошибке.
[43:37.000 --> 43:39.000]  Он не обязан вам, вообще говоря,
[43:39.000 --> 43:41.000]  ничего конкретного здесь
[43:41.000 --> 43:43.000]  говорить. Просто мы надеялись,
[43:43.000 --> 43:45.000]  что он нам что-то скажет, но он не сказал.
[43:45.000 --> 43:47.000]  И не обязан был. Он не должен называть
[43:47.000 --> 43:49.000]  внутреннее название своего типа.
[43:49.000 --> 43:51.000]  Какой-нибудь другой компилятор мог бы что-то более подробное
[43:51.000 --> 43:53.000]  сказать.
[43:53.000 --> 43:55.000]  Если ты напишешь
[43:55.000 --> 43:57.000]  декол-тайп от одной лямбды, равно-равно
[43:57.000 --> 43:59.000]  декол-тайп от лямбды?
[43:59.000 --> 44:01.000]  Что такое равно-равно для типов?
[44:03.000 --> 44:05.000]  Так.
[44:11.000 --> 44:13.000]  Естественно, это будут разные типы.
[44:13.000 --> 44:15.000]  Разумеется. Более того, если
[44:15.000 --> 44:17.000]  ты напишешь две абсолютно одинаковые лямбды,
[44:17.000 --> 44:19.000]  это все равно будут разные типы.
[44:19.000 --> 44:21.000]  Для каждой написанной тобою лямбды компилятор
[44:21.000 --> 44:23.000]  будет проверить свой собственный тип.
[44:23.000 --> 44:25.000]  По-моему, да.
[44:25.000 --> 44:27.000]  Ну, возможно, компилятор умеет их
[44:27.000 --> 44:29.000]  как-то матчить и делать одинаковыми,
[44:29.000 --> 44:31.000]  но, по-моему, нет. Все-таки они будут разными.
[44:37.000 --> 44:39.000]  Да, это будет, скорее всего, CE.
[44:39.000 --> 44:41.000]  Но я не хочу проверять.
[44:41.000 --> 44:43.000]  Ну, давайте проверим,
[44:43.000 --> 44:45.000]  кстати.
[44:45.000 --> 44:47.000]  Ну, под каждую...
[44:47.000 --> 44:49.000]  Ну, да. То есть, если я скажу вот так,
[44:49.000 --> 44:51.000]  декол-тайп от вот этого F
[44:51.000 --> 44:53.000]  равно вот этому,
[44:55.000 --> 44:57.000]  то я думаю, будет
[44:57.000 --> 44:59.000]  сейчас CE.
[45:01.000 --> 45:03.000]  Потому что конверсия из лямбды
[45:03.000 --> 45:05.000]  в лямбду запрошена, а это разные
[45:05.000 --> 45:07.000]  лямбды, и у них разные типы.
[45:09.000 --> 45:11.000]  Давайте я все-таки продолжу
[45:11.000 --> 45:13.000]  рассказывать, потому что если вы будете
[45:13.000 --> 45:15.000]  задавать вопросы, то мы не успеем.
[45:15.000 --> 45:17.000]  Нет, нельзя.
[45:17.000 --> 45:19.000]  Извините, мы не успеем иначе.
[45:19.000 --> 45:21.000]  А тем более нельзя,
[45:21.000 --> 45:23.000]  это не нужно сейчас.
[45:25.000 --> 45:27.000]  Ты задал уже три вопроса, твой
[45:27.000 --> 45:29.000]  лимит вопросов...
[45:33.000 --> 45:35.000]  Что?
[45:35.000 --> 45:37.000]  Как писать лямбда функции?
[45:37.000 --> 45:39.000]  Так, пожалуйста, тихо.
[45:41.000 --> 45:43.000]  У тебя закончилась по именам подписка.
[45:47.000 --> 45:49.000]  Ну, вообще, нет.
[45:49.000 --> 45:51.000]  Но если вы в одну строчку пишете,
[45:51.000 --> 45:53.000]  то можно и разделять. Но вообще,
[45:53.000 --> 45:55.000]  конечно, желательно лямбды писать вот так.
[45:55.000 --> 45:57.000]  Ну, и типа вот делать так.
[45:59.000 --> 46:01.000]  Но если у вас очень короткая лямбда,
[46:01.000 --> 46:03.000]  то ее можно в одну строкочку писать.
[46:05.000 --> 46:07.000]  Ну, да, думаю, можно и так.
[46:07.000 --> 46:09.000]  Тут нет
[46:09.000 --> 46:11.000]  четких каких-то сформулированных правил.
[46:11.000 --> 46:13.000]  Разные люди пишут по-разному.
[46:13.000 --> 46:15.000]  Вот.
[46:15.000 --> 46:17.000]  Главное, чтобы красиво...
[46:21.000 --> 46:23.000]  Так.
[46:23.000 --> 46:25.000]  Допустим, я хочу лямбды
[46:25.000 --> 46:27.000]  использовать как компаратор в мэпе.
[46:27.000 --> 46:29.000]  Что мне тогда надо делать?
[46:29.000 --> 46:31.000]  А тогда мне надо как раз делать мэп
[46:31.000 --> 46:33.000]  от int int
[46:33.000 --> 46:35.000]  и декл-тайп от int
[46:35.000 --> 46:37.000]  от f.
[46:37.000 --> 46:39.000]  Вот это пример, когда мне может понадобиться
[46:39.000 --> 46:41.000]  декл-тайп от объекта лямбды.
[46:41.000 --> 46:43.000]  Например, лямбду хочу использовать как компаратор
[46:43.000 --> 46:45.000]  в контейнере. Тогда мне декл-тайп здесь
[46:45.000 --> 46:47.000]  нужен. Правильно?
[46:47.000 --> 46:49.000]  Вот.
[46:49.000 --> 46:51.000]  Да.
[46:51.000 --> 46:53.000]  И заметьте, что если я здесь напишу
[46:53.000 --> 46:55.000]  декл-тайп от экспрешена,
[46:55.000 --> 46:57.000]  то это не сработает. Мне нужно именно декл-тайп
[46:57.000 --> 46:59.000]  от объекта. То есть, если я хочу в компаратор
[46:59.000 --> 47:01.000]  мэп передать лямбду, то мне нужно именно
[47:01.000 --> 47:03.000]  от объекта брать декл-тайп.
[47:03.000 --> 47:05.000]  Потому что, как я уже сказал, для разных
[47:05.000 --> 47:07.000]  лямб генерируют разные типы.
[47:07.000 --> 47:09.000]  Вот.
[47:09.000 --> 47:11.000]  Дальше.
[47:11.000 --> 47:13.000]  Как лямбда
[47:15.000 --> 47:17.000]  понимает, что и возвращать?
[47:19.000 --> 47:21.000]  Вообще-то это тоже не тривиальный вопрос,
[47:21.000 --> 47:23.000]  потому что обычно для функций
[47:23.000 --> 47:25.000]  мы указываем их возвращаемый тип, а тут вдруг
[47:25.000 --> 47:27.000]  не указываем.
[47:27.000 --> 47:29.000]  Да, значит, на самом деле
[47:29.000 --> 47:31.000]  для лямбд по умолчанию
[47:31.000 --> 47:33.000]  делается вывод типа автоматически.
[47:33.000 --> 47:35.000]  То есть, вот то, что мы раньше
[47:35.000 --> 47:37.000]  с вами говорили про вывод типа для функций,
[47:37.000 --> 47:39.000]  то есть, мы тут... Федя тут час
[47:39.000 --> 47:41.000]  распинался про то, что там есть
[47:41.000 --> 47:43.000]  авто, есть такое, авто-секой, авто-декл-тайп,
[47:43.000 --> 47:45.000]  авто-авто-амперсант,
[47:45.000 --> 47:47.000]  сто пятьсот правил, как это делается.
[47:47.000 --> 47:49.000]  Для лямбд они все молчаливо по умолчанию
[47:49.000 --> 47:51.000]  зашиты, и вы не пишете в лямбде
[47:51.000 --> 47:53.000]  возвращаемый тип, он сам выводится. То есть,
[47:53.000 --> 47:55.000]  вы, если не написали в лямбде
[47:55.000 --> 47:57.000]  ничего про возвращаемый тип, то он как будто
[47:57.000 --> 47:59.000]  авто.
[47:59.000 --> 48:01.000]  Но вы можете
[48:01.000 --> 48:03.000]  возвращать в лямбде явный возвращаемый тип и пишете это
[48:03.000 --> 48:05.000]  вот здесь, после скобочек, через
[48:05.000 --> 48:07.000]  стрелочку, да, нужно написать вот так,
[48:07.000 --> 48:09.000]  например, буль вот здесь написать.
[48:09.000 --> 48:11.000]  Разумеется,
[48:11.000 --> 48:13.000]  если я
[48:13.000 --> 48:15.000]  вот здесь вот, ну давайте я
[48:15.000 --> 48:17.000]  вот так уже эту лямбду
[48:17.000 --> 48:19.000]  сделаю многострочной,
[48:19.000 --> 48:21.000]  здесь, допустим, я могу написать,
[48:21.000 --> 48:23.000]  если, господи,
[48:23.000 --> 48:25.000]  если
[48:25.000 --> 48:27.000]  что-нибудь, не знаю, х меньше
[48:27.000 --> 48:29.000]  у, то вернуть
[48:31.000 --> 48:33.000]  там один,
[48:33.000 --> 48:35.000]  а иначе
[48:35.000 --> 48:37.000]  вернуть один у.
[48:39.000 --> 48:41.000]  То, что
[48:45.000 --> 48:47.000]  То, что
[48:47.000 --> 48:49.000]  что скажет компилятор.
[48:51.000 --> 48:53.000]  What does the fox
[48:55.000 --> 48:57.000]  Что говорит компилятор?
[49:03.000 --> 49:05.000]  Тихо, тихо, тихо,
[49:05.000 --> 49:07.000]  в общем, да.
[49:07.000 --> 49:09.000]  Что говорит компилятор? Несовместимые типы,
[49:09.000 --> 49:11.000]  не знаю, какой выводить. Ну, что в общем-то
[49:11.000 --> 49:13.000]  и происходит, когда вы автопишете
[49:13.000 --> 49:15.000]  в возвращаемом типе функции? Понятно.
[49:15.000 --> 49:17.000]  Компилятор
[49:17.000 --> 49:19.000]  он должен в compile-time решить, какой тип возвращаемый
[49:19.000 --> 49:21.000]  у этой функции, а он не знает,
[49:21.000 --> 49:23.000]  ваши типы разные, и у него нет предпочтений.
[49:23.000 --> 49:25.000]  Вы написали два ретерна, он не
[49:25.000 --> 49:27.000]  выбирает, как бы, к чему привести.
[49:27.000 --> 49:29.000]  Он должен понять в возвращаемый тип функции, какой.
[49:29.000 --> 49:31.000]  Ну, давай вопрос.
[49:31.000 --> 49:33.000]  Почему нужно писать
[49:33.000 --> 49:35.000]  фигурные скобочки
[49:35.000 --> 49:37.000]  точку с запятой в конце, если вот так надо
[49:37.000 --> 49:39.000]  строчную, а если однострочную, то не будет?
[49:39.000 --> 49:41.000]  Как это не нужно? Нужно?
[49:41.000 --> 49:43.000]  Нет, у вас вон там хостесвор
[49:43.000 --> 49:45.000]  и в конце после ретурна нет.
[49:45.000 --> 49:47.000]  А вот это параметр
[49:47.000 --> 49:49.000]  потому что
[49:49.000 --> 49:51.000]  Чел, ну потому что это параметр функции,
[49:51.000 --> 49:53.000]  скобка закрылась, и точка с запятой после конца инструкции.
[49:53.000 --> 49:55.000]  Я имею ввиду
[49:55.000 --> 49:57.000]  Ты объявляешь переменным для
[49:57.000 --> 49:59.000]  С условно, и
[49:59.000 --> 50:01.000]  фигурная скобочка закрывается.
[50:01.000 --> 50:03.000]  А, господи!
[50:03.000 --> 50:05.000]  Потому что таков синтаксис
[50:05.000 --> 50:07.000]  условных операторов C++.
[50:07.000 --> 50:09.000]  Ну, я не знаю, как тебе сказать, это
[50:09.000 --> 50:11.000]  как бы тема
[50:11.000 --> 50:13.000]  первой пары. Ну, типа такой синтаксис,
[50:13.000 --> 50:15.000]  что я должен тебе?
[50:15.000 --> 50:17.000]  Давай мы, пожалуйста,
[50:17.000 --> 50:19.000]  не будем обсуждать синтаксис
[50:19.000 --> 50:21.000]  ИФА сейчас. Вот мы правда
[50:21.000 --> 50:23.000]  хотим этим заниматься? Я думаю, нет.
[50:23.000 --> 50:25.000]  Мы не пишем точку с запятой после
[50:25.000 --> 50:27.000]  последней скобочки. Вот у вас
[50:27.000 --> 50:29.000]  фигурная скобочка.
[50:29.000 --> 50:31.000]  Так.
[50:31.000 --> 50:33.000]  Идем дальше.
[50:33.000 --> 50:35.000]  А...
[50:35.000 --> 50:37.000]  Тип непонятный.
[50:37.000 --> 50:39.000]  Мы должны написать явно,
[50:39.000 --> 50:41.000]  если мы хотим возвращать разные типы.
[50:41.000 --> 50:43.000]  Ну, вообще, конечно, это плохой код style,
[50:43.000 --> 50:45.000]  если у нас лямбда возвращает разные типы потенциально.
[50:45.000 --> 50:47.000]  Вот.
[50:47.000 --> 50:49.000]  Если мы так
[50:49.000 --> 50:51.000]  напишем, то оно скомпилируется,
[50:51.000 --> 50:53.000]  но теперь вот это будет конвертироваться
[50:53.000 --> 50:55.000]  не явно в int. Ну, то есть здесь мог бы быть double,
[50:55.000 --> 50:57.000]  и тогда он бы не явно конвертировался в int.
[50:57.000 --> 50:59.000]  В пятый раз
[50:59.000 --> 51:01.000]  прошу не говорить вслух громко,
[51:01.000 --> 51:03.000]  пока вы там между собой общаетесь.
[51:03.000 --> 51:05.000]  А...
[51:05.000 --> 51:07.000]  Явно написали возвращаемый тип.
[51:07.000 --> 51:09.000]  Разумеется, я мог бы написать
[51:09.000 --> 51:11.000]  возвращаемый тип, который
[51:11.000 --> 51:13.000]  является каким-то сложным, то есть я мог бы написать
[51:13.000 --> 51:15.000]  декл-тайп
[51:15.000 --> 51:17.000]  от чего-нибудь здесь,
[51:17.000 --> 51:19.000]  какого-нибудь там выражения,
[51:19.000 --> 51:21.000]  например, от x плюс y.
[51:21.000 --> 51:23.000]  Вот. И это бы тоже скомпилировалось.
[51:23.000 --> 51:25.000]  Возвращаемым типом был бы int.
[51:25.000 --> 51:27.000]  Вот.
[51:27.000 --> 51:29.000]  Вот. Ну, хорошо.
[51:29.000 --> 51:31.000]  Кстати,
[51:31.000 --> 51:33.000]  я не уверен, могу ли я здесь писать декл-тайп
[51:33.000 --> 51:35.000]  от авто. Думаю,
[51:35.000 --> 51:37.000]  не могу. Но давайте проверим.
[51:37.000 --> 51:39.000]  Нет, могу.
[51:39.000 --> 51:41.000]  Потому что, ну,
[51:41.000 --> 51:43.000]  могу, он просто будет ссылку тогда возвращать.
[51:43.000 --> 51:45.000]  Ну, типа...
[51:45.000 --> 51:47.000]  Вот так я могу написать?
[51:47.000 --> 51:49.000]  Интересно.
[51:49.000 --> 51:51.000]  А.
[51:53.000 --> 51:55.000]  Могу.
[51:55.000 --> 51:57.000]  Могу и так. То есть я могу сказать здесь,
[51:57.000 --> 51:59.000]  ну, то есть я могу попросить его
[51:59.000 --> 52:01.000]  возвращать не авто, что он делает по умолчанию,
[52:01.000 --> 52:03.000]  а авто-амперсант. Или декл-тайп
[52:03.000 --> 52:05.000]  от авто. И тогда он просто будет применять те
[52:05.000 --> 52:07.000]  правила вывода типов, которые применялись бы,
[52:07.000 --> 52:09.000]  если бы это была обычная функция с таким возвращаемым типом.
[52:09.000 --> 52:11.000]  Ну, да.
[52:11.000 --> 52:13.000]  Получается так, да.
[52:13.000 --> 52:15.000]  Хорошо.
[52:17.000 --> 52:19.000]  Еще пара
[52:19.000 --> 52:21.000]  маленьких замечаний, и пункт
[52:21.000 --> 52:23.000]  на этом закончен.
[52:23.000 --> 52:25.000]  Вот этот вот expression,
[52:25.000 --> 52:27.000]  вот этот вот expression,
[52:27.000 --> 52:29.000]  да, начиная от квадратных скобок,
[52:29.000 --> 52:31.000]  заканчивая закрывающей фигурной скобкой,
[52:31.000 --> 52:33.000]  называется closure, замыканием.
[52:39.000 --> 52:41.000]  Вот.
[52:41.000 --> 52:43.000]  Такое название.
[52:43.000 --> 52:45.000]  Нет, вру.
[52:45.000 --> 52:47.000]  Замыканием называется не expression,
[52:47.000 --> 52:49.000]  а его тип как раз.
[52:49.000 --> 52:51.000]  Вот тип, вот тип этого expression
[52:51.000 --> 52:53.000]  называется замыканием.
[52:53.000 --> 52:55.000]  Ну, это определение,
[52:55.000 --> 52:57.000]  пришедшее из функционального
[52:57.000 --> 52:59.000]  программирования.
[52:59.000 --> 53:01.000]  К сожалению, не могу дать никаких коммента...
[53:01.000 --> 53:03.000]  не могу дать никаких комментариев, просто
[53:03.000 --> 53:05.000]  вы можете встречать в тексте
[53:05.000 --> 53:07.000]  в тексте там какого-нибудь
[53:07.000 --> 53:09.000]  переференс или, значит,
[53:09.000 --> 53:11.000]  каких-нибудь статей на хабре
[53:11.000 --> 53:13.000]  каких-нибудь стандартов,
[53:13.000 --> 53:15.000]  вы будете встречать такое слово closure.
[53:15.000 --> 53:17.000]  Что такое closure? Это как раз то,
[53:17.000 --> 53:19.000]  что получается в результате генерации
[53:19.000 --> 53:21.000]  лямбда функции. Вот closure
[53:21.000 --> 53:23.000]  это тип того, что получается.
[53:23.000 --> 53:25.000]  Все такие типы называются типами замыканиями.
[53:25.000 --> 53:27.000]  Это просто такой вид типа.
[53:27.000 --> 53:29.000]  Да, тип
[53:29.000 --> 53:31.000]  вот этого выражения это замыкание.
[53:31.000 --> 53:33.000]  Ну, они могут быть разными,
[53:33.000 --> 53:35.000]  разные лямбды, разные замыкания.
[53:35.000 --> 53:37.000]  И одинаковые лямбды, разные замыкания.
[53:37.000 --> 53:39.000]  И одинаковые лямбы, разные замыкания.
[53:39.000 --> 53:41.000]  Вот.
[53:41.000 --> 53:43.000]  И последнее. Нет, предпоследнее.
[53:43.000 --> 53:45.000]  А
[53:45.000 --> 53:47.000]  лямбду можно прямо на месте вызывать.
[53:47.000 --> 53:49.000]  Например,
[53:49.000 --> 53:51.000]  давайте
[53:51.000 --> 53:53.000]  я вот здесь уберу возвращаемый тип
[53:53.000 --> 53:55.000]  и напишу вот так.
[53:59.000 --> 54:01.000]  Какой тип будет у f
[54:01.000 --> 54:03.000]  сейчас?
[54:03.000 --> 54:07.000]  Да, это правда.
[54:07.000 --> 54:09.000]  Ну, я могу вот так сделать.
[54:11.000 --> 54:13.000]  Нет. А, ну да.
[54:13.000 --> 54:15.000]  Все еще непонятно, что возвращать.
[54:15.000 --> 54:17.000]  Но давайте вот так сделаю. Вот сейчас f будет
[54:17.000 --> 54:19.000]  и типа int.
[54:19.000 --> 54:21.000]  Потому что я сразу же вызвал лямбду на месте.
[54:21.000 --> 54:23.000]  Вот.
[54:23.000 --> 54:25.000]  А вот здесь
[54:25.000 --> 54:27.000]  конечно же так писать нельзя.
[54:27.000 --> 54:29.000]  Если я так напишу, то будет c и e. Кстати, это отличный вопрос
[54:29.000 --> 54:31.000]  для зачета на оценку
[54:31.000 --> 54:33.000]  3. Типа, что будет,
[54:33.000 --> 54:35.000]  если здесь круглые скобки написать и почему так.
[54:35.000 --> 54:37.000]  Да.
[54:37.000 --> 54:39.000]  Это immediate invocation.
[54:39.000 --> 54:41.000]  Кстати, есть такой мем,
[54:41.000 --> 54:43.000]  что c++11 можно написать вот так.
[54:43.000 --> 54:45.000]  И это корректный код.
[54:49.000 --> 54:51.000]  Это не просто все скобки подряд,
[54:51.000 --> 54:53.000]  это еще добивающие в конце.
[54:55.000 --> 54:57.000]  Вот.
[54:57.000 --> 54:59.000]  Ну, это лямбда,
[54:59.000 --> 55:01.000]  которая ничего не принимает, ничего не делает
[55:01.000 --> 55:03.000]  и сразу же выполняется.
[55:05.000 --> 55:07.000]  Да, это правда.
[55:07.000 --> 55:09.000]  Но вот так смешнее.
[55:13.000 --> 55:15.000]  Вот.
[55:15.000 --> 55:17.000]  И последнее, что я скажу в этом пункте,
[55:17.000 --> 55:19.000]  я бы хотел вам
[55:19.000 --> 55:21.000]  озвучить
[55:21.000 --> 55:23.000]  один пример
[55:23.000 --> 55:25.000]  использования лямбды неочевидный, который
[55:25.000 --> 55:27.000]  можно...
[55:27.000 --> 55:29.000]  Ну, который, во-первых, отличная
[55:29.000 --> 55:31.000]  задача для экзамена
[55:31.000 --> 55:33.000]  или для собеседования, а во-вторых,
[55:33.000 --> 55:35.000]  просто чтобы расширить кругозор,
[55:35.000 --> 55:37.000]  так сказать, что лямбды
[55:37.000 --> 55:39.000]  использовать можно не только когда вам надо
[55:39.000 --> 55:41.000]  куда-то отдать функциональный объект.
[55:41.000 --> 55:43.000]  Их можно, например, использовать
[55:43.000 --> 55:45.000]  вот для чего. Представьте, что
[55:45.000 --> 55:47.000]  мне нужно проинцелизировать,
[55:47.000 --> 55:49.000]  мне нужно завести некоторый const int
[55:51.000 --> 55:53.000]  равный, но чтобы
[55:53.000 --> 55:55.000]  его вычислить, нужно сделать сложные
[55:55.000 --> 55:57.000]  какие-то манипуляции. То есть мне нужно завести
[55:57.000 --> 55:59.000]  константную перемену какой-то типа,
[55:59.000 --> 56:01.000]  но я не могу сразу сказать, чему она должна быть равна.
[56:01.000 --> 56:03.000]  Я должен сделать каких-то много вызовов функций
[56:03.000 --> 56:05.000]  и то, что получится в результате, объявить
[56:05.000 --> 56:07.000]  константной переменной.
[56:07.000 --> 56:09.000]  Что я должен... Что я могу тогда сделать?
[56:09.000 --> 56:11.000]  А я могу сказать
[56:11.000 --> 56:13.000]  лямбда
[56:13.000 --> 56:15.000]  тут что-то повычислять,
[56:15.000 --> 56:17.000]  return там
[56:17.000 --> 56:19.000]  что-то и сразу же выполнить.
[56:19.000 --> 56:21.000]  Вот это пример, когда immediate
[56:21.000 --> 56:23.000]  invocation может быть полезно.
[56:23.000 --> 56:25.000]  Чтобы не...
[56:25.000 --> 56:27.000]  Ну, то есть чтобы вот
[56:27.000 --> 56:29.000]  вычисление значения какой-то переменной,
[56:29.000 --> 56:31.000]  что вы хотите сделать константной,
[56:31.000 --> 56:33.000]  выделить в отдельную штуку,
[56:33.000 --> 56:35.000]  но не создавать отдельную функцию под это.
[56:35.000 --> 56:37.000]  Прямо на месте создали
[56:37.000 --> 56:39.000]  какие-то вычисления и вычислили.
[56:39.000 --> 56:41.000]  И объявили константную перемену такого типа.
[56:41.000 --> 56:43.000]  Вот, например, когда immediate invocation
[56:43.000 --> 56:45.000]  может быть полезно.
[56:45.000 --> 56:47.000]  И это, например, полезно
[56:47.000 --> 56:49.000]  еще, когда у вас есть список
[56:49.000 --> 56:51.000]  инициализации конструктора,
[56:51.000 --> 56:53.000]  и там вам надо какую-нибудь ссылку инициализировать
[56:53.000 --> 56:55.000]  в полях, но вы не можете сразу сказать,
[56:55.000 --> 56:57.000]  чем инициализировать, вам опять нужно какие-то длинные вычисления,
[56:57.000 --> 56:59.000]  чтобы сказать, чему она равна. Вы пишете там
[56:59.000 --> 57:01.000]  x в скобочках и вы должны
[57:01.000 --> 57:03.000]  пронициализировать чем-то. Тогда вы опять можете
[57:03.000 --> 57:05.000]  лямбду, в ней написать какой-то код
[57:05.000 --> 57:07.000]  и сразу выполнить круглые скобочки.
[57:07.000 --> 57:09.000]  И вернуть эту штуку.
[57:09.000 --> 57:11.000]  Вот это immediate invocation полезная
[57:11.000 --> 57:13.000]  штука.
[57:13.000 --> 57:15.000]  Хорошо.
[57:15.000 --> 57:17.000]  Это базовые примеры.
[57:17.000 --> 57:19.000]  Теперь давайте будут примеры поинтереснее.
[57:23.000 --> 57:25.000]  Следующий
[57:25.000 --> 57:27.000]  параграф это
[57:27.000 --> 57:29.000]  захват в лямбду.
[57:31.000 --> 57:33.000]  Как раз об этом сейчас
[57:33.000 --> 57:35.000]  будет разговор.
[57:39.000 --> 57:41.000]  Сейчас об этом и будет
[57:41.000 --> 57:43.000]  разговор.
[57:43.000 --> 57:45.000]  Пункт 13.2 называется
[57:45.000 --> 57:47.000]  захват в лямбду.
[57:49.000 --> 57:51.000]  Capture lists in lambdas, ну или captures
[57:51.000 --> 57:53.000]  просто. Вот.
[57:55.000 --> 57:57.000]  В этом пункте разговор
[57:57.000 --> 57:59.000]  пойдет про то, что вот эти квадратные
[57:59.000 --> 58:01.000]  скобочки на самом деле за собой таят.
[58:01.000 --> 58:03.000]  Вот они неспроста.
[58:03.000 --> 58:05.000]  Давайте я вот это все удалю
[58:05.000 --> 58:07.000]  и начну писать что-нибудь
[58:07.000 --> 58:09.000]  заново.
[58:11.000 --> 58:13.000]  Отвратительный подход. По код стайлу
[58:13.000 --> 58:15.000]  будем банить такое, если что.
[58:15.000 --> 58:17.000]  Значит, эта штука вообще
[58:17.000 --> 58:19.000]  deprecated по-моему даже и
[58:19.000 --> 58:21.000]  хороший компилятор ругается на
[58:21.000 --> 58:23.000]  когда вы амперсант в квадратных
[58:23.000 --> 58:25.000]  скобках пишете.
[58:29.000 --> 58:31.000]  Сейчас расскажу.
[58:31.000 --> 58:33.000]  Смотрите.
[58:35.000 --> 58:37.000]  Иногда мне в лямбде может потребоваться
[58:37.000 --> 58:39.000]  использовать какие-то переменные из внешней
[58:39.000 --> 58:41.000]  области видимости.
[58:43.000 --> 58:45.000]  Да, ну вот опять
[58:45.000 --> 58:47.000]  давайте я возьму
[58:47.000 --> 58:49.000]  блин, зря я все удалил.
[58:49.000 --> 58:51.000]  Нет, давайте все-таки я не все удалю,
[58:51.000 --> 58:53.000]  а вот эту лямбду все-таки оставлю.
[58:53.000 --> 58:55.000]  Вот тут, допустим, я хочу
[58:59.000 --> 59:01.000]  я хочу здесь
[59:03.000 --> 59:05.000]  ну, учебный пример.
[59:05.000 --> 59:07.000]  Я хочу сравнивать
[59:07.000 --> 59:09.000]  я хочу, чтобы это был такой компиратор,
[59:09.000 --> 59:11.000]  который проверяет
[59:13.000 --> 59:15.000]  вот что-нибудь такое.
[59:17.000 --> 59:19.000]  И вот эта пятерка, это
[59:19.000 --> 59:21.000]  внешний параметр такой.
[59:21.000 --> 59:23.000]  Я хочу компиратор по признаку
[59:23.000 --> 59:25.000]  насколько эти два числа, кто из них дальше
[59:25.000 --> 59:27.000]  от точки напрямой.
[59:27.000 --> 59:29.000]  Такой компиратор.
[59:29.000 --> 59:31.000]  Но эта точка напрямая
[59:31.000 --> 59:33.000]  она тоже является некоторым параметром.
[59:35.000 --> 59:37.000]  И она не должна быть параметром
[59:37.000 --> 59:39.000]  самого компиратора.
[59:39.000 --> 59:41.000]  Я не хочу ее передавать как параметр функцию,
[59:41.000 --> 59:43.000]  потому что функция двух переменных.
[59:43.000 --> 59:45.000]  Я ее, допустим, хочу отдать в сортировку,
[59:45.000 --> 59:47.000]  а в сортировке я должен сравнивать два числа.
[59:47.000 --> 59:49.000]  Но в этой функции мне нужно использовать
[59:49.000 --> 59:51.000]  еще какие-то внешние данные,
[59:51.000 --> 59:53.000]  которые не являются параметрами функций.
[59:53.000 --> 59:55.000]  Что мне тогда делать?
[59:55.000 --> 59:57.000]  А тогда мне нужно их захватить в лямбду.
[59:57.000 --> 59:59.000]  Это называется capture.
[59:59.000 --> 01:00:01.000]  Вот если я просто так напишу здесь
[01:00:01.000 --> 01:00:03.000]  использовать, начну эту переменную,
[01:00:03.000 --> 01:00:05.000]  то у меня будет CE.
[01:00:05.000 --> 01:00:07.000]  Потому что нельзя в лямбде
[01:00:07.000 --> 01:00:09.000]  использовать
[01:00:09.000 --> 01:00:11.000]  необъявленную переменную.
[01:00:11.000 --> 01:00:13.000]  Необъявленную переменную, да.
[01:00:13.000 --> 01:00:15.000]  Внутри лямбды ее не существует.
[01:00:17.000 --> 01:00:19.000]  Mid – это переменная,
[01:00:19.000 --> 01:00:21.000]  которая не существует
[01:00:21.000 --> 01:00:23.000]  с точки зрения лямбды.
[01:00:23.000 --> 01:00:25.000]  Ну, с точки зрения лямбды,
[01:00:25.000 --> 01:00:27.000]  если бы вот здесь
[01:00:27.000 --> 01:00:29.000]  была какая-то переменная Mid,
[01:00:29.000 --> 01:00:31.000]  то она бы существовала.
[01:00:31.000 --> 01:00:33.000]  Глобальной переменной использовать можно.
[01:00:37.000 --> 01:00:39.000]  А он пытается локально его сожрать,
[01:00:39.000 --> 01:00:41.000]  потому что с таким же названием есть.
[01:00:41.000 --> 01:00:43.000]  Так, сейчас. Нет, подожди, подожди, подожди.
[01:00:47.000 --> 01:00:49.000]  Сейчас.
[01:00:57.000 --> 01:00:59.000]  А, я понял.
[01:00:59.000 --> 01:01:01.000]  Он
[01:01:01.000 --> 01:01:03.000]  локально как бы затмевает глобальную,
[01:01:03.000 --> 01:01:05.000]  да, но при этом локально он не может
[01:01:05.000 --> 01:01:07.000]  использовать, и поэтому такая ошибка. Очень весело.
[01:01:07.000 --> 01:01:09.000]  Но вот глобальную использовать можно,
[01:01:09.000 --> 01:01:11.000]  а из-за конфликта имен было нельзя.
[01:01:11.000 --> 01:01:13.000]  Глобальную использовать можно.
[01:01:13.000 --> 01:01:15.000]  Но локальные переменные, если вы не захватили
[01:01:15.000 --> 01:01:17.000]  их, использовать вы не можете.
[01:01:17.000 --> 01:01:19.000]  А что значит захватить?
[01:01:19.000 --> 01:01:21.000]  Ну, мне надо написать.
[01:01:21.000 --> 01:01:23.000]  Давайте, чтобы не было конфликта имен,
[01:01:23.000 --> 01:01:25.000]  я вот здесь вот этот раз закомментирую.
[01:01:25.000 --> 01:01:27.000]  Я должен вот здесь в квадратных скобочках
[01:01:27.000 --> 01:01:29.000]  написать, что я захватываю. В данном
[01:01:29.000 --> 01:01:31.000]  случае Mid.
[01:01:31.000 --> 01:01:33.000]  Я прямо в квадратных скобочках
[01:01:33.000 --> 01:01:35.000]  указываю переменные, которые я
[01:01:35.000 --> 01:01:37.000]  захватываю. Это называется Capture.
[01:01:37.000 --> 01:01:39.000]  Я могу захватить несколько
[01:01:39.000 --> 01:01:41.000]  переменных.
[01:01:45.000 --> 01:01:47.000]  Я не знаю, вот здесь будет...
[01:01:47.000 --> 01:01:49.000]  Я уже не уверен, что это корректный компаратор,
[01:01:49.000 --> 01:01:51.000]  но...
[01:01:51.000 --> 01:01:53.000]  Можно, сейчас все будет.
[01:01:53.000 --> 01:01:55.000]  Я могу
[01:01:55.000 --> 01:01:57.000]  захватить несколько переменных.
[01:01:57.000 --> 01:01:59.000]  Тогда я через запятую их указываю.
[01:02:01.000 --> 01:02:03.000]  Вот.
[01:02:03.000 --> 01:02:05.000]  Ну ладно.
[01:02:07.000 --> 01:02:09.000]  Ну, допустим,
[01:02:09.000 --> 01:02:11.000]  я хочу
[01:02:11.000 --> 01:02:13.000]  сравнивать не
[01:02:13.000 --> 01:02:15.000]  инты, а строки.
[01:02:19.000 --> 01:02:21.000]  И тогда возникает
[01:02:21.000 --> 01:02:23.000]  логичная проблема.
[01:02:23.000 --> 01:02:25.000]  Мне захватывать по значению
[01:02:25.000 --> 01:02:27.000]  или по ссылке?
[01:02:27.000 --> 01:02:29.000]  Да.
[01:02:33.000 --> 01:02:35.000]  Это как раз тот вопрос, на который
[01:02:35.000 --> 01:02:37.000]  я сейчас и собираюсь отвечать.
[01:02:37.000 --> 01:02:39.000]  Я говорю, вот
[01:02:39.000 --> 01:02:41.000]  представь, что я бы не инты сравнивала
[01:02:41.000 --> 01:02:43.000]  строки.
[01:02:43.000 --> 01:02:45.000]  Тогда
[01:02:45.000 --> 01:02:47.000]  у меня возникает вопрос.
[01:02:47.000 --> 01:02:49.000]  А если у меня вот это Mid, которое
[01:02:49.000 --> 01:02:51.000]  захватываю, является строкой?
[01:02:53.000 --> 01:02:55.000]  Ну, я...
[01:02:55.000 --> 01:02:57.000]  Давайте, наверное, все буду все-таки...
[01:02:57.000 --> 01:02:59.000]  Допустим, короче, мне
[01:02:59.000 --> 01:03:01.000]  строка нужна для того, чтобы
[01:03:01.000 --> 01:03:03.000]  два инта сравнить. Не знаю, вот я хочу...
[01:03:03.000 --> 01:03:05.000]  Ну, давайте какой-нибудь пример
[01:03:05.000 --> 01:03:07.000]  придумаем, для чего мне может быть нужна строка в сравнении
[01:03:07.000 --> 01:03:09.000]  двух интов.
[01:03:17.000 --> 01:03:19.000]  Ну, не знаю, допустим...
[01:03:29.000 --> 01:03:31.000]  Ну, строка вот...
[01:03:31.000 --> 01:03:33.000]  Ладно, не хочу придумать пример.
[01:03:33.000 --> 01:03:35.000]  Просто хочу захватить строку.
[01:03:35.000 --> 01:03:37.000]  Вот у меня...
[01:03:37.000 --> 01:03:39.000]  Вот у меня есть строка.
[01:03:39.000 --> 01:03:41.000]  И я хочу ее...
[01:03:45.000 --> 01:03:47.000]  Вот, и я хочу...
[01:03:53.000 --> 01:03:55.000]  Да, класс.
[01:03:55.000 --> 01:03:57.000]  Вот я хочу, короче, так делать.
[01:03:57.000 --> 01:03:59.000]  Я хочу спрашивать
[01:03:59.000 --> 01:04:01.000]  s.subster
[01:04:05.000 --> 01:04:07.000]  Я не знаю.
[01:04:07.000 --> 01:04:09.000]  0.x
[01:04:09.000 --> 01:04:11.000]  меньше, чем
[01:04:11.000 --> 01:04:13.000]  s.subster
[01:04:15.000 --> 01:04:17.000]  s.size
[01:04:17.000 --> 01:04:19.000]  минус
[01:04:19.000 --> 01:04:21.000]  y.y
[01:04:23.000 --> 01:04:25.000]  Так, по-моему, да, начиная с какого символа
[01:04:25.000 --> 01:04:27.000]  и сколько символов.
[01:04:27.000 --> 01:04:29.000]  Я хочу проверить, правда ли
[01:04:29.000 --> 01:04:31.000]  префикс этой строки длины x
[01:04:31.000 --> 01:04:33.000]  графически меньше, чем
[01:04:33.000 --> 01:04:35.000]  суффикс этой строки длины y.
[01:04:35.000 --> 01:04:37.000]  Очень полезная функция.
[01:04:37.000 --> 01:04:39.000]  Так вот.
[01:04:39.000 --> 01:04:41.000]  Ничего только не бывает в Олимпиадах по программированию, правда?
[01:04:43.000 --> 01:04:45.000]  Мне подарили массив.
[01:04:47.000 --> 01:04:49.000]  Филипп очень любит задачи про строки,
[01:04:49.000 --> 01:04:51.000]  и он уже решил все задачи,
[01:04:51.000 --> 01:04:53.000]  поэтому решил придумать свою.
[01:04:57.000 --> 01:04:59.000]  Массив строк?
[01:04:59.000 --> 01:05:01.000]  Поэтому он попросил
[01:05:01.000 --> 01:05:03.000]  на день рождения массив строк,
[01:05:03.000 --> 01:05:05.000]  и дальше он стал с ним делать следующую операцию.
[01:05:05.000 --> 01:05:07.000]  Так вот.
[01:05:09.000 --> 01:05:11.000]  Мне надо строку в лямбду захватить.
[01:05:11.000 --> 01:05:13.000]  Господи, что я сделал?
[01:05:13.000 --> 01:05:15.000]  Мне нужно захватить строку в лямбду.
[01:05:15.000 --> 01:05:17.000]  Но если я напишу вот так,
[01:05:17.000 --> 01:05:19.000]  как вы думаете, она по значению или по ссылке
[01:05:19.000 --> 01:05:21.000]  захватится? То есть она скопируется в лямбду
[01:05:21.000 --> 01:05:23.000]  или нет?
[01:05:23.000 --> 01:05:25.000]  Правильный ответ скопируется.
[01:05:25.000 --> 01:05:27.000]  Почему четыре-то?
[01:05:27.000 --> 01:05:29.000]  Один раз скопируется.
[01:05:29.000 --> 01:05:31.000]  Ну вот. Прямо сейчас один раз скопируется.
[01:05:33.000 --> 01:05:35.000]  А как делать, чтобы она
[01:05:35.000 --> 01:05:37.000]  не копировалась?
[01:05:37.000 --> 01:05:39.000]  Надо захватить по ссылке.
[01:05:39.000 --> 01:05:41.000]  Как захватить по ссылке?
[01:05:41.000 --> 01:05:43.000]  А вот так.
[01:05:43.000 --> 01:05:45.000]  Амперсант перед именем надо поставить.
[01:05:45.000 --> 01:05:47.000]  То есть надо
[01:05:47.000 --> 01:05:49.000]  поставить амперсант перед именем переменной,
[01:05:49.000 --> 01:05:51.000]  когда вы ее захватываете.
[01:05:51.000 --> 01:05:53.000]  Амперсант и имперсант.
[01:05:53.000 --> 01:05:55.000]  Нет, нет, нет.
[01:05:55.000 --> 01:05:57.000]  Нет, нет, нет.
[01:05:57.000 --> 01:05:59.000]  Это
[01:05:59.000 --> 01:06:01.000]  CE будет. Значит, захватывать
[01:06:01.000 --> 01:06:03.000]  можно либо по значению,
[01:06:03.000 --> 01:06:05.000]  либо по ссылке. У вас есть два варианта,
[01:06:05.000 --> 01:06:07.000]  чего вы можете написать. Вы можете написать либо имя
[01:06:07.000 --> 01:06:09.000]  переменной, либо амперсант имя переменной.
[01:06:09.000 --> 01:06:11.000]  И все это через запятую. Других способов
[01:06:11.000 --> 01:06:13.000]  пока нет, но там есть еще
[01:06:13.000 --> 01:06:15.000]  кое-что, но мы потом обсудим.
[01:06:15.000 --> 01:06:17.000]  Нет, так нельзя.
[01:06:17.000 --> 01:06:19.000]  Вот.
[01:06:21.000 --> 01:06:23.000]  Хорошо.
[01:06:33.000 --> 01:06:35.000]  Давайте затестим.
[01:06:35.000 --> 01:06:37.000]  Давайте я верну все-таки
[01:06:37.000 --> 01:06:39.000]  mid
[01:06:39.000 --> 01:06:41.000]  и буду здесь
[01:06:41.000 --> 01:06:43.000]  все-таки сравнивать.
[01:06:47.000 --> 01:06:49.000]  Это лекция о том,
[01:06:49.000 --> 01:06:51.000]  как играет
[01:06:51.000 --> 01:06:53.000]  компаратор.
[01:06:53.000 --> 01:06:55.000]  Буду здесь сравнивать вот это.
[01:06:55.000 --> 01:06:57.000]  Но
[01:06:57.000 --> 01:06:59.000]  я буду
[01:06:59.000 --> 01:07:01.000]  из этой функции менять переменную mid.
[01:07:01.000 --> 01:07:03.000]  И в одном
[01:07:03.000 --> 01:07:05.000]  случае я буду
[01:07:05.000 --> 01:07:07.000]  да,
[01:07:07.000 --> 01:07:09.000]  я буду наблюдать, что
[01:07:09.000 --> 01:07:11.000]  mid меняется, а в другом нет. Правда
[01:07:11.000 --> 01:07:13.000]  сейчас будет
[01:07:13.000 --> 01:07:15.000]  некоторая проблема. Сейчас, короче, вы увидите.
[01:07:15.000 --> 01:07:17.000]  Да, то есть я говорю f от 1
[01:07:17.000 --> 01:07:19.000]  2 и еще раз
[01:07:19.000 --> 01:07:21.000]  mid.
[01:07:23.000 --> 01:07:25.000]  Зачем?
[01:07:27.000 --> 01:07:29.000]  Что-то хотелось.
[01:07:29.000 --> 01:07:31.000]  Вот. Давайте я так
[01:07:31.000 --> 01:07:33.000]  сделаю. Сейчас у меня, правда, наверное, что-нибудь
[01:07:33.000 --> 01:07:35.000]  не скомпилируется. А нет, все скомпилировался. Смотрим.
[01:07:35.000 --> 01:07:37.000]  Изначально было 5, потом стало
[01:07:37.000 --> 01:07:39.000]  6, потому что я mid захватил по ссылке.
[01:07:39.000 --> 01:07:41.000]  И стало быть, когда я меняю mid
[01:07:41.000 --> 01:07:43.000]  внутри функции, я тем самым влияю на локальную
[01:07:43.000 --> 01:07:45.000]  переменную, которая была в этом
[01:07:45.000 --> 01:07:47.000]  в мейне. Ничего удивительного.
[01:07:47.000 --> 01:07:49.000]  Ничего удивительного. Но что
[01:07:49.000 --> 01:07:51.000]  если бы я захватил по значению?
[01:07:51.000 --> 01:07:53.000]  Кто знает, что сейчас будет?
[01:07:53.000 --> 01:07:55.000]  Страшно.
[01:07:55.000 --> 01:07:57.000]  Надеюсь, что я не пострадаю.
[01:07:57.000 --> 01:07:59.000]  Это либо compilation roll, либо
[01:07:59.000 --> 01:08:01.000]  UB. Какой compilation roll?
[01:08:01.000 --> 01:08:03.000]  Все нормально. Просто висит 5,5.
[01:08:03.000 --> 01:08:05.000]  А он создает прям
[01:08:05.000 --> 01:08:07.000]  локальную копию или это будет как?
[01:08:07.000 --> 01:08:09.000]  Значит, правильный ответ будет CE.
[01:08:09.000 --> 01:08:11.000]  Как же я хорош!
[01:08:11.000 --> 01:08:13.000]  Ну иначе
[01:08:13.000 --> 01:08:15.000]  бы я не спрашивал.
[01:08:15.000 --> 01:08:17.000]  Значит,
[01:08:17.000 --> 01:08:19.000]  смотрите,
[01:08:19.000 --> 01:08:21.000]  сейчас вам
[01:08:21.000 --> 01:08:23.000]  придется
[01:08:23.000 --> 01:08:25.000]  с этим смириться,
[01:08:25.000 --> 01:08:27.000]  потому что, к сожалению, я
[01:08:27.000 --> 01:08:29.000]  пока не готов объяснить,
[01:08:29.000 --> 01:08:31.000]  почему такое правило введено в язык.
[01:08:31.000 --> 01:08:33.000]  Но вскоре мы поймем, почему.
[01:08:33.000 --> 01:08:35.000]  Но на самом деле правило следующее.
[01:08:35.000 --> 01:08:37.000]  Если вы захватываете что-то по значению,
[01:08:37.000 --> 01:08:39.000]  то оно по дефолту считается константным.
[01:08:39.000 --> 01:08:41.000]  Это очень странно звучит
[01:08:41.000 --> 01:08:43.000]  на первый взгляд. Казалось бы,
[01:08:43.000 --> 01:08:45.000]  почему не наоборот. То, что мы захватываем
[01:08:45.000 --> 01:08:47.000]  по ссылке, оно не константное.
[01:08:47.000 --> 01:08:49.000]  Мы его и захватывая менять можем.
[01:08:49.000 --> 01:08:51.000]  Но если бы что-то в лямбду захватили
[01:08:51.000 --> 01:08:53.000]  по значению,
[01:08:53.000 --> 01:08:55.000]  то оно константное.
[01:08:55.000 --> 01:08:57.000]  Оно скопировалось,
[01:08:57.000 --> 01:08:59.000]  и при этом оно константным стало.
[01:08:59.000 --> 01:09:01.000]  Честно скопировалось
[01:09:01.000 --> 01:09:03.000]  и стало константным.
[01:09:03.000 --> 01:09:07.000]  Конст и редонли это разные вещи?
[01:09:07.000 --> 01:09:09.000]  Нет, редонли
[01:09:09.000 --> 01:09:11.000]  потому что конст.
[01:09:11.000 --> 01:09:13.000]  Оно константное.
[01:09:17.000 --> 01:09:19.000]  Вот, мы объясним это
[01:09:19.000 --> 01:09:21.000]  видимо сегодня уже не успеем.
[01:09:21.000 --> 01:09:23.000]  Нет, может и успеем, кстати.
[01:09:23.000 --> 01:09:25.000]  В общем, вскоре мы поймем,
[01:09:25.000 --> 01:09:27.000]  почему так, но пока просто поверим.
[01:09:27.000 --> 01:09:29.000]  Тем не менее, есть
[01:09:29.000 --> 01:09:31.000]  способ этого избежать.
[01:09:31.000 --> 01:09:33.000]  Как же мне захватить что-то по значению,
[01:09:33.000 --> 01:09:35.000]  чтобы его можно было менять?
[01:09:35.000 --> 01:09:37.000]  Для этого есть слово mutable.
[01:09:37.000 --> 01:09:39.000]  Я могу написать mutable,
[01:09:39.000 --> 01:09:41.000]  но его надо написать после сигнатуры.
[01:09:43.000 --> 01:09:45.000]  Слева, если мне нужно
[01:09:45.000 --> 01:09:47.000]  явный тип возвращить, то вот так.
[01:09:55.000 --> 01:09:57.000]  К сожалению, так не выйдет.
[01:10:01.000 --> 01:10:03.000]  Можно перед аргументом
[01:10:03.000 --> 01:10:05.000]  конст мид написать?
[01:10:05.000 --> 01:10:07.000]  То есть нельзя перед мид написать
[01:10:07.000 --> 01:10:09.000]  конст мид?
[01:10:09.000 --> 01:10:11.000]  Нет, нельзя, я уже говорил.
[01:10:13.000 --> 01:10:15.000]  Это какой-то избират, честно говоря.
[01:10:15.000 --> 01:10:17.000]  Вот, теперь будет 5,5.
[01:10:17.000 --> 01:10:19.000]  То есть теперь все работает,
[01:10:19.000 --> 01:10:21.000]  компилируется и...
[01:10:21.000 --> 01:10:23.000]  Ну да, мы же скопировали
[01:10:23.000 --> 01:10:25.000]  и то, что мы меняем
[01:10:25.000 --> 01:10:27.000]  внутри функции, не влияет на исходную переменду.
[01:10:27.000 --> 01:10:29.000]  Она могла скопироваться
[01:10:29.000 --> 01:10:31.000]  на все вызовы функций.
[01:10:31.000 --> 01:10:33.000]  Сиаут мид внутри функции, пожалуйста.
[01:10:33.000 --> 01:10:35.000]  Чего? Сиаут мид внутри функции?
[01:10:35.000 --> 01:10:37.000]  Ну, где здесь?
[01:10:37.000 --> 01:10:39.000]  Ну, 6 будет.
[01:10:39.000 --> 01:10:41.000]  Два раза?
[01:10:41.000 --> 01:10:43.000]  Да.
[01:10:47.000 --> 01:10:49.000]  Нет, один раз.
[01:10:49.000 --> 01:10:51.000]  Ну, потому что мы вызываем один.
[01:10:53.000 --> 01:10:55.000]  А!
[01:10:55.000 --> 01:10:57.000]  Я понял вопрос.
[01:10:57.000 --> 01:10:59.000]  Если я второй раз вызову,
[01:10:59.000 --> 01:11:01.000]  тогда будет... Ну, давай подумаем.
[01:11:01.000 --> 01:11:03.000]  Ну, 7, значит, будет,
[01:11:03.000 --> 01:11:05.000]  потому что в ней она хранится,
[01:11:05.000 --> 01:11:07.000]  старое значение хранится между вызовами.
[01:11:11.000 --> 01:11:13.000]  Конечно, она копию создала
[01:11:13.000 --> 01:11:15.000]  и сохранила у себя в объекте.
[01:11:15.000 --> 01:11:17.000]  Лямбда функция – это объект.
[01:11:17.000 --> 01:11:19.000]  А зачем она это сделала?
[01:11:19.000 --> 01:11:21.000]  Ну, мы вроде немножко
[01:11:21.000 --> 01:11:23.000]  не змеи заклинаем туда.
[01:11:25.000 --> 01:11:27.000]  То есть она как бы статическая?
[01:11:27.000 --> 01:11:29.000]  Как будто бы статическая.
[01:11:29.000 --> 01:11:31.000]  Почему статическая?
[01:11:31.000 --> 01:11:33.000]  Она просто хранится в объекте, как поле.
[01:11:33.000 --> 01:11:35.000]  Причем почему статическая?
[01:11:35.000 --> 01:11:37.000]  Оно не общее на все объекты такого типа.
[01:11:37.000 --> 01:11:39.000]  Оно для данного объекта.
[01:11:39.000 --> 01:11:41.000]  Нет, объект не обязательно один.
[01:11:41.000 --> 01:11:43.000]  Я могу написать
[01:11:43.000 --> 01:11:45.000]  авто f2 равно f.
[01:11:45.000 --> 01:11:47.000]  Я могу написать
[01:11:47.000 --> 01:11:49.000]  авто f2 равно f.
[01:11:49.000 --> 01:11:51.000]  Что, можно?
[01:11:51.000 --> 01:11:53.000]  В смысле, я могу создать такой...
[01:11:53.000 --> 01:11:55.000]  Это будет один и тот же тип,
[01:11:55.000 --> 01:11:57.000]  но разные объекты.
[01:11:57.000 --> 01:11:59.000]  Я не говорил, что лямбда функция такого тип
[01:11:59.000 --> 01:12:01.000]  может существовать только одна.
[01:12:01.000 --> 01:12:03.000]  Если я напишу дословный такую же лямбда функцию,
[01:12:03.000 --> 01:12:05.000]  это будет другой тип.
[01:12:05.000 --> 01:12:07.000]  Но если я напишу авто f2 равно f,
[01:12:07.000 --> 01:12:09.000]  то это будет вторая лямбда функция точно такого же типа.
[01:12:09.000 --> 01:12:11.000]  Это за что?
[01:12:11.000 --> 01:12:13.000]  Чего?
[01:12:13.000 --> 01:12:15.000]  Если мы несколько переменных указываем,
[01:12:15.000 --> 01:12:17.000]  мы мьютабел пишем один раз
[01:12:17.000 --> 01:12:19.000]  после сигнатуры.
[01:12:19.000 --> 01:12:21.000]  Мьютабел на всю лямбда функцию.
[01:12:21.000 --> 01:12:23.000]  А можно наследовать?
[01:12:23.000 --> 01:12:25.000]  Кого?
[01:12:25.000 --> 01:12:27.000]  От кого?
[01:12:27.000 --> 01:12:29.000]  Как?
[01:12:29.000 --> 01:12:31.000]  Можно ли сказать...
[01:12:31.000 --> 01:12:33.000]  Можно ли объявить класс S
[01:12:33.000 --> 01:12:35.000]  наследник декл-тайп от...
[01:12:35.000 --> 01:12:37.000]  Объект лямбда, который наследует
[01:12:37.000 --> 01:12:39.000]  тип, который наследует...
[01:12:39.000 --> 01:12:41.000]  Ну смотри, давай я попробую.
[01:12:41.000 --> 01:12:43.000]  Смотри, смотри, давай сделаю.
[01:12:43.000 --> 01:12:45.000]  Ну я не вижу препятствий.
[01:12:45.000 --> 01:12:47.000]  Я глобально говорю авто f
[01:12:47.000 --> 01:12:49.000]  равно вот этому.
[01:12:49.000 --> 01:12:51.000]  А дальше говорю...
[01:12:51.000 --> 01:12:53.000]  Только мид, правда, непонятно, что такое.
[01:12:53.000 --> 01:12:55.000]  Мид придется убрать.
[01:12:55.000 --> 01:12:57.000]  Нет, мид придется...
[01:12:57.000 --> 01:12:59.000]  Да, блин, все придется убрать.
[01:12:59.000 --> 01:13:01.000]  Черт.
[01:13:01.000 --> 01:13:03.000]  Глобально забей уже
[01:13:03.000 --> 01:13:05.000]  и забей.
[01:13:05.000 --> 01:13:07.000]  Так CE все равно, потому что
[01:13:07.000 --> 01:13:09.000]  нельзя захватывать глобальные.
[01:13:09.000 --> 01:13:11.000]  Захватывать может только локальные.
[01:13:11.000 --> 01:13:13.000]  И он не поймет, что такое захват глобальный.
[01:13:13.000 --> 01:13:15.000]  Давайте мид внутри.
[01:13:15.000 --> 01:13:17.000]  Так не захватывай.
[01:13:17.000 --> 01:13:19.000]  Илья, не захватывай.
[01:13:19.000 --> 01:13:21.000]  Делай просто глобальный мид.
[01:13:21.000 --> 01:13:23.000]  Ну так убрать захват в этом и проблема.
[01:13:23.000 --> 01:13:25.000]  Так, все.
[01:13:25.000 --> 01:13:27.000]  Я написал. Теперь я говорю
[01:13:27.000 --> 01:13:29.000]  struct S
[01:13:29.000 --> 01:13:31.000]  паблик декл-тайп
[01:13:31.000 --> 01:13:33.000]  от f.
[01:13:35.000 --> 01:13:37.000]  Нормас.
[01:13:37.000 --> 01:13:39.000]  Кажется, я не вижу препятствий.
[01:13:39.000 --> 01:13:41.000]  Это за мида.
[01:13:41.000 --> 01:13:43.000]  Ну, CE из-за мида, да,
[01:13:43.000 --> 01:13:45.000]  но наследоваться
[01:13:45.000 --> 01:13:47.000]  от лямбда функции можно. Почему нет?
[01:13:47.000 --> 01:13:49.000]  А лямбда функцию можно
[01:13:49.000 --> 01:13:51.000]  от наследования функции?
[01:13:51.000 --> 01:13:53.000]  Как?
[01:13:53.000 --> 01:13:55.000]  Очень громко.
[01:13:55.000 --> 01:13:57.000]  Опять кричите.
[01:13:57.000 --> 01:13:59.000]  Ты слишком громко говоришь. Так, господа,
[01:13:59.000 --> 01:14:01.000]  слишком много вопросов. Идем дальше, мы иначе не успеем
[01:14:01.000 --> 01:14:03.000]  опять. Ну все, у нас дискуссия
[01:14:03.000 --> 01:14:05.000]  какая-то разгорается.
[01:14:05.000 --> 01:14:07.000]  Давайте дальше.
[01:14:07.000 --> 01:14:09.000]  Следующее, что надо сказать.
[01:14:11.000 --> 01:14:13.000]  А что, если мы хотим что-то мувнуть в лямбда функцию?
[01:14:13.000 --> 01:14:15.000]  Да.
[01:14:15.000 --> 01:14:17.000]  Да.
[01:14:21.000 --> 01:14:23.000]  Просто я показал
[01:14:23.000 --> 01:14:25.000]  очень громко.
[01:14:25.000 --> 01:14:27.000]  Просто я показал, что тип лямбда функции
[01:14:27.000 --> 01:14:29.000]  вполне себе нормальный тип, от него можно наследоваться,
[01:14:29.000 --> 01:14:31.000]  в частности, в чем проблема. Ну это такой класс.
[01:14:31.000 --> 01:14:33.000]  Что это класс?
[01:14:35.000 --> 01:14:37.000]  Оператор круглой скобочки, например.
[01:14:37.000 --> 01:14:39.000]  Как и у всех лямбда функций.
[01:14:39.000 --> 01:14:41.000]  Поле?
[01:14:41.000 --> 01:14:43.000]  Поле нет. Он не знает, какие у него
[01:14:43.000 --> 01:14:45.000]  поля.
[01:14:45.000 --> 01:14:47.000]  Идем дальше. Идем дальше.
[01:14:47.000 --> 01:14:49.000]  Как захватить что-то в лямбда функцию
[01:14:49.000 --> 01:14:51.000]  через move?
[01:14:51.000 --> 01:14:53.000]  Вот допустим, я хочу мувнуть строку в лямбда функцию.
[01:14:53.000 --> 01:14:55.000]  Что мне надо сделать?
[01:14:57.000 --> 01:14:59.000]  Да.
[01:14:59.000 --> 01:15:01.000]  Вот это, кстати,
[01:15:01.000 --> 01:15:03.000]  желание, оно в отличие от ваших
[01:15:03.000 --> 01:15:05.000]  тут разных фантазий,
[01:15:05.000 --> 01:15:07.000]  неизращенское.
[01:15:07.000 --> 01:15:09.000]  Мувать что-то в лямбда функцию
[01:15:09.000 --> 01:15:11.000]  бывает нужно.
[01:15:11.000 --> 01:15:13.000]  Например,
[01:15:13.000 --> 01:15:15.000]  если вы находитесь где-то
[01:15:15.000 --> 01:15:17.000]  в ту же строку, у вас лямбда функция
[01:15:17.000 --> 01:15:19.000]  может использовать какие-то внешние данные,
[01:15:19.000 --> 01:15:21.000]  но эти внешние данные вы локально
[01:15:21.000 --> 01:15:23.000]  создали и сразу же хотите ей отдать. Вы не хотите,
[01:15:23.000 --> 01:15:25.000]  чтобы они туда копировались.
[01:15:25.000 --> 01:15:27.000]  И вы не собираетесь
[01:15:27.000 --> 01:15:29.000]  хранить ссылку на них. Вы лямбда функцию
[01:15:29.000 --> 01:15:31.000]  как объект запихнули в какой-нибудь
[01:15:31.000 --> 01:15:33.000]  дредпул, не знаю, чтобы она
[01:15:33.000 --> 01:15:35.000]  в очереди выполнялась как задача,
[01:15:37.000 --> 01:15:39.000]  в каком-нибудь потоке, но ей нужны данные.
[01:15:39.000 --> 01:15:41.000]  Вы эти данные хотите ей передать.
[01:15:41.000 --> 01:15:43.000]  Но вы не хотите хранить эти данные, и вы их сейчас
[01:15:43.000 --> 01:15:45.000]  уничтожите, и вы не хотите ссылку на эти данные
[01:15:45.000 --> 01:15:47.000]  поэтому передавать. Это значит вы
[01:15:47.000 --> 01:15:49.000]  хотите их передать move.
[01:15:49.000 --> 01:15:51.000]  Вы не хотите их не копировать, не ссылку
[01:15:51.000 --> 01:15:53.000]  на них хранить, потому что их временно создали
[01:15:53.000 --> 01:15:55.000]  и сейчас уничтожите. Вы хотите, чтоб она их
[01:15:55.000 --> 01:15:58.280]  вам себе туда что вы хотите сделать вы хотите мовнуть эти данные в лямбда
[01:15:58.280 --> 01:16:06.600]  функцию как это сделать до c++14 не было синтакса так сделать не было синтакса
[01:16:06.600 --> 01:16:10.520]  захватить что-то в лямбда функцию через муф и приходилось извращаться довольно
[01:16:10.520 --> 01:16:13.960]  стрёмными способами но я не буду про них рассказывать они уже устарели
[01:16:13.960 --> 01:16:19.560]  начиная c++14 появился захват с инициализацией вы можете в лямбда
[01:16:19.560 --> 01:16:24.040]  функцию захватить что-то сразу указав чему его до чему и чем его надо
[01:16:24.040 --> 01:16:29.680]  проинциализировать при захвате смотрите что я могу сказать вот у меня есть да
[01:16:29.680 --> 01:16:42.040]  std string s равно там a b c d e f g вот я говорю авто f2 равно и сюда я захватываю мувом
[01:16:42.040 --> 01:16:46.840]  строку ну я мог бы захватить его по ссылке ну давайте мастер моя функция
[01:16:46.840 --> 01:16:52.640]  например она будет возвращать не знаю и ты элемент строки отличная функция
[01:16:52.640 --> 01:17:00.960]  очень полезно вот return а значит s и по индексу вот но допустим я в эту
[01:17:00.960 --> 01:17:06.440]  функцию хочу передать строку не по ссылке а копии причем ну копии бы я вот
[01:17:06.440 --> 01:17:13.760]  так передал но это мы поняли как мунуть чтобы мунуть нужно вот здесь
[01:17:13.760 --> 01:17:21.520]  написать s равно и написать чему равно а да если му вот с например можно
[01:17:21.520 --> 01:17:29.680]  писать да здесь это как списках инициализации будет работать то есть
[01:17:29.680 --> 01:17:36.520]  вот это s это будет внутренней внутреннее имя с а это эста то есть
[01:17:36.520 --> 01:17:45.040]  который локально видно и я могу им даже разные имена дать нет это непонятно как
[01:17:45.040 --> 01:17:48.120]  раз потому что раньше у нас синтаксис был я указываю имя того что я
[01:17:48.120 --> 01:17:54.600]  захватываю а теперь я использует тут некоторая другая логика я теперь если
[01:17:54.600 --> 01:17:59.680]  у меня синтаксис с равенством то я указываю имя не того что я захватываю от
[01:17:59.680 --> 01:18:03.400]  того как я хотел бы чтобы это называлось у меня а справа от равно я
[01:18:03.400 --> 01:18:10.920]  пишу некоторые expression от того что я вижу локально вот сейчас я захватил ss
[01:18:10.920 --> 01:18:21.520]  как знать как строку сейчас я захватил ss как строку по значению но я мувнул
[01:18:21.520 --> 01:18:31.600]  эту s туда то есть если я вот здесь прошу какой у меня размер с будет 0
[01:18:32.480 --> 01:18:39.000]  давайте проверим вот здесь мне выведется 0 потому что я мувнул строку в лямбда
[01:18:39.000 --> 01:18:50.160]  функцию тут много конечно проблем какие проблемы у меня здесь есть
[01:18:50.160 --> 01:18:57.040]  мид у знот деклэр а потому что мид потому что потому что мид был ниже да я слишком
[01:18:57.040 --> 01:19:13.120]  не туда это перенес давайте сюда это перенесу вот f2 уже было это будет f3
[01:19:13.120 --> 01:19:23.520]  ну пусть на память останется так 0 потому что строка мувнулась в лямбда
[01:19:23.520 --> 01:19:46.080]  функцию жестко вот тем не менее я не могу менять эту строку отсюда строка все еще
[01:19:46.080 --> 01:20:00.640]  константная хоть и мувнутая да вопрос какой это какой-то сложный вопрос давай на перерыве
[01:20:00.640 --> 01:20:07.360]  потому что мы сейчас потратим кучу времени на него вот могу захватить черепом могу захватить
[01:20:07.360 --> 01:20:13.800]  мувом но это используется не только для мув захвата то есть я могу разумеется здесь какое-нибудь
[01:20:13.800 --> 01:20:19.920]  другое выражение написать то есть я могу написать вот это вот ss равно и какое-нибудь выражение чем я
[01:20:19.920 --> 01:20:25.640]  бы хотел чтобы являлась сс у меня но в частности это позволяет муф захват делать что если мне
[01:20:25.640 --> 01:20:30.920]  нужно сделать захват нескольких вещей некоторые из которых хочу про инициализировать но я
[01:20:30.920 --> 01:20:36.240]  через запятую перечисляю я могу захватить вот это например так а еще я могу захватить вектор
[01:20:36.240 --> 01:20:43.640]  посылки вот пожалуйста то есть я у меня через запятую перечисляются и захвата с инициализации
[01:20:43.640 --> 01:20:48.240]  и захвата без инфилизации я могу перечислить через запятую что я захватываю по значению что по
[01:20:48.240 --> 01:21:03.120]  ссылке а что с инициализацией да как конструктор чего конструктор мувающий конструктор но я
[01:21:03.120 --> 01:21:10.000]  создаю объект лямбда объект лямбда в себе хранит объект строки и он создался это значит вот
[01:21:10.000 --> 01:21:17.640]  момент когда создают два с чего нет нет объект f2 же создан вот сейчас f2 это созданный объект в
[01:21:17.640 --> 01:21:30.320]  нем лежит поле строка поэтому создаваясь он должен мунуть строку в себя чего f3 что где вот тут
[01:21:30.320 --> 01:21:42.080]  да можешь ты можешь написать захватить сказать чему будет равно конкретно да это будет constant
[01:21:42.080 --> 01:21:52.000]  любой expression можно писать вот есть дефолтный захват а еще момент я могу вот например что
[01:21:52.000 --> 01:21:58.640]  сделать например я хочу вот вы спрашивали как захватить по константной ссылке да просто так же
[01:21:58.640 --> 01:22:06.880]  через мувающий через захват с инициализацией просто я вот такую функцию использую у меня есть
[01:22:06.880 --> 01:22:12.480]  стандартной библиотеки такая функция специально на этот случай стд с конст которая просто берет
[01:22:12.480 --> 01:22:18.920]  объекты возвращает конст референс на него очень удобно таким образом я захвачу сс по константной
[01:22:18.920 --> 01:22:32.360]  ссылке а как мух чтобы можно менять чтобы не конст стринг а нормально
[01:22:32.360 --> 01:22:57.560]  чего поменять ну не как если константная ссылка то ничего чего мью то был написать а вот дальше есть
[01:22:57.560 --> 01:23:07.520]  дефолтный захват что такое дефолтный захват я могу написать в квадратных скобочках просто равно
[01:23:07.520 --> 01:23:25.080]  чем вас это веселит это значит что я собираюсь захватить все локальные переменные по значениям
[01:23:25.080 --> 01:23:34.160]  а персант значит по все по ссылке а ты не знал типа то есть вы пользовались захватом а персант
[01:23:34.160 --> 01:23:41.560]  но не знали что это что он делает в общем-то так и бывает часто именно поэтому а персант вот
[01:23:41.560 --> 01:23:46.600]  именно поэтому а персант и запрещен современными кодстайлами очень рекомендуется к использованию я
[01:23:46.600 --> 01:23:51.040]  вам объясню почему потому что вы захватываете все по ссылке а ваша лямбда может пережить то что
[01:23:51.040 --> 01:23:55.960]  вы захватили по ссылке а вы даже не знаете что вы по ссылке захватили у вас убе как нефиг делать
[01:23:55.960 --> 01:24:02.920]  возникнет нет вы просто лямбда функцию захватили по ссылке и объект этой лямбда куда-то передали и
[01:24:02.920 --> 01:24:12.160]  у вас может эту лямбу там кто-то еще скопировал кто-то куда-то положил и те перемены которые
[01:24:12.160 --> 01:24:17.280]  захватила по ссылке уже давным-давно свое отжили и функция та завершилась а в той лямбде все еще
[01:24:17.280 --> 01:24:30.400]  будут храниться ссылки на них равно захватит все локальные переменные вам именно локальные то
[01:24:30.400 --> 01:24:34.480]  есть она не захватит глобальные но глобальные захватывать не нужно они и так вам доступны
[01:24:34.480 --> 01:24:45.840]  вы захватите все локальные переменные которые вам видны вот из этого места вот отсюда а если
[01:24:45.920 --> 01:24:51.000]  вы по значению они все будут скопированы и все будут конст их и если хотите менять мьют и был
[01:24:51.000 --> 01:24:57.320]  написать если вы напишите вот так то это значит вы все локальные переменные захватите по ссылке
[01:24:57.320 --> 01:25:10.760]  вот например сейчас у меня получится что с size это 8 потому что я в с положил а и стало абc да
[01:25:11.240 --> 01:25:25.640]  нет я неправильно посчитал что ли а потому что я не вызвал вот если я так сделаю f2 от нуля например
[01:25:25.640 --> 01:25:35.600]  а потом сделаю сайс то будет 8 понятно да понятно почему вот без этого 7 а если это написать то 8
[01:25:35.600 --> 01:25:43.720]  хорошо как я уже сказал захват по ссылке вот этот дефолтный захват это очень плохой
[01:25:43.720 --> 01:25:48.160]  код style и не рекомендуется так делать почему не рекомендуется потому что я уже сказал ваша
[01:25:48.160 --> 01:25:52.520]  лямбда функция может как нефть делать пережить по времени жизни те переменные которые вы
[01:25:52.520 --> 01:25:59.440]  локальные захватили а вы поскольку вы их даже не заметили то есть вы вы очень рискуете вы
[01:25:59.440 --> 01:26:06.760]  пишете захвати мне все и у вас из лямбда оно остается доступно при том что его время жизни
[01:26:06.760 --> 01:26:14.920]  может быть меньше чем время жизни вашей лямбды вот и это опасно поэтому рекомендуется если вы
[01:26:14.920 --> 01:26:20.720]  что-то захватываете явно перечислять что вы захватили вы так обезопасите себя от того что
[01:26:20.720 --> 01:26:27.240]  вы случайно захватили что-то а потом забыли и начали этим пользоваться и последнее про захват
[01:26:27.240 --> 01:26:31.520]  если вы захватили все по ссылке то тем не менее некоторые вещи вы можете захватить по значению
[01:26:31.520 --> 01:26:38.200]  вместо того чтобы по ссылке я могу например написать вот так это значит я все захватываю
[01:26:38.200 --> 01:26:46.600]  посылки кроме векторов и его по значению копирую аналогично я могу сказать равно запитаем персант
[01:26:46.600 --> 01:26:51.760]  тес это значит я все захватываю по значению но вотr по ссылке
[01:26:51.760 --> 01:26:56.760]  А карбиллятор никак не оптимизирует то, что мы некоторые переменные просто не используем нигде в лямбде?
[01:26:56.760 --> 01:27:04.760]  Нет, не оптимизирует, потому что ты поймешь почему, когда мы поговорим как лямбды устроены внутренне.
[01:27:04.760 --> 01:27:11.760]  А мы об этом скоро поговорим. Ну вот Феде все нет, может быть мне и начать про это уже говорить.
[01:27:11.760 --> 01:27:25.760]  Да, вот смотрите, давайте я вам приведу пример такой.
[01:27:25.760 --> 01:27:34.760]  Пример, когда у меня возникают проблемы. Вот пусть у меня есть структура S, но не вот такая, а вот такая.
[01:27:34.760 --> 01:27:56.760]  В ней есть какое-то поле A. Нет, не так. Вот в моей структуре S будет функция, вот такая странная функция, которая будет делать следующее.
[01:27:56.760 --> 01:28:21.760]  Ну вот. Изврат-то и изврат, но тем не менее вы думаете в реальном коде такое не встречается, очень даже встречается.
[01:28:21.760 --> 01:28:36.760]  Да, я говорю, return f. Ну, допустим, я хочу такую функцию, которая мне вот. Я, это конечно плохо.
[01:28:36.760 --> 01:28:46.760]  Я создаю класс, который умеет генерировать функциональные объекты. Он умеет генерировать функциональные объекты от разных параметров.
[01:28:46.760 --> 01:28:55.760]  То есть я хочу, чтобы мне класс умел давать штуку, которую я потом вызывать смогу. Вот. И это зависит от параметра.
[01:28:55.760 --> 01:29:01.760]  Например, вот моя функция, она будет возвращать число, которое получается добавлением х к пятерке.
[01:29:01.760 --> 01:29:05.760]  Ну, это конечно учебный пример, но понятно, что это может быть очень сложная функция.
[01:29:05.760 --> 01:29:22.760]  Я говорю S, S. Сейчас. Подождите, подождите, подождите. Зачем мне X get function?
[01:29:22.760 --> 01:29:34.760]  А, ну да. Мне здесь не нужен X. Мне нужен скорее, мне скорее вот что нужно. Вот я что хочу сделать. Я хочу вот это назвать A.
[01:29:34.760 --> 01:29:45.760]  Да, да, да. Вот так я хочу сделать. То есть у меня функция, которая прибавляет некоторую штуку, фиксированную к тому, что я от этого, от чего эту функцию вызываю.
[01:29:45.760 --> 01:29:58.760]  И вот я говорю S, S. И да, смотрите. Пять новых способов, десять новых способов сложить два целых числа я вам сегодня покажу.
[01:29:58.760 --> 01:30:17.760]  Вот, смотрите. Я говорю A, G равно S.get function от пяти. Вот. И потом я вызываю G от трех, например.
[01:30:17.760 --> 01:30:37.760]  Вот. Чего? S.get function, конечно. Вот. Это UB. Все понимают, почему это UB? Кто понимает, почему это UB? Так можно проверить, кто еще слушает меня.
[01:30:37.760 --> 01:30:49.760]  Да, это UB. Потому что эта функция захватила по ссылке локальную переменную, которая уничтожилась сразу же после того, как вернулась эта функция. То есть в этой функции хранится ссылка на то, чего уже не существует.
[01:30:49.760 --> 01:31:02.760]  Скорее всего, фактически это все еще 8? Да нет, вряд ли как раз. Вот здесь как раз вряд ли это 8. Ну давайте проверим.
[01:31:02.760 --> 01:31:17.760]  Чего? Где? А, ну это не помешает, но давайте уберем. Чего не должно быть? Так. У меня conflicting declaration опять.
[01:31:17.760 --> 01:31:33.760]  Переименуй просто и все. Вот две верхних строчки просто переименуй, а с маленькой и забей. А то иначе мы сейчас будем пол кода переделывать.
[01:31:33.760 --> 01:31:52.760]  Да, ну все-таки 8. Ну а если минус O2, то 3. Ну это в общем-то логично. Потому что зачем, зачем что-то складывать, если можно ничего не складывать. И так UB.
[01:31:52.760 --> 01:32:08.760]  Ну да, кстати. Вот, но это в простом случае 8. А если бы я после того, как создал эту функцию, еще насоздавал каких-то объектов на стеке, а потом уже вызвал эту функцию, то там бы все перезатерлось и было бы не 8, а рандомное число.
[01:32:08.760 --> 01:32:20.760]  То есть там нужно передавать по значению. Вот. Да. Да, вот если бы я сюда передал по значению, то было бы нормально.
[01:32:20.760 --> 01:32:44.760]  Потому что я бы скопировал и она бы, ну 8, да. Вот, а теперь другой интересный момент. Представьте теперь, что у меня это A было не параметром функции, а полем класса.
[01:32:44.760 --> 01:33:09.760]  И я, создавая AS, сказал ему от чего создаться. Вот, и теперь я хочу вот здесь использовать это A. Как вы думаете, что будет? Ну сейчас-то понятно, что будет. Здесь все нормально, потому что, да, во-первых, будет ли ошибка компиляции?
[01:33:09.760 --> 01:33:25.760]  А это не локальная переменная. А это класс scope переменная. Локальная переменная – это переменная, которая в функции объявлена, которая объявлена в local scope. А поле – это не локальная переменная.
[01:33:25.760 --> 01:33:41.760]  И если я напишу вот так. О, Федя пришел. Все, значит мы закругляемся. Если я напишу вот так, то будет ошибка компиляции. Правда, по какой-то странной причине.
[01:33:41.760 --> 01:34:00.760]  Ну да, вот нельзя захватить non-variable. Интересно, конечно, у него. Почему non-variable? Ну, короче, нельзя захватывать то, что не является локальными переменными. Это просто запрещено. Захватывать может только локальная переменная. Поля класса нельзя в capture-листах указывать.
[01:34:00.760 --> 01:34:16.760]  Вот. Да. Что будет, если я так напишу? А вот если я так напишу, то будет нормально. Ну, ненормально по какой-то другой причине, потому что там что-то вывести не получается.
[01:34:16.760 --> 01:34:31.760]  А, нет, не будет, да, нормально. Потому что он... Да, сорян, сорян, сорян. Так не будет работать. Тоже не будет, потому что а, нет.
[01:34:31.760 --> 01:34:46.760]  А если конс добавить? Нет, статик добавить. Чего конс добавить? Где? А, да, спасибо, да. А если мы не хотим конс? Нет, все равно не работает.
[01:34:46.760 --> 01:35:00.760]  Так, короче, рассказываю, что надо сделать, чтобы поле класса в лямду захватить. Надо на самом деле написать здесь вот такую вещь. Да, мы в классе, мы в классе.
[01:35:00.760 --> 01:35:10.760]  Значит, когда мы из класса, из метода класса, пытаемся в лямде использовать поля класса, мы не можем захватить их непосредственно, потому что они не локальные переменные.
[01:35:10.760 --> 01:35:29.760]  Ну вот, нельзя. Вот, скопируем на вис, это же поинтер. А, ну ладно. Вот. Значит, если мы в объекте хотим использовать поля объекта, то нам надо в лямду захватить, как бы получить доступ к нашему объекту, из которого мы вызываемся.
[01:35:29.760 --> 01:35:44.760]  И делается это следующим способом. Мы пишем в списке захвата вис. Вис дает нам неявный доступ ко всем полям. Вот теперь А будет в лямдо функции браться из полей объекта.
[01:35:44.760 --> 01:36:04.760]  Захватив вис, мы из лямдо функции получили доступ ко всем полям нашего объекта. Но если мы эту лямдо функцию куда-то отдадим наружу, а наш объект будет уничтожен раньше, чем эта лямдо функция, то, разумеется, это будет УВ.
[01:36:04.760 --> 01:36:16.760]  Потому что мы захватили все эти поля, получили к ним доступ по указателю, то есть по ссылке на объект, а объект умер. Поэтому мы схватим УВ с ноу.
[01:36:16.760 --> 01:36:22.760]  Мы так можем изменить ссылку на поле и убить объект, пользоваться ссылкой.
[01:36:22.760 --> 01:36:39.760]  Вис – это указатель на объект. Мы захватили в лямдо указатель на наш объект. И когда мы в лямдо используем поля объекта, они неявно подменяются на вот такое. Указатель на тот объект, который мы захватили, стрелочка – это поле.
[01:36:39.760 --> 01:36:59.760]  Вис – это специализированный синтаксис. Это еще один костыль, что может быть в Capture List. Там может быть имя переменной, амперсант имя переменной, имя переменной равно Expression и еще Vis. А еще просто равно, а еще просто амперсант.
[01:36:59.760 --> 01:37:09.760]  Правда ли, что мы убьемся раньше, чем будем использовать? Давайте мы закончим пару, потому что надо уже перерыв и надо Федю.
[01:37:09.760 --> 01:37:23.760]  Сейчас мы поговорим про тему новую. В смысле, у нас впервые в курсе. Это фича чистое 20 стандарта.
[01:37:23.760 --> 01:37:25.760]  Ключи свет, пожалуйста.
[01:37:26.760 --> 01:37:28.760]  Ой, а чего он седонный такой?
[01:37:29.760 --> 01:37:31.760]  Все, хватит.
[01:37:31.760 --> 01:37:59.760]  И в целом, наверное, я бы хотел, чтобы сегодня семинар был более интерактивный, чтобы мы просто пощупали, как это работает.
[01:37:59.760 --> 01:38:07.760]  И глубоко разобраться, как это внутри устроено, и нам, на самом деле, пока не хватает теории.
[01:38:08.760 --> 01:38:10.760]  Ты что, оставил мужицкий ВИМ?
[01:38:11.760 --> 01:38:13.760]  Во-первых, это ВИМ, ты просто не видишь.
[01:38:14.760 --> 01:38:17.760]  Нет, это Мексика, я вижу.
[01:38:21.760 --> 01:38:24.760]  Я, конечно, знаю, что высказала балочка над ВИМом.
[01:38:25.760 --> 01:38:28.760]  Нет, это ВИМ, потому что здесь стоят все ВИМские биндинги.
[01:38:30.760 --> 01:38:34.760]  Вот, суть в чем. Смотрите, давайте начнем. Начнем издалека.
[01:38:35.760 --> 01:38:39.760]  Вы, наверное, еще не говорили даже про...
[01:38:40.760 --> 01:38:44.760]  Да, вы точно не говорили, потому что как-то на прошлом семинаре я упоминал стринг-вью.
[01:38:45.760 --> 01:38:48.760]  И вы такие, о, что такое стринг-вью?
[01:38:49.760 --> 01:38:53.760]  Вот, есть такой класс на дартной библиотеке STD-String-View.
[01:38:54.760 --> 01:38:56.760]  Он лежит в отдельном хедере.
[01:38:59.760 --> 01:39:01.760]  А микрофон?
[01:39:08.760 --> 01:39:10.760]  Вот, в чем его смысл?
[01:39:11.760 --> 01:39:16.760]  Это такой класс, у которого в полях он выглядит примерно с следующим образом.
[01:39:17.760 --> 01:39:19.760]  На самом деле он прям таким образом выглядит.
[01:39:19.760 --> 01:39:23.760]  Ну, кроме того, что у него есть несколько шаблонных аргументов, в которых мы умолчим.
[01:39:24.760 --> 01:39:33.760]  Значит, у него есть указатель на начало, и у него есть вот так.
[01:39:34.760 --> 01:39:36.760]  Вот такая штука.
[01:39:38.760 --> 01:39:42.760]  Он позволяет... Ну, и куча методов, как у строки.
[01:39:43.760 --> 01:39:46.760]  Вот кому-то у него есть шаблонные аргументы.
[01:39:46.760 --> 01:39:48.760]  Ну, и куча методов, как у строки.
[01:39:49.760 --> 01:39:54.760]  Вот кому-то из вас понятно, когда такой класс может быть полезнее, чем STD-String?
[01:40:00.760 --> 01:40:02.760]  Ну, я только что объяснил, что он делает.
[01:40:03.760 --> 01:40:05.760]  Это он внутри хранения, и у него куча методов, собственно говоря, как у строки.
[01:40:06.760 --> 01:40:07.760]  Да, абсолютно верно.
[01:40:08.760 --> 01:40:09.760]  Когда у нас уже где-то хранится строка.
[01:40:10.760 --> 01:40:14.760]  Например, если вы когда-то писали, не знаю, где-нибудь статическую переменную или глобальную,
[01:40:14.760 --> 01:40:20.760]  STD, String, Global равно Hello World.
[01:40:21.760 --> 01:40:23.760]  Что здесь происходит, на самом деле?
[01:40:24.760 --> 01:40:27.760]  У вас есть вшитый в бинарник строка Hello World.
[01:40:28.760 --> 01:40:33.760]  Я не помню, смотрели мы с вами или нет, но вот строки, они прям вшиваются в исходный код, прям в Assembler.
[01:40:34.760 --> 01:40:35.760]  И затем...
[01:40:36.760 --> 01:40:37.760]  Да.
[01:40:38.760 --> 01:40:43.760]  И затем, еще до функции main, там вызывается сишная стандартная библиотека такая,
[01:40:44.760 --> 01:40:50.760]  что я вижу стандартную переменную, в смысле, глобальную переменную,
[01:40:51.760 --> 01:40:53.760]  и я ее конструирую на запуске программы.
[01:40:54.760 --> 01:40:57.760]  Хотя, на самом деле, зачем нам может быть понадобится такой стринг?
[01:40:58.760 --> 01:41:01.760]  Ну, потому что с стрингом общаться удобнее, чем с const charge звездочкой.
[01:41:02.760 --> 01:41:09.760]  Вот если здесь написать string view, все еще произойдет то же самое, в смысле вызовется конструктор.
[01:41:10.760 --> 01:41:13.760]  Но этот конструктор, например, не пойдет в кучу, он не будет алоцировать новую память.
[01:41:14.760 --> 01:41:19.760]  Мы создадим указатель на начало этой строки и пробежимся за линию, посчитаемую длину.
[01:41:20.760 --> 01:41:21.760]  И теперь у нас всегда будет ее длина.
[01:41:22.760 --> 01:41:23.760]  Это очень удобно.
[01:41:24.760 --> 01:41:25.760]  Вот есть такая штука.
[01:41:26.760 --> 01:41:28.760]  Собственно, он называется string view.
[01:41:29.760 --> 01:41:33.760]  View, потому что он как бы смотрит на данные, понятно, да?
[01:41:34.760 --> 01:41:35.760]  Он не владеет ими.
[01:41:38.760 --> 01:41:42.760]  Это кажется на введение 17-х плюсов, этот класс.
[01:41:44.760 --> 01:41:45.760]  Вот.
[01:41:46.760 --> 01:41:47.760]  Вот.
[01:41:48.760 --> 01:41:50.760]  Вот с ним понятно пока все, да?
[01:41:54.760 --> 01:41:55.760]  Окей.
[01:41:56.760 --> 01:42:04.760]  Вот, начиная с 20-х плюсов, у нас появилась огромная новая библиотека, ну как бы под библиотека, в стандартной библиотеке.
[01:42:05.760 --> 01:42:07.760]  Значит, заголочный файл ranges.
[01:42:09.760 --> 01:42:11.760]  Или диапазоны.
[01:42:12.760 --> 01:42:13.760]  Что это такое?
[01:42:14.760 --> 01:42:19.760]  Это мы хотим на самом деле частично переписать немножко остальные алгоритмы.
[01:42:20.760 --> 01:42:21.760]  Сейчас мы посмотрим зачем и почему.
[01:42:22.760 --> 01:42:28.760]  А частично мы хотим вот идею string view очень сильно обобщить.
[01:42:29.760 --> 01:42:32.760]  И накрутить на нее кучу-кучу-кучу классных штук.
[01:42:33.760 --> 01:42:37.760]  Вот какую классную кучу классных штук сейчас мы с вами и посмотрим.
[01:42:37.760 --> 01:42:39.760]  Вообще кто-то пользовался уже ranges?
[01:42:43.760 --> 01:42:45.760]  Кто-то что-то про них знает, слышал?
[01:42:53.760 --> 01:42:54.760]  Да.
[01:42:54.760 --> 01:42:55.760]  Ну хорошо, смотрите.
[01:42:55.760 --> 01:42:57.760]  Давайте начнем пока просто поговорим.
[01:42:57.760 --> 01:42:59.760]  Что такое произвольный диапазон?
[01:43:00.760 --> 01:43:01.760]  Вот.
[01:43:01.760 --> 01:43:02.760]  Да.
[01:43:02.760 --> 01:43:05.760]  В целом определение рейнджа в стандарте почти такое.
[01:43:06.760 --> 01:43:24.240]  За единственным исключением, что в этой рейндже очень много
[01:43:24.240 --> 01:43:39.240]  Определение рейнджа в стандарте почти такое, за единственным исключением, что пара итераторов это на самом деле даже несколько сильное условие. То, что мы хотим от рейнджа чуть-чуть слабее, чем пара итераторов.
[01:43:39.240 --> 01:43:47.240]  Почему так? Ну, смотрите. Какой у нас может быть диапазон?
[01:43:47.240 --> 01:43:50.240]  Да, но он может быть бесконечным.
[01:43:50.240 --> 01:43:59.240]  Он может быть бесконечным. Это правда. Но тогда у нас все равно есть бесконечность. Математиками тоже пишем. От, до, плюс бесконечность.
[01:43:59.240 --> 01:44:04.240]  Ну, как бы что-то там справа есть. Вот что-то справа есть, но это не совсем итератор.
[01:44:05.240 --> 01:44:09.240]  А мы должны уметь проверять на то, что кончилось.
[01:44:09.240 --> 01:44:12.240]  Мы должны уметь проверять на то, что кончилось. Это правда.
[01:44:12.240 --> 01:44:18.240]  А что мы еще хотим от второй части? Мы хотим вообще что-то еще от второй части?
[01:44:18.240 --> 01:44:20.240]  Просто здесь срабатывать и все?
[01:44:20.240 --> 01:44:22.240]  Да. Это на самом деле все, что мы от нее хотим. Это правда.
[01:44:22.240 --> 01:44:29.240]  Потому что, как вы помните, у нас есть этот pass the end итератор. Его нельзя разыминовывать, очевидно. Это UB.
[01:44:29.240 --> 01:44:38.240]  Более того, его нельзя даже инкрементировать. Это UB, как мы правили тесты и выяснили это лишний раз.
[01:44:38.240 --> 01:44:52.240]  Вот. Это UB. Все, что с ним можно делать, это иногда декрементировать. Иногда. Не всегда. Потому что вообще не все итераторы можно декрементировать.
[01:44:52.240 --> 01:44:55.240]  Ну, наш тип итератора можно, то есть...
[01:44:55.240 --> 01:45:06.240]  Ну да. И сравнивать с ним. Вот давайте вспомним какой-нибудь итератор, для которого вот эта правая часть как раз была такой странной штукой,
[01:45:06.240 --> 01:45:09.240]  которая не совсем тот же самый итератор, что слева.
[01:45:09.240 --> 01:45:14.240]  Вот я вам два таких, кажется, показывал. Один совсем скользь, другой мы относительно подробно рассматриваем.
[01:45:14.240 --> 01:45:23.240]  Истрим, я бы сказал. Ну, stream output, он там отдельно. Вот истрим, да. Вот у нас есть истрим итератор.
[01:45:23.240 --> 01:45:33.240]  Это текущее место в импуте. А есть конец. И вот конец, мы его как делали? Мы просто говорили, ну, типа, какое-то особое значение итератора этого же типа.
[01:45:33.240 --> 01:45:46.240]  Да, да. Вот к чему весь этот, все эти слова, а к тому, что в плюсах range определяется так.
[01:45:46.240 --> 01:45:56.240]  Это объект, у которого можно позвать begin, у которого можно позвать end. Begin и end не обязаны возвращать один и тот же тип.
[01:45:56.240 --> 01:46:01.240]  Но они обязаны быть сравниваны.
[01:46:01.240 --> 01:46:10.240]  Ну, мы этого ожидаем, я не уверен, что это формальное определение самого range есть, но вообще да.
[01:46:10.240 --> 01:46:16.240]  А как еще мы внутри это вообще можем реализовать, если мы не умеем сравнивать begin и end?
[01:46:16.240 --> 01:46:23.240]  Ну да, да, да. Давайте скажем, что мы их хотим сравнивать.
[01:46:23.240 --> 01:46:30.240]  Ну сейчас мы можем на самом деле, смотрите, вот у меня есть волшебный сайт cpp-reference, мы можем к нему сегодня время от времени обращаться.
[01:46:30.240 --> 01:46:42.240]  Вот у нас есть ranges-range, и тут написано, что это что-то, у чего есть begin, у чего есть end. Кажется, кажется, все, вообще все.
[01:46:42.240 --> 01:46:49.240]  Вот, то есть понятно, что в тех местах, где мы будем их использовать, мы будем налагать дополнительные ограничения на то, что возвращает begin и end.
[01:46:49.240 --> 01:46:56.240]  У нас есть какие-то алгоритмы, которые работают только с random access-терраторами. Ну, то есть нам уже подойдет только, какие-то ограничения добавить на будут.
[01:46:56.240 --> 01:47:04.240]  Окей, это глобально, абстрактно. Значит, у нас появилась такая штука, абстрактный range.
[01:47:04.240 --> 01:47:13.240]  Давайте посмотрим, как на вот этот вот концепт, который появился, отреагировала стандартная библиотека.
[01:47:13.240 --> 01:47:19.240]  Вот в первую очередь, значит, стандартные алгоритмы. Вот как мы раньше делали stdsort.
[01:47:19.240 --> 01:47:28.240]  Вот если у нас есть, допустим, вот мне интересно, кстати, у нас есть лист int.
[01:47:28.240 --> 01:47:34.240]  Что произойдет, если я сделаю вот так?
[01:47:34.240 --> 01:47:37.240]  Ну, он посредствуется.
[01:47:37.240 --> 01:47:43.240]  Отличное предположение. Да, но неверное. Этот код не скомпилируется.
[01:47:43.240 --> 01:48:02.240]  Ответ.
[01:48:02.240 --> 01:48:08.240]  Значит, смотрите, у нас ошибка. И где-то вот в 1938 стручке он вычитает.
[01:48:08.240 --> 01:48:13.240]  Он не будет сортировать за квадрат, наверное.
[01:48:13.240 --> 01:48:23.240]  Я не хочу думать об этом.
[01:48:23.240 --> 01:48:28.240]  Вот с другой стороны, если мы сделаем вектор, вот все будет нормально.
[01:48:28.240 --> 01:48:33.240]  Смотрите, что произошло первое в стандартной библиотеке.
[01:48:33.240 --> 01:48:37.240]  У нас появилась копия всех стандартных алгоритмов,
[01:48:37.240 --> 01:48:43.240]  которые работают не с парой итераторов, а с объектом range.
[01:48:43.240 --> 01:48:48.240]  Значит, эти алгоритмы лежат в std ranges.
[01:48:48.240 --> 01:48:53.240]  И вот здесь есть sort, в который можно передать просто объект.
[01:48:53.240 --> 01:48:57.240]  Вот вектор, как мы понимаем, это range. У вектора есть begin и end.
[01:48:57.240 --> 01:49:00.240]  Значит, он range. Значит, можно передать сюда. Класс.
[01:49:00.240 --> 01:49:04.240]  Я думаю, вы так хотели делать. Теперь можно так делать.
[01:49:04.240 --> 01:49:08.240]  Ну, нам не приходилось сортировать листы вообще-то.
[01:49:08.240 --> 01:49:12.240]  Ну, листы нельзя, это вектор.
[01:49:12.240 --> 01:49:18.240]  Тем более можно попытаться определить операторы.
[01:49:18.240 --> 01:49:25.240]  Операторы?
[01:49:25.240 --> 01:49:27.240]  Ладно, вот. Что еще важно?
[01:49:27.240 --> 01:49:32.240]  А да, есть общепринятое более-менее в комьюнити сокращение,
[01:49:32.240 --> 01:49:37.240]  чтобы не писать std . . . ranges . . . долго это надоедает.
[01:49:37.240 --> 01:49:44.240]  Часто, и я на этом семинаре точно буду использовать rng это ranges.
[01:49:44.240 --> 01:49:50.240]  Почему аналогия string u?
[01:49:50.240 --> 01:49:56.240]  Потому что кроме ranges у нас появились view.
[01:49:56.240 --> 01:49:59.240]  Куча-куча классных-классных view.
[01:49:59.240 --> 01:50:02.240]  Давайте сначала разберемся с алгоритмами.
[01:50:02.240 --> 01:50:04.240]  Давайте сначала поговорим про алгоритмы.
[01:50:04.240 --> 01:50:15.240]  На самом деле, потому что это не все, что изменилось в стандартных алгоритмах.
[01:50:15.240 --> 01:50:17.240]  А, то есть факты стандартных алгоритм.
[01:50:17.240 --> 01:50:24.240]  То есть sort это не include sort, это из sort.hfile.
[01:50:24.240 --> 01:50:26.240]  Это настоящий sort.
[01:50:26.240 --> 01:50:28.240]  Это не ranger-ский sort.
[01:50:28.240 --> 01:50:30.240]  Нет, нет.
[01:50:30.240 --> 01:50:38.240]  Ну, короче, ну, я не знаю, как внутри это сделано.
[01:50:38.240 --> 01:50:40.240]  Возможно, они зовут какие-то общие функции,
[01:50:40.240 --> 01:50:44.240]  но там типа не просто добавили перегрузку, нет.
[01:50:44.240 --> 01:50:46.240]  Почему не просто добавили перегрузку?
[01:50:46.240 --> 01:50:48.240]  Потому что, как я только что сказал,
[01:50:48.240 --> 01:50:55.240]  у нас имеет право range в отличие от пары итераторов,
[01:50:55.240 --> 01:50:59.240]  чтобы эти пары итераторов у range была разного типа.
[01:50:59.240 --> 01:51:00.240]  Что это значит?
[01:51:00.240 --> 01:51:05.240]  Что если у нас есть какая-то структура S,
[01:51:05.240 --> 01:51:13.240]  у нее внутри есть T1, T2.
[01:51:13.240 --> 01:51:18.240]  Это какие-то итераторы.
[01:51:18.240 --> 01:51:27.240]  И она возвращает там T1, begin.
[01:51:27.240 --> 01:51:30.240]  И T2, end.
[01:51:30.240 --> 01:51:34.240]  То вот эту структуру мы сортировать не сможем в std-сорте.
[01:51:34.240 --> 01:51:39.240]  std-sort ожидает, что у нас один и тот же тип у двух итераторов.
[01:51:39.240 --> 01:51:41.240]  Rng-sort он просто...
[01:51:41.240 --> 01:51:44.240]  Rng-sort он уже нормально.
[01:51:44.240 --> 01:51:45.240]  Что значит нормально?
[01:51:45.240 --> 01:51:47.240]  Ну, в смысле, он с этим работает.
[01:51:47.240 --> 01:51:50.240]  Он это компилирует.
[01:51:50.240 --> 01:51:52.240]  No.
[01:51:52.240 --> 01:51:54.240]  Ну, понятно, что вот эту структуру мы сейчас не посортим,
[01:51:54.240 --> 01:51:58.240]  потому что кучи всего не хватает, но идея такая.
[01:51:58.240 --> 01:52:00.240]  Точек с запятой, кстати, не хватает.
[01:52:00.240 --> 01:52:03.240]  Все-таки он не сможет посортить, если мы не сможем сравнить begin и end.
[01:52:03.240 --> 01:52:07.240]  Да, сравнение должно быть, безусловно.
[01:52:07.240 --> 01:52:15.240]  Кстати, мне вот интересно, какую ошибку нам выдаст Rng-sort, если мы попробуем...
[01:52:15.240 --> 01:52:17.240]  От листа, да?
[01:52:17.240 --> 01:52:18.240]  Да, от листа.
[01:52:18.240 --> 01:52:19.240]  Вот раньше у нас какая была ошибка?
[01:52:19.240 --> 01:52:21.240]  У нас ошибка...
[01:52:21.240 --> 01:52:25.240]  Нет, у чего-то там нет минуса.
[01:52:25.240 --> 01:52:27.240]  Какая у нас здесь ошибка?
[01:52:27.240 --> 01:52:31.240]  Мы не смогли найти call, кандидат...
[01:52:36.240 --> 01:52:40.240]  constraints not satisfied, ограничения не соблюдены.
[01:52:44.240 --> 01:52:51.240]  Мы хотим std random access итератор так, а у нас bidirectional итератор так.
[01:52:51.240 --> 01:52:53.240]  Ошибка вообще другая.
[01:52:53.240 --> 01:53:00.240]  Мы сломались немножко в другом месте.
[01:53:00.240 --> 01:53:04.240]  То есть у этих ranges алгоритмов явно прописаны условия,
[01:53:04.240 --> 01:53:08.240]  типа если там не просто скомпилировалось-скомпилировалось,
[01:53:08.240 --> 01:53:14.240]  а типа условия, если мне не дали random access итератор, CE.
[01:53:15.240 --> 01:53:17.240]  Вот.
[01:53:17.240 --> 01:53:19.240]  Ну хорошо.
[01:53:19.240 --> 01:53:24.240]  Давайте еще немножко поговорим об обычных стандартных алгоритмах.
[01:53:24.240 --> 01:53:30.240]  Друзья, можно чуть потише, это прям раздражает.
[01:53:30.240 --> 01:53:33.240]  Окей, немножко про стандартные алгоритмы.
[01:53:33.240 --> 01:53:38.240]  Смотрите, представьте, что у нас есть задача.
[01:53:38.240 --> 01:53:46.240]  У нас есть структура стандартная, не знаю, point.
[01:53:46.240 --> 01:53:53.240]  У нас есть float x, float y.
[01:53:53.240 --> 01:53:59.240]  У нас есть что?
[01:53:59.240 --> 01:54:01.240]  Что мы хотим с ним сделать?
[01:54:01.240 --> 01:54:07.240]  Мы хотим их считать, мы хотим их пофильтровать.
[01:54:07.240 --> 01:54:13.240]  Это что?
[01:54:13.240 --> 01:54:18.240]  Запишите 13-я тема ranges.
[01:54:18.240 --> 01:54:19.240]  Ноль, наверное.
[01:54:19.240 --> 01:54:26.240]  Только сам пронумеруй.
[01:54:26.240 --> 01:54:27.240]  Хорошо.
[01:54:27.240 --> 01:54:32.240]  Илья в номенклатуре больше понимает.
[01:54:32.240 --> 01:54:34.240]  Вот.
[01:54:34.240 --> 01:54:39.240]  Давайте вот придумаем что-то более-менее стандартное с этой точкой.
[01:54:39.240 --> 01:54:43.240]  И потом попробуем реализовать это не фориком, а истерильевскими алгоритмами.
[01:54:43.240 --> 01:54:47.240]  Как это как бы должно бы быть?
[01:54:47.240 --> 01:54:52.240]  Значит, ну сначала мы хотим считать эти структуры с входа.
[01:54:52.240 --> 01:54:58.240]  Потом, скажем, хотим отфильтровать те, которые находятся в квадрате там 0, 10.
[01:54:58.240 --> 01:55:01.240]  Там 0, 0, 10, 10.
[01:55:01.240 --> 01:55:08.240]  И потом все эти точки, не знаю, сдвинуть вправо и вывести.
[01:55:08.240 --> 01:55:10.240]  Еще где-нибудь отсортировать их в середине.
[01:55:10.240 --> 01:55:21.240]  Вот как мы можем это сделать?
[01:55:21.240 --> 01:55:23.240]  Есть у кого-то какие-то идеи.
[01:55:23.240 --> 01:55:25.240]  Ну или давайте начнем, типа, чуть попроще.
[01:55:25.240 --> 01:55:29.240]  Давайте считать, что они у нас уже считаны.
[01:55:29.240 --> 01:55:33.240]  Вот у нас есть вектор, пойнтов.
[01:55:33.240 --> 01:55:39.240]  Вот у нас есть... что?
[01:55:39.240 --> 01:55:45.240]  Мы хотим фильтр, sort.
[01:55:45.240 --> 01:55:54.240]  Нет, фильтр transform, sort, output.
[01:55:54.240 --> 01:55:56.240]  Короткий фильтр не приходит.
[01:55:56.240 --> 01:56:00.240]  Приходит только создать новый вектор и у него попушбекать все, что подходит.
[01:56:00.240 --> 01:56:06.240]  Окей, первый вариант.
[01:56:06.240 --> 01:56:08.240]  Вот, а как попушбекать?
[01:56:08.240 --> 01:56:10.240]  Давай, хотя бы вот этот вариант.
[01:56:10.240 --> 01:56:14.240]  Мы, так как прострелять алгоритмы не говорили, вот давай хотя бы этот вариант.
[01:56:14.240 --> 01:56:23.240]  Мы делаем новый вектор.
[01:56:23.240 --> 01:56:25.240]  Делаем новый вектор points filter.
[01:56:25.240 --> 01:56:29.240]  Что мы дальше делаем?
[01:56:29.240 --> 01:56:31.240]  Не-не-не, погоди.
[01:56:31.240 --> 01:56:33.240]  Алгоритмы.
[01:56:33.240 --> 01:56:38.240]  Мы хотим на алгоритмах написать.
[01:56:38.240 --> 01:56:40.240]  Смотрите, хорошо, есть стандартный алгоритм.
[01:56:40.240 --> 01:56:47.240]  std, copy, if.
[01:56:47.240 --> 01:56:50.240]  В общем, есть куча стандартных алгоритмов.
[01:56:50.240 --> 01:56:52.240]  Многие из них можно навешивать.
[01:56:52.240 --> 01:56:59.240]  Блин, есть шикарное выступление на каком-то старом цепопоконе от человека, который сделал гигантскую карту алгоритмов и говорил, что вот есть алгоритмы.
[01:56:59.240 --> 01:57:01.240]  А на них можно навешивать rune.
[01:57:01.240 --> 01:57:03.240]  И вот if это rune.
[01:57:03.240 --> 01:57:05.240]  Или там нижнее подчеркивание n это rune.
[01:57:05.240 --> 01:57:07.240]  Вот, у вас есть copy.
[01:57:07.240 --> 01:57:09.240]  И copy if делает copy, но с условием.
[01:57:09.240 --> 01:57:11.240]  Копирует только если.
[01:57:11.240 --> 01:57:13.240]  Да?
[01:57:13.240 --> 01:57:19.240]  points.begin points.end
[01:57:19.240 --> 01:57:21.240]  back
[01:57:21.240 --> 01:57:23.240]  inserter
[01:57:23.240 --> 01:57:25.240]  inserter
[01:57:25.240 --> 01:57:27.240]  points
[01:57:27.240 --> 01:57:29.240]  filtered
[01:57:29.240 --> 01:57:31.240]  std ranges
[01:57:31.240 --> 01:57:33.240]  Это просто страшное.
[01:57:33.240 --> 01:57:35.240]  Давайте, у нас сейчас задача
[01:57:35.240 --> 01:57:37.240]  посмотреть, как это делается в std и как это
[01:57:37.240 --> 01:57:39.240]  можно делать стильно, модно, молодежно.
[01:57:39.240 --> 01:57:41.240]  Так, давайте вот так
[01:57:41.240 --> 01:57:43.240]  сделаем.
[01:57:43.240 --> 01:57:45.240]  Ну и лямбду там написать.
[01:57:45.240 --> 01:57:47.240]  Да, и последний аргумент это
[01:57:47.240 --> 01:57:49.240]  лямбда, которая принимает
[01:57:49.240 --> 01:57:51.240]  что?
[01:57:51.240 --> 01:57:53.240]  point.
[01:57:53.240 --> 01:57:55.240]  Мне кажется,
[01:57:55.240 --> 01:57:57.240]  вот для перфоманса вот это желательнее.
[01:57:57.240 --> 01:57:59.240]  Point занимает всего лишь
[01:57:59.240 --> 01:58:01.240]  немного байтов.
[01:58:01.240 --> 01:58:03.240]  Да.
[01:58:07.240 --> 01:58:09.240]  Ну 4 и 4. 8 байт.
[01:58:09.240 --> 01:58:11.240]  Указатель занимает 8 байт.
[01:58:11.240 --> 01:58:13.240]  Ещё добавляет индирекцию.
[01:58:13.240 --> 01:58:15.240]  Вот.
[01:58:15.240 --> 01:58:17.240]  И мы возвращаем
[01:58:17.240 --> 01:58:19.240]  ну скажем
[01:58:19.240 --> 01:58:21.240]  return
[01:58:21.240 --> 01:58:23.240]  x.
[01:58:23.240 --> 01:58:25.240]  value.x
[01:58:25.240 --> 01:58:27.240]  не знаю, меньше
[01:58:27.240 --> 01:58:29.240]  10.
[01:58:29.240 --> 01:58:31.240]  Ну вот такое простое условие.
[01:58:31.240 --> 01:58:33.240]  Вот так.
[01:58:33.240 --> 01:58:35.240]  Окей, мы это сделали.
[01:58:35.240 --> 01:58:37.240]  Мы сделали шаг фильтр.
[01:58:37.240 --> 01:58:39.240]  Что мы делаем дальше?
[01:58:39.240 --> 01:58:41.240]  Что мы делаем дальше?
[01:58:43.240 --> 01:58:45.240]  Transform.
[01:58:45.240 --> 01:58:47.240]  Мы хотим сдвинуть все точки.
[01:58:47.240 --> 01:58:49.240]  Ну давайте, раз мы пофильтровали по x,
[01:58:49.240 --> 01:58:51.240]  сдвинем их по игроку.
[01:58:51.240 --> 01:58:53.240]  Каждому игроку прибавим
[01:58:53.240 --> 01:58:55.240]  тоже 10. Как мы это
[01:58:55.240 --> 01:58:57.240]  сделаем?
[01:58:59.240 --> 01:59:01.240]  Так, std for each есть.
[01:59:01.240 --> 01:59:03.240]  Но что он делает?
[01:59:09.240 --> 01:59:11.240]  Так, а вы
[01:59:11.240 --> 01:59:13.240]  помните std for each?
[01:59:13.240 --> 01:59:15.240]  Он
[01:59:15.240 --> 01:59:17.240]  имеет ли право
[01:59:17.240 --> 01:59:19.240]  наменять элементы? Я что-то даже забыл.
[01:59:21.240 --> 01:59:23.240]  Ну хорошо.
[01:59:25.240 --> 01:59:27.240]  Вообще должен.
[01:59:27.240 --> 01:59:29.240]  Давайте попробуем.
[01:59:31.240 --> 01:59:33.240]  For each уже
[01:59:33.240 --> 01:59:35.240]  значит у нас
[01:59:35.240 --> 01:59:37.240]  points
[01:59:37.240 --> 01:59:39.240]  points filtered
[01:59:39.240 --> 01:59:41.240]  .begin
[01:59:41.240 --> 01:59:43.240]  points filtered
[01:59:43.240 --> 01:59:45.240]  .end
[01:59:45.240 --> 01:59:47.240]  принимаем лямду.
[01:59:47.240 --> 01:59:49.240]  Берем
[01:59:49.240 --> 01:59:51.240]  instant
[01:59:51.240 --> 01:59:53.240]  value
[01:59:53.240 --> 01:59:55.240]  и делаем
[01:59:57.240 --> 01:59:59.240]  что мы делаем?
[01:59:59.240 --> 02:00:01.240]  Мы делаем value.y
[02:00:01.240 --> 02:00:03.240]  плюс равно 10.
[02:00:03.240 --> 02:00:05.240]  Пока все понятно.
[02:00:05.240 --> 02:00:07.240]  Ну предположим, что это сработает.
[02:00:07.240 --> 02:00:09.240]  Мы конечно можем проверить.
[02:00:11.240 --> 02:00:13.240]  О, работает.
[02:00:13.240 --> 02:00:15.240]  Упс, фокус.
[02:00:15.240 --> 02:00:17.240]  Окей.
[02:00:17.240 --> 02:00:19.240]  Окей, хорошо. Теперь нам нужно
[02:00:19.240 --> 02:00:21.240]  посортировать.
[02:00:21.240 --> 02:00:23.240]  Как мы будем сортировать?
[02:00:23.240 --> 02:00:25.240]  А сортировать мы хотим
[02:00:27.240 --> 02:00:29.240]  по x.
[02:00:29.240 --> 02:00:31.240]  Стд sort
[02:00:31.240 --> 02:00:33.240]  от
[02:00:33.240 --> 02:00:35.240]  тоже filter
[02:00:35.240 --> 02:00:37.240]  получается.
[02:00:37.240 --> 02:00:39.240]  Filter
[02:00:39.240 --> 02:00:41.240]  .begin
[02:00:41.240 --> 02:00:43.240]  in points
[02:00:43.240 --> 02:00:45.240]  filtered
[02:00:45.240 --> 02:00:47.240]  .end
[02:00:49.240 --> 02:00:51.240]  и
[02:00:51.240 --> 02:00:53.240]  кастомный
[02:00:53.240 --> 02:00:55.240]  компаратор.
[02:00:55.240 --> 02:00:57.240]  Видите?
[02:00:57.240 --> 02:00:59.240]  Лямды только
[02:00:59.240 --> 02:01:01.240]  прошли, они уже так нужны.
[02:01:01.240 --> 02:01:03.240]  Лямды всю жизнь были нужны.
[02:01:03.240 --> 02:01:05.240]  Left,
[02:01:05.240 --> 02:01:07.240]  alt, right.
[02:01:07.240 --> 02:01:09.240]  Что возвращаем?
[02:01:13.240 --> 02:01:15.240]  Left, x меньше,
[02:01:15.240 --> 02:01:17.240]  чем right, x.
[02:01:17.240 --> 02:01:19.240]  Почему?
[02:01:19.240 --> 02:01:21.240]  Почему?
[02:01:23.240 --> 02:01:25.240]  В смысле?
[02:01:25.240 --> 02:01:27.240]  Ну подожди, хорошо, вектор чисел мы можем
[02:01:27.240 --> 02:01:29.240]  посортировать?
[02:01:29.240 --> 02:01:31.240]  Чем это отличается от сортировки вектора чисел?
[02:01:31.240 --> 02:01:33.240]  Мы просто игнорируем.
[02:01:33.240 --> 02:01:35.240]  Мы считаем равными элементами,
[02:01:35.240 --> 02:01:37.240]  у которых разные игроки, но одинаковые к суду.
[02:01:39.240 --> 02:01:41.240]  Не, это можно посортировать.
[02:01:41.240 --> 02:01:43.240]  Тут все нормально.
[02:01:43.240 --> 02:01:45.240]  И output. Как мы делаем output?
[02:01:47.240 --> 02:01:49.240]  Копии.
[02:01:51.240 --> 02:01:53.240]  Да.
[02:01:53.240 --> 02:01:55.240]  Я, честно говоря,
[02:01:55.240 --> 02:01:57.240]  устал это писать.
[02:01:59.240 --> 02:02:01.240]  Вот.
[02:02:01.240 --> 02:02:03.240]  И в std,
[02:02:03.240 --> 02:02:05.240]  astrim,
[02:02:05.240 --> 02:02:07.240]  operator.
[02:02:09.240 --> 02:02:11.240]  Да, да, да.
[02:02:11.240 --> 02:02:13.240]  Ну, предположим, что определен.
[02:02:13.240 --> 02:02:15.240]  Ладно, тогда это вот.
[02:02:17.240 --> 02:02:19.240]  Ну, типа того, да.
[02:02:19.240 --> 02:02:21.240]  Окей. Смотрите.
[02:02:21.240 --> 02:02:23.240]  Значит, в чем проблема
[02:02:23.240 --> 02:02:25.240]  этого подхода?
[02:02:25.240 --> 02:02:27.240]  Заметили вы какие-то проблемы, что они
[02:02:27.240 --> 02:02:29.240]  удобны?
[02:02:29.240 --> 02:02:31.240]  Окей, да, это решено.
[02:02:31.240 --> 02:02:33.240]  Это вот прям решается буквально вот
[02:02:33.240 --> 02:02:35.240]  следующим способом.
[02:02:37.240 --> 02:02:39.240]  Опа.
[02:02:41.240 --> 02:02:43.240]  Что у нас тут?
[02:02:43.240 --> 02:02:45.240]  Кажется, можно сделать просто вот так.
[02:02:51.240 --> 02:02:53.240]  Окей, да?
[02:02:53.240 --> 02:02:55.240]  Хорошо,
[02:02:55.240 --> 02:02:57.240]  эта проблема решили. Еще проблема
[02:02:57.240 --> 02:02:59.240]  очевидная.
[02:03:03.240 --> 02:03:05.240]  Лямды.
[02:03:05.240 --> 02:03:07.240]  Что именно в лямды?
[02:03:11.240 --> 02:03:13.240]  Что, ты хочешь сказать, что мы что-то
[02:03:13.240 --> 02:03:15.240]  сильно умнее тут напишем?
[02:03:15.240 --> 02:03:17.240]  Да. Ну, про избавление от лямб.
[02:03:17.240 --> 02:03:19.240]  Ну, смотрите, вот личное
[02:03:19.240 --> 02:03:21.240]  личное мнение нравится писать
[02:03:23.240 --> 02:03:25.240]  вот это.
[02:03:25.240 --> 02:03:27.240]  Нет, не вот это, вот это.
[02:03:27.240 --> 02:03:29.240]  Ну, то есть мы должны
[02:03:29.240 --> 02:03:31.240]  задавать кастомный компаратор, да?
[02:03:33.240 --> 02:03:35.240]  Значит, в RNG-сорте
[02:03:35.240 --> 02:03:37.240]  есть еще один параметр
[02:03:37.240 --> 02:03:39.240]  проекция так называемая.
[02:03:39.240 --> 02:03:41.240]  Вот.
[02:03:41.240 --> 02:03:43.240]  Почему? Математик.
[02:03:43.240 --> 02:03:45.240]  Смотрите. Что такое проекция?
[02:03:45.240 --> 02:03:47.240]  Мы берем наш элемент
[02:03:47.240 --> 02:03:49.240]  и его как бы превращаем в что-то другое.
[02:03:49.240 --> 02:03:51.240]  И запускаем алгоритм
[02:03:51.240 --> 02:03:53.240]  уже на вот этих превращенных элементах.
[02:03:53.240 --> 02:03:55.240]  Осортируем изначально.
[02:03:55.240 --> 02:03:57.240]  Ну, суть в том, что здесь мы хотим посортировать по иксам.
[02:03:57.240 --> 02:03:59.240]  Что я хотел сказать? Посортировать по иксам.
[02:03:59.240 --> 02:04:01.240]  Мы говорим... Смотрите.
[02:04:05.240 --> 02:04:07.240]  Смотрите, мы можем сделать вот так
[02:04:07.240 --> 02:04:09.240]  и здесь написать
[02:04:13.240 --> 02:04:15.240]  return value.x.
[02:04:17.240 --> 02:04:19.240]  Ну, тогда нет.
[02:04:19.240 --> 02:04:21.240]  Что это значит?
[02:04:21.240 --> 02:04:23.240]  Это значит, что мы сортируем вот
[02:04:23.240 --> 02:04:25.240]  по значениям, которые возвращают этот альамат. Прикольно, да?
[02:04:25.240 --> 02:04:27.240]  Зачем мы фигуельные сотни?
[02:04:27.240 --> 02:04:29.240]  Зачем у нас между этим всем?
[02:04:29.240 --> 02:04:31.240]  А, ну, потому что мы все еще принимаем
[02:04:31.240 --> 02:04:33.240]  компаратор.
[02:04:33.240 --> 02:04:35.240]  Значит, у нас же как? У STD-сорта
[02:04:35.240 --> 02:04:37.240]  есть какие-то шаблонные аргументы, правильно?
[02:04:37.240 --> 02:04:39.240]  И компаратор, как вы понимаете сейчас,
[02:04:39.240 --> 02:04:41.240]  это один из шаблонных аргументов.
[02:04:41.240 --> 02:04:43.240]  Но
[02:04:43.240 --> 02:04:45.240]  у него есть
[02:04:45.240 --> 02:04:47.240]  дефолтное значение, шаблонное.
[02:04:47.240 --> 02:04:49.240]  Это STD-less. То есть просто вызов
[02:04:49.240 --> 02:04:51.240]  оператора минус.
[02:04:51.240 --> 02:04:53.240]  Что здесь происходит? STD-сорт
[02:04:53.240 --> 02:04:55.240]  подставляется STD-less
[02:04:55.240 --> 02:04:57.240]  и это дефолтная конструкция STD-less.
[02:04:57.240 --> 02:04:59.240]  То есть мы говорим, используй оператор минус.
[02:04:59.240 --> 02:05:01.240]  Окей?
[02:05:05.240 --> 02:05:07.240]  Вот.
[02:05:07.240 --> 02:05:09.240]  Ну, потому что мы не можем сделать
[02:05:09.240 --> 02:05:11.240]  перегрузку STD-сорт под компаратор
[02:05:11.240 --> 02:05:13.240]  и перегрузку STD-сорт под
[02:05:13.240 --> 02:05:15.240]  проекцию в том, чтобы это был
[02:05:15.240 --> 02:05:17.240]  второй аргумент. Ну, потому что
[02:05:17.240 --> 02:05:19.240]  куча проблем. Понятно, да?
[02:05:19.240 --> 02:05:21.240]  Окей. Вот вам это больше нравится, чем
[02:05:21.240 --> 02:05:23.240]  раньше было или нет?
[02:05:23.240 --> 02:05:25.240]  А что если я скажу, что можно сделать
[02:05:25.240 --> 02:05:27.240]  еще лучше? Значит,
[02:05:27.240 --> 02:05:29.240]  в проекции можно передавать не только функции
[02:05:29.240 --> 02:05:31.240]  и функторы. В них
[02:05:31.240 --> 02:05:33.240]  можно передавать.
[02:05:33.240 --> 02:05:35.240]  Ну, сейчас.
[02:05:35.240 --> 02:05:37.240]  Значит, я утверждаю, что
[02:05:37.240 --> 02:05:39.240]  можно сделать вот так.
[02:05:41.240 --> 02:05:43.240]  В смысле, что вы должны знать,
[02:05:43.240 --> 02:05:45.240]  что это такое?
[02:05:45.240 --> 02:05:47.240]  Это указатель
[02:05:47.240 --> 02:05:49.240]  на...
[02:05:49.240 --> 02:05:51.240]  Да.
[02:05:51.240 --> 02:05:53.240]  Мы говорим, пожалуйста,
[02:05:53.240 --> 02:05:55.240]  спроецируй мой тип вот сюда.
[02:05:55.240 --> 02:05:57.240]  И он сделает это.
[02:05:57.240 --> 02:05:59.240]  Так.
[02:05:59.240 --> 02:06:01.240]  Вот.
[02:06:01.240 --> 02:06:03.240]  И он сделает это.
[02:06:03.240 --> 02:06:05.240]  И будем сортировать по иксам.
[02:06:05.240 --> 02:06:07.240]  Давайте попробуем скомпилировать.
[02:06:07.240 --> 02:06:09.240]  Мы скомпилировали.
[02:06:09.240 --> 02:06:11.240]  А вы сомневались?
[02:06:11.240 --> 02:06:13.240]  А, он ничего не выведет.
[02:06:13.240 --> 02:06:15.240]  Ну, он ничего не выведет, да?
[02:06:15.240 --> 02:06:17.240]  Ну, вот у нас...
[02:06:17.240 --> 02:06:19.240]  У нас точно нет чем...
[02:06:19.240 --> 02:06:21.240]  Да.
[02:06:23.240 --> 02:06:25.240]  Вот.
[02:06:25.240 --> 02:06:27.240]  Вот как вам такое? По-моему, это шикарно.
[02:06:27.240 --> 02:06:29.240]  Очень вкусно?
[02:06:29.240 --> 02:06:31.240]  Да.
[02:06:33.240 --> 02:06:35.240]  Окей. Я утверждаю, что мы все еще можем сделать лучше.
[02:06:35.240 --> 02:06:37.240]  Что еще вам здесь не нравится?
[02:06:41.240 --> 02:06:43.240]  Ну, нет.
[02:06:43.240 --> 02:06:45.240]  Мне кажется, вы упускаете
[02:06:45.240 --> 02:06:47.240]  что-то довольно ключевое.
[02:06:55.240 --> 02:06:57.240]  Я могу только
[02:06:57.240 --> 02:06:59.240]  вот так сделать.
[02:07:01.240 --> 02:07:03.240]  Да, так можно.
[02:07:07.240 --> 02:07:09.240]  Ну, ребят, я вам...
[02:07:09.240 --> 02:07:11.240]  Ну, я не знаю, вы обращали внимание или нет.
[02:07:11.240 --> 02:07:13.240]  Вот int main вообще-то ничего не возвращает.
[02:07:13.240 --> 02:07:15.240]  А компилятор не ругается.
[02:07:15.240 --> 02:07:17.240]  Ну, может возвращать. А у меня не возвращает.
[02:07:17.240 --> 02:07:19.240]  Компилятор не ругается.
[02:07:19.240 --> 02:07:21.240]  Он сам добавляет. Это специально для main.
[02:07:23.240 --> 02:07:25.240]  Ну, void тоже может.
[02:07:25.240 --> 02:07:27.240]  Войд всегда...
[02:07:27.240 --> 02:07:29.240]  Всегда все хорошо уйдет.
[02:07:31.240 --> 02:07:33.240]  Нельзя.
[02:07:35.240 --> 02:07:37.240]  Ладно, нельзя.
[02:07:37.240 --> 02:07:39.240]  А почему нельзя?
[02:07:39.240 --> 02:07:41.240]  Компилятор, по-моему, зависит еще.
[02:07:41.240 --> 02:07:43.240]  MSWC может.
[02:07:43.240 --> 02:07:45.240]  Да, возможно.
[02:07:45.240 --> 02:07:47.240]  Значит, это нестандартное расширение.
[02:07:47.240 --> 02:07:49.240]  Пам-пам.
[02:07:49.240 --> 02:07:51.240]  Окей.
[02:07:51.240 --> 02:07:53.240]  Копииф. Что нам не нравится в копиифе?
[02:07:53.240 --> 02:07:55.240]  Самое главное, друзья.
[02:07:57.240 --> 02:07:59.240]  Лямда.
[02:07:59.240 --> 02:08:01.240]  Ну, смотри.
[02:08:03.240 --> 02:08:05.240]  Я не понимаю, как сделать лучше проверку.
[02:08:05.240 --> 02:08:07.240]  Действительно. Потому что мы хотим в проверку
[02:08:07.240 --> 02:08:09.240]  запихивать произвольный предикат. Правильно?
[02:08:09.240 --> 02:08:11.240]  Я хочу. А вы?
[02:08:13.240 --> 02:08:15.240]  Тогда оставляем лямду.
[02:08:23.240 --> 02:08:25.240]  Это человек что-то знает.
[02:08:27.240 --> 02:08:29.240]  Друзья, у меня
[02:08:29.240 --> 02:08:31.240]  подозрение, что самое плохое в этом коде.
[02:08:31.240 --> 02:08:33.240]  Вот до этого мы правили какие-то...
[02:08:33.240 --> 02:08:35.240]  Мы делали код более красивым.
[02:08:37.240 --> 02:08:39.240]  Идейно он остался таким же.
[02:08:39.240 --> 02:08:41.240]  Но основная проблема в том, что он
[02:08:41.240 --> 02:08:43.240]  копия. Потенциально копия всех наших
[02:08:43.240 --> 02:08:45.240]  данных. Правильно?
[02:08:45.240 --> 02:08:47.240]  Ну, вообще неприятно так-то.
[02:08:47.240 --> 02:08:49.240]  Да. А вот если у нас есть какой-то
[02:08:49.240 --> 02:08:51.240]  view, который...
[02:08:51.240 --> 02:08:53.240]  Вот представьте себе. У нас есть
[02:08:53.240 --> 02:08:55.240]  вектор. Это range. Мы можем сказать
[02:08:55.240 --> 02:08:57.240]  view. Как string view,
[02:08:57.240 --> 02:08:59.240]  только какой-нибудь условно...
[02:08:59.240 --> 02:09:01.240]  Условно говоря, vector view.
[02:09:01.240 --> 02:09:03.240]  Такого нет, потому что есть лучше.
[02:09:05.240 --> 02:09:07.240]  Которого сделаем дополнительный параметр.
[02:09:07.240 --> 02:09:09.240]  Пожалуйста, скипай все элементы
[02:09:09.240 --> 02:09:11.240]  типа filter, vector, view.
[02:09:11.240 --> 02:09:13.240]  Почему? Я считаю, что вот это неэффективно
[02:09:13.240 --> 02:09:15.240]  по времени. Мы кучу динамических локаций
[02:09:15.240 --> 02:09:17.240]  делаем.
[02:09:17.240 --> 02:09:19.240]  Партишен.
[02:09:21.240 --> 02:09:23.240]  На месте их переставить.
[02:09:23.240 --> 02:09:25.240]  Смотрите.
[02:09:27.240 --> 02:09:29.240]  Да, что ж такое-то?
[02:09:29.240 --> 02:09:31.240]  Point заключается в следующем.
[02:09:31.240 --> 02:09:33.240]  Что мы хотим...
[02:09:33.240 --> 02:09:35.240]  Вот эта операция, видите, тут мы
[02:09:35.240 --> 02:09:37.240]  хотим...
[02:09:37.240 --> 02:09:39.240]  Что мы хотим...
[02:09:39.240 --> 02:09:41.240]  Вот эта операция, видите, тут
[02:09:41.240 --> 02:09:43.240]  написано filter, а потом происходит copy if.
[02:09:43.240 --> 02:09:45.240]  Вот мы хотим именно фильтровать
[02:09:45.240 --> 02:09:47.240]  изначальные
[02:09:47.240 --> 02:09:49.240]  данные.
[02:09:49.240 --> 02:09:51.240]  Мы не хотим их копировать.
[02:09:51.240 --> 02:09:53.240]  Стандартный библиотек не дает нам
[02:09:53.240 --> 02:09:55.240]  других штук. А если бы мы их
[02:09:55.240 --> 02:09:57.240]  фильтровали, а не копировали, нам бы пришлось
[02:09:57.240 --> 02:09:59.240]  писать гигантский фор. Потому что
[02:09:59.240 --> 02:10:01.240]  не написав гигантский фор,
[02:10:01.240 --> 02:10:03.240]  следующие алгоритмы у нас сломаются.
[02:10:03.240 --> 02:10:05.240]  Потому что все следующие алгоритмы зависят
[02:10:05.240 --> 02:10:07.240]  от предыдущих. Понятно?
[02:10:09.240 --> 02:10:11.240]  Вот в чем проблема?
[02:10:11.240 --> 02:10:13.240]  В том, что если мы сразу отфильтруем,
[02:10:13.240 --> 02:10:15.240]  нам придется этот результат
[02:10:15.240 --> 02:10:17.240]  где-то хранить. Значит, мы хотим
[02:10:17.240 --> 02:10:19.240]  фильтровать не сразу.
[02:10:19.240 --> 02:10:21.240]  На самом деле, что нам позволяют
[02:10:21.240 --> 02:10:23.240]  RNG? Они нам позволяют сделать гигантскую
[02:10:23.240 --> 02:10:25.240]  композицию из алгоритмов и
[02:10:25.240 --> 02:10:27.240]  запустить их только все вместе, когда мы
[02:10:27.240 --> 02:10:29.240]  закончим.
[02:10:29.240 --> 02:10:31.240]  То есть мы хотим идти по ходу, фильтровать,
[02:10:31.240 --> 02:10:33.240]  потом выполнять transform
[02:10:33.240 --> 02:10:35.240]  и выполнять потом sort, когда все это
[02:10:35.240 --> 02:10:37.240]  закончится.
[02:10:37.240 --> 02:10:39.240]  Как это выглядит
[02:10:41.240 --> 02:10:43.240]  у человека, у которого есть RNG? Значит,
[02:10:43.240 --> 02:10:45.240]  мы говорим
[02:10:45.240 --> 02:10:47.240]  points. Я сразу не буду вас
[02:10:47.240 --> 02:10:49.240]  мучить. Покажу еще одну классную
[02:10:49.240 --> 02:10:51.240]  фичу.
[02:10:51.240 --> 02:10:53.240]  Можно писать вот так.
[02:10:53.240 --> 02:10:55.240]  Points.
[02:10:55.240 --> 02:10:57.240]  Как в линуксе, пайпируем их,
[02:10:57.240 --> 02:10:59.240]  так сказать. Куда?
[02:10:59.240 --> 02:11:01.240]  В views
[02:11:01.240 --> 02:11:03.240]  фильтр от
[02:11:03.240 --> 02:11:05.240]  лямды.
[02:11:05.240 --> 02:11:07.240]  Какой лямды?
[02:11:07.240 --> 02:11:09.240]  От вот такой лямды.
[02:11:17.240 --> 02:11:19.240]  Значит,
[02:11:19.240 --> 02:11:21.240]  можем вот так сделать.
[02:11:21.240 --> 02:11:23.240]  Что это за синтаксис?
[02:11:23.240 --> 02:11:25.240]  Ну, это
[02:11:25.240 --> 02:11:27.240]  типа того.
[02:11:31.240 --> 02:11:33.240]  Ну, смотрите, палка
[02:11:33.240 --> 02:11:35.240]  это оператор.
[02:11:35.240 --> 02:11:37.240]  Вертикальная палка это
[02:11:37.240 --> 02:11:39.240]  оператор в языке.
[02:11:39.240 --> 02:11:41.240]  Собственно говоря, побитого или...
[02:11:41.240 --> 02:11:43.240]  Здесь, на самом деле, чуть более хитрый механизм,
[02:11:43.240 --> 02:11:45.240]  к сожалению.
[02:11:51.240 --> 02:11:53.240]  Вот здесь
[02:11:53.240 --> 02:11:55.240]  здесь тонкий момент.
[02:11:55.240 --> 02:11:57.240]  На самом деле, проблема в том,
[02:11:57.240 --> 02:11:59.240]  что, значит, вот этот оператор
[02:11:59.240 --> 02:12:01.240]  работает для
[02:12:01.240 --> 02:12:03.240]  стандартных рейнджей, стандартных
[02:12:03.240 --> 02:12:05.240]  view, а
[02:12:05.240 --> 02:12:07.240]  ваш view пока что
[02:12:07.240 --> 02:12:09.240]  не умеет такой оператор
[02:12:09.240 --> 02:12:11.240]  делать. Вы можете написать свои
[02:12:11.240 --> 02:12:13.240]  произвольные view, но его придется вызывать
[02:12:13.240 --> 02:12:15.240]  типа скобочками, как обычно. Проблема
[02:12:15.240 --> 02:12:17.240]  вызывать скобочками и не палочкой в том, что
[02:12:17.240 --> 02:12:19.240]  ну, как это будет?
[02:12:19.240 --> 02:12:21.240]  У вас будет фильтр от
[02:12:21.240 --> 02:12:23.240]  points, от этого вы вызовете
[02:12:23.240 --> 02:12:25.240]  там
[02:12:25.240 --> 02:12:27.240]  foreach, от этого вы вызовете
[02:12:27.240 --> 02:12:29.240]  transform. Вам нужно читать выражение
[02:12:29.240 --> 02:12:31.240]  изнутри в снаружу.
[02:12:31.240 --> 02:12:33.240]  Понятно? То есть
[02:12:33.240 --> 02:12:35.240]  я могу также написать
[02:12:35.240 --> 02:12:37.240]  типа фильтр
[02:12:37.240 --> 02:12:39.240]  от points.
[02:12:39.240 --> 02:12:41.240]  Потом напишу
[02:12:41.240 --> 02:12:43.240]  transform
[02:12:43.240 --> 02:12:45.240]  от filter, от points.
[02:12:45.240 --> 02:12:47.240]  И вот сначала происходит
[02:12:47.240 --> 02:12:49.240]  вот это, потом вот это, потом вот это. Это неудобно читать.
[02:12:49.240 --> 02:12:51.240]  А палка разворачивает наоборот.
[02:12:55.240 --> 02:12:57.240]  Палка преобразует
[02:12:57.240 --> 02:12:59.240]  вот это, вот
[02:12:59.240 --> 02:13:01.240]  вот это, вот это.
[02:13:09.240 --> 02:13:11.240]  Да, я говорю, это особый случай,
[02:13:11.240 --> 02:13:13.240]  он вшит в компилятор, типа
[02:13:19.240 --> 02:13:21.240]  насколько я понимаю, у него есть
[02:13:21.240 --> 02:13:23.240]  списочек, вот для этих штук
[02:13:23.240 --> 02:13:25.240]  сделай вот такую магию,
[02:13:25.240 --> 02:13:27.240]  пожалуйста, пока.
[02:13:31.240 --> 02:13:33.240]  Да.
[02:13:35.240 --> 02:13:37.240]  Ну, тебе придется написать этот
[02:13:37.240 --> 02:13:39.240]  оператор.
[02:13:43.240 --> 02:13:45.240]  В общем, я не уверен, насколько
[02:13:45.240 --> 02:13:47.240]  я понимаю, это не сделать.
[02:13:47.240 --> 02:13:49.240]  Вот. Можно попробовать,
[02:13:49.240 --> 02:13:51.240]  если у вас получится, браво,
[02:13:51.240 --> 02:13:53.240]  пожалуйста, научите меня.
[02:13:55.240 --> 02:13:57.240]  Сейчас, чем-то критерия отличается.
[02:13:57.240 --> 02:13:59.240]  Смотрите.
[02:13:59.240 --> 02:14:01.240]  Что такое вот эта
[02:14:01.240 --> 02:14:03.240]  штука? В.
[02:14:03.240 --> 02:14:05.240]  Давайте назовем ее filtered.
[02:14:05.240 --> 02:14:07.240]  Вот давайте начнем с малого.
[02:14:07.240 --> 02:14:09.240]  Мы сказали points, палка,
[02:14:09.240 --> 02:14:11.240]  views, filter.
[02:14:11.240 --> 02:14:13.240]  Вот мы теперь можем, во-первых, убрать вот это.
[02:14:13.240 --> 02:14:15.240]  А во-вторых,
[02:14:15.240 --> 02:14:17.240]  сделать вот это.
[02:14:19.240 --> 02:14:21.240]  И вроде все еще даже скомпилироваться.
[02:14:21.240 --> 02:14:23.240]  Нет.
[02:14:23.240 --> 02:14:25.240]  Expected запятая.
[02:14:25.240 --> 02:14:27.240]  41.
[02:14:31.240 --> 02:14:33.240]  38, а, ой, да, я не прав.
[02:14:35.240 --> 02:14:37.240]  И points filtered
[02:14:37.240 --> 02:14:39.240]  не declared.
[02:14:39.240 --> 02:14:41.240]  Не declared.
[02:14:43.240 --> 02:14:45.240]  А, кстати,
[02:14:45.240 --> 02:14:47.240]  да, нельзя, но это мы посмотрим.
[02:14:47.240 --> 02:14:49.240]  Сейчас мы поймем, почему.
[02:14:49.240 --> 02:14:51.240]  Блин, ссор там нехороший пример.
[02:14:51.240 --> 02:14:53.240]  Ну, в общем, вот.
[02:14:53.240 --> 02:14:55.240]  Смотрите. Вот на этом этапе
[02:14:55.240 --> 02:14:57.240]  у нас произошел
[02:14:57.240 --> 02:14:59.240]  вот что такое filtered.
[02:14:59.240 --> 02:15:01.240]  Filtered — это объект
[02:15:01.240 --> 02:15:03.240]  довольно сложного типа, но смысл
[02:15:03.240 --> 02:15:05.240]  в том, что это view на наш
[02:15:05.240 --> 02:15:07.240]  изначальный вектор. Он
[02:15:07.240 --> 02:15:09.240]  не владеет никакими элементами, как сам.
[02:15:09.240 --> 02:15:11.240]  Он только смотрит на вектор. При этом,
[02:15:11.240 --> 02:15:13.240]  если мы сейчас пройдемся по нему вот этим
[02:15:13.240 --> 02:15:15.240]  фарычем, он выдаст только те элементы,
[02:15:15.240 --> 02:15:17.240]  которые удовлетворяют вот этому условию.
[02:15:19.240 --> 02:15:21.240]  Он пропустит все ненужные.
[02:15:23.240 --> 02:15:25.240]  Окей?
[02:15:31.240 --> 02:15:33.240]  Да.
[02:15:33.240 --> 02:15:35.240]  Пока.
[02:15:35.240 --> 02:15:37.240]  Еще раз.
[02:15:37.240 --> 02:15:39.240]  Filter — это структура, у которой
[02:15:39.240 --> 02:15:41.240]  просто есть начальный итератор, конечный
[02:15:41.240 --> 02:15:43.240]  итератор, и внутри, по-моему, хранится
[02:15:43.240 --> 02:15:45.240]  этот, ну да,
[02:15:45.240 --> 02:15:47.240]  предикат. Все, больше там ничего не хранится.
[02:15:51.240 --> 02:15:53.240]  Нет, предикат должен
[02:15:53.240 --> 02:15:55.240]  в итератор.
[02:15:55.240 --> 02:15:57.240]  Filter — это же не range.
[02:15:57.240 --> 02:15:59.240]  Filter — это view.
[02:15:59.240 --> 02:16:01.240]  Ну, view — это STD range с там view.
[02:16:03.240 --> 02:16:05.240]  Честно, у нас вот лямбда,
[02:16:05.240 --> 02:16:07.240]  мы же в любом случае будем проходить
[02:16:07.240 --> 02:16:09.240]  цели. Да.
[02:16:09.240 --> 02:16:11.240]  Смотри, у нас на этом этапе
[02:16:11.240 --> 02:16:13.240]  во-первых, вообще не произошло
[02:16:13.240 --> 02:16:15.240]  никаких вычислений, а во-вторых,
[02:16:15.240 --> 02:16:17.240]  когда мы...
[02:16:17.240 --> 02:16:19.240]  Еще раз, что такое filter?
[02:16:19.240 --> 02:16:21.240]  Объект, в котором хранится
[02:16:21.240 --> 02:16:23.240]  указатель на начало
[02:16:23.240 --> 02:16:25.240]  вектора.
[02:16:25.240 --> 02:16:27.240]  Окей?
[02:16:29.240 --> 02:16:31.240]  Он сам умеет возвращать свой собственный
[02:16:31.240 --> 02:16:33.240]  итератор, указатель-итератор.
[02:16:33.240 --> 02:16:35.240]  Что делает этот итератор?
[02:16:35.240 --> 02:16:37.240]  Он говорит,
[02:16:37.240 --> 02:16:39.240]  текущий элемент вектора
[02:16:39.240 --> 02:16:41.240]  удовлетворяет условию.
[02:16:41.240 --> 02:16:43.240]  Если да, на разоменование
[02:16:43.240 --> 02:16:45.240]  верну его. Если нет,
[02:16:45.240 --> 02:16:47.240]  пойду вперед.
[02:16:47.240 --> 02:16:49.240]  Типа на
[02:16:49.240 --> 02:16:51.240]  плюс-плюс.
[02:17:01.240 --> 02:17:03.240]  Когда мы проходимся, мы все равно
[02:17:03.240 --> 02:17:05.240]  сверяем.
[02:17:05.240 --> 02:17:07.240]  Что мы копируем?
[02:17:07.240 --> 02:17:09.240]  Это чисто из-за лямбды.
[02:17:09.240 --> 02:17:11.240]  А,
[02:17:11.240 --> 02:17:13.240]  это копирование, да.
[02:17:13.240 --> 02:17:15.240]  Ну, в смысле, да, но я могу написать
[02:17:15.240 --> 02:17:17.240]  интересант, тогда этого копирования не будет,
[02:17:17.240 --> 02:17:19.240]  не суть.
[02:17:19.240 --> 02:17:21.240]  Это такой метод, да, у него
[02:17:21.240 --> 02:17:23.240]  плюс-плюс, ну или что такое?
[02:17:23.240 --> 02:17:25.240]  У него оператор плюс-плюс,
[02:17:25.240 --> 02:17:27.240]  в общем, какой-то.
[02:17:27.240 --> 02:17:29.240]  Он все равно будет находить массив золота.
[02:17:29.240 --> 02:17:31.240]  Мы не выделили второе вектор.
[02:17:37.240 --> 02:17:39.240]  Да, да.
[02:17:43.240 --> 02:17:45.240]  С фильтр?
[02:17:45.240 --> 02:17:47.240]  Кстати, какие есть операции с фильтр?
[02:17:49.240 --> 02:17:51.240]  Смотрите.
[02:17:59.240 --> 02:18:01.240]  За бесплатно, практически. Золот единицы.
[02:18:05.240 --> 02:18:07.240]  Вот здесь ничего
[02:18:07.240 --> 02:18:09.240]  не произошло еще с элементами
[02:18:09.240 --> 02:18:11.240]  вектора. Них никто не смотрел.
[02:18:11.240 --> 02:18:13.240]  Мы только создали, вот это
[02:18:13.240 --> 02:18:15.240]  ключевая идея, что мы на этом этапе
[02:18:15.240 --> 02:18:17.240]  не выполнили никаких вычислений.
[02:18:19.240 --> 02:18:21.240]  Да.
[02:18:21.240 --> 02:18:23.240]  Но каждую фурыщ
[02:18:23.240 --> 02:18:25.240]  и так будет ЗОТН.
[02:18:25.240 --> 02:18:27.240]  Но, да, это важно помнить, что
[02:18:27.240 --> 02:18:29.240]  вот эта штука будет пересчитываться
[02:18:29.240 --> 02:18:31.240]  каждый раз, когда вы вызываетесь.
[02:18:31.240 --> 02:18:33.240]  Если вам нужно это куда-то сохранить, вы можете
[02:18:33.240 --> 02:18:35.240]  сохранить.
[02:18:35.240 --> 02:18:37.240]  Нет, она
[02:18:37.240 --> 02:18:39.240]  не будет создавать под собой никакого нового
[02:18:39.240 --> 02:18:41.240]  хранилища.
[02:18:47.240 --> 02:18:49.240]  Если 3 элемента подходят, а
[02:18:49.240 --> 02:18:51.240]  3 не подходят, то мы можем, что сделать?
[02:18:51.240 --> 02:18:53.240]  Да.
[02:18:55.240 --> 02:18:57.240]  Вот.
[02:18:57.240 --> 02:18:59.240]  Что есть у фильтрда?
[02:18:59.240 --> 02:19:01.240]  У фильтрда...
[02:19:05.240 --> 02:19:07.240]  У него
[02:19:07.240 --> 02:19:09.240]  сложный тип.
[02:19:09.240 --> 02:19:11.240]  Давай его попробуем вывести.
[02:19:13.240 --> 02:19:15.240]  Print
[02:19:15.240 --> 02:19:17.240]  filtered
[02:19:17.240 --> 02:19:19.240]  type
[02:19:19.240 --> 02:19:21.240]  of
[02:19:21.240 --> 02:19:23.240]  filtered.
[02:19:29.240 --> 02:19:31.240]  Вот такой.
[02:19:31.240 --> 02:19:33.240]  А type of он в run time?
[02:19:33.240 --> 02:19:35.240]  А?
[02:19:35.240 --> 02:19:37.240]  Type of он в run time.
[02:19:37.240 --> 02:19:39.240]  Type of...
[02:19:39.240 --> 02:19:41.240]  50 на 50.
[02:19:41.240 --> 02:19:43.240]  Ну вот, смотрите.
[02:19:43.240 --> 02:19:45.240]  СТД...
[02:19:45.240 --> 02:19:47.240]  Кстати, можем посмотреть. Здесь есть важная
[02:19:47.240 --> 02:19:49.240]  особенность, которая отличает
[02:19:49.240 --> 02:19:51.240]  вот эти новые view от string view, о
[02:19:51.240 --> 02:19:53.240]  котором мы поговорили в начале.
[02:19:53.240 --> 02:19:55.240]  Что у нас такое? У нас есть STD ranges
[02:19:55.240 --> 02:19:57.240]  filtered view
[02:19:57.240 --> 02:19:59.240]  от STD ranges
[02:19:59.240 --> 02:20:01.240]  ref view
[02:20:01.240 --> 02:20:03.240]  от STD vector point.
[02:20:05.240 --> 02:20:07.240]  Ref view это
[02:20:09.240 --> 02:20:11.240]  такой
[02:20:11.240 --> 02:20:13.240]  view, который
[02:20:13.240 --> 02:20:15.240]  собственно говоря, просто
[02:20:15.240 --> 02:20:17.240]  не владеет.
[02:20:17.240 --> 02:20:19.240]  Вот и все.
[02:20:21.240 --> 02:20:23.240]  Вот.
[02:20:23.240 --> 02:20:25.240]  Во-первых, это композиция, значит
[02:20:25.240 --> 02:20:27.240]  если вы навешите еще палок, вот здесь увеличится
[02:20:27.240 --> 02:20:29.240]  вот эта вот строчечка.
[02:20:29.240 --> 02:20:31.240]  Но, что важно, мы
[02:20:31.240 --> 02:20:33.240]  помним, что мы пришли из вектора.
[02:20:35.240 --> 02:20:37.240]  В STD string view
[02:20:37.240 --> 02:20:39.240]  мы не помним, откуда мы пришли. Мы могли
[02:20:39.240 --> 02:20:41.240]  пришли из конччара, мы могли
[02:20:41.240 --> 02:20:43.240]  из STD string, мы могли
[02:20:43.240 --> 02:20:45.240]  из двух произвольных итераторов.
[02:20:45.240 --> 02:20:47.240]  Здесь мы помним.
[02:20:47.240 --> 02:20:49.240]  Вот.
[02:20:49.240 --> 02:20:51.240]  И мы можем, кстати, вызывать точка
[02:20:51.240 --> 02:20:53.240]  base.
[02:20:55.240 --> 02:20:57.240]  Filtered
[02:20:57.240 --> 02:20:59.240]  точка base.
[02:21:03.240 --> 02:21:05.240]  Ну, ref
[02:21:05.240 --> 02:21:07.240]  view.
[02:21:07.240 --> 02:21:09.240]  Точка base у любого
[02:21:09.240 --> 02:21:11.240]  view возвращает то,
[02:21:11.240 --> 02:21:13.240]  как бы, раскрывает
[02:21:13.240 --> 02:21:15.240]  одну луковичку.
[02:21:15.240 --> 02:21:17.240]  Понятно, да?
[02:21:17.240 --> 02:21:19.240]  Да,
[02:21:19.240 --> 02:21:21.240]  как она раскрывает эту луковичку? Она возвращает
[02:21:21.240 --> 02:21:23.240]  копию. То есть, если мы
[02:21:23.240 --> 02:21:25.240]  сделаем вот так, мы здесь
[02:21:25.240 --> 02:21:27.240]  получим вектор.
[02:21:31.240 --> 02:21:33.240]  Ampersand.
[02:21:41.240 --> 02:21:43.240]  Должны быть копии.
[02:21:43.240 --> 02:21:45.240]  Ну ладно.
[02:21:47.240 --> 02:21:49.240]  Вот.
[02:21:49.240 --> 02:21:51.240]  Так, с этим понятно.
[02:21:53.240 --> 02:21:55.240]  Окей, давайте немножко
[02:21:55.240 --> 02:21:57.240]  ускоримся, наверное.
[02:21:57.240 --> 02:21:59.240]  Сколько у нас там времени
[02:21:59.240 --> 02:22:01.240]  осталось? Не очень много, кажется.
[02:22:05.240 --> 02:22:07.240]  Так, ну давайте тогда, раз мы поговорили
[02:22:07.240 --> 02:22:09.240]  про view, во-первых, я вам покажу несколько
[02:22:09.240 --> 02:22:11.240]  классных полезных view, во-вторых, скажем формально
[02:22:11.240 --> 02:22:13.240]  какие требования к тому, чтобы view был view.
[02:22:13.240 --> 02:22:15.240]  Во-первых, view это range.
[02:22:17.240 --> 02:22:19.240]  Во-вторых, view
[02:22:19.240 --> 02:22:21.240]  должен быть movable.
[02:22:25.240 --> 02:22:27.240]  Давайте я вам прямо покажу, мне кажется, вам понравится.
[02:22:27.240 --> 02:22:29.240]  Смотрите.
[02:22:31.240 --> 02:22:33.240]  Ranges library.
[02:22:35.240 --> 02:22:37.240]  View.
[02:22:37.240 --> 02:22:39.240]  Вот. Ranges view.
[02:22:39.240 --> 02:22:41.240]  Смотрите, какие у нас требования к
[02:22:41.240 --> 02:22:43.240]  view. Она должна быть range,
[02:22:43.240 --> 02:22:45.240]  она должна быть movable
[02:22:45.240 --> 02:22:47.240]  и...
[02:22:49.240 --> 02:22:51.240]  Что значит вот эта штука? Эта штука значит, что мы
[02:22:51.240 --> 02:22:53.240]  сказали,
[02:22:53.240 --> 02:22:55.240]  что мы view.
[02:22:55.240 --> 02:22:57.240]  Вот три условия. Мы должны быть range, мы должны
[02:22:57.240 --> 02:22:59.240]  быть movable, и мы должны сами
[02:22:59.240 --> 02:23:01.240]  обещать клятвенно, что мы являемся view.
[02:23:01.240 --> 02:23:03.240]  Что значит клятвенно обещать, что мы являемся
[02:23:03.240 --> 02:23:05.240]  view? Это значит, у нас есть семантические
[02:23:05.240 --> 02:23:07.240]  реквариенты. Вот здесь написано, что
[02:23:07.240 --> 02:23:09.240]  мы должны
[02:23:09.240 --> 02:23:11.240]  муваться за от
[02:23:11.240 --> 02:23:13.240]  единицы, наш деструктор
[02:23:13.240 --> 02:23:15.240]  должен работать за от единицы,
[02:23:15.240 --> 02:23:17.240]  и если мы вдруг решили сделать
[02:23:17.240 --> 02:23:19.240]  копирование, оно должно работать за от
[02:23:19.240 --> 02:23:21.240]  единицы. Смысл в том, что view
[02:23:21.240 --> 02:23:23.240]  это очень легковесный объект.
[02:23:31.240 --> 02:23:33.240]  Мы зачем муваться?
[02:23:35.240 --> 02:23:37.240]  Зачем муваться?
[02:23:37.240 --> 02:23:39.240]  Ну, смотри, хорошо. Зачем
[02:23:39.240 --> 02:23:41.240]  unique pointer муваться? Он же
[02:23:41.240 --> 02:23:43.240]  легковесный.
[02:23:43.240 --> 02:23:45.240]  А, стоп, вы еще... Нет,
[02:23:45.240 --> 02:23:47.240]  unique pointer... А, были, были.
[02:23:49.240 --> 02:23:51.240]  Ну, смотри,
[02:23:51.240 --> 02:23:53.240]  потребовать от view
[02:23:53.240 --> 02:23:55.240]  копировать, это слишком сильно.
[02:23:55.240 --> 02:23:57.240]  От всех view копироваться. Есть view, который
[02:23:57.240 --> 02:23:59.240]  нельзя копировать. По примеру,
[02:23:59.240 --> 02:24:01.240]  идейно, условно говоря,
[02:24:01.240 --> 02:24:03.240]  unique ptr, это view, который владеют чем-то.
[02:24:03.240 --> 02:24:05.240]  Вот есть std owning view,
[02:24:05.240 --> 02:24:07.240]  он
[02:24:07.240 --> 02:24:09.240]  владеет своим
[02:24:09.240 --> 02:24:11.240]  рейнджом, его нельзя копировать, но его
[02:24:11.240 --> 02:24:13.240]  можно мывать. Вот мы хотим, чтобы
[02:24:13.240 --> 02:24:15.240]  хотя бы мывать можно было.
[02:24:15.240 --> 02:24:17.240]  Объект, который нельзя
[02:24:17.240 --> 02:24:19.240]  ни мывать, ни копировать, это сложный
[02:24:19.240 --> 02:24:21.240]  объект, чтобы с ним нормально работать.
[02:24:21.240 --> 02:24:23.240]  Вот.
[02:24:23.240 --> 02:24:25.240]  Окей.
[02:24:25.240 --> 02:24:27.240]  Ну, смотрите,
[02:24:27.240 --> 02:24:29.240]  для применения в повседневной
[02:24:29.240 --> 02:24:31.240]  жизни, что нам может понадобиться?
[02:24:31.240 --> 02:24:33.240]  У нас есть...
[02:24:33.240 --> 02:24:35.240]  Давайте покажу, например,
[02:24:35.240 --> 02:24:37.240]  for reach, как это обычно используется.
[02:24:37.240 --> 02:24:39.240]  И там
[02:24:39.240 --> 02:24:41.240]  двоеточие. У нас там был points.
[02:24:41.240 --> 02:24:43.240]  Вот, представьте,
[02:24:43.240 --> 02:24:45.240]  что points теперь это, например,
[02:24:45.240 --> 02:24:47.240]  фигура. Да?
[02:24:47.240 --> 02:24:49.240]  Это набор точек, которые составляют полигон.
[02:24:49.240 --> 02:24:51.240]  И мы хотим его
[02:24:51.240 --> 02:24:53.240]  нарисовать.
[02:24:53.240 --> 02:24:55.240]  Что значит нам? Нам нужно пройти
[02:24:55.240 --> 02:24:57.240]  по нему по всему,
[02:24:57.240 --> 02:24:59.240]  плюс еще раз вернуться в первый элемент,
[02:24:59.240 --> 02:25:01.240]  чтобы каждый отрезок получить.
[02:25:01.240 --> 02:25:03.240]  Понятна проблема, да?
[02:25:05.240 --> 02:25:07.240]  Как бы мы это
[02:25:07.240 --> 02:25:09.240]  написали? Мы написали
[02:25:09.240 --> 02:25:11.240]  обычным циклам.
[02:25:11.240 --> 02:25:13.240]  For reach, потом next.
[02:25:13.240 --> 02:25:15.240]  For reach от 0 до 0.
[02:25:15.240 --> 02:25:17.240]  Да.
[02:25:17.240 --> 02:25:19.240]  И в конце еще сделать еще одну дополнительную
[02:25:19.240 --> 02:25:21.240]  итерацию после цикла.
[02:25:21.240 --> 02:25:23.240]  Нет, просто в хоре увеличение на 1 больше.
[02:25:23.240 --> 02:25:25.240]  В хоре мы помним e,
[02:25:25.240 --> 02:25:27.240]  и у нас в каждой итерации цикла
[02:25:27.240 --> 02:25:29.240]  мы соберем переменную, как кружит,
[02:25:29.240 --> 02:25:31.240]  и плюс один размер.
[02:25:31.240 --> 02:25:33.240]  Окей, да, это вариант.
[02:25:37.240 --> 02:25:39.240]  Вот, да, можно сделать так.
[02:25:39.240 --> 02:25:41.240]  Добавлять в конец
[02:25:41.240 --> 02:25:43.240]  не хочется, это, во-первых, pushback,
[02:25:43.240 --> 02:25:45.240]  что можно сделать?
[02:25:45.240 --> 02:25:47.240]  Можно сделать views.
[02:25:49.240 --> 02:25:51.240]  О, кстати, это, кстати, сложно.
[02:25:51.240 --> 02:25:53.240]  Смотрите,
[02:25:53.240 --> 02:25:55.240]  мы хотим добавить view.
[02:25:55.240 --> 02:25:57.240]  Здесь views.
[02:25:59.240 --> 02:26:01.240]  Так, как же тебе зовут?
[02:26:01.240 --> 02:26:03.240]  А не join ли тебя зовут?
[02:26:07.240 --> 02:26:09.240]  Split, join.
[02:26:15.240 --> 02:26:17.240]  Нет, ладно.
[02:26:17.240 --> 02:26:19.240]  Давайте сначала начнем с простого.
[02:26:19.240 --> 02:26:21.240]  Как бы я это, например,
[02:26:21.240 --> 02:26:23.240]  сделал? Сказал...
[02:26:25.240 --> 02:26:27.240]  last
[02:26:27.240 --> 02:26:33.240]  равно points.front.
[02:26:33.240 --> 02:26:35.240]  Берем первый элемент, потом говорим.
[02:26:35.240 --> 02:26:37.240]  Мы хотим пройтись по
[02:26:41.240 --> 02:26:43.240]  points, палка,
[02:26:45.240 --> 02:26:47.240]  drop 1.
[02:26:47.240 --> 02:26:49.240]  Что делает drop 1?
[02:26:49.240 --> 02:26:51.240]  Пропускает сколько-то элементов.
[02:26:55.240 --> 02:26:57.240]  Смотрите,
[02:26:57.240 --> 02:26:59.240]  когда мы делаем
[02:26:59.240 --> 02:27:01.240]  какой-то view, потом палка
[02:27:01.240 --> 02:27:03.240]  views.drop, он берет
[02:27:03.240 --> 02:27:05.240]  этот view, но отщипывает
[02:27:05.240 --> 02:27:07.240]  от начала столько, сколько
[02:27:07.240 --> 02:27:09.240]  мы ему скажем.
[02:27:09.240 --> 02:27:11.240]  Почему? Points это вект.
[02:27:11.240 --> 02:27:13.240]  Ну да, это не view, но это range.
[02:27:13.240 --> 02:27:15.240]  Не важно.
[02:27:15.240 --> 02:27:17.240]  Range тоже так работает.
[02:27:17.240 --> 02:27:19.240]  Призвольный range вот так может делать.
[02:27:19.240 --> 02:27:21.240]  Вот, сейчас мы пропустим
[02:27:21.240 --> 02:27:23.240]  view это...
[02:27:23.240 --> 02:27:25.240]  Да, смотри, view обязательно
[02:27:25.240 --> 02:27:27.240]  range, plus movable, plus сказал,
[02:27:27.240 --> 02:27:29.240]  что он view.
[02:27:29.240 --> 02:27:31.240]  Зачем last тогда?
[02:27:31.240 --> 02:27:33.240]  А?
[02:27:33.240 --> 02:27:35.240]  Зачем last? Ну, потому что мы можем
[02:27:35.240 --> 02:27:37.240]  делать
[02:27:37.240 --> 02:27:39.240]  point
[02:27:39.240 --> 02:27:41.240]  кто?
[02:27:41.240 --> 02:27:43.240]  Не знаю.
[02:27:43.240 --> 02:27:45.240]  Почему мы говорили, что мы взяли последний элемент,
[02:27:45.240 --> 02:27:47.240]  хоть мы берем front?
[02:27:47.240 --> 02:27:49.240]  Типа
[02:27:49.240 --> 02:27:51.240]  previous
[02:27:51.240 --> 02:27:53.240]  draw там
[02:27:53.240 --> 02:27:55.240]  от previous
[02:27:57.240 --> 02:27:59.240]  до item.
[02:27:59.240 --> 02:28:01.240]  Вот, ну понятно, да?
[02:28:01.240 --> 02:28:03.240]  Вот так.
[02:28:05.240 --> 02:28:07.240]  Ну,
[02:28:07.240 --> 02:28:09.240]  это гипотетическая
[02:28:09.240 --> 02:28:11.240]  функция, которая достает линию. Помните, мы
[02:28:11.240 --> 02:28:13.240]  хотели нарисовать полигон.
[02:28:13.240 --> 02:28:15.240]  Draw line.
[02:28:15.240 --> 02:28:17.240]  Вот.
[02:28:17.240 --> 02:28:19.240]  Сейчас, drop 1 он сначала
[02:28:19.240 --> 02:28:21.240]  дропает, да?
[02:28:21.240 --> 02:28:23.240]  Да, да.
[02:28:23.240 --> 02:28:25.240]  Он на самом деле просто указатель смещает.
[02:28:25.240 --> 02:28:27.240]  Да. Итератор.
[02:28:27.240 --> 02:28:29.240]  Вот. У drop есть его
[02:28:29.240 --> 02:28:31.240]  двойник take.
[02:28:31.240 --> 02:28:33.240]  Он, наоборот, берет n первых.
[02:28:33.240 --> 02:28:35.240]  Типа, если вам нужно взять
[02:28:35.240 --> 02:28:37.240]  n первых элементов, вы берете range,
[02:28:37.240 --> 02:28:39.240]  палка take и проходите
[02:28:39.240 --> 02:28:41.240]  вот так. Плюс в том, что вообще не нужно
[02:28:41.240 --> 02:28:43.240]  думать про индексы.
[02:28:43.240 --> 02:28:45.240]  Take, take, а что он сделает?
[02:28:45.240 --> 02:28:47.240]  Он возьмет только первый элемент.
[02:28:47.240 --> 02:28:49.240]  Первый элемент, то есть мы пройдемся только по первому элементу?
[02:28:49.240 --> 02:28:51.240]  Да.
[02:28:51.240 --> 02:28:53.240]  А если мы делаем drop, он у нас
[02:28:53.240 --> 02:28:55.240]  первый элемент выбирает?
[02:28:55.240 --> 02:28:57.240]  Да. А, все остальные оставляет, мы по ним проходим?
[02:28:57.240 --> 02:28:59.240]  Да.
[02:28:59.240 --> 02:29:01.240]  А мы можем это комбинировать?
[02:29:01.240 --> 02:29:03.240]  Да, мы можем сделать вот так.
[02:29:03.240 --> 02:29:05.240]  И это будет ничего.
[02:29:07.240 --> 02:29:09.240]  Ай, фиги, это классно.
[02:29:09.240 --> 02:29:11.240]  Нет, эта штука
[02:29:11.240 --> 02:29:13.240]  выдаст ноль элементов.
[02:29:13.240 --> 02:29:15.240]  Да, если мы делали
[02:29:15.240 --> 02:29:17.240]  текстурный рик,
[02:29:17.240 --> 02:29:19.240]  а если мы делали фообразный рик...
[02:29:19.240 --> 02:29:21.240]  Да, мы бы получили только
[02:29:21.240 --> 02:29:23.240]  второй элемент.
[02:29:25.240 --> 02:29:27.240]  Ну, соответственно, мы уже видели, что
[02:29:27.240 --> 02:29:29.240]  есть фильтр.
[02:29:29.240 --> 02:29:31.240]  Это все,
[02:29:31.240 --> 02:29:33.240]  все сюда можно комбинировать. Фильтр
[02:29:33.240 --> 02:29:35.240]  от какой-то лямбды.
[02:29:37.240 --> 02:29:39.240]  Смотри.
[02:29:39.240 --> 02:29:41.240]  Оно
[02:29:41.240 --> 02:29:43.240]  генерирует другой код.
[02:29:43.240 --> 02:29:45.240]  В смысле, ассемблер другой.
[02:29:45.240 --> 02:29:47.240]  Замедляет
[02:29:47.240 --> 02:29:49.240]  ли оно? Кажется, что
[02:29:49.240 --> 02:29:51.240]  не особо.
[02:29:51.240 --> 02:29:53.240]  Возможно,
[02:29:53.240 --> 02:29:55.240]  даже нет. Нужно смотреть на
[02:29:55.240 --> 02:29:57.240]  каждом конкретном компиляторе, в каждом конкретном
[02:29:57.240 --> 02:29:59.240]  случае. Но, идейно, вообще
[02:29:59.240 --> 02:30:01.240]  замедление не особо должно быть.
[02:30:05.240 --> 02:30:07.240]  Ну, возможно.
[02:30:07.240 --> 02:30:09.240]  Только лучше. Вот. Что
[02:30:09.240 --> 02:30:11.240]  еще можно делать?
[02:30:11.240 --> 02:30:13.240]  Ну, можно делать
[02:30:13.240 --> 02:30:15.240]  правда, с 23
[02:30:15.240 --> 02:30:17.240]  плюсов, к сожалению.
[02:30:17.240 --> 02:30:19.240]  Уже 23.
[02:30:19.240 --> 02:30:21.240]  Зип.
[02:30:21.240 --> 02:30:23.240]  Точно там, точно там.
[02:30:23.240 --> 02:30:25.240]  Вы туда передаете несколько рейнджей,
[02:30:25.240 --> 02:30:27.240]  и он выдает вам пару.
[02:30:27.240 --> 02:30:29.240]  Мап 23 добавит?
[02:30:29.240 --> 02:30:31.240]  SDMap существует давно.
[02:30:33.240 --> 02:30:35.240]  Смотрите.
[02:30:35.240 --> 02:30:37.240]  Да, вот у нас есть points.
[02:30:37.240 --> 02:30:39.240]  И, не знаю, points еще раз. Мы получим
[02:30:39.240 --> 02:30:41.240]  пары points сейчас.
[02:30:41.240 --> 02:30:43.240]  Не очень интеллектуально.
[02:30:43.240 --> 02:30:45.240]  Дальше input stream.
[02:30:45.240 --> 02:30:47.240]  Что мы можем сделать еще? Еще, на самом деле.
[02:30:47.240 --> 02:30:49.240]  Вот. У нас есть
[02:30:49.240 --> 02:30:51.240]  например,
[02:30:51.240 --> 02:30:53.240]  iota view.
[02:30:55.240 --> 02:30:57.240]  Понимаете ли вы, куда я клоню?
[02:30:57.240 --> 02:30:59.240]  iota view?
[02:30:59.240 --> 02:31:01.240]  Да.
[02:31:01.240 --> 02:31:03.240]  Прикол.
[02:31:03.240 --> 02:31:05.240]  Кажется, мы сделали numrate.
[02:31:05.240 --> 02:31:07.240]  Это линиевый
[02:31:07.240 --> 02:31:09.240]  датчик.
[02:31:09.240 --> 02:31:11.240]  У нас points.
[02:31:11.240 --> 02:31:13.240]  У нас остается view
[02:31:13.240 --> 02:31:15.240]  из двух элементов.
[02:31:15.240 --> 02:31:17.240]  Кажется, действительно,
[02:31:17.240 --> 02:31:19.240]  points мы зря передаем куда-то.
[02:31:19.240 --> 02:31:21.240]  Почему?
[02:31:21.240 --> 02:31:23.240]  Почему?
[02:31:23.240 --> 02:31:25.240]  Что-нибудь так.
[02:31:25.240 --> 02:31:27.240]  А?
[02:31:27.240 --> 02:31:29.240]  Зачем мы
[02:31:29.240 --> 02:31:31.240]  пайпаем еще points?
[02:31:31.240 --> 02:31:33.240]  Что-то странное происходит.
[02:31:33.240 --> 02:31:35.240]  Да-да, вот так.
[02:31:39.240 --> 02:31:41.240]  Там есть std
[02:31:41.240 --> 02:31:43.240]  ranges-генератор, так что не надо.
[02:31:43.240 --> 02:31:45.240]  Zip что возвращает?
[02:31:45.240 --> 02:31:47.240]  Zip возвращает какой-то
[02:31:47.240 --> 02:31:49.240]  view.
[02:31:49.240 --> 02:31:51.240]  Там std ranges-view
[02:31:51.240 --> 02:31:53.240]  zip-view от вот этого
[02:31:53.240 --> 02:31:55.240]  всего.
[02:31:55.240 --> 02:31:57.240]  Не пара, это объект какой-то zip-то.
[02:31:57.240 --> 02:31:59.240]  Он будет выдавать тюфлы?
[02:31:59.240 --> 02:32:01.240]  Он будет выдавать тюфлы, да.
[02:32:01.240 --> 02:32:03.240]  Вот.
[02:32:03.240 --> 02:32:05.240]  Что еще есть классного и полезного,
[02:32:05.240 --> 02:32:07.240]  что немаловажно.
[02:32:07.240 --> 02:32:09.240]  Значит, можно делать
[02:32:11.240 --> 02:32:13.240]  следующие.
[02:32:17.240 --> 02:32:19.240]  Points
[02:32:19.240 --> 02:32:21.240]  палка
[02:32:21.240 --> 02:32:23.240]  views
[02:32:23.240 --> 02:32:25.240]  reverse.
[02:32:25.240 --> 02:32:27.240]  И пройтись в обратном порядке.
[02:32:31.240 --> 02:32:33.240]  Ушли времена, когда нам
[02:32:33.240 --> 02:32:35.240]  нужны
[02:32:35.240 --> 02:32:37.240]  хаки с IST.
[02:32:41.240 --> 02:32:43.240]  Так.
[02:32:43.240 --> 02:32:45.240]  Так же можно?
[02:32:45.240 --> 02:32:47.240]  Можно, можно.
[02:32:47.240 --> 02:32:49.240]  Решил проверить, да?
[02:32:49.240 --> 02:32:51.240]  Вот. На самом деле
[02:32:51.240 --> 02:32:53.240]  важный момент.
[02:32:53.240 --> 02:32:55.240]  Что?
[02:32:55.240 --> 02:32:57.240]  А что?
[02:32:57.240 --> 02:32:59.240]  А что не так?
[02:32:59.240 --> 02:33:01.240]  Сейчас
[02:33:01.240 --> 02:33:03.240]  мимо идеи вы должны делать
[02:33:03.240 --> 02:33:05.240]  типа условий минус-минус-н.
[02:33:05.240 --> 02:33:07.240]  Так.
[02:33:07.240 --> 02:33:09.240]  View может
[02:33:09.240 --> 02:33:11.240]  вообще range может
[02:33:11.240 --> 02:33:13.240]  Он может быть
[02:33:13.240 --> 02:33:15.240]  бесконечной и правой.
[02:33:15.240 --> 02:33:17.240]  Когда, видимо, у тебя просто
[02:33:17.240 --> 02:33:19.240]  Смотри. Скорее всего, у тебя
[02:33:19.240 --> 02:33:21.240]  требования на этот
[02:33:21.240 --> 02:33:23.240]  тебе... Давай, давай
[02:33:23.240 --> 02:33:25.240]  попробуем, давай попробуем
[02:33:25.240 --> 02:33:27.240]  сделать view с
[02:33:27.240 --> 02:33:29.240]  и это ноль.
[02:33:29.240 --> 02:33:31.240]  Вот это, мне кажется, не скомпилируется.
[02:33:31.240 --> 02:33:33.240]  Скомпилировалось.
[02:33:45.240 --> 02:33:47.240]  Ну отсюда и до обеда, видимо.
[02:33:47.240 --> 02:33:49.240]  Segmentation fault.
[02:33:51.240 --> 02:33:53.240]  То есть он постарался, он
[02:33:53.240 --> 02:33:55.240]  пытался.
[02:33:55.240 --> 02:33:57.240]  В начале перед созданием
[02:33:57.240 --> 02:33:59.240]  реверса
[02:33:59.240 --> 02:34:01.240]  находится до конца.
[02:34:01.240 --> 02:34:03.240]  Теперь, как на настоящем питоне, у нас
[02:34:03.240 --> 02:34:05.240]  нету CE, у нас только ANTAN.
[02:34:05.240 --> 02:34:07.240]  Опять Segmentation fault. Сейчас, стоп, а на что
[02:34:07.240 --> 02:34:09.240]  на Segmentation fault?
[02:34:09.240 --> 02:34:11.240]  Как бы питон имеет
[02:34:11.240 --> 02:34:13.240]  свои последствия.
[02:34:13.240 --> 02:34:15.240]  Неагонизм.
[02:34:15.240 --> 02:34:17.240]  Нет, нет.
[02:34:17.240 --> 02:34:19.240]  Лучше, чем UB.
[02:34:19.240 --> 02:34:21.240]  Нет.
[02:34:21.240 --> 02:34:23.240]  Да.
[02:34:23.240 --> 02:34:25.240]  Сейчас у нас points
[02:34:25.240 --> 02:34:27.240]  не пустим.
[02:34:27.240 --> 02:34:29.240]  Все еще UB.
[02:34:33.240 --> 02:34:35.240]  Так, давайте
[02:34:35.240 --> 02:34:37.240]  посмотрим.
[02:34:37.240 --> 02:34:39.240]  Сейчас.
[02:34:41.240 --> 02:34:43.240]  Так, давайте посмотрим,
[02:34:43.240 --> 02:34:45.240]  что не так. 44-я строка.
[02:34:47.240 --> 02:34:49.240]  А, ну потому что points
[02:34:49.240 --> 02:34:51.240]  front нет, все нормально.
[02:34:53.240 --> 02:34:55.240]  Вот.
[02:35:01.240 --> 02:35:03.240]  На реверс?
[02:35:03.240 --> 02:35:05.240]  А давайте. Я, кстати, я, честно говоря,
[02:35:05.240 --> 02:35:07.240]  удивлен, что это скомпилировалось. Я буду честен.
[02:35:07.240 --> 02:35:09.240]  Мне очень
[02:35:09.240 --> 02:35:11.240]  интересно, что произойдет.
[02:35:17.240 --> 02:35:19.240]  А, ну, видимо, может я не сохранил
[02:35:19.240 --> 02:35:21.240]  тогда случайно.
[02:35:21.240 --> 02:35:23.240]  Нет, все-таки оно не скомпилировалось.
[02:35:25.240 --> 02:35:27.240]  Давайте поймем, почему
[02:35:27.240 --> 02:35:29.240]  оно не скомпилировалось. Смотрите, он говорит, нет
[02:35:29.240 --> 02:35:31.240]  оператора. Почему нет оператора?
[02:35:43.240 --> 02:35:45.240]  Что еще раз?
[02:35:45.240 --> 02:35:47.240]  Если мы сделаем вот так,
[02:35:47.240 --> 02:35:49.240]  возможно, это скомпилируется.
[02:35:55.240 --> 02:35:57.240]  А, да,
[02:35:57.240 --> 02:35:59.240]  ой, да, вы правы.
[02:35:59.240 --> 02:36:01.240]  Я опечатался.
[02:36:05.240 --> 02:36:07.240]  Ну, заработать оно не должно, конечно.
[02:36:09.240 --> 02:36:11.240]  Ну, и он завис.
[02:36:11.240 --> 02:36:13.240]  Хоба, а вот так работает?
[02:36:15.240 --> 02:36:17.240]  Это мы, да.
[02:36:21.240 --> 02:36:23.240]  Не-не.
[02:36:23.240 --> 02:36:25.240]  Ну, он не смог найти конец.
[02:36:25.240 --> 02:36:27.240]  Что возможно?
[02:36:31.240 --> 02:36:33.240]  Ну, я думаю, что
[02:36:33.240 --> 02:36:35.240]  он не смог найти конец.
[02:36:35.240 --> 02:36:37.240]  Ну, я думаю, что
[02:36:37.240 --> 02:36:39.240]  он не смог найти конец.
[02:36:39.240 --> 02:36:41.240]  Нет, потому что оно
[02:36:41.240 --> 02:36:43.240]  под собой ничего не хранит.
[02:36:47.240 --> 02:36:49.240]  Ну, что тебе нужно? Тебе нужно получить
[02:36:49.240 --> 02:36:51.240]  итератор на конец и идти
[02:36:51.240 --> 02:36:53.240]  типа до итератора до начала.
[02:36:53.240 --> 02:36:55.240]  Ну, примерно. Идейно это.
[02:36:59.240 --> 02:37:01.240]  Сейчас.
[02:37:05.240 --> 02:37:07.240]  Сейчас. А давайте
[02:37:07.240 --> 02:37:09.240]  я покажу вам, на самом деле,
[02:37:09.240 --> 02:37:11.240]  в чем вообще мощнейшая
[02:37:11.240 --> 02:37:13.240]  сила этих штук, потому что вот их
[02:37:13.240 --> 02:37:15.240]  можно бесконечно
[02:37:17.240 --> 02:37:19.240]  бесконечно
[02:37:19.240 --> 02:37:21.240]  навешивать друг на друга.
[02:37:21.240 --> 02:37:23.240]  А...
[02:37:23.240 --> 02:37:25.240]  А, давайте
[02:37:25.240 --> 02:37:27.240]  поставим, короче, иота ноль.
[02:37:27.240 --> 02:37:29.240]  Поставим проверку на то, что
[02:37:29.240 --> 02:37:31.240]  является квадратом и спечатаем все
[02:37:31.240 --> 02:37:33.240]  квадраты натуральных штук.
[02:37:35.240 --> 02:37:37.240]  Красивый фильтр, конечно.
[02:37:45.240 --> 02:37:47.240]  Что еще раз?
[02:37:51.240 --> 02:37:53.240]  Да.
[02:37:59.240 --> 02:38:01.240]  И скажем,
[02:38:01.240 --> 02:38:03.240]  я не знаю,
[02:38:03.240 --> 02:38:05.240]  от всего
[02:38:05.240 --> 02:38:07.240]  от этого, например,
[02:38:07.240 --> 02:38:09.240]  views drop
[02:38:09.240 --> 02:38:11.240]  2. Вот так.
[02:38:13.240 --> 02:38:15.240]  Чтобы
[02:38:15.240 --> 02:38:17.240]  поставить ноль
[02:38:17.240 --> 02:38:19.240]  и без реверса, чтобы он искал последний
[02:38:19.240 --> 02:38:20.240]  просто бесконечно
[02:38:20.240 --> 02:38:22.240]  мечаток. Сейчас, что не так?
[02:38:22.240 --> 02:38:24.240]  Ну, типа без ноль запятай 10.
[02:38:24.240 --> 02:38:26.240]  Он же сможет бесконечно
[02:38:26.240 --> 02:38:28.240]  мечаток. Да.
[02:38:28.240 --> 02:38:30.240]  Теперь точно кетон.
[02:38:30.240 --> 02:38:32.240]  Может генератор. Ну, это генератор.
[02:38:32.240 --> 02:38:34.240]  Вот, удобно.
[02:38:34.240 --> 02:38:36.240]  Вот, удобно. Нашел
[02:38:36.240 --> 02:38:38.240]  красотельное кровь.
[02:38:38.240 --> 02:38:40.240]  Квадрат отрицательный, да.
[02:38:40.240 --> 02:38:42.240]  Ну и ты.
[02:38:42.240 --> 02:38:44.240]  Вот. А что еще можно делать?
[02:38:44.240 --> 02:38:46.240]  А знаете, как еще его можно ограничить?
[02:38:46.240 --> 02:38:48.240]  Вот так. Действительно. Take 20,
[02:38:48.240 --> 02:38:50.240]  например, написать, и тогда он
[02:38:50.240 --> 02:38:52.240]  возьмет из этой бесконечной последовательности
[02:38:52.240 --> 02:38:54.240]  только 20 первых.
[02:38:54.240 --> 02:38:56.240]  Ну,
[02:38:56.240 --> 02:38:58.240]  пропустив, конечно же, первые 2,
[02:38:58.240 --> 02:39:00.240]  потому что там drop 2 написано.
[02:39:00.240 --> 02:39:02.240]  Вот.
[02:39:02.240 --> 02:39:04.240]  Take 20 он берет 20 первых
[02:39:04.240 --> 02:39:06.240]  и drop, то есть он берет
[02:39:06.240 --> 02:39:08.240]  на полной интервале,
[02:39:08.240 --> 02:39:10.240]  на интервале от 2 до 20.
[02:39:10.240 --> 02:39:12.240]  Не-не-не-не. Возначало drop,
[02:39:12.240 --> 02:39:14.240]  а потом take.
[02:39:14.240 --> 02:39:16.240]  То есть там ровно
[02:39:16.240 --> 02:39:18.240]  10. Да.
[02:39:18.240 --> 02:39:20.240]  Мы как написали, он после сделал.
[02:39:20.240 --> 02:39:22.240]  У нас
[02:39:22.240 --> 02:39:24.240]  4,41 квадрат.
[02:39:24.240 --> 02:39:26.240]  Так.
[02:39:26.240 --> 02:39:28.240]  Так.
[02:39:28.240 --> 02:39:30.240]  Давайте вот,
[02:39:30.240 --> 02:39:32.240]  что сделаем.
[02:39:32.240 --> 02:39:34.240]  Есть еще пара фичей, которые я вам
[02:39:34.240 --> 02:39:36.240]  хочу показать классных.
[02:39:36.240 --> 02:39:38.240]  Это все вещи.
[02:39:38.240 --> 02:39:40.240]  Вот это, мне кажется, то, ради чего стоит
[02:39:40.240 --> 02:39:42.240]  жить.
[02:39:42.240 --> 02:39:44.240]  Это прекрасно.
[02:39:44.240 --> 02:39:46.240]  И теперь нам не нужны эти руны на алгоритмов.
[02:39:46.240 --> 02:39:48.240]  Не нужен copy if. Мы можем отфильтровать,
[02:39:48.240 --> 02:39:50.240]  а потом скопировать.
[02:39:50.240 --> 02:39:52.240]  Да.
[02:39:52.240 --> 02:39:54.240]  Да. Видишь? Плюсы.
[02:39:56.240 --> 02:39:58.240]  Так.
[02:39:58.240 --> 02:40:00.240]  Да.
[02:40:04.240 --> 02:40:06.240]  Как
[02:40:06.240 --> 02:40:08.240]  он работает внутри?
[02:40:10.240 --> 02:40:12.240]  Не уверен.
[02:40:12.240 --> 02:40:14.240]  Мне, честно говоря,
[02:40:14.240 --> 02:40:16.240]  вот что,
[02:40:16.240 --> 02:40:18.240]  вот что важно сказать.
[02:40:18.240 --> 02:40:20.240]  Помните, я вот здесь,
[02:40:20.240 --> 02:40:22.240]  какое-то время назад
[02:40:22.240 --> 02:40:24.240]  сказали, что с сортом что-то не так.
[02:40:24.240 --> 02:40:26.240]  С сортом что-то не так. Кто-то скажет мне
[02:40:26.240 --> 02:40:28.240]  теперь, когда мы примерно это все
[02:40:28.240 --> 02:40:30.240]  пощупали, потрогали, что не так
[02:40:30.240 --> 02:40:32.240]  с сортом было.
[02:40:32.240 --> 02:40:34.240]  Он RNG.
[02:40:34.240 --> 02:40:36.240]  Вот у нас есть этот фильтр,
[02:40:36.240 --> 02:40:38.240]  и мы хотим посортить.
[02:40:38.240 --> 02:40:40.240]  Кажется, он ничего не изменится.
[02:40:40.240 --> 02:40:42.240]  Вот это не скомпилируется сейчас.
[02:40:44.240 --> 02:40:46.240]  Потому что фильтр ничего не меняет.
[02:40:48.240 --> 02:40:50.240]  Да, у фильтра не random access
[02:40:50.240 --> 02:40:52.240]  итератор.
[02:40:52.240 --> 02:40:54.240]  Ну, что логично вообще-то.
[02:40:54.240 --> 02:40:56.240]  Вам нужно каждый элемент по очереди.
[02:40:56.240 --> 02:40:58.240]  Вы не можете прыгнуть за от единицы.
[02:40:58.240 --> 02:41:00.240]  Вам нужно за от отходить.
[02:41:00.240 --> 02:41:02.240]  Вот эта штука поменяла
[02:41:02.240 --> 02:41:04.240]  в процессе преобразования категорию итератора.
[02:41:04.240 --> 02:41:06.240]  Больше мы не можем сортить.
[02:41:06.240 --> 02:41:08.240]  Окей, но какие-то простые штуки,
[02:41:08.240 --> 02:41:10.240]  типа дропа,
[02:41:10.240 --> 02:41:12.240]  у них
[02:41:12.240 --> 02:41:14.240]  категория итератора сохраняется.
[02:41:14.240 --> 02:41:16.240]  Реверс, который стандартный,
[02:41:16.240 --> 02:41:18.240]  реверс.
[02:41:18.240 --> 02:41:20.240]  Типа реверс, не который view с реверсом, который
[02:41:20.240 --> 02:41:22.240]  реверс, нормальный реверс.
[02:41:22.240 --> 02:41:24.240]  Что, какой реверс, что?
[02:41:24.240 --> 02:41:26.240]  Мы можем от реверса что-то поменять?
[02:41:26.240 --> 02:41:28.240]  В смысле, мы можем ли вызвать стандартные
[02:41:28.240 --> 02:41:30.240]  алгоритмы на view?
[02:41:30.240 --> 02:41:32.240]  Да, до тех пор, пока
[02:41:32.240 --> 02:41:34.240]  у них одинаковый тип
[02:41:34.240 --> 02:41:36.240]  итераторов. На самом деле, всегда
[02:41:36.240 --> 02:41:38.240]  можем. Если у вас у view разные типы
[02:41:38.240 --> 02:41:40.240]  итераторов, вы можете сделать...
[02:41:40.240 --> 02:41:42.240]  А как мы вообще view должны передавать
[02:41:42.240 --> 02:41:44.240]  в стандартной алгоритме?
[02:41:44.240 --> 02:41:46.240]  Вызывать у них .begin и .end.
[02:41:46.240 --> 02:41:48.240]  А какая типовая итератора?
[02:41:48.240 --> 02:41:50.240]  Какая типовая итератора у view?
[02:41:50.240 --> 02:41:52.240]  У какого смотря?
[02:41:52.240 --> 02:41:54.240]  У фильтров, forward, не, хотя
[02:41:54.240 --> 02:41:56.240]  bidirectional, наверное.
[02:41:56.240 --> 02:41:58.240]  Они все правят итераторы, да?
[02:41:58.240 --> 02:42:00.240]  Ну, они делают свои итераторы поверх
[02:42:00.240 --> 02:42:02.240]  того, что было раньше.
[02:42:02.240 --> 02:42:04.240]  Скорее всего...
[02:42:04.240 --> 02:42:06.240]  Матрешка такая.
[02:42:06.240 --> 02:42:08.240]  Скорее всего, это bidirectional.
[02:42:08.240 --> 02:42:10.240]  Ну да, они повышать не могут явно.
[02:42:10.240 --> 02:42:12.240]  Скорее всего, это bidirectional.
[02:42:12.240 --> 02:42:14.240]  Скорее всего, да.
[02:42:14.240 --> 02:42:16.240]  Не, ну почему только, например, теоретически
[02:42:16.240 --> 02:42:18.240]  может повысить?
[02:42:18.240 --> 02:42:20.240]  Нет.
[02:42:20.240 --> 02:42:22.240]  Да.
[02:42:22.240 --> 02:42:24.240]  Сначала дропнули,
[02:42:24.240 --> 02:42:26.240]  потом взяли.
[02:42:26.240 --> 02:42:28.240]  Ну и что?
[02:42:28.240 --> 02:42:30.240]  Конечно, не является...
[02:42:30.240 --> 02:42:32.240]  Что тут важно сказать?
[02:42:32.240 --> 02:42:34.240]  Если у вас по какой-то причине,
[02:42:34.240 --> 02:42:36.240]  у вас какой-то legacy или еще что-то
[02:42:36.240 --> 02:42:38.240]  нужно передать view
[02:42:38.240 --> 02:42:40.240]  в стандартный алгоритм,
[02:42:40.240 --> 02:42:42.240]  вы можете сделать
[02:42:42.240 --> 02:42:44.240]  std ranges
[02:42:44.240 --> 02:42:46.240]  common view
[02:42:46.240 --> 02:42:48.240]  от вашей штуки.
[02:42:48.240 --> 02:42:50.240]  И она сделает так, чтобы у вас...
[02:42:50.240 --> 02:42:52.240]  Эта штука будет такая же,
[02:42:52.240 --> 02:42:54.240]  как была раньше, но тип
[02:42:54.240 --> 02:42:56.240]  итераторов будет один и тот же.
[02:42:56.240 --> 02:42:58.240]  Она...
[02:42:58.240 --> 02:43:00.240]  Нет.
[02:43:00.240 --> 02:43:02.240]  Ну потому что само-само-бейс
[02:43:02.240 --> 02:43:04.240]  тоже может быть другой итератор.
[02:43:04.240 --> 02:43:06.240]  Она, как бы, нет проблем, которые
[02:43:06.240 --> 02:43:08.240]  нельзя решить дополнительным уровнем абстракции.
[02:43:08.240 --> 02:43:10.240]  Мы добавили уровень абстракции
[02:43:10.240 --> 02:43:12.240]  и сделали новый тип
[02:43:12.240 --> 02:43:14.240]  итератора, который
[02:43:14.240 --> 02:43:16.240]  хранит внутри старый этот,
[02:43:16.240 --> 02:43:18.240]  и они между собой сравниваются.
[02:43:18.240 --> 02:43:20.240]  Вот. Что, кстати говоря,
[02:43:20.240 --> 02:43:22.240]  интересная деталька.
[02:43:22.240 --> 02:43:24.240]  Понял.
[02:43:24.240 --> 02:43:26.240]  Common view это понижать может быть.
[02:43:26.240 --> 02:43:28.240]  Сейчас. Смотри.
[02:43:28.240 --> 02:43:30.240]  Давай посмотрим. Вот есть common view.
[02:43:32.240 --> 02:43:34.240]  Common view берет какой-то view.
[02:43:34.240 --> 02:43:36.240]  Вот у него
[02:43:36.240 --> 02:43:38.240]  конструктор.
[02:43:40.240 --> 02:43:42.240]  Ладно, давайте...
[02:43:42.240 --> 02:43:44.240]  Тут есть пример использования.
[02:43:44.240 --> 02:43:46.240]  Это C++20, да?
[02:43:46.240 --> 02:43:48.240]  C++20, да.
[02:43:48.240 --> 02:43:50.240]  Смотрите.
[02:43:50.240 --> 02:43:52.240]  Вот у нас есть R
[02:43:52.240 --> 02:43:54.240]  какой-то.
[02:43:54.240 --> 02:43:56.240]  Какой-то view.
[02:43:56.240 --> 02:43:58.240]  И здесь, видите, это subrange
[02:43:58.240 --> 02:44:00.240]  из итератора и default sentinel.
[02:44:00.240 --> 02:44:02.240]  Default sentinel это специальная штука
[02:44:02.240 --> 02:44:04.240]  как раз для таких итераторов,
[02:44:04.240 --> 02:44:06.240]  про которые мы говорили, у которых...
[02:44:08.240 --> 02:44:10.240]  Которые мы по дефолтам конструктуры
[02:44:10.240 --> 02:44:12.240]  делали и сказали, это конец.
[02:44:12.240 --> 02:44:14.240]  Вот у них... Можно для них использовать
[02:44:14.240 --> 02:44:16.240]  default sentinel.
[02:44:16.240 --> 02:44:18.240]  Для новых.
[02:44:20.240 --> 02:44:22.240]  Так вот.
[02:44:24.240 --> 02:44:26.240]  Вот мы делаем ranges
[02:44:26.240 --> 02:44:28.240]  common view от range,
[02:44:28.240 --> 02:44:30.240]  у которого разные типы итераторов.
[02:44:30.240 --> 02:44:32.240]  Разный тип у итератора и
[02:44:32.240 --> 02:44:34.240]  у конца. Конец называется sentinel.
[02:44:34.240 --> 02:44:36.240]  И теперь
[02:44:36.240 --> 02:44:38.240]  мы можем вызывать std accumulate
[02:44:38.240 --> 02:44:40.240]  от него. Видите?
[02:44:40.240 --> 02:44:42.240]  А, мы begin and end
[02:44:42.240 --> 02:44:44.240]  одинаковыми. Да, все, что он делает,
[02:44:44.240 --> 02:44:46.240]  все, что он делает, делает
[02:44:46.240 --> 02:44:48.240]  begin and end одинаковыми.
[02:44:48.240 --> 02:44:50.240]  Вот зачем это может понадобиться.
[02:44:50.240 --> 02:44:52.240]  Смотрите.
[02:44:52.240 --> 02:44:54.240]  Как можно... Значит, лайфхак
[02:44:54.240 --> 02:44:56.240]  небольшой, это не то, что ключевая тема,
[02:44:56.240 --> 02:44:58.240]  но небольшой лайфхак. Как можно
[02:44:58.240 --> 02:45:00.240]  выиграть немножко перфа примерно в два раза,
[02:45:00.240 --> 02:45:02.240]  используя std ranges
[02:45:02.240 --> 02:45:04.240]  в некоторых ситуациях. Смотрите.
[02:45:04.240 --> 02:45:06.240]  Представим, что у нас есть vector and off.
[02:45:06.240 --> 02:45:08.240]  Как говорится, мне на день рождения
[02:45:08.240 --> 02:45:10.240]  подарили vector and off.
[02:45:10.240 --> 02:45:12.240]  Сегодня такое было.
[02:45:12.240 --> 02:45:14.240]  Сегодня точности.
[02:45:14.240 --> 02:45:16.240]  Настя Пысак.
[02:45:16.240 --> 02:45:18.240]  Нет, у меня...
[02:45:18.240 --> 02:45:20.240]  На прошлый день рождения.
[02:45:20.240 --> 02:45:22.240]  Я его берем для вас.
[02:45:22.240 --> 02:45:24.240]  Вот, смотрите, у нас есть такая
[02:45:24.240 --> 02:45:26.240]  штука. И мы
[02:45:26.240 --> 02:45:28.240]  хотим найти в ней число 6.
[02:45:28.240 --> 02:45:30.240]  Вот, хотим найти итератор
[02:45:30.240 --> 02:45:32.240]  на число 6. Окей?
[02:45:32.240 --> 02:45:34.240]  Как мы обычно это делаем?
[02:45:34.240 --> 02:45:36.240]  std find
[02:45:36.240 --> 02:45:38.240]  от int begin.
[02:45:38.240 --> 02:45:40.240]  Ну, понятно.
[02:45:40.240 --> 02:45:42.240]  Как будет работать
[02:45:42.240 --> 02:45:44.240]  std find от этой штуки?
[02:45:44.240 --> 02:45:46.240]  Он будет каждый раз
[02:45:46.240 --> 02:45:48.240]  проверять, нашли
[02:45:48.240 --> 02:45:50.240]  ли мы вещь и дошли ли мы
[02:45:50.240 --> 02:45:52.240]  до конца.
[02:45:52.240 --> 02:45:54.240]  Правильно? Две проверки
[02:45:54.240 --> 02:45:56.240]  и, типа,
[02:45:56.240 --> 02:45:58.240]  все. Return.
[02:45:58.240 --> 02:46:00.240]  Просто.
[02:46:00.240 --> 02:46:02.240]  Смотрите, сейчас вспоминаем,
[02:46:02.240 --> 02:46:04.240]  как работает find.
[02:46:04.240 --> 02:46:06.240]  Ну, ладно, мне подсказали,
[02:46:06.240 --> 02:46:08.240]  что нужно 3 найти. Давайте искать 3.
[02:46:08.240 --> 02:46:10.240]  Мы хотим найти 3. Как внутри устроен
[02:46:10.240 --> 02:46:12.240]  find? Он говорит следующее.
[02:46:12.240 --> 02:46:14.240]  Текущий итератор. Это еще не end?
[02:46:14.240 --> 02:46:16.240]  Окей. Если
[02:46:16.240 --> 02:46:18.240]  не end, то текущий итератор.
[02:46:18.240 --> 02:46:20.240]  По нему лежит то, что мы ищем.
[02:46:20.240 --> 02:46:22.240]  Да, возвращаю. Нет. Идем дальше.
[02:46:22.240 --> 02:46:24.240]  Правильно?
[02:46:24.240 --> 02:46:26.240]  На каждую итерацию две проверки.
[02:46:26.240 --> 02:46:28.240]  Но мы-то с вами знаем, что 3 тут есть.
[02:46:28.240 --> 02:46:30.240]  Поэтому мы можем
[02:46:30.240 --> 02:46:32.240]  вот сюда написать вместо end
[02:46:34.240 --> 02:46:36.240]  std
[02:46:36.240 --> 02:46:38.240]  unreachable
[02:46:38.240 --> 02:46:40.240]  sentinel.
[02:46:42.240 --> 02:46:44.240]  Нифига
[02:46:44.240 --> 02:46:46.240]  он умный.
[02:46:48.240 --> 02:46:50.240]  Опять у тебя английский язык
[02:46:50.240 --> 02:46:52.240]  вместо end.
[02:46:52.240 --> 02:46:54.240]  У нас не будет сравняться с концом.
[02:46:54.240 --> 02:46:56.240]  Это
[02:46:56.240 --> 02:46:58.240]  sentinel, который
[02:46:58.240 --> 02:47:00.240]  у которого, значит, все, что есть,
[02:47:00.240 --> 02:47:02.240]  это оператор равно-равно, и он всегда
[02:47:02.240 --> 02:47:04.240]  возвращает false.
[02:47:04.240 --> 02:47:06.240]  У меня
[02:47:06.240 --> 02:47:08.240]  end.
[02:47:08.240 --> 02:47:10.240]  Опять
[02:47:10.240 --> 02:47:12.240]  не тот wave space.
[02:47:12.240 --> 02:47:14.240]  И смотрите, что это значит.
[02:47:14.240 --> 02:47:16.240]  Компилятор видит, что у вас функция
[02:47:16.240 --> 02:47:18.240]  тупо, всегда, безусловно,
[02:47:18.240 --> 02:47:20.240]  возвращает false. Он ее
[02:47:20.240 --> 02:47:22.240]  выхинит из кода.
[02:47:22.240 --> 02:47:24.240]  Вы когда-то проверяете, что вход
[02:47:24.240 --> 02:47:26.240]  миллиметра, он только
[02:47:26.240 --> 02:47:28.240]  возвращает false.
[02:47:28.240 --> 02:47:30.240]  Не-не-не, смотри.
[02:47:30.240 --> 02:47:32.240]  Он на этапе компиляции видит, что эта штука
[02:47:32.240 --> 02:47:34.240]  не может вернуть не false.
[02:47:34.240 --> 02:47:36.240]  Он говорит, это бесполезная проверка.
[02:47:36.240 --> 02:47:38.240]  Я ее уберу.
[02:47:38.240 --> 02:47:40.240]  Замерил, если что,
[02:47:40.240 --> 02:47:42.240]  прямо на Compiler Explorer
[02:47:42.240 --> 02:47:44.240]  дает ускорение.
[02:47:44.240 --> 02:47:46.240]  102
[02:47:46.240 --> 02:47:48.240]  104
[02:47:48.240 --> 02:47:50.240]  Еще одна фишка, не плюс-плюс 23.
[02:47:56.240 --> 02:47:58.240]  Вот такой прикол.
[02:48:00.240 --> 02:48:02.240]  А, я вызвал RNGFind.
[02:48:04.240 --> 02:48:06.240]  Он умеет, ну,
[02:48:08.240 --> 02:48:10.240]  вот.
[02:48:12.240 --> 02:48:14.240]  Это я сказал,
[02:48:14.240 --> 02:48:16.240]  это я сказал, и
[02:48:16.240 --> 02:48:18.240]  так, а сколько у меня времени осталось?
[02:48:18.240 --> 02:48:20.240]  Минус две минуты.
[02:48:24.240 --> 02:48:26.240]  8 минут, окей.
[02:48:26.240 --> 02:48:28.240]  Смотрите, есть
[02:48:28.240 --> 02:48:30.240]  важная вещь.
[02:48:30.240 --> 02:48:32.240]  Мы начали
[02:48:32.240 --> 02:48:34.240]  специально пару
[02:48:34.240 --> 02:48:36.240]  не пораньше, чтобы закончили...
[02:48:36.240 --> 02:48:38.240]  Нет, мы начали нашу пару чуть попозже,
[02:48:38.240 --> 02:48:40.240]  потому что когда я пришел, у вас еще была пара.
[02:48:40.240 --> 02:48:42.240]  Чуть-чуть. Но мы задержимся...
[02:48:42.240 --> 02:48:44.240]  Быстро, смотрите.
[02:48:46.240 --> 02:48:48.240]  Если мне вектор подарили
[02:48:48.240 --> 02:48:50.240]  вот таким способом.
[02:48:50.240 --> 02:48:52.240]  Понимаете ли вы
[02:48:52.240 --> 02:48:54.240]  проблему?
[02:48:54.240 --> 02:48:56.240]  Ну, во-первых,
[02:48:56.240 --> 02:48:58.240]  это скомпилируется,
[02:48:58.240 --> 02:49:00.240]  потому что вектор это range, правильно?
[02:49:06.240 --> 02:49:08.240]  Я потом скину
[02:49:08.240 --> 02:49:10.240]  лучше, с более хорошим,
[02:49:10.240 --> 02:49:12.240]  нормально пройдусь по коду и скину.
[02:49:12.240 --> 02:49:14.240]  Что возвращает Find?
[02:49:14.240 --> 02:49:16.240]  Find возвращает итератор.
[02:49:16.240 --> 02:49:18.240]  Во!
[02:49:18.240 --> 02:49:20.240]  Проблемка.
[02:49:22.240 --> 02:49:24.240]  Что будет, если я сделаю вот так?
[02:49:28.240 --> 02:49:30.240]  Убе.
[02:49:30.240 --> 02:49:32.240]  Убе.
[02:49:32.240 --> 02:49:34.240]  Компиляционеррор не хотите?
[02:49:34.240 --> 02:49:36.240]  Что?
[02:49:36.240 --> 02:49:38.240]  Он что, сильно умный что ли?
[02:49:40.240 --> 02:49:42.240]  Смотрите, оператор
[02:49:42.240 --> 02:49:44.240]  звездочка у
[02:49:44.240 --> 02:49:46.240]  std ranges-dangling
[02:49:46.240 --> 02:49:48.240]  нету.
[02:49:48.240 --> 02:49:50.240]  Смотрите, он
[02:49:50.240 --> 02:49:52.240]  понял, что мы pair value
[02:49:52.240 --> 02:49:54.240]  передали то,
[02:49:54.240 --> 02:49:56.240]  что нельзя передавать. Он понял,
[02:49:56.240 --> 02:49:58.240]  что оно протухнет и вернул нам специальный
[02:49:58.240 --> 02:50:00.240]  тип,
[02:50:00.240 --> 02:50:02.240]  который
[02:50:02.240 --> 02:50:04.240]  он ничего не умеет, он пустой.
[02:50:06.240 --> 02:50:08.240]  Типа, если мы сделаем вот так,
[02:50:08.240 --> 02:50:10.240]  это скомпилируется.
[02:50:10.240 --> 02:50:12.240]  Не правда, что
[02:50:12.240 --> 02:50:14.240]  он ничего не умеет.
[02:50:16.240 --> 02:50:18.240]  Вот, не совсем так.
[02:50:18.240 --> 02:50:20.240]  Чуть более хитро, потому что если я напишу здесь
[02:50:20.240 --> 02:50:22.240]  ну, смотрите,
[02:50:22.240 --> 02:50:24.240]  я же хочу уметь писать
[02:50:24.240 --> 02:50:26.240]  вот так.
[02:50:26.240 --> 02:50:28.240]  У меня
[02:50:28.240 --> 02:50:30.240]  в смысле, про
[02:50:30.240 --> 02:50:32.240]  что?
[02:50:32.240 --> 02:50:34.240]  Ой, не то.
[02:50:36.240 --> 02:50:38.240]  Смотрите, я с другой стороны
[02:50:40.240 --> 02:50:42.240]  хочу уметь
[02:50:42.240 --> 02:50:44.240]  писать какой-нибудь view от вектора здесь, да?
[02:50:44.240 --> 02:50:46.240]  Скажем, если я напишу здесь vw
[02:50:46.240 --> 02:50:48.240]  take 1,
[02:50:48.240 --> 02:50:50.240]  вот это должно быть
[02:50:50.240 --> 02:50:52.240]  валидно, хотя take view это объект,
[02:50:52.240 --> 02:50:54.240]  и он здесь создается.
[02:50:54.240 --> 02:50:56.240]  То есть, если написать более явно,
[02:50:56.240 --> 02:50:58.240]  ну, не знаю, давайте напишем какой-нибудь
[02:50:58.240 --> 02:51:00.240]  reverse.
[02:51:00.240 --> 02:51:02.240]  Это тоже rvalue, конечно,
[02:51:02.240 --> 02:51:04.240]  это объект, но это скомпилируется
[02:51:04.240 --> 02:51:06.240]  и не вернет нам dangling.
[02:51:16.240 --> 02:51:18.240]  Смотрите, а
[02:51:18.240 --> 02:51:20.240]  нет, не скомпилируется, почему?
[02:51:20.240 --> 02:51:22.240]  А, потому что я sort раскомментировал.
[02:51:22.240 --> 02:51:24.240]  Sort, уходи.
[02:51:24.240 --> 02:51:26.240]  Мы с тобой уже разобрались.
[02:51:28.240 --> 02:51:30.240]  Во, скомпилировалось.
[02:51:30.240 --> 02:51:32.240]  А, ну, так, ладно, я звездочку.
[02:51:32.240 --> 02:51:34.240]  Ну, короче, можно даже вот так делать.
[02:51:36.240 --> 02:51:38.240]  Point в том, что
[02:51:38.240 --> 02:51:40.240]  для некоторых типов он вернет dangling,
[02:51:40.240 --> 02:51:42.240]  а для некоторых он такой
[02:51:42.240 --> 02:51:44.240]  ага, это view, нормально.
[02:51:44.240 --> 02:51:46.240]  Если view уничтожится,
[02:51:46.240 --> 02:51:48.240]  оператор не протухнет, потому что объект
[02:51:48.240 --> 02:51:50.240]  все еще существует.
[02:51:50.240 --> 02:51:52.240]  Вот это важная
[02:51:52.240 --> 02:51:54.240]  особенность view.
[02:51:54.240 --> 02:51:56.240]  Типа
[02:51:56.240 --> 02:51:58.240]  жизнь их итераторов
[02:51:58.240 --> 02:52:00.240]  не привязана к их собственной жизни.
[02:52:00.240 --> 02:52:02.240]  Если view разрушился, итераторы могут остаться
[02:52:02.240 --> 02:52:04.240]  валидными.
[02:52:04.240 --> 02:52:06.240]  Да, да, да.
[02:52:08.240 --> 02:52:10.240]  Вся логика в итераторе.
[02:52:18.240 --> 02:52:20.240]  Что?
[02:52:20.240 --> 02:52:22.240]  Что значит не может быть наложен view?
[02:52:34.240 --> 02:52:36.240]  Вопрос. Вы уже должны примерно
[02:52:36.240 --> 02:52:38.240]  понимать, как он понимает
[02:52:40.240 --> 02:52:42.240]  в каком случае, если он получает Rvalue,
[02:52:42.240 --> 02:52:44.240]  ему возвращать dangling, а в каком
[02:52:44.240 --> 02:52:46.240]  не dangling?
[02:52:48.240 --> 02:52:50.240]  Это первое Rvalue.
[02:52:50.240 --> 02:52:52.240]  Это не первое Rvalue.
[02:52:52.240 --> 02:52:54.240]  Какой тип был у самого первого, изначального?
[02:52:54.240 --> 02:52:56.240]  Это первое Rvalue, да.
[02:52:56.240 --> 02:52:58.240]  И какой же у всех, которые на него наращиваются?
[02:52:58.240 --> 02:53:00.240]  У первого рейджа.
[02:53:00.240 --> 02:53:02.240]  Ну да, у первого рейджа.
[02:53:02.240 --> 02:53:04.240]  Вот он помнит, что в начале было?
[02:53:04.240 --> 02:53:06.240]  В начале был вектор.
[02:53:06.240 --> 02:53:08.240]  Тут тоже в начале был вектор.
[02:53:08.240 --> 02:53:10.240]  Может быть есть какая-то функция, типа
[02:53:10.240 --> 02:53:12.240]  из view, которая...
[02:53:12.240 --> 02:53:14.240]  Если вы скажете,
[02:53:14.240 --> 02:53:16.240]  что мой тип
[02:53:16.240 --> 02:53:18.240]  там...
[02:53:18.240 --> 02:53:20.240]  Я забыл точно название этой перемены,
[02:53:20.240 --> 02:53:22.240]  но вы можете переопределить, короче, переменную
[02:53:22.240 --> 02:53:24.240]  не переопределить, а специализировать.
[02:53:24.240 --> 02:53:26.240]  Говорите, мой тип
[02:53:26.240 --> 02:53:28.240]  можно передавать
[02:53:28.240 --> 02:53:30.240]  по Rvalue в алгоритмы.
[02:53:30.240 --> 02:53:32.240]  И тогда он такой, хорошо, я не верну тебе
[02:53:32.240 --> 02:53:34.240]  dangling. Если вы этого не сделаете,
[02:53:34.240 --> 02:53:36.240]  если он получает
[02:53:36.240 --> 02:53:38.240]  Rvalue, он считает, что
[02:53:38.240 --> 02:53:40.240]  вы накосячили и вернет вам
[02:53:40.240 --> 02:53:42.240]  dangling на этапе компиляции.
[02:53:42.240 --> 02:53:44.240]  Что я считаю великолепно.
[02:53:44.240 --> 02:53:46.240]  Это явно лучше, чем UB.
[02:53:46.240 --> 02:53:48.240]  Да.
[02:53:48.240 --> 02:53:50.240]  И пожалуйста, как это работает?
[02:53:50.240 --> 02:53:52.240]  Как это работает, смотри.
[02:53:52.240 --> 02:53:54.240]  Вот у нас есть find от
[02:53:56.240 --> 02:53:58.240]  std
[02:53:58.240 --> 02:54:00.240]  vector
[02:54:00.240 --> 02:54:02.240]  от vw.
[02:54:02.240 --> 02:54:04.240]  Можно вообще написать не просто std vector,
[02:54:04.240 --> 02:54:06.240]  а еще find и reverse?
[02:54:06.240 --> 02:54:08.240]  Можно.
[02:54:08.240 --> 02:54:10.240]  А, кстати,
[02:54:10.240 --> 02:54:12.240]  хороший вопрос.
[02:54:12.240 --> 02:54:14.240]  Да.
[02:54:14.240 --> 02:54:16.240]  Он, наверное,
[02:54:16.240 --> 02:54:18.240]  понимает,
[02:54:18.240 --> 02:54:20.240]  там какой-нибудь user написан
[02:54:20.240 --> 02:54:22.240]  value type
[02:54:22.240 --> 02:54:24.240]  и написано правдами, что Rvalue
[02:54:24.240 --> 02:54:26.240]  или value и так.
[02:54:26.240 --> 02:54:28.240]  Так, ну мы хотим, чтобы он сломался.
[02:54:30.240 --> 02:54:32.240]  Нет, он понял.
[02:54:32.240 --> 02:54:34.240]  Наверное, он
[02:54:34.240 --> 02:54:36.240]  просто запоминает, как это
[02:54:36.240 --> 02:54:38.240]  чем был изначальный
[02:54:38.240 --> 02:54:40.240]  плюс, с которого все началось.
[02:54:40.240 --> 02:54:42.240]  Ну...
[02:54:46.240 --> 02:54:48.240]  Да.
[02:54:48.240 --> 02:54:50.240]  Да, ему нужно вспоминать, да.
[02:54:50.240 --> 02:54:52.240]  Да.
[02:54:56.240 --> 02:54:58.240]  Это хорошее замечание.
[02:54:58.240 --> 02:55:00.240]  Вот это CE. Вот это не CE.
[02:55:04.240 --> 02:55:06.240]  Вот.
[02:55:06.240 --> 02:55:08.240]  Так, ну смотрите.
[02:55:10.240 --> 02:55:12.240]  Да.
[02:55:14.240 --> 02:55:16.240]  Так мы только что это делали.
[02:55:16.240 --> 02:55:18.240]  Ну, считай, это вот эта строчка так и есть.
[02:55:18.240 --> 02:55:20.240]  Ну, только я его по копии создаю,
[02:55:20.240 --> 02:55:22.240]  а не по 123. Давай 123.
[02:55:22.240 --> 02:55:24.240]  Вот то же самое.
[02:55:26.240 --> 02:55:28.240]  Да.
[02:55:28.240 --> 02:55:30.240]  Отскобочек? Это то же самое.
[02:55:30.240 --> 02:55:32.240]  Особенно то же самое.
[02:55:36.240 --> 02:55:38.240]  Нет, зачем здесь писать std vector,
[02:55:38.240 --> 02:55:40.240]  я хочу проверить следующий вопрос.
[02:55:40.240 --> 02:55:42.240]  Ну, смотри. Конечный объект
[02:55:42.240 --> 02:55:44.240]  это views-reverse. И его можно
[02:55:44.240 --> 02:55:46.240]  по Rvalue передавать.
[02:55:46.240 --> 02:55:48.240]  Не, ну views-reverse просто говорит, что
[02:55:48.240 --> 02:55:50.240]  можно ли его передавать, зависит от того,
[02:55:50.240 --> 02:55:52.240]  что передали ему и все.
[02:55:52.240 --> 02:55:54.240]  Да. Да.
[02:55:54.240 --> 02:55:56.240]  Ну...
[02:55:58.240 --> 02:56:00.240]  Хорошее замечание.
[02:56:08.240 --> 02:56:10.240]  Нет, нет, нет.
[02:56:10.240 --> 02:56:12.240]  Сейчас. Тут x-value, p-value
[02:56:12.240 --> 02:56:14.240]  не важно.
[02:56:14.240 --> 02:56:16.240]  Rvalue. Просто Rvalue или не Rvalue.
[02:56:16.240 --> 02:56:18.240]  Вот в чем вопрос.
[02:56:24.240 --> 02:56:26.240]  Смотри. Он получает
[02:56:26.240 --> 02:56:28.240]  тип. И тип, у него
[02:56:28.240 --> 02:56:30.240]  явно есть глобальная
[02:56:32.240 --> 02:56:34.240]  так сказать, константная переменная
[02:56:34.240 --> 02:56:36.240]  существует.
[02:56:36.240 --> 02:56:38.240]  Которая говорит, можно этот тип так
[02:56:38.240 --> 02:56:40.240]  передавать или нельзя. Если там написано
[02:56:40.240 --> 02:56:42.240]  нельзя, то он вернет дендинг.
[02:56:42.240 --> 02:56:44.240]  Если написано можно, он вернет итератор.
[02:56:44.240 --> 02:56:46.240]  View
[02:56:46.240 --> 02:56:48.240]  в зависимости
[02:56:48.240 --> 02:56:50.240]  от того, как они были сконструированы.
[02:56:52.240 --> 02:56:54.240]  Да. Да.
[02:56:54.240 --> 02:56:56.240]  Ну, определяет себе это состояние в зависимости
[02:56:56.240 --> 02:56:58.240]  от того, как... То есть, вот видишь, вот если мы
[02:56:58.240 --> 02:57:00.240]  написали вот так. Ну, давай, чтобы было
[02:57:00.240 --> 02:57:02.240]  прямо одинаково, напишем вот так.
[02:57:02.240 --> 02:57:04.240]  Здесь вот vw, палка.
[02:57:06.240 --> 02:57:08.240]  Да.
[02:57:10.240 --> 02:57:12.240]  Ну,
[02:57:12.240 --> 02:57:14.240]  да. Ну, давай добавим сюда
[02:57:14.240 --> 02:57:16.240]  да.
[02:57:16.240 --> 02:57:18.240]  views
[02:57:18.240 --> 02:57:20.240]  drop 1.
[02:57:20.240 --> 02:57:22.240]  Я утверждаю, что это все еще не должно скомпилироваться.
[02:57:22.240 --> 02:57:24.240]  Оно не скомпилировалось.
[02:57:24.240 --> 02:57:26.240]  Нет оператора у дендинг.
[02:57:26.240 --> 02:57:28.240]  Ну, дендинг типа провис итератор.
[02:57:30.240 --> 02:57:32.240]  Да, для того все еще скомпилируется.
[02:57:36.240 --> 02:57:38.240]  Вот.
[02:57:38.240 --> 02:57:40.240]  Это очень
[02:57:40.240 --> 02:57:42.240]  честно говоря, поверхностный
[02:57:42.240 --> 02:57:44.240]  обзор того, что можно делать в
[02:57:44.240 --> 02:57:46.240]  view.
[02:57:46.240 --> 02:57:48.240]  Вот.
[02:57:48.240 --> 02:57:50.240]  Это моя любимая фича 20
[02:57:50.240 --> 02:57:52.240]  плюсов.
[02:57:54.240 --> 02:57:56.240]  Но, к сожалению,
[02:57:56.240 --> 02:57:58.240]  она сильно опирается, например,
[02:57:58.240 --> 02:58:00.240]  на концепты. И
[02:58:00.240 --> 02:58:02.240]  посмотреть, как они устроены.
[02:58:02.240 --> 02:58:04.240]  Нам пока не хватает. Вот.
[02:58:04.240 --> 02:58:06.240]  Вот. 23 добавили еще больше классных
[02:58:06.240 --> 02:58:08.240]  view, например zip добавили 23.
[02:58:08.240 --> 02:58:10.240]  Вот. Там есть
[02:58:10.240 --> 02:58:12.240]  ну, тут очень много всего.
[02:58:12.240 --> 02:58:14.240]  Мы с вами не пройдем. Вот я как бы вас
[02:58:14.240 --> 02:58:16.240]  призываю открыть эту страничку.
[02:58:16.240 --> 02:58:18.240]  Она не душная.
[02:58:20.240 --> 02:58:22.240]  Вот. Что еще классного?
[02:58:22.240 --> 02:58:24.240]  Что у вас view, например, умеет
[02:58:24.240 --> 02:58:26.240]  если вы сделали какой-то view от вектора
[02:58:26.240 --> 02:58:28.240]  и это какой-то простой view,
[02:58:28.240 --> 02:58:30.240]  например, есть view all, который просто берет
[02:58:30.240 --> 02:58:32.240]  все элементы и делает из этого view.
[02:58:32.240 --> 02:58:34.240]  У вас останутся методы size,
[02:58:34.240 --> 02:58:36.240]  empty, cast bool, если вы empty
[02:58:36.240 --> 02:58:38.240]  и так далее.
[02:58:38.240 --> 02:58:40.240]  Вот.
[02:58:42.240 --> 02:58:44.240]  Заглянули на забор.
[02:58:44.240 --> 02:58:46.240]  Что еще?
[02:58:46.240 --> 02:58:48.240]  Да, вот эта штука в 23
[02:58:48.240 --> 02:58:50.240]  появилась. Вы можете потом
[02:58:50.240 --> 02:58:52.240]  навесить точка to к чему
[02:58:52.240 --> 02:58:54.240]  и написать, типа, а вот это view потом сделай вектор,
[02:58:54.240 --> 02:58:56.240]  пожалуйста, чтоб ручками не писать, создай
[02:58:56.240 --> 02:58:58.240]  новый вектор и скопируй туда этот view.
[02:58:58.240 --> 02:59:00.240]  Вот.
[02:59:02.240 --> 02:59:04.240]  Думаю, да.
[02:59:06.240 --> 02:59:08.240]  Non view range.
[02:59:08.240 --> 02:59:10.240]  Ну, это
[02:59:10.240 --> 02:59:12.240]  уже реальная штука, которая владеет,
[02:59:12.240 --> 02:59:14.240]  создает копию.
[02:59:14.240 --> 02:59:16.240]  То есть это может быть контейнер какой-то.
[02:59:16.240 --> 02:59:18.240]  Да. Ну, вот ты туда и передаешь,
[02:59:18.240 --> 02:59:20.240]  какой контейнер. Ты передаешь
[02:59:20.240 --> 02:59:22.240]  to вектор.
[02:59:22.240 --> 02:59:24.240]  Контейнер это range всегда.
[02:59:24.240 --> 02:59:26.240]  Ну, это
[02:59:26.240 --> 02:59:28.240]  нечто больше, чем range.
[02:59:28.240 --> 02:59:30.240]  Да.
[02:59:30.240 --> 02:59:32.240]  Нечто другое, да. Вот.
[02:59:34.240 --> 02:59:36.240]  Да, да. Я просто, типа, обращу внимание
[02:59:36.240 --> 02:59:38.240]  на какие-то штуки. У вас есть всякие конструкторы,
[02:59:38.240 --> 02:59:40.240]  из которых можно собирать маленькие штуки.
[02:59:40.240 --> 02:59:42.240]  Типа single.
[02:59:42.240 --> 02:59:44.240]  Вы передаете элемент. Это
[02:59:44.240 --> 02:59:46.240]  view из одного элемента. Есть
[02:59:46.240 --> 02:59:48.240]  всякие классные, типа, cycle.
[02:59:48.240 --> 02:59:50.240]  Cycle, типа, сумасшедший.
[02:59:50.240 --> 02:59:52.240]  Нет. Типа...
[02:59:54.240 --> 02:59:56.240]  Это типа, cycle. Вы передаете
[02:59:56.240 --> 02:59:58.240]  view и он по циклу будет по нему ходить бесконечно.
[03:00:00.240 --> 03:00:02.240]  Вот. Repeat – один элемент.
[03:00:02.240 --> 03:00:04.240]  Повторяя этот элемент, там, либо сколько-то раз,
[03:00:04.240 --> 03:00:06.240]  либо бесконечно. И вы можете конструировать так
[03:00:06.240 --> 03:00:08.240]  довольно...
[03:00:08.240 --> 03:00:10.240]  Да, только
[03:00:10.240 --> 03:00:12.240]  куча...
[03:00:12.240 --> 03:00:14.240]  Да. Вот. Ну, и там
[03:00:14.240 --> 03:00:16.240]  case value на мапчик можете навесить.
[03:00:16.240 --> 03:00:18.240]  Пройдите по ключам мапчика или по value мапчика.
[03:00:18.240 --> 03:00:20.240]  Спасибо за внимание.
[03:00:20.240 --> 03:00:22.240]  Я вас не буду больше задерживать.
