[00:00.000 --> 00:05.000]  Итак, наша цель сегодня разобраться с тем, что такое потоки.
[00:05.000 --> 00:10.000]  Мы весь курс говорим про потоки, собираемся говорить про потоки,
[00:10.000 --> 00:13.000]  на самом деле нет, я сказал уже, что про файберы, а не про потоки.
[00:13.000 --> 00:16.000]  Но в первом приближении, в названии курса они есть,
[00:16.000 --> 00:21.000]  в первой домашке потоки тоже есть, и вы должны их там завести в дедлог.
[00:21.000 --> 00:22.000]  Так что полезно понимать, что это.
[00:22.000 --> 00:24.000]  Вот наша цель сегодня разобраться, что такое поток,
[00:24.000 --> 00:27.000]  чтобы вы представляли это чуть лучше себе.
[00:27.000 --> 00:32.000]  Не то что какая-то магия запускается, что-то происходит, вот что именно происходит.
[00:32.000 --> 00:37.000]  Вот по-честному до конца мы разберемся с этим на четвертой лекции,
[00:37.000 --> 00:42.000]  начинающей с единицы, которая называется механика потоков, кажется, в плане.
[00:42.000 --> 00:46.000]  Вот там поговорим, не то что поговорим, мы там код посмотрим,
[00:46.000 --> 00:49.000]  который реализует потоки, и тогда уже все должно быть понятно,
[00:49.000 --> 00:51.000]  в смысле как все работает.
[00:51.000 --> 00:55.000]  Вот вы понимаете что-то, когда вы можете это написать на C++,
[00:55.000 --> 01:00.000]  а то, что не можете написать на C++, пишите на Assembler.
[01:00.000 --> 01:03.000]  Вот мы до такой степени должны с вами до лекции дойти.
[01:03.000 --> 01:08.000]  Сегодня мы хотим приблизиться к этому, то есть подготовить себя к этой лекции.
[01:08.000 --> 01:11.000]  Ну и просто представить, что мы понимаем конкретно под вычислением,
[01:11.000 --> 01:14.000]  под потоками, как мы это себе представляем.
[01:14.000 --> 01:20.000]  Это разговор про операционные системы, про архитектуру компьютера в первую очередь.
[01:20.000 --> 01:24.000]  Ну вот у вас уже был про это курс, вы что-то уже определенно знаете.
[01:24.000 --> 01:26.000]  Наверное не все, но что-то.
[01:26.000 --> 01:30.000]  И вот мы сейчас это проверим и по пути выйдем к нашей цели.
[01:33.000 --> 01:37.000]  Смотрите, есть такая вот мета-рекомендация ко всему курсу.
[01:39.000 --> 01:41.000]  Называется она xv6.
[01:41.000 --> 01:45.000]  Это учебная операционная система, которая была написана в MIT,
[01:45.000 --> 01:49.000]  и которой в MIT учат, собственно, операционные системы писать.
[01:49.000 --> 01:52.000]  Вы в первую очередь сейчас учились их использовать,
[01:52.000 --> 01:56.000]  то есть есть эсколов, можете их вызывать, можете по сети общаться,
[01:56.000 --> 01:58.000]  можете что-то еще делать.
[01:58.000 --> 02:03.000]  Вот это учебная операционная система для того, чтобы учиться писать операционные системы.
[02:03.000 --> 02:08.000]  Вам дают очень простой код на очень простом, аккуратном C,
[02:08.000 --> 02:14.000]  где все очень неэффективно, но есть все разумные компоненты операционной системы.
[02:14.000 --> 02:18.000]  А где чего-то не хватает, вы должны дописать их сами просто в домашней работе.
[02:18.000 --> 02:23.000]  Ну вот, не то чтобы я ожидал, чтобы вы будете проходить курс параллельно
[02:23.000 --> 02:26.000]  и писать код в xv6, это сложная задача.
[02:26.000 --> 02:32.000]  Но вместе с исходниками этой системы, они довольно маленькие,
[02:32.000 --> 02:35.000]  есть замечательная книжка, написанная преподавателями MIT,
[02:35.000 --> 02:38.000]  про Ассулон Коксом, который в том числе разработчик языка ГО.
[02:38.000 --> 02:40.000]  Внезапно это тот же человек.
[02:40.000 --> 02:43.000]  И вот книжка занимает всего 100 страниц довольно крупным шрифтом,
[02:43.000 --> 02:46.000]  с картинками, со схемами, с примерами кода.
[02:46.000 --> 02:50.000]  И мне кажется, что это замечательное место для того, чтобы изучать внутренность.
[02:50.000 --> 02:55.000]  После этой книжки можно даже не читать никакие другие учебные книжки,
[02:55.000 --> 02:58.000]  можно сразу идти и разбираться, как Linux устроено,
[02:58.000 --> 03:00.000]  и переходить на следующий уровень.
[03:00.000 --> 03:02.000]  А какая книжка называется?
[03:02.000 --> 03:04.000]  Можно загуглить xv6-book.
[03:04.000 --> 03:08.000]  Там будет много ревизий ПДФок, но какой-то постарше возьми.
[03:08.000 --> 03:11.000]  Там 18-е, 20-е, какие-то такие числа.
[03:11.000 --> 03:13.000]  Может быть, уже посвежее есть.
[03:13.000 --> 03:16.000]  И там фрагменты кода, комментарии, диаграммы.
[03:16.000 --> 03:18.000]  Все очень здорово, по ней можно научиться.
[03:18.000 --> 03:22.000]  Ну и там 100 страниц вы можете их прочесть за какое-то очень разумное время.
[03:24.000 --> 03:26.000]  Еще одна рекомендация вслед за этой.
[03:26.000 --> 03:29.000]  Если вы пойдете в ШАД учиться, многие пойдут,
[03:29.000 --> 03:33.000]  то в ШАД есть курс АКОС, который как раз использует xv6,
[03:33.000 --> 03:37.000]  и там вы сможете все это по-честному написать.
[03:37.000 --> 03:39.000]  Ну вот если вы знаете, что виртуальная память,
[03:39.000 --> 03:41.000]  мы сейчас вспомним, что такое механизм Copy-on-Write.
[03:41.000 --> 03:43.000]  Слышали про это?
[03:43.000 --> 03:45.000]  Ну вот там скажем, Домашка, напишите Copy-on-Write.
[03:45.000 --> 03:49.000]  Это гораздо лучше, чем читать про Copy-on-Write в учебниках,
[03:49.000 --> 03:51.000]  или на слайдах, или что-то такое.
[03:51.000 --> 03:53.000]  В конце концов, вы же инженер, да?
[03:53.000 --> 03:55.000]  Вы учитесь для того, чтобы программировать.
[03:55.000 --> 03:59.000]  Просто люди приходят разные, кто-то учится в математике, машинном обучении.
[03:59.000 --> 04:01.000]  В первую очередь, у вас специальность про программирование.
[04:01.000 --> 04:05.000]  Ну вот я ожидаю, что вы должны ожидать от себя,
[04:05.000 --> 04:08.000]  что вы знаете что-то, когда вы умеете это сделать руками.
[04:08.000 --> 04:12.000]  Так что в XF6 вам придется делать руками все,
[04:12.000 --> 04:14.000]  и в нашем курсе мы тоже все, что изучаем,
[04:14.000 --> 04:20.000]  все абстракции, сущности, все мы пишем сами.
[04:22.000 --> 04:24.000]  Ну хорошо, наша цель сегодня поговорить про исполнение,
[04:24.000 --> 04:26.000]  начать с операционных систем.
[04:26.000 --> 04:28.000]  Давайте начнем.
[04:28.000 --> 04:30.000]  В вашем понимании, для чего нужна операционная система?
[04:30.000 --> 04:33.000]  Какие задачи она решает?
[04:33.000 --> 04:38.000]  Для того, чтобы пользователю было легче делать что-то с помощью электронного устройства.
[04:38.000 --> 04:40.000]  Пользователю? Кто такой пользователь?
[04:40.000 --> 04:42.000]  Человек.
[04:42.000 --> 04:44.000]  Человек?
[04:44.000 --> 04:46.000]  Абстрактно можно представить.
[04:46.000 --> 04:50.000]  Мне кажется, что операционная система в первую очередь для разработчика.
[04:52.000 --> 04:57.000]  Вот смотри, у тебя есть компьютер, и вот в компьютере у тебя есть...
[04:57.000 --> 04:59.000]  Ну ладно, во-первых, операционная система для того,
[04:59.000 --> 05:02.000]  чтобы программа могла с нижним миром взаимодействовать.
[05:02.000 --> 05:07.000]  Ты не можешь погами на C++ с помощью ассемблянных инструкций отправлять данные в сеть.
[05:07.000 --> 05:11.000]  Тебе нужен драйвер, сетевая карточка, и нужно как-то с ним общаться.
[05:11.000 --> 05:15.000]  Для этого у тебя есть какие-то сисколы, которые ядро перехватывает
[05:15.000 --> 05:18.000]  и умеет с помощью этого драйвера с каким-то конкретным устройством работать,
[05:18.000 --> 05:21.000]  и вот ты умеешь общаться с другой машиной в дата-центре.
[05:21.000 --> 05:24.000]  Хорошо, это первая задача, общение с нижним миром.
[05:24.000 --> 05:27.000]  А вот есть вторая важная задача, это виртуализация.
[05:27.000 --> 05:29.000]  Вот у вас есть конкретный компьютер, там есть процессор,
[05:29.000 --> 05:32.000]  может быть, не слишком эффективный, с одним ядром, допустим.
[05:32.000 --> 05:35.000]  Вот он может запускать только одну программу.
[05:35.000 --> 05:37.000]  А у вас программ много, у вас мультизадачность.
[05:37.000 --> 05:41.000]  У вас открываете браузер, и там 50 вкладок, они все должны рисоваться.
[05:41.000 --> 05:46.000]  А кроме того, вы делите общий процессор.
[05:46.000 --> 05:50.000]  Кроме того, вы делите общую память, и она тоже небольшая.
[05:50.000 --> 05:53.000]  Но о каждой программе нужна своя память.
[05:53.000 --> 05:56.000]  И вот будет очень плохо, если разработчик программы будет думать о том,
[05:56.000 --> 06:00.000]  что он использует память, а ее использует еще кто-то другой.
[06:00.000 --> 06:02.000]  Но это неудобно, это, конечно, небезопасно.
[06:02.000 --> 06:04.000]  Нам нужна изоляция.
[06:04.000 --> 06:07.000]  Мы хотим, чтобы мы привыкли к тому, что мы запускаем программу,
[06:07.000 --> 06:14.000]  давайте напишем какую-то программу, с которой мы будем работать сегодня.
[06:14.000 --> 06:18.000]  Вот такая очень условная.
[06:18.000 --> 06:23.000]  Мы там создадим вектор.
[06:23.000 --> 06:29.000]  Положим туда что-нибудь, потом вызовем какую-то функцию.
[06:34.000 --> 06:40.000]  Ну а функция foo, допустим, написана здесь.
[06:40.000 --> 06:44.000]  И она тоже ничего полезного особо не делает, она вызывает функцию bar.
[06:44.000 --> 06:54.000]  Функция bar поместится сюда.
[07:04.000 --> 07:06.000]  Пусть она даже ничего не делает.
[07:06.000 --> 07:08.000]  Ну вот такая вот не слишком полезная программа.
[07:08.000 --> 07:09.000]  Какая это?
[07:09.000 --> 07:13.000]  Можем такую написать, скомплировать, надеюсь, запустить.
[07:13.000 --> 07:16.000]  Вот, эта программа запускается, и смотрите, что она ожидает.
[07:16.000 --> 07:21.000]  Во-первых, она ожидает, что ей дадут как будто бы виртуальный процессор.
[07:21.000 --> 07:25.000]  Вот вы запускаете функцию main, которая делает что-то бессмысленное,
[07:25.000 --> 07:29.000]  или она решает какую-то более полезную вам задачу.
[07:29.000 --> 07:36.000]  Но так или иначе вы не думаете о том, как эта программа пойдет на ядро, на процессор.
[07:36.000 --> 07:39.000]  Ну то есть она там попадет, начнет работать, а в какой-то момент
[07:39.000 --> 07:44.000]  операционная система может ее взять, с ядра снять и поставить на ядро другую программу, другой процесс.
[07:44.000 --> 07:47.000]  Ну программу не стоит говорить, конечно.
[07:47.000 --> 07:53.000]  Вот мы написали программу, скомплировали ее, вот она лежит на диске, мы нажимаем enter в Shelly,
[07:53.000 --> 07:56.000]  и вот запускается процесс, и вот он уже исполняется.
[07:56.000 --> 08:02.000]  Ну вот, этот процесс встал на ядро, работает, работает, работает,
[08:02.000 --> 08:06.000]  а дальше операционная система решила, что вот квант времени этого процесса истек.
[08:06.000 --> 08:10.000]  То есть нужно делиться с другими, мы с ядра этот процесс сняли, мы операционную систему планировщик
[08:10.000 --> 08:15.000]  выбрали следующий процесс, поставили его на ядро, он тоже поработал потом,
[08:15.000 --> 08:20.000]  через какое-то время мы вернулись к нашему процессу, вернули его обратно, он продолжил работать.
[08:20.000 --> 08:22.000]  Ну вот это то, что происходило на самом деле.
[08:22.000 --> 08:27.000]  Но вы же об этом не думаете, вы просто пишете main и считаете, что вы будете выполнять сверху вниз.
[08:27.000 --> 08:33.000]  Вы не наблюдаете вот этих разрывов, этих пауз, и у вас даже нет способа никакого их пронаблюдать.
[08:33.000 --> 08:37.000]  То есть вы можете по каким-то косвенным признакам догадываться, что у вас вытеснились ядра,
[08:37.000 --> 08:42.000]  но вообще говоря, для вас исполнение вот так вот непрерывно.
[08:42.000 --> 08:48.000]  Вам как будто бы дали виртуальный процессор, и вот операционная система дает каждому процессу
[08:48.000 --> 08:51.000]  виртуальный процессор, чтобы там исполняться.
[08:51.000 --> 08:58.000]  А еще этой программе полагается большая память.
[08:58.000 --> 09:02.000]  Вот она тоже виртуальная, и она так и называется, виртуальная память.
[09:02.000 --> 09:07.000]  У нас есть такой большой и непрерывный массив байт.
[09:07.000 --> 09:12.000]  Насколько большой?
[09:12.000 --> 09:14.000]  Как они кончатся?
[09:14.000 --> 09:17.000]  Ну так вот я и спрашиваю, когда он кончится.
[09:17.000 --> 09:21.000]  Сколько байт вы можете адресовать в программе?
[09:21.000 --> 09:23.000]  Это зависит от ситуации.
[09:23.000 --> 09:27.000]  Нет, не зависит от ситуации. Ну в смысле, зависит, конечно, но что значит от ситуации?
[09:27.000 --> 09:29.000]  Это не слишком строгий термин.
[09:30.000 --> 09:35.000]  Ну то есть если памяти меньше, то в этом же есть мысло абстракции,
[09:35.000 --> 09:39.000]  что абстракция, она как бы отрывает тебя от конкретных лимитов железа.
[09:39.000 --> 09:42.000]  Все разумеется, ты не сможешь себе выделить бесконечно много памяти,
[09:42.000 --> 09:45.000]  потому что физическая память 8 гигабайт, допустим,
[09:45.000 --> 09:49.000]  но ты не должен об этом беспокоиться, когда пишешь программу.
[09:49.000 --> 09:55.000]  Давайте подумаем, вот память массив байт, вы можете эти байты адресовать.
[09:55.000 --> 09:59.000]  У вас в программе бывают указатели.
[09:59.000 --> 10:02.000]  Ну вот сколько бит в этих указателях?
[10:02.000 --> 10:05.000]  Вы заводите переменную, у вас односвязанный список,
[10:05.000 --> 10:09.000]  в структуре листа находится нод-звездочка,
[10:09.000 --> 10:13.000]  поинтер на очередной узел.
[10:13.000 --> 10:19.000]  Видимо, вы можете адресовать столько памяти, сколько у вас бит в этом поинтере, в этом указателе.
[10:19.000 --> 10:22.000]  Ну то есть в конечном итоге мы зависим от процессора,
[10:22.000 --> 10:26.000]  какими машинами слаймы он оперирует, какова их разрядность.
[10:26.000 --> 10:30.000]  Вот какова разрядность современного процессора?
[10:30.000 --> 10:32.000]  64-битные.
[10:32.000 --> 10:35.000]  Значит, у нас бывают 64-битные указатели.
[10:35.000 --> 10:40.000]  Видимо, мы можем адресовать вот столько памяти.
[10:40.000 --> 10:42.000]  Довольно много.
[10:42.000 --> 10:44.000]  Какие-то экзобайты.
[10:44.000 --> 10:46.000]  У нас, конечно, столько нет.
[10:46.000 --> 10:49.000]  У нас все еще какие-то единицы гигабайт,
[10:49.000 --> 10:54.000]  на каком-нибудь домашнем ноутбуке, но адресовать мы можем столько же.
[10:54.000 --> 10:58.000]  Разумеется, мы не можем всю эту виртуальную память заполнить.
[10:58.000 --> 11:03.000]  Мы не можем ее заполнить, потому что у нас столько физической памяти нет.
[11:03.000 --> 11:06.000]  Поэтому мы можем заполнить только ее часть.
[11:06.000 --> 11:11.000]  И какой-то механизм появляется для того, чтобы это уметь делать.
[11:11.000 --> 11:15.000]  То есть мы можем пользоваться памятью, но при этом мы не можем заполнить всю-всю.
[11:15.000 --> 11:18.000]  Вот как операционная система с ней справляется?
[11:18.000 --> 11:22.000]  Надо управлять виртуальную, физическую.
[11:22.000 --> 11:24.000]  Вот. А как это происходит?
[11:24.000 --> 11:27.000]  Какой механизм там используется?
[11:27.000 --> 11:35.000]  У нас есть виртуальная память и есть физическая память.
[11:35.000 --> 11:38.000]  И она довольно маленькая.
[11:38.000 --> 11:43.000]  По крайней мере гораздо-гораздо меньше, чем эта виртуальная.
[11:43.000 --> 11:48.000]  В каком масштабе происходит отображение? На каком уровне?
[11:48.000 --> 11:53.000]  Гранулярность это отображение.
[11:53.000 --> 11:57.000]  Мы говорим для каждого байтика, какому байтику физическая память соответствует?
[11:57.000 --> 12:02.000]  Вот это называется paging, страница.
[12:02.000 --> 12:10.000]  Вот мы делим виртуальную память на блоке размера.
[12:11.000 --> 12:14.000]  Обычно 4 096.
[12:14.000 --> 12:18.000]  Да. 4 килобайта.
[12:18.000 --> 12:20.000]  Но в системе можно это изменить?
[12:20.000 --> 12:24.000]  Это можно изменить, но вот такой стан...
[12:24.000 --> 12:26.000]  Это не так, ну в смысле...
[12:26.000 --> 12:29.000]  Это не настолько гибкая настройка, все-таки она...
[12:29.000 --> 12:32.000]  Думаю, у Виктора Вадимовича говорят, что там легко.
[12:32.000 --> 12:35.000]  Просто пара команд это сделать.
[12:35.000 --> 12:37.000]  При размене нового места.
[12:37.000 --> 12:40.000]  В общем, дефолт такой.
[12:40.000 --> 12:43.000]  Давай сейчас его придерживаться, потому что я пытаюсь объяснить,
[12:43.000 --> 12:48.000]  где он окажется дальше, где он будет использоваться.
[12:48.000 --> 12:50.000]  Ну вот страница.
[12:50.000 --> 12:54.000]  И мы делим виртуальные адреса на такие вот страницы.
[12:54.000 --> 12:57.000]  И физическую память мы делим на такие страницы.
[12:57.000 --> 13:02.000]  И, разумеется, мы не рассчитываем, что каждая виртуальная страница
[13:02.000 --> 13:04.000]  соответствует физическую.
[13:04.000 --> 13:06.000]  Каким-то соответствует, каким-то нет.
[13:06.000 --> 13:08.000]  У нас есть эта страница.
[13:08.000 --> 13:11.000]  Она в физической памяти находится здесь.
[13:15.000 --> 13:17.000]  Есть и эта виртуальная страница.
[13:19.000 --> 13:23.000]  Она находится пусть вот здесь.
[13:26.000 --> 13:28.000]  Штриховка в другую сторону получилась.
[13:30.000 --> 13:33.000]  Разумеется, непрерывность тут никакая не нужна.
[13:33.000 --> 13:35.000]  Здесь страницы могут идти подряд.
[13:35.000 --> 13:37.000]  Они могут идти далеко друг от друга.
[13:37.000 --> 13:40.000]  Ну и бухер вектора может разорвать его на две части,
[13:40.000 --> 13:42.000]  если он границу пересекает.
[13:42.000 --> 13:44.000]  В этом ничего страшного нет.
[13:44.000 --> 13:47.000]  А теперь мы пишем программу.
[13:50.000 --> 13:54.000]  И в ней мы написали вот такой код.
[13:56.000 --> 13:59.000]  Мы хотим интервироваться по односвязанному списку.
[13:59.000 --> 14:01.000]  Говорим, но стрелочка next.
[14:02.000 --> 14:07.000]  Это означает, что процессор исполняет инструкции.
[14:07.000 --> 14:09.000]  Тут написано какое-то move, видимо.
[14:09.000 --> 14:13.000]  И процессор должен взять вот этот pointer на узел
[14:13.000 --> 14:18.000]  и по этому указателю прочесть какие-то байты из памяти с каким-то offset.
[14:18.000 --> 14:20.000]  У этого поля есть offset внутри класса.
[14:20.000 --> 14:22.000]  Вот нужно взять указатель, прибавить к нему этот offset
[14:22.000 --> 14:25.000]  и прочесть из памяти значения.
[14:25.000 --> 14:27.000]  Этим должен заниматься процессор.
[14:27.000 --> 14:29.000]  Так вот, откуда же процессор знает,
[14:29.000 --> 14:33.000]  как виртуальные страницы соответствуют физическим?
[14:33.000 --> 14:37.000]  Очевидно, это соответствие поддерживается операционной системой.
[14:37.000 --> 14:40.000]  Процессор не будет ходить к операционной системе
[14:40.000 --> 14:42.000]  каждый раз что-то сложное спрашивать.
[14:42.000 --> 14:44.000]  Ему нужно прямо сейчас узнать,
[14:44.000 --> 14:47.000]  как транслировать виртуальный адрес физически.
[14:47.000 --> 14:49.000]  И вот виртуальный адрес у нас занимает...
[14:49.000 --> 14:52.000]  Мы выяснили, что 64 бита.
[14:54.000 --> 14:58.000]  Вот смотрите, 64 бита.
[14:58.000 --> 15:00.000]  Что если адрес как число,
[15:00.000 --> 15:04.000]  вот как индекс в этом гигантском массиве байт,
[15:04.000 --> 15:09.000]  что если взять остаток отделения этого числа на 4096?
[15:09.000 --> 15:11.000]  Какой вот его смысл?
[15:13.000 --> 15:17.000]  Ну да, мы получим отступ от начала страницы.
[15:18.000 --> 15:22.000]  Вот если мы поделим на 4096, мы получим индекс страницы.
[15:22.000 --> 15:25.000]  Вот нулевая страница, первая, вторая, третья.
[15:25.000 --> 15:28.000]  Остаток отделения, то есть младший 12 бит,
[15:28.000 --> 15:31.000]  ну потому что вот 2 в 12,
[15:31.000 --> 15:35.000]  младший 12 бит этого указателя,
[15:35.000 --> 15:38.000]  это просто отступ внутри страницы.
[15:38.000 --> 15:40.000]  Вот его транслировать не нужно.
[15:40.000 --> 15:42.000]  Он сохраняется.
[15:42.000 --> 15:44.000]  Нам нужно как-то взять номер страницы,
[15:44.000 --> 15:46.000]  вот эти старшие биты,
[15:46.000 --> 15:49.000]  и транслировать их в номер физической страницы.
[15:49.000 --> 15:51.000]  Вот операционная система нам должна,
[15:51.000 --> 15:55.000]  нам, процессору, должна подготовить какую-то структуру данных,
[15:55.000 --> 15:58.000]  которые можно использовать для отображения.
[15:58.000 --> 16:02.000]  Ну вот как вы храните отображение обычно?
[16:02.000 --> 16:05.000]  Сомневаюсь, вы, наверное, СТД-мэп пишете,
[16:05.000 --> 16:08.000]  или СТД Нордэдмэп?
[16:08.000 --> 16:10.000]  Вот.
[16:10.000 --> 16:13.000]  Нет никакой надежды сделать то же самое здесь,
[16:13.000 --> 16:16.000]  потому что здесь вот это отображение строит операционная система,
[16:16.000 --> 16:18.000]  ходит по нему процессор,
[16:18.000 --> 16:21.000]  и логика процессора выложена просто вот на нем.
[16:21.000 --> 16:23.000]  Это не какой-то код.
[16:23.000 --> 16:25.000]  Это вот то, что прямо в процессоре на схеме выложено.
[16:25.000 --> 16:27.000]  Поэтому логика должна быть какая-то простая,
[16:27.000 --> 16:30.000]  и вот там не может быть, наверное,
[16:30.000 --> 16:32.000]  не стоит писать какие-то бесконечные циклы,
[16:32.000 --> 16:35.000]  в смысле не бесконечные какие-то циклы с непредсказуемыми переходами.
[16:35.000 --> 16:38.000]  Должно быть все очень понятно, быть очень просто.
[16:38.000 --> 16:41.000]  Поэтому вот мы сейчас должны выяснить,
[16:41.000 --> 16:44.000]  каким же именно образом это отображение поддерживается.
[16:44.000 --> 16:46.000]  Но перед тем, как мы это сделаем,
[16:46.000 --> 16:47.000]  заменим следующее.
[16:47.000 --> 16:51.000]  А где это отображение вообще будет храниться?
[16:51.000 --> 16:53.000]  Вот какая-то структура данных должна быть,
[16:53.000 --> 16:56.000]  в которой указано, как вот одни большие числа
[16:56.000 --> 16:58.000]  отображаются в другие большие числа,
[16:58.000 --> 17:01.000]  одни там виртуальные адреса физические.
[17:01.000 --> 17:04.000]  Вот где это будет храниться?
[17:04.000 --> 17:06.000]  Какой-нибудь кэша процессор?
[17:06.000 --> 17:12.000]  Нет, в кэше у нас все постоянно куда-то девается.
[17:12.000 --> 17:14.000]  Мы пока про кэши не говорили,
[17:14.000 --> 17:15.000]  но это можно любым момент потерять,
[17:15.000 --> 17:16.000]  поэтому его смысл.
[17:16.000 --> 17:19.000]  Поэтому мы там хранить, конечно, ничего не можем.
[17:19.000 --> 17:21.000]  В смысле только там хранить не можем.
[17:21.000 --> 17:23.000]  Это не является основным местом хранения.
[17:23.000 --> 17:27.000]  Вот где же нам хранить отображение?
[17:27.000 --> 17:29.000]  У нас есть память, ничего другого у нас нет.
[17:29.000 --> 17:30.000]  Причем вот это отображение typicallyி Executoq,
[17:30.000 --> 17:31.000]  из виртуальных адресов физически,
[17:31.000 --> 17:34.000]  оно же будет для каждого процесса свое,
[17:34.000 --> 17:37.000]  потому что у нас есть один виртуальный адрес,
[17:37.000 --> 17:38.000]  но вот эта одна виртуальная страница,
[17:38.000 --> 17:41.000]  может в одном процессе отображаться в одно физическое,
[17:41.000 --> 17:43.000]  в другом процессе — в другую физическую.
[17:43.000 --> 17:48.000]  этого можно ожидать. Иногда бывает так, что страница общая,
[17:48.000 --> 17:52.000]  например, потому что там лежит общая библиотека. В этом у вас есть Lipsy,
[17:52.000 --> 17:56.000]  зачем Lipsy дублировать физическую память? Она одна общая и просто на нее все
[17:56.000 --> 18:00.000]  ссылаются. В общем случае, страницы разные, таблицы страниц разные,
[18:00.000 --> 18:04.000]  поэтому для каждого процесса своей структуры данных у нас ничего нет,
[18:04.000 --> 18:09.000]  кроме памяти. Ну, в смысле, кроме вот этой памяти физической.
[18:09.000 --> 18:14.000]  А эта физическая память, она разделена на страницы. И вот мы скажем,
[18:14.000 --> 18:20.000]  что среди этих страниц есть страницы, которые хранят данные ваших программ,
[18:20.000 --> 18:25.000]  ваших процессов, а есть страницы, которые хранят, скажем, методанные,
[18:25.000 --> 18:28.000]  то есть служебные данные, которые нужны операционной системе для того,
[18:28.000 --> 18:31.000]  чтобы ваши программы работали. Так что вот мы здесь будем использовать
[18:31.000 --> 18:36.000]  физические страницы. И вот ровно поэтому я написал, что 4096.
[18:36.000 --> 18:43.000]  Смотрите, как именно организовано отображение. Это не хэштаблица,
[18:43.000 --> 18:51.000]  это не дерево сбалансированное, конечно же, это структура, которая называется,
[18:51.000 --> 18:54.000]  я не знаю, как вы ее называете, я могу тремя способами называть,
[18:54.000 --> 19:01.000]  try, bore, прихистное дерево. Что вам ближе? Бор. В чем идея, напомню?
[19:01.000 --> 19:06.000]  У нас есть... Мы храним отображение из строчек куда-то. Как мы это делаем?
[19:06.000 --> 19:13.000]  Вот если у нас строчка ABC есть, мы храним... Мы строим вот такой вот деревце,
[19:13.000 --> 19:17.000]  такую веточку. Если мы туда добавляем в эту структуру строчку ABD,
[19:17.000 --> 19:21.000]  то мы вот здесь префикс разделяем и добавляем еще один лист.
[19:21.000 --> 19:25.000]  Если мы добавляем строчку AD, то у нас появляется вот такой вот лист.
[19:25.000 --> 19:30.000]  И вот эта структура кодирует нам 4 пути от корня до листа,
[19:30.000 --> 19:32.000]  то есть 4 строчки.
[19:36.000 --> 19:38.000]  Он не сжатый.
[19:41.000 --> 19:44.000]  Нет, конечно же, это было бы убийственно, но не эффективно.
[19:44.000 --> 19:48.000]  Сейчас давай постепенно. Мы собираемся хранить отображение
[19:48.000 --> 19:54.000]  из виртуальных адресов физически в виде такого вот bore, да, я забыл?
[19:54.000 --> 19:57.000]  В виде такого bore. Но правда алхалит у нас будет немножко побольше.
[19:57.000 --> 20:04.000]  Здесь он 26, а у нас мощность алхавита будет 2 в 9.
[20:06.000 --> 20:11.000]  То есть мы рассматриваем вот эту часть адреса как строчку
[20:11.000 --> 20:15.000]  с довольно толстыми символами. Вот он берен...
[20:17.000 --> 20:25.000]  Давайте чуть покомпактнее. 9 бит, 9 бит, 9 бит, 9 бит.
[20:27.000 --> 20:34.000]  И вот это символы нашей строчки, которую мы собираемся искать в этом bore.
[20:34.000 --> 20:40.000]  Почему 9 бит? Почему мы берем вот такие блоки в нашем адресе?
[20:40.000 --> 20:43.000]  Понятно это или нет? Непонятно.
[20:43.000 --> 20:48.000]  Ну смотрите, вот мы собираемся спускаться по этому bore.
[20:48.000 --> 20:52.000]  У нас теперь в каждом узле побольше развилок становится.
[20:52.000 --> 20:57.000]  Здесь их 26 максимально, а сейчас у нас сколько развилок может быть?
[21:02.000 --> 21:05.000]  Почему в смысле 2 в 9? Мне же это интересно.
[21:05.000 --> 21:10.000]  Вот у нас каждый узел будет представлен в виде отдельной страницы.
[21:10.000 --> 21:16.000]  Вот у нас есть корень bore, это страница памяти размером 4096.
[21:17.000 --> 21:23.000]  А что такое ссылка? Ну вот стрелочка.
[21:23.000 --> 21:30.000]  Это адрес другой физической страницы. Сколько он занимает? Ну 8 байт.
[21:30.000 --> 21:34.000]  У нас 4096 байт есть, да, в 12.
[21:34.000 --> 21:40.000]  И нам нужно в этом массиве уложить ссылки, стрелочки размером 8 байт.
[21:40.000 --> 21:43.000]  Сколько у нас их поместится?
[21:43.000 --> 21:45.000]  Ну 2 в 9.
[21:45.000 --> 21:49.000]  Поэтому мы и выбираем блоки по 9 бит, такой алфавит берем,
[21:49.000 --> 21:54.000]  потому что вот так мы можем насытить этот блок, эту страницу памяти.
[21:54.000 --> 21:59.000]  И что мы делаем в итоге? Мы берем, кажется, вот старшие 9 бит.
[21:59.000 --> 22:06.000]  Да, у нас еще остается сколько? 12 плюс 36, 48. Остается еще 16 бит.
[22:06.000 --> 22:10.000]  Так вот, 16 бит они не используются для адресации.
[22:10.000 --> 22:12.000]  То есть на самом деле у нас не столько памяти,
[22:12.000 --> 22:18.000]  мы можем адресовать, а 2 в 48. Чуть поменьше.
[22:18.000 --> 22:24.000]  Это можно дорастить, в смысле у нас процессор позволяет использовать больше бит для адресации,
[22:24.000 --> 22:28.000]  но пока мы используем чуть меньше, и сейчас будет видно, почему.
[22:28.000 --> 22:33.000]  Вот мы, кажется, берем сначала старшие вот эти биты.
[22:33.000 --> 22:37.000]  Получается у нас некоторое число от 0 до 2 в 9 минус 1.
[22:37.000 --> 22:42.000]  И вот мы просто используем это число как индекс в массиве,
[22:42.000 --> 22:47.000]  где каждая запись занимает 8 байт. Вот попадаем куда-то сюда.
[22:49.000 --> 22:57.000]  И здесь написана ссылка на другую страницу, где находится следующий узел нашего бора.
[22:57.000 --> 23:12.000]  Там мы берем уже синие биты и снова попадаем куда-то.
[23:12.000 --> 23:16.000]  Снова куда-то переходим.
[23:22.000 --> 23:25.000]  Тут у нас будут черные биты.
[23:28.000 --> 23:32.000]  Так, я помещаюсь даже.
[23:32.000 --> 23:41.000]  Ну и наконец мы берем последний символ этого большого алфавита.
[23:41.000 --> 23:46.000]  И он указывает нам куда.
[23:46.000 --> 23:50.000]  Вот сюда.
[23:50.000 --> 23:55.000]  Вот теперь мы наконец знаем, что нам нужно прочитать. Мы процессор.
[23:55.000 --> 24:00.000]  Правда, непонятно, как мы вообще корень нашли этого дерева.
[24:00.000 --> 24:03.000]  Откуда он?
[24:03.000 --> 24:09.000]  Ну как, что значит в определенных местах? Для каждого процесса эта таблица своя.
[24:09.000 --> 24:15.000]  Так что операционная система, когда она ставит процесс, исполняется на процессор,
[24:15.000 --> 24:20.000]  то в специальный регистр, я, честно говоря, не помню, как он называется.
[24:20.000 --> 24:23.000]  CR3, да, совершенно очевидно.
[24:23.000 --> 24:31.000]  Операционная система пишет указатель, по сути, на корневую страничку с метаданами.
[24:31.000 --> 24:35.000]  А дальше уже, когда вы пишете node next, процессор что делает?
[24:35.000 --> 24:40.000]  Он по этой ссылке идет сюда, бьет эти 9 бит, переходит глубже, глубже, глубже.
[24:40.000 --> 24:46.000]  И в итоге вместо того, чтобы просто один раз прочтить из памяти, он читает раз, два, три, четыре раза,
[24:46.000 --> 24:49.000]  и потом пятый еще наконец. Выглядит довольно безумно.
[24:49.000 --> 24:54.000]  Мы вместо одного, на месте одного логического чтения делаем пять физических чтений.
[24:54.000 --> 25:03.000]  А учитывая то, что чтение из памяти примерно в сто раз медленнее, чем операции над регистрами,
[25:03.000 --> 25:05.000]  это все выглядит очень печально.
[25:05.000 --> 25:10.000]  Поэтому в процессоре есть то, что называется TLB.
[25:10.000 --> 25:16.000]  Это кэш, это наслаждаемо касаемый buffer, то есть кэш, который просто в процессоре запоминает
[25:16.000 --> 25:21.000]  самые горячие страницы, которые чаще всего вы используете, и просто напрямую хранит отображение.
[25:21.000 --> 25:23.000]  Не читая много раз в памяти.
[25:23.000 --> 25:28.000]  Ну вот такой механизм называется page table, page directory.
[25:28.000 --> 25:33.000]  Вот вы, конечно, все это знали.
[25:33.000 --> 25:37.000]  Хорошо, мы процессор научились читать.
[25:37.000 --> 25:39.000]  Глубина этого дерева может быть...
[25:39.000 --> 25:43.000]  Нет, глубина не то, что может быть, она фиксирована, она четыре.
[25:43.000 --> 25:48.000]  То есть процессор ожидает, что он сделает четыре чтения, тогда берется до страницы нужной.
[25:48.000 --> 25:55.000]  Смысл этих 16 бит в том, что процессоры оставили себе возможность адресовать больше памяти,
[25:55.000 --> 26:00.000]  но пока делать этого не хотят, потому что текущей памяти хватает вот такой вот.
[26:00.000 --> 26:04.000]  Но если мы захотим поддержать больше, мы поддержим, добавим еще 9 бит,
[26:04.000 --> 26:08.000]  но правда замедлим трансляцию, потому что появится еще один лишний уровень.
[26:08.000 --> 26:13.000]  Вот текущим процессорам четырехуровневые таблицы страниц достаточно.
[26:13.000 --> 26:18.000]  Вот 16 бит пока свободны, но не то чтобы они произвольные, они не произвольные,
[26:18.000 --> 26:26.000]  но они такой нагрузки существенные, они не несут себе ничего полезного.
[26:26.000 --> 26:31.000]  Вот то есть если страница есть, если в отображении есть такая стрелочка,
[26:31.000 --> 26:38.000]  может быть и нет ее. Вот если есть, то ты проходишь через четыре ура.
[26:38.000 --> 26:43.000]  Ну хорошо, мы научились читать память, уже неплохо.
[26:43.000 --> 26:47.000]  Ну а теперь подумаем, что в этой памяти вообще лежит.
[26:47.000 --> 26:52.000]  Ну смотрите, процессор начал исполнять нашу программу, он движется по ее инструкциям.
[26:52.000 --> 26:56.000]  Откуда он их берет?
[26:56.000 --> 27:06.000]  Он, конечно, берет их с памяти, потому что брать их из диска было бы примерно миллион раз медленнее.
[27:06.000 --> 27:13.000]  У нас будет лекция про это, там есть смешные аналогии, не хочу их сейчас спойлерить.
[27:13.000 --> 27:17.000]  Ну в общем, это много-много порядков, но кажется примерно миллион раз.
[27:17.000 --> 27:24.000]  То есть чтение с диска это миллисекунды, чтение с памяти это сотни на секунду.
[27:24.000 --> 27:29.000]  Ну с SSD может быть чуть меньше, но все равно это...
[27:36.000 --> 27:41.000]  Ну очень много процессоров, но примерно в сто раз медленнее, чем ты работаешь с регистрами.
[27:41.000 --> 27:47.000]  Но намного быстрее, чем ты работаешь, скажем, с диском, который вращается и там вот эта рука ездит.
[27:47.000 --> 27:51.000]  В общем, мы загружаем текст программы в память, конечно, он где-то находится.
[27:51.000 --> 27:56.000]  Вот давайте его где-то здесь изобразим. Где-то здесь находится текст.
[28:00.000 --> 28:06.000]  И в процессоре, чтобы исполнять вашу программу, есть регистр, который мы называем как?
[28:11.000 --> 28:18.000]  Как мы называем его? Мы называем RIP, Instruction Pointer.
[28:18.000 --> 28:23.000]  А Instruction Pointer, который указывает на что?
[28:23.000 --> 28:27.000]  На следующую инструкцию, которую мы собираемся исполнить.
[28:27.000 --> 28:32.000]  Вот он куда-то указывает.
[28:32.000 --> 28:39.000]  Ну и если все идет как обнудно, в зависимости от того, какие инструкции процессор встречает,
[28:39.000 --> 28:44.000]  этот Instruction Pointer передвигается либо в следующей инструкции, которая следствует за текущей идет,
[28:44.000 --> 28:48.000]  либо может быть прыгнет куда-то в другое место.
[28:48.000 --> 28:55.000]  Вот что может заставить процессор перепрыгнуть в другую точку текст программы?
[28:55.000 --> 28:58.000]  Ну, например, вы написали там GoTo, не дай бог.
[28:58.000 --> 29:03.000]  Ну, кажется, вы так не делали. Умные люди давно научились не использовать GoTo и получат от этого массу выгод.
[29:03.000 --> 29:08.000]  Ну скажем, если вы не используете GoTo, то у вас получаются вызовы, образуют такую иерархию,
[29:08.000 --> 29:11.000]  поэтому у вас работает рай, и это все очень удобно.
[29:11.000 --> 29:16.000]  И это такой глубокий инсайт нам в будущее про одну из последних лекций.
[29:16.000 --> 29:20.000]  Ну, в общем, ты можешь написать GoTo все еще, никто тебя не остановит.
[29:20.000 --> 29:25.000]  И тогда в коде будет какой-то джамп по какому-то адресу, то есть такой безусловный прыжок.
[29:25.000 --> 29:32.000]  Может быть ты написал цикл или условие, вот написал и в какое-то условие,
[29:32.000 --> 29:37.000]  то код A не пишите так, это не по код стайлу LCB.
[29:37.000 --> 29:44.000]  И тогда компилятор выложит там подряд, допустим, A и B и напишет, что если условие выполнилось, то пойти дальше,
[29:44.000 --> 29:49.000]  а иначе перепрыгнуть A и исполнять B. Ну, какие-то там метки расставит, будет по ним прыгать.
[29:49.000 --> 29:53.000]  В общем, понятно, куда мы прыгаем.
[29:53.000 --> 29:59.000]  А есть, скажем, вызов функции. Вот вызов функции он чуть интереснее устроен.
[29:59.000 --> 30:07.000]  Вот если на месте GoTo мы напишем какой-нибудь джамп, или на месте if мы там напишем снова какой-то джамп условный уже,
[30:07.000 --> 30:11.000]  то есть прыгнуть если больше или прыгнуть если меньше, что-нибудь такое,
[30:11.000 --> 30:19.000]  то что компилятор напишет здесь? Какую инструкцию? Он напишет инструкцию call.
[30:23.000 --> 30:26.000]  И здесь напишет адрес, куда нужно прыгнуть.
[30:26.000 --> 30:32.000]  Ну, адрес все еще известен, хотя это уже менее очевидный нюанс, потому что, скажем, вы компилируете программу,
[30:32.000 --> 30:39.000]  и там вот функция foo вызывает функцию bar. И может быть так, что функция foo находится в одном cpp-файле,
[30:39.000 --> 30:46.000]  а функция bar находится в другом cpp-файле. В смысле, реализация функции bar находится в другом cpp-файле.
[30:46.000 --> 30:50.000]  И компиляторы, говорят, компилируют их независимо. Это называется единица трансляции.
[30:50.000 --> 30:55.000]  Компилятор берет cpp-файл, включает в него все заголовки, которые в этом заинклузере,
[30:55.000 --> 31:01.000]  и вот собирает код, собирает объектный файл. Правда, компилятору в этот момент неизвестно,
[31:01.000 --> 31:09.000]  куда же прыгать, когда мы вызываем из foo bar, потому что в текущем скопе компилятору неизвестно реализация функции bar,
[31:09.000 --> 31:15.000]  код непонятно где находится. Ну, кажется, на стадии построения объектных файлов это не страшно,
[31:15.000 --> 31:20.000]  но с этим же все не заканчивается при компиляции, что дальше происходит.
[31:20.000 --> 31:24.000]  Ну вот дальше мы связываем вот эти все объектные файлы и понимаем, куда мы собираемся прыгать.
[31:24.000 --> 31:42.000]  И в итоге, когда у нас есть текст программы, так условно, и в нем можно выделить main, bar foo,
[31:42.000 --> 31:47.000]  у нас еще bus был, да? Вот, и программа начинает исполняться.
[31:47.000 --> 31:51.000]  Там компилятор расставил эти самые call с адресами, и вот мы исполняем функцию main,
[31:51.000 --> 32:02.000]  прыгаем в вызов функции foo, она прыгает в bar, bar прыгает в bus. Все вроде понятно пока, да?
[32:02.000 --> 32:09.000]  Непонятно только, возможно, почему мы вместо инструкции jump используем инструкцию call.
[32:09.000 --> 32:14.000]  Зачем нам отдельные инструкции?
[32:14.000 --> 32:19.000]  Ну вот, да, смотрите, у нас есть проблема, когда мы доходим до конца функции bus,
[32:19.000 --> 32:24.000]  и вот в этот момент непонятно, что делать процессору, потому что он должен переместиться куда.
[32:24.000 --> 32:29.000]  Вот сюда он должен переместиться. Но в момент компиляции компилятору, конечно же,
[32:29.000 --> 32:34.000]  непонятно в какое место нужно вернуться из функции bus, потому что можно вернуться вообще,
[32:34.000 --> 32:39.000]  куда угодно. Может быть, это библиотека, и кто угодно может ей пользоваться.
[32:39.000 --> 32:46.000]  Так что статический адрес неизвестен, поэтому чтобы процессор мог вызывать функции,
[32:46.000 --> 32:51.000]  чтобы он мог вызывать эти foo, bar, bus, возвращаться из них, нужно в runtime поддерживать еще одну структуру.
[32:51.000 --> 32:56.000]  Вот у нас уже в runtime есть вот этот page table для трансляции адресов,
[32:56.000 --> 33:01.000]  а у нас есть еще одна структура, она называется...
[33:01.000 --> 33:06.000]  Увереннее говорите. Она называется call stack, stack вызов.
[33:06.000 --> 33:11.000]  И что именно делает инструкция call?
[33:11.000 --> 33:19.000]  Когда мы говорим call, мы с одной стороны прыгаем в начало той функции, которую мы собираемся вызвать,
[33:19.000 --> 33:25.000]  а еще этот stack живет где-то в памяти. Давайте нарисуем его сразу.
[33:25.000 --> 33:30.000]  Вот где-то у нас появился stack.
[33:30.000 --> 33:38.000]  И нужно добавить кое-что в процессор. Нужно добавить еще один регистр, который называется...
[33:38.000 --> 33:45.000]  Называли уже. Rsp, который указывает на вершину stack.
[33:45.000 --> 33:49.000]  Давайте нарисуем.
[33:49.000 --> 33:56.000]  Оказывает на вершину stack. И когда мы говорим call, то мы вершину stack сдвигаем вниз по адресам
[33:56.000 --> 34:00.000]  и помещаем в stack адрес возврата.
[34:00.000 --> 34:05.000]  То есть инструкцию, в которую нужно прыгнуть после того, как функция bar завершится.
[34:05.000 --> 34:10.000]  Ну и в конце теперь функции bar мы используем инструкцию call.
[34:10.000 --> 34:14.000]  Здесь мы помещаем инструкцию red, которая поступает симметрично.
[34:14.000 --> 34:22.000]  Она снимает со stack адрес возврата. Она ожидает, что к этому моменту stack pointer находится в этом месте.
[34:22.000 --> 34:30.000]  Мы снимаем со stack RIP, возвращаем его вот сюда, ну и прыгаем по этому адресу.
[34:30.000 --> 34:36.000]  То есть мы помимо того, что прыгаем, мы еще и с stack немножко манипулируем,
[34:36.000 --> 34:43.000]  восстанавливаем RIP или запоминаем RIP.
[34:43.000 --> 34:45.000]  Что?
[34:45.000 --> 34:55.000]  Что значит просто в stack?
[34:55.000 --> 34:58.000]  Сейчас я...
[34:58.000 --> 35:01.000]  Это не то, чтобы в call stack живут только RIP, разумеется.
[35:01.000 --> 35:04.000]  Но он в первую очередь для этого нужен.
[35:04.000 --> 35:08.000]  Не только, не знаю, в первую очередь, не в первую, но он называется call stack,
[35:08.000 --> 35:12.000]  потому что с помощью него можно перемещаться по вызовам.
[35:12.000 --> 35:18.000]  Но, конечно же, это еще не все, потому что, скажем, нам нужно передавать аргумент функциям иногда.
[35:18.000 --> 35:22.000]  И вот что мы делаем здесь?
[35:22.000 --> 35:29.000]  Мы вызываем функцию bar с двумя аргументами. Как мы их передаем?
[35:29.000 --> 35:33.000]  Через регистр, а не через stack. Здесь stack нам не нужен.
[35:33.000 --> 35:36.000]  Здесь мы передаем через RDI, здесь мы через RSI, не ошибаюсь.
[35:36.000 --> 35:39.000]  Вот тут правильно говорят, это называется соглашение о вызовах.
[35:39.000 --> 35:45.000]  Вот мы в процессореоперационной системе должны зафиксировать, как функции общаются друг с другом.
[35:45.000 --> 35:49.000]  Потому что, в самом деле, вы вызываете функцию, вы ожидаете, что вы...
[35:49.000 --> 35:54.000]  То есть вы, компилятор, вы вызываете функцию, вы ожидаете, что функция как-то будет разумно себя вести.
[35:54.000 --> 36:01.000]  Ну, например, представьте себе, что вы были функцией foo, и в вас был написан очень сложный код.
[36:01.000 --> 36:07.000]  И вы, компилятор, этот код скомпилировали, этот код разложил текущие данные по регистрам.
[36:07.000 --> 36:13.000]  Вот регистр в процессоре, и вот там сейчас лежат ваши текущие вычисления.
[36:13.000 --> 36:18.000]  И вот вы вызываете функцию bar, а ее компилировал кто-то отдельно вообще.
[36:18.000 --> 36:22.000]  Ну и bar, функция bar написана как-то, она что-то делает тоже с регистрами, видимо.
[36:22.000 --> 36:26.000]  И вот было бы очень печально, если бы функция foo вызвала эту функцию bar.
[36:26.000 --> 36:30.000]  Функция bar внутри переписала бы все эти регистры, вернула бы управление функцией foo,
[36:30.000 --> 36:34.000]  а функция foo, что ей делать теперь? Все данные стерли.
[36:34.000 --> 36:38.000]  Поэтому, что фиксирует соглашение о вызвах?
[36:38.000 --> 36:42.000]  Это называется calling conventions. Вы знаете, да, это?
[36:42.000 --> 36:48.000]  С одной стороны, они фиксируют, как возвращать результаты, как передавать аргументы,
[36:48.000 --> 36:56.000]  а с другой, эти соглашения делят регистры на caller saved и caller esaved.
[36:56.000 --> 37:01.000]  И вот есть набор регистров, которые функция bar, она может их перезаписать,
[37:01.000 --> 37:05.000]  но перед возвратом функции foo она должна их восстановить.
[37:05.000 --> 37:11.000]  То есть часть регистров после вызова bar останутся в том же виде, которые были перед вызовом bar.
[37:11.000 --> 37:15.000]  Остальные можно стереть. И вот компилятор, когда он компилирует функцию foo,
[37:15.000 --> 37:18.000]  он пишет код таким образом, чтобы этот код не зависел от того,
[37:18.000 --> 37:22.000]  что будет в других регистрах, кроме call esaved после вызова foo.
[37:22.000 --> 37:26.000]  Давайте вспомним call esaved регистр на всякий случай. Не то, что на всякий случай.
[37:26.000 --> 37:36.000]  Это нам потребуется. R12-15, это опять для Linux, для x86 и x4, rbx, rbpr, rsp.
[37:36.000 --> 37:40.000]  Объясните мне, почему вы помните вот это, хотя зачем это помнить?
[37:40.000 --> 37:45.000]  Это должен помнить компилятор. И не помните вот это, и не знаете вот это.
[37:45.000 --> 37:50.000]  Вы как-то неправильно распределяете свои усилия.
[37:50.000 --> 37:54.000]  Вообще, кстати, я рассказываю это для баловства на самом деле.
[37:54.000 --> 37:58.000]  Нам это прямо не нужно. Сейчас смотрите, я объясню, что имею в виду.
[37:58.000 --> 38:01.000]  Все, что я рассказываю, рассказываю с какой-то целью.
[38:01.000 --> 38:04.000]  То есть почти все, что я говорю, понадобится нам, кроме вот этого.
[38:04.000 --> 38:12.000]  Потому что, смотрите, я сейчас все объясню. На курсе конкарнсии прямо это не пригодится.
[38:12.000 --> 38:17.000]  Но я рассказываю курс конкарнсии с таким намерением хитрым, чтобы на самом деле
[38:17.000 --> 38:20.000]  найти людей, которые послужат курсом по распределенным системам.
[38:20.000 --> 38:26.000]  И все для этого на самом деле. На половину я шучу, конечно, но на другую половину это правда.
[38:26.000 --> 38:31.000]  И вот там действительно сложные вещи, и вот там мы конкарнсии пользуемся в полный рост.
[38:31.000 --> 38:35.000]  Так вот, оказывается, что если вы понимаете, как работает трансляция адресов
[38:35.000 --> 38:39.000]  в операционной системе, то внезапно вы можете, отталкиваясь от этой идеи,
[38:39.000 --> 38:43.000]  придумать, как масштабировать дизайн распределенного кивели у хранилища,
[38:43.000 --> 38:48.000]  который хранит все ваши письма. Вот система Google Bigtable, которая используется в Google
[38:48.000 --> 38:54.000]  для хранения, которая живет Gmail. Вот там ключевая идея для ее масштабирования,
[38:54.000 --> 39:01.000]  она не то чтобы напоминает, она вот однозначно соответствует этой конструкции.
[39:01.000 --> 39:05.000]  С кэшами там есть TLB, там есть этот регистр, там все это есть.
[39:05.000 --> 39:08.000]  Это, конечно, очень трудно увидеть, когда вы читаете статью.
[39:08.000 --> 39:12.000]  Но если вы подумаете, как на самом деле это выглядит и как это придумали,
[39:12.000 --> 39:16.000]  то окажется, что просто была переиспользована идея из дизайна операционных систем.
[39:16.000 --> 39:21.000]  Чем больше пользователей у Gmail, тем медленнее у каждого конкретного оно будет работать?
[39:21.000 --> 39:26.000]  Ну, разумеется. Система масштабируется.
[39:26.000 --> 39:29.000]  В смысле, она не может работать одинаково быстро и вот расти бесконечно.
[39:29.000 --> 39:32.000]  Где-то вот накапливается аверхед из-за этого.
[39:32.000 --> 39:36.000]  Ну, ты очень верно заметил. В общем, это тоже мне пригодится.
[39:36.000 --> 39:39.000]  Но в какой-то очень отдаленной перспективе, когда это вы забудете,
[39:39.000 --> 39:43.000]  а я напомню, вы такие, ага. Ну вот, а все остальное нам нужно.
[39:43.000 --> 39:46.000]  И вот скажем, зачем я говорю про соглашения о вызовах?
[39:46.000 --> 39:51.000]  Ну, вот они нам пригодятся, когда мы будем потоки переключать.
[39:51.000 --> 39:54.000]  Ну, удивительно, что это вы запомните, конечно.
[39:54.000 --> 39:57.000]  Ладно.
[39:57.000 --> 40:00.000]  Так, хорошо. Значит, до начала мы остановились.
[40:00.000 --> 40:05.000]  Мы научились вызывать функцию foo, вызывать функцию bar с аргументами.
[40:05.000 --> 40:08.000]  А теперь мы поговорим про calling convention, про stack.
[40:08.000 --> 40:10.000]  Давайте еще про stack кое-что вспомним.
[40:10.000 --> 40:14.000]  Ну, что еще у нас таки лежит, кроме аргументов иногда и вот адресов возврата?
[40:14.000 --> 40:18.000]  Вот есть вектор. Из чего он состоит?
[40:18.000 --> 40:21.000]  Причисляйте поля.
[40:21.000 --> 40:25.000]  Ну, название скорее.
[40:25.000 --> 40:30.000]  Вот есть pointer на буфер с данными, который живет, кстати, где? В хипе, да?
[40:30.000 --> 40:33.000]  У нас хипанина нарисована.
[40:33.000 --> 40:38.000]  Ну, хип.
[40:38.000 --> 40:44.000]  Есть размер вектора и есть capacity, размер буфера.
[40:44.000 --> 40:47.000]  Вот где это все лежит?
[40:47.000 --> 40:50.000]  Сайти и capacity на stack все-таки.
[40:50.000 --> 40:52.000]  А дата?
[40:52.000 --> 40:54.000]  И указатель тоже на stack.
[40:54.000 --> 40:59.000]  То есть если мы вызываем какой-нибудь main, то вот этот вектор будет где-то здесь лежать.
[40:59.000 --> 41:04.000]  Тремя своими полями.
[41:04.000 --> 41:09.000]  Ну, или есть какой-то локальный, может в регистр, я не знаю, могут его в регистр положить.
[41:09.000 --> 41:11.000]  Ну ладно.
[41:11.000 --> 41:15.000]  В общем, на stack тоже может что-то жить.
[41:15.000 --> 41:21.000]  То есть call stack не только для того, чтобы сохранить RIP, но вот все-таки это основная его задача.
[41:21.000 --> 41:27.000]  Хорошо, значит, мы научились ходить по вызову, вглубью возвращаться оттуда.
[41:27.000 --> 41:34.000]  Мы научились читать из памяти что-то. Мы умеем прыгать с помощью джампов, колов и ретов.
[41:34.000 --> 41:36.000]  Что еще осталось обсудить?
[41:36.000 --> 41:41.000]  Ну, вот куча есть.
[41:41.000 --> 41:43.000]  Мы где собираемся здесь с кучей работать?
[41:43.000 --> 41:45.000]  Видимо, когда мы вызываем pushback.
[41:45.000 --> 41:47.000]  Видимо, пустой вектор не алоцирует динамическую память.
[41:47.000 --> 41:51.000]  И когда мы говорим pushback 7, то алоцируется какой-то небольшой буфер.
[41:51.000 --> 41:55.000]  Но не из одного все-таки элемента. Из какого?
[41:55.000 --> 41:58.000]  Ну, понимаю, да. Я просто не знаю, мне любопытно.
[41:58.000 --> 42:00.000]  Я 8 писал, когда мы...
[42:00.000 --> 42:02.000]  Извините.
[42:02.000 --> 42:08.000]  Все же не про тебя спрашиваю. Я скорее про Estelle, про какую-нибудь из реализации. Не помните, да?
[42:08.000 --> 42:10.000]  Ну, не больше 10, скорее всего.
[42:10.000 --> 42:15.000]  Все же это локация динамической памяти. Вы там зовете какой-то молок.
[42:15.000 --> 42:17.000]  Вот понимаете ли вы, что делает молок?
[42:17.000 --> 42:19.000]  Да.
[42:19.000 --> 42:21.000]  Хорошо, идем дальше.
[42:21.000 --> 42:23.000]  Давайте развернем.
[42:23.000 --> 42:27.000]  О чем я говорю сейчас? О том, что у нас есть память.
[42:27.000 --> 42:30.000]  И есть единственный способ алоцировать эту память.
[42:30.000 --> 42:32.000]  В смысле, есть виртуальное адресное пространство.
[42:32.000 --> 42:34.000]  И вот есть вот эти блоки виртуальные, странички.
[42:34.000 --> 42:37.000]  И за ними может лежать клиническая память, а может не лежать.
[42:37.000 --> 42:42.000]  То есть может быть в page table этом нет записи вот для этой страницы.
[42:42.000 --> 42:44.000]  Может быть, она вот пустая.
[42:44.000 --> 42:46.000]  Вот эта, пусть.
[42:46.000 --> 42:49.000]  Может быть, там вот нет записи.
[42:49.000 --> 42:54.000]  Процессор по ней пойдет и встретит sigfold.
[42:54.000 --> 43:00.000]  Так вот, как же нам получить в процессе новую страничку памяти?
[43:00.000 --> 43:02.000]  Как ее алоцировать, собственно?
[43:02.000 --> 43:06.000]  Ну, вот мы не можем этого сами сделать, разумеется, на C++.
[43:06.000 --> 43:08.000]  Мы можем только просить операционную систему.
[43:08.000 --> 43:12.000]  Для этого у нас есть вызов системный, который называется MMAP.
[43:12.000 --> 43:15.000]  Который про memory mapping, собственно, он и занимается отображением памяти.
[43:15.000 --> 43:18.000]  Мы говорим ему, например, там есть много вариантов, что мы можем ему сказать.
[43:18.000 --> 43:26.000]  Ну, допустим, мы говорим, выдели, пожалуйста, мне, ну, не знаю, 100 страниц абы где.
[43:26.000 --> 43:29.000]  И он нам их выделяет, возвращает pointer на первую страницу.
[43:29.000 --> 43:32.000]  И мы знаем, что 100 следующих к ним можно обращаться.
[43:32.000 --> 43:37.000]  Может быть, они еще не выделены на самом деле, но там случится page fold и операционная система.
[43:37.000 --> 43:41.000]  Все-таки по мере необходимости, если заставят, выделит.
[43:41.000 --> 43:45.000]  А что делает malloc тогда?
[43:46.000 --> 43:50.000]  Ну, вот смотри, мы вызываем здесь, видимо, malloc в конце концов, да?
[43:50.000 --> 43:54.000]  И вот мы у него просим 10 умножить на size of t.
[43:54.000 --> 43:57.000]  Ну, довольно мало.
[43:57.000 --> 43:59.000]  Что он будет делать?
[43:59.000 --> 44:01.000]  Он же не будет к операционной системе ходить.
[44:01.000 --> 44:10.000]  Это же было бы безумием, если мы на каждую аллокацию ходили бы, переключались бы в ядро.
[44:10.000 --> 44:13.000]  Ну, вот аллокатор, он обычный память не аллоцирует.
[44:13.000 --> 44:17.000]  Он аллоцирует как-нибудь заранее, ну или иногда большими аренами.
[44:17.000 --> 44:19.000]  Просит через мэп много-много памяти.
[44:19.000 --> 44:21.000]  Но обычно аллокаторы делают так современные.
[44:21.000 --> 44:23.000]  Они делят все локации на классы.
[44:23.000 --> 44:25.000]  Вот до 32 бит.
[44:25.000 --> 44:28.000]  32, там, не знаю, 16, 8 байт иногда.
[44:28.000 --> 44:30.000]  16 байт, 32, 64.
[44:30.000 --> 44:33.000]  Если вы просите 51 байт, то он округляет до 64.
[44:33.000 --> 44:35.000]  И аллоцирует 64.
[44:35.000 --> 44:36.000]  Вот такие вот классы есть.
[44:36.000 --> 44:40.000]  И для каждого класса аллокатор аллоцирует арену, то есть зовет мэп,
[44:40.000 --> 44:42.000]  и просто нарезает их на равные кусочки.
[44:42.000 --> 44:45.000]  И вот когда вы просите очередной блок размера 64 байта,
[44:45.000 --> 44:50.000]  то он просто, аллокатор помнит, что вот есть такая арена для этого класса аллокаций,
[44:50.000 --> 44:55.000]  и что мы уже использовали какое-то количество этих кусочков P64.
[44:55.000 --> 44:57.000]  Возьмем следующий, отдадим на него поинтер.
[44:57.000 --> 45:02.000]  То есть просто он обращается к метаданным и понимает, какой кусочек сейчас не используется.
[45:02.000 --> 45:05.000]  И отдает поинтер на него.
[45:05.000 --> 45:06.000]  Ну вот, хорошо.
[45:06.000 --> 45:07.000]  У нас есть хип.
[45:07.000 --> 45:08.000]  У нас есть хип.
[45:08.000 --> 45:10.000]  Мы там можем выделить динамическую память.
[45:10.000 --> 45:13.000]  А стэк, чем отличается он от кучи?
[45:13.000 --> 45:16.000]  В смысле, странный вопрос, чем он отличается.
[45:16.000 --> 45:18.000]  Он для другого совсем.
[45:18.000 --> 45:21.000]  Но на каком-то уровне все это страница.
[45:21.000 --> 45:25.000]  И вот на самом деле стэк-то не сильно отличается от кучи.
[45:25.000 --> 45:27.000]  И это не какая-то особенная память.
[45:27.000 --> 45:30.000]  Если мы собираемся писать свои потоки,
[45:30.000 --> 45:32.000]  а мы собираемся писать свои потоки,
[45:32.000 --> 45:35.000]  то нам нужно выделять для них стэки.
[45:35.000 --> 45:37.000]  Потому что без стэка исполняться вообще невозможно.
[45:37.000 --> 45:39.000]  Просто ходить по коду невозможно.
[45:39.000 --> 45:41.000]  Так что нам нужно будет выделить стэк.
[45:41.000 --> 45:44.000]  Никто не помешает нам выделить стэк через malloc, скажем.
[45:44.000 --> 45:47.000]  Вот стэк это просто какой-то фрагмент памяти,
[45:47.000 --> 45:49.000]  на который в процессоре есть поинтеры,
[45:49.000 --> 45:52.000]  которые используются для того, чтобы там запоминать адреса возврата,
[45:52.000 --> 45:54.000]  иногда передавать аргументы,
[45:54.000 --> 45:58.000]  иногда хранить какие-то локальные переменные небольшие.
[46:00.000 --> 46:02.000]  Ну вот, я почти готов закончить.
[46:02.000 --> 46:04.000]  Только еще маленький кусочек.
[46:04.000 --> 46:06.000]  Про сисколы давайте вспомним.
[46:06.000 --> 46:08.000]  Но сисколы мы не будем вспоминать,
[46:08.000 --> 46:10.000]  вспомним какие-то.
[46:10.000 --> 46:12.000]  Давайте подумаем,
[46:12.000 --> 46:14.000]  какие вы знаете сисколы, которые, конечно,
[46:14.000 --> 46:16.000]  отличаются от вызовов функций обычных,
[46:16.000 --> 46:18.000]  потому что они могут быть обслужены только ядром.
[46:18.000 --> 46:21.000]  Значит, нужно перевести процессор в другой режим
[46:21.000 --> 46:24.000]  и вообще уйти с этого стэка,
[46:24.000 --> 46:27.000]  потому что его можно покарабтить для операционной системы.
[46:27.000 --> 46:29.000]  Короче, какие сисколы вы знаете,
[46:29.000 --> 46:31.000]  которые работают с планировщиком?
[46:32.000 --> 46:34.000]  Что?
[46:34.000 --> 46:36.000]  Я так и не настолько хорош.
[46:36.000 --> 46:38.000]  Еще раз поясню вопрос.
[46:38.000 --> 46:40.000]  Вот сисколы бывают разные,
[46:40.000 --> 46:42.000]  и нас интересуют только те, которые работают,
[46:42.000 --> 46:44.000]  которые касаются исполнения.
[46:44.000 --> 46:46.000]  То есть если мы говорим Bright,
[46:46.000 --> 46:48.000]  то мы работаем с сокетами, с каким-то устройством.
[46:48.000 --> 46:50.000]  Вот какие сисколы обращаются к планировщику?
[46:52.000 --> 46:54.000]  Ты с козырей начинаешь сразу.
[46:54.000 --> 46:56.000]  Давай что-нибудь попроще.
[46:56.000 --> 46:58.000]  Вот есть сискол, который знает каждый школьник.
[47:02.000 --> 47:04.000]  Который обращается к планировщику.
[47:11.000 --> 47:13.000]  Ну это какой-то специальный школьник все-таки.
[47:13.000 --> 47:15.000]  Не самый простой.
[47:15.000 --> 47:17.000]  Какой-то специально обученный.
[47:17.000 --> 47:19.000]  А вот прям чтобы каждый школьник.
[47:19.000 --> 47:22.000]  Ретроит он разве к планировщику обращается?
[47:22.000 --> 47:24.000]  Не похоже.
[47:24.000 --> 47:26.000]  То есть мы говорим,
[47:26.000 --> 47:28.000]  мы хотим что-то сделать с исполнением,
[47:28.000 --> 47:30.000]  но то, что мы сами не можем
[47:30.000 --> 47:32.000]  написать.
[47:32.000 --> 47:34.000]  Очень простой сискол.
[47:34.000 --> 47:36.000]  Но это не то, чтобы сискол
[47:36.000 --> 47:38.000]  можно назвать библиотечную функцию.
[47:46.000 --> 47:48.000]  Проще, проще.
[47:50.000 --> 47:52.000]  Ну слип, конечно.
[47:52.000 --> 47:54.000]  Вот смотрите, вы можете
[47:54.000 --> 47:56.000]  исполнять что угодно.
[47:56.000 --> 47:58.000]  Вы можете исполнять инструкцию, я ничего не делаю.
[47:58.000 --> 48:00.000]  Я просто там
[48:00.000 --> 48:02.000]  стараюсь не тратить много энергии.
[48:02.000 --> 48:04.000]  Но вы все равно исполняете инструкции.
[48:04.000 --> 48:06.000]  Но вы не можете не исполнять инструкции в коде.
[48:06.000 --> 48:08.000]  Вот вы не можете уйти с ядра сами.
[48:08.000 --> 48:10.000]  Своими инструкциями.
[48:10.000 --> 48:12.000]  Вы можете просить ядро, чтобы вас сняли.
[48:12.000 --> 48:14.000]  Ну вот слип, он позволяет вам уйти с ядра
[48:14.000 --> 48:16.000]  и
[48:16.000 --> 48:18.000]  отдать это место кому-то другому.
[48:18.000 --> 48:20.000]  Ну вот чуть посложнее вызов.
[48:20.000 --> 48:22.000]  Он называется шид-илд.
[48:22.000 --> 48:24.000]  Ну я коротко иилд напишу.
[48:24.000 --> 48:26.000]  У него семантика такая. Вы исполняете, потом говорите
[48:26.000 --> 48:28.000]  с темы, что я вообще-то готов
[48:28.000 --> 48:30.000]  уступить ядро. Если есть другие желающие,
[48:30.000 --> 48:32.000]  которым больше надо, чем мне,
[48:32.000 --> 48:34.000]  то можно нас переключить.
[48:34.000 --> 48:36.000]  Вот довольно странная ситуация,
[48:36.000 --> 48:38.000]  что мы вроде бы хотим использовать ядро,
[48:38.000 --> 48:40.000]  а потом мы отказываемся от этого сами.
[48:40.000 --> 48:42.000]  Ну вот в субботу мы увидим какой-то код простой,
[48:42.000 --> 48:44.000]  который этим будет заниматься.
[48:46.000 --> 48:48.000]  Это, конечно, еще не все, но на сегодня
[48:48.000 --> 48:50.000]  хватит, в смысле, сисколов.
[48:50.000 --> 48:52.000]  И давайте перейдем к заключению, зачем все это было.
[48:52.000 --> 48:54.000]  Что я хотел вам рассказать.
[48:56.000 --> 48:58.000]  Во-первых, я хотел вам сказать следующее,
[48:58.000 --> 49:00.000]  что вот посмотрите на эту картинку.
[49:02.000 --> 49:04.000]  Вот тут нарисовано ядро процессора,
[49:08.000 --> 49:10.000]  и оно исполняет какой-то код.
[49:12.000 --> 49:14.000]  Ну, возможно, это поток.
[49:14.000 --> 49:16.000]  Вот вы создали studio.red,
[49:16.000 --> 49:18.000]  и вот он выглядит так вот.
[49:18.000 --> 49:20.000]  У него есть какой-то свой стэк,
[49:20.000 --> 49:22.000]  он исполняет какие-то инструкции,
[49:22.000 --> 49:24.000]  но он живет в адресном пространстве
[49:24.000 --> 49:26.000]  какого-то процесса.
[49:26.000 --> 49:28.000]  Но вот само ядро на этой картинке
[49:28.000 --> 49:30.000]  оно ничего про std.red не знает,
[49:30.000 --> 49:32.000]  в смысле про thread вообще ничего не знает.
[49:32.000 --> 49:34.000]  Вот у ядра есть просто stack pointer,
[49:34.000 --> 49:36.000]  у ядра есть instruction pointer,
[49:36.000 --> 49:38.000]  у интра есть корень, таблица,
[49:38.000 --> 49:40.000]  страницы.
[49:40.000 --> 49:42.000]  И вот в данном случае
[49:42.000 --> 49:44.000]  мы эту картинку рисовали в предположении,
[49:44.000 --> 49:46.000]  что мы скомпилировали программу, запустили процесс,
[49:46.000 --> 49:48.000]  и вот операционная система сама это настроила все.
[49:50.000 --> 49:52.000]  Вот она создала единственный
[49:52.000 --> 49:54.000]  для вашей программы поток,
[49:54.000 --> 49:56.000]  который исполняет мы.
[49:56.000 --> 49:58.000]  Но мы с вами
[49:58.000 --> 50:00.000]  собираемся исполнять свои потоки.
[50:00.000 --> 50:02.000]  Так вот,
[50:02.000 --> 50:04.000]  что мы должны будем сделать, получается?
[50:04.000 --> 50:06.000]  Получается, мы сами
[50:06.000 --> 50:08.000]  должны будем установить instruction pointer,
[50:08.000 --> 50:10.000]  установить stack pointer,
[50:10.000 --> 50:12.000]  видимо, латировать stack.
[50:12.000 --> 50:14.000]  Это делать не нужно, потому что все потоки
[50:14.000 --> 50:16.000]  живут и так в адресном пространстве процесса,
[50:16.000 --> 50:18.000]  это уже все готово.
[50:18.000 --> 50:20.000]  То есть мы должны будем настроить
[50:20.000 --> 50:22.000]  процессор так, чтобы он исполнял нашу программу
[50:22.000 --> 50:24.000]  на нашем стеке.
[50:24.000 --> 50:26.000]  И вот мы тогда создадим поток.
[50:26.000 --> 50:28.000]  В смысле, о чем я говорю?
[50:28.000 --> 50:30.000]  О том, что с точки зрения процессора вообще
[50:30.000 --> 50:32.000]  нет никакой разницы между потоками, файберами,
[50:32.000 --> 50:34.000]  как бы мы это ни называли.
[50:34.000 --> 50:36.000]  Вот мы исполняем в Гога routine сейчас
[50:36.000 --> 50:38.000]  или в C++ исполняем поток.
[50:38.000 --> 50:40.000]  Да какая разница
[50:40.000 --> 50:42.000]  процессора? Вот у него есть регистр,
[50:42.000 --> 50:44.000]  он с этим всем работает.
[50:44.000 --> 50:46.000]  Кто поставил эти регистры,
[50:46.000 --> 50:48.000]  runtime языка, ваша библиотека,
[50:48.000 --> 50:50.000]  операционная система, не важно.
[50:50.000 --> 50:52.000]  На таком уровне мы говорим просто
[50:52.000 --> 50:54.000]  про исполнение.
[50:54.000 --> 50:56.000]  Откуда это исполнение взялось,
[50:56.000 --> 50:58.000]  это вопрос уже, который решается уровнем выше.
[50:58.000 --> 51:00.000]  Это нас должно обнадеживать.
[51:00.000 --> 51:02.000]  А есть одна деталь,
[51:02.000 --> 51:04.000]  которая должна нас немного сбивать с толку.
[51:04.000 --> 51:06.000]  Вот мы же
[51:06.000 --> 51:08.000]  хотим реализовать потоки
[51:08.000 --> 51:10.000]  без операционной системы.
[51:10.000 --> 51:12.000]  То есть мы хотим сделать легковесные потоки в пространстве пользователя.
[51:12.000 --> 51:14.000]  Это значит, что мы должны
[51:14.000 --> 51:16.000]  уметь делать slip и yield.
[51:16.000 --> 51:18.000]  А теперь смотрите,
[51:18.000 --> 51:20.000]  какая штука.
[51:20.000 --> 51:22.000]  Вот у нас есть
[51:22.000 --> 51:24.000]  процессор.
[51:24.000 --> 51:26.000]  Он умеет двигаться
[51:26.000 --> 51:28.000]  по коду с помощью джампов, но они нам не интересны,
[51:28.000 --> 51:30.000]  с помощью колов и ред.
[51:30.000 --> 51:32.000]  И вот когда вы пишете такой код,
[51:32.000 --> 51:34.000]  структурное программирование называется,
[51:34.000 --> 51:36.000]  у вас есть такое свойство,
[51:36.000 --> 51:38.000]  что любые два вызова они
[51:38.000 --> 51:40.000]  либо не пересекаются, либо вложены.
[51:40.000 --> 51:42.000]  Вот у вас есть вызов main,
[51:42.000 --> 51:44.000]  там вы зовете pushback, а потом зовете
[51:44.000 --> 51:46.000]  фу.
[51:46.000 --> 51:48.000]  А внутри фу вы зовете бар, а внутри бар
[51:48.000 --> 51:50.000]  вы там еще что-то зовете.
[51:50.000 --> 51:52.000]  Вот такая иерархия получается.
[51:52.000 --> 51:54.000]  Вот вы вначале вызовете кол, углубляетесь,
[51:54.000 --> 51:56.000]  потом говорите ред, возвращаетесь на уровень выше.
[51:56.000 --> 51:58.000]  А теперь посмотрите,
[51:58.000 --> 52:00.000]  что происходит, когда вы делаете yield.
[52:00.000 --> 52:02.000]  В первой домашке вы там уже работаете с файберами,
[52:02.000 --> 52:04.000]  и мы их
[52:04.000 --> 52:06.000]  собираемся написать,
[52:06.000 --> 52:08.000]  а у них тоже есть
[52:08.000 --> 52:10.000]  эта функция yield.
[52:10.000 --> 52:12.000]  И если мы запускаем, скажем, два файбера,
[52:12.000 --> 52:14.000]  сначала красный, вот он начинает исполняться.
[52:14.000 --> 52:16.000]  Исполняется, исполняется, потом говорит yield.
[52:16.000 --> 52:18.000]  Это значит, что мы
[52:18.000 --> 52:20.000]  готовы уступить, исполняя синему.
[52:20.000 --> 52:22.000]  Вот он запустился,
[52:22.000 --> 52:24.000]  и исполняется теперь, вот он.
[52:24.000 --> 52:26.000]  Потом он сказал yield,
[52:26.000 --> 52:28.000]  и продолжил исполняться
[52:28.000 --> 52:30.000]  красный. Закончил,
[52:32.000 --> 52:34.000]  наш поток виртуального ядра
[52:34.000 --> 52:36.000]  освободилась, и продолжил синий,
[52:36.000 --> 52:38.000]  и вот тоже завершился.
[52:38.000 --> 52:40.000]  И вот мы запускали в потоках
[52:40.000 --> 52:42.000]  файберах две лямды,
[52:42.000 --> 52:44.000]  две функции какие-нибудь.
[52:44.000 --> 52:46.000]  Но вот у них теперь интервалы пересекаются.
[52:46.000 --> 52:48.000]  Вот мы поломали это свойство.
[52:48.000 --> 52:50.000]  Вот мы каким-то образом
[52:50.000 --> 52:52.000]  должны научиться исполнять
[52:52.000 --> 52:54.000]  код так вот,
[52:54.000 --> 52:56.000]  переключаясь, чередуя
[52:56.000 --> 52:58.000]  внутри вызовов.
[52:58.000 --> 53:00.000]  При этом
[53:00.000 --> 53:02.000]  ничего другого, кроме
[53:02.000 --> 53:04.000]  тех инструкций, которые мы обсудили, у нас нет.
[53:04.000 --> 53:06.000]  У нас есть колы реты, и вот нам нужно
[53:06.000 --> 53:08.000]  будет как-то выкрутиться, есть у них
[53:08.000 --> 53:10.000]  такую семантику реализовать.
[53:12.000 --> 53:14.000]  То есть это не то чтобы
[53:14.000 --> 53:16.000]  препятствие, но вот это некоторые
[53:16.000 --> 53:18.000]  неочевидные моменты, которые
[53:18.000 --> 53:20.000]  нам придется обходить,
[53:20.000 --> 53:22.000]  и вот окажется, что компилятор нам здесь
[53:22.000 --> 53:24.000]  не поможет. В смысле, компилятор не умеет.
[53:24.000 --> 53:26.000]  Компилятор расставляет колы реты вот так вот.
[53:28.000 --> 53:30.000]  А мы хотим чего-то более экзотического.
[53:30.000 --> 53:32.000]  Ну вот если мы это сможем
[53:32.000 --> 53:34.000]  сделать, то вот все остальное мы тоже
[53:34.000 --> 53:36.000]  сможем сделать.
[53:38.000 --> 53:40.000]  Ну что, надеюсь, я примерно объяснил,
[53:40.000 --> 53:42.000]  что такой поток.
[53:42.000 --> 53:44.000]  Ну по крайней мере, как его видит процессор.
[53:44.000 --> 53:46.000]  Кажется, мы
[53:46.000 --> 53:48.000]  поверили, что мы сможем такое же сделать,
[53:48.000 --> 53:50.000]  без походов в ядро. Нужно вот
[53:50.000 --> 53:52.000]  может быть только вот этот момент
[53:52.000 --> 53:54.000]  придумать. Он называется
[53:54.000 --> 53:56.000]  переключением контекста, но обычно этим ядро занимается,
[53:56.000 --> 53:58.000]  там прерывание прилетает по таймеру, у нас
[53:58.000 --> 54:00.000]  вытесняет, ну а может быть мы сможем
[54:00.000 --> 54:02.000]  это сделать
[54:02.000 --> 54:04.000]  сами.
[54:04.000 --> 54:06.000]  Ну вот такая история. На сегодня
[54:06.000 --> 54:08.000]  тогда все.
[54:08.000 --> 54:10.000]  Это было повторение, надеюсь, вы все
[54:10.000 --> 54:12.000]  это знали.
[54:12.000 --> 54:14.000]  Большая часть.
[54:14.000 --> 54:16.000]  Тогда через неделю мы продолжим.
