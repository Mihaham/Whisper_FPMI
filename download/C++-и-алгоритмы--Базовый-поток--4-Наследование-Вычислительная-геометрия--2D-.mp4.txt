[00:00.000 --> 00:12.980]  Сегодня у нас новый раздел ООП, который называется наследование. Про наследование мы будем
[00:12.980 --> 00:21.520]  говорить много. В общем, это довольно объемная часть и существенная часть языка C++. Сегодня мы
[00:21.520 --> 00:33.960]  что-то из этого рассмотрим, остальное в следующих лекциях. Формально наследование это свойство,
[00:33.960 --> 00:38.560]  которое позволяет создавать новый тип данных на основе уже существующего или на основе уже
[00:38.560 --> 00:45.120]  существующих, при этом с полным или частичным взаимствованием функционала. Как вы помните,
[00:45.120 --> 00:49.840]  когда мы обсуждали ООП, мы говорили про четыре основных концепции, на которых здесь ждется ООП.
[00:49.840 --> 00:54.800]  Это абстракция, инкапсуляция, наследование, полиморфизм. Наследование — это последний
[00:54.800 --> 00:58.640]  раздел, который мы говорим. Он буквально про следующее. Если у вас есть какой-то тип,
[00:58.640 --> 01:03.440]  то есть вы написали свой класс, свою структуру данных, то вы на ее основе можете порождать
[01:03.440 --> 01:10.640]  новые, при этом заимствовать ее функционал, частично или полностью. В качестве примера можно
[01:10.640 --> 01:15.920]  привести такую. С одной стороны искусственность, с другой стороны вполне себе реальную задачу.
[01:15.920 --> 01:27.920]  Представьте, что вы проектируете какую-то компьютерную игру. У вас есть какие-то
[01:27.920 --> 01:34.560]  персонажи. Персонажи могут что-то делать, собирать какие-то ресурсы и что-то такое.
[01:34.560 --> 01:42.680]  Вам нужно создать иерархию классов. Допустим, у вас есть класс эльфы, класс гномы и так далее.
[01:45.920 --> 02:06.600]  Что еще раз? Это расы, окей. Послышалось. У каждого персонажа в компьютерной игре есть свой
[02:06.600 --> 02:11.760]  набор действий, которые они могут совершать. Некоторые общий набор действий. Например,
[02:12.240 --> 02:16.640]  у каждого персонажа есть сила, есть показатель здоровья, есть показатель опыта, который он
[02:16.640 --> 02:22.880]  получает в течение своей жизни. Естественно, по мере роста вашей программы, по мере того,
[02:22.880 --> 02:28.680]  как вы вводите новые сущности в вашу программу, у вас соответственно возникает, естественно,
[02:28.680 --> 02:33.320]  образом дублирования кода, потому что вы составите нового персонажа с некоторой новой способностью,
[02:33.320 --> 02:37.200]  при этом старые свойства у него должны остаться. У него тоже есть показатель здоровья, у него тоже
[02:37.200 --> 02:42.720]  есть показатель сила и тому подобное. Возникает, во-первых, естественным образом дублирование кода.
[02:42.720 --> 02:52.160]  А во-вторых, давайте подумаем. Допустим, есть какой-то игрок, и игрок пытается создать
[02:52.160 --> 03:00.400]  свой набор юнитов, который у него есть, свой набор персонажей, которыми он управляет. Естественным
[03:00.400 --> 03:05.000]  образом хочется, наверное, сохранить их в одном массиве. Хочется сохранить их в одном массиве и
[03:05.000 --> 03:10.160]  как-то ими управлять единым образом, то есть заставить всех пойти в одно место, заставить их все выполнить
[03:10.160 --> 03:14.320]  какое-то определенное действие и тому подобное. При этом, если мы действуем таким образом,
[03:14.320 --> 03:20.600]  то есть мы для каждого персонажа, для каждой расы, чтобы это ни было, в общем, вы создаете свой класс,
[03:20.600 --> 03:24.320]  естественным образом вы не можете в одном массиве сохранить их все, потому что массив,
[03:24.320 --> 03:31.440]  собственно, у нас C++, может хранить только объекта одного типа. Поэтому возникает две проблемы.
[03:31.440 --> 03:37.440]  Первое, хотелось бы, наверное, избавиться от дублирования кода, то есть указать, что у вас есть класс,
[03:37.440 --> 03:41.520]  который очень похож на какой-то другой класс, и при этом не дублировать код, а создать примерно
[03:41.520 --> 03:45.200]  такое же, но с какими-то, может быть, дополнительными свойствами. А во-вторых, каким-то явным образом
[03:45.200 --> 03:51.240]  задать родство между этими классами, то есть сказать, что вот эти классы явно связаны друг с другом,
[03:51.240 --> 03:55.480]  то есть один тип, например, может приводиться к другому, вместо одного типа можно везде использовать
[03:55.480 --> 04:02.120]  другой тип и так далее. Соответственно, наследование про все это. И вот чтобы так поступить,
[04:02.120 --> 04:06.760]  мы можем воспользоваться следующим синтаксисом. Допустим, у вас есть некоторый базовый класс,
[04:06.760 --> 04:13.120]  персонаж, в данном случае StructHero, и вы хотите, то есть это некоторый базовый класс,
[04:13.120 --> 04:16.760]  который представляет себе какие-то общие характеристики каждого персонажа вашей компьютерной
[04:16.760 --> 04:21.160]  игры. Ну а теперь вы хотите на его основе уметь создавать каких-то конкретных персонажей,
[04:21.160 --> 04:26.640]  какие-то конкретные расы и тому подобное. Тогда для этого вы делаете следующую вещь. Вы пишете
[04:26.640 --> 04:33.680]  класс или структ, дальше пишете имя структуры или класса, и дальше через двоеточие указываете
[04:33.680 --> 04:38.120]  класс, на основании которого этот класс должен создаться. В данном случае я говорю, что структура
[04:38.120 --> 04:43.520]  лучника у меня создается на основе класса персонаж. Что это означает? Про это слово пока можно
[04:43.520 --> 04:49.760]  забыть, пока для нас оно ничего не означает. То есть просто пишем двоеточие и можно написать имя
[04:49.760 --> 04:55.240]  класса или какой-то другой структуры. И что это означает? Это означает, что все те поля и все те
[04:55.240 --> 05:03.440]  методы, которые были в базовом классе, теперь будут полями и методами в классе Archer. Понятно? То есть
[05:03.440 --> 05:08.800]  мне не нужно дублировать показатели сил, здоровья, опыта, метод лечения и так далее. То есть это у
[05:08.800 --> 05:16.640]  меня все уже автоматически присутствует в классе Archer. В этом суть, в общем, такой простой
[05:16.640 --> 05:27.000]  синтаксис. Почти то, к чему мы стремились, то, чего мы хотели. Тут пример, который демонстрирует,
[05:27.000 --> 05:32.080]  что теперь все поля и методы Hero являются также полями и методами класса Archer. То есть у HeroArcher
[05:32.080 --> 05:40.640]  есть поле HP, есть метод heal, и еще дополнительно мы здесь видим, что в классе Archer мы добавили
[05:40.640 --> 05:50.440]  метод shoot, которого нет в методе Hero. Соответственно, понятное дело, что у объекта типа Hero вы вызывать
[05:50.440 --> 05:56.320]  метод shoot не можете, так как там его нет, а у Archer метод shoot вызывать можете, так как мы туда его
[05:56.320 --> 06:06.520]  привнесли. Все понятно. Теперь давайте поговорим про важный момент, про то, как работают модификаторы
[06:06.520 --> 06:14.120]  доступа при наследовании. Модификаторы доступа, которые мы сейчас знаем, это public и private.
[06:14.120 --> 06:19.520]  С ними на самом деле все просто. Смотрите, если у меня есть какой-то базовый класс Hero, и у него есть
[06:19.520 --> 06:24.520]  публичные методы и приватные методы, то соответственно общие правила они сохраняются. Мы помним,
[06:24.520 --> 06:31.240]  что означает приватность. Приватность означает, что мы запрещаем всем, кроме друзей, пользоваться
[06:31.240 --> 06:37.680]  этим методами. И вот тут возникает такая ситуация, что наследники на самом деле не друзья. Если вы
[06:37.680 --> 06:42.520]  наследовались от этого класса, то вы не имеете права все равно использовать приватные методы. Но это
[06:42.520 --> 06:47.080]  логично. Представьте, что у вас есть некоторые классы. Допустим, в стандартной библиотеке есть
[06:47.080 --> 06:50.760]  какой-то класс. Понятное дело, что у них есть какие-то приватные методы. Как получить к ним доступ?
[06:50.760 --> 06:55.240]  Ну никак. Но при этом мог бы существовать лайфхак, при котором вы просто наследовались от этого класса
[06:55.240 --> 06:59.160]  и могли спокойно получить доступ к этим полям. Но, естественно, так делать нельзя.
[06:59.160 --> 07:13.160]  Если публичные методы используют приватные поля, и мы наследуем вот эти публичные методы, то эти методы используют приватные поля, а это не работает правильно?
[07:13.160 --> 07:18.400]  Естественно, они работают. Вот здесь пример. Естественно публичные поля могут спокойно использовать
[07:18.400 --> 07:24.920]  приватные как поля, так и методы, вот как и здесь. Соответственно, если я буду вызывать метод Heal через
[07:25.080 --> 07:29.440]  объект типа Archer, то все будет нормально. Я же на самом деле зову публичный метод, а он мне доступен.
[07:29.440 --> 07:42.280]  Ну вот, все понятно. Да, если вы на своего наследника объявите другом, то ему можно будет обращаться и к приватным методам.
[07:42.280 --> 07:52.600]  Вот здесь вот тогда такой пример. Есть структура Hero. У него есть публичный метод Heal и приватный метод UpdateHP.
[07:53.560 --> 07:59.160]  Тогда Archer в своих методах может вызывать Heal. То есть Heal это его метод.
[07:59.160 --> 08:05.480]  То есть он может вызывать свой метод. Потому что мы у наследовались от Hero, и теперь это его метод, он спокойно его может вызывать.
[08:05.480 --> 08:10.640]  Но при этом, несмотря на то, что UpdateHP тоже является его методом, но он как бы находится в закрытой части.
[08:10.640 --> 08:14.640]  То есть в закрытой части даже для самого класса Archer. Поэтому он его вызывать не имеет права.
[08:15.640 --> 08:21.720]  То есть он как бы есть, но он находится в закрытой части и к нему обращаться нельзя. Понятно?
[08:29.720 --> 08:39.080]  С наследованием паблик и приват могут приобретать некоторый иной смысл. В частности, я думаю, вы заметили, что у меня слово паблик написано вот здесь.
[08:39.520 --> 08:44.520]  То есть модификаторы доступа я также могу написать перед классом, который я наследую.
[08:44.520 --> 08:48.520]  То есть, например, здесь я могу написать паблик Hero или private Hero.
[08:48.520 --> 08:55.520]  Что это означает для класса Archer? Вот здесь важный момент. Для класса Archer это не означает буквально ничего.
[08:55.520 --> 09:00.520]  То есть на доступ внутри класса Archer это никак не влияет.
[09:00.520 --> 09:07.520]  То есть Archer по-прежнему может пользоваться публичными методами класса Hero, а приватными не может.
[09:07.960 --> 09:11.960]  То есть вот эти слова в данном контексте ни на что не влияют.
[09:11.960 --> 09:18.960]  Если я вот тут заменю паблик на private, то все будет то же самое. Понятно?
[09:21.960 --> 09:28.960]  А на что же все-таки влияют эти слова? Они влияют на то, как внешний код относится к классу Archer.
[09:28.960 --> 09:31.960]  Здесь все то же самое, что и с модификаторами доступа.
[09:32.400 --> 09:45.400]  Если вы говорите, что вы публично унаследовались Hero, то это означает, что вы всем говорите, что это мой батя и все имеют право использовать эту информацию.
[09:45.400 --> 09:47.400]  Что значит имеют право использовать эту информацию?
[09:47.400 --> 09:51.400]  Это означает, что они имеют право использовать методы.
[09:51.840 --> 10:00.840]  Если я создал класс Archer, то я имею право говорить, что Archer.Hill.
[10:02.840 --> 10:08.840]  Потому что у меня в структуре Hero есть метод Hill, а я Archer публичным образом унаследовал от Hero.
[10:08.840 --> 10:15.840]  То есть я всем говорю, что я унаследован от Hero, поэтому у меня есть все методы, которые есть и в классе Hero. Понятно?
[10:15.840 --> 10:20.840]  А если вы говорите private, а не паблик, то вот такая штука у вас не скомпилируется. Почему?
[10:21.280 --> 10:24.280]  Потому что вы говорите private, вы говорите, что это только для служебного пользования.
[10:24.280 --> 10:28.280]  Только класс Archer имеет право знать, что он унаследован от Hero.
[10:28.280 --> 10:32.280]  Никто другой не имеет права знать о том, что он унаследован от Hero.
[10:32.280 --> 10:36.280]  Соответственно, использовать методы Hero даже открытые, никто не имеет права. Понятно?
[10:36.280 --> 10:38.280]  Внешний код.
[10:38.280 --> 10:40.280]  Ещё один момент, кроме друзей.
[10:40.280 --> 10:44.280]  Но друзья все-таки могут использовать тот факт, что что-то приватное и так далее.
[10:44.280 --> 10:46.280]  Этот момент понятен?
[10:46.720 --> 10:49.720]  Ещё раз, вот это слово, которое написано здесь,
[10:49.720 --> 10:53.720]  оно имеет значение только для внешнего кода.
[10:53.720 --> 11:00.720]  Внутри класса Archer вы по-прежнему можете использовать публичные поля Hero, а приватные не можете.
[11:00.720 --> 11:05.720]  А вот это паблик и private относятся только к тому, как внешний код воспринимает Archer.
[11:05.720 --> 11:09.720]  В данном случае, если мы приватным образом унаследовались от Hero,
[11:09.720 --> 11:11.720]  то метод Heal мы не можем вызывать у Archer.
[11:11.720 --> 11:13.720]  Потому что метод Heal определен в Hero.
[11:14.160 --> 11:16.160]  А мы не имеем права знать, что мы унаследованы от Hero.
[11:19.160 --> 11:23.160]  Ну и давайте немного поупражняемся в этом всём.
[11:23.160 --> 11:25.160]  Что у меня тут за пример?
[11:26.160 --> 11:31.160]  У меня есть класс A, у него есть публичное поле X и приватный метод F.
[11:33.160 --> 11:37.160]  От этого класса я унаследовал структуру B публичным образом,
[11:37.160 --> 11:40.160]  и структуру C, но приватным образом.
[11:40.600 --> 11:43.600]  Давайте попробуем ответить на вопрос,
[11:43.600 --> 11:47.600]  имели ли я право в методе H структура B изменять поле X?
[11:49.600 --> 11:51.600]  Да, потому что X, по какой причине?
[11:51.600 --> 11:55.600]  Потому что паблик внутри A и потому что паблик внутри B.
[11:58.600 --> 12:01.600]  Да, потому что паблик у меня находится вот здесь.
[12:01.600 --> 12:05.600]  То есть класс A разрешил всем использовать это поле.
[12:05.600 --> 12:08.600]  Поэтому структура B тоже имеет право это использовать.
[12:09.040 --> 12:11.040]  Теперь то же самое, но в структуре C.
[12:11.040 --> 12:15.040]  Точный такой же метод H может ли он изменять поле X?
[12:15.040 --> 12:18.040]  Да, может, потому что снова возвращаемся.
[12:18.040 --> 12:21.040]  Вот это вот слово в данном контексте ни на что не влияет.
[12:21.040 --> 12:23.040]  То есть не важно, как я унаследовался.
[12:23.040 --> 12:26.040]  Вот эти слова паблик и private говорят лишь о том,
[12:26.040 --> 12:29.040]  что разрешаю ли я другим знать о том,
[12:29.040 --> 12:31.040]  что я унаследовался от кого-то или нет.
[12:31.040 --> 12:33.040]  При этом сама структура B и структура C, естественно,
[12:33.040 --> 12:35.040]  она знает, что она от кого-то унаследовалась.
[12:35.040 --> 12:37.040]  Ну а к X я могу обратиться,
[12:37.480 --> 12:39.480]  потому что, во-первых, C знает о том, что она унаследовалась от A,
[12:39.480 --> 12:44.480]  а во-вторых, потому что A разрешила всем использовать поле X.
[12:44.480 --> 12:46.480]  Оно в публичной области.
[12:46.480 --> 12:51.480]  Ну а метод F можно ли использовать в структуре B?
[12:51.480 --> 12:53.480]  Нет, нельзя. Почему?
[12:53.480 --> 12:58.480]  Да, потому что структура A вообще всем запретила использовать это поле.
[12:58.480 --> 13:00.480]  И структура B и структура C не являются друзьями.
[13:00.480 --> 13:03.480]  Поэтому и здесь, и здесь использовать нельзя.
[13:03.480 --> 13:05.480]  Теперь давайте перейдем на правую сторону.
[13:05.920 --> 13:07.920]  Значит, я создал объект типа A
[13:07.920 --> 13:09.920]  и пытаюсь обратиться к X и к F.
[13:09.920 --> 13:11.920]  Получится у меня это сделать или нет?
[13:11.920 --> 13:14.920]  Да, к X, да, к F нет.
[13:14.920 --> 13:17.920]  Ну тут как бы наследования никого нет.
[13:17.920 --> 13:20.920]  Просто работают модикатры доступа public и private.
[13:20.920 --> 13:22.920]  Теперь рассматриваем структуру B.
[13:22.920 --> 13:25.920]  Могу ли я у структуры B обратиться к полю X?
[13:25.920 --> 13:27.920]  Да.
[13:27.920 --> 13:29.920]  Почему?
[13:29.920 --> 13:32.920]  Ну, потому что, во-первых, да,
[13:33.360 --> 13:35.360]  потому что мы публично наследовали от A.
[13:35.360 --> 13:37.360]  То есть мы имеем право знать о том,
[13:37.360 --> 13:40.360]  что у меня в классе B тоже есть поле X.
[13:40.360 --> 13:42.360]  Ну, а во-вторых, сам A тоже разрешает доступ к X.
[13:42.360 --> 13:44.360]  Поэтому все нормально.
[13:44.360 --> 13:46.360]  Могу ли я вызывать B.F?
[13:50.360 --> 13:52.360]  А почему нет?
[13:52.360 --> 13:54.360]  Да, потому что даже несмотря на то,
[13:54.360 --> 13:56.360]  что у меня структура B говорит,
[13:56.360 --> 13:58.360]  что я публично наследован от A,
[13:58.360 --> 14:00.360]  то есть казалось бы, все имеют право знать о том,
[14:00.360 --> 14:02.360]  что я наследован от A,
[14:02.800 --> 14:04.800]  то есть не разрешает использовать метод F.
[14:04.800 --> 14:06.800]  То есть наследники никак не могут разрешить
[14:06.800 --> 14:08.800]  использовать эти методы.
[14:08.800 --> 14:10.800]  То есть если предок запретил,
[14:10.800 --> 14:12.800]  то, соответственно, наследники
[14:12.800 --> 14:14.800]  открыть доступ не могут.
[14:14.800 --> 14:16.800]  Ну, точнее, могут при переопределении,
[14:16.800 --> 14:18.800]  но об этом позже поговорим.
[14:18.800 --> 14:20.800]  Так, а в структуре C?
[14:20.800 --> 14:22.800]  Да, ни то, ни другое нельзя,
[14:22.800 --> 14:24.800]  потому что поле X и метод F
[14:24.800 --> 14:26.800]  это поля и методы,
[14:26.800 --> 14:28.800]  которые принадлежат классу A.
[14:28.800 --> 14:30.800]  А класс A у нас следован приватным образом.
[14:31.240 --> 14:33.240]  То есть мы не имеем права использовать тот факт,
[14:33.240 --> 14:35.240]  что мы как-то у наследованного от A.
[14:35.240 --> 14:37.240]  Все понятно?
[14:39.240 --> 14:41.240]  Отлично.
[14:41.240 --> 14:43.240]  Да, ну вот ответы.
[14:43.240 --> 14:45.240]  Теперь познакомимся
[14:45.240 --> 14:47.240]  с новым модификатором доступа.
[14:47.240 --> 14:49.240]  Вот.
[14:49.240 --> 14:51.240]  И он носит название Protected.
[14:51.240 --> 14:53.240]  Про Protected мы говорили,
[14:53.240 --> 14:55.240]  но до этого мы говорили,
[14:55.240 --> 14:57.240]  что Protected работает точно так же, как и Private.
[14:57.240 --> 14:59.240]  Но Protected работает немного иначе,
[14:59.680 --> 15:01.680]  значит, Protected действительно запрещает
[15:01.680 --> 15:03.680]  всем использовать
[15:03.680 --> 15:05.680]  эти поля и методы.
[15:05.680 --> 15:07.680]  То есть, грубо говоря, Protected действительно работает
[15:07.680 --> 15:09.680]  как и Private, но
[15:09.680 --> 15:11.680]  он разрешает доступ наследникам.
[15:11.680 --> 15:13.680]  То есть, если Private запрещает доступ наследникам,
[15:13.680 --> 15:15.680]  то Protected
[15:15.680 --> 15:17.680]  разрешает доступ наследникам
[15:17.680 --> 15:19.680]  и друзьям. Понятно?
[15:19.680 --> 15:21.680]  То есть, вот назначение
[15:21.680 --> 15:23.680]  ключевого слова Protected.
[15:23.680 --> 15:25.680]  Соответственно, если в структуре A
[15:25.680 --> 15:27.680]  объявил два поля, а они оба Protected,
[15:28.120 --> 15:30.120]  то внутри структуры B
[15:30.120 --> 15:32.120]  я могу использовать и X, и F.
[15:32.120 --> 15:34.120]  Спокойно.
[15:34.120 --> 15:36.120]  То есть, я могу спокойно обращаться к X,
[15:36.120 --> 15:38.120]  могу спокойно обращаться к F. Почему?
[15:38.120 --> 15:40.120]  Потому что структура A разрешила наследникам использовать эти поля.
[15:40.120 --> 15:42.120]  То есть, их вызывать, их как-то изменять и так далее.
[15:42.120 --> 15:44.120]  Но при этом,
[15:44.120 --> 15:46.120]  если я у объекта типа A
[15:46.120 --> 15:48.120]  попытаюсь через точку
[15:48.120 --> 15:50.120]  позвать X, F,
[15:50.120 --> 15:52.120]  то у меня возникнет ошибка компиляции.
[15:52.120 --> 15:54.120]  Потому что Protected разрешает доступ только наследникам.
[15:54.120 --> 15:56.120]  Внешнему коду использовать
[15:56.560 --> 15:58.560]  B.X и B.F вызывать нельзя.
[15:58.560 --> 16:00.560]  То есть, работает как private.
[16:00.560 --> 16:02.560]  Ну и то же самое касается B.
[16:02.560 --> 16:04.560]  B.X и B.F вызывать нельзя.
[16:04.560 --> 16:06.560]  Почему? Потому что
[16:06.560 --> 16:08.560]  внутри структуры A они объявлены как Protected.
[16:08.560 --> 16:10.560]  А Protected разрешает только наследникам.
[16:10.560 --> 16:12.560]  То есть, разрешает использовать только B.
[16:12.560 --> 16:14.560]  Внешнему коду A не давал никакого разрешения.
[16:14.560 --> 16:16.560]  Поэтому B.X и B.F
[16:16.560 --> 16:18.560]  тоже под запретом.
[16:19.000 --> 16:21.000]  Хорошо.
[16:25.000 --> 16:27.000]  Ну и Protected, как из
[16:27.000 --> 16:29.000]  public и private,
[16:29.000 --> 16:31.000]  можно использовать
[16:31.000 --> 16:33.000]  для изменения режима наследования.
[16:33.000 --> 16:35.000]  То есть, Protected можно писать
[16:35.000 --> 16:37.000]  перед именем класса, при наследовании.
[16:37.000 --> 16:39.000]  Ну и, собственно, это будет означать
[16:39.000 --> 16:41.000]  то же самое, что и модификатор доступа.
[16:41.000 --> 16:43.000]  То есть, мы запрещаем кому-либо знать о том,
[16:43.000 --> 16:45.000]  что мы у наследованного от A,
[16:45.000 --> 16:47.000]  кроме наследников.
[16:47.440 --> 16:49.440]  Ну вот здесь пример. У меня есть структура A.
[16:49.440 --> 16:51.440]  Структура B Protected образом
[16:51.440 --> 16:53.440]  унаследовала A.
[16:53.440 --> 16:55.440]  И дальше у меня структура C, которая унаследовала B.
[16:55.440 --> 16:57.440]  То есть, вот картина такая. Есть A.
[16:57.440 --> 16:59.440]  Есть B.
[16:59.440 --> 17:01.440]  Вот есть C.
[17:01.440 --> 17:03.440]  При этом, вот эту вот связь
[17:03.440 --> 17:05.440]  имеют право знать только наследники.
[17:05.440 --> 17:07.440]  То есть, только C, B имеют право знать,
[17:07.440 --> 17:09.440]  что вот есть такая связь.
[17:09.440 --> 17:11.440]  Поэтому, естественно, C
[17:11.440 --> 17:13.440]  имеет право обращаться к X и имеет
[17:13.440 --> 17:15.440]  это право обращаться к F.
[17:16.380 --> 17:18.380]  Потому что B разрешило своим наследникам
[17:18.380 --> 17:20.380]  знать о том, что B от чего-то унаследовано.
[17:20.380 --> 17:22.380]  Ну, соответственно, C знает,
[17:22.380 --> 17:24.380]  что B унаследовано от A.
[17:24.380 --> 17:26.380]  И поэтому C спокойно может обращаться к полям X и F.
[17:26.380 --> 17:28.380]  Но при этом обращаться
[17:28.380 --> 17:30.380]  к полям X и F через B,
[17:30.380 --> 17:32.380]  ну а тем более через C.
[17:32.380 --> 17:34.380]  A.X и A.
[17:34.380 --> 17:36.380]  Ой. C.X
[17:36.380 --> 17:38.380]  и C.F.
[17:38.380 --> 17:40.380]  Это запрещено.
[17:40.380 --> 17:42.380]  Окей?
[17:42.380 --> 17:44.380]  Вопрос какой-то?
[17:44.380 --> 17:46.380]  Вот.
[17:46.380 --> 17:48.380]  Ну и
[17:48.380 --> 17:50.380]  еще одно упражнение.
[17:50.380 --> 17:52.380]  Значит,
[17:52.380 --> 17:54.380]  есть структура A,
[17:54.380 --> 17:56.380]  теперь у него три поля,
[17:56.380 --> 17:58.380]  теперь у него три модификатора
[17:58.380 --> 18:00.380]  доступа внутри есть публичное поле X,
[18:00.380 --> 18:02.380]  есть приватный метод F,
[18:02.380 --> 18:04.380]  есть protected метод G.
[18:04.380 --> 18:06.380]  Я структуру B
[18:06.380 --> 18:08.380]  protected образом наследую от A.
[18:08.380 --> 18:10.380]  А структуру C публичным образом
[18:10.380 --> 18:12.380]  наследую от B.
[18:12.380 --> 18:14.380]  Вопрос внутри H.
[18:14.380 --> 18:16.380]  Могу ли я обращаться к X?
[18:16.380 --> 18:18.380]  Да, потому что почему?
[18:18.380 --> 18:20.380]  Во-первых,
[18:20.380 --> 18:22.380]  потому что я бы
[18:22.380 --> 18:24.380]  унаследовал от A, во-вторых,
[18:24.380 --> 18:26.380]  потому что в A это поле публичное.
[18:26.380 --> 18:28.380]  Так, могу ли я обращаться к F?
[18:28.380 --> 18:30.380]  Нет, у A это поле
[18:30.380 --> 18:32.380]  приватное, поэтому к нему я
[18:32.380 --> 18:34.380]  обращаться не могу. Могу ли я обращаться к G?
[18:34.380 --> 18:36.380]  Да, почему?
[18:36.380 --> 18:38.380]  Да, потому что это поле
[18:38.380 --> 18:40.380]  protected, то есть структура A
[18:40.380 --> 18:42.380]  разрешает использовать
[18:42.380 --> 18:44.380]  этот метод.
[18:44.380 --> 18:46.380]  Ну и на правую сторону перейдем.
[18:48.380 --> 18:50.380]  Можно ли вызывать A.G?
[18:50.380 --> 18:52.380]  Нельзя, это protected поле.
[18:52.380 --> 18:54.380]  Protected поле для внешнего кода работает
[18:54.380 --> 18:56.380]  как private.
[18:56.380 --> 18:58.380]  Могу ли я обращаться к B.X?
[18:58.380 --> 19:00.380]  Почему?
[19:02.380 --> 19:04.380]  Да, потому что я
[19:04.380 --> 19:06.380]  от A унаследован
[19:06.380 --> 19:08.380]  protected образом.
[19:08.380 --> 19:10.380]  А вот это наследование говорит о том,
[19:10.380 --> 19:12.380]  что никто не имеет права, кроме наследников,
[19:12.380 --> 19:14.380]  знать о том, что я от чего-то унаследован.
[19:14.380 --> 19:16.380]  Поэтому здесь нет, ну и давайте сразу скажем,
[19:16.380 --> 19:18.380]  что здесь везде нет.
[19:18.380 --> 19:20.380]  H можно, потому что H это публичное поле
[19:20.380 --> 19:22.380]  внутри самой структуры B.
[19:22.380 --> 19:24.380]  Почему
[19:24.380 --> 19:26.380]  B.X, B.F, B.G нельзя вызывать?
[19:26.380 --> 19:28.380]  Понятно, да?
[19:28.380 --> 19:30.380]  Эти все методы, они принадлежат
[19:30.380 --> 19:32.380]  классу A, а класс A у меня
[19:32.380 --> 19:34.380]  у наследован, а структура B
[19:34.380 --> 19:36.380]  у меня protected образом наследована от A.
[19:36.380 --> 19:38.380]  Поэтому вот внутри,
[19:38.380 --> 19:40.380]  в этом внешнем коде я не имею права использовать
[19:40.380 --> 19:42.380]  тот факт, что я как-то унаследован от A.
[19:44.380 --> 19:46.380]  Так, ну и теперь
[19:46.380 --> 19:48.380]  на C посмотрим, могу ли я обращаться
[19:48.380 --> 19:50.380]  к C.X?
[19:50.380 --> 19:52.380]  Почему?
[19:58.380 --> 20:00.380]  Кто считает, что можно?
[20:00.380 --> 20:02.380]  А кто считает, что нельзя?
[20:02.380 --> 20:04.380]  Ну, с победой, да.
[20:04.380 --> 20:06.380]  В общем, к X
[20:06.380 --> 20:08.380]  обращаться
[20:08.380 --> 20:10.380]  действительно нельзя. Почему?
[20:10.380 --> 20:12.380]  Потому что X, ну смотрите,
[20:12.380 --> 20:14.380]  что у меня тут происходит. У меня есть
[20:14.380 --> 20:16.380]  структура C,
[20:16.380 --> 20:18.380]  а внутри структуры C лежит
[20:18.380 --> 20:20.380]  некоторая часть,
[20:20.380 --> 20:22.380]  которая относится к B.
[20:22.380 --> 20:24.380]  А внутри B относится
[20:24.380 --> 20:26.380]  какой-то кусок, который относится к A.
[20:26.380 --> 20:28.380]  И вот B говорит о том,
[20:28.380 --> 20:30.380]  что вот
[20:30.380 --> 20:32.380]  тот факт, что в B есть какие-то
[20:32.380 --> 20:34.380]  поля или методы от A,
[20:34.380 --> 20:36.380]  внешний код
[20:36.380 --> 20:38.380]  не имеет никакого права.
[20:38.380 --> 20:40.380]  А что происходит здесь, когда я вызываю
[20:40.380 --> 20:42.380]  C.X?
[20:42.380 --> 20:44.380]  Ну откуда у меня пришло поле X?
[20:44.380 --> 20:46.380]  Ну поле X, во-первых, у меня пришло
[20:46.380 --> 20:48.380]  из B, то есть так у меня C унаследован от B,
[20:48.380 --> 20:50.380]  у меня X перешло по наследству
[20:50.380 --> 20:52.380]  в класс C. А B
[20:52.380 --> 20:54.380]  разрешает использовать X?
[20:54.380 --> 20:56.380]  Нет, B не разрешает использовать
[20:56.380 --> 20:58.380]  X. Почему? Потому что
[20:58.380 --> 21:00.380]  это значит, что внешнему коду использовать знание о том,
[21:00.380 --> 21:02.380]  что B унаследован от A нельзя.
[21:02.380 --> 21:04.380]  Соответственно, классу C
[21:04.380 --> 21:06.380]  тоже нельзя использовать.
[21:06.380 --> 21:08.380]  Внешнему коду нельзя использовать информацию о том,
[21:08.380 --> 21:10.380]  что C унаследован от A.
[21:10.380 --> 21:12.380]  Понятно?
[21:12.380 --> 21:14.380]  Поэтому здесь, конечно, нет.
[21:16.380 --> 21:18.380]  Дальше. Можно ли вызывать F?
[21:18.380 --> 21:20.380]  Ну, F, понятное дело, нельзя,
[21:20.380 --> 21:22.380]  потому что это приватное поле вообще в A.
[21:22.380 --> 21:24.380]  G можно вызывать или нет?
[21:24.380 --> 21:26.380]  Нет, это Protected поле, а H
[21:26.380 --> 21:28.380]  могу вызывать?
[21:28.380 --> 21:30.380]  Да, могу, потому что у меня, во-первых,
[21:30.380 --> 21:32.380]  у меня C разрешает знать о том,
[21:32.380 --> 21:34.380]  что я унаследован от B,
[21:34.380 --> 21:36.380]  а во-вторых, сам B разрешает
[21:36.380 --> 21:38.380]  использовать H.
[21:40.380 --> 21:42.380]  Вопросы?
[21:44.380 --> 21:46.380]  Хорошо.
[21:48.380 --> 21:50.380]  Ну да.
[21:50.380 --> 21:52.380]  Ну и в общем,
[21:52.380 --> 21:54.380]  когда мы говорим про
[21:54.380 --> 21:56.380]  вот эти самые режимы наследования,
[21:56.380 --> 21:58.380]  Public, Private, Protected,
[21:58.380 --> 22:00.380]  можно пользоваться
[22:00.380 --> 22:02.380]  следующей семантикой.
[22:02.380 --> 22:04.380]  Когда вы публичным образом
[22:04.380 --> 22:06.380]  наследуете от чего-то,
[22:06.380 --> 22:08.380]  вы заявляете, что
[22:08.380 --> 22:10.380]  тот класс, который вы сейчас
[22:10.380 --> 22:12.380]  создаете, является
[22:12.380 --> 22:14.380]  и тем классом, от которого вы унаследованы.
[22:14.380 --> 22:16.380]  То есть, грубо говоря, когда вы наследуете
[22:16.380 --> 22:18.380]  структуру B публичным образом от A,
[22:18.380 --> 22:20.380]  то вы объясните, что
[22:20.380 --> 22:22.380]  B, на самом деле, является A.
[22:22.380 --> 22:24.380]  Понятно почему.
[22:24.380 --> 22:26.380]  Потому что всё то, что верно
[22:26.380 --> 22:28.380]  для A, верно и для B.
[22:28.380 --> 22:30.380]  То есть, если у A можно вызывать какие-то поля,
[22:30.380 --> 22:32.380]  то те же самые поля можно вызывать и у B.
[22:32.380 --> 22:35.380]  Если для A можно вызовать какие-то
[22:35.380 --> 22:37.380]  методы, то те же поля можно вызывать
[22:37.380 --> 22:39.380]  и у B. Поэтому везде, где
[22:39.380 --> 22:41.380]  по смыслу можно подставить A...
[22:41.380 --> 22:43.380]  Это у меня от вас есть F от A!
[22:43.380 --> 22:45.380]  ...туда же и по смыслу можно
[22:45.380 --> 22:53.180]  Понятно? Семантика такая. Это не только семантика, не только такой амниманический правил, но и реальный действующий правил.
[22:53.180 --> 22:58.380]  Везде, где по смыслу, по контексту вы можете подставить класс A, вы можете подставить и класс B.
[22:58.380 --> 23:04.380]  Это называется принцип установки Барбар и Лисков. Вот эта семантика является. Понятно?
[23:04.380 --> 23:11.380]  То есть если вы хотите сказать, что какой-то класс является тем же самым, что и другой класс,
[23:11.380 --> 23:15.380]  можно с некоторыми уточнениями, то используйте публичное наследование.
[23:15.380 --> 23:18.380]  А какую семантику реализует Private и Protected?
[23:18.380 --> 23:22.380]  Естественно, Private и Protected не могут использовать семантику «является»,
[23:22.380 --> 23:28.380]  потому что если у A можно вызывать метод F, то у B метод F вызывать нельзя.
[23:28.380 --> 23:32.380]  Мы это проговорили несколько минут назад.
[23:32.380 --> 23:36.380]  Private и Protected реализуют семантику «содержат».
[23:36.380 --> 23:40.380]  То есть если структура B Protected или Private образом наследована от A,
[23:40.380 --> 23:43.380]  то мы можем говорить о том, что B содержит A.
[23:43.380 --> 23:47.380]  То есть B, как деталь реализации внутри себя, содержит A.
[23:53.380 --> 24:00.380]  Ну и в большинстве ситуаций, так как Private и Protected реализуют семантику «содержать»,
[24:00.380 --> 24:05.380]  вообще говоря, Private и Protected наследования используются очень редко.
[24:05.380 --> 24:11.380]  Почему? Потому что семантику «содержать» можно реализовать и с помощью простой композиции.
[24:11.380 --> 24:15.380]  То есть вместо того, чтобы наследовать структуру B от класса A,
[24:15.380 --> 24:21.380]  вы спокойно можете просто-напросто создать поле типа A и использовать его.
[24:21.380 --> 24:24.380]  Понятно, почему это эквивалентно?
[24:24.380 --> 24:29.380]  Потому что по-прежнему вот и здесь, и здесь, то есть классы B и C могут использовать спокойные методы A,
[24:29.380 --> 24:34.380]  могут использовать спокойно поля A, и при этом никто внешне об этом ничего не знает.
[24:34.380 --> 24:41.380]  Поэтому очень часто, но почти всегда Private и Protected наследования можно избежать
[24:41.380 --> 24:47.380]  и ввести просто композицию, то есть ввести просто поле в Private или Protected область.
[24:47.380 --> 24:54.380]  Но есть небольшое отличие, когда на самом деле используется Private или Protected наследование.
[24:55.380 --> 25:01.380]  Самый частый кейс – это так называемая empty-base-optimization.
[25:01.380 --> 25:11.380]  История такая. Известно, что для любого объекта C++ размер байтов должен быть как минимум 1 байт.
[25:11.380 --> 25:19.380]  Даже если вы создали пустую структуру или пустой класс, то размер одного объекта такого класса или структуры – это 1 байт.
[25:19.380 --> 25:25.380]  Для чего это нужно? Просто стандарт говорит о том, что если у вас есть два различных объекта,
[25:25.380 --> 25:28.380]  то их адреса физически должны отличаться.
[25:28.380 --> 25:32.380]  Понятное дело, что если у вас объект занимает 0 байт, то у вас нет никакой возможности
[25:32.380 --> 25:37.380]  отличить один объект от другого по адресу.
[25:37.380 --> 25:41.380]  Поэтому каждый объект C++ имеет размер как минимум 1 байт.
[25:41.380 --> 25:44.380]  И это может вызывать проблемы.
[25:44.380 --> 25:49.380]  Допустим, у меня есть структура C, у которой есть свое какое-то поле X,
[25:49.380 --> 25:55.380]  и при этом она сама по себе унаследована в качестве деталей реализации.
[25:55.380 --> 25:58.380]  Ей необходимо использовать класс, у которого нет никаких полей.
[25:58.380 --> 26:03.380]  Это может пока показаться странным, но вообще такие классы можно придумать.
[26:03.380 --> 26:08.380]  Мы писали такие классы. Может, кто-нибудь вспомнит, какой класс у нас был, когда про шаблоны говорили.
[26:09.380 --> 26:12.380]  Например, мы писали класс IsInt.
[26:12.380 --> 26:15.380]  Класс, который проверял, является ли тип Int или нет.
[26:15.380 --> 26:19.380]  Но этот класс естественным образом не содержал никаких полей,
[26:19.380 --> 26:24.380]  кроме статического поля, а статического поля в самом объекте не содержится.
[26:24.380 --> 26:29.380]  Соответственно, такие объекты, которые не содержат в себе стейтлесс объекта,
[26:29.380 --> 26:33.380]  которые не содержат в себе никакого состояния, являются пустыми.
[26:33.380 --> 26:40.380]  Тем не менее, если я заведу этот объект в качестве поля некоторые структуры,
[26:40.380 --> 26:44.380]  то размер самой структуры C у меня будет больше, чем размер Int.
[26:44.380 --> 26:47.380]  Ну, ровно по той причине, про которую я говорил.
[26:47.380 --> 26:50.380]  Каждый объект памяти должен занимать хотя бы один байт.
[26:50.380 --> 26:52.380]  Что, наверное, как-то накладно.
[26:52.380 --> 26:55.380]  То есть мы хотели как бы завести всего лишь одно поле Int,
[26:55.380 --> 26:58.380]  всего лишь одно интовое поле, и завести какое-нибудь поле,
[26:58.380 --> 27:02.380]  которое вообще не имеет внутри себя никаких других полей.
[27:02.380 --> 27:05.380]  Конечно, мы ожидаем, что это все будет как-то эффективно по памяти храниться и так далее,
[27:05.380 --> 27:07.380]  но этого не происходит.
[27:07.380 --> 27:10.380]  Так вот, в C++ есть MTBaseOptimization, которая говорит о следующем,
[27:10.380 --> 27:17.380]  что если вы наследуетесь от объекта, от пустого объекта,
[27:17.380 --> 27:20.380]  то есть от объекта, у которого нет своих собственных полей,
[27:20.380 --> 27:25.380]  то, в общем, размер этой базы составляет 0 байт.
[27:25.380 --> 27:29.380]  Короче, сама часть, которая относится к базовому классу,
[27:29.380 --> 27:31.380]  то есть как это расположено в памяти.
[27:31.380 --> 27:34.380]  Если у вас есть какой-то класс B, то в нем сначала в памяти располагается какая-то часть,
[27:34.380 --> 27:36.380]  которая относится к A, а затем, соответственно,
[27:36.380 --> 27:39.380]  относятся все те части, которые являются с полями.
[27:39.380 --> 27:44.380]  Так вот, если у вас базовый класс пустой, то есть у него у самого нет полей,
[27:44.380 --> 27:53.380]  то происходит оптимизация, и, в общем, базовый класс в памяти B занимает ровно 0 байт.
[27:53.380 --> 28:05.380]  Опять же, как я сказал, я привел примеры для класса изInt.
[28:05.380 --> 28:08.380]  То есть у вас в принципе могут защищать классы, у которых нет никаких полей.
[28:08.380 --> 28:12.380]  ИзInt, и в принципе в стандартной библиотеке их много.
[28:12.380 --> 28:17.380]  ИзInt, изPointer, и так далее, и так далее.
[28:17.380 --> 28:19.380]  Зачем можно было захотеть их наследовать?
[28:19.380 --> 28:26.380]  Ну вот, представьте себе, что вы...
[28:26.380 --> 28:30.380]  Давайте продолжим изInt.
[28:30.380 --> 28:36.380]  Смотрите, у вас есть структура изInt,
[28:36.380 --> 28:41.380]  которая проверяет, грубо говоря, является шаблонной, естественно.
[28:41.380 --> 28:47.380]  Которая проверяет, является ли шаблонный тип, который вы туда передали, Int.
[28:47.380 --> 28:50.380]  А теперь представьте себе, что вы хотите завести класс,
[28:50.380 --> 28:53.380]  который не просто проверяет, является ли переданный тип Int,
[28:53.380 --> 28:58.380]  а хотите проверять, действительно ли он является в принципе целочисленным типом.
[28:58.380 --> 29:03.380]  Тогда что вы можете сделать? Вы можете написать структ из Integral,
[29:03.380 --> 29:07.380]  то есть является ли тип целочисленным,
[29:07.380 --> 29:10.380]  ну и прописать там какую-то реализацию.
[29:10.380 --> 29:13.380]  Но при этом снова возникает проблема дублирования кода, согласны?
[29:13.380 --> 29:18.380]  Понятное дело, что у меня есть классы изInt, у меня есть класс изChar, и так далее, и так далее.
[29:18.380 --> 29:22.380]  Соответственно, мне нужно просто все эти проверки внести внутрь моего класса.
[29:22.380 --> 29:31.380]  Если я этого делать не хочу, я просто, например, наследуюсь от класса изInt.
[29:31.380 --> 29:36.380]  И теперь из Integral у меня автоматически будет равен true, если там, грубо говоря...
[29:36.380 --> 29:40.380]  Если мне передали тип Int, то у меня автоматически будет подставлен true.
[29:57.380 --> 30:02.380]  Нет, у вас все работает так.
[30:02.380 --> 30:07.380]  Я рисовал картинку, давайте еще раз.
[30:07.380 --> 30:11.380]  Если я хочу создать объект типа B, то что у меня происходит?
[30:11.380 --> 30:17.380]  У меня в начале объекта B находится все то, что относится к наследнику.
[30:17.380 --> 30:27.380]  То есть если у меня у наследника есть поля X, Y и Z, то все эти поля располагаются строго в объекте B.
[30:27.380 --> 30:32.380]  А дальше идут свои собственные поля, там это T, U, V и так далее.
[30:32.380 --> 30:36.380]  То есть B это на самом деле самостоятельный тип.
[30:36.380 --> 30:39.380]  Просто мы говорим, что он создан вот так.
[30:39.380 --> 30:44.380]  То есть он содержит все те же поля, что и A, и все те же методы, что и A.
[30:48.380 --> 30:53.380]  Каждый класс должен самостоятельно проговорить, кто и чьим другом является.
[30:53.380 --> 30:58.380]  То есть если кто-то является другом для A, то он не будет являться другом для B.
[30:58.380 --> 31:01.380]  Наоборот тоже нет.
[31:06.380 --> 31:10.380]  Нет, это все на этапе компиляции, естественно, происходит.
[31:10.380 --> 31:18.380]  То есть компилятор видит, как объявлен и определен класс структуры B.
[31:18.380 --> 31:22.380]  Структура B это то же самое, что структура A плюс еще что-то.
[31:22.380 --> 31:25.380]  Тут нет никаких проблем.
[31:25.380 --> 31:28.380]  То есть размер структуры B и все то, что содержится внутри структуры B,
[31:28.380 --> 31:30.380]  известно на этапе компиляции.
[31:30.380 --> 31:32.380]  То есть уже при чтении вашей программы все понятно.
[31:32.380 --> 31:36.380]  То есть тут на этап линковки, на этап рантайма ничего не оставляется.
[31:40.380 --> 31:42.380]  Еще вопросы?
[31:42.380 --> 31:50.380]  То есть если у нас есть компиляция B, то это будет класс A.
[31:50.380 --> 31:53.380]  Если у класса B сделано компиляция, какой-то другой класс,
[31:53.380 --> 31:57.380]  он не сможет являться к элементам класса A.
[31:57.380 --> 32:00.380]  Сможет. Нет, так сможет.
[32:00.380 --> 32:03.380]  Давайте про это тоже поговорим.
[32:03.380 --> 32:09.380]  Ну, допустим, у меня в структуре A есть поле, давайте int y заведем.
[32:09.380 --> 32:17.380]  Если я внутри B скажу, что у меня там, не знаю, friend void f,
[32:17.380 --> 32:23.380]  и вот я начну писать реализацию метода f,
[32:23.380 --> 32:28.380]  то B.y я делать могу.
[32:28.380 --> 32:38.380]  Если y protected, то...
[32:38.380 --> 32:42.380]  Так, давайте разбираться.
[32:42.380 --> 32:47.380]  Нет, я думаю нет.
[32:47.380 --> 32:50.380]  Потому что protected...
[32:50.380 --> 32:54.380]  Короче, поле y защищено самим A, а не B.
[32:54.380 --> 32:58.380]  То есть B не имеет права разрешать доступ к полям A.
[32:58.380 --> 33:02.380]  То есть если A сам запретил, то B не может открыть доступ.
[33:06.380 --> 33:09.380]  Да, вот это понятно, почему если я сделаю поле y protected,
[33:09.380 --> 33:13.380]  то даже если у меня f друг, тут будет ошибка компиляции.
[33:13.380 --> 33:15.380]  Давайте так, по порядку, как это работает.
[33:15.380 --> 33:17.380]  Вот я обращаюсь B.y.
[33:17.380 --> 33:19.380]  Сначала происходит проверка имен.
[33:19.380 --> 33:22.380]  То есть сначала компилятор проверяет,
[33:22.380 --> 33:24.380]  существует ли такое имя y внутри B.
[33:24.380 --> 33:26.380]  Ну вот он смотрит.
[33:26.380 --> 33:29.380]  Внутри структуры B такого поля нет.
[33:29.380 --> 33:31.380]  Может оно есть у наследников.
[33:31.380 --> 33:35.380]  Компилятор сам себя спрашивает, а могу ли я обращаться к наследникам?
[33:35.380 --> 33:38.380]  Ну, естественно, в данном случае могу, потому что f друг.
[33:38.380 --> 33:41.380]  Даже несмотря на то, что я унаследовал A приватным образом,
[33:41.380 --> 33:44.380]  я могу обращаться к A.
[33:44.380 --> 33:47.380]  Все, дальше я попадаю в A и смотрю, да, там есть y.
[33:47.380 --> 33:51.380]  Я захожу в y, но потом понимаю, что y это protected.
[33:51.380 --> 33:55.380]  То есть сам A запрещает, то есть B разрешает использовать A,
[33:55.380 --> 34:00.380]  но при этом A запрещает обращаться к своим приватным и protected областям, естественно.
[34:00.380 --> 34:04.380]  Вот чтобы я мог обращаться к y, мне нужно еще внутри A дополнительно объявить,
[34:04.380 --> 34:09.380]  то есть сам A еще должен объявить функцию f своим другом.
[34:15.380 --> 34:17.380]  Все ясно?
[34:17.380 --> 34:25.380]  В каком случае, например, структура C не может обращаться к A?
[34:25.380 --> 34:28.380]  Вот здесь A.y?
[34:28.380 --> 34:34.380]  Нет, нет, естественно, структура C же не унаследована от A.
[34:34.380 --> 34:37.380]  То есть protected разрешает доступ только к наследникам.
[34:37.380 --> 34:40.380]  В данном случае C от A не унаследован.
[34:40.380 --> 34:44.380]  C просто завел поле типа A.
[34:44.380 --> 34:49.380]  Еще вопросы?
[34:54.380 --> 34:57.380]  Давайте тогда дальше пойдем.
[35:15.380 --> 35:19.380]  В конце замечаний, бывает полезно, если класс реализован с помощью другого класса,
[35:19.380 --> 35:21.380]  которого нет, не статически.
[35:21.380 --> 35:23.380]  Но это вот про пример из int.
[35:23.380 --> 35:25.380]  То есть если я хочу унаследовать свойства из int,
[35:25.380 --> 35:28.380]  то есть если я хочу, чтобы у меня класс дополнительно мог проверять свойства,
[35:28.380 --> 35:32.380]  является там что-то int или нет, то я могу делать так.
[35:32.380 --> 35:35.380]  А ваш вопрос подробный в чем стоял еще?
[35:44.380 --> 35:59.380]  Вот, да, это интересный вопрос.
[35:59.380 --> 36:04.380]  Слушайте, каждый год возникает такой вопрос, я это постоянно проверяю,
[36:04.380 --> 36:08.380]  но я могу соврать, но вообще работает так.
[36:08.380 --> 36:10.380]  Сейчас я поясню вопрос.
[36:10.380 --> 36:12.380]  Вопрос состоит в следующем.
[36:12.380 --> 36:14.380]  У меня статическое поле X.
[36:14.380 --> 36:18.380]  Я структуру A унаследовал в класс B.
[36:18.380 --> 36:20.380]  То есть теперь у меня как будто бы есть класс A,
[36:20.380 --> 36:23.380]  у которого есть общий X, как это статический.
[36:23.380 --> 36:27.380]  И с другой стороны вроде как есть класс B,
[36:27.380 --> 36:29.380]  который унаследован от A,
[36:29.380 --> 36:31.380]  соответственно у него тоже есть какой-то статическое поле X.
[36:31.380 --> 36:34.380]  И вот вопрос, вот это поле X, оно общее для A и B или разное?
[36:34.380 --> 36:37.380]  И вот насколько я помню, оно все-таки разное.
[36:37.380 --> 36:39.380]  То есть B и A в этом смысле независимо.
[36:39.380 --> 36:41.380]  То есть если вы статическое поле меняете у A,
[36:41.380 --> 36:44.380]  то у B оно не изменится.
[36:44.380 --> 36:47.380]  Если у кого-то есть нож, можете сейчас проверить и искать.
[36:47.380 --> 36:51.380]  Это хороший вопрос, но я точно не помню.
[36:51.380 --> 36:53.380]  Но вообще, как правило, когда мы говорим про статические поля,
[36:53.380 --> 36:55.380]  они как правило все константные.
[36:55.380 --> 36:57.380]  То есть когда мы говорим про излинт и так далее,
[36:57.380 --> 37:00.380]  в случае константных полей, естественно, такого вопроса не возникает.
[37:00.380 --> 37:04.380]  Но вообще, по-моему, у A и B все-таки разные поля.
[37:04.380 --> 37:09.380]  Если что, в перерыве я посмотрю, если сейчас никто не проверит.
[37:10.380 --> 37:13.380]  Так, еще интересные вопросы будут.
[37:18.380 --> 37:20.380]  Хорошо.
[37:24.380 --> 37:26.380]  Когда мы говорили про классы и структуры,
[37:26.380 --> 37:28.380]  то есть я думаю, вы уже привыкли,
[37:28.380 --> 37:31.380]  что я взаимозаменяемо называю классы структурами, структуры классами.
[37:31.380 --> 37:34.380]  Потому что с точки зрения теории ООП и структуры класса это то же самое.
[37:34.380 --> 37:37.380]  Просто у одних все поля открыты, у других все поля закрыты.
[37:37.380 --> 37:40.380]  Но это можно изменить с помощью public, private и protected слов.
[37:40.380 --> 37:45.380]  И вот до этого мы говорили, что это единственное отличие классов от структур.
[37:45.380 --> 37:47.380]  Вот есть, на самом деле, второе и последнее.
[37:47.380 --> 37:49.380]  То есть отличие классов от структур всего два.
[37:49.380 --> 37:51.380]  Первое, про то, что мы говорили,
[37:51.380 --> 37:54.380]  что в классах все по умолчанию приватное, а в структурах все по умолчанию публичное.
[37:54.380 --> 37:57.380]  И второе отличие связано с наследованием.
[37:57.380 --> 38:01.380]  То есть для структур, если вы вот тут не пишете никакого слова,
[38:01.380 --> 38:05.380]  то есть не указываете конкретно, каким образом вы наследуете класс,
[38:05.380 --> 38:07.380]  то тут ставится public.
[38:07.380 --> 38:10.380]  То есть по умолчанию вы наследуете публичное.
[38:10.380 --> 38:13.380]  А если вы пишете класс, то по умолчанию вы наследуете приватное.
[38:13.380 --> 38:15.380]  То есть по сути то же самое.
[38:15.380 --> 38:17.380]  То есть правило общее остается.
[38:17.380 --> 38:19.380]  В классах все приватное, в структурах все публичное.
[38:19.380 --> 38:21.380]  Если не сказано иное.
[38:21.380 --> 38:26.380]  Отличие классов от структур всего два, и вот мы все их обсудили.
[38:26.380 --> 38:29.380]  Больше никаких отличий структур от классов нет.
[38:29.380 --> 38:31.380]  Они абсолютно взаимозаменяемые.
[38:31.380 --> 38:34.380]  И формальной, и какой-то синтетической тоже разницы нет.
[38:34.380 --> 38:37.380]  То есть отличие только в модификаторах доступа по умолчанию.
[38:42.380 --> 38:44.380]  Хорошо.
[38:46.380 --> 38:51.380]  Теперь поговорим про основные моменты, которые связаны с наследованием.
[38:51.380 --> 38:53.380]  Мы поговорили.
[38:53.380 --> 38:55.380]  Мы теперь можем наследовать один класс от другого,
[38:55.380 --> 38:58.380]  использовать свойства одного типа в другом типе,
[38:58.380 --> 39:01.380]  использовать их взаимозаменяемые и так далее.
[39:01.380 --> 39:05.380]  Ну и теперь давайте поговорим про некоторые технические детали.
[39:05.380 --> 39:09.380]  В частности, про то, в каком порядке вызывают конструкторы и деструкторы.
[39:09.380 --> 39:12.380]  И вообще, в принципе, как вызвать деструктор базового класса.
[39:12.380 --> 39:16.380]  Потому что мы говорили, что если у вас есть класс B,
[39:16.380 --> 39:18.380]  то у него есть часть, которая относится к A,
[39:18.380 --> 39:21.380]  и у него могут быть свои поля типа X, Y и Z.
[39:21.380 --> 39:24.380]  Ну и естественный вопрос возникающий.
[39:24.380 --> 39:26.380]  Понятное дело, как мне проницилизировать X, Y и Z,
[39:26.380 --> 39:29.380]  а как мне проницилизировать часть, которая относится к A?
[39:29.380 --> 39:31.380]  Нужно ли мне все это заново делать вручную или нет?
[39:31.380 --> 39:33.380]  Ну вот про это, видимо, поговорим после перерыва.
[39:35.380 --> 39:37.380]  Так, продолжим.
[39:42.380 --> 39:46.380]  Ну вот перед перерывом я уже задал некоторую задачу,
[39:46.380 --> 39:48.380]  то есть задал некоторую проблему.
[39:48.380 --> 39:51.380]  Напомню, давайте более конкретно.
[39:51.380 --> 39:53.380]  Вот у нас есть класс Stack.
[39:53.380 --> 39:57.380]  Представьте себе, что я хочу написать класс StackMax и StackMin.
[39:57.380 --> 40:01.380]  Ну, собственно, классы, которые поддерживают,
[40:01.380 --> 40:03.380]  ну, помимо того, что являются стэками,
[40:03.380 --> 40:06.380]  так еще и поддерживают максимум и минимум.
[40:06.380 --> 40:08.380]  То есть в любой момент времени я могу спросить,
[40:08.380 --> 40:10.380]  какой у меня сейчас максимум хранится в стэке
[40:10.380 --> 40:11.380]  и какой у меня сейчас минимум.
[40:11.380 --> 40:13.380]  Ну, классическая задача, ну, помните, так решается.
[40:13.380 --> 40:15.380]  Просто мы храним два стэка,
[40:15.380 --> 40:17.380]  в одном стэке храним текущий максимум,
[40:17.380 --> 40:19.380]  в другом стэке храним сами значения.
[40:19.380 --> 40:21.380]  Ну, естественно, чтобы не дублировать код,
[40:21.380 --> 40:25.380]  я хочу, например, унаследовать StackMax
[40:25.380 --> 40:27.380]  или Stack публичным образом.
[40:27.380 --> 40:29.380]  Ну, почему я публичным образом?
[40:29.380 --> 40:32.380]  Потому что у меня выполняется принцип установки лисков.
[40:32.380 --> 40:34.380]  То есть у меня StackMax, он, по сути,
[40:34.380 --> 40:36.380]  сам является по себе stack'ом.
[40:36.380 --> 40:39.380]  Так как у меня отношение между Stack и StackMax
[40:39.380 --> 40:41.380]  отношение является,
[40:41.380 --> 40:43.380]  то это значит я делаю публичное наследование.
[40:43.380 --> 40:45.380]  Ну и дополнительно в StackMax я завожу
[40:45.380 --> 40:48.380]  буфер, которым буду хранить текущий максимум.
[40:48.380 --> 40:51.380]  Вот.
[40:51.380 --> 40:53.380]  Ну и аналогично завожу класс StackMin.
[40:53.380 --> 40:55.380]  И вот представь себе, делаю, ну,
[40:55.380 --> 40:57.380]  делаю следующие вещи.
[40:57.380 --> 40:59.380]  Значит, здесь, что я делаю?
[40:59.380 --> 41:01.380]  Здесь я просто беру, говорю, что,
[41:01.380 --> 41:03.380]  ну, внутри StackMax мне нужен
[41:03.380 --> 41:05.380]  конструктор копирования.
[41:05.380 --> 41:07.380]  И я его пишу, ну, следующим образом.
[41:07.380 --> 41:09.380]  Я говорю, что у меня есть,
[41:09.380 --> 41:11.380]  я принимаю объект adder
[41:11.380 --> 41:13.380]  и внутри него как-то инициализирую
[41:13.380 --> 41:15.380]  Max буфер на основе adder.
[41:15.380 --> 41:17.380]  Вот.
[41:17.380 --> 41:19.380]  И есть другой класс,
[41:19.380 --> 41:21.380]  который я просто объявляю как дефолт.
[41:21.380 --> 41:23.380]  Вот.
[41:23.380 --> 41:25.380]  Может кто-то понимает, почему.
[41:25.380 --> 41:27.380]  То есть, соответственно, тут стоит вопрос,
[41:27.380 --> 41:29.380]  как StackMax и StackMin будут проинициализированы части,
[41:29.380 --> 41:31.380]  которые относятся к Stack?
[41:31.380 --> 41:33.380]  Вот кто как думает?
[41:33.380 --> 41:35.380]  Вот смотрите, у меня есть,
[41:35.380 --> 41:37.380]  давайте рассмотрим StackMax.
[41:37.380 --> 41:39.380]  У меня есть StackMax, я там пытаюсь
[41:39.380 --> 41:41.380]  реализовать конструктор копирования.
[41:41.380 --> 41:43.380]  Ну, что делает конструктор?
[41:43.380 --> 41:45.380]  Конструктор, естественно, нужно
[41:45.380 --> 41:47.380]  проинициализировать все поля.
[41:47.380 --> 41:49.380]  Ну, какие поля? То есть, это поля,
[41:49.380 --> 41:51.380]  это Max буфер.
[41:51.380 --> 41:53.380]  Вот Max буфер, я вроде как
[41:53.380 --> 41:55.380]  с ним что-то делаю.
[41:55.380 --> 41:57.380]  Тут написано, что я выполню какие-то действия.
[41:57.380 --> 41:59.380]  Как проинициализируется у меня Stack?
[41:59.380 --> 42:01.380]  И будет ли оно вообще проинициализирован?
[42:11.380 --> 42:13.380]  Так, вызовет свой конструктор копирование.
[42:13.380 --> 42:15.380]  А еще какие варианты?
[42:15.380 --> 42:17.380]  Кто считает, что вообще хоть какой-то конструктор
[42:17.380 --> 42:19.380]  вызовется?
[42:19.380 --> 42:21.380]  Кто считает, что никакого конструктора
[42:21.380 --> 42:23.380]  для Stack вызвано не будет?
[42:29.380 --> 42:31.380]  Ну, на самом деле, смотрите,
[42:31.380 --> 42:33.380]  весь прикол конструктора заключается в том,
[42:33.380 --> 42:35.380]  что они не могут быть
[42:35.380 --> 42:37.380]  не вызваны.
[42:37.380 --> 42:39.380]  В общем, если у вас для класса есть конструктор,
[42:39.380 --> 42:41.380]  то у вас нет никакого другого способа
[42:41.380 --> 42:43.380]  создать объект, кроме как вызов конструктора.
[42:43.380 --> 42:45.380]  Поэтому, так как у меня внутри StackMax
[42:45.380 --> 42:47.380]  есть какой-то поле Stack,
[42:47.380 --> 42:49.380]  то в любом случае для него хоть какой-то конструктор
[42:49.380 --> 42:51.380]  обязан быть вызван.
[42:51.380 --> 42:53.380]  И он произойдет по вашему желанию
[42:53.380 --> 42:55.380]  или без вашего желания.
[42:55.380 --> 42:57.380]  Другой вопрос какой?
[42:57.380 --> 42:59.380]  На самом деле, здесь будет вызван обычный
[42:59.380 --> 43:01.380]  конструктор по умолчанию.
[43:01.380 --> 43:03.380]  Stack будет создан по умолчанию, никого копирования
[43:03.380 --> 43:05.380]  не произойдет. Ну, и это на самом деле согласуется
[43:05.380 --> 43:07.380]  с тем, что мы обсуждали до этого.
[43:07.380 --> 43:09.380]  Помните, когда мы обсуждали списки инициализации?
[43:09.380 --> 43:11.380]  Что мы говорили, когда у нас списка инициализации нет?
[43:11.380 --> 43:13.380]  Если мы не пишем список инициализации,
[43:13.380 --> 43:15.380]  то что происходит?
[43:19.380 --> 43:21.380]  Что происходит, если мы не пишем список инициализации?
[43:25.380 --> 43:27.380]  Все поля инициализируются по умолчанию.
[43:29.380 --> 43:31.380]  Если вы не пишете список инициализации,
[43:31.380 --> 43:33.380]  то все равно надо все проинициализировать,
[43:33.380 --> 43:35.380]  прежде чем вы войдете в тело конструктора,
[43:35.380 --> 43:37.380]  вам нужно все проинициализировать.
[43:37.380 --> 43:39.380]  Я предвидел это.
[43:39.380 --> 43:41.380]  И, соответственно,
[43:45.380 --> 43:47.380]  базовые классы тоже, естественно,
[43:47.380 --> 43:49.380]  нужно проинициализировать.
[43:49.380 --> 43:51.380]  Точнее, часть, которая относится к базовым классам,
[43:51.380 --> 43:53.380]  тоже нужно проинициализировать.
[43:53.380 --> 43:55.380]  А как ее проинициализировать? Тут есть только один вариант
[43:55.380 --> 43:57.380]  вызвать конструктор по умолчанию.
[43:57.380 --> 43:59.380]  А что произойдет здесь, если я попытаюсь
[43:59.380 --> 44:01.380]  сделать дефолт?
[44:01.380 --> 44:03.380]  Во-первых,
[44:03.380 --> 44:05.380]  наверное, должно быть понятно,
[44:05.380 --> 44:07.380]  что
[44:07.380 --> 44:09.380]  MaxG bin Romania
[44:09.380 --> 44:11.380]  не будет проинициализирован,
[44:11.380 --> 44:13.380]  точнее, будет проинициализирован, но бусером.
[44:15.380 --> 44:17.380]  Неправда, тебе это Lynnd simplified Shamrock сказал.
[44:17.380 --> 44:19.380]  Как будет проинициализструктор MaxG buf?
[44:21.380 --> 44:23.380]  Вот у меня есть Stackmin,
[44:23.380 --> 44:25.380]  в нем есть часть, которая относится к dollar,
[44:25.380 --> 44:27.380]  и这 часть, которая относится к MaxG buf.
[44:27.380 --> 44:29.380]  Как будет проинициализовано часть, которая относится к MaxG buf?
[44:29.380 --> 44:31.380]  Не probability.
[44:31.380 --> 44:33.380]  Да, она будет просто побитово скопирована.
[44:33.380 --> 44:42.840]  Дефолт означает, что конструктор копирования должен быть реализован как не побитого, а просто вызван для всего копирования.
[44:42.840 --> 44:45.840]  То есть, maxboot будет скопирован из другого, то есть из adder.
[44:45.840 --> 44:48.840]  А как будет проницелизированная часть, которая относится к стеку?
[44:48.840 --> 44:53.840]  Да, правильно. Вот тут уже будет вызван конструктор копирования.
[44:53.840 --> 45:01.340]  Тут будет вызвано копирование для этой штуки и копирование для этой штуки.
[45:01.800 --> 45:04.800]  Но при этом здесь это OK, а здесь это не OK.
[45:04.800 --> 45:08.800]  А то, что написано сверху, здесь вот такой стек нас не устраивает.
[45:08.800 --> 45:11.800]  То есть, мы вряд ли хотим создавать копирование стек по дефолту.
[45:11.800 --> 45:14.800]  А вот здесь нас устраивает. То есть, мы что-то сделали для maxboot.
[45:16.800 --> 45:17.800]  Понятно проблема?
[45:23.800 --> 45:26.800]  В первом случае в стек ничего не копируется.
[45:26.800 --> 45:29.800]  То есть, сама часть, которая относится к стеку, она не будет скопирована, она будет просто создана по умолчанию.
[45:30.260 --> 45:35.260]  В втором случае стек скопируется, но часть, которая относится к стеку, интеллизируется по умолчанию.
[45:35.260 --> 45:43.260]  То есть, сам буфер, который должен хранить минимум, будет скопирован неправильно.
[45:43.260 --> 45:46.260]  Он просто скопируется.
[45:46.720 --> 45:59.720]  Как решить эту проблему?
[45:59.720 --> 46:02.720]  Как написать конструктор так, чтобы все было нормально?
[46:02.720 --> 46:06.720]  Допустим, вы пишете свой конструктор, допустим, для stackmax.
[46:06.720 --> 46:09.720]  И вы знаете, что stackmax унаследован как-то от стека.
[46:09.720 --> 46:11.720]  Вот как правильно прониетализировать базовый класс?
[46:11.720 --> 46:14.720]  На самом деле, все очень просто. Достаточно воспользоваться списком интеллизации.
[46:15.180 --> 46:22.180]  В списке интеллизации вы через двоеточие просто-напросто указываете, какой конструктор базового класса нужно вызвать.
[46:22.180 --> 46:29.180]  И вот вся базовая часть, точнее, все поля, которые относятся к базовой части, они будут прониетализированы с помощью вот этого конструктора, который вы здесь указали.
[46:29.180 --> 46:34.180]  То есть, можно считать в некотором смысле, опять же, как можно думать про наследование.
[46:34.180 --> 46:38.180]  Про наследование можно думать так, что у вас есть просто какое-то неявное поле.
[46:38.180 --> 46:42.180]  То есть, раньше у вас были поля явные, вы создавали поля, давали им имена.
[46:42.640 --> 46:48.640]  И здесь можно сказать, что у вас появилось некоторое безымянное поле, к которому просто можно обращаться через имя класса.
[46:48.640 --> 46:52.640]  Но в данном случае мы знаем, что stackmax у наследован от стека.
[46:52.640 --> 46:55.640]  То есть, в нем содержится целый кусок, который относится к стеку.
[46:55.640 --> 47:00.640]  И есть поле maxBuffer. И вот здесь я, соответственно, инициализирую stack с помощью копирования от adder.
[47:00.640 --> 47:05.640]  И maxBuffer, соответственно, выделяю там память.
[47:05.640 --> 47:08.640]  Ну и дальше, собственно, в цикле копирую все, что мне нужно.
[47:09.100 --> 47:10.100]  Окей?
[47:16.100 --> 47:20.100]  Во, да, это хороший вопрос.
[47:20.100 --> 47:26.100]  Предполагается, что у меня в стеке, естественно, есть конструктор копирования.
[47:26.100 --> 47:28.100]  Как выглядит конструктор копирования в стеке?
[47:28.100 --> 47:30.100]  Ну, он выглядит таким образом.
[47:30.100 --> 47:34.100]  const stack по ссылке.
[47:34.100 --> 47:36.100]  Да, и тут возникает логичный вопрос.
[47:36.560 --> 47:38.560]  Это ссылка на stackmax.
[47:38.560 --> 47:43.560]  Но при этом я ее передаю в функцию, которая ожидает ссылку на stack.
[47:43.560 --> 47:44.560]  Как это работает?
[47:44.560 --> 47:46.560]  Ну, на самом деле это работает.
[47:46.560 --> 47:52.560]  Работает это по той причине, что публичное наследование у меня реализует семантику является.
[47:52.560 --> 47:54.560]  Даже не так. Нет, это неправда.
[47:54.560 --> 47:56.560]  Не по этой причине.
[47:56.560 --> 48:00.560]  Это верно, потому что у меня stackmax сам по себе имеет право использовать...
[48:01.020 --> 48:08.020]  Stackmax имеет право использовать тот факт, что он наследован от stack.
[48:08.020 --> 48:14.020]  То есть stackmax имеет право использовать тот факт, что внутри stackmax есть часть, которая относится к stack.
[48:14.020 --> 48:18.020]  И, соответственно, когда у вас происходит такое присваивание, у вас что происходит?
[48:18.020 --> 48:22.020]  У вас есть stack, у вас есть какая-то часть, которая относится к stackmax.
[48:22.020 --> 48:24.020]  Это все stackmax.
[48:24.480 --> 48:30.480]  Когда вы передаете ссылку на такой объект в функцию, которая ожидает ссылку на stack,
[48:30.480 --> 48:33.480]  то она просто связывается с этим начальным куском.
[48:37.480 --> 48:41.480]  То есть, грубо говоря, stackmax – это то же самое, что и stack, но что-то еще.
[48:41.480 --> 48:45.480]  Но когда вы связываете ссылку на производный класс с ссылкой на базовый класс,
[48:45.480 --> 48:48.480]  то вот это вот что-то еще, оно как бы игнорируется просто-напросто.
[48:48.480 --> 48:50.480]  Понятно?
[48:50.940 --> 48:55.940]  То есть мы со stackmaxом можем работать точно так же, как и с обычным stack'ом.
[48:55.940 --> 49:00.940]  То есть мы stackmax можем передавать во все функции, которые там ожидают stack и так далее.
[49:03.940 --> 49:04.940]  Нет, естественно, нет.
[49:04.940 --> 49:09.940]  То есть если у вас есть какая-то функция, которая ожидает на вход stackmax,
[49:09.940 --> 49:14.940]  то передать ей внутрь stack нельзя.
[49:14.940 --> 49:19.940]  Это тоже понятно, потому что если вы передаете stackmax туда, где ожидается stack,
[49:20.400 --> 49:22.400]  то вы как-то подужать до stack'а можете.
[49:22.400 --> 49:26.400]  А если вы передаете stack там, где ожидается stackmax, то расширить вы не можете.
[49:26.400 --> 49:30.400]  Точнее, мы об этом поговорим, на самом деле можете, но нужно написать отдельный конструктор.
[49:30.400 --> 49:32.400]  То есть если вы написали отдельный конструктор,
[49:32.400 --> 49:36.400]  который позволяет вам из меньшего типа сделать больший тип, то да, так нет.
[49:45.400 --> 49:47.400]  Этот пример понятен?
[49:48.360 --> 49:54.860]  Ну то есть мораль такая, если вам нужно как-то особый образом создать базовую часть,
[49:54.860 --> 49:56.860]  точнее часть, которая относится к базовому классу,
[49:56.860 --> 49:58.860]  то вы должны вызвать его конструктор и синтаксис такой.
[49:58.860 --> 50:00.860]  Через твои точки вы в списке индивидуализации пишете,
[50:00.860 --> 50:02.860]  какой конструктор для базовой класса нужно вызвать,
[50:02.860 --> 50:06.860]  именно он будет работать, точнее базовую часть создаст он.
[50:10.860 --> 50:12.860]  Ну да, какой у нас порядок?
[50:12.860 --> 50:15.860]  То есть мы говорили, что то, что вы написали в списке индивидуализации,
[50:15.860 --> 50:19.860]  Порядок создания списка инициализации по сути игнорируется.
[50:19.860 --> 50:32.860]  Порядок создания полей определяется порядком их перечистления,
[50:32.860 --> 50:36.860]  а не порядком их упоминания в списке инициализации.
[50:36.860 --> 50:39.860]  В случае с базовыми классами все то же самое.
[50:39.860 --> 50:42.860]  Как это работает? У вас есть структура B,
[50:42.860 --> 50:46.860]  у вас есть часть, которая относится к A,
[50:46.860 --> 50:55.860]  у вас есть класс A, в нем есть X и Y,
[50:55.860 --> 50:58.860]  все это остальное, все это большое, это B,
[50:58.860 --> 51:01.860]  и в нем есть дополнительное поле Z.
[51:01.860 --> 51:07.860]  Значит, инициализируется все по порядку.
[51:07.860 --> 51:10.860]  Сначала инициализируется все то, что относится к A.
[51:10.860 --> 51:14.860]  Если ваш класс следует от какого-то другого класса,
[51:14.860 --> 51:17.860]  то сначала будет инициализироваться базовый класс,
[51:17.860 --> 51:20.860]  по понятным причинам.
[51:20.860 --> 51:22.860]  Сначала инициализируется база,
[51:22.860 --> 51:25.860]  а только потом инициализируется все остальное,
[51:25.860 --> 51:28.860]  которое относится к B, и при этом строго в том порядке,
[51:28.860 --> 51:30.860]  в котором все перечислено.
[51:30.860 --> 51:34.860]  Если у вас тут есть int, то после Z будет инициализирован t.
[51:34.860 --> 51:42.860]  Теперь давайте посмотрим, каким образом...
[51:42.860 --> 51:45.860]  Вот у меня есть структура A,
[51:45.860 --> 51:47.860]  в нем есть два поля X и Y,
[51:47.860 --> 51:49.860]  и в этой структуре есть два конструктора.
[51:49.860 --> 51:51.860]  Есть конструктор, который принимает 1 int,
[51:51.860 --> 51:53.860]  есть конструктор, который принимает 2 int.
[51:53.860 --> 51:55.860]  Не важно, что они делают,
[51:55.860 --> 51:58.860]  допустим, предположим, что они просто инициализируют X и Y.
[51:58.860 --> 52:02.860]  Что у меня произойдет, если я просто-напросто возьму
[52:02.860 --> 52:06.860]  и попытаюсь создать конструктор по умолчанию B вот таким образом?
[52:06.860 --> 52:10.860]  Здесь у меня произойдет ошибка эмпиляции.
[52:10.860 --> 52:13.860]  Понятно, почему?
[52:19.860 --> 52:24.860]  Кто понимает, почему в такой строке у меня будет ошибка эмпиляции?
[52:25.860 --> 52:31.860]  А почему тут вызывается конструктор по умолчанию?
[52:31.860 --> 52:34.860]  Я же его не вызываю.
[52:42.860 --> 52:47.860]  Здесь я пытался написать конструктор по умолчанию,
[52:47.860 --> 52:49.860]  который ничего не принимает
[52:49.860 --> 52:51.860]  и который, по сути, ничего не делает.
[52:51.860 --> 52:53.860]  На самом деле мы знаем,
[52:53.860 --> 52:55.860]  что сейчас какая-то инициализация должна происходить.
[52:55.860 --> 52:57.860]  В частности, я еще раз повторяю,
[52:57.860 --> 52:59.860]  что если вы написали списки инициализации,
[52:59.860 --> 53:01.860]  они в любом случае выполняются.
[53:01.860 --> 53:04.860]  В данном случае компилятор просто попытался все проинциализировать по умолчанию.
[53:04.860 --> 53:08.860]  То есть сначала он попытался проинциализировать базу A,
[53:08.860 --> 53:10.860]  то есть базовый класс A, по умолчанию.
[53:10.860 --> 53:12.860]  Но у класса A конструктор по умолчанию нет.
[53:12.860 --> 53:18.860]  И вот, собственно, в этот же момент, в самый первый момент он зафейлился.
[53:18.860 --> 53:20.860]  Что происходит далее?
[53:20.860 --> 53:24.860]  Дальше я пишу конструктор, который принимает один int.
[53:24.860 --> 53:28.860]  Он принимает один int и далее перенаправляет его в конструктор A.
[53:28.860 --> 53:30.860]  То есть в итоге что у меня происходит?
[53:30.860 --> 53:34.860]  У меня класс A, точнее часть класса B, которая относится к A,
[53:34.860 --> 53:36.860]  проинциализирована одним int,
[53:36.860 --> 53:38.860]  а Z проинциализирован нулем,
[53:38.860 --> 53:40.860]  потому что у меня написано это здесь.
[53:40.860 --> 53:42.860]  Можно вопрос?
[53:42.860 --> 53:44.860]  Да.
[53:44.860 --> 53:46.860]  А если бы у нас не было ни одного конструктора по умолчанию,
[53:46.860 --> 53:50.860]  то для вас это будет сначала строить свободу на самwife local?
[53:50.860 --> 53:52.860]  Да.
[53:52.860 --> 53:54.860]  По правилам создание конструктора.
[53:54.860 --> 53:55.860]  Если у вас в классе нет ни одного конструктора,
[53:55.860 --> 53:57.860]  то комператор за вас создает конструктор по умолчанию.
[53:57.860 --> 54:00.860]  То есть если внутри структура они написали неодного конструктора,
[54:00.860 --> 54:02.860]  то это на самом деле значит, что у вас в структуре A есть конструктор
[54:02.860 --> 54:04.860]  и конструктор по умолчанию.
[54:06.860 --> 54:08.860]  Вот.
[54:08.860 --> 54:10.860]  Ну то же самое для конструктора с двумя аргументами.
[54:10.860 --> 54:13.860]  То есть у меня B принимает X, Y.
[54:13.860 --> 54:15.860]  И я их могу спокойно перенаправить в A.
[54:15.860 --> 54:20.580]  Ну и третий пример.
[54:20.580 --> 54:24.060]  У меня конструктор B может принимать три аргумента,
[54:24.060 --> 54:27.220]  и тогда первые два аргумента я передаю to.
[54:27.220 --> 54:29.500]  А последним аргументом инестализирую set.
[54:29.500 --> 54:33.460]  Вот, соответственно, пример, как использовать конструктор базового класса.
[54:33.460 --> 54:35.980]  В данном случае я использовал конструктор, который принимает один аргумент,
[54:35.980 --> 54:37.960]  и конструктор, который принимает два аргумента.
[54:37.960 --> 54:41.820]  В зависимости от ситуации я пользуюсь тем или иным конструктором.
[54:41.820 --> 54:51.820]  Теперь у меня вопрос к вам. А есть ли что-то, что вас, так скажем, смущает в этих примерах?
[54:51.820 --> 55:09.820]  Не кажется ли, например, вам, что вот эти два конструктора, они в некотором смысле, если код не дублируют, то по крайней мере его как-то сильно увеличивают?
[55:09.820 --> 55:21.820]  Что я по сути тут говорю? Я по сути говорю то, что класс B я могу создать точно так же, как и класс A. То есть я могу создать его с помощью одного аргумента, могу создать его с помощью двух аргументов.
[55:21.820 --> 55:27.820]  И все, что я делаю, это я просто перенаправляю эти аргументы к конструктору A. Согласитесь как-то накладно.
[55:27.820 --> 55:34.820]  Представьте, что у меня в конструкторе A есть какой-то большой список конструкторов, который принимает один аргумент, два, три, четыре и так далее.
[55:34.820 --> 55:40.820]  И я хочу, чтобы наследник я мог создавать точно таким же образом. То есть передавать один, два, три и так далее аргументов.
[55:40.820 --> 55:50.820]  Но тогда мне просто придется все вот эти конструкторы продублировать. Проблема.
[55:50.820 --> 56:00.820]  Чтобы такой проблемы избежать, если вы хотите сказать, что в классе наследники можно использовать те же самые конструкторы, что и в A, вам достаточно писать следующую конструкцию.
[56:00.820 --> 56:10.820]  Using A 2.2.A. То есть это просто нам означает, что у меня класс B использует те же самые конструкторы, что и A.
[56:10.820 --> 56:20.820]  То есть в данном случае у меня структура B может принимать те же самые аргументы конструктора, что и A, и при этом все эти параметры будут автоматически перенаправлены в класс A.
[56:20.820 --> 56:26.820]  Ну если вам нужен конструктор от трех аргументов, то тут уже ничего не поделаешь.
[56:26.820 --> 56:34.820]  А нет конструктора от трех аргументов, поэтому здесь мы принимаем три аргумента, первые два передаем в A, остальные оставляем в B.
[56:34.820 --> 56:46.820]  Нет, с деструктурами мы отдельно поговорим, но с деструктурами все гораздо проще, с деструктурами все нормально.
[56:46.820 --> 56:54.820]  Деструкторы базовых классов тоже вызываются автоматически, но так как деструктор не имеет аргументов, то там такой проблемы в принципе не возникает.
[56:54.820 --> 57:04.820]  Еще важный момент. Вы не можете проинициализировать базовый класс частично.
[57:04.820 --> 57:12.820]  То есть вы инициализируете базовый класс либо полностью, либо полностью, в общем других вариантов нет.
[57:12.820 --> 57:17.820]  То есть вы не можете сказать, что у меня есть конструктор B, который принимает три аргумента, x, y и z.
[57:17.820 --> 57:22.820]  И отдельно проинициализировать x, отдельно проинициализировать y, и отдельно проинициализировать z.
[57:22.820 --> 57:30.820]  Х и y это не независимые сущности. Х и y они приходят вам в пакет.
[57:30.820 --> 57:38.820]  Т.е. х и y они приходят вместе, вместе с классом А. Они неразрывно с классом A связаны, поэтому отдельно их проинициализировать вы не можете.
[57:38.820 --> 57:44.820]  только класс A целиком, соответственно, вот эта штука не работает.
[57:44.820 --> 57:51.820]  То есть единственный возможный способ проницилизировать поля базового класса
[57:51.820 --> 57:59.820]  это явно вызвать конструктор базового класса. По отдельности поля инициализировать нельзя.
[57:59.820 --> 58:06.820]  Пример ясен? Хорошо.
[58:06.820 --> 58:11.820]  Ну и про деструктор. С деструктором всё на самом деле очень просто.
[58:11.820 --> 58:19.820]  Всё то же самое, про что мы говорили ранее. Если у меня есть класс B, у него есть поля X, Y, Z и T,
[58:19.820 --> 58:28.820]  если они создаются в прямом порядке, то уничтожаются они в обратном порядке.
[58:28.820 --> 58:38.820]  Ну и то же самое касается базовых классов. У вас B в данном примере выглядит на самом деле следующим образом.
[58:38.820 --> 58:45.820]  У вас есть B, в нём находится какая-то часть, которая относится к A, и есть S1 и S2.
[58:45.820 --> 58:52.820]  Когда у вас вызывается конструктор для B, сначала создаётся A, а потом создаются S1 и S2.
[58:52.820 --> 58:57.820]  А когда у вас вызывается деструктор, то у вас автоматически вызывается деструктор для S2,
[58:57.820 --> 59:03.820]  вызывается деструктор для S1 и автоматически вызывается деструктор для базового класса.
[59:03.820 --> 59:08.820]  То есть, если вы написали деструкт어를 для базового класса, то дублировать его в наследники не нужно.
[59:08.820 --> 59:16.500]  не нужно. В этом и кайф конструкторов и деструкторов. Он состоит в том, что где бы не
[59:16.500 --> 59:20.700]  находился этот объект, то есть как наследованная часть или там как часть
[59:20.700 --> 59:24.100]  какой-то функции, у вас всегда в начале жизни этого объекта будет вызываться
[59:24.100 --> 59:28.540]  конструктор, а в позвершении будет вызываться деструктор.
[59:29.100 --> 59:32.420]  Мораль понятна?
[59:36.020 --> 59:43.660]  Ну и поговорим про срезку. Привет, последний пункт. Это про что?
[59:43.660 --> 59:48.220]  Это как раз про то, что мы сейчас на самом деле вот все это время до этого
[59:48.220 --> 59:53.260]  говорили про такое поставить наследование, как отсутствие дублирования кода.
[59:53.260 --> 59:58.060]  То есть по большому счету мы почти никак не использовали родство между классами,
[59:58.060 --> 01:00:02.580]  мы просто говорили, что а у наследовали от а, и теперь у меня внутри
[01:00:02.580 --> 01:00:06.620]  б находятся те же самые поля и меды, которые находятся и в а. То есть просто
[01:00:06.620 --> 01:00:10.500]  избавился себя от дублирования кода. Ну и деструктор у меня тоже для базового
[01:00:10.500 --> 01:00:13.580]  класса вызывается автоматически. Воззывать там ничего не нужно, тоже избавилось
[01:00:13.580 --> 01:00:17.140]  от дублирования кода. Конструкторы тоже автоматически, мне писать не нужно, все они
[01:00:17.140 --> 01:00:22.420]  могут быть унаследованы. А теперь давайте поговорим про второй пункт, который мы
[01:00:22.420 --> 01:00:26.380]  задавали в самом начале. Это про использование информации о том, что
[01:00:26.380 --> 01:00:31.380]  что какие-то классы являются родственниками друг к другу. И вот первый пункт – это срезка.
[01:00:31.380 --> 01:00:38.380]  Смотрите, у меня есть структура A, есть структура B, которая публичным образом наследована от A.
[01:00:38.380 --> 01:00:42.380]  Еще раз повторюсь, что публичное наследование, оно, по сути, говорит о том, что B является A.
[01:00:42.380 --> 01:00:50.380]  Ну, естественно, не наоборот. То есть если стол является мебелью, то не любая мебель является столом.
[01:00:50.380 --> 01:00:55.380]  Ну и, соответственно, что это означает? Что нам дает на практике, вот это вот отношение является.
[01:00:55.380 --> 01:01:00.380]  Дает нам следующее. Я теперь могу создавать объекты типа B, во второй строке.
[01:01:00.380 --> 01:01:06.380]  Я могу выставлять объекты типа B и присваивать их объектам типа A.
[01:01:09.380 --> 01:01:14.380]  Ну и то же самое в третьей строке. Почему это работает?
[01:01:14.380 --> 01:01:23.380]  Ну, ровно потому, что B является A. Если B является A, то во всех контекстах,
[01:01:23.380 --> 01:01:28.380]  где у меня ожидается тип A, я могу подставлять и тип B.
[01:01:32.380 --> 01:01:38.380]  То есть везде, куда я могу подставить A, я могу подставить и B, потому что B является A.
[01:01:38.380 --> 01:01:42.380]  И что? Ну, наоборот, естественно, неверно.
[01:01:42.380 --> 01:01:47.380]  Это логично, что я не могу проинтересовать объект типа B, а объектом типа A,
[01:01:47.380 --> 01:01:51.380]  потому что A это более узкий объект, чем B. B более широкий.
[01:01:51.380 --> 01:01:58.380]  Что здесь происходит? Что такое срезка? Что здесь происходит с логической точки зрения?
[01:01:58.380 --> 01:02:02.380]  Здесь на самом деле создается отдельный объект A.
[01:02:02.380 --> 01:02:09.380]  То есть у вас есть какой-то объект B, и вы хотите с помощью него создать объект A.
[01:02:09.380 --> 01:02:13.380]  И в этом случае происходит, так скажем, копирование.
[01:02:13.380 --> 01:02:18.380]  Копирование части, которая относится к A в объект, который вы что-то присваиваете.
[01:02:21.380 --> 01:02:25.380]  То есть просто часть, которая относится к A, она копируется в другую часть.
[01:02:25.380 --> 01:02:31.380]  Ну, либо с помощью конструктора копирования, если такой в классе A задан, либо просто-напросто побитого.
[01:02:31.380 --> 01:02:34.380]  Вот эта штука называется срезкой.
[01:02:34.380 --> 01:02:40.380]  То есть у вас был какой-то исходный большой объект, и вы его обрезали до более узкого, который потребовался.
[01:02:40.380 --> 01:02:45.380]  То есть создалась отдельная копия, копия объекта базового класса,
[01:02:45.380 --> 01:02:49.380]  но при этом которая создана с помощью объекта производного класса.
[01:02:51.380 --> 01:02:56.380]  Есть вопросы по этому? Что происходит? Все понятно?
[01:03:00.380 --> 01:03:04.380]  Да, соответственно данная возможность называется срезкой.
[01:03:04.380 --> 01:03:08.380]  При присваивании используется только часть класса, относящаяся к базовому классу.
[01:03:08.380 --> 01:03:12.380]  Соответственно здесь в правой части стоит объект типа B, в левой части стоит объект типа A.
[01:03:12.380 --> 01:03:16.380]  Ну и соответственно в объект типа A копируется только часть, которая относится к A.
[01:03:16.380 --> 01:03:21.380]  Наоборот, естественно нельзя, потому что непонятно, как пронизируются элементы B, которых нет в A.
[01:03:21.380 --> 01:03:28.380]  Ну и при срезке будут использованы именно копирующий или перемещающий конструктор, если они есть.
[01:03:28.380 --> 01:03:40.380]  То есть в данном случае будет вызван вот здесь конструктор копирования A.
[01:03:40.380 --> 01:03:44.380]  Почему он может быть корректно вызван? Мы уже говорили, да?
[01:03:44.380 --> 01:03:47.380]  Потому что в объекте типа B есть целый кусок, который относится к A.
[01:03:47.380 --> 01:03:51.380]  И вот соответственно когда я создаю ссылку или константную ссылку вот на этот объект,
[01:03:51.380 --> 01:03:54.380]  у меня ссылка она ссылается только вот на эту часть.
[01:03:54.380 --> 01:03:57.380]  То есть все остальное игнорируется.
[01:04:01.380 --> 01:04:06.380]  На самом деле то же самое, на самом деле срезка может быть использована и при приватном и протекторном следовании.
[01:04:06.380 --> 01:04:12.380]  Но единственное отличие, посмотрите, почему срезка у меня была возможна здесь?
[01:04:12.380 --> 01:04:19.380]  Потому что внешний код имеет право знать о том, что я унаследован от A, точнее B унаследовано от A.
[01:04:19.380 --> 01:04:24.380]  То есть внешний код имеет право знать о том, что A унаследовано от B, B унаследовано от A,
[01:04:24.380 --> 01:04:27.380]  и поэтому я объектом типа A могу присваивать объект типа B.
[01:04:27.380 --> 01:04:31.380]  Если я использую протектор для приватного наследования, естественно я так делать не могу.
[01:04:31.380 --> 01:04:39.380]  Если я здесь заменю public на private, например, то вот этот код перестанет работать по понятным причинам.
[01:04:39.380 --> 01:04:43.380]  То есть я теперь не могу использовать тот факт, что у меня B является A.
[01:04:43.380 --> 01:04:46.380]  То есть я вместо B могу подставлять A.
[01:04:46.380 --> 01:04:57.380]  Но при этом внутри класса B я по-прежнему могу использовать срезку.
[01:04:57.380 --> 01:05:09.380]  Почему? Потому что если я унаследовался от A, если я унаследовался от A протектор образом,
[01:05:09.380 --> 01:05:15.380]  то это говорит о том, что я внешнему коду запретил использовать информацию о том, что я унаследован от A.
[01:05:15.380 --> 01:05:21.380]  Но при этом внутри структуры B или внутри класса B эту информацию я могу спокойно использовать.
[01:05:21.380 --> 01:05:25.380]  Поэтому здесь срезка внутри работает.
[01:05:25.380 --> 01:05:32.380]  Если я попробую то же самое сделать снаружи класса, то уже будет ошибка эмпиляции.
[01:05:37.380 --> 01:05:39.380]  Соответственно, внутри класса наследник я так могу делать.
[01:05:39.380 --> 01:05:45.380]  Ну и понятно делать, что если у меня есть какие-то друзья, то внутри друзей я тоже могу использовать факт наследования.
[01:05:45.380 --> 01:05:54.380]  Ну и теперь еще один пример.
[01:05:54.380 --> 01:05:58.380]  Что если мне не нравится, как мне работает срезка?
[01:05:58.380 --> 01:06:09.380]  Что если я хочу, чтобы у меня вот такая штука работала, но при этом я хочу, чтобы у меня копировалась не просто часть, которая относится к, а выполняют какие-то другие действия?
[01:06:09.380 --> 01:06:11.380]  Ну вот есть такое желание.
[01:06:11.380 --> 01:06:18.380]  То есть я хочу, чтобы у меня не тупо происходило копирование, а писала какая-то дополнительная информация на выход или что-то еще.
[01:06:18.380 --> 01:06:20.380]  Ну вот здесь такой пример.
[01:06:20.380 --> 01:06:23.380]  Ну смотрите, у меня есть поле name в классе A.
[01:06:23.380 --> 01:06:28.380]  И естественно, если я наследую B от A, то у меня в классе B тоже есть поле name.
[01:06:28.380 --> 01:06:36.380]  Но при этом я в классе A говорю, что name у меня равен A, потому что имя класса A это A.
[01:06:36.380 --> 01:06:39.380]  А в классе B говорю, что имя B это B.
[01:06:39.380 --> 01:06:41.380]  Нормально? Ну, кажется, нормально.
[01:06:41.380 --> 01:06:45.380]  Ну и теперь, когда я создаю объект типа A, у меня A.name выдает A.
[01:06:45.380 --> 01:06:48.380]  Если я создаю объект типа B, то B.name выдает B.
[01:06:48.380 --> 01:06:57.380]  Но теперь, если я попытаюсь создать объект типа A с помощью объекта типа B, то у меня произойдет срезка.
[01:06:57.380 --> 01:07:00.380]  То есть произойдет копирование, как здесь это выглядит.
[01:07:00.380 --> 01:07:04.380]  У меня есть класс B, в нем есть часть, которая относится к A, и в нем есть поле name.
[01:07:04.380 --> 01:07:06.380]  И есть просто класс A.
[01:07:06.380 --> 01:07:10.380]  Как происходит срезка? Ну просто вот эта часть берет и копируется вот сюда.
[01:07:10.380 --> 01:07:14.380]  Соответственно, в классе B у меня хранится информация о том, что имя это B.
[01:07:14.380 --> 01:07:19.380]  Когда я делаю срезку, то есть когда я копирую в A, у меня это имя тоже напросто целиком копируется.
[01:07:19.380 --> 01:07:20.380]  Понятно?
[01:07:20.380 --> 01:07:23.380]  Ну и теперь у меня класс A говорит, что у него имя это B.
[01:07:23.380 --> 01:07:31.380]  Но, наверное, хотелось бы, чтобы и в этом случае тоже класс A не отказывался от своей идентичности и тоже говорил, что у него имя это A.
[01:07:31.380 --> 01:07:35.380]  Как этого добиться? Ну очень просто.
[01:07:35.380 --> 01:07:41.380]  Вам достаточно просто взять и сказать, что вам достаточно просто создать конструктор от наследника.
[01:07:41.380 --> 01:07:51.380]  То есть вы в структуре A говорите, что вот если я пытаюсь создаться от наследника, в данном случае от класса B,
[01:07:51.380 --> 01:07:56.380]  то у меня должно быть какое-то особое поведение.
[01:07:56.380 --> 01:08:06.380]  Ну, например, в частности, я тут должен написать, что у меня name это A.
[01:08:06.380 --> 01:08:14.380]  Все, и теперь, когда я вызываю срезку, то есть когда я пытаюсь объект типа A создать с помощью объекта типа B,
[01:08:14.380 --> 01:08:17.380]  у меня вызывается не конструктор копирования.
[01:08:17.380 --> 01:08:19.380]  Смотрите, в чем идея.
[01:08:19.380 --> 01:08:23.380]  Теперь у меня внутри класса A есть конструктор копирования, естественным образом.
[01:08:23.380 --> 01:08:26.380]  const A&.
[01:08:26.380 --> 01:08:31.380]  И есть конструктор, который принимает B. A const B&.
[01:08:31.380 --> 01:08:37.380]  То есть раньше, когда у меня вот этого конструктора не было, у меня вызывался верхний конструктор, то есть просто конструктор копирования A. Понятно?
[01:08:37.380 --> 01:08:46.380]  Но теперь, когда я создал конструктор от наследника, то есть специальный конструктор, который принимает B, именно он будет выигрывать перегрузку.
[01:08:46.380 --> 01:08:52.380]  И вот теперь вот в этой строке, когда я попытаюсь выполнить срезку, то есть создать объект типа A с помощью объекта типа B,
[01:08:52.380 --> 01:08:58.380]  у меня будет вызываться именно вот этот конструктор.
[01:08:58.380 --> 01:09:07.380]  Соответственно, имя объекта A будет A, собственно, как я указывал в этом конструкторе.
[01:09:07.380 --> 01:09:15.380]  Все ясно?
[01:09:15.380 --> 01:09:20.380]  Да, ну и соответственно, аналогичным образом вы можете запретить срезку.
[01:09:20.380 --> 01:09:28.380]  Допустим, вам не нравится, что у вас происходят вот такие вот вещи, что у вас объекты производного класса могут приводиться к объектам базового класса.
[01:09:28.380 --> 01:09:34.380]  Ну, вообще говоря, непонятно, зачем вам это нужно, то есть если вы хотите это запретить, то просто используйте Protect или править наследование.
[01:09:34.380 --> 01:09:40.380]  Ну, допустим, вы хотите вот именно такое запретить, то есть именно создавать копии базового класса на основе производного вы не хотите.
[01:09:40.380 --> 01:09:49.380]  Но в этом случае вы тоже создаете там вот этот вот конструктор, который принимает объект типа B и пишете равно delete.
[01:09:49.380 --> 01:09:59.380]  Обычный трюк с удалением перегрузки функции.
[01:09:59.380 --> 01:10:10.380]  Так, еще один интересный пункт связан с затенением или замещением методов базового класса.
[01:10:10.380 --> 01:10:14.380]  В чем идея?
[01:10:14.380 --> 01:10:20.380]  Смотрите, есть класс A. Этот класс я унаследовал в классе B.
[01:10:20.380 --> 01:10:28.380]  И представьте себе, что у меня внутри структуры A или внутри класса A есть метод F, который принимает int.
[01:10:28.380 --> 01:10:35.380]  Ну и внутри класса B я тоже создал метод F, который принимает int.
[01:10:35.380 --> 01:10:46.380]  Соответственно, тот метод, который объявлен в базовом классе, печатает, что вызван метод A, а внутри класса B печатает, что вызван метод B.
[01:10:46.380 --> 01:10:54.380]  Теперь, если я создам объект типа B и попытаюсь вызвать B.F, то конфликта не будет. Это нормальная ситуация.
[01:10:54.380 --> 01:11:00.380]  То есть наследники вполне себе могут переопределать методы базового класса. Ну в данном случае это не переопределение, а замещение.
[01:11:00.380 --> 01:11:06.380]  То есть методы производного класса могут замещать метод базового класса.
[01:11:06.380 --> 01:11:10.380]  Все это нормально.
[01:11:10.380 --> 01:11:14.380]  Ну вот вопрос. Вроде, как тогда мы говорили про наследование, мы говорили следующую вещь.
[01:11:14.380 --> 01:11:20.380]  Если я что-то унаследовал от базового класса, то все это и все методы, все поля находятся в моем классе.
[01:11:20.380 --> 01:11:33.380]  что на самом деле внутри класса B вот этот метод тоже есть. Тоже там присутствует. Точнее компилятор понимает, что через класс B вот этот метод, который находится в A, тоже могу вызывать.
[01:11:33.380 --> 01:11:47.380]  Вопрос, как его вызвать? Ответ убил. Вот таким образом. То есть мне нужно использовать так называемое qualified ID или полное квалифицированное имя метода.
[01:11:47.380 --> 01:11:58.380]  То есть я пишу B. и дальше пишу, что мне нужен именно тот F, который находится в A и никакой иной. И вот теперь, если вызываю просто B.F, то вызывается F, который находится внутри B.
[01:11:58.380 --> 01:12:15.380]  Не, вот модификаторы доступа и перегрузка это вообще разные вещи. То есть модификаторы доступа и перегрузки не имеют никакого отношения.
[01:12:15.380 --> 01:12:26.380]  То есть если вы тут написали private, то при вызове первой строки у вас бы все равно вызывался метод B. Но так его вызвать нельзя, то у вас бы тут была ошибка в компиляции.
[01:12:26.380 --> 01:12:37.380]  То есть приватность публичность на перегрузку никак не влияет. То есть теперь, когда вы просто вызываете через точку F, то у вас вызывается тот метод, который находится в B.
[01:12:37.380 --> 01:12:50.380]  Потому что этот метод заместил метод, который находится в базовом классе. Но это более-менее кажется естественным, потому что если вы в производном классе как-то указали какое-то другое поведение, то наверное нужно использовать его более конкретное.
[01:12:50.380 --> 01:13:03.380]  Но если вы все-таки хотите использовать метод, который находится в базовом классе, то придется помучиться и использовать прям полное имя. То есть сказать B. и дальше то, что находится в классе A, и вызвать метод F.
[01:13:03.380 --> 01:13:17.380]  Второй пример, более странный. Если тут было более-менее все логично, то смотрите, у меня в базовом классе есть F от int, в производном классе есть F от int, ну и если я вызываю F от int, то вызывается метод производного класса.
[01:13:17.380 --> 01:13:27.380]  Просто произошло замещение, кажется все нормально. Странный пример вот такой. Есть у меня класс A, в нем есть метод F, который не принимает аргументов.
[01:13:28.380 --> 01:13:36.380]  Не принимает аргументов. Есть класс B, который унаследован от A и имеет свой метод F, который принимает один аргумент.
[01:13:36.380 --> 01:13:43.380]  Казалось бы, конфликта вообще никого нет. То есть есть метод F, не принимает аргументов, есть метод F, но он принимает аргументы.
[01:13:43.380 --> 01:13:53.380]  Но при этом возникает странная ситуация. Если я попытаюсь вызвать метод F от 0, то все нормально. В классе B действительно есть такой метод, все хорошо.
[01:13:53.380 --> 01:13:58.380]  А если я попытаюсь вызвать метод B.F, то возникнет внезапно какой-то ошибка компиляции.
[01:13:58.380 --> 01:14:03.380]  И мне компилятор скажет, что внутри класса B нет метода F. Что произошло?
[01:14:03.380 --> 01:14:13.380]  Мы же буквально, если отмотать все слайды в самое начало, мы же спокойно вызывали методы базовых классов, они все работали и так далее.
[01:14:13.380 --> 01:14:18.380]  А здесь все перестало работать. Почему?
[01:14:18.380 --> 01:14:24.380]  Потому что по правилам C++ замещение работает довольно странным образом.
[01:14:24.380 --> 01:14:36.380]  Считается, что когда вы объявляете метод с каким-то именем, то все остальные методы с таким же именем в базовом классе не просто-напросто вымещаются.
[01:14:36.380 --> 01:14:53.380]  Если у вас есть в классе A F с пустыми скобками, F от NTA, F от Boolean, а в классе B есть только метод F от NTA, то считается, что все эти методы полностью замещаются вот этим методом.
[01:14:53.380 --> 01:14:58.380]  Что?
[01:14:58.380 --> 01:15:03.380]  Да, похоже на конструкторы.
[01:15:03.380 --> 01:15:09.380]  Тем не менее, не совсем.
[01:15:09.380 --> 01:15:17.380]  Неважно, написали вы в базовом классе конструктор или нет, у вас все равно конструкторы базовых классов не вызываются просто так. Вам нужно писать using и так далее.
[01:15:17.380 --> 01:15:24.380]  А здесь у вас такая проблема возникает, если вы написали внутри B функцию с тем же именем, что и в базовом классе.
[01:15:24.380 --> 01:15:29.380]  Это можно обосновать примерно следующим образом.
[01:15:29.380 --> 01:15:41.380]  Если вы в классе B задали какое-то действие F, то, наверное, вы хотите, чтобы для производного класса выполнялось только это действие, и никаких других.
[01:15:41.380 --> 01:15:47.380]  Скажем, для класса A можно выполнять действие F без аргументов, можно выполнять с одним аргументом, можно выполнять с другим аргументом.
[01:15:47.380 --> 01:15:59.380]  А если вы для производного класса задали такое же действие, но с каким-то другим аргументом, то разработчики языка предполагают, что вы хотите использовать только это действие, никаких других.
[01:15:59.380 --> 01:16:06.380]  Проблема ясна? Хорошо.
[01:16:06.380 --> 01:16:13.380]  Как ее побороть? Проблема называется shadowing, затенение методов.
[01:16:13.380 --> 01:16:20.380]  Если вы ввели какой-то метод с таким же именем, что и в базовом классе, то все методы, которые есть в базовом классе, они игнорируются.
[01:16:20.380 --> 01:16:28.380]  Логично ли это? Я сам проговорил. С одной стороны кажется, что это какая-то ерунда, с другой стороны, наверное, какая-то логика в этом все-таки есть.
[01:16:28.380 --> 01:16:38.380]  Но при этом вы по-прежнему можете вызывать методы A, даже если они затенены, вы их можете вызывать с помощью полного квалифицированного имени.
[01:16:38.380 --> 01:16:47.380]  Как бороться с этой проблемой? Есть несколько вариантов. Первый вариант – просто нам смириться и ничего с этим не делать.
[01:16:47.380 --> 01:16:55.380]  Есть второй вариант – заставлять пользователя всегда вызывать полное имя метода.
[01:16:55.380 --> 01:17:01.380]  Если какие-то методы затенены, то вызывайте его через полное имя.
[01:17:01.380 --> 01:17:14.380]  Есть третий вариант. Если вы все-таки хотите, чтобы методы вышли из сумрака, вы можете использовать директиву using.
[01:17:14.380 --> 01:17:24.380]  В данном случае это работает так. У меня в структуре A есть метод f, который принимает ничего, есть метод f, который принимает double,
[01:17:24.380 --> 01:17:31.380]  и внутри B у меня есть метод, который принимает int. Этот метод затеняет все остальные, то есть все остальные просто так вызваны не будут.
[01:17:31.380 --> 01:17:42.380]  Но если вы написали директиву using, using a.f, то это говорит о том, что все методы, которые есть внутри класса A, должны быть включены и в класс B, то есть они не должны быть затенены.
[01:17:42.380 --> 01:17:54.380]  Да, была бы CE. То есть вы пытаетесь в класс B внести функцию с такой же сигнатурой, что и в B.
[01:17:54.380 --> 01:18:04.380]  Вопрос был в том, что если тут f от int, то тут было бы CE. Если у вас есть функция f с таким же прототипом, то это не работает.
[01:18:04.380 --> 01:18:14.380]  Важный момент, что по отдельности функции вносить нельзя. То есть вы вносите либо все, либо вообще никакие.
[01:18:14.380 --> 01:18:24.380]  Вот. Не получится.
[01:18:24.380 --> 01:18:34.380]  Что еще раз? А, ну а тут, кстати, имеет значение, где писать using, то есть в публичной или приватной области.
[01:18:34.380 --> 01:18:40.380]  То есть если вы хотите, чтобы эти затененные методы стали публичными, вы их пишете в публичной области. Если нет, то в приватной.
[01:18:40.380 --> 01:18:58.380]  Нет, нет, нет. Тут такое правило действует. То есть когда вы написали вот так, вы просто говорите, что класс B может использовать...
[01:18:58.380 --> 01:19:04.380]  Ну, кстати, по поводу правила public, может я наврал. То есть я не уверен. Короче говоря, приватные поля таким образом публичными стать не могут.
[01:19:04.380 --> 01:19:14.380]  То есть вы просто говорите, что... таким образом вы просто говорите, что вы избавляетесь от, как это называется, от недопонимания.
[01:19:14.380 --> 01:19:22.380]  То есть вы просто говорите, что если какой-то метод затенен, то нужно еще принимать во внимание методы, которые объявлены в A, и все.
[01:19:22.380 --> 01:19:30.380]  Поэтому тут спокойно вы можете вызвать f от нуля, f с пустыми скопами, f от добла. Все нормально.
[01:19:30.380 --> 01:19:42.380]  Так, есть вопросы? Все, давайте последний пункт. Работа с производным классом через указатель или ссылку на базу.
[01:19:42.380 --> 01:19:53.380]  Ну, это мы частично уже проговорили. Давайте еще раз уже конкретно проговорим, что если у вас есть класс B, который наследован от A публичным образом,
[01:19:53.380 --> 01:20:05.380]  то теперь вы помимо того, что можете осуществлять срезку, так еще и можете создавать указатели или ссылки на базовый класс, но при этом связываться с производным классом.
[01:20:05.380 --> 01:20:18.380]  То есть в данном случае у меня есть объект типа B, и я могу создать указатель, который является... тип которого это указатель на A, но при этом на самом деле он будет указывать на B.
[01:20:18.380 --> 01:20:27.380]  То есть почему это возможно? Ну, снова, надо вспоминать вот такую картинку. У меня есть класс B, у меня есть часть, которая относится к A. Вот, есть что-то еще.
[01:20:27.380 --> 01:20:33.380]  И у меня класс A, точнее часть, которая находится к классу A, находится в самом начале объекта типа B.
[01:20:33.380 --> 01:20:44.380]  И поэтому если я создаю указатель, точнее беру адрес B, то на самом деле вот этот указатель он будет указывать как на начало B, так и начало A внутри класса B.
[01:20:44.380 --> 01:20:54.380]  То же самое касается и ссылок. То есть я могу спокойно оставать ссылку на базовый класс и при этом связывать ее с производным классом.
[01:20:54.380 --> 01:21:09.380]  Наоборот, естественно, нельзя... вот такое запрещено. Естественно, я не могу указывать на производный класс, но при этом притворяться, что я на самом деле указываю на базовый класс.
[01:21:09.380 --> 01:21:21.380]  В чем отличие срезки и указателей и ссылок? В случае срезки мы получаем, когда мы делаем срезку, мы получаем полностью независимую копию того же самого объекта,
[01:21:21.380 --> 01:21:33.380]  точнее той части объекта, которая находится в классе B. То есть мы на самом деле создаем объект типа A, ну и просто копируем часть, которая относится к A из класса B.
[01:21:33.380 --> 01:21:46.380]  Когда мы работаем через указатели или ссылку, то мы получаем полностью независимую копию того же самого объекта, точнее той части объекта, которая находится в классе B.
[01:21:46.380 --> 01:21:56.380]  Когда мы работаем через указатели или ссылку, ну вот здесь, прямо через ссылку, то есть мы создаем ссылку на A, но при этом инициализируем ее ссылкой на B.
[01:21:56.380 --> 01:22:04.380]  Здесь мы на самом деле работаем именно с объектом типа B.
[01:22:04.380 --> 01:22:14.380]  То есть вот у меня снова есть объект B, есть часть, которая относится к A, и я создаю ссылку как будто бы вот на эту часть.
[01:22:14.380 --> 01:22:24.380]  Вот эта ссылка ссылается вот именно на эту область. И когда я работаю через эту ссылку, я на самом деле работаю вот с конкретной внутренней частью объекта B.
[01:22:24.380 --> 01:22:28.380]  Никакой копии у меня не создается. Понятно?
[01:22:28.380 --> 01:22:36.380]  Окей. Ну и, соответственно, вопрос такой, смотрите.
[01:22:36.380 --> 01:22:51.380]  Точнее не вопрос, а замечание просто такое, что несмотря на то, что у меня есть указатель, точнее ссылка на класс B, я через эту ссылку не могу обращаться к полям или методам производного класса.
[01:22:51.380 --> 01:22:58.380]  То есть, смотрите, у меня есть ссылка BREF. Давайте ее назовем BREF.
[01:22:58.380 --> 01:23:04.380]  Вот в данном примере у меня есть ссылка BREF, которую я проинициализировал объектом B.
[01:23:04.380 --> 01:23:10.380]  Но при этом еще раз повторю, что я на самом деле ссылаюсь только на какую-то часть объекта B, то есть вот на конкретную внутреннюю часть.
[01:23:10.380 --> 01:23:19.380]  И поэтому естественным образом обращаться к полям самого класса B, но вот сейчас вот тут играет, вот к этому полю, через вот эту ссылку я обращаться не могу.
[01:23:19.380 --> 01:23:26.380]  И дело даже не в том, что я ссылаюсь в какую-то маленькую область памяти. Тут проблема на самом деле в том, что компилятор этого сам никак не может проверить.
[01:23:26.380 --> 01:23:38.380]  Но представьте себе, что компилятор встречает вот эту строку. BREF.Y. Какой тип у BREF? У BREF тип ссылка на A.
[01:23:38.380 --> 01:23:48.380]  А какие методы и поля я могу вызывать у A? Все они перечислены вот здесь. Никакого Y там нет. Поэтому к нему я обращаться, естественно, не могу.
[01:23:48.380 --> 01:23:57.380]  Понятно? Несмотря на то, что я могу создавать ссылки на базовый класс и инициализировать их производным классом,
[01:23:57.380 --> 01:24:04.380]  использовать поля и методы производного класса я таким образом никак не могу. Потому что это проверяется все на этапе компиляции.
[01:24:04.380 --> 01:24:10.380]  На этапе компиляции компилятор видит, что это ссылка на базовый класс, и поэтому я могу обращаться только к полям и методам базового класса.
[01:24:11.380 --> 01:24:15.380]  То есть только к вот этой части. Все понятно?
[01:24:19.380 --> 01:24:28.380]  Ну и последний пример. Такая небольшая затравка на следующую неделю, на следующую лекцию.
[01:24:28.380 --> 01:24:34.380]  В общем, смотрите. Представьте себе, что у меня и в структуре A, и в структуре B есть метод F.
[01:24:35.380 --> 01:24:41.380]  То есть в структуре A я объявляю метод F каким-то таким образом, то есть он просто уводит A.F.
[01:24:41.380 --> 01:24:45.380]  А внутри структура B я объявляю точно такой же метод, который уводит B.F.
[01:24:45.380 --> 01:24:52.380]  И при этом я создаю объект типа B и создаю указатель на A, но на самом деле он указывает на объект типа B.
[01:24:52.380 --> 01:25:00.380]  И через стрелку вызываю B.F. Вот в этом случае у меня тоже будет вызываться метод, который относится к A.
[01:25:00.380 --> 01:25:03.380]  И никаких проблем с затенением и так далее не будет. Понятно почему?
[01:25:03.380 --> 01:25:09.380]  Ну снова, что здесь происходит? Давайте отдельно рассмотрим вот эту строку. Bptr, стрелка F.
[01:25:09.380 --> 01:25:15.380]  Компилятор чисто формально смотрит на следующую вещь. Какой тип имеет Bptr?
[01:25:15.380 --> 01:25:23.380]  Bptr имеет тип A со звездой. То есть для компилятора этот указатель указывает на A.
[01:25:23.380 --> 01:25:26.380]  Ну все, и дальше он вызывается через стрелку F.
[01:25:26.380 --> 01:25:30.380]  Есть ли у меня метод F в классе A? Смотрит. Да, он есть.
[01:25:30.380 --> 01:25:34.380]  Ну и соответственно именно этот метод и вызывается. Понятно?
[01:25:34.380 --> 01:25:38.380]  Ну вот на самом деле такого поведения хочется не всегда.
[01:25:38.380 --> 01:25:41.380]  Ну все-таки, наверное, хотелось бы делать следующую вещь.
[01:25:41.380 --> 01:25:48.380]  Что если у вас есть указатель A со звездой, который указывает на самом деле на объект типа B,
[01:25:48.380 --> 01:25:54.380]  возможно хотелось бы, чтобы метод F вызывался именно на объекта типа B, а не типа A.
[01:25:54.380 --> 01:25:57.380]  Ну естественное желание. Ну я же на самом деле указываю на B, а не на A.
[01:25:57.380 --> 01:26:01.380]  Поэтому, наверное, хочется вызывать метод именно для B.
[01:26:01.380 --> 01:26:04.380]  И вот именно этим мы займемся на следующей неделе.
[01:26:04.380 --> 01:26:08.380]  А пока вот проблема, которую мы подвесили в воздухе.
[01:26:08.380 --> 01:26:13.380]  Хорошо? В следующий раз мы с этим разберемся.
[01:26:13.380 --> 01:26:18.380]  Ну и соответственно на этом первая часть пронаследования подошла к концу.
[01:26:18.380 --> 01:26:22.380]  Соответственно, да, мы поговорили, что наследование позволяет задавать связь между классами
[01:26:22.380 --> 01:26:26.380]  и способствует постороннему использованию кода, то есть мы избавляемся от дублирования кода.
[01:26:26.380 --> 01:26:30.380]  Значит, паблик реализует отношения, является, проекты и private содержат.
[01:26:30.380 --> 01:26:34.380]  Имена в производном классе могут затенять соответствующие имена в базовом классе.
[01:26:34.380 --> 01:26:38.380]  Ну это затенение, которое мы говорили, что если вы заводите метод с таким же именем,
[01:26:38.380 --> 01:26:42.380]  что и в базовом классе, то у вас методы базового класса могут быть вызваны с трудом.
[01:26:42.380 --> 01:26:46.380]  Вот. Значит, поговорили про срезку, ну и поговорили про то,
[01:26:46.380 --> 01:26:49.380]  как работать с производными классами через ссылку или указатель на базовый класс.
[01:26:50.380 --> 01:26:53.380]  Ну пока правило очень простое. Если у вас есть ссылка или указатель на базовый класс,
[01:26:53.380 --> 01:26:56.380]  который на самом деле указывает или ссылается на производный класс,
[01:26:56.380 --> 01:27:00.380]  то вы имеете право вызывать только методы и поля базового класса.
[01:27:00.380 --> 01:27:03.380]  Производного класса вам недоступны.
[01:27:03.380 --> 01:27:06.380]  Но в следующий раз мы попробуем немного побороть эту проблему и попробуем понять,
[01:27:06.380 --> 01:27:10.380]  как через ссылку или указатель вызывать именно методы того класса, который там лежит.
[01:27:10.380 --> 01:27:13.380]  Так, на этом наследование все.
[01:27:13.380 --> 01:27:17.380]  И предлагаю перейти к первой лекции по алгоритмам,
[01:27:17.380 --> 01:27:22.380]  а именно вычислительной геометрии на плоскости.
[01:27:40.380 --> 01:27:43.380]  Ну почему именно она?
[01:27:43.380 --> 01:27:52.380]  Потому что, во-первых, тут существует довольно естественная, скажем,
[01:27:52.380 --> 01:27:56.380]  естественная связь с наследованием, и вы ее прочувствуете, когда будете решать второе здание.
[01:27:56.380 --> 01:27:59.380]  В общем, там вполне естественно возникает некоторая иерархия фигур.
[01:27:59.380 --> 01:28:03.380]  То есть можно создавать базовый класс фигуры и от него наследовать другие и так далее.
[01:28:03.380 --> 01:28:07.380]  Но во-вторых, довольно часто в приложениях возникают всякие задачи,
[01:28:07.380 --> 01:28:12.380]  которые связаны с геометрией, причем это даже не связано с какой-то компьютерной графикой и так далее.
[01:28:12.380 --> 01:28:16.380]  Но довольно часто вам приходится моделировать какие-то пространственные объекты,
[01:28:16.380 --> 01:28:19.380]  и было бы неплохо научиться этим всем пользоваться.
[01:28:19.380 --> 01:28:22.380]  Естественно, можно использовать аналитический аппарат, который вы наверняка проходите
[01:28:22.380 --> 01:28:25.380]  на курсе линейной алгебры или аналитической геометрии.
[01:28:25.380 --> 01:28:29.380]  Но проблема в том, что этот аппарат, который вы используете, он использует, скажем,
[01:28:29.380 --> 01:28:32.380]  действительные числа, то есть некоторую непрерывность.
[01:28:32.380 --> 01:28:36.380]  А в компьютерах у нас все представляется все-таки в виде некоторых дискретных структур и так далее.
[01:28:36.380 --> 01:28:41.380]  Но в частности, нельзя точно задать длину окружности.
[01:28:41.380 --> 01:28:45.380]  То есть у вас все равно, если вы хотите, например, определить, пересекаются две прямые или нет,
[01:28:45.380 --> 01:28:49.380]  то в зависимости от того, насколько точную арифметику вы используете,
[01:28:49.380 --> 01:28:52.380]  насколько у вас велика погрешность или нет, у вас могут получиться абсолютно два разных ответа,
[01:28:52.380 --> 01:28:55.380]  причем для параллельных прямых.
[01:28:55.380 --> 01:29:00.380]  Погрешность, она им играет роль, например, в частности определения пересекаются две прямые или нет.
[01:29:00.380 --> 01:29:03.380]  То есть они могут лежать под таким небольшим углом,
[01:29:03.380 --> 01:29:07.380]  что, скажем, точность компьютера может не позволить это сделать.
[01:29:07.380 --> 01:29:11.380]  Поэтому будем рассматривать так называемую точную арифметику,
[01:29:11.380 --> 01:29:16.380]  а именно попробуем понять, какие алгоритмы существуют в ситуации,
[01:29:16.380 --> 01:29:19.380]  когда все точки у нас задаются целочислыми координатами.
[01:29:19.380 --> 01:29:24.380]  Вот оказывается, если у вас есть, оказывается, что если вы работаете с геометрией,
[01:29:24.380 --> 01:29:29.380]  в которой все точки, там, точки, вершины, вершины многоугольников,
[01:29:29.380 --> 01:29:33.380]  концы, отрезков и так далее, представляют у себя целые числа,
[01:29:33.380 --> 01:29:37.380]  то в этом случае оказывается, что возможно построить точные алгоритмы,
[01:29:37.380 --> 01:29:41.380]  которые со 100% точки стоят вам ответ, пересекаются прямые или нет, пересекаются отрезки или нет.
[01:29:41.380 --> 01:29:44.380]  И вот давайте про них поговорим.
[01:29:44.380 --> 01:29:53.380]  Простые примитивы, которые будем использовать, это примитив-точка,
[01:29:53.380 --> 01:29:58.380]  которая будет представлять у себя координаты целочисленные.
[01:29:58.380 --> 01:30:02.380]  Ну и второй примитив, это естественный вектор,
[01:30:02.380 --> 01:30:09.380]  который тоже представляет у себя набор из двух целочисленных координат.
[01:30:09.380 --> 01:30:18.380]  Ну, соответственно, вот таким образом.
[01:30:18.380 --> 01:30:23.380]  Ну и здесь надо вспомнить немного фактов про вектора, которые нам понадобятся.
[01:30:23.380 --> 01:30:28.380]  Ну вот, в частности, давайте введем понятие ориентированного угла
[01:30:28.380 --> 01:30:35.380]  между векторами A и B.
[01:30:35.380 --> 01:30:43.380]  Ну, ориентированным углом между векторами A и B называется угол,
[01:30:43.380 --> 01:30:49.380]  величина которого совпадает, собственно, с величиной угла, образованной этими двумя векторами.
[01:30:49.380 --> 01:30:55.380]  И мы считаем, что phi положителен, если поворот от A к B осуществляется
[01:30:55.380 --> 01:31:02.380]  против часовой стрелки и отрицательным, если по часовой.
[01:31:02.380 --> 01:31:08.380]  То есть, в данном случае у меня есть вектор,
[01:31:09.380 --> 01:31:17.380]  то есть в данном случае у меня величина угла между A и B больше нуля,
[01:31:17.380 --> 01:31:27.380]  а величина угла между A и B, ой, наоборот, между B и A меньше нуля.
[01:31:27.380 --> 01:31:33.380]  То есть, есть разница, угол между каким, то есть,
[01:31:33.380 --> 01:31:39.380]  играет роль порядок векторов, когда я ее считаю, вычисляю угол, то есть A к B или B к A.
[01:31:39.380 --> 01:31:44.380]  Ну, для чего нужны ориентированные углы, чем они помогают, почему нельзя просто использовать модуль и так далее.
[01:31:44.380 --> 01:31:48.380]  Ну, во-первых, в большинстве приложений, как мы увидим, нам будет важно, по какую сторону, например,
[01:31:48.380 --> 01:31:53.380]  от вектора A находится вектор B или, наоборот, от вектора A относительно вектора B и так далее.
[01:31:53.380 --> 01:31:58.380]  Ну, во-вторых, в качестве небольшого применения давайте я расскажу вот такую штуку.
[01:31:58.380 --> 01:32:03.380]  Вот представьте себе, что вам даны какие-то произвольные три вектора A, B, C.
[01:32:03.380 --> 01:32:10.380]  И вам даны величины углов между A и B, и B и C.
[01:32:10.380 --> 01:32:15.380]  Вопрос, как найти величину угла между векторами A и C?
[01:32:15.380 --> 01:32:23.380]  Ну, вообще говоря, если бы мы не использовали понятие ориентированного угла,
[01:32:23.380 --> 01:32:27.380]  то тут бы нужно было рассматривать кучу вариантов.
[01:32:27.380 --> 01:32:30.380]  То есть, как у меня расположены вектора A, B, C между собой?
[01:32:30.380 --> 01:32:34.380]  Возможно, такая ситуация. Тогда мне нужно просто-напросто A, B и C сложить.
[01:32:34.380 --> 01:32:37.380]  Возможно, такая ситуация.
[01:32:37.380 --> 01:32:39.380]  Тогда что мне надо было сделать?
[01:32:39.380 --> 01:32:44.380]  Мне нужно было взять вектор A, B и вычесть из него вектор C, B и так далее.
[01:32:44.380 --> 01:32:46.380]  Вот рассматривать в случае мне очень не хочется.
[01:32:46.380 --> 01:32:49.380]  Вот в этом смысле мне очень помогают ориентированные углы.
[01:32:49.380 --> 01:32:53.380]  Потому что в случае использования ориентированных углов
[01:32:53.380 --> 01:32:55.380]  мне достаточно написать следующую вещь.
[01:32:55.380 --> 01:33:02.380]  Угол между A и C – это просто угол между A и B плюс угол B и C.
[01:33:02.380 --> 01:33:04.380]  Ну, почему это так?
[01:33:04.380 --> 01:33:07.380]  Ну, потому что... Снова давайте...
[01:33:07.380 --> 01:33:10.380]  Вот тут A, C, B.
[01:33:10.380 --> 01:33:16.380]  Если я хочу найти угол между A и C, вот такой, то что у меня получается?
[01:33:16.380 --> 01:33:20.380]  Я смотрю, какой у меня угол между A и B. Вот он.
[01:33:20.380 --> 01:33:24.380]  И потом прибавляю угол B и C. Вот он.
[01:33:24.380 --> 01:33:27.380]  Так у меня углы ориентированы, то есть вот этот угол будет идти с отрицательным знаком,
[01:33:27.380 --> 01:33:29.380]  а этот угол – с положительным знаком,
[01:33:29.380 --> 01:33:32.380]  то в итоге я получу величину угла между A и C, при этом тоже со знаком.
[01:33:32.380 --> 01:33:35.380]  Тоже он будет отрицательным.
[01:33:35.380 --> 01:33:38.380]  Единственный момент, который тут не учитывается этим сложением,
[01:33:38.380 --> 01:33:41.380]  что на самом деле у вас может быть такая ситуация,
[01:33:42.380 --> 01:33:46.380]  углы могут быть достаточно большими.
[01:33:46.380 --> 01:33:49.380]  Скажем, угол A, B может быть таким,
[01:33:49.380 --> 01:33:52.380]  и угол между B и C тоже может быть достаточно большим.
[01:33:52.380 --> 01:33:55.380]  В этом случае, когда вы складываете большие углы,
[01:33:55.380 --> 01:33:59.380]  у вас происходит такой вот, грубо говоря, переход через угол π,
[01:33:59.380 --> 01:34:04.380]  поэтому тут дополнительно еще нужно добавить плюс-минус 2π.
[01:34:04.380 --> 01:34:09.380]  Ну, в зависимости от того, пересекли ли вы черту в π или минус π.
[01:34:09.380 --> 01:34:14.380]  Окей? Вот это первое применение.
[01:34:14.380 --> 01:34:20.380]  Теперь давайте вспомним про такие вещи, как скалярные векторные произведения.
[01:34:20.380 --> 01:34:23.380]  Коротко. Надеюсь, все помнят.
[01:34:34.380 --> 01:34:36.380]  Все помнят вот такую вещь.
[01:34:36.380 --> 01:34:40.380]  Значит, для чего нам будет интересно скалярное произведение?
[01:34:40.380 --> 01:34:43.380]  Скалярное произведение, как правило, позволяет узнать...
[01:34:43.380 --> 01:34:47.380]  Здесь, во-первых, мы видим, что с ориентированным углом все нормально.
[01:34:47.380 --> 01:34:50.380]  То есть неважно, вы считаете в положительном направлении, в витератлом направлении,
[01:34:50.380 --> 01:34:55.380]  у нас с Косинус функция четная, поэтому Косинус у вас всегда будет нормально.
[01:34:55.380 --> 01:34:59.380]  Ну, значит, Косинус, как правило, используется для выяснения,
[01:34:59.380 --> 01:35:03.380]  находятся ли, так скажем, концы векторов A и B
[01:35:03.380 --> 01:35:08.380]  в одной полуплоскости относительно некоторой пербитикулярной или нет.
[01:35:08.380 --> 01:35:12.380]  В данном случае у вас скалярное произведение меньше нуля.
[01:35:12.380 --> 01:35:14.380]  Понятно?
[01:35:14.380 --> 01:35:16.380]  В случае, если они у вас...
[01:35:16.380 --> 01:35:19.380]  Давайте условно будем говорить, что если они сонаправлены,
[01:35:19.380 --> 01:35:23.380]  то есть грубо говоря, смотрят в одну и ту же плоскость относительно некоторой прямой,
[01:35:23.380 --> 01:35:26.380]  то будем говорить, что скалярное произведение положительное.
[01:35:26.380 --> 01:35:28.380]  Но это просто следует и свойств.
[01:35:28.380 --> 01:35:32.380]  И причем, заметьте, сразу же замечаю, что у нас координаты все целочисленные,
[01:35:32.380 --> 01:35:36.380]  то и скалярное произведение тоже вычисляется абсолютно точно.
[01:35:36.380 --> 01:35:38.380]  Скалярное произведение двух векторов,
[01:35:38.380 --> 01:35:53.380]  которые имеют целочислые координаты,
[01:35:53.380 --> 01:35:58.380]  Поэтому скалярное произведение мы можем высчитать абсолютно точно.
[01:36:05.380 --> 01:36:11.380]  Ну и еще одно произведение, это векторное произведение A и B.
[01:36:11.380 --> 01:36:14.380]  Ну вот смотрите, как мы знаем, векторное произведение двух векторов это что?
[01:36:14.380 --> 01:36:20.380]  Это тоже вектор, причем который лежит в каком-то дополнительном измерении.
[01:36:20.380 --> 01:36:24.380]  То есть на плоскости этот результат произведения двух векторов не укладывается.
[01:36:24.380 --> 01:36:27.380]  Поэтому будем говорить, что нас будет интересовать не именно векторное произведение,
[01:36:27.380 --> 01:36:32.380]  а его проекция на некоторую мнимую ось Z, которая у нас не явно присутствует.
[01:36:32.380 --> 01:36:36.380]  Ну грубо говоря, просто будем интересоваться величиной этого самого векторного произведения,
[01:36:36.380 --> 01:36:38.380]  ну или проекции на ось Z.
[01:36:38.380 --> 01:36:49.380]  Начну, напомню, способ вычисления.
[01:36:51.380 --> 01:36:58.380]  Вот, если мы возьмем проекцию на ось Z, то мы получим следующую величину.
[01:36:58.380 --> 01:37:03.380]  AX BY минус AY BX.
[01:37:03.380 --> 01:37:07.380]  Снова, векторное произведение это тоже целое число.
[01:37:07.380 --> 01:37:10.380]  Мы все вычисляем, то есть у нас все координаты целые,
[01:37:10.380 --> 01:37:15.380]  и векторное произведение, ровно как и скалярное произведение, у нас представляет в себе целое число.
[01:37:15.380 --> 01:37:20.380]  Ну, актернативно, запись представляет в себе следующую вещь.
[01:37:20.380 --> 01:37:24.380]  Модуль A, модуль B на синус phi.
[01:37:24.380 --> 01:37:30.380]  И вот отсюда уже на самом деле видно применение векторного произведения.
[01:37:30.380 --> 01:37:34.380]  Смотрите, мы говорили про ориентированный угол.
[01:37:34.380 --> 01:37:39.380]  И вот я уже подрисовала, в каком порядке у нас следующие два вектора.
[01:37:39.380 --> 01:37:42.380]  Либо от а к b, либо от b к a.
[01:37:42.380 --> 01:37:45.380]  В одном случае у нас угол положительный, в другом – отрицательный.
[01:37:45.380 --> 01:37:48.380]  И вот здесь мы можем спокойно проверить,
[01:37:48.380 --> 01:37:53.380]  какой угол между двумя векторами у нас есть, положительный или отрицательный.
[01:37:53.380 --> 01:37:59.380]  В случае, если угол между векторами a и bi положительный, то векторное произведение больше 0.
[01:37:59.380 --> 01:38:01.380]  Если угол отрицательный, то, естественно,
[01:38:01.380 --> 01:38:08.380]  Поэтому основное применение вектором произведения это как раз-таки понять величину угла, то есть положительная или отрицательная.
[01:38:08.380 --> 01:38:13.380]  Грубо говоря, правый поворот вас образует, а вас образуют эти два вектора, или отрицательный поворот, то есть левый поворот.
[01:38:13.380 --> 01:38:17.380]  Окей?
[01:38:17.380 --> 01:38:25.380]  Так, ну давайте, значит, сложение ориентированных углов, это у нас была первая задача.
[01:38:26.380 --> 01:38:33.380]  Ну и давайте перейдем ко второй задаче, которую можно решать абсолютно точно.
[01:38:33.380 --> 01:38:46.380]  Значит, внезапно эта задача – поиск площади двухугольника.
[01:38:46.380 --> 01:38:55.380]  Значит, давайте завязываем следующую вещь, точнее, ведем такое понятие, как ориентированная площадь.
[01:38:55.380 --> 01:39:06.380]  Значит, ориентированная площадь параллелограмма.
[01:39:06.380 --> 01:39:24.380]  Значит, пусть у меня есть два вектора, ну я дострою на этих сторонах, то есть я буду использовать эти векторы как стороны для некоторого параллелограмма.
[01:39:24.380 --> 01:39:39.380]  Видно, что ориентированную площадь параллелограмма можно вычислить просто как векторное произведение векторов A и B.
[01:39:39.380 --> 01:39:46.380]  Ну, собственно, это и есть определение, что параллелограмм, построенный на векторах A и B, его ориентированную площадью будем называть величину векторного произведения.
[01:39:46.380 --> 01:39:55.380]  То есть, грубо говоря, если у меня вектор A и вектор B будут образовывать правый поворот, то величина площади положительна.
[01:39:55.380 --> 01:40:00.380]  Если левый поворот, то величина площади отрицательна.
[01:40:00.380 --> 01:40:06.380]  Как нам поможет при вычислении площади произвольного многоугольника?
[01:40:07.380 --> 01:40:18.380]  Ну, смотрите, идея такая. На самом деле, идея очень похожа на вычисление угла между двумя векторами.
[01:40:18.380 --> 01:40:21.380]  Пусть мне дан абсолютно произвольный многоугольник.
[01:40:21.380 --> 01:40:26.380]  Опять же, есть специальные алгоритмы, которые работают для выпуклых многоугольников, ну там, примерно все просто и так далее.
[01:40:26.380 --> 01:40:32.380]  Вот мы работаем вообще в произвольном случае, мне дан вообще произвольный многоугольник, не важно выпуклый, не выпуклый, выраженный, не выраженный.
[01:40:32.380 --> 01:40:37.380]  Давайте как-нибудь, давайте побольше.
[01:40:41.380 --> 01:40:43.380]  Абсолютно произвольный многоугольник.
[01:40:44.380 --> 01:40:46.380]  Как вычислить его площадь?
[01:40:46.380 --> 01:40:48.380]  Значит, делается это следующим образом.
[01:40:48.380 --> 01:40:50.380]  Ну, один из возможных вариантов.
[01:40:50.380 --> 01:40:52.380]  Давайте возьму произвольную точку.
[01:40:52.380 --> 01:40:54.380]  Ну, допустим, это будет точка 0,0.
[01:40:55.380 --> 01:41:01.380]  И из этой точки я проведу векторы.
[01:41:09.380 --> 01:41:13.380]  Я проведу векторы в вершины моего многоугольника.
[01:41:20.380 --> 01:41:22.380]  Что я буду делать?
[01:41:22.380 --> 01:41:29.380]  Давайте я буду последовательно проходить, ну пусть это вектор P1, точнее P0, P1, это P2 и так далее.
[01:41:29.380 --> 01:41:33.380]  Ну, в общем, занумеру их в порядке следования вдоль многоугольника.
[01:41:33.380 --> 01:41:36.380]  Ну и давайте я просто-напросто возьму и сделаю следующую вещь.
[01:41:36.380 --> 01:41:42.380]  Я посчитаю площади всех треугольников, которые образованы последовательными векторами.
[01:41:45.380 --> 01:41:47.380]  То есть в частности я сделаю следующую вещь.
[01:41:47.380 --> 01:41:50.380]  Я посчитаю векторное произведение P0 на P1.
[01:41:52.380 --> 01:41:56.380]  P1 на P2 и так далее.
[01:41:56.380 --> 01:42:02.380]  Pn-2, точнее так Pn-1, P0.
[01:42:05.380 --> 01:42:07.380]  И пополам.
[01:42:07.380 --> 01:42:09.380]  Ну понятно, да?
[01:42:09.380 --> 01:42:14.380]  То есть когда я беру векторное произведение двух векторов, я вычисляю площадь параллограмма.
[01:42:14.380 --> 01:42:17.380]  Чтобы получить площадь треугольника, я делю на 2.
[01:42:17.380 --> 01:42:19.380]  Вот.
[01:42:19.380 --> 01:42:21.380]  И делю пополам.
[01:42:21.380 --> 01:42:25.380]  И в итоге я утверждаю, что я в итоге получу площадь моего многоугольника.
[01:42:25.380 --> 01:42:27.380]  Ну почему это так?
[01:42:27.380 --> 01:42:29.380]  Значит, история такая.
[01:42:31.380 --> 01:42:33.380]  Ну видно, что когда я беру...
[01:42:36.380 --> 01:42:45.380]  Да, видно, что когда я беру произведение от P0 на P1, дальше от P0 на P2, от P2 до P3 и так далее, я вычисляю...
[01:42:45.380 --> 01:42:47.380]  Давайте.
[01:42:47.380 --> 01:42:49.380]  Какой у меня многоугольник?
[01:42:52.380 --> 01:42:59.380]  Я вычисляю площадь, и она у меня идёт, с каким знаком?
[01:42:59.380 --> 01:43:01.380]  Ну с отрицательным знаком, да?
[01:43:01.380 --> 01:43:03.380]  То есть я беру площади и их складываю.
[01:43:03.380 --> 01:43:07.380]  То есть когда я иду в прямом направлении, у меня площади идут с отрицательным знаком.
[01:43:07.380 --> 01:43:09.380]  То есть я их просто складываю.
[01:43:09.380 --> 01:43:13.380]  Но при этом, когда я буду идти в обратном направлении, вот, например, вот, от этой вершины до этой вершины,
[01:43:13.380 --> 01:43:15.380]  что мне произойдёт?
[01:43:16.380 --> 01:43:20.380]  Я уже буду перемножать вектор на вот этот вектор, на вот этот вектор.
[01:43:20.380 --> 01:43:24.220]  Какой угол? Положительный, угол с другим знаком.
[01:43:24.220 --> 01:43:30.300]  Соответственно, вот эта часть у меня просто-напросто будет вычтена.
[01:43:30.300 --> 01:43:34.780]  Ровно как и вот эта часть.
[01:43:34.780 --> 01:43:37.580]  И в итоге, ну давайте какую-нибудь отдельную картинку изображу.
[01:43:37.580 --> 01:43:42.060]  В общем, есть какая-то произвольная фигура.
[01:43:42.060 --> 01:43:45.260]  То когда я иду вдоль вот такого направления по внешнему контуру,
[01:43:45.260 --> 01:43:48.220]  я беру все с одним знаком.
[01:43:48.220 --> 01:43:50.620]  Когда я буду идти в обратном направлении,
[01:43:50.620 --> 01:43:56.380]  то вдоль внутреннего контура я буду брать все с отрицательным знаком.
[01:43:56.380 --> 01:43:59.580]  И в итоге вот это все у меня вылется в ноль.
[01:43:59.580 --> 01:44:02.300]  А вот здесь будет плюс или минус С.
[01:44:02.300 --> 01:44:05.820]  Ровно то, что мне нужно.
[01:44:09.580 --> 01:44:13.500]  Соответственно, просто мы берем два последних вектора по порядку
[01:44:13.500 --> 01:44:15.100]  и перемножаем их векторами друг на друга.
[01:44:15.100 --> 01:44:16.300]  Дальше делим пополам.
[01:44:16.300 --> 01:44:17.900]  И в итоге мы получаем ориентированную площадь.
[01:44:17.900 --> 01:44:22.700]  Ну то есть площадь, которая нам нужна либо с положительным, либо с отрицательным знаком.
[01:44:22.700 --> 01:44:25.660]  Ну вот вопрос такой.
[01:44:25.660 --> 01:44:31.820]  Смотрите, вроде как я не прошло и получаться, как я не сдержал свое обещание.
[01:44:31.820 --> 01:44:36.620]  То есть вроде как я говорил, что у нас будет абсолютно точная арифметика и так далее.
[01:44:36.620 --> 01:44:38.300]  Но вот кажется, что если я вычисляю площадь...
[01:44:38.300 --> 01:44:40.620]  Кажется, что вычление площади наугольника,
[01:44:40.620 --> 01:44:43.020]  это довольно такая дробно-рациональная вещь.
[01:44:43.020 --> 01:44:47.660]  Поэтому, короче, я не могу ее вычислить с абсолютной точностью.
[01:44:47.660 --> 01:44:49.900]  Так это или нет.
[01:44:49.900 --> 01:44:55.740]  То есть может ли у меня, например, получиться так, что у меня площадь наугольника будет равна 4,3,
[01:44:55.740 --> 01:45:00.940]  что, скорее всего, на компьютере у меня будет отображено как 2,9,9 и так далее.
[01:45:00.940 --> 01:45:03.100]  Вот возможны ли такие проблемы с точностью?
[01:45:03.900 --> 01:45:05.180]  Супер.
[01:45:05.180 --> 01:45:09.660]  Да, на самом деле площадь произволенного наугольника я могу вычислить абсолютно точно.
[01:45:09.660 --> 01:45:10.940]  И вот почему.
[01:45:10.940 --> 01:45:13.660]  Действительно, когда я беру векторные произведения,
[01:45:13.660 --> 01:45:16.460]  все векторные произведения вычисляются у меня в целых числах.
[01:45:16.460 --> 01:45:19.820]  То есть в числителе у меня стоит целое число.
[01:45:19.820 --> 01:45:26.140]  И все, что я делаю с этим целым числом, в конце я просто беру и делю на два.
[01:45:26.780 --> 01:45:29.500]  И в итоге площадь многоугольника у меня всегда...
[01:45:29.500 --> 01:45:30.940]  Давайте пропишем.
[01:45:30.940 --> 01:45:45.340]  Площадь многоугольника это либо целое, либо полуцелое число.
[01:45:46.300 --> 01:45:48.940]  Все, других вариантов нет.
[01:45:48.940 --> 01:45:54.300]  То есть я всегда с абсолютной точностью могу вычислить площадь любого многоугольника.
[01:45:55.580 --> 01:45:57.820]  Ну, естественно, с целочислыми координатами.
[01:46:00.300 --> 01:46:01.660]  Все ясно?
[01:46:03.100 --> 01:46:04.380] ��요.
[01:46:04.380 --> 01:46:09.020]  И с этой точностью могу вычислить площадь любого многоугольника
[01:46:09.020 --> 01:46:13.020]  Естественно, со целочислыми координатами
[01:46:13.020 --> 01:46:17.020]  Все ясно
[01:46:17.020 --> 01:46:23.020]  Давайте теперь поговорим про другие фигуры
[01:46:23.020 --> 01:46:25.020]  Разобрались, для чего нам нужны векторы
[01:46:25.020 --> 01:46:29.020]  Векторы позволяют вычислять векторное произведение
[01:46:29.660 --> 01:46:33.660]  Векторное произведение позволяет вам, во-первых, узнавать величину угла
[01:46:33.660 --> 01:46:37.660]  Ну и во-вторых, вы научились читать площадь абсолютно произвольного многоугольника
[01:46:37.660 --> 01:46:39.660]  с абсолютной точностью
[01:46:39.660 --> 01:46:43.660]  Многоугольника с целыми координатами, так говорится
[01:46:43.660 --> 01:46:47.660]  Следующий примитив, про который мы поговорим
[01:46:53.660 --> 01:46:57.660]  Будет линия
[01:46:59.660 --> 01:47:05.660]  Давайте я сразу скажу, что линию я буду задавать
[01:47:05.660 --> 01:47:09.660]  Уравнением прямой
[01:47:09.660 --> 01:47:13.660]  Вот таким образом
[01:47:13.660 --> 01:47:17.660]  Сейчас о нем отдельно поговорим
[01:47:17.660 --> 01:47:21.660]  И соответственно
[01:47:21.660 --> 01:47:27.660]  Любая линия представляется тройкой
[01:47:28.300 --> 01:47:32.300]  Целых чисел
[01:47:32.300 --> 01:47:34.300]  Что можно сказать про это уравнение прямое?
[01:47:34.300 --> 01:47:36.300]  Откуда оно берется?
[01:47:36.300 --> 01:47:38.300]  Давайте сделаем следующую вещь
[01:47:38.300 --> 01:47:40.300]  Рассмотрим произвольную линию
[01:47:40.300 --> 01:47:44.300]  Во-первых, зададим вектор нормали
[01:47:44.300 --> 01:47:48.300]  И зададим некоторую точку на ней
[01:47:54.300 --> 01:47:56.300]  То есть любую линию можно задать
[01:47:56.940 --> 01:47:58.940]  И плюс вектор нормали
[01:47:58.940 --> 01:48:00.940]  Тогда линия будет проходить через эту точку
[01:48:00.940 --> 01:48:04.940]  И плюс прямобедикулярно вот этому вектору нормали
[01:48:04.940 --> 01:48:06.940]  Как из этого представления получить такое представление?
[01:48:06.940 --> 01:48:08.940]  Ну очень просто
[01:48:08.940 --> 01:48:12.940]  К какому условию у меня удовлетворяет произвольная точка
[01:48:12.940 --> 01:48:16.940]  Которая лежит на этой линии?
[01:48:16.940 --> 01:48:18.940]  Вот как связать произвольную точку
[01:48:18.940 --> 01:48:20.940]  Точку, которая лежит гарантированно на этой линии
[01:48:20.940 --> 01:48:22.940]  И n
[01:48:26.940 --> 01:48:28.940]  P-P0
[01:48:28.940 --> 01:48:30.940]  на n
[01:48:30.940 --> 01:48:32.940]  равно 0
[01:48:32.940 --> 01:48:34.940]  Ну действительно это так
[01:48:34.940 --> 01:48:38.940]  Потому что если мы возьмем точку P, которая лежит на прямой
[01:48:38.940 --> 01:48:40.940]  И возьмем разность ее с конкретной точкой P0
[01:48:40.940 --> 01:48:44.940]  То понятное дело, что так у меня нормаль
[01:48:44.940 --> 01:48:46.940]  Это перпендикуляр к линии
[01:48:46.940 --> 01:48:48.940]  То вот этот вектор получен
[01:48:48.940 --> 01:48:50.940]  Он будет перпендикулярен вектору нормали
[01:48:50.940 --> 01:48:52.940]  Вот такое уравнение мне задает уравнение прямой
[01:48:52.940 --> 01:48:54.940]  Ну отсюда можно спокойно раскрыть
[01:48:55.580 --> 01:48:57.580]  Что раскрыть?
[01:48:57.580 --> 01:48:59.580]  Раскрыть скобки
[01:48:59.580 --> 01:49:01.580]  Например, скажем, что у меня P это есть x, y
[01:49:01.580 --> 01:49:03.580]  А P0
[01:49:03.580 --> 01:49:05.580]  Это x0, y0
[01:49:05.580 --> 01:49:07.580]  Тогда отсюда что следует?
[01:49:07.580 --> 01:49:09.580]  Да, и n
[01:49:09.580 --> 01:49:11.580]  Пусть у меня будет вектором AB
[01:49:13.580 --> 01:49:15.580]  Если я раскрою, то у меня получится следующая вещь
[01:49:15.580 --> 01:49:17.580]  Ax
[01:49:17.580 --> 01:49:19.580]  Плюс Ay
[01:49:19.580 --> 01:49:21.580]  Минус
[01:49:21.580 --> 01:49:23.580]  Минус By
[01:49:24.220 --> 01:49:26.220]  Минус
[01:49:26.220 --> 01:49:28.220]  Ax0
[01:49:30.220 --> 01:49:32.220]  Ax0 равно 0
[01:49:32.220 --> 01:49:34.220]  Ну и отсюда понятно, откуда берется это уравнение
[01:49:34.220 --> 01:49:36.220]  То есть если я положу вот эту штуку
[01:49:36.220 --> 01:49:38.220]  равной c
[01:49:38.220 --> 01:49:40.220]  То будет ровно то, что я заявлял
[01:49:42.220 --> 01:49:44.220]  То есть отсюда следует, что
[01:49:48.220 --> 01:49:50.220]  Вектор нормали
[01:49:50.220 --> 01:49:52.220]  Точнее перпендикуляр к моей линии найти очень просто
[01:49:52.860 --> 01:49:54.860]  Достаточно просто взять первые коэффициенты
[01:49:54.860 --> 01:49:56.860]  A и B
[01:49:58.860 --> 01:50:00.860]  А как найти вектор, который
[01:50:00.860 --> 01:50:02.860]  Ну так скажем, направляющий вектор
[01:50:02.860 --> 01:50:04.860]  Мой прямой
[01:50:04.860 --> 01:50:06.860]  То есть вектор, который лежит вдоль направления
[01:50:06.860 --> 01:50:08.860]  Мой прямой
[01:50:12.860 --> 01:50:14.860]  Ну да, ну то есть
[01:50:14.860 --> 01:50:16.860]  Мне интересует больше алгоритм, как это получить
[01:50:16.860 --> 01:50:18.860]  В общем
[01:50:18.860 --> 01:50:20.860]  Мы знаем, что направляющий вектор
[01:50:21.500 --> 01:50:23.500]  Перпендикулярен вектору n
[01:50:23.500 --> 01:50:25.500]  Давайте просто составим какой-то вектор
[01:50:25.500 --> 01:50:27.500]  Который перпендикулярен вектору n
[01:50:27.500 --> 01:50:29.500]  Ну
[01:50:29.500 --> 01:50:31.500]  Например вот так
[01:50:31.500 --> 01:50:33.500]  Понятно, что при скалярном произведении
[01:50:33.500 --> 01:50:35.500]  A на B идет с плюсом
[01:50:35.500 --> 01:50:37.500]  B и минус A идет с минусом
[01:50:37.500 --> 01:50:39.500]  Соответственно получаем скалярное произведение 0
[01:50:39.500 --> 01:50:41.500]  Вот
[01:50:41.500 --> 01:50:43.500]  Такие дела
[01:50:43.500 --> 01:50:45.500]  Значит
[01:50:45.500 --> 01:50:47.500]  Ну третья
[01:50:47.500 --> 01:50:49.500]  Не совсем задача
[01:50:50.140 --> 01:50:52.140]  Такая постановка
[01:50:52.140 --> 01:50:54.140]  Вот
[01:50:54.140 --> 01:50:56.140]  Допустим, у меня дана линия
[01:50:56.140 --> 01:50:58.140]  И я хочу понять
[01:51:00.140 --> 01:51:02.140]  Ну, у меня дана линия l
[01:51:02.140 --> 01:51:04.140]  И две точки
[01:51:04.140 --> 01:51:06.140]  Допустим, по 1 и по 2
[01:51:06.140 --> 01:51:08.140]  Я хочу понять, эта точка находится
[01:51:08.140 --> 01:51:10.140]  По одну сторону, прямой или нет
[01:51:12.140 --> 01:51:14.140]  Как это можно сделать?
[01:51:20.140 --> 01:51:22.140]  Да, на самом деле очень просто
[01:51:22.140 --> 01:51:24.140]  Смотрите
[01:51:24.140 --> 01:51:26.140]  Вот дело в том, что если я
[01:51:26.140 --> 01:51:28.140]  Подставлю в уравнение прямой
[01:51:30.140 --> 01:51:32.140]  Py
[01:51:32.140 --> 01:51:34.140]  1 плюс c
[01:51:34.140 --> 01:51:36.140]  Вот давайте f
[01:51:36.140 --> 01:51:38.140]  P1
[01:51:38.140 --> 01:51:40.140]  То
[01:51:40.140 --> 01:51:42.140]  Вот такая величина у меня будет равна
[01:51:42.140 --> 01:51:44.140]  То есть она будет больше 0
[01:51:44.780 --> 01:51:46.780]  Для одной полуплоскости
[01:51:50.780 --> 01:51:52.780]  И меньше 0
[01:51:56.780 --> 01:51:58.780]  Для другой
[01:52:00.780 --> 01:52:02.780]  Ну, это, наверное, понятно, почему
[01:52:02.780 --> 01:52:04.780]  Потому что, если я рассмотрю
[01:52:06.780 --> 01:52:08.780]  Смотрите, если я рассматриваю
[01:52:08.780 --> 01:52:10.780]  Рассматриваю
[01:52:11.420 --> 01:52:13.420]  Рассматриваю
[01:52:17.420 --> 01:52:19.420]  Если я рассматриваю точку P0
[01:52:19.420 --> 01:52:21.420]  И произвольную точку P, которая лежит у меня
[01:52:21.420 --> 01:52:23.420]  На этой прямой
[01:52:23.420 --> 01:52:25.420]  То вот такое произведение
[01:52:29.420 --> 01:52:31.420]  У меня равно 0
[01:52:31.420 --> 01:52:33.420]  Согласны?
[01:52:33.420 --> 01:52:35.420]  А произвольную точку P1 или P2
[01:52:35.420 --> 01:52:37.420]  Я могу представить в виде, ну, такой
[01:52:37.420 --> 01:52:39.420]  Delta1 и Delta2
[01:52:40.060 --> 01:52:42.060]  Соответственно, у меня n
[01:52:42.060 --> 01:52:44.060]  Будет P
[01:52:44.060 --> 01:52:46.060]  Плюс Delta1
[01:52:46.060 --> 01:52:48.060]  Минус P0
[01:52:48.060 --> 01:52:50.060]  Вот
[01:52:50.060 --> 01:52:52.060]  Ну, и, соответственно, n на P и P0
[01:52:52.060 --> 01:52:54.060]  У меня сокращается и в итоге останется просто
[01:52:54.060 --> 01:52:56.060]  N умноженное на Delta1
[01:52:56.060 --> 01:52:58.060]  Ну, а вектор нормальный
[01:52:58.060 --> 01:53:00.060]  Умноженный на вектор Delta1
[01:53:00.060 --> 01:53:02.060]  Будет идти с положительным знаком
[01:53:02.060 --> 01:53:04.060]  Так как они, про что мы говорили, находятся, грубо говоря
[01:53:04.060 --> 01:53:06.060]  Смотрят в одну полуплоскость
[01:53:06.060 --> 01:53:08.060]  А векторы N и Delta2
[01:53:08.060 --> 01:53:10.060]  В одной полуплоскости
[01:53:10.060 --> 01:53:12.060]  Поэтому будут идти с другим знаком
[01:53:12.060 --> 01:53:14.060]  Понятно?
[01:53:14.060 --> 01:53:16.060]  Поэтому для проверки того, что две точки лежат
[01:53:16.060 --> 01:53:18.060]  В одной полуплоскости или нет
[01:53:18.060 --> 01:53:20.060]  Достаточно просто взять уравнение прямое
[01:53:20.060 --> 01:53:22.060]  Подставить в него точку 1 или точку 2
[01:53:22.060 --> 01:53:24.060]  И
[01:53:24.060 --> 01:53:26.060]  Если f от P1
[01:53:26.060 --> 01:53:28.060]  И f от P2
[01:53:32.060 --> 01:53:34.060]  Имеют
[01:53:34.060 --> 01:53:36.060]  Разные
[01:53:38.060 --> 01:53:40.060]  Знаки
[01:53:40.060 --> 01:53:42.060]  То
[01:53:46.060 --> 01:53:48.060]  То в разных
[01:53:48.060 --> 01:53:50.060]  Полуплоскостях
[01:53:50.060 --> 01:53:52.060]  Окей?
[01:53:52.060 --> 01:53:54.060]  Не знаю
[01:53:54.060 --> 01:53:56.060]  Расстояние между прямой точкой
[01:53:56.060 --> 01:53:58.060]  Расстояние между двумя прямыми я думаю говорить не будем
[01:53:58.060 --> 01:54:00.060]  Аналитические формулы
[01:54:00.060 --> 01:54:02.060]  Я думаю, вы в любом учебнике можете посмотреть
[01:54:02.060 --> 01:54:04.060]  Поэтому это не особо интересно
[01:54:04.060 --> 01:54:06.060]  Вот последний пункт, который рассмотрим про линию
[01:54:06.060 --> 01:54:08.060]  Четвертый
[01:54:10.060 --> 01:54:12.060]  Знаете так, проверка параллельности прямых
[01:54:20.060 --> 01:54:22.060]  То есть есть прямая
[01:54:22.060 --> 01:54:24.060]  A1х плюс B1y
[01:54:24.060 --> 01:54:26.060]  Плюс C
[01:54:26.060 --> 01:54:28.060]  1 равно 0
[01:54:28.060 --> 01:54:30.060]  И есть прямая A2х
[01:54:30.060 --> 01:54:32.060]  Плюс B2y
[01:54:32.060 --> 01:54:34.060]  Плюс C2 равно 0
[01:54:34.060 --> 01:54:36.060]  Вот
[01:54:36.060 --> 01:54:38.060]  Как понять параллельные эти прямые
[01:54:38.060 --> 01:54:40.060]  Параллельные эти прямые или нет
[01:54:40.060 --> 01:54:42.060]  Желательно наиболее простым способом
[01:54:50.060 --> 01:54:52.060]  Ну да
[01:54:52.060 --> 01:54:54.060]  Самый простой способ это
[01:54:54.060 --> 01:54:56.060]  Если не совпадают
[01:54:56.060 --> 01:54:58.060]  Ну в зависимости от задачи
[01:55:00.060 --> 01:55:02.060]  Если у вас задачи спрашиваются
[01:55:02.060 --> 01:55:04.060]  Если параллельные прямые пересекаются или совпадают
[01:55:04.060 --> 01:55:06.060]  То три варианта
[01:55:06.060 --> 01:55:08.060]  Если параллельные или
[01:55:08.060 --> 01:55:10.060]  Вобще пересекаются, наверное
[01:55:10.060 --> 01:55:12.060]  Но опять же это от условия задачи зависит
[01:55:14.060 --> 01:55:16.060]  В общем, так или иначе
[01:55:16.060 --> 01:55:18.060]  Действительно
[01:55:18.060 --> 01:55:20.060]  Прямые параллельные тогда и только тогда
[01:55:20.060 --> 01:55:22.060]  Когда их перпестигляры тоже параллельны
[01:55:22.060 --> 01:55:24.060]  Ну это я думаю понятно
[01:55:24.060 --> 01:55:26.060]  Ну как проверить, что вектора
[01:55:26.060 --> 01:55:28.060]  Во-первых, как понять
[01:55:28.060 --> 01:55:30.060]  Чему равен вектор n1 чему равен вектор n2
[01:55:30.060 --> 01:55:39.500]  что n1 это просто a1 и b1, а n2 это просто a2 и b2. Но как понять, что два вектора параллельно?
[01:55:39.500 --> 01:55:48.860]  Да, просто нужно смотреть на эффектное произведение. В этом случае произведение n1 на n2 должно быть
[01:55:48.860 --> 01:55:58.260]  равным 0. Ну и снова заметьте, что так как я работаю в целочисленных координатах, и все координаты,
[01:55:58.260 --> 01:56:06.140]  и все значения коэффициентов у меня целые, то я абсолютно точно, без каких-либо приближений,
[01:56:06.140 --> 01:56:10.580]  и так далее, могу вычислить параллельность прямых. То есть я могу понять параллельно мои прямые или
[01:56:10.580 --> 01:56:17.940]  нет. Не привлекая при этом никакую арифметику вычисления, не знаю, кто-то предлагал через
[01:56:17.940 --> 01:56:22.660]  детерминат и так далее. Но вот если вычислять детерминат или определять точку пересечения,
[01:56:22.660 --> 01:56:26.980]  то там естественным образом возникает деление. То есть при вычислении детермината там, конечно,
[01:56:26.980 --> 01:56:30.580]  будет целые числа, но если вы хотите вычислить, например, точку пересечения, то все будет плохо.
[01:56:30.580 --> 01:56:38.740]  Вопрос уже был, ну смотрите, можно рассмотреть и случаи совпадения. То есть вы можете проверить,
[01:56:38.740 --> 01:56:41.860]  что эти две прямые на самом деле совпадают. Ну что для этого нужно сделать? Нужно просто привести
[01:56:41.860 --> 01:56:47.060]  к общим коэффициентам и так далее. Здесь уже зависимость от задачи. То есть вы читаете условия,
[01:56:47.060 --> 01:56:54.060]  и если вас просят отдельно проверить случаи совпадения, то проверяйте. Если нет, то вот.
[01:56:54.060 --> 01:57:01.500]  На этом, наверное, с прямой закончим. Перейдем к чуть более интересным вещам. Следующий пункт – это луч.
[01:57:01.500 --> 01:57:20.700]  Луч удобнее всего задавать точкой начала и направляющим вектором v.
[01:57:20.700 --> 01:57:42.460]  Какие вопросы может задать луч? Давайте пятым пунктом проверим.
[01:57:51.660 --> 01:58:12.460]  Принадлежность точки P лучу OV. Ну вот есть луч. Есть некоторая точка P. П1 и пусть точка P2.
[01:58:12.460 --> 01:58:21.980]  Как проверить? Опять же, не прибегая никаким делениям, вычислениям расстояний и так далее.
[01:58:21.980 --> 01:58:28.940]  Абсолютно точно проверить, лежит ли у меня точка с целыми координатами на луче.
[01:58:28.940 --> 01:58:32.940]  Тоже с целыми координатами точки и с целыми координатами направляющим вектора.
[01:58:33.420 --> 01:58:52.220]  В целом, да. Давайте рассмотрим вектор OP2 и вектор V.
[01:58:52.220 --> 01:59:01.420]  В чем отличие синего вектора от такого? Первый из них сонаправлен с вектором V, а второй нет.
[01:59:01.900 --> 01:59:09.420]  Поэтому возникает, наверное, естественное желание сказать, что если у меня вектор OP2 и вектор V
[01:59:09.420 --> 01:59:17.420]  грубо говоря параллельны, так линярны, то значит у меня точка P лежит на луче.
[01:59:17.420 --> 01:59:23.420]  Давайте как это проверить? Как уже сказали, параллельность векторов мы проверяем с помощью векторного произведения.
[01:59:23.420 --> 01:59:41.420]  Если векторное произведение V и OP равно 0, то лежит. Так или нет?
[01:59:45.420 --> 01:59:47.420]  Что еще надо?
[01:59:53.420 --> 01:59:59.420]  Вот это не совсем правда, потому что эта штука проверяет лишь половину того, что нужно.
[01:59:59.420 --> 02:00:07.420]  Потому что если у вас есть какая-то точка P3, которая лежит на продолжении луча сюда, то у вас проблема.
[02:00:07.420 --> 02:00:15.420]  Векторное произведение действительно равно 0, так как эти вектора направлены в разные стороны.
[02:00:15.420 --> 02:00:19.420]  Но при этом точка P3 не лежит на луче.
[02:00:19.420 --> 02:00:23.420]  Что нужно дополнительно сделать?
[02:00:23.420 --> 02:00:33.420]  Мало того, что нам нужно проверить, что два вектора параллельны, нам нужно проверить, что они сонаправлены.
[02:00:33.420 --> 02:00:39.420]  Поэтому здесь мы дополняем вот таким условием.
[02:00:39.420 --> 02:00:41.420]  Вот теперь все.
[02:00:41.420 --> 02:01:03.420]  И вот эти два условия образуют следующее понятие, что векторы V и OP сонаправлены.
[02:01:03.420 --> 02:01:09.420]  Так, ну и второй и последний пункт, что касается луча.
[02:01:09.420 --> 02:01:17.420]  Он не совсем вписывается в нашу концепцию, что мы хотим делать все абсолютно точно, но вот ничего не поделаешь.
[02:01:17.420 --> 02:01:21.420]  Вот что есть у нас попросили? Расстояние.
[02:01:21.420 --> 02:01:25.420]  Вот точка P3.
[02:01:25.420 --> 02:01:29.420]  Понятно дело, что расстояние такая сущность, которую в принципе абсолютно точно нельзя посчитать.
[02:01:29.420 --> 02:01:35.420]  То есть так или иначе будут возникать всякие корни и так далее.
[02:01:35.420 --> 02:01:39.420]  Ну давайте хотя бы как-то в раунде.
[02:01:39.420 --> 02:01:47.420]  В раунде, в раунде, в раунде, в раунде, в раунде, в раунде, в раунде, в раунде.
[02:01:47.420 --> 02:01:51.420]  Ну давайте хотя бы как-то попробуем посчитать расстояние от точки до луча.
[02:01:51.420 --> 02:01:55.420]  Через какую площадь?
[02:02:18.420 --> 02:02:24.420]  Ну один из вариантов, да, наверное, да, можно найти площадь в такого перлограмма.
[02:02:24.420 --> 02:02:32.420]  Дальше, ну давайте как. Найдем площадь перлограмма, образованного векторами в AOP.
[02:02:32.420 --> 02:02:36.420]  Вот. И дальше что нужно сделать?
[02:02:36.420 --> 02:02:42.420]  Ну как вы считаете, площадь перлограмма кто помнит?
[02:02:48.420 --> 02:02:52.420]  Надо вот эту высоту умножить на что?
[02:02:52.420 --> 02:02:56.420]  Ну то есть вот так.
[02:02:56.420 --> 02:03:00.420]  Вот.
[02:03:00.420 --> 02:03:04.420]  Ну в целом норм. Можно и так.
[02:03:04.420 --> 02:03:08.420]  Что?
[02:03:08.420 --> 02:03:12.420]  В чем проблема вектор В?
[02:03:20.420 --> 02:03:24.420]  Да, есть проблема, вот такая.
[02:03:24.420 --> 02:03:28.420]  Вот если...
[02:03:28.420 --> 02:03:32.420]  Ну, тут плохой пример.
[02:03:32.420 --> 02:03:36.420]  А, нет, нормальный пример. Хороший.
[02:03:36.420 --> 02:03:40.420]  Ну вот представьте себе, что у вас луч вот такой.
[02:03:40.420 --> 02:03:44.420]  Луч направлен сюда, а точка P находится здесь.
[02:03:44.420 --> 02:03:48.420]  Тогда вот этот луч не подходит, согласны?
[02:03:48.420 --> 02:03:52.420]  Потому что кратчайшее расстояние от точки P до луча это какое?
[02:03:52.420 --> 02:03:56.420]  Это как раз вот эта точка.
[02:03:56.420 --> 02:04:00.420]  Вот поэтому...
[02:04:00.420 --> 02:04:04.420]  Мы вычисляем расстояние либо так,
[02:04:04.420 --> 02:04:08.420]  либо так. То есть, модуль вектора OP.
[02:04:08.420 --> 02:04:12.420]  А в зависимости от каких условий?
[02:04:12.420 --> 02:04:16.420]  Что отличает вот это случая от вот этого случая?
[02:04:16.420 --> 02:04:20.420]  Вот этот случай.
[02:04:20.420 --> 02:04:24.420]  Вот этот случай.
[02:04:24.420 --> 02:04:28.420]  Что отличает вот этого случая?
[02:04:28.420 --> 02:04:32.420]  Да, вновь, скалярное произведение вектора В и вектора OP.
[02:04:32.420 --> 02:04:36.420]  То есть снова мы хотим понять, в какой полуплоскости мы находимся, в левой или в правый.
[02:04:36.420 --> 02:04:40.420]  Ну и здесь тоже. В левой или в правый.
[02:04:40.420 --> 02:04:44.420]  Соответственно, здесь, если у нас OP, скалярное произведение на В,
[02:04:44.420 --> 02:04:48.420]  больше либо равно нуля,
[02:04:48.420 --> 02:04:52.420]  то мы используем вот такой способ.
[02:04:52.420 --> 02:04:56.420]  Ну, меньше нуля пусть будет.
[02:04:56.420 --> 02:05:00.420]  То есть, используем вот такую штуку.
[02:05:00.420 --> 02:05:04.420]  Окей.
[02:05:04.420 --> 02:05:08.420]  Что еще раз?
[02:05:08.420 --> 02:05:12.420]  Ну, без разницы.
[02:05:12.420 --> 02:05:16.420]  То есть, тут тоже самое будет.
[02:05:16.420 --> 02:05:20.420]  Ну, хорошо. Давайте так.
[02:05:20.420 --> 02:05:24.420]  Так нормально?
[02:05:34.420 --> 02:05:38.420]  Так.
[02:05:38.420 --> 02:05:42.420]  Самая интересная фигура, ну как фигура.
[02:05:42.420 --> 02:05:46.420]  Короче, отрезок.
[02:05:50.420 --> 02:05:54.420]  Нет, просто отрезок.
[02:05:54.420 --> 02:05:58.420]  Ну, отрезок просто представляем в виде
[02:05:58.420 --> 02:06:02.420]  пары точек.
[02:06:02.420 --> 02:06:06.420]  Знаете, PQ.
[02:06:06.420 --> 02:06:10.420]  Пойнт P.
[02:06:14.420 --> 02:06:18.420]  Пойнт Q.
[02:06:18.420 --> 02:06:22.420]  Мы хотели узнать про отрезок.
[02:06:22.420 --> 02:06:26.420]  Ну, первый пункт давайте сразу
[02:06:26.420 --> 02:06:30.420]  найдем, точнее, определим.
[02:06:36.420 --> 02:06:40.420]  Принадлежность точки
[02:06:40.420 --> 02:06:44.420]  P'
[02:06:44.420 --> 02:06:48.420]  отрезку PQ.
[02:06:48.420 --> 02:06:52.420]  Давайте О, чтоб.
[02:06:52.420 --> 02:06:56.420]  А, все.
[02:07:00.420 --> 02:07:04.420]  Ну чего, как будем проверять?
[02:07:04.420 --> 02:07:08.420]  Что с фильтрами?
[02:07:08.420 --> 02:07:12.420]  Ну да, кажется, этого достаточно.
[02:07:12.420 --> 02:07:16.420]  Всем понятна идея?
[02:07:16.420 --> 02:07:20.420]  Если у вас точка A лежит вне отрезка,
[02:07:20.420 --> 02:07:24.420]  то у вас вектора P'A и PQ,
[02:07:24.420 --> 02:07:28.420]  но они, во-первых, не параллельны, а во-вторых, не сонаправлены.
[02:07:28.420 --> 02:07:32.420]  Если точка A лежит на отрезке,
[02:07:32.420 --> 02:07:36.420]  то P'A и PQ, они у вас сонаправлены.
[02:07:36.420 --> 02:07:40.420]  Более того, если у вас точка лежит где-то на продолжении отрезка,
[02:07:40.420 --> 02:07:44.420]  то тут этот критерий тоже работает,
[02:07:44.420 --> 02:07:48.420]  потому что у вас в этом случае P'A и PQ будут противоложно направлены.
[02:07:48.420 --> 02:07:52.420]  Поэтому, да, критерий простой,
[02:07:52.420 --> 02:07:56.420]  и он звучит следующим. Во-первых, у вас
[02:07:56.420 --> 02:08:00.420]  вектор P'A должен быть параллелен вектору PQ.
[02:08:00.420 --> 02:08:04.420]  Давайте просто напишем то, что мы там писали.
[02:08:04.420 --> 02:08:18.420]  Сонаправленность векторов P'A и PQ.
[02:08:24.420 --> 02:08:28.420]  Ну, опять же, расстояние плохо.
[02:08:34.420 --> 02:08:38.420]  Да, возьмем две очень удаленные друг от друга точки,
[02:08:38.420 --> 02:08:42.420]  и тут находится точка на расстоянии 1.
[02:08:42.420 --> 02:08:46.420]  Тогда у вас может быть ошибка с точностью.
[02:08:46.420 --> 02:08:50.420]  А здесь все точно. То есть у нас сонаправленность векторов проверяется с помощью
[02:08:50.420 --> 02:08:54.420]  векторно-висколярного произведения, которые вычисляются в целых числах, и все нормально.
[02:08:54.420 --> 02:08:58.420]  Вот. Хорошо.
[02:08:58.420 --> 02:09:02.420]  Восьмой пункт.
[02:09:02.420 --> 02:09:06.420]  Ну, расстояние от точки до отрезка.
[02:09:06.420 --> 02:09:10.420]  Может, сразу скажете,
[02:09:10.420 --> 02:09:14.420]  как вычислить расстояние от точки до отрезка.
[02:09:24.420 --> 02:09:28.420]  Так, что аналогично?
[02:09:32.420 --> 02:09:36.420]  Ну, короче говоря, видимо,
[02:09:36.420 --> 02:09:40.420]  в случае отрезка нужно рассмотреть три случая.
[02:09:40.420 --> 02:09:44.420]  Находимся ли мы здесь?
[02:09:44.420 --> 02:09:48.420]  Находимся мы здесь?
[02:09:48.420 --> 02:09:52.420]  Или находимся мы здесь?
[02:09:52.420 --> 02:09:56.420]  Ну, как проверять, в каком случае мы находимся, будем обсуждать?
[02:09:56.420 --> 02:10:00.420]  Или понятно?
[02:10:00.420 --> 02:10:04.420]  Ну, аналогично лучшую, да. То есть вы просто смотрите на вектор ПQ и смотрите на вектор ПА.
[02:10:04.420 --> 02:10:08.420]  Вот. Если они сонаправлены, то точно не здесь.
[02:10:08.420 --> 02:10:12.420]  Аналогично рассмотреть вектор QP и вектор QA.
[02:10:12.420 --> 02:10:16.420]  Если их скалярное произведение больше 0, то точно не здесь.
[02:10:16.420 --> 02:10:20.420]  Ну и соответственно по этим двум критериям вы можете спокойно определить,
[02:10:20.420 --> 02:10:24.420]  какого части вы находитесь.
[02:10:24.420 --> 02:10:28.420]  Ну и теперь давайте, если я нахожусь в первой области, то чему равно расстояние?
[02:10:28.420 --> 02:10:32.420]  Чему равно расстояние от точки A до точки P?
[02:10:32.420 --> 02:10:36.420]  Да, просто расстояние от A до P в случае 3.
[02:10:36.420 --> 02:10:40.420]  Да, от точки A до точки Q.
[02:10:40.420 --> 02:10:44.420]  В втором случае...
[02:10:44.420 --> 02:10:48.420]  Да, ну просто расстояние от точки A до прямой PQ.
[02:10:48.420 --> 02:10:52.420]  Прямая или луч, как вам удобнее.
[02:10:52.420 --> 02:10:56.420]  Прямая, луч.
[02:10:56.420 --> 02:11:00.420]  Все.
[02:11:00.420 --> 02:11:04.420]  Пересечение с линией.
[02:11:10.420 --> 02:11:14.420]  Ну данный отрезок, данная линия, нужно понять,
[02:11:14.420 --> 02:11:18.420]  пересекаются ли отрезок и линия или нет.
[02:11:26.420 --> 02:11:30.420]  Ну и...
[02:11:48.420 --> 02:11:52.420]  Ну и...
[02:11:52.420 --> 02:11:56.420]  Короче, хочется сказать, что эту задачу мы уже решали.
[02:11:56.420 --> 02:12:00.420]  Какой пункт у нас был?
[02:12:00.420 --> 02:12:04.420]  Ну номер пункта, чтобы сослаться.
[02:12:04.420 --> 02:12:08.420]  1, 2, 3.
[02:12:08.420 --> 02:12:12.420]  Давайте просто напишем, смотри, пункт 3.
[02:12:12.420 --> 02:12:16.420]  Ну действительно, если у вас...
[02:12:16.420 --> 02:12:20.420]  В каком случае у нас отрезок пересекает линию?
[02:12:20.420 --> 02:12:24.420]  Если две точки находятся по одну сторону от прямой,
[02:12:24.420 --> 02:12:28.420]  то в общем все плохо.
[02:12:28.420 --> 02:12:32.420]  Отдельно надо сказать про случай, когда у вас точка лежит на прямой.
[02:12:32.420 --> 02:12:36.420]  По умолчанию считаем, что если хотя бы одна из точек лежит на прямой,
[02:12:36.420 --> 02:12:40.420]  то пересечение есть.
[02:12:40.420 --> 02:12:44.420]  Плюс отдельно
[02:12:44.420 --> 02:12:48.420]  случай
[02:12:48.420 --> 02:12:52.420]  П принадлежит L
[02:12:52.420 --> 02:12:56.420]  или Q принадлежит L.
[02:12:56.420 --> 02:13:00.420]  Ну как проверяем принадлежность точки прямой? Говорили, да, просто подставляем в уравнении прямой и все.
[02:13:00.420 --> 02:13:04.420]  Вот. Соответственно, снова пересечение прямой и отрезка
[02:13:04.420 --> 02:13:08.420]  абсолютно точно у нас вычисляется. Без применения каких-то там
[02:13:08.420 --> 02:13:12.420]  делений, вычислений корня и так далее и так далее.
[02:13:12.420 --> 02:13:16.420]  Ну я напомню, что мы принадлежность точки в полуплоскости проверяли
[02:13:16.420 --> 02:13:20.420]  с помощью обычного скалярного произведения.
[02:13:20.420 --> 02:13:24.420]  Поэтому тут тоже все со стопроцентной точностью.
[02:13:24.420 --> 02:13:28.420]  Так, давайте здесь же напишу.
[02:13:28.420 --> 02:13:32.420]  Значит, теперь мы пересекаем отрезок
[02:13:32.420 --> 02:13:36.420]  и луч.
[02:13:46.420 --> 02:13:50.420]  Ну вот тут, к сожалению,
[02:13:50.420 --> 02:13:54.420]  так просто не получится ничего сделать.
[02:13:54.420 --> 02:13:58.420]  И вот по какой причине?
[02:14:02.420 --> 02:14:06.420]  Ну вот смотри.
[02:14:06.420 --> 02:14:10.420]  Вот здесь вот мы пересекаем отрезок.
[02:14:10.420 --> 02:14:14.420]  И вот здесь вот мы пересекаем отрезок.
[02:14:14.420 --> 02:14:18.420]  Ну вот смотрите. Вот есть точка P здесь.
[02:14:22.420 --> 02:14:26.420]  А есть точка P здесь.
[02:14:26.420 --> 02:14:30.420]  Одна из них пересекает луч, другая не пересекает луч.
[02:14:30.420 --> 02:14:34.420]  Ну казалось бы, они более-менее одинаковые, да,
[02:14:34.420 --> 02:14:38.420]  то есть лежат в одной полуплоскости слева
[02:14:38.420 --> 02:14:42.420]  от вектора V сверху и так далее и так далее.
[02:14:42.420 --> 02:14:46.420]  Но при этом одна прямая пересекает, другая не пересекает.
[02:14:46.420 --> 02:14:50.420]  Здесь я, в общем,
[02:14:50.420 --> 02:14:54.420]  тут можно помахать руками и посчитать через углы,
[02:14:54.420 --> 02:14:58.420]  через повороты и так далее, но, в общем,
[02:14:58.420 --> 02:15:02.420]  я надеюсь, вы меня простите, но мне больше нравится
[02:15:02.420 --> 02:15:06.420]  аналитический подход к этому всему делу.
[02:15:06.420 --> 02:15:10.420]  Давайте попробуем вывести некоторые критерии,
[02:15:10.420 --> 02:15:14.420]  например, прежнодержность точки прямой или лучу.
[02:15:14.420 --> 02:15:18.420]  Значит, смотрите, как задается произвольная точка на луче?
[02:15:18.420 --> 02:15:22.420]  Ну ее можно задать очень просто.
[02:15:22.420 --> 02:15:26.420]  Согласны?
[02:15:26.420 --> 02:15:30.420]  Положение произвольной точки на луче задается как?
[02:15:30.420 --> 02:15:34.420]  Положение точки O плюс двиг на какой-то вектор в направлении V.
[02:15:34.420 --> 02:15:38.420]  Как задается произвольная точка на отрезке по Q?
[02:15:38.420 --> 02:15:42.420]  Я так напишу Q минус P.
[02:15:42.420 --> 02:15:46.420]  Причем здесь T больше либо равно нуля,
[02:15:46.420 --> 02:15:50.420]  а альфа принадлежит нуля до единицы.
[02:15:54.420 --> 02:15:58.420]  Теперь смотрите.
[02:15:58.420 --> 02:16:02.420]  Давайте пункт А алгоритма.
[02:16:02.420 --> 02:16:06.420]  Первым пунктом давайте сразу проверим, что у меня
[02:16:06.420 --> 02:16:10.420]  в принципе отрезок PQ пересекает линию, на которой лежит луч.
[02:16:10.420 --> 02:16:14.420]  Потому что если отрезок не пересекает линию, на которой лежит луч, то о чем вообще говорить?
[02:16:14.420 --> 02:16:18.420]  Давайте просто проверяем
[02:16:22.420 --> 02:16:26.420]  пересечение PQ
[02:16:26.420 --> 02:16:30.420]  и линии OV.
[02:16:30.420 --> 02:16:34.420]  Вот смотрите.
[02:16:34.420 --> 02:16:38.420]  Если отрезок PQ пересекает линию OV,
[02:16:38.420 --> 02:16:42.420]  то у меня гарантированно в этом уравнении в качестве альфы решение будет 0.1.
[02:16:42.420 --> 02:16:46.420]  Согласны?
[02:16:46.420 --> 02:16:50.420]  То есть гарантируем
[02:16:50.420 --> 02:16:54.420]  альфа принадлежит от нуля до единицы.
[02:16:54.420 --> 02:16:58.420]  Ну то есть T может быть отрицательной в принципе,
[02:16:58.420 --> 02:17:02.420]  но альфа точно принадлежит от нуля до единицы.
[02:17:02.420 --> 02:17:06.420]  Понятно, да, решение?
[02:17:06.420 --> 02:17:10.420]  Ну и пункт В, давайте что сделаем?
[02:17:10.420 --> 02:17:14.420]  Давайте перенесем в левую часть. Что у меня получится?
[02:17:14.420 --> 02:17:18.420]  Вектор O-вектор P что мне даст?
[02:17:18.420 --> 02:17:22.420]  Вектор PO кажется, да?
[02:17:22.420 --> 02:17:26.420]  Вектор O-P равно PO.
[02:17:26.420 --> 02:17:30.420]  Из этого следует, что O равно P плюс PO.
[02:17:30.420 --> 02:17:34.420]  Кажется, все верно.
[02:17:34.420 --> 02:17:38.420]  Дальше. Плюс VT
[02:17:38.420 --> 02:17:42.420]  равно... Давайте вот эту штуку оставим.
[02:17:42.420 --> 02:17:46.420]  Альфа на... А Q-P это что?
[02:17:46.420 --> 02:17:50.420]  Это PQ, да?
[02:17:50.420 --> 02:17:54.420]  Вот.
[02:17:54.420 --> 02:17:58.420]  Ну и теперь мне надо как-то понять, при каком условии у меня T больше нуля.
[02:17:58.420 --> 02:18:02.420]  Но вот меня смущает, что тут есть еще параметр альфа и T.
[02:18:02.420 --> 02:18:06.420]  Вот давайте я как-то от альфа пытаюсь избавиться. Вот предложите какой-нибудь способ, как мне избавиться от альфа.
[02:18:06.420 --> 02:18:10.420]  Вот как занулить правую часть. Умножать на 0 не вариант.
[02:18:20.420 --> 02:18:24.420]  Давайте векторно только. Векторно на что умножить?
[02:18:24.420 --> 02:18:28.420]  Давайте я векторно умножу на PQ.
[02:18:28.420 --> 02:18:32.420]  Но если я векторно умножу PQ на PQ, то получится 0.
[02:18:32.420 --> 02:18:36.420]  Все. То есть в итоге у меня получается следующая вещь. Вектор PO векторно на PQ
[02:18:36.420 --> 02:18:40.420]  плюс
[02:18:40.420 --> 02:18:44.420]  V векторно на PQ
[02:18:44.420 --> 02:18:48.420]  T равно нулю.
[02:18:48.420 --> 02:18:52.420]  При каком условии у меня есть... Ну теперь надо проверить при каком условии у меня есть корень,
[02:18:52.420 --> 02:18:56.420]  который больше либо равен нуля.
[02:19:00.420 --> 02:19:04.420]  Ну T больше либо равен нуля.
[02:19:04.420 --> 02:19:08.420]  Задачи с параметром не решали.
[02:19:12.420 --> 02:19:16.420]  Давайте вот это A, вот это B. Или у меня A занято? Нет.
[02:19:16.420 --> 02:19:20.420]  Ну тогда и только тогда, когда A и B
[02:19:20.420 --> 02:19:24.420]  разных знаков.
[02:19:34.420 --> 02:19:38.420]  Ну давайте вот так скажем. Что T больше нуля, тогда и только тогда,
[02:19:38.420 --> 02:19:42.420]  когда A и B разных знаков.
[02:19:42.420 --> 02:19:46.420]  Здесь еще один случай.
[02:19:46.420 --> 02:19:50.420]  Не знаю, нужно ли его проверить отдельно или нет.
[02:19:50.420 --> 02:19:54.420]  Вот если O принадлежит
[02:19:54.420 --> 02:19:58.420]  O принадлежит PQ.
[02:19:58.420 --> 02:20:02.420]  Вот если O принадлежит PQ, то все OK.
[02:20:02.420 --> 02:20:06.420]  Ну давайте это нулевым пунктом отдельно проверим.
[02:20:06.420 --> 02:20:10.420]  Если точка O лежит на отрезке PQ,
[02:20:10.420 --> 02:20:14.420]  то пересечение есть.
[02:20:14.420 --> 02:20:18.420]  Все, ну а дальше собственно проверяем, действительно ли у меня PQ пересекает прямую.
[02:20:18.420 --> 02:20:22.420]  В этом случае я гарантирую, что у меня решение для альфы лежит в отрезке 0,1.
[02:20:22.420 --> 02:20:26.420]  Ну и дальше мне осталось проверить, что решение для T у меня больше нуля.
[02:20:26.420 --> 02:20:30.420]  А это я проверяю вот таким образом. Просто смотрю на скалярные произведения
[02:20:30.420 --> 02:20:34.420]  по O и PQ,
[02:20:34.420 --> 02:20:38.420]  и в и PQ.
[02:20:38.420 --> 02:20:42.420]  Если они разных знаков, то все OK.
[02:20:46.420 --> 02:20:50.420]  Вот у этого всего есть геометрический смысл.
[02:20:50.420 --> 02:20:54.420]  В общем, вы можете покрутить и посмотреть, что вот...
[02:20:54.420 --> 02:20:58.420]  Ну короче, если там что-то типа...
[02:20:58.420 --> 02:21:02.420]  Если поворот, то есть поворот угла от V до P
[02:21:02.420 --> 02:21:06.420]  и V до Q там что-то типа имеет одинаковый знак, то вот все плохо.
[02:21:06.420 --> 02:21:10.420]  В общем, посмотрите,
[02:21:10.420 --> 02:21:14.420]  я обычно все вывожу, а не геометрирую.
[02:21:14.420 --> 02:21:18.420]  Вот решение, пользуйтесь.
[02:21:24.420 --> 02:21:28.420]  Так, ну и последний пункт, который касается отрезка.
[02:21:28.420 --> 02:21:32.420]  Мы пересекали отрезок с прямой, пересекали отрезок с лучом.
[02:21:32.420 --> 02:21:36.420]  Да, с самим отрезком.
[02:21:38.420 --> 02:21:42.420]  Итак, пересечение AB и CD.
[02:21:42.420 --> 02:21:46.420]  Ну, отрезок AB и отрезок CD.
[02:21:48.420 --> 02:21:52.420]  Ну вот, даны два отрезка.
[02:21:52.420 --> 02:21:56.420]  Ну или вот так.
[02:21:56.420 --> 02:22:00.420]  Нужно проверить, пересекаются они или нет.
[02:22:00.420 --> 02:22:04.420]  Что делать?
[02:22:14.420 --> 02:22:18.420]  Ну, я предлагаю попроще.
[02:22:18.420 --> 02:22:22.420]  Давайте проверим, что отрезок... ну, смотрите, давайте воспользуемся тем, что мы уже делали.
[02:22:22.420 --> 02:22:26.420]  Давайте попробуем пересечь отрезок CD и прямую AB.
[02:22:26.420 --> 02:22:30.420]  И наоборот, прямую CD с отрезком AB.
[02:22:30.420 --> 02:22:34.420]  Вот.
[02:22:34.420 --> 02:22:38.420]  Если отрезок AB пересекает
[02:22:38.420 --> 02:22:42.420]  прямую CD и отрезок CD
[02:22:42.420 --> 02:22:46.420]  пересекает
[02:22:46.420 --> 02:22:50.420]  прямую AB.
[02:22:50.420 --> 02:22:54.420]  Разумно?
[02:22:54.420 --> 02:22:58.420]  Вот, этот критерий работает почти всегда.
[02:22:58.420 --> 02:23:02.420]  В каком случае он не работает?
[02:23:14.420 --> 02:23:18.420]  Совпадают.
[02:23:18.420 --> 02:23:22.420]  Совпадают. Нет, если совпадают, то все нормально.
[02:23:22.420 --> 02:23:26.420]  При совпадении отрезок пересекает прямую CD и наоборот.
[02:23:34.420 --> 02:23:38.420]  А вот если прямые совпадают...
[02:23:40.420 --> 02:23:44.420]  Ну вот такой пример. Согласны?
[02:23:44.420 --> 02:23:48.420]  AB пересекает прямую CD, CD тоже пересекает прямую AB.
[02:23:48.420 --> 02:23:52.420]  Но при этом сами отрезки не пересекаются.
[02:23:52.420 --> 02:23:56.420]  Что делать?
[02:23:56.420 --> 02:24:00.420]  Но в этом случае надо дополнительно проверить.
[02:24:00.420 --> 02:24:04.420]  Давайте тут напишу. Плюс
[02:24:04.420 --> 02:24:08.420]  проверить пересечение
[02:24:08.420 --> 02:24:12.420]  проекции
[02:24:12.420 --> 02:24:16.420]  проекции
[02:24:16.420 --> 02:24:20.420]  AB и CD.
[02:24:20.420 --> 02:24:24.420]  То есть...
[02:24:24.420 --> 02:24:28.420]  Мы смотрим на проекции отрезка AB
[02:24:32.420 --> 02:24:36.420]  и проекции отрезка CD.
[02:24:38.420 --> 02:24:42.420]  Ну и в этом случае их проекции не совпадают.
[02:24:42.420 --> 02:24:46.420]  Поэтому, естественно, никого пересечения у них самих нет.
[02:24:46.420 --> 02:24:50.420]  Но при этом, если их проекции пересекаются...
[02:24:50.420 --> 02:24:54.420]  Ну, то есть...
[02:25:00.420 --> 02:25:04.420]  Ну как проверить пересечение проекций?
[02:25:04.420 --> 02:25:08.420]  Ну или наоборот?
[02:25:20.420 --> 02:25:24.420]  Ну, в общем, нужно аккуратно проверить...
[02:25:24.420 --> 02:25:28.420]  Ну, еще какие-то условия. Нужно аккуратно проверить
[02:25:28.420 --> 02:25:32.420]  пересечение проекции.
[02:25:32.420 --> 02:25:34.420]  Ну, в общем, нужно аккуратно проверить
[02:25:34.420 --> 02:25:47.360] prü
[02:25:47.360 --> 02:25:49.360]  То есть я привел пример, когда первую условия
[02:25:49.360 --> 02:25:51.360]  недостаточно, да. То есть проверить еще вторую.
[02:25:51.360 --> 02:25:53.080]  Можете привести пример, что teaspoon
[02:25:53.080 --> 02:25:57.080]  не достаточно тоже. Нужно проверять еще пересечение прямых.
[02:26:15.080 --> 02:26:18.080]  В этом случае они по y не пересекаются.
[02:26:23.080 --> 02:26:25.080]  Вот так.
[02:26:27.080 --> 02:26:30.080]  Они и по x пересекаются, и по y пересекаются.
[02:26:30.080 --> 02:26:32.080]  Но при этом сами отрезки не пересекаются.
[02:26:32.080 --> 02:26:35.080]  То есть отрезка B не пересекает линию CD.
[02:26:38.080 --> 02:26:42.080]  Ну и, видимо, последний пункт на сегодня.
[02:26:46.080 --> 02:26:48.080]  Многоугольники.
[02:26:53.080 --> 02:27:05.080]  Многоугольник будем представлять в виде упорядочного набора вершин.
[02:27:16.080 --> 02:27:22.080]  Ну то есть многоугольник это просто массив, который состоит из его вершин.
[02:27:22.080 --> 02:27:24.080]  Поэтому упорядочное в каком-то порядке.
[02:27:24.080 --> 02:27:27.080]  По часовой стрелке или про часовой стрелке неважно.
[02:27:29.080 --> 02:27:32.080]  Ну и пункт 7.
[02:27:33.080 --> 02:27:35.080]  Какой у нас пункт был?
[02:27:35.080 --> 02:27:37.080]  Почему тут 8?
[02:27:40.080 --> 02:27:42.080]  Ну короче, пункт плюс-плюс и.
[02:27:42.080 --> 02:27:45.080]  Значит, мы должны проверить.
[02:27:45.080 --> 02:27:48.080]  Хочется проверить, лежит ли точка.
[02:27:52.080 --> 02:27:55.080]  Лежит точка внутри многоугольника или нет.
[02:27:56.080 --> 02:27:58.080]  Произвольно, абсолютно.
[02:27:58.080 --> 02:28:01.080]  То есть не выпуклого и так далее.
[02:28:07.080 --> 02:28:10.080]  В общем, хочется уметь отличать вот такую ситуацию от вот такой ситуации.
[02:28:11.080 --> 02:28:13.080]  Ну и пункт 9.
[02:28:13.080 --> 02:28:15.080]  Ну и пункт 10.
[02:28:15.080 --> 02:28:17.080]  Ну и пункт 11.
[02:28:17.080 --> 02:28:19.080]  Ну и пункт 12.
[02:28:19.080 --> 02:28:23.080]  Теперь я хочу уметь отличать вот такую ситуацию от вот такой ситуации.
[02:28:26.080 --> 02:28:32.080]  Здесь предлагается использовать следующий метод.
[02:28:34.080 --> 02:28:38.080]  Давайте рассмотрим произвольную фигуру.
[02:28:39.080 --> 02:28:41.080]  Замкнутую ноту.
[02:28:43.080 --> 02:28:44.080]  Такая фигура.
[02:28:44.080 --> 02:28:50.680]  фигура и я хочу проверить действительно у меня точка лежит внутри или нет вот
[02:28:50.680 --> 02:28:55.840]  давайте я опущу произвольный луч ну допустим горизонтально направлении
[02:29:00.480 --> 02:29:07.880]  пускай луч горизонтально направлении я получаю какое-то количество пересечений
[02:29:07.880 --> 02:29:12.040]  что можно сказать про их количество
[02:29:25.360 --> 02:29:30.120]  ну да ну из чего да из чего это следует смотрите вот когда я пересекаю когда
[02:29:30.120 --> 02:29:33.800]  пересекаю стороны что у меня происходит вот когда пересекаю первый раз у меня
[02:29:33.800 --> 02:29:39.200]  луч выходит из этой фигуры да когда я захожу во второй раз он обратно входит в эту фигуру
[02:29:39.200 --> 02:29:44.900]  выходит-входит-входит и вот если количество выходов у меня больше чем количество вхождений
[02:29:44.900 --> 02:29:49.300]  то значит у меня луч в конце концов покинул фигуру но в каком случае у меня луч может
[02:29:49.300 --> 02:29:52.760]  покинуть фигуру только в случае если у меня изначально точка находилась внутри согласны
[02:29:52.760 --> 02:30:03.720]  а где здесь вершина ну про это мы отдельно поговорим да это вы в общем правильное
[02:30:03.720 --> 02:30:07.320]  замечание делать очень действительно если меня там проходит через касательную то да ну в
[02:30:07.320 --> 02:30:12.400]  принципе как бы касса ну не знаю там с логической точки зрения наверное касание не читается входом
[02:30:12.400 --> 02:30:17.800]  или выходом поэтому все-таки будем считать что вход или выход как пересечение ну то есть заход
[02:30:17.800 --> 02:30:25.640]  именно внутрь фигуры в общем примерные критерии такое если число пересечения чётно то снаружи
[02:30:25.640 --> 02:30:43.640]  иначе иначе внутри первое приближение теперь проблемы вот одну проблему действительно уже
[02:30:43.640 --> 02:30:56.280]  вскрыли конкретно в случае многоугольника что если у меня вот такая ситуация дайте вот такой
[02:30:56.280 --> 02:31:10.160]  многоугольник рисуем и точка здесь вот если я многоугольник пересекаю здесь то что у меня
[02:31:10.160 --> 02:31:18.560]  получается ну мы можем смотреть такую точку можем считать действительно за две но потому что
[02:31:18.560 --> 02:31:22.520]  с одной стороны мы пересекли вот такую вершину и вот такую вершину да то есть в итоге у нас
[02:31:22.520 --> 02:31:39.800]  три пересечения и что точка внутри контрпример сколько пересечений ну два и при этом точка внутри
[02:31:39.800 --> 02:31:52.560]  тоже поэтому когда я встречаю вершину на своем пути мне плохо что делать есть два трюка и
[02:31:52.560 --> 02:32:00.360]  первый заключается следующим смотрите вот давайте я буду поступать следующим образом
[02:32:09.800 --> 02:32:18.840]  ну примерно только мы луч вообще смотреть не будем будем просто смотреть на то короче
[02:32:18.840 --> 02:32:25.640]  будем смотреть вот эта точка находится выше или ниже чем вторая вторая короче сейчас объясню
[02:32:25.640 --> 02:32:33.440]  смотрите вот если я вот смотрите когда я когда то есть как я проверяю пересечение луча с моим
[02:32:33.440 --> 02:32:37.280]  многоугольником я просто последовательно прохожу по всем сторонам и проверяю вот этот отрезок
[02:32:37.280 --> 02:32:42.680]  пересекается случом или нет отрезок пересекается случаемumber нет и так далее andy и вот допустим я в
[02:32:42.680 --> 02:32:52.320]  какой-то момент понял что какой-то момент понял что мой луч пересекают вот эту сторону вот эту
[02:32:52.320 --> 02:32:59.200]  сторону при этом он проходит через одну из вершин ну конкретно через точку и давайте сделаем
[02:32:59.200 --> 02:33:06.720]  такой трюк если мой луч проходит через верхнюю точку стороны то я буду добавлять к счетчику
[02:33:06.720 --> 02:33:13.800]  плюс один. Я иду по всем сторонам и считаю количество пересечений.
[02:33:13.800 --> 02:33:19.760]  Вот если я встретил верхнюю точку прямой, точнее верхнюю точку стороны, то я даю
[02:33:19.760 --> 02:33:26.160]  плюс один. Вот здесь то же самое. Когда я прохожу через вот эту сторону и
[02:33:26.160 --> 02:33:34.120]  прохожу через верхнюю точку вот этой прямой, я делаю плюс один. А если я
[02:33:34.120 --> 02:33:39.640]  прохожу через нижнюю точку, ну вот здесь.
[02:33:41.000 --> 02:33:44.800]  Смотрите, я второй раз прохожу через эту вершину, но при этом вот эта точка
[02:33:44.800 --> 02:33:48.640]  является нижней точкой относительно всей стороны. Понятно? То есть у нее меньше
[02:33:48.640 --> 02:33:59.000]  y координата. Это вообще отдельная история. Пока вот такой пример понятен.
[02:33:59.000 --> 02:34:04.440]  Вот если мы проходим через нижнюю точку стороны, то даем плюс ноль. И в этом
[02:34:04.440 --> 02:34:10.520]  случае какой у меня суммарный баланс? Ну плюс один. А в этом случае что у меня
[02:34:10.520 --> 02:34:17.160]  получается? И эту сторону, и эту сторону я пересекаю по верхней точке, поэтому я и там
[02:34:17.160 --> 02:34:21.760]  и там даю плюс один. Поэтому суммарно получается плюс два. То есть, что у меня
[02:34:21.760 --> 02:34:25.720]  получается? Значит какие варианты возможны? Ну вот есть луч, он может
[02:34:25.720 --> 02:34:30.860]  пересечь вот таким образом, может пересечь вот таким образом, может пересечь вот
[02:34:30.860 --> 02:34:39.640]  таким образом. Тогда здесь насколько у меня изменится счетчик? На ноль. Не пугайтесь, на ноль.
[02:34:40.620 --> 02:34:46.800]  Меня это устраивает? Ну да, устраивает. Почему? Потому что у меня, то вышел я или
[02:34:46.800 --> 02:34:49.520]  вошел в фигуру, зависит только от чётности. В этом случае чётность не поменялась,
[02:34:49.520 --> 02:34:56.000]  собственно, как и нужно. Здесь насколько у меня щечка изменится? На плюс два, потому что обе вершины
[02:34:56.000 --> 02:35:02.920]  верхние, и в этом случае тоже четность не меняется. И только здесь щечка изменится на один, но это
[02:35:02.920 --> 02:35:11.080]  ровно то, чего я хочу. То есть я как бы вышел или вошел в фигуру, все нормально. Ну давайте этот
[02:35:11.080 --> 02:35:24.120]  способ А. Как справляться с подобными коллизиями. Есть альтернативный способ Б. Он может быть даже
[02:35:24.120 --> 02:35:31.440]  несколько проще. Он скорее всего проще. Извлечается он в следующем. Вот смотрите, вот допустим,
[02:35:31.440 --> 02:35:40.800]  у меня есть снова точка, я хочу понять, нахожусь ли я внутри многоугольника,
[02:35:40.800 --> 02:35:47.560]  или нет. Предлагаю сделать следующий вид. Давайте я возьму точку, которая расположена очень-очень
[02:35:47.560 --> 02:35:54.480]  далеко от моей, вот прямо по х, почти на бесконечности. Но при этом с единственным отличием. Вот у этой
[02:35:54.480 --> 02:36:07.280]  точке координаты x и y, у этой точке координаты бесконечность y плюс 1. Ну зачем мне нужно x на
[02:36:07.280 --> 02:36:12.560]  бесконечности? Ну чтобы гарантированно эта точка была за моим многоугольником. Для чего я делаю y
[02:36:12.560 --> 02:36:21.080]  плюс 1? Кто мне ответит? Да, смотрите, теперь если у меня тут y, а тут y плюс 1, то у меня вот эта
[02:36:21.080 --> 02:36:28.680]  прямая, точнее вот этот отрез, гарантированно не пересекает никакую вершину. Потому что у меня
[02:36:28.680 --> 02:36:41.400]  все дискретно, и поэтому промахнулся. Поэтому в этой области ширины 1, у меня точно нет ни одной целой
[02:36:41.400 --> 02:36:48.400]  точки. Поэтому эта проблема вообще выходит с повестки. Единственная проблема, которая тут есть,
[02:36:48.400 --> 02:36:53.280]  это вот эта бесконечность. Ну то есть непонятно, какую ее назначать, и во-вторых, если ее назначать
[02:36:53.280 --> 02:36:56.720]  слишком большой, то у вас может возникнуть ошибка переполнения, что естественно неприятно.
[02:36:56.720 --> 02:37:03.920]  Поэтому выбирайте способ. Ну и вот последний случай, который мы не разобрали, это вот, а что если
[02:37:03.920 --> 02:37:07.360]  у меня вот этот луч, который, ну неважно, там вот таким способом я построил, или вот таким способом,
[02:37:07.360 --> 02:37:18.560]  что если он проходит через сторону? Ну кажется, в этом случае понятно, что делать. Если у меня луч
[02:37:18.560 --> 02:37:35.760]  параллельно стороне, то просто мы ее игнорируем. Ну кажется, и в том, ну неважно, какой у меня случай,
[02:37:35.760 --> 02:37:44.280]  то есть если я прохожу в сторону, мне достаточно ее просто проигнорировать и все. Ну вот. Ну на этом
[02:37:44.280 --> 02:37:49.280]  сегодня все. В следующий раз закончим про наследование и поговорим про выпуклую оболочку.
