[00:00.000 --> 00:16.000]  Так, давайте начнем. Продолжим разговор прошлой лекции. Будем говорить про умные указатели,
[00:16.000 --> 00:22.000]  ну и дальше построим некоторый мост к тому, что будем обсуждать в качестве новой темы сегодня.
[00:22.000 --> 00:29.000]  Прежде всего хочется сказать, что на прошлой лекции мы сделали несколько ошибок, когда писали UniquePTR,
[00:29.000 --> 00:41.000]  а вы все промолчали. А потом будете дизлайки ставить после экзамена. Что тут нужно исправить?
[00:41.000 --> 00:49.000]  Мы писали UniquePTR, что нужно изменить? Во-первых, мы с вами обсуждали, что конструктор перемещения
[00:49.000 --> 00:54.000]  и перемещающее присваивание должны быть noexcept. Пока по непонятным причинам, но вскоре мы поймем,
[00:54.000 --> 01:01.000]  зачем это нужно. В общем, им всегда нужно приписывать noexcept. Это первое.
[01:01.000 --> 01:07.000]  Второе, когда мы писали перемещающее присваивание, мы забыли в качестве первой строки сделать deletePTR.
[01:07.000 --> 01:13.000]  Естественно, что когда вы присваиваете какой-то другой объект, старому объекту, то у старого объекта
[01:13.000 --> 01:20.000]  нужно сначала удалить ресурс. Вот у вас был старый объект, он указывал на какой-то ресурс R.
[01:20.000 --> 01:25.000]  И вы решили присвоить... есть какой-то другой ресурс, не знаю, x.
[01:25.000 --> 01:34.000]  И вы решили... Adr, Vis. Если вы решили Adr присвоить Vis, ну точнее переместить Vis, то понятное дело,
[01:34.000 --> 01:39.000]  что сначала нужно старый ресурс удалить и только потом забрать чужой ресурс.
[01:39.000 --> 01:46.000]  Ну и надо разделать noexcept. OK.
[01:46.000 --> 01:52.000]  Тогда давайте продолжим и вспомним то, на чем остановились в прошлый раз.
[01:52.000 --> 01:58.000]  В прошлый раз мы остановились на проблеме циклических ссылок. Напомню.
[01:58.000 --> 02:03.000]  Допустим, вы решили написать класс двухсвязанного списка и при этом использовать умные указатели sharedPTR.
[02:03.000 --> 02:08.000]  SharedPTR — это умные указатели, которые используют семантику разделяемого владения,
[02:08.000 --> 02:11.000]  то есть на один и тот же ресурс могут указывать сразу несколько умных указателей.
[02:11.000 --> 02:16.000]  Тогда с помощью подсчета ссылок они следят, сколько в данный момент указателей указывает
[02:16.000 --> 02:21.000]  на тот или иной объект, и если в какой-то момент число умных указателей
[02:21.000 --> 02:24.000]  на данный объект обнурилось, мы удаляем сам объект.
[02:24.000 --> 02:28.000]  Мы можем написать класс связанного списка, для этого мы пишем ноду.
[02:28.000 --> 02:32.000]  То есть говорим, что есть указатель на следующий элемент, есть указатель на предыдущий элемент,
[02:32.000 --> 02:36.000]  точнее значение, которое мы храним внутри узла.
[02:36.000 --> 02:38.000]  У нас возникает следующая проблема.
[02:38.000 --> 02:44.000]  Один из sharedPTR указывает на один элемент, и этот же элемент списка указывает на предыдущий.
[02:44.000 --> 02:48.000]  Получается такая замкнутая система, которая указывает сама на себя.
[02:48.000 --> 02:52.000]  То есть один узел указывает на второй узел, а второй указывает на первый узел.
[02:52.000 --> 02:56.000]  В этом случае понятное дело, что, во-первых, не вызовется деструктор для первого узла.
[02:56.000 --> 02:59.000]  Почему? Потому что на него все еще есть какие-то действующие ссылки.
[02:59.000 --> 03:03.000]  И понятное дело, что не вызовется деструктура второго узла, потому что первый узел держит второй,
[03:03.000 --> 03:06.000]  а второй узел держит первый.
[03:06.000 --> 03:09.000]  Поэтому у нас возникает, грубо говоря, утечка памяти.
[03:09.000 --> 03:13.000]  Причем такая утечка памяти, которая никак не фиксится.
[03:13.000 --> 03:15.000]  Это проблема циклических ссылок.
[03:15.000 --> 03:20.000]  Если sharedPTR, грубо говоря, указывает сам на себя, то возникает проблема.
[03:20.000 --> 03:22.000]  Как эта проблема решается?
[03:22.000 --> 03:24.000]  Решается проблема с помощью третьего умного указателя.
[03:24.000 --> 03:26.000]  Это weakPTR.
[03:26.000 --> 03:31.000]  Как мы говорили в прошлый раз, weakPTR – это такой умный указатель, который не учитывается при подсчете сильных ссылок.
[03:31.000 --> 03:35.000]  То есть weakPTR имеет право указывать туда же, куда указывает sharedPTR,
[03:35.000 --> 03:39.000]  но при этом он не является полноправным владельцем этого ресурса.
[03:39.000 --> 03:43.000]  То есть он этим ресурсом не владеет, соответственно, при подсчете ссылок учитываться не должен.
[03:43.000 --> 03:45.000]  Соответственно, как исправить пример связанным списком?
[03:45.000 --> 03:47.000]  Очень просто.
[03:47.000 --> 03:51.000]  Один из указателей, например, который смотрит вперед, мы делаем sharedPTR,
[03:51.000 --> 03:55.000]  а тот указатель, который смотрит назад, мы делаем weakPTR.
[03:55.000 --> 03:58.000]  То есть слабым указателем, который не учитывается при подсчете ссылок.
[03:58.000 --> 04:00.000]  Тогда все нормально.
[04:00.000 --> 04:07.000]  Вот этим узлом владеет предыдущий, а предыдущим следующий не владеет.
[04:07.000 --> 04:11.000]  Поэтому если, скажем, у нас удалились все указатели на начало и конец,
[04:11.000 --> 04:15.000]  то на этот узел указывает ноль указателей, на этот узел указывает один указатель.
[04:15.000 --> 04:20.000]  В тот момент, когда у первого узла счетчик замудрился, мы вызываем для него деструктор.
[04:20.000 --> 04:24.000]  А когда мы вызываем деструктор для первого узла, у нас вызывается деструктор для sharedPTR.
[04:24.000 --> 04:27.000]  Ну а sharedPTR просто-напросто убирает счетчик и говорит, тут ноль.
[04:27.000 --> 04:30.000]  Ну и, соответственно, и так далее. По рекурсии у нас все элементы списка удалятся.
[04:30.000 --> 04:34.000]  Понятно? То есть циклических ссылок теперь нет.
[04:34.000 --> 04:37.000]  Давайте теперь по-другому поговорим про weakPTR, что это такое.
[04:37.000 --> 04:42.000]  Как я сказал, weakPTR на самом деле не владеет тем ресурсом, на который он указывает.
[04:42.000 --> 04:45.000]  И, строго говоря, weakPTR нельзя считать указателем.
[04:45.000 --> 04:48.000]  Потому что что мы на самом деле ожидаем от указателя?
[04:48.000 --> 04:51.000]  От указателя мы ожидаем, что его можно, наверное, разаменовать,
[04:51.000 --> 04:54.000]  и в некоторых ситуациях можно обратиться по стрелочке.
[04:54.000 --> 04:56.000]  То есть можно сделать стрелочки и обратиться к чему-то.
[04:56.000 --> 04:59.000]  Вот weakPTR не такой.
[04:59.000 --> 05:04.000]  weakPTR не дает вам вообще, говоря ничего, не дает вам обратиться к ресурсу.
[05:04.000 --> 05:07.000]  weakPTR вообще, говоря ничего, не знает про ресурс.
[05:07.000 --> 05:09.000]  Вначале что-то знает, но вам об этом не говорит.
[05:09.000 --> 05:13.000]  weakPTR не служит для того, чтобы, первое, узнать, протухли ресурс или нет.
[05:13.000 --> 05:20.000]  То есть weakPTR смотрит на память и говорит вам, вот этот ресурс, он как бы еще жив или уже нет.
[05:20.000 --> 05:25.500]  И, во-вторых, он может вам дать право пользоваться этим ресурсом, вернув вам sharedPtr.
[05:25.500 --> 05:29.500]  То есть, грубо говоря, есть два важных метода для работы свикптр.
[05:29.500 --> 05:33.500]  Это expired, ну, собственно, дословно, протух элемент, пропал элемент,
[05:33.500 --> 05:35.500]  который возвращается в untrue или false.
[05:35.500 --> 05:38.500]  То есть false, если элемент уже протух, а в какой момент элемент протух?
[05:38.500 --> 05:42.500]  Ну, например, вот такой.
[05:42.500 --> 05:46.500]  Значит, вот у вас есть какой-то ресурс r.
[05:47.000 --> 05:51.000]  Есть sharedPtr, который указывает на него, есть wikPtr, который указывает на него.
[05:51.000 --> 05:55.000]  Если вот на этот ресурс нет ни одного sharedPtr, то есть все sharedPtr уже умерли,
[05:55.000 --> 05:59.000]  то есть все сильные ссылки на этот ресурс уже как бы пропали,
[05:59.000 --> 06:02.000]  то в этот момент wikPtr возвращает вам false.
[06:02.000 --> 06:06.000]  Ну, не wikPtr, а, собственно, метод expired.
[06:06.000 --> 06:08.000]  Expired возвращает вам false.
[06:08.000 --> 06:12.000]  А если сильная ссылка жива, хоть какая-то,
[06:12.000 --> 06:15.000]  то он возвращает вам true.
[06:15.500 --> 06:17.500]  В чем отличие expired от не expired?
[06:17.500 --> 06:21.500]  Ну, и в случае, если у вас expired, собственно, равно false,
[06:21.500 --> 06:25.500]  то есть если объект жив, то вы можете попросить у него вернуть вам новый sharedPtr на этот объект
[06:25.500 --> 06:27.500]  с помощью метода log.
[06:27.500 --> 06:29.500]  Ну, то есть как это выглядит?
[06:29.500 --> 06:32.500]  Снова у вас есть ресурс r, на него указывает какой-то sharedPtr,
[06:32.500 --> 06:34.500]  на него указывает какой-то wikPtr.
[06:34.500 --> 06:36.500]  Ну, давайте s1.
[06:36.500 --> 06:38.500]  Если вы понимаете, что данный ресурс еще жив,
[06:38.500 --> 06:40.500]  и вы хотите к нему как-то обратиться через wikPtr,
[06:40.500 --> 06:42.500]  вы можете у wikPtr позвать метод log,
[06:43.000 --> 06:45.000]  и этот метод log вернет вам новый sharedPtr,
[06:45.000 --> 06:47.000]  который указывает на тот же самый ресурс.
[06:47.000 --> 06:49.000]  И уже с этим sharedPtr вы можете делать, что хотите.
[06:49.000 --> 06:52.000]  Можете обращаться там по стрелочке, можете его разуменовывать и так далее.
[06:52.000 --> 06:56.000]  Понятно? То есть wikPtr напрямую не дает вам права пользоваться ресурсом.
[06:56.000 --> 06:58.000]  Он лишь вам может выдать такое право,
[06:58.000 --> 07:00.000]  если вы его попросите.
[07:02.000 --> 07:06.000]  А что если вы позовете log у протухшего указателя?
[07:08.000 --> 07:09.000]  Как вы думаете, что произойдет?
[07:09.000 --> 07:11.000]  Ну, какое бы поведение вы бы ожидали?
[07:11.500 --> 07:13.500]  Что?
[07:13.500 --> 07:15.500]  Ce?
[07:17.500 --> 07:19.500]  Да, ну nullPtr.
[07:19.500 --> 07:22.500]  Соответственно, если вы просите log у уже протухшего указателя,
[07:22.500 --> 07:24.500]  то он возвращает вам nullPtr.
[07:24.500 --> 07:27.500]  Ну, грубо говоря, sharedPtr на nullPtr.
[07:27.500 --> 07:29.500]  Нормально?
[07:29.500 --> 07:33.500]  То есть он возвращает вам умный указатель на нулевой указатель.
[07:33.500 --> 07:36.500]  Значнее, умный указатель, который ведет в никуда.
[07:36.500 --> 07:38.500]  Вот.
[07:38.500 --> 07:40.500]  Такой wikPtr.
[07:41.000 --> 07:43.000]  Теперь главный вопрос.
[07:43.000 --> 07:45.000]  Ну, соответственно,
[07:45.000 --> 07:49.000]  а как wikPtr все-таки понимает, жив объект или нет?
[07:49.000 --> 07:51.000]  Ну, смотрите, в чем проблема?
[07:51.000 --> 07:53.000]  Вот у вас есть ресурс снова.
[07:53.000 --> 07:55.000]  У вас есть sharedPtr, который указывает на этот ресурс.
[07:55.000 --> 07:57.000]  Есть wikPtr, который указывает на этот ресурс.
[07:57.000 --> 08:01.000]  Вот, допустим, sharedPtr умер.
[08:01.000 --> 08:03.000]  Что делает sharedPtr?
[08:03.000 --> 08:05.000]  Что происходит, когда все sharedPtr умирают?
[08:06.000 --> 08:09.000]  Ресурс удаляется, да. То есть мы ресурс удалили.
[08:09.000 --> 08:11.000]  Но у нас есть живой еще wikPtr.
[08:11.000 --> 08:15.000]  А как wikPtr поймет, жив ли ресурс или нет?
[08:23.000 --> 08:27.000]  Это решает другую проблему. Да.
[08:32.000 --> 08:37.000]  Ну, да. Наверное, хотелось бы, чтобы wikPtr просто выставился в ноль. Вы про это.
[08:37.000 --> 08:41.000]  А как вот этот sharedPtr при удалении сможет wikPtr что-то выставить?
[08:41.000 --> 08:45.000]  Тем более, что у нас wikPtr потенциально может быть очень большое количество.
[08:45.000 --> 08:49.000]  Вот этот sharedPtr уже не знает про существование всех wikPtr.
[08:49.000 --> 08:53.000]  Поэтому он у них всех не может зановить указатель.
[08:53.000 --> 08:55.000]  Поэтому это не решение.
[08:55.000 --> 08:59.000]  Что у нас еще хранится, помимо указателя на сам ресурс?
[09:01.000 --> 09:03.000]  В sharedPtr.
[09:03.000 --> 09:07.000]  Счетчик. Счетчик сильных ссылок. Каунтер.
[09:09.000 --> 09:15.000]  Ну и действительно, соответственно, решение заключается в том, чтобы wikPtr,
[09:15.000 --> 09:19.000]  то есть wikPtr, на самом деле, помимо того, что он указывает на ресурс,
[09:19.000 --> 09:21.000]  он еще указывает на счетчик.
[09:21.000 --> 09:25.000]  И вот по этому счетчику, по значению этого счетчика, wikPtr как раз и может понять,
[09:25.000 --> 09:28.000]  собственно, жив объект или нет. Как?
[09:28.000 --> 09:30.000]  Если счетчик не нулевой, если счетчик...
[09:30.000 --> 09:34.000]  Здесь количество сильных ссылок на этот объект еще не ноль,
[09:34.000 --> 09:36.000]  то значит объект не протух.
[09:36.000 --> 09:40.000]  А если счетчик стал равным нулю, то объект протух и им пользоваться нельзя.
[09:40.000 --> 09:44.000]  Нормально или есть какие-то подводные камни?
[09:48.000 --> 09:50.000]  Отлично. Все поняли?
[09:50.000 --> 09:56.000]  Смотрите, wikPtr, на самом деле, в данной конструкции wikPtr никогда не сможет увидеть нулевой счетчик.
[09:56.000 --> 10:00.000]  Почему? Потому что в тот момент, когда у меня умирает последний шар от Ptr,
[10:00.000 --> 10:02.000]  в том алгоритме, который мы обсуждали в прошлый раз,
[10:02.000 --> 10:06.000]  он удаляет не только сам ресурс, но и удаляет счетчик.
[10:06.000 --> 10:12.000]  Поэтому wikPtr в этот момент будет пользоваться не то что протухшим объектом,
[10:12.000 --> 10:14.000]  но даже протухшим счетчиком.
[10:16.000 --> 10:18.000]  Беда.
[10:18.000 --> 10:20.000]  Как решить эту проблему?
[10:20.000 --> 10:30.000]  Отлично. Давайте хранить еще один счетчик. Нормально.
[10:30.000 --> 10:36.000]  Действительно, давайте в одном месте, я так изображу.
[10:36.000 --> 10:40.000]  Strong и wik.
[10:40.000 --> 10:50.000]  Действительно, решение такое, давайте помимо сильного счетчика,
[10:50.000 --> 10:54.000]  давайте дополнительно хранить еще счетчик слабых ссылок.
[10:54.000 --> 11:00.000]  То есть у нас будет отдельно strong counter и отдельно wik counter.
[11:00.000 --> 11:04.000]  Их, естественно, лучше объединить в одну структуру, чтобы не было 3 разных указателя.
[11:04.000 --> 11:06.000]  То есть грубо говоря, мы заводим структ.
[11:06.000 --> 11:08.000]  Он обычно называется контрольный блок,
[11:08.000 --> 11:10.000]  можно назвать просто блок,
[11:10.000 --> 11:20.000]  в котором мы будем хранить sizeT strong и sizeT wik.
[11:20.000 --> 11:22.000]  Без подчеркиваемых.
[11:24.000 --> 11:28.000]  Все, и внутри shardptr вы храните просто-напросто указатель на блок.
[11:28.000 --> 11:40.000]  И у блока можете спросить число сильных ссылок strong или число слабых ссылок wik.
[11:44.000 --> 11:48.000]  То есть счетчик strong, счетчик сильных ссылок хранит вам количество shardptr,
[11:48.000 --> 11:50.000]  которое указывает на данный объект,
[11:50.000 --> 11:54.000]  а wik хранит количество слабых ссылок, которые хранит данный объект,
[11:54.000 --> 11:56.000]  которые указывают на этот объект.
[11:56.000 --> 11:58.000]  Окей, ну хорошо, завели еще один счетчик.
[11:58.000 --> 12:00.000]  То есть тут один, тут один.
[12:00.000 --> 12:02.000]  Что происходит, когда я удаляю shardptr?
[12:02.000 --> 12:06.000]  Ну, количество сильных ссылок у меня зануляется.
[12:06.000 --> 12:08.000]  Что происходит дальше?
[12:08.000 --> 12:10.000]  Да, так у меня число сильных ссылок занудилось,
[12:10.000 --> 12:14.000]  это значит, что все владельцы данного ресурса уже как бы пропали.
[12:14.000 --> 12:18.000]  Поэтому я со спокойной совестью могу вызвать delete ресурс, то есть deleteptr.
[12:18.000 --> 12:20.000]  А что я должен сделать со счетчиком?
[12:20.000 --> 12:22.000]  Должен я удалять счетчик?
[12:22.000 --> 12:24.000]  Нет, почему?
[12:24.000 --> 12:26.000]  Потому что счетчик, вот здесь мы видим,
[12:26.000 --> 12:28.000]  что помимо strong count, то есть strong count 0 равен 0,
[12:28.000 --> 12:30.000]  но при этом есть wik counter,
[12:30.000 --> 12:32.000]  который говорит, что кто-то все еще на этот счетчик указывает.
[12:32.000 --> 12:34.000]  То есть есть какой-то wikptr,
[12:34.000 --> 12:36.000]  который пользуется этим счетчиком,
[12:36.000 --> 12:38.000]  поэтому этот счетчик удалять рано.
[12:38.000 --> 12:40.000]  Окей, а кто должен удалять счетчик?
[12:40.000 --> 12:42.000]  Ну, в данном случае wikptr, да.
[12:42.000 --> 12:44.000]  В данном случае, когда у меня удалится wikptr,
[12:44.000 --> 12:46.000]  он занулит wik counter,
[12:46.000 --> 12:48.000]  и он увидит, что число слабых ссылок и,
[12:48.000 --> 12:50.000]  самое главное, сильных ссылок равно 0,
[12:50.000 --> 12:52.000]  поэтому я спокойно могу удалить счетчик.
[12:52.000 --> 12:54.000]  Счетчик, окей?
[12:54.000 --> 12:56.000]  Поэтому общий алгоритм, ну давайте пропишем
[12:56.000 --> 12:58.000]  как-то в каком-то псевдокоде,
[12:58.000 --> 13:00.000]  выглядит примерно так.
[13:00.000 --> 13:02.000]  Условно, давайте внутри shardptr.
[13:04.000 --> 13:06.000]  Условно я опишу, что если
[13:08.000 --> 13:10.000]  strong
[13:12.000 --> 13:14.000]  если число сильных ссылок равно 0,
[13:16.000 --> 13:18.000]  то я делаю deleteptr.
[13:18.000 --> 13:20.000]  Ну, ptr указывает на ресурс.
[13:22.000 --> 13:24.000]  Вот.
[13:24.000 --> 13:26.000]  Ну и что дальше?
[13:28.000 --> 13:30.000]  Достаточно этого или еще что-то надо сделать?
[13:30.000 --> 13:32.000]  Да, во-первых,
[13:32.000 --> 13:34.000]  понятное дело, надо еще сделать
[13:34.000 --> 13:36.000]  минус-минус блок
[13:36.000 --> 13:38.000]  strong, то есть перед тем, как проверять
[13:38.000 --> 13:40.000]  на ноль, нужно еще сделать
[13:40.000 --> 13:42.000]  минус-минус счетчика.
[13:42.000 --> 13:44.000]  Так, что еще нужно сделать?
[13:46.000 --> 13:48.000]  Ну, точнее, здесь еще
[13:48.000 --> 13:50.000]  можно, например, внутри,
[13:50.000 --> 13:52.000]  лучше добавить, что если
[13:52.000 --> 13:54.000]  дополнительно, то есть понятное дело, что
[13:54.000 --> 13:56.000]  если число сильных ссылок обнулилось,
[13:56.000 --> 13:58.000]  то мы удаляем ресурс.
[13:58.000 --> 14:00.000]  Но плюс нам еще может понадобиться удалить счетчик,
[14:00.000 --> 14:02.000]  в каком случае? Если дополнительные числа
[14:02.000 --> 14:04.000]  слабых ссылок тоже равно 0, согласны?
[14:04.000 --> 14:06.000]  То есть если блок
[14:06.000 --> 14:08.000]  weak равно равно 0
[14:08.000 --> 14:10.000]  дополнительно,
[14:10.000 --> 14:12.000]  то я должен еще сделать delete
[14:12.000 --> 14:14.000]  блок.
[14:16.000 --> 14:18.000]  Все понятно?
[14:18.000 --> 14:20.000]  Ну, и внутри WIC-PTR
[14:20.000 --> 14:22.000]  там
[14:22.000 --> 14:24.000]  логика только
[14:24.000 --> 14:26.000]  со слабыми счетчиками.
[14:26.000 --> 14:28.000]  Что мы делаем в WIC-PTR?
[14:28.000 --> 14:30.000]  Ну, понятное дело, мы делаем минус-минус
[14:30.000 --> 14:32.000]  от блок
[14:32.000 --> 14:34.000]  WIC, то есть уменьшаем
[14:34.000 --> 14:36.000]  количество слабых ссылок.
[14:38.000 --> 14:40.000]  И что делаем?
[14:44.000 --> 14:46.000]  Вот, все понимают,
[14:46.000 --> 14:48.000]  что если сумма сильных и слабых ссылок
[14:48.000 --> 14:50.000]  равно 0, то мы удаляем счетчик.
[14:50.000 --> 14:52.000]  Не достаточно проверить только слабые ссылки.
[14:52.000 --> 14:54.000]  Понятное дело, что нужно проверить вообще все ссылки.
[14:54.000 --> 14:56.000]  Давайте сразу напишу
[14:56.000 --> 14:58.000]  strong
[14:58.000 --> 15:00.000]  plus weak
[15:00.000 --> 15:02.000]  равно равно 0,
[15:02.000 --> 15:04.000]  то мы делаем delete
[15:06.000 --> 15:08.000]  блок.
[15:08.000 --> 15:10.000]  Все.
[15:10.000 --> 15:12.000]  Заметьте, в WIC-PTR не должно быть
[15:12.000 --> 15:14.000]  логики управления ресурсом, то есть
[15:14.000 --> 15:16.000]  WIC за ресурс вообще не отвечает.
[15:16.000 --> 15:18.000]  То есть в WIC-PTR мы не имеем права написать.
[15:18.000 --> 15:20.000]  Потому что WIC-PTR это слабый указатель,
[15:20.000 --> 15:22.000]  он не владеет ресурсом.
[15:22.000 --> 15:24.000]  Ну вот, собственно,
[15:24.000 --> 15:26.000]  примерно так.
[15:26.000 --> 15:28.000]  Разбрались?
[15:28.000 --> 15:30.000]  Ну и последний пункт
[15:30.000 --> 15:32.000]  по умным указателям
[15:32.000 --> 15:34.000]  это функции
[15:34.000 --> 15:36.000]  std
[15:36.000 --> 15:38.000]  makeunique
[15:40.000 --> 15:42.000]  и std
[15:44.000 --> 15:46.000]  makeshard
[15:48.000 --> 15:50.000]  Что это за функция?
[15:50.000 --> 15:52.000]  Ну смотрите, когда мы ввели умные указатели,
[15:52.000 --> 15:54.000]  мы избавили себя от необходимости написать delete.
[15:54.000 --> 15:56.000]  Но тем не менее у нас
[15:56.000 --> 15:58.000]  все еще есть необходимость писать new.
[15:58.000 --> 16:00.000]  Ну для того, чтобы создать умный указатель.
[16:00.000 --> 16:02.000]  То есть как выглядит создание умного указателя?
[16:02.000 --> 16:04.000]  Мы пишем std
[16:04.000 --> 16:06.000]  unique
[16:06.000 --> 16:08.000]  ptr
[16:08.000 --> 16:10.000]  p
[16:10.000 --> 16:12.000]  int
[16:12.000 --> 16:14.000]  и вот этот, собственно, умный указатель.
[16:14.000 --> 16:16.000]  То есть new int.
[16:16.000 --> 16:18.000]  То есть от необходимости писать delete мы избавились,
[16:18.000 --> 16:20.000]  но все еще необходимо писать new.
[16:20.000 --> 16:22.000]  Ну, во-первых, это асимметрично.
[16:22.000 --> 16:24.000]  То есть вроде как мы
[16:24.000 --> 16:26.000]  с самого детства, точнее с первого семестра,
[16:26.000 --> 16:28.000]  привыкли, что на каждое new нужно писать delete.
[16:28.000 --> 16:30.000]  А тут как бы есть new,
[16:30.000 --> 16:32.000]  но при этом delete нет.
[16:32.000 --> 16:34.000]  Это первый момент.
[16:34.000 --> 16:36.000]  Второй момент, если вы используете,
[16:36.000 --> 16:38.000]  если вы сами внутри своей программы используете ручное управление памятью,
[16:38.000 --> 16:40.000]  то все еще возникают
[16:40.000 --> 16:42.000]  сложные проблемы.
[16:42.000 --> 16:44.000]  Ну, мы в прошлый раз, например, обсуждали, что если вы внезапно,
[16:44.000 --> 16:46.000]  то есть не внезапно, а если в какой-нибудь момент вы сохраните
[16:46.000 --> 16:48.000]  какой-нибудь указатель,
[16:48.000 --> 16:50.000]  какой-нибудь сырой указатель на выделенную память,
[16:50.000 --> 16:52.000]  то вы можете создать unique ptr.
[16:52.000 --> 16:54.000]  Давайте тут, бла-бла-бла, ptr1
[16:54.000 --> 16:56.000]  от p
[16:56.000 --> 16:58.000]  и потом можете там забыть или как-то
[16:58.000 --> 17:00.000]  на p может пропасть, может утечь какая-то косвенность,
[17:00.000 --> 17:02.000]  то есть p вы можете куда-то скопировать
[17:02.000 --> 17:04.000]  и так далее, и забыть, что вы этот
[17:04.000 --> 17:06.000]  p на самом деле обернули в какой-то умный указатель
[17:06.000 --> 17:08.000]  и даже спустя какое-то время обернуть его
[17:08.000 --> 17:10.000]  второй раз.
[17:10.000 --> 17:12.000]  Беда.
[17:12.000 --> 17:14.000]  Если вы один тот же указатель обернули в два умных указателя,
[17:14.000 --> 17:16.000]  ну, в два разных умных указателя,
[17:16.000 --> 17:18.000]  то проблема.
[17:18.000 --> 17:20.000]  У вас возникает двойное удаление.
[17:20.000 --> 17:22.000]  Один раз при уничтожении одного умного указателя,
[17:22.000 --> 17:24.000]  второй раз при уничтожении второго умного указателя.
[17:24.000 --> 17:26.000]  Это первая проблема.
[17:26.000 --> 17:28.000]  Вторая возможная проблема
[17:28.000 --> 17:30.000]  на самом деле, она в современных прессах уже пофикшена,
[17:30.000 --> 17:32.000]  но вообще говоря, если вы используете c++14 или ранее,
[17:32.000 --> 17:34.000]  то есть следующая
[17:34.000 --> 17:36.000]  беда.
[17:36.000 --> 17:40.000]  Представь себе, что у вас есть функция, которая принимает два умных указателя.
[17:40.000 --> 17:42.000]  Ну и я просто-напросто делаю следующую вещь.
[17:42.000 --> 17:54.000]  Я туда передаю std unicptr от int new int.
[17:54.000 --> 17:58.000]  Вот, это первый аргумент. И в качестве второго аргумента передаю то же самое.
[17:58.000 --> 18:06.000]  Unicptr от int, ну и какое-то другое new int.
[18:06.000 --> 18:10.000]  В чем здесь может быть проблема?
[18:10.000 --> 18:13.000]  Проблема довольно интересная и довольно неожиданная.
[18:13.000 --> 18:20.000]  Смотрите. Дело в том, что DOSI++17, DOSI++11, DOSI++14 и более ранние версии, они,
[18:20.000 --> 18:26.000]  вообще говоря, в данном примере они не задавали строго порядок вычисления
[18:26.000 --> 18:29.000]  операндов и порядок вычисления операндов внутри операндов.
[18:29.000 --> 18:32.000]  То есть, грубо говоря, что у вас могло произойти?
[18:32.000 --> 18:35.000]  Чисто теоретически у вас может произойти следующее.
[18:35.000 --> 18:40.000]  Сначала у вас вызывается операция new int, которая находится в первом аргументе.
[18:40.000 --> 18:42.000]  Ну или во втором аргументе, неважно.
[18:42.000 --> 18:46.000]  Вот допустим, произошел new int в первом аргументе.
[18:46.000 --> 18:51.000]  А потом, то есть компилятор вообще раньше не гарантировал, что вот это вот выражение,
[18:51.000 --> 18:53.000]  которое стоит здесь, оно будет вычисляться полностью.
[18:53.000 --> 18:56.000]  Он может частично выполнить new int, то есть выделить память,
[18:56.000 --> 19:00.000]  а потом перейти и выделить память для вот этого new int.
[19:00.000 --> 19:03.000]  Ну, например, компилятор так соптимизировал, ему так удобнее.
[19:03.000 --> 19:06.000]  То есть ему гораздо выгоднее, например, вызвать два раза подряд new,
[19:06.000 --> 19:09.000]  чем сначала вызвать new, потом конструктор ptr, потом снова new и ptr.
[19:09.000 --> 19:12.000]  То есть он мог сначала вызвать первый new, потом второй new,
[19:12.000 --> 19:17.000]  и только во вторую очередь вызвать конструктор этого new ptr и конструктор этого new ptr.
[19:17.000 --> 19:21.000]  В чем может быть проблема вот в таком сценарии?
[19:23.000 --> 19:35.000]  Ну, например, самое простое, что может произойти, это вот вы вызвали тут new,
[19:35.000 --> 19:38.000]  а для второго new у вас, допустим, памяти не хватило.
[19:38.000 --> 19:41.000]  И, на самом деле, когда происходит какая-то нештатная ситуация,
[19:41.000 --> 19:43.000]  она как бы не сразу приводит к завершению программы,
[19:43.000 --> 19:45.000]  вы, в принципе, можете эту ситуацию обработать.
[19:45.000 --> 19:47.000]  То есть если вы понимаете, что вам памяти не хватает,
[19:47.000 --> 19:50.000]  вы, грубо говоря, можете, мы об этом будем говорить уже в следующий раз,
[19:50.000 --> 19:53.000]  вы можете обработать эту ошибку и продолжить работать дальше.
[19:53.000 --> 19:55.000]  Но вот какая проблема.
[19:55.000 --> 20:01.000]  Допустим, вот эта штука отработала нормально, а вот здесь пошло что-то не так.
[20:01.000 --> 20:03.000]  Ну, у вас не хватило памяти.
[20:03.000 --> 20:06.000]  Даже если вы эту ошибку обработали, что у вас произошло?
[20:06.000 --> 20:09.000]  У вас произошла утечка памяти. Почему?
[20:09.000 --> 20:13.000]  Потому что вот этот new, вот этот указатель, вы никуда не сохранили.
[20:13.000 --> 20:18.000]  Он у вас создался, подставился вместо вызвана, при этом сам unique ptr вызвал не был.
[20:18.000 --> 20:22.000]  А так он вызван не был, то понятное дело, что для него и деструктор вызван не будет.
[20:22.000 --> 20:24.000]  Понятно?
[20:24.000 --> 20:27.000]  То есть у вас один ресурс выделился, второй не смог выделиться,
[20:27.000 --> 20:30.000]  и первый провис, то есть первый утек, ну совсем.
[20:30.000 --> 20:36.000]  Опять же, повторюсь, что в 17 стандарте это уже не ошибка,
[20:36.000 --> 20:38.000]  потому что там уже есть более строгая гарантия,
[20:38.000 --> 20:41.000]  что у вас каждый оперант вычисляется, грубо говоря, атомарно.
[20:41.000 --> 20:44.000]  То есть без вычислений одного из оперантов следующие не вычисляются.
[20:44.000 --> 20:46.000]  На тем не менее такая проблема была.
[20:46.000 --> 20:54.000]  Так вот, чтобы победить эту проблему, были в язык введены следующие функции makeUnique и makeSharif.
[20:54.000 --> 20:56.000]  Значит, как они работают?
[20:56.000 --> 20:58.000]  Давайте еще раз повторим.
[20:58.000 --> 21:06.000]  Вот, допустим, у вас есть std unique ptr на какую-нибудь структуру A.
[21:06.000 --> 21:11.000]  На какую-нибудь структуру A указатель p.
[21:11.000 --> 21:17.000]  Значит, вы создаете объект, ну примерно вот таким способом A, X, Z.
[21:17.000 --> 21:19.000]  Ну что здесь происходит?
[21:19.000 --> 21:24.000]  Вы выделяете в памяти объект A с помощью параметра конструктора X, Y, Z.
[21:24.000 --> 21:28.000]  То есть вы передаете в конструктор A параметры X, Y, Z и создаете новый объект в куче.
[21:28.000 --> 21:31.000]  И создаете на него умный указатель.
[21:31.000 --> 21:34.000]  Как выглядит тот же самый код, но с использованием makeUnique?
[21:34.000 --> 21:36.000]  Очень просто. Вы делаете следующие вещи.
[21:36.000 --> 21:50.000]  Aftp равно std makeUnique, тут треугольные скобки, makeUnique от A.
[21:50.000 --> 21:55.000]  И передаете в параметры этой функции X, Y, Z.
[21:55.000 --> 21:58.000]  То есть что такое makeUnique?
[21:58.000 --> 22:02.000]  makeUnique – это шаблонная функция, которая в качестве шаблонного параметра
[22:02.000 --> 22:07.000]  принимает тип, на который нужно создать uniquePTR.
[22:07.000 --> 22:10.000]  То есть давайте с самого начала.
[22:10.000 --> 22:14.000]  makeUnique – это функция, которая порождает новые умные указатели.
[22:14.000 --> 22:17.000]  То есть makeUnique возвращает uniquePTR.
[22:17.000 --> 22:21.000]  В качестве шаблонного параметра она принимает тип,
[22:21.000 --> 22:23.000]  с которым нужно создать uniquePTR.
[22:23.000 --> 22:27.000]  В данном случае makeUnique от A вернет вам std uniquePTR от A.
[22:27.000 --> 22:29.000]  А что она принимает в качестве параметров?
[22:29.000 --> 22:31.000]  Она принимает параметры параметров.
[22:31.000 --> 22:34.000]  А в качестве параметров внезапно она принимает параметры конструктора,
[22:34.000 --> 22:37.000]  которые нужно будет передать в A.
[22:37.000 --> 22:46.000]  То есть вот тут параметры конструктора A.
[22:46.000 --> 22:52.000]  Грубо говоря, эта вторая строка дословно повторяет то же самое, что здесь.
[22:52.000 --> 22:56.000]  Но при этом она лишна недостатка, в котором мы описали до этого.
[22:56.000 --> 22:59.000]  В той строке вы не пишете вручную new.
[22:59.000 --> 23:01.000]  То есть вы вызываете просто некоторую функцию makeUnique,
[23:01.000 --> 23:04.000]  которая вам возвращает нужный uniquePTR.
[23:04.000 --> 23:06.000]  То есть new вы вручную не пишете.
[23:06.000 --> 23:09.000]  И из этого же следует решение второй проблемы.
[23:09.000 --> 23:13.000]  Так как вы не пишете new, то все выделение происходит внутри функции makeUnique.
[23:13.000 --> 23:15.000]  И эта функция makeUnique, если там внутри что-то идет не так,
[23:15.000 --> 23:21.000]  она сама может почистить всю нужную память и продолжить нормальную работу.
[23:21.000 --> 23:23.000]  Вот такие дела.
[23:23.000 --> 23:29.000]  Ну и, собственно, аналогично есть функция std makeShared,
[23:29.000 --> 23:34.000]  который работает... принцип работы которой такой же.
[23:34.000 --> 23:40.000]  Она принимает нужный вам тип и принимает аргументы конструктора x, y, z.
[23:46.000 --> 23:49.000]  Правда, тут при этом есть небольшая тонкость,
[23:49.000 --> 23:54.000]  что получается в том, что makeShared на самом деле действует немного иначе.
[23:54.000 --> 23:58.000]  Ну давайте об этом тоже поговорим, чтобы была полная картина.
[23:58.000 --> 24:09.000]  Что происходит, когда вы создаете sharedPTR от какого-нибудь new int?
[24:09.000 --> 24:11.000]  Ну что у вас происходит?
[24:11.000 --> 24:14.000]  У вас вот этот указатель, то есть у вас есть некоторый int,
[24:14.000 --> 24:18.000]  вот этот указатель сохраняется в поле PTR,
[24:18.000 --> 24:22.000]  и при этом выделяется блок, собственно, счетчики,
[24:22.000 --> 24:26.000]  на которые указывает поле блок.
[24:29.000 --> 24:32.000]  И вот эти два ресурса, то есть то, что вы выделили,
[24:32.000 --> 24:36.000]  и счетчик, и счетчики, они лежат абсолютно в разных частях памяти.
[24:38.000 --> 24:42.000]  Понимаете ли вы, к чему это может привести, в чем потенциальная проблема?
[24:44.000 --> 24:47.000]  Ну потенциальная проблема на самом деле в неэффективности.
[24:47.000 --> 24:50.000]  То есть обращение к разным участкам памяти,
[24:50.000 --> 24:53.000]  то есть так называемые прыжки по памяти, они довольно неэффективны.
[24:53.000 --> 24:57.000]  Ну то есть, грубо говоря, что нужно делать вашему компьютеру?
[24:57.000 --> 24:59.000]  То есть когда вы обращаетесь к одному участку памяти,
[24:59.000 --> 25:02.000]  он, понятное дело, он загружает не только ту ячейку памяти, которую вы просили,
[25:02.000 --> 25:04.000]  то есть не только 4 байта, то есть как бы он не дурак,
[25:04.000 --> 25:08.000]  он как бы берет сразу большой кусок и загружает там в кэш.
[25:08.000 --> 25:12.000]  И дальше при работе с этим кэшом все происходит гораздо более эффективнее,
[25:12.000 --> 25:15.000]  потому что вам не нужно заново лезть в оперативную память.
[25:15.000 --> 25:20.000]  И это происходит, если у вас все переменные расположены в одной и той же области памяти.
[25:20.000 --> 25:26.000]  Например, это стековые переменные, или, например, если это динамический массив.
[25:26.000 --> 25:29.000]  То есть в динамический массив вы можете сразу загрузить несколько ячей к памяти
[25:29.000 --> 25:31.000]  и работать с ними подряд.
[25:31.000 --> 25:34.000]  Это гораздо эффективнее, чем просто прыгать по массиву.
[25:34.000 --> 25:36.000]  Можете в этом убедиться, там поставятся соответствующие эксперименты.
[25:36.000 --> 25:38.000]  Если вы обращаетесь к разным участкам памяти,
[25:38.000 --> 25:41.000]  которые расположены потенциально на большом расстоянии друг от друга,
[25:41.000 --> 25:43.000]  то у вас происходит следующая вещь.
[25:43.000 --> 25:47.000]  Когда вы обращаетесь к ресурсу, вы загружаете какой-то кусок памяти в кэш.
[25:47.000 --> 25:49.000]  Когда вы обращаетесь к другой, то есть к блоку,
[25:49.000 --> 25:52.000]  вам снова нужно взять и этот кусок памяти загрузить в кэш.
[25:52.000 --> 25:55.000]  Понятно дело, что это все работает за единицу,
[25:55.000 --> 25:57.000]  но вообще говоря это работает сильно дольше,
[25:57.000 --> 26:00.000]  чем если бы вы взяли и все единым блоком занесли в кэш и с ним работали.
[26:00.000 --> 26:03.000]  Ну и такая чисто техническая деталь, надеюсь, понятна.
[26:04.000 --> 26:07.000]  И поэтому MakeSharad, он это учитывает
[26:09.000 --> 26:11.000]  и делает на самом деле умнее.
[26:11.000 --> 26:15.000]  Вот у MakeSharad, когда вы пишете просто sharedptr от new что-то там,
[26:15.000 --> 26:19.000]  то есть у конструктора нет ни единого шанса выделить все единым блоком.
[26:19.000 --> 26:22.000]  Потому что вы этот int выделили где-то в одном месте,
[26:22.000 --> 26:25.000]  и он не может просто так взять и блок приписать сюда.
[26:25.000 --> 26:27.000]  Ну по понятным причинам.
[26:27.000 --> 26:29.000]  Потому что вы выделяете память с помощью new,
[26:29.000 --> 26:31.000]  у вас операционная система что даст, то даст.
[26:31.000 --> 26:33.000]  А вы этим никак не управляете.
[26:34.000 --> 26:36.000]  Тем не менее MakeSharad может это сделать.
[26:36.000 --> 26:38.000]  Что делает MakeSharad?
[26:38.000 --> 26:41.000]  MakeSharad просто-напросто берет и сразу выделяет единым куском
[26:41.000 --> 26:44.000]  нужное количество памяти для хранения ресурса
[26:46.000 --> 26:48.000]  и для хранения блока.
[26:50.000 --> 26:52.000]  То есть он сразу выделяет столько bytes, сколько им нужно
[26:52.000 --> 26:54.000]  для хранения и ресурса, и блока,
[26:54.000 --> 26:56.000]  и дальше в первой части хранит ресурс,
[26:56.000 --> 26:59.000]  а в второй части хранит блок со счетчиками.
[26:59.000 --> 27:02.000]  Это получается более эффективно по времени использования.
[27:06.000 --> 27:09.000]  У этого тоже есть, собственно, свой минус.
[27:09.000 --> 27:11.000]  И он связан с тем, что
[27:11.000 --> 27:14.000]  при условии, что если у вас есть еще и WeakPtr,
[27:14.000 --> 27:18.000]  то вот представьте, что у вас есть и SharePtr,
[27:18.000 --> 27:20.000]  который указывает сюда,
[27:20.000 --> 27:22.000]  и WeakPtr, который указывает сюда.
[27:23.000 --> 27:25.000]  Когда у вас удаляется SharePtr,
[27:25.000 --> 27:27.000]  он, естественно, может удалить ресурс.
[27:27.000 --> 27:29.000]  Он может вызвать деструктуру ресурса.
[27:29.000 --> 27:31.000]  Но при этом вот весь большой кусок памяти
[27:31.000 --> 27:33.000]  он удалить не может. Почему?
[27:33.000 --> 27:35.000]  Потому что весь большой кусок памяти
[27:35.000 --> 27:37.000]  он выделял единым блоком,
[27:37.000 --> 27:39.000]  грубо говоря, с помощью new.
[27:39.000 --> 27:41.000]  И поэтому удалить его тоже можно только
[27:41.000 --> 27:43.000]  с помощью единой операции delete.
[27:44.000 --> 27:46.000]  И поэтому пока у вас жива WeakPtr,
[27:46.000 --> 27:48.000]  вот этот вот участок памяти,
[27:48.000 --> 27:50.000]  он так и будет висеть у вас в памяти до тех пор,
[27:50.000 --> 27:52.000]  пока все WeakPtr не удалятся.
[27:52.000 --> 27:54.000]  В этом подходе такой проблемы нет.
[27:54.000 --> 27:56.000]  Вы можете сразу удалить там и память,
[27:56.000 --> 27:58.000]  и ресурс, и все будет нормально.
[27:58.000 --> 28:00.000]  Так что тут есть такой вот трейд-оп
[28:00.000 --> 28:02.000]  между тем, что у вас все работает быстрее,
[28:02.000 --> 28:04.000]  если вы используете такой подход.
[28:04.000 --> 28:06.000]  Но с другой стороны у вас работает
[28:06.000 --> 28:08.000]  как бы, возможно, потенциально неэффективно
[28:08.000 --> 28:10.000]  по памяти, потому что у вас вот этот ресурс
[28:10.000 --> 28:12.000]  может висеть совместно с этим блоком,
[28:12.000 --> 28:14.000]  пока все WeakPtr не удалятся.
[28:14.000 --> 28:16.000]  Ну, это же такие-таки
[28:16.000 --> 28:18.000]  технические детали. В общем, если что-то понятно
[28:18.000 --> 28:20.000]  хорошо, если нет, то ну...
[28:20.000 --> 28:22.000]  Ну и ладно.
[28:22.000 --> 28:24.000]  Надеюсь, все понятно, да?
[28:24.000 --> 28:26.000]  Все нормально?
[28:28.000 --> 28:30.000]  Окей.
[28:30.000 --> 28:32.000]  Ну, видимо, на этом
[28:32.000 --> 28:34.000]  с умными указателями все.
[28:34.000 --> 28:36.000]  Единственное надо было сделать дисклеймер,
[28:36.000 --> 28:38.000]  про который я забыл. Вот на самом деле
[28:38.000 --> 28:40.000]  писать всякие
[28:40.000 --> 28:42.000]  деревья, всякие списки
[28:42.000 --> 28:44.000]  на умных указателях, это
[28:44.000 --> 28:46.000]  честно говоря, не очень хорошая идея.
[28:46.000 --> 28:48.000]  Ну, точнее как. Это нормальная идея,
[28:48.000 --> 28:50.000]  но следует помнить вот о чем.
[28:50.000 --> 28:52.000]  Ну, давайте так.
[28:52.000 --> 28:54.000]  Давайте представим себе, что вы написали
[28:54.000 --> 28:56.000]  односвязанный список.
[28:58.000 --> 29:00.000]  Односвязанный список на умных указателях.
[29:00.000 --> 29:02.000]  Чем хорошо
[29:02.000 --> 29:04.000]  используется списка
[29:04.000 --> 29:06.000]  на умных указателях?
[29:06.000 --> 29:08.000]  Ну, вам не нужно писать деструктор, согласны?
[29:08.000 --> 29:10.000]  Ну, потому что когда у вас
[29:10.000 --> 29:12.000]  будет вызван деструктор, у вас автоматически вызовется
[29:12.000 --> 29:14.000]  деструктор у умного указателя, который
[29:14.000 --> 29:16.000]  там владеет, собственно, началом списка.
[29:16.000 --> 29:18.000]  И дальше рекурсивно у вас вызовется
[29:18.000 --> 29:20.000]  деструктор для всех умных указателей.
[29:20.000 --> 29:22.000]  И весь список автоматически
[29:22.000 --> 29:24.000]  удалится.
[29:24.000 --> 29:26.000]  Тут, возможно, проблема какая?
[29:26.000 --> 29:28.000]  В чем проблема вот такого
[29:28.000 --> 29:30.000]  рекурсивного удаления?
[29:34.000 --> 29:36.000]  Ну нет, такого мы не можем сделать.
[29:36.000 --> 29:38.000]  У нас как бы удаление в деструкторе запустится
[29:38.000 --> 29:40.000]  только. Ну, по идее.
[29:40.000 --> 29:42.000]  Чему обычно равен размер списка?
[29:42.000 --> 29:44.000]  Ну, необычно, но вот потенциально.
[29:44.000 --> 29:46.000]  Ну, долго...
[29:46.000 --> 29:48.000]  Если у вас большой список, у вас как бы удаление долго
[29:48.000 --> 29:50.000]  это как бы априори.
[29:50.000 --> 29:52.000]  То есть, тут вы физику не обманете.
[29:52.000 --> 29:54.000]  Тут проблема другая.
[29:54.000 --> 29:56.000]  Вот, допустим, у вас список на миллион элементов.
[29:56.000 --> 29:58.000]  В чем проблема такой рекурсии?
[30:00.000 --> 30:02.000]  Стэк оверфлоу.
[30:02.000 --> 30:04.000]  Ну, грубо говоря, у вас размер стэка ограничен.
[30:04.000 --> 30:06.000]  Там, ну,
[30:06.000 --> 30:08.000]  если у вас большой список,
[30:08.000 --> 30:10.000]  то размер стэка ограничен.
[30:10.000 --> 30:12.000]  Короче, точно не миллион.
[30:12.000 --> 30:14.000]  То есть, точно миллион рекурсивных вызовов
[30:14.000 --> 30:16.000]  деструктора он не выдержит.
[30:16.000 --> 30:18.000]  Поэтому вот такое вот рекурсивное удаление
[30:18.000 --> 30:20.000]  может привести к стэку оверфлоу и беда.
[30:20.000 --> 30:22.000]  Поэтому даже если вы
[30:22.000 --> 30:24.000]  держите умные указатели
[30:24.000 --> 30:26.000]  на элементы списка,
[30:26.000 --> 30:28.000]  то деструктор для списка, к сожалению,
[30:28.000 --> 30:30.000]  все еще нужно писать вручную.
[30:30.000 --> 30:32.000]  Ну, для того, чтобы избежать вот такого рекурсивного вызова.
[30:32.000 --> 30:34.000]  То есть, вы просто-напросто вручную прописываете цикл,
[30:34.000 --> 30:36.000]  в котором в цикле проходите по всем элементам
[30:36.000 --> 30:38.000]  и, грубо говоря, очищаете эти самые умные указатели.
[30:38.000 --> 30:40.000]  Понятно?
[30:40.000 --> 30:42.000]  Поэтому
[30:42.000 --> 30:44.000]  будьте осторожны.
[30:44.000 --> 30:46.000]  Есть такая проблема.
[30:46.000 --> 30:48.000]  Хорошо.
[30:48.000 --> 30:50.000]  Теперь давайте перейдем к
[30:50.000 --> 30:52.000]  теме сегодняшних
[30:52.000 --> 30:54.000]  лекций, то есть,
[30:54.000 --> 30:56.000]  о чем я хотел сегодня поговорить.
[30:56.000 --> 30:58.000]  И, в общем, эти темы, они тесно связаны
[30:58.000 --> 31:00.000]  с тем, что есть на этом слайде.
[31:00.000 --> 31:02.000]  Смотрите, давайте обратим внимание
[31:02.000 --> 31:04.000]  вот сюда.
[31:04.000 --> 31:06.000]  Вот, когда я написал такую штуку,
[31:06.000 --> 31:08.000]  у вас должно было
[31:08.000 --> 31:10.000]  взыграть,
[31:10.000 --> 31:12.000]  ну, если не любопытство, то хотя бы
[31:12.000 --> 31:14.000]  программатизм. Вы могли сказать,
[31:14.000 --> 31:16.000]  у нас задание
[31:16.000 --> 31:18.000]  есть в качестве одной из частей
[31:18.000 --> 31:20.000]  написать Make Unique и Make Sharad.
[31:20.000 --> 31:22.000]  И у вас мог возник вопрос какой?
[31:24.000 --> 31:26.000]  Что?
[31:28.000 --> 31:30.000]  У нас должен быть
[31:30.000 --> 31:32.000]  возник вопрос, а как?
[31:32.000 --> 31:34.000]  Как реализовать функцию
[31:34.000 --> 31:36.000]  Make Unique?
[31:36.000 --> 31:38.000]  Смотрите, это довольно странная функция.
[31:38.000 --> 31:40.000]  Потому что...
[31:40.000 --> 31:42.000]  Давайте попробуем
[31:42.000 --> 31:44.000]  написать.
[31:44.000 --> 31:46.000]  Я пишу Make Unique.
[31:46.000 --> 31:48.000]  Вроде как утверждается,
[31:48.000 --> 31:50.000]  что она шаблонная.
[31:50.000 --> 31:52.000]  template
[31:52.000 --> 31:54.000]  class
[31:54.000 --> 31:56.000]  t. Она шаблонная.
[31:56.000 --> 31:58.000]  Она должна делать
[31:58.000 --> 32:00.000]  return,
[32:00.000 --> 32:02.000]  track.
[32:02.000 --> 32:04.000]  Здесь моя Make Unique птеро t.
[32:04.000 --> 32:06.000]  Вродеsee, с этим проблем нет.
[32:06.000 --> 32:08.000]  А что она принимает?
[32:08.000 --> 32:10.000]  Я сказал что она принимает параметры
[32:10.000 --> 32:12.000]  конструктора t,
[32:12.000 --> 32:14.000]  то есть в данном случае параметры конструктора A.
[32:14.000 --> 32:16.000]  А откуда Make Unique
[32:16.000 --> 32:18.000]  знает какие параметры у конструктора A?
[32:18.000 --> 32:20.000]  Ну, потенциально у A
[32:20.000 --> 32:22.000]  какие могут быть параметры? У A
[32:22.000 --> 32:24.000]  может быть 0 параметров.
[32:24.000 --> 32:26.000]  У А может вообще много конструкторов.
[32:26.000 --> 32:28.000]  У А может быть metric с yyim параметром,
[32:28.000 --> 32:30.000]  с одним параметром, с двумя параметрами, с тремя.
[32:30.000 --> 32:32.000]  Может быть, copy-конструктор, может быть, move-конструктор.
[32:32.000 --> 32:34.000]  И все эти опции makeunique,
[32:34.000 --> 32:36.000]  вообще говоря, должен поддерживать.
[32:36.000 --> 32:38.000]  То есть, вообще говоря, makeunique
[32:38.000 --> 32:40.000]  должен уметь принимать
[32:40.000 --> 32:42.000]  произвольное количество аргументов.
[32:42.000 --> 32:44.000]  Вас это не шокирует?
[32:44.000 --> 32:46.000]  Нет?
[32:46.000 --> 32:48.000]  Все нормально.
[32:48.000 --> 32:50.000]  Как написать функцию,
[32:50.000 --> 32:52.000]  которая принимает произвольное количество аргументов?
[32:52.000 --> 32:54.000]  Хоть пять, хоть десять, хоть сто.
[32:54.000 --> 32:56.000]  Понятное дело, что вручную
[32:56.000 --> 32:58.000]  из двух функций мы писать не будем.
[32:58.000 --> 33:00.000]  И вот как мы это будем делать,
[33:00.000 --> 33:02.000]  сейчас об этом поговорим.
[33:02.000 --> 33:04.000]  Значит,
[33:04.000 --> 33:06.000]  шаблоны с переменным
[33:06.000 --> 33:08.000]  числом аргументов
[33:08.000 --> 33:10.000]  или variadic-templates.
[33:12.000 --> 33:14.000]  Ну, проблемы я уже обрисовал.
[33:14.000 --> 33:16.000]  Мы хотим написать функцию,
[33:16.000 --> 33:18.000]  которая работает примерно так же,
[33:18.000 --> 33:20.000]  как makeunique или std.printf.
[33:20.000 --> 33:22.000]  Вот printf еще один пример функции,
[33:22.000 --> 33:24.000]  уже из языка C,
[33:24.000 --> 33:26.000]  который может принимать
[33:26.000 --> 33:28.000]  произвольное количество аргументов.
[33:28.000 --> 33:30.000]  То есть вы пишете какой-то формат строку,
[33:30.000 --> 33:32.000]  то есть в каком формате вам нужно вводить данные,
[33:32.000 --> 33:34.000]  и дальше через запятую указываете те данные,
[33:34.000 --> 33:36.000]  которые нужно вводить на экран.
[33:36.000 --> 33:38.000]  И при этом printf может принимать произвольное количество аргументов.
[33:38.000 --> 33:40.000]  Вот как она работает?
[33:40.000 --> 33:42.000]  Ну, пока непонятно.
[33:42.000 --> 33:44.000]  Makeunique, то же самое.
[33:44.000 --> 33:46.000]  Вот как раз тот пример, про который я говорил.
[33:46.000 --> 33:48.000]  У A может быть потенциально много конструкторов.
[33:48.000 --> 33:50.000]  В данном случае у меня все параметры конструктора
[33:50.000 --> 33:52.000]  здесь они дефолтные.
[33:52.000 --> 33:54.000]  То есть я потенциально вот этот конструктор
[33:54.000 --> 33:56.000]  могу вызывать с нулем числом аргументов,
[33:56.000 --> 33:58.000]  с одним аргументом, с двумя, с тремя.
[33:58.000 --> 34:00.000]  И при этом каждый из makeunique при этом работает.
[34:00.000 --> 34:02.000]  Как это работает?
[34:02.000 --> 34:04.000]  Ну, пока непонятно.
[34:04.000 --> 34:06.000]  Один слайд,
[34:06.000 --> 34:08.000]  чисто для истории,
[34:08.000 --> 34:10.000]  это экскурс
[34:10.000 --> 34:12.000]  в язык C, мы этим пользоваться не будем.
[34:12.000 --> 34:14.000]  В языке C
[34:16.000 --> 34:18.000]  функции с произвольным числом аргументов
[34:18.000 --> 34:20.000]  пишутся следующим образом.
[34:20.000 --> 34:22.000]  То есть произвольное число аргументов
[34:22.000 --> 34:24.000]  указывается с помощью специального оператора
[34:24.000 --> 34:26.000]  многоточий или эллипсис.
[34:26.000 --> 34:28.000]  То есть он выступает в качестве
[34:28.000 --> 34:30.000]  последнего параметра функции
[34:30.000 --> 34:32.000]  и носит некоторый особый смысл.
[34:32.000 --> 34:34.000]  То есть это троеточие означает, что вот туда
[34:34.000 --> 34:36.000]  вы можете загнать все что угодно
[34:36.000 --> 34:38.000]  и произвольное количество аргументов.
[34:38.000 --> 34:40.000]  Как всем-всем пользоваться? На самом деле не очень удобно.
[34:40.000 --> 34:42.000]  Делается это так.
[34:42.000 --> 34:44.000]  Вы заводите специальную переменную,
[34:44.000 --> 34:46.000]  которая имеет тип va list.
[34:46.000 --> 34:48.000]  То есть в вариаде arguments list.
[34:48.000 --> 34:50.000]  Список произвольного числа аргументов.
[34:50.000 --> 34:52.000]  Дальше вы пишете
[34:52.000 --> 34:54.000]  специальную функцию va start,
[34:54.000 --> 34:56.000]  которая грубо говоря
[34:56.000 --> 34:58.000]  инициализирует этот список.
[34:58.000 --> 35:00.000]  То есть она использует какую-то магию,
[35:00.000 --> 35:02.000]  и все аргументы, которые передали,
[35:02.000 --> 35:04.000]  она берет и запихивает в некоторый список.
[35:04.000 --> 35:06.000]  При этом вы должны заранее знать размер этого списка,
[35:06.000 --> 35:08.000]  что уже как бы наталкивает на мысль,
[35:08.000 --> 35:10.000]  что это не особо удобно.
[35:10.000 --> 35:12.000]  То есть вы должны заранее указывать,
[35:12.000 --> 35:14.000]  какое количество аргументов вы туда передали.
[35:14.000 --> 35:16.000]  Или как-то ваши функции должны быть поднимать.
[35:16.000 --> 35:18.000]  Вы туда не передаете количество аргументов,
[35:18.000 --> 35:20.000]  но при этом printf понимает, сколько аргументов нужно и принять
[35:20.000 --> 35:22.000]  с помощью вот этих вот...
[35:24.000 --> 35:26.000]  с помощью вот этой последовательности.
[35:26.000 --> 35:28.000]  То есть тут вы говорите,
[35:28.000 --> 35:30.000]  что printf должен вывести на экран три значения.
[35:30.000 --> 35:32.000]  То есть целое значение,
[35:32.000 --> 35:34.000]  значение с плавающей точкой и строку.
[35:34.000 --> 35:38.000]  Поэтому функция printf ожидает от вас три аргумента.
[35:38.000 --> 35:40.000]  Идем далее.
[35:40.000 --> 35:42.000]  Ну и дальше, например, в цикле, если вы пишете функцию print int,
[35:42.000 --> 35:44.000]  которая печатает на экран int,
[35:44.000 --> 35:46.000]  то здесь есть следующая вещь.
[35:46.000 --> 35:48.000]  Ну, собственно, в цикле вызываете va-arq,
[35:48.000 --> 35:52.000]  ну va-arq возвращает вам очередной аргумент функции.
[35:52.000 --> 35:54.000]  То есть вот вы инициализировали список,
[35:54.000 --> 35:58.000]  и с помощью va-arq вы получаете очередной элемент вашего списка.
[35:58.000 --> 36:00.000]  При этом вы должны явно указывать,
[36:00.000 --> 36:02.000]  опять же довольно странно,
[36:02.000 --> 36:04.000]  вы в качестве параметра функции указываете еще и тип.
[36:04.000 --> 36:06.000]  В общем, это совсем что-то дикое.
[36:06.000 --> 36:08.000]  Короче, вы должны прям четко знать,
[36:08.000 --> 36:10.000]  какой тип вам пришел.
[36:10.000 --> 36:12.000]  В данном случае мы откуда-то знаем,
[36:12.000 --> 36:14.000]  что нам приходит только int.
[36:14.000 --> 36:16.000]  Поэтому мы тут пишем int.
[36:16.000 --> 36:18.000]  Ну и дальше вводим на экран.
[36:18.000 --> 36:20.000]  Ну и дальше по завершению работы мы должны не забыть написать va-end.
[36:20.000 --> 36:22.000]  То есть мы закончили работу со списком,
[36:22.000 --> 36:24.000]  заканчиваем работу.
[36:24.000 --> 36:26.000]  Ну и то же самое с sum-doubles,
[36:26.000 --> 36:28.000]  то есть если вы хотите посчитать сумму чисел с плавающей точкой,
[36:28.000 --> 36:30.000]  ну примерно такой же ситексис тоже сначала.
[36:30.000 --> 36:32.000]  va-list, va-start, va-end, va-arq и так далее.
[36:32.000 --> 36:34.000]  Мало того, что это работает долго,
[36:34.000 --> 36:36.000]  так это еще не очень удобно.
[36:36.000 --> 36:38.000]  Ну опять же, по причине того,
[36:38.000 --> 36:40.000]  что вам нужно явно знать количество аргументов,
[36:40.000 --> 36:42.000]  вы должны явно знать типы аргументов,
[36:42.000 --> 36:44.000]  которые вам передали,
[36:44.000 --> 36:46.000]  чтобы их можно было использовать в функции va-arq.
[36:48.000 --> 36:50.000]  Мы воспользуемся другим способом,
[36:50.000 --> 36:52.000]  который актуален
[36:52.000 --> 36:54.000]  непосредственно для C++,
[36:54.000 --> 36:56.000]  но вот каким мы поговорим после перерыва.
[36:56.000 --> 36:58.000]  Как в C++ мы пишем функции, которые принимают
[36:58.000 --> 37:00.000]  произвольное количество аргументов?
[37:00.000 --> 37:02.000]  Для этого в C++ есть специальный
[37:02.000 --> 37:04.000]  синтаксис шаблонов.
[37:04.000 --> 37:06.000]  То есть функции с переменным числом
[37:06.000 --> 37:08.000]  аргументов пишутся с помощью шаблонов.
[37:08.000 --> 37:10.000]  И вот каким образом.
[37:10.000 --> 37:12.000]  Для того, чтобы указать,
[37:12.000 --> 37:14.000]  что вы хотите принять произвольное количество
[37:14.000 --> 37:16.000]  аргументов,
[37:16.000 --> 37:18.000]  вы в качестве шаблонного параметра
[37:18.000 --> 37:20.000]  должны принять специальный тип,
[37:20.000 --> 37:22.000]  ну как тип, даже пакет типов,
[37:22.000 --> 37:24.000]  который вы объявляете с помощью
[37:24.000 --> 37:26.000]  класс и дальше многоточие.
[37:26.000 --> 37:28.000]  То есть если вы в качестве шаблонного параметра
[37:28.000 --> 37:30.000]  объявляете класс, многоточие
[37:30.000 --> 37:32.000]  и дальше пишете имя
[37:32.000 --> 37:34.000]  пакета типов, обычно его называют
[37:34.000 --> 37:36.000]  args, то есть аргументы,
[37:36.000 --> 37:38.000]  то вы говорите, что в данном args
[37:38.000 --> 37:40.000]  будут сохранены
[37:40.000 --> 37:42.000]  типы аргументов,
[37:42.000 --> 37:44.000]  которые вы передали в эту функцию.
[37:44.000 --> 37:46.000]  И дальше вы пишете следующую вещь.
[37:46.000 --> 37:48.000]  Соответственно вы пишете обычную функцию,
[37:48.000 --> 37:50.000]  то есть print, дальше что она принимает,
[37:50.000 --> 37:52.000]  в качестве первого аргумента она принимает
[37:52.000 --> 37:54.000]  ссылку на поток,
[37:54.000 --> 37:56.000]  то есть куда нужно выводить результат.
[37:56.000 --> 37:58.000]  И дальше вы пишете следующую вещь,
[37:58.000 --> 38:00.000]  чтобы объявить аргументы,
[38:00.000 --> 38:02.000]  точнее пакет аргументов,
[38:02.000 --> 38:04.000]  которые будет принимать функции,
[38:04.000 --> 38:06.000]  то есть вы должны написать args многоточие,
[38:06.000 --> 38:08.000]  арг, который вы объявили в template.
[38:08.000 --> 38:10.000]  Ну и дальше как это вы называете?
[38:10.000 --> 38:12.000]  Называете пакет аргументов.
[38:12.000 --> 38:14.000]  Понятно?
[38:14.000 --> 38:16.000]  То есть первый момент это класс многоточия,
[38:16.000 --> 38:18.000]  второй момент при объявлении
[38:18.000 --> 38:20.000]  параметра функции вы пишете args
[38:20.000 --> 38:22.000]  и приписываете туда многоточие.
[38:22.000 --> 38:24.000]  Или не args, а любое имя, которое вы дали
[38:24.000 --> 38:26.000]  пакету параметров.
[38:26.000 --> 38:28.000]  Ну и то же самое, если вы хотите
[38:28.000 --> 38:30.000]  написать функцию для суммы,
[38:30.000 --> 38:32.000]  у вас сумма может
[38:32.000 --> 38:34.000]  принимать произвольное количество аргументов,
[38:34.000 --> 38:36.000]  вы пишете класс многоточия args,
[38:36.000 --> 38:38.000]  и принимаете тоже args многоточия args.
[38:38.000 --> 38:40.000]  Здесь мы это не обсуждали,
[38:40.000 --> 38:42.000]  но я тут специально писал авто.
[38:42.000 --> 38:44.000]  Авто можно писать еще и у типа
[38:44.000 --> 38:46.000]  возвращаемого значения функции.
[38:46.000 --> 38:48.000]  Это будет означать,
[38:48.000 --> 38:50.000]  короче, функция сама в выведе,
[38:50.000 --> 38:52.000]  что ты возвращаешь.
[38:52.000 --> 38:54.000]  Если пишешь шаблонную функцию сам,
[38:54.000 --> 38:56.000]  то вообще говоря непонятно,
[38:56.000 --> 38:58.000]  что она возвращает.
[38:58.000 --> 39:00.000]  Если вы передали все int,
[39:00.000 --> 39:02.000]  то результирующий тип тоже непонятен,
[39:02.000 --> 39:04.000]  поэтому мы и говорим,
[39:04.000 --> 39:06.000]  что компилятор сам решает,
[39:06.000 --> 39:08.000]  что тебе надо вернуть.
[39:08.000 --> 39:10.000]  В данных примерах args с большой буквы
[39:10.000 --> 39:12.000]  это пакет параметров типов,
[39:12.000 --> 39:14.000]  а args с маленькой буквы
[39:14.000 --> 39:16.000]  это пакет параметров функций.
[39:16.000 --> 39:18.000]  То есть у нас есть два пакета.
[39:18.000 --> 39:20.000]  Первый пакет — это все типы,
[39:20.000 --> 39:22.000]  которые принимает у меня функция,
[39:22.000 --> 39:24.000]  и второй пакет — это аргументы,
[39:24.000 --> 39:26.000]  которые имеют соответствующий
[39:26.000 --> 39:28.000]  параметр параметров функций.
[39:28.000 --> 39:30.000]  Второй пакет — это аргументы,
[39:30.000 --> 39:32.000]  которые имеют соответствующие типы.
[39:32.000 --> 39:34.000]  Ну и если вдруг мы как-то смогли
[39:34.000 --> 39:36.000]  написать эти функции принты сам,
[39:36.000 --> 39:38.000]  то их спокойно можно будет вызывать
[39:38.000 --> 39:40.000]  вот таким образом,
[39:40.000 --> 39:42.000]  с произволом количеством аргументов.
[39:42.000 --> 39:44.000]  То есть первый вызов вам будет
[39:44.000 --> 39:46.000]  выводить на экран все переданные аргументы,
[39:46.000 --> 39:48.000]  а вторая функция будет вам суммировать
[39:48.000 --> 39:50.000]  все то, что вы туда внутрь передали.
[39:50.000 --> 39:52.000]  Синтактиз понятен?
[39:52.000 --> 39:54.000]  Объявление функций? Хорошо.
[39:54.000 --> 39:56.000]  Несколько правил.
[39:56.000 --> 39:58.000]  Несколько правил
[39:58.000 --> 40:00.000]  использования пакета параметров.
[40:00.000 --> 40:02.000]  Значит, пакеты параметров
[40:02.000 --> 40:04.000]  можно использовать не только
[40:04.000 --> 40:06.000]  в качестве шаблонных функций,
[40:06.000 --> 40:08.000]  но и в качестве шаблонных классов.
[40:08.000 --> 40:10.000]  То есть в принципе вы можете написать
[40:10.000 --> 40:12.000]  классы, на которые тоже принимает
[40:12.000 --> 40:14.000]  произволенное количество параметров.
[40:14.000 --> 40:16.000]  И делается это абсолютно точно так же.
[40:16.000 --> 40:18.000]  То есть у вас может быть класс,
[40:18.000 --> 40:20.000]  который в качестве шаблонного
[40:20.000 --> 40:22.000]  аргумента принимает один тип
[40:22.000 --> 40:24.000]  и плюс какое-то произвольное количество
[40:24.000 --> 40:32.400]  При этом пакет параметров, то есть параметры с произвольным количеством аргументов,
[40:32.400 --> 40:36.500]  могут идти в шаблонных классах только в последнюю очередь, то есть только в самом конце.
[40:36.500 --> 40:39.700]  То есть нельзя написать вот так, а потом написать какой-то еще класс T.
[40:39.700 --> 40:42.800]  То есть если универсальный класс многоточит, то это может идти только последним параметрам.
[40:42.800 --> 40:44.800]  То есть только в конце.
[40:44.800 --> 40:50.800]  Ну и как это работает? Соответственно, если вы инстанцируете MyClass с помощью просто int,
[40:50.800 --> 40:53.800]  то что у вас происходит? У вас в качестве tpt выводится, естественно, int,
[40:53.800 --> 40:56.800]  а в качестве args выводится пустой пакет параметров.
[40:56.800 --> 41:00.800]  То есть пустой пакет параметров тоже допустим.
[41:00.800 --> 41:04.800]  Ну и если вы передали int, char и float, то у вас в качестве t выводится тип int,
[41:04.800 --> 41:08.800]  а в качестве args выводится список из char и float.
[41:08.800 --> 41:12.800]  То есть пакет параметров шаблона содержит char и float.
[41:12.800 --> 41:15.800]  Именно в таком порядке, что бы это ни значило.
[41:15.800 --> 41:19.800]  Дальше. Шаблоны функций вы можете...
[41:19.800 --> 41:21.800]  Шаблоны функций мы уже обсудили.
[41:21.800 --> 41:26.800]  Тут, в отличие от шаблонных классов, вы можете писать пакеты параметров в произвольном порядке.
[41:26.800 --> 41:30.800]  То есть вы можете сначала написать класс многоточия args, а потом класс t.
[41:30.800 --> 41:33.800]  Можете написать наоборот, как мы показали до этого.
[41:33.800 --> 41:37.800]  Но в данном случае это неважно. Почему? Потому что функции, как правило, умеют выводить собственные типы.
[41:37.800 --> 41:39.800]  Ну а для вывода типа это не особо важно.
[41:39.800 --> 41:42.800]  Ну и также вы можете поменять местами args и t.
[41:42.800 --> 41:45.800]  Ну собственно, пакет параметров, который идет...
[41:45.800 --> 41:48.800]  Ну вы можете написать пакет параметров либо в конце, либо в начале.
[41:48.800 --> 41:53.800]  Дело в том, что если вы напишете вот так, то компилятор-то вам позволяет это сделать.
[41:53.800 --> 41:56.800]  Но вот вызвать у вас это не получится.
[41:56.800 --> 41:58.800]  По следующей странной причине.
[41:58.800 --> 42:02.800]  Дело в том, что пакеты параметров, они очень жадные.
[42:02.800 --> 42:05.800]  Вот. Если компилятор в какой-то момент встретил пакет параметров,
[42:05.800 --> 42:09.800]  то вот этот пакет параметров будет выбирать себе все, что попадется ему на пути.
[42:09.800 --> 42:11.800]  И никому он ничего не оставит.
[42:11.800 --> 42:14.800]  То есть, грубо говоря, вы тут, наверное, планировали следующее поведение.
[42:14.800 --> 42:17.800]  Если вы хотите, чтобы у вас функция принимала...
[42:17.800 --> 42:20.800]  То есть у вас функция в качестве последнего аргумента была t и x.
[42:20.800 --> 42:22.800]  То есть t и x это последний аргумент.
[42:22.800 --> 42:24.800]  А все то, что идет спереди, было бы внутри args.
[42:24.800 --> 42:26.800]  Вот так не получится.
[42:26.800 --> 42:28.800]  Все происходит ровно наоборот.
[42:28.800 --> 42:30.800]  Сначала все в себя вбирает args.
[42:30.800 --> 42:35.800]  И только потом все то, что остается, он назначает в x.
[42:35.800 --> 42:38.800]  Но так args жадный, он ничего не оставляет.
[42:38.800 --> 42:41.800]  Ну примеры.
[42:41.800 --> 42:43.800]  То есть если вы написали как положено.
[42:43.800 --> 42:46.800]  Сначала написали t, а потом args многоточаем.
[42:46.800 --> 42:48.800]  И здесь то же самое t, а потом args многоточим.
[42:48.800 --> 42:49.800]  То есть все нормально.
[42:49.800 --> 42:53.800]  Если вы вызываете просто function от 0 и 0.0, то у вас в качестве типа t выводится int.
[42:53.800 --> 42:55.800]  В качестве args выводится пакет...
[42:55.800 --> 42:58.800]  или список, к которому содержится всего лишь один тип double.
[42:58.800 --> 43:00.800]  Если вы вызываете function...
[43:00.800 --> 43:04.800]  То есть если вы явно просите, какие типы вам нужны, int, int, int,
[43:04.800 --> 43:06.800]  то у вас тоже все нормально.
[43:06.800 --> 43:08.800]  В качестве типа t выводится int.
[43:08.800 --> 43:13.400]  список из двух int. Все нормально работает.
[43:13.400 --> 43:18.440]  Если вы меняете местами t и args, что у вас происходит?
[43:18.440 --> 43:23.360]  Вывод типов по-прежнему работает нормально.
[43:23.360 --> 43:26.800]  Почему? Потому что компилятор может по этому вызову понять, что вы имели в виду.
[43:26.800 --> 43:31.200]  Он понимает, что 0 отвечает за tx, поэтому t это int,
[43:31.200 --> 43:35.800]  а все оставшиеся он отдает в аргумент args.
[43:35.800 --> 43:38.800]  Поэтому все нормально.
[43:38.800 --> 43:42.800]  Но если вы в таком случае попытаетесь вызвать function с помощью явного указания параметров,
[43:42.800 --> 43:46.800]  в качестве явного указания шаблонных параметров, то тут возникнет беда,
[43:46.800 --> 43:52.800]  которая как раз завязана на том, что шаблоны с переменочным аргументом
[43:52.800 --> 43:55.800]  вбирают в себя все жадно и ничего не оставляют дальше.
[43:55.800 --> 43:58.800]  Что вас произведет? Вы написали тут int, int, int.
[43:58.800 --> 44:01.800]  Компилятор видит, что в качестве первых шаблонных параметров вы указали args.
[44:01.800 --> 44:05.800]  И поэтому компилятор честно говорит, что int – мое, int – мое, int – мое,
[44:05.800 --> 44:09.800]  t – ой, ничего не осталось, ну все, беда.
[44:09.800 --> 44:15.800]  То есть вот args впитал в себя int, int, int, а в качестве t ничего не осталось.
[44:15.800 --> 44:20.800]  Ну вот ошибка в компиляции. Понятно?
[44:20.800 --> 44:29.800]  Тоже самое может произойти, если вы поменяли местами args и t внутри аргументов.
[44:29.800 --> 44:32.800]  В этом случае вы не можете вызвать функцион вот так.
[44:32.800 --> 44:35.800]  Ну снова почему? Потому что компилятор пытается вывести
[44:35.800 --> 44:38.800]  первый шаблонный параметр args. То есть он увидит 0.
[44:38.800 --> 44:41.800]  То есть он поймет, что первый шаблонный параметр внутри этого пакета должен быть int.
[44:41.800 --> 44:43.800]  Дальше смотрит 0.0.
[44:43.800 --> 44:47.800]  Вторым аргументом внутри этого пакета должен быть double.
[44:47.800 --> 44:49.800]  Поэтому вот создаю int double.
[44:49.800 --> 44:52.800]  Дальше ничего не осталось. Ну все, я заканчиваю работу с пакетом.
[44:52.800 --> 44:56.800]  А дальше приходит t и говорит, что еще есть я, а ему и ничего не осталось.
[44:56.800 --> 44:58.800]  Все.
[44:58.800 --> 45:01.800]  Но при этом в данном случае можно вызвать функцион int, int.
[45:01.800 --> 45:04.800]  Почему? Потому что внутри этого списка,
[45:04.800 --> 45:06.800]  внутри объявления шаблонов параметра все нормально.
[45:06.800 --> 45:11.800]  То есть тут более-менее понятно, что первый int это t, а последний это args.
[45:11.800 --> 45:15.800]  Ну и последний случай, самый печальный.
[45:15.800 --> 45:17.800]  Эту функцию вы вообще никак вызвать не можете.
[45:17.800 --> 45:20.800]  То есть ни первым способом, ни вторым способом.
[45:20.800 --> 45:25.800]  Ну понятно. В первом случае у вас вот здесь все уйдет в args.
[45:25.800 --> 45:28.800]  В втором случае у вас и здесь все уйдет в args.
[45:30.800 --> 45:33.800]  Поэтому все-таки правильным способом использования шаблонных параметров
[45:33.800 --> 45:36.800]  является написание списка пакета параметров в конце.
[45:36.800 --> 45:39.800]  Окей?
[45:39.800 --> 45:42.800]  Все примеры тут понятны?
[45:42.800 --> 45:44.800]  Хорошо.
[45:44.800 --> 45:46.800]  Ну и наконец ключевой вопрос.
[45:46.800 --> 45:49.800]  Мы поняли, как объявлять шаблоны с переменом числом аргументов.
[45:49.800 --> 45:52.800]  А как с ними работать?
[45:52.800 --> 45:56.800]  То есть как написать функцию, которая бы работала с переменом числом аргументов?
[45:56.800 --> 45:59.800]  Вот сейчас мы это обсудим.
[45:59.800 --> 46:02.800]  Первое, про что нужно поговорить, это про оператор sizeof.
[46:02.800 --> 46:07.800]  Помните, когда мы использовали сишный синтаксис?
[46:07.800 --> 46:12.800]  Тут мы должны были отдельным аргументом как-то сообщать,
[46:12.800 --> 46:16.800]  ну не компилятору, а как-то сообщать функции, сколько аргументов мы передали.
[46:16.800 --> 46:20.800]  В C++ стиле этого не нужно делать, потому что у нас есть специальный оператор sizeof.
[46:20.800 --> 46:23.800]  Sizeof с многоточием.
[46:23.800 --> 46:26.800]  Sizeof с многоточием можно применять только к пакетам параметров.
[46:26.800 --> 46:29.800]  То есть только к пакетам, которые объявлены с помощью класса и многоточия,
[46:29.800 --> 46:32.800]  или которые объявлены с помощью вот такой штуки.
[46:32.800 --> 46:36.800]  Так, здесь это вам рано, давайте просто args напишем.
[46:36.800 --> 46:39.800]  Окей?
[46:39.800 --> 46:43.800]  То есть если вы sizeof примените к args большой буквы, ну или args с маленькой буквы,
[46:43.800 --> 46:48.800]  неважно к пакету параметров типов или к параметру функции,
[46:48.800 --> 46:54.800]  sizeof с многоточием возвращает вам количество элементов в этом пакете.
[46:54.800 --> 46:58.800]  Именно что количество элементов, а не размер в байках?
[46:58.800 --> 47:01.800]  Ну классический sizeof, я думаю вы помните,
[47:01.800 --> 47:04.800]  sizeof от x возвращает вам размер выражения.
[47:04.800 --> 47:08.800]  Ну, точнее размера результатов выражения или размер переменной в байтах.
[47:08.800 --> 47:11.800]  Или размер типа в байтах.
[47:11.800 --> 47:15.800]  Sizeof с многоточием возвращает вам размер не в байтах, а именно что в штуках.
[47:15.800 --> 47:19.800]  в количестве, в единицах, в объектах, в общем, что угодно.
[47:19.800 --> 47:21.800]  Понятно?
[47:21.800 --> 47:24.800]  Поэтому если вы вызываете в данном случае функцию 1, 2, 3,
[47:24.800 --> 47:28.800]  то sizeOfArcБольшой вернет вам 3, и sizeOfArcМаленькойБуквой
[47:28.800 --> 47:31.800]  вернет вам тоже 3. То есть это первое правило, что количество аргументов
[47:31.800 --> 47:36.800]  вы всегда можете определить с помощью sizeOf с многоточием.
[47:36.800 --> 47:39.800]  Дальше.
[47:39.800 --> 47:45.800]  Первый способ написания функции с переменом числом аргументов.
[47:45.800 --> 47:48.800]  Начнем со следующих слов.
[47:48.800 --> 47:52.800]  Допустим, вы написали какую-то функцию с переменом числом аргументов.
[47:52.800 --> 47:56.800]  Допустим, у вас уже есть какая-то функция с переменом числом аргументов.
[47:56.800 --> 47:59.800]  Вы ее можете использовать внутри своей функции.
[47:59.800 --> 48:03.800]  Например, допустим, у меня есть функция print,
[48:03.800 --> 48:06.800]  которая может принимать произвольное число аргументов.
[48:06.800 --> 48:10.800]  При этом я хочу написать функцию printTitle,
[48:10.800 --> 48:13.800]  которая помимо того, что печатает сами аргументы,
[48:13.800 --> 48:16.800]  еще в самом начале печатает какой-то заголовок.
[48:16.800 --> 48:19.800]  То есть, грубо говоря, это числа, и дальше печатает числа,
[48:19.800 --> 48:22.800]  и вот там мой массив, и дальше печатает массив.
[48:22.800 --> 48:25.800]  Как я это реализую?
[48:25.800 --> 48:29.800]  Я принимаю поток, в который я буду все это выводить.
[48:29.800 --> 48:32.800]  Дальше я принимаю сам заголовок,
[48:32.800 --> 48:35.800]  который я буду выводить перед тем, как выводить все остальное.
[48:35.800 --> 48:38.800]  Ну и дальше принимаю, собственно, все остальные аргументы.
[48:38.800 --> 48:41.800]  Ну и как моя функция работает? Я изначально вывожу title,
[48:41.800 --> 48:44.800]  то есть изначально вывожу заголовок, что сейчас будет выведено,
[48:44.800 --> 48:47.800]  ну и дальше все остальные аргументы,
[48:47.800 --> 48:50.800]  передаю функцию print. Как я это делаю?
[48:50.800 --> 48:53.800]  Как мне взять пакет параметров и передать другую функцию?
[48:53.800 --> 48:56.800]  Очень просто. Я пишу args, и после этого пишу многоточие.
[48:56.800 --> 48:59.800]  Многоточие означает распаковать пакет.
[48:59.800 --> 49:02.800]  Ну и пакет распакуется следующим образом.
[49:02.800 --> 49:05.800]  Сначала пишется первый параметр, через запятую второй параметр,
[49:05.800 --> 49:08.800]  через запятую третий параметр и так далее.
[49:08.800 --> 49:11.800]  То есть распаковка пакета происходит с помощью многоточия.
[49:11.800 --> 49:18.800]  То есть просто написать print os args нельзя.
[49:18.800 --> 49:20.800]  Вот так писать нельзя.
[49:20.800 --> 49:23.800]  Потому что args это пакет, пакет, вообще говоря,
[49:23.800 --> 49:26.800]  в дизаке C++ нет такого типа пакет,
[49:26.800 --> 49:29.800]  и просто так передать пакет другую функцию вы не можете.
[49:29.800 --> 49:32.800]  Вы можете его передать и распаковать.
[49:37.800 --> 49:40.800]  Более того, к пакету вы можете применять
[49:40.800 --> 49:43.800]  некоторый шаблон, некоторые паттерны или некоторую функцию,
[49:43.800 --> 49:46.800]  которая будет применена ко всем элементам пакета сразу.
[49:46.800 --> 49:49.800]  Следующий пример.
[49:49.800 --> 49:52.800]  Допустим, вы хотите написать функцию, которая суммирует квадраты чисел.
[49:52.800 --> 49:55.800]  Допустим, у вас есть функция sum, уже написанная,
[49:55.800 --> 49:58.800]  которая принимает произвольное количество аргументов
[49:58.800 --> 50:01.800]  и суммирует их все, возвращает вам ответ.
[50:01.800 --> 50:04.800]  А теперь мы хотим написать функцию sum squares,
[50:04.800 --> 50:07.800]  которая возвращает вам сумму квадратов чисел.
[50:07.800 --> 50:10.800]  Как это можно сделать?
[50:10.800 --> 50:13.800]  Снова мы принимаем произвольное количество аргументов
[50:13.800 --> 50:16.800]  и дальше пишем следующую интересную вещь.
[50:16.800 --> 50:19.800]  Пишем sum args умножить на args и дальше многоточие.
[50:19.800 --> 50:22.800]  Потому что пакет раскрывается целиком.
[50:22.800 --> 50:25.800]  Мы не хотим отдельно распаковать первый пакет,
[50:25.800 --> 50:28.800]  а потом вот эту распаковку умножить на второй пакет.
[50:28.800 --> 50:31.800]  Мы как бы тут пишем шаблон.
[50:31.800 --> 50:34.800]  Мы говорим, что к каждому аргументу нужно применить,
[50:34.800 --> 50:37.800]  взять аргумент, умножить его на другой аргумент.
[50:37.800 --> 50:40.800]  И вот эту всю конструкцию нужно распаковать.
[50:40.800 --> 50:43.800]  Грубо говоря, здесь написан шаблон,
[50:43.800 --> 50:46.800]  написан некоторый шаблон, и после него пишется многоточие.
[50:46.800 --> 50:49.800]  И даже этот шаблон применяется к каждому аргументу.
[50:49.800 --> 50:52.800]  Собственно, здесь вы написали, что к каждому аргументу
[50:52.800 --> 50:55.800]  нужно применить умножение его самим собой.
[50:55.800 --> 51:02.800]  И поэтому у вас эта штука как бы распакуется в args 0 умножить на args 0,
[51:02.800 --> 51:05.800]  args 1 умножить на args 1 и так далее.
[51:05.800 --> 51:08.800]  У вас вопрос?
[51:08.800 --> 51:11.800]  Ещё раз, можешь что-то поставить?
[51:11.800 --> 51:17.800]  Боюсь, что это не сработает, потому что непонятно,
[51:17.800 --> 51:20.800]  что имеется в виду.
[51:20.800 --> 51:23.800]  Вопрос такой, что если сделать вот так?
[51:23.800 --> 51:30.800]  args многоточие, или умножить на args многоточие.
[51:30.800 --> 51:33.800]  На самом деле непонятно, что вы имеете в виду,
[51:33.800 --> 51:36.800]  потому что распаковка пакета, грубо говоря, означает,
[51:36.800 --> 51:39.800]  что вы пишете args 0, args 1, грубо говоря, через запятую.
[51:39.800 --> 51:42.800]  На самом деле это не так, потому что запятая это оператор.
[51:42.800 --> 51:45.800]  Вообще говоря, примерно n-1.
[51:45.800 --> 51:48.800]  Дальше всё, что распаковали через запятую, умножайте на другую вещь,
[51:48.800 --> 51:51.800]  которая распакована через запятую.
[51:51.800 --> 51:54.800]  Грубо говоря, непонятно, что вы имеете в виду.
[51:54.800 --> 51:57.800]  Поэтому так не получится.
[51:57.800 --> 52:00.800]  Всё понятно?
[52:00.800 --> 52:03.800]  То есть применение простое. Вы либо просто распаковываете пакет
[52:03.800 --> 52:06.800]  и передаёте его в другую функцию, либо говорите,
[52:06.800 --> 52:09.800]  что каждому элементу нужно применить какую-то операцию,
[52:09.800 --> 52:12.800]  какое-то действие, и дальше снова через многоточие распаковываете.
[52:12.800 --> 52:15.800]  Нет, это происходит во время распаковки.
[52:15.800 --> 52:18.800]  То есть вы пишете, что нужно применить, что нужно сделать с каждым аргументом.
[52:18.800 --> 52:21.800]  Здесь вы пишете, что каждый аргумент нужно умножить на само себя,
[52:21.800 --> 52:24.800]  а дальше пишете многоточие.
[52:24.800 --> 52:27.800]  И теперь у вас происходит следующая вещь.
[52:27.800 --> 52:30.800]  Берётся первый аргумент, умножается на сам себя,
[52:30.800 --> 52:33.800]  берётся второй аргумент, умножается на сам себя и так далее.
[52:33.800 --> 52:36.800]  Всё это перечитает через запятую и передаётся в другую функцию.
[52:36.800 --> 52:39.800]  Ещё примеры, как эту распаковку можно использовать.
[52:39.800 --> 52:42.800]  Например, если у вас есть функция print,
[52:42.800 --> 52:45.800]  которая принимает произвольное количество аргументов,
[52:45.800 --> 52:48.800]  печатает их на экран, вы можете написать свою функцию printAddresses,
[52:48.800 --> 52:51.800]  которая просто принимает аргументы
[52:51.800 --> 52:54.800]  и печатает их адреса на экран.
[52:54.800 --> 52:57.800]  И вот тут мы знакомимся с ещё одной возможностью.
[52:57.800 --> 53:00.800]  Это применение паттерна к типам.
[53:00.800 --> 53:03.800]  Понятное дело, что паттерн,
[53:03.800 --> 53:06.800]  тот, который был написан здесь,
[53:06.800 --> 53:09.800]  можно применять не только к аргументам,
[53:09.800 --> 53:12.800]  но ещё можно что-то навешивать на типы.
[53:12.800 --> 53:15.800]  Понятное дело, что у вас может быть не только int,
[53:15.800 --> 53:18.800]  но, скажем, int&, ссылка на int,
[53:18.800 --> 53:21.800]  константная ссылка на int, правая ссылка на int и так далее.
[53:21.800 --> 53:24.800]  Примерно то же самое можно делать и с пакетом параметров типов.
[53:24.800 --> 53:27.800]  Что здесь дословно написано?
[53:27.800 --> 53:30.800]  Вы говорите, что каждому аргументу типу
[53:30.800 --> 53:33.800]  нужно применить const&&.
[53:33.800 --> 53:36.800]  И дальше вы через запятую это всё распаковываете.
[53:36.800 --> 53:39.800]  И у вас получается, что у вас есть const arc1&,
[53:39.800 --> 53:42.800]  const arc2& и так далее.
[53:42.800 --> 53:45.800]  Понятно?
[53:45.800 --> 53:48.800]  То есть вы каждый аргумент пакета
[53:48.800 --> 53:51.800]  принимаете по константной ссылке.
[53:51.800 --> 53:54.800]  Понятно, почему здесь нужно использовать
[53:54.800 --> 53:57.800]  константную ссылку.
[53:57.800 --> 54:00.800]  Потому что мы хотим напечатать адреса.
[54:00.800 --> 54:03.800]  Если это констант, то мы будем печатать локальные адреса.
[54:03.800 --> 54:06.800]  То есть мы сначала всё скопируем и потом будем писать локальные адреса.
[54:06.800 --> 54:09.800]  Мы этого не хотим. Скорее всего мы хотим напечатать
[54:09.800 --> 54:12.800]  именно адреса тех объектов, которые нам передали.
[54:15.800 --> 54:18.800]  Вот с этим const arc&& понятно?
[54:18.800 --> 54:21.800]  То есть мы просто говорим, что мы каждый аргумент этого пакета
[54:21.800 --> 54:24.800]  хотим принимать по константной ссылке.
[54:30.800 --> 54:33.800]  Так или иначе, все объекты умеют проводиться в константной ссылке.
[54:33.800 --> 54:36.800]  Временные, невременные.
[54:36.800 --> 54:39.800]  В общем, конст ссылки – это, грубо говоря,
[54:39.800 --> 54:42.800]  некоторый универсальный способ принимать всё, что угодно.
[54:42.800 --> 54:45.800]  Но если что-то идёт не так,
[54:45.800 --> 54:48.800]  то можно задать другой вопрос.
[54:48.800 --> 54:51.800]  Что если я делаю вот так? Что если я пишу не конст, а просто arc ссылка?
[54:51.800 --> 54:54.800]  То есть я говорю, что я просто все элементы принимаю по ссылке, а не по константной ссылке.
[54:54.800 --> 54:57.800]  Тогда сюда можно передавать только lvalue.
[54:57.800 --> 55:00.800]  Ну и тогда будет просто ошибка компиляции.
[55:00.800 --> 55:03.800]  То есть если у вас ожидается, что тут будет передаваться lvalue,
[55:03.800 --> 55:06.800]  а вы передаете не lvalue, то ошибка компиляции.
[55:06.800 --> 55:09.800]  Всё как в обычных функциях.
[55:09.800 --> 55:12.800]  Ну и дальше я говорю, что каждому аргументу
[55:12.800 --> 55:15.800]  мне нужно взять адрес,
[55:15.800 --> 55:18.800]  ну и дальше я это всё распаковываю.
[55:18.800 --> 55:21.800]  То есть у меня получается, что я беру адрес первого аргумента, второго аргумента,
[55:21.800 --> 55:24.800]  ну и последнего аргумента.
[55:24.800 --> 55:27.800]  Ну и последний ещё один интересный пример.
[55:27.800 --> 55:30.800]  Значит, пакеты вы можете на самом деле распаковывать
[55:30.800 --> 55:33.800]  в произвольных местах, в произвольном количестве.
[55:33.800 --> 55:36.800]  Здесь какой пример?
[55:36.800 --> 55:39.800]  Здесь пример...
[55:39.800 --> 55:42.800]  То есть я хочу напечатать так называемые частичные суммы,
[55:42.800 --> 55:45.800]  то есть сумму без первого аргумента,
[55:45.800 --> 55:48.800]  сумму без второго аргумента, сумму без третьего аргумента и так далее.
[55:48.800 --> 55:51.800]  Понятно, да? То есть если у меня есть 1, 2, 3, 4,
[55:51.800 --> 55:54.800]  то у меня функция должна вернуть 9,
[55:54.800 --> 55:57.800]  что дальше? 8, дальше 7, ну и 6.
[55:57.800 --> 56:00.800]  То есть это сумма всех элементов без единицы,
[56:00.800 --> 56:03.800]  сумма всех элементов без двойки, сумма всех элементов без тройки,
[56:03.800 --> 56:06.800]  сумма всех элементов без четвёрки.
[56:06.800 --> 56:09.800]  Как я это делаю?
[56:09.800 --> 56:12.800]  Следующим образом. Первое, что я делаю, я говорю, что
[56:12.800 --> 56:15.800]  в качестве первого аппаранда у меня выступает
[56:15.800 --> 56:18.800]  сумма всех элементов.
[56:19.800 --> 56:22.800]  Понятно? То есть в качестве первого параметра я говорю,
[56:22.800 --> 56:25.800]  что я считаю сумму всех аргументов.
[56:25.800 --> 56:28.800]  То есть я и распаковываю это всё, я внутри скобок,
[56:28.800 --> 56:31.800]  то есть внутри аргументов. То есть у меня тут есть
[56:31.800 --> 56:34.800]  сумм от всего, что передали.
[56:34.800 --> 56:37.800]  А дальше я пишу минус аркс и многоточие.
[56:37.800 --> 56:40.800]  Ну, дословно, что это означает?
[56:40.800 --> 56:43.800]  Это означает, что мне нужно взять вот это значение s,
[56:43.800 --> 56:46.800]  ну на самом деле всё внизу написано,
[56:46.800 --> 56:49.800]  мне нужно взять значение s, которое было посчитано здесь,
[56:49.800 --> 56:52.800]  из него вычесть аргумент
[56:52.800 --> 56:55.800]  и повторить этого для каждого аргумента.
[56:58.800 --> 57:01.800]  Это непонятно. Скорее всего, нет.
[57:01.800 --> 57:04.800]  Скорее всего, это будет оптимизирован. То есть так как это всё разрешается
[57:04.800 --> 57:07.800]  на этапе компиляции, скорее всего он на этапе компиляции там
[57:07.800 --> 57:10.800]  почитает и всё подставит и так далее. Но возможно и нет.
[57:10.800 --> 57:13.800]  Но так или иначе к какому результату это приводит?
[57:13.800 --> 57:16.800]  Из общей суммы вычитается аркс 0,
[57:16.800 --> 57:19.800]  потом из общей суммы вычитается аркс 1,
[57:19.800 --> 57:22.800]  и так далее, потом аркс n-1.
[57:28.800 --> 57:31.800]  Вот этот пример понятен? То есть здесь я распаковал пакет,
[57:31.800 --> 57:34.800]  посчитал сумму и только потом распаковал весь паттерн
[57:34.800 --> 57:37.800]  целиком, который содержит аркс.
[57:39.800 --> 57:42.800]  То есть, грубо говоря, на самом деле
[57:42.800 --> 57:45.800]  многоточие относится к вот этому аркс.
[57:45.800 --> 57:48.800]  К этому арксу оно не имеет никакого отношения. Почему?
[57:48.800 --> 57:51.800]  Потому что первый аркс уже распакован, то есть многоточие
[57:51.800 --> 57:54.800]  относится только к не распакованному аргументу. Хорошо?
[57:57.800 --> 58:00.800]  Значит, это первый способ использования шаблона с переменочным
[58:00.800 --> 58:03.800]  аргументов. То есть вы можете распаковывать пакеты и передать их
[58:03.800 --> 58:06.800]  в другую функцию. При этом вы можете распаковывать как вам угодно.
[58:06.800 --> 58:09.800]  Вы можете применить ко всем одну и ту же операцию и передать дальше.
[58:09.800 --> 58:16.800]  Ну и можете конструировать какие-то более сложные вещи, как, например, вот во втором примере здесь.
[58:16.800 --> 58:22.800]  Второй метод уже более разумный, то есть метод откусывания.
[58:22.800 --> 58:26.800]  Смотрите, метод откусывания заключается в следующем.
[58:26.800 --> 58:30.800]  Вообще говоря, сложность в написании шаблона с переменочным аргументом заключается в том,
[58:30.800 --> 58:36.800]  что мы не можем, как в языке Python, как устроены функции с переменочным аргументом.
[58:36.800 --> 58:41.800]  Там есть специальный аргумент, объявляется со звездочкой.
[58:41.800 --> 58:44.800]  И этот аргумент, по-моему, представляет себя tuple.
[58:44.800 --> 58:46.800]  Ну, грубо говоря, неизменяемый массив.
[58:46.800 --> 58:50.800]  И вы к этому массиву можете спокойно обращаться к нулевому элементу, к первому элементу, к второму элементу.
[58:50.800 --> 58:52.800]  То есть вы можете спокойно индексироваться.
[58:52.800 --> 58:54.800]  В языке C++ так нельзя делать.
[58:54.800 --> 58:58.800]  То есть вы не можете просто взять и написать args в скобочках 0.
[58:58.800 --> 59:01.800]  Просто так взять и обратиться к элементу вы не можете.
[59:01.800 --> 59:06.800]  Вы можете это сделать просто, потому что это вот такая зашита на этапе компиляции внутренняя структура.
[59:06.800 --> 59:10.800]  На что вы можете сделать? Вы можете откусывать элементы по одному.
[59:10.800 --> 59:12.800]  Как это работает? Смотрите.
[59:12.800 --> 59:14.800]  Снова возвращаемся к исходной задаче.
[59:14.800 --> 59:17.800]  Я хочу написать функцию print, которая печатает произвольные аргументы.
[59:17.800 --> 59:19.800]  Делаю я это следующим образом.
[59:19.800 --> 59:22.800]  Значит, я пишу рекурсию.
[59:22.800 --> 59:27.800]  Значит, сначала я пишу функцию, которая работает в случае, когда мне передали один аргумент.
[59:27.800 --> 59:29.800]  Это так называемый конец рекурсии.
[59:29.800 --> 59:33.800]  Ну понятно, что когда мне передали один аргумент, мне понятно, что делать.
[59:34.800 --> 59:38.800]  Если мне передали один аргумент, мне понятно, что нужно просто взять и вывести
[59:38.800 --> 59:40.800]  на экран это один аргумент. Всё нормально.
[59:41.800 --> 59:49.800]  И плюс я пишу перекрузку для в случае, когда мне передали более одного аргумента.
[59:49.800 --> 59:55.800]  То есть я пишу, что в случае, если мне передали один аргумент и плюс ещё что-то,
[59:55.800 --> 59:57.800]  нужно вызывать вот эту функцию.
[59:57.800 --> 01:00:00.300]  Она будет выигрывать перегрузку по понятным причинам.
[01:00:00.300 --> 01:00:04.800]  Потому что если вы вызвали функцию print от двух аргументов,
[01:00:04.800 --> 01:00:07.800]  то будет вызываться вот эта функция, потому что она подходит лучше всего.
[01:00:07.800 --> 01:00:11.800]  То есть компилятору дешевле ничего не подставлять в ARX,
[01:00:11.800 --> 01:00:13.800]  чем подставлять в ARX пустой список.
[01:00:13.800 --> 01:00:16.800]  Мы говорили, что точное соответствие всегда подходит лучше.
[01:00:16.800 --> 01:00:22.800]  Точнее, соответствие с наименеешим числом постановок подходит лучше.
[01:00:22.800 --> 01:00:26.800]  А здесь что вы пишете? Вы пишете, что если вам передали один аргумент и плюс еще что-то,
[01:00:26.800 --> 01:00:28.800]  то мы работаем следующим образом.
[01:00:28.800 --> 01:00:31.800]  Мы выводим head, ну точнее мы выводим первый аргумент на экран.
[01:00:31.800 --> 01:00:36.800]  И потом рекурсивно вызываем функцию print от оставшейся части.
[01:00:36.800 --> 01:00:39.800]  И в этом собственно заключается метод откусывания.
[01:00:39.800 --> 01:00:43.800]  То есть мы откусили первый аргумент, с ним что-то сделали, а остальные передали дальше.
[01:00:43.800 --> 01:00:45.800]  Рекурсивно.
[01:00:45.800 --> 01:00:47.800]  Понятно, что произошло?
[01:00:47.800 --> 01:00:55.800]  То есть когда я вызываю print от os и 0.1.2, что происходит?
[01:00:55.800 --> 01:01:03.800]  Сначала у меня вызывается функция print, у которой head равен 0,
[01:01:03.800 --> 01:01:08.800]  а в ARX записано 1 и 2.
[01:01:08.800 --> 01:01:15.800]  Выводите 0 и дальше просите print от 1 и 2.
[01:01:15.800 --> 01:01:21.800]  В head у вас записывается единица, в ARX у вас записывается двойка.
[01:01:21.800 --> 01:01:25.800]  Дальше вызываете print рекурсивно от двойки.
[01:01:25.800 --> 01:01:28.800]  И все, рекурсия заканчивается, потому что вы вызываете вот эту функцию.
[01:01:28.800 --> 01:01:31.800]  Первая функция ничего рекурсивно не вызывает, все отлично.
[01:01:31.800 --> 01:01:33.800]  Понятно?
[01:01:33.800 --> 01:01:35.800]  Что?
[01:01:35.800 --> 01:01:37.800]  Stackoverflow?
[01:01:37.800 --> 01:01:40.800]  Ну тут очень сложно добиться stackoverflow по следующей причине.
[01:01:40.800 --> 01:01:44.800]  Вообще говоря, число аргументов функции ограничено.
[01:01:44.800 --> 01:01:48.800]  По-моему 256.
[01:01:48.800 --> 01:01:52.800]  По-моему около максимального количества аргументов,
[01:01:52.800 --> 01:01:56.800]  которые можно принимать функции в языке C++, это что-то типа 256.
[01:01:56.800 --> 01:01:59.800]  Больше чем 256 аргументов функции вы передать не можете.
[01:01:59.800 --> 01:02:02.800]  Поэтому тут рекурсия максимум 256 шагов.
[01:02:02.800 --> 01:02:04.800]  Но это как бы не очень много.
[01:02:04.800 --> 01:02:06.800]  Но проблема действительно есть.
[01:02:06.800 --> 01:02:08.800]  Рекурсивно вызвано, мы ее поборем в использовании 3.
[01:02:08.800 --> 01:02:12.800]  Все будет нормально.
[01:02:12.800 --> 01:02:15.800]  Так, этот пример понятен.
[01:02:15.800 --> 01:02:18.800]  Ну и то же самое метод кусывания для функции суммы.
[01:02:18.800 --> 01:02:20.800]  Если мы хотим просуммировать все аргументы, то то же самое.
[01:02:20.800 --> 01:02:22.800]  Мы пишем конец рекурсии.
[01:02:22.800 --> 01:02:25.800]  Что делать, если в сумму нам передали один аргумент?
[01:02:25.800 --> 01:02:28.800]  Если нам в сумму передали один аргумент, то мы просто его возвращаем.
[01:02:28.800 --> 01:02:30.800]  Сумма из одного слагаемого.
[01:02:30.800 --> 01:02:32.800]  Вы на первом курсе проходили.
[01:02:32.800 --> 01:02:35.800]  Это, собственно, слагаемая.
[01:02:35.800 --> 01:02:38.800]  Если мы в сумму передаем произвольное количество аргументов,
[01:02:38.800 --> 01:02:43.800]  то мы говорим, что у нас как минимум есть один аргумент и плюс еще что-то.
[01:02:43.800 --> 01:02:45.800]  В этом случае что мы делаем?
[01:02:45.800 --> 01:02:48.800]  Как выглядит рекурсивное вычление суммы от многих аргументов?
[01:02:48.800 --> 01:02:52.800]  Нужно вычлить сумму от меньшего количества аргументов и плюс первый аргумент.
[01:02:52.800 --> 01:02:56.800]  Понятно?
[01:02:56.800 --> 01:02:59.800]  Тоже понятно, как работает.
[01:02:59.800 --> 01:03:02.800]  Хорошо.
[01:03:02.800 --> 01:03:05.800]  И наконец, третий способ использования, который завезли в 17 стандарте,
[01:03:05.800 --> 01:03:08.800]  это так называемый Fold Expressions.
[01:03:08.800 --> 01:03:10.800]  Ну снова, да, как тут правильно отметили,
[01:03:10.800 --> 01:03:14.800]  вообще говоря, то, что мы здесь делали, мы здесь делали рекурсивно.
[01:03:14.800 --> 01:03:19.800]  Рекурсия это не всегда хорошо, это не всегда эффективно.
[01:03:19.800 --> 01:03:23.800]  Просто потому что на это тратится стек, на это тратятся лишние вызовы.
[01:03:23.800 --> 01:03:26.800]  Эти функции, вообще говоря, рекурсивно не инлайнятся.
[01:03:26.800 --> 01:03:28.800]  В общем, все плохо.
[01:03:28.800 --> 01:03:34.800]  Так вот, в 17 стандарте решили завести такую возможность как Fold Expressions.
[01:03:34.800 --> 01:03:38.800]  Fold Expressions — это такой, некоторый специальный синтаксис распаковки параметров.
[01:03:38.800 --> 01:03:41.800]  Дайте сначала общий синтаксис, а потом к примерам.
[01:03:41.800 --> 01:03:47.800]  Допустим, вы хотите применить бинарную операцию подряд ко всем элементам.
[01:03:47.800 --> 01:03:51.800]  Допустим, как мы здесь хотели, мы хотели сложить все элементы.
[01:03:51.800 --> 01:03:53.800]  Для этого вы пишете следующую вещь.
[01:03:53.800 --> 01:04:00.800]  Вы пишете скобки, пишете пакет параметров, нужную вам операцию,
[01:04:00.800 --> 01:04:03.800]  и потом многоточие.
[01:04:03.800 --> 01:04:07.800]  Эта штука автоматически раскрывается вот в такую вещь.
[01:04:07.800 --> 01:04:11.800]  Как называется? В правоассоциативную бинарную операцию.
[01:04:11.800 --> 01:04:14.800]  То есть сначала считается результат операции для последних двух аргументов,
[01:04:14.800 --> 01:04:16.800]  потом для предпоследнего с результатом,
[01:04:16.800 --> 01:04:19.800]  потом результат перед последним аргументом и так далее.
[01:04:19.800 --> 01:04:21.800]  Понятно.
[01:04:21.800 --> 01:04:25.800]  То есть это дословно то, во что раскрывается эта штука.
[01:04:25.800 --> 01:04:28.800]  Если вы хотите левоассоциативную операцию,
[01:04:28.800 --> 01:04:30.800]  которая сначала работает с левыми аргументами,
[01:04:30.800 --> 01:04:40.800]  то вы пишете то же самое, но многоточие слева. То есть, грубо говоря, вы пишете многоточие, плюс аркс, скобка закрылась.
[01:04:40.800 --> 01:04:49.800]  И вот это дословно переводится в аркс 0, плюс аркс 1, плюс и так далее.
[01:04:49.800 --> 01:04:54.800]  Ну при этом скобки расставляются вот таким образом.
[01:04:55.800 --> 01:05:02.800]  Ну и последние две штуки. Это та же самая распаковка с бинарной операцией, но с некоторым инициализатором.
[01:05:02.800 --> 01:05:13.800]  Ну, например, вы хотите просуммировать все аргументы, но при этом сделать так, что сначала идет 1, а потом аркс 0, плюс аркс 1, плюс и так далее.
[01:05:13.800 --> 01:05:16.800]  То есть задать некоторое начальное значение.
[01:05:17.800 --> 01:05:25.800]  Ну и это делается тоже точно так же. То есть вы пишете pack, потом операция, потом многоточие, потом снова операция и init. То есть то, с чем нужно проинцидизировать.
[01:05:25.800 --> 01:05:32.800]  То есть это будет правоассоциативная операция. То же самое, если вы хотите левоассоциативную операцию, то вы пишете вот таким способом.
[01:05:32.800 --> 01:05:36.800]  Ну, это общий синтакт, сейчас будут примеры. Пока понятно, да?
[01:05:38.800 --> 01:05:43.800]  Ну вот примеры, собственно. Как можно написать функцию... давайте сначала сам. Тут проще.
[01:05:43.800 --> 01:05:51.800]  Сначала функцию суммы. Ну, как я уже писал до этого, мы используем fold expression, то есть распаковку параметров в выражении свертки.
[01:05:51.800 --> 01:06:01.800]  То есть мы пишем обязательно скобки, то есть скобки обязательно это часть синтаксиса. Вы пишете скобки, дальше вы пишете пакет параметров, дальше пишете плюс и многоточие.
[01:06:01.800 --> 01:06:07.800]  И это дословно означает, что нужно все элементы сложить друг с другом. Окей?
[01:06:07.800 --> 01:06:16.800]  Значит, как можно писать принт? То же самое, но только нужно использовать в данном случае последний. Последний fold expression.
[01:06:16.800 --> 01:06:23.800]  Ну почему? Потому что... что мы здесь делаем? По сути мы здесь используем операцию побитого сдвига влево для всех аргументов.
[01:06:23.800 --> 01:06:30.800]  Но при этом мы используем операцию побитого сдвига влево, и при этом изначально слева у нас должен обязательно стоять поток.
[01:06:30.800 --> 01:06:37.800]  Ну потому что если мы будем просто ко всем аргументам принимать операцию побитого сдвига, то они все просто побитого сдвинутся, и непонятно что и всё.
[01:06:37.800 --> 01:06:44.800]  Понятное дело, что когда вы вводите на экран, у вас сначала стоит поток, а только потом эти самые операторы побитого сдвига.
[01:06:44.800 --> 01:06:50.300]  Чтобы этого добиться, вы сначала пишете скобки, часть синтаксиса,
[01:06:50.300 --> 01:06:58.800]  потом пишете os, то есть оператор удаф поток, дальше побитву издвиг, многоточие, побитву издвиг и дальше аргументы.
[01:06:58.800 --> 01:07:02.800]  Вот такой синтаксис.
[01:07:02.800 --> 01:07:08.800]  То есть это пример к четвертому, это пример к первому пункту.
[01:07:08.800 --> 01:07:12.800]  Понятно?
[01:07:12.800 --> 01:07:20.800]  При этом, естественно, выражение к свертке, как и при любой другой распаковке параметров, вы можете использовать некоторый шаблон.
[01:07:20.800 --> 01:07:30.800]  Например, как можно в последнем примере вывести не просто сумму всех чител, а сумму квадратов чител?
[01:07:30.800 --> 01:07:34.800]  Что нужно написать?
[01:07:34.800 --> 01:07:42.800]  Да, просто аркс умножить на аркс. Аркс умножить на аркс, ну естественно все в скобках, плюс и многоточие.
[01:07:42.800 --> 01:07:49.800]  И это все будет работать как вы хотите. Вы сначала написали пакет параметров, ну или что нужно делать с пакетом параметров,
[01:07:49.800 --> 01:07:58.800]  а дальше написали fold expression, то есть выражение свертки, какую операцию нужно ко всем ним применить.
[01:07:58.800 --> 01:08:06.800]  В смысле, в последних пунктах?
[01:08:06.800 --> 01:08:08.800]  Да.
[01:08:08.800 --> 01:08:22.800]  Два пакета можно...
[01:08:22.800 --> 01:08:34.800]  Грубо говоря, вы хотите так. Допустим, у вас есть два пакета, arcs1 и arcs2, и вы хотите их, допустим, сложить друг с другом.
[01:08:34.800 --> 01:08:39.800]  Это можно сделать, но не совсем так. Здесь это можно сделать так.
[01:08:39.800 --> 01:08:51.800]  Во-первых, короче, это проще всего сделать в следующем образом. arcs1 распаковать, плюс многоточие, плюс arcs2 распаковать.
[01:08:51.800 --> 01:08:59.800]  Ой, не распаковать, тут ерунда. Вот так понятно, что происходит?
[01:08:59.800 --> 01:09:06.800]  То есть вот это у вас init. То есть он сначала распаковывается и вычисляется.
[01:09:06.800 --> 01:09:12.800]  А потом вы всю эту конструкцию применяете arcs2. То есть вот этот многоточий относится к вот этому arcs2.
[01:09:12.800 --> 01:09:20.800]  Потому что первый arcs1, он уже распакован. То есть нельзя два пакета распаковать одновременно.
[01:09:20.800 --> 01:09:23.800]  Вы должны сначала распаковать один пакет, потом распаковать другой пакет.
[01:09:23.800 --> 01:09:29.800]  То есть в каждом момент времени вы должны понимать, к какому пакету параметру у вас относится каждое многоточие.
[01:09:29.800 --> 01:09:33.800]  Вот так можно.
[01:09:33.800 --> 01:09:39.800]  Да, еще вопросы?
[01:09:39.800 --> 01:09:43.800]  Хорошо.
[01:09:43.800 --> 01:09:48.800]  Так, ну и отлично 5 минут есть. У меня есть несколько бонусных проблем, которые...
[01:09:48.800 --> 01:09:53.800]  В общем, на этом все. Все, что я хотел рассказать про шаблонность перемен и числому аргументов я рассказал.
[01:09:53.800 --> 01:09:58.800]  Сейчас несколько проблем, которые, возможно, были незаметны или которые потенциально могут встретиться.
[01:09:58.800 --> 01:10:05.800]  То есть первая проблема... Вообще говоря, я обманул, и вот этот принт работает не очень правильно.
[01:10:05.800 --> 01:10:10.800]  Ну, здесь уже есть ответ. В общем, он выводит все без пробелов.
[01:10:10.800 --> 01:10:17.800]  Смотрите, до этого, когда я использовал этот откусывание, я мог явно тут прописать пробел.
[01:10:17.800 --> 01:10:21.800]  То есть я вожу аргумент, вожу пробел.
[01:10:21.800 --> 01:10:27.800]  Когда я использую выражение свертки, у меня теряется возможность вывести пробел.
[01:10:27.800 --> 01:10:34.800]  Потому что у меня все побитые сдвига последовательно применяются ко всем параметрам.
[01:10:34.800 --> 01:10:40.800]  Проблему эту можно решить вот таким хитрым способом.
[01:10:40.800 --> 01:10:44.800]  Свертка с операцией запятая внезапно.
[01:10:44.800 --> 01:10:49.800]  Ну, если кто-то не знал, то запятая это бинарная операция.
[01:10:49.800 --> 01:10:53.800]  Операция запятая работает так. Она просто последовательно выполняет все, что ей дали.
[01:10:53.800 --> 01:10:59.800]  Если вы хотите вывести все через пробел, то решение выглядит следующим образом.
[01:10:59.800 --> 01:11:03.800]  Ну, вы пишете просто os.
[01:11:03.800 --> 01:11:05.800]  Тут уже написано все.
[01:11:05.800 --> 01:11:11.800]  Значит, вы просто пишете, что нужно применить карк с вот такой паттерн.
[01:11:11.800 --> 01:11:16.800]  То есть каждому аргументу нужно сделать следующую вещь.
[01:11:16.800 --> 01:11:21.800]  Нужно сначала вывести пробел, а потом сам аргумент.
[01:11:21.800 --> 01:11:23.800]  Потом я пишу запятую и многоточие.
[01:11:23.800 --> 01:11:25.800]  И все это оборачиваю скобки.
[01:11:25.800 --> 01:11:29.800]  И теперь это fold expression с бинарной операцией запятая.
[01:11:29.800 --> 01:11:31.800]  Понятно?
[01:11:31.800 --> 01:11:33.800]  То есть грубо говоря, у меня происходит следующая вещь.
[01:11:33.800 --> 01:11:37.800]  Os, короче, вывод пробела, вывод аркс 0, запятая.
[01:11:37.800 --> 01:11:42.800]  Вывод os, пробел, вывод аркс 1, запятая.
[01:11:42.800 --> 01:11:45.800]  Ну и так далее. Понятно?
[01:11:45.800 --> 01:11:50.800]  То есть вот это вот все применяется к каждому аргументу через запятую.
[01:11:50.800 --> 01:11:52.800]  Все ясно?
[01:11:52.800 --> 01:11:55.800]  Понятно, как это работает?
[01:11:55.800 --> 01:11:59.800]  То есть я просто выполнил выражение свертки для операции запятая.
[01:11:59.800 --> 01:12:02.800]  И через запятую указал, что мне нужно сделать для каждого параметра.
[01:12:02.800 --> 01:12:08.800]  В данном случае для каждого параметра нужно вывести его совместно с пробелом.
[01:12:08.800 --> 01:12:11.800]  Так, ну и вторая проблема.
[01:12:11.800 --> 01:12:13.800]  Наверняка у вас должен был возникнуть такой вопрос.
[01:12:13.800 --> 01:12:18.800]  Ну, смотрите, шаблоны с переменом числом аргументов это все-таки шаблоны.
[01:12:18.800 --> 01:12:21.800]  А шаблоны могут принимать все, что угодно.
[01:12:21.800 --> 01:12:27.800]  А что, если я хочу написать функцию, которая может принимать только int?
[01:12:27.800 --> 01:12:30.800]  Ну, естественное желание, я хочу написать функцию sumInt,
[01:12:30.800 --> 01:12:32.800]  которая суммирует только int.
[01:12:32.800 --> 01:12:35.800]  И в этом я хочу написать функцию, которая принимает произвольное количество int.
[01:12:35.800 --> 01:12:39.800]  А не произвольное количество элементов произвольного типа.
[01:12:39.800 --> 01:12:44.800]  Но тут у меня нет для вас радостной новости.
[01:12:44.800 --> 01:12:47.800]  Базовым синтаксом C++ это сделать нельзя.
[01:12:47.800 --> 01:12:50.800]  Можно только с помощью некоторого хака,
[01:12:50.800 --> 01:12:53.800]  на который, боюсь, у нас времени не хватит в этом семестре.
[01:12:53.800 --> 01:12:59.800]  Но, если что, можете пользоваться вот такой конструкцией.
[01:12:59.800 --> 01:13:02.800]  Если совсем коротко, то вы все еще принимаете...
[01:13:02.800 --> 01:13:06.800]  Вы в ряде к templates, то есть шаблоны с переменом числом аргументов,
[01:13:06.800 --> 01:13:08.800]  по-прежнему передаете его sumInt.
[01:13:08.800 --> 01:13:12.800]  И при этом дополнительно используете следующую конструкцию std-enable-ift.
[01:13:12.800 --> 01:13:15.800]  Std-enable-ift, судя по названию, говорит просто о том,
[01:13:15.800 --> 01:13:18.800]  что вот эту штуку нужно разрешить только в случае,
[01:13:18.800 --> 01:13:20.800]  если выполнено что-то.
[01:13:20.800 --> 01:13:22.800]  И вот это что-то, это вот это.
[01:13:22.800 --> 01:13:25.800]  Только в случае, если у вас все аргументы,
[01:13:25.800 --> 01:13:28.800]  все типы аргументов совпадают с int.
[01:13:28.800 --> 01:13:30.800]  Ну и тут дальше fold expression.
[01:13:30.800 --> 01:13:34.800]  То есть я применяю операцию i ко всем этим выражениям.
[01:13:34.800 --> 01:13:36.800]  То есть и первый аргумент у меня int, и второй аргумент у меня int,
[01:13:36.800 --> 01:13:38.800]  и третий аргумент, и так далее.
[01:13:38.800 --> 01:13:41.800]  И вот только в этом случае у меня вот эта сумма заработает.
[01:13:41.800 --> 01:13:43.800]  Если я передаю не все int,
[01:13:43.800 --> 01:13:45.800]  то эта штука не работает.
[01:13:47.800 --> 01:13:49.800]  Ну или более мягкий вариант.
[01:13:49.800 --> 01:13:51.800]  Вы все-таки принимаете все что угодно,
[01:13:51.800 --> 01:13:55.800]  но при этом при суммировании делаете static-cast к int.
[01:13:55.800 --> 01:13:58.800]  То есть приводите к int то, что вам передали.
[01:13:58.800 --> 01:14:00.800]  Это не порождает вам ошибку компиляции,
[01:14:00.800 --> 01:14:04.800]  а просто-напросто приводит к int то, что вы передали.
[01:14:07.800 --> 01:14:09.800]  Вот такие дела.
[01:14:09.800 --> 01:14:12.800]  Ну и теперь мы на самом деле более-менее понимаем,
[01:14:12.800 --> 01:14:14.800]  что нужно писать в make-unique.
[01:14:14.800 --> 01:14:17.800]  Давайте вернемся к изначальной задаче.
[01:14:17.800 --> 01:14:19.800]  Мы все-таки хотели написать make-unique.
[01:14:19.800 --> 01:14:21.800]  Теперь понятно, что мы делаем.
[01:14:21.800 --> 01:14:25.800]  Мы теперь пишем template class-t.
[01:14:25.800 --> 01:14:27.800]  make-unique у нас возвращает,
[01:14:27.800 --> 01:14:29.800]  давайте наш unique-ptr, который мы писали,
[01:14:29.800 --> 01:14:33.800]  unique-ptr от t.
[01:14:33.800 --> 01:14:37.800]  make-unique.
[01:14:39.800 --> 01:14:41.800]  И что он должен принимать?
[01:14:45.800 --> 01:14:49.800]  Ну он должен принимать произвольное количество аргументов.
[01:14:49.800 --> 01:14:51.800]  Так мы заранее не знаем,
[01:14:51.800 --> 01:14:53.800]  какое количество аргументов нужно передать конструктор t,
[01:14:53.800 --> 01:14:56.800]  поэтому мы принимаем сразу произвольное количество.
[01:14:56.800 --> 01:15:00.800]  То есть мы пишем class-maga.args.
[01:15:00.800 --> 01:15:02.800]  И здесь...
[01:15:02.800 --> 01:15:04.800]  ну давайте напишем пока так.
[01:15:04.800 --> 01:15:08.800]  args-maga.args.
[01:15:08.800 --> 01:15:12.800]  И дальше здесь пишем return.
[01:15:12.800 --> 01:15:16.800]  Вот, да, уже слышу, что кто-то понимает проблему.
[01:15:16.800 --> 01:15:18.800]  ptr-t.
[01:15:18.800 --> 01:15:24.800]  Ну и здесь уже сразу пишем new-t args-maga.
[01:15:24.800 --> 01:15:26.800]  В общем, понятно, да, идея?
[01:15:26.800 --> 01:15:28.800]  Мы пишем шаблонную функцию make-unique,
[01:15:28.800 --> 01:15:30.800]  которая в качестве первого шаблона параметра понимает t,
[01:15:30.800 --> 01:15:34.800]  то есть тип умного указателя, который нужно вернуть.
[01:15:34.800 --> 01:15:36.800]  Дальше мы принимаем произвольное количество аргументов,
[01:15:36.800 --> 01:15:40.800]  и все эти аргументы мы будем передавать в конструктор.
[01:15:40.800 --> 01:15:42.800]  Здесь мы эти аргументы принимаем,
[01:15:42.800 --> 01:15:44.800]  здесь мы эти аргументы с помощью распаковки
[01:15:44.800 --> 01:15:46.800]  передаем в конструктор t.
[01:15:46.800 --> 01:15:48.800]  Но при этом возникает проблема,
[01:15:48.800 --> 01:15:50.800]  которую уже заметили,
[01:15:50.800 --> 01:15:54.800]  что тут мы все аргументы принимаем по значению.
[01:15:54.800 --> 01:15:56.800]  То есть потенциально копируем.
[01:15:56.800 --> 01:15:58.800]  Было бы неплохо здесь написать какую-нибудь ссылку,
[01:15:58.800 --> 01:16:00.800]  например, const args-ampersand.
[01:16:00.800 --> 01:16:02.800]  Но тогда все аргументы будем принимать по константной ссылке,
[01:16:02.800 --> 01:16:06.800]  и с этим на самом деле тоже есть проблемы,
[01:16:06.800 --> 01:16:08.800]  которые мы сейчас осознаем в начале следующей лекции,
[01:16:08.800 --> 01:16:10.800]  и к которым будем решать всю следующую часть.
[01:16:10.800 --> 01:16:14.800]  Сегодня мы продолжим семантическое перемещение,
[01:16:14.800 --> 01:16:16.800]  надеюсь, с ней закончим.
[01:16:16.800 --> 01:16:20.800]  Рассмотрим некоторые более продвинутые сценарии.
[01:16:20.800 --> 01:16:22.800]  Вот вообще, наверное, вот эта часть,
[01:16:22.800 --> 01:16:24.800]  она наиболее сложная в курсе,
[01:16:24.800 --> 01:16:26.800]  если вообще в принципе можно считать ее сложной.
[01:16:26.800 --> 01:16:28.800]  Но как сложной?
[01:16:28.800 --> 01:16:30.800]  Тут главное осознать проблему.
[01:16:30.800 --> 01:16:32.800]  Вот если осознание проблемы придет,
[01:16:32.800 --> 01:16:34.800]  то я думаю, все будет нормально.
[01:16:34.800 --> 01:16:36.800]  Давайте как раз таки с проблемой и начнем.
[01:16:36.800 --> 01:16:38.800]  Смотрите.
[01:16:38.800 --> 01:16:40.800]  Давайте издалека.
[01:16:40.800 --> 01:16:42.800]  Вот есть язык Python,
[01:16:42.800 --> 01:16:44.800]  те, кто с ним знакомы,
[01:16:44.800 --> 01:16:46.800]  и вы знаете, что это язык Python,
[01:16:46.800 --> 01:16:48.800]  и вы знаете, что это язык Python.
[01:16:48.800 --> 01:16:50.800]  Есть язык Python,
[01:16:50.800 --> 01:16:52.800]  те, кто с ним знакомы,
[01:16:52.800 --> 01:16:54.800]  наверняка знакомы с таким понятием,
[01:16:54.800 --> 01:16:56.800]  как декоратор.
[01:16:56.800 --> 01:16:58.800]  Декоратор – это просто некоторая функция,
[01:16:58.800 --> 01:17:00.800]  которая оборачивает другую функцию.
[01:17:00.800 --> 01:17:02.800]  Функция занимается своим делом,
[01:17:02.800 --> 01:17:04.800]  и при этом есть декоратор,
[01:17:04.800 --> 01:17:06.800]  который навешивает на нее какой-то дополнительный функционал.
[01:17:06.800 --> 01:17:08.800]  Например, логирует все ее действия,
[01:17:08.800 --> 01:17:10.800]  то есть увозит на экран,
[01:17:10.800 --> 01:17:12.800]  что эта функция запустилась, эта функция кончила работу,
[01:17:12.800 --> 01:17:14.800]  или вычисляет время, сколько работала там та или иная функция,
[01:17:14.800 --> 01:17:16.800]  или что-то еще.
[01:17:16.800 --> 01:17:18.800]  Представим себе, что
[01:17:18.800 --> 01:17:20.800]  в C++ мы хотим сделать то же самое.
[01:17:20.800 --> 01:17:22.800]  То есть мы хотим написать некоторую функцию,
[01:17:22.800 --> 01:17:24.800]  которая бы принимала другую функцию,
[01:17:24.800 --> 01:17:26.800]  принимала аргументы этой функции,
[01:17:26.800 --> 01:17:28.800]  вызывала эту функцию
[01:17:28.800 --> 01:17:30.800]  с этим аргументом,
[01:17:30.800 --> 01:17:32.800]  и при этом дополнительно вычисляла время работы
[01:17:32.800 --> 01:17:34.800]  нужной нам функции.
[01:17:34.800 --> 01:17:36.800]  То есть я хочу написать функцию RunningTime,
[01:17:36.800 --> 01:17:38.800]  которая принимает функцию
[01:17:38.800 --> 01:17:40.800]  и ее аргумент.
[01:17:40.800 --> 01:17:42.800]  Пока давайте для простоты считать,
[01:17:42.800 --> 01:17:44.800]  что все функции принимают только один аргумент.
[01:17:44.800 --> 01:17:46.800]  Как распространить это на много аргументов,
[01:17:46.800 --> 01:17:48.800]  мы уже поговорили, достаточно сказать многоточие.
[01:17:48.800 --> 01:17:50.800]  Но для простоты давайте пока считать, что только один аргумент.
[01:17:50.800 --> 01:17:52.800]  Есть функция,
[01:17:52.800 --> 01:17:54.800]  я принимаю ее с помощью шаблонов аргументов,
[01:17:54.800 --> 01:17:56.800]  чтобы, во-первых, не заморачиваться с типом функции,
[01:17:56.800 --> 01:17:58.800]  потому что функция мне может прийти какая угодно.
[01:17:58.800 --> 01:18:00.800]  Она может возвращать что угодно,
[01:18:00.800 --> 01:18:02.800]  она может принимать что угодно и так далее.
[01:18:02.800 --> 01:18:04.800]  Ну и плюс в качестве вот этой функции
[01:18:04.800 --> 01:18:06.800]  мне может прийти не просто функция,
[01:18:06.800 --> 01:18:08.800]  а на самом деле некоторая структура,
[01:18:08.800 --> 01:18:10.800]  у которой перегружены круглые скобки.
[01:18:10.800 --> 01:18:12.800]  Ее, естественно, я тоже могу вызвать.
[01:18:12.800 --> 01:18:14.800]  Ну и плюс в качестве шаблонов аргументов я принимаю арк.
[01:18:14.800 --> 01:18:16.800]  Естественно, тоже произвольный,
[01:18:16.800 --> 01:18:18.800]  потому что непонятно, что мне функцию могут передать.
[01:18:18.800 --> 01:18:20.800]  Ну и что я делаю?
[01:18:20.800 --> 01:18:22.800]  В начале работы я просто вызываю
[01:18:22.800 --> 01:18:24.800]  стандартную функцию stackLog.
[01:18:24.800 --> 01:18:26.800]  StackLog просто берет
[01:18:26.800 --> 01:18:28.800]  текущую отметку времени,
[01:18:28.800 --> 01:18:30.800]  грубо говоря.
[01:18:30.800 --> 01:18:32.800]  То есть я выключаю таймер,
[01:18:32.800 --> 01:18:34.800]  дальше вызываю эту функцию
[01:18:34.800 --> 01:18:36.800]  с передним аргументом,
[01:18:36.800 --> 01:18:38.800]  и дальше таймер выключаю, точнее нажимаю еще раз на таймер,
[01:18:38.800 --> 01:18:40.800]  и вычисляю, сколько времени прошло от начала до конца.
[01:18:40.800 --> 01:18:42.800]  И возвращаю там некоторые значения.
[01:18:42.800 --> 01:18:44.800]  Грубо говоря,
[01:18:44.800 --> 01:18:46.800]  сколько моя функция отработала процессорного времени.
[01:18:46.800 --> 01:18:48.800]  То есть как работает running time понятно,
[01:18:48.800 --> 01:18:50.800]  что я от нее хочу.
[01:18:50.800 --> 01:18:52.800]  Я хочу, чтобы она принимала функцию,
[01:18:52.800 --> 01:18:54.800]  принимала аргумент,
[01:18:54.800 --> 01:18:56.800]  вызывала эту функцию с нужным аргументом,
[01:18:56.800 --> 01:18:58.800]  и при этом возвращала в качестве ответа,
[01:18:58.800 --> 01:19:00.800]  сколько у меня отработала эта функция.
[01:19:00.800 --> 01:19:02.800]  Довольно полезная функция,
[01:19:02.800 --> 01:19:04.800]  если вы пишете какие-то свои бейчмарки,
[01:19:04.800 --> 01:19:06.800]  хотите измерять время работы тех или иных отдельных
[01:19:06.800 --> 01:19:08.800]  кусков функций.
[01:19:08.800 --> 01:19:10.800]  Если у вас есть функция function,
[01:19:10.800 --> 01:19:12.800]  которая принимает int,
[01:19:12.800 --> 01:19:14.800]  я вызываю функцию от пяти, она нормально работает.
[01:19:14.800 --> 01:19:16.800]  Я вызываю running time от функции от пяти,
[01:19:16.800 --> 01:19:18.800]  и внешний running time не возвращает,
[01:19:18.800 --> 01:19:20.800]  сколько времени отработала моя функция.
[01:19:20.800 --> 01:19:22.800]  Все работает, понятно.
[01:19:22.800 --> 01:19:24.800]  Пятерка сохраняется в арг, арг передается внутрь функции,
[01:19:24.800 --> 01:19:26.800]  все нормально.
[01:19:26.800 --> 01:19:28.800]  В чем проблема?
[01:19:28.800 --> 01:19:30.800]  Кто понимает, в чем может быть проблема?
[01:19:30.800 --> 01:19:32.800]  Это функция, она копируется.
[01:19:32.800 --> 01:19:34.800]  Это функция, она копируется,
[01:19:34.800 --> 01:19:36.800]  это одна из проблем.
[01:19:36.800 --> 01:19:38.800]  Мы можем победить, если тут написать на, допустим, амперсант.
[01:19:38.800 --> 01:19:40.800]  Это ничего страшного.
[01:19:40.800 --> 01:19:42.800]  Если у нас функция
[01:19:42.800 --> 01:19:44.800]  передается просто по указателю на функцию,
[01:19:44.800 --> 01:19:46.800]  то указатели, в принципе, копируются дешево.
[01:19:46.800 --> 01:19:48.800]  Это не самая главная проблема.
[01:19:48.800 --> 01:19:50.800]  Тут есть
[01:19:50.800 --> 01:19:52.800]  другая,
[01:19:52.800 --> 01:19:54.800]  более интересная.
[01:19:54.800 --> 01:19:56.800]  Хорошо.
[01:19:56.800 --> 01:19:58.800]  На следующий слайд переходим.
[01:19:58.800 --> 01:20:00.800]  Давайте рассмотрим другую функцию.
[01:20:00.800 --> 01:20:02.800]  Другая функция function тоже возвращает void,
[01:20:02.800 --> 01:20:04.800]  но при этом возвращает int по ссылке.
[01:20:04.800 --> 01:20:06.800]  Возвращает int по ссылке
[01:20:06.800 --> 01:20:08.800]  и внутри себя делает plus-plus-value.
[01:20:08.800 --> 01:20:10.800]  Вполне себе допустимый код.
[01:20:10.800 --> 01:20:12.800]  Если я в функцию что-то передал по ссылке,
[01:20:12.800 --> 01:20:14.800]  то эта функция может это значение изменить.
[01:20:14.800 --> 01:20:16.800]  Логично.
[01:20:16.800 --> 01:20:18.800]  Хорошо.
[01:20:18.800 --> 01:20:20.800]  У меня есть переменная int x,
[01:20:20.800 --> 01:20:22.800]  я вызываю function от x.
[01:20:22.800 --> 01:20:24.800]  Если я вызываю function от x, то, естественно, я ожидаю,
[01:20:24.800 --> 01:20:26.800]  что x у меня увеличится на единицу.
[01:20:26.800 --> 01:20:28.800]  Потому что function ровно это и делает.
[01:20:28.800 --> 01:20:30.800]  А теперь я вызываю running time
[01:20:30.800 --> 01:20:32.800]  от функции от x.
[01:20:32.800 --> 01:20:34.800]  Смотрите еще раз.
[01:20:34.800 --> 01:20:36.800]  Какой у меня контракт? Что я ожидаю от функции running time?
[01:20:36.800 --> 01:20:38.800]  От функции running time я ожидаю,
[01:20:38.800 --> 01:20:40.800]  что она возьмет function, возьмет аргумент,
[01:20:40.800 --> 01:20:42.800]  вызовет функцию function с передным аргументом
[01:20:42.800 --> 01:20:44.800]  и просто дополнительно
[01:20:44.800 --> 01:20:46.800]  вернет время работы.
[01:20:46.800 --> 01:20:48.800]  Но если я запущу running time от function от x,
[01:20:48.800 --> 01:20:50.800]  у меня x останется равным единице.
[01:20:52.800 --> 01:20:54.800]  То есть произошло не то, чего я хотел.
[01:20:54.800 --> 01:20:56.800]  Почему?
[01:20:56.800 --> 01:20:58.800]  Да, смотрите,
[01:20:58.800 --> 01:21:00.800]  потому что вот этот арк
[01:21:00.800 --> 01:21:02.800]  он у меня свяжется,
[01:21:02.800 --> 01:21:04.800]  ну, точнее, не свяжется,
[01:21:04.800 --> 01:21:06.800]  неправильно сказал.
[01:21:06.800 --> 01:21:08.800]  Вот этот арк, вот в этот арк
[01:21:08.800 --> 01:21:10.800]  скопируется содержимое x.
[01:21:10.800 --> 01:21:12.800]  То есть арк
[01:21:12.800 --> 01:21:14.800]  будет копией x.
[01:21:14.800 --> 01:21:16.800]  И когда я буду вызывать вот здесь func от arg,
[01:21:16.800 --> 01:21:18.800]  у меня функция function
[01:21:18.800 --> 01:21:20.800]  будет работать с вот этим
[01:21:20.800 --> 01:21:22.800]  аргом, но не с x.
[01:21:22.800 --> 01:21:24.800]  Понятно?
[01:21:24.800 --> 01:21:26.800]  То есть я буду функцию function
[01:21:26.800 --> 01:21:28.800]  передавать ссылку, но ссылку
[01:21:28.800 --> 01:21:30.800]  на исходный x,
[01:21:30.800 --> 01:21:32.800]  а на локальный арк.
[01:21:32.800 --> 01:21:34.800]  И будет заменяться именно локальный арк.
[01:21:34.800 --> 01:21:36.800]  То есть после того, как у меня отработает функция function,
[01:21:36.800 --> 01:21:38.800]  у меня локальный арк станет равным на двойке,
[01:21:38.800 --> 01:21:40.800]  ну а x он вообще ни сном ни духом.
[01:21:40.800 --> 01:21:42.800]  Потому что он просто скопировался туда.
[01:21:42.800 --> 01:21:44.800]  Понятно?
[01:21:44.800 --> 01:21:46.800]  Проблема.
[01:21:46.800 --> 01:21:48.800]  Ну хорошо.
[01:21:48.800 --> 01:21:50.800]  Как побороть эту проблему?
[01:21:50.800 --> 01:21:52.800]  Я предлагаю тут написать амперсант.
[01:21:52.800 --> 01:21:54.800]  Ну у нас может что передаться?
[01:21:54.800 --> 01:21:56.800]  Ну да, да.
[01:21:56.800 --> 01:21:58.800]  Давайте сначала разберемся с этим.
[01:21:58.800 --> 01:22:00.800]  Вот я предлагаю написать
[01:22:00.800 --> 01:22:02.800]  арк амперсант, чтобы решить эту проблему.
[01:22:02.800 --> 01:22:04.800]  Но тогда казалось бы,
[01:22:04.800 --> 01:22:06.800]  все нормально тоже.
[01:22:06.800 --> 01:22:08.800]  Вот есть function, она принимает
[01:22:08.800 --> 01:22:10.800]  in по ссылке,
[01:22:10.800 --> 01:22:12.800]  у меня есть x, я вызываю function от x,
[01:22:12.800 --> 01:22:14.800]  x становится равным единицам.
[01:22:14.800 --> 01:22:16.800]  Вызываю running time от function от x,
[01:22:16.800 --> 01:22:18.800]  x становится равным двойке. Почему?
[01:22:18.800 --> 01:22:20.800]  Потому что в arg сохраняется
[01:22:20.800 --> 01:22:22.800]  ссылка на x, и когда я изменяю arg,
[01:22:22.800 --> 01:22:24.800]  я на самом деле изменяю x.
[01:22:24.800 --> 01:22:26.800]  Потому что arg это ссылка на x.
[01:22:26.800 --> 01:22:28.800]  Ну вот как правильно сказал оператор,
[01:22:28.800 --> 01:22:30.800]  возвращаемся к исходному function,
[01:22:30.800 --> 01:22:32.800]  который принимает не ссылку,
[01:22:32.800 --> 01:22:34.800]  а принимает просто int.
[01:22:34.800 --> 01:22:36.800]  Вызываю function от 5,
[01:22:36.800 --> 01:22:38.800]  все отлично работает.
[01:22:38.800 --> 01:22:40.800]  Пробую вызвать running time от function от 5,
[01:22:40.800 --> 01:22:42.800]  ошибка компиляции.
[01:22:42.800 --> 01:22:44.800]  Почему?
[01:22:44.800 --> 01:22:46.800]  Потому что ссылка имеет право
[01:22:46.800 --> 01:22:48.800]  связываться только с cell value.
[01:22:48.800 --> 01:22:50.800]  Помним, что такое L-value и R-value.
[01:22:50.800 --> 01:22:52.800]  L-value ссылки имеет право связываться только с L-value.
[01:22:52.800 --> 01:22:54.800]  Опять, это литерал.
[01:22:54.800 --> 01:22:56.800]  Литерал это по R-value.
[01:22:56.800 --> 01:22:58.800]  Ну все, беда.
[01:22:58.800 --> 01:23:00.800]  Короче, проблема ясна.
[01:23:00.800 --> 01:23:02.800]  Есть function running time,
[01:23:02.800 --> 01:23:04.800]  я хочу, чтобы она принимала функцию, принимала аргумент.
[01:23:04.800 --> 01:23:06.800]  И хочу, чтобы все побочные
[01:23:06.800 --> 01:23:08.800]  эффекты у меня были доступны.
[01:23:08.800 --> 01:23:10.800]  Если function принимает ссылку,
[01:23:10.800 --> 01:23:12.800]  я хочу, чтобы туда передавалась ссылка.
[01:23:12.800 --> 01:23:14.800]  Если function принимает не ссылку,
[01:23:14.800 --> 01:23:16.800]  хочу, чтобы туда передавалась копия.
[01:23:16.800 --> 01:23:18.800]  Но у меня не получается.
[01:23:18.800 --> 01:23:20.800]  У меня банально на самом первом уровне
[01:23:20.800 --> 01:23:22.800]  возникает проблема.
[01:23:22.800 --> 01:23:24.800]  Я не знаю, что мне передать вот сюда.
[01:23:26.800 --> 01:23:28.800]  В чем дело?
[01:23:28.800 --> 01:23:30.800]  Дело в том, что
[01:23:30.800 --> 01:23:32.800]  этот аргумент
[01:23:32.800 --> 01:23:34.800]  не умеет подстраиваться
[01:23:34.800 --> 01:23:36.800]  от фактических аргументов функции.
[01:23:36.800 --> 01:23:38.800]  Хотелось бы, чтобы этот аргумент вел себя так.
[01:23:38.800 --> 01:23:40.800]  Если бы я передал L-value объект,
[01:23:40.800 --> 01:23:42.800]  у меня бы арк связался с L-value объектом.
[01:23:42.800 --> 01:23:44.800]  Была бы L-value ссылка на этот объект.
[01:23:44.800 --> 01:23:46.800]  Если бы я передал туда R-value,
[01:23:46.800 --> 01:23:48.800]  то я бы хотел, чтобы у меня была
[01:23:48.800 --> 01:23:50.800]  R-value ссылка на этот объект.
[01:23:52.800 --> 01:23:54.800]  Я бы хотел, чтобы этот арк
[01:23:54.800 --> 01:23:56.800]  как-то адаптировался под то,
[01:23:56.800 --> 01:23:58.800]  что я туда подаю.
[01:23:58.800 --> 01:24:00.800]  Если я туда передаю L-value,
[01:24:00.800 --> 01:24:02.800]  я хочу L-value ссылку.
[01:24:02.800 --> 01:24:04.800]  Если я туда передаю R-value объект,
[01:24:04.800 --> 01:24:06.800]  то я хочу, чтобы там была R-value ссылка.
[01:24:10.800 --> 01:24:12.800]  В качестве решения можно предложить
[01:24:12.800 --> 01:24:14.800]  вот эту функцию RunningTime
[01:24:16.800 --> 01:24:18.800]  перегрузить.
[01:24:18.800 --> 01:24:20.800]  Ну хорошо, давайте напишем перегрузку.
[01:24:20.800 --> 01:24:22.800]  Одна перегрузка будет
[01:24:22.800 --> 01:24:24.800]  принимать L-value,
[01:24:24.800 --> 01:24:26.800]  вторая перегрузка будет принимать R-value.
[01:24:26.800 --> 01:24:28.800]  Решение?
[01:24:28.800 --> 01:24:30.800]  Частично да, вообще говоря, решение.
[01:24:30.800 --> 01:24:32.800]  Но тут возникает дублирование кода.
[01:24:32.800 --> 01:24:34.800]  Понятное дело, что функция RunningTime
[01:24:34.800 --> 01:24:36.800]  очень маленькая.
[01:24:36.800 --> 01:24:38.800]  А что если вам нужны большие функции?
[01:24:38.800 --> 01:24:40.800]  Вот большие функции, которые имеют
[01:24:40.800 --> 01:24:42.800]  очень большую семантику,
[01:24:42.800 --> 01:24:44.800]  тогда вы дублируете код.
[01:24:44.800 --> 01:24:46.800]  Вы можете мне ответить.
[01:24:46.800 --> 01:24:48.800]  Сам собой это делаю.
[01:24:48.800 --> 01:24:50.800]  Кто-то из вас может мне сказать,
[01:24:50.800 --> 01:24:52.800]  ну смотрите, мы же ровно то же самое делали,
[01:24:52.800 --> 01:24:54.800]  когда писали перемещающие конструкторы.
[01:24:54.800 --> 01:24:56.800]  Мы же перемещающий конструктор перегружали.
[01:24:56.800 --> 01:24:58.800]  Вы помните, мы писали отдельно
[01:24:58.800 --> 01:25:00.800]  конструктор копирования для L-value ссылки
[01:25:00.800 --> 01:25:02.800]  и писали перемещение в случае,
[01:25:02.800 --> 01:25:04.800]  когда мне передается R-value объект,
[01:25:04.800 --> 01:25:06.800]  то есть R-value ссылка.
[01:25:06.800 --> 01:25:08.800]  Но там не было дублирования кода.
[01:25:08.800 --> 01:25:10.800]  Мы как бы зашивались на это поведение.
[01:25:10.800 --> 01:25:12.800]  Мы как бы сказали, что в случае L-value
[01:25:12.800 --> 01:25:14.800]  мы действуем одним образом, то есть мы копируем,
[01:25:14.800 --> 01:25:16.800]  в случае R-value мы перемещаем.
[01:25:16.800 --> 01:25:18.800]  Здесь другая ситуация.
[01:25:20.800 --> 01:25:22.800]  Здесь мы хотим делать
[01:25:22.800 --> 01:25:24.800]  практически то же самое,
[01:25:24.800 --> 01:25:26.800]  но только с изменением R-value ссылки на L-value ссылку.
[01:25:26.800 --> 01:25:28.800]  Это другое. Понятно?
[01:25:32.800 --> 01:25:34.800]  Как решается эта проблема?
[01:25:34.800 --> 01:25:36.800]  Решается эта проблема с помощью
[01:25:36.800 --> 01:25:38.800]  так называемых forwarding ссылок
[01:25:38.800 --> 01:25:40.800]  или пробрасывающих ссылок,
[01:25:40.800 --> 01:25:42.800]  ну или в русскоязычной литературе более часто
[01:25:42.800 --> 01:25:44.800]  встречается универсальная ссылка.
[01:25:44.800 --> 01:25:46.800]  Сейчас мы познакомимся с универсальными ссылками,
[01:25:46.800 --> 01:25:48.800]  которые ведут себя ровно так, как я хочу.
[01:25:48.800 --> 01:25:50.800]  То есть если я передал L-value объект,
[01:25:50.800 --> 01:25:52.800]  то это L-value ссылка,
[01:25:52.800 --> 01:25:54.800]  если передал туда R-value объект,
[01:25:54.800 --> 01:25:56.800]  то это R-value ссылка.
[01:25:56.800 --> 01:25:58.800]  Как она выглядит?
[01:25:58.800 --> 01:26:00.800]  Нет. Сначала поговорим
[01:26:00.800 --> 01:26:02.800]  про немного извлеченную тему,
[01:26:02.800 --> 01:26:04.800]  про сворачивание ссылок.
[01:26:04.800 --> 01:26:06.800]  Это короткий пункт.
[01:26:06.800 --> 01:26:08.800]  Идея такая.
[01:26:08.800 --> 01:26:10.800]  В процессе
[01:26:10.800 --> 01:26:12.800]  подстановки шаблонных параметров,
[01:26:12.800 --> 01:26:14.800]  это все про шаблоны функций,
[01:26:14.800 --> 01:26:16.800]  если у вас есть шаблоны функций,
[01:26:16.800 --> 01:26:18.800]  то в процессе подстановки шаблонов
[01:26:18.800 --> 01:26:20.800]  у вас могут возникнуть конструкции вида
[01:26:20.800 --> 01:26:22.800]  ссылка на ссылку,
[01:26:22.800 --> 01:26:24.800]  правая ссылка на ссылку,
[01:26:24.800 --> 01:26:26.800]  левая ссылка на правую ссылку и так далее.
[01:26:26.800 --> 01:26:28.800]  Как это может получиться?
[01:26:28.800 --> 01:26:30.800]  Очень просто.
[01:26:30.800 --> 01:26:32.800]  Вы написали функцию f,
[01:26:32.800 --> 01:26:34.800]  2-ой аргумент принимается с помощью t-двойной амперсант.
[01:26:34.800 --> 01:26:36.800]  Но если вы вызываете эту функцию
[01:26:36.800 --> 01:26:38.800]  например, вот так, f от int амперсант.
[01:26:38.800 --> 01:26:40.800]  Понятное дело, что в процессе
[01:26:40.800 --> 01:26:42.800]  подстановки у вас получается следующая вещь.
[01:26:42.800 --> 01:26:44.800]  int от амперсант,
[01:26:44.800 --> 01:26:46.800]  и на это все навешивается амперсант,
[01:26:46.800 --> 01:26:48.800]  а потом еще int амперсант,
[01:26:48.800 --> 01:26:50.800]  и на это все навешивается 2 амперсанда.
[01:26:50.800 --> 01:26:52.800]  В языке C++
[01:26:52.800 --> 01:26:54.800]  не существует ссылок
[01:26:54.800 --> 01:26:56.800]  на ссылки, это помним.
[01:26:56.800 --> 01:26:58.800]  Не существуют правые ссылки
[01:26:58.800 --> 01:27:00.800]  на левую ссылку, не существуют
[01:27:00.800 --> 01:27:02.800]  правые ссылки на левую ссылку и так далее.
[01:27:02.800 --> 01:27:04.800]  Но компилятору можно.
[01:27:04.800 --> 01:27:06.800]  Компилятор сам себе разрешает
[01:27:06.800 --> 01:27:08.800]  создавать ссылки на ссылку.
[01:27:08.800 --> 01:27:10.800]  Точнее не так, он разрешает себе писать подобные вещи.
[01:27:10.800 --> 01:27:12.800]  Но при этом эта вещь
[01:27:12.800 --> 01:27:14.800]  ведет себя не как ссылка на ссылку,
[01:27:14.800 --> 01:27:16.800]  а ведет себя
[01:27:16.800 --> 01:27:18.800]  по-другому.
[01:27:18.800 --> 01:27:20.800]  Ведет себя следующим образом,
[01:27:20.800 --> 01:27:22.800]  по правилу сворачивания ссылок.
[01:27:22.800 --> 01:27:24.800]  Правило здесь такое,
[01:27:24.800 --> 01:27:26.800]  если вы создали левую ссылку на левую ссылку,
[01:27:26.800 --> 01:27:28.800]  то у вас общий тип,
[01:27:28.800 --> 01:27:30.800]  в итоге получается это просто обычная ссылка.
[01:27:30.800 --> 01:27:32.800]  Если вы создаете правую ссылку
[01:27:32.800 --> 01:27:34.800]  на обычную ссылку, то у вас тоже обычная ссылка.
[01:27:34.800 --> 01:27:36.800]  Если вы создаете обычную ссылку на правую ссылку,
[01:27:36.800 --> 01:27:38.800]  то тоже обычная ссылка.
[01:27:38.800 --> 01:27:40.800]  И только если вы создаете правую ссылку на правую ссылку,
[01:27:40.800 --> 01:27:42.800]  то у вас в итоге получается правая ссылка.
[01:27:42.800 --> 01:27:44.800]  То есть это все можно уменьшить
[01:27:44.800 --> 01:27:48.800]  до мини от амперсанда и 2 амперсанда.
[01:27:48.800 --> 01:27:52.800]  То есть из амперсанда выживает только на меньшее из них.
[01:27:52.800 --> 01:27:54.800]  То есть на меньшее количество амперсантов.
[01:27:54.800 --> 01:27:56.800]  Еще раз вы в своем коде так писать не можете.
[01:27:56.800 --> 01:28:00.860]  Еще раз, вы в своем коде так писать не можете, вы не имеете права написать вот так.
[01:28:04.460 --> 01:28:09.740]  Так писать нельзя. Вот такой имеет право написать только компилятор, когда подставляет ваши шаблонные параметры.
[01:28:11.780 --> 01:28:14.700]  Понятно? То есть что здесь на самом деле происходит?
[01:28:15.700 --> 01:28:19.700]  Здесь у вас в качестве типа T подставляется int&&, потому что вы явно попросили об этом.
[01:28:19.700 --> 01:28:25.660]  Но при этом тип X это int&& и тип Y это тоже int&& по правилу сворачивания ссылок.
[01:28:27.660 --> 01:28:33.660]  Если вы передаете int&&, то в качестве T у вас естественно вводится int&&, потому что вы явно об этом попросили.
[01:28:33.660 --> 01:28:40.660]  Но при этом тип X это int&&, а тип Y это int&&, потому что вы 2&& навесили на 2&&.
[01:28:40.660 --> 01:28:42.660]  Все понятно?
[01:28:42.660 --> 01:28:46.660]  Ну, это вот такая техническая деталь, про которую сейчас поговорили.
[01:28:46.660 --> 01:28:52.660]  Окей. Теперь непосредственно про универсальные ссылки.
[01:28:53.520 --> 01:28:55.520]  Смотрите, что такое универсальная ссылка?
[01:28:55.520 --> 01:28:58.520]  Универсальная ссылка – это ссылка одного из двух видов.
[01:28:58.520 --> 01:29:02.520]  Либо T2&, либо afto2&.
[01:29:02.520 --> 01:29:12.520]  Вот, смотрите, когда я пишу обычную функцию fint2&, вот это называется R-value ссылка.
[01:29:15.520 --> 01:29:19.520]  Ссылка на int.
[01:29:20.380 --> 01:29:25.380]  Когда я пишу это все в шаблонном контексте, то есть если у меня T – это шаблонный параметр функции,
[01:29:25.380 --> 01:29:33.380]  значит важно, что T – это шаблонный параметр функции.
[01:29:33.380 --> 01:29:39.380]  Вот если T – это шаблонный параметр функции, и я написал T2&, то это считается не R-value ссылкой,
[01:29:39.380 --> 01:29:43.380]  а это считается универсальной ссылкой, называется универсальной ссылкой.
[01:29:43.380 --> 01:29:45.380]  Тоже самое касается afto.
[01:29:46.240 --> 01:29:48.240]  Написали T2& и больше ничего.
[01:29:48.240 --> 01:29:54.240]  Да, важный момент, что кроме T2& и кроме afto2& ничего не должно быть написано.
[01:29:54.240 --> 01:29:56.240]  То есть никакого const не волатайл, не указатель, ничего.
[01:29:56.240 --> 01:30:02.240]  Если T2&, ну, понятное дело, с точностью до замены там T на U.
[01:30:02.240 --> 01:30:06.240]  Понятно, что если вы шаблонный параметр назвали по-другому, то это тоже работает.
[01:30:06.240 --> 01:30:10.240]  Тут имеется в виду, что если вы написали шаблонный параметр,
[01:30:10.240 --> 01:30:13.240]  2& без всяких const и так далее, то это универсальная ссылка.
[01:30:13.300 --> 01:30:17.300]  Если вы написали afto без const, без указателей, без ничего другого,
[01:30:17.300 --> 01:30:19.300]  просто 2&, то это тоже универсальная ссылка.
[01:30:21.300 --> 01:30:24.300]  Важно понимать, что универсальной ссылкой R-value ссылкой не является.
[01:30:24.300 --> 01:30:26.300]  Мы сейчас посмотрим, почему.
[01:30:26.300 --> 01:30:28.300]  Мы посмотрим, как ведут себя универсальные ссылки.
[01:30:28.300 --> 01:30:33.300]  А пока примеры того, что на самом деле универсальными ссылками не являются.
[01:30:33.300 --> 01:30:37.300]  Как я сказал, универсальные ссылки это только ссылки вида T2& или afto2&.
[01:30:37.300 --> 01:30:40.300]  Что универсальными ссылками не являются.
[01:30:40.360 --> 01:30:44.360]  Если вы навесили на T или на шаблонный параметр const,
[01:30:44.360 --> 01:30:46.360]  то это уже не универсальная ссылка.
[01:30:46.360 --> 01:30:50.360]  Это R-value ссылка на константный T.
[01:30:52.360 --> 01:30:56.360]  То же самое, если вы на afto навесили const или volatile,
[01:30:56.360 --> 01:30:58.360]  то это считается не универсальной ссылкой,
[01:30:58.360 --> 01:31:01.360]  а это считается правой ссылкой на const afto,
[01:31:01.360 --> 01:31:03.360]  на const того, что будет выведено.
[01:31:03.360 --> 01:31:07.360]  Кроме того, это более тонкий момент.
[01:31:07.420 --> 01:31:09.420]  Если я тут написал, вот у меня есть класс stack,
[01:31:09.420 --> 01:31:11.420]  и у него есть шаблонный параметр T.
[01:31:11.420 --> 01:31:14.420]  Если я написал push T2&value,
[01:31:14.420 --> 01:31:16.420]  несмотря на то, что я тут написал T2&value,
[01:31:16.420 --> 01:31:18.420]  это не универсальная ссылка.
[01:31:20.420 --> 01:31:22.420]  Почему?
[01:31:22.420 --> 01:31:26.420]  Потому что T это не шаблонный параметр функции push.
[01:31:26.420 --> 01:31:28.420]  T это шаблонный параметр класса stack.
[01:31:28.420 --> 01:31:30.420]  Понятно разница?
[01:31:30.420 --> 01:31:34.420]  То есть у вас T-шкой параметризован не push,
[01:31:34.420 --> 01:31:36.420]  а сам stack целиком.
[01:31:36.480 --> 01:31:40.480]  Если угодно, вот тут нет контекста вывода типа.
[01:31:40.480 --> 01:31:42.480]  То есть тут типа T не выводится.
[01:31:42.480 --> 01:31:44.480]  То есть тут T нельзя вывести.
[01:31:44.480 --> 01:31:46.480]  Когда вы создаете stack,
[01:31:46.480 --> 01:31:48.480]  вы уже создаете stack и подставляете явно нужный тип.
[01:31:52.480 --> 01:31:54.480]  А вот здесь у вас типа T
[01:31:54.480 --> 01:31:56.480]  является шаблонным параметром самого функции,
[01:31:56.480 --> 01:31:58.480]  поэтому все нормально.
[01:31:58.480 --> 01:32:00.480]  Ну и тут с afto понятно.
[01:32:00.480 --> 01:32:02.480]  А если вы написали бы метод push вот таким образом,
[01:32:02.480 --> 01:32:05.480]  то есть если вы написали шаблонный метод,
[01:32:05.540 --> 01:32:07.540]  то есть вы на сам push навесили бы класс u,
[01:32:07.540 --> 01:32:09.540]  то тогда бы это считалось универсальной ссылкой.
[01:32:09.540 --> 01:32:11.540]  Почему?
[01:32:11.540 --> 01:32:13.540]  Потому что u это шаблонный параметр самой функции push.
[01:32:15.540 --> 01:32:17.540]  Понятна разница между этим и этим?
[01:32:17.540 --> 01:32:19.540]  Между первым и вторым.
[01:32:19.540 --> 01:32:21.540]  T это шаблонный параметр всей структуры.
[01:32:21.540 --> 01:32:23.540]  Это не шаблонный параметр самой функции push.
[01:32:23.540 --> 01:32:25.540]  Поэтому это не универсальная ссылка.
[01:32:25.540 --> 01:32:27.540]  Во втором случае u к stack вообще никак не относится.
[01:32:27.540 --> 01:32:29.540]  u относится только к функции push.
[01:32:29.540 --> 01:32:31.540]  Поэтому u, двойной амперсант,
[01:32:31.540 --> 01:32:33.540]  это универсальная ссылка.
[01:32:33.600 --> 01:32:35.600]  С определениями понятно,
[01:32:35.600 --> 01:32:37.600]  что такое универсальная ссылка,
[01:32:37.600 --> 01:32:39.600]  а что такое не универсальная ссылка?
[01:32:39.600 --> 01:32:41.600]  А универсальная ссылка работает медленнее?
[01:32:41.600 --> 01:32:43.600]  В каком смысле медленнее?
[01:32:43.600 --> 01:32:45.600]  Почему нам мешает,
[01:32:45.600 --> 01:32:47.600]  когда всегда брали универсальную ссылку?
[01:32:47.600 --> 01:32:49.600]  Я покажу, что нам мешает.
[01:32:49.600 --> 01:32:51.600]  Дело в том, что универсальные ссылки,
[01:32:51.600 --> 01:32:53.600]  они очень агрессивные.
[01:32:53.600 --> 01:32:55.600]  Из-за того, что они универсальны,
[01:32:55.600 --> 01:32:57.600]  из названия в принципе следует,
[01:32:57.600 --> 01:32:59.600]  что они могут взять в себя все что угодно.
[01:32:59.600 --> 01:33:01.600]  Иногда нам этого не хочется,
[01:33:01.660 --> 01:33:03.660]  и я покажу, почему.
[01:33:03.660 --> 01:33:05.660]  Это первый момент.
[01:33:05.660 --> 01:33:07.660]  А второй момент,
[01:33:07.660 --> 01:33:09.660]  если вы каждый раз будете навешивать универсальную ссылку,
[01:33:09.660 --> 01:33:11.660]  то, да, это во-первых,
[01:33:11.660 --> 01:33:13.660]  увеличивает время компиляции,
[01:33:13.660 --> 01:33:15.660]  потому что мы знаем,
[01:33:15.660 --> 01:33:17.660]  что шаблонные функции инстанцируются лениво.
[01:33:17.660 --> 01:33:19.660]  То есть вам тогда на каждый чих,
[01:33:19.660 --> 01:33:21.660]  на каждый вызов функции,
[01:33:21.660 --> 01:33:23.660]  нужно создавать свою шаблонную функцию.
[01:33:23.660 --> 01:33:25.660]  Но этого мы не очень хотим.
[01:33:25.660 --> 01:33:27.660]  Тут есть некоторые проблемы,
[01:33:27.660 --> 01:33:29.660]  о которых мы в самом конце поговорим.
[01:33:29.720 --> 01:33:31.720]  А теперь они понятны, да?
[01:33:31.720 --> 01:33:33.720]  Хорошо.
[01:33:35.720 --> 01:33:37.720]  Теперь, наконец,
[01:33:37.720 --> 01:33:39.720]  про назначение универсальных ссылок.
[01:33:39.720 --> 01:33:41.720]  Как они работают? Почему они называются универсальными?
[01:33:41.720 --> 01:33:43.720]  Дело в том,
[01:33:43.720 --> 01:33:45.720]  что правила вывода для универсальных ссылок
[01:33:45.720 --> 01:33:47.720]  немного отличаются от правила вывода
[01:33:47.720 --> 01:33:49.720]  для остальных ссылок,
[01:33:49.720 --> 01:33:51.720]  про которые мы говорили на лекции по шаблонам.
[01:33:51.720 --> 01:33:53.720]  Первый пункт он сохраняется.
[01:33:53.720 --> 01:33:55.720]  Помните,
[01:33:55.720 --> 01:33:57.720]  если у меня в качестве параметра шаблонного
[01:33:57.780 --> 01:33:59.780]  стоит амперсант, то есть ссылка,
[01:33:59.780 --> 01:34:01.780]  то CV-квалификаторы они не отбрасываются.
[01:34:01.780 --> 01:34:03.780]  Это мы говорили об этом.
[01:34:03.780 --> 01:34:05.780]  А вот дальше начинаются
[01:34:05.780 --> 01:34:07.780]  интересные особенности.
[01:34:07.780 --> 01:34:09.780]  Если вы в качестве
[01:34:09.780 --> 01:34:11.780]  аргумента универсальной ссылки
[01:34:11.780 --> 01:34:13.780]  подсунете lvalue значение,
[01:34:15.780 --> 01:34:17.780]  то тип T
[01:34:17.780 --> 01:34:19.780]  выведется как lvalue ссылка.
[01:34:19.780 --> 01:34:21.780]  То есть если я в данную функцию
[01:34:21.780 --> 01:34:23.780]  function
[01:34:23.780 --> 01:34:25.780]  подставлю x,
[01:34:25.840 --> 01:34:27.840]  то тип T у меня будет иметь тип int амперсант.
[01:34:29.840 --> 01:34:31.840]  Давайте более такой пример.
[01:34:31.840 --> 01:34:33.840]  У меня есть const int x
[01:34:33.840 --> 01:34:35.840]  равно нулю.
[01:34:35.840 --> 01:34:37.840]  Я передал функцию function x.
[01:34:37.840 --> 01:34:39.840]  Тогда у меня в качестве типа T
[01:34:39.840 --> 01:34:41.840]  будет выведен
[01:34:41.840 --> 01:34:43.840]  const
[01:34:43.840 --> 01:34:45.840]  int амперсант.
[01:34:45.840 --> 01:34:47.840]  Почему const int амперсант?
[01:34:47.840 --> 01:34:49.840]  Почему const int понятно?
[01:34:49.840 --> 01:34:51.840]  Константность не отбрасывается.
[01:34:51.840 --> 01:34:53.840]  Почему ссылка?
[01:34:53.900 --> 01:34:55.900]  Я в качестве параметра функцию
[01:34:55.900 --> 01:34:57.900]  передал lvalue.
[01:34:57.900 --> 01:34:59.900]  Поэтому тип T у меня выводится
[01:34:59.900 --> 01:35:01.900]  как lvalue ссылка.
[01:35:01.900 --> 01:35:03.900]  lvalue ссылка на const int.
[01:35:03.900 --> 01:35:05.900]  И третье правило.
[01:35:05.900 --> 01:35:07.900]  Если в качестве аргумента я передаю
[01:35:07.900 --> 01:35:09.900]  rvalue, то есть все то, что не является lvalue,
[01:35:09.900 --> 01:35:11.900]  у меня тип T выводится по обычным правилам.
[01:35:11.900 --> 01:35:13.900]  Просто как обычный тип.
[01:35:13.900 --> 01:35:15.900]  Скажем, если я сюда function
[01:35:17.900 --> 01:35:19.900]  передам просто 0,
[01:35:19.900 --> 01:35:21.900]  то в качестве типа T
[01:35:21.900 --> 01:35:23.900]  у меня будет const int и все.
[01:35:27.900 --> 01:35:29.900]  И теперь смотрите,
[01:35:29.900 --> 01:35:31.900]  почему это называется универсальной ссылкой.
[01:35:31.900 --> 01:35:33.900]  По следующей причине.
[01:35:33.900 --> 01:35:35.900]  Тут все эти примеры написаны.
[01:35:35.900 --> 01:35:37.900]  Значит, есть const int cx.
[01:35:37.900 --> 01:35:39.900]  Я передаю функцию function cx.
[01:35:39.900 --> 01:35:41.900]  В качестве типа T у меня выводится
[01:35:41.900 --> 01:35:43.900]  const int амперсант.
[01:35:43.900 --> 01:35:45.900]  И тогда какой у меня будет тип у аргумента?
[01:35:45.900 --> 01:35:47.900]  Какой будет тип у арга?
[01:35:47.900 --> 01:35:49.900]  По правилу сворачивания ссылок.
[01:35:49.900 --> 01:35:51.900]  То есть у меня получается по сути тип у арга
[01:35:51.900 --> 01:35:55.900]  это const int амперсант,
[01:35:55.900 --> 01:35:57.900]  на который я навесил двойной амперсант.
[01:35:57.900 --> 01:35:59.900]  Но у меня работает правило сворачивания ссылок,
[01:35:59.900 --> 01:36:01.900]  при котором я двойную ссылку игнорирую.
[01:36:01.900 --> 01:36:03.900]  Поэтому общий тип у арга будет const int амперсант.
[01:36:05.900 --> 01:36:07.900]  То есть lvalue ссылка на константный int.
[01:36:07.900 --> 01:36:09.900]  А если я передам 0,
[01:36:09.900 --> 01:36:11.900]  то в качестве типа T у меня
[01:36:11.900 --> 01:36:13.900]  выводится int.
[01:36:13.900 --> 01:36:15.900]  А тип у арга будет T двойной амперсант.
[01:36:15.900 --> 01:36:17.900]  То есть int двойной амперсант.
[01:36:17.900 --> 01:36:19.900]  То есть что мы сделали?
[01:36:19.900 --> 01:36:21.900]  Что мы получили?
[01:36:21.900 --> 01:36:23.900]  Если я передаю функцию function lvalue объект,
[01:36:23.900 --> 01:36:25.900]  lvalue значения,
[01:36:25.900 --> 01:36:27.900]  то у меня тип аргумента, вот этого,
[01:36:27.900 --> 01:36:29.900]  arg, выводится как ссылка
[01:36:29.900 --> 01:36:31.900]  на то, что я передал.
[01:36:31.900 --> 01:36:33.900]  lvalue ссылка на то, что я передал.
[01:36:33.900 --> 01:36:35.900]  Если я передаю rvalue значения,
[01:36:35.900 --> 01:36:37.900]  то у меня тип arg выводится
[01:36:37.900 --> 01:36:39.900]  как rvalue ссылка на то, что я передал.
[01:36:39.900 --> 01:36:41.900]  И это, кажется,
[01:36:41.900 --> 01:36:43.900]  равно то, чего я хотел до этого.
[01:36:43.900 --> 01:36:45.900]  Я хотел, чтобы арг был либо левой ссылкой на левый объект,
[01:36:45.900 --> 01:36:47.900]  либо правой ссылкой на rvalue объект.
[01:36:49.900 --> 01:36:51.900]  И вот в этом смысл универсальности ссылок.
[01:36:51.900 --> 01:36:53.900]  Почему они универсальны?
[01:36:53.900 --> 01:36:55.900]  Потому что в зависимости от того, что вы туда передали,
[01:36:55.900 --> 01:36:57.900]  это либо lvalue ссылка, либо rvalue ссылка.
[01:36:57.900 --> 01:36:59.900]  Все ясно.
[01:36:59.900 --> 01:37:01.900]  Давайте по примерам пройдемся.
[01:37:03.900 --> 01:37:05.900]  Попробуем поиграть.
[01:37:05.900 --> 01:37:07.900]  Вот у меня есть функция function
[01:37:07.900 --> 01:37:09.900]  с универсальной ссылкой.
[01:37:09.900 --> 01:37:11.900]  У меня есть x, обычный int.
[01:37:11.900 --> 01:37:13.900]  У меня есть cx, константный int.
[01:37:13.900 --> 01:37:15.900]  У меня есть ссылка на int
[01:37:15.900 --> 01:37:17.900]  и есть константная правая ссылка на int.
[01:37:17.900 --> 01:37:19.900]  Если я вызываю function от x,
[01:37:19.900 --> 01:37:21.900]  то что у меня выводится в качестве t?
[01:37:21.900 --> 01:37:23.900]  То есть тут два вопроса.
[01:37:23.900 --> 01:37:25.900]  Что у меня выводится в качестве t?
[01:37:25.900 --> 01:37:27.900]  И какой тип имеет аргумент arg?
[01:37:27.900 --> 01:37:29.900]  Какой тип у меня выводится?
[01:37:29.900 --> 01:37:31.900]  Что подставляется в качестве t?
[01:37:33.900 --> 01:37:35.900]  int&
[01:37:35.900 --> 01:37:37.900]  По какому правилу?
[01:37:37.900 --> 01:37:39.900]  По правилу 2.
[01:37:39.900 --> 01:37:41.900]  Если я функцию передаю lvalue объект,
[01:37:41.900 --> 01:37:43.900]  у меня тип t выводится как lvalue ссылка
[01:37:43.900 --> 01:37:45.900]  на то, что я передал, то есть int&
[01:37:45.900 --> 01:37:47.900]  А тип аргумента какой?
[01:37:47.900 --> 01:37:49.900]  int&
[01:37:49.900 --> 01:37:51.900]  Это универсальная ссылка.
[01:37:51.900 --> 01:37:53.900]  Тут можно не обращаться к сворачиванию ссылок.
[01:37:53.900 --> 01:37:55.900]  Тут можно сразу сказать,
[01:37:55.900 --> 01:37:57.900]  что это та ссылка, которая нужна.
[01:37:57.900 --> 01:37:59.900]  Вот ответ короткий.
[01:37:59.900 --> 01:38:01.900]  Потому что это универсальная ссылка.
[01:38:01.900 --> 01:38:03.900]  Если я передаю cx,
[01:38:03.900 --> 01:38:05.900]  ну, cx обсуждали.
[01:38:05.900 --> 01:38:07.900]  Тут тип const int&
[01:38:07.900 --> 01:38:09.900]  Ну и тип тоже const int&
[01:38:09.900 --> 01:38:11.900]  Теперь я передаю rx.
[01:38:17.900 --> 01:38:19.900]  То есть t это int.
[01:38:35.900 --> 01:38:37.900]  У вас есть время подумать.
[01:38:37.900 --> 01:38:39.900]  Ну ладно.
[01:38:39.900 --> 01:38:41.900]  Ладно, нет у вас времени больше.
[01:38:47.900 --> 01:38:49.900]  Намек понятен?
[01:38:49.900 --> 01:38:51.900]  Переменная это всегда lvalue.
[01:38:51.900 --> 01:38:53.900]  Если вот за эти две лекции
[01:38:53.900 --> 01:38:55.900]  нужно было что-то запомнить,
[01:38:55.900 --> 01:38:57.900]  вот это одно, это вот.
[01:38:57.900 --> 01:38:59.900]  Переменная это всегда lvalue.
[01:38:59.900 --> 01:39:01.900]  Всегда, нет исключений.
[01:39:03.900 --> 01:39:05.900]  Неважно, кого типа эта переменная.
[01:39:05.900 --> 01:39:07.900]  Ссылка, правая ссылка,
[01:39:07.900 --> 01:39:09.900]  константа, неконстанта.
[01:39:09.900 --> 01:39:11.900]  Все, переменная это всегда lvalue. Почему?
[01:39:11.900 --> 01:39:13.900]  Потому что за каждой переменной всегда лежит некоторая область памяти.
[01:39:13.900 --> 01:39:15.900]  Даже по определению.
[01:39:15.900 --> 01:39:17.900]  Переменная это именовная область памяти.
[01:39:17.900 --> 01:39:19.900]  А мы говорили, что если у чего-то есть
[01:39:19.900 --> 01:39:21.900]  какая-то область памяти,
[01:39:21.900 --> 01:39:23.900]  то это lvalue.
[01:39:23.900 --> 01:39:25.900]  Поэтому тут
[01:39:25.900 --> 01:39:27.900]  какой тип у t?
[01:39:27.900 --> 01:39:29.900]  У t int&
[01:39:29.900 --> 01:39:31.900]  Потому что это lvalue.
[01:39:31.900 --> 01:39:33.900]  Ну и ссылка, понятное дело, левая.
[01:39:35.900 --> 01:39:37.900]  Итак, crx.
[01:39:37.900 --> 01:39:39.900]  crx это
[01:39:39.900 --> 01:39:41.900]  lvalue, ссылка на constant.
[01:39:41.900 --> 01:39:43.900]  Что у меня вводится в качестве t?
[01:39:43.900 --> 01:39:45.900]  constant int&
[01:39:45.900 --> 01:39:47.900]  Почему?
[01:39:47.900 --> 01:39:49.900]  Потому что crx это lvalue.
[01:39:49.900 --> 01:39:51.900]  И это ссылка на
[01:39:51.900 --> 01:39:53.900]  и она из себя представляет
[01:39:53.900 --> 01:39:55.900]  константный объект.
[01:39:55.900 --> 01:39:57.900]  Поэтому тут вводится constant int&
[01:39:57.900 --> 01:39:59.900]  Ну и тип аргумента
[01:39:59.900 --> 01:40:01.900]  это тоже
[01:40:01.900 --> 01:40:03.900]  const int&
[01:40:03.900 --> 01:40:05.900]  Отлично.
[01:40:05.900 --> 01:40:07.900]  Вызываю function от нуля.
[01:40:07.900 --> 01:40:09.900]  Давайте еще раз.
[01:40:09.900 --> 01:40:11.900]  Если я вызываю function от нуля, то в качестве t выводится у меня int.
[01:40:11.900 --> 01:40:13.900]  Потому что 0 это rvalue.
[01:40:13.900 --> 01:40:15.900]  Да, ну и тип аргумента.
[01:40:17.900 --> 01:40:19.900]  Да, int двойной &.
[01:40:19.900 --> 01:40:21.900]  То есть rvalue ссылка на то, что мне передали.
[01:40:21.900 --> 01:40:23.900]  Так, теперь.
[01:40:23.900 --> 01:40:25.900]  Function от stdmove от x.
[01:40:25.900 --> 01:40:27.900]  Инт или int&?
[01:40:27.900 --> 01:40:29.900]  Инт или int&?
[01:40:29.900 --> 01:40:31.900]  Инт или int&?
[01:40:31.900 --> 01:40:33.900]  Инт или int&?
[01:40:33.900 --> 01:40:35.900]  Инт или int&?
[01:40:35.900 --> 01:40:37.900]  А кто считает, что int&?
[01:40:37.900 --> 01:40:39.900]  Поясните, почему int&?
[01:40:39.900 --> 01:40:41.900]  Ну
[01:40:41.900 --> 01:40:43.900]  у нас будет
[01:40:43.900 --> 01:40:45.900]  писаваться
[01:40:45.900 --> 01:40:47.900]  все равно переменные.
[01:40:47.900 --> 01:40:49.900]  Но просто rvalue переменные.
[01:40:49.900 --> 01:40:51.900]  Перменные
[01:40:51.900 --> 01:40:53.900]  это переменные, но
[01:40:53.900 --> 01:40:55.900]  у stdmove какое?
[01:40:55.900 --> 01:40:57.900]  У stdmove
[01:40:57.900 --> 01:40:59.900]  как раз ровное это и назначение.
[01:40:59.900 --> 01:41:01.900]  Притвориться rvalue.
[01:41:01.900 --> 01:41:03.900]  То есть x это lvalue, да.
[01:41:03.900 --> 01:41:05.900]  Но stdmove говорит, что то, что стоит в скобках,
[01:41:05.900 --> 01:41:07.900]  должно притвориться rvalue.
[01:41:07.900 --> 01:41:09.900]  Поэтому да, действительно, функцию мы на самом деле передаем rvalue.
[01:41:09.900 --> 01:41:11.900]  Ну точнее, мы передаем не rvalue,
[01:41:11.900 --> 01:41:13.900]  но мы передаем назначение, которое притворяется rvalue.
[01:41:13.900 --> 01:41:15.900]  У нас даже название было для этого xvalue.
[01:41:15.900 --> 01:41:17.900]  xvalue это часть rvalue.
[01:41:17.900 --> 01:41:19.900]  OK.
[01:41:19.900 --> 01:41:21.900]  То есть это rvalue.
[01:41:21.900 --> 01:41:23.900]  Выводится тип int.
[01:41:23.900 --> 01:41:25.900]  Ну и соответственно,
[01:41:25.900 --> 01:41:27.900]  тип аргумента
[01:41:27.900 --> 01:41:29.900]  int%
[01:41:29.900 --> 01:41:31.900]  Я делаю stdmove от cx.
[01:41:31.900 --> 01:41:33.900]  cx я напомню,
[01:41:33.900 --> 01:41:35.900]  это константная ссылка.
[01:41:35.900 --> 01:41:37.900]  Что у меня вводится в качестве t?
[01:41:37.900 --> 01:41:39.900]  const int
[01:41:39.900 --> 01:41:41.900]  Ну и в качестве типа ссылки
[01:41:41.900 --> 01:41:43.900]  у меня вводится const int 0%.
[01:41:43.900 --> 01:41:45.900]  Ну почему? Тоже понятно.
[01:41:45.900 --> 01:41:47.900]  Что такое cx?
[01:41:47.900 --> 01:41:49.900]  cx представляет себе lvalue,
[01:41:49.900 --> 01:41:51.900]  по которому лежит константный объект.
[01:41:51.900 --> 01:41:53.900]  Когда я делаю stdmove от cx,
[01:41:53.900 --> 01:41:55.900]  у меня в качестве результата возвращается
[01:41:55.900 --> 01:41:57.900]  как бы rvalue на константу.
[01:41:57.900 --> 01:41:59.900]  Поэтому константность сохраняется.
[01:41:59.900 --> 01:42:01.900]  То есть у меня есть константный объект,
[01:42:01.900 --> 01:42:03.900]  и у меня есть константный объект,
[01:42:03.900 --> 01:42:05.900]  и у меня есть константный объект,
[01:42:05.900 --> 01:42:07.900]  и у меня есть константный объект,
[01:42:07.900 --> 01:42:09.900]  поэтому константность сохраняется,
[01:42:09.900 --> 01:42:11.900]  у меня передается const int,
[01:42:11.900 --> 01:42:13.900]  то есть t вводится как const int,
[01:42:13.900 --> 01:42:15.900]  потому что константность не игнорируется,
[01:42:15.900 --> 01:42:17.900]  и плюс, так как я передаю rvalue,
[01:42:17.900 --> 01:42:19.900]  ну как бы rvalue,
[01:42:19.900 --> 01:42:21.900]  то есть stdmove говорит перетворить rvalue,
[01:42:21.900 --> 01:42:23.900]  у меня вводится тип t без ссылки.
[01:42:23.900 --> 01:42:25.900]  Ну и суммарно идти, у меня получается
[01:42:25.900 --> 01:42:27.900]  просто const int 0%.
[01:42:27.900 --> 01:42:29.900]  Ну и последние три примера,
[01:42:29.900 --> 01:42:31.900]  что если я прям явно указываю,
[01:42:31.900 --> 01:42:33.900]  что мне делать,
[01:42:33.900 --> 01:42:35.900]  то есть если я пишу function int% x,
[01:42:35.900 --> 01:42:37.900]  то я делаю тут везде,
[01:42:37.900 --> 01:42:39.900]  t равно int% в первом случае,
[01:42:39.900 --> 01:42:41.900]  t равно int% в втором случае,
[01:42:41.900 --> 01:42:43.900]  и t равно просто int в последнем случае.
[01:42:43.900 --> 01:42:45.900]  А какие типы аргументов?
[01:42:45.900 --> 01:42:47.900]  Давайте в первом случае.
[01:42:49.900 --> 01:42:51.900]  Да, тип аргумента просто int%
[01:42:51.900 --> 01:42:53.900]  по правилу сворачивания ссылок.
[01:42:53.900 --> 01:42:55.900]  int% или int% просто обычная ссылка,
[01:42:55.900 --> 01:42:57.900]  давайте одну нарисуем.
[01:42:57.900 --> 01:42:59.900]  int%
[01:42:59.900 --> 01:43:01.900]  да, превратится в int%,
[01:43:01.900 --> 01:43:03.900]  потому что я двойную ссылку навешиваю на двойную ссылку.
[01:43:03.900 --> 01:43:05.900]  Если я пишу просто int,
[01:43:05.900 --> 01:43:07.900]  то есть на просто int навешивается
[01:43:07.900 --> 01:43:09.900]  двойная ссылка, все нормально.
[01:43:09.900 --> 01:43:11.900]  Все, окей?
[01:43:11.900 --> 01:43:13.900]  Понятно?
[01:43:13.900 --> 01:43:15.900]  Ну вот.
[01:43:19.900 --> 01:43:21.900]  Ну и теперь понятно,
[01:43:21.900 --> 01:43:23.900]  к чему я все клонил,
[01:43:23.900 --> 01:43:25.900]  и теперь понятно, что нужно принимать вот здесь.
[01:43:27.900 --> 01:43:29.900]  Да, понятно.
[01:43:29.900 --> 01:43:31.900]  Я принимаю
[01:43:31.900 --> 01:43:33.900]  арг-двойной амперсант,
[01:43:33.900 --> 01:43:35.900]  и теперь почти все ок.
[01:43:37.900 --> 01:43:39.900]  Вот как раз первую половину, кажется, мы потратили
[01:43:39.900 --> 01:43:41.900]  на решение части проблемы.
[01:43:41.900 --> 01:43:43.900]  Да, если я передаю
[01:43:43.900 --> 01:43:45.900]  универсальную ссылку, то что у меня получается?
[01:43:45.900 --> 01:43:47.900]  Если я внутрь функцион
[01:43:47.900 --> 01:43:49.900]  передаю ноль,
[01:43:49.900 --> 01:43:51.900]  то у меня тип арг
[01:43:51.900 --> 01:43:53.900]  это int-двойной амперсант,
[01:43:53.900 --> 01:43:55.900]  то есть просто ссылка на этот ноль.
[01:43:55.900 --> 01:43:57.900]  И я спокойно вычисляю раингтами от функцион 0.
[01:43:57.900 --> 01:43:59.900]  То есть ноль передается по правой ссылке,
[01:43:59.900 --> 01:44:01.900]  и вызывается обычный функцион, который работает с синтомом.
[01:44:01.900 --> 01:44:03.900]  Все нормально.
[01:44:03.900 --> 01:44:05.900]  Все корректно работает.
[01:44:05.900 --> 01:44:07.900]  Если я же передаю x,
[01:44:07.900 --> 01:44:09.900]  то вот тоже все хорошо,
[01:44:09.900 --> 01:44:11.900]  потому что раингтайм функцион x принимает
[01:44:11.900 --> 01:44:13.900]  x по ссылке,
[01:44:13.900 --> 01:44:15.900]  то есть внутри арга у меня создается ссылка на x,
[01:44:15.900 --> 01:44:17.900]  и внутри вот этой функции
[01:44:17.900 --> 01:44:19.900]  раингтайм я работаю с исходным x.
[01:44:19.900 --> 01:44:21.900]  Да?
[01:44:21.900 --> 01:44:23.900]  Поэтому я когда внутри функцион передаю,
[01:44:23.900 --> 01:44:25.900]  ну вот тут внутри, там блабла,
[01:44:25.900 --> 01:44:27.900]  у меня там есть
[01:44:27.900 --> 01:44:29.900]  вызов функ от арг.
[01:44:31.900 --> 01:44:33.900]  Вот этот арг
[01:44:33.900 --> 01:44:35.900]  на самом деле является ссылкой на x,
[01:44:35.900 --> 01:44:37.900]  когда я вызываю ее вот так.
[01:44:37.900 --> 01:44:39.900]  Поэтому внутри раингтайм
[01:44:39.900 --> 01:44:41.900]  я работаю с исходным x,
[01:44:41.900 --> 01:44:43.900]  и если какие-то изменения у меня затрагивают x,
[01:44:43.900 --> 01:44:45.900]  то эти изменения я увижу и во внешнем коде,
[01:44:45.900 --> 01:44:47.900]  то есть ровно то, чего я хотел.
[01:44:47.900 --> 01:44:49.900]  Понятно?
[01:44:49.900 --> 01:44:51.900]  То есть я написал одну функцию,
[01:44:51.900 --> 01:44:53.900]  которая умеет подстраиваться
[01:44:53.900 --> 01:44:55.900]  под нужные виды value.
[01:44:55.900 --> 01:44:57.900]  Если я передал lvalue, то это lvalue ссылка.
[01:44:57.900 --> 01:44:59.900]  И не нужно никого дублирования кода.
[01:44:59.900 --> 01:45:01.900]  Универсальная ссылка, она примет в себя
[01:45:01.900 --> 01:45:03.900]  все, что нужно.
[01:45:03.900 --> 01:45:05.900]  Про вторую часть проблемы
[01:45:05.900 --> 01:45:07.900]  поговорим после перерыва.
[01:45:07.900 --> 01:45:09.900]  Овечная новая проблема.
[01:45:09.900 --> 01:45:11.900]  Вот она.
[01:45:13.900 --> 01:45:15.900]  Вспомним, как мы реализовывали
[01:45:15.900 --> 01:45:17.900]  функцию раингтайм,
[01:45:17.900 --> 01:45:19.900]  ну и добавив в нее универсальную ссылку.
[01:45:19.900 --> 01:45:21.900]  Вот у меня функция
[01:45:21.900 --> 01:45:23.900]  раингтайм,
[01:45:23.900 --> 01:45:25.900]  я принимаю ARK по универсальной ссылке,
[01:45:25.900 --> 01:45:27.900]  то есть теперь
[01:45:27.900 --> 01:45:29.900]  если я передаю lvalue,
[01:45:29.900 --> 01:45:39.900]  то я на самом деле принимаю lvalue
[01:45:39.900 --> 01:45:41.900]  на исходный объект,
[01:45:41.900 --> 01:45:43.900]  то есть я как бы внутри этой функции
[01:45:43.900 --> 01:45:45.900]  я работаю именно с тем объектом,
[01:45:45.900 --> 01:45:47.900]  который мне передали в эту функцию.
[01:45:47.900 --> 01:45:49.900]  Ну и дальше я вызываю функт от ARK,
[01:45:49.900 --> 01:45:51.900]  и здесь уже можно
[01:45:53.900 --> 01:46:00.900]  Уже можно вот в этот момент понять, что что-то все-таки пойдет не так, что-то может пойти не так.
[01:46:00.900 --> 01:46:03.900]  Давайте на конкретном примере. Смотрите.
[01:46:03.900 --> 01:46:12.900]  У меня есть function l. function l говорит о том, что эта функция у меня принимает int по l-value ссылки.
[01:46:12.900 --> 01:46:16.900]  Все нормально. Если я function l передаю x, то это работает.
[01:46:16.900 --> 01:46:20.900]  Если я передаю ранний time function l от x, то это тоже работает и при этом работает корректно.
[01:46:20.900 --> 01:46:23.900]  Мы это гарантировали с помощью универсальной ссылки.
[01:46:23.900 --> 01:46:28.900]  Вот какой момент. Смотрите. Function l от 0 я, естественно, вызвать не могу.
[01:46:28.900 --> 01:46:35.900]  Ну понятно почему. 0 не имеет права связываться с временными объектами, коим является 0.
[01:46:35.900 --> 01:46:37.900]  Поэтому тут ошибка амбиляции.
[01:46:37.900 --> 01:46:44.900]  Но внезапно, если я вызову ранний time от function l и 0, у меня все заработает.
[01:46:44.900 --> 01:46:49.900]  То есть я как будто бы смог вызвать function l от 0.
[01:46:49.900 --> 01:46:53.900]  Как так получилось? Самое главное, почему получилось?
[01:46:53.900 --> 01:46:58.900]  Да, отлично. Потому что 0 стало переменной.
[01:46:58.900 --> 01:47:01.900]  Потому что, смотрите какая картина.
[01:47:01.900 --> 01:47:07.900]  Я в ARC могу передавать как l-value, так и r-value.
[01:47:07.900 --> 01:47:12.900]  Точнее, в саму функцию ранних time.
[01:47:12.900 --> 01:47:17.900]  Но на выходе, после того как я это сохранил в ARC, в чем у меня стал ARC?
[01:47:17.900 --> 01:47:21.900]  L-value, то есть переменной или l-value.
[01:47:21.900 --> 01:47:32.900]  Понятно? И когда я вызываю func от ARC, я функцию func всегда вызываю от l-value.
[01:47:32.900 --> 01:47:36.900]  Всегда. Понятно?
[01:47:36.900 --> 01:47:41.900]  Даже несмотря на то, что я в ARC сохранил ссылку на l-value или r-value,
[01:47:41.900 --> 01:47:43.900]  сам ARC является l-value.
[01:47:43.900 --> 01:47:50.900]  Поэтому когда я его передаю в функцию func, вот здесь, я передаю всегда l-value.
[01:47:50.900 --> 01:47:54.900]  Даже если изначально у меня объект был r-value.
[01:47:54.900 --> 01:47:58.900]  Беда.
[01:47:58.900 --> 01:48:01.900]  Еще более тяжелая проблема.
[01:48:01.900 --> 01:48:04.900]  Еще более тяжелая проблема начинается тогда, когда я создаю функцию,
[01:48:04.900 --> 01:48:07.900]  которая принимает на самом деле r-value ссылку.
[01:48:07.900 --> 01:48:09.900]  Смотрите, в чем прикол.
[01:48:09.900 --> 01:48:14.900]  Я создаю функцию function r, которая принимает in двойной персант.
[01:48:14.900 --> 01:48:17.900]  Если я вызываю function r от x, то ошибка эмпиляции.
[01:48:17.900 --> 01:48:22.900]  Оно и понятно. Function r говорит о том, что я могу принимать только r-value объекта.
[01:48:22.900 --> 01:48:25.900]  Если вызываю running time от function r и x, то тоже ошибка эмпиляции.
[01:48:25.900 --> 01:48:27.900]  Тоже все нормально.
[01:48:27.900 --> 01:48:32.900]  Потому что ARC это l-value, я не могу function r передать l-value.
[01:48:32.900 --> 01:48:36.900]  Но есть существенная беда. Я могу вызвать function r от 0.
[01:48:36.900 --> 01:48:40.900]  Могу? Могу. То есть in двойная ссылка связывается с 0.
[01:48:40.900 --> 01:48:45.900]  Но когда я вызываю running time от function r и 0, я не могу так сделать.
[01:48:45.900 --> 01:48:51.900]  Ошибка эмпиляции. Почему? Потому что 0 сохраняется в ARC.
[01:48:51.900 --> 01:48:54.900]  И дальше этот ARC передается func от ARC.
[01:48:54.900 --> 01:48:59.900]  А func у меня имеет право принимать только r-value ссылки.
[01:48:59.900 --> 01:49:01.900]  Понятно?
[01:49:01.900 --> 01:49:07.900]  ARC сам по себе является либо l-value ссылкой, либо r-value ссылкой.
[01:49:07.900 --> 01:49:10.900]  Его тип является либо l-value ссылкой, либо r-value ссылкой.
[01:49:10.900 --> 01:49:14.900]  Но сам ARC как объект является l-value.
[01:49:14.900 --> 01:49:19.900]  Поэтому вот сюда, вот внутри func, я никогда не передаю r-value на самом деле.
[01:49:19.900 --> 01:49:22.900]  И это проблема. Понятно?
[01:49:22.900 --> 01:49:28.900]  Понятно, что у нас получилось? Какой кошмар мы устроили.
[01:49:28.900 --> 01:49:32.900]  Ну вот, собственно, здесь это все показано.
[01:49:32.900 --> 01:49:35.900]  Ну, в общем, суммаризация, что какие-то проблемы.
[01:49:35.900 --> 01:49:38.900]  То есть наблюдается некоторая асимметричность.
[01:49:38.900 --> 01:49:42.900]  Все-таки, наверное, хотелось бы, что во всех тех случаях, когда я могу вызвать функцию function,
[01:49:42.900 --> 01:49:45.900]  она вызывалась. Во всех тех случаях, когда я не могу вызвать функцию function,
[01:49:45.900 --> 01:49:48.900]  она не вызывалась. То есть создавалась ошибка эмпиляции.
[01:49:48.900 --> 01:49:53.900]  Здесь у меня не так. Здесь в первом случае у меня на самом деле ce, а по факту ok.
[01:49:53.900 --> 01:49:57.900]  Во втором случае у меня на самом деле ok, а по факту ce.
[01:49:57.900 --> 01:50:00.900]  То есть running time работает, опять же, не так, как я хотел.
[01:50:00.900 --> 01:50:05.900]  Я бы хотел, чтобы running time в принципе меня не замечался в программе.
[01:50:05.900 --> 01:50:08.900]  То есть running time просто некоторая обертка, которая просто берет function,
[01:50:08.900 --> 01:50:12.900]  которая берет аргумент и просто один аргумент передает другой, и все.
[01:50:12.900 --> 01:50:15.900]  Беда.
[01:50:15.900 --> 01:50:17.900]  Как решать эту проблему?
[01:50:17.900 --> 01:50:20.900]  Давайте так, вот на таком чисто бытовом уровне.
[01:50:20.900 --> 01:50:22.900]  Как решить эту проблему?
[01:50:22.900 --> 01:50:24.900]  Вот как решить проблему с r-value?
[01:50:24.900 --> 01:50:29.900]  Мы уже сказали, что вот здесь, внутрь функции func, я всегда передаю l-value.
[01:50:29.900 --> 01:50:33.900]  Но иногда я бы хотел передавать r-value. Как мне передавать r-value?
[01:50:33.900 --> 01:50:36.900]  Как мне из arg сделать r-value?
[01:50:36.900 --> 01:50:38.900]  std move, отлично.
[01:50:38.900 --> 01:50:41.900]  Следующая вещь. Хотелось бы иногда вызывать func от arg,
[01:50:41.900 --> 01:50:46.900]  а хотелось бы иногда вызывать func от std move от arg.
[01:50:46.900 --> 01:50:49.900]  std move от arg.
[01:50:49.900 --> 01:50:51.900]  Понятно?
[01:50:51.900 --> 01:50:53.900]  То есть в зависимости от того, что мне на самом деле передали,
[01:50:53.900 --> 01:50:58.900]  я хочу еще на самом деле вызывать либо func от arg, либо func от std move от arg.
[01:50:58.900 --> 01:51:01.900]  Дело в том, что внутри running time, arg всегда l-value.
[01:51:01.900 --> 01:51:03.900]  Да, это правда.
[01:51:03.900 --> 01:51:05.900]  Идея решения такая.
[01:51:05.900 --> 01:51:08.900]  Если я в аргумент arg на самом деле передал l-value,
[01:51:08.900 --> 01:51:11.900]  то нужно вызывать func от arg.
[01:51:11.900 --> 01:51:12.900]  Все нормально.
[01:51:12.900 --> 01:51:15.900]  Потому что я функцию передавал l-value, значит я хотел вызвать функцию function
[01:51:15.900 --> 01:51:18.900]  от l-value, и поэтому нужно вызывать func от arg.
[01:51:18.900 --> 01:51:20.900]  Потому что arg это само по себе l-value.
[01:51:20.900 --> 01:51:22.900]  Если я в арг передал l-value,
[01:51:22.900 --> 01:51:27.900]  то это означает, что я хотел бы, чтобы у меня функцию func пришло l-value.
[01:51:27.900 --> 01:51:33.900]  И чтобы так случилось, мне нужно вызвать func от std move от arg.
[01:51:33.900 --> 01:51:36.900]  То есть код должен выглядеть примерно как-то так.
[01:51:36.900 --> 01:51:41.900]  Если в арг передали l-value, это не синтаксис, это вот я так написал,
[01:51:41.900 --> 01:51:45.900]  если в арг передали l-value, то нужно вызвать f от arg.
[01:51:45.900 --> 01:51:48.900]  А иначе нужно вызвать std move от arg.
[01:51:48.900 --> 01:51:51.900]  Ну это вот то, чего мы хотим. Согласны?
[01:51:53.900 --> 01:51:55.900]  Теперь еще один вопрос вам.
[01:51:55.900 --> 01:51:59.900]  А можем ли мы как-то внутри функции func,
[01:51:59.900 --> 01:52:03.900]  ну вот вообще в принципе вот по аргументам, по типам,
[01:52:03.900 --> 01:52:06.900]  можем ли как-то понять, а что передали в арг?
[01:52:06.900 --> 01:52:08.900]  То есть грубо говоря, вот у меня есть некоторые условия.
[01:52:08.900 --> 01:52:10.900]  В арг передали l-value.
[01:52:10.900 --> 01:52:14.900]  Могу ли я как-то понять, что мне передали в арг?
[01:52:14.900 --> 01:52:16.900]  l-value или r-value?
[01:52:18.900 --> 01:52:20.900]  Ну идея. Как бы я мог это понять?
[01:52:20.900 --> 01:52:22.900]  Внутри функции у меня есть арг на руках.
[01:52:22.900 --> 01:52:25.900]  Вот я вижу арг. Ну арг, хорошо.
[01:52:25.900 --> 01:52:29.900]  Я же не знаю, на что на самом деле он ссылается.
[01:52:29.900 --> 01:52:31.900]  Точнее, я же не...
[01:52:31.900 --> 01:52:33.900]  Я знаю, что арг это l-value.
[01:52:33.900 --> 01:52:36.900]  Но что туда передали?
[01:52:36.900 --> 01:52:39.900]  Изначально l-value объект или l-value объект?
[01:52:39.900 --> 01:52:41.900]  Что?
[01:52:41.900 --> 01:52:44.900]  На арг.
[01:52:44.900 --> 01:52:47.900]  Отлично. Прекрасно, гениально.
[01:52:47.900 --> 01:52:50.900]  Нужно посмотреть на арг.
[01:52:50.900 --> 01:52:52.900]  Всем понятно, почему на арг?
[01:52:52.900 --> 01:53:00.900]  Чем является арг, если я передал l-value или передал r-value?
[01:53:00.900 --> 01:53:05.900]  Чем является арг?
[01:53:05.900 --> 01:53:07.900]  Да, в первом случае он является типом сосылка,
[01:53:07.900 --> 01:53:09.900]  во втором случае он является просто типом без ссылки.
[01:53:09.900 --> 01:53:12.900]  Но это только работа у универсальной ссылки.
[01:53:12.900 --> 01:53:15.900]  Давайте напомним.
[01:53:15.900 --> 01:53:19.900]  Универсальные ссылки при передаче l-value тип T
[01:53:19.900 --> 01:53:21.900]  вводится как l-value ссылка. При передаче r-value тип
[01:53:21.900 --> 01:53:24.900]  вводится как несылочный.
[01:53:24.900 --> 01:53:29.900]  То есть на самом деле вот этот if в арг передали l-value.
[01:53:29.900 --> 01:53:31.900]  То есть я могу принять решение на основании того,
[01:53:31.900 --> 01:53:34.900]  чем является арг. Если арг является ссылкой,
[01:53:34.900 --> 01:53:37.900]  то я не делаю std move.
[01:53:37.900 --> 01:53:39.900]  Если арг является несылкой, то это значит,
[01:53:39.900 --> 01:53:41.900]  что мне в аргумент изначально передавали r-value,
[01:53:41.900 --> 01:53:44.900]  а я должен сделать std move.
[01:53:44.900 --> 01:53:48.900]  Понятно?
[01:53:48.900 --> 01:53:50.900]  Ну и собственно ответ. Универсальные ссылки
[01:53:50.900 --> 01:53:54.900]  действительно по-разному вводят шаплонный аргумент arc.
[01:53:54.900 --> 01:53:56.900]  Шаплонный параметр arc.
[01:53:56.900 --> 01:53:58.900]  То есть он либо ссылочный, либо несылочный.
[01:53:58.900 --> 01:54:01.900]  И вот на этом основании я могу принять решение,
[01:54:01.900 --> 01:54:04.900]  что мне вызывать.
[01:54:04.900 --> 01:54:07.900]  Ну и наконец волшебная функция std forward.
[01:54:07.900 --> 01:54:10.900]  Вот эта сама std forward функция,
[01:54:10.900 --> 01:54:13.900]  она делает все за вас.
[01:54:13.900 --> 01:54:17.900]  Значит, std forward – это такая специальная функция,
[01:54:17.900 --> 01:54:20.900]  которая выполняет условный move.
[01:54:20.900 --> 01:54:23.900]  То есть std move – это std move и все.
[01:54:23.900 --> 01:54:25.900]  То есть притворить r-value ссылкой.
[01:54:25.900 --> 01:54:30.900]  А std forward говорит о том,
[01:54:30.900 --> 01:54:33.900]  что std forward делает std move,
[01:54:33.900 --> 01:54:39.900]  если реально объект связан с r-value значением
[01:54:39.900 --> 01:54:42.900]  и не делает std move, если реально там
[01:54:42.900 --> 01:54:45.900]  этот объект связан наоборот с l-value.
[01:54:45.900 --> 01:54:48.900]  Понятно, да?
[01:54:48.900 --> 01:54:53.900]  То есть std forward как раз таки выполняет вот этот вот условный move.
[01:54:53.900 --> 01:54:57.900]  То есть внутри std forward грубо говоря написано что-то наподобие такого.
[01:54:57.900 --> 01:55:00.900]  То есть он смотрит на тип арга,
[01:55:01.900 --> 01:55:04.900]  и дальше делает std move от ARC или не std move от ARC,
[01:55:04.900 --> 01:55:08.900]  в зависимости от того, является ли ARC l-value ссылкой или нет.
[01:55:08.900 --> 01:55:12.900]  Да, ну здесь вот написано, что std forward от ARC.
[01:55:12.900 --> 01:55:14.900]  Вот заметьте, что std forward,
[01:55:14.900 --> 01:55:16.900]  дополнительно чтобы он понимал,
[01:55:16.900 --> 01:55:19.900]  нужно ли ему делать или не нужно делать std move,
[01:55:19.900 --> 01:55:23.900]  ему нужно дополнительно в треугольных скопках всегда передавать ARC.
[01:55:23.900 --> 01:55:26.900]  Вот в этом отличие от std move.
[01:55:26.900 --> 01:55:29.900]  Дело в том, что std move мы ничего не передаем в треугольных скопках.
[01:55:29.900 --> 01:55:32.900]  std move мы говорим просто в круглые скопки и дальше прокинь дальше.
[01:55:32.900 --> 01:55:34.900]  Все.
[01:55:34.900 --> 01:55:36.900]  То есть std move всегда делает l-value ссылку.
[01:55:36.900 --> 01:55:39.900]  А std forward, ну чтобы понять, что делать с ARC,
[01:55:39.900 --> 01:55:41.900]  ему нужно дополнительно передать в треугольных скопках, собственно,
[01:55:41.900 --> 01:55:45.900]  о чем этот ARC является, l-value ссылкой или не l-value ссылкой.
[01:55:45.900 --> 01:55:47.900]  Ну и дальше он делает следующую вещь.
[01:55:47.900 --> 01:55:49.900]  Ну понятно дело, что это не код на C++,
[01:55:49.900 --> 01:55:51.900]  то есть там проверка выглядит чуть более сложная,
[01:55:51.900 --> 01:55:54.900]  но в целом идея такая, он проверяет,
[01:55:54.900 --> 01:55:58.900]  если ARC это левая ссылка, то возвращается просто ARC.
[01:55:58.900 --> 01:56:00.900]  Тут, наверное, надо написать return.
[01:56:00.900 --> 01:56:02.900]  Return ARC.
[01:56:02.900 --> 01:56:06.900]  Иначе return std move от ARC.
[01:56:12.900 --> 01:56:14.900]  Ну и теперь вот этот код,
[01:56:14.900 --> 01:56:16.900]  который мы пытались написать с помощью Fof,
[01:56:16.900 --> 01:56:18.900]  можно написать просто так.
[01:56:18.900 --> 01:56:21.900]  Значит, принимаем ARC по универсальной ссылке
[01:56:21.900 --> 01:56:24.900]  и дальше вызываем func от std forward от ARC.
[01:56:24.900 --> 01:56:29.900]  Еще раз обращаю внимание, что std forward нужно вызывать
[01:56:29.900 --> 01:56:31.900]  с треугольными скопками,
[01:56:31.900 --> 01:56:34.900]  передавая туда ARC, то есть изначальный тип аргумента,
[01:56:34.900 --> 01:56:38.900]  и, собственно, аргумент, который нужно либо move, либо не move.
[01:56:45.900 --> 01:56:48.900]  Все, и теперь мы все проблемы решили.
[01:56:48.900 --> 01:56:51.900]  Все, вот это корректное решение того,
[01:56:51.900 --> 01:56:54.900]  как можно написать потенциально функцию running time.
[01:56:54.900 --> 01:56:56.900]  Но опять же, не вдаваясь детали,
[01:56:56.900 --> 01:56:58.900]  что функцию, на самом деле, вот эту функцию func
[01:56:58.900 --> 01:57:00.900]  тоже желательно принимать по универсальной ссылке,
[01:57:00.900 --> 01:57:02.900]  но это мы опустим.
[01:57:02.900 --> 01:57:03.900]  Еще раз.
[01:57:03.900 --> 01:57:05.900]  Есть функция running time,
[01:57:05.900 --> 01:57:07.900]  которая принимает первым аргументом функцию,
[01:57:07.900 --> 01:57:09.900]  вторым аргументом принимает универсальную ссылку.
[01:57:09.900 --> 01:57:11.900]  Почему она принимает универсальную ссылку?
[01:57:11.900 --> 01:57:13.900]  Потому что я хочу, чтобы у меня ARC
[01:57:13.900 --> 01:57:15.900]  был либо lvalue с ссылкой,
[01:57:15.900 --> 01:57:17.900]  либо lvalue с ссылкой,
[01:57:17.900 --> 01:57:19.900]  зависит от того, что я передал.
[01:57:19.900 --> 01:57:21.900]  Я принимаю отсчет времени,
[01:57:21.900 --> 01:57:23.900]  то есть запускаю таймер,
[01:57:23.900 --> 01:57:25.900]  и дальше функцию func передаю std forward от ARC и ARC.
[01:57:25.900 --> 01:57:27.900]  Что делает std forward?
[01:57:27.900 --> 01:57:29.900]  Условный move.
[01:57:29.900 --> 01:57:33.900]  Если я хотел функцию func передать lvalue,
[01:57:33.900 --> 01:57:35.900]  то std forward передаст lvalue.
[01:57:35.900 --> 01:57:37.900]  Если я хотел rvalue, то std forward
[01:57:37.900 --> 01:57:39.900]  сделает мне std move от того, что я туда передал.
[01:57:39.900 --> 01:57:41.900]  Окей?
[01:57:41.900 --> 01:57:43.900]  Все.
[01:57:43.900 --> 01:57:45.900]  Ну и в конце,
[01:57:45.900 --> 01:57:47.900]  еще раз нажимаю на таймер
[01:57:47.900 --> 01:57:49.900]  и на этом завершаю работу
[01:57:49.900 --> 01:57:51.900]  и возвращаю то, сколько времени
[01:57:51.900 --> 01:57:53.900]  у меня работала функция.
[01:57:53.900 --> 01:57:55.900]  И теперь не важно, какая у меня функция,
[01:57:55.900 --> 01:57:57.900]  что принимает lvalue, rvalue просто по значению
[01:57:57.900 --> 01:57:59.900]  и так далее, все у меня работает так, как надо.
[01:57:59.900 --> 01:58:01.900]  То есть вызов function от x
[01:58:01.900 --> 01:58:03.900]  абсолютно неотличим
[01:58:03.900 --> 01:58:05.900]  от вызова running time
[01:58:05.900 --> 01:58:07.900]  от function от x.
[01:58:07.900 --> 01:58:09.900]  Понятно?
[01:58:09.900 --> 01:58:11.900]  То есть вот эти вещи,
[01:58:11.900 --> 01:58:13.900]  они абсолютно эквивалентны,
[01:58:13.900 --> 01:58:15.900]  но опять же с точностью до того,
[01:58:15.900 --> 01:58:17.900]  как время считает.
[01:58:17.900 --> 01:58:19.900]  То есть сделали буквально
[01:58:19.900 --> 01:58:21.900]  некоторый декоратор,
[01:58:21.900 --> 01:58:23.900]  аналог Питоновского.
[01:58:23.900 --> 01:58:25.900]  Все хорошо.
[01:58:25.900 --> 01:58:27.900]  Ну вот,
[01:58:27.900 --> 01:58:29.900]  на этом
[01:58:29.900 --> 01:58:31.900]  основная суть.
[01:58:31.900 --> 01:58:33.900]  Да, ну естественно,
[01:58:33.900 --> 01:58:35.900]  можно обобщить на произвольное число аргументов,
[01:58:35.900 --> 01:58:37.900]  то есть естественно,
[01:58:37.900 --> 01:58:39.900]  мы хотим считать времени не только функции,
[01:58:39.900 --> 01:58:41.900]  которые принимают один аргумент,
[01:58:41.900 --> 01:58:43.900]  но потенциально произвольное количество аргументов.
[01:58:43.900 --> 01:58:45.900]  Одного, двух, ну как обобщить?
[01:58:45.900 --> 01:58:47.900]  Очень просто.
[01:58:47.900 --> 01:58:49.900]  Принимаем произвольное количество аргументов
[01:58:49.900 --> 01:58:51.900]  и каждый из них форвардим.
[01:58:51.900 --> 01:58:53.900]  Ну это, я думаю,
[01:58:53.900 --> 01:58:55.900]  не успели забыть, да, как это работает.
[01:58:55.900 --> 01:58:57.900]  std forward от args
[01:58:57.900 --> 01:58:59.900]  многоточие означает, что каждому аргументу
[01:58:59.900 --> 01:59:01.900]  нужно применить std forward.
[01:59:03.900 --> 01:59:05.900]  Все.
[01:59:05.900 --> 01:59:07.900]  И теперь вы можете использовать функцию running time
[01:59:07.900 --> 01:59:09.900]  для подсчета времени работы функции,
[01:59:09.900 --> 01:59:11.900]  которая принимает вообще сколько угодно аргументов.
[01:59:11.900 --> 01:59:13.900]  Хоть один, хоть два, хоть ноль.
[01:59:13.900 --> 01:59:15.900]  Хоть десять.
[01:59:15.900 --> 01:59:17.900]  Вот.
[01:59:17.900 --> 01:59:19.900]  Ну и теперь просто простые примеры применения
[01:59:19.900 --> 01:59:21.900]  из стандартной библиотеки,
[01:59:21.900 --> 01:59:23.900]  где вы можете встретить функцию,
[01:59:23.900 --> 01:59:25.900]  которая ведет себя как running time.
[01:59:25.900 --> 01:59:27.900]  Ну running time это все-таки хороший пример,
[01:59:27.900 --> 01:59:29.900]  но все-таки искусственный немного,
[01:59:29.900 --> 01:59:31.900]  но есть более полезные применения этой всей техники
[01:59:31.900 --> 01:59:33.900]  и как этим пользоваться.
[01:59:33.900 --> 01:59:35.900]  Ну, во-первых, вернемся к std makeunique и makeshared.
[01:59:35.900 --> 01:59:37.900]  Вот теперь я утверждаю,
[01:59:37.900 --> 01:59:39.900]  что вы можете спокойно написать
[01:59:39.900 --> 01:59:41.900]  функции makeunique и makeshared.
[01:59:41.900 --> 01:59:43.900]  Как это сделать?
[01:59:43.900 --> 01:59:45.900]  Давайте так. Что нужно
[01:59:45.900 --> 01:59:47.900]  принимать в функции makeunique?
[01:59:47.900 --> 01:59:49.900]  Умную ссылку.
[01:59:49.900 --> 01:59:51.900]  Одну?
[01:59:51.900 --> 01:59:53.900]  Да, то есть нужно
[01:59:53.900 --> 01:59:55.900]  принимать
[01:59:55.900 --> 01:59:57.900]  вариабельный шаблон, то есть шаблоны с переменом
[01:59:57.900 --> 01:59:59.900]  числом аргументов, и при этом все это
[01:59:59.900 --> 02:00:01.900]  по универсальной ссылке.
[02:00:01.900 --> 02:00:03.900]  Потому что меня конструктор может ожидать
[02:00:03.900 --> 02:00:05.900]  как rvalue, так и lvalue.
[02:00:05.900 --> 02:00:07.900]  А дальше что я делаю?
[02:00:07.900 --> 02:00:09.900]  Внутри создавать std forward.
[02:00:11.900 --> 02:00:13.900]  Да, ну дальше я делаю newt и передаю
[02:00:13.900 --> 02:00:15.900]  args многоточие, так?
[02:00:19.900 --> 02:00:21.900]  Нет, да, std forward.
[02:00:21.900 --> 02:00:23.900]  То есть я хочу
[02:00:23.900 --> 02:00:25.900]  сохранить вид value.
[02:00:25.900 --> 02:00:27.900]  То есть я хочу, чтобы те аргументы, которые
[02:00:27.900 --> 02:00:29.900]  мне передали по lvalue, остались lvalue,
[02:00:29.900 --> 02:00:31.900]  и все то, что мне передали по rvalue,
[02:00:31.900 --> 02:00:33.900]  я хочу, чтобы осталось rvalue.
[02:00:33.900 --> 02:00:35.900]  То есть я хочу...
[02:00:35.900 --> 02:00:37.900]  Я бы это не сказал, но наверное стоило бы.
[02:00:37.900 --> 02:00:39.900]  Вот forward, что значит forward?
[02:00:39.900 --> 02:00:41.900]  Ну forward означает...
[02:00:41.900 --> 02:00:43.900]  forward...
[02:00:43.900 --> 02:00:45.900]  В этой части матика называется
[02:00:45.900 --> 02:00:47.900]  perfect forwarding, то есть прямая передача.
[02:00:47.900 --> 02:00:49.900]  Или идеальная передача.
[02:00:49.900 --> 02:00:51.900]  Вот здесь я в то же самое.
[02:00:51.900 --> 02:00:53.900]  Я хочу идеально взять аргументы
[02:00:53.900 --> 02:00:55.900]  и идеально их передать в том же виде
[02:00:55.900 --> 02:00:57.900]  внутрь какой-то другой функции.
[02:00:57.900 --> 02:00:59.900]  Потому что чтобы обеспечить эту идеальную
[02:00:59.900 --> 02:01:01.900]  передачу, я должен вызвать
[02:01:01.900 --> 02:01:03.900]  std forward.
[02:01:03.900 --> 02:01:05.900]  std forward.
[02:01:05.900 --> 02:01:07.900]  Вот args.
[02:01:07.900 --> 02:01:09.900]  Ну и в скобках передать еще
[02:01:09.900 --> 02:01:11.900]  сами аргументы args, ну и многоточие.
[02:01:11.900 --> 02:01:13.900]  Ну потому что их произвольное количество.
[02:01:13.900 --> 02:01:15.900]  То есть универсальная ссылка
[02:01:15.900 --> 02:01:17.900]  plus std forward
[02:01:17.900 --> 02:01:19.900]  позволяет обеспечить идеальную прямую
[02:01:19.900 --> 02:01:21.900]  передачу. То есть perfect forwarding.
[02:01:21.900 --> 02:01:23.900]  Это надо написать.
[02:01:23.900 --> 02:01:25.900]  Perfect.
[02:01:29.900 --> 02:01:31.900]  Forwarding.
[02:01:31.900 --> 02:01:33.900]  OK.
[02:01:35.900 --> 02:01:37.900]  Еще один пример из стандартной библиотеки.
[02:01:37.900 --> 02:01:39.900]  Вы наверняка
[02:01:39.900 --> 02:01:41.900]  пользовались всякими
[02:01:41.900 --> 02:01:43.900]  векторами, вектор, дек и так далее.
[02:01:43.900 --> 02:01:45.900]  Вот у вектора, помимо метода pushback,
[02:01:45.900 --> 02:01:47.900]  ну и собственно
[02:01:47.900 --> 02:01:49.900]  для строк вы тоже написали нам свой pushback
[02:01:49.900 --> 02:01:51.900]  и так далее.
[02:01:51.900 --> 02:01:53.900]  У вектора есть дополнительный метод emplaceback.
[02:01:53.900 --> 02:01:55.900]  Как он работает?
[02:01:55.900 --> 02:01:57.900]  Ну вообще
[02:01:57.900 --> 02:01:59.900]  в чем проблема pushback? Почему нам нужно
[02:01:59.900 --> 02:02:01.900]  дополнительный emplaceback? Ну смотрите,
[02:02:01.900 --> 02:02:03.900]  допустим, у меня есть
[02:02:03.900 --> 02:02:05.900]  некоторый тяжелый объект.
[02:02:05.900 --> 02:02:07.900]  Что значит тяжелый? Это значит, что его долго копировать,
[02:02:07.900 --> 02:02:09.900]  его долго перемещать.
[02:02:09.900 --> 02:02:11.900]  Вызывать его конструктор
[02:02:11.900 --> 02:02:13.900]  очень дорого.
[02:02:15.900 --> 02:02:17.900]  Что если я хочу
[02:02:17.900 --> 02:02:19.900]  создать объект heavy object,
[02:02:19.900 --> 02:02:21.900]  то есть тяжелый объект, ну и запихнуть его
[02:02:21.900 --> 02:02:23.900]  в конец вектора?
[02:02:23.900 --> 02:02:25.900]  Что происходит здесь?
[02:02:25.900 --> 02:02:27.900]  А здесь происходит следующая вещь.
[02:02:27.900 --> 02:02:29.900]  Создаю тяжелый объект,
[02:02:29.900 --> 02:02:31.900]  ну без создания
[02:02:31.900 --> 02:02:33.900]  мне не обойтись, тут как бы все нормально.
[02:02:33.900 --> 02:02:35.900]  Я создаю тяжелый объект, а даже
[02:02:35.900 --> 02:02:37.900]  что делает pushback?
[02:02:37.900 --> 02:02:39.900]  Ну pushback его копирует, да, в нужное
[02:02:39.900 --> 02:02:41.900]  место, ну вообще говоря, он его может и
[02:02:41.900 --> 02:02:43.900]  мувнуть. То есть pushback
[02:02:43.900 --> 02:02:45.900]  может понять, что мы передали времени
[02:02:45.900 --> 02:02:47.900]  и значение, его мувнуть. Но так или иначе,
[02:02:47.900 --> 02:02:49.900]  тут происходят две вещи. Создание
[02:02:49.900 --> 02:02:51.900]  либо копии, либо move, то есть
[02:02:51.900 --> 02:02:53.900]  два действия.
[02:02:53.900 --> 02:02:55.900]  Ну по факту, что я хочу сделать?
[02:02:55.900 --> 02:02:57.900]  По факту я хочу взять массив и просто
[02:02:57.900 --> 02:02:59.900]  в последнюю ячейку записать
[02:02:59.900 --> 02:03:01.900]  нужный объект. То есть прямо в
[02:03:01.900 --> 02:03:03.900]  нужной ячейке создать нужный мне объект.
[02:03:03.900 --> 02:03:05.900]  И вот ровно это и делает emplaceback.
[02:03:05.900 --> 02:03:07.900]  Emplaceback
[02:03:07.900 --> 02:03:09.900]  принимает не сам объект,
[02:03:09.900 --> 02:03:11.900]  в отличие от pushback. Вот pushback принимает
[02:03:11.900 --> 02:03:13.900]  объект, и дальше уже с ним что-то делает,
[02:03:13.900 --> 02:03:15.900]  либо копирует, либо перемещает. А вот
[02:03:15.900 --> 02:03:17.900]  emplaceback принимает параметры конструктора.
[02:03:17.900 --> 02:03:19.900]  Вот он принимает параметры
[02:03:19.900 --> 02:03:21.900]  конструктора и в нужном месте,
[02:03:21.900 --> 02:03:23.900]  в нужной ячейке создает нужный
[02:03:23.900 --> 02:03:25.900]  мне объект.
[02:03:25.900 --> 02:03:27.900]  И вот emplaceback, в отличие от pushback,
[02:03:27.900 --> 02:03:29.900]  просто-напросто вызывает один конструктор,
[02:03:29.900 --> 02:03:31.900]  просто-напросто создание. Без копирования,
[02:03:31.900 --> 02:03:33.900]  без перемещений. И поэтому потенциали
[02:03:33.900 --> 02:03:35.900]  использования emplaceback, оно гораздо
[02:03:35.900 --> 02:03:37.900]  более эффективно, чем pushback.
[02:03:37.900 --> 02:03:39.900]  Особенно в случае каких-то тяжелых объектов.
[02:03:39.900 --> 02:03:41.900]  Понятно?
[02:03:41.900 --> 02:03:43.900]  Ну и emplaceback
[02:03:43.900 --> 02:03:45.900]  на самом деле работает примерно так же,
[02:03:45.900 --> 02:03:47.900]  как и, собственно,
[02:03:47.900 --> 02:03:49.900]  как и sdmake-unique и sdmake-shared.
[02:03:49.900 --> 02:03:51.900]  Мы принимаем параметры конструктора,
[02:03:51.900 --> 02:03:53.900]  и дальше их forward-им в нужный конструктор.
[02:03:53.900 --> 02:03:55.900]  То есть делаем sdforward
[02:03:55.900 --> 02:03:57.900]  от этих аргументов и создаем в нужном месте
[02:03:57.900 --> 02:03:59.900]  объект.
[02:03:59.900 --> 02:04:01.900]  Окей?
[02:04:01.900 --> 02:04:03.900]  Окей.
[02:04:03.900 --> 02:04:05.900]  Да, ну и здесь вот,
[02:04:05.900 --> 02:04:07.900]  здесь у меня представлена упрощенная реализация emplace,
[02:04:07.900 --> 02:04:09.900]  как бы это могло работать, ну например, в случае
[02:04:09.900 --> 02:04:11.900]  нашего стека, который мы писали.
[02:04:11.900 --> 02:04:13.900]  Ну опять же emplace принимает произвольное количество аргументов,
[02:04:13.900 --> 02:04:15.900]  ну и дальше мы их все
[02:04:15.900 --> 02:04:17.900]  передаем в конструктор T.
[02:04:17.900 --> 02:04:19.900]  Сразу скажу, что это
[02:04:19.900 --> 02:04:21.900]  не совсем то, как работает настоящий emplace
[02:04:21.900 --> 02:04:23.900]  или emplaceback.
[02:04:23.900 --> 02:04:25.900]  Дело в том, что тут вызывается присваивание.
[02:04:25.900 --> 02:04:27.900]  А мы бы хотели в нужном месте создать объект.
[02:04:27.900 --> 02:04:29.900]  Но вот об этом, я надеюсь, мы
[02:04:29.900 --> 02:04:31.900]  в какой-то момент поговорим, но, в общем,
[02:04:31.900 --> 02:04:33.900]  если прям хочется углубиться в это,
[02:04:33.900 --> 02:04:35.900]  то вот, почитайте про placement new.
[02:04:35.900 --> 02:04:37.900]  Ну, если что, в третьем задании
[02:04:37.900 --> 02:04:39.900]  вы познакомитесь с placement new,
[02:04:39.900 --> 02:04:41.900]  все будет нормально.
[02:04:41.900 --> 02:04:43.900]  Идея понятна.
[02:04:43.900 --> 02:04:45.900]  Принимаем параметры конструктора и передаем их
[02:04:45.900 --> 02:04:47.900]  в нужный конструктор при создании.
[02:04:49.900 --> 02:04:51.900]  Вот.
[02:04:51.900 --> 02:04:53.900]  Так.
[02:04:53.900 --> 02:04:55.900]  Время есть, отлично.
[02:04:55.900 --> 02:04:57.900]  И вот теперь про проблемы с
[02:04:57.900 --> 02:04:59.900]  универсальными ссылками,
[02:04:59.900 --> 02:05:01.900]  то есть, каким проблемам они могут привести.
[02:05:03.900 --> 02:05:05.900]  Смотрите.
[02:05:05.900 --> 02:05:07.900]  Можно было сказать
[02:05:07.900 --> 02:05:09.900]  следующую вещь. Ну, хорошо.
[02:05:09.900 --> 02:05:11.900]  Есть универсальные ссылки, давайте всегда
[02:05:11.900 --> 02:05:13.900]  использовать универсальные ссылки
[02:05:13.900 --> 02:05:15.900]  и только их, потому что они
[02:05:15.900 --> 02:05:17.900]  могут адаптироваться под вид-value,
[02:05:17.900 --> 02:05:19.900]  и так далее.
[02:05:19.900 --> 02:05:21.900]  Тут могут возникли проблемы, если вы используете
[02:05:21.900 --> 02:05:23.900]  шаблонный конструктор с универсальными
[02:05:23.900 --> 02:05:25.900]  ссылками. Смотрите в чем проблема.
[02:05:25.900 --> 02:05:27.900]  О, допустим, у меня есть
[02:05:27.900 --> 02:05:29.900]  дефолтный конструктор, у меня есть конструктор
[02:05:29.900 --> 02:05:31.900]  копирования, и я дополнительно
[02:05:31.900 --> 02:05:33.900]  написал универсальный конструктор
[02:05:33.900 --> 02:05:35.900]  который принимает что угодно, и с этим что угодно
[02:05:35.900 --> 02:05:37.900]  что-то делает.
[02:05:37.900 --> 02:05:39.900]  Ну и дальше, ну, собственно, понятно.
[02:05:39.900 --> 02:05:41.900]  У меня есть конструктор копирования,
[02:05:41.900 --> 02:05:43.900]  наверное, я могу копировать объект.
[02:05:43.900 --> 02:05:45.900]  Ну хорошо. Я создаю объект А
[02:05:45.900 --> 02:05:50.460]  и вызываю конструктор копирования от A, создаю объект B.
[02:05:50.460 --> 02:05:54.020]  Вместо того, чтобы увидеть на экране копии,
[02:05:54.020 --> 02:05:57.100]  я вижу, что что-то пошло не так.
[02:05:57.100 --> 02:06:00.120]  Почему-то вот здесь вывозил не конструктор копирования,
[02:06:00.120 --> 02:06:04.320]  а вывался этот шаблонный конструктор, который принимает универсальную ссылку?
[02:06:04.320 --> 02:06:07.300]  Вопрос, почему так вышло?
[02:06:07.300 --> 02:06:12.660]  Почему не был вызван конструктор копирования, а был вызван такой универсальный конструктор?
[02:06:12.660 --> 02:06:24.160]  Да, да, отлично. Смотрите. Дальше на следующем кладете.
[02:06:24.160 --> 02:06:30.160]  Что такое a? Давайте так, поработаем компилятором. Что делает компилятор?
[02:06:30.160 --> 02:06:33.160]  Компилятор пытается понять, какой конструктор вы имели в виду.
[02:06:33.160 --> 02:06:40.160]  Ну хорошо, он смотрит сюда и видит. У меня есть a, и a я могу передать по константной ссылке.
[02:06:40.660 --> 02:06:43.660]  Что мне нужно сделать, чтобы a передать по константной ссылке?
[02:06:43.660 --> 02:06:47.660]  Мне нужно сделать приведение типа. У меня a не констант, и я должен его привести к константе.
[02:06:47.660 --> 02:06:52.660]  Логично. Я могу не констант, а приводить к константам.
[02:06:52.660 --> 02:06:58.660]  А теперь компилятор смотрит вот сюда и думает, чтобы передать сюда a, что мне нужно сделать?
[02:06:58.660 --> 02:07:05.660]  a это lvalue, поэтому в качестве типа t выводится ссылка. А ссылка на что?
[02:07:06.160 --> 02:07:10.160]  A у меня не константный объект, поэтому вводится не константный a.
[02:07:10.160 --> 02:07:16.160]  И компилятор понимает, что у него есть выбор. Передать сюда объект по константной ссылке,
[02:07:16.160 --> 02:07:21.160]  или передать сюда a просто по ссылке. Естественно он выбирает второй вариант.
[02:07:21.160 --> 02:07:25.160]  Почему? По принципу точного соответствия.
[02:07:25.160 --> 02:07:29.160]  Вот этот конструктор обеспечивает точное соответствие.
[02:07:29.160 --> 02:07:34.160]  То есть я передал не константный a, и я могу сюда передать ссылку на не константный a.
[02:07:34.660 --> 02:07:37.660]  Ну и все. Конструктор копирования заблокирован.
[02:07:37.660 --> 02:07:40.660]  Ну в таких случаях. Если бы мы передали константный объект, то естественно
[02:07:40.660 --> 02:07:43.660]  вызвался бы конструктор копирования нужный.
[02:07:43.660 --> 02:07:47.660]  Но как часто вы копируете константные объекты?
[02:07:47.660 --> 02:07:51.660]  Как часто вы еще код пишете?
[02:07:51.660 --> 02:07:55.660]  Хотелось бы чаще, ну ладно.
[02:07:55.660 --> 02:07:59.660]  Ну и как решить эту проблему? Решение несколько.
[02:08:00.160 --> 02:08:06.160]  Решение. Это… Если вам очень сильно хочется и очень сильно нужен конструктор от универсальной ссылки,
[02:08:06.160 --> 02:08:11.160]  то вам придется прописать конструкторы на все случаи жизни.
[02:08:11.160 --> 02:08:15.160]  То есть вам нужно написать конструктор копирования, который принимает константный a.
[02:08:15.160 --> 02:08:18.160]  Вам нужно писать конструктор копирования, который принимает не константный a.
[02:08:18.160 --> 02:08:23.160]  Вам нужно написать конструктор перемещения.
[02:08:23.160 --> 02:08:28.160]  И плюс написать конструктор, который принимаетupid self url ссылке.
[02:08:28.160 --> 02:08:34.160]  Все эти случаи нужно прописать, чтобы их внезапно не забрал себе вот этот самый универсальный конструктор.
[02:08:34.160 --> 02:08:46.160]  Либо вы можете написать еще раз какую-то там магическую функцию, которая, давайте так, в общих чертах обрисуем, что она делает.
[02:08:46.160 --> 02:08:59.160]  EnableIFT говорит нам о том, что эта функция должна быть включена только в случае, если неверно, что тип A не совпадает с типом std.dk.i.t.
[02:08:59.160 --> 02:09:10.160]  В общем, грубо говоря, здесь написано, что эта функция должна принимать участие в перегрузке только если после того, как вы убрали все ссылки, все константы с типа T, у вас получится A.
[02:09:11.160 --> 02:09:18.160]  Ну понятно, что если после того, как вы очистили тип T от ссылок и от константов, у вас получилась A, то значит, что этот конструктор вызывать не нужно.
[02:09:18.160 --> 02:09:25.160]  Но это магия, она вряд ли пригодится. В общем, общее замечание – не используйте универсальный конструктор и все.
[02:09:25.160 --> 02:09:30.160]  Они нужны, но они нужны крайне редко, в нашем курсе они вам точно не нужны.
[02:09:30.160 --> 02:09:40.160]  Ну и последний пункт. Он такой более развлекательный.
[02:09:40.160 --> 02:09:53.160]  Он тоже напрямую не относится к символике перемещения, но он скорее больше поучительный про то, что конструктор перемещения на самом деле очень сложно вызвать.
[02:09:53.160 --> 02:10:06.160]  Давайте посмотрим налево. Что я хочу сделать? Что я хочу показать? Я хочу провести несколько экспериментов и посмотреть, в каких случаях у меня вызывается move конструктор,
[02:10:06.160 --> 02:10:11.160]  в каких случаях у меня вызывается copy конструктор и вообще вызываются они или нет на самом деле.
[02:10:11.160 --> 02:10:17.160]  У меня есть обычный класс A, который просто-напросто логирует все то, что он делает.
[02:10:17.160 --> 02:10:23.160]  То есть когда он создается, он говорит, что я создался с помощью default конструктора, если он создался с помощью копирования, он говорит, что был вызван copy конструктор,
[02:10:23.160 --> 02:10:28.160]  если он там был перемещен, то он говорит, что move конструктор, ну и так далее. В общем, он просто говорит, какие действия он выполняет.
[02:10:28.160 --> 02:10:36.160]  Дальше у меня есть функция f и есть функция g, о них позже поговорим. Давайте просто перейдем по порядку примером.
[02:10:36.160 --> 02:10:46.160]  Давайте по порядку. Давайте C++14 пока включим.
[02:10:46.160 --> 02:11:02.160]  Ну по порядку. Секция номер ноль. Что я делаю? Я создаю объект A, дальше копирую объект A в B и дальше присваиваю объект B в A.
[02:11:02.160 --> 02:11:09.160]  То есть что я ожидаю увидеть? Я ожидаю, что объект A создаться с помощью default конструктора, объект B создаться с помощью copy конструктора,
[02:11:09.160 --> 02:11:17.160]  а дальше третьей строкой у меня что будет? Ну копирующее присваивание. Ну ровно это, кажется, я и вижу. Вот экзампл ноль справа.
[02:11:17.160 --> 02:11:24.160]  Сначала вызвать default конструктор, потом copy конструктор, потом copy assignment. Ну ничего удивительного нет.
[02:11:24.160 --> 02:11:33.160]  Дальше переходим к первой секции. Я создаю объект A и создаю объект B с помощью std move от A.
[02:11:33.160 --> 02:11:41.160]  А потом присваиваю объект A и std move от B. Что я ожидаю увидеть? Я ожидаю увидеть одно создание с помощью default конструктора и дальше два move.
[02:11:41.160 --> 02:11:45.160]  Ну собственно это и происходит. Снова ничего удивительного.
[02:11:45.160 --> 02:11:54.160]  Ну std move от A и std move от B как раз говорит нужно притвориться временным и поэтому как бы здесь объект B, в 47 строке объект B думает, что справа стоит rvalue,
[02:11:54.160 --> 02:12:02.160]  поэтому вызывается конструктор перемещения. А в 48 строке объект A думает, что справа стоит rvalue и вызывается перемещающее присваивание.
[02:12:02.160 --> 02:12:08.160]  Ну это обсуждали в прошлый раз, тоже ничего удивительного. Все хорошо.
[02:12:08.160 --> 02:12:22.160]  А вот теперь должны начаться удивительные вещи. Номер два. Смотрите, давайте поработаем старым компилятором, ну не знаю, компилятором образца 14, 11 или еще более старого образца.
[02:12:22.160 --> 02:12:31.160]  И попробуем чисто пенантично, формально посмотреть, что тут на самом деле должно происходить. А что тут должно происходить?
[02:12:31.160 --> 02:12:45.160]  Я создаю объект A с помощью rvalue значения A. То есть я справа создаю временный объект и говорю, что с помощью него нужно создать объект, который стоит слева.
[02:12:45.160 --> 02:12:55.160]  То есть казалось бы, если следовать строгой букве языка C++, то что тут происходит? Сначала создается временный объект, то есть вызывается default конструктор.
[02:12:55.160 --> 02:13:08.160]  А потом этот временный объект должен переместиться в A. Согласны? Ожидаемое поведение? Ну и здесь тоже на самом деле.
[02:13:08.160 --> 02:13:14.160]  Тут уже не конструктор, тут уже присваивание. Я справа создаю временный объект, и временный объект присваиваю в A.
[02:13:14.160 --> 02:13:20.160]  То есть у меня должен вызываться один default конструктор, и плюс этот вот временный объект, который создался, должен переместиться в A.
[02:13:20.160 --> 02:13:23.800]  То есть я должен увидеть два дефолт-конструирования и два move-конструирования.
[02:13:23.800 --> 02:13:26.560]  Что я вижу на самом деле?
[02:13:26.560 --> 02:13:30.960]  А я вижу, что один move пропал внезапно.
[02:13:30.960 --> 02:13:36.320]  Причем пропал move именно отсюда, с 53-й строки.
[02:13:36.320 --> 02:13:42.000]  То есть в 53-й строке у меня вызвался только один дефолтный конструктор.
[02:13:42.000 --> 02:13:45.320]  Никакого move не произошло.
[02:13:45.320 --> 02:13:47.480]  Ну, допустим.
[02:13:47.480 --> 02:13:49.160]  Что вы скажете на это?
[02:13:49.280 --> 02:13:51.520]  Тут надо посмотреть на определение функции f.
[02:13:51.520 --> 02:13:54.880]  Функция f простая. Функция просто возвращает a.
[02:13:54.880 --> 02:13:59.520]  Но она создает a в return и сразу же его возвращает.
[02:13:59.520 --> 02:14:00.440]  Функт 3.
[02:14:00.440 --> 02:14:02.040]  Что я ожидал увидеть? Снова.
[02:14:02.040 --> 02:14:03.760]  Я справа вызываю функцию f.
[02:14:03.760 --> 02:14:06.840]  У меня функция f должна создать этот объект,
[02:14:06.840 --> 02:14:09.240]  а потом переместить его в a.
[02:14:09.240 --> 02:14:11.320]  Наверное, так должно работать.
[02:14:11.320 --> 02:14:13.240]  Ну и на 60-й строке тоже самое.
[02:14:13.240 --> 02:14:18.520]  f создает новый объект, и дальше я его перемещаю с помощью присваивания в a.
[02:14:18.520 --> 02:14:21.600]  Смотрим, что на самом деле... Снова.
[02:14:21.600 --> 02:14:24.000]  Куда-то пропал один move.
[02:14:24.000 --> 02:14:26.920]  И move пропал в 59-й строке.
[02:14:26.920 --> 02:14:29.400]  То есть f у меня создал объект,
[02:14:29.400 --> 02:14:32.440]  но как будто бы его никуда не переместил.
[02:14:32.440 --> 02:14:35.320]  Странно.
[02:14:35.320 --> 02:14:37.800]  Идем дальше.
[02:14:37.800 --> 02:14:40.360]  Смотрим на определение функции g.
[02:14:40.360 --> 02:14:44.440]  Функция g работает примерно точно так же, как и функция f,
[02:14:44.440 --> 02:14:48.480]  но при этом она внутри себя создает объект a.
[02:14:48.480 --> 02:14:50.920]  А потом этот объект возвращает.
[02:14:50.920 --> 02:14:53.360]  То есть она внутри себя создает объект, и потом его возвращает.
[02:14:53.360 --> 02:14:55.360]  То есть тут уже как бы не отвертеться.
[02:14:55.360 --> 02:14:58.080]  Так или иначе у нас этот объект должен создаться внутри.
[02:14:58.080 --> 02:15:02.480]  У меня есть такая инструкция.
[02:15:02.480 --> 02:15:05.080]  Поэтому тут как будто бы я ожидаю следующего поведения.
[02:15:05.080 --> 02:15:07.520]  Я ожидаю, что у меня функция g внутри себя создаст объект
[02:15:07.520 --> 02:15:09.000]  с помощью default-конструктора.
[02:15:09.000 --> 02:15:13.600]  Потом этот объект вернет в точку вызова с помощью move-конструктора.
[02:15:13.600 --> 02:15:15.600]  И дальше вот этот временный объект, который получился,
[02:15:15.600 --> 02:15:18.040]  снова move-нется в нужное место a.
[02:15:18.080 --> 02:15:20.560]  Ну и в 66-й строке то же самое.
[02:15:20.560 --> 02:15:21.680]  Смотрим.
[02:15:21.680 --> 02:15:25.680]  Ну тут вообще совсем непонятно.
[02:15:25.680 --> 02:15:31.160]  В строке номер 65 вызывается только один default-конструктор.
[02:15:31.160 --> 02:15:35.080]  То есть вот тут у вас должны заказаться сомнения.
[02:15:35.080 --> 02:15:38.040]  Ну смотрите, в 65-й строке, в принципе, кажется,
[02:15:38.040 --> 02:15:39.960]  и априори не может создаться один объект.
[02:15:39.960 --> 02:15:40.960]  Почему?
[02:15:40.960 --> 02:15:43.560]  Потому что как минимум я создаю вот этот объект.
[02:15:43.560 --> 02:15:44.760]  Видно, да?
[02:15:44.760 --> 02:15:46.920]  Я его объявляю.
[02:15:46.920 --> 02:15:49.520]  И плюс я создаю вот этот объект.
[02:15:49.520 --> 02:15:52.120]  Более того, функцию g я вызываю два раза.
[02:15:52.120 --> 02:15:55.880]  Поэтому функция g должна была создать мне два объекта.
[02:15:55.880 --> 02:16:00.240]  А выходит, как будто бы не создает ни одного.
[02:16:00.240 --> 02:16:01.680]  Ладно.
[02:16:01.680 --> 02:16:04.600]  Ну и наконец, ну давайте, да, пятый пример.
[02:16:04.600 --> 02:16:07.240]  Пятый пример, ну, так.
[02:16:07.240 --> 02:16:08.120]  Определение функции h.
[02:16:08.120 --> 02:16:11.920]  h просто принимает внутри себя аргумент a.
[02:16:11.920 --> 02:16:12.560]  Вот.
[02:16:12.560 --> 02:16:16.880]  То есть я создаю параметр a.
[02:16:16.880 --> 02:16:18.760]  То есть с помощью дефолтного конструктора.
[02:16:18.760 --> 02:16:20.360]  Я передаю h от a.
[02:16:20.360 --> 02:16:22.720]  Я ожидаю, что у него будет вызван копирующий конструктор.
[02:16:22.720 --> 02:16:24.120]  Я вызываю h от sdmove от a.
[02:16:24.120 --> 02:16:25.560]  У меня должен вызваться move-конструктор.
[02:16:25.560 --> 02:16:26.400]  Тут, на самом деле, все нормально.
[02:16:26.400 --> 02:16:28.000]  Да, так и происходит.
[02:16:28.000 --> 02:16:28.160]  Все.
[02:16:28.160 --> 02:16:33.200]  Если h принимает, то есть если я h передаю a, то a может только скопироваться.
[02:16:33.200 --> 02:16:35.520]  Если я делаю sdmove от a, то a притворяется временным
[02:16:35.520 --> 02:16:37.240]  и вызывается конструктор перемещения.
[02:16:37.240 --> 02:16:39.280]  Все нормально.
[02:16:39.280 --> 02:16:43.400]  И вот, наконец, финальный пример.
[02:16:43.400 --> 02:16:47.720]  Что если я в h передам a с круглыми скопками?
[02:16:47.720 --> 02:16:49.240]  Ну, снова, что я ожидаю?
[02:16:49.240 --> 02:16:50.440]  h принимает a.
[02:16:50.440 --> 02:16:54.400]  Значит, вот здесь должен создаться временный объект a.
[02:16:54.400 --> 02:16:57.400]  А потом переместится в h.
[02:16:57.400 --> 02:16:58.400]  Что произойдет здесь?
[02:16:58.400 --> 02:16:59.400]  f.
[02:16:59.400 --> 02:17:01.480]  Напомню, f возвращает просто a.
[02:17:01.480 --> 02:17:03.880]  То есть делает return и создает a на месте.
[02:17:03.880 --> 02:17:06.960]  То есть я ожидаю, что f мне создаст в нужном месте a.
[02:17:06.960 --> 02:17:09.760]  И потом этот a переместится в h.
[02:17:09.760 --> 02:17:10.760]  Ну, и с g тоже самое.
[02:17:11.440 --> 02:17:14.280]  g внутри себя создает объект a.
[02:17:14.280 --> 02:17:15.280]  Потом его возвращает наружу.
[02:17:15.280 --> 02:17:22.280]  И вот то, что свернулось наружу, должно перейти в h.
[02:17:22.280 --> 02:17:23.280]  Вообще безобразие.
[02:17:23.280 --> 02:17:24.280]  Смотрите.
[02:17:24.280 --> 02:17:25.440]  Только три дефолтных конструктора.
[02:17:25.440 --> 02:17:30.440]  Хотя при этом, смотрите, я создал a вот тут.
[02:17:30.440 --> 02:17:33.560]  У меня f должен был создать a, g должен был создать a.
[02:17:33.560 --> 02:17:36.160]  И плюс a в качестве своего аргумента тоже принимает a.
[02:17:36.160 --> 02:17:38.480]  То есть там тоже должен был создаться a.
[02:17:38.720 --> 02:17:39.720]  Но куда-то это все делось.
[02:17:39.720 --> 02:17:43.720]  И вот дело как раз так называемым copy-elision.
[02:17:43.720 --> 02:17:50.120]  Ладно, тут не буду переключаться, в общем, скажу словами.
[02:17:50.120 --> 02:17:52.000]  На слайдах можете посмотреть.
[02:17:52.000 --> 02:17:54.000]  Значит, copy-elision.
[02:17:54.000 --> 02:17:58.920]  Copy-elision это оптимизация компилятора, которая избавляется
[02:17:58.920 --> 02:17:59.920]  от временных объектов.
[02:17:59.920 --> 02:18:06.520]  Ну и действительно, смотрите, везде в коде, где я писал
[02:18:06.560 --> 02:18:09.160]  default-plus-move и так далее, везде я как бы подразумевал,
[02:18:09.160 --> 02:18:11.880]  что у меня есть некоторый временный объект, который
[02:18:11.880 --> 02:18:12.880]  нужно куда-то переместить.
[02:18:12.880 --> 02:18:16.800]  И вот компилятор на самом деле в этом смысле не дурак.
[02:18:16.800 --> 02:18:18.920]  Компилятор понимает, что вот вы тут, давайте вот
[02:18:18.920 --> 02:18:22.440]  тут, например, вот вы тут создаете временный объект,
[02:18:22.440 --> 02:18:25.520]  а потом его сразу перемещаете в a.
[02:18:25.520 --> 02:18:27.440]  Ну это неэффективно, согласны?
[02:18:27.440 --> 02:18:29.920]  То есть, наверное, было бы логично сразу взять этот
[02:18:29.920 --> 02:18:31.480]  объект и создать в нужном месте.
[02:18:31.480 --> 02:18:34.320]  И вот ровно это и происходит.
[02:18:34.320 --> 02:18:37.560]  Ровно это и заключается, ровно в этом и заключается
[02:18:37.560 --> 02:18:38.560]  копия-elision.
[02:18:38.560 --> 02:18:42.080]  То есть, эллиминация копирования, уничтожение копирования.
[02:18:42.080 --> 02:18:44.920]  И ровно это происходит везде.
[02:18:44.920 --> 02:18:45.920]  То есть, смотрите, f.
[02:18:45.920 --> 02:18:48.120]  f должен создать временный объект и потом переместить
[02:18:48.120 --> 02:18:49.120]  его в a.
[02:18:49.120 --> 02:18:50.120]  Компилятор не дурак.
[02:18:50.120 --> 02:18:51.680]  Компилятор понимает, что вот то, что создает f, на
[02:18:51.680 --> 02:18:53.560]  самом деле нужно только для того, чтобы проинцидизировать
[02:18:53.560 --> 02:18:54.560]  a.
[02:18:54.560 --> 02:18:59.120]  Поэтому вот то, что создает f, сразу же, сразу конструируется
[02:18:59.120 --> 02:19:01.560]  в том месте, где находится a.
[02:19:01.800 --> 02:19:04.560]  Для функции g это вообще удивительно.
[02:19:04.560 --> 02:19:09.160]  Смотрите, казалось бы, внутри функции g я создаю a.
[02:19:09.160 --> 02:19:12.320]  То есть, я вот эту a-шку создаю внутри g.
[02:19:12.320 --> 02:19:16.600]  Но компилятор понимает, что вот этот a, на самом деле,
[02:19:16.600 --> 02:19:21.240]  нужен по итогу только для того, чтобы проинцидизировать
[02:19:21.240 --> 02:19:22.240]  вот этот a.
[02:19:22.240 --> 02:19:29.440]  И поэтому вот этот a, на самом деле, сразу же создается
[02:19:29.440 --> 02:19:30.440]  в нужном месте.
[02:19:31.320 --> 02:19:32.320]  Понятно?
[02:19:32.320 --> 02:19:36.040]  То есть, вот этот a, на самом деле, то есть, вот тут создается
[02:19:36.040 --> 02:19:38.720]  не тот a, который внутри g, а создается именно тот
[02:19:38.720 --> 02:19:43.400]  a, который находится вот здесь, в пункте 4.
[02:19:43.400 --> 02:19:48.760]  Вот это все называется копия иллюзии, и это все оптимизация
[02:19:48.760 --> 02:19:49.760]  компилятора.
[02:19:49.760 --> 02:19:51.920]  Эту оптимизацию компилятора можно отключить с помощью
[02:19:51.920 --> 02:19:57.840]  опции minus f no elite constructors.
[02:19:58.840 --> 02:20:02.480]  Вот, и теперь мы, давайте посмотрим сразу интересные
[02:20:02.480 --> 02:20:03.480]  примеры.
[02:20:03.480 --> 02:20:04.480]  Вот пример 4.
[02:20:04.480 --> 02:20:07.720]  Вот в примере 4 теперь мы видим все то, что ожидали
[02:20:07.720 --> 02:20:08.720]  увидеть.
[02:20:08.720 --> 02:20:12.160]  Default constructor, потом move constructor, потом еще раз move constructor
[02:20:12.160 --> 02:20:13.160]  и так далее.
[02:20:13.160 --> 02:20:14.440]  Вот все то, что убрал нам компилятор, мы просили
[02:20:14.440 --> 02:20:15.440]  не убирать.
[02:20:15.440 --> 02:20:16.440]  Ну вот, пожалуйста.
[02:20:16.440 --> 02:20:19.520]  Ну и последний пример тоже интересный, тут тоже много
[02:20:19.520 --> 02:20:20.520]  чего.
[02:20:20.520 --> 02:20:22.320]  Помните, в шестом примере у нас было всего лишь три
[02:20:22.320 --> 02:20:23.320]  вызова конструктора.
[02:20:23.320 --> 02:20:25.040]  То есть, три создания объекта.
[02:20:25.360 --> 02:20:28.200]  А здесь мы создали объект, переместили, создали объект,
[02:20:28.200 --> 02:20:30.880]  переместили, создали объект и два раза переместили.
[02:20:30.880 --> 02:20:33.720]  Ну, почему два раза переместили?
[02:20:33.720 --> 02:20:35.440]  Потому что как работает g?
[02:20:35.440 --> 02:20:39.440]  g сначала создает объект, потом его возвращает в место
[02:20:39.440 --> 02:20:42.160]  вызова с помощью cd move, а потом из этого места вызова
[02:20:42.160 --> 02:20:47.640]  он еще move-ается в то, куда его попросили переместиться.
[02:20:47.640 --> 02:20:49.640]  Понятно?
[02:20:49.640 --> 02:20:53.400]  Вот, поэтому копия иллюзии, это такая хитрая штука.
[02:20:53.480 --> 02:20:55.560]  С одной стороны, она позволяет очень сильно сэкономить
[02:20:55.560 --> 02:20:57.760]  на копированиях и на перемещениях.
[02:20:57.760 --> 02:20:58.760]  С одной стороны.
[02:20:58.760 --> 02:21:02.160]  С другой стороны, она может вызывать некоторые недоумения
[02:21:02.160 --> 02:21:04.120]  в случае, если вы все-таки ожидаете увидеть что-то
[02:21:04.120 --> 02:21:05.120]  на экране.
[02:21:05.120 --> 02:21:08.600]  Ну, тут я как бы делал так, чтобы у меня конструктор
[02:21:08.600 --> 02:21:11.200]  водили что-то на экран, но в принципе вы могли закладываться
[02:21:11.200 --> 02:21:13.880]  на поведение, что у вас move-конструктор дополнительно
[02:21:13.880 --> 02:21:14.880]  что-то делает полезное.
[02:21:14.880 --> 02:21:18.480]  И вот в этом смысле компилятор это все убирает.
[02:21:18.480 --> 02:21:20.680]  И об этом важно помнить.
[02:21:20.680 --> 02:21:23.280]  И это как бы было расширение компилятора в обход стандарта
[02:21:23.280 --> 02:21:24.280]  языка.
[02:21:24.280 --> 02:21:26.400]  В обход стандарта языка.
[02:21:26.400 --> 02:21:34.240]  Но в 17 стандарте копия elision официально, в общем,
[02:21:34.240 --> 02:21:37.240]  в общем, его легализовали в C++.
[02:21:37.240 --> 02:21:38.240]  Давайте посмотрим.
[02:21:38.240 --> 02:21:43.680]  Давайте посмотрим на то же самое, но только внутри
[02:21:43.680 --> 02:21:44.680]  C++17.
[02:21:44.680 --> 02:21:50.880]  Снова я делаю все то же самое, но в C++17 и при этом говорю
[02:21:51.560 --> 02:21:53.560]  компилятору, пожалуйста, не убирай конструкторы.
[02:21:53.560 --> 02:21:55.720]  То есть не убирай конструкторы, которые ты можешь убрать.
[02:21:55.720 --> 02:21:58.000]  Что у меня происходит?
[02:21:58.000 --> 02:21:59.520]  Снова все нормально.
[02:21:59.520 --> 02:22:04.120]  И снова мы видим, что почти везде нужные конструкторы
[02:22:04.120 --> 02:22:05.120]  убрались.
[02:22:05.120 --> 02:22:08.120]  Давайте сравним.
[02:22:08.120 --> 02:22:15.680]  В C++14, ну, экзампл 6, в C++14 я явно попросил компилятор
[02:22:15.680 --> 02:22:17.160]  не убирать конструкторы, он ничего не убрал.
[02:22:18.000 --> 02:22:21.560]  В C++17 я явно попросил компилятор не убирать конструкторы,
[02:22:21.560 --> 02:22:22.560]  и он все равно что-то убрал.
[02:22:22.560 --> 02:22:28.920]  Это как раз говорит о том, что в 17 стандарте вот это
[02:22:28.920 --> 02:22:32.320]  поведение, убирание конструкторов, которые не нужны, стало
[02:22:32.320 --> 02:22:33.320]  обязательным.
[02:22:33.320 --> 02:22:36.360]  Обязательно, но не во всех случаях.
[02:22:36.360 --> 02:22:37.840]  Об этом на слайдах поговорим.
[02:22:37.840 --> 02:22:40.840]  Давайте пока вопросы.
[02:22:40.840 --> 02:22:41.840]  Пока все понятно.
[02:22:41.840 --> 02:22:45.640]  То есть на самом деле в современных плюсах вызвать
[02:22:45.720 --> 02:22:47.520]  конструктор перемещения не так-то просто.
[02:22:47.520 --> 02:22:49.560]  То есть на самом деле компилятор может все соптимизировать
[02:22:49.560 --> 02:22:52.120]  так, что и без всякого перемещения у вас все будет...
[02:22:52.120 --> 02:23:04.280]  Ну ладно, в принципе, на этом все, если что, закончим
[02:23:04.280 --> 02:23:05.280]  в следующий раз.
[02:23:05.280 --> 02:23:06.280]  А пока пожарная тревога.
