[00:00.000 --> 00:14.760]  так у нас пропало в итоге 4 пары получается да ну из них я две попытаюсь нагадать прям
[00:14.760 --> 00:24.480]  сегодня две в следующий раз короче смотрите что у нас осталось нам с вами осталось закончить тему
[00:24.480 --> 00:28.520]  шаблонного метапрограммирования по идее мы должны были закончить в прошлый раз и последняя тема
[00:28.520 --> 00:39.640]  compile time вычисления которая у нас должна быть сегодня и в следующий раз вот я думаю что мы
[00:39.640 --> 00:49.640]  поступим так я вам сейчас за минут 40 или за час быстренько расскажу ну так не покажу то что
[00:49.640 --> 00:56.000]  должен был рассказывать три часа вот то есть я не буду там вдаваться в детали я просто чтобы вы
[00:56.000 --> 01:02.120]  были в курсе чтобы так немного может освежить кто-нибудь посмотрел чтобы не совсем вы сами все
[01:02.120 --> 01:08.400]  вот или чтобы у вас вопросы можно было задать ну и за одно что вы потом не жаловались что вам это не
[01:08.400 --> 01:15.520]  рассказывали и спрашивают вот я все-таки вкратце расскажу что там за история тем более это моя
[01:15.520 --> 01:22.200]  любимая тема одна из любимых поэтому ну как-то совсем не грустно что мы так ее и не прошли вот
[01:22.200 --> 01:30.520]  а в следующий раз ну тогда уж тайп лист и последняя так сказать финальный аккорд в общем в
[01:30.520 --> 01:38.240]  следующий раз будет в следующий раз у нас вроде как зачетная неделя но мы я использую нагло этот
[01:38.240 --> 01:51.040]  раз чтобы восполнить пропавшие выходные у нас не будет алгоритмов это ты конечно сейчас тебя за
[01:51.040 --> 02:02.640]  это твои коллеги захатят а то есть можно типа в следующий раз а то есть а то есть я могу
[02:02.640 --> 02:06.400]  типа сейчас рассказать в нормальном темпе то что прошлый раз должно было быть а в следующий
[02:06.400 --> 02:13.520]  раз рассказать все остальное нет ну короче давайте я в каком-то темпе в ускоренном все-таки
[02:13.520 --> 02:21.160]  быстренько расскажу то что в прошлый раз собирался и все-таки начну ноутер я не хочу
[02:21.160 --> 02:28.600]  да я хочу это быстренько так скажем так проспидранить чтобы мы все были в курсе того
[02:28.600 --> 02:34.800]  что от вас ожидалось и что там имелось в виду вот и дальше я начну рассказывать компайл тайм
[02:34.800 --> 02:47.520]  вычисления вот проверка наличия методов классе вот она у меня готовая написано с прошлого года
[02:47.520 --> 02:57.920]  в целом если вы знаете что такое с финаге то вы наверное понимаете как это написать тут
[02:57.920 --> 03:02.000]  тем не менее есть несколько важных моментов на которые стоит обратить внимание
[03:02.000 --> 03:17.040]  почему так ладно сейчас мы сейчас мы дойдем до этого а ну вот сразу видно человек смотрел
[03:17.040 --> 03:25.960]  значит история о чем в чем мы хотим научиться теперь с помощью с финаге с помощью на и был
[03:25.960 --> 03:30.400]  фа писать ну и нейбл фа про약 полностью в сно сказали проверку что в классе присутствует
[03:30.400 --> 03:36.040]  данный метод с данными аргументами данный конкретно метод с названием вот за hpeszcze
[03:36.040 --> 03:42.960]  им название и с данными шаблонными параметрами вот мы написали мета функцию transforming
[03:42.960 --> 03:48.800]  почему констракт ну мы вот как в аллокатрия как аллокатор троиц проверяет есть ли в
[03:48.800 --> 03:54.020]  аллокатрии метод констракта данных аргументов ну вот там примерно такая метафункция написано
[03:54.020 --> 04:03.300]  есть шаблонный тип T, шаблонный ARX, hasMethodConstruct это декл-тайп от вот такой штуковины,
[04:03.300 --> 04:14.300]  hmchelper, t-arx от нуля. Да, это мы еще в прошлый раз делали. Декл-тайп это полноценный тип,
[04:14.300 --> 04:22.460]  то есть мы наследуемся от вот такой штуковины, hmchelper с такими-то шаблонными параметрами от нуля.
[04:22.460 --> 04:31.620]  Ага, раз от нуля, значит декл-тайп пытается выяснить, что это за тип, чтобы от него у наследоваться,
[04:31.620 --> 04:41.340]  и он должен здесь разрешить перегрузку. hmchelper от int он должен вызвать. Есть на самом деле два
[04:41.340 --> 04:49.860]  hmchelper, один от int, а другой от всего чего угодно, и конечно же предпочтительнее этот. А этот
[04:49.860 --> 05:01.140]  возвращает следующий тип. IntegralConstant вот такого типа true. Что такое IntegralConstant мы в
[05:01.140 --> 05:12.380]  прошлый раз обсуждали. Ему надо вычислить, что это за тип. Ну вот здесь давайте я пока напишу
[05:12.380 --> 05:19.780]  просто вот так для простоты. Здесь написано декл-тайп от t с круглыми скобочками, точка констракт,
[05:19.780 --> 05:28.740]  и вместо декл-вал тоже напишу вот так. А что здесь такое? Здесь опять кома-трик. Да,
[05:28.740 --> 05:38.380]  что такое кома-трик? Мы в прошлый раз обсуждали. Тип этого выражения, это на самом деле буль,
[05:38.380 --> 05:43.780]  в любом случае. Ну вот под декл-тайпом написано некоторое expression. Вот в этих скобочках написано
[05:43.780 --> 05:51.140]  некоторое expression. Его тип это в любом случае буль, потому что там оператор запятая стоит. Вот
[05:51.140 --> 05:56.740]  это оператор запятая. Не просто запятая, а оператор запятая, который вычисляет левый аргумент,
[05:56.740 --> 06:02.280]  вычисляет правый, возвращает правый. Тип этого выражения буль в любом случае, но это выражение
[06:02.280 --> 06:13.320]  некорректно, если у типа t нету методоконстракт от таких аргументов. Поэтому, если у типа t нету
[06:13.320 --> 06:19.440]  методоконстракт от таких аргументов, компилятор, пытаясь понять, какой тип возвращает эта функция,
[06:19.440 --> 06:25.800]  идет сюда, пытается вычислить этот тип и понимает, что он наталкивается на некомпилируемое выражение.
[06:25.800 --> 06:31.520]  Значит, эта перегрузка у него отваливается. И остается другая перегрузка, которая менее
[06:31.520 --> 06:37.880]  предпочтительная, она принимает что угодно, но возвращает false type. Значит, получается, что
[06:37.880 --> 06:44.800]  hesmet construct наследник false type. А false type это что такое? Это структура, в которой написано static
[06:44.800 --> 06:53.520]  cons bool value равно false. А если бы он смог вот этот тип вычислить, то есть если бы это было корректным
[06:53.520 --> 07:01.240]  выражением, то этот hesmet construct был бы наследником true type. А true type это что такое? Это integral
[07:01.240 --> 07:07.480]  constant bool true. А что это такое? Это такая метафункция, то есть структура, в которой написано using,
[07:07.480 --> 07:15.560]  точнее не using, static const t value, где t это тип вот этой integral, bool value равно true. Ну вот и все,
[07:15.560 --> 07:19.760]  вот и получилось, что в зависимости от того есть или нет этот метод у данного типа от таких
[07:19.760 --> 07:28.280]  аргументов, у нас написано либо static cons bool value равно true, либо false. Здесь есть проблема. Вот я
[07:28.280 --> 07:35.320]  стер тут decal val, значит, есть некоторый decal val и я вместо него написал вот это. Здесь есть проблема.
[07:35.320 --> 07:41.440]  Кто смотрел прошлогодние лекции, тот знает какая, да в принципе можно и так догадаться какая. Это
[07:41.440 --> 07:46.560]  может отвалиться по причине не того, что мет метод construct от таких аргументов, а по причине того,
[07:46.560 --> 07:53.560]  что у t нет конструктора по умолчанию или у args нет конструктора по умолчанию. Что же делать? Нам
[07:53.560 --> 07:59.760]  надо как-то по типу t получить объект t. Мы не можем написать t круглой скобочки, точь констракта,
[07:59.760 --> 08:03.480]  args круглой скобочки, потому что а вдруг нет конструктора по умолчанию, тогда мы отвалимся,
[08:03.480 --> 08:12.960]  хотя метод констракта может быть был. Нам нужна специальная функция, которая, ну можно было бы и
[08:12.960 --> 08:17.800]  без нее обойтись, что нам надо сделать? Нам нужно некоторым образом получить здесь выражение типа t,
[08:17.800 --> 08:24.560]  не обращаясь к конструктору t. А как это сделать? Ну давайте просто запрячем это в еще один вызов
[08:24.560 --> 08:31.240]  функции. Давайте напишем функцию, которая просто возвращает t. Но я могу опять же, я опять упрощу,
[08:31.240 --> 08:36.360]  я вот так напишу. Я могу написать так. Это функция, которая просто возвращает t и
[08:36.360 --> 08:51.640]  значит deckLVal от t круглой скобочки, констракт deckLVal от args круглой скобочки. Это функция,
[08:51.640 --> 08:58.520]  которая возвращает t, и неважно как она реализована, потому что мы же ее не вызываем. Компилятор же
[08:58.520 --> 09:03.480]  лишь тип вычисляет, какое выражение получится. Поэтому на самом деле эту функцию можно и не
[09:03.480 --> 09:07.320]  реализовывать никак. Она никак не реализована. Значит на самом деле в стандартной библиотеке есть
[09:07.320 --> 09:14.880]  такая функция std deckLVal. Она просто содержит такое объявление для произвольного t, возвращает тип t,
[09:14.880 --> 09:21.600]  и никак не реализована. Попытка вызвать ее, это ошибка линкера. Но она не предназначена,
[09:21.600 --> 09:29.080]  чтобы ее вызывали, она предназначена, чтобы только под deckLType быть использована. Ну и последнее
[09:29.080 --> 09:41.360]  уточнение, это что здесь должно быть t2 амперсанда, а не просто t. Кто понимает почему? Что-что? Ну сегодня
[09:41.360 --> 09:48.920]  у вас, на самом деле я вам скажу так, вот последние две наших встречи сегодняшней в следующий раз,
[09:48.920 --> 09:55.720]  это окончательный гвоздь в крышку гроба, попытка убедить вас не писать на c++ окончательно,
[09:55.720 --> 10:00.960]  и проклянуть этот язык. Вот сегодня еще будет не совсем, но в следующий раз совсем. Так вы говорите,
[10:00.960 --> 10:13.640]  что это ваша любимая тема. Это моя любимая тема, потому что она как раз... Ну например по этому. Ну мои
[10:13.640 --> 10:22.800]  вкусы специфичны весьма. Впрочем, если вы прошли на продву, то наверное ваши тоже. Так,
[10:22.800 --> 10:41.040]  почему здесь t2 амперсанда, а не просто t? Да нет, никто не вызывается. Ничего вообще не вызывается,
[10:41.040 --> 10:57.400]  у нас только тип оценивается. Т может быть incomplete type. Что такое incomplete type? Это тип,
[10:57.400 --> 11:09.200]  который вообще не реализован. Или, например, t это может быть некоторый класс, который сам по
[11:09.200 --> 11:16.160]  себе шаблонный и его инстанцировать надо. Чем отличается t от t2 амперсанда? Тем, что ссылку на
[11:16.160 --> 11:23.600]  тип можно завести, не инстанцируя сам тип и даже не зная определение этого типа. А если бы мы просто
[11:23.600 --> 11:29.280]  t возвращали, то компилятору пришлось бы выяснять, что такое t. Как минимум компилятор бы требовал
[11:29.280 --> 11:33.600]  определение, и он попытался бы подставить в определение конкретные типы, которые у нас тут
[11:33.600 --> 11:43.600]  имеются. Мы с вами обсуждали, когда говорили про инстанцирование шаблонов в прошлый раз,
[11:43.600 --> 11:54.440]  что для получения ссылки на t не нужно знать определение t. Ссылка на t это всегда 8 байтов,
[11:54.440 --> 12:04.200]  всегда поинтер просто. Ну, для чего нужно узнавать t, чтобы понять его размер? Ну,
[12:04.200 --> 12:11.440]  не единственное, там много для чего нужно узнавать. Но правило такое, что для того,
[12:11.440 --> 12:17.720]  чтобы компилировать выражение, в которое фигурировать тип t, нужно, чтобы компилятор знал
[12:17.720 --> 12:26.240]  определение t. Ну, вот так вот. А для ссылки не нужно. Ну, в частности, если у t нет определения,
[12:26.240 --> 12:32.680]  ну, если я просто написал там класс какой-то c точкой запятой, то вернуть из функции объект
[12:32.680 --> 12:38.120]  c это будет некорректным выражением, потому что t неопределен. А вернуть ссылку на t будет
[12:38.120 --> 12:41.960]  корректным выражением, потому что неопределен. Ну и что? Мы не требуем определения, мы требуем
[12:41.960 --> 12:48.400]  лишь объявления. Нет, это нормально, мы про это говорили, типа указатель или ссылка на t не
[12:48.400 --> 12:52.600]  требует знания определения типа. Определение типа может быть в какой-то другой там единиц
[12:52.600 --> 12:57.160]  трансляции, компилятор не будет туда лезть, он не будет искать определение типа, чтобы завести
[12:57.160 --> 13:19.480]  ссылку на него, это ему не нужно. Ну, например, да. Вот, почему возвращаем r-value ссылку? Потому
[13:19.480 --> 13:25.400]  что если бы возвращали l-value ссылку, то мы бы тип value нарушили. Ну, потому что мы хотим здесь
[13:25.400 --> 13:32.720]  получить объект t как r-value. Если бы мы l-value ссылку возвращали, мы бы получили l-value expression.
[13:32.720 --> 13:39.240]  В чем прикол возвращать r-value ссылку? В том, что мы получаем такой же вид value,
[13:39.240 --> 13:43.160]  как если бы возвращали просто t, но при этом не требуем определение t быть доступным.
[13:43.160 --> 13:53.160]  Нет, это r-value ссылка. Мы не принимаем t как аргумент, мы t явно указываем.
[13:53.160 --> 13:58.880]  Ну, t здесь не принимаемый аргумент, а возвращаемый тип.
[13:58.880 --> 14:03.000]  Как мы решили проблему с вызовом конструктора?
[14:03.000 --> 14:05.040]  Какого конструктора?
[14:05.040 --> 14:07.720]  Мы же все равно пишем d-col-val-a-t от...
[14:07.720 --> 14:13.320]  Нет, мы не требуем наличия конструктора сейчас. Мы говорим компилятору,
[14:13.320 --> 14:19.320]  проверь какой тип у этого выражения. Компилятор такой, хорошо, какой тип был бы,
[14:19.320 --> 14:24.520]  если бы я у результата d-col-val-a-t вызвал констракт. Что такое d-col-val-a-t?
[14:24.520 --> 14:33.360]  Это ссылка r-value на t, то есть тип этой штуки это t r-value. Тип t и категория выражения r-value.
[14:33.360 --> 14:40.880]  Дальше мне надо проверить, есть ли у него констракт. Но компилятору не нужно проверять,
[14:40.880 --> 14:44.360]  что у t есть какой-то конструктор. Он вызвал функцию, которая возвращает...
[14:44.360 --> 14:51.520]  Он увидел, что функция возвращает t 2A sando, и это означает, что ему не нужно проверять,
[14:51.520 --> 14:56.960]  что есть там еще какая-то версия, как это t создается. Что d-col-val никак не определена,
[14:56.960 --> 15:00.680]  это проблема не компилятора, а линковщика. Компилятор же он только типа проверяет,
[15:00.680 --> 15:02.680]  но d-col-val мы не вызываем.
[15:02.680 --> 15:09.080]  Непонятно еще раз, если мы заменим 2A sando на 1, что сломается?
[15:09.080 --> 15:15.680]  В случае, если бы t не имел определения, мы бы не могли использовать d-col-val для таких типов.
[15:15.680 --> 15:19.480]  Но конкретно в этом случае мы бы все равно не могли использовать вот эту конструкцию,
[15:19.480 --> 15:26.760]  потому что вызов констракта t требует определения t. Но если мы занимаемся профессиональным
[15:26.760 --> 15:31.640]  метапрограммированием, так сказать, где типы могут быть вполне себе без определений,
[15:31.640 --> 15:37.960]  просто какие-нибудь заглушки, то d-col-val можно вызывать даже не инстанцируя определение типа.
[15:37.960 --> 15:46.760]  Простая ссылка тоже не инстанцирует, но она портит width-value. Мы хотим,
[15:46.760 --> 15:55.760]  чтобы здесь был t, но не хотим, чтобы было доступно определение t. R-value ссылка,
[15:55.760 --> 16:00.880]  она сохраняет width-value такой же, как если бы просто t создали.
[16:00.880 --> 16:12.360]  Ну потому что я хочу здесь написать что-то в духе t, но я не могу написать t,
[16:12.360 --> 16:16.640]  потому что вдруг t нет конструктора по умолчанию. Что мне написать? Мне нужен
[16:16.640 --> 16:24.480]  какой-то expression, который мне дает готовый t, но из чего мне его взять? А вот такую функцию
[16:24.480 --> 16:30.280]  использовать d-col-val от t. Но если бы она начала l-value ссылку, то это было бы не совсем то же самое,
[16:30.640 --> 16:38.520]  потому что width-value был бы другой. Вдруг этот метод констракт, он определен только у r-value,
[16:38.520 --> 16:46.240]  а у l-value запрещен. Тогда d-col-val от t мне бы давал не совсем эквивалентную штуку,
[16:46.240 --> 16:53.440]  как если бы я просто t вызвал. Если я хочу l-value t, то я так и напишу d-col-val от t-ampersand.
[16:53.440 --> 16:59.840]  Тогда мне вернется, ну по правилам сворачивания ссылок, t-ampersand, 2-ampersand, то есть t-ampersand.
[16:59.840 --> 17:05.800]  Если я хочу l-value получить с помощью d-col-val, я могу это сделать. А если я d-col-val от t пишу,
[17:05.800 --> 17:12.640]  то я хочу получить r-value. Но такой r-value, который не требует инстанцирования самого t. То же самое
[17:12.640 --> 17:21.440]  d-col-val от arcs. Вам говорить, что вы еще в d-col-val забыли? TypeName t равно void? А что еще забыл? Ну
[17:21.440 --> 17:30.720]  accept? Ну на самом деле человек молодец, потому что посмотрел лекции. Что могу сказать, хвалю.
[17:30.720 --> 17:46.720]  Че, только с ватей в лекции посмотрел? Вот это кстати может быть, но это я не знаю.
[17:46.720 --> 17:58.120]  Ты тоже, значит, посмотрел лекции? Да, хорошо. Да, ну наверное add r-value reference, а не t-2-ampersand,
[17:58.120 --> 18:03.200]  потому что для void тогда это будет некорректно работать, да? Хорошо.
[18:03.200 --> 18:10.640]  Add r-value reference это просто, ну, обрабатывать отдельную ситуацию, когда void. Да. То есть это просто
[18:10.640 --> 18:24.160]  костыль для этой ситуации. Удобный язык программированный. Что? А когда мы проверяем, есть его локатор и метод
[18:24.160 --> 18:31.000]  констракта? Да. Или пытаться вызвать его от l-value выражение? Ведь когда мы в реальности вызываем
[18:31.000 --> 18:36.720]  констракт от l-value, почему мы проверяем от r-value? Я на самом деле не знаю, может там и от l-value
[18:36.720 --> 18:44.520]  проверяется. Ну я говорю это так скажем в учебных целях, то есть я объясняю как устроен d-col-val
[18:44.520 --> 18:51.160]  просто на этом примере. Может быть в случае локатора разумнее проверять так, да? А если мы просто сюда
[18:51.160 --> 18:57.560]  передадим именно, когда будем всех helper вызывать, просто ему в качестве шаблонного параметра
[18:57.560 --> 19:05.480]  от l-value дадим? Разве мы не получим как раз проверку для... Да, получим. Ну вот тогда нам в любом случае
[19:05.480 --> 19:13.160]  выгоднее написать так. Ну да, наверное да. Просто потому что мы снаружи можем, по умолчанию оно проверяет для r-value,
[19:13.160 --> 19:20.440]  но мы можем просто снаружи передать туда не t, а l-value и проверить конкретно для r-value. Ну да. То есть
[19:20.440 --> 19:30.520]  это просто более общая реализация, которая... Вот. Пару слов про d-col-val еще. Почему он так называется?
[19:30.520 --> 19:39.920]  Это может быть... Почему он так называется, понимаешь? Ну вы говорили. Ну я знаю, да, я много раз говорил,
[19:39.920 --> 19:47.320]  если б ты еще поза прошлого года лекции смотрел, ты бы представил как мне тяжело живется. Так это то же самое, что и t-col-val.
[19:47.480 --> 19:55.080]  Да, это как бы обратная к d-col-type операция. Смотрите, что такое... Почему d-col-val? Потому что это штука, которая
[19:55.080 --> 20:02.760]  по типу дает вам значение, а d-col-type по значению дает вам тип. Это как бы взаимно обратная... Ну вот. Я это сам, кстати,
[20:02.760 --> 20:08.920]  не сразу понял далеко, потому что кажется это такое не очень понятное название, но становится понятно, если вы
[20:08.920 --> 20:15.400]  немножко позанимаетесь шаблонным метапрограммированием. D-col-type это как бы штука, которая из мира значений
[20:15.640 --> 20:20.840]  переводит вас в мир типов, а d-col-val это штука, которая переводит вас обратно из мира типов в мир значений.
[20:20.840 --> 20:31.320]  При этом d-col-type это как бы метафункция, а d-col-val это функция в обычном понимании. Вот. Понятно, что таким же
[20:31.320 --> 20:37.720]  способом можно написать проверку из constructible, из convertible, из copy constructible, из move constructible,
[20:37.720 --> 20:43.080]  из... В общем, проверка того, что тип можно создать из чего-то другого, например, из constructible. Как
[20:43.080 --> 20:49.720]  написать? Таким же способом просто здесь нужно другое выражение. Вот. Теперь дальше. Из no throw move
[20:49.720 --> 20:54.520]  constructible. У нас была проблема, как написать из no throw move constructible. Напоминаю. У нас есть функция
[20:54.520 --> 21:02.200]  move of no accept, которая устроена так. Она принимает tm% и возвращается to conditional. Из no throw move
[21:02.200 --> 21:10.920]  constructible или не из td из copy constructible, тогда tm2m% иначе const tm%. Зачем нам нужна была
[21:10.920 --> 21:16.440]  функция move of no accept, а в векторе, когда мы перекладывали, чтобы если там move constructor
[21:16.440 --> 21:25.840]  не no accept, то мы бы копировали, а не move-али. Как написать из no throw move constructible? Наивный
[21:25.840 --> 21:34.960]  подход. Можно попробовать написать из move constructible и no accept от move constructor. Ну,
[21:35.000 --> 21:41.320]  от выражения вызова move конструктора. Но это неверно, потому что, если вы так напишете,
[21:41.320 --> 21:47.720]  у вас move конструктора может не быть, тогда это не скомпилируется. Вы не можете просто через
[21:47.720 --> 21:59.400]  и оператор no accept выразить из условия, что no throw move constructible. Ну, наивный подход к
[21:59.400 --> 22:05.280]  реализации из no throw move constructible. Какой? Написать это все равно, что из move constructible и,
[22:05.280 --> 22:15.800]  обычное и логическое, но accept от t, от std callval, от t круглые сковочки. Почему это неправильно?
[22:15.800 --> 22:21.560]  Потому что, если нету move конструктора, ну, если он delete, то это будет ce, потому что
[22:21.560 --> 22:38.160]  конъюнкция работает так, что правая часть пусть и не вычисляется, если первая ложная, но она все
[22:38.160 --> 22:45.720]  же компилируется. То есть из move constructible false, потому что нет move конструктора. А дальше
[22:45.720 --> 22:52.560]  написано и, но accept от move конструктора. Но логическая конъюнкция, она short-circuit,
[22:52.560 --> 22:56.200]  но это не значит, что она не пытается проверить корректность на компилируемость вторую часть.
[22:56.200 --> 23:01.480]  Она не вычисляет вторую часть, если первая ложная, но она все же пытается скомпилировать
[23:01.480 --> 23:12.960]  вторую часть, если первая ложная. Что значит вычисляет с точки зрения компиля? Значит ничего. Как будто
[23:12.960 --> 23:19.920]  пытается скомпилировать и вычислять, то тоже в терминах. Может быть, но тем не менее она пытается
[23:19.920 --> 23:40.440]  скомпилировать. В общем, а тут как бы вопрос в том, что почему бы нам не использовать
[23:40.440 --> 23:49.760]  стд конжанкшн, который у нас есть. А что ты напишешь под стд конжанкшн на втором? Стд конжанкшн,
[23:49.760 --> 23:54.320]  она принимает метафункт. Она должна принять штуку true type, то есть там должно быть что?
[23:54.320 --> 24:03.560]  Да, в стд конжанкшн нужно передать нечто, что является integral constant в каком-то смысле,
[24:03.560 --> 24:14.400]  что является full constant. Короче, так не получится. А как тогда? Ну вот так. То же самое. А где у меня
[24:14.400 --> 24:22.640]  это написано? Так, подождите. А где у меня изнофромов констрактибл? Ну понятно, что здесь написано,
[24:22.640 --> 24:28.080]  все то же самое я делаю. Просто я делаю изнофромов констрактибл helper от чего угодно,
[24:28.080 --> 24:33.360]  который false type возвращает, а также изнофромов констрактибл helper, который, ну например,
[24:33.360 --> 24:36.720]  это один из вариантов, как можно реализовать, который принимает первым аргументом int,
[24:36.720 --> 24:44.280]  а вторым аргументом по умолчанию принимает вот такую штуковину. Enableift от вот такого,
[24:44.280 --> 24:50.240]  запитая bool, равно true. Соответственно, если мы вызываем int mnc helper от int, он пытается идти
[24:50.240 --> 24:55.280]  сюда, пытается понять, что тут за второй аргумент. Если у него это не получается, он отваливается,
[24:55.280 --> 25:00.120]  идет в эту версию, которая false type. Ну это как вариант, можно и по-другому реализовать, в общем.
[25:00.120 --> 25:13.040]  Ну и самая вкуснятина это из базов. Кто досмотрел это из базов? Отлично. Значит,
[25:13.040 --> 25:37.600]  вот это самая вкуснятина. Ох, не надо, пожалуйста, Илья, не пугай. It's T++ time.
[25:37.600 --> 25:51.840]  Я думаю, как бы это рассказать вкратце. В общем, ну хорошо, вот мы хотим написать проверку,
[25:51.840 --> 25:57.280]  что тип является наследником один другого. Значит, давайте...
[25:57.280 --> 26:16.680]  Ну короче, что я хочу сделать? Я вот это сейчас закомментирую. Давайте быстренько,
[26:16.680 --> 26:23.440]  все-таки я освещу, как работает из базов. То есть, наивная реализация из базов такая. Я
[26:23.440 --> 26:39.920]  делаю из базов helper от одного шаблонного аргумента. Вот. Сейчас. Нет, кажется, не так.
[26:39.920 --> 26:53.640]  Здесь не от нуля надо, а вот. А вот. Declval от D звездочки, от null, от круглых скобочек,
[26:53.640 --> 27:02.480]  по-моему, так, да. Сейчас, я уже забыл, как там это делалось в самом начале. Ну короче, идея в
[27:02.480 --> 27:08.160]  чем? Я хочу проверить, правда ли один тип наследник другого. Я пишу из базов, но это,
[27:08.160 --> 27:12.560]  во-первых, conjunction, что первый является классом, второй является классом, и вот дальше самое
[27:12.560 --> 27:20.080]  интересное. Я пишу из базов helper, которому отдаю указатель на D. А у меня есть две версии
[27:20.080 --> 27:27.120]  базов helper. Один принимает указатель на B, а другой принимает что угодно. И первый возвращает true
[27:27.120 --> 27:38.520]  type, а второй возвращает false type. Что я этим добиваюсь? Если D наследник B, то, ну, в любом
[27:38.520 --> 27:44.240]  случае предпочтительно вот эта версия. Но если D наследник B, то эта версия подходит, а иначе она
[27:44.240 --> 27:54.440]  просто не подходит. Правильно? Значит, если D наследник B, то выбирается эта версия, потому что
[27:54.440 --> 28:00.960]  лучше вызваться от B звездочки, если вызвали от D звездочки, чем от чего угодно другого. А она
[28:00.960 --> 28:08.040]  возвращает true type. Если D не наследник B, то эта версия просто не подходит. Ну, она просто вообще
[28:08.040 --> 28:14.240]  не является кандидатом на перегрузку, потому что D звездочка не кастится к B звездочки, не подходит
[28:14.240 --> 28:22.640]  эта версия. Значит, выбирается эта версия и поэтому false type. Так? Вроде нормально, но какая здесь
[28:22.640 --> 28:35.360]  проблема? В каком случае это будет не работать? Ну, даже не множественное. Приватное наследование.
[28:35.360 --> 28:44.640]  Если наследование приватное, то такая реализация даст CE. Почему? Потому что проверка доступа
[28:44.640 --> 28:56.440]  после разрешения перегрузки. Пусть D от B унаследовано приватно, тогда первая версия предпочтительнее,
[28:56.440 --> 29:04.880]  потому что B звездочка-то это же, ну, да, подходит, но наследование приватное и мы упадем с ошибкой
[29:04.880 --> 29:10.080]  компиляции, нельзя скастить D звездочка к B звездочки. Эта версия не будет рассмотрена, потому что
[29:10.080 --> 29:16.640]  приватность проверяется после разрешения перегрузки. Напоминаю, кто забыл. Ну, идея первая, вспомнить,
[29:16.640 --> 29:21.760]  что мы уже в велосипеде из костылей и перестать с компилятором ругаться на эту комплектную функцию.
[29:21.760 --> 29:39.440]  Значит, как мы обходим эту проблему? А мы делаем еще один уровень индирекции. Мы делаем вот такую
[29:39.440 --> 29:51.040]  функцию. Тест из Бейзов, которая от Инта, и смотрите, что происходит. Тест из Бейзов от Инт,
[29:51.040 --> 30:00.040]  она возвращает декл-тайп от того, что вернула бы, ну, короче, она возвращает то, что вернула бы
[30:00.040 --> 30:10.160]  вот та функция. Мы в тест из Бейзов отдаем Инт, и версия от Инт возвращает тот тип,
[30:10.160 --> 30:19.120]  который бы вернула из Бейзов хелпер от D звездочки. Но это может отвалиться. Вот это вот выражение
[30:19.120 --> 30:26.640]  может быть некорректным по причине приватности. И это выражение может себе содержать ошибку
[30:26.640 --> 30:31.200]  компиляцию из-за приватности. Что тогда мы делаем? Значит, эта версия по сфинае нам не
[30:31.200 --> 30:37.680]  подходит. Значит, нам подходит другая версия, которая отчего угодно, а она возвращает true
[30:37.680 --> 30:46.920]  type. Почему true type? Да потому что D наследник B. Если мы попали сюда, это значит, что здесь было
[30:46.920 --> 30:53.360]  приватное наследование. Значит, мы отвалились там, потому что была приватная. Значит, мы должны
[30:53.360 --> 31:01.800]  сказать, да, это наследник. Вот. Я считаю, что это шедеврально. Я не знаю, как вы, но мне кажется,
[31:01.800 --> 31:09.480]  это просто прекрасно. По-моему, это просто шедевр. Вот. А что, кстати, с множественным
[31:09.480 --> 31:16.280]  наследованием? Да-да, можно сфоткать еще. А что с множественным наследованием? А то же самое.
[31:16.280 --> 31:22.320]  Множественность наследования, она тоже проверяется. Так случайно совпало, что множественность
[31:22.320 --> 31:26.080]  наследования, она тоже проверяется после выбора версии перегрузки. То есть, на самом деле, мы одним
[31:26.080 --> 31:32.120]  махом били двух зайцев. То есть, на самом деле, если у нас амбигиус приведения типа от D звёздочек
[31:32.120 --> 31:36.680]  к B звёздочке, если у нас было ромбовидное наследование, мы тоже решим эту же проблему,
[31:36.680 --> 31:44.920]  потому что мы тоже отвалимся здесь по причине ошиб компиляции вот именно здесь и попадем сюда,
[31:44.920 --> 31:52.240]  где ответ TrueType. Таким образом, Избейзов проверяет, отвечает да, в том числе в случае множественного
[31:52.240 --> 32:03.600]  и приватного наследования. Сейчас, почему в случае предпадного наследования мы не попадаем просто
[32:03.600 --> 32:14.600]  во второй Избейзов Хелпе? Потому что приватность проверяется после выбора версии. Ну,
[32:15.240 --> 32:20.840]  правила языка такие, мы их обсуждали. Это мы обсуждали в первом семестре, что мы сначала решаем
[32:20.840 --> 32:24.680]  какую версию вызвать, а потом проверяем доступ. Скорее вопрос, почему она вообще проверяется в Финаге.
[32:24.680 --> 32:33.480]  Кто проверяется? Нет, Финаге полноценно проверяет корректность вот этого выражения. Он проверяет
[32:33.480 --> 32:37.640]  полностью компилируемость вот этой штуки. Если это корректная штука, то он...
[32:37.640 --> 32:49.080]  Ну, то есть, не если. Он просто проверяет, корректно ли с точки зрения компиляции вот это вот выражение.
[32:49.080 --> 32:57.320]  Оно некорректно. Поэтому отваливаемся, идем сюда. Вот, ну и последнее, это Common Type. Что такое Common Type?
[32:57.320 --> 33:08.080]  Значит, это метафункция, которая выводит как бы общий, наименьший общий тип для данных N типов.
[33:08.080 --> 33:20.000]  Вот, что такое Common Type от N типов? Это Common Type от двух данных, от двух первых и от всех остальных.
[33:20.000 --> 33:25.520]  Да, ну то есть, в случае N типов легко сводится к случаю N-1 типа. Осталось ответить на вопрос,
[33:25.520 --> 33:30.360]  что такое Common Type от двух данных типов. Как вычисляется Common Type от двух данных типов?
[33:30.360 --> 33:36.800]  Не используете или используете? Ну, давай, ладно, давай остальные подумают. Значит, так сказать, это
[33:36.800 --> 33:42.120]  мой тоже любимый вопрос в зал. Как бы вы вычислили наименьший общий тип для двух данных типов?
[33:42.120 --> 33:52.320]  Ну, не LCH-ку, на самом деле там еще чуть хуже, да, но... А если попытаться там, типа, автопункция,
[33:52.320 --> 34:14.600]  которая... Да нет. Вот. Осознайте. Значит, осознайте все величие, всю прелесть того,
[34:14.600 --> 34:21.320]  к чему вы прикоснулись, только что. Значит, как нам понять общий тип для двух данных типов?
[34:21.320 --> 34:32.120]  Нам нужен некоторый expression, тип которого, и есть общий тип для двух данных типов. Да. Ну,
[34:32.120 --> 34:36.680]  у нас, к счастью, в языке уже есть некоторая конструкция, которая дает нам общий тип для
[34:36.680 --> 34:42.800]  двух данных типов. Это оператор знак вопроса двоеточия. Мы просто говорим, пусть тип это будет
[34:42.800 --> 34:49.680]  такой, как получился бы, если мы сделали decal type от знак вопроса двоеточия для двух данных типов.
[34:49.680 --> 34:55.360]  Тут написано true, потому что неважно какое-то выражение, нам важен тип того,
[34:55.360 --> 34:59.960]  что получилось. Значит, мы получаем общий тип для T1 и T2 вот таким способом.
[34:59.960 --> 35:03.920]  А если наследование приватное будет ничего сломаться?
[35:03.920 --> 35:11.800]  Сломается, конечно. Вот. Поэтому common type от двух типов, это просто, значит, то,
[35:11.800 --> 35:17.040]  какой тип возвращал бы оператор знак вопроса двоеточия от двух данных типов, а common type от
[35:17.040 --> 35:26.360]  T1 типов это просто сводится в common type от T1 типов. Легко. Вопрос можно ли это реализовать
[35:26.360 --> 35:41.640]  без использования оператора тернального? Это просто забавно, что какие-то нишевые операторы находят
[35:41.640 --> 36:00.920]  применение в каких-то таких более высоком уровне. Так, ну, в общем, умение писать такие тернавики
[36:00.920 --> 36:18.560]  никогда. Да, как я могу это прокомментировать? На самом деле это работает хуже, чем вы могли бы подумать,
[36:18.560 --> 36:27.440]  потому что, например, если у вас есть хуже, чем вы могли бы подумать, это не может работать. Нет,
[36:27.440 --> 36:34.320]  вы все еще недооцениваете масштабы. А если у вас, допустим, есть мама и есть сын и дочь,
[36:34.320 --> 36:48.280]  в общем, если у вас есть класс mother, класс son, класс daughter, и вы попробуете найти общий тип для
[36:48.280 --> 36:54.520]  сына и дочери, то вы не найдете его. Это будет CE. На самом деле STD common type тоже не может найти
[36:54.520 --> 37:00.640]  общий тип для двух данных. Для сына и дочери, если у них есть общая мама, он не найдет общий тип.
[37:00.640 --> 37:10.000]  STD common type тоже сделает CE. Ну, потому что это было изначально, что ему придется перебрать все
[37:10.000 --> 37:13.760]  существующие типы и понять, то есть компилятор, короче, не поддерживает такую структуру у себя,
[37:13.760 --> 37:20.400]  а он так не умеет, к сожалению. Вот, но вот если у вас общий тип для мамы и сына, то он скажет,
[37:20.400 --> 37:31.520]  что это мама. Вот. И наша реализация, она плоха еще тем, что корректность ее работы зависит от того,
[37:31.520 --> 37:36.280]  на каком месте мама стоит. Вот, смотрите, представьте, что я спросил common type от son,
[37:36.280 --> 37:42.440]  daughter и mother. Тогда это будет CE. А вот если бы я спросил общий тип от mother son и daughter,
[37:42.440 --> 37:47.320]  то это было бы mother. Почему? Да потому что я сначала вычислил common type от T1 T2,
[37:47.320 --> 37:54.040]  а потом только к нему добавил T3. Но если я упомянул маму последний, то для T1 T2 это уже будет CE.
[37:54.040 --> 38:00.720]  Разумеется, разработчики языка почитали, что такое поведение это нормально и выкатили этот продаж.
[38:00.720 --> 38:08.680]  Нет, разработчики языка, значит, на самом деле STD common type реализован сложнее, и там эта проблема
[38:08.680 --> 38:15.520]  устранена. То есть там сделано так, что неважно на каком месте вы укажете mother. По-моему, я надеюсь.
[38:15.520 --> 38:22.800]  По-моему. Вот, но есть и другая причина, по которой decal type реализован не так.
[38:22.800 --> 38:33.760]  Мне кажется, что там кто-то храпится. Да.
[38:45.520 --> 38:57.240]  Когда я в 4 часа утра заканчивал делать алгосы, Вася все еще их писал. Может его разбудить все-таки,
[38:57.240 --> 39:01.160]  но как-то просто нехорошо. Нет, я не против, чтобы он спал, но просто звук отвлекает.
[39:01.160 --> 39:08.560]  Ну просто ты очень громко храпишь, даже я слышу отсюда. Я не против, чтобы ты спал,
[39:08.560 --> 39:27.160]  но ты хотя бы вот так ляг, чтобы мы не слышали. Ладно, хорошо. Да, в общем STD common type реализован не так, а вот так.
[39:27.160 --> 39:43.440]  STD decay это штука, которая убирает амперсанды и разрушает массивы до
[39:43.440 --> 39:57.920]  поинтров, это мы уже обсуждали неоднократно. В общем, помимо проблемы, о которой я сказал,
[39:57.920 --> 40:07.280]  что важно на каком месте стоит, собственно, искомый type, есть еще одна проблема. Возможно,
[40:07.280 --> 40:17.080]  она здесь не упомянута. Илья, такое поведение, что он не умеет интеллектуальные случаи обрабатывать,
[40:17.080 --> 40:23.720]  это по стандарту или это просто капиллятор не умеет? Не, по стандарту. А то есть по стандарту он проверяет,
[40:23.720 --> 40:29.920]  только если они прям один, жестко наследник другого? Нет, common type он пригождается, когда вы,
[40:29.920 --> 40:35.720]  например, у вас есть in, double, char, float, тогда common type будет double. Это типа,
[40:36.040 --> 40:42.040]  к которому они все могут привестись. Если из данных типов существует тип, которому они все умеют
[40:42.040 --> 40:47.360]  приводиться, то он его найдет. Это не обязательно наследование, это может быть что угодно. Наследование
[40:47.360 --> 40:55.400]  частней лучшей, да. А вот у нас же там, ну, можно какие-то алгоритмы написать на типах,
[40:55.400 --> 41:03.760]  а что, нельзя там написать какой-нибудь там, ну, реальный LCA написать? Ну, к сожалению, нельзя. Ну вот,
[41:03.760 --> 41:11.280]  я, слушайте, наблюдая за тенденциями развития C++, я, в принципе, допускаю, что когда-нибудь это станет,
[41:11.280 --> 41:18.640]  что это вскоре станет можно, потому что можешь внести пропузал в комитет, хотя, я думаю, уже кто-нибудь
[41:18.640 --> 41:25.040]  вносил. Ну, короче, пока нельзя. Ну, так вот, почему-то решил комитет по стандартизации. Ну, так же работает.
[41:25.040 --> 41:30.160]  Почему, и чего не делается в строительных комплятах? Что нельзя было бы не высокого уровня, не на
[41:30.160 --> 41:35.000]  высоком уровне это реализовывать? Я не знаю, так исторически сложилось, я ничего не могу сказать
[41:35.160 --> 41:52.040]  по этому поводу. Ну, вот так вот. Ладно, короче, давайте я не буду, поскольку мы все равно, типа, я обещал не закапываться в
[41:52.040 --> 41:58.000]  подробности, я не буду сейчас вот это вот все обсуждать, почему тут так и почему реализация вот так устроена.
[41:58.000 --> 42:06.720]  Короче, по некоторым причинам реализация через тернарный оператор, она плоха, и вот, в общем, тут нужно
[42:06.720 --> 42:13.000]  некоторые дополнительные надстройки. Ну, ладно, бог с ним. Вот, напоследок, давайте обсудим концепты.
[42:13.000 --> 42:17.000]  Напоследок.
[42:17.000 --> 42:36.640]  Класс. Да, уж, конечно, напоследок это такое. По-хорошему, на концепты бы неплохо бы и две пары занять,
[42:36.640 --> 42:45.720]  так сказать, не грех, но... Так, сейчас. По-моему, есть прикол, что концепты рассказали где-то в базе,
[42:45.720 --> 42:58.600]  уже. Ну, ничего страшного. Нет, научиться пользоваться концептами не сложно.
[42:58.600 --> 43:26.440]  Сейчас, ладно, ну, короче, давайте я открою просто файлик концепты. Там много изменений,
[43:26.440 --> 43:45.600]  так, а давайте я вот так просто сделаю. А, концепт 2, все, отлично, вот уж я не думал. Смотрите,
[43:45.600 --> 43:53.920]  какая история. C++20 вводит замечательное ключевое слово requires. Почему-то у меня его не подсвечивает
[43:53.920 --> 44:11.800]  vim, что печально. Это довольно печально, да. Ну ладно. Да, это штука, которая в C++20 пришла на замену
[44:11.800 --> 44:20.680]  enableif на самом деле. Вот, и на самом деле enableif, ну, в большинстве мест подобных все еще используется
[44:20.680 --> 44:27.960]  enableif, потому что на C++20, как вы понимаете, все переходят не сразу. Я думаю, еще ближайшие лет 5,
[44:27.960 --> 44:37.600]  какое там 5, если у нас сейчас много кто пишет, даже на 17-й не перешел. Ну, короче, ну, не знаю,
[44:37.600 --> 44:43.560]  ну, ближайшие лет 5 точно, я думаю, еще enableif будет в ходу. Но постепенно люди начинают переходить
[44:43.560 --> 44:52.080]  на более человеческий синтаксис. В C++20 люди поняли, что вообще-то можно придумать наконец нормальную
[44:52.080 --> 44:59.240]  синтаксическую конструкцию проверки того, что тип допускает какие-то операции. И не писать вот
[44:59.240 --> 45:04.160]  эту вот хрень, вот эту вот enableif, шаблонный параметр какой-то, совершенно сумасшедшая вещь.
[45:04.160 --> 45:08.200]  Раз уж мы все равно это умеем писать, давайте просто введем нормальную синтаксическую конструкцию,
[45:08.200 --> 45:12.040]  чтобы это делать. И такая синтаксичная конструкция появилась, называется requires,
[45:12.040 --> 45:18.640]  requires-keyword. Мне кажется, будет проще открыть просто на себе переференс ее. Ну, то есть,
[45:18.640 --> 45:26.080]  по-хорошему я должен был на это целую пару потратить, но раз уж мы все равно, так сказать,
[45:26.080 --> 45:42.920]  speedrun делаем, то... Не, я хотел speedrun именно. Вот, что такое requires? Это штука,
[45:42.920 --> 45:48.160]  которая позволяет вам... Блин, тут все только на примере концептов показано, к сожалению.
[45:56.080 --> 46:08.200]  Ну, не на примере концептов, давайте я вам покажу. Я могу написать requires от какого-то типа,
[46:08.200 --> 46:25.600]  там, от s, x, и здесь написать какие-то операции над x. Это expression. Ну,
[46:25.640 --> 46:32.200]  я могу вот так сказать. Сейчас мне не скомпилируется, наверное, по какой-нибудь причине. Так,
[46:32.200 --> 46:55.440]  извините. Чего? Нет, структура
[46:55.440 --> 47:05.120]  это не expression, нет. Я так обожаю твои синтоксические вопросы каждый раз,
[47:05.120 --> 47:15.800]  ближе к концу года обычно. Сейчас, структура... Что? Это не expression, это объявление, declaration.
[47:15.800 --> 47:19.880]  Что? После объявления структуры ставится точка, после объявления функции не ставится. Ну,
[47:19.880 --> 47:42.280]  такой синтоксис, что поделаешь? Так, минус std равна c++20. Блин, жалко, что я, конечно, не... Ну,
[47:42.280 --> 48:10.600]  да, вот. Сейчас, чёрт. Сейчас, я не понял, почему вот это ничего не вывело.
[48:12.280 --> 48:21.560]  Не, не, requires я хочу. А, concepts2. Всё, я понял.
[48:21.560 --> 48:51.520]  Нет, нет, нет, это не работает. Я ощущение, что он не научился пока. Так. Ну, короче,
[48:51.520 --> 49:00.080]  что такое requires? Requires это штука, это expression. Requires expression. У вас есть ключевое слово
[49:00.080 --> 49:05.920]  requires, после чего вы можете в скобках как бы принять некоторые аргументы как функцию, а дальше
[49:05.920 --> 49:11.600]  некоторые написать набор экспрешенов, и ваш requires вернёт вам true, если это корректные
[49:11.600 --> 49:22.360]  экспрешены всё были. И false вернёт, если не корректные. Да, если они не скомпилировались.
[49:22.360 --> 49:33.320]  Не знаю, почему. Так, давайте я попробую вот здесь-то написать. Вот у меня структура s.
[49:33.320 --> 49:59.000]  Значит, что? А я не буду. Ну вот, допустим, так я напишу. И точки запятой не хватает. Так,
[49:59.000 --> 50:06.800]  всё равно не работает. Да что ж такое-то? Что, я не умею пользоваться requires
[50:06.800 --> 50:31.240]  expression? Да вы чего хоть. Господи. А, ну видимо это только в шаблонах, что ли, можно делать. Ну-ка.
[50:31.240 --> 50:48.320]  Давайте-ка я сделаю шаблонную функцию. Сейчас. Template type name t. Avoid f. И вот тут я сделаю вот так.
[50:48.320 --> 51:06.280]  Requires от t. Вот, плюс плюс x. И теперь я, значит, вот допустим верну это из функции. И здесь я выведу
[51:06.280 --> 51:14.720]  сначала f с шаблонным параметром int, а потом выведу f с шаблонным параметром s.
[51:19.200 --> 51:38.880]  Ну и у стрим само собой сейчас подключим. Господи. Нет. Вот, ну теперь это скомпилировалось и теперь я
[51:38.880 --> 51:46.840]  утверждаю, что вот первый вызов вернет true, а второй false. Да, ну, значит, это может только с
[51:46.840 --> 51:56.200]  шаблонными типами делать. С конкретным типом, видите, он не справился. Ну, ему, видимо, надо,
[51:56.200 --> 52:02.760]  чтобы это было мета, чтобы t был переменным типом, а если я подставил конкретный, ну так работает.
[52:02.760 --> 52:07.440]  Значит, да, я опять должен сделать disclaimer, который я делал в прошлом году. Он, в принципе, остался в
[52:07.440 --> 52:16.120]  силе, что мало кто этим умеет совершенствовать пользу в самом числе я. И на самом деле тут,
[52:16.120 --> 52:21.840]  возможно, неочевидные баги, которые даже разработчики компиляторов пока не в курсе о них. Поэтому если
[52:21.840 --> 52:28.440]  вдруг вы увидите странное поведение в этих концептах или Requires, возможно, это не вы, глупые,
[52:28.440 --> 52:33.160]  возможно, это ошибка компилятора или, возможно, это ошибка разработчиков стандарта, что они не
[52:33.160 --> 52:42.280]  предусмотрели это. То есть это, как бы, достаточно новая фича, чтобы она была прям идеально всеми
[52:42.280 --> 52:50.440]  протестирована и проверена, как она работает. А что это? А это какой-то тракедий, что ли? Вот. Что такое
[52:50.440 --> 52:56.280]  Requires Expression? Это штука, которая проверяет, допустим, для вашего типа вот такие операции. В том
[52:56.280 --> 53:03.320]  числе здесь можно написать вызов какого-нибудь метода от вашего x, там, констракт, например,
[53:03.320 --> 53:06.800]  создание чего-нибудь другого. То есть здесь можно написать произвольный набор экспрешенов.
[53:06.800 --> 53:12.420]  Выражение Requires вернет вам true или false в зависимости от того, корректны ли все эти выражения. Вот. Но это не
[53:12.420 --> 53:17.760]  все, что она умеет проверять. Она умеет проверять еще более сложные констрейнты. Это называют
[53:17.760 --> 53:25.800]  констрейнты. Да. Ну, во-первых, есть Simple Requirements. Это вот то, что я сейчас сделал. Значит, это просто
[53:25.800 --> 53:31.560]  проверка того, что такие экспрешены корректны. Вот. Или, например, Swap, что вот так можно сделать,
[53:31.560 --> 53:38.520]  что экспрешены корректны. Дальше могут быть Type Requirements. И это проверка того, что данный тип
[53:38.520 --> 53:46.160]  существует и корректен. Например, я могу написать TypeName вот так. Это не Expression. Тем не менее,
[53:46.160 --> 53:51.480]  я могу написать просто вот так и точка с запятой. И это будет проверка того, что такой тип существует
[53:51.480 --> 53:57.600]  и корректен. Я могу написать вот так TypeName какой-то шаблонный класс подставлен T. И он
[53:57.600 --> 54:04.440]  проинстанцирует и проверит, что подстановка T корректна. Вот. Это Type Requirements. Дальше Compound
[54:04.440 --> 54:15.560]  Requirements. Я могу написать, что... Пропустим эту часть. Nested Requirements. Ну, вернемся,
[54:15.560 --> 54:27.880]  когда я расскажу, что такое Concept. Nested Requirements. Я могу написать... Ну, скажем,
[54:27.880 --> 54:41.800]  внутри Requires еще какой-то Requires. Или я могу написать, скажем, что некоторые операции
[54:41.800 --> 54:51.280]  является noexcept. Ну, короче, очень много всего я могу написать. Просто я не прошу вас это учить,
[54:51.280 --> 54:59.920]  я просто показываю вам, сколько всего добавили нового C++20. Это Requires Expression. Понятно,
[54:59.920 --> 55:06.480]  Requires Expression. Штука, которая позволяет вам проверить, корректны ли данные выражения или данные
[55:06.480 --> 55:13.200]  типы, или выполняются ли некоторые Compile Time условия относительно них. А теперь Concepts. И вот
[55:13.200 --> 55:24.080]  это самое главное. Что такое Concepts? К сожалению, меня не подсвечивает Vim, потому что я, видимо,
[55:24.080 --> 55:29.680]  обновлял, переустанавливал все, и он ключевое слово Concepts Requires не знает пока. Что такое Concept?
[55:29.680 --> 55:37.000]  Это новая сущность вообще в языке, наряду с типами, с классами, с шаблонами. Это новый
[55:37.000 --> 55:46.800]  вид сущности. Concept — это некоторый, как бы, множество типов. Что такое Concept? Concept — это такая
[55:46.800 --> 55:55.480]  сущность, которая отражает идею набора типов. Вот про тип можно ответить, он относится к данному
[55:55.480 --> 56:01.280]  концепту или нет. Он представляет собой данный концепт или нет. Например, я могу ввести такой
[56:01.280 --> 56:10.640]  Concept Input Iterator. Вот. Что такое Input Iterator? А я могу сказать, например, Input Iterator — это такая
[56:10.640 --> 56:16.400]  штука, которая позволяет себя инкейментировать и разыминовывать. И как я это могу написать? Я
[56:16.400 --> 56:34.960]  могу сказать, template typeNameT Concept Input Iterator равно... Здесь я могу написать либо какое-то
[56:34.960 --> 56:40.320]  булевское выражение относительно, ну, либо метафункцию относительно T. Ну, вот, как, например,
[56:40.320 --> 56:48.060]  здесь я написал Concept Polymorphic. Polymorphic — это некоторый концепт, который говорит,
[56:48.060 --> 56:52.600]  что тип является полиморфным. У меня уже есть метафункция из Polymorphic V, которая приведает
[56:52.600 --> 56:56.840]  сущность, что тип является полиморфным. И я могу просто эту метафункцию сюда впендюрить. Я могу,
[56:56.840 --> 57:02.560]  то есть, булевское выражение написать здесь. Concept Input Iterator равно и некоторый булевский
[57:02.560 --> 57:10.680]  expression от T, как бы, метафункция. У меня получится Concept Polymorphic. А могу написать requires,
[57:10.680 --> 57:17.920]  ну, что, в общем-то, тоже булевское выражение. Я могу написать requires и здесь сказать разыминовать
[57:17.920 --> 57:22.760]  x и plus plus x, допустим. Вот, это то, что должен иметь мой Input Iterator. Ну, на самом деле он должен
[57:22.760 --> 57:30.080]  иметь еще что-то, но, допустим, для простоты, что Input Iterator только это должен иметь. Теперь
[57:30.080 --> 57:46.080]  мой Input Iterator это некоторый вид типов. Такой, что я могу его передавать функции. Я могу его
[57:46.080 --> 57:52.840]  использовать как шаблонный параметр. Ну, вот, что я могу сделать? Я могу говорить template и не как
[57:52.840 --> 58:00.480]  раньше писать type name Input Iterator, потому что это был костыль. Вот, вы согласны с тем, что это был
[58:00.480 --> 58:07.960]  некоторый ужасный костыль. Мы, когда в алгоритмы передавали итераторы, мы костыляли название типов,
[58:07.960 --> 58:14.680]  специально название шаблонных параметров, чтобы они отражали суть. У нас в стд, ну, у нас в алгоритме,
[58:14.680 --> 58:22.200]  в заголовочном файле алгоритм, все алгоритмы принимают type name и этот type name особенным
[58:22.200 --> 58:27.960]  образом называется, в зависимости от того, какой итератор они ожидают. То есть, там, например,
[58:27.960 --> 58:33.560]  stdsort ожидает random access итератор, и поэтому там type name random access итератор. Хотя, по факту,
[58:33.560 --> 58:38.800]  мы можем отдать туда не random access итератор, и название типа не будет отражать суть того,
[58:38.800 --> 58:44.240]  что туда передали. Это был костыль, с которым мы жили очень долго. Так вот, наконец, концепты,
[58:44.240 --> 58:53.120]  они эту проблему решают. Теперь мы не названием отражаем суть того, что передаем, а как бы самим
[58:53.120 --> 58:58.600]  шаблонным параметром мы говорим, что теперь мы в шаблон передаем не просто какой-то type name,
[58:58.600 --> 59:05.080]  а именно std input итератор. Ну, std input итератор это просто вот стандартный концепт, который
[59:05.080 --> 59:12.720]  одержит в себе requires то, что input итератор должен уметь. Я могу сказать template и здесь написать
[59:12.720 --> 59:22.320]  input итератор. Вот мой input итератор. Итер. Господи. Теперь input итератор это концепт,
[59:22.320 --> 59:32.000]  а итер это название типа. И вот сюда я уже принял итер. И если я в эту функцию в качестве параметра
[59:32.000 --> 59:37.600]  отдам не input итератор, то есть такой тип, который не удовлетворяет требованиям к input итератору,
[59:37.600 --> 59:43.040]  я получу ошибку в компиляции. Не что там на 25 строке я пытаюсь выполнить операцию,
[59:43.040 --> 59:49.280]  которая не разрешена, а что нарушен концепт, нарушен requires. Ты пытаешь создать функцию,
[59:49.280 --> 59:57.160]  которая принимает input итератор, тип, который не является input итератором. И это очень круто.
[59:57.160 --> 01:00:04.600]  То есть мы теперь на типы можем накладывать ограничения, вот эти вот, говорящие о том,
[01:00:04.600 --> 01:00:30.120]  какой именно тип мы ожидаем получить на вход. А вот вопрос. Есть условный input итератор,
[01:00:30.120 --> 01:00:36.640]  можно ли как-то через концепту наложить более сильное примчение, что input итератор на
[01:00:36.640 --> 01:00:44.520]  какой-то тип, чтобы типа разыминование давало нужное? Конечно можно. Сейчас расскажу как так.
[01:00:44.520 --> 01:00:54.360]  Сейчас минутку. Что это шаблонный параметр концепта? Подожди минутку.
[01:00:54.360 --> 01:01:05.920]  Параметризировать концепт? Да, да, да. Ну, в смысле, чтобы концепт сам по себе был шаблонный.
[01:01:06.320 --> 01:01:12.360]  Может быть, это не все, или это очень шаблонная магия, может быть, что-то с вас?
[01:01:12.360 --> 01:01:21.200]  Мы концепт инсуцируем каким-то типом, который по себе содержит точно две точки в бэде.
[01:01:21.200 --> 01:01:36.120]  Я просто спрашиваю, как мы инсуцируем концепт чем? Концепт просто. В смысле, мы его инсуцируем,
[01:01:36.120 --> 01:01:44.800]  или мы типом, который содержит в себе? Нет, это будет выражение. Так, я отвлекся. Какой вопрос был?
[01:01:44.800 --> 01:01:52.960]  Можно ли дополнительно параметризировать концепт, чтобы можно было, понятно, что не так, но типа
[01:01:52.960 --> 01:01:57.680]  что-то наподобие input-интератор в уголовных скобочках сказать вот int и предполагать,
[01:01:57.680 --> 01:02:05.920]  что это будет концепт, который принимает input-интератор на int. Короче, шаблонный концепт.
[01:02:05.920 --> 01:02:17.480]  Сейчас, ты хочешь дополнительно к требованиям на input-интератор еще какое-то навесить требование?
[01:02:17.480 --> 01:02:26.280]  Я могу делать составные концепты, я могу сказать, да как же он меня достал-то. Я могу сказать,
[01:02:26.280 --> 01:02:34.520]  что это input-интератор и что-то еще. Мы хотим input-интератор, у которого звездочка возвращает U,
[01:02:34.520 --> 01:02:49.840]  и requires от t, x. Что? Звездочка возвращает t. Звездочка x. Compound requirement сейчас будет.
[01:02:49.840 --> 01:03:01.920]  Стрелочка is same as что надо. Стоп, стоп, стоп. Ну, я же вам показывал, что requirement-ы бывают вот
[01:03:01.920 --> 01:03:08.640]  такими. Я требую, чтобы звездочка x была convertible to, например, это. Или вот это выражение было
[01:03:08.640 --> 01:03:15.440]  same as такой же, как вот этот тип. А вот этот тип теперь хочется сделать типа не постоянным,
[01:03:15.440 --> 01:03:25.920]  короче, чтобы этот тип можно было как-то снаружи задавать для этого концепта. Ну,
[01:03:25.920 --> 01:03:30.440]  второй шаблонный параметр можно отдать сюда. И то есть мы явно будем указывать шаблонные
[01:03:30.440 --> 01:03:36.560]  аргументы концепта. Мы будем писать constant input-interaтор от одного типа, это подставится
[01:03:36.560 --> 01:03:44.360]  во второй аргумент, и то, что пойдет после этой штуки, подставится на первый. Я не очень понял
[01:03:44.360 --> 01:03:51.400]  сейчас, но возможно это правда. Было сказано, что явные шаблонные аргументы концепта подставляются
[01:03:51.400 --> 01:03:56.720]  во второй и так далее. Да, у тебя то, что идет после названия концепта, вот эта единственная штука,
[01:03:56.720 --> 01:04:03.160]  это подставится в качестве первого. То есть Сеня сказал, что если мы напишем constant input-interaтор
[01:04:03.160 --> 01:04:15.440]  в фигурных скобочках int, то u станет int, а не t. Ну да. Constant input-interaтор в угловых скобочках int?
[01:04:15.440 --> 01:04:24.960]  Да, то int поедет в u, а не в t. А, ну да, возможно. Ну, наверное, да. Это логично, потому что у нас
[01:04:24.960 --> 01:04:31.920]  же после этой штуки один только тип. Я не уверен на 100%, но возможно, что да. У нас же в концепте
[01:04:31.920 --> 01:04:45.600]  может быть там 3-4 параметра. Так, а можно шаблонно принимать концепт? Что? Ну, чтобы шаблонным параметром был какой-то концепт.
[01:04:45.600 --> 01:04:49.800]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:49.800 --> 01:04:49.820]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:49.820 --> 01:04:50.640]  Нет, нет, нет. Концепт.
[01:04:50.640 --> 01:04:50.660]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:50.660 --> 01:04:50.680]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:50.680 --> 01:04:50.700]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:50.700 --> 01:04:50.720]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:50.720 --> 01:04:51.220]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:51.220 --> 01:04:51.720]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:51.720 --> 01:04:52.220]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:52.220 --> 01:04:52.720]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:52.720 --> 01:04:53.220]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:53.220 --> 01:04:53.720]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:53.720 --> 01:04:54.220]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:55.220 --> 01:04:55.720]  Тимплейт, импут-интератор, итер.
[01:04:55.720 --> 01:04:56.220]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:56.220 --> 01:04:56.720]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:56.720 --> 01:04:57.220]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:57.220 --> 01:04:57.720]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:57.720 --> 01:04:58.220]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:58.220 --> 01:04:58.720]  Я же только что это показывал. Вот. Тимплейт, импут-интератор, итер.
[01:04:59.220 --> 01:04:59.720]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:04:59.720 --> 01:05:00.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:00.220 --> 01:05:00.720]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:00.720 --> 01:05:01.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:01.220 --> 01:05:01.720]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:01.720 --> 01:05:02.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:02.220 --> 01:05:02.720]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:02.720 --> 01:05:03.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:03.720 --> 01:05:04.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:04.220 --> 01:05:04.720]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:04.720 --> 01:05:05.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:05.220 --> 01:05:05.720]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:05.720 --> 01:05:06.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:06.220 --> 01:05:06.720]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:06.720 --> 01:05:07.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:07.220 --> 01:05:07.720]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:08.220 --> 01:05:08.720]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:08.720 --> 01:05:09.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:09.220 --> 01:05:09.720]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:09.720 --> 01:05:10.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:10.220 --> 01:05:10.720]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:10.720 --> 01:05:11.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:11.220 --> 01:05:11.720]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:11.720 --> 01:05:12.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:12.220 --> 01:05:14.220]  Так вот же написано. Тимплейт, импут-интератор, итер.
[01:05:42.220 --> 01:05:44.220]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:44.220 --> 01:05:44.720]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:44.720 --> 01:05:45.220]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:45.220 --> 01:05:45.720]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:45.720 --> 01:05:46.220]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:46.220 --> 01:05:46.720]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:46.720 --> 01:05:47.220]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:47.220 --> 01:05:47.720]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:47.720 --> 01:05:48.220]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:48.220 --> 01:05:48.720]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:48.720 --> 01:05:49.220]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:49.220 --> 01:05:49.720]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:49.720 --> 01:05:50.220]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:50.220 --> 01:05:50.720]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:50.720 --> 01:05:51.220]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:51.220 --> 01:05:51.720]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:51.720 --> 01:05:52.220]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:52.220 --> 01:05:52.720]  Ты когда писал, там, стрейнт, импут-интератор.
[01:05:52.720 --> 01:05:54.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:05:54.720 --> 01:05:55.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:05:55.220 --> 01:05:55.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:05:55.720 --> 01:05:56.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:05:56.220 --> 01:05:56.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:05:56.720 --> 01:05:57.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:05:57.220 --> 01:05:57.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:05:57.720 --> 01:05:58.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:05:58.220 --> 01:05:58.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:05:58.720 --> 01:05:59.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:05:59.220 --> 01:05:59.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:05:59.720 --> 01:06:00.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:00.720 --> 01:06:01.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:01.220 --> 01:06:01.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:29.720 --> 01:06:30.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:30.220 --> 01:06:30.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:30.720 --> 01:06:31.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:31.220 --> 01:06:31.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:31.720 --> 01:06:32.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:32.220 --> 01:06:32.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:32.720 --> 01:06:33.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:33.220 --> 01:06:33.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:33.720 --> 01:06:34.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:34.220 --> 01:06:34.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:34.720 --> 01:06:35.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:35.220 --> 01:06:36.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:36.220 --> 01:06:36.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:36.720 --> 01:06:37.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:37.220 --> 01:06:37.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:37.720 --> 01:06:38.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:38.220 --> 01:06:38.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:38.720 --> 01:06:39.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:39.220 --> 01:06:39.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:39.720 --> 01:06:40.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:40.220 --> 01:06:40.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:40.720 --> 01:06:41.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:41.220 --> 01:06:41.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:41.720 --> 01:06:42.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:42.220 --> 01:06:42.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:42.720 --> 01:06:43.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:43.220 --> 01:06:43.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:43.720 --> 01:06:44.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:44.220 --> 01:06:44.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:44.720 --> 01:06:45.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:45.220 --> 01:06:45.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:45.720 --> 01:06:46.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:46.220 --> 01:06:46.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:46.720 --> 01:06:47.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:47.220 --> 01:06:47.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:47.720 --> 01:06:48.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:48.220 --> 01:06:48.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:48.720 --> 01:06:49.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:49.220 --> 01:06:49.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:49.720 --> 01:06:50.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:50.220 --> 01:06:50.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:50.720 --> 01:06:51.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:51.220 --> 01:06:51.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:51.720 --> 01:06:52.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:52.220 --> 01:06:52.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:52.720 --> 01:06:53.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:53.220 --> 01:06:53.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:53.720 --> 01:06:54.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:54.220 --> 01:06:54.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:54.720 --> 01:06:55.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:55.220 --> 01:06:55.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:55.720 --> 01:06:56.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:56.220 --> 01:06:56.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:56.720 --> 01:06:57.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:57.220 --> 01:06:57.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:57.720 --> 01:06:58.220]  Синтаксис такой, типа, синтаксис реквариментов.
[01:06:58.220 --> 01:06:58.720]  Синтаксис такой, типа, синтаксис реквариментов.
[01:07:27.720 --> 01:07:29.720]  Не знаю, можно ли, но может быть и можно.
[01:07:29.720 --> 01:07:31.720]  Сейчас, а какой-нибудь написать enableif?t?
[01:07:31.720 --> 01:07:35.720]  Нет, давай не будем смешивать концепты с enableif'ом, пожалуйста.
[01:07:35.720 --> 01:07:38.720]  Концепты придуманы, чтобы не писать enableif.
[01:07:41.720 --> 01:07:42.720]  Хорошо, а вот второй вопрос.
[01:07:42.720 --> 01:07:45.720]  Requires вычисляет как в compile или в run?
[01:07:45.720 --> 01:07:46.720]  Конечно!
[01:07:46.720 --> 01:07:49.720]  Естественно, в compile-time какой смысл иначе.
[01:07:49.720 --> 01:07:52.720]  А там была функция, которую...
[01:07:52.720 --> 01:07:56.720]  Ну, к самой первой ты показывал, где Require не в концептах.
[01:07:56.720 --> 01:07:58.720]  Да, и она просто отвалилась.
[01:07:58.720 --> 01:08:02.720]  То есть Require, если я делаю не от шаблонного аргумента, то значит он просто падает.
[01:08:02.720 --> 01:08:05.720]  Видимо, он не умеет не от шаблонного параметра вычисляться.
[01:08:07.720 --> 01:08:11.720]  То есть там писать Requires 2 plus 3 равно 5, это типа бог?
[01:08:11.720 --> 01:08:13.720]  Что Requires 2 plus 3?
[01:08:13.720 --> 01:08:15.720]  Requires 2 plus 3 равно равно 5.
[01:08:15.720 --> 01:08:17.720]  Нет, что значит синтаксически?
[01:08:17.720 --> 01:08:19.720]  Requires...
[01:08:20.720 --> 01:08:22.720]  Ааа, это кисатру.
[01:08:22.720 --> 01:08:23.720]  Ладно, да.
[01:08:23.720 --> 01:08:28.720]  После Requires ты должен написать экспрешены, которые будут проверены на корректность с точки зрения компиляции.
[01:08:28.720 --> 01:08:30.720]  А не на истинность, как булевские выражения.
[01:08:30.720 --> 01:08:33.720]  Окей, тогда писать статик ассет.
[01:08:33.720 --> 01:08:37.720]  Их концепт равно 1 plus 2 равно равно 3.
[01:08:37.720 --> 01:08:38.720]  Так можно.
[01:08:39.720 --> 01:08:40.720]  Просто булевский подеказ.
[01:08:40.720 --> 01:08:45.720]  Концепт чего-то там равно 1 plus 2 равно равно 3.
[01:08:45.720 --> 01:08:50.720]  Я не уверен, что так можно, потому что я не уверен, что любой булевский экспрешен A компилируется.
[01:08:50.720 --> 01:08:54.720]  Но дело в том, что после концепт можно писать не любое булевское выражение.
[01:08:54.720 --> 01:08:56.720]  Там есть какие-то ограничения, но я не помню какие.
[01:08:56.720 --> 01:09:02.720]  Ну да, ну компайл там вычиснимый, но кажется там еще какие-то есть дополнительные ограничения.
[01:09:04.720 --> 01:09:06.720]  Ну да, можно написать...
[01:09:06.720 --> 01:09:10.720]  Ну 1 plus 2 равно равно 3, наверное, можно, потому что это тривиально.
[01:09:10.720 --> 01:09:15.720]  Я могу написать концепт trivial равно true, и это будет всегда истинный концепт.
[01:09:16.720 --> 01:09:21.720]  Но соответственно, вот что такое compound requirements, я раньше сказал, что мы пропустим эту часть.
[01:09:21.720 --> 01:09:22.720]  Теперь мы к ней вернемся.
[01:09:22.720 --> 01:09:23.720]  Собственно, вот это и есть оно.
[01:09:23.720 --> 01:09:28.720]  Я могу для данного экспрешена проверить, что это не просто корректный экспрешен или корректный тип.
[01:09:28.720 --> 01:09:31.720]  А что этот экспрешен сам удовлетворяет некоторому концепту.
[01:09:31.720 --> 01:09:35.720]  Вот std convertible2 это концепт тоже, например.
[01:09:35.720 --> 01:09:37.720]  Что такое convertible2?
[01:09:38.720 --> 01:09:50.720]  Это на самом деле std из convertible2, а также еще дополнительное требование, что requires, короче, что from еще static cast допускает.
[01:09:54.720 --> 01:09:58.720]  Это корректность вот такого экспрешена, компилируемость вот такого экспрешена.
[01:09:58.720 --> 01:09:59.720]  Вот.
[01:10:01.720 --> 01:10:06.720]  Значит, на самом деле в библиотеке стандартных концептов есть много чего.
[01:10:06.720 --> 01:10:08.720]  Например, вот есть концепт std same as.
[01:10:09.720 --> 01:10:21.720]  Это как same, как is same, только с дополнительными.
[01:10:21.720 --> 01:10:22.720]  Это корректный экспрешен.
[01:10:22.720 --> 01:10:23.720]  Это корректный экспрешен.
[01:10:23.720 --> 01:10:24.720]  Это корректный экспрешен.
[01:10:24.720 --> 01:10:25.720]  Это корректный экспрешен.
[01:10:25.720 --> 01:10:26.720]  Это корректный экспрешен.
[01:10:26.720 --> 01:10:27.720]  Это корректный экспрешен.
[01:10:27.720 --> 01:10:28.720]  Это корректный экспрешен.
[01:10:28.720 --> 01:10:29.720]  Это корректный экспрешен.
[01:10:29.720 --> 01:10:30.720]  Это корректный экспрешен.
[01:10:30.720 --> 01:10:31.720]  Это корректный экспрешен.
[01:10:31.720 --> 01:10:32.720]  Это корректный экспрешен.
[01:10:32.720 --> 01:10:33.720]  Это корректный экспрешен.
[01:10:33.720 --> 01:10:34.720]  Это корректный экспрешен.
[01:10:34.720 --> 01:10:35.720]  Это корректный экспрешен.
[01:10:35.720 --> 01:10:36.720]  Это корректный экспрешен.
[01:10:36.720 --> 01:10:37.720]  Это корректный экспрешен.
[01:10:37.720 --> 01:10:38.720]  Это корректный экспрешен.
[01:10:38.720 --> 01:10:39.720]  Это корректный экспрешен.
[01:10:39.720 --> 01:10:40.720]  Это корректный экспрешен.
[01:10:40.720 --> 01:10:41.720]  Это корректный экспрешен.
[01:10:41.720 --> 01:10:42.720]  Это корректный экспрешен.
[01:10:42.720 --> 01:10:43.720]  Это корректный экспрешен.
[01:10:43.720 --> 01:10:44.720]  Это корректный экспрешен.
[01:10:44.720 --> 01:10:45.720]  Это корректный экспрешен.
[01:10:45.720 --> 01:10:46.720]  Это корректный экспрешен.
[01:10:46.720 --> 01:10:47.720]  Это корректный экспрешен.
[01:10:47.720 --> 01:10:48.720]  Это корректный экспрешен.
[01:10:48.720 --> 01:10:49.720]  Это корректный экспрешен.
[01:10:49.720 --> 01:10:50.720]  Это корректный экспрешен.
[01:10:50.720 --> 01:10:51.720]  Это корректный экспрешен.
[01:10:51.720 --> 01:10:52.720]  Это корректный экспрешен.
[01:10:52.720 --> 01:10:53.720]  Это корректный экспрешен.
[01:10:53.720 --> 01:10:54.720]  Это корректный экспрешен.
[01:10:54.720 --> 01:10:55.720]  Это корректный экспрешен.
[01:10:55.720 --> 01:10:56.720]  Это корректный экспрешен.
[01:10:56.720 --> 01:10:57.720]  Это корректный экспрешен.
[01:10:57.720 --> 01:10:58.720]  Это корректный экспрешен.
[01:10:58.720 --> 01:10:59.720]  Это корректный экспрешен.
[01:10:59.720 --> 01:11:00.720]  Это корректный экспрешен.
[01:11:00.720 --> 01:11:01.720]  Это корректный экспрешен.
[01:11:01.720 --> 01:11:02.720]  Это корректный экспрешен.
[01:11:02.720 --> 01:11:03.720]  Это корректный экспрешен.
[01:11:03.720 --> 01:11:04.720]  Это корректный экспрешен.
[01:11:04.720 --> 01:11:05.720]  Это корректный экспрешен.
[01:11:05.720 --> 01:11:06.720]  Это корректный экспрешен.
[01:11:06.720 --> 01:11:07.720]  Это корректный экспрешен.
[01:11:07.720 --> 01:11:08.720]  Это корректный экспрешен.
[01:11:08.720 --> 01:11:09.720]  Это корректный экспрешен.
[01:11:09.720 --> 01:11:10.720]  Это корректный экспрешен.
[01:11:10.720 --> 01:11:11.720]  Это корректный экспрешен.
[01:11:12.720 --> 01:11:13.720]  Это корректный экспрешен.
[01:11:13.720 --> 01:11:14.720]  Это корректный экспрешен.
[01:11:14.720 --> 01:11:15.720]  Это корректный экспрешен.
[01:11:15.720 --> 01:11:16.720]  Это корректный экспрешен.
[01:11:16.720 --> 01:11:17.720]  Это корректный экспрешен.
[01:11:17.720 --> 01:11:18.720]  Это корректный экспрешен.
[01:11:18.720 --> 01:11:19.720]  Это корректный экспрешен.
[01:11:19.720 --> 01:11:20.720]  Это корректный экспрешен.
[01:11:20.720 --> 01:11:21.720]  Это корректный экспрешен.
[01:11:21.720 --> 01:11:22.720]  Это корректный экспрешен.
[01:11:22.720 --> 01:11:23.720]  Это корректный экспрешен.
[01:11:23.720 --> 01:11:24.720]  Это корректный экспрешен.
[01:11:24.720 --> 01:11:25.720]  Это корректный экспрешен.
[01:11:25.720 --> 01:11:26.720]  Это корректный экспрешен.
[01:11:26.720 --> 01:11:27.720]  Это корректный экспрешен.
[01:11:27.720 --> 01:11:28.720]  Это корректный экспрешен.
[01:11:28.720 --> 01:11:29.720]  Это корректный экспрешен.
[01:11:29.720 --> 01:11:30.720]  Это корректный экспрешен.
[01:11:30.720 --> 01:11:31.720]  Это корректный экспрешен.
[01:11:31.720 --> 01:11:32.720]  Это корректный экспрешен.
[01:11:32.720 --> 01:11:33.720]  Это корректный экспрешен.
[01:11:33.720 --> 01:11:34.720]  Это корректный экспрешен.
[01:11:34.720 --> 01:11:35.720]  Это корректный экспрешен.
[01:11:35.720 --> 01:11:36.720]  Это корректный экспрешен.
[01:11:36.720 --> 01:11:37.720]  Это корректный экспрешен.
[01:11:37.720 --> 01:11:38.720]  Это корректный экспрешен.
[01:11:38.720 --> 01:11:39.720]  Это корректный экспрешен.
[01:11:39.720 --> 01:11:40.720]  Это корректный экспрешен.
[01:11:40.720 --> 01:11:41.720]  Это корректный экспрешен.
[01:11:41.720 --> 01:11:42.720]  Это корректный экспрешен.
[01:11:42.720 --> 01:11:43.720]  Это корректный экспрешен.
[01:11:43.720 --> 01:11:44.720]  Это корректный экспрешен.
[01:11:44.720 --> 01:11:45.720]  Это корректный экспрешен.
[01:11:45.720 --> 01:11:46.720]  Это корректный экспрешен.
[01:11:46.720 --> 01:11:47.720]  Это корректный экспрешен.
[01:11:47.720 --> 01:11:48.720]  Это корректный экспрешен.
[01:11:48.720 --> 01:11:49.720]  Это корректный экспрешен.
[01:11:49.720 --> 01:11:50.720]  Это корректный экспрешен.
[01:11:50.720 --> 01:11:51.720]  Это корректный экспрешен.
[01:11:51.720 --> 01:11:52.720]  Это корректный экспрешен.
[01:11:52.720 --> 01:11:53.720]  Это корректный экспрешен.
[01:11:53.720 --> 01:11:54.720]  Это корректный экспрешен.
[01:11:54.720 --> 01:11:55.720]  Это корректный экспрешен.
[01:11:55.720 --> 01:11:56.720]  Это корректный экспрешен.
[01:11:56.720 --> 01:11:57.720]  Это корректный экспрешен.
[01:11:57.720 --> 01:11:58.720]  Это корректный экспрешен.
[01:11:58.720 --> 01:11:59.720]  Это корректный экспрешен.
[01:11:59.720 --> 01:12:00.720]  Это корректный экспрешен.
[01:12:00.720 --> 01:12:01.720]  Это корректный экспрешен.
[01:12:01.720 --> 01:12:02.720]  Это корректный экспрешен.
[01:12:02.720 --> 01:12:03.720]  Это корректный экспрешен.
[01:12:03.720 --> 01:12:04.720]  Это корректный экспрешен.
[01:12:04.720 --> 01:12:05.720]  Это корректный экспрешен.
[01:12:05.720 --> 01:12:06.720]  Это корректный экспрешен.
[01:12:06.720 --> 01:12:07.720]  Это корректный экспрешен.
[01:12:07.720 --> 01:12:08.720]  Это корректный экспрешен.
[01:12:08.720 --> 01:12:09.720]  Это корректный экспрешен.
[01:12:09.720 --> 01:12:10.720]  Это корректный экспрешен.
[01:12:10.720 --> 01:12:11.720]  Это корректный экспрешен.
[01:12:11.720 --> 01:12:12.720]  Это корректный экспрешен.
[01:12:12.720 --> 01:12:13.720]  Это корректный экспрешен.
[01:12:13.720 --> 01:12:14.720]  Это корректный экспрешен.
[01:12:14.720 --> 01:12:15.720]  Это корректный экспрешен.
[01:12:15.720 --> 01:12:16.720]  Это корректный экспрешен.
[01:12:16.720 --> 01:12:17.720]  Это корректный экспрешен.
[01:12:17.720 --> 01:12:18.720]  Это корректный экспрешен.
[01:12:18.720 --> 01:12:19.720]  Это корректный экспрешен.
[01:12:19.720 --> 01:12:20.720]  Это корректный экспрешен.
[01:12:20.720 --> 01:12:21.720]  Это корректный экспрешен.
[01:12:21.720 --> 01:12:22.720]  Это корректный экспрешен.
[01:12:22.720 --> 01:12:23.720]  Это корректный экспрешен.
[01:12:23.720 --> 01:12:24.720]  Это корректный экспрешен.
[01:12:24.720 --> 01:12:25.720]  Это корректный экспрешен.
[01:12:25.720 --> 01:12:26.720]  Это корректный экспрешен.
[01:12:26.720 --> 01:12:27.720]  Это корректный экспрешен.
[01:12:27.720 --> 01:12:28.720]  Это корректный экспрешен.
[01:12:28.720 --> 01:12:29.720]  Это корректный экспрешен.
[01:12:29.720 --> 01:12:30.720]  Это корректный экспрешен.
[01:12:30.720 --> 01:12:31.720]  Это корректный экспрешен.
[01:12:31.720 --> 01:12:32.720]  Это корректный экспрешен.
[01:12:32.720 --> 01:12:33.720]  Это корректный экспрешен.
[01:12:33.720 --> 01:12:34.720]  Это корректный экспрешен.
[01:12:34.720 --> 01:12:35.720]  Это корректный экспрешен.
[01:12:35.720 --> 01:12:36.720]  Это корректный экспрешен.
[01:12:36.720 --> 01:12:37.720]  Это корректный экспрешен.
[01:12:37.720 --> 01:12:38.720]  Это корректный экспрешен.
[01:12:38.720 --> 01:12:39.720]  Это корректный экспрешен.
[01:12:39.720 --> 01:12:40.720]  Это корректный экспрешен.
[01:12:40.720 --> 01:12:41.720]  Это корректный экспрешен.
[01:12:41.720 --> 01:12:42.720]  Это корректный экспрешен.
[01:12:42.720 --> 01:12:43.720]  Это корректный экспрешен.
[01:12:43.720 --> 01:12:44.720]  Это корректный экспрешен.
[01:12:44.720 --> 01:12:45.720]  Это корректный экспрешен.
[01:12:45.720 --> 01:12:46.720]  Это корректный экспрешен.
[01:12:46.720 --> 01:12:47.720]  Это корректный экспрешен.
[01:12:47.720 --> 01:12:48.720]  Это корректный экспрешен.
[01:12:48.720 --> 01:12:49.720]  Это корректный экспрешен.
[01:12:49.720 --> 01:12:50.720]  Это корректный экспрешен.
[01:12:50.720 --> 01:12:51.720]  Это корректный экспрешен.
[01:12:51.720 --> 01:12:52.720]  Это корректный экспрешен.
[01:12:52.720 --> 01:12:53.720]  Это корректный экспрешен.
[01:12:53.720 --> 01:12:54.720]  Это корректный экспрешен.
[01:12:54.720 --> 01:12:55.720]  Это корректный экспрешен.
[01:12:55.720 --> 01:12:56.720]  Это корректный экспрешен.
[01:12:56.720 --> 01:12:57.720]  Это корректный экспрешен.
[01:12:57.720 --> 01:12:58.720]  Это корректный экспрешен.
[01:12:58.720 --> 01:12:59.720]  Это корректный экспрешен.
[01:12:59.720 --> 01:13:00.720]  Это корректный экспрешен.
[01:13:00.720 --> 01:13:01.720]  Это корректный экспрешен.
[01:13:01.720 --> 01:13:02.720]  Это корректный экспрешен.
[01:13:02.720 --> 01:13:03.720]  Это корректный экспрешен.
[01:13:03.720 --> 01:13:04.720]  Это корректный экспрешен.
[01:13:04.720 --> 01:13:05.720]  Это корректный экспрешен.
[01:13:05.720 --> 01:13:06.720]  Это корректный экспрешен.
[01:13:06.720 --> 01:13:07.720]  Это корректный экспрешен.
[01:13:07.720 --> 01:13:08.720]  Это корректный экспрешен.
[01:13:08.720 --> 01:13:09.720]  Это корректный экспрешен.
[01:13:09.720 --> 01:13:10.720]  Это корректный экспрешен.
[01:13:10.720 --> 01:13:11.720]  Это корректный экспрешен.
[01:13:11.720 --> 01:13:12.720]  Это корректный экспрешен.
[01:13:12.720 --> 01:13:13.720]  Это корректный экспрешен.
[01:13:13.720 --> 01:13:14.720]  Это корректный экспрешен.
[01:13:14.720 --> 01:13:15.720]  Это корректный экспрешен.
[01:13:15.720 --> 01:13:16.720]  Это корректный экспрешен.
[01:13:16.720 --> 01:13:17.720]  Это корректный экспрешен.
[01:13:17.720 --> 01:13:18.720]  Это корректный экспрешен.
[01:13:18.720 --> 01:13:19.720]  Это корректный экспрешен.
[01:13:19.720 --> 01:13:20.720]  Это корректный экспрешен.
[01:13:20.720 --> 01:13:21.720]  Это корректный экспрешен.
[01:13:21.720 --> 01:13:22.720]  Это корректный экспрешен.
[01:13:22.720 --> 01:13:23.720]  Это корректный экспрешен.
[01:13:23.720 --> 01:13:24.720]  Это корректный экспрешен.
[01:13:24.720 --> 01:13:25.720]  Это корректный экспрешен.
[01:13:25.720 --> 01:13:26.720]  Это корректный экспрешен.
[01:13:26.720 --> 01:13:27.720]  Это корректный экспрешен.
[01:13:27.720 --> 01:13:28.720]  Это корректный экспрешен.
[01:13:28.720 --> 01:13:29.720]  Это корректный экспрешен.
[01:13:29.720 --> 01:13:30.720]  Это корректный экспрешен.
[01:13:30.720 --> 01:13:31.720]  Это корректный экспрешен.
[01:13:31.720 --> 01:13:32.720]  Это корректный экспрешен.
[01:13:32.720 --> 01:13:33.720]  Это корректный экспрешен.
[01:13:33.720 --> 01:13:34.720]  Это корректный экспрешен.
[01:13:34.720 --> 01:13:35.720]  Это корректный экспрешен.
[01:13:35.720 --> 01:13:36.720]  Это корректный экспрешен.
[01:13:36.720 --> 01:13:37.720]  Это корректный экспрешен.
[01:13:37.720 --> 01:13:38.720]  Это корректный экспрешен.
[01:13:38.720 --> 01:13:39.720]  Это корректный экспрешен.
[01:13:39.720 --> 01:13:40.720]  Это корректный экспрешен.
[01:13:40.720 --> 01:13:41.720]  Это корректный экспрешен.
[01:13:41.720 --> 01:13:42.720]  Это корректный экспрешен.
[01:13:42.720 --> 01:13:43.720]  Это корректный экспрешен.
[01:13:43.720 --> 01:13:44.720]  Это корректный экспрешен.
[01:13:44.720 --> 01:13:45.720]  Это корректный экспрешен.
[01:13:45.720 --> 01:13:46.720]  Это корректный экспрешен.
[01:13:46.720 --> 01:13:47.720]  Это корректный экспрешен.
[01:13:47.720 --> 01:13:48.720]  Это корректный экспрешен.
[01:13:48.720 --> 01:13:49.720]  Это корректный экспрешен.
[01:13:49.720 --> 01:13:50.720]  Это корректный экспрешен.
[01:13:50.720 --> 01:13:51.720]  Это корректный экспрешен.
[01:13:51.720 --> 01:13:52.720]  Это корректный экспрешен.
[01:13:52.720 --> 01:13:53.720]  Это корректный экспрешен.
[01:13:53.720 --> 01:13:54.720]  Это корректный экспрешен.
[01:13:54.720 --> 01:13:55.720]  Это корректный экспрешен.
[01:13:55.720 --> 01:13:56.720]  Это корректный экспрешен.
[01:13:56.720 --> 01:13:57.720]  Это корректный экспрешен.
[01:13:57.720 --> 01:13:58.720]  Это корректный экспрешен.
[01:13:58.720 --> 01:13:59.720]  Это корректный экспрешен.
[01:13:59.720 --> 01:14:00.720]  Это корректный экспрешен.
[01:14:00.720 --> 01:14:01.720]  Это корректный экспрешен.
[01:14:01.720 --> 01:14:02.720]  Это корректный экспрешен.
[01:14:02.720 --> 01:14:03.720]  Это корректный экспрешен.
[01:14:03.720 --> 01:14:04.720]  Это корректный экспрешен.
[01:14:04.720 --> 01:14:05.720]  Это корректный экспрешен.
[01:14:05.720 --> 01:14:06.720]  Это корректный экспрешен.
[01:14:06.720 --> 01:14:07.720]  Это корректный экспрешен.
[01:14:07.720 --> 01:14:08.720]  Это корректный экспрешен.
[01:14:08.720 --> 01:14:09.720]  Это корректный экспрешен.
[01:14:09.720 --> 01:14:10.720]  Это корректный экспрешен.
[01:14:10.720 --> 01:14:11.720]  Это корректный экспрешен.
[01:14:11.720 --> 01:14:12.720]  Это корректный экспрешен.
[01:14:12.720 --> 01:14:13.720]  Это корректный экспрешен.
[01:14:13.720 --> 01:14:14.720]  Это корректный экспрешен.
[01:14:14.720 --> 01:14:15.720]  Это корректный экспрешен.
[01:14:15.720 --> 01:14:16.720]  Это корректный экспрешен.
[01:14:16.720 --> 01:14:17.720]  Это корректный экспрешен.
[01:14:17.720 --> 01:14:18.720]  Это корректный экспрешен.
[01:14:18.720 --> 01:14:19.720]  Это корректный экспрешен.
[01:14:19.720 --> 01:14:20.720]  Это корректный экспрешен.
[01:14:20.720 --> 01:14:21.720]  Это корректный экспрешен.
[01:14:21.720 --> 01:14:22.720]  Это корректный экспрешен.
[01:14:22.720 --> 01:14:23.720]  Это корректный экспрешен.
[01:14:23.720 --> 01:14:24.720]  Это корректный экспрешен.
[01:14:24.720 --> 01:14:25.720]  Это корректный экспрешен.
[01:14:25.720 --> 01:14:26.720]  Это корректный экспрешен.
[01:14:26.720 --> 01:14:27.720]  Это корректный экспрешен.
[01:14:27.720 --> 01:14:28.720]  Это корректный экспрешен.
[01:14:28.720 --> 01:14:29.720]  Это корректный экспрешен.
[01:14:29.720 --> 01:14:30.720]  Это корректный экспрешен.
[01:14:30.720 --> 01:14:31.720]  Это корректный экспрешен.
[01:14:31.720 --> 01:14:32.720]  Это корректный экспрешен.
[01:14:32.720 --> 01:14:33.720]  Это корректный экспрешен.
[01:14:33.720 --> 01:14:34.720]  Это корректный экспрешен.
[01:14:34.720 --> 01:14:35.720]  Это корректный экспрешен.
[01:14:35.720 --> 01:14:36.720]  Это корректный экспрешен.
[01:14:36.720 --> 01:14:37.720]  Это корректный экспрешен.
[01:14:37.720 --> 01:14:38.720]  Это корректный экспрешен.
[01:14:38.720 --> 01:14:39.720]  Это корректный экспрешен.
[01:14:39.720 --> 01:14:40.720]  Это корректный экспрешен.
[01:14:40.720 --> 01:14:41.720]  Это корректный экспрешен.
[01:14:41.720 --> 01:14:42.720]  Это корректный экспрешен.
[01:14:42.720 --> 01:14:43.720]  Это корректный экспрешен.
[01:14:43.720 --> 01:14:44.720]  Это корректный экспрешен.
[01:14:44.720 --> 01:14:45.720]  Это корректный экспрешен.
[01:14:45.720 --> 01:14:46.720]  Это корректный экспрешен.
[01:14:46.720 --> 01:14:47.720]  Это корректный экспрешен.
[01:14:47.720 --> 01:14:48.720]  Это корректный экспрешен.
[01:14:48.720 --> 01:14:49.720]  Это корректный экспрешен.
[01:14:49.720 --> 01:14:50.720]  Это корректный экспрешен.
[01:14:50.720 --> 01:14:51.720]  Это корректный экспрешен.
[01:14:51.720 --> 01:14:52.720]  Это корректный экспрешен.
[01:14:52.720 --> 01:14:53.720]  Это корректный экспрешен.
[01:14:53.720 --> 01:14:54.720]  Это корректный экспрешен.
[01:14:54.720 --> 01:14:55.720]  Это корректный экспрешен.
[01:14:55.720 --> 01:14:56.720]  Это корректный экспрешен.
[01:14:56.720 --> 01:14:57.720]  Это корректный экспрешен.
[01:14:57.720 --> 01:14:58.720]  Это корректный экспрешен.
[01:14:58.720 --> 01:14:59.720]  Это корректный экспрешен.
[01:14:59.720 --> 01:15:00.720]  Это корректный экспрешен.
[01:15:00.720 --> 01:15:01.720]  Это корректный экспрешен.
[01:15:01.720 --> 01:15:02.720]  Это корректный экспрешен.
[01:15:02.720 --> 01:15:03.720]  Это корректный экспрешен.
[01:15:03.720 --> 01:15:04.720]  Это корректный экспрешен.
[01:15:04.720 --> 01:15:05.720]  Это корректный экспрешен.
[01:15:05.720 --> 01:15:06.720]  Это корректный экспрешен.
[01:15:06.720 --> 01:15:07.720]  Это корректный экспрешен.
[01:15:07.720 --> 01:15:08.720]  Это корректный экспрешен.
[01:15:08.720 --> 01:15:09.720]  Это корректный экспрешен.
[01:15:09.720 --> 01:15:10.720]  Это корректный экспрешен.
[01:15:10.720 --> 01:15:11.720]  Это корректный экспрешен.
[01:15:11.720 --> 01:15:12.720]  Это корректный экспрешен.
[01:15:12.720 --> 01:15:13.720]  Это корректный экспрешен.
[01:15:13.720 --> 01:15:14.720]  Это корректный экспрешен.
[01:15:14.720 --> 01:15:15.720]  Это корректный экспрешен.
[01:15:15.720 --> 01:15:16.720]  Это корректный экспрешен.
[01:15:16.720 --> 01:15:17.720]  Это корректный экспрешен.
[01:15:17.720 --> 01:15:18.720]  Это корректный экспрешен.
[01:15:18.720 --> 01:15:19.720]  Это корректный экспрешен.
[01:15:19.720 --> 01:15:20.720]  Это корректный экспрешен.
[01:15:20.720 --> 01:15:21.720]  Это корректный экспрешен.
[01:15:21.720 --> 01:15:22.720]  Это корректный экспрешен.
[01:15:22.720 --> 01:15:23.720]  Это корректный экспрешен.
[01:15:23.720 --> 01:15:24.720]  Это корректный экспрешен.
[01:15:24.720 --> 01:15:25.720]  Это корректный экспрешен.
[01:15:25.720 --> 01:15:26.720]  Это корректный экспрешен.
[01:15:26.720 --> 01:15:27.720]  Это корректный экспрешен.
[01:15:27.720 --> 01:15:28.720]  Это корректный экспрешен.
[01:15:28.720 --> 01:15:29.720]  Это корректный экспрешен.
[01:15:29.720 --> 01:15:30.720]  Это корректный экспрешен.
[01:15:30.720 --> 01:15:31.720]  Это корректный экспрешен.
[01:15:32.720 --> 01:15:33.720]  Это корректный экспрешен.
[01:15:33.720 --> 01:15:34.720]  Это корректный экспрешен.
[01:15:34.720 --> 01:15:35.720]  Это корректный экспрешен.
[01:15:35.720 --> 01:15:36.720]  Это корректный экспрешен.
[01:15:36.720 --> 01:15:37.720]  Это корректный экспрешен.
[01:15:37.720 --> 01:15:38.720]  Это корректный экспрешен.
[01:15:38.720 --> 01:15:39.720]  Это корректный экспрешен.
[01:15:39.720 --> 01:15:40.720]  Это корректный экспрешен.
[01:15:40.720 --> 01:15:41.720]  Это корректный экспрешен.
[01:15:41.720 --> 01:15:42.720]  Это корректный экспрешен.
[01:15:42.720 --> 01:15:43.720]  Это корректный экспрешен.
[01:15:43.720 --> 01:15:44.720]  Это корректный экспрешен.
[01:15:44.720 --> 01:15:45.720]  Это корректный экспрешен.
[01:15:45.720 --> 01:15:46.720]  Это корректный экспрешен.
[01:15:46.720 --> 01:15:47.720]  Это корректный экспрешен.
[01:15:47.720 --> 01:15:48.720]  Это корректный экспрешен.
[01:15:48.720 --> 01:15:49.720]  Это корректный экспрешен.
[01:15:49.720 --> 01:15:50.720]  Это корректный экспрешен.
[01:15:50.720 --> 01:15:51.720]  Это корректный экспрешен.
[01:15:51.720 --> 01:15:52.720]  Это корректный экспрешен.
[01:15:52.720 --> 01:15:53.720]  Это корректный экспрешен.
[01:15:53.720 --> 01:15:54.720]  Это корректный экспрешен.
[01:15:54.720 --> 01:15:55.720]  Это корректный экспрешен.
[01:15:55.720 --> 01:15:56.720]  Это корректный экспрешен.
[01:15:56.720 --> 01:15:57.720]  Это корректный экспрешен.
[01:15:57.720 --> 01:15:58.720]  Это корректный экспрешен.
[01:15:58.720 --> 01:15:59.720]  Это корректный экспрешен.
[01:15:59.720 --> 01:16:00.720]  Это корректный экспрешен.
[01:16:00.720 --> 01:16:01.720]  Это корректный экспрешен.
[01:16:01.720 --> 01:16:02.720]  Это корректный экспрешен.
[01:16:02.720 --> 01:16:03.720]  Это корректный экспрешен.
[01:16:03.720 --> 01:16:04.720]  Это корректный экспрешен.
[01:16:04.720 --> 01:16:05.720]  Это корректный экспрешен.
[01:16:05.720 --> 01:16:06.720]  Это корректный экспрешен.
[01:16:06.720 --> 01:16:07.720]  Это корректный экспрешен.
[01:16:07.720 --> 01:16:08.720]  Это корректный экспрешен.
[01:16:08.720 --> 01:16:09.720]  Это корректный экспрешен.
[01:16:09.720 --> 01:16:10.720]  Это корректный экспрешен.
[01:16:10.720 --> 01:16:11.720]  Это корректный экспрешен.
[01:16:11.720 --> 01:16:12.720]  Это корректный экспрешен.
[01:16:12.720 --> 01:16:13.720]  Это корректный экспрешен.
[01:16:13.720 --> 01:16:14.720]  Это корректный экспрешен.
[01:16:14.720 --> 01:16:15.720]  Это корректный экспрешен.
[01:16:15.720 --> 01:16:16.720]  Это корректный экспрешен.
[01:16:16.720 --> 01:16:17.720]  Это корректный экспрешен.
[01:16:17.720 --> 01:16:18.720]  Это корректный экспрешен.
[01:16:18.720 --> 01:16:19.720]  Это корректный экспрешен.
[01:16:19.720 --> 01:16:20.720]  Это корректный экспрешен.
[01:16:20.720 --> 01:16:21.720]  Это корректный экспрешен.
[01:16:21.720 --> 01:16:22.720]  Это корректный экспрешен.
[01:16:22.720 --> 01:16:23.720]  Это корректный экспрешен.
[01:16:23.720 --> 01:16:24.720]  Это корректный экспрешен.
[01:16:24.720 --> 01:16:25.720]  Это корректный экспрешен.
[01:16:25.720 --> 01:16:26.720]  Это корректный экспрешен.
[01:16:26.720 --> 01:16:27.720]  Это корректный экспрешен.
[01:16:27.720 --> 01:16:28.720]  Это корректный экспрешен.
[01:16:28.720 --> 01:16:29.720]  Это корректный экспрешен.
[01:16:29.720 --> 01:16:30.720]  Это корректный экспрешен.
[01:16:30.720 --> 01:16:31.720]  Это корректный экспрешен.
[01:16:31.720 --> 01:16:32.720]  Это корректный экспрешен.
[01:16:32.720 --> 01:16:33.720]  Это корректный экспрешен.
[01:16:33.720 --> 01:16:34.720]  Это корректный экспрешен.
[01:16:34.720 --> 01:16:35.720]  Это корректный экспрешен.
[01:16:35.720 --> 01:16:36.720]  Это корректный экспрешен.
[01:16:36.720 --> 01:16:37.720]  Это корректный экспрешен.
[01:16:37.720 --> 01:16:38.720]  Это корректный экспрешен.
[01:16:38.720 --> 01:16:39.720]  Это корректный экспрешен.
[01:16:39.720 --> 01:16:40.720]  Это корректный экспрешен.
[01:16:40.720 --> 01:16:41.720]  Это корректный экспрешен.
[01:16:41.720 --> 01:16:42.720]  Это корректный экспрешен.
[01:16:42.720 --> 01:16:43.720]  Это корректный экспрешен.
[01:16:43.720 --> 01:16:44.720]  Это корректный экспрешен.
[01:16:44.720 --> 01:16:45.720]  Это корректный экспрешен.
[01:16:45.720 --> 01:16:46.720]  Это корректный экспрешен.
[01:16:46.720 --> 01:16:47.720]  Это корректный экспрешен.
[01:16:47.720 --> 01:16:48.720]  Это корректный экспрешен.
[01:16:48.720 --> 01:16:49.720]  Это корректный экспрешен.
[01:16:49.720 --> 01:16:50.720]  Это корректный экспрешен.
[01:16:50.720 --> 01:16:51.720]  Это корректный экспрешен.
[01:16:51.720 --> 01:16:52.720]  Это корректный экспрешен.
[01:16:52.720 --> 01:16:53.720]  Это корректный экспрешен.
[01:16:53.720 --> 01:16:54.720]  Это корректный экспрешен.
[01:16:54.720 --> 01:16:55.720]  Это корректный экспрешен.
[01:16:55.720 --> 01:16:56.720]  Это корректный экспрешен.
[01:16:56.720 --> 01:16:57.720]  Это корректный экспрешен.
[01:16:57.720 --> 01:16:58.720]  Это корректный экспрешен.
[01:16:58.720 --> 01:16:59.720]  Это корректный экспрешен.
[01:16:59.720 --> 01:17:00.720]  Это корректный экспрешен.
[01:17:00.720 --> 01:17:01.720]  Это корректный экспрешен.
[01:17:01.720 --> 01:17:02.720]  Это корректный экспрешен.
[01:17:03.720 --> 01:17:04.720]  Это корректный экспрешен.
[01:17:04.720 --> 01:17:05.720]  Это корректный экспрешен.
[01:17:05.720 --> 01:17:06.720]  Это корректный экспрешен.
[01:17:06.720 --> 01:17:07.720]  Это корректный экспрешен.
[01:17:07.720 --> 01:17:08.720]  Это корректный экспрешен.
[01:17:08.720 --> 01:17:09.720]  Это корректный экспрешен.
[01:17:09.720 --> 01:17:10.720]  Это корректный экспрешен.
[01:17:10.720 --> 01:17:11.720]  Это корректный экспрешен.
[01:17:11.720 --> 01:17:12.720]  Это корректный экспрешен.
[01:17:12.720 --> 01:17:13.720]  Это корректный экспрешен.
[01:17:13.720 --> 01:17:14.720]  Это корректный экспрешен.
[01:17:14.720 --> 01:17:15.720]  Это корректный экспрешен.
[01:17:15.720 --> 01:17:16.720]  Это корректный экспрешен.
[01:17:16.720 --> 01:17:17.720]  Это корректный экспрешен.
[01:17:17.720 --> 01:17:18.720]  Это корректный экспрешен.
[01:17:18.720 --> 01:17:19.720]  Это корректный экспрешен.
[01:17:19.720 --> 01:17:20.720]  Это корректный экспрешен.
[01:17:20.720 --> 01:17:21.720]  Это корректный экспрешен.
[01:17:21.720 --> 01:17:22.720]  Это корректный экспрешен.
[01:17:22.720 --> 01:17:23.720]  Это корректный экспрешен.
[01:17:23.720 --> 01:17:24.720]  Это корректный экспрешен.
[01:17:24.720 --> 01:17:25.720]  Это корректный экспрешен.
[01:17:25.720 --> 01:17:26.720]  Это корректный экспрешен.
[01:17:26.720 --> 01:17:27.720]  Это корректный экспрешен.
[01:17:27.720 --> 01:17:28.720]  Это корректный экспрешен.
[01:17:28.720 --> 01:17:29.720]  Это корректный экспрешен.
[01:17:29.720 --> 01:17:30.720]  Это корректный экспрешен.
[01:17:30.720 --> 01:17:31.720]  Это корректный экспрешен.
[01:17:31.720 --> 01:17:32.720]  Это корректный экспрешен.
[01:17:32.720 --> 01:17:33.720]  Это корректный экспрешен.
[01:17:33.720 --> 01:17:34.720]  Это корректный экспрешен.
[01:17:34.720 --> 01:17:35.720]  Это корректный экспрешен.
[01:17:35.720 --> 01:17:36.720]  Это корректный экспрешен.
[01:17:36.720 --> 01:17:37.720]  Это корректный экспрешен.
[01:17:37.720 --> 01:17:38.720]  Это корректный экспрешен.
[01:17:38.720 --> 01:17:39.720]  Это корректный экспрешен.
[01:17:39.720 --> 01:17:40.720]  Это корректный экспрешен.
[01:17:40.720 --> 01:17:41.720]  Это корректный экспрешен.
[01:17:41.720 --> 01:17:42.720]  Это корректный экспрешен.
[01:17:42.720 --> 01:17:43.720]  Это корректный экспрешен.
[01:17:43.720 --> 01:17:44.720]  Это корректный экспрешен.
[01:17:44.720 --> 01:17:45.720]  Это корректный экспрешен.
[01:17:45.720 --> 01:17:46.720]  Это корректный экспрешен.
[01:17:46.720 --> 01:17:47.720]  Это корректный экспрешен.
[01:17:47.720 --> 01:17:48.720]  Это корректный экспрешен.
[01:17:48.720 --> 01:17:49.720]  Это корректный экспрешен.
[01:17:49.720 --> 01:17:50.720]  Это корректный экспрешен.
[01:17:50.720 --> 01:17:51.720]  Это корректный экспрешен.
[01:17:51.720 --> 01:17:52.720]  Это корректный экспрешен.
[01:17:52.720 --> 01:17:53.720]  Это корректный экспрешен.
[01:17:53.720 --> 01:17:54.720]  Это корректный экспрешен.
[01:17:54.720 --> 01:17:55.720]  Это корректный экспрешен.
[01:17:55.720 --> 01:17:56.720]  Это корректный экспрешен.
[01:17:56.720 --> 01:17:57.720]  Это корректный экспрешен.
[01:17:57.720 --> 01:17:58.720]  Это корректный экспрешен.
[01:17:58.720 --> 01:17:59.720]  Это корректный экспрешен.
[01:17:59.720 --> 01:18:00.720]  Это корректный экспрешен.
[01:18:00.720 --> 01:18:01.720]  Это корректный экспрешен.
[01:18:01.720 --> 01:18:02.720]  Это корректный экспрешен.
[01:18:02.720 --> 01:18:03.720]  Это корректный экспрешен.
[01:18:03.720 --> 01:18:04.720]  Это корректный экспрешен.
[01:18:04.720 --> 01:18:05.720]  Это корректный экспрешен.
[01:18:05.720 --> 01:18:06.720]  Это корректный экспрешен.
[01:18:06.720 --> 01:18:07.720]  Это корректный экспрешен.
[01:18:07.720 --> 01:18:08.720]  Это корректный экспрешен.
[01:18:08.720 --> 01:18:09.720]  Это корректный экспрешен.
[01:18:09.720 --> 01:18:10.720]  Это корректный экспрешен.
[01:18:10.720 --> 01:18:11.720]  Это корректный экспрешен.
[01:18:11.720 --> 01:18:12.720]  Это корректный экспрешен.
[01:18:12.720 --> 01:18:13.720]  Это корректный экспрешен.
[01:18:13.720 --> 01:18:14.720]  Это корректный экспрешен.
[01:18:14.720 --> 01:18:15.720]  Это корректный экспрешен.
[01:18:15.720 --> 01:18:16.720]  Это корректный экспрешен.
[01:18:16.720 --> 01:18:17.720]  Это корректный экспрешен.
[01:18:17.720 --> 01:18:18.720]  Это корректный экспрешен.
[01:18:18.720 --> 01:18:19.720]  Это корректный экспрешен.
[01:18:19.720 --> 01:18:20.720]  Это корректный экспрешен.
[01:18:20.720 --> 01:18:21.720]  Это корректный экспрешен.
[01:18:21.720 --> 01:18:22.720]  Это корректный экспрешен.
[01:18:22.720 --> 01:18:23.720]  Это корректный экспрешен.
[01:18:23.720 --> 01:18:24.720]  Это корректный экспрешен.
[01:18:24.720 --> 01:18:25.720]  Это корректный экспрешен.
[01:18:25.720 --> 01:18:26.720]  Это корректный экспрешен.
[01:18:26.720 --> 01:18:27.720]  Это корректный экспрешен.
[01:18:27.720 --> 01:18:28.720]  Это корректный экспрешен.
[01:18:28.720 --> 01:18:29.720]  Это корректный экспрешен.
[01:18:29.720 --> 01:18:30.720]  Это корректный экспрешен.
[01:18:30.720 --> 01:18:31.720]  Это корректный экспрешен.
[01:18:31.720 --> 01:18:32.720]  Это корректный экспрешен.
[01:18:32.720 --> 01:18:33.720]  Это корректный экспрешен.
[01:18:33.720 --> 01:18:34.720]  Это корректный экспрешен.
[01:18:34.720 --> 01:18:35.720]  Это корректный экспрешен.
[01:18:35.720 --> 01:18:36.720]  Это корректный экспрешен.
[01:18:36.720 --> 01:18:37.720]  Это корректный экспрешен.
[01:18:37.720 --> 01:18:38.720]  Это корректный экспрешен.
[01:18:38.720 --> 01:18:39.720]  Это корректный экспрешен.
[01:18:39.720 --> 01:18:40.720]  Это корректный экспрешен.
[01:18:40.720 --> 01:18:41.720]  Это корректный экспрешен.
[01:18:41.720 --> 01:18:42.720]  Это корректный экспрешен.
[01:18:42.720 --> 01:18:43.720]  Это корректный экспрешен.
[01:18:43.720 --> 01:18:44.720]  Это корректный экспрешен.
[01:18:44.720 --> 01:18:45.720]  Это корректный экспрешен.
[01:18:45.720 --> 01:18:46.720]  Это корректный экспрешен.
[01:18:46.720 --> 01:18:47.720]  Это корректный экспрешен.
[01:18:47.720 --> 01:18:48.720]  Это корректный экспрешен.
[01:18:48.720 --> 01:18:49.720]  Это корректный экспрешен.
[01:18:49.720 --> 01:18:50.720]  Это корректный экспрешен.
[01:18:50.720 --> 01:18:51.720]  Это корректный экспрешен.
[01:18:51.720 --> 01:18:52.720]  Это корректный экспрешен.
[01:18:52.720 --> 01:18:53.720]  Это корректный экспрешен.
[01:18:53.720 --> 01:18:54.720]  Это корректный экспрешен.
[01:18:54.720 --> 01:18:55.720]  Это корректный экспрешен.
[01:18:55.720 --> 01:18:56.720]  Это корректный экспрешен.
[01:18:56.720 --> 01:18:57.720]  Это корректный экспрешен.
[01:18:57.720 --> 01:18:58.720]  Это корректный экспрешен.
[01:18:58.720 --> 01:18:59.720]  Это корректный экспрешен.
[01:18:59.720 --> 01:19:00.720]  Это корректный экспрешен.
[01:19:00.720 --> 01:19:01.720]  Это корректный экспрешен.
[01:19:01.720 --> 01:19:02.720]  Это корректный экспрешен.
[01:19:02.720 --> 01:19:03.720]  Это корректный экспрешен.
[01:19:03.720 --> 01:19:04.720]  Это корректный экспрешен.
[01:19:04.720 --> 01:19:05.720]  Это корректный экспрешен.
[01:19:05.720 --> 01:19:06.720]  Это корректный экспрешен.
[01:19:06.720 --> 01:19:07.720]  Это корректный экспрешен.
[01:19:07.720 --> 01:19:08.720]  Это корректный экспрешен.
[01:19:08.720 --> 01:19:09.720]  Это корректный экспрешен.
[01:19:09.720 --> 01:19:10.720]  Это корректный экспрешен.
[01:19:10.720 --> 01:19:11.720]  Это корректный экспрешен.
[01:19:11.720 --> 01:19:12.720]  Это корректный экспрешен.
[01:19:12.720 --> 01:19:13.720]  Это корректный экспрешен.
[01:19:13.720 --> 01:19:14.720]  Это корректный экспрешен.
[01:19:14.720 --> 01:19:15.720]  Это корректный экспрешен.
[01:19:15.720 --> 01:19:16.720]  Это корректный экспрешен.
[01:19:16.720 --> 01:19:17.720]  Это корректный экспрешен.
[01:19:17.720 --> 01:19:18.720]  Это корректный экспрешен.
[01:19:18.720 --> 01:19:19.720]  Это корректный экспрешен.
[01:19:19.720 --> 01:19:20.720]  Это корректный экспрешен.
[01:19:20.720 --> 01:19:21.720]  Это корректный экспрешен.
[01:19:21.720 --> 01:19:22.720]  Это корректный экспрешен.
[01:19:22.720 --> 01:19:23.720]  Это корректный экспрешен.
[01:19:23.720 --> 01:19:24.720]  Это корректный экспрешен.
[01:19:24.720 --> 01:19:25.720]  Это корректный экспрешен.
[01:19:25.720 --> 01:19:26.720]  Это корректный экспрешен.
[01:19:26.720 --> 01:19:27.720]  Это корректный экспрешен.
[01:19:27.720 --> 01:19:28.720]  Это корректный экспрешен.
[01:19:28.720 --> 01:19:29.720]  Это корректный экспрешен.
[01:19:29.720 --> 01:19:30.720]  Это корректный экспрешен.
[01:19:30.720 --> 01:19:31.720]  Это корректный экспрешен.
[01:19:31.720 --> 01:19:32.720]  Это корректный экспрешен.
[01:19:32.720 --> 01:19:33.720]  Это корректный экспрешен.
[01:19:33.720 --> 01:19:34.720]  Это корректный экспрешен.
[01:19:34.720 --> 01:19:35.720]  Это корректный экспрешен.
[01:19:35.720 --> 01:19:36.720]  Это корректный экспрешен.
[01:19:36.720 --> 01:19:37.720]  Это корректный экспрешен.
[01:19:37.720 --> 01:19:38.720]  Это корректный экспрешен.
[01:19:38.720 --> 01:19:39.720]  Это корректный экспрешен.
[01:19:39.720 --> 01:19:40.720]  Это корректный экспрешен.
[01:19:40.720 --> 01:19:41.720]  Это корректный экспрешен.
[01:19:41.720 --> 01:19:42.720]  Это корректный экспрешен.
[01:19:42.720 --> 01:19:43.720]  Это корректный экспрешен.
[01:19:43.720 --> 01:19:44.720]  Это корректный экспрешен.
[01:19:44.720 --> 01:19:45.720]  Это корректный экспрешен.
[01:19:45.720 --> 01:19:46.720]  Это корректный экспрешен.
[01:19:46.720 --> 01:19:47.720]  Это корректный экспрешен.
[01:19:47.720 --> 01:19:48.720]  Это корректный экспрешен.
[01:19:48.720 --> 01:19:49.720]  Это корректный экспрешен.
[01:19:49.720 --> 01:19:50.720]  Это корректный экспрешен.
[01:19:50.720 --> 01:19:51.720]  Это корректный экспрешен.
[01:19:51.720 --> 01:19:52.720]  Это корректный экспрешен.
[01:19:52.720 --> 01:19:53.720]  Это корректный экспрешен.
[01:19:53.720 --> 01:19:54.720]  Это корректный экспрешен.
[01:19:54.720 --> 01:19:55.720]  Это корректный экспрешен.
[01:19:55.720 --> 01:19:56.720]  Это корректный экспрешен.
[01:19:56.720 --> 01:19:57.720]  Это корректный экспрешен.
[01:19:57.720 --> 01:19:58.720]  Это корректный экспрешен.
[01:19:58.720 --> 01:19:59.720]  Это корректный экспрешен.
[01:19:59.720 --> 01:20:00.720]  Это корректный экспрешен.
[01:20:00.720 --> 01:20:01.720]  Это корректный экспрешен.
[01:20:01.720 --> 01:20:02.720]  Это корректный экспрешен.
[01:20:02.720 --> 01:20:03.720]  Это корректный экспрешен.
[01:20:03.720 --> 01:20:04.720]  Это корректный экспрешен.
[01:20:04.720 --> 01:20:05.720]  Это корректный экспрешен.
[01:20:05.720 --> 01:20:06.720]  Это корректный экспрешен.
[01:20:06.720 --> 01:20:07.720]  Это корректный экспрешен.
[01:20:07.720 --> 01:20:08.720]  Это корректный экспрешен.
[01:20:08.720 --> 01:20:09.720]  Это корректный экспрешен.
[01:20:09.720 --> 01:20:10.720]  Это корректный экспрешен.
[01:20:10.720 --> 01:20:11.720]  Это корректный экспрешен.
[01:20:11.720 --> 01:20:12.720]  Это корректный экспрешен.
[01:20:12.720 --> 01:20:13.720]  Это корректный экспрешен.
[01:20:13.720 --> 01:20:14.720]  Это корректный экспрешен.
[01:20:14.720 --> 01:20:15.720]  Это корректный экспрешен.
[01:20:15.720 --> 01:20:16.720]  Это корректный экспрешен.
[01:20:16.720 --> 01:20:17.720]  Это корректный экспрешен.
[01:20:17.720 --> 01:20:18.720]  Это корректный экспрешен.
[01:20:18.720 --> 01:20:19.720]  Это корректный экспрешен.
[01:20:19.720 --> 01:20:20.720]  Это корректный экспрешен.
[01:20:20.720 --> 01:20:21.720]  Это корректный экспрешен.
[01:20:21.720 --> 01:20:22.720]  Это корректный экспрешен.
[01:20:22.720 --> 01:20:23.720]  Это корректный экспрешен.
[01:20:23.720 --> 01:20:24.720]  Это корректный экспрешен.
[01:20:24.720 --> 01:20:25.720]  Это корректный экспрешен.
[01:20:25.720 --> 01:20:26.720]  Это корректный экспрешен.
[01:20:26.720 --> 01:20:27.720]  Это корректный экспрешен.
[01:20:27.720 --> 01:20:28.720]  Это корректный экспрешен.
[01:20:28.720 --> 01:20:29.720]  Это корректный экспрешен.
[01:20:29.720 --> 01:20:30.720]  Это корректный экспрешен.
[01:20:30.720 --> 01:20:31.720]  Это корректный экспрешен.
[01:20:31.720 --> 01:20:32.720]  Это корректный экспрешен.
[01:20:32.720 --> 01:20:33.720]  Это корректный экспрешен.
[01:20:33.720 --> 01:20:34.720]  Это корректный экспрешен.
[01:20:34.720 --> 01:20:35.720]  Это корректный экспрешен.
[01:20:35.720 --> 01:20:36.720]  Это корректный экспрешен.
[01:20:36.720 --> 01:20:37.720]  Это корректный экспрешен.
[01:20:37.720 --> 01:20:38.720]  Это корректный экспрешен.
[01:20:38.720 --> 01:20:39.720]  Это корректный экспрешен.
[01:20:39.720 --> 01:20:40.720]  Это корректный экспрешен.
[01:20:40.720 --> 01:20:41.720]  Это корректный экспрешен.
[01:20:41.720 --> 01:20:42.720]  Это корректный экспрешен.
[01:20:42.720 --> 01:20:43.720]  Это корректный экспрешен.
[01:20:43.720 --> 01:20:44.720]  Это корректный экспрешен.
[01:20:44.720 --> 01:20:45.720]  Это корректный экспрешен.
[01:20:45.720 --> 01:20:46.720]  Это корректный экспрешен.
[01:20:46.720 --> 01:20:47.720]  Это корректный экспрешен.
[01:20:47.720 --> 01:20:48.720]  Это корректный экспрешен.
[01:20:48.720 --> 01:20:49.720]  Это корректный экспрешен.
[01:20:49.720 --> 01:20:50.720]  Это корректный экспрешен.
[01:20:50.720 --> 01:20:51.720]  Это корректный экспрешен.
[01:20:51.720 --> 01:20:52.720]  Это корректный экспрешен.
[01:20:52.720 --> 01:20:53.720]  Это корректный экспрешен.
[01:20:53.720 --> 01:20:54.720]  Это корректный экспрешен.
[01:20:54.720 --> 01:20:55.720]  Это корректный экспрешен.
[01:20:55.720 --> 01:20:56.720]  Это корректный экспрешен.
[01:20:56.720 --> 01:20:57.720]  Это корректный экспрешен.
[01:20:57.720 --> 01:20:58.720]  Это корректный экспрешен.
[01:20:58.720 --> 01:20:59.720]  Это корректный экспрешен.
[01:20:59.720 --> 01:21:00.720]  Это корректный экспрешен.
[01:21:00.720 --> 01:21:01.720]  Это корректный экспрешен.
[01:21:01.720 --> 01:21:02.720]  Это корректный экспрешен.
[01:21:02.720 --> 01:21:03.720]  Это корректный экспрешен.
[01:21:03.720 --> 01:21:04.720]  Это корректный экспрешен.
[01:21:04.720 --> 01:21:05.720]  Это корректный экспрешен.
[01:21:05.720 --> 01:21:06.720]  Это корректный экспрешен.
[01:21:06.720 --> 01:21:07.720]  Это корректный экспрешен.
[01:21:07.720 --> 01:21:08.720]  Это корректный экспрешен.
[01:21:08.720 --> 01:21:09.720]  Это корректный экспрешен.
[01:21:09.720 --> 01:21:10.720]  Это корректный экспрешен.
[01:21:10.720 --> 01:21:11.720]  Это корректный экспрешен.
[01:21:11.720 --> 01:21:12.720]  Это корректный экспрешен.
[01:21:12.720 --> 01:21:13.720]  Это корректный экспрешен.
[01:21:13.720 --> 01:21:14.720]  Это корректный экспрешен.
[01:21:14.720 --> 01:21:15.720]  Это корректный экспрешен.
[01:21:15.720 --> 01:21:16.720]  Это корректный экспрешен.
[01:21:16.720 --> 01:21:17.720]  Это корректный экспрешен.
[01:21:17.720 --> 01:21:18.720]  Это корректный экспрешен.
[01:21:18.720 --> 01:21:19.720]  Это корректный экспрешен.
[01:21:19.720 --> 01:21:20.720]  Это корректный экспрешен.
[01:21:20.720 --> 01:21:21.720]  Это корректный экспрешен.
[01:21:21.720 --> 01:21:22.720]  Это корректный экспрешен.
[01:21:22.720 --> 01:21:23.720]  Это корректный экспрешен.
[01:21:23.720 --> 01:21:24.720]  Это корректный экспрешен.
[01:21:24.720 --> 01:21:25.720]  Это корректный экспрешен.
[01:21:25.720 --> 01:21:26.720]  Это корректный экспрешен.
[01:21:26.720 --> 01:21:27.720]  Это корректный экспрешен.
[01:21:27.720 --> 01:21:28.720]  Это корректный экспрешен.
[01:21:28.720 --> 01:21:29.720]  Это корректный экспрешен.
[01:21:29.720 --> 01:21:30.720]  Это корректный экспрешен.
[01:21:30.720 --> 01:21:31.720]  Это корректный экспрешен.
[01:21:31.720 --> 01:21:32.720]  Это корректный экспрешен.
[01:21:32.720 --> 01:21:33.720]  Это корректный экспрешен.
[01:21:33.720 --> 01:21:34.720]  Это корректный экспрешен.
[01:21:34.720 --> 01:21:35.720]  Это корректный экспрешен.
[01:21:35.720 --> 01:21:36.720]  Это корректный экспрешен.
[01:21:36.720 --> 01:21:37.720]  Это корректный экспрешен.
[01:21:37.720 --> 01:21:38.720]  Это корректный экспрешен.
[01:21:38.720 --> 01:21:42.480]  А это как раз чтобы самсьюминг работал.
[01:21:42.480 --> 01:21:50.480]  Если бы мы просто написали sameS это isSameV от tu, то тогда
[01:21:50.480 --> 01:22:01.420]  если бы кто-то сделал sameS и что-то еще, ну короче
[01:22:01.420 --> 01:22:04.820]  мы хотим чтобы tu были симметричны, потому что с точки зрения
[01:22:04.820 --> 01:22:07.320]  анализатора вот этого вот самсьюминга капцептов
[01:22:07.320 --> 01:22:13.640]  isSameV tu и isSameV ut это абсолютно разные никак не связанные
[01:22:13.640 --> 01:22:14.640]  друг с другом требования.
[01:22:14.640 --> 01:22:19.960]  И чтобы концепт корректно умел обрабатывать более
[01:22:19.960 --> 01:22:24.480]  частные требования по отношению к isSame, он их упоминает
[01:22:24.480 --> 01:22:30.520]  оба isSameV tu и ut, чтобы когда мы сделаем более частный
[01:22:30.520 --> 01:22:34.080]  концепт, он умел правильно понимать, что те требования
[01:22:34.540 --> 01:22:39.700]  накрывают эти, что там больше требований, чем здесь.
[01:22:39.700 --> 01:22:42.700]  Вот как-то так.
[01:22:42.700 --> 01:22:43.700]  Наверное все.
[01:22:43.700 --> 01:22:44.700]  Давайте перерыв сделаем на этом.
[01:22:44.700 --> 01:22:45.700]  Я в общем...
[01:22:45.700 --> 01:22:50.480]  Last but not least, последняя глава нашего замечательного
[01:22:50.480 --> 01:22:51.480]  курса.
[01:22:51.480 --> 01:22:54.900]  Compile time отчисления.
[01:22:54.900 --> 01:23:01.660]  Это близко к тому, о чем мы только что говорили, но
[01:23:01.660 --> 01:23:03.460]  все-таки это несколько другая тема.
[01:23:03.460 --> 01:23:11.880]  Сейчас мы познакомимся с таким замечательным словом,
[01:23:11.880 --> 01:23:12.880]  как constexpr.
[01:23:12.880 --> 01:23:17.840]  Мы с ним уже чуть-чуть знакомы, но сейчас мы познакомимся
[01:23:17.840 --> 01:23:18.840]  полноценно.
[01:23:18.840 --> 01:23:46.860]  16.1, это constexpr, ну давайте скажу constexpr функции.
[01:23:46.860 --> 01:24:00.640]  Давайте так назову, constantExpressions и constexpr функции.
[01:24:00.640 --> 01:24:11.760]  Вот, ну с идеей constantExpressions на самом деле мы уже знакомы,
[01:24:11.760 --> 01:24:12.760]  как понять...
[01:24:13.660 --> 01:24:20.340]  Ну вот, допустим, у нас есть такой класс array, да?
[01:24:20.340 --> 01:24:34.580]  И вот мы хотим завести array из int 5a равно 1, 2, 3, 4, 5.
[01:24:34.580 --> 01:24:35.580]  Вот.
[01:24:35.580 --> 01:24:39.940]  Могу ли я сказать int x равно 5?
[01:24:40.360 --> 01:24:47.320]  Ну, очевидно, нет, потому что x это переменная, я не
[01:24:47.320 --> 01:24:51.440]  могу переменную как шаблонный параметр использовать.
[01:24:51.440 --> 01:24:59.160]  Да, ну ничего, недолго терпеть нам осталось.
[01:24:59.580 --> 01:25:02.580]  Да.
[01:25:02.580 --> 01:25:11.980]  До Мексика все время.
[01:25:11.980 --> 01:25:22.260]  А если я напишу constant, то внезапно уже смогу.
[01:25:22.260 --> 01:25:24.860]  Ну там есть некоторые костыли в стандарте на тему того,
[01:25:24.860 --> 01:25:27.220]  что если у меня константа, которая инициализирована
[01:25:27.220 --> 01:25:32.080]  сразу, то как будто бы я, в общем, могу.
[01:25:32.080 --> 01:25:35.520]  Но понятно, что даже если x это constantint, то не всегда
[01:25:35.520 --> 01:25:37.080]  я могу его использовать.
[01:25:37.080 --> 01:25:39.240]  Кажется, пример мы тоже приводили.
[01:25:39.240 --> 01:25:40.240]  То есть я могу что сделать?
[01:25:40.240 --> 01:25:45.640]  Я могу сказать int x, ну я могу сказать int y, stdcint y, а потом
[01:25:45.640 --> 01:25:47.040]  constant x равно y.
[01:25:47.040 --> 01:25:49.160]  И, конечно же, это не скомпилируется.
[01:25:49.160 --> 01:25:56.820]  Потому что хоть тип x и const, но в compile-time нельзя его
[01:25:56.820 --> 01:25:57.820]  подставить.
[01:25:57.820 --> 01:25:58.820]  Это вообще невозможно.
[01:25:58.820 --> 01:26:05.180]  Водится понятие constant expression, значит constant expression
[01:26:05.180 --> 01:26:08.500]  это такой expression, что его значение известно на этапе
[01:26:08.500 --> 01:26:09.500]  компиляции.
[01:26:09.500 --> 01:26:14.540]  Ну не то, что известно, а должно быть вычислено
[01:26:14.540 --> 01:26:15.540]  на этапе компиляции.
[01:26:15.540 --> 01:26:25.580]  И у нас, начиная с C++H11, есть такое замечательное слово
[01:26:25.580 --> 01:26:44.660]  constexpr, которое говорит, что данная переменная должна
[01:26:45.340 --> 01:26:48.500]  быть в момент компиляции, ее значение должно быть
[01:26:48.500 --> 01:26:49.500]  вычислено.
[01:26:49.500 --> 01:27:00.780]  Вот у меня есть, скажем, я могу сказать const int z равно
[01:27:00.780 --> 01:27:04.420]  5, и это значит, что я объявил константу.
[01:27:04.420 --> 01:27:09.780]  Но здесь вместо 5 я могу написать нечто, что не обязательно
[01:27:09.780 --> 01:27:12.540]  на этапе компиляции будет известно, чему равно, и
[01:27:12.540 --> 01:27:15.700]  тогда эту константу в качестве шаблонного параметра
[01:27:15.700 --> 01:27:16.700]  вот сюда я не смогу подставить.
[01:27:16.700 --> 01:27:20.020]  Но я могу сказать более сильную вещь, я могу сказать
[01:27:20.020 --> 01:27:25.380]  constexpr int z равно 5, и вот constexpr при объявлении переменной
[01:27:25.380 --> 01:27:28.780]  означает, что я обязываю компилятор вычислить вот
[01:27:28.780 --> 01:27:31.460]  это вот, то, чем я проницилизировал в момент компиляции.
[01:27:31.460 --> 01:27:37.020]  А если здесь написано выражение, которое в момент компиляции
[01:27:37.020 --> 01:27:41.220]  компилятор не может вычислить или не должен вычислять
[01:27:41.220 --> 01:27:44.260]  по каким-то причинам, то это будет CE.
[01:27:44.260 --> 01:27:49.540]  Вот, например, здесь, если я напишу constexpr int x равно
[01:27:49.540 --> 01:27:53.220]  y, это уже будет ошибкой компиляции не потому, что я стдр
[01:27:53.220 --> 01:27:56.660]  и от этого завел, а просто потому, что y справа нельзя
[01:27:56.660 --> 01:27:58.020]  в момент компиляции вычислить.
[01:27:58.020 --> 01:28:12.740]  Вот, the value of y is not usable in a constant expression, ну в общем-то
[01:28:12.740 --> 01:28:13.740]  понятно.
[01:28:13.740 --> 01:28:22.340]  Правда ли, что если переменная constexpr, то она обязательно
[01:28:22.340 --> 01:28:26.380]  влечет const.
[01:28:26.380 --> 01:28:40.820]  Правильный ответ – да, значит constexpr обязательно влечет
[01:28:40.820 --> 01:28:41.820]  const.
[01:28:41.820 --> 01:28:49.380]  constexpr – это более строгое условие, чем const, constexpr означает,
[01:28:49.380 --> 01:28:53.020]  что это не просто константная переменная, а еще и константа
[01:28:53.020 --> 01:28:54.020]  времени компиляции.
[01:28:54.020 --> 01:28:58.900]  То есть, вот, надо именно, что… правильно это понимать.
[01:28:58.900 --> 01:29:02.580]  constexpr переменная – это значит, что это не просто константа,
[01:29:02.580 --> 01:29:06.060]  а нечто большее, это константа времени компиляции, константа
[01:29:06.060 --> 01:29:09.900]  вычисленная в момент компиляции и зашита в бинарник, прям
[01:29:09.900 --> 01:29:13.060]  вот, вот, как бы, в секцию константа.
[01:29:13.060 --> 01:29:16.860]  Вот что такое constexpr.
[01:29:16.860 --> 01:29:20.900]  Теперь вопрос, ну, вот это constant expressions, да, теперь
[01:29:20.900 --> 01:29:30.900]  вопрос, а могу ли я… а, ну, пока, вот так, вот я, например,
[01:29:30.900 --> 01:29:35.620]  напишу, int y равно 5, и дальше constexpr int x равно y, так можно,
[01:29:35.620 --> 01:29:40.860]  тоже нельзя, потому что y – это не constexpr.
[01:29:40.860 --> 01:29:45.740]  Значит, y, несмотря на то, что казалось бы известно во
[01:29:45.900 --> 01:29:47.980]  время компиляции, ну, нет, неизвестно.
[01:29:47.980 --> 01:29:51.980]  yr – это локальная переменная, она неконстантная, и это
[01:29:51.980 --> 01:29:53.860]  уж точно не константа времени компиляции.
[01:29:53.860 --> 01:29:55.860]  А если написать constant y?
[01:29:55.860 --> 01:30:00.380]  Вот, если написать constant y, то это будет работать по
[01:30:00.380 --> 01:30:05.860]  причине, что для этого специально костыль какой-то заведен,
[01:30:05.860 --> 01:30:11.780]  но, в общем… ну, в общем, там, кажется, есть в стандарте
[01:30:11.780 --> 01:30:15.500]  костыль, что если вы пишете const int и справа прям конкретное
[01:30:15.500 --> 01:30:18.180]  значение, то он считает, что это можно использовать
[01:30:18.180 --> 01:30:20.180]  в константных выражениях.
[01:30:20.180 --> 01:30:24.260]  Ну да, да, он как бы воспринимает это как constexpr.
[01:30:24.260 --> 01:30:27.060]  Правила точно такие же, вот как понять выражение
[01:30:27.060 --> 01:30:29.020]  constexpr или нет?
[01:30:29.020 --> 01:30:31.820]  Задайте себе вопрос, можно ли мне вот здесь было написать
[01:30:31.820 --> 01:30:32.820]  его?
[01:30:32.820 --> 01:30:36.940]  Вот, правила, на самом деле, именно такие, вот, ну,
[01:30:36.940 --> 01:30:39.060]  вот, в шаблонном параметре, представь, что вы делаете
[01:30:39.060 --> 01:30:43.420]  std array от int запятая и вот это, это бы скомпилировалось?
[01:30:43.500 --> 01:30:45.940]  Вот, можно себя так проверить, если у вас есть интуиция
[01:30:45.940 --> 01:30:48.540]  на тему того, что можно делать шаблонными параметрами,
[01:30:48.540 --> 01:30:50.620]  что нет, то это именно оно.
[01:30:50.620 --> 01:30:53.180]  Можно ли это выражение поставить сюда как шаблонный
[01:30:53.180 --> 01:30:54.180]  параметр?
[01:30:54.180 --> 01:30:58.140]  Вот, в точности это и значит, что оно должно быть констант
[01:30:58.140 --> 01:31:01.180]  и времени компиляции, constant expression.
[01:31:01.180 --> 01:31:10.660]  А, можно ли вызов функции сделать, вот, например, у
[01:31:10.660 --> 01:31:21.140]  меня есть функция, я не знаю, int f от int x, которая что-нибудь
[01:31:21.140 --> 01:31:24.540]  делает, не знаю, return x умножить на x.
[01:31:24.540 --> 01:31:28.820]  Давайте назовем ее sqr от x.
[01:31:28.820 --> 01:31:36.940]  Вот, могу ли я здесь сказать, господи, sqr от пяти.
[01:31:36.940 --> 01:31:55.340]  Вот, господин Барыкин правильно сказал, что надо, чтобы
[01:31:55.340 --> 01:31:58.780]  можно было, надо специальное слово написать, пожалуйста.
[01:31:58.780 --> 01:32:04.740]  То есть компилятор может это сделать, но если его
[01:32:05.740 --> 01:32:08.940]  просто так-то не будет работать, потому что вызов функции
[01:32:08.940 --> 01:32:11.700]  не считается constant expression, так, я не сохранил.
[01:32:11.700 --> 01:32:18.820]  Значит, вызов функции не является constant expression,
[01:32:18.820 --> 01:32:21.180]  потому что он, вообще говоря, может требовать там каких-то
[01:32:21.180 --> 01:32:25.860]  там проходов по сте, ну, там каких-то, значит, прыжков
[01:32:25.860 --> 01:32:26.860]  куда-то.
[01:32:26.860 --> 01:32:32.420]  Но если написать constexpr int, короче, функции тоже можно
[01:32:32.420 --> 01:32:33.420]  объявлять constexpr.
[01:32:33.980 --> 01:32:35.700]  constexpr функцию можно завести.
[01:32:35.700 --> 01:32:46.100]  И вот, если вы саму функцию объявили как constexpr, то тогда
[01:32:46.100 --> 01:32:51.500]  результат ее вызова считается constant expression.
[01:32:51.500 --> 01:32:52.500]  Чего?
[01:32:52.700 --> 01:33:05.700]  Вот, такие дела.
[01:33:05.700 --> 01:33:10.700]  Как это, в смысле, не обманули?
[01:33:10.700 --> 01:33:18.420]  Ну, это правильный вопрос, на самом деле.
[01:33:18.420 --> 01:33:25.620]  Значит, здесь открывается дверь в пропасть, вот примерно
[01:33:25.620 --> 01:33:27.580]  об этом мы будем разговаривать в ближайший час.
[01:33:27.580 --> 01:33:33.940]  Оказывается, что функции можно объявлять constexpr.
[01:33:33.940 --> 01:33:38.020]  Возникает вопрос, а что в таких функциях можно делать,
[01:33:38.020 --> 01:33:39.020]  если они constexpr?
[01:33:39.020 --> 01:33:41.460]  То есть, когда я говорю, что функция constexpr, я тем
[01:33:41.460 --> 01:33:44.740]  самым, как бы говорю компилятору, ты должен уметь это на
[01:33:44.740 --> 01:33:46.060]  этапе компиляции вычислять.
[01:33:46.900 --> 01:33:47.900]  Хорошо.
[01:33:47.900 --> 01:33:54.140]  А могу ли я, скажем, ну вот, я сейчас какой-нибудь
[01:33:54.140 --> 01:33:59.860]  пример напишу, там у меня есть там функция isPrime, пример
[01:33:59.860 --> 01:34:03.500]  типа с прошлого года.
[01:34:03.500 --> 01:34:06.580]  Могу ли я вот, например, проверить число на простоту
[01:34:06.580 --> 01:34:07.580]  на этапе компиляции?
[01:34:07.580 --> 01:34:09.740]  Мне здесь что надо сделать?
[01:34:09.740 --> 01:34:14.860]  Ну давайте там я переберу делители, там for, int, int, ну
[01:34:14.860 --> 01:34:19.180]  я тут не буду, значит, соблюдать хороший код style, там умножить
[01:34:19.180 --> 01:34:25.420]  на i меньше, чем n, меньше равно n, плюс-плюс i, тут, наверное,
[01:34:25.420 --> 01:34:32.660]  от двух надо, да, типа если, значит, если n делится
[01:34:32.660 --> 01:34:42.500]  на i равно нулю, тогда return false, и return, значит, и что
[01:34:42.500 --> 01:34:43.500]  надо return?
[01:34:44.140 --> 01:34:45.140]  Ну как асинхрон?
[01:34:45.140 --> 01:35:01.140]  Неравно 1, да, вот так, что именно вас повседлило,
[01:35:01.140 --> 01:35:09.660]  я правду вообще написал, да, вот видите как, ну нет,
[01:35:09.660 --> 01:35:12.900]  на самом деле нужно, потому что в таком случае, если,
[01:35:12.900 --> 01:35:15.940]  а, ну нет, если n равно 1, то я просто цикл не буду
[01:35:15.940 --> 01:35:18.940]  делать и все, да.
[01:35:18.940 --> 01:35:25.580]  Вопрос, могу ли я вот это сделать constexpr?
[01:35:25.580 --> 01:35:30.500]  Ну тут, смотрите, тут for есть, тут есть if, if constexpr, for constexpr,
[01:35:30.500 --> 01:35:31.500]  да?
[01:35:31.500 --> 01:35:34.500]  Нет, кажется, это можно делать спокойно, потому
[01:35:34.500 --> 01:35:37.500]  что, ну, типа все компетент вычислимое.
[01:35:37.500 --> 01:35:41.740]  А что некомпетентом вычислимое, когда, а где проходит граница
[01:35:41.740 --> 01:35:44.340]  между тем, что компилятор может компетентом вычислить,
[01:35:44.340 --> 01:35:45.340]  и не может?
[01:35:45.340 --> 01:35:49.260]  Размышление, что здесь, да, он обращается только к
[01:35:49.260 --> 01:35:55.740]  локальным переменам, короче, мысль, что здесь он обращается
[01:35:55.740 --> 01:35:59.660]  только к локальным переменам, соответственно, зависеть
[01:35:59.660 --> 01:36:03.420]  может только от, типа, входных параметров.
[01:36:03.420 --> 01:36:16.020]  Вот могу ли я так сделать?
[01:36:16.020 --> 01:36:18.900]  Ну, я здесь должен писать constexpr.
[01:36:18.900 --> 01:36:19.900]  Да, тогда да.
[01:36:19.900 --> 01:36:20.900]  Вы поверьте.
[01:36:20.900 --> 01:36:27.060]  Я бы ставил как минимум на YouTube все компиляторы.
[01:36:27.060 --> 01:36:28.060]  Как бы что ставил?
[01:36:28.460 --> 01:36:30.460]  constexpr на YouTube.
[01:36:30.460 --> 01:36:33.660]  Так, а как бы смысл ставить это в глубину, если ты
[01:36:33.660 --> 01:36:35.660]  бы что-то от меня поставил?
[01:36:35.660 --> 01:36:36.660]  Ну, это...
[01:36:36.660 --> 01:36:42.460]  Вот, на самом деле, if constexpr и просто constexpr надо разделять,
[01:36:42.460 --> 01:36:44.100]  это разные идеи на штуке.
[01:36:44.100 --> 01:36:47.300]  Мы с вами if constexpr изучили раньше, чем просто constexpr,
[01:36:47.300 --> 01:36:49.860]  хотя появился он позже, но это на самом деле совсем
[01:36:49.860 --> 01:36:50.860]  другая история.
[01:36:50.860 --> 01:36:55.300]  If constexpr это какая-то штука, которую вот в compile time надо
[01:36:55.300 --> 01:36:59.140]  проверить, там, на шаблонах, например, что-то, и не компилировать
[01:36:59.140 --> 01:37:02.100]  одну ветку, если это ложно, то есть if constexpr его смысл
[01:37:02.100 --> 01:37:03.100]  в чем?
[01:37:03.100 --> 01:37:06.260]  В том, что вы хотите одну из веток не компилировать,
[01:37:06.260 --> 01:37:07.420]  если условие ложно.
[01:37:07.420 --> 01:37:09.140]  Вот для чего нужен if constexpr.
[01:37:09.140 --> 01:37:11.300]  Здесь if constexpr не уместен, у него задача другая.
[01:37:11.300 --> 01:37:18.140]  Вот, поэтому тут if constexpr, это не об этом, и for, ну for constexpr
[01:37:18.140 --> 01:37:20.980]  это тоже странно, нет, for constexpr такого нет.
[01:37:20.980 --> 01:37:23.180]  На самом деле, правильный ответ, да, это можно вычислить
[01:37:23.180 --> 01:37:30.220]  на этапе компиляции, но, только начиная c++14, значит,
[01:37:30.220 --> 01:37:31.220]  следите за руками.
[01:37:31.220 --> 01:37:35.900]  constexpr появился в c++11, а вот for и if в constexpr функциях
[01:37:35.900 --> 01:37:36.900]  начиная с c++14.
[01:37:36.900 --> 01:37:40.340]  То есть, получается, в 11-х плюсах просто это нельзя
[01:37:40.340 --> 01:37:41.340]  было заставить?
[01:37:41.340 --> 01:37:44.460]  Просто, да, нельзя, потому что слишком сложно, потому
[01:37:44.460 --> 01:37:46.700]  что еще не реализовали, потому что компилятор пока
[01:37:46.700 --> 01:37:47.700]  не умеет.
[01:37:47.700 --> 01:37:51.340]  Значит, я давайте вам продемонстрирую, минус std равно c++, нет, циклы
[01:37:51.340 --> 01:37:52.340]  тоже нельзя.
[01:37:52.900 --> 01:37:58.900]  Смотрите, я вот скомпилировал в версии c++11, и смотрите,
[01:37:58.900 --> 01:37:59.900]  что он мне сказал.
[01:37:59.900 --> 01:38:03.340]  Body of constexpr function not a return statement.
[01:38:03.340 --> 01:38:07.540]  Значит, c++11 было следующее требование, если функция
[01:38:07.540 --> 01:38:10.100]  constexpr, то все из чего она может состоять, это просто
[01:38:10.100 --> 01:38:12.900]  один return и только один expression в нем.
[01:38:12.900 --> 01:38:16.540]  То есть, это должен быть return что-то, а там вы изгоняетесь,
[01:38:16.540 --> 01:38:19.140]  как хотите, тернарники пишите там, вызовы других
[01:38:19.140 --> 01:38:21.580]  constexpr функций, но if и for нельзя.
[01:38:22.060 --> 01:38:23.060]  О, однострочники.
[01:38:23.060 --> 01:38:26.140]  Да, только однострочники можно было делать в constexpr
[01:38:26.140 --> 01:38:27.140]  c++11.
[01:38:27.140 --> 01:38:30.180]  А если точку с запятой написать две строчки в одной, это
[01:38:30.180 --> 01:38:31.180]  считается?
[01:38:31.180 --> 01:38:32.180]  Но это же после второй строчки.
[01:38:32.180 --> 01:38:34.740]  Только return 1, только один return можно написать.
[01:38:34.740 --> 01:38:37.180]  Так, в продолжении будет после return statement, так что
[01:38:37.180 --> 01:38:38.180]  как бы, ну, пиши, не пиши.
[01:38:38.180 --> 01:38:39.180]  Блин.
[01:38:39.180 --> 01:38:41.620]  Нет, я напишу c++, точка с запятой, return 1.
[01:38:41.620 --> 01:38:43.980]  Слушай, меня, честно говоря, пугают твои вопросы, вот
[01:38:43.980 --> 01:38:46.500]  уже меня они все больше пугают, у тебя какие-то вопросы,
[01:38:46.500 --> 01:38:48.780]  вот, мне кажется, тебе надо вот фундамент какой-то
[01:38:48.780 --> 01:38:49.780]  переделать.
[01:38:49.780 --> 01:38:53.060]  Да, просто вот мы вот что-то изучаем, изучаем, а Миша
[01:38:53.060 --> 01:38:55.060]  такой, а вот почему синтаксис ИФА такой?
[01:38:55.060 --> 01:38:57.660]  А что если я два expression напишу в одну строчку, это будет
[01:38:57.660 --> 01:38:58.660]  считаться однострочником?
[01:38:58.660 --> 01:38:59.660]  Нет.
[01:38:59.660 --> 01:39:01.700]  Типа, блин, мне кажется, у тебя проблемы с базовым
[01:39:01.700 --> 01:39:04.700]  синтаксисом какие-то.
[01:39:04.700 --> 01:39:07.700]  Мне кажется, что...
[01:39:07.700 --> 01:39:13.100]  Не, у нас в прошлом году, я помню, где-то в марте или
[01:39:13.100 --> 01:39:17.100]  в апреле в чате возникла дискуссия, а что такое переменная?
[01:39:17.100 --> 01:39:18.380]  Вот это было прям хорошо.
[01:39:18.380 --> 01:39:24.140]  На продве, да, там прям, там просто кто-то задал глубокий
[01:39:24.140 --> 01:39:27.140]  вопрос, что-то про RvL и дальше задался вопросом, что такое
[01:39:27.140 --> 01:39:28.140]  переменная.
[01:39:28.140 --> 01:39:36.940]  Ну вот, а все плюсы 14 уже можно.
[01:39:36.940 --> 01:39:39.940]  Ну ладно.
[01:39:39.940 --> 01:39:43.940]  Нет, то есть можно было делать всякие тернарники?
[01:39:43.940 --> 01:39:45.740]  Да, return и дальше expression.
[01:39:46.740 --> 01:39:49.740]  Тернарники можно было бы это сэмулировать, да.
[01:39:49.740 --> 01:39:52.740]  Можно было бы сделать вызов другой функции.
[01:39:52.740 --> 01:39:53.740]  Вот, хорошо.
[01:39:56.740 --> 01:39:59.740]  Можно ли рекурсию делать?
[01:39:59.740 --> 01:40:02.740]  Ну в 14-х уже можно, в 11-х не помню.
[01:40:02.740 --> 01:40:03.740]  Наверное, тоже можно.
[01:40:05.740 --> 01:40:08.740]  Ну если она код Stexpr, наверное, можно.
[01:40:08.740 --> 01:40:11.740]  Вот, и окей.
[01:40:11.740 --> 01:40:14.740]  Ну хорошо.
[01:40:14.740 --> 01:40:17.740]  Так, а что еще, например, я могу сделать?
[01:40:22.740 --> 01:40:24.740]  Давайте вот что сделаем.
[01:40:31.740 --> 01:40:32.740]  Ой.
[01:40:32.740 --> 01:40:44.740]  Не знаю, вот смотрите, вот я сейчас напишу такое.
[01:40:55.740 --> 01:40:57.740]  Ну, короче, вот.
[01:41:02.740 --> 01:41:04.740]  Я, к сожалению...
[01:41:08.740 --> 01:41:11.740]  Ну, я пока боюсь немножечко йоту вызывать, вдруг нельзя.
[01:41:17.740 --> 01:41:22.740]  Вот, и давайте я скажу, значит, int result, ну или res равно нулю,
[01:41:22.740 --> 01:41:33.740]  и от нуля до 20 res плюс равно isPrime от aitova.
[01:41:35.740 --> 01:41:37.740]  Return res.
[01:41:37.740 --> 01:41:41.740]  Вопрос, могу ли я массив завести?
[01:41:41.740 --> 01:41:45.740]  Ну, он на стеке, наверное, да.
[01:41:45.740 --> 01:41:47.740]  Стеком понятно?
[01:41:47.740 --> 01:41:48.740]  Какой стеке?
[01:41:48.740 --> 01:41:50.740]  Да, это хороший вопрос, на каком стеке?
[01:41:52.740 --> 01:41:54.740]  Пусть это хранятся, пусть он там...
[01:41:57.740 --> 01:41:58.740]  В каком бинарнике?
[01:41:58.740 --> 01:42:02.740]  Бинарника нет, у нас процесс компиляции идет, никакой бинарник еще не создан.
[01:42:02.740 --> 01:42:06.740]  Мы просто хотим посчитать, сколько простых среди первых 20 чисел.
[01:42:06.740 --> 01:42:09.740]  Я такое говорю, constexpr, int.
[01:42:16.740 --> 01:42:18.740]  В принципе, вы правы, да.
[01:42:18.740 --> 01:42:20.740]  Но, но...
[01:42:20.740 --> 01:42:22.740]  Ну да, да, даже C++14 можно.
[01:42:22.740 --> 01:42:24.740]  В принципе, вы правы.
[01:42:24.740 --> 01:42:28.740]  Ладно, тогда усложняем задачу.
[01:42:28.740 --> 01:42:31.740]  Давайте скажем вот так.
[01:42:49.740 --> 01:42:53.740]  Слушай, ну не смешно, ну хватит уже.
[01:43:00.740 --> 01:43:02.740]  Ну все равно, вот могу ли...
[01:43:02.740 --> 01:43:05.740]  Ну вот указатель я хочу завести в compile-time.
[01:43:05.740 --> 01:43:07.740]  Это нормально?
[01:43:07.740 --> 01:43:10.740]  С другой стороны, почему бы и нет?
[01:43:10.740 --> 01:43:13.740]  Мы оставили, что нет.
[01:43:13.740 --> 01:43:15.740]  Уже сделали шаг назад.
[01:43:15.740 --> 01:43:17.740]  Это работа с памятью какая-то, да.
[01:43:17.740 --> 01:43:19.740]  То есть обращаться к массиву можно.
[01:43:19.740 --> 01:43:20.740]  Ну хорошо, ладно.
[01:43:20.740 --> 01:43:21.740]  А указатель?
[01:43:21.740 --> 01:43:24.740]  Следующий шаг это, видимо, введение локаторов.
[01:43:31.740 --> 01:43:34.740]  Ну что, ваши ставки можно так или нельзя?
[01:43:35.740 --> 01:43:37.740]  Кто считает, что нельзя?
[01:43:38.740 --> 01:43:40.740]  Я считаю, что в 14 нельзя.
[01:43:43.740 --> 01:43:45.740]  Чем вот это отличается просто от...
[01:43:45.740 --> 01:43:47.740]  Ну хоть в каких-нибудь.
[01:43:55.740 --> 01:43:57.740]  Нормально.
[01:43:57.740 --> 01:43:59.740]  Даже в 14 можно.
[01:44:02.740 --> 01:44:04.740]  Ну ладно.
[01:44:04.740 --> 01:44:08.740]  Сейчас Илья, а может же нам надо попытаться выйти за конец массива?
[01:44:08.740 --> 01:44:11.740]  Можно попробовать его начать от Nuptera.
[01:44:11.740 --> 01:44:12.740]  Подожди.
[01:44:12.740 --> 01:44:14.740]  Сейчас, не все так быстро.
[01:44:16.740 --> 01:44:18.740]  Давайте...
[01:44:21.740 --> 01:44:26.740]  Кстати, вот конкретно, если указать не 20, а, например, 40,
[01:44:26.740 --> 01:44:29.740]  у меня статический анализатор подсвечивает.
[01:44:30.740 --> 01:44:33.740]  Если в цикле 20 заменить на 40,
[01:44:34.740 --> 01:44:35.740]  так, подожди, подожди.
[01:44:35.740 --> 01:44:37.740]  Сейчас все по порядочку, все по порядочку.
[01:44:38.740 --> 01:44:39.740]  Тихо, тихо, тихо.
[01:44:39.740 --> 01:44:41.740]  Давайте, давайте, давайте, например...
[01:44:42.740 --> 01:44:44.740]  Давайте, например...
[01:44:44.740 --> 01:44:46.740]  Окей, указатели можно.
[01:44:46.740 --> 01:44:48.740]  Ну, на самом деле, действительно, можно указатели.
[01:44:48.740 --> 01:44:50.740]  То есть я, например, могу сказать,
[01:44:51.740 --> 01:44:55.740]  int звездочка ptr равно address res.
[01:44:56.740 --> 01:44:58.740]  Могу сказать.
[01:44:59.740 --> 01:45:00.740]  Эм...
[01:45:01.740 --> 01:45:03.740]  И, значит, вместо того, чтобы res писать,
[01:45:03.740 --> 01:45:07.740]  я буду говорить, вот поэтому ptr я хочу инкриментировать.
[01:45:09.740 --> 01:45:11.740]  Как он это эмулирует?
[01:45:11.740 --> 01:45:13.740]  Как он это делает?
[01:45:14.740 --> 01:45:16.740]  Тоже можно, все нормально.
[01:45:17.740 --> 01:45:19.740]  Даже в C++14.
[01:45:19.740 --> 01:45:21.740]  Сейчас, это какой еще раз сценарий?
[01:45:21.740 --> 01:45:23.740]  Я просто pointer завел,
[01:45:23.740 --> 01:45:25.740]  address переменной взял,
[01:45:25.740 --> 01:45:27.740]  и по pointer теперь,
[01:45:27.740 --> 01:45:29.740]  разыминовывая pointer, кладу туда значение.
[01:45:30.740 --> 01:45:32.740]  Все в compile-time делается.
[01:45:33.740 --> 01:45:35.740]  После предыдущего примера это не удивительно,
[01:45:35.740 --> 01:45:37.740]  потому что на это лечили...
[01:45:37.740 --> 01:45:39.740]  Да, ну, то есть он как-то эмулирует указатели в себе.
[01:45:39.740 --> 01:45:41.740]  Ну, ладно.
[01:45:41.740 --> 01:45:43.740]  Хорошо.
[01:45:44.740 --> 01:45:45.740]  Что еще мы умеем?
[01:45:45.740 --> 01:45:47.740]  ООП давайте мы пока пропустим.
[01:45:47.740 --> 01:45:49.740]  New Delete.
[01:45:49.740 --> 01:45:51.740]  New Delete мы пока тоже пропустим.
[01:45:51.740 --> 01:45:53.740]  Ссылки.
[01:45:53.740 --> 01:45:55.740]  Ну, очевидно, ссылки можно, я не буду...
[01:45:55.740 --> 01:45:57.740]  Да, то есть понятно, что ссылки тоже можно.
[01:45:57.740 --> 01:45:59.740]  Я могу завести int&persand, значит,
[01:45:59.740 --> 01:46:01.740]  там, res2 равно res.
[01:46:01.740 --> 01:46:03.740]  Ну, короче, ссылки тоже можно.
[01:46:07.740 --> 01:46:09.740]  Что еще?
[01:46:09.740 --> 01:46:11.740]  Давайте...
[01:46:11.740 --> 01:46:13.740]  Какие мы еще знаем фичи языка?
[01:46:13.740 --> 01:46:15.740]  Ну, мы, например, знаем такую фичу, как...
[01:46:15.740 --> 01:46:17.740]  Views.
[01:46:21.740 --> 01:46:23.740]  Бросание исключений.
[01:46:23.740 --> 01:46:25.740]  Бросание исключений.
[01:46:31.740 --> 01:46:33.740]  Вот.
[01:46:33.740 --> 01:46:35.740]  Давайте какую-нибудь я придумаю...
[01:46:35.740 --> 01:46:37.740]  Историю...
[01:46:37.740 --> 01:46:39.740]  О, смотрите.
[01:46:39.740 --> 01:46:41.740]  Допустим, меня спросили,
[01:46:41.740 --> 01:46:43.740]  просто или число.
[01:46:43.740 --> 01:46:45.740]  Вот я хочу, если n меньше или равно нуля,
[01:46:45.740 --> 01:46:47.740]  то бросить...
[01:46:47.740 --> 01:46:49.740]  Ну, я пока объекты боюсь создавать,
[01:46:49.740 --> 01:46:51.740]  давайте я брошу ноль.
[01:46:51.740 --> 01:46:53.740]  Ну, стекспор он, наверно, подразумевает
[01:46:53.740 --> 01:46:55.740]  в новых сетах.
[01:46:55.740 --> 01:46:57.740]  Вот, давайте я проверю,
[01:46:57.740 --> 01:46:59.740]  что...
[01:46:59.740 --> 01:47:01.740]  Ну, давайте я для начала проверю, что
[01:47:01.740 --> 01:47:03.740]  3867 простое.
[01:47:03.740 --> 01:47:05.740]  А как вы думаете, нормально вообще это
[01:47:05.740 --> 01:47:07.740]  скомпилируется?
[01:47:07.740 --> 01:47:09.740]  Куда он должен бросить исключения?
[01:47:09.740 --> 01:47:11.740]  Тот же вопрос, что он должен кинуть исключения
[01:47:11.740 --> 01:47:13.740]  в победе.
[01:47:13.740 --> 01:47:15.740]  Так, подождите,
[01:47:15.740 --> 01:47:17.740]  что-то мне не нравится, потому что это
[01:47:17.740 --> 01:47:19.740]  не должно компилироваться вообще-то.
[01:47:19.740 --> 01:47:21.740]  Мы с вами что-то не то делаем.
[01:47:21.740 --> 01:47:23.740]  А может он просто понял, что...
[01:47:23.740 --> 01:47:25.740]  Что статистический анализатор
[01:47:25.740 --> 01:47:27.740]  понял, что это гибросайд,
[01:47:27.740 --> 01:47:29.740]  поэтому просто заигрывали?
[01:47:29.740 --> 01:47:31.740]  Не-не-не, подождите-подождите, у меня такое ощущение,
[01:47:31.740 --> 01:47:33.740]  как будто...
[01:47:35.740 --> 01:47:37.740]  Да, вот сейчас я уже удивлен,
[01:47:37.740 --> 01:47:39.740]  потому что это не должно компилироваться.
[01:47:39.740 --> 01:47:41.740]  Хорошо, давайте я C++11.
[01:47:41.740 --> 01:47:43.740]  Да, в C++11
[01:47:43.740 --> 01:47:45.740]  она отказывается компилировать.
[01:47:45.740 --> 01:47:47.740]  А, но в C++11 даже
[01:47:47.740 --> 01:47:49.740]  фор не компилирует.
[01:47:49.740 --> 01:47:51.740]  Хорошо, а если я G++9
[01:47:51.740 --> 01:47:53.740]  скомпилировать попытаюсь?
[01:47:55.740 --> 01:47:57.740]  Тоже компилирует.
[01:47:57.740 --> 01:47:59.740]  Он нас перегнал и уничтожил?
[01:47:59.740 --> 01:48:01.740]  Как это вообще работает?
[01:48:01.740 --> 01:48:03.740]  Он сначала просто компилирует,
[01:48:03.740 --> 01:48:05.740]  потом делает compile time вычисления,
[01:48:05.740 --> 01:48:07.740]  а потом уже гинает.
[01:48:07.740 --> 01:48:09.740]  Нет, подожди, когда он компилирует, он делает
[01:48:09.740 --> 01:48:11.740]  в том числе compile time вычисления.
[01:48:11.740 --> 01:48:13.740]  Он бьет себя универсально.
[01:48:13.740 --> 01:48:15.740]  Вызвайте от него одного.
[01:48:15.740 --> 01:48:17.740]  Это очень странно,
[01:48:17.740 --> 01:48:19.740]  потому что кажется,
[01:48:19.740 --> 01:48:21.740]  он не должен это компилировать.
[01:48:21.740 --> 01:48:23.740]  Ну, короче...
[01:48:25.740 --> 01:48:27.740]  Может это просто правило
[01:48:27.740 --> 01:48:29.740]  не запрещено так писать,
[01:48:29.740 --> 01:48:31.740]  это типа УБ?
[01:48:31.740 --> 01:48:33.740]  Нет, это не УБ.
[01:48:33.740 --> 01:48:35.740]  Сейчас, короче, я вот так сделаю,
[01:48:35.740 --> 01:48:37.740]  я просто на Godbolt
[01:48:37.740 --> 01:48:39.740]  сейчас это залью
[01:48:39.740 --> 01:48:41.740]  и там проверю с вами это.
[01:48:41.740 --> 01:48:43.740]  Какие они?
[01:48:43.740 --> 01:48:45.740]  Да-да-да-да-да.
[01:48:45.740 --> 01:48:47.740]  Дальше?
[01:48:47.740 --> 01:48:49.740]  Ммм...
[01:48:49.740 --> 01:48:51.740]  Значит...
[01:48:51.740 --> 01:48:53.740]  Так.
[01:48:53.740 --> 01:48:55.740]  Поменьше сделаем.
[01:48:55.740 --> 01:48:57.740]  Вам же видно, да?
[01:48:57.740 --> 01:48:59.740]  Ааа...
[01:48:59.740 --> 01:49:01.740]  Значит, со стд C++14
[01:49:01.740 --> 01:49:03.740]  24 нет,
[01:49:03.740 --> 01:49:05.740]  пока мы не дожили.
[01:49:05.740 --> 01:49:07.740]  Да, все-таки компилируется.
[01:49:07.740 --> 01:49:09.740]  Странно.
[01:49:09.740 --> 01:49:11.740]  Ну ладно, значит компилируется.
[01:49:11.740 --> 01:49:13.740]  Действительно.
[01:49:13.740 --> 01:49:15.740]  Силенг тоже компилирует.
[01:49:15.740 --> 01:49:17.740]  Ааа...
[01:49:17.740 --> 01:49:19.740]  Ну, в общем, да, throw можно писать, короче,
[01:49:19.740 --> 01:49:21.740]  в constexpr функциях.
[01:49:21.740 --> 01:49:23.740]  На самом деле, по-моему, можно начинать
[01:49:23.740 --> 01:49:25.740]  с C++17 было?
[01:49:25.740 --> 01:49:27.740]  Но, видимо,
[01:49:27.740 --> 01:49:29.740]  с C++14 можно.
[01:49:29.740 --> 01:49:31.740]  Теперь вопрос, а если я вызовусь
[01:49:31.740 --> 01:49:33.740]  от нуляс хотя бы?
[01:49:33.740 --> 01:49:35.740]  Что будет?
[01:49:35.740 --> 01:49:37.740]  Вот теперь ваша версия.
[01:49:37.740 --> 01:49:39.740]  Как это не вызовется?
[01:49:41.740 --> 01:49:43.740]  Нет, мы вот здесь вот
[01:49:43.740 --> 01:49:45.740]  n меньше равно нуля
[01:49:45.740 --> 01:49:47.740]  нас сделает throw 0.
[01:49:47.740 --> 01:49:49.740]  Ну, в общем-то...
[01:49:49.740 --> 01:49:51.740]  Это как доказывать,
[01:49:51.740 --> 01:49:53.740]  что корень из двух степени корень из двух
[01:49:53.740 --> 01:49:55.740]  рационален.
[01:49:55.740 --> 01:49:57.740]  Не очень понятно, что будет,
[01:49:57.740 --> 01:49:59.740]  но итог-то ясен.
[01:49:59.740 --> 01:50:01.740]  Ошибка компиляции.
[01:50:01.740 --> 01:50:03.740]  Что еще может случиться
[01:50:03.740 --> 01:50:05.740]  на этапе компиляции, если что-то пошло не так?
[01:50:05.740 --> 01:50:07.740]  Ну, наверное, ошибка компиляции.
[01:50:07.740 --> 01:50:09.740]  Мы не очень понимаем,
[01:50:09.740 --> 01:50:11.740]  умеет ли компилятор бросать исключения
[01:50:11.740 --> 01:50:13.740]  в compile-time или не умеет.
[01:50:13.740 --> 01:50:15.740]  Но в любом случае будет ошибка компиляции.
[01:50:15.740 --> 01:50:17.740]  Потому что в compile-time должна
[01:50:17.740 --> 01:50:19.740]  случиться ошибка.
[01:50:19.740 --> 01:50:21.740]  Значит...
[01:50:21.740 --> 01:50:23.740]  Так и будет.
[01:50:25.740 --> 01:50:27.740]  Так и будет.
[01:50:27.740 --> 01:50:29.740]  Throw expression из нота constant expression.
[01:50:33.740 --> 01:50:35.740]  Ну, просто он
[01:50:35.740 --> 01:50:37.740]  дошел до expression,
[01:50:37.740 --> 01:50:39.740]  он дошел до throw в compile-time.
[01:50:39.740 --> 01:50:41.740]  Короче, правило такое.
[01:50:41.740 --> 01:50:43.740]  Throw в constexpr функциях писать можно,
[01:50:43.740 --> 01:50:45.740]  при условии, что на него дело не доходит.
[01:50:45.740 --> 01:50:47.740]  Если на него дело доходит, то это ошибка компиляции.
[01:50:47.740 --> 01:50:49.740]  Короче, компиляция — это
[01:50:49.740 --> 01:50:51.740]  интерпретация.
[01:50:51.740 --> 01:50:53.740]  Очень похоже туда.
[01:50:53.740 --> 01:50:55.740]  Похоже на Python.
[01:50:55.740 --> 01:50:57.740]  Вот. Очень удобно.
[01:50:57.740 --> 01:50:59.740]  Ну, на самом деле так и в современных
[01:50:59.740 --> 01:51:01.740]  плюсах тоже.
[01:51:01.740 --> 01:51:03.740]  То есть можно писать throw
[01:51:03.740 --> 01:51:05.740]  в constexpr функциях, но просто если
[01:51:05.740 --> 01:51:07.740]  на него дело дойдет, то это будет ошибка компиляции.
[01:51:07.740 --> 01:51:09.740]  А, то есть это идея типа,
[01:51:09.740 --> 01:51:11.740]  что мы можем написать throw
[01:51:11.740 --> 01:51:13.740]  в constexpr функции, чтобы...
[01:51:13.740 --> 01:51:15.740]  Чтобы, если это...
[01:51:15.740 --> 01:51:17.740]  Компиляции ее вызывать, но там до throw не дойдет
[01:51:17.740 --> 01:51:19.740]  и нормально, а потом ее использовать в runtime
[01:51:19.740 --> 01:51:21.740]  в каком, условно, нормальном способу.
[01:51:21.740 --> 01:51:23.740]  Типа, чтобы оттуда...
[01:51:23.740 --> 01:51:25.740]  Да, это правда. Да, вот тут я вам,
[01:51:25.740 --> 01:51:27.740]  кстати, не сказал важную вещь, но давайте скажу
[01:51:27.740 --> 01:51:29.740]  сейчас, я хотел позже сказать.
[01:51:29.740 --> 01:51:31.740]  constexpr не означает, что эту функцию
[01:51:31.740 --> 01:51:33.740]  нельзя использовать в runtime.
[01:51:33.740 --> 01:51:35.740]  То, что функция constexpr
[01:51:35.740 --> 01:51:37.740]  не запрещает вам обычной переменной
[01:51:37.740 --> 01:51:39.740]  с помощью инициализировать в runtime.
[01:51:39.740 --> 01:51:41.740]  Вот.
[01:51:41.740 --> 01:51:43.740]  constexpr — это значит,
[01:51:43.740 --> 01:51:45.740]  что если вы эту функцию
[01:51:45.740 --> 01:51:47.740]  использовали в
[01:51:47.740 --> 01:51:49.740]  constexpr, то это корректно,
[01:51:49.740 --> 01:51:51.740]  и он будет пытаться ее вычислить на этапе компиляции.
[01:51:51.740 --> 01:51:53.740]  Но если вы ее используете
[01:51:53.740 --> 01:51:55.740]  для инициализации обычной переменной в runtime,
[01:51:55.740 --> 01:51:57.740]  он ничего плохого тоже не скажет.
[01:51:57.740 --> 01:51:59.740]  А он будет использоваться в результат вычислений,
[01:51:59.740 --> 01:52:01.740]  которые могли бы сегодня в runtime?
[01:52:01.740 --> 01:52:03.740]  В runtime?
[01:52:03.740 --> 01:52:05.740]  Нет. Думаю, нет.
[01:52:07.740 --> 01:52:09.740]  Ну, нет, он будет, я думаю, заново вычислять.
[01:52:09.740 --> 01:52:11.740]  Типа, сможет ли он
[01:52:11.740 --> 01:52:13.740]  соптимизировать и увидеть
[01:52:13.740 --> 01:52:15.740]  заранее, что это предвычислить можно?
[01:52:15.740 --> 01:52:17.740]  Ну, для каких-то простых функций
[01:52:17.740 --> 01:52:19.740]  для маленьких значений может быть и сможет.
[01:52:19.740 --> 01:52:21.740]  Но в общем случае нет.
[01:52:21.740 --> 01:52:23.740]  Вот, короче, show
[01:52:23.740 --> 01:52:25.740]  вот так работает.
[01:52:25.740 --> 01:52:27.740]  Вот, здесь мы приходим к ответу на вопрос,
[01:52:27.740 --> 01:52:29.740]  а что же будет,
[01:52:29.740 --> 01:52:31.740]  если я, например, вот так
[01:52:31.740 --> 01:52:33.740]  напишу?
[01:52:37.740 --> 01:52:39.740]  Я отложил этот вопрос
[01:52:39.740 --> 01:52:41.740]  неспроста,
[01:52:41.740 --> 01:52:43.740]  потому что на самом деле ответ на него тоже
[01:52:45.740 --> 01:52:47.740]  такой же.
[01:52:47.740 --> 01:52:49.740]  То есть, что если я
[01:52:49.740 --> 01:52:51.740]  во время compile-time вычислений
[01:52:51.740 --> 01:52:53.740]  выйду за границу массива?
[01:52:55.740 --> 01:52:57.740]  Ну, вообще-то это
[01:52:57.740 --> 01:52:59.740]  должно быть, если бы это было
[01:52:59.740 --> 01:53:01.740]  в нормальном вычислении, то это было бы УБ.
[01:53:01.740 --> 01:53:03.740]  Но мы в compile-time
[01:53:03.740 --> 01:53:05.740]  находимся.
[01:53:05.740 --> 01:53:07.740]  А в compile-time
[01:53:07.740 --> 01:53:09.740]  это будет ошибкой компиляции,
[01:53:09.740 --> 01:53:11.740]  потому что он поймет, что
[01:53:11.740 --> 01:53:13.740]  мы вышли за границу массива.
[01:53:13.740 --> 01:53:15.740]  В compile-time умеет включать указатели на массивы от...
[01:53:15.740 --> 01:53:17.740]  Нет, в compile-time
[01:53:17.740 --> 01:53:19.740]  он запомнил, что размер, массив у него
[01:53:19.740 --> 01:53:21.740]  размера 20, и если мы обратились
[01:53:21.740 --> 01:53:23.740]  к элементу за границей,
[01:53:23.740 --> 01:53:25.740]  он это заметил во время компиляции.
[01:53:27.740 --> 01:53:29.740]  И сказал нам
[01:53:29.740 --> 01:53:31.740]  это ошибка компиляции.
[01:53:37.740 --> 01:53:39.740]  Вот.
[01:53:39.740 --> 01:53:41.740]  Если мы, короче, разыминовываем указатель...
[01:53:41.740 --> 01:53:43.740]  Да, вот, например...
[01:53:43.740 --> 01:53:45.740]  О, отличный, отличный, отличный вопрос.
[01:53:45.740 --> 01:53:47.740]  Давайте, подождите, подождите, подождите.
[01:53:47.740 --> 01:53:49.740]  Давайте-ка я вот что сделаю.
[01:53:51.740 --> 01:53:53.740]  Как вам такое?
[01:53:53.740 --> 01:53:55.740]  Я не перехожу за границу массива, я вот так делаю.
[01:53:55.740 --> 01:53:57.740]  Взяли мы
[01:53:57.740 --> 01:53:59.740]  адрес локальной переменной, увеличили его
[01:53:59.740 --> 01:54:01.740]  на один, то есть следующую за ним, как бы, взяли.
[01:54:01.740 --> 01:54:03.740]  И...
[01:54:05.740 --> 01:54:07.740]  Нет, run-timer в компиляторе, конечно,
[01:54:07.740 --> 01:54:09.740]  не будет.
[01:54:09.740 --> 01:54:11.740]  Да нет.
[01:54:11.740 --> 01:54:13.740]  Это...
[01:54:15.740 --> 01:54:17.740]  Подожди, нет, out of bounds это предыдущее было.
[01:54:17.740 --> 01:54:19.740]  Я взял,
[01:54:19.740 --> 01:54:21.740]  в compile-time сделал
[01:54:21.740 --> 01:54:23.740]  как бы уб. То есть я взял,
[01:54:23.740 --> 01:54:25.740]  вот, обратите внимание, на это он не поругался.
[01:54:25.740 --> 01:54:27.740]  Я взял адрес локальной переменной, увеличил на один.
[01:54:27.740 --> 01:54:29.740]  То есть взял как бы следующую по стеку.
[01:54:29.740 --> 01:54:31.740]  Ну, я
[01:54:31.740 --> 01:54:33.740]  я сделал нормальную операцию,
[01:54:33.740 --> 01:54:35.740]  сложил указатель с 4.
[01:54:35.740 --> 01:54:37.740]  Да то же самое, это все уб.
[01:54:37.740 --> 01:54:39.740]  Да, да, да, ну он перейдет к резлу.
[01:54:39.740 --> 01:54:41.740]  Да.
[01:54:41.740 --> 01:54:43.740]  Нет,
[01:54:43.740 --> 01:54:45.740]  это уб, ну в смысле
[01:54:45.740 --> 01:54:47.740]  нет, ну как, если это
[01:54:47.740 --> 01:54:49.740]  уб, то он...
[01:54:49.740 --> 01:54:51.740]  Типа он знает, что это уб, да?
[01:54:51.740 --> 01:54:53.740]  Он знает, что это уб и будет давать ошибку.
[01:54:53.740 --> 01:54:55.740]  Я не могу,
[01:54:55.740 --> 01:54:57.740]  я не могу присваивать этому адресу,
[01:54:57.740 --> 01:54:59.740]  потому что он уже все, он не указывает
[01:54:59.740 --> 01:55:01.740]  ни на какое корректное место...
[01:55:01.740 --> 01:55:03.740]  Он в compile-time умеет,
[01:55:03.740 --> 01:55:05.740]  видите, ловить уб.
[01:55:05.740 --> 01:55:07.740]  В смысле уб не в том, что
[01:55:07.740 --> 01:55:09.740]  его не обрабатывается?
[01:55:09.740 --> 01:55:11.740]  Ну не в compile-time же.
[01:55:13.740 --> 01:55:15.740]  Не, ну кажется, что
[01:55:15.740 --> 01:55:17.740]  типа в compile-time он тогда может им по полной
[01:55:17.740 --> 01:55:19.740]  задачи нам пытаться решать. Почему?
[01:55:19.740 --> 01:55:21.740]  Ну потому что... Нет, подожди,
[01:55:21.740 --> 01:55:23.740]  нет, подожди, во-первых, им по полной задачи
[01:55:23.740 --> 01:55:25.740]  нет никакой проблемы решать, просто они долго
[01:55:25.740 --> 01:55:27.740]  решают. Ну да, ну в compile-time
[01:55:27.740 --> 01:55:29.740]  и убы проверяют, и даже если убы
[01:55:29.740 --> 01:55:31.740]  определить им по полной задачи, он тоже
[01:55:31.740 --> 01:55:33.740]  может проверять. Ну он просто
[01:55:33.740 --> 01:55:35.740]  долго компилироваться будет.
[01:55:35.740 --> 01:55:37.740]  Нет, просто смотри.
[01:55:37.740 --> 01:55:39.740]  Проблемы остановки он в compile-time не решит,
[01:55:39.740 --> 01:55:41.740]  конечно, но это по полной задача
[01:55:41.740 --> 01:55:43.740]  вполне.
[01:55:43.740 --> 01:55:45.740]  Он будет просто 2 часа компилировать,
[01:55:45.740 --> 01:55:47.740]  потому что он хочет все обгонять.
[01:55:47.740 --> 01:55:49.740]  Не, не, в смысле, у нас же очень простая штука.
[01:55:49.740 --> 01:55:51.740]  Почему мы в целом не ловим уб
[01:55:51.740 --> 01:55:53.740]  в compile-time? Потому что это невозможно
[01:55:53.740 --> 01:55:55.740]  типа... Почему мы
[01:55:55.740 --> 01:55:57.740]  не ловим уб в runtime? Потому что это долго.
[01:55:57.740 --> 01:55:59.740]  Ну да. Мы не обвешиваем себя
[01:55:59.740 --> 01:56:01.740]  проверками, потому что
[01:56:01.740 --> 01:56:03.740]  мы не хотим, чтобы был питон.
[01:56:03.740 --> 01:56:05.740]  Мы хотим как бы рисковать.
[01:56:05.740 --> 01:56:07.740]  Мы хотим жить рискованно.
[01:56:07.740 --> 01:56:09.740]  Когда пишем на плюсах.
[01:56:09.740 --> 01:56:11.740]  В compile-time мы не хотим жить рискованно,
[01:56:11.740 --> 01:56:13.740]  а он убы отлавливает.
[01:56:13.740 --> 01:56:15.740]  Другой пример. Еще один пример
[01:56:15.740 --> 01:56:17.740]  сейчас вам покажу. Окей.
[01:56:17.740 --> 01:56:19.740]  Давайте
[01:56:19.740 --> 01:56:21.740]  я в этом цикле добавлю еще одну операцию.
[01:56:23.740 --> 01:56:25.740]  Я вот что сделаю.
[01:56:31.740 --> 01:56:33.740]  Ой.
[01:56:33.740 --> 01:56:35.740]  Вот.
[01:56:35.740 --> 01:56:37.740]  Я заведу некоторые int и буду его
[01:56:37.740 --> 01:56:39.740]  умножать на миллион двадцать раз.
[01:56:39.740 --> 01:56:41.740]  Что произойдет? Ну, конечно же,
[01:56:41.740 --> 01:56:43.740]  переполнение int. И это тоже
[01:56:43.740 --> 01:56:45.740]  ошибка компиляции.
[01:56:45.740 --> 01:56:47.740]  Переполнение int в compile-time, и вот вам и ошибка компиляции.
[01:56:49.740 --> 01:56:51.740]  Хорошо. Вопрос на что. Если мы возьмем
[01:56:51.740 --> 01:56:53.740]  указатель, как бы на конец памяти,
[01:56:53.740 --> 01:56:55.740]  которая будет доступна,
[01:56:55.740 --> 01:56:57.740]  мы берем плюс один?
[01:56:57.740 --> 01:56:59.740]  Вот именно не будем по нему ничего записывать,
[01:56:59.740 --> 01:57:01.740]  но просто указатель.
[01:57:01.740 --> 01:57:03.740]  Так ничего страшного. Я же только что там делал.
[01:57:03.740 --> 01:57:05.740]  Инкремент указатель
[01:57:05.740 --> 01:57:07.740]  это ничего страшного.
[01:57:07.740 --> 01:57:09.740]  Теперь он указывает не куда-то, куда нельзя,
[01:57:09.740 --> 01:57:11.740]  а просто туда, куда вообще не существует.
[01:57:13.740 --> 01:57:15.740]  Подожди. А в чем разница
[01:57:15.740 --> 01:57:17.740]  между существует или
[01:57:17.740 --> 01:57:19.740]  то, куда нельзя? Вот когда я так написал.
[01:57:21.740 --> 01:57:23.740]  Ну, вот когда я так написал,
[01:57:23.740 --> 01:57:25.740]  это тоже как бы конец памяти,
[01:57:25.740 --> 01:57:27.740]  которая нам доступна.
[01:57:29.740 --> 01:57:31.740]  Короче,
[01:57:31.740 --> 01:57:33.740]  просто компилятор отслеживает,
[01:57:33.740 --> 01:57:35.740]  что все обращения к указателям корректны.
[01:57:35.740 --> 01:57:37.740]  Если не корректны, то все, падение.
[01:57:39.740 --> 01:57:41.740]  Вот, ну хорошо.
[01:57:43.740 --> 01:57:45.740]  Ладно, окей.
[01:57:47.740 --> 01:57:49.740]  На самом деле,
[01:57:49.740 --> 01:57:51.740]  эта пара, это просто
[01:57:55.740 --> 01:57:57.740]  Main, я думаю, нельзя.
[01:57:59.740 --> 01:58:01.740]  На самом деле, сегодня
[01:58:01.740 --> 01:58:03.740]  вот эта вот пара, это
[01:58:03.740 --> 01:58:05.740]  такой, краткое
[01:58:05.740 --> 01:58:07.740]  повторение всего того, что мы проходили
[01:58:07.740 --> 01:58:09.740]  с переосмыслением.
[01:58:09.740 --> 01:58:11.740]  Вот мы с вами
[01:58:11.740 --> 01:58:13.740]  поговорили об указателях,
[01:58:13.740 --> 01:58:15.740]  об UB при переполнении указателей, о ссылках,
[01:58:15.740 --> 01:58:17.740]  о константах. Давайте поговорим
[01:58:17.740 --> 01:58:19.740]  про OOP теперь.
[01:58:19.740 --> 01:58:21.740]  Давайте заново
[01:58:21.740 --> 01:58:23.740]  поизвучаем классы.
[01:58:23.740 --> 01:58:25.740]  Вот, например, я могу
[01:58:25.740 --> 01:58:27.740]  завести структуру.
[01:58:27.740 --> 01:58:29.740]  Подожди, подожди, подожди, подожди.
[01:58:29.740 --> 01:58:31.740]  Не торопись.
[01:58:31.740 --> 01:58:33.740]  Вот у меня есть структура
[01:58:33.740 --> 01:58:35.740]  с двумя полями.
[01:58:35.740 --> 01:58:37.740]  Как насчет завести объект этой структуры?
[01:58:39.740 --> 01:58:41.740]  Ну и что-нибудь поприсваивать ему, например.
[01:58:41.740 --> 01:58:43.740]  Ну кажется, что
[01:58:43.740 --> 01:58:45.740]  все еще все хорошо.
[01:58:45.740 --> 01:58:47.740]  Чем это отличается от того, что мы завели int?
[01:58:49.740 --> 01:58:51.740]  Совершенно ничем не отличается, ты прав, да.
[01:58:53.740 --> 01:58:55.740]  Только у меня нет
[01:58:55.740 --> 01:58:57.740]  икса, ну ничего страшного.
[01:58:57.740 --> 01:58:59.740]  Да, да, пожалуйста.
[01:58:59.740 --> 01:59:01.740]  Я могу
[01:59:01.740 --> 01:59:03.740]  запросто...
[01:59:03.740 --> 01:59:05.740]  Иппоинтера нет.
[01:59:05.740 --> 01:59:07.740]  Какая жалость.
[01:59:09.740 --> 01:59:11.740]  А ты звездочку
[01:59:11.740 --> 01:59:13.740]  смотри и все.
[01:59:13.740 --> 01:59:15.740]  Да, я могу
[01:59:15.740 --> 01:59:17.740]  запросто создать объект
[01:59:17.740 --> 01:59:19.740]  структуры в compile-time, но
[01:59:19.740 --> 01:59:21.740]  только начиная с C++.
[01:59:21.740 --> 01:59:23.740]  Смех.
[01:59:23.740 --> 01:59:25.740]  Мне кажется,
[01:59:25.740 --> 01:59:27.740]  C++ что-то вложает,
[01:59:27.740 --> 01:59:29.740]  потому что в C++14, кажется,
[01:59:29.740 --> 01:59:31.740]  нельзя было.
[01:59:37.740 --> 01:59:39.740]  Нет, все равно.
[01:59:39.740 --> 01:59:41.740]  Ну, может и в 14.
[01:59:41.740 --> 01:59:43.740]  Ладно, не будем былое вспоминать.
[01:59:43.740 --> 01:59:45.740]  В общем, можно и в 14.
[01:59:45.740 --> 01:59:47.740]  Хорошо, а если у этой структуры не тривиальный
[01:59:47.740 --> 01:59:49.740]  конструктор?
[01:59:49.740 --> 01:59:51.740]  Конструктор, может ли
[01:59:51.740 --> 01:59:53.740]  констэкспорт пометить?
[01:59:53.740 --> 01:59:55.740]  Это отличный вопрос.
[01:59:55.740 --> 01:59:57.740]  Если не пометчен, то, видимо, нет.
[01:59:57.740 --> 01:59:59.740]  Все, совершенно верно.
[01:59:59.740 --> 02:00:01.740]  Вот сейчас будет нельзя, потому что
[02:00:01.740 --> 02:00:03.740]  вызов конструктора...
[02:00:03.740 --> 02:00:05.740]  Ну, он, очевидно, может вызывать что угодно,
[02:00:05.740 --> 02:00:07.740]  делать там сины, сеалты.
[02:00:07.740 --> 02:00:09.740]  Да, вызов конструктора не констэкспорт.
[02:00:09.740 --> 02:00:11.740]  Но если конструктор констэкспорт,
[02:00:11.740 --> 02:00:13.740]  то почему бы и нет?
[02:00:15.740 --> 02:00:17.740]  Ну, логично.
[02:00:17.740 --> 02:00:19.740]  Шаблоны и так в Compile Timer делаются.
[02:00:19.740 --> 02:00:21.740]  Вот, но у меня теперь нету...
[02:00:21.740 --> 02:00:23.740]  В 14 угасится прикладение?
[02:00:23.740 --> 02:00:25.740]  Нет, нет, нет. У него теперь нету...
[02:00:25.740 --> 02:00:27.740]  Это обычная ошибка, и она была бы
[02:00:27.740 --> 02:00:29.740]  и без констэкспорта.
[02:00:29.740 --> 02:00:31.740]  Все нормально. Конструктор вызвался
[02:00:31.740 --> 02:00:33.740]  в Compile Timer.
[02:00:35.740 --> 02:00:37.740]  Вот.
[02:00:39.740 --> 02:00:41.740]  Ну, потому что я
[02:00:41.740 --> 02:00:43.740]  примеры просто разбираю.
[02:00:43.740 --> 02:00:45.740]  Хорошо.
[02:00:45.740 --> 02:00:47.740]  Ну, понятно, что...
[02:00:47.740 --> 02:00:49.740]  Понятно, что дальше это
[02:00:49.740 --> 02:00:51.740]  распространяется на все методы.
[02:00:51.740 --> 02:00:53.740]  Я могу точно так же сделать конструктор копирования,
[02:00:53.740 --> 02:00:55.740]  конструктор перемещения,
[02:00:55.740 --> 02:00:57.740]  деструктор, оператор присваивания.
[02:00:57.740 --> 02:00:59.740]  Если они все...
[02:00:59.740 --> 02:01:01.740]  Вот до тех пор, пока все это констэкспорт,
[02:01:01.740 --> 02:01:03.740]  оно запросто может отсюда
[02:01:03.740 --> 02:01:05.740]  вызываться.
[02:01:05.740 --> 02:01:07.740]  А в чем отличие от функции?
[02:01:07.740 --> 02:01:09.740]  Вот.
[02:01:09.740 --> 02:01:11.740]  Возможно, вы замечали,
[02:01:11.740 --> 02:01:13.740]  когда...
[02:01:13.740 --> 02:01:15.740]  Значит...
[02:01:17.740 --> 02:01:19.740]  Да.
[02:01:19.740 --> 02:01:21.740]  Заходили на... Заходили на
[02:01:21.740 --> 02:01:23.740]  cpp-reference,
[02:01:23.740 --> 02:01:25.740]  вы, возможно, замечали,
[02:01:25.740 --> 02:01:27.740]  что
[02:01:27.740 --> 02:01:29.740]  слово констэкспор, оно много где.
[02:01:29.740 --> 02:01:31.740]  Это все потому,
[02:01:31.740 --> 02:01:33.740]  что все это, на самом деле,
[02:01:33.740 --> 02:01:35.740]  можно вызывать в констэкспор функциях.
[02:01:35.740 --> 02:01:37.740]  Правда, начиная с C++20?
[02:01:39.740 --> 02:01:41.740]  Вот.
[02:01:41.740 --> 02:01:43.740]  Ну, все эти алгоритмы,
[02:01:43.740 --> 02:01:45.740]  начиная с C++20,
[02:01:45.740 --> 02:01:47.740]  написаны так, что они работают в констэкспоре.
[02:01:47.740 --> 02:01:49.740]  И STD sort можно вызывать в констэкспоре.
[02:01:49.740 --> 02:01:51.740]  Это логично.
[02:01:51.740 --> 02:01:53.740]  Это логично, конечно.
[02:01:53.740 --> 02:01:55.740]  Хорошо, что для вас уже логично.
[02:01:55.740 --> 02:01:57.740]  Чем это нужно?
[02:01:57.740 --> 02:01:59.740]  Если ты хочешь в compile-time
[02:01:59.740 --> 02:02:01.740]  предвычислить что-то,
[02:02:01.740 --> 02:02:03.740]  там, я не знаю,
[02:02:03.740 --> 02:02:05.740]  какой-нибудь решетой ротосфена в compile-time написать,
[02:02:05.740 --> 02:02:07.740]  и вот у тебя предвычисленные простые числа
[02:02:07.740 --> 02:02:09.740]  до какого-то.
[02:02:09.740 --> 02:02:11.740]  Мне бы это лучше сделать
[02:02:11.740 --> 02:02:13.740]  в начале мейна.
[02:02:13.740 --> 02:02:15.740]  Потому что они у тебя будут в бинарник зашиты,
[02:02:15.740 --> 02:02:17.740]  и когда ты запустишь,
[02:02:17.740 --> 02:02:19.740]  они уже готовы у тебя, предвычисленные.
[02:02:19.740 --> 02:02:21.740]  Ты можешь захотеть вычислить
[02:02:21.740 --> 02:02:23.740]  все простые числа до 1.e8
[02:02:23.740 --> 02:02:25.740]  до запуска программы.
[02:02:25.740 --> 02:02:27.740]  Например, пусть тебе надо упихать.
[02:02:27.740 --> 02:02:29.740]  В смысле?
[02:02:29.740 --> 02:02:31.740]  Это вряд ли будет
[02:02:31.740 --> 02:02:33.740]  быстрее.
[02:02:33.740 --> 02:02:35.740]  Это один раз при компиляции произойдет,
[02:02:35.740 --> 02:02:37.740]  а дальше...
[02:02:37.740 --> 02:02:39.740]  Ты вычисляешь это при компиляции,
[02:02:39.740 --> 02:02:41.740]  и в a.out уже зашит ответ.
[02:02:41.740 --> 02:02:43.740]  По-моему, это чуть ли не
[02:02:43.740 --> 02:02:45.740]  эталон олимпиады с ПБГУ.
[02:02:45.740 --> 02:02:47.740]  Насколько это дольше,
[02:02:47.740 --> 02:02:49.740]  чем в runtime в среднем?
[02:02:49.740 --> 02:02:51.740]  Что значит в среднем?
[02:02:51.740 --> 02:02:53.740]  В смысле,
[02:02:53.740 --> 02:02:55.740]  однократно вычислить?
[02:02:55.740 --> 02:02:57.740]  В compile-time
[02:02:57.740 --> 02:02:59.740]  вычисления
[02:02:59.740 --> 02:03:01.740]  делаются дольше,
[02:03:01.740 --> 02:03:03.740]  чем в runtime.
[02:03:03.740 --> 02:03:05.740]  Во сколько раз,
[02:03:05.740 --> 02:03:07.740]  я не знаю.
[02:03:07.740 --> 02:03:09.740]  На олимпиаде с ПБГУ
[02:03:09.740 --> 02:03:11.740]  дольше чем?
[02:03:11.740 --> 02:03:13.740]  Я не знаю.
[02:03:13.740 --> 02:03:15.740]  Я, к сожалению, не могу ответить.
[02:03:15.740 --> 02:03:17.740]  Но runtime запускается многократно,
[02:03:17.740 --> 02:03:19.740]  а compile-time однократно.
[02:03:19.740 --> 02:03:21.740]  Ну-ка.
[02:03:21.740 --> 02:03:23.740]  Вот.
[02:03:23.740 --> 02:03:25.740]  Ну ладно.
[02:03:25.740 --> 02:03:27.740]  А что все-таки насчет...
[02:03:29.740 --> 02:03:31.740]  Еще обращение к конструкции
[02:03:31.740 --> 02:03:33.740]  быстрее, чем обращение
[02:03:33.740 --> 02:03:35.740]  к динамическому памяти.
[02:03:37.740 --> 02:03:39.740]  Ты можешь просто ответить, чтобы это...
[02:03:39.740 --> 02:03:41.740]  Насчет вот такого.
[02:03:41.740 --> 02:03:43.740]  Ну, это же...
[02:03:43.740 --> 02:03:45.740]  Это не может быть...
[02:03:45.740 --> 02:03:47.740]  Это не может быть!
[02:03:47.740 --> 02:03:49.740]  Я не верю!
[02:03:49.740 --> 02:03:51.740]  Это невозможно!
[02:03:51.740 --> 02:03:53.740]  Такого быть не может!
[02:03:53.740 --> 02:03:55.740]  Это будет...
[02:03:55.740 --> 02:03:57.740]  Какая динамическая память?
[02:03:57.740 --> 02:03:59.740]  Он не выделяет динамическую!
[02:03:59.740 --> 02:04:01.740]  Он тебя выделит в той,
[02:04:01.740 --> 02:04:03.740]  на все он просто делает...
[02:04:03.740 --> 02:04:05.740]  Теперь никто не гертирует, что ньюд
[02:04:05.740 --> 02:04:07.740]  не выделит динамическую, блин!
[02:04:07.740 --> 02:04:09.740]  Он знал.
[02:04:09.740 --> 02:04:11.740]  А если я выделю...
[02:04:11.740 --> 02:04:13.740]  Итак, ваши гипотезы.
[02:04:13.740 --> 02:04:15.740]  Что же все-таки будет?
[02:04:15.740 --> 02:04:17.740]  Я же прав, что ньюд не гарантирует, что он
[02:04:17.740 --> 02:04:19.740]  в динамической памяти выделяет.
[02:04:19.740 --> 02:04:21.740]  Я видел много, и это увидел.
[02:04:21.740 --> 02:04:23.740]  То есть вот это вот...
[02:04:23.740 --> 02:04:25.740]  Что делает дилит? Он бинарники чистит или что?
[02:04:25.740 --> 02:04:27.740]  Он просто скажет, что это
[02:04:27.740 --> 02:04:29.740]  освобождено, и по идее...
[02:04:29.740 --> 02:04:31.740]  По идее он не должен просто ее выделить.
[02:04:35.740 --> 02:04:37.740]  А вы можете дилит пока не вызывать?
[02:04:37.740 --> 02:04:39.740]  Он будет часто вызывать
[02:04:39.740 --> 02:04:41.740]  какой-нибудь констэкспер нью
[02:04:41.740 --> 02:04:43.740]  и констэкспер дилит, нет?
[02:04:43.740 --> 02:04:45.740]  Ну вот тут-то все-таки мне наконец-то
[02:04:45.740 --> 02:04:47.740]  C++14 отказывает.
[02:04:47.740 --> 02:04:49.740]  Не могу я
[02:04:49.740 --> 02:04:51.740]  вызвать, извините, пожалуйста,
[02:04:51.740 --> 02:04:53.740]  вось звездочки оператор нью
[02:04:53.740 --> 02:04:55.740]  в квадратной скобочке.
[02:04:55.740 --> 02:04:57.740]  Он не констэкспер.
[02:04:57.740 --> 02:04:59.740]  А как же насчет
[02:04:59.740 --> 02:05:01.740]  двадцатых плюсов, интересно.
[02:05:01.740 --> 02:05:03.740]  Давайте посмотрим,
[02:05:03.740 --> 02:05:05.740]  что представляет из себя
[02:05:05.740 --> 02:05:07.740]  оператор нью в двадцатых плюсах.
[02:05:11.740 --> 02:05:13.740]  Да, почему-то констэкспер здесь
[02:05:13.740 --> 02:05:15.740]  не написано. Ну, ничего.
[02:05:15.740 --> 02:05:17.740]  Можно.
[02:05:21.740 --> 02:05:23.740]  Значит, вот теперь,
[02:05:23.740 --> 02:05:25.740]  вот сейчас,
[02:05:25.740 --> 02:05:27.740]  вот сейчас
[02:05:29.740 --> 02:05:31.740]  вот сейчас начинается
[02:05:35.740 --> 02:05:37.740]  я хочу увидеть настоящее
[02:05:37.740 --> 02:05:39.740]  CompileTime вычисление.
[02:05:39.740 --> 02:05:41.740]  Я сказал настоящее CompileTime вычисление.
[02:05:41.740 --> 02:05:43.740]  Это только начиная C++20
[02:05:43.740 --> 02:05:45.740]  можно. Значит,
[02:05:45.740 --> 02:05:47.740]  начиная C++20
[02:05:47.740 --> 02:05:49.740]  можно делать нью и дилит
[02:05:49.740 --> 02:05:51.740]  в CompileTime
[02:05:51.740 --> 02:05:53.740]  констэкспер.
[02:05:53.740 --> 02:05:55.740]  Дилит, видимо, не делает ничего, кроме вызывать дистанктуру.
[02:05:55.740 --> 02:05:57.740]  Не, ну как?
[02:05:57.740 --> 02:05:59.740]  В смысле память то он не должен вычислять.
[02:05:59.740 --> 02:06:01.740]  Что такое память?
[02:06:01.740 --> 02:06:03.740]  Насколько я понимаю,
[02:06:03.740 --> 02:06:05.740]  здесь ньюин 100 просто
[02:06:05.740 --> 02:06:07.740]  на стеке
[02:06:07.740 --> 02:06:09.740]  выделяет
[02:06:09.740 --> 02:06:11.740]  под стоим то память.
[02:06:11.740 --> 02:06:13.740]  Вот что если я закомментирую дилит в квадратной скобочке?
[02:06:13.740 --> 02:06:15.740]  Как вы думаете?
[02:06:15.740 --> 02:06:17.740]  А будет ошибка компиляции?
[02:06:17.740 --> 02:06:19.740]  А потому что я не освободил?
[02:06:19.740 --> 02:06:21.740]  Ну,
[02:06:21.740 --> 02:06:23.740]  утечка памяти
[02:06:23.740 --> 02:06:25.740]  она тоже в CompileTime
[02:06:25.740 --> 02:06:27.740]  отлавливается.
[02:06:27.740 --> 02:06:29.740]  Но это
[02:06:29.740 --> 02:06:31.740]  УБ.
[02:06:31.740 --> 02:06:33.740]  Смотрите,
[02:06:33.740 --> 02:06:35.740]  как это прекрасно.
[02:06:35.740 --> 02:06:37.740]  В CompileTime вы можете
[02:06:37.740 --> 02:06:39.740]  пользоваться нью и дилитом,
[02:06:39.740 --> 02:06:41.740]  и если вы дилит сделаете
[02:06:41.740 --> 02:06:43.740]  случайно, лишний раз,
[02:06:43.740 --> 02:06:45.740]  или забудете сделать,
[02:06:45.740 --> 02:06:47.740]  или сделаете по неправильному адресу,
[02:06:47.740 --> 02:06:49.740]  то это будет CE.
[02:06:49.740 --> 02:06:51.740]  Компилятор в CompileTime отслеживает
[02:06:51.740 --> 02:06:53.740]  корректность нью и дилит.
[02:06:53.740 --> 02:06:55.740]  Вот если я сделаю дилит без квадратных скобочек,
[02:06:55.740 --> 02:06:57.740]  то это тоже CE,
[02:06:57.740 --> 02:06:59.740]  потому что должна быть диалокация массива,
[02:06:59.740 --> 02:07:01.740]  а я сделал диалокацию просто НТА.
[02:07:01.740 --> 02:07:03.740]  С наследованием все хорошо?
[02:07:03.740 --> 02:07:05.740]  С каким наследованием?
[02:07:05.740 --> 02:07:07.740]  Если мы будем пытаться все эти кулькологи
[02:07:07.740 --> 02:07:09.740]  проворачивать.
[02:07:09.740 --> 02:07:11.740]  Какие?
[02:07:11.740 --> 02:07:13.740]  Виртуальные функции?
[02:07:13.740 --> 02:07:15.740]  Не, подожди.
[02:07:15.740 --> 02:07:17.740]  У меня есть ощущение, что
[02:07:17.740 --> 02:07:19.740]  Компилятор написал космический корабль,
[02:07:19.740 --> 02:07:21.740]  потом отрубил ему крылья,
[02:07:21.740 --> 02:07:23.740]  заменил шасси...
[02:07:23.740 --> 02:07:25.740]  Космический корабль тоже добавили
[02:07:25.740 --> 02:07:27.740]  в C++20, я напоминаю.
[02:07:27.740 --> 02:07:29.740]  Шасси на шины или на лыжи
[02:07:29.740 --> 02:07:31.740]  и выкидывал на вход...
[02:07:31.740 --> 02:07:33.740]  Космический корабль уже есть, вот он.
[02:07:33.740 --> 02:07:35.740]  Мы его уже изучали в первом семесте.
[02:07:35.740 --> 02:07:37.740]  Так что даже шутка про космический корабль
[02:07:37.740 --> 02:07:39.740]  уже не актуальна. Короче,
[02:07:39.740 --> 02:07:41.740]  в C++20 можно выделять
[02:07:41.740 --> 02:07:43.740]  динамическую память,
[02:07:43.740 --> 02:07:45.740]  но я ее облачил в Compile Timer.
[02:07:45.740 --> 02:07:47.740]  А можно сейчас проверить одну штуку?
[02:07:47.740 --> 02:07:49.740]  Если выделить там, типа, 10 в седьмой.
[02:07:49.740 --> 02:07:51.740]  На стеке это очевидно
[02:07:51.740 --> 02:07:53.740]  не выделится.
[02:07:53.740 --> 02:07:55.740]  Она как мне должна выделиться?
[02:07:57.740 --> 02:07:59.740]  Ну, это не 10 в седьмой немножко,
[02:07:59.740 --> 02:08:01.740]  но ладно.
[02:08:01.740 --> 02:08:03.740]  Ой, извините.
[02:08:03.740 --> 02:08:05.740]  Да, давайте я не буду
[02:08:05.740 --> 02:08:07.740]  лучше выделять.
[02:08:07.740 --> 02:08:09.740]  Четыре гигабайта.
[02:08:09.740 --> 02:08:11.740]  Да, четыре гигабайта я немножко
[02:08:11.740 --> 02:08:13.740]  приемно.
[02:08:13.740 --> 02:08:15.740]  Я не хочу еще раз переустанавливать.
[02:08:15.740 --> 02:08:17.740]  Да, ну...
[02:08:17.740 --> 02:08:19.740]  Делить квадратные скобочки.
[02:08:19.740 --> 02:08:21.740]  Он дошел
[02:08:21.740 --> 02:08:23.740]  до этого дилета, значит он скобок.
[02:08:23.740 --> 02:08:25.740]  Можно еще вновь добавить?
[02:08:25.740 --> 02:08:27.740]  Нет, ну,
[02:08:27.740 --> 02:08:29.740]  короче, нет, ему ничего не мешает.
[02:08:29.740 --> 02:08:31.740]  То есть, что...
[02:08:31.740 --> 02:08:33.740]  Давайте подумаем, что
[02:08:33.740 --> 02:08:35.740]  происходит, как это работает.
[02:08:35.740 --> 02:08:37.740]  А представьте, что вы...
[02:08:37.740 --> 02:08:39.740]  Давайте представим, что мы реализуем,
[02:08:39.740 --> 02:08:41.740]  что нам так не повезло в жизни, что мы
[02:08:41.740 --> 02:08:43.740]  реализуем, значит, фантазии Комитета
[02:08:43.740 --> 02:08:45.740]  по стандартизации, и вот мы
[02:08:45.740 --> 02:08:47.740]  реализуем компилятор C++20. Как бы мы
[02:08:47.740 --> 02:08:49.740]  это сделали? Да очень просто.
[02:08:49.740 --> 02:08:51.740]  Мы просто эмулируем в CompileTime.
[02:08:51.740 --> 02:08:53.740]  Что, по сути, делает компилятор?
[02:08:53.740 --> 02:08:55.740]  Он видит этот код, и он просто
[02:08:55.740 --> 02:08:57.740]  эмулирует, пока компилирует, он берет
[02:08:57.740 --> 02:08:59.740]  и делает все то, что он делал бы.
[02:08:59.740 --> 02:09:01.740]  Ну, все те инструкции,
[02:09:01.740 --> 02:09:03.740]  которые бы в Рантайме происходили,
[02:09:03.740 --> 02:09:05.740]  просто компилятор запускает как бы программу.
[02:09:05.740 --> 02:09:07.740]  Никаких проблем.
[02:09:07.740 --> 02:09:09.740]  Но только дополнительно нужно
[02:09:09.740 --> 02:09:11.740]  доделать, чтобы он проверял...
[02:09:11.740 --> 02:09:13.740]  Ну, он обвешивает дополнительно проверками,
[02:09:13.740 --> 02:09:15.740]  что УБ нету.
[02:09:15.740 --> 02:09:17.740]  Но, по сути, ведь ничего нового, кроме...
[02:09:17.740 --> 02:09:19.740]  Ну, что здесь новое принципиально?
[02:09:19.740 --> 02:09:21.740]  То, что компилятор теперь еще умеет
[02:09:21.740 --> 02:09:23.740]  проверять отсутствие УБ.
[02:09:23.740 --> 02:09:25.740]  То есть, это реально динамическая
[02:09:25.740 --> 02:09:27.740]  партия? Ну, это динамическая...
[02:09:27.740 --> 02:09:29.740]  Ну, а что? Я говорю компилятору,
[02:09:29.740 --> 02:09:31.740]  запроси, пожалуйста,
[02:09:31.740 --> 02:09:33.740]  у операционной системы 100
[02:09:33.740 --> 02:09:35.740]  мегабайт, допустим. Что он должен делать?
[02:09:35.740 --> 02:09:37.740]  Он изначально, когда запустился сам компилятор,
[02:09:37.740 --> 02:09:39.740]  у него же, наверно, не было 100 мегабайт,
[02:09:39.740 --> 02:09:41.740]  но он говорит, ну, че, окей,
[02:09:41.740 --> 02:09:43.740]  пока компилирую, мне 100 мегабайт понадобилось.
[02:09:43.740 --> 02:09:45.740]  Он запрашивает, операционная система его выдает.
[02:09:45.740 --> 02:09:47.740]  Ну, то есть, это реально
[02:09:47.740 --> 02:09:49.740]  динамическая память. Если здесь
[02:09:49.740 --> 02:09:51.740]  мало памяти, то может компилятор
[02:09:51.740 --> 02:09:53.740]  как-то своей памятью обходится? Мы не знаем.
[02:09:53.740 --> 02:09:55.740]  Но если это много памяти,
[02:09:55.740 --> 02:09:57.740]  ну, окей, просто компилятор пока компилирует,
[02:09:57.740 --> 02:09:59.740]  сам запрашивает динамическую память у операционной
[02:09:59.740 --> 02:10:01.740]  она ему выдает, потом он ее отдаёт
[02:10:01.740 --> 02:10:03.740]  обратно. Он просто, по сути,
[02:10:03.740 --> 02:10:05.740]  не эмулирует. Он же умеет генерировать
[02:10:05.740 --> 02:10:07.740]  инструкции под этим. Вот он их и выполняет.
[02:10:07.740 --> 02:10:09.740]  На самом деле, очень стрёмный вопрос,
[02:10:09.740 --> 02:10:11.740]  а многопоточка в CompileTime
[02:10:11.740 --> 02:10:13.740]  возможно?
[02:10:13.740 --> 02:10:15.740]  А что именно
[02:10:15.740 --> 02:10:17.740]  ты понимаешь под многопоточкой?
[02:10:17.740 --> 02:10:19.740]  Ну, мы же
[02:10:19.740 --> 02:10:21.740]  из компилятора
[02:10:21.740 --> 02:10:23.740]  в CompileTime считать какие-то очень сложные
[02:10:23.740 --> 02:10:25.740]  задачи? Нет, что
[02:10:25.740 --> 02:10:27.740]  именно ты поднимаешь под многопоточку? Запустить
[02:10:27.740 --> 02:10:29.740]  другой трет в CompileTime?
[02:10:29.740 --> 02:10:31.740]  То есть, бывают они, допустим,
[02:10:31.740 --> 02:10:33.740]  что-нибудь из
[02:10:33.740 --> 02:10:35.740]  header, который execution
[02:10:35.740 --> 02:10:37.740]  вроде называется, и пытаться
[02:10:37.740 --> 02:10:39.740]  какой-то распараллельный алгоритм просто навосить?
[02:10:39.740 --> 02:10:41.740]  Ну да. Что-то вот такое.
[02:10:41.740 --> 02:10:43.740]  Ну, я думаю, что
[02:10:43.740 --> 02:10:45.740]  просто трет нельзя, потому что
[02:10:45.740 --> 02:10:47.740]  у него конструктор не constexpr, вот и
[02:10:47.740 --> 02:10:49.740]  всё.
[02:10:49.740 --> 02:10:51.740]  Если вы про это. Ну, всё,
[02:10:51.740 --> 02:10:53.740]  он не constexpr. Здравствуйте.
[02:10:53.740 --> 02:10:55.740]  А execution, скорее всего, просто есть
[02:10:55.740 --> 02:10:57.740]  constexpr-версия, которая делает
[02:10:57.740 --> 02:10:59.740]  одного worker и всё.
[02:10:59.740 --> 02:11:01.740]  Вот.
[02:11:01.740 --> 02:11:03.740]  Ну, короче, потоки заводить нельзя в CompileTime-е.
[02:11:05.740 --> 02:11:07.740]  Coroutine тоже нельзя,
[02:11:07.740 --> 02:11:09.740]  но давайте не будем об этом.
[02:11:09.740 --> 02:11:11.740]  Так написано,
[02:11:11.740 --> 02:11:13.740]  вот есть страничка
[02:11:15.740 --> 02:11:17.740]  в двадцатых плюсах появилась.
[02:11:17.740 --> 02:11:19.740]  Тихо,
[02:11:19.740 --> 02:11:21.740]  что?
[02:11:21.740 --> 02:11:23.740]  Вопрос. Правда ли, что
[02:11:23.740 --> 02:11:25.740]  механизм проверки на УВ
[02:11:25.740 --> 02:11:27.740]  он такой же, как санитайзеры?
[02:11:27.740 --> 02:11:29.740]  Что санитайзеры и проверка CompileTime?
[02:11:29.740 --> 02:11:31.740]  Вот этого я не знаю.
[02:11:31.740 --> 02:11:33.740]  Может быть, они написали свой,
[02:11:33.740 --> 02:11:35.740]  может быть, они позаимствовали.
[02:11:35.740 --> 02:11:37.740]  По логике, если компилятор
[02:11:37.740 --> 02:11:39.740]  умеет отлавливать всё УВ,
[02:11:39.740 --> 02:11:41.740]  то должны существовать
[02:11:41.740 --> 02:11:43.740]  и аналогичные санитайзеры.
[02:11:43.740 --> 02:11:45.740]  Что им жалко, что ли санитайзер
[02:11:45.740 --> 02:11:47.740]  такой же сделать?
[02:11:47.740 --> 02:11:49.740]  Ну, короче, вопрос хороший, я не знаю.
[02:11:49.740 --> 02:11:51.740]  Можно погуглить, можно
[02:11:51.740 --> 02:11:53.740]  настаковываться.
[02:11:53.740 --> 02:11:55.740]  Вот.
[02:11:55.740 --> 02:11:57.740]  Подождите, давайте дальше.
[02:11:59.740 --> 02:12:01.740]  Это ещё не всё.
[02:12:01.740 --> 02:12:03.740]  Почему-то все плюсы с 14 дают
[02:12:03.740 --> 02:12:05.740]  вызывать NewDelete без проблем.
[02:12:05.740 --> 02:12:07.740]  Ну, так не должно быть.
[02:12:07.740 --> 02:12:09.740]  Все плюсы с 14 не должно быть.
[02:12:09.740 --> 02:12:11.740]  Вот, окей, хорошо.
[02:12:11.740 --> 02:12:13.740]  Мы научились делать NewDelete в CompileTime.
[02:12:13.740 --> 02:12:15.740]  И это нам
[02:12:15.740 --> 02:12:17.740]  открывает замечательные возможности.
[02:12:17.740 --> 02:12:19.740]  Знаете какие? А это нам, например,
[02:12:19.740 --> 02:12:21.740]  открывает такие прекрасные возможности, как
[02:12:21.740 --> 02:12:23.740]  Как насчёт
[02:12:25.740 --> 02:12:27.740]  Как насчёт
[02:12:29.740 --> 02:12:31.740]  Господи.
[02:12:31.740 --> 02:12:33.740]  Как насчёт
[02:12:33.740 --> 02:12:35.740]  вот этого?
[02:12:35.740 --> 02:12:37.740]  Вы никогда не замечали,
[02:12:37.740 --> 02:12:39.740]  например,
[02:12:39.740 --> 02:12:41.740]  вы никогда внимательно не изучали
[02:12:41.740 --> 02:12:43.740]  страничку
[02:12:43.740 --> 02:12:45.740]  конструкторы-векторы?
[02:12:45.740 --> 02:12:47.740]  Вы замечали здесь
[02:12:47.740 --> 02:12:49.740]  вот это, например?
[02:12:49.740 --> 02:12:51.740]  Аааа!
[02:12:51.740 --> 02:12:53.740]  Вы думали о том,
[02:12:53.740 --> 02:12:55.740]  что это значит?
[02:12:55.740 --> 02:12:57.740]  Здесь написано Sync C++20.
[02:12:57.740 --> 02:12:59.740]  Совершенно верно.
[02:12:59.740 --> 02:13:01.740]  NewDelete в C++20 уже можно
[02:13:01.740 --> 02:13:03.740]  в CompileTime, так почему
[02:13:03.740 --> 02:13:05.740]  Vector тогда нельзя?
[02:13:05.740 --> 02:13:07.740]  Значит, String и Vector
[02:13:07.740 --> 02:13:09.740]  можно заводить в CompileTime,
[02:13:09.740 --> 02:13:11.740]  начиная с C++20.
[02:13:13.740 --> 02:13:15.740]  Я могу вместо того,
[02:13:15.740 --> 02:13:17.740]  чтобы писать вот это,
[02:13:17.740 --> 02:13:19.740]  просто сказать
[02:13:19.740 --> 02:13:21.740]  std Vector
[02:13:21.740 --> 02:13:23.740]  от int v
[02:13:23.740 --> 02:13:25.740]  ну там a от 100
[02:13:27.740 --> 02:13:29.740]  и просто обращаться к элементам
[02:13:29.740 --> 02:13:31.740]  Vector.
[02:13:31.740 --> 02:13:33.740]  int i равно 0
[02:13:35.740 --> 02:13:37.740]  i меньше
[02:13:37.740 --> 02:13:39.740]  значит, чего?
[02:13:39.740 --> 02:13:41.740]  100 plus plus i
[02:13:41.740 --> 02:13:43.740]  значит
[02:13:43.740 --> 02:13:45.740]  вот
[02:13:45.740 --> 02:13:47.740]  я
[02:13:47.740 --> 02:13:49.740]  запросто могу завести Vector
[02:13:49.740 --> 02:13:51.740]  в CompileTime и обращаться
[02:13:51.740 --> 02:13:53.740]  к его элементам. Правда,
[02:13:53.740 --> 02:13:55.740]  Vector из ноты мембрового стадина.
[02:13:55.740 --> 02:13:57.740]  Ну, бывает.
[02:14:13.740 --> 02:14:15.740]  Возможно,
[02:14:15.740 --> 02:14:17.740]  мой компилятор
[02:14:17.740 --> 02:14:19.740]  этого не умеет делать,
[02:14:19.740 --> 02:14:21.740]  потому что в прошлом году
[02:14:21.740 --> 02:14:23.740]  еще не умел.
[02:14:23.740 --> 02:14:25.740]  Давайте я
[02:14:25.740 --> 02:14:27.740]  это проверю.
[02:14:29.740 --> 02:14:31.740]  Короче,
[02:14:31.740 --> 02:14:33.740]  поддержка CompileTime
[02:14:33.740 --> 02:14:35.740]  Vector появилась далеко не сразу.
[02:14:35.740 --> 02:14:37.740]  Давайте я это скопипащу
[02:14:37.740 --> 02:14:39.740]  в, к сожалению, не помню,
[02:14:39.740 --> 02:14:41.740]  как скопипастить
[02:14:41.740 --> 02:14:43.740]  одной командой, поэтому я вот так
[02:14:43.740 --> 02:14:45.740]  делаю. Давайте я продемонстрирую вам
[02:14:45.740 --> 02:14:47.740]  в годбалте, что современный
[02:14:47.740 --> 02:14:49.740]  так сказать C++
[02:14:51.740 --> 02:14:53.740]  это позволяет
[02:14:53.740 --> 02:14:55.740]  так сейчас
[02:15:03.740 --> 02:15:05.740]  Мы с 14 плюсами
[02:15:05.740 --> 02:15:07.740]  мы собираемся с 14 плюсами.
[02:15:11.740 --> 02:15:13.740]  Сейчас.
[02:15:19.740 --> 02:15:21.740]  Может, надо
[02:15:21.740 --> 02:15:23.740]  аллокатить?
[02:15:23.740 --> 02:15:25.740]  Так, PrimeScout.
[02:15:25.740 --> 02:15:27.740]  Чего мы не можем сделать?
[02:15:27.740 --> 02:15:29.740]  У нас какие-то, что-то у нас
[02:15:29.740 --> 02:15:31.740]  конкретно неконстантное. Что именно?
[02:15:35.740 --> 02:15:37.740]  Assignment to an object
[02:15:37.740 --> 02:15:39.740]  outside
[02:15:39.740 --> 02:15:41.740]  UnitedLifetime is not allowed
[02:15:41.740 --> 02:15:43.740]  in a constant expression.
[02:15:49.740 --> 02:15:51.740]  Это Trunk.
[02:15:51.740 --> 02:15:53.740]  Ну, в смысле, это
[02:15:53.740 --> 02:15:55.740]  последняя рабочая версия, это мастер-версия.
[02:15:57.740 --> 02:15:59.740]  Сейчас. Я пытаюсь понять,
[02:15:59.740 --> 02:16:01.740]  что именно я сделал не так.
[02:16:01.740 --> 02:16:03.740]  Возможно, я
[02:16:03.740 --> 02:16:05.740]  не должен этот конструктор вызывать.
[02:16:09.740 --> 02:16:11.740]  Ну, работает.
[02:16:11.740 --> 02:16:13.740]  На 12-м мы не должны работать.
[02:16:13.740 --> 02:16:15.740]  Да, Илья сработало просто
[02:16:15.740 --> 02:16:17.740]  аллокатер указатель.
[02:16:17.740 --> 02:16:19.740]  А если не указатель?
[02:16:19.740 --> 02:16:21.740]  Это точно.
[02:16:21.740 --> 02:16:23.740]  Чего?
[02:16:23.740 --> 02:16:25.740]  Ну, мы указали аллокатер.
[02:16:25.740 --> 02:16:27.740]  Нет, это не так работает. 12 и плюсы просто работают.
[02:16:27.740 --> 02:16:29.740]  C++ 2 поддерживает это C++ 11.
[02:16:29.740 --> 02:16:31.740]  Ну, точнее,
[02:16:31.740 --> 02:16:33.740]  видимо, не просто уже нет,
[02:16:33.740 --> 02:16:35.740]  а в принципе нет.
[02:16:35.740 --> 02:16:37.740]  Ну, собственно, полная поддержка 25 плюсов уже появилась только в 12-й весе.
[02:16:37.740 --> 02:16:39.740]  Ну, в принципе,
[02:16:39.740 --> 02:16:41.740]  на C++ 2 работает.
[02:16:41.740 --> 02:16:43.740]  Сейчас, а у меня, а почему на...
[02:16:43.740 --> 02:16:45.740]  А, Силенг, что ли, не работает?
[02:16:45.740 --> 02:16:47.740]  Силенг, видимо, все еще не поддержал.
[02:16:47.740 --> 02:16:49.740]  Хорошо, давайте GCC Trunk попросим.
[02:16:51.740 --> 02:16:53.740]  Да, GCC работает прекрасно.
[02:16:53.740 --> 02:16:55.740]  А с Trunk это кто?
[02:16:55.740 --> 02:16:57.740]  Trunk, не с Trunk, а Trunk.
[02:16:57.740 --> 02:16:59.740]  Trunk это ствол.
[02:16:59.740 --> 02:17:01.740]  Ну, типа это мастер-ветка GCC,
[02:17:01.740 --> 02:17:03.740]  мастер-ветка разработки GCC.
[02:17:03.740 --> 02:17:05.740]  Почему GCC падает на сролл,
[02:17:05.740 --> 02:17:07.740]  потому что мы в него не зашли.
[02:17:07.740 --> 02:17:09.740]  Хороший вопрос.
[02:17:09.740 --> 02:17:11.740]  А, мы в него зашли.
[02:17:11.740 --> 02:17:13.740]  А вопрос...
[02:17:13.740 --> 02:17:15.740]  Мы в него зашли, потому что я не заполнил
[02:17:15.740 --> 02:17:17.740]  вектор значениями.
[02:17:17.740 --> 02:17:19.740]  Вот, я должен заполнить
[02:17:19.740 --> 02:17:21.740]  вектор значениями.
[02:17:21.740 --> 02:17:23.740]  Ну, по идее, SD-Yota здесь тоже будет работать.
[02:17:25.740 --> 02:17:27.740]  Да, только я не помню, к сожалению,
[02:17:27.740 --> 02:17:29.740]  синтаксис SD-Yota.
[02:17:29.740 --> 02:17:31.740]  SD-Yota...
[02:17:31.740 --> 02:17:33.740]  Сейчас мне еще алгоритм надо подключать.
[02:17:33.740 --> 02:17:35.740]  Нафиг.
[02:17:35.740 --> 02:17:37.740]  For int i от 0 до 100.
[02:17:37.740 --> 02:17:39.740]  У меня вот алгоритмами
[02:17:39.740 --> 02:17:41.740]  примерно такие же.
[02:17:43.740 --> 02:17:45.740]  a i t равно i плюс 1.
[02:17:45.740 --> 02:17:47.740]  Нормально?
[02:17:49.740 --> 02:17:51.740]  Все, отлично, компилируется.
[02:17:51.740 --> 02:17:53.740]  Божественно.
[02:17:53.740 --> 02:17:55.740]  Вот, пожалуйста, можно использовать
[02:17:55.740 --> 02:17:57.740]  вектор в Compile Time.
[02:17:59.740 --> 02:18:01.740]  Можно даже использовать
[02:18:01.740 --> 02:18:03.740]  string в Compile Time.
[02:18:05.740 --> 02:18:07.740]  Но если я обращусь здесь
[02:18:07.740 --> 02:18:09.740]  к элементу вектора, который
[02:18:11.740 --> 02:18:13.740]  выходит за границей,
[02:18:13.740 --> 02:18:15.740]  то будет CE.
[02:18:15.740 --> 02:18:17.740]  По причине...
[02:18:19.740 --> 02:18:21.740]  Я вышел за границы...
[02:18:25.740 --> 02:18:27.740]  вышел за границы
[02:18:27.740 --> 02:18:29.740]  выделения динамической памяти.
[02:18:29.740 --> 02:18:31.740]  То есть, смотрите, я в векторе
[02:18:31.740 --> 02:18:33.740]  могу...
[02:18:33.740 --> 02:18:35.740]  То, что раньше у меня было
[02:18:35.740 --> 02:18:37.740]  у b, теперь у меня CE.
[02:18:37.740 --> 02:18:39.740]  Если я обратился квадратными
[02:18:39.740 --> 02:18:41.740]  скобочками за границы вектора.
[02:18:43.740 --> 02:18:45.740]  Причем я могу
[02:18:45.740 --> 02:18:47.740]  эту функцию параметризовать
[02:18:47.740 --> 02:18:49.740]  и здесь вызываться там от какого-нибудь
[02:18:49.740 --> 02:18:51.740]  int, и это будет
[02:18:51.740 --> 02:18:53.740]  или не будет CE в зависимости от того,
[02:18:53.740 --> 02:18:55.740]  от чего я вызвался.
[02:18:55.740 --> 02:18:57.740]  Как из throw.
[02:18:57.740 --> 02:18:59.740]  Вот, отлично.
[02:18:59.740 --> 02:19:01.740]  Ну и давайте напоследок,
[02:19:01.740 --> 02:19:03.740]  так сказать, на десерт,
[02:19:03.740 --> 02:19:05.740]  разговаривая о возможностях
[02:19:05.740 --> 02:19:07.740]  constexpr функций.
[02:19:09.740 --> 02:19:11.740]  Давайте поговорим о такой
[02:19:11.740 --> 02:19:13.740]  замечательной вещи.
[02:19:13.740 --> 02:19:15.740]  Вот мы с вами изучали еще одну прекрасную
[02:19:15.740 --> 02:19:17.740]  возможность языка C++ в первом
[02:19:17.740 --> 02:19:19.740]  семестре. Вот ты о ней говорил.
[02:19:23.740 --> 02:19:25.740]  Да, надо быть смелее.
[02:19:25.740 --> 02:19:27.740]  Что бы мы хотели уметь делать в компайл тайме?
[02:19:27.740 --> 02:19:29.740]  Ну, динамическую память
[02:19:29.740 --> 02:19:31.740]  мы на следование, а конкретнее?
[02:19:31.740 --> 02:19:33.740]  Виртуальные функции.
[02:19:33.740 --> 02:19:35.740]  Виртуальные функции.
[02:19:35.740 --> 02:19:37.740]  Типа RTTI как работает?
[02:19:37.740 --> 02:19:39.740]  Как насчет
[02:19:39.740 --> 02:19:41.740]  попробовать в компайл тайме вызвать какую-нибудь виртуальную
[02:19:41.740 --> 02:19:43.740]  функцию?
[02:19:43.740 --> 02:19:45.740]  А в чем проблема?
[02:19:45.740 --> 02:19:47.740]  И здесь вообще не видно проблемы.
[02:19:47.740 --> 02:19:49.740]  Не видно проблемы, действительно. Какая проблема?
[02:19:49.740 --> 02:19:51.740]  В компайл тайме таблицу виртуальных функций завести.
[02:19:51.740 --> 02:19:53.740]  Совершенно естественное желание.
[02:19:53.740 --> 02:19:55.740]  Динамика сделать в компайл тайме
[02:19:55.740 --> 02:19:57.740]  очень логична.
[02:19:57.740 --> 02:19:59.740]  Виртуальных функций
[02:19:59.740 --> 02:20:01.740]  не в компайл тайме все равно считается.
[02:20:01.740 --> 02:20:03.740]  Когда у нас уже есть компилирование.
[02:20:03.740 --> 02:20:05.740]  Это очень хорошо, что для вас
[02:20:05.740 --> 02:20:07.740]  это не выглядит проблемой, потому что
[02:20:07.740 --> 02:20:09.740]  действительно можно делать в компайл тайме.
[02:20:09.740 --> 02:20:11.740]  Смотрите.
[02:20:11.740 --> 02:20:13.740]  Потому что у нас там указатели на именно те программы,
[02:20:13.740 --> 02:20:15.740]  поэтому
[02:20:15.740 --> 02:20:17.740]  когда у нас собрана игра, у нас все это уже
[02:20:17.740 --> 02:20:19.740]  просчитано.
[02:20:19.740 --> 02:20:21.740]  Смотрите, давайте я заведу
[02:20:21.740 --> 02:20:23.740]  действительно функцию
[02:20:23.740 --> 02:20:25.740]  virtual voidf
[02:20:25.740 --> 02:20:27.740]  и она будет
[02:20:27.740 --> 02:20:29.740]  virtual int
[02:20:31.740 --> 02:20:33.740]  virtual int
[02:20:33.740 --> 02:20:35.740]  и она будет возвращать 1.
[02:20:35.740 --> 02:20:37.740]  А здесь я заведу
[02:20:37.740 --> 02:20:39.740]  int f override
[02:20:39.740 --> 02:20:41.740]  которая будет возвращать 2.
[02:20:45.740 --> 02:20:47.740]  И давайте я заведу такую замечательную
[02:20:47.740 --> 02:20:49.740]  constexpr функцию.
[02:20:49.740 --> 02:20:51.740]  Мы методы не хотим сделать?
[02:20:53.740 --> 02:20:55.740]  Это, кстати, хороший вопрос.
[02:20:55.740 --> 02:20:57.740]  Да, давайте я constexpr напишу.
[02:21:01.740 --> 02:21:03.740]  Ну он по умолчанию же constexpr.
[02:21:03.740 --> 02:21:05.740]  Илья.
[02:21:05.740 --> 02:21:07.740]  Миша подсказал
[02:21:07.740 --> 02:21:09.740]  одно волшебное слово, которое работает
[02:21:09.740 --> 02:21:11.740]  во всех компайл тайм вычислениях.
[02:21:11.740 --> 02:21:13.740]  Дивертуализация.
[02:21:13.740 --> 02:21:15.740]  Там же известный какой класс в какой момент дергается,
[02:21:15.740 --> 02:21:17.740]  поэтому в целом даже таблице виртуальных функций
[02:21:17.740 --> 02:21:19.740]  Подождите, кто вам это сказал?
[02:21:25.740 --> 02:21:27.740]  Сейчас, давайте все-таки
[02:21:27.740 --> 02:21:29.740]  constexpr
[02:21:29.740 --> 02:21:31.740]  constexpr
[02:21:31.740 --> 02:21:33.740]  constexpr
[02:21:33.740 --> 02:21:35.740]  void
[02:21:35.740 --> 02:21:37.740]  test-virtual
[02:21:37.740 --> 02:21:39.740]  Вот, и допустим
[02:21:39.740 --> 02:21:41.740]  я здесь буду делать
[02:21:41.740 --> 02:21:43.740]  от x.
[02:21:43.740 --> 02:21:45.740]  Вот, если x
[02:21:45.740 --> 02:21:47.740]  больше 0
[02:21:47.740 --> 02:21:49.740]  то
[02:21:49.740 --> 02:21:51.740]  ну я что сделаю?
[02:21:51.740 --> 02:21:53.740]  Я сейчас заведу derived
[02:21:57.740 --> 02:21:59.740]  но я заведу объект наследника
[02:21:59.740 --> 02:22:01.740]  да
[02:22:01.740 --> 02:22:03.740]  и объект
[02:22:03.740 --> 02:22:05.740]  родителя, как у меня
[02:22:05.740 --> 02:22:07.740]  вводится для полноценного примера
[02:22:07.740 --> 02:22:09.740]  с виртуальностью. И давайте я скажу
[02:22:09.740 --> 02:22:11.740]  basempercent
[02:22:11.740 --> 02:22:13.740]  ref равно
[02:22:13.740 --> 02:22:15.740]  в зависимости от того, x больше 0
[02:22:15.740 --> 02:22:17.740]  он ссылается либо на
[02:22:17.740 --> 02:22:19.740]  родителя, либо на наследника
[02:22:21.740 --> 02:22:23.740]  в обратном порядке
[02:22:23.740 --> 02:22:25.740]  либо на наследника, либо на родителя
[02:22:25.740 --> 02:22:27.740]  вот, и вот если
[02:22:27.740 --> 02:22:29.740]  ref
[02:22:29.740 --> 02:22:31.740]  точка f
[02:22:31.740 --> 02:22:33.740]  возвращает
[02:22:33.740 --> 02:22:35.740]  один, то
[02:22:35.740 --> 02:22:37.740]  бросьте исключения
[02:22:37.740 --> 02:22:39.740]  Отличная
[02:22:39.740 --> 02:22:41.740]  тема. Давай теперь
[02:22:41.740 --> 02:22:43.740]  попробуем
[02:22:43.740 --> 02:22:45.740]  вот здесь вот затестить виртуальность
[02:22:47.740 --> 02:22:49.740]  test-virtual
[02:22:49.740 --> 02:22:51.740]  от
[02:22:51.740 --> 02:22:53.740]  одного
[02:22:57.740 --> 02:22:59.740]  тест-virtual от одного
[02:23:03.740 --> 02:23:05.740]  да, ну мы уже поняли, что
[02:23:05.740 --> 02:23:07.740]  вектор ты не умеешь
[02:23:07.740 --> 02:23:09.740]  ну, бог с тобой
[02:23:09.740 --> 02:23:11.740]  давай мы тебя закомментируем
[02:23:11.740 --> 02:23:13.740]  простые числа мы считать
[02:23:13.740 --> 02:23:15.740]  больше не хотим, мы хотим
[02:23:15.740 --> 02:23:17.740]  тест-virtual делать
[02:23:19.740 --> 02:23:21.740]  компили, а, ну все
[02:23:21.740 --> 02:23:23.740]  запускать можно не запускать
[02:23:23.740 --> 02:23:25.740]  так, это компилируется, давайте
[02:23:25.740 --> 02:23:27.740]  поймем, что происходит, x больше 0
[02:23:27.740 --> 02:23:29.740]  я передал x больше 0
[02:23:29.740 --> 02:23:31.740]  значит ссылка привязалась
[02:23:31.740 --> 02:23:33.740]  к derived
[02:23:33.740 --> 02:23:35.740]  derived возвращает два
[02:23:35.740 --> 02:23:37.740]  не один, значит ноль не кидается
[02:23:37.740 --> 02:23:39.740]  окей, давайте test-virtual
[02:23:39.740 --> 02:23:41.740]  от минус одного
[02:23:45.740 --> 02:23:47.740]  так, вот это уже интересно
[02:23:47.740 --> 02:23:49.740]  господи, что я делаю
[02:23:49.740 --> 02:23:51.740]  меня сила не удает terminate
[02:23:51.740 --> 02:23:53.740]  code after throwing an instance
[02:23:53.740 --> 02:23:55.740]  of int
[02:23:55.740 --> 02:23:57.740]  ну это и должно произойти, в смысле terminate cold
[02:23:57.740 --> 02:23:59.740]  terminate cold
[02:23:59.740 --> 02:24:01.740]  в compile-time
[02:24:01.740 --> 02:24:03.740]  так в run-time должно быть
[02:24:03.740 --> 02:24:05.740]  а, господи
[02:24:05.740 --> 02:24:07.740]  ну конечно, что я делаю
[02:24:07.740 --> 02:24:09.740]  я же test-virtual вызываю не в
[02:24:09.740 --> 02:24:11.740]  constant-контексте, я же должен
[02:24:11.740 --> 02:24:13.740]  ее использовать для инициализации
[02:24:13.740 --> 02:24:15.740]  какой-то constant-export переменной
[02:24:19.740 --> 02:24:21.740]  ну сейчас я и верну int какой-нибудь
[02:24:25.740 --> 02:24:27.740]  она не из compile-time контекста вызывает
[02:24:27.740 --> 02:24:29.740]  ну да, она не запускается
[02:24:29.740 --> 02:24:31.740]  в compile-time
[02:24:31.740 --> 02:24:33.740]  в compile-time она будет запускаться
[02:24:33.740 --> 02:24:35.740]  только если я ее вынудил запуститься в compile-time
[02:24:35.740 --> 02:24:37.740]  путем того, что подставил ее в compile-time
[02:24:37.740 --> 02:24:39.740]  контекст
[02:24:39.740 --> 02:24:41.740]  да, спасибо
[02:24:41.740 --> 02:24:43.740]  на самом деле ты подсказал, потому что
[02:24:43.740 --> 02:24:45.740]  в run-time она бы упала, а не в compile-time
[02:24:45.740 --> 02:24:47.740]  давайте еще раз потестим
[02:24:47.740 --> 02:24:49.740]  то есть вот, я пытаюсь
[02:24:49.740 --> 02:24:51.740]  инициализировать constant-export int через результат
[02:24:51.740 --> 02:24:53.740]  тест-virtual, тем самым заставляя ее
[02:24:53.740 --> 02:24:55.740]  запуститься в compile-time
[02:24:55.740 --> 02:24:57.740]  и это сейчас не должно упасть, потому что
[02:24:57.740 --> 02:24:59.740]  класс
[02:24:59.740 --> 02:25:01.740]  ладно
[02:25:01.740 --> 02:25:03.740]  уберем это
[02:25:03.740 --> 02:25:05.740]  ну нормально
[02:25:05.740 --> 02:25:07.740]  а теперь я от минус одного вызовусь
[02:25:07.740 --> 02:25:09.740]  и
[02:25:09.740 --> 02:25:11.740]  все
[02:25:15.740 --> 02:25:17.740]  значит, в compile-time
[02:25:17.740 --> 02:25:19.740]  он симулировал таблицу виртуальных функций
[02:25:19.740 --> 02:25:21.740]  и действительно, если мы
[02:25:21.740 --> 02:25:23.740]  попали в версию
[02:25:23.740 --> 02:25:25.740]  наследника, то мы
[02:25:25.740 --> 02:25:27.740]  вернули
[02:25:27.740 --> 02:25:29.740]  два, а если попали в версию родителя, то
[02:25:29.740 --> 02:25:31.740]  вернули один
[02:25:31.740 --> 02:25:33.740]  почему он не может просто всегда
[02:25:33.740 --> 02:25:35.740]  девиртуализацию делать?
[02:25:35.740 --> 02:25:37.740]  может и может
[02:25:37.740 --> 02:25:39.740]  девиртуализация
[02:25:39.740 --> 02:25:41.740]  это такая штука
[02:25:41.740 --> 02:25:43.740]  я думаю механизмы другие
[02:25:45.740 --> 02:25:47.740]  я думаю, что это отдельные немножко
[02:25:47.740 --> 02:25:49.740]  проекты
[02:25:49.740 --> 02:25:51.740]  просто здесь же он буквально
[02:25:51.740 --> 02:25:53.740]  девиртуализация решает другую задачу
[02:25:53.740 --> 02:25:55.740]  девиртуализация пытается оптимизировать
[02:25:55.740 --> 02:25:57.740]  некоторые конкретные ситуации
[02:25:57.740 --> 02:25:59.740]  с конкретными очень строгими
[02:25:59.740 --> 02:26:01.740]  ограничениями, а здесь я
[02:26:01.740 --> 02:26:03.740]  канонический пример чистого
[02:26:03.740 --> 02:26:05.740]  полиморфизма вызвал
[02:26:05.740 --> 02:26:07.740]  я думаю, что просто проще
[02:26:07.740 --> 02:26:09.740]  симулировать заново таблицу виртуальных
[02:26:09.740 --> 02:26:11.740]  функций в compile-time, чем написать
[02:26:11.740 --> 02:26:13.740]  чем приспособить девиртуализацию
[02:26:13.740 --> 02:26:15.740]  под вот этот сценарий
[02:26:15.740 --> 02:26:17.740]  ну я не знаю
[02:26:17.740 --> 02:26:19.740]  в любом случае, я не знаю, мне кажется, что
[02:26:19.740 --> 02:26:21.740]  компилятору просто проще
[02:26:21.740 --> 02:26:23.740]  если бы я был разработчиком компилятора
[02:26:23.740 --> 02:26:25.740]  ну я не знаю, как бы я делался
[02:26:25.740 --> 02:26:27.740]  в зависимости от того, что уже для девиртуализации написано
[02:26:27.740 --> 02:26:29.740]  но
[02:26:29.740 --> 02:26:31.740]  как нормально вызвать void-концепцию в функцию
[02:26:31.740 --> 02:26:33.740]  чтобы
[02:26:33.740 --> 02:26:35.740]  никуда и не присваивать
[02:26:35.740 --> 02:26:37.740]  а что ты хочешь добиться
[02:26:37.740 --> 02:26:39.740]  void-концепции?
[02:26:39.740 --> 02:26:41.740]  ну например, проверить
[02:26:41.740 --> 02:26:43.740]  ты потом родишь всю память, которую
[02:26:43.740 --> 02:26:45.740]  сделаешь
[02:26:45.740 --> 02:26:47.740]  в контексте void-концепции
[02:26:47.740 --> 02:26:49.740]  да, я не очень понимаю
[02:26:49.740 --> 02:26:51.740]  для чего в constexpr вызывать void-функцию
[02:26:51.740 --> 02:26:53.740]  она ничего не возвращает
[02:26:53.740 --> 02:26:55.740]  то есть ты заставляешь компилятор что-то посчитать
[02:26:55.740 --> 02:26:57.740]  и все
[02:26:57.740 --> 02:26:59.740]  и ничего не вернуть
[02:27:03.740 --> 02:27:05.740]  тогда ты для
[02:27:05.740 --> 02:27:07.740]  инициализации этого глобального
[02:27:07.740 --> 02:27:09.740]  а, в смысле, ты хоть
[02:27:09.740 --> 02:27:11.740]  ну чтобы вместо вот этих
[02:27:11.740 --> 02:27:13.740]  кастарей стафферов, ее можно сделать
[02:27:13.740 --> 02:27:15.740]  в блог, засунуть в статик и все
[02:27:15.740 --> 02:27:17.740]  подожди, а вдруг это какая-то
[02:27:17.740 --> 02:27:19.740]  third-party-функция
[02:27:19.740 --> 02:27:21.740]  у тебя нет доступа к ее коду?
[02:27:23.740 --> 02:27:25.740]  ладно, давайте
[02:27:25.740 --> 02:27:27.740]  дальше я все-таки расскажу
[02:27:27.740 --> 02:27:29.740]  я почти
[02:27:29.740 --> 02:27:31.740]  был прав, я сказал, что мы сейчас будем
[02:27:31.740 --> 02:27:33.740]  обсуждать, что можно еще нельзя делать в constexpr функцию
[02:27:33.740 --> 02:27:35.740]  но мы почти
[02:27:35.740 --> 02:27:37.740]  закончили обсуждение, осталось только
[02:27:37.740 --> 02:27:39.740]  вот это
[02:27:39.740 --> 02:27:41.740]  да
[02:27:41.740 --> 02:27:43.740]  а вот src, алгоритмский src
[02:27:43.740 --> 02:27:45.740]  это же функция, которая возвращает void
[02:27:47.740 --> 02:27:49.740]  но она constexpr
[02:27:49.740 --> 02:27:51.740]  а как ее вызвать?
[02:27:51.740 --> 02:27:53.740]  в какую-то функцию делаешь
[02:27:53.740 --> 02:27:55.740]  а, ну если ты в constexpr функции
[02:27:55.740 --> 02:27:57.740]  пишешь sort
[02:27:57.740 --> 02:27:59.740]  то вот тебе и
[02:27:59.740 --> 02:28:01.740]  если ты
[02:28:01.740 --> 02:28:03.740]  ну тогда это не будет в compile-time вызывать
[02:28:03.740 --> 02:28:05.740]  ну я же вот
[02:28:05.740 --> 02:28:07.740]  ну слушай, ну я же вот здесь вот
[02:28:07.740 --> 02:28:09.740]  если я нахожусь
[02:28:09.740 --> 02:28:11.740]  если я нахожусь в вычислении
[02:28:11.740 --> 02:28:13.740]  constexpr функции
[02:28:13.740 --> 02:28:15.740]  и вызываю какую-то другую функцию, хоть void
[02:28:15.740 --> 02:28:17.740]  то она
[02:28:17.740 --> 02:28:19.740]  но это я понимаю
[02:28:19.740 --> 02:28:21.740]  ну как, вот здесь вот я мог бы сделать sort
[02:28:21.740 --> 02:28:23.740]  например, если бы я count-prime
[02:28:23.740 --> 02:28:25.740]  сделал во момент компиляции, то sort тоже
[02:28:25.740 --> 02:28:27.740]  должна быть constexpr
[02:28:27.740 --> 02:28:29.740]  если у меня в мэйне constexpr-вектор
[02:28:29.740 --> 02:28:31.740]  я хочу его отсортировать
[02:28:31.740 --> 02:28:33.740]  в compile-time
[02:28:33.740 --> 02:28:35.740]  если у тебя в мэйне constexpr-вектор
[02:28:35.740 --> 02:28:37.740]  ты не можешь его отсортировать
[02:28:37.740 --> 02:28:39.740]  потому что constexpr
[02:28:39.740 --> 02:28:41.740]  привлекает константность самого объекта
[02:28:41.740 --> 02:28:43.740]  если ты уже создал constexpr
[02:28:43.740 --> 02:28:45.740]  я говорил, что constexpr
[02:28:45.740 --> 02:28:47.740]  привлечет const, ты не можешь сортировать
[02:28:47.740 --> 02:28:49.740]  константный вектор
[02:28:53.740 --> 02:28:55.740]  я могу использовать его внутри
[02:28:55.740 --> 02:28:57.740]  constexpr функции
[02:28:57.740 --> 02:28:59.740]  ты можешь создавать там неконстантный вектор
[02:28:59.740 --> 02:29:01.740]  и его сортировать
[02:29:01.740 --> 02:29:03.740]  а если я лямду какую-нибудь
[02:29:03.740 --> 02:29:05.740]  ссссссссссссссссссссссссссссссссссссссссс
[02:29:05.740 --> 02:29:07.740]  это можно
[02:29:07.740 --> 02:29:09.740]  ну сейчас покажу, подождите
[02:29:15.740 --> 02:29:17.740]  так вот
[02:29:17.740 --> 02:29:19.740]  виртуальная функция в compile-time
[02:29:19.740 --> 02:29:21.740]  ну короче, увидели мы этот пример
[02:29:21.740 --> 02:29:23.740]  у меня теперь вот какой вопрос
[02:29:23.740 --> 02:29:25.740]  что если бы я здесь
[02:29:25.740 --> 02:29:27.740]  c++
[02:29:27.740 --> 02:29:29.740]  gcc не поддерживает
[02:29:29.740 --> 02:29:31.740]  вектор, да?
[02:29:31.740 --> 02:29:33.740]  ну 12 поддерживает
[02:29:33.740 --> 02:29:35.740]  как мы поняли
[02:29:35.740 --> 02:29:37.740]  у меня написано
[02:29:37.740 --> 02:29:39.740]  c++ 2b
[02:29:41.740 --> 02:29:43.740]  2b это 23
[02:29:43.740 --> 02:29:45.740]  нет, gcc
[02:29:45.740 --> 02:29:47.740]  просто не дорелизовал
[02:29:47.740 --> 02:29:49.740]  не знаю, покажи потом свой пример
[02:29:49.740 --> 02:29:51.740]  так, смотрите
[02:29:51.740 --> 02:29:53.740]  я поступил
[02:29:53.740 --> 02:29:55.740]  следующим образом, у меня была constexpr
[02:29:55.740 --> 02:29:57.740]  virtualint
[02:29:57.740 --> 02:29:59.740]  а вот эта версия
[02:29:59.740 --> 02:30:01.740]  не constexpr
[02:30:01.740 --> 02:30:03.740]  видимо разные симнатуры
[02:30:03.740 --> 02:30:05.740]  вопрос
[02:30:05.740 --> 02:30:07.740]  нет, симнатуры одинаковые
[02:30:07.740 --> 02:30:09.740]  constexpr не является частью симнатуры
[02:30:09.740 --> 02:30:11.740]  вопрос
[02:30:11.740 --> 02:30:13.740]  можно ли override-ить constexpr функцию
[02:30:13.740 --> 02:30:15.740]  не constexpr функции ей
[02:30:15.740 --> 02:30:17.740]  или наоборот
[02:30:17.740 --> 02:30:19.740]  ну как минимум не константность отличается
[02:30:19.740 --> 02:30:21.740]  ну нет
[02:30:21.740 --> 02:30:23.740]  не отличается
[02:30:23.740 --> 02:30:25.740]  стоп
[02:30:25.740 --> 02:30:27.740]  то что функция constexpr
[02:30:27.740 --> 02:30:29.740]  не накладывает на функцию ограничение
[02:30:29.740 --> 02:30:31.740]  константности
[02:30:31.740 --> 02:30:33.740]  констэкспр функция
[02:30:33.740 --> 02:30:35.740]  это свойство функции
[02:30:35.740 --> 02:30:37.740]  оно никак не связано с типами
[02:30:37.740 --> 02:30:39.740]  принимаемыми или возвращаемыми
[02:30:43.740 --> 02:30:45.740]  еще раз
[02:30:45.740 --> 02:30:47.740]  констэкспр это почти то же самое что и конст
[02:30:47.740 --> 02:30:49.740]  это же часть симнатуры
[02:30:49.740 --> 02:30:51.740]  нет
[02:30:51.740 --> 02:30:53.740]  констэкспр функция это свойство функции
[02:30:53.740 --> 02:30:55.740]  константный
[02:30:57.740 --> 02:30:59.740]  она может менять объект
[02:30:59.740 --> 02:31:01.740]  и не соревноваться
[02:31:03.740 --> 02:31:05.740]  короче
[02:31:07.740 --> 02:31:09.740]  мы еще глобальные перемены не рассмотрели
[02:31:09.740 --> 02:31:11.740]  сейчас рассмотрим
[02:31:15.740 --> 02:31:17.740]  по идее должно быть можно убирать
[02:31:17.740 --> 02:31:19.740]  значит смотрите как это работает
[02:31:19.740 --> 02:31:21.740]  вот я вызвался
[02:31:21.740 --> 02:31:23.740]  от отрицательного числа
[02:31:23.740 --> 02:31:25.740]  и получилось
[02:31:25.740 --> 02:31:27.740]  throw
[02:31:27.740 --> 02:31:29.740]  вот
[02:31:29.740 --> 02:31:31.740]  он мне ничего не сказал
[02:31:31.740 --> 02:31:33.740]  что вот это не констэкспр
[02:31:33.740 --> 02:31:35.740]  но если
[02:31:35.740 --> 02:31:37.740]  я вызвался от положительного числа
[02:31:39.740 --> 02:31:41.740]  то он уже на этот раз
[02:31:41.740 --> 02:31:43.740]  выдал ошибку компиляции
[02:31:43.740 --> 02:31:45.740]  по причине вызов не констэкспр
[02:31:45.740 --> 02:31:47.740]  функции
[02:31:47.740 --> 02:31:49.740]  что произошло
[02:31:49.740 --> 02:31:51.740]  а он просто сначала
[02:31:51.740 --> 02:31:53.740]  вычислил разрешил
[02:31:53.740 --> 02:31:55.740]  динамический полиморфизм
[02:31:55.740 --> 02:31:57.740]  то есть
[02:31:57.740 --> 02:31:59.740]  что происходит он решает
[02:31:59.740 --> 02:32:01.740]  какую версию функций ему реально надо вызвать
[02:32:01.740 --> 02:32:03.740]  он выбирает
[02:32:03.740 --> 02:32:05.740]  перегрузку но не просто выбирает перегрузку
[02:32:05.740 --> 02:32:07.740]  он еще и проверяет таблицу виртуальных функций
[02:32:07.740 --> 02:32:09.740]  ну как бы псевдо таблицы
[02:32:09.740 --> 02:32:11.740]  я не знаю что он там хранит в compile time
[02:32:11.740 --> 02:32:13.740]  то есть он сначала решает какую версию
[02:32:13.740 --> 02:32:15.740]  ему нужно выбрать
[02:32:15.740 --> 02:32:17.740]  а потом пытается вызвать и тут
[02:32:17.740 --> 02:32:19.740]  обнаружена не констэкспр
[02:32:19.740 --> 02:32:21.740]  вот это как раз супер вонично
[02:32:21.740 --> 02:32:23.740]  ну в плане она там же ведет себя
[02:32:23.740 --> 02:32:25.740]  и с ambitious
[02:32:25.740 --> 02:32:27.740]  и с квалификаторами доступа
[02:32:27.740 --> 02:32:29.740]  ну да
[02:32:29.740 --> 02:32:31.740]  то есть я могу
[02:32:31.740 --> 02:32:33.740]  оверрайдить
[02:32:33.740 --> 02:32:35.740]  констэкспр функции
[02:32:35.740 --> 02:32:37.740]  не констэкспр функциями и наоборот
[02:32:37.740 --> 02:32:39.740]  вот этот вот констэкспр
[02:32:39.740 --> 02:32:41.740]  он влияет только на то
[02:32:41.740 --> 02:32:43.740]  что если реально в compile time ему понадобится
[02:32:43.740 --> 02:32:45.740]  ее вызвать это будет ошибка компиляции или нет
[02:32:45.740 --> 02:32:47.740]  на выбор версии
[02:32:47.740 --> 02:32:49.740]  это никак не влияет
[02:32:49.740 --> 02:32:51.740]  и на runtime поведение это никак не влияет
[02:32:51.740 --> 02:32:53.740]  это влияет только на то что если ему реально
[02:32:53.740 --> 02:32:55.740]  надо будет в compile time ее вызвать он просто упадет
[02:32:57.740 --> 02:32:59.740]  ну и dynamic cast
[02:32:59.740 --> 02:33:01.740]  ну конечно же dynamic cast тоже
[02:33:01.740 --> 02:33:03.740]  можно делать в compile time
[02:33:05.740 --> 02:33:07.740]  в первом семестре за такой ответ
[02:33:07.740 --> 02:33:09.740]  конечно вы получили
[02:33:09.740 --> 02:33:11.740]  что то плохое но
[02:33:11.740 --> 02:33:13.740]  теперь можно значит
[02:33:13.740 --> 02:33:15.740]  dynamic cast тоже можно делать в compile time
[02:33:15.740 --> 02:33:17.740]  вот
[02:33:17.740 --> 02:33:19.740]  ээээ
[02:33:19.740 --> 02:33:21.740]  значит
[02:33:21.740 --> 02:33:23.740]  надо просто
[02:33:23.740 --> 02:33:25.740]  вот я просто скажу dynamic cast
[02:33:27.740 --> 02:33:29.740]  к derived
[02:33:29.740 --> 02:33:31.740]  ampersand
[02:33:31.740 --> 02:33:33.740]  от ref
[02:33:35.740 --> 02:33:37.740]  точка f
[02:33:37.740 --> 02:33:39.740]  ну и давайте верну это
[02:33:41.740 --> 02:33:43.740]  ну да там же int
[02:33:43.740 --> 02:33:45.740]  вернется вот
[02:33:45.740 --> 02:33:47.740]  то есть смотрите
[02:33:47.740 --> 02:33:49.740]  я сейчас передаю в эту функцию
[02:33:49.740 --> 02:33:51.740]  единицу
[02:33:51.740 --> 02:33:53.740]  и у меня
[02:33:53.740 --> 02:33:55.740]  под ref лежит
[02:33:55.740 --> 02:33:57.740]  derived
[02:33:57.740 --> 02:33:59.740]  то есть теперь я должен
[02:33:59.740 --> 02:34:01.740]  ну вот этот dynamic cast должен корректно отработать
[02:34:03.740 --> 02:34:05.740]  правда я упаду потому что не
[02:34:05.740 --> 02:34:07.740]  констэкспр
[02:34:07.740 --> 02:34:09.740]  вот
[02:34:11.740 --> 02:34:13.740]  чего
[02:34:13.740 --> 02:34:15.740]  да
[02:34:15.740 --> 02:34:17.740]  а попробуй кстати
[02:34:17.740 --> 02:34:19.740]  поменять местами констэкспр
[02:34:19.740 --> 02:34:21.740]  и не констэкспр в классах
[02:34:21.740 --> 02:34:23.740]  посмотреть просто что он реально вот сейчас работает даже в такой ситуации
[02:34:25.740 --> 02:34:27.740]  пожалуйста давайте значит
[02:34:27.740 --> 02:34:29.740]  здесь я убираю констэкспр
[02:34:29.740 --> 02:34:31.740]  а тут я
[02:34:31.740 --> 02:34:33.740]  пишу констэкспр
[02:34:35.740 --> 02:34:37.740]  вот работает
[02:34:37.740 --> 02:34:39.740]  сейчас
[02:34:39.740 --> 02:34:41.740]  то есть ему пофиг что бэйза не констэкспр
[02:34:41.740 --> 02:34:43.740]  почему уб это
[02:34:43.740 --> 02:34:45.740]  почему уб нет никого уб
[02:34:45.740 --> 02:34:47.740]  я ему пофиг что
[02:34:47.740 --> 02:34:49.740]  убэйза не констэкспр
[02:34:49.740 --> 02:34:51.740]  а убэйза не констэкспр да
[02:34:51.740 --> 02:34:53.740]  чего
[02:34:55.740 --> 02:34:57.740]  какой
[02:34:59.740 --> 02:35:01.740]  ну давай верну
[02:35:01.740 --> 02:35:03.740]  как было
[02:35:03.740 --> 02:35:05.740]  ну вот у меня есть вот этот ref
[02:35:05.740 --> 02:35:07.740]  под ним может быть либо derived либо
[02:35:07.740 --> 02:35:09.740]  based смотря от чего я вызвался
[02:35:09.740 --> 02:35:11.740]  ну вот я делаю
[02:35:11.740 --> 02:35:13.740]  dynamic cast derived
[02:35:13.740 --> 02:35:15.740]  он либо корректен либо некорректен
[02:35:15.740 --> 02:35:17.740]  в зависимости от того чего я вызвался
[02:35:17.740 --> 02:35:19.740]  ну как бы
[02:35:19.740 --> 02:35:21.740]  в нормальной ситуации
[02:35:21.740 --> 02:35:23.740]  это было бы либо
[02:35:23.740 --> 02:35:25.740]  исключение либо все хорошо
[02:35:25.740 --> 02:35:27.740]  значит если я вызвался
[02:35:27.740 --> 02:35:29.740]  от отрицательного числа то это
[02:35:29.740 --> 02:35:31.740]  должен быть exception bad cast
[02:35:31.740 --> 02:35:33.740]  почему это было бы
[02:35:33.740 --> 02:35:35.740]  исключение
[02:35:35.740 --> 02:35:37.740]  чего потому что
[02:35:37.740 --> 02:35:39.740]  dynamic cast так работает
[02:35:39.740 --> 02:35:41.740]  к ссылке это exception если там
[02:35:41.740 --> 02:35:43.740]  based на самом деле
[02:35:43.740 --> 02:35:45.740]  да от родителя к наследнику
[02:35:45.740 --> 02:35:47.740]  вот если я вызвался от
[02:35:47.740 --> 02:35:49.740]  положительного вот сейчас
[02:35:49.740 --> 02:35:51.740]  если я вызовусь от отрицательного числа
[02:35:51.740 --> 02:35:53.740]  у меня будет
[02:35:53.740 --> 02:35:55.740]  ce
[02:35:55.740 --> 02:35:57.740]  со словами
[02:35:57.740 --> 02:35:59.740]  некорректный dynamic cast
[02:36:01.740 --> 02:36:03.740]  то есть dynamic cast зафейлился
[02:36:03.740 --> 02:36:05.740]  в compile time потому что я попытался
[02:36:05.740 --> 02:36:07.740]  скастить к базу
[02:36:07.740 --> 02:36:09.740]  а там был
[02:36:09.740 --> 02:36:11.740]  то что не являлось
[02:36:11.740 --> 02:36:13.740]  derived в run time это было
[02:36:13.740 --> 02:36:15.740]  исключение но поскольку мы делаем все в
[02:36:15.740 --> 02:36:17.740]  compile time это ce
[02:36:17.740 --> 02:36:19.740]  вот а если я вызвываюсь от
[02:36:19.740 --> 02:36:21.740]  положительного числа
[02:36:21.740 --> 02:36:23.740]  то
[02:36:23.740 --> 02:36:25.740]  ce уже другая
[02:36:25.740 --> 02:36:27.740]  dynamic cast корректно отработал
[02:36:27.740 --> 02:36:29.740]  но мы
[02:36:29.740 --> 02:36:31.740]  попали в версию f которая не
[02:36:31.740 --> 02:36:33.740]  constexpr и мы пытаемся
[02:36:33.740 --> 02:36:35.740]  вызвать неконстекспру версию f поэтому
[02:36:35.740 --> 02:36:37.740]  ce
[02:36:37.740 --> 02:36:39.740]  нормально
[02:36:41.740 --> 02:36:43.740]  хорошо
[02:36:43.740 --> 02:36:45.740]  нравится вам
[02:36:45.740 --> 02:36:47.740]  ну вот
[02:36:47.740 --> 02:36:49.740]  ну давайте
[02:36:49.740 --> 02:36:51.740]  напоследок
[02:36:51.740 --> 02:36:53.740]  я вам покажу
[02:36:53.740 --> 02:36:55.740]  страничку на cp-референс про
[02:36:55.740 --> 02:36:57.740]  constant expression
[02:36:57.740 --> 02:36:59.740]  и вы пронаблюдаете
[02:36:59.740 --> 02:37:01.740]  полный список вместе с его
[02:37:01.740 --> 02:37:03.740]  эволюцией
[02:37:05.740 --> 02:37:07.740]  что считается constant expression
[02:37:15.740 --> 02:37:17.740]  что такое
[02:37:17.740 --> 02:37:19.740]  constant expression
[02:37:19.740 --> 02:37:21.740]  значит constant expression это
[02:37:21.740 --> 02:37:23.740]  gl value
[02:37:23.740 --> 02:37:25.740]  core constant
[02:37:25.740 --> 02:37:27.740]  expression что такое core constant expression
[02:37:27.740 --> 02:37:29.740]  это отдельный пункт
[02:37:29.740 --> 02:37:31.740]  которое ссылается на объект
[02:37:33.740 --> 02:37:35.740]  ну в общем
[02:37:35.740 --> 02:37:37.740]  тут перечислено на
[02:37:45.740 --> 02:37:47.740]  так не получится понять конечно надо
[02:37:47.740 --> 02:37:49.740]  как то по другому
[02:37:49.740 --> 02:37:51.740]  давайте прочитаем что такое core constant expression
[02:37:51.740 --> 02:37:53.740]  есть понятие core constant expression
[02:37:53.740 --> 02:37:55.740]  это такой expression
[02:37:55.740 --> 02:37:57.740]  чье вычисление
[02:37:57.740 --> 02:37:59.740]  не приведет к вычислению
[02:37:59.740 --> 02:38:01.740]  чего угодно из ниже перечисленного
[02:38:05.740 --> 02:38:07.740]  в общем длинный список
[02:38:07.740 --> 02:38:09.740]  а у нас еще одно занятие будет
[02:38:11.740 --> 02:38:13.740]  да да в следующий раз мы продолжим
[02:38:13.740 --> 02:38:15.740]  в следующий раз я вам как раз про
[02:38:15.740 --> 02:38:17.740]  type list расскажу
[02:38:17.740 --> 02:38:19.740]  вот ну в следующий раз
[02:38:19.740 --> 02:38:21.740]  мы компенсируем то что должно было быть
[02:38:21.740 --> 02:38:23.740]  в этот раз
[02:38:23.740 --> 02:38:25.740]  ну в общем это
[02:38:25.740 --> 02:38:27.740]  то что не является
[02:38:27.740 --> 02:38:29.740]  constant expression
[02:38:29.740 --> 02:38:31.740]  вот тут вот перечислено
[02:38:31.740 --> 02:38:33.740]  что не является constant expression
[02:38:33.740 --> 02:38:35.740]  вот кажется
[02:38:35.740 --> 02:38:37.740]  vis нельзя использовать constant expression
[02:38:37.740 --> 02:38:39.740]  значит
[02:38:39.740 --> 02:38:41.740]  нельзя
[02:38:41.740 --> 02:38:43.740]  объявлять статические
[02:38:43.740 --> 02:38:45.740]  или trade local
[02:38:45.740 --> 02:38:47.740]  переменные
[02:38:47.740 --> 02:38:49.740]  нельзя делать
[02:38:49.740 --> 02:38:51.740]  function call или
[02:38:51.740 --> 02:38:53.740]  конструктор который
[02:38:53.740 --> 02:38:55.740]  не constexpr
[02:38:55.740 --> 02:38:57.740]  нельзя вызывать constexpr
[02:38:57.740 --> 02:38:59.740]  функцию которая объявлена на нее
[02:38:59.740 --> 02:39:01.740]  определена
[02:39:01.740 --> 02:39:03.740]  ну вот не поддержали
[02:39:03.740 --> 02:39:05.740]  нельзя
[02:39:05.740 --> 02:39:07.740]  вызывать constexpr virtual
[02:39:07.740 --> 02:39:09.740]  функцию которая
[02:39:09.740 --> 02:39:11.740]  вызывается над
[02:39:11.740 --> 02:39:13.740]  объектом
[02:39:13.740 --> 02:39:15.740]  not usable in constant expressions
[02:39:15.740 --> 02:39:17.740]  и время жизни началось
[02:39:17.740 --> 02:39:19.740]  вне этого выражения
[02:39:19.740 --> 02:39:21.740]  нельзя вычитать выражение
[02:39:21.740 --> 02:39:23.740]  которое превзойдет implementation defined limits
[02:39:27.740 --> 02:39:29.740]  нельзя вычитать выражение
[02:39:29.740 --> 02:39:31.740]  чье вычтение приведет к любому виду
[02:39:31.740 --> 02:39:33.740]  core language and defined behavior
[02:39:33.740 --> 02:39:35.740]  включая
[02:39:35.740 --> 02:39:37.740]  переполнение целочисленного int
[02:39:37.740 --> 02:39:39.740]  деление на ноль
[02:39:39.740 --> 02:39:41.740]  pointer arithmetic and sideware and bounce
[02:39:41.740 --> 02:39:43.740]  короче вот этот пункт вот по нему
[02:39:43.740 --> 02:39:45.740]  вот согласно этому пункту
[02:39:45.740 --> 02:39:47.740]  вычтения всего того было compile time
[02:39:47.740 --> 02:39:49.740]  что?
[02:39:49.740 --> 02:39:51.740]  убейтаце
[02:39:51.740 --> 02:39:53.740]  ну да здесь написано вот то что по сути убейтаце
[02:39:53.740 --> 02:39:55.740]  а лямбда expression
[02:39:55.740 --> 02:39:57.740]  до 7++17
[02:39:57.740 --> 02:39:59.740]  внимание вот это очень важный пункт
[02:39:59.740 --> 02:40:01.740]  начиная с 7++17 лямбды можно
[02:40:01.740 --> 02:40:03.740]  в constexpr делать
[02:40:03.740 --> 02:40:05.740]  просто лямда если сама лямда
[02:40:05.740 --> 02:40:07.740]  по себе ничего вот не нарушает
[02:40:07.740 --> 02:40:09.740]  того что перечислено в этом списке
[02:40:09.740 --> 02:40:11.740]  то лямду тоже можно создавать
[02:40:11.740 --> 02:40:13.740]  и вызывать в constexpr
[02:40:13.740 --> 02:40:15.740]  как перт работает если здесь нельзя вызывать
[02:40:19.740 --> 02:40:21.740]  я думаю что
[02:40:21.740 --> 02:40:23.740]  не не тут написано
[02:40:29.740 --> 02:40:31.740]  видимо вот этот пункт как раз
[02:40:31.740 --> 02:40:33.740]  те ограничения позволяет обойти
[02:40:35.740 --> 02:40:37.740]  неявная конверсия lvl
[02:40:37.740 --> 02:40:39.740]  ukrvl короче список
[02:40:39.740 --> 02:40:41.740]  из 35
[02:40:41.740 --> 02:40:43.740]  пяти пунктов
[02:40:43.740 --> 02:40:45.740]  что нельзя делать в constexpr выражениях
[02:40:45.740 --> 02:40:47.740]  нельзя делать
[02:40:47.740 --> 02:40:49.740]  вот смотрите нельзя делать throw
[02:40:49.740 --> 02:40:51.740]  нельзя делать assembler вставку
[02:40:51.740 --> 02:40:53.740]  нельзя делать
[02:40:53.740 --> 02:40:55.740]  var
[02:40:55.740 --> 02:40:57.740]  это вот помните в C у нас были функции
[02:40:57.740 --> 02:40:59.740]  с переменным количеством аргументов в стиле C
[02:40:59.740 --> 02:41:01.740]  вот их нельзя
[02:41:01.740 --> 02:41:03.740]  нельзя делать go to
[02:41:03.740 --> 02:41:05.740]  нельзя делать dynamic cast или typeid
[02:41:05.740 --> 02:41:07.740]  который бы бросил исключение
[02:41:07.740 --> 02:41:09.740]  и нельзя в лямда expression
[02:41:09.740 --> 02:41:11.740]  ссылаться на vis который
[02:41:11.740 --> 02:41:13.740]  был определен за пределами этой лямды
[02:41:13.740 --> 02:41:15.740]  если эта ссылка будет
[02:41:15.740 --> 02:41:17.740]  odruse
[02:41:17.740 --> 02:41:19.740]  вот смотрите как этот список
[02:41:19.740 --> 02:41:21.740]  поредел в c++20
[02:41:21.740 --> 02:41:23.740]  смотрите typeid
[02:41:23.740 --> 02:41:25.740]  нельзя было
[02:41:25.740 --> 02:41:27.740]  делать do c++20
[02:41:27.740 --> 02:41:29.740]  new expression
[02:41:29.740 --> 02:41:31.740]  delete expression
[02:41:31.740 --> 02:41:33.740]  ну вот new expression
[02:41:33.740 --> 02:41:35.740]  вообще нельзя было
[02:41:35.740 --> 02:41:37.740]  до c++20
[02:41:37.740 --> 02:41:39.740]  а начиная c++20
[02:41:39.740 --> 02:41:41.740]  дописка такая
[02:41:41.740 --> 02:41:43.740]  oracle
[02:41:43.740 --> 02:41:45.740]  std-allocator allocate
[02:41:45.740 --> 02:41:47.740]  если только эта
[02:41:47.740 --> 02:41:49.740]  allocation
[02:41:49.740 --> 02:41:51.740]  это replaceable global allocation
[02:41:51.740 --> 02:41:53.740]  function and allocated storage
[02:41:53.740 --> 02:41:55.740]  короче можно при условии
[02:41:55.740 --> 02:41:57.740]  что это все диалацируется
[02:41:57.740 --> 02:41:59.740]  в той же самой функции внутри вычтения
[02:41:59.740 --> 02:42:01.740]  внутри вычтения того же выражения
[02:42:01.740 --> 02:42:03.740]  а в той же функции
[02:42:03.740 --> 02:42:05.740]  isDialocated
[02:42:05.740 --> 02:42:07.740]  within the evaluation of this expression
[02:42:11.740 --> 02:42:13.740]  не знаю что это значит
[02:42:13.740 --> 02:42:15.740]  ну короче так написано
[02:42:15.740 --> 02:42:17.740]  что это должно проходить
[02:42:17.740 --> 02:42:19.740]  вот
[02:42:19.740 --> 02:42:21.740]  начиная с c++20 нельзя корутины
[02:42:21.740 --> 02:42:23.740]  его ap-yield
[02:42:23.740 --> 02:42:25.740]  вы и так не знаете что это
[02:42:25.740 --> 02:42:27.740]  поэтому не думайте об этом
[02:42:27.740 --> 02:42:29.740]  c++20 добавилось и constexpr
[02:42:29.740 --> 02:42:31.740]  не сделали
[02:42:31.740 --> 02:42:33.740]  до 714 нельзя было делать
[02:42:33.740 --> 02:42:35.740]  присваивания
[02:42:35.740 --> 02:42:37.740]  ну в общем вот
[02:42:37.740 --> 02:42:39.740]  ну а дальше объяснять что такое
[02:42:39.740 --> 02:42:41.740]  constant expression
[02:42:41.740 --> 02:42:43.740]  ну тут есть еще какие-то
[02:42:43.740 --> 02:42:45.740]  технические штуки
[02:42:45.740 --> 02:42:47.740]  converted constant expression, constant subexpression
[02:42:47.740 --> 02:42:49.740]  manifestly constant evaluated expressions
[02:42:51.740 --> 02:42:53.740]  я не хочу выяснять
[02:42:53.740 --> 02:42:55.740]  что это такое
[02:42:55.740 --> 02:42:57.740]  вы поняли что почти все можно
[02:42:57.740 --> 02:42:59.740]  в делать в constexpr начиная с c++20
[02:42:59.740 --> 02:43:01.740]  а вот
[02:43:01.740 --> 02:43:03.740]  с корутиными это типа
[02:43:03.740 --> 02:43:05.740]  просто потому что это решили не поддерживать
[02:43:05.740 --> 02:43:07.740]  потому что это непонятно зачем нужно
[02:43:07.740 --> 02:43:09.740]  я думаю что
[02:43:09.740 --> 02:43:11.740]  корутины дай бог
[02:43:11.740 --> 02:43:13.740]  чтобы и без constexpr
[02:43:13.740 --> 02:43:15.740]  нормально работали пока что
[02:43:15.740 --> 02:43:17.740]  то есть ты как бы ты только добавил
[02:43:17.740 --> 02:43:19.740]  огромную фичу в язык тебе бы ее
[02:43:19.740 --> 02:43:21.740]  сначала саму отдебажить чтобы она нормально
[02:43:21.740 --> 02:43:23.740]  работала там относительно них
[02:43:23.740 --> 02:43:25.740]  я думаю что это куча дискуссий
[02:43:25.740 --> 02:43:27.740]  как там что должно быть
[02:43:27.740 --> 02:43:29.740]  а ты хочешь их еще в constexpr разрешить
[02:43:29.740 --> 02:43:31.740]  потому что их только добавили и пока что
[02:43:31.740 --> 02:43:33.740]  я думаю да
[02:43:33.740 --> 02:43:35.740]  я думаю по той же причине почему
[02:43:35.740 --> 02:43:37.740]  и например нельзя
[02:43:37.740 --> 02:43:39.740]  freeway comparison
[02:43:39.740 --> 02:43:41.740]  почему spaceship
[02:43:41.740 --> 02:43:43.740]  оператор нельзя
[02:43:43.740 --> 02:43:45.740]  потому что она только в языке появилась
[02:43:45.740 --> 02:43:47.740]  не работает пока не трогает
[02:43:47.740 --> 02:43:49.740]  не работает пока не трогает
[02:43:49.740 --> 02:43:51.740]  не работает пока не заработает
[02:43:51.740 --> 02:43:53.740]  когда заработает все равно не трогает
[02:43:53.740 --> 02:43:55.740]  возможно в c++
[02:43:55.740 --> 02:43:57.740]  40 каком нибудь мы увидим все это
[02:43:57.740 --> 02:43:59.740]  тоже в constexpr
[02:43:59.740 --> 02:44:01.740]  судя по тенденции
[02:44:01.740 --> 02:44:03.740]  вполне допускаю что и трэды
[02:44:03.740 --> 02:44:05.740]  и корутины будут в constexpr
[02:44:05.740 --> 02:44:07.740]  в общем следите за
[02:44:07.740 --> 02:44:09.740]  новостями что называется
[02:44:09.740 --> 02:44:11.740]  на сегодня все
