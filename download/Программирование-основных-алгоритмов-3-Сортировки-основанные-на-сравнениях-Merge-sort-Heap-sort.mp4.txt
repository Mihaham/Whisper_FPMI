[00:00.000 --> 00:10.120]  Сегодня с вами мы начнем второй раздел, собственно первый это был всякие основы основ, там мы
[00:10.120 --> 00:15.120]  вспоминали бинпоиски, префиксные суммы, линейный контейнер, теперь мы с вами поговорим о такой
[00:15.120 --> 00:36.000]  вещи как сортировки, у нас раздел два, это будут сортировки и куча, вот чем будем с вами заниматься
[00:36.000 --> 00:45.720]  ближайшие две, может чуть больше лекций, и начнем мы с главного и основного, да вообще что такое
[00:45.720 --> 00:59.520]  сортировка, которая именно нас интересует, определение, а сортировка основанная на сравнениях
[00:59.520 --> 01:23.000]  это такая сортировка, что в ней можно только сравнивать элементы вау, то есть вы не знаете как
[01:23.000 --> 01:28.480]  внутри устроены эти элементы, например проинты вы знаете там что это 4 байта, да можно с ними что-то
[01:28.480 --> 01:35.600]  делать, простроки вы знаете что это там какие-то там набор букв, последовательность, вот конечно,
[01:35.600 --> 01:42.160]  а здесь мы будем уметь лишь сравнивать элементы, все, то есть это может быть там не знаю, ну что мы
[01:42.160 --> 01:46.400]  умеем сравнивать, например мы людей мы не умеем сравнивать, но как-то вы допустим определили как
[01:46.400 --> 01:49.960]  вы сравниваете людей, вот тогда это будет сортировка основанная на сравнениях, потому что больше
[01:50.960 --> 02:14.080]  ничего с ними не можете, который можно только сравнивать элементы, вот, ну и давайте мы докажем
[02:14.080 --> 02:29.560]  теорему, теорема звучит так, сортировка n элементов основанная на сравнениях,
[02:29.560 --> 02:55.360]  работает за вот такую вот интересную величину, работает за оногатый n луган времени, то есть
[02:55.360 --> 03:02.840]  он требуется хотя бы n луган там на какую-то константу, быстрее нельзя, вот один из тех
[03:02.840 --> 03:08.200]  немногих примеров когда мы будем доказывать что что-то будет связанное с омегой, ну давайте
[03:08.200 --> 03:23.960]  докажем, а для этого нам понадобится лемма, она звучит так, луган факториал это θ от n луган,
[03:23.960 --> 03:35.360]  ну здесь есть доказательство в одну строчку, это если знать формулу стирлинга, ну давайте хоть раз
[03:35.360 --> 03:45.160]  в жизни притворимся что мы ее не знаем, ну докажем наверное в одну сторону, ну сначала что это будет,
[03:45.160 --> 03:56.120]  давайте оценим луган факториал вообще, что это такое, ну это сумма по k от 1 до n логарифма в k,
[03:56.120 --> 04:05.720]  ну очевидно что это меньше либо равно, чем вот такая вот сумма, то есть я k заменяю на n верхним
[04:05.720 --> 04:17.760]  значением и ограничиваю, но это равно n луган, вот, в эту сторону было легко, теперь надо оценить снизу,
[04:17.760 --> 04:42.280]  ждем, ну пока напишу очевидно, вот так вот, ну то же самое что и сверху, теперь давайте я откушу от этой
[04:42.280 --> 04:51.320]  суммы хвост, ну так как села грифма я считаю положительной, ну давайте чтобы здесь эти основания
[04:51.320 --> 04:54.880]  все-таки, чтобы было корректно с математической точки зрения, возьмем везде двоичный,
[05:01.880 --> 05:09.640]  ну тогда я могу сделать вот такую вот интересную штуку, то есть опустить первую половину ряда,
[05:09.640 --> 05:17.440]  ну первую половину суммы, в плане того, что я меняю при делу суммирования и забываю про то,
[05:17.440 --> 05:23.960]  что там k от 1 до n пополам было у нас, он окей, теперь я могу сделать тогда еще ход дальше,
[05:23.960 --> 05:41.520]  я ограничу это вот такой вот штукой, то есть я все кашки заменил наименьшим значением,
[05:41.520 --> 05:59.080]  ну это понятно, уже равно n пополам, логарифм двоичный, это n пополам, вот, ну Леон доказали
[05:59.080 --> 06:14.160]  с вами, что конкретно, ну логарифм произведения, это сумма логарифмов, отлично, n факториал это
[06:14.160 --> 06:26.640]  1 умножить на 2, умножить на 3 и так далее, ну я вместо k поставил n, я же сверху оцениваю, все,
[06:26.640 --> 06:35.640]  логарифма антонная функция, где тета, нет, я просто неравенство выписываю, если не выписываю симптотики,
[06:35.640 --> 06:56.760]  где нет, это когда есть тета, нет, там будет омега. Ну да, здесь видите, как логарифм пополам,
[06:56.760 --> 07:05.920]  ну смотрите, окей, я могу сказать больше, ну что это больше либо равно чего, давайте подумаю с
[07:05.920 --> 07:23.320]  вами, ну как это можно оценить, ну что такое n пополам, а в логарифме 2 n пополам, это n пополам,
[07:23.320 --> 07:37.560]  вот такая вот штука, да, окей, то есть это n пополам, уберите по основанию 2 от n,
[07:37.560 --> 07:47.880]  минус n пополам, ну давайте мы сделаем вот как, я утверждаю, что начиная с какого-то n,
[07:47.880 --> 08:02.000]  эта штука будет больше либо равна что-нибудь типа такого, ну как-то можно доказать, найти минимальный
[08:02.000 --> 08:08.320]  n, для которого это верно, ну просто решить это неравенство, оно явно или поздно решится,
[08:08.320 --> 08:25.360]  ну давайте его решим, от n, окей, ну переносим это сюда, это сюда, что мы получаем, получаем,
[08:25.360 --> 08:31.760]  что у нас здесь n, зеленая натрия, логарифм по основанию 2 от n, больше либо равен чем n пополам,
[08:31.760 --> 08:39.840]  n сокращаем, этого следует, что логарифм по основанию 2 от n, больше либо равен чем 3 вторых,
[08:39.840 --> 08:47.800]  ну видимо n больше либо равен чем 2 степени 3 вторых, то есть начиная с таких n, у вас вот
[08:47.800 --> 09:00.120]  эта вот оценка выполняется, окей, ну для меньших n там нам не очень интересно, 2 степени 3 вторых,
[09:00.120 --> 09:06.160]  это не очень много, это 2 корни из 2, это что такое, это меньше 3 вообще, с n равны тройке,
[09:06.160 --> 09:12.920]  у вас все здесь верно, можно здесь строже оценку выбрать, и n на 4 какие-нибудь, и все вообще будет
[09:12.920 --> 09:20.160]  красиво, вот теперь доказать левму, а теперь будем доказывать саму теорему,
[09:20.160 --> 09:34.120]  вот здесь будет немножко такое эзотерическое доказательство, помимо того, что оно будет
[09:34.120 --> 09:38.880]  не математическое, вам придется думать, смотрите, что значит, что вы умеете сравнивать элементы,
[09:38.880 --> 09:45.360]  и только это делать, у вас, грубо говоря, есть какой-то оракул, у которого вы можете задать вопрос,
[09:45.360 --> 09:49.560]  правда ли, что x меньше y, и он вам ответит, да, нет, это все, что вы умеете делать,
[09:49.560 --> 09:56.600]  и причем у вас на вход передается какая-то перестановка, ну там, допустим, мы сортируем
[09:56.600 --> 10:01.640]  массив от 1 до n, и вам придется просто из чисел от 1 до n такая-то перестановка из этих чисел,
[10:01.640 --> 10:06.680]  то есть у вас на вход какая-то перестановка, и вы умеете спрашивать, правда ли, что x меньше y,
[10:06.680 --> 10:12.880]  если да, то я буду менять эти два числа местами, если не это надо, то есть вот ваш массив,
[10:12.880 --> 10:19.080]  вот у вас здесь где-то x, здесь где-то y, и вы спрашиваете, правда ли, что x меньше y,
[10:19.080 --> 10:25.480]  если да, то вы такие, окей, хорошо, здесь у нас все устраивало, буду там про что-нибудь другое
[10:25.480 --> 10:32.080]  спрашивать, если же наоборот, у вас там x больше y казалось, а мне надо поменять их, и дальше про
[10:32.080 --> 10:38.720]  что-то спрашивать, и того у нас что получается, у нас есть что-то на вход, и дальше у нас есть два
[10:38.720 --> 10:49.080]  варианта пути, и здесь мы получаем какие-то другие перестановки, снова два варианта,
[10:49.080 --> 10:58.720]  снова какие-то другие перестановки, и так далее, и так далее, и так далее, вот, ну, после кучи
[10:58.720 --> 11:07.200]  таких-то раций у нас получится такое вот огромное-огромное дерево, в котором листьям
[11:07.200 --> 11:11.240]  будут выступать все возможные варианты перестановок, потому что у вас дерево должно
[11:11.240 --> 11:15.960]  уметь отрабатывать для всех возможных перестановок на входе и выдавать верно отсортированную версию,
[11:15.960 --> 11:22.280]  это как-таки то, что вы хотите сделать, то есть у вас получается полное бинарное дерево, у которого
[11:22.280 --> 11:29.040]  n-факториал листьев, потому что перестановок n-факториал, давайте это как-то сформулируем теперь
[11:29.040 --> 11:34.080]  формально, вообще, такая штука называется решающим деревом, где вы спрашиваете какие-то вопросы,
[11:34.080 --> 11:39.720]  в зависимости от этого идёте в какие-то ветки, построим решающее дерево,
[11:39.720 --> 12:08.240]  где в узлах можно спрашивать x меньше y или нет, вот такие от нас вопросы будут,
[12:08.240 --> 12:16.400]  вот построить такое решающее дерево, тогда у него должно быть n-факториал листьев,
[12:16.400 --> 12:33.200]  давайте оценим высоту такого дерева, то есть пускай у нас высота дерева h,
[12:33.200 --> 12:43.960]  сколько у него тогда листьев будет, давайте подумаем с вами, ну да, у вас здесь два в нулевой,
[12:43.960 --> 12:52.760]  два в первый, два в второй, тогда или два в степня h, откуда вас следует, что его высота
[12:52.760 --> 13:15.920]  алгоритма двоичная, там факториал, ну это это это Эмбоген, вот он, Полемми. Ну понятное
[13:15.920 --> 13:22.560]  дело, что алгоритмы не так работают, то есть вы не строите нигде никогда в вашем коде решающее
[13:22.560 --> 13:27.640]  дерево сортировки и не спрашивайте, правда ли, что x и y должен менять местами, это просто такая
[13:27.640 --> 13:32.040]  теоретическая модель, в которой мы будем доказывать, что быстрее нельзя, ну и действительно,
[13:32.040 --> 13:40.200]  мы с вами показали с точки зрения вообще необходимого минимума действий, что нам нужно хотя бы
[13:40.200 --> 13:46.800]  это от Эмбоген действий, ну значит тогда у нас любая сортировка работает хотя бы за такое время,
[13:46.800 --> 13:51.560]  за Омега, потому что понятное дело, вы можете построить сортировку, которая будет работать дольше,
[13:51.560 --> 14:08.960]  но быстрее нельзя, быстрее, чем за этот Эмбоген нельзя.
[14:08.960 --> 14:28.360]  Доказали? Вопросы? Потому что вам нужно все возможные перестановки собрать. Ну конечно,
[14:28.360 --> 14:36.960]  например, у вас массив был для двух элементов, да? Вот у вас 1, 3, 2 массив. Ну давайте в индексах это
[14:36.960 --> 14:42.240]  будет 0, 1, 2. Тогда исходная перестановка, какая будет? Что у вас на первом месте стоит
[14:42.240 --> 14:49.360]  элемент с 0 индексом, на втором месте стоит элемент с индексом 2 и на третьем месте
[14:49.360 --> 14:54.880]  стоит элемент с индексом 1. То есть вот ваша искомая перестановка. И как бы я здесь не
[14:54.880 --> 15:06.600]  переставил элементы, я получу 7 факториал разных ответов. Потому что мы считаем,
[15:06.600 --> 15:11.160]  что у нас высота это сколько нам операции надо сделать, чтобы спуститься от корня до листа.
[15:11.160 --> 15:15.800]  То есть у нас есть какой-то вход, и дальше мы должны вот хотя бы Эмбоген спусков вниз
[15:15.800 --> 15:24.960]  делать, чтобы дойти до ответа. Ну это, смотрите, решающее дерево, да, это такая штука, где вы
[15:24.960 --> 15:33.480]  спрашиваете, правда ли, что там. Например, здесь вопрос, а ИТ меньше, чем ОЖИТОЕ? И в зависимости
[15:33.720 --> 15:47.800]  от этого вы идете дальше туда или туда? Кого с кем сравниваете? Я еще раз говорю, что мы доказали в
[15:47.800 --> 15:53.000]  теоретической модели, что нельзя быстрее, что хотя бы Эмбоген нам потребуется. Ну и стед исследует
[15:53.000 --> 15:58.880]  Омега большая так-то. Понятно, что вы можете алгоритм медленнее написать. Но мы как бы доказали такую
[15:58.880 --> 16:05.000]  теоретическую оценку, что лучше нельзя. Вот. Но пока что мы еще не привели ни одного алгоритма,
[16:05.000 --> 16:15.440]  чтобы от Эмбоген работающего, чтобы можно было строго за это оценивать. Вот. Окей, а теперь что?
[16:15.440 --> 16:26.320]  Ну давайте построим такой алгоритм. Следующий раздел — это сортировка слиянием.
[16:26.320 --> 16:39.800]  Просьба предупредить, когда там перерыв будет. Вот. Окей, что такое сортировка слиянием? Устроено
[16:39.920 --> 16:51.320]  очень просто на самом деле. Психотокод у нее примерно такой. Ну мерч что-то сливать,
[16:51.320 --> 17:01.320]  поэтому мерч-сорт. Не знаю. От А. Просто А. Ну этот психотокод здесь можно вообще типа не писать.
[17:01.320 --> 17:18.760]  Вот. Что мы будем здесь делать? Будем вызывать рекурсивно мерч-сорт от А0. Давайте АН сюда
[17:18.760 --> 17:25.480]  передадим. Н как размер. Н пополам. То есть вот такая вот строка у нас будет. То есть мы будем
[17:25.480 --> 17:35.760]  вызывать мерч-сорт от левой половины массива. Дальше будет мерч-сорт от правой половины массива.
[17:35.760 --> 17:53.600]  А ну давайте LR. Даже не так. Ну может здесь LR пойдет по названиям. У нас правда N не
[17:53.600 --> 18:05.400]  определено. Давайте я напишу твой здесь типа. N равно R-L. Ну я думаю понятно, короче говоря,
[18:05.400 --> 18:17.520]  что хочу сделать. Вот. И дальше у нас идет следующая процедура. Мерч от A0 N пополам N.
[18:17.520 --> 18:32.760]  Такая вот интересная сортировка. Ну это все, если что. В чем ее смысл? То есть мы рекурсивно. Сначала
[18:32.760 --> 18:38.960]  объясню, что такое вообще смысл. Сначала вы разбиваете массив на две половинки. Каждую из них
[18:38.960 --> 18:46.280]  будто бы сортируете. А дальше вы здесь делаете мерч. Это вы сливаете два массива от сортированных.
[18:46.280 --> 18:53.480]  Давайте подумаем, то есть как это будет выглядеть. Вот допустим у вас там один массив. И вот допустим у
[18:53.480 --> 19:06.840]  вас другой массив. Тогда итоговый результат по действию мерч. Это будет 1, 2, 3, 4, 5, 6. То есть
[19:06.840 --> 19:14.520]  это вот такая процедура. То есть грубый вариант на вход у вас принимает массив 1, 3, 6, 2, 4, 5 и знает,
[19:14.520 --> 19:21.880]  что у вас здесь граница. То есть это 0, это N, это N пополам. Вот 0, N пополам N. И дальше выполняем
[19:21.880 --> 19:34.240]  такое вот слияние. То есть два сортированных массива сливают в один. Ну база рекурсии здесь
[19:34.240 --> 19:40.680]  понятна. Когда у вас один элемент, он отсортирован. Очень концептуальная база. Вот.
[19:40.680 --> 19:52.360]  Потому что мы хотим отсортированный массив получить в конце концов. То есть смотрите,
[19:52.360 --> 19:58.640]  мы гарантируем, что после вызова мерч-сорт массив, от которого мы вызвали, или его кусок,
[19:58.640 --> 20:09.080]  он будет отсортирован. Ну вот. Потому что у нас вот один кусок от 0 до N пополам,
[20:09.080 --> 20:16.040]  вот второй кусок от N пополам до N. Видите, здесь граница. Вот он отсортирован и он отсортирован.
[20:16.040 --> 20:21.400]  Но вместе, если вдвоем их сконцентрировать, они отсортированы. Как раз мерч их и сортирует.
[20:21.400 --> 20:34.560]  Ну должны, конечно. Но это псевдокод и здесь как бы чисто идейная вещь. Вот детали. Ну здесь
[20:34.560 --> 20:42.320]  понятно, нужно базу прописать сюда. Нормальные аргументы назвать и все такое. Вот. По-хорошему
[20:42.320 --> 20:53.280]  надо здесь запускаться от L до L плюс R минус L пополам. Вот. Здесь там тоже как-то
[20:53.280 --> 20:57.440]  называть верно границе и здесь тоже верно назвать границу. Вот. Здесь у нас просто псевдокод.
[20:57.440 --> 21:03.640]  Окей, давайте, ну это понятно, это рекурсивные вызовы. Теперь надо обсудить с операцией мерч.
[21:03.640 --> 21:25.440]  Что это такое? Давайте посмотрим, как реализовывать мерч. Сначала идейно. Вот ваши два массива. Это будет
[21:25.440 --> 21:40.280]  И и это будет G. Вы смотрите, правда ли, что элемент под этим указателем, короче, вот этот вот
[21:40.280 --> 21:47.480]  элемент под буквой И, правда ли, что он меньше, чем элемент связан с буквой G? Если да, то пишите
[21:47.480 --> 21:52.800]  его первым. Потому что понятное дело, что минимум вот этого массива, то минимум из этих двух. Потому
[21:52.800 --> 22:01.480]  что они оба отсортированы. Выписали единичку и сдвинули соответствующий индекс вперед. Дальше
[22:01.480 --> 22:09.640]  смотрите, кто круче. И лежи. Нужит элемент круче. Выписывайте двойку. Круче в плане меньше. Издвигаете
[22:09.640 --> 22:22.760]  указатель на один вперед. Дальше здесь три-четыре. Ну три меньше, поэтому выписываем три. Да, если что,
[22:22.760 --> 22:28.080]  мы все это пишем в отдельный массив. Мы не пишем их как-то на месте, не перезаписываем ничего. То есть
[22:28.080 --> 22:47.640]  мы здесь до памяти будем выделять. Дальше здесь четыре, здесь пять и шесть. За сколько это работает?
[22:47.640 --> 22:58.040]  Ну если размеры массивов N и M, то за о-от их сумма. Вот так вот скажем. На это пишем код.
[22:58.040 --> 23:19.320]  А, Н, Б. Ну псевдокод, конечно. Типа А и Б это что-нибудь типа вектор НТОВ. А Н и М это их там размеры.
[23:19.320 --> 23:34.120]  Сначала мы говорим, там res равно вектор int там вот N плюс M ноль. Ну что-нибудь такое.
[23:34.120 --> 23:51.160]  Это же все на уровне псевдокода. Папапам. Ну говорим и ж равно нулю. Теперь делаем while и меньше N,
[23:51.160 --> 24:10.160]  ж меньше M. Ну и ж меньше M. И начинается, что если А и ты меньше чем B, ж и ты, то что тогда мы делаем?
[24:10.160 --> 24:28.160]  Ну говорим res и plus j равно а и ты. Ну плюс плюсы. Там иначе. Мы делаем почти все то же самое.
[24:28.160 --> 24:45.160]  То есть у нас теперь момент, когда один из указателей дошел до конца своего массива. Например, это вот такая вот стадия.
[24:45.160 --> 24:57.160]  Собственно, здесь вам нужно, вы здесь понимаете уже, что у вас один из массивов закончился. Здесь нужно
[24:57.160 --> 25:05.160]  описать просто еще два while будет внизу. Который будет в while доводить один массив до конца и while доводить другой массив до конца.
[25:05.160 --> 25:11.160]  Потому что если вывели все уже элементы в одном массиве, значит все элементы дальше в этом, если бы они тут еще были,
[25:11.160 --> 25:17.160]  они были бы все строго больше, чем этот. А так этот массив отсортирован, их можно просто подряд все выписывать.
[25:17.160 --> 25:27.160]  Ну, например, у вас здесь была бы еще семерка впереди. Что-нибудь такое. Вот тогда выписали бы 6, 7, 9 просто вперед идя.
[25:27.160 --> 25:47.160]  Ну, естественно, здесь вторая часть кода будет что-то типа такого. While и меньше n. Если t plus j равно aity, плюс-плюс и.
[25:47.160 --> 25:59.160]  И здесь будет еще такое же while, только для второго массива. Причем, заметьте, что while только один всегда запустится, один из двух,
[25:59.160 --> 26:17.160]  потому что по одному массиву были обязаны дойти до конца.
[26:17.160 --> 26:25.160]  Ну, там дальше я не знаю, что вы с этим массивом будете делать. Возвращать этот рез или что-нибудь еще там делать.
[26:25.160 --> 26:36.160]  Это уже, скажем так, не моя забота, как вы это будете реализовывать внутри. Но сама идея слияния, она вот такая вот.
[26:36.160 --> 26:48.160]  Круто, да? Скоростном времени. Так, окей. Давайте подумаем, за сколько времени работает эта штука.
[26:48.160 --> 27:16.160]  Ну, как будут идеи, как ценят время работы?
[27:16.160 --> 27:31.160]  Ну, это хорошо. Да что вы, какой-то мастер терем пользы. Вы помните формулировку?
[27:31.160 --> 27:41.160]  То есть у нас вот такая вот какая-то с вами рекуррента. Это у нас будет наш мерч, он же за линию работает.
[27:41.160 --> 27:52.160]  А это будут два рекурсивных вызова мерч сорта. Ну, понятное дело, что вы имеете здесь право оценивать через мастер терему.
[27:52.160 --> 28:09.160]  У меня что-то так лень. Я лучше оценю как-нибудь вот так вот. Ну, как здесь можно оценить? Что это 4t от n на 4.
[28:09.160 --> 28:26.160]  Плюс что? То есть я здесь раскрываю. 2t от n пополам. Тра-та-та. Ну, что-то типа 2t от n пополам. Плюс от n.
[28:26.160 --> 28:38.160]  Ну, давайте я напишу здесь, чтобы без ошек было. Я напишу, что это плюс какая-то константа нож на c. То есть мерч выполняется в время константа на c.
[28:38.160 --> 29:04.160]  Это константа c. Вот, чтобы избежать потом всяких проблем. Здесь тоже лишнее. То есть 4t от n на 4 плюс 2c от n.
[29:04.160 --> 29:16.160]  Ну, здесь двойка сокращается. cn плюс cn складывается. Получается 2cm. Ну, вы не поверите, но если я сделаю сейчас третий шаг.
[29:16.160 --> 29:28.160]  Ну, я сделал катой. 2 в катой. t от n делить на 2 в катой. Плюс k на c на m.
[29:28.160 --> 29:38.160]  Ну, если вы сделаете здесь еще один шаг, вы поймете, что у вас сюда прибавится 4t от n делить на 4 и все. Что равно?
[29:38.160 --> 29:58.160]  k равно логарифм на 2c на n. Ну, давайте скажем так, что просто без целой части. Получим, что это просто-напросто c на n на логарифм на 2c на n.
[29:58.160 --> 30:06.160]  Вот такое. Ну, здесь можно верхнюю часть оценить через плюс один, но здесь нам не очень важно принципиальный порядок.
[30:06.160 --> 30:22.160]  То есть здесь рекуррента легкая на самом деле. Она не требует никаких специальных знаний. Вот. Ну да, получаем cn лог n. То есть время работы.
[30:22.160 --> 30:30.160]  Вот. Это один из тех немногих алгоритмов, где мы можем сказать, что это действительно будет t от n лог n.
[30:30.160 --> 30:42.160]  Во-первых, потому что работает 2o от n лог n. Во-вторых, можно сказать, что быстрее нельзя. Вот как-то так. Да.
[30:43.160 --> 30:51.160]  Ну, чтобы у нас часть под, то есть чтобы у нас здесь вышел что-то меньше единицы. Ну, конечно.
[30:51.160 --> 31:00.160]  Ну, потому что у нас t от гамма, где гамма меньше единицы, это ноль. Мы договаривались с вами. Потому что мы не умеем делать там операцию с половинкой элемента.
[31:00.160 --> 31:10.160]  Так, окей. То есть мы с вами вот построили сортировку, которая работает за t от n лог n. Мы сами молодцы.
[31:12.160 --> 31:14.160]  Окей. Так.
[31:14.160 --> 31:16.160]  Так.
[31:21.160 --> 31:30.160]  Давайте мы сделаем вот как. Сейчас мы начнем немножко другую тему. Если у нас останется время на лекции, то я докажу пару интересных фактов про мерш.
[31:32.160 --> 31:36.160]  Ну, если не останется, значит не будет на следующей лекции просто-напросто.
[31:37.160 --> 31:41.160]  Вот. А вам, чтобы задачу решать, нужна сейчас немного другая тема.
[31:42.160 --> 31:44.160]  Давайте там сотрем.
[31:45.160 --> 31:53.160]  Собственно, тема называется «бинарная куча». В общем, в целом, что такое куча? Мы с вами обсудим.
[31:57.160 --> 32:00.160]  Почему? Помершь? Да.
[32:06.160 --> 32:08.160]  А второй меньше, чем бы первый?
[32:13.160 --> 32:15.160]  Чего-нибудь типа такого?
[32:18.160 --> 32:20.160]  Ну, вот вы выписали один.
[32:21.160 --> 32:23.160]  Сдвинули указатель сюда.
[32:24.160 --> 32:27.160]  Дальше выписали два. Сдвинули указатель сюда. Выписали семь.
[32:28.160 --> 32:32.160]  Ну, вот вы выписали один. Сдвинули указатель сюда.
[32:33.160 --> 32:36.160]  Дальше выписали два. Сдвинули указатель сюда. Выписали семь.
[32:37.160 --> 32:39.160]  Окей.
[32:48.160 --> 32:50.160]  Так.
[32:51.160 --> 32:53.160]  Куча.
[32:54.160 --> 32:56.160]  Бинарная куча.
[32:58.160 --> 33:04.160]  Окей. Собственно, куча, что это такое?
[33:05.160 --> 33:10.160]  Куча – это нечто, что позволяет вам делать следующие операции.
[33:11.160 --> 33:14.160]  А именно, ставка,
[33:17.160 --> 33:19.160]  insert,
[33:20.160 --> 33:22.160]  извлечение минимума.
[33:27.160 --> 33:32.160]  То есть это нечто, куда можно добавлять элементы и дальше извлекать из нее минимумы.
[33:33.160 --> 33:36.160]  Ну, в плане извлекать с удалением. То есть у вас там лежали один, два, три, четыре, пять.
[33:37.160 --> 33:42.160]  Вы говорите, извлеки минимум, а она такая, окей, у тебя осталось два, три, четыре, пять в куче.
[33:43.160 --> 33:45.160]  И так далее.
[33:46.160 --> 33:50.160]  Вот. Мы хотим построить такую структуру, которую мы будем делать это и это.
[33:52.160 --> 33:54.160]  Ну, в частности, мы будем делать это и это.
[33:54.160 --> 33:56.160]  Ну, в частности, мы будем строить бинарную.
[33:57.160 --> 33:59.160]  Есть еще другие кучи, есть всякие бидмяльные.
[34:00.160 --> 34:02.160]  Там фибоначевы,
[34:03.160 --> 34:05.160]  эливацкие, косы и так далее.
[34:06.160 --> 34:08.160]  Куча очень много, вот.
[34:09.160 --> 34:12.160]  И у них там всех разные вещи, у них там разные оценки на время этих операций.
[34:13.160 --> 34:15.160]  И некоторые из них еще умеют делать мерш.
[34:16.160 --> 34:18.160]  То есть они умеют как бы две кучи взять и превратить в одну большую кучу.
[34:19.160 --> 34:21.160]  Вот.
[34:21.160 --> 34:24.160]  Со сливаемыми кучами я особо на практике не сталкивался.
[34:25.160 --> 34:28.160]  Но вот с бинарной кучей периодически бывает, да.
[34:29.160 --> 34:31.160]  Окей.
[34:32.160 --> 34:34.160]  Что мы будем делать?
[34:35.160 --> 34:38.160]  Давайте мы просто определим бинарную кучу как что.
[34:39.160 --> 34:41.160]  То есть бинарная куча.
[34:43.160 --> 34:49.160]  Это у нас будет полное бинарное дерево.
[34:50.160 --> 34:58.160]  Полное бинарное дерево,
[35:04.160 --> 35:14.160]  для которого элемент всегда меньше своих детей.
[35:20.160 --> 35:23.160]  Вот эта вот фраза, элемент меньше своих детей,
[35:24.160 --> 35:29.160]  она как раз таки обозначает свойства кучи, инвариант, кучи это еще называют.
[35:30.160 --> 35:34.160]  Окей, какое дерево называют бинарным?
[35:35.160 --> 35:39.160]  Дерево бинарное, если оно подвешенное, то есть у него есть какой-то корень,
[35:40.160 --> 35:42.160]  оно там растет в какую-то сторону.
[35:43.160 --> 35:45.160]  То есть, например, что-нибудь такое.
[35:46.160 --> 35:48.160]  Сейчас так вот.
[35:50.160 --> 35:53.160]  Перед вами бинарное дерево.
[35:54.160 --> 35:57.160]  То есть каждого узла не больше двух детей.
[35:58.160 --> 36:00.160]  Вот.
[36:01.160 --> 36:03.160]  Окей.
[36:04.160 --> 36:06.160]  Что значит полное?
[36:07.160 --> 36:11.160]  Полное это значит, что у вас почти все узлы двухдетные.
[36:12.160 --> 36:15.160]  Ну, как-то понимать.
[36:15.160 --> 36:17.160]  Вот пример полного бинарного дерева.
[36:17.160 --> 36:19.160]  Причем, если у узла только один ребенок, то это левый ребенок,
[36:19.160 --> 36:21.160]  которых слева мы рисуем.
[36:22.160 --> 36:23.160]  Вот.
[36:23.160 --> 36:25.160]  Это, например, полное бинарное дерево на сколько?
[36:25.160 --> 36:27.160]  Шесть элементов.
[36:30.160 --> 36:32.160]  Вот это вот на трех.
[36:32.160 --> 36:34.160]  Это на четырех полное бинарное.
[36:36.160 --> 36:37.160]  Вот.
[36:37.160 --> 36:41.160]  И при этом мы знаем, что элемент в узле всегда больше двух детей.
[36:42.160 --> 36:43.160]  Вот.
[36:43.160 --> 36:47.160]  И при этом мы знаем, что элемент в узле всегда меньше, чем его дети.
[36:48.160 --> 36:50.160]  Ну, давайте не больше скажем.
[36:50.160 --> 36:53.160]  То есть у нас выполнено вот такие вот соотношения здесь везде на ребрах.
[36:55.160 --> 36:58.160]  Ну, тогда понятно, где у вас лежит минимум.
[37:00.160 --> 37:02.160]  Где минимум лежит такой куча?
[37:02.160 --> 37:04.160]  Да, в корне.
[37:05.160 --> 37:06.160]  Вот.
[37:06.160 --> 37:08.160]  Осталось научиться в нее вставлять элементы.
[37:09.160 --> 37:13.160]  И удалять элемент, удалять корень.
[37:15.160 --> 37:17.160]  Ну, полное бинарное дерево, смотрите.
[37:17.160 --> 37:19.160]  Это дерево, которое...
[37:19.160 --> 37:21.160]  Вот вы рисуете дерево бинарное,
[37:21.160 --> 37:24.160]  вы заполните все его слои вот так вот сверху, вниз, слева, направо.
[37:24.160 --> 37:26.160]  Пока у вас есть элементы.
[37:27.160 --> 37:30.160]  То есть у вас не может быть вот такой вот ситуации.
[37:31.160 --> 37:33.160]  Вы можете этот элемент сюда перекинуть.
[37:38.160 --> 37:40.160]  Теория детей тоже меньше дам?
[37:41.160 --> 37:43.160]  Ну, для всех детей да меньше, Любровна.
[37:44.160 --> 37:46.160]  Нет, нет, это деревья поиска будут.
[37:47.160 --> 37:49.160]  Когда, если вы будете больше здесь писать.
[37:52.160 --> 37:54.160]  А вы сколько хотите?
[37:58.160 --> 38:02.160]  Вот. Докажите, что обе эти операции нельзя сделать золоть единицы.
[38:04.160 --> 38:06.160]  Не такое упражнение, но подумать.
[38:06.160 --> 38:09.160]  Используя теорему, которую мы сегодня доказали.
[38:11.160 --> 38:14.160]  Ну, понятно, что если вы возьмете, вставите n раз элементы,
[38:14.160 --> 38:16.160]  а дальше n раз извлечете минимум все пол от единицы,
[38:16.160 --> 38:18.160]  вау, вы ассортировали массив.
[38:18.160 --> 38:20.160]  За отn.
[38:20.160 --> 38:22.160]  А куча как гнуло.
[38:22.160 --> 38:24.160]  Мы так не умеем делать, а куча умеет только сравнивать элементы,
[38:24.160 --> 38:26.160]  мы от нее больше ничего не требуем.
[38:26.160 --> 38:28.160]  Окей.
[38:28.160 --> 38:30.160]  Собственно, как...
[38:30.160 --> 38:32.160]  Ну, за счет чего она будет поддерживать свои свойства,
[38:32.160 --> 38:34.160]  свойства кучи, так называемые.
[38:35.160 --> 38:39.160]  Для этого куча имеет две операции со своими элементами.
[38:40.160 --> 38:42.160]  Одна из них поднять вверх, другая утопить.
[38:44.160 --> 38:46.160]  Вот.
[38:46.160 --> 38:48.160]  Ну, или еще просеивание, вверх-низ они называются.
[38:48.160 --> 38:50.160]  Давайте рассмотрим ситуацию.
[38:52.160 --> 38:54.160]  Чего-нибудь типа такого.
[38:54.160 --> 38:56.160]  Вот.
[39:02.160 --> 39:04.160]  Вот у вас дерево с нарушенным свойством кучи,
[39:06.160 --> 39:08.160]  у вас для этого узла не выполнено,
[39:08.160 --> 39:10.160]  что здесь меньше либо равно, здесь меньше либо равно.
[39:10.160 --> 39:12.160]  Вот. Что происходит.
[39:12.160 --> 39:15.160]  Эта штука сплапывает с наименьшим из детей.
[39:15.160 --> 39:17.160]  Просеивание вниз, так сказать.
[39:17.160 --> 39:25.940]  Просеивание вниз.
[39:25.940 --> 39:31.500]  Она свапывает с ребенком значение, с наименьшим
[39:31.500 --> 39:32.500]  причем.
[39:32.500 --> 39:38.500]  Типа while, типа пока можем, не знаю, давайте по-русски
[39:38.500 --> 39:39.500]  напишу.
[39:39.500 --> 39:55.360]  Пока свойство куча нарушено, свапни, ну, обменяем местами
[39:55.360 --> 40:02.940]  элемент с меньшим сыном.
[40:02.940 --> 40:11.580]  То есть вот она здесь 10 и 5 свапнула, смотрит, блин,
[40:11.580 --> 40:13.380]  тут снова свойство кучи нарушено, есть сын, который
[40:13.380 --> 40:14.380]  меньше меня.
[40:14.380 --> 40:19.660]  И свойство кучи восстановлено, ура.
[40:19.660 --> 40:32.380]  Ну, предположим пока что, что мы по элементу можем
[40:32.380 --> 40:34.540]  знать его родителя и его двух детей.
[40:34.540 --> 40:39.060]  Пока что это великое знание, которое нам неизвестно,
[40:39.060 --> 40:41.180]  потом мы придумаем как это сделать.
[40:41.180 --> 40:43.100]  Допустим, у нас есть этот функционал.
[40:43.100 --> 40:47.700]  Ну и там будет понятно, зачем нам полнота беременного
[40:47.700 --> 40:48.700]  нужно.
[40:48.700 --> 40:51.900]  Собственно просевание вверх, это наоборот, если здесь
[40:51.900 --> 40:54.380]  вы топили элемент как можно дальше вниз, то здесь
[40:54.380 --> 40:55.940]  наоборот он будет у вас всплывать.
[40:55.940 --> 41:00.940]  Чего-нибудь такого сейчас.
[41:00.940 --> 41:14.620]  Вот такая вот ситуация, и вот вам нужно, чтобы один
[41:14.620 --> 41:15.620]  всплыл наверх.
[41:15.740 --> 41:17.260]  То есть у вас здесь нарушено свойство кучи.
[41:17.260 --> 41:20.700]  Например, можно либо тройку просеять вниз, либо наоборот
[41:20.700 --> 41:24.180]  единичку поднять вверх, здесь как вам удобнее это все
[41:24.180 --> 41:25.180]  принимать.
[41:25.180 --> 41:26.660]  Вот просеивание вверх.
[41:26.660 --> 41:44.100]  В английском это shift down, здесь это будет shift up.
[41:44.100 --> 41:59.380]  То есть пока нарушено свойство кучи, меняй элемент с родителем.
[41:59.380 --> 42:08.020]  Ну и все, это вот две операции, которые вам будут нужны
[42:08.020 --> 42:10.060]  дальше, мы через них будем все остальное выражать.
[42:10.060 --> 42:17.260]  Окей, давайте поговорим про выразимость операции
[42:17.260 --> 42:19.260]  через просеивание.
[42:19.260 --> 42:21.580]  Давайте обсудим, как будет делаться инсерт.
[42:21.580 --> 42:30.220]  Ну и давайте какую-нибудь кучу нарисуем для примера.
[42:30.220 --> 42:46.300]  Вот тут отмена, здесь 3, здесь давайте 2, здесь 5, здесь 6.
[42:46.300 --> 42:52.940]  Вот что-нибудь такое, вот куча, и тут я говорю, давайте
[42:52.940 --> 42:56.060]  здесь 4 сделаем.
[42:56.060 --> 43:11.260]  Вот, я говорю, инсерт 3, что мы тогда делаем, ну конечно,
[43:11.260 --> 43:12.260]  здесь можно.
[43:12.260 --> 43:13.260]  Что?
[43:13.260 --> 43:19.660]  Только как левым ревенком четверки мы его записываем.
[43:19.660 --> 43:25.420]  Ну это правда, да, и делайте shift up.
[43:25.420 --> 43:28.780]  То есть будто бы добавляйте ее в дерево, крайним листом,
[43:28.780 --> 43:29.780]  назовем это так.
[43:29.780 --> 43:33.100]  Так сказать, спойлерну, потом это будет не дерево,
[43:33.100 --> 43:34.100]  это будет массив.
[43:34.100 --> 43:35.100]  Вот.
[43:35.100 --> 43:37.100]  Мы будем ее в массиве хранить, а не в дерево, там будет
[43:37.100 --> 43:38.100]  все понятно.
[43:38.100 --> 43:39.100]  Вот.
[43:39.100 --> 43:40.620]  Поэтому, конечно, не пугайтесь, что я такими запутанными
[43:40.620 --> 43:41.620]  фразами говорю.
[43:41.620 --> 44:00.740]  Добавим элемент крайним листом, сделаем shift up, потому
[44:00.740 --> 44:02.820]  что свойство кучи может быть нарушено, когда мы
[44:02.820 --> 44:03.820]  добавили этот элемент.
[44:03.820 --> 44:07.380]  То есть здесь все было стабильно, и тут стабильность разрушена.
[44:07.380 --> 44:12.660]  Тогда нужно поднять добавленный элемент вверх, то есть здесь
[44:12.660 --> 44:13.660]  их свапнуть.
[44:13.660 --> 44:17.020]  Тогда у нас здесь будет тройка здесь сидится, и свойство
[44:17.020 --> 44:19.700]  кучи не нарушено выше, и дальше просеивать не нужно.
[44:19.700 --> 44:30.100]  Следовательно, экстракт мин как делается тогда?
[44:30.100 --> 44:31.340]  Экстракт мин делается следующим образом.
[44:31.340 --> 44:52.060]  Вот у меня происходит экстракт мин, происходит страшное.
[44:52.060 --> 45:06.940]  Шаг первый – это обменять корень с крайним листом,
[45:06.940 --> 45:09.100]  потому что вырезать корень – это как вырезать голову
[45:09.100 --> 45:11.900]  всего этого семейства, это слишком жестоко, потому
[45:11.900 --> 45:13.540]  что тогда непонятно, что с ним вообще делать.
[45:14.540 --> 45:16.900]  То есть мы в этом меняем их сначала местами.
[45:16.900 --> 45:21.100]  Здесь будет 4, здесь один.
[45:21.100 --> 45:25.980]  Дальше, мы говорим, второй шаг – это отрезать крайний
[45:25.980 --> 45:27.140]  лист, то есть забыть его.
[45:27.140 --> 45:41.660]  Все, больше нет этого чувака.
[45:41.780 --> 45:44.020]  Последнее вам нужно, единственное дело, где у вас могло нарушиться
[45:44.020 --> 45:47.260]  свойство кучи – это в корне, нужно делать сивдаун от корни.
[45:47.260 --> 46:04.540]  Ну все, давайте подумаем, за сколько это работает.
[46:04.540 --> 46:09.660]  Так у вас n элементов, то высота бинарного дерева
[46:09.660 --> 46:10.660]  на n элементах какая?
[46:10.660 --> 46:11.660]  Log n.
[46:11.660 --> 46:18.460]  Значит, все за от log n делается.
[46:18.460 --> 46:19.460]  Обе операции.
[46:19.460 --> 46:39.580]  За от h, высота куча, равно от log n.
[46:39.580 --> 46:46.020]  Окей, теперь следующее, чем мы займемся, это как
[46:46.020 --> 46:47.020]  хранить кучу.
[46:47.020 --> 46:48.020]  Да.
[46:48.020 --> 46:49.020]  Какие?
[46:49.020 --> 46:50.020]  Сивдаун и сифтап?
[46:50.020 --> 47:07.260]  Ну, свап вы типа берете, ну сейчас мы поймем как-то
[47:07.260 --> 47:08.900]  сделать так, чтобы это можно было делать мгновенно.
[47:08.900 --> 47:17.900]  Хранение кучи.
[47:17.900 --> 47:19.900]  Давайте выпишем снова прекрасное дерево.
[47:19.900 --> 47:31.660]  Что-нибудь такое.
[47:31.660 --> 47:33.220]  И давайте выпишем в таком порядке.
[47:34.220 --> 47:37.220]  Вот так вот.
[47:37.220 --> 47:40.220]  Раз, два, три.
[47:40.220 --> 47:43.340]  То есть такого змейка будем выписывать в массив.
[47:43.340 --> 47:49.500]  То есть сначала один на верхнем уровне, дальше два, три,
[47:49.500 --> 47:56.940]  дальше четыре, семь, пять.
[47:56.940 --> 47:58.220]  Нарисуем, что это будто бы массив.
[47:58.220 --> 48:02.740]  Победа.
[48:02.740 --> 48:05.740]  То есть мы храним кучу теперь как массив.
[48:05.740 --> 48:13.420]  Вот, давайте выясним по индексу, где находятся его
[48:13.420 --> 48:14.420]  левые и правые дети.
[48:14.420 --> 48:28.140]  Храним в массиве, пусть и это индекс элемента.
[48:28.140 --> 48:46.220]  Тогда индексы родителя левого сына, правого сына.
[48:46.300 --> 48:58.740]  Здесь ноль, один, два, три, четыре, пять.
[48:58.740 --> 49:05.420]  Я утверждаю, что индекс левого сына это два на и.
[49:05.420 --> 49:09.740]  Плюс один у правого сына два на и, плюс два.
[49:10.260 --> 49:20.660]  А у родителя это будет что-то типа, сейчас соображу, что-то
[49:20.660 --> 49:22.260]  типа и минус один пополам.
[49:22.260 --> 49:26.620]  Так мы с нуля номируем.
[49:26.620 --> 49:30.500]  Ну, если единицы номировать, то все проще, у вас массив
[49:30.500 --> 49:33.100]  этого будете с нуля номировать, когда вы будете писать код.
[49:33.100 --> 49:38.700]  Ну, имеется в виду, что здесь нижняя часть.
[49:39.660 --> 49:40.660]  Такое вот округление.
[49:40.660 --> 49:47.980]  Ну, вроде бы сходится по формулам, пять минус один
[49:47.980 --> 49:50.140]  это четыре пополам, это два.
[49:50.140 --> 49:52.340]  Четыре минус один, это три пополам, полтора округляем
[49:52.340 --> 49:53.340]  вниз один.
[49:53.340 --> 49:58.740]  Вроде по формулам сходится, но строгое, чтобы доказать
[49:58.740 --> 50:03.980]  вам, нужно понять, что элементов вот здесь столько же сколько
[50:03.980 --> 50:07.300]  элементов было до него на самом деле.
[50:07.300 --> 50:11.340]  Ну, просто порисовать деревья и посчитать, и это все получится
[50:11.340 --> 50:12.340]  у вас.
[50:12.340 --> 50:13.340]  Я в вас верю.
[50:16.340 --> 50:17.340]  Окей.
[50:17.340 --> 50:19.900]  Ну, тогда понятно, что такое крайний лист, по сути.
[50:19.900 --> 50:23.220]  Вы просто добавляете, будто бы пушбэк в векторе делаете,
[50:23.220 --> 50:24.620]  то есть добавляете в конец элементов и все.
[50:24.620 --> 50:27.740]  Вот что скрывается этой загадочной фразой с крайним
[50:27.740 --> 50:28.740]  листом.
[50:28.740 --> 50:33.900]  То есть, вот это вот операция, вы делаете пушбэк в вектор,
[50:33.900 --> 50:36.100]  здесь вы делаете сифтап от последнего элемента.
[50:36.900 --> 50:40.300]  Сифтап вы с помощью индексов детей и родителей можете
[50:40.300 --> 50:41.300]  делать.
[50:41.300 --> 50:46.820]  Экстракт-мин, вы меняете нулевой элемент с последним,
[50:46.820 --> 50:50.580]  дальше делаете поп-бэк, дальше сифт-даун от нулевого
[50:50.580 --> 50:51.580]  элемента.
[50:51.580 --> 50:52.580]  Все.
[50:52.580 --> 50:54.300]  Поэтому теперь мы умеем делать все это очень быстро.
[50:54.300 --> 50:55.300]  Вот.
[50:55.300 --> 51:03.780]  Давайте мы сразу здесь вот такой вот маленький раздел
[51:03.780 --> 51:04.780]  напишем.
[51:05.780 --> 51:11.780]  Сортировка кучей или hip-сорт.
[51:16.780 --> 51:18.780]  Ну как это сортировать с помощью кучи?
[51:22.780 --> 51:27.780]  For i равное 0, i меньше n, plus, plus i.
[51:29.780 --> 51:31.780]  Делайте hip.insert.
[51:31.780 --> 51:36.780]  А i ты какой-нибудь, i это исходный массив, который
[51:36.780 --> 51:37.780]  надо отсортировать.
[51:37.780 --> 51:41.780]  Дальше делайте следующую штуку.
[51:41.780 --> 51:51.780]  For i равное 0, i меньше n, plus, plus i, не знаю, что-нибудь
[51:51.780 --> 51:54.780]  типа сиаута, сиаут.
[51:57.780 --> 51:59.780]  Hip.extract-min.
[52:01.780 --> 52:02.780]  Все.
[52:13.780 --> 52:14.780]  Можно.
[52:20.780 --> 52:23.780]  Можно, можно, да, это мы сейчас обсудим с вами.
[52:23.780 --> 52:26.780]  Ну кажется, у вас эта часть будет занимать на луген
[52:26.780 --> 52:27.780]  времени все равно.
[52:27.780 --> 52:29.780]  Здесь-то вы не умеете быстрее делать.
[52:29.780 --> 52:34.780]  Здесь у вас луген на операцию, n штук, n луген на операцию.
[52:34.780 --> 52:41.780]  Время от n луген.
[52:44.780 --> 52:47.780]  Соответственно, у вас здесь появляется такое понятие
[52:47.780 --> 52:48.780]  как доп-память.
[52:50.780 --> 52:54.780]  Потому что вам нужно создать хипу, отдельный массив.
[52:54.780 --> 52:57.780]  Ну наш шорт тоже требовал доп-память, чтобы вы слили
[52:57.780 --> 52:58.780]  в отдельный массив.
[52:59.780 --> 53:00.780]  Вот.
[53:06.780 --> 53:08.780]  Он есть, по-моему, он за лог квадрат работает,
[53:08.780 --> 53:09.780]  на n лог квадрат.
[53:09.780 --> 53:11.780]  In place-овский.
[53:12.780 --> 53:15.780]  Нет, я утверждаю, что есть сортировка, которая не
[53:15.780 --> 53:17.780]  требует доп-памяти, работает за n луген.
[53:17.780 --> 53:18.780]  Это правда.
[53:18.780 --> 53:21.780]  Мы ее проходить не будем, если что.
[53:21.780 --> 53:27.780]  Потому что это нечто очень страшное, скажем так.
[53:30.780 --> 53:33.780]  Я даже не вспомню, там на back какое-то у нее название.
[53:33.780 --> 53:35.780]  Black sort, что ли, по-моему.
[53:38.780 --> 53:39.780]  Вот.
[53:40.780 --> 53:41.780]  Окей.
[53:42.780 --> 53:44.780]  А теперь, да, здесь действительно нам говорят из зрительного
[53:44.780 --> 53:47.780]  зала, верно, что здесь можно делать это оптимальный
[53:47.780 --> 53:48.780]  hip insert.
[53:49.780 --> 53:51.780]  Процедура hipify будет называться.
[53:55.780 --> 53:57.780]  Давайте рассмотрим наш массив.
[53:59.780 --> 54:01.780]  И будем делать shift down от каждого элемента.
[54:02.780 --> 54:03.780]  Начиная с конца.
[54:09.780 --> 54:11.780]  То есть вот вы пытаетесь про shift down 4, 7, 5, дальше
[54:11.780 --> 54:14.780]  shift down 2, 3, дальше единичку shift down.
[54:16.780 --> 54:17.780]  Вот алгоритм.
[54:19.780 --> 54:20.780]  For.
[54:29.780 --> 54:30.780]  Окей.
[54:43.780 --> 54:44.780]  Ой.
[54:45.780 --> 54:46.780]  Sorry, да.
[54:46.780 --> 54:52.780]  Это уже n больше либо ровно нуля, минус, минус и.
[54:52.780 --> 54:54.780]  Такой это алгоритм будет, да.
[54:54.780 --> 54:57.780]  Вы с конца просеиваете, чтобы корень в конце у вас
[54:57.780 --> 54:58.780]  опустился.
[54:58.780 --> 54:59.780]  Вот.
[55:00.780 --> 55:02.780]  Упражнение вам надо подумать, почему этот алгоритм корректен.
[55:04.780 --> 55:07.780]  Ну у вас будет на семинаре задача, там будут вариации
[55:07.780 --> 55:10.780]  разные, типа от нуля до nt, shift up делать или shift down,
[55:10.780 --> 55:12.780]  и вот у вас будет парочка вариаций.
[55:12.780 --> 55:14.780]  Вы поймете, что они неверные.
[55:14.780 --> 55:16.780]  Там контрпримеры придумываются, а здесь все будет верным.
[55:17.780 --> 55:18.780]  Вот.
[55:20.780 --> 55:21.780]  Ну да, да.
[55:24.780 --> 55:25.780]  N минус 1.
[55:28.780 --> 55:30.780]  Давайте оценим время работы этой штуки.
[55:31.780 --> 55:33.780]  Хочется сказать n лог n, потому что shift down занимает
[55:33.780 --> 55:34.780]  лог n времени каждый.
[55:35.780 --> 55:39.780]  Ну давайте теперь применим немножко смекалочки.
[55:41.780 --> 55:43.780]  Вот у вас первое.
[55:43.780 --> 55:46.780]  Давайте я буду для справедливости полагать, что у меня тут
[55:46.780 --> 55:47.780]  полное дерево.
[55:49.780 --> 55:51.780]  Ну просто, чтобы было проще жить.
[55:52.780 --> 55:53.780]  Тогда первое.
[55:53.780 --> 55:54.780]  Тогда первое.
[55:55.780 --> 55:56.780]  Как здесь будет?
[55:56.780 --> 55:57.780]  Ну почти n пополам элементов.
[55:57.780 --> 55:58.780]  Ну без одного.
[56:00.780 --> 56:01.780]  Точнее, ну да.
[56:02.780 --> 56:04.780]  Сколько действий будет совершено с этими чуваками,
[56:04.780 --> 56:07.780]  когда мы shift down от них вызовем, от самых нижних?
[56:08.780 --> 56:09.780]  Ноль действий.
[56:10.780 --> 56:11.780]  Когда мы будем работать с этими?
[56:13.780 --> 56:15.780]  Одно действие, один обмен может быть максимум.
[56:16.780 --> 56:18.780]  То есть давайте оценим, что у нас
[56:18.780 --> 56:25.780]  на высоте h от корня
[56:28.780 --> 56:32.780]  два степени h элементов, да,
[56:34.780 --> 56:35.780]  и действие с ними.
[56:40.780 --> 56:41.780]  Сколько с ними действий?
[56:46.780 --> 56:47.780]  n минус h.
[56:49.780 --> 56:50.780]  Точнее, n минус h.
[56:51.780 --> 56:53.780]  Высота всей кучи, короче.
[56:56.780 --> 56:58.780]  Давайте оценим h большая, это высота кучи.
[57:00.780 --> 57:01.780]  h минус h.
[57:03.780 --> 57:07.780]  Это высота кучи.
[57:10.780 --> 57:11.780]  То есть у нас получается что такое?
[57:15.780 --> 57:16.780]  Мы получаем какую-то сумму,
[57:18.780 --> 57:20.780]  да, страшную.
[57:25.780 --> 57:27.780]  Сумма по h от
[57:28.780 --> 57:29.780]  чего до чего?
[57:29.780 --> 57:30.780]  От нуля
[57:31.780 --> 57:32.780]  до лог 2h на n.
[57:34.780 --> 57:35.780]  2 в степени h
[57:36.780 --> 57:37.780]  на h
[57:38.780 --> 57:39.780]  минус h маленькое.
[57:42.780 --> 57:43.780]  Вот.
[57:45.780 --> 57:46.780]  Надо оценить этот ряд.
[57:46.780 --> 57:48.780]  Сейчас, мне кажется, он не очень оценивается.
[57:48.780 --> 57:49.780]  Ну ладно.
[57:53.780 --> 57:54.780]  До лог 2n.
[57:55.780 --> 57:57.780]  2 в степени h маленькое на h большое.
[57:58.780 --> 58:02.780]  Минус сумма по h равной нулю до лог 2n.
[58:04.780 --> 58:06.780]  2 в степени h на h маленькое.
[58:09.780 --> 58:11.780]  Давайте вынесем здесь за скобку h
[58:11.780 --> 58:14.780]  и посчитаем это как сумма геометрической прогрессии.
[58:14.780 --> 58:15.780]  Что это будет?
[58:16.780 --> 58:17.780]  Что будет тогда?
[58:19.780 --> 58:21.780]  2 в степени лог 2h на n.
[58:23.780 --> 58:25.780]  Минус 1 делить на 2 минус 1.
[58:25.780 --> 58:27.780]  Что-то такое в формуле.
[58:27.780 --> 58:30.780]  Вроде так там геометрическая прогрессия будет хлопываться.
[58:31.780 --> 58:33.780]  Минус сумма
[58:35.780 --> 58:36.780]  до лог 2n
[58:37.780 --> 58:38.780]  h на 2 в степени h.
[58:38.780 --> 58:39.780]  Ну.
[58:39.780 --> 58:43.780]  Что это h в скобочках n-1.
[58:43.780 --> 58:44.780]  Что-то такое здесь.
[58:45.780 --> 58:46.780]  Минус вот эту вот сумму.
[58:52.780 --> 58:54.780]  Единственная проблема то, что мы не умеем считать такие ряды.
[58:59.780 --> 59:01.780]  Так нет, если вы говорите, что у вас будет n лог n,
[59:02.780 --> 59:03.780]  вам нужно точное значение.
[59:04.780 --> 59:06.780]  Так нет, если вы ограничите у вас debut n лог n,
[59:07.780 --> 59:08.780]  вам нужно точное значение суммы.
[59:09.780 --> 59:10.780]  В этом проблема.
[59:19.780 --> 59:21.780]  Вы не умеете интеграл награничивать сверху.
[59:23.780 --> 59:25.780]  То есть вы скажете, что это больше либо равно, чем что-то.
[59:25.780 --> 59:27.780]  Вам нужно, наоборот, оценка сверху.
[59:29.780 --> 59:30.780]  Кого? Эту штуку?
[59:30.780 --> 59:32.780]  У интегралов сверху ограничить эту штуку.
[59:32.780 --> 59:33.780]  У вас минус ограничение сверху.
[59:33.780 --> 59:34.780]  То есть вы ограничиваете снизу тогда.
[59:35.780 --> 59:36.780]  А мы хотим...
[59:42.780 --> 59:43.780]  Вы умеете дифференцировать ряды.
[59:44.780 --> 59:45.780]  Я не знаю, что вы это умеете делать.
[59:46.780 --> 59:47.780]  Ну это понятно.
[59:48.780 --> 59:50.780]  Ну можно продиференцировать и проинтегрировать, да.
[59:51.780 --> 59:52.780]  Хорошо.
[59:53.780 --> 59:54.780]  Давайте посчитаем, что...
[59:55.780 --> 59:56.780]  Что это такое будет?
[59:57.780 --> 59:59.780]  Не, ладно, мне лень брать производные.
[01:00:01.780 --> 01:00:03.780]  Сейчас, я подумал, как по-другому это просто оценить.
[01:00:04.780 --> 01:00:05.780]  Сейчас.
[01:00:09.780 --> 01:00:11.780]  Короче, я знаю способ, как оценить.
[01:00:11.780 --> 01:00:13.780]  Это без дифференцирования рядов.
[01:00:13.780 --> 01:00:14.780]  Сейчас я попробую вспомнить.
[01:00:17.780 --> 01:00:18.780]  Нет, конечно.
[01:00:19.780 --> 01:00:21.780]  Так у вас аж там меняется постоянно.
[01:00:23.780 --> 01:00:26.780]  Ну и чтобы ограничить, у вас будет сумма лог квадрат.
[01:00:26.780 --> 01:00:28.780]  Вам нужно выжить что-то порядка n лог n.
[01:00:28.780 --> 01:00:30.780]  Чтобы у вас осталось что-то порядка o от n.
[01:00:33.780 --> 01:00:35.780]  Ладно, сейчас давайте я подумаю быстренько.
[01:00:40.780 --> 01:00:41.780]  Где?
[01:00:42.780 --> 01:00:43.780]  Здесь?
[01:00:44.780 --> 01:00:46.780]  Аж, аж. Здесь ведь аж маленькие стоят.
[01:00:50.780 --> 01:00:51.780]  Так.
[01:00:51.780 --> 01:00:52.780]  Сейчас.
[01:00:54.780 --> 01:00:56.780]  Давайте пробуем по-другому, наверное, пойти.
[01:00:58.780 --> 01:01:01.780]  Ну, понятно, способ этот рабочий, но я не помню, как эту сумму считать.
[01:01:01.780 --> 01:01:04.780]  Точнее, могу посчитать, но, допустим, чтобы ее не умеем считать.
[01:01:05.780 --> 01:01:06.780]  Сейчас.
[01:01:10.780 --> 01:01:13.780]  Ну, давайте скажем так, что у нас есть куда интереснее вещи.
[01:01:14.780 --> 01:01:16.780]  А оставим без доказательств, что это o от n.
[01:01:16.780 --> 01:01:17.780]  Вот.
[01:01:17.780 --> 01:01:18.780]  Так будет проще всего поступить.
[01:01:19.780 --> 01:01:20.780]  Что эта сумма o от n.
[01:01:21.780 --> 01:01:22.780]  Вставляет
[01:01:24.780 --> 01:01:25.780]  теорема
[01:01:26.780 --> 01:01:27.780]  BD
[01:01:29.780 --> 01:01:30.780]  сумма выше
[01:01:32.780 --> 01:01:33.780]  составляет
[01:01:36.780 --> 01:01:38.780]  o от n по времени.
[01:01:39.780 --> 01:01:40.780]  Вот.
[01:01:48.780 --> 01:01:49.780]  Та-та-та-та-та-та.
[01:01:50.780 --> 01:01:52.780]  Сейчас мы лучше поговорим про другое с вами.
[01:01:55.780 --> 01:01:56.780]  Мы лучше с вами поговорим про
[01:01:58.780 --> 01:01:59.780]  оптимальный мерч,
[01:02:00.780 --> 01:02:01.780]  так сказать.
[01:02:02.780 --> 01:02:05.780]  Почему у нас там была аж, минус аж операция?
[01:02:06.780 --> 01:02:07.780]  Потому что у вас,
[01:02:07.780 --> 01:02:09.780]  если у вас элемент на высоте 3,
[01:02:10.780 --> 01:02:12.780]  ну, в высоте 1, да, а у вас высота кучи 2,
[01:02:12.780 --> 01:02:13.780]  то у вас всего 1 обмен будет.
[01:02:19.780 --> 01:02:22.780]  Ну, хорошо, а у меня высота кучи была аж маленькая.
[01:02:22.780 --> 01:02:23.780]  Нет, аж большая.
[01:02:24.780 --> 01:02:25.780]  Ну, аж большая.
[01:02:25.780 --> 01:02:26.780]  Да.
[01:02:26.780 --> 01:02:27.780]  Аж маленькая.
[01:02:27.780 --> 01:02:29.780]  Вы должны опускать элемент.
[01:02:30.780 --> 01:02:31.780]  Опустить вниз.
[01:02:31.780 --> 01:02:33.780]  Вы не можете опустить больше, чем наш большой,
[01:02:33.780 --> 01:02:34.780]  минус аж маленькая.
[01:02:36.780 --> 01:02:37.780]  Функция hipify?
[01:02:37.780 --> 01:02:39.780]  Hipify функция, да.
[01:02:39.780 --> 01:02:40.780]  Что делает функция hipify?
[01:02:40.780 --> 01:02:43.780]  Она берет произвольный массив и делает из него кучу.
[01:02:44.780 --> 01:02:46.780]  То есть, чтобы у вас были верны соотношения
[01:02:46.780 --> 01:02:48.780]  по индексам родителей ребенка.
[01:02:50.780 --> 01:02:51.780]  Вот. В чем ее суть.
[01:02:52.780 --> 01:02:53.780]  То есть, надо как бы вам на месте
[01:02:53.780 --> 01:02:55.780]  строить кучу из массива.
[01:02:57.780 --> 01:02:58.780]  Да.
[01:03:03.780 --> 01:03:04.780]  Да.
[01:03:04.780 --> 01:03:05.780]  Ну, вы извлекайте минимум.
[01:03:06.780 --> 01:03:09.780]  Этот шаг можно на hipify заменить будет потом.
[01:03:10.780 --> 01:03:12.780]  Ну, уже сейчас можно сделать, вот.
[01:03:13.780 --> 01:03:15.780]  Я хочу поговорить про нечто более концептуальное.
[01:03:16.780 --> 01:03:19.780]  А именно, поговорить про такую штуку, как merge.
[01:03:19.780 --> 01:03:20.780]  Все-таки вернуться к нему.
[01:03:24.780 --> 01:03:25.780]  Merge как много в этом слово.
[01:03:26.780 --> 01:03:29.780]  Мы с вами построили алгоритм за от n плюс m.
[01:03:30.780 --> 01:03:32.780]  Ну, если n и m это размеры массивов.
[01:03:32.780 --> 01:03:33.780]  Соответственно, да.
[01:03:35.780 --> 01:03:36.780]  Хорошо.
[01:03:36.780 --> 01:03:38.780]  Давайте я буду считать, что n много меньше, чем m.
[01:03:43.780 --> 01:03:45.780]  Пусть n много меньше, чем m.
[01:03:46.780 --> 01:03:47.780]  За это вас следует, что
[01:03:48.780 --> 01:03:49.780]  классический алгоритм
[01:03:49.780 --> 01:03:52.780]  за от m, понятное дело, тогда работает.
[01:03:53.780 --> 01:03:54.780]  Но возникает вопрос.
[01:03:54.780 --> 01:03:55.780]  А почему за от m?
[01:03:56.780 --> 01:03:58.780]  Если нам достаточно лишь понять,
[01:03:58.780 --> 01:04:00.780]  а в какие места нужно вставить элементы.
[01:04:01.780 --> 01:04:03.780]  Вот эти вот очень мало n штук.
[01:04:05.780 --> 01:04:07.780]  Можно же тогда за n плюс m сделать.
[01:04:08.780 --> 01:04:10.780]  Просто определить позицию, куда вставить.
[01:04:10.780 --> 01:04:11.780]  Согласны?
[01:04:14.780 --> 01:04:16.780]  Ну, я хочу сказать, что
[01:04:16.780 --> 01:04:17.780]  согласны.
[01:04:19.780 --> 01:04:21.780]  То есть вот ваш массив большой.
[01:04:24.780 --> 01:04:26.780]  И вот ваш маленький массивчик.
[01:04:26.780 --> 01:04:28.780]  Тогда вы понимаете, что этот надо сюда вставить.
[01:04:28.780 --> 01:04:29.780]  Этот сюда.
[01:04:29.780 --> 01:04:31.780]  И этот вот сюда.
[01:04:33.780 --> 01:04:34.780]  Вот.
[01:04:35.780 --> 01:04:37.780]  Алгоритм с Бинпольском.
[01:04:37.780 --> 01:04:39.780]  Сколько работает алгоритм с Бинпольском?
[01:04:39.780 --> 01:04:40.780]  Ну, здесь понятно.
[01:04:41.780 --> 01:04:43.780]  От n лог m.
[01:04:46.780 --> 01:04:47.780]  Так вопрос, что оптимальнее?
[01:04:50.780 --> 01:04:52.780]  Потому что если у вас n равно m,
[01:04:52.780 --> 01:04:54.780]  тогда эта штука превращается в n лог m,
[01:04:54.780 --> 01:04:55.780]  а здесь все от n.
[01:04:56.780 --> 01:04:57.780]  Вот как оптимально действовать?
[01:04:59.780 --> 01:05:01.780]  Ну, если у вас n равно m,
[01:05:02.780 --> 01:05:04.780]  тогда эта штука превращается в n лог m,
[01:05:04.780 --> 01:05:05.780]  а здесь все от n.
[01:05:05.780 --> 01:05:06.780]  Вот как оптимально действовать?
[01:05:10.780 --> 01:05:12.780]  Может, вы скажете что-нибудь типа такого?
[01:05:24.780 --> 01:05:26.780]  Ну, давайте считать, что...
[01:05:27.780 --> 01:05:28.780]  Окей.
[01:05:29.780 --> 01:05:31.780]  Считаем, что это односвязанные списки.
[01:05:31.780 --> 01:05:33.780]  Вы же умеете ходить вперед по ним?
[01:05:33.780 --> 01:05:35.780]  Все, вот так вот давайте сделаем.
[01:05:35.780 --> 01:05:37.780]  Тогда вы умеете вставлять за его единицу.
[01:05:37.780 --> 01:05:39.780]  То есть это нечто техническое,
[01:05:39.780 --> 01:05:41.780]  что не очень для мерджа нам важно здесь.
[01:05:42.780 --> 01:05:43.780]  Что?
[01:05:46.780 --> 01:05:48.780]  Ну, окей, хорошо.
[01:05:48.780 --> 01:05:49.780]  Сейчас.
[01:05:53.780 --> 01:05:55.780]  Мы представим, что мы живем в теории,
[01:05:55.780 --> 01:05:57.780]  мы просто хотим для каждого элемента определить,
[01:05:57.780 --> 01:05:58.780]  куда его вставить там потом.
[01:05:58.780 --> 01:06:01.780]  Понятное дело, что потом вы будете выписывать все это в один большой массив,
[01:06:01.780 --> 01:06:03.780]  и это все будет суммарно выписываться за линию от длины.
[01:06:04.780 --> 01:06:05.780]  Вот.
[01:06:05.780 --> 01:06:08.780]  Давайте покажем, что я просто хочу для каждого элемента определить позицию, куда он встанет.
[01:06:09.780 --> 01:06:10.780]  Вот такая вот задача.
[01:06:10.780 --> 01:06:12.780]  То есть не до конца надо делать слияние,
[01:06:12.780 --> 01:06:14.780]  а именно понять для каждого элемента, куда ему надо встать.
[01:06:16.780 --> 01:06:18.780]  То есть после кого элемента он будет идти?
[01:06:21.780 --> 01:06:22.780]  Что?
[01:06:23.780 --> 01:06:24.780]  Первое лучше.
[01:06:25.780 --> 01:06:28.780]  Ну, я говорю, опять же, если у вас n много меньше, чем m,
[01:06:28.780 --> 01:06:30.780]  то у вас классический алгоритм за такую штуку.
[01:06:31.780 --> 01:06:33.780]  А этот за такую будет работать.
[01:06:36.780 --> 01:06:39.780]  То есть вопрос, существует ли нечто универсальное, работающее во всех случаях?
[01:06:41.780 --> 01:06:43.780]  Ну, вот у нас есть log m.
[01:06:44.780 --> 01:06:48.780]  Ну, тогда если у вас n равно m, то это n log n, а это o от n.
[01:06:50.780 --> 01:06:52.780]  Ну, то есть o от minimum, да, по-вашему?
[01:06:54.780 --> 01:06:55.780]  Хорошо.
[01:06:55.780 --> 01:06:57.780]  А если я вам скажу вот такую вот классную штуку?
[01:07:01.780 --> 01:07:03.780]  Ой, ну у нас n много меньше, чем m.
[01:07:03.780 --> 01:07:04.780]  Давайте наоборот.
[01:07:07.780 --> 01:07:12.780]  Здесь n, здесь m, и здесь n.
[01:07:14.780 --> 01:07:20.780]  Давайте посмотрим экстремальный случай, когда n очень маленькая.
[01:07:22.780 --> 01:07:25.780]  То есть если у нас n много меньше, чем m,
[01:07:25.780 --> 01:07:26.780]  то что тогда это будет?
[01:07:28.780 --> 01:07:29.780]  Ну, почему это будет?
[01:07:29.780 --> 01:07:31.780]  Нет, у нас n хотя бы единица.
[01:07:31.780 --> 01:07:33.780]  То есть log m, по сути, здесь будет, да?
[01:07:33.780 --> 01:07:36.780]  То есть это будет n log m около того.
[01:07:36.780 --> 01:07:38.780]  То есть вот он первый случай.
[01:07:38.780 --> 01:07:40.780]  Второй случай m сравнимо с n.
[01:07:41.780 --> 01:07:43.780]  Ну, тогда он получим o от n.
[01:07:44.780 --> 01:07:45.780]  Ну, все, победа.
[01:07:46.780 --> 01:07:48.780]  То есть мы получили алгоритм, который в двух крайних случаях,
[01:07:48.780 --> 01:07:51.780]  когда мы получим o от n, мы получим o от m.
[01:07:51.780 --> 01:07:52.780]  Ну, все, победа.
[01:07:53.780 --> 01:07:55.780]  То есть мы получили алгоритм, который в двух крайних случаях,
[01:07:55.780 --> 01:08:00.780]  когда равенство и когда огромное неравенство вырождается в обе эти асимптотики.
[01:08:00.780 --> 01:08:01.780]  Ну, как получили?
[01:08:01.780 --> 01:08:03.780]  Я вам формулу лишь написал.
[01:08:04.780 --> 01:08:08.780]  Давайте докажем, что быстрее нельзя.
[01:08:14.780 --> 01:08:17.780]  Я вам обещал лекцию по дискретной математике сегодня.
[01:08:17.780 --> 01:08:19.780]  Вот она и наступила.
[01:08:21.780 --> 01:08:33.780]  Как мы с вами доказывали до сортировок, что быстрее нельзя?
[01:08:37.780 --> 01:08:39.780]  Давайте здесь построим решающее дерево.
[01:08:41.780 --> 01:08:43.780]  Давайте построим решающее дерево.
[01:08:43.780 --> 01:08:45.780]  Вообще теорема звучит так.
[01:08:46.780 --> 01:08:55.780]  Пусть n меньше либо равно, чем 2m.
[01:08:56.780 --> 01:08:58.780]  Наоборот, только все поставим.
[01:09:00.780 --> 01:09:02.780]  m больше, чем 2m.
[01:09:02.780 --> 01:09:08.780]  Тогда оптимальное время мержа.
[01:09:08.780 --> 01:09:10.780]  Время мержа.
[01:09:14.780 --> 01:09:16.780]  Какое оно будет у нас?
[01:09:17.780 --> 01:09:20.780]  Это будет ω от...
[01:09:21.780 --> 01:09:23.780]  И сейчас я скажу, от чего именно будет.
[01:09:24.780 --> 01:09:27.780]  n log m делить на n.
[01:09:27.780 --> 01:09:29.780]  Вроде бы так.
[01:09:32.780 --> 01:09:34.780]  Но это доказывать.
[01:09:35.780 --> 01:09:38.780]  Это размеры двух массивов.
[01:09:39.780 --> 01:09:42.780]  У нас же массив можно неравную размеров сливать.
[01:09:42.780 --> 01:09:44.780]  В общем случае-то.
[01:09:45.780 --> 01:09:47.780]  Делается следующее.
[01:09:47.780 --> 01:09:49.780]  Построим решающее дерево.
[01:09:49.780 --> 01:10:09.780]  Делаем решающее дерево с вопросом аиты меньше, чем божиты.
[01:10:11.780 --> 01:10:15.780]  Это те вопросы, которые мы задавали с вами, когда здесь был код мержа написан.
[01:10:15.780 --> 01:10:22.780]  Мы с вами делали while и спрашивали, если аиты меньше божитого, то пиши аиты, иначе пиши божиты.
[01:10:25.780 --> 01:10:27.780]  Давайте подумаем, сколько у нас всего вариантов есть.
[01:10:28.780 --> 01:10:30.780]  Сколько должно быть листьев?
[01:10:34.780 --> 01:10:39.780]  То есть у вас будут два любых массива, сколько у вас возможных вариантов их смёржить?
[01:10:39.780 --> 01:10:42.780]  Что-то сложно. Можно как-то комбинаторное обоснование?
[01:10:44.780 --> 01:10:46.780]  Но обоснование здесь следующее.
[01:10:47.780 --> 01:10:50.780]  У вас всего m плюс m позиций в итоговом массиве будет.
[01:10:51.780 --> 01:10:54.780]  Вам нужно зафиксировать позиции для m элементов из них.
[01:10:55.780 --> 01:10:59.780]  Тогда остальные m очевидно сразу восстанавливаются, потому что у вас массивы ассортированные.
[01:11:00.780 --> 01:11:02.780]  Всего листьев должно быть.
[01:11:02.780 --> 01:11:04.780]  С из n плюс m по n.
[01:11:05.780 --> 01:11:07.780]  С из n плюс m по n, да.
[01:11:11.780 --> 01:11:12.780]  Окей.
[01:11:14.780 --> 01:11:16.780]  Что тогда можно дальше заявлять?
[01:11:18.780 --> 01:11:24.780]  У вас результатирующим массивом ассортированного объекта, который у вас есть,
[01:11:24.780 --> 01:11:25.780]  окей.
[01:11:26.780 --> 01:11:28.780]  Ну что тогда можно дальше заявлять?
[01:11:30.780 --> 01:11:33.780]  Ну смотрите, у вас в результатирующем массиве сколько места?
[01:11:35.780 --> 01:11:41.780]  Если вы расставите n элементов из одного массива, правда ли, что вы однозначно зададите места для второго массива?
[01:11:42.780 --> 01:11:43.780]  Всё.
[01:11:43.780 --> 01:11:48.780]  Ну теперь вспоминаем, мы говорили с вами, что глубина дерева, порядка логарифма, да?
[01:11:50.780 --> 01:11:52.780]  Ну, осталось оценить вот эту вот штучку.
[01:11:56.780 --> 01:12:00.780]  Поверите, что это вот такая вот омега, tn лог m делить, наверное, или доказать?
[01:12:02.780 --> 01:12:05.780]  Ну, вспоминаем тогда, что такое формула цешечки.
[01:12:06.780 --> 01:12:09.780]  Ну, вспоминаем тогда, что такое формула цешечки.
[01:12:11.780 --> 01:12:13.780]  Логарифм по основанию 2, от чего здесь будет?
[01:12:14.780 --> 01:12:15.780]  Сейчас.
[01:12:16.780 --> 01:12:22.780]  Чего-нибудь n плюс m факториал, 9 на k факториал, m факториал, m факториал.
[01:12:25.780 --> 01:12:27.780]  Лог 2 от c из цешки.
[01:12:28.780 --> 01:12:29.780]  Из вот этой вот.
[01:12:30.780 --> 01:12:31.780]  Окей.
[01:12:32.780 --> 01:12:34.780]  Ну что тогда можно дальше сказать?
[01:12:35.780 --> 01:12:37.780]  А формула стирлинга,
[01:12:39.780 --> 01:12:41.780]  которая нам здесь понадобится,
[01:12:45.780 --> 01:12:47.780]  она стоит в следующем, что
[01:12:49.780 --> 01:12:50.780]  сейчас,
[01:12:51.780 --> 01:12:54.780]  n факториал очень близок вот такой вот штуке.
[01:13:02.780 --> 01:13:03.780]  Да.
[01:13:05.780 --> 01:13:06.780]  В плане?
[01:13:09.780 --> 01:13:10.780]  В плане.
[01:13:11.780 --> 01:13:13.780]  Нет-нет, у вас же два массива отсортированных.
[01:13:13.780 --> 01:13:16.780]  Если зафиксировали места, вы, очевидно, восстанавливаете оба массива.
[01:13:20.780 --> 01:13:22.780]  Это не стремиться, это эквивалентин.
[01:13:23.780 --> 01:13:25.780]  Корень из 2 пен,
[01:13:26.780 --> 01:13:29.780]  умножить на n делить на e, и все это встепенируем.
[01:13:30.780 --> 01:13:32.780]  Это формула стирлинга. Не спрашивайте, какой он выводил.
[01:13:32.780 --> 01:13:34.780]  Вот, возможно, он на мотонею выведут.
[01:13:37.780 --> 01:13:41.780]  Ну давайте выпишем вот этот вот, вот этот вот кошмар сюда.
[01:13:46.780 --> 01:13:47.780]  E.
[01:13:47.780 --> 01:13:48.780]  Число Эйлера.
[01:13:49.780 --> 01:13:51.780]  Которая 2, 7, 1, 8, 2, 8, бла-бла-бла.
[01:13:56.780 --> 01:14:00.780]  Проблема в том, что там на логарифм n факториал точная оценка.
[01:14:00.780 --> 01:14:04.780]  На n факториал нам нужна будет более точная оценка, чем у стайлема получить.
[01:14:05.780 --> 01:14:07.780]  Скажем так, там нам тетлы то и не хватит.
[01:14:08.780 --> 01:14:10.780]  Нам здесь нужно что-то более точное.
[01:14:11.780 --> 01:14:12.780]  Ну давайте выписывать.
[01:14:13.780 --> 01:14:15.780]  Логарифм по основанию 2 от
[01:14:16.780 --> 01:14:19.780]  Оринис 2 пи n плюс m,
[01:14:21.780 --> 01:14:25.780]  умножить на n плюс m делить на e,
[01:14:26.780 --> 01:14:28.780]  в степени n плюс m.
[01:14:30.780 --> 01:14:34.780]  Делить на корень из 2 пи n
[01:14:35.780 --> 01:14:37.780]  на n делить на e в степени n.
[01:14:38.780 --> 01:14:41.780]  На корень из 2 пи m
[01:14:42.780 --> 01:14:44.780]  на m делить на e в степени m.
[01:14:45.780 --> 01:14:46.780]  Красота же, да?
[01:14:47.780 --> 01:14:50.780]  Давайте сгруппируем слагаемые.
[01:14:56.780 --> 01:14:58.780]  Ну множители здесь точнее будут.
[01:14:59.780 --> 01:15:00.780]  Что это такое?
[01:15:01.780 --> 01:15:02.780]  Это
[01:15:03.780 --> 01:15:04.780]  корень из
[01:15:05.780 --> 01:15:09.780]  n плюс m делить на 2 пи nm.
[01:15:10.780 --> 01:15:12.780]  Это я корни объединил отдельно все.
[01:15:13.780 --> 01:15:14.780]  Плюс
[01:15:15.780 --> 01:15:17.780]  логарифм по основанию 2 от
[01:15:19.780 --> 01:15:20.780]  n плюс m
[01:15:21.780 --> 01:15:24.780]  в степени n плюс m умножить на 1 делить на e
[01:15:25.780 --> 01:15:26.780]  в степени n плюс m
[01:15:26.780 --> 01:15:29.780]  делить на n в степени n
[01:15:30.780 --> 01:15:31.780]  на m в степени m
[01:15:32.780 --> 01:15:33.780]  на e в степени
[01:15:34.780 --> 01:15:35.780]  деленное на e в степени n плюс m.
[01:15:38.780 --> 01:15:39.780]  Ну я просто взял
[01:15:40.780 --> 01:15:42.780]  скобки будто бы раскрыл, типа a делить на b в степени c,
[01:15:43.780 --> 01:15:45.780]  а в степени c делить на b в степени c.
[01:15:50.780 --> 01:15:51.780]  У меня здесь 2 пи есть.
[01:15:51.780 --> 01:15:52.780]  Ну
[01:15:53.780 --> 01:15:55.780]  понятное дело, что эта штука стремится к нулю
[01:15:56.780 --> 01:15:57.780]  с ростом n и m.
[01:15:57.780 --> 01:15:59.780]  Это мне очень интересно вообще, что это такое.
[01:16:00.780 --> 01:16:01.780]  Вот.
[01:16:02.780 --> 01:16:04.780]  Ну давайте скажем, что она там чем-то ограничена.
[01:16:04.780 --> 01:16:05.780]  Мы знаем, что у нас
[01:16:06.780 --> 01:16:07.780]  2m меньше либо равно, чем m.
[01:16:08.780 --> 01:16:09.780]  Тогда
[01:16:09.780 --> 01:16:11.780]  знаменатель меньше либо равен, чем
[01:16:12.780 --> 01:16:13.780]  больше либо равен, чем 3n
[01:16:14.780 --> 01:16:15.780]  числитель, а здесь знаменатель там
[01:16:15.780 --> 01:16:17.780]  что-нибудь типа 4m квадрат будет.
[01:16:18.780 --> 01:16:19.780]  Здесь.
[01:16:19.780 --> 01:16:20.780]  Ну короче, все сократится, все прекрасно.
[01:16:21.780 --> 01:16:23.780]  Поехали дальше расписывать эту фигню.
[01:16:26.780 --> 01:16:28.780]  Давайте я обозначу это выражение за p
[01:16:29.780 --> 01:16:30.780]  от nm.
[01:16:31.780 --> 01:16:32.780]  Потом мы с ним разберемся.
[01:16:35.780 --> 01:16:36.780]  Плюс
[01:16:37.780 --> 01:16:39.780]  логариф по основанию 2 от
[01:16:40.780 --> 01:16:41.780]  e сокращаются.
[01:16:43.780 --> 01:16:45.780]  И здесь я возьму и распишу вот так вот.
[01:16:46.780 --> 01:16:47.780]  Вот.
[01:16:47.780 --> 01:16:48.780]  n плюс m
[01:16:49.780 --> 01:16:50.780]  в степени n
[01:16:51.780 --> 01:16:52.780]  умножить на n плюс m
[01:16:53.780 --> 01:16:54.780]  в степени m
[01:16:55.780 --> 01:16:56.780]  делить на n в степени n
[01:16:57.780 --> 01:16:58.780]  на m в степени m.
[01:17:03.780 --> 01:17:04.780]  Тогда что это такое?
[01:17:05.780 --> 01:17:06.780]  Давайте перейдем на эту доску.
[01:17:17.780 --> 01:17:18.780]  Окей.
[01:17:20.780 --> 01:17:21.780]  Равно
[01:17:26.780 --> 01:17:27.780]  p от nm
[01:17:29.780 --> 01:17:30.780]  плюс
[01:17:31.780 --> 01:17:33.780]  логариф по основанию 2 от
[01:17:35.780 --> 01:17:38.780]  n плюс m деленное на n в степени n
[01:17:39.780 --> 01:17:41.780]  плюс логариф по основанию 2 от
[01:17:42.780 --> 01:17:45.780]  n плюс m деленное на n в степени n
[01:17:46.780 --> 01:17:48.780]  плюс логариф по основанию 2 от
[01:17:49.780 --> 01:17:51.780]  n плюс m деленное на m в степени m.
[01:17:56.780 --> 01:17:57.780]  Уже красиво выражается.
[01:17:59.780 --> 01:18:00.780]  Равно p от nm
[01:18:02.780 --> 01:18:03.780]  плюс
[01:18:04.780 --> 01:18:06.780]  n логариф по основанию 2 от
[01:18:07.780 --> 01:18:08.780]  1 плюс m делить на n
[01:18:09.780 --> 01:18:10.780]  плюс логариф
[01:18:11.780 --> 01:18:12.780]  плюс... не так.
[01:18:13.780 --> 01:18:14.780]  Сейчас степень вынесем.
[01:18:15.780 --> 01:18:17.780]  Логариф по основанию 2 от
[01:18:19.780 --> 01:18:20.780]  1 плюс
[01:18:21.780 --> 01:18:22.780]  n деленное на m.
[01:18:27.780 --> 01:18:28.780]  Давайте распишем.
[01:18:29.780 --> 01:18:30.780]  Что это такое все будет?
[01:18:31.780 --> 01:18:32.780]  p от nm.
[01:18:35.780 --> 01:18:36.780]  Это у нас
[01:18:37.780 --> 01:18:38.780]  одна-вторая
[01:18:39.780 --> 01:18:40.780]  логарифа по основанию 2 от
[01:18:40.780 --> 01:18:41.780]  давайте напишем в скобках
[01:18:42.780 --> 01:18:44.780]  1 делить на 2p умножить на
[01:18:46.780 --> 01:18:47.780]  1 деленное на n плюс
[01:18:48.780 --> 01:18:49.780]  1 деленное на m.
[01:18:51.780 --> 01:18:52.780]  Очевидно, что это к нулю стремится.
[01:18:55.780 --> 01:18:58.780]  Что n увеличивать, что n увеличивать, оно стремится к нулю.
[01:19:02.780 --> 01:19:04.780]  Поэтому p от nm нам здесь вообще никак не влияет
[01:19:05.780 --> 01:19:06.780]  на асимптотику.
[01:19:06.780 --> 01:19:07.780]  Дальше смотрим.
[01:19:09.780 --> 01:19:11.780]  2n меньше либо равно, чем m.
[01:19:13.780 --> 01:19:14.780]  Но откуда вас следует, что
[01:19:16.780 --> 01:19:17.780]  n делить на m
[01:19:19.780 --> 01:19:20.780]  меньше либо равно, чем 1-вторая?
[01:19:24.780 --> 01:19:25.780]  Логично?
[01:19:26.780 --> 01:19:27.780]  Логично.
[01:19:30.780 --> 01:19:31.780]  То есть это какая-то константа,
[01:19:32.780 --> 01:19:33.780]  которая может быть
[01:19:33.780 --> 01:19:34.780]  ограничена константой.
[01:19:35.780 --> 01:19:37.780]  Поэтому запишем это вот так вот на самом деле.
[01:19:38.780 --> 01:19:40.780]  Ну не равно, а теперь эквивалентно запишем.
[01:19:44.780 --> 01:19:45.780]  Эквивалентно чему?
[01:19:47.780 --> 01:19:48.780]  n лог
[01:19:49.780 --> 01:19:51.780]  двоичное от 1 плюс m деленное на n
[01:19:55.780 --> 01:19:57.780]  плюс m на логариф по основанию 2 от
[01:19:58.780 --> 01:19:59.780]  1 деленное на m
[01:19:59.780 --> 01:20:00.780]  плюс m
[01:20:02.780 --> 01:20:03.780]  на логариф по основанию 2 от
[01:20:05.780 --> 01:20:06.780]  1 плюс 1-вторая.
[01:20:16.780 --> 01:20:17.780]  Ну вот сейчас все, почти.
[01:20:18.780 --> 01:20:19.780]  На самом-то деле.
[01:20:20.780 --> 01:20:22.780]  Ну то есть вот мы получили сам вот эту вот штуку.
[01:20:24.780 --> 01:20:25.780]  Это вот это вот.
[01:20:25.780 --> 01:20:26.780]  Вот.
[01:20:28.780 --> 01:20:29.780]  А вот эта вот штука, она нужна,
[01:20:31.780 --> 01:20:33.780]  чтобы этот длинный массив m все-таки, видимо, как-то прочитать.
[01:20:34.780 --> 01:20:35.780]  Потому что он все-таки будет у вас.
[01:20:36.780 --> 01:20:37.780]  Вот.
[01:20:38.780 --> 01:20:39.780]  Ну окей.
[01:20:40.780 --> 01:20:41.780]  Может мне от нее избавиться?
[01:20:42.780 --> 01:20:43.780]  Что?
[01:20:44.780 --> 01:20:45.780]  Ну вот нет.
[01:20:46.780 --> 01:20:47.780]  Что это равно?
[01:20:49.780 --> 01:20:50.780]  Мы заявили, что оно к нулю стремится.
[01:20:51.780 --> 01:20:53.780]  Поэтому оно вообще не влияет на асимптотику.
[01:20:55.780 --> 01:20:56.780]  Но мы вывели.
[01:20:57.780 --> 01:20:58.780]  Нам дано, что 2n меньше леворочим m.
[01:20:59.780 --> 01:21:00.780]  Из этого следует это соотношение.
[01:21:01.780 --> 01:21:03.780]  Мы его подставляем вот сюда вот.
[01:21:05.780 --> 01:21:08.780]  Это от n логарифма.
[01:21:09.780 --> 01:21:10.780]  От m деленное на n.
[01:21:13.780 --> 01:21:17.780]  Ну понятно, что вы сюда 1 прибавите вообще особо не влияет.
[01:21:18.780 --> 01:21:19.780]  Вот.
[01:21:20.780 --> 01:21:22.780]  Давайте скажем так, что это эквивалентно
[01:21:22.780 --> 01:21:25.780]  к m стремящимся к бесконечности.
[01:21:26.780 --> 01:21:27.780]  То есть мы считаем, что у нас один басив.
[01:21:28.780 --> 01:21:29.780]  Нет, это плохо.
[01:21:30.780 --> 01:21:31.780]  Ладно, не будем никого стремить к бесконечности.
[01:21:32.780 --> 01:21:33.780]  Просто так оставим.
[01:21:34.780 --> 01:21:35.780]  Вот эта вот штука.
[01:21:36.780 --> 01:21:37.780]  Ну плюс m.
[01:21:38.780 --> 01:21:39.780]  Вот.
[01:21:40.780 --> 01:21:42.780]  Ну m, да, там действительно будет по времени.
[01:21:43.780 --> 01:21:44.780]  Поэтому как-то вот так вот.
[01:21:48.780 --> 01:21:49.780]  Да.
[01:21:50.780 --> 01:21:52.780]  Кто к нулю стремится?
[01:21:53.780 --> 01:21:54.780]  m делить на n вот это вот?
[01:21:55.780 --> 01:21:56.780]  Нет, нет, на выше.
[01:21:58.780 --> 01:21:59.780]  Это?
[01:22:04.780 --> 01:22:05.780]  Ну.
[01:22:06.780 --> 01:22:07.780]  Окей, хорошо.
[01:22:08.780 --> 01:22:09.780]  Но здесь немножко не так сказано, что к нулю стремится.
[01:22:10.780 --> 01:22:13.780]  Если лучше сказать так, что это просто какая-то константа,
[01:22:14.780 --> 01:22:16.780]  которая очень мала по сравнению с линейным ростом этих штук.
[01:22:16.780 --> 01:22:21.780]  Поэтому мне можно благополучно опустить ее в наших числениях.
[01:22:22.780 --> 01:22:23.780]  Так будет корректнее сказать, вы правы.
[01:22:24.780 --> 01:22:26.780]  Что она не стремится к нулю, конечно же.
[01:22:27.780 --> 01:22:29.780]  А что она просто крайне мала.
[01:22:32.780 --> 01:22:36.780]  2p от этой штуки.
[01:22:38.780 --> 01:22:43.780]  Да, что она просто крайне мала.
[01:22:44.780 --> 01:22:45.780]  Мала.
[01:22:46.780 --> 01:22:48.780]  Ну то есть у нее порядок роста никакой, она вообще не растет.
[01:22:49.780 --> 01:22:50.780]  Она убывает.
[01:22:51.780 --> 01:22:52.780]  А у этих штук линейный порядок роста.
[01:22:53.780 --> 01:22:54.780]  Ну чуть более, чем линейный.
[01:22:55.780 --> 01:22:56.780]  Поэтому константу можно опустить.
[01:22:57.780 --> 01:22:59.780]  Ну ее можно типа сверху ограничить чем-то и сказать, что она не важна.
[01:23:00.780 --> 01:23:01.780]  Вот так вот.
[01:23:03.780 --> 01:23:05.780]  Ну все, вот такое вот доказательство, что нельзя.
[01:23:05.780 --> 01:23:06.780]  Да, да.
[01:23:12.780 --> 01:23:13.780]  Почему это лучше, чем M plus M?
[01:23:16.780 --> 01:23:18.780]  Не, подождите, вот M plus M.
[01:23:19.780 --> 01:23:20.780]  Вот здесь вот 3 вот этих маленьких.
[01:23:21.780 --> 01:23:23.780]  У вас там вот эта вот M берется за то, чтобы надо краски от массива прочитать.
[01:23:24.780 --> 01:23:27.780]  Она всегда будет. Если массива не надо было читать, то она бы там ее не было, грубо говоря.
[01:23:28.780 --> 01:23:29.780]  Вот.
[01:23:31.780 --> 01:23:33.780]  А, ну все, вот и время подошло к концу.
[01:23:33.780 --> 01:23:34.780]  И теорию мы сами доказали.
