[00:00.000 --> 00:18.000]  В чем суть? Мы хотим построить какую-то структуру данных, которая будет уметь отвечать на три запроса.
[00:19.000 --> 00:23.000]  Это find, то есть проверить есть ли элемент.
[00:23.000 --> 00:30.000]  Insert, ставить элемент и erase, удалить.
[00:30.000 --> 00:35.000]  Мы с вами уже делали похоже, это были всякие деревья поиска.
[00:35.000 --> 00:37.000]  И там получили разные варианты.
[00:37.000 --> 00:44.000]  Средним логорифом, амортизированный логорифом, обычный логорифом, логориф по основанию T.
[00:44.000 --> 01:01.000]  А здесь мы будем целиться в еще более лучшую вещь, а именно хотим за от единицы в среднем.
[01:09.000 --> 01:12.000]  В среднем, то есть в ожидании будет от единицы.
[01:12.000 --> 01:17.000]  Возможно мы сегодня с вами познакомимся с штуком от ожидания, с этим словом страшно.
[01:17.000 --> 01:21.000]  Вот, это наша цель великая.
[01:21.000 --> 01:29.000]  И первая идея, которая предлагается вообще, раз у нас салат единицы, значит мы должны как-то сравнивать объекты с салат единицы.
[01:29.000 --> 01:33.000]  Какие объекты мы умеем сравнивать с салат единицы? На равенство.
[01:33.000 --> 01:35.000]  Все, только числа.
[01:35.000 --> 01:53.000]  Поэтому мы будем считать, что определение, следующая пусть, у, это множество всех объектов.
[01:53.000 --> 01:58.000]  Ну там не знаю, например, это строки на алфавите ABC длины до 50.
[01:58.000 --> 02:03.000]  Ну допустим, какое-то такое странное множество.
[02:03.000 --> 02:22.000]  Вот, тогда функция h, которая будет переводить множество u в n-1, это hash функция.
[02:22.000 --> 02:33.000]  Вот, мы не знаем как она действует, мы знаем лишь, что она берет, может брать любой объект из рассматриваемых и вытащить чиселку.
[02:33.000 --> 02:56.000]  Дальше, следующее определение, что пара x и y, где x не равен y, создает коллизию,
[02:56.000 --> 03:10.000]  а если h от x равна h от y?
[03:10.000 --> 03:16.000]  То есть, если мы нашли пару неравных ключей, у которых hash функция одинаковая, то мы считаем, что это коллизия.
[03:16.000 --> 03:22.000]  Как вы можете догадаться, коллизия это плохо.
[03:22.000 --> 03:30.000]  Почему это плохо? Потому что если у вас hash от x не равно hash от y, вы сразу же делаете вывод, что x не равно y.
[03:30.000 --> 03:35.000]  В обратную сторону это неверно.
[03:35.000 --> 03:39.000]  Собственно, за счет вот этой вот такой идеи мы будем быстро сравнивать все.
[03:39.000 --> 03:41.000]  Окей, дальше что мы будем делать?
[03:41.000 --> 03:46.000]  Вопрос, почему hash переводит значение от 0 до n-1?
[03:46.000 --> 03:49.000]  Потому что мы умеем только числа быстро сравнивать.
[03:49.000 --> 03:51.000]  Почему не?
[03:51.000 --> 03:54.000]  Потому что n-чиселок всего должно быть.
[03:54.000 --> 03:59.000]  Ну, программисты с 0 начинают.
[03:59.000 --> 04:04.000]  Хорошо, коллизию определили. Что дальше мы хотим?
[04:04.000 --> 04:07.000]  Наверное, создать какую-то hash таблицу надо.
[04:07.000 --> 04:14.000]  Ну вот, какие будут идеи?
[04:14.000 --> 04:16.000]  Как переводит hash?
[04:16.000 --> 04:18.000]  Как hash?
[04:18.000 --> 04:22.000]  Массив из n-элементов.
[04:22.000 --> 04:28.000]  Да, давайте бахнем массив из n-элементов. Почему нет?
[04:28.000 --> 04:36.000]  Сделаем массив из n-элементов.
[04:36.000 --> 04:43.000]  Ой, зачем он то? В гулей давайте.
[04:43.000 --> 04:47.000]  Наш hash таблица.
[04:47.000 --> 04:49.000]  И она будет иметь размер n.
[04:49.000 --> 04:51.000]  И у всех false означает.
[04:51.000 --> 04:54.000]  Ну тогда понятно, что при insert можно будто бы просто сказать,
[04:54.000 --> 05:00.000]  посчитай-ка мне hash функцию от объекта и что-то сделай дальше.
[05:00.000 --> 05:05.000]  Ну вот, пойди по нужному индексу, поставь true, что элемент есть.
[05:05.000 --> 05:07.000]  Чем такая схема плоха?
[05:08.000 --> 05:11.000]  У коллизии, во-первых, мы не умеем с ними справляться.
[05:11.000 --> 05:13.000]  Это раз. Два.
[05:13.000 --> 05:17.000]  Но все-таки много памяти, так или иначе.
[05:17.000 --> 05:20.000]  Все-таки от n-элементов неприятно.
[05:20.000 --> 05:24.000]  Будем хотеть чуть меньше, обычно.
[05:24.000 --> 05:30.000]  В частности, мы, наверное, хотим памяти от числа добавленных объектов,
[05:30.000 --> 05:35.000]  а не от какого-то абстрактного m.
[05:35.000 --> 05:37.000]  Мы бахнули вектором, какая разница?
[05:37.000 --> 05:40.000]  У вас уже n-памяти выделено, это плохо.
[05:40.000 --> 05:43.000]  Вы хотите, чтобы у вас, наверное, если hash таблица содержит один элемент,
[05:43.000 --> 05:47.000]  она там не очень большего размера была.
[05:51.000 --> 05:55.000]  Такая схема называется прямая десенсия.
[05:55.000 --> 05:59.000]  Директ адресинг по-английски.
[05:59.000 --> 06:03.000]  Проблемы мы уже с вами выяснили.
[06:07.000 --> 06:10.000]  Первый – это коллизия.
[06:10.000 --> 06:14.000]  Второй – это o от n-памяти.
[06:16.000 --> 06:18.000]  Всегда.
[06:18.000 --> 06:22.000]  Давайте такую модель посмотрим.
[06:30.000 --> 06:32.000]  Здесь у нас все плохо.
[06:32.000 --> 06:34.000]  Давайте посмотрим вторую модель.
[06:34.000 --> 06:36.000]  Это вот такая.
[06:36.000 --> 06:40.000]  Simple Uniform Cache.
[06:40.000 --> 06:44.000]  Или просто равномерное хаширование по-русски.
[06:44.000 --> 06:48.000]  Simple – это простой, Uniform – равномерный.
[06:48.000 --> 06:52.000]  В чем будет суть?
[06:52.000 --> 06:54.000]  Смотрите.
[06:54.000 --> 06:56.000]  Мы хотим сделать что?
[06:56.000 --> 06:58.000]  Нам нужно как-то разобраться с коллизиями.
[06:58.000 --> 07:00.000]  Мы хотим сделать что?
[07:00.000 --> 07:02.000]  Нам нужно как-то разобраться с коллизиями.
[07:02.000 --> 07:04.000]  Мы хотим сделать что?
[07:04.000 --> 07:06.000]  Мы хотим сделать что?
[07:06.000 --> 07:08.000]  Мы хотим сделать что?
[07:08.000 --> 07:10.000]  Нам нужно как-то разобраться с коллизиями.
[07:10.000 --> 07:12.000]  Давайте сделаем следующее.
[07:12.000 --> 07:18.000]  Будто бы у нас есть массивчик размера m.
[07:18.000 --> 07:24.000]  Будто бы у нас есть массивчик размера m.
[07:24.000 --> 07:34.000]  И мы будем брать, что наша h' от x – это h от x по модулю m.
[07:34.000 --> 07:38.000]  Здесь мы себе позовем хрень не m элементов, а какое-то m.
[07:38.000 --> 07:42.000]  Оно будет сильно меньше, чем m.
[07:42.000 --> 07:46.000]  И там при необходимости мы можем как-то менять.
[07:46.000 --> 07:48.000]  Если добавилось слишком много элементов, то увеличить.
[07:48.000 --> 07:52.000]  Если убрали слишком много элементов, то как-то уменьшить.
[07:52.000 --> 07:54.000]  Как в векторе мы делали с вами.
[07:54.000 --> 07:58.000]  Здесь можно как-то динамически пытаться расширять.
[07:58.000 --> 08:00.000]  И что делать с коллизиями?
[08:00.000 --> 08:02.000]  Тем более их стало у вас сильно больше.
[08:02.000 --> 08:04.000]  Потому что по модулю m.
[08:04.000 --> 08:06.000]  М меньше m, очевидно.
[08:06.000 --> 08:08.000]  Считайте.
[08:10.000 --> 08:12.000]  Делать следующее.
[08:12.000 --> 08:14.000]  Храним.
[08:16.000 --> 08:18.000]  Здесь какие-то контейнеры.
[08:18.000 --> 08:20.000]  То есть храним цепочки.
[08:30.000 --> 08:32.000]  Так.
[08:32.000 --> 08:34.000]  Давайте симплу сотрем.
[08:34.000 --> 08:36.000]  Он нам позже понадобится в виду архитектуры.
[08:36.000 --> 08:38.000]  Немного не прото.
[08:40.000 --> 08:42.000]  То есть храним.
[08:48.000 --> 08:58.000]  Массив размера m меньше m.
[08:58.000 --> 09:00.000]  Это будет массив цепочек.
[09:06.000 --> 09:08.000]  Еще их называют бакетами.
[09:08.000 --> 09:10.000]  То есть мы будем называть термином бакет.
[09:10.000 --> 09:12.000]  Нечто, что хранит элементы, образующие коллизию.
[09:16.000 --> 09:18.000]  Или бакетов.
[09:20.000 --> 09:22.000]  По-английски бакет.
[09:22.000 --> 09:24.000]  То есть здесь у всех хэши равные.
[09:24.000 --> 09:26.000]  И тогда, по идее, что такое поиск?
[09:26.000 --> 09:28.000]  Поиск – это посчитать хэш-функцию,
[09:28.000 --> 09:30.000]  пройти в нужный массивчик
[09:30.000 --> 09:32.000]  и пройтись под цепочки полностью.
[09:32.000 --> 09:34.000]  Аналогично вставка – это
[09:34.000 --> 09:36.000]  найти нужный индекс,
[09:36.000 --> 09:38.000]  пройтись в под цепочки,
[09:38.000 --> 09:40.000]  если такого элемента нет, давайте конец.
[09:40.000 --> 09:42.000]  Что такое удаление?
[09:42.000 --> 09:44.000]  Что такое удаление?
[09:44.000 --> 09:46.000]  Что такое удаление?
[09:46.000 --> 09:48.000]  Что такое удаление?
[09:48.000 --> 09:50.000]  Что такое удаление?
[09:50.000 --> 09:52.000]  Что такое удаление?
[09:52.000 --> 09:54.000]  Идея та же.
[09:54.000 --> 09:56.000]  Так, допустим, вы где-то остановитесь посередине
[09:56.000 --> 09:58.000]  и вам нужно удалять.
[09:58.000 --> 10:00.000]  Ну где-то из середины. Вот, допустим,
[10:00.000 --> 10:02.000]  элемент, которого надо сделать.
[10:02.000 --> 10:04.000]  Тогда какой контейнер нам
[10:04.000 --> 10:06.000]  подойдет для хранения вот таких вот цепочек?
[10:06.000 --> 10:08.000]  Ну да, потому что нам нужно
[10:08.000 --> 10:10.000]  из середины быстро удалять.
[10:14.000 --> 10:16.000]  Так, как надо.
[10:16.000 --> 10:18.000]  За от единицы
[10:20.000 --> 10:22.000]  удалять
[10:22.000 --> 10:24.000]  из
[10:24.000 --> 10:26.000]  бакета.
[10:28.000 --> 10:30.000]  А зачем нам за от единицы
[10:30.000 --> 10:32.000]  удалять от бакета?
[10:32.000 --> 10:34.000]  Мы же хотим вот здесь вот за от единицы
[10:34.000 --> 10:36.000]  в середине все операции.
[10:38.000 --> 10:40.000]  Ну это правда.
[10:40.000 --> 10:42.000]  Это правда.
[10:42.000 --> 10:44.000]  Ну хочется как можно быстрее
[10:44.000 --> 10:46.000]  удалять, скажем так. Если мы можем
[10:46.000 --> 10:48.000]  за от единицы, почему нет?
[10:48.000 --> 10:50.000]  Ну чтобы лишний раз не нагружать.
[10:52.000 --> 10:54.000]  Ну ладно, давайте напишем.
[10:54.000 --> 10:56.000]  Не надо, хочется.
[10:58.000 --> 11:00.000]  Сейчас в бакета
[11:04.000 --> 11:06.000]  будем хранить
[11:10.000 --> 11:12.000]  качество
[11:12.000 --> 11:14.000]  списка.
[11:16.000 --> 11:18.000]  Ну как вы смотрите, у вас здесь,
[11:18.000 --> 11:20.000]  если вы хрените вектор, у вас синтетически
[11:20.000 --> 11:22.000]  не сильно изменится константу все равно,
[11:22.000 --> 11:24.000]  но вам не все все равно не нужна
[11:24.000 --> 11:26.000]  индексация от этого,
[11:26.000 --> 11:28.000]  которые предоставляет вам вектор.
[11:28.000 --> 11:30.000]  Вот такая вот идея, что
[11:30.000 --> 11:32.000]  если вы можете обойтись меньшим
[11:32.000 --> 11:34.000]  множеством операций, берите наиболее
[11:34.000 --> 11:36.000]  удобное.
[11:38.000 --> 11:40.000]  Окей, то есть тогда мы получаем,
[11:40.000 --> 11:42.000]  что по сути
[11:42.000 --> 11:44.000]  время работы операции
[11:48.000 --> 11:50.000]  это что-то типа
[11:50.000 --> 11:52.000]  от длины цепочки.
[11:56.000 --> 11:58.000]  Согласны?
[12:00.000 --> 12:02.000]  Ну тогда мы наверное
[12:02.000 --> 12:04.000]  хотим оценивать
[12:04.000 --> 12:06.000]  в худшем случае, если мы
[12:06.000 --> 12:08.000]  смотрим от длины цепочки, мы хотим, чтобы
[12:08.000 --> 12:10.000]  они все были плюс-минус равные длины.
[12:10.000 --> 12:12.000]  То есть чтобы наша хреш-функция раскидывала
[12:12.000 --> 12:14.000]  равномерно элегента.
[12:14.000 --> 12:16.000]  Логично?
[12:16.000 --> 12:18.000]  То есть что у нас есть?
[12:20.000 --> 12:22.000]  Наш в рецепте
[12:22.000 --> 12:24.000]  лежит h
[12:26.000 --> 12:28.000]  действующий из u
[12:28.000 --> 12:30.000]  0 tra-ta-ta
[12:30.000 --> 12:32.000]  n-1
[12:32.000 --> 12:34.000]  ну только
[12:34.000 --> 12:36.000]  m-1 все-таки уже.
[12:36.000 --> 12:38.000]  Потому что мы берем по моду Lamp, поэтому
[12:38.000 --> 12:40.000]  m-1.
[12:42.000 --> 12:44.000]  И мы хотим, чтобы она равномерно раскидывала.
[12:44.000 --> 12:46.000]  Ну пусть.
[12:50.000 --> 12:52.000]  Мы даже не будем называть
[12:52.000 --> 12:54.000]  переменную.
[12:54.000 --> 12:56.000]  Теперь собственно говоря наш simple uniform
[12:56.000 --> 12:58.000]  hashing прекрасный.
[13:06.000 --> 13:08.000]  А в чем была суть?
[13:08.000 --> 13:10.000]  Ну давайте мы для каждого объекта из u
[13:12.000 --> 13:14.000]  возьмем случайно и независимо выберем отсюда
[13:14.000 --> 13:16.000]  число. Из 0 tra-ta-ta
[13:16.000 --> 13:18.000]  n-1.
[13:20.000 --> 13:22.000]  Создадим массив размера u.
[13:32.000 --> 13:34.000]  Как-то проиндексируем его элементы
[13:34.000 --> 13:36.000]  может 100 u.
[13:38.000 --> 13:40.000]  И поставим
[13:42.000 --> 13:44.000]  каждому
[13:48.000 --> 13:50.000]  уиты из u
[13:54.000 --> 13:56.000]  независимо
[13:58.000 --> 14:00.000]  и равновероятно.
[14:04.000 --> 14:06.000]  Число
[14:08.000 --> 14:10.000]  из множества
[14:16.000 --> 14:18.000]  Вот такая вот идея.
[14:20.000 --> 14:22.000]  Ну тогда
[14:22.000 --> 14:24.000]  будто бы мы все сами построили, да?
[14:26.000 --> 14:28.000]  Подождите.
[14:28.000 --> 14:30.000]  Будто бы мы сами построили, но мы еще
[14:30.000 --> 14:32.000]  про время не знаем что там. Мы еще не знаем
[14:32.000 --> 14:34.000]  что в последнем 12 почке.
[14:34.000 --> 14:36.000]  Видите, мы написали это
[14:36.000 --> 14:38.000]  написали это и это вообще
[14:38.000 --> 14:40.000]  никак не связано.
[14:40.000 --> 14:42.000]  Пока что. Давайте цементировать.
[14:44.000 --> 14:46.000]  Окей.
[14:46.000 --> 14:48.000]  Пусть
[14:50.000 --> 14:52.000]  l-q
[14:52.000 --> 14:54.000]  это 12 почки
[14:56.000 --> 14:58.000]  для ключа q.
[15:02.000 --> 15:04.000]  И соответственно
[15:04.000 --> 15:06.000]  что еще?
[15:10.000 --> 15:12.000]  В текущий момент
[15:16.000 --> 15:18.000]  в хэштаблице
[15:24.000 --> 15:26.000]  ключи
[15:26.000 --> 15:28.000]  k-1
[15:28.000 --> 15:30.000]  k-t.
[15:30.000 --> 15:32.000]  k-t.
[15:32.000 --> 15:34.000]  t ключей.
[15:36.000 --> 15:38.000]  Ну тогда как посчитать среднюю длину цепочки?
[15:42.000 --> 15:44.000]  Ну можно и записать это так
[15:44.000 --> 15:46.000]  что l-q
[15:46.000 --> 15:48.000]  это просто сумма по i
[15:48.000 --> 15:50.000]  от единички до t
[15:50.000 --> 15:52.000]  индикаторов того, что h
[15:52.000 --> 15:54.000]  от
[15:54.000 --> 15:56.000]  x
[15:56.000 --> 15:58.000]  там не знаю
[15:58.000 --> 16:00.000]  давайте h от q
[16:00.000 --> 16:02.000]  равно h от
[16:02.000 --> 16:04.000]  k-i
[16:06.000 --> 16:08.000]  Ну это понятно почему так?
[16:08.000 --> 16:10.000]  Ну индикатор, например,
[16:10.000 --> 16:12.000]  1 если true и 0 если false
[16:12.000 --> 16:14.000]  условия в нем.
[16:14.000 --> 16:16.000]  Тогда вы рассмотрите просто число
[16:16.000 --> 16:18.000]  коллизий, то есть число элементов, которые дают вам
[16:18.000 --> 16:20.000]  коллизию с вашим q.
[16:20.000 --> 16:22.000]  Ну это и есть как раз 12 почки
[16:22.000 --> 16:24.000]  по сути.
[16:24.000 --> 16:26.000]  Все каиты различны.
[16:30.000 --> 16:32.000]  Ну теперь страшное слово.
[16:32.000 --> 16:34.000]  Вот ожидание
[16:36.000 --> 16:38.000]  или expectation.
[16:42.000 --> 16:44.000]  Скажем так, пока что я оставлю это без комментариев
[16:44.000 --> 16:46.000]  вот
[16:46.000 --> 16:48.000]  для первого курса особенно достойно.
[16:48.000 --> 16:50.000]  Я вам пришлю
[16:50.000 --> 16:52.000]  в чат
[16:52.000 --> 16:54.000]  методику по тому, как понимать
[16:54.000 --> 16:56.000]  что такое мотождание.
[16:56.000 --> 16:58.000]  Пока что остановимся лишь на интуитивном
[16:58.000 --> 17:00.000]  уровне, что
[17:00.000 --> 17:02.000]  вообще не так, я просто распишу сначала формулу
[17:02.000 --> 17:04.000]  потом поясню все переходы в ней.
[17:04.000 --> 17:06.000]  Вот.
[17:06.000 --> 17:08.000]  Это просто мотождание от такой вот интересной суммы.
[17:18.000 --> 17:20.000]  Мотождание обладает интересным
[17:20.000 --> 17:22.000]  свойством, что
[17:22.000 --> 17:24.000]  оно линейно, то есть можно
[17:24.000 --> 17:26.000]  менять сумму и мотождание местами.
[17:26.000 --> 17:28.000]  В частности
[17:28.000 --> 17:30.000]  ну
[17:30.000 --> 17:32.000]  окей, мы сами говорили про мотождание в контексте
[17:32.000 --> 17:34.000]  что если у нас есть кубик один, то он выбрасывает
[17:34.000 --> 17:36.000]  в среднем 3,5, да?
[17:36.000 --> 17:38.000]  Типа у вас там кубик
[17:38.000 --> 17:40.000]  от 1 до 6, там
[17:40.000 --> 17:42.000]  грани у него пронумерованы, тогда средний номер,
[17:42.000 --> 17:44.000]  который упадет в грани, 3,5.
[17:44.000 --> 17:46.000]  Вот, такое у нас же было.
[17:46.000 --> 17:48.000]  Тогда если в среднем вы выбрете 2 кубика
[17:48.000 --> 17:50.000]  наверное у вас в среднем 3,5
[17:50.000 --> 17:52.000]  плюс 3,5 будет, то есть 7.
[17:52.000 --> 17:54.000]  Что вроде бы логично.
[17:54.000 --> 17:56.000]  Вот.
[17:56.000 --> 17:58.000]  Детское объяснение,
[17:58.000 --> 18:00.000]  то почему так можно делать.
[18:02.000 --> 18:04.000]  Подробные объяснения вам дадут
[18:04.000 --> 18:06.000]  это наверное
[18:06.000 --> 18:08.000]  в третьем семестре или в четвертом, где у вас
[18:08.000 --> 18:10.000]  мера либега будет.
[18:10.000 --> 18:12.000]  Мера либега.
[18:18.000 --> 18:20.000]  Ну ладно, я в мотождании напишу что такое.
[18:20.000 --> 18:22.000]  Не расстраивайтесь.
[18:22.000 --> 18:24.000]  Сейчас я допишу формулу.
[18:26.000 --> 18:28.000]  И есть такое интересное свойство, что
[18:28.000 --> 18:30.000]  мотождание индикатора это его вероятность.
[18:44.000 --> 18:46.000]  Давайте оценим эту вероятность.
[18:46.000 --> 18:48.000]  Почему она равна?
[19:02.000 --> 19:04.000]  Ну, наверное она равна следующему.
[19:06.000 --> 19:08.000]  Будто бы хочется сказать, что раз мы
[19:08.000 --> 19:10.000]  убираем независимо равномерно
[19:10.000 --> 19:12.000]  из вот того прекрасного множества
[19:12.000 --> 19:14.000]  ноль тра-та-та м минус 1,
[19:14.000 --> 19:16.000]  то наверное 1 делить на m просто, да?
[19:18.000 --> 19:20.000]  Ну вот, это неправильно.
[19:22.000 --> 19:24.000]  Это единичка, если
[19:24.000 --> 19:26.000]  q равно k и t,
[19:26.000 --> 19:28.000]  и 1 делить на m
[19:28.000 --> 19:30.000]  иначе.
[19:34.000 --> 19:36.000]  Ну потому что если у вас
[19:36.000 --> 19:38.000]  как бы они совпали, то понятно, что
[19:38.000 --> 19:40.000]  вероятность 1.
[19:40.000 --> 19:42.000]  Точно будет это верно. Если они не совпали,
[19:42.000 --> 19:44.000]  то тогда действительно идет
[19:44.000 --> 19:46.000]  наша логика, что мы выбирали
[19:46.000 --> 19:48.000]  независимо и равномерно, поэтому здесь
[19:48.000 --> 19:50.000]  будет 1 делить на m.
[19:50.000 --> 19:52.000]  Но это как не знаю.
[19:52.000 --> 19:54.000]  Если вы бросите два кубика,
[19:54.000 --> 19:56.000]  какая вероятность того, что у них будут
[19:56.000 --> 19:58.000]  одинаковые значения?
[20:00.000 --> 20:02.000]  Вот одна шестая будет, если что.
[20:02.000 --> 20:04.000]  Можете посчитать.
[20:04.000 --> 20:06.000]  Наверное.
[20:06.000 --> 20:08.000]  Ну да, 6 пар, что у вас совпадет,
[20:08.000 --> 20:10.000]  6 квадрат пар, что всего.
[20:10.000 --> 20:12.000]  6 делить на 6 квадрат,
[20:12.000 --> 20:14.000]  1 делить на m получаем.
[20:14.000 --> 20:16.000]  Окей.
[20:16.000 --> 20:18.000]  Ну тогда можно оценить эту штуку.
[20:20.000 --> 20:22.000]  1 плюс
[20:22.000 --> 20:24.000]  t минус 1 делить на m.
[20:28.000 --> 20:30.000]  Понятно, откуда эта оценка берется?
[20:30.000 --> 20:32.000]  То есть у вас, допустим,
[20:32.000 --> 20:34.000]  здесь есть одно равенство,
[20:34.000 --> 20:36.000]  это единичка, и тогда у вас
[20:36.000 --> 20:38.000]  t минус 1 не равенство,
[20:38.000 --> 20:40.000]  в любом случае.
[20:40.000 --> 20:42.000]  Потому что у вас все каиты различны.
[20:42.000 --> 20:44.000]  А почему мы равенство не поставим?
[20:46.000 --> 20:48.000]  Ну...
[20:48.000 --> 20:50.000]  Нам достаточно неравенство здесь,
[20:50.000 --> 20:52.000]  скажем так.
[20:52.000 --> 20:54.000]  Можно равенство поставить.
[20:54.000 --> 20:56.000]  А, равенство здесь мы не можем поставить.
[20:56.000 --> 20:58.000]  Знаете почему? Потому что вдруг у нас q не равно
[20:58.000 --> 21:00.000]  никакому каитам.
[21:00.000 --> 21:02.000]  Тогда это было бы просто t делить на m,
[21:02.000 --> 21:04.000]  а это меньше.
[21:04.000 --> 21:06.000]  Поэтому здесь неравенство стоит.
[21:08.000 --> 21:10.000]  И для красты
[21:10.000 --> 21:12.000]  минус 1 уберем.
[21:14.000 --> 21:16.000]  Окей.
[21:16.000 --> 21:18.000]  Так-так-так.
[21:18.000 --> 21:20.000]  Там стиратка.
[21:28.000 --> 21:30.000]  Так сказать,
[21:30.000 --> 21:32.000]  наша цель перед нами,
[21:32.000 --> 21:34.000]  как видите,
[21:34.000 --> 21:36.000]  мы уже близки к успеху на самом деле.
[21:36.000 --> 21:38.000]  Мы уже близки к успеху на самом деле.
[21:42.000 --> 21:44.000]  Почему мы близки к успеху?
[21:44.000 --> 21:46.000]  Потому что мы оценили,
[21:46.000 --> 21:48.000]  что для на цепочке,
[21:48.000 --> 21:50.000]  в среднем, она меньше
[21:50.000 --> 21:52.000]  1 плюс t делить на m. Согласны?
[21:54.000 --> 21:56.000]  Определение.
[21:56.000 --> 21:58.000]  t деленное на m,
[21:58.000 --> 22:00.000]  где
[22:00.000 --> 22:02.000]  t это
[22:02.000 --> 22:04.000]  размер х-таблицы
[22:06.000 --> 22:08.000]  Развер в плане
[22:08.000 --> 22:10.000]  так напишем,
[22:10.000 --> 22:12.000]  число элементов х-таблицы.
[22:14.000 --> 22:16.000]  То есть то, что вам вернуло метод size
[22:20.000 --> 22:22.000]  в х-таблице
[22:24.000 --> 22:26.000]  а m
[22:26.000 --> 22:28.000]  это число бакетов
[22:28.000 --> 22:30.000]  макетов
[22:34.000 --> 22:36.000]  называется
[22:40.000 --> 22:42.000]  коэффициентом
[22:42.000 --> 22:44.000]  загрузки
[22:44.000 --> 22:46.000]  ну или загруженности.
[22:48.000 --> 22:50.000]  Тут как бы
[22:50.000 --> 22:52.000]  в этой теории обычно все говорят на английском.
[22:54.000 --> 22:56.000]  На английском это load factor называется.
[22:58.000 --> 23:00.000]  Ну тогда
[23:00.000 --> 23:02.000]  смотри, что мы делаем.
[23:04.000 --> 23:06.000]  Зафиксируем
[23:06.000 --> 23:08.000]  c больше 0
[23:10.000 --> 23:12.000]  и будем поддерживать
[23:20.000 --> 23:22.000]  m так,
[23:22.000 --> 23:24.000]  чтобы
[23:24.000 --> 23:26.000]  alpha
[23:26.000 --> 23:28.000]  t деленное на m
[23:28.000 --> 23:30.000]  было столько меньше c.
[23:30.000 --> 23:32.000]  То есть когда вы
[23:32.000 --> 23:34.000]  подобавляли туда элементов кучу,
[23:34.000 --> 23:36.000]  вам рано или поздно придется
[23:36.000 --> 23:38.000]  расширяться,
[23:38.000 --> 23:40.000]  чтобы вы сохраняли вот это вот свойство.
[23:44.000 --> 23:46.000]  То есть как бы у нас будет такая
[23:46.000 --> 23:48.000]  х-таблица, что когда у нас
[23:48.000 --> 23:50.000]  поднакидали столько элементов, что мы превысили это
[23:50.000 --> 23:52.000]  отношение, мы берем
[23:52.000 --> 23:54.000]  исправим полностью перестройку.
[23:54.000 --> 23:56.000]  То есть мы берем, создаем новую х-таблицу
[23:56.000 --> 23:58.000]  в два раза большего размера
[23:58.000 --> 24:00.000]  и
[24:00.000 --> 24:02.000]  что мы с ней делаем?
[24:02.000 --> 24:04.000]  Заново сгибаем в нее элементы.
[24:06.000 --> 24:08.000]  Идея такая, в общем-то.
[24:08.000 --> 24:10.000]  Ну тогда если мы сказали, что это
[24:10.000 --> 24:12.000]  меньше c,
[24:12.000 --> 24:14.000]  тогда мы можем сказать, что это столько меньше,
[24:14.000 --> 24:16.000]  чем 1 х c.
[24:18.000 --> 24:20.000]  Ну откуда вас следует?
[24:22.000 --> 24:24.000]  Потому что
[24:24.000 --> 24:26.000]  мы от ожидания длины цепочки
[24:26.000 --> 24:28.000]  это от 1.
[24:28.000 --> 24:30.000]  Значит все операции
[24:30.000 --> 24:32.000]  выполняются за от 1 в среднем.
[24:36.000 --> 24:38.000]  Победа как бы, да?
[24:40.000 --> 24:42.000]  Теперь давайте поймем, что это нифига не победа.
[24:42.000 --> 24:44.000]  Мы по сути не приблизились к успеху
[24:44.000 --> 24:46.000]  вообще ни разу.
[24:46.000 --> 24:48.000]  Почему?
[24:48.000 --> 24:50.000]  Потому что в этой модели
[24:50.000 --> 24:52.000]  нужно хранить для каждого
[24:52.000 --> 24:54.000]  ключа из u
[24:54.000 --> 24:56.000]  какую-то случайную
[24:56.000 --> 24:58.000]  числу.
[24:58.000 --> 25:00.000]  Допустим, мы умеем случайно
[25:00.000 --> 25:02.000]  убирать числа, да?
[25:02.000 --> 25:04.000]  Но проблема в том, что мы должны хранить
[25:04.000 --> 25:06.000]  массив размера модуль u.
[25:06.000 --> 25:08.000]  Что совсем неприемлемо, в общем-то.
[25:10.000 --> 25:12.000]  Вот вы работаете со строками,
[25:12.000 --> 25:14.000]  строки на алфавите длины 2,
[25:14.000 --> 25:16.000]  бинарные строки, да?
[25:16.000 --> 25:18.000]  И они все, рассматривают
[25:18.000 --> 25:20.000]  все строки длины до 50.
[25:20.000 --> 25:22.000]  Два в 0, плюс два в первой,
[25:22.000 --> 25:24.000]  плюс и так далее.
[25:24.000 --> 25:26.000]  Два в пятидесятой минус один.
[25:26.000 --> 25:28.000]  Много достаточно.
[25:30.000 --> 25:32.000]  И как бы нам с таким
[25:32.000 --> 25:34.000]  иметь дело не хочется.
[25:34.000 --> 25:36.000]  Поэтому simple uniform hashing
[25:36.000 --> 25:38.000]  это не алгоритм никакой.
[25:38.000 --> 25:40.000]  Это модель теоретическая, в которой мы смогли
[25:40.000 --> 25:42.000]  что-то посчитать.
[25:42.000 --> 25:44.000]  И действительно, если это верно,
[25:44.000 --> 25:46.000]  то есть если у вас верно тот принцип,
[25:46.000 --> 25:48.000]  то если мы равномерно выбираем,
[25:48.000 --> 25:50.000]  то действительно это круто.
[25:50.000 --> 25:52.000]  Мы смогли доказать,
[25:52.000 --> 25:54.000]  что все-таки единица работает.
[25:54.000 --> 25:56.000]  Но мы только что поняли, что на практике
[25:56.000 --> 25:58.000]  это ни разу не применимо.
[25:58.000 --> 26:00.000]  Теперь будем подгонять модель,
[26:00.000 --> 26:02.000]  чтобы она была применима на практике.
[26:02.000 --> 26:04.000]  Давайте еще раз
[26:04.000 --> 26:06.000]  вернемся к этим вычислениям.
[26:08.000 --> 26:10.000]  Вот это просто по определению цепочки.
[26:12.000 --> 26:14.000]  Это свойством от ожидания,
[26:14.000 --> 26:16.000]  этот переход.
[26:16.000 --> 26:18.000]  Этот переход тоже свойством от ожидания.
[26:18.000 --> 26:20.000]  Смотрите, вот отсюда
[26:20.000 --> 26:22.000]  до сюда
[26:22.000 --> 26:24.000]  мы ни разу
[26:24.000 --> 26:26.000]  не пользовались моделью теоретической
[26:26.000 --> 26:28.000]  как таковой.
[26:28.000 --> 26:30.000]  Мы пользуемся тем, что у нас есть какие-то бакеты.
[26:30.000 --> 26:32.000]  Я ценю их размер.
[26:32.000 --> 26:34.000]  Что теперь будем делать?
[26:34.000 --> 26:36.000]  Проблема в том,
[26:36.000 --> 26:38.000]  что у нас вот такое неравенство есть.
[26:38.000 --> 26:40.000]  И вот оно вытекает
[26:40.000 --> 26:42.000]  из нашей модели, которую мы построили.
[26:44.000 --> 26:46.000]  Давайте мы ослабим требования
[26:46.000 --> 26:48.000]  и не будем требовать равномерности, независимости.
[26:48.000 --> 26:50.000]  Будем требовать только вот
[26:50.000 --> 26:52.000]  такое вот интересное ограничение.
[26:52.000 --> 26:54.000]  Определение.
[26:56.000 --> 26:58.000]  Отдельное следующее.
[26:58.000 --> 27:00.000]  Что
[27:00.000 --> 27:02.000]  назовем
[27:06.000 --> 27:08.000]  семейство
[27:08.000 --> 27:10.000]  аж красивое.
[27:14.000 --> 27:16.000]  Хэш функции
[27:18.000 --> 27:20.000]  лямбда универсальный
[27:26.000 --> 27:28.000]  если
[27:30.000 --> 27:32.000]  для любых x и y
[27:38.000 --> 27:40.000]  рассматривается вероятность по хэш функциям
[27:40.000 --> 27:42.000]  из семейства.
[27:42.000 --> 27:44.000]  То есть, да, вы хотите брать случайную
[27:44.000 --> 27:46.000]  хэш функцию.
[27:46.000 --> 27:48.000]  У вас зачем-то возникло такое желание.
[27:48.000 --> 27:50.000]  аж от x
[27:50.000 --> 27:52.000]  равно аж от y
[27:52.000 --> 27:54.000]  не превосходит
[27:54.000 --> 27:56.000]  лямбда делить на
[27:56.000 --> 27:58.000]  сем.
[27:58.000 --> 28:00.000]  То есть, смотрите,
[28:00.000 --> 28:02.000]  в чем суть?
[28:02.000 --> 28:04.000]  Вы такие, окей, хорошо.
[28:04.000 --> 28:06.000]  Это все, конечно, круто.
[28:06.000 --> 28:08.000]  Я не могу брать бассейн размера u
[28:08.000 --> 28:10.000]  и каждому из них, независимо, проставлять
[28:10.000 --> 28:12.000]  это долго.
[28:12.000 --> 28:14.000]  Это много по памяти.
[28:14.000 --> 28:16.000]  Но я могу что сделать?
[28:16.000 --> 28:18.000]  Я могу как-то параметризовать мою
[28:18.000 --> 28:20.000]  семейство хэш функций.
[28:20.000 --> 28:22.000]  То есть, сделать, чтобы оно зависело
[28:22.000 --> 28:24.000]  от каких-то параметров.
[28:24.000 --> 28:26.000]  И дальше просто перебирать вот эту
[28:26.000 --> 28:28.000]  вероятность.
[28:28.000 --> 28:30.000]  Потому что вдруг хэш функции будет удовлетворять
[28:30.000 --> 28:32.000]  вот этому соотношению.
[28:34.000 --> 28:36.000]  Вот тут вот.
[28:36.000 --> 28:38.000]  Это вот оно, по сути.
[28:38.000 --> 28:40.000]  Лямбда.
[28:40.000 --> 28:42.000]  Либо с неравных игр,
[28:42.000 --> 28:44.000]  имеется в виду, конечно.
[28:44.000 --> 28:46.000]  Окей.
[28:46.000 --> 28:48.000]  Теперь, что мы сами сделаем?
[28:48.000 --> 28:50.000]  Мы будем считать, что u
[28:50.000 --> 28:52.000]  это множество.
[28:56.000 --> 28:58.000]  То есть, это какое-то множество чечелок.
[28:58.000 --> 29:00.000]  Оно будет большим.
[29:00.000 --> 29:02.000]  Достаточно.
[29:02.000 --> 29:04.000]  Это будет uint64t.
[29:04.000 --> 29:06.000]  То есть, их будет 2 в 64
[29:06.000 --> 29:08.000]  в реализацию у вас.
[29:10.000 --> 29:12.000]  Но при этом это не все объекты
[29:12.000 --> 29:14.000]  возможны, типа там строк, например.
[29:14.000 --> 29:16.000]  Как со строками работать,
[29:16.000 --> 29:18.000]  потом поясним.
[29:18.000 --> 29:20.000]  Это нам будет важно для анализа.
[29:20.000 --> 29:22.000]  Тогда, если у нас есть такое
[29:22.000 --> 29:24.000]  семейство хэш функций,
[29:24.000 --> 29:26.000]  то все. У нас есть вот такое
[29:26.000 --> 29:28.000]  вот свойство.
[29:28.000 --> 29:30.000]  У нас есть такое свойство, у нас есть оценка.
[29:30.000 --> 29:32.000]  Нужная нам.
[29:32.000 --> 29:34.000]  Но осталось
[29:34.000 --> 29:36.000]  предвить h.
[29:36.000 --> 29:38.000]  Согласны?
[29:38.000 --> 29:40.000]  Если я построю вам такую h красивую,
[29:40.000 --> 29:42.000]  то мы победим.
[29:44.000 --> 29:46.000]  Определение.
[29:52.000 --> 29:54.000]  В плане.
[29:56.000 --> 29:58.000]  У вас вот здесь вот
[29:58.000 --> 30:00.000]  один делить на m.
[30:00.000 --> 30:02.000]  Но нам достаточно лямбда делить на m здесь взять.
[30:02.000 --> 30:04.000]  Все равно оценки все не изменятся.
[30:08.000 --> 30:10.000]  Просто там
[30:10.000 --> 30:12.000]  констант циприс побольше взять просто.
[30:12.000 --> 30:14.000]  Определение следующее, что
[30:18.000 --> 30:20.000]  h красивая сильно универсальная,
[30:22.000 --> 30:24.000]  ну или просто универсальная.
[30:26.000 --> 30:28.000]  Если оно
[30:30.000 --> 30:32.000]  один универсальное.
[30:36.000 --> 30:38.000]  То есть, если вы смогли
[30:38.000 --> 30:40.000]  построить лямбда равна единице, то оно называется у вас
[30:40.000 --> 30:42.000]  сильно универсальным.
[30:42.000 --> 30:44.000]  Или просто универсальным.
[30:44.000 --> 30:46.000]  Или один универсальным.
[30:46.000 --> 30:48.000]  И еще тысяча других вариантов, которые вы только
[30:48.000 --> 30:50.000]  придумаете, потому что здесь нет фиксированной терминологии.
[30:54.000 --> 30:56.000]  Мы убьем его строить.
[31:00.000 --> 31:02.000]  Они один универсальная.
[31:02.000 --> 31:04.000]  То есть, лямбда равна единице у вас в этом соотношении.
[31:12.000 --> 31:14.000]  Окей.
[31:16.000 --> 31:18.000]  Рассмотрим
[31:20.000 --> 31:22.000]  h параметризованная параметрами
[31:22.000 --> 31:24.000]  a и b.
[31:24.000 --> 31:26.000]  А b принадлежит zp,
[31:28.000 --> 31:30.000]  а не равно 0.
[31:36.000 --> 31:38.000]  Давайте так
[31:38.000 --> 31:40.000]  допишем.
[31:40.000 --> 31:42.000]  h ab
[31:44.000 --> 31:46.000]  так
[31:46.000 --> 31:48.000]  h ab
[31:48.000 --> 31:50.000]  от x
[31:50.000 --> 31:52.000]  равно
[31:52.000 --> 31:54.000]  ax
[31:54.000 --> 31:56.000]  плюс b
[31:56.000 --> 31:58.000]  по модулю p,
[31:58.000 --> 32:00.000]  по модулю m.
[32:02.000 --> 32:04.000]  Где m, это у вас
[32:04.000 --> 32:06.000]  вот отсюда берется чиселка.
[32:06.000 --> 32:08.000]  А эта чиселка берется
[32:08.000 --> 32:10.000]  отсюда.
[32:10.000 --> 32:12.000]  Эта чиселка берется отсюда,
[32:12.000 --> 32:14.000]  а m это число бакетов.
[32:18.000 --> 32:20.000]  Я хочу доказать, что у такого семейства будет один универсальный.
[32:22.000 --> 32:24.000]  Сильно универсальный.
[32:24.000 --> 32:26.000]  Что вообще не очевидно.
[32:26.000 --> 32:28.000]  Что?
[32:28.000 --> 32:30.000]  p простое.
[32:30.000 --> 32:32.000]  p простое.
[32:34.000 --> 32:36.000]  p больше,
[32:36.000 --> 32:38.000]  чем
[32:38.000 --> 32:40.000]  модулю.
[32:40.000 --> 32:42.000]  Чтобы у вас любой x,
[32:42.000 --> 32:44.000]  который вы могли подать хэш-функции,
[32:44.000 --> 32:46.000]  он у вас всегда был
[32:46.000 --> 32:48.000]  меньше, чем p.
[32:48.000 --> 32:50.000]  Чтобы он тоже жил в zp.
[32:52.000 --> 32:54.000]  Теорема.
[32:56.000 --> 32:58.000]  Семейство выше.
[33:00.000 --> 33:02.000]  Сильно универсальное.
[33:04.000 --> 33:06.000]  Универсальное.
[33:14.000 --> 33:16.000]  Будут идеи, как доказывать?
[33:18.000 --> 33:20.000]  Ну окей, ладно, давайте я начну.
[33:22.000 --> 33:24.000]  Это вот 0,
[33:24.000 --> 33:26.000]  1, 2,
[33:26.000 --> 33:28.000]  и минус 1.
[33:28.000 --> 33:30.000]  То есть, арифметика по модулю p.
[33:32.000 --> 33:34.000]  Окей, здесь будет 2 этапа.
[33:34.000 --> 33:36.000]  Первый этап это,
[33:36.000 --> 33:38.000]  что значит, что
[33:38.000 --> 33:40.000]  ax плюс b,
[33:40.000 --> 33:42.000]  давайте зафиксируем x не равно y.
[33:44.000 --> 33:46.000]  Зафиксируем
[33:46.000 --> 33:48.000]  x не равно
[33:48.000 --> 33:50.000]  y.
[33:50.000 --> 33:52.000]  Введем g от x
[33:52.000 --> 33:54.000]  равную ax плюс b
[33:54.000 --> 33:56.000]  по модулю p.
[33:58.000 --> 34:00.000]  То есть, вот это вот первый кусочек
[34:00.000 --> 34:02.000]  внутренний.
[34:04.000 --> 34:06.000]  Давайте рассмотрим, что значит g от x
[34:06.000 --> 34:08.000]  равно g от y.
[34:10.000 --> 34:12.000]  Это то же самое, что у вас
[34:12.000 --> 34:14.000]  ax плюс b
[34:16.000 --> 34:18.000]  равно
[34:18.000 --> 34:20.000]  ax плюс b
[34:20.000 --> 34:22.000]  по модулю p.
[34:24.000 --> 34:26.000]  Согласны?
[34:26.000 --> 34:28.000]  Просто по определению уже.
[34:30.000 --> 34:32.000]  Это то же самое,
[34:32.000 --> 34:34.000]  что у вас
[34:34.000 --> 34:36.000]  ax
[34:36.000 --> 34:38.000]  сравнимо с ay
[34:38.000 --> 34:40.000]  по модулю p.
[34:42.000 --> 34:44.000]  Так как zp это поле,
[34:44.000 --> 34:46.000]  там можно делить
[34:46.000 --> 34:48.000]  мы можем домножить на a в минус
[34:48.000 --> 34:50.000]  1 здесь и здесь,
[34:50.000 --> 34:52.000]  и у вас не возникнет
[34:52.000 --> 34:54.000]  многих проблем.
[34:58.000 --> 35:00.000]  Что x сравним с y по модулю p?
[35:00.000 --> 35:02.000]  Так как у нас
[35:02.000 --> 35:04.000]  x и y из zp заведомо,
[35:04.000 --> 35:06.000]  потому что p больше, чем размер множества,
[35:06.000 --> 35:08.000]  размер u,
[35:08.000 --> 35:10.000]  равесенен тому, что x равно y.
[35:10.000 --> 35:12.000]  То есть, мы вам показали
[35:12.000 --> 35:14.000]  равносильность
[35:14.000 --> 35:16.000]  того, что у вас
[35:16.000 --> 35:18.000]  g от x равно g от y,
[35:18.000 --> 35:20.000]  это то же самое, что x равно y.
[35:20.000 --> 35:22.000]  Ну что из этого следует в частности?
[35:22.000 --> 35:24.000]  Из этого следует в частности,
[35:24.000 --> 35:26.000]  что g
[35:28.000 --> 35:30.000]  из zp,
[35:30.000 --> 35:32.000]  ну x и y вообще лежат вот здесь, вот в u.
[35:32.000 --> 35:34.000]  x и y в u.
[35:36.000 --> 35:38.000]  Так как у нас
[35:38.000 --> 35:40.000]  p заведомо больше, чем u,
[35:40.000 --> 35:42.000]  у нас x и y
[35:42.000 --> 35:44.000]  равносильно этому,
[35:44.000 --> 35:46.000]  просто-напросто.
[35:46.000 --> 35:48.000]  Окей.
[35:48.000 --> 35:50.000]  Мы показали, что g коллизии вообще не дает.
[35:52.000 --> 35:54.000]  g не дает коллизий.
[36:06.000 --> 36:08.000]  Второй этап доказательства.
[36:08.000 --> 36:10.000]  Докажем, что g биекция.
[36:12.000 --> 36:14.000]  То есть, смотрите, у вас
[36:14.000 --> 36:16.000]  была какая-то точка.
[36:16.000 --> 36:18.000]  Вот у вас шкарнатная плоскость.
[36:18.000 --> 36:20.000]  Ось x, ось y.
[36:24.000 --> 36:26.000]  Это g от x,
[36:26.000 --> 36:28.000]  это ось g от y.
[36:28.000 --> 36:30.000]  И вы как-то сюда переносите
[36:30.000 --> 36:32.000]  по действиям функции g.
[36:32.000 --> 36:34.000]  То есть,
[36:34.000 --> 36:36.000]  у вас была какая-то точка.
[36:36.000 --> 36:38.000]  Вот у вас шкарнатная плоскость.
[36:38.000 --> 36:40.000]  Ось x, ось y.
[36:42.000 --> 36:44.000]  Ваш точку x, y.
[36:44.000 --> 36:46.000]  x, y приходит
[36:46.000 --> 36:48.000]  g от x, g от y.
[36:52.000 --> 36:54.000]  То есть, мы действительно показали,
[36:54.000 --> 36:56.000]  что каждую точку мы переносим в какую-то одну.
[36:56.000 --> 36:58.000]  Отсюда-сюда.
[37:00.000 --> 37:02.000]  Но правда ли, что из-за этого следует
[37:02.000 --> 37:04.000]  что g биекция?
[37:06.000 --> 37:08.000]  Вот мы доказали
[37:08.000 --> 37:10.000]  с вами, что g от x равно g от y,
[37:10.000 --> 37:12.000]  а тогда это x равно y.
[37:12.000 --> 37:14.000]  Правда ли, что g биекция?
[37:20.000 --> 37:22.000]  Ну да, x, y из z, p лежат.
[37:24.000 --> 37:26.000]  g от y будто бы тоже
[37:26.000 --> 37:28.000]  из z, p лежат, потому что берете по моделю
[37:28.000 --> 37:30.000]  p в конце.
[37:30.000 --> 37:32.000]  Ну как-то можно явно показать.
[37:34.000 --> 37:36.000]  Можно показать, на самом деле, что
[37:36.000 --> 37:38.000]  если у вас
[37:38.000 --> 37:40.000]  есть пара x, y
[37:40.000 --> 37:42.000]  и пара g от x, g от y,
[37:42.000 --> 37:44.000]  вы можете однозначно a, b восстановить
[37:44.000 --> 37:46.000]  по ним просто-напросто.
[37:46.000 --> 37:48.000]  Согласны ли вы с этим утверждением?
[37:52.000 --> 37:54.000]  То есть, если вы знаете, что у вас
[37:54.000 --> 37:56.000]  ax плюс b равно u,
[37:56.000 --> 37:58.000]  ay плюс b
[37:58.000 --> 38:00.000]  равно v,
[38:00.000 --> 38:02.000]  то у вас есть такая система, да?
[38:02.000 --> 38:04.000]  То вы a и b однозначно
[38:04.000 --> 38:06.000]  из нее находите.
[38:08.000 --> 38:10.000]  Ну давайте посмотрим, почему это верно.
[38:10.000 --> 38:12.000]  Рассмотрим матричную запись.
[38:14.000 --> 38:16.000]  Что это такое?
[38:16.000 --> 38:18.000]  Это будто бы вы рассматриваете
[38:18.000 --> 38:20.000]  матрицу A.
[38:22.000 --> 38:24.000]  Не, не так. Не так хочу
[38:24.000 --> 38:26.000]  написать. Наоборот, хочу x, y написать.
[38:30.000 --> 38:32.000]  У, в.
[38:32.000 --> 38:34.000]  Правда? Вроде правда, да?
[38:34.000 --> 38:36.000]  Правда, да?
[38:36.000 --> 38:38.000]  Тогда у меня a, b однозначно
[38:38.000 --> 38:40.000]  останавливаются по u и v,
[38:40.000 --> 38:42.000]  тогда и только тогда, когда этот
[38:42.000 --> 38:44.000]  определитель не выражен.
[38:46.000 --> 38:48.000]  У вас определитель выражен только тогда,
[38:48.000 --> 38:50.000]  когда x равно y.
[38:52.000 --> 38:54.000]  Все, победа. То есть, мы с вами
[38:54.000 --> 38:56.000]  получили что-то биекция, действительно.
[38:56.000 --> 38:58.000]  Вот. Зачем я это делаю?
[38:58.000 --> 39:00.000]  Зачем я это сделал?
[39:00.000 --> 39:02.000]  Затем, что иногда вам нужно будет,
[39:02.000 --> 39:04.000]  если вы будете заниматься алгоритмами,
[39:04.000 --> 39:06.000]  у вас будут не только вот такие вот семейства,
[39:06.000 --> 39:08.000]  но вы будете
[39:08.000 --> 39:10.000]  хотеть семейства больше,
[39:10.000 --> 39:12.000]  что у вас был h от x, там равно h от y,
[39:12.000 --> 39:14.000]  h от y равно h от z и так далее.
[39:14.000 --> 39:16.000]  То есть, больше сюда засовывать условий.
[39:16.000 --> 39:18.000]  Да, такие случаи
[39:18.000 --> 39:20.000]  не нужны. Есть такие хэш-функции.
[39:20.000 --> 39:22.000]  Они там называются
[39:22.000 --> 39:24.000]  два независимые,
[39:24.000 --> 39:26.000]  три независимые. В некоторых алгоритмах
[39:26.000 --> 39:28.000]  нужно пять независимые хэш-функции.
[39:28.000 --> 39:30.000]  И у вас получается здесь матрица
[39:30.000 --> 39:32.000]  Вандермонда, по сути.
[39:32.000 --> 39:34.000]  И вы считаете определитель.
[39:34.000 --> 39:36.000]  А определитель матрицы Вандермонда у вас
[39:36.000 --> 39:38.000]  не выражен, если у вас нет равных элементов
[39:38.000 --> 39:40.000]  среди x, y и так далее.
[39:40.000 --> 39:42.000]  Поэтому я это написал, чтобы было красиво.
[39:42.000 --> 39:44.000]  Вот.
[39:44.000 --> 39:46.000]  Ну, давайте это
[39:46.000 --> 39:48.000]  дельта обозначим.
[39:48.000 --> 39:50.000]  death от
[39:50.000 --> 39:52.000]  x, y.
[39:52.000 --> 39:54.000]  Вот.
[39:54.000 --> 39:56.000]  Ну, давайте это дельта
[39:56.000 --> 39:58.000]  обозначим.
[39:58.000 --> 40:00.000]  death от
[40:00.000 --> 40:02.000]  x, y, 1, 1
[40:02.000 --> 40:04.000]  дельта не равен нулю при
[40:04.000 --> 40:06.000]  x, не равных y.
[40:06.000 --> 40:08.000]  Ну все, доказали, что у нас есть объекция.
[40:12.000 --> 40:14.000]  Я говорю следующее,
[40:14.000 --> 40:16.000]  что
[40:16.000 --> 40:18.000]  вероятность вот этих вот
[40:18.000 --> 40:20.000]  это то же самое, что вероятность
[40:22.000 --> 40:24.000]  вот эта вот.
[40:24.000 --> 40:26.000]  То есть, вероятность третьей равной x, y
[40:26.000 --> 40:28.000]  такова же,
[40:28.000 --> 40:30.000]  что вы возьмете равные a, b.
[40:30.000 --> 40:32.000]  Поэтому у вас семейство хэш-функций
[40:32.000 --> 40:34.000]  параметризуется так,
[40:34.000 --> 40:36.000]  а с помощью этого хода вы можете
[40:36.000 --> 40:38.000]  перейти к x, y от a, b.
[40:38.000 --> 40:40.000]  Потому что там у вас
[40:40.000 --> 40:42.000]  на самом деле записана вероятность
[40:42.000 --> 40:44.000]  и для x, y.
[40:44.000 --> 40:46.000]  Для x, не равных y вы рассматриваете.
[40:46.000 --> 40:48.000]  А здесь у вас написана
[40:48.000 --> 40:50.000]  вероятность по хэш-функциям.
[40:50.000 --> 40:52.000]  И вообще связь не очевидна, откуда она берется.
[40:52.000 --> 40:54.000]  Это же разные вероятности, по сути.
[40:54.000 --> 40:56.000]  И когда он сказал, что отсюда следует это,
[40:56.000 --> 40:58.000]  это вообще неправда на самом деле.
[40:58.000 --> 41:00.000]  Это следует тогда и только когда,
[41:00.000 --> 41:02.000]  когда у вас по x и y
[41:02.000 --> 41:04.000]  однозначно восстанавливается хэш-функция.
[41:04.000 --> 41:06.000]  Что мы здесь доказали с вами.
[41:10.000 --> 41:12.000]  По модулю m мы будем брать только для того,
[41:12.000 --> 41:14.000]  чтобы получить вот эту вот оценку
[41:14.000 --> 41:16.000]  на самом деле.
[41:16.000 --> 41:18.000]  Это просто вероятность того,
[41:18.000 --> 41:20.000]  что берете случайную хэш-функцию.
[41:20.000 --> 41:22.000]  То есть вы считаете здесь
[41:22.000 --> 41:24.000]  число хэш-функций, дающих коллизию
[41:24.000 --> 41:26.000]  на конкретных x, y.
[41:26.000 --> 41:28.000]  И делите на размерность семейства.
[41:28.000 --> 41:30.000]  Классическое комбинаторное
[41:30.000 --> 41:32.000]  определение вероятности,
[41:32.000 --> 41:34.000]  это число успехов делить на число
[41:34.000 --> 41:36.000]  всевозможных вариантов.
[41:36.000 --> 41:38.000]  Число успехов это число хэш-функций,
[41:38.000 --> 41:40.000]  которые вам дадут коллизию.
[41:40.000 --> 41:42.000]  Всего вариантов, это сколько у вас
[41:42.000 --> 41:44.000]  элементов семейства.
[41:44.000 --> 41:46.000]  И здесь это вообще не очевидно как-то связано
[41:46.000 --> 41:48.000]  с числом пар.
[41:48.000 --> 41:50.000]  А если мы показали, что это биекция
[41:50.000 --> 41:52.000]  на этапе g,
[41:52.000 --> 41:54.000]  на этапе функции g,
[41:54.000 --> 41:56.000]  это биекция.
[41:56.000 --> 41:58.000]  И вы можете говорить в терминах
[41:58.000 --> 42:00.000]  x, y о вероятности в терминах h.
[42:00.000 --> 42:02.000]  Отлично.
[42:02.000 --> 42:04.000]  Теперь осталось,
[42:04.000 --> 42:06.000]  раз у нас g биекция,
[42:06.000 --> 42:08.000]  осталось по модулю m разобраться,
[42:08.000 --> 42:10.000]  что происходит.
[42:10.000 --> 42:12.000]  Наверное, сатрусы этой доски
[42:12.000 --> 42:14.000]  все-таки, потому что там
[42:14.000 --> 42:16.000]  все еще важная вещь.
[42:20.000 --> 42:22.000]  Пункт третий.
[42:24.000 --> 42:26.000]  Соотношение
[42:26.000 --> 42:28.000]  на вероятность, так называемое.
[42:32.000 --> 42:34.000]  Как я вам сказал,
[42:34.000 --> 42:36.000]  мы сейчас будем считать число
[42:36.000 --> 42:38.000]  хэш-функций, которые дадут вам коллизию.
[42:38.000 --> 42:40.000]  То есть зафиксируем x неравно y.
[42:52.000 --> 42:54.000]  Если мы зафиксировали x неравно y,
[42:54.000 --> 42:56.000]  мы можем однозначно восстановить a, b.
[42:56.000 --> 42:58.000]  Поэтому мы однозначно можем восстановить
[42:58.000 --> 43:00.000]  не так сейчас, не x неравно y.
[43:00.000 --> 43:02.000]  И все, просто зафиксировали их.
[43:02.000 --> 43:04.000]  Остановились на этом этапе.
[43:04.000 --> 43:06.000]  Что дальше будем делать?
[43:06.000 --> 43:08.000]  Будем считать вероятность того,
[43:08.000 --> 43:10.000]  что h от x равна h от y.
[43:12.000 --> 43:14.000]  Которую нам сказано посчитать.
[43:18.000 --> 43:20.000]  Как ее оценить?
[43:24.000 --> 43:26.000]  Зафиксируем x.
[43:28.000 --> 43:30.000]  Мы зафиксировали x неравно y.
[43:32.000 --> 43:34.000]  Даже не так, просто зафиксируем какой-то x.
[43:34.000 --> 43:36.000]  Тогда что это такое?
[43:36.000 --> 43:38.000]  Как это можно посчитать?
[43:38.000 --> 43:40.000]  Сколько у вас для заданного x
[43:40.000 --> 43:42.000]  хэш-функций,
[43:42.000 --> 43:44.000]  которым дадут коллизию?
[43:52.000 --> 43:54.000]  Тогда h от x
[43:54.000 --> 43:56.000]  равно h от y
[43:56.000 --> 43:58.000]  равна сильно тому,
[43:58.000 --> 44:00.000]  что g от x
[44:00.000 --> 44:02.000]  равно g от y
[44:02.000 --> 44:04.000]  по модулю m.
[44:04.000 --> 44:06.000]  То есть вот у вас
[44:06.000 --> 44:08.000]  какая-то числа прямая, да?
[44:10.000 --> 44:12.000]  Вот ваш g от x.
[44:14.000 --> 44:16.000]  Он лежит где-то в отрезке
[44:16.000 --> 44:18.000]  от 0 до p-1.
[44:20.000 --> 44:22.000]  Тогда как найти число таких y,
[44:22.000 --> 44:24.000]  что g от y,
[44:24.000 --> 44:26.000]  будучи биекцией,
[44:26.000 --> 44:28.000]  вам даст
[44:28.000 --> 44:30.000]  равное число?
[44:32.000 --> 44:34.000]  g от x
[44:36.000 --> 44:38.000]  плюс m,
[44:38.000 --> 44:40.000]  g от x
[44:40.000 --> 44:42.000]  плюс 2m,
[44:42.000 --> 44:44.000]  g от x минус m.
[44:44.000 --> 44:46.000]  Сколько таких отрезков длины m влезет?
[44:48.000 --> 44:50.000]  Ну я утверждаю что-то типа
[44:54.000 --> 44:56.000]  что вот столько отрезков будет.
[44:58.000 --> 45:00.000]  То есть я при фиксированном x
[45:00.000 --> 45:02.000]  из двух вариантов получу коллизии.
[45:02.000 --> 45:04.000]  Почему это так?
[45:04.000 --> 45:06.000]  Потому что у меня есть биекция
[45:06.000 --> 45:08.000]  между x и y, которые я здесь
[45:08.000 --> 45:10.000]  рассматриваю напрямой, и хэш-функциями,
[45:10.000 --> 45:12.000]  которые я здесь рассматриваю.
[45:12.000 --> 45:14.000]  У меня же биекция как в одну сторону,
[45:14.000 --> 45:16.000]  так и в другую биекцию будет.
[45:16.000 --> 45:18.000]  Поэтому если я посчитал число равных пар
[45:18.000 --> 45:20.000]  x и y при фиксированном x,
[45:20.000 --> 45:22.000]  это значит, что я нашел число
[45:22.000 --> 45:24.000]  нужных нам хэш-функций.
[45:26.000 --> 45:28.000]  То есть это равно
[45:30.000 --> 45:32.000]  p на вот эту вот штуку.
[45:36.000 --> 45:38.000]  Ну почему это так?
[45:38.000 --> 45:40.000]  Потому что у вас x в p штук.
[45:42.000 --> 45:44.000]  А для каждого x вот столько y.
[45:44.000 --> 45:46.000]  Поделить на
[45:46.000 --> 45:48.000]  размерность h большого,
[45:48.000 --> 45:50.000]  h красивого.
[45:50.000 --> 45:52.000]  Сколько у нас хэш-функций всего существует?
[45:56.000 --> 45:58.000]  Ну давайте они параметризуются a и b буквами.
[45:58.000 --> 46:00.000]  Буквок a сколько разных может быть?
[46:02.000 --> 46:04.000]  А лежит zp, а не равно 0.
[46:06.000 --> 46:08.000]  p-1, а b разных сколько?
[46:08.000 --> 46:10.000]  В смысле плюс 1.
[46:12.000 --> 46:14.000]  Почему b-то p-1?
[46:14.000 --> 46:16.000]  А ну любое может быть.
[46:16.000 --> 46:18.000]  Их p.
[46:18.000 --> 46:20.000]  Ну 0, 1, 2, 3.
[46:20.000 --> 46:22.000]  Их p чисел разных будет.
[46:22.000 --> 46:24.000]  То есть b класс p, h к p-1.
[46:24.000 --> 46:26.000]  Поднимите руки,
[46:26.000 --> 46:28.000]  кто верит, что это
[46:28.000 --> 46:30.000]  1 делик на m будет.
[46:30.000 --> 46:32.000]  Не превосходить.
[46:34.000 --> 46:36.000]  Ну давайте докажем.
[46:38.000 --> 46:40.000]  Изня.
[46:40.000 --> 46:42.000]  Ну я утверждаю,
[46:42.000 --> 46:44.000]  что это верно на самом деле.
[46:44.000 --> 46:46.000]  Просто мне немножко лень сейчас с этим возиться.
[46:46.000 --> 46:48.000]  Будем честны.
[46:48.000 --> 46:50.000]  Вот.
[46:50.000 --> 46:52.000]  То есть мы с вами построили сильно универсальное
[46:52.000 --> 46:54.000]  семейство хэш-функций.
[46:54.000 --> 46:56.000]  А раз мы смогли его построить,
[46:56.000 --> 46:58.000]  и мы доказали, что
[46:58.000 --> 47:00.000]  в данном семействе хэш-функций,
[47:00.000 --> 47:02.000]  данной вероятности коверентам на той доске,
[47:02.000 --> 47:04.000]  мы с вами построили нужное нам
[47:04.000 --> 47:06.000]  семейство хэш-функций с таким свойством.
[47:06.000 --> 47:08.000]  Значит мы построили наконец-то
[47:08.000 --> 47:10.000]  хэштаблицу с заданными
[47:10.000 --> 47:12.000]  операциями.
[47:12.000 --> 47:14.000]  Все, теперь вы можете пользоваться
[47:14.000 --> 47:16.000]  в следующем контесте, можно будет пользоваться
[47:16.000 --> 47:18.000]  всем, если что.
[47:18.000 --> 47:20.000]  Типа нордовцитами тоже можно будет
[47:20.000 --> 47:22.000]  теперь пользоваться.
[47:22.000 --> 47:24.000]  Потому что мы обсуждали, как они реализованы,
[47:24.000 --> 47:26.000]  почему они работают.
[47:26.000 --> 47:28.000]  Все окей, мы закончили с хэштаблицами, и
[47:28.000 --> 47:30.000]  я вас поздравляю, мы закончили с структурами данных
[47:30.000 --> 47:32.000]  на этот семестр. Теперь алгоритмы.
[47:34.000 --> 47:36.000]  Динамическое программирование.
[47:44.000 --> 47:46.000]  Шутка
[47:46.000 --> 47:48.000]  и простатическое программирование не уместно
[47:48.000 --> 47:50.000]  из зала.
[47:50.000 --> 47:52.000]  Кто-то пошутил, я слышал.
[47:56.000 --> 47:58.000]  Окей, вот, динамическое программирование,
[47:58.000 --> 48:00.000]  что это такое? Это
[48:00.000 --> 48:02.000]  такой подход, когда мы
[48:02.000 --> 48:04.000]  хотим решить какую-то одну большую задачу,
[48:04.000 --> 48:06.000]  и мы знаем, как решить задачу
[48:06.000 --> 48:08.000]  гораздо проще.
[48:10.000 --> 48:12.000]  Пример. Тут
[48:12.000 --> 48:14.000]  легче сразу сразу с примера начать.
[48:14.000 --> 48:16.000]  Вспомним наше любимое число
[48:16.000 --> 48:18.000]  Fibonacci.
[48:22.000 --> 48:24.000]  F1
[48:24.000 --> 48:26.000]  равно F2
[48:26.000 --> 48:28.000]  равно
[48:28.000 --> 48:30.000]  1.
[48:30.000 --> 48:32.000]  Как
[48:32.000 --> 48:34.000]  напишут
[48:34.000 --> 48:36.000]  вычисление числа Fibonacci
[48:36.000 --> 48:38.000]  человек, который
[48:38.000 --> 48:40.000]  мало об этом программирует,
[48:40.000 --> 48:42.000]  нажимается так, что
[48:42.000 --> 48:44.000]  int функция Fib
[48:44.000 --> 48:46.000]  от n
[48:48.000 --> 48:50.000]  типа if
[48:50.000 --> 48:52.000]  n
[48:52.000 --> 48:54.000]  больше либо равно 2
[48:54.000 --> 48:56.000]  в return
[48:58.000 --> 49:00.000]  Fib от
[49:00.000 --> 49:02.000]  n-1
[49:02.000 --> 49:04.000]  plus Fib
[49:04.000 --> 49:06.000]  от n-2.
[49:06.000 --> 49:08.000]  Иначе
[49:08.000 --> 49:10.000]  return
[49:10.000 --> 49:12.000]  0.
[49:24.000 --> 49:26.000]  Это всегда код,
[49:26.000 --> 49:28.000]  вы не понимаете, это другое.
[49:32.000 --> 49:34.000]  Есть такой код,
[49:34.000 --> 49:36.000]  чем он плох,
[49:36.000 --> 49:38.000]  чем он хорош, давайте так.
[49:42.000 --> 49:44.000]  Он с полностью соответствующей математической модели,
[49:44.000 --> 49:46.000]  но при этом он очень плох
[49:46.000 --> 49:48.000]  с точки зрения реализации.
[49:50.000 --> 49:52.000]  Можете попробовать по приколу
[49:52.000 --> 49:54.000]  оценить, сколько времени это работает.
[49:56.000 --> 49:58.000]  Ну, примерно, да.
[50:00.000 --> 50:02.000]  Ну, от числа Fibonacci.
[50:02.000 --> 50:04.000]  Оно не растет
[50:04.000 --> 50:06.000]  потенциально быстро, мы это сами уже выясняли.
[50:08.000 --> 50:10.000]  То есть, смотрите, здесь явно принцип
[50:10.000 --> 50:12.000]  того, что мы хотим посчитать Fn,
[50:12.000 --> 50:14.000]  но если мы знаем n-1 и n-2,
[50:14.000 --> 50:16.000]  то мы как бы явно можем
[50:16.000 --> 50:18.000]  посчитать Fn.
[50:18.000 --> 50:20.000]  То есть, как бы у нас какая-то сложная задача, мы ее делим
[50:20.000 --> 50:22.000]  под задачу попроще.
[50:22.000 --> 50:24.000]  Поэтому давайте мы будем
[50:24.000 --> 50:26.000]  считать не так, а заведем массив dp
[50:26.000 --> 50:28.000]  так называемый.
[50:28.000 --> 50:30.000]  Пусть dpi
[50:30.000 --> 50:32.000]  равно
[50:32.000 --> 50:34.000]  F it
[50:34.000 --> 50:36.000]  просто.
[50:36.000 --> 50:38.000]  Тогда у нас есть база индукции,
[50:38.000 --> 50:40.000]  база динамики, так сказать.
[50:50.000 --> 50:52.000]  У нас есть с вами переход.
[50:58.000 --> 51:00.000]  Это что dp it
[51:02.000 --> 51:04.000]  это dp i-1
[51:04.000 --> 51:06.000]  плюс dp
[51:06.000 --> 51:08.000]  i-2.
[51:08.000 --> 51:10.000]  Мы знаем, где лежит ответ.
[51:12.000 --> 51:14.000]  После того, как мы посчитали dp,
[51:14.000 --> 51:16.000]  ответ от dp n.
[51:20.000 --> 51:22.000]  Осталось понять, как порядок
[51:22.000 --> 51:24.000]  пересчета делать.
[51:24.000 --> 51:26.000]  В каком порядке вы будете
[51:26.000 --> 51:28.000]  высчитывать значения dp it?
[51:28.000 --> 51:30.000]  Можно вот так вот высчитывать, да?
[51:30.000 --> 51:32.000]  Можно написать
[51:32.000 --> 51:34.000]  i равно 1,
[51:34.000 --> 51:36.000]  i равно 3,
[51:36.000 --> 51:38.000]  n.
[51:38.000 --> 51:40.000]  Вот.
[51:40.000 --> 51:42.000]  То есть, можно идти вниз,
[51:42.000 --> 51:44.000]  так сказать, нисходящую динамику делать,
[51:44.000 --> 51:46.000]  от n уменьшать.
[51:46.000 --> 51:48.000]  А можно, наоборот, вверх,
[51:48.000 --> 51:50.000]  от маленьких в больших.
[51:50.000 --> 51:52.000]  Вот.
[51:52.000 --> 51:54.000]  Собственно, как-то так.
[51:54.000 --> 51:56.000]  То есть, смотрите, чем прикол.
[51:56.000 --> 51:58.000]  Вы могли бы здесь действительно заполнить
[51:58.000 --> 52:00.000]  мотив dp, запомните его.
[52:00.000 --> 52:02.000]  И здесь перекрутивно вызываться,
[52:02.000 --> 52:04.000]  и просто, если вы взялись рекурсивно,
[52:04.000 --> 52:06.000]  то возвращать dp it,
[52:06.000 --> 52:08.000]  если он уже посчитан.
[52:08.000 --> 52:10.000]  Иначе,
[52:10.000 --> 52:12.000]  надо посчитать.
[52:12.000 --> 52:14.000]  Как бы, действительно,
[52:14.000 --> 52:16.000]  это будет работать тоже за рению
[52:16.000 --> 52:18.000]  суммарно, но
[52:18.000 --> 52:20.000]  эта рекурсия, она не очень
[52:20.000 --> 52:22.000]  просмотрится все-таки.
[52:22.000 --> 52:24.000]  Вот.
[52:24.000 --> 52:26.000]  То есть, как бы,
[52:26.000 --> 52:28.000]  как можно рассматривать динамику?
[52:28.000 --> 52:30.000]  Динамику в некотором плане к ней можно посмотреть
[52:30.000 --> 52:32.000]  как какая-то индукция.
[52:32.000 --> 52:34.000]  То есть, индукция по номеру
[52:34.000 --> 52:36.000]  часа фибоначи, например.
[52:36.000 --> 52:38.000]  Мы сейчас посмотрим часам пару задач,
[52:38.000 --> 52:40.000]  чтобы было понятнее.
[52:40.000 --> 52:42.000]  У нас есть база, у нас есть переход, у нас есть местный гляд,
[52:42.000 --> 52:44.000]  у нас есть порядок пересчета.
[52:44.000 --> 52:46.000]  То есть, и того, чтобы,
[52:46.000 --> 52:48.000]  так сказать, пять шагов к успеху в задаче на dp,
[52:48.000 --> 52:50.000]  это вам нужно определить пять
[52:50.000 --> 52:52.000]  из этих параметров.
[52:54.000 --> 52:56.000]  Это
[52:56.000 --> 52:58.000]  собственно, что такое
[52:58.000 --> 53:00.000]  dp it?
[53:00.000 --> 53:02.000]  Ну, быть может, здесь будут у вас больше измерений.
[53:02.000 --> 53:04.000]  Просто, что такое состояние динамики?
[53:04.000 --> 53:06.000]  Дальше, какие базы в состоянии вам заведомо
[53:06.000 --> 53:08.000]  известны, и вы считаете
[53:08.000 --> 53:10.000]  относительно быстро?
[53:10.000 --> 53:12.000]  Какие у вас есть формулы перехода?
[53:12.000 --> 53:14.000]  Где у вас будет лежать ответ, когда вы посчитаете?
[53:14.000 --> 53:16.000]  И в каком порядке вы будете считать ответ?
[53:18.000 --> 53:20.000]  Здесь желательно четвертый и пятый местами поменять.
[53:20.000 --> 53:22.000]  Но это неважно особо.
[53:22.000 --> 53:24.000]  То есть,
[53:24.000 --> 53:26.000]  не то чтобы формальность,
[53:26.000 --> 53:28.000]  понятное дело, что
[53:28.000 --> 53:30.000]  никто, когда решает задачу на динамику,
[53:30.000 --> 53:32.000]  не сидит такой, блин,
[53:32.000 --> 53:34.000]  где, какой у меня порядок пересчета?
[53:34.000 --> 53:36.000]  И не выписывает на листочке где-то себя.
[53:36.000 --> 53:38.000]  Просто берет и пишет.
[53:38.000 --> 53:40.000]  И он не особо задумывается о том,
[53:40.000 --> 53:42.000]  что здесь действительно есть пять шагов.
[53:42.000 --> 53:44.000]  Итак,
[53:46.000 --> 53:48.000]  что можно об этом сказать?
[53:48.000 --> 53:50.000]  Короче, если вы будете представить голове как-то так,
[53:50.000 --> 53:52.000]  то он будет жить проще, просто,
[53:52.000 --> 53:54.000]  решать задачу на динамику.
[53:54.000 --> 53:56.000]  Помимо того, есть еще принцип
[53:56.000 --> 53:58.000]  перекрывающихся под задач,
[53:58.000 --> 54:00.000]  это когда вы много раз должны посчитать одно и то же.
[54:00.000 --> 54:02.000]  То есть, если вы рассматриваете
[54:02.000 --> 54:04.000]  этот код,
[54:04.000 --> 54:06.000]  то у вас там в часах манача 10,
[54:06.000 --> 54:08.000]  когда вы его вызовете, ФИБА 10,
[54:08.000 --> 54:10.000]  где-нибудь в мейне вы здесь ФИБА 10 посчитаете, да?
[54:10.000 --> 54:12.000]  У вас кучу раз ФИБА 5
[54:12.000 --> 54:14.000]  будут вызываться.
[54:14.000 --> 54:16.000]  То есть, перескачиваешься
[54:16.000 --> 54:18.000]  под задачу, посчитать ФИБА 5
[54:18.000 --> 54:20.000]  и кучу раз. Давайте просто один раз
[54:20.000 --> 54:22.000]  сферим ответы и все.
[54:22.000 --> 54:24.000]  То есть, подход, когда у вас есть рекурсия
[54:24.000 --> 54:26.000]  и вы запоминаете массив ответов,
[54:26.000 --> 54:28.000]  это называется рекурсия
[54:28.000 --> 54:30.000]  с мемуизацией, так называют.
[54:30.000 --> 54:32.000]  А когда вы отказываетесь от рекурсии,
[54:32.000 --> 54:34.000]  то это называется ДБА.
[54:36.000 --> 54:38.000]  Как много в этом словосочетании?
[54:40.000 --> 54:42.000]  Ну, и по сути дела,
[54:42.000 --> 54:44.000]  мы сейчас будем просто рассматривать
[54:44.000 --> 54:46.000]  разные задачи, какие есть.
[54:46.000 --> 54:48.000]  Ну, и такая первая задача,
[54:48.000 --> 54:50.000]  помимо чисел ФИБА,
[54:50.000 --> 54:52.000]  легендарных, конечно же,
[54:52.000 --> 54:54.000]  это задача про кузнечика.
[54:54.000 --> 54:56.000]  Ну да, прикиньте,
[54:56.000 --> 54:58.000]  вот мы с вами проходили
[54:58.000 --> 55:00.000]  Б деревья с Б деревья.
[55:00.000 --> 55:02.000]  Тут, кажется, таблицу рядом с ними считали.
[55:02.000 --> 55:04.000]  Мы с вами спустились на такое дно.
[55:04.000 --> 55:06.000]  Это кузнечик. Вот, есть кузнечик.
[55:10.000 --> 55:12.000]  Знакомьтесь к кузнечику.
[55:14.000 --> 55:16.000]  Он не очень похож на кузнечика,
[55:16.000 --> 55:18.000]  но были вот такие кузнечики,
[55:18.000 --> 55:20.000]  откуда я родился.
[55:20.000 --> 55:22.000]  Будем считать.
[55:22.000 --> 55:24.000]  Может, это Козлик, не знаю.
[55:24.000 --> 55:26.000]  У вас вот написано там
[55:26.000 --> 55:28.000]  числа, которые...
[55:28.000 --> 55:30.000]  Вот есть вот, так сказать,
[55:30.000 --> 55:32.000]  он умеет у вас прыгать как-то,
[55:32.000 --> 55:34.000]  тут написано число.
[55:36.000 --> 55:38.000]  Допустим, не знаю,
[55:38.000 --> 55:40.000]  он упал на клетку с А1,
[55:42.000 --> 55:44.000]  там, не знаю, потеряешь,
[55:44.000 --> 55:46.000]  но что может кузнечик потерять?
[55:46.000 --> 55:48.000]  Не надо так.
[55:48.000 --> 55:50.000]  У нас все-таки ХП.
[55:50.000 --> 55:52.000]  Очки ХП он теряет.
[55:54.000 --> 55:56.000]  Вот, там, не знаю, если он упал во 2,
[55:56.000 --> 55:58.000]  типа тут, не знаю, была там
[55:58.000 --> 56:00.000]  схватка с гусеницей, например, какая-нибудь.
[56:00.000 --> 56:02.000]  Если он упал во 2, то он там
[56:02.000 --> 56:04.000]  поел, что идет к кузнечике.
[56:04.000 --> 56:06.000]  Ну траву, вот он поел траву,
[56:06.000 --> 56:08.000]  плюс есть очки ХП,
[56:08.000 --> 56:10.000]  что-нибудь такое.
[56:10.000 --> 56:12.000]  Вот кузнечик умеет прыгать на 1 вперед
[56:12.000 --> 56:14.000]  и на 2 вперед.
[56:14.000 --> 56:16.000]  Вопрос в том, какая траектория
[56:16.000 --> 56:18.000]  должна быть к кузнечику, чтобы
[56:18.000 --> 56:20.000]  собрать максимальное
[56:20.000 --> 56:22.000]  количество очков ХП
[56:22.000 --> 56:24.000]  к А1.
[56:24.000 --> 56:26.000]  Давайте здесь у него
[56:26.000 --> 56:28.000]  будет, не знаю, домик.
[56:28.000 --> 56:30.000]  А как он умеет прыгать?
[56:30.000 --> 56:32.000]  На 1 вперед, а на 2 вперед.
[56:36.000 --> 56:38.000]  Вот, ну давайте
[56:38.000 --> 56:40.000]  здесь жадный алгоритм, который
[56:40.000 --> 56:42.000]  все время прыгает в максимальную
[56:42.000 --> 56:44.000]  возможность, что он не проходит.
[56:44.000 --> 56:46.000]  Вы согласны с этим или нет?
[56:46.000 --> 56:48.000]  Да, да.
[56:48.000 --> 56:50.000]  Ну давайте построим пример,
[56:50.000 --> 56:52.000]  когда он не работает.
[56:52.000 --> 56:54.000]  Что-нибудь типа минус 1.
[56:54.000 --> 56:56.000]  Десять.
[56:56.000 --> 56:58.000]  Минус 100 и минус 1000.
[56:58.000 --> 57:00.000]  Вот ваш балдежный кузнечик.
[57:04.000 --> 57:06.000]  Вот его тропа успеха.
[57:08.000 --> 57:10.000]  И как ваш алгоритм будет
[57:10.000 --> 57:12.000]  прыгать?
[57:12.000 --> 57:14.000]  Что?
[57:14.000 --> 57:16.000]  Не, почему?
[57:16.000 --> 57:18.000]  Он у вас прыгнет сюда?
[57:18.000 --> 57:20.000]  Ну вот что такое жадный алгоритм?
[57:20.000 --> 57:22.000]  Вы будете прыгать, а он
[57:22.000 --> 57:24.000]  в наименьше из зол
[57:24.000 --> 57:26.000]  возможных на данный момент.
[57:26.000 --> 57:28.000]  Ну минус 1 и 10.
[57:28.000 --> 57:30.000]  Вы прыгнете в 10, понятное дело.
[57:32.000 --> 57:34.000]  Ну вам нужно всегда в ноль добраться, допустим.
[57:36.000 --> 57:38.000]  Хорошо, дальше прыгать вперед.
[57:38.000 --> 57:40.000]  Либо сюда, либо сюда.
[57:40.000 --> 57:42.000]  Видимо сюда, да?
[57:42.000 --> 57:44.000]  Все, наждано.
[57:44.000 --> 57:46.000]  Да, это
[57:46.000 --> 57:48.000]  минус 3.
[57:48.000 --> 57:50.000]  Сейчас.
[57:50.000 --> 57:52.000]  Это обман.
[57:54.000 --> 57:56.000]  Наверное 1000.
[57:56.000 --> 57:58.000]  Ну да, если минус 100 и 1000.
[57:58.000 --> 58:00.000]  Если он отработает,
[58:00.000 --> 58:02.000]  в любом случае.
[58:04.000 --> 58:06.000]  Десять и не минус.
[58:06.000 --> 58:08.000]  Наверное, у вас есть число
[58:08.000 --> 58:10.000]  для вытягивающих.
[58:10.000 --> 58:12.000]  Вот так вот.
[58:12.000 --> 58:14.000]  Он не сможет прыгнуть.
[58:16.000 --> 58:18.000]  Минус 100, минус 50.
[58:18.000 --> 58:20.000]  Он тогда в минус 100 прыгнет.
[58:24.000 --> 58:26.000]  Да я хочу вас байтить на прыжок.
[58:26.000 --> 58:28.000]  В какое место?
[58:28.000 --> 58:30.000]  Он не байтит.
[58:30.000 --> 58:32.000]  Помогите.
[58:36.000 --> 58:38.000]  Ну типа, мы стоим, окей.
[58:38.000 --> 58:40.000]  Мы прыгаем в лучшее из возможных.
[58:42.000 --> 58:44.000]  И вот Коки хорошо стоит и дальше смотрит.
[58:44.000 --> 58:46.000]  Я прыгаю в минус 100, наверное.
[58:46.000 --> 58:48.000]  Смотрит и дальше прыгает.
[58:48.000 --> 58:50.000]  Лучше из двух, наверное, минус 1000.
[58:50.000 --> 58:52.000]  Прыгнет 0.
[58:52.000 --> 58:54.000]  А оптимальный алгоритм
[58:54.000 --> 58:56.000]  был бы такой.
[58:56.000 --> 58:58.000]  Раз, два, три.
[58:58.000 --> 59:00.000]  То есть не фармит лишние минус 100.
[59:04.000 --> 59:06.000]  Валдежно мы смотрели.
[59:06.000 --> 59:08.000]  Это было сложно.
[59:12.000 --> 59:14.000]  Вот такой у нас кузнечик классный есть.
[59:14.000 --> 59:16.000]  Вопрос, как решать задачу.
[59:16.000 --> 59:18.000]  Жадную гриф не подходит.
[59:18.000 --> 59:20.000]  Можно пробовать другую жадность какую-нибудь.
[59:20.000 --> 59:22.000]  Не факт, что это получится.
[59:24.000 --> 59:26.000]  Поэтому предлагается следующее решение.
[59:28.000 --> 59:30.000]  Рассмотрим DPIT.
[59:30.000 --> 59:32.000]  Рассмотрим DPIT.
[59:34.000 --> 59:36.000]  Ответ.
[59:36.000 --> 59:38.000]  Если
[59:38.000 --> 59:40.000]  массив имеет вид.
[59:42.000 --> 59:44.000]  A1, A2.
[59:44.000 --> 59:46.000]  То есть первый и элемент.
[59:46.000 --> 59:48.000]  Это прекрасный
[59:48.000 --> 59:50.000]  naming, а нам как-то
[59:50.000 --> 59:52.000]  именно надо назвать.
[59:52.000 --> 59:54.000]  Вот, это самое сложное
[59:54.000 --> 59:56.000]  в динамическом программировании.
[59:56.000 --> 59:58.000]  Но помимо того, чтобы понять, как решать задачу,
[59:58.000 --> 01:00:00.000]  правильно назвать DP.
[01:00:00.000 --> 01:00:02.000]  Что такое DP?
[01:00:02.000 --> 01:00:04.000]  Это
[01:00:04.000 --> 01:00:06.000]  не знаю.
[01:00:06.000 --> 01:00:08.000]  Max result
[01:00:08.000 --> 01:00:10.000]  on prefix.
[01:00:12.000 --> 01:00:14.000]  То есть длинные имя писать.
[01:00:14.000 --> 01:00:16.000]  Да.
[01:00:16.000 --> 01:00:18.000]  Ну я не знаю, может у вас там
[01:00:18.000 --> 01:00:20.000]  семинаристы примут короткое имя, я не буду понимать.
[01:00:22.000 --> 01:00:24.000]  Окей.
[01:00:24.000 --> 01:00:26.000]  Хорошо.
[01:00:26.000 --> 01:00:28.000]  Мы сами определили базы где.
[01:00:30.000 --> 01:00:32.000]  Где базы, ребят?
[01:00:32.000 --> 01:00:34.000]  Ну такой отбеляет 0.
[01:00:34.000 --> 01:00:36.000]  Отбеляет 0, да.
[01:00:38.000 --> 01:00:40.000]  Что еще может быть?
[01:00:40.000 --> 01:00:42.000]  Мы можем сказать четко DP от единички.
[01:00:42.000 --> 01:00:44.000]  Это что такое?
[01:00:44.000 --> 01:00:46.000]  Это A1 просто.
[01:00:48.000 --> 01:00:50.000]  Мы можем еще DP2 задать,
[01:00:50.000 --> 01:00:52.000]  например.
[01:00:52.000 --> 01:00:54.000]  Это максимум из
[01:00:54.000 --> 01:00:56.000]  A2,
[01:00:56.000 --> 01:00:58.000]  A1 плюс A2.
[01:00:58.000 --> 01:01:00.000]  Ну или можно перестать
[01:01:00.000 --> 01:01:02.000]  так как A2 плюс
[01:01:02.000 --> 01:01:04.000]  A1 на индикатор того,
[01:01:04.000 --> 01:01:06.000]  что A1 больше 0.
[01:01:08.000 --> 01:01:10.000]  Да чего так сказать просто A2
[01:01:10.000 --> 01:01:12.000]  плюс максимум A1
[01:01:12.000 --> 01:01:14.000]  0? Можно.
[01:01:14.000 --> 01:01:16.000]  Можно как угодно.
[01:01:16.000 --> 01:01:18.000]  Типа здесь
[01:01:18.000 --> 01:01:20.000]  it's up to you, как говорится.
[01:01:20.000 --> 01:01:22.000]  Где-то считать.
[01:01:22.000 --> 01:01:24.000]  Окей.
[01:01:24.000 --> 01:01:26.000]  С этим справились.
[01:01:26.000 --> 01:01:28.000]  Уже хорошо.
[01:01:28.000 --> 01:01:30.000]  И переходы есть.
[01:01:32.000 --> 01:01:34.000]  Ну,
[01:01:34.000 --> 01:01:36.000]  DP iti
[01:01:36.000 --> 01:01:38.000]  это A iti
[01:01:38.000 --> 01:01:40.000]  плюс
[01:01:40.000 --> 01:01:42.000]  максимум из
[01:01:42.000 --> 01:01:44.000]  DP
[01:01:44.000 --> 01:01:46.000]  и минус 1, DP
[01:01:46.000 --> 01:01:48.000]  и минус 2.
[01:01:48.000 --> 01:01:50.000]  Почему?
[01:01:50.000 --> 01:01:52.000]  Вы обязательно придете
[01:01:52.000 --> 01:01:54.000]  и выберете максимум
[01:01:54.000 --> 01:01:56.000]  из двух величин, откуда вы могли попасть.
[01:01:58.000 --> 01:02:00.000]  Но ответ лежит в DPN.
[01:02:00.000 --> 01:02:02.000]  Порядок пересчета
[01:02:02.000 --> 01:02:04.000]  вот.
[01:02:06.000 --> 01:02:08.000]  Окей, знаете, справились.
[01:02:08.000 --> 01:02:10.000]  У нас времени.
[01:02:10.000 --> 01:02:12.000]  Вам уже опять надо сказать.
