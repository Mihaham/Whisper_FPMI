[00:00.000 --> 00:12.360]  Наша цель на сегодня не очень большая, но такая есть. Нужно научиться реализовывать
[00:12.360 --> 00:19.680]  некое подобие контейнеров, которое содержит сущности переменного типа.
[00:19.680 --> 00:27.120]  В частности, шерты с кастомным локатором. Но это не контейнеры, это я неправильно сказал.
[00:27.120 --> 00:31.280]  Мы сегодня не поговорим о том, как Сипрос Плюс устроит динамическую типизацию.
[00:31.280 --> 00:42.840]  Ну так. Некое подобие динамической типизации. И это будет тема 14, которая будет называться,
[00:42.840 --> 00:49.520]  ну можно было бы ее назвать, наверное, я пока сюда шел, вот я придумал, что ее, наверное,
[00:49.520 --> 00:55.280]  можно было бы назвать одним словом динамической типизация, но давайте я более подробно напишу.
[00:55.280 --> 01:07.160]  TypeRanger и Union. На самом деле есть примерно два разных подхода к тому, как можно устроить
[01:07.160 --> 01:17.120]  в плюсах динамическую типизацию. TypeRanger и Union. Ну и опять-таки, честно говоря, поскольку плюсы
[01:17.120 --> 01:25.120]  это основа мироздания, значит, я подозреваю, что в большинстве языков, в которых есть динамическая
[01:25.120 --> 01:31.640]  типизация, в том же питоне, скорее всего, ну под капотом примерно так что-то и работает.
[01:31.640 --> 01:37.680]  То есть у нас просто, мы сейчас просто реализуем это, и вы поймете, что, ну в общем-то, это,
[01:38.280 --> 01:45.360]  пожалуй, естественный способ, и другого-то, собственно, принципиально какого-то особо не придумаешь,
[01:45.360 --> 01:51.000]  мне кажется. Вот, мы начнем с TypeRanger. Это такая идеологическая стирание типов,
[01:51.000 --> 02:03.160]  ну по-русски уже довольно прижившийся термин, и разберем мы это на примере такого замечательного
[02:03.160 --> 02:25.160]  класса, который называется STD Any. Значит, STD Any, ну и его реализация. Что такое STD Any,
[02:25.160 --> 02:33.920]  как вы, наверное, можете догадаться из названия. Да, это объект, который может хранить любой тип.
[02:33.920 --> 02:46.600]  Ну, он на самом деле, этот тип появился, начиная с C++17 только. Ну, сама идеома TypeRanger
[02:46.600 --> 02:54.360]  появилась гораздо раньше, но вот этот тип появился с C++17, и вот мы начнем с него,
[02:54.360 --> 03:02.560]  потому что он самый такой, ну самый простой, что ли. Вот, ну давайте для начала как им пользоваться.
[03:02.560 --> 03:09.480]  Смотрите, я могу написать STD Any, да, ну, во-первых, надо подключить загадочный файл Any,
[03:09.480 --> 03:17.560]  могу написать STD Any a там равно 5, и теперь Any будет хранить int. А потом я могу сказать a равно,
[03:17.560 --> 03:29.080]  но вот если так сделать, я, честно говоря, не уверен, что он будет хранить. Ну, давайте я вот так
[03:29.080 --> 03:39.480]  напишу. Вот так сделаю. Ну, это значит, для строк есть типа, пусть не было бы начинать с такой версии,
[03:39.480 --> 03:54.040]  литеральный суффикс s, это значит, что this is the Sting, а не Charles S. Вот, теперь a будет строкой,
[03:54.040 --> 04:06.120]  потом можно a положить вектор, ну, короче, что угодно можно сделать с a. Вот, нет, чтобы обратиться к
[04:06.120 --> 04:12.840]  тому, что в a лежит, вот это хороший вопрос. А как обратиться, собственно, к отцу? Или можно ли написать,
[04:12.840 --> 04:20.120]  сейчас, по крайней мере, можно написать auto b равно a? Да, b будет Any. Ого. С таким же
[04:20.120 --> 04:31.320]  содержимым. Логично. И String b равно a нельзя написать сейчас. А там a минус abc? А равно? Нет, это присваивание,
[04:31.320 --> 04:44.280]  не минус конечно. Таких операций мы не поддерживаем. Вот, как обратиться к тому, что в Any лежит? Нужно знать,
[04:44.280 --> 04:52.120]  что там лежит. Это некое неудобство, это вам все-таки не питом. Придется явно говорить,
[04:52.120 --> 04:58.400]  какой вы хотите тип, когда к Any обращаетесь. То есть, вот вы можете обратиться к Any и сказать,
[04:58.400 --> 05:06.160]  ну, давай-ка достань мне строку, которая там сейчас лежит. Но если там будет не строка в этот
[05:06.160 --> 05:18.840]  момент, то exception. Сейчас. Он не знает, что там лежит. Нет, кто? Any. Сам по себе. Что значит
[05:18.840 --> 05:24.640]  знает? В смысле? И вот если вы просите его вернуть строку, он вернет. Если просите вернуть int,
[05:24.640 --> 05:30.160]  сейчас он не справится. Да. Но при этом сам он не может понять, что мы от него... Нет, может,
[05:30.160 --> 05:40.700]  может, спросить type. Значит, есть два основных метода. Type и, ну, вот, скастовать к данному
[05:40.700 --> 05:47.480]  te. Если там действительно te, то все будет хорошо. То есть, можно скастовать к type и все. Да. Ну,
[05:47.480 --> 05:58.080]  и спросить, какой type. Он вернет type id. Ну, то есть, можно сказать a.type. Сейчас, я, на всякий
[05:58.080 --> 06:06.240]  случай... Да, Any. Значит, type это такой метод, который просто возвращает вам type id. Ну,
[06:06.240 --> 06:15.200]  можно написать name. Это вам выведет... Ну, вот это будет type id. Тот самый type id, который вернул
[06:15.200 --> 06:23.560]  у нас, когда мы виртуальное добро всякое обсуждали. У type id есть поле name? Ладно. Не поле, а метод.
[06:23.560 --> 06:28.520]  Собственно, это и, по сути, главный метод. Один из двух главных методов, который у него есть.
[06:28.520 --> 06:37.400]  Оператор равно и name. Все. Вот, можно спросить вот так. Какой тип сейчас? Ну, соответственно,
[06:37.400 --> 06:46.320]  можно вот это не писать, а можно, например, проверить, правда ли, что в any лежит string. Ну,
[06:46.320 --> 06:55.720]  можно написать. Правда ли, что a.type равно равно type id вот... Ну, что? Сд string. Ну, что-нибудь в
[06:55.720 --> 07:01.440]  таком стиле. То есть, вы можете проверить, правда ли, что там лежит тот тип, который вы хотите. Вот. И
[07:01.440 --> 07:10.640]  дальше вы можете скастовать к нему. Сейчас. Как скастовать к нему? Как взять тип type id какого-то
[07:10.640 --> 07:17.240]  объекта? В смысле, вот не any, а string. Да. Оператор type id. Это оператор такой встроенный. Мы о нем
[07:17.240 --> 07:21.520]  говорили, когда было виртуальное расследование. Мы о нем говорили в первое семестре, когда были
[07:21.520 --> 07:26.680]  виртуальные функции. Да. Ладно, видимо, в моей голове просто отразилось, что с невиртуальными
[07:26.680 --> 07:32.680]  классами это не работает. Это работает со всеми классами, но имеет смысл только для полиморфных.
[07:32.680 --> 07:39.440]  Ну, потому что для неполиморфных вы в compile time знаете тип. Ну да, понятно. Чем type id
[07:39.440 --> 07:46.280]  спрашивать. Вот. Но работает это со всеми. Но вот теперь еще у нас есть any, с которым это
[07:46.280 --> 07:56.200]  тоже работает. Ну и, спойлер, я по-прежнему... Ну, это все еще работает только для полиморфных.
[07:56.200 --> 08:04.800]  Просто там внутри полиморфизм просто спрятан. Виртуальные функции, на самом деле, внутри. Но
[08:04.800 --> 08:11.680]  сейчас увидите. Вот. Ну так вот. И еще есть сейчас функция. Это не оператор. И это даже не метод. AnyCast.
[08:11.680 --> 08:29.080]  AnyCast к типу T. Я могу сказать AnyCast std AnyCast. Все, вот у меня без std. AnyCast к std String.
[08:29.080 --> 08:50.320]  Вот a. Ну, сказать auto s. Ну вот так. Это будет значит строка. Ну, это будет копия строки. Вот. А можно
[08:50.320 --> 09:03.840]  ли? Не копировать. Нет. Скастовать его к его type. Нет. Блин. В смысле? Он знает свой type,
[09:03.840 --> 09:17.120]  но скастовать к нему нельзя. А, это логично. Конечно, это очень логично. Это попытка сделать
[09:17.120 --> 09:26.000]  питон, но в меру сил, так сказать. В меру сил. Ну вот. Можно не копировать. И тогда у вас есть метод...
[09:26.000 --> 09:32.680]  Ой, не метод, извините. Это все не методы. Это внешняя функция. AnyCast, которая возвращает вам...
[09:32.680 --> 09:45.200]  А, да, кстати. Есть еще. У AnyCast есть перегрузка, которая принимает AnyAmpersand. А можно вот так.
[09:45.200 --> 09:56.720]  Ну, тогда вы заберете просто из Any и его содержимое. Ну, все нормально. Вот, чтобы не копировать.
[09:56.720 --> 10:09.720]  Видимо, будет пустой объект. А, который там был. Вот. Да, там будет лежать... Что угодно. Не типизировано.
[10:09.720 --> 10:17.040]  Нет. Там будет лежать, я думаю, все еще тот же тип, просто пустой. Ну, вы мугнетесь как-нибудь.
[10:17.040 --> 10:24.440]  Да. Оттуда. Вот. Ну, можно не копировать, а можно сделать так. Можно сказать, что я хочу...
[10:24.440 --> 10:34.280]  Не знаю, почему. Почему-то нету AnyCast на ссылку. А, ну понятно. Потому что как исключение? Там как?
[10:34.280 --> 10:39.600]  А, нет. Не понятно, почему нет AnyCast на ссылку, честно говоря. Но есть AnyCast-показатель.
[10:39.600 --> 10:50.120]  Можно вот так сделать. И тут тогда, наверное... Ну, тогда тут лук присутствует. А зато можно написать
[10:50.120 --> 11:02.640]  AnyCast. Ну, то есть, я вот так вот делаю и получаю указатель на стринг. Вместо того, чтобы получить
[11:02.640 --> 11:06.840]  новую стринг. На ту стринг, да, которая там лежит.
[11:06.840 --> 11:14.960]  Зачем все равно передавать указатель на AnyCast? Ну, чтобы он отличал... Я вызываюсь.
[11:14.960 --> 11:21.400]  Так, может быть, в Any лежал ST-стринг звездочка. Когда я вызываюсь от указателя на Any, он понимает,
[11:21.400 --> 11:28.000]  что я хочу указатель на Т получить, а не сам Т. Так. Сейчас. Откуда он возьмет указатель на Т?
[11:28.480 --> 11:37.800]  Ну, у него же там Т хранится. А, ну да. Ну, указатель вернет. Еще. Так, все. Это короткий, значит, гайд,
[11:37.800 --> 11:45.760]  как пользоваться STD Any. А, ну да, эта штука бросает исключение Bad AnyCast, если там лежал не этот тип.
[11:45.760 --> 11:56.280]  Если что-то наследники, родители... Нет-нет. Не работает. С наследованием, сколько знаю, не поможет.
[11:56.280 --> 12:06.960]  Вот. Ну, все. Вот это все, как можно использовать STD Any. Ну, можно вектор из Any создать. Да.
[12:06.960 --> 12:14.160]  Понятно, что Any можно копировать, мувать. Вот. Как обычно, оператор присваивания у него есть.
[12:14.160 --> 12:19.440]  И будет вызываться просто оно у его типа, и все. Ну, да-да, он просто мувит.
[12:19.440 --> 12:28.880]  Не, а пункты... Вот AnyCast, STD, Stringer, Tempest, Sat. Вот звездочка вернул ноль. Хотя и не пустой, интересный.
[12:28.880 --> 12:29.880]  Чего?
[12:35.880 --> 12:37.880]  А ты не последний, кто это сделал? Нет.
[12:49.880 --> 13:03.880]  Ну, все. Должно быть, как я сказал, по идее. О, стоп. Он звездочка не бросает исключение, скажи. Или я прослушал.
[13:03.880 --> 13:08.880]  А, да, это правда. Звездочка не бросает исключение. Как стройный макад. Ну, понятно, да.
[13:08.880 --> 13:16.880]  Да, да, логично. То есть он просто либо нолпойнтер, если вы типа не отгадали, либо вернет просто.
[13:17.320 --> 13:19.320]  Может, тебе там лежит нейтрей?
[13:21.320 --> 13:29.320]  Я, честно говоря, что-то вот смотрю на это и не понимаю, почему-то все-таки нету ссылки. Не знаю.
[13:29.320 --> 13:37.320]  То есть мне почему-то казалось естественным, что должны быть ссылки. Понятно. Ну, фиксим.
[13:37.320 --> 13:45.320]  Ну, указать ему можно, по крайней мере. Так вот. Как это реализовано теперь? Нам надо понять.
[13:45.760 --> 13:52.760]  Что там внутри? Ну, вы уже... Я уже засполнил, что там. Там виртуальные функции.
[13:52.760 --> 13:57.760]  А давайте, может, вы придумаете сейчас, как это сделать.
[13:57.760 --> 14:05.760]  Идея красивая и такая прям... Ну, короче, прям вот красивая штука.
[14:06.200 --> 14:15.200]  Я, кстати, читал этот курс в первый раз лекции еще, когда это была весна 2019 года.
[14:15.200 --> 14:22.200]  Ну, когда впервые я постал лекциями. Вот я тоже рассказывал про ЭНИ.
[14:22.200 --> 14:30.200]  Но тогда я сам еще не знал, как оно реализовано. Ну, потому что это был C++17, и что-то я там затупил.
[14:30.640 --> 14:37.640]  Вот. И сходу не придумал. Ну, вот сейчас я предлагаю еще раз вместе подумать.
[14:37.640 --> 14:43.640]  То есть штука довольно красивая, если...
[14:43.640 --> 14:50.640]  Ну, так. Просто знаний имеющихся уже достаточно, чтобы это придумать.
[14:50.640 --> 14:55.640]  Надо придумать. Что нужно написать? Что должно быть внутри?
[14:56.080 --> 15:01.080]  Но самая проблема, главное, какая? Надо, когда мы меняем, вот когда мы так делаем,
[15:01.080 --> 15:04.080]  надо корректно уничтожить то, что лежало раньше.
[15:04.080 --> 15:07.080]  Нарушить что-то вроде указатели, ну, на функции деструктора.
[15:07.080 --> 15:14.080]  Вот да, да. И вот это вот как раз... Ну да, это проблема. А что именно там? Как это должно?
[15:14.080 --> 15:21.080]  Ну, мы уже чуть-чуть говорили про то, что там есть какой-то подкапот дополнительный, более тяжелый вес,
[15:21.520 --> 15:26.520]  который хрень кучит указателей, а на хрень мы контролируем его.
[15:26.520 --> 15:30.520]  Ну, сейчас Уэйни там, ну есть где-то еще...
[15:30.520 --> 15:33.520]  Представим себе, у нас есть вот какой-нибудь стринг, да?
[15:33.520 --> 15:38.520]  У него, конечно, нет таблицы виртуальных функций, но можно ее сделать.
[15:38.520 --> 15:41.520]  Просто таблицу функций стринга.
[15:41.520 --> 15:45.520]  Вот. И хранить указатели на этой таблице функций, и все.
[15:45.520 --> 15:49.520]  Как-то там к ней обращаться. Как ноль людей.
[15:51.520 --> 15:53.520]  Нельзя же унаследоваться от всех типов сразу.
[15:53.520 --> 16:00.520]  Да, вот проблема в том, что действительно нужно хранить какие-то внутри указатели на...
[16:00.520 --> 16:05.520]  Ну, на что? На типа... На деструктор, на...
[16:07.520 --> 16:12.520]  Если мы копируем 1A, то тоже нужно что-то вызвать правильное.
[16:12.520 --> 16:17.520]  Наверное, мы по меньшей мере храним какую-нибудь звездочку на сам объект.
[16:17.960 --> 16:20.960]  Ну...
[16:20.960 --> 16:21.960]  Плохо, конечно.
[16:21.960 --> 16:24.960]  Ну, например...
[16:24.960 --> 16:27.960]  Ну, не будет звездочку на самом деле, а кое-что другое.
[16:27.960 --> 16:30.960]  Вот, короче, да, смотрите, гениальная идея.
[16:30.960 --> 16:36.960]  Нам нужно где-то сохранить указатели на разные методы.
[16:36.960 --> 16:40.960]  И они динамически подменяться должны.
[16:40.960 --> 16:45.960]  Но если подумать, если так вот переосмыслить то, что мы знаем,
[16:46.400 --> 16:49.400]  вообще-то у нас уже есть языковой механизм, который это...
[16:49.400 --> 16:50.400]  Виртуальный функции?
[16:50.400 --> 16:51.400]  Конечно.
[16:51.400 --> 16:54.400]  В смысле, я сказал, у нас нету у стринга таблицы виртуальных функций.
[16:54.400 --> 16:56.400]  Если она была, мы могли просто на нее сослаться.
[16:56.400 --> 17:00.400]  Нам нужно что-то такое сделать, чтобы как-то...
[17:00.400 --> 17:04.400]  То есть не хочется это руками прям реализовывать, да и непонятно как, если честно.
[17:04.400 --> 17:05.400]  Ну да.
[17:05.400 --> 17:10.400]  Хочется как-то выразить через виртуальные функции вот эту идею,
[17:10.840 --> 17:13.840]  что нам нужно просто на произвольный тип навесить табли...
[17:13.840 --> 17:17.840]  Ну, добавить к нему таблицу типа виртуальных функций,
[17:17.840 --> 17:20.840]  которые будут говорить, что делать, если деструктор позвали,
[17:20.840 --> 17:23.840]  что делать, если то позвали, все позвали.
[17:23.840 --> 17:26.840]  Вот.
[17:26.840 --> 17:30.840]  В общем, идея гениальная, красивая и простая.
[17:30.840 --> 17:32.840]  Мы сейчас объявим...
[17:32.840 --> 17:34.840]  Шифронного наследника для каждого типа.
[17:34.840 --> 17:35.840]  Да!
[17:35.840 --> 17:37.840]  Серьезно?
[17:38.280 --> 17:41.280]  Мы сейчас, здесь внутри,
[17:41.280 --> 17:43.280]  во-первых, напишем такое.
[17:43.280 --> 17:46.280]  Ну, это все в приватной части я пишу.
[17:46.280 --> 17:50.280]  Ну, давайте я не буду думать над названием особо.
[17:50.280 --> 17:52.280]  Я назову просто StructBase.
[17:55.280 --> 18:00.280]  И эта структура, она будет особо-то ничего не...
[18:00.280 --> 18:02.280]  Она будет просто полиморфная.
[18:02.280 --> 18:05.280]  Все, что мне от нее надо пока, что это...
[18:05.720 --> 18:08.720]  Виртуальный деструктор, чтобы она полиморфной была.
[18:20.720 --> 18:23.720]  А теперь я скажу, что для каждого Т
[18:23.720 --> 18:26.720]  будет наследник этой штуки...
[18:26.720 --> 18:28.720]  Изя.
[18:28.720 --> 18:31.720]  Просто парень в чаши.
[18:32.160 --> 18:34.160]  Слышишь?
[18:40.160 --> 18:43.160]  Значит, у меня будет наследник этой штуки
[18:45.160 --> 18:48.160]  для каждого Т.
[18:48.160 --> 18:51.160]  И что будет в этом наследнике?
[18:51.160 --> 18:53.160]  Сейчас нас... Ага.
[18:56.160 --> 18:58.160]  Убираю деструктора.
[18:58.600 --> 19:00.600]  Т...
[19:00.600 --> 19:02.600]  Т и...
[19:02.600 --> 19:04.600]  Ну, типа на конструктор.
[19:04.600 --> 19:07.600]  На деструктор, на какие-нибудь еще функции.
[19:09.600 --> 19:12.600]  Ну, давайте подумаем, что нужно в наследнике.
[19:12.600 --> 19:15.600]  Давайте для начала просто вот без копирования,
[19:15.600 --> 19:18.600]  просто вот, чтобы мы могли...
[19:18.600 --> 19:21.600]  Ну, вот, чтобы тот код, который это это написал, работал.
[19:21.600 --> 19:23.600]  Чтобы мы могли один А и Н создать,
[19:23.600 --> 19:26.600]  присловить ему потом другой тип и так далее.
[19:28.600 --> 19:30.600]  Сейчас.
[19:32.600 --> 19:36.600]  У нас что-то среднее между лекцией семинаров,
[19:36.600 --> 19:39.600]  ближе к семинару, кажется, вот, но...
[19:39.600 --> 19:42.600]  Ну, тут реально вот прикольно.
[19:42.600 --> 19:45.600]  Это, скорее, такая задача.
[19:45.600 --> 19:48.600]  Нам точно нужно виррайт деструктора, давайте так.
[19:48.600 --> 19:50.600]  Ну, да.
[19:50.600 --> 19:53.600]  Ну, деструкторы, там не пишется overwrite,
[19:53.600 --> 19:55.600]  они просто...
[19:55.600 --> 19:57.600]  Нужно сохранить объект типа Т.
[19:58.040 --> 20:00.040]  Мы же не его наследник.
[20:00.040 --> 20:02.040]  Начнем с того, что где-то хранить само Т надо.
[20:02.040 --> 20:03.040]  Вот здесь.
[20:03.040 --> 20:05.040]  Вот здесь самое место, да.
[20:05.040 --> 20:08.040]  Вот прямо тут мы и сохраним его.
[20:11.040 --> 20:13.040]  Мы же от него не наследовались.
[20:13.040 --> 20:15.040]  Так.
[20:19.040 --> 20:22.040]  А что мы будем, собственно, в полях хранить?
[20:23.040 --> 20:25.040]  Amy.
[20:25.040 --> 20:26.040]  Давайте поймем.
[20:26.480 --> 20:28.480]  Вот я не знаю, здесь где-нибудь...
[20:28.480 --> 20:30.480]  Блин, плохо я, конечно, доскуюсь больше.
[20:30.480 --> 20:32.480]  Ну, давайте вот здесь...
[20:32.480 --> 20:34.480]  Указатель на base.
[20:35.480 --> 20:38.480]  Да, вот тут, короче, будет продолжение кода класса Amy.
[20:39.480 --> 20:41.480]  Вот в полях у меня будет...
[20:41.480 --> 20:43.480]  Ну, вот, продолжаем.
[20:43.480 --> 20:45.480]  Класс Amy.
[20:47.480 --> 20:49.480]  Тут будет указатель на base.
[20:50.480 --> 20:51.480]  Ну, не знаю.
[20:51.480 --> 20:53.480]  Не буду думать именно названиями.
[20:53.480 --> 20:55.480]  Ptr.
[20:55.920 --> 20:57.920]  Это в derived или нет?
[20:57.920 --> 20:59.920]  Это в Amy.
[20:59.920 --> 21:01.920]  Вот это класс Amy.
[21:01.920 --> 21:03.920]  Да, но вот в нем сначала есть две такие структуры.
[21:03.920 --> 21:05.920]  Я пока что-то не знаю.
[21:05.920 --> 21:08.920]  Там продолжение derived, а там продолжение Amy.
[21:08.920 --> 21:10.920]  Да, что в derived мы дописать должны?
[21:10.920 --> 21:12.920]  Сейчас мы подумаем.
[21:12.920 --> 21:14.920]  Давайте для этого сначала подумать, что в Amy, собственно, будет происходить.
[21:14.920 --> 21:16.920]  У нас есть указатель на base.
[21:18.920 --> 21:20.920]  Ну, как будет выглядеть, например, указатель на...
[21:22.920 --> 21:24.920]  Не указатель, как будет выглядеть конструктор.
[21:25.360 --> 21:27.360]  Amy.
[21:28.360 --> 21:30.360]  Вот мне говорят...
[21:30.360 --> 21:32.360]  Шаблонный конструктор, чего угодно.
[21:32.360 --> 21:34.360]  Да, template type name T.
[21:36.360 --> 21:38.360]  Amy.
[21:38.360 --> 21:40.360]  От...
[21:40.360 --> 21:42.360]  Ну, давайте скажем const temperson.
[21:42.360 --> 21:44.360]  Value.
[21:46.360 --> 21:48.360]  Что нужно сделать?
[21:48.360 --> 21:50.360]  Ну, зря рано я скобку открыл.
[21:50.360 --> 21:52.360]  Нужно две точки.
[21:52.360 --> 21:54.360]  Создать объект типа derivedT.
[21:54.800 --> 21:56.800]  Чем проинициализировать поле мое?
[21:56.800 --> 21:58.800]  Ну, да, объект типа derivedT.
[22:00.800 --> 22:02.800]  Проинициализировать чем?
[22:02.800 --> 22:04.800]  New.
[22:04.800 --> 22:06.800]  New?
[22:06.800 --> 22:08.800]  О, господи, нет, только не new.
[22:08.800 --> 22:10.800]  Нет, аллокаторов не будет.
[22:10.800 --> 22:12.800]  Спасибо большое.
[22:14.800 --> 22:16.800]  В этот раз аллокаторов не будет.
[22:16.800 --> 22:18.800]  А в Amy нет аллокаторов.
[22:18.800 --> 22:20.800]  В Amy нет аллокаторов.
[22:21.240 --> 22:23.240]  Да, на самом деле
[22:23.240 --> 22:25.240]  комитет
[22:25.240 --> 22:27.240]  к 2017 году
[22:27.240 --> 22:29.240]  начал подозревать, что
[22:29.240 --> 22:31.240]  пихать аллокаторов в всюду
[22:31.240 --> 22:33.240]  кажется, было не очень хорошей идеей.
[22:33.240 --> 22:35.240]  И в Amy они уже не стали.
[22:35.240 --> 22:37.240]  Долго ожидали.
[22:37.240 --> 22:39.240]  Не подходило, это правда.
[22:39.240 --> 22:41.240]  Но, потому что
[22:41.240 --> 22:43.240]  все равно
[22:43.240 --> 22:45.240]  ну, короче, они поняли, что
[22:45.240 --> 22:47.240]  использовать аллокаторы не всегда удобно.
[22:47.240 --> 22:49.240]  Они даже придумали полиморфику аллокаторов.
[22:49.240 --> 22:51.240]  Как вы помните.
[22:51.240 --> 22:53.240]  Вот, new derived
[22:53.240 --> 22:55.240]  от
[22:55.240 --> 22:57.240]  t?
[22:57.240 --> 22:59.240]  Нет, не от.
[22:59.240 --> 23:01.240]  Или он сам подставит?
[23:01.240 --> 23:03.240]  Derived t.
[23:03.240 --> 23:05.240]  А, new derived, ну
[23:05.240 --> 23:07.240]  да, можно во-первых
[23:07.240 --> 23:09.240]  я забыл шаблонный параметр.
[23:09.240 --> 23:11.240]  New derived с шаблонным параметром t,
[23:11.240 --> 23:13.240]  но я думаю, что
[23:13.240 --> 23:15.240]  в сети AD
[23:15.240 --> 23:17.240]  здесь есть.
[23:17.240 --> 23:19.240]  Вот.
[23:19.240 --> 23:21.240]  Да и, в общем-то
[23:21.240 --> 23:23.240]  все.
[23:23.240 --> 23:25.240]  Конструктор мы написали.
[23:25.240 --> 23:27.240]  Объект готов.
[23:29.240 --> 23:31.240]  Вот.
[23:31.240 --> 23:33.240]  Ну и давайте, как будет выглядеть,
[23:33.240 --> 23:35.240]  вот в чем мы пользовались.
[23:35.240 --> 23:37.240]  Расписываемся, оно страшное, потому что
[23:37.240 --> 23:39.240]  нужно деструктор вызывать.
[23:39.240 --> 23:41.240]  Ну деструктор там, ну да.
[23:41.240 --> 23:43.240]  У нас его еще нет.
[23:43.240 --> 23:45.240]  Значит, тем не менее,
[23:45.240 --> 23:47.240]  темплей
[23:47.240 --> 23:49.240]  опять type name
[23:51.240 --> 23:53.240]  type name
[23:53.240 --> 23:55.240]  t
[23:57.240 --> 23:59.240]  any
[23:59.240 --> 24:01.240]  апператор равно
[24:03.240 --> 24:05.240]  от конст
[24:05.240 --> 24:07.240]  t
[24:07.240 --> 24:09.240]  Она хорошая,
[24:09.240 --> 24:11.240]  типа от t
[24:11.240 --> 24:13.240]  2 амперсанта.
[24:13.240 --> 24:15.240]  5 2 амперсанта.
[24:15.240 --> 24:17.240]  И ты не можешь сделать здесь так.
[24:17.240 --> 24:19.240]  Говорите, пожалуйста.
[24:19.240 --> 24:21.240]  Это не будет универсальная ссылка.
[24:21.240 --> 24:23.240]  Вот, у слова амперсант последняя буква d.
[24:23.240 --> 24:25.240]  Давайте будем говорить амперсант да,
[24:25.240 --> 24:27.240]  а не амперсант так.
[24:27.240 --> 24:29.240]  Меня бесило.
[24:29.240 --> 24:31.240]  Короче, говорите правильно.
[24:31.240 --> 24:33.240]  Я не знаю, кстати,
[24:33.240 --> 24:35.240]  почему все говорят амперсант.
[24:35.240 --> 24:37.240]  Я не знаю.
[24:37.240 --> 24:39.240]  Я не понимаю, почему.
[24:39.240 --> 24:41.240]  Надо сделать паузу перед d, чтобы
[24:41.240 --> 24:43.240]  сделать 2 амперсанта.
[24:43.240 --> 24:45.240]  Ладно.
[24:45.240 --> 24:47.240]  Все хорошо.
[24:47.240 --> 24:49.240]  Короче, нет.
[24:49.240 --> 24:51.240]  Чего вы говорили
[24:51.240 --> 24:53.240]  про 2 амперсанта?
[24:53.240 --> 24:55.240]  Мы же должны уметь делать
[24:55.240 --> 24:57.240]  конструктор от std move
[24:57.240 --> 24:59.240]  потом.
[24:59.240 --> 25:01.240]  Понятно, что нужно еще
[25:01.240 --> 25:03.240]  версию для 2 амперсанта.
[25:03.240 --> 25:05.240]  Это все ясно.
[25:05.240 --> 25:07.240]  Кстати,
[25:07.240 --> 25:09.240]  вы же понимаете, да,
[25:09.240 --> 25:11.240]  что проблема. Если мы сделаем конструктор
[25:11.240 --> 25:13.240]  n от t2d на амперсанта,
[25:13.240 --> 25:15.240]  это будет универсальная ссылка.
[25:15.240 --> 25:17.240]  Будет ли?
[25:17.240 --> 25:19.240]  Конечно.
[25:19.240 --> 25:21.240]  Но он же не ARKS.
[25:21.240 --> 25:23.240]  Он же не ARKS.
[25:23.240 --> 25:25.240]  А мы тогда сможем
[25:25.240 --> 25:27.240]  передавать этот форум
[25:27.240 --> 25:29.240]  на твоей лифте?
[25:29.240 --> 25:31.240]  Ну, сможем.
[25:31.240 --> 25:33.240]  Ну, короче, слушайте, это детали.
[25:33.240 --> 25:35.240]  Это уже упражнение.
[25:35.240 --> 25:37.240]  Реализовать оставшиеся методы
[25:37.240 --> 25:39.240]  это, в общем...
[25:39.240 --> 25:41.240]  Ну, понятно, да, что нужно еще
[25:41.240 --> 25:43.240]  от move, от RBL
[25:43.240 --> 25:45.240]  правильно сконструироваться уметь.
[25:45.240 --> 25:47.240]  Нет, это будет универсальная ссылка, если ты...
[25:47.240 --> 25:49.240]  Ладно.
[25:49.240 --> 25:51.240]  Ты думал, универсальная ссылка будет только то,
[25:51.240 --> 25:53.240]  как это многоточие бывает? Нет, конечно.
[25:53.240 --> 25:55.240]  Нет, такого я не говорю.
[25:55.240 --> 25:57.240]  Так вот, а что здесь сделать надо?
[25:57.240 --> 25:59.240]  А может, сначала деструктор напишем?
[25:59.240 --> 26:01.240]  Ты сам сказал сначала
[26:01.240 --> 26:03.240]  оператор присваивания. Давай уж оператор присваивания тогда.
[26:03.240 --> 26:05.240]  Вызываем деструктор.
[26:05.240 --> 26:07.240]  Нет, деструктор чего?
[26:07.240 --> 26:09.240]  Ну, не себя, а деструктор T.
[26:09.240 --> 26:11.240]  Как это нужно вызвать сейчас?
[26:11.240 --> 26:13.240]  Ну, мы не можем пока что.
[26:13.240 --> 26:15.240]  Нужно дописать бейс.
[26:15.240 --> 26:17.240]  Да, что же делать?
[26:17.240 --> 26:19.240]  Давайте приопределим
[26:19.240 --> 26:21.240]  деструктор derived. Это же тривиальная штука.
[26:23.240 --> 26:25.240]  Tilde derived,
[26:25.240 --> 26:27.240]  overwrite, что там.
[26:27.240 --> 26:29.240]  Вызываем деструктор, его T,
[26:29.240 --> 26:31.240]  и все.
[26:31.240 --> 26:33.240]  Что?
[26:33.240 --> 26:35.240]  Ну, давайте
[26:35.240 --> 26:37.240]  у derived переопределим деструктор.
[26:37.240 --> 26:39.240]  Или оно уже нормально?
[26:39.240 --> 26:41.240]  Если ты у derived в деструкторе
[26:41.240 --> 26:43.240]  напишешь вызвать деструктор этого,
[26:43.240 --> 26:45.240]  то
[26:45.240 --> 26:47.240]  что будет происходить?
[26:47.240 --> 26:49.240]  А, у него уже есть
[26:49.240 --> 26:51.240]  по умолчанию. Все хорошо.
[26:51.240 --> 26:53.240]  Можно просто вызвать его.
[26:53.240 --> 26:55.240]  Какого вызвать?
[26:55.240 --> 26:57.240]  Ну, точка.
[26:57.240 --> 26:59.240]  Явно.
[26:59.240 --> 27:01.240]  И диалатировать потом еще надо.
[27:01.240 --> 27:03.240]  Господи, зачем?
[27:03.240 --> 27:05.240]  Delete просто давайте сделаем.
[27:05.240 --> 27:07.240]  Тупой я просто.
[27:07.240 --> 27:09.240]  Я путаю деструктор и delete. Простите меня, пожалуйста.
[27:09.240 --> 27:11.240]  Я не делал первую задачу для основы,
[27:11.240 --> 27:13.240]  которая была на это, и все.
[27:13.240 --> 27:15.240]  С тех пор. Прочек.
[27:15.240 --> 27:17.240]  Что за первая задача для основы?
[27:17.240 --> 27:19.240]  Самая первая задача. У нас была string,
[27:19.240 --> 27:21.240]  а у них была еще что-то.
[27:21.240 --> 27:23.240]  Я понял, да.
[27:23.240 --> 27:25.240]  New, delete. Я их пропустил, все.
[27:25.240 --> 27:27.240]  Для основы.
[27:27.240 --> 27:29.240]  Когда не было, это просто
[27:29.240 --> 27:31.240]  так сказать, чтобы люди
[27:31.240 --> 27:33.240]  получше освоились, а то обычно люди
[27:33.240 --> 27:35.240]  не освоятся, но
[27:35.240 --> 27:37.240]  я не освоил.
[27:37.240 --> 27:39.240]  Delete, ptr. А почему это корректно будет?
[27:39.240 --> 27:41.240]  А потому что он вызовет что?
[27:41.240 --> 27:43.240]  Что он сделает?
[27:43.240 --> 27:45.240]  У нас же был уже delete
[27:45.240 --> 27:47.240]  с абстрактными,
[27:47.240 --> 27:49.240]  господи, с виртуальными классами.
[27:49.240 --> 27:51.240]  Поскольку это полиморфный тип,
[27:51.240 --> 27:53.240]  благодаря тому, что
[27:53.240 --> 27:55.240]  виртуальный деструктор, когда мы сделаем
[27:55.240 --> 27:57.240]  delete этой штуки,
[27:57.240 --> 27:59.240]  он правильно уничтожит объект.
[27:59.240 --> 28:01.240]  Он правильно вызовет
[28:01.240 --> 28:03.240]  деструктор, он вызовет деструктор именно
[28:03.240 --> 28:05.240]  той штуки, которую надо.
[28:05.240 --> 28:07.240]  Но вопрос, от этого в какой момент уничтожится?
[28:07.240 --> 28:09.240]  Когда вызывается деструктор derived, у него уже
[28:09.240 --> 28:11.240]  поле есть t, значит,
[28:11.240 --> 28:13.240]  угадаются все поля объектов.
[28:13.240 --> 28:15.240]  Но на самом деле сначала отрабатывает код
[28:15.240 --> 28:17.240]  деструктора derived, который нет.
[28:17.240 --> 28:19.240]  А потом
[28:19.240 --> 28:21.240]  уничтожаются поля derived,
[28:21.240 --> 28:23.240]  ну то есть это все
[28:23.240 --> 28:25.240]  у нас компилятор делает.
[28:25.240 --> 28:27.240]  А потом вызывает деструктор based,
[28:27.240 --> 28:29.240]  уничтожается поля based,
[28:29.240 --> 28:31.240]  и диалацируется память тоже в
[28:31.240 --> 28:33.240]  правильном количестве.
[28:33.240 --> 28:35.240]  Просто вала.
[28:37.240 --> 28:39.240]  Классно.
[28:39.240 --> 28:41.240]  А теперь, в общем-то,
[28:41.240 --> 28:43.240]  PTR, можно сказать, PTR равно
[28:47.240 --> 28:51.240]  Сейчас бы явно деструктор
[28:51.240 --> 28:55.240]  отвел ее.
[28:55.240 --> 28:57.240]  Все.
[28:57.240 --> 28:59.240]  Кайф.
[28:59.240 --> 29:01.240]  Ну, деструктор это просто delete PTR, кажется.
[29:03.240 --> 29:05.240]  А че
[29:05.240 --> 29:07.240]  в derived нам вообще больше ничего не надо, что ли?
[29:07.240 --> 29:09.240]  Или как?
[29:09.240 --> 29:11.240]  Пока выглядит как будто да.
[29:11.240 --> 29:13.240]  Ну конструктора нет пока.
[29:15.240 --> 29:17.240]  Да, нету конструктора.
[29:17.240 --> 29:19.240]  Ой.
[29:19.240 --> 29:21.240]  Ну давайте скажем, что конструктор
[29:21.240 --> 29:23.240]  ну конструктор триреальный.
[29:23.240 --> 29:25.240]  Биз не будем возвращать?
[29:25.240 --> 29:27.240]  Где?
[29:27.240 --> 29:29.240]  А.
[29:29.240 --> 29:31.240]  Ну конструктор тут понятно.
[29:43.240 --> 29:45.240]  Кстати,
[29:45.240 --> 29:47.240]  с какого
[29:47.240 --> 29:49.240]  с каких плюсов у нас вообще есть виртуальная функция
[29:49.240 --> 29:51.240]  вообще такая?
[29:51.240 --> 29:53.240]  Прямо с рождения. С третьих.
[29:53.240 --> 29:55.240]  Нет, третьи это не первая, это начальная версия.
[29:55.240 --> 29:57.240]  99-й, 98-й.
[29:57.240 --> 29:59.240]  Ну,
[29:59.240 --> 30:01.240]  в 98-м они уже были,
[30:01.240 --> 30:03.240]  но даже 98-й это не начальная
[30:03.240 --> 30:05.240]  версия. Круто.
[30:05.240 --> 30:07.240]  Там была еще какая-то суп супер древняя, 80-я какая-то.
[30:07.240 --> 30:09.240]  Круто. А когда плюсов было?
[30:09.240 --> 30:11.240]  Тоже очень давно.
[30:11.240 --> 30:13.240]  Ну, короче,
[30:13.240 --> 30:15.240]  скорее всего раньше, чем мы все родились,
[30:15.240 --> 30:17.240]  поэтому, я не знаю, когда.
[30:17.240 --> 30:19.240]  До исторической эпохи.
[30:21.240 --> 30:23.240]  Отчета, отчитывая время
[30:23.240 --> 30:25.240]  от моего дня рождения.
[30:25.240 --> 30:27.240]  Да.
[30:27.240 --> 30:29.240]  Сеологично абсолютно.
[30:29.240 --> 30:31.240]  Да, это до исторической эпохи считается.
[30:35.240 --> 30:37.240]  Так, хорошо.
[30:37.240 --> 30:39.240]  Чего не хватает еще?
[30:41.240 --> 30:43.240]  А в деструкторе нам ничего не надо написать?
[30:43.240 --> 30:45.240]  Мы не написали.
[30:45.240 --> 30:47.240]  В 103 дирает зачем?
[30:47.240 --> 30:49.240]  Да.
[30:49.240 --> 30:51.240]  Они ж все обвертки вроде просто.
[30:51.240 --> 30:53.240]  Никчемные.
[30:57.240 --> 30:59.240]  Сейчас, если мы ничего не напишем
[30:59.240 --> 31:01.240]  в деструкторе.
[31:01.240 --> 31:03.240]  Но он будет дефолтный.
[31:03.240 --> 31:05.240]  Ну да, скорее всего будет нормально.
[31:05.240 --> 31:07.240]  Можно написать просто, что он
[31:07.240 --> 31:09.240]  дефолтный, наверное.
[31:09.240 --> 31:11.240]  Подстраховаться
[31:11.240 --> 31:13.240]  точно не будет.
[31:19.240 --> 31:21.240]  Ну, давайте теперь поймем, как копирование
[31:21.240 --> 31:23.240]  устроено.
[31:23.240 --> 31:25.240]  Вот тут, на самом деле, чуть похитрее
[31:25.240 --> 31:27.240]  надо сделать. Вот здесь,
[31:27.240 --> 31:29.240]  если ты совпал с тем, который у нас,
[31:29.240 --> 31:31.240]  то не надо заново создавать.
[31:31.240 --> 31:33.240]  Надо просто копировать старый.
[31:33.240 --> 31:35.240]  Ну, надо присваивать, присвоить.
[31:35.240 --> 31:37.240]  Я не играю тутом.
[31:37.240 --> 31:39.240]  Вообще, по идее.
[31:39.240 --> 31:41.240]  Это ладно.
[31:41.240 --> 31:43.240]  Это чуть более хитрая история.
[31:43.240 --> 31:45.240]  Как копировать Эни?
[31:45.240 --> 31:47.240]  Вот как будет выглядеть конструктор
[31:47.240 --> 31:49.240]  копирования Эни?
[31:49.240 --> 31:51.240]  Эни
[31:51.240 --> 31:53.240]  от конст Эни Амперсан.
[31:59.240 --> 32:01.240]  Что тут должно произойти?
[32:03.240 --> 32:05.240]  ПТР проницилизировать надо чем?
[32:09.240 --> 32:11.240]  Это отличный вопрос.
[32:11.240 --> 32:13.240]  Когда-то это было вопросом
[32:13.240 --> 32:15.240]  на отел 10 на экзамен,
[32:15.240 --> 32:17.240]  а теперь это будет вопросом, скорее всего,
[32:17.240 --> 32:19.240]  на какой-нибудь хор.
[32:19.240 --> 32:21.240]  Времена меняются, да.
[32:21.240 --> 32:23.240]  Инфляция, ценок.
[32:23.240 --> 32:25.240]  Во-первых, да, во-вторых,
[32:25.240 --> 32:27.240]  то, что 5 лет назад еще никто
[32:27.240 --> 32:29.240]  в мире не знал, сейчас
[32:29.240 --> 32:31.240]  постепенно становятся общей практикой,
[32:31.240 --> 32:33.240]  как надо писать, поэтому неудивительно.
[32:33.240 --> 32:35.240]  Теперь в 20
[32:35.240 --> 32:37.240]  уже изобретали такого, что 5 лет назад
[32:37.240 --> 32:39.240]  никто не подозревал, что такое.
[32:39.240 --> 32:41.240]  Кто-то может придумать.
[32:41.240 --> 32:43.240]  Опять, нам нужно менять
[32:43.240 --> 32:45.240]  утирайф оттэ, не знаем, какой у нас тэ.
[32:45.240 --> 32:47.240]  Да.
[32:47.240 --> 32:49.240]  Давайте Вене, что ли,
[32:49.240 --> 32:51.240]  утирайф хранить
[32:51.240 --> 32:53.240]  оттэ или юзинг.
[32:53.240 --> 32:55.240]  Ну хотя бы что-нибудь.
[32:55.240 --> 32:57.240]  Юзинг оттэ.
[32:57.240 --> 32:59.240]  И что?
[32:59.240 --> 33:01.240]  Мы же не можем менять юзинги.
[33:01.240 --> 33:03.240]  Нет, подожди, а как ты
[33:03.240 --> 33:05.240]  ПТР сконструируешь, от чего?
[33:05.240 --> 33:07.240]  От чего?
[33:07.240 --> 33:09.240]  Погнали, короче, в точку копии
[33:09.240 --> 33:11.240]  сделаем функцию.
[33:11.240 --> 33:13.240]  Нас учили на этой
[33:13.240 --> 33:15.240]  давайте втирайф
[33:15.240 --> 33:17.240]  и объявим функцию.
[33:17.240 --> 33:19.240]  Где вас учили? На ТПшке.
[33:19.240 --> 33:21.240]  Паттерн такой.
[33:25.240 --> 33:27.240]  Что-то там, кто-то там,
[33:27.240 --> 33:29.240]  что-то там.
[33:29.240 --> 33:31.240]  То, что втирайф, это функция,
[33:31.240 --> 33:33.240]  которая будет сообщать указанного утирайфа.
[33:33.240 --> 33:35.240]  Уважаемо, уважаемо.
[33:35.240 --> 33:37.240]  Ура! Хор! Сколько?
[33:37.240 --> 33:39.240]  Пять? Но учили, да.
[33:39.240 --> 33:41.240]  Блин, это же сильно.
[33:41.240 --> 33:43.240]  Надо было не говорить, что нас к тому учили.
[33:43.240 --> 33:45.240]  Он бы таким умным меня считал.
[33:45.240 --> 33:47.240]  Да, вот, короче,
[33:47.240 --> 33:49.240]  здесь нужно функцию кофе сделать.
[33:49.240 --> 33:51.240]  Которая возвращает,
[33:51.240 --> 33:53.240]  типа, бейз, звездочка и нормально.
[33:53.240 --> 33:55.240]  Или может со... Щас.
[33:55.240 --> 33:57.240]  Может ли у виртуальных методов
[33:57.240 --> 33:59.240]  быть разный возвращаемый тип?
[33:59.240 --> 34:01.240]  Вроде нет, поэтому бейз, звездочка
[34:01.240 --> 34:03.240]  и нормально.
[34:03.240 --> 34:05.240]  Нам надо, чтобы она была виртуальной.
[34:05.240 --> 34:07.240]  Ну да, понятно.
[34:17.240 --> 34:19.240]  И здесь она будет равна нулю.
[34:21.240 --> 34:23.240]  Ну или что-нибудь бросать будет,
[34:23.240 --> 34:25.240]  ну неважно. А тут
[34:27.240 --> 34:29.240]  значит, бейз, звездочка
[34:31.240 --> 34:33.240]  копия.
[34:33.240 --> 34:35.240]  Override?
[34:39.240 --> 34:41.240]  Наверное, конст. Везде.
[34:41.240 --> 34:43.240]  Ну да.
[34:49.240 --> 34:51.240]  Еще no accept, наверное.
[34:51.240 --> 34:53.240]  Почему? Нет.
[34:53.240 --> 34:55.240]  Ну no accept здесь нет, потому что new везде вызывается.
[34:55.240 --> 34:57.240]  Кстати, что насчет exception safety?
[34:57.240 --> 34:59.240]  Ничего.
[34:59.240 --> 35:01.240]  Ну в общем, да.
[35:01.240 --> 35:03.240]  Исключаем исключения.
[35:03.240 --> 35:05.240]  Ничего.
[35:05.240 --> 35:07.240]  Ну и что здесь надо сделать?
[35:07.240 --> 35:09.240]  Return.
[35:09.240 --> 35:11.240]  Да просто я скажу, return new.
[35:13.240 --> 35:15.240]  Derive от T.
[35:21.240 --> 35:23.240]  От...
[35:23.240 --> 35:25.240]  Ну, можно сказать, от object вот нашего,
[35:25.240 --> 35:27.240]  а можно сказать от vis.
[35:27.240 --> 35:29.240]  Короче, просто...
[35:29.240 --> 35:31.240]  А vis можно?
[35:31.240 --> 35:33.240]  Ну конструктор кофирования derived,
[35:33.240 --> 35:35.240]  ну почему бы нам не написать?
[35:35.240 --> 35:37.240]  Ну и тут мы про... да, и все.
[35:37.240 --> 35:39.240]  А тут мы просто, значит,
[35:39.240 --> 35:41.240]  говорим, что PTR мы имитализируем.
[35:45.240 --> 35:47.240]  Значит, PTR, стрелочка, копия.
[35:47.240 --> 35:49.240]  Ой.
[35:49.240 --> 35:51.240]  ADAC PTR, стрелочка, копия, да.
[35:53.240 --> 35:55.240]  Ну там, понятно, надо проверить,
[35:55.240 --> 35:57.240]  что ничего не...
[35:59.240 --> 36:01.240]  что это не NALPTR,
[36:01.240 --> 36:03.240]  там, ну короче, понятно.
[36:05.240 --> 36:07.240]  Тут не other.ptr.
[36:09.240 --> 36:11.240]  Other.ptr, правда.
[36:19.240 --> 36:21.240]  Да, ну вот и все.
[36:21.240 --> 36:23.240]  По сути, реализовали.
[36:23.240 --> 36:25.240]  Ну, понятно, что во-первых,
[36:25.240 --> 36:27.240]  нужно проверки на NALPTR делать,
[36:27.240 --> 36:29.240]  во-вторых, нужно там
[36:29.240 --> 36:31.240]  что-то про exception подумать,
[36:31.240 --> 36:33.240]  в-третьих, нужно для MOV
[36:33.240 --> 36:35.240]  сделать правильные версии, то есть
[36:35.240 --> 36:37.240]  правильную перегрузку
[36:37.240 --> 36:39.240]  сделать в случае, когда RwL
[36:39.240 --> 36:41.240]  передали, и тут для RwL что-нибудь сделать,
[36:41.240 --> 36:43.240]  типа MOV. Ну, это все
[36:43.240 --> 36:45.240]  упражнение. Для...
[36:45.240 --> 36:47.240]  не знаю. Ну, вы можете считать, что
[36:47.240 --> 36:49.240]  упражнение NALPTR какое-то будет.
[36:49.240 --> 36:51.240]  Ну, как одна из задач на экзамене,
[36:51.240 --> 36:53.240]  вполне можно быть...
[36:53.240 --> 36:55.240]  напишите там
[36:55.240 --> 36:57.240]  any... реализацию
[36:57.240 --> 36:59.240]  как бы вы сделали там
[36:59.240 --> 37:01.240]  не знаю.
[37:01.240 --> 37:03.240]  Вот.
[37:03.240 --> 37:05.240]  Ладно, это any.
[37:05.240 --> 37:07.240]  Теперь классно,
[37:07.240 --> 37:09.240]  вот этот вот, вот этот вот вот
[37:09.240 --> 37:11.240]  вот это идиом называется type erasure.
[37:11.240 --> 37:13.240]  Значит, в чем конкретно
[37:13.240 --> 37:15.240]  заключается? Что мы делаем вот такую вот
[37:15.240 --> 37:17.240]  штуку,
[37:17.240 --> 37:19.240]  У нас есть база
[37:22.040 --> 37:25.040]  И шаблонный наследник для любого tr
[37:26.240 --> 37:37.240]  И на этом же, в принципе, основанная реализация будет еще как минимум двух классов, которые мы с вами разберем
[37:37.240 --> 37:41.240]  Это, во-первых, широту tr, которую вам, собственно, и надо написать будет
[37:41.240 --> 37:47.240]  Илья, а почему мы не хотели сделать оператор tr вот здесь вот?
[37:50.240 --> 37:51.240]  Зачем?
[37:51.240 --> 37:55.240]  Ну, у нас чтобы можно было неярно конструктировать tr
[37:57.240 --> 37:58.240]  А где это надо?
[37:58.240 --> 38:01.240]  Ну вот, у нас там были проблемы с тем, что мы всегда должны были знать, к чему костовать
[38:02.240 --> 38:04.240]  Почему бы не знать, к чему костовать?
[38:05.240 --> 38:06.240]  Так, еще раз
[38:06.240 --> 38:10.240]  Ты хочешь удираем, да, определить t, оператор t
[38:12.240 --> 38:14.240]  И где тебе это поможет?
[38:15.240 --> 38:17.240]  О, Гостон не будет виртуальным, может отстой
[38:17.240 --> 38:19.240]  Да, все логично, нормально, все отлично, все
[38:21.240 --> 38:22.240]  Так вот, возвращаемся
[38:22.240 --> 38:26.240]  Так вот, у нас есть еще как минимум два класса, где нам это пригодится
[38:26.240 --> 38:30.240]  Один из них широта tr, а другой из них это что?
[38:31.240 --> 38:32.240]  В прошлый раз мы это обсуждали
[38:33.240 --> 38:34.240]  Function
[38:34.240 --> 38:36.240]  Function точно в таком же принципе реализован
[38:37.240 --> 38:40.240]  Ну, на самом деле Function реализован чуть хитрее
[38:41.240 --> 38:46.240]  Там сделаны хитрые странные оптимизации, чтобы с виртуальными функциями не работать
[38:47.240 --> 38:48.240]  Так можно меньше работать?
[38:48.240 --> 38:49.240]  Или вообще не работать?
[38:49.240 --> 38:50.240]  Вообще не работать
[38:50.240 --> 38:51.240]  Господи
[38:52.240 --> 38:58.240]  Ну, наверное, как реализована Function мы с вами разберем завтра
[38:59.240 --> 39:05.240]  А сейчас мы поговорим о том, как все-таки реализовать shared ptr, вот тот самый многострадальный
[39:06.240 --> 39:10.240]  Чтобы в нем и делитер был кастомный, и аллокатор был кастомный
[39:14.240 --> 39:16.240]  Для этого нам потребуется вертальная функция
[39:17.240 --> 39:20.240]  Вот в shared ptr, в реальном, востоянном shared ptr
[39:21.240 --> 39:28.240]  Ну, если вы просто откроете код реализации shared ptr, то вы там, с удивлением, найдете слово virtual в нескольких местах
[39:29.240 --> 39:31.240]  Потому что он использует вот эту вот штуку
[39:32.240 --> 39:34.240]  Но там черт ногу сломает, невозможно понять, что написано
[39:35.240 --> 39:36.240]  Потому что там...
[39:37.240 --> 39:38.240]  А вы еще нас за код ставите
[39:39.240 --> 39:44.240]  Ну, в общем, там весьма интересная есть оптимизация
[39:45.240 --> 39:58.240]  Вот, но если внимательно вчитаться, то за огромным слоем дополнительных каких-то оптимизаций и всяких проверок
[39:59.240 --> 40:04.240]  Скрыта вот эта идея, что у нас есть база, а есть верет
[40:05.240 --> 40:09.240]  Так вот, у нас shared ptr хотелось бы, чтобы умел конструироваться
[40:09.240 --> 40:15.240]  Да, нам хотелось бы, чтобы наш shared ptr, значит, это будет параграф 14.2 у нас
[40:16.240 --> 40:30.240]  shared ptr с кастомным дилитером и аллокатором
[40:30.240 --> 40:34.240]  Ну, что такое кастомный дилитер? Ну, я вроде уже рассказывал
[40:35.240 --> 40:38.240]  Давайте для начала с кастомным дилитером разберемся
[40:39.240 --> 40:41.240]  У нас есть контролл блок
[40:44.240 --> 40:52.240]  Ну, так, давайте опять же еще упростим сначала и скажем, что у нас пока нет вот этой возниз моей шефов
[40:52.240 --> 40:59.240]  Давайте считать, что у нас пока вот shared ptr создается только одним способом, просто через конструктор
[41:00.240 --> 41:05.240]  Ну, то есть ему дают указатель и, возможно, еще дилитер
[41:06.240 --> 41:09.240]  Будем считать, что пока нет у них у меня шерты и нет никакого аллокатора
[41:10.240 --> 41:14.240]  Что тогда мы бы хранили в полях shared ptr?
[41:14.240 --> 41:16.240]  Ну, один звездочка
[41:17.240 --> 41:19.240]  В ptr думаем или нет?
[41:20.240 --> 41:22.240]  Да, давайте думаем
[41:23.240 --> 41:25.240]  Вроде ничего не меняется
[41:26.240 --> 41:33.240]  Ну, меняется то, что у нас там была возня с контролл блоком, который мы хотим хранить
[41:33.240 --> 41:35.240]  А, ну да, если у нас нету
[41:38.240 --> 41:41.240]  Если у нас нету мейк шерд, это все проще, но нам все равно нужно хранить
[41:42.240 --> 41:45.240]  Нам же нужно контролл блок еще хранить с двумя счетчиками в любом случае
[41:46.240 --> 41:48.240]  И еще указатель на t отдельно
[41:49.240 --> 41:52.240]  То есть у нас, я напоминаю, у нас была
[41:53.240 --> 41:55.240]  У нас была, я напоминаю
[41:55.240 --> 41:59.240]  У нас уже без того был бейс контролл блок, в котором хранилось shared counter v counter
[42:00.240 --> 42:06.240]  И у него был наследник там, контролл блок, просто контролл блок, в котором хранилось t
[42:07.240 --> 42:08.240]  Да? Правда?
[42:09.240 --> 42:12.240]  У нас был другой контролл блок, который shared counter v counter
[42:13.240 --> 42:17.240]  Бейс контролл блок у меня был, в общем, у нас был бейс контролл блок
[42:18.240 --> 42:19.240]  Да? Правда?
[42:20.240 --> 42:23.240]  У нас был другой контролл блок, который shared counter v counter
[42:24.240 --> 42:25.240]  Бейс контролл блок у него был t
[42:26.240 --> 42:28.240]  И контролл блок у нас селся с бейс контролл блок, и в нем еще контролл блок
[42:29.240 --> 42:33.240]  Да, мне кажется, что нужно, чтобы бейс был t, потому что нам никогда не нужно dest
[42:34.240 --> 42:39.240]  Фактически, а удобнее было так хранить, чтобы меньше info писать
[42:40.240 --> 42:43.240]  Ну, в общем, сейчас мы переделаем все, кажется, снова
[42:43.240 --> 42:44.240]  Так, стоп
[42:57.240 --> 43:01.240]  У нас был бейс контролл блок, а в нем t, а контролл блок чем от ним отличался?
[43:02.240 --> 43:03.240]  Еще counter
[43:03.240 --> 43:05.240]  А когда тоже еще одна структура?
[43:07.240 --> 43:08.240]  Правда, кстати?
[43:09.240 --> 43:11.240]  Ну, в смысле, сам по себе counter
[43:12.240 --> 43:15.240]  А, все, я понял, у нас бейс контролл блок хранился t
[43:16.240 --> 43:17.240]  Да, да, да
[43:18.240 --> 43:21.240]  Короче, по сути, бейс контролл блок у нас был t, а контролл блок от него отличался тем, что к нему еще одна счетчика добавилась
[43:22.240 --> 43:23.240]  Да, да, да
[43:24.240 --> 43:25.240]  Да, вот так, ну окей
[43:28.240 --> 43:31.240]  Да, наверное, все-таки надо было бы сделать наоборот
[43:31.240 --> 43:32.240]  Наоборот? Ну, ладно
[43:33.240 --> 43:34.240]  Мы пытались в прошлый раз
[43:35.240 --> 43:36.240]  Много чего пытались
[43:37.240 --> 43:38.240]  Да
[43:39.240 --> 43:42.240]  Ну вот, у нас добавился кастомный дилитер, что теперь делать?
[43:43.240 --> 43:44.240]  Как добавился? А как вообще передали?
[43:45.240 --> 43:46.240]  В конструкторе передали
[43:47.240 --> 43:48.240]  Какого типа объекта?
[43:49.240 --> 43:50.240]  Дилитер – это такой объект шамплит
[43:51.240 --> 43:52.240]  Функциональный шамплит
[43:57.240 --> 43:58.240]  Type name – дилитер
[44:02.240 --> 44:06.240]  Дилитер – это штука, которая, ну, это функциональный объект, да
[44:07.240 --> 44:08.240]  Может быть, там одна функция
[44:09.240 --> 44:15.240]  Которая вызывается, которая имеет оператор круглой скобочки, от t звездочки
[44:16.240 --> 44:18.240]  И вот ее надо вместо деструктора вызывать
[44:20.240 --> 44:23.240]  Sheriff PTR, нам сказали, t звездочка PTR
[44:24.240 --> 44:26.240]  И дилитер
[44:28.240 --> 44:29.240]  D
[44:30.240 --> 44:34.240]  Ну, дилитер тут, наверное, конечно, нужно по ссылке принимать
[44:38.240 --> 44:39.240]  Сейчас, я не уверен
[44:40.240 --> 44:41.240]  Наверное, что по ссылке
[44:50.240 --> 44:51.240]  Ну, в общем, да
[44:52.240 --> 44:55.240]  А если мы можем передать просто обычную функцию?
[44:56.240 --> 44:59.240]  Указатель носичной функции
[45:00.240 --> 45:02.240]  Это должна быть сама функция или указатель на нее?
[45:03.240 --> 45:04.240]  Ну, указатель на нее, да, по идее, можно
[45:05.240 --> 45:06.240]  Ложим по ссылке принять указатель
[45:07.240 --> 45:08.240]  А в чем проблема?
[45:09.240 --> 45:10.240]  Указатель по ссылке как раз можно
[45:15.240 --> 45:16.240]  Указатель на ссылке нельзя
[45:17.240 --> 45:19.240]  Нет, дилитер принимается по значению
[45:20.240 --> 45:22.240]  Потому что, типа, подозревается, что он слабительный
[45:22.240 --> 45:23.240]  Слабительный
[45:24.240 --> 45:26.240]  Да, что там просто пора указатель, в худшем случае, в нем
[45:27.240 --> 45:30.240]  Но если это тяжелый объект, то, ну, мугнем его
[45:32.240 --> 45:33.240]  Изо всех сил
[45:34.240 --> 45:35.240]  В смысле, стоп, мугнем туда
[45:36.240 --> 45:40.240]  Ну, мы сейчас положим, мы еще не будем копировать, просто мы туда сохраним себе мугнуть эту штуку
[45:41.240 --> 45:42.240]  Мы же не приняли его по делу
[45:43.240 --> 45:44.240]  Мы же приняли по значению
[45:45.240 --> 45:46.240]  Вот, что делать-то?
[45:47.240 --> 45:48.240]  Как, значит, нам, что нам делать?
[45:49.240 --> 45:50.240]  Туда нам что положить?
[45:52.240 --> 45:54.240]  Ну, нам надо вот этот дилитер тоже в контроллер-блоке сохранить
[45:55.240 --> 45:57.240]  В каком-то из контроллер-блока
[46:02.240 --> 46:05.240]  То есть нам нужен бейс-бейс-контролл-блок
[46:07.240 --> 46:08.240]  С виртуальным
[46:09.240 --> 46:11.240]  На самом деле нам все-таки
[46:13.240 --> 46:16.240]  Мне все-таки что-то вот очень нравится, что мы в прошлый раз написали
[46:16.240 --> 46:17.240]  Потому что какой-то у меня вот прям
[46:20.240 --> 46:21.240]  Какой-то у меня диссонанс
[46:22.240 --> 46:25.240]  Потому что обычно бейс-контролл-блок содержит как раз счетчики
[46:26.240 --> 46:27.240]  А ты, он либо есть, либо нет
[46:28.240 --> 46:29.240]  Вроде у нас получалось и так
[46:30.240 --> 46:32.240]  Мы просто хотели как можно меньше указателей хранить в основном шерптере
[46:33.240 --> 46:35.240]  И так получилось меньше ифов, можно и наоборот хранить
[46:36.240 --> 46:38.240]  Давайте я все-таки сделаю бейс-контролл-блок
[46:39.240 --> 46:40.240]  Вот я просто почему хочу
[46:41.240 --> 46:44.240]  Вот эта идея с тем, что у нас есть бейс и дирайв, то она как раз сейчас очень полезной будет
[46:44.240 --> 46:47.240]  Потому что мы заодно просто делаем еще его полиморфным
[46:48.240 --> 46:50.240]  А, сам контролл-блок с каунтерами
[46:51.240 --> 46:53.240]  Конечно, сам контролл-блок с каунтерами и он и будет полиморфным
[46:54.240 --> 46:56.240]  И там будет вся эта виртуальная штука
[46:57.240 --> 46:59.240]  А вот дирайв в контролл-блоке будет...
[47:00.240 --> 47:02.240]  Он будет шаблонным в зависимости от типа дилитера
[47:03.240 --> 47:04.240]  А потом еще локатор туда допилим
[47:05.240 --> 47:08.240]  У нас будет шаблонный контролл-блок в котором будет лежать дилитер и локатор
[47:09.240 --> 47:13.240]  Вот, но это только на случай если мы создали через Мейкшерет
[47:14.240 --> 47:19.240]  Ну, точнее, наоборот, если мы создали черед Мэйдшерра, то у нас как раз дилитер не будет.
[47:19.240 --> 47:27.240]  У нас будет два разных контроллблока. У нас будет один базовый контроллблок, в котором будут лежать счетчики и виртуальный деструктор.
[47:27.240 --> 47:33.240]  Ну, и виртуал, там, копия, что еще там надо. И будет два разных наследника от него.
[47:33.240 --> 47:47.240]  В одном будет лежать аллокатор, но не будет дилитера. А в другом будет лежать и дилитер и аллокатор, но не будет Т.
[47:47.240 --> 47:51.240]  Что за прикол? А Т ку надели?
[47:51.240 --> 47:58.240]  А потому что, смотрите, если мы через Мэйдшеррад создаемся, то Т уже создан.
[47:58.240 --> 48:01.240]  Ага, и Т его хранит?
[48:01.240 --> 48:05.240]  Виноват. Сейчас, ну, я все перепутал, неправильно сказал.
[48:05.240 --> 48:12.240]  Ну, короче, в одном, один будет на случай, если мы через Мэйдшеррад создаем, другой на случай, если мы через обычный конструктор создаем.
[48:12.240 --> 48:15.240]  Вот. Если мы созданы через, не через, что?
[48:15.240 --> 48:16.240]  Может напишем?
[48:16.240 --> 48:22.240]  Ну, давайте попробуем. Ну, давайте я попробую, сейчас, наверное...
[48:22.240 --> 48:24.240]  Пусть в бейс будет каунтер, это нормально.
[48:24.240 --> 48:25.240]  Короче, давайте я...
[48:25.240 --> 48:27.240]  На полтрайфа больше будет. Это вообще не страшно.
[48:27.240 --> 48:30.240]  Значит, да, давайте у меня будет бейс-контрол-блок.
[48:38.240 --> 48:42.240]  И все, что мне надо в бейс-контрол-блоке, это...
[48:42.240 --> 48:44.240]  У нас запись идет, да?
[48:44.240 --> 48:48.240]  Блин, я вам сливаю просто решение задачи, что-то как-то неправильно.
[48:48.240 --> 48:54.240]  Если бы записи не шло, то просто остальные бы страдали.
[48:54.240 --> 48:57.240]  А мы нет? В смысле, типа...
[48:57.240 --> 49:02.240]  Это как в истории за посещение зачет просто в другой форме.
[49:02.240 --> 49:04.240]  Ну, типа да.
[49:04.240 --> 49:07.240]  Да, ну, короче...
[49:07.240 --> 49:10.240]  Ну да, мне нужно, чтобы у меня был, значит, сайс...
[49:10.240 --> 49:13.240]  Ну, тут будет сайс-т.
[49:13.240 --> 49:15.240]  Share account, week account.
[49:25.240 --> 49:31.240]  Ну и для того, чтобы все понимали, с чем они связались, будет вот такая вещь.
[49:41.240 --> 49:44.240]  А почему уже здесь?
[49:44.240 --> 49:45.240]  Так...
[49:45.240 --> 49:48.240]  И от него как раз и будет шагунный последний.
[49:48.240 --> 49:51.240]  Это тот самый бейс, который для TypeRage'а.
[49:51.240 --> 49:53.240]  Я просто хотел сделать следующее. Очень бы.
[49:53.240 --> 49:59.240]  Если я не из вот этих вот кастомных дилитеров, я не хочу связываться с виртуальной функцией.
[49:59.240 --> 50:00.240]  Не выйдет.
[50:00.240 --> 50:03.240]  В смысле, без кастомного дилитера же почему не выйдет?
[50:03.240 --> 50:05.240]  А, ты хочешь сказать, что...
[50:05.240 --> 50:08.240]  Ну, кстати, может быть что-то подобное...
[50:11.240 --> 50:13.240]  Задачка на около 11.
[50:13.240 --> 50:18.240]  Я не знаю. Но я думаю, что нет.
[50:18.240 --> 50:21.240]  Я думаю, действительно, это можно так сделать.
[50:24.240 --> 50:29.240]  Ну, не только кастомный дилитер, еще и кастомный аллокатор бывает.
[50:29.240 --> 50:31.240]  Ну, я хочу, чтобы если я ничего кастомного не делал...
[50:31.240 --> 50:33.240]  Если ни кастомного дилитера, ни кастомного аллокатора...
[50:33.240 --> 50:36.240]  Я бы очень хотел бы не связываться с виртуальной функцией.
[50:36.240 --> 50:37.240]  Знаешь, почему не получится?
[50:37.240 --> 50:42.240]  Потому что твоему shared ptr'у могут присвоить другой shared ptr, у которого они будут.
[50:42.240 --> 50:44.240]  Что за люди это делают?
[50:44.240 --> 50:47.240]  Зачем они присваивают мне этот дельмо?
[50:47.240 --> 50:48.240]  В том-то и дело, что...
[50:48.240 --> 50:49.240]  Да, хорошо, понятно.
[50:49.240 --> 50:50.240]  Что мы...
[50:50.240 --> 50:54.240]  Если бы у нас дилитеры и аллокаторы были шаблонными параметрами самого shared ptr,
[50:54.240 --> 50:56.240]  то не было бы вообще никаких проблем.
[50:56.240 --> 50:59.240]  Но мы хотим, чтобы они были динамически подменяемыми.
[50:59.240 --> 51:03.240]  И именно поэтому мы должны сделать с виртуальными функциями в любом случае.
[51:03.240 --> 51:05.240]  Так вот, у нас будет наследник...
[51:05.240 --> 51:10.240]  Вот давайте сделаем наследник этой штуке на случай, если мы...
[51:11.240 --> 51:15.240]  Созданы не через make-shared.
[51:16.240 --> 51:19.240]  Если мы созданы не через make-shared,
[51:20.240 --> 51:23.240]  значит это будет структура...
[51:27.240 --> 51:29.240]  Control-блок...
[51:33.240 --> 51:36.240]  Не знаю, regular давайте, обычный Control-блок.
[51:38.240 --> 51:41.240]  Она будет наследоваться от Base Control-блок.
[51:41.240 --> 51:43.240]  А они шаблонные?
[51:43.240 --> 51:46.240]  Да, конечно, наша будет шаблонная.
[51:46.240 --> 51:48.240]  Adup, Angev.
[51:48.240 --> 51:49.240]  Разве?
[51:49.240 --> 51:53.240]  Да, с шаблонным параметром дилитеры, с шаблонным параметром аллокатор.
[52:03.240 --> 52:06.240]  Да, даже если мы не через make-shared созданы,
[52:06.240 --> 52:08.240]  все равно мы можем кастомный аллокатор передать.
[52:08.240 --> 52:13.240]  То есть, мы могли создать объект на кастомном аллокаторе
[52:14.240 --> 52:19.240]  и в конструктор shared-ptr отдать этот аллокатор,
[52:19.240 --> 52:22.240]  чтобы он удалил его правильным аллокатором.
[52:23.240 --> 52:26.240]  Но эти штуки, они имеют...
[52:26.240 --> 52:28.240]  По умолчанию значение...
[52:28.240 --> 52:31.240]  Вот аллок по умолчанию стд-аллокатор...
[52:32.240 --> 52:33.240]  Ну, там...
[52:33.240 --> 52:36.240]  А дилитер по умолчанию равен чему должен быть?
[52:38.240 --> 52:41.240]  Дилитер по умолчанию равен...
[52:44.240 --> 52:48.240]  А же был какой-то 2.2.0, оператор, что-то там...
[52:49.240 --> 52:50.240]  Не то?
[52:51.240 --> 52:55.240]  Значит, есть такой класс в стандартной библиотеке,
[52:55.240 --> 52:58.240]  на котором мы можем кастомный аллокатор,
[52:59.240 --> 53:03.240]  а, значит, есть такой класс в стандартной библиотеке,
[53:03.240 --> 53:05.240]  называется std-default-delete.
[53:09.240 --> 53:11.240]  Кто бы мог подумать...
[53:11.240 --> 53:13.240]  Вот t, вот шамлонный,
[53:13.240 --> 53:15.240]  и он просто...
[53:15.240 --> 53:16.240]  Его вызов...
[53:16.240 --> 53:17.240]  Ну, он...
[53:17.240 --> 53:19.240]  Это эквивалент того, что делается обычно.
[53:19.240 --> 53:23.240]  Мы вызываем оператора круглые скобочки у этого объекта
[53:23.240 --> 53:24.240]  от t звелочка ptr.
[53:24.240 --> 53:26.240]  Вот у него есть оператор круглые скобочки
[53:26.240 --> 53:27.240]  от t звелочка ptr.
[53:27.240 --> 53:29.240]  И что делает этот оператор?
[53:29.240 --> 53:30.240]  Удаляет.
[53:30.240 --> 53:33.240]  ptr стрелочка tilde t.
[53:33.240 --> 53:35.240]  Да, вот это default-delete.
[53:36.240 --> 53:39.240]  Заметьте, это только деструктор, это не освобождение.
[53:39.240 --> 53:40.240]  Да, да, да.
[53:40.240 --> 53:42.240]  А, я забыл самое главное.
[53:42.240 --> 53:44.240]  Здесь же должен быть, собственно, type-name t.
[53:46.240 --> 53:47.240]  Кто?
[53:47.240 --> 53:49.240]  Точнее, type-name u, потому что t у нас...
[53:49.240 --> 53:50.240]  Те уже заняты.
[53:50.240 --> 53:51.240]  Да, type-name u.
[53:51.240 --> 53:55.240]  Вот это u, это будет тот самый, который для type erasure нужен.
[53:57.240 --> 53:58.240]  Вот.
[53:58.240 --> 54:01.240]  И что мы в этом control-block regular будем хранить?
[54:02.240 --> 54:04.240]  Сейчас, какой type мы удалить-то хотим?
[54:05.240 --> 54:06.240]  Что?
[54:07.240 --> 54:08.240]  При чем тут type erasure?
[54:08.240 --> 54:10.240]  Зачем нам что удалять?
[54:14.240 --> 54:16.240]  А, нет, стоп, стоп, стоп.
[54:16.240 --> 54:18.240]  Ой, господи, чушь написал, извините.
[54:18.240 --> 54:20.240]  Это delete-relocator, это type erasure.
[54:20.240 --> 54:21.240]  Да, все, все, все.
[54:21.240 --> 54:23.240]  Все, я какую-то ерунду написал.
[54:27.240 --> 54:29.240]  Слава богу.
[54:29.240 --> 54:31.240]  Страшно стало очень.
[54:37.240 --> 54:39.240]  Вот, и что здесь будет храниться?
[54:43.240 --> 54:44.240]  Сейчас подумаем.
[54:44.240 --> 54:45.240]  Ну, то же самое.
[54:45.240 --> 54:46.240]  Что такое?
[54:48.240 --> 54:50.240]  Объект delete-relocator.
[54:50.240 --> 54:52.240]  Здесь уходится delete-relocator.
[54:53.240 --> 54:54.240]  Логично, да?
[54:55.240 --> 54:58.240]  И еще что-то, связанное с T.
[55:02.240 --> 55:03.240]  Угу.
[55:03.240 --> 55:04.240]  Да, а знаете?
[55:04.240 --> 55:06.240]  Виртуальная функция, которая удаляет его, что-то такое.
[55:07.240 --> 55:09.240]  Не, все, delete-relocator хватит, объект T.
[55:10.240 --> 55:12.240]  Значит, T object.
[55:14.240 --> 55:16.240]  Вот сейчас, кажется, не получится.
[55:16.240 --> 55:17.240]  Ну, подумаем.
[55:17.240 --> 55:18.240]  Delete-er.
[55:20.240 --> 55:22.240]  Не знаю, просто D.
[55:22.240 --> 55:23.240]  Облокатор.
[55:23.240 --> 55:24.240]  A.
[55:24.240 --> 55:26.240]  D-O.
[55:27.240 --> 55:28.240]  Все.
[55:29.240 --> 55:30.240]  Аллок.
[55:30.240 --> 55:31.240]  Не знаю, давайте D-O хотя бы.
[55:31.240 --> 55:32.240]  Да, спасибо.
[55:33.240 --> 55:34.240]  Так.
[55:36.240 --> 55:37.240]  Хорошо.
[55:41.240 --> 55:42.240]  Ну, хорошо.
[55:44.240 --> 55:45.240]  Так, и что?
[55:46.240 --> 55:48.240]  Ну, как мы это создавать-то будем?
[55:48.240 --> 55:53.240]  Вот если нас конструируют от кастомного delete-а, кастомного локатора и дают нам T звездочку,
[55:53.240 --> 55:54.240]  чем мы будем делать?
[55:55.240 --> 55:56.240]  Понимаете, в чем проблема?
[55:56.240 --> 55:58.240]  А мы же раньше T звездочку хранили.
[55:58.240 --> 56:00.240]  Мы же вообще раньше не хранили объект T, да?
[56:00.240 --> 56:02.240]  Мы в итоге пришли к тому, что мы храним T,
[56:02.240 --> 56:04.240]  но мы просто делали интерпрет-каст,
[56:04.240 --> 56:07.240]  потому что у нас была плей-инструктура с одним полем T.
[56:08.240 --> 56:10.240]  И мы сказали, что если нам дали T звездочку,
[56:10.240 --> 56:13.240]  ну давайте мы просто скажем, что это и есть.
[56:13.240 --> 56:15.240]  Это на самом деле не указатель на T,
[56:15.240 --> 56:17.240]  это на самом деле не указатель на T,
[56:17.240 --> 56:18.240]  это указатель на наш BaseControlBlog.
[56:18.240 --> 56:20.240]  Вот почему мы BaseControlBlog сделали T.
[56:20.240 --> 56:21.240]  Вот.
[56:21.240 --> 56:23.240]  А теперь у нас так не получится,
[56:23.240 --> 56:24.240]  потому что мы не сможем сказать,
[56:24.240 --> 56:26.240]  что та T звездочка, которая нам дали,
[56:26.240 --> 56:28.240]  это и есть pointer на нашу штуку.
[56:28.240 --> 56:29.240]  Кстати, почему?
[56:29.240 --> 56:32.240]  А потому что у нас есть еще BaseControlBlog.
[56:32.240 --> 56:33.240]  И мы не можем делать плюс.
[56:33.240 --> 56:35.240]  Потому что нам еще куда-то надо будет присобачить
[56:35.240 --> 56:36.240]  shared count, visual.
[56:36.240 --> 56:37.240]  Да, да, да.
[56:37.240 --> 56:39.240]  Нет, может быть как-то можно извернуться?
[56:41.240 --> 56:42.240]  Ну, короче, не знаю.
[56:42.240 --> 56:43.240]  Подумайте.
[56:43.240 --> 56:46.240]  Я утверждаю, что вот так сработает.
[56:46.240 --> 56:48.240]  Мы просто здесь будем честно хранить ту T звездочку,
[56:48.240 --> 56:49.240]  которую нам дали.
[56:49.240 --> 56:50.240]  Это будут два перехода.
[56:51.240 --> 56:54.240]  Нет, ну мы будем в полях shared PTR хранить
[56:54.240 --> 56:56.240]  T звездочку отдельно.
[56:57.240 --> 56:59.240]  И если нам shared PTR спрашивают,
[56:59.240 --> 57:02.240]  то мы будем хранить указатель на правильную T звездочку.
[57:06.240 --> 57:08.240]  Два перехода будут когда?
[57:09.240 --> 57:11.240]  Нам дали T звездочку,
[57:11.240 --> 57:13.240]  но в ControlBlog мы будем хранить T звездочку.
[57:13.240 --> 57:15.240]  Но shared PTR мы продублируем.
[57:15.240 --> 57:18.240]  Мы будем в поле еще shared PTR хранить эту же T звездочку.
[57:18.240 --> 57:19.240]  Ну, указатель на то же самое.
[57:19.240 --> 57:20.240]  Ну, зачем мы вообще это делаем?
[57:20.240 --> 57:23.240]  Чтобы не прыгать сначала указатель на ControlBlog,
[57:23.240 --> 57:24.240]  потом указатель на...
[57:24.240 --> 57:25.240]  Зачем здесь ее хранить тогда?
[57:26.240 --> 57:27.240]  Ага.
[57:28.240 --> 57:31.240]  А как мы будем из ControlBlog удалять объект?
[57:31.240 --> 57:32.240]  Справедливо.
[57:32.240 --> 57:34.240]  Передавать ему.
[57:35.240 --> 57:38.240]  Мы же им пользуемся в shared PTR.
[57:39.240 --> 57:43.240]  Ты должен будешь говорить delete...
[57:43.240 --> 57:45.240]  Ну, там тебе нужно будет в какой-то момент говорить,
[57:45.240 --> 57:46.240]  типа delete ControlBlog.
[57:46.240 --> 57:48.240]  И что ты будешь делать?
[57:48.240 --> 57:49.240]  Или ты хочешь сказать,
[57:49.240 --> 57:50.240]  ты будешь...
[57:50.240 --> 57:54.240]  У тебя будет типа виртуальная функция delete ControlBlog вот...
[57:57.240 --> 57:58.240]  И ты будешь передавать...
[57:58.240 --> 57:59.240]  Не, не понятно.
[57:59.240 --> 58:01.240]  Как ты будешь делать?
[58:01.240 --> 58:02.240]  Как ты ему...
[58:02.240 --> 58:03.240]  А, ну да, один хрен...
[58:03.240 --> 58:05.240]  Да, все нормально.
[58:09.240 --> 58:10.240]  В любом случае, короче,
[58:10.240 --> 58:12.240]  два перехода по указателю.
[58:15.240 --> 58:16.240]  В общем, не знаю,
[58:16.240 --> 58:18.240]  может, когда ты начнешь писать,
[58:18.240 --> 58:19.240]  ты придумаешь что-нибудь более умное,
[58:19.240 --> 58:24.240]  но вот пока я знаю такую реализацию.
[58:24.240 --> 58:25.240]  Ладно.
[58:25.240 --> 58:28.240]  И если кто-то придумает что-то более умное,
[58:28.240 --> 58:29.240]  более оптимальное, или если кто-то...
[58:29.240 --> 58:31.240]  А сам темы где хранили, кстати?
[58:31.240 --> 58:32.240]  Все это время?
[58:32.240 --> 58:34.240]  Ты этот ControlBlog на случай,
[58:34.240 --> 58:36.240]  если ты уже создан.
[58:36.240 --> 58:40.240]  А, у нас же еще будет сейчас ControlBlog и Regular.
[58:40.240 --> 58:43.240]  Конечно, ControlBlog и Regular еще будет.
[58:43.240 --> 58:46.240]  И вот в нем уже будет настоящий Те лежать.
[58:46.240 --> 58:47.240]  Кайф.
[58:47.240 --> 58:48.240]  Так вот.
[58:48.240 --> 58:52.240]  У нас не только будет разный регулятор для MakeShared,
[58:52.240 --> 58:54.240]  для LocateShared.
[58:54.240 --> 58:57.240]  Нет, для MakeShared это частный случай LocateShared
[58:57.240 --> 59:00.240]  просто со стандартным локатором.
[59:02.240 --> 59:05.240]  Так, мне кажется сейчас важный момент,
[59:05.240 --> 59:08.240]  потому что я, на самом деле, почти все сказал,
[59:08.240 --> 59:11.240]  и самое время спросить, кто понял,
[59:11.240 --> 59:13.240]  как реализовывать SharedPTR.
[59:15.240 --> 59:18.240]  Ну, в основном, как бы, идейно.
[59:18.240 --> 59:19.240]  Ты, кстати, тоже слушай,
[59:19.240 --> 59:21.240]  потому что тебе тоже реализовывать просто
[59:21.240 --> 59:23.240]  это будет следующей задачей у вас.
[59:23.240 --> 59:24.240]  В смысле следующей?
[59:24.240 --> 59:25.240]  У основы просто.
[59:25.240 --> 59:26.240]  После кого?
[59:26.240 --> 59:27.240]  После NordicMap.
[59:27.240 --> 59:29.240]  Ну, они на одну задачу стоят,
[59:29.240 --> 59:31.240]  но это у вас тоже будет.
[59:31.240 --> 59:33.240]  У основы такие же задачи будут.
[59:33.240 --> 59:35.240]  У основы такие же задачи,
[59:35.240 --> 59:37.240]  просто у них есть первая задача,
[59:37.240 --> 59:38.240]  которая нет у вас,
[59:38.240 --> 59:39.240]  а у вас последняя,
[59:39.240 --> 59:41.240]  которая нет у них, будет вот так.
[59:41.240 --> 59:43.240]  Я подумал, что основа
[59:43.240 --> 59:46.240]  должна не сильно отставать в прадвы в этом году,
[59:46.240 --> 59:47.240]  потому что...
[59:47.240 --> 59:49.240]  А про два быть круче, чем в прошлое,
[59:49.240 --> 59:51.240]  про два раза в два и нормально.
[59:51.240 --> 59:52.240]  Так каждый год...
[59:52.240 --> 59:53.240]  Ну, во-первых, ни раза в два нет.
[59:53.240 --> 59:54.240]  Мы с вами пройдем чуть больше,
[59:54.240 --> 59:55.240]  чем в прошлом году успели,
[59:55.240 --> 59:56.240]  но не сильно больше.
[59:56.240 --> 59:57.240]  Да, хорошо.
[59:57.240 --> 59:58.240]  Но так каждый год происходит.
[59:58.240 --> 59:59.240]  Это нормально.
[59:59.240 --> 01:00:00.240]  Конечно.
[01:00:00.240 --> 01:00:01.240]  В следующем году будет лучше,
[01:00:01.240 --> 01:00:02.240]  чем у вас, да.
[01:00:02.240 --> 01:00:04.240]  И вообще каждое следующее поколение студентов...
[01:00:04.240 --> 01:00:05.240]  Они уже будут писать
[01:00:05.240 --> 01:00:06.240]  на плюсах двадцатых просто каждый день.
[01:00:06.240 --> 01:00:07.240]  Конечно.
[01:00:07.240 --> 01:00:08.240]  Слушайте, еще...
[01:00:08.240 --> 01:00:09.240]  Еще я не знаю,
[01:00:09.240 --> 01:00:10.240]  еще пять лет назад,
[01:00:10.240 --> 01:00:11.240]  в первом семестре,
[01:00:11.240 --> 01:00:12.240]  мы вообще не затрагивали C++11.
[01:00:12.240 --> 01:00:13.240]  Мы говорили,
[01:00:13.240 --> 01:00:14.240]  что равно дефолт, равно дилит,
[01:00:14.240 --> 01:00:15.240]  этого нет,
[01:00:15.240 --> 01:00:16.240]  потому что типа C++11,
[01:00:16.240 --> 01:00:17.240]  это еще вот...
[01:00:17.240 --> 01:00:18.240]  Это слишком сложно?
[01:00:18.240 --> 01:00:19.240]  Ну, там...
[01:00:19.240 --> 01:00:20.240]  Мы были на C++3.
[01:00:20.240 --> 01:00:21.240]  Ну, да.
[01:00:21.240 --> 01:00:22.240]  Ну, да.
[01:00:22.240 --> 01:00:23.240]  Ну, да.
[01:00:23.240 --> 01:00:24.240]  Ну, да.
[01:00:24.240 --> 01:00:25.240]  Ну, да.
[01:00:25.240 --> 01:00:26.240]  Ну, да.
[01:00:26.240 --> 01:00:27.240]  Ну, да.
[01:00:27.240 --> 01:00:28.240]  Вы же там...
[01:00:28.240 --> 01:00:29.240]  Мы были на C++3.
[01:00:29.240 --> 01:00:30.240]  Да.
[01:00:30.240 --> 01:00:31.240]  Ну, сейчас мы уже
[01:00:31.240 --> 01:00:34.240]  C++17 с вами изучаем вот в полной мере вот этот вот
[01:00:34.240 --> 01:00:35.240]  E, и все прочее.
[01:00:35.240 --> 01:00:37.240]  Через год, я думаю, уже
[01:00:37.240 --> 01:00:39.240]  вполне C++20 фичи какие-нибудь будем изучать
[01:00:39.240 --> 01:00:40.240]  на первом семестре.
[01:00:40.240 --> 01:00:41.240]  Ну, короче...
[01:00:41.240 --> 01:00:42.240]  Вот.
[01:00:42.240 --> 01:00:43.240]  Так, так что?
[01:00:43.240 --> 01:00:44.240]  Ни кто не понял,
[01:00:44.240 --> 01:00:45.240]  как шеф пытается реализовать, да?
[01:00:45.240 --> 01:00:46.240]  Ты понял.
[01:00:46.240 --> 01:00:47.240]  Ну,
[01:00:47.240 --> 01:00:48.240]  у меня будет очень много проблем,
[01:00:48.240 --> 01:00:49.240]  когда я собираюсь писать.
[01:00:49.240 --> 01:00:51.240]  Но идея наверняка понятна.
[01:00:51.240 --> 01:00:52.240]  Вот.
[01:00:52.240 --> 01:00:53.240]  Главное – идею понять, да.
[01:00:53.240 --> 01:00:54.240]  Ну вот
[01:00:54.240 --> 01:00:56.240]  я выпождаю, что вот с такими...
[01:00:56.240 --> 01:01:12.240]  с такой иерархией классов, всё получится, ну потому что у меня есть рабочая реализация, в которой именно такие поля, короче, я знаю, что можно по-другому, но вот можно так, как минимум так получится, да, что
[01:01:12.240 --> 01:01:18.240]  мы сюда допилили дилитер и аллокатор, по сравнению с тем, что проходили несколько знаний назад
[01:01:19.240 --> 01:01:27.240]  да, ну и чуть-чуть по-другому организовали эту штуку, потому что тут рачку хранили Т, а теперь-то звёздочку
[01:01:27.240 --> 01:01:30.240]  аллокатор мы будем называть СРПТ, а мы будем ВИКПТ, а тоже ВИКПТ
[01:01:30.240 --> 01:01:35.240]  понятное дело, да, но образ простенький относится, сравнительно, он ничего не делает, сравнительно
[01:01:35.240 --> 01:01:36.240]  он же не отвечает за создание объектов
[01:01:36.240 --> 01:01:38.240]  а вот тут дилитер и аллок, это кто, это типы?
[01:01:38.240 --> 01:01:39.240]  смотрите, что?
[01:01:39.240 --> 01:01:44.240]  дилитер и аллок, это какие-то типы на функцию или на объекты?
[01:01:44.240 --> 01:01:54.240]  дилитер это функциональный объект, что от него требуется, чтобы у него был оператор круглой скобочки от Т звёздочки
[01:01:54.240 --> 01:01:56.240]  дилитер это тип функционального объекта
[01:01:56.240 --> 01:02:01.240]  дилитер это тип функционального объекта, ДЕЛЬ это сам функциональный объект, то есть его использование будет таким
[01:02:01.240 --> 01:02:03.240]  ДЕЛЬ от ПТР
[01:02:03.240 --> 01:02:05.240]  в какой-то момент
[01:02:05.240 --> 01:02:11.240]  вместо того, чтобы вызывать ПТР в стрелочку тильда Т, вы будете говорить ДЕЛЬ от ПТР
[01:02:11.240 --> 01:02:17.240]  в дефолтом случае это будет то же самое, что ПТР с точки тильда Т, но может быть и что-то другое
[01:02:17.240 --> 01:02:19.240]  ДЕЛЬ это по сути просто настройка над деструктором
[01:02:19.240 --> 01:02:20.240]  что?
[01:02:20.240 --> 01:02:22.240]  ДЕЛЬ настройка над деструктором или что?
[01:02:22.240 --> 01:02:23.240]  это замена деструктора
[01:02:23.240 --> 01:02:30.240]  так, смотри ещё раз, шеред ПТР, вообще говоря, может вместо деструктора с объектом делать что-то другое при уничтожении
[01:02:30.240 --> 01:02:34.240]  пример я приводил в прошлый раз, хотя он может быть вам не очень понятен, но
[01:02:35.240 --> 01:02:36.240]  топ-1
[01:02:36.240 --> 01:02:39.240]  какие бывают сценарии использования РАИ?
[01:02:39.240 --> 01:02:41.240]  первый пример это освобождение памяти
[01:02:41.240 --> 01:02:43.240]  топ-2 пример
[01:02:43.240 --> 01:02:45.240]  или даже может быть наоборот
[01:02:45.240 --> 01:02:47.240]  топ-1 это
[01:02:47.240 --> 01:02:49.240]  смотря что вы пишете
[01:02:49.240 --> 01:02:51.240]  если у вас многопоточная программа
[01:02:51.240 --> 01:02:56.240]  у вас может быть разделяемая память
[01:02:56.240 --> 01:02:58.240]  и на неё нужна блокировка
[01:02:58.240 --> 01:03:00.240]  это значит, что вы
[01:03:00.240 --> 01:03:02.240]  у вас есть несколько
[01:03:02.240 --> 01:03:04.240]  платоков, которые работают с одним и тем же
[01:03:04.240 --> 01:03:06.240]  и при входе
[01:03:06.240 --> 01:03:08.240]  в критическую секцию
[01:03:08.240 --> 01:03:10.240]  вы должны сделать некоторую операцию
[01:03:10.240 --> 01:03:12.240]  типа я захватил блокировку
[01:03:12.240 --> 01:03:14.240]  грубо говоря, я пометил, что я сейчас здесь, это моё
[01:03:14.240 --> 01:03:16.240]  и остальные
[01:03:16.240 --> 01:03:18.240]  прежде чем туда начать заходить
[01:03:18.240 --> 01:03:20.240]  они смотрят занято или нет
[01:03:20.240 --> 01:03:22.240]  да, и если нет, то ждут
[01:03:22.240 --> 01:03:24.240]  пока не освободиться
[01:03:24.240 --> 01:03:26.240]  когда кто-то занимает, он
[01:03:26.240 --> 01:03:28.240]  так вот, если вы
[01:03:28.240 --> 01:03:30.240]  делаете, и у вас опять
[01:03:30.240 --> 01:03:32.240]  вы какую-то функцию пишете
[01:03:32.240 --> 01:03:34.240]  и у вас вместо muteX
[01:03:34.240 --> 01:03:36.240]  написано muteX.log
[01:03:36.240 --> 01:03:38.240]  это значит взять вот эту штуку
[01:03:38.240 --> 01:03:40.240]  которая заведует блокировкой
[01:03:40.240 --> 01:03:42.240]  и занять
[01:03:42.240 --> 01:03:44.240]  и в конце при выходе вам надо сделать muteX.log
[01:03:44.240 --> 01:03:46.240]  по сути это просто переставить вложок обратно
[01:03:46.240 --> 01:03:48.240]  что свободно
[01:03:48.240 --> 01:03:50.240]  но может быть
[01:03:50.240 --> 01:03:52.240]  вы объект не уничтожайте никакой, просто он существует
[01:03:52.240 --> 01:03:54.240]  между потоками, вы им пользуетесь по очереди
[01:03:54.240 --> 01:03:56.240]  но может быть у вас исключение
[01:03:56.240 --> 01:03:58.240]  или вы вышли из функции по другой причине какой-то
[01:03:58.240 --> 01:04:00.240]  и вы хотите в любом случае
[01:04:00.240 --> 01:04:02.240]  не забыть Unlock, сделать иначе все зависимы навечно
[01:04:02.240 --> 01:04:04.240]  они никогда не смогут зайти
[01:04:04.240 --> 01:04:06.240]  потому что будут вечно заняты
[01:04:06.240 --> 01:04:08.240]  вы забыли освободить и вышли
[01:04:08.240 --> 01:04:10.240]  вот это второй случай, когда нужно R.I.E
[01:04:10.240 --> 01:04:12.240]  это пример, что может делать Deleter
[01:04:12.240 --> 01:04:14.240]  кроме того, чтобы делать Deleter
[01:04:14.240 --> 01:04:16.240]  он может делать, например, Unlock
[01:04:16.240 --> 01:04:18.240]  он может говорить
[01:04:18.240 --> 01:04:20.240]  пометь там, что свободно
[01:04:20.240 --> 01:04:22.240]  перед выходом
[01:04:22.240 --> 01:04:24.240]  соответственно у вас возникает
[01:04:24.240 --> 01:04:26.240]  второй паттерн из поля
[01:04:26.240 --> 01:04:28.240]  через год
[01:04:28.240 --> 01:04:30.240]  пройдете
[01:04:30.240 --> 01:04:32.240]  на многопоточность
[01:04:32.240 --> 01:04:34.240]  когда будете многопоточность делать
[01:04:34.240 --> 01:04:36.240]  ну вот это просто пример того, где это может быть нужно
[01:04:36.240 --> 01:04:38.240]  кроме как освобождения
[01:04:38.240 --> 01:04:40.240]  можно вопрос?
[01:04:40.240 --> 01:04:42.240]  Make Share, я просто не помню, что он еще принимал
[01:04:42.240 --> 01:04:44.240]  он делает
[01:04:44.240 --> 01:04:46.240]  с оригинальным
[01:04:46.240 --> 01:04:48.240]  локатором и делитером
[01:04:48.240 --> 01:04:50.240]  Make Share
[01:04:50.240 --> 01:04:52.240]  значит, Make Share нельзя отдать кастомный делитер
[01:04:52.240 --> 01:04:54.240]  если вы делаете Make Share
[01:04:54.240 --> 01:04:56.240]  то вы просите
[01:04:56.240 --> 01:04:58.240]  его создать объект за вас
[01:04:58.240 --> 01:05:00.240]  ну тогда делитер
[01:05:00.240 --> 01:05:02.240]  Make Share это неуместно
[01:05:02.240 --> 01:05:04.240]  не совместимо с кастомным делитером
[01:05:04.240 --> 01:05:06.240]  хорошо, Allocate Share
[01:05:06.240 --> 01:05:08.240]  тоже самое
[01:05:08.240 --> 01:05:10.240]  Allocate?
[01:05:10.240 --> 01:05:12.240]  он должен его сохранить
[01:05:12.240 --> 01:05:14.240]  Значит, Allocate Share
[01:05:14.240 --> 01:05:16.240]  это по сути вы говорите
[01:05:16.240 --> 01:05:18.240]  создай объект за меня
[01:05:18.240 --> 01:05:20.240]  потом сам разберись как его удалять
[01:05:20.240 --> 01:05:22.240]  вопрос в том
[01:05:22.240 --> 01:05:24.240]  что хранит второй наследник
[01:05:24.240 --> 01:05:26.240]  да, что будет хранить второй наследник
[01:05:26.240 --> 01:05:28.240]  давайте это
[01:05:28.240 --> 01:05:30.240]  кажется, что между Allocate Share и Make Share
[01:05:30.240 --> 01:05:32.240]  он в одном случае должен хранить локатор, в другом не обязан
[01:05:32.240 --> 01:05:34.240]  почему же он хранит локатор
[01:05:34.240 --> 01:05:36.240]  не надо делать
[01:05:36.240 --> 01:05:38.240]  различия
[01:05:38.240 --> 01:05:40.240]  Make Share это просто частный случай Allocate Share
[01:05:40.240 --> 01:05:42.240]  со стандартным локатором
[01:05:42.240 --> 01:05:44.240]  не надо для него отдельно заводить
[01:05:44.240 --> 01:05:46.240]  давайте я напишу теперь еще один темплей
[01:05:46.240 --> 01:05:48.240]  TypeNameT
[01:05:52.240 --> 01:05:54.240]  почему я пишу TypeNameT
[01:05:54.240 --> 01:05:56.240]  TypeNameAlloc
[01:05:58.240 --> 01:06:00.240]  ну равно
[01:06:00.240 --> 01:06:02.240]  sdelocatorT
[01:06:02.240 --> 01:06:04.240]  структура
[01:06:04.240 --> 01:06:06.240]  какая структура
[01:06:06.240 --> 01:06:08.240]  структура
[01:06:08.240 --> 01:06:10.240]  ControlBlock
[01:06:10.240 --> 01:06:12.240]  пух
[01:06:16.240 --> 01:06:18.240]  не знаю как это назвать
[01:06:18.240 --> 01:06:20.240]  ControlBlock какой
[01:06:20.240 --> 01:06:22.240]  ну не регуляр
[01:06:22.240 --> 01:06:24.240]  ControlBlock Make Share
[01:06:24.240 --> 01:06:26.240]  ну не знаю
[01:06:30.240 --> 01:06:32.240]  тоже наследник Base ControlBlock
[01:06:32.240 --> 01:06:34.240]  а почему у нас первый регуляр
[01:06:34.240 --> 01:06:36.240]  ну типа
[01:06:36.240 --> 01:06:38.240]  стандартным способом создали
[01:06:38.240 --> 01:06:40.240]  стандартным способом это типа
[01:06:40.240 --> 01:06:42.240]  с кастомным дилитером, с кастомным локатором
[01:06:42.240 --> 01:06:44.240]  нет, стандартным это без Make Share
[01:06:44.240 --> 01:06:46.240]  да, окей, ладно
[01:06:46.240 --> 01:06:48.240]  и тогда может быть дилитер и локатор
[01:06:48.240 --> 01:06:50.240]  что здесь нам хранить надо
[01:06:52.240 --> 01:06:54.240]  ну нам по прежнему надо хранить локатор
[01:06:56.240 --> 01:06:58.240]  очевидно, а еще что
[01:06:58.240 --> 01:07:00.240]  а тут как раз надо будет хранить T
[01:07:00.240 --> 01:07:02.240]  не T звелочку, а уже именно T
[01:07:02.240 --> 01:07:04.240]  потому что T мы сами должны создать
[01:07:04.240 --> 01:07:06.240]  а дилитер уже не надо будет хранить
[01:07:06.240 --> 01:07:08.240]  есть еще проблема
[01:07:08.240 --> 01:07:10.240]  а мы
[01:07:10.240 --> 01:07:12.240]  к сожалению
[01:07:12.240 --> 01:07:14.240]  нам же друг между другом
[01:07:14.240 --> 01:07:16.240]  нужно уметь присваивать
[01:07:18.240 --> 01:07:20.240]  чего
[01:07:20.240 --> 01:07:22.240]  ну вот
[01:07:22.240 --> 01:07:24.240]  у нас
[01:07:24.240 --> 01:07:26.240]  хранился обычный
[01:07:26.240 --> 01:07:28.240]  ControlBlock
[01:07:28.240 --> 01:07:30.240]  а нам дали вот этот ControlBlock, нам нужно переприсваивать
[01:07:30.240 --> 01:07:32.240]  но вроде не страшно, мы все указательно храним
[01:07:32.240 --> 01:07:34.240]  какого-то удаления надо будет
[01:07:34.240 --> 01:07:36.240]  потом подумаем
[01:07:36.240 --> 01:07:38.240]  а
[01:07:38.240 --> 01:07:40.240]  хотелось бы
[01:07:40.240 --> 01:07:42.240]  ну хотя нет, можно переприсваивать
[01:07:42.240 --> 01:07:44.240]  дилитер
[01:07:44.240 --> 01:07:46.240]  у нас может быть ситуация
[01:08:04.240 --> 01:08:06.240]  значит
[01:08:06.240 --> 01:08:08.240]  у нас может быть
[01:08:08.240 --> 01:08:10.240]  какая ситуация
[01:08:10.240 --> 01:08:12.240]  что
[01:08:12.240 --> 01:08:14.240]  мы
[01:08:14.240 --> 01:08:16.240]  в этом ControlBlock
[01:08:16.240 --> 01:08:18.240]  объект мертв может быть
[01:08:18.240 --> 01:08:20.240]  проблема
[01:08:20.240 --> 01:08:22.240]  в чем
[01:08:22.240 --> 01:08:24.240]  ну у нас
[01:08:24.240 --> 01:08:26.240]  не получится type erasure
[01:08:26.240 --> 01:08:28.240]  в чистом бьюе
[01:08:28.240 --> 01:08:30.240]  как мы его реализовывали
[01:08:30.240 --> 01:08:32.240]  потому что смотрите у нас
[01:08:32.240 --> 01:08:34.240]  в том type erasure
[01:08:34.240 --> 01:08:36.240]  подразумевалось, что вот этот T
[01:08:36.240 --> 01:08:38.240]  он
[01:08:38.240 --> 01:08:40.240]  ну короче, нет
[01:08:40.240 --> 01:08:42.240]  не так, когда будет уничтожаться
[01:08:42.240 --> 01:08:44.240]  ControlBlock make shared
[01:08:44.240 --> 01:08:46.240]  он же будет уничтожаться
[01:08:46.240 --> 01:08:48.240]  он будет вызывать destructor T
[01:08:48.240 --> 01:08:50.240]  но бывает так, что
[01:08:50.240 --> 01:08:52.240]  объект T мертв на самом деле
[01:08:52.240 --> 01:08:54.240]  когда ControlBlock еще жив
[01:08:54.240 --> 01:08:56.240]  потому что может быть shared PTR умер раньше
[01:08:56.240 --> 01:08:58.240]  чем wig PTR
[01:08:58.240 --> 01:09:00.240]  а wig PTR же не хранит
[01:09:00.240 --> 01:09:02.240]  wig PTR хранит тот же ControlBlock
[01:09:02.240 --> 01:09:04.240]  как же, у нас общий с ними ControlBlock
[01:09:04.240 --> 01:09:06.240]  у нас ControlBlock
[01:09:06.240 --> 01:09:08.240]  в нем лежит объект
[01:09:08.240 --> 01:09:10.240]  но объект может быть убит shared PTR
[01:09:10.240 --> 01:09:12.240]  а еще на это все дело
[01:09:12.240 --> 01:09:14.240]  продолжать смотреть wig PTR
[01:09:14.240 --> 01:09:16.240]  и когда будет wig PTR умирать
[01:09:16.240 --> 01:09:18.240]  сейчас wig PTR убивает base ControlBlock
[01:09:18.240 --> 01:09:20.240]  wig PTR если он последним остался
[01:09:20.240 --> 01:09:22.240]  должен удалить всю вот эту байду
[01:09:22.240 --> 01:09:24.240]  с ControlBlock
[01:09:24.240 --> 01:09:26.240]  но ты уже удален
[01:09:26.240 --> 01:09:28.240]  ты уже уничтожен destructor
[01:09:28.240 --> 01:09:30.240]  destructor объекта T
[01:09:30.240 --> 01:09:32.240]  а wig PTR потом шикетит
[01:09:32.240 --> 01:09:34.240]  да, ну то есть все это еще продолжает существовать
[01:09:34.240 --> 01:09:36.240]  но объект уже мертв
[01:09:36.240 --> 01:09:38.240]  храним буль что-то там
[01:09:38.240 --> 01:09:40.240]  нет, ты когда будешь делать
[01:09:40.240 --> 01:09:42.240]  delete вот это все
[01:09:42.240 --> 01:09:44.240]  ControlBlock
[01:09:44.240 --> 01:09:46.240]  объект это поле
[01:09:46.240 --> 01:09:48.240]  если оно будет полем типа T
[01:09:48.240 --> 01:09:50.240]  то у тебя автоматически будет вызываться destructor T
[01:09:50.240 --> 01:09:52.240]  когда ты будешь уничтожать всю эту конструкцию
[01:09:52.240 --> 01:09:54.240]  о госпит, я не могу этого избежать
[01:09:54.240 --> 01:09:56.240]  поэтому нам придется здесь
[01:09:56.240 --> 01:09:58.240]  и конечно немножечко
[01:09:58.240 --> 01:10:00.240]  поступить
[01:10:00.240 --> 01:10:02.240]  некрасиво
[01:10:06.240 --> 01:10:08.240]  массив чара
[01:10:08.240 --> 01:10:10.240]  ну
[01:10:10.240 --> 01:10:12.240]  не антилизированный память
[01:10:12.240 --> 01:10:14.240]  здесь нужно просто количество
[01:10:14.240 --> 01:10:16.240]  ну то есть массив
[01:10:16.240 --> 01:10:18.240]  из стольких байд сколько нужно
[01:10:26.240 --> 01:10:28.240]  ну еще
[01:10:28.240 --> 01:10:30.240]  align of T
[01:10:30.240 --> 01:10:32.240]  align st
[01:10:32.240 --> 01:10:34.240]  здесь нужно писать предчат
[01:10:34.240 --> 01:10:36.240]  да
[01:10:38.240 --> 01:10:40.240]  вот вам new
[01:10:40.240 --> 01:10:42.240]  вот вам эстедуение
[01:10:44.240 --> 01:10:46.240]  так, поняли зачем
[01:10:46.240 --> 01:10:48.240]  так, ну короче когда будете писать
[01:10:48.240 --> 01:10:50.240]  поймете
[01:10:50.240 --> 01:10:52.240]  сколько людей здесь сдали лист
[01:10:52.240 --> 01:10:54.240]  ясно
[01:10:54.240 --> 01:10:56.240]  пока никто, потому что еще мы ни у кого не принес
[01:10:56.240 --> 01:10:58.240]  но только КТ сдало
[01:10:58.240 --> 01:11:00.240]  нет, вы что-то слушайте
[01:11:00.240 --> 01:11:02.240]  вы слабые какие-то
[01:11:02.240 --> 01:11:04.240]  в прошлом году вроде люди быстрее
[01:11:04.240 --> 01:11:06.240]  лист сдавали
[01:11:08.240 --> 01:11:10.240]  он просто такой
[01:11:10.240 --> 01:11:12.240]  ну сейчас будете писать, поймете
[01:11:12.240 --> 01:11:14.240]  а кто это вообще писать-то будет
[01:11:14.240 --> 01:11:16.240]  кстати, хорошо просто
[01:11:16.240 --> 01:11:18.240]  ну нет, Семен точно будет писать
[01:11:18.240 --> 01:11:20.240]  это я знаю
[01:11:20.240 --> 01:11:22.240]  я надеюсь, что эту задачу еще
[01:11:22.240 --> 01:11:24.240]  я надеюсь еще
[01:11:24.240 --> 01:11:26.240]  10
[01:11:26.240 --> 01:11:28.240]  я рассчитываю, что ее зовут больше, чем сейчас
[01:11:28.240 --> 01:11:30.240]  здесь людей
[01:11:30.240 --> 01:11:32.240]  зачем мы храним массив чаров
[01:11:32.240 --> 01:11:34.240]  мы его прикастуем к Т
[01:11:34.240 --> 01:11:36.240]  еще раз
[01:11:36.240 --> 01:11:38.240]  у нас возможна ситуация, что
[01:11:38.240 --> 01:11:40.240]  тут
[01:11:40.240 --> 01:11:42.240]  мертвый объект
[01:11:42.240 --> 01:11:44.240]  но контроллок еще не удален
[01:11:44.240 --> 01:11:46.240]  есть проблема
[01:11:46.240 --> 01:11:48.240]  деструктор объекта
[01:11:48.240 --> 01:11:50.240]  мы не можем избежать того, чтобы он вызывал деструкторы своих
[01:11:50.240 --> 01:11:52.240]  я понимаю
[01:11:52.240 --> 01:11:54.240]  поэтому если мы храним объект Т
[01:11:54.240 --> 01:11:56.240]  мы обосрались
[01:11:56.240 --> 01:11:58.240]  теперь мы храним массив чаров
[01:11:58.240 --> 01:12:00.240]  и реинтерпреткастим его каждый раз
[01:12:00.240 --> 01:12:02.240]  и все
[01:12:02.240 --> 01:12:04.240]  хорошо, а нельзя хранить Звездочку тут
[01:12:04.240 --> 01:12:06.240]  плохо
[01:12:06.240 --> 01:12:08.240]  Т же где-то нужно хранить
[01:12:08.240 --> 01:12:10.240]  вот тут, на куче
[01:12:10.240 --> 01:12:12.240]  через Нью, через Аллок
[01:12:12.240 --> 01:12:14.240]  на самом деле
[01:12:14.240 --> 01:12:16.240]  на самом деле
[01:12:16.240 --> 01:12:18.240]  что
[01:12:18.240 --> 01:12:20.240]  тоже будет хорошо
[01:12:20.240 --> 01:12:22.240]  это вместе с
[01:12:22.240 --> 01:12:24.240]  это просто унифицированное
[01:12:24.240 --> 01:12:26.240]  для того, чтобы унифицированно
[01:12:26.240 --> 01:12:28.240]  все работало, удобно здесь тоже хранить
[01:12:28.240 --> 01:12:30.240]  Звездочку ПТР, как и здесь
[01:12:30.240 --> 01:12:32.240]  чтобы
[01:12:32.240 --> 01:12:34.240]  это будет указатель
[01:12:34.240 --> 01:12:36.240]  на эту же штуку
[01:12:36.240 --> 01:12:38.240]  в полях мы храним указатель
[01:12:38.240 --> 01:12:40.240]  на бейс контроллок, а еще Звездочку
[01:12:40.240 --> 01:12:42.240]  чтобы быстрее обращаться
[01:12:42.240 --> 01:12:44.240]  и
[01:12:44.240 --> 01:12:46.240]  какая еще проблема есть
[01:12:46.240 --> 01:12:48.240]  вот какая
[01:12:48.240 --> 01:12:50.240]  дело в том, что
[01:12:50.240 --> 01:12:52.240]  у нас же может в Шеред ПТР
[01:12:52.240 --> 01:12:54.240]  лежать не Т на самом деле
[01:12:54.240 --> 01:12:56.240]  а У, где У наследник Т
[01:12:56.240 --> 01:12:58.240]  нет, нет, нет
[01:13:00.240 --> 01:13:02.240]  и что делать
[01:13:02.240 --> 01:13:04.240]  поэтому здесь все-таки нужен там
[01:13:04.240 --> 01:13:06.240]  nameT, там nameU еще
[01:13:06.240 --> 01:13:08.240]  и там тоже?
[01:13:08.240 --> 01:13:10.240]  потому что здесь реально object может быть не типа Т
[01:13:10.240 --> 01:13:12.240]  а что разница?
[01:13:12.240 --> 01:13:14.240]  здесь, кстати, может и не нужен
[01:13:14.240 --> 01:13:16.240]  тут точно нужен, потому что тут
[01:13:16.240 --> 01:13:18.240]  реально мы можем хранить объект не типа Т
[01:13:18.240 --> 01:13:20.240]  вот здесь точно нужен еще один шаблонный параметр
[01:13:20.240 --> 01:13:22.240]  У, потому что это может быть
[01:13:22.240 --> 01:13:24.240]  реально не Т, а что-то большее, чем Т
[01:13:24.240 --> 01:13:26.240]  прям реально
[01:13:26.240 --> 01:13:28.240]  большее
[01:13:28.240 --> 01:13:30.240]  но указатель можно хранить
[01:13:30.240 --> 01:13:32.240]  на
[01:13:32.240 --> 01:13:34.240]  не уверен
[01:13:34.240 --> 01:13:36.240]  надо подумать
[01:13:36.240 --> 01:13:38.240]  ну вот здесь
[01:13:38.240 --> 01:13:40.240]  мы можем хранить указатель на Т, а тут
[01:13:40.240 --> 01:13:42.240]  может быть и на У хранить
[01:13:42.240 --> 01:13:44.240]  ну если я что-то забыл сказать
[01:13:44.240 --> 01:13:46.240]  то, наверное, я завтра это скажу еще
[01:13:46.240 --> 01:13:48.240]  или там, когда вошли
[01:13:48.240 --> 01:13:50.240]  у нас как работает?
[01:13:50.240 --> 01:13:52.240]  у нас не осталось для НУ Шеред ПТР на объект
[01:13:52.240 --> 01:13:54.240]  а остались в ВИК, а когда все удалится?
[01:13:54.240 --> 01:13:56.240]  память освободится
[01:13:56.240 --> 01:13:58.240]  только когда умрет последний ВИК ПТР
[01:13:58.240 --> 01:14:00.240]  а дилитер вызовется, когда
[01:14:00.240 --> 01:14:02.240]  да, когда Шеред ПТР
[01:14:02.240 --> 01:14:04.240]  последний умирает, он вызывает дилитер
[01:14:04.240 --> 01:14:06.240]  на вот эту штуку, и тем самым действуют
[01:14:06.240 --> 01:14:08.240]  просто массив чаров
[01:14:08.240 --> 01:14:10.240]  а когда умирает последний ВИК ПТР, он
[01:14:10.240 --> 01:14:12.240]  делает дилокей
[01:14:12.240 --> 01:14:14.240]  и там кто-то жаловался
[01:14:14.240 --> 01:14:16.240]  где-то там у нас такой орфлоу, что память
[01:14:16.240 --> 01:14:18.240]  не освобождается
[01:14:18.240 --> 01:14:20.240]  да, это я вам рассказывал в прошлый раз
[01:14:20.240 --> 01:14:22.240]  ну тут еще проблема есть в том, что вам нужен
[01:14:22.240 --> 01:14:24.240]  аллокатор, это будет аллокатор на Т
[01:14:24.240 --> 01:14:26.240]  а вам нужно будет из него сделать аллокатор
[01:14:26.240 --> 01:14:28.240]  на вот эту все
