[00:00.000 --> 00:08.120]  Прошлый семинар прошел по такому сценарию.
[00:08.120 --> 00:12.600]  Мы сначала обсудили какие-то вопросы, накопившиеся по
[00:12.600 --> 00:13.600]  домашним задачам.
[00:13.600 --> 00:17.040]  Что мы там делаем, почему мы делаем именно так.
[00:17.040 --> 00:21.200]  А второй половины мы начали говорить про тестирование.
[00:21.200 --> 00:24.640]  У меня есть план рассказать вам, как устроено тестирование
[00:24.640 --> 00:27.360]  в нашем курсе, как устроено вообще тестирование подобных
[00:27.360 --> 00:28.360]  вещей, которые мы пишем.
[00:28.360 --> 00:46.240]  Мы еще хотели про стег договорить, да, это правда.
[00:46.240 --> 00:49.960]  Начнем с этого, потом поговорим про вопросы, которые у нас
[00:49.960 --> 00:53.120]  в задачах есть, и отдельный топик, который мы, наверное,
[00:53.120 --> 00:55.520]  сегодня не успеем разобрать, если все пойдет хорошо.
[00:55.520 --> 00:59.520]  Это тестирование про санитайзеры, про fault injection, про все
[00:59.520 --> 01:01.440]  механики, которые в нашем курсе используются, потому
[01:01.440 --> 01:05.160]  что мне кажется, что без этого писать сложный конкурентный
[01:05.160 --> 01:09.520]  код хорошего качества, надежный, невозможно.
[01:09.520 --> 01:12.320]  И вообще, тестирование это то, о чем нужно подумать.
[01:12.320 --> 01:14.240]  Если мы говорим про большие и сложные проекты, то тестирование
[01:14.240 --> 01:16.840]  это то, о чем нужно подумать в самом начале, потому что
[01:16.840 --> 01:18.360]  иначе потом будет уже поздно.
[01:18.360 --> 01:24.960]  Ну что, давайте с чего-то начнем, и начнем, вы говорите
[01:24.960 --> 01:28.840]  начнем со стеков, которые мы разбирали в прошлый раз.
[01:28.840 --> 01:37.840]  Ну хорошо, тогда мы переместимся сейчас на экран, на доску,
[01:54.960 --> 02:14.840]  чтобы у файмеров стеки не качались, и мы столкнулись
[02:14.840 --> 02:17.560]  с тем, что совершенно наивно действовать нельзя, потому
[02:17.560 --> 02:22.040]  что, может быть, совершенно, давайте по порядку, стеки
[02:23.040 --> 02:24.040]  не могут переполняться.
[02:24.040 --> 02:25.040]  Мы полоцируем как файмер стеков с фиксированного
[02:25.040 --> 02:26.040]  размера.
[02:26.040 --> 02:27.040]  Он может, разумеется, закончиться, но я не знаю почему.
[02:27.040 --> 02:28.040]  Не только потому, что он бесконечная реку, а потому,
[02:28.040 --> 02:29.040]  что мы пишем в использовании какие-то очень большие и
[02:29.040 --> 02:30.040]  сложные библиотеки, в которых огромное количество
[02:30.040 --> 02:31.040]  различных вызовов, аргументов, и вот стек наш переполнился.
[02:31.040 --> 02:32.040]  Первое, о чем мы должны позаботиться, это о том, чтобы программа
[02:32.040 --> 02:33.040]  от этого, наоборот, упал, можно быстрее, потому что
[02:33.040 --> 02:34.040]  программа, которая не работает, не может сделать ничего
[02:34.040 --> 02:35.040]  плохого.
[02:35.040 --> 02:36.040]  Программа, которая работает, она неправильная, может
[02:36.040 --> 02:37.040]  навредить.
[02:37.040 --> 02:38.040]  Поэтому первое, что мы сделали в прошлый раз, сказали,
[02:38.040 --> 02:39.040]  что у нас есть фамилия с будинной подстек.
[02:39.040 --> 02:40.040]  И мы сделали, что у нас есть фамилия с будинной
[02:40.040 --> 02:41.040]  подстек.
[02:41.040 --> 02:42.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:42.040 --> 02:43.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:43.040 --> 02:44.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:44.040 --> 02:45.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:45.040 --> 02:46.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:46.040 --> 02:47.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:47.040 --> 02:48.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:48.040 --> 02:49.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:49.040 --> 02:50.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:50.040 --> 02:51.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:51.040 --> 02:52.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:52.040 --> 02:53.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:53.040 --> 02:54.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:54.040 --> 02:55.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:55.040 --> 02:56.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:56.040 --> 02:57.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:57.040 --> 02:58.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:58.040 --> 02:59.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[02:59.040 --> 03:00.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:00.040 --> 03:01.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:01.040 --> 03:02.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:02.040 --> 03:03.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:03.040 --> 03:04.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:04.040 --> 03:05.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:05.040 --> 03:06.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:06.040 --> 03:07.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:07.040 --> 03:08.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:08.040 --> 03:09.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:09.040 --> 03:10.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:10.040 --> 03:11.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:11.040 --> 03:12.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:12.040 --> 03:13.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:13.040 --> 03:14.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:14.040 --> 03:15.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:15.040 --> 03:16.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:16.040 --> 03:17.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:17.040 --> 03:18.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:18.040 --> 03:19.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:19.040 --> 03:20.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:20.040 --> 03:21.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:21.040 --> 03:22.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:22.040 --> 03:23.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:23.040 --> 03:24.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:24.040 --> 03:25.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:25.040 --> 03:26.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:26.040 --> 03:27.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:27.040 --> 03:28.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:28.040 --> 03:29.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:29.040 --> 03:30.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:30.040 --> 03:31.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:31.040 --> 03:32.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:32.040 --> 03:33.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:33.040 --> 03:34.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:34.040 --> 03:35.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:35.040 --> 03:36.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:36.040 --> 03:37.040]  И мы сделали, что у нас есть фамилия с будинной подстек.
[03:37.040 --> 03:38.040]  Хорошая практика.
[03:38.040 --> 03:39.040]  Хорошая практика.
[03:39.040 --> 03:40.040]  Пожалуйста, следуйте игре.
[03:40.040 --> 03:41.040]  Пожалуйста, следуйте игре.
[03:41.040 --> 03:42.040]  Пожалуйста, следуйте игре.
[03:42.040 --> 03:43.040]  Если этой страницы guard page не будет, она называется,
[03:43.040 --> 03:44.040]  Если этой страницы guard page не будет, она называется,
[03:44.040 --> 03:45.040]  если этой страницы guard page не будет, она называется,
[03:45.040 --> 03:46.040]  если этой страницы guard page не будет, она называется,
[03:46.040 --> 03:47.040]  если этой страницы guard page не будет, она называется,
[03:47.040 --> 03:48.040]  если этой страницы guard page не будет, она называется,
[03:48.040 --> 03:49.040]  если этой страницы guard page не будет, она называется,
[03:49.040 --> 03:50.040]  если этой страницы guard page не будет, она называется,
[03:50.040 --> 03:51.040]  если этой страницы guard page не будет, она называется,
[03:51.040 --> 03:52.040]  если этой страницы guard page не будет, она называется,
[03:52.040 --> 03:53.040]  если этой страницы guard page не будет, она называется,
[03:53.040 --> 03:54.040]  если этой страницы guard page не будет, она называется,
[03:54.040 --> 03:55.040]  если этой страницы guard page не будет, она называется,
[03:55.040 --> 03:56.040]  если этой страницы guard page не будет, она называется,
[03:56.040 --> 03:57.040]  если этой страницы guard page не будет, она называется,
[03:57.040 --> 03:58.040]  если этой страницы guard page не будет, она называется,
[03:58.040 --> 03:59.040]  если этой страницы guard page не будет, она называется,
[03:59.040 --> 04:00.040]  если этой страницы guard page не будет, она называется,
[04:00.040 --> 04:01.040]  если этой страницы guard page не будет, она называется,
[04:01.040 --> 04:02.040]  если этой страницы guard page не будет, она называется,
[04:02.040 --> 04:03.040]  если этой страницы guard page не будет, она называется,
[04:03.040 --> 04:04.040]  если этой страницы guard page не будет, она называется,
[04:04.040 --> 04:05.040]  если этой страницы guard page не будет, она называется,
[04:05.040 --> 04:06.040]  если этой страницы guard page не будет, она называется,
[04:06.040 --> 04:07.040]  если этой страницы guard page не будет, она называется,
[04:07.040 --> 04:08.040]  ну и первая наивная попытка состояла в том,
[04:08.040 --> 04:09.040]  что мы пытались выделить новую память под stack
[04:09.040 --> 04:10.040]  ну и первая наивная попытка состояла в том,
[04:10.040 --> 04:11.040]  что мы пытались выделить новую память под stack
[04:11.040 --> 04:12.040]  ну и первая наивная попытка состояла в том,
[04:12.040 --> 04:13.040]  что мы пытались выделить новую память под stack
[04:13.040 --> 04:14.040]  ну и первая наивная попытка состояла в том,
[04:14.040 --> 04:15.040]  что мы пытались выделить новую память под stack
[04:15.040 --> 04:16.040]  ну и первая наивная попытка состояла в том,
[04:16.040 --> 04:17.040]  что мы пытались выделить новую память под stack
[04:17.040 --> 04:18.040]  ну и первая наивная попытка состояла в том,
[04:18.040 --> 04:19.040]  что мы пытались выделить новую память под stack
[04:19.040 --> 04:20.040]  ну и первая наивная попытка состояла в том,
[04:20.040 --> 04:21.040]  что мы пытались выделить новую память под stack
[04:21.040 --> 04:22.040]  ну и первая наивная попытка состояла в том,
[04:22.040 --> 04:23.040]  что мы пытались выделить новую память под stack
[04:23.040 --> 04:24.040]  ну и первая наивная попытка состояла в том,
[04:24.040 --> 04:25.040]  что мы пытались выделить новую память под stack
[04:25.040 --> 04:26.040]  ну и первая наивная попытка состояла в том,
[04:26.040 --> 04:27.040]  что мы пытались выделить новую память под stack
[04:27.040 --> 04:28.040]  ну и первая наивная попытка состояла в том,
[04:28.040 --> 04:29.040]  что мы пытались выделить новую память под stack
[04:29.040 --> 04:30.040]  ну и первая наивная попытка состояла в том,
[04:30.040 --> 04:31.040]  что мы пытались выделить новую память под stack
[04:31.040 --> 04:32.040]  ну и первая наивная попытка состояла в том,
[04:32.040 --> 04:33.040]  что мы пытались выделить новую память под stack
[04:33.040 --> 04:34.040]  ну и первая наивная попытка состояла в том,
[04:34.040 --> 04:35.040]  что мы пытались выделить новую память под stack
[04:35.040 --> 04:36.040]  ну и первая наивная попытка состояла в том,
[04:36.040 --> 04:37.040]  что мы пытались выделить новую память под stack
[04:37.040 --> 04:38.040]  ну и первая наивная попытка состояла в том,
[04:38.040 --> 04:39.040]  что мы пытались выделить новую память под stack
[04:39.040 --> 04:40.040]  ну и первая наивная попытка состояла в том,
[04:40.040 --> 04:41.040]  что мы пытались выделить новую память под stack
[04:41.040 --> 04:42.040]  ну и первая наивная попытка состояла в том,
[04:42.040 --> 04:43.040]  что мы пытались выделить новую память под stack
[04:43.040 --> 04:44.040]  ну и первая наивная попытка состояла в том,
[04:44.040 --> 04:45.040]  что мы пытались выделить новую память под stack
[04:45.040 --> 04:46.040]  ну и первая наивная попытка состояла в том,
[04:46.040 --> 04:47.040]  что мы пытались выделить новую память под stack
[04:47.040 --> 04:48.040]  ну и первая наивная попытка состояла в том,
[04:48.040 --> 04:49.040]  что мы пытались выделить новую память под stack
[04:49.040 --> 04:50.040]  ну и первая наивная попытка состояла в том,
[04:50.040 --> 04:51.040]  что мы пытались выделить новую память под stack
[04:51.040 --> 04:52.040]  ну и первая наивная попытка состояла в том,
[04:52.040 --> 04:53.040]  что мы пытались выделить новую память под stack
[04:53.040 --> 04:54.040]  ну и первая наивная попытка состояла в том,
[04:54.040 --> 04:55.040]  что мы пытались выделить новую память под stack
[04:55.040 --> 04:56.040]  ну и первая наивная попытка состояла в том,
[04:56.040 --> 04:57.040]  что мы пытались выделить новую память под stack
[04:57.040 --> 04:58.040]  ну и первая наивная попытка состояла в том,
[04:58.040 --> 04:59.040]  что мы пытались выделить новую память под stack
[04:59.040 --> 05:00.040]  ну и первая наивная попытка состояла в том,
[05:00.040 --> 05:01.040]  что мы пытались выделить новую память под stack
[05:01.040 --> 05:02.040]  ну и первая наивная попытка состояла в том,
[05:02.040 --> 05:03.040]  что мы пытались выделить новую память под stack
[05:03.040 --> 05:04.040]  ну и первая наивная попытка состояла в том,
[05:04.040 --> 05:05.040]  что мы пытались выделить новую память под stack
[05:05.040 --> 05:06.040]  ну и первая наивная попытка состояла в том,
[05:06.040 --> 05:07.040]  что мы пытались выделить новую память под stack
[05:07.040 --> 05:08.040]  ну и первая наивная попытка состояла в том,
[05:08.040 --> 05:09.040]  что мы пытались выделить новую память под stack
[05:09.040 --> 05:10.040]  ну и первая наивная попытка состояла в том,
[05:10.040 --> 05:11.040]  что мы пытались выделить новую память под stack
[05:11.040 --> 05:12.040]  ну и первая наивная попытка состояла в том,
[05:12.040 --> 05:13.040]  что мы пытались выделить новую память под stack
[05:13.040 --> 05:14.040]  ну и первая наивная попытка состояла в том,
[05:14.040 --> 05:15.040]  что мы пытались выделить новую память под stack
[05:15.040 --> 05:16.040]  ну и первая наивная попытка состояла в том,
[05:16.040 --> 05:17.040]  что мы пытались выделить новую память под stack
[05:18.040 --> 05:19.040]  есть две проблемы
[05:19.040 --> 05:20.040]  первая проблема стоит в том,
[05:20.040 --> 05:22.040]  что вот у вас в программе есть
[05:22.040 --> 05:25.040]  какие внутренние ссылки
[05:25.040 --> 05:28.040]  у вас на stack лежит какая-то
[05:28.040 --> 05:30.040]  вы написали функцию,
[05:30.040 --> 05:31.040]  в ней ваша переменная
[05:31.040 --> 05:33.040]  его ссылка идет перед революционной функцией
[05:33.040 --> 05:34.040]  его ссылка идет перед революционной функцией
[05:34.040 --> 05:36.040]  теперь у вас где-то на stack есть ящик памяти,
[05:36.040 --> 05:37.040]  которая следует надо из любой ящики на stack
[05:37.040 --> 05:38.040]  теперь у вас где-то на stack есть ящик памяти,
[05:38.040 --> 05:39.040]  которая следует надо из любой ящики на stack
[05:39.040 --> 05:40.040]  если вы просто скопируете память,
[05:40.040 --> 05:41.040]  если вы просто скопируете память,
[05:41.040 --> 05:42.040]  если вы просто скопируете память,
[05:42.040 --> 05:43.040]  как вот на CBI,
[05:43.040 --> 05:44.040]  то вы получите, что на этом stack
[05:44.040 --> 05:45.040]  то вы получите, что на этом stack
[05:45.040 --> 05:47.040]  давайте слайдить вот сюда
[05:47.040 --> 05:49.040]  неприятная история
[05:49.040 --> 05:51.040]  давайте подумаем,
[05:51.040 --> 05:55.040]  как можно было бы эту проблему разрешить
[05:55.040 --> 05:59.040]  давайте даже не будем думать,
[05:59.040 --> 06:01.040]  как ее разрешить
[06:01.040 --> 06:03.040]  потому что одна проблема есть
[06:03.040 --> 06:05.040]  и, может быть, нужно делать и не так, и не так,
[06:05.040 --> 06:08.040]  а каким-то третьим способом
[06:08.040 --> 06:10.040]  вот третий способ состоит в том,
[06:10.040 --> 06:13.040]  что давайте я, к сожалению, вернусь
[06:13.040 --> 06:17.040]  я не буду опускать проект,
[06:17.040 --> 06:19.040]  чтобы нам не было выпить
[06:19.040 --> 06:21.040]  долго
[06:23.040 --> 06:25.040]  не работает, да?
[06:25.040 --> 06:26.040]  работает
[06:26.040 --> 06:28.040]  ну давайте я так покажу
[06:39.040 --> 06:40.040]  есть альтернативный подход,
[06:40.040 --> 06:49.040]  который состоит в том,
[06:49.040 --> 06:53.040]  что мы перестаем считать stack непрерывным
[06:53.040 --> 06:55.040]  то есть у нас stack заканчивается
[06:55.040 --> 06:57.040]  и мы выделяем просто для stack
[06:57.040 --> 06:58.040]  новый сегмент
[06:58.040 --> 06:59.040]  мы не переносим память,
[06:59.040 --> 07:02.040]  потому что тогда вот у нас поедут все ссылки
[07:02.040 --> 07:04.040]  мы просто алоцируем новый сегмент stack
[07:04.040 --> 07:06.040]  и живем на нем
[07:06.040 --> 07:08.040]  ну, конечно же, так работать не будет,
[07:08.040 --> 07:10.040]  потому что процессор-то он ожидает
[07:10.040 --> 07:12.040]  непрерывного stack'а
[07:12.040 --> 07:13.040]  он уже код скомпилировал,
[07:13.040 --> 07:16.040]  а под ним вот внезапно stack меняется
[07:16.040 --> 07:18.040]  поэтому так можно делать
[07:18.040 --> 07:20.040]  это называется сегментированные stack'и
[07:20.040 --> 07:23.040]  но так можно делать только если вы компилятор
[07:23.040 --> 07:25.040]  то есть вы говорите компилятору,
[07:25.040 --> 07:28.040]  что я хочу использовать сегментированные stack'и
[07:28.040 --> 07:32.040]  и он в начале каждой функции
[07:32.040 --> 07:35.040]  помещает специальный пролог
[07:35.040 --> 07:37.040]  в котором что он делает
[07:37.040 --> 07:39.040]  но он прикидывает сколько stack'а
[07:39.040 --> 07:41.040]  компилятор же компилирует функцию
[07:41.040 --> 07:44.040]  он знает, каков размер ее stack'ового фрейма
[07:44.040 --> 07:46.040]  тут есть какие-то маргинальные исключения
[07:46.040 --> 07:49.040]  типа динамическая локация на stack'е, функция лока
[07:49.040 --> 07:51.040]  но, допустим, нормальные люди мы ее не зовем
[07:51.040 --> 07:54.040]  поэтому мы знаем, каков размер наш stack'овый фрейм
[07:54.040 --> 07:57.040]  мы записываем, где он должен кончиться
[07:57.040 --> 07:59.040]  там в R10
[07:59.040 --> 08:02.040]  а потом мы из thread-локальной переменной
[08:02.040 --> 08:05.040]  мы сравниваем вот это значение
[08:05.040 --> 08:07.040]  границы очередного stack'ового фрейма
[08:07.040 --> 08:09.040]  с границей stack'а
[08:09.040 --> 08:11.040]  и если оказывается, что нам не хватает
[08:11.040 --> 08:13.040]  текущего stack'а
[08:13.040 --> 08:16.040]  для того, чтобы выполнить текущий вызов функции
[08:16.040 --> 08:20.040]  то мы вызываем служебную процедуру
[08:20.040 --> 08:23.040]  локации нового сегмента stack'а
[08:23.040 --> 08:27.040]  и как бы перепозиционируемся относительно него
[08:27.040 --> 08:31.040]  вот эта проверка и перепозиционирование Rasp
[08:31.040 --> 08:34.040]  разумеется может сделать только сам компилятор
[08:34.040 --> 08:39.040]  но поэтому мы сообщаем флажком специальным
[08:39.040 --> 08:42.040]  что мы собираемся алоцировать stack таким образом
[08:42.040 --> 08:45.040]  наращивать его и назвать здесь stacklet
[08:45.040 --> 08:50.040]  и вот происходит перепозиционирование в случае падания на границу
[08:50.040 --> 08:53.040]  но это некоторый оверхед
[08:53.040 --> 08:56.040]  то есть вы добавляете такую прологу каждую функцию
[08:56.040 --> 08:59.040]  но если предположить, что stack будет переполнится нечасто
[08:59.040 --> 09:02.040]  то это в конце концов одно сравнение с thread-локальной переменной
[09:02.040 --> 09:05.040]  кажется, что это не очень дорого
[09:05.040 --> 09:08.040]  но беда не в этом
[09:08.040 --> 09:11.040]  вообще, решения рабочие так можно делать
[09:11.040 --> 09:13.040]  так можно расширять stack'и
[09:13.040 --> 09:16.040]  и так пытались делать
[09:16.040 --> 09:19.040]  в го, кажется, пытались так делать
[09:19.040 --> 09:21.040]  и в расти так пытались делать
[09:21.040 --> 09:24.040]  но в зале времен в расти было еще совсем по-другому
[09:24.040 --> 09:27.040]  но тем не менее
[09:28.040 --> 09:31.040]  в ссылках к курсу есть
[09:31.040 --> 09:34.040]  сейчас я найду ее
[09:34.040 --> 09:37.040]  неожиданно у меня застались этими stack'ами
[09:40.040 --> 09:43.040]  короткая статья с интересными ссылками на обсуждение
[09:43.040 --> 09:46.040]  конкретное от одного из разработчиков языка Rast
[09:46.040 --> 09:49.040]  и там он описывает такую трудность
[09:49.040 --> 09:53.040]  почему сегментированные stack'и плохо подходят к такому
[09:53.040 --> 09:56.040]  потому что у них совершенно непредсказуемая модель стоимости
[09:56.040 --> 09:59.040]  вам очень сложно под них оптимизировать код
[09:59.040 --> 10:02.040]  почему?
[10:02.040 --> 10:05.040]  но представьте себе, что у вас есть какой-нибудь цикл
[10:05.040 --> 10:08.040]  в котором очень много, очень часто вызывается какая-то функция
[10:08.040 --> 10:11.040]  и вот
[10:11.040 --> 10:14.040]  вызов этой функции выпадает на границу stack'ов
[10:14.040 --> 10:17.040]  и нужно какие-то нетриальные действия совершать
[10:17.040 --> 10:20.040]  было бы хорошо, если бы у вас был такой цикл
[10:20.040 --> 10:23.040]  а теперь представим, что вы повлияли
[10:23.040 --> 10:26.040]  вы пооптимизировали, чтобы такого не было у вас
[10:26.040 --> 10:29.040]  а потом приходит новый сотрудник в вашу команду
[10:29.040 --> 10:32.040]  и рефакторит код
[10:32.040 --> 10:35.040]  и пишет какие-нибудь дополнительные вызовы функции
[10:35.040 --> 10:38.040]  что-то там
[10:38.040 --> 10:41.040]  что-то такое
[10:41.040 --> 10:44.040]  что-то такое
[10:44.040 --> 10:47.040]  что-то такое
[10:47.040 --> 10:50.040]  какие-нибудь дополнительные вызовы функции
[10:50.040 --> 10:53.040]  выделяет методы
[10:53.040 --> 10:56.040]  и ваш stack немного сдвигается
[10:56.040 --> 10:59.040]  и вот вы снова попадаете на эту границу
[10:59.040 --> 11:02.040]  и это же контролировать совершенно невозможно
[11:02.040 --> 11:05.040]  невозможно предсказать, потому что вот эти границы stack'ов
[11:05.040 --> 11:08.040]  они в коде не заметны, они прозрачны
[11:08.040 --> 11:11.040]  в итоге просто невозможно
[11:11.040 --> 11:14.040]  учитывать вот этот overhead, невозможно на него влиять
[11:14.040 --> 11:17.040]  невозможно его предсказывать при написании кода
[11:17.040 --> 11:20.040]  так что такой подход существует, но от него в итоге
[11:20.040 --> 11:23.040]  отказались
[11:25.040 --> 11:28.040]  возвращаемся на доску
[11:28.040 --> 11:31.040]  ну вот в Rust'е говорят, что
[11:31.040 --> 11:34.040]  future в Rust'е — это вот такой
[11:34.040 --> 11:37.040]  perfectly sized stack, что это значит, это отдельная история
[11:37.040 --> 11:40.040]  мы однажды про это поговорим
[11:40.040 --> 11:43.040]  где-то уже в апреле, наверное, не быстро
[11:43.040 --> 11:46.040]  а пока
[11:46.040 --> 11:49.040]  проблема
[11:49.040 --> 11:52.040]  как проблему можно все-таки решить?
[11:52.040 --> 11:55.040]  проблему можно решить в очень красивый способ
[11:55.040 --> 11:58.040]  мне кажется, безумно красиво, но только если вы пишете свое загомирование
[11:58.040 --> 12:01.040]  вот скажем, решить проблему на уровне блячечи трудно
[12:01.040 --> 12:04.040]  а вот если вы пишете свой собственный год, то внезапно у вас появляются инструменты
[12:04.040 --> 12:07.040]  и мне кажется, что сочетание идеи
[12:07.040 --> 12:10.040]  и сочетание разных механик обезумительно
[12:10.040 --> 12:13.040]  смотрите, первая проблема
[12:13.040 --> 12:16.040]  вот есть такие ссылки
[12:16.040 --> 12:19.040]  что мы могли бы делать, если бы написали за плюс-плюс?
[12:19.040 --> 12:22.040]  ну, мы бы изобрели какую-то иллюмистику
[12:22.040 --> 12:25.040]  мы бы пошли просто по 8 байтовым кусочкам
[12:25.040 --> 12:28.040]  стака и смотрели
[12:28.040 --> 12:31.040]  если содержимый кусочек похожего поэта
[12:31.040 --> 12:34.040]  то есть вкладывается в диапазон
[12:34.040 --> 12:37.040]  то, возможно, это ссылка на наш собственный stack
[12:37.040 --> 12:40.040]  и нужно ее исправить подсюда
[12:43.040 --> 12:46.040]  будет ли это работать?
[12:46.040 --> 12:49.040]  точнее, и на пяток делаем
[12:49.040 --> 12:52.040]  вот скажем, есть попытки написать сборщик мусора
[12:52.040 --> 12:55.040]  за с плюс-плюс, слышали вы такое?
[12:55.040 --> 12:58.040]  вы слышали, там нужно с чего начать?
[12:58.040 --> 13:01.040]  там нужно открыть графобъект, искать живые объекты
[13:01.040 --> 13:04.040]  а для того чтобы искать живые объекты
[13:04.040 --> 13:07.040]  нужно с чего-то начать, с чего обычно начинают?
[13:07.040 --> 13:10.040]  начинают с того, что называется gc-рус
[13:10.040 --> 13:13.040]  чтобы попасть в какой-то объект, вы же в первую очередь
[13:13.040 --> 13:16.040]  в первую очередь вращаетесь в какие-то перемены
[13:16.040 --> 13:19.040]  локальные перемены, то есть все пути в кучу идут со stack
[13:19.040 --> 13:22.040]  и вот если вы пишете сборщик мусора
[13:22.040 --> 13:25.040]  то нужно понимать, какие ссылки со stack ведут
[13:25.040 --> 13:28.040]  вот если вы пишете такой консервативный
[13:28.040 --> 13:31.040]  бочек мусора, на с плюс-плюс даже
[13:31.040 --> 13:34.040]  то вы используете такую рейстику, что это значение
[13:34.040 --> 13:37.040]  памяти похоже на Пойнтер
[13:37.040 --> 13:40.040]  вы увидите это Пойнтер
[13:40.040 --> 13:43.040]  то сборщик мусора не безопасен, потому что вы рассматриваете
[13:43.040 --> 13:46.040]  если на бурбайке Пойнтер, он куда-то ведет
[13:46.040 --> 13:49.040]  и возможно в эту память не соберется
[13:49.040 --> 13:52.040]  ничего плохого не случится
[13:52.040 --> 13:55.040]  ну а здесь если мы перепутаем, то будет плохо
[13:56.040 --> 13:59.040]  как помогает то, что мы пишем го
[13:59.040 --> 14:02.040]  и это такое
[14:02.040 --> 14:05.040]  го есть техническая сборка мусора
[14:05.040 --> 14:08.040]  и сборщику мусора в го
[14:08.040 --> 14:11.040]  нужно обходить граф объект
[14:11.040 --> 14:14.040]  нужно создавать на stack
[14:14.040 --> 14:17.040]  поэтому сборщику мусора в го нужно знать, какие
[14:17.040 --> 14:20.040]  байки на stack играют с Пойнтером
[14:20.040 --> 14:23.040]  для сборки мусора, для решения stack
[14:23.040 --> 14:26.040]  поэтому для вашей горутины хранится bitmap
[14:26.040 --> 14:29.040]  где для каждого кусочка 8 байков
[14:29.040 --> 14:32.040]  хранится флажок, который является
[14:32.040 --> 14:35.040]  кусочек на stack Poynter
[14:35.040 --> 14:38.040]  и этот bitmap заполняется
[14:38.040 --> 14:41.040]  условно копиатором
[14:41.040 --> 14:44.040]  если он размещает этот Poynter на stack
[14:44.040 --> 14:47.040]  то он заполняет флажок bitmap
[14:47.040 --> 14:50.040]  и в итоге у нас в runtime есть
[14:50.040 --> 14:53.040]  bitmap, который размечает
[14:53.040 --> 14:56.040]  в котором размечен этот stack
[14:56.040 --> 14:59.040]  так что го, какая проблема решена?
[14:59.040 --> 15:02.040]  просто всего того, что го и сборка мусора
[15:02.040 --> 15:05.040]  го мог бы найти вот такие ссылки
[15:05.040 --> 15:08.040]  и корректно их переставить
[15:08.040 --> 15:11.040]  но это не единственная проблема
[15:11.040 --> 15:14.040]  потому что
[15:14.040 --> 15:17.040]  это может быть даже и самая большая проблема
[15:17.040 --> 15:20.040]  у нас есть одна горутина
[15:20.040 --> 15:23.040]  а есть другая горутина
[15:23.040 --> 15:26.040]  у нее тоже есть свой stack
[15:29.040 --> 15:32.040]  и вот этот stack
[15:32.040 --> 15:35.040]  на этом stack лежит Poynter
[15:35.040 --> 15:38.040]  на наш stack
[15:38.040 --> 15:41.040]  это уже совсем печально, потому что
[15:41.040 --> 15:44.040]  если мы ссылки будем висеть в омлинайте
[15:44.040 --> 15:47.040]  то чтобы найти такие ссылки
[15:47.040 --> 15:50.040]  нужно вся горутина обойти
[15:50.040 --> 15:53.040]  а их могут быть до света тысячи миллиона
[15:53.040 --> 15:56.040]  задача абсолютно безнадежная
[15:56.040 --> 15:59.040]  и решение еще более лопкое
[15:59.040 --> 16:02.040]  чем с bitmap, который переиспользуется
[16:02.040 --> 16:05.040]  из сборки мусора
[16:05.040 --> 16:08.040]  решение такое
[16:08.040 --> 16:11.040]  если вы знакомы с го, то вы знаете
[16:11.040 --> 16:14.040]  вы знаете, что вы можете алоцировать
[16:14.040 --> 16:17.040]  примерно на куче и на stack
[16:17.040 --> 16:20.040]  вы не можете алоцировать объект на куче и на stack
[16:20.040 --> 16:23.040]  потому что в языке нет понятия
[16:23.040 --> 16:26.040]  в языке вы просто алоцируете объекты
[16:26.040 --> 16:29.040]  а объект уместить решает как реактор
[16:29.040 --> 16:32.040]  как он это делает?
[16:32.040 --> 16:35.040]  он использует escape analysis
[16:35.040 --> 16:38.040]  а в чем его запись?
[16:38.040 --> 16:41.040]  вы знаете, его про сборку мусора что-нибудь
[16:41.040 --> 16:44.040]  в частности про гипотезу похоронения
[16:44.040 --> 16:47.040]  но гипотеза звучит так, что
[16:47.040 --> 16:50.040]  чаще всего умирает молодой объект
[16:50.040 --> 16:53.040]  высокая детская смертность программ
[16:53.040 --> 16:56.040]  поэтому сборка мусора
[16:56.040 --> 16:59.040]  обычно делится на два уровня
[16:59.040 --> 17:02.040]  сборка мусора и алоцированных объектов
[17:02.040 --> 17:05.040]  сборка мусора объекту прожили долго
[17:05.040 --> 17:08.040]  если объект прожил достаточно долго
[17:08.040 --> 17:11.040]  то он скорее всего долго еще и проживет
[17:11.040 --> 17:14.040]  если он пережил детство, то он проживет долго
[17:14.040 --> 17:17.040]  либо же он...
[17:20.040 --> 17:23.040]  например, классический сборки мусора
[17:23.040 --> 17:26.040]  используют две разных ставии
[17:26.040 --> 17:29.040]  сначала объект алоцируется в этих язлях
[17:29.040 --> 17:32.040]  если он пережил дни асфе, то он перемещается
[17:32.040 --> 17:35.040]  в общем, дело живет надолго
[17:35.040 --> 17:38.040]  потому что программа так и устроена
[17:38.040 --> 17:41.040]  такого нет, потому что идея такая
[17:41.040 --> 17:44.040]  если компьютер понимает
[17:44.040 --> 17:47.040]  что объект не нужен
[17:47.040 --> 17:50.040]  за пределами вызова функции
[17:50.040 --> 17:53.040]  то он алоцируется у нас в теке
[17:53.040 --> 17:56.040]  если же компьютер понимает, что pointer
[17:56.040 --> 17:59.040]  и что адрес объекта алоцированного
[17:59.040 --> 18:02.040]  если созданный внутри вызова функции
[18:02.040 --> 18:05.040]  покидают эту функцию
[18:05.040 --> 18:08.040]  и утекают в другую часть программы
[18:08.040 --> 18:11.040]  то объект алоцируется на куче
[18:11.040 --> 18:14.040]  это решает сам комператур
[18:14.040 --> 18:17.040]  как можно получить ссылку с одного стека в другой
[18:17.040 --> 18:20.040]  нужно чтобы pointer убежал
[18:20.040 --> 18:23.040]  а если pointer убегает, то объект алоцируется на куче
[18:23.040 --> 18:26.040]  итого, от них ссылок просто не бывает
[18:30.040 --> 18:33.040]  ну и чуть сложнее еще не бывает
[18:33.040 --> 18:36.040]  ссылок с куча над стеками
[18:36.040 --> 18:39.040]  вот если мы такое запретим
[18:39.040 --> 18:42.040]  то нам не нужно придумать такие сценарии
[18:42.040 --> 18:45.040]  то есть в силу того, что у нас есть
[18:45.040 --> 18:48.040]  скейп анализа такого свойства, то таких слуг не бывает
[18:48.040 --> 18:51.040]  поэтому мы про это не думаем
[18:51.040 --> 18:54.040]  но с помощью разметки
[18:54.040 --> 18:57.040]  в рамтайне для сборки мусора
[18:57.040 --> 19:00.040]  мы их используем
[19:00.040 --> 19:03.040]  и можем привести стеку, проверить внутренний ссылок
[19:03.040 --> 19:06.040]  и в горло стеки растут
[19:06.040 --> 19:09.040]  фактически не могли расти бесконечно
[19:09.040 --> 19:12.040]  кажется, там есть какой-то хард-лимит, типа 1 гб
[19:12.040 --> 19:15.040]  но стеков на 1 гб кажется больше, чем...
[19:15.040 --> 19:18.040]  кому бы не могло поработать
[19:18.040 --> 19:21.040]  очень интересно, насколько это было задумано
[19:21.040 --> 19:24.040]  потому что здесь такая схитная комбинация
[19:24.040 --> 19:27.040]  свойства скейп анализа и сборки мусора используется
[19:27.040 --> 19:30.040]  насколько это было задумано
[19:30.040 --> 19:33.040]  с самого начала
[19:33.040 --> 19:36.040]  я правильно понял, что
[19:36.040 --> 19:39.040]  если компилятор видит
[19:39.040 --> 19:42.040]  что на какую-то переменную
[19:42.040 --> 19:45.040]  будут потом ссылаться
[19:45.040 --> 19:48.040]  то он алоцирует ее на кучу
[19:49.040 --> 19:52.040]  если куча
[19:52.040 --> 19:55.040]  то у нас все указатели остаются валидными
[19:55.040 --> 19:58.040]  потому что ты не стекал
[19:58.040 --> 20:01.040]  а как тогда может появиться указатель
[20:01.040 --> 20:04.040]  изнутри стеков внутреннего же?
[20:04.040 --> 20:07.040]  не знаю, у тебя может быть в той же функции
[20:07.040 --> 20:10.040]  это же не утечка
[20:10.040 --> 20:13.040]  еще раз
[20:13.040 --> 20:16.040]  у тебя же может быть внутри такого фрейма ссылка
[20:16.040 --> 20:19.040]  это уже не очень важные детали
[20:19.040 --> 20:22.040]  важно, что
[20:22.040 --> 20:25.040]  у нас разметка для стек в любом случае есть
[20:25.040 --> 20:28.040]  мы можем пользоваться
[20:28.040 --> 20:31.040]  и у нас есть
[20:31.040 --> 20:34.040]  но вот такие внешние ссылки в себя
[20:34.040 --> 20:37.040]  мы точно уже запрещаем скейп анализа
[20:37.040 --> 20:40.040]  а что с адресами выбраться на скейп?
[20:40.040 --> 20:43.040]  так это адреса в коде
[20:44.040 --> 20:47.040]  ну а что с ними?
[20:47.040 --> 20:50.040]  ну да
[20:50.040 --> 20:53.040]  а что с ними не так?
[20:53.040 --> 20:56.040]  почему?
[20:56.040 --> 20:59.040]  адрес возврата это адрес вместо в коде
[20:59.040 --> 21:02.040]  у себя есть сегмент памяти там, где написан текст программы
[21:02.040 --> 21:05.040]  там ссылки дают
[21:05.040 --> 21:08.040]  это внешние ссылки
[21:08.040 --> 21:11.040]  ну что, с этим мы кончили
[21:11.040 --> 21:14.040]  и давайте мы обсудим
[21:14.040 --> 21:17.040]  какие текущие задачи
[21:17.040 --> 21:20.040]  я не знаю, вот на...
[21:23.040 --> 21:26.040]  на прошлой плаве с другой группой
[21:26.040 --> 21:29.040]  мы обсудили
[21:29.040 --> 21:32.040]  как лучше оформить, написать тредпул
[21:32.040 --> 21:35.040]  вот я в чатике общался с кем-то
[21:35.040 --> 21:38.040]  не уверен, что с кем-то из вас
[21:38.040 --> 21:41.040]  про то, сколько полей в частности
[21:41.040 --> 21:44.040]  должно быть от тредпула
[21:44.040 --> 21:47.040]  давайте я перескажу эту мысль
[21:47.040 --> 21:50.040]  а вы подумайте над своими вопросами
[21:50.040 --> 21:53.040]  хотя не все очень активны сегодня
[21:53.040 --> 21:56.040]  так вот
[21:56.040 --> 21:59.040]  вопрос такой
[21:59.040 --> 22:02.040]  как понять, что вы написали хороший тредпул
[22:02.040 --> 22:05.040]  или плохой тредпул, как их отличить
[22:05.040 --> 22:08.040]  это простой критерий, по которому можно
[22:08.040 --> 22:11.040]  проверить качество своего кода
[22:11.040 --> 22:14.040]  убедиться легко, что тредпул ваш не самый лучший
[22:14.040 --> 22:17.040]  но это правило довольно универсальное
[22:17.040 --> 22:20.040]  я его в чате писал, повторю
[22:20.040 --> 22:23.040]  если у вас в коде в пределах одного класса
[22:23.040 --> 22:26.040]  одной функции есть какая-то
[22:26.040 --> 22:29.040]  операция типа запуска спутников в космос
[22:29.040 --> 22:32.040]  и в то же время есть операция разыменования
[22:33.040 --> 22:36.040]  то с вашим кодом возможно
[22:36.040 --> 22:39.040]  что-то не в порядке
[22:39.040 --> 22:42.040]  потому что он на уровне одного класса
[22:42.040 --> 22:45.040]  или одной функции сочетает в себе действия
[22:45.040 --> 22:48.040]  очень разного масштаба
[22:48.040 --> 22:51.040]  очень разной степени абстракции
[22:51.040 --> 22:54.040]  и в хорошем классе
[22:54.040 --> 22:57.040]  правилам мы работаем в пределах одного уровня абстракции
[22:57.040 --> 23:00.040]  что это значит для тредпула
[23:01.040 --> 23:04.040]  тредпул это некоторый компонент
[23:04.040 --> 23:07.040]  который кажется составлен из других компонентов поменьше
[23:07.040 --> 23:10.040]  в частности в нем есть очередь
[23:10.040 --> 23:13.040]  в которую хранятся задачи
[23:13.040 --> 23:16.040]  и вот эта очередь сама по себе не такая уж деревиальная
[23:16.040 --> 23:19.040]  там буфер, кондвар, мютекс, какая-то синхронизация
[23:19.040 --> 23:22.040]  но тем не менее тредпул про детали реализации этой очереди
[23:22.040 --> 23:25.040]  ничего не знает
[23:25.040 --> 23:28.040]  для него есть просто класс очередь
[23:28.040 --> 23:31.040]  не тот шаблон, который мне нужен
[23:34.040 --> 23:37.040]  есть просто класс очередь, которая реализует
[23:37.040 --> 23:40.040]  вот этот API и гарантирует, что
[23:40.040 --> 23:43.040]  метод take заблокируется до тех пор, пока не появится элемент
[23:43.040 --> 23:46.040]  или не будет вызван close или cancel
[23:46.040 --> 23:49.040]  с другой стороны, с стороны продюсеров
[23:49.040 --> 23:52.040]  как это очень реализовано, полупотоков не важно
[23:52.040 --> 23:55.040]  важны ее свойства, ее интерфейс
[23:55.040 --> 23:58.040]  и вы этим пользуетесь
[23:58.040 --> 24:01.040]  а дальше у вас есть другая задача в поле потоков
[24:01.040 --> 24:04.040]  а именно реализовать wait idle
[24:04.040 --> 24:07.040]  дождаться, пока пул не опустеет
[24:07.040 --> 24:10.040]  первое наблюдение
[24:10.040 --> 24:13.040]  если вы хорошо поняли API, то вы должны заметить
[24:13.040 --> 24:16.040]  что wait idle и stop
[24:16.040 --> 24:19.040]  вообще у них совершенно не то что
[24:19.040 --> 24:22.040]  несвязанная семантика, но перпендикулярная вообще-то
[24:22.040 --> 24:25.040]  потому что stop он про воркеры
[24:25.040 --> 24:28.040]  и про очередь, там выключить очередь
[24:28.040 --> 24:31.040]  остановить воркеры, а wait idle
[24:31.040 --> 24:34.040]  он на пул не влияет
[24:34.040 --> 24:37.040]  и ни с очереди, ни с воркерами не работает
[24:37.040 --> 24:40.040]  wait idle просто подсчет задач
[24:40.040 --> 24:43.040]  когда мы говорим submit, у нас видимо число задач
[24:43.040 --> 24:46.040]  увеличивается, когда воркер завершает задачу
[24:46.040 --> 24:49.040]  число задач уменьшается, а в wait idle мы хотим дождаться нуля
[24:50.040 --> 24:53.040]  про очередь мы здесь кажется не думаем
[24:53.040 --> 24:56.040]  и это хороший API, потому что метода
[24:56.040 --> 24:59.040]  артагональна, это значит, что их можно комбинировать
[24:59.040 --> 25:02.040]  можно вызывать только один, можно вызывать оба
[25:02.040 --> 25:05.040]  в зависимости от того, как вы пулу используете
[25:05.040 --> 25:08.040]  так вот, у вас есть такая вот задача
[25:08.040 --> 25:11.040]  подсчитывать задачи
[25:11.040 --> 25:14.040]  и что вы можете в коде написать
[25:14.040 --> 25:17.040]  вы можете в коде написать прямо в полях класса threadpool
[25:17.040 --> 25:20.040]  мьютексы, кундвары, счетчики
[25:20.040 --> 25:23.040]  и вот вы смотрите на поля и с одной стороны у вас есть
[25:23.040 --> 25:26.040]  потоки воркеры, понятно о чем речь
[25:26.040 --> 25:29.040]  очередь, понятно о чем речь, а дальше какие-то
[25:29.040 --> 25:32.040]  мьютексы, кундвары, счетчики
[25:32.040 --> 25:35.040]  и смотрите, очередь, сущность довольно высоко
[25:35.040 --> 25:38.040]  в уровне, понятно что она делает, а что делает
[25:38.040 --> 25:41.040]  мьютекс, сам по себе он ничего не... ну в смысле
[25:41.040 --> 25:44.040]  он сам по себе не полезен, он реализует некоторые
[25:44.040 --> 25:47.040]  в смысле он помогает реализовать нечто
[25:47.040 --> 25:50.040]  кундвар, какая у него семантика, у него
[25:50.040 --> 25:53.040]  самостоятельной семантики вообще нет, мы дожидаемся
[25:53.040 --> 25:56.040]  какого-то события, какого-то события вообще не ясно
[25:56.040 --> 25:59.040]  вот это признак того, что у вас в коде
[25:59.040 --> 26:02.040]  нарушены... смешиваются
[26:02.040 --> 26:05.040]  разный масштаб и где-то у вас сущность высокого
[26:05.040 --> 26:08.040]  уровня лежит, а где-то у вас какие-то детали реализации
[26:08.040 --> 26:11.040]  и возникает такое естественное желание получить
[26:11.040 --> 26:14.040]  такой модульный код, вот эту задачу
[26:14.040 --> 26:17.040]  подсчета других задач, просто выделить в отдельный
[26:17.040 --> 26:20.040]  компонент
[26:20.040 --> 26:23.040]  и ну... я не хотел это делать сразу
[26:23.040 --> 26:26.040]  но сейчас в условии есть подсказка про то, что
[26:29.040 --> 26:32.040]  есть... да, есть
[26:32.040 --> 26:35.040]  про то, что ну посмотрите на мир вокруг, как он устроен
[26:35.040 --> 26:38.040]  то есть с одной стороны, да, мы считаем задачи
[26:38.040 --> 26:41.040]  с одной стороны, но компонент, который мы хотим выделить
[26:41.040 --> 26:44.040]  мы хотим... но он мог бы быть полезен
[26:44.040 --> 26:47.040]  сам по себе, так же как очередь полезна
[26:47.040 --> 26:50.040]  сама по себе, не только для реализации полного атак
[26:50.040 --> 26:53.040]  и вот такой счетчик, который в ГО называется Weight Group
[26:53.040 --> 26:56.040]  мне больше по душе название типа Workout
[26:56.040 --> 26:59.040]  там подсчет работы некоторые абстрактный
[26:59.040 --> 27:02.040]  вот он может быть использован сам по себе для синхронизации
[27:02.040 --> 27:05.040]  вот в ГО пример такой, мы запускаем 5 ГРУТИН
[27:06.040 --> 27:09.040]  в счетчике мы... ну, перед запуском мы увеличиваем счетчик
[27:09.040 --> 27:12.040]  в конце каждого запуска
[27:12.040 --> 27:15.040]  вот defer означает, что этот код вызовется при завершении
[27:15.040 --> 27:18.040]  исполняемой процедуры, вызовется дан
[27:18.040 --> 27:21.040]  это минус 1 и Weight Group Weight
[27:21.040 --> 27:24.040]  дождется, пока счетчик вот этой работы
[27:24.040 --> 27:27.040]  не опустится до нуля
[27:27.040 --> 27:30.040]  и вот можно синхронизировать потоки, а можно считать
[27:30.040 --> 27:33.040]  задачи в стратпуле, и кажется, что и там, и там
[27:33.040 --> 27:36.040]  того и того же интерфейса будет достаточно
[27:36.040 --> 27:39.040]  это говорит нам о том, что декомпозиция, возможно, разумная
[27:39.040 --> 27:42.040]  что стоит ее использовать
[27:42.040 --> 27:45.040]  еще один критерий разумной декомпозиции
[27:45.040 --> 27:48.040]  ну, тут можно разные привести
[27:48.040 --> 27:51.040]  вот если декомпозиция разумная
[27:51.040 --> 27:54.040]  то вот, во-первых, вы получаете компоненты, которые полезны
[27:54.040 --> 27:57.040]  сами по себе, за пределами вашей задачи
[27:57.040 --> 28:00.040]  во-вторых, код самого стратпула
[28:00.040 --> 28:03.040]  в идеале упрощается
[28:06.040 --> 28:09.040]  ну, это не симмофор, это какой-то примитив
[28:09.040 --> 28:12.040]  который чем-то напоминает, он скорее на барьер похож
[28:12.040 --> 28:15.040]  но я бы не стал тут смешивать, это все-таки у него отдельное название
[28:15.040 --> 28:18.040]  своя собственная семантика, понятно, что это можно
[28:18.040 --> 28:21.040]  написать с помощью опять минуток, секунд два, какого-нибудь
[28:21.040 --> 28:24.040]  впрочем, не только так
[28:24.040 --> 28:27.040]  ну, это какой-то примитив, который
[28:27.040 --> 28:30.040]  фиксирует правило ожидания какого-то события
[28:30.040 --> 28:33.040]  вот в задаче про кундвар написано, кундвар-кундвар
[28:33.040 --> 28:36.040]  что кундвар сам по себе симантики не имеет
[28:36.040 --> 28:39.040]  но мы его используем для разных примитивов синхронизации
[28:39.040 --> 28:42.040]  и в каждом примитиве синхронизации симантика своя
[28:42.040 --> 28:45.040]  вот там, у барьера одна, у симмофора другая
[28:45.040 --> 28:48.040]  у вейт-групп третья какая-то
[28:48.040 --> 28:51.040]  и вот мы можем такую штуку выделить
[28:51.040 --> 28:54.040]  и второй вейтпоинт в том, что третпул станет проще
[28:54.040 --> 28:57.040]  все вызовы там буквально из двух-трех строчек
[28:57.040 --> 29:00.040]  и вот все на одном уровне абстракции
[29:00.040 --> 29:03.040]  на одном масштабе, и вот такой третпул
[29:03.040 --> 29:06.040]  там, не знаю, его реализация читается просто
[29:06.040 --> 29:09.040]  как документация симантики
[29:09.040 --> 29:12.040]  сабмит, положить задачу в очередь, вылечить счетчик задачи
[29:12.040 --> 29:15.040]  в правильном порядке, возможно
[29:15.040 --> 29:18.040]  вейт-айдл, дождаться, пока счетчик опустится до нуля
[29:18.040 --> 29:21.040]  стоп, закрыть очередь, остановить потоки
[29:21.040 --> 29:24.040]  с одной стороны реализация, с другой стороны
[29:24.040 --> 29:27.040]  буквально документация, что пул делает
[29:27.040 --> 29:30.040]  код получается очень простой
[29:30.040 --> 29:33.040]  ну и еще одно приятное свойство
[29:33.040 --> 29:36.040]  такого модульного подхода стоит в том, что если
[29:36.040 --> 29:39.040]  декомпозиция удачная, правильная, то
[29:39.040 --> 29:42.040]  можно оптимизировать независимо разные компоненты
[29:42.040 --> 29:45.040]  вот скажем, с мьютоксами и кундварами
[29:45.040 --> 29:48.040]  голыми в третпуле очень легко написать плохой код
[29:48.040 --> 29:51.040]  в котором будет нечто подобное написано
[29:51.040 --> 29:54.040]  мы говорим сабмит, а в нем берем мьютокс
[29:54.040 --> 29:57.040]  какой-нибудь, увеличиваем счетчик
[29:57.040 --> 30:00.040]  и прямо под этим мьютоксом еще пут в очередь делаем
[30:00.040 --> 30:03.040]  а в нем свой мьютокс, там мьютокс, положенный в мьютокс, хотя вот
[30:03.040 --> 30:06.040]  смысла в этом вообще никакого нет, это просто неаккуратный код
[30:06.040 --> 30:09.040]  но если мы разделим это на два компонента, то такого кода
[30:09.040 --> 30:12.040]  просто не получится, потому что мьютоксы у них будут внутри
[30:12.040 --> 30:15.040]  спрятаны
[30:15.040 --> 30:18.040]  кроме того, тут мы так
[30:18.040 --> 30:21.040]  случайно, можно сказать, повысим эффективность
[30:21.040 --> 30:27.040]  кроме того, сами эти классы, weight group и очередь ожидания
[30:27.040 --> 30:34.040]  weight group и очередь элементов задач блокирующих
[30:34.040 --> 30:38.040]  их можно реализовать по-разному, можно оптимизировать
[30:38.040 --> 30:42.040]  но очередь задач оптимизировать пока не будем
[30:42.040 --> 30:45.040]  это разговор про локфрии скорее
[30:45.040 --> 30:48.040]  а вот weight group можно написать очень по-разному
[30:48.040 --> 30:51.040]  самая простая реализация, самая разумная
[30:51.040 --> 30:54.040]  это мьютокс, кундуар и счетчик
[30:54.040 --> 30:59.040]  но можно так постараться, чтобы weight group
[30:59.040 --> 31:04.040]  на add и done, на самые частые вызовы свои
[31:04.040 --> 31:07.040]  выполнял только одно тамарную операцию
[31:07.040 --> 31:11.040]  чтобы он был очень легкий
[31:11.040 --> 31:14.040]  правда при этом
[31:14.040 --> 31:17.040]  тут нужно меня аккуратно правильно понять
[31:17.040 --> 31:20.040]  потому что можно написать его на одном атомике
[31:20.040 --> 31:23.040]  очень грубо, очень некачественно
[31:23.040 --> 31:26.040]  вот я говорю не про плохое решение
[31:26.040 --> 31:28.040]  которое очень легко написать
[31:28.040 --> 31:30.040]  я говорю, что есть решение с мьютоксом и кундуаром
[31:30.040 --> 31:32.040]  очень просто и разумное
[31:32.040 --> 31:34.040]  а есть решение на атомике с мьютоксом
[31:34.040 --> 31:37.040]  с weight'ом, оно довольно хитрое
[31:37.040 --> 31:40.040]  оно чем-то напоминает идею барьеры
[31:40.040 --> 31:42.040]  вот в хорошем решении
[31:42.040 --> 31:44.040]  семантика weight используется
[31:44.040 --> 31:47.040]  то есть я дожидаюсь, пока значение изменится
[31:47.040 --> 31:50.040]  но имейте ввиду, что вот этому классу weight group
[31:50.040 --> 31:52.040]  не подходит семантика weight
[31:52.040 --> 31:54.040]  он не дожидается, пока значение изменится
[31:54.040 --> 31:58.040]  он дожидается, пока счетчик не опустится до нуря
[31:58.040 --> 32:02.040]  вот это weight'у не соответствует
[32:02.040 --> 32:07.040]  но можно написать так, чтобы семантика weight group weight
[32:07.040 --> 32:11.040]  выражалась через мьютокс weight прямолинейно
[32:11.040 --> 32:14.040]  что действительно ожидание смены значения
[32:14.040 --> 32:17.040]  будет означать, что задачи кончились
[32:17.040 --> 32:19.040]  вот можно написать такой аккуратный код
[32:19.040 --> 32:24.040]  но это скорее вопрос для защиты
[32:24.040 --> 32:27.040]  вот такая история
[32:27.040 --> 32:30.040]  вопрос, может быть, какие-то
[32:30.040 --> 32:35.040]  вы говорили, что задача тройлог
[32:35.040 --> 32:40.040]  он отчасти про то, чтобы узнать про инструкцию компея
[32:40.040 --> 32:47.040]  Exchange, но отчасти там есть что-то глубже
[32:47.040 --> 32:50.040]  и вы говорили, что если вам напомнить, то вы расскажете
[32:50.040 --> 32:52.040]  а давай на защите расскажу
[32:52.040 --> 32:54.040]  ну или спрашиваю, я не знаю
[32:54.040 --> 32:56.040]  но это интересная история, но довольно маленькая
[32:56.040 --> 32:58.040]  довольно локальная
[32:58.040 --> 33:02.040]  мне кажется, что сейчас можно про какие-то более масштабные вещи поговорить
[33:02.040 --> 33:04.040]  я зачитывал ассистенту
[33:04.040 --> 33:05.040]  а?
[33:05.040 --> 33:06.040]  я ассистенту зачитывал
[33:06.040 --> 33:08.040]  ассистенту, да
[33:08.040 --> 33:11.040]  ну ладно, найдем повод, я расскажу
[33:11.040 --> 33:16.040]  вот может быть непрямо сейчас, может быть в локфрии это будет тоже разумно сделать
[33:16.040 --> 33:19.040]  ладно, давай я сам на что-то внимание обращу
[33:19.040 --> 33:21.040]  вот что в тредпуле появилось
[33:21.040 --> 33:24.040]  и что появится в задаче про карутину
[33:24.040 --> 33:28.040]  что мне кажется полезно знать
[33:28.040 --> 33:32.040]  то, что мы на лекциях не обсуждали, а если мы на лекциях не обсуждали, а в задачах уже есть
[33:32.040 --> 33:37.040]  это вот такая вот штука
[33:37.040 --> 33:41.040]  ну вернее не такая, потому что это некоторая наша альтернатива механизму
[33:41.040 --> 33:45.040]  который называется тредлокал
[33:45.040 --> 33:48.040]  тредлокал, да
[33:48.040 --> 33:52.040]  это некоторая интересная штука
[33:52.040 --> 33:55.040]  и о чем она?
[33:56.040 --> 34:00.040]  вот у вас есть локальные переменные
[34:00.040 --> 34:03.040]  вот, представьте, что у вас есть потоки, да
[34:03.040 --> 34:07.040]  и у вас есть вот какие классы переменных? есть локальные переменные, это переменные, лозированные на стэке
[34:07.040 --> 34:11.040]  у каждого по тока, эта переменная своя собственная
[34:11.040 --> 34:15.040]  когда он обращается, он обращается только к ней
[34:15.040 --> 34:18.040]  к другим переменным, на других стэках обращаться, разумеется, нельзя
[34:18.040 --> 34:19.040]  нельзя.
[34:19.040 --> 34:21.520]  Вот здесь глобальные переменные.
[34:21.520 --> 34:24.280]  К ней могут упрощаться все потоки, и она у всех
[34:24.280 --> 34:25.280]  одна и та же.
[34:25.280 --> 34:28.320]  А есть еще трудлокальные переменные.
[34:28.320 --> 34:30.480]  Это довольно особенная переменная такая, что у
[34:30.480 --> 34:31.480]  нее одно имя.
[34:31.480 --> 34:35.040]  То есть как будто бы это ячейка памяти, которая
[34:35.040 --> 34:38.580]  адресуется некоторым именем, но при этом воплощение
[34:38.580 --> 34:41.080]  этой ячейки у каждого потока свое.
[34:41.080 --> 34:43.160]  То есть имя одно, но у каждого потока она разная.
[34:43.160 --> 34:46.240]  Это довольно нетривиальная штука.
[34:46.240 --> 34:49.480]  Мне кажется, что мы такого не видели.
[34:49.480 --> 34:52.480]  Я не знаю, вы видели вы такое где-нибудь?
[34:52.480 --> 34:55.520]  Но вот они здесь появляются, и нам здесь нужно в threadlock
[34:55.520 --> 35:00.880]  или хранить поинтер на текущий пул поток, чтобы из потока
[35:00.880 --> 35:03.040]  воркера его легко можно было найти.
[35:03.040 --> 35:08.560]  В threadpool это скорее забава, потому что вам самим в реализации
[35:08.560 --> 35:09.560]  это не нужно было.
[35:09.560 --> 35:14.360]  Но смотрите, когда вы будете писать задачу про крутину,
[35:14.360 --> 35:21.800]  давайте я открою ее ритми, то вы там пишете многопоточные
[35:21.800 --> 35:29.880]  файберы, и у них есть функция yield, и вот в этой функции
[35:29.880 --> 35:34.600]  yield вам уже неизбежно потребуется threadlock.
[35:34.600 --> 35:37.240]  Собственно в threadpool это переменный threadlock появился,
[35:37.240 --> 35:41.760]  чтобы вы могли здесь его в частности понять, что
[35:41.840 --> 35:43.840]  вам нужен и использовать его.
[35:43.840 --> 35:49.040]  Вообще, что хочется сказать в связи со всем этим, с этой
[35:49.040 --> 35:53.560]  задачей прошлой лекции, которая была в субботу?
[35:53.560 --> 35:56.160]  Мне кажется, что эта лекция, хоть и новая, но она в том
[35:56.160 --> 35:58.760]  или ином виде раньше была в курсе, но не в виде лекции,
[35:58.760 --> 35:59.760]  а в виде семинара.
[35:59.760 --> 36:01.280]  Сейчас, мне кажется, это одна из самых важных лекций
[36:01.280 --> 36:04.120]  всего курса, потому что в ней сходится все, что было
[36:04.120 --> 36:08.840]  до, а с другой стороны, все, что будет после, за исключением
[36:08.840 --> 36:11.720]  модели памяти, из этой лекции тоже будет следовать.
[36:11.720 --> 36:14.280]  И планировщик будем развивать, и коррутины будем развивать,
[36:14.280 --> 36:18.160]  и там в разные стороны пойдем от нее.
[36:18.160 --> 36:21.040]  И вот сейчас в курсе очень многое меняется, потому
[36:21.040 --> 36:24.840]  что, объясню, как на это можно смотреть.
[36:24.840 --> 36:28.760]  Мы с вами до этого момента занимались каким-то баловством
[36:28.760 --> 36:31.920]  таким локальным, брали мьютерс, там какие-то строчки,
[36:31.920 --> 36:34.920]  три строчки тут, строчки там, какие-то мьютеры, атомики,
[36:34.920 --> 36:38.160]  кондвары, какие-то небольшие манипуляции, продумать в
[36:38.160 --> 36:44.120]  голове все пересечения, переключения, интерливинги.
[36:44.120 --> 36:50.440]  Дальше так продолжаться не будет, потому что это,
[36:50.440 --> 36:53.080]  конечно, не совсем правда, но я бы сказал так, что если
[36:53.080 --> 36:55.800]  говорить про... если не говорить пока про локфрия, про локфрия
[36:55.800 --> 37:01.160]  нам пока знать не обязательно, то нам ютоксных кондварах
[37:01.160 --> 37:05.840]  мы более-менее все разумные паттерны синхронизации
[37:05.840 --> 37:06.840]  освоили уже.
[37:06.840 --> 37:11.520]  То есть мы вот с такими техническими вещами разобрались.
[37:11.520 --> 37:16.760]  Ну, я понимаю, что, наверное, не до конца, но это другая
[37:16.760 --> 37:17.760]  история.
[37:17.760 --> 37:20.360]  Но, в принципе, вот задачи, которые есть в ютоксных
[37:20.360 --> 37:23.280]  кондварах, они покрывают очень много всего, что можно
[37:23.280 --> 37:24.920]  про вот такую синхронизацию знать.
[37:24.920 --> 37:29.360]  А дальше мы хотим с вами в курсе строить какие-то
[37:29.360 --> 37:33.200]  более высокоуровневые вещи, и там эта синхронизация
[37:33.200 --> 37:35.180]  будет возникать просто как вот некоторые маленькие
[37:35.180 --> 37:36.180]  строительные блоки.
[37:36.180 --> 37:39.340]  Но вещи мы делаем гораздо сложнее, гораздо масштабнее.
[37:39.340 --> 37:42.580]  Вот мы сейчас начинаем писать вы, собственно, ГО, и...
[37:42.580 --> 37:46.700]  Ну, я вот вроде вас не обманываю, мы собираемся в этом довольно
[37:46.700 --> 37:49.220]  далеко продвинуться, в смысле мы вот здесь уже
[37:49.220 --> 37:52.900]  напишем какие-то грутины, дальше мы напишем следующие
[37:52.900 --> 37:56.140]  задачи примитива синхронизации для них, потом мы напишем
[37:56.140 --> 37:58.380]  канал селект, потом мы пойдем как это интегрировать
[37:58.380 --> 38:01.660]  фьючами, про которые отдельная история еще будет, как это
[38:01.660 --> 38:04.820]  все обобщить, но чтобы сделать этот фреймворк расширяемым,
[38:04.820 --> 38:06.620]  можно будет дожидаться не только на каналах, на
[38:06.620 --> 38:09.500]  мьютексах, а на каких-то своих примитивах.
[38:09.500 --> 38:14.940]  Короче, становится сильно сложнее, но, обратите внимание,
[38:14.940 --> 38:16.660]  становится сложнее не потому, что нужно больше кода
[38:16.660 --> 38:17.660]  писать.
[38:17.660 --> 38:25.140]  Вот, я могу быть не совсем точен, но скорее всего в задачи
[38:25.140 --> 38:27.500]  про крутину потребуется написать меньше кода,
[38:27.500 --> 38:28.500]  чем в задачу на трэдпул.
[38:28.500 --> 38:32.580]  Ну, как бы, задача на трэдпул вложена в крутину, но вот
[38:32.620 --> 38:37.620]  если не брать в расчет перенесенный код, то нового кода там будет
[38:37.620 --> 38:38.620]  даже меньше.
[38:38.620 --> 38:43.700]  Но написать его, мне кажется, будет сложнее, не потому
[38:43.700 --> 38:52.060]  что он требует какого-то, там сложнее переключения,
[38:52.060 --> 38:54.700]  наоборот, там ничего такого не будет, сложность там
[38:54.700 --> 38:58.620]  совершенно в другом, вот, я условия дорабатываю периодически
[38:58.620 --> 39:04.300]  и на днях, на днях, задача добавилась, в воскресенье
[39:04.300 --> 39:05.980]  я, может быть, вчера или позавчера добавил такой
[39:05.980 --> 39:11.060]  пункт, что как вообще понять, что вы делаете что-то разумное
[39:11.060 --> 39:13.060]  в задаче, как понять, что вы понимаете вообще ее условия,
[39:13.060 --> 39:14.060]  ее замысел.
[39:14.060 --> 39:16.940]  Вот задачи вам говорят, что мы хотим сделать многопоточные
[39:16.940 --> 39:20.100]  файберы, мы хотим сделать их из, там, с комбинировав
[39:20.100 --> 39:21.940]  пул потоков и с программы.
[39:21.940 --> 39:24.900]  И вот задачи появляются с разными сущностями, которые
[39:24.900 --> 39:27.980]  похожи, но которые все же отличаются.
[39:27.980 --> 39:30.820]  Задача – это карутина, это файбер.
[39:30.820 --> 39:34.060]  И вот неплохо было бы при решении задачи понять,
[39:34.060 --> 39:37.220]  прежде чем ее писать, может быть, или по ходу, вот, где
[39:37.220 --> 39:39.260]  границы проведены между этими понятиями, чем они
[39:39.260 --> 39:43.180]  отличаются, за что каждый из них отвечает.
[39:43.180 --> 39:48.420]  Вот мы пишем файберы, файберы и за что файбер означает
[39:48.420 --> 39:51.780]  задача, как она выглядит, как в файбере используется
[39:51.780 --> 39:53.820]  карутина, чем она от самого файбера отличается.
[39:53.820 --> 39:57.220]  Потому что в первом приближении это можно не почувствовать.
[39:58.220 --> 40:00.900]  Вот я бы сказал, что сложность этой задачи и сложность
[40:00.900 --> 40:03.900]  многих последующих задач будет даже не в том, не только
[40:03.900 --> 40:07.180]  в том, чтобы код написать, а в том, чтобы понять, что
[40:07.180 --> 40:10.700]  вокруг происходит, понять дизайн, которым мы собираемся
[40:10.700 --> 40:14.660]  пользоваться, по нему декомпозицию, которую нам предлагают.
[40:14.660 --> 40:18.540]  Вот подумайте сами, написать свои многопоточные файберы
[40:18.540 --> 40:19.780]  – это же выглядит сложной задачей.
[40:19.780 --> 40:23.980]  Ну, по крайней мере, неделю назад, вот без лекции прошли,
[40:23.980 --> 40:28.420]  по крайней мере, это сложно придумать, сев и начав
[40:28.420 --> 40:30.980]  думать, вряд ли вы придумаете этот дизайн.
[40:30.980 --> 40:33.980]  Людям потребовалось некоторое время, некоторая история,
[40:33.980 --> 40:35.660]  чтобы к этому дизайну прийти.
[40:35.660 --> 40:38.980]  И сложность этой задачи в том, чтобы понять, как
[40:38.980 --> 40:39.980]  этот дизайн устроен.
[40:39.980 --> 40:43.580]  И потом уже его просто воплотить.
[40:43.580 --> 40:47.100]  Я обычные решения задач не рассказываю, на самом
[40:47.100 --> 40:48.940]  деле на лекции я рассказал полностью решение задачи.
[40:48.940 --> 40:55.780]  Но это не чувствуется, потому что само решение довольно
[40:55.780 --> 40:56.780]  сложное.
[40:56.780 --> 41:02.700]  И вот вы, разбирая шаблон задачи, надеюсь, это увидите.
[41:02.700 --> 41:04.900]  Шаблон тоже очень разумный, пожалуйста, попытайтесь
[41:04.900 --> 41:07.260]  понять все, что там написано, и вообще все, что в условии
[41:07.260 --> 41:08.260]  написано.
[41:08.260 --> 41:11.820]  Потому что многие вещи там написаны довольно, ну,
[41:11.820 --> 41:12.820]  скажем так, странно.
[41:12.820 --> 41:15.260]  И, например, вам говорят, что мы теперь не будем
[41:15.260 --> 41:19.460]  вызывать вот этот пула метод Submit.
[41:19.460 --> 41:25.500]  Мы будем вызывать функцию Submit, которая сейчас реализована
[41:25.500 --> 41:26.500]  вот так вот.
[41:26.500 --> 41:28.940]  Она получает лямбда и бросает ее в пул.
[41:28.940 --> 41:32.860]  Ну, как бы зачем нам такая странная косвенность.
[41:32.860 --> 41:37.340]  Ну, оказывается, что можно из этого извлечь очень
[41:37.340 --> 41:42.020]  важную, очень большую опцимизацию для пула потоков, для файберов,
[41:42.020 --> 41:43.420]  для вообще светлого будущего нашего.
[41:43.420 --> 41:50.620]  Или там задача, ну, это такие уже вещи, ну, в общем, про
[41:50.620 --> 41:53.860]  настоящее программирование, а не вот про такие вот пазлы,
[41:53.860 --> 41:54.860]  которые были в метоксах в ганварах.
[41:54.860 --> 42:00.140]  Например, там предлагают, что вот можно, ну, у нас
[42:00.140 --> 42:02.300]  есть переключение контекста, и можно, в принципе, с помощью
[42:02.300 --> 42:04.820]  него было бы делать разные вещи, там файберы писать,
[42:04.820 --> 42:07.220]  карутины писать, там генераторы писать.
[42:07.220 --> 42:10.140]  Но мы хотим сначала построить некоторый вспомогательный
[42:10.860 --> 42:13.580]  класс Karoutine.Impel, потом уже его переиспользовать.
[42:13.580 --> 42:17.900]  Вот почему у нас есть такой класс, который стеками
[42:17.900 --> 42:20.900]  не управляет, у которого саспенд небезопасный.
[42:20.900 --> 42:25.220]  Вот почувствовать, почему дизайн именно такой от вас
[42:25.220 --> 42:29.020]  требует тоже каких-то усилий, и при чтении условий наверняка
[42:29.020 --> 42:30.020]  не будет понятно.
[42:30.020 --> 42:38.140]  Что еще?
[42:38.140 --> 42:41.180]  Наверное, сложность еще в том, что теперь эти задачи
[42:41.180 --> 42:47.460]  требуют, ну, такого более широкого понимания программирования.
[42:47.460 --> 42:53.220]  Вот, я не знаю, вы проходите лабы по алгоритмам, и чтобы
[42:53.220 --> 42:55.900]  решить любую лабу по алгоритмам, написать любой сложный
[42:55.900 --> 42:58.540]  там, не знаю, суффиксное дерево, любое, нужно примерно
[42:58.540 --> 42:59.540]  нулевое знание языка.
[42:59.540 --> 43:04.980]  Вот вы знаете C, вы знаете там Container STL, все, вы можете
[43:04.980 --> 43:05.980]  что угодно написать.
[43:05.980 --> 43:08.700]  Но программирование так не устроено, в программировании
[43:08.700 --> 43:11.700]  очень много задач разных, и для этого требуют, ну,
[43:11.700 --> 43:13.900]  и для решения требуются самые разные вещи.
[43:13.900 --> 43:18.180]  Вот, например, ну, Treadlock'a поговорили уже, другой пример
[43:18.180 --> 43:21.380]  — интрузивность, про которую мы пока мало знаем, но вот,
[43:21.380 --> 43:22.940]  которую можно здесь использовать.
[43:22.940 --> 43:26.660]  Или, например, управление памятью.
[43:26.660 --> 43:32.380]  В условиях говорят, можно ли использовать Do-read-this?
[43:32.380 --> 43:35.300]  Вот вы не часто пишете такой код.
[43:35.300 --> 43:42.220]  Ну, есть такое простое правило, что, скажем, не нужно вообще
[43:42.220 --> 43:46.540]  писать New Do-read руками в программе на C++ современном,
[43:46.540 --> 43:50.820]  потому что у вас есть make-shared, make-unique, и вам говорят, ну,
[43:50.820 --> 43:55.220]  зачем вам Malog-free, тем более, New Do-read?
[43:55.700 --> 43:58.860]  Ну ладно, New можно писать только для того, чтобы сделать
[43:58.860 --> 44:01.060]  плейсмут New, когда вы пишете, там, не знаю, свой вектор,
[44:01.060 --> 44:02.060]  это может быть еще полезно.
[44:02.060 --> 44:05.860]  Но вот зачем вам прямо Do-read-this сделать?
[44:05.860 --> 44:07.740]  У вас же есть чередпоинтер и никпоинтер.
[44:07.740 --> 44:13.580]  Ну, ответ такой, что любая языковая конструкция — она
[44:13.580 --> 44:17.300]  нехорошая и неплохая — это инструмент, и вот бывают
[44:17.300 --> 44:18.300]  разные сценарии.
[44:18.300 --> 44:20.460]  Когда вам говорят, не пишите никогда так, то вам говорят
[44:20.460 --> 44:24.860]  на самом деле, что в 99,9% случаев не пишите так.
[44:24.860 --> 44:29.140]  Но есть сценарий какой-то сложный, хитрый, специальный,
[44:29.140 --> 44:31.940]  где вот такая функциональность в языке будет полезна.
[44:31.940 --> 44:34.140]  И вот именно она и нужна.
[44:34.140 --> 44:38.060]  И вот, и вам говорят, что не пишите никогда, потому
[44:38.060 --> 44:39.060]  что детали сложные.
[44:39.060 --> 44:43.340]  Но вы же разумный человек, вы понимаете, что если в
[44:43.340 --> 44:46.540]  языке что-то есть, то, возможно, для этого есть какие-то
[44:46.540 --> 44:47.540]  прикладные сценарии.
[44:47.540 --> 44:50.900]  Ну вот здесь я утверждаю, что в Fiber'е разумно писать
[44:50.900 --> 44:51.900]  Do-read-this.
[44:51.900 --> 44:54.700]  Можно и без него написать на самом деле, и в этой
[44:54.700 --> 44:58.180]  задаче, может быть, даже покажется, что так лучше.
[44:58.180 --> 45:00.220]  Но забегая вперед, нет, не лучше.
[45:00.220 --> 45:03.300]  Как бы сложно про будущее объяснить, можно только
[45:03.300 --> 45:04.300]  не поверить.
[45:04.300 --> 45:07.140]  Но, по крайней мере, поймите, как можно, в смысле, что
[45:07.140 --> 45:11.220]  можно так, можно иначе, и мы об этом поговорим.
[45:11.220 --> 45:13.100]  Опять же, вопрос про программирование.
[45:13.100 --> 45:14.460]  Там про оптимизация.
[45:14.460 --> 45:17.060]  Вот не знаю, какие у вас отношения к оптимизациям,
[45:17.060 --> 45:20.660]  но вот в настоящем промышленном коде оптимизация, они, во-первых,
[45:20.660 --> 45:22.900]  не про асимптотики никогда, во-вторых, не про ассемблеры
[45:22.900 --> 45:23.900]  какой-нибудь.
[45:23.900 --> 45:27.700]  Оптимизации, они, скорее, вот про какой-то грамотный
[45:27.700 --> 45:28.700]  дизайн.
[45:28.700 --> 45:30.820]  Вот у нас здесь есть важная оптимизация, это там стэк
[45:30.820 --> 45:35.460]  локаторов, тьфу, локатор стэков, в котором есть эти
[45:35.460 --> 45:38.020]  самые стэки, которые нужно переиспользовать, например.
[45:38.020 --> 45:39.660]  Потому что они лоцируются дорого.
[45:39.660 --> 45:41.620]  Там M-map делается, M-protect, изколы.
[45:41.620 --> 45:43.980]  Вот в хороших, быстрых Fiber'ах, разумеется, не должно быть
[45:43.980 --> 45:44.980]  изколы при создании.
[45:44.980 --> 45:52.820]  Или вот эта самая интрузивность, это еще одна мощная оптимизация.
[45:52.820 --> 45:57.500]  Вот мы говорим threadpool-submit, а что в submit попадает?
[45:57.500 --> 45:58.500]  Задача, да?
[45:58.500 --> 46:00.140]  А что такое задача?
[46:00.140 --> 46:02.820]  Это unique function.
[46:02.820 --> 46:06.420]  Знаете ли вы, что такое type erasure?
[46:06.420 --> 46:13.140]  Ну вот представьте, что вы, у вас есть две лямбды.
[46:13.140 --> 46:19.060]  Можете ли вы их положить в вектор?
[46:19.060 --> 46:21.020]  Не можете, конечно, потому что у них типы разные.
[46:21.020 --> 46:24.900]  А можете ли вы положить две STD function-вектор с одной
[46:24.900 --> 46:25.900]  сигнатурой?
[46:25.900 --> 46:29.700]  Какой-то обман, да?
[46:29.700 --> 46:30.700]  Как так получилось?
[46:30.700 --> 46:35.860]  Видимо, как-то, ну, то есть, unique function, STD function стерло
[46:35.860 --> 46:38.060]  конкретный тип лямбды и заменил его чем-то общим.
[46:38.060 --> 46:40.700]  Ну, в этом есть некоторый overhead.
[46:40.700 --> 46:43.140]  Внутри allocation спрятано.
[46:43.140 --> 46:45.300]  Вот если вы не знаете, как написать STD function, подумайте.
[46:45.300 --> 46:47.340]  Ну, я однажды расскажу, пока не очень важно.
[46:47.340 --> 46:49.660]  Главное, что внутри allocation скрытые.
[46:49.660 --> 46:53.740]  Или, скажем, вот вы бросаете задачу в пул потоков, ну,
[46:53.740 --> 46:57.020]  там, задачу, которая исполнит кусочек файбера.
[46:57.020 --> 47:00.500]  А что такое submit в пул потоков?
[47:00.500 --> 47:02.460]  Это добавить задачу в очередь.
[47:02.460 --> 47:03.860]  А что такое добавить задачу в очередь?
[47:03.860 --> 47:06.420]  Сделать pushback в, не знаю, дэк.
[47:06.420 --> 47:07.420]  Это еще одна локация.
[47:07.420 --> 47:11.820]  Нужна она там или нет?
[47:11.820 --> 47:14.260]  Вот над этими вопросами можно размышлять и можно
[47:14.260 --> 47:17.220]  в конце концов, ну, я так забегаю вперед совсем далеко,
[47:17.220 --> 47:23.060]  в том, что можно сделать так, чтобы в наших файберах
[47:23.060 --> 47:24.660]  allocations при исполнении не было.
[47:24.660 --> 47:28.140]  То есть они перепланируются, они берут mutex, они там ждут
[47:28.140 --> 47:32.540]  на каналах, на селектах, а allocations при этом в коде
[47:32.540 --> 47:33.540]  вообще ноль.
[47:33.540 --> 47:42.300]  Это довольно хитрое свойство, которое, в общем, которого
[47:42.300 --> 47:46.100]  можно добиться и опять же сделать это, это настоящая
[47:46.780 --> 47:49.740]  сложная оптимизация, и она абсолютно не про Assembler
[47:49.740 --> 47:53.060]  и не про какие-то асимптотики, не про структуру данных.
[47:53.060 --> 48:01.900]  Я бы сказал, что программирование настоящее большое, но выглядит
[48:01.900 --> 48:03.460]  как примерно вот такая задача.
[48:03.460 --> 48:08.140]  Много инструментов разных может понадобиться, можно
[48:08.140 --> 48:10.740]  в много направлений пойти, много оптимизаций сделать.
[48:10.740 --> 48:13.940]  С самых разных сторон код улучшать.
[48:13.940 --> 48:19.780]  Что еще можно было бы сказать про задачу, которую мы, наверное,
[48:19.780 --> 48:20.780]  еще не начали решать?
[48:20.780 --> 48:23.820]  Ну, я бы вам порекомендовал сделать бонусный уровень
[48:23.820 --> 48:24.820]  про генератора.
[48:24.820 --> 48:29.660]  Я на лекции показывал, что можно делать такой хитрый
[48:29.660 --> 48:30.660]  конвейер.
[48:30.660 --> 48:33.900]  Ну ладно, эта ссылка не ведет никуда в интересное
[48:33.900 --> 48:34.900]  место.
[48:34.900 --> 48:43.460]  Такая вот хитрая функция, которая дожидается значений,
[48:43.460 --> 48:46.580]  и может быть передает дальше.
[48:46.580 --> 48:50.700]  Вот мы здесь говорим Send, и внутри этого Сенда вызывается
[48:50.700 --> 48:52.900]  на самом деле очередной шаг консьюмера.
[48:52.900 --> 48:59.420]  Ну вы, возможно, если вы писали на Питоне, то вы
[48:59.420 --> 49:01.940]  к этому привыкли, вы знаете, что там такое с Поширядом.
[49:01.940 --> 49:06.940]  Ну вот, опять полезно увидеть, как это можно реализовать
[49:06.940 --> 49:11.980]  все плюс-плюс, причем реализовать через некоторый общий механизм,
[49:12.980 --> 49:16.700]  не то, что в смысле наследования базу, но некоторую такую
[49:16.700 --> 49:21.660]  общую базу функциональную, Crouting Imp.
[49:21.660 --> 49:27.980]  Короче, осмыслить дизайн, вот, все части этого условия
[49:27.980 --> 49:30.700]  и весь предложенный дизайн, это само по себе сложно.
[49:30.700 --> 49:32.820]  Это новый класс задач, и дальше у нас задачи будут
[49:32.820 --> 49:34.780]  скорее большими, чем маленькими.
[49:34.780 --> 49:37.620]  Иногда будут маленькие встречаться, но сейчас мы
[49:37.620 --> 49:42.180]  все уже вот эти маленькие паттерны синхронизации
[49:42.180 --> 49:46.020]  изучили, дальше мы из них хотим собирать сложные
[49:46.020 --> 49:47.020]  фреймворки.
[49:47.020 --> 49:52.180]  Ну и да, я хотел сказать, чуть не забыл, мы же в чате
[49:52.180 --> 49:55.620]  предложили чудесную идею, она мне прям очень понравилась,
[49:55.620 --> 49:58.460]  ну в смысле, я хотел ее сделать, но прямо не до такой степени,
[49:58.460 --> 50:00.620]  как предложили, а мне она и понравилась.
[50:00.620 --> 50:03.060]  Вы смотрите, вы написали Mutex и Condvar с помощью Atomic,
[50:03.060 --> 50:06.780]  да, потому что ElectroDipool с помощью Mutex и Condvar, что
[50:06.780 --> 50:08.580]  можно было бы сделать, ну прямо сейчас можно было
[50:08.580 --> 50:09.580]  бы сделать.
[50:09.580 --> 50:14.540]  Взять и в задачу вставить ваше решение Mutex и Condvar,
[50:14.540 --> 50:18.660]  и получится, что вы сделали Treadpool с помощью одного Atomic.
[50:18.660 --> 50:23.020]  Ну, конечно, выделив компоненты перед этим, но тем не менее,
[50:23.020 --> 50:24.860]  по сути, вам нужен был один Atomic.
[50:24.860 --> 50:30.100]  А дальше мы этот Treadpool будем использовать для Fiber'ов,
[50:30.100 --> 50:35.900]  а дальше мы сделаем Mutex и Condvar, вот, и там много всего,
[50:35.900 --> 50:39.220]  и в итоге, ну, если вы получите Othel, то, мне кажется, что
[50:39.220 --> 50:41.500]  у вас будет возможность в конце курса собрать это
[50:41.500 --> 50:44.860]  все в одну библиотеку, где буквально из одного из
[50:44.860 --> 50:48.420]  тогда Atomic, это все, что нужно от стандартной библиотеки,
[50:48.420 --> 50:51.380]  можно будет построить свой ГО, который умеет много
[50:51.380 --> 50:52.380]  всего.
[50:52.380 --> 50:53.380]  А Futex?
[50:53.380 --> 50:56.380]  А Futex, ну мы же тоже напишем его.
[50:56.380 --> 51:00.580]  Ну, в смысле, я говорю про Atomic, в смысле, я говорю,
[51:00.580 --> 51:04.500]  что нам нужно от компьютера уметь блокирующее ожидание,
[51:05.180 --> 51:08.180]  уметь искол Futex и уметь автомарные операции для синхронизации.
[51:08.180 --> 51:10.980]  И это все, что нужно, чтобы построить что-то сложное.
[51:10.980 --> 51:14.900]  Ну вот, мы это все в виде Atomic'а получаем, а все остальное
[51:14.900 --> 51:16.340]  мы с помощью Atomic'а можем сделать сами.
[51:16.340 --> 51:19.340]  Понятно мысль?
[51:19.340 --> 51:23.860]  Вот, ну, то есть, понятно, что мы можем и мы так по
[51:23.860 --> 51:26.140]  шагам делаем, но я надеюсь, что будет финальный шаг,
[51:26.140 --> 51:27.620]  где можно это все слепить вообще в одно.
[51:27.620 --> 51:31.820]  Кажется, что это будет занятно.
[51:31.860 --> 51:34.860]  Кроме того, у нас еще, ну, я сразу предупреждаю, что
[51:34.860 --> 51:37.060]  тут кого-то может огорчить, что мы двигаем код из задачи
[51:37.060 --> 51:38.060]  в задачу.
[51:38.060 --> 51:40.820]  Так, к сожалению, будет происходить, потому что
[51:40.820 --> 51:42.580]  мы двигаем код, иногда его немного меняем.
[51:42.580 --> 51:47.180]  И вот скажем, мы Treadpool еще раз будем переиспользовать,
[51:47.180 --> 51:50.700]  и мы подвинем его еще во вложенную директорию и так немного
[51:50.700 --> 51:51.700]  обобщим.
[51:51.700 --> 51:54.940]  Короче, вот мы так наблюдаем за эволюцией этого всего
[51:54.940 --> 52:01.620]  кода, и через два месяца мы уже можем, ну, довольно
[52:01.700 --> 52:04.860]  много себе вещей словно представить вот сразу в одной картинке.
[52:04.860 --> 52:10.020]  У нас еще Future появится, который мы тоже интегрируем
[52:10.020 --> 52:11.500]  сюда к Fiber'ам.
[52:11.500 --> 52:16.220]  Эта вот лекция будет, которая через раз суббота, два суббота,
[52:16.220 --> 52:17.220]  третий суббота.
[52:17.220 --> 52:19.500]  Вот мы поговорим про Future.
[52:19.500 --> 52:22.820]  Да, кстати, Future я по-прежнему рекомендовал в канале,
[52:22.820 --> 52:23.820]  рекомендую и сейчас.
[52:23.820 --> 52:30.580]  Задачу это сделать, потому что дальше, в будущем, ну,
[52:30.580 --> 52:32.700]  в будущем вам говорят, сделайте плохие стады Future
[52:32.700 --> 52:33.700]  бесполезные.
[52:33.700 --> 52:38.780]  И, ну, они действительно плохие и бесполезные, я вас
[52:38.780 --> 52:41.340]  не обманываю ни в коем случае, но дальше мы поговорим
[52:41.340 --> 52:43.660]  про хорошие Future.
[52:43.660 --> 52:46.780]  Потому что вот здесь Future — это такой, ну, одноразовый
[52:46.780 --> 52:49.140]  условный канал для передачи значения.
[52:49.140 --> 52:52.380]  На самом деле Future, конечно, не для этого нужны.
[52:52.380 --> 52:55.260]  Вот я не знаю, пугает ли вас это слово, Future — это
[52:56.260 --> 53:00.820]  Это такой инструмент для композиции вычислений.
[53:00.820 --> 53:03.300]  Fiber — это инструмент для композиции вычислений,
[53:03.300 --> 53:07.060]  и Future — это инструмент для композиции вычислений.
[53:07.060 --> 53:08.060]  Я вам на лекции расскажу.
[53:08.060 --> 53:12.260]  Вот скажем, Twitter, они пишут, что у них все свои сервисы,
[53:12.260 --> 53:15.820]  они пишут на фреймворке, там, где есть RPC, Future и декораторы
[53:15.820 --> 53:16.820]  для них.
[53:16.820 --> 53:18.420]  То есть это такое средство, с помощью которого они
[53:18.420 --> 53:22.300]  свою логику описывают, своего кода.
[53:22.740 --> 53:27.340]  Ну, мы это все увидим однажды, и чтобы мы к этой лекции
[53:27.340 --> 53:29.660]  были готовы, чтобы у нас были какие-то минимальные
[53:29.660 --> 53:32.100]  представления о том, что такое Future, как оно реализовано,
[53:32.100 --> 53:35.500]  вот нужно сейчас задачу решить.
[53:35.500 --> 53:38.420]  Ну и плюс они объясняют нам, как можно решить проблему
[53:38.420 --> 53:42.940]  с тредпулом, потому что тредпул, кажется, не умел дожидаться
[53:42.940 --> 53:46.940]  конкретной задачи и не умел вернуть из нее значение.
[53:46.940 --> 53:50.900]  Ну вот мы в этой задачи, в этом примере увидим, что
[53:50.900 --> 53:53.100]  тредпулу не нужно, потому что если у нас есть Future
[53:53.100 --> 53:55.220]  и тредпул, то можно их скомбинировать и получить
[53:55.220 --> 53:59.340]  то, что мы хотим.
[53:59.340 --> 54:01.740]  Можно написать маленькую функцию вспомогательную,
[54:01.740 --> 54:05.540]  которая просит задачу в пул с промиссом, а нам сразу
[54:05.540 --> 54:06.540]  вернет Future.
[54:06.540 --> 54:11.140]  Но для этого тредпул дорабатывать вроде бы не требуется.
[54:11.140 --> 54:22.060]  Ну что ж, вот, наблюдайте, как все это происходит, потому
[54:22.060 --> 54:24.780]  что тут постепенно разные вещи начинают собираться,
[54:24.780 --> 54:26.540]  они не то чтобы мы, не то чтобы какие-то независимые
[54:26.540 --> 54:27.540]  вещи делаем.
[54:27.540 --> 54:30.140]  Ну тут барьер, симафор — это какие-то маленькие такие
[54:30.140 --> 54:33.100]  бесполезные штуки, такие маленькие учебные примеры,
[54:33.100 --> 54:36.780]  а вот все остальное, мне кажется, что оно собирается
[54:36.780 --> 54:41.540]  в одну большую картину, и нужно, чтобы она у вас
[54:41.540 --> 54:42.540]  накапливалась в голове.
[54:42.540 --> 54:48.020]  Подкиньте вопрос, может быть, потому что я вот что хотел
[54:48.020 --> 55:01.780]  сказал вроде бы, а что вы хотели, я не знаю.
[55:01.780 --> 55:04.500]  Мне кажется, не знаю, можно считать, что это, смотрел
[55:04.500 --> 55:05.500]  обыкновенное чудо.
[55:06.500 --> 55:08.500]  Или читал, может быть, пьесу.
[55:08.500 --> 55:11.500]  Ну короче, есть такая замечательная пьеса, шварца советская.
[55:11.500 --> 55:15.500]  Там такой король, Самадур.
[55:15.500 --> 55:21.500]  Коротко это мне захотелось, потому что Weight Idol — это
[55:21.500 --> 55:24.500]  имя, которое так хорошо описывает семантику метода.
[55:24.500 --> 55:26.500]  Вот Weight плохо его описывает.
[55:26.500 --> 55:29.500]  И там в чате уже начались вопросы, а что делает Weight,
[55:29.500 --> 55:30.500]  чего он там у меня дожидается.
[55:30.500 --> 55:32.500]  Ну в самом деле непонятно.
[55:33.500 --> 55:35.500]  А что делает Weight Idol, понятно даже школьнику.
[55:37.500 --> 55:39.500]  Это же большая удача придумать такой набор методов с такими
[55:39.500 --> 55:41.500]  хорошими именами, чтобы все было сразу ясно.
[55:43.500 --> 55:45.500]  Так что нужно, чтобы код был лучше, потому что нам
[55:45.500 --> 55:46.500]  с ним долго еще жить.
[55:52.500 --> 55:54.500]  Какой-то необходимости, ну разумеется, необходимости
[55:54.500 --> 55:55.500]  в этом не было.
[55:55.500 --> 55:59.500]  Но я, конечно, оставляю за собой некоторые… Я хочу,
[55:59.500 --> 56:02.500]  чтобы этого было меньше, но все же я считаю, что
[56:02.500 --> 56:05.500]  у нас возможны в курсе моменты, когда я ломаю немного
[56:05.500 --> 56:08.500]  шаблоны, потому что я считаю, что глобально это пользу
[56:08.500 --> 56:09.500]  нанесет всем.
[56:09.500 --> 56:13.500]  Ну ценой некоторых конфликтов при апдейте репозитория,
[56:13.500 --> 56:14.500]  при слиянии каких-то.
[56:14.500 --> 56:17.500]  Ну неприятная ситуация, но иногда ничего не пойдет.
[56:20.500 --> 56:25.500]  В прошлый год был метод Join, и у него была такая совмещенная
[56:25.500 --> 56:26.500]  семантика.
[56:26.500 --> 56:30.500]  Это такая стандартная штука вообще-то в тредпулах,
[56:30.500 --> 56:32.500]  но вот текущий опиум гораздо лучше.
[56:35.500 --> 56:38.500]  Курс совершенствуется, никто этого не замечает, конечно,
[56:38.500 --> 56:41.500]  но вот с каждым годом… И за счет того, что он совершенствуется,
[56:41.500 --> 56:44.500]  с каждым годом мы делаем все больше и больше, потому
[56:44.500 --> 56:46.500]  что все более гладко и гладко все проходит.
[56:46.500 --> 56:50.500]  Так что мы в этом году можем дойти необычайно далеко.
[56:57.500 --> 56:58.500]  Такая история.
[57:00.500 --> 57:03.500]  Вообще то, что мы делаем, люди пишут, ну не знаю, это
[57:03.500 --> 57:05.500]  пишут какие-то очень старшие разработчики на самом деле.
[57:07.500 --> 57:08.500]  Вот.
[57:08.500 --> 57:10.500]  Но, конечно, это не означает, я не пытаюсь сказать, что
[57:10.500 --> 57:12.500]  вы придете в курс и станете старшим разработчиком.
[57:12.500 --> 57:14.500]  Нет, так не работает вселенная.
[57:14.500 --> 57:17.500]  Ну потому что самые сложные вещи в курсе делаю я все же.
[57:18.500 --> 57:22.500]  То есть, но то, что мы делаем, это действительно сложно.
[57:22.500 --> 57:25.500]  Сложно не просто так бы запомнить много там нюансов
[57:25.500 --> 57:29.500]  в суффиксном дереве, а вот по-пограммистски, по-инженерному
[57:29.500 --> 57:30.500]  сложно.
[57:31.500 --> 57:33.500]  В конце концов, мы получим довольно неплохой год, если
[57:33.500 --> 57:37.500]  мы напишем, ну если вы напишите его хорошо, то вы не будете
[57:37.500 --> 57:38.500]  за него стыдиться.
[57:39.500 --> 57:41.500]  Знаете, говорят, что вот есть такой код, который проиграет
[57:41.500 --> 57:42.500]  только ваша мама.
[57:43.500 --> 57:46.500]  Вот можно написать очень хороший код.
[57:46.500 --> 57:47.500]  Вопросы еще.
[57:48.500 --> 57:49.500]  Я, кажется, про адреса не тазерный.
[57:49.500 --> 57:52.500]  Успеваю с вами поговорить, что меня скорее печарит.
[57:54.500 --> 57:55.500]  Не успеваю.
[57:55.500 --> 57:57.500]  Мне нужно минут, не знаю, двадцать.
[58:05.500 --> 58:07.500]  Я боюсь, что просто нас вытеснет в конце.
[58:07.500 --> 58:09.500]  Я бы не хотел это сделать.
[58:09.500 --> 58:11.500]  Я бы не хотел это сделать.
[58:12.500 --> 58:15.500]  Я боюсь, что просто нас вытеснет в конце.
[58:15.500 --> 58:17.500]  Я бы не хотел, чтобы нас вытесняли.
[58:21.500 --> 58:23.500]  Ладно, в следующий раз мы это разберем, может быть,
[58:23.500 --> 58:25.500]  не страшно, потому что все равно я не только про него
[58:25.500 --> 58:27.500]  хочу рассказать, а еще про что-то другое.
[58:30.500 --> 58:32.500]  Может быть, у вас вопросы просто есть по домашкам
[58:32.500 --> 58:33.500]  еще.
[58:33.500 --> 58:35.500]  Ну, желательно по каким-то новым, ну или по темам лекций
[58:35.500 --> 58:40.500]  последней, потому что, ну наверняка что-то должно
[58:40.500 --> 58:41.500]  быть.
[58:46.500 --> 58:48.500]  Неужели прям все ясно?
[58:49.500 --> 58:51.500]  Это может быть вы большие молодцы просто, я не
[58:51.500 --> 58:53.500]  сомневаюсь, но даже если бы вы были большими
[58:53.500 --> 58:55.500]  молодцами все, то у вас были бы более сложные
[58:55.500 --> 58:56.500]  вопросы.
[58:56.500 --> 58:57.500]  Да, давай.
[59:02.500 --> 59:03.500]  Ну была такая, да.
[59:08.500 --> 59:09.500]  Спинлок.
[59:16.500 --> 59:17.500]  Ну, да.
[59:19.500 --> 59:20.500]  Ну, да.
[59:22.500 --> 59:23.500]  Ну, да.
[59:23.500 --> 59:24.500]  Ну, да, вот.
[59:28.500 --> 59:31.500]  У меня вопрос, почему, в смысле,
[59:32.500 --> 59:34.500]  если вы будете смотреть, то
[59:35.500 --> 59:37.500]  вы заткнулись в историю,
[59:37.500 --> 59:39.500]  не вижу в этом центре инструкцию Exchange.
[59:41.500 --> 59:43.500]  Ну, это хорошо, что ты увидел, но ответа пока нет
[59:43.500 --> 59:45.500]  вопроса нет. Эта тема про модели памяти, она будет
[59:45.500 --> 59:47.500]  через субботу. Нет, давайте рискнем, потому что
[59:47.500 --> 59:49.500]  что это у нас? Семинары разъезжаются в
[59:49.500 --> 59:51.500]  двух групп, не дело.
[59:51.500 --> 59:53.500]  Давайте все-таки попробуем про адрес
[59:53.500 --> 59:54.500]  CineTizer поговорить.
[59:56.500 --> 59:58.500]  А если нас вытеснили из
[59:58.500 --> 59:59.500]  аудитории?
[01:00:10.500 --> 01:00:12.500]  Можем, наверное. Я бы хотел скринкаст
[01:00:12.500 --> 01:00:13.500]  склеить просто.
[01:00:13.500 --> 01:00:15.500]  Давайте попробуем начать сейчас, но
[01:00:15.500 --> 01:00:17.500]  успеем успеем, я пытаюсь
[01:00:17.500 --> 01:00:19.500]  быстро, гладенько все объяснить.
[01:00:20.500 --> 01:00:22.500]  Итак, мы переходим
[01:00:22.500 --> 01:00:40.500]  portions.
[01:00:40.500 --> 01:00:42.500]  Мы хотим поговорить про тестирование
[01:00:42.500 --> 01:00:52.300]  поговорить про тестирование кода, потому что... Давайте я вам объясню, в чем сложность.
[01:00:52.300 --> 01:00:59.820]  В том, что любой сложный код нужно тестировать, разумеется, а любой
[01:00:59.820 --> 01:01:04.540]  недотерминированный код нужно тестировать гораздо аккуратнее, потому что
[01:01:04.540 --> 01:01:09.140]  недотерминированный код гораздо сложнее, потому что для него
[01:01:09.140 --> 01:01:14.660]  юнит теста не напишешь, не переберешь аккуратно все поведения, не поверишь в все инварианты, и вот чем
[01:01:14.660 --> 01:01:20.180]  сложнее код, который мы пишем, тем... Ну, вы представьте себе, мы пишем примитиву
[01:01:20.180 --> 01:01:24.700]  синхронизации, мы пишем свой собственный го, там всякие переключения, сплю свои
[01:01:24.700 --> 01:01:31.100]  капы, какие-то перепланирования. Вот вы написали там свой мьютокс, свой
[01:01:31.100 --> 01:01:36.020]  кондвар, свой тредпул. Почему вы уверены, что вы правильный код написали? Почему вы
[01:01:36.020 --> 01:01:41.500]  уверены, что он правильный синхронизирован? Вот если вы просто напишете стресс-тест, то
[01:01:41.500 --> 01:01:48.140]  вам это не поможет, потому что сложные баги в стресс-тестах не появятся, скорее
[01:01:48.140 --> 01:01:54.020]  всего. И вот в курсе, мы используем целый набор инструментов, и в частности, мы
[01:01:54.020 --> 01:01:57.340]  используем... Ну, мы там используем фут инжекшен, мы используем там файбры для
[01:01:57.340 --> 01:02:03.740]  чего-то, вот сегодня точно про это не успею, а еще мы используем санитайзеры. И я бы
[01:02:03.740 --> 01:02:08.340]  хотела поговорить немного про них. У нас санитайзеров два. У нас адрес санитайзера и тред санитайзер.
[01:02:08.340 --> 01:02:12.300]  Адрес санитайзера, он про проблемы работы с памятью, про memory safety,
[01:02:12.300 --> 01:02:17.260]  тред санитайзер про тред сафти, то есть про датарейсы. Но вот что такое датарейс,
[01:02:17.260 --> 01:02:22.020]  как работает тред санитайзер, объяснить сложно, потому что он находит датарейсы,
[01:02:22.020 --> 01:02:25.660]  а что такое датарейс, я еще строго не определял. Я сказал, что это два
[01:02:25.660 --> 01:02:29.340]  несинхронизированных обращения к ячейке памяти, среди которых одну запись. Но это
[01:02:29.340 --> 01:02:34.140]  пока не строгое определение, строгое будет в моделях памяти. А вот адрес санитайзера это то,
[01:02:34.140 --> 01:02:39.780]  что кажется понятно нам сейчас, и это вещь более универсальная, потому что она будет просто
[01:02:39.780 --> 01:02:49.660]  проработать с памятью. Вот давайте посмотрим на пример. Вот такая функция badStringView.
[01:02:49.660 --> 01:02:57.140]  Знаем ли мы, что такое string? Это класс, у которого есть поле, там, чарзвездочка у
[01:02:57.140 --> 01:03:04.580]  pointer на буфер, есть размер, и вот когда мы создаем строку, на кучу алоцируется буфер для нее,
[01:03:04.580 --> 01:03:10.140]  когда строка разрушается, буфер освобождается. Когда строка копируется, копируется буфер,
[01:03:10.140 --> 01:03:15.380]  то есть алоцируется новый, копируется его содержимое. А есть stringView. Что такое stringView?
[01:03:15.380 --> 01:03:22.580]  Это по сути тоже пара, чарзвездочка и размер. Но в отличие от строчки stringView памятью не
[01:03:22.580 --> 01:03:30.420]  владеет, просто ссылается на нее. Копирование stringView бесплатно, копирование двух полей. Поэтому,
[01:03:30.420 --> 01:03:39.300]  кстати, stringView не передавайте по ссылке, передавайте по значению всегда. Очевидно,
[01:03:39.300 --> 01:03:43.980]  в этом примере со stringView есть некоторая проблема, потому что вот здесь мы ссылаемся на строчку
[01:03:44.580 --> 01:03:53.380]  hello, а после этого вызывается деструктор строчки тест, и буфер, видимо, освобождается. Мы отдаем память
[01:03:53.380 --> 01:04:00.900]  локатору. Блок уже не адресуем, но при этом stringView ссылается на него, и здесь мы печатаем
[01:04:00.900 --> 01:04:14.460]  какое-то содержимое. Будет ли это работать? Сейчас, подожди, ну тут что бы ни было, все равно
[01:04:14.460 --> 01:04:27.620]  программа некорректная, да? Правда ведь? Ну она некорректная, ты обращаешься к памяти объекта,
[01:04:27.620 --> 01:04:35.900]  который разрушен. Что значит, как бы он не был реализован, это не то, что ты хочешь. Еще раз,
[01:04:35.900 --> 01:04:42.500]  речь не про то, как работает компьютер, речь про семантику. У тебя объект разрушен. Почему ты,
[01:04:42.500 --> 01:04:47.460]  рассуждая про семантику программы, рассуждаешь про конкретную оптимизацию, которая сделана в конкретной
[01:04:47.460 --> 01:04:53.140]  библиотеке? Это, кажется, не должен делать, это нарушение абстракции. У тебя абстракция
[01:04:53.140 --> 01:04:57.500]  что значит? Нет, код, конечно, некорректный, потому что мы ссылаемся на строчку, которая уже не
[01:04:57.500 --> 01:05:02.460]  существует. Если она отцирована на куче, то это точно и беда. Если она отцирована на стэке,
[01:05:02.460 --> 01:05:12.140]  ну ладно, строчка пока короткая, это правильное замечание, но пример, смотрим-смотрим, работает.
[01:05:12.140 --> 01:05:24.380]  Да я знаю про ССО, я говорю, что она и так не упадет.
[01:05:30.660 --> 01:05:35.860]  Она и так и так неправильная, и так и так работает, но тем не менее,
[01:05:35.860 --> 01:05:44.620]  для того, чтобы эти ошибки найти, у нас есть адрес санитайзера. Адрес санитайзера — это
[01:05:44.620 --> 01:05:51.220]  инструмент в компиляторе. Мы ставим флажок fsanitizer-dress, запускаем этот код, и что мы видим?
[01:05:51.220 --> 01:06:06.340]  Вот в этом примере. Хип юз офтофри. Неудобство. Ну, если исправить здесь вот так вот, то не то,
[01:06:06.340 --> 01:06:19.580]  чтобы станет лучше. Мы получили стэк юз офтоскоп. В любом случае, это проезд по памяти.
[01:06:19.580 --> 01:06:33.260]  Ну, здесь строчка лежит на стэке, вот со знаками восклицания, она лежит на куче,
[01:06:33.260 --> 01:06:37.140]  но тем не менее, что произошло? Строчка разрушилась, мы аллокатора дали память,
[01:06:37.140 --> 01:06:44.140]  аллокатор ее положил поинтер на освободившийся блок куда-то в себя, ну а байт это в памяти остались,
[01:06:44.140 --> 01:06:48.220]  мы просто на них сослались. Поэтому программа не падает, но это плохо, а нехорошо,
[01:06:48.380 --> 01:06:53.100]  потому что хорошая программа не работает, когда она совершила ошибку. Когда в ней появился бак,
[01:06:53.100 --> 01:07:00.380]  программа должна упасть. Вот для этого есть адрес санитайзер, и он такие ошибки нам обнаруживает.
[01:07:00.380 --> 01:07:08.540]  И вот нам интересно, как он устроен. Почему нам интересно это вообще понятно,
[01:07:08.540 --> 01:07:15.300]  а почему нам интересно это в конкретном курсе? Потому что мы пишем конкарнси, а конкарнси,
[01:07:15.300 --> 01:07:22.660]  ну ошибки в конкарнсе, какие-то рейс-кондишны часто могут проявлять себя как неправильная
[01:07:22.660 --> 01:07:28.620]  работа с памятью. Ну вот пример, у нас есть односвязанный список, который я уже показывал,
[01:07:28.620 --> 01:07:37.300]  кажется, не один раз, и мы с ним работаем из разных поток. Чем эта работа может закончиться?
[01:07:37.300 --> 01:07:50.700]  Разными исходами. Во-первых, мы можем получить heapUseAutoFree в методе forwardListPop вот в этой строчке.
[01:07:50.700 --> 01:07:56.700]  Почему? Потому что пришли два потока, они оба прочли одну и ту же голову в локальную переменную,
[01:07:56.700 --> 01:08:04.020]  потом один поток головы переставил, удалил голову, а дальше мы вот здесь по этому поинтеру
[01:08:04.020 --> 01:08:12.180]  пошли в удаленный блок, удаленный узел и попробовали прочесть next. Ну вот использование памяти после ее
[01:08:12.180 --> 01:08:19.100]  освобождения UseAutoFree. Вот если перезапускать этот код, то через некоторое время, повезло сразу,
[01:08:19.100 --> 01:08:26.580]  реализовалось double free. Два потока вошли в поп, прочли один и тот же pointer, переставили один и тот же,
[01:08:26.580 --> 01:08:35.380]  переставили point голову вперед на одно и то же, и потом дважды удалили. Пять проблем. Ну то есть у нас
[01:08:35.380 --> 01:08:41.140]  проблемы с памятью проявляются, проблемы с синхронизацией проявляются как проблемы с памятью.
[01:08:41.140 --> 01:08:46.860]  Вот поэтому мы в курсе используем адрес-санитайзер, потому что просто он ищет байлист работы с памятью,
[01:08:46.860 --> 01:08:56.940]  а во-вторых, эти баги могут быть средствами ошибок с синхронизацией. И так, что нужно про
[01:08:56.940 --> 01:09:02.740]  санитайзер вообще глобально знать? Ну вот санитайзер хочет нам обеспечить memory safety, но точнее он
[01:09:02.740 --> 01:09:09.860]  конечно не может обеспечить ее, он всего лишь пытается обнаружить ошибки. Если в программе,
[01:09:09.860 --> 01:09:16.220]  в исполнении программы ошибка проявилась, то санитайзер ее найдет, а может и не найти,
[01:09:16.220 --> 01:09:22.500]  может пропустить, потому что он работает не идеально. А может быть в конкретном исполнении
[01:09:22.500 --> 01:09:29.740]  программы в программе ошибка есть, а в конкретном исполнении она не реализовалась. Санитайзер тоже
[01:09:29.740 --> 01:09:37.380]  ее не найдет поэтому. Санитайзер проверяет исполнение, а не программу. Поэтому он нам может сказать
[01:09:37.380 --> 01:09:41.900]  точно, что ошибка есть, но если он говорит что ошибки нет, то это само по себе не доказывает,
[01:09:42.100 --> 01:09:49.100]  что программа корректная. Но есть же альтернативные подходы. С++ такой подход. Мы собираем программу с
[01:09:49.100 --> 01:09:55.380]  санитайзером и находим ошибки. Есть другой подход, другие подходы к memory safety. Как гарантировать,
[01:09:55.380 --> 01:10:00.180]  что в программе нет висящих поинтов, которые указывают на освобожденную память уже?
[01:10:00.180 --> 01:10:14.700]  Чуть более общие слова нужно сказать. Как обеспечить в языке memory safety? Самое очевидное
[01:10:14.700 --> 01:10:25.380]  и пример. Сделать автоматическую сборку мусора в языке. У вас просто нет явных
[01:10:25.380 --> 01:10:31.260]  аллокаций. Вы не делаете делаллокации просто руками. За вас, за вас их делают сборщик мусора,
[01:10:31.260 --> 01:10:36.020]  делают их тогда, когда это безопасно. Когда гарантированно вы не можете в памяти обратиться,
[01:10:36.020 --> 01:10:39.140]  потому что у вас не осталось никаких способов до этой памяти добраться по ссылкам.
[01:10:39.140 --> 01:10:51.860]  Можно понимать автоматическую сборку мусора в двух смыслах. Можно представить себе автоматическое
[01:10:51.860 --> 01:11:00.540]  управление памятью в двух смыслах. Это сборка мусора, то есть гарбыч коллектор, и это референс
[01:11:00.540 --> 01:11:06.300]  каунтинг. В принципе, две стороны одной медали. Не то, чтобы это разные подходы. Они в
[01:11:06.300 --> 01:11:15.940]  каком-то смысле двойственные. Давайте подумаем, а за что мы в таких подходах платим? Потому что
[01:11:15.940 --> 01:11:23.180]  это же не бесплатно. Нам дают memory safety, но мы должны зачем-то за нее заплатить. Вот какова наша
[01:11:23.180 --> 01:11:36.500]  плата за безопасность? За отсутствие такого класса ошибок в программе? Так а плата-то в чем состоит?
[01:11:36.500 --> 01:11:46.300]  Непонятно. Мне кажется, что плата состоит в паузах. Но если мы говорим про простой сборщик мусора,
[01:11:46.300 --> 01:11:50.780]  самый такой наивный stop the world, то иногда ему нужно остановить исполнение вашей программы,
[01:11:50.900 --> 01:11:55.180]  чтобы зафиксировать граф объектов, а дальше этот граф объектов размером 100 гигабайт,
[01:11:55.180 --> 01:12:04.980]  30 секунд обходить. Вот 30 секунд ваша программа не отзывается. Неприятная ситуация. В плюсах
[01:12:04.980 --> 01:12:13.820]  нет сборки мусора. У нас memory safety в плюсах нет. Давай сразу до этого договоримся. Поэтому это не
[01:12:13.820 --> 01:12:19.300]  решение. Мы можем писать баги. В джайве мы такие баги написать не можем. Как классы, они отсутствуют.
[01:12:19.300 --> 01:12:25.620]  Но за это мы платим тем, что мы имеем overhead при исполнении. Во-первых, мы имеем overhead в смысле
[01:12:25.620 --> 01:12:31.580]  пауз сборщика мусора, а во-вторых, если мы говорим про современные языки и про более отзывчивые
[01:12:31.580 --> 01:12:36.180]  приложения, то там сборка мусора по-другому устроена. Там она не stop the world, там она concurrent.
[01:12:36.180 --> 01:12:43.180]  То есть у вас одни потоки мутируют граф объектов, они так называются мутаторы, а другие потоки обходят
[01:12:43.180 --> 01:12:49.540]  граф и помечают красить его в три цвета. И тут появляется дополнительная overhead, потому что
[01:12:49.540 --> 01:12:55.340]  паузы иногда бывают все же, пусть даже и короткие, но когда вы одновременно конкурентно меняете
[01:12:55.340 --> 01:13:01.020]  граф и обходите его, вам при мутации, при изменении графа, при переставлении ссылок, вам нужно
[01:13:01.020 --> 01:13:09.100]  исполнять некоторый служебный код, который вы тоже за это платите, чтобы просто сборщик мусора
[01:13:09.100 --> 01:13:15.580]  знал, что граф поменялся. И в принципе тут можно сразу увидеть аналогию с референс каунсингом,
[01:13:15.580 --> 01:13:22.340]  потому что вы всегда платите в референс каунсинге, когда вы переставляете ссылку, вы счетчик
[01:13:22.340 --> 01:13:28.060]  уменьшаете и увеличиваете. Поэтому референс каунсинг, это скорее два конца спектра,
[01:13:28.060 --> 01:13:33.340]  автоматическая сборка мусора и референс каунсинг. Они не то чтобы разные, они противоположные,
[01:13:33.340 --> 01:13:39.980]  но по сути они выполняют одну и ту же работу, они просто по-разному ее группируют. Ну референс
[01:13:39.980 --> 01:13:45.420]  каунсинг, там свои проблемы, там он в C++ не безопасен, он сам по себе не гарантирует проблему,
[01:13:45.420 --> 01:13:53.260]  не решает проблему с циклами, а в C++ shared pointer еще плохо, потому что в нем автоматический
[01:13:53.260 --> 01:13:58.140]  счетчик ссылок. У вас программа однопоточная, а счетчик ссылок атомарный, вы платите вообще
[01:13:58.140 --> 01:14:08.820]  ни за что. Это очень плохой дизайн, вот в C++ такого навал. Хорошо, есть ли альтернативный способ,
[01:14:08.820 --> 01:14:14.820]  как обеспечить memory safety без такого оверхеда? Мы хотим и memory safety, и отсутствие оверхеда при
[01:14:14.820 --> 01:14:24.020]  исполнении. Известен ли вам способ, как этого достичь? Ну статический анализатор есть примерно
[01:14:24.020 --> 01:14:29.820]  в одном месте в языке Rust, но это не то чтобы статический анализатор, этот подход не работает,
[01:14:29.820 --> 01:14:35.700]  это работает, когда у вас есть язык, который, система типов языка, это все позволяет делать.
[01:14:35.700 --> 01:14:40.940]  Вот система типов в языках программирования, это очень сложная тема, она не про то, что там строчку
[01:14:40.940 --> 01:14:47.220]  не складывается числом, она в общем случае про описание свойств программы, эти свойства могут
[01:14:47.220 --> 01:14:52.420]  быть самыми разными. Вот в Rust есть такое свойство, такой вариант, который вы поддерживаете для вашего
[01:14:52.420 --> 01:14:59.620]  кода, что вы не можете в коде иметь разом две ссылки на одну и ту же память, такие, что по крайней
[01:14:59.620 --> 01:15:05.460]  мере через одну ссылку вы можете в память писать, или ударять там, или что-то подобное делать. Вот скажем
[01:15:05.460 --> 01:15:10.020]  программа на C++, вы создаете вектор из двух элементов, вы берете pointer на первый его элемент,
[01:15:10.020 --> 01:15:14.700]  а потом вы делаете pushback, и ваша программа разваливается, потому что вектор перелатировал
[01:15:14.700 --> 01:15:19.420]  буфер, а ваш pointer так и остался, он вот висящая ссылка у вас, и вот вы здесь получаете юзовство
[01:15:19.420 --> 01:15:27.740]  free. В Rust такая программа не комперируется, потому что вы не можете получить две мутабельные ссылки,
[01:15:27.740 --> 01:15:37.580]  но это с одной стороны здорово, потому что Rust статически запрещает вам неправильные
[01:15:37.580 --> 01:15:43.540]  программы, но конечно же Rust не может отличить правильные программы от неправильных, он может
[01:15:43.540 --> 01:15:48.660]  просто отличить программы, в которых есть некоторые паттерны по сути, так что он запрещает конечно
[01:15:48.660 --> 01:15:54.140]  программы с ошибками, а еще запрещает какие-то разумные программы. Скажем, в таких ограничениях
[01:15:54.140 --> 01:16:02.300]  нельзя написать вдвусвязанный список, это довольно печально, но поэтому в Rust есть некоторое
[01:16:02.300 --> 01:16:07.500]  небезопасное подможество, из-за того, как вы можете писать код, в котором могут быть нарушения
[01:16:07.500 --> 01:16:13.540]  memory-safety, но вы можете дальше спрятать этот код за безопасным API, и там короче есть целая работа
[01:16:13.540 --> 01:16:19.740]  по формализации всего этого. А еще смотрите, какое интересное свойство из этого решения в Rust
[01:16:19.740 --> 01:16:27.760]  следует. Вам говорят, вы не можете иметь два поинтера на одну и ту же ячейку так, чтобы через один
[01:16:27.760 --> 01:16:33.820]  поинтер можно было писать. А теперь вспомните, что такое датарейс. Это ситуация, когда у вас два
[01:16:33.820 --> 01:16:39.460]  потока, которые пишут в одну ячейку несинхронизированно, в смысле два потока, которые обращаются
[01:16:39.460 --> 01:16:44.060]  к одной ячейке несинхронизированной, и по крайней мере одно из обращений в запись. Так вот, если Rust
[01:16:44.060 --> 01:16:49.140]  просто запрещает в своих программах иметь два таких поинтера, то у вас не только memory-safety будет,
[01:16:49.140 --> 01:16:57.460]  у вас еще будет датарейс-safety. У вас датарейсов не будет. Это вот еще один пример, что работа с
[01:16:57.460 --> 01:17:02.580]  памятью и buggy-синхронизация, это какие-то очень связанные друг с другом вещи.
[01:17:02.580 --> 01:17:13.900]  Ну что, дальше нужно говорить уже конкретно про адрес санитайза, про то, как он эти проблемы
[01:17:13.900 --> 01:17:22.420]  решает. Ну давайте, наверное, сделаем это после перерыва. Все-таки перетянемся в соседнюю
[01:17:22.420 --> 01:17:30.540]  аудиторию. Такая у нас пауза возникла. На чем мы остановились? Мы поговорили, что мы хотим искать
[01:17:30.540 --> 01:17:40.140]  ошибки, связанные с обращением к памяти, висящие указатели double-free. Хотим искать эти ошибки просто
[01:17:40.140 --> 01:17:46.020]  потому, что в любом сложном коде такие ошибки полезны отлавливать, а во-вторых, потому что эти
[01:17:46.020 --> 01:17:51.380]  ошибки в контексте нашего курса свидетельствуют, могут говорить о том, что у нас проблемы
[01:17:51.380 --> 01:17:57.980]  с синхронизацией. Вот мы обсудили, что есть разные подходы вообще как такие ошибки, но не то чтобы
[01:17:57.980 --> 01:18:02.940]  обнаруживать, а скорее предотвращать вообще. В принципе, это автентическая сборка мусора,
[01:18:02.940 --> 01:18:13.420]  это не то что правильная система типов, специально решающая такую задачу. Или в C++ это санитайзер.
[01:18:13.420 --> 01:18:20.340]  Санитайзер — инструмент, который обнаруживает ошибки не в программе, а в конкретном исполнении. И мы
[01:18:20.340 --> 01:18:25.420]  сейчас хотим поговорить, как он устроен. Важно заметить следующее с самого начала, что мы...
[01:18:25.420 --> 01:18:31.580]  Можно себе представить разные инструменты. Так вот, санитайзер — это инструмент, который целится в
[01:18:31.580 --> 01:18:38.020]  программы большие, скоро угодно большие. То есть он в промышленные программы целится, какие-то
[01:18:38.020 --> 01:18:47.580]  проекты из миллионов строчек. И это означает, что адрес санитайзера должен работать с большим кодом,
[01:18:47.580 --> 01:18:54.180]  с большими кучами. И желательно давать как можно меньше аверхед. То есть мы можем, наверное,
[01:18:54.260 --> 01:19:02.180]  придумать очень разные проверки, которые бы позволяли находить наши ошибки. Но адрес санитайзер
[01:19:02.180 --> 01:19:08.460]  может делать довольно просто, должен делать по возможности простые вещи, чтобы сочетаться с
[01:19:08.460 --> 01:19:17.100]  сложными программами. Итак, как же адрес санитайзер должен быть устроен? Ну, это можно понять,
[01:19:17.100 --> 01:19:23.140]  глядя вот на этот код. Вот мы его запускаем и здесь обнаруживаем, не знаю, что у нас сразу получится,
[01:19:23.140 --> 01:19:29.620]  юзов-тофри, нам повезло. Вот адрес санитайзер поймал ошибку сразу же. Вот мы в этом месте
[01:19:29.620 --> 01:19:36.740]  обратились к полю объекта на куче, который уже был деалацирован, и прямо в точке этого обращения
[01:19:36.740 --> 01:19:42.180]  мы сумели на ошибку обнаружить. Это очень важно, потому что дальше бы там все как-то каскадом
[01:19:42.180 --> 01:19:46.540]  накапливалось, уже непонятно, что бы произошло. А это также означает, что адрес санитайзер,
[01:19:46.900 --> 01:19:53.380]  видимо, выполнил проверку прямо вот здесь, прямо в этом обращении. Как же он это сумел сделать?
[01:19:53.380 --> 01:19:59.540]  По какому принципу вообще работают санитайзеры? Санитайзеры состоят, как правило, из двух
[01:19:59.540 --> 01:20:05.740]  компонентов. С одной стороны, они выполняют инструментацию кода, то есть исполняется не наша
[01:20:05.740 --> 01:20:13.260]  программа, исполняется программа, в которую комператор вот с флажком fsanitizeaddress вставил
[01:20:13.260 --> 01:20:21.780]  рядом с обращениями к памяти проверки. То есть вокруг этого, перед, условно, этим обращениям
[01:20:21.780 --> 01:20:27.180]  памяти находится некоторый служебный код, который проверяет, что память адресуема, что она вообще
[01:20:27.180 --> 01:20:33.540]  сейчас выделена локатором. Ну, во-первых, нам нужна инструментация, то есть нам нужно такие
[01:20:33.540 --> 01:20:40.740]  проверки в код вставить, а во-вторых, нам в runtime-е нужна какая-то структура данных, которая сможет
[01:20:40.740 --> 01:20:51.740]  эти проверки обслуживать. То есть нам нужно, ну, я, конечно, утрирую, но, грубо говоря, нам нужно для
[01:20:51.740 --> 01:20:57.740]  каждого байта памяти знать, адресуем он или нет. Вот мы такую проверку здесь вставим и проверим,
[01:20:57.740 --> 01:21:04.140]  но я, конечно, говорю неправду, потому что прям для каждого байта знать, адресуем он или нет,
[01:21:04.140 --> 01:21:12.900]  нам не требуется. Почему? Потому что нужно вспомнить про такое свойство работы с памятью, такое
[01:21:12.900 --> 01:21:18.980]  свойство локатора, как выравнивание. Ну, вот процессор ожидает, что наши данные выровнены,
[01:21:18.980 --> 01:21:25.820]  и компилятор это выравнивание соблюдает, и если вы обращаетесь к молоку и получаете этот блок
[01:21:25.820 --> 01:21:31.380]  памяти, то этот блок памяти всегда выровнен по 8. То есть, если вы алоцируете в динамической
[01:21:31.380 --> 01:21:39.260]  памяти какой-то объект, то его адрес кратен восьми. Это означает следующее, что если мы посмотрим на блок
[01:21:39.260 --> 01:21:47.580]  из восьми байт в памяти, ну, выровненный блок из восьми байт, то в каких состояниях, то может ли
[01:21:47.580 --> 01:21:53.340]  быть такое, что, скажем, вот первые два байта в этом блоке не алоцированы, а третий байт алоцирован.
[01:21:53.340 --> 01:21:59.780]  Возможно ли такая ситуация? Нет, невозможно, потому что любой объект, который был бы алоцирован,
[01:21:59.780 --> 01:22:08.340]  был бы выровнен по 8. Поэтому, если мы посмотрим на каждый блок размером 8 байт, то он бывает в восьми
[01:22:08.340 --> 01:22:15.740]  состояниях. Он может быть полностью адресуем, то есть все байты его адресуемые, либо адресуемые
[01:22:15.740 --> 01:22:26.260]  первые 7 байт, либо первые 6, либо 5, 4, 3, 2, 1, либо блок вообще не адресуемый. Это я сейчас к тому
[01:22:26.260 --> 01:22:32.620]  говорю, что нужно разобраться, а какую метаинформацию о состоянии памяти адрес Sanitizer должен
[01:22:32.620 --> 01:22:39.020]  поддерживать время исполнения. Вот он должен для каждого 8-байтового блока помнить, сколько байт в
[01:22:39.020 --> 01:22:46.140]  этом блоке доступно для чтения записи. Для каждого 8-байтового блока ему нужна метаинформация размером
[01:22:46.140 --> 01:22:55.140]  в 1 байт. Как адрес Sanitizer это поддерживает? Адрес Sanitizer подменяет аллокатор в программе.
[01:22:55.140 --> 01:23:08.620]  Когда он выделяет память, то он для блоков выделенных помечает в служебной части памяти,
[01:23:08.620 --> 01:23:17.020]  что эти блоки адресуемы. Когда он освобождает память, он эти блоки в некотором смысле отравляет.
[01:23:17.020 --> 01:23:24.220]  Но что именно я имею в виду? Тут я вам рекомендую обратиться к статье про адрес Sanitizer. Она,
[01:23:24.220 --> 01:23:30.900]  по-моему, очень... она 12-го года, но с тех пор Sanitizer не сильно менялся, и статья очень простая,
[01:23:30.900 --> 01:23:38.060]  и в нем очень много содержания. Адрес Sanitizer подменяет аллокатор, и у этого аллокатора есть
[01:23:38.060 --> 01:23:44.460]  зона, собственно, кучек, где аллокатор выделяет память, и есть зона, которая называется Shadow Area,
[01:23:44.460 --> 01:23:54.100]  или Shadow Memory. Это зона, в которой лежат служебные байтики, которые описывают состояние 8-байтовых
[01:23:54.100 --> 01:24:03.740]  блоков в куче. И когда адрес Sanitizer аллоцирует память, он в Shadow Area для аллоцированных блоков
[01:24:03.740 --> 01:24:08.620]  помечает, что они адресуемы. Когда освобождает, он помечает, что они не адресуемы теперь больше.
[01:24:08.620 --> 01:24:16.420]  А когда мы к ним обращаем... а когда мы обращаемся по Pointer в программе, то на стадии инструментации
[01:24:16.420 --> 01:24:25.580]  кода адрес Sanitizer помещает вот такую проверку. Вот мы собираюсь в программе прочесть такой адрес.
[01:24:25.580 --> 01:24:32.500]  Перед этим обращением адрес Sanitizer вставил... компилятор вставил такой код. Мы берем этот
[01:24:32.500 --> 01:24:41.500]  адрес, делим его на 8, то есть получаем фактически индекс 8-байтового блока, и добавляем к этому
[01:24:41.500 --> 01:24:49.220]  индексу магический offset, который означает вот начало Shadow Area, начало Shadow Memory. То есть мы
[01:24:49.220 --> 01:24:57.940]  вычисляем здесь для вот 8-байтового блока адрес байта, в котором лежит статус. И смотрим,
[01:24:57.940 --> 01:25:04.700]  если тут в этом служебном Shadow адресе написано 0, то это означает, что все 8-байт адресуемы.
[01:25:04.700 --> 01:25:11.380]  Если же он не равен 0, то значит адресуема какая-то только часть байта или вообще никакие,
[01:25:11.380 --> 01:25:20.780]  поэтому мы пишем отчет. Вот, кажется, и вся механика. И вы смотрите, когда мы
[01:25:20.780 --> 01:25:26.860]  получили User-free, то нам адрес Sanitizer в отчете вместе со стэками написал еще и кусочек Shadow
[01:25:26.860 --> 01:25:36.780]  Memory. Вот мы обратились к какому-то байту, и вот смотрите, в каком он был. То есть мы читали узел
[01:25:36.780 --> 01:25:44.380]  списка, перед этим чтением мы обратились к служебному байту в Shadow Memory, и в этом байтике
[01:25:44.380 --> 01:25:53.740]  была написана такая же стеричная константа FD. То есть этот 8-байтовый блок был освобожден уже
[01:25:53.740 --> 01:26:01.860]  отданного локатора. Вот когда мы отдаем память локатору, локатор записывает в Shadow байта этого
[01:26:01.860 --> 01:26:13.420]  блока вот такую вот константу. Понятная идея. Ну и теперь вопрос на понимание, а что будет,
[01:26:13.420 --> 01:26:21.100]  если программа вот алоцировала что-то на куче, потом поставила ссылку на эту память, а потом
[01:26:21.100 --> 01:26:27.060]  память была освобождена, отдана локатору, потом локатор ее перевыдел какому-то другому коду,
[01:26:27.060 --> 01:26:33.860]  а дальше мы по исходной ссылке решили прочесть. Ну то есть случилось некоторое оба. Память была
[01:26:33.860 --> 01:26:39.380]  адресуема, потом стала не адресуема, потом снова стала адресуема, и мы при обращении вроде бы вот
[01:26:39.380 --> 01:26:47.380]  эту проверку, вот эту проверку прошли успешно. Там написано ноль сейчас, то есть блок адресуемый,
[01:26:47.380 --> 01:26:56.740]  хотя в программе явно что-то идет не так. Ну вопрос просто будет ли, в смысле что будет,
[01:26:56.740 --> 01:27:06.460]  найдет ли адрес санитайзера ошибку или нет? Ну ошибка есть и адрес санитайзера, скажем так,
[01:27:06.460 --> 01:27:13.900]  он постарается ее найти, потому что что он сделает? Когда вы освобождаете память в программе,
[01:27:13.900 --> 01:27:19.380]  то вы отдаете ее локатору санитайзера, а санитайзер вот о чем думает. Он думает, что,
[01:27:19.380 --> 01:27:25.660]  ну если я эту память сразу переиспользую, то возможно у пользователя будет юзоста фрио,
[01:27:25.660 --> 01:27:32.100]  и мы не заметим этого. Поэтому санитайзер кладет этот блок памяти, который мы ему отдали,
[01:27:32.100 --> 01:27:39.940]  в такую очередь, которая называется карантином. И вот блок из карантина еще некоторое время не
[01:27:39.940 --> 01:27:47.140]  переиспользуется для локаций, чтобы дать возможность пользователю в него наступить и получить ошибку.
[01:27:47.140 --> 01:27:55.260]  То есть блок в карантине, он уже отравлен вот этими служебными байтами, ну не сам блок,
[01:27:55.260 --> 01:28:02.340]  а Shadow Memory для него отравлены этими байтами, этими значениями, и пока он там мринуется в
[01:28:02.340 --> 01:28:07.740]  карантине, ошибка будет обнаружена. Если ошибка пройдет спустя слишком долгое время,
[01:28:07.740 --> 01:28:15.740]  то возможно мы ее пропустим. По поводу оверхеда. Ну смотрите, у нас есть для каждых восьми байт еще
[01:28:15.740 --> 01:28:22.140]  один служебный байт. Это вроде не так много. Если программа требует, не знаю, сотни гигабайт
[01:28:22.140 --> 01:28:31.380]  памяти, то такой оверхед допустим. А с точки зрения производительности, мы, кажется, вместо одного
[01:28:31.380 --> 01:28:36.700]  обращения к памяти теперь делаем два. То есть у нас было одно обращение к памяти, теперь добавилось
[01:28:36.700 --> 01:28:43.180]  еще одно служебное. И вот оттуда берется примерно оверхед в два раза для адрес санитайзера.
[01:28:43.180 --> 01:28:50.220]  Я не знаю, где-то в документации это должно быть написано, что ожидаемое замедление в два раза,
[01:28:50.220 --> 01:28:54.820]  но вот ровно потому, что теперь на каждое чтение ваш выполняется еще чтение Shadow Memory.
[01:28:54.820 --> 01:29:03.780]  Ну и еще один класс ошибок, которые возникают в программе и который адрес санитайзера обнаруживает,
[01:29:03.780 --> 01:29:13.100]  это выход за границы массива. Вот мы алоцируем блок и можем выпасть по индексу за его край. Если не
[01:29:13.100 --> 01:29:17.500]  сделать ничего специально, то ошибки скорее всего тоже не будет, потому что рядом с вашим алоцированным
[01:29:17.500 --> 01:29:23.420]  блоком лежит может быть блок какого-то, не знаю, другого вектора или чего-нибудь подобного, так что
[01:29:23.420 --> 01:29:29.060]  программа продолжит работать, пусть и неправильно. И чтобы такие ошибки обнаруживать, адрес санитайзер
[01:29:29.060 --> 01:29:37.220]  выполняет такой трюк. Когда он алоцирует память, какой-нибудь такой кусочек, то слева от этой памяти
[01:29:37.220 --> 01:29:45.100]  он оставляет некоторый зазор, который называет Redzone, и служебно и Shadow Bytes для этого Redzone
[01:29:45.100 --> 01:29:55.500]  заполняются специальным флажком. Вот мы их видим, здесь FA — это левая Redzone для объекта на куче.
[01:29:55.500 --> 01:30:03.580]  Вот на всякий случай, вот эти вот Bytes — это не прямо Bytes в памяти, не в куче, это Bytes в Shadow
[01:30:03.580 --> 01:30:09.900]  Memory для кучи, понимаете, да? Вот, то есть слева от вашего выделенного блока есть служебный блок,
[01:30:09.900 --> 01:30:18.700]  для которого Shadow Area отравлено вот специальным значением. Так что если мы переполним или там
[01:30:18.700 --> 01:30:25.060]  выпадем через край, то мы в какую-то Redzone попадем и опять сломаемся. Это все похоже на
[01:30:25.060 --> 01:30:29.900]  GuardPage в стеках, которые мы обсуждали на прошлом семинале, на реакции не обсуждали, по-моему. Но
[01:30:29.900 --> 01:30:40.540]  механизм тот же самый, то есть чтобы упасть побыстрее. Наверное, последнее, что сейчас я скажу — это...
[01:30:40.540 --> 01:30:49.260]  Ну, по карантинам я сказал, про проверки я сказал, про... Ну, есть проверки со стеком,
[01:30:49.460 --> 01:30:58.740]  тут не точно так же, конечно, но похожим образом все устроено. Есть такой забавный нюанс,
[01:30:58.740 --> 01:31:04.060]  который вот делает адрес-синитайзер хорошим промышленным инструментом. Ну, во-первых,
[01:31:04.060 --> 01:31:07.140]  он вносит маленький оверхед в исполнение программы, по крайней мере старается его
[01:31:07.140 --> 01:31:13.300]  минимизировать. А во-вторых, адрес-синитайзер генерирует очень хорошие отчеты. Вот без хорошего
[01:31:13.300 --> 01:31:20.260]  отчета инструмент тестирования обычно не годится. Вот адрес-синитайзер вам пишет много информации,
[01:31:20.260 --> 01:31:26.900]  он пишет, во-первых, что юзовство free по такому-то адресу, а дальше он печатает три стека. Во-первых,
[01:31:26.900 --> 01:31:33.580]  он печатает, где именно вы наступили на освобожденную память. Вот здесь сообщает он,
[01:31:33.580 --> 01:31:44.380]  вот стэк, то есть мы внутри метода forward list pop. Хорошо, но этот стэк легко нарисовать,
[01:31:44.380 --> 01:31:51.940]  потому что мы сейчас в нем, мы там вот наступили в shadow memory, который писать нельзя. Есть еще два
[01:31:51.940 --> 01:31:59.540]  стека. Адрес-синитайзер сообщает не просто, где он в память наступил освобожденную, он сообщает
[01:31:59.540 --> 01:32:08.780]  нам еще, где она была освобождена и где она была алоцирована. Сейчас. Была освобождена и была
[01:32:08.780 --> 01:32:16.340]  алоцирована, то есть целых три стека. Откуда он их берет? Ну это довольно красивый инженерный нюанс,
[01:32:16.340 --> 01:32:23.980]  когда локатор алоцирует блок для вашей программы, он же слева оставляет RedZone с отрабленными
[01:32:23.980 --> 01:32:31.980]  ShadowBytes. Так вот он в этой левой RedZone не сохраняет стека локации. А когда он диалоцирует блок,
[01:32:31.980 --> 01:32:39.260]  когда вы диалоцируете блок и отдаете его в карантин, то он лежит в этом карантине и синитайзер
[01:32:39.260 --> 01:32:46.340]  внутри этого блока, уже освобожденного, кладет стэк диалокации. Если вы успели к этому блоку в
[01:32:46.340 --> 01:32:53.020]  карантине обратиться, то, во-первых, вы узнаете, что там ShadowBytes отравлены, поэтому вы получите
[01:32:53.020 --> 01:33:04.020]  ошибку и вы имеете два стека, где вы освободили блок и где вы его алоцировали. Ну и последняя такая
[01:33:04.020 --> 01:33:12.620]  забавная штука, мне кажется, она подходит к завершению всей этой истории. Смотрите, вот у вас была
[01:33:12.620 --> 01:33:17.980]  программа, собранная с адресинитайзером. Вы ее собрали с адресинитайзером, потому что вы думаете,
[01:33:17.980 --> 01:33:26.060]  что в ней есть баг, но у вас есть основания верить, что там есть баг, вы хотите его обнаружить. Но ваша
[01:33:26.060 --> 01:33:35.100]  программа сломана, она же плохо работает с памятью, пишет и читает не оттуда. Вот что, если она начала
[01:33:35.100 --> 01:33:44.100]  писать прямо в Shadow Memory? Вот если ваша программа пишет не туда в кучу, то с помощью Shadow Memory
[01:33:44.100 --> 01:33:50.700]  санитайзер это обнаружит. А что, если ваша программа пишет прямо в Shadow Memory? Она же просто
[01:33:50.700 --> 01:33:59.460]  разломает санитайзер. Вот это решается, мне кажется, довольно остроумно, потому что перед
[01:33:59.460 --> 01:34:08.860]  любым обращением к памяти в программе вставляется код с такой проверкой. И вот если вы даже
[01:34:08.860 --> 01:34:17.460]  обращаетесь к Shadow Memory неаккуратно, вот напрямую, то сначала выполнится код, который вычисляет Shadow
[01:34:17.460 --> 01:34:28.940]  Address для Shadow Memory, то есть Shadow Memory для Shadow Memory. И санитайзер так размещает все вот эти
[01:34:28.940 --> 01:34:37.180]  структуры, то есть HIP и Shadow Memory в памяти, чтобы Shadow Memory от Shadow Memory отображалась в специальный
[01:34:37.180 --> 01:34:44.820]  сегмент памяти, на который адрес санитайзер ставит mprotect и запрещает туда записи чтения. И
[01:34:44.820 --> 01:34:50.860]  если вы собираетесь записать в Shadow Memory что-то, то перед этим выполнится проверка, вы вычислите
[01:34:50.860 --> 01:34:57.420]  адрес Shadow Address от вашего адреса, попадете в защищенный блок, и там вы разломаетесь. Таким
[01:34:57.420 --> 01:35:01.380]  образом, санитайзер, он, конечно, понимает, что по одним программам может быть неправильное,
[01:35:01.380 --> 01:35:10.940]  разломанное, но он не даст вам писать в его структуры данных и ломать самого проверяющего. Ну,
[01:35:10.940 --> 01:35:21.220]  это реализовано так, что просто в реализации аллокатора аккуратно подогнаны и подобраны все
[01:35:21.220 --> 01:35:30.260]  адреса. Ну, вот такая история. Мне кажется, очень простой механизм, и при этом очень мощный,
[01:35:31.060 --> 01:35:37.060]  если вы пишете на C++, то вы непременно должны им пользоваться. Нет никаких причин не пользоваться
[01:35:37.060 --> 01:35:43.820]  им при написании хоть сколько-нибудь сложной программы. Мы им пользуемся каждый раз,
[01:35:43.820 --> 01:35:49.180]  но вы им пользуетесь каждый раз, когда в тестах запускается сборка Faulty Tracesun. Там есть Fault
[01:35:49.180 --> 01:35:53.660]  Injection, про который мы сегодня не успели поговорить, и там есть адрес санитайзер, который пытается
[01:35:53.660 --> 01:35:58.740]  увидеть, что Fault Injection привел к тому, что у вас есть кондицион, который привел к разламыванию
[01:35:58.740 --> 01:36:18.620]  памяти. Нет, еще раз, у B, есть у B сам отдельный, который ловит у B, то есть тут не надо
[01:36:18.620 --> 01:36:25.540]  так обобщать, но здесь мы ловим ошибки вращения. Да, это разумный инструмент. При программировании
[01:36:25.540 --> 01:36:29.700]  на C++ некоторые стандарты уже невозможно им не пользоваться, но в нашем курсе у него
[01:36:29.700 --> 01:36:31.780]  такая вот своя особенная цель еще.
