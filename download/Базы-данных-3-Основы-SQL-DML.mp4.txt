[00:00.000 --> 00:15.200]  Ребята, у нас третья лекция в курсе. Сегодня разберем основы Data Manipulation Language, основы
[00:15.200 --> 00:25.000]  четырех базовых команд SQL для того, чтобы работать с данными в базе. И самую главную,
[00:25.000 --> 00:36.040]  наверное, команду посылающую запрос, команду Select довольно большой объем получается. Боюсь,
[00:36.040 --> 00:48.000]  что мы не успеем дойти до темы с подзапросами, но по крайней мере сегодня мы должны DML в общем
[00:48.000 --> 00:58.960]  виде весь закрыть. Постараемся это сегодня успеть. Хорошо, Data Manipulation Language под множество
[00:58.960 --> 01:09.240]  языка SQL. Схема общая приведена. Мы левую часть этой схемы, левую часть этого дерева,
[01:09.240 --> 01:16.560]  два левых узла разобрали на предыдущей лекции в общих чертах. Сегодня разбираем второе слева
[01:16.560 --> 01:25.160]  часть. Пройдемся по всем перечисленным командам. Таким образом у нас в принципе будет,
[01:25.160 --> 01:30.720]  по крайней мере с точки зрения лекции, я понимаю, что у некоторых и на семинарах уже это случилось,
[01:30.720 --> 01:39.200]  будет общее представление о том, как создавать, наполнять базу. Вот на уровне команд SQL по
[01:39.200 --> 01:45.480]  проектированию у нас планируется следующая лекция, наверное будет. И там мы уже разберем
[01:45.600 --> 01:56.600]  чуть более подробно, как в общих чертах формировать схему базы данных в таком логическом смысле и как
[01:56.600 --> 02:04.480]  проектировать по возможности без потерь. Сегодня инсертилика длится соответственно у нас. Команда,
[02:04.480 --> 02:13.680]  что читать, опять же здесь никаких откровений я для вас не сделаю. Это в общем-то в первую и в
[02:13.680 --> 02:21.000]  основную очередь это документация. Не забывайте про книжки с предыдущей лекцией. Это книжки,
[02:21.000 --> 02:27.240]  опять же, они находятся на сайте Postgres Pro, Postgres Professional компании. Довольно доходчивые,
[02:27.240 --> 02:33.320]  хорошие вещи в плане, во всяком случае, практическом. Очень удобные, чтобы там что-то
[02:33.320 --> 02:39.800]  быстро подчеркнуть. Опять же отсылаю вас к ним, рекомендую, всячески. Тем более это все бесплатно,
[02:39.800 --> 02:48.600]  и опять же официально без нарушения всяческих авторских прав. Ну и также гуглим, не стесняемся.
[02:48.600 --> 03:00.000]  Давайте рассмотрим, соответственно начнем с команды insert. У нас здесь будет в таком порядке
[03:00.000 --> 03:06.680]  insert, update, delete и в самом конце, в самой большей части мы посвятим селекту. Базовый синтакс
[03:06.680 --> 03:15.560]  приведен. Опять же, напоминаю, что в тех доках гораздо более полное описание синтаксиса,
[03:15.560 --> 03:22.480]  он гораздо более богатый, больше гораздо нюансов, но на данном этапе в принципе основное приведено
[03:22.480 --> 03:32.360]  на слайде. Это insert into, имя таблицы дальше, можно также специфицировать имя столбства,
[03:32.360 --> 03:39.320]  можно не специфицировать, и опять же дальше дополнительные всяческие варианты. Ну как
[03:39.320 --> 03:46.040]  дополнительные? Insert into у вас все равно должно быть после имени таблицы какие-то значения,
[03:46.040 --> 03:51.160]  которые вы вставляете, либо по умолчанию, либо какие-то конкретные. Также можно в конце вывести
[03:51.160 --> 03:59.760]  результат того, что вы вставили таблицу для того, чтобы с этим работать, если вы insert
[03:59.760 --> 04:08.040]  используете в своей какой-то функции, например, или в каком-то процессе исполнения команд,
[04:08.040 --> 04:15.080]  когда смысл дополнительного селекта в дополнительном селекте не будет. Проще вывести
[04:15.080 --> 04:23.880]  через returning и получить по крайней мере все, что вы вставили по умолчанию, либо там обвесить
[04:23.880 --> 04:28.440]  какими-то псевдонимами, какую-то спецификацию указать для того, чтобы вывести конкретные столбцы.
[04:28.440 --> 04:36.880]  Элементы синтаксиса. Имя таблицы – это имя существующей таблицы или, возможно, дополненные
[04:36.880 --> 04:41.040]  схемы. То есть когда у нас будет вначале иметь схемы, точка, имя таблицы. Что такое схема?
[04:41.040 --> 04:51.600]  Схема – это, если говорить с такой логической точки зрения, схема, опять же, это схема СУБД,
[04:52.360 --> 04:58.400]  то есть это не схема данных при проектировании базы данных, это схема СУБД. Это, по сути дела,
[04:58.400 --> 05:06.720]  пространство имен. Вы можете в своей базе данных создать схему, которая будет у вас позволять две
[05:06.720 --> 05:12.840]  таблицы именовать одинаково, при условии, что они к разным схемам относятся. Имя столбца – понятно,
[05:12.840 --> 05:20.000]  что может быть дополненным именем вложенного поля или индексом в массиве. То есть если у вас
[05:20.000 --> 05:36.720]  есть какие-то более сложные конструкции, чем таблица со столбцами, можно также выражение
[05:36.720 --> 05:50.880]  использовать как в указании значений, так и в принципе, это уже потом, в именовании столбцов
[05:50.880 --> 05:58.320]  можно использовать выражение в селекте в частности, мы это посмотрим. Можно использовать запрос
[05:58.320 --> 06:04.760]  оператор селект, который выдаст строки для добавления в таблицу, выражение результата.
[06:04.760 --> 06:12.520]  Что после ретернинга появляется? Это то, что будет вычисляться. По сути дела, это та же самая
[06:12.520 --> 06:16.760]  таблица, но не вся целиком, которая у нас получится в результате, а только те столбцы,
[06:16.760 --> 06:27.680]  которые у нас вставлены. Мы можем ограничить результат, получающийся после ретернинга,
[06:27.680 --> 06:34.600]  за счет того, чтобы укажем какое-то конкретное количество столбцов и можем как-то их
[06:34.600 --> 06:40.360]  переименовать, как там заблагорассудится, соответственно. А что важно, наверное, понимать,
[06:40.360 --> 06:48.440]  это имена столбцов можно располагать в произвольном порядке, если мы их явно указываем. Если у нас
[06:48.440 --> 06:56.120]  есть столбцы со значениями по умолчанию, то есть когда мы создали и повесили ограничение
[06:56.120 --> 07:06.080]  default value, то у нас, соответственно, можно эти столбцы не заполнять, но если мы перечислили
[07:06.080 --> 07:13.360]  при команде insert имя столбцов, в том числе для которых установлены default значения,
[07:13.360 --> 07:20.200]  мы все равно должны будем явным образом указать, какие значения мы вставляем в эти столбцы,
[07:20.200 --> 07:25.680]  даже если не смотря на то, что у нас есть default. Мы, правда, можем маркером default при вставке
[07:25.680 --> 07:37.080]  указать нашей системе управления базой данных, чтобы алгоритмы взяли значения, процедуры,
[07:37.080 --> 07:43.000]  по сути дела не алгоритмы, все-таки процедуры взяли значения из логики, которую мы заложили на
[07:43.000 --> 07:49.600]  этапе create. Сейчас я все это покажу на примерах. Если указать список столбцов, но привести во
[07:49.600 --> 07:54.160]  вставке не все значения, то вставка будет происходить последовательно во все ячейки строки, в связи с чем
[07:54.160 --> 07:59.880]  система выдаст ошибку либо из-за несовпадений типа данных, либо из-за недостаточности добавляемых
[07:59.880 --> 08:04.720]  в строку данных. То есть, если мы не указываем после имени таблицы в скобках имена столбцов,
[08:04.720 --> 08:12.360]  мы должны все значения явно представить, даже если будут это будут default, и default-ные маркеры
[08:12.360 --> 08:16.200]  все равно должны явно представить в списке значений, которые вставляем в строку.
[08:16.200 --> 08:29.600]  По какому принципу? Вопрос в чате. По какому принципу упорядовываются строки в результате
[08:29.600 --> 08:38.600]  запроса пересечения? Ответ такой. С точки зрения релизационной модели у нас нет никакого условия
[08:38.600 --> 08:43.920]  на упорядочивание строк. У вас от времени, когда вы сделаете этот запрос, грубо говоря,
[08:44.400 --> 08:49.840]  может разниться число строк. Другое дело, что при конкретной реализации подлежащие
[08:49.840 --> 08:58.480]  механизмы они могут соблюдать порядок, но стандарту не накладывает на это никаких ограничений,
[08:58.480 --> 09:12.760]  поэтому на это не стоит закладываться. Если вы хотите определить порядок, то есть просто способ
[09:12.760 --> 09:28.120]  в запросе селект сортировки. Способ сортировки мы до этого дойдем попозже. Примеры инсерт
[09:28.120 --> 09:36.920]  приведены на рисунке, если мы просто создаем create table. Вот мы создали таблицу пустую,
[09:36.920 --> 09:47.240]  мы поставили запрос селект, у нас выводится заголовок нашего отношения со списком атрибутов,
[09:47.240 --> 09:57.320]  таблица у нас пустая. Давайте добавим значения. Вот мы добавляем ряд значений, шаги с первого
[09:57.320 --> 10:02.960]  по пятый в левой части слайда описаны, приведены вернее, и в правой части у нас, соответственно,
[10:02.960 --> 10:08.360]  полный результат. На что здесь можно обратить внимание? Во-первых, смотрите. Перевернем слайд
[10:08.360 --> 10:16.720]  обратно. У нас таблица четырьмя полями. На первое поле ограничений сериал и праймеры key,
[10:16.720 --> 10:23.280]  на второе поле у нас явное ограничение default. По дефолту у нас unknown заносится, по дефолту
[10:23.280 --> 10:29.880]  в столбе с h будет значение 18, по дефолту в столбе с email будет значение, соответственно,
[10:29.880 --> 10:39.680]  default email. Почему это важно? Вот давайте смотреть. В первом шаге, в первом этапе мы заносим явно
[10:39.680 --> 10:46.760]  только в столбе с name только одно значение John. Вот у нас первая строка. Что мы видим? ID у нас,
[10:46.760 --> 10:55.760]  соответственно, автоинкрементация происходит с единички, начиная. Вот единичка в поле ID,
[10:55.760 --> 11:02.720]  в столбце ID, в столбце name, соответственно, занесенное имя в столбце h, в столбцах h и email у
[11:02.720 --> 11:07.960]  нас дефолтное значение. Мы здесь явно указали столбец, повторюсь, явно указали значение для
[11:07.960 --> 11:13.360]  столбца. Остальное заносится по дефолту. Второй шаг тоже самое. Единственное, мы маркером default,
[11:13.360 --> 11:21.280]  видите, в конце заносим, говорим нашей базе, чтобы в столбце h у нас было дефолтное значение. И вот оно
[11:21.280 --> 11:28.160]  тоже появляется 18. В третьем шаге, обратите внимание, мы можем все столбцы дефолтные,
[11:28.160 --> 11:33.240]  все столбцы заполнить дефолтными значениями. Вот таким коротким запросом, если это позволяет
[11:33.240 --> 11:42.120]  схема нашего отношения, то как мы его задали, соответственно, у нас в столбце 3 все дефолтные
[11:42.120 --> 11:50.680]  значения. А что еще? На четвертом шаге мы здесь добавляем не одно значение, как мы делали раньше,
[11:50.920 --> 11:55.400]  не в одну строку значения, как в первом, во втором или даже в третьем шаге. На четвертом шаге мы
[11:55.400 --> 12:03.080]  добавляем несколько строк. Три строки с разными комбинациями того, что заносится. На четвертом шаге,
[12:03.080 --> 12:11.600]  соответственно, обратите внимание, мы в столбец возраст, причем мы его указываем первым после
[12:11.600 --> 12:18.800]  values. Почему? Потому что мы его указали первым в перечислении столбцов, когда определяли таблицу,
[12:18.800 --> 12:24.200]  куда мы добавляем строку. Мы определили таблицу, определили конкретные столбцы, которые мы
[12:24.200 --> 12:28.880]  добавляем значения, определили их порядок, по сути, перечисляя его в скобках. И мы также,
[12:28.880 --> 12:34.240]  после предложения в values, должны этот порядок соблюсти. Соответственно, хотя у нас в нашем
[12:34.240 --> 12:41.120]  отношении, в нашей таблице age идет после name, столбец age после name, мы тем не менее в обставке
[12:41.120 --> 12:47.920]  вставляем сначала в age, потом в числовое значение, потом в name строковое значение. Причем
[12:47.920 --> 12:55.520]  числовое значение мы еще и вставляем путем почисления выражения. Хорошо, ну и вот результат,
[12:55.520 --> 13:10.320]  соответственно, на экране вы видите. Далее добавим в нашу таблицу новые значения и сделаем также
[13:10.320 --> 13:18.320]  операцию returning. Посмотрим, что нам выдаст наша база данных. Соответственно, на первом шаге мы
[13:18.320 --> 13:24.720]  добавляем очередную дефолтную строку и, собственно, мы ее и выводим.
[13:30.040 --> 13:35.920]  На втором шаге мы добавляем три дефолтных строки и, как вы видите, соответственно, как было сказано
[13:35.920 --> 13:41.920]  ранее, три дефолтных строки подряд выводятся. То есть, повторюсь, returning у нас выдают не всю
[13:41.920 --> 13:52.080]  таблицу, только то, что мы ввели. Ну, соответственно, полностью то, что мы ввели. Если ввели явно только
[13:52.080 --> 13:58.840]  часть из тех значений, которые мы, только часть значений для строки, то есть только в некоторые
[13:58.840 --> 14:05.600]  столбцы, у нас все равно по returning будет выдача полной строки со всеми значениями по каждому
[14:05.600 --> 14:14.120]  атрибуту. Просто какие-то будут, ну, понятно, по дефолту добавлены. Можно использовать команду
[14:14.120 --> 14:22.360]  select для вставки в insert. Мы здесь, по сути дела, можем скопировать из одной таблицы какие-то данные
[14:22.360 --> 14:36.280]  в нашу таблицу, из какой-то таблицы внешне. Ну, скажем, таблицу, в которую мы копируем, пусть будет
[14:36.280 --> 14:41.320]  эта итоговая таблица. Вот в итоговую таблицу мы скопируем из какой-то внешней таблицы по select
[14:41.320 --> 14:51.080]  значения, но у нас, конечно, условие должно быть такое, что мы должны добавлять только значения,
[14:51.080 --> 14:57.120]  которые соответствуют атрибутам отношения. Если у нас не будет соответствия, то как результат
[14:57.120 --> 15:14.320]  система выдаст ошибку, ничего добавить не получится. Можно также копировать целиком таблицы таким образом
[15:14.320 --> 15:23.720]  из одной в другую, то есть не просто по какому-то условию, как в предыдущем примере, когда у нас было
[15:23.720 --> 15:29.120]  условие aware после команды select, в команде select. Можем скопировать полностью все, ну, опять же,
[15:29.120 --> 15:37.080]  при условии соответствия отношений. Вопрос в чате returning возвращает то, что вы только что вставили.
[15:37.080 --> 15:47.000]  Да. Во-первых, returning – это не отдельная команда, это то предложение, которое записывается в
[15:47.000 --> 15:54.520]  рамках команды insert, и если у вас после insert будет какое-то количество операций над базой данных,
[15:54.520 --> 16:01.720]  то, во-первых, в returning просто не запустите в отрыве от insert, и, во-вторых, когда запустите
[16:01.720 --> 16:11.920]  returning внутри нового insert, у вас только новые значения вставятся. Хорошо. Update – довольно тоже
[16:11.920 --> 16:19.280]  понятная, наверное, простая команда. Ну, как бы да, update, то есть мы обновляем какое-то поле или поля
[16:19.280 --> 16:29.000]  в базе данных по некой логике, которую мы соответственно сами прописываем. Базовый синтакс
[16:29.000 --> 16:35.520]  исправеден, опять же, в документации он полнее, хотя не намного, здесь уже простота команды
[16:35.520 --> 16:46.480]  ограничивает возможности для вариантов ее использования. На что обратить внимание, что может быть вложенный
[16:46.480 --> 16:51.520]  селект под запрос селектов, выдающий столько выходных столбцов, сколько перечислено в предшествующем
[16:51.520 --> 17:01.680]  его списке столбцов. Это определение, по сути дела. То есть у нас здесь вот update имя таблицы, звездочка,
[17:01.680 --> 17:16.640]  то есть мы можем все поля. Окей, звездочка опустим пока. Сет имя столбца у нас может быть вложенный
[17:16.640 --> 17:24.000]  селект запрос. И что это такое? Это под запрос селектов, выдающий столько выходных столбцов,
[17:24.000 --> 17:29.720]  сколько перечислено в предшествующем ему списке столбцов в скобках. То есть селект, потом список
[17:29.720 --> 17:34.120]  столбцов, столько он и выдаст. При выполнении этого под запроса должно быть получена максимум одна
[17:34.120 --> 17:38.560]  строка. Если он выдаёт одну строку значения столбцов, в нем присваивается целевым столбцам,
[17:38.560 --> 17:42.680]  если же он не возвращается в руку, то целевым столбцам присваивается нал. Этот подзапрос
[17:42.680 --> 17:47.400]  может обращаться к предыдущим значениям текущей изменяемой строки в таблице. Ребята,
[17:47.400 --> 17:54.320]  вот это определение вложенного селекта, селект запроса, то есть оно релевантно не только для
[17:54.320 --> 18:01.360]  update команд, оно относится ко всем в принципе командам, которые могут использовать под запрос,
[18:01.360 --> 18:14.560]  то есть вложенные селект запросы. Поэтому имейте в виду, что это, повторюсь, общее место,
[18:14.560 --> 18:19.440]  не только когда это относится. Элемент from табличное выражение позволяющий обращаться в
[18:19.440 --> 18:25.920]  условия where, то есть это определение того, что у нас на предыдущем слайде показано. Я думаю,
[18:25.920 --> 18:30.880]  довольно здесь всё понятно, в крайнем случае можете обратиться к документации. Давайте
[18:30.880 --> 18:36.040]  посмотрим просто на примере, как это выглядит, чтобы было нагляднее. Вот у нас две таблицы,
[18:36.040 --> 18:42.560]  два отношения наших, вернее одно отношение, прошу прощения, и как оно изменится. Вот мы в нашу
[18:42.560 --> 18:47.520]  таблицу, которую мы сформировали на предыдущих наших шагах, когда выполнили команду insert,
[18:47.520 --> 18:59.960]  мы в неё вносим изменения, обновляем атрибут edge для записи, для кортежа, в котором
[18:59.960 --> 19:05.720]  атрибут id равен единичке. Вот соответственно у нас это, по сути, первая строка получается,
[19:05.720 --> 19:16.280]  поскольку id у нас заполняется за счет типа данных сериал. И вот дефолтный возраст 18
[19:16.280 --> 19:21.240]  поменялся, возраст по умолчанию, на возраст 25, как у нас, собственно говоря, и в запросе это
[19:21.240 --> 19:32.840]  фигурирует. Что мы еще можем делать интересного? Мы можем, поскольку здесь принцип именования
[19:32.840 --> 19:37.600]  строк, именование, прошу прощения, атрибутов такой же, как и было в команде insert, мы можем
[19:37.600 --> 19:46.840]  произвольным образом указать необходимые нам поля и дальше внести корректные значения,
[19:46.840 --> 19:51.600]  соответствующего типа значения, в эти самые поля, как приведено на рисунке. Опять же, мы можем
[19:51.600 --> 19:59.480]  менять ни одну ячейку в таблице, ни значение одного атрибута, можем поменять часть нашего
[19:59.480 --> 20:09.640]  кортежа, часть нашей строки, так как посчитаем нужным. В данном случае изменен порядок следования
[20:09.640 --> 20:15.480]  столбцов, но за счет того, что корректные типа данных вносятся в соответствующие столбцы,
[20:15.480 --> 20:23.600]  мы получаем результат, как показано на экране. Опять же, ORID 8 и логическое ограничение у нас
[20:23.600 --> 20:32.720]  стоит. Ребят, выключите, пожалуйста, микрофон. Мы его соблюли, несли в восьмую строку изменение.
[20:32.720 --> 20:47.520]  Дальше у нас пример сложного селект-запроса или еще же так называемого подзапроса. В данном
[20:47.520 --> 20:53.760]  случае мы довольно сложно сформулировали этот подзапрос, но давайте разберемся. На самом деле,
[20:53.760 --> 20:57.120]  он довольно простой. Здесь опять же, мы немножко забегаем вперед, селект у нас будет буквально
[20:57.120 --> 21:07.960]  через одну команду, но запрос простой, я думаю, не вызовет никаких проблем. Мы здесь в селекте из
[21:07.960 --> 21:19.560]  нашей example table берем по условию, чтобы ID был равен 4, берем значение возраста, имени и
[21:19.560 --> 21:27.120]  email. И для возраста мы еще и добавляем тройку. То есть у нас результат подзапроса будет строка 4,
[21:27.120 --> 21:36.400]  это Alice 25 лет и почта. Но поскольку возраст плюс 3 года, то будет Alice 28 лет и почта для Alice.
[21:36.400 --> 21:47.360]  Соответственно, мы дальше вносим изменения уже по условию внешнему для того, чтобы найти строку,
[21:47.360 --> 21:53.480]  куда мы вносим изменения. Вносим изменения в виде полученных из подзапроса данных,
[21:53.480 --> 22:03.400]  изменяем те поля, те столбцы, которые у нас после команды set, после предложения set указаны. И вот они
[22:03.400 --> 22:12.560]  соответственно изменились. Это все на слайдах будет возможно скопировать, вставить, сможете
[22:12.560 --> 22:18.400]  прогнать все это у себя. Но я думаю, правда, уже часть из вас пробовала, трогала руками. Но тем
[22:18.400 --> 22:24.480]  не менее, может быть, для кого-то кому-то еще захочется поиграться, поэтому, пожалуйста,
[22:24.480 --> 22:32.360]  копируйте, вставляйте, пробуйте работать с текстом данной лекции. Так, update примеры еще. Какие
[22:32.360 --> 22:44.760]  примеры? Это с from where. Мы в данном случае изменяем имя контакта в таблице счетов. Что здесь важно?
[22:44.760 --> 22:57.800]  Важно то, что в отличие от предыдущих примеров, мы берем данные из другой таблицы, и соответственно
[22:57.800 --> 23:11.440]  у нас в таблице accounts будут внесены данные из таблицы employees по соответствию указанному после
[23:11.440 --> 23:19.720]  предложения where, и будут внесены данные, соответствующие условию после команды set,
[23:19.720 --> 23:27.320]  после предложения set. То есть сначала у нас будет from employees, где employees.id соответствует
[23:27.320 --> 23:36.160]  accounts salesperson. Мы находим все соответствия вот в этом фрагменте, и по этим соответствиям в
[23:36.160 --> 23:43.160]  таблице accounts меняем поля contact firstname на firstname. Соответственно, contact firstname
[23:43.160 --> 23:47.240]  подразумевается, что это таблица accounts, firstname подразумевается, что это таблица employees.
[23:47.240 --> 23:54.720]  Опять же, можно было бы вот такую нотацию использовать с точкой таблицы, точкой и имя атрибута.
[23:54.720 --> 24:04.640]  Ok. Delete. Базовый синтаксис. Тоже здесь простая команда, простой базовый синтаксис приведен на
[24:04.640 --> 24:15.080]  экране. Можем указать либо что-то конкретное, удалить конкретный фрагмент, можем удалить какое-то
[24:15.080 --> 24:21.320]  количество строк. Можем удалить всю таблицу целиком, но это будет построчное удаление.
[24:21.320 --> 24:31.280]  Удаление не быстрое и не эффективное, в общем случае. Примеры. Опять же, вот можно
[24:31.280 --> 24:40.240]  использовать returning. Работает он также как с insert, и выдаёт returning у нас соответственно
[24:40.240 --> 24:46.000]  то, что было удалено. Вот справа на слайде показано, как изменяется таблица. То есть
[24:46.000 --> 24:52.320]  исходное отношение сверху, результирующее снизу. В результирующем у нас отсутствует 11 строка,
[24:52.320 --> 24:58.200]  то есть строка, в которой id был равен 11, и мы её получили по результатам удаления.
[24:58.200 --> 25:09.840]  Чем отличается delete, truncate и drop? Как вы помните из прошлой лекции,
[25:09.840 --> 25:14.600]  должны по крайней мере помнить, и уж точно должны знать из семинарских занятий, кто до этого успел
[25:14.600 --> 25:24.400]  дойти. Все две последние команды у нас занимаются также удалением данных, как и вновь изученная
[25:24.400 --> 25:29.840]  знамя команды delete. Ну и занимаются они удалением данных по-разному. Delete осуществляет
[25:29.840 --> 25:36.320]  посрочное удаление строк, truncate удаляет все строки в таблице разом, а drop удаляет всю таблицу
[25:36.320 --> 25:42.760]  целиком. Соответственно, если вы хотите оставить отношение на удалить все строки, используйте
[25:42.760 --> 25:49.520]  truncate, это гораздо быстрее, гораздо гораздо быстрее. Хотите удалить всю таблицу, используйте drop,
[25:50.520 --> 25:58.440]  здесь все очевидно, наверное, понятно из слайда напрямую из прошлой лекции. А что еще? По delete
[25:58.440 --> 26:03.440]  можно устанавливать определенные условия, а не удалять все целиком. Truncate и drop этого не
[26:03.440 --> 26:09.560]  позволяют. Delete можно откатить, но как откатить? Это не значит, что откатить после завершения
[26:09.560 --> 26:16.520]  транзакции. В процессе транзакции можно сделать там либо точки остановы, либо в случае неудачи
[26:16.520 --> 26:23.440]  можно взять и откатить truncate, если у вас неудача произошла на этапе выполнения другой команды,
[26:23.440 --> 26:29.680]  то есть у вас какая-то функция, например, идет, выполняется, и у вас возникла проблема,
[26:29.680 --> 26:35.920]  все упало почему-то, но truncate уже был реализован, так вот здесь уже, или drop опять же, также это
[26:35.920 --> 26:42.760]  работает. Здесь, к сожалению, ничего откатить уже не получится, delete получится до команды commit,
[26:42.760 --> 26:51.160]  если она явно прописана, либо до завершения выполнения команды или функции, потому что по
[26:51.160 --> 26:58.040]  умолчанию у нас завершение выполнения команды или функции результируется commit системным,
[26:58.040 --> 27:05.080]  внутри системным, можно delete откатить. Также, что еще важно отметить, у нас delete физически не
[27:05.080 --> 27:14.440]  удаляет все еще данные, хотя и откатить rollback их уже может быть проблематично, ну там есть еще
[27:14.440 --> 27:21.480]  как бы варианты, да, помимо собственно команды rollback, который мы поговорим с вами позже, а truncate
[27:21.480 --> 27:28.840]  и drop, наоборот, удаляют полностью, безвозвратно, и для того, чтобы после delete действительно
[27:28.840 --> 27:35.760]  освободить дисковое пространство, нужно будет выполнять команду vacuum, если не удалить стройки
[27:35.760 --> 27:41.840]  физически, ну они соответственно так вот копиться и будут, пока у вас какие-то системные утилиты,
[27:41.840 --> 27:49.640]  может быть, не запустят vacuum, или пока не будет сообщения о переполнении физической памяти на
[27:49.640 --> 28:04.720]  устройстве. Так, хорошо. Команда select, основной предмет нашего сегодняшнего разговора, пожалуй,
[28:04.720 --> 28:14.040]  основная, наверное, рабочая команда, с которой работают все, потому что позволяет, понятно,
[28:14.040 --> 28:20.440]  позволяет достать из базы какие-то данные с помощью select, то есть, возможно, это, конечно,
[28:20.440 --> 28:25.920]  будет там неявный select, не прямой, там будет select внутри какой-то, может быть, процедуры,
[28:25.920 --> 28:33.400]  но, тем не менее, select у вас будет запускаться практически, наверное, в любом случае, в любом,
[28:33.400 --> 28:38.800]  кажется, да, вот так, на первый взгляд, чтобы получить какие-то, ну да, можно здесь поговорить
[28:38.800 --> 28:43.720]  о том, что returning у нас еще возвращает данные, но это такие данные, наверное,
[28:43.720 --> 28:49.320]  не представляющие особого значения, потому что мы либо знаем, что мы вставляем, либо знаем,
[28:49.320 --> 29:02.520]  что мы удаляем или обновляем, ну, скорее всего, знаем. Так, а базовый, базовый синтаксис приведен
[29:02.520 --> 29:19.480]  на экране, так, а на секундочку, да, базовый синтаксис приведен на экране, вот самый верхний
[29:19.480 --> 29:27.080]  уровень, невый способ описания, это первый bullet, то есть, у нас есть select, потом идет список
[29:27.080 --> 29:33.960]  выборки некой, некий, после этого предложение from, потом табличные выражения и потом, может быть,
[29:33.960 --> 29:42.000]  определение сортировки, но, как вы видите, в квадратных скобках у нас только определение
[29:42.000 --> 29:48.800]  сортировки, from и табличные выражения не занесены в квадратные скобки, но на самом деле, на самом
[29:48.800 --> 29:57.720]  деле, select можно использовать для вычисления, для выдачи, вернее, выражений, которые у нас будут
[29:57.720 --> 30:06.840]  исполняться, будут стоять на месте списка выборки, будут исполняться на месте, что называется, и select
[30:06.840 --> 30:12.840]  просто выдается в виде скалярного результата, скаляра одной ячейки, то есть, одной строки с
[30:12.840 --> 30:22.840]  одним столбцом, некой таблице результирующей. Ну окей, синтаксис чуть более подробный приведен во втором
[30:22.840 --> 30:30.000]  bullet, опять же, это далеко не полный синтаксис, по команде select документация, большая объемная
[30:30.000 --> 30:40.720]  статья, сама команда имеет огромное количество дополнительных предложений, всевозможных
[30:40.720 --> 30:53.320]  усложняющих возможностей запроса, семантические, расширяющие возможности запроса. Ну пока давайте
[30:53.320 --> 30:59.320]  посмотрим на базовые элементы, то есть, вот что такое список выборки, это первая фигурная скобка,
[30:59.320 --> 31:11.600]  по сути дела это у нас некое, это у нас перечисление наших, перечисление интересующих нас столбцов,
[31:11.600 --> 31:19.680]  в общем случае. Это может быть в принципе, конечно, некое выражение, причем выражение, которое имеет,
[31:19.680 --> 31:24.920]  выдаёт результат на месте, то есть, это может быть сложение или какая-нибудь логическая проверка,
[31:24.920 --> 31:31.400]  и мы можем использовать select так, опять же, повторюсь, без части, которая идет, начиная с from и далее,
[31:31.400 --> 31:39.680]  но в общем случае это будут столбцы, перечисление каких-то столбцов, потом у нас будет from с from
[31:39.680 --> 31:48.600]  элементом, который тоже, кстати, в поле в табличное выражение, здесь немножко не точно, я обозначил
[31:48.600 --> 31:52.920]  фигурную скобку, в табличное выражение, соответственно, у нас войдет элемент from,
[31:52.920 --> 32:00.840]  where условия, group by элемент группировки и having условия тоже. Дальше у нас могут быть варианты
[32:00.840 --> 32:08.280]  с объединением, пересечением или исключением, с некой другой выборкой, то есть, по сути дела,
[32:08.280 --> 32:15.160]  мы можем на самом деле, таким образом, вот за счет этих трех команд union, intersect и accept,
[32:15.160 --> 32:22.240]  ну, в общем-то понятно, наверное, теоретика множественные операции, мы можем результаты
[32:22.240 --> 32:28.800]  двух селект-запросов пересечь, объединить или вычесть один из другого. Также мы можем,
[32:28.800 --> 32:36.560]  соответственно, определить порядок следования через команду order by и дополнительное выражение и,
[32:36.560 --> 32:44.480]  наконец, мы можем задать либо предельное количество срок, которое мы получим в результате
[32:44.480 --> 32:51.840]  запроса, либо мы можем также задать или и то и другое вместе, либо это значение или, но в таком
[32:51.840 --> 32:56.240]  логическом или и то и другое вместе мы можем задавать, конечно же. Также, наконец, мы можем
[32:56.240 --> 33:06.920]  через команду offset задать смещение для начала выдачи наших результатов. Окей, поехали посмотрим
[33:06.920 --> 33:16.800]  поподробнее на каждую, на каждый из перечисленных элементов. Селект элемента синтакса со список
[33:16.800 --> 33:22.240]  выборки. Что здесь важно иметь в виду? Селект возвращает набор, состоящий, по крайней мере,
[33:22.240 --> 33:26.720]  из одного значения, и для простоты на данном этапе можно считать, что селект всегда возвращает
[33:26.720 --> 33:31.960]  таблицу, которая есть, по крайней мере, одна строка с, по крайней мере, одной ячейкой. В
[33:31.960 --> 33:36.640]  последнем случае также говорят, что селект возвращает скалярное значение. Скалярное значение
[33:36.640 --> 33:44.440]  это можно сразу запомнить, это понадобится нам для подзапросов, потому что там в зависимости от
[33:44.440 --> 33:53.200]  того, какой тип возвращаемого результата подзапрос нам выдает, будет изменяться порядок обработки
[33:53.200 --> 34:00.480]  подзапроса. Причем изменяться может быть даже не очень очевидно с точки зрения синтаксиса,
[34:00.480 --> 34:08.400]  а вот семантически различия будут существенные. Список выборки задает столбцы, которые появляются
[34:08.400 --> 34:13.080]  в результирующем отношении. Допустимо также задать операцию над каждым значением столбца.
[34:13.080 --> 34:22.000]  Синтаксис ссылок на столбцы вариативен. Соответственно, задать операцию над каждым
[34:22.000 --> 34:27.880]  значением столбца мы это уже, в общем-то, с вами увидели еще на этапе команда Update,
[34:27.880 --> 34:35.080]  когда на нее смотрели. Поэтому мы можем в селекте, соответственно, какие-то, например,
[34:35.080 --> 34:41.720]  аэропедические операции совершать со столбцом, и у нас будет везде все прибавляться в рамках этого
[34:41.720 --> 34:51.720]  столбца, к значениям в каждой ячейке. Селект элемента синтаксиса, опять же, список выборки
[34:51.720 --> 34:59.080]  продолжения. Можно также задавать в списке выборки псевдонимы для столбцов результирующей
[34:59.080 --> 35:09.160]  таблицы. Обычно это делается, это можно сделать явно через команду S, предложение S, соответственно,
[35:09.160 --> 35:18.360]  как на экране показано. Можно сделать это не явно, просто указав после имени столбца некое
[35:18.360 --> 35:26.240]  сокращение через пробел, но это не всегда может быть удобно, по понятным причинам. Лучше явное,
[35:26.240 --> 35:34.120]  лучше неявного, хотя с другой стороны неявное короче. Поэтому здесь соотносить надо, наверное,
[35:34.120 --> 35:41.480]  с этим. Что быстрее, что проще, опять же, для каких-то критических запросов, очевидно,
[35:41.480 --> 35:49.160]  там важнее явно все прописать, чтобы понимать, где там потенциально может быть ошибка на уровне
[35:49.160 --> 35:57.960]  таком, что здесь семантическом, наверное, даже. Ну ладно, не важно. В общем, лучше явно прописать,
[35:57.960 --> 36:08.880]  где что подразумевается под тем или иным сокращением. Также у нас S позволяет, предложение S позволяет
[36:08.880 --> 36:18.560]  использовать в качестве псевдонима ключевые слова, так же, как и, например, заключение псевдонима
[36:18.560 --> 36:29.360]  в кавычке, но здесь для чего это когда нужно. Вот, например, у нас в селекте здесь, в приведенном
[36:29.360 --> 36:36.360]  примере, использовано в качестве псевдонима сам. Сам это также у нас, как вы, возможно, уже знаете,
[36:36.360 --> 36:45.000]  имя агрегатной или агрегирующей функции. Соответственно, чтобы лишний раз у нас система
[36:45.000 --> 36:51.360]  не выдавала нам синтаксическую ошибку, либо кавычки, либо явное обозначение псевдонима.
[36:51.360 --> 36:57.200]  Аналогичное правило действует также для таблиц, перечисляемых после предложения from. Это немножко
[36:57.200 --> 37:10.360]  тоже забегая вперед. Вот в этом элементе элементы from. Но есть некоторые особенности. Псевдоним
[37:10.360 --> 37:15.720]  становится новым именем таблиц в рамках текущего запроса, то есть после назначения псевдонима после
[37:15.720 --> 37:25.360]  предложения from использовать исходное имя таблица в другом месте нельзя. Бывает явно необходимо
[37:25.360 --> 37:32.120]  использовать псевдонимы после предложения from, когда мы соединяем таблицу саму с собой.
[37:32.120 --> 37:42.640]  Бывает это нужно, например, для запросов, которые у нас по данным складированным в виде таблиц в
[37:42.640 --> 37:48.440]  нашей базе данных проходятся как по графам. Ну и сами эти данные представляют на самом деле некие
[37:48.440 --> 38:00.040]  структурированные определенным образом данные, представимые в виде графа в иной какой-то
[38:00.040 --> 38:05.360]  системе представления. Но позгресс, вернее, революционная база данных у нас позволяет только
[38:05.360 --> 38:14.120]  в табличке хранить, как мы знаем. Так, элементы синтаксиза опять же мы продолжаем. Да, здесь так
[38:14.120 --> 38:20.400]  сухая теория, но, наверное, какие-то ключевые моменты приведены на слайдах, и я поэтому их все
[38:20.400 --> 38:27.920]  равно считаю необходимо зачитать для того, чтобы вы понимали вообще на что ориентироваться,
[38:27.920 --> 38:33.160]  и в том числе ориентироваться в квизе. Так что потерпите, будут еще картинки и вопросы в аудиторию.
[38:33.160 --> 38:39.480]  А хорошо, результат вычисления табличного выражения это другая таблица, которая также может
[38:39.480 --> 38:50.160]  состоять всего из одной ячейки скаляра. То есть не только под запрос может быть скалярным,
[38:50.160 --> 38:55.920]  у нас весь запрос, наш селект может быть результатом, результат выдавать скалярный. Ну ладно,
[38:55.920 --> 39:02.760]  это такое может быть излишне терминологическое уточнение. Табличное выражение можно опустить
[39:02.760 --> 39:10.400]  и использовать селект для возврата результата вычисления выражения. То есть мы можем, как я
[39:10.400 --> 39:19.040]  уже говорил, вот селект использовать для выдачи каких-то, ну, как написано в документации,
[39:19.040 --> 39:25.200]  если вы откроете на Postgres Professional, селект можно использовать как калькулятор. Это, наверное,
[39:25.200 --> 39:33.840]  такое немножко вольное описание. По сути дела селект у нас сам по себе возвращает таблицу,
[39:33.840 --> 39:41.200]  а вычисления происходят в рамках, конечно, селект запроса. Но не сам селект запрос у нас работает
[39:41.200 --> 39:49.280]  как калькулятор. Конечно, во всяком случае по стандарту это немножко не про селект.
[39:49.280 --> 39:54.520]  Ну вот, можно выдать числовое значение какое-то, вот триумф нужно четыре,
[39:54.520 --> 40:02.160]  можно выдать значение логической проверки. То есть, в принципе, операции над поддерживаемыми
[40:02.160 --> 40:10.160]  типами можно совершать, и вот у вас будет скалярное выражение в качестве результата.
[40:19.280 --> 40:24.640]  Что еще? Предложение From у нас образует таблицу из одной или нескольких ссылок на таблице,
[40:24.640 --> 40:33.560]  разделенных запятыми. То есть, во From мы можем просто перечислить таблицы, и тогда у нас,
[40:33.560 --> 40:42.560]  ну, по сути, будет декартовое произведение этих таблиц. И, наверное, так делать не стоит,
[40:42.560 --> 40:49.960]  в общем случае. А табличные ссылки, вот table and в примере, может быть, имя таблицы,
[40:49.960 --> 40:56.240]  возможно, с именем схемы производная таблица, как, например, полученная в результате под запрос,
[40:56.240 --> 41:02.400]  соединение таблиц или сложная комбинация этих вариантов. То есть, может быть, после From в
[41:02.400 --> 41:08.320]  скобочках селект стоять и дальше будет какой-то вложенный запрос. Может быть, после From table
[41:08.320 --> 41:18.840]  1 join table 2, и там уже в зависимости от вариантов соединения используется либо условия,
[41:18.840 --> 41:25.560]  либо отсутствие условия. Об этом чуть-чуть попозже. А если в предложении From перечисляются она,
[41:25.560 --> 41:30.280]  ну или третий под bullet, сложная комбинация этих вариантов, то есть мы можем там после From писать
[41:30.280 --> 41:39.240]  table 1 join, потом какой-то селект под запрос, потом он заканчивается, закрывается круглая скобка,
[41:39.240 --> 41:47.520]  и у нас будет еще и условие какое-то логическое на это соединение сложное. А если в предложении
[41:47.520 --> 41:51.840]  From перечисляются несколько ссылок, для них применяется перекрестное соединение в виде
[41:51.840 --> 41:55.680]  результаты декартового произведения отношений. Ну вот то, о чем я, собственно, сказал, просто
[41:55.680 --> 42:02.960]  перечисление таблиц, это по оболчанию декартового произведения, то есть сцепка каждой строки одной
[42:02.960 --> 42:12.600]  таблицы с каждой строкой другой таблицы. Давайте рассмотрим соединение поподробнее. Что это такое?
[42:12.600 --> 42:21.080]  Ну, что это такое, это, наверное, понятно. В принципе, такой тоже аналог теоретика множественных
[42:21.080 --> 42:30.640]  операций в религационной алгебре. Дальше у нас там будут геограммы с кругами Эйлера такая,
[42:30.640 --> 42:38.320]  ну, общая тоже, опять же, визуально отсылающая нас к курсам мат-логики и теории множеств.
[42:38.320 --> 42:46.560]  Так что здесь, наверное, все достаточно на каком-то таком интуитивном уровне понятно,
[42:46.560 --> 42:54.160]  но надо рассмотреть специфику применительно корреляционной нашей алгебре. И базовый синтакс
[42:54.160 --> 42:59.520]  соединения таблиц выглядит следующим образом. Таблица 1 – тип соединения, таблица 2 – условия
[42:59.520 --> 43:09.240]  соединения. При этом у нас соединение любых типов, то есть inner join, left outer join и так далее,
[43:09.240 --> 43:13.800]  могут вкладываться друг в друга или объединяться. То есть t1 и t2 в примере могут быть результатами,
[43:13.800 --> 43:18.960]  сами по себе могут быть результатами соединения. У нас ограничений на количество вот этих вот
[43:18.960 --> 43:25.600]  соединений нет, они могут быть у нас каскадными, но нет как бы с точки зрения абстрактного какого-то
[43:25.600 --> 43:29.800]  принципа ограничивающего нас. Конечно, реализация имеет свои ограничения всегда.
[43:29.800 --> 43:38.200]  Тип соединений в Postgres приведен на слайде, опять же, внизу. Это, во-первых, cross-join – перекрестное
[43:38.200 --> 43:46.040]  соединение, то есть просто-напросто декартовое произведение отношений и соединение с сопоставлением
[43:46.040 --> 43:54.280]  строк. Их в Postgres 4 вида – inner join, left outer join, right outer join и full outer join. При этом у нас
[43:54.280 --> 44:04.920]  outer можно опустить, и по умолчанию Postgres нас вполне себе поймёт. И inner, да, конечно же.
[44:04.920 --> 44:12.720]  По умолчанию подразумевается вот внутреннее соединение при указании left, right и full. То есть
[44:12.720 --> 44:17.280]  когда он просто join пишет, подразумевается inner при указании left, right, full – внешнее соединение.
[44:17.280 --> 44:25.040]  Условия соединения в предложении указываются в предложении on или using, либо неявно задаётся
[44:25.040 --> 44:30.440]  ключевым словом natural. Это условие определяет, какие строки двух исходных таблиц считаются
[44:30.440 --> 44:38.240]  соответствующими друг другу. Что имеется в виду? Смотрите, у нас может быть предложение on и
[44:38.240 --> 44:44.760]  какое-то логическое условие. Мы таблицу 1 соединяем с таблицей 2, он, и дальше там ID,
[44:45.240 --> 44:58.160]  таблица 1 ID равно таблице 2 ID. Мы можем использовать using, если у нас есть набор атрибутов одноимённых.
[44:58.160 --> 45:06.920]  И в таком случае, используя using, мы подразумеваем, что у нас, и перечисляя столбцы, по которым мы будем
[45:06.920 --> 45:12.600]  производить соединение, мы подразумеваем, что у нас соединение будет по условию эквивалентности,
[45:12.600 --> 45:22.920]  то есть равенства. По сути дела, это значит, что в этом примере using у нас будет равен on T1 ID,
[45:22.920 --> 45:30.800]  T2 ID, то, о чём я сказал очень ранее. А natural – это наиболее общий вариант из всех трёх,
[45:30.800 --> 45:38.360]  потому что он позволяет скрыть лишнее, возможно, но он, соответственно, менее явный.
[45:38.360 --> 45:45.560]  Natural подразумевает, что у нас по всем совпадающим атрибутам отношений происходит соединение по
[45:45.560 --> 45:54.080]  эквивалентности значения атрибутов. То есть, подразумевается, что мы используем по всем
[45:54.080 --> 46:04.280]  одноимённым столбцам условия эквивалентности, условия равенства значений. Элементы синтаксиса,
[46:04.280 --> 46:16.000]  соединение таблицы join. Вот 4 вида соединения приведены в символической записи, в такой более
[46:16.000 --> 46:22.240]  нагладной. Почему здесь нет внешнего соединения, перекрёстного соединения? Потому что, на самом деле,
[46:22.240 --> 46:33.880]  у нас получается при перекрёстном соединении не full join, не полное соединение, а нечто другое.
[46:33.880 --> 46:39.040]  Нечто другое, и на это мы сейчас чуть подробнее посмотрим. Хотя, в принципе, я уже говорил,
[46:39.040 --> 46:44.400]  до декартового произведения, и мы это обсуждали с вами на первой лекции, это сцепка каждой строки
[46:44.400 --> 46:51.360]  одной таблицы с каждой строкой другой таблицы. При внешнем соединении полном у нас происходит не
[46:51.360 --> 47:03.840]  сцепка каждой строки с каждой строкой, а сцепка всех строк, независимо от того, есть ли соответствующий
[47:03.840 --> 47:11.040]  значение в одной таблице для другой таблицы или нет. И вот отсутствие соответствия у нас будет
[47:11.040 --> 47:19.880]  заполняться нашим маркером null, и соответственно, в таблице это будет null-ами обозначено.
[47:19.880 --> 47:27.960]  Так, хорошо, cross-join давайте рассмотрим на примере. Вот у нас две небольших таблички,
[47:27.960 --> 47:38.720]  соответственно, у нас в одной три кортежа, в другой две. Два кортежа, мы их полностью соединяем
[47:38.720 --> 47:43.920]  путем декартового произведения, получаем результирующую таблицу из шести строчек,
[47:43.920 --> 47:47.880]  то есть каждая строка первой таблицы с каждой строкой второй. Ну здесь, в общем, все наглядно,
[47:47.880 --> 47:57.560]  понятно, очевидно. Вот опять же, эквивалентность cross-join запроса у нас следующая. Мы
[47:57.560 --> 48:05.240]  можем для cross-join запроса, вместо cross-join запроса записать from employees inner-join departments
[48:05.240 --> 48:16.840]  on true. То есть мы соединяем путем внутреннего соединения две таблицы, но у нас нет никакого
[48:16.840 --> 48:25.600]  осмысленного какого-то условия. Мы, по сути дела, здесь пишем тавтологию, условия тавтологии,
[48:25.600 --> 48:32.320]  и у нас происходит то же самое декартовое произведение, перекрестное соединение путем
[48:32.320 --> 48:44.360]  декартового произведения. Так, это у нас в копилку того, что у нас SQL-язык, он семантически
[48:44.360 --> 48:49.680]  избыточен. Это в какой-то степени может быть хорошо, потому что довольно гибкие требования
[48:49.680 --> 48:54.440]  к пользователям баз данных предъявляются в какой-то степени плохо, потому что не
[48:54.440 --> 49:00.640]  всегда понятно, как лучше и оптимальнее построить запрос, не зная какие-то поднагодные структуры,
[49:00.640 --> 49:08.000]  подлежащие структуры. Хорошо, а внутреннее соединение inner-join, что у нас происходит? Во-первых,
[49:08.000 --> 49:16.040]  вот после перекрестного соединения у нас вот эти все inner-join и три типа outer-join, outer-join
[49:16.040 --> 49:21.320]  соединений, они подразумевают условия какие-то, явно заданные. Это вот первое явное отличие от
[49:21.320 --> 49:29.080]  cross-join. И здесь вот первый пример inner-join, мы видим это условие опять же, оно здесь уже такое более
[49:29.080 --> 49:38.040]  или менее понятное. Здесь мы пытаемся по ID полю соединить две таблицы, мы пытаемся получить
[49:38.040 --> 49:49.680]  всех работников, которые у нас работают в каких-то конкретных департаментах. Вот по сути дела мы
[49:49.680 --> 49:59.680]  здесь это и получили, соединили две таблицы, у нас все работники работают во всех возможных
[49:59.680 --> 50:07.040]  департаментах, поэтому у нас здесь нет каких-то вот уменьшений, что ли, поли, у нас получается
[50:07.040 --> 50:13.960]  сцепка по первой таблице. По первой таблице, по всем ее строкам, со всеми возможными значениями
[50:14.400 --> 50:26.200]  второй таблицы, повторюсь потому что у нас здесь нет разночтений, нет отсутствующих, нет значений в
[50:26.200 --> 50:31.560]  таблице департаментов, нет значений в таблице департаментов, которые бы отсутствовали в таблице
[50:31.560 --> 50:37.620]  работников, и наоборот, наоборот вернее неверно в наш стаблиц департаментов вообще нет ссылок
[50:37.620 --> 50:45.060]  работников, да, прошу прощения. Так, хорошо. Смотрите, а теперь что у нас произойдет, если мы
[50:45.060 --> 50:54.140]  захотим получить всех работников, которые у нас работают в первом департаменте? Можно ли
[50:54.140 --> 51:00.700]  сделать вот такой запрос? Можно ли сделать вот такой запрос или нет? Что он нам выдаст? Казалось
[51:00.700 --> 51:10.900]  бы, вроде бы мы пытаемся по department ID равным единице получить результат, где бы у нас только
[51:10.900 --> 51:19.340]  Джон Доу и Элис Джонсон фигурировали бы в результирующей таблице. Но на самом деле здесь
[51:19.340 --> 51:24.820]  есть определенная проблема, потому что действительно у нас Джон Доу и Элис Джонсон фигурируют в
[51:24.820 --> 51:29.620]  результирующей таблице, но они фигурируют в задвоенном варианте. Почему так произошло? Потому
[51:29.620 --> 51:38.740]  что мы на самом деле никакого ограничения на цепку со второй таблицей не задали. Мы задали
[51:38.740 --> 51:44.620]  ограничения для первой таблицы, мы выдали только значения, выбрали из нее только значения,
[51:44.620 --> 51:52.620]  которые соответствуют департаменту 1, это инжиниринг, и соединили дальше все эти значения
[51:52.620 --> 51:59.460]  со всеми сроками таблицы 2. Как нам нужно было записать запрос? А вот так. Нужно было сохранить
[51:59.460 --> 52:08.220]  изначальные условия по соответствию ID департамента и добавить еще условия, что нам нужно в результирующей
[52:08.220 --> 52:16.060]  таблице получить только те записи, где у нас работники работают в департаменте 1.
[52:16.060 --> 52:30.740]  Что дальше? Дальше у нас left join. Left join – это внешнее соединение слева. Что это значит?
[52:30.740 --> 52:38.300]  Значит, что мы берем две таблицы. В данном случае это наши изначальные таблицы, но немножко
[52:38.300 --> 52:47.180]  расширенные. Мы добавили две строки в таблицу работников и одну строку в таблицу департаментов.
[52:47.180 --> 52:52.500]  Теперь у нас есть несоответствие. У нас есть работник номер 5, Дэвид Вилсон, который у нас не
[52:52.500 --> 52:57.580]  работает ни в одном из перечисленных департаментов, а с другой стороны департамент есть маркетинга,
[52:57.580 --> 53:07.220]  который не содержит в себе сотрудников, в котором нет сотрудников перечисленных в таблице employees.
[53:07.220 --> 53:15.780]  Таким образом, что происходит здесь? Мы берем путем внешнего соединения слева,
[53:15.780 --> 53:25.660]  соединяем две таблицы работников и департамента по ID департамента. У нас получается,
[53:25.660 --> 53:33.940]  что для Дэвида Вилсона не будет корреспонтирующего значения, как Postgres с этим справится,
[53:33.940 --> 53:49.140]  ну или вернее стандарт SQL с этим справится. На самом деле, выделенные две ячейки – это не пустые
[53:49.140 --> 54:12.300]  ячейки, это ячейки, в которых будет значение NALT. Что произошло? У нас, поскольку для нашей
[54:12.300 --> 54:19.500]  левой таблицы не хватило для соединения подходящих значений, мы все равно взяли всю полностью левую
[54:19.500 --> 54:26.820]  таблицу целиком, и для недостающего значения справа и справой таблицы мы приписали в строку
[54:26.820 --> 54:36.420]  левой таблицы два значения NALT. Таким образом, у нас отработал LEFT JOIN и RIGHT JOIN будет работать
[54:36.420 --> 54:45.380]  аналогичным образом, но уже для правой таблицы. Соответственно, у нас здесь для департамента
[54:45.380 --> 54:52.580]  маркетинга будет значение NALT. Как это будет выглядеть? Все сотрудники, которые у нас работают
[54:52.580 --> 54:59.140]  в перечисленных департаментах, появятся в результирующей таблице. У нас для маркетинга
[54:59.140 --> 55:04.260]  не будет никакого значения по сотрудникам, там будут выделенных ячейок значения NALT,
[55:04.260 --> 55:23.820]  а один сотрудник Дэвид Вилсон не будет выбран из исходной таблицы. Возвращаясь к этой общей
[55:23.820 --> 55:32.740]  схеме, теоретико-множественной, у нас таблица здесь работников. Прошу прощения, здесь, конечно,
[55:32.740 --> 55:41.900]  должна быть перевернутая схема. При выкладывании я это поправлю, но здесь, соответственно,
[55:41.900 --> 55:48.940]  должен быть вот этот кружочек закрашен, этот кружочек должен быть не закрашен в части за
[55:48.940 --> 55:53.780]  пределами пересечения. Соответственно, вот здесь у нас, ну, например, LFJoin таблица с
[55:53.780 --> 56:01.420]  сотрудниками, здесь таблица с департаментами, и вот мы захватили всех сотрудников, и в том числе
[56:01.420 --> 56:12.100]  часть департаментов, которые у нас с сотрудниками соотносятся. Часть сотрудников, которые с
[56:12.100 --> 56:18.460]  департаментами не соотносятся, получила значение NALT. Понятно, на схеме это выглядит немножко не так,
[56:18.460 --> 56:29.260]  если воспроизводить схему по примеру того, что приведено ниже, наложение кругов должно
[56:29.260 --> 56:39.580]  быть сильно больше. И наоборот, область не захлёстнутая, не за пределами перекреста,
[56:39.580 --> 56:48.700]  перекрещивание должно быть меньше. Это уже так, в частности, детали. Пример приведен без
[56:48.700 --> 56:58.380]  соблюдения реальных масштабов, скажем так. Давайте посмотрим на последний вариант соединения,
[56:58.380 --> 57:04.500]  это full outer join, полное внешнее соединение, и что у нас получится. По сути дела, это будет комбинация
[57:04.500 --> 57:13.220]  двух предыдущих вариантов. Когда мы взяли все значения из всех таблиц, мы их, в отличие от
[57:13.220 --> 57:22.420]  декартового произведения, не соединяли посрочно, не конкатенировали строка за строкой,
[57:22.420 --> 57:29.300]  соединяли только по вот этому логическому условию, а то, что в это условие не попало,
[57:29.300 --> 57:35.860]  мы взяли и слева, и справа, и дополнили соответствующие строки значениями Null. Повторюсь,
[57:35.860 --> 57:41.580]  это значения Null, вот эти вот выделенные, залитые строки, они не пустые, в них значение Null.
[57:41.580 --> 57:55.980]  Хорошо, давайте пойдём дальше. Что у нас теперь? Это выражение where, это выражение, которое
[57:55.980 --> 58:02.340]  позволяет нам задать условия ограничения в выборке, и здесь все условия ограничения – это любое
[58:02.340 --> 58:09.380]  выражение значения, выдающее результат типа boolean, то есть любое выражение, которое даёт нам
[58:09.380 --> 58:19.620]  true или false, допустимо в значение where. Опять же, вспоминаем троичную тернарную логику, что там у нас,
[58:19.620 --> 58:31.980]  в SQL у нас три значения, напоминаю, что для where должно быть строго истинное значение,
[58:31.980 --> 58:40.180]  у нас значение not false, то есть true и unknown не подходят, если у нас будет unknown, строка не
[58:40.180 --> 58:47.300]  будет выбрана. А для unknown, соответственно, нужно использовать специальные предикаты,
[58:47.380 --> 58:54.620]  мы в общих чертах о них говорили в прошлый раз. А стоящие элементы синтаксиса, табличное выражение
[58:54.620 --> 59:00.220]  group by и having, то есть, напоминаю, табличное выражение – это всё то, что идёт после for,
[59:00.220 --> 59:09.540]  мы разобрали с вами после for, как мы можем задавать исходные отношения, из которых мы возьмём
[59:09.540 --> 59:13.860]  данные, мы можем их задавать перечислением, и будет у нас до картого произведения, можем
[59:13.860 --> 59:20.020]  использовать соединение в явной форме. Потом мы увидели, что у нас есть дополнительные логические
[59:20.020 --> 59:26.620]  условия после предложения where только что, а ещё у нас есть дополнительные команды, дополнительные
[59:26.620 --> 59:35.380]  операторы – это group by и having. Что это такое? Это любопытная штука, на самом деле, на базовом
[59:35.380 --> 59:42.300]  уровне это простая вещь, она сложно становится в комплексных запросах, но базово получается,
[59:42.300 --> 59:53.820]  что за счёт group by мы можем по какому-то столбцу сгруппировать значения так, что у нас по какому-то
[59:53.820 --> 01:00:03.820]  столбцу одинаковые строки схлопнутся, они будут как бы одной строкой. А дальше там на слайдах мы
[01:00:03.820 --> 01:00:09.700]  это ещё посмотрим чуть подробнее, но смысл вот такой – group by схлопывает у нас одинаковые
[01:00:09.700 --> 01:00:17.020]  значения. Having позволяет эти одинаковые значения отсортировать уже после предшествующей
[01:00:17.020 --> 01:00:23.420]  сортировки where. Ну не сортировки, а выборки. Позволяет выбрать дополнительно where, позволяет
[01:00:23.420 --> 01:00:34.380]  выбрать после исполнения команды from и следующих за ним выражений, а having позволяет выбрать
[01:00:34.380 --> 01:00:45.380]  после исполнения команды group by. Дополнительная информация на слайде. Что ещё можно сказать в слух?
[01:00:45.380 --> 01:00:49.900]  Это упоминание агрегатных функций, что если они используются, то учисляются по всем строкам,
[01:00:49.900 --> 01:00:55.060]  составляющим каждую группу, и в итоге выдают отдельное значение для каждой группы уже, а по
[01:00:55.060 --> 01:01:01.620]  умолчанию агрегатные функции будут выдавать значение для всей таблицы целиком, если мы
[01:01:01.620 --> 01:01:09.660]  используем здесь группировки. Что ещё? Это вот предложение group by собирает в одну строку
[01:01:09.660 --> 01:01:15.060]  все выбранные строки, выдающие одинаковые значения для выражения группировки. В качестве выражения
[01:01:15.060 --> 01:01:19.620]  внутри элемента группировки может выступать имя входного столбца, либо имя или порядковый номер
[01:01:19.620 --> 01:01:27.060]  выходного столбца. Это уже более сложные нюансы для подзапросов каких-то, либо произвольное
[01:01:27.060 --> 01:01:36.940]  значение, вычисляемое по значениям входных столбцов. Хорошо. Если у нас в запросе присутствует
[01:01:36.940 --> 01:01:41.300]  предложение group by или какая-либо агрегатная функция, выражения в списке select по общему
[01:01:41.300 --> 01:01:46.580]  правилу не могут обращаться к негруппируемым столбцам, так как иначе в негруппируемом столбце
[01:01:46.580 --> 01:01:52.540]  нужно было бы вернуть более одного возможного значения. Ну то есть понятно, если у нас group
[01:01:52.540 --> 01:01:59.700]  by есть и мы в group by указываем какой-то столбец, то мы уже в select не можем выбрать другой столбец,
[01:01:59.700 --> 01:02:05.380]  потому что у нас для другого столбца значение будет неопределено. У нас уже схлопнута по
[01:02:05.380 --> 01:02:13.300]  отдельным атрибутам наша строки нашей таблицы, а по другим атрибутам те же строки они не
[01:02:13.300 --> 01:02:19.180]  схлопнуты. И как работать в select в такой ситуации стандарт не определяет. Поэтому
[01:02:19.180 --> 01:02:26.340]  мы должны явно обозначить, что мы хотим выбрать после использования group by. У нас в select список
[01:02:26.340 --> 01:02:36.500]  выборки должен совпадать в этом отношении с элементом группирования. Также можно отфильтровать,
[01:02:36.500 --> 01:02:43.780]  да, мы это уже проговорили с вами. Давайте посмотрим на примере, чтобы было попонятнее. Вот мы здесь
[01:02:43.780 --> 01:02:53.500]  группируем по департаменту. У нас новая таблица new employees. Мы группируем по департаменту и по
[01:02:53.500 --> 01:02:59.580]  жалованию по заработной плате. Что у нас получится? Вот что у нас получается. Вот по департаменту мы
[01:02:59.580 --> 01:03:06.140]  сгруппировали. Смотрите, здесь получились кадры маркетинг финанса IT и вот они выделены. Каждый
[01:03:06.140 --> 01:03:12.900]  департамент выделен своей заливкой в исходной таблице. И по жалованию по зарплате мы тоже
[01:03:12.900 --> 01:03:21.380]  сгруппировали. И у нас получилось 50, 60, 70. И тоже здесь группы с повторяющимися значениями выделены
[01:03:21.380 --> 01:03:27.500]  каждой своей заливкой. Ну как бы базово все, наверное, довольно понятно. А что будет, если мы
[01:03:27.500 --> 01:03:37.900]  сделаем один шаг вперед, один шаг дальше? Если мы хотим сгруппировать по двум столбцам. Ну,
[01:03:37.980 --> 01:03:48.540]  во-первых, сразу скажу, что в таком случае у нас не будет влиять на результат порядок группировки.
[01:03:48.540 --> 01:03:53.500]  То есть мы можем department salary, group by department salary, можем group by salary department,
[01:03:53.500 --> 01:03:58.460]  сформулировать селек запрос. Это неважно. Смысл в том, что у нас в нашей группе должны
[01:03:58.460 --> 01:04:06.300]  быть повторяющиеся значения. Какой у нас будет результат? Результат будет следующий. Смотрите,
[01:04:06.300 --> 01:04:11.460]  что получилось. У нас была исходная таблица 10 значений, результирующая таблица 7 значений,
[01:04:11.460 --> 01:04:21.780]  7 строк. Что удалось сгруппировать? У нас здесь три IT-департамента, здесь у нас только два IT-департамента.
[01:04:21.780 --> 01:04:29.860]  Что случилось? У нас по IT-департаменту есть два специалиста с одинаковой зарплатой. Вот это и
[01:04:29.860 --> 01:04:39.460]  вот эта строка. Даже более того, вот два вот этих значения, вот здесь и вот здесь, они схлопнулись.
[01:04:39.460 --> 01:04:45.940]  Вот они стали одним значением. Вот это значение у нас не может ни с чем схлопнуться. Оно уникальное,
[01:04:45.940 --> 01:04:53.740]  поэтому оно попало в отдельную строку. Для маркетинга то же самое. Здесь схлопнулись у нас
[01:04:53.740 --> 01:05:06.420]  значения 60 тысяч маркетинг. 60 тысяч маркетинг в одно. Маркетинг 50 тысяч. Оно осталось,
[01:05:06.420 --> 01:05:16.300]  потому что ни с чем не схлопнулось. Получается еще с кадрами. С кадрами склопнулись два значения в одно.
[01:05:16.300 --> 01:05:23.220]  И вот соответственно три склопывания. Три строки у нас три раза совместились,
[01:05:23.220 --> 01:05:30.940]  соединились, сгруппировались по две строки. Из шести строк стало три. Вот из десяти начальных
[01:05:30.940 --> 01:05:40.580]  строк стало отношение с семью результирующими. Давайте еще немножко усложним, попробуем посмотреть,
[01:05:40.580 --> 01:05:50.420]  что получится с Хевинг. Хевинг сэлори больше 60 тысяч. Мы из предыдущей таблицы оставили у нас
[01:05:50.420 --> 01:05:57.220]  в результирующем отношении только две записи, где у нас больше 60 тысяч рублей получает некто,
[01:05:57.220 --> 01:06:04.620]  кто-то в IT-департаменте или финансе. Это не очень осмысленный запрос, но механику того,
[01:06:04.620 --> 01:06:11.100]  как работает групп-бай по нескольким столбцам и как работает Хевинг, в принципе он показывает.
[01:06:11.100 --> 01:06:23.940]  Одну секунду, вопрос в чате. Вопрос, если убрать групп-бай, то с точки зрения релиционной алгебры
[01:06:23.940 --> 01:06:33.420]  не получится ли тот же самый результат? Если убрать групп-бай, то мы здесь
[01:06:33.420 --> 01:06:49.580]  получим не вот эту табличку, а получим целиком, давайте попробуем на пальцах,
[01:06:49.580 --> 01:07:02.580]  from new employees, то есть мы берем всю таблицу, берем оттуда department salary. Вы знаете,
[01:07:02.580 --> 01:07:12.580]  может быть, что в этом конкретном примере кажется, что возможно так и получится. Это опять же с точки
[01:07:12.580 --> 01:07:18.100]  зрения релиционной алгебры, потому что когда мы выполним вот этот вот запрос без групп-бай,
[01:07:18.100 --> 01:07:26.020]  то есть select department salary, department salary from new employees, у нас не будет автоматического совмещения
[01:07:26.020 --> 01:07:31.940]  повторяющихся результатов. У нас будет просто вот этот столбец и еще вот этот столбец целиком,
[01:07:31.940 --> 01:07:37.820]  без исключения. Для исключения нам нужно будет задать условия, например, нам нужно будет там
[01:07:37.820 --> 01:07:46.340]  distinct поставить, select distinct department salary, тогда скорее всего, наверное, получится такой же
[01:07:46.340 --> 01:07:53.500]  результат. Кажется, что здесь, ну не кажется, здесь больше совпадающих значений нет, по идее должен
[01:07:53.500 --> 01:08:00.060]  получиться такой же результат. Спасибо за вопрос, но повторюсь, в алгебре, в чистой алгебре получилось,
[01:08:00.060 --> 01:08:11.540]  в базе данных автоматического совмещения идентичных значений не произойдет, просто выдаст запрос
[01:08:11.540 --> 01:08:17.020]  полных два столбца со всеми десятью значениями, пускай они будут повторяющиеся.
[01:08:17.020 --> 01:08:26.980]  Хорошо. Сортировка. С сортировкой все очень просто, ребят, здесь даже не будет сейчас
[01:08:26.980 --> 01:08:38.780]  примера, потому что просто. Здесь сказать можно, пожалуй, что у нас выражение сортировки может
[01:08:38.780 --> 01:08:46.860]  быть любое значение допустимое в списке выборки запроса. Когда указывается несколько выражений,
[01:08:46.860 --> 01:08:53.100]  последующие значения позволяют сортировать строки, в которых совпали все предыдущие значения,
[01:08:53.100 --> 01:08:58.660]  и каждое выражение можно дополнить ключевыми словами ask или desk, которые выбирают сортировку,
[01:08:58.660 --> 01:09:03.380]  соответственно, по возрастанию или убыванию. По умолчанию принят порядок по возрастанию. То
[01:09:03.380 --> 01:09:09.780]  есть мы можем в order by несколько условий задать, и условия будут работать, как указано. Последующие
[01:09:09.780 --> 01:09:19.340]  значения сортируют строки, в которых совпали все предыдущие значения. По умолчанию, опять же,
[01:09:19.340 --> 01:09:25.180]  у нас порядок по возрастанию, и мы можем также задать порядок работы с налами. То есть по умолчанию
[01:09:25.180 --> 01:09:32.060]  у нас всегда считаются налы больше любых других значений. То есть подразумевается, что null first
[01:09:32.060 --> 01:09:37.660]  для порядка desk и null last в противном случае. Но мы можем задать, соответственно, произвольно,
[01:09:37.660 --> 01:09:48.780]  явным предложением null first или null last. Хорошо, давайте теперь поговорим, наконец-то, о порядке
[01:09:48.780 --> 01:09:56.460]  выполнения запросов. Смотрите, у нас в чем проблема? SQL — язык декларативный. Мы не говорим,
[01:09:56.460 --> 01:10:00.460]  как мы делаем, мы говорим, что мы хотим получить. SQL — язык, как мы уже с вами говорили,
[01:10:00.460 --> 01:10:06.700]  семантически избыточный. У нас есть много вариантов получить те данные, которые мы хотим,
[01:10:06.700 --> 01:10:13.140]  сформировав несколько семантических икновалентных, то синтаксических и различающихся между собой
[01:10:13.140 --> 01:10:22.780]  конструкций. И хотя, как вы помните, из первой лекции разработчики пытались снизить порог входа
[01:10:22.780 --> 01:10:29.060]  для SQL, но на самом деле запрос SQL нетривиальный. Я думаю, часть из вас на семинарах уже явно
[01:10:29.060 --> 01:10:41.820]  успели в этом убедиться, особенно кто нашел под запросов. Они не тривиальные. На естественном
[01:10:41.820 --> 01:10:48.180]  языке звучат просто, что мы хотим получить из базных данных. На SQL языке запрос будет не
[01:10:48.180 --> 01:10:52.980]  столь очевидным, как хотелось бы. Процесс или команда получения данных из базных данных
[01:10:52.980 --> 01:10:58.540]  называется запросом. В SQL запрос оформулируется с помощью команды Select. Это такая цитата
[01:10:58.540 --> 01:11:10.820]  из официальной документации. Разберемся, как работает Select-запрос. Смотрите, хотя мы пишем
[01:11:10.820 --> 01:11:20.220]  сначала как Select, From, Where, GroupBy, Having, OrderBy, Limit и Offset. Но на самом деле у нас выполняется
[01:11:20.220 --> 01:11:26.100]  все иначе. Сначала у нас From и Join отрабатывает, потом Where, потом GroupBy, потом Having,
[01:11:26.100 --> 01:11:35.660]  потом только Select, и дальше OrderBy и Limit или Offset. Что происходит? Сначала у нас в любом случае
[01:11:35.660 --> 01:11:44.180]  из таблицы 1 с таблицы 2 происходит соединение. Причем Декартова в данном случае у нас показывает
[01:11:44.180 --> 01:11:50.940]  соединение на этапе, а потом только у нас происходит выборка по соответствию значения columnA, columnA,
[01:11:50.940 --> 01:11:58.660]  в т1 таблица и т2 по columnA соответствию. Дальше дополнительное ограничение какое-то логическое у
[01:11:58.660 --> 01:12:05.180]  нас еще больше отфильтровывает таблицу, еще больше уменьшает результирующую выборку. Дальше мы можем
[01:12:05.180 --> 01:12:10.900]  сгруппировать каким-то образом наш отношение, получившееся к этому моменту. И вот видите,
[01:12:10.900 --> 01:12:18.620]  здесь показано визуально схлопывание по одному из атрибутов, схлопывание нескольких строк. И уже
[01:12:18.620 --> 01:12:24.780]  вот это отношение мы также можем дополнительно каким-то логическим условиям ограничить. И только
[01:12:24.780 --> 01:12:31.240]  потом у нас появится Select, будет отрабатывать Select запрос сам непосредственно. Он уже из
[01:12:31.240 --> 01:12:38.300]  вот этого множество выберет те значения, те атрибуты, значения которых нас интересует.
[01:12:38.300 --> 01:12:46.740]  И дальше дополнительно мы уже можем отсортировать или задать какой-то лимит или сдвиг на выдаваемый
[01:12:46.740 --> 01:12:53.980]  результат. Пример работы запроса Select. Мы хотим знать название только двух городов, кроме Сан-Брунов,
[01:12:53.980 --> 01:13:00.460]  в которых проживает два и более жителей. Мы также хотим получить результат упорядоченный по
[01:13:00.460 --> 01:13:06.940]  алфавиту. Вот у нас такая мини схема наших отношений. Вот собственно два отношения представлены.
[01:13:06.940 --> 01:13:16.540]  Есть какое-то количество горожан и три города. Так вот у нас два отношения. Вот как наполнены
[01:13:16.540 --> 01:13:24.140]  эти отношения данными. Дальше что мы делаем? Вот у нас запрос. Вот у нас два отношения. Смотрим.
[01:13:24.140 --> 01:13:30.500]  Сначала отрабатывает From Citizen, Joint City. Вот у нас полное декартовое произведение между Citizen
[01:13:30.660 --> 01:13:40.700]  между горожанами и городами. У нас здесь было на предыдущем слайде 9 горожан и три города. И вот
[01:13:40.700 --> 01:13:46.540]  здесь вот у нас, если вы посчитаете, 27 столбцов. То есть 9 на 3 у нас полное декартовое произведение,
[01:13:46.540 --> 01:13:54.580]  27, прошу прощения, строк. Полная сцепка каждой строки с каждой строкой из двух таблиц. Дальше у нас
[01:13:54.580 --> 01:14:05.380]  отрабатывает условие логическое на соединение. По CityID у нас происходит соединение. И здесь по равенству
[01:14:05.380 --> 01:14:15.300]  CityID вот соответственно остается всего опять же 9 человек, как и было изначально в отношении
[01:14:15.300 --> 01:14:23.660]  горожан. Дальше мы дополнительные условия накладываем на наши результирующие отношения. Говорим,
[01:14:23.700 --> 01:14:30.660]  что нас не интересуют жители города Сан-Бруно, и вот они у нас исключены. И дальше мы группируем
[01:14:30.660 --> 01:14:43.260]  наше результирующее отношение по значению CityName, по имени города. Обратите внимание визуально,
[01:14:43.260 --> 01:14:51.540]  как это обозначено. Вот явно здесь обозначено, что строки схлопнуты. Таким образом у нас как бы и
[01:14:51.540 --> 01:14:59.780]  таким образом вот это и нужно себе представлять для удобства. Слопывание строк как объединение
[01:14:59.780 --> 01:15:06.460]  ячеек просто-напросто в таблице. Потом мы отфильтровываем по HeavenCount больше или равно
[01:15:06.460 --> 01:15:12.380]  двум. То есть там, где у нас больше чем две строки, подразумевается, что каждая строка это отдельный
[01:15:12.380 --> 01:15:19.180]  горожанин. У нас здесь везде больше двух строк, поэтому оба для обоих городов у нас остается
[01:15:19.180 --> 01:15:26.820]  неизменным количеством записей о горожанах. Дальше мы наконец отрабатываем наш Select
[01:15:26.820 --> 01:15:37.260]  Statement, Select предложение и выводим имена названия городов, которые соответствуют нашему запросу,
[01:15:37.260 --> 01:15:43.900]  и дальше уже мы их сортируем и ограничиваем. Лимит два ставим, но здесь опять же только два
[01:15:43.900 --> 01:15:51.220]  города, поэтому произошла только сортировка без ограничения списка выдачи. Таким образом,
[01:15:51.220 --> 01:15:58.060]  ребята, мы с вами разобрали основные моменты, связанные с Data Manipulation Language, с языком
[01:15:58.060 --> 01:16:04.220]  манипулирования данными под множеством языка SQL. Посмотрели на основные особенности Select
[01:16:04.220 --> 01:16:15.620]  запроса, на типы соединений, на то, как отрабатывает Select запрос. Посмотрели на остальные операторы DML,
[01:16:15.620 --> 01:16:23.020]  это Insert, Update и Delete. В следующей лекции у нас будут агрегирующие функции под запросы обязательно,
[01:16:23.020 --> 01:16:31.580]  и мы постараемся с вами разобрать основу проектирования баз данных. Таким образом,
[01:16:31.580 --> 01:16:41.180]  вы после следующей лекции будете во всеоружии, я надеюсь, для начала подготовки курсового проекта.
