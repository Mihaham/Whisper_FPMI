[00:00.000 --> 00:14.280]  Сегодня, значит, на первой из двух пар мы должны разобрать два пункта и первый пункт будет
[00:14.280 --> 00:33.720]  называться unions, ну по классике include eostream. У нас тема называется type erasure и что-то там
[00:33.720 --> 00:48.200]  еще, я не помню. Вот и это параграф 14.3 unions and small strings optimization, что бы это не значило.
[00:48.200 --> 01:01.560]  Сейчас мы познакомимся с еще одной замечательной возможностью c++. Ну кто из вас
[01:01.560 --> 01:18.760]  знает что такое unions? Один человек. И что это? На самом деле unions это такая несколько
[01:18.760 --> 01:26.560]  выделяющаяся тема из всех, вообще не знаю, за последние три месяца, наверное, это очень
[01:26.560 --> 01:35.560]  необычная для нас тема, потому что это единственная за последние три месяца вещь, которая была еще
[01:35.560 --> 01:41.520]  до c++11 изучаемая нами. На самом деле это очень древняя возможность c++, просто в силу того,
[01:41.520 --> 01:46.880]  что она довольно редкая, мы ее отложили на потом. Вот, по идее про нее можно было в самом первом
[01:46.880 --> 01:53.680]  семестре рассказать вместе с классами. На самом деле unions это еще один такой вид типов. Вот
[01:53.680 --> 02:02.800]  бывают классы, да, бывают структуры, бывают unions. А unions это такое ключевое слово,
[02:02.800 --> 02:10.800]  значит вы можете объявлять unions, ну объединение то бишь. Вот, что такое unions? Ну давайте я вот
[02:10.800 --> 02:21.760]  создам такой unions, в нем будет лежать int x double y, не очень оригинально. И вот заведу объект такого
[02:21.760 --> 02:36.880]  union. Ну вот первое же, что вас должно заинтересовать, это то, что размер такого будет не 16, как в случае
[02:36.880 --> 02:50.320]  класса, а 8 всего лишь. А что в смысле? Double 8 занимает. Ну это конечно не специфицировано в стандарте,
[02:50.320 --> 02:59.880]  но у нас 8. Вот, как это так-то? А просто union это такая штука, которая, ну если класс это вещь,
[02:59.880 --> 03:06.680]  которая состоит из полей и хранит одновременно их все, то union это штука, которая в каждый момент
[03:06.680 --> 03:18.120]  времени хранит что-то одно из перечисленного. Вот так. Да, поэтому я это, чтобы не шокировать вас
[03:18.120 --> 03:22.640]  раньше времени, я это отложил аж на апрель. Рассказ об этой возможности замечать. Есть реально
[03:22.640 --> 03:30.400]  логичный вопрос. Вот, так сказать, you are free to ask questions. Давайте, какие у вас вопросы, пожалуйста,
[03:30.400 --> 03:38.280]  вот я понимаю, что у вас может это не... А она сама выбирает кого хранить? Ну если я не сказал,
[03:38.280 --> 03:46.480]  что туда положить, до чертова Мексика. Слушайте, я не знаю, что с этим делать. В общем, если я не сказал,
[03:46.480 --> 03:54.640]  кого туда положить, то там будет лежать вот то, что там первая перечислена. Давайте я скажу,
[03:54.640 --> 04:07.000]  интекс равно 1 и double равно 3,14. Не, давайте 5, чтобы на всякий случай ничего не... А я не могу по
[04:07.000 --> 04:14.920]  умолчанию инициализировать несколько членов. Ну вот да, если я так напишу, то будет 5 union не
[04:14.920 --> 04:23.200]  лежать. Да, но если я ничего не написал, то отлично. Сейчас он перезвонит, смотрите.
[04:23.200 --> 04:40.520]  Почему не выказывал? Я же говорю. Сейчас выйду. После этого он звонит на телефон.
[04:44.920 --> 05:00.480]  Чего? Я понимаю, я знаю, что такое ног, но как ты вообще пришел к этой идее? Может просто максимум?
[05:00.480 --> 05:14.480]  Я могу легко создать поле размера 3. Это массив чаров из трех чаров. Вот у меня
[05:14.480 --> 05:22.160]  может быть чар С из трех. И нет, он не будет кратен трем тогда размер. Нет, размер это максимум,
[05:22.160 --> 05:35.600]  ну с точки до выравнивания. Вот, хорошо. А давайте какие-нибудь примерчики разберем. У union есть
[05:35.600 --> 05:42.600]  такое понятие как активный член. Это то, что лежит в нем в данный момент. Вот если я просто так
[05:42.600 --> 05:50.680]  написал union по умолчанию, то активный член в нем становится первый. И я могу попросить его вывести,
[05:50.680 --> 06:10.360]  я могу попросить вывести у.x. Ну выведется там рандомное число скорее всего, но это... А если ты
[06:10.360 --> 06:16.060]  инициализируешь у и выведешь у.x, что будет? Будет у.b, формально, но по факту мне выведется
[06:16.060 --> 06:24.000]  интовое представление дабла, что логично. Ну давайте я так напишу. У.b, видимо, потому что с другими
[06:24.000 --> 06:30.760]  типами это непонятно как будет работать. Ну да, давайте вот так сделаем. Мне вывелся какой-то
[06:30.760 --> 06:42.160]  int, но по сути интерпреткасс сделался из первой части дабла в int. Обращаться к тому члену union,
[06:42.160 --> 06:54.720]  который в данный момент не активен, на чтение, это у.b. Я могу, впрочем, сказать у.x равно 5 и это
[06:54.720 --> 07:03.720]  нормально. И если это примитивные типы, то я спокойно могу просто присваивая одному перезатирать
[07:03.720 --> 07:17.040]  другой. Да, если я так делаю, то вывести его будет нормально. А если не примитивные типы становятся
[07:17.040 --> 07:26.720]  интереснее. Давайте предположим, что у меня тут еще std string лежит. У которого есть прекрасные поля,
[07:26.720 --> 07:34.560]  типа разумной. Да. Сейчас мы из стринга перезапишем случайно. Вот, ну во-первых, у меня сразу возникла
[07:34.560 --> 07:46.520]  ошибка. Default constructor of u is implicitly deleted. Если у меня в union одним из полей является что-то
[07:46.520 --> 07:51.720]  с нетривиальным конструктором, то я уже не могу создавать union по умолчанию. Мне нужно явно
[07:51.720 --> 08:09.560]  определить конструктор union. Есть то есть, но он нетривиальный. Считается, что мотивацию этого,
[08:09.560 --> 08:14.040]  что небезопасно так делать. Если я в union положил какие-то объекты, которые нетривиально
[08:14.040 --> 08:21.960]  конструируются, а потом говорю, создай мне union по умолчанию. У тебя там случайно лежит стряка,
[08:21.960 --> 08:29.040]  у которой в размере прописан миллиард. Это как-то не безопасно что ли. Мало ли что там
[08:29.040 --> 08:35.320]  код конструктора делает. Если я написал u, что я хочу? Я точно хочу вызвать вот тот код конструктора,
[08:35.320 --> 08:42.200]  который там происходит. Непонятно. Короче, если у меня есть какие-то более формальные требования,
[08:42.200 --> 08:48.280]  возможно даже не суть в том, что конструктор нетривиальный, а что-то там более тонкое. Но
[08:48.280 --> 08:54.680]  короче, я вынужден определить конструктор по умолчанию. Давайте я скажу, что там просто я
[08:54.680 --> 09:05.280]  их санитализирую пятеркой и все. Все равно не могу, потому что теперь деструктор неопределен. Это,
[09:05.360 --> 09:14.680]  кстати, тоже логично, потому что что делать деструктору-то тоже непонятно, но вот теперь
[09:14.680 --> 09:20.560]  нормально. То есть я должен определить и конструктор, и деструктор union явно теперь. Ну,
[09:20.560 --> 09:28.520]  почему я должен деструктор union явно определить? Потому что, вообще говоря, компилятор не может
[09:28.520 --> 09:36.720]  знать, когда union уничтожается, надо что-то уничтожить или нет. Это просто в целях безопасности
[09:36.720 --> 09:42.720]  сделано так, что я должен явно прописать, что должен делать компилятор, когда union уничтожается.
[09:42.720 --> 09:47.080]  Потому что мало ли там какие-то нетривиальные поля, надо как-то нетривиально уничтожать. Пока
[09:47.080 --> 09:53.600]  поля были примитивные, все было просто. А когда появилось поле какое-то вот такое, создавать,
[09:53.600 --> 10:02.480]  уничтожать union стало нетривиально. Ну, короче, вот. Вот я, значит, создал union, точно также в
[10:02.480 --> 10:10.600]  списке инициализации пронициализировал x. Теперь меня активен x, и я спокойненько им пользуюсь.
[10:10.600 --> 10:15.720]  Вот. Ну, ничего интересного, сейчас просто пятерка выявится.
[10:15.720 --> 10:36.920]  Нет. Нет, нельзя. Конечно, именно вам его и надо будет реализовать. Это пятая задача, да? Да. И как
[10:36.920 --> 10:45.960]  раз о том, как это сделать, мы будем обсуждать все две пары следующие. Ну, то есть, да, в следующий
[10:45.960 --> 10:51.800]  понедельник мы как раз... Сегодня вас Федя познакомит с этим замечательным объектом, так сказать,
[10:51.800 --> 10:55.640]  с этой замечательной сущностью из стандартной библиотеки, а в следующий понедельник мы с вами
[10:55.640 --> 11:00.320]  все три часа потратим на обсуждение, как же это реализовано. Так, а ты уезжаешь через день? Я
[11:00.320 --> 11:05.960]  уезжаю, нет, вот, послезавтра. И в следующий раз у нас уже должен быть онлайн. Ну, если все стоит,
[11:05.960 --> 11:13.280]  там еще, возможно, что-то... Просто непонятно, как это все будет. Ой, да господи. Ну, господи,
[11:13.280 --> 11:22.240]  сдвинем их попозже, если там, чтобы вам удобно было доехать, докуда надо. Короче, разберемся.
[11:22.240 --> 11:31.800]  Вот. Ну, тут все понятно. Да, чем плохи юнионы, тем, что никак не поймешь, кто активен, это вы
[11:31.800 --> 11:40.040]  должны сами как-то запоминать где-то. Ну, вот вам нужно как-то... Например, вы можете хранить структуру,
[11:40.040 --> 11:49.120]  в которую хранить тег и юнион. И этот тег будет показывать, какой член активен. Это называется
[11:49.120 --> 11:59.840]  тег и юнион. И это, в общем-то, иногда используется. Вот. Давайте разберем более интересный пример.
[11:59.840 --> 12:15.040]  Смотрите. Допустим, я сделал вот так, проинстилизировал у х, проинстилизировал пятеркой, а дальше
[12:15.040 --> 12:28.560]  решил, что мне надо бы строку чем-то проинстилизировать. И решил вывести х. Ну, не х, строку. То есть,
[12:28.560 --> 12:36.200]  я что решил сделать? Я такой, окей, у меня активный член х, а еще там лежит строка. Ну, все. Я хочу
[12:36.200 --> 12:45.600]  теперь, чтобы строка была активной. Давайте я строку вот теперь сделаю активной и выведу. Может быть,
[12:45.600 --> 12:55.480]  кто-то догадается, что сейчас будет не так? Ну, видимо, там вызывается оператор копирования,
[12:55.480 --> 13:01.920]  а не... Оператор присваивания. Точно. Да, оператор присваивания. Конечно, конечно, конечно. Это классическая
[13:01.920 --> 13:10.160]  ошибка при использовании юниона, да, и такой главный вопрос на понимание. Вот. Почему так очень плохо?
[13:10.160 --> 13:18.320]  Нет, стоп. Ну, убивает то, что лежит по указателю. Это классическая ошибка, когда вы вместо того,
[13:18.320 --> 13:25.160]  чтобы делать placement new, делаете присваивание. Вы взяли и присвоили. Но что это такое? Это оператор
[13:25.160 --> 13:30.680]  присваивания, у которого левый оперант стринг и правый оперант стринг. То есть, вызывается оператор
[13:30.680 --> 13:35.040]  присваивания стринг от стринг. То есть, первым делом делается delete квадратной скобочки на
[13:35.040 --> 13:48.560]  pointer. А там не pointer, там int, там лежит пятерка. Ну и все, значит. Set fold. Как же быть? Что же делать?
[13:48.560 --> 14:00.640]  Как же? Как же нам вместо int положить страху? Но я уже сказал, placement new надо использовать.
[14:00.640 --> 14:14.080]  Нужно сказать new по адресу вот этой строки.
[14:14.080 --> 14:26.640]  Std string. Ну, я в new хочу отдать указатель на t, то есть на то, что я создаю от abc. Вот.
[14:26.640 --> 14:35.560]  И мы должны сами же это чистить. Конечно. Вот. Сейчас будет, казалось бы, все нормально.
[14:35.560 --> 14:42.440]  Но только утечка памяти, да. Потому что деструктор строки, конечно же, никто не вызвал. В деструкторе
[14:42.440 --> 14:48.480]  union ничего не происходит. Я могу, конечно, здесь вызывать деструктор строки, но... А всегда ли она
[14:48.480 --> 14:56.080]  инициативой? Да, а если строка сейчас неактивна. Поэтому, чтобы все было корректно, мне нужно эту строку
[14:56.080 --> 15:08.480]  и уничтожить вручную. А как это сделать? u.str. Что? Давайте, давайте, это уже вопрос на понимание.
[15:08.480 --> 15:33.000]  Что надо написать? u.str. Что? Тильда что? Нет. Нет. Такой функции tilde string. Есть функция tilde
[15:33.000 --> 15:48.000]  basic string с шаблонным параметром char. Вот. Вот теперь все нормально. Если бы я написал tilde string,
[15:48.000 --> 15:54.760]  это бы не скомпилировалось. А разве не нужно писать tilde std basic string? Нет, потому что мы уже в пространстве
[15:54.760 --> 16:07.960]  std когда вошли в .str. Ага, окей. Ну вот, ну, как вы уже видите, что expected class name string это не
[16:07.960 --> 16:20.080]  class name, это using. Такие дела. Вот так. Очень странно, что using не прокатывает, потому что теоретически это реализуемо.
[16:20.080 --> 16:34.400]  Ну, давайте теперь посмотрим немножечко на cbp-reference и остальные возможности, так сказать, в формате
[16:34.400 --> 16:48.200]  быстро пробежимся. А что еще может быть в unions? Ну, unions могут иметь функции члены,
[16:48.200 --> 16:54.040]  включая конструкторы и деструкторы, но не виртуальные функции. Union не может ни от кого
[16:54.040 --> 17:01.600]  наследоваться и от union нельзя наследоваться. У union не может быть нестатических членов ссылок.
[17:01.600 --> 17:12.800]  До C++11 unions не могут содержать нестатический член, у которого не трев... О, до C++11 нельзя было делать
[17:12.800 --> 17:23.080]  string, полем union, но начиная с C++11, если union такой член содержит, то тогда соответствующая функция в
[17:23.080 --> 17:28.880]  union как раз удалена по умолчанию и нужна вот, нужна это в определении явно. То есть мы добавили
[17:28.880 --> 17:33.920]  полем string, это значит, что все то, что у string нетривиальное, копимув конструктор, копимув сайны,
[17:33.920 --> 17:38.560]  деструктор, все это сразу у нашего union стало implicitly deleted и мы должны явно это определять.
[17:38.560 --> 17:51.160]  Вот, так же как и в структуре, да в union могут быть модификаторы доступа, правила public,
[17:51.160 --> 17:59.600]  но по умолчанию так же как и в структуре все публичное. Вот, для чего нужны union?
[18:00.200 --> 18:07.200]  Илья, а что мешало union сгенерить такой же конструктор и деструктор, как вот то, что мы написали?
[18:07.200 --> 18:19.200]  Что значит такой же деструктор? Ну, имеется в виду, что если бы была конструктура и мы напишем то же самое, то у нас как бы оно все само сгенерится, а то оно почему-то запрещено, почему-то.
[18:19.200 --> 18:28.800]  Потому что комитет... Ну, а почему бы... Зачем генерировать конструктор и деструктор, который заведомо скорее всего делает что-то неправильное?
[18:28.800 --> 18:51.800]  Если ты добавил в union член с нетривиальным конструктором, то скорее всего... Ну, это что-то наподобие правила трех, ну, типа, однажды мы уже обожглись очень сильно о том, что компилятор генерировал за нас копий конструктор в случае, когда он скорее всего бы неправильно работал, и после этого у нас куча багов.
[18:51.800 --> 19:09.800]  Зачем компилятору генерировать конструктор, если ситуация явно подозрительная? Компилятор уж лучше скажет нам, чувак, задумайся, что должно здесь происходить, а не я по умолчанию сделаю что-то от балды. Ну, мне кажется, это поведение очень логично.
[19:09.800 --> 19:17.800]  Открывай, пожалуйста, код, который... Вот, если заменить union на struct и стереть конструктор и деструктор, что будет работать?
[19:17.800 --> 19:18.800]  Да.
[19:18.800 --> 19:25.800]  Вот, еще раз, я не понимаю мотивации, почему, если мы меняем на union, то уже не работает?
[19:25.800 --> 19:40.800]  Потому что в struct однозначно понятно, что делать, нужно проинitiциализировать все, а когда мы заканчиваем, нужно уничтожить все. А в union, вот union, допустим, выходит из области видимости, нужно уничтожить не все, а что-то одно, что?
[19:40.800 --> 19:49.800]  Нужно уничтожать string или не нужно, когда мы у union заканчиваем область видимости? Не понятно. Вот здесь должен называться деструктор string или не должен? Не понятно.
[19:49.800 --> 20:03.800]  Если он будет не вызывать никакой деструктор, то, вероятно, это будет утечка памяти у нас постоянно. Если он будет вызывать все, ну, какой-то деструктор от балды, то это будет seg-fall в половине случаев. Он не может сам отгадать, что делать здесь.
[20:03.800 --> 20:06.800]  А в данном случае он не вызывает никакого?
[20:06.800 --> 20:16.800]  В данном случае я написал пустой деструктор, он ничего не делает, да. Поэтому, чтобы у меня утечку памяти избежать, мне нужно вручную вызывать деструктор поля, вот так вот.
[20:16.800 --> 20:20.800]  Ну, то есть вообще union это какая-то очень тупая обертка над старой памятью.
[20:20.800 --> 20:39.800]  Да, union обычно используется в низкоуровневом коде, когда вам нужно экономить память. Ну, когда у вас по одному и тому же адресу может лежать что-то из перечисленных, у нас может лежать числа там с разными значениями, либо число, либо символ, ну не знаю.
[20:39.800 --> 20:48.800]  В общем, когда у вас какая-то вот структурка, в которой одно из полей бывает то одним, то другим, для этого использовались union.
[20:48.800 --> 20:52.800]  Я вам сейчас покажу...
[20:52.800 --> 20:53.800]  Сейчас, можно вопрос?
[20:53.800 --> 20:54.800]  Ну?
[20:54.800 --> 21:01.800]  Как у нас вообще может быть что-то нетривеленное в деструкторе, если это зависит от того, в какой поле активно?
[21:01.800 --> 21:02.800]  Кто может?
[21:02.800 --> 21:05.800]  Ну, вот вне у.
[21:05.800 --> 21:06.800]  Тильда у.
[21:06.800 --> 21:07.800]  Да.
[21:07.800 --> 21:12.800]  Ну, он не генерирует никакой деструктор, ты сам должен написать.
[21:12.800 --> 21:21.800]  Ну, я не знаю, ну, напиши что, ну, хорошо, не можете, можете написать, можете не написать.
[21:21.800 --> 21:31.800]  Нет, у тебя могут быть какие-то другие знания, у тебя может быть какие-то там данные, исходя из которых ты понимаешь, что сейчас нужно уничтожить, что не нужно уничтожать.
[21:31.800 --> 21:35.800]  Компилятор за тебя, конечно же, этого не знает.
[21:36.800 --> 21:40.800]  Давайте все, пожалуйста, остальное в перерыве, иначе мы не продвинемся.
[21:40.800 --> 21:42.800]  Простите.
[21:42.800 --> 21:46.800]  Пойдем дальше.
[21:46.800 --> 21:55.800]  Так вот, у нас есть, значит, ну, вот тут описано, как начинается и заканчивается время жизни членов, есть анонимные юнионы.
[21:55.800 --> 21:59.800]  Это прекрасная вещь.
[21:59.800 --> 22:00.800]  Для чего это надо?
[22:00.800 --> 22:01.800]  Для чего это надо?
[22:01.800 --> 22:04.800]  Ну, это надо...
[22:04.800 --> 22:08.800]  Смотрите, да, вот есть такая штука еще.
[22:08.800 --> 22:24.800]  Когда вы хотите на стеке положить либо инк, либо какую-то сейчас звездочку, то есть вы как бы в область видимости локальную внесли сразу и а, и п, но они на одном и том же адресе оказались.
[22:24.800 --> 22:26.800]  Вот.
[22:26.800 --> 22:28.800]  Это вот так можно использовать.
[22:28.800 --> 22:30.800]  А зачем бы так нужно делать?
[22:30.800 --> 22:33.800]  А почему здесь нет такой проблемы, что мы присваиваем?
[22:33.800 --> 22:36.800]  Потому что здесь тривиальные поля.
[22:36.800 --> 22:38.800]  Здесь конс, чай, звездочка.
[22:38.800 --> 22:43.800]  Нету никаких объектов в полях.
[22:43.800 --> 22:46.800]  Вот, ну вот, вот паттерн, о котором я говорил.
[22:46.800 --> 22:57.800]  TaggedUnion, то есть у меня структура, в которой есть ену, ну, маленькая чиселка, которая говорит, что сейчас лежит, а дальше юнион, в котором что-то лежит.
[22:57.800 --> 23:06.800]  И таким образом мы можем на одной и той же памяти хранить что-то из трех и, глядя на первый там битик, допустим, нашей структуры, смотреть, что там лежит.
[23:06.800 --> 23:07.800]  Как-то понимать.
[23:07.800 --> 23:08.800]  Например, вот так.
[23:08.800 --> 23:12.800]  Это, конечно, довольно уродская конструкция, но вот как есть.
[23:12.800 --> 23:22.800]  А сейчас я вам покажу одну...
[23:22.800 --> 23:29.800]  Сейчас я вам, в общем, как сказать?
[23:29.800 --> 23:36.800]  Я подниму на новый уровень ваше представление о базовых вещах, так сказать.
[23:36.800 --> 23:39.800]  Вы хорошо знаете, как устроен класс StdString?
[23:39.800 --> 23:41.800]  Вы его в первом семестре реализовывали?
[23:41.800 --> 23:42.800]  Нет.
[23:42.800 --> 23:44.800]  Там была пометка, что это очень непрощенно.
[23:44.800 --> 23:45.800]  А вот и нет.
[23:45.800 --> 23:50.800]  Вот на самом деле в классе String используются юнионы.
[23:50.800 --> 23:51.800]  Да.
[23:51.800 --> 23:53.800]  Отгадайте, зачем.
[23:53.800 --> 23:55.800]  Вот я сейчас я открою...
[23:55.800 --> 24:00.800]  Я сейчас на ваших глазах открою код Basic String, и мы там найдем слово Union в коде.
[24:00.800 --> 24:02.800]  Зачем оно там?
[24:02.800 --> 24:08.800]  Возможно, смысл в том, чтобы, типа, когда мы строковый ветерал, от него, допустим, конструируемся...
[24:08.800 --> 24:09.800]  Так.
[24:09.800 --> 24:11.800]  ...конструировать его, а просто условно сохранить, что...
[24:11.800 --> 24:16.800]  Ну вот есть этот строковый ветерал, тогда мы знаем, что он в тексте хранится и никогда не поменяется.
[24:16.800 --> 24:17.800]  Э-э-э...
[24:17.800 --> 24:18.800]  Нет, это не так.
[24:18.800 --> 24:19.800]  Так не работает.
[24:20.800 --> 24:22.800]  Ну, то, что ты называешь...
[24:22.800 --> 24:26.800]  То, что ты говоришь, это называется, скорее, оптимизацией Copy on Write.
[24:26.800 --> 24:29.800]  Типа, не копировать, пока нас не попросили изменить.
[24:29.800 --> 24:30.800]  Вот.
[24:30.800 --> 24:36.800]  Ну, тебе же, если я попрошу квадратными скобочками что-то присвоить, то мне придется копию создать.
[24:36.800 --> 24:45.800]  То есть, получается, что обращение квадратными скобочками присваивания по индексу иногда будет занимать линейное время в твоей реализации.
[24:45.800 --> 24:46.800]  Так не пойдет.
[24:46.800 --> 24:48.800]  Но так некоторые строки реализованы.
[24:48.800 --> 24:51.800]  Одна из возможных оптимизаций реализации строка называется Copy on Write Optimization.
[24:51.800 --> 24:53.800]  Cal Optimization.
[24:53.800 --> 24:55.800]  C-O-W.
[24:55.800 --> 24:57.800]  Кстати, очень полезная штука.
[24:57.800 --> 24:59.800]  Тоже на собеседованиях можно выпендриваться этим знанием.
[24:59.800 --> 25:00.800]  Но...
[25:00.800 --> 25:06.800]  А если мы в конец стринк операционства будем передаем строковый ветерал, там может как-то отмениваться?
[25:06.800 --> 25:09.800]  Господа, подсказка...
[25:09.800 --> 25:11.800]  Подсказка написана в названии параграфа.
[25:11.800 --> 25:12.800]  Вот, смотрите.
[25:12.800 --> 25:14.800]  Кто слышал когда-нибудь такой термин?
[25:14.800 --> 25:16.800]  Small Strings Optimization.
[25:16.800 --> 25:18.800]  А если у нас очень маленькая строка...
[25:18.800 --> 25:20.800]  Если у нас строка очень маленькая,
[25:20.800 --> 25:22.800]  нафига под нее динамическую память выделять?
[25:22.800 --> 25:24.800]  Если у нас строка, например, длины 3,
[25:24.800 --> 25:30.800]  то она уместится на те 8 байт, на которые мы обычно указатель кладем.
[25:30.800 --> 25:31.800]  Чего?
[25:31.800 --> 25:33.800]  Ну что, это сильно ускоряет?
[25:33.800 --> 25:35.800]  Конечно.
[25:35.800 --> 25:37.800]  Конечно, это сильно ускоряет.
[25:37.800 --> 25:42.800]  Если у вас маленькие строки, то под них не надо выделять динамическую память.
[25:42.800 --> 25:44.800]  Боже...
[25:44.800 --> 25:46.800]  И вы не смейтесь.
[25:46.800 --> 25:48.800]  Вам это сейчас кажется извращенным,
[25:48.800 --> 25:51.800]  но это как раз очень и очень правильно.
[25:51.800 --> 25:54.800]  Это так все нормальные строки реализованы.
[25:54.800 --> 25:57.800]  Вот, наоборот, строка, которая так не реализована,
[25:57.800 --> 25:59.800]  плоха очень.
[25:59.800 --> 26:00.800]  А?
[26:00.800 --> 26:04.800]  Когда-то раньше ты нам говорил, что есть еще указательные члены в строках.
[26:04.800 --> 26:06.800]  Нет, указательные члены...
[26:06.800 --> 26:08.800]  А, что одно из полей строка...
[26:08.800 --> 26:09.800]  Да.
[26:09.800 --> 26:10.800]  Да, да, да, да.
[26:10.800 --> 26:13.800]  Ты проховал, да, ты проховал жизнь.
[26:13.800 --> 26:15.800]  Сейчас, сейчас до этого дойдем.
[26:15.800 --> 26:17.800]  А можно мне тоже?
[26:19.800 --> 26:21.800]  Сейчас, я говорю, сейчас до этого дойдем.
[26:21.800 --> 26:24.800]  Я сначала вам покажу, что в строке реально написано.
[26:25.800 --> 26:26.800]  Тихо.
[26:26.800 --> 26:31.800]  Давайте я просто сейчас воспользуюсь магией,
[26:31.800 --> 26:36.800]  Господи, которая мне позволяет мой новый чудо Vim,
[26:36.800 --> 26:39.800]  и открою код Basic String.
[26:39.800 --> 26:40.800]  Вот.
[26:40.800 --> 26:45.800]  И тут я найду слово Union.
[26:50.800 --> 26:53.800]  Я, к сожалению, не помню, как между вкладками Vim переключаться.
[26:54.800 --> 26:57.800]  Control-V и вниз или вверх.
[26:57.800 --> 26:58.800]  Control-V...
[26:58.800 --> 26:59.800]  Что?
[26:59.800 --> 27:00.800]  Control-V?
[27:00.800 --> 27:01.800]  Control-V.
[27:01.800 --> 27:02.800]  Control-V.
[27:02.800 --> 27:04.800]  Control-W.
[27:04.800 --> 27:06.800]  Control-W.
[27:06.800 --> 27:07.800]  Control-W.
[27:07.800 --> 27:08.800]  И J.
[27:08.800 --> 27:10.800]  И ну туда-сюда, вверх-вниз.
[27:10.800 --> 27:11.800]  Сейчас J-T.
[27:11.800 --> 27:12.800]  О, отлично.
[27:12.800 --> 27:16.800]  Я сейчас выйду отсюда и останусь вот здесь.
[27:16.800 --> 27:17.800]  Спасибо.
[27:18.800 --> 27:22.800]  Мы оказались с вами в коде STD String.
[27:22.800 --> 27:23.800]  Наконец-то.
[27:23.800 --> 27:25.800]  Смотрите, что тут написано.
[27:25.800 --> 27:26.800]  Это...
[27:26.800 --> 27:27.800]  Это...
[27:28.800 --> 27:32.800]  Да, ну, во-первых, тут есть замечательная структурка ElogHider.
[27:32.800 --> 27:35.800]  Вы уже догадываетесь, зачем она нужна.
[27:36.800 --> 27:38.800]  Это MTBase Optimization.
[27:41.800 --> 27:45.800]  Здесь есть структурка ElogHider, которая наследуется от Allocator.
[27:45.800 --> 27:47.800]  И в ней хранится Pointer.
[27:48.800 --> 27:49.800]  Значит...
[27:49.800 --> 27:51.800]  Блин, тудуховы стояли в ском-коде, это смешно.
[27:51.800 --> 27:52.800]  Итак.
[27:52.800 --> 27:54.800]  Да нет, их там полно.
[27:54.800 --> 28:00.800]  У нас есть ElogHider, mdata+, а еще size-t string-length.
[28:01.800 --> 28:04.800]  А дальше у нас лежит следующая штука.
[28:04.800 --> 28:12.800]  Union из local-buffer размера local-capacity-plus-1, а также size-t-capacity.
[28:12.800 --> 28:14.800]  То есть, у нас на одном и том же адресе...
[28:14.800 --> 28:16.800]  Это анонимный Union.
[28:16.800 --> 28:22.800]  То есть, у нас на одном и том же адресе лежит size-t cap, то самое вот это capacity.
[28:22.800 --> 28:23.800]  Господи, где мы?
[28:23.800 --> 28:25.800]  А, ну, потому что нам реально capacity не нужно.
[28:25.800 --> 28:26.800]  Да.
[28:26.800 --> 28:33.800]  У нас на одном и том же адресе лежит число capacity, то что у нас называлось cap,
[28:33.800 --> 28:41.800]  и массив local-buff размера local-capacity-plus-1.
[28:41.800 --> 28:42.800]  Вот.
[28:42.800 --> 28:50.800]  И как работает, значит, например, обращение по индексу.
[28:50.800 --> 28:52.800]  Давайте я найду оператор.
[28:53.800 --> 28:55.800]  Квадратные скобочки.
[28:57.800 --> 29:02.800]  Return mData, круглые скобочки, по индексу pos.
[29:02.800 --> 29:04.800]  А что такое mData?
[29:05.800 --> 29:07.800]  А эта функция такая.
[29:08.800 --> 29:10.800]  Ой, не сработало.
[29:10.800 --> 29:12.800]  Ладно.
[29:12.800 --> 29:14.800]  Так, а чего?
[29:14.800 --> 29:16.800]  Что-то мне не находишь определение.
[29:16.800 --> 29:18.800]  А, вот, наверное, вот оно.
[29:18.800 --> 29:21.800]  Return mData-plus-mp.
[29:21.800 --> 29:27.800]  А, что такое mData-plus, давайте вспомним?
[29:27.800 --> 29:30.800]  Это pointer-mp.
[29:30.800 --> 29:32.800]  Короче, что такое data-plus?
[29:32.800 --> 29:42.800]  Это pointer в data-plus лежит, вот этот pointer, он указывает либо на вот этот local-buff,
[29:42.800 --> 29:44.800]  либо куда-то вовне.
[29:45.800 --> 29:47.800]  Значит, как он проверяет?
[29:48.800 --> 29:50.800]  Ну, то есть, понятная идея, у вас что должно быть?
[29:50.800 --> 29:52.800]  У вас есть поле size.
[29:53.800 --> 29:55.800]  У вас есть поле size, которое хранит размер строки.
[29:56.800 --> 29:58.800]  И еще есть у вас pointer.
[29:58.800 --> 30:00.800]  А также у вас есть поле capacity.
[30:02.800 --> 30:12.800]  Так вот, если ваш размер меньше, чем то, что вы можете вместить в size-of-size-t,
[30:12.800 --> 30:15.800]  то вам незачем выделять динамическую память.
[30:15.800 --> 30:19.800]  Вам можно на тех битах, на которых вы храните capacity, хранить саму строку,
[30:19.800 --> 30:22.800]  а pointer будет указывать вот именно на это место.
[30:22.800 --> 30:28.800]  То есть, ваш pointer указывает на то самое поле, на другое поле вас же.
[30:28.800 --> 30:34.800]  А capacity тут написано 15 делить на size-of-charter.
[30:34.800 --> 30:38.800]  Почему 15? Потому что... Почему, кстати, 15?
[30:38.800 --> 30:49.800]  Ну да, потому что там еще на trailing 0, значит, сколько-то выделено.
[30:56.800 --> 30:58.800]  Смотри, у тебя есть...
[30:58.800 --> 31:00.800]  Я кто-то писал?
[31:00.800 --> 31:06.800]  У тебя есть size-t, size, у тебя есть size-t-s-s.
[31:06.800 --> 31:10.800]  Вот размер строки ты всегда знаешь, ты его ничем не переписываешь.
[31:10.800 --> 31:22.800]  У тебя есть charge-звездочка-ptr и union, где лежит либо size-t-cap,
[31:24.800 --> 31:31.800]  либо charge-buffer размера, ну сколько-то там, 8.
[31:32.800 --> 31:43.800]  И вот этот... Ты смотришь на size-e и понимаешь, если твой size-e меньше, чем вот этот размер буфера локального,
[31:43.800 --> 31:49.800]  то pointer у тебя просто указывает вот на это место, то есть на твое же другое поле.
[31:49.800 --> 31:55.800]  А если size-e больше, то ты понимаешь, что ты находишься в другой ситуации,
[31:55.800 --> 32:01.800]  и по этим bit-ам у тебя лежит число capacity, а не строка, а строка лежит там, где я pointer указываю.
[32:01.800 --> 32:05.800]  Понятно? Это называется small strings optimization.
[32:05.800 --> 32:09.800]  И это, на самом деле, очень распространенная оптимизация, так устроены...
[32:09.800 --> 32:14.800]  Ну, все нормальные строки, короче, так устроены, иначе это очень эффективные строки.
[32:14.800 --> 32:17.800]  Та строка, которую вы писали в первом семестре, была отвратительной.
[32:17.800 --> 32:21.800]  Вот вопрос. Все строки, какие есть?
[32:21.800 --> 32:27.800]  Ну все адекватные строки. Ну и, господи, открой любой большой проект.
[32:27.800 --> 32:33.800]  Яндекс, Google, там, не знаю, кто угодно, VK, что угодно, Telegram, там ты найдешь кучу реализации класса string.
[32:33.800 --> 32:36.800]  Не знаю, qt, мне нравится qstring, например.
[32:36.800 --> 32:40.800]  Ну, типа, ну каждый просто реализует строку кто во что гора.
[32:40.800 --> 32:44.800]  Стандартная строка многих не устраивает, кто-то там хочет ее как-то заоптимизировать еще.
[32:45.800 --> 32:48.800]  Ну, короче, не важно.
[32:48.800 --> 32:51.800]  Честно, он же, кажется, не может по размеру узнавать в каком сейчас состоянии, если...
[32:51.800 --> 32:54.800]  Может он по размеру узнавать в каком состоянии.
[32:54.800 --> 32:56.800]  Мы же можем попбэкать эти строки, да, или как?
[32:56.800 --> 32:58.800]  Ну, как только вы попбэкаете, вы переходите в ста...
[32:58.800 --> 33:02.800]  Если вы понимаете, что превзошли размер, то все, вы выделяете домическую память.
[33:02.800 --> 33:05.800]  Нет, в смысле, это есть ужбэк, а есть попбэк.
[33:05.800 --> 33:08.800]  Мы уменьшили размер, да, размера маленькой строки.
[33:08.800 --> 33:11.800]  Значит, если вы сделали попбэк, ну он должен это поддержать.
[33:11.800 --> 33:13.800]  Значит, если вы сделали...
[33:16.800 --> 33:17.800]  Да, если...
[33:17.800 --> 33:20.800]  Да, если вы сделали попбэк, у вас размер уменьшился, но, видимо, он должен переложить.
[33:20.800 --> 33:23.800]  Ну, то есть, по СЗ он должен как-то это понимать.
[33:27.800 --> 33:29.800]  То есть, да, кстати, на размере 8...
[33:29.800 --> 33:31.800]  Сука, там 16.
[33:31.800 --> 33:35.800]  Если мы делаем попбэк, пушбэк, попбэк, пушбэк, то он перекладывает каждый раз?
[33:36.800 --> 33:37.800]  Ну да.
[33:39.800 --> 33:42.800]  Я понимаю, почему многих не устраивает стандартная строка.
[33:42.800 --> 33:45.800]  Я, кстати, не знаю, это хороший вопрос, можно посмотреть, что он делает.
[33:45.800 --> 33:48.800]  В смысле, ты так будешь делать в нормальном ходе?
[33:48.800 --> 33:49.800]  Это работает за от 80.
[33:51.800 --> 33:52.800]  Так, господа.
[33:52.800 --> 33:53.800]  Спасибо.
[33:53.800 --> 33:56.800]  Да, ну еще тут аллок-хайдер, но аллок-хайдер понятно зачем.
[33:56.800 --> 33:58.800]  Так, господа, господа, господа.
[33:58.800 --> 34:04.800]  Теперь, вот, значит, господин Андрусов, да, прохавал жизнь.
[34:04.800 --> 34:06.800]  Сейчас вы это тоже прохаваете.
[34:08.800 --> 34:12.800]  Помните, мы с вами, я вскользь упоминал в очередной раз про пушбэк.
[34:13.800 --> 34:15.800]  В очередной раз наши бараны про пушбэк.
[34:15.800 --> 34:18.800]  Я говорил, помните, мы когда в пушбэке делали мем CPI?
[34:18.800 --> 34:20.800]  Я говорил, нельзя делать мем CPI.
[34:20.800 --> 34:23.800]  Это уже для СТ стринга работать не будет.
[34:23.800 --> 34:25.800]  Так вот, поэтому и не будет.
[34:26.800 --> 34:31.800]  У вас стринг является типом, у которого одно из полей может быть поинтером на другое поле?
[34:34.800 --> 34:40.800]  Поэтому, если вы строки копируете мем CPI-м, STD-шные, у вас уже УБ.
[34:42.800 --> 34:44.800]  Ой, понятно?
[34:44.800 --> 34:50.800]  То есть, строка, STD-шная строка, самая что ни на есть обычная STD-шная строка.
[34:50.800 --> 34:56.800]  Так устроено, что одно из ее полей является, вообще говоря, поинтером на другое ее же поле.
[34:56.800 --> 35:00.800]  И если вы такую строку мем CPI-м будете копировать, у вас УБ.
[35:00.800 --> 35:02.800]  И настоящий самый УБ, вы сломаете все.
[35:04.800 --> 35:05.800]  Такие дела.
[35:05.800 --> 35:09.800]  То есть, стринг является как раз примером такого самого типа, который...
[35:09.800 --> 35:14.800]  Ну и любой тип, у которого small object optimization, является примером такого типа.
[35:15.800 --> 35:19.800]  Вот это то, что я хотел вам рассказать про union и про small object optimization.
[35:20.800 --> 35:22.800]  Вот.
[35:22.800 --> 35:32.800]  А теперь мы с вами поговорим о том, как реализовать STD-фанкшн.
[35:35.800 --> 35:37.800]  Это то, что я вам обещал в прошлый раз.
[35:37.800 --> 35:39.800]  Помните такой тип STD-фанкшн?
[35:47.800 --> 35:48.800]  Вот.
[35:48.800 --> 35:50.800]  Теперь мы сможем наконец реализовать его полноценно.
[35:50.800 --> 35:51.800]  Да.
[35:51.800 --> 35:55.800]  Ну, я говорил, что вообще реализовать STD-фанкшн – это хорошая задача содержательная.
[35:55.800 --> 35:58.800]  Но вам и так задач хватает, поэтому не будем.
[35:59.800 --> 36:00.800]  Ладно.
[36:00.800 --> 36:01.800]  Смотрите.
[36:01.800 --> 36:02.800]  Вот.
[36:02.800 --> 36:03.800]  Вот.
[36:03.800 --> 36:04.800]  Вот.
[36:04.800 --> 36:05.800]  Вот.
[36:05.800 --> 36:06.800]  Вот.
[36:06.800 --> 36:07.800]  Вот.
[36:07.800 --> 36:08.800]  Вот.
[36:08.800 --> 36:09.800]  Вот.
[36:09.800 --> 36:10.800]  Вот.
[36:10.800 --> 36:11.800]  Вот.
[36:11.800 --> 36:12.800]  Вот.
[36:12.800 --> 36:13.800]  Вот.
[36:13.800 --> 36:14.800]  Вот.
[36:14.800 --> 36:15.800]  Вот.
[36:15.800 --> 36:16.800]  Вот.
[36:16.800 --> 36:17.800]  Вот.
[36:17.800 --> 36:18.800]  Вот.
[36:19.800 --> 36:20.800]  Ладно.
[36:20.800 --> 36:21.800]  Спасибо.
[36:21.800 --> 36:23.800]  STD-фанкшн.
[36:23.800 --> 36:25.920]  Напоминаю, это тип, который может хранить себе любой
[36:25.920 --> 36:29.800]  callable-объект и подменять его один на другой в рантайме.
[36:48.800 --> 36:58.800]  Я просто ржу, что мы в четвером отновременно этим занимаемся.
[36:58.800 --> 36:59.800]  Так.
[36:59.800 --> 37:00.800]  Значит.
[37:00.800 --> 37:03.800]  Во-первых.
[37:03.800 --> 37:26.800]  Если моя фанкшн использована не с теми шаблонными параметрами,
[37:27.800 --> 37:42.800]  Рабочая является только специализацией STD-фанкшн от таких
[37:42.800 --> 37:43.800]  параметров.
[37:43.800 --> 37:44.800]  Так.
[37:44.800 --> 37:45.800]  Резулт.
[37:45.800 --> 37:46.800]  Да.
[37:46.800 --> 37:47.800]  Класс.
[37:47.800 --> 37:48.800]  Резулт.
[37:48.800 --> 37:49.800]  Значит.
[37:49.800 --> 37:50.800]  Да.
[37:50.800 --> 37:51.800]  Вот.
[37:51.800 --> 37:52.800]  Если фанкшн.
[37:52.800 --> 38:16.800]  С любыми параметрами, с которыми нас устраивают,
[38:16.800 --> 38:17.800]  то это CE.
[38:17.800 --> 38:21.800]  Фанкшн только вот от такого шаблонного параметра
[38:21.800 --> 38:24.800]  это не CE.
[38:24.800 --> 38:29.800]  Просто это мы оставим без реализации, и все.
[38:29.800 --> 38:30.800]  Хорошо.
[38:30.800 --> 38:31.800]  Сейчас.
[38:31.800 --> 38:33.800]  Шаблонный параметр это что?
[38:33.800 --> 38:35.800]  Это функция ResultAttacks.
[38:35.800 --> 38:36.800]  Ну.
[38:36.800 --> 38:37.800]  Сейчас.
[38:37.800 --> 38:42.800]  Мы обсуждали фанкшн, и в прошлый раз тебя не было,
[38:42.800 --> 38:43.800]  кажется.
[38:43.800 --> 38:44.800]  Поэтому сорян.
[38:44.800 --> 38:50.800]  Давайте подумаем, какие поля.
[38:50.800 --> 38:52.800]  Ну кто помнит TypeRage, о чем мы должны хранить.
[38:52.800 --> 39:02.800]  Не, ну давайте нормально.
[39:02.800 --> 39:08.800]  Мы уже реализовывали похожие вещи.
[39:08.800 --> 39:10.800]  Сначала мы реализуем как умеем.
[39:10.800 --> 39:12.800]  Значит у нас будет template.
[39:12.800 --> 39:16.800]  У нас будет базовый класс.
[39:16.800 --> 39:20.800]  Ну он будет.
[39:20.800 --> 39:22.800]  Будет ли он шаблонным?
[39:22.800 --> 39:23.800]  Хороший вопрос.
[39:23.800 --> 39:26.800]  А зачем базовый шаблонный делать?
[39:26.800 --> 39:28.800]  Наверное не будет, да.
[39:28.800 --> 39:33.800]  StructBase, в которое будет virtual.
[39:33.800 --> 39:34.800]  Base.
[39:34.800 --> 39:40.800]  Ну давайте я все-таки назову не Base, а BaseFunktor.
[39:40.800 --> 39:45.800]  BaseFunktor равно Default.
[39:45.800 --> 39:51.800]  Ну нам еще что-то потребуется, но пока отложим этот вопрос.
[39:51.800 --> 39:52.800]  Вот.
[39:52.800 --> 39:54.800]  И теперь у нас будет template.
[39:54.800 --> 39:56.800]  Шаблонный класс.
[39:56.800 --> 39:57.800]  Derived.
[39:57.800 --> 40:01.800]  С каким шаблонным параметром?
[40:01.800 --> 40:08.800]  Наверное с шаблонным параметром Funktor.
[40:08.800 --> 40:13.800]  Давайте скажу с шаблонным параметром F.
[40:13.800 --> 40:16.800]  StructDerived.
[40:16.800 --> 40:19.800]  Funktor.
[40:19.800 --> 40:23.800]  Это наследник BaseFunktor.
[40:23.800 --> 40:24.800]  Вот.
[40:24.800 --> 40:30.800]  И в нем будет лежать F.
[40:30.800 --> 40:31.800]  Правильно.
[40:31.800 --> 40:33.800]  Ну классический type arranger.
[40:33.800 --> 40:34.800]  Да?
[40:34.800 --> 40:36.800]  Что мы будем хранить в полях?
[40:36.800 --> 40:45.800]  В полях мы будем хранить указатель на BaseFunktor.
[40:45.800 --> 40:48.800]  FPTR.
[40:48.800 --> 40:49.800]  Вот.
[40:49.800 --> 40:54.800]  Как будет устроено наше все.
[40:54.800 --> 40:56.800]  Что мы должны делать?
[40:56.800 --> 40:58.800]  Я пока даже ничего нового.
[40:58.800 --> 41:01.800]  Все это мы в прошлый раз обсуждали.
[41:01.800 --> 41:07.800]  Я пока никаких новых идей не добавляю к тому, что мы в прошлый раз обсуждали.
[41:07.800 --> 41:09.800]  Ну давайте напишем что-нибудь.
[41:09.800 --> 41:13.800]  Давайте напишем например конструктор.
[41:13.800 --> 41:14.800]  Ну да.
[41:14.800 --> 41:21.800]  Вот здесь какие должны быть методы.
[41:21.800 --> 41:23.800]  Самое главное, что должно быть у нашего функтора?
[41:23.800 --> 41:25.800]  Оператор круглые скобочки.
[41:25.800 --> 41:31.800]  Ну это значит что у BaseFunkтора должны быть круглые скобочки виртуальные тоже.
[41:31.800 --> 41:33.800]  Virtual.
[41:33.800 --> 41:35.800]  Дальше что?
[41:35.800 --> 41:37.800]  Какой тип?
[41:37.800 --> 41:39.800]  Возвращаемый.
[41:39.800 --> 41:41.800]  Result.
[41:41.800 --> 41:44.800]  Оператор круглые скобочки.
[41:44.800 --> 41:49.800]  От каких аргументов?
[41:49.800 --> 41:52.800]  По какой ссылке нужно принимать ARKS?
[41:52.800 --> 41:54.800]  По универсальной ссылке.
[41:54.800 --> 41:58.800]  Только она должна быть параметром самого...
[41:58.800 --> 42:00.800]  Да, это отличное замечание.
[42:00.800 --> 42:04.800]  Но...
[42:04.800 --> 42:10.800]  Кстати вот с этим проблемком.
[42:10.800 --> 42:14.800]  Потому что...
[42:14.800 --> 42:18.800]  Нам очень хочется форму использовать, да?
[42:18.800 --> 42:20.800]  Ну нам конечно хочется использовать форму.
[42:20.800 --> 42:24.800]  Ладно, давайте отложим этот вопрос в какой-то сложный вопрос, что-то я над ним не подумал.
[42:24.800 --> 42:26.800]  Давайте пока так делать.
[42:26.800 --> 42:28.800]  Нет, это как-то ужасно.
[42:28.800 --> 42:32.800]  Сейчас.
[42:32.800 --> 42:36.800]  Что будет, если я...
[42:36.800 --> 42:38.800]  Сюда присоединяюсь?
[42:38.800 --> 42:40.800]  Нет.
[42:40.800 --> 42:42.800]  Нет.
[42:42.800 --> 42:44.800]  Нет.
[42:44.800 --> 42:46.800]  Нет.
[42:46.800 --> 42:48.800]  Нет.
[42:48.800 --> 42:52.800]  Сюда приму параметры по...
[42:52.800 --> 42:56.800]  По какой ссылке?
[42:56.800 --> 43:00.800]  Да, это какая-то неловкая ситуация, слушайте.
[43:00.800 --> 43:06.800]  Ладно, мы эту проблему все равно решим сегодня.
[43:06.800 --> 43:10.800]  И...
[43:10.800 --> 43:12.800]  Значит...
[43:12.800 --> 43:14.800]  Давайте пока оставим.
[43:14.800 --> 43:16.800]  Равно нулю.
[43:16.800 --> 43:18.800]  To do.
[43:18.800 --> 43:22.800]  Forwarding reference.
[43:22.800 --> 43:26.800]  Вы понимаете проблему?
[43:26.800 --> 43:28.800]  Мы не хотим копировать то, что можно можно.
[43:28.800 --> 43:30.800]  Да, а проблема, почему я не могу написать тимплейт?
[43:30.800 --> 43:32.800]  Ну, если я напишу тимплейт, вот это вот.
[43:32.800 --> 43:36.800]  Virtual result operator круглой скобочки.
[43:36.800 --> 43:42.800]  Что вообще значит, что виртуальный метод является шаблонным?
[43:42.800 --> 43:44.800]  То есть компилятор должен...
[43:44.800 --> 43:48.800]  Ну, это причем еще pure virtual метод, являющийся шаблоном.
[43:48.800 --> 43:50.800]  То есть, по сути, каждый из наших игр должен объявлять
[43:50.800 --> 43:52.800]  какой же шаблон, где идет себя конструктор.
[43:52.800 --> 43:54.800]  Все, которые мы вызываем, в принципе.
[43:54.800 --> 43:56.800]  Да.
[43:56.800 --> 44:00.800]  Ну, хотя он вообще может, когда-нибудь определяйте.
[44:00.800 --> 44:02.800]  Сейчас, я что-то туплю.
[44:02.800 --> 44:06.800]  Может, это и будет работать?
[44:06.800 --> 44:10.800]  Нет, кажется прям явных проблем.
[44:10.800 --> 44:12.800]  Если я сделаю...
[44:12.800 --> 44:16.800]  Давайте, господи, давайте я попробую.
[44:16.800 --> 44:26.800]  Template type name многоточие new arcs.
[44:26.800 --> 44:30.800]  И вот здесь напишу new arcs.
[44:30.800 --> 44:34.800]  И попробую это скомпилировать.
[44:34.800 --> 44:36.800]  Ну, вот.
[44:36.800 --> 44:38.800]  В общем.
[44:38.800 --> 44:40.800]  Можно и не гадать.
[44:40.800 --> 44:46.800]  Не могут функции члены быть шаблонными.
[44:46.800 --> 44:48.800]  Виртуальные.
[44:48.800 --> 44:50.800]  Короче, эту проблему нам придется пока оставить.
[44:50.800 --> 44:52.800]  Но он просто не сможет.
[44:52.800 --> 44:54.800]  Это несочетаемые вещи.
[44:54.800 --> 44:58.800]  Ему надо, с одной стороны, в compile-time-е знать,
[44:58.800 --> 45:00.800]  все типы, с которыми он вызывается.
[45:00.800 --> 45:02.800]  А с другой стороны, он виртуальный.
[45:02.800 --> 45:04.800]  Это значит, что он может вызываться с типом,
[45:04.800 --> 45:06.800]  не соответствующим реальному типу того,
[45:06.800 --> 45:08.800]  от чего его вызвали.
[45:08.800 --> 45:10.800]  Ему нужно в virtual table ходить.
[45:10.800 --> 45:12.800]  Ну, все нормально.
[45:12.800 --> 45:14.800]  Всем детям просто просчитываем эти вызовицы.
[45:14.800 --> 45:16.800]  В смысле.
[45:16.800 --> 45:18.800]  Потому что мы подставили всем детям этот аргумент.
[45:18.800 --> 45:20.800]  Ну, все нормально.
[45:20.800 --> 45:22.800]  Ну, все нормально.
[45:22.800 --> 45:24.800]  Ну, все нормально.
[45:24.800 --> 45:26.800]  Ну, все нормально.
[45:26.800 --> 45:28.800]  То есть объявляем этот аргумент.
[45:29.800 --> 45:31.800]  Теоретически это сочетаемый?
[45:31.800 --> 45:33.800]  Вопрос на сколько мы этого хотим просто.
[45:33.800 --> 45:35.640]  Ну, вот.
[45:35.640 --> 45:37.640]  Короче.
[45:37.640 --> 45:39.640]  Мне кажется, что там есть какая-то проблема.
[45:39.640 --> 45:42.140]  Не кажется, скорее всего, там есть
[45:42.140 --> 45:44.140]  проблема, которую я сейчас忘 heл.
[45:44.140 --> 45:46.140]  Почему это не получается сделать?
[45:46.140 --> 45:48.140]  Но короче, так или иначе,
[45:48.140 --> 45:50.480]  это ошибка в компиляции.
[45:50.480 --> 45:52.480]  Нам пока придется с этим жить.
[45:52.480 --> 45:57.560]  да ст функшен и вы от аркс двойной персант вызываетесь кстати давайте
[45:57.560 --> 46:07.120]  проверим это у нас вот как раз страничка заготовлена а функшен вот у
[46:07.120 --> 46:16.320]  меня есть оператор круглые скобочки и он ха смешно сильно
[46:22.480 --> 46:31.480]  это прям очень сильное утверждение а так подождите кажется это будет
[46:31.480 --> 46:36.040]  нормально работать если я передал по ссылке но это кстати кажется будет
[46:36.040 --> 46:39.560]  нормально работать как раз по той причине помните я говорил что есть такой тоже
[46:39.560 --> 46:44.920]  способ когда вы принимаете по значению если вам мунули то вы рвл ее отдадите а
[46:44.920 --> 46:53.600]  если вы лвл и ссылку отдали то значит скопируется да другой вопрос что вам
[46:53.600 --> 47:00.960]  придется именно явно отдавать лвл и ссылку туда потому что если вы отдадите
[47:00.960 --> 47:11.760]  просто что-то лвл и тип все равно выведется как а нет господи все все
[47:11.760 --> 47:17.440]  нормально мы мы все тупим аркса даже шаблонные параметры класса если у меня f
[47:17.440 --> 47:20.880]  от шаблонных если у меня функцион от шаблонных параметра допустим им персант
[47:20.880 --> 47:26.800]  им персант то аркста будет сам персантами и все нормально и форвэд их
[47:26.800 --> 47:31.640]  поразнёт правильно то есть у меня если я хочу ссылки принимать параметры
[47:31.640 --> 47:38.720]  функции то это уже закодировано в типе аркс поэтому мне не нужно указывать этот
[47:38.720 --> 47:51.560]  тип когда я вызываюсь этот аркс он уже в классе да смотрите еще раз я вот как
[47:51.560 --> 48:00.320]  пользуюсь этим я говорю int main и говорю там std function допустим я хочу чтобы она
[48:00.320 --> 48:16.200]  там void была от int амперсант int 2 амперсанда f вот эти аркс выведутся как
[48:16.200 --> 48:20.440]  int амперсант int 2 амперсанда у меня аркс будут сам персантами уже все они с
[48:20.440 --> 48:23.920]  амперсантами амперсант никуда не деваются теперь везде где я пишу аркс
[48:23.920 --> 48:28.800]  амперсанты сохраняются вывод типа в заново не происходит я явно указал типа
[48:28.800 --> 48:37.320]  когда класс объявлял конечно поэтому здесь все ссылки сохранятся поэтому аркс по значению но
[48:37.320 --> 48:41.840]  по факту аргументы при этом могут быть посылки и все нормально и форвард корректин в этой
[48:41.840 --> 48:48.640]  ситуации поэтому проблемы нет все проблема решена мы будем форвардить и все будет нормально
[48:48.640 --> 48:55.240]  работать потому что если там lvl и ссылка она форварднется правильно понятно кто понял
[48:55.240 --> 49:12.480]  давайте дальше ну пересмотрите давайте дальше давайте дальше значит result оператор круглой
[49:12.480 --> 49:22.680]  скобочки override что мы тут должны делать а оператор круглой скобочки от аркс
[49:22.680 --> 49:27.320]  аркс override что мы тут должны делать
[49:33.320 --> 49:38.160]  но вызвать f от аркс только астеса форвард от аркс
[49:38.160 --> 49:42.720]  правильно
[49:42.720 --> 49:56.960]  а я не там скобку закрыл так нормально все понятно
[49:56.960 --> 50:07.640]  кто успевает следить за происходящим кого смущает то что я написал до корректора
[50:08.640 --> 50:15.480]  да ретерн надо сделать конечно а если там void это нормально это он void
[50:15.480 --> 50:27.600]  кого смущает то что я написал никого не смущает все нормально вроде написал то так на самом деле
[50:27.600 --> 50:41.160]  здесь есть одна один косячок у нас f да хранится конечно как объект хранится
[50:41.160 --> 50:50.720]  f это может быть либо функциональный объект полноценный либо function pointer либо лямбда
[50:50.720 --> 50:58.800]  функция либо еще ну либо closure объект либо bind объект помните bind вот ну в общем да
[50:58.800 --> 51:10.560]  рво здесь здесь ну если я возвращает рвл ю то да конечно а если не рвл ю то ну если
[51:10.560 --> 51:19.680]  f возвращает пьюр рвл ю то да а если все остальное то нет какой рвл так еще вопросы
[51:19.680 --> 51:27.520]  давайте дальше диструктор а диструктор можно не писать потому что все и так корректно отработает
[51:27.520 --> 51:35.040]  правда же все давайте напишем конструктор function наконец function от чего но он шаблонный должен
[51:35.040 --> 51:44.000]  быть template type name functor function от чего
[51:44.000 --> 51:57.800]  ну я function могу сконструировать от любого объекта от любого коллабел объекта от любого
[51:57.800 --> 52:04.880]  коллабел объекта да значит f равно там не знаю круглые скобочки int x int y return x меньше y
[52:04.880 --> 52:19.000]  да ну это я показываю пример как я мог бы использовать function вот мне нужно сделать
[52:19.000 --> 52:27.080]  function конструктор от чего потому что он function не за inclusion вот по какой ссылке надо
[52:27.080 --> 52:35.680]  принять functor ну по идее нам нужно уметь и по рвл ю и по лвл ю ссылки принимать на самом деле
[52:35.680 --> 52:43.480]  здесь по универсальной можно принять вполне мы его форварднём но то есть нам надо вот этот
[52:43.480 --> 52:50.080]  functor положить как поле в класс derived functor мы его форварднём сейчас туда мы его мувнем либо
[52:50.080 --> 52:56.720]  скопируем в зависимости от того по какой ссылке приняли только нам надо стать и кассирт знаете
[52:56.720 --> 53:14.960]  какой стд из инвокабл да из инвокабл от f от functor с нашими аргументами ну
[53:14.960 --> 53:38.080]  ну можно и это проверить ну давайте это оставим ну потому что будет ошибка потому что ошибка
[53:38.080 --> 53:44.080]  будет во первых пока я не вызвал ее я должен не уметь создаваться с такими типами если я
[53:44.080 --> 53:52.520]  создался но ни разу не вызвал это у меня не упадет все равно нужно упасть но я не инстанцировал там
[53:52.520 --> 53:58.240]  этот ну хотя нет если я подставлю в derived functor ну да да да это все равно упадет согласен я же
[53:58.240 --> 54:04.420]  инстанцировал все равно но ошибка компиляции будет некрасивая лучше ловить таки но на самом
[54:04.420 --> 54:10.240]  деле спойлер мы с вами скоро пройдем ну как скоро достаточно скоро уже концепты и у нас
[54:10.240 --> 54:24.280]  будет вообще очень вообще 2 знака подчеркивания из инвокабл возможно потому что этот подсказчик
[54:24.280 --> 54:34.640]  не обладает и плюс 17 ну давайте я вам покажу из инвокабл значит есть такой type 3 и мы его
[54:34.640 --> 54:44.000]  конечно же тоже научимся реализовывать а вскоре нам уже нам уже это вот вот предстоит но это
[54:44.000 --> 54:52.560]  начинается плюс 17 метафункция которая проверяет правда ли функция ну правда ли этот класс вызываем
[54:52.560 --> 54:59.000]  колобл с такими параметрами вот тут тут есть много странных уточнений которые мы пока не будем
[54:59.000 --> 55:12.720]  обсуждать короче ладно а ну нету так нету такого type 3 ты не знаешь так не знаешь о нем как
[55:12.720 --> 55:25.680]  говорится что мы делаем мы должны про инициализировать что fptr new derived functor
[55:25.680 --> 55:44.040]  с шаблонным параметром functor от чего std forward от шаблонным параметром functor от functor
[55:44.040 --> 55:50.520]  а и тут мы понимаем что нам конструктора не хватает в этом классе давайте его напишем
[55:50.520 --> 56:10.840]  derived functor чего где фигурные скобки писать а зачем нам конструктор а нельзя фигурные скобки
[56:10.840 --> 56:21.680]  написать если ты хочешь чтобы я вот так сделал типа вот так кстати не знаю так я не там скобки
[56:21.680 --> 56:35.840]  поставил вот так не сделал а нет к сожалению так нельзя я думаю нельзя потому что виртуальные
[56:35.840 --> 56:40.840]  функции есть ну короче для структуру мне кажется для структуры с виртуальными функциями
[56:40.840 --> 56:47.560]  еще и шаблонных это уже не работает короче нет конструктор все-таки нужен давайте его напишем
[56:47.560 --> 57:05.200]  ну давайте напишем derived functor от а что мы тут можем написать а мы можем f просто
[57:05.200 --> 57:14.800]  принять по значению как раз и сделать f от std move от f правда мне кажется так будет работать
[57:14.800 --> 57:22.800]  ну то и ну я для краткости по-хорошему надо написать конструктор от const f амперсанта от f2
[57:22.800 --> 57:29.000]  амперсанта и в одном случае к этому другому но я могу так сказать почему это будет работать
[57:29.000 --> 57:36.600]  понимаете ну потому что если я форвард ну форвард сработал как муф я передал x value здесь
[57:36.600 --> 57:46.640]  я спронициализировал f от x value то есть муфнул уже и это f тоже муфнул но если я скопировал то
[57:46.640 --> 57:53.880]  все равно я один раз копирую когда передал сюда а здесь уже муфну то есть не покопирую
[57:53.960 --> 58:01.520]  в целом один лишний муф но да ну мы считаем что типа поддержит муф семантику короче понятно вот ну
[58:01.520 --> 58:08.680]  вот пожалуйста function минимальный реализа да но еще оператор круглой скобочки нужен давайте сделаем
[58:08.680 --> 58:20.600]  оператор круглой скобочки result оператор круглой скобочки от arcs многоточие arcs вопрос const или
[58:21.160 --> 58:38.040]  вот короче тут какая-то очень тонкая грань на самом деле это константный оператор так по
[58:38.040 --> 58:46.760]  стандарту сказано возможно это ошибка разработчиков стандарт ну короче круглой
[58:46.760 --> 58:52.680]  скобочки function это константный оператор просто если бы он был не константным то приняв
[58:52.680 --> 58:57.560]  function куда-либо по константной ссылке вы бы не могли его от него вызывать круглой скобочки это
[58:57.560 --> 59:11.000]  проблема а почему мы вообще можем не ходить в общем это константный оператор просто примите
[59:11.000 --> 59:17.200]  это что мы должны сделать мы же мы должны что и это все что мы требуем в константности
[59:17.200 --> 59:27.200]  ну фптр же мы не меняем никак не меняем да фптр мы не меняем это все что мы требуем когда
[59:27.200 --> 59:33.920]  навешиваем констант да ну все нормально да поэтому тут констант такое а о чем делаем
[59:33.920 --> 59:53.640]  return фптр оператор круглые скобочки под чего стд форвард от arcs от arcs многоточие точка
[59:53.640 --> 01:00:07.560]  запятой может это не ошибка ну это ну это не возможно нужно было сделать два оператора
[01:00:07.560 --> 01:00:14.640]  круглой скобочки один коз другой не конст зачем нам не константный ну просто в чем смысл
[01:00:15.640 --> 01:00:25.640]  почему она может быть не констант почему можем хотеть точнее не констант
[01:00:25.640 --> 01:00:37.360]  просто честно мне понятен смысл нет но вообще кажется что это странно что мы у
[01:00:37.360 --> 01:00:43.640]  него у нас константный пункшен мы вызываем константный метод что-то меняется под указателем
[01:00:44.200 --> 01:00:55.880]  слушайте я понимаю ну короче вот просто примите как факт это константный оператор можно
[01:00:55.880 --> 01:00:59.960]  философствовать на тему правильно это или неправильно идеологически ну короче это
[01:00:59.960 --> 01:01:03.520]  константный оператор для того чтобы по конст ссылке можно было функции куда-то
[01:01:03.520 --> 01:01:10.400]  передавать и там вызывать скобки хорошо этим тогда вообще отлично то есть все никаких вопросов
[01:01:10.400 --> 01:01:16.400]  у вас нет давайте дальше потому что нам самое интересное впереди на самом деле давайте
[01:01:16.400 --> 01:01:33.960]  диструктор быстренько напишем function диструктор что он делает delete fptr ну дальше надо написать
[01:01:33.960 --> 01:01:42.720]  конструктор копирования конструктор перемещения оператор копирующего присваивания оператор
[01:01:42.720 --> 01:01:58.320]  перемещающего присваивания но в общем да это не интересная часть давайте поговорим о некоторых
[01:01:58.320 --> 01:02:14.320]  так сказать как говорят на западе concerns вот у нас тут new не наводит ли это вас на мысль что
[01:02:14.320 --> 01:02:23.120]  нужно что-то еще добавить а локатор добавить да кажется я вам уже рассказывал про эту историю
[01:02:23.120 --> 01:02:34.040]  я вам рассказывал правда был раньше такой конструктор у function с нестандартным
[01:02:34.040 --> 01:02:42.760]  локатором он был начиная с до function появилась тоже c++ 11 но это мы уже обсуждали он был до
[01:02:42.760 --> 01:02:53.000]  c++ 17 помните почему нам говорил в общем комитет понял что перестарались они добавлять тела
[01:02:53.000 --> 01:02:59.120]  локаторы везде везде где ни попадя разработчики компилятор сказали шоке нет вы нет добавить
[01:02:59.120 --> 01:03:06.160]  локатор function как-нибудь потом в общем они так и не добавили нормально и короче это удалились
[01:03:06.160 --> 01:03:15.240]  стандартно просто ну короче не получилось function не поддерживает нестандартные локаторы
[01:03:16.240 --> 01:03:27.480]  потому что это была гиблая идея да да компилятор и ну потому что нам бы сейчас на один указатель
[01:03:27.480 --> 01:03:41.240]  нестандартный локатор держит вот другая проблема но давайте какие вы здесь видите проблемы какие два
[01:03:41.240 --> 01:04:00.160]  класса по другому ты не сможешь подменять на самом деле то о чем он говорит это правильно ты был
[01:04:00.160 --> 01:04:09.640]  в прошлый раз а тогда все понятно но мы в прошлый раз обсуждали ну блин плохо но надо ты упустил
[01:04:09.640 --> 01:04:20.640]  важную часть рассуждений ну я не выложили да видимо нам нужен type erasure потому что нам
[01:04:20.640 --> 01:04:24.740]  нужно как-то динамически подменять тип который у нас хранится и деструктор вызывать под
[01:04:24.740 --> 01:04:36.080]  правильного типа когда мы подменяем одно другим вот ну когда нам говорят function вот давайте
[01:04:36.080 --> 01:04:47.040]  я напишу function % оператор равно от const function other вот тут интересно потому что мне
[01:04:47.040 --> 01:05:01.680]  надо сделать delete fptr а потом сказать fptr равно new derived functor
[01:05:01.680 --> 01:05:14.720]  да ну много чего там еще но exception и проверить там и так далее но в общем new derived functor
[01:05:14.720 --> 01:05:30.520]  а шаблонным параметром кстати с каким шаблонным параметром нам надо other стрелочек
[01:05:30.520 --> 01:05:42.560]  outer.fptr getCopy помните да такое скорее всего так да ну вот у нас здесь еще должен быть метод сделай копию
[01:05:42.560 --> 01:05:53.200]  ладно что-то я это не хочу ну в общем короче вы помните про эту проблему но проблем пока
[01:05:53.200 --> 01:06:00.940]  проблем пока не в этом тут есть проблемы и посерьезней это не эффективно очень скажите
[01:06:00.940 --> 01:06:05.280]  пожалуйста вы часто в своей жизни встречали функции или функциональные объекты которые
[01:06:05.280 --> 01:06:17.680]  весят больше чем 8 байт большинство функции это либо просто поинтеры на самом деле либо лябды
[01:06:17.680 --> 01:06:22.880]  в которых либо ничего не захвачено либо ну максимум чиселка какая-нибудь захвачена или еще
[01:06:22.880 --> 01:06:29.840]  какой-нибудь поинтер но функции которые весят ну хорошо больше чем 16 байт очень мало а мы
[01:06:29.840 --> 01:06:36.120]  здесь выделяем динамическую память на каждую сущность то есть даже если я функции присваиваю
[01:06:36.120 --> 01:06:43.720]  обычный сишный поинтер я выделяю динамическую память здесь просто кричит просто вот просто
[01:06:43.720 --> 01:06:51.800]  просто красная лампочка мигает small objects optimization конечно же function обязательно нужно не выделять
[01:06:51.800 --> 01:06:56.080]  динамическую память если можно иначе будет совершенно никуда не годный класс его на помойку
[01:06:56.080 --> 01:07:01.840]  выкинуть сразу же никто не будет пользу такой функции вы хотите чтобы функция она не выделяла
[01:07:01.840 --> 01:07:08.920]  динамическую память на каждый значит на хранение 8 байтного поинтера то есть у вас функция хранит
[01:07:08.920 --> 01:07:14.760]  поинтер по которому лежит поинтер по которому лежит нет не так должно работать должен быть
[01:07:14.760 --> 01:07:30.520]  small objects optimization у меня должен быть здесь union конечно же он должен быть это логично но нафиг
[01:07:30.520 --> 01:07:44.000]  либо указатель на base functor либо массив чаров размера ну скажем 16 ну только elines ну тут
[01:07:44.000 --> 01:07:57.000]  нужно есть такой класс elines storage ну давайте я скажу elines std max elines t можно и так сказать
[01:07:57.000 --> 01:08:16.360]  чар кстати кажется это можно писать ладно чар размера ну 16 чар буф 16 локал буф
[01:08:16.360 --> 01:08:25.400]  вот непонятно что max elines t где лежит max elines t напомните пожалуйста
[01:08:25.520 --> 01:08:40.360]  почему ты скобку не закрыл как не закрыл а хорошо все остальное были мне понятно new может
[01:08:40.360 --> 01:08:48.040]  я уже пытался
[01:08:49.040 --> 01:09:03.280]  hunks max elines thanks
[01:09:03.280 --> 01:09:21.240]  Так вот, а как нам понимать, в какой из двух ситуаций
[01:09:21.240 --> 01:09:39.240]  Мы находимся по сайзов, увидимого
[01:09:39.240 --> 01:09:47.240]  Ну можно хранить булл, да, в принципе
[01:09:47.240 --> 01:09:50.240]  Вообще, кстати, кажется, это даже можно нигде не хранить
[01:09:50.240 --> 01:10:03.240]  Смотрите, правда ли, что когда мы создаёмся от функтора, мы же...
[01:10:03.240 --> 01:10:10.240]  А, нет, никак не проверять не получится, потому что мы...
[01:10:10.240 --> 01:10:16.240]  Мы должны проверить, понимать, мы в ситуации локал или нет
[01:10:16.240 --> 01:10:19.240]  Ну давайте, да, ну хорошо, давайте вот здесь поймём
[01:10:19.240 --> 01:10:21.240]  Вот смотрите, вот что я делаю здесь
[01:10:21.240 --> 01:10:28.240]  Я говорю, если... Тут мне уже придётся, видимо, в теле конструктора код писать
[01:10:28.240 --> 01:10:32.240]  Очень жаль
[01:10:32.240 --> 01:10:33.240]  Удалю это нафиг
[01:10:33.240 --> 01:10:40.240]  Если constexpr
[01:10:40.240 --> 01:10:56.240]  Ну давайте я напишу static const size t local boof size равно 16
[01:10:56.240 --> 01:11:03.240]  А зачем они быстрее для этого сделали непременную, а енуф всего одно значение
[01:11:03.240 --> 01:11:04.240]  Не знаю
[01:11:04.240 --> 01:11:10.240]  Значит, if constexpr...
[01:11:10.240 --> 01:11:12.240]  If constexpr что?
[01:11:12.240 --> 01:11:24.240]  If constexpr sizeof functor меньше или равен, чем local boof size
[01:11:24.240 --> 01:11:29.240]  То мне не надо создавать никакой new
[01:11:29.240 --> 01:11:40.240]  Мне надо просто сказать placement new по адресу local boof
[01:11:40.240 --> 01:11:43.240]  Что?
[01:11:43.240 --> 01:11:58.240]  A functor от std forward от functor от functor
[01:11:58.240 --> 01:12:01.240]  Как это прекрасно пишется всё, конечно
[01:12:01.240 --> 01:12:06.240]  А иначе я уже делаю вот это
[01:12:06.240 --> 01:12:14.240]  Но только я пишу равно здесь
[01:12:14.240 --> 01:12:20.240]  Вот, а теперь как мне...
[01:12:20.240 --> 01:12:24.240]  Опять в операторе круглые скобочки, что мне надо делать?
[01:12:24.240 --> 01:12:26.240]  Опять if constexpr
[01:12:26.240 --> 01:12:34.240]  И if constexpr sizeof functor меньше или равно, чем local
[01:12:34.240 --> 01:12:37.240]  Какой functor? У нас уже нет functor
[01:12:37.240 --> 01:12:39.240]  Во, да, у нас нет functor, и что делать?
[01:12:39.240 --> 01:12:40.240]  И как понимать тогда?
[01:12:40.240 --> 01:12:45.240]  То есть мне всё-таки нужен какой-то bool
[01:12:45.240 --> 01:12:48.240]  Кто говорил, что bool не нужен?
[01:12:48.240 --> 01:12:54.240]  Либо bool храним, либо sizef, но кажется, что bool не хруст
[01:12:54.240 --> 01:12:58.240]  Привет, друзья!
[01:12:58.240 --> 01:13:02.240]  Здрасте
[01:13:02.240 --> 01:13:13.240]  Значит, if local равно true, а здесь if local равно false
[01:13:13.240 --> 01:13:16.240]  Ну и дальше, что понятно, в принципе, можно не писать
[01:13:16.240 --> 01:13:22.240]  Ну давайте для примера напишу
[01:13:22.240 --> 01:13:25.240]  Тут будет to do if local
[01:13:25.240 --> 01:13:29.240]  А если constexpr?
[01:13:29.240 --> 01:13:32.240]  Тут уже не constexpr, к сожалению, а просто if
[01:13:32.240 --> 01:13:35.240]  if local
[01:13:35.240 --> 01:13:38.240]  то
[01:13:38.240 --> 01:13:41.240]  то что?
[01:13:42.240 --> 01:13:48.240]  to reinterpret cast
[01:13:48.240 --> 01:13:55.240]  ну reinterpret cast
[01:13:55.240 --> 01:13:59.240]  к чему?
[01:13:59.240 --> 01:14:01.240]  к functor
[01:14:01.240 --> 01:14:05.240]  ampersand
[01:14:05.240 --> 01:14:07.240]  отлов
[01:14:07.240 --> 01:14:09.240]  А, да, отличный вопрос
[01:14:09.240 --> 01:14:12.240]  Так, и что же делать?
[01:14:12.240 --> 01:14:15.240]  А мы не знаем проблемы
[01:14:15.240 --> 01:14:20.240]  Ну base functor
[01:14:20.240 --> 01:14:22.240]  Кажется, надо не так делать
[01:14:22.240 --> 01:14:25.240]  Кажется, надо, чтобы base functor всё-таки был
[01:14:25.240 --> 01:14:30.240]  Просто указывал в одном из случаев тоже на наше другое поле
[01:14:30.240 --> 01:14:33.240]  Да, давай, а, ой
[01:14:33.240 --> 01:14:35.240]  Так мы тогда ничего не выиграли
[01:14:35.240 --> 01:14:39.240]  Ну оно будет всё ещё локальное
[01:14:39.240 --> 01:14:41.240]  Да, мы динамическую память просто не кладём
[01:14:41.240 --> 01:14:44.240]  Да, так не получится, то есть base functor в любом случае
[01:14:44.240 --> 01:14:47.240]  Вот этот FPTR в любом случае нужен
[01:14:47.240 --> 01:14:50.240]  А в чём релект конкрет cast?
[01:14:50.240 --> 01:14:52.240]  Нет, 100
[01:14:52.240 --> 01:14:54.240]  На что указывают base functor?
[01:14:54.240 --> 01:14:56.240]  Что-то не знаю
[01:14:56.240 --> 01:14:58.240]  Что-то что?
[01:14:58.240 --> 01:15:00.240]  На что надо будет указывать?
[01:15:00.240 --> 01:15:02.240]  На то же самое?
[01:15:02.240 --> 01:15:04.240]  Нет, в юнионе вот этого уже не будет
[01:15:04.240 --> 01:15:06.240]  Давайте подумаем, нам нужен ли
[01:15:06.240 --> 01:15:09.240]  Нет, нет, нет, давайте подумаем, нам нужен ли вообще юнион тогда?
[01:15:09.240 --> 01:15:10.240]  Нет, очевидно
[01:15:10.240 --> 01:15:12.240]  Нет, подождите, ещё не очевидно
[01:15:12.240 --> 01:15:16.240]  Нам уже два поля, значит один FPTR, а другой
[01:15:16.240 --> 01:15:18.240]  А, ну возможно и не...
[01:15:18.240 --> 01:15:21.240]  Вот, может быть действительно не нужен юнион
[01:15:21.240 --> 01:15:24.240]  Да, кажется не нужен юнион, вы правы
[01:15:24.240 --> 01:15:28.240]  Потому что как мы будем понимать, что мы в...
[01:15:28.240 --> 01:15:30.240]  Какой-то мем просто
[01:15:30.240 --> 01:15:33.240]  Как мы будем понимать, что мы в локальной ситуации
[01:15:33.240 --> 01:15:35.240]  А просто этот FPTR будет указывать
[01:15:35.240 --> 01:15:37.240]  На то самое поле и всё
[01:15:37.240 --> 01:15:38.240]  Правда?
[01:15:38.240 --> 01:15:40.240]  Нам не нужен локал, да
[01:15:40.240 --> 01:15:42.240]  Нам даже локал не был в сайзе
[01:15:42.240 --> 01:15:44.240]  Чё, чё странно
[01:15:44.240 --> 01:15:46.240]  Ну, а нет
[01:15:46.240 --> 01:15:49.240]  Так вот, если FPTR
[01:15:49.240 --> 01:15:53.240]  Если сайзов такой, то FPTR мы присваиваем
[01:15:53.240 --> 01:15:56.240]  Локал boof
[01:15:56.240 --> 01:15:58.240]  Только его надо reinterpret cast-нуть
[01:15:58.240 --> 01:15:59.240]  К намужному типу
[01:15:59.240 --> 01:16:00.240]  Сейчас он скажет это не...
[01:16:00.240 --> 01:16:02.240]  Так, я не могу, вы что сейчас сделаете?
[01:16:02.240 --> 01:16:03.240]  Я букву f забыл ещё
[01:16:03.240 --> 01:16:05.240]  Interpret cast-out
[01:16:05.240 --> 01:16:08.240]  Base звёздочки
[01:16:08.240 --> 01:16:11.240]  Вот, локал boof
[01:16:11.240 --> 01:16:13.240]  Одну букву f
[01:16:13.240 --> 01:16:19.240]  Да, а new-то нам нужно положить не функтор, а derived
[01:16:19.240 --> 01:16:21.240]  Функтор, с шаблонным параметром функтор
[01:16:21.240 --> 01:16:24.240]  Чтоб там таблица виртуальных функций правильно лежала
[01:16:24.240 --> 01:16:26.240]  Я букву f потерял в локал boof, стручка
[01:16:26.240 --> 01:16:29.240]  Да, господи, это не так важно
[01:16:29.240 --> 01:16:33.240]  Да, и ещё не base, а base-функтор
[01:16:33.240 --> 01:16:36.240]  Так, base-функтор, хорошо
[01:16:39.240 --> 01:16:42.240]  А если нет, то...
[01:16:42.240 --> 01:16:45.240]  То всё
[01:16:45.240 --> 01:16:47.240]  В чём у нас эта проблема не решилась?
[01:16:47.240 --> 01:16:49.240]  В чём у нас была проблема с юнионом?
[01:16:49.240 --> 01:16:51.240]  Почему нельзя было вызывать просто, типа
[01:16:51.240 --> 01:16:54.240]  Всегда PTR, а если у нас там не PTR, а это для массива чаров
[01:16:54.240 --> 01:16:57.240]  Как мы отличим PTR от массива чаров?
[01:16:57.240 --> 01:16:59.240]  Зачем нам вызывать? Зачем нам отвечать, типа?
[01:16:59.240 --> 01:17:00.240]  Нас просто...
[01:17:00.240 --> 01:17:02.240]  Вот, я в операторе круглые скобочки, а что сделать?
[01:17:02.240 --> 01:17:04.240]  Вот, всегда будем f PTR вызывать
[01:17:04.240 --> 01:17:07.240]  Что значит вызывать? Что я напишать должен?
[01:17:07.240 --> 01:17:08.240]  Ну, типа f
[01:17:08.240 --> 01:17:10.240]  f PTR, стрелочка, что?
[01:17:10.240 --> 01:17:11.240]  Да
[01:17:11.240 --> 01:17:14.240]  Так если в юнионе активен не этот член, это уб
[01:17:14.240 --> 01:17:17.240]  Да, но там же всё равно будет, типа, такой же массив
[01:17:17.240 --> 01:17:18.240]  Как это так?
[01:17:18.240 --> 01:17:20.240]  На том же месте будет лежать вот этот массив чаров
[01:17:20.240 --> 01:17:21.240]  Нет
[01:17:21.240 --> 01:17:22.240]  Или как?
[01:17:22.240 --> 01:17:25.240]  Там может быть функциональный объект с какими-то полями
[01:17:25.240 --> 01:17:26.240]  Да
[01:17:26.240 --> 01:17:29.240]  И как ты у него стрелочку, оператор круглые скобочки?
[01:17:29.240 --> 01:17:31.240]  Стрелочка подразумевает, что там лежит Пойнтер
[01:17:31.240 --> 01:17:32.240]  И ты...
[01:17:32.240 --> 01:17:34.240]  Ты пытаешься разыминовывать локально
[01:17:34.240 --> 01:17:38.240]  Ты пытаешься разыминовывать нечто, что не является Пойнтером, а является лообъектом локально
[01:17:39.240 --> 01:17:44.240]  Почему нельзя простануть бейс пасу в поле, если у нас и боков
[01:17:44.240 --> 01:17:46.240]  Чего-чего нельзя сделать?
[01:17:46.240 --> 01:17:50.240]  Ну, сделать каст к бейс пуктеру, а потом вызвать круглые скобочки
[01:17:57.240 --> 01:18:00.240]  А туда положить дирайвт пуктер, на самом деле
[01:18:00.240 --> 01:18:01.240]  Ну да
[01:18:02.240 --> 01:18:03.240]  А, то есть...
[01:18:05.240 --> 01:18:07.240]  Что, ещё раз переделывать, что ли?
[01:18:10.240 --> 01:18:13.240]  По адресу localbuff предлагается сделать...
[01:18:14.240 --> 01:18:17.240]  Предлагается положить дирайвт пуктер
[01:18:17.240 --> 01:18:21.240]  А если из local, то просто кастить его к бейс звёздочки
[01:18:22.240 --> 01:18:26.240]  И вызывать оператор круглые скобочки через стрелочку
[01:18:26.240 --> 01:18:28.240]  Да, кажется, это сработает
[01:18:28.240 --> 01:18:29.240]  Чтобы сэкономить память?
[01:18:29.240 --> 01:18:30.240]  Чтобы сэкономить память, да
[01:18:30.240 --> 01:18:31.240]  Давай забьём на память сейчас
[01:18:31.240 --> 01:18:32.240]  Ну давайте забьём
[01:18:32.240 --> 01:18:35.240]  Короче, понятно, что... Да, кажется, так можно
[01:18:36.240 --> 01:18:39.240]  Ещё раз... Ну блин, ну давайте напишу тогда
[01:18:40.240 --> 01:18:41.240]  Ой
[01:18:42.240 --> 01:18:43.240]  Ещё раз, у нас юнион
[01:18:43.240 --> 01:18:45.240]  Бейс пуктер звёздочка и вот это
[01:18:46.240 --> 01:18:49.240]  Мы кладём new localbuff дирайвт пуктер
[01:18:50.240 --> 01:18:52.240]  И ещё буль храним из local
[01:18:52.240 --> 01:18:56.240]  Если из local, то reinterpret cast к бейс звёздочки
[01:18:56.240 --> 01:18:58.240]  от localbuff
[01:18:58.240 --> 01:19:01.240]  Стрелочка, оператор круглые скобочки
[01:19:03.240 --> 01:19:06.240]  Ну поскольку там дирайвт пуктер, всё нормально отработает
[01:19:09.240 --> 01:19:11.240]  Да, так будет получше
[01:19:14.240 --> 01:19:17.240]  Сейчас а мы в наследовании можем показывать
[01:19:18.240 --> 01:19:21.240]  У нас же в наследовании там касты какие-то странные
[01:19:21.240 --> 01:19:23.240]  Какие? Ну чего?
[01:19:24.240 --> 01:19:26.240]  У нас тут никакого множества наследований
[01:19:26.240 --> 01:19:29.240]  У нас обычно у нас бейс звёздочка и от него дирайвт звёздочка
[01:19:29.240 --> 01:19:33.240]  А анонтируется ли, что это корректное поведение?
[01:19:34.240 --> 01:19:35.240]  Ну по логике да
[01:19:35.240 --> 01:19:38.240]  Если там лежит дирайвт пуктер
[01:19:38.240 --> 01:19:42.240]  Мы к нему обратились как будто это бейс пуктер, то конечно это корректно
[01:19:42.240 --> 01:19:47.240]  Ну просто мы к нему обратились не через динамит каста, а через reinterpret каст
[01:19:48.240 --> 01:19:52.240]  Да, мы сказали, что там лежит указатель на бейс
[01:19:52.240 --> 01:19:56.240]  Мы сказали, считай, что там лежит указатель на бейс
[01:19:56.240 --> 01:19:59.240]  А под ним лежит указатель на дирайвт пуктер
[01:19:59.240 --> 01:20:02.240]  А под ним лежит дирайвт пуктер, да, нормально
[01:20:09.240 --> 01:20:11.240]  Да какое приведение? Ещё раз
[01:20:11.240 --> 01:20:13.240]  У меня есть бейс
[01:20:13.240 --> 01:20:15.240]  У меня есть объект дирайвт
[01:20:15.240 --> 01:20:17.240]  У меня есть объект дирайвт
[01:20:17.240 --> 01:20:21.240]  Я завёл пойнтер на бейс
[01:20:21.240 --> 01:20:23.240]  И сказал, вот
[01:20:23.240 --> 01:20:27.240]  И заставил указывать туда, где начинается объект дирайвт
[01:20:27.240 --> 01:20:28.240]  Ну и что?
[01:20:28.240 --> 01:20:32.240]  А гарантируется ли стандартом, что они начинаются в одном и том же месте?
[01:20:34.240 --> 01:20:35.240]  Да, думаю да
[01:20:41.240 --> 01:20:43.240]  А где оно будет?
[01:20:46.240 --> 01:20:48.240]  В таблице виртуальных функций
[01:20:48.240 --> 01:20:50.240]  В таблице виртуальных функций, конечно
[01:20:50.240 --> 01:20:53.240]  На этом и virtual тут и припилили
[01:21:04.240 --> 01:21:06.240]  Минуточку, мы положили туда
[01:21:06.240 --> 01:21:08.240]  Объект дирайвт пуктер
[01:21:08.240 --> 01:21:10.240]  Дирайвт пуктер это полиморфный объект
[01:21:10.240 --> 01:21:13.240]  Значит, первым полем у него есть vptr
[01:21:13.240 --> 01:21:16.240]  Значит, под него создалась таблица виртуальных функций, где-то в статической памяти
[01:21:16.240 --> 01:21:18.240]  Этот vptr на неё указывает
[01:21:20.240 --> 01:21:22.240]  Короче, тут тоже туду
[01:21:22.240 --> 01:21:24.240]  Давайте
[01:21:24.240 --> 01:21:26.240]  В общем, с этой проблемой понятно
[01:21:26.240 --> 01:21:27.240]  Small object optimization
[01:21:27.240 --> 01:21:29.240]  Нам надо ещё две проблемы обсудить
[01:21:29.240 --> 01:21:31.240]  Так вот, как остальевский код пишется
[01:21:32.240 --> 01:21:34.240]  Примерно тайна
[01:21:34.240 --> 01:21:37.240]  Так весь код пишется, я вам открою тайну, типа
[01:21:37.240 --> 01:21:39.240]  Что-то мы не успеваем по дидлайну
[01:21:39.240 --> 01:21:41.240]  Что-то у нас время заканчивается
[01:21:41.240 --> 01:21:43.240]  Давайте туду оставим, потом когда-нибудь решим эту проблему
[01:21:43.240 --> 01:21:45.240]  Спустя год
[01:21:45.240 --> 01:21:47.240]  Что-то так и не решили
[01:21:47.240 --> 01:21:49.240]  И работает нормально
[01:21:49.240 --> 01:21:51.240]  Да и вроде нормально работает
[01:21:51.240 --> 01:21:53.240]  Так, ещё две проблемы надо обсудить
[01:21:55.240 --> 01:21:57.240]  А, уважаемые господа
[01:21:57.240 --> 01:21:59.240]  Посмотрите, пожалуйста, вот на эту строчку
[01:22:01.240 --> 01:22:03.240]  Вот ещё раз, я вас спрашивал
[01:22:03.240 --> 01:22:05.240]  Вас здесь ничего не смущает
[01:22:05.240 --> 01:22:07.240]  Теперь время смущения
[01:22:07.240 --> 01:22:09.240]  Вас должно здесь что-то смущать
[01:22:11.240 --> 01:22:13.240]  Да нет, здесь всё вообще
[01:22:13.240 --> 01:22:15.240]  Тут f это поле наше
[01:22:17.240 --> 01:22:19.240]  Я напомню вам
[01:22:19.240 --> 01:22:21.240]  Я напомню вам
[01:22:23.240 --> 01:22:25.240]  Нет, лучше вы напомните мне
[01:22:25.240 --> 01:22:27.240]  Напомните мне, что является
[01:22:27.240 --> 01:22:29.240]  Colable объектами
[01:22:29.240 --> 01:22:31.240]  Что вообще является Colable
[01:22:31.240 --> 01:22:33.240]  Указатели на функции
[01:22:33.240 --> 01:22:35.240]  Указатели на функции, сами функции
[01:22:35.240 --> 01:22:37.240]  Функциональные классы
[01:22:37.240 --> 01:22:39.240]  Клоузеры, байнды
[01:22:39.240 --> 01:22:41.240]  А ещё
[01:22:41.240 --> 01:22:43.240]  Лямды, я уже сказал
[01:22:43.240 --> 01:22:45.240]  Клоузеры, а ещё указатели на методы
[01:22:47.240 --> 01:22:49.240]  А если это
[01:22:49.240 --> 01:22:51.240]  PointerToMember
[01:22:51.240 --> 01:22:53.240]  Да ё-моё
[01:22:53.240 --> 01:22:55.240]  Если это указатель на метод
[01:22:55.240 --> 01:22:57.240]  То такой Col не сработает
[01:22:57.240 --> 01:22:59.240]  Потому что нужно делать точку со звёздочками
[01:22:59.240 --> 01:23:01.240]  И передавать
[01:23:01.240 --> 01:23:03.240]  Неявно первым аргументом
[01:23:03.240 --> 01:23:05.240]  В общем
[01:23:25.240 --> 01:23:27.240]  В общем, if constexpr
[01:23:27.240 --> 01:23:29.240]  Ой, что я написал
[01:23:29.240 --> 01:23:31.240]  Ну
[01:23:31.240 --> 01:23:33.240]  Можно примерно
[01:23:33.240 --> 01:23:35.240]  Написать так
[01:23:35.240 --> 01:23:37.240]  std isPointerTo
[01:23:43.240 --> 01:23:45.240]  Я забыл
[01:23:45.240 --> 01:23:47.240]  isPointerToMember
[01:23:53.240 --> 01:23:55.240]  isMemberPointer
[01:23:57.240 --> 01:23:59.240]  IsPointerTo
[01:23:59.240 --> 01:24:01.240]  С роут криком
[01:24:01.240 --> 01:24:03.240]  Ну тут есть isMemberFunctionPointer
[01:24:03.240 --> 01:24:05.240]  Вот что нам надо
[01:24:05.240 --> 01:24:07.240]  IsMemberFunctionPointer
[01:24:11.240 --> 01:24:13.240]  Atf
[01:24:13.240 --> 01:24:15.240]  Well, memberFunctionPointerV
[01:24:15.240 --> 01:24:17.240]  Опять он сейчас скажет, что нет такого
[01:24:17.240 --> 01:24:19.240]  Ну хорошо, MemberFunctionPointerValue
[01:24:19.240 --> 01:24:21.240]  То что
[01:24:21.240 --> 01:24:23.240]  Ну return
[01:24:23.240 --> 01:24:25.240]  F. звёздочка
[01:24:25.240 --> 01:24:27.240]  то ретюр
[01:24:41.240 --> 01:24:43.240]  ну то есть нам нужно
[01:24:43.240 --> 01:24:45.240]  откусить начало пакета здесь
[01:24:45.240 --> 01:24:47.240]  давай это сделаем
[01:24:47.240 --> 01:24:49.240]  здесь я просто вдираю
[01:24:49.240 --> 01:24:51.240]  фанкты
[01:24:51.240 --> 01:24:53.240]  нет у нас пакет
[01:24:53.240 --> 01:24:55.240]  для класса
[01:24:55.240 --> 01:24:57.240]  целиком
[01:24:57.240 --> 01:24:59.240]  можно предложить
[01:24:59.240 --> 01:25:01.240]  давай вдираем фанкты
[01:25:01.240 --> 01:25:03.240]  и сделаем просто
[01:25:03.240 --> 01:25:05.240]  функцию в духе
[01:25:05.240 --> 01:25:07.240]  result call
[01:25:07.240 --> 01:25:09.240]  у которого
[01:25:09.240 --> 01:25:11.240]  который видимо тоже будет
[01:25:11.240 --> 01:25:13.240]  шаблон
[01:25:13.240 --> 01:25:15.240]  я предлагаю сделать
[01:25:15.240 --> 01:25:17.240]  решение в стиле stl
[01:25:17.240 --> 01:25:19.240]  смотрите какая замечательная вещь
[01:25:19.240 --> 01:25:21.240]  template type name f
[01:25:21.240 --> 01:25:23.240]  type name многоточие
[01:25:23.240 --> 01:25:25.240]  type name
[01:25:25.240 --> 01:25:27.240]  ну давайте скажу arc
[01:25:27.240 --> 01:25:29.240]  type name head type name tail
[01:25:31.240 --> 01:25:33.240]  правда нам нужна будет специализация
[01:25:33.240 --> 01:25:35.240]  на перемен количества
[01:25:35.240 --> 01:25:37.240]  ладно на случай когда их ноль
[01:25:37.240 --> 01:25:39.240]  а есть такая замечательная функция
[01:25:39.240 --> 01:25:41.240]  а еще type name result
[01:25:43.240 --> 01:25:45.240]  есть такая замечательная
[01:25:45.240 --> 01:25:47.240]  функция
[01:25:47.240 --> 01:25:49.240]  invoke
[01:25:55.240 --> 01:25:57.240]  которая принимает по
[01:25:57.240 --> 01:25:59.240]  универсальной ссылке f
[01:26:01.240 --> 01:26:03.240]  и все это тоже
[01:26:05.240 --> 01:26:07.240]  и что она делает
[01:26:07.240 --> 01:26:09.240]  а вот она как раз это и делает
[01:26:09.240 --> 01:26:11.240]  если constexpr
[01:26:11.240 --> 01:26:13.240]  ну я предлагал это просто внутри
[01:26:13.240 --> 01:26:15.240]  написать
[01:26:15.240 --> 01:26:17.240]  о это пришел
[01:26:19.240 --> 01:26:21.240]  и еще раз
[01:26:21.240 --> 01:26:23.240]  if constexpr is member
[01:26:23.240 --> 01:26:25.240]  function pointer
[01:26:25.240 --> 01:26:27.240]  то
[01:26:29.240 --> 01:26:31.240]  что
[01:26:35.240 --> 01:26:37.240]  вкуснотища
[01:26:37.240 --> 01:26:39.240]  обожаю
[01:26:39.240 --> 01:26:41.240]  опять пришел в такой же куртке как у меня
[01:26:41.240 --> 01:26:43.240]  я в прошлый раз перепутал куртки
[01:26:43.240 --> 01:26:45.240]  ты знал об этом?
[01:26:45.240 --> 01:26:47.240]  head.f
[01:26:47.240 --> 01:26:49.240]  от tail
[01:26:49.240 --> 01:26:51.240]  head.
[01:26:51.240 --> 01:26:53.240]  звездочка
[01:26:53.240 --> 01:26:55.240]  head.
[01:26:55.240 --> 01:26:57.240]  конечно сейчас сделаем
[01:26:57.240 --> 01:26:59.240]  f от
[01:27:03.240 --> 01:27:05.240]  tail многоточие
[01:27:07.240 --> 01:27:09.240]  но надо сделать std forward
[01:27:09.240 --> 01:27:11.240]  ко всему этому
[01:27:11.240 --> 01:27:13.240]  от head
[01:27:13.240 --> 01:27:15.240]  от head
[01:27:15.240 --> 01:27:17.240]  точка звездочка
[01:27:17.240 --> 01:27:19.240]  std forward
[01:27:19.240 --> 01:27:21.240]  от tail
[01:27:21.240 --> 01:27:23.240]  от tail
[01:27:23.240 --> 01:27:25.240]  что смеетесь это все на экзамене будет
[01:27:25.240 --> 01:27:27.240]  а иначе
[01:27:27.240 --> 01:27:29.240]  не надо дядя
[01:27:31.240 --> 01:27:33.240]  у нас еще самый интересный впереди
[01:27:33.240 --> 01:27:35.240]  подождите мы еще такое 10 апреля
[01:27:35.240 --> 01:27:37.240]  а
[01:27:39.240 --> 01:27:41.240]  не ну это какой нибудь хор будет скорее
[01:27:41.240 --> 01:27:43.240]  5
[01:27:43.240 --> 01:27:45.240]  вот
[01:27:45.240 --> 01:27:47.240]  а иначе что
[01:27:47.240 --> 01:27:49.240]  а иначе std forward
[01:27:53.240 --> 01:27:55.240]  от f
[01:27:55.240 --> 01:27:57.240]  с шаблон параметром f
[01:27:57.240 --> 01:27:59.240]  от f точка
[01:28:01.240 --> 01:28:03.240]  а все просто вот так можно написать
[01:28:03.240 --> 01:28:05.240]  а мы сверху не забыли
[01:28:05.240 --> 01:28:07.240]  а f не надо forward
[01:28:07.240 --> 01:28:09.240]  мы же знаем что это из member function pointer
[01:28:09.240 --> 01:28:11.240]  что его forward
[01:28:11.240 --> 01:28:13.240]  это просто указатель
[01:28:13.240 --> 01:28:15.240]  а
[01:28:15.240 --> 01:28:17.240]  head от head
[01:28:17.240 --> 01:28:19.240]  запятая
[01:28:19.240 --> 01:28:21.240]  std forward
[01:28:23.240 --> 01:28:25.240]  от tail от tail
[01:28:25.240 --> 01:28:27.240]  вот
[01:28:29.240 --> 01:28:31.240]  такойخرой
[01:28:31.240 --> 01:28:33.240]  в Sanpreza
[01:28:33.240 --> 01:28:35.240]  1968
[01:28:41.240 --> 01:28:43.240]  вот такая функция действительно есть
[01:28:43.240 --> 01:28:45.240]  в стандартной библиотеке она так называется std invoke
[01:28:45.240 --> 01:28:47.240]  а еще она умеет вызывать pointer to
[01:28:47.240 --> 01:28:49.240]  member object
[01:28:49.240 --> 01:28:51.240]  помните я говорил что колоблами являются
[01:28:51.240 --> 01:28:53.240]  указатели на члены
[01:28:53.240 --> 01:29:02.160]  на поля и их вызов он как бы с неявным аргументом ссылка на класс ссылка на объект просто возвращает
[01:29:02.160 --> 01:29:10.520]  это поле но это удобно если вам там да да но в общем здесь еще надо разобрать случай если это
[01:29:10.520 --> 01:29:18.680]  поле член но мы не будем его разбирать в общем а здесь мы просто вместо того чтобы делать круглые
[01:29:18.680 --> 01:29:43.520]  скобочки напишем return std invoke от f и от std forward от arcs вот arcs нужно ли st forward от f делать
[01:29:48.680 --> 01:30:02.240]  у нас она как поле хранится она у нас lvl и в любом случае нет не нужно
[01:30:02.240 --> 01:30:10.360]  так мы же вот в нашем вулке еще type name result
[01:30:10.360 --> 01:30:20.560]  надо тогда явно дай стд инвок да кажется ну кажется у нее первым параметром result чтобы
[01:30:20.560 --> 01:30:28.920]  мы явно говорили а нет знаете нет почему потому что там кажется есть шаблонные давайте посмотрим
[01:30:28.920 --> 01:30:36.280]  что он сам шаблоны подставит потому что он знает что возвращает думаю ну давайте проверим
[01:30:36.280 --> 01:30:46.400]  значит а у нее вообще нету этого шаблонного параметра но есть версия с ним а есть версии
[01:30:46.400 --> 01:30:52.320]  без него а почему а потому что зачем мне делать его если я могу написать декл тайп
[01:30:52.320 --> 01:31:05.160]  декл тайп от f ну вот тут короче есть такая проблемка что я не могу написать декл от
[01:31:05.160 --> 01:31:10.200]  чего именно декл тайп потому что либо от этого либо от этого опять в зависимости того чем оно
[01:31:10.200 --> 01:31:19.760]  было но как раз на этот случай есть мета функция инвок result то есть result он тоже
[01:31:19.760 --> 01:31:24.480]  выводится автоматически с помощью штуки под названием инвок result который тоже делает декл
[01:31:24.480 --> 01:31:33.920]  тайп там про от правильной штуки ну давайте я его тоже открою вам result инвок result вот да
[01:31:33.920 --> 01:31:42.080]  смотрите смотрите что здесь написано здесь все очень или а что нам мешает просто вместо декл
[01:31:42.080 --> 01:32:01.960]  тайпа авто написать сам разберется кстати может быть можно и декл тайпа авто написать
[01:32:01.960 --> 01:32:08.880]  почему просто потому что авто ссылки отбросит может же быть такая ситуация что мы хотим чтобы
[01:32:12.480 --> 01:32:18.080]  типа у нас функции какой-то из этих вариантов возвращает нам флот а мы хотим скастить
[01:32:18.080 --> 01:32:28.760]  что у тебя сама господа давайте наверное мы на этом сегодня закончим и видимо да обсудим
[01:32:28.760 --> 01:32:33.840]  в следующий раз потому что уже нам пора заканчивать уже пришел и ждет цель пробросить вы пробросить
[01:32:33.840 --> 01:32:39.720]  ответ функции короче мы с вами на самом деле почти все проблемы обсудили а я вам рассказал про
[01:32:39.720 --> 01:32:46.920]  функции invoke но мы еще до до дочитаем вот что тут написано в следующий раз тут видите как
[01:32:46.920 --> 01:32:56.240]  много тут видите много этих кастом template deduction rules вот для того что он правильно
[01:32:56.240 --> 01:33:06.960]  уводил эти типа вот ну давайте ладно давайте на этом закончим все теперь точно и вот значит
[01:33:06.960 --> 01:33:17.560]  смотрите сначала поговорим про просто простую ути литарную штуку вот полиморф на локаторе
[01:33:17.560 --> 01:33:25.640]  значит штука простая но у нас есть целый на им спейс под нее вот вы даже возможно где-то
[01:33:25.640 --> 01:33:40.120]  видели на цп референс например вот если мы откроем дек или вектор или строку или лист вот
[01:33:40.120 --> 01:33:48.640]  у нас здесь видите всегда есть основная так сказать объявление класса рядом еще одно вот
[01:33:48.640 --> 01:33:54.680]  на им спейсе пимар вот это просто на самом деле специализация дека с каким-то конкретным
[01:33:54.680 --> 01:34:00.040]  локатором стд помар полиморфик локатор вот какой же флекс сегодня сегодня мы с вами
[01:34:00.040 --> 01:34:14.760]  очевидно попробуем понять что такое ну хорошо что такое полиморф на локатор какой это параграф
[01:34:14.760 --> 01:34:41.840]  илья вот идея в чем идея в том что вот у нас есть разные разные виды локаторов например
[01:34:41.840 --> 01:34:51.880]  то что вы писали в листе те кто писали стэка локатор у нас есть там локатор который
[01:34:51.880 --> 01:34:59.400]  заведет new delete есть локатор там какой-то другой и вот люди решили что давайте
[01:34:59.400 --> 01:35:04.800]  делаем один локатор который имеет вот это все и нам не нужно явно указывать какие-то сложные
[01:35:04.800 --> 01:35:14.280]  типы мы можем со всеми тем работать и оно очень классно комбинируется и вот да и
[01:35:14.280 --> 01:35:17.280]  получился полиморф на локатор кстати что такое комбинируется зачем вообще нужно
[01:35:17.280 --> 01:35:23.440]  может захотелось комбинировать локаторы как вы думаете комбинировать вот у вас есть два
[01:35:23.440 --> 01:35:42.120]  локатор и хоп делать один вот например так подменить тоже можно да вот вот идея мне нравится
[01:35:42.120 --> 01:35:49.840]  что если у нас вот есть наш локатор на стэке да и как вам например такое поведение мы выделили
[01:35:49.840 --> 01:35:55.000]  память на стэке она быстрая но если она вдруг закончилась мы начинаем вызывать new delete вот
[01:35:55.000 --> 01:36:01.040]  ну прикольно прикольно же иметь такой локатор просто большие объекты через new delete а маленькие
[01:36:01.040 --> 01:36:13.600]  на стэке то есть размер объекта там я не знаю больше чем да я понял твою идею 64 байта давай
[01:36:13.600 --> 01:36:19.440]  да тут чтобы вот такое сделать придется пописать кастомный код но да вот вот ту
[01:36:19.440 --> 01:36:23.920]  проблему прям красиво решим на смотрите как работает полиморф на локатор у нас
[01:36:23.920 --> 01:36:32.920]  есть вот этот один тип локатора который обычный локатор и он значит конструируется от так
[01:36:32.920 --> 01:36:39.080]  называемого memory ресурса вот memory ресурс это то что выдает память какая-то штука у
[01:36:39.080 --> 01:36:44.840]  которой есть память который умеет выдавать память и забирать память обратно например
[01:36:44.840 --> 01:36:48.840]  стэк сторож да в некотором смысле и на самом деле вот раз мы заговорили о стэк сторожи у
[01:36:48.840 --> 01:37:02.880]  нас в стандарте есть стэк сторож он называется стд пмр мана тоник баффер ресурс вот давайте
[01:37:02.880 --> 01:37:07.280]  мы его собственно создадим на стэке вот поэтому вы его не нашли
[01:37:07.280 --> 01:37:21.720]  не знаю могли посмотреть в код и написать зачем-нибудь когда писали стэк сторож но
[01:37:21.720 --> 01:37:27.960]  на самом деле умеет больше чем ваш стэк сторож вот так это просто 100 байт memory ресурс
[01:37:27.960 --> 01:37:36.120]  он умеет конструироваться по умолчанию я локатор умеет конструироваться по умолчанию
[01:37:36.120 --> 01:37:40.520]  внезапно что вы думаете происходит если мы конструируем такой локатор по умолчанию вот
[01:37:40.520 --> 01:37:55.520]  что бы почти значит он это то же самое практически что написать стд пмр get default ресурс у нас есть
[01:37:55.520 --> 01:38:00.800]  какой-то дефолтный ресурс мы его можем который глобальный тип в программе мы его можем получать и
[01:38:00.800 --> 01:38:06.200]  мы его можем устанавливать в любой момент то есть мы можем например сделать наш баффер
[01:38:06.200 --> 01:38:19.600]  дефолтным ресурсом через стд мар сет дефолт ресурс абсолютно верно кто-то что-то нашел вот
[01:38:19.600 --> 01:38:27.040]  но он принимает указательный ресурс ему же указатель потому что нет потому что так как
[01:38:27.040 --> 01:38:34.920]  локатор полиморфный как это вообще все внутри работает ну через виртуальные функции у вас просто
[01:38:34.920 --> 01:38:41.640]  есть базовый класс memory ресурс мы от него наследуемся каждым ресурсом вот и каждый ресурс по
[01:38:41.640 --> 01:38:50.160]  своему определяет просто до locate вот поэтому все так относительно красиво и удобно относительно
[01:38:50.160 --> 01:39:08.360]  пока не заглянешь в код видимо понимать каким локатором делись кто вот вот такая
[01:39:08.360 --> 01:39:25.560]  а кому на ходу решили локатор поднимать вот кажется локатору мы уже не можем нет мы можем
[01:39:25.560 --> 01:39:34.160]  только получить ресурс мы не можем установить действительно было бы что-то странное вот окей
[01:39:34.160 --> 01:39:41.200]  так вот дай дефолтный ресурс а значит дефолтный ресурс это следующего вида ресурс значит я
[01:39:41.200 --> 01:39:58.120]  призываю вас догадаться что он делает это ресурс у нас локатор один вообще что мне нравится
[01:40:04.160 --> 01:40:10.000]  да ну он просто вызывает типа вы вызываете не локейт он вызывает нью вызываете у него
[01:40:10.000 --> 01:40:26.400]  делокейт он вызывает delete все так чуть-чуть что он с ума сошел мне как у нас есть глобальный
[01:40:26.400 --> 01:40:32.000]  указатель где-то в программе и он устанавливает грит вот этот ресурс теперь дефолтный если кто-то
[01:40:32.000 --> 01:40:38.480]  позовет потом гет дефолт ресурс он получит указатель на то что мы туда положили это что-то
[01:40:38.480 --> 01:40:42.920]  что умеет выдавать тебе сырую память то есть в отличие от локатора эта штука вообще не думает
[01:40:42.920 --> 01:40:48.360]  никак о типе вот представьте свой стек сторож все о чем он думает это его могут попросить выдать
[01:40:48.360 --> 01:40:58.640]  сколько-то памяти его могут попросить забрать эту память обратно все ну именно для работы
[01:40:58.640 --> 01:41:20.400]  с вот этим полиморфным локатором так я хочу понять понимаете вы что тут пошло не так ну в общем
[01:41:20.400 --> 01:41:31.240]  есть нью дилит ресурс я вам обещаю вот какие ресурсы еще есть вот два тех с которыми мы
[01:41:31.240 --> 01:41:38.640]  работали мы уже назвали какой вы можете придумать кроме этих двух самый простой локатор вообще
[01:41:38.640 --> 01:41:54.920]  на самом деле это монотоник баффер мы можем ему передать готовый начнетоник баффер может
[01:41:54.920 --> 01:42:03.000]  от количества байт создаться а может от кого-то указателя можем выделить и передать
[01:42:03.000 --> 01:42:12.000]  его указатель и размер и тогда он будет от него работать еще проще не выделять не выделять память
[01:42:12.000 --> 01:42:30.280]  ну именно так вот ну memory ресурс у нас есть действительно самый простой вообще галлокатор
[01:42:30.280 --> 01:42:37.520]  и так он может быть но то есть у него просто нет памяти он всегда говорит у меня нет памяти
[01:42:37.520 --> 01:42:49.160]  так я хочу немножко понять он как будто еще на прошлой строчки не видит
[01:42:49.160 --> 01:43:02.720]  нет не дилит остается не дилитом но вот если ты если ты после этого создашь например вот
[01:43:02.720 --> 01:43:10.320]  такой локатор он будет использовать наш ресурс если ты после этого создашь стд пмар дек
[01:43:10.320 --> 01:43:25.600]  он будет использовать твой ресурс более того есть особенность у него если ты в этот дек положишь
[01:43:25.600 --> 01:43:40.160]  строки здесь будет дек стд пмар строк вот строки внутри будет использовать тот же локатор с тем
[01:43:40.160 --> 01:43:52.480]  же ресурсом что и сам дек но помните там у вас было же что там этот как это штука называется я
[01:43:52.480 --> 01:44:03.320]  забыл даже да скоптала катор адаптер вот вот вот примерно также что-то меня волнует это конечно
[01:44:03.320 --> 01:44:11.880]  немножко чтобы какой-то очень странно выдают
[01:44:11.880 --> 01:44:23.960]  есть у вас идея что пошло не так
[01:44:23.960 --> 01:44:30.360]  так нет
[01:44:30.360 --> 01:44:45.280]  интересно ну-ка давайте стандарт смысле но у меня вроде
[01:44:45.280 --> 01:45:00.560]  это функция
[01:45:00.560 --> 01:45:14.480]  все понял это функция которая возвращает указатель на эту штуку мы можем вот так сделать
[01:45:14.480 --> 01:45:33.320]  да ну и тогда соответственно растет уже указатель вот да все все хорошо но с ней
[01:45:33.320 --> 01:45:39.160]  дилет ресурсом видимо также что в том справедливо зачем нам их создавать если он для всех везде
[01:45:40.000 --> 01:45:53.760]  окей так ну мы ресурс ну соответственно если я что-то в этот дек добавлю то мы получим исключение
[01:45:53.760 --> 01:46:10.800]  бд лог очень просто вот и последний стандартный ресурс это значит ладно на самом деле это
[01:46:10.800 --> 01:46:19.200]  пара ресурсов стандартных значит есть стд помар значит есть синхрон айст пол ресурс и
[01:46:19.200 --> 01:46:26.800]  ансинхрон айст
[01:46:26.800 --> 01:46:45.280]  ну чем отличается синхрон айст от ансинхрон айст мы подробно говорить не будем если коротко
[01:46:45.280 --> 01:46:52.920]  тем что один безопасен для работы с многими потоками другой нет вот то синхрон айст можно
[01:46:52.920 --> 01:46:57.400]  использовать разных потоков параллельно как например new delete new delete имейте право
[01:46:57.400 --> 01:47:06.360]  использовать из разных потоков и не думать ни о чем а вот что на самом деле налагает некоторые
[01:47:06.360 --> 01:47:13.200]  ограничения на ну на производительность ансинхрон айст пул ресурс вот он об этом не думает
[01:47:13.200 --> 01:47:19.960]  наш пул ресурс
[01:47:26.600 --> 01:47:31.520]  вот что это за ресурсы такие значит ну
[01:47:35.360 --> 01:47:37.160]  они работают следующим образом
[01:47:37.400 --> 01:47:48.720]  внутри они выделяют несколько больших блоков памяти которые режут на несколько больших
[01:47:48.720 --> 01:47:54.080]  чанков памяти которые лежат на маленькие блоки вот блоки маленького размера давай не знаю порисую
[01:47:54.080 --> 01:48:02.840]  для общего сведения в целом мы это писать не будем но кстати вам это потом может пригодиться в
[01:48:02.840 --> 01:48:14.560]  будущем на курсе как раз многопоточки так справляюсь ладно может этого хватит а куда
[01:48:14.560 --> 01:48:18.000]  значит смотрите
[01:48:18.000 --> 01:48:29.520]  откуда-то эта штука берет себе память она эту память делит на несколько таких больших кусков
[01:48:29.520 --> 01:48:32.640]  которые мы не видим
[01:48:32.640 --> 01:48:41.400]  несколько больших кусков кусок 1 кусок 2
[01:48:41.400 --> 01:48:50.960]  кусок n значит в каждом куске память делится на одинакового размера блоки
[01:48:50.960 --> 01:49:03.880]  но они одинаковые внутри одного куска но между кусками разные вот понимаете ли вы после этого
[01:49:03.880 --> 01:49:10.800]  как она будет примерно алоцировать в чем идея зачем так делать
[01:49:10.800 --> 01:49:25.600]  нет сейчас это memory ресурс синхронизм и синхронизм работает похожим образом и вот
[01:49:25.600 --> 01:49:32.600]  идейна вот эта логика для них для обоих верно но вот еще раз я примерно типа в общих деталях
[01:49:32.600 --> 01:49:38.080]  объясняю как внутри работают pool memory ресурс синхронизм или синхронизм вот я говорю что внутри
[01:49:38.080 --> 01:49:43.480]  хранит у него есть несколько больших чанков памяти которые он делит на маленькие блоки вот
[01:49:43.480 --> 01:49:55.920]  есть идеи зачем так делать ну да что там еще может лежать но везде попросили нас нет смысле картинка
[01:49:55.920 --> 01:50:04.080]  двухмерная но в плане у нас есть сам элемент чара они объединяются вот в эти блоки блоки
[01:50:05.080 --> 01:50:19.520]  ну допустим может что-то типа корневой корневой ну смотрите зачем это на самом деле сделано вот
[01:50:19.520 --> 01:50:29.520]  представьте вы локатор вы хотите написать вы хотите работать эффективно вы вот а еще вы в данном
[01:50:29.520 --> 01:50:34.140]  случае вот эта штука вы даже не локатор вы memory ресурс и вы должны алоцировать память
[01:50:34.140 --> 01:50:40.440]  разных размеров должны алоцировать инты должны алоцировать указатели чары массивы всего этого
[01:50:40.440 --> 01:50:49.760]  это все очень разного размера и вы хотите эффективно это выделять и возвращать ну не совсем то
[01:50:49.760 --> 01:50:57.800]  есть смотрите вот давайте представить что мы взяли наш кто-то стек локатор из листа и захотели
[01:50:57.800 --> 01:51:07.440]  научить его удалять память типа как как это можно было бы сделать через бурю страдания у нас
[01:51:07.440 --> 01:51:22.560]  есть задача нам уже рассказывали хранить эти отрезки и сливать хранить трески
[01:51:22.560 --> 01:51:30.880]  ну смотрите в чем у вас проблема вот у вас есть один большой кусок памяти
[01:51:30.880 --> 01:51:39.400]  правильно у вас попросили сначала не знаю вот столько потом попросили вот столько потом
[01:51:39.400 --> 01:51:52.240]  попросили вот столько потом вам говорят я хочу освободить вот скажем вот эту память
[01:51:52.240 --> 01:52:06.560]  да ну типа например мы все эти отрезки храним в каком-то сете отрезки памяти
[01:52:06.560 --> 01:52:15.280]  свободно смотрим что справа что справа и возможно их вот как вот когда мы выделяем как нам после
[01:52:15.280 --> 01:52:22.720]  этого находить вот нам нам вот скажем у нас вот здесь был кусок и вот здесь вот был кусочек
[01:52:22.720 --> 01:52:43.680]  ну откуда-то найдем мы мы мы ресурс но да то есть окей то есть допустим если мы удалили потом
[01:52:43.680 --> 01:52:52.240]  вот эти две штуки мы их как-то там хитро объединяем ким толгосом в общую память и потом когда нас
[01:52:52.240 --> 01:53:03.600]  попросили допустим вот столько памяти мы должны как-то найти вот это окей вот утверждается что
[01:53:03.600 --> 01:53:10.600]  значит можно выделять память быстрее чем двоичным деревьев поиска вот так смотрите за от одного ну
[01:53:10.640 --> 01:53:19.600]  смотрите вот у нас есть допустим да чанхи допустим здесь не знаю 4 байта здесь 8 байт здесь 16 байт вас
[01:53:19.600 --> 01:53:33.760]  попросили выделить инт что вы делаете так этого недостаточно просто берем отщипываем отсюда
[01:53:33.760 --> 01:53:42.000]  выделяем блок окей нас попросили память 7 байт что мы делаем просто выделяем из восьмерки
[01:53:42.000 --> 01:53:47.520]  всю восьмерку даем пофиг мы выделили немножко лишнего зато зато быстро
[01:53:47.520 --> 01:54:00.080]  он умеет удалять еще вот вот в общем у нас получается такая система
[01:54:04.760 --> 01:54:20.960]  в целом да там ну как вариант мы можем хранить просто список из блоков действительно типа
[01:54:20.960 --> 01:54:26.200]  фрилли свободных блоков если мы освобождаем чан какой-то мы его в конец листа докидываем и
[01:54:26.200 --> 01:54:39.960]  все у нас все операции 100 единиц вот ну это вот типа теория как как как это примерно работает
[01:54:39.960 --> 01:54:48.920]  зачем-то примерно люди хотели вот да ну вопрос что он делает если у него что делать если нас
[01:54:48.920 --> 01:54:57.640]  попросили 32 байта памяти ну вот нет нельзя два по 16 потому что если мы хотим очень просто
[01:54:57.640 --> 01:55:08.520]  всем этим работать не могут 32 да значит ну что делает pool ресурс он горит так значит у меня
[01:55:08.520 --> 01:55:13.760]  закончилась память попрошу кого-нибудь у кого памяти есть вот мы ему можем указать у кого
[01:55:13.760 --> 01:55:18.320]  просить памяти если памяти нет если мы ему не укажем он будет просить из дефолта ресурса
[01:55:18.320 --> 01:55:29.000]  вот и просто сразу грит все прошу 32 я отдаю и не думаю вот такая идея значит идейно это было
[01:55:29.000 --> 01:55:36.920]  сделать сделано чтобы быть быстрее я в прошлом году замерял на каких-то многих разных тестах
[01:55:36.920 --> 01:55:45.560]  время типа сравнивал вот этот pool локатор и new delete локатор по моему у меня на моих тестах
[01:55:45.560 --> 01:55:51.640]  ни разу не получилось обогнать new delete потом я нашел где-то на реддите пост от человека который
[01:55:51.640 --> 01:55:56.920]  его имплементировал в одной из тестов дали он сказал что вот как-то так работает но я не
[01:55:56.920 --> 01:56:02.080]  знаю как обгонять молок молок слишком быстрый ну потому что на самом деле внутри молок почти
[01:56:02.080 --> 01:56:06.720]  наверное делает еще что-то вот то же самое если мы наворачиваем что-то похожее сверху это не очень
[01:56:06.720 --> 01:56:24.800]  да но new delete не всегда обращается к еду у new delete тоже внутри какие-то свои структуры на
[01:56:24.800 --> 01:56:45.400]  самом деле да да мы себе вот как-то монотоник buffer resource он тоже обгонит типа и pool и молок
[01:56:45.400 --> 01:56:51.520]  обгонит все нормально но проблема в том что он не чистит ни фига ну да он вообще ничего не
[01:56:51.520 --> 01:56:57.160]  запоминает вот у него нет вот этой все надстройки это можно чистить если мы удалили ровно последний
[01:56:57.160 --> 01:57:06.320]  элемент да это можно больше мы ничего не умеем это можно делать да как ты будешь это все отслеживать
[01:57:06.320 --> 01:57:13.360]  не имеется в виду что можно удалить только только последний выделенный если нам пришел запрос на
[01:57:13.360 --> 01:57:21.960]  удаление элемента и это вдруг последний выделенный ну давай честно удалим его да и все в смысле
[01:57:21.960 --> 01:57:26.840]  освободим память скажем что мы ее можем рьюзить так вот не можем нас может быть что-то не удаленно
[01:57:26.840 --> 01:57:34.840]  еще слева то что удалили последнего чувака это значит что мы можем его памяти рьюзить его да ну я
[01:57:34.840 --> 01:57:43.800]  в этом и говорю нет ну смотри
[01:57:43.800 --> 01:58:01.640]  просто в конец ну или в начало как удобнее
[01:58:05.400 --> 01:58:12.840]  у нас эти блоки не обязаны быть подряд типа окей вот соответственно что еще тут нужно сказать что
[01:58:12.840 --> 01:58:25.520]  вот у pull memory ресурса и на самом деле у monotonic memory buffer ресурса они умеют принимать ну скажем вот
[01:58:25.520 --> 01:58:40.320]  мы можем взять какой-нибудь char ray 100 передать сюда ray 100 и еще можем передать откуда брать
[01:58:40.320 --> 01:58:46.160]  если у нас закончилось можем там несколько буферов сделать и вот они также будут делать если
[01:58:46.160 --> 01:58:51.640]  память у них самих закончилась братью следующего вот это про то что я говорил про комбинацию
[01:58:51.640 --> 01:59:03.520]  нескольких локаторов вот окей с этим вопросов нет вот если у вас типа сейчас заставить
[01:59:03.520 --> 01:59:15.080]  реализовать полиморфик локатор вы понимаете как это сделать ну давайте попробуем супер быстро
[01:59:15.080 --> 01:59:32.000]  нет сейчас тут все очень просто давайте попробую я попробую написать какой-то
[01:59:32.000 --> 01:59:39.960]  вместе с вами а он есть все так то есть у нас действительно есть стракт
[01:59:39.960 --> 01:59:48.560]  в какой момент
[01:59:48.560 --> 02:00:04.880]  как как сделать полиморфик локатор вот давайте что должно быть бейс ресурса
[02:00:04.880 --> 02:00:20.600]  метод чтобы выделить метод чтобы освободить ну в целом да но что он должен быть ну какой-нибудь
[02:00:20.600 --> 02:00:43.000]  допустим do allocate что он что он принимает сайс и но alignment да кажется все вот прям так
[02:00:43.000 --> 02:00:55.680]  ну на самом деле можно делать allocate просто есть такой паттерн в целом который кажется и
[02:00:55.680 --> 02:01:04.760]  используется в том числе здесь что у вас сама функция locate будет выглядеть как-то так
[02:01:04.760 --> 02:01:33.680]  вот звездочка locate что еще да ну смысле там куча разных конструкторов вообще делает вот так
[02:01:33.680 --> 02:01:42.240]  в чем смысл так делать ну в целом как паттерн это используется чтобы например у вас могла быть
[02:01:42.240 --> 02:01:47.960]  какая-то общая логика в базовом классе ну как это самый банальный пример вы-то можете логировать
[02:01:47.960 --> 02:01:53.760]  вас неважно какой ну класс под вами это кажется совсем бесполезно вы просто делали
[02:01:53.760 --> 02:02:00.120]  до allocate чтобы написать лишнего кода и просто ну да не типа я могу переносить на allocate
[02:02:00.120 --> 02:02:25.840]  смысл самого локатора в том что вы можете написать любой ресурс и не меняя никаких типов
[02:02:25.840 --> 02:02:37.960]  программе просто взять его и другой это типа удобство использования ну второй дефолт не стоит
[02:02:37.960 --> 02:02:47.640]  мак салант это ну тут действительно locate без долога потому что это не имеется да это правда
[02:02:47.640 --> 02:03:03.040]  но это просто такая опция такой вот кусочек из тд либо вот можно пользоваться можно не
[02:03:03.040 --> 02:03:11.320]  пользоваться я в целом согласен то есть насколько я понимаю на самом деле а локаторы они пришли
[02:03:11.320 --> 02:03:19.280]  изначально вообще из там других побуждений они на старых каких-то архитектурах помогали
[02:03:19.280 --> 02:03:26.160]  работать с поинтерами разных размеров но и со временем из-за локаторов выпилили почти все
[02:03:26.160 --> 02:03:31.920]  оставили практически только работу с памятью вот memory resource это как бы такая штука которая
[02:03:31.920 --> 02:03:37.280]  вот абсолютно абстрагируется от всяких конструирований муссимантики вот этого всего
[02:03:37.280 --> 02:03:42.040]  просто выделяет память и как бы для удобства использования если вам просто нужно какой-то
[02:03:42.040 --> 02:03:49.200]  новый способ выделять память вы можете так сделать да вы платите тем что вызываете виртуальные
[02:03:49.200 --> 02:03:56.280]  функции виртуальных функций дороже чем просто вот но как бы если вы по умолчанию считаете что
[02:03:56.280 --> 02:04:02.600]  алоцирование это дорогая операция то и делать ее не слишком часто наверное это в каких-то
[02:04:02.600 --> 02:04:15.080]  ситуациях вполне приемлемый трейдов как реализуем вот у нас какой-то бейс ресурс у нас есть
[02:04:15.080 --> 02:04:22.480]  локатор ну давай подумаем что он хранить ну наверное он хранит у себя
[02:04:22.480 --> 02:04:33.080]  бейс ресурс звездочка когда мы вызываем у него locate который выглядит кажется примерно так же
[02:04:33.080 --> 02:04:54.240]  мы просто завем allocate да все есть там ну констракт нам нужно какой-то ну как обычно
[02:04:54.240 --> 02:04:58.880]  как у локатора делаем констракт но вроде не нужен какой констракт это на самом деле реально очень
[02:04:58.880 --> 02:05:05.520]  простая концепция которая как раз для удобства сделано вот поэтому тут никаких хитростей не
[02:05:05.520 --> 02:05:20.520]  нужно все поэтому по этой части есть какие-то вопросы еще что зачем когда откуда почему в чем
[02:05:20.520 --> 02:05:39.320]  полимортность потому что полимортные функции ну смотри например мы тут просто мы должны что-то
[02:05:39.320 --> 02:05:46.760]  понять написать конструктор локатора от бейс ресурс звездочки и тогда но будет просто приравнивать
[02:05:46.760 --> 02:05:54.920]  это поле все ну да смотри к преимущества захотел ты написать дек на ты понимаешь что у тебя есть
[02:05:54.920 --> 02:05:59.560]  какая-то ситуация ты не знаю считываешь много данных что ты по нему считаешь сразу все удаляешь
[02:05:59.560 --> 02:06:04.480]  ты понимаешь что это операция у тебя часто используется занимает много времени в том числе
[02:06:04.480 --> 02:06:10.880]  потому что ты вектор там например pushback и алоцируешь много раз память такой окей как я
[02:06:10.880 --> 02:06:15.560]  могу это оптимизировать или даже лист вот листы нам на каждый pushback в лист будешь алоцировать
[02:06:16.040 --> 02:06:25.760]  такой хочу стэка локатор как это сделать все берешь готовый ресурс нужный те в том случае
[02:06:25.760 --> 02:06:36.680]  monotonic buffer подключаешь его готово альтернативно ты бы мог написать стэка локатор свой но его
[02:06:36.680 --> 02:06:48.560]  нужно писать ну я говорю да это штука ну типа для удобства в теории каждую из этих штук ты
[02:06:48.560 --> 02:07:00.200]  мог бы нет нет картину резко не поворачивает ну и плюс тут именно это это все для удобства если
[02:07:00.200 --> 02:07:05.360]  ты придумал какой-то свой новый способ выделять память просто пишешь наследуешься там стд memory
[02:07:05.360 --> 02:07:12.080]  ресурс пишешь свой ресурс и все просто подключаешь его готовый код все замечательно ничего
[02:07:12.080 --> 02:07:31.520]  сверх интеллектуального тут нет ну смысл ты просто вот вот вот здесь тебе был раньше res 2
[02:07:31.520 --> 02:07:36.160]  а теперь будет там res 1
[02:07:36.160 --> 02:07:51.720]  опа и все res 3 res 1 у меня нет тут вообще никакого подвоха нет все мне кажется максимально просто
[02:07:51.720 --> 02:08:03.680]  потому что вот это вот один тип у него просто разные ресурсы ну типа для удобства все
[02:08:03.680 --> 02:08:12.800]  можешь ли ты написать свой стэк локатор можешь ну вот тут сделано так
[02:08:12.800 --> 02:08:18.680]  еще вопрос почему такой локатор позволяет нам решить проблем не в скопе локатора ну как
[02:08:18.680 --> 02:08:24.880]  когда вот у нас вот это стринг и мы хотим чтобы и стрит чтобы стрим использовала тот же
[02:08:24.880 --> 02:08:31.480]  локатор что используем ну вот там дек дек строк у нас была проблема что мы хотим вот у нас
[02:08:31.480 --> 02:08:37.320]  строка где-то алоцируется мы хотим чтобы там же строка алоцировала и свои приколы вот как
[02:08:37.320 --> 02:08:45.680]  этот локатор решает эту проблему как он решает проблему что вопрос я даже
[02:08:53.280 --> 02:08:56.880]  вот что изменилось почему нам стало
[02:08:56.880 --> 02:09:04.920]  лучше чем полиморфик локатор отличается от обычного что он позволил нам вот так вот
[02:09:18.920 --> 02:09:22.200]  ну вот тут написано давайте разберемся
[02:09:26.880 --> 02:09:51.120]  да да да все как он это делает вот значит нас есть стд юзис локатор что он делает
[02:09:51.120 --> 02:10:16.480]  илья помнишь это что делает стд юзис локатор вот ладно честно говоря я
[02:10:16.480 --> 02:10:25.400]  ну смотри тут просто меня спросили как он делает так чтобы строка из дека
[02:10:25.400 --> 02:10:36.240]  использовала тот же локатор что и сам дек вот мне цепи референс рассказывает что значит
[02:10:36.240 --> 02:10:53.240]  используя юзис локатор он как-то этого добивается я честно говоря даже не задумывался об этом
[02:11:06.240 --> 02:11:17.520]  строка использовала тот мемори ресурс короче мы хотим как-то его заменить заменить ну мы не
[02:11:17.520 --> 02:11:28.720]  можем уже заменить так какую проблему он решал он решал проблему что мы хотели чтобы строка
[02:11:28.720 --> 02:11:47.620]  использовала тот же локатор да ну просто локатор прик clever при создании строки мы укажем
[02:11:47.620 --> 02:11:57.320]  локатор и передадим в аргумент Эрак локатор а тот же ресурс который в нашем локатор до
[02:11:57.320 --> 02:12:08.840]  да, да, все так. Ну и все. Ну давай лучше перенесем тогда
[02:12:08.840 --> 02:12:13.840]  этот разговор в чат, ты спроси и мы подробно ответим.
[02:12:38.840 --> 02:12:50.840]  Ну если мы везде пользуемся дефолтным ресурсом, то да.
[02:12:50.840 --> 02:13:07.840]  Безусловно, я не знаю, как это относится к нашей теме.
[02:13:09.840 --> 02:13:16.840]  Ладно, давайте, ну, давайте быстро поговорим все-таки о второй части.
[02:13:16.840 --> 02:13:22.840]  Ну то есть, если единственный вопрос, который остался, это как...
[02:13:22.840 --> 02:13:30.840]  Ну сейчас, я на самом деле не вижу проблемы. Действительно, у нас же, что такое
[02:13:30.840 --> 02:13:36.840]  ПМАР-дек, ПМАР-строк. Вот ПМАР-строка это строка с нашим аллокатором.
[02:13:36.840 --> 02:13:43.840]  Окей? Теперь все аллокаторы, если мы живем в мире ПМАР, это полиморфик аллокаторы.
[02:13:43.840 --> 02:13:46.840]  Они друг от друга отличаются только тем ресурсом, который они используют.
[02:13:46.840 --> 02:13:52.840]  Мы просто при создании строки в ее аллокатор передадим наш ресурс, и все.
[02:13:52.840 --> 02:13:56.840]  А, ну окей, сейчас все, я, кажется, понял. Кажется, сколп, аллокатор, адаптер, он решал
[02:13:56.840 --> 02:14:02.840]  проблему не в памяти, а конструирование. Ну, кажется, у нас там была разница в том, как
[02:14:02.840 --> 02:14:08.840]  конструировать. Сейчас, я, кажется, понял. Вот есть подозрение, что если мы напишем вот так,
[02:14:08.840 --> 02:14:14.840]  то больше это будет неправда. Неправда, что мы будем пользоваться тем же ресурсом
[02:14:14.840 --> 02:14:24.840]  памяти, что и раньше. Ну, потому что мы можем сделать, ну типа, мы можем сделать строку
[02:14:24.840 --> 02:14:30.840]  над нашим стек-аллокатором. Отдельный тип. Если мы передадим ее в дек, вот так же, как сейчас,
[02:14:30.840 --> 02:14:37.840]  вот эта строка, это на самом деле строка от STD-аллокатора дефолтного. Она, очевидно, не может
[02:14:37.840 --> 02:14:48.840]  использовать нашу штуку. Значит, мы передаем тот же ресурс только для PMR-строки. Ну, как это сделать
[02:14:48.840 --> 02:14:59.840]  для PMR-строки, очевидно. Ладно, давай, действительно, если ты попробуешь сформулировать вопрос
[02:14:59.840 --> 02:15:07.840]  чаще разберемся. Значит, у нас есть еще одна штука сегодня. Вариант. Мы только начнем о нем
[02:15:07.840 --> 02:15:13.840]  говорить сегодня. Смотрите, есть STD-вариант. Что такое STD-вариант? Вот, это такая переменная,
[02:15:13.840 --> 02:15:20.840]  которая хранит один из выбранных типов. Что-то такое мы сегодня уже видели. Что такое вы сегодня
[02:15:20.840 --> 02:15:31.840]  уже видели? Как же это вас называлось? Юнион. Да, вот это, на первый взгляд, примерно то же самое,
[02:15:31.840 --> 02:15:36.840]  что и юнион. Вот давайте попробуем разобраться, почему это лучше, чем юнион. Вот давайте представим,
[02:15:36.840 --> 02:15:46.840]  что у нас есть юнион. Да, он сам будет разбираться с тем, как почистить планет. О да. В том числе.
[02:15:46.840 --> 02:15:55.840]  То есть это юнион только осмысленный? Ну, видимо, что-то вроде того. То есть, сейчас мы написаем,
[02:15:55.840 --> 02:16:20.840]  как я бы пользовался этим юнионом? Я бы мог написать s.s равно
[02:16:20.840 --> 02:16:30.840]  А вот сам. Так, ну только сейчас. Не мог бы, потому что конструктор для s-ки нужно определять.
[02:16:30.840 --> 02:16:39.840]  Во-первых, нужен конструктор для юниона? Так. Тебе в s, в юнионе нужно явно определить конструктор,
[02:16:39.840 --> 02:16:45.840]  потому что он не умеет дефолтный создавать. Все так. Потому что у тебя стринг или... Все так.
[02:16:45.840 --> 02:16:57.840]  Короче, уже хочется выбрать. Уже хочется, да. Так, сейчас. Ну я же как-то явно могу. Нет? Не надейся.
[02:16:57.840 --> 02:17:05.840]  Не могу. У тебя и вектор, и стринг имеют нетривиальные конструкторы по умолчанию? Нельзя. Очень жаль.
[02:17:05.840 --> 02:17:18.840]  Окей. Ну давайте еще диструктор, на всякий случай. Да, диструктор тоже требуется. Да.
[02:17:18.840 --> 02:17:29.840]  А теперь ты не создал. Вот, окей. У нас есть такая штука. Если хочу теперь записать сюда вектор, я, очевидно,
[02:17:29.840 --> 02:17:50.840]  что должен сделать? Возможно, вы вообще должны вот так сделать. Вы правы. Что вроде, значит, адрес...
[02:17:50.840 --> 02:18:05.840]  Адрес... Попросить юниона ничего нельзя. Ну в смысле, здесь ты хочешь STD Basic String написать от?
[02:18:05.840 --> 02:18:19.840]  Нет, все. Не хочу даже. Короче, сжечь нафиг все. Что еще сделать?
[02:18:19.840 --> 02:18:33.840]  С конструирует с отпускной строки. Да, наверное. Давайте U.
[02:18:33.840 --> 02:18:51.840]  U. Теперь можно написать U.S равно Abatsaba. Это правда. Вот, но теперь чтобы записать вектор, мы должны сначала разрушить строку,
[02:18:51.840 --> 02:18:59.840]  вызвать руками диструктор, потом создать вектор, и потом в конце программы не забыть еще руками вызвать диструктор вектора.
[02:18:59.840 --> 02:19:13.840]  Именно так. Да. Не забыть повеситься в конце этого всего действия. Чтобы делать не ручками, нам подарили STD вариант.
[02:19:13.840 --> 02:19:23.840]  Это чтобы забыть повеситься в конце этого. Да, значит, смотрите, мы можем сделать STD String и STD Vector.
[02:19:23.840 --> 02:19:37.840]  Интуов. Чаров. Класс. Мы можем написать V. Вот V. не можем написать, как и с туплом, очевидно.
[02:19:37.840 --> 02:19:47.840]  Ну, а мы можем написать STD. Мы можем написать, знаете, что? Мы можем написать V равно STD Vector.
[02:19:47.840 --> 02:19:57.840]  Вот так мы можем написать. Просто через равно. Все сработает, никакого UB. Стоп, а он у вас?
[02:19:57.840 --> 02:20:07.840]  Потом мы можем написать V равно. Почему нет? У вас не получится, что у него размер 97 теперь.
[02:20:07.840 --> 02:20:15.840]  Чего? Сейчас, подожди, у кого размер 97? Возможно, там, например, хранится первым полем вектора Чаров его размер.
[02:20:15.840 --> 02:20:25.840]  Так. Не-не-не, я же фигурные скольточки написал.
[02:20:25.840 --> 02:20:35.840]  Ниш, так можно писать. По-моему, лучше просто... Я могу его так написать без проблем.
[02:20:35.840 --> 02:20:45.840]  Сейчас, давай проверим, хорошо. Можем писать STD SEOUT.
[02:20:45.840 --> 02:20:53.840]  Ну, в смысле, я уверен, что тут тоже все в порядке. Я вам сейчас докажу.
[02:20:53.840 --> 02:21:04.840]  Смотрите, вопрос. Я хочу вывести, скажем, последний элемент вектора, который лежит в варианте.
[02:21:04.840 --> 02:21:10.840]  Что я могу сделать? Чтобы это сделать, я пишу STD GET.
[02:21:10.840 --> 02:21:19.840]  GET что? Как и в тупле, точно так же. Я могу обратиться GET либо к типу, либо к индексу.
[02:21:19.840 --> 02:21:31.840]  То есть, я могу сказать STD Vector Char. Дай мне, пожалуйста, свой STD Vector Char. V и .back.
[02:21:31.840 --> 02:21:43.840]  Да. Он активно это делает в рентайме. Вот. Вот это сработает.
[02:21:43.840 --> 02:21:56.840]  Значит, вопрос. Что будет, если мы напишем вот так? Вот так.
[02:21:56.840 --> 02:22:15.840]  Да. Он поймет, что мы делаем что-то не то и кинет нас исключением. Смотрите.
[02:22:15.840 --> 02:22:29.840]  Давай теперь. Все прекрасно. Мы увеличили B и потом мы получили Bad Variant Access.
[02:22:29.840 --> 02:22:48.840]  Попросили тот тип, который сейчас активный. Можно?
[02:22:48.840 --> 02:23:03.840]  Давайте я тогда вот так сделаю. Да, было бы славно.
[02:23:03.840 --> 02:23:21.840]  Да. Ну, это он и есть. Вот размер два, если кто-то сомневался.
[02:23:21.840 --> 02:23:32.840]  Можем ли мы получить тип, не выстреливая себе в ногу и не используя Tray Catch?
[02:23:32.840 --> 02:23:39.840]  Получить тип. Спросить, что в тебе хранится. Смотри, а как ты себе это представляешь? Что тебе эта функция должна возвратить?
[02:23:39.840 --> 02:23:49.840]  Нет. Скорее хотелось бы уметь вызывать функцию, которая определена для всех типов, которые содержатся в STD Variant, чтобы она корректно работала.
[02:23:49.840 --> 02:24:01.840]  Так. Какая еще раз функция? Ну, например, у вас для всех типов определена функция Shout и хотелось бы, чтобы вызываясь просто STD Variant, она выводила...
[02:24:01.840 --> 02:24:12.840]  Я понял, чего ты хочешь. Ты хочешь, чтобы я мог написать вот этот STD Get Back и чтобы он сработал и для вектора, и для строки. А я на самом деле могу так сделать.
[02:24:12.840 --> 02:24:25.840]  Ну давайте, смотрите. У нас есть функция, которая лежит рядом с вариантом, называется STD Visit.
[02:24:25.840 --> 02:24:30.840]  А если там еще Get лежит, то оно не свободно, да?
[02:24:30.840 --> 02:24:35.840]  Ну да. Ну сейчас посмотрим. Смотрите, STD Visit принимает...
[02:24:35.840 --> 02:24:42.840]  Я хотелось бы, например, уметь копировать текущие активные члены из STD Variant.
[02:24:42.840 --> 02:24:50.840]  Ну, у него есть индекс. Вы можете позвать v.index. Он вернет вам индекс активного типа.
[02:24:50.840 --> 02:24:52.840]  Ну это и факт надо.
[02:24:52.840 --> 02:24:56.840]  Ну, еще раз. Вот давай. Представим. Ты хочешь...
[02:24:56.840 --> 02:25:03.840]  Я хочу вне зависимости от того, что в нем лежит, сказать, вот возьми, что в тебе сейчас активно, запиши мне переменную под названием S.
[02:25:03.840 --> 02:25:05.840]  А какого типа эта переменная?
[02:25:05.840 --> 02:25:07.840]  Я не могу даже да, понятно.
[02:25:07.840 --> 02:25:12.840]  Ну, ты можешь очевидно приравнивать один Variant к другому. Это нормально.
[02:25:12.840 --> 02:25:20.840]  Ну вот, смотри. Visit. Он почему-то сначала принимает лямду. Ну не лямду, а какой-то visitor.
[02:25:21.840 --> 02:25:25.840]  Это что-то, что можно вызвать.
[02:25:29.840 --> 02:25:37.840]  И мы на этом item давайте возьмем и вызовем, собственно, вот это.
[02:25:51.840 --> 02:25:55.840]  И мы потом передаем сам Variant.
[02:25:55.840 --> 02:25:59.840]  Вот. И теперь мы можем вот это удалить.
[02:25:59.840 --> 02:26:04.840]  Вызвать точно такой же visit вот здесь.
[02:26:08.840 --> 02:26:13.840]  И сейчас работает ровно так, как ты хотел.
[02:26:13.840 --> 02:26:15.840]  B, A.
[02:26:15.840 --> 02:26:20.840]  Потому что у Vector последняя B, у строки последняя A.
[02:26:23.840 --> 02:26:25.840]  Вот.
[02:26:27.840 --> 02:26:34.840]  Как это работает? Вопрос сложный и не требующий спешки.
[02:26:37.840 --> 02:26:40.840]  Давайте сначала посмотрим, что мы с этим можем сделать.
[02:26:41.840 --> 02:26:46.840]  Давайте быстренько загляну, смотри, что ничего не забыл.
[02:26:50.840 --> 02:26:57.840]  Ink в эту же структуру. Без проблем. Но тогда мы не скомпилируемся.
[02:27:05.840 --> 02:27:09.840]  Так, сначала Vector, потом строка, да.
[02:27:11.840 --> 02:27:15.840]  Да, ну смотри, ну теперь если мы уберем Back,
[02:27:15.840 --> 02:27:19.840]  просто будем вводить item. На самом деле мы можем больше сделать.
[02:27:20.840 --> 02:27:25.840]  Да, и теперь уберем Vector отсюда. Снова заработает.
[02:27:25.840 --> 02:27:50.840]  Да, да. Именно так. Более того, он, ну как бы, что еще интересно,
[02:27:50.840 --> 02:27:55.840]  вы можете сделать вот так. Нет, так вы не можете сделать.
[02:27:55.840 --> 02:28:03.840]  Ну хорошо, ну вы можете написать int816t1.
[02:28:05.840 --> 02:28:09.840]  И смотрите, что здесь произошло, почему это важно?
[02:28:09.840 --> 02:28:19.840]  Это он. Ну я хочу вам показать, что мы приравниваем наш вариант к int16.
[02:28:19.840 --> 02:28:30.840]  И он все еще компилируется, потому что один из его типов умеет, ну типа, может сконструироваться от int16, это int.
[02:28:30.840 --> 02:28:42.840]  Если здесь будет еще int64t, ну давайте int64t.
[02:28:42.840 --> 02:28:48.840]  Скомпилировалось. А что мы получим?
[02:28:48.840 --> 02:28:55.840]  В смысле, да. У нас какой активный член тогда? Есть вопрос.
[02:28:55.840 --> 02:29:05.840]  Есть вопрос, давайте посмотрим. Ну, значит он решил, что какой-то из них более подходящий.
[02:29:05.840 --> 02:29:10.840]  Ну это реально выстрелом в ногу.
[02:29:10.840 --> 02:29:15.840]  Вопрос работает ли, это просто по правилам перегрузки.
[02:29:15.840 --> 02:29:22.840]  Да, кажется. Один, значит int, ну в целом, справедливо.
[02:29:22.840 --> 02:29:26.840]  Почему? Несправедливо.
[02:29:26.840 --> 02:29:28.840]  Мы куда угодно могли записать.
[02:29:28.840 --> 02:29:34.840]  Ну, смотри, если мы здесь делаем, так, нужен какой-нибудь пример, когда касс будет точно неоднозначный.
[02:29:34.840 --> 02:29:38.840]  А, кстати, давай прямо попробуем в другом порядке, сначала int64t, потом int.
[02:29:38.840 --> 02:29:41.840]  А это ничего не изменит.
[02:29:41.840 --> 02:29:42.840]  А сейчас посмотрим.
[02:29:42.840 --> 02:29:45.840]  Ну, вообще не должно. Я уверен, что не изменит.
[02:29:45.840 --> 02:29:47.840]  В первое совпадение положил просто.
[02:29:47.840 --> 02:29:48.840]  Представь, что у тебя два конструктора.
[02:29:48.840 --> 02:29:49.840]  Изменило?
[02:29:49.840 --> 02:29:50.840]  Изменило, изменило.
[02:29:50.840 --> 02:29:51.840]  Да.
[02:29:51.840 --> 02:29:52.840]  А, нет.
[02:29:52.840 --> 02:29:55.840]  Ну, в смысле, он int все еще. Все еще int.
[02:29:55.840 --> 02:29:56.840]  Это логично.
[02:29:56.840 --> 02:29:57.840]  Да.
[02:29:57.840 --> 02:30:00.840]  То есть точно нельзя два int положить?
[02:30:00.840 --> 02:30:03.840]  Два int, а два int можно положить.
[02:30:03.840 --> 02:30:04.840]  Что?
[02:30:04.840 --> 02:30:07.840]  Ну, он теперь типа не понимает.
[02:30:07.840 --> 02:30:17.840]  Смотрите, вот здесь, это легальное объявление переменной типа variant, но теперь он не понимает вот здесь, что ему делать.
[02:30:17.840 --> 02:30:22.840]  А какое разумеет, когда оно полезно?
[02:30:22.840 --> 02:30:25.840]  Я, честно говоря, не знаю.
[02:30:25.840 --> 02:30:26.840]  Все нормально.
[02:30:26.840 --> 02:30:30.840]  Я, у меня в голове примера, когда это полезно, нет.
[02:30:30.840 --> 02:30:32.840]  Вот.
[02:30:32.840 --> 02:30:35.840]  Ну, потому что бесполезно, наверное.
[02:30:35.840 --> 02:30:37.840]  Вот, да.
[02:30:37.840 --> 02:30:39.840]  У нас видит вызывается только один раз.
[02:30:39.840 --> 02:30:41.840]  То есть, если мы посмотрим был, то у нас...
[02:30:41.840 --> 02:30:43.840]  Там 30, там 1000.
[02:30:43.840 --> 02:30:45.840]  А 1 – это индекс.
[02:30:45.840 --> 02:30:46.840]  Да, да.
[02:30:46.840 --> 02:30:49.840]  Ну, в смысле, потому что видит вызывается на активном элементе.
[02:30:49.840 --> 02:30:50.840]  Активно?
[02:30:50.840 --> 02:30:51.840]  Да.
[02:30:51.840 --> 02:30:52.840]  Да.
[02:30:52.840 --> 02:30:53.840]  Все, все, понятно.
[02:30:53.840 --> 02:30:54.840]  Вот.
[02:30:54.840 --> 02:30:55.840]  Что еще важно сказать?
[02:30:55.840 --> 02:30:59.840]  Variant после создания активный первый элемент.
[02:30:59.840 --> 02:31:01.840]  Вот, видите, сначала...
[02:31:01.840 --> 02:31:02.840]  А, ну, мы не вводим.
[02:31:02.840 --> 02:31:05.840]  В общем, вот эта вот штука выведет ноль.
[02:31:05.840 --> 02:31:08.840]  Соответственно, видите ли вы проблему?
[02:31:08.840 --> 02:31:10.840]  Дефолт для конструктора?
[02:31:10.840 --> 02:31:11.840]  Да.
[02:31:11.840 --> 02:31:13.840]  Если у вас, скажем...
[02:31:13.840 --> 02:31:17.840]  Ну, ни у одного из типов, которые вы хотите вариант передать, нет дефолтного конструктора.
[02:31:17.840 --> 02:31:19.840]  Что делать?
[02:31:21.840 --> 02:31:23.840]  Стандартная библиотека идет к вам на помощь.
[02:31:23.840 --> 02:31:25.840]  У нее есть специальный тип.
[02:31:25.840 --> 02:31:28.840]  Std monostate.
[02:31:32.840 --> 02:31:33.840]  Это пустой...
[02:31:33.840 --> 02:31:34.840]  Ломаем все виды.
[02:31:34.840 --> 02:31:37.840]  Это просто пустая структура, которая нужна для такого случая.
[02:31:37.840 --> 02:31:38.840]  А сколько?
[02:31:38.840 --> 02:31:39.840]  Можно вопросить?
[02:31:39.840 --> 02:31:40.840]  Да.
[02:31:40.840 --> 02:31:44.840]  Что это в Std пустых структур с различными именами?
[02:31:44.840 --> 02:31:46.840]  Много.
[02:31:46.840 --> 02:31:48.840]  Тейди как минимум.
[02:31:48.840 --> 02:31:49.840]  Вот.
[02:31:49.840 --> 02:31:50.840]  Есть monostate.
[02:31:50.840 --> 02:31:52.840]  Про него полезно знать.
[02:31:52.840 --> 02:31:53.840]  Visit.
[02:31:53.840 --> 02:31:54.840]  Вот так работает.
[02:31:54.840 --> 02:31:55.840]  Get.
[02:31:55.840 --> 02:31:56.840]  Понятно.
[02:31:56.840 --> 02:31:57.840]  Через дрансу можно присваивать.
[02:31:57.840 --> 02:32:00.840]  Что еще полезно знать про варианты?
[02:32:00.840 --> 02:32:04.840]  Для них определены хэш и сравнение.
[02:32:04.840 --> 02:32:06.840]  Значит, вы можете пихать их в мапу и в хэш-мапу.
[02:32:06.840 --> 02:32:07.840]  Сейчас.
[02:32:07.840 --> 02:32:09.840]  А как сравнивать?
[02:32:09.840 --> 02:32:12.840]  То есть для пара они не определили хэш?
[02:32:17.840 --> 02:32:18.840]  Сейчас.
[02:32:18.840 --> 02:32:19.840]  Не-не-не.
[02:32:19.840 --> 02:32:20.840]  Ты что?
[02:32:20.840 --> 02:32:21.840]  Нет.
[02:32:21.840 --> 02:32:22.840]  Какой интерпретер звездочка?
[02:32:22.840 --> 02:32:23.840]  Зачем?
[02:32:23.840 --> 02:32:24.840]  За что?
[02:32:24.840 --> 02:32:25.840]  Если у нас два разных типа активных, то это что?
[02:32:25.840 --> 02:32:26.840]  А.
[02:32:26.840 --> 02:32:29.840]  Если два разных типа активных, то кажется это нельзя так.
[02:32:29.840 --> 02:32:33.840]  У меня очень много вопросов к разработчикам Std линии.
[02:32:33.840 --> 02:32:35.840]  Get по индексу.
[02:32:35.840 --> 02:32:36.840]  Что?
[02:32:36.840 --> 02:32:37.840]  Get по индексу можно.
[02:32:37.840 --> 02:32:40.840]  Тут у нас один объект.
[02:32:40.840 --> 02:32:45.840]  В.get от 0.
[02:32:45.840 --> 02:32:48.840]  Ну, от 1, чтобы сработало.
[02:32:48.840 --> 02:32:52.840]  Ну, то есть скорее всего так.
[02:32:52.840 --> 02:32:55.840]  А, потому что не v.get, а std.get.
[02:32:57.840 --> 02:32:58.840]  Так, что мне не нравится?
[02:32:58.840 --> 02:32:59.840]  А, потому что от v.
[02:32:59.840 --> 02:33:01.840]  Где три слыша подряд?
[02:33:08.840 --> 02:33:09.840]  Так.
[02:33:09.840 --> 02:33:10.840]  Окей.
[02:33:16.840 --> 02:33:17.840]  Вот.
[02:33:21.840 --> 02:33:22.840]  Что у нас еще есть?
[02:33:22.840 --> 02:33:24.840]  У нас есть helper функции variant-size.
[02:33:26.840 --> 02:33:31.840]  Variant-size возвращает сколько у нас типов просто в варианте.
[02:33:31.840 --> 02:33:33.840]  А get единичка это?
[02:33:33.840 --> 02:33:34.840]  Это альтернативный get.
[02:33:34.840 --> 02:33:36.840]  Ну, типа можно делать get по типу.
[02:33:36.840 --> 02:33:37.840]  А можно по индексу?
[02:33:37.840 --> 02:33:38.840]  А можно по индексу.
[02:33:38.840 --> 02:33:41.840]  То есть вот это и вот это одно и то же.
[02:33:41.840 --> 02:33:42.840]  Окей, хорошо.
[02:33:46.840 --> 02:33:47.840]  Вот.
[02:33:47.840 --> 02:33:48.840]  Это просто как этим всем пользоваться.
[02:33:48.840 --> 02:33:52.840]  Просто если у нас огромные типы, мы явно не хотим их писать каждый раз.
[02:33:52.840 --> 02:33:53.840]  Ну, может быть.
[02:33:53.840 --> 02:33:55.840]  А может быть у нас несколько типов.
[02:33:55.840 --> 02:33:56.840]  Вот.
[02:33:56.840 --> 02:33:57.840]  У нас тип имеет право повторяться.
[02:33:57.840 --> 02:34:01.840]  Поэтому иногда только по индексу можно.
[02:34:01.840 --> 02:34:02.840]  Сейчас.
[02:34:02.840 --> 02:34:03.840]  Да.
[02:34:03.840 --> 02:34:08.840]  Часто variant используется с полиморфными типами в том плане, что если мы храним
[02:34:08.840 --> 02:34:11.840]  как бы указатель на...
[02:34:11.840 --> 02:34:12.840]  То есть...
[02:34:12.840 --> 02:34:13.840]  Сейчас.
[02:34:13.840 --> 02:34:14.840]  Я...
[02:34:14.840 --> 02:34:15.840]  А если variant-size?
[02:34:15.840 --> 02:34:21.840]  Короче, мы можем в варианте хранить кучу указателей на разные структуры, которые являются...
[02:34:21.840 --> 02:34:25.840]  Ну, которые являются сыновьями какой-то базовой структуры, чтобы потом получать
[02:34:25.840 --> 02:34:28.840]  что-то, пытаться в родной мере поделить, что лежит под этим.
[02:34:28.840 --> 02:34:30.840]  В смысле, что лежит под этим.
[02:34:30.840 --> 02:34:32.840]  Пока все, что ты сказал, мы можем делать.
[02:34:32.840 --> 02:34:33.840]  Да.
[02:34:33.840 --> 02:34:37.840]  Про то, что у нас есть индекс, но мне очень понятно, как нам по индексу получать
[02:34:37.840 --> 02:34:38.840]  какой-то тип.
[02:34:41.840 --> 02:34:45.840]  Я пытаюсь понять, каким образом можно получить там...
[02:34:45.840 --> 02:34:46.840]  Что там в подробии?
[02:34:46.840 --> 02:34:48.840]  Decal type от v.tango.
[02:34:48.840 --> 02:34:49.840]  Variant-tango.
[02:34:49.840 --> 02:34:50.840]  Смотри.
[02:34:50.840 --> 02:34:53.840]  Есть такая штука, как holes-alternative.
[02:34:55.840 --> 02:34:57.840]  Так, давайте.
[02:34:58.840 --> 02:35:05.840]  Значит, holes-alternative позволяет нам понять, лежит тип или не лежит.
[02:35:07.840 --> 02:35:09.840]  А, variant-alternative.
[02:35:09.840 --> 02:35:10.840]  Был неправ.
[02:35:10.840 --> 02:35:11.840]  Вот.
[02:35:11.840 --> 02:35:13.840]  Мы можем позвать...
[02:35:18.840 --> 02:35:19.840]  А, нет.
[02:35:19.840 --> 02:35:20.840]  Мне это позволяет делать.
[02:35:20.840 --> 02:35:21.840]  Сейчас.
[02:35:21.840 --> 02:35:22.840]  Что такое variant-alternative?
[02:35:22.840 --> 02:35:24.840]  Что такое variant-alternative?
[02:35:24.840 --> 02:35:25.840]  Мы...
[02:35:27.840 --> 02:35:28.840]  Я нам наврал.
[02:35:29.840 --> 02:35:32.840]  Variant-alternative, она просто по...
[02:35:34.840 --> 02:35:35.840]  Так, ей нужен вообще вариант?
[02:35:36.840 --> 02:35:37.840]  Нет, не нужен.
[02:35:38.840 --> 02:35:46.840]  Мы просто выдаем ей единичку, выдаем ей, кажется, v.
[02:35:48.840 --> 02:35:51.840]  И это тип, который лежит в этом варианте по индексу.
[02:35:51.840 --> 02:35:52.840]  Что?
[02:35:52.840 --> 02:35:53.840]  Type name?
[02:35:53.840 --> 02:35:54.840]  И что?
[02:35:54.840 --> 02:35:57.840]  Нет какой-то конструкции, что в подробии, эквивалентный
[02:35:57.840 --> 02:36:00.840]  get авто каким-то левым боком.
[02:36:00.840 --> 02:36:01.840]  Еще раз.
[02:36:01.840 --> 02:36:02.840]  Get это авто?
[02:36:04.840 --> 02:36:07.840]  Можно мы каким-то образом variant в runtime определять его key?
[02:36:07.840 --> 02:36:08.840]  Вот вопрос такой.
[02:36:08.840 --> 02:36:09.840]  Без индекса.
[02:36:09.840 --> 02:36:10.840]  Без индекса.
[02:36:10.840 --> 02:36:13.840]  То есть, как бы непонятно, что мы индекс не можем передать
[02:36:13.840 --> 02:36:15.840]  в этот блок, просто потому, что это...
[02:36:15.840 --> 02:36:18.840]  Ну, мы не можем передать в этот блок.
[02:36:18.840 --> 02:36:19.840]  Ну да.
[02:36:19.840 --> 02:36:24.840]  Ну вот единственный способ определять тип в runtime-е,
[02:36:24.840 --> 02:36:26.840]  это полимортное предъятие.
[02:36:26.840 --> 02:36:27.840]  Что полимортное?
[02:36:27.840 --> 02:36:31.840]  Ну, в смысле, единственный способ, как мы можем определять
[02:36:31.840 --> 02:36:34.840]  тип в runtime, физический язык, если пусть тут ставится,
[02:36:34.840 --> 02:36:35.840]  то из того, что мы знаем.
[02:36:35.840 --> 02:36:36.840]  Да.
[02:36:36.840 --> 02:36:39.840]  Это пользоваться, ну, виртуальными функциями.
[02:36:39.840 --> 02:36:40.840]  Вот.
[02:36:40.840 --> 02:36:45.840]  Есть ли что-то, какое-то анало для variant?
[02:36:45.840 --> 02:36:46.840]  Ну, давай так.
[02:36:46.840 --> 02:36:47.840]  Что ты хочешь сделать?
[02:36:47.840 --> 02:36:49.840]  Ты хочешь типа запустить какой-то код, который если
[02:36:49.840 --> 02:36:52.840]  тип один, то делай одно, если тип другое, делай другое.
[02:36:52.840 --> 02:36:53.840]  Да?
[02:36:53.840 --> 02:36:54.840]  Да.
[02:36:54.840 --> 02:36:55.840]  Смотри, это можно.
[02:36:55.840 --> 02:36:56.840]  Это можно сделать.
[02:36:56.840 --> 02:36:59.840]  Ну, то есть, во-первых, ты можешь зайти в видит
[02:36:59.840 --> 02:37:12.840]  и написать что-то вроде там if const export std isSameVariantVariantVariantVariantVariantVariantVariant
[02:37:12.840 --> 02:37:42.840]  isSameVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVariantVari
[02:37:42.840 --> 02:38:11.840]  Да, ну в смысле у тебя в рантайме, сейчас еще раз, подождите, вы мне утверждаете, что это не сработает?
[02:38:11.840 --> 02:38:19.840]  Я утверждаю, что это сработает, сейчас я посмотрю, в каком хедре лежит ASTD decay, это сработает, type traits, в целом ожидаемо.
[02:38:19.840 --> 02:38:40.840]  Ну смотрите, ну мы с вами на самом деле обсуждали, что это, она удаляет всякие консты, удаляет амперсанды и превращает массивы в указатели.
[02:38:40.840 --> 02:38:46.840]  Вообще, я хочу сказать, что вообще с ASTD decay любые консексы проекта, не важно, что они лежат, другие работать не будут.
[02:38:46.840 --> 02:38:51.840]  Потому что в большинстве того, что бывают ситуации, когда компалируют амперсанды, и невозможно определить, что там лежит.
[02:38:51.840 --> 02:38:58.840]  Ровно так же, как мы не делали для ASTD, мы вместе ставим. Просто точно то, что мы делали.
[02:38:58.840 --> 02:39:00.840]  Так.
[02:39:00.840 --> 02:39:02.840]  Это не сработает только Пэр.
[02:39:02.840 --> 02:39:06.840]  Ну, я вот очень хочу сказать сейчас.
[02:39:06.840 --> 02:39:08.840]  Сейчас посмотрим.
[02:39:08.840 --> 02:39:10.840]  Это вообще не должно так себя вести.
[02:39:10.840 --> 02:39:12.840]  Не должно так себя вести.
[02:39:12.840 --> 02:39:14.840]  Сейчас я могу вот так сделать.
[02:39:14.840 --> 02:39:16.840]  Тип B, на того, что у меня лежит, зависит от runtime.
[02:39:16.840 --> 02:39:18.840]  Безусловно.
[02:39:18.840 --> 02:39:20.840]  Смотри, хорошо.
[02:39:20.840 --> 02:39:24.840]  В консексе он не сможет работать.
[02:39:31.840 --> 02:39:32.840]  Окей.
[02:39:32.840 --> 02:39:39.840]  Вот такой код, который если строка делает одно, если не строка, делает другое.
[02:39:43.840 --> 02:39:45.840]  Ну, конечно.
[02:39:45.840 --> 02:39:48.840]  Видимо, он может хранить указатель на функцию, который ему нужен.
[02:39:48.840 --> 02:39:50.840]  Указатель runtime.
[02:39:50.840 --> 02:39:52.840]  Вот. Давайте посмотрим вот так.
[02:39:58.840 --> 02:40:00.840]  Ну, какой билд?
[02:40:00.840 --> 02:40:02.840]  Нет, у нас тут билд-система, к сожалению.
[02:40:02.840 --> 02:40:04.840]  Здесь у нас есть стринг.
[02:40:04.840 --> 02:40:06.840]  Окей. Почему это не стринг?
[02:40:06.840 --> 02:40:08.840]  Потому что есть вот эта строка.
[02:40:08.840 --> 02:40:14.840]  Если мы берем вот эту строку, и вот эту строку, и вот эту строку.
[02:40:14.840 --> 02:40:20.840]  Ага. А теперь я там напишу, что if вот с клавиатуры...
[02:40:20.840 --> 02:40:22.840]  This is a string.
[02:40:22.840 --> 02:40:28.840]  А теперь я говорю, что if вот с клавиатуры равен 228, я записываю туда строку, иначе int.
[02:40:28.840 --> 02:40:30.840]  И что делает твой degle type?
[02:40:30.840 --> 02:40:32.840]  Объясни мне.
[02:40:32.840 --> 02:40:34.840]  Ну, смотри. Хорошо. Давай вот так.
[02:40:40.840 --> 02:40:42.840]  Видишь, человек понимает.
[02:40:42.840 --> 02:40:44.840]  Давай. Если вот это вот равно 42?
[02:40:46.840 --> 02:40:48.840]  Ну, вот типа того, да.
[02:40:48.840 --> 02:40:50.840]  То делаем вот так.
[02:40:50.840 --> 02:40:52.840]  Да.
[02:40:52.840 --> 02:40:54.840]  Ну, argc это явно исключительно runtime штука.
[02:40:58.840 --> 02:41:00.840]  Да пофиг.
[02:41:00.840 --> 02:41:02.840]  Ну, хорошо. Давай не 42. Давай будет 2 аргумента.
[02:41:02.840 --> 02:41:06.840]  Потому что теперь я смогу показать, что вот один раз компилировал.
[02:41:06.840 --> 02:41:08.840]  Запустил...
[02:41:08.840 --> 02:41:10.840]  This is a string.
[02:41:10.840 --> 02:41:12.840]  This is an out-argument.
[02:41:12.840 --> 02:41:14.840]  This is not a string.
[02:41:16.840 --> 02:41:18.840]  Okay?
[02:41:34.840 --> 02:41:36.840]  В compile-time все работает.
[02:41:36.840 --> 02:41:38.840]  Ну, constexpr не может работать в runtime.
[02:41:38.840 --> 02:41:40.840]  STD из sameware работает только в compile-time.
[02:41:40.840 --> 02:41:42.840]  Более того, сейчас вот, смотрите, у меня есть здесь план.
[02:41:42.840 --> 02:41:44.840]  Вот здесь, видите, написано std-visit-boom.
[02:41:44.840 --> 02:41:46.840]  Это типа...
[02:41:46.840 --> 02:41:48.840]  А дальше написано overload-pattern и большой boom.
[02:41:52.840 --> 02:41:54.840]  Смотрите.
[02:42:02.840 --> 02:42:04.840]  Нет.
[02:42:04.840 --> 02:42:06.840]  Да.
[02:42:06.840 --> 02:42:08.840]  Лянда.
[02:42:08.840 --> 02:42:10.840]  Это у вас структура просто
[02:42:10.840 --> 02:42:12.840]  и скобочки.
[02:42:12.840 --> 02:42:14.840]  Вы можете также написать... Не обязательно.
[02:42:14.840 --> 02:42:16.840]  Вы можете написать просто структуру свою.
[02:42:16.840 --> 02:42:18.840]  Сделать у нее, например, много операторов круглые скобки.
[02:42:18.840 --> 02:42:20.840]  Или там шаблонный оператор круглые скобки.
[02:42:20.840 --> 02:42:22.840]  Пожалуйста.
[02:42:22.840 --> 02:42:24.840]  Ну, и у нас просто
[02:42:24.840 --> 02:42:26.840]  template-ная штука генерируется...
[02:42:26.840 --> 02:42:28.840]  Ну, видите, генерируется для каждого
[02:42:28.840 --> 02:42:30.840]  типа, который может
[02:42:30.840 --> 02:42:32.840]  храниться в этом варианте.
[02:42:32.840 --> 02:42:34.840]  Да.
[02:42:34.840 --> 02:42:36.840]  Раз он знает...
[02:42:36.840 --> 02:42:38.840]  И потом он в run-time
[02:42:38.840 --> 02:42:40.840]  вызывает нужную.
[02:42:40.840 --> 02:42:42.840]  В run-time вызывает нужную. Все проблемы.
[02:42:42.840 --> 02:42:44.840]  То есть, вы знаете, что если мы сейчас запустим проверку
[02:42:44.840 --> 02:42:46.840]  в убитый теориям формата, у нас полукод просто
[02:42:46.840 --> 02:42:48.840]  местный генерируется. Что мы сейчас делаем?
[02:42:48.840 --> 02:42:50.840]  Ну, запустим, например.
[02:42:50.840 --> 02:42:52.840]  Ну, если мы сейчас делаем какой-то цикл, который вообще
[02:42:52.840 --> 02:42:54.840]  нереально что-то делает, и в зависимости от этого
[02:42:54.840 --> 02:42:56.840]  может генерируется бесконечное число версии
[02:42:56.840 --> 02:42:58.840]  варианта, то код наш не запустится.
[02:42:58.840 --> 02:43:00.840]  В смысле, бесконечное число яснее генерируется?
[02:43:00.840 --> 02:43:02.840]  Я не понимаю вопрос.
[02:43:02.840 --> 02:43:04.840]  Кажется, мы копилируем сами условия,
[02:43:04.840 --> 02:43:06.840]  а
[02:43:06.840 --> 02:43:08.840]  не то,
[02:43:08.840 --> 02:43:10.840]  выполнились ли одни.
[02:43:10.840 --> 02:43:12.840]  Мы по временам делаем сами условия.
[02:43:12.840 --> 02:43:14.840]  Мы constexpr раскрываем. Мы все константные вещи
[02:43:14.840 --> 02:43:16.840]  раскрываем. Просто для каждого типа
[02:43:16.840 --> 02:43:18.840]  из варианта независимо.
[02:43:18.840 --> 02:43:20.840]  То есть, мы для всех типов, что у нас есть
[02:43:20.840 --> 02:43:22.840]  варианта... Нам не нужно проверять
[02:43:22.840 --> 02:43:24.840]  выполнение условий. Мы просто проверяем.
[02:43:24.840 --> 02:43:26.840]  Мы просто делаем код для случаев,
[02:43:26.840 --> 02:43:28.840]  когда выполнен, и для случаев, когда не выполнен.
[02:43:28.840 --> 02:43:30.840]  Так вот.
[02:43:30.840 --> 02:43:32.840]  И про антайли мы уже выбираем
[02:43:32.840 --> 02:43:34.840]  какой год выпускается.
[02:43:34.840 --> 02:43:36.840]  Да, все генерируются.
[02:43:36.840 --> 02:43:38.840]  У тебя их конечное количество по числу типов,
[02:43:38.840 --> 02:43:40.840]  которые могут храниться конкретно
[02:43:40.840 --> 02:43:42.840]  на этом варианте.
[02:43:46.840 --> 02:43:48.840]  У тебя просто какая-то темплейная структура есть,
[02:43:48.840 --> 02:43:50.840]  у которой темплейные параметры
[02:43:50.840 --> 02:43:52.840]  может быть ровно столько,
[02:43:52.840 --> 02:43:54.840]  сколько у тебя вариантов разных типов можно изразить.
[02:43:54.840 --> 02:43:56.840]  Ну, подставим все.
[02:43:56.840 --> 02:43:58.840]  Смотрите, что я еще могу сделать.
[02:44:06.840 --> 02:44:08.840]  Почему больное? Невероятно красивое.
[02:44:08.840 --> 02:44:10.840]  Смотрите.
[02:44:18.840 --> 02:44:20.840]  Смотрите, что мы можем сделать.
[02:44:20.840 --> 02:44:22.840]  Сказать.
[02:44:22.840 --> 02:44:24.840]  То же самое, но более красиво
[02:44:24.840 --> 02:44:26.840]  гораздо. Значит, если нам дают строку,
[02:44:28.840 --> 02:44:30.840]  выведи,
[02:44:30.840 --> 02:44:32.840]  что это строка.
[02:44:36.840 --> 02:44:38.840]  Так.
[02:44:40.840 --> 02:44:42.840]  Что-то не хватает.
[02:44:42.840 --> 02:44:44.840]  А, точки запятая.
[02:44:46.840 --> 02:44:48.840]  Если у нас
[02:44:48.840 --> 02:44:50.840]  int
[02:44:50.840 --> 02:44:52.840]  int
[02:44:54.840 --> 02:44:56.840]  std
[02:44:56.840 --> 02:44:58.840]  int
[02:45:00.840 --> 02:45:02.840]  точка запятая.
[02:45:04.840 --> 02:45:06.840]  Так.
[02:45:06.840 --> 02:45:08.840]  Сейчас посмотрим на overload.
[02:45:08.840 --> 02:45:10.840]  Смотрите, string
[02:45:10.840 --> 02:45:12.840]  и, соответственно,
[02:45:14.840 --> 02:45:16.840]  int.
[02:45:16.840 --> 02:45:18.840]  Видали, что я написал? Это почти pattern matching в плюсах.
[02:45:20.840 --> 02:45:22.840]  Если string выполняет этот код,
[02:45:22.840 --> 02:45:24.840]  если int выполняет этот код.
[02:45:24.840 --> 02:45:26.840]  Как вам такое?
[02:45:26.840 --> 02:45:28.840]  Нет.
[02:45:30.840 --> 02:45:32.840]  Ну, это то же самое, только не нужно писать
[02:45:32.840 --> 02:45:34.840]  if constexpr std is same way
[02:45:34.840 --> 02:45:36.840]  std decay t decal type item
[02:45:36.840 --> 02:45:38.840]  запятая std string. Можно писать просто?
[02:45:38.840 --> 02:45:40.840]  std string.
[02:45:42.840 --> 02:45:44.840]  Да. Значит, как это вдавиться?
[02:45:44.840 --> 02:45:46.840]  Что?
[02:45:46.840 --> 02:45:48.840]  Всего четыре строки.
[02:45:50.840 --> 02:45:52.840]  Что?
[02:45:58.840 --> 02:46:00.840]  Функция сплошные точки.
[02:46:00.840 --> 02:46:02.840]  Сплошные точки.
[02:46:02.840 --> 02:46:04.840]  Ну, давайте разберем. Давайте попробуем
[02:46:04.840 --> 02:46:06.840]  разобраться, что здесь происходит и почему
[02:46:06.840 --> 02:46:08.840]  эта штука красная.
[02:46:10.840 --> 02:46:12.840]  Это называется overload pattern.
[02:46:12.840 --> 02:46:14.840]  Это называется overload pattern.
[02:46:14.840 --> 02:46:16.840]  У нас есть структура,
[02:46:16.840 --> 02:46:18.840]  у которой есть
[02:46:20.840 --> 02:46:22.840]  параметр pack шаблонный.
[02:46:22.840 --> 02:46:24.840]  Да.
[02:46:24.840 --> 02:46:26.840]  Мы от них от всех наследуемся публично.
[02:46:26.840 --> 02:46:28.840]  Вот здесь уже вопросики.
[02:46:30.840 --> 02:46:32.840]  В этом моменте
[02:46:32.840 --> 02:46:34.840]  уже очень много.
[02:46:34.840 --> 02:46:36.840]  Мы передаем туда
[02:46:36.840 --> 02:46:38.840]  сколько угодно типы и от каждого из этих типов
[02:46:38.840 --> 02:46:40.840]  наследуемся. Нормально?
[02:46:40.840 --> 02:46:42.840]  Почему нет?
[02:46:44.840 --> 02:46:46.840]  Давай сразу посмотрим,
[02:46:46.840 --> 02:46:48.840]  какие типы мы передадим в этот overload
[02:46:48.840 --> 02:46:50.840]  из двух лямб.
[02:46:50.840 --> 02:46:52.840]  Какие это типы?
[02:46:52.840 --> 02:46:54.840]  Ну, это тип лямб
[02:46:54.840 --> 02:46:56.840]  в мейне на 31 строке и лямб
[02:46:56.840 --> 02:46:58.840]  в мейне на 32 строке.
[02:46:58.840 --> 02:47:00.840]  Это структура, как мы помним.
[02:47:00.840 --> 02:47:02.840]  Почему мы вообще создаем overload?
[02:47:02.840 --> 02:47:04.840]  У нас конструкторов нет.
[02:47:04.840 --> 02:47:06.840]  Почему? Как это работает?
[02:47:06.840 --> 02:47:08.840]  А, у нас есть...
[02:47:08.840 --> 02:47:10.840]  У нас там в конце стримки янта, что ли?
[02:47:10.840 --> 02:47:12.840]  Нет, подожди.
[02:47:12.840 --> 02:47:13.840]  Что такое
[02:47:13.840 --> 02:47:15.840]  оператор круглой скобочки?
[02:47:15.840 --> 02:47:17.840]  Это, смотри.
[02:47:17.840 --> 02:47:19.840]  Мы делаем using.
[02:47:19.840 --> 02:47:21.840]  Из каждого из типов,
[02:47:21.840 --> 02:47:23.840]  от которых наследуемся,
[02:47:23.840 --> 02:47:25.840]  берем оттуда оператор круглой скобочки.
[02:47:25.840 --> 02:47:27.840]  И вот это значит, что это делаем
[02:47:27.840 --> 02:47:29.840]  для каждого из...
[02:47:29.840 --> 02:47:31.840]  А, для каждого из types?
[02:47:31.840 --> 02:47:33.840]  Для каждого из types.
[02:47:33.840 --> 02:47:35.840]  Так, стоп.
[02:47:35.840 --> 02:47:37.840]  Как же это прекрасно.
[02:47:37.840 --> 02:47:39.840]  Как же это плохо.
[02:47:39.840 --> 02:47:41.840]  Подождите, у нас квадрат?
[02:47:41.840 --> 02:47:43.840]  Что квадратное?
[02:47:43.840 --> 02:47:45.840]  Меня очень беспокоит, как мы вообще overload создаем?
[02:47:45.840 --> 02:47:47.840]  В смысле, что-то как-то происходит.
[02:47:47.840 --> 02:47:49.840]  Это самый мужской способ объединиться.
[02:47:51.840 --> 02:47:53.840]  Ну, давай подумаем, что такое overload?
[02:47:53.840 --> 02:47:55.840]  Overload у нас в данном случае
[02:47:55.840 --> 02:47:57.840]  наследуется от двух родителей.
[02:47:57.840 --> 02:47:59.840]  Правильно?
[02:47:59.840 --> 02:48:01.840]  Какие аргументы у нас вообще как шаблонные
[02:48:01.840 --> 02:48:03.840]  подставляются, и как это
[02:48:03.840 --> 02:48:05.840]  подставляется, потому что мы же...
[02:48:07.840 --> 02:48:09.840]  Ну, смотри, какие
[02:48:09.840 --> 02:48:11.840]  подставляются аргументы. У нас есть вот эта штука.
[02:48:11.840 --> 02:48:13.840]  Мы пытаемся вызывать какой-то конструктор,
[02:48:13.840 --> 02:48:15.840]  непонятно от чего.
[02:48:15.840 --> 02:48:17.840]  Вот у нас есть auto-lamb1.
[02:48:17.840 --> 02:48:19.840]  У нее тип
[02:48:19.840 --> 02:48:21.840]  decal-type от auto-lamb1.
[02:48:21.840 --> 02:48:23.840]  Больше никакой.
[02:48:25.840 --> 02:48:27.840]  У нас есть auto-lamb2
[02:48:27.840 --> 02:48:29.840]  равно вот это.
[02:48:33.840 --> 02:48:35.840]  Мы создаем overload
[02:48:35.840 --> 02:48:37.840]  от decal-type
[02:48:37.840 --> 02:48:39.840]  от lambda1,
[02:48:39.840 --> 02:48:41.840]  decal-type
[02:48:41.840 --> 02:48:43.840]  от lambda2.
[02:48:45.840 --> 02:48:47.840]  Да?
[02:48:49.840 --> 02:48:51.840]  А, в самом деле, вот этого уже достаточно?
[02:48:51.840 --> 02:48:53.840]  Типа, вот этот код будет делать то же самое?
[02:48:55.840 --> 02:48:57.840]  Почему нам типа все достаточно?
[02:48:59.840 --> 02:49:01.840]  Ну, потому что...
[02:49:01.840 --> 02:49:03.840]  Ну, что такое тип lambda?
[02:49:03.840 --> 02:49:05.840]  Это просто пустая структура, у которой
[02:49:05.840 --> 02:49:07.840]  оператор круглые скобочки, который статический,
[02:49:07.840 --> 02:49:09.840]  потому что у нас нет захватов.
[02:49:09.840 --> 02:49:11.840]  Он статический, да.
[02:49:11.840 --> 02:49:13.840]  У нас это пустая структура со статической функцией.
[02:49:13.840 --> 02:49:15.840]  Все, статическим методом.
[02:49:15.840 --> 02:49:17.840]  Но вообще, на самом деле непонятно,
[02:49:17.840 --> 02:49:19.840]  потому что мы не пишем шаблонные параметры
[02:49:19.840 --> 02:49:21.840]  и просто пишем, от чего им генировать,
[02:49:21.840 --> 02:49:23.840]  он сам
[02:49:23.840 --> 02:49:25.840]  как-то это очень аккуратно
[02:49:25.840 --> 02:49:27.840]  парсит. Тут не очевидно.
[02:49:27.840 --> 02:49:29.840]  Ну, происходит deduction-guide.
[02:49:29.840 --> 02:49:31.840]  Ну, не очевидно, как именно
[02:49:31.840 --> 02:49:33.840]  происходит, кажется.
[02:49:33.840 --> 02:49:35.840]  На самом деле,
[02:49:35.840 --> 02:49:37.840]  до C++20
[02:49:37.840 --> 02:49:39.840]  нужно было писать кастомный deduction-guide
[02:49:39.840 --> 02:49:41.840]  здесь. Чтобы это так красиво работало,
[02:49:41.840 --> 02:49:43.840]  нужно было писать... Вот к этому вопросов
[02:49:43.840 --> 02:49:45.840]  нет. Это понятно почему. Вообще
[02:49:45.840 --> 02:49:47.840]  непонятно, почему после 20-х не нужно.
[02:49:47.840 --> 02:49:49.840]  Ну, потому что
[02:49:49.840 --> 02:49:51.840]  мощный update. Это очень сильная
[02:49:51.840 --> 02:49:53.840]  магия должна быть написана.
[02:49:53.840 --> 02:49:55.840]  Сейчас, а где нужно было
[02:49:55.840 --> 02:49:57.840]  писать deduction-guide? Ну, до 20-х
[02:49:57.840 --> 02:49:59.840]  плюсов нужно было... Вот здесь нужно было
[02:49:59.840 --> 02:50:01.840]  написать что-то вроде...
[02:50:01.840 --> 02:50:03.840]  Так, давайте вспомним. Нужно было объяснять ему,
[02:50:03.840 --> 02:50:05.840]  что делать с шаблонными параметрами.
[02:50:09.840 --> 02:50:11.840]  Что вроде такое...
[02:50:15.840 --> 02:50:17.840]  Мы
[02:50:17.840 --> 02:50:19.840]  создаем overload
[02:50:21.840 --> 02:50:23.840]  от
[02:50:23.840 --> 02:50:25.840]  types
[02:50:25.840 --> 02:50:27.840]  types
[02:50:31.840 --> 02:50:33.840]  Кажется, что-то вот такое.
[02:50:33.840 --> 02:50:35.840]  Вот, видите, он ругаться перестал.
[02:50:35.840 --> 02:50:37.840]  Ну, ругался он, потому что клан, как вы помните,
[02:50:37.840 --> 02:50:39.840]  еще пока нет.
[02:50:39.840 --> 02:50:41.840]  Не успел.
[02:50:41.840 --> 02:50:43.840]  Не успел.
[02:50:43.840 --> 02:50:45.840]  Ну, вот тут понятно.
[02:50:45.840 --> 02:50:47.840]  Ну, просто 20-й плюсы такую штуку
[02:50:47.840 --> 02:50:49.840]  по умолчанию сгенерили. Нам повезло.
[02:50:49.840 --> 02:50:51.840]  Что если мы хотим поддерживать
[02:50:51.840 --> 02:50:53.840]  функцию для вейн, которая
[02:50:53.840 --> 02:50:55.840]  может...
[02:50:55.840 --> 02:50:57.840]  которая в одном случае корректна,
[02:50:57.840 --> 02:50:59.840]  в другом случае не корректна.
[02:50:59.840 --> 02:51:01.840]  Еще раз, мы хотим хранить две перегрузки
[02:51:01.840 --> 02:51:03.840]  в одном случае
[02:51:03.840 --> 02:51:05.840]  вызывать, которое можно, например,
[02:51:05.840 --> 02:51:07.840]  астремиала, но то, что мы показывали с точка back
[02:51:07.840 --> 02:51:09.840]  и у int.bat нет.
[02:51:09.840 --> 02:51:11.840]  Поэтому мы такого делать не можем.
[02:51:11.840 --> 02:51:13.840]  Есть ли какой-то способ
[02:51:13.840 --> 02:51:15.840]  с вейн, который позволяет
[02:51:15.840 --> 02:51:17.840]  для разных вариантов того, что
[02:51:17.840 --> 02:51:19.840]  в нем лежит, одну функцию исполнять
[02:51:19.840 --> 02:51:21.840]  или не исполнять?
[02:51:21.840 --> 02:51:23.840]  Кажется, я могу написать...
[02:51:23.840 --> 02:51:25.840]  То есть, судя по тому,
[02:51:25.840 --> 02:51:27.840]  как это работает, насколько я понял,
[02:51:27.840 --> 02:51:29.840]  мы просто генерируем все варианты функций
[02:51:29.840 --> 02:51:31.840]  в compile-time для каждого из вариантов.
[02:51:31.840 --> 02:51:33.840]  Но что, если один из вариантов функций
[02:51:33.840 --> 02:51:35.840]  нельзя сгенерировать?
[02:51:35.840 --> 02:51:37.840]  То есть, можно ли
[02:51:37.840 --> 02:51:39.840]  попытаться имплементировать логику,
[02:51:39.840 --> 02:51:41.840]  где...
[02:51:41.840 --> 02:51:43.840]  Ну, короче, для кого-то можно
[02:51:43.840 --> 02:51:45.840]  что-то делать, для кого-то нельзя.
[02:51:45.840 --> 02:51:47.840]  Ну вот, смотри, давай попробуем вот так.
[02:51:47.840 --> 02:51:49.840]  Вот так.
[02:51:51.840 --> 02:51:53.840]  Вот.
[02:51:53.840 --> 02:51:55.840]  И теперь давай мы...
[02:51:55.840 --> 02:51:57.840]  Так, я опять забыл точку запятой.
[02:51:57.840 --> 02:51:59.840]  Вот.
[02:51:59.840 --> 02:52:01.840]  Допустим, мы добавим сюда
[02:52:01.840 --> 02:52:03.840]  какой-нибудь
[02:52:03.840 --> 02:52:05.840]  std-вектор опять.
[02:52:05.840 --> 02:52:07.840]  И вот в двух этих штуках
[02:52:07.840 --> 02:52:09.840]  от int-ов
[02:52:11.840 --> 02:52:13.840]  в двух этих штуках мы будем
[02:52:13.840 --> 02:52:15.840]  выводить, скажем, вот string.
[02:52:17.840 --> 02:52:19.840]  Потом, собственно говоря,
[02:52:19.840 --> 02:52:21.840]  item, который мы пока опускали,
[02:52:25.840 --> 02:52:27.840]  вводим item.
[02:52:27.840 --> 02:52:29.840]  Вводим int.
[02:52:29.840 --> 02:52:31.840]  Ну, пожалуйста, вводим этот int.
[02:52:41.840 --> 02:52:43.840]  Вот.
[02:52:43.840 --> 02:52:45.840]  То есть, вот эта у нас штука сломалась,
[02:52:45.840 --> 02:52:47.840]  но наша новая более красивая
[02:52:47.840 --> 02:52:49.840]  все скомпилировалась.
[02:52:49.840 --> 02:52:51.840]  Все хорошо.
[02:53:01.840 --> 02:53:03.840]  Почему больно-то?
[02:53:11.840 --> 02:53:13.840]  Да, надо.
[02:53:13.840 --> 02:53:15.840]  Так.
[02:53:17.840 --> 02:53:19.840]  Нужную перегрузку
[02:53:19.840 --> 02:53:21.840]  для каждого...
[02:53:21.840 --> 02:53:23.840]  для каждого из гляд.
[02:53:23.840 --> 02:53:25.840]  И в том...
[02:53:27.840 --> 02:53:29.840]  Да, у меня одна гляда потерялась куда-то.
[02:53:29.840 --> 02:53:31.840]  Потому что она в одной стройке.
[02:53:33.840 --> 02:53:35.840]  А?
[02:53:35.840 --> 02:53:37.840]  А?
[02:53:37.840 --> 02:53:39.840]  Это предложение 35-й стройки, да.
[02:53:41.840 --> 02:53:43.840]  Все.
[02:53:47.840 --> 02:53:49.840]  Не очевидно, нет.
[02:53:51.840 --> 02:53:53.840]  Вот, смотрите, вот так, пожалуйста.
[02:53:53.840 --> 02:53:55.840]  Ну, типа, если это строка
[02:53:55.840 --> 02:53:57.840]  или int, выводим, если что угодно другое.
[02:53:59.840 --> 02:54:01.840]  Да.
[02:54:05.840 --> 02:54:07.840]  Нет.
[02:54:07.840 --> 02:54:09.840]  Что еще нужно сказать про видеть?
[02:54:09.840 --> 02:54:11.840]  Видеть, на самом деле, было бы логично,
[02:54:11.840 --> 02:54:13.840]  чтобы он принимал вариант первым
[02:54:13.840 --> 02:54:15.840]  аргументом, да, не вторым.
[02:54:15.840 --> 02:54:17.840]  Но он принимает его вторым, потому что вы можете туда
[02:54:17.840 --> 02:54:19.840]  сколько угодно вариантов передать.
[02:54:19.840 --> 02:54:21.840]  И он...
[02:54:21.840 --> 02:54:23.840]  для каждого из них
[02:54:23.840 --> 02:54:25.840]  запустится.
[02:54:25.840 --> 02:54:27.840]  Или нет.
[02:54:29.840 --> 02:54:31.840]  Не знаю, почему он решил не запускаться.
[02:54:31.840 --> 02:54:33.840]  Кажется, должен.
[02:54:37.840 --> 02:54:39.840]  Visit.
[02:54:39.840 --> 02:54:41.840]  Visit.
[02:54:43.840 --> 02:54:45.840]  VisitorVariants.
[02:54:51.840 --> 02:54:53.840]  Ну, подозрительно.
[02:54:55.840 --> 02:54:57.840]  Вот.
[02:54:57.840 --> 02:54:59.840]  Ну, соответственно, если у вас какой-то есть вектор вариантов
[02:54:59.840 --> 02:55:01.840]  или мапчик вариантов, можете по ним проходиться
[02:55:01.840 --> 02:55:03.840]  и для каждого вызвать Visitor.
[02:55:03.840 --> 02:55:05.840]  Потому что у вас в векторе вариантов, очевидно, разные
[02:55:05.840 --> 02:55:07.840]  варианты могут иметь разные активные элементы.
[02:55:07.840 --> 02:55:09.840]  И для каждого из них автоматически выберется
[02:55:09.840 --> 02:55:11.840]  нужная штука.
[02:55:13.840 --> 02:55:15.840]  Ну, так.
[02:55:15.840 --> 02:55:17.840]  По времени уже все, да?
[02:55:17.840 --> 02:55:19.840]  По времени мы все пятнадцать минут назад.
[02:55:19.840 --> 02:55:21.840]  А, черт.
[02:55:21.840 --> 02:55:23.840]  Какой юзинг? Вот этот?
[02:55:23.840 --> 02:55:25.840]  Ну, это типа...
[02:55:25.840 --> 02:55:27.840]  Представь, что types в нашем случае, это там
[02:55:27.840 --> 02:55:29.840]  лямбда один, лямбда два,
[02:55:29.840 --> 02:55:31.840]  лямбда три, да?
[02:55:31.840 --> 02:55:33.840]  Окей. Тогда это будет
[02:55:33.840 --> 02:55:35.840]  то же самое, что написать
[02:55:35.840 --> 02:55:37.840]  юзинг там лямбда один,
[02:55:37.840 --> 02:55:39.840]  оператор, клыскопки.
[02:55:43.840 --> 02:55:45.840]  Только оператор.
[02:55:47.840 --> 02:55:49.840]  Что это за запись вообще?
[02:55:49.840 --> 02:55:51.840]  Это значит, что этот оператор
[02:55:51.840 --> 02:55:53.840]  можно вызывать от нас.
[02:55:53.840 --> 02:55:55.840]  Мы добавляем себе
[02:55:55.840 --> 02:55:57.840]  из нашего родителя вот этот метод,
[02:55:57.840 --> 02:55:59.840]  даже если его у нас нет.
[02:56:01.840 --> 02:56:03.840]  Ну, так же, как с конструктором мы делали.
[02:56:05.840 --> 02:56:07.840]  Мы, наверное, когда-то так делали
[02:56:07.840 --> 02:56:09.840]  с конструктором, что типа...
[02:56:25.840 --> 02:56:27.840]  Ну, можно попробовать...
[02:56:35.840 --> 02:56:37.840]  Вот так. Давай сделаем это
[02:56:37.840 --> 02:56:39.840]  на вот этой штуке.
[02:56:39.840 --> 02:56:41.840]  Второй кое-ниче.
[02:56:43.840 --> 02:56:45.840]  Верлот два, и у него
[02:56:45.840 --> 02:56:47.840]  мы будем делать юзинг на бэк.
[02:56:47.840 --> 02:56:49.840]  Почему нет?
[02:56:49.840 --> 02:56:51.840]  И здесь делаем
[02:56:53.840 --> 02:56:55.840]  верлот два
[02:56:55.840 --> 02:56:57.840]  от стд
[02:56:57.840 --> 02:56:59.840]  от стд
[02:56:59.840 --> 02:57:01.840]  от стд
[02:57:01.840 --> 02:57:03.840]  от стд
[02:57:03.840 --> 02:57:05.840]  верлот два
[02:57:05.840 --> 02:57:07.840]  от стд
[02:57:07.840 --> 02:57:09.840]  ринг
[02:57:09.840 --> 02:57:11.840]  стд вектор
[02:57:11.840 --> 02:57:13.840]  int.
[02:57:19.840 --> 02:57:21.840]  Так, что мне нравится?
[02:57:21.840 --> 02:57:23.840]  Он с конструктором не справился,
[02:57:23.840 --> 02:57:25.840]  что в целом справедливо.
[02:57:25.840 --> 02:57:27.840]  Давай просто укажем у стд
[02:57:27.840 --> 02:57:29.840]  ринг,
[02:57:29.840 --> 02:57:31.840]  стд вектор
[02:57:31.840 --> 02:57:33.840]  вектор
[02:57:33.840 --> 02:57:35.840]  во, пожалуйста,
[02:57:35.840 --> 02:57:37.840]  можем.
[02:57:45.840 --> 02:57:47.840]  Ну, векторе их и так несколько.
[02:57:47.840 --> 02:57:49.840]  Ну, просто он все их добавляет.
[02:57:51.840 --> 02:57:53.840]  Так, ладно, давайте заканчивать.
[02:57:57.840 --> 02:57:59.840]  С чем он не справился?
[02:58:01.840 --> 02:58:10.800]  ну потому что это слишком сложно для него ну смотри то есть что ему нужно сделать
[02:58:10.800 --> 02:58:19.800]  а да сейчас да он скорее всего на геймпультуста скомпилиться
[02:58:19.800 --> 02:58:32.320]  но тут нужно чтобы он добавил ровно те же самые дедакшн гайды
[02:58:32.960 --> 02:58:36.720]  Publix
[02:58:43.840 --> 02:58:43.860]  все
