[00:00.000 --> 00:09.800]  Давайте начинать продолжать, поговорим про дизайн.
[00:09.800 --> 00:13.640]  Есть все вот эти вот паттерны дизайна оу пешные, про которые
[00:13.640 --> 00:17.100]  мы говорим, вспоминаем постоянно, а есть чисто вот
[00:17.100 --> 00:21.240]  в шаблонах, из них так как-то получилось, что вытекло
[00:21.240 --> 00:25.280]  несколько тоже таких, то ли шаблонов, то ли чего-то
[00:25.280 --> 00:26.280]  такого.
[00:26.280 --> 00:29.080]  Короче, техника, которую все постоянно используют,
[00:29.080 --> 00:33.120]  их говорят, но иногда не очень правильно терминно
[00:33.120 --> 00:36.320]  используют, и путаница начинается, но в общем
[00:36.320 --> 00:40.360]  что-то вроде с rtp, такие модные слова, которые в шаблонном
[00:40.360 --> 00:42.640]  мире постоянно вы будете слышать.
[00:42.640 --> 00:48.000]  Давайте про них говорить, примерчик сразу, мы сделали
[00:48.000 --> 00:54.320]  функцию копия, вот стандарта такая есть, она копирует
[00:54.320 --> 00:59.200]  из одного какого-то контейнера данные, в какой-то другой,
[00:59.200 --> 01:01.600]  ну из вектора в вектор перекладывает.
[01:01.600 --> 01:03.520]  Давайте представим, что у нас на платформе есть
[01:03.520 --> 01:09.000]  какая-то волшебная функция bitblast, superspeedy bitblast, которая
[01:09.000 --> 01:12.820]  умеет какие-то примитивные типы данных копировать
[01:12.820 --> 01:16.160]  со скоростью света просто, ну и мы хотим соответственно
[01:16.160 --> 01:18.800]  проверить, если у нас в контейнере на самом деле
[01:18.800 --> 01:23.280]  лежат кинькинты или что-нибудь подобное, то использовать
[01:23.280 --> 01:28.400]  супер быструю функцию, иначе ручками цикл, идти, копировать,
[01:28.400 --> 01:29.400]  как бы выхода нет.
[01:29.400 --> 01:33.200]  Ну очень быстро окажется, что там еще нужно добавлять
[01:33.200 --> 01:40.680]  условия tif, там entable и float, погнали-погнали, неудобно,
[01:40.680 --> 01:43.640]  как решить эту проблему, неудобство, что вот надо
[01:43.640 --> 01:51.600]  просто вписывать сюда, какой концепт, ну а как расширять,
[01:51.720 --> 01:55.160]  просто в другое место вписывать надо будет в одно и то же.
[01:55.160 --> 01:59.280]  Хочется, чтобы не было одного места, куда нужно все вписывать,
[01:59.280 --> 02:00.280]  как-то децентрализовать.
[02:00.280 --> 02:09.120]  По сайзову можно поменять, да, хочется помечать типа,
[02:09.120 --> 02:11.080]  но тоже это будет централизованное место.
[02:11.080 --> 02:17.560]  Можно сделать концепт в духе hesmet и написать отдельное
[02:17.560 --> 02:18.560]  название метода.
[02:19.120 --> 02:22.480]  А, даже не так, можно просто завести класс, который говорит,
[02:22.480 --> 02:28.880]  что он совместим с суперскими библиотеклассами и наследоваться
[02:28.880 --> 02:30.880]  от него тем, кто...
[02:30.880 --> 02:33.880]  Так, как ты будешь int наследоваться от чего-то?
[02:33.880 --> 02:34.880]  Как ты будешь int наследоваться от чего-то?
[02:34.880 --> 02:35.880]  Как мы будем...
[02:35.880 --> 02:38.880]  Вот есть такая еще идея, да, можно внутри...
[02:38.880 --> 02:40.880]  Надо о специализации спрашивать.
[02:40.880 --> 02:41.880]  Вот.
[02:41.880 --> 02:44.200]  Ну тупая идея, можно прямо внутри класса писать
[02:44.840 --> 02:45.840]  какой-нибудь флажок.
[02:45.840 --> 02:52.360]  Ну, compile-time флажок, типа struct, yes, you can beatblast me и
[02:52.360 --> 02:53.360]  прям точка с запятой.
[02:53.360 --> 02:58.240]  То есть с этим типом внутри класса какого-то ничего
[02:58.240 --> 03:00.480]  нельзя сделать, кроме как проверить, что он там написан
[03:00.480 --> 03:01.480]  или не написан.
[03:01.480 --> 03:04.480]  Вот это как бы такая пометка.
[03:04.480 --> 03:05.480]  Можно или нельзя.
[03:05.480 --> 03:07.840]  В NT ее не пихнуть, в Bly не пихнуть.
[03:07.840 --> 03:11.760]  Поэтому мы делаем вот так, как сказал Аркадий примерно.
[03:11.840 --> 03:13.640]  Мы делаем трейты, так называемые.
[03:13.640 --> 03:20.000]  Трейты – это такой шаблон для некоторого семейства
[03:20.000 --> 03:25.400]  типов, которые описывают конкретные типы в этом семействе,
[03:25.400 --> 03:26.400]  какие-то их свойства.
[03:26.400 --> 03:30.600]  В данном случае мы делаем некоторые трейты для алгоритма
[03:30.600 --> 03:37.200]  копия и там позволяем конкретным типам в специализациях
[03:37.200 --> 03:38.200]  вписывать свойства.
[03:38.200 --> 03:41.480]  Вот int пометили, что beatblastable true.
[03:41.480 --> 03:44.440]  Можно еще какие-то другие типы пометить, даже которыми
[03:44.440 --> 03:45.440]  вы не владеете.
[03:45.440 --> 03:48.920]  То есть если бы вот этот вот flag beatblastable true-false вы
[03:48.920 --> 03:52.440]  просили писать прямо внутри типа, то с int вы бы не смогли
[03:52.440 --> 03:53.440]  работать.
[03:53.440 --> 03:54.440]  А так можете.
[03:54.440 --> 03:58.720]  Или какими-то чужими классами чай-код вам запрещено менять.
[03:58.720 --> 04:01.320]  Но вы все равно их хотите beatblastить, вот так можно.
[04:01.320 --> 04:10.720]  Можно так, да, ну тут по-разному можно.
[04:10.720 --> 04:13.320]  Идея одна, что вот в таких трейт-объектах можно кучу
[04:13.320 --> 04:16.440]  разных свойств написать, compile-type-свойств типов.
[04:16.440 --> 04:20.000]  Можно какие-то связанные с ними типы, например signed
[04:20.000 --> 04:21.960]  type какой-нибудь или что-нибудь такое.
[04:21.960 --> 04:23.960]  Можно вот boolean или там int.
[04:23.960 --> 04:24.960]  Да?
[04:24.960 --> 04:33.560]  Я просто думаю, если мы, ну допустим, мы хотим завести
[04:33.560 --> 04:41.000]  какой-то трейд, который у нас, который мы хотим
[04:41.000 --> 04:44.000]  наставить только для типа под нашим контролем.
[04:44.000 --> 04:46.440]  То есть, во-первых, не какие-то встроенные типы интопы,
[04:46.440 --> 04:49.440]  а не какие-то чужие, которые нельзя трогать.
[04:49.440 --> 04:54.440]  Вот не лучше ли все-таки сказать, что трейд это конце?
[04:54.440 --> 04:58.840]  Сейчас будем, давай, ты вот слишком глубокие вопросы
[04:58.840 --> 05:00.880]  слишком рано задаешь.
[05:01.000 --> 05:03.920]  Надо такой сложный вопрос под конец раздела про трейты
[05:03.920 --> 05:04.920]  задать.
[05:04.920 --> 05:07.440]  Потому что сейчас про концепты мы еще чуть-чуть поговорим.
[05:07.440 --> 05:10.640]  Собственно, да, использовать это так.
[05:10.640 --> 05:14.280]  Заметьте, type-name здесь не написан и работает дефолт
[05:14.280 --> 05:16.640]  как раз, который нам обычно не нужен, а тут ровно он и
[05:16.640 --> 05:17.640]  нужен.
[05:17.640 --> 05:20.040]  Что тип два двуи точа что-то это переменная.
[05:20.040 --> 05:25.240]  Ну и вот, теперь можно дописывать кого можно битбластить
[05:25.240 --> 05:27.480]  вообще где угодно в коде и это будет работать.
[05:27.960 --> 05:31.960]  А вот еще раз мы эти копии трейд под каждый тип пишем?
[05:31.960 --> 05:34.960]  Не под каждый, есть дефолтная.
[05:34.960 --> 05:37.960]  Под каждый, который да, мы можем специализировать,
[05:37.960 --> 05:38.960]  если хотим.
[05:38.960 --> 05:39.960]  Есть какие-то разумные дефолты.
[05:39.960 --> 05:44.040]  Ну, бывают, конечно, ситуации, когда по дефолту трейд
[05:44.040 --> 05:46.960]  вообще не должен быть определен для вашего типа.
[05:46.960 --> 05:49.960]  Например, итератор трейдс.
[05:49.960 --> 05:53.120]  Итератор трейдс от какого-то рандомного типа вроде void
[05:53.120 --> 05:54.120]  просто void.
[05:54.120 --> 05:56.840]  Не должен быть определен, но он и не определен.
[05:56.840 --> 05:59.400]  Вот, а когда разумно, в принципе, для всего дел
[05:59.400 --> 06:01.400]  дефолт, то вот он можно сделать.
[06:01.400 --> 06:05.400]  И еще раз, если вернемся назад, у нас вот копия трейса
[06:05.400 --> 06:09.400]  бинта true от bool, true от size 3, true…
[06:09.400 --> 06:11.400]  Да, руками вписываем.
[06:11.400 --> 06:16.400]  Если хочется для целого другого семейства, то можно
[06:16.400 --> 06:20.200]  тут еще через концепт частичную специализацию сделать.
[06:20.200 --> 06:22.920]  Ну, короче, все шаблонные трюки работают.
[06:23.000 --> 06:29.600]  Ну и вот, тут такая цитатка из книжки, что такое в целом
[06:29.600 --> 06:32.760]  трейд, в классическом их понимании, что это некоторый
[06:32.760 --> 06:37.400]  уровень индирекции, выносящий принятие решения о конкретных
[06:37.400 --> 06:42.800]  типов куда-то туда, из текущего контекста.
[06:42.800 --> 06:48.400]  Вот, кстати, название книжки, в репетитории ссылка есть,
[06:48.400 --> 06:52.320]  ну, вернее, название, мы тут не пиратим, правда.
[06:52.320 --> 06:54.720]  Ну, найдете.
[06:54.720 --> 06:55.840]  Там много чего полезного.
[06:55.840 --> 07:00.480]  Ну, тут еще вопросы к этому алгоритму на самом деле
[07:00.480 --> 07:04.920]  остаются копия, да, но от всякого банального, которое,
[07:04.920 --> 07:07.320]  я думаю, тоже понятно, как решить, да, вот первые
[07:07.320 --> 07:12.240]  два пункта про последовательность контейнера и там вектор
[07:12.240 --> 07:17.600]  bool off тоже через какие-то трейты того же самого итератора
[07:17.600 --> 07:18.600]  оно решается.
[07:19.360 --> 07:22.960]  Ну, знаете, почему вектор bool off сложнее с ним писать
[07:22.960 --> 07:26.520]  алгоритмы обобщенные, да, там разыменование итератора
[07:26.520 --> 07:30.200]  возвращает не конкретно bool, а какая-то оберточка дурацкая,
[07:30.200 --> 07:36.480]  вот там можно немножко наесться, да, когда поставишь
[07:36.480 --> 07:40.360]  bitblastable для bool true, пихнешь вектор bool off и ничего работать
[07:40.360 --> 07:41.360]  не будет.
[07:41.360 --> 07:44.080]  Повезет, если ошибка компиляции, если нет, то просто все
[07:44.080 --> 07:45.080]  скрашится.
[07:45.240 --> 07:51.720]  Вот есть чуть менее тривиальные проблемы, что first result могут
[07:51.720 --> 07:54.040]  на самом деле разные типы иметь, там конвертации
[07:54.040 --> 07:57.360]  всякие происходят, хотим мы этого, не хотим, хороший
[07:57.360 --> 08:00.160]  вопрос, можно ли просто так bitblastить разные типы
[08:00.160 --> 08:03.800]  друг в друга, ну тоже как-то надо это учесть, правда,
[08:03.800 --> 08:07.120]  если мы на самом деле хотим перекопировать контейнер
[08:07.120 --> 08:11.680]  int в контейнер float, сделав конверсию, а мы запустим
[08:11.840 --> 08:16.400]  bitblast, то мы как бы побитого скопируем int как float и работа
[08:16.400 --> 08:19.280]  ничего не будет, да, такие вещи надо учитывать.
[08:19.280 --> 08:24.480]  И вот нужда в новых ифах, если у нас еще какие-то
[08:24.480 --> 08:27.000]  способы есть для конкретных контейнеров или конкретных
[08:27.000 --> 08:31.400]  случаев, делать алгоритм копирования быстрее, что-то
[08:31.400 --> 08:36.200]  в прошлый раз было про то, как это сделать, никто
[08:36.200 --> 08:37.200]  не запомнил.
[08:37.720 --> 08:38.720]  Или?
[08:38.720 --> 08:41.040]  И еще раз, чем это?
[08:41.040 --> 08:44.440]  Мы написали if прямо в алгоритме копирования, для чего мы
[08:44.440 --> 08:45.440]  его сделали?
[08:45.440 --> 08:48.320]  Чтобы ускорить для каких-то конкретных специализаций
[08:48.320 --> 08:51.040]  этот алгоритм, у нас всегда есть общий алгоритм, он
[08:51.040 --> 08:53.720]  всегда работает, но он не всегда оптимальный, поэтому
[08:53.720 --> 08:56.120]  для конкретной специализации мы говорим, нет, будем такое
[08:56.120 --> 09:01.000]  использовать, что если есть еще куча разных частных
[09:01.000 --> 09:04.600]  кейсов, где для конкретной специализации можно алгоритм
[09:04.760 --> 09:06.760]  по-другому реализовать, он будет быстрее работать.
[09:11.760 --> 09:14.760]  СВОП вспомнил, это правильное направление, что там было?
[09:14.760 --> 09:23.520]  Там была такая аббревиатура ADL, так же как мы СВОП кастомизировали
[09:23.520 --> 09:26.600]  для разных штук, так же и всякие копии предполагается,
[09:26.600 --> 09:31.840]  но это дико неудобно и вообще надо это все обернуть в
[09:31.840 --> 09:35.280]  10 слоев шаблонов, чтобы было удобно, а как это делать
[09:35.280 --> 09:37.480]  мы только в конце курса будем узнавать, потому что
[09:37.480 --> 09:41.000]  это убойная тема и не особо кому нужная, поэтому она
[09:41.000 --> 09:43.200]  на задворке запихана, а может и вообще выкинем.
[09:43.200 --> 09:48.380]  Первые две проблемы просто через этот итератор трейдс
[09:48.380 --> 09:51.000]  на самом деле решаются, и для решения вот этой последней
[09:51.000 --> 09:55.960]  проблемы есть пропузл, собственно эта проблема возникла очень
[09:55.960 --> 10:00.720]  ярко в STD ranges, но там ее обхачили, натуральные хаки
[10:00.720 --> 10:06.000]  включили, и подробнее об этом в следующих сериях,
[10:06.000 --> 10:09.000]  и в STD execution тоже возникла такая же абсолютно проблема
[10:09.000 --> 10:12.880]  и там уже ее так хорошо обхачивать не получалось,
[10:12.880 --> 10:17.000]  пришлось хачить с удвоенной силой, удестеренной, и
[10:17.000 --> 10:24.720]  все-таки получилось, но результат не блойды и точки
[10:25.720 --> 10:26.720]  кастомизации.
[10:26.720 --> 10:29.560]  Точки кастомизации в этом теген вуке?
[10:29.560 --> 10:32.840]  Теген вуке они тоже, вот в ranges были не блойды, точки
[10:32.840 --> 10:40.360]  кастомизации, а в execution запихали теген вук, и в общем
[10:40.360 --> 10:43.840]  все это лютая дичь, невозможно читать, невозможно в этом
[10:43.840 --> 10:50.680]  разобраться, вот возможно мы разберемся, но когда
[10:50.680 --> 10:53.560]  ты свой хочешь кастомизацию сделать для этого копии,
[10:53.560 --> 10:56.280]  ты хочешь свой контейнер, ты хочешь для него кастомизировать,
[10:56.280 --> 10:58.160]  тебе придется разбираться в том, как оно работает,
[10:58.160 --> 11:01.040]  и там подыхаешь, поэтому есть пропозл, выкинуть все
[11:01.040 --> 11:03.880]  эти костыли и хаки нафиг и сделать на уровне языка
[11:03.880 --> 11:07.120]  прям инструмент, чтобы можно было кастомизировать
[11:07.120 --> 11:10.760]  специализации откуда угодно, аккуратным образом, без
[11:10.760 --> 11:15.560]  конфликтов всяких имен, проблем с линковкой, аби и прочего-прочего,
[11:15.560 --> 11:19.680]  то есть просто руками написать специализацию, это проблематично,
[11:19.800 --> 11:24.600]  специализировать шаблоны из стандартной библиотеки
[11:24.600 --> 11:28.680]  по умолчанию нельзя, если не оговорено иного, и там
[11:28.680 --> 11:32.720]  вот какие-то проблемы есть, давайте о них пока не говорить.
[11:32.720 --> 11:37.360]  Вот, идем дальше, взаимодействие с концептами вот этого всего,
[11:37.360 --> 11:40.360]  ну вот там был концепт-этератор, да и в принципе тогда есть
[11:40.360 --> 11:45.120]  концепт-этератор, но если мы его захотим написать,
[11:45.120 --> 11:52.560]  то возможно мы что-то такое сделаем, да, понятно, что написано,
[11:54.560 --> 12:00.040]  мы требуем, чтобы было бульевое поле contiguous у класса-этератора,
[12:00.040 --> 12:03.080]  которое нам говорит, можно ли его просто мем-копию
[12:03.080 --> 12:05.320]  взять и перекопировать или нет, ну то есть подряд
[12:05.320 --> 12:08.680]  ли в памяти идут необходимые элементы, ну это чтобы был
[12:08.680 --> 12:12.640]  какой-то tap name, value type, чтобы как раз по нему понять,
[12:12.640 --> 12:16.920]  а не proxy ли там у нас и вот это все, ну то есть какой-то такой
[12:16.920 --> 12:20.920]  концепт мы можем завести, но он будет плохой, почему?
[12:22.920 --> 12:28.480]  Вот такой концепт утверждается, что очень плохой, какой-то
[12:28.480 --> 12:31.680]  очень частый кейс, который в миллионе код бас просто
[12:31.680 --> 12:38.040]  каждый день используется, что, указатели, да, указатели
[12:38.040 --> 12:42.080]  тоже-этераторы, первая домашка должна была этого научить,
[12:42.080 --> 12:44.240]  то есть здесь, конечно, если вы указатели, попытаетесь
[12:44.240 --> 12:46.720]  найти какую-то переменную внутри, ничего не выйдет,
[12:49.480 --> 12:55.360]  поэтому так не делают, да, и в целом всякие тривиальные
[12:55.360 --> 12:58.640]  типы, указатели, а еще типы, которыми вы не владеете
[12:58.640 --> 13:01.560]  и не можете их заставить соблюдать контракт, что
[13:01.560 --> 13:04.120]  вот написано вот такие вот названия внутри, может
[13:04.120 --> 13:06.600]  них по-другому просто, ну код стайл другой, с маленькой
[13:06.600 --> 13:09.840]  буквы пишут, а у вас с большой, вот во всех таких случаях
[13:09.840 --> 13:14.520]  просто так делать максимально тупо, да, за этим у нас есть
[13:14.520 --> 13:19.920]  трейты, давайте на примере STD это посмотрим, в STD есть
[13:19.920 --> 13:25.240]  итератор trades, ну и тут сразу видно, что итератор trades
[13:25.240 --> 13:29.000]  для т-звездочки переопределен, потому что мы говорим, что
[13:29.000 --> 13:34.000]  как бы указатель тоже-этератор, ну и внутри трейта для итератора
[13:34.000 --> 13:38.920]  есть вот такие типы, я думаю, вы их уже успели повидать,
[13:39.000 --> 13:43.080]  вы писали slice, а дальше есть концепты, целая стопка
[13:43.080 --> 13:46.800]  концептов разных, ну они как бы были и раньше, только
[13:46.800 --> 13:50.120]  они не были концепциями, это были именованные требования,
[13:50.120 --> 13:54.240]  кто-нибудь сможет напомнить, что такое input итератор,
[13:54.240 --> 13:58.920]  что он умеет, пройтись только один раз, да, пройтись только
[13:58.920 --> 14:04.880]  один раз и что писать, читать, что можно, да, вот input итератор
[14:04.880 --> 14:07.440]  можно читать, причем каждый раз прочитать можно только
[14:07.440 --> 14:11.760]  один раз и потом заинкрементить, по-моему как-то так, ну output
[14:11.760 --> 14:14.760]  итератор тоже самое симметрично, только писать и двигать
[14:14.760 --> 14:24.160]  вперед, forward итератор, да, только вперед, ну bidirectional
[14:24.160 --> 14:27.480]  из названия понятно, тоже самое, но еще есть назад,
[14:27.480 --> 14:37.360]  так random access, да, причем за сколько?
[14:37.360 --> 14:48.880]  Регулярность, что значит регулярность, что это значит, ну возможно,
[14:48.880 --> 14:52.200]  я в таких вопросах не силен, если честно, где в стандарте
[14:52.200 --> 14:54.560]  требуется регуляр, а где не требуется, скорее всего
[14:54.560 --> 14:58.120]  требуется, да, что там output, input итератора копировать
[14:58.120 --> 15:02.360]  нельзя, конечно же, да, что это значит, начиная с forward
[15:02.360 --> 15:06.080]  там скорее всего всякая копируемость требуется,
[15:06.240 --> 15:09.320]  да, random access за от единицы можно двигать, наверное,
[15:09.320 --> 15:12.320]  элементов в любую сторону и contiguous о чем говорит?
[15:12.320 --> 15:20.720]  Да, окей, все это помним, ну давайте, что?
[15:20.720 --> 15:24.960]  Forward копировать это очень плохая идея, forward итератор копировать
[15:24.960 --> 15:25.960]  почему?
[15:25.960 --> 15:29.920]  Так, это единственный способ, что-то полезное сделать
[15:29.920 --> 15:34.200]  с forward итераторами на самом деле, кажется, что, ну потому
[15:34.200 --> 15:38.560]  что ты копируешь его, копию двигаешь куда-то, у тебя
[15:38.560 --> 15:40.680]  остался старый, ты доволен, нет?
[15:40.680 --> 15:43.880]  Ну не факт, надо, конечно, конкретные концепты смотреть,
[15:43.880 --> 15:47.280]  какие сейчас поставили там, давайте один из них посмотрим,
[15:47.280 --> 15:52.720]  ну вот предварительный концепт дурацкий, input or output итератор,
[15:52.720 --> 15:55.040]  требуется, чтобы можно было разыминовать и что-то
[15:55.040 --> 15:58.000]  референсабл получить, ну я думаю понятно, что что-то
[15:58.000 --> 16:02.760]  типа ссылку вернуть вглубь не идем сегодня, и weekly incrementable,
[16:02.760 --> 16:04.560]  но incrementable что значит?
[16:04.560 --> 16:07.800]  Можно инкремитировать, можно инкремитировать, почему
[16:07.800 --> 16:08.800]  weekly?
[16:08.800 --> 16:11.320]  Только с одной стороны?
[16:11.320 --> 16:12.320]  Нет.
[16:12.320 --> 16:16.720]  Нет, по-моему, там в том числе, нет, да, конечно, этот
[16:16.720 --> 16:21.800]  incrementable говорит про plus plus, который префиксный,
[16:21.800 --> 16:22.800]  почему weekly?
[16:22.800 --> 16:23.800]  Что это слово значит?
[16:23.800 --> 16:31.000]  Ну типа не факт, что сдвиген, ну у нас же были две недели
[16:31.080 --> 16:34.680]  назад, по-моему, всякие концепты, где было слово weekly, оно
[16:34.680 --> 16:36.440]  конкретный смысл имело в стандарте.
[16:36.440 --> 16:41.600]  Ну там ордер, да, что там слово weekly означало?
[16:41.600 --> 16:44.600]  В week-ордере.
[16:44.600 --> 16:45.600]  Иquality.
[16:45.600 --> 16:49.560]  Ну вот что-то, да, что-то про семантику, сейчас вот.
[16:49.560 --> 16:53.600]  Иquality preservation нету.
[16:53.600 --> 16:57.760]  Ну почему на input и output итераторах не требуют equality preservation,
[16:57.840 --> 17:00.840]  когда делают increment?
[17:00.840 --> 17:07.000]  Ну да, они вообще одноразовые, как вы там что-то будете
[17:07.000 --> 17:10.040]  одинаковые два создавать и потом их сравнивать?
[17:10.040 --> 17:16.440]  Ну окей, взяли стрим, читаем с него, да, input итератором,
[17:16.440 --> 17:20.120]  создали два одинаковых input итератора, прочитали
[17:20.120 --> 17:23.280]  одним по incrementale, прочитали другим по incrementale, будут
[17:23.280 --> 17:24.280]  ли они равны?
[17:24.280 --> 17:25.280]  Нет уже.
[17:25.280 --> 17:28.520]  Нет уже, потому что как бы, ну вот результаты, которые
[17:28.520 --> 17:31.280]  вы прочитаете, они будут разные, вот эти вот операции
[17:31.280 --> 17:35.440]  там incrementa и чтения, они не сохраняют equality, поэтому
[17:35.440 --> 17:38.600]  вот тут как раз одно из тех мест, когда явно оговорено
[17:38.600 --> 17:41.280]  и понятно почему equality не соблюдается, потому что
[17:41.280 --> 17:44.400]  там input и input итератор, они с внешним миром взаимодействуют,
[17:44.400 --> 17:45.720]  результат там может быть разный.
[17:45.720 --> 17:48.720]  То есть они будут равны, но это не значит, что они
[17:48.720 --> 17:50.280]  равны, что при этом они будут не равны?
[17:50.280 --> 17:52.760]  Ну ты создал два input и input итератора, изначально
[17:52.760 --> 17:54.520]  они равны, да?
[17:54.520 --> 17:58.240]  Значит, после любой последовательности операций, дозволенных,
[17:58.240 --> 17:59.960]  тоже должны остаться равны значениям.
[17:59.960 --> 18:02.520]  Например, в прошлый витфли и ордеринге было тоже equality
[18:02.520 --> 18:05.520]  непризвестно, когда у нас пары, мы сравниваем только
[18:05.520 --> 18:06.520]  по первому элементу.
[18:06.520 --> 18:08.520]  То есть все раз отличается, а первые одинаковые.
[18:08.520 --> 18:11.520]  Он нас вернул, что они равны, но по факту они не равны.
[18:11.520 --> 18:12.520]  Да.
[18:12.520 --> 18:14.520]  Но тут вопрос был, если два итератора, которые мы
[18:14.520 --> 18:17.520]  один сдвинули, второй сдвинули, ну плюс-плюс сделали,
[18:17.520 --> 18:21.520]  сравним, он выдаст трубку?
[18:21.520 --> 18:25.520]  Ну вообще, по-моему, никогда для input итераторов не делают
[18:25.520 --> 18:28.520]  оператор равенства, поэтому, да, банально некорректен
[18:28.520 --> 18:30.520]  вопрос equality preservation.
[18:30.520 --> 18:33.520]  А почему викли, если там у нас нет?
[18:33.520 --> 18:37.520]  Потому что если ты требуешь equality preservation, то ты автоматом
[18:37.520 --> 18:40.520]  требуешь как бы неявно, чтобы equality был определен,
[18:40.520 --> 18:41.520]  да?
[18:41.520 --> 18:42.520]  Да.
[18:42.520 --> 18:44.520]  Тут не требуется equality, чтобы был определен для них,
[18:44.520 --> 18:45.520]  поэтому викли.
[18:45.520 --> 18:47.520]  А тут викли просто неопределен.
[18:47.520 --> 18:50.520]  Да, и это, и даже если бы вы попытались определить,
[18:50.520 --> 18:53.520]  у вас бы все равно не получилось достичь equality preservation,
[18:53.520 --> 18:54.520]  да?
[18:54.520 --> 18:55.520]  Пример.
[18:55.520 --> 18:57.520]  Создали два input итератора на поток.
[18:57.520 --> 18:59.520]  Что значит equality preservation?
[18:59.520 --> 19:02.520]  Любое выражение от них, вот одного вычислили,
[19:02.520 --> 19:05.520]  от другого вычислили, должно одно и то же получиться
[19:05.520 --> 19:06.520]  в результате.
[19:06.520 --> 19:10.520]  Давайте от одного там разоминуем его по инкрементам,
[19:10.520 --> 19:13.520]  потом второе разоминуем по инкрементам.
[19:13.520 --> 19:16.520]  Ну понятно, что мы разные вещи прочитаем, и не будут
[19:16.520 --> 19:18.520]  равные вещи, которые мы прочитали.
[19:18.520 --> 19:19.520]  Да?
[19:19.520 --> 19:22.520]  Ну там вот такие проблемы возникают из-за взаимодействия
[19:22.520 --> 19:23.520]  с внешним миром.
[19:23.520 --> 19:26.520]  Мы не знаем, что нам там выдадут, и вот эти все вопросы
[19:26.520 --> 19:28.520]  equality preservation здесь бессмысленные.
[19:28.520 --> 19:29.520]  Поэтому...
[19:29.520 --> 19:31.520]  Окей, ладно, давайте вот это вот...
[19:31.520 --> 19:34.520]  Не так важно сейчас, надо успеть все остальное.
[19:34.520 --> 19:36.520]  Концепт input итератор.
[19:36.520 --> 19:39.520]  Вот здесь как раз используется input-output-iterator.
[19:39.520 --> 19:41.520]  Некоторое indirectly readable есть.
[19:41.520 --> 19:43.520]  Но не особо важно, что это.
[19:45.520 --> 19:48.520]  Окей, можно понять, что это вот что-то про то,
[19:48.520 --> 19:51.520]  что разыминовываешь, и получается что-то хорошее.
[19:51.520 --> 19:52.520]  Ну, не важно.
[19:52.520 --> 19:55.520]  Меня больше интересует вот это вот красное,
[19:55.520 --> 19:56.520]  iter-concept.
[19:56.520 --> 20:01.520]  Вот это как раз про понимание того, что за итератор перед нами.
[20:01.520 --> 20:04.520]  Тут требуют, чтобы был определен некоторый
[20:04.520 --> 20:07.520]  iter-concept, который вообще непонятно что пока.
[20:07.520 --> 20:10.520]  И чтобы он наследовал input-iterator-tag.
[20:12.520 --> 20:15.520]  Итератор теги, вы помните что-нибудь?
[20:15.520 --> 20:18.520]  Они друг на друга наследуют и просто обозначают,
[20:18.520 --> 20:20.520]  насколько силен наш итератор.
[20:20.520 --> 20:24.520]  Вот в итераторах надо явно указывать, что мы итератор.
[20:24.520 --> 20:27.520]  То есть какой-то рандомный тип просто никогда не должен...
[20:27.520 --> 20:31.520]  Любой тип взяли, попытались запихать в вот этот концепт.
[20:31.520 --> 20:34.520]  Он никогда не пройдет этот концепт как раз из-за
[20:34.520 --> 20:35.520]  предпоследнего требования.
[20:35.520 --> 20:36.520]  Нужна явная пометка.
[20:36.520 --> 20:38.520]  Да, я итератор, вот у меня есть тег.
[20:38.520 --> 20:40.520]  Вопрос только, где эта пометка ставится
[20:40.520 --> 20:42.520]  и что это за итер-концепт.
[20:42.520 --> 20:47.520]  Внимание на икра.
[20:47.520 --> 20:48.520]  Что?
[20:48.520 --> 20:50.520]  Для legacy?
[20:50.520 --> 20:52.520]  Да, ты абсолютно прав.
[20:52.520 --> 20:55.520]  Потому что итер-концепт нужен зачем?
[20:55.520 --> 20:57.520]  Определим итер-trades.
[20:57.520 --> 21:01.520]  Итер-trades это как бы итератор-trades, но не совсем.
[21:01.520 --> 21:05.520]  Если у нас специализирован итератор-trades,
[21:05.520 --> 21:07.520]  то мы используем эту специализацию.
[21:07.520 --> 21:10.520]  Если нет, то мы используем сам итератор.
[21:10.520 --> 21:14.520]  И прямо внутри самого итератора будем искать
[21:14.520 --> 21:18.520]  всякие наши типы, интересующие нас.
[21:18.520 --> 21:21.520]  Тут уже начинаются такие выкрутасы.
[21:21.520 --> 21:24.520]  И дальше этот итер-концепт определяется
[21:24.520 --> 21:27.520]  как либо там итератор-trades, итератор-концепт,
[21:27.520 --> 21:29.520]  если он есть, если его нет,
[21:29.520 --> 21:31.520]  итератор-trades, итератор-category.
[21:31.520 --> 21:34.520]  Если есть, а если нет, то там еще какие-то правила.
[21:34.520 --> 21:37.520]  Сложные правила для поддержания legacy.
[21:37.520 --> 21:38.520]  Но мораль в чем?
[21:38.520 --> 21:41.520]  В концепте мы не напрямую идем в тип,
[21:41.520 --> 21:44.520]  а идем через trades на самом деле.
[21:44.520 --> 21:47.520]  И вам я тоже рекомендую так делать.
[21:47.520 --> 21:49.520]  Конечно, зависит от ситуации.
[21:49.520 --> 21:52.520]  Но в целом, если вы вводите какую-то новую абстракцию,
[21:52.520 --> 21:55.520]  которая для вашего кода столь же фундаментально
[21:55.520 --> 21:57.520]  как итератор для алгоритмов,
[21:57.520 --> 21:59.520]  лучше бы иметь не только концепт,
[21:59.520 --> 22:02.520]  но и трейты для спецификации всяких деталей.
[22:02.520 --> 22:05.520]  И вот не в концепте требовать, чтобы было,
[22:05.520 --> 22:07.520]  как я вот здесь написал, какой-то value-type,
[22:07.520 --> 22:09.520]  чтобы через... пока.
[22:09.520 --> 22:11.520]  Чтобы через трейты мы прошли,
[22:11.520 --> 22:13.520]  и вот в трейте уже нашли value-type.
[22:15.520 --> 22:16.520]  Вот.
[22:16.520 --> 22:18.520]  Давайте еще просто примеры посмотрим,
[22:18.520 --> 22:20.520]  где эти трейты бывают.
[22:22.520 --> 22:23.520]  Вот такая фигня есть.
[22:23.520 --> 22:25.520]  Видели ее когда-нибудь?
[22:25.520 --> 22:28.520]  Вот я тоже когда составлял эти слайды,
[22:28.520 --> 22:30.520]  увидел ее первый раз, но она есть.
[22:30.520 --> 22:32.520]  Это трейты для всяких умных поинтеров.
[22:32.520 --> 22:34.520]  Ну и для обычного поинтера тоже.
[22:37.520 --> 22:40.520]  Тут, например, есть нормальная функция toAdress.
[22:42.520 --> 22:44.520]  Ладно, это...
[22:46.520 --> 22:48.520]  Не будем про это.
[22:52.520 --> 22:55.520]  Из зумного указателя вытащить указатель.
[23:07.520 --> 23:09.520]  Ну я не уверен, что это как бы,
[23:09.520 --> 23:11.520]  что итераторы удовлетворяют поинтер трейтсам,
[23:11.520 --> 23:13.520]  а может и удовлетворяют...
[23:13.520 --> 23:14.520]  Не знаю.
[23:14.520 --> 23:17.520]  Но это уже какая-то такая арканная магия, да?
[23:17.520 --> 23:20.520]  Вот сколько лет вы программируете на плюсах,
[23:20.520 --> 23:23.520]  про такие трейты не слышали, они, оказывается, есть.
[23:23.520 --> 23:25.520]  И вот там всякие приколы типа.
[23:25.520 --> 23:26.520]  Pointer2.
[23:26.520 --> 23:27.520]  Ребинда.
[23:27.520 --> 23:29.520]  Ну да, еще есть такие штуки.
[23:29.520 --> 23:31.520]  Ну, в общем, есть такое.
[23:31.520 --> 23:32.520]  Есть chart trades.
[23:32.520 --> 23:34.520]  Об этом вы точно не слышали.
[23:34.520 --> 23:35.520]  Слышал?
[23:35.520 --> 23:37.520]  Ты что, с Unicode'ом работаешь?
[23:37.520 --> 23:39.520]  На плюсах?
[23:39.520 --> 23:40.520]  Нет.
[23:40.520 --> 23:41.520]  Нет?
[23:41.520 --> 23:43.520]  Ну зачем тебе это тогда?
[23:43.520 --> 23:44.520]  Дальше почти.
[23:44.520 --> 23:45.520]  Ну, я не знаю.
[23:45.520 --> 23:46.520]  Я не знаю.
[23:46.520 --> 23:47.520]  Я не знаю.
[23:47.520 --> 23:48.520]  Я не знаю.
[23:48.520 --> 23:49.520]  Я не знаю.
[23:49.520 --> 23:50.520]  Я не знаю.
[23:50.520 --> 23:51.520]  Я не знаю.
[23:51.520 --> 23:52.520]  Я не знаю.
[23:52.520 --> 23:53.520]  Я не знаю.
[23:53.520 --> 23:54.520]  Я не знаю.
[23:54.520 --> 23:55.520]  Я не знаю.
[23:55.520 --> 23:56.520]  Ну, зачем тебе это тогда?
[23:56.520 --> 23:57.520]  Дальше почти.
[23:57.520 --> 23:58.520]  Почти.
[23:58.520 --> 24:00.520]  Почти слышал, а не почти работаешь?
[24:00.520 --> 24:01.520]  Почти Unicode.
[24:01.520 --> 24:02.520]  Почти Unicode.
[24:02.520 --> 24:05.520]  Ну, короче, это вот одна из темных частей стандарта.
[24:05.520 --> 24:09.520]  Мы не умеем Unicode, мы не умеем строки, мы ничего не умеем,
[24:09.520 --> 24:11.520]  но какие-то там chart trades у нас есть,
[24:11.520 --> 24:15.520]  и они там говорят всякие типы разные, интересные.
[24:15.520 --> 24:18.520]  Ну, вот как понимать, вот эти три типа.
[24:18.520 --> 24:21.520]  Off-type, post-type, state-type, implementation-defined.
[24:21.520 --> 24:22.520]  Что это?
[24:22.520 --> 24:23.520]  Зачем это?
[24:23.520 --> 24:24.520]  Не используете.
[24:24.520 --> 24:26.520]  Да, я так и живу в своей жизни.
[24:26.520 --> 24:28.520]  В принципе, мне все хорошо.
[24:28.520 --> 24:30.520]  Есть что локатер трейдсы?
[24:30.520 --> 24:33.520]  То есть какие-то фундаментальные концепции, которые есть в стандарте,
[24:33.520 --> 24:37.520]  для них есть трейды, чтобы понимать про них всякие разные интересные факты.
[24:37.520 --> 24:42.520]  Про конкретные классы, которые удовлетворяют этим абстрактным концептам,
[24:42.520 --> 24:47.520]  понимать интересные вещи, при этом не накладывая строгих ограничений
[24:47.520 --> 24:53.520]  на то, как эти сами классы выглядят, чтобы у вас там указатель мог быть итератором.
[24:54.520 --> 24:55.520]  Вот.
[24:55.520 --> 24:58.520]  Или какая-нибудь legacy могла там быть обернута через трейды
[24:58.520 --> 25:00.520]  и стать нормальным этим.
[25:00.520 --> 25:01.520]  Одна только деталь.
[25:01.520 --> 25:05.520]  По-моему, локатер трейдс с каких-то там плюсов нельзя специализировать теперь.
[25:05.520 --> 25:06.520]  Вот.
[25:06.520 --> 25:11.520]  Так что не получится ваш legacy-локатер затолкать в стандартный интерфейс.
[25:11.520 --> 25:12.520]  Но...
[25:12.520 --> 25:16.520]  А он разве не будет просто сам defining мета?
[25:16.520 --> 25:18.520]  Там не знаю, что происходило.
[25:18.520 --> 25:19.520]  Сломаться страшно.
[25:19.520 --> 25:22.520]  Что-то там, короче, какие-то телодвижения в комитете есть.
[25:22.520 --> 25:24.520]  Давайте не будем про это.
[25:24.520 --> 25:26.520]  Итог про трейты.
[25:28.520 --> 25:31.520]  Это точки кастомизации с свойстью типов.
[25:31.520 --> 25:34.520]  Какие-то вот property на уровне типов.
[25:35.520 --> 25:37.520]  С концептами они прекрасно дружат.
[25:37.520 --> 25:39.520]  Они друг друга не заменяют.
[25:39.520 --> 25:41.520]  Они просто артагональные.
[25:41.520 --> 25:43.520]  Разные функции выполняют.
[25:44.520 --> 25:48.520]  И еще такая мысль, что это не проповедение.
[25:48.520 --> 25:50.520]  Какие-то функции определять в трейтах.
[25:50.520 --> 25:53.520]  Это как бы в типах трейтах.
[25:53.520 --> 25:55.520]  Это как бы не очень кошерно.
[25:55.520 --> 25:58.520]  Считается, что вот чуть по-другому надо это делать.
[25:58.520 --> 26:04.520]  Ну, по крайней мере, согласно книжке Modern C++ Design.
[26:04.520 --> 26:06.520]  И не только ей.
[26:06.520 --> 26:08.520]  Может, это в Underworld вычитал.
[26:08.520 --> 26:11.520]  Короче, сейчас будет еще одна шняга, которая покажется похожей.
[26:11.520 --> 26:12.520]  Но на самом деле нет.
[26:12.520 --> 26:14.520]  И вот она уже про поведение.
[26:14.520 --> 26:15.520]  Будет или нет?
[26:15.520 --> 26:17.520]  У нас осталось пять минут.
[26:17.520 --> 26:19.520]  Попытаемся чуть-чуть затронуть.
[26:19.520 --> 26:20.520]  Да?
[26:21.520 --> 26:25.520]  Есть такая часть, плюс как инвалидация итератора.
[26:25.520 --> 26:26.520]  Да.
[26:26.520 --> 26:28.520]  И референс тоже.
[26:28.520 --> 26:32.520]  И разные трейнеры, они по-разному дают гарантии,
[26:32.520 --> 26:34.520]  не дала будет инвалидации или не будет инвалидации.
[26:34.520 --> 26:36.520]  И вот у меня вопрос.
[26:36.520 --> 26:38.520]  Почему эти гарантии не засунули в трейдах?
[26:38.520 --> 26:40.520]  Почему нельзя спросить...
[26:40.520 --> 26:41.520]  В смысле?
[26:41.520 --> 26:45.520]  Спросить, инвалидирует ли конкретный метод итератор.
[26:45.520 --> 26:46.520]  Ну, например?
[26:46.520 --> 26:48.520]  Когда тебе это нужно?
[26:52.520 --> 26:53.520]  Что?
[26:57.520 --> 27:00.520]  Ну, смотрите, трейды нужны, когда вы пишете обобщенный код.
[27:00.520 --> 27:01.520]  Да?
[27:01.520 --> 27:03.520]  Когда вы должны работать с любым чем-то.
[27:04.520 --> 27:07.520]  Как часто ты пишешь код, обобщенный по контейнерам?
[27:08.520 --> 27:10.520]  Я, если честно, никогда.
[27:11.520 --> 27:12.520]  Зачем?
[27:12.520 --> 27:13.520]  Какой use case этого?
[27:13.520 --> 27:19.520]  Сделать мэп, но у которого есть метод возвращающий ключ максимального значения.
[27:21.520 --> 27:22.520]  Хорошо.
[27:22.520 --> 27:24.520]  Ты наследуешь какой-то мэп.
[27:26.520 --> 27:29.520]  Ключ максимального значения, что ты там...
[27:29.520 --> 27:31.520]  Ну, в смысле, end типа или...
[27:31.520 --> 27:32.520]  Нет.
[27:32.520 --> 27:34.520]  Ну, back, front.
[27:34.520 --> 27:35.520]  Нет.
[27:35.520 --> 27:38.520]  Front и back это максимальный и минимальный ключ.
[27:38.520 --> 27:41.520]  А мне нужен ключ максимального значения.
[27:41.520 --> 27:44.520]  Ну, а зачем тебе обобщенный контейнер?
[27:44.520 --> 27:47.520]  Потому что он в нескольких местах в коде используется.
[27:48.520 --> 27:49.520]  Что?
[27:49.520 --> 27:53.520]  Ну нет, ты конкретный контейнер берешь, конкретный шаблон мапа.
[27:53.520 --> 27:55.520]  И вот его используешь, правда?
[27:55.520 --> 27:57.520]  Ты же знаешь, какие у него методы, что инвалидирует и что...
[27:57.520 --> 27:58.520]  Это понятно.
[27:58.520 --> 27:59.520]  Ну, все.
[27:59.520 --> 28:03.520]  Поэтому просто не возникает use case, когда у вас код обобщен именно по...
[28:03.520 --> 28:04.520]  По значениям.
[28:04.520 --> 28:05.520]  По значениям.
[28:05.520 --> 28:06.520]  По значениям.
[28:06.520 --> 28:07.520]  По значениям.
[28:07.520 --> 28:11.520]  Не возникает use case, когда у вас код обобщен именно по...
[28:12.520 --> 28:15.520]  Не специализации шаблона контейнера,
[28:15.520 --> 28:17.520]  а по самому шаблону контейнера.
[28:17.520 --> 28:21.520]  Потому что нужно для каждого контента чуть-чуть проверять.
[28:21.520 --> 28:24.520]  Ну да, еще непонятно, какой API...
[28:24.520 --> 28:27.520]  А если мы знаем API контейнера,
[28:27.520 --> 28:29.520]  мы, скорее всего, знаем контейнер.
[28:29.520 --> 28:36.520]  Да, и тут просто не сложилось на уровне концептуальном.
[28:36.520 --> 28:37.520]  Такого кода не бывает.
[28:37.520 --> 28:39.520]  Поэтому нужды в этом нет.
[28:39.520 --> 28:41.520]  Мне кажется, так.
[28:41.520 --> 28:44.520]  Но если у тебя есть какие-то очень хорошие use case,
[28:44.520 --> 28:46.520]  ты можешь принести предложение в комитет.
[28:46.520 --> 28:48.520]  Там тебя закидают пометом.
[28:53.520 --> 28:55.520]  Ну опять же, да, интерфейсы разные.
[28:55.520 --> 28:57.520]  Если вы интерфейс зафиксировали, то...
[28:58.520 --> 29:00.520]  Да нет.
[29:00.520 --> 29:04.520]  Специально называют их по-разному, чтобы ты не мог обобщить на самом-то деле.
[29:04.520 --> 29:06.520]  Почему?
[29:06.520 --> 29:08.520]  Что?
[29:08.520 --> 29:10.520]  Это же получается палку в колеса списать.
[29:10.520 --> 29:14.520]  Нет, это правильные палки, потому что пытаться обобщить в этом месте не надо.
[29:14.520 --> 29:17.520]  Используй конкретную структуру данных.
[29:17.520 --> 29:19.520]  Давайте...
[29:19.520 --> 29:21.520]  Что?
[29:24.520 --> 29:26.520]  Я не расслышал, помню, что ты сказал,
[29:26.520 --> 29:30.520]  но это важно, потому что нам надо ехать дальше сейчас буквально за 5 минут,
[29:30.520 --> 29:32.520]  попытаемся прилететь.
[29:32.520 --> 29:34.520]  Вот алгоритм, да.
[29:35.520 --> 29:37.520]  Вот мы тут ИФ завязали.
[29:37.520 --> 29:39.520]  Наверное, не надо.
[29:39.520 --> 29:41.520]  Мы не любим ИФы, мы любим там какой-то полиморфизм,
[29:41.520 --> 29:43.520]  как-то выносить это все.
[29:43.520 --> 29:45.520]  Ну и как бы я уже сказал про точки кастомизации,
[29:45.520 --> 29:47.520]  вот сейчас не через них будем,
[29:47.520 --> 29:49.520]  и вообще это плохой пример для того, что будет.
[29:49.520 --> 29:51.520]  Мы будем в рамках класса конкретного.
[29:51.520 --> 29:53.520]  Ладно, нет, рано говорю.
[29:53.520 --> 29:57.520]  Тут вообще много параметров вот у этого алгоритма.
[29:57.520 --> 30:00.520]  Или абстрактного алгоритма.
[30:01.520 --> 30:03.520]  Да.
[30:03.520 --> 30:06.520]  Будем смотреть абстрактный алгоритм распределенной сортировки.
[30:06.520 --> 30:10.520]  Какие точки кастомизации у него в принципе могут быть.
[30:10.520 --> 30:12.520]  На самом деле их много, да.
[30:12.520 --> 30:14.520]  Тут есть...
[30:14.520 --> 30:16.520]  Ну вообще, что он делает?
[30:16.520 --> 30:18.520]  Он параллельно сортирует значения.
[30:18.520 --> 30:20.520]  И вот ему нужно и понять,
[30:20.520 --> 30:22.520]  в каком виде они приходят,
[30:22.520 --> 30:24.520]  и в каком виде на выход,
[30:24.520 --> 30:26.520]  то есть какие-то контейнеры нужны,
[30:26.520 --> 30:28.520]  и понять, что значит параллельно,
[30:28.520 --> 30:32.520]  и мифический нужен, чтобы там как-то вот это все запустить.
[30:32.520 --> 30:34.520]  Некоторые локаторы нужны,
[30:34.520 --> 30:36.520]  чтобы промежуточные штуки хранить.
[30:36.520 --> 30:38.520]  Нужно и компаратор тоже, в принципе,
[30:38.520 --> 30:40.520]  чтобы понять, как данные сравнивать.
[30:40.520 --> 30:42.520]  Вот все эти разные точки кастомизации,
[30:42.520 --> 30:44.520]  они вот как бы артагональны,
[30:44.520 --> 30:46.520]  и по ним нужно, даже, наверное,
[30:46.520 --> 30:48.520]  не очень корректно это говорить,
[30:48.520 --> 30:50.520]  точками кастомизации,
[30:50.520 --> 30:52.520]  это некоторые такие параметры алгоритма,
[30:52.520 --> 30:56.520]  которые вот на уровне входа нужно как-то указать.
[30:56.520 --> 30:58.520]  И в случае с функциями,
[30:58.520 --> 31:00.520]  тут особо как бы трюков я никаких не расскажу,
[31:00.520 --> 31:02.520]  а вот если вы пишете некоторый класс
[31:02.520 --> 31:05.520]  для алгоритма распределенной сортировки,
[31:05.520 --> 31:08.520]  то сейчас будет смешной прикол.
[31:08.520 --> 31:10.520]  Ну, перед тем, как прикол рассказать,
[31:10.520 --> 31:14.520]  надо понять, что мы хотим от вот такого механизма,
[31:14.520 --> 31:16.520]  чтобы задавать все эти разные параметры.
[31:16.520 --> 31:18.520]  Во-первых, он должен быть полностью открытый,
[31:18.520 --> 31:22.520]  то есть если мы хотим, мы должны смочь свой новый локатор написать и подставить, так?
[31:22.520 --> 31:24.520]  Написать свой новый экзекьютор и запихать туда,
[31:24.520 --> 31:26.520]  или свой новый контейнер.
[31:28.520 --> 31:30.520]  Ну, контейнеры новые написали,
[31:30.520 --> 31:32.520]  подставили туда, но мы должны соблюдать контракт,
[31:32.520 --> 31:34.520]  который там учитывается.
[31:34.520 --> 31:37.520]  А я не думаю, что кто-то в алгоритме распределенной сортировки
[31:37.520 --> 31:39.520]  будет заранее думать,
[31:39.520 --> 31:43.520]  а инвалидируются ли там итераторы у твоего классного контейнера,
[31:43.520 --> 31:46.520]  который как-то там, ну, нет.
[31:46.520 --> 31:48.520]  Такого просто не делают.
[31:50.520 --> 31:53.520]  Да, вот эти все параметры, которые мы собрались уносить,
[31:53.520 --> 31:55.520]  они обязательно должны быть артагональными,
[31:55.520 --> 31:57.520]  понимаете, о чем я, да?
[31:57.520 --> 32:00.520]  Не должно быть такого, что вот такие две комбинации друг с другом не работают,
[32:00.520 --> 32:04.520]  а если вы используете вот это вот, то вы там обязаны вот это вот использовать.
[32:04.520 --> 32:06.520]  Все эти параметры, они независимо меняются.
[32:06.520 --> 32:09.520]  Любой из них можно поменять, другие оставить как были,
[32:09.520 --> 32:11.520]  и все будет нормально в теории.
[32:13.520 --> 32:15.520]  И мы должны избежать комбинаторного взрыва.
[32:15.520 --> 32:19.520]  Ну, очевидно, мы не хотим руками все комбинации там прописывать,
[32:19.520 --> 32:21.520]  как-то вот что-то...
[32:22.520 --> 32:24.520]  Ну, понятно, о чем я.
[32:24.520 --> 32:26.520]  Ну, и тут уже в голову приходят всякие идеи,
[32:26.520 --> 32:29.520]  типа, ну, давайте как-то шаблонными аргументами
[32:29.520 --> 32:31.520]  какого-то вот этого вот алгоритма это указывать
[32:31.520 --> 32:33.520]  и потом как-то к ним дергаться.
[32:34.520 --> 32:37.520]  Но у нас на самом деле есть общий инструмент для этого.
[32:37.520 --> 32:39.520]  Называется стратегия.
[32:41.520 --> 32:45.520]  Ну, когда в ОП вы хотите что-то из вот этого всего кастомизировать,
[32:45.520 --> 32:47.520]  берете и делаете интерфейс,
[32:47.520 --> 32:49.520]  кайф-экзекютер, который имеет нет-экзекют,
[32:49.520 --> 32:52.520]  имеет интерфейс-компаратор с методом compare.
[32:52.520 --> 32:56.520]  Интерфейс, там, аллокатор с методом create и там remove.
[32:56.520 --> 32:58.520]  Не знаю, в джаве так делают или нет.
[32:58.520 --> 33:01.520]  Но у нас не ОП.
[33:02.520 --> 33:05.520]  И в целом мы хотим вот эту вот идею стратегии...
[33:05.520 --> 33:07.520]  Ну, а что это?
[33:07.520 --> 33:10.520]  Это, по сути, просто интерфейс с одним методом запустить.
[33:10.520 --> 33:13.520]  Интерфейс, который с одной целью существует,
[33:13.520 --> 33:17.520]  мы хотим закрыть то, какую именно функцию мы запускаем.
[33:19.520 --> 33:22.520]  Перенесем это в compile-time в каком-то смысле.
[33:22.520 --> 33:24.520]  Делать мы это будем так.
[33:27.520 --> 33:31.520]  Context — это класс, который как раз отвечает за нашу распределенную сортировку
[33:31.520 --> 33:33.520]  или еще что-то.
[33:33.520 --> 33:36.520]  И ему нужна стратегия того, как делать сальтуху.
[33:37.520 --> 33:42.520]  Ну, это может быть стратегия аллокации, стратегия еще чего-то.
[33:42.520 --> 33:45.520]  Даже стратегия копирования, например.
[33:47.520 --> 33:52.520]  И мы потребуем, чтобы у шаблонного аргумента, который здесь будет указан,
[33:52.520 --> 33:55.520]  был метод статический — сделать сальтуху.
[33:56.520 --> 34:00.520]  И в, собственно, нашем коде, где мы захотели сделать сальтуху,
[34:00.520 --> 34:02.520]  мы берем ее и делаем.
[34:03.520 --> 34:04.520]  Окей?
[34:04.520 --> 34:07.520]  Просто взяли и сделали стратегию статической.
[34:07.520 --> 34:09.520]  Пока ничего волшебного.
[34:09.520 --> 34:11.520]  Ну, причем без состояния.
[34:11.520 --> 34:12.520]  Да.
[34:12.520 --> 34:16.520]  Здесь, так как метод статический, мы не можем никакое состояние в стратегии хранить.
[34:16.520 --> 34:21.520]  Это такой просто заглушка, чтобы передать метод внутрь шаблона.
[34:21.520 --> 34:26.520]  С таким же успехом здесь можно было бы передать указатель на функцию в шаблон.
[34:26.520 --> 34:28.520]  Умеем так?
[34:28.520 --> 34:29.520]  Надеюсь, умеем.
[34:29.520 --> 34:32.520]  Вот этот синтакс, синт в скобочках звездочка.
[34:32.520 --> 34:34.520]  Можно пойти дальше.
[34:36.520 --> 34:37.520]  Чего?
[34:41.520 --> 34:42.520]  С кем?
[34:42.520 --> 34:44.520]  Я слова не могу расслышать.
[34:44.520 --> 34:45.520]  Фронды.
[34:53.520 --> 34:55.520]  Ну, в смысле, ну...
[34:59.520 --> 35:01.520]  Ну, это просто функция какая-то.
[35:01.520 --> 35:04.520]  Ну, D должно быть, да, так класс должен быть.
[35:04.520 --> 35:06.520]  Ну, в общем-то, да.
[35:06.520 --> 35:09.520]  Ну, это просто функция какая-то.
[35:09.520 --> 35:12.520]  Ну, D должно быть, да, так класс должен быть, наверное, публичный,
[35:12.520 --> 35:15.520]  видимый вот этим вот конкретным классом,
[35:15.520 --> 35:18.520]  который удовлетворяет вот этому концепту сделать с Альтуху.
[35:20.520 --> 35:24.520]  Ну, что произошло, по сути, мы просто взяли и сделали вместо интерфейса
[35:24.520 --> 35:26.520]  для паттерна стратегия концепт.
[35:26.520 --> 35:28.520]  И вместо того, чтобы передавать объект, там,
[35:28.520 --> 35:30.520]  передаем теперь шаблонное, эту штуку.
[35:32.520 --> 35:35.520]  Такой перенос паттерна на статические рельсы.
[35:35.520 --> 35:37.520]  Ну, мы пойдем дальше.
[35:38.520 --> 35:42.520]  Мы не просто статическую функцию потребуем,
[35:42.520 --> 35:44.520]  а обычный метод.
[35:45.520 --> 35:48.520]  И будем себя наследовать от стратегии.
[35:49.520 --> 35:50.520]  Зачем?
[35:51.520 --> 35:52.520]  Зачем?
[35:52.520 --> 35:53.520]  Хороший вопрос.
[35:53.520 --> 35:56.520]  Ну, теперь мы можем писать саммерсолд без двух двоеточек,
[35:56.520 --> 35:58.520]  это прикольно.
[35:58.520 --> 35:59.520]  Состояние.
[35:59.520 --> 36:01.520]  Состояние можем хранить, да, например.
[36:01.520 --> 36:03.520]  Можем каять циклы.
[36:04.520 --> 36:06.520]  Можем CRTP накастовать.
[36:07.520 --> 36:08.520]  MTBase Optimization.
[36:08.520 --> 36:10.520]  Еще MTBase Optimization, да.
[36:10.520 --> 36:13.520]  Но почему именно наследуемся, а не храним как поле?
[36:13.520 --> 36:15.520]  Ну, на самом деле...
[36:15.520 --> 36:18.520]  Ну, как поле тоже, наверное, можно.
[36:18.520 --> 36:20.520]  Сейчас мы же можем и контрастать.
[36:20.520 --> 36:21.520]  Ну, да.
[36:22.520 --> 36:24.520]  Ну, исторически так сложилось.
[36:26.520 --> 36:31.520]  Если кого-то интерфейс принимающий стратегию
[36:32.520 --> 36:35.520]  и мы хотим себя...
[36:35.520 --> 36:37.520]  Нет, такого мы не хотим.
[36:37.520 --> 36:40.520]  Мы хотим кастомизировать поведение внутри вот этого контекста.
[36:40.520 --> 36:42.520]  Вот контекст делает много всякого кода,
[36:42.520 --> 36:45.520]  и у него есть какие-то вот места, где можно что-то поменять.
[36:45.520 --> 36:48.520]  Поменять экзекьютор, поменять там локатор, поменять еще что-то.
[36:48.520 --> 36:51.520]  И мы вот ровно эту задачу решаем.
[36:51.520 --> 36:54.520]  Вот такое решение вполне ок.
[36:54.520 --> 36:57.520]  Ну, и вот эта вот такая статическая стратегия,
[36:57.520 --> 37:00.520]  где мы наследуемся от набора стратегий,
[37:00.520 --> 37:02.520]  она называется policy в книжках.
[37:02.520 --> 37:04.520]  И не только.
[37:04.520 --> 37:07.520]  Ну, и есть целое такое направление.
[37:07.520 --> 37:09.520]  Policy-based design.
[37:09.520 --> 37:12.520]  Что это дизайн шаблонных библиотек,
[37:12.520 --> 37:15.520]  который основывается на вот таких вот политиках.
[37:15.520 --> 37:17.520]  Ну, почему это здорово?
[37:17.520 --> 37:20.520]  Вы же любую политику можете написать и подмешать в класс,
[37:20.520 --> 37:22.520]  и оно будет работать так же быстро,
[37:22.520 --> 37:26.520]  как если бы автор этой библиотеки изначально там такой код вписал.
[37:26.520 --> 37:29.520]  Ну, еще много всяких приколов есть.
[37:29.520 --> 37:32.520]  Просто дальше ехать и смотреть примерчики классные.
[37:32.520 --> 37:35.520]  Есть некоторый виджет-менеджер.
[37:35.520 --> 37:40.520]  Ему нужна политика создания виджетов, наверное.
[37:40.520 --> 37:42.520]  Ну, как это использовать?
[37:42.520 --> 37:44.520]  Сделать две политики каких-то.
[37:44.520 --> 37:48.520]  Вот одна через Нью создаёт, другая через клон чего-то.
[37:48.520 --> 37:52.520]  И пихнуть OpNew Creator от виджета.
[37:52.520 --> 37:54.520]  Но это не очень удобно.
[37:54.520 --> 37:56.520]  Потому что мы же понимаем, что вот этот виджет-менеджер
[37:56.520 --> 37:58.520]  хочет создавать виджеты.
[37:58.520 --> 38:02.520]  Зачем тому, кто из вне собрался использовать виджет-менеджер,
[38:02.520 --> 38:04.520]  указывать конкретно, что виджет.
[38:04.520 --> 38:06.520]  А если он укажет не виджет, то что-то другое.
[38:06.520 --> 38:08.520]  Может, оно не скомпилируется.
[38:08.520 --> 38:10.520]  Ну, в общем, странно.
[38:10.520 --> 38:12.520]  Зачем это уточнять?
[38:12.520 --> 38:15.520]  Давайте просто шаблонные-шаблонные аргументы использовать.
[38:15.520 --> 38:21.520]  Вот это вот более полное видение того, что такое по политике.
[38:21.520 --> 38:25.520]  В книжке Александреска уже книжка, да, в ней.
[38:25.520 --> 38:27.520]  Вот ровно так показывают, что такое политика.
[38:27.520 --> 38:32.520]  Шаблонный-шаблонный аргумент, который как-то кастомизирует поведение,
[38:32.520 --> 38:36.520]  которое вы инстанцируете сами и наследуетесь от него.
[38:36.520 --> 38:39.520]  То есть вот именно такой паттерн визуально.
[38:39.520 --> 38:41.520]  Это не CRTP.
[38:41.520 --> 38:43.520]  Вот этот вот виджет – это у нас конкретный класс.
[38:43.520 --> 38:45.520]  Он ниоткуда не приходит с небес.
[38:45.520 --> 38:48.520]  Мы прямо вот знаем, что нам нужно создавать виджеты.
[38:48.520 --> 38:51.520]  Поэтому мы инстанцируем политику создания для виджета.
[38:51.520 --> 38:53.520]  А можем не только для виджета.
[38:53.520 --> 38:57.520]  Вот несколько разных политик создания чего-то отнаследоваться
[38:57.520 --> 39:00.520]  и уметь создавать все виды объектов, которые нам нужны.
[39:00.520 --> 39:05.520]  Возможно, не уверен.
[39:05.520 --> 39:09.520]  Но тут всегда можно сказать типа декоратор, когда речь идет о дизайне.
[39:09.520 --> 39:12.520]  Везде одинаковые трюки используются.
[39:12.520 --> 39:14.520]  Ввести еще один indirection.
[39:14.520 --> 39:19.520]  Вот здесь мы в качестве indirection принимаем что-то в шаблонные аргументы
[39:19.520 --> 39:21.520]  и наследуемся от него.
[39:21.520 --> 39:24.520]  Можно концептом завестись.
[39:24.520 --> 39:26.520]  Как-то хочется.
[39:26.520 --> 39:28.520]  Видим голый класс.
[39:28.520 --> 39:30.520]  Вернее, голый template-class-class.
[39:30.520 --> 39:35.520]  Хотим шаблоны в концепты вернуть, чтобы как-то сказать пользователю,
[39:35.520 --> 39:38.520]  что конкретно мы сюда ожидаем, нам подставят.
[39:38.520 --> 39:42.520]  Тут можно написать так.
[39:42.520 --> 39:45.520]  Будет работать.
[39:45.520 --> 39:49.520]  Вот нашла коса на камень, что называется.
[39:49.520 --> 39:52.520]  Вот T это шаблон.
[39:52.520 --> 39:55.520]  А переменная не может быть типа просто шаблон.
[39:55.520 --> 39:57.520]  Нужен конкретный тип.
[39:57.520 --> 39:59.520]  Какую специализацию хотим?
[39:59.520 --> 40:01.520]  Еще один type name.
[40:01.520 --> 40:03.520]  Какой еще один type name?
[40:03.520 --> 40:05.520]  Можно спросить явно аргументам.
[40:05.520 --> 40:07.520]  Можно дурацкий подход.
[40:07.520 --> 40:11.520]  Сделать некоторого свидетеля, что крейт есть, хоть какой-то.
[40:11.520 --> 40:13.520]  И подставлять его.
[40:13.520 --> 40:16.520]  То есть технически что мы хотим написать?
[40:16.520 --> 40:22.520]  Для любого U, T от U нормальный класс.
[40:22.520 --> 40:24.520]  И можно вызвать крейт.
[40:24.520 --> 40:29.520]  Или для любого U, который наследуется от чего-нибудь.
[40:29.520 --> 40:33.520]  Мы поднимали на одной из прошлых парт этот вопрос,
[40:33.520 --> 40:37.520]  что хочется иметь квантор всеобщности не только по переменам T,
[40:37.520 --> 40:39.520]  но и по типам каким-то.
[40:39.520 --> 40:43.520]  Для любого U, T от U инстанцируется.
[40:43.520 --> 40:45.520]  Нельзя. Нет такого.
[40:45.520 --> 40:47.520]  Поэтому вот такой хак предлагается.
[40:47.520 --> 40:50.520]  Проверить на одном конкретном и надеяться, что если на нем сработало,
[40:50.520 --> 40:52.520]  то сработает на всех.
[40:52.520 --> 40:54.520]  Еще раз не очень.
[40:54.520 --> 40:56.520]  То есть вопрос фиктивный.
[40:56.520 --> 40:59.520]  Мы фиктивный класс поставляем?
[40:59.520 --> 41:01.520]  Да.
[41:01.520 --> 41:03.520]  Тупейший хак.
[41:03.520 --> 41:05.520]  Но иногда, может, и его хватит.
[41:05.520 --> 41:07.520]  То есть если там во всяком...
[41:07.520 --> 41:09.520]  Ну, такая простая ситуация, что там...
[41:09.520 --> 41:11.520]  Сейчас когда ему не хватит?
[41:11.520 --> 41:16.520]  Если это класс, закрытый от пользователей?
[41:16.520 --> 41:20.520]  Ну, если класс требует какого-то интерфейса от того,
[41:20.520 --> 41:22.520]  что в него подставляют.
[41:22.520 --> 41:25.520]  То есть если это вот T, то есть какой-то концепт внутри.
[41:25.520 --> 41:28.520]  Вот тогда это все, типа, поломается.
[41:28.520 --> 41:32.520]  Ну, конечно, это же не может быть просто потому,
[41:32.520 --> 41:36.520]  что у нас написан интерплейт класс-класс.
[41:36.520 --> 41:38.520]  Может.
[41:38.520 --> 41:40.520]  Сюда нельзя вписывать.
[41:40.520 --> 41:42.520]  Не работает так.
[41:42.520 --> 41:44.520]  Нельзя вписывать концепты.
[41:44.520 --> 41:47.520]  Да, но если даже у класса написано, что он концепт хочет,
[41:47.520 --> 41:50.520]  оно спокойно сюда подставится в качестве шаблона.
[41:50.520 --> 41:52.520]  Ну и да.
[41:52.520 --> 41:54.520]  Ну, короче, тут...
[41:54.520 --> 41:57.520]  Чувствуете некоторые несостыковки в языке?
[41:57.520 --> 41:59.520]  Как-то все так вот корявенько.
[41:59.520 --> 42:01.520]  Ну, к сожалению, вот так.
[42:01.520 --> 42:04.520]  Да, тут еще есть такой вопрос.
[42:04.520 --> 42:06.520]  Откуда вообще прототип будет браться?
[42:06.520 --> 42:08.520]  Прототип криэйтора.
[42:08.520 --> 42:10.520]  Ну, что значит прототип криэйтора?
[42:10.520 --> 42:12.520]  Значит, он там какой-то объект у себя имеет
[42:12.520 --> 42:15.520]  и возвращает его клоны, копии каким-то образом полученные.
[42:15.520 --> 42:18.520]  Ну, возможно, такое нужно там зачем-то.
[42:18.520 --> 42:20.520]  Уже стилизованный виджет туда положили,
[42:20.520 --> 42:23.520]  и вот он уже стилизованные копии возвращает.
[42:23.520 --> 42:25.520]  Так как положить-то?
[42:25.520 --> 42:28.520]  Ну, предлагаются тупые хаки.
[42:28.520 --> 42:34.520]  Просто взять и сделать методы getPrototype, setPrototype в криэйторе,
[42:34.520 --> 42:39.520]  и внимание, понт этой всей схемы с политиками.
[42:39.520 --> 42:41.520]  Вот оно, состояние.
[42:41.520 --> 42:43.520]  Мы подмешали новое состояние,
[42:43.520 --> 42:45.520]  и можем его сетать и гетать снаружи.
[42:45.520 --> 42:48.520]  Вот эти методы мы их просто подмешаем
[42:48.520 --> 42:51.520]  внутрь того класса, который будет эту политику использовать.
[42:51.520 --> 42:55.520]  И вот если мы знаем, что у нас наша конкретная специализация,
[42:55.520 --> 42:59.520]  которой мы пользуемся, она вот политику криэйтора использует,
[42:59.520 --> 43:01.520]  то мы можем вызвать эти методы.
[43:01.520 --> 43:03.520]  Берем, вызываем.
[43:03.520 --> 43:07.520]  Это в ходе того, что мы наследуемся от чего-то,
[43:07.520 --> 43:09.520]  если мы хотим подмешать методы,
[43:09.520 --> 43:12.520]  мы можем отнесеться, можем сделать так.
[43:12.520 --> 43:14.520]  Или где-нибудь.
[43:14.520 --> 43:18.520]  Да, мы подмешиваем новые методы, которые...
[43:18.520 --> 43:22.520]  Можем ли мы так правильно правильно сделать?
[43:22.520 --> 43:24.520]  Что сделать?
[43:24.520 --> 43:26.520]  Бранчинг.
[43:26.520 --> 43:28.520]  Если мы...
[43:28.520 --> 43:30.520]  Что?
[43:30.520 --> 43:33.520]  А тут конструктор явно написан.
[43:33.520 --> 43:35.520]  Вот да.
[43:35.520 --> 43:37.520]  Тут можно так, можно всяк.
[43:37.520 --> 43:39.520]  Просто конструктор плохо,
[43:39.520 --> 43:41.520]  потому что нам придется как бы менять конструктор
[43:41.520 --> 43:43.520]  того, кто политику имплементирует,
[43:43.520 --> 43:45.520]  чтобы он еще инициализировал.
[43:45.520 --> 43:49.520]  Если бы мы хотели все-таки не иметь конструктора,
[43:49.520 --> 43:52.520]  а иметь статические методы.
[43:52.520 --> 43:54.520]  Тогда никак не получится.
[43:54.520 --> 43:56.520]  У тебя стейт нужен.
[43:56.520 --> 43:58.520]  Что ты копировать будешь?
[43:58.520 --> 44:00.520]  Это фундаментально такой типа creator,
[44:00.520 --> 44:02.520]  который имеет стейт.
[44:02.520 --> 44:04.520]  Он копирует какой-то конкретный объект.
[44:04.520 --> 44:06.520]  Ну да.
[44:06.520 --> 44:08.520]  Такое подмешивание методов
[44:08.520 --> 44:10.520]  отличается просто от наследоваться,
[44:10.520 --> 44:12.520]  а тем, что родитель без CRTP тогда не сможет.
[44:12.520 --> 44:14.520]  Пользуется тем, что есть в ребенке.
[44:14.520 --> 44:16.520]  А тут я напомню,
[44:16.520 --> 44:18.520]  вот этот вот виджет-менеджер
[44:18.520 --> 44:20.520]  использует метод create.
[44:20.520 --> 44:22.520]  То есть CRTP и эта штука,
[44:22.520 --> 44:24.520]  они в каком-нибудь смысле противоположны.
[44:24.520 --> 44:26.520]  CRTP говорит,
[44:26.520 --> 44:28.520]  что мы будем наследоваться от кого-то,
[44:28.520 --> 44:30.520]  от главного куска кода,
[44:30.520 --> 44:33.520]  и наши методы наш родитель
[44:33.520 --> 44:35.520]  сможет использовать за счет CRTP.
[44:35.520 --> 44:37.520]  Ну и мы, соответственно,
[44:37.520 --> 44:39.520]  методы родителя можем использовать.
[44:39.520 --> 44:41.520]  А тут мы говорим наоборот.
[44:41.520 --> 44:43.520]  Давайте главный кусок кода
[44:43.520 --> 44:45.520]  наследуется от политик,
[44:45.520 --> 44:47.520]  и мы можем использовать методы из политика,
[44:47.520 --> 44:49.520]  и политики могут нам подмешать
[44:49.520 --> 44:51.520]  новых методов, которые пользователям будут доступны.
[44:51.520 --> 44:53.520]  Вот, это про это.
[44:53.520 --> 44:55.520]  Что ты говорил?
[44:55.520 --> 44:57.520]  Подумал, что, наверное,
[44:57.520 --> 44:59.520]  можно просто create, getPrototype
[44:59.520 --> 45:01.520]  одну функцию сделать,
[45:01.520 --> 45:03.520]  и тогда элементы держат
[45:03.520 --> 45:05.520]  на стейке.
[45:05.520 --> 45:07.520]  Что? Нет, create это
[45:07.520 --> 45:09.520]  фиксированный интерфейс,
[45:09.520 --> 45:11.520]  что виджет-менеджер всегда пытается вызвать
[45:11.520 --> 45:13.520]  в своей полисе метод create
[45:13.520 --> 45:15.520]  без аргументов.
[45:15.520 --> 45:17.520]  Crate ровно так должен быть имплементирован,
[45:17.520 --> 45:19.520]  не как иначе.
[45:19.520 --> 45:21.520]  То есть это что?
[45:21.520 --> 45:23.520]  Как мы будем использовать это?
[45:23.520 --> 45:25.520]  В смысле?
[45:25.520 --> 45:27.520]  Есть виджет-менеджер, он хочет создавать виджеты.
[45:27.520 --> 45:29.520]  Он всегда дергает метод create.
[45:29.520 --> 45:31.520]  Все.
[45:31.520 --> 45:33.520]  У своего creation полисе дергает метод create.
[45:33.520 --> 45:35.520]  Мы,
[45:35.520 --> 45:37.520]  тот, кто извне создал
[45:37.520 --> 45:39.520]  виджет-менеджер, который использует
[45:39.520 --> 45:41.520]  prototype creator, он сам обязан
[45:41.520 --> 45:43.520]  сделать set.
[45:43.520 --> 45:45.520]  Но он же знает, что он использует prototype
[45:45.520 --> 45:47.520]  creator, да?
[45:47.520 --> 45:49.520]  Он знает, что там будет метод set.
[45:49.520 --> 45:51.520]  Почему метод set будет у виджет-менеджера?
[45:51.520 --> 45:53.520]  Ну, просто наследование.
[45:53.520 --> 45:55.520]  Он вызовет его и установит
[45:55.520 --> 45:57.520]  конкретный prototype, и дальше виджет-менеджер
[45:57.520 --> 45:59.520]  нормально будет функционировать.
[45:59.520 --> 46:01.520]  Это, конечно, не очень круто, мы нарушаем
[46:01.520 --> 46:03.520]  райи, но лучше не получилось.
[46:03.520 --> 46:05.520]  А если у нас
[46:05.520 --> 46:07.520]  есть default-ный аргумент?
[46:07.520 --> 46:09.520]  У нас же концепт проверяет, что
[46:09.520 --> 46:11.520]  если мы require, спишем и просто
[46:11.520 --> 46:13.520]  вызов, да, какой-то,
[46:13.520 --> 46:15.520]  то он проверяет, что это просто wall-defined,
[46:15.520 --> 46:17.520]  поэтому если я напишу в create,
[46:17.520 --> 46:19.520]  вот если я напишу в create,
[46:19.520 --> 46:21.520]  с default-ным аргументом
[46:21.520 --> 46:23.520]  будет работать просто.
[46:23.520 --> 46:25.520]  И тогда я могу выменить
[46:25.520 --> 46:27.520]  вот эти два метода,
[46:27.520 --> 46:29.520]  которые я использую, как
[46:29.520 --> 46:31.520]  способ заследить
[46:31.520 --> 46:33.520]  прототип, я могу
[46:33.520 --> 46:35.520]  на самом деле сделать
[46:35.520 --> 46:37.520]  стейп и
[46:37.520 --> 46:39.520]  оставить его.
[46:39.520 --> 46:41.520]  У меня create будет
[46:41.520 --> 46:43.520]  принимать опциональный аргумент
[46:43.520 --> 46:45.520]  тестом звездочками.
[46:45.520 --> 46:47.520]  Да, но если он
[46:47.520 --> 46:49.520]  по дефолту null,
[46:49.520 --> 46:51.520]  и ты в виджет менеджере уже написал
[46:51.520 --> 46:53.520]  кучу кода, который зовет create без
[46:53.520 --> 46:55.520]  аргумента,
[46:55.520 --> 46:57.520]  цель метода create...
[46:57.520 --> 46:59.520]  Бранчинг важно описать просто
[46:59.520 --> 47:01.520]  в теле функции, что если мы пришли... Зачем?
[47:01.520 --> 47:03.520]  Это
[47:03.520 --> 47:05.520]  антитезис тому, к чему мы хотим прийти.
[47:05.520 --> 47:07.520]  Ты вытягиваешь
[47:07.520 --> 47:09.520]  вот эти вот артагональные
[47:09.520 --> 47:11.520]  кейсы обратно в главный алгоритм
[47:11.520 --> 47:13.520]  и начинаешь их там...
[47:13.520 --> 47:15.520]  Короче, это путь никуда, потом у тебя еще
[47:15.520 --> 47:17.520]  бранчинга будет с каждым разом, надо хранить
[47:17.520 --> 47:19.520]  все артагональным и вот
[47:19.520 --> 47:21.520]  single responsibility. Вот этот чувак
[47:21.520 --> 47:23.520]  не должен думать о том, что там какие-то
[47:23.520 --> 47:25.520]  прототипы могут использоваться.
[47:25.520 --> 47:27.520]  Он же не будет думать.
[47:27.520 --> 47:29.520]  Ну ты говоришь, здесь if и напишем, что if
[47:29.520 --> 47:31.520]  прототип так... Нет, if и будут
[47:31.520 --> 47:33.520]  в теле криейта,
[47:33.520 --> 47:35.520]  который мы пишем один раз для
[47:35.520 --> 47:37.520]  прототип криейтора. Так, и какой if?
[47:37.520 --> 47:39.520]  Какой if? Если мы пришел null,
[47:39.520 --> 47:41.520]  то он интерпретирует
[47:41.520 --> 47:43.520]  этот вызов, как просто
[47:43.520 --> 47:45.520]  установить прототип, который в него
[47:45.520 --> 47:47.520]  положен, state статической переменной.
[47:47.520 --> 47:49.520]  Если он пришел не null, то значит его нужно
[47:49.520 --> 47:51.520]  выставить.
[47:51.520 --> 47:53.520]  То есть ты говоришь
[47:53.520 --> 47:55.520]  извне, ты хочешь
[47:55.520 --> 47:57.520]  извне вызвать create этот аргумент и
[47:57.520 --> 47:59.520]  типа это более читаемый код, да? Зачем?
[47:59.520 --> 48:01.520]  Это код, который
[48:01.520 --> 48:03.520]  позволит state брать.
[48:03.520 --> 48:05.520]  Так а куда ты установишь этот прототип?
[48:05.520 --> 48:07.520]  Статическую перемену.
[48:09.520 --> 48:11.520]  Прекрасная идея.
[48:11.520 --> 48:13.520]  А потом мы будем писать такопоточный код
[48:13.520 --> 48:15.520]  или захотим два виджет менеджера или несколько
[48:15.520 --> 48:17.520]  прототип криейторов и такие
[48:17.520 --> 48:19.520]  все сломалось.
[48:19.520 --> 48:21.520]  Короче, нет.
[48:21.520 --> 48:23.520]  Не надо так, пожалуйста.
[48:23.520 --> 48:25.520]  Все, давай ехать дальше, потому что это все
[48:25.520 --> 48:27.520]  провокации и развод.
[48:27.520 --> 48:29.520]  Вот да, если тут концепт-трюк
[48:29.520 --> 48:31.520]  не работает, зато
[48:31.520 --> 48:33.520]  работает более простой трюк,
[48:33.520 --> 48:35.520]  что вы явно указываете, для кого вы хотите
[48:35.520 --> 48:37.520]  creation policy.
[48:37.520 --> 48:39.520]  Вот это хороший способ обойти вот эту
[48:39.520 --> 48:41.520]  проблему. Просто вытягивайте
[48:41.520 --> 48:43.520]  наружу информацию о том, что конкретно
[48:43.520 --> 48:45.520]  вы хотите.
[48:45.520 --> 48:47.520]  Это логично, но
[48:47.520 --> 48:49.520]  первая мысль, когда с таким сталкиваешься,
[48:49.520 --> 48:51.520]  по крайней мере, у меня была, я хочу квантро всеобщенности.
[48:51.520 --> 48:53.520]  Он не нужен.
[48:53.520 --> 48:55.520]  То есть вот здесь
[48:55.520 --> 48:57.520]  я хотел квантро всеобщенности, он не нужен.
[48:57.520 --> 48:59.520]  Просто сделайте еще один аргумент
[48:59.520 --> 49:01.520]  у концепта, как что конкретно
[49:01.520 --> 49:03.520]  вы создавать хотите. И в том контексте,
[49:03.520 --> 49:05.520]  в котором вы используете этот концепт, вы, наверное,
[49:05.520 --> 49:07.520]  знаете, что вы хотите создавать.
[49:07.520 --> 49:09.520]  Покажите.
[49:15.520 --> 49:17.520]  Короче, нет, все можем.
[49:17.520 --> 49:19.520]  Все всегда утверждается, что это всегда
[49:19.520 --> 49:21.520]  решение проблемы того, что вам захотелось
[49:21.520 --> 49:23.520]  написать квантро всеобщенности по типам.
[49:23.520 --> 49:25.520]  Не надо вытягивать эту информацию
[49:25.520 --> 49:27.520]  наружу, будет нормально.
[49:27.520 --> 49:29.520]  Окей.
[49:29.520 --> 49:31.520]  Вот еще так можно делать.
[49:31.520 --> 49:33.520]  В книжке это приводится, не знаю
[49:33.520 --> 49:35.520]  зачем. То есть мы делаем шаблонные
[49:35.520 --> 49:37.520]  не саму полисе,
[49:37.520 --> 49:39.520]  а функцию.
[49:39.520 --> 49:41.520]  Но тогда мы уже не можем стейт никакой, связанный
[49:41.520 --> 49:43.520]  с типом t хранить.
[49:43.520 --> 49:45.520]  Кажется, что не очень полезно,
[49:45.520 --> 49:47.520]  но так тоже можно.
[49:47.520 --> 49:49.520]  Все.
[49:49.520 --> 49:51.520]  Все-таки все. Трюк маленький.
[49:51.520 --> 49:53.520]  Можно вот такой код
[49:53.520 --> 49:55.520]  написать, правда?
[49:55.520 --> 49:57.520]  Что мы делаем? Мы создаем виджет
[49:57.520 --> 49:59.520]  менеджер, потом сохраняем где-то
[49:59.520 --> 50:01.520]  за три девять земель ссылку на него
[50:01.520 --> 50:03.520]  через полисе.
[50:03.520 --> 50:05.520]  Конкретно.
[50:05.520 --> 50:07.520]  Потом
[50:07.520 --> 50:09.520]  пытаемся удалить.
[50:11.520 --> 50:13.520]  Почему это
[50:13.520 --> 50:15.520]  УБ?
[50:15.520 --> 50:17.520]  Где
[50:17.520 --> 50:19.520]  Нью?
[50:19.520 --> 50:21.520]  Ну где-то был Нью, считай Нью был.
[50:21.520 --> 50:23.520]  То есть даже если
[50:23.520 --> 50:25.520]  Нью был, это все равно УБ, правда?
[50:25.520 --> 50:27.520]  То есть мы сделали Нью
[50:27.520 --> 50:29.520]  и my-widget-менеджер, а удалили
[50:29.520 --> 50:31.520]  по указателю на прототайп-креатор.
[50:31.520 --> 50:33.520]  Почему УБ?
[50:33.520 --> 50:35.520]  Да, тип другой,
[50:35.520 --> 50:37.520]  а что нужно сделать?
[50:39.520 --> 50:41.520]  Нет, если мы
[50:41.520 --> 50:43.520]  либо виртуальный
[50:43.520 --> 50:45.520]  деструктор, либо
[50:45.520 --> 50:47.520]  приватный. То есть вопрос, что
[50:47.520 --> 50:49.520]  мы хотим? Мы хотим, чтобы такой код
[50:49.520 --> 50:51.520]  корректно работал, и так можно было сделать.
[50:51.520 --> 50:53.520]  Тогда нужен виртуальный деструктор.
[50:53.520 --> 50:55.520]  Здесь мы не хотим, чтобы такой код работал.
[50:55.520 --> 50:57.520]  Нафиг нам это надо? Почему
[50:57.520 --> 50:59.520]  вообще кто-то запоминает
[50:59.520 --> 51:01.520]  этот
[51:01.520 --> 51:03.520]  widget-менеджер по указателю
[51:03.520 --> 51:05.520]  на его полисе? Вообще такого не должно
[51:05.520 --> 51:07.520]  быть.
[51:07.520 --> 51:09.520]  Наследование сделать приватным мы не можем,
[51:09.520 --> 51:11.520]  но такое тоже
[51:11.520 --> 51:13.520]  иногда прокатывает. Делать приватное
[51:13.520 --> 51:15.520]  наследование, чтобы даже вот эта строчка не скомпилировалась.
[51:15.520 --> 51:17.520]  То есть нельзя было
[51:17.520 --> 51:19.520]  присвоить по указателю. Но мы так
[51:19.520 --> 51:21.520]  не можем, потому что нам get-прототайп,
[51:21.520 --> 51:23.520]  set-прототайп нужны, чтобы они публично
[51:23.520 --> 51:25.520]  вылетели наружу.
[51:25.520 --> 51:27.520]  Окей, давайте
[51:27.520 --> 51:29.520]  просто сделаем деструктор приватным.
[51:29.520 --> 51:31.520]  Protect-от, точнее.
[51:31.520 --> 51:33.520]  Всё. Теперь вот это
[51:33.520 --> 51:35.520]  не компилируется, и мы предотвратили
[51:35.520 --> 51:37.520]  ошибку. Ну и не
[51:37.520 --> 51:39.520]  добавили никаких виртуальных вызовов дурацких,
[51:39.520 --> 51:41.520]  которые здесь не нужны. Вообще
[51:41.520 --> 51:43.520]  не нужны.
[51:43.520 --> 51:45.520]  Если у вас в главе есть правило
[51:45.520 --> 51:47.520]  «используешь наследование, делай виртуальный
[51:47.520 --> 51:49.520]  деструктор», поменяйте
[51:49.520 --> 51:51.520]  это правило, пожалуйста, на «используешь
[51:51.520 --> 51:53.520]  наследование, делай либо
[51:53.520 --> 51:55.520]  приватный, либо виртуальный деструктор».
[51:55.520 --> 51:57.520]  Такое очень общее правило,
[51:57.520 --> 51:59.520]  мне кажется, оно покрывает
[51:59.520 --> 52:01.520]  все кейсы.
[52:01.520 --> 52:03.520]  Мне кажется, ничего сложного,
[52:03.520 --> 52:05.520]  правда?
[52:05.520 --> 52:07.520]  Что я тут хотел сказать?
[52:09.520 --> 52:11.520]  Ну да, можно какие-то
[52:11.520 --> 52:13.520]  конкретные методы же ещё делать.
[52:13.520 --> 52:15.520]  То есть, вот я говорил, там артагональность
[52:15.520 --> 52:17.520]  не зависит от деталей имплементации.
[52:17.520 --> 52:19.520]  Можно. Можно в виджет-менеджере
[52:19.520 --> 52:21.520]  сделать конкретный кейс для
[52:21.520 --> 52:23.520]  конкретной
[52:23.520 --> 52:25.520]  полиси.
[52:25.520 --> 52:27.520]  Почему можно?
[52:27.520 --> 52:29.520]  Потому что шавлоны лениво инстанцируются.
[52:29.520 --> 52:31.520]  Если вы не используете этот метод,
[52:31.520 --> 52:33.520]  то он вам компиляцию не сломает.
[52:33.520 --> 52:35.520]  То есть, ну вот такое
[52:35.520 --> 52:37.520]  как бы окей. Опциональная
[52:37.520 --> 52:39.520]  такая штука. Если полиси позволяет
[52:39.520 --> 52:41.520]  менять прототип, то эта функция тоже
[52:41.520 --> 52:43.520]  можете использовать, всё будет работать.
[52:45.520 --> 52:47.520]  Здесь должен быть план «покодить».
[52:47.520 --> 52:49.520]  Кодение на следующий раз переносится,
[52:49.520 --> 52:51.520]  конечно. А примеры,
[52:51.520 --> 52:53.520]  где это используется?
[52:53.520 --> 52:55.520]  Полиси-бейст дизайн.
[52:55.520 --> 52:57.520]  Вот кто-нибудь вот это вот на
[52:57.520 --> 52:59.520]  олимпиадках использовал?
[52:59.520 --> 53:01.520]  Это ГЦЦ-шная
[53:01.520 --> 53:03.520]  библиотека,
[53:03.520 --> 53:05.520]  стандартная библиотека плюсов от ГЦЦ,
[53:05.520 --> 53:07.520]  от ГНУ, да? У неё есть вот такая
[53:07.520 --> 53:09.520]  вот include-ext-pbds.
[53:09.520 --> 53:11.520]  Полиси-бейст data structures.
[53:11.520 --> 53:13.520]  Вот если вас
[53:13.520 --> 53:15.520]  интересовало, что значит полиси-бейст,
[53:15.520 --> 53:17.520]  вот ровно это.
[53:17.520 --> 53:19.520]  Это есть, а ещё там
[53:19.520 --> 53:21.520]  Rb-дерево. Красно-чёрное
[53:21.520 --> 53:23.520]  дерево, которое там можно как-то кастомизировать,
[53:23.520 --> 53:25.520]  свои собственные ноды туда вставлять,
[53:25.520 --> 53:27.520]  новые какие-то эти
[53:27.520 --> 53:29.520]  ребра добавлять дополнительные.
[53:29.520 --> 53:31.520]  Вот кто умело этим пользовался, мог
[53:31.520 --> 53:33.520]  там рвать олимпиадки при помощи
[53:33.520 --> 53:35.520]  уже имеющегося красно-чёрного
[53:35.520 --> 53:37.520]  дерева, в которое встроил ещё пару каких-нибудь
[53:37.520 --> 53:39.520]  хитрых обратных ребер, и там всё заработало
[53:39.520 --> 53:41.520]  и взлетело. Но я так не умел,
[53:41.520 --> 53:43.520]  к сожалению.
[53:43.520 --> 53:45.520]  Преоритет Q там тоже вроде есть.
[53:45.520 --> 53:47.520]  Да там много чего есть.
[53:47.520 --> 53:49.520]  Вот, аллокаторы в стандартной библиотеке,
[53:49.520 --> 53:51.520]  это вы не поверите. Это тоже политики.
[53:51.520 --> 53:53.520]  У всех контейнеров.
[53:53.520 --> 53:55.520]  Потому что мы наследуемся от аллокатора, как правило,
[53:55.520 --> 53:57.520]  чтобы
[53:57.520 --> 53:59.520]  empty-based optimizations
[53:59.520 --> 54:01.520]  работал.
[54:05.520 --> 54:07.520]  Ну,
[54:07.520 --> 54:09.520]  не совсем. Мы принимаем не шаблон
[54:09.520 --> 54:11.520]  аллокатора, а конкретный аллокатор, поэтому это
[54:11.520 --> 54:13.520]  не совсем тот паттерн, который в книжке
[54:13.520 --> 54:15.520]  описывается. Но
[54:15.520 --> 54:17.520]  тем не менее. Вот здесь прямо честно,
[54:17.520 --> 54:19.520]  ровно то, что в книжке описано, ровно то они и сделали.
[54:19.520 --> 54:21.520]  Вот есть библиотеки,
[54:21.520 --> 54:23.520]  две штуки. Там я это тоже
[54:23.520 --> 54:25.520]  нашёл. Но я уже забыл, что это за библиотеки,
[54:25.520 --> 54:27.520]  что они делают. Ладно, вру не забыл,
[54:27.520 --> 54:29.520]  но сами почитайте, если хотите.
[54:29.520 --> 54:31.520]  Последние
[54:31.520 --> 54:33.520]  мы уже совсем задерживаемся, да.
[54:33.520 --> 54:35.520]  Последние три слайда буквально.
[54:37.520 --> 54:39.520]  Такой кейс смешной. Я сейчас буду просто
[54:39.520 --> 54:41.520]  как из Пушкили. Есть полигон,
[54:41.520 --> 54:43.520]  есть точки. Мы в полигоне храним
[54:43.520 --> 54:45.520]  вектор точек. Мы захотели
[54:45.520 --> 54:47.520]  как-то расширять эту дурацкую программу,
[54:47.520 --> 54:49.520]  какие-то вот там хитрости делать.
[54:49.520 --> 54:51.520]  Например, точки помечать лейблами
[54:51.520 --> 54:53.520]  какими-то. Или делать точки там
[54:53.520 --> 54:55.520]  в пятимерном пространстве.
[54:55.520 --> 54:57.520]  Конечно, мы вот так не расширим ничего,
[54:57.520 --> 54:59.520]  надо сделать шаблон.
[54:59.520 --> 55:01.520]  Конечно надо.
[55:01.520 --> 55:03.520]  Полигон в пятимерном пространстве.
[55:03.520 --> 55:05.520]  Ну окей, приметризовали
[55:05.520 --> 55:07.520]  шаблоном, и
[55:07.520 --> 55:09.520]  теперь можно подменять на какую-то точку,
[55:09.520 --> 55:11.520]  и вот если мы там захотим лейбла добавить,
[55:11.520 --> 55:13.520]  то мы наследуемся точки
[55:13.520 --> 55:15.520]  и добавим там
[55:15.520 --> 55:17.520]  стринг лейбл. Звучит
[55:17.520 --> 55:19.520]  отлично.
[55:19.520 --> 55:21.520]  Можно по-другому?
[55:21.520 --> 55:23.520]  Можно, пожалуйста, еще назад.
[55:23.520 --> 55:25.520]  Еще назад. Шаблонный
[55:25.520 --> 55:27.520]  полигон, точка.
[55:27.520 --> 55:29.520]  Пешек.
[55:29.520 --> 55:31.520]  Почему мы не можем
[55:31.520 --> 55:33.520]  н-коррелинат хранить?
[55:33.520 --> 55:35.520]  У нас же точки, которые должны это заново создавать,
[55:35.520 --> 55:37.520]  если у нас трехмерная, четырехмерная,
[55:37.520 --> 55:39.520]  что они, ну просто
[55:39.520 --> 55:41.520]  какой-то полигон, ну коллекция
[55:41.520 --> 55:43.520]  точек, я не знаю, ну вот
[55:43.520 --> 55:45.520]  точки хранимые.
[55:45.520 --> 55:49.520]  Да,
[55:49.520 --> 55:51.520]  то есть это могут быть там не просто точки,
[55:51.520 --> 55:53.520]  а какие-то точки в гильбертовом пространстве
[55:53.520 --> 55:55.520]  хранимые как-то ла-ла-ла-ла.
[55:55.520 --> 55:57.520]  Ну просто обобщили, вот тупейшее
[55:57.520 --> 55:59.520]  обобщение. С чем собрались использовать?
[55:59.520 --> 56:01.520]  Вот, например, с таким.
[56:01.520 --> 56:03.520]  Вот лейбл point, оно там расширяет point
[56:03.520 --> 56:05.520]  и добавляет
[56:05.520 --> 56:07.520]  но чтобы соблюдить интерфейс, который
[56:07.520 --> 56:09.520]  полигон использует, нам нужен конструктор
[56:09.520 --> 56:11.520]  двух аргументов. И вот тут все
[56:11.520 --> 56:13.520]  сломалось, потому что если мы хотим добавить
[56:13.520 --> 56:15.520]  несколько разных лейблов, или еще
[56:15.520 --> 56:17.520]  что-нибудь такое хитрое, и много
[56:17.520 --> 56:19.520]  разного функционала нового к точке прикрепить,
[56:19.520 --> 56:21.520]  да, что это там, например, точка
[56:21.520 --> 56:23.520]  на карте, у которой
[56:23.520 --> 56:25.520]  там есть иконка специальная, есть
[56:25.520 --> 56:27.520]  пометка, есть подсказка, есть там
[56:27.520 --> 56:29.520]  привязка к какому-то квисту, потому что
[56:29.520 --> 56:31.520]  это на самом деле не просто полигон, а там
[56:31.520 --> 56:33.520]  путь, который вам нужно по квисту пройти,
[56:33.520 --> 56:35.520]  идя в Скайриме, куда-то в горы.
[56:35.520 --> 56:37.520]  Ну,
[56:37.520 --> 56:39.520]  искусственный немножко пример, но
[56:39.520 --> 56:41.520]  предлагаемое решение вот такое.
[56:41.520 --> 56:43.520]  Отнаследовать точку
[56:43.520 --> 56:45.520]  от параметра пака.
[56:45.520 --> 56:47.520]  Чем-то напоминает политики.
[56:47.520 --> 56:49.520]  Называется
[56:49.520 --> 56:51.520]  теперь миксыны.
[56:51.520 --> 56:53.520]  Ну, почему-то вот так.
[56:53.520 --> 56:55.520]  То есть, миксыны — это главное
[56:55.520 --> 56:57.520]  про то, что тут целый пак, и вы можете их сколько
[56:57.520 --> 56:59.520]  угодно вписывать. С
[56:59.520 --> 57:01.520]  политиками это тоже можно скрестить, да?
[57:01.520 --> 57:03.520]  То есть, миксыны — это именно про то,
[57:03.520 --> 57:05.520]  что у вас пак чего-то, чего вы наследуетесь.
[57:05.520 --> 57:07.520]  Политика — это вот то, что говорили.
[57:07.520 --> 57:09.520]  И теперь мы можем
[57:09.520 --> 57:11.520]  подмешивать. Слово «миксын» — что значит
[57:11.520 --> 57:13.520]  «подмешать». Можете подмешать лейбл
[57:13.520 --> 57:15.520]  прямо внутрь точки,
[57:15.520 --> 57:17.520]  пихнув его вот сюда.
[57:17.520 --> 57:19.520]  И как бы у каждой точки будет состояние лейбл.
[57:19.520 --> 57:21.520]  Да, вот у нас, собственно,
[57:21.520 --> 57:23.520]  point от лейбла.
[57:23.520 --> 57:25.520]  Да,
[57:25.520 --> 57:27.520]  подмешиваем поля, подмешиваем методы, причем
[57:27.520 --> 57:29.520]  сколько угодно.
[57:29.520 --> 57:31.520]  Че?
[57:33.520 --> 57:35.520]  Для дефолтных что?
[57:37.520 --> 57:39.520]  Ну, тут как бы да,
[57:39.520 --> 57:41.520]  как такие структуры данных
[57:41.520 --> 57:43.520]  с миксинами инициализировать,
[57:43.520 --> 57:45.520]  ну, через конструктор у вас ничего не выйдет.
[57:45.520 --> 57:47.520]  Че?
[57:47.520 --> 57:49.520]  Через какой-нибудь билдер что-нибудь можно изобрести,
[57:49.520 --> 57:51.520]  наверное, да. Да даже с конструктором,
[57:51.520 --> 57:53.520]  если постараться, можно изобрести, ну,
[57:53.520 --> 57:55.520]  просто принимать сюда пак миксинов и, типа,
[57:55.520 --> 57:57.520]  руками давайте, ребята, указывайте.
[57:57.520 --> 57:59.520]  Ну, может быть там неудобно.
[57:59.520 --> 58:01.520]  Ну, в общем вот,
[58:01.520 --> 58:03.520]  можно сделать их шаблонами, будут миксины политики
[58:03.520 --> 58:05.520]  и еще ЦРТП закастывать
[58:05.520 --> 58:07.520]  и вот вообще классно будет.
[58:09.520 --> 58:11.520]  А что стало лучше?
[58:11.520 --> 58:13.520]  Не знаю.
[58:13.520 --> 58:15.520]  Уже слишком поздно, чтобы было что-то лучше,
[58:15.520 --> 58:17.520]  но вот так можно.
[58:19.520 --> 58:21.520]  Есть смешной трюк через все это.
[58:23.520 --> 58:25.520]  Внимание!
[58:25.520 --> 58:27.520]  Функция использует миксины.
[58:27.520 --> 58:29.520]  Вот сейчас очень смешной трюк.
[58:29.520 --> 58:31.520]  Я думаю, эта забивка совсем последняя будет.
[58:31.520 --> 58:33.520]  Функция использует миксины.
[58:33.520 --> 58:35.520]  Бейс.
[58:35.520 --> 58:37.520]  Вот она тут фу какое-то делает, да.
[58:37.520 --> 58:39.520]  Потом кто-то наследует этот дирайвт
[58:39.520 --> 58:41.520]  тоже там с миксинами
[58:41.520 --> 58:43.520]  и тоже делает фу.
[58:43.520 --> 58:45.520]  Шедуинг происходит, да.
[58:45.520 --> 58:47.520]  Теперь внимание.
[58:47.520 --> 58:49.520]  Вот эти вот шаблоны
[58:49.520 --> 58:51.520]  видите? Один из них
[58:51.520 --> 58:53.520]  ничего не имеет, а другой говорит, что
[58:53.520 --> 58:55.520]  а фу-то вообще-то виртуальная функция.
[58:55.520 --> 58:57.520]  И теперь мы
[58:57.520 --> 58:59.520]  вот этот дирайвт-шаблон
[58:59.520 --> 59:01.520]  можем инстанцировать от node-virtual, а можем от virtual.
[59:01.520 --> 59:03.520]  И вот в этом классе A
[59:03.520 --> 59:05.520]  фу это не виртуальный вызов,
[59:05.520 --> 59:07.520]  а в классе B он виртуальный.
[59:07.520 --> 59:09.520]  Поздравляю, мы научились
[59:09.520 --> 59:11.520]  с помощью шаблонных аргументов включать
[59:11.520 --> 59:13.520]  или выключать виртуальность верархии.
[59:13.520 --> 59:15.520]  Так можно.
[59:17.520 --> 59:19.520]  В одном есть виртуальная функция?
[59:19.520 --> 59:21.520]  Да, вот это вот
[59:21.520 --> 59:23.520]  дирайвт наследует бейс.
[59:23.520 --> 59:25.520]  Ещё тут всё миксинами обмазано.
[59:25.520 --> 59:27.520]  И у дирайвта и бейса есть фу
[59:27.520 --> 59:29.520]  функция.
[59:29.520 --> 59:31.520]  Вот они печатают, там разное.
[59:31.520 --> 59:33.520]  Бейс и дирайвт.
[59:33.520 --> 59:35.520]  Ну, они не виртуальные.
[59:35.520 --> 59:37.520]  Тут не написано, что они виртуальные.
[59:37.520 --> 59:39.520]  Но мы можем подмешать миксин,
[59:39.520 --> 59:41.520]  который
[59:41.520 --> 59:43.520]  прилетит через вот-вот
[59:43.520 --> 59:45.520]  через дирайвт прилетит, к бейзу прилетит
[59:45.520 --> 59:47.520]  и бейс от него наследуется.
[59:47.520 --> 59:49.520]  И в этом миксине написано, что
[59:49.520 --> 59:51.520]  фута вообще-то была виртуальной всё это время.
[59:51.520 --> 59:53.520]  И тогда и это станет виртуальной.
[59:53.520 --> 59:55.520]  И это станет виртуальной.
[59:55.520 --> 59:57.520]  И всё, у вас виртуальная иерархия.
[59:57.520 --> 59:59.520]  Что?
[59:59.520 --> 01:00:01.520]  Не знаю.
[01:00:05.520 --> 01:00:07.520]  Зачем здесь бейс? Почему нельзя?
[01:00:07.520 --> 01:00:09.520]  Ну, чтобы продемонстрировать,
[01:00:09.520 --> 01:00:11.520]  что если мы прикастим к бейзу,
[01:00:11.520 --> 01:00:13.520]  вот А или там Б, то и вызовем
[01:00:13.520 --> 01:00:15.520]  футу будут разные результаты.
[01:00:15.520 --> 01:00:17.520]  Ну да.
[01:00:17.520 --> 01:00:19.520]  Да.
[01:00:23.520 --> 01:00:25.520]  Да.
[01:00:25.520 --> 01:00:27.520]  Когда ты кастуешь
[01:00:27.520 --> 01:00:29.520]  вот такие вещи,
[01:00:29.520 --> 01:00:31.520]  ты уже должен быть джедаем.
[01:00:31.520 --> 01:00:33.520]  Ты не можешь ошибиться.
[01:00:33.520 --> 01:00:35.520]  Должен контролировать каждую букву в своем коде.
[01:00:35.520 --> 01:00:37.520]  Ну, в общем, тут компилятор тебе не помощник,
[01:00:37.520 --> 01:00:39.520]  если вот таким занимаешься.
[01:00:39.520 --> 01:00:41.520]  И вот библиотека, про которую я говорил.
[01:00:41.520 --> 01:00:43.520]  Там это есть.
[01:00:43.520 --> 01:00:45.520]  Там реально используют миксины и реально отключают или включают виртуальность.
[01:00:45.520 --> 01:00:47.520]  Если интересно, почитайте.
[01:00:47.520 --> 01:00:49.520]  А у меня на этом всё.
[01:00:49.520 --> 01:00:51.520]  Все свободны.
