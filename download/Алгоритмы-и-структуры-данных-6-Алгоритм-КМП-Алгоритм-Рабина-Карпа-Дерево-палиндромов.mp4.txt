[00:00.000 --> 00:08.360]  Ну, сформулируем так, так как сейчас будут достаточно
[00:08.360 --> 00:11.120]  простые вещи, то мы ускорим процесс с помощью презентации.
[00:11.120 --> 00:15.760]  Ну, пока сейчас точно просто, значит, во-первых, так мы
[00:15.760 --> 00:17.560]  живем в строках, поэтому у нас появляется понятие
[00:17.560 --> 00:18.560]  алфавит.
[00:18.560 --> 00:19.560]  Что такое алфавит?
[00:19.560 --> 00:22.520]  Ну, это просто набор таких, то есть чего-то, что мы будем
[00:22.520 --> 00:24.360]  воспринимать за буквы или символы.
[00:24.360 --> 00:28.120]  Ну вот, мы будем жить с конечными алфавитами.
[00:28.600 --> 00:31.280]  То есть алфавит, какие у нас бывают, от а до z, от 0 до
[00:31.280 --> 00:34.040]  9, бывает 0 и 1, ну и в общем как угодно.
[00:34.040 --> 00:36.760]  То есть обычно в каждой задаче оговаривается, здесь
[00:36.760 --> 00:38.520]  перечислены самые типичные.
[00:38.520 --> 00:40.000]  Вот, значит, строки.
[00:40.000 --> 00:41.480]  Что такое строка?
[00:41.480 --> 00:44.800]  Это конечная последовательность символов, не более того.
[00:44.800 --> 00:48.640]  Значит, единственная маленькая оговорочка заключается
[00:48.640 --> 00:52.640]  в том, что иногда строки, символы в строке будем
[00:52.640 --> 00:54.720]  набирать в один индексации, иногда в ноль.
[00:55.600 --> 01:01.560]  То есть иногда оказывается, что в z функции удобно все
[01:01.560 --> 01:04.240]  делать в ноль индексации, а в префикс функции в один
[01:04.240 --> 01:05.240]  индексации.
[01:05.240 --> 01:08.240]  Вот, начнем мы сегодня с один индексации.
[01:08.240 --> 01:10.240]  Конечно, не одинобразно делать?
[01:10.240 --> 01:11.240]  Ну, в плане…
[01:11.240 --> 01:12.240]  Ну, нет, просто…
[01:12.240 --> 01:15.240]  Если не одинобразно, то меньше бабов.
[01:15.240 --> 01:17.320]  Нет, ну это, конечно, да, но с другой стороны, с точки
[01:17.320 --> 01:19.840]  зрения теории иногда вот как-то префикс функции,
[01:19.840 --> 01:22.000]  она на самом деле просто такую значительную часть
[01:22.000 --> 01:23.920]  своей красоты теряет, если вы начинаете работать
[01:23.920 --> 01:24.920]  в ноль индексации.
[01:24.920 --> 01:25.920]  Вот.
[01:25.920 --> 01:28.480]  Так что тут момент такой.
[01:28.480 --> 01:31.920]  Да, значит, еще у нас будет понятие подстрока, и тут
[01:31.920 --> 01:33.400]  у нас действительно важный момент.
[01:33.400 --> 01:36.160]  Да, то есть мы будем писать вот какую-то такую штуку,
[01:36.160 --> 01:38.640]  то есть s от и g, это будет означать, что у нас в эту
[01:38.640 --> 01:42.000]  строку входят все символы от it включительного до
[01:42.000 --> 01:43.000]  z включительного.
[01:43.000 --> 01:48.000]  Ну, сразу еще давайте оговоримся, что может быть, конечно,
[01:48.000 --> 01:50.760]  не гарантируем, что мы иногда будем употреблять там
[01:50.760 --> 01:55.880]  всякие вещи типа, значит, вот такие, то есть типа
[01:55.880 --> 01:58.640]  полуинтервал от и включительно, даже не включительно, но
[01:58.640 --> 02:01.320]  там может быть вот так вот, где-нибудь, когда-нибудь
[02:01.320 --> 02:04.480]  встретятся вот, то есть вот, то есть такие вот обозначения
[02:04.480 --> 02:05.480]  строчек у нас будут.
[02:05.480 --> 02:08.320]  Ну и здесь пока, соответственно.
[02:08.320 --> 02:12.320]  Так, ну и, конечно, будем считать, что пустая строка является
[02:12.320 --> 02:14.400]  подстрокой любой строки.
[02:14.400 --> 02:15.400]  Вот.
[02:15.400 --> 02:16.400]  По соответствии.
[02:17.240 --> 02:18.240]  По соответствии.
[02:18.240 --> 02:21.960]  То есть это вот мы тоже так считать будем.
[02:21.960 --> 02:22.960]  Итак.
[02:22.960 --> 02:29.960]  Ну какие еще тут, какие у нас тут еще классические
[02:29.960 --> 02:30.960]  определения есть?
[02:30.960 --> 02:32.840]  Классические определения еще говорят, что вот есть
[02:32.840 --> 02:36.880]  длина строки, значит, ну длина строки это модулес,
[02:36.880 --> 02:41.800]  значит, и есть, соответственно, также префикс длины l и суффикс
[02:41.800 --> 02:44.520]  длины not и суффикс длины l.
[02:44.920 --> 02:47.160]  Так, вот здесь обратите внимание, здесь произошел
[02:47.160 --> 02:48.160]  перенос.
[02:48.160 --> 02:50.680]  Суффикс длины l у нас это подстрока вот, видите,
[02:50.680 --> 02:51.680]  модулес минус l плюс один.
[02:51.680 --> 02:52.680]  Ну понятно, да?
[02:52.680 --> 02:53.680]  Чего?
[02:53.680 --> 02:54.680]  Смешной получилось с переносом.
[02:54.680 --> 02:55.680]  Ну вот.
[02:55.680 --> 02:56.680]  Да.
[02:56.680 --> 02:59.680]  То есть, на самом деле, не путайте.
[02:59.680 --> 03:04.080]  Еще мы сразу скажу, будем иногда употреблять такое
[03:04.080 --> 03:05.880]  словосочетание, как l-ты суффикс.
[03:05.880 --> 03:10.440]  Так вот, обычно под l-ты суффикс я подразумеваю суффикс, который
[03:10.440 --> 03:11.720]  начинается в l-тым символе.
[03:12.680 --> 03:15.280]  Но это я просто предупреждаю, что вот такое может быть,
[03:15.280 --> 03:16.280]  если что.
[03:16.280 --> 03:19.280]  В l-тым символе.
[03:19.280 --> 03:22.280]  Ну любой суффикс у вас это вся строка, да?
[03:22.280 --> 03:23.280]  Да.
[03:23.280 --> 03:24.280]  Ну если строка в ноль индексации, разумеется.
[03:26.280 --> 03:27.280]  Ладно.
[03:27.280 --> 03:28.280]  Вот так.
[03:28.280 --> 03:32.280]  Ну то есть, скорее всего, так, по контексту будет понятно,
[03:32.280 --> 03:34.280]  что имеется в виду, вот просто предупреждаю, что тут, возможно,
[03:34.280 --> 03:35.280]  разные терминологи.
[03:35.280 --> 03:36.280]  Да.
[03:36.280 --> 03:37.280]  Не очевидно, как бы.
[03:37.280 --> 03:38.280]  Да.
[03:38.280 --> 03:39.280]  Ну поэтому я вот и проговариваю, что это возможно.
[03:39.280 --> 03:40.280]  И?
[03:40.280 --> 03:41.280]  Ну интуитивно.
[03:41.840 --> 03:42.840]  Не знаю.
[03:42.840 --> 03:43.840]  Вот.
[03:43.840 --> 03:44.840]  Вот интуитивность тут проблема.
[03:44.840 --> 03:45.840]  Мне это как раз интуитивно, поэтому, соответственно.
[03:45.840 --> 03:50.280]  Ну просто интуитивно делать все единообразно и с суффиксами
[03:50.280 --> 03:52.880]  работать справа-налево, как бы, и тогда нулевой суффикс.
[03:52.880 --> 03:56.200]  А вот мы будем работать с суффиксами немножко слева-направо.
[03:56.200 --> 03:59.320]  Вот уже, Сергей, уже сейчас префикс функции мы с этим
[03:59.320 --> 04:00.320]  даже познакомимся.
[04:00.320 --> 04:03.320]  Ну в суффмассе не тоже слева-направо.
[04:03.320 --> 04:04.320]  Ну вообще, да.
[04:04.320 --> 04:07.160]  То есть там и там с суффиксом считается то, что начинается
[04:07.160 --> 04:08.160]  в l-тым символе.
[04:08.160 --> 04:11.160]  Ну там опять вопрос терминологии.
[04:11.240 --> 04:13.260]  Так это можно назвать не l-тым суффиксом.
[04:13.260 --> 04:14.260]  Но это логично.
[04:14.260 --> 04:15.660]  Но там, оказывается, удобнее.
[04:15.660 --> 04:22.520]  Ну
[04:22.520 --> 04:35.040]  slowed у 그것 дали в
[04:35.040 --> 04:42.000]  мы ищем подстроков таки двумя указателями на самом деле, да, собственно как
[04:42.000 --> 04:45.360]  говорится, да, возможно удивляет, но собственно покажу откуда это берется, но пока
[04:45.360 --> 04:50.320]  значит немножко терминологии, значит s у нас является, да, ну понятно сама строка
[04:50.320 --> 04:54.240]  является как своим префиксом, только своим суфиксом, но все остальные префиксы
[04:54.240 --> 05:02.000]  суфиксы мы будем называть собственными, вот, ну конечно у нас классическая задача
[05:02.000 --> 05:07.480]  о поиске под строке, то есть дана строка p и s, скажите, пожалуйста, ну такая
[05:07.480 --> 05:11.560]  простая постановка могла быть, входит ли строка p в строку s как подстрока, да или
[05:11.560 --> 05:18.440]  нет, ну или там, или вот нас так же будет интересовать, а найдите, пожалуйста, где,
[05:18.440 --> 05:23.000]  вот прям по списку, знаете, как вот, когда алгебры говорят, решение, что такое
[05:23.000 --> 05:28.160]  решить уравнение, найти все его корни и доказать, что других нет, да, вот, вот здесь
[05:28.160 --> 05:33.240]  примерно то же самое, но у нас, ну фактически такая задача в некотором смысле у нас будет
[05:33.240 --> 05:39.120]  просто красной нитью проходить по всему нашему блоку строковых алгоритмов, то есть как бы
[05:39.120 --> 05:46.640]  уровень easy это ищем одну подстроку в одной строке, уровень medium, так сказать, значит ищем много
[05:46.640 --> 05:53.080]  подстрок, но в одной строке они все заданы заранее и, конечно, уровень hard мы ищем подстроки в строке в онлайне.
[05:53.080 --> 06:02.160]  А это не принципиально, потому что искать много подстрок в многих строках, это то же самое,
[06:02.160 --> 06:06.960]  как искать много подстрок в одной строке сконкатинированной из кучи, так что это и
[06:06.960 --> 06:15.400]  не hard, это когда строка, в которой вы ищете, тоже задается в онлайне, но там смотря в
[06:15.400 --> 06:19.560]  каком смысле, то есть если у вас там приходят даже запросы вида поменяйте символ строки,
[06:19.560 --> 06:27.680]  то это, конечно, расстрел, это да, кстати, уже задача, дан текст, и приходят два запроса,
[06:27.680 --> 06:32.080]  первая, дана строка penid, входит ли она в текст как подстрока, и второй запрос,
[06:32.080 --> 06:35.680]  а поменяй, пожалуйста, и ты символ на вот это. Время пошло.
[06:35.680 --> 06:44.600]  Ещё лучше это операция с такой, как с дикарточком. Да, тут хоть один символ поменял.
[06:44.600 --> 06:53.640]  При свой на отрезке, там начинается мясо. Ну, конечно. Итак, мы пока начнём с простого
[06:53.640 --> 06:59.120]  уровня, просто дана одна строка, дана один шаблон и дан один текст.
[06:59.120 --> 07:14.160]  А мы будем искать в домашнем задании идеи? Чего искать? Идеи. Какие идеи? Как решать? Как решать D2 2019.
[07:14.160 --> 07:29.440]  Что такое D2 2019? Поиск идеи. Так, ну понятно. Видимо, я с Лётой не помню задачу. Ну понятно,
[07:29.440 --> 07:37.240]  возможно, я не помню или даже не знаю задачу. Ну, разберёмся отдельно, может быть и будем,
[07:37.240 --> 07:42.680]  не гарантирую, потому что я пока не видел задачу. Может быть, в будущем мы столкнёмся с ней,
[07:42.680 --> 07:51.960]  почему бы нет. Скорее всего, я должен был что-то подобное видеть, но дойдём. Момент понял. Хорошо,
[07:51.960 --> 07:59.920]  значит D2 2019 вас интересует. Хорошо. А что, там-то прям что-то страшное? Ну, там типа строка можно,
[07:59.920 --> 08:08.440]  ну короче, там персидентное 2-3 дерева. А, ой-ой-ой, а это точно? Знаете, это Миша как блокирующую задачу и
[08:08.440 --> 08:14.520]  остальные поймают. Нет, погодите, погодите, нет. А, это так, это ЗДД. А, я что-то не вспоминал,
[08:14.520 --> 08:21.760]  как задачу на строке. Ну, формулировки там строки. Ну да, но в итоге мы приходим к персидентному 2-3,
[08:21.760 --> 08:27.480]  сначала декорточок, потом 2-3 дерева, как оптимизация, как у пихон по памяти. А это я примерно
[08:27.480 --> 08:36.080]  помню, это веселье. Окей, ладно, идём дальше. Вот, значит, смотрим, что это значит, как решать такую
[08:36.080 --> 08:45.960]  задачу. Ну, самое тупое, самое тупое, конечно, это давайте переберём действительно у нас все строки,
[08:45.960 --> 08:52.920]  то есть переберём все подстроки и каждую ту по сравним. Кстати, в общем случае, это может
[08:52.920 --> 08:58.520]  оказаться не самое плохое решение. То есть да, сим-точка, конечно, п на с, и действительно перебирать
[08:58.520 --> 09:05.680]  придётся, ну и там можно придумать пример, когда мы реально будем сток перебирать. Но в некотором
[09:05.680 --> 09:11.240]  условно-рандомном случае, на самом деле, скорее всего, если это не подстрока, то отсекаться будем
[09:11.240 --> 09:20.960]  быстро. Вот, то есть это как бы вещь такая. Вот, но, значит, но оказывается, у нас есть более быстрое
[09:20.960 --> 09:31.800]  решение, в которое мы вводим префикс функции. Вот, так, ну возникает вопрос, что такое префикс
[09:31.800 --> 09:37.760]  функция? Ну, здесь вот, да, здесь написан какой-то текст, давайте нарисуем картинку и поймём,
[09:37.760 --> 09:44.200]  что он вообще значит. Ну, значит, он примерно следующее. Жила была строка P, вот нам жутко
[09:44.200 --> 09:55.120]  интересно. Вот, и нам в каждой позиции И очень интересно найти максимальной длины префикс,
[09:55.120 --> 10:04.000]  длины меньше, чем И, который совпадает с подстрокой заканчивающейся в этом символе. Вот, то есть,
[10:04.000 --> 10:10.200]  в общем-то, вот там написано ровно это, то есть остаётся только добавить, что тут вот L и L.
[10:10.200 --> 10:25.000]  Нет, то строго в И он должен заканчиваться. Да, да, как я говорю, да, вот именно поэтому,
[10:25.000 --> 10:32.040]  то есть указывает, что L должно быть строго меньше, чем И. Наоборот, как раз, собственный. То есть,
[10:32.040 --> 10:38.400]  скажем так, собственный, то есть как бы L это должен быть собственный суффикс префикса длины И,
[10:38.400 --> 10:45.680]  вот так. Вот я избегаю такого словосочетания, потому что это немножко расстреляно звучит,
[10:45.680 --> 10:51.440]  но тем не менее. Не, он и собственный префикс, и собственный суффикс. Да, на самом деле, да. Вот,
[10:51.440 --> 10:58.680]  ну а теперь возникает вопрос просто, откуда эта штука взялась? Ну, на самом деле, давайте попробуем,
[10:58.680 --> 11:02.560]  вот прежде чем двигаться дальше, то есть на самом деле сейчас я могу, можно просто попробовать
[11:02.560 --> 11:09.040]  сказать, откуда это вообще берется. А берется вот откуда. Смотрите, то есть, на самом деле,
[11:09.040 --> 11:16.400]  предположим, что у нас есть мистический черный ящик. Вот есть мистический черный ящик,
[11:16.400 --> 11:23.320]  который умеет брать какие-нибудь две подстроки и сообщать, равны ли они, да или нет. В принципе,
[11:23.320 --> 11:29.240]  возможно, вы даже в некотором смысле писали такой черный ящик в виде полимеральных хэшей. Но мы
[11:29.240 --> 11:33.440]  сейчас не будем, конкретно сейчас мы не будем прописывать, что это вообще такое, как-то пишется.
[11:33.440 --> 11:40.760]  Ну а теперь возникает вопрос, как искать подстрок в строке с помощью такого черного ящика?
[11:40.760 --> 11:46.760]  Надо было, наверное, здесь сказать, что между РС и П плюс С есть решение бинпоиск с хэшами.
[11:46.760 --> 11:54.160]  Нет, бинпоиск даже не нужен. Нет, бинпоиск даже не нужен, потому что в данном случае,
[11:54.160 --> 11:59.080]  если вы ищете подстроку с помощью хэшей, то вы просто перебираете все подстроки длинной
[11:59.080 --> 12:08.640]  П и проверяете. Так что, соответственно, да, это, наверное, это действительно может быть не так
[12:08.640 --> 12:16.360]  хорошо. Хотелось бы, наверное, чего-то еще. А теперь давайте попробуем, собственно,
[12:16.360 --> 12:23.520]  применить, попробовать искать этот метод двух указателей. Раньше говорили, что магия просто говорит
[12:23.520 --> 12:30.640]  о том, что мы умеем просто взять две рандомные подстроки. А теперь идея такая. Давайте вообразим
[12:30.640 --> 12:36.440]  себе, что мы идем в тупую. А именно, вот берем самое начало строки С и честно сравниваем,
[12:36.440 --> 12:42.840]  совпадает ли, совпадает ли, значит, там подстрока, начинающаяся с первого символа строки С,
[12:42.840 --> 12:50.320]  с соответствующим префиксом строки П. Вот она идет, совпадает, совпадает, и опа! И вот очередной
[12:50.320 --> 13:05.760]  символ не совпал. Видно, да? Вот. Ну, теперь мы начинаем думать. Вот такая подстрока совпадает,
[13:05.760 --> 13:12.800]  но дальше мы как бы этот правый указатель сдвинуть не можем. А теперь идея такая. Давайте сдвинем
[13:12.800 --> 13:18.840]  левый указатель, давайте нот. То есть для первой строки такой, для строки начинается со следующего
[13:18.840 --> 13:27.640]  символа вот. Сейчас, это вы зафиксировали префикс? Чего я зафиксировал? На плане книги у вас
[13:27.640 --> 13:38.160]  фиксированная, да? Нет. Нет, я вообще уже сейчас другое... Нет, забыли давайте об этом. Нет,
[13:38.160 --> 13:43.840]  я делаю вообще другое. То есть у меня как бы идея теперь такая. То есть я вот с какой стороны
[13:43.840 --> 13:53.320]  начинаю на это смотреть. Я начинаю на это смотреть следующим образом. То есть я попытался рассматривать
[13:53.320 --> 13:57.480]  же не позицию... То есть я сейчас не ищу префикс функцию, я ищу подстроку в строке. То есть я не
[13:57.480 --> 14:03.080]  знаю никакой префикс функции, я пытаюсь ее придумать. Ну, может даже не ее. И поэтому я начинаю вот тут
[14:03.080 --> 14:10.280]  просто тупо сказать, случайно эта строка П вот здесь прямо не входит в строку С случайно. Вот.
[14:10.280 --> 14:15.560]  Ну вот, допустим, я тут шел-шел-шел и выяснилось, что у меня вот какой-то префикс совпадает,
[14:15.560 --> 14:23.200]  но вот, но не более. Тогда какая у меня идея возникает? Тогда давайте посмотрим с первым,
[14:23.200 --> 14:28.760]  то есть вот со следующим символом. То есть это был первый, начиная с первого и со второго. Вот.
[14:28.760 --> 14:35.680]  Ну что здесь можно сказать? То есть теперь идея такая. То есть давайте тоже используем ту же магию,
[14:35.680 --> 14:41.480]  вот этот черный ящик, но мы его будем использовать чисто внутри строки П. Вот предположим,
[14:41.480 --> 14:48.160]  что нас теперь черный ящик не может нас отсылать к подстроке С, но он может нас отсылать к двум
[14:48.160 --> 14:54.440]  подстрокам строки П. Такой черный ящик. Тогда мы просто, мы хотим проверить, а верно ли,
[14:54.440 --> 15:01.440]  что вот эта строка совпадает с префиксом строки П? Ну, заметь, ну вот. Ну, заметим, что это то же
[15:01.440 --> 15:05.800]  самое, что проверить, верно ли, что вот эта подстрока совпадает с вот этой подстрокой, правда?
[15:05.800 --> 15:13.320]  Вот. То есть заметим, что если она, ну если она не совпадает, то с этого символа на самом деле
[15:13.320 --> 15:20.800]  ходить бессмысленно, потому что значит до конца П мы отсюда точно не дойдем, правда? Вот. А если
[15:20.800 --> 15:25.200]  совпадает, то наоборот, мы уже здесь проскочили, получается правый указатель, можно двигать дальше.
[15:25.200 --> 15:31.960]  То есть, по сути, тогда идея приобретает следующий вид. То есть, мы двигаем левый указатель до тех пор,
[15:31.960 --> 15:38.120]  пока вот эта подстрока, соответственно, не совпадет с префиксом строки П. Как только она совпадет,
[15:38.120 --> 15:46.560]  значит правый указатель двигаем до тех пор, пока не упремся. Да, ну или, кстати, упираться она
[15:46.560 --> 15:51.840]  может еще потому, что строка П закончится, это означает, что мы вхождение нашли. Это не значит,
[15:51.840 --> 15:58.200]  что мы остановимся просто значит двигаем левый указатель и ищем следующее вхождение вот то есть
[15:58.200 --> 16:04.000]  оказывается есть у нас есть черный ящик с хэшами только для строки п то вот таким вот простым методом
[16:04.000 --> 16:13.740]  двух указателей на самом деле мы можем решить задачу понимаете да осталось только выяснить как
[16:13.740 --> 16:20.400]  избавиться от черного ящика а черного ящика избавиться оказывается очень просто потому что
[16:20.400 --> 16:27.200]  вот мы в данном случае получается с этим взять минимально вот у этой строки максимальной длины
[16:27.200 --> 16:35.760]  собственный суффикс который совпадает с префиксом правда вот ну вот собственно мы и пришли к
[16:35.760 --> 16:49.240]  определению префикс функции удобно правда да нет наверное вот то есть вот получается что и действительно
[16:49.240 --> 16:55.720]  то есть отсюда тогда и получается что если вы насчитали префикс функцию для строки п то в принципе
[16:55.720 --> 17:02.120]  тогда с помощью префикс функции вы тогда явно уже вот например вот этими двумя указателями можете
[17:02.120 --> 17:15.340]  найти под строку строки с остался только понять а как саму префикс функцию вообще найти вот как же
[17:15.340 --> 17:31.300]  ее найти но давайте смотреть так так ну тут написано какая-то параллель ну первая лепка
[17:31.300 --> 17:37.580]  штаб п от леденицы равно очевидно нулю ну там без вариантов в общем-то да а вот дальше написано
[17:37.580 --> 17:48.660]  что п от и плюс первой не превосходит п от и плюс один вот ну тут написан какой-то текст опять вот
[17:48.660 --> 17:53.580]  но его доказательства на самом деле но как всегда у нас сейчас будет это все в стиле там доказательстве
[17:53.580 --> 17:58.020]  написано какой-то формальный текст давайте нарисуем его на картинке и все будет и все станет видно
[17:58.020 --> 18:05.420]  и поймем почему даже обсуждать его не надо ну вот нет то почему-то обсудить то стоит вот ну
[18:05.420 --> 18:10.660]  значит давайте посмотрим потому что вот у меня есть и и плюс один действительно давайте рассмотрим
[18:10.660 --> 18:15.260]  префикс функцию для позиции плюс один то есть вот эта подстрока совпадает допустим с вот этой
[18:15.260 --> 18:21.260]  но тогда заметим что и вот эта подстрока на единичку меньше тоже совпадает с префиксом то
[18:21.260 --> 18:37.460]  следует на п от и это как минимум вот эта штука минус 1 нет у нас нет наоборот у нас есть строка
[18:37.460 --> 18:44.380]  для и плюс один и вы вытянули по последнему символу получилось строка для отсюда следует
[18:44.380 --> 18:50.380]  что п а ты больше либо равно чем при плюс один минус один более того даже сразу можно заявить
[18:50.380 --> 19:00.980]  что если на самом деле вот этот символ совпал с вот этим то есть там с там вот это вот то есть
[19:00.980 --> 19:07.620]  вот этой длины плюс первым символом то тогда это п и плюс один равно в точности п и плюс один
[19:07.620 --> 19:13.180]  прям в самом начале когда вы читаете префикс функцию можно прям то есть допустим мы будем
[19:13.180 --> 19:18.860]  вычислять префикс функцию как вы уже догадываетесь лево направо то и плюс первый символ то когда мы
[19:18.860 --> 19:24.460]  уже знаем присутствия и и всех раньше кто мы говорим что если x совпадает тут так сказать
[19:24.460 --> 19:30.780]  п от и плюс там п от и заканчиваем скобочку плюс первым символом строки то есть как бы это
[19:30.780 --> 19:38.900]  получается и плюс первый символ а этот символ получается значит п от и плюс 1 то есть если они
[19:38.900 --> 19:51.460]  совпали то значит мы п и плюс один тоже прекрасно вычислил вот остается только внимание вопрос а
[19:51.460 --> 20:07.940]  что делать если он не совпадает вот ну формально говоря возникает что дальше то есть если п и
[20:07.940 --> 20:13.820]  плюс первое не равно п и плюс один то следующее что надо проверить это п от п и плюс один
[20:13.820 --> 20:25.380]  почему так очень просто то есть на самом деле то есть вот эти вот леммы можно расписать следующим
[20:25.380 --> 20:29.500]  образом то есть даже без формального текста но я думаю так формальный текст можно не переписывать
[20:29.500 --> 20:35.100]  просто потому что презентацию я вам естественно вышли вот чего не веришь
[20:39.100 --> 20:44.500]  наверное может быть но это да такой телефончик может уберешься
[20:44.500 --> 20:55.220]  ну что нет именно уберешь они там это большой соблазн его опять заглянуть что там писать как
[20:55.220 --> 21:01.700]  и вот перерывы будут не волнуйся вот так смотреть то есть на самом деле все до дальнейшей леммы
[21:01.700 --> 21:06.260]  имеют следующий смысл то есть вот действительно давайте посмотрим вот мы у нас есть вот такой
[21:06.260 --> 21:12.260]  и ты символ там есть и плюс первое вот мы хотим найти префикс функцию то есть максимальной длины
[21:12.260 --> 21:21.100]  вот какую-то такую строчку которая совпадает с префиксом но что для этого но что это означает
[21:21.100 --> 21:27.540]  но то есть если отпилить по одному символу то есть вот тут получается такой x или да то
[21:27.540 --> 21:34.860]  получается подходящая строка для и то есть получается что должно быть что вот и должна
[21:34.860 --> 21:39.620]  быть строка на единичку меньше совпадать соответствующим префикс и тогда будет какая-то
[21:39.620 --> 21:48.400]  идея такая а давайте переберем все такие строки то есть как перебрать для и для и все такие под
[21:48.720 --> 21:53.960]  все такие суффиксы которые совпадают с префиксами в чем желательно давайте переберем в порядке
[21:53.960 --> 22:00.720]  убывания то есть сначала самый первый ну самый самый первый проверим там получается ли с ним
[22:00.720 --> 22:06.600]  если не получается то второй потом третий и так далее и так далее пока не сойдется да понимаете
[22:06.600 --> 22:18.760]  да что не так сейчас у нас есть вот это вот вот мы знаем что какая-то величина этой штуки есть
[22:18.760 --> 22:30.600]  мы знаем что последний символ не совпадает ну нету это значит что нам нужно попробовать взять
[22:30.600 --> 22:35.320]  какую-то чуть меньшую длину суффикса который совпадает с префиксом и попробовать приписать
[22:35.320 --> 22:54.320]  к нему этот символ здесь и здесь проверить совпадают ли они ну почему нет ну хорошо
[22:54.320 --> 22:59.760]  можно как бы формальное доказательство так провести но на самом деле суть от этого не
[22:59.760 --> 23:07.600]  поменяется ну давайте еще раз то есть задача надо найти какой-то такое как какую-то такую
[23:07.600 --> 23:14.000]  подстроку заканчивается в плюс первым символе которая совпадает с префиксом правда да максимально
[23:14.000 --> 23:19.040]  возможной длины всех таких но что она из себя представляет а да то есть если она там длины
[23:19.040 --> 23:26.720]  какой-то и она представляет из себя под строку длины l-1 заканчивающиеся в этом символе которая
[23:26.720 --> 23:37.240]  совпадает с префиксом да вот и причем после которой еще идет символ символ икс а теперь
[23:37.240 --> 23:43.040]  идея такая рассмотрим таких строчек ну про икс конечно я ничего не знаю но вот строчек но
[23:43.040 --> 23:47.920]  для и таких строчек которые совпадают с префиксом вот заканчивается в этом символе
[23:47.920 --> 23:53.440]  спадают префиксом их может быть несколько правда так вот давай идея такая а давайте переберем
[23:53.440 --> 23:59.280]  каким-то образом все такие строки в порядке убывания длины и для каждой из них проверим
[23:59.280 --> 24:07.200]  не идет ли у соответствующего префикса за ним символ икс если если нам какие-то небеса по
[24:07.200 --> 24:16.120]  факсу будут присылать эти длины в порядке убывания просто будут при ноте в порядке то тогда заметим
[24:16.120 --> 24:25.040]  что мы эту префикс функцию будем искать за линейное время почему а вот почему потому что то есть
[24:25.040 --> 24:31.720]  работать это будет примерно так потому что значит сам по штабу но опять чем с того что самая длинная
[24:31.720 --> 24:37.200]  такая подстрока но мы же ищем сам префикс функцию то есть самую длинную только по строчку да это
[24:37.200 --> 24:42.080]  что такое это есть префикс функция найденная ранее то есть раньше мы работали вот с этой подстрокой
[24:42.960 --> 24:52.160]  если нам вот эта штука не помогла то тогда мы ищем вторую совпадающую какие-то небеса нам присылают
[24:52.160 --> 25:04.800]  и она на самом деле уже вот такая то есть мы ну скажем так можно и так но как бы а можно через
[25:04.800 --> 25:09.920]  метод двух указатель сразу это увидеть потому что да можно понятно там в презентации будет
[25:10.200 --> 25:15.240]  конечно введен метод потенциалов и действительно введение через потенциалы но это нам не нужно на
[25:15.240 --> 25:22.480]  самом деле то есть по большому счету то есть то есть как бы если мы перебираем все подстройки
[25:22.480 --> 25:25.920]  вот заканчивается совпадающий префиксом то есть берем когда вторую то есть получается мы левые
[25:25.920 --> 25:34.280]  указатели сдвинули и смотрим можем ли сейчас сдвинуть правый вот эта идея да вот поэтому
[25:34.280 --> 25:38.360]  собственно префикс функции на самом деле такой метод двух указателей но осталось только выяснить
[25:38.360 --> 25:47.040]  откуда нам эти вот такие подстройки вот по порядочку брать ну классическая идея конечно давайте
[25:47.040 --> 25:51.640]  просто в тупую перебирать и проверять совпадает ли подстрока с префиксом но это мы делаем отсылку
[25:51.640 --> 25:58.920]  к черным ящику для строки п да но на самом деле в этом нет необходимости потому что в реальности
[25:58.920 --> 26:05.520]  вот мы думаем вот у вас есть подстрока просто даже какая-то длины длины допустим даже не
[26:05.520 --> 26:12.840]  эля там какой-нибудь там л штрих которая совпадает с префиксом как найти следующую такую длину
[26:12.840 --> 26:25.080]  л 2 штриха которая совпадает с префиксом как вы найти нет а это не там надо смотреть это от
[26:25.080 --> 26:33.160]  смотреть здесь посадите мы же уже знаем что вот это строка равна вот этой строке да это означает
[26:33.160 --> 26:39.280]  что вот эта строка равна вот этой строке то есть получается у префикса длины л штрих надо найти
[26:39.280 --> 26:45.880]  максимальной длины собственный суффикс который совпадает с префиксом то есть в переводе говоря
[26:45.880 --> 26:54.520]  л 2 штриха это просто префикс функция от л штриха удобно правда то есть более того когда после
[26:54.520 --> 27:00.880]  л 2 штриха надо найти следующую мы тоже должны просто взять там п то есть п от л штриха то есть
[27:00.880 --> 27:09.840]  п от л штриха и так далее то есть в результате это приводит нас то есть действительно к
[27:09.840 --> 27:17.320]  достаточно простому следствию то есть вот идем идем идем вот то есть получается там код просто
[27:17.320 --> 27:29.920]  вот ну совсем простой а нет это не совсем то хотя нет это тоже на самом деле то сейчас вот давайте
[27:29.920 --> 27:44.920]  это не совсем то так так сейчас ну да нет все нормально просто мы для стратегии с ищем
[27:44.920 --> 27:52.680]  префикс функция то есть префикс функция получается ищется вот очень простым вот таким методом вот
[27:52.680 --> 28:02.840]  то есть по большому счету идти то есть мы как бы то есть вот то есть видите то есть мы тут
[28:02.840 --> 28:06.440]  скайон вот то есть фактически вот обратить внимание тут ваил так очень удобно сделать то есть
[28:06.440 --> 28:12.960]  вайла скачет пока у нас этот вот длина это его префикса суффикса не сожмется в ноль вот но в
[28:12.960 --> 28:19.680]  конце мы правда префикс функцию там увеличиваем на 1 от текущего g именно когда вот но вот именно
[28:20.180 --> 28:25.280]  совпадают но тут это вот интересное такое за замечание получается если g равно нулю
[28:25.280 --> 28:31.960]  то оно тоже работает вот то есть получается вот такой простой код то есть можно ввести метод
[28:31.960 --> 28:37.760]  потенциалов и доказать что это работает за линию ну потому что по классике увеличивается nicto
[28:37.760 --> 28:43.280]  то есть никогда не станов Moses 0 меньше но они становятся и анн раз увеличивается на один и
[28:43.280 --> 28:48.240]  никогда он не уходит минус следовательно Orthodox skating уменьшается значит скачков
[28:48.240 --> 28:54.800]  суммарно не более чем n, но на самом деле можно просто заметить, что это
[28:54.800 --> 28:59.160]  простые два указателя. То есть тут десятью способами можно это
[28:59.160 --> 29:08.280]  увидеть. То есть вот так мы нашли префикс функции. Понятная идея, да?
[29:08.280 --> 29:13.520]  Что тут еще тогда важно знать про префикс функции?
[29:14.160 --> 29:20.200]  Еще важный терминологический момент еще есть. Как с помощью префикс функции
[29:20.200 --> 29:26.160]  искать подстроку в строке? Но тот вот, смотрите, есть тонкий момент. Потому что
[29:26.160 --> 29:29.960]  самый тупой, потому что в принципе есть вот такое понятие как алгоритм Кнута
[29:29.960 --> 29:38.040]  Мориса Пратта. Но он означает, возможно, обычно предельно тупую вещь.
[29:38.640 --> 29:44.760]  Это не совсем то, что я объяснял. Он говорит просто. Давайте возьмем строки P и S,
[29:44.760 --> 29:48.840]  сконкатинируем их через доллар, ну или диезик, там как вам будет угодно. Любой
[29:48.840 --> 29:55.520]  символ, которого нет ни в строке P, ни в строке S. И после этого насчитаем для
[29:55.520 --> 30:02.520]  всей этой строки префикс функции. И тогда просто прибираемся по зоне строки S,
[30:02.520 --> 30:09.880]  где она равна модуль P, там и под строка. Где нет, там нет. Обычно по поискам
[30:09.880 --> 30:13.600]  подстроки префикс функции или там под алгоритмом КМП подразумевается ровно это.
[30:13.600 --> 30:24.440]  Ну вот, то есть так по идее тоже можно. Это самое тупое. То есть это если для вас
[30:24.440 --> 30:29.640]  префикс функции просто черный ящик, у которого вы просто выучили код, то как бы да, так работает.
[30:29.640 --> 30:35.920]  Но на самом деле, если в префикс функции поразбираться, то можно сделать небольшую
[30:35.920 --> 30:43.240]  оптимизацию. То есть пару оптимизаций. Ну во-первых, тут еще важный вопрос в какой-то
[30:43.240 --> 30:49.880]  момент возникает. А сколько дополнительной памяти вы используете для поиска подстроки в строке?
[30:49.880 --> 31:04.520]  Вот дополнительной памяти. Да, здесь P плюс S. Ну на самом деле, ну заметим в шоке,
[31:04.520 --> 31:08.960]  что в явном виде вот эту конкатинацию можно не хранить, правда? То есть не надо там,
[31:08.960 --> 31:12.880]  условно говоря, копировать там P и S куда-то в одно место вам не надо. То есть на самом деле,
[31:12.880 --> 31:17.760]  конечно, можно там написать какую-нибудь функцию, которая там по числу И возвращает вам символ
[31:17.760 --> 31:23.480]  либо строки P, либо строки S, либо доллар. Ну там просто И в чекам, да? То есть это как бы
[31:23.480 --> 31:34.560]  симпточку вам не ухудшит, но по памяти вам... Ну и утверждение. Но по хорошему, чтобы сконкретинировать
[31:34.560 --> 31:41.120]  две строки, нужно тоже потратить P плюс S в дополнительной памяти. Вот. Но я просто сказал
[31:41.120 --> 31:46.080]  только что, что от этого, то есть от этого можно избавиться. Но кажется, у нас от префикс-функции
[31:46.080 --> 31:54.160]  нужна не больше, чем... Да, но на самом деле, но на самом деле, да. Я утверждаю, что на самом
[31:54.160 --> 32:00.840]  деле нам префикс-функцию реально хранить надо только для строки P. Да, почему? Ну просто обратите
[32:00.840 --> 32:05.840]  внимание, что когда мы тут, мы к ней вот обращаемся вот в этих местах, но на самом деле вот эта штука,
[32:05.840 --> 32:10.480]  это просто предыдущая префикс-функция, то есть на самом деле надо было просто здесь написать
[32:10.480 --> 32:18.960]  типа, что если вот верно вот эту равенство, то просто плюс-плюс G, а иначе G равно нулю. Вот. И тогда,
[32:18.960 --> 32:22.560]  на самом деле, вот в этом присваивании необходимости бы не было. То есть таким образом,
[32:22.560 --> 32:29.960]  реально префикс-функция нужна только здесь. Вот. Но заметим, что если... Но заметим, что как бы,
[32:29.960 --> 32:34.720]  если у нас есть P доллар S, то легко заметить, что у нас префикс-функция больше, чем модуль P,
[32:34.720 --> 32:40.720]  не становится никогда в принципе. Правда? Поэтому получается, что в реальности, оказывается,
[32:40.720 --> 32:46.560]  удобно сделать даже по-другому. Удобно сделать, посчитать префикс-функцию для строки P вот таким
[32:46.560 --> 32:53.200]  образом, а для строки S после этого взять G равно нулю и делать абсолютно тот же самый проход.
[32:53.200 --> 33:02.160]  Понимаете, да? То есть делать проход, но просто каждую новую префикс-функцию, то есть каждое
[33:02.160 --> 33:06.560]  новое значение префикс-функции не сохранять. А просто говорить, так, если у меня получился модуль P,
[33:06.560 --> 33:15.440]  значит, ой, ура, мы нашли под строку. Но записывать ее не обязательно. То есть более того,
[33:15.440 --> 33:19.720]  это получается алгоритм даже в некотором смысле в онлайне, потому что мы можем даже строку S
[33:19.720 --> 33:22.840]  не хранить, а просто приходит новый символ, мы там пересчитываем префикс-функцию.
[33:22.840 --> 33:36.840]  Да, то есть он онлайн относительно текста, да. То есть мы фактически нам дали шаблон P,
[33:36.840 --> 33:41.760]  мы сделали на нем какое-то шаманство, и после этого мы теперь любой текст можем обрабатывать
[33:41.760 --> 33:50.280]  условно в онлайне. Да, но мы умеем не просто только добавлять, а только pushback. Совершенно верно.
[33:50.280 --> 33:56.280]  Но уже, тем не менее, неплохо. Более того, на самом деле, то есть на самом деле можно это еще
[33:56.280 --> 34:01.200]  пооптимизировать, и это иногда помогает даже. Там даже не оптимизация, а следующая логика,
[34:01.200 --> 34:09.360]  что если мы добавляем в строку S символы по одному, то у нас может, алгоритм может зависнуть.
[34:09.360 --> 34:16.920]  Ну потому что у нас же алгоритм работает за линию, но он амортизированный, правда? То есть на
[34:16.920 --> 34:25.320]  каждой конкретный вайл может работать за O от P. Но на самом деле с этим тоже можно справиться.
[34:25.320 --> 34:37.840]  Нет, на самом деле тут идея такая. Потому что на самом деле заметим, что вот этот проход,
[34:37.840 --> 34:57.200]  вот этот вайлер, на самом деле можно тупо сжать до функции go. На самом деле, смотрите,
[34:57.200 --> 35:01.640]  заметим следующее, что у нас в этом коде происходит. Мы берем предыдущую функцию,
[35:01.640 --> 35:07.120]  префикс-функцию, и пытаемся приписать ей какой-то символ. Теперь заметим,
[35:07.120 --> 35:15.080]  что от самого по себе И, вот эта вот штука вся, не зависит от слова никак. То есть она зависит
[35:15.080 --> 35:22.080]  только от самого символа. То есть если бы я тут написал charge равно SE, то в общем-то дальше код
[35:22.080 --> 35:44.120]  никак бы и не использовал, правда? Да, то есть более того, если быть точнее, я хочу написать
[35:44.120 --> 35:47.920]  auto. То есть у меня ощущение, что у меня есть структура такая, что у меня есть текущая
[35:47.920 --> 35:54.120]  префикс-функция. Я приписываю символ, и префикс-функция как-то меняется. Причем новая префикс-функция зависит только от
[35:54.120 --> 36:00.960]  предыдущей, ну там внутри строке S, новая префикс-функция зависит только от предыдущей префикс-функции и символа.
[36:00.960 --> 36:09.840]  Что это значит? Префикс-функции автоматной префикс-функции. Более того, мы это будем называть
[36:09.840 --> 36:21.680]  автомат префикс-функции. То есть речь идет об автомате. Можно сказать и так. То есть действительно можно
[36:21.680 --> 36:26.960]  заметить, что эту функцию можно узнать до функции go соответственно, которая по сути более того,
[36:26.960 --> 36:35.920]  она в некотором смысле даже ее можно рекурсивно реализовать. Потому что мы говорим, вот мы хотим,
[36:36.560 --> 36:42.640]  вот смотрите, у нас сейчас префикс-функция в строке S. Давайте вот на эту строчку посмотрю. То есть мы
[36:42.640 --> 36:52.720]  говорим, что жила была у нас опять строка P, жила была строка S. Мы прошли из символа в строке S,
[36:52.720 --> 36:59.480]  и у нас оказалась какая-то строка длины L, которая совпадает с префиксом строки P.
[36:59.480 --> 37:08.760]  Окей, говорим мы. Так, теперь говорим, если мы к этой строке теперь припишем новый символ,
[37:08.760 --> 37:18.280]  там какой, ну, например, X, то есть и плюс первый, то как у нас поменяется вот это вот суффикс этой
[37:18.280 --> 37:25.560]  имеющейся строки, совпадающий с префиксом P? Ну, поменяется он тут два варианта. Но он будет либо,
[37:25.560 --> 37:32.880]  тут окажется, что тут тоже символ X, и тогда мы делаем вывод, что там L плюс один, либо,
[37:32.880 --> 37:39.720]  значит, нужно искать какие-то меньшие строки. Как их искать? Ну, очень просто, как мы уже ранее
[37:39.720 --> 37:44.600]  убедились, нам просто нужно перебрать все, получается, суффиксы, которые совпадают с префиксами,
[37:44.600 --> 37:50.120]  мы это делаем с помощью префикс-функции, правда? То есть мы знаем, что если у нас это L,
[37:50.120 --> 37:57.840]  то следующая строка имеет вид там префикс-функция там P от L, и тут P от P от L, ну и так далее. Понята
[37:57.840 --> 38:03.920]  логика, да? Вот, и так перебираем до тех пор, пока не найдем строчку, то есть префикс, у которого
[38:03.920 --> 38:12.360]  следующий символ X, ну или не убедимся, что это 0. Понятно, да? Но заметим, что, ну, как мы уже сказали,
[38:12.360 --> 38:21.920]  но только идея такая, на самом деле, что после L, то есть если мы от L, значит, на L плюс один
[38:21.920 --> 38:27.320]  перейти не смогли, то, получается, мы говорим, что, то есть надо фактически делать то же самое,
[38:27.320 --> 38:32.720]  просто от строки P от L. То есть, по большому счету, мы знаем, что наш ответ не больше,
[38:32.720 --> 38:37.760]  чем P от L, но там P от L теоретически мог бы подходить, если там символ совпадает, но, в общем-то,
[38:37.760 --> 38:42.200]  суть делать то же самое, поэтому просто запускаемся рекурсивно. То есть, заметим,
[38:42.200 --> 38:47.080]  что если бы тут было не L, а P от L, то мы бы дальше делали абсолютно то же самое. Поэтому,
[38:47.080 --> 38:55.360]  получается, что go от, в нашем случае, там ИА равно go от P от ИА, ну и так далее. Вот, то есть, как бы,
[38:55.360 --> 39:00.680]  там получается только ифтики, что про вот это вот условие, естественно, неверно, если и уже равно
[39:00.680 --> 39:07.280]  модуль P, тогда следующего символа тупо не существует. Вот, но это такая маленькая техника. То есть,
[39:07.280 --> 39:13.040]  вот получается такой автомат префикс функции. То есть, он иногда удобен, там бывают какие-то
[39:13.040 --> 39:19.440]  задачи, в которых это вот, в которых, как бы, от амортизации лучше избавляться. То есть, знаете,
[39:19.440 --> 39:26.120]  там есть классическая задача под bore называется. То есть, когда дан bore, по сути, надо находить
[39:26.120 --> 39:32.120]  подстроки уже в bore. Вот. Вот оказывается, то есть, на самом деле, в чем даже не подбор, а хуже дерево,
[39:32.120 --> 39:35.880]  потому что, на самом деле, там, то есть, если bore состоял из, там, суммарной длины,
[39:35.880 --> 39:40.120]  там, адекватных строк, то, как бы, там тоже все в порядке, на самом деле, можно показать по
[39:40.120 --> 39:45.640]  симптомике. Но, даже если бы в тупую делали. Но, в данном случае, но вот, но если там рандомное
[39:45.640 --> 39:52.600]  дерево, то лучше, конечно, просто написать автомат и не думать об этом. Вот. Так что, вот такая,
[39:52.600 --> 40:03.640]  вот штука автомат префикс функции. Вот. Понятная идея. С автомата, что такое автомат строк?
[40:03.640 --> 40:16.680]  О господи. Существуют ли у заданного текста подстроки, которые удовлетворяют вот этому
[40:16.680 --> 40:29.000]  автомату? Чего? Это такое, что ли, имеется в виду? Вот. Ну вот. Так что получается такая красота.
[40:29.000 --> 40:36.000]  Так это вот была у нас префикс функции. Существуют ли у этого автомата подстроки? Да-да-да-да-да-да-да-да.
[40:36.000 --> 40:39.040]  Да. Так, ну что, есть ли тут какие-то вопросы?
[40:39.040 --> 40:57.520]  Хорошо. Хорошо. Так, ну ладно. Тут, соответственно, все понятно, да? Ну,
[40:57.520 --> 41:04.480]  тогда давайте попробуем пойти дальше. Почему честные в кавычках? Ну, потому что, честные,
[41:04.480 --> 41:09.520]  ну, потому что у нас нет официально, ну, обычно в кавычках придется писать термин, которые как бы
[41:09.520 --> 41:15.360]  не, то есть мы не вводим там, то есть как бы там, от единицы времени называются честными, если там вот
[41:15.360 --> 41:21.680]  определение. То есть как бы честное тут имеется в виду, что вот такие, то есть мы как бы пытаемся
[41:21.680 --> 41:26.400]  неформально донести смысл, считая, что это будет удобнее, чем если мы его распишем формально.
[41:26.400 --> 41:31.200]  Вот. То есть это, конечно, определенный риск, потому что если это будет непонятно, то там как бы
[41:31.200 --> 41:35.960]  там читающие вашу статью люди там начнут вылькать, что так, ну, значит, вы пишете неформально,
[41:35.960 --> 41:40.120]  надо писать формально. Ай-ай-ай. Вот. То есть объяснением, что я написал неформально,
[41:40.120 --> 41:46.920]  что так понятнее, ну, вот для них это не довод, потому что им оказалось непонятно. Вот. Так что
[41:46.920 --> 41:57.040]  такие вот проблемы тоже есть. Вот. Но это у нас была префикс функции. Вот. Запомнили, да? Но на самом
[41:57.040 --> 42:09.520]  деле два указателя можно вывести и в другую сторону. Вот. Так. В какую? Ну, впрочем, можно два
[42:09.520 --> 42:13.600]  указателя на самом деле вывести в Z функцию. Но там два указателя, конечно, более явные будут.
[42:13.600 --> 42:23.920]  То есть альтернативой у нас служит такая Z функция. Ну, формальное определение тоже вывести на
[42:23.920 --> 42:36.880]  экране. Вот. Не, ну, в данном случае честно являлась она не потому, что честно, а в том плане,
[42:36.880 --> 42:41.000]  что там как бы нет амортизации. То есть как бы это не учетная стоимость, а реальная.
[42:41.000 --> 42:54.440]  Кто? Z функция N функция называлась? А, ну, правильно. Ну, потому что Z функция это официальное
[42:54.440 --> 43:00.640]  название, просто научное. Так что, общепринято. То есть понятно, можно там N функцию можно вводить,
[43:00.640 --> 43:09.280]  в конце концов, есть там очень старая задача A функция в строчке. Нет, ну, в смысле, скажем так,
[43:09.280 --> 43:14.320]  там многие задачи сдаются тупо хэшами на самом деле. Ну, главное просто местами их нужно сделать
[43:14.320 --> 43:23.320]  двойными или тройными, но как бы все равно сдаются. Нет, ну, эти дальше по Константе может не влазить.
[43:23.320 --> 43:37.840]  Зачем нужны птикатные хэши? Потому что меня Дима ломал. Ну, шубы. Ну, просто кажется, что в любой
[43:37.840 --> 43:49.040]  задаче это невозможно. Ну, скорее всего, да. Ну, там как повезет. Может, проблема в том, что как бы
[43:49.040 --> 43:53.160]  если вы замените одинарные хэши на трехкратной, значит у вас время работы, скорее всего,
[43:53.160 --> 43:58.440]  увеличится раза в три. Ну, в смысле, Дима может не хватить корень из 10 до 27. Не, ну, там же неправда,
[43:58.440 --> 44:10.680]  что прям в три раза увеличивается. Ну, вот хороший вопрос. Ну, и то правда, да. Ну,
[44:10.680 --> 44:19.440]  можно и так, но тогда дальше надо анализировать, как там совпадает. Ну, я понял, да, согласен,
[44:19.440 --> 44:26.120]  хорошо, уговорил. Аккуратно везде это написать, самое сложное. Нет, то обычно такие вещи пишутся,
[44:27.000 --> 44:32.800]  давай напишем функцию, которая просто это делает, там данные две под строки, проверь, пожалуйста,
[44:32.800 --> 44:41.960]  совпадают ли они. Ну, обычно это делается, просто напиши класс stringHash и создай три таких класса.
[44:41.960 --> 44:48.120]  Так что это все, ну понятно, это все технические детали, конечно, да. Так вот, значит, идейно z
[44:48.120 --> 44:54.680]  функция. Так, ну z функция, она в некотором смысле мыслит так назад. Ну, она обычно считается
[44:54.680 --> 45:04.240]  интуитивно проще. Вот, что в ней происходит? Да, ну, хэшами да, потому что, как минимум,
[45:04.240 --> 45:09.040]  да, она ищется хэшами и бинпоиском. Потому что на этот раз, то есть на этот раз, если у нас есть
[45:09.040 --> 45:16.920]  позиция и какая-нибудь, то нас интересует подстрока, начинающаяся, максимальная длина подстрока,
[45:16.920 --> 45:25.840]  которая начинается в символе и совпадает с префиксом. Ну, картинка вас не должна вводить в
[45:25.840 --> 45:31.680]  заблуждение, потому что, как бы, эта штука может, как бы префикс, может вполне себе накладываться на
[45:31.680 --> 45:39.240]  это символ. Вот, вот такая идея. Значит, вот у нас есть префикс функция, вот у нас есть такая,
[45:39.240 --> 45:46.640]  такой z функция. Вот. Ну, заметим, что, конечно, с помощью ее подстройки в строке тоже можно
[45:46.640 --> 45:54.040]  достаточно легко искать, правда? Потому что, если такая z функция уже насчитана для всех символов,
[45:54.040 --> 46:02.600]  то тогда, опять же, p диезик s, то есть делаем вот такой p диезик s, насчитываем z функцию,
[46:02.600 --> 46:11.480]  и где вот тут z функция у нас хорошая, то есть, где у нас z функция равна модуле p, там мы победили.
[46:11.480 --> 46:17.880]  Ну вот, то есть, да, только с той лишь разницы, что там начало, вхождение, а не конец. Да,
[46:17.880 --> 46:22.960]  только такая мелкая, мелкая техническая деталь. Но как же эту z функцию вычислять?
[46:22.960 --> 46:34.240]  Ну, оказывается двумя указателями. Ну, как ее вычислять? Ну, просто теми же двумя указателями,
[46:34.240 --> 46:46.560]  потому что, ну, то есть, формально можно расписать вот такую лему. И получается вот так и да. Такое
[46:46.560 --> 46:53.800]  большое количество букв. Ну а что делать? Да. Но, как бы, я думаю, видимо, сейчас, да, видимо,
[46:53.800 --> 46:58.000]  как в этом случае происходит на типичных формалках, мы сейчас нарисуем картинку и поймем,
[46:58.000 --> 47:05.800]  что это вообще значит. То есть, значит, оно на самом деле следующее. Да, там прямо без картинки.
[47:05.800 --> 47:24.760]  Ну, это уже отдельная задача. Нет, ну, на самом деле можно. Нет, вопрос тут был наоборот,
[47:24.760 --> 47:36.760]  можно ли по z функции восстановить префикс функции? Ну, нет. Ну, у меня был вопрос когда-то,
[47:36.760 --> 47:44.520]  как считать функцию хешами. По-моему, это можно было, но не особо тременно. Ну, утверждение нет. Ну,
[47:44.520 --> 47:50.800]  на самом деле, нет, сформулируем так. Заметим, что z функция, нет, смотрите, тут видимо имеется
[47:50.800 --> 47:55.560]  в виду идея, что если у вас есть z функция, то как бы сравнивать под строку с префиксом на равенство
[47:55.560 --> 48:01.760]  вы можете теперь за вот единиц. Да, но правда, к сожалению, рандомные две строки вам сравнить
[48:01.760 --> 48:14.800]  не удастся, но ничего страшного. Нет, это да, но это уже немножко другая история. Вот, значит,
[48:14.800 --> 48:21.480]  смотрите, ищем z функцию у мистической строки s. Лемма говорит нам о следующем. Смотрите,
[48:21.480 --> 48:30.400]  Лемма говорит следующее. То есть пусть у нас есть какая-то позиция i, в которой есть под строка
[48:30.400 --> 48:38.440]  длины k, вот длина k, вот эта вот позиция i плюс k получается, которая совпадает с префиксом. Вот,
[48:38.440 --> 48:48.800]  видно, да? Да. Ну вот, то есть идея на Лемма говорит следующее. То есть дальше она говорит так,
[48:48.800 --> 48:55.600]  что пусть у нас есть какой-то символ, ладно, не здесь, вот давайте пусть у нас есть какой-то символ j
[48:55.600 --> 49:08.440]  внутри этой подстроки. Так, ну вот, тогда я утверждаю, что если, то есть теперь, давайте
[49:08.440 --> 49:13.040]  кать вопрос, когда мы начинаем проверять, то есть находить максимальный, максимальную подстроку
[49:13.040 --> 49:20.080]  совпадающую с префиксом, мы как бы идем, идем, идем и вот до какого-то момента доходим, да? Ну,
[49:20.080 --> 49:24.200]  теперь, давайте кать вопрос, этот момент, он может быть как бы позже этой границы, а может быть раньше
[49:24.200 --> 49:31.040]  этой границы, да? Ну, может совпадать, конечно. Так вот, идея такая, если он не доходит до этой
[49:31.040 --> 49:42.800]  границы, то я утверждаю, что из ранее найденных z функций мы уже прекрасно можем его найти. То есть,
[49:42.800 --> 49:48.200]  ну, предположим, что мы z функции, вот там идея такая, предположим, что мы z функцию ищем слева направо,
[49:48.200 --> 49:55.520]  как всегда, вот до сюда дошли. Тогда я утверждаю, что на тему того, дойдет ли она до конца вот этой
[49:55.520 --> 50:03.960]  подстроки или не дойдет, если не дойдет, то куда, мы можем уже сказать и старые z функции. Почему? А вот
[50:03.960 --> 50:10.520]  почему. Потому что заметим, что в принципе, когда вы идете здесь до какого-то момента, то это примерно
[50:10.520 --> 50:17.800]  то же самое, как вы идете в символ, получается вот какой, и плюс к, минус g, да? Видите, вот тут и плюс
[50:17.800 --> 50:30.840]  к. Нет, не так. То есть, нет, смотрите, вот это длина строки k, то есть здесь получается, то есть, ну да, и плюс
[50:30.840 --> 50:40.040]  к, минус g, по сути. Нет, вру, вру, вру, неправда, неправда, неправда. Вот давайте, то есть, смотрите,
[50:40.040 --> 50:48.560]  то есть, вот эта подстрока равна вот этой. То есть, тут и плюс к, а тут g, но тухая нот, то есть,
[50:48.560 --> 50:54.080]  на самом деле, а, хотя можно и наоборот, тут и ты символ, а тут g, то есть, значит, если тут условно,
[50:54.080 --> 51:02.000]  там какой у нас первый символ, то тут получается, какой g, минус и плюс первый. То есть, тогда можно
[51:02.000 --> 51:13.160]  заметить, можно заметить, что вот эта подстрока просто равна вот этой, согласны? Ну, если у нас тут
[51:13.160 --> 51:19.240]  вот с один адексации. И тогда к чему это нас приводит? Приводит нас к этому, что тогда получается,
[51:19.240 --> 51:26.000]  мы можем посмотреть z функцию вот этой штуки, g, минус и плюс первый. И, оказывается, следующее,
[51:26.000 --> 51:31.480]  что если оказывается, что z функции этой штуки меньше, чем вот эта длина, а эта длина, это и плюс
[51:31.480 --> 51:37.160]  к, минус g, то есть, получается, у нас как бы вот тут где-то все обрубается, да, то есть, вот тут
[51:37.160 --> 51:45.840]  получается пуп и обрубается, и тут вот тут оба раза х, а тут получается игр. То тогда мы вынуждены
[51:45.840 --> 51:51.840]  заключить, что и здесь z функцию можно тупо скопипастить отсюда и не париться. То есть,
[51:51.840 --> 52:01.240]  на самом деле, вот эта лемма, если разобраться ровно, это означает. То есть, там другое,
[52:01.240 --> 52:08.880]  потому что это все на языке буквок там написано. И более того, вторая идея возникает, что может
[52:08.880 --> 52:14.640]  выясниться, что тут z функция больше либо равно, чем эта длина, но тогда мы про вот эту z же знаем
[52:14.640 --> 52:21.000]  только одно, мы знаем, что у нее z функция хотя бы вот столько. То есть, помните, тут вот бывает
[52:21.000 --> 52:26.960]  ошибка такая, что кто-то хочет прям, то есть, бывает реализация, что кто-то хочет прям скопипастить
[52:26.960 --> 52:32.840]  сюда прям значение отсюда, но если тут значение какое-то больше, то это означает, что здесь значение
[52:32.840 --> 52:37.120]  не меньше вот этой длины, потому что мы вот про вот эти две совпадающие строки знаем, что они
[52:37.120 --> 52:46.240]  совпадают, а то, что они будут совпадать дальше, мы не знаем. Вот. И это, кстати, иллюстрируется
[52:46.240 --> 52:58.240]  второй леммой. Вот. То есть, в принципе, здесь как бы все то же самое, только в формальном виде.
[52:58.240 --> 53:08.280]  То есть, я имею в виду, что вот эти строки равны и бла-бла-бла-бла-бла-бла-бла. Вот. И в результате
[53:08.280 --> 53:13.440]  получается такой достаточно классический алгоритм поиска префикс функции с помощью двух указателей.
[53:13.440 --> 53:20.760]  Он говорит так. Мы идем слева направо и считаем z функцию, начиная со второго символа. В каждый
[53:20.760 --> 53:26.360]  момент времени мы храним, то есть, мы храним такую подстроку, совпадающую с префиксом,
[53:26.360 --> 53:35.360]  которая заканчивается как можно позже. Вот. И дальше говорим, что мы находимся в очередной,
[53:35.360 --> 53:39.680]  то есть, мы находимся в очередной позиции. Но если она уже вышла за пределы этой строки,
[53:39.680 --> 53:49.840]  то мы ее начисляем в тупую. Прям вот совсем в тупую. Ну вот, если она попала еще внутрь вот этой
[53:49.840 --> 53:54.480]  его длинной строчки, то значит, тогда у нас два варианта. Мы берем вот, то есть, мы берем z,
[53:54.480 --> 53:58.840]  вот g минус и плюс первое. Если оно меньше, чем эта длина, значит, мы его тупо копируем.
[53:58.840 --> 54:10.800]  Если оно не меньше, то значит, мы копируем вот эту длину и далее в тупую. Вот. Понятная идея, да?
[54:10.800 --> 54:18.040]  Вот. Ну и, конечно, не забываем обновлять l и r, но и в общем-то получается, что фактически вот эта
[54:18.120 --> 54:25.360]  строка i и плюс k, она на самом деле держится на двух указателях по сути, потому что по сути получается
[54:25.360 --> 54:32.320]  каждая в тупую на самом деле вот это вот правый конец этой строки увеличивает хотя бы на 1. Вот.
[54:32.320 --> 54:39.080]  И тогда получается, что и отсюда тогда становится очевидно, что это, что суммарное время поиска
[54:39.080 --> 54:52.640]  такой z функции, это линия. Вот. Понятная идея. Вот. То есть, вот даже и код, в общем-то, получается,
[54:52.640 --> 55:00.320]  не сильно сложно. То есть, более того, можно даже в тупую делать всегда. То есть, по большому счету
[55:00.320 --> 55:07.280]  писать так, что z и t стартует либо с нуля, если у нас под строка не дошла до i, либо вот взять
[55:07.280 --> 55:15.320]  просто минимум из длины этой строки z и далее идти в тупую. То есть, можно даже тут не заморачиваться,
[55:15.320 --> 55:19.800]  потому что вот в этом случае, если она тут не доходила до сюда, то на самом деле у вас просто на
[55:19.800 --> 55:26.720]  первом же шаге будет фейл. Поэтому в коде это можно не писать. Вот. То есть, вот такая получается
[55:26.720 --> 55:42.560]  не сильно сложная штука. Вот. Так, ну что, есть ли тут какие-то вопросы? Да нет, наверное.
[55:42.560 --> 55:54.400]  Да нет, наверное. Нет, наверное. Ну хорошо. Да, ну здесь уже. Вот. Ну и, конечно, теперь, да,
[55:54.400 --> 56:01.440]  пришло время немножко обсудить, собственно, сам этот черный ящик знаменитый. То есть,
[56:01.440 --> 56:07.760]  теперь каким образом, вот, ВАЗК действительно тупая идея, да, как сравнивать две подстроки. Ну идея,
[56:07.760 --> 56:13.360]  на самом деле, берется вот откуда. Предположим, что нам так фантастически повезло, что мы умеем
[56:13.360 --> 56:19.680]  работать с произвольными числами. Вот знаете, такая мечта. Вот иногда, кстати, всегда верим,
[56:19.680 --> 56:28.520]  что давайте поверим, что мы умеем работать с натуральными числами произвольной длины. Вот. То есть,
[56:28.520 --> 56:32.320]  вообще абсолютно там нам плевать, какой величины. То есть, никаких там лонг-лонгов у нас нет,
[56:32.320 --> 56:39.240]  никаких длинной рифметики нет, просто все за вот единицы. Так. Ну вот. И предположим,
[56:39.240 --> 56:44.320]  что мы верим, что это за вот единицы работает, а не за какую-то там зашитую адскую фурятину.
[56:44.320 --> 56:51.080]  Тогда, оказывается, тогда, на самом деле, идея такая. То есть, тогда каждую строчку можно кодировать,
[56:51.080 --> 56:55.840]  ну просто, вообразите, что каждый символ это такая цифра в какой-нибудь системе
[56:55.840 --> 57:05.320]  счисления с основанием. Ну, например, 257. Или даже 256. Или сколько у нас там в АСКе кодировки символов?
[57:05.320 --> 57:20.440]  Ну, погодите, погодите, погодите. Нет, ведущая нулитка, конечно, да, но с другой стороны,
[57:20.440 --> 57:25.600]  мы же обычно и в хэшах можем подстройки срагивать по принципу. Так, погодите, а длину не совпадают.
[57:25.600 --> 57:35.640]  Нет, сразу до свидания. То есть, подстройки не совпадают. То есть, можно просто гарантировать,
[57:35.640 --> 57:40.680]  что мы хэш начинаем, пытаемся вычислять, так сказать, какую-то величину только для строк
[57:40.680 --> 57:47.200]  одинаковой длины. Вот. Но так можно действительно, но в принципе, хотя с другой стороны,
[57:47.200 --> 57:55.840]  ну, на самом деле, в принципе, можно, потому что если вы кодируете число в таком варианте,
[57:55.840 --> 58:01.760]  то есть, фактически, воображаете строку длины n как n-разрядное число такое, то по большому счету
[58:01.760 --> 58:06.240]  длина не принципиальна. То есть, как бы чем больше длина, тем фактически больше число будет. Ну,
[58:06.240 --> 58:11.440]  если только у вас, ну, правда, с оговоркой, если, конечно, только у вас первая буква не кодируется
[58:12.080 --> 58:17.560]  числом 0. Ну, я про это и говорю. Да. Ну, поэтому, ну, в принципе, да, тут два варианта можно. Либо длины
[58:17.560 --> 58:22.960]  тоже хранить, либо говорить, что давайте у нас, если у нас в Аске, там, допустим, в чаре 256 символов,
[58:22.960 --> 58:30.560]  да, там, ну, сколько там? Он же, там, сколько? Двубайтный обычно, да? А, нет. Ну, вот. Нет, а нет.
[58:30.560 --> 58:37.440]  300 тысяч. Нет, зачем 300 тысяч? Вот 257 достаточно. И кодировать все символы от 1 до 256. Тем более,
[58:37.440 --> 58:41.720]  что часто в этом нет необходимости, потому что у вас в строках обычно нету символа номер ноль.
[58:41.720 --> 58:49.400]  Потому что у нас, как всегда, как вы помните, в языке си это обычно знак конца строки такой. Понимаете,
[58:49.400 --> 58:56.560]  да? Поэтому, в принципе, как, поэтому даже можно не заморачиваться. Но, к сожалению, ну, в чем
[58:56.560 --> 59:00.240]  проблем? Да, то есть, как бы, если мы с такими числами умели работать, то никаких проблем бы у нас
[59:00.240 --> 59:05.280]  не было. То есть, каждая строка, это вот такое число, можно с ними как-то даже работать, можно там
[59:05.280 --> 59:10.120]  какие-то подстроки с помощью, даже иногда, даже битовых операций выковыривать. Давайте сделаем
[59:10.120 --> 59:16.800]  основание, там 512 и не будем париться. Вот. Но, как вы понимаете, в реальной жизни, к сожалению,
[59:16.800 --> 59:25.400]  это не так. Сейчас. Будем доказывать? Ну, в плане, то, что вставали в степень двойки, оно не повлияет
[59:25.400 --> 59:30.880]  негативно на то, что если оно, если было простое? Нет, ну, доказывать не будем, но известный факт
[59:30.880 --> 59:36.800]  повлияет. Хотя, смотря, как считать. Потому что, да, так, ну, давайте официально скажу, что такое хэш,
[59:36.800 --> 59:41.840]  да? То есть, обычно классические применяемые хэш, это когда мы такие числа все-таки вычисляем,
[59:41.840 --> 59:50.600]  но вычисляем не его, а остаток в какой-нибудь модулю. Ну, тогда, то есть, он как бы хэш, он как бы тогда...
[59:50.600 --> 59:56.160]  А, вы пока не берете по модулю. Ну, до этого момента не брал. То ты прикол, я говорю, что если бы у нас была
[59:56.160 --> 01:00:00.640]  такая счастье, что мы сколь угодно большие числа берем, то тогда это было бы даже не... То есть,
[01:00:00.640 --> 01:00:06.600]  это была бы не подхачка какая-то с вероятностью коллизии, а как бы абсолютно работающий метод,
[01:00:06.600 --> 01:00:12.720]  и не надо было бы париться и изобретать там какие-то префиксы функции. Почему же мы их изобретаем?
[01:00:12.720 --> 01:00:21.520]  Потому что, на самом деле, оказывается, что такие большие числа мы хранить не можем. Но мы можем
[01:00:21.520 --> 01:00:28.280]  хранить остаток по какому-нибудь модулю. Но идея вот такая. А давайте действительно заведем какие-нибудь
[01:00:28.280 --> 01:00:35.480]  основания A, основания M, и будем сравнивать. Ну, и с точки зрения какой-то интуитивной... Ну,
[01:00:35.480 --> 01:00:40.480]  вообще, интуитивной рандомности говорим, что если строки одинаковые, то хэши точно совпадут,
[01:00:40.480 --> 01:00:48.280]  а если строки не одинаковые, то они, наверное, где-то с вероятностью один делить на M. Ну, может,
[01:00:48.280 --> 01:00:57.320]  нам не повезет. И тогда чем больше M, тем лучше. Ну, там дальше что такое M? Ну, потому что самое...
[01:00:57.320 --> 01:01:05.680]  Ну, тут, конечно, по-разному. Ну, здесь давайте первое, что хочется. Ну, наверное, хотелось бы,
[01:01:05.680 --> 01:01:12.080]  чтобы если строка поменялась на один символ, то хэш изменялся, да? Но как бы это обычно делается,
[01:01:12.080 --> 01:01:17.840]  ну, в идеале хочется просто, что если есть какой-нибудь S, то хотим бы прибегаться по A,
[01:01:17.840 --> 01:01:23.600]  подомножать его на A разной степени, чтобы он там прибегал как можно больше значений по модулю M,
[01:01:23.600 --> 01:01:30.640]  правда? Ну, короче, нам, во-первых, чтобы A было больше, чем размер ассоциации. Ну, нет. Ну,
[01:01:30.640 --> 01:01:36.000]  может быть, даже не обязательно. Нет, если не обязательно, то мы подставляем два разных символа.
[01:01:36.000 --> 01:01:41.880]  Нет, понимаешь, что фишка такая. Нет, а, ну, в этом смысле, да. А, конечно, желать,
[01:01:41.880 --> 01:01:47.520]  чтобы больше был, чем размер алфавита, да, наверное. Хотя принципиально ли это?
[01:01:47.520 --> 01:01:55.800]  Сейчас, если мы храним длину... Нет, то есть храним длину, то, наверное, не принципиально. Потому
[01:01:55.800 --> 01:02:01.720]  что мы шли по модулю A берем по модулю M. Да, если не храним длину, то нас просто... То есть, в принципе,
[01:02:01.720 --> 01:02:06.680]  если мы хотим пока, если у нас пока цель просто, то есть давайте так просто, давайте мысль такая,
[01:02:06.680 --> 01:02:18.120]  то есть поредите мысль просто, мыслите немножко не туда, то есть... Нет, тут идея... То есть,
[01:02:18.120 --> 01:02:22.080]  тут, как бы, да, заметим, что если мы возьмем A, как вы уже, наверное, из каких-нибудь УКТЧ знаете,
[01:02:22.080 --> 01:02:26.880]  да, если мы A возьмем взаимно простым с M, то, в общем-то, там, видимо, примерно какие-то
[01:02:26.880 --> 01:02:33.480]  остатки прибегутся. Если M еще и простое, то, как бы, тогда он прибегает вообще все остатки,
[01:02:33.480 --> 01:02:41.160]  не нулевые. Ну, а простое, с этой точки зрения, даже не принципиально, на самом деле. То есть,
[01:02:41.160 --> 01:02:45.200]  если M простое, то вот так. То есть, можно, в принципе, сделать, чтобы M было не простое,
[01:02:45.200 --> 01:02:52.000]  а взаимно простое с ним. Тогда мы таким образом прибежим все взаимно простые с M остатки. Тоже,
[01:02:52.000 --> 01:02:59.880]  в принципе, вариант. Вот, на самом деле одно время некоторое было популярен в этом месте. Ну, там вот,
[01:02:59.880 --> 01:03:09.240]  да, тут есть, Рейше. Да, есть такая вот некоторая теремка, конечно, веселая, да. Но это, как бы,
[01:03:09.240 --> 01:03:13.480]  я думаю, не будет сейчас... Я думаю, из УКТЧ вам все это там не то, чтобы очевидно, но прекрасно
[01:03:13.480 --> 01:03:19.000]  известно. Ну, как очевидно? Ну, там не очевидно. Мне кажется, там, как бы, с нуля вот эти все остатки,
[01:03:19.240 --> 01:03:25.320]  свойства всякие по модулю, это не так быстро. Ну, если не с нуля, то, естественно, не очень
[01:03:25.320 --> 01:03:34.480]  интересно. Да. Так что не важно. Так что ладно, я думаю, тут можем особо не копать. Вот. Но просто
[01:03:34.480 --> 01:03:39.320]  хочется сказать следующее, что на самом деле когда-то был очень популярный такой хэш по модулю
[01:03:39.320 --> 01:03:51.080]  264. Потому что как? Чего? Ну, возможно, не знаю. Нет, ну это просто летает. Нет, ну да, потому что это
[01:03:51.080 --> 01:03:58.320]  летает почему? Потому что как провести сложение-вычитание-умножение в языке C++ по модулю 264?
[01:03:58.320 --> 01:04:04.320]  Нет, храним в онсайн плонглон и просто позволяем переполняться, потому что оказывается
[01:04:04.320 --> 01:04:10.200]  переполнение в онсайн плонглон, железобетонно работает так, как надо. Вот. Более того, по факту и в
[01:04:10.200 --> 01:04:17.760]  лонглоне тоже. Правда, да, это просто стандартом это уже не гарантируется, но по идее там часто в
[01:04:17.760 --> 01:04:28.800]  лонглоне. На самом деле да. Но это сейчас это непопулярно. Потому что возникла, к сожалению,
[01:04:28.800 --> 01:04:39.000]  маленькая подлянка. Нет, на самом деле просто хэши 244, к сожалению, вам могут и забанить. Потому что,
[01:04:39.000 --> 01:04:45.720]  к сожалению, там есть некоторые такие свойства, которые говорят, что если вот сгенивить строку
[01:04:46.320 --> 01:04:58.880]  вот таким вот нехитрым образом. Вот. Видно каким? Да, видно. Но то есть идея такая, что мы берем строку 0,
[01:04:58.880 --> 01:05:07.120]  потом значит на каждом шаге мы берем предыдущую строку и приписываем сзади ее же, но инвертированно.
[01:05:07.120 --> 01:05:13.280]  То есть вот 0, 0, 1, вот 0, 1, 1, 0, потом сюда там 1, 0, 0, 1, ну и так далее.
[01:05:15.720 --> 01:05:23.280]  Ну сформулируем так, ну для любого не гарантирую, но по примеру конкретно для 244, значит есть подробная
[01:05:23.280 --> 01:05:29.280]  роспись. Кстати, можете найти там пост на Codeforces, автор Макс Ахмедов, значит в котором-то это
[01:05:29.280 --> 01:05:36.000]  показывает, что там огромное количество будет совпадающих там по модуле 244 строк, у которых
[01:05:36.000 --> 01:05:43.120]  хэши будут совпадать. Для любого основания. Нет, это вот именно по основанию степень 2. В чем-то
[01:05:43.440 --> 01:05:55.360]  абсолютно все равно какое основание вы выберете. Да, именно. А вот не важно. Вот утверждается,
[01:05:55.360 --> 01:06:02.240]  что там вообще при любом нечетном там фейлы начнутся. А при четном как вы просто сокращаете
[01:06:02.240 --> 01:06:09.200]  его с модулем. Так что не суть важна. А там даже еще хуже будет. Если у вас, извините,
[01:06:09.200 --> 01:06:17.120]  основание четное, то основание в степени 64, это уже, простите, 0. Так что, поэтому основание четное вы
[01:06:17.120 --> 01:06:22.080]  тем более не возьмете. Поэтому, то есть претекают проблемы. То есть нет, то есть на самом деле,
[01:06:22.080 --> 01:06:28.480]  но правда сам Макс Ахмедов говорит, что он такие тесты никогда не вставляет. Вот мы в этом смысле
[01:06:28.480 --> 01:06:36.160]  грешны, мы вот свои контесты такие тесты пару раз вставляли. Вот. Но на самом деле, да, Макс
[01:06:36.160 --> 01:06:41.600]  Ахмедов говорит, что я такие тесты себе никогда в тесты не вставляю. Почему? Ну просто потому,
[01:06:41.600 --> 01:06:46.320]  что очень тупо, потому что это примерно то же самое, как валить хэш в предположении, что вы его
[01:06:46.320 --> 01:06:51.040]  пишете по модулю миллиард семь. Потому что тогда задача сдается так. Заменяем миллиард семь на
[01:06:51.040 --> 01:06:59.600]  миллиард девять и у вас неожиданно окей. То есть поэтому, естественно, валить конкретные модули
[01:06:59.600 --> 01:07:03.680]  хэшей, естественно, никто не будет. То есть никто не будет просто потому, что это нечестно. То есть
[01:07:03.680 --> 01:07:10.000]  тогда надо либо валить все возможные хэши, коих бесконечно много. Потому что лично я вообще часто
[01:07:10.000 --> 01:07:14.240]  люблю, когда писать не миллиард семь, миллиард девять, а пишу там первое пришедшее мне в голову
[01:07:14.240 --> 01:07:21.080]  число в районе миллиарда и там буквально фориком накажу ближайшее простое. Есть же прекрасные числа,
[01:07:21.080 --> 01:07:51.080]  состоящие 179, с добавлением чего-то там. Ну вот да, ну можно и так. Это не то, которое все используют, там есть другое, которое еще на него похоже. Ну понятно, понятно, но да. Так же всякое такое, ну можно вообще... Нет, а это неважно, а все равно как бы, ну то есть... Не, ну там просто нет. Дальше как бы фишка по кодфольсису, конечно. Да, на кодфольсе, если вы в явном виде написали хэш, то вас в явном виде могут взломать конкретно. Фишка в том, что вы пишете
[01:07:51.080 --> 01:07:58.040]  массив на 20 хэшей, рандомно выбираете там пару... А вот это уже... Ну, проблема в том, что рандом тоже, как показала практика,
[01:07:58.040 --> 01:08:11.600]  неправильно написано рандом тоже прекрасно предподсчитывается, потому что это псевта. Во-во-во-во. Через хрона почтишь, что любой колок типо нормально работает. Ну да. В секундах тебе отдается время.
[01:08:11.600 --> 01:08:20.680]  Ну это да. Оно уже не ломается как бы. Ну так просто уже не ломается. В секунду уже не угадаешь. Нет, ну там отдельная песня, там на кодфольсе была на самом деле как-то дана такая задача,
[01:08:20.800 --> 01:08:29.800]  которая, по-моему, принципиально нельзя сдать без угрозы взлома. Ну почти нельзя. Потому что там задача, потому что там задача, по-моему, там примерно такая.
[01:08:29.800 --> 01:08:46.680]  То есть у вас... Чего? Сейчас, нет. Там немного другое. Там дано так. Вам дано досвязанный список. Он состоит из, по-моему, 50 тысяч вершин, но фишка в том,
[01:08:46.680 --> 01:08:57.680]  что вы не знаете, в каком порядке эти вершины идут друг с другом. То есть у вас есть интерактор, который вам сообщает, что там для каждой вершины может сообщить, какое число на нем написано и какое следующее.
[01:08:57.680 --> 01:09:10.680]  И какая следующая вершина. То есть также было известно, что там на них написаны какие-то числа, и известно, что если вы идете вдоль списка, то у вас получается...
[01:09:11.680 --> 01:09:23.680]  То этот массив получается цартирован. Так вот, задача. Дано n, то есть длина этого списка, и дано число x. Найдите lower bound от x. У вас тысяча запросов.
[01:09:23.680 --> 01:09:24.680]  Тысяча?
[01:09:24.680 --> 01:09:25.680]  Да.
[01:09:25.680 --> 01:09:26.680]  На сколько вершин?
[01:09:26.680 --> 01:09:28.680]  На 50 тысяч.
[01:09:28.680 --> 01:09:30.680]  Чего? Зачем? Сколько?
[01:09:30.680 --> 01:09:34.680]  Ну, может там, ну и, может там, может там чуть поточнее. Не помню.
[01:09:34.680 --> 01:09:36.680]  То есть типа 40 не хватает?
[01:09:36.680 --> 01:09:44.680]  Нет, ну так кто-то и прикроет, что вы не знаете заранее порядка. То есть там, может, идет за первым, идет там на пятый, за пятым десятый, за десятым второй.
[01:09:44.680 --> 01:09:46.680]  То есть кажется, что либо логарифм, либо ОАТМ?
[01:09:46.680 --> 01:09:49.680]  Ну, формально ОАТМ, да.
[01:09:49.680 --> 01:09:50.680]  А.
[01:09:50.680 --> 01:09:55.680]  Нет, потому что никакого логарифма нет, потому что вы не можете найти элемент, который находится в середине списка.
[01:09:55.680 --> 01:09:57.680]  Ну да.
[01:09:57.680 --> 01:10:05.680]  Да, получается, что как бы, то есть получается, то есть эпическая ситуация. То есть как бы честного решения, видимо, не существует в природе.
[01:10:07.680 --> 01:10:11.680]  Вот. То есть по факту там как бы начинает пихаться там что-то в духе.
[01:10:11.680 --> 01:10:18.680]  Давайте там условно сгенерим там что-то типа 500 рандомных значений, выберем из них максимальное, которое меньше, это меньше икса.
[01:10:18.680 --> 01:10:21.680]  И после, а с него будем идти честно.
[01:10:21.680 --> 01:10:22.680]  Тем временем.
[01:10:22.680 --> 01:10:26.680]  Вот. Но проблема в том, что это все упирается в рандом, и дальше любой рандом может быть завален.
[01:10:26.680 --> 01:10:29.680]  Тем временем задача касс-квалификация CPC.
[01:10:29.680 --> 01:10:34.680]  Ну это уже да. Нет, я ее не читал, но как бы наслышан. Да.
[01:10:34.680 --> 01:10:37.680]  Да, наслышан как-то, да.
[01:10:37.680 --> 01:10:39.680]  У нас есть любители этой задачи.
[01:10:39.680 --> 01:10:40.680]  Да.
[01:10:40.680 --> 01:10:41.680]  Рандомные.
[01:10:41.680 --> 01:10:42.680]  Да.
[01:10:42.680 --> 01:10:49.680]  Гарантируется, что входные тесты можно зарифать, да.
[01:10:49.680 --> 01:10:52.680]  Ну понятно, понятно. Да, да, да, да.
[01:10:52.680 --> 01:10:53.680]  Вот.
[01:10:53.680 --> 01:11:00.680]  Так что тут так же получилась такая эпическая задача, то есть как бы практически, то есть надо очень аккуратно писать рандом, чтобы вас не завалили.
[01:11:00.680 --> 01:11:06.680]  То есть потому что там, то есть там любители найдутся, да.
[01:11:06.680 --> 01:11:17.680]  Но там надо читать, потому что у меня было ощущение, что там едва ли не даже с какими-то ходят там, то есть с какими-то там даже рандомными эстрандами или чем-то еще, даже это там ухитрялись валить.
[01:11:17.680 --> 01:11:19.680]  Вот. То есть это эпическая абсолютно задача.
[01:11:19.680 --> 01:11:25.680]  То есть это я бы назвал, это просто идеально, просто идеально, можно сказать, взлом самой системы Код Форсиса на самом деле.
[01:11:25.680 --> 01:11:28.680]  Просто, то есть это прям вот лучшая задача.
[01:11:28.680 --> 01:11:31.680]  Просто я помню, это называется IMT-Храунд 2 или что-то в этом роде очень рекомендую.
[01:11:31.680 --> 01:11:36.680]  То есть там специально сделали максимально мерзкую вещь, да?
[01:11:36.680 --> 01:11:38.680]  Ну это не мерзкая вещь, но вот, да.
[01:11:38.680 --> 01:11:46.680]  Ну это нет, конечно, авторы какие-то говорят, а мы умели взламывать там кучу технологий там генерации рандома, но мы все такие тесты, естественно, из тестов удалили.
[01:11:46.680 --> 01:11:48.680]  Ну вот.
[01:11:48.680 --> 01:11:50.680]  Взламывали участник?
[01:11:50.680 --> 01:11:54.680]  Да. Но участника взламывать не запретишь, да, поэтому.
[01:11:54.680 --> 01:11:56.680]  Чего?
[01:11:56.680 --> 01:11:58.680]  Можно запретить участнику взламывать в дачу.
[01:11:58.680 --> 01:11:59.680]  Да.
[01:11:59.680 --> 01:12:01.680]  Но как минимум в задачах B1-B2 B1 взламывать нельзя.
[01:12:01.680 --> 01:12:03.680]  Да.
[01:12:03.680 --> 01:12:05.680]  Потому что без дачи B2.
[01:12:05.680 --> 01:12:09.680]  Без дачи B2, ты стоишь в B1 и держишь взламывать, видишь решение B2, даешь B2.
[01:12:09.680 --> 01:12:11.680]  А.
[01:12:11.680 --> 01:12:13.680]  Потому что человек в B1-B2 заслал, да.
[01:12:13.680 --> 01:12:19.680]  Ну часто в дачах, если нет реально, как сделать взлом, там просто говорят, что взламывать нельзя.
[01:12:19.680 --> 01:12:21.680]  Понятно.
[01:12:21.680 --> 01:12:23.680]  А, ну бывает.
[01:12:23.680 --> 01:12:25.680]  Чтобы не думать.
[01:12:25.680 --> 01:12:28.680]  Нет, просто честно, я на такое не наталкивался, видимо, я редко пишу код форсиса.
[01:12:28.680 --> 01:12:30.680]  Хорошо.
[01:12:30.680 --> 01:12:32.680]  Знаете, да типа каждый десятый раунд.
[01:12:32.680 --> 01:12:34.680]  Ну я понял, я понял.
[01:12:34.680 --> 01:12:36.680]  Ладно, хорошо.
[01:12:36.680 --> 01:12:39.680]  Ладно, то есть вот такие вот рандомы и засудили, но что еще тут надо обсудить?
[01:12:39.680 --> 01:12:41.680]  Таким образом, значит.
[01:12:41.680 --> 01:12:43.680]  Просто как еще можно валить хэши глобально?
[01:12:43.680 --> 01:12:45.680]  Потому что на самом деле есть подлянки.
[01:12:45.680 --> 01:12:47.680]  Какие еще подлянки?
[01:12:47.680 --> 01:12:49.680]  Потому что ладно, по модуле 2,64 поняли.
[01:12:49.680 --> 01:12:51.680]  Казалось бы, можно брать по модуле какие-нибудь 10, 9, 7.
[01:12:51.680 --> 01:12:53.680]  Ну такой хэш.
[01:12:53.680 --> 01:12:55.680]  Ну как бы, на самом деле, как завалить такой хэш?
[01:12:55.680 --> 01:12:57.680]  Просто по модуле...
[01:12:59.680 --> 01:13:01.680]  Нет, ну строку не обязательно.
[01:13:01.680 --> 01:13:03.680]  Просто как минимум, просто проблема в другом.
[01:13:03.680 --> 01:13:06.680]  Просто по модуле миллиард 7, на самом деле, просто фишка будет такая.
[01:13:06.680 --> 01:13:10.680]  То есть если вы просто сравниваете там две строки и совпадут ли у них хэши, то это одно дело.
[01:13:11.680 --> 01:13:13.680]  А так, на самом деле, если у вас была задача,
[01:13:13.680 --> 01:13:15.680]  дано, например, 10 в пятый строк.
[01:13:17.680 --> 01:13:19.680]  Дано 10 в пятый строк.
[01:13:19.680 --> 01:13:21.680]  Скажите, пожалуйста, сколько из них попало на различных.
[01:13:23.680 --> 01:13:25.680]  И тогда...
[01:13:25.680 --> 01:13:27.680]  То есть у вас может возить тут такая идея.
[01:13:27.680 --> 01:13:29.680]  А давайте-ка сгенерируем хэши и запихнем их в какой-нибудь сет.
[01:13:30.680 --> 01:13:32.680]  И сколько там в сете различных элементов будет, столько и окей.
[01:13:34.680 --> 01:13:36.680]  Но есть маленькая подлянка.
[01:13:36.680 --> 01:13:38.680]  То есть, к сожалению, независимо от того,
[01:13:38.680 --> 01:13:40.680]  какой вы там выберете хэш по модулю,
[01:13:40.680 --> 01:13:42.680]  конкретно миллиард 7 или порядка миллиарда,
[01:13:42.680 --> 01:13:44.680]  скорее всего, у вас будут левые коллизии.
[01:13:44.680 --> 01:13:46.680]  Почему?
[01:13:46.680 --> 01:13:48.680]  Потому что есть действительно такой парадокс.
[01:13:48.680 --> 01:13:50.680]  То есть важно отметить, что есть такая вещь,
[01:13:50.680 --> 01:13:52.680]  как парадокс нерождений.
[01:13:54.680 --> 01:13:56.680]  В чем он заключается?
[01:13:58.680 --> 01:14:00.680]  То есть суть действительно заключается в том,
[01:14:00.680 --> 01:14:02.680]  что, например,
[01:14:02.680 --> 01:14:04.680]  то есть он формулируется так же.
[01:14:04.680 --> 01:14:06.680]  Если мы возьмем
[01:14:06.680 --> 01:14:08.680]  какой-то рандомных N людей,
[01:14:10.680 --> 01:14:12.680]  то утверждается, что начиная с какого-то момента,
[01:14:12.680 --> 01:14:14.680]  с большой вероятностью найдутся
[01:14:14.680 --> 01:14:16.680]  два человека, у которых
[01:14:16.680 --> 01:14:18.680]  день рождения совпадет.
[01:14:18.680 --> 01:14:20.680]  Так хорошо, что в нашей аудитории это не работает.
[01:14:20.680 --> 01:14:22.680]  Да, в нашей аудитории сейчас это, конечно, не работает.
[01:14:22.680 --> 01:14:24.680]  Но если бы я спросил вас где-нибудь там
[01:14:24.680 --> 01:14:26.680]  где-нибудь год назад,
[01:14:26.680 --> 01:14:28.680]  то, скорее всего, такое бы произошло.
[01:14:28.680 --> 01:14:30.680]  Нет, на самом деле там медленно бывает вероятность.
[01:14:30.680 --> 01:14:32.680]  То есть мой папа один раз
[01:14:32.680 --> 01:14:34.680]  на этом погорел, у него было
[01:14:34.680 --> 01:14:36.680]  в аудитории человек сорок,
[01:14:36.680 --> 01:14:38.680]  он рассудил интуитивно, что
[01:14:38.680 --> 01:14:40.680]  наверняка должны быть люди с днем рождения.
[01:14:40.680 --> 01:14:42.680]  Так.
[01:14:42.680 --> 01:14:44.680]  И проспалил шоколадку, потому что
[01:14:44.680 --> 01:14:46.680]  там вероятность больше 50%
[01:14:46.680 --> 01:14:48.680]  становится быстро, а вот убывает она не очень быстро.
[01:14:48.680 --> 01:14:50.680]  А, понятно, понятно.
[01:14:50.680 --> 01:14:52.680]  Прикольно.
[01:14:56.680 --> 01:14:58.680]  Ух ты!
[01:14:58.680 --> 01:15:00.680]  А там было
[01:15:00.680 --> 01:15:02.680]  четыре человека или восемь?
[01:15:02.680 --> 01:15:04.680]  А, математика.
[01:15:04.680 --> 01:15:06.680]  Ну, ладно.
[01:15:06.680 --> 01:15:08.680]  Ну, значит,
[01:15:08.680 --> 01:15:10.680]  ну, значит, вот соответственно твоего папу
[01:15:10.680 --> 01:15:12.680]  скомпенсировали где-то, да?
[01:15:12.680 --> 01:15:14.680]  Да.
[01:15:14.680 --> 01:15:16.680]  Шоколадку-то не вернули?
[01:15:16.680 --> 01:15:18.680]  Ну, господи.
[01:15:18.680 --> 01:15:20.680]  Ну, да.
[01:15:20.680 --> 01:15:22.680]  Ну, ладно, это уже мелочи.
[01:15:22.680 --> 01:15:24.680]  Ну, вот.
[01:15:24.680 --> 01:15:26.680]  Ну, действительно, да, всякое такое бывает.
[01:15:26.680 --> 01:15:28.680]  Но что, действительно, там
[01:15:28.680 --> 01:15:30.680]  парадокс такой, действительно, что если прям там где-то
[01:15:30.680 --> 01:15:32.680]  посчитать, то там, оказывается,
[01:15:32.680 --> 01:15:34.680]  вероятность 50% достигается
[01:15:34.680 --> 01:15:36.680]  где-то в районе 23.
[01:15:36.680 --> 01:15:38.680]  То есть даже есть какая-то
[01:15:38.680 --> 01:15:40.680]  легенда, на самом деле, что
[01:15:40.680 --> 01:15:42.680]  на каком-то званом ужине
[01:15:42.680 --> 01:15:44.680]  там Давид Гильберт
[01:15:44.680 --> 01:15:46.680]  даже рассказывал про этот парадокс,
[01:15:46.680 --> 01:15:48.680]  люди не поверили и стали проверять.
[01:15:48.680 --> 01:15:50.680]  Там за столом сидело 22
[01:15:50.680 --> 01:15:52.680]  человек и стали проверять, ни у кого не совпало.
[01:15:52.680 --> 01:15:54.680]  И она, да ладно, ничего не работает.
[01:15:54.680 --> 01:15:56.680]  А потом так подходит и горничная
[01:15:56.680 --> 01:15:58.680]  вот эта, которая подносила им еду
[01:15:58.680 --> 01:16:00.680]  и говорит, слушайте, я прошу прощения, но я тут 23
[01:16:00.680 --> 01:16:02.680]  и у меня день рождения вот такой же, как у
[01:16:02.680 --> 01:16:04.680]  вон того генерала.
[01:16:04.680 --> 01:16:06.680]  Да, вот.
[01:16:06.680 --> 01:16:08.680]  Есть такая, да, есть такая еще,
[01:16:08.680 --> 01:16:10.680]  маленькая там такая баечка.
[01:16:10.680 --> 01:16:12.680]  Гильберт заплатил.
[01:16:12.680 --> 01:16:14.680]  Нет, знаете,
[01:16:14.680 --> 01:16:16.680]  давайте прежде чем перерыв, я скажу, там на самом деле
[01:16:16.680 --> 01:16:18.680]  заплатили, бывает еще шедевральне.
[01:16:18.680 --> 01:16:20.680]  Знаете, классический анекдот звучит так,
[01:16:20.680 --> 01:16:22.680]  как еще советский анекдот.
[01:16:22.680 --> 01:16:24.680]  Приехал в Советский Союз какой-то крутой
[01:16:24.680 --> 01:16:26.680]  американский математик.
[01:16:26.680 --> 01:16:28.680]  Его аналогичный советский коллега,
[01:16:28.680 --> 01:16:30.680]  принимающий, позвал его
[01:16:30.680 --> 01:16:32.680]  в ресторан, и ему захотелось похвастаться,
[01:16:32.680 --> 01:16:34.680]  что у нас математическое образование самое
[01:16:34.680 --> 01:16:36.680]  крутое в мире.
[01:16:36.680 --> 01:16:38.680]  Поэтому он сделал так, перед тем, как вести
[01:16:38.680 --> 01:16:40.680]  американцев в ресторан, он так, позвал
[01:16:40.680 --> 01:16:42.680]  официан, говорит, смотрите,
[01:16:42.680 --> 01:16:44.680]  я сейчас приведу коллегу, мы там будем сидеть,
[01:16:44.680 --> 01:16:46.680]  когда вы меня поднесете нам
[01:16:46.680 --> 01:16:48.680]  напитки, я вам задам
[01:16:48.680 --> 01:16:50.680]  какой-то вопрос, значит, абсолютно
[01:16:50.680 --> 01:16:52.680]  неважно, какой вопрос,
[01:16:52.680 --> 01:16:54.680]  абсолютно неважно, просто вы ответите
[01:16:54.680 --> 01:16:56.680]  Треть Икс Куб.
[01:16:56.680 --> 01:16:58.680]  Она как?
[01:16:58.680 --> 01:17:00.680]  Треть Икс Куб?
[01:17:00.680 --> 01:17:02.680]  Нет, Треть Икс Куб.
[01:17:02.680 --> 01:17:04.680]  Треть Икс Куб, да?
[01:17:04.680 --> 01:17:06.680]  Треть Икс Куб, запомните,
[01:17:06.680 --> 01:17:08.680]  выучите.
[01:17:08.680 --> 01:17:10.680]  Треть Икс Куб.
[01:17:10.680 --> 01:17:12.680]  Все, договорились.
[01:17:12.680 --> 01:17:14.680]  Хорошо.
[01:17:14.680 --> 01:17:16.680]  И так находит следующий день,
[01:17:16.680 --> 01:17:18.680]  приходит он американца, приходит официантка,
[01:17:18.680 --> 01:17:20.680]  он говорит, слушай, девушки,
[01:17:20.680 --> 01:17:22.680]  на самом деле у нас вообще вся страна
[01:17:22.680 --> 01:17:24.680]  на самом деле знает мотоанализ.
[01:17:24.680 --> 01:17:26.680]  Он говорит, да, вообще все,
[01:17:26.680 --> 01:17:28.680]  прям все, даже он официант,
[01:17:28.680 --> 01:17:30.680]  давай девушку плывем, давай.
[01:17:30.680 --> 01:17:32.680]  Вот девушка, идите сюда. Подходит девушка
[01:17:32.680 --> 01:17:34.680]  и говорит, вот скажите, пожалуйста, девушка,
[01:17:34.680 --> 01:17:36.680]  а чему равен
[01:17:36.680 --> 01:17:38.680]  интеграл от х квадрат?
[01:17:40.680 --> 01:17:42.680]  Девушка.
[01:17:42.680 --> 01:17:44.680]  Треть Икс Куб.
[01:17:44.680 --> 01:17:46.680]  Она мне говорит, вау,
[01:17:46.680 --> 01:17:48.680]  ничего себе.
[01:17:48.680 --> 01:17:50.680]  Вот так, да, девушка ставит напитки,
[01:17:50.680 --> 01:17:52.680]  а забыла добавить
[01:17:52.680 --> 01:17:54.680]  плюс константа.
[01:17:58.680 --> 01:18:00.680]  Так, господа, ладно, прежде чем мы двинемся дальше,
[01:18:00.680 --> 01:18:02.680]  я должен упомянуть еще
[01:18:02.680 --> 01:18:04.680]  так, ребят, все, поехали.
[01:18:10.680 --> 01:18:12.680]  Ну, прикол еще раз такой,
[01:18:12.680 --> 01:18:14.680]  я напомню, значит, прикол.
[01:18:14.680 --> 01:18:16.680]  Ну, прикол ее в том,
[01:18:16.680 --> 01:18:18.680]  что у нее, что если вы делаете
[01:18:18.680 --> 01:18:20.680]  модуль какой-нибудь степень двойки
[01:18:20.680 --> 01:18:22.680]  244, то он начинает
[01:18:22.680 --> 01:18:24.680]  с какой-то длины, причем меньше,
[01:18:24.680 --> 01:18:26.680]  какой-то одиннадцатый, тут у этой
[01:18:26.680 --> 01:18:28.680]  строти находится огромное количество подстрока
[01:18:28.680 --> 01:18:30.680]  этой длины с одинаковым хэшом,
[01:18:30.680 --> 01:18:32.680]  то есть с хэшом равным ноль.
[01:18:32.680 --> 01:18:34.680]  Причем парадокс заключается
[01:18:34.680 --> 01:18:36.680]  в том, что этот прикол
[01:18:36.680 --> 01:18:38.680]  работает с абсолютно любым нечетным
[01:18:38.680 --> 01:18:40.680]  основанием хэша,
[01:18:40.680 --> 01:18:42.680]  под не модулем, а основанием.
[01:18:42.680 --> 01:18:44.680]  Ну, то есть я это
[01:18:44.680 --> 01:18:46.680]  говорю как черную магию,
[01:18:46.680 --> 01:18:48.680]  я это не доказываю,
[01:18:48.680 --> 01:18:50.680]  на экзамен естественно тоже не потребую,
[01:18:50.680 --> 01:18:52.680]  но факт такой есть, то есть отсылка
[01:18:52.680 --> 01:18:54.680]  на кодфорсе, вот есть пост на эту
[01:18:54.680 --> 01:18:56.680]  тему, никнейм,
[01:18:56.680 --> 01:18:58.680]  вот так, ну, никнейм, если вы
[01:18:58.680 --> 01:19:00.680]  возможно уже не застали Макса Ахмедова,
[01:19:00.680 --> 01:19:02.680]  ну,
[01:19:02.680 --> 01:19:04.680]  вырос.
[01:19:04.680 --> 01:19:06.680]  Знаете, как часто
[01:19:06.680 --> 01:19:08.680]  бывает, люди там занимаются некоторым
[01:19:08.680 --> 01:19:10.680]  время олимпиадами, а потом там начинают работать, там вырастают
[01:19:10.680 --> 01:19:12.680]  и больше к олимпиадам отношений не имеют.
[01:19:12.680 --> 01:19:14.680]  Такое на самом деле очень часто случается.
[01:19:14.680 --> 01:19:16.680]  Может он просто никнейм?
[01:19:16.680 --> 01:19:18.680]  Ну, потому что в конце концов
[01:19:18.680 --> 01:19:20.680]  вы сталкивались с таким человеком, как Иван
[01:19:20.680 --> 01:19:22.680]  Смирнов, например?
[01:19:22.680 --> 01:19:24.680]  Скорее нет.
[01:19:24.680 --> 01:19:26.680]  А, ну да,
[01:19:26.680 --> 01:19:28.680]  тут с именем не повезло, да.
[01:19:28.680 --> 01:19:30.680]  Нет, я имею ввиду Иван Смирнов, который был еще
[01:19:30.680 --> 01:19:32.680]  моим сокомандником в свое время, там пару
[01:19:32.680 --> 01:19:34.680]  сезонов, там, он
[01:19:34.680 --> 01:19:36.680]  двукратный медалист и CPC от
[01:19:36.680 --> 01:19:38.680]  Фистеха, там золотая и серебряная медаль.
[01:19:38.680 --> 01:19:40.680]  Вот.
[01:19:40.680 --> 01:19:42.680]  То есть вот как бы, казалось бы, со мной участвовал,
[01:19:42.680 --> 01:19:44.680]  но как бы, скорее всего, вы его
[01:19:44.680 --> 01:19:46.680]  не знаете, он в принципе там еще ведет, по-моему,
[01:19:46.680 --> 01:19:48.680]  там семинары,
[01:19:48.680 --> 01:19:50.680]  что-то как бы ему ведет в вышке еще.
[01:19:50.680 --> 01:19:52.680]  Так что в принципе вышка его знает.
[01:19:52.680 --> 01:19:54.680]  Вот. Но это
[01:19:54.680 --> 01:19:56.680]  или там, кого еще вы можете так знать?
[01:19:56.680 --> 01:19:58.680]  А, ну я имею ввиду, что
[01:19:58.680 --> 01:20:00.680]  или, например, там, кого еще
[01:20:00.680 --> 01:20:02.680]  можно было знать, там Саша Голованов,
[01:20:02.680 --> 01:20:04.680]  теперь может там Костя Семенов, или там
[01:20:04.680 --> 01:20:06.680]  или там
[01:20:06.680 --> 01:20:08.680]  Голованов,
[01:20:08.680 --> 01:20:10.680]  ну,
[01:20:10.680 --> 01:20:12.680]  периодически, ну, скажем так, он работает в
[01:20:12.680 --> 01:20:14.680]  МТехе и, собственно, там собралась
[01:20:14.680 --> 01:20:16.680]  такая компашка из Фистеха, на самом деле, ну, в том
[01:20:16.680 --> 01:20:18.680]  числе из Фистеха, там не только Фистехи, но там
[01:20:18.680 --> 01:20:20.680]  наших там много.
[01:20:20.680 --> 01:20:22.680]  И, значит, они там периодически
[01:20:22.680 --> 01:20:24.680]  делают раунды. То есть МТех,
[01:20:24.680 --> 01:20:26.680]  сейчас они Пайнели называются, там и так
[01:20:26.680 --> 01:20:28.680]  далее. Иван Смирнов, случайно, не вот этот?
[01:20:28.680 --> 01:20:30.680]  Нет.
[01:20:30.680 --> 01:20:32.680]  Голованов почти всегда только один инкутренер.
[01:20:32.680 --> 01:20:34.680]  Ну, нормально.
[01:20:34.680 --> 01:20:36.680]  Иван Смирнов, семинарист по
[01:20:36.680 --> 01:20:38.680]  Матлогову.
[01:20:38.680 --> 01:20:40.680]  Это так, скорее всего,
[01:20:40.680 --> 01:20:42.680]  ну, рискну предположить, что это другой
[01:20:42.680 --> 01:20:44.680]  Иван Смирнов. Нет, или там
[01:20:44.680 --> 01:20:46.680]  скорее всего знаком...
[01:20:46.680 --> 01:20:50.680]  Иван Смирнов,
[01:20:50.680 --> 01:20:52.680]  нет, то Иван Смирнов, нет, в данном случае
[01:20:52.680 --> 01:20:54.680]  четкое совпадение. Да, потому что нет, можно тогда
[01:20:54.680 --> 01:20:56.680]  по-другому, хорошо. Ладно, потому что там
[01:20:56.680 --> 01:20:58.680]  парадокс такое. Знаете ли вы такого человека, как Владислав
[01:20:58.680 --> 01:21:00.680]  Епифанов? Нет, Владислав Епифанов тоже эпическое
[01:21:00.680 --> 01:21:02.680]  совпадение, конечно, есть.
[01:21:02.680 --> 01:21:04.680]  Потому что есть Владислав Епифанов, просто вот мой
[01:21:04.680 --> 01:21:06.680]  ровесник, после одной вот
[01:21:06.680 --> 01:21:08.680]  треххратной призер Мишнара.
[01:21:08.680 --> 01:21:10.680]  Вот, то есть мой
[01:21:10.680 --> 01:21:12.680]  ровесник. Есть там Владислав Епифанов, какой-то более
[01:21:12.680 --> 01:21:14.680]  молодой, из Питера, потому что тот-то из Нижнего Новгорода.
[01:21:14.680 --> 01:21:16.680]  Вы его, возможно, знаете, потому что тот Владислав Епифанов
[01:21:16.680 --> 01:21:18.680]  ездит как тренер из Нижнего Новгорода.
[01:21:18.680 --> 01:21:20.680]  Короче, у нас опять вот тема
[01:21:20.680 --> 01:21:22.680]  лекции. Коллизия. Да.
[01:21:22.680 --> 01:21:24.680]  Ладно.
[01:21:24.680 --> 01:21:26.680]  Я уже писал чат про Александра
[01:21:26.680 --> 01:21:28.680]  Некрасова-Павловича. Да, да, да.
[01:21:28.680 --> 01:21:30.680]  Да. Ладно.
[01:21:30.680 --> 01:21:32.680]  Значит, хорошо.
[01:21:32.680 --> 01:21:34.680]  Тут мы про Коллизию поговорили, с Лобобером упомянули,
[01:21:34.680 --> 01:21:36.680]  ладно, пойдемте дальше.
[01:21:36.680 --> 01:21:38.680]  Но на самом деле с хэшами есть еще один поиск
[01:21:38.680 --> 01:21:40.680]  под строк-строки. Можно просто хэши проверять,
[01:21:40.680 --> 01:21:42.680]  но есть как бы... Но на самом деле тут по-разному
[01:21:42.680 --> 01:21:44.680]  можно проверять. Потому что наш алгоритм
[01:21:44.680 --> 01:21:46.680]  обычно подразумевает, что если хэши совпали,
[01:21:46.680 --> 01:21:48.680]  то мы свято верим, что и строки совпали.
[01:21:48.680 --> 01:21:50.680]  Потому что мы считаем, что вероятность того,
[01:21:50.680 --> 01:21:52.680]  что хэши совпали, а строки нет, крайне
[01:21:52.680 --> 01:21:54.680]  мала.
[01:21:54.680 --> 01:21:56.680]  Вот.
[01:21:56.680 --> 01:21:58.680]  Соответственно. Но есть
[01:21:58.680 --> 01:22:00.680]  более точный алгоритм, который
[01:22:00.680 --> 01:22:02.680]  говорит о том, что если Коллизия произошла,
[01:22:02.680 --> 01:22:04.680]  то есть там, например, если хэши совпали,
[01:22:04.680 --> 01:22:06.680]  то давайте в тупую проверим.
[01:22:06.680 --> 01:22:08.680]  Вот.
[01:22:08.680 --> 01:22:10.680]  И тут, в принципе, получается достаточно
[01:22:10.680 --> 01:22:12.680]  интересно.
[01:22:12.680 --> 01:22:14.680]  Потому что на самом деле, если предположить, что для
[01:22:14.680 --> 01:22:16.680]  двух различных строк у нас вероятность Коллизии
[01:22:16.680 --> 01:22:18.680]  равна 1 делить на q,
[01:22:18.680 --> 01:22:20.680]  то тогда... Ну, вы уже знакомы
[01:22:20.680 --> 01:22:22.680]  с понятием математическое ожидание, да?
[01:22:22.680 --> 01:22:24.680]  Знакомы?
[01:22:24.680 --> 01:22:26.680]  Ну, нам его на дискране обвели,
[01:22:26.680 --> 01:22:28.680]  а на ВИКМе нет.
[01:22:28.680 --> 01:22:30.680]  А...
[01:22:30.680 --> 01:22:32.680]  Да, даже еще не ввели?
[01:22:32.680 --> 01:22:34.680]  Какое безобразие. Ну, ладно.
[01:22:34.680 --> 01:22:36.680]  Ну, хорошо, ладно. Нет, ну, на дискране
[01:22:36.680 --> 01:22:38.680]  нам ввели в дозажском уровне. Ну, на дискране.
[01:22:38.680 --> 01:22:40.680]  Чтобы мы и так его... На продвинутом ВИКМе
[01:22:40.680 --> 01:22:42.680]  не ввели, на основном уже ввели давно.
[01:22:42.680 --> 01:22:44.680]  А, ну, короче, на продвинутом нет. Понятно.
[01:22:44.680 --> 01:22:46.680]  Хорошо. Вот.
[01:22:46.680 --> 01:22:48.680]  Ну,
[01:22:48.680 --> 01:22:50.680]  отлично. Молодцы.
[01:22:50.680 --> 01:22:52.680]  Вот.
[01:22:52.680 --> 01:22:54.680]  Ну, почему? Ну, логично, да.
[01:22:54.680 --> 01:22:56.680]  Ну, вот. Ну, и тогда получается, действительно, просто маленькая
[01:22:56.680 --> 01:22:58.680]  простая вещь, что тогда у нас в среднем
[01:22:58.680 --> 01:23:00.680]  это будет работать за, получается, сколько.
[01:23:00.680 --> 01:23:02.680]  Вот.
[01:23:02.680 --> 01:23:04.680]  Но тогда получается, что...
[01:23:04.680 --> 01:23:06.680]  Значит, у нас... Мы
[01:23:06.680 --> 01:23:08.680]  тогда получается... Работаем за О
[01:23:08.680 --> 01:23:10.680]  от П, плюс С, плюс работа с коллизиями.
[01:23:10.680 --> 01:23:12.680]  А сколько у нас будет вообще коллизий?
[01:23:12.680 --> 01:23:14.680]  Но тогда получается... То есть, каждую коллизию мы обрабатываем
[01:23:14.680 --> 01:23:16.680]  за О от П, но коллизию у нас
[01:23:16.680 --> 01:23:18.680]  бывает... Ну, даже не коллизия, если
[01:23:18.680 --> 01:23:20.680]  честно совпало из троки, а
[01:23:20.680 --> 01:23:22.680]  бывает, когда они не совпали, но тогда их
[01:23:22.680 --> 01:23:24.680]  бывает в среднем, модул С
[01:23:24.680 --> 01:23:26.680]  поделить на К получается.
[01:23:26.680 --> 01:23:31.540]  Условно говоря, каждая кутая подстрока, видимо, в среднем
[01:23:31.540 --> 01:23:33.140]  совпадет просто потому, что повезет.
[01:23:33.140 --> 01:23:38.540]  А мне повезет вот это вот.
[01:23:38.540 --> 01:23:42.140]  Так что в принципе тоже на практике могут часто
[01:23:42.140 --> 01:23:44.620]  это использовать, тем более, что на самом деле асимпточка
[01:23:44.620 --> 01:23:47.820]  еще может где-то не совсем точно, потому что там часто
[01:23:47.820 --> 01:23:51.020]  еще будет бывает, что если хэши совпали, строки не
[01:23:51.020 --> 01:23:53.260]  совпали от слова совсем, поэтому и вы это поймете
[01:23:53.260 --> 01:23:55.780]  там за несколько первых символов на самом деле.
[01:23:56.160 --> 01:23:59.240]  Но это если брать на реальной практике, то есть на реальной
[01:23:59.240 --> 01:24:01.560]  практике, где никто там вам специальные контртесты
[01:24:01.560 --> 01:24:02.440]  придумывать не будет.
[01:24:06.000 --> 01:24:08.720]  Более того, на самом деле это анонс, видимо, уже на
[01:24:08.720 --> 01:24:09.760]  следующее занятие.
[01:24:10.960 --> 01:24:14.000]  Есть вообще совершенно эпический алгоритм, который
[01:24:14.000 --> 01:24:16.720]  будет искать подстроку строкеза от единицы дополнительной
[01:24:16.720 --> 01:24:17.120]  памяти.
[01:24:20.160 --> 01:24:22.960]  По умолчанию, без хэшей.
[01:24:23.580 --> 01:24:24.860]  Хэши сами тратят дополнительную память.
[01:24:25.540 --> 01:24:27.580]  Да, ну во-первых хэши сами тратят дополнительную память.
[01:24:29.580 --> 01:24:30.380]  Нет, чего?
[01:24:32.100 --> 01:24:34.740]  А потому что в этом алгоритме хэшей нет.
[01:24:37.060 --> 01:24:37.820]  И рандома нет.
[01:24:38.140 --> 01:24:38.540]  Нет.
[01:24:42.140 --> 01:24:44.340]  Ну потому что у нас нет официального понятия слова
[01:24:44.340 --> 01:24:47.540]  честно, потому что кто сказал, что хэши не честно?
[01:24:50.260 --> 01:24:52.860]  Мы же честно говорим, что бывает, что иногда нам может
[01:24:52.860 --> 01:24:56.200]  не повезти, но мы верим, что это не в нашей жизни.
[01:24:57.640 --> 01:25:00.600]  Ну для этого есть слово детерминированное.
[01:25:01.960 --> 01:25:02.920]  Ну хорошо, хорошо.
[01:25:02.920 --> 01:25:06.000]  Нет, не детерминированный алгоритм абсолютно, ты не
[01:25:06.000 --> 01:25:06.360]  путай.
[01:25:08.000 --> 01:25:11.200]  Да, но правда нам с хэшами может не повезти.
[01:25:11.200 --> 01:25:13.440]  Да, у нас все детерминированный, но это все еще.
[01:25:13.440 --> 01:25:15.640]  Так, ладно, давайте сейчас это все стоп-занудство,
[01:25:15.640 --> 01:25:18.280]  ребят, давайте это, такая формализм, потому что в
[01:25:18.280 --> 01:25:19.960]  данном случае суть, думаю, понятна, в данном случае
[01:25:19.960 --> 01:25:21.120]  действительно имеет в виду, что это абсолютно
[01:25:21.120 --> 01:25:23.540]  детерминированный алгоритм, nightmares...
[01:25:25.120 --> 01:25:28.120]  То есть не использующий, тогда у тебя нигде.
[01:25:28.120 --> 01:25:31.620]  Так, ребят, так, так ребят, я понимаю, что интересно
[01:25:31.620 --> 01:25:33.240]  беседа, давайте меня перебивать не будем, да.
[01:25:33.980 --> 01:25:36.420]  Ну вот, то есть понятно, что данной случае имеет в
[01:25:36.420 --> 01:25:38.520]  виду абсолютно детерминированный алгоритм не использующий
[01:25:38.520 --> 01:25:41.380]  никакихistle, никаких вероятостей, никаких хэшей, ничего
[01:25:41.380 --> 01:25:44.600]  такого, Thanksgiving, и еще он использовuelт от единицы
[01:25:44.600 --> 01:25:46.920]  дополнительной памяти破чать как horizon.
[01:25:47.660 --> 01:25:49.820]  То есть это да, в какой-тоyer aposthhferntulu�, буквально недавно
[01:25:49.820 --> 01:25:54.580]  в одном из там, буквально два поколения назад он у нас появился, и, собственно, оказалось, что очень полезно
[01:25:54.580 --> 01:25:58.380]  говорить, потому что попутно мы еще очень много вообще интересного про строки узнаем, на самом деле.
[01:25:58.380 --> 01:26:04.940]  Про всякие строки, про их периодичность, так что не пропустите, так что это называется реклама, не пропустите
[01:26:04.940 --> 01:26:05.940]  следующее занятие.
[01:26:05.940 --> 01:26:18.700]  На практике, ну, нет, я бы сказал, что к счастью, конечно, бегают хэшами, потому что редко бывает,
[01:26:18.700 --> 01:26:21.140]  что надо прям вот под строку прям вот в строке искать.
[01:26:21.140 --> 01:26:28.260]  Нет, потому что чаще бывает, что там что-нибудь быстрое надо найти, обычно, до нас строка,
[01:26:28.260 --> 01:26:29.740]  найди ее по базе, там, я не знаю.
[01:26:29.740 --> 01:26:37.700]  Ну, в какой-нибудь редакторе, скорее всего, вам там надо, то есть, ну, обычно, если у вас там поиск
[01:26:37.700 --> 01:26:42.180]  какой-нибудь файла, то вы там, наверное, то есть, обычно надо пробежаться по компьютеру, что-то
[01:26:42.180 --> 01:26:43.180]  найти.
[01:26:43.180 --> 01:26:47.940]  Ну, или там, например, или там какой-нибудь поисковик, например, да, то есть, как вот, например,
[01:26:47.940 --> 01:26:52.900]  как вот написать поисковик по Библии, да, вы знаете, это легенда основания Яндекса, да, то есть,
[01:26:52.900 --> 01:26:57.300]  легенда говорит о том, что просто Яндекс начался с того, что просто к молодым программистам просто
[01:26:57.300 --> 01:27:03.340]  пришли представители церкви и попросили написать поисковик по Библии там в 96-м, но там просто, ну,
[01:27:03.340 --> 01:27:07.100]  фишка была, ну, нет, просто, нет, фишка была абсолютно естественная, то есть, как бы священники
[01:27:07.100 --> 01:27:11.420]  хотели просто действительно подкреплять свои слова действительно конкретными цитатами из Библии,
[01:27:11.900 --> 01:27:16.460]  но часто бывало, что они там действительно примерно помнят, но очень сложно там вот найти, поэтому
[01:27:16.460 --> 01:27:22.620]  вот очень хочется, собственно, так сказать, найти, то есть, да, Гугла тогда не было более того,
[01:27:22.620 --> 01:27:28.460]  утверждается, что вот российская версия Гугла вот с этого и началась, потому что, в принципе, ну,
[01:27:28.460 --> 01:27:32.620]  просто в те времена, как бы интернет был такой маленький, что он, в принципе, там все, что
[01:27:32.620 --> 01:27:36.500]  хранилось в интернете на самом деле могло поместиться просто в одном процессоре у вас под столом,
[01:27:36.500 --> 01:27:40.800]  то есть, тогда немного всего было, то естьorm now, of course, it's already impossible,
[01:27:40.800 --> 01:27:43.780]  уже невозможно, в те времена, как бы все было сильное, это сильно меньше,
[01:27:43.780 --> 01:27:49.980]  сильно медленнее, то есть, да, динозавры по улицам уже не бегали, но, тем не менее,
[01:27:49.980 --> 01:27:55.060]  да, вот, но все временные мобильники, в общем-то, тогда только появлялись, если что,
[01:27:55.060 --> 01:27:59.580]  то есть, вот знаете, все эти вот времена, времена были, так что вот легенда говорит,
[01:27:59.580 --> 01:28:04.040]  шо вот яндекс с этого и начался, но вот, причем, более того, как они это сделали,
[01:28:04.040 --> 01:28:09.480]  то есть они просто значит понятно действительно вбили всю библию значит взяли там конкретные может
[01:28:09.480 --> 01:28:16.240]  быть там конкретные слова где-то и вот и там допустим для каждого для каждого слова там записали
[01:28:16.240 --> 01:28:24.960]  где оно встречается вот то есть это иду примерно вот это назвали индекс вот ну собственно примерно
[01:28:24.960 --> 01:28:29.120]  кстати название яндахс примерно тоже из этой логики и возникло где-то то есть я не помню как
[01:28:29.120 --> 01:28:35.980]  конкретно они там из индекса сделал яндекс но вот судьба примерно такая вот поэтому исходя уже то
[01:28:35.980 --> 01:28:43.100]  есть уже proced bathing но вот то есть поб佐 formulation более того ведьau pesco
[01:28:43.100 --> 01:28:45.160]  век яндекс работает до сих пор то есть потому что по большому счету супер чем примерно такаяаша то есть
[01:28:45.160 --> 01:28:49.620]  у них то есть действительно есть интернет то есть есть такой паук яндекс которые там периодически
[01:28:49.620 --> 01:28:54.880]  там qualité ходить по интернету и сохранять себе какие-то странички с него ну вот и соответственно
[01:28:54.880 --> 01:29:01.120]  потом идти там то есть найденное значит вот как-то обрабатывается это вы в этот индекс наносит
[01:29:01.120 --> 01:29:06.760]  к индекс естественно уже не в одной компе хранится в большом кластере эти классы но вот и там в кластере
[01:29:06.760 --> 01:29:11.400]  там хранятся какие-то слова по как раз тем самым хэшам то есть вычислим хэши поэтому хэшу там
[01:29:11.400 --> 01:29:17.280]  поймем на каком в каком процессоре он лежит вот то есть ну там основа но основные вот там
[01:29:17.280 --> 01:29:27.960]  в общей детали то есть вот то есть как бы основная база вот вот такая вот так соответственно так
[01:29:27.960 --> 01:29:38.320]  что же у нас будет дальше ну что ж пришло время начать говорить о полиндромах вот но начнем мы
[01:29:38.320 --> 01:29:48.360]  конечно не с дерева полиндромов а вот а с кое-чего более интересного это более простого ну а первых
[01:29:48.360 --> 01:29:55.280]  начнем давайте давайте скажем что такое вообще полиндром ну вот ну во первых научимся введем
[01:29:55.280 --> 01:30:00.760]  операцию как бы с с верхним индексом это типа разворот строки то есть записываем теперь символы
[01:30:00.760 --> 01:30:06.080]  в обратном порядке ну и будем говорить что строка называется полиндромом если строка равна своей
[01:30:06.080 --> 01:30:13.960]  развернутой версии пока вроде логично ну и задача поиски полиндромов может быть такая смотрите то
[01:30:13.960 --> 01:30:18.880]  есть можно сфагулировать так давайте в некотором смысле найдем все пары чисел и жи такая что
[01:30:18.880 --> 01:30:26.680]  подстрока с и по жи является полиндромом ну формально конечно скажете что быстрее чем за квадрат
[01:30:26.680 --> 01:30:30.560]  такую задачу решить нельзя почему потому что размер ответа может быть в таком виде квадрат
[01:30:31.200 --> 01:30:37.400]  но с другой стороны мы можем заметить маленькую и приятную вещь что если какая-то подстрока
[01:30:37.400 --> 01:30:43.580]  является полиндромом то любая подстрока с тем же центром тоже является полиндромом правда
[01:30:43.580 --> 01:30:49.480]  правда что такое центр под строки ну если для нас трак по цы drinks четные длины то центр это
[01:30:49.480 --> 01:30:55.660]  один символ а если подстро fifty по цык отчетное то центр это какая-то позиция между двумя символами
[01:30:55.660 --> 01:31:03.280]  ну это уже это уже техническая деталь там по разному бывает да то есть мы мы в какой-то
[01:31:03.280 --> 01:31:08.480]  момент при примере применим и этот лайфхак но как бы пока но идейно мы понимаем что у каждой
[01:31:08.480 --> 01:31:15.340]  подстроки из центра он как бы либо символ либо что-то между ними вот это вот и тогда идея такая
[01:31:15.340 --> 01:31:20.940]  что если она то есть тогда получается для каждого центра можно найти так называемый размах крыла
[01:31:20.940 --> 01:31:26.620]  то есть максимальная подстрока с таким центром который является полиндрома то есть как ее найти
[01:31:26.620 --> 01:31:31.940]  очень просто давайте начиная с этого центра будем идти влево и вправо на один символ на два символа
[01:31:31.940 --> 01:31:37.980]  на три символа до тех пор пока эти символы совпадают понятно да то есть пока это естественно в
[01:31:37.980 --> 01:31:45.000]  тупую работает за квадрат ну или пока или или по факту за общие то есть на самом деле за
[01:31:45.000 --> 01:31:55.560]  общее число под полиндромов строке на самом деле вот но но но но но на самом деле но заметим что
[01:31:55.560 --> 01:32:01.800]  для хранения этой информации нам уже нужно всего отн памяти правда и тогда если и тогда мы после
[01:32:01.800 --> 01:32:06.200]  этой отн памяти можем уже отвечать на запросы вида вот там спросит является ли подстрока с
[01:32:06.200 --> 01:32:12.160]  лп лр полиндромом тогда мы просто берем центр берем размах крыла и проверяем это крыло рот
[01:32:12.160 --> 01:32:18.560]  дотягивается да или если да то значит полиндром если нет нет так это идея понятна это идея
[01:32:18.560 --> 01:32:28.560]  понятна отлично но раз уж мы храним отн памяти то наверное хотелось бы и работать побыстрее как
[01:32:28.560 --> 01:32:35.880]  же это сделать но мы значит но но формализуем что мы хотим искать мы хотим искать массивы пал
[01:32:36.480 --> 01:32:49.640]  и пал зелен так видно да это вы там контесты ведете лишь вы делаете если там что-то делаете
[01:32:49.640 --> 01:32:53.520]  давайте лучше уберем а то знаете очень сложно рассказывать людям которые там что-то параллельно
[01:32:53.520 --> 01:32:59.080]  делают активный ходит просто как бы если у вас там сейчас так это занятие надо это делать то как
[01:32:59.080 --> 01:33:06.880]  бы зачем вы сюда пришли вообще давайте так что давайте убираем ноутбуки так что давайте закрывать
[01:33:06.880 --> 01:33:12.960]  так что закрываем ноутбуки закрываем давайте так что закрываем или просто идем с этими
[01:33:12.960 --> 01:33:17.360]  ноутбуками как и в более удобное место где нету какого-то этого заварливого лектора который
[01:33:17.360 --> 01:33:23.720]  вам там уши еще какую-то информацию пытается донести вот и так значит пытаемся делать пал
[01:33:23.880 --> 01:33:33.240]  и пал и значит соответственно вот но в принципе то есть так как у нас пустая строка действительно
[01:33:33.240 --> 01:33:38.120]  является полиндромом тогда как минимум можно сделать вывод что массивы корректно
[01:33:38.120 --> 01:33:45.480]  определены хаха но в принципе так понятно да и хочется задача на заключается в том чтобы
[01:33:45.480 --> 01:33:53.680]  эти массивы как-то за уатес найти как же это сделать ну на самом деле миша уже предложил как
[01:33:53.680 --> 01:34:00.920]  по крайней мере как бы уменьшить себе интуитивно работу в два раза то есть давайте вставим между
[01:34:00.920 --> 01:34:10.880]  любыми двумя символами диезики тогда можно заметить мистическую формулу
[01:34:10.880 --> 01:34:21.280]  ну как бы понятно что она означает идеи на идеи она означает что как бы все то есть по сути
[01:34:21.280 --> 01:34:27.520]  теперь четные палиндромы как бы получается увеличились где-то в два раза и превратились
[01:34:27.520 --> 01:34:32.160]  в нечетные палиндромы с центром диезики они четные палиндромы тоже увеличились примерно в
[01:34:32.160 --> 01:34:39.480]  два раза но центры у них остались символах своих да и в принципе я то есть формулы это просто как
[01:34:39.480 --> 01:34:46.200]  точным образом восстановить на самом деле четные нечетные палиндромы строки с по только лишь
[01:34:46.200 --> 01:34:53.120]  нечетным палиндромом вот этой строки вот этой вот диезнутой строки с во хорошее название
[01:34:54.120 --> 01:35:02.520]  вот и таким образом получается мы свели задачу к поиску исключительно пал от но на самом деле
[01:35:02.520 --> 01:35:07.280]  если вам нужно поэкономить память то часто конечно бывает что пал от и пал ивер просто делаются
[01:35:07.280 --> 01:35:15.080]  одинаковым кодом там просто в одном месте плюс-минус и денечка и так свели задачу к пал от то есть
[01:35:15.080 --> 01:35:22.680]  ищем только нечетные палиндромы как же у нас ну как бы больше памяти вроде а ну только на
[01:35:22.680 --> 01:35:34.360]  саму строку да ну ну то есть можно как всегда конечно мысли в принципе да да да да так вот
[01:35:34.360 --> 01:35:43.920]  значит смотреть что же у нас теперь с пал отдами получается пал отдами получается следующее вот
[01:35:43.920 --> 01:35:52.560]  но здесь опять написано какой-то мистический текст и давайте как всегда напишем в нем кое-что
[01:35:52.560 --> 01:36:02.040]  еще то есть давайте разберемся что он значит вот но картинка практически та же на самом деле сейчас
[01:36:02.040 --> 01:36:14.920]  вот ее сотру чтобы нарисовать заново с лобобером и тоже убираем вот так
[01:36:14.920 --> 01:36:28.840]  значит смотреть вот и так получается примерно следующим вот жила была то есть он говорит
[01:36:28.840 --> 01:36:38.640]  так жила была строка с дам и мы говорим пусть у нас в какой-то и ты позиции обнаружился палиндром
[01:36:39.640 --> 01:36:54.960]  да ну можно и так мысли дам и теперь вот идея такая давайте рассмотрим какую-нибудь позицию вот
[01:36:54.960 --> 01:37:06.480]  какую-нибудь вот эту и плюс сель где л меньше к мы очень хотим но тогда вот идея такая вот есть
[01:37:06.520 --> 01:37:11.120]  как бы позиция вот это и плюс сель есть как бы в принципе симметричная ей позиция и минус
[01:37:11.120 --> 01:37:19.160]  вот и лема говорит примерно следующее что пусть у нас есть пал полиндромность здесь и выяснилось
[01:37:19.160 --> 01:37:28.920]  что размах крыла здесь не доходит вот до этой границы к тогда оказывается что в общем тогда
[01:37:28.920 --> 01:37:32.640]  утверждается что просто в этом смысле полиндромный здесь та же что полиндромный здесь
[01:37:36.560 --> 01:37:44.080]  в такой формулировке в общем-то очевидно правда ну потому что как бы заметим что здесь все то
[01:37:44.080 --> 01:37:48.640]  же самое что здесь только развернутая правда то есть палиндробности то есть палиндробности
[01:37:48.640 --> 01:37:57.840]  будут одинаковые если вы и минус л поля вот эти крылышки нет строго не дотягиваются досюда то
[01:37:57.840 --> 01:38:03.840]  есть формально это называется то есть вот эта вот штука меньше чем к-л строго меньше
[01:38:03.840 --> 01:38:13.120]  вот она вот такая п тогда оказывается что в этом случае тогда она просто оказывается буквально
[01:38:13.120 --> 01:38:21.600]  такой же но естественно если крылышки здесь дотягиваются до к-л или дальше то есть здесь
[01:38:21.600 --> 01:38:27.160]  тогда крылышки дотягиваются хотя бы то к-л и это позволяет нам пал отды искать буквально тем
[01:38:27.160 --> 01:38:34.040]  же методом что и в z функции то есть вы как бы храните крылышки которые то есть как бы всех
[01:38:34.040 --> 01:38:38.640]  посчитанных крылышек вы храните те которые справа дотягиваются как можно дальше и когда
[01:38:38.640 --> 01:38:43.680]  доходите до черного символа вот вы говорите так какие у нас крылышки по симметрии так если они
[01:38:43.680 --> 01:38:50.240]  дотягиваются досюда значит пишем что тут хотя бы к-л и дальше насчитываем в тупую а если не
[01:38:50.240 --> 01:39:01.640]  дотягиваться значит копипастим то что есть и идем дальше вот так что вот такая вот достаточно
[01:39:01.640 --> 01:39:06.240]  такая классическая идея то есть в общем-то то есть как бы да если вы с этим не сталкивались можно
[01:39:06.240 --> 01:39:11.320]  на самом деле за функцию тут не придумать нет на самом деле самое смешное что у меня с этим
[01:39:11.320 --> 01:39:19.920]  тоже был эпический прецедент потому что давным-давно когда я был в 10 классе далее там на на
[01:39:20.260 --> 01:39:25.880]  тогда это называется на заочной олимпиаде которой сейчас называется открыты на такие назад каждый
[01:39:25.880 --> 01:39:31.200]  завала ставочный этап открытой олимпиады тогда далее веселую задачу до на строк Piece но тысяч
[01:39:31.200 --> 01:39:41.760]  найдите максимальные длины под строку которое является полиндромом чего найдите м settlers
[01:39:41.760 --> 01:39:46.240]  максимальный длины под строку продолжается полиндрома почему это не является халявой
[01:39:46.240 --> 01:39:52.520]  потому что тогда ну лично я тогда вот этого алгоритма не знал он тогда он тогда еще популярным
[01:39:52.520 --> 01:40:04.040]  являлся хеши написать хеши ой ну с хешами у меня отдельная история поэтому вот знаете вы знаете я
[01:40:04.040 --> 01:40:08.960]  даже в этом месте потрачу время и расскажу вам что что я написал почему я скажу потому что это
[01:40:08.960 --> 01:40:14.080]  тоже будет полезно потому что в будущем это тоже нам пригодится может даже и сегодня так вот на
[01:40:14.080 --> 01:40:19.720]  самом деле я этого не знал то есть я потом то как то есть я написал следующий так смотрите давайте
[01:40:19.720 --> 01:40:26.720]  сделаем разделяем властвой ну то есть ну как бы чтобы как бы рассмотрим строку с так вот задачи
[01:40:26.720 --> 01:40:32.320]  еще раз найти максимальной длины под строку которая является полиндромом но если длины найти ее
[01:40:32.320 --> 01:40:43.360]  длину только надо ну там так вот но идея такая давайте распилим строку пополам тогда надо
[01:40:43.360 --> 01:40:50.720]  найти ответ слева найти справа и через храницу ну понятно слева справа запустились рекурсивно
[01:40:50.720 --> 01:40:56.120]  если мы сейчас научимся искать через храницу за линию то получится суммарно н лог и неправда
[01:40:56.120 --> 01:41:03.520]  хэши я говорю а теперь но а теперь представьте себе что я не знаю что такое хэши ну ладно я
[01:41:03.520 --> 01:41:07.520]  знаю что такое хэши но я честно говоря до какого-то второго третьего курса ими по каким-то вот своим
[01:41:07.520 --> 01:41:13.200]  внутренним причинам не пользовался вот то есть я по я помню я им у меня был такое сначала им не
[01:41:13.200 --> 01:41:16.920]  пользовался потом где-то на втором курсе я столкнулся с задачей которые без хэшей не сдавалась
[01:41:16.920 --> 01:41:25.440]  принципиально и потом так обрадовался что начал эти хэши сдавать везде вот кончилась кончилась
[01:41:25.440 --> 01:41:30.880]  но да но потом кончилась это тем когда на одном контесте я написал хэши бин поиск за н логен
[01:41:30.880 --> 01:41:45.800]  и получил тл там вздохнул написал префикс функцию за линию получил окей не знаю но тогда нет я бы
[01:41:45.800 --> 01:41:52.040]  не сказал что мне в конце хэши прям фигня этого это нот это не так было но то есть это не так то
[01:41:52.040 --> 01:41:56.680]  есть теперь как бы то есть я как бы хэши для меня это тоже метод но вот но как бы условно говоря там
[01:41:56.680 --> 01:42:03.080]  поклонение тому что там тот хэши это наше все и там за это хэши это полная шляпа нет у меня ни того
[01:42:03.080 --> 01:42:13.640]  ни другого уже нет так что скорее вот так вот да да если не хочешь становиться не знаю победам
[01:42:13.680 --> 01:42:22.160]  но нет в наши времена это по-другому было я же я уже вам рассказывал мемас про то что задача вида
[01:42:22.160 --> 01:42:26.520]  дан массив на 100 тысячи сделать 100 тысяч за 100 тысяч реверсов и выведи ответ тогда никто не
[01:42:26.520 --> 01:42:34.680]  решил вот сборы на межах 2008 года это задача одна из четырех на контесте ее сдали только на 35
[01:42:34.680 --> 01:42:45.880]  баллов за квадратичные решения да это сейчас сейчас это даже сейчас это как называется да но
[01:42:45.880 --> 01:42:51.280]  тогда это да тогда это был уже приходило то есть потом я уже это преподаватели там пришли и сказали
[01:42:51.280 --> 01:42:55.320]  что ребят ну байси пи си это как бы такие задачи на завтра кушают потому что понятно что в дикарте
[01:42:55.320 --> 01:43:06.680]  это легко делается вот но вот ну вот да хотя ну вот так что соответственно вот но это ну знаете
[01:43:06.680 --> 01:43:13.600]  как я говорю вот вы вот почувствуете насколько за это сейчас уровень продвинулся по сравнению с
[01:43:13.600 --> 01:43:24.060]  2008 так что да да да да да да так что вот а вот значит смотрите это еще кто-то плод так вот
[01:43:24.060 --> 01:43:30.400]  значит как я но это значит поэтому так вот я тут хэши не делал так что же я сделал а я говорю так
[01:43:30.400 --> 01:43:38.360]  но у меня бывают два случая нет я сказал без ограничений обществе центр справа вот у меня
[01:43:38.360 --> 01:43:44.600]  будет справа ну слева естественно аналогично так вот ребят тихо тихо тихо значит смотрите тогда
[01:43:44.600 --> 01:43:54.520]  я думаю так говорю я так значит у меня центр где-то из центр допустим где-то справа да тогда
[01:43:54.520 --> 01:44:05.360]  смотрите что у меня происходит тогда вот у меня префикс этой строке с1 и с2 нет нет вообще нет но
[01:44:05.360 --> 01:44:10.040]  хотя в цит функция сейчас тоже будет потому что смотрите то есть у меня значит тут получается
[01:44:10.040 --> 01:44:17.120]  префикс полиндром и вот эта строчка равна вот этой вот развернутой строки да так ну теперь первая
[01:44:17.120 --> 01:44:24.040]  задача как давайте для начала найдем так найдем все префиксы этой строки который является полиндромы
[01:44:24.040 --> 01:44:31.960]  такой за такая задача там когда-то давалось в группе б на зачете в лкш все префиксы строки заданной
[01:44:31.960 --> 01:44:35.720]  строки которые для с полиндромом но обычно задача называется там про приведение петь там либо
[01:44:35.720 --> 01:44:42.240]  приведение петь либо она еще бывает иногда называется носки вот известная такая думаю сталкивались
[01:44:42.240 --> 01:44:51.040]  такой задачи да но мы сейчас а как вы решаете вы не знаете не хеши ничего нет ну если ну ничего
[01:44:51.040 --> 01:44:57.840]  они нет префиксы за эту функцию я прекрасно знал и сейчас мне понадобится обе а префикс функции
[01:44:58.400 --> 01:45:04.280]  и так вот задача другая задача дан да на строка т найдите все ее префиксы которые являются
[01:45:04.280 --> 01:45:14.080]  полиндромом это значит делят делается так берем строку т добавляем диезик добавляем строку т но
[01:45:14.080 --> 01:45:19.680]  развернутая тогда утверждается что вам теперь нужно найти все префиксы которые совпадают
[01:45:19.680 --> 01:45:26.640]  супиксы как это сделает стандартная задача вида посчитай префикс функцию и вот от этой позиции
[01:45:26.660 --> 01:45:38.240]  бери там пятно все паят конец пет пет конец пет веопед Qin's и так далее кому как от23 но
[01:45:38.240 --> 01:45:43.360]  нет нет почему но дляظать функции тебе ну как исполнится за функции убедиться что полиндром
[01:45:43.360 --> 01:45:51.740]  этот полиндром я сказал так то есть можно да то есть но да то есть как то Kara- aim
[01:45:51.740 --> 01:45:58.940]  Смотрите, давайте, префикс-функция это значит, то есть как бы педлины, педлины, педлины и так далее, это в точности они.
[01:45:58.940 --> 01:46:00.940]  Как проверить z-функцию?
[01:46:00.940 --> 01:46:02.940]  Да, то есть префикс-функция делается так.
[01:46:02.940 --> 01:46:04.940]  Как делается z-функция?
[01:46:04.940 --> 01:46:06.940]  Как проверить, что суффикс совпадает с префиксом?
[01:46:06.940 --> 01:46:10.940]  Очень просто взять z-функцию в начале и проверить, что она дотягивается до конца.
[01:46:10.940 --> 01:46:12.940]  То есть можно и так, и так.
[01:46:12.940 --> 01:46:14.940]  То есть я в данном случае за то, чтобы уметь это делать и тем, и другим способом.
[01:46:14.940 --> 01:46:18.940]  То есть про все там вот эти простенькие задачи, на самом деле рекомендую подумать,
[01:46:19.140 --> 01:46:24.140]  можно ли решить с помощью только префикс-функции, только z-функции или только хэшей.
[01:46:24.140 --> 01:46:30.140]  Все, что решается с помощью хотя бы одной из этих функций, решается второй, как минимум.
[01:46:30.140 --> 01:46:35.140]  Да, но это как бы то же самое, что как бы гвоздь можно забить молотком, а можно забить головой.
[01:46:35.140 --> 01:46:37.140]  Но как бы это не оно вот.
[01:46:37.140 --> 01:46:43.140]  Ну вот, то есть просто как бы молоток просто где-то, ну вот, так что соответственно.
[01:46:43.140 --> 01:46:48.140]  Но с другой стороны там всякие, если вы складываете все столбиком, можно писать на бумаге, а можно писать на молотке.
[01:46:48.340 --> 01:46:53.340]  То есть значит ли это, что молоток интуитивно очевиден и пользоваться только молотком будем.
[01:46:53.340 --> 01:46:55.340]  Ну или там наоборот.
[01:46:55.340 --> 01:47:00.340]  Писать на стене можно мелом, а можно вот это молотком дырки выбивать.
[01:47:00.340 --> 01:47:03.340]  То есть мы говорим молотком-то тоже это делается, так давайте забьем.
[01:47:03.340 --> 01:47:08.340]  Вообще мел это все, мел это елись, давайте пользоваться молотком, он везде решает.
[01:47:08.340 --> 01:47:12.340]  Ну, в олигардах нормальный подход в целом?
[01:47:12.340 --> 01:47:13.340]  Нет.
[01:47:13.340 --> 01:47:15.340]  Ну, на самом деле нет.
[01:47:15.540 --> 01:47:20.540]  Когда вам нужно быстро решить кучу задач, вы не хотите?
[01:47:20.540 --> 01:47:27.540]  Вы не хотите тратить на забивание, на написание текст на стене молотком кучу времени?
[01:47:27.540 --> 01:47:36.540]  То есть, на самом деле, да, но более оптимальная подходка, молотка же более сложная,
[01:47:36.540 --> 01:47:39.540]  что изучить на самом деле все варианты и в каждом именем выбирать наилучший.
[01:47:39.540 --> 01:47:43.540]  Вот это, конечно, хорошее решение и сложно поспорить.
[01:47:43.740 --> 01:47:45.740]  Почему вы так себе сделали, да?
[01:47:45.740 --> 01:47:51.740]  Ну, все такие не всегда, потому что это сложно действительно.
[01:47:51.740 --> 01:47:56.740]  Во-вторых, как бы интуитивно себя в этом сложно убедить в том, что это стоит делать,
[01:47:56.740 --> 01:47:59.740]  потому что окажется, что ты и так умный, и сам все это придумаешь.
[01:47:59.740 --> 01:48:04.740]  Не то что и так умный, а просто кажется эффективнее научиться пользоваться молотком.
[01:48:04.740 --> 01:48:07.740]  Ну, вопрос где?
[01:48:07.740 --> 01:48:12.740]  Все-таки правильно пользоваться молотком там, где им действительно хорошо пользоваться.
[01:48:12.740 --> 01:48:20.740]  Дальше это сводится к каким холиварам, в духе нужно ли изучать дерево отрезков с операциями снизу.
[01:48:20.740 --> 01:48:28.740]  Многие считают, что просто вообще про это нужно забыть как страшный сон и не использовать, потому что это с точки зрения изучения программирования просто потеря времени.
[01:48:28.740 --> 01:48:31.740]  Наоборот, фенвик потеря времени, а вот дерево отрезков...
[01:48:31.740 --> 01:48:36.740]  Нет, фенвик не потеря времени, потому что его полезно иногда быстро писать, чтобы быстро работать.
[01:48:36.740 --> 01:48:38.740]  Он заменяется на дерево отрезков.
[01:48:38.740 --> 01:48:51.740]  Ну скажем так, у меня вот за тому его олимпиадную жизнь, ни в одной реальной олимпиаде, в контесте у меня не было такого, что я из-за того, что я фенвика и ДО снизу не писал особо, у меня не было проблем.
[01:48:51.740 --> 01:48:52.740]  Ну понятно.
[01:48:52.740 --> 01:48:54.740]  Я просто не писал ДО сверху и в целом все.
[01:48:54.740 --> 01:49:04.740]  Нет, ну понятно, нет, ну там вот есть конкретные задачи, где все-таки фенвик... ну как бы все-таки там какой-нибудь фенвика написать лучше, там фенвик фенвиков, но...
[01:49:04.740 --> 01:49:08.740]  Ну тут у кого как?
[01:49:08.740 --> 01:49:10.740]  Ну по-разному бывает.
[01:49:10.740 --> 01:49:15.740]  У кого-то нет, у кого-то там у кого-то может быть, но это уже, я говорю, тоже такие холиварные вопросы на самом деле.
[01:49:15.740 --> 01:49:16.740]  Потому что дальше можно обсуждать еще.
[01:49:16.740 --> 01:49:25.740]  То есть как мне кажется, что дерево снизу все-таки тоже полезно изучать, потому что там дерево отрезков, то есть тогда можно лучше понимать, как дерево отрезков устроено.
[01:49:25.740 --> 01:49:27.740]  Еще так немножко с другой стороны посмотреть.
[01:49:27.740 --> 01:49:30.740]  Но как бы с другой стороны...
[01:49:30.740 --> 01:49:31.740]  Это другое.
[01:49:31.740 --> 01:49:32.740]  Ну вот.
[01:49:32.740 --> 01:49:33.740]  Так вот.
[01:49:33.740 --> 01:49:39.740]  Значит хорошо, что префикс функции, что z функции, все префиксы, которые являются полиндромами мы здесь за линию нашли.
[01:49:39.740 --> 01:49:49.740]  Но для каждого такого полиндрома теперь хочется сказать, хочется получается найти, насколько максимально его теперь можно вот так раздвинуть, чтобы это был все еще полиндром.
[01:49:49.740 --> 01:49:51.740]  Как это сделать?
[01:49:51.740 --> 01:49:52.740]  Очень просто.
[01:49:52.740 --> 01:50:02.740]  Если это половина s1, это s2, то по большому счету давайте рассмотрим такую строчку, как s1 развернутая, там какой-нибудь диезик s2.
[01:50:02.740 --> 01:50:15.740]  И тогда получается, что в такой строке, то есть надо найти максимальную, то есть вот если вот эту длину мы нарисуем вот так, то по большому счету надо найти вот такой максимальной длины,
[01:50:15.740 --> 01:50:23.740]  ну ладно, префикс, то есть такая под строку в какой-то позиции s2 начинающейся, которая совпадает с префиксом развернутой строки.
[01:50:23.740 --> 01:50:42.740]  То есть получается, если вы насчитаете, во-первых, вот эту функцию, то есть там префикс или z для вот такой строки и префикс, и там скажем z функцию в данном случае для вот такой строки за линию, то получается на все запросы вида, там какой у меня максимальный полиндром вот в этом центре стоит, вы легко ответите.
[01:50:42.740 --> 01:50:56.740]  При условии, что это полиндром такой. Вот, собственно, такое решение, собственно, я за NLogin-чика написал, вот оно радостно зашло со временем работы полторы секунды при TL2.
[01:50:56.740 --> 01:51:07.740]  Ну, может, и сигара, может, тогда были медленные, ну там, может, и я на Паскале писал тогда, хотя Паскаль, по-моему, незначительно медленнее сей, на самом деле.
[01:51:08.740 --> 01:51:09.740]  Да, Паскаль на самом деле не летает.
[01:51:09.740 --> 01:51:26.740]  Да, нет, Паскаль хороший. Вот, но на поверху, потом где-то я услышал и даже потом будущему сакоманику так еще и там, потом быстром дело рассказал, что на самом деле, то есть на что на самом деле, то есть это вот полиндромности можно искать просто аналогично z функции, просто с той же идеей.
[01:51:26.740 --> 01:51:36.740]  Вот, но, как ни странно, на самом деле эта идея тоже в какой-то момент помогла, потому что на самом деле есть такая красивая, потому что есть еще две красивые задачи, которые решаются тем же подходом.
[01:51:38.740 --> 01:51:40.740]  Одну я расскажу, другая у вас будет в домашнем задании.
[01:51:42.740 --> 01:51:50.740]  Задача называется, задача, ну раз уж зашла речь, давайте перейдем сюда, задача о тандемном повторе.
[01:51:52.740 --> 01:51:55.740]  А, ну-ка, кто сталкивался с задачей о тандемном повторе?
[01:51:56.740 --> 01:52:01.740]  А сколько раз сталкивались с задачей о тандемном повторе?
[01:52:02.740 --> 01:52:04.740]  Ну, я не помню конкретно.
[01:52:05.740 --> 01:52:07.740]  Значит, смотри, сейчас я сформулирую задачу.
[01:52:08.740 --> 01:52:13.740]  Нет, то есть, да, есть дерево тандемных повторов, но с ним, с ним, по крайней мере, пока не сталкивался я.
[01:52:14.740 --> 01:52:15.740]  Я сталкивался.
[01:52:16.740 --> 01:52:17.740]  Буду благодарен.
[01:52:18.740 --> 01:52:19.740]  Давай.
[01:52:20.740 --> 01:52:22.740]  О, глядишь, у нас новинка в курсе будет.
[01:52:23.740 --> 01:52:25.740]  Да, значит, Рознецов говорит спасибо.
[01:52:26.740 --> 01:52:29.740]  Нет, ну да, нет, ну да, а я, почему бы нет, собственно, чего.
[01:52:30.740 --> 01:52:32.740]  Денис, отбирай битую ссылку.
[01:52:33.740 --> 01:52:34.740]  Зачем?
[01:52:35.740 --> 01:52:36.740]  Чтобы у нас не было дерева тандемных повторов.
[01:52:37.740 --> 01:52:38.740]  Значит, смотри.
[01:52:39.740 --> 01:52:40.740]  Тихо, тихо.
[01:52:44.740 --> 01:52:45.740]  Значит, смотри.
[01:52:45.740 --> 01:52:47.740]  Давай, смотри, как у нас будет новинка в курсе.
[01:52:48.740 --> 01:52:58.740]  Господи, да, тут еще таких новинок накинешь, и у меня полночье ощущение, что, видимо, в четвертом семестре нужно устраивать вообще там это, то есть, это продолжение этого курса, но уже в формате спецкурса.
[01:52:59.740 --> 01:53:06.740]  Нет, нет, у меня даже была мысль, а может быть, действительно, то есть такое вот сделать и рассказывать там вот совсем какой-нибудь расстрел, типа там алгоритм Торупа, например, какой-нибудь.
[01:53:07.740 --> 01:53:13.740]  Ну вот, ну что-нибудь, что сюда не вошло, потому что на самом деле там есть куча вещей, которые вот сюда не входят, на самом деле.
[01:53:14.740 --> 01:53:18.740]  Ну вот, а может, например, доказательства мастер-теремы, например.
[01:53:19.740 --> 01:53:20.740]  Чего?
[01:53:21.740 --> 01:53:23.740]  Почему неинтересно, ну так.
[01:53:25.740 --> 01:53:27.740]  Нет, ну это да.
[01:53:28.740 --> 01:53:32.740]  Нет, ну с этой точки зрения, да, давайте тогда копать там это лучшие алгоритмы поиска максимального потока еще.
[01:53:33.740 --> 01:53:36.740]  О-о-о, то есть вот там.
[01:53:37.740 --> 01:53:38.740]  То есть этих расстрел.
[01:53:39.740 --> 01:53:41.740]  Правда, проблема в том, что каждый из этих алгоритмов нужно примерно месяц рассказывать.
[01:53:41.740 --> 01:53:43.740]  Как может, спецкурс на несколько идет.
[01:53:44.740 --> 01:53:45.740]  О-о-о, да.
[01:53:46.740 --> 01:53:48.740]  Ну теоретически можно практически.
[01:53:49.740 --> 01:53:57.740]  Ой, как говорится, практически, чтобы я, да, практически, конечно, чтобы это делать мне на самом деле свою текущую работу научиться нормально делать, конечно.
[01:53:58.740 --> 01:54:00.740]  Ну вот там, дзэ там вовремя.
[01:54:01.740 --> 01:54:04.740]  Ну как бы, ну дзэ там вовремя проверять вот это все, да.
[01:54:05.740 --> 01:54:06.740]  Вот.
[01:54:07.740 --> 01:54:08.740]  Так вот, смотрите.
[01:54:08.740 --> 01:54:10.740]  Значит задача о тандемном повторе звучит так.
[01:54:11.740 --> 01:54:12.740]  Смотрите.
[01:54:13.740 --> 01:54:14.740]  Дана строка S.
[01:54:16.740 --> 01:54:23.740]  Найти максимальной длины под строку, которая состоит из двух одинаковых подстрок.
[01:54:24.740 --> 01:54:25.740]  С конкретегированных.
[01:54:26.740 --> 01:54:31.740]  Вот хочется найти такого вида под строку, где длина T как можно больше.
[01:54:33.740 --> 01:54:35.740]  То есть вот такая задача.
[01:54:36.740 --> 01:54:37.740]  То есть вот такая задача.
[01:54:40.740 --> 01:54:41.740]  Вот тоже на самом деле.
[01:54:43.740 --> 01:54:44.740]  Значит как ее искать?
[01:54:45.740 --> 01:54:46.740]  Так вот, оказывается.
[01:54:47.740 --> 01:54:54.740]  То есть в принципе, вот сейчас парадокс будет, потому что как бы мы вот с вами столкнулись вот с этим вот разделяем и властвуем, казалось вроде просто.
[01:54:54.740 --> 01:54:57.740]  Хотя вот обычно, когда я это вот сейчас рассказываю, обычно что-то люди застреливаются.
[01:54:59.740 --> 01:55:02.740]  Потому что почему-то кажется, что вот то, что я сейчас расскажу, это прям супер больно.
[01:55:02.740 --> 01:55:07.740]  Ну и то, что я уже рассказал, я сейчас расскажу на самом деле идеи, например, на то же самое.
[01:55:08.740 --> 01:55:09.740]  То есть идея такая.
[01:55:09.740 --> 01:55:11.740]  То есть опять же давайте распилим строку на пополам.
[01:55:11.740 --> 01:55:14.740]  Найдем ответ рикусивно слева, рикусивно справа.
[01:55:14.740 --> 01:55:17.740]  И теперь будем искать тандемный повтор, который проходит через границу.
[01:55:18.740 --> 01:55:24.740]  Так, ну давайте без ограничений общности считать, что у нас как бы стыковка находится где?
[01:55:24.740 --> 01:55:25.740]  Ну естественно справа.
[01:55:26.740 --> 01:55:27.740]  Вот.
[01:55:27.740 --> 01:55:28.740]  Как же мы это будем делать?
[01:55:30.740 --> 01:55:31.740]  Так, ну допустим мы...
[01:55:32.740 --> 01:55:35.740]  А, ну мы опять без ограничений общности считаем, что у нас длина L.
[01:55:35.740 --> 01:55:38.740]  Значит давайте переберем и предположим, что у нас длина L.
[01:55:38.740 --> 01:55:41.740]  Как проверить, что есть ли тандемный повтор длины L?
[01:55:43.740 --> 01:55:44.740]  Я скажу, я это сделаю так.
[01:55:44.740 --> 01:55:47.740]  Вот смотрите, вот есть у меня вот эта граница.
[01:55:47.740 --> 01:55:50.740]  Давайте я вот предположу, что у меня вот эта вот длина L.
[01:55:50.740 --> 01:55:52.740]  Тогда фактически что я должен проверить?
[01:55:53.740 --> 01:55:55.740]  Ну, во-первых, у меня идея такая.
[01:55:55.740 --> 01:56:00.740]  Давайте, во-первых, я проверю просто, насколько я вот сюда с этой позиции могу пойти.
[01:56:01.740 --> 01:56:03.740]  Ну, если я могу пойти прям на L или более.
[01:56:03.740 --> 01:56:04.740]  Ну, как я это проверю?
[01:56:04.740 --> 01:56:06.740]  Я просто Z-функцию здесь насчитаю и проверю, правда?
[01:56:09.740 --> 01:56:10.740]  Вот.
[01:56:10.740 --> 01:56:11.740]  И допустим, я вот...
[01:56:12.740 --> 01:56:15.740]  То есть, допустим, если у меня вот эта длина L,
[01:56:16.740 --> 01:56:17.740]  Так.
[01:56:17.740 --> 01:56:18.740]  Вот.
[01:56:18.740 --> 01:56:19.740]  И допустим, я вот...
[01:56:19.740 --> 01:56:21.740]  То есть, допустим, я тут докуда-то дошел.
[01:56:23.740 --> 01:56:26.740]  До какого-нибудь там, я не знаю, X.
[01:56:26.740 --> 01:56:27.740]  Да?
[01:56:27.740 --> 01:56:29.740]  То есть, у меня вот X совпадает вот тут с префиксом.
[01:56:29.740 --> 01:56:30.740]  Вот.
[01:56:32.740 --> 01:56:33.740]  Тогда...
[01:56:34.740 --> 01:56:35.740]  Ну, вот.
[01:56:35.740 --> 01:56:36.740]  То есть, нот...
[01:56:36.740 --> 01:56:37.740]  Тогда что мне нужно?
[01:56:38.740 --> 01:56:41.740]  Тогда, если X тут совпадает,
[01:56:42.740 --> 01:56:44.740]  То тогда, получается, я как минимум...
[01:56:44.740 --> 01:56:45.740]  Вот.
[01:56:45.740 --> 01:56:46.740]  То есть, что у меня еще должно быть?
[01:56:46.740 --> 01:56:50.740]  Тогда, получается, если дальше это так, чтобы это повторялось,
[01:56:50.740 --> 01:56:53.740]  вот так сказать, с периодом L, проходило дальше,
[01:56:53.740 --> 01:56:58.740]  я должен сделать так, чтобы у меня вот оставшаяся часть L-X
[01:56:59.740 --> 01:57:01.740]  вот здесь вот совпадала.
[01:57:04.740 --> 01:57:05.740]  Логично, да?
[01:57:05.740 --> 01:57:06.740]  Да.
[01:57:06.740 --> 01:57:07.740]  Как я это буду проверять?
[01:57:08.740 --> 01:57:10.740]  На самом деле, очень просто.
[01:57:10.740 --> 01:57:11.740]  Я, опять же...
[01:57:12.740 --> 01:57:13.740]  То есть, если...
[01:57:13.740 --> 01:57:15.740]  Нет, даже не префикс функции, а просто Z-функция.
[01:57:15.740 --> 01:57:18.740]  То есть, я возьму просто функцию S1-реверснутая,
[01:57:18.740 --> 01:57:20.740]  диезик S2, иначе...
[01:57:20.740 --> 01:57:21.740]  Реверснутая.
[01:57:22.740 --> 01:57:23.740]  Иначе считаю Z-функцию.
[01:57:23.740 --> 01:57:24.740]  Да.
[01:57:26.740 --> 01:57:31.740]  Потому что, если я теперь нарисую, что такое S1-развернутая,
[01:57:31.740 --> 01:57:34.740]  диезик S2-развернутая,
[01:57:35.740 --> 01:57:41.740]  то тогда вот эти две зеленые стрелочки превращаться в вот такую стрелочку
[01:57:41.740 --> 01:57:44.740]  и где-то вот такую стрелочку.
[01:57:49.740 --> 01:57:53.740]  И мне, то есть, мне останется просто насчитать Z-функцию,
[01:57:53.740 --> 01:57:55.740]  и получается, мне просто надо проверить,
[01:57:55.740 --> 01:57:57.740]  верно ли, что Z-функция строки S2,
[01:57:57.740 --> 01:58:01.740]  плюс Z-функция в позиции вот эта длина этого всего – L,
[01:58:01.740 --> 01:58:03.740]  они больше либо равны L.
[01:58:04.740 --> 01:58:06.740]  Сейчас, какую вы конкретно задачу решаете?
[01:58:06.740 --> 01:58:08.740]  Ну и не в том плане, какая промылировка, а...
[01:58:08.740 --> 01:58:12.740]  Конкретно сейчас я пытаюсь найти тандемный повтор, хоть какой-нибудь.
[01:58:12.740 --> 01:58:14.740]  Который начинается в каком-то конкретном символе.
[01:58:14.740 --> 01:58:15.740]  Да.
[01:58:15.740 --> 01:58:16.740]  То есть, за квадрат, кажется.
[01:58:16.740 --> 01:58:18.740]  Нет, почему за квадрат? Нет.
[01:58:18.740 --> 01:58:22.740]  Просто для каждого L я это сделаю за линию, за единицу.
[01:58:22.740 --> 01:58:24.740]  При подсчете правильных Z-функций.
[01:58:24.740 --> 01:58:25.740]  Сейчас.
[01:58:25.740 --> 01:58:26.740]  Нет.
[01:58:26.740 --> 01:58:27.740]  Что?
[01:58:27.740 --> 01:58:30.740]  У вас же вот этот символ середины может быть где угодно.
[01:58:30.740 --> 01:58:31.740]  Да.
[01:58:31.740 --> 01:58:34.740]  Но меня интересует не он, меня интересует длина.
[01:58:35.740 --> 01:58:37.740]  Смотрите, по большому счету я сформулирую...
[01:58:37.740 --> 01:58:39.740]  Смотрите, давайте я введу определение.
[01:58:39.740 --> 01:58:41.740]  Значит, смотрите, прям давайте записываем.
[01:58:41.740 --> 01:58:43.740]  Определение.
[01:58:44.740 --> 01:58:45.740]  Строка T.
[01:58:47.740 --> 01:58:48.740]  Строка T.
[01:58:49.740 --> 01:58:52.740]  Значит, допустим, L периодическая.
[01:58:54.740 --> 01:58:55.740]  L периодическая.
[01:58:55.740 --> 01:58:56.740]  L периодическая.
[01:58:59.740 --> 01:59:00.740]  Если...
[01:59:04.740 --> 01:59:07.740]  То есть, для любого I такое...
[01:59:07.740 --> 01:59:11.740]  Вам нужно просто проверить, что у вас сумма этих двух Z-функций больше, чем L.
[01:59:11.740 --> 01:59:13.740]  Не меньше, чем L.
[01:59:14.740 --> 01:59:15.740]  Сейчас.
[01:59:15.740 --> 01:59:17.740]  Давайте введу формулировать, чтобы было удобнее.
[01:59:17.740 --> 01:59:21.740]  Потому что в будущее после этого я тоже сейчас ввожу то, в чем мы будем жить.
[01:59:21.740 --> 01:59:25.740]  Значит, для любого I такое, что...
[01:59:25.740 --> 01:59:29.740]  Короче говоря, I и I плюс L символы строки T существуют.
[01:59:29.740 --> 01:59:33.740]  Верно, что T и T равно T и плюс L.
[01:59:35.740 --> 01:59:36.740]  Вот.
[01:59:36.740 --> 01:59:38.740]  Вот я назову такую строку L периодической.
[01:59:43.740 --> 01:59:44.740]  Вот.
[01:59:44.740 --> 01:59:48.740]  Так вот, по большому счету теперь моя задача найти...
[01:59:48.740 --> 01:59:58.740]  То есть, для каждого L понять, существует ли L периодическая подстрока длины хотя бы 2L с вот этой вот границей.
[02:00:00.740 --> 02:00:02.740]  А, L периодическая.
[02:00:02.740 --> 02:00:03.740]  Ого.
[02:00:03.740 --> 02:00:05.740]  Да, у вас какое-то неинтуитивное определение.
[02:00:05.740 --> 02:00:06.740]  Ну вот.
[02:00:06.740 --> 02:00:08.740]  Интуитивное определение, это типа L раз повторяется.
[02:00:08.740 --> 02:00:09.740]  Нет.
[02:00:10.740 --> 02:00:11.740]  Вот.
[02:00:11.740 --> 02:00:12.740]  Нет, я...
[02:00:13.740 --> 02:00:15.740]  Так, вот поэтому мы вводим определение.
[02:00:15.740 --> 02:00:16.740]  Для меня вот это интуитивно.
[02:00:17.740 --> 02:00:19.740]  Причем тут вот это определение?
[02:00:20.740 --> 02:00:21.740]  А вот причем.
[02:00:21.740 --> 02:00:23.740]  То есть, по большому счету, смотрите, если у меня...
[02:00:23.740 --> 02:00:27.740]  То есть, вот эта строка, она модуль T периодично.
[02:00:28.740 --> 02:00:30.740]  Да, просто два раза T стоит.
[02:00:30.740 --> 02:00:31.740]  Да, но это означает, что...
[02:00:31.740 --> 02:00:33.740]  Нет, просто, смотри, утверждение.
[02:00:33.740 --> 02:00:40.740]  Смотри, вот эта строка, она имеет длину 2 модуль T и она модуль T периодично.
[02:00:41.740 --> 02:00:44.740]  Это эквивалентно тому, что она состоит из двух одинаковых копий.
[02:00:46.740 --> 02:00:50.740]  Ну, в принципе, вообще можно сказать, что пусть у вас есть строка длины N,
[02:00:51.740 --> 02:00:54.740]  там она K периодично, и N делится на K.
[02:00:54.740 --> 02:00:55.740]  На K.
[02:00:55.740 --> 02:00:56.740]  Тогда...
[02:00:56.740 --> 02:00:57.740]  То есть, пусть N делится на K.
[02:00:57.740 --> 02:01:01.740]  Тогда эта строка K периодично, тогда и только тогда, когда она состоит из одинаковых копий длины K.
[02:01:01.740 --> 02:01:03.740]  Можно на экзамене вот эту?
[02:01:04.740 --> 02:01:05.740]  Да, как угодно.
[02:01:06.740 --> 02:01:07.740]  Ну вот.
[02:01:08.740 --> 02:01:10.740]  Нет, у вас тут другое определение.
[02:01:10.740 --> 02:01:11.740]  У вас необязательно делитесь.
[02:01:12.740 --> 02:01:13.740]  Да.
[02:01:13.740 --> 02:01:14.740]  Вот это более общее.
[02:01:14.740 --> 02:01:18.740]  То есть, я утверждаю, что у меня строка длины 9 вполне может быть 2 периодично.
[02:01:19.740 --> 02:01:22.740]  Ну, если она типа A, B, A, B, A, B, A.
[02:01:24.740 --> 02:01:25.740]  Да, это...
[02:01:26.740 --> 02:01:28.740]  А не может быть 10 периодично, потому что там...
[02:01:31.740 --> 02:01:32.740]  Чего и плюс L?
[02:01:32.740 --> 02:01:35.740]  Ну, строка длины 9 не может быть 10 периодичной.
[02:01:37.740 --> 02:01:38.740]  10 периодичной...
[02:01:38.740 --> 02:01:39.740]  Наоборот.
[02:01:40.740 --> 02:01:43.740]  Ну, формально говоря, получается, что она 10 периодична.
[02:01:44.740 --> 02:01:48.740]  Потому что просто для любого и удовлетворяющего такого условия это верно.
[02:01:49.740 --> 02:01:50.740]  Да.
[02:01:51.740 --> 02:01:52.740]  Вот.
[02:01:53.740 --> 02:01:54.740]  Но давайте так.
[02:01:54.740 --> 02:01:57.740]  Обычно интуитивно, конечно, считают, что строка 9 все-таки не 10 периодично.
[02:01:57.740 --> 02:01:58.740]  Нет, но интуитивно она да.
[02:01:58.740 --> 02:01:59.740]  Да, да, да.
[02:02:00.740 --> 02:02:02.740]  Да, но обычно так не говорят, и это не очень интересно.
[02:02:02.740 --> 02:02:03.740]  Там начинаются там всякие свойства.
[02:02:03.740 --> 02:02:04.740]  Давайте про периодически говорить так.
[02:02:05.740 --> 02:02:09.740]  Так вот, наша задача найти под строку хотя бы длины 2L,
[02:02:09.740 --> 02:02:11.740]  которая является L периодической.
[02:02:11.740 --> 02:02:13.740]  И которая проходит через вот эту границу.
[02:02:15.740 --> 02:02:17.740]  Так, не надо туда читать.
[02:02:22.740 --> 02:02:25.740]  Вы можете делать криты с телекрамой, тогда они будут проходить.
[02:02:25.740 --> 02:02:26.740]  Ну, могу.
[02:02:26.740 --> 02:02:27.740]  Да, ладно.
[02:02:28.740 --> 02:02:30.740]  Нет, но, кстати, эта новость, между прочим, ладно,
[02:02:30.740 --> 02:02:32.740]  для вас тоже будет вполне интересна на самом деле.
[02:02:32.740 --> 02:02:33.740]  Уже была.
[02:02:33.740 --> 02:02:34.740]  Хотя...
[02:02:35.740 --> 02:02:36.740]  Ну, она уже была.
[02:02:36.740 --> 02:02:38.740]  Нет, я вам скажу, я ничего не скрываю.
[02:02:38.740 --> 02:02:40.740]  В общем, грядет новый технокубок.
[02:02:41.740 --> 02:02:42.740]  Ну вот.
[02:02:42.740 --> 02:02:43.740]  И как бы...
[02:02:43.740 --> 02:02:44.740]  Нет, но...
[02:02:45.740 --> 02:02:47.740]  Нет, ну, скажу так, для вас ничего.
[02:02:47.740 --> 02:02:49.740]  Ну, если новость заключает, что это будет заниматься
[02:02:49.740 --> 02:02:51.740]  просто не ЦРТО, а непосредственно ФПМИ,
[02:02:51.740 --> 02:02:54.740]  но как бы для вас идея на то же самое.
[02:02:54.740 --> 02:02:56.740]  То есть, короче, Call for problems.
[02:02:56.740 --> 02:02:58.740]  Филипп Грибов сказал, что в этом году
[02:02:58.740 --> 02:03:00.740]  будут выбирать хорошие задачи на технологию.
[02:03:01.740 --> 02:03:03.740]  А не как в прошлом смысле.
[02:03:03.740 --> 02:03:06.740]  Осталось только выяснить, почему это сказал Филипп Грибов,
[02:03:06.740 --> 02:03:08.740]  какое он имеет отношение к технокубку.
[02:03:08.740 --> 02:03:10.740]  Игры в ВТИ.
[02:03:10.740 --> 02:03:11.740]  Нет, я могу...
[02:03:11.740 --> 02:03:13.740]  Ну, как бы не передавали, на самом деле,
[02:03:13.740 --> 02:03:15.740]  как в ВКонтакте, на самом деле,
[02:03:15.740 --> 02:03:18.740]  там очень понравилась работа в прошлом году, кстати.
[02:03:18.740 --> 02:03:20.740]  Так что...
[02:03:20.740 --> 02:03:22.740]  Так что тут все бы...
[02:03:22.740 --> 02:03:24.740]  А участникам олимпиады очень не понравилась
[02:03:24.740 --> 02:03:26.740]  работа составителей, да?
[02:03:26.740 --> 02:03:27.740]  Нет.
[02:03:27.740 --> 02:03:29.740]  Ну, как сказать...
[02:03:29.740 --> 02:03:31.740]  По модулю...
[02:03:31.740 --> 02:03:34.740]  Нет, по модулю стандартной нелюбимой,
[02:03:34.740 --> 02:03:36.740]  там массовых людей, геометрии.
[02:03:36.740 --> 02:03:38.740]  Ну, тут тяжелая доля, к сожалению,
[02:03:38.740 --> 02:03:40.740]  любого составителя задач по геометрии.
[02:03:40.740 --> 02:03:42.740]  Хотя там, по-моему, не было.
[02:03:42.740 --> 02:03:44.740]  Но там претензии...
[02:03:44.740 --> 02:03:46.740]  Ребят, так тихо, не перебивайте меня, пожалуйста.
[02:03:46.740 --> 02:03:48.740]  Основные претензии там были, по-моему,
[02:03:48.740 --> 02:03:50.740]  не к составителям задач, а к тому,
[02:03:50.740 --> 02:03:52.740]  как работал тестирующий систем.
[02:03:52.740 --> 02:03:54.740]  Ну, скорее к тому, чтобы и составление
[02:03:54.740 --> 02:03:56.740]  просто протестировали где-то
[02:03:56.740 --> 02:03:58.740]  на левой системе,
[02:03:58.740 --> 02:04:00.740]  и там все ограничения подогнали,
[02:04:00.740 --> 02:04:01.740]  а потом...
[02:04:01.740 --> 02:04:03.740]  Да, но, по-моему,
[02:04:03.740 --> 02:04:05.740]  это вопрос как бы не к самим задачам.
[02:04:05.740 --> 02:04:07.740]  То есть к самим задачам тоже, конечно, были,
[02:04:07.740 --> 02:04:09.740]  потому что иногда в каких-то раундах
[02:04:09.740 --> 02:04:11.740]  перезроп случался.
[02:04:11.740 --> 02:04:13.740]  Почему это вопрос целый к ограничениям,
[02:04:13.740 --> 02:04:15.740]  то есть к части условий?
[02:04:15.740 --> 02:04:17.740]  Ну, там технический момент,
[02:04:17.740 --> 02:04:19.740]  что как бы это...
[02:04:19.740 --> 02:04:21.740]  Это просто нужно тестировать...
[02:04:21.740 --> 02:04:23.740]  Ну, да, но там
[02:04:23.740 --> 02:04:25.740]  это сложилось так, что, к сожалению,
[02:04:25.740 --> 02:04:27.740]  не от нас зависело, а там просто ВК разрабатывает
[02:04:27.740 --> 02:04:29.740]  новую систему, и это называется...
[02:04:29.740 --> 02:04:31.740]  Они вот наткнулись просто на эти детские болячки.
[02:04:31.740 --> 02:04:33.740]  Так что, увы.
[02:04:33.740 --> 02:04:35.740]  На этот раз надеется,
[02:04:35.740 --> 02:04:37.740]  что все ошибки эти были учтены,
[02:04:37.740 --> 02:04:39.740]  поэтому в будущем будет нормально.
[02:04:39.740 --> 02:04:41.740]  То есть, но прав...
[02:04:41.740 --> 02:04:43.740]  Нет, там просто единственное решение тестировать.
[02:04:43.740 --> 02:04:45.740]  Они собираются ВК КАП туда же переносить.
[02:04:45.740 --> 02:04:47.740]  ВК КАП? Ну, мне об этом не известно.
[02:04:47.740 --> 02:04:49.740]  Вот. Да.
[02:04:49.740 --> 02:04:51.740]  Единственное только для всех, то есть все
[02:04:51.740 --> 02:04:53.740]  активно приглашаются в этом участвовать,
[02:04:53.740 --> 02:04:55.740]  естественно, это тоже оплачиваемо.
[02:04:55.740 --> 02:04:57.740]  То есть, я думаю, как минимум,
[02:04:57.740 --> 02:04:59.740]  не хуже, чем в прошлый раз.
[02:04:59.740 --> 02:05:01.740]  Единственное только будет мелкая оговорка.
[02:05:01.740 --> 02:05:03.740]  Оговорка будет заключаться в том,
[02:05:03.740 --> 02:05:05.740]  что на этот раз они заказывают все-таки задачи с баллами.
[02:05:07.740 --> 02:05:09.740]  Ага.
[02:05:09.740 --> 02:05:11.740]  Сколько часов длится контеста?
[02:05:11.740 --> 02:05:13.740]  Нет. Да. Нет.
[02:05:13.740 --> 02:05:15.740]  Нет. Контесты, длительность контеста
[02:05:15.740 --> 02:05:17.740]  может быть примерно столько же,
[02:05:17.740 --> 02:05:19.740]  и задача тоже требуется, кстати, столько же.
[02:05:19.740 --> 02:05:21.740]  Ага. И еще все с подгруппами.
[02:05:21.740 --> 02:05:23.740]  С подгруппами, да. Слушайте, ловко они
[02:05:23.740 --> 02:05:25.740]  придумали. А что такое?
[02:05:25.740 --> 02:05:27.740]  А шоги так?
[02:05:27.740 --> 02:05:29.740]  Двухчасовой контест
[02:05:29.740 --> 02:05:31.740]  на семь задач с подгруппами
[02:05:31.740 --> 02:05:33.740]  даже не знаю, сколько. Хорошо. Нет, ну ладно.
[02:05:33.740 --> 02:05:35.740]  Скорее всего, будет уже, наверное,
[02:05:35.740 --> 02:05:37.740]  двухчасовой, все-таки побольше, но соответственно.
[02:05:37.740 --> 02:05:39.740]  Так что в том плане...
[02:05:39.740 --> 02:05:41.740]  Трехчасовой, вроде.
[02:05:41.740 --> 02:05:43.740]  Ну, у нас
[02:05:43.740 --> 02:05:45.740]  в прошлом году было так, раунды были
[02:05:45.740 --> 02:05:47.740]  по два часа, финальный три.
[02:05:47.740 --> 02:05:49.740]  Да. Да.
[02:05:49.740 --> 02:05:51.740]  Не, но отборы как бы не рассчитаны на то, чтобы
[02:05:51.740 --> 02:05:53.740]  их закрывали. В целом кажется, что...
[02:05:53.740 --> 02:05:55.740]  Так же, соответственно. Есть вот несколько людей талантливых.
[02:05:55.740 --> 02:05:57.740]  Так же, соответственно. Так что все
[02:05:57.740 --> 02:05:59.740]  ноты. Не, ну нет.
[02:05:59.740 --> 02:06:01.740]  Ну как всегда, тут активно приглашаем всех,
[02:06:01.740 --> 02:06:03.740]  потому что как бы задачи нужны
[02:06:03.740 --> 02:06:05.740]  разного уровня,
[02:06:05.740 --> 02:06:07.740]  как самые сложные,
[02:06:07.740 --> 02:06:09.740]  так и, собственно, попроще.
[02:06:09.740 --> 02:06:11.740]  И с реги, то есть все нужны. Но там совсем сложные, может быть,
[02:06:11.740 --> 02:06:13.740]  даже не нужны. Потому что, как показала практика
[02:06:13.740 --> 02:06:15.740]  прошлого технокубка, возможно, там задача
[02:06:15.740 --> 02:06:17.740]  на какой-нибудь там конвекс халт три может быть там...
[02:06:17.740 --> 02:06:19.740]  Может быть дана там... Может быть
[02:06:19.740 --> 02:06:21.740]  в финальном туре
[02:06:21.740 --> 02:06:23.740]  в каком-то последнем слоте.
[02:06:23.740 --> 02:06:25.740]  И то не факт, что оно там нужно.
[02:06:25.740 --> 02:06:27.740]  Вот. Но, соответственно.
[02:06:27.740 --> 02:06:29.740]  Так что вот, соответственно, такое
[02:06:29.740 --> 02:06:31.740]  вот объявление есть. Так что, соответственно,
[02:06:31.740 --> 02:06:33.740]  всех, так что всех, соответственно, активно
[02:06:33.740 --> 02:06:35.740]  приглашаем. Вот. Ну объявление.
[02:06:35.740 --> 02:06:37.740]  Так что вы, соответственно, просто первые, кто об этом
[02:06:37.740 --> 02:06:39.740]  узнает. Вот.
[02:06:39.740 --> 02:06:41.740]  Так что все сделаем все это.
[02:06:41.740 --> 02:06:43.740]  Ну вот. Так что
[02:06:43.740 --> 02:06:45.740]  спасибо Димиду, что тут сообщение высветилось
[02:06:45.740 --> 02:06:47.740]  на эту тему. Да.
[02:06:47.740 --> 02:06:49.740]  Это как раз не секретная информация.
[02:06:49.740 --> 02:06:51.740]  Вот.
[02:06:51.740 --> 02:06:53.740]  Вот.
[02:06:53.740 --> 02:06:55.740]  Так вот. Значит, вернемся
[02:06:55.740 --> 02:06:57.740]  к тандемным повторам.
[02:06:57.740 --> 02:06:59.740]  Значит, смотрите. Ищем... То есть, смотрите,
[02:06:59.740 --> 02:07:01.740]  для каждого l мы хотим понять
[02:07:01.740 --> 02:07:03.740]  за от единицы каким-то образом.
[02:07:03.740 --> 02:07:05.740]  Есть ли у нас 2l
[02:07:05.740 --> 02:07:07.740]  периодическая подстрока,
[02:07:07.740 --> 02:07:09.740]  которая проходит
[02:07:09.740 --> 02:07:11.740]  через вот эту границу.
[02:07:11.740 --> 02:07:13.740]  То есть, строка длины 2l,
[02:07:13.740 --> 02:07:15.740]  которая является l периодической.
[02:07:15.740 --> 02:07:17.740]  l периодической длины хотя бы 2l.
[02:07:17.740 --> 02:07:19.740]  Тогда мы
[02:07:19.740 --> 02:07:21.740]  идейно делаем так.
[02:07:21.740 --> 02:07:23.740]  Найдем максимальной длины префикс
[02:07:23.740 --> 02:07:25.740]  строки s2, который является
[02:07:25.740 --> 02:07:27.740]  l периодическим.
[02:07:27.740 --> 02:07:29.740]  Вот задача, как найти
[02:07:29.740 --> 02:07:31.740]  префикс,
[02:07:31.740 --> 02:07:33.740]  то есть максимальной длины
[02:07:33.740 --> 02:07:35.740]  префикс, который является l периодическим.
[02:07:41.740 --> 02:07:43.740]  Да. Ага. Не, ну,
[02:07:43.740 --> 02:07:45.740]  если вы поняли... Не, боже упаси.
[02:07:45.740 --> 02:07:47.740]  На самом деле все гораздо проще.
[02:07:47.740 --> 02:07:49.740]  Заметим, что строка l
[02:07:49.740 --> 02:07:51.740]  периодическая,
[02:07:51.740 --> 02:07:53.740]  ну, тогда и только тогда,
[02:07:53.740 --> 02:07:55.740]  когда префикс длины
[02:07:55.740 --> 02:07:57.740]  n минус,
[02:07:57.740 --> 02:07:59.740]  там, модуль t минус l,
[02:07:59.740 --> 02:08:01.740]  совпадает
[02:08:01.740 --> 02:08:03.740]  с l плюс
[02:08:03.740 --> 02:08:05.740]  первым суффиксом.
[02:08:07.740 --> 02:08:09.740]  Вот, я вот вижу, что это на самом деле
[02:08:09.740 --> 02:08:11.740]  буквально одно и то же. Да?
[02:08:11.740 --> 02:08:13.740]  Сейчас. Что? Что?
[02:08:13.740 --> 02:08:15.740]  Нет.
[02:08:15.740 --> 02:08:17.740]  В смысле, если длины 2l, то окей.
[02:08:17.740 --> 02:08:19.740]  Нет, вообще, я вот это определение
[02:08:19.740 --> 02:08:21.740]  переписал. Если не кратная l длина, это ж вроде
[02:08:21.740 --> 02:08:23.740]  неправда. Правда, правда.
[02:08:23.740 --> 02:08:25.740]  Потому что... Смотрите.
[02:08:25.740 --> 02:08:27.740]  А, у вас там модуль
[02:08:27.740 --> 02:08:29.740]  n минус l. Модуль t.
[02:08:29.740 --> 02:08:31.740]  Ладно, хорошо. Ну,
[02:08:31.740 --> 02:08:33.740]  у нас n нет. Да, пойдет.
[02:08:33.740 --> 02:08:35.740]  Или что то же самое.
[02:08:37.740 --> 02:08:39.740]  Ну, это почти как задача про то,
[02:08:39.740 --> 02:08:41.740]  что все лошади одной масти.
[02:08:43.740 --> 02:08:45.740]  Ну, типа, докажем по индукции,
[02:08:45.740 --> 02:08:47.740]  что все лошади одной масти. База одна,
[02:08:47.740 --> 02:08:49.740]  лошади одной масти. Шаг.
[02:08:49.740 --> 02:08:51.740]  Если n плюс 1 лошадь
[02:08:51.740 --> 02:08:53.740]  берем первые на одной масти и
[02:08:53.740 --> 02:08:55.740]  последние на одной масти, естественно, они все
[02:08:55.740 --> 02:08:57.740]  того же цвета, что и средние. Ага, ну да.
[02:08:57.740 --> 02:08:59.740]  Бага в том, что пересечение может быть
[02:08:59.740 --> 02:09:01.740]  пустым, да. А тут...
[02:09:01.740 --> 02:09:03.740]  Какое может произойти случайно? Не,
[02:09:03.740 --> 02:09:05.740]  ну не очень понятно. Нет, ну смотри,
[02:09:05.740 --> 02:09:07.740]  просто давай... Ну, тут можно, наверное...
[02:09:07.740 --> 02:09:09.740]  Проблема при n равно 2, да.
[02:09:09.740 --> 02:09:11.740]  Ну, вот. То есть, на самом деле, тут надо уточнять,
[02:09:11.740 --> 02:09:13.740]  что, видимо, это все предполагается, когда
[02:09:13.740 --> 02:09:15.740]  у нас, допустим, 1 меньше
[02:09:15.740 --> 02:09:17.740]  либо равно n, видимо, там,
[02:09:17.740 --> 02:09:19.740]  чтобы это было адекватно. Ну, надо, меньше
[02:09:19.740 --> 02:09:21.740]  либо равно модуль t, вот так.
[02:09:21.740 --> 02:09:23.740]  Да, ошибка в рассудении при n равно 2,
[02:09:23.740 --> 02:09:25.740]  просто и все. Потому что первое
[02:09:25.740 --> 02:09:27.740]  лошадь, второе, одно и до свидания.
[02:09:27.740 --> 02:09:29.740]  Да, точно.
[02:09:33.740 --> 02:09:35.740]  Ну, отлично. Ну, вот там
[02:09:35.740 --> 02:09:37.740]  да, там бага такая. Тут бага не
[02:09:37.740 --> 02:09:39.740]  совсем здесь. Но тут заметим,
[02:09:39.740 --> 02:09:41.740]  что, вот, если вы будете
[02:09:41.740 --> 02:09:43.740]  распишите, что означает, что вот эта подстрока равна
[02:09:43.740 --> 02:09:45.740]  вот этой? Это как раз означает, что первый символ
[02:09:45.740 --> 02:09:47.740]  равен l плюс 1, второй l
[02:09:47.740 --> 02:09:49.740]  l плюс 2, третий l плюс 3 и так далее.
[02:09:49.740 --> 02:09:51.740]  Но это, по сути, вот это.
[02:09:51.740 --> 02:09:53.740]  Так, ладно. Вот.
[02:09:53.740 --> 02:09:55.740]  Вот.
[02:09:55.740 --> 02:09:57.740]  Классно. Вот.
[02:09:57.740 --> 02:09:59.740]  Но заметим, что вот эти вот проверки,
[02:09:59.740 --> 02:10:01.740]  это, на самом деле, можно сделать на языке
[02:10:01.740 --> 02:10:03.740]  просто z функции. Видно, да?
[02:10:05.740 --> 02:10:07.740]  То есть, в принципе, это означает, что если
[02:10:07.740 --> 02:10:09.740]  вы посчитаете z функцию для строки
[02:10:09.740 --> 02:10:11.740]  s2, то как бы все
[02:10:11.740 --> 02:10:13.740]  ее периодичности, то есть, все числа
[02:10:13.740 --> 02:10:15.740]  x, для которых она x периодичная,
[02:10:15.740 --> 02:10:17.740]  вы, получается, за линию и найдете.
[02:10:25.740 --> 02:10:27.740]  То есть, можно, если даже
[02:10:27.740 --> 02:10:29.740]  сказать, что в этом случае мы назовем l
[02:10:29.740 --> 02:10:31.740]  периодом строки t,
[02:10:31.740 --> 02:10:33.740]  то получается, да, что
[02:10:33.740 --> 02:10:35.740]  периодом являются те и только те l,
[02:10:35.740 --> 02:10:37.740]  для которых верно
[02:10:37.740 --> 02:10:39.740]  вот это вот.
[02:10:39.740 --> 02:10:41.740]  Ну, ладно.
[02:10:41.740 --> 02:10:43.740]  На самом деле, формально мы должны
[02:10:43.740 --> 02:10:45.740]  написать...
[02:10:45.740 --> 02:10:47.740]  Ну, я
[02:10:47.740 --> 02:10:49.740]  объясню,
[02:10:49.740 --> 02:10:51.740]  я, можно сказать, я объясняю алгоритм,
[02:10:51.740 --> 02:10:53.740]  правда,
[02:10:53.740 --> 02:10:55.740]  ну, можно сказать и так, да.
[02:10:55.740 --> 02:10:57.740]  Да, да, да.
[02:10:57.740 --> 02:10:59.740]  На самом деле, можно сказать и так, да.
[02:10:59.740 --> 02:11:01.740]  Вот.
[02:11:01.740 --> 02:11:03.740]  Поэтому исходя...
[02:11:03.740 --> 02:11:05.740]  Ну, на самом деле, формально это должен написать, что
[02:11:05.740 --> 02:11:07.740]  либо так, либо l равно 0t еще,
[02:11:07.740 --> 02:11:09.740]  потому что z от t плюс 1 мы не определили,
[02:11:09.740 --> 02:11:11.740]  к сожалению. Вот.
[02:11:11.740 --> 02:11:13.740]  Но это уже такие уже
[02:11:13.740 --> 02:11:15.740]  формалистические детали. Вот, кстати, еще возникает
[02:11:15.740 --> 02:11:17.740]  вопрос. Хорошо, с помощью z функции мы научились
[02:11:17.740 --> 02:11:19.740]  искать все периоды.
[02:11:19.740 --> 02:11:21.740]  А как искать периоды с помощью
[02:11:21.740 --> 02:11:23.740]  префикс-функции, кстати?
[02:11:23.740 --> 02:11:25.740]  Надо просто где-то недоразвернуться.
[02:11:25.740 --> 02:11:27.740]  Да нет.
[02:11:29.740 --> 02:11:31.740]  Вот задача.
[02:11:31.740 --> 02:11:33.740]  У вас вам дана строка
[02:11:33.740 --> 02:11:35.740]  и дана префикс-функция строки.
[02:11:35.740 --> 02:11:37.740]  Найдите ее минимальный период.
[02:11:39.740 --> 02:11:41.740]  Предположим, вам дана даже строка не дана,
[02:11:41.740 --> 02:11:43.740]  дана только префикс-функция.
[02:11:43.740 --> 02:11:45.740]  Найдите ее минимальное.
[02:11:45.740 --> 02:11:47.740]  У меня есть ощущение, что это префикс от конца.
[02:11:47.740 --> 02:11:49.740]  Нет. Но только l минус.
[02:11:49.740 --> 02:11:51.740]  Вот, совершенно верно. То есть
[02:11:51.740 --> 02:11:53.740]  минимальный период строки это...
[02:11:53.740 --> 02:11:55.740]  Ну, потому что, да, заметим, что строка...
[02:11:55.740 --> 02:11:57.740]  То есть давайте оговоримся, что строка
[02:11:57.740 --> 02:11:59.740]  у нас на самом деле l периодично,
[02:11:59.740 --> 02:12:01.740]  тогда и только тогда, когда
[02:12:01.740 --> 02:12:03.740]  как бы
[02:12:03.740 --> 02:12:05.740]  префикс длины модуль s минус l совпадает
[02:12:05.740 --> 02:12:07.740]  с суферсом длины модуль
[02:12:07.740 --> 02:12:09.740]  s минус l.
[02:12:09.740 --> 02:12:11.740]  Поэтому отсюда
[02:12:11.740 --> 02:12:13.740]  автоматически получается, что
[02:12:13.740 --> 02:12:15.740]  периодами строки s являются
[02:12:15.740 --> 02:12:17.740]  в точности. Модуль s
[02:12:17.740 --> 02:12:19.740]  минус там p от модуль s.
[02:12:19.740 --> 02:12:21.740]  Модуль s
[02:12:21.740 --> 02:12:23.740]  минус p от p
[02:12:23.740 --> 02:12:25.740]  от модуль s.
[02:12:25.740 --> 02:12:27.740]  Там модуль s
[02:12:27.740 --> 02:12:29.740]  минус p от p от p, ну и так далее.
[02:12:29.740 --> 02:12:31.740]  В общем, так вот все периоды вы переберете.
[02:12:33.740 --> 02:12:35.740]  Вот.
[02:12:39.740 --> 02:12:41.740]  Вот. То есть вот так
[02:12:41.740 --> 02:12:43.740]  с помощью префикс функции тоже все периоды
[02:12:43.740 --> 02:12:45.740]  прекрасно ищутся.
[02:12:45.740 --> 02:12:47.740]  Так вот.
[02:12:47.740 --> 02:12:49.740]  Что еще... Что еще можно
[02:12:49.740 --> 02:12:51.740]  с помощью этого... Ну вот. Как это нам
[02:12:51.740 --> 02:12:53.740]  помогает? Ну, теперь задача о тандемдах
[02:12:53.740 --> 02:12:55.740]  повторок говорим так. Давайте найдем максимальный
[02:12:55.740 --> 02:12:57.740]  префикс строки s2,
[02:12:57.740 --> 02:12:59.740]  который является l периодично.
[02:12:59.740 --> 02:13:01.740]  Как мы это сделаем?
[02:13:03.740 --> 02:13:05.740]  Ну, просто возьмем z функцию
[02:13:05.740 --> 02:13:07.740]  вот в этой точке и посмотрим, до куда
[02:13:07.740 --> 02:13:09.740]  она нас доведет.
[02:13:09.740 --> 02:13:11.740]  Я вот решаю, что ровно
[02:13:11.740 --> 02:13:13.740]  до куда она дойдет, вот ровно этот
[02:13:13.740 --> 02:13:15.740]  префикс является l периодично. А дальше
[02:13:15.740 --> 02:13:17.740]  нет.
[02:13:33.740 --> 02:13:35.740]  Я вот не очень
[02:13:35.740 --> 02:13:37.740]  понял про...
[02:13:41.740 --> 02:13:43.740]  Ну, давайте попробуем. Что означает,
[02:13:43.740 --> 02:13:45.740]  что префикс является l периодичным,
[02:13:45.740 --> 02:13:47.740]  да? Префикс длины
[02:13:47.740 --> 02:13:49.740]  x является l периодичным, да? Это означает,
[02:13:49.740 --> 02:13:51.740]  что этот символ совпадает с вот этим,
[02:13:51.740 --> 02:13:53.740]  да? Этот символ
[02:13:53.740 --> 02:13:55.740]  совпадает с этим и так далее. То есть, по сути,
[02:13:55.740 --> 02:13:57.740]  вот эти x символов совпадают с префиксом длины
[02:13:57.740 --> 02:13:59.740]  x.
[02:13:59.740 --> 02:14:01.740]  И что?
[02:14:01.740 --> 02:14:03.740]  Строка a, b, c, d, e,
[02:14:03.740 --> 02:14:05.740]  a, b, c, d является
[02:14:05.740 --> 02:14:07.740]  5 периодичной.
[02:14:07.740 --> 02:14:09.740]  А, все, да, да, да,
[02:14:09.740 --> 02:14:11.740]  да, просто у нас a другое.
[02:14:11.740 --> 02:14:13.740]  Ну, ну да.
[02:14:13.740 --> 02:14:15.740]  У нас a не совпадает с длиной, но да,
[02:14:15.740 --> 02:14:17.740]  в таком виде да, в таком виде согласен.
[02:14:17.740 --> 02:14:19.740]  Вот. То есть, получается, все, что нужно,
[02:14:19.740 --> 02:14:21.740]  это... То есть, находимся, функцию находимся.
[02:14:21.740 --> 02:14:23.740]  Но правда, если tx уже оказался l
[02:14:23.740 --> 02:14:25.740]  или более, то ура,
[02:14:25.740 --> 02:14:27.740]  тандемный повтор длины l найден.
[02:14:27.740 --> 02:14:29.740]  Ну, это правда. А теперь,
[02:14:29.740 --> 02:14:31.740]  если это не так, то что нам нужно сделать?
[02:14:31.740 --> 02:14:33.740]  Тогда нам нужно просто
[02:14:33.740 --> 02:14:35.740]  взять, что вот максимальный префикс
[02:14:35.740 --> 02:14:37.740]  длины l, то есть
[02:14:37.740 --> 02:14:39.740]  максимальный префикс строки s2, который l периодичен,
[02:14:39.740 --> 02:14:41.740]  он дошел
[02:14:41.740 --> 02:14:43.740]  вот до сюда. Да?
[02:14:43.740 --> 02:14:45.740]  Теперь наша задача... Хорошо.
[02:14:45.740 --> 02:14:47.740]  То есть, l периодичным образом мы дальше не пойдем
[02:14:47.740 --> 02:14:49.740]  вправо, но насколько мы
[02:14:49.740 --> 02:14:51.740]  можем пройти l периодичным путем влево?
[02:14:53.740 --> 02:14:55.740]  Но для этого мы возьмем вот z функцию
[02:14:55.740 --> 02:14:57.740]  вот из этой строки и поймем,
[02:14:57.740 --> 02:14:59.740]  можем ли мы вот пройти
[02:14:59.740 --> 02:15:01.740]  отсюда хотя бы длину l,
[02:15:01.740 --> 02:15:03.740]  так, чтобы это совпадало с вот этой строкой?
[02:15:03.740 --> 02:15:05.740]  Ну, если мы хотя бы l
[02:15:05.740 --> 02:15:07.740]  тут найдем, то, конечно, тандемный повтор
[02:15:07.740 --> 02:15:09.740]  найден.
[02:15:09.740 --> 02:15:11.740]  У нас же насчитана z функция не из любого символа,
[02:15:11.740 --> 02:15:13.740]  а только из конца. Да, но...
[02:15:13.740 --> 02:15:15.740]  Нет, смотрите. Да, но мы...
[02:15:15.740 --> 02:15:17.740]  Да, но здесь, смотрите,
[02:15:17.740 --> 02:15:19.740]  здесь из любого символа, а здесь
[02:15:19.740 --> 02:15:21.740]  вот это вот, откуда мы идем влево, оно
[02:15:21.740 --> 02:15:23.740]  фиксировано. Ну, короче говоря,
[02:15:23.740 --> 02:15:25.740]  с z функциями понятно,
[02:15:25.740 --> 02:15:27.740]  но зачем это сводить периодично,
[02:15:27.740 --> 02:15:29.740]  не очень понятно. Ну, видимо...
[02:15:29.740 --> 02:15:31.740]  Сейчас еще раз,
[02:15:31.740 --> 02:15:33.740]  Дмитрий, почему не можем сделать следующее?
[02:15:33.740 --> 02:15:35.740]  Вот мы вот эту правую
[02:15:35.740 --> 02:15:37.740]  позицию двигаем,
[02:15:37.740 --> 02:15:39.740]  и проверяем, что если сумма 2z функций,
[02:15:39.740 --> 02:15:41.740]  ну, которую вы сказали,
[02:15:41.740 --> 02:15:43.740]  хотя бы l,
[02:15:43.740 --> 02:15:45.740]  то тогда
[02:15:45.740 --> 02:15:47.740]  мы учитываем. Ну,
[02:15:47.740 --> 02:15:49.740]  тогда тандемный повтор длины 2l найден.
[02:15:49.740 --> 02:15:51.740]  Да.
[02:15:51.740 --> 02:15:53.740]  Так и есть. Но в итоге
[02:15:53.740 --> 02:15:55.740]  так и есть. Мы лишь объясняем, почему
[02:15:55.740 --> 02:15:57.740]  это так.
[02:16:05.740 --> 02:16:07.740]  Так что вот такая вот красота,
[02:16:07.740 --> 02:16:09.740]  вот так вот мы идем, вот так вот хорошо.
[02:16:09.740 --> 02:16:11.740]  Понятно?
[02:16:13.740 --> 02:16:15.740]  То есть как бы если мы вот так вот,
[02:16:15.740 --> 02:16:17.740]  то есть совпадает ли этот с этим, этот с этим,
[02:16:17.740 --> 02:16:19.740]  ну, насколько мы так можем пройти, мы вот
[02:16:19.740 --> 02:16:21.740]  из z функции для этой строки и выкопаем.
[02:16:23.740 --> 02:16:25.740]  Короче, за линию здесь решаем.
[02:16:25.740 --> 02:16:27.740]  Получается, да.
[02:16:27.740 --> 02:16:29.740]  Да, совершенно верно.
[02:16:29.740 --> 02:16:31.740]  Причем так и быстро.
[02:16:31.740 --> 02:16:33.740]  Потому что вот у этой задачи есть
[02:16:33.740 --> 02:16:35.740]  напарник, то есть у этой задачи есть напарник, собственно,
[02:16:35.740 --> 02:16:37.740]  в домашнем задании.
[02:16:37.740 --> 02:16:39.740]  Не супер-быстрый, но нормально.
[02:16:39.740 --> 02:16:41.740]  Ну да, то есть у этой задачи есть напарник. Я даже спалю там
[02:16:41.740 --> 02:16:43.740]  условия сразу, то есть решение сейчас
[02:16:43.740 --> 02:16:45.740]  рассказывать какие будут. Там суть такая, что дана строка длины
[02:16:45.740 --> 02:16:47.740]  тоже там стоили 200, там может даже миллион.
[02:16:47.740 --> 02:16:49.740]  И найдите, пожалуйста,
[02:16:49.740 --> 02:16:51.740]  под строку,
[02:16:51.740 --> 02:16:53.740]  которая наоборот состоит из
[02:16:53.740 --> 02:16:55.740]  конкретинации одинаковой
[02:16:55.740 --> 02:16:57.740]  одной и той же строки,
[02:16:57.740 --> 02:16:59.740]  так, чтобы количество экземпляров этой
[02:16:59.740 --> 02:17:01.740]  строки было как можно больше.
[02:17:01.740 --> 02:17:03.740]  То есть найдите под строку, которая равна
[02:17:03.740 --> 02:17:05.740]  t в степени k, где t не пустая строка,
[02:17:05.740 --> 02:17:07.740]  а k максимально большая.
[02:17:07.740 --> 02:17:09.740]  Понятно.
[02:17:09.740 --> 02:17:11.740]  То есть вот такая задача.
[02:17:11.740 --> 02:17:13.740]  Пораду ли, что ручной проигрок не будет, и можно
[02:17:13.740 --> 02:17:15.740]  везде пихать хэши? Удачи.
[02:17:15.740 --> 02:17:17.740]  Спасибо.
[02:17:17.740 --> 02:17:19.740]  Потому что фишка была такая, потому что в этой задачи
[02:17:19.740 --> 02:17:21.740]  было два решения. Автор задачи уже упоминавшейся ранее
[02:17:21.740 --> 02:17:23.740]  Иван Смирнов.
[02:17:23.740 --> 02:17:25.740]  То же история была такая. То есть мы ее дали на контесте
[02:17:25.740 --> 02:17:27.740]  в Петрозаводске.
[02:17:27.740 --> 02:17:29.740]  И было, и у автора было
[02:17:29.740 --> 02:17:31.740]  вообще два решения. То есть у автора было
[02:17:31.740 --> 02:17:33.740]  решение.
[02:17:33.740 --> 02:17:35.740]  Какой-то там суфмасс
[02:17:35.740 --> 02:17:37.740]  и какой-то с ним анализ. Или можно там пытаться
[02:17:37.740 --> 02:17:39.740]  пихать хэшами.
[02:17:39.740 --> 02:17:41.740]  Вот.
[02:17:41.740 --> 02:17:43.740]  Тоже решение n log n, все хорошо.
[02:17:43.740 --> 02:17:45.740]  Но только у меня сразу возникла
[02:17:45.740 --> 02:17:47.740]  идея, соответственно, вот это вот.
[02:17:47.740 --> 02:17:49.740]  Ну такая же.
[02:17:49.740 --> 02:17:51.740]  Вот. Такого же рода.
[02:17:51.740 --> 02:17:53.740]  Вот. В итоге, когда я в какой-то момент
[02:17:53.740 --> 02:17:55.740]  написал
[02:17:55.740 --> 02:17:57.740]  свое решение, выяснилось, что решение
[02:17:57.740 --> 02:17:59.740]  Иване пришлось отсекать по туэлю. Потому что
[02:17:59.740 --> 02:18:01.740]  мое решение работает в десять раз быстрее.
[02:18:01.740 --> 02:18:03.740]  Да, при той же асимптотике.
[02:18:03.740 --> 02:18:05.740]  То есть, более того, выяснилось,
[02:18:05.740 --> 02:18:07.740]  что у него там даже еще и багов в решении
[02:18:07.740 --> 02:18:09.740]  дошлось. Бывает. Да, потому что
[02:18:09.740 --> 02:18:11.740]  мое решение оказалось просто так.
[02:18:11.740 --> 02:18:13.740]  Еще и проще пишется, помимо всего прочего.
[02:18:13.740 --> 02:18:15.740]  Так я даже сильно удивился, насколько
[02:18:15.740 --> 02:18:17.740]  оно проще пишется.
[02:18:17.740 --> 02:18:19.740]  Вот. То есть фантастика.
[02:18:19.740 --> 02:18:21.740]  Вот. То есть, на самом
[02:18:21.740 --> 02:18:23.740]  контесте, по-моему, задачу
[02:18:23.740 --> 02:18:25.740]  то есть там, по-моему,
[02:18:25.740 --> 02:18:27.740]  возможно, сдал только Геннадий Короткевич.
[02:18:27.740 --> 02:18:29.740]  И то он какие-то двойные
[02:18:29.740 --> 02:18:31.740]  хэши едва-едва там обеими
[02:18:31.740 --> 02:18:33.740]  ногами запихал.
[02:18:33.740 --> 02:18:35.740]  Вот.
[02:18:35.740 --> 02:18:37.740]  Да. Ну вот. То есть такое.
[02:18:37.740 --> 02:18:39.740]  Но на этом контесте была эта байка,
[02:18:39.740 --> 02:18:41.740]  когда он там в какой-то момент прислал там
[02:18:41.740 --> 02:18:43.740]  в какой-то момент сдал задачу,
[02:18:43.740 --> 02:18:45.740]  включает ВА-8. Он там
[02:18:45.740 --> 02:18:47.740]  по брутфорсел, ну там, с его стороны
[02:18:47.740 --> 02:18:49.740]  по брутфорсел у него все работает. Смотрит
[02:18:49.740 --> 02:18:51.740]  в таблице, никто не сдает эту задачу.
[02:18:51.740 --> 02:18:53.740]  То есть, он так передшлёт.
[02:18:53.740 --> 02:18:55.740]  А вы уверены, что у вас там все правильно? Эту по брутфорсел
[02:18:55.740 --> 02:18:57.740]  у меня все работает.
[02:18:57.740 --> 02:18:59.740]  Так. Ну мы смотрим. Ага. Так. Ответ
[02:18:59.740 --> 02:19:01.740]  по модуле миллиард семь. Так. Что выводит Гена?
[02:19:01.740 --> 02:19:03.740]  Ага. Семнадцать цифр. Ага. Ага.
[02:19:03.740 --> 02:19:05.740]  Да. С чистой совестью
[02:19:05.740 --> 02:19:07.740]  написали нол комец.
[02:19:07.740 --> 02:19:09.740]  Вот. Совесть.
[02:19:09.740 --> 02:19:11.740]  Да. Чистота совести подкрепилась
[02:19:11.740 --> 02:19:13.740]  рецептом через три минуты.
[02:19:15.740 --> 02:19:17.740]  Так шаманная вот. Но это была по мне эта задача,
[02:19:17.740 --> 02:19:19.740]  естественно. Ну вот.
[02:19:19.740 --> 02:19:21.740]  Так что вот. Ну это такие вот. Веселые.
[02:19:21.740 --> 02:19:23.740]  Так что делайте контесты в Тетрозаводске.
[02:19:23.740 --> 02:19:25.740]  Будут у вас самих такие истории.
[02:19:25.740 --> 02:19:27.740]  Да.
[02:19:27.740 --> 02:19:29.740]  Так что.
[02:19:29.740 --> 02:19:31.740]  Так что вот. То есть, такая задача.
[02:19:31.740 --> 02:19:33.740]  То есть, вот неожиданным
[02:19:33.740 --> 02:19:35.740]  образом там никаких суфмассов этих ваших
[02:19:35.740 --> 02:19:37.740]  тамуканинов и так далее. То есть, нет, это у нас
[02:19:37.740 --> 02:19:39.740]  все тоже будет, но...
[02:19:39.740 --> 02:19:41.740]  На самом деле общение вот на таких контестах с жюри
[02:19:41.740 --> 02:19:43.740]  иногда выглядит очень
[02:19:43.740 --> 02:19:45.740]  интересно, потому что у жюри буквально
[02:19:45.740 --> 02:19:47.740]  два-три возможных ответа. И они
[02:19:47.740 --> 02:19:49.740]  чаще всего дают однозначное понимание,
[02:19:49.740 --> 02:19:51.740]  что именно, ну как это интерпретировать.
[02:19:51.740 --> 02:19:53.740]  Ну да.
[02:19:53.740 --> 02:19:55.740]  Там варианты
[02:19:55.740 --> 02:19:57.740]  понятны. Да-да-да. Так. Ладно.
[02:19:57.740 --> 02:19:59.740]  Что-то мы опять забалтываемся. Ладно.
[02:19:59.740 --> 02:20:01.740]  То есть, на самом деле серьезно просто вот это
[02:20:01.740 --> 02:20:03.740]  вот. То есть, вот эта вот штука в экзамене будет, если
[02:20:03.740 --> 02:20:05.740]  что. Протендемный повтор.
[02:20:05.740 --> 02:20:07.740]  Поэтому как бы есть ли
[02:20:07.740 --> 02:20:09.740]  тут какие-то вопросы по этому алгоритму?
[02:20:11.740 --> 02:20:13.740]  Вот.
[02:20:13.740 --> 02:20:15.740]  Так что... А? Нет?
[02:20:15.740 --> 02:20:17.740]  Ну там можно просто везать функции и рассказать
[02:20:17.740 --> 02:20:19.740]  нормально. Ну вот эти,
[02:20:19.740 --> 02:20:21.740]  в экзамене. Ну да. Нет, ну
[02:20:21.740 --> 02:20:23.740]  более того, это и будет подразумеваться.
[02:20:23.740 --> 02:20:25.740]  То есть, там...
[02:20:25.740 --> 02:20:27.740]  То есть, Боже упаси
[02:20:27.740 --> 02:20:29.740]  вас в основном упичивать какие-то там...
[02:20:29.740 --> 02:20:31.740]  То есть, там какие-нибудь суфмассы адские.
[02:20:31.740 --> 02:20:33.740]  Я про то, что
[02:20:33.740 --> 02:20:35.740]  периодичность тут на самом деле не нужно рассказывать.
[02:20:35.740 --> 02:20:37.740]  Ну,
[02:20:37.740 --> 02:20:39.740]  на ваше усмотрение. Ну, как бы терминология
[02:20:39.740 --> 02:20:41.740]  это уже другой вопрос.
[02:20:41.740 --> 02:20:43.740]  То есть, другой вопрос, что как бы, да.
[02:20:43.740 --> 02:20:45.740]  Напоминаю, мне эль периодичность интуитивно поняки.
[02:20:45.740 --> 02:20:47.740]  И поэтому, если вы будете
[02:20:47.740 --> 02:20:49.740]  употреблять слова эль периодичности,
[02:20:49.740 --> 02:20:51.740]  понимая принципиально другое, то будьте готовы
[02:20:51.740 --> 02:20:53.740]  к тому, что моя ваша
[02:20:53.740 --> 02:20:55.740]  понимать будет не очень.
[02:20:55.740 --> 02:20:57.740]  Поэтому, как бы,
[02:20:57.740 --> 02:20:59.740]  такие вещи лучше прописывать.
[02:20:59.740 --> 02:21:01.740]  У меня есть
[02:21:01.740 --> 02:21:03.740]  противоположная история, когда в задачу
[02:21:03.740 --> 02:21:05.740]  можно было там вывести небольшой ответ,
[02:21:05.740 --> 02:21:07.740]  а уже по условию, а уже и в тестах
[02:21:07.740 --> 02:21:09.740]  как раз было 17 цифр.
[02:21:09.740 --> 02:21:11.740]  Понятно. Ой-ой-ой.
[02:21:11.740 --> 02:21:13.740]  Бывает. Так, сколько там времени?
[02:21:15.740 --> 02:21:17.740]  Ой-ой-ой. А, ну нет.
[02:21:17.740 --> 02:21:19.740]  Это еще пока не перерыв вроде.
[02:21:19.740 --> 02:21:21.740]  Так.
[02:21:21.740 --> 02:21:23.740]  Так, ну хорошо. Ладно.
[02:21:23.740 --> 02:21:25.740]  Эту задачу мы тоже обсудили.
[02:21:25.740 --> 02:21:27.740]  Обычно я ее обсуждаю ближе к конце, но сейчас, по-моему,
[02:21:27.740 --> 02:21:29.740]  она как раз очень к месту пришлась,
[02:21:29.740 --> 02:21:31.740]  и мы кое-что еще полезное обсудили.
[02:21:33.740 --> 02:21:35.740]  Так же, соответственно,
[02:21:35.740 --> 02:21:37.740]  то есть если вы там ищете какую-нибудь периодичность,
[02:21:37.740 --> 02:21:39.740]  то есть лучше там,
[02:21:39.740 --> 02:21:41.740]  то есть можно там лишними хэшами и не бегать.
[02:21:41.740 --> 02:21:43.740]  Вот.
[02:21:43.740 --> 02:21:45.740]  Так.
[02:21:45.740 --> 02:21:47.740]  Ну, впрочем.
[02:21:47.740 --> 02:21:49.740]  Так. Что же у нас дальше?
[02:21:49.740 --> 02:21:51.740]  Хорошо. Монакера
[02:21:51.740 --> 02:21:53.740]  с полиндробами мы обсудили.
[02:21:53.740 --> 02:21:55.740]  Что же у нас пойдет дальше?
[02:21:55.740 --> 02:21:57.740]  Так.
[02:21:57.740 --> 02:21:59.740]  Ну, это мы обсудили.
[02:21:59.740 --> 02:22:01.740]  Да, алгоритм понятия. Там код, я думаю, тоже понятия.
[02:22:01.740 --> 02:22:03.740]  В общем, ничего интересного такого нет.
[02:22:03.740 --> 02:22:05.740]  Так.
[02:22:05.740 --> 02:22:07.740]  Что-что?
[02:22:07.740 --> 02:22:09.740]  Страна слова обрезались.
[02:22:09.740 --> 02:22:11.740]  Где?
[02:22:11.740 --> 02:22:13.740]  Где?
[02:22:13.740 --> 02:22:15.740]  Полинод.
[02:22:15.740 --> 02:22:17.740]  А, ну это картинка.
[02:22:17.740 --> 02:22:19.740]  Полинод и полиневин
[02:22:19.740 --> 02:22:21.740]  даже могут вычислить.
[02:22:21.740 --> 02:22:23.740]  Вот. Ну, как бы тут отмечается,
[02:22:23.740 --> 02:22:25.740]  что хэши и бинпольск тут тоже
[02:22:25.740 --> 02:22:27.740]  в принципе тащат, но с меньшей асимптотикой.
[02:22:27.740 --> 02:22:29.740]  С большей.
[02:22:29.740 --> 02:22:31.740]  Скажешь так, с менее хорошей асимптотикой.
[02:22:31.740 --> 02:22:33.740]  Вот так.
[02:22:33.740 --> 02:22:35.740]  В этом ты колхоз.
[02:22:35.740 --> 02:22:37.740]  Да.
[02:22:37.740 --> 02:22:39.740]  Ну, да, да, да, да, да.
[02:22:39.740 --> 02:22:41.740]  Ну, то есть это такая.
[02:22:41.740 --> 02:22:43.740]  Это молоток.
[02:22:43.740 --> 02:22:45.740]  Да.
[02:22:45.740 --> 02:22:47.740]  Думал, да.
[02:22:47.740 --> 02:22:49.740]  Дубинка, я бы сказал.
[02:22:49.740 --> 02:22:51.740]  То есть тупая такая, да.
[02:22:51.740 --> 02:22:53.740]  Такая бита, соответственно.
[02:22:53.740 --> 02:22:55.740]  Не, молоток. Если хочешь написать, нужно
[02:22:55.740 --> 02:22:57.740]  обмакнуть где-то голову.
[02:22:57.740 --> 02:22:59.740]  Ладно.
[02:22:59.740 --> 02:23:01.740]  Так, ну что у нас вообще идет дальше?
[02:23:05.740 --> 02:23:07.740]  Вообще по-хорошему дальше, видимо,
[02:23:07.740 --> 02:23:09.740]  я должен вам рассказывать про
[02:23:09.740 --> 02:23:11.740]  ахакарасик.
[02:23:13.740 --> 02:23:15.740]  Ну, вот начинаю думать.
[02:23:15.740 --> 02:23:17.740]  А хочу ли я вам рассказывать про ахакарасик?
[02:23:17.740 --> 02:23:19.740]  Вообще или сегодня?
[02:23:19.740 --> 02:23:21.740]  Нет, именно сейчас.
[02:23:21.740 --> 02:23:23.740]  Ну, просто идейно вообще план
[02:23:23.740 --> 02:23:25.740]  лекции такой. То есть мы сейчас как бы
[02:23:25.740 --> 02:23:27.740]  обсуждали задачу, где нужно искать
[02:23:27.740 --> 02:23:29.740]  поиск одной строки в другой.
[02:23:29.740 --> 02:23:31.740]  По идее,
[02:23:31.740 --> 02:23:33.740]  дальше мы должны перейти на уровень медиум,
[02:23:33.740 --> 02:23:35.740]  где мы должны
[02:23:35.740 --> 02:23:37.740]  искать много подстрок
[02:23:37.740 --> 02:23:39.740]  в одном тексте. Вообще подстроки
[02:23:39.740 --> 02:23:41.740]  заданы заранее. Это, как раз, задача, которая
[02:23:41.740 --> 02:23:43.740]  решает ахакарасик.
[02:23:43.740 --> 02:23:45.740]  Вот.
[02:23:45.740 --> 02:23:47.740]  А потом мы должны перейти к
[02:23:47.740 --> 02:23:49.740]  суффиксным структурам, которые ищут все в онлайне.
[02:23:49.740 --> 02:23:51.740]  И одним из этих алгоритмов
[02:23:51.740 --> 02:23:53.740]  там самым сложным, может быть, будет алгоритм
[02:23:53.740 --> 02:23:55.740]  Уканина.
[02:23:55.740 --> 02:23:57.740]  Нет.
[02:23:57.740 --> 02:23:59.740]  Зянь? Буду.
[02:23:59.740 --> 02:24:01.740]  А мы будем на экзамене.
[02:24:01.740 --> 02:24:03.740]  Я его писал один раз.
[02:24:03.740 --> 02:24:05.740]  Я не хочу
[02:24:05.740 --> 02:24:07.740]  больше его видеть.
[02:24:07.740 --> 02:24:09.740]  Не, вы знаете, он
[02:24:09.740 --> 02:24:11.740]  на самом деле очень красивый. Тем более, что конкретно
[02:24:11.740 --> 02:24:13.740]  Уканина мы, кстати, почти, наверное,
[02:24:13.740 --> 02:24:15.740]  сами напишем. Он очень красивый,
[02:24:15.740 --> 02:24:17.740]  если его не кодит и не дебатит.
[02:24:17.740 --> 02:24:19.740]  Не знаю. Ну, не знаю.
[02:24:19.740 --> 02:24:21.740]  Мне нормально.
[02:24:21.740 --> 02:24:23.740]  Вот. Но вопрос не в этом. На самом деле
[02:24:23.740 --> 02:24:25.740]  просто он действительно сложный.
[02:24:25.740 --> 02:24:27.740]  Но просто исторически
[02:24:27.740 --> 02:24:29.740]  тут
[02:24:29.740 --> 02:24:31.740]  появляется такая красивая вещь, как дерево
[02:24:31.740 --> 02:24:33.740]  полиндровов.
[02:24:33.740 --> 02:24:35.740]  А дерево полиндровов уже нормально пишется.
[02:24:35.740 --> 02:24:37.740]  Ну, вот. Потому что... Ну, как?
[02:24:37.740 --> 02:24:39.740]  Кто знает, что такое дерево полиндровов?
[02:24:39.740 --> 02:24:41.740]  В смысле, слышал?
[02:24:41.740 --> 02:24:43.740]  Ну, давайте. Пока для начала слышал.
[02:24:43.740 --> 02:24:45.740]  Я слышал название. Кто знает, что это такое?
[02:24:45.740 --> 02:24:47.740]  Так кто умеет
[02:24:47.740 --> 02:24:49.740]  его писать?
[02:24:49.740 --> 02:24:51.740]  Вот.
[02:24:55.740 --> 02:24:57.740]  Ну, в идеале
[02:24:57.740 --> 02:24:59.740]  давайте, кто напишет натуре без бумажки?
[02:24:59.740 --> 02:25:01.740]  Ну, за какое время?
[02:25:01.740 --> 02:25:03.740]  Я просто тот
[02:25:03.740 --> 02:25:05.740]  интересный. Вы же у меня просто дерево полиндровов
[02:25:05.740 --> 02:25:07.740]  и запрашивали. Может, по этой причине мы сейчас строки обсуждаем,
[02:25:07.740 --> 02:25:09.740]  а не геома.
[02:25:09.740 --> 02:25:11.740]  В гебаге вопрос. А если вы
[02:25:11.740 --> 02:25:13.740]  это умеете писать с бумажкой, то как бы
[02:25:13.740 --> 02:25:15.740]  зачем оно вам?
[02:25:15.740 --> 02:25:17.740]  А, то есть
[02:25:17.740 --> 02:25:19.740]  ты как заклинание писал?
[02:25:19.740 --> 02:25:21.740]  Ну, я один раз разбирался, но это было
[02:25:21.740 --> 02:25:23.740]  год назад, я уже ничего не помню.
[02:25:23.740 --> 02:25:25.740]  Ну, хорошо.
[02:25:25.740 --> 02:25:27.740]  Ну, хорошо. Ладно.
[02:25:27.740 --> 02:25:29.740]  Так вот. Значит,
[02:25:29.740 --> 02:25:31.740]  к чему я, собственно, это?
[02:25:31.740 --> 02:25:33.740]  Потому что, на самом деле, идея оказалась
[02:25:33.740 --> 02:25:35.740]  интересной факт.
[02:25:35.740 --> 02:25:37.740]  Потому что обычно, на самом деле,
[02:25:37.740 --> 02:25:39.740]  часто дерево полиндровов рассказывается, как такая
[02:25:39.740 --> 02:25:41.740]  идейная перемычка между алгоритмом
[02:25:41.740 --> 02:25:43.740]  Ахакарасика и алгоритмом Уканины.
[02:25:43.740 --> 02:25:45.740]  Вот.
[02:25:45.740 --> 02:25:47.740]  То есть такая.
[02:25:47.740 --> 02:25:49.740]  То есть, в принципе, но исторически
[02:25:49.740 --> 02:25:51.740]  он, конечно, создавался как...
[02:25:51.740 --> 02:25:53.740]  То есть, идеи, основанные
[02:25:53.740 --> 02:25:55.740]  в основе алгоритма обстроения,
[02:25:55.740 --> 02:25:57.740]  это что-то среднее между Ахакарасиком и Уканиным.
[02:25:57.740 --> 02:25:59.740]  Как говорит нам автор, просто автор
[02:25:59.740 --> 02:26:01.740]  статьи в своей же статье.
[02:26:01.740 --> 02:26:03.740]  Вот. Поэтому я вот и думаю.
[02:26:03.740 --> 02:26:05.740]  Вот мне сейчас Ахакарасик вам
[02:26:05.740 --> 02:26:07.740]  рассказывать?
[02:26:07.740 --> 02:26:09.740]  Или рассказать вам дерево полиндровов?
[02:26:09.740 --> 02:26:11.740]  Перемычку. Сразу.
[02:26:11.740 --> 02:26:13.740]  Ну, вот. Ладно.
[02:26:13.740 --> 02:26:15.740]  Вот давайте. Что-то хочется мне сегодня
[02:26:15.740 --> 02:26:17.740]  дерево полиндровов вам рассказывать, да?
[02:26:17.740 --> 02:26:19.740]  Потому что, ладно, Ахакарасик, ну он тоже, конечно,
[02:26:19.740 --> 02:26:21.740]  такой гадостный алгоритм, но его, кажется, знают чуть больше.
[02:26:21.740 --> 02:26:23.740]  Или нет?
[02:26:23.740 --> 02:26:25.740]  Тоже гадостный? Это хорошее начало.
[02:26:25.740 --> 02:26:27.740]  Не, но тоже гадостный,
[02:26:27.740 --> 02:26:29.740]  как Уканин в смысле.
[02:26:29.740 --> 02:26:31.740]  Ну ладно. Полиндромы так полиндромы.
[02:26:31.740 --> 02:26:33.740]  Значит, смотрите. Итак.
[02:26:33.740 --> 02:26:35.740]  Ну, то есть, давайте, как всегда,
[02:26:35.740 --> 02:26:37.740]  прежде чем решать задачу для
[02:26:37.740 --> 02:26:39.740]  каких-то произвольных подстрок, будем
[02:26:39.740 --> 02:26:41.740]  решать задачу для обычных подстрок...
[02:26:41.740 --> 02:26:43.740]  Для полиндромов.
[02:26:43.740 --> 02:26:45.740]  Типа более простая.
[02:26:45.740 --> 02:26:47.740]  Ладно. Итак.
[02:26:47.740 --> 02:26:49.740]  Переходим к дереву полиндровов.
[02:26:49.740 --> 02:26:51.740]  В принципе, для этого можем даже вот эту штуку,
[02:26:51.740 --> 02:26:53.740]  думаю, убрать, потому что у меня нет презентации
[02:26:53.740 --> 02:26:55.740]  на дерево полиндровов.
[02:26:55.740 --> 02:26:57.740]  Вот.
[02:26:57.740 --> 02:26:59.740]  Ну, ничего. Так что, в принципе,
[02:26:59.740 --> 02:27:01.740]  сейчас давайте это выключим.
[02:27:01.740 --> 02:27:03.740]  Спасибо.
[02:27:03.740 --> 02:27:05.740]  Удивительно, на стене, кажется, даже лучше.
[02:27:05.740 --> 02:27:07.740]  Да, но на стене.
[02:27:07.740 --> 02:27:09.740]  А.
[02:27:09.740 --> 02:27:11.740]  О, Господи.
[02:27:11.740 --> 02:27:13.740]  В этом смысле, да?
[02:27:13.740 --> 02:27:15.740]  Ладно. Ой, ребят, а можете свет тогда
[02:27:15.740 --> 02:27:17.740]  включить? Я думаю. Ой.
[02:27:17.740 --> 02:27:19.740]  Давайте тогда.
[02:27:31.740 --> 02:27:33.740]  А, в этом плане. Ну, можно и так.
[02:27:33.740 --> 02:27:35.740]  Значит, смотрите. Так дерево полиндровов.
[02:27:35.740 --> 02:27:37.740]  Значит, о чем речь? Значит, мы хотим решать
[02:27:37.740 --> 02:27:39.740]  такую задачу.
[02:27:39.740 --> 02:27:41.740]  Дана строка С.
[02:27:41.740 --> 02:27:43.740]  Ладно.
[02:27:43.740 --> 02:27:45.740]  Да, дана строка С.
[02:27:45.740 --> 02:27:47.740]  Что мы сейчас еще
[02:27:47.740 --> 02:27:49.740]  будет делать? Дерево полиндровов строить.
[02:27:49.740 --> 02:27:51.740]  То есть, там, то есть, новое, так.
[02:27:51.740 --> 02:27:53.740]  Так, это дети записываем новую тему.
[02:27:53.740 --> 02:27:55.740]  Дерево полиндровов.
[02:27:55.740 --> 02:27:57.740]  Вот.
[02:27:57.740 --> 02:27:59.740]  Так вот, задача будет такая.
[02:27:59.740 --> 02:28:01.740]  Значит, мы, по крайней мере, попытаемся решить такую
[02:28:01.740 --> 02:28:03.740]  интересную задачу.
[02:28:03.740 --> 02:28:05.740]  Дана строка С.
[02:28:05.740 --> 02:28:07.740]  Я хочу сделать на ней какой-нибудь
[02:28:07.740 --> 02:28:09.740]  логический предподсчет.
[02:28:09.740 --> 02:28:11.740]  И после этого отвечать
[02:28:11.740 --> 02:28:13.740]  на запросы. Запрос такой.
[02:28:13.740 --> 02:28:15.740]  Допустим, дана строка
[02:28:15.740 --> 02:28:17.740]  П. В чем именно запрос?
[02:28:17.740 --> 02:28:19.740]  И я хочу где-нибудь там
[02:28:19.740 --> 02:28:21.740]  за О от П
[02:28:21.740 --> 02:28:23.740]  понять, входит ли строка
[02:28:23.740 --> 02:28:25.740]  П в строку С,
[02:28:25.740 --> 02:28:27.740]  как подстрока?
[02:28:27.740 --> 02:28:29.740]  А почему она полиндрома? А полиндромы
[02:28:29.740 --> 02:28:31.740]  при том, что мне известно, что
[02:28:31.740 --> 02:28:33.740]  строка П является
[02:28:33.740 --> 02:28:35.740]  полиндромом.
[02:28:35.740 --> 02:28:37.740]  Вы хотите сказать, что эта задача проще решать,
[02:28:37.740 --> 02:28:39.740]  чем просто входит ли, как подстрока?
[02:28:39.740 --> 02:28:41.740]  Да.
[02:28:41.740 --> 02:28:43.740]  Я утверждаю так.
[02:28:43.740 --> 02:28:45.740]  А входит ли, как подстрока?
[02:28:45.740 --> 02:28:47.740]  Ну, то есть, что существует
[02:28:47.740 --> 02:28:49.740]  подстрока в строке С, существует подстрока
[02:28:49.740 --> 02:28:51.740]  равная П.
[02:28:51.740 --> 02:28:53.740]  Ну, то есть,
[02:28:53.740 --> 02:28:55.740]  суф-автомат.
[02:28:55.740 --> 02:28:57.740]  Ну, в принципе, это задача решать суф-автомат.
[02:28:57.740 --> 02:28:59.740]  Но для этого нам придется там строить суф-автомат
[02:28:59.740 --> 02:29:01.740]  и доказывать, почему он работает.
[02:29:01.740 --> 02:29:03.740]  Это сложно.
[02:29:03.740 --> 02:29:05.740]  Возможно.
[02:29:05.740 --> 02:29:07.740]  Хотя нет, с точки зрения доказательства
[02:29:07.740 --> 02:29:09.740]  не факт.
[02:29:09.740 --> 02:29:11.740]  Да нет, там
[02:29:11.740 --> 02:29:13.740]  не сложно. То есть, код там пишется
[02:29:13.740 --> 02:29:15.740]  на муа, но
[02:29:15.740 --> 02:29:17.740]  с доказательством там может быть сложно.
[02:29:17.740 --> 02:29:19.740]  Много символов, мало идей.
[02:29:19.740 --> 02:29:21.740]  Тихо-тихо, ну понятно, ладно, посмотрим.
[02:29:21.740 --> 02:29:23.740]  Ладно, тут уже на вкус
[02:29:23.740 --> 02:29:25.740]  и цвет. А мы вот, ну я утверждаю,
[02:29:25.740 --> 02:29:27.740]  что если мы ищем полиндромы в строке С,
[02:29:27.740 --> 02:29:29.740]  то все проще.
[02:29:29.740 --> 02:29:31.740]  И первая идея,
[02:29:31.740 --> 02:29:33.740]  почему это так,
[02:29:33.740 --> 02:29:35.740]  она такая. А сколько
[02:29:35.740 --> 02:29:37.740]  вообще различных подполиндромов
[02:29:37.740 --> 02:29:39.740]  являются подстроками строки С?
[02:29:39.740 --> 02:29:41.740]  То есть, обратите,
[02:29:41.740 --> 02:29:43.740]  вот раньше мы смотрели, сколько подстрок
[02:29:43.740 --> 02:29:45.740]  строки С могут быть полиндромными? Мы знали, что
[02:29:45.740 --> 02:29:47.740]  порядка квадрата.
[02:29:47.740 --> 02:29:49.740]  Ну, потому что все подстроки могут быть
[02:29:49.740 --> 02:29:51.740]  полиндромами. Но
[02:29:51.740 --> 02:29:53.740]  если мы возьмем строку А,
[02:29:53.740 --> 02:29:55.740]  то куча из этих подполиндромов
[02:29:55.740 --> 02:29:57.740]  будут одинаковыми.
[02:29:57.740 --> 02:29:59.740]  Так вот, а теперь
[02:29:59.740 --> 02:30:01.740]  меня интересуют, как бы подстроки различаются,
[02:30:01.740 --> 02:30:03.740]  если они различаются на как строки, а не по позиции.
[02:30:03.740 --> 02:30:05.740]  Вы хотите вносить все, посчитать на всех,
[02:30:05.740 --> 02:30:07.740]  и потом просто хрешами издать?
[02:30:07.740 --> 02:30:09.740]  Ну,
[02:30:09.740 --> 02:30:11.740]  нет, мы видим на 7 полиндромов
[02:30:11.740 --> 02:30:13.740]  и решить. Нет, все еще круче будет.
[02:30:13.740 --> 02:30:15.740]  Но хотя бы я вот думаю
[02:30:15.740 --> 02:30:17.740]  так, а сколько их различных вообще? Может быть,
[02:30:17.740 --> 02:30:19.740]  хотя бы их хрешмап покидать и действительно.
[02:30:19.740 --> 02:30:21.740]  Тихо-тихо, спокойно.
[02:30:23.740 --> 02:30:25.740]  Спокойно.
[02:30:25.740 --> 02:30:27.740]  Ой, да ладно, вы на C++
[02:30:27.740 --> 02:30:29.740]  не писали хрешмап, что тебе не поверить?
[02:30:29.740 --> 02:30:31.740]  Хрешмап это как раз отличный.
[02:30:31.740 --> 02:30:33.740]  А нордеритмап писали.
[02:30:33.740 --> 02:30:35.740]  Так вот, смотрите.
[02:30:35.740 --> 02:30:37.740]  Так вот, мистическая идея.
[02:30:37.740 --> 02:30:39.740]  Я утверждаю, что
[02:30:39.740 --> 02:30:41.740]  различных подполиндромов не пустых
[02:30:41.740 --> 02:30:43.740]  в строке S
[02:30:43.740 --> 02:30:45.740]  не более чем
[02:30:45.740 --> 02:30:47.740]  модуль S.
[02:30:49.740 --> 02:30:51.740]  Почему так?
[02:30:51.740 --> 02:30:53.740]  Очень просто.
[02:30:53.740 --> 02:30:55.740]  Давайте припишем к строке S
[02:30:55.740 --> 02:30:57.740]  символ C.
[02:30:57.740 --> 02:30:59.740]  Я утверждаю,
[02:30:59.740 --> 02:31:01.740]  что от этого приписывания
[02:31:01.740 --> 02:31:03.740]  в строке S появится
[02:31:03.740 --> 02:31:05.740]  не более чем один
[02:31:05.740 --> 02:31:07.740]  новый подполиндром.
[02:31:07.740 --> 02:31:09.740]  Но это
[02:31:09.740 --> 02:31:11.740]  очевидно доказывается.
[02:31:11.740 --> 02:31:13.740]  Но спокойно.
[02:31:13.740 --> 02:31:15.740]  Возьмем самый большой, возьмем все остальные,
[02:31:15.740 --> 02:31:17.740]  заметим, что все остальные встречались ранее.
[02:31:17.740 --> 02:31:19.740]  Спокойно. Мы уже поняли, что ты уже все знаешь.
[02:31:19.740 --> 02:31:21.740]  Спокойно, дай другим узнать.
[02:31:21.740 --> 02:31:23.740]  Не все с этим сталкивались.
[02:31:25.740 --> 02:31:27.740]  Так вот, да.
[02:31:27.740 --> 02:31:29.740]  Но доказательства Денис обрисовал совершенно верно.
[02:31:29.740 --> 02:31:31.740]  Предположим, что добавилось
[02:31:31.740 --> 02:31:33.740]  два подполиндрома.
[02:31:33.740 --> 02:31:35.740]  Тогда один из них большей длины, другой
[02:31:35.740 --> 02:31:37.740]  меньшей длины. Но тогда заметим, что
[02:31:37.740 --> 02:31:39.740]  вот эта строка равна вот этой
[02:31:39.740 --> 02:31:41.740]  развернутой строке, так как это полиндром.
[02:31:41.740 --> 02:31:43.740]  Но так как это тоже полиндром,
[02:31:43.740 --> 02:31:45.740]  то эта строка оказывается равна вот этой.
[02:31:45.740 --> 02:31:47.740]  Следовательно, она
[02:31:47.740 --> 02:31:49.740]  уже была.
[02:31:51.740 --> 02:31:53.740]  Все.
[02:31:53.740 --> 02:31:55.740]  То есть, получается, с добавлением
[02:31:55.740 --> 02:31:57.740]  каждого нового символа
[02:31:57.740 --> 02:31:59.740]  мы выясняем,
[02:31:59.740 --> 02:32:01.740]  что у нас
[02:32:01.740 --> 02:32:03.740]  подполиндром
[02:32:03.740 --> 02:32:05.740]  новый не более чем один.
[02:32:05.740 --> 02:32:07.740]  Пока все просто.
[02:32:09.740 --> 02:32:11.740]  Более того, давайте
[02:32:11.740 --> 02:32:13.740]  мысленно можем попытаться
[02:32:13.740 --> 02:32:15.740]  выписать даже все
[02:32:15.740 --> 02:32:17.740]  подполиндромы и запихать их хэшмап.
[02:32:17.740 --> 02:32:19.740]  Это уже похоже на квадрат.
[02:32:19.740 --> 02:32:21.740]  Но тем не менее, давайте это сделаем.
[02:32:21.740 --> 02:32:23.740]  Для строки
[02:32:23.740 --> 02:32:25.740]  какой?
[02:32:25.740 --> 02:32:27.740]  А-ба-ца-ба-а-ба-ба.
[02:32:31.740 --> 02:32:33.740]  Вот давайте
[02:32:33.740 --> 02:32:35.740]  это, значит, смотрите. Чего мы будем делать?
[02:32:35.740 --> 02:32:37.740]  Это кажется хуже, чем квадрат,
[02:32:37.740 --> 02:32:39.740]  потому что для каждой строки мы ищем от ее длины.
[02:32:39.740 --> 02:32:41.740]  Нет, ну, смотри.
[02:32:41.740 --> 02:32:43.740]  Нет, смотри. Выписать
[02:32:43.740 --> 02:32:45.740]  мы можем из эква...
[02:32:45.740 --> 02:32:47.740]  У нас всего строк С.
[02:32:47.740 --> 02:32:49.740]  Ну, смотрите, давайте выписывать.
[02:32:49.740 --> 02:32:51.740]  Давайте выпишем, причем я выпишу
[02:32:51.740 --> 02:32:53.740]  даже отдельно
[02:32:53.740 --> 02:32:55.740]  четные подполиндромы, отдельно нечетные.
[02:32:55.740 --> 02:32:57.740]  Вот нечетные я буду выписывать красным цветом.
[02:32:57.740 --> 02:32:59.740]  Какие у меня есть нечетные полиндромы?
[02:32:59.740 --> 02:33:01.740]  Ну, поехали.
[02:33:01.740 --> 02:33:03.740]  Ну, во-первых, А, Б, С.
[02:33:03.740 --> 02:33:05.740]  Во-вторых, что еще есть?
[02:33:05.740 --> 02:33:07.740]  Ну, давайте вот так. Пум-пум.
[02:33:07.740 --> 02:33:09.740]  Очевидно А-ба.
[02:33:09.740 --> 02:33:11.740]  А-ца.
[02:33:11.740 --> 02:33:13.740]  Так, тут Аут, тут А-ца.
[02:33:13.740 --> 02:33:15.740]  И сразу Ба-цаб.
[02:33:15.740 --> 02:33:17.740]  Давайте вот от этого центра не уходить.
[02:33:17.740 --> 02:33:19.740]  А-баб еще есть?
[02:33:19.740 --> 02:33:21.740]  Дойдем. Мы же не в порядке длинный.
[02:33:21.740 --> 02:33:23.740]  Я хочу идти вот так слева направо
[02:33:23.740 --> 02:33:25.740]  и выписывать то, что вижу.
[02:33:25.740 --> 02:33:27.740]  Вот.
[02:33:27.740 --> 02:33:29.740]  То есть с этой точки зрения даже я вот сделаю.
[02:33:29.740 --> 02:33:31.740]  Но так, чтобы точно ничего не упустить,
[02:33:31.740 --> 02:33:33.740]  тогда надо написать вот так.
[02:33:33.740 --> 02:33:35.740]  Сначала А-ба, потом Ц.
[02:33:35.740 --> 02:33:37.740]  Тут мы пишем Ба-цаб.
[02:33:37.740 --> 02:33:39.740]  Так, и дальше. Ой.
[02:33:39.740 --> 02:33:41.740]  Даже до А-бацаба мы и дошли.
[02:33:41.740 --> 02:33:43.740]  Наша любимая А-бацаб.
[02:33:43.740 --> 02:33:45.740]  Так, что дальше?
[02:33:45.740 --> 02:33:47.740]  Так, тут мимо. Так, А-ба.
[02:33:47.740 --> 02:33:49.740]  Аут. А-ба было дальше. Аут.
[02:33:49.740 --> 02:33:51.740]  Так, тут Аут.
[02:33:51.740 --> 02:33:53.740]  Аут и Ба-б.
[02:33:55.740 --> 02:33:57.740]  Ба-б и потом А-баб.
[02:33:57.740 --> 02:33:59.740]  Да.
[02:33:59.740 --> 02:34:01.740]  И А-баба тоже есть.
[02:34:01.740 --> 02:34:03.740]  Все.
[02:34:03.740 --> 02:34:05.740]  Так, что у нас еще есть?
[02:34:05.740 --> 02:34:07.740]  Так, нечетные мы вроде
[02:34:07.740 --> 02:34:09.740]  все запомнили.
[02:34:09.740 --> 02:34:11.740]  А как сделать четные?
[02:34:11.740 --> 02:34:13.740]  Вот, у нас только в одном месте
[02:34:13.740 --> 02:34:15.740]  две буквы совпадают.
[02:34:15.740 --> 02:34:17.740]  Поэтому пишем А-а.
[02:34:17.740 --> 02:34:19.740]  Дальше пишем
[02:34:19.740 --> 02:34:21.740]  Ба-аб.
[02:34:21.740 --> 02:34:23.740]  И дальше пишем А-ба-аба.
[02:34:25.740 --> 02:34:27.740]  Так, тут еще вроде все.
[02:34:31.740 --> 02:34:33.740]  Так, но на самом деле здесь легко убедиться,
[02:34:33.740 --> 02:34:35.740]  что все. Заметим, что мы нашли 12
[02:34:35.740 --> 02:34:37.740]  подполингромов, а для нас в ряке 12.
[02:34:37.740 --> 02:34:39.740]  Так что у нас теория
[02:34:39.740 --> 02:34:41.740]  уже говорит, что больше мы ничего не найдем.
[02:34:43.740 --> 02:34:45.740]  Так редко бывает, конечно.
[02:34:45.740 --> 02:34:47.740]  Но теперь возникает
[02:34:47.740 --> 02:34:49.740]  естественный вопрос.
[02:34:49.740 --> 02:34:51.740]  Как эти строки вообще...
[02:34:51.740 --> 02:34:53.740]  Что же это за такая структура данных
[02:34:53.740 --> 02:34:55.740]  мистическая,
[02:34:55.740 --> 02:34:57.740]  в которой можно искать строки?
[02:34:57.740 --> 02:34:59.740]  Ну, кроме хэш-сета, конечно.
[02:35:01.740 --> 02:35:03.740]  Ну да, что это за структура данных,
[02:35:03.740 --> 02:35:05.740]  в которой можно добавить строку, например,
[02:35:05.740 --> 02:35:07.740]  удалить строку и
[02:35:07.740 --> 02:35:09.740]  спрашивать, есть ли такая строка.
[02:35:09.740 --> 02:35:11.740]  Но есть такая известная
[02:35:11.740 --> 02:35:13.740]  структура данных, называется
[02:35:13.740 --> 02:35:15.740]  БОР.
[02:35:15.740 --> 02:35:17.740]  Надо ли рассказывать, что такое БОР?
[02:35:17.740 --> 02:35:19.740]  Кто знает, что такое БОР?
[02:35:25.740 --> 02:35:27.740]  Кстати, парадокс. БОР является
[02:35:27.740 --> 02:35:29.740]  детерминированным автоматом.
[02:35:31.740 --> 02:35:33.740]  То есть это такой
[02:35:33.740 --> 02:35:35.740]  автомат, у которого никакие две стрелочки
[02:35:35.740 --> 02:35:37.740]  в одну вершину не ведут.
[02:35:37.740 --> 02:35:39.740]  Просто у нас есть другие предметы,
[02:35:39.740 --> 02:35:41.740]  на которые мы только и занимаемся,
[02:35:41.740 --> 02:35:43.740]  что задаем автоматом множество слов.
[02:35:43.740 --> 02:35:45.740]  Ну понятно, да-да, я знаю.
[02:35:49.740 --> 02:35:51.740]  Идея такая, в принципе, мы могли бы
[02:35:51.740 --> 02:35:53.740]  запихнуть все эти слова в БОР
[02:35:55.740 --> 02:35:57.740]  и сказать, что давайте
[02:35:57.740 --> 02:35:59.740]  теперь любой полиндром искать
[02:35:59.740 --> 02:36:01.740]  в этом БОРе. Но размер такого
[02:36:01.740 --> 02:36:03.740]  БОРа будет квадрат.
[02:36:03.740 --> 02:36:05.740]  Логично, да?
[02:36:05.740 --> 02:36:07.740]  Ну если прям вот так
[02:36:07.740 --> 02:36:09.740]  строки писать.
[02:36:09.740 --> 02:36:11.740]  Ну тут у нас возникает интересная фишка.
[02:36:11.740 --> 02:36:13.740]  Так как строка полиндром, то в общем-то
[02:36:13.740 --> 02:36:15.740]  проверять можно не строку, а только
[02:36:15.740 --> 02:36:17.740]  ее половинку.
[02:36:17.740 --> 02:36:19.740]  Потому что если мы это равно.
[02:36:19.740 --> 02:36:21.740]  То есть давайте проверять, допустим, правую
[02:36:21.740 --> 02:36:23.740]  половинку.
[02:36:23.740 --> 02:36:25.740]  Ну а в нечетных строчках
[02:36:25.740 --> 02:36:27.740]  будем искать, будем эту правую половинку
[02:36:27.740 --> 02:36:29.740]  брать, типа большую половину, начиная
[02:36:29.740 --> 02:36:31.740]  с полиндрома.
[02:36:31.740 --> 02:36:33.740]  И давайте их запишем в БОР.
[02:36:35.740 --> 02:36:37.740]  Но тогда я утверждаю, что вот этот
[02:36:37.740 --> 02:36:39.740]  БОР на 9...
[02:36:39.740 --> 02:36:41.740]  Сколько у нас? Раз, два, три, четыре, девять
[02:36:41.740 --> 02:36:43.740]  символов. Я утверждаю, что нам потребуется
[02:36:43.740 --> 02:36:45.740]  всего девять... В этом БОРе
[02:36:45.740 --> 02:36:47.740]  будет всего девять вершин, плюс корневая.
[02:36:49.740 --> 02:36:51.740]  Почему так?
[02:36:51.740 --> 02:36:53.740]  Ну очевидно почему.
[02:36:53.740 --> 02:36:55.740]  Потому что если какое-то слово
[02:36:55.740 --> 02:36:57.740]  является правой половинкой полиндрома,
[02:36:57.740 --> 02:36:59.740]  то очевидно, что если от него отпилить один символ,
[02:36:59.740 --> 02:37:01.740]  то это слово тоже
[02:37:01.740 --> 02:37:03.740]  будет правой половинкой полиндрома.
[02:37:03.740 --> 02:37:05.740]  И все его префиксы.
[02:37:05.740 --> 02:37:07.740]  То есть когда я, например, САБа
[02:37:07.740 --> 02:37:09.740]  добавлю в этот БОР потенциальный,
[02:37:09.740 --> 02:37:11.740]  то у меня и
[02:37:11.740 --> 02:37:13.740]  добавлю не один
[02:37:13.740 --> 02:37:15.740]  под полиндром, а сразу четыре.
[02:37:15.740 --> 02:37:17.740]  Так у меня и получится.
[02:37:17.740 --> 02:37:19.740]  У меня тут получится а, у меня получится
[02:37:19.740 --> 02:37:21.740]  б, у меня получится с,
[02:37:21.740 --> 02:37:23.740]  у меня получится са, у меня
[02:37:23.740 --> 02:37:25.740]  получится са.. САБа, короче.
[02:37:25.740 --> 02:37:31.900]  короче, что-то еще у меня получится, або у меня получится, и або у меня получится,
[02:37:31.900 --> 02:37:32.900]  так что-то, и ба.
[02:37:32.900 --> 02:37:36.580]  Причем все состояния конечны.
[02:37:36.580 --> 02:37:37.580]  Но по сути да.
[02:37:37.580 --> 02:37:39.900]  То есть каждое состояние задает под полингром.
[02:37:39.900 --> 02:37:40.900]  Да.
[02:37:40.900 --> 02:37:41.900]  Вот.
[02:37:41.900 --> 02:37:45.700]  Но правда заметим, что у нас половинка А может означать
[02:37:45.700 --> 02:37:49.140]  и нечетный полингром, и четный полингром.
[02:37:49.140 --> 02:37:50.820]  Давайте два отдельных дерева замесить.
[02:37:50.820 --> 02:37:52.820]  Нет, давайте просто решетки поставим.
[02:37:52.820 --> 02:37:54.980]  Нет, мы не будем ставить решетки.
[02:37:54.980 --> 02:37:58.860]  Мы действительно заведем два дерева.
[02:37:58.860 --> 02:38:01.300]  И получается определение.
[02:38:01.300 --> 02:38:04.380]  Дерево полингромов, то есть дерево полингромов для
[02:38:04.380 --> 02:38:07.980]  строки, это два бора правых половинок.
[02:38:07.980 --> 02:38:12.780]  Да, парадокс, что дерево – это по факту два дерева.
[02:38:12.780 --> 02:38:17.140]  Хотя вы правильно заметили, что если бы вставили диезики,
[02:38:17.140 --> 02:38:19.500]  то можно было бы сделать единое дерево полингромов.
[02:38:19.500 --> 02:38:23.660]  Ну, это чисто нанечетные полингромы.
[02:38:24.660 --> 02:38:27.660]  Но обычно как-то не странно все-таки строят имена.
[02:38:27.660 --> 02:38:30.660]  Либо мы можем какой-нибудь условный там опсилон-переход
[02:38:30.660 --> 02:38:32.660]  нарисовать из одной корневой борьбы.
[02:38:32.660 --> 02:38:36.660]  Не-не-не, он будет не опсилон-переход.
[02:38:36.660 --> 02:38:37.660]  Вот.
[02:38:37.660 --> 02:38:39.660]  Так смотрите, более…
[02:38:39.660 --> 02:38:40.660]  То есть длинный переход.
[02:38:40.660 --> 02:38:48.660]  Значит, если мы такую мистику построим, то есть каким-то
[02:38:48.660 --> 02:38:51.660]  образом, то искать полингромные подстройки в строке можем…
[02:38:51.660 --> 02:38:53.660]  То есть искать полингромные подстройки в строке можем
[02:38:53.660 --> 02:38:55.660]  за один проход по этому бору.
[02:38:55.660 --> 02:38:56.660]  Правда?
[02:38:56.660 --> 02:38:57.660]  Да.
[02:38:57.660 --> 02:38:58.660]  Вот.
[02:38:58.660 --> 02:39:00.660]  Осталось только это построить.
[02:39:02.660 --> 02:39:03.660]  Внимание, вопрос.
[02:39:03.660 --> 02:39:06.660]  Как же это построить?
[02:39:06.660 --> 02:39:09.660]  Ну, хочется сказать, что у него суммарная величина
[02:39:09.660 --> 02:39:10.660]  будет маленькая.
[02:39:10.660 --> 02:39:11.660]  Нет, ну суммарная…
[02:39:11.660 --> 02:39:13.660]  Нет, мы уже выяснили, что суммарная величина этих
[02:39:13.660 --> 02:39:15.660]  двух деревьев не более чем модуле с плюс два.
[02:39:15.660 --> 02:39:21.660]  Потому что а, каждая вершина задает под полингром.
[02:39:21.660 --> 02:39:23.660]  А, каждая вершина задает под полингром.
[02:39:23.660 --> 02:39:24.660]  Вот.
[02:39:24.660 --> 02:39:26.660]  А всего у нас под полингром не более чем модуле с.
[02:39:26.660 --> 02:39:29.660]  Поэтому получается, что размер этой штуки линеен.
[02:39:29.660 --> 02:39:32.660]  Ну, это уже было…
[02:39:32.660 --> 02:39:34.660]  Но, я скажу больше.
[02:39:34.660 --> 02:39:36.660]  Если вы к строке с…
[02:39:36.660 --> 02:39:40.660]  То есть у нас будет такая идея, можно сказать, украниновская.
[02:39:40.660 --> 02:39:42.660]  То есть потому что как мы это будем строить?
[02:39:42.660 --> 02:39:43.660]  Мы будем строить так.
[02:39:43.660 --> 02:39:46.660]  Мы начнем с пустой строки и будем приписывать к ней
[02:39:46.660 --> 02:39:47.660]  по одному символу.
[02:39:47.660 --> 02:39:52.660]  И при каждом приписывании я буду модифицировать
[02:39:52.660 --> 02:39:54.660]  уже существующее дерево полингромов.
[02:39:54.660 --> 02:39:58.660]  Почему у нас есть надежда, что все будет хорошо?
[02:39:58.660 --> 02:40:01.660]  То есть у нас эта надежда сейчас подкрепляется тем,
[02:40:01.660 --> 02:40:05.660]  что, смотрите, когда мы приписываем новый символ,
[02:40:05.660 --> 02:40:09.660]  у нас появляется не более чем один новый подполингром.
[02:40:10.660 --> 02:40:13.660]  Более того, с точки зрения дерева полингромов
[02:40:13.660 --> 02:40:15.660]  можно легко заметить, что у нас оно будет…
[02:40:15.660 --> 02:40:21.660]  То есть по сравнению со старым будет только одно отличие.
[02:40:21.660 --> 02:40:24.660]  Появится одна новая вершинка.
[02:40:27.660 --> 02:40:30.660]  Потому что если вот этот полингром, самый длинный подполингром,
[02:40:30.660 --> 02:40:33.660]  который является сейчас суффиксом, он новый,
[02:40:33.660 --> 02:40:37.660]  то заметим, что если отпилить символ в конце и символ в начале,
[02:40:37.660 --> 02:40:40.660]  то получится подполингром, который там в строке S уже был.
[02:40:40.660 --> 02:40:43.660]  Там опять какие-то суффиксные ссылки фигачить надо.
[02:40:43.660 --> 02:40:45.660]  Что значит опять? У нас еще не было суффиксных ссылок.
[02:40:45.660 --> 02:40:48.660]  Мы впервые в жизни еще не обсуждали ахкарасик,
[02:40:48.660 --> 02:40:51.660]  поэтому у нас еще не было суффиксных ссылок.
[02:40:51.660 --> 02:40:54.660]  Так что впервые мы сейчас познакомимся именно здесь,
[02:40:54.660 --> 02:40:55.660]  с ними.
[02:40:55.660 --> 02:40:58.660]  Но ничего страшного.
[02:40:58.660 --> 02:41:00.660]  То есть получается, что когда вы добавили новый символ,
[02:41:00.660 --> 02:41:04.660]  то есть просто надо найти этот максимальный, получается, суффикс
[02:41:04.660 --> 02:41:07.660]  и где-то вот этот переходик приписать.
[02:41:07.660 --> 02:41:11.660]  Или неожиданно выяснить, что это на самом деле подполингром,
[02:41:11.660 --> 02:41:13.660]  он не является новым,
[02:41:13.660 --> 02:41:18.660]  поэтому на самом деле дерево полингромов не поменялось.
[02:41:20.660 --> 02:41:23.660]  То есть вот такая мистическая идея.
[02:41:25.660 --> 02:41:29.660]  Вот как же эту мистическую идею реализовать?
[02:41:30.660 --> 02:41:33.660]  И причем тут два указания?
[02:41:34.660 --> 02:41:36.660]  Но для этого мы ответим на такой вопрос.
[02:41:36.660 --> 02:41:39.660]  Надо ли перед этим сделать перерыв?
[02:41:40.660 --> 02:41:44.660]  Давайте попробуем строить вот такое дерево полингромов
[02:41:44.660 --> 02:41:48.660]  с помощью, допустим, хэш-мапы.
[02:41:51.660 --> 02:41:53.660]  Где... Смотрите.
[02:41:53.660 --> 02:41:55.660]  Ну, подполингромов-то у нас не сильно много, правда?
[02:41:55.660 --> 02:41:59.660]  Давайте я хэш каждого подполингрома буду хранить в какой-нибудь мапе.
[02:41:59.660 --> 02:42:02.660]  Почему мапе, а не сете?
[02:42:03.660 --> 02:42:05.660]  Ну, чем мапа от сета отличается?
[02:42:05.660 --> 02:42:07.660]  Помните, да?
[02:42:13.660 --> 02:42:15.660]  Ну да, напоминаю, мапа отличается от сета тем,
[02:42:15.660 --> 02:42:17.660]  что в сете есть только ключи,
[02:42:17.660 --> 02:42:21.660]  а в мапе рядом с ключом находится значение какое-то.
[02:42:23.660 --> 02:42:25.660]  Ну, это в сете null-type.
[02:42:25.660 --> 02:42:31.660]  А в мапе это значение, оно будет вершина.
[02:42:32.660 --> 02:42:34.660]  В уже построенном дерево полингромов.
[02:42:35.660 --> 02:42:37.660]  Понимаете, да?
[02:42:40.660 --> 02:42:44.660]  Потому что, смотрите, как тогда, если мы верим в эту хэш-мапу,
[02:42:44.660 --> 02:42:48.660]  то на самом деле мы сейчас без всяких суффиксных ссылок,
[02:42:48.660 --> 02:42:52.660]  без всяких заморочек построим дерево полингромов
[02:42:52.660 --> 02:42:56.660]  с помощью уже полюбившегося нам методу двух указателей.
[02:42:57.660 --> 02:43:01.660]  Значит, магия очень простая.
[02:43:01.660 --> 02:43:05.660]  Итак, предположим, что у нас уже есть строка S.
[02:43:05.660 --> 02:43:09.660]  Значит, сейчас мы предположим, что у нас уже есть строка S.
[02:43:09.660 --> 02:43:12.660]  И для строки S дерево полингромов построено.
[02:43:12.660 --> 02:43:15.660]  А также соответствующая хэш-мапа тоже есть.
[02:43:15.660 --> 02:43:18.660]  Теперь мы приписываем к строке S символ C
[02:43:18.660 --> 02:43:23.660]  и хотим понять, как нам надо поменять дерево полингромов и хэш-мап.
[02:43:23.660 --> 02:43:26.660]  Но поменять ее надо понятно каким образом.
[02:43:26.660 --> 02:43:29.660]  Все, что нам нужно, это получается понять,
[02:43:29.660 --> 02:43:34.660]  нашелся ли у нас какой-то новый подполингром, правда?
[02:43:39.660 --> 02:43:42.660]  Задача фактически теперь такая.
[02:43:42.660 --> 02:43:46.660]  Надо найти максимальный суффикс этой строки,
[02:43:46.660 --> 02:43:49.660]  который является полингромом.
[02:43:49.660 --> 02:43:52.660]  И просто проверить, есть ли он в хэш-мапе,
[02:43:52.660 --> 02:43:55.660]  если нет, добавить.
[02:43:55.660 --> 02:43:58.660]  Причем как добавить? Не просто в хэшах добавить,
[02:43:58.660 --> 02:44:01.660]  а еще и заметить, что вот этот полингром у нас уже был,
[02:44:01.660 --> 02:44:04.660]  и от него получается вот есть вот этот новый переход
[02:44:04.660 --> 02:44:07.660]  по символу C получается.
[02:44:07.660 --> 02:44:10.660]  Так что вот такая идея.
[02:44:10.660 --> 02:44:13.660]  Как же мы это будем делать?
[02:44:13.660 --> 02:44:16.660]  Как мы это будем делать двумя указателями?
[02:44:16.660 --> 02:44:19.660]  Идея будет такая.
[02:44:20.660 --> 02:44:23.660]  Мы будем в явном виде.
[02:44:28.660 --> 02:44:31.660]  Все, есть кто-нибудь?
[02:44:31.660 --> 02:44:34.660]  Или вы опять это на финише контеста
[02:44:34.660 --> 02:44:37.660]  параллельно две задачи решаете?
[02:44:42.660 --> 02:44:45.660]  На очереди? На какой очереди?
[02:44:45.660 --> 02:44:48.660]  А в плавающем окне?
[02:44:48.660 --> 02:44:51.660]  Ой-ой-ой.
[02:44:51.660 --> 02:44:54.660]  Ну, удачи, да.
[02:44:54.660 --> 02:44:57.660]  Ну, значит, смотрите.
[02:44:57.660 --> 02:45:00.660]  Как без очеред делать, вы уже поняли.
[02:45:00.660 --> 02:45:03.660]  Молодцы.
[02:45:03.660 --> 02:45:06.660]  Попробуем сравнить, совпало ли у меня представление с вашим.
[02:45:06.660 --> 02:45:09.660]  Идея такая. В каждый момент времени мы храним не только
[02:45:09.660 --> 02:45:12.660]  дерево полингромов и хэш-мапу, но и вот эти два указателя.
[02:45:13.660 --> 02:45:16.660]  То есть два указателя, которые...
[02:45:16.660 --> 02:45:19.660]  Ну, один указывает тупо на конец строки, а вот левый
[02:45:19.660 --> 02:45:22.660]  будет указывать на начало вот такой максимальной
[02:45:22.660 --> 02:45:25.660]  подлине суффикса, который является полингромом.
[02:45:25.660 --> 02:45:28.660]  Понятно, да?
[02:45:28.660 --> 02:45:31.660]  То есть мы будем это в явном виде хранить.
[02:45:31.660 --> 02:45:34.660]  Потому что первая идея вот такая.
[02:45:34.660 --> 02:45:37.660]  Когда вы приписываете к строке символ C, то какой
[02:45:37.660 --> 02:45:40.660]  самый длинный суффикс полингром может быть?
[02:45:40.660 --> 02:45:43.660]  Это тот же самый полингром, что был раньше,
[02:45:43.660 --> 02:45:46.660]  только расширенный на два символа, правда?
[02:45:46.660 --> 02:45:49.660]  То есть тогда получается так.
[02:45:49.660 --> 02:45:52.660]  Смотрите, мы сдвигаем, получается, левый указатель
[02:45:52.660 --> 02:45:55.660]  на один влево, правый на один вправо.
[02:45:55.660 --> 02:45:58.660]  То есть два указателя, но при этом левый указатель
[02:45:58.660 --> 02:46:01.660]  может двигаться назад.
[02:46:01.660 --> 02:46:04.660]  Но адекватно двигается, потому что он на каждом шаге
[02:46:04.660 --> 02:46:07.660]  будет двигаться налево-влево не более чем на один.
[02:46:07.660 --> 02:46:10.660]  Но тогда, смотрите, идея получается такая.
[02:46:10.660 --> 02:46:13.660]  Значит, проверяем, является ли это строка полингромом.
[02:46:13.660 --> 02:46:16.660]  Давайте это просто то есть с помощью хэшей.
[02:46:16.660 --> 02:46:19.660]  Да, кстати, хэши такая приятная штука, что при
[02:46:19.660 --> 02:46:22.660]  приписывании символа справа хэш легко пересчитывается.
[02:46:22.660 --> 02:46:25.660]  Так вот, проверяем.
[02:46:25.660 --> 02:46:28.660]  Если это полингром, то значит мы его там добавляем
[02:46:28.660 --> 02:46:31.660]  в дерево полингромов, если надо.
[02:46:31.660 --> 02:46:34.660]  Если это оказался не полингром, то что делать?
[02:46:34.660 --> 02:46:37.660]  Тогда сдвигаем этот указатель на один, проверяем,
[02:46:37.660 --> 02:46:40.660]  является ли это строка полингромом.
[02:46:40.660 --> 02:46:43.660]  Если нет, то проверяем, является ли это строка полингромом.
[02:46:43.660 --> 02:46:46.660]  Это и так до тех пор, пока вот строка реально
[02:46:46.660 --> 02:46:49.660]  являющейся полингромом не найдется.
[02:46:54.660 --> 02:46:57.660]  И тогда все, что нам теперь останется, то есть максимально
[02:46:57.660 --> 02:47:00.660]  этот подполингром мы нашли, остается только с помощью
[02:47:00.660 --> 02:47:03.660]  хэш-мапы проверить, есть ли он у нас уже среди полингромов,
[02:47:03.660 --> 02:47:06.660]  если нет, добавить и в дерево полингромов тоже его
[02:47:06.660 --> 02:47:09.660]  добавить. А проверка, что то, что в конце полингромов
[02:47:09.660 --> 02:47:12.660]  мы тоже с помощью хэш-мапы делаем? Даже просто с помощью
[02:47:12.660 --> 02:47:15.660]  хэшей. Мы же умеем с помощью хэшей проверять,
[02:47:15.660 --> 02:47:18.660]  является ли под строка полингромов.
[02:47:21.660 --> 02:47:24.660]  Ну смотрите, у нас идея такая, мы все хэши
[02:47:24.660 --> 02:47:27.660]  полингромов храним в хэш-мапе.
[02:47:27.660 --> 02:47:30.660]  Для удобства мы завозим даже не один хэш-мап,
[02:47:30.660 --> 02:47:34.660]  а Н хэш-мапов, где в каждом хэш-мапе номер L мы храним
[02:47:34.660 --> 02:47:37.660]  только хэши для подполингромов длины L.
[02:47:39.660 --> 02:47:42.660]  Ну это чтоб совсем удобно было.
[02:47:42.660 --> 02:47:45.660]  Что мы храним в хэш-мапе? Для каждого полингрома
[02:47:45.660 --> 02:47:48.660]  хэша, полингрома потенциального мы храним,
[02:47:48.660 --> 02:47:51.660]  ну мы можем хранить, где этот полингром мы вообще
[02:47:51.660 --> 02:47:54.660]  откопали, в какой подстроке. Ну то есть такая идея,
[02:47:54.660 --> 02:47:57.660]  что мы в хэш-мапе можем хранить не сам полингром,
[02:47:57.660 --> 02:48:00.660]  а только индексы его вхождения в строку S.
[02:48:01.660 --> 02:48:04.660]  Во-первых, это можно хранить, а во-вторых,
[02:48:04.660 --> 02:48:07.660]  что самое главное, мы храним в какой вершине дерева
[02:48:07.660 --> 02:48:10.660]  полингромов, какая вершина дерева полингромов соответствует
[02:48:10.660 --> 02:48:13.660]  именно этому подполингрому.
[02:48:13.660 --> 02:48:16.660]  То есть вот такая идея.
[02:48:16.660 --> 02:48:19.660]  Теперь идея такая, предположим, что нам пришел
[02:48:19.660 --> 02:48:22.660]  символ C, и мы нашли подполингром,
[02:48:22.660 --> 02:48:25.660]  который раньше не встречался.
[02:48:26.660 --> 02:48:29.660]  Но это очевидно, это может быть только самый длинный
[02:48:29.660 --> 02:48:32.660]  суффикс этой строки S+, который является полингромом.
[02:48:32.660 --> 02:48:36.660]  Получается, нужно N в четвертой относительно длины строки
[02:48:36.660 --> 02:48:39.660]  хэш, чтобы проверять, что
[02:48:39.660 --> 02:48:42.660]  все подстроки были различные.
[02:48:42.660 --> 02:48:45.660]  В смысле? Зачем?
[02:48:45.660 --> 02:48:48.660]  Ну у нас типа N квадрат подстрок и вероятность коллизии и корень.
[02:48:48.660 --> 02:48:51.660]  Ну, если корень... Ну погоди, давайте так, я использую
[02:48:51.660 --> 02:48:54.660]  сейчас хэши как черный ящик. Я предполагаю, что у меня хэши
[02:48:54.660 --> 02:48:57.660]  идеальные и коллизий нет.
[02:48:57.660 --> 02:49:00.660]  Потому что моя идея будет заключать в том, что потом я расскажу технологию,
[02:49:00.660 --> 02:49:03.660]  как избавиться от этих хэшей.
[02:49:03.660 --> 02:49:06.660]  Вот, поэтому пока предполагаем, что хэши идеальны.
[02:49:06.660 --> 02:49:09.660]  Нет, пока мы считаем, что они идеальны.
[02:49:09.660 --> 02:49:12.660]  Тогда идея такая.
[02:49:12.660 --> 02:49:15.660]  Значит, тогда получается, как добавить новый подполингром?
[02:49:15.660 --> 02:49:18.660]  Идея очень простая.
[02:49:18.660 --> 02:49:21.660]  Ну, заметим, что этот подполингром, если он не из одного символа
[02:49:21.660 --> 02:49:24.660]  С, то он как бы состоит из символа С в начале, символа С в конце
[02:49:24.660 --> 02:49:27.660]  и вот уже имеющегося у нас в хэшмапе деревья полингромов
[02:49:27.660 --> 02:49:30.660]  полингрома, который был раньше.
[02:49:30.660 --> 02:49:33.660]  То есть надо просто найти его вершину через хэшмапу
[02:49:33.660 --> 02:49:36.660]  и построить из него переход по символу С в новую вершину.
[02:49:36.660 --> 02:49:39.660]  Или убедиться, что там переход по символу С и так и есть
[02:49:39.660 --> 02:49:42.660]  и понять, что этот подполингром в хэшмапе уже тоже есть.
[02:49:42.660 --> 02:49:45.660]  Понятно, да?
[02:49:45.660 --> 02:49:48.660]  То есть получается вот так с помощью N хэшмапа
[02:49:48.660 --> 02:49:51.660]  ну или там одного хэшмапа, как вам удобно,
[02:49:51.660 --> 02:49:54.660]  мы можем построить дерево полингромов,
[02:49:54.660 --> 02:49:57.660]  обратите внимание, за два указателя, то есть за лигию.
[02:50:02.660 --> 02:50:05.660]  Но теперь...
[02:50:05.660 --> 02:50:08.660]  Так, есть тут до этого момента вопросы?
[02:50:08.660 --> 02:50:11.660]  Да нет, наверное.
[02:50:11.660 --> 02:50:14.660]  Нету?
[02:50:14.660 --> 02:50:17.660]  Ну, так вот.
[02:50:17.660 --> 02:50:20.660]  Но тогда идея...
[02:50:20.660 --> 02:50:23.660]  Тогда этот алгоритм понятен,
[02:50:23.660 --> 02:50:26.660]  остается только придумать, а как бы сделать так,
[02:50:26.660 --> 02:50:29.660]  чтобы в этом алгоритме хэшмап не фигурировал?
[02:50:29.660 --> 02:50:32.660]  Вот как это сделать?
[02:50:32.660 --> 02:50:35.660]  Ну, на самом деле идея заключается в следующем.
[02:50:35.660 --> 02:50:38.660]  Потому что мы говорим,
[02:50:38.660 --> 02:50:41.660]  что мы тут двумя указателями перебираем.
[02:50:41.660 --> 02:50:44.660]  То есть мы пытаемся перебрать все суффиксы,
[02:50:44.660 --> 02:50:47.660]  все суффиксы, начиная с какого-то подполингрома,
[02:50:47.660 --> 02:50:50.660]  там подполингрома длины,
[02:50:50.660 --> 02:50:53.660]  предыдущий максимальный подполингром плюс два,
[02:50:53.660 --> 02:50:56.660]  перебираем тут все длины до тех пор,
[02:50:56.660 --> 02:50:59.660]  пока не наткнемся на полингром, правда?
[02:50:59.660 --> 02:51:02.660]  А на самом деле давайте это сформулируем по-другому.
[02:51:02.660 --> 02:51:05.660]  Рассмотрим все подполингромы,
[02:51:05.660 --> 02:51:08.660]  которые были суффиксами строки до появления нового символа С.
[02:51:08.660 --> 02:51:11.660]  Вот они, все подполингромы.
[02:51:11.660 --> 02:51:14.660]  Первый по длине, третий, четвертый по длине.
[02:51:14.660 --> 02:51:17.660]  Вот.
[02:51:17.660 --> 02:51:20.660]  Нам нужно тогда, в принципе,
[02:51:20.660 --> 02:51:23.660]  если бы нам кто-то с небес по факсу умел сообщать эту последовательность,
[02:51:23.660 --> 02:51:26.660]  хотя бы по одному чиселке,
[02:51:26.660 --> 02:51:29.660]  то мы бы просто тогда перебирали все эти подполингромы
[02:51:29.660 --> 02:51:32.660]  и для каждого проверяли.
[02:51:32.660 --> 02:51:35.660]  А слева от него случайно не символ там С завалялся.
[02:51:35.660 --> 02:51:38.660]  Там еще нужно находить номер этой вершины.
[02:51:38.660 --> 02:51:41.660]  Ну вот.
[02:51:41.660 --> 02:51:44.660]  Ну еще желательно года, чтобы подполингром еще и номер в боре был.
[02:51:44.660 --> 02:51:47.660]  Вот.
[02:51:47.660 --> 02:51:50.660]  Но тогда идея такая. Для того, чтобы это перебирать,
[02:51:50.660 --> 02:51:53.660]  заметим так, что в этом списке самый большой подполингром
[02:51:53.660 --> 02:51:56.660]  мы откуда-то, допустим, знаем.
[02:51:56.660 --> 02:51:59.660]  Но заметим, что каждый следующий подполингром
[02:51:59.660 --> 02:52:02.660]  зависит только от предыдущего, правда?
[02:52:02.660 --> 02:52:05.660]  Потому что по большому счету каждый следующий это что такое?
[02:52:05.660 --> 02:52:08.660]  Собственный суфикс вот этого полингрома,
[02:52:08.660 --> 02:52:11.660]  который тоже является полингромом, правда?
[02:52:11.660 --> 02:52:14.660]  А почему в слове суфикс 2 я пообстрою префикс 1?
[02:52:18.660 --> 02:52:21.660]  Ну видимо, да.
[02:52:21.660 --> 02:52:24.660]  Ну да.
[02:52:24.660 --> 02:52:27.660]  Например.
[02:52:27.660 --> 02:52:30.660]  Нет, ну или просто как бы в английском есть слово фикс?
[02:52:30.660 --> 02:52:33.660]  То есть типа где фиксировать?
[02:52:33.660 --> 02:52:36.660]  В прее видимо фиксировать и суфиксировать.
[02:52:36.660 --> 02:52:39.660]  То есть видимо.
[02:52:39.660 --> 02:52:42.660]  Нет, не суба.
[02:52:42.660 --> 02:52:45.660]  Нет, там как бы прее и пост там.
[02:52:45.660 --> 02:52:48.660]  Ну и наверное.
[02:52:48.660 --> 02:52:51.660]  Да, но по суфиксам непонятно.
[02:52:51.660 --> 02:52:54.660]  Ну хороший вопрос на самом деле, если честно, не знаю.
[02:52:54.660 --> 02:52:57.660]  Тут я, тут я прокомментировать не могу.
[02:52:57.660 --> 02:53:00.660]  Так вот. Значит, идея такая.
[02:53:00.660 --> 02:53:03.660]  То есть каждый следующий полингром.
[02:53:03.660 --> 02:53:06.660]  Отделяется предыдущим получается.
[02:53:06.660 --> 02:53:09.660]  То есть каждый следующий шаг мы можем делать так.
[02:53:09.660 --> 02:53:12.660]  Ну тогда выNOISEт следующие идеи, то есть как это дело?
[02:53:12.660 --> 02:53:15.660]  Нуdeep.
[02:53:15.660 --> 02:53:18.660]  А первым заметим, что мы полингром в принципе.
[02:53:18.660 --> 02:53:21.660]  То есть эти все ж полингромы у нас уже есть в нашем дереве полингромов, правда?
[02:53:21.660 --> 02:53:24.660]  Тогда мы можем кодировать каждый полингром.
[02:53:24.660 --> 02:53:27.660]  Просто соответствующий вершинкой дерева полингромов, правда?
[02:53:27.660 --> 02:53:30.400]  И тогда получается для того, чтобы понять, какой у нас полингром следующий,
[02:53:30.400 --> 02:53:37.480]  нам нужно просто в каждой вершине дерева полиндромов хранить ссылку, то есть хранить
[02:53:37.480 --> 02:53:43.440]  указатель, ну, такие номер вершины, которые вершины вот собственного суффикса полиндрома
[02:53:43.440 --> 02:53:53.400]  этого полиндрома. Итак, да, пришло время ввести официально это понятие. Так, давайте, будет такой
[02:53:53.400 --> 02:53:59.720]  чернорабочее у нас понятие. Давайте, для этого я достану коричневый маркер. Не, ну, я обычно
[02:53:59.720 --> 02:54:05.200]  такое рыжим пишу, но рыжий с красным. Ладно, как будете, коричневым или рыжим будем писать?
[02:54:05.200 --> 02:54:23.200]  Так, ну, давайте так попробуем. Вот, выбирайте.
[02:54:23.200 --> 02:54:39.400]  Это рыжий, это коричневый. Хорошо, ладно. Рыжий так рыжий. Ну, отлично. Значит, да,
[02:54:39.400 --> 02:54:47.840]  двое застальны, да. Двое, да, просто про одном явно воздержавшимся, да. Хорошо. Итак, внимание,
[02:54:47.840 --> 02:54:56.360]  объявляем суффиксную ссылку. Так, ну, во-первых, сначала нужно объявить такое понятие, как допустим,
[02:54:56.360 --> 02:55:02.440]  то есть, если у нас есть вершина В деревополиндромов, то мы можем ввести такое понятие, собственно,
[02:55:02.440 --> 02:55:13.480]  пал от В. Пал. Ну, пал от В, видите, я как функцию пишу, то есть, я не буду это в явном виде хранить,
[02:55:13.480 --> 02:55:18.280]  но я обозначу запал от В это полиндром, соответствующий вершине В.
[02:55:18.280 --> 02:55:41.280]  Какие классные сегодня марки. Вот. Вот. Теперь берем рыженький. Теперь, внимание, введем такое
[02:55:41.280 --> 02:55:59.240]  суфф от В. Значит, определение такое, при В не равно, там, не равно рут, имейте в виду,
[02:55:59.240 --> 02:56:24.240]  ни одному из рутов. Вот так. Вот я даже вот так напишу. То есть, пусть у меня В не равно ни одному из,
[02:56:24.240 --> 02:56:36.640]  ни одной из вершин. Тогда мы говорим, что суфф от В это такая вершина У, что, внимание,
[02:56:36.640 --> 02:56:55.960]  пал от нее. То есть, пал от У. Вот давайте, сейчас я черненький возьму. Это собственный суффикс.
[02:56:55.960 --> 02:57:24.080]  Пал от В. Вот. При этом, значит, модуль этого пал от У. Максимально возможно.
[02:57:24.080 --> 02:57:41.600]  Вот так. По сути, да. Я бы сказал, что это, но я это обозначаю, конечно, мы этому одному элементу суффиксную ссылку и прислаиваем.
[02:57:41.600 --> 02:58:00.720]  Вот. То есть, это такое официальное определение. Да, еще, конечно, оговоримся. Или что то же самое,
[02:58:00.720 --> 02:58:18.320]  А заметим еще, можно еще сказать так, что пал от В мы хранить не будем. Но лен от В, которое будет равно длине пал от В, мы в каждой вершине в явном виде храним.
[02:58:18.320 --> 02:58:41.920]  Но с мелкой оговоркой. Точнее, двумя мелкими оговорками. Что лен от, нет, да. Ну, не совсем. Нет, можно, но оказывается, скажем так, учитывая, что когда вы просто попали в вершину, вы заранее даже не знаете, в каком дереве вы находитесь.
[02:58:41.920 --> 02:58:55.520]  Вот. То есть, на самом деле, это тоже понятно, что можно сказать, для каждой вершины в явном виде хранить, в каком дереве она находится и на какой глубине, но это то же самое, но просто удобнее, оказывается, давайте просто длину хранить и все.
[02:58:55.520 --> 02:59:02.960]  Вот. По большому счету, это такие параметры, что из каждого восстанавливаются другие, вопрос только что удобнее. Вот обычно удобнее лен писать.
[02:59:03.280 --> 02:59:05.280]  Так вот. Я напишу так. Смотрите.
[02:59:06.800 --> 02:59:26.400]  Значит, лен от, от нечетного корня удобно считать равно минус единицей, а лен от root-even удобно считать ноль. То есть, смотрите.
[02:59:27.360 --> 02:59:45.760]  То есть, фишка будет такая, что всякие однобуквенные, то есть, из однобуквенных полиндромов суффиксная ссылка всегда будет вести в root-even, потому что максимальная длина собственного суффикса, который полиндром, это, конечно, ноль, а не минус один.
[02:59:46.640 --> 03:00:00.640]  Вот. Но, оказывается, значит, то есть, в этом случае мы тогда скажем, что по определению, что суффиксная ссылка от, значит, root-even будет равна, соответственно, root-o'do.
[03:00:04.640 --> 03:00:06.640]  Вот так я напишу.
[03:00:08.640 --> 03:00:12.640]  То есть, пару символов реализации это нам скушает.
[03:00:12.640 --> 03:00:14.640]  Во.
[03:00:16.640 --> 03:00:18.640]  То есть, вот так мы определим суффиксную ссылку.
[03:00:18.640 --> 03:00:20.640]  Ну, это просто, чтобы не...
[03:00:20.640 --> 03:00:28.640]  Теперь давайте предположим, что нам эта суффиксная ссылка присылается с небес по факсу.
[03:00:28.640 --> 03:00:38.640]  Тогда, то есть, если, то есть, как бы, то есть, предположим, что у нас там какая-нибудь появилась новая вершина, и тут мы, бабах, у чуда в ней появилась суффиксная ссылка сразу.
[03:00:38.640 --> 03:00:40.640]  Так вот.
[03:00:40.640 --> 03:00:44.640]  Тогда я утверждаю, что этих иши нам не нужны.
[03:00:46.640 --> 03:00:48.640]  Потому что идея будет такая.
[03:00:48.640 --> 03:00:58.640]  То есть, в каждый момент времени мы храним самый длинный суффикс-полиндром в виде вершины, которые ему соответствуют.
[03:00:58.640 --> 03:01:02.640]  И тогда мы знаем его длину и проверяем, верно ли, что слева от него тут символ c.
[03:01:02.640 --> 03:01:08.640]  Если да, то, значит, получается, вот мы нашли самый длинный полиндром, если надо, создаем.
[03:01:09.520 --> 03:01:11.520]  Если нет, то мы еще берем следующий суффикс.
[03:01:11.520 --> 03:01:15.520]  То есть, скачиваем по суффиксной ссылке, знаем ее длину, проверяем, есть ли тут символ c.
[03:01:15.520 --> 03:01:21.520]  Вайл здесь упадает, мы переходим, и в итоге обязательно совпадет, потому что мы дойдем до...
[03:01:21.520 --> 03:01:23.520]  Да, да.
[03:01:23.520 --> 03:01:25.520]  И там один символ получится, что символ равен самому символу.
[03:01:25.520 --> 03:01:27.520]  Да, да, да, да, совершенно верно.
[03:01:27.520 --> 03:01:33.520]  Именно поэтому мы суффиксную ссылку и проставили, чтобы сначала там попытаться два символа набрать, а потом один, если совсем.
[03:01:34.400 --> 03:01:44.400]  То есть, да, идея тут будет заключаться в том, что когда в худшем случае, если там совсем будет не переть, мы дойдем до длины 0 и проверим, не равны ли тут два символа c.
[03:01:44.400 --> 03:01:46.400]  А потом длины минус 1 и сравним с собой.
[03:01:46.400 --> 03:01:54.400]  А потом найдем префикс длины минус 1, но просто если строку длины минус 1 добавить с в начало и с в конец, то получится строка длины 1.
[03:01:58.400 --> 03:02:02.400]  И тогда получится, что она под полиндром, и ее мы получаем рацнуки.
[03:02:03.280 --> 03:02:05.280]  Ну да, то есть это скорее вот такой трюк.
[03:02:05.280 --> 03:02:15.280]  То есть получается, что если суффиксная ссылка откуда-то у нас небес по факсу взялась, то тогда получается, что мы победили.
[03:02:15.280 --> 03:02:23.280]  И в общем-то из вот этих вот двух указателей автоматически становится понятно, что мы действительно нашли суффиксную ссылку.
[03:02:23.280 --> 03:02:27.280]  Что мы, получается, построили дерево полиндромов за линию.
[03:02:28.160 --> 03:02:30.160]  Но нам осталось только придумать, как суффиксную ссылку насчитывать.
[03:02:30.160 --> 03:02:36.160]  Да, да, да, я вот ровно это и сказал.
[03:02:36.160 --> 03:02:42.160]  Да, что если суффиксную ссылку мы откуда-то берем, то мы победили.
[03:02:42.160 --> 03:02:44.160]  Согласны?
[03:02:44.160 --> 03:02:46.160]  Вот.
[03:02:46.160 --> 03:02:48.160]  Но теперь возникает вопрос.
[03:02:48.160 --> 03:02:50.160]  Да, откуда же мы найдем эту суффиксную ссылку?
[03:02:51.040 --> 03:02:53.040]  Не надо никаких потенциалов даже вводить.
[03:02:53.040 --> 03:03:03.040]  Ну точнее потенциал в некотором смысле придет, потому что у нас такие интересные два указателя, в которых левый указатель все-таки имеет право двигаться влево.
[03:03:03.040 --> 03:03:07.040]  Но там рассуждение из цикла, что левый указатель двигается не становится...
[03:03:07.040 --> 03:03:15.040]  То есть он начинает с нуля, заканчивается не позже n, и двигается влево не более чем n раз, каждый раз по единичке.
[03:03:15.040 --> 03:03:19.040]  Но так-то два указателя тоже нужно с помощью потенциала?
[03:03:19.920 --> 03:03:21.920]  Ну можно так сказать.
[03:03:21.920 --> 03:03:23.920]  Нет, ну не совсем так.
[03:03:23.920 --> 03:03:29.920]  Когда два указателя двигаются только вправо, то мы говорим, что каждый указатель двигается вправо не более чем n раз, поэтому победа суммарна у АТМ.
[03:03:29.920 --> 03:03:33.920]  Причем, кстати, на причет суффиксной ссылки тупые идеи приходят сразу.
[03:03:33.920 --> 03:03:35.920]  Типа не супер тупые, но такие конструктивные.
[03:03:35.920 --> 03:03:39.920]  Как там, например, за логарифм это сделать?
[03:03:40.800 --> 03:03:48.800]  Там конструктивные варианты типа бинт-подъемов и хранить массив.
[03:03:48.800 --> 03:04:00.800]  Я боюсь тут с бинт-подъемами напряг, потому что если ты имеешь в виду с помощью бинт-подъемов для каждого символа, чтобы в завод единица было написано.
[03:04:00.800 --> 03:04:06.800]  Не, нам уметь подниматься за логарифм и уметь просто дальше...
[03:04:07.680 --> 03:04:13.680]  Ну подниматься за логарифм куда, если ты все равно на каждом должен прям последовательно их проверять.
[03:04:13.680 --> 03:04:21.680]  Нет, ну просто там придумываются какие-то странные объемные конструктивные способы.
[03:04:21.680 --> 03:04:23.680]  Ну вот, ну спокойно.
[03:04:23.680 --> 03:04:25.680]  Нет, ну мы хотим...
[03:04:25.680 --> 03:04:27.680]  Нет, на самом деле мы ничего умного-то не хотим.
[03:04:27.680 --> 03:04:31.680]  Потому что вот у нас, допустим, возникла задача.
[03:04:32.560 --> 03:04:34.560]  То есть задача такая.
[03:04:34.560 --> 03:04:44.560]  Вот мы тут шли-шли-шли по суффиксным ссылкам, и вот, наконец, неожиданно нашли новый красивый зеленый полиндром.
[03:04:46.560 --> 03:04:50.560]  Вот даже не здесь нашли, а вот неожиданно вот здесь нашли.
[03:04:50.560 --> 03:04:54.560]  Я хочу у этого полиндрома найти суффиксную ссылку.
[03:04:54.560 --> 03:04:56.560]  Как я это буду делать?
[03:04:57.440 --> 03:05:03.440]  Ну на самом деле получается, если я отпилю эти символы С обратно, у меня опять получится полиндром здесь.
[03:05:03.440 --> 03:05:11.440]  А если я возьму какой-нибудь суффикс, который является полиндромом, то отпилив символ С здесь и здесь, я опять найду суффикс полиндром вот этого полиндрома.
[03:05:11.440 --> 03:05:25.440]  То есть идея такая, давайте получается от этого полиндрома, от которого мы только что стрелочку построили, давайте тоже идти по вот этим суффиксным ссылкам.
[03:05:26.320 --> 03:05:32.320]  До тех пор, пока мы здесь не найдем там какой-нибудь суффикс, который расширяется до символа С.
[03:05:34.320 --> 03:05:35.320]  Осталось только...
[03:05:35.320 --> 03:05:37.320]  Да, сейчас, спокойно.
[03:05:37.320 --> 03:05:42.320]  Ну то есть у нас было два указателя, мы этими двумя указателями нашли вот этот суффикс и расширили его на С.
[03:05:42.320 --> 03:05:46.320]  Мы по суффиксным ссылкам нашли суффикс, который нам нужен.
[03:05:46.320 --> 03:05:49.320]  Соответственно, мы нашли наш полиндром.
[03:05:49.320 --> 03:05:54.320]  Тут нам еще не нужна наша суффиксная ссылка.
[03:05:55.200 --> 03:06:01.200]  Нет, то есть мы только что создали эту вершину, и мы теперь для нее должны не считать суффиксную ссылку.
[03:06:03.200 --> 03:06:04.200]  А как она выглядит?
[03:06:04.200 --> 03:06:05.200]  Выглядит она так.
[03:06:05.200 --> 03:06:12.200]  То есть она тоже выглядит как уже суффикс собственной, суффикс полиндром вот этого полиндрома, родительского.
[03:06:12.200 --> 03:06:17.200]  Какого-то родительского, который можно расширить влево и вправо на символ С.
[03:06:17.200 --> 03:06:20.200]  Ну вообще, да.
[03:06:20.280 --> 03:06:21.280]  Ну тогда как их перебрать?
[03:06:21.280 --> 03:06:26.280]  Так давай начнем с префикс функции по суффиксной ссылке родителя.
[03:06:26.280 --> 03:06:35.280]  И будем по ней идти, идти, идти до тех пор, пока не наткнемся на расширение.
[03:06:35.280 --> 03:06:36.280]  Почему это плохо?
[03:06:36.280 --> 03:06:38.280]  Это же за квадрат может быть.
[03:06:42.280 --> 03:06:44.280]  Не факт.
[03:06:44.280 --> 03:06:48.280]  Вам может показаться, что это работает за квадрат.
[03:06:48.360 --> 03:06:49.360]  Потому что у нас сломалось.
[03:06:49.360 --> 03:06:54.360]  Ну в плане мы будем делать лишнюю работу, потом откатывать, потом еще раз ее делать.
[03:06:54.360 --> 03:06:55.360]  Нет, почему лишнюю работу?
[03:06:55.360 --> 03:07:00.360]  Ну на самом деле заметил, что в некотором смысле лишнюю мы не делаем, потому что мы как бы продолжаем идти.
[03:07:00.360 --> 03:07:06.360]  Хотя да, если вам кажется, что мы работаем только с двумя указателями, этот указатель мы сдвинули сюда, потом вернули на место, то да.
[03:07:07.360 --> 03:07:12.360]  Но, ну вот да, такой анализ нам победы не дает.
[03:07:12.360 --> 03:07:15.360]  Но мы более хитрые.
[03:07:15.440 --> 03:07:20.440]  Дамы и господа, метод трех указателей.
[03:07:20.440 --> 03:07:24.440]  А давайте вообразим себе следующее.
[03:07:24.440 --> 03:07:26.440]  Смотрите.
[03:07:26.440 --> 03:07:40.440]  В каждый момент времени на самом деле заметим, что у нас есть, значит, какой-то два указателя, которые указывают на, значит, начало и конец самого большого, там какого-то суффикса полиндрома, правда?
[03:07:40.520 --> 03:07:48.520]  То есть мы как бы когда этими двумя указателями мы говорили, что мы тут идем, идем, идем, в какой-то момент останавливаемся и два указателя вот так расширяем, правда?
[03:07:48.520 --> 03:07:50.520]  А теперь у меня следующий идея.
[03:07:50.520 --> 03:07:53.520]  Давайте мысленно добавим третий указатель.
[03:07:53.520 --> 03:08:08.520]  Да, третий указатель, зелененький, красивый, ладно, вру, рыженький, который будет указывать на мысленно, на, так сказать, суффиксную ссылку вот этого полиндрома синего.
[03:08:08.600 --> 03:08:10.600]  Ладно.
[03:08:10.600 --> 03:08:12.600]  Давайте мысленно будем считать, что это рыжий указатель с нами.
[03:08:12.600 --> 03:08:14.600]  Заметим, что, как тогда все это будет быть?
[03:08:14.600 --> 03:08:22.600]  Когда мы будем искать, собственно, вот это расширение, то есть как бы у нас синий указатель двигается вперед, но вместе с ним вперед двигается и рыжий.
[03:08:22.600 --> 03:08:28.600]  То есть как бы это синий указатель скачет по суффиксным ссылкам, а рыжий бежит впереди него.
[03:08:28.600 --> 03:08:32.600]  Да, то есть такой глошатый такой кричит, что сейчас сюда придет король.
[03:08:32.600 --> 03:08:36.600]  Ну, там король или там, я не знаю, фантомас может там, я не знаю.
[03:08:36.680 --> 03:08:46.680]  Ну, знаете, это ситуация, вы приходите домой, там вам звонит телефон, вы берете трубку, а там, внимание, сейчас с вами будет говорить фантомас.
[03:08:46.680 --> 03:08:50.680]  Повторяю, с вами сейчас будет говорить фантомас.
[03:08:50.680 --> 03:08:52.680]  Ну, вот что-то такое.
[03:08:52.680 --> 03:08:57.680]  Да, потом дубинкой по голове и вы появляетесь в комнате дворца и с вами реально начинает говорить фантомас.
[03:08:57.680 --> 03:09:01.680]  Да, потом требуется 15 минут фильма, чтобы понять, что это был не сон.
[03:09:01.760 --> 03:09:05.760]  Ну, подробнее смотрите фильм про...
[03:09:05.760 --> 03:09:09.760]  Ну, я вас уверяю, не про просто кваш.
[03:09:09.760 --> 03:09:13.760]  Да, на самом деле такой веселый фильмец, на самом деле, смешной.
[03:09:13.760 --> 03:09:17.760]  Жалко, потом во втором фильме фантомас все-таки убивать начинает, это становится грустно.
[03:09:17.760 --> 03:09:19.760]  До этого было смешно.
[03:09:19.760 --> 03:09:23.760]  Ладно, значит, смотрите, то есть такой глошатый значит идет вперед.
[03:09:23.760 --> 03:09:30.760]  И вот в какой-то момент, значит, вы тут шли-шли-шли и наткнулись.
[03:09:30.840 --> 03:09:34.840]  Наткнулись на то, что надо что-то расширить.
[03:09:34.840 --> 03:09:36.840]  Вот.
[03:09:36.840 --> 03:09:38.840]  Но как мы дальше ищем суффиксную ссылку?
[03:09:38.840 --> 03:09:42.840]  То есть, да, хорошо, синие указатели чуть-чуть раздвигаются.
[03:09:42.840 --> 03:09:46.840]  Значит, синие указатели чуть-чуть раздвигаются.
[03:09:46.840 --> 03:09:48.840]  Вот.
[03:09:48.840 --> 03:09:50.840]  Пока.
[03:09:50.840 --> 03:09:54.840]  Потому что, чтобы он стал корректным, мы должны реально найти для этого нового полиндрома суффиксную ссылку.
[03:09:54.840 --> 03:09:56.840]  Ну ладно.
[03:09:56.840 --> 03:09:58.840]  Вот.
[03:09:58.920 --> 03:10:04.920]  Давайте мы можем сейчас даже предполагать, что мы ее всегда будем в тупую искать, даже если эта вершина уже существовала.
[03:10:04.920 --> 03:10:06.920]  А как мы ее будем искать?
[03:10:06.920 --> 03:10:10.920]  Мы будем, начиная с вот внимания ровно этого момента,
[03:10:10.920 --> 03:10:14.920]  скакать по префикс-функциям дальше, до тех пор, пока очередной не расширится.
[03:10:14.920 --> 03:10:22.920]  Но тогда получается, что, видите, рыжий в этой ситуации до сих пор, пока ни разу назад не сдвинулся.
[03:10:22.920 --> 03:10:24.920]  То есть он тоже двигается вперед-вперед-вперед-вперед.
[03:10:24.920 --> 03:10:26.920]  И только вот там двигается вперед-вперед-вперед.
[03:10:27.000 --> 03:10:31.000]  И в какой-то момент он сдвинется на один назад.
[03:10:35.000 --> 03:10:37.000]  Вот.
[03:10:37.000 --> 03:10:43.000]  Ну можно даже сказать, правильно было, что мы тут тоже два рыжих указателя храним, то есть этот как бы фиксирован, но потом он вот так сдвигается.
[03:10:43.000 --> 03:10:45.000]  Да.
[03:10:45.000 --> 03:10:47.000]  Да.
[03:10:47.000 --> 03:10:49.000]  Ну метод двух пар, двух указателей, по сути.
[03:10:49.000 --> 03:10:55.000]  То есть как бы, если вы храните два указателя, двумя указателями, не только вот сам этот префикс,
[03:10:55.080 --> 03:11:01.080]  не только вот эту суффиксную ссылку, то оказывается, что эти два указателя тоже двигаются по принципу,
[03:11:01.080 --> 03:11:03.080]  что там правый указатель двигается только вперед,
[03:11:03.080 --> 03:11:11.080]  левый указатель там двигается иногда налево, но исключительно в рамках ампилотерапии по чайной ложке, там не более чем 1 раз суммарно.
[03:11:11.080 --> 03:11:13.080]  Вот.
[03:11:13.080 --> 03:11:15.080]  И поэтому...
[03:11:15.080 --> 03:11:17.080]  Рыжий на что формально указывается?
[03:11:17.080 --> 03:11:19.080]  На суффикс...
[03:11:19.080 --> 03:11:23.080]  Ну на начало и конец самого большого собственного суффикса нашего синего полиндрома,
[03:11:23.160 --> 03:11:25.160]  который тоже является полиндромом.
[03:11:25.160 --> 03:11:31.160]  То есть давайте назовем синем полиндромом самый большой суффикс полиндрома.
[03:11:31.160 --> 03:11:35.160]  Кстати, обратите внимание, он может совпадать со строкой S от слова вполне.
[03:11:35.160 --> 03:11:41.160]  То есть если строкается полиндром, то синие указатели просто указывают на все вот это вот.
[03:11:41.160 --> 03:11:43.160]  Вот.
[03:11:43.160 --> 03:11:45.160]  Рыжий указатель...
[03:11:45.160 --> 03:11:47.160]  Значит это назовем синем полиндромом.
[03:11:47.240 --> 03:11:53.240]  То есть рыжий указатель указывает на самый большой собственный суффикс синего полиндрома,
[03:11:53.240 --> 03:11:55.240]  который является тоже полиндромом.
[03:11:57.240 --> 03:12:01.240]  И тогда оказывается, что, двигаясь вот так рыжим указателем, получается красиво.
[03:12:01.240 --> 03:12:07.240]  То есть получается, что суммарно эти скачки по суффиксным ссылкам тоже работают за линией.
[03:12:07.320 --> 03:12:09.320]  По сути так, да.
[03:12:09.320 --> 03:12:11.320]  Вот. То есть боль то, я думаю, да.
[03:12:11.320 --> 03:12:15.320]  Так что получается, после этого можно теперь бежать и кодить, и мы, пожалуй, даже это сделаем.
[03:12:17.320 --> 03:12:25.320]  То есть получается, когда мы находим вот это вот совпадающий символ, мы не останавливаемся, а продолжаем прыгать?
[03:12:25.320 --> 03:12:27.320]  Ну нет, синим останавливаемся, рыжим нет.
[03:12:27.320 --> 03:12:31.320]  Да, но имеется в виду мы можем не останавливаться, а продолжаем прыгать.
[03:12:31.400 --> 03:12:33.400]  Мы не останавливаемся, а продолжаем прыгать?
[03:12:33.400 --> 03:12:35.400]  Ну нет, синим останавливаемся, рыжим нет.
[03:12:35.400 --> 03:12:43.400]  Да, но имеется в виду мы потом, чтобы еще насчитать от нас, мы еще дальше прыгаем, чтобы найти второе совпадение.
[03:12:43.400 --> 03:12:45.400]  Да. То есть по сути мы не одно...
[03:12:45.400 --> 03:12:53.400]  То есть можно считать так, мы ищем не только первое, не только самый большой суффикс, но практически два самых больших суффикса.
[03:12:55.400 --> 03:12:56.400]  Прикольно.
[03:12:56.400 --> 03:12:58.400]  То есть на самом деле оказывается вот так.
[03:12:58.480 --> 03:13:02.480]  Да, можно ввести потенциал, конечно, но на самом деле вот...
[03:13:02.480 --> 03:13:04.480]  А почему странно-то?
[03:13:04.480 --> 03:13:06.480]  Ну что за бред?
[03:13:06.480 --> 03:13:08.480]  Ну вот.
[03:13:08.480 --> 03:13:10.480]  Нет, у меня такая интерпретация.
[03:13:10.480 --> 03:13:14.480]  Ты можешь почитать, собственно, оригинальную статью Рубинчика, а может быть там будет менее странно.
[03:13:14.480 --> 03:13:16.480]  Вот, я не знаю.
[03:13:16.480 --> 03:13:18.480]  Но просто как по мне...
[03:13:18.480 --> 03:13:22.480]  То есть как бы тут вопрос, можно ввести формально потенциал и доказать, что все работает?
[03:13:22.480 --> 03:13:24.480]  Нет, понятно, почему работает.
[03:13:24.560 --> 03:13:26.560]  Ну вот.
[03:13:26.560 --> 03:13:28.560]  Ну как бы сказать, да.
[03:13:28.560 --> 03:13:34.560]  Мне кажется вот так вот тоже должно быть как бы тоже интуитивно красиво, хоть и немножко разрывает шаблон.
[03:13:34.560 --> 03:13:36.560]  Ну вот.
[03:13:36.560 --> 03:13:38.560]  Ну с другой стороны.
[03:13:38.560 --> 03:13:40.560]  Как это называется?
[03:13:40.560 --> 03:13:42.560]  Так что давайте попробуем.
[03:13:42.560 --> 03:13:44.560]  А, да-да-да.
[03:13:44.560 --> 03:13:46.560]  Забыл, забыл, забыл.
[03:13:46.560 --> 03:13:48.560]  Давайте.
[03:13:48.560 --> 03:13:50.560]  Какую?
[03:13:50.560 --> 03:13:52.560]  Да, вот самая левая.
[03:13:52.640 --> 03:13:54.640]  Вот эта?
[03:13:54.640 --> 03:13:56.640]  Да, ой.
[03:13:56.640 --> 03:13:58.640]  Ну скажи так, она двигается, но не тривиально.
[03:13:58.640 --> 03:14:00.640]  Она кажется должна.
[03:14:00.640 --> 03:14:02.640]  Нет, она по-моему так двигается.
[03:14:02.640 --> 03:14:04.640]  Ее можно вот, да, вот она двигается вот так.
[03:14:04.640 --> 03:14:06.640]  Вот так.
[03:14:06.640 --> 03:14:08.640]  И вот так.
[03:14:08.640 --> 03:14:10.640]  Да, ну вот.
[03:14:10.640 --> 03:14:12.640]  Вот.
[03:14:12.640 --> 03:14:14.640]  Но эту придется вот так сдвинуть, да.
[03:14:14.640 --> 03:14:16.640]  Хануйские башни.
[03:14:16.640 --> 03:14:18.640]  Не, хануйские башни другое.
[03:14:18.720 --> 03:14:20.720]  Чего?
[03:14:20.720 --> 03:14:22.720]  Бануйские хашни?
[03:14:22.720 --> 03:14:24.720]  Чего?
[03:14:24.720 --> 03:14:26.720]  Бануйские хашни?
[03:14:26.720 --> 03:14:28.720]  Чего?
[03:14:28.720 --> 03:14:30.720]  О боже.
[03:14:30.720 --> 03:14:32.720]  Ага, да-да-да.
[03:14:32.720 --> 03:14:34.720]  Нет, там уже начинается теря Махана-Бахана.
[03:14:34.720 --> 03:14:36.720]  Там какого-нибудь.
[03:14:36.720 --> 03:14:38.720]  Ну а как еще там будет как бы?
[03:14:38.720 --> 03:14:40.720]  Кажется вот так должно быть достаточно,
[03:14:40.720 --> 03:14:42.720]  потому что она пересекалась.
[03:14:42.720 --> 03:14:44.720]  Так ладно, давайте сейчас попробуем.
[03:14:44.720 --> 03:14:46.720]  Так, Вася, включайся.
[03:14:46.800 --> 03:14:48.800]  Ой, давненько, да.
[03:14:48.800 --> 03:14:50.800]  Вася сегодня нет.
[03:14:50.800 --> 03:14:52.800]  Да я вижу. Ее вообще что-то давно уже нету.
[03:14:52.800 --> 03:14:54.800]  Вася сегодня пришел на испанское действие.
[03:14:54.800 --> 03:14:56.800]  Сказал тему.
[03:14:56.800 --> 03:14:58.800]  Видимо шел дальше спать.
[03:14:58.800 --> 03:15:00.800]  А, Вася профессионал, да.
[03:15:00.800 --> 03:15:02.800]  Ну да-да-да.
[03:15:02.800 --> 03:15:04.800]  Да я знаю, мы так вчера на КВН сходили.
[03:15:04.800 --> 03:15:06.800]  Мы там, как это?
[03:15:06.800 --> 03:15:08.800]  Официальное начало в билете 18.30.
[03:15:08.800 --> 03:15:10.800]  Мы вошли в 19.07.
[03:15:10.800 --> 03:15:12.800]  КВН начался где-то там по-моему 19.15.
[03:15:12.800 --> 03:15:14.800]  Блин.
[03:15:14.880 --> 03:15:16.880]  Ну.
[03:15:20.880 --> 03:15:22.880]  О, Валебульчик, так.
[03:15:22.880 --> 03:15:24.880]  Выключи свет, пожалуйста.
[03:15:24.880 --> 03:15:26.880]  Так.
[03:15:26.880 --> 03:15:28.880]  Смотрите, сейчас мы это узнаем.
[03:15:28.880 --> 03:15:30.880]  Потому что если это
[03:15:30.880 --> 03:15:32.880]  не так.
[03:15:32.880 --> 03:15:34.880]  Так.
[03:15:34.880 --> 03:15:36.880]  Да, именно вот
[03:15:36.880 --> 03:15:38.880]  таким образом можно сделать первую оптимизацию
[03:15:38.880 --> 03:15:40.880]  в ФФТ.
[03:15:40.880 --> 03:15:42.880]  Но для вас новой информацией не является.
[03:15:42.960 --> 03:15:44.960]  Мы уже с вами в прошлом году.
[03:15:44.960 --> 03:15:46.960]  Там ровно год назад делали.
[03:15:46.960 --> 03:15:48.960]  Нет, еще.
[03:15:48.960 --> 03:15:50.960]  Не-не-не, это я в 11 классе
[03:15:50.960 --> 03:15:52.960]  рассказал. Так.
[03:15:52.960 --> 03:15:54.960]  Пока проектор прогреется.
[03:15:54.960 --> 03:15:56.960]  Ну а что делать?
[03:15:56.960 --> 03:15:58.960]  Я с ними уже четвертый год.
[03:15:58.960 --> 03:16:00.960]  Так что пришло время и это ладно.
[03:16:00.960 --> 03:16:02.960]  Вот.
[03:16:02.960 --> 03:16:04.960]  Когда вы ставим ФФ2,
[03:16:04.960 --> 03:16:06.960]  почему не ФФТ2?
[03:16:06.960 --> 03:16:08.960]  Это в смысле, это
[03:16:08.960 --> 03:16:10.960]  самое первое ФФТ.
[03:16:11.040 --> 03:16:13.040]  Это два ФФ2.
[03:16:13.040 --> 03:16:15.040]  Я ФФТ назвал.
[03:16:15.040 --> 03:16:17.040]  Вектор Олд.
[03:16:19.040 --> 03:16:21.040]  Вектор Олдов, да.
[03:16:23.040 --> 03:16:25.040]  Ну что? Так. Ну что?
[03:16:25.040 --> 03:16:27.040]  Лучше видно?
[03:16:27.040 --> 03:16:29.040]  Да я знаю, за фотоша, да-да-да.
[03:16:33.040 --> 03:16:35.040]  Ой.
[03:16:35.040 --> 03:16:37.040]  Полинтромик 3.
[03:16:37.040 --> 03:16:39.040]  Ну хорошо,
[03:16:39.120 --> 03:16:41.120]  не занудствуй.
[03:16:41.120 --> 03:16:43.120]  Вот.
[03:16:43.120 --> 03:16:45.120]  Е-3.
[03:16:45.120 --> 03:16:47.120]  Е-3.
[03:16:47.120 --> 03:16:49.120]  Чтоб полинтром был.
[03:16:49.120 --> 03:16:51.120]  А!
[03:16:51.120 --> 03:16:53.120]  Это какой-то 800-й кирю-юмор.
[03:17:03.120 --> 03:17:05.120]  Ну это лучше, чем Курева, конечно.
[03:17:05.200 --> 03:17:07.200]  Ой.
[03:17:07.200 --> 03:17:09.200]  Ладно.
[03:17:13.200 --> 03:17:15.200]  Ну да-да-да.
[03:17:15.200 --> 03:17:17.200]  Поэтому Куреву называют да-да-да.
[03:17:17.200 --> 03:17:19.200]  Так. Ну ладно, давайте.
[03:17:21.200 --> 03:17:23.200]  Так, значит, смотрите.
[03:17:23.200 --> 03:17:25.200]  Давайте посмотрим, что нам нужно хранить
[03:17:25.200 --> 03:17:27.200]  в нашей ноде.
[03:17:27.200 --> 03:17:29.200]  Ну давайте смотреть, что мы храним в ноде.
[03:17:29.200 --> 03:17:31.200]  Так. Ну, во-первых, храним Инт.
[03:17:31.200 --> 03:17:33.200]  Значит храним Лен.
[03:17:33.280 --> 03:17:35.280]  Да.
[03:17:35.280 --> 03:17:37.280]  Значит храним Лен.
[03:17:37.280 --> 03:17:39.280]  Так, что нам, да, ну вообще
[03:17:39.280 --> 03:17:41.280]  переходы надо. Так, ну переходы можно
[03:17:41.280 --> 03:17:43.280]  двумя способами хранить. Можно в мапчике
[03:17:43.280 --> 03:17:45.280]  хранить, можно
[03:17:45.280 --> 03:17:47.280]  в массивчике.
[03:17:47.280 --> 03:17:49.280]  Как правильно? Ну естественно зависит
[03:17:49.280 --> 03:17:51.280]  на самом деле от размера алфавита.
[03:17:51.280 --> 03:17:53.280]  Потому что есть подозрение, что если у вас алфавит размера 26,
[03:17:53.280 --> 03:17:55.280]  то мапчик может выиграть.
[03:17:55.280 --> 03:17:57.280]  Если у вас размер алфавита 2, то очевидно
[03:17:57.280 --> 03:17:59.280]  нужно хранить в массивчике.
[03:17:59.280 --> 03:18:01.280]  Вот. Не, еще зависит
[03:18:01.360 --> 03:18:03.360]  от того, что вы хотите оптимизировать память или время.
[03:18:03.360 --> 03:18:05.360]  И то, правда.
[03:18:05.360 --> 03:18:07.360]  Потому что если вы хотите оптимизировать время,
[03:18:07.360 --> 03:18:09.360]  вам мап нужен никогда.
[03:18:09.360 --> 03:18:11.360]  Ну вот. Значит смотрите,
[03:18:11.360 --> 03:18:13.360]  храним.
[03:18:13.360 --> 03:18:15.360]  Так, Лен и соответственно СУФ.
[03:18:17.360 --> 03:18:19.360]  Значит поехали. Такое вот ноде.
[03:18:21.360 --> 03:18:23.360]  Значит смотрите.
[03:18:23.360 --> 03:18:25.360]  Ну вот.
[03:18:25.440 --> 03:18:27.440]  Ну вот.
[03:18:29.440 --> 03:18:31.440]  Значит заводим ER3.
[03:18:33.440 --> 03:18:35.440]  Вот.
[03:18:37.440 --> 03:18:39.440]  Значит что я тут буду хранить?
[03:18:39.440 --> 03:18:41.440]  Ну естественно я буду хранить вектор нодов.
[03:18:43.440 --> 03:18:45.440]  Неправильная большая буква.
[03:18:45.440 --> 03:18:47.440]  Первая маленькая,
[03:18:47.440 --> 03:18:49.440]  ты большая. О господи.
[03:18:49.440 --> 03:18:51.440]  Нет, ну классы у нас все-таки
[03:18:51.440 --> 03:18:53.440]  с большой буквы пишут.
[03:18:53.520 --> 03:18:55.520]  А, это вообще неправильно, да.
[03:18:57.520 --> 03:18:59.520]  Так, хорошо, нодис.
[03:18:59.520 --> 03:19:01.520]  Значит что нам нужно, чтобы хранить еще?
[03:19:03.520 --> 03:19:05.520]  Нам ну INT.
[03:19:05.520 --> 03:19:07.520]  Ну так, как хранить эту?
[03:19:09.520 --> 03:19:11.520]  Значит INT, ну допустим.
[03:19:11.520 --> 03:19:13.520]  О.
[03:19:19.520 --> 03:19:21.520]  Значит я заведу.
[03:19:23.520 --> 03:19:25.520]  Нет, хотя вот нет,
[03:19:25.520 --> 03:19:27.520]  просто проблема в том, что мы этот,
[03:19:27.520 --> 03:19:29.520]  ладно.
[03:19:31.520 --> 03:19:33.520]  Да.
[03:19:33.520 --> 03:19:35.520]  Ну, как сказать, мы с вами
[03:19:35.520 --> 03:19:37.520]  только что обсуждали, что мы храним вот этот вот,
[03:19:37.520 --> 03:19:39.520]  называем синий суффикс, да?
[03:19:39.520 --> 03:19:41.520]  Вот.
[03:19:41.520 --> 03:19:43.520]  Тогда в нашем контексте мы это можем назвать синию вершину.
[03:19:43.520 --> 03:19:45.520]  Ну правильно, конечно,
[03:19:45.520 --> 03:19:47.520]  а там по-другому это называть, наверное.
[03:19:47.520 --> 03:19:49.520]  Ну можем, хорошо, в укоренении мы будем это называть
[03:19:49.520 --> 03:19:51.520]  last. Ничего.
[03:19:51.600 --> 03:19:53.600]  Или, а, мы это хуже будем называть,
[03:19:53.600 --> 03:19:55.600]  last, not suf, мы это будем называть
[03:19:55.600 --> 03:19:57.600]  или first, not suf.
[03:19:57.600 --> 03:19:59.600]  И в этот момент просто кто-то лицет головой в окно.
[03:19:59.600 --> 03:20:01.600]  Да, да, да.
[03:20:01.600 --> 03:20:03.600]  Да, кого-то кукнул.
[03:20:03.600 --> 03:20:05.600]  Ну, как хотите, можно last, можно blue суффикс оставить.
[03:20:07.600 --> 03:20:09.600]  И тогда у нас потом будет orange суффикс.
[03:20:16.600 --> 03:20:18.600]  Значит, смотрите.
[03:20:18.600 --> 03:20:20.600]  А, ну и конечно же мы не забываем,
[03:20:20.680 --> 03:20:22.680]  так, еще нам конечно надо хранить
[03:20:22.680 --> 03:20:24.680]  саму строчку, наверное, да?
[03:20:30.680 --> 03:20:32.680]  Так, во-первых,
[03:20:32.680 --> 03:20:34.680]  ER3, собственно, конструктор.
[03:20:42.680 --> 03:20:44.680]  Так, ну здесь все просто.
[03:20:44.680 --> 03:20:46.680]  Nodes мы храним, у нас будет две вершины.
[03:20:46.760 --> 03:20:48.760]  И last.
[03:20:54.760 --> 03:20:56.760]  Так, ну last, в принципе, можно хранить от нуля.
[03:21:02.760 --> 03:21:04.760]  Хотя, о,
[03:21:04.760 --> 03:21:06.760]  пришло время сделать красивую
[03:21:06.760 --> 03:21:08.760]  штуку.
[03:21:08.840 --> 03:21:10.840]  Нет, курс по посторонней,
[03:21:10.840 --> 03:21:12.840]  это TP.
[03:21:20.840 --> 03:21:22.840]  О,
[03:21:22.840 --> 03:21:24.840]  смотри,
[03:21:24.840 --> 03:21:26.840]  какая красота.
[03:21:32.840 --> 03:21:34.840]  О,
[03:21:34.840 --> 03:21:36.840]  смотри,
[03:21:36.920 --> 03:21:38.920]  там еще int, наверное, было.
[03:21:40.920 --> 03:21:42.920]  Ну, четный корень,
[03:21:42.920 --> 03:21:44.920]  нечетный корень.
[03:21:44.920 --> 03:21:46.920]  Нет, я думал написать красный корень и синий корень,
[03:21:46.920 --> 03:21:48.920]  но, пожалуй, я не буду этого делать.
[03:21:48.920 --> 03:21:50.920]  Конечно, да.
[03:21:50.920 --> 03:21:52.920]  Давайте, сейчас мы хотим
[03:21:52.920 --> 03:21:54.920]  минус один, так?
[03:21:54.920 --> 03:21:56.920]  Нет, нет, смотрите, нет, почему минус один?
[03:21:56.920 --> 03:21:58.920]  Сами вершины,
[03:21:58.920 --> 03:22:00.920]  которые будут вот этим корнем E,
[03:22:00.920 --> 03:22:02.920]  и тем корнем они будут 0,1.
[03:22:02.920 --> 03:22:04.920]  Оформляем нечетный корень.
[03:22:05.000 --> 03:22:07.000]  Нечетный корень, дети,
[03:22:07.000 --> 03:22:09.000]  так, ну, во-первых, давайте тут напишем,
[03:22:09.000 --> 03:22:11.000]  что это нодя, чтобы красиво было.
[03:22:13.000 --> 03:22:15.000]  Вот так вот напишем. Значит,
[03:22:15.000 --> 03:22:17.000]  нулевой вершине, значит, ну, мапчик
[03:22:17.000 --> 03:22:19.000]  пустой, естественно, len равен
[03:22:19.000 --> 03:22:21.000]  минус один, суффиксная ссылка равна
[03:22:21.000 --> 03:22:23.000]  ну, допустим, минус один.
[03:22:23.000 --> 03:22:25.000]  Далее.
[03:22:27.000 --> 03:22:29.000]  Значит,
[03:22:29.000 --> 03:22:31.000]  учетного корня
[03:22:31.000 --> 03:22:33.000]  мапчик пустой, len равен ноль,
[03:22:33.080 --> 03:22:35.080]  суффиксная ссылка равна
[03:22:35.080 --> 03:22:37.080]  odd root.
[03:22:37.080 --> 03:22:39.080]  Вот, я так и напишу.
[03:22:41.080 --> 03:22:43.080]  Понятно, да?
[03:22:45.080 --> 03:22:47.080]  Вот, ну, минус один, на самом деле,
[03:22:47.080 --> 03:22:49.080]  тоже можно написать.
[03:22:51.080 --> 03:22:53.080]  Вот.
[03:22:59.080 --> 03:23:01.080]  О, можно еще вот так написать,
[03:23:01.160 --> 03:23:03.160]  чтобы совсем красиво было.
[03:23:11.160 --> 03:23:13.160]  Вот, потому что тут минус один как бы
[03:23:13.160 --> 03:23:15.160]  у нас уже осмысленно, а тут как бы я могу
[03:23:15.160 --> 03:23:17.160]  написать минус один, минус 57,
[03:23:17.160 --> 03:23:19.160]  там, что угодно.
[03:23:19.160 --> 03:23:21.160]  Вот. Так вот.
[03:23:21.160 --> 03:23:23.160]  И теперь нам нужно написать функцию
[03:23:25.160 --> 03:23:27.160]  как бы
[03:23:27.160 --> 03:23:29.160]  push back
[03:23:29.240 --> 03:23:31.240]  чара.
[03:23:37.240 --> 03:23:39.240]  Хорошо, хорошо, да.
[03:23:41.240 --> 03:23:43.240]  Значит, теперь push back m symbol.
[03:23:45.240 --> 03:23:47.240]  Можно, но
[03:23:47.240 --> 03:23:49.240]  не очень-то нужно.
[03:23:49.240 --> 03:23:51.240]  Вот.
[03:23:51.240 --> 03:23:53.240]  Итак, поехали.
[03:23:55.240 --> 03:23:57.240]  Значит, смотрите. Итак, я хочу, чтобы этот чар
[03:23:57.320 --> 03:23:59.320]  был n-ым символом строки.
[03:23:59.320 --> 03:24:01.320]  Для этого я сделаю так.
[03:24:07.320 --> 03:24:09.320]  Так.
[03:24:13.320 --> 03:24:15.320]  Так. Тихо-тихо-тихо, ребят.
[03:24:15.320 --> 03:24:17.320]  Значит, поехали.
[03:24:17.320 --> 03:24:19.320]  Итак, у нас n-ый s, значит,
[03:24:19.320 --> 03:24:21.320]  это чар, это n-ый символ строки s, я его уже
[03:24:21.320 --> 03:24:23.320]  push back, чтобы потом не говорить об этом.
[03:24:23.320 --> 03:24:25.320]  Last это сейчас
[03:24:25.400 --> 03:24:27.400]  он указывает, то есть это на максимальный
[03:24:27.400 --> 03:24:29.400]  полиндром, который заканчивается в n-1
[03:24:29.400 --> 03:24:31.400]  символе.
[03:24:31.400 --> 03:24:33.400]  Значит, я теперь
[03:24:33.400 --> 03:24:35.400]  говорю, что while
[03:24:35.400 --> 03:24:37.400]  там какой-то, то есть
[03:24:37.400 --> 03:24:39.400]  пока у меня текущий полиндром
[03:24:39.400 --> 03:24:41.400]  last-овый нельзя расширить
[03:24:41.400 --> 03:24:43.400]  на два символа,
[03:24:43.400 --> 03:24:45.400]  что я делаю?
[03:24:45.400 --> 03:24:47.400]  Я просто говорю, что
[03:24:47.400 --> 03:24:49.400]  last равно
[03:24:49.400 --> 03:24:51.400]  suf от last.
[03:24:51.480 --> 03:24:53.480]  Да, знаете, в таких
[03:24:53.480 --> 03:24:55.480]  случаях, кстати, очень удобно вводить
[03:24:55.480 --> 03:24:57.480]  такие функции.
[03:25:05.480 --> 03:25:07.480]  Вот.
[03:25:07.480 --> 03:25:09.480]  Вот, знаете, просто, ну, такие вот
[03:25:09.480 --> 03:25:11.480]  коротенькие такие
[03:25:11.480 --> 03:25:13.480]  функции, чтобы просто
[03:25:13.480 --> 03:25:15.480]  быстрее писать.
[03:25:15.480 --> 03:25:17.480]  Да, знаете, вот, может быть, даже
[03:25:17.480 --> 03:25:19.480]  имеет смысл их вот так писать, смотрите.
[03:25:19.560 --> 03:25:21.560]  Вот.
[03:25:21.560 --> 03:25:23.560]  Лен еще вот так можно писать.
[03:25:27.560 --> 03:25:29.560]  Не, но приватные все-таки.
[03:25:33.560 --> 03:25:35.560]  Зависит от вашего
[03:25:35.560 --> 03:25:37.560]  код-стайла. В моем код-стайле все
[03:25:37.560 --> 03:25:39.560]  приватное с нижним подчеркиваем.
[03:25:41.560 --> 03:25:43.560]  Потому что в некоторых код-стайлах
[03:25:43.560 --> 03:25:45.560]  и push, ну вот, в моем код-стайле
[03:25:45.560 --> 03:25:47.560]  все приватное с нижним подчеркиваем.
[03:25:47.640 --> 03:25:49.640]  В некоторых код-стайлах и push, ну вот,
[03:25:49.640 --> 03:25:51.640]  в некоторых push-back и push-back
[03:25:51.640 --> 03:25:53.640]  не так пишут.
[03:25:53.640 --> 03:25:55.640]  Вот.
[03:25:55.640 --> 03:25:57.640]  Ну, это как бы, то есть там,
[03:25:57.640 --> 03:25:59.640]  если у вас там на код C++ и другой код-стайл,
[03:25:59.640 --> 03:26:01.640]  то значит вы будете пользоваться другим код-стайлом.
[03:26:01.640 --> 03:26:03.640]  Или там, ну, как бы, как всегда
[03:26:03.640 --> 03:26:05.640]  он может быть один, там C++ и другой,
[03:26:05.640 --> 03:26:07.640]  в гугле третий, в яндексе четвертый,
[03:26:07.640 --> 03:26:09.640]  у вас в команде пятый.
[03:26:11.640 --> 03:26:13.640]  Ну, я имею в виду курс,
[03:26:13.640 --> 03:26:15.640]  ваш курс C++, естественно.
[03:26:15.720 --> 03:26:17.720]  Вот.
[03:26:17.720 --> 03:26:19.720]  Да, у STL, конечно, есть.
[03:26:19.720 --> 03:26:21.720]  Нет, у STL есть код-стайл.
[03:26:21.720 --> 03:26:23.720]  Так же, соответственно.
[03:26:23.720 --> 03:26:25.720]  Значит, смотрите.
[03:26:25.720 --> 03:26:27.720]  Так.
[03:26:27.720 --> 03:26:29.720]  Ну вот, значит, смотрите.
[03:26:29.720 --> 03:26:31.720]  Значит, что мы видим от last?
[03:26:31.720 --> 03:26:33.720]  Значит, что же тут за условие должно быть?
[03:26:33.720 --> 03:26:35.720]  Надо просто проверить, верно ли,
[03:26:35.720 --> 03:26:37.720]  что слева от этого полиндрома
[03:26:37.720 --> 03:26:39.720]  находится
[03:26:39.720 --> 03:26:41.720]  какой-то чаровый символ.
[03:26:41.800 --> 03:26:43.800]  Ну, значит, проверять
[03:26:43.800 --> 03:26:45.800]  это надо так.
[03:26:45.800 --> 03:26:47.800]  Ну, во-первых, что это за символ?
[03:26:47.800 --> 03:26:49.800]  Ну, давайте подумаем,
[03:26:49.800 --> 03:26:51.800]  вот что это у нас за символ,
[03:26:51.800 --> 03:26:53.800]  что, вообще, какой номер
[03:26:53.800 --> 03:26:55.800]  в строке этот символ имеет?
[03:26:55.800 --> 03:26:57.800]  Если у нас в конце
[03:26:57.800 --> 03:26:59.800]  вот сейчас полиндром, который находится
[03:26:59.800 --> 03:27:01.800]  в вершине last.
[03:27:07.800 --> 03:27:09.800]  Так.
[03:27:11.800 --> 03:27:13.800]  Так, минус 1.
[03:27:15.800 --> 03:27:17.800]  Нет, мы в ноль индексации.
[03:27:17.800 --> 03:27:19.800]  Но суть-то одна.
[03:27:19.800 --> 03:27:21.800]  Но суть-то одна. Н-ный символ — это сам ч.
[03:27:21.800 --> 03:27:23.800]  То есть по-хорошему мы должны написать,
[03:27:23.800 --> 03:27:25.800]  что пока вот этот символ
[03:27:25.800 --> 03:27:27.800]  не равен
[03:27:27.800 --> 03:27:29.800]  ч.
[03:27:29.800 --> 03:27:31.800]  В чем проверка такая,
[03:27:31.800 --> 03:27:33.800]  что в конце, в самом конце, если будет
[03:27:33.800 --> 03:27:35.800]  никогда не вести last, должен,
[03:27:35.800 --> 03:27:37.800]  лен от last должен стать минус 1,
[03:27:37.800 --> 03:27:39.800]  и тогда вот эта штука должна сойтись
[03:27:39.880 --> 03:27:41.880]  с н-ное, что должно быть равно ч.
[03:27:43.880 --> 03:27:45.880]  Но, к сожалению, есть мелкая проблема.
[03:27:45.880 --> 03:27:47.880]  Да, мелкая проблема бывает,
[03:27:47.880 --> 03:27:49.880]  лен от last бывает n, и
[03:27:49.880 --> 03:27:51.880]  тогда, получается, нам придется все-таки написать,
[03:27:51.880 --> 03:27:53.880]  что вот лен
[03:27:53.880 --> 03:27:55.880]  от last,
[03:27:55.880 --> 03:27:57.880]  к сожалению,
[03:27:57.880 --> 03:27:59.880]  бывает
[03:27:59.880 --> 03:28:01.880]  отрицательная, поэтому
[03:28:01.880 --> 03:28:03.880]  нам придется вот так написать.
[03:28:03.960 --> 03:28:05.960]  Даже вот так.
[03:28:07.960 --> 03:28:09.960]  Вот, да.
[03:28:09.960 --> 03:28:11.960]  Но, наверное, да, кстати,
[03:28:11.960 --> 03:28:13.960]  видимо, для оптимизации не помешает
[03:28:13.960 --> 03:28:15.960]  еще тут const написать.
[03:28:17.960 --> 03:28:19.960]  Тогда больше вероятно, что
[03:28:19.960 --> 03:28:21.960]  оптимизатор как бы вот это
[03:28:21.960 --> 03:28:23.960]  два раза вычислять не будет.
[03:28:23.960 --> 03:28:25.960]  Чтобы еще
[03:28:25.960 --> 03:28:27.960]  повыстроить,
[03:28:27.960 --> 03:28:29.960]  можно там, наверное, даже inline.
[03:28:29.960 --> 03:28:31.960]  Типа того, да.
[03:28:32.040 --> 03:28:34.040]  Так что вот такая красота, получается.
[03:28:38.040 --> 03:28:40.040]  Не люблю.
[03:28:40.040 --> 03:28:42.040]  Вот. Ну, допустим, ладно,
[03:28:42.040 --> 03:28:44.040]  это мои, допустим, какие-то.
[03:28:44.040 --> 03:28:46.040]  Ну, понятно.
[03:28:46.040 --> 03:28:48.040]  Окей.
[03:28:48.040 --> 03:28:50.040]  Смотрите.
[03:28:50.040 --> 03:28:52.040]  Next, дальше, while, соответственно,
[03:28:52.040 --> 03:28:54.040]  хорошо. Значит, что будет дальше?
[03:28:54.040 --> 03:28:56.040]  Дальше, получается,
[03:28:56.040 --> 03:28:58.040]  ваил, соответственно, хорошо.
[03:28:58.040 --> 03:29:00.040]  Ваил, соответственно, хорошо.
[03:29:00.120 --> 03:29:02.120]  Значит, что будет дальше?
[03:29:02.120 --> 03:29:04.120]  Дальше, получается, примерно, следующее.
[03:29:04.120 --> 03:29:06.120]  Так, ну, хорошо.
[03:29:06.120 --> 03:29:08.120]  Сам суффикс мы, значит,
[03:29:08.120 --> 03:29:10.120]  этот суффикс, который можно найти до q, мы нашли,
[03:29:10.120 --> 03:29:12.120]  и даже last уже находится в нем.
[03:29:12.120 --> 03:29:14.120]  Значит, дальше мы напишем,
[03:29:14.120 --> 03:29:16.120]  можно написать следующее.
[03:29:20.120 --> 03:29:22.120]  Значит, теперь,
[03:29:22.120 --> 03:29:24.120]  если нельзя пойти из вершины
[03:29:24.120 --> 03:29:26.120]  last по символу q,
[03:29:26.120 --> 03:29:28.120]  то мы тут
[03:29:28.200 --> 03:29:30.200]  делаем. Вычисляем, ищем префикс функцию.
[03:29:32.200 --> 03:29:34.200]  Но в конце мы говорим,
[03:29:34.200 --> 03:29:36.200]  что last равно go
[03:29:36.200 --> 03:29:38.200]  от last х.
[03:29:40.200 --> 03:29:42.200]  Ну, здесь мне просто удобно писать,
[03:29:42.200 --> 03:29:44.200]  что can go, пусть я там лезу в это дерево,
[03:29:44.200 --> 03:29:46.200]  можно ли из этой вершины пройти,
[03:29:46.200 --> 03:29:48.200]  если у меня есть переход из этой вершины
[03:29:48.200 --> 03:29:50.200]  по символу q, да или нет?
[03:29:50.200 --> 03:29:52.200]  Понятно, да?
[03:29:52.200 --> 03:29:54.200]  Вот.
[03:29:54.200 --> 03:29:56.200]  Ну, а go он просто берет и идет по этому
[03:29:56.280 --> 03:29:58.280]  символу, он у меня будет даже небезопасный.
[03:29:58.280 --> 03:30:00.280]  То есть он будет подразумевать, что переход есть,
[03:30:00.280 --> 03:30:02.280]  я просто туда пойду.
[03:30:02.280 --> 03:30:04.280]  Обычно я такие функции реализую в конце,
[03:30:04.280 --> 03:30:06.280]  потому что мне все равно компилятор скажет,
[03:30:06.280 --> 03:30:08.280]  что их надо там дописать.
[03:30:12.280 --> 03:30:14.280]  Ну, а это уже вопрос
[03:30:14.280 --> 03:30:16.280]  к тому,
[03:30:16.280 --> 03:30:18.280]  какие у вас настройки редактора.
[03:30:18.280 --> 03:30:20.280]  Как бы мне не сильно принципиально.
[03:30:20.360 --> 03:30:22.360]  Ладно, это не принципиально.
[03:30:22.360 --> 03:30:24.360]  Итак, поехали.
[03:30:24.360 --> 03:30:26.360]  Итак, что же делать?
[03:30:26.360 --> 03:30:28.360]  Ну, понятно, что здесь, в общем-то, не интересно,
[03:30:28.360 --> 03:30:30.360]  потому что как бы да.
[03:30:30.360 --> 03:30:32.360]  Итак, что же делать, если перехода нет?
[03:30:34.360 --> 03:30:36.360]  Так, что же делать, если перехода нет?
[03:30:40.360 --> 03:30:42.360]  Значит,
[03:30:42.360 --> 03:30:44.360]  пишем int
[03:30:44.360 --> 03:30:46.360]  n last
[03:30:46.360 --> 03:30:48.360]  равно, ну, точнее,
[03:30:48.440 --> 03:30:50.440]  создаем
[03:30:50.440 --> 03:30:52.440]  новую вершину.
[03:30:52.440 --> 03:30:54.440]  Она будет, естественно, номер точнее.
[03:30:54.440 --> 03:30:56.440]  Так, она будет
[03:30:56.440 --> 03:30:58.440]  nodis.size.
[03:30:58.440 --> 03:31:00.440]  Пишем nodis,
[03:31:00.440 --> 03:31:02.440]  значит, pushback-аем новую вершину.
[03:31:12.440 --> 03:31:14.440]  Значит, внимание,
[03:31:14.440 --> 03:31:16.440]  pushback-аем новую вершину.
[03:31:16.520 --> 03:31:18.520]  В этой вершине
[03:31:18.520 --> 03:31:20.520]  будет
[03:31:20.520 --> 03:31:22.520]  пустой мапчик,
[03:31:22.520 --> 03:31:24.520]  len будет равен
[03:31:24.520 --> 03:31:26.520]  len от n last
[03:31:26.520 --> 03:31:28.520]  плюс два
[03:31:28.520 --> 03:31:30.520]  и что-то еще.
[03:31:30.520 --> 03:31:32.520]  Чего?
[03:31:32.520 --> 03:31:34.520]  Ну, пока
[03:31:34.520 --> 03:31:36.520]  undefined.
[03:31:40.520 --> 03:31:42.520]  Понятно, да?
[03:31:42.520 --> 03:31:44.520]  Ну, можно так,
[03:31:44.600 --> 03:31:46.600]  там, любители оптимизации
[03:31:46.600 --> 03:31:48.600]  могут там placeback написать,
[03:31:48.600 --> 03:31:50.600]  если есть желание.
[03:31:52.600 --> 03:31:54.600]  Так, ну, теперь пришло время посчитать
[03:31:54.600 --> 03:31:56.600]  суффиксную ссылку.
[03:31:56.600 --> 03:31:58.600]  Undefined у нас
[03:31:58.600 --> 03:32:00.600]  специально, вообще, отдельно
[03:32:00.600 --> 03:32:02.600]  прописывается, чтобы что?
[03:32:02.600 --> 03:32:04.600]  Чего?
[03:32:04.600 --> 03:32:06.600]  Да нет, просто...
[03:32:06.600 --> 03:32:08.600]  Так, ну, во-первых,
[03:32:08.600 --> 03:32:10.600]  значит, сразу предупреждаю,
[03:32:10.600 --> 03:32:12.600]  нам придется здесь разобрать
[03:32:12.680 --> 03:32:14.680]  один вредный случай.
[03:32:14.680 --> 03:32:16.680]  Смотрите, дело в том, что нам
[03:32:16.680 --> 03:32:18.680]  надо как бы пойти в родителя
[03:32:18.680 --> 03:32:20.680]  этой вершины, которая сейчас в власти.
[03:32:20.680 --> 03:32:22.680]  Вот.
[03:32:22.680 --> 03:32:24.680]  Значит, который, соответственно, в власти.
[03:32:26.680 --> 03:32:28.680]  Вот.
[03:32:28.680 --> 03:32:30.680]  Из этого родителя хотя бы один раз
[03:32:30.680 --> 03:32:32.680]  скакнуть по суффиксной ссылке,
[03:32:32.680 --> 03:32:34.680]  а потом еще скакать до тех пор, пока не дойдем.
[03:32:34.680 --> 03:32:36.680]  Отсюда возникает случай.
[03:32:36.680 --> 03:32:38.680]  А что делать, если этот родитель
[03:32:38.680 --> 03:32:40.680]  уже с lenом равным минус один
[03:32:40.760 --> 03:32:42.760]  по суффиксной ссылке скакнуть нельзя?
[03:32:44.760 --> 03:32:46.760]  То есть, к сожалению, вот тут лишний
[03:32:46.760 --> 03:32:48.760]  ифчик придется написать.
[03:32:48.760 --> 03:32:50.760]  Значит, придется написать, что если
[03:32:50.760 --> 03:32:52.760]  last
[03:32:52.760 --> 03:32:54.760]  оказался
[03:32:54.760 --> 03:32:56.760]  вот этим вот нечетным
[03:32:56.760 --> 03:32:58.760]  корнем,
[03:32:58.760 --> 03:33:00.760]  то тогда что мы сделаем?
[03:33:04.760 --> 03:33:06.760]  То есть, мы тогда сделаем, что nodis от
[03:33:06.760 --> 03:33:08.760]  suf
[03:33:08.840 --> 03:33:10.840]  nodis от
[03:33:12.840 --> 03:33:14.840]  last
[03:33:14.840 --> 03:33:16.840]  точка
[03:33:16.840 --> 03:33:18.840]  back у вектора.
[03:33:18.840 --> 03:33:20.840]  Ну, нет, ну мы просто, тут лучше,
[03:33:20.840 --> 03:33:22.840]  что мы вот это новое, т.е. last это новая вершина.
[03:33:22.840 --> 03:33:24.840]  Вот, nodis last suf,
[03:33:24.840 --> 03:33:26.840]  тогда пишем, что она равна просто чему
[03:33:26.840 --> 03:33:28.840]  правильно, соответственно,
[03:33:28.840 --> 03:33:30.840]  к счетному корке.
[03:33:32.840 --> 03:33:34.840]  В противном случае
[03:33:34.840 --> 03:33:36.840]  начинаем что-то делать.
[03:33:36.920 --> 03:33:38.920]  Правда, смотрите, вот на самом деле, если не хочется
[03:33:38.920 --> 03:33:40.920]  вот это присваивание делать,
[03:33:40.920 --> 03:33:42.920]  смотрите, есть один наглый чит, который в большинстве
[03:33:42.920 --> 03:33:44.920]  случаев работает.
[03:33:44.920 --> 03:33:46.920]  Чит знаете, как называется?
[03:33:46.920 --> 03:33:48.920]  Вот так.
[03:33:49.000 --> 03:34:05.000]  Ну, хорошо, хорошо.
[03:34:09.000 --> 03:34:11.000]  Ну, в таком случае мы подразумеваем, что мы ссылки имеем.
[03:34:11.000 --> 03:34:13.000]  Очень удобно.
[03:34:13.000 --> 03:34:15.000]  Правда, есть одна
[03:34:15.000 --> 03:34:17.000]  nod. Правда, смотрите,
[03:34:17.080 --> 03:34:19.080]  правда, на самом деле,
[03:34:19.080 --> 03:34:21.080]  это надо использовать с большой оговорой,
[03:34:21.080 --> 03:34:23.080]  с большой осторожностью.
[03:34:23.080 --> 03:34:25.080]  Потому что,
[03:34:25.080 --> 03:34:27.080]  на самом деле, дело в том, что мы
[03:34:27.080 --> 03:34:29.080]  работаем с вектором.
[03:34:29.080 --> 03:34:31.080]  И вам, если вы вычисляете
[03:34:31.080 --> 03:34:33.080]  вот эту ссылку,
[03:34:33.080 --> 03:34:35.080]  то надо следить,
[03:34:35.080 --> 03:34:37.080]  что пока вы что-то присваиваете и работаете,
[03:34:37.080 --> 03:34:39.080]  надо следить за тем, чтобы эта
[03:34:39.080 --> 03:34:41.080]  ссылка не инвалидировалась.
[03:34:43.080 --> 03:34:45.080]  Потому что, знаете, у меня,
[03:34:45.160 --> 03:34:47.160]  когда я писал как-то, потому что я в Петроводске
[03:34:47.160 --> 03:34:49.160]  так полдня украни надебажил.
[03:34:49.160 --> 03:34:51.160]  Значит, прям сидел.
[03:34:51.160 --> 03:34:53.160]  Чего?
[03:34:53.160 --> 03:34:55.160]  Нет, и во время, и на контесте, и потом
[03:34:55.160 --> 03:34:57.160]  еще полдня в дорежке.
[03:34:57.160 --> 03:34:59.160]  А причина оказалась следующим.
[03:34:59.160 --> 03:35:01.160]  Дело в том, что я написал там
[03:35:01.160 --> 03:35:03.160]  вот какую-то строчку, вида
[03:35:07.160 --> 03:35:09.160]  нет, я написал там
[03:35:09.160 --> 03:35:11.160]  nodisware.suf
[03:35:11.160 --> 03:35:13.160]  равно, там условно, calc
[03:35:13.240 --> 03:35:15.240]  suffixlink.
[03:35:17.240 --> 03:35:19.240]  Вот так.
[03:35:21.240 --> 03:35:23.240]  Вот.
[03:35:23.240 --> 03:35:25.240]  Значит, какая бага
[03:35:25.240 --> 03:35:27.240]  потенциально
[03:35:27.240 --> 03:35:29.240]  здесь зашита? То есть я даже вот
[03:35:29.240 --> 03:35:31.240]  этого суфа я не делал, я просто вот так
[03:35:31.240 --> 03:35:33.240]  сделал. Оказалось
[03:35:33.240 --> 03:35:35.240]  следующее, что
[03:35:35.240 --> 03:35:37.240]  он, значит, компилятор оказался
[03:35:37.240 --> 03:35:39.240]  просто в укранине, вот я вам заранее
[03:35:39.240 --> 03:35:41.240]  скажу, есть подлянка в том, что вот эта функция
[03:35:41.320 --> 03:35:43.320]  сама по себе создает новые вершины.
[03:35:43.320 --> 03:35:45.320]  Может даже не одну.
[03:35:45.320 --> 03:35:47.320]  Может даже несколько.
[03:35:47.320 --> 03:35:49.320]  Вот. Ну вот.
[03:35:49.320 --> 03:35:51.320]  А кто когда-нибудь писал
[03:35:51.320 --> 03:35:53.320]  укранина, кстати?
[03:35:53.320 --> 03:35:55.320]  К сожалению.
[03:35:55.320 --> 03:35:57.320]  О господи. Слушай, это ты
[03:35:57.320 --> 03:35:59.320]  тогда так удачно в лошадь ездил?
[03:35:59.320 --> 03:36:01.320]  Или где-то еще?
[03:36:01.320 --> 03:36:03.320]  Вы мне читали, но я тогда не писал,
[03:36:03.320 --> 03:36:05.320]  я писал в ЛКШ.
[03:36:05.320 --> 03:36:07.320]  А, окей.
[03:36:07.320 --> 03:36:09.320]  Хорошо.
[03:36:09.400 --> 03:36:11.400]  Понятно. Хорошо.
[03:36:11.400 --> 03:36:13.400]  Ну понятно, да. Зачем это?
[03:36:13.400 --> 03:36:15.400]  Понятно. Значит, я понял алгоритм
[03:36:15.400 --> 03:36:17.400]  с 19-го раза. Ну это нормально.
[03:36:17.400 --> 03:36:19.400]  Я укранина в ЛКШ вообще не понял.
[03:36:19.400 --> 03:36:21.400]  Я его так писал еще в 8 часов.
[03:36:21.400 --> 03:36:23.400]  О да.
[03:36:23.400 --> 03:36:25.400]  Я просто терпеть не могу
[03:36:25.400 --> 03:36:27.400]  укранина после этого.
[03:36:27.400 --> 03:36:29.400]  Ну тут у кого как, потому что я помню, я в 10 классе
[03:36:29.400 --> 03:36:31.400]  я был в ЛКШ, у меня я Капелевич его рассказал.
[03:36:31.400 --> 03:36:33.400]  Сначала я рассказал Капелевич, я ничего не
[03:36:33.400 --> 03:36:35.400]  понял, слово в ноль.
[03:36:35.400 --> 03:36:37.400]  Не, просто сначала вам его 4 часа читают,
[03:36:37.480 --> 03:36:39.480]  вы в дупле идите, как оно работает,
[03:36:39.480 --> 03:36:41.480]  задаете миллиарды вопросов, потом
[03:36:41.480 --> 03:36:43.480]  еще 8 часов и вы пишете с дебагом.
[03:36:43.480 --> 03:36:45.480]  Так вот, да, твой опыт мы допоняли.
[03:36:45.480 --> 03:36:47.480]  Отвечаю, значит, мой. Значит, там
[03:36:47.480 --> 03:36:49.480]  Капелевич рассказывал полтора часа, я ничего
[03:36:49.480 --> 03:36:51.480]  не понял. Но правда со мной ничего не понял
[03:36:51.480 --> 03:36:53.480]  никто, а это была группа А вообще.
[03:36:53.480 --> 03:36:55.480]  Понял то, видимо, написать это
[03:36:55.480 --> 03:36:57.480]  после этого смог только один человек, возможно
[03:36:57.480 --> 03:36:59.480]  он просто тупо знал до этого.
[03:37:01.480 --> 03:37:03.480]  Ну почти, нет,
[03:37:03.480 --> 03:37:05.480]  Лев Толбачев. Значит, после
[03:37:05.560 --> 03:37:07.560]  его когда-то мы отдельно собрались, и это алгоритм
[03:37:07.560 --> 03:37:09.560]  рассказал Станкевич.
[03:37:09.560 --> 03:37:11.560]  Честно скажу, я тоже вообще ничего не понял, но количество
[03:37:11.560 --> 03:37:13.560]  аксептов в контесте увеличилось до 10.
[03:37:13.560 --> 03:37:15.560]  Видимо, я был тогда тупенький.
[03:37:21.560 --> 03:37:23.560]  Ну, а прошло так, прошло несколько
[03:37:23.560 --> 03:37:25.560]  там, пошло получается, сколько там,
[03:37:25.560 --> 03:37:27.560]  где-то там почти 2,5 года.
[03:37:27.560 --> 03:37:29.560]  На втором курсе
[03:37:29.560 --> 03:37:31.560]  я пришел на лекцию по алгоритмам,
[03:37:31.560 --> 03:37:33.560]  собственно, к моему, вот, собственно, преподаватель
[03:37:33.640 --> 03:37:35.640]  алгоритмов, это Виталий Борисович Эльштейн.
[03:37:35.640 --> 03:37:37.640]  Ну, я уже рассказывал о нем, ну вот.
[03:37:37.640 --> 03:37:39.640]  И он рассказал Уканина. Рассказал он его
[03:37:39.640 --> 03:37:41.640]  примерно за час, в чем рассказал так,
[03:37:41.640 --> 03:37:43.640]  чтобы, по крайней мере, лично я все сразу понял.
[03:37:43.640 --> 03:37:45.640]  Ну и, собственно, как он
[03:37:45.640 --> 03:37:47.640]  конкретно рассказывал, вот я, наверное, примерно вам
[03:37:47.640 --> 03:37:49.640]  и расскажу.
[03:37:49.640 --> 03:37:51.640]  Кроме понять,
[03:37:51.640 --> 03:37:53.640]  еще большая проблема его написать.
[03:37:53.640 --> 03:37:55.640]  Просто нам нюансов именно
[03:37:55.640 --> 03:37:57.640]  вот реализации такой точно
[03:37:57.640 --> 03:37:59.640]  много. Ну вот мы, вот мы и
[03:37:59.640 --> 03:38:01.640]  посмотрим, потому что потом, когда я
[03:38:01.720 --> 03:38:03.720]  впервые написал Уканину, даже на джаве.
[03:38:03.720 --> 03:38:05.720]  И никаких проблем даже не возникло.
[03:38:05.720 --> 03:38:07.720]  Там столько вот всяких
[03:38:07.720 --> 03:38:09.720]  мерзких ифов, которые
[03:38:09.720 --> 03:38:11.720]  можно пропустить. Познакомимся.
[03:38:11.720 --> 03:38:13.720]  Понятно. Так вот.
[03:38:13.720 --> 03:38:15.720]  Ребят, давайте не будем это тратить
[03:38:15.720 --> 03:38:17.720]  время. Значит, смотрите. Так вот.
[03:38:17.720 --> 03:38:19.720]  Я просто к чему? Значит, я вот писал
[03:38:19.720 --> 03:38:21.720]  это в Укане. Так вот, в Укане возникла такая подлянка.
[03:38:21.720 --> 03:38:23.720]  Значит, Калк Суферслинк менял
[03:38:23.720 --> 03:38:25.720]  то есть вера, то есть
[03:38:25.720 --> 03:38:27.720]  как бы добавлял вершины, то есть
[03:38:27.720 --> 03:38:29.720]  пушбекал их в вектор.
[03:38:29.800 --> 03:38:31.800]  Получилось так, что компилятор сначала вычислил
[03:38:31.800 --> 03:38:33.800]  вот эту ссылку, куда присваивать,
[03:38:33.800 --> 03:38:35.800]  да.
[03:38:35.800 --> 03:38:37.800]  А потом
[03:38:37.800 --> 03:38:39.800]  запустил эту функцию и инвалидировал
[03:38:39.800 --> 03:38:41.800]  вектор. То есть вот эту ссылку
[03:38:41.800 --> 03:38:43.800]  инвалидировалась.
[03:38:43.800 --> 03:38:45.800]  То есть очень сложно было дебагать,
[03:38:45.800 --> 03:38:47.800]  потому что когда я написал там
[03:38:47.800 --> 03:38:49.800]  что-то дебаггерское типа int у равно
[03:38:49.800 --> 03:38:51.800]  вот там,
[03:38:51.800 --> 03:38:53.800]  то есть типа написал, что это мы потом
[03:38:53.800 --> 03:38:55.800]  взяли после, то оно не совпадало.
[03:38:55.800 --> 03:38:57.800]  Так. Ркал Катве, значит,
[03:38:57.880 --> 03:38:59.880]  ср у соответственно
[03:38:59.880 --> 03:39:01.880]  нодис
[03:39:01.880 --> 03:39:03.880]  от v.suf равно у
[03:39:03.880 --> 03:39:05.880]  все почему-то начинало работать.
[03:39:05.880 --> 03:39:07.880]  Ну вот вы уже поняли почему.
[03:39:09.880 --> 03:39:11.880]  То есть поэтому просто вот
[03:39:11.880 --> 03:39:13.880]  есть такая вот подлянка есть.
[03:39:13.880 --> 03:39:15.880]  То есть чисто
[03:39:15.880 --> 03:39:17.880]  сишная вот подлянка такая есть.
[03:39:17.880 --> 03:39:19.880]  Поэтому вот будьте внимательны.
[03:39:19.880 --> 03:39:21.880]  То есть поэтому надо
[03:39:21.880 --> 03:39:23.880]  поэтому я просто сказал, пользуйтесь
[03:39:23.880 --> 03:39:25.880]  вектором, то есть два варианта. Можете на самом деле
[03:39:25.960 --> 03:39:27.960]  вместо вектора создать статический массив
[03:39:27.960 --> 03:39:29.960]  и там pushback просто сдвигая
[03:39:29.960 --> 03:39:31.960]  указатель.
[03:39:31.960 --> 03:39:33.960]  Компилятор должен
[03:39:33.960 --> 03:39:35.960]  понимать, что оно
[03:39:35.960 --> 03:39:37.960]  никому он ничего не должен.
[03:39:37.960 --> 03:39:39.960]  Он вычисляет левую функцию, вычисляет правую
[03:39:39.960 --> 03:39:41.960]  функцию. Все.
[03:39:41.960 --> 03:39:43.960]  Это просто значение левой функции
[03:39:43.960 --> 03:39:45.960]  и value-value это ссылка. Так что
[03:39:45.960 --> 03:39:47.960]  как бы
[03:39:47.960 --> 03:39:49.960]  просто так работает C++.
[03:39:49.960 --> 03:39:51.960]  Просто там с годами некоторые
[03:39:51.960 --> 03:39:53.960]  гарантии заводят, что что-то вычисляется раньше,
[03:39:54.040 --> 03:39:56.040]  может быть. Так вот.
[03:39:56.040 --> 03:39:58.040]  Это я просто предупредил.
[03:39:58.040 --> 03:40:00.040]  Просто чтобы какие
[03:40:00.040 --> 03:40:02.040]  аккуратности нужны. А так вот в принципе можно
[03:40:02.040 --> 03:40:04.040]  сув тоже вот так присваивать.
[03:40:04.040 --> 03:40:06.040]  Значит поехали.
[03:40:06.040 --> 03:40:08.040]  То есть желательно, чтобы когда используете ссылку
[03:40:08.040 --> 03:40:10.040]  у вас там никаких вектор точно
[03:40:10.040 --> 03:40:12.040]  не изменялся.
[03:40:12.040 --> 03:40:14.040]  Так вот поехали.
[03:40:14.040 --> 03:40:16.040]  Значит поехали. Здесь надо сказать, если
[03:40:16.040 --> 03:40:18.040]  last равно true, то тут все просто.
[03:40:18.040 --> 03:40:20.040]  В противном случае пишем
[03:40:20.040 --> 03:40:22.040]  int, значит скачем вот этим рыжим указателем
[03:40:24.040 --> 03:40:26.040]  Как мы его назовем
[03:40:26.040 --> 03:40:28.040]  этот рыжий указатель?
[03:40:30.040 --> 03:40:32.040]  Ну да.
[03:40:34.040 --> 03:40:36.040]  Ну да.
[03:40:36.040 --> 03:40:38.040]  Получился апельсиновый указатель.
[03:40:38.040 --> 03:40:40.040]  Ну тоже позитивчик какой-то.
[03:40:40.040 --> 03:40:42.040]  Ну да, вот почему orange
[03:40:42.040 --> 03:40:44.040]  а не brown.
[03:40:44.040 --> 03:40:46.040]  Orange PTR for
[03:40:48.040 --> 03:40:50.040]  значит orange
[03:40:50.120 --> 03:40:52.120]  brown PTR
[03:40:54.120 --> 03:40:56.120]  значит orange
[03:40:56.120 --> 03:40:58.120]  PTR равно
[03:40:58.120 --> 03:41:00.120]  suv от last
[03:41:02.120 --> 03:41:04.120]  значит получается suv от last
[03:41:04.120 --> 03:41:06.120]  orange PTR
[03:41:06.120 --> 03:41:08.120]  нет, хотя нет.
[03:41:08.120 --> 03:41:10.120]  В данном случае давайте уже copy
[03:41:10.120 --> 03:41:12.120]  paste while.
[03:41:16.120 --> 03:41:18.120]  То есть фактически он пишем
[03:41:18.200 --> 03:41:20.200]  suv от last
[03:41:22.200 --> 03:41:24.200]  Значит пишем абсолютно
[03:41:24.200 --> 03:41:26.200]  то же самое, только вот вместо last
[03:41:26.200 --> 03:41:28.200]  пишем orange PTR
[03:41:36.200 --> 03:41:38.200]  То есть пока вот выполняется ровно
[03:41:38.200 --> 03:41:40.200]  то же самое, хотя вот это тут по идее можно
[03:41:40.200 --> 03:41:42.200]  не писать, потому что это будет уже заведомо
[03:41:42.200 --> 03:41:44.200]  как бы больше либо равно нуля,
[03:41:44.200 --> 03:41:46.200]  но тем не менее.
[03:41:46.280 --> 03:41:48.280]  То же пишем orange PTR
[03:41:48.280 --> 03:41:50.280]  равно suv
[03:41:50.280 --> 03:41:52.280]  от orange PTR
[03:41:56.280 --> 03:41:58.280]  Обратите внимание, кстати тут большой
[03:41:58.280 --> 03:42:00.280]  соблазн на самом деле написать
[03:42:00.280 --> 03:42:02.280]  знаете у меня вот была такая когда-то бара
[03:42:02.280 --> 03:42:04.280]  когда я вместо вот этой штуки
[03:42:04.280 --> 03:42:06.280]  написал там
[03:42:06.280 --> 03:42:08.280]  что-то типа can go из orange PTR
[03:42:08.280 --> 03:42:10.280]  по символу chart
[03:42:12.280 --> 03:42:14.280]  То есть просто проверять нельзя
[03:42:14.360 --> 03:42:16.360]  Что?
[03:42:16.360 --> 03:42:18.360]  Сейчас
[03:42:20.360 --> 03:42:22.360]  А, окей, да
[03:42:22.360 --> 03:42:24.360]  То есть мы тут проверяем как
[03:42:24.360 --> 03:42:26.360]  мы в самой строке проверяем
[03:42:26.360 --> 03:42:28.360]  можно ли соответствующий suv продлить на символ
[03:42:28.360 --> 03:42:30.360]  chart влево и вправо
[03:42:30.360 --> 03:42:32.360]  Так вот, бывает соблазн
[03:42:32.360 --> 03:42:34.360]  на самом деле, особенно после всяких
[03:42:34.360 --> 03:42:36.360]  карасиков с уконенными
[03:42:36.360 --> 03:42:38.360]  проверять это просто
[03:42:38.360 --> 03:42:40.360]  нельзя ли из вершины orange PTR
[03:42:40.360 --> 03:42:42.360]  пройти в символ chart
[03:42:42.440 --> 03:42:44.440]  Так вот, это ошибка
[03:42:44.440 --> 03:42:46.440]  Потому что из того, что
[03:42:46.440 --> 03:42:48.440]  есть такой же полиндром orange PTR
[03:42:48.440 --> 03:42:50.440]  плюс символ
[03:42:50.440 --> 03:42:52.440]  chart влево и вправо никак не следует
[03:42:52.440 --> 03:42:54.440]  что именно этот полиндром является
[03:42:54.440 --> 03:42:56.440]  суффиксом нашего нового полиндрома
[03:42:56.440 --> 03:42:58.440]  у которого мы эти суффиксы ищем
[03:42:58.440 --> 03:43:00.440]  и там можно придумать, и там вы получите
[03:43:00.440 --> 03:43:02.440]  VA8 в котором стоит
[03:43:02.440 --> 03:43:04.440]  и там в соответствующей задаче будет
[03:43:04.440 --> 03:43:06.440]  VA8 и с контратест
[03:43:06.440 --> 03:43:08.440]  в котором есть тест в котором это действительно работает
[03:43:08.440 --> 03:43:10.440]  Если у нас символ совпадает
[03:43:10.520 --> 03:43:12.520]  то мы можем перейти, но если он не совпадает
[03:43:12.520 --> 03:43:14.520]  то нам никуда идти нет
[03:43:14.520 --> 03:43:16.520]  то есть тут лучше вот
[03:43:16.520 --> 03:43:18.520]  поэтому так
[03:43:18.520 --> 03:43:20.520]  ну и в конце соответственно мы говорим, что
[03:43:20.520 --> 03:43:22.520]  да
[03:43:24.520 --> 03:43:26.520]  ой, совсем забыл
[03:43:26.520 --> 03:43:28.520]  надо же не просто по push back
[03:43:28.520 --> 03:43:30.520]  а надо еще сказать
[03:43:30.520 --> 03:43:32.520]  nodis от соответственно last
[03:43:32.520 --> 03:43:34.520]  точка children
[03:43:36.520 --> 03:43:38.520]  от символа ch должно быть
[03:43:38.600 --> 03:43:40.600]  равно n last
[03:43:40.600 --> 03:43:42.600]  ну это так или иначе
[03:43:42.600 --> 03:43:44.600]  а, ну конечно
[03:43:44.600 --> 03:43:46.600]  значит скачем
[03:43:46.600 --> 03:43:48.600]  знаем, что так как мы стартовали не изодруто
[03:43:48.600 --> 03:43:50.600]  то мы рано или поздно найдем куда
[03:43:50.600 --> 03:43:52.600]  то есть получается мы это заведомо ищем
[03:43:52.600 --> 03:43:54.600]  не для полиндрома длины 1
[03:43:54.600 --> 03:43:56.600]  то есть мы заметим, что вот это случае работает тогда и только тогда
[03:43:56.600 --> 03:43:58.600]  когда новая вершина имеет длину 1
[03:43:58.600 --> 03:44:00.600]  то есть мы новый символ добавили
[03:44:00.600 --> 03:44:02.600]  а в противном случае нам все что тут остается
[03:44:02.600 --> 03:44:04.600]  это написать, что
[03:44:04.680 --> 03:44:06.680]  ну вот
[03:44:06.680 --> 03:44:08.680]  значит чего тут написать
[03:44:08.680 --> 03:44:10.680]  last равно go от last
[03:44:10.680 --> 03:44:12.680]  это мы сказали
[03:44:12.680 --> 03:44:14.680]  тогда написать suv
[03:44:14.680 --> 03:44:16.680]  от orange ptr
[03:44:16.680 --> 03:44:18.680]  точнее от pardon
[03:44:18.680 --> 03:44:20.680]  от n last
[03:44:20.680 --> 03:44:22.680]  равно
[03:44:22.680 --> 03:44:24.680]  просто go
[03:44:24.680 --> 03:44:26.680]  из orange ptr
[03:44:26.680 --> 03:44:28.680]  мы гарантируем, что там уже можно пройти
[03:44:28.680 --> 03:44:30.680]  по символу ch
[03:44:30.680 --> 03:44:32.680]  все
[03:44:32.760 --> 03:44:34.760]  не сильно много кода получилось, да?
[03:44:34.760 --> 03:44:36.760]  я почему-то не учею в этом пару строк
[03:44:36.760 --> 03:44:38.760]  особенно вот про
[03:44:38.760 --> 03:44:40.760]  давай посмотрим
[03:44:40.760 --> 03:44:42.760]  давай
[03:44:42.760 --> 03:44:44.760]  давай узнаем почему
[03:44:46.760 --> 03:44:48.760]  не, может просто не понял
[03:44:48.760 --> 03:44:50.760]  конкретно ваш вариант
[03:44:50.760 --> 03:44:52.760]  как оно выглядит, но
[03:44:52.760 --> 03:44:54.760]  не знаю
[03:44:54.760 --> 03:44:56.760]  я не знаю
[03:44:56.760 --> 03:44:58.760]  я не знаю
[03:44:58.760 --> 03:45:00.760]  я не знаю
[03:45:00.840 --> 03:45:02.840]  как оно выглядит, но
[03:45:02.840 --> 03:45:04.840]  а ну ладно
[03:45:04.840 --> 03:45:06.840]  это go и can go еще надо написать
[03:45:06.840 --> 03:45:08.840]  но это еще две строчки
[03:45:08.840 --> 03:45:10.840]  буквально
[03:45:20.840 --> 03:45:22.840]  а просто у нас если наш родитель
[03:45:22.840 --> 03:45:24.840]  это od root
[03:45:24.920 --> 03:45:26.920]  ну да
[03:45:26.920 --> 03:45:28.920]  тогда тут все просто
[03:45:28.920 --> 03:45:30.920]  это будет тогда и только тогда
[03:45:30.920 --> 03:45:32.920]  когда у нас полиндром длины 1
[03:45:32.920 --> 03:45:34.920]  в противном случае у нас полиндром
[03:45:34.920 --> 03:45:36.920]  длины 2 или более и тогда этот код прекрасно
[03:45:36.920 --> 03:45:38.920]  работает
[03:45:38.920 --> 03:45:40.920]  вот
[03:45:46.920 --> 03:45:48.920]  ну просто там тогда мы
[03:45:48.920 --> 03:45:50.920]  в противном случае мы гарантируем, что там хотя бы одна
[03:45:50.920 --> 03:45:52.920]  суффиксная ссылка у родителя
[03:45:53.000 --> 03:45:55.000]  это реально есть
[03:45:55.000 --> 03:45:57.000]  и мы обязательно в какой-то момент упремся в строку длины
[03:45:57.000 --> 03:45:59.000]  минус 1
[03:46:05.000 --> 03:46:07.000]  так если last равно, то есть мы обрабатываем
[03:46:07.000 --> 03:46:09.000]  полиндром длины 2 и родитель у нас even root
[03:46:09.000 --> 03:46:11.000]  давайте смотреть
[03:46:11.000 --> 03:46:13.000]  что тогда произойдет, он пойдет по суффиксной ссылке
[03:46:13.000 --> 03:46:15.000]  отправится в минус 1
[03:46:15.000 --> 03:46:17.000]  то есть в od root
[03:46:17.000 --> 03:46:19.000]  то есть нечетный
[03:46:19.000 --> 03:46:21.000]  из него переход
[03:46:21.080 --> 03:46:23.080]  это было уже заведомо есть и он по нему пройдет
[03:46:23.080 --> 03:46:25.080]  вот и все
[03:46:25.080 --> 03:46:27.080]  вот так что
[03:46:27.080 --> 03:46:29.080]  ну go и значит эти две строчки
[03:46:29.080 --> 03:46:31.080]  там go вы там уже напишите в качестве упражнения
[03:46:31.080 --> 03:46:33.080]  сами
[03:46:33.080 --> 03:46:35.080]  вот
[03:46:35.080 --> 03:46:37.080]  да
[03:46:37.080 --> 03:46:39.080]  ну да по-разному вопрос только
[03:46:39.080 --> 03:46:41.080]  какая-то там как мапа
[03:46:41.080 --> 03:46:43.080]  я бы рекомендовал писать аккуратно
[03:46:43.080 --> 03:46:45.080]  то есть bool can go конечно
[03:46:45.080 --> 03:46:47.080]  лучше писать там int v
[03:46:47.080 --> 03:46:49.080]  char ch
[03:46:49.160 --> 03:46:51.160]  ну естественно нужно писать как
[03:46:51.160 --> 03:46:53.160]  return
[03:46:53.160 --> 03:46:55.160]  значит
[03:46:55.160 --> 03:46:57.160]  nodis от v точка
[03:46:57.160 --> 03:46:59.160]  children точка
[03:46:59.160 --> 03:47:01.160]  count от ch
[03:47:01.160 --> 03:47:03.160]  ну то есть
[03:47:03.160 --> 03:47:05.160]  да чтобы не создать лишнюю вершину
[03:47:05.160 --> 03:47:07.160]  ну я так на всякий случай пропишу
[03:47:07.160 --> 03:47:09.160]  причина писать на массиве
[03:47:09.160 --> 03:47:11.160]  ну при условии что алфавита
[03:47:11.160 --> 03:47:13.160]  пожалуйста да
[03:47:13.160 --> 03:47:15.160]  потому что по памяти оно почти везде заходит
[03:47:15.160 --> 03:47:17.160]  ну да да да да да
[03:47:17.240 --> 03:47:19.240]  конечно
[03:47:19.240 --> 03:47:21.240]  но да
[03:47:21.240 --> 03:47:23.240]  ну и здесь соответственно return nodis
[03:47:23.240 --> 03:47:25.240]  от v точка children
[03:47:25.240 --> 03:47:27.240]  от ch все
[03:47:27.240 --> 03:47:29.240]  то есть на указателях оно может не зайти
[03:47:29.240 --> 03:47:31.240]  ну можно
[03:47:31.240 --> 03:47:33.240]  как хотите
[03:47:33.240 --> 03:47:35.240]  ну я из-за нет смысла в данном случае в указателях
[03:47:35.240 --> 03:47:37.240]  наверное все таки хотя на вашу смотреть
[03:47:37.240 --> 03:47:39.240]  да то есть дальше
[03:47:39.240 --> 03:47:41.240]  ну то есть дальше как
[03:47:41.240 --> 03:47:43.240]  позже ну
[03:47:43.240 --> 03:47:45.240]  не знаю
[03:47:45.240 --> 03:47:47.240]  тут
[03:47:47.240 --> 03:47:49.240]  на вкус и цвет всегда можно и так
[03:47:49.240 --> 03:47:51.240]  и так
[03:47:51.240 --> 03:47:53.240]  так что вот получается и все дерево
[03:47:53.240 --> 03:47:55.240]  полидромов в общем так оказалось не сильно сложно
[03:47:55.240 --> 03:47:57.240]  вот
[03:47:57.240 --> 03:47:59.240]  то есть более того чем
[03:47:59.240 --> 03:48:01.240]  это нам вообще помогает
[03:48:01.240 --> 03:48:03.240]  ну здесь давайте в конце я все таки
[03:48:03.240 --> 03:48:05.240]  добавлю еще это чтобы мы не просто
[03:48:05.240 --> 03:48:07.240]  строили а на самом деле можно отметить что дерево
[03:48:07.240 --> 03:48:09.240]  полидромов конечно позволяет с этими полидромами
[03:48:09.240 --> 03:48:11.240]  очень красиво работать
[03:48:11.240 --> 03:48:13.240]  ну например самая тупая задача
[03:48:13.240 --> 03:48:15.240]  на самом деле такая
[03:48:15.240 --> 03:48:17.240]  то есть например нам вот
[03:48:17.240 --> 03:48:19.240]  допустим нам очень захочется
[03:48:19.240 --> 03:48:21.240]  до нас строка она фиксирована
[03:48:21.240 --> 03:48:23.240]  и нам приходят запросы про вот эту
[03:48:23.240 --> 03:48:25.240]  строку p которая полидромов
[03:48:25.240 --> 03:48:27.240]  и нас спрашивают является ли она под строкой
[03:48:27.240 --> 03:48:29.240]  ну мы это теперь сделаем без труда
[03:48:29.240 --> 03:48:31.240]  да
[03:48:31.240 --> 03:48:33.240]  а теперь внимание
[03:48:33.240 --> 03:48:35.240]  предположим что нам случайно
[03:48:35.240 --> 03:48:37.240]  говорят что
[03:48:37.240 --> 03:48:39.240]  нам допустим говорят что
[03:48:39.240 --> 03:48:41.240]  если она есть то скажите
[03:48:41.240 --> 03:48:43.440]  там самое первое вхождение этой
[03:48:43.440 --> 03:48:45.440]  строки
[03:48:45.440 --> 03:48:47.440]  или самое последнее
[03:48:47.440 --> 03:48:49.440]  или количество
[03:48:49.440 --> 03:48:51.440]  ну это вроде
[03:48:51.440 --> 03:48:53.440]  количество уже не так тривиально
[03:48:53.440 --> 03:48:55.440]  ну там хоть сколько то
[03:48:55.440 --> 03:48:57.440]  думать надо там первое вхождение
[03:48:57.440 --> 03:48:59.440]  ну первое
[03:48:59.440 --> 03:49:01.440]  так ну первое вхождение
[03:49:01.440 --> 03:49:03.440]  первое вхождение конечно каждого полидрома
[03:49:03.440 --> 03:49:05.440]  действительно тривиально потому что первое вхождение
[03:49:05.440 --> 03:49:07.440]  у вершины это когда
[03:49:07.440 --> 03:49:09.440]  вы ее создали правда
[03:49:09.440 --> 03:49:21.040]  очевидно, да, просто сохраните момент времени и возрадуйтесь, а вот значит, так тут понятно, о чем я о чем речь, а
[03:49:22.680 --> 03:49:28.880]  то тут вот у нас, а то у нас тут знающий Денис действительно сразу все рассказывает, да, вот,
[03:49:30.240 --> 03:49:36.740]  но идея на самом деле очень проста, то есть идея, то есть на самом деле, допустим, мы хотим теперь для каждого суффикса
[03:49:36.740 --> 03:49:43.180]  пометить, сколько раз он встречался, как нам это сделать, но идея на самом деле очень простая, то есть давайте, когда мы строим дерево
[03:49:43.180 --> 03:49:50.540]  полиндромов, мы знаем самый большой суффикс, который полиндром, да, то есть давайте для него и для всех из всего его
[03:49:50.540 --> 03:49:57.440]  префиксного пути, то есть этого суффиксного пути, прибавим там в черчах единичку, да, тогда у нас будет в конце в точности
[03:49:57.440 --> 03:50:03.740]  ответная задача, единственная мелкая оговорка заключается в том, что, конечно, если мы так будем берем, это будет квадрат,
[03:50:03.740 --> 03:50:11.740]  понятно, да, но как, но как этот квадрат оптимизировать до линии, да, очень просто, давайте просто сохраним для каждой вершины,
[03:50:11.740 --> 03:50:17.740]  что мы тут прибавляли единичку, а потом после того, как мы построим дерево полиндромов для всего, мы эти единички просто наверх
[03:50:17.740 --> 03:50:24.740]  пропихнем стандартным образом, там либо ДФС, либо просто пробежимся по дереву справа налево и будем там говорить, что
[03:50:24.740 --> 03:50:31.740]  там прибавь мое число к суффиксной ссылке, да, то есть как угол, то есть там лениво, то есть более того, аналогичным образом можно
[03:50:32.740 --> 03:50:38.740]  пропихивать и последние вхождения, то есть для каждой, то есть каждый раз, когда вы пришли суффикс, да, какой-нибудь самый большой,
[03:50:38.740 --> 03:50:46.740]  вы записываете, что я его видел сейчас, а потом в конце пропихиваем, что если я себя видел сейчас, то и суффиксную ссылку я видел сейчас,
[03:50:46.740 --> 03:50:55.740]  то есть выбираем максимум, вот, то есть самая крутая задача, то есть у вас там, то есть это на самом деле в 2014 году,
[03:50:55.740 --> 03:51:00.740]  вот, то есть, знаете, в диссертации Рубинчика, на этом, кстати, очень смешно, знаете, редкий случай, когда олимпиадному программисту,
[03:51:00.740 --> 03:51:07.740]  с точки зрения даже олимпиадной практики, интересно почитать кандидатскую диссертацию, потому что там какие страны в обосновании
[03:51:07.740 --> 03:51:13.740]  того, зачем это надо, там тоже расписываются, знаете, вот, бывают такие соревнования CPC и там вот подсовывают задачи на полиндромы,
[03:51:13.740 --> 03:51:21.740]  в которых там какие-то зубодробительные решения, вот, например, одна из таких задач, например, была в 2014 году данные две строки,
[03:51:21.740 --> 03:51:35.740]  там С и Т, я хочу найти количество таких четверок там И, Ж, К, Л, что под строка С и по Ж совпадает с под строкой Т от К, Л,
[03:51:35.740 --> 03:51:49.740]  и при этом эта подстрока является полиндромом, вот, то есть, нет, у меня самого был прикол, что я тогда не знал дерева полиндромов еще,
[03:51:49.740 --> 03:51:57.740]  дерева полиндромов это тривиально делается, сейчас, ну, сейчас, погоди, ну, там вот действительно просто интересно, давайте,
[03:51:57.740 --> 03:52:05.740]  ну, тривиально нет реально, но техника стандарта, значит, как тогда это делать, ну, идея такая, ну, например, одна из идей на самом деле может быть такая,
[03:52:05.740 --> 03:52:19.740]  то есть, давайте, ну, значит, как это можно сделать, вот, ну, на самом деле можно сделать по-разному, можно, например, пробежаться по строке С,
[03:52:19.740 --> 03:52:29.740]  построить дерево полиндромов, построить дерево полиндромов и заодно там для, ну, да, ну, просто, короче, построить дерево полиндромов,
[03:52:30.740 --> 03:52:38.740]  тогда идея такая, а теперь возьмем строку Т, для нее не будем строить дерево полиндромов, а будем, так сказать, ходить по строкой Т,
[03:52:38.740 --> 03:52:45.740]  по дереву полиндромов в строке С, то есть, что я имею в виду, я буду иметь в виду, что я буду идти Т слева направо,
[03:52:45.740 --> 03:52:55.740]  и в этот момент времени я хочу знать самую длинную подстроку, которая заканчивается в этом символе и которая не просто является полиндромом,
[03:52:55.740 --> 03:53:02.740]  но является полиндромом, который встречается в строке С. А в строке Т как мы будем проверять, что встречается?
[03:53:02.740 --> 03:53:12.740]  Так зачем? Я же говорил, определение еще раз. Я хочу для каждого символа этого символа строки Т найти самую длинную подстроку строки Т,
[03:53:12.740 --> 03:53:19.740]  которая заканчивается в этом символе и является полиндромом, встречающимся в С. Ну, не очень понятно, как это сделать.
[03:53:20.740 --> 03:53:29.740]  Элементарно. То есть, делать я это буду следующим классическим образом, вот это надо обсудить.
[03:53:29.740 --> 03:53:35.740]  Нет, погоди. Ну, я рассказываю другой метод. Так, давайте я это выключу тогда.
[03:53:35.740 --> 03:53:44.740]  Так, давай, погоди, погоди. Слушай, как бы на эту тему я так скажу, на вкус и цвет фломастера разные, а изучить стоит несколько способов,
[03:53:44.740 --> 03:53:51.740]  потому что тут кому как. Потому что я, например, вот первое решение, которое у меня тут приходит в голову вот такое.
[03:53:51.740 --> 03:53:59.740]  Вот это мы убираем, эту красоту, все. Жалко, что убираем, вот придем. Если бы это осталось, конечно, до понедельника, это была бы красота, конечно.
[03:53:59.740 --> 03:54:08.740]  Нет, знаете, потому что забавно, почему... Да? Так тут и прикол. Более того, я каждый раз прихожу, и тут остается то, что осталось у меня после среды.
[03:54:08.740 --> 03:54:16.740]  Вот это красиво. Ну, вот, ладно, вот это я оставлю, да.
[03:54:16.740 --> 03:54:22.740]  А на сколько мы, собственно, говорили, что 45 минут... Все, все, все.
[03:54:22.740 --> 03:54:30.740]  Я говорил 30 через 45. Ну ладно, ну.
[03:54:31.740 --> 03:54:41.740]  Значит, сейчас быстренько, значит, смотрите. То есть первое смысл такой, что, значит, мы... Жала была строка С, мы построили по ней дерево полиндромов.
[03:54:41.740 --> 03:54:53.740]  Теперь идея такая, идем по строке Т. Я хочу для каждой позиции И хранить максимальный суффикс, у которого есть вершинка в этом дереве полиндромов.
[03:54:54.740 --> 03:54:59.740]  Так вот, дальше у меня идея такая. Хочу перейти от И к И плюс один. Как я это сделал?
[03:54:59.740 --> 03:55:08.740]  Во-первых, я проверю, не совпадает ли вот этот символ с этим. Если совпадает, то я проверю, а нельзя ли из этой вершины здесь пойти по символу С.
[03:55:08.740 --> 03:55:19.740]  Если можно, то иду, а если нельзя, значит, этот полиндром нас не устраивает. Ну, дальше, получается, скачем по суффиксным ссылкам до тех пор, пока две звезды не сойдутся.
[03:55:19.740 --> 03:55:29.740]  То есть и тут символ С окажется, и там переход такой будет. То есть, получается, я для каждой позиции И нашел самый длинный суффикс, который тут встречается.
[03:55:29.740 --> 03:55:38.740]  Но тогда, получается, я могу в потенциальном ответе прибавить, сказать, что этот суффикс, вот мы нашли еще вхождение этого суффикса, а также всего его суффиксного пути.
[03:55:38.740 --> 03:55:47.740]  То есть отложенное прибавление единички на пути от вершины до корня. Только в дереве суффиксных ссылок.
[03:55:47.740 --> 03:55:50.740]  Ну, мы же тоже самое делаем, когда количество считаем.
[03:55:50.740 --> 03:55:51.740]  Ну, по сути...
[03:55:51.740 --> 03:55:52.740]  Можно еще раз?
[03:55:52.740 --> 03:55:53.740]  Давай, погоди.
[03:55:53.740 --> 03:55:59.740]  Ну, еще раз. Пусть мы для этого символа его знаем.
[03:55:59.740 --> 03:56:07.740]  Тогда нам что нужно? Нам нужно перебрать все вот эти суффиксы, которые являются встречающимися тут полиндромами. Это мы делаем с помощью суффиксных ссылок.
[03:56:07.740 --> 03:56:11.740]  И для каждого из них проверяем. Ну, начиная прямо сам первого.
[03:56:11.740 --> 03:56:18.740]  Во-первых, верно ли, что тут не только этот суффикс существует, но из него можно пойти по символу С в дереве полиндромов?
[03:56:18.740 --> 03:56:22.740]  А во-вторых, верно ли, что этот символ С еще есть здесь?
[03:56:22.740 --> 03:56:27.740]  То есть, как только мы на него наткнемся, значит, вот ура, этот суффикс на месте.
[03:56:27.740 --> 03:56:31.740]  То есть, получается, очевидно, этот проход тоже делается за линию.
[03:56:31.740 --> 03:56:37.740]  То есть, это просто стандартный такой проход. Мы в Ахакарасике каком-нибудь или вообще где угодно будем с таким проходом сталкиваться.
[03:56:37.740 --> 03:56:40.740]  То есть, это у нас будет одна из таких стандартных идей.
[03:56:40.740 --> 03:56:43.740]  Поэтому я это рассказал ее.
[03:56:43.740 --> 03:56:50.740]  Потому что, в принципе, как правильно было замечено, можно здесь второй метод решения этой задачи.
[03:56:50.740 --> 03:56:58.740]  Давайте построим дерево полиндромов для С, дерево полиндромов для Т и запустим параллельный ДФС.
[03:56:58.740 --> 03:57:05.740]  То есть, давайте для каждого дерево полиндромов С посчитаем, сколько раз он встречается, и посчитаем, сколько он в Т встречается.
[03:57:05.740 --> 03:57:12.740]  Остается только запустить параллельный ДФС и для каждого решим просто добавить к ответу произведение этого на это.
[03:57:12.740 --> 03:57:14.740]  Так тоже можно.
[03:57:14.740 --> 03:57:17.740]  Это более лобовое решение.
[03:57:17.740 --> 03:57:20.740]  Если мы дерево полиндромов строим один раз, давайте построим два.
[03:57:20.740 --> 03:57:24.740]  Согласен. В принципе, согласен.
[03:57:24.740 --> 03:57:26.740]  В принципе, можно сделать так, можно сделать эдак.
[03:57:26.740 --> 03:57:27.740]  В общем, и так, и так.
[03:57:27.740 --> 03:57:37.740]  То есть, честно говоря, в 2013 я вообще рассказал какое-то эпическое решение, которое использовала, как всегда, суффиксный массив ЛЦП.
[03:57:37.740 --> 03:57:39.740]  Сейчас, как ее там, Спарсы.
[03:57:39.740 --> 03:57:41.740]  Ну, вот эту стандартную технологию там всю.
[03:57:41.740 --> 03:57:43.740]  И что-то там еще на них.
[03:57:43.740 --> 03:57:45.740]  Потом выходит Рубинчик и рассказывает.
[03:57:45.740 --> 03:57:47.740]  Ну, вся там, да, на суффиксном дереве.
[03:57:47.740 --> 03:57:48.740]  Ну, не факт.
[03:57:48.740 --> 03:57:52.740]  Так вот, таких примеров у самого Рубинчика в диссертации на самом деле аж несколько.
[03:57:52.740 --> 03:57:56.740]  То есть, там была вот такая задача на какой-то там суперсложной олимпиаде.
[03:57:56.740 --> 03:57:58.740]  Там акцептов, дай бог, чтобы один.
[03:57:58.740 --> 03:58:00.740]  Подразумевалось вот такое решение.
[03:58:00.740 --> 03:58:04.740]  На самом деле, с деревом полиндромов эта задача становится легко приятной.
[03:58:04.740 --> 03:58:07.740]  Потому что, да.
[03:58:07.740 --> 03:58:08.740]  То есть, это очень забавно.
[03:58:08.740 --> 03:58:09.740]  Так что рекомендую.
[03:58:09.740 --> 03:58:10.740]  Кстати, кандидатская диссертация.
[03:58:10.740 --> 03:58:11.740]  Можете так в Гугле вбить.
[03:58:11.740 --> 03:58:12.740]  Кандидатская диссертация.
[03:58:12.740 --> 03:58:14.740]  Там Михаил Рубинчик, кандидатская диссертация.
[03:58:14.740 --> 03:58:16.740]  Ну, как бы.
[03:58:16.740 --> 03:58:21.740]  Ну, скажите так, половина решения, половина диссертации вот это.
[03:58:21.740 --> 03:58:23.740]  То есть, там еще она была чем-то добита.
[03:58:23.740 --> 03:58:26.740]  Тоже в общем-то там достаточно известна в олимпиадной среде чем-то.
[03:58:26.740 --> 03:58:29.740]  Но основа, конечно, дерево полиндромов.
[03:58:29.740 --> 03:58:31.740]  Так что вот такая красота.
[03:58:31.740 --> 03:58:36.740]  Так что актуальный алгоритм придуман получается в 2013 году.
[03:58:36.740 --> 03:58:37.740]  Так что вот.
[03:58:37.740 --> 03:58:40.740]  Ну, как обычно, оказывается, что мы все это знали.
[03:58:40.740 --> 03:58:43.740]  Не-не-не. Дерево полиндромов никто не знал.
[03:58:43.740 --> 03:58:46.740]  2013 год как бы.
[03:58:46.740 --> 03:58:48.740]  То есть, до этого никто от полиндромов так не шел.
[03:58:48.740 --> 03:58:52.740]  Структура данных, конечно, имеет крайне узкую область применения.
[03:58:52.740 --> 03:58:55.740]  Только когда мы говорим, ищем подстройки, являющиеся полиндромами.
[03:58:55.740 --> 03:58:56.740]  Как-то, да.
[03:58:56.740 --> 03:58:57.740]  Вот, конечно.
[03:58:57.740 --> 03:58:59.740]  Но, то есть, мы ее.
[03:58:59.740 --> 03:59:02.740]  То есть, у нас как бы смысл обсуждения ее.
[03:59:02.740 --> 03:59:04.740]  Кроме того, что она просто красивая зараза.
[03:59:04.740 --> 03:59:06.740]  В тем, что она нам прольет свет.
[03:59:06.740 --> 03:59:09.740]  На тем, что вот мы в следующий раз будем обсуждать алгоритмы Аха-Карасик.
[03:59:09.740 --> 03:59:10.740]  И, видимо, Уконен.
[03:59:10.740 --> 03:59:11.740]  Почему бы нет.
[03:59:11.740 --> 03:59:14.740]  И как бы в каждый из них, видимо, вот эти вот идеи.
[03:59:14.740 --> 03:59:17.740]  Как-то в том или ином виде будут прослеживаться.
[03:59:18.740 --> 03:59:20.740]  Ладно, на сегодня все.
