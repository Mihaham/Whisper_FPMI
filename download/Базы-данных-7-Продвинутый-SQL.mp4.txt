[00:00.000 --> 00:19.480]  Сегодня почти закончим с SQL и с его продвинутыми возможностями. Рассмотрим DCL, некоторые пункции,
[00:19.480 --> 00:24.440]  некоторые команды и варианты команд, которые мы еще не рассмотрели, которые позволяют делать
[00:24.440 --> 00:34.680]  более сложно интересные вещи с запросами из обработки данных. Поехали. DCL последнее четвертое
[00:34.680 --> 00:43.560]  подможество нашего глобального множества команд SQL позволяет соответственно нам контролировать
[00:43.560 --> 00:53.480]  данные путем предоставления доступов и разрешений на операции с ними. Для чего
[00:53.520 --> 01:00.600]  это вообще в принципе нужно? В первую очередь это обеспечение безопасности данных на уровне
[01:00.600 --> 01:09.560]  такой логики, что ли, функционирования базы за счет того, что мы можем определить роли,
[01:09.560 --> 01:17.960]  определить привилегии этих ролей, определить соответственно к каким объектам какие роли
[01:18.080 --> 01:24.640]  имеют доступ и какие действия над какими объектами они могут совершать. В Postgres
[01:24.640 --> 01:37.360]  по большому счету реализованы можно сказать полторы модели управления правами, но основная это
[01:37.360 --> 01:47.600]  role-based access control. Она реализована в полной мере и есть некоторые черты реализованы от
[01:47.600 --> 01:56.360]  контроля модели разграничения доступа на основе атрибутов объектов. Посмотрим подробнее, что такое
[01:56.360 --> 02:03.880]  role-based access model. Postgres использует концепцию ролей для управления разрешениями на доступ к
[02:03.880 --> 02:12.480]  базе данных. Есть еще понятие пользователей, то есть прям физически есть команды, связанные
[02:12.480 --> 02:23.680]  с предложением user, create user, alter user, grant, что-то там в пользу юзера. Здесь надо понимать,
[02:23.680 --> 02:30.680]  что на данный момент в Postgres команды, связанные с термином user, с термином role,
[02:30.680 --> 02:39.320]  они синонимичны, но сейчас правильный будет употреблять термин role в ваших командах.
[02:39.320 --> 02:46.000]  Role, соответственно, можно рассматривать как пользователя базы данных или как группу
[02:46.000 --> 02:50.640]  пользователей в зависимости от того, как роль настроена. То есть в рамках одной роли можно
[02:55.000 --> 03:00.080]  передавать привилегии и эту роль можно передавать не только конкретному человеку,
[03:00.120 --> 03:04.440]  можно передавать группе пользователей с одной стороны, а с другой стороны в рамках роли могут
[03:04.440 --> 03:21.840]  быть другие как бы суброли, которые имеют соответственно доступ к привилегиям своей
[03:21.840 --> 03:27.400]  материнской или групповой роли или не имеют. В зависимости от настроек все можно сделать на
[03:27.400 --> 03:37.280]  самом деле довольно гибко. Схематично можно изобразить следующим образом то,
[03:37.280 --> 03:44.480]  как существует модель разграничения доступом на основе ролей. То есть у нас есть некоторые
[03:44.480 --> 03:51.160]  основные абстракции, скажем так. Есть понятие объекта, понятие действия. То есть у нас есть
[03:51.160 --> 03:56.400]  какая-то группа объектов в базе данных, мы над ними можем совершать какие-то действия.
[03:56.400 --> 04:01.400]  Совместно это все называется привилегией, какие действия над какими объектами мы совершаем.
[04:01.400 --> 04:07.880]  И какие-то привилегии, какое-то их количество объединяются с понятием роли. И роль мы можем
[04:07.880 --> 04:16.840]  предоставить какому-то пользователю. Пользователю не в смысле предложения юзеру в SQL, а в смысле
[04:16.840 --> 04:25.200]  пользователю непосредственного базы данных. Основные абстракции. Здесь все то же самое,
[04:25.200 --> 04:34.040]  но чуть подробнее. То, о чем мы только что сказали. Единственный пользователь соответственно может
[04:34.040 --> 04:41.240]  получить некоторое количество ролей, не обязательно одно. Наверное это понятно по определению,
[04:41.240 --> 04:48.720]  по общим каким-то основным моментам. Основные объекты Postgresа перечислены на слайде. В первую
[04:48.720 --> 04:54.960]  очередь понятно, что это таблицы. Можно обратить внимание, обращаться к столбцам, можно обращаться
[04:54.960 --> 05:01.600]  к представлениям в юз, последовательностям. Это более продвинутые штуки, которые могут
[05:01.600 --> 05:12.080]  генерировать последовательности величин, последовательности данных. Можно непосредственно
[05:12.080 --> 05:18.360]  базу данных считать объектом, функции, хранимые процедуры, схемы и табличное пространство. Все это
[05:18.360 --> 05:26.400]  может быть объектом. И не только это, скажем так. С теми, с которыми вы сталкивались уже или еще
[05:26.400 --> 05:31.960]  столкнетесь в рамках курса, это пожалуй основные и даже с некоторым запасом. Соответственно в
[05:31.960 --> 05:37.760]  отношении всех этих объектов можно гарантировать, можно предоставить какую-то привилегию. Все это
[05:37.760 --> 05:47.160]  обозначено в качестве какой-то роли. Основной синтаксис. Несмотря на то, что у нас основные
[05:47.160 --> 05:51.440]  команды на наших слайдах были перечислены на протяжении курса, мы перечисляли всего два,
[05:51.440 --> 06:00.840]  две, да, grant, revoke. В данном случае create role это не самостоятельная команда получается,
[06:00.840 --> 06:09.520]  а такая производная от create, от команды create и указанием на определенный объект, который создается
[06:09.520 --> 06:16.240]  в данном случае роль. Поэтому можно как бы договорить, что это тоже часть синтакса с DCL,
[06:16.240 --> 06:23.280]  create role команда. Можно это не говорить как, можно об этом не говорить, специально не упоминать,
[06:23.280 --> 06:33.200]  поскольку это не специфический DCL команда. На всякий случай я говорю в тестах, т.е. в следующем
[06:33.200 --> 06:39.240]  просто не будет такого вопроса, будет ли create role в синтаксе DCL или нет, чтобы не путаться. Так что
[06:39.240 --> 06:44.920]  на это счет не переживайте. Но тем не менее мы можем создать роль. Общий синтаксис он приведен
[06:44.920 --> 06:51.680]  на экране, там довольно все просто, и приведен пример того, как создается роль с некоторым
[06:51.680 --> 07:00.160]  атрибутом, в данном случае пароль. В стандарте, ну и помимо стандартов документации SQA,
[07:00.160 --> 07:06.760]  поздно, прошу прощения, перечисляется большое количество атрибутов, ну, вернее сказать,
[07:06.760 --> 07:12.960]  параметров, если говорить терминологией словного синтакса. Большое количество параметров,
[07:12.960 --> 07:22.080]  которые можно использовать при создании роли. Можно назначать роль в качестве адмида,
[07:22.080 --> 07:29.760]  можно разрешать роли логиница в сеанс, ну, там довольно большой перечень, можете посмотреть,
[07:29.760 --> 07:35.480]  в принципе, там ничего сложного нету. А параметр роли определяет ее полномочий взаимодействия
[07:35.480 --> 07:40.640]  системы аутентификации клиентов, да, и для изменения атрибутов роли, соответственно, ну,
[07:40.640 --> 07:47.120]  по аналогии с тем, что мы уже видели для, в частности, таблиц, применяются команды alter, drop,
[07:47.120 --> 07:54.400]  точно так же, совершенно. Здесь никакой специфики нет, и, опять же, повторюсь,
[07:54.400 --> 08:01.200]  команда create user теперь является просто синонимом create role, ну, теперь с версии 8.1 поздроса,
[08:01.200 --> 08:10.160]  то есть почти ровно половину версии назад произошло такое слияние. Ну, маленькое историческое
[08:10.160 --> 08:22.640]  примарка. Что касается непосредственно команд grant revoke. Вот, по команде grant позволяет нам,
[08:22.640 --> 08:28.760]  во-первых, ее синтаксис тоже приведен на слайде, во-вторых, она нам позволяет, повторюсь, предоставить
[08:28.760 --> 08:40.040]  какие-то дополнительные привилегии в отношении каких-то объектов или действий для уже создания
[08:40.280 --> 08:47.760]  ролей, и команда revoke соответственно делает обратное, позволяет эти привилегии забирать.
[08:47.760 --> 08:53.200]  Команда grant имеет две основные разновидности, это назначение прав доступа к объектам и
[08:53.200 --> 09:02.600]  назначение роли одних ролей членами других ролей. Ну, вот, да, здесь на слайде с синтаксисом указано,
[09:02.600 --> 09:12.600]  что первая часть она видно, что относится к объектам, вторая после предложения to позволяет
[09:12.600 --> 09:21.680]  указать роль, да, и позволяет соответственно указать там дальше, то есть, какой роли,
[09:21.680 --> 09:27.320]  и granted by указание роли позволяет указать, к какой группе ролей можно отнести текущую роль.
[09:27.320 --> 09:40.680]  Примеры grant insert on films to public соответственно позволяет нам для роли паблик, это паблик
[09:40.680 --> 09:56.280]  ключевое слово в данном случае обозначает роль такого общего доступа. Мы для пользователя по
[09:56.280 --> 10:05.920]  умолчанию предоставляем ему возможность вставлять в таблицу фильма какие-то данные. Второй
[10:05.920 --> 10:16.560]  пример позволяет все возможные привилегии для некой таблицы kinds предоставить пользователю
[10:16.560 --> 10:25.360]  мануэль и последний пример соответственно позволяет у нас в роли админ включить пользователь
[10:25.360 --> 10:32.440]  джо револк соответственно да как уже было сказано это обратная команда то есть здесь синтаксис
[10:32.440 --> 10:38.480]  похожий в плане того что мы тоже должны указать либо что мы забираем какие привилегии в отношении
[10:38.480 --> 10:48.080]  каких объектов или или какие действия запрещаем совершать и указать должны также роль и можем
[10:48.080 --> 10:59.680]  указать соответственно из какой группы роли какая роль исключается мы можем также показать
[10:59.680 --> 11:07.600]  да option grant option for соответственно мы можем отозвать право передачи текущей привилегии
[11:07.600 --> 11:14.000]  от какого-то пользователя но не само эту привилегию и если мы данные указываем
[11:14.000 --> 11:24.880]  специфик не специфицируем нашу команду grant то да у правой распоряжение им
[11:27.240 --> 11:35.800]  отзывается по умолчанию совместно примеры ну соответственно тоже довольно простые здесь делаем
[11:35.800 --> 11:41.040]  все то же самое что предыдущем слайде но в обратном порядке на позапрошлом вернее забираем
[11:41.040 --> 11:50.400]  у роли паблик возможность вставлять данные в таблицу фильмов забираем все привилегии у роли
[11:50.400 --> 12:00.120]  мануэль из таблицы кайнс и из группы админов исключаем роль джо из роли админов групповой
[12:00.120 --> 12:07.640]  роли так вот получается исключаем роль джо так ну хорошо давайте пойдем дальше более продвинутые
[12:07.640 --> 12:20.120]  функции SQL значит рассмотрим для начала общие табличные выражения по большому счету общие
[12:20.120 --> 12:27.080]  табличные выражения мы с вами их практически умеем писать и ничего в этом сложного нет ну
[12:27.080 --> 12:32.040]  для некоторых в принципе уже наверное это понятно потому что кто-то может быть успел
[12:32.040 --> 12:38.760]  на семинарах пройти а по сути делает те же самые подзапросы о которых мы с вами говорили несколько
[12:38.760 --> 12:49.200]  лекций назад только синтоксически выраженные более простой форме и ну правда имеющие определенные
[12:49.200 --> 12:58.200]  нюансы с точки зрения выполнения ну во-первых что можно сказать по выполнению это то что у нас
[12:58.200 --> 13:07.880]  по в общем случае у нас общие табличные выражения выполняются всегда единожды и перед основным
[13:07.880 --> 13:20.960]  запросом то есть случаев когда как с выполнением связанных под запросов мы могли попасть в ситуацию
[13:20.960 --> 13:29.040]  возрастание там до сложности выполнения квадратичной и более потому что у нас по сути
[13:29.040 --> 13:34.960]  получался вложенный цикл с общими табличными выражениями такое поведение по умолчанию
[13:34.960 --> 13:45.520]  недопустимо они выполняются повторюсь единожды также у нас получается дали можно разделить
[13:45.520 --> 13:55.280]  условно операторы которые совершаются внутри общего табличного выражения сети и и которые
[13:55.280 --> 14:04.840]  совершаются после соответственно внутри сети у нас могут быть select insert update или delete а
[14:04.840 --> 14:12.480]  после ну тоже select insert update или delete или merge в принципе здесь все тоже довольно тривиально
[14:12.480 --> 14:21.320]  что еще нужно сказать что сначала ну да у нас все внутри в wi-fi выполняется только потом выполняется
[14:21.320 --> 14:33.240]  приложение from как уже было сказано и в соответствии со стандартом запросу содержащие сети должны
[14:33.240 --> 14:41.880]  выполняться как если бы каждой сети было вычислено один раз это относится к тому что у нас внутри
[14:41.880 --> 14:49.760]  common table expression может быть еще какие-то вложенные выражения здесь сложности у нас не ограничено
[14:49.760 --> 14:57.120]  по умолчанию и тем не менее все равно это все будет выполняться единожды перед основным запросом то
[14:57.120 --> 15:05.200]  есть да вот здесь на слайде уже на синтаксе все более понятно что вы recursive запрос вы и какие-то
[15:05.200 --> 15:10.520]  какой-то определение запроса потом это все соответственно common table expression потом идет
[15:10.520 --> 15:18.440]  основной select у нас вот все что перед select у нас выполняется перед select буквально то есть
[15:18.440 --> 15:24.440]  порядок выполнения запроса у нас здесь дополняется как вы помните у нас начинается с from потом
[15:24.440 --> 15:38.720]  where потом ну и потом так далее там from where идет из основного селекта а в случае наличия общего
[15:38.720 --> 15:44.200]  табличного выражения перед from из основного селека запрос у нас будет выполняться сначала тем не менее
[15:44.200 --> 15:49.160]  common table expression если там у нас будет свой селект запрос соответственно он будет у нас идти по
[15:49.160 --> 15:57.560]  общим правилам селекта начиная со своего запроса from и так далее по порядку выполнения запроса
[15:57.560 --> 16:11.640]  что такой запрос в определение да это имя запросу и дальше имя столбца можно его опустить если у
[16:11.640 --> 16:20.320]  нас не рекурсивный запрос и далее мы можем соответственно делать либо выбор путем селекта
[16:20.320 --> 16:27.880]  либо да как говорилось использовать иные операторы оператор values кстати у нас позволяет возможность
[16:27.880 --> 16:38.480]  сделать просто-напросто таблицу из неких константных величин values давайте наверное здесь
[16:38.480 --> 16:43.680]  разоговоримся это нам будет для рекурсии полезно для понимания то есть values мы отдельно его
[16:43.680 --> 16:49.160]  не рассматривали в рамках курса до сих пор но если вы обратитесь к документации того же
[16:49.160 --> 16:57.680]  позгресса то увидите что values в списке команд выделено отдельно и по сути дела результат выполнения
[16:57.680 --> 17:06.600]  команды values как таковой самой по себе что называется это возврат таблицы с тем количеством
[17:06.600 --> 17:16.200]  значений которые у нас values внутри скобок определено при этом все значения будут в
[17:16.200 --> 17:24.520]  одной строке вот этой вот итоговой таблицы и мы можем там объединяя несколько запросов
[17:24.520 --> 17:32.880]  values подряд за счет команды union ну вот так вот искусственно создавать по сути дела
[17:32.880 --> 17:44.200]  таблицу из констант в ходе там выполнения запроса для чего это нужно ну
[17:44.200 --> 17:55.160]  как бы бывают случаи скажем так но в общем виде конечно так делать не надо если у вас есть
[17:55.160 --> 18:06.280]  какой набор константных величин просто запишите их как констант внутри запроса и не надо делать
[18:06.280 --> 18:15.800]  дополнительных команд с запросом команды values для создания дополнительных лишних таблиц ну
[18:15.800 --> 18:25.240]  окей сейчас дойдем до рекурсии будет чуть более понятно все это означает а пример сети и да
[18:25.240 --> 18:33.160]  соответственно что здесь мы делаем ну вот у нас основной селек запрос в общем все понятно наш
[18:33.160 --> 18:41.840]  типичный селек запрос с группировкой с выборкой по мне даже с под запросом кстати говоря он с
[18:41.840 --> 18:52.360]  выборкой по вхождению регионов некоторое множество регионов топовых при этом обратите
[18:52.360 --> 19:03.280]  внимание у нас вот этот вот предварительный запрос сети даже два их во первых мы можем
[19:03.280 --> 19:10.160]  их через запятую после единственного оператора вы после единственной команды через запятую мы
[19:10.160 --> 19:21.680]  их можем перечислять псевдонимы мы им назначили да и получается один сети у нас пошел в под
[19:21.680 --> 19:32.760]  запрос основу запроса селек другой сети у нас оказался в качестве качестве еще в качестве
[19:32.760 --> 19:41.640]  таблицы да и с которой также у нас под запрос вытаскивает данные уже во втором сети то есть
[19:41.640 --> 19:47.640]  первой сети regional sales у нас появляется во втором сети топ рэд джонс вот рэд джонс сам
[19:47.640 --> 19:53.720]  топ рэд джонс появляется у нас в под запросе основного запроса никаких проблем с этим нет
[19:53.720 --> 20:01.800]  пожалуйста группируйте так вы используете под запрос прошу прощения общие табличные выражения
[20:02.120 --> 20:07.560]  везде где уместно использовать ссылаться на таблицу потому что до результат выполнения сети
[20:07.560 --> 20:15.800]  это у нас некое результирующее отношение некое результирующее виртуальная таблица и вот в данном
[20:15.800 --> 20:25.600]  случае у нас выдаются выдаются итоги по продажам только для передовых регионов предложение да у
[20:26.200 --> 20:35.280]  два дополнительных оператора об их использовании мы уже с вами сказали что один используется в
[20:35.280 --> 20:44.320]  другом второй используется в основном селек запросе в качестве внутри даже под запроса можно
[20:44.320 --> 20:50.280]  было бы переписать без вы как справедливо сказано на слайде но тогда у нас вот в под запросах было
[20:50.280 --> 20:54.920]  бы но в частности вот в этом под запрос основного запроса просто было бы несколько уровней
[20:54.920 --> 21:03.160]  вложения селектов несколько вложенных селектов что конечно бы на мой взгляд и на взгляд многих
[21:03.160 --> 21:13.560]  сильно бы ухудшила читаемость того что мы с вами здесь видим окей давайте рассмотрим рекурсию
[21:13.560 --> 21:27.480]  рекурсия это по сути дела специальный вид common table expressions и на самом деле хотя это все
[21:27.480 --> 21:32.520]  называют рекурсии это в стандарте называется рекурсии документации того же постгресса
[21:32.520 --> 21:41.600]  называется рекурсии это не рекурсия это итерация и по большому счету вот исследователями баз
[21:41.600 --> 21:50.360]  данных 80 90-х годах были было доказано что мы нашим декларативным сql описать рекурсивный
[21:50.360 --> 21:59.240]  запрос не сможем не длежащим образом синтаксис практически не меняется за исключением
[21:59.240 --> 22:04.960]  обязательного включения в него дополнительного ключевого слова ключевого предложения recursive
[22:04.960 --> 22:11.840]  соответственно используя recursive мы даем команду нашей суббд чтобы хотим сделать наш запрос
[22:11.840 --> 22:18.720]  рекурсивным что значит в данном случае рекурсивность это означает то что он под
[22:18.720 --> 22:25.920]  запрос как бы прошу прощения common table expression конечно не под запрос что в наш под наш сети как
[22:25.920 --> 22:31.280]  бы обращается к собственному результату как бы ну как бы вернее не как бы он бы обращается
[22:31.480 --> 22:35.520]  к собственному результату ну и мы понимаем что обращение к собственному результату это как бы
[22:35.520 --> 22:41.080]  обращение к самому себе но на самом деле нет мы просто используя промежуточные схемы для хранения
[22:41.080 --> 22:52.880]  промежуточное отношение промежуточные виртуальные таблица для хранения результата выполнение каждой
[22:52.880 --> 23:02.240]  в итоге получаем такой же результат, как если бы мы действительно использовали рекурсию,
[23:02.240 --> 23:11.280]  то есть вызывали бы наш запрос изнутри него самого повторно, столько сколько там предполагается по
[23:11.280 --> 23:20.640]  условиям, собственно, запросом. Для чего вообще нужны рекурсивные запросы? Для того чтобы в первую
[23:20.640 --> 23:30.880]  очередь извлекать данные, имеющие по сути своей иерархическую структуру, но которые тем не менее
[23:30.880 --> 23:38.840]  хранятся в таком, условно говоря, плоском виде, в виде наших отношений релиционных, в виде таблиц,
[23:38.840 --> 23:53.560]  по сути дела. Причем таблиц не как мы храним графы в табличном представлении, а в несколько
[23:53.560 --> 23:59.920]  ином виде сейчас посмотрим как именно. Но давайте посмотрим сначала на примитивный пример рекурсии,
[23:59.920 --> 24:08.280]  вот это прям не буду даже приписывать себе лишних заслуг, вот это вот просто цитата из документации
[24:08.280 --> 24:17.360]  Позгресса, здесь такой пример предлагается рассмотреть. Что здесь происходит? Здесь происходит на самом
[24:17.360 --> 24:31.040]  деле очень простая штука, здесь суммируется числа от 1 до 100. И вот итоговый селект наш основной
[24:31.040 --> 24:39.680]  выведет соответственно нам там ну больше 5000 в сумме результат. Причем выведет он нам в виде
[24:39.680 --> 24:47.080]  одного скалярного значения, хотя на самом деле вот здесь вот у нас будет появляться довольно
[24:47.080 --> 24:51.840]  большая таблица, которая в итоге на самом деле вот здесь вот схлопнется. Давайте попробуем
[24:51.840 --> 24:58.240]  разобраться, что происходит по этапам. Во-первых, из чего состоит рекурсивный запрос в данном случае.
[24:58.240 --> 25:06.280]  Вот у нас есть несколько его частей, вот эта вот верхняя рамочка красная,
[25:06.280 --> 25:15.920]  в которую заключено обращение к некой таблице, по сути не таблице, прошу прощения, к некой
[25:15.920 --> 25:28.600]  переменной в данном случае. То есть мы помним, что по, так немножко далеко, то запрос WIF у нас
[25:28.600 --> 25:33.840]  начинается с имени запроса. И вот в примере мы с вами видели, что это просто-напросто после
[25:33.840 --> 25:39.680]  WIF идет имя запроса, которое мы произвольно назначаем САБИ. В данном случае мы произвольно
[25:39.680 --> 25:48.240]  назначили некое имя запроса и указали днем на столбец, тоже в данном случае произвольный.
[25:48.240 --> 25:57.760]  И это важно, потому что у нас столбцы должны, их количество должно соответствовать внутри нашего
[25:57.760 --> 26:02.880]  рекурсивного запроса. Должно соответствовать тому количеству столбцов, которые мы определили вот
[26:02.880 --> 26:10.760]  в этой такой переменной нашей, условно говоря, которую мы используем для рекурсии. Нерекурсивная
[26:10.760 --> 26:18.320]  часть. По сути дела это все, что идет после скобки и до команды union или union all. В данном случае
[26:18.320 --> 26:25.560]  union all. Вы помните union all у нас сохраняет все повторяющиеся строки. По сути дела,
[26:25.560 --> 26:33.800]  присоединяя каждую новую строку к уже имеющимся. А просто union у нас тогда бы что сделал,
[26:33.800 --> 26:42.840]  у нас бы он исключал строки повторяющиеся, ну затирал по сути дела. И после команды union
[26:42.840 --> 26:47.840]  или union all у нас идет собственно рекурсивная часть. И в данном случае что у нас происходит? У
[26:47.840 --> 26:54.080]  нас селект запрос, ну во-первых value, давайте все-таки с ней рекурсивной части. Value 1, как мы с вами
[26:54.080 --> 27:01.320]  чуть раньше сказали, команда values у нас вернет строку таблицы. В данном случае у нас по сути
[27:01.320 --> 27:07.440]  дела вернет скалярное значение. Будет у нас не строка, а единственная таблица из единственной
[27:07.440 --> 27:12.760]  ячейки, в которую у нас будет значение единичка. Вот что у нас здесь делает нерекурсивная часть.
[27:12.760 --> 27:22.120]  Что у нас делает рекурсивная часть? Она обращаясь к столбцу n добавляет в него единичку из таблицы
[27:22.480 --> 27:31.200]  до тех пор пока у нас значение n не будет равно сотне. Казалось бы окей, почему это все у нас будет
[27:31.200 --> 27:40.560]  работать больше чем один раз? Собственно говоря, вот почему. Потому что порядок выполнения рекурсивного
[27:40.560 --> 27:47.880]  запроса, то есть порядок выполнения CTE с вот этим ключевым словом recursive, у нас изменяется,
[27:47.880 --> 27:55.120]  у нас появляются промежуточные этапы хранения наших промежуточных, собственно говоря, результатов.
[28:01.120 --> 28:08.400]  Какой порядок? Да, здесь циферка 2 должна быть. Какой порядок? Вычисляется нерекурсивная часть.
[28:08.400 --> 28:13.920]  Для union отбрасываются дублирующие сроки, все оставшиеся сроки включаются в результат
[28:13.920 --> 28:18.440]  рекурсивного запроса и также помещаются во временную рабочую таблицу.
[28:25.280 --> 28:33.520]  При этом важно также понимать, что у нас вот грубо говоря, очень грубо говоря, двойные,
[28:33.520 --> 28:41.720]  тройные и так далее кавычки, вот мы вот это обращение, вот это обозначение t в скобках n,
[28:41.720 --> 28:49.840]  n как некий столбец, как некая колонка, мы это можем рассматривать как своего рода переменную и у
[28:49.840 --> 28:58.560]  нас количество вот этих вот переменных столбцов должно совпадать с тем, что у нас получится в
[28:58.560 --> 29:03.040]  нерекурсивной части количеством столбцов и в рекурсивной части, то есть если бы у нас здесь
[29:03.040 --> 29:12.800]  было n1, n2, n3, у нас бы здесь values должно было быть 1, 2, 3 и так далее по количеству столбцов
[29:12.800 --> 29:22.320]  в нашем имени CTE и вот здесь вот в рекурсивной части также у нас select запрос должен был бы
[29:22.320 --> 29:29.400]  выдавать количество столбцов, равное количеству столбцов в имени нашего общего табличного
[29:29.400 --> 29:37.240]  выражения рекурсивного. Далее у нас помещается во временную рабочую таблицу наша нерекурсивная
[29:37.240 --> 29:46.320]  часть и пока рабочая таблица не пустая повторяются следующие действия. Вычисляется рекурсивная
[29:46.320 --> 29:55.000]  часть, так что рекурсивная ссылка на сам запрос обращается к текучему содержимому рабочей
[29:55.000 --> 30:06.200]  таблицы, происходит в принципе то же самое у нас вычисляется, добавляется все это в некую таблицу,
[30:06.200 --> 30:11.560]  но уже промежуточную и далее содержимое рабочей таблицы заменяется содержимым промежуточной
[30:11.560 --> 30:23.120]  таблицы, а затем промежуточная таблица очищается. То есть пока у нас не окажется результатом вот этого
[30:23.240 --> 30:32.520]  запроса пустая таблица, то мы не остановимся в выполнении и остановка произойдет соответственно
[30:32.520 --> 30:42.120]  по условию в данном случае, что n меньше 100. Как это все еще можно понять, ну как бы более что-ли
[30:42.120 --> 30:47.720]  на пальцах для себя? Можно попробовать вот что сделать, попробовать разложить вот этот вот запрос
[30:47.720 --> 30:56.080]  рекурсивный на нерекурсивные части, попробовать его переписать. Тогда у нас вот это values 1 должно
[30:56.080 --> 31:06.560]  стать create table n к table t, прошу прощения, с колонкой n и мы туда добавляем значение единичка. И вот
[31:06.560 --> 31:12.960]  мы в отличие от рекурсивного запроса у нас здесь появляется виртуальная таблица, не существующая
[31:12.960 --> 31:20.840]  в базе нашей, которая условно называется рабочая. Здесь мы ее прямо-прямо создаем, если мы пытаемся
[31:20.840 --> 31:30.480]  вот разложить для себя, воспроизвести рекурсивный запрос нерекурсивно. А рекурсивную часть
[31:30.480 --> 31:39.560]  рекурсивного запроса мы повторяем вот следующим образом. Select n from t и union all select n plus 1
[31:39.560 --> 31:46.960]  from t or n меньше 100. Единственно что? Единственно что? Вот эта часть вот в этой рабочке, она выполнится
[31:46.960 --> 31:55.160]  конечно единожды. Для полного тождества нам пришлось вот это вот все заключать в функцию или в процедуру и
[31:55.160 --> 32:04.880]  функции или в процедуре нам проверять условия и итерировать вот это вот, вот этот вот select запрос
[32:04.880 --> 32:13.120]  столько сколько потребуется. Дополнительно еще и его результаты добавляя в нашу вот исходную
[32:13.120 --> 32:23.040]  таблицу t, которую мы прямо физически создали. Вот в принципе наверное и все что что нужно
[32:23.040 --> 32:29.680]  попытаться понять о рекурсивном запросе вот на таком базовом уровне. Для простоты я вам предлагаю
[32:29.680 --> 32:37.200]  просто руками попробовать поиграться с рекурсией, с простыми какими-то элементарными запросами,
[32:37.200 --> 32:42.040]  взять тот же вот этот вот запрос по вычислению первых ста, по вычислению суммы первых ста
[32:42.040 --> 32:51.520]  натуральных целых чисел и посмотреть да вот что будет если там поменять один параметр,
[32:51.520 --> 32:57.440]  поменять другой, поменять количество колонок, поменять вместо суммы поставить например просто
[32:57.440 --> 33:05.760]  в основном селегозапросе поставить просто выборку всего что получится в рекурсии и так далее. Но в
[33:05.760 --> 33:13.120]  целом да надо просто понимать что у нас каждый раз к вот этой нашей первой ну в данном случае первой
[33:13.120 --> 33:21.800]  строке добавляется новая строка и когда у нас но сначала у нас появляется две сначала у нас
[33:21.920 --> 33:26.680]  появляется строка с единичкой здесь у нас появляется тоже одна строка но с двойкой она
[33:26.680 --> 33:39.020]  добавляется вот сюда далее мы прибавляем здесь единичку и у нас появляются строки 2 3
[33:39.020 --> 33:43.660]  мы их опять добавляем вот сюда потом у нас появ tasted все сразу на 2 строки 1 2 3 мы добавляем
[33:43.660 --> 33:50.700]  единичку появляется строки 2 3 4 мы добавляем опять в исходную нашу в التي но в рабочую
[33:50.700 --> 33:55.460]  нашу таблицу, появляются строки 1, 2, 3, 4 и так далее до тех пор, пока мы не дойдем до 100, а
[33:55.460 --> 34:03.980]  потом у нас все склопывается в основном селекозапросе с помощью агрегирующей функции сам и выводится
[34:03.980 --> 34:12.980]  просто скалярный результат сложения всех первых 100 чисел. Результат 550, можете там проверить,
[34:12.980 --> 34:22.900]  запустить запрос, проверить результат, посмотреть. Если мы как раз, как я и говорил, уберем из-за
[34:22.900 --> 34:32.500]  внешнего селекозапроса функцию суммирования, то из основного селекозапроса у нас получится
[34:32.500 --> 34:45.460]  просто набор наших данных до сотни, причем, что интересно, да, почему у нас здесь 100 будет,
[34:45.460 --> 34:56.460]  потому что вот здесь вот, когда мы будем выбирать в последний раз из нашей рабочей таблицы все
[34:56.460 --> 35:07.140]  значения и прибавлять к ним единичку, у нас условия n меньше 100 еще не сработает. У нас сработает
[35:07.140 --> 35:14.140]  условие, у нас выберется все значения до 99, мы к ним прибавим единичку, у нас появится 100, то есть
[35:14.140 --> 35:21.140]  вот этот селект работает корректно и мы вот то, что получилось в нашей рабочей таблице, вернее в
[35:21.140 --> 35:27.980]  промежуточной таблице, да, с единички по 100, по сотню мы соединим команды union all с нашей рабочей
[35:27.980 --> 35:37.340]  таблицей и уже на следующем шаге у нас с рекурсию закончится, потому что мы как раз n равно 100 найдем
[35:37.340 --> 35:45.740]  на, найдем на нашей рабочей таблице. Поэтому здесь, ну, здесь корректный, это корректный результат,
[35:45.740 --> 35:55.220]  он получится в том числе и у вас и здесь не надо этого как бы страшиться, да, это не баг,
[35:55.220 --> 36:03.780]  это фича, это особенности обработки рекурсии, потому что здесь мы, соответственно, на этапе 99,
[36:03.780 --> 36:11.580]  когда мы выберем все значения до 99, а потом прибавим единичку, мы получим сотню, поэтому все
[36:11.580 --> 36:19.660]  корректно. Ну, это примерно как в цикле while условия у нас идет проверка условия
[36:19.660 --> 36:28.340]  после совершения операции. Вернее, прошу прощения, перед совершением операции, конечно же.
[36:28.340 --> 36:36.620]  Давайте посмотрим на более сложный пример. Вот у нас есть таблица parts, мы хотим посчитать,
[36:36.620 --> 36:42.660]  сколько деталей нам нужно для нашего продукта, our product, то есть our product это некий агрегированный
[36:42.660 --> 36:52.180]  продукт, состоящий из некоторого количества деталей, а у него есть соответственно, да, части
[36:52.180 --> 36:59.700]  и субчасти, то есть вот это вот все, если вы обратите внимание, будет построено в виде графа,
[36:59.700 --> 37:08.500]  вершинами, в виде дерева даже, и на верхушке дерева верхним самым узлом будет our product,
[37:08.500 --> 37:16.980]  от него будут отходить соответственно, четыре дуги к вершинам bolt, четыре дуги к вершинам nap,
[37:16.980 --> 37:24.460]  четыре дуги к вершинам washer, и уже от bolt, screw и washer будут отходить, ну, в данном случае от bolt,
[37:24.460 --> 37:33.060]  конечно же, и от washer тоже, прошу прощения, и от вершин bolt и washer будут отходить еще дуги к screw,
[37:33.060 --> 37:37.700]  от screw будет отходить дуга к metal, от washer будет отходить дуга к rubber, ну, соответственно,
[37:37.700 --> 37:50.860]  вот такое вот у нас дерево получается, раз, два, три, четыре, четырех, четырехуровневые максимально
[37:50.860 --> 37:56.100]  глубину, и мы хотим, соответственно, посчитать, сколько деталей нам нужно для каждого нашего
[37:56.100 --> 38:02.620]  продукта, вот этого конечного our product, и наш ожидаемый результат вот такой вот, то есть мы
[38:02.620 --> 38:13.380]  считаем количество дуг, по сути дела, в этом графе, вот our product, четыре болта нам нужно,
[38:13.380 --> 38:24.060]  в четырех болтах по два винта, ну, так условно, давайте тогда на английском, четыре bolt нам нужно
[38:24.060 --> 38:30.180]  для our product, два screw нужно для каждого болта, и по одному metal нужно для каждого screw,
[38:30.180 --> 38:37.500]  соответственно, один на два на четыре получается восемь, восемь частей metal нам нужно, правильно?
[38:37.500 --> 38:45.900]  правильно, metal восемь, и как нам этого добиться? вот таким вот интересным запросом, обратите
[38:45.900 --> 38:56.180]  внимание, как мы с вами и говорили, перечисляемые в имени нашего рекурсивного CTE столбцы, они все
[38:56.180 --> 39:02.660]  должны у нас фигурировать и в нерекурсивной части, и вот они у нас все фигурируют, и в нашей
[39:02.660 --> 39:12.660]  рекурсивной части, и вот они у нас тоже все фигурируют, и соответственно,
[39:12.660 --> 39:21.460]  да, да, все правильно, и соответственно, что мы с вами делаем? здесь выбираем в рабочую нашу таблицу
[39:21.460 --> 39:36.260]  part-part-quantity из таблиц частей наших, где у нас часть является главным продуктом,
[39:36.260 --> 39:51.260]  где выбираем все части для главного продукта, и дальше мы из таблиц частей и также из
[39:51.260 --> 40:03.340]  самого нашего этого рекурсивного запроса начинаем выбирать все части, при этом мы количество
[40:03.340 --> 40:10.020]  из таблиц частей умножаем на количество из нашего рекурсивного запроса, выбираем все части по
[40:10.020 --> 40:21.180]  условию, где часть равна своей запчасти, ну понятно, да, то есть мы по сути дела вот таким образом по узлам
[40:21.180 --> 40:30.940]  дерева нашего спускаемся вниз до тех пор, пока у нас не нарушатся условия рекурсии, ну в данном
[40:30.940 --> 40:41.740]  случае пока у нас не будет несоответствия между частью и запчастью, далее мы ну все это понятно
[40:41.740 --> 40:48.060]  складываем там где нужно и группируем складываем и получаем нашу результативающую таблицу вот как
[40:48.060 --> 40:57.500]  в ответе, опять же ну здесь просто рекомендую руками, что называется, попробовать этот запрос
[40:57.500 --> 41:06.260]  по задавать базе, по обращаться к базе с ним, может быть попробовать убрать грубая, чтобы посмотреть
[41:06.260 --> 41:13.100]  как у нас и сам quantity например тоже, чтобы посмотреть как вообще у нас сам рекурсивный
[41:13.100 --> 41:22.340]  запрос отработает в таком первом приближении без какой-то агрегации и обработки его данных в
[41:22.340 --> 41:32.620]  основном запросе, но еще раз наверное важно понимать пожалуй самое главное это то, что у нас количество
[41:32.620 --> 41:40.740]  этих наших условно говоря переменных, а по сути дела название столцов должно везде у нас совпадать,
[41:40.740 --> 41:48.140]  если у нас не будет совпадения, это будет проблема для запроса, у нас он упадет с ошибкой и по сути
[41:48.140 --> 41:54.860]  дела вот здесь у нас union all, вот все чтобы здесь делаем union или у нас будет union all,
[41:54.860 --> 41:59.220]  но это уже там как бы частности, по сути дела вот результат рекурсивного запроса это большая
[41:59.220 --> 42:04.100]  большая таблица, где у нас там могут быть какие много повторяющихся данных, которые мы можем
[42:04.100 --> 42:11.300]  сгруппировать по столбцам и так далее, то есть вот здесь у нас всегда не вот это вот, не вот
[42:11.300 --> 42:20.420]  этот приличного вида результат, из семи строк, шести строк сущностных или вот как здесь результат
[42:20.420 --> 42:28.220]  из скаляра, результат рекурсивного запроса это большая массивная таблица, где там будет много
[42:28.220 --> 42:36.140]  всякой разной информации жидучей своего часа, чтобы быть агрегированной и обработанной как-то
[42:36.140 --> 42:45.200]  более рационально, но еще раз повторюсь, что просто вот для понимания здесь нужно поработать с этим
[42:45.200 --> 42:52.940]  руками и просто покрутить какие-то рекурсивные запросы, поизменять их параметры, примеры
[42:52.940 --> 43:00.140]  рекурсивных запросов вы можете еще найти в документации позгресса и то еще важно отметить,
[43:00.300 --> 43:10.380]  что вот таким образом с помощью рекурсии конечно мы обрабатываем в первую очередь какие-то
[43:10.380 --> 43:19.860]  иерархические данные, данные подразумевающие иерархическую структуру внутри себя, это конечно
[43:19.860 --> 43:26.900]  не те данные, которые бы хотелось хранить в нашей революционной базе, но за неимением лучшего,
[43:27.220 --> 43:35.780]  за неимением возможности в рамках, оставаясь революционного подхода, описать граф как-то
[43:35.780 --> 43:45.300]  более эффективным, приходится делать обход графа таким образом, по сути дела, граф хранимого вот так.
[43:45.300 --> 43:53.900]  Так, опять же, это не таблица смежности, повторюсь, это совершенно другая конструкция,
[43:54.300 --> 44:02.980]  которая из теории алгоритмов, алгоритмов о графах не следует, ей вообще не соответствует.
[44:02.980 --> 44:12.660]  Окей, двигаемся дальше. У нас на очереди представление. Что это такое? Представление,
[44:12.660 --> 44:19.260]  в принципе довольно простая вещь, это виртуальные таблицы, которые представляют собой результаты
[44:19.260 --> 44:26.980]  выполнения некоторых SQL запросов. Важно понимать, что представление, в отличие от того, о чем мы
[44:26.980 --> 44:34.500]  с вами говорили ранее, это не реальная таблица, это просто определение, по сути дела, запроса.
[44:34.500 --> 44:47.340]  Представление внутри себя всего лишь сохраняет SQL запрос, назначает ему некий псевдоним,
[44:47.340 --> 44:55.500]  по сути дела, и предоставляет возможность обращаться к нему как к таблице. Соответственно,
[44:55.500 --> 45:00.700]  у нас представление наше, будучи по сути дела еще не исполненным запросом, может быть,
[45:00.700 --> 45:11.220]  тем не менее, может фигурировать в любых местах наших реальных SQL запросов, где требуются таблицы
[45:11.220 --> 45:18.500]  или табличные данные. Представления также могут ссылаться внутри себя не только на таблицу,
[45:18.500 --> 45:22.860]  но и на другие представления. Соответственно, в таком случае у нас будет каскадное выполнение
[45:22.860 --> 45:30.300]  представления при обращении к верхнюю уровню. По цепочке, двигаясь вниз к нашим физическим
[45:30.300 --> 45:36.740]  отношениям, будет соответственно выполняться наш запрос. Вообще цель использования представлений
[45:36.740 --> 45:43.900]  это абстракция безопасности, логическое разделение данных, но мне лично, наверное,
[45:43.900 --> 45:51.100]  больше всего нравится в этом смысле абстракция. То есть мы можем создать слой внутри нашей базы,
[45:51.100 --> 45:56.740]  некий дополнительный слой абстракции, когда даже пользователи смогут обращаться не к нашим
[45:56.740 --> 46:02.980]  физическим представлениям, а к чему-то, например, к чему-то более похожему, вот обращаясь к теме
[46:02.980 --> 46:06.900]  проектирования, к чему-то более похожему на логическую схему или, может быть, даже
[46:06.900 --> 46:13.540]  вообще на концептуальную схему данных. Это уже такие вопросы, немножко перемежающиеся с
[46:13.540 --> 46:24.380]  хранилищами данных, с обработкой данных, с анализом данных, так сказать, на лету в режиме онлайн,
[46:24.380 --> 46:32.820]  да, вот с тем, что как мы данные агрегируем, собираем их в хранилища, из хранилища их
[46:32.820 --> 46:41.780]  выводим на витрины, делаем лапку бы и так далее. Вот тема немножко смежная с этим, она не
[46:41.780 --> 46:48.840]  тождественна, конечно, но поскольку мы еще остаемся в рамках позгресса и обычной революционной
[46:48.840 --> 46:57.600]  СОБД, но, тем не менее, связь, да, очевидно, прослеживается, то есть мы можем несколько упростить работу
[46:57.600 --> 47:06.200]  аналитиком с нашей какой-то конкретной отдельно взятой базой, используя представление как способ
[47:06.200 --> 47:16.320]  формирования нового слоя, нового слоя абстракции. Так, и позгресс также поддерживает, в принципе,
[47:16.320 --> 47:21.440]  материализованные представления, то есть те представления, которые могут быть сохранены
[47:21.440 --> 47:31.800]  в виде физической таблицы, периодически обновляемой либо автоматически, либо вручную. Да, кстати,
[47:31.800 --> 47:36.560]  ну соответственно, коль скорое представление у нас выполняются на лету в процессе выполнения
[47:36.560 --> 47:43.440]  запроса, обращающегося к ним, соответственно, у нас представление, да, по сути дела, всегда
[47:43.920 --> 47:54.000]  некие актуальные данные в отличие от варианта физического хранения результата промежуточных
[47:54.000 --> 47:59.680]  запросов. Ну понятно, что если мы таблицу храним, она у нас, некую таблицу на физическом уровне мы
[47:59.680 --> 48:05.080]  подразумеваем, что она всегда у нас актуальна, просто по определению, поскольку мы постоянно в неё
[48:05.080 --> 48:12.000]  заносим какие-то данные, но чисто технически, вот может быть удобно хранить какой-то набор
[48:12.000 --> 48:22.320]  агрегатных данных по нашей основной, что ли, схеме данных, потому что не всегда удобно там
[48:22.320 --> 48:33.840]  джойнить и группировать, агрегировать какое-то большое количество физических таблиц и какое-то
[48:33.840 --> 48:42.000]  большое количество данных. Поэтому представление, ну правда, конечно, здесь есть нюансы, что если мы
[48:42.000 --> 48:48.400]  храним какие-то промежуточные данные, периодически их обновляем в виде физической таблицы, мы
[48:48.400 --> 48:55.920]  сокращаем расходы на запросы. Представления нематериализованы, конечно, расходы на запросы не
[48:55.920 --> 49:01.040]  сокращают, они просто более удобный синтаксис могут предоставлять конечным пользователям. Ну
[49:01.120 --> 49:08.600]  окей, ладно, это такие темы более абстрактные. Давайте посмотрим на представления вблизи.
[49:08.600 --> 49:14.000]  Представления ещё бывают изменяемые и неизменяемые, да, важно отметить. Изменяемые
[49:14.000 --> 49:20.920]  представления позволяют при этом не только выполнять чтение, но и изменять данные в базовом
[49:20.920 --> 49:28.600]  отношении, на которые они ссылаются, к которому они обращаются. И по умолчанию все простые
[49:28.600 --> 49:34.320]  представления являются автоматически изменяемыми. Для сложных представлений такого эффекта может
[49:34.320 --> 49:41.360]  добиться, ну, например, используя триггеры, в частности триггеры instead of. Что значит
[49:41.360 --> 49:46.520]  простое представление? Простое представление является таковым, если оно соответствует некоторым
[49:46.520 --> 49:58.040]  условиям, а именно в списке from должен быть ровно один элемент. В определении представления
[49:58.040 --> 50:05.480]  не должно содержаться предложение with, distinct, group, by, having и вот еще некоторых. Но, опять же,
[50:05.480 --> 50:09.840]  это на верхнем уровне запроса. Мы можем внутри вложить, конечно, поиграться и вложить что-то
[50:09.840 --> 50:18.400]  еще, как бы обманув таким образом систему, что называется. Также не должно содержаться команд
[50:18.400 --> 50:26.920]  union, intersect, accept и список выборки, то есть то, что у нас между select и from расположено,
[50:26.920 --> 50:32.920]  а именно перечисление наших столбцов. Не должен содержать агрегатных и оконных функций, а также
[50:32.920 --> 50:38.600]  функции возвращающих множество. Синтаксис представления довольно простой. Опять же,
[50:38.600 --> 50:48.600]  используются команды create. Дальше, некоторый набор возможных дополнительных команд. Опять же,
[50:48.600 --> 50:54.960]  обратите внимание, можно создавать рекурсивные представления. И после create мы используем
[50:54.960 --> 51:05.720]  дополнительное обязательное слово view и дальше имя нашего представления. Далее
[51:05.720 --> 51:15.840]  представление, по большому счету, задается как, например, select запрос. Например, создание
[51:15.840 --> 51:27.360]  представления комедии из данных некой таблицы с фильмами. Мы создаем наше представление по
[51:27.360 --> 51:35.560]  условию, что тематика или жанр фильма у нас соответствует теме комедии, соответствует маркировке
[51:35.560 --> 51:46.760]  комедии. При этом обратите еще внимание на нашу select звездочку. Звездочка в данном случае ведет
[51:46.760 --> 51:52.440]  себя специфически, потому что мы, хотя и вроде бы обращаемся, казалось бы, ко всем столбцам,
[51:52.440 --> 51:58.800]  но на самом деле наша база запоминает при создании, что мы делаем, а именно, вернее,
[51:58.800 --> 52:05.800]  запоминает при создании представления свою структуру. И в дальнейшем, когда мы будем
[52:05.800 --> 52:13.800]  использовать наш запрос, у нас будут выдаваться не все наши столбцы из таблицы фильмов,
[52:13.800 --> 52:22.600]  а только те столбцы, которые были в таблице фильмы на момент создания запроса. Вот пример
[52:22.600 --> 52:32.560]  создания представления с изменяемого представления, но это изменяемое мое представление,
[52:32.560 --> 52:47.720]  оно имеет ограничение по условию проверки. То есть у нас здесь, если мы обратимся, вот мы создали
[52:47.720 --> 52:58.600]  представление Universal Comedies. Если мы к нему обратимся в дальнейшем по команде insert с
[52:58.600 --> 53:12.320]  командой insert или update, то мы не сможем вставить или обновить запись, если у нас она не пройдет
[53:12.320 --> 53:23.720]  проверку, если у нас не будет поля classification равно значению U. При этом ограничение по полю
[53:23.720 --> 53:28.520]  kind, вот то, о чем мы говорили при создании представления комедии, а мы обратите внимание еще
[53:28.520 --> 53:36.360]  раз в предложении from, ссылаемся тоже на представление Comedies, созданное ранее. То есть мы при
[53:36.360 --> 53:45.080]  добавлении в наше представление второго уровня Universal Comedies должны будем соблюсти только по
[53:45.080 --> 53:53.800]  классификации, только по условию classification правильное значение, мы должны будем добавлять только
[53:53.800 --> 54:01.400]  сроки с classification равно U. А тот факт, что у нас еще на самом представлении Comedies было наложено
[54:01.400 --> 54:11.960]  ограничение, то есть столбец kind, он проверяться автоматически не будет. У нас, соответственно,
[54:11.960 --> 54:16.360]  могут быть какие-то ошибки в связи с этим, если у нас нет ограничений дополнительных на
[54:16.360 --> 54:29.040]  наше, на нашем базовом отношении. А если мы хотим сделать необходимую проверку не только нашего
[54:29.040 --> 54:37.200]  текущего отношения представления, к которому мы обращаемся, но и подлежащих представлений,
[54:37.200 --> 54:44.320]  то есть представления, на которые ссылается наше верхнеуровневое, то мы должны check option
[54:44.320 --> 54:51.840]  изменить и использовать не local, а cascaded. Тогда у нас в случае создания представления по команде
[54:51.840 --> 54:57.840]  на слайду, на слайде, прошу прощения, будет проверяться не только столбец classification,
[54:57.840 --> 55:07.480]  чтобы в нем была маркировка PG, но и столбец kind нашего подлежащего представления Comedies,
[55:07.480 --> 55:14.200]  чтобы также маркировка была правильная, по сроке, по столбцу Comedies было значение Comedies.
[55:14.200 --> 55:21.080]  Вот еще пример представления, где поддерживается операция insert и delete,
[55:21.080 --> 55:28.240]  но изменятся будут все столбцы из таблицы films, кроме вычисляемых столбцов, то есть у нас здесь,
[55:28.240 --> 55:39.560]  мы выбираем из таблицы films все столбцы, вот f. звездочка, но еще мы добавляем несколько столбцов
[55:39.560 --> 55:54.840]  несколько столбцов, которые вычисляются в процессе, это country и average rating, при этом
[55:54.840 --> 56:04.400]  country code to name это некоторая вот у нас функция получается, и average rating это у нас результат
[56:04.400 --> 56:14.640]  выполнения внутреннего, связан с результатом выполнения под запрос Select, они не соответствуют
[56:14.640 --> 56:24.400]  в данном случае определению простого запроса, и они у нас изменяться не будут при использовании
[56:24.400 --> 56:36.040]  insert, update или delete. Хорошо, оконные функции, в данном случае оконные функции это расширение,
[56:36.040 --> 56:49.960]  можно сказать, функциональности предложения group by, за счет того, что мы можем теперь не склопывать
[56:49.960 --> 56:58.960]  строки с одинаковыми значениями, а оставлять их различными, так вопрос можно сделать так,
[56:58.960 --> 57:02.720]  чтобы представление выдавало действительно все значения, даже добавленные после создания view,
[57:02.720 --> 57:08.800]  но в общем случае оно будет выдавать все значения даже после создания view, просто если здесь вопрос,
[57:08.800 --> 57:15.240]  смотрите, новые строки оно выдавать будет, новые атрибуты внутри таблицы, к которой оно
[57:15.240 --> 57:22.440]  обращается, оно выдавать не будет, вот такой механизм, то есть здесь вы ограничены по атрибутам,
[57:22.440 --> 57:31.320]  вы тогда просто будете обновить представление после создания. С оконными функциями, как уже я
[57:31.320 --> 57:38.520]  сказал, строки не группируются в одну выходную строку, и оконную функцию можно определить путем
[57:38.520 --> 57:46.800]  того, что она всегда содержит предложение over, смотрите, здесь довольно синтаксис, наверное,
[57:46.800 --> 57:51.560]  простой, вот с пониманием опять же оконных функций будет сложнее, то есть когда у нас есть некоторая
[57:51.560 --> 57:59.400]  функция, мы можем использовать после нее предложение over и дальше определить, собственно говоря,
[57:59.400 --> 58:06.680]  окно, внутри которых функция получается у нас будет действовать, и для определения окна у нас
[58:06.680 --> 58:12.840]  существует несколько вариантов, имя существующего окна, но этого мы касаться не будем, а вот partition
[58:12.840 --> 58:19.120]  by, order by и определение рамки, об этом сейчас с вами поговорим. Предложение, собственно,
[58:19.120 --> 58:25.400]  over определяет то, как именно нужно разделить строки запроса для обработки оконной функции.
[58:25.400 --> 58:39.120]  Да, предложение partition by, дополняющее over, разделяет строки по группам или разделам,
[58:39.120 --> 58:45.720]  объединяя одинаковые значения выражений partition by, и оконная функция вычисляется тогда соответственно
[58:45.720 --> 58:53.000]  по строкам, попадающим в один раздел с текущей строкой. Предложение order by позволяет определять
[58:53.000 --> 58:56.920]  порядок, в котором строки будут обрабатываться оконными функциями, а параметр рамки окна
[58:56.920 --> 59:02.600]  позволяет определить набор строк в ее разделе партиции, которые будут обрабатываться оконной
[59:02.600 --> 59:13.040]  функцией. Давайте посмотрим на примерах. Оконные функции, если у нас внутри over не определено,
[59:13.040 --> 59:22.880]  собственно говоря, окно, по сути дела отработает как просто суммирование. Все значения из столбца
[59:22.880 --> 59:31.680]  salary по сути дела у нас в данном случае подцепятся, просуммируются и присоединятся в виде дополнительного
[59:31.680 --> 59:47.600]  столбца сам. А вот что будет, если мы в данном случае определим среднее жалование, но окно
[59:47.600 --> 59:59.240]  определим по департаменту. В таком случае мы везде смотрим на каждую строку и по департаменту мы
[59:59.240 --> 01:00:06.560]  соответственно определяем партицию. То есть окно для, ну единственно здесь у нас, прошу прощения,
[01:00:06.560 --> 01:00:13.280]  немножко разновой получился с заголовками и с определением столбцов, но depth name это department,
[01:00:13.280 --> 01:00:23.960]  employee number и salary. Average соответственно average salary. То есть мы здесь в столбце department
[01:00:23.960 --> 01:00:33.400]  выбираем имя, конкретное прошу прощения название департамента depth develop и наша партиция получается
[01:00:33.400 --> 01:00:43.200]  равна вот этому вот окну. Наш раздел, вот оконная функция у нас будет действовать вот в этом
[01:00:43.200 --> 01:00:52.680]  вот разделе develop, но по каждой строке. Единственно что в данном случае у нас нет никаких спецификаций
[01:00:52.680 --> 01:00:58.800]  для определения рамки окна, то есть внутри и внутри партиции может быть еще и дополнительное
[01:00:58.800 --> 01:01:07.680]  ограничение, дополнительная рамка по отношению к строке. И у нас получается тогда функционал очень
[01:01:07.680 --> 01:01:17.880]  похожий на group buy. По департаменту суммируется все жалование и вычисляется среднее жалование,
[01:01:17.880 --> 01:01:23.200]  средняя заработная плата. То же самое по департаменту personnel и по департаменту sales.
[01:01:23.200 --> 01:01:34.480]  Ну опять повторюсь, очень похоже на group buy. Первые три столбца извлекаются из нашей
[01:01:34.480 --> 01:01:40.480]  таблицы непосредственно, а причем для каждой строки таблицы есть строка результата. В четвертом
[01:01:40.480 --> 01:01:45.000]  столбце оказалось среднее значение, вычисленное по всем строкам, имеющим то же значение depth name,
[01:01:45.000 --> 01:01:49.800]  что и текущая строка. Единственное, что здесь еще можно сказать, если бы у нас было group buy,
[01:01:49.800 --> 01:01:58.240]  если бы было group buy, у нас бы ответ был бы не по каждой строке, у нас бы вот это вот все
[01:01:58.240 --> 01:02:05.160]  схлопнулось вместе и ответ был бы только один. И мы бы не смогли его подцепить,
[01:02:05.160 --> 01:02:10.360]  не используя там каких-то дополнительных ущрений, не смогли бы подцепить напрямую
[01:02:10.360 --> 01:02:16.840]  к каждой строке нашей исходной таблицы. С партиционированием с оконной функцией мы это
[01:02:16.840 --> 01:02:21.440]  делаем легко, потому что, как говорилось в определении, результат выполнения оконной
[01:02:21.440 --> 01:02:27.920]  функции при использовании оконной функции у нас не происходит схлопывания строк, у нас вот этот
[01:02:27.920 --> 01:02:37.920]  over, даже определение окна, не заставляет базу данных все это сжимать воедино в некий,
[01:02:37.920 --> 01:02:45.480]  ну условно говоря, сжимать, да в кавычках, в некий агрегированный результат. Давайте посмотрим
[01:02:45.480 --> 01:02:52.720]  еще на пример с order buy. Здесь довольно любопытная штука происходит, потому что order buy у нас
[01:02:52.720 --> 01:03:03.080]  действует по умолчанию с указанием order buy. Ранка состоит из всех строк, от начала раздела до текущей
[01:03:03.080 --> 01:03:08.440]  строки, из строк равных текущей по значению выражения order buy. Но об этом чуть подробнее через
[01:03:08.440 --> 01:03:24.200]  несколько слайдов. Так, и мы здесь, по сути дела, вычисляем ранг по жалованию внутри партиции,
[01:03:24.200 --> 01:03:33.160]  определенной по департаменту. Соответственно, у нас есть департамент, у нас есть жалование,
[01:03:33.160 --> 01:03:47.440]  и вот у нас первое окно develop, разработка, и смотрим тогда, да, какой у нас ранг по жалованию.
[01:03:47.440 --> 01:03:54.040]  6000, это максимально в нашем окне? Да, это максимально, вот у нас первый ранг. И 5200,
[01:03:54.040 --> 01:04:02.520]  соответственно, следующее значение, и 4500 значение номер 4, и 4200 значение номер 5,
[01:04:02.520 --> 01:04:15.720]  почему так? Потому что у нас здесь одинаковые значения жалования, и ранг, он у нас один,
[01:04:15.720 --> 01:04:20.440]  но в общем зачете это уже получается, да, третья строка. Вот эта строка четвертая,
[01:04:20.440 --> 01:04:30.480]  пятая в общем зачете работников, что ли, да, поэтому, то есть это пятая, это четвертый работник
[01:04:30.480 --> 01:04:40.280]  всего, и он на четвертом месте, но он как бы на третьем месте, но по сути он четвертый. Вот такая
[01:04:40.280 --> 01:04:49.440]  немножко сложная логика за счет использования order by rank, но в принципе, если вы попробуете это
[01:04:49.440 --> 01:04:57.320]  руками, вы к этому привыкнете. Выдает порядковый номер, как уже было сказано, для каждого уникального
[01:04:57.320 --> 01:05:01.880]  значения в разделе текущей строки, по которому выполняется сортировка order by. У функции rank нет
[01:05:01.880 --> 01:05:08.120]  параметров, так как ее поведение полностью определяется поведением over. Давайте еще немножко
[01:05:08.120 --> 01:05:20.480]  с примерами. Здесь у нас тоже вычисление суммы заработной платы, но без партиционирования и
[01:05:20.480 --> 01:05:29.400]  только с использованием order by для задания rank окна. Тогда что у нас происходит? Поскольку order
[01:05:29.400 --> 01:05:39.240]  by у нас действует, как было сказано ранее, на все предшествующие строки и на текущую, то когда мы
[01:05:39.240 --> 01:05:44.680]  вот в этом окне начинаем по каждой строке, мы проходим, повторюсь, начинаем проходить по каждой
[01:05:44.680 --> 01:05:55.720]  строке. От сортированной по жалованию получается, что 3500 это наименьшее значение, то есть до 3500
[01:05:55.720 --> 01:06:00.440]  у нас просто физически нет меньшего значения, то есть физически нет другой строки, поэтому здесь
[01:06:00.440 --> 01:06:07.120]  только 3500. Следующее значение 3900, и здесь уже мы объединяем текущую строку с предыдущей,
[01:06:07.120 --> 01:06:17.760]  4200 мы объединяем текущую строку с предыдущими, 4500 тоже самое. Опять же order by идет по salary,
[01:06:17.760 --> 01:06:24.400]  поэтому мы суммируем не сам, суммируем не экспоненциальный рост, получается все здесь
[01:06:24.400 --> 01:06:36.320]  нормально. У нас получается рост по salary, 3500 плюс 3900, 7400 плюс 4200, 11600 и так далее. И
[01:06:36.320 --> 01:06:43.680]  каждая новая строка у нас расширяет рамку нашего окна. Ну, наше окно вернее, скажем так,
[01:06:43.680 --> 01:06:49.120]  правильнее, чтобы не путать понятия. Вот у нас при первой строке окно в виде одной строки,
[01:06:49.120 --> 01:06:55.080]  прошу прощения, для второй строки окно уже из двух строк, для третьей строки окно уже из трех
[01:06:55.080 --> 01:06:59.600]  строк и так далее. Если бы у нас было еще партиционирование дополнительно, например,
[01:06:59.600 --> 01:07:11.480]  по, опять же, по тому же департаменту, то у нас было бы тогда внутри вот этого вот окна нашего,
[01:07:11.480 --> 01:07:21.080]  рамка окна всегда бы двигалась по order by посрочно, то есть было бы первое 4200 значение,
[01:07:21.080 --> 01:07:27.280]  и здесь был бы не rank, а sum, было бы тоже 4200. Второе значение было бы 4500. Рамка окна
[01:07:27.360 --> 01:07:39.000]  внутри партиции была бы уже из двух строк, и sum была бы 8700. Дальше было бы 505200. Рамка окна
[01:07:39.000 --> 01:07:49.040]  была бы уже из трех строк, и была бы sum соответственно 8700 плюс 5200 до 13900 и так далее.
[01:07:49.040 --> 01:08:00.760]  Поэтому вот это вот задание окна, определение окна, оно не взаимо исключающее, вот то,
[01:08:00.760 --> 01:08:08.800]  что здесь приведено, а оно взаимодополняющее, и мы можем поэтому говорить о том, что у нас есть
[01:08:08.800 --> 01:08:18.480]  окно, которое задается командой over. Внутри окна мы можем дополнительно еще задать выражение,
[01:08:18.480 --> 01:08:27.520]  которое нам это окно либо сузит, либо как-то специфически расширит, и внутри окна мы
[01:08:27.520 --> 01:08:37.120]  можем задать еще и рамку, по которой будет наша функция проходить, чтобы уменьшить или каким-то
[01:08:37.120 --> 01:08:42.040]  образом специфическим агрегировать наши результаты так, как нам это необходимо.
[01:08:42.040 --> 01:08:53.000]  Так, хорошо, тогда у нас небольшой комментарий по селекту, который мы с вами только что видели,
[01:08:53.000 --> 01:09:02.440]  по тройоконной функции. В общем-то бы это уже все сказали, что накапливаются зарплаты от первой,
[01:09:02.440 --> 01:09:08.800]  самой низкой до текущей, включая повторяющиеся текущие значения. Обратите внимание на результат,
[01:09:08.800 --> 01:09:18.560]  вот в одинаковых сроках он не просуммировался у нас, потому что в данном случае у нас нет,
[01:09:18.560 --> 01:09:23.160]  ну не просуммировался дважды, потому что в данном случае у нас однопорядковый
[01:09:23.160 --> 01:09:31.560]  результат для выполнения вот этой команды. Order by salary, то есть 4800, 4800, он не различает,
[01:09:31.560 --> 01:09:43.200]  как и 5200, 5200, поэтому для него это одно и то же, он не считает это, ну парсер, оптимизатор и так
[01:09:43.200 --> 01:09:52.000]  далее. Наш SQL запрос не рассматривает вот эти вот строки как различающиеся, они для него едины,
[01:09:52.120 --> 01:09:59.360]  и он SQL запрос для себя внутри вот своих каких-то оптимизационных процедур нашей СВД уже учел эту
[01:09:59.360 --> 01:10:03.000]  строку и новое идентичное значение для него уже не воспримет.
