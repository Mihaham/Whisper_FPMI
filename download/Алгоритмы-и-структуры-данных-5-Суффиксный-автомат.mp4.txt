[00:00.000 --> 00:20.160]  Так, добрый день, продолжаем про строковые суффиксные
[00:20.160 --> 00:21.160]  структуры.
[00:21.160 --> 00:22.600]  У нас был суффиксное дерево, сегодня суффиксный автомат.
[00:22.600 --> 00:37.280]  Значит, по моим представлениям об этой жизни, суфф дерево
[00:37.280 --> 00:41.000]  и суфф автомат в каком-то смысле взаимозаменяемые
[00:41.000 --> 00:44.160]  структуры, и, грубо говоря, достаточно знать что-то
[00:44.160 --> 00:45.160]  одного из них.
[00:45.160 --> 00:48.680]  На семинаре должна быть задача о том, как построить...
[00:48.680 --> 00:52.320]  Ну, в общем, есть очень простое соответствие между
[00:52.320 --> 00:55.240]  суфф автоматом для строки S и суфф деревом для строки
[00:55.240 --> 00:56.240]  S-реверсунда.
[00:56.240 --> 00:58.200]  То есть, если вы строчку записываете справа налево,
[00:58.200 --> 01:01.040]  для нее стоит суфф дерево, а для исходной просто построили
[01:01.040 --> 01:02.040]  суфф автомат.
[01:02.040 --> 01:05.040]  Давайте напишу автомат.
[01:05.040 --> 01:06.040]  Здесь дерево.
[01:06.040 --> 01:10.800]  То они, ну, там будут практически одним и тем же объектом.
[01:10.800 --> 01:13.680]  То есть, у них будет одинаковая структура рёбера переходов,
[01:13.680 --> 01:16.040]  надо будет только понять, что написать на ребрах.
[01:16.880 --> 01:20.240]  То есть, в каком-то смысле это очень похожие вещи,
[01:20.240 --> 01:23.280]  и чтобы решать какие-то задачи, достаточно знать
[01:23.280 --> 01:24.280]  одной структуры.
[01:24.280 --> 01:28.840]  Это уже, в общем, вам на выбор, что вам более понятно,
[01:28.840 --> 01:32.360]  что кажется более простым для написания и так далее.
[01:32.360 --> 01:36.400]  Ну, что такое автомат сначала?
[01:36.400 --> 01:37.560]  Давайте нарисуем какие-нибудь картинки.
[01:37.560 --> 01:40.240]  Что такое детерминированный...
[01:46.240 --> 01:47.240]  конечный автомат.
[01:51.760 --> 01:54.040]  Так, кто знает, что это такое, пожалуйста, дайте знать.
[01:59.600 --> 02:00.600]  Которое что, еще раз?
[02:03.640 --> 02:05.600]  Ну, это на формалах должно быть.
[02:05.600 --> 02:07.400]  Наверное, только по моему тематику, я надеюсь.
[02:08.600 --> 02:09.600]  Вот.
[02:09.600 --> 02:11.840]  Ну, концепция очень простая.
[02:11.840 --> 02:14.680]  Это граф, ориентированный, у которого на ребрах написаны
[02:14.680 --> 02:15.680]  какие-то буквы.
[02:17.040 --> 02:21.440]  Так, я сейчас что-нибудь нарисую интересненькое.
[02:33.440 --> 02:36.040]  Дальше, какая-то вершина помещена стартовой, давайте
[02:36.040 --> 02:37.600]  вот так вот буду выделять у старт.
[02:37.600 --> 02:42.640]  И какие-то вершины помещены терминальными.
[02:42.640 --> 02:44.400]  Ну, давайте, например, будет у меня вот эта терминальная
[02:44.400 --> 02:45.400]  и вот эта терминальная.
[02:45.400 --> 02:52.560]  То есть, это ориентированный граф, где одна вершина выделена
[02:52.560 --> 02:54.840]  в качестве стартовой и несколько в качестве терминальных.
[02:54.840 --> 03:02.240]  Дальше, этот автомат, он все слова, ну, над, скажем,
[03:02.240 --> 03:04.320]  произвольным алфавитом, либо принимает, либо не
[03:04.320 --> 03:05.320]  принимает.
[03:05.320 --> 03:07.000]  Принимает он те слова, которые соответствуют каким-то
[03:07.000 --> 03:10.360]  корректным путям из начальной вершины в одну из терминальных.
[03:10.440 --> 03:15.120]  Например, этот автомат принимает слово AB, ABE или, например,
[03:15.120 --> 03:16.120]  ABCA.
[03:16.120 --> 03:19.960]  Можно вот так пройти по этой петле и тоже прийти в терминальное
[03:19.960 --> 03:20.960]  состояние.
[03:20.960 --> 03:22.920]  Давайте нарисуем какие-нибудь примеры.
[03:22.920 --> 03:29.960]  Принимает AB, ABE, потому что он заканчивается в этой
[03:29.960 --> 03:34.320]  терминальной вершинке, ABCA, ну, например, можно целиком
[03:34.320 --> 03:39.080]  пройти вот эту вот петлю и еще AB в конце, ABEXAB.
[03:39.580 --> 03:43.600]  В общем, любой корректный путь по ребрам, по буковкам
[03:43.600 --> 03:45.780]  заканчивающихся в терминальной вершинке это принимаемое
[03:45.780 --> 03:46.780]  слово.
[03:46.780 --> 03:51.400]  Все остальное это непринимаемые слова, не принимают.
[03:51.400 --> 03:55.840]  Например, this automaton не принимает слово А, потому
[03:55.840 --> 03:58.020]  что оно ведет в не терминальную вершину.
[03:58.020 --> 04:02.060]  Не принимает слово ABEX, потому что, ну, опять-таки не
[04:02.060 --> 04:03.760]  ведет в терминальную вершину.
[04:03.760 --> 04:06.140]  Ну, и более того, он не принимает слово С, потому
[04:06.140 --> 04:08.920]  что мы вообще не можем даже такое слово прочитать
[04:08.920 --> 04:09.920]  в автомате.
[04:09.920 --> 04:11.720]  Мы не можем встать в стартовую вершинку, прочитать как-то
[04:11.720 --> 04:13.240]  С и закончиться в тюрьме.
[04:13.240 --> 04:14.960]  Мы даже просто её прочитать не можем.
[04:14.960 --> 04:16.640]  Поэтому это слово тоже считается непринимаемым.
[04:16.640 --> 04:21.760]  Ну, формальное определение писать не буду.
[04:21.760 --> 04:23.440]  Нам главное вот это вот интуитивное понимание
[04:23.440 --> 04:24.440]  плюс картинка.
[04:24.440 --> 04:27.860]  А ещё, значит, нужно сказать, что такой детерминированный
[04:27.860 --> 04:41.560]  Это значит, что не бывает вот таких вот случаев.
[04:41.560 --> 04:43.700]  Не бывает случаев, когда из одной вершины есть два
[04:43.700 --> 04:45.040]  перехода по одинаковой букве.
[04:45.040 --> 04:48.120]  Ну, так же, как у нас было в боре, в сухдереве.
[04:48.120 --> 04:51.480]  Нельзя, чтобы была какая-то неоднозначность про чтение.
[04:51.480 --> 04:53.280]  То есть, встав в вершинку, если мы хотим пересвечить
[04:53.280 --> 04:56.800]  какую-то букву, то вариантов действия максимум один.
[04:57.020 --> 04:58.260]  Но не два и больше.
[04:58.260 --> 05:01.820]  Вот, значит, детерминированный, конечно, автомат.
[05:01.820 --> 05:09.060]  И мы у такого автомата, ну, по сути, у такого графа
[05:09.060 --> 05:11.020]  можем определить множество принимаемых слов.
[05:11.020 --> 05:29.320]  Пусть А автомат через L от А будем обозначать множество
[05:29.320 --> 05:30.560]  принимаемых им слов.
[05:41.020 --> 05:54.580]  Вот, и нам нужно будет построить такой автомат, как можно
[05:54.580 --> 05:56.620]  меньшего размера, чтобы он занимал как можно меньше
[05:56.620 --> 05:59.820]  памяти, строился как можно меньше по времени, который
[05:59.820 --> 06:03.460]  бы принимал все суффиксы некоторой строки и только
[06:03.460 --> 06:04.460]  их.
[06:05.460 --> 06:18.020]  По данной строке S построить, ну, вот я напишу, минимальный
[06:18.020 --> 06:25.080]  в каком-то смысле автомат, а такой, что вот это вот
[06:25.080 --> 06:28.140]  L от А, это есть все суффиксы строки S и только они.
[06:34.460 --> 06:47.740]  То есть, автомат принимает еще только суффиксы некоторой
[06:47.740 --> 06:49.260]  фиксированной строки S.
[06:49.260 --> 06:52.060]  А почему, например, мы не делаем автомат, который
[06:52.060 --> 06:53.060]  принимал бы все префиксы?
[06:53.060 --> 06:55.100]  Ну, потому что он тривиальный, можно просто написать вот
[06:55.100 --> 07:02.140]  так вот S сверху вниз по символю S1, S2, и так далее S&N, и все
[07:02.140 --> 07:04.060]  вершины сделать терминальными, тогда мы понимаем все
[07:04.060 --> 07:07.500]  префиксы только их, да, потому что начав из стартовой
[07:07.500 --> 07:09.860]  вершинки, прочитав какой-то путь, это обязательно будет
[07:09.860 --> 07:11.660]  префикс, мы заканчиваем терминальное вершине, тут
[07:11.660 --> 07:13.980]  как бы автомат не очень интересен, а вот суффиксами
[07:13.980 --> 07:15.660]  уже будет похитрее.
[07:15.660 --> 07:25.420]  Хорошо, ничего дальше, определение.
[07:25.420 --> 07:29.660]  Вот у нас есть некий язык, да, у нас есть язык суффиксов
[07:29.660 --> 07:31.300]  строки S.
[07:31.780 --> 07:35.620]  Дальше, если мы хотим строить автомат для какого-то произвольного
[07:35.620 --> 07:38.260]  языка, в нашем случае это будет множество всех суффиксов
[07:38.260 --> 07:40.460]  строки S, но давайте пока для произвольного языка.
[07:40.460 --> 07:47.660]  Значит, пусть L произвольный язык, то есть произвольное
[07:47.660 --> 07:48.660]  множество слов.
[07:48.660 --> 07:53.180]  Отношение эквивалентности относительно этого языка
[07:53.180 --> 07:57.860]  мы вводим, но сначала вводим правый контекст, значит,
[07:57.860 --> 08:09.300]  если x это слово, то r с индексом l от x, это все такие, скажем
[08:09.300 --> 08:11.580]  z, что xz это слово из языка.
[08:11.580 --> 08:20.580]  И это мы будем называть правым контекстом.
[08:20.580 --> 08:31.300]  Правый контекст, слово x относительно l.
[08:31.300 --> 08:33.340]  То есть правый контекст это множество всевозможных
[08:33.340 --> 08:37.860]  дополнений x справа до слова из языка, то есть что-то
[08:37.860 --> 08:43.580]  мы пишем справа так, чтобы это было слово из языка.
[08:43.580 --> 08:48.500]  Полезное такое мнимоническое свойство, правило, как это
[08:49.100 --> 08:50.100]  следующее.
[08:50.100 --> 08:51.380]  Что такое вот эти дополнения справа?
[08:51.380 --> 08:54.180]  Это, например, когда вы заходите в поисковую строку,
[08:54.180 --> 08:57.220]  вбиваете там некое начало вашего запроса, а вам предлагают
[08:57.220 --> 08:59.860]  несколько дополнений до популярных запросов.
[08:59.860 --> 09:04.500]  В этом плане можно в качестве l рассматривать набор популярных
[09:04.500 --> 09:07.580]  запросов, что у гугла часто спрашивают.
[09:07.580 --> 09:11.020]  x это то, что вы уже успели вбить, а z это все возможные
[09:11.020 --> 09:15.700]  продолжения типа как быстро, если x это как быстро, то
[09:15.700 --> 09:19.380]  в качестве z вас может быть почистить зубы, сшить
[09:19.380 --> 09:20.380]  что-нибудь.
[09:20.380 --> 09:26.100]  Все, самые популярные запросы дополняет в поисковую строку
[09:26.100 --> 09:27.100]  вбивать.
[09:27.100 --> 09:34.420]  Значит, дальше мы вводим отношение эквивалентности.
[09:34.420 --> 09:42.100]  Мы говорим, что два слова эквивалентны относительно
[09:42.100 --> 09:45.740]  языка l, если и только если у них одинаковый правый
[09:45.740 --> 09:57.900]  контекст.
[09:57.900 --> 09:59.500]  Слова эквивалентны, если и только если у них одинаковый
[09:59.500 --> 10:00.500]  правый контекст.
[10:00.500 --> 10:14.900]  Так, ну и дальше теорема Майхилла Нироуда.
[10:14.900 --> 10:17.120]  Она говорит примерно следующее, что если у вас есть некий
[10:17.120 --> 10:20.260]  язык l, вот как у нас здесь фиксирование некий язык,
[10:20.260 --> 10:23.620]  и относительно него есть сколько-то классов эквивалентности.
[10:23.620 --> 10:25.980]  Скажем, вот все слова нашего алфавита, все слова из
[10:25.980 --> 10:30.900]  сигма звездочки, как-то разбились на классы эквивалентности
[10:30.900 --> 10:32.460]  в соответствии с этим отношением.
[10:32.460 --> 10:33.620]  Ну, конечно, это отношение эквивалентности, потому
[10:33.620 --> 10:36.740]  что тут тоже отношение эквивалентности.
[10:36.740 --> 10:39.540]  Все слова разбились на классы эквивалентности, и утверждается
[10:39.540 --> 10:43.820]  теоремой, что в минимальном автомате, который бы принимал
[10:43.820 --> 10:47.300]  ровно этот язык l, то есть распознавал бы этот язык
[10:47.300 --> 10:50.740]  l, число состояний равно в точности числу класса
[10:50.740 --> 10:51.740]  эквивалентности.
[10:51.740 --> 10:55.020]  Ну давайте я это напишу.
[10:55.020 --> 10:59.420]  Пусть l это произвольный язык.
[10:59.420 --> 11:15.940]  Пусть, будьте здоровы, относительно отношения, относительно отношения
[11:16.940 --> 11:22.340]  тильда с индексом l, есть ровно k классов эквивалентности.
[11:22.340 --> 11:27.100]  K классов эквивалентности.
[11:27.100 --> 11:36.140]  Тогда в минимальном диссерминированном, конечно, автомате, который
[11:36.140 --> 11:39.580]  распознает в точности l, который принимает l, ровно
[11:40.300 --> 11:41.300]  вершин.
[11:41.300 --> 11:48.780]  В минимальном, ну давайте здесь напишу, полном, диссерминированном
[11:48.780 --> 11:58.780]  в конечном автомате, принимающем l, ровно а вершину.
[11:58.780 --> 12:11.020]  Вот, то есть если игнорируем это слово полный, то по сути
[12:11.020 --> 12:13.860]  нам количество классов эквивалентности относительно
[12:13.860 --> 12:16.140]  введенного отношения и говорим, сколько у нас
[12:16.140 --> 12:18.020]  будет минимальный число вершин в диссерминированном
[12:18.020 --> 12:19.020]  автомате.
[12:19.020 --> 12:22.340]  Да, минимальный, минимальность здесь понимается с точки
[12:22.340 --> 12:25.460]  зрения числа вершин, минимальный по числу вершин.
[12:25.460 --> 12:35.460]  Ну смотри, что такое отношение эквивалентности, это по сути
[12:35.460 --> 12:39.340]  набор пар x, y таких, что у них вот это вот одинаково.
[12:39.340 --> 12:42.780]  Дальше, если у вас фиксировано некое отношение эквивалентности,
[12:42.780 --> 12:46.500]  вот это вот tilde sin xml, то у вас все сигма звездочка
[12:46.500 --> 12:50.020]  бьется на вот такие вот множества класса эквивалентности,
[12:50.020 --> 12:52.380]  такие, что внутри каждого класса любые два слова
[12:52.380 --> 12:55.620]  находятся в отношении, а меньше два слова не находятся
[12:55.620 --> 12:56.620]  в отношении.
[12:56.620 --> 12:58.780]  В этом смысле отношение эквивалентности это как
[12:58.780 --> 13:03.220]  бы пары, находящиеся в отношении, а классы эквивалентности
[13:03.220 --> 13:06.700]  это как раз множество такое, что внутри множество все
[13:06.700 --> 13:09.700]  они попарны в отношении, а если добавить любое другое,
[13:09.700 --> 13:10.700]  то они уже не будут в отношении.
[13:10.700 --> 13:17.620]  Ну это будет без доказательства, это как бы для тех, у кого
[13:17.620 --> 13:20.860]  есть формалки, вы наверное уже должны знать, если нет,
[13:20.860 --> 13:21.860]  скоро узнаете.
[13:21.860 --> 13:22.860]  Да уже должны знать.
[13:22.860 --> 13:23.860]  Вот.
[13:23.860 --> 13:27.420]  А для нас это значит примерно следующее, что вот это отношение
[13:27.420 --> 13:29.140]  эквивалентности, в которое мы вводим равенство правых
[13:29.140 --> 13:32.900]  контекстов, это и есть, собственно, оценка на то, сколько вершин
[13:32.900 --> 13:34.180]  в автомате мы будем ожидать.
[13:34.180 --> 13:37.100]  Сколько вершин в автомате, соответственно, каждая
[13:37.100 --> 13:40.340]  вершина, по сути, представляет собой некий класс эквивалентности.
[13:40.340 --> 13:49.380]  Так, хорошо, ну соответственно, из-за этой теории мы будем
[13:49.420 --> 13:52.420]  возиться очень долго с классами эквивалентности относительно
[13:52.420 --> 13:55.100]  нашего языка, разбираться, как они устроены, как устроены
[13:55.100 --> 13:57.380]  правые контексты, что бывает, когда там между ними какие-то
[13:57.380 --> 13:58.380]  соотношения и так далее.
[13:58.380 --> 14:11.580]  Значит, давайте с этого момента считаем, что L это все суффиксы
[14:11.580 --> 14:23.020]  строки S, а также в качестве всех строк там X, Y и так далее
[14:23.020 --> 14:24.780]  мы будем рассматривать только под строки S.
[14:41.580 --> 14:48.420]  Ну, потому что если мы берем какой-то не под строку,
[14:48.420 --> 14:51.020]  да, какой-то набор символов, который не является под
[14:51.020 --> 14:56.780]  строкой S, он у нас, ну, давайте напишу, значит, если X это
[14:56.780 --> 15:03.180]  не под строка S, не под строка S, то скажите, пожалуйста,
[15:03.180 --> 15:10.940]  чему равен правый контекст этой строки?
[15:10.940 --> 15:12.860]  Пустое множество, да, потому что если это не под строка,
[15:12.860 --> 15:15.300]  то мы ее как ни пытаемся, мы не можем добить ее до
[15:15.300 --> 15:18.820]  конца строки S, до суффикса, поэтому это пустое множество.
[15:18.820 --> 15:21.980]  Ну и более того, это, собственно, критерии того, что X не
[15:21.980 --> 15:31.660]  под строка S, значит, и наоборот, если RL от X это пустое множество,
[15:31.660 --> 15:40.380]  то X не под строка S, потому что иначе будет под строкой
[15:40.380 --> 15:43.060]  хотя бы одно продолжение до конца было бы, мы можем
[15:43.060 --> 15:45.540]  что-то дописать, то есть есть под строка, есть какое-то
[15:45.540 --> 15:48.300]  окончание до конца строки, соответственно, вот это
[15:48.300 --> 15:51.900]  было бы нашим элементом правого контекста, а мы
[15:51.900 --> 15:53.260]  предполагаем, что нет ни одного элемента.
[15:53.260 --> 16:00.460]  То, Эпсилон, пустая строка, ну, как бы пустая строка
[16:00.460 --> 16:05.300]  это тоже строка, сигма звездочка, тут есть пустое слово.
[16:06.140 --> 16:10.140]  Вот, ну чего, значит, как бы не под строками можем
[16:10.140 --> 16:13.100]  выбросить, они все характеризуют всем, что у них правый контекст
[16:13.100 --> 16:16.220]  пустой и в терминах нашего автомата, который мы в итоге
[16:16.220 --> 16:19.460]  построим, это будут те слова, которые не отвечают
[16:19.460 --> 16:21.700]  корректным путям в автомате, то есть вот, например, на
[16:21.700 --> 16:27.300]  этом рисунке вот C это то самое не под слово, то есть
[16:27.300 --> 16:30.020]  мы стоим здесь, мы даже не можем его прочитать, мы
[16:30.020 --> 16:33.620]  не можем, начав стартовывершинку, прочитать C, ровно то же
[16:34.180 --> 16:35.780]  받아path, то же самое будет с непод строками C, там
[16:35.780 --> 16:39.460]  как бы какую часть можем прочитать, например, ABB,
[16:39.460 --> 16:42.260]  AB мы можем прочитать, AB отсюда уже прочитать не можем,
[16:42.260 --> 16:43.300]  мы из автомата вываливаемся.
[16:43.300 --> 16:46.900]  Ровно то же самое будет происходить с непод строками,
[16:46.900 --> 16:48.980]  мы ближе до кута доходим, потом не можем прочитать.
[16:48.980 --> 16:52.340]  Вот, поэтому давайте пока игнорировать и считать,
[16:52.340 --> 16:55.540]  что все строки, которые мы рассматриваем, это под
[16:55.540 --> 16:57.660]  строки С.
[16:57.660 --> 17:06.960]  Начну утверждение, если правые контексты двух подстрок
[17:06.960 --> 17:15.480]  одинаковые, давайте их назову U и V, если правые контексты
[17:15.480 --> 17:22.520]  двух строк одинаковые, то либо U suffix V, либо, наоборот,
[17:22.520 --> 17:34.440]  U suffix U, то есть слова, лежащие в одном классике
[17:34.440 --> 17:37.740]  эквивалентности, потому что мы знаем, что совпадение
[17:37.740 --> 17:40.000]  правых контекстов – это то же самое, что лежать в
[17:40.000 --> 17:43.600]  отношении эквивалентности, значит, слова, находящиеся
[17:43.600 --> 17:46.040]  в отношении эквивалентности, являются обязательно
[17:46.040 --> 17:47.040]  одно суффиксом другого.
[17:47.040 --> 17:53.600]  Ну, доказательств здесь нехитрое, смотрите, раз
[17:53.600 --> 17:56.720]  правые контексты совпадают, и они не пустые, потому
[17:56.720 --> 17:59.160]  что мы договорились не рассматривать строки с
[17:59.160 --> 18:02.080]  пустым правым контекстом, то есть хотя бы один общий
[18:02.080 --> 18:03.080]  элемент.
[18:03.080 --> 18:06.280]  Есть некое вот продолжение, есть некий вот тот самый
[18:06.280 --> 18:11.840]  Z, такой, что U Z – это суффикс S, и V Z – это суффикс S, но
[18:11.840 --> 18:16.880]  давайте это нарисуем, вот было S наше, что значит,
[18:16.880 --> 18:20.040]  что U Z – это суффикс S, значит, где-то вот здесь находится
[18:20.040 --> 18:24.160]  U, а все, что правее до конца строки – это Z, ну а тогда
[18:24.160 --> 18:31.240]  U Z – это как раз суффикс S, U Z – суффикс S, то есть,
[18:31.240 --> 18:34.000]  поскольку у меня оба эти множества не пустые, потому
[18:34.000 --> 18:36.420]  что U и V – это по строке S, то тогда обязательно есть
[18:36.420 --> 18:38.880]  хотя бы одно вот такое Z, такое, что U Z – это суффикс
[18:38.880 --> 18:39.880]  S.
[18:39.880 --> 18:43.240]  Более того, поскольку эти множества одинаковые,
[18:43.240 --> 18:52.880]  то V Z тоже суффикс S, V Z тоже суффикс S, значит, вот
[18:52.880 --> 18:55.280]  оно Z, да, мы как бы с конца идем, вот оно Z, где-то здесь
[18:55.280 --> 18:58.320]  находится V, ну и, соответственно, оно либо вот такое какое-то
[18:58.320 --> 19:01.400]  содержащее U целиком, либо вот такое, наоборот, вложенное
[19:01.400 --> 19:05.360]  в U, ну и тогда видно, что в любом случае одна строка
[19:05.560 --> 19:16.000]  суффикс другой. Понятно? Значит, ну давай, напишем,
[19:16.000 --> 19:35.080]  U и V имеют одинаковое окончание сождения в S, в том смысле,
[19:35.080 --> 19:38.800]  что вот она позиция такая, что в ней заканчивается
[19:38.800 --> 19:41.760]  вхождение U и вхождение V, да, у них одинаковое окончание
[19:41.760 --> 19:47.160]  вот в этой вот позиции. Ну и дальше, если длина U меньше
[19:47.160 --> 19:56.120]  длины V, то U – это суффикс V, иначе, наоборот, иначе V – это
[19:56.120 --> 20:24.360]  суффикс U.
[20:24.360 --> 20:39.160]  Дальше утверждение об устройстве класса эквивалентности.
[20:39.160 --> 20:41.160]  Утверждение говорит нам о том, как может выглядеть
[20:41.160 --> 20:51.320]  любой класс эквивалентности. Значит, пусть C класс эквивалентности,
[20:51.320 --> 21:00.640]  когда существует некая строка U, такая, что C состоит
[21:00.640 --> 21:08.560]  из U и нескольких ее самых длинных суффиксов. Я так
[21:08.560 --> 21:13.040]  не очень хорошо напишу, но пусть будет так. И несколько
[21:13.040 --> 21:28.440]  ее самых длинных суффиксов. То есть картинка будет такой,
[21:28.440 --> 21:31.000]  есть некая строка U, самая длинная строка в нашем классе,
[21:31.000 --> 21:33.640]  лежащая в этом классе. Затем мы откусили от нее первый
[21:33.640 --> 21:36.480]  символ, получили суффикс длинный 1 поменьше, откусили
[21:36.480 --> 21:38.840]  еще один символ, получили следующий подлиннее суффикс,
[21:38.840 --> 21:41.840]  ну и так далее. Несколько таких вот суффиксов, самых
[21:41.840 --> 21:46.840]  длинных. Это все один класс C. А скажем, следующее уже,
[21:46.840 --> 21:49.200]  если мы еще один символ откусим, то это будет уже следующий
[21:49.200 --> 22:02.000]  класс. Я вот так нарисую, уже другой класс. Любой класс
[22:02.000 --> 22:06.400]  содержит некую самую длинную строчку в себе, и затем
[22:06.400 --> 22:08.840]  если вы многократно будете отбрасывать первый символ
[22:08.840 --> 22:11.860]  вот этой вот текущей строки, то вы таким образом заметете
[22:11.860 --> 22:14.680]  все C. На какой-то момент уже будет другой класс, но
[22:14.680 --> 22:18.360]  главное, что C это вот несколько отличающихся на один таких
[22:18.360 --> 22:25.760]  вот строчек по длине. Так, доказается, ну пусть U
[22:25.760 --> 22:34.280]  это самая длинная строка в C. Пусть U самая длинная
[22:34.280 --> 22:42.720]  строка в C. Дальше, поскольку все слова в одном классе
[22:42.720 --> 22:45.760]  имеют одинаковый правый контекст, по определению,
[22:45.760 --> 22:47.360]  класс эквивалентности, это множество слов, у которых
[22:47.360 --> 22:49.000]  одинаковый правый контекст, такое, что к ним больше
[22:49.000 --> 22:51.680]  никого нельзя добавить в этот же класс. Значит, еще
[22:51.680 --> 22:55.800]  раз, пусть U это самая длинная строка в C, тогда все остальные
[22:55.800 --> 22:58.720]  слова из этого же класса гарантированно имеют тот
[22:58.720 --> 23:08.360]  же правый контекст. Для любого, ну там V из C и rl от U равно
[23:08.360 --> 23:12.000]  rl от V, потому что они в одном классе, в одном классе эквивалентности.
[23:12.000 --> 23:16.360]  Ну, а раз у них одинаковый правый контекст, то по предыдущему
[23:16.360 --> 23:23.920]  утверждению гарантировано V это суффиксу. Тогда по
[23:23.920 --> 23:33.360]  предыдущему утверждению V это суффиксу. Причем именно
[23:33.360 --> 23:36.160]  в таком порядке не U суффиксу, а именно V суффиксу, потому
[23:36.160 --> 23:38.480]  что U самая длинная, значит, не может быть наоборот.
[23:38.480 --> 23:44.440]  Значит, мы получили, что в одном классе находится
[23:44.440 --> 23:48.320]  одна строка U и только ее суффиксы. Вот теперь вопрос,
[23:48.320 --> 23:50.040]  почему это непрерывный отрезок в порядке убывания длин.
[23:50.040 --> 23:54.280]  То есть мы поняли, что здесь могут быть какие-то суффиксы
[23:54.280 --> 23:56.680]  и только суффиксы. Вопрос, почему это обязательно несколько
[23:56.680 --> 24:00.360]  подряд идущих. Ну давайте возьмем какой-нибудь самый
[24:00.360 --> 24:05.400]  короткий. Пусть V самая короткая
[24:05.400 --> 24:21.000]  слова из C. Самая короткая строка в C. Тогда мы точно
[24:21.000 --> 24:25.240]  знаем, что в C лежит вот эта вот U и некий ее суффикс
[24:25.240 --> 24:28.840]  V. Достаточно доказать, что все суффиксы промежуточной
[24:28.840 --> 24:32.440]  длины тоже лежат в C. Если мы докажем, что между вот
[24:32.440 --> 24:34.440]  этими длиннокрайностями все промежуточные тоже
[24:34.440 --> 24:37.960]  лежат в C, то получается, что C целиком образует некий
[24:37.960 --> 24:41.040]  отрезок суффиксов. Все более короткие не лежат, все более
[24:41.040 --> 24:43.560]  длинные не лежат, а вот целиком отрезок здесь находится.
[24:43.560 --> 24:47.640]  Ну давайте для этого рассмотрим произвольную промежуточную
[24:47.640 --> 24:50.760]  строчку здесь, какую-нибудь W и докажем, что она имеет
[24:50.760 --> 25:02.200]  тот же класс эквивалентности. Пусть W это суффикс U, причем
[25:02.200 --> 25:04.760]  вот так у нас соотносятся длины. Длина U больше длины
[25:04.760 --> 25:09.880]  W больше длины V. То есть это вот суффикс промежуточной
[25:09.880 --> 25:17.880]  длины. Ну тогда что? Тогда мы знаем. Тогда мы точно
[25:17.880 --> 25:22.040]  знаем, смотрите. Давайте я напишу вот такое вот соотношение.
[25:22.040 --> 25:30.520]  RL от W, нет, RL от U вложено в RL от W и оно в свою очередь
[25:30.520 --> 25:50.200]  вложено в RL от V. Тут нужна картинка. Так, что у нас есть?
[25:50.200 --> 25:53.920]  У нас есть, что V это суффикс W, а W это суффикс U. Ну давайте
[25:53.920 --> 26:00.200]  нарисуем. Давайте нарисуем какое-нибудь вхождение U.
[26:00.200 --> 26:04.160]  Здесь вхождение U. Мы точно понимаем, что коль скоро
[26:04.160 --> 26:07.080]  у нас в строке нашлось вхождение U, вот в этой нашей большой
[26:07.080 --> 26:10.880]  S было вхождение U, то здесь же заканчивается вхождение
[26:10.880 --> 26:17.000]  и V и W. Потому что вот они, вот здесь W, а здесь V. Поэтому
[26:17.000 --> 26:19.720]  автоматически мы знаем вот такое вот соотношение,
[26:19.720 --> 26:24.320]  что RL от U вложено в RL от W. Ну просто любое вхождение
[26:24.320 --> 26:27.360]  U автоматически порождает вхождение W, а значит все,
[26:27.360 --> 26:30.920]  что вот здесь справа лежало, раз оно было в правом контексте
[26:30.920 --> 26:33.920]  U, то оно также лежит в правом контексте W. Возможно здесь
[26:33.920 --> 26:37.040]  даже было бы не строгое вложение, наоборот строгое вложение
[26:37.040 --> 26:41.240]  в случае, если например есть некое вхождение W, не продолжающееся
[26:41.240 --> 26:45.000]  влево до вхождения U. Такой гипотетический могло бы
[26:45.000 --> 26:48.000]  быть, поэтому я здесь пишу просто вложение. То же самое
[26:48.000 --> 26:55.160]  с этими двумя. Вот есть наша S. Мы знаем, что V это суффикс
[26:55.160 --> 26:59.320]  W, потому что W больше длины и является суффиксом той
[26:59.320 --> 27:03.240]  же строки U. Ну то же самое. Это значит, что любое вхождение
[27:03.240 --> 27:06.240]  W автоматически генерирует вхождение W, поэтому у нас
[27:06.240 --> 27:08.800]  есть такое соотношение на классы. Навсюду где есть
[27:08.800 --> 27:14.240]  W есть здесь же W. Поэтому любая строка, вот здесь вот, дополняющая
[27:14.240 --> 27:17.880]  справа до суффикса, если она лежит здесь, то она автоматически
[27:17.880 --> 27:22.960]  лежит здесь. Значит есть вот такое вложение. Вот,
[27:22.960 --> 27:26.440]  с другой стороны, мы знаем, что RL от U равно RL от V. Мы знаем,
[27:26.440 --> 27:29.200]  что внутри этого класса у них у всех одинаковые правые
[27:29.200 --> 27:32.640]  контексты. А раз у нас крайние элементы равны, то значит
[27:32.640 --> 27:37.480]  здесь тоже везде равенство. Поэтому правый контекст
[27:37.480 --> 27:41.280]  строки W такой же, как и у, и у В. Значит W обязательно
[27:41.280 --> 27:52.280]  в том же классе лежит. Значит отсюда RL от W равно RL от U.
[27:53.160 --> 28:05.720]  Равно RL от V. Значит W лежит в C. Что и требовалось. Нам
[28:05.720 --> 28:09.360]  ровно это и хотелось показать, что все слова промежуточной
[28:09.360 --> 28:12.840]  длины между U и V лежат в том же классе. Ну вот мы показали.
[28:12.840 --> 28:40.640]  Вот, ну и тогда, например, с использованием теории
[28:40.640 --> 28:42.880]  Махиллони Роуд, мы уже можем описать, как будет выглядеть
[28:42.880 --> 28:46.200]  наш искомый минимальный суффиксный автомат. Да,
[28:46.200 --> 28:50.480]  то есть суффиксный автомат до строки S. Значит мы понимаем,
[28:50.480 --> 28:54.560]  что каждый класс это с срока и нескольких суффиксов,
[28:54.560 --> 28:57.920]  а также мы понимаем, как по сути они все устроены.
[28:57.920 --> 29:01.200]  Ну не совсем, сейчас скажу. Значит нужно понять, что
[29:01.200 --> 29:06.080]  с переходами будет примерно следующее. Смотрите, что
[29:06.080 --> 29:08.440]  такое вершина в суффиксном автомате? Это по сути некий
[29:08.440 --> 29:11.880]  классик эволентности. То есть набор строк. Вот есть
[29:11.880 --> 29:14.000]  некая вершина, отвечающая набору вот таких вот строк.
[29:14.000 --> 29:22.480]  И есть другая вершина, отвечающая еще кому-то набору строк.
[29:22.480 --> 29:26.520]  И между ними бывают переходы. Да, ну автомат, понятно,
[29:26.520 --> 29:29.040]  там нужны какие-то ребра. Вот когда есть переход
[29:29.040 --> 29:32.760]  из одного состояния в другой, из одной вершины в другое.
[29:32.760 --> 29:36.000]  Ну раз есть такой переход, что это значит? Значит что,
[29:36.000 --> 29:37.880]  ну вот, например, мы стали в стартовую вершинку, где-то
[29:37.880 --> 29:41.600]  у нас был акустарт. Мы могли до вот этой вершинки дойти
[29:41.600 --> 29:44.440]  несколькими способами. Там вот первый способ нас
[29:44.440 --> 29:47.160]  приводил бы в такое слово, второй в такое, третий в
[29:47.160 --> 29:49.440]  такое, четвертый в такое. И дальше каким бы образом
[29:49.440 --> 29:52.400]  мы до этой вершинки не дошли, мы можем прочитать буковку
[29:52.400 --> 29:55.520]  с и попасть в другую вершину. То есть независимо от того,
[29:55.520 --> 29:58.400]  как именно мы попали из стартовой вершины вот сюда,
[29:58.400 --> 30:00.440]  мы можем дописать с и попасть в одно из слов вот этого
[30:00.440 --> 30:03.400]  класса эволюмности, новой вершинки. Но это в частности
[30:03.400 --> 30:09.160]  означает, что по сути дописывание буковы с справа ко всем вот
[30:09.160 --> 30:13.760]  этим словам дает мне слово какое-то вот отсюда. То есть
[30:13.760 --> 30:16.600]  если я допишу вот сюда буковку с, ну давайте пусть это будет
[30:16.600 --> 30:20.760]  у, это будет у с с на конце. Если это в, то это в с с на
[30:20.760 --> 30:25.120]  конце. Вот, и тогда по сути автомат будет выглядеть
[30:25.120 --> 30:31.040]  так. Значит автомат. Вершины – это классы эволюмности,
[30:31.040 --> 30:36.040]  как мы уже поняли. Вершины – это классы эволюмности,
[30:36.040 --> 30:42.800]  классы эволюмности. Ну а переходы, то есть вот эти
[30:42.800 --> 30:47.240]  вот ребра, ребра с меточками, ребра с буквами, это все
[30:47.240 --> 30:52.960]  такие возможные, ну давайте я так напишу. Что такое
[30:52.960 --> 31:00.280]  ребро? Ребро – это пара вершин и метка. Так, как
[31:00.320 --> 31:09.000]  будет написать? Давайте я так напишу. Все тройки, класс
[31:09.000 --> 31:13.960]  1, класс 2 и символ, ну пусть будет, так ц маленько тупо,
[31:13.960 --> 31:24.160]  пусть будет, ну пусть будет д, такие что в классе ц1 есть
[31:24.160 --> 31:38.240]  слово у, такое что в классе ц2 есть слово уц. А то есть
[31:38.240 --> 31:44.800]  мы грубо говоря рассматриваем все пары классов, уд, рассматриваем
[31:44.800 --> 31:48.680]  все пары классов, смотрим есть ли в первом классе такое
[31:48.680 --> 31:51.080]  слово, что после дописывания одной буквы мы попадаем
[31:51.080 --> 31:55.280]  во второй класс. И если есть такой, если есть такая
[31:55.280 --> 31:58.600]  пара слов, то здесь у, а здесь уд, то мы добавляем переход
[31:58.600 --> 32:03.120]  между этими двумя классами по стрелочке с меткой д.
[32:03.120 --> 32:08.840]  Заводим такое ребро с меткой д. Вот, ну и чуть позже мы
[32:08.840 --> 32:13.000]  докажем, что на самом деле это будет корректный переход,
[32:13.000 --> 32:15.040]  то есть любое слово, вот если мы возьмем любое слово
[32:15.040 --> 32:18.120]  вот отсюда, а даже давайте сразу докажем. Я утверждаю,
[32:18.120 --> 32:20.600]  что если есть хотя бы один такой переход, то здесь
[32:20.600 --> 32:23.920]  было слово у, а здесь есть слово уд, то тогда на самом
[32:23.920 --> 32:26.520]  деле любое слово отсюда с помощью буквы д продолжается
[32:26.520 --> 32:32.160]  обязательно сюда. Так, ну значит почему это так?
[32:32.160 --> 32:37.640]  То есть у нас вот, представьте, что у нас были два слова,
[32:37.640 --> 32:41.600]  в одном классе ц1, вот здесь была у и в. Почему после
[32:41.600 --> 32:43.780]  дописывания буквы д мы попадаем обязательно в один класс
[32:43.780 --> 32:47.980]  эквивалентности? Значит у и в были в одном классе,
[32:47.980 --> 32:55.060]  почему уд и ув, vd наоборот, лежат тоже в одном классе
[32:55.060 --> 33:09.420]  ц2? Так, кто-то может ответить? То есть у нас были два слова
[33:09.420 --> 33:12.140]  одного класса, мы дописали к ним произвольную буквку
[33:12.140 --> 33:15.300]  справа к обеим словам, к обоим словам, почему мы
[33:15.300 --> 33:39.980]  обязательно получим слова из одного класса ц2? Да-да-да-да,
[33:40.820 --> 33:48.500]  давайте я это и запишу. Пусть z это слово из правого контекста
[33:48.500 --> 33:58.420]  слово уд, тогда что я могу написать? У, д, z это суффикс
[33:58.420 --> 34:08.780]  v, суффикс с, тогда д, z это слово из правого контекста
[34:08.780 --> 34:12.180]  у, потому что вот оно у и все что написано справа
[34:12.180 --> 34:16.220]  это добивка до суффикса. Отсюда следует, что поскольку
[34:16.220 --> 34:18.300]  исходно они были в одном классе эквивалентности,
[34:18.300 --> 34:26.020]  то д, z также лежит в правом контексте для слова v, поскольку
[34:26.020 --> 34:35.100]  они были в одном классе эквивалентности, ну и значит z лежит в правом контексте
[34:35.100 --> 34:39.180]  слово v, д, то есть мы взяли произвольное слово из правого
[34:39.180 --> 34:42.180]  контекста слово уд, получили, что это же слово лежит
[34:42.180 --> 34:44.820]  в правом контексте слова v, д, ну и наоборот можно
[34:44.820 --> 34:46.580]  провести то же самое, что любое слово отсюда лежит
[34:46.580 --> 34:51.500]  здесь, значит у них одинаковый класс. Вот, тем самым мы показали,
[34:51.500 --> 34:54.140]  что такие переходы действительно корректны, если есть хотя
[34:54.140 --> 34:56.900]  бы один такой возможный переход, то есть я взял слово
[34:56.900 --> 34:59.580]  отсюда, написал д, получил слово отсюда, то на самом
[34:59.580 --> 35:01.740]  деле это будет верно для любого слова, какое бы
[35:01.740 --> 35:04.620]  слово отсюда не взял и дописал бы тот же самый символ
[35:04.620 --> 35:08.500]  д, то я обязательно попаду в тот же самый класс c2. И тем
[35:08.500 --> 35:11.140]  самым мы как раз описали все возможные переходы,
[35:11.140 --> 35:13.820]  что мы были в одном классе, нам нужно было дописать
[35:13.820 --> 35:15.620]  одну букву, чтобы попасть в другой класс, ну вот они
[35:15.620 --> 35:19.100]  все сразу все слова из этого класса целиком наследуются
[35:19.100 --> 35:25.180]  в другой класс, предописывая одну букву. Так, и последнее,
[35:25.180 --> 35:27.020]  что нам нужно, это еще понять, что такое терминальные
[35:27.020 --> 35:32.740]  вершины, терминальные вершины, ну и начальные. Так, терминальные
[35:32.740 --> 35:37.900]  вершины. Скажите, пожалуйста, как определить вот в этом
[35:37.900 --> 35:43.220]  автомате, какие вершины будут терминальными? Еще раз?
[35:43.220 --> 35:52.660]  Да, в программном контексте есть эпсилон. Я бы так сформулировал.
[35:52.660 --> 36:00.500]  Терминальная, ну не так. Давайте так и напишем. В
[36:00.500 --> 36:06.260]  программном контексте, в программном контексте есть
[36:06.260 --> 36:11.060]  эпсилон. Терминальная это вершина, содержащая суффикс,
[36:11.880 --> 36:17.500]  то есть мы как бы встали в стартовую вершину, как то
[36:17.500 --> 36:20.600]  прошли, дошли до терминальной. И терминальные у нас должны
[36:20.600 --> 36:23.160]  быть ровно те, которые отвечают суффиксом. То есть мы встали
[36:23.160 --> 36:25.940]  в начало, что-то прочитали, закончились, прочитав
[36:25.940 --> 36:28.860]  суффикс. Суффикс это те, у кого в программном контексте
[36:28.860 --> 36:31.860]  лежит эпсилон. И более того, наоборот, если в программном
[36:31.860 --> 36:34.740]  контексте есть эпсилон, то это обязательно вершина,
[36:34.740 --> 36:37.980]  отвечающая только суффиксом, потому что только у суффикса
[36:37.980 --> 36:43.220]  в правом контексте может быть пустая строка, пустая
[36:43.220 --> 36:44.220]  строка.
[36:44.220 --> 36:51.740]  Ну, значит, сущности содержания Эпсилона – это, короче,
[36:51.740 --> 36:53.620]  те, кто содержит Эпсилон – это суффиксы, вот мы их
[36:53.620 --> 36:54.620]  все помещаем.
[36:54.620 --> 36:55.620]  Так, да?
[36:55.620 --> 37:00.820]  Ну, конечно, да, конечно, например, если у вас есть
[37:00.820 --> 37:04.340]  вот такая как-нибудь строка АВАВ, то у вас правый контекст
[37:04.340 --> 37:10.820]  суффикса АВ – это Эпсилон и АВ, это нормально.
[37:10.820 --> 37:16.260]  Ну, и начальная вершина, понятно, что это класс, отвечающий
[37:16.260 --> 37:21.660]  пустой строке, какой правый контекст у этой начальной
[37:21.660 --> 37:24.660]  вершины?
[37:24.660 --> 37:33.860]  Да, все подстроки, начальная вершина, правый контекст
[37:34.380 --> 37:37.380]  релет, кустарт, я напишу вот так, правый контекст
[37:37.380 --> 37:42.500]  стартовой вершины – это все подстроки С, все подстроки.
[37:42.500 --> 37:47.060]  А потому что начало – это как-нибудь пустая строка,
[37:47.060 --> 37:48.540]  сколькими способами?
[37:48.540 --> 37:52.660]  Нет, не так, все суффиксы, да, наверное, скорее, да,
[37:52.660 --> 37:53.660]  все суффиксы.
[37:53.660 --> 37:59.940]  У нас же правый контекст – это добивка до конца строки,
[37:59.940 --> 38:02.860]  поэтому здесь будут все суффиксы.
[38:02.860 --> 38:09.020]  Ну и только у этой вершины, у пустого слова в правом
[38:09.020 --> 38:12.460]  контексте будут все суффиксы, потому что во всех суффиксах,
[38:12.460 --> 38:16.100]  в частности, есть все слово С, на вся строка, значит,
[38:16.100 --> 38:19.380]  в начале может быть только Эпсилон – пустая строка.
[38:19.380 --> 38:23.660]  Ну вроде мы весь темат так описали, и как бы в принципе,
[38:23.660 --> 38:26.220]  если нам нужно хоть за какую-то асимптотику построить
[38:26.220 --> 38:27.220]  его, то вот он алгоритм.
[38:27.460 --> 38:30.260]  Да, мы просто сначала бьем все подстроки по классам,
[38:30.260 --> 38:32.820]  считая правые контексты, потом вот так проводим ребра,
[38:32.820 --> 38:33.820]  находим терминальные вершины и стартово.
[38:33.820 --> 38:37.980]  Вот, ну конечно, мы научимся это делать более эффективно.
[38:37.980 --> 38:49.100]  Хороший вопрос, нет, он не полный будет, там не будет
[38:49.100 --> 38:50.100]  не подстрок.
[38:50.100 --> 38:56.300]  Давайте какой-нибудь пример нарисуем, выдавайте
[38:56.380 --> 39:17.460]  тоже АБАБ, нарисуем его, АБАБ, так, ладно, значит,
[39:17.460 --> 39:20.020]  какой правый контекст у строки АБАБ, значит только
[39:20.020 --> 39:23.300]  Эпсилон, у БАБ тоже только Эпсилон, у АБАБ уже другой,
[39:23.300 --> 39:29.700]  то есть это будет один класс, у АБ и Б еще свой класс,
[39:29.700 --> 39:36.900]  у Эпсилон еще свой класс, то есть это были все, заканчиваемся
[39:36.900 --> 39:40.220]  тут, перезаканчиваемся здесь, у АБА правый контекст
[39:40.220 --> 39:48.180]  только Б, у БА тоже правый контекст только Б, у А уже
[39:48.180 --> 39:54.100]  другой контекст, так, АБ уже было, Б уже было, А уже
[39:54.100 --> 39:55.100]  было.
[39:55.100 --> 39:58.420]  Так, вроде я все разбил, сейчас я нарисовал разбиение
[39:58.420 --> 40:02.140]  всех подстрок слова АБАБ на классы эквивалентности,
[40:02.140 --> 40:03.140]  проверяйте, что оно правильное, пожалуйста.
[40:03.140 --> 40:18.060]  Ну, вроде да, вроде такое разбиение, это будет
[40:18.060 --> 40:19.220]  стартовое состояние.
[40:19.220 --> 40:28.460]  Ну и переходы какие, здесь будет переход по А, здесь
[40:28.460 --> 40:38.700]  будет переход по Б, дальше, дальше, дальше, здесь будет
[40:38.700 --> 40:53.340]  переход по Б, АБ, А, и здесь будет Б.
[40:53.340 --> 40:55.540]  Вот такой автомат, значит, вот это будут суффиксные,
[40:55.540 --> 40:59.300]  точнее, терминальные вершины, потому что в них есть суффиксы,
[40:59.300 --> 41:00.300]  и только в них.
[41:00.300 --> 41:04.620]  Вот, ну, короче, как видим, здесь нет неподстрок, да,
[41:04.620 --> 41:07.180]  то есть все, что мы можем прочитать в этом автомате,
[41:07.180 --> 41:10.340]  это только подстроки исходной строки.
[41:10.340 --> 41:13.620]  Если мы стартуем в стартовой вершине и как-то здесь ходим,
[41:13.620 --> 41:17.700]  то можем прочитать только подстроки исходной строки.
[41:17.700 --> 41:19.900]  Ну, собственно, мы его так и строим, да, мы там в какой-то
[41:19.900 --> 41:21.660]  момент сказали, что рассматриваем только подстроки.
[41:21.660 --> 41:27.580]  И здесь число вершин, оно равно, конечно, числу класса
[41:27.580 --> 41:29.860]  эквивалентности относительно нашего отношения, кроме
[41:29.860 --> 41:34.860]  вот этого вот, когда RL это пустое множество, да, вот
[41:34.860 --> 41:37.940]  этого как бы не включается в автомат, не включается
[41:37.940 --> 41:38.940]  в автомат.
[41:38.940 --> 41:43.300]  Отвечая на ваш вопрос, если бы хотели сделать полный
[41:43.300 --> 41:46.060]  суффиксный автомат, то есть тот, у которого есть
[41:46.060 --> 41:49.380]  из каждой вершины стрелки по всем возможным буквам,
[41:49.380 --> 41:52.620]  то нам нужно было бы еще завести фиктивное состояние,
[41:52.620 --> 41:57.300]  отвечающее не под словом, ну, не под строком, не под
[41:57.300 --> 41:58.300]  строки.
[41:58.300 --> 42:00.460]  И проводить вот такие вот ребра, значит, отсюда
[42:00.460 --> 42:04.100]  по A мы переходим в неподстроки, отсюда по B мы переходим
[42:04.100 --> 42:07.740]  в неподстроки, отсюда по A и отсюда по A и по B.
[42:07.740 --> 42:10.660]  И здесь еще есть петли A и B.
[42:10.660 --> 42:11.660]  Вот.
[42:11.660 --> 42:15.180]  Но поскольку мы договорились, что нам не нужна явным образом
[42:15.180 --> 42:18.780]  эта вершина, да, то есть если бы мы ввели дополнительно
[42:18.780 --> 42:21.620]  такую вершинку и провели бы в нее все недостающие
[42:21.620 --> 42:24.700]  ребра по всем недостающим буквам и еще бы зациклили
[42:24.700 --> 42:28.300]  на нее бы петли повесили, то мы бы как бы могли читать
[42:28.300 --> 42:31.500]  любое слово над нашим алфавитом, но, возможно, иногда бы
[42:31.500 --> 42:33.340]  заканчивались вот этой вот вершине, которая отвечает
[42:33.340 --> 42:34.340]  не под строчкой.
[42:34.340 --> 42:37.940]  Значит, от этого у нас увеличивается число вершин на 1, но зато
[42:37.940 --> 42:41.100]  мы можем читать любую строчку, заканчивая в кодте вершинки
[42:41.100 --> 42:42.100]  гарантированно.
[42:42.100 --> 42:43.100]  Вот.
[42:43.100 --> 42:46.260]  Нам, в принципе, это не нужно, поэтому у нас число вершин
[42:46.260 --> 42:49.900]  будет равно, ну, числу классифика лентности за вычетом вот
[42:49.900 --> 42:53.460]  этого одного, за вычетом того, который не отвечает
[42:53.460 --> 42:54.460]  под строчком.
[42:55.460 --> 43:02.320]  Число вершин – это число классов эквивалентности
[43:02.320 --> 43:04.780]  минус 1.
[43:04.780 --> 43:13.220]  Классов эквивалентности минус 1, так как не включаем
[43:13.220 --> 43:16.220]  непростройки.
[43:16.220 --> 43:18.220]  Вот.
[43:18.220 --> 43:23.300]  И он от этого в частности становится неполным, да,
[43:23.300 --> 43:27.660]  потому что мы, по сути, все ребра, ведущие в вершину
[43:27.660 --> 43:29.980]  отвечающую не под строчкой, мы их просто все удалили
[43:29.980 --> 43:32.140]  вместе с этой вершиной и оставили только то, что
[43:32.140 --> 43:33.140]  отвечает под строком.
[43:33.140 --> 43:36.260]  Ну, тем самым мы уменьшим наш смат на одну вершинку,
[43:36.260 --> 43:39.300]  но основная суть его сохранилась.
[43:39.300 --> 43:42.140]  Все, что здесь, это какая-то фигня, которая ничему не
[43:42.140 --> 43:43.140]  отвечает.
[43:43.140 --> 43:46.180]  Мы ее просто игнорируем, считаем, что если мы попасть
[43:46.180 --> 43:49.540]  туда, то же самое, что попытаться прочитать незаконный символ,
[43:50.300 --> 43:51.300]  который не ведет ни в какую вершину.
[43:51.300 --> 44:12.020]  Так, ладно, тогда давайте дальше изучать суффиксный
[44:12.020 --> 44:14.660]  автомат на пути к тому, чтобы построить его за
[44:14.660 --> 44:15.660]  линейное время.
[44:16.660 --> 44:26.660]  Значит, обозначение, обозначение, пусть x это какое-то слово
[44:26.660 --> 44:31.620]  через x в квадратных скобках просто или, скажем, x в квадратных
[44:31.620 --> 44:35.020]  скобках с индексом s, мы будем обозначать класс эквивалентности
[44:35.020 --> 44:38.780]  слова x относительно вот того самого нашего языка,
[44:38.780 --> 44:41.780]  определяемого словом s.
[44:41.900 --> 44:49.820]  Ну, как обычно, вроде стандартное обозначение квадратные
[44:49.820 --> 44:52.500]  скобки – это множество всех слов, которые лежат
[44:52.500 --> 44:55.380]  в том же классе эквивалентности, что и x.
[44:55.380 --> 44:58.300]  То есть, можно так написать, что это множество всех
[44:58.300 --> 45:05.220]  y таких, что x с y находится в отношении l, в отношении
[45:05.220 --> 45:06.220]  эквивалентности тильда.
[45:06.220 --> 45:19.340]  Значит, дальше, если c это некий класс эквивалентности,
[45:19.340 --> 45:25.580]  то через лонгест от c я буду просто обозначать самое
[45:25.580 --> 45:26.940]  длинное слово в этом классе.
[45:26.940 --> 45:42.020]  Ну, а как знаем, любой класс устроен вот так.
[45:42.020 --> 45:44.700]  Это некое самое длинное слово в этом классе и несколько
[45:44.700 --> 45:45.940]  его самых длинных суффиксов.
[45:45.940 --> 45:50.020]  То есть, лонгест – это просто вот то самое слово, от которого
[45:50.020 --> 45:51.300]  мы берем суффиксы многократно.
[45:52.140 --> 46:01.380]  И еще нам будет нужна суффиксная… Сейчас, давайте длину
[46:01.380 --> 46:02.380]  сначала еще.
[46:02.380 --> 46:03.380]  LEN определим.
[46:03.380 --> 46:08.620]  LEN от c – это просто длина лонгест, число символов
[46:08.620 --> 46:15.060]  в нем длиной класса, мы будем обозначать длину самого
[46:15.060 --> 46:17.060]  длинного слова в нем.
[46:17.060 --> 46:18.900]  И последнее, мне нужна суффиксная ссылка.
[46:18.900 --> 46:29.220]  Класса c – это будет ссылка на тот класс, который содержит
[46:29.220 --> 46:32.020]  самый длинный суффикс этой строки, которая лежит
[46:32.020 --> 46:33.020]  в другом классе.
[46:33.020 --> 46:38.700]  То есть, мы знаем, что самая длинная строка и несколько
[46:38.700 --> 46:40.940]  ее самых длинных суффиксов лежат в одном классе, а
[46:40.940 --> 46:42.980]  вот если мы возьмем следующий по длине, то есть, как бы
[46:42.980 --> 46:45.060]  еще один символ откусим, возьмем следующий суффикс,
[46:45.060 --> 46:46.460]  то это будет уже другой класс.
[46:46.460 --> 46:48.300]  И вот этот класс будет ссылкой для c.
[46:48.300 --> 46:59.260]  Ну, давайте я напишу так, у равно лонгест, пусть у
[46:59.260 --> 47:05.980]  – это лонгест от c, а у штрих – это самый длинный суффикс,
[47:05.980 --> 47:15.980]  самый длинный суффикс у, лежащий в другом классе,
[47:16.980 --> 47:32.300]  c-штрих, тогда линк от c – это c-штрих, суффиксная ссылка
[47:32.300 --> 47:37.380]  от одного класса – это другой класс, содержащий самое
[47:37.380 --> 47:39.780]  длинное слово, являющегося суффиксом исходной строки
[47:39.780 --> 47:41.940]  вот этой вот лонгеста c, которая при этом все равно
[47:41.940 --> 47:42.940]  другой класс.
[47:42.940 --> 48:08.820]  Утверждение критерии лонгеста.
[48:08.820 --> 48:27.500]  Пусть у – это строка, тогда у является самым длинным
[48:27.500 --> 48:32.180]  словом в своем классе, то есть, она равна лонгесту
[48:32.180 --> 48:38.980]  от своего класса, если только если выполнено одно из двух,
[48:38.980 --> 48:48.060]  либо у – это префикс s, либо существует два различных
[48:48.060 --> 49:00.660]  символа a и b, такие что ау и бу – это подслова s, под
[49:00.660 --> 49:12.340]  строки s, значит, слово является самым длинным в своем классе,
[49:12.340 --> 49:15.460]  если только если оно либо префикс s, либо его можно
[49:15.460 --> 49:18.180]  двумя разными способами продлить налево до подстроки
[49:18.180 --> 49:21.740]  s, то есть, есть два разных символа, которые слева
[49:21.740 --> 49:23.460]  можно писать, все равно получим подстрок s.
[49:23.460 --> 49:36.820]  Так, ну первое, пусть у – это не лонгест, пусть у не
[49:36.820 --> 49:42.980]  равно лонгест от своего класса, если оно не лонгест
[49:42.980 --> 49:47.660]  в своем классе, значит, класс устроен как-то так,
[49:47.660 --> 49:50.780]  есть некое самое длинное слово отличное от у, потом
[49:50.780 --> 49:54.460]  вот его суффиксы, в какой-то момент здесь будет написано
[49:54.460 --> 50:00.780]  у, ну что это значит, значит, например, вот если я рассмотрю
[50:00.780 --> 50:05.980]  строчку длины на один побольше, какое-то там du, то раз они
[50:05.980 --> 50:07.820]  лежат в одном классе, то у них одинаковые правые
[50:07.820 --> 50:11.300]  контексты, у них одинаковое множество вхождений, и
[50:11.300 --> 50:14.460]  по сути это означает, что любое вхождение у гарантированно
[50:14.460 --> 50:20.980]  слева предваряется буквкой d, а значит, неверно, нет
[50:20.980 --> 50:21.980]  и нет.
[50:21.980 --> 50:27.740]  Начну давайте формально напишу, пусть у не лонге
[50:27.740 --> 50:35.740]  в своем классе, тогда существует d, такое, что du и u находятся
[50:35.740 --> 50:39.100]  в одном классе эквивалентности относительно нашего отношения,
[50:39.100 --> 50:43.100]  а просто мы берем вот этот вот символ, ну берем строчку
[50:43.180 --> 50:46.820]  длины на один побольше в том же классе эквивалентности,
[50:46.820 --> 50:48.380]  ну и поскольку у них в одном классе, то они обязательно
[50:48.380 --> 50:56.260]  находятся в отношении эквивалентности, значит, любое вхождение
[50:56.260 --> 51:07.980]  u в s предваряется символом d, предваряется символом
[51:07.980 --> 51:14.900]  d, ну потому что, что такое находиться в отношении
[51:14.900 --> 51:15.900]  эквивалентности?
[51:15.900 --> 51:17.980]  Значит, у них одинаковые правые контексты, то есть
[51:17.980 --> 51:21.380]  по сути это, у них совпадают множество вхождений, потому
[51:21.380 --> 51:26.180]  что любое вхождение u в s, это вот, по сути, вот эта
[51:26.180 --> 51:29.300]  вот точка такая, что с правой от нее написано вот какое-то
[51:29.300 --> 51:32.820]  окончание du суффикса, да, вот эти вот z, они по сути
[51:32.820 --> 51:35.260]  нам определяют множество вхождений, множество завершений
[51:35.260 --> 51:37.540]  вхождений, и если у этих двух слов одинаковые множество
[51:37.540 --> 51:41.260]  вхождений, то получается, что вот всюду, где есть u,
[51:41.260 --> 51:45.100]  есть также слева символ d, у них одинаковые множество
[51:45.100 --> 51:47.740]  вхождения, потому что одинаковые правые контексты, а значит
[51:47.740 --> 51:52.660]  неверно не это, не это, потому что всегда слева от u написано
[51:52.660 --> 51:58.020]  d, значит u не может быть префиксом, потому что слева кто-то есть,
[51:58.020 --> 52:00.900]  а слева от префикса никого нет, ну и при этом двумя
[52:00.900 --> 52:03.020]  различными способами продлиться влево нельзя, потому что
[52:03.020 --> 52:19.140]  всегда только d, еще раз, а что значит другая строчка
[52:19.140 --> 52:21.780]  u, вот еще раз, u это какая-то конкретно, u это какая-то
[52:21.780 --> 52:24.780]  фиксированная строка, да, вот мы ее зафиксировали
[52:24.780 --> 52:26.860]  и говорим, что она является лонгестом в своем классе,
[52:26.860 --> 52:31.780]  если только, если что-то, вот, значит мы доказали,
[52:31.780 --> 52:33.860]  что если она не лонгест, то одновременно не это
[52:33.860 --> 52:37.860]  и не это, то есть это импликация, видимо, справа налево, ну
[52:37.860 --> 52:39.980]  там, взяли контрапозицию, это получилась импликация
[52:39.980 --> 52:58.980]  справа налево, теперь слева направо, да, нет-нет, а это,
[52:58.980 --> 53:02.860]  sorry, тут я не написал, это символ алфавита, это буквы,
[53:02.860 --> 53:09.700]  да, спасибо, именно символы единичные, не строки, так,
[53:09.700 --> 53:14.260]  в обратную сторону, пусть u это лонгест в своем классе,
[53:14.260 --> 53:19.340]  лонгест в своем классе, ну и пусть, давайте для определенности
[53:19.340 --> 53:28.060]  u это не префикс s, тогда нам нужно доказать, что есть
[53:28.060 --> 53:31.000]  как минимум две различные буквы, такие, что ими можно
[53:31.000 --> 53:33.820]  предварить нашу строчку u и они обе будут под сроками
[53:33.820 --> 53:41.980]  s, ну давайте опять нарисуем этот класс эквивалентности,
[53:41.980 --> 53:46.100]  отвечающий u, здесь u будет самый длинный и вот есть
[53:46.100 --> 53:55.900]  ее несколько суффиксов, давайте нарисуем вхождение
[53:55.900 --> 54:03.620]  u в s, например, как-нибудь вот так я нарисую несколько
[54:03.620 --> 54:06.940]  вхождений, ни одно из этих вхождений не является
[54:06.940 --> 54:10.220]  префиксом s, да, то есть вот здесь никто не начинается,
[54:10.220 --> 54:12.900]  поэтому я могу посмотреть на символы, предшествующие
[54:12.900 --> 54:15.740]  всем этим вхождением, мне нужно доказать, что среди
[54:15.740 --> 54:19.460]  них не все одинаковые, мне нужно доказать, что среди
[54:19.460 --> 54:23.380]  вот этих символов, предшествующих всем вхождением u, есть хотя
[54:23.380 --> 54:26.500]  бы два разные, тогда мы как раз докажем, что есть два
[54:26.500 --> 54:28.700]  разных символа, такие, что влево можно продолжить
[54:28.700 --> 54:33.160]  наше слово u, но если они все одинаковые, то на самом
[54:33.160 --> 54:37.180]  деле это слово должно было быть в том же классе, давайте
[54:37.180 --> 54:52.500]  здесь напишу, да, рассмотрим, рассмотрим символы, предшествующие
[54:52.500 --> 55:01.020]  всем вхождением u, всем вхождением u, если они все одинаковые
[55:01.020 --> 55:10.780]  вдруг, если они все одинаковые, то картинка такая, в тюду
[55:10.780 --> 55:14.540]  перед u располагается один и тот же самый символ, скажем
[55:14.540 --> 55:19.380]  c, вот здесь c, здесь c и здесь c, ну тогда понятно, что u
[55:19.380 --> 55:21.700]  и cu имеют один и тот же правый контекст, потому что у них
[55:21.700 --> 55:28.780]  одинаково множество вхождений, то u находится в отношении
[55:28.780 --> 55:31.380]  эквивалентности со словом cu, потому что у них одинаково
[55:31.380 --> 55:35.260]  множество вхождений, противоречие с тем, что u это длинное, самое
[55:35.260 --> 55:53.820]  длинное в всем классе, значит они не могли быть все одинаковые
[55:53.820 --> 55:56.540]  и среди вот этих вот символов хотя бы два различные, скажем
[55:56.540 --> 56:00.420]  есть какой-то c, есть какой-то d, победа, значит вот это вот
[56:00.420 --> 56:26.140]  верно. Вопросы? Так, хорошо, значит и вот это вот
[56:26.860 --> 56:29.060]  полезный критерий longest, он будет у нас на самом деле
[56:29.060 --> 56:32.980]  база нашего алгоритма, давайте мы его немножко начнем ждать,
[56:32.980 --> 56:41.260]  алгоритм построения. Значит он будет немножечко, немножечко
[56:41.260 --> 56:44.420]  самая малость напоминать алгоритм построения сувдерева,
[56:44.420 --> 56:47.540]  а именно тем, что во-первых он будет такой же ингриментальный,
[56:47.540 --> 56:50.180]  то есть по одному символу дополнять нашу строчку,
[56:50.180 --> 56:52.820]  как бы читать по одному символу строки s и перестраивать
[56:52.820 --> 56:58.700]  автомат. То есть если у нас была строка s и для нее построен
[56:58.700 --> 57:01.980]  суффиксный автомат, то мы читаем новый символ, перестраиваем
[57:01.980 --> 57:07.980]  автомат, дописав справа, докинув справа в конец новый
[57:07.980 --> 57:10.820]  символ c, также как в суффиксном деле мы читаем по одному
[57:10.820 --> 57:12.700]  символу и перестраиваем нашу структуру на ходу.
[57:12.700 --> 57:18.660]  Назваемый ингриментальный подход. То есть не то, что мы
[57:18.660 --> 57:21.300]  прочитали один раз строчку, если сразу все построили, а скорее
[57:21.420 --> 57:31.980]  так по одному символу перестраиваем. Ну и второе сходство, что ли, в том,
[57:31.980 --> 57:36.340]  что мы тоже пока не следим за терминальностью. Если вы помните,
[57:36.340 --> 57:39.780]  как работает алгоритм Уканина, он сначала все делает, сначала все
[57:39.780 --> 57:44.460]  строит, проводит все ребра, все вершинки строит и только в самом
[57:44.460 --> 57:47.940]  конце помечает терминальными вершины, которые, получается,
[57:48.020 --> 57:51.540]  со всылками от самого длинного слова. Сначала все построил, потом
[57:51.540 --> 57:55.780]  прошелся по мете вершины терминальными. Также и здесь, до самого конца алгоритма,
[57:55.780 --> 58:06.500]  до самого конца алгоритма, не заботимся о терминальности,
[58:06.500 --> 58:19.500]  потому что в конце, если мы правильно построим все вершины, все переходы, то
[58:19.500 --> 58:22.540]  по мете терминальность будет очень просто. Нужно будет всего лишь найти класс
[58:22.540 --> 58:26.780]  эквивалентности строки S. Это будет обязательно некая вершина,
[58:26.780 --> 58:32.940]  отвечающая, она будет обязательно терминальной, потому что в ней содержится суффикс.
[58:32.940 --> 58:41.260]  Ну а дальше мы знаем, что такое класс эквивалентности этой вершинки. Это S и
[58:41.260 --> 58:44.780]  несколько ее самых длинных суффиксов, то есть все они тоже будут терминальными,
[58:44.780 --> 58:49.140]  все хорошо. Дальше следующий суффикс, не попадающий в тот же класс
[58:49.140 --> 58:54.540]  эквивалентности, достигается по линке, по сувсылке. То есть все вот эти мы уже
[58:54.540 --> 58:58.380]  отметили терминальными, потому что они в одной вершине лежат, а следующее мы
[58:58.380 --> 59:02.060]  должны взять сувсылку у этой вершинки и пометить терминальными их, потому что
[59:02.060 --> 59:05.380]  они лежат в следующем классе, но это как бы следующих суффиксов. Дальше мы их
[59:05.380 --> 59:11.780]  пометим, то есть мы прыгнули по сувсылке, пометили терминальными, потом опять у нас
[59:11.780 --> 59:15.460]  есть следующий суффикс, лежащий в другом классе, он достигается просто по
[59:15.460 --> 59:19.420]  сувсылке. Мы помечаем эту вершину терминальной и так далее.
[59:19.420 --> 59:23.060]  То есть ровно так же, как в сувдереве, мы сначала все построили, потом встали в
[59:23.060 --> 59:27.460]  самую длинную точку, в самую длинную вершину, отвечающую всей строке, и просто
[59:27.460 --> 59:34.580]  по сувсылкам прыгаем, помечаем все терминальные. Вот, на этом сходство
[59:34.580 --> 59:37.380]  заканчивается.
[59:45.860 --> 59:50.740]  Теперь мы будем рассуждать в терминах лонгестов, потому что, смотрите, вот что
[59:50.740 --> 59:56.140]  происходит, когда дописывается символ С. У нас как-то по сути меняются все классы
[59:56.140 --> 59:59.580]  эквивалентности. Вот у нас поменялась строка, у нас, соответственно, поменялось даже
[59:59.580 --> 01:00:03.540]  отношение эквивалентности. Если раньше нам нужны были суффиксы С, то теперь это
[01:00:03.540 --> 01:00:10.140]  суффиксы СС. У нас все поменялось. И по сути, наша весь автомат должен как-то
[01:00:10.140 --> 01:00:14.140]  перестроиться, с учетом того, что классы как-то изменились. Но, смотрите, у нас есть
[01:00:14.140 --> 01:00:18.740]  удобное на самом деле представление классов через лонгесты, потому что если
[01:00:18.740 --> 01:00:21.820]  нам известны только лонгесты от всех классов, то мы на самом деле все классы
[01:00:21.820 --> 01:00:30.140]  тоже можем легко восстановить. Классы эквивалентности, они легко восстанавливаются
[01:00:30.140 --> 01:00:36.780]  через все лонгесты. То есть, например, если вместо разбиения на классы нам
[01:00:36.780 --> 01:00:40.780]  известны только лонгесты, то мы на самом деле все классы тоже можем восстановить.
[01:00:40.780 --> 01:00:44.740]  Потому что вот мы берем некие, скажем, два лонгеста, и если мы видим, что один
[01:00:44.740 --> 01:00:49.380]  это суффикс другого, и между ними никого нет, то значит все, что между ними, это
[01:00:49.380 --> 01:00:53.860]  один класс, но все, что ниже, опять до следующего лонгеста, лежащего в другом
[01:00:53.860 --> 01:00:58.380]  классе, это другой класс. То есть, по сути, чтобы восстановить разбиение на
[01:00:58.380 --> 01:01:02.260]  классы, нам нужны только лонгесты. Потому что я рассматриваю все пары
[01:01:02.260 --> 01:01:06.020]  лонгестов таких, что один это суффикс другого, они, соответственно, лежат в разных
[01:01:06.020 --> 01:01:11.420]  классах, и все, что между ними, это один класс. Поэтому вместо того, чтобы
[01:01:11.420 --> 01:01:15.060]  заботиться о том, как именно устроены классы эквивалентности, мы будем следить
[01:01:15.060 --> 01:01:19.140]  за строчками, которые являются лонгестами. И все вот эти вот лонгесты, благо, у нас
[01:01:19.140 --> 01:01:22.980]  есть как раз критерии лонгеста, чтобы понимать, что с ними происходит. А, если уж
[01:01:22.980 --> 01:01:26.820]  мы знаем лонгесты, то все классы мы тоже восстановим. Потому что, как бы, ну,
[01:01:26.820 --> 01:01:31.180]  предельные элементы в своих классах, зная предельные элементы, мы восстановим все
[01:01:31.180 --> 01:01:45.420]  все классы сами себе. Еще раз? Ну, смотрите, так, v это суффикс u, то есть, вот все вот
[01:01:45.420 --> 01:01:51.300]  эти прямоугольники, это лонгесты, и v это суффикс u, такой, что между ними нет
[01:01:51.300 --> 01:01:57.740]  других лонгестов. То есть, грубо говоря, я рассматриваю все пары лонгестов, если
[01:01:57.740 --> 01:02:02.660]  один это суффикс другого, и больше никто не является суффиксом этого, более
[01:02:02.660 --> 01:02:06.980]  длинным, тогда все, что между ними, это один класс.
[01:02:09.100 --> 01:02:13.180]  Ну да, да, да, да. То есть, мы взяли какую-то произвольную, произвольную строчку u,
[01:02:13.180 --> 01:02:18.340]  являющуюся лонгестом, осмотрели все суффиксы, упорядочили по длине, и вот у
[01:02:18.340 --> 01:02:23.180]  нас получилось такое разъединение на классы. Да, можно так сказать. Значит,
[01:02:23.180 --> 01:02:27.260]  мораль. Вместо того, чтобы следить за классом, будем следить за лонгестами.
[01:02:27.260 --> 01:02:37.340]  Вот вопрос, что происходит с лонгестами, что происходит с лонгестами при
[01:02:37.340 --> 01:02:51.660]  переходе вот s к sc. Вот s к sc. А у нас есть критерии лонгеста. Что лонгесты это
[01:02:51.660 --> 01:02:56.020]  либо префиксы, либо расширяющиеся влево разными способами, как минимум двумя
[01:02:56.020 --> 01:03:01.140]  способами. Первое важное замечание, что если строка когда-то была лонгестом, то
[01:03:01.140 --> 01:03:05.260]  она лонгестом останется. Потому что, если она была префиксом s, то она остается
[01:03:05.260 --> 01:03:10.180]  префиксом sc. Если она предварялась влево двумя разными буквами a и b в строке
[01:03:10.180 --> 01:03:14.860]  s, то в строке sc происходит то же самое. Все, что слева, оно не меняется. Поэтому
[01:03:14.860 --> 01:03:24.500]  первое важное замечание, что если у была лонгестом, если у была лонгестом в s, то она остается
[01:03:24.500 --> 01:03:43.340]  лонгестом в sc. Остается лонгестом в sc по критериям. Потому что в обоих случаях,
[01:03:43.340 --> 01:03:50.100]  будь у префиксом s или имея оно два разных продолжения влево, дописывание c в
[01:03:50.100 --> 01:03:56.740]  конец строки s ничего не меняет. То есть все, что раньше было лонгестами, остается. То есть
[01:03:56.740 --> 01:04:00.980]  единственное, что может происходить, это только появляться некие новые лонгесты. Никто пропадает,
[01:04:00.980 --> 01:04:06.260]  никто переставать быть лонгестом не может. Могут только появляться новые. Так, критерии я оставлю.
[01:04:06.260 --> 01:04:30.340]  Могут только появляться новые лонгесты. Вопрос, какой лонгест гарантированно появится новый?
[01:04:30.340 --> 01:04:49.620]  Еще раз? Да, sc. Гарантированно, sc это новый лонгест. Просто потому, что раньше это не было строкой в
[01:04:49.620 --> 01:04:56.820]  s, это не было под строкой s. А теперь оно становится под строкой всей большой строки sc. И оно, конечно,
[01:04:56.820 --> 01:05:04.100]  лонгест, просто потому, что нет вообще никакой строки длиннее, чем это. Давайте прописывать не
[01:05:04.100 --> 01:05:08.180]  буду еще раз, почему это точно новый лонгест. Раньше это не было лонгестом, потому что это даже
[01:05:08.180 --> 01:05:12.460]  под строкой не было. Ее раньше вообще в автомате нельзя было прочитать, потому что она длиннее,
[01:05:12.460 --> 01:05:18.740]  чем s. С другой стороны, теперь это лонгест, потому что она теперь самая длинная. Теперь длиннее
[01:05:18.740 --> 01:05:27.220]  нее никого нет. Есть какой-то у него класс, она там точно самая длинная. Ну давайте попробуем понять,
[01:05:27.220 --> 01:05:40.900]  чему равен… ну давайте я вот так вот буду писать. Нет, не так, не так, не так. Да. Значит,
[01:05:40.900 --> 01:05:53.540]  правый контекст относительно слова sc у слова sc равен epsilon. Потому что если у нас есть слово
[01:05:53.540 --> 01:05:59.060]  sc, то единственный способ дополнить его до суффикса sc это написать пустую строчку, ничего не написать.
[01:05:59.060 --> 01:06:08.580]  Вот. Соответственно, в классе sc относительно вот этой нашей новой строки sc, то есть относительно
[01:06:08.580 --> 01:06:13.980]  нового отношения эквивалентности. У нас лежат все такие строки, единственное дополнение которых до
[01:06:13.980 --> 01:06:24.980]  конца это epsilon. То есть это гарантировано точно суффикс sc, суффикс sc, которые раньше не имели
[01:06:24.980 --> 01:06:43.380]  вхождения в s, не имели вхождений в s, которые не имеют вхождений в s. Ну почему-то суффикс sc
[01:06:43.380 --> 01:06:48.500]  понятно, потому что у них в правом контексте есть epsilon. Почему они не имели вхождений в s? Ну
[01:06:48.500 --> 01:06:54.180]  потому что если бы они где-то входили в s, давайте нарисую, было s, стало sc, если бы они где-то здесь
[01:06:54.180 --> 01:07:00.620]  входили, то у них бы в правом контексте было бы еще вот это, какая-то не пустая строка, а мы рассматриваем
[01:07:00.620 --> 01:07:04.180]  только класс этой строки, то есть только те слова, у которых правый контекст состоит только из
[01:07:04.180 --> 01:07:10.820]  epsilon. Значит ничего, никаких больше вхождений было не могло. Ну и наоборот, если слово удовлетворяет вот
[01:07:10.820 --> 01:07:15.380]  этим вот обоим условиям, то есть у нас с одной стороны суффикс sc с другой стороны раньше не входило,
[01:07:15.380 --> 01:07:21.140]  то есть это слово обязательно вот такого вот вида, да, и больше нигде его раньше не было, то
[01:07:21.140 --> 01:07:25.140]  гарантированно правый контекст этой строки только epsilon, потому что если бы там было что-то еще,
[01:07:25.140 --> 01:07:31.500]  то гарантированно должно было быть вхождение левее, а его нет. Вот, то есть мы точно поняли,
[01:07:31.500 --> 01:07:36.180]  что появляется новый лонгест, и мы знаем, как выглядит, то есть мы характеризовали его класс.
[01:07:36.180 --> 01:07:41.500]  Это все суффиксы sc, которых раньше не было, то есть это как бы новые подстроки, те кого раньше
[01:07:41.500 --> 01:07:46.140]  не было. Это вот все sc и несколько опять-таки самых длинных суффиксов, такие, что вот все они не
[01:07:46.140 --> 01:07:50.260]  имели вхождение в s, а вот уже предыдущие, скажем, имеют вхождение.
[01:07:50.260 --> 01:08:09.060]  Теперь вопрос, мог ли стать лонгестом кто-то еще? Кто еще мог стать лонгестом?
[01:08:09.060 --> 01:08:27.100]  Ну пусть некая t, пусть t. Значит, давайте смотреть на критерий, критерий лонгеста. То есть у нас раньше
[01:08:27.100 --> 01:08:35.020]  была некая строка t, она уже не могла быть не под строкой s, то есть она обязательно была под строкой
[01:08:35.020 --> 01:08:40.060]  s, потому что все не под строки, мы уже вот здесь вот расположили, все не под строки s уже лежат в
[01:08:40.060 --> 01:08:45.380]  этом классе коверенности, а все не под строки, они имеют пустой, ну как бы только, эпсилон в правом
[01:08:45.380 --> 01:08:49.700]  контексте. Значит, t раньше была под строкой, но при этом не было лонгестом, то есть t это какая-то
[01:08:49.700 --> 01:08:55.780]  подстрока, не являвшаяся раньше лонгестом, но ставшая теперь лонгестом. А раз она раньше не являлась
[01:08:55.780 --> 01:09:02.340]  лонгестом, то она не префикс s и не имела двух продолжений влево, а теперь как бы либо стала
[01:09:02.340 --> 01:09:13.060]  префиксом sc, либо имеет два продолжения влево в строке sc. Давайте это запишем. Пусть это t,
[01:09:13.060 --> 01:09:39.660]  t имела вхождение в s, так как все не имевшие вхождений лежат в классе sc, в отвечающем
[01:09:39.660 --> 01:10:06.180]  все строке. Значит, t не была лонгестом в s, но стала лонгестом в sc. Еще раз.
[01:10:09.660 --> 01:10:27.380]  Почему все слова не имевшие вхождение в s теперь находятся в этом классе? Так,
[01:10:27.380 --> 01:10:31.260]  комментарий не помню, давайте я на вопрос отвечу. Еще раз, почему вот это верно, почему все не
[01:10:31.260 --> 01:10:37.100]  имевшие вхождение в s лежат в классе, отвечающем sc? Что такое слово не имевшее вхождение в s,
[01:10:37.100 --> 01:10:43.540]  но теперь рассматриваемое, то есть это раньше было не под строка, теперь под строка. Ну,
[01:10:43.540 --> 01:10:47.940]  потому что не под строки sc мы не рассматриваем, они как бы нам не интересно, отвечают отдельному
[01:10:47.940 --> 01:10:54.340]  состоянию, который мы не строим. То есть была строка не имевшая вхождение в s, но теперь получившая
[01:10:54.340 --> 01:10:59.540]  вхождение в sc, значит обязательно суффикс, потому что новое вхождение только суффикс sc, больше
[01:10:59.540 --> 01:11:05.300]  никаких вхождений не появилось. Итого у нас была строка не входившая сюда, но теперь получившая
[01:11:05.300 --> 01:11:11.180]  вхождение в sc. То есть обязательно какой-то суффикс, что-то такое. Но все суффиксы sc не
[01:11:11.180 --> 01:11:16.820]  имевшие вхождение в s, вот оно мы знаем, мы уже это обсуждали, что это в точности класс эквивалентности
[01:11:16.820 --> 01:11:29.780]  строки sc. Нет, в обе, в обе, в обе. То есть еще раз, да, ну давайте здесь проговорю. Вот я рассматриваю sc,
[01:11:29.780 --> 01:11:34.700]  я понимаю, что у нее правый контекст, это только эпсилон. С одной стороны, строки лежащие здесь,
[01:11:34.700 --> 01:11:40.100]  строки лежащие здесь, это обязательно суффикс sc, потому что у них есть правый контекст эпсилон.
[01:11:40.100 --> 01:11:43.460]  С другой стороны, раньше не входили, потому что если бы не входили, у них бы кто-то был еще,
[01:11:43.460 --> 01:11:48.140]  да, то есть если бы было здесь, то можно было бы дополнить чем-то еще. Теперь наоборот, пусть строка
[01:11:48.140 --> 01:11:52.260]  вот такая, почему она лежит в этом классе, то есть почему у нее такой правый контекст. Но если она
[01:11:52.260 --> 01:11:58.660]  суффикс sc, то у нее точно есть эпсилон в правом контексте, а если она не имела вхождение в s,
[01:11:58.660 --> 01:12:04.740]  то ничто другое не могло быть в правом контексте. То есть это критерия, могу здесь равенство написать.
[01:12:04.740 --> 01:12:19.100]  Вот, значит t не было лонгестом в s, но теперь стало в sc. Ну что это значит? Это значит, что раньше,
[01:12:19.100 --> 01:12:24.580]  ну конечно, что оно как бы в частности не было префиксом, поэтому этот случай исключается.
[01:12:24.580 --> 01:12:28.960]  Значит, раньше любое вхождение t в s предваряется одним и тем же символом,
[01:12:28.960 --> 01:12:45.340]  любое вхождение t в s предваряется одним и тем же символом, скажем, x. Предваряется одним и тем
[01:12:45.340 --> 01:13:05.540]  же символом x. Сюда, где sc, слева написано x. А дальше, я дописываю c в конец, и внезапно t пересовывает
[01:13:05.540 --> 01:13:10.580]  лонгестом, то есть внезапно появляется как минимум два разных символа, которые предваряют t в
[01:13:10.580 --> 01:13:17.020]  нашей строке sc. Ну тогда гарантированно t получил новое вхождение вот здесь вот. Такое,
[01:13:17.020 --> 01:13:23.660]  что тут не x. Потому что раньше все вхождения обязательно предварялись x, а теперь это не так,
[01:13:23.660 --> 01:13:27.620]  то есть появился какой-то еще символ. Но единственное новое вхождение, которое t могло
[01:13:27.620 --> 01:13:33.300]  получить, вот оно, это суффикс. Все новые вхождения только суффиксы. Только вот эти строки получили
[01:13:33.300 --> 01:13:40.620]  новое вхождение. Значит, обязательно t это суффикс sc, перед которым написан не x. Вот оно t,
[01:13:40.620 --> 01:13:48.500]  и здесь написан некий y отличный от x. Чтобы ему стать лонгестом, обязательно появилось новое
[01:13:48.500 --> 01:13:58.260]  вхождение, предваряемое другим символом. Так, значит, давайте это запишем. В sc появляется
[01:13:58.260 --> 01:14:21.740]  появляется новое вхождение строки t, предваряемое другим символом, другим символом y не равно x.
[01:14:21.740 --> 01:14:31.380]  Просто чтобы выполнился критерий лонгеста. Значит, смотрите, мы поняли, что если у нас есть еще
[01:14:31.380 --> 01:14:36.980]  какой-то новый лонгест, отличный от sc, если кто-то еще стал лонгестом, вот если это t стал тоже
[01:14:36.980 --> 01:14:42.980]  лонгестом, то для него верно следующее. Это суффикс строки sc, потому что только суффиксы получили
[01:14:42.980 --> 01:14:49.860]  новое вхождение. Это суффикс строки sc такой, что если его на один символ расширить, то это же
[01:14:49.860 --> 01:15:03.540]  будет не под строка s. Итак, t это, на чему можно характеризовать так, самый длинный
[01:15:03.540 --> 01:15:18.500]  суффикс sc, являющийся, являющийся под строкой s.
[01:15:18.500 --> 01:15:33.540]  Потому что если я возьму суффикс длины на один побольше, то получу уже yt, а yt раньше нигде не
[01:15:33.540 --> 01:15:41.900]  входил, потому что всегда было только xt. Тем самым мы получили следующее, что если хотя бы еще
[01:15:41.900 --> 01:15:46.300]  один лонгест появился, то есть если t это еще какой-то новый лонгест, то он обязательно
[01:15:46.300 --> 01:15:55.820]  ретрируется ровно вот так. Это самый длинный суффикс строки sc, который также входил в s. Такая строка,
[01:15:55.820 --> 01:15:59.260]  которая получила новое вхождение, но и раньше тоже имела вхождение, потому что более длинные
[01:15:59.260 --> 01:16:08.500]  суффиксы, все более длинные, содержат в конце yt, а yt раньше никуда не входил. Тем самым мы показали,
[01:16:08.500 --> 01:16:14.220]  что если новый лонгест есть, максимум один. Вот он, потому что такая строка, она единственна.
[01:16:14.220 --> 01:16:20.620]  На самый длинный суффикс sc являешься по строкой s, но это просто какая-то конкретная строка,
[01:16:20.620 --> 01:16:27.860]  потому что все суффиксы sc, начиная с максимальной длины, вот эти вот все суффиксы, лежащие в этом
[01:16:27.860 --> 01:16:34.460]  классе, они не имели вхождения в s, а потом следующие как бы в другом классе, меньше длины,
[01:16:34.460 --> 01:16:40.140]  длины на один поменьше, уже по-прежнему являются суффиксом sc, но имеют хотя бы одно вхождение в s.
[01:16:40.140 --> 01:16:45.860]  И вот это вот самая t, единственный кандидат на новый лонгест. Из всего, что мы здесь делали,
[01:16:45.860 --> 01:16:47.900]  мы поняли, что лонгест обязательно обладает таким свойством.
[01:16:47.900 --> 01:17:05.420]  Нет-нет, классов не обязательно n-1. Ну вот, если вы рисовали картинку,
[01:17:05.540 --> 01:17:14.820]  когда там для ab-ab рисовал, там было пять классов, кажется. Да, а n-то кто еще у нас? Я думал,
[01:17:14.820 --> 01:17:22.700]  это n-то длина, я думал. Число класса эквивалентности с длиной мы пока не можем соотнести.
[01:17:22.700 --> 01:17:32.420]  Еще раз.
[01:17:32.420 --> 01:17:44.620]  Да-да-да, сейчас понял. Почему не мог кто-то более короткий стать?
[01:17:44.620 --> 01:17:51.660]  Так, момент.
[01:17:51.980 --> 01:17:57.500]  Вот.
[01:18:04.260 --> 01:18:05.020] u- undo.
[01:18:21.660 --> 01:18:36.420]  ну еще раз смотрите почему то есть окей вот мы рассмотрим пусть это какой-то
[01:18:36.420 --> 01:18:43.020]  новый лонгест почему он обязательно вот такой ну это ответить на вас на ваш
[01:18:43.020 --> 01:18:46.380]  вопрос то есть мы уже поняли что он точно суффикс сс вот я его нарисовал
[01:18:46.380 --> 01:18:50.580]  суффикс сс являешься по строкой с это мы все доказали почему самый длинный
[01:18:50.580 --> 01:18:56.460]  почему он самый длинный ну потому что мне нужно чтобы перед ним вот был именно
[01:18:56.460 --> 01:19:02.060]  этот y отрисован всех предыдущих х слов а как бы а меньше они ну они вот имеют
[01:19:02.060 --> 01:19:07.020]  здесь как бы те же вхождения и у них ну собственно то что написано здесь оно
[01:19:07.060 --> 01:19:10.420]  оно такое же грубо говоря еще раз
[01:19:10.420 --> 01:19:21.900]  да да сейчас сейчас сейчас сейчас сейчас
[01:19:37.020 --> 01:19:53.940]  смотрите все что все что было другое да то есть мы более короткий рассмотрим и вот
[01:19:53.940 --> 01:20:02.820]  здесь скажем еще то но оно оно и так оно либо раньше было лонгестом либо не станет
[01:20:02.820 --> 01:20:06.060]  лонгестом и теперь потому что если вот эти символы различные то оно и так было
[01:20:06.060 --> 01:20:11.220]  лонгестом а если все эти символы одинаково этот другой то извините почему тогда это суффикс
[01:20:11.220 --> 01:20:17.260]  вот этого потому что любое да то есть эти все одинаковые а это какой-то другой но такого
[01:20:17.260 --> 01:20:23.500]  быть не может потому что вот это окончание вот этого также как вот здесь вот то есть он
[01:20:23.500 --> 01:20:39.700]  обязательно именно самый длинный так хорошо да ну давайте тогда видим и последнее утверждение
[01:20:39.700 --> 01:20:53.900]  попробуем доказать быстренько утверждение об устройстве ребер ведущих вершину в
[01:20:53.900 --> 01:21:10.940]  утверждение такое я его на картиночке сформулирую пусть есть некая вот пусть есть у нас суффикс на
[01:21:10.940 --> 01:21:15.700]  автомат для какой-то строки есть некая вершина в нем давайте рассмотрим все входящие ребра в эту
[01:21:15.700 --> 01:21:21.300]  вершину все входящие ребра я утверждаю что во-первых на них на всех написано одна и та же буква
[01:21:21.300 --> 01:21:31.100]  во-вторых если я упорядочу их в порядке убывания лен да то есть параке убывание длины лонгеста то
[01:21:31.100 --> 01:21:42.140]  они друг на друга ссылаются по суффсылкам то есть иными словами если выфиксировано то множество
[01:21:42.140 --> 01:21:48.140]  вершин имеющих ребров эту вершину во-первых на этих ребрах написано одинаковая буква во-вторых
[01:21:48.140 --> 01:21:53.260]  эти вершины образуют как бы часть суффиксного пути часть пути по суффсылкам какая-то самая
[01:21:53.260 --> 01:22:01.380]  длинная потом линк покороче линк покороче и так далее доказательства но давайте нарисуем класс
[01:22:01.380 --> 01:22:17.340]  эквивалентности для вы поскольку это самая длинная строка и все ее суффиксы то они конечно
[01:22:17.340 --> 01:22:24.100]  заканчивается на одну и ту же букву как пусть какой-то ц здесь не может пустой строки потому
[01:22:24.100 --> 01:22:28.940]  что пустая строка это только корень но отдельная вершина соответственно и в нее не может вести
[01:22:28.940 --> 01:22:36.140]  никаких ребер поэтому это все не пустые слова у них у всех одинаковый последний символ ну а дальше
[01:22:36.140 --> 01:22:40.300]  раз мы знаем что вот это вот буква это по сути просто приписывание ко всем словам отсюда некоторые
[01:22:40.300 --> 01:22:45.660]  одной буковки в конец то получается что только вот вот на этом последнем месте она может быть
[01:22:45.660 --> 01:22:50.580]  да значит все ребра ведущие сюда обязательно имеют ту же самую последнюю ну как бы на них
[01:22:50.580 --> 01:22:58.180]  написано та же самая последняя буква ц вот дальше почему это путь по суффсылкам потому что
[01:22:58.180 --> 01:23:04.100]  каждая вершина это некий отрезок слов ну отрезок длин слов вот мы к ним ко всем взяли приписали
[01:23:04.100 --> 01:23:08.580]  ц в конец то есть скажем вот это вот после приписывания ц переходят вот сюда например вот
[01:23:08.580 --> 01:23:14.140]  эти вот три слова это вот они после приписывания ц дальше здесь там были несколько слов более
[01:23:14.140 --> 01:23:20.700]  длинные опять я к ним ко всем приписал ц и попал в этот класс то есть опять здесь я заметаю некий
[01:23:20.700 --> 01:23:31.020]  отрезок заметаю некий отрезок слов в этом в этом в этом классе ну и соответственно поскольку я знаю
[01:23:31.020 --> 01:23:34.900]  что каждая вершина это некий отрезок длин то здесь тоже заметается отрезок длин после
[01:23:34.900 --> 01:23:41.180]  дописывания одной буквы и если я рассмотрел здесь все ребра то получается я покрыл обязательно
[01:23:41.260 --> 01:23:45.500]  слова по одному разу и тем самым у меня весь вот этот класс большой отвечающий вешенки в
[01:23:45.500 --> 01:23:52.400]  он разбился на несколько групп но я вот так нарисую как-нибудь он разбивается на несколько
[01:23:52.400 --> 01:23:57.840]  групп так что скажем последняя группа отвечает всем вот этим словам после дописывания ц дальше
[01:23:57.840 --> 01:24:07.520]  следующая группа отвечает всем словам после даже этого ц ну это отвечает вот это так
[01:24:11.180 --> 01:24:15.640]  Ну и все, собственно, давайте рассмотрим самое длинное,
[01:24:15.640 --> 01:24:18.660]  вот этот самый блок, отвечающий самым длинным словом, это
[01:24:18.660 --> 01:24:20.740]  некое самое длинное слово, несколько его самых длинных
[01:24:20.740 --> 01:24:21.740]  суффиксов.
[01:24:21.740 --> 01:24:24.220]  Если я отбрасывать них в C, то я получаю вот этот,
[01:24:24.220 --> 01:24:25.220]  скажем, первый класс.
[01:24:25.220 --> 01:24:28.100]  Потом я отбросил еще один первый символ, пришел
[01:24:28.100 --> 01:24:31.060]  к другому классу, к другой группе, которая отвечает
[01:24:31.060 --> 01:24:32.060]  в следующей вершинке.
[01:24:32.060 --> 01:24:35.140]  Соответственно, вот отбрасывание первого символа здесь переводит
[01:24:35.140 --> 01:24:39.420]  меня в эту группу, внутри вершинки В, и в другую вершину
[01:24:39.420 --> 01:24:40.420]  на этом пути.
[01:24:40.900 --> 01:24:43.540]  То есть я понимаю, что отбрасывание первого символа здесь – это
[01:24:43.540 --> 01:24:45.980]  с одной стороны перевод в другую группу в вершинке
[01:24:45.980 --> 01:24:50.020]  В, с другой стороны, в терминах вот этих вершинок, которые
[01:24:50.020 --> 01:24:53.420]  имеют входящее ребро, это просто переход по суффссылке,
[01:24:53.420 --> 01:24:56.380]  потому что я отбросил одну вершину, одно слово, извините,
[01:24:56.380 --> 01:24:59.020]  одну букву, перешел в новый класс, в новую вершинку.
[01:24:59.020 --> 01:25:01.620]  Ну значит, то, что отвечала та вершина, которая отвечает
[01:25:01.620 --> 01:25:04.660]  вот этому первому блоку, будет ссылаться по суффссылке
[01:25:04.660 --> 01:25:06.300]  на вершину, отвечающую второму блоку.
[01:25:06.300 --> 01:25:08.420]  То же самое здесь, отбрасываю первый символ, попадаю в
[01:25:08.420 --> 01:25:11.340]  третью, вот здесь отбрось, вал в третью группу, значит,
[01:25:11.340 --> 01:25:12.340]  здесь идет такая суффссылка.
[01:25:12.340 --> 01:25:16.460]  Вроде все, спасибо.
