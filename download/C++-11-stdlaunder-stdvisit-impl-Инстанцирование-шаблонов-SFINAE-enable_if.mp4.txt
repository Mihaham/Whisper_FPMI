[00:00.000 --> 00:17.840]  Включаем запись. Сегодня мы закончим обсуждать проблемы, связанные с вариантом. И перейдем к
[00:17.840 --> 00:26.560]  следующей и предпоследней теме. К шаблонному метапрограммированию. В прошлый раз мы остановились
[00:26.560 --> 00:35.560]  на том, что мы почти поняли, как реализован STD variant. Ну, вообще, как STD variant реализован,
[00:35.560 --> 00:43.760]  мы даже, можно сказать, поняли до конца. Но у нас остались некоторые моменты, о которых мы не
[00:43.760 --> 00:52.920]  подумали, из-за которых все может сломаться. Ну, там какой-нибудь оператор присваивания варианта,
[00:52.920 --> 00:59.320]  какой-нибудь там всякие конвертирующие конструкторы. Это вы сами догадаетесь,
[00:59.320 --> 01:09.600]  как написать, я думаю. Как, кстати, 14-й параграф называется? 14-я глава. Она называлась, если мне не
[01:09.600 --> 01:21.480]  изменяет память, unions и type erasure. Ну, в каком-то смысле type erasure and unions. Значит type erasure мы
[01:21.480 --> 01:27.680]  обсуждали, когда говорили про any, а потом про shared ptr, а потом про function. А потом мы сказали,
[01:27.680 --> 01:33.360]  что у нас есть unions, а есть вариант, который на самом деле велится type safe unions. Штука,
[01:33.360 --> 01:38.720]  которая умеет хранить разные типы в runtime и безопасно, скажем так, подменять один другим.
[01:38.720 --> 01:47.400]  Вот, значит, у нас, ну, напомню, что у нас в прошлый раз был вот такой класс вариант. Мы
[01:47.400 --> 01:52.800]  тут обсуждали, как правильно реализовать его конструктор с помощью вот такой конструкции,
[01:52.800 --> 01:59.240]  как правильно, значит, сделать наследование отчего, чтобы все это работало без ub,
[01:59.240 --> 02:05.840]  как сделать destructor мы обсудили, обсудили функцию get, даже успели еще что-то обсудить. Вот,
[02:05.840 --> 02:14.800]  но в конце я вам сделал такой спойлер и тизер на этот раз. И на самом деле я тогда вам сказал
[02:14.800 --> 02:23.240]  неправду, сейчас я буду исправляться. На самом деле вот то, что я говорил последние пять минут,
[02:23.240 --> 02:29.520]  последний раз было не совсем правильной формулировкой. У нас есть одна проблема,
[02:29.520 --> 02:35.680]  о которой невозможно догадаться, если о ней не знать, и проблема начинается тогда, когда мы
[02:35.680 --> 02:44.320]  пытаемся на указатель, под которым лежал один тип, положить другой тип, и при этом продолжаем
[02:44.320 --> 02:51.160]  обращаться по старому указателю. Ну да. Вот, это некоторая абсолютно неочевидная вещь,
[02:51.160 --> 02:57.880]  и такое даже казалось бы, ну это в голову не могло прийти, что тут может быть какая-то
[02:57.880 --> 03:05.360]  проблема, если об этом специально не поговорить, то даже и не подумать, что здесь какие-то проблемы
[03:05.360 --> 03:15.440]  могут быть. На самом деле такое вызывает УБ, и вот в связи с чем. Я вам приготовил один пример,
[03:15.440 --> 03:24.160]  который называется Divertualize. Давайте посмотрим вот на такой код. Вот, чтобы проиллюстрировать
[03:24.160 --> 03:35.000]  проблему. Это будет пункт 14-8, я под это не поленюсь отдельный пункт завести. Я даже не знаю,
[03:35.000 --> 03:47.840]  как назвать эту проблему. Ну давайте я просто... Давайте я назову ее Launder Problem или Laundry Problem.
[03:47.840 --> 03:56.320]  Я пока не буду объяснять, что значит это слово, вот. Скоро мы поймем. Давайте посмотрим вот такой
[03:56.320 --> 04:04.040]  пример. Этот пример на самом деле довольно экзотический, и его довольно трудно придумать.
[04:04.040 --> 04:14.320]  Вот в прошлом году на лекциях мы пример такой не нашли. Я только потом его нашел там кое-где,
[04:14.320 --> 04:20.320]  и в общем показал. Но вот в этот раз мы можем сразу увидеть этот пример. Вот он
[04:20.320 --> 04:30.040]  заготовлен. Что здесь происходит? Давайте вдумаемся. Вот вычитается функция H. Мы создаем объект A,
[04:30.040 --> 04:40.240]  говорим, что N это результат вызова F, а потом говорим, что M это снова результат вызова F,
[04:40.240 --> 04:48.640]  и возвращаем N плюс M. Чему будет равно N плюс M? И тут надо посмотреть, что делает функция F.
[04:48.640 --> 05:04.040]  Функция F, она возвращает, ну, казалось бы, 1. Нет, виноват, это у B функция F возвращает 1.
[05:04.040 --> 05:15.560]  Функция F у A возвращает 2. Но перед этим она делает вот это. В этой строчке хочется умереть просто.
[05:15.560 --> 05:26.520]  Вот. Это она создаёт объект типа B по данному. Да-да-да-да. Вот мы зашли в функцию F,
[05:26.520 --> 05:33.480]  а функция F берет и по адресу Viz кладет другой объект и возвращает 2. После этого мы снова
[05:33.480 --> 05:45.360]  вызываем A.F. А зачем? Что зачем? Лазь по своему адресу другой объект. Значит,
[05:45.360 --> 05:52.600]  ещё раз. Это пример, иллюстрирующий, когда у B наблюдается. Мы обсуждаем проблему того,
[05:52.600 --> 05:57.440]  что если мы по одному и тому же адресу, под один и тот же pointer кладем объекты разных типов,
[05:57.440 --> 06:01.640]  то в какой-то момент компилятор может не заметить этого, продолжать считать, что там предыдущий тип.
[06:01.640 --> 06:07.120]  Если ты делаешь STD variant, то ты именно этим и занимаешься. Ты кладёшь по одному и тому
[06:07.120 --> 06:11.720]  же адресу разные типы. Можешь положить toBase и toDerived. Допустим, у тебя STD variant из разных штук.
[06:11.720 --> 06:18.480]  В какой-то момент ты возьмёшь и положишь по тому же адресу новый тип, а указатель будешь
[06:18.480 --> 06:22.880]  использовать старый, чтобы к нему обращаться. Что будет компилятор думать в этот момент?
[06:22.880 --> 06:28.040]  Компилятор тоже захочет умереть, но на самом деле будет думать про старый тип.
[06:29.000 --> 06:34.440]  Компилятор имеет право считать, что тип не поменялся от того, что мы так сделали.
[06:34.440 --> 06:43.520]  То есть переменная a была типа a, и мы вызвали у него какой-то метод. Компилятор имеет право считать,
[06:43.520 --> 06:53.960]  что от такого тип того, что подали, не изменился. Если бы это было pointer,
[06:53.960 --> 07:02.480]  то компилятор бы имел право считать то же самое. Странно бы, если бы компилятор считал
[07:02.480 --> 07:11.160]  наче, а это же переменная, у неё статический тип a. С чего бы ему стать равным b? Как это могло
[07:11.160 --> 07:18.760]  случиться? Если бы я вам показал этот код до того, как показал определение функций,
[07:18.760 --> 07:23.480]  вы бы даже не догадались, что тут может пойти не так. Казалось бы, понятно,
[07:23.480 --> 07:29.560]  что a.f одно и то же будет возвращать, если на том никаких статических переменных не используют.
[07:29.560 --> 07:41.480]  И компиляторы тоже так думали до некоторых пор. Еще до C++17, когда появился variant и прочие приколы,
[07:41.480 --> 07:48.240]  так и было. И компилятор действительно это умеет оптимизировать. А в чем смысл оптимизации?
[07:48.240 --> 07:54.400]  Ну файл называется devirtualize. Это один из сценариев, когда можно оптимизировать.
[07:54.400 --> 07:59.720]  Почему здесь можно оптимизировать? Конечно, это виртуальная функция, но мы не хотим прыгать
[07:59.720 --> 08:07.760]  по pointer, чтобы её вызвать. В чем смысл этой оптимизации? Чтобы вызвать виртуальную функцию,
[08:07.760 --> 08:11.520]  нам нужно сделать два прыжка, нужно сходить в таблицу виртуальных функций, посмотреть,
[08:11.520 --> 08:17.520]  какую именно версию функции вызвать и пойти её исполнять. Вопрос, нафига, если и так видно,
[08:17.520 --> 08:23.200]  что мы объявили A, никакого B в помине не было, вызвали у него F, а потом еще раз вызвали у него F.
[08:23.200 --> 08:31.840]  Зачем компилятору ходить здесь, генерировать походы в таблицу виртуальных функций? Ну вот,
[08:31.840 --> 08:46.040]  я сейчас это скомпилирую с g++11 и выведется 4. Ну вывелось 4, то есть, что он сделал?
[08:52.040 --> 08:59.920]  Ну два раза вызвал функцию. А второй вызов функции A.F не будет у B, потому что мы положили туда B.
[08:59.920 --> 09:13.320]  Да, вот я сейчас вызвал эту штуку и вывелось 4. Так, мне казалось,
[09:13.320 --> 09:19.680]  что должно вывести 3. Сейчас, а если я оптимизацию включу? Все равно 4 выводится.
[09:19.680 --> 09:33.760]  Это даже минус O2 не влияет на это. Это даже без минус O2 выводится 4. Даже оптимизатор включать не надо.
[09:33.760 --> 09:40.080]  Типа девиртуализация происходит. Да, ну давайте посмотрим. Можно открыть Godbolt и в него это
[09:40.080 --> 09:47.200]  запихнуть. Давайте посмотрим hard-divirtualize-cpp и сейчас я, значит, в Godbolt посмотрю,
[09:47.200 --> 09:58.600]  что происходит. Где посмотрите? Если до сих пор не знаешь, что такое Godbolt, очень жаль. Мы не раз
[09:58.600 --> 10:03.040]  пользовались, но вот сейчас ты увидишь, что это такое, и я надеюсь, запомнишь, потому что очень
[10:03.040 --> 10:15.840]  полезная штука. Это типа жирный бог? Нет, это не bold как жирный, а bold как... Я, кстати, не знаю,
[10:15.840 --> 10:25.080]  что. На самом деле Godbolt это фамилия разработчика просто. Его звали Godbolt, того, кто это придумал.
[10:25.080 --> 10:36.360]  Вот, смотрите. Мы просто смотрим, в какой Assembler это превратилось. Что из себя представляет функция
[10:36.360 --> 10:49.920]  h? Тут не то чтобы что-то понятно сильно, мы не то чтобы специпы Assembler, но, короче говоря, видно,
[10:49.920 --> 11:02.840]  вот, что он делает вызов a2.2.f и второй раз делает вызов a2.2.f, то есть он, вот он здесь вот,
[11:02.840 --> 11:13.480]  я даже не уверен, делает ли он хоть раз проход по Vtable. Ну, короче, видно, что оба раза вызывается
[11:13.480 --> 11:28.160]  a2.2.f. Видно, что он не идет в b. Вот. То же самое было бы, если бы это был pointer. Ну, я бы сказал,
[11:28.160 --> 11:38.160]  а звездочка а равно new a, а потом сказал, значит, а стрелочка f и еще раз а стрелочка f. Вот.
[11:42.680 --> 11:43.880]  Он, значит...
[11:52.840 --> 11:57.640]  А вот, возможно, кстати, нет. Вот здесь уже, видите, что-то другое появилось. Вот когда
[11:57.640 --> 12:05.200]  я делаю, когда я заменяю это на pointer, как будто бы он делает что-то более сложное, то есть он не
[12:05.200 --> 12:10.720]  прям напрямую вызывает call, известный адрес, а он вызывает call, адрес, который он куда-то
[12:10.720 --> 12:16.600]  до этого записал. А откуда он взял этот адрес? Он взял, значит, по каким-то там адресам на какие-то
[12:16.600 --> 12:22.000]  числа, положил в rdx, это вот его регистр, где он потом, откуда он потом будет вызывать какое-то число,
[12:22.000 --> 12:27.080]  и, значит, стал вызывать функцию по адресу, который он только что записал. И во второй раз он делает
[12:27.080 --> 12:33.320]  то же самое. То есть, возможно, если я заменяю это на pointer, дело меняется. Это новый компилятор же,
[12:33.320 --> 12:44.160]  да? Ну, на Godbolt я сейчас смотрю GCC 13, у меня GCC 12. Вот. Ну, давайте проверим, а, значит, вот если
[12:44.160 --> 12:52.600]  я возьму здесь, сделаю, что а это у меня теперь pointer, вы видите, да, что я делаю, new a. Понятно,
[12:52.600 --> 13:02.360]  что будет утечка памяти, но нас уже такие мелочи не волнуют сейчас. Вот. Мы переросли, так сказать.
[13:02.360 --> 13:13.280]  И я теперь компилирую, и получается 3. То есть, он справился, если был pointer. Вот. Ну, без оптимизации
[13:13.280 --> 13:26.120]  он тоже, очевидно, справится. Вот. Ну, если это был не pointer, то он считает, что под этим именем
[13:26.120 --> 13:32.120]  ничего не поменялось, хотя он имеет право считать и в том, и в другом случае так. Вот. Ну, можно это
[13:32.120 --> 13:36.640]  тестить на разных компиляторах, я не буду. Короче, смысл в том, что он имеет право так делать. Это
[13:36.640 --> 13:41.800]  единственный случай, когда это возможно. Когда такая ситуация возможна. Другой случай, когда такое
[13:41.800 --> 13:46.360]  возможно, это когда вы взяли, и у вас был, это я уже не буду пример показывать, потому что довольно
[13:46.360 --> 13:53.040]  трудно подогнать так, чтобы это проявилось, но другой пример, когда у вас константный тип.
[13:53.040 --> 14:04.760]  Представьте, что у вас есть const int, и вы его выводите, а потом, ну, допустим, у вас по pointer
[14:04.760 --> 14:11.640]  лежит const int, и вы выводите его. Вы же не можете const int ничего присвоить. Поэтому компилятор,
[14:11.640 --> 14:16.840]  он как бы имеет право считать, так раньше было проектировано изначально, что компилятор имеет право
[14:16.840 --> 14:22.480]  считать, что под const int ничего не поменяется, если у вас был указатель на const int. Он же указатель
[14:22.480 --> 14:27.320]  на const int, поэтому под ним ничего не может новое появиться, и он как бы имеет право соптимизировать
[14:27.320 --> 14:36.440]  и считать, что там, в общем-то, все как раньше и есть. На что, если вы placement new на него натравили?
[14:36.440 --> 14:42.880]  Присвоить const int вы ничего не можете, но вот placement new по адресу, по которому лежит const int,
[14:42.880 --> 14:50.440]  сделать туда новый const int, вы можете, и как будто бы от этого const int поменяется, но компилятор
[14:50.440 --> 14:57.640]  имеет право считать, что под const int ничего не поменялось. Причем я замечу, что вот это даже не...
[14:57.640 --> 15:06.760]  Тут нет ошибки в том, что я делаю new, placement new, не сделав предварительно деструктор. Потому что
[15:06.760 --> 15:12.360]  деструктор тривиальный. Есть такое правило в стандарте, что если деструктор тривиальный не
[15:12.360 --> 15:22.920]  выполнять никаких действий, то ничего страшного, если его не вызвали, это не ошибка. Время жизни все
[15:22.920 --> 15:27.840]  равно корректно считается завершенным. Если я просто placement new сделал на это место нового объекта,
[15:27.840 --> 15:33.600]  тот объект корректно завершил время жизни. УB в другом, в том, что я новый тип положил,
[15:33.600 --> 15:41.200]  а компилятор думает, что там старый тип продолжает лежать. Вот, короче, это проблема,
[15:41.200 --> 15:53.840]  которую люди осознали только в C++17. Я вам сейчас покажу один великолепный документ. Сегодня у нас
[15:53.840 --> 16:02.960]  такая прям вот, я не знаю, это к концу года несколько развлекательных историй, чтобы вы
[16:02.960 --> 16:08.280]  окончательно поняли, что такое C++. Я вам покажу сейчас замечательный документ, вот такой вот,
[16:08.280 --> 16:12.920]  который написан Николаем Джосаттисом. Это один из членов комитета по стандартизации, насколько я
[16:12.920 --> 16:21.240]  помню. И один из авторов книги большой, толстый про шаблоны C++, на который я еще собираюсь
[16:21.240 --> 16:29.120]  ссылаться сегодня. Так вот, смотрите, что предлагается сделать. Предлагается ввести в
[16:29.120 --> 16:40.320]  стандарт следующую функцию std-londer. Кто помнит, как переводится слово londer? Ну, стирка белья,
[16:40.320 --> 16:47.160]  laundry room бывает, значит, londer это стирать белья. А еще londer можно делать, значит, есть второе
[16:47.160 --> 16:55.080]  значение, можно деньги отмывать, londer money. Вот здесь скорее второе значение. Что такое londer?
[16:55.080 --> 17:06.320]  Давайте я вам сейчас открою даже страницу на cpp-референс про нее. Сейчас. И даже, знаете,
[17:06.320 --> 17:10.000]  что, даже я вам, наверное, вот так сделаю. Я вам вот эту статью тоже сейчас покажу.
[17:10.000 --> 17:22.280]  Ну, сначала cpp-референс посмотрим. Значит, std-londer это такая замечательная функция,
[17:22.280 --> 17:26.720]  определенная в header.new. Начиная с 17, она появилась. И она,
[17:26.720 --> 17:43.680]  ну, короче, она возвращает тот же самый pointer, который в нее передали. Что это такое? Берется
[17:43.680 --> 17:52.240]  pointer и возвращается он же самый без изменений. Ну, видимо, это pointer на другой объекте. Нет,
[17:52.240 --> 17:59.000]  тот же самый берется, значит, возвращается тот же самый, который и передали. Есть некоторые вопросы.
[17:59.000 --> 18:14.520]  Но при этом, что это значит? Типа, это такой, мы не можем с вами реализовать эту функцию сами.
[18:14.520 --> 18:21.600]  Функция londer — это штука, которая реализована. В общем, мы даже не сможем увидеть ее реализацию.
[18:21.600 --> 18:27.960]  Ну, мы сможем, наверное, увидеть ее реализацию в некоторых компиляторах. Она там просто ничего
[18:27.960 --> 18:33.480]  не делает, просто return то же самое написано в одну строчку. Ну, просто не все компиляторы еще умеют
[18:33.480 --> 18:39.280]  ее поддерживать нормально. В некоторых компиляторах, скажем так, она и не нужна, потому что они не умеют
[18:39.280 --> 18:46.440]  оптимизировать. Вот, например, си лэнг. Ладно, не буду зря гнать на си лэнг. В общем, не все компиляторы умеют
[18:46.440 --> 18:51.040]  делать вот эту оптимизацию девиртуализации. Не все версии, по крайней мере, компиляторов. И не все
[18:51.040 --> 18:55.720]  версии компиляторов умеют делать те оптимизации, которые я сейчас говорил. И если компиляторы и так не умели
[18:55.720 --> 18:59.680]  делать эту оптимизацию, то в них и функция londer, в принципе, может быть тривиальна и просто возвращать
[18:59.680 --> 19:05.400]  тот же самый pointer. Но в тех компиляторах, которые умеют делать эту оптимизацию, эта функция должна
[19:05.400 --> 19:11.280]  быть написана на каком-то низкоуровневом специальном коде. То есть там она написана не на си плюс плюс,
[19:11.280 --> 19:16.840]  скорее всего, а либо на ассемблере, либо на внутреннем представлении компилятора. И она делает
[19:16.840 --> 19:26.880]  примерно следующее. Она запрещает компилятору предполагать, что этот pointer, что он что-то
[19:26.880 --> 19:34.680]  знает про этот pointer в дальнейшем. Да это логично. То есть эта функция, она делает какую-то магию,
[19:34.840 --> 19:39.440]  и вот тут даже я не в состоянии вам сказать, что она делает. Это как move, только гораздо хуже.
[19:39.440 --> 19:50.680]  Она делает нечто, что понимает только компилятор. То есть какие-то внутри компилятора меняет
[19:50.680 --> 19:56.560]  флажочки относительно этого pointer, что компилятор отныне не будет предполагать,
[19:56.560 --> 20:03.440]  что он что-то про этот p знает, и оптимизации перестанут работать. Формально, значит,
[20:03.440 --> 20:10.960]  если у нас есть pointer, объект x размещенный по адресу a, x находится в пределах его времени жизни,
[20:10.960 --> 20:18.320]  тип x такой же как t, без си квалификаторов и в общем, бла-бла-бла, тогда лондор вернет
[20:18.320 --> 20:29.800]  указатель типа t звездочка, который указывает на x, а иначе ub. Как этим пользоваться? Ну смотрите,
[20:29.880 --> 20:40.560]  я вот сейчас возьму и напишу. Так, давайте я вернусь к старому примеру. Вот у меня есть такая штука,
[20:40.560 --> 21:09.360]  а у меня выводится 4. А теперь я напишу следующее. std londor от адреса a стрелочка f и вот теперь у
[21:09.360 --> 21:19.360]  меня выведется 3. А почему она с c++11 компилировалась, если она с 17? Это,
[21:19.360 --> 21:28.640]  еще раз, это версия компилятора, а не языка c++11, да. Можно же было сделать просто
[21:28.640 --> 21:41.640]  адреса a равно std londor от адреса a и потом вызвать? Адресу ничего нельзя присваивать. Ну да,
[21:41.640 --> 21:48.200]  вот типа адреса нельзя, но как бы сейчас, ну вот что-то такое. Ну можно было бы, если бы у меня
[21:48.200 --> 21:56.280]  были pointer, то я мог бы сказать, что pointer на a теперь это std londor от старого pointer, да, и дальше
[21:56.280 --> 22:00.560]  этим pointer пользоваться, это было бы корректно. А дальше я бы мог его сменять сколько угодно в
[22:00.560 --> 22:07.240]  плане? Нет, каждый раз, когда ты подменил под ним то, что лежит, ты потенциально обрел ub,
[22:07.240 --> 22:13.080]  если только не сделал londor перед этим. А, то есть это типа на каждое изменение типа свой londor?
[22:13.080 --> 22:21.000]  Да, londor это барьер, который запрещает компилятору предполагать в дальнейшем, что он что-то знает,
[22:21.000 --> 22:26.200]  у него к моменту этого места могли быть какие-то предположения. То есть, короче,
[22:26.200 --> 22:36.320]  обнуляет знания? Да, это как раз почему-то называется londor, это, ну идеологически это как отмывание денег
[22:36.320 --> 22:42.520]  работает, действительно такая была мотивировка, что типа мы как будто, что такое отмывание денег,
[22:42.520 --> 22:50.840]  это когда мы получили деньги, но мы забываем, откуда они пришли и как они у нас оказались,
[22:50.840 --> 22:56.560]  вот londor это штука, которая говорит компилятору, если ты даже что-то знал раньше про то, откуда это
[22:56.560 --> 23:03.240]  взялось, забудь об этом, считай, что как будто вот оно вот взялось просто из ниоткуда и пользуйся
[23:03.240 --> 23:10.440]  им, как будто ты ничего о нем заранее не знаешь, вот что такое londor. А в чем прикол, почему londor
[23:10.440 --> 23:17.320]  нон дискардом сейчас сделали с двадцатых плюсов? Нам же кажется, хотелось бы иногда сделать просто
[23:17.320 --> 23:25.400]  londor от адреса и после этого продолжить работу с переменной. Думаю, что потому что если londor
[23:25.400 --> 23:32.920]  вызываешь и ничего не присваиваешь, если дискардишь результат londor, то это ни на что не влияет, то есть
[23:32.920 --> 23:39.920]  ты как бы сделал londor от A и вот про это компилятор ничего не предполагает, но про сам A-то он по-прежнему
[23:39.920 --> 23:49.040]  предполагает. Ты же, еще раз, вот A после такой операции сам по себе, имя A, оно продолжает
[23:49.040 --> 23:55.560]  нести в себе какую-то информацию для компилятора. Если я дальше снова напишу k равно A.f, то компилятор
[23:55.560 --> 24:03.040]  опять может считать, что там 2. А, все понятно. У меня это в виду, что вот ты londor сделал и вот результат londor
[24:03.040 --> 24:20.200]  он как бы чист. Ты отмыл то, что… Я понял, спасибо. Вот. Сейчас будет несколько анекдотов. Ну, во-первых,
[24:20.200 --> 24:28.760]  давайте еще раз посчитаем вот эту статью. Я, в принципе, все, что вам надо знать, рассказал
[24:28.760 --> 24:38.280]  про londor. Вот. Нет, вру, не все. Сейчас мы с вами еще вы цитату из стандарта прочитаем, вот, и вы оцените
[24:38.280 --> 24:43.800]  по достоинству, я надеюсь. Но сначала я все-таки хочу еще раз вот на эту статью посмотреть. Здесь
[24:43.800 --> 24:49.240]  написано, какую проблему должен решать londor. Смотрите, что, какой пример здесь приводился. Вот
[24:49.240 --> 24:57.080]  у меня есть структура, в которой есть поле constant и поле double. И мы говорим, вот, создали
[24:57.080 --> 25:06.600]  новый объект x, а потом сделали вот так. И спрашиваем, чему равно n, вот это поле, которое constant.
[25:06.600 --> 25:16.880]  И внезапно это уб. Почему? Да, по той же причине, потому что это было константное поле в структуре x.
[25:16.880 --> 25:29.120]  Компилятор имел право считать, что это же константное поле, оно не поменялось. Вот,
[25:29.120 --> 25:41.080]  когда, когда люди писали стандарт про то, что такое lifetime объекта, откуда вообще пришла эта
[25:41.080 --> 25:49.000]  проблема. Был написан стандарт как-то. Вот люди формально начали, ну вот, определять, что такое
[25:49.000 --> 25:58.840]  object lifetime. Они написали вот это. И что-то еще там написали. И разработчики компиляторов такие,
[25:58.840 --> 26:07.120]  о, класс. Они прочитали стандарт, поняли, что, так это же значит, что мы можем соптимизировать.
[26:07.120 --> 26:13.000]  Соптимизировали. И только спустя долгие годы, после того, как они это соптимизировали,
[26:13.000 --> 26:19.200]  чуваки стандарта осознали фейл, который они допустили, когда вот так сформулировали все эти
[26:19.200 --> 26:34.640]  определения. Потому что, например, это приводит к тому, что вплоть до c++14 хранить в векторе
[26:34.640 --> 26:48.200]  константная типа было уб. Смотрите. Вот вы хотите, вы заметили, что мы никогда не создавали вектор из
[26:48.200 --> 26:56.880]  констентов, например. Или из конст чего угодно. Ладно, из констентов. Представьте, что у вас есть
[26:56.880 --> 27:08.160]  вектор, в котором лежит структура, в которой есть поле типа конст. Стоп, мы же создавали. Ну,
[27:08.160 --> 27:17.160]  до c++14, ну, в c++17 уже перестало быть уб. До c++14. Ну, какой-нибудь big integer типа там лежит конст,
[27:17.160 --> 27:25.120]  там, не знаю, int, base. И мы его кладем в вектор. Оно статическое было. Мы униклали вектор. Ну,
[27:25.120 --> 27:32.280]  может, и создавали. Ну, я вам говорю, что вот если бы вы до c++14, включительно, по-моему,
[27:32.280 --> 27:41.680]  создали бы вектор из объектов некоторого типа, в которых было поле типа конст, то, сделав из
[27:41.680 --> 27:48.080]  этого вектора popback, а потом pushback чего-то другого, вы бы обрели именно эту проблему. Потому что вы
[27:48.080 --> 27:55.720]  по тому же самому поинтеру положили нечто, что компилятор вообще-то имел право предполагать,
[27:55.720 --> 28:03.160]  что не поменяя... Ну, потому что как? Там лежал какой-то x. Вот. И в нем было константное поле.
[28:03.160 --> 28:08.840]  Компилятор имеет право предполагать, что оно... Вы сделали popback, потом pushback. Pushback,
[28:09.840 --> 28:18.480]  на это место с другим значением. И вот вам убе. И эта проблема реально существовала в c++
[28:18.480 --> 28:26.680]  вплоть до 14 стандарта. И вот только в 2000, это статья о 2017 года, 14 января,
[28:26.680 --> 28:35.240]  чел наконец-то сформулировал... Ну, он не первый, кто это написал. Это он уже саммари, так сказать,
[28:35.240 --> 28:40.840]  написал проблем, которые были известны к тому моменту. Только в 2016 году люди осознали,
[28:40.840 --> 28:46.000]  что у них из стандарта это следует. То есть у них написан стандарт, в стандарте черт ногу сломает,
[28:46.000 --> 28:52.800]  и там написано вот это. А разработчики компиляторов, конечно же, рады оптимизировать. И только в 2016
[28:52.800 --> 28:57.400]  году люди поняли, что из стандарта формально следует возможность вот такого убе, если векторе
[28:57.400 --> 29:03.760]  хранить вот такой тип. До сих пор, кстати, я не знаю, есть ли пример действительно, что что-то
[29:03.760 --> 29:14.320]  сломалось. Но вот тут Джасатис пишет, насколько это вообще реально такое убе, насколько его
[29:14.320 --> 29:26.200]  реально встретить на практике. Непонятно, насколько, но есть ивристика. Я просто попросил
[29:26.200 --> 29:34.080]  некоего своего знакомого посчитать, сколько в кодовой базе гугла использование placement new,
[29:34.080 --> 29:41.400]  которое игнорирует возвращаемое значение. Ну вот написали new, ptr, tr чего-то, и ничему это не
[29:41.400 --> 29:49.720]  присвоили. Это означает, что потенциально создали убе, если вы тем самым, ну когда вы присвоили
[29:49.720 --> 29:55.000]  результат placement new чему-то, вы дальше начали это использовать, и это уже не убе. Но если вы создали
[29:55.000 --> 29:59.200]  placement new и проигнорировали возвращаемое значение, это значит вы по старому койнтеру продолжаете
[29:59.200 --> 30:06.000]  обращаться к объекту, хотя он уже заново создан в нем, а значит потенциальное место,
[30:06.000 --> 30:12.840]  где может возникнуть убе. Так вот из 800 использований placement new, которые были в кодовой базе гугла
[30:12.840 --> 30:18.760]  на тот момент найдены, примерно 40% не используют возвращаемое значение, значит примерно там
[30:18.760 --> 30:25.640]  320 потенциальных возможных убе было найдено в кодовой базе гугла в 2019 году вот из-за этого.
[30:25.640 --> 30:37.280]  Вот такая история. А в 2017 году стандарты изменили, я вам сейчас покажу, ну это уже
[30:37.280 --> 30:46.120]  стандарт 2020 года, нам сейчас покажу замечательное место в нем. Вот здесь есть такой раздел basics,
[30:46.200 --> 30:54.880]  вы когда-нибудь читали этот раздел? Очень познавательный. В нем есть раздел memory and objects,
[30:54.880 --> 31:05.920]  и в нем есть раздел lifetime, и вот в этом пункте basic, базовые определения в стандарте,
[31:05.920 --> 31:14.840]  точка lifetime, есть пункт легендарный шестой, вот этот, в котором написано,
[31:18.400 --> 31:24.520]  а нет, вру, восьмой, вот нам какой пункт нужен, вот этот вот. Вот этот замечательный пункт,
[31:24.520 --> 31:31.960]  в котором написано, я не поленюсь это прочитать целиком, если после того, как время жизни одного
[31:31.960 --> 31:41.360]  объекта закончилось, и перед тем, как хранилище под этот объект занято, переиспользовано или
[31:41.360 --> 31:49.240]  освобождено, новый объект создан на том же storage, который занимался прежде чем оригинальным объектом,
[31:49.240 --> 31:55.000]  указатель, который указан оригинальным объектом, ссылка, которая ссылалась на оригинальный объект,
[31:55.000 --> 31:59.560]  или просто имя оригинального объекта, то что было в нашем примере, просто имя оригинального объекта,
[31:59.560 --> 32:07.400]  автоматически начнет обозначать новый объект, и как только время жизненного объекта начато,
[32:07.400 --> 32:15.120]  может быть использовано для обращения к новому объекту, если оригинальный объект
[32:15.120 --> 32:23.800]  transparently replaceable по отношению к новому объекту, а если не transparently replaceable,
[32:23.800 --> 32:29.560]  то это УБ, и вот это понятие transparently replaceable было введено в C++17, и вот что оно означает,
[32:29.560 --> 32:36.160]  объект у один transparently replaceable прозрачно подменяем на другой, если, во-первых, у них
[32:36.160 --> 32:44.240]  совпадает storage полностью, во-вторых, они одинакового типа, игнорируя верхний кост и
[32:44.240 --> 32:52.400]  волатайл квалификаторы, в-третьих, это не константный объект, в-четвертых, еще техническое какое-то условие,
[32:52.400 --> 32:59.520]  что они не potentially overlapping sub-object, это отдельно надо считать, что это такое, и либо они оба полные
[32:59.520 --> 33:06.000]  объекты, либо они direct sub-object, в общем, вот нас на самом деле вот эти три пункта интересуют, то есть
[33:06.000 --> 33:13.040]  здесь написано, что вы можете вот так вот непрозрачно подменять один объект на другой по тому же
[33:13.040 --> 33:23.800]  адресу, если вы одновременно того же самого типа, и еще не константный, и еще не potentially overlapping,
[33:23.800 --> 33:32.800]  и еще не вот это вот все, и вот здесь приведен пример, то есть я взял, в операторе присваивания
[33:32.800 --> 33:42.640]  сделал, например, destructor C, а потом new-vis C от other, это нормально, я могу так сделать по своему
[33:42.640 --> 33:48.440]  адресу подменить объект на тот же тип, если он не константный, если он константный, то не могу,
[33:48.440 --> 33:54.600]  и вот здесь написано, что если эти условия не соблюдены, то указатель на новый объект может
[33:54.600 --> 34:01.640]  быть получен из указателя, который представляет себе адрес его storage через stdlonder, и вот написано,
[34:01.640 --> 34:16.840]  что stdlonder pointer optimization barrier, а значит здесь, черт, я потерял, ну в общем вы поняли, вот здесь приведен
[34:16.840 --> 34:25.440]  пример с константом, вот у меня была структура x, в ней был int n, у меня был указатель на константный x,
[34:25.440 --> 34:32.920]  я положил туда тройку, я обратился, значит, по этому указателю достал n, а потом я взял и сделал
[34:32.920 --> 34:42.040]  новый const x по этому адресу этого поинтера через const cast и положил туда новый объект x, и обратился
[34:42.040 --> 34:49.520]  теперь снова по этому поинтеру достал n, вот это ub, потому что я подменил константный объект другим
[34:49.520 --> 34:54.560]  константным объектом через placement new, но вот если я через stdlonder обратился, то это ok.
[34:54.560 --> 35:06.560]  Обратите внимание, что вот это уже теперь не ub, начиная с c++17, потому что параграф вот этот
[35:06.560 --> 35:13.920]  вот object lifetime, который я вам показывал, с c++17 был изменен, и здесь условия были усилены,
[35:13.920 --> 35:22.040]  то есть раньше, в общем, вот иметь структуру с константным полем это тоже было плохо, сейчас такое
[35:22.040 --> 35:40.000]  можно. Вот, и последнее, что я скажу, это такой мем, что вообще-то, ну тут дальше объясняется,
[35:40.000 --> 35:48.880]  почему, значит, как london может помочь решить проблему, вот в том числе с с вектором, потом
[35:48.880 --> 35:55.440]  с классом optional, в котором мы тоже можем иметь дело с константным, ну вот тут менять объекты,
[35:55.440 --> 36:05.440]  которые там лежат через placement new, но дальше самое смешное, что, к сожалению, в контейнерах,
[36:05.440 --> 36:11.040]  которых используется Allocator, london всё равно не помогает до конца решить проблему, и вот почему,
[36:11.040 --> 36:23.880]  потому что, ну имеется в виду в тех контейнерах, в которых элементами являются константы или
[36:23.880 --> 36:36.160]  ссылки, и вот почему, потому что на самом деле у Allocator, когда мы делаем обращение к Allocator,
[36:36.160 --> 36:41.640]  в Allocator есть внутренний тип pointer, но он не обязан совпадать с сишным pointer, может существовать
[36:41.640 --> 36:47.440]  Allocator, у которого тип pointer это некоторый fancy pointer, который там не сишный pointer, а ещё какая-то
[36:47.440 --> 36:53.880]  обёртка над ним, и если в контейнер вектор подложить Allocator, у которого pointer это не сишный
[36:53.880 --> 37:01.000]  pointer, а какой-то специальный fancy pointer, я не говорю smart pointer, ну какой-то вот навороченный pointer,
[37:01.000 --> 37:09.120]  какая-то обёртка над сишным pointer, то std london, ну shared ptr я не уверен, что можно, ну в общем,
[37:09.120 --> 37:16.720]  то вот london от такого не поможет, потому что здесь написано, потому что тип вот этого elements может
[37:16.720 --> 37:24.680]  быть не просто сырой pointer, std allocator trades app pointer может быть классом, и тогда std london не сработает
[37:24.680 --> 37:31.120]  от него, и тогда это всё равно будет ub. Короче, если у вас в контейнерах есть константные элементы
[37:31.120 --> 37:39.400]  или элементы ссылки, или элементы вот такие вот с виртуальными, значит, вот эти вот проблемы,
[37:39.400 --> 37:55.240]  то жалко нас видимо, да, то могут быть разные тонкости, скажем так. А когда в 2017 году добавляли в
[37:55.240 --> 38:00.480]  стандарт вот это, там был тоже такой смешной момент, ну вы можете нагуглить, значит, лекцию про то,
[38:00.480 --> 38:06.280]  что такое std london, там говорилось следующее, там кто-то из членов комитета, возможно, кстати,
[38:07.040 --> 38:13.240]  нет, по-моему, кто-то другой, там была фраза в ответ на вопрос, что такое std london, объясните,
[38:13.240 --> 38:21.160]  пожалуйста, он сказал, if you are not one of five people on the planet who already knows what it is,
[38:21.160 --> 38:30.040]  you don't want to know what it is and don't need it, типа, ну вы поняли. Короче, мы добавили в стандарт одну
[38:30.040 --> 38:35.080]  функцию, если вы к настоящему моменту не один из пяти человек на планете, которые уже знают,
[38:35.080 --> 38:40.360]  зачем она нужна, то, пожалуйста, не пытайтесь понять, зачем она нужна, просто у нас проблемы
[38:40.360 --> 38:49.520]  нет при стандарте, лучше не вникайте. Вот примерно так это было. Вот, вам в std variant,
[38:49.520 --> 38:56.680]  вероятно, предстоит использовать эту функцию, когда вы будете обращаться к хранилищу, сменив тип
[38:56.680 --> 39:04.000]  в нем. То есть, я правильно понимаю, что если мы заводим вектор из константов и какой-то
[39:04.000 --> 39:12.160]  интересный аллокатор ему даем, то потенциально это все еще УБ? Ну, если этот аллокатор таков,
[39:12.160 --> 39:19.200]  что в нем pointer type не стандартный pointer, то это потенциально УБ, да. Я не знаю, на самом деле,
[39:19.200 --> 39:24.960]  сделали они, может, они в 2020 еще придумали на этот счет, но я, честно говоря, уже не знаю,
[39:24.960 --> 39:31.360]  я, в общем, значит, на хабре я вам хочу показать одну статью, я вам ее, вероятно, скину, ну,
[39:31.360 --> 39:38.240]  вы можете и так запомнить, значит, одна статья, которая в 2021 году появилась, здесь чувак просто
[39:38.240 --> 39:46.080]  разобрался, что делает Лондор на самом деле. То есть, он просто залез под капот компилятора и
[39:46.080 --> 39:55.080]  выяснил, что именно там делается. Это увлекательное чтение, я думаю, вам на ночь хватит,
[39:55.080 --> 39:58.920]  если вы решите в этом разобраться. Тут он начинает с примеров с вот этими виртуальными
[39:58.920 --> 40:03.720]  таблицами, рассказывает про то, как они устроены, эти виртуальные таблицы, показывает, значит,
[40:03.720 --> 40:14.240]  разные примеры, когда это может, когда компилятор может это оптимизировать. Кстати, один из примеров,
[40:14.240 --> 40:19.000]  когда компилятор может оптимизировать виртуальные таблицы, это когда у вас final написано. Это очень
[40:19.000 --> 40:22.640]  интересно. На мой взгляд, это одна из интересных вещей, которые можно этой статьи подчеркнуть.
[40:22.640 --> 40:28.680]  Вот казалось бы, зачем слово final в методе или в классе, что нельзя от него больше ничего наследовать,
[40:28.680 --> 40:33.120]  а потому что это дает возможность компилятору оптимизировать виртуализацию. Он понимает,
[40:33.120 --> 40:37.840]  что уже глубже не будет ничего, а значит, можно не ходить по таблице виртуальных функций,
[40:37.840 --> 40:47.760]  если у меня тип такой. Вот. Тем не менее, если вы потом подмените тип, то у вас начнутся
[40:47.760 --> 40:55.520]  проблемы, и вот здесь, значит, рассказано, что же именно происходит, и заканчивается все тем,
[40:55.520 --> 41:02.800]  как в LLVM, значит, ну, то есть вот LLVM, это проект по разработке силенга, я напоминаю,
[41:02.840 --> 41:09.040]  родственных ему компиляторов. И вот здесь, на внутреннем языке представления этого LLVM,
[41:09.040 --> 41:20.440]  объясняется, как компилятор делает эту оптимизацию, и что именно запрещает ему делать лондор. Вот. Вот
[41:20.440 --> 41:26.800]  что делает операция лондор, здесь, значит, написано. Я не буду с вами разбирать эту статью,
[41:26.800 --> 41:37.120]  но, я не знаю, можно там, если вы на устной части экзамена захотите, там у вас будет спорная
[41:37.120 --> 41:45.520]  ситуация, и вы захотите там отел 10, и, короче, не знаю, в какой-нибудь там, выпендрится где-нибудь,
[41:45.520 --> 41:50.200]  если вы хотите какой-нибудь плюс балл к чему-нибудь, можно будет чуть-чуть из этого пообсуждать,
[41:50.200 --> 41:58.440]  вот, но на любителя. Ты можешь прислать вот, не только эту статью, но еще статью с описанием,
[41:58.440 --> 42:05.400]  типа, в чем проблема? Конечно, конечно, я пришлю эти все ссылки вам в чат. Вот, в общем, все,
[42:05.400 --> 42:11.880]  я закончил говорить про лондор на этом. История, на мой взгляд, весьма показательная, она показывает,
[42:11.880 --> 42:17.880]  в том числе, то, как люди иногда находят ошибки в стандарте спустя много лет, понимают, что они
[42:17.880 --> 42:28.680]  косякнули, вводят нечто, и дальше, в общем, начинается веселье. Можно вопрос? Да, конечно.
[42:28.680 --> 42:37.560]  Пара вопросов. Получается, лондор нам нужен для тех объектов, которые не transparently replaceable.
[42:37.560 --> 42:45.440]  Да. Те, которые transparently replaceable, с ними все хорошо и так. Да, да, да. Хорошо, а вот еще можно
[42:45.440 --> 42:51.040]  как-то в настройках компилятора, ну, опции какой-нибудь в компиляции попросить, типа, вот,
[42:51.040 --> 42:57.000]  пожалуйста, вообще не делай никогда эту оптимизацию, чтобы, ну, просто не париться насчет этой проблемы.
[42:57.000 --> 43:08.240]  Ну, вот смотри, я вот, например, в G++ сейчас без оптимизации компилировал, но он все равно считал,
[43:08.240 --> 43:18.080]  что там лежит старый тип. Ну, просто обращение. А если прям честно, минусу ноль прописать? Давайте
[43:18.080 --> 43:31.640]  проверим. Ну, мне кажется, что это не поможет. Нет, ну, я о том, что, как бы, вот если обнаружили
[43:31.640 --> 43:41.360]  такой косяк, как бы, из-за оптимизации, то, казалось бы, ну, логично. Не то, что оптимизация. То есть,
[43:41.360 --> 43:50.520]  смотри, понимаешь, вот это даже не то, чтобы оптимизация. Вот я сказал АА, а дальше А.Ф. Ну,
[43:50.520 --> 43:56.680]  и также понятно, что там не Б лежит. Чего проверять-то? Если б я вам не рассказал эту историю,
[43:56.680 --> 44:01.160]  вот представьте, только когда мы начинали говорить про виртуальные функции в первом смене,
[44:01.160 --> 44:05.720]  я бы вам дал такой код и сказал, как бы вы, будучи компилятором, выполняли, вы бы сказали, ну как,
[44:05.720 --> 44:09.520]  зачем? Очевидно, не надо ходить в таблицу виртуальных функций. Вы даже про плейснью не знали
[44:09.520 --> 44:16.200]  тогда. Разработчики компилятора тоже такие, очевидно, нечего даже здесь… Это даже не считается
[44:16.200 --> 44:22.440]  оптимизацией, может быть, у них. И спустя 10 лет они поняли вдруг, что вообще-то есть вот такой
[44:22.440 --> 44:33.040]  пример, когда это работает неправильно. Ну, короче, не знаю. Как отключить? Не знаю. Надо
[44:33.040 --> 44:37.360]  разбираться, какие компиляторы вообще умеют это оптимизировать, какие нет. Силенка вроде
[44:37.360 --> 44:46.760]  что-то умеет, но за подробностями идите в эту статью. Значит, окей, это с лондером история. И
[44:47.760 --> 44:58.280]  последняя история с функцией SD-Visit. Ну, здесь, наверное, ну, если хотите, может сказать, это пункт 14.9.
[44:58.280 --> 45:06.120]  Что за история с функцией SD-Visit? Ну, как ее реализовать, в общем-то, вот история какая, вопрос.
[45:06.120 --> 45:14.840]  Значит, у нас есть функция SD-Visit, и мы хотим, точнее, у нас нет функции SD-Visit, мы хотим,
[45:14.840 --> 45:27.920]  чтобы она была как раз. Так она нам зачем нужна еще раз? Вот пример с Visit. Ну вот,
[45:27.920 --> 45:37.640]  мы хотим, чтобы у нас... А, которая, ну, всегда типа исполняет. Да, берет вариант, берет SD-Variant
[45:37.640 --> 45:57.320]  и выполняет что-то из вот этого. Вот. В очередной раз смотрим на этот пример. Значит, у нас вот
[45:57.320 --> 46:05.400]  есть три разных обработчика на случай, если то 5 и 10, и есть вариант, в котором exitInt. И вот мы
[46:05.400 --> 46:19.480]  вызываем функцию Visit, и сейчас будет, значит, int написано. Нет. Не будет написано, а почему? А, да,
[46:19.480 --> 46:27.960]  о, я вспомнил почему. Я этот пример написал тоже, тоже заготовил неспроста. Значит, у меня случился
[46:27.960 --> 46:36.320]  статик Assert. На самом деле, обратите внимание, что именно здесь не так. Static Assertion failed. Кстати,
[46:36.320 --> 46:43.120]  возможно, если я C++ 20 сделаю, то у меня даже будет другая ошибка. Нет, также она выглядит. Ну ладно.
[46:43.120 --> 46:50.160]  Смотрите-ка, Static Assertion failed. As the Visit requires the Visitor to have the same return type for all
[46:50.160 --> 46:57.760]  alternatives of a variant. Ага. Вы меня спрашивали, а что, если я буду из разных Visit возвращать разные
[46:57.760 --> 47:10.240]  типы? Помните, было такое? Я сказал, что, ну, это все равно не сработает. Ну, то есть я там сказал,
[47:10.240 --> 47:18.640]  что можно было бы найти общий тип, которому они приводятся, и возвращать его из Visit. Но, короче,
[47:18.640 --> 47:22.320]  по некоторым причинам, вот, как выяснилось, все равно в стандартной библиотеке сделано не так.
[47:22.320 --> 47:30.360]  Просто стандартная библиотека не разрешает вызывать Visit, когда у разных функций разные
[47:30.360 --> 47:45.440]  типы, что будет возвращено. У меня здесь возвращается int, char и double в каждом случае. И вот,
[47:45.440 --> 47:54.480]  если типы не одинаковые, то Visit просто падает, там Static Assert стоит. Я не могу из Visit вернуть
[47:54.480 --> 48:01.320]  разные вещи. Пока Visit все void, например, ну, хорошо. А Visit с разными типами не могу вернуть. Ну,
[48:01.320 --> 48:12.760]  это, в общем-то, логично. Как написано в ответе на Stack Overflow про это, вы не можете обмануть C++
[48:13.360 --> 48:21.080]  все-таки сделать вам динамическую типизацию. А нельзя возвращать Union из этих типов? Ну,
[48:21.080 --> 48:27.880]  можно возвращать вариант, если на то пошло. Зачем Union? Union, конечно, можно. Статический тип,
[48:27.880 --> 48:33.640]  главное, один и тот же надо возвращать. Вот, короче, Visit, если он возвращает разные типы для
[48:33.640 --> 48:43.720]  разных принимаемых типов, так не покатит, у вас будет CE. Вот, ну и, в общем-то, по сути, кроме как
[48:43.720 --> 48:53.560]  вот обеспечить этот Static Assert, Visit тривиален. Ну, вам, по сути, чтобы реализовать Visit,
[48:53.560 --> 49:01.960]  вам нужно просто правильно чекнуть, что все типы одинаковые возможны, а дальше просто сделать
[49:01.960 --> 49:10.600]  вызов. Но как сделать? У вас дан вам функтор и дан вариант. Как реализовать Visit? Вы просто берете
[49:10.600 --> 49:19.800]  и этот функтор вызываете от этого варианта. Как вы это делаете? Конечно же, с помощью STD Invoke,
[49:19.800 --> 49:30.520]  потому что, напоминаю, функтором может быть, в том числе, и указатель на член или какой-нибудь
[49:30.520 --> 49:56.720]  Bind Expression или какой-нибудь поле, я не знаю. Вот. Вот. Еще раз Invoke, что вы сделали? Сейчас я открою
[49:57.200 --> 50:03.480]  CP Perference, соответствующую страницу. Значит, мне нужна страничка про Visit.
[50:11.960 --> 50:19.400]  Так вот, SD Visit. У него есть две версии. Одна с явно указанным возвращаемым типом, другая с типом,
[50:19.400 --> 50:29.280]  который автоматически выводится. Но вот этот тип, он выводится при условии, что он одинаковый у всех
[50:29.280 --> 50:43.400]  возможных вызовов. Что делает эта функция? Она вызывает Visitor, то есть вот этот вот Vis. Как
[50:43.400 --> 50:57.880]  если бы мы написали следующее выражение. Invoke от STD Forward от Visitor и от STD Get. Ну, давайте для
[50:57.880 --> 51:03.880]  начала разберем пример, когда у нас один всего вариант. Если у нас просто Visitor, можно передавать
[51:03.880 --> 51:09.800]  несколько вариантов, и в этом главный мем. Но вот если у нас есть просто один вариант, то мы по сути
[51:09.800 --> 51:25.440]  что делаем? Мы делаем Invoke STD Forward от Visitor и STD Get от соответствующего индекса варианта,
[51:25.440 --> 51:34.720]  который в нем сейчас лежит. От этого вариант.
[51:56.440 --> 52:00.200]  Что такое индексы? Мы же их нигде не передавали.
[52:00.200 --> 52:09.920]  Experian Farce Index.
[52:09.920 --> 52:24.520]  Да, значит сейчас нам нужно что сделать? Нам нужно, какая здесь есть проблема? Ну, во-первых,
[52:24.520 --> 52:32.880]  что такое Invoke? Invoke это вот эта штука, которую мы уже обсуждали. Ну, это по сути вот такое
[52:32.880 --> 52:44.360]  вот выражение STD Invoke. Помните его? Которое вызывает функцию вроде, да? Да, ну мы вызываем
[52:44.360 --> 52:51.040]  его не круглыми скобочками, а через вот это, через STD Invoke, чтобы корректно обрабатывать
[52:51.040 --> 53:01.880]  в случае указатель и на члены, указатель и на методы. Вот. Второй вопрос. Да, второй момент. Мы,
[53:01.880 --> 53:10.240]  конечно же, принимаем и Visitor, и варианты по универсальным ссылкам, и forward, и то, и другое. То
[53:10.240 --> 53:19.000]  есть мы forward-им Visitor, forward-им вариант, чтобы не потерять категорию значения, если что. Вот.
[53:19.000 --> 53:25.360]  И главный вопрос, это как узнать, от какого типа Visitor вызвать?
[53:37.360 --> 53:48.720]  Там дидакшен не сработает? Нам надо понять, какой тип в варианте именно от этого типа вызвать Visitor.
[53:48.720 --> 53:52.640]  Вот, а как это сделать?
[53:59.160 --> 54:05.480]  Мы не можем сделать просто вот здесь вот, мы не можем написать index, ну у варианта есть метод
[54:05.480 --> 54:15.640]  index, который говорит, какой по номеру тип в нем сейчас лежит. Index. Ну он просто говорит,
[54:15.640 --> 54:20.320]  какой по счету тип в нем сейчас активен. Но мы не можем это как шаблонный параметр в get передать,
[54:20.320 --> 54:30.360]  конечно же, потому что это не compile-time число, а в get нужно compile-time. Вот. Как же нам быть?
[54:36.920 --> 54:43.400]  Это загвоздка. Я так понимаю, мы преддаем сразу все, но если специализация, где он true и false,
[54:43.400 --> 54:53.960]  и на false мы ничего не делаем, что-то такое. Вот. На самом деле реализовать это можно примерно так,
[54:53.960 --> 55:06.400]  кажется. Нам нужно взять вот эти типы и их сделать шаблонными параметрами, а дальше просто перебирать
[55:13.400 --> 55:22.720]  Ну, нам нужно как бы несколько уровней перегрузки сделать. Мы напишем некоторую вспомогательную функцию Visitor.impl,
[55:22.720 --> 55:29.920]  Visitor.impl, которая будет принимать дополнительным пакетом шаблонных параметров вот этот вот список
[55:29.920 --> 55:38.400]  типов и вариантов. И дальше мы будем смотреть тип, который сейчас лежит в варианте, то есть индекс
[55:38.400 --> 55:51.400]  вот этого типа в пакете типов. Это то же самое, что первый тип нашего пакета. Если да, то каст к нему
[55:51.400 --> 56:00.560]  и вызвать от него, а иначе пойти дальше и сделать визит от этого же варианта, но уже с пакетом с
[56:00.560 --> 56:19.640]  откушенной головой. Понятная идея или не очень понятная? Ну, вроде бы да. Ну, я не хочу
[56:19.640 --> 56:25.880]  это сам писать, потому что тогда всё будет неинтересно. Вы сами, в общем, это напишете, я думаю,
[56:25.880 --> 56:35.640]  кто будет варианты писать, конечно. Значит, как это можно сделать? Мы берем вариант, вот этот пакет
[56:35.640 --> 56:41.120]  типов мы дополнительными параметрами передаём в аргумент. Мы по сути делаем такой if, мы такое
[56:41.120 --> 56:52.200]  делаем как бы форик по этому списку типов. Вот. И мы говорим, правда ли, что тип того, что сейчас
[56:52.200 --> 56:57.280]  лежит в варианте, уже не constexpr. Правда ли, что тип того, что сейчас лежит в варианте, то же самое,
[56:57.280 --> 57:06.960]  что голова нашего пакета. Если да, то каст к этому и вызваться от этого, а иначе вызваться
[57:06.960 --> 57:17.240]  рекурсивно эту же функцию от того же пакета типов, но без первого элемента. Итак, пройдем все
[57:17.240 --> 57:24.360]  элементы, пока не найдем тип, который совпадает с типом того, что сейчас лежит в варианте. И от него
[57:24.360 --> 57:36.200]  вызываемся. Вот. Но при этом нам надо еще написать static-assert на то, что результаты вызова визит от
[57:36.200 --> 57:42.840]  всех этих типов будут одинаковыми. А как нам это сделать? Ну, это кажется как раз просто. Сделать
[57:42.840 --> 57:49.160]  это может через fold expression сделать. Нам надо написать, что static-assert, ну, можно написать
[57:49.160 --> 57:59.680]  метафункцию allSame, типа все результаты, decal-type от наш визитер, от головы пакета и так далее. Все
[57:59.680 --> 58:11.320]  это одинаковый тип. Вот такой static-assert. А дальше просто идти и вызывать. Ну как, нормально? Ну,
[58:11.320 --> 58:17.400]  вроде понятно. Ну вот. Я так понимаю, я так понимаю, раз вы это не хотите писать, значит есть
[58:17.400 --> 58:31.800]  какие-то подводные камни. Ну, да вроде нет. Везде нигде нет подводных камней, пока не начнешь это
[58:31.800 --> 58:39.920]  писать. Не, я просто боюсь, что если я начну это писать, то я ошибусь где-нибудь, у меня потратится
[58:39.920 --> 58:45.440]  много времени. Я вот почему не хочу. То есть типа не то, что там есть подводные камни, а то, что
[58:45.440 --> 58:51.040]  может с первого раза неправильно написать и дальше ошибки компиляции ловить. Ну, в принципе кажется,
[58:51.040 --> 58:57.160]  короче да, я не чувствую себе храбрости написать это правильно с первого раза, поэтому я не хочу
[58:57.160 --> 59:04.600]  сейчас это сделать. Вот так. Но вообще это кажется пишется не особо сложно. Ну и потом, если я это
[59:04.600 --> 59:09.240]  напишу, то вам-то о чем думать тогда надо будет. Вам же все-таки надо же самим порешать что-нибудь,
[59:09.240 --> 59:14.240]  пока вы эту задачу пишете. На самом деле в варианте будет еще одна проблемка,
[59:14.240 --> 59:20.760]  которую я не сказал в реализации варианта. Ну, в общем, когда начнете писать, увидите,
[59:20.760 --> 59:30.640]  в чате обсудим. Идейно вроде все понятно, но там будут некоторые тонкости. Вот, в целом все про
[59:30.640 --> 59:44.160]  вариант, про юнионы, про type erasure. Дайте лайн по варианту. Я думаю, что никогда. Ну, то есть,
[59:44.160 --> 59:49.280]  я думаю, что вот варианты и следующая, то есть вот эти как бы вариант и следующая,
[59:49.280 --> 59:58.560]  последняя задача называется type list. Скорее всего, они бонусные. А по ПТР? По ПТР, ну давайте,
[59:58.560 --> 01:00:05.080]  когда вы хотели? 20 мая? Ну, давайте будет 20. Ну, плюс 21 день вроде типа. Ну, давайте 20. Вот,
[01:00:05.080 --> 01:00:10.160]  вариант и type list, последняя задача будет без дилайна. Ну, в смысле, их можно без штрафа сдавать
[01:00:10.160 --> 01:00:17.400]  вплоть до дня перед экзаменом. Вот, ну просто их мало кто будет сдавать, я думаю. А ревьювятся они
[01:00:17.400 --> 01:00:21.680]  как будут тогда, если сдать их в день перед экзаменом? Так нет, нормально, если их никто не
[01:00:21.680 --> 01:00:29.440]  сдает, то они ревьюются нормально. Да, мы подумаем там, либо просто быстренько посмотрим там,
[01:00:29.440 --> 01:00:36.960]  и как-нибудь. Ну, в прошлом году несколько человек всего сдавало, и они все быстро устно сдали там
[01:00:36.960 --> 01:00:42.280]  с первого максимум со второго раза. Сейчас, разве вы не написали код estate variant почти полностью?
[01:00:42.280 --> 01:00:53.320]  Нет. Ну, я написал основные идеи, но когда ты начнешь реализовывать, ты поймешь, что там еще есть
[01:00:53.320 --> 01:01:02.080]  проблемки, скажем так. Вот. Ну, например, проблемка будет, скажем, когда тебе надо будет уметь
[01:01:02.080 --> 01:01:09.640]  создавать вариант. Я его буду инициализировать con char звездочкой, а тебе нужно будет snd string
[01:01:09.640 --> 01:01:20.240]  получить, и это вызовет некоторую проблемку. Сейчас уже с кодом даже не вспомню какую. Ну, в общем,
[01:01:20.240 --> 01:01:31.520]  увидите. Короче, в чате обсудим. Я думаю, что условия я выложу уже, блин, боюсь говорить сегодня,
[01:01:31.520 --> 01:01:35.600]  потому что сегодня, мне кажется, я не успею. Ну, давайте завтра постараюсь выложить условия
[01:01:35.600 --> 01:01:56.760]  варианта. Вот. Все, в общем-то. Конец темы 14. Идем дальше. Перерыв, я думаю, пока не будем
[01:01:56.760 --> 01:02:11.560]  делать, у нас еще не прошло сколько надо времени. Следующая тема называется шаблонное метапрограммирование
[01:02:11.560 --> 01:02:35.000]  свиная и концепты. Значит, ну, давайте я напишу просто метапрог cpp.
[01:02:41.560 --> 01:03:02.760]  Вот. Я думаю, многие из вас ждали этого, потому что шепот перешептования об этом я слышал довольно
[01:03:02.760 --> 01:03:16.400]  давно. Ну, приближаясь к завершению нашего путешествия по современному программиру на c++,
[01:03:16.400 --> 01:03:26.240]  нам надо бы наконец закрыть долги, связанные с тем, что мы постоянно не умели реализовывать разные
[01:03:26.240 --> 01:03:34.800]  метафункции. Мы с вами многие уже метафункции использовали. Сначала мы использовали метафункции,
[01:03:34.800 --> 01:03:42.920]  когда каким-то чудом итератор трейдс сами определяли, какого вида наш итератор. Потом мы
[01:03:42.920 --> 01:03:53.520]  использовали метафункцию, значит, там, правда ли аллокатор обладает методом констракта таких-то
[01:03:53.520 --> 01:03:59.640]  аргументов. И аллокатор трейдс опять-таки как-то сами это определяли. Потом мы пользовались
[01:03:59.640 --> 01:04:06.680]  метафункцией из constructable, из no-throw move constructable. Потом мы пользовались метафункциями из base-off.
[01:04:06.680 --> 01:04:12.080]  Один тип является наследником другого. Мы пользовались метафункцией uses аллокатор. Мы
[01:04:12.080 --> 01:04:20.840]  пользовались функцией из callable. Ну, короче, очень многими. Вот в этом, в этой главе мы все их
[01:04:20.840 --> 01:04:25.600]  научимся реализовывать. Но не прям все, мы их реализуем целиком, потому что некоторые из них
[01:04:25.600 --> 01:04:33.960]  очень технически долго реализовывать. Но мы идейно научимся реализовывать их всем. И начнем мы с
[01:04:33.960 --> 01:04:43.720]  такого пунктика. Я бы сказал, он немножечко выбивается, он немножечко особнячком стоит,
[01:04:43.720 --> 01:04:49.480]  то есть он немного не в тему именно метапрограммирования. Но мы о нем не сказали,
[01:04:49.480 --> 01:04:57.360]  когда говорили про шаблоны в первом семестре. И надо сказать о нем в этом семестре. Это будет
[01:04:57.360 --> 01:05:11.480]  короткий пункт. И под него я тоже заготовил кусочек кода. Пункт про инстанцирование. Вот мы с
[01:05:11.480 --> 01:05:28.280]  вами говорили, что... Давайте я назову его ленивое инстанцирование и explicit
[01:05:28.280 --> 01:05:45.320]  instantiation. Мы с вами говорили, что компилятор инстанцирует шаблоны лениво. Прошлый раз даже я
[01:05:45.320 --> 01:05:53.880]  там запутался сам. Помните, у нас была история с function, да, почему у нас в копе конструктор. Я это
[01:05:53.880 --> 01:05:59.600]  в чате написал, на видео не сказал. Помните, была проблема с function, почему move only объекты в
[01:05:59.600 --> 01:06:05.320]  function class нельзя. Потому что инстанцируется копе конструктор, а почему он инстанцируется? На
[01:06:05.320 --> 01:06:09.320]  самом деле копе конструктор не инстанцируется, инстанцируется статическая функция, которая
[01:06:09.320 --> 01:06:17.680]  заведует, сохраняет указатель на эту копию. И поскольку ее надо инстанцировать, приходится
[01:06:17.680 --> 01:06:26.280]  инстанцировать копе конструктор. Но вообще компилятор инстанцирует шаблоны лениво. Вот давайте
[01:06:26.280 --> 01:06:33.400]  посмотрим на вот этот вот код. И я не знаю, скомпилируем его. Вот я сейчас это открою,
[01:06:33.400 --> 01:06:40.280]  закрою, наоборот. Пример, взятый из книжки к Ванварду Джасати со шаблоном. Вы все стерли,
[01:06:40.280 --> 01:06:48.400]  только что нет. Нет, я на другой вкладке это сделал. Вот, я сейчас компилирую вот этот файл и
[01:06:48.400 --> 01:07:00.680]  обнаруживаю, что он прекрасно компилируется. Вот. Ну, почему он компилируется? Здесь вообще у нас
[01:07:00.680 --> 01:07:06.080]  есть какие-то проблемы, почему это не должно компилироваться, вот пока я не использовал ни
[01:07:06.080 --> 01:07:14.120]  один из этих классов. Но вообще есть, да, вот смотрите, например, здесь инстанцируется вот
[01:07:14.120 --> 01:07:20.720]  этот вот класс Danger с шаблонным параметром минус один. Но он объявляется в теле функции,
[01:07:20.720 --> 01:07:25.920]  которая сама в свою очередь находится внутри шаблонного класса, а шаблонные аргументы я
[01:07:25.920 --> 01:07:32.600]  еще никакие не подставил, поэтому компилятор просто не смотрит даже на это. Он не инстанцировал вот это
[01:07:32.600 --> 01:07:46.360]  тело. Вот. С другой стороны, если бы я вот здесь вот попытался сделать такое поле, то, вероятно,
[01:07:46.360 --> 01:08:01.320]  это бы уже было ошибкой, потому что объявление полей он все-таки смотрит. То есть несмотря на то,
[01:08:01.320 --> 01:08:08.080]  что я не подставил t и n, компилятор все-таки просматривает объявления функций и полей на
[01:08:08.080 --> 01:08:23.640]  корректность объявления. В плане, ну, мы же вообще трики нигде не заводим, зачем? Да, но компилятор
[01:08:23.640 --> 01:08:33.080]  уже видит, что это будет ошибкой, независимо от того, какие t и n мы подставим. Тут он тоже,
[01:08:33.080 --> 01:08:38.160]  по идее, мог бы увидеть, что это будет ошибкой всегда, но просто определение функций он ленится
[01:08:38.160 --> 01:08:44.560]  инстанцировать, а объявление не ленится. Ну, это какая-то очень странная граница, почему что-то он
[01:08:44.560 --> 01:08:50.480]  проверяет всегда, что-то может запустить. Причем, насколько я знаю, методы класса он может не
[01:08:50.480 --> 01:08:58.360]  компилировать вообще, пока они не вызываются, даже если у нас этот класс создается реально. То есть
[01:08:58.360 --> 01:09:05.720]  здесь какая-то очень странная граница. Давайте попробуем заиспользовать этот класс. Вот я
[01:09:05.720 --> 01:09:17.000]  инстанцировал сейчас трики с шаблонными параметрами int и 1. Вот. Что от этого поменяется?
[01:09:17.000 --> 01:09:30.640]  Вот кажется, что от этого... На самом деле, вот этот пример, да, вот этот пример вместе с
[01:09:30.640 --> 01:09:35.400]  комментариями взят из книжки шаблона C++ на читавторов Wonderwood-Jasattis. Я еще раз повторю.
[01:09:35.400 --> 01:09:48.360]  Такая толстенная книжка. Пример довольно-таки получительный. В стандарте про многие вещи из этих
[01:09:48.360 --> 01:09:57.640]  написано, что это unspecified. Должен ли компилятор инстанцировать что-либо? Вот, например,
[01:09:57.640 --> 01:10:05.320]  дойдет ли он сейчас до сюда? Упадет ли это? Я вот сейчас класс инстанцировал с параметром
[01:10:05.320 --> 01:10:13.920]  шаблонными. И окей, поле он обнаружил ошибкой еще до того, как я вообще инстанцировал. Ну вот,
[01:10:13.920 --> 01:10:21.120]  я сейчас инстанцировал объявление класса. Извиняюсь, инстанцировал определение класса.
[01:10:21.120 --> 01:10:29.040]  Инстанцируются ли определения функций? Честно говоря, я не знаю и, по-моему, это unspecified. То
[01:10:29.040 --> 01:10:35.800]  есть компилятор имеет право не заметить этого, пока я функцию не вызвал. Давайте проверим 2++11.
[01:10:35.800 --> 01:10:46.960]  Так, я сохранил. Ну да, вот он даже, несмотря на то, что я уже подставил сюда аргументы, он все равно
[01:10:46.960 --> 01:10:56.000]  вот это не инстанцировал, потому что error не вызвалось. Ну вот, если я вызову t.error, то,
[01:10:56.000 --> 01:11:01.240]  конечно же, он инстанцирует, ну он начнет компилировать определение функций, теперь уже упадет.
[01:11:01.240 --> 01:11:17.080]  Вот. Что еще? Ну вот, если я теперь инстанцирую сразу вот с таким параметром, что будет? В каких
[01:11:17.080 --> 01:11:31.080]  местах возникнут ошибки? Strike nested. Strike nested. Наверное, возникнут, потому что это объявление
[01:11:31.080 --> 01:11:37.280]  поля внутри структуры, которую как бы мы инстанцировали, мы подставили. В n-класс не будет,
[01:11:37.280 --> 01:11:44.280]  по идее, если не было... Вот здесь вот, вероятно, возникнет, потому что это объявление функции,
[01:11:44.280 --> 01:11:55.240]  правда, вот это объявление функции, и объявление функции он подставит, а вот определение функции
[01:11:55.240 --> 01:12:02.320]  он, вероятно, не подставит, поэтому, например, вот здесь ошибки не будет. Вот здесь, я думаю,
[01:12:02.320 --> 01:12:09.360]  ошибка будет и здесь. Если бы мы поменяли местами align и anonymous, у нас же не было бы ошибки в юнию 1?
[01:12:09.360 --> 01:12:14.240]  Я думаю, что была бы все равно. Давайте, во-первых, проверим, какие ошибки будут сейчас.
[01:12:14.240 --> 01:12:23.520]  А вот и нет. Вот мы и не отгадали, значит. Он, оказывается, и вот это не инстанцировал,
[01:12:23.520 --> 01:12:31.760]  и вот это не инстанцировал. Жесть. Спасибо великому и ужасному Implementation Defined.
[01:12:31.760 --> 01:12:40.240]  Стоп, почему он union не инстанцировал? Ну, видимо, потому что Implementation Defined.
[01:12:40.240 --> 01:12:46.040]  Ну, типа union это же прямо поле класса трики. Ладно, структура nested, она вроде нигде не
[01:12:46.040 --> 01:12:54.040]  используется, но... Сфига ли это поле? Ну, это безымянный union, и в нем, по идее, есть поле вот
[01:12:54.040 --> 01:12:59.160]  это и поле вот это, и они оба являются полями нашего класса, как бы лежащими на одном и том же
[01:12:59.160 --> 01:13:04.920]  адресе просто. Ну да, ну и типа еще... И первое поле у нас первое, ну danger первое, поэтому, по идее,
[01:13:04.920 --> 01:13:09.440]  должно default на его конструкции. Да, и вот это странно, потому что здесь даже комментарий написан,
[01:13:09.440 --> 01:13:16.560]  что, по идее, это... Илья, подожди, а я, может, что-то не понял, но мы же имя этому union не дали,
[01:13:16.560 --> 01:13:22.560]  и не завели переменную этого типа локально. Я, может, что-то путаю. Не, не, значит, еще раз, у нас был
[01:13:22.560 --> 01:13:29.760]  пример такой, мы с std string тоже самое видели, у нас безымянный union, это значит, что мы вносим все
[01:13:29.760 --> 01:13:37.360]  его члены в объемлющую область видимости, то есть, как бы, у этого класса полями являются
[01:13:37.360 --> 01:13:52.480]  anonymous и line, но у них одинаковые адреса. Безымянный union, это штука, которая просто заставляет
[01:13:52.480 --> 01:13:57.400]  положить вот это и вот это на одинаковые адреса, то есть, у нас как бы два поля share один и тот же
[01:13:57.400 --> 01:14:03.920]  адрес памяти, но они оба являются как бы полями класса. Правда ли, что он саптимайзил, увидел,
[01:14:03.920 --> 01:14:09.720]  что мы нигде не используем ни anonymous, ни line и выкинул их нафиг? Я, честно говоря, удивлен,
[01:14:09.720 --> 01:14:23.080]  потому что, казалось бы, мы точно, я точно сохранил это. А, так подождите, нет, все правильно,
[01:14:23.080 --> 01:14:30.480]  все правильно, required from, вот отсюда, из 25 строки, это где у нас произошло? Вот отсюда,
[01:14:30.480 --> 01:14:39.080]  все правильно, в union ошибка возникла. У нас возникла первая ошибка из-за объявления функции вот
[01:14:39.080 --> 01:14:46.480]  этой. Вторая ошибка из union, потому что поле union он таки инстанцировал, и он сказал, вот,
[01:14:46.480 --> 01:14:57.800]  в инстанцировании класса такого из строки вот такой, union, 2.2.unnamed, unnamed это имя union,
[01:14:57.800 --> 01:15:07.000]  required from class, required from here, ошибка возникла из-за union. Попробуйте поменять местами online
[01:15:07.000 --> 01:15:24.440]  anonymous. Я думаю, что это не поможет, ну, хорошо, давай попробуем. Тоже самое. Ну, неважно,
[01:15:24.440 --> 01:15:28.840]  в каком порядке, это очень странно было, если он инстанцировал первое поле, но не второе,
[01:15:28.840 --> 01:15:35.800]  он оба их инстанцировал. Вот, а вот это он таки не инстанцировал. Но понятно при этом,
[01:15:35.800 --> 01:15:48.040]  что если мы напишем, допустим, там, tricky int-1.2.2.nested, то он уже инстанцирует структуру и тогда
[01:15:48.040 --> 01:16:05.240]  будет еще и ошибка в ней. Так, что? Что происходит? Каждый день. Нет, сейчас, подождите, мне кажется,
[01:16:05.240 --> 01:16:22.600]  что это очень странно. Что? Typical плюсы.
[01:16:35.240 --> 01:16:47.680]  У меня есть подозрение, что, может быть, это из-за того, что он уже эту ошибку обнаружил здесь и не
[01:16:47.680 --> 01:16:58.600]  стал говорить о ней второй раз. Да, наверное, вот в чем дело, наверное, он просто обнаружил эту ошибку
[01:16:58.760 --> 01:17:22.720]  здесь, не стал ее повторять. Вот. Но мы еще не получили ошибку вот здесь. Что здесь за ошибка?
[01:17:22.720 --> 01:17:26.880]  Здесь мы пытаемся присвоить аргументу по умолчанию число 3, но это тип такой,
[01:17:26.880 --> 01:17:36.880]  которому не принадлежит присвоить int. Мы приняли тип и пытаемся ему присвоить число. Мы просто
[01:17:36.880 --> 01:17:45.080]  безымянный аргумент завели. Можно заводить безымянный аргумент со значением по умолчанию,
[01:17:45.080 --> 01:17:51.200]  зачем? Ну да, синтез позволяет. Это как если бы я написал так, просто не придал ему значение.
[01:17:51.200 --> 01:18:00.560]  Что? Зачем? Нам это скоро пригодится, кстати. Мы же нигде не можем. Правда, в шаблонах. Например,
[01:18:00.560 --> 01:18:07.200]  чтобы сгенерировать ошибку как раз. Это может быть нужно. Ну, короче, вот это не вызвало ошибку,
[01:18:07.200 --> 01:18:13.440]  и вот это не вызвало ошибку, и вот это не вызвало ошибку, потому что тела функции не инстанцировались,
[01:18:13.440 --> 01:18:18.320]  и даже аргументы по умолчанию не инстанцируются, не произведена проверка, что вот это вот ему не
[01:18:18.320 --> 01:18:21.520]  потребовалось подставлять аргумент по умолчанию, поэтому он не выдал ошибку.
[01:18:21.520 --> 01:18:35.800]  Если бы я попытался сказать трики blah blah blah t, а потом сказал t.nobodyhere и не передал
[01:18:35.800 --> 01:18:41.560]  аргументов, то он бы, конечно же, выдал ошибку, потому что теперь-то ему надо подставить аргумент
[01:18:41.560 --> 01:18:47.960]  по умолчанию, а я не передал его, а значит, он будет пытаться присвоить этому типу тройку
[01:18:47.960 --> 01:18:55.960]  и будет CE. Ну, понятно, что он логично будет, если я попытаюсь вызвать сейчас, что там,
[01:18:55.960 --> 01:19:04.520]  in class и так далее. Короче, тела не инстанцируются, когда я объявляю, когда я использую класс,
[01:19:04.520 --> 01:19:11.760]  инстанцируются его все объявления в нем, но определение метов еще пока не инстанцируется,
[01:19:11.840 --> 01:19:19.760]  а когда я уже использую функции из него, то инстанцируется определение этих функций.
[01:19:19.760 --> 01:19:28.920]  Вот. Еще один интересный вопрос, что будет, если я скажу вот так.
[01:19:28.920 --> 01:19:42.600]  Ну, по идее, то же самое. Вот, смотрите.
[01:19:42.600 --> 01:19:54.120]  Хотя, кстати, у нас до этого был пример, когда у нас в классе еще общего определения не было,
[01:19:54.320 --> 01:20:04.960]  вот именно, если я делаю указательно на тип, это не заставляет компилятор генерировать
[01:20:04.960 --> 01:20:14.280]  определение этого типа. Например, поля класса знать не нужно для этого. Вот, чтобы создать объект
[01:20:14.280 --> 01:20:23.600]  типа T, компилятору нужно узнать все про его поля, например. Вот это неизбежно нужно подставить сюда,
[01:20:23.600 --> 01:20:30.840]  потому что здесь нужно выяснить сайзов этих полей, например. Но если я делаю pointer,
[01:20:30.840 --> 01:20:37.720]  то компилятору не нужно этого делать. Потому что pointer на T, он не зависит от того,
[01:20:37.720 --> 01:20:43.520]  что на самом деле содержит в себе T. Вот если бы я написал вот это равно new tricky,
[01:20:43.520 --> 01:20:49.200]  бла-бла-бла, то опять нужно. Но если я просто завожу pointer, ну ладно, компилятору на самом деле
[01:20:49.200 --> 01:20:54.240]  не нужно ничего инстанцировать, и это компилируется вообще без ошибок. То же самое,
[01:20:54.240 --> 01:21:00.560]  если бы я ссылку завел. Если я завожу указатель или ссылку на тип, то это, что называется,
[01:21:00.560 --> 01:21:08.080]  не требует от типа быть complete type. Complete type – это тот, у которого определение есть,
[01:21:08.080 --> 01:21:17.120]  и оно корректно. Но заводить указатель или ссылку на тип вообще не нужно. Для этого вообще не
[01:21:17.120 --> 01:21:26.640]  нужно, чтобы тип обладал определением. Сейчас, а как мы можем создать ссылку? Мы же сразу должны
[01:21:26.640 --> 01:21:34.200]  унициализировать чем-то. Я, например, могу написать функцию, которая принимает ссылку на вот это.
[01:21:34.200 --> 01:21:43.280]  А, хорошо. И тут что-то делать, но к полям не обращаться. Я не знаю, эту ссылку передать куда-то
[01:21:43.280 --> 01:21:49.160]  еще. Вот это все прекрасно будет компилироваться, потому что я не создал объект типа трики. Ни разу
[01:21:49.160 --> 01:21:54.160]  нет в коде места, где компиляторе реально нужно знать, что такое трики под ним, что лежит. Это
[01:21:54.160 --> 01:22:02.360]  просто ссылка, которая как указатель используется. Вот этот факт, он один раз, даже не один, нам
[01:22:02.360 --> 01:22:15.400]  пригодится вскоре. Сайзов ссылки ему тоже не нужен. Сайзов ссылки – ссылка представляется,
[01:22:15.400 --> 01:22:24.560]  как указатель, неважно какой это тип. Размер указателя типа не зависит. Если я спрошу сайзов
[01:22:24.560 --> 01:22:37.040]  от T вот здесь, то, конечно же, он подставит все трики и все упадет. Просто сайзов от T – это не
[01:22:37.040 --> 01:22:41.880]  сайзов от ссылки, это сайзов от самого типа. Я напоминаю, сайзов от ссылки означает сайзов
[01:22:41.880 --> 01:22:50.480]  от самого типа. И поэтому такой вызов его заставит инстанцировать поля. А без этого и не нужно.
[01:22:50.480 --> 01:23:04.600]  Вот. Есть такая замечательная штука в C++, которая называется явное инстанцирование – explicit
[01:23:04.600 --> 01:23:12.160]  instantiation. Наверняка вы ни разу этим не пользовались, но если может кто-то пользовался,
[01:23:12.160 --> 01:23:21.000]  круто. 99% инстанцирований, которые вы делаете, они не явные implicit. Они происходят,
[01:23:21.000 --> 01:23:25.640]  когда вы начинаете использовать класс, и тогда компилятор вынужден подставить то,
[01:23:25.640 --> 01:23:46.160]  что вы сказали. Вот. Но на самом деле есть способ. Сейчас. Я попробую открыть страничку
[01:23:46.360 --> 01:24:07.240]  референс соответствующую. Да. Вот. На самом деле есть способ сказать компилятору явно – проинстанцируй
[01:24:07.240 --> 01:24:24.480]  сейчас, пожалуйста, вот это. Это называется explicit instantiation. Вот как это пишется. Вот пример.
[01:24:24.480 --> 01:24:34.840]  Вот, допустим, я хочу, а вот чтобы в этом месте кода компилятор явно сделал подстановку и
[01:24:34.840 --> 01:24:48.480]  сгенерировал соответствующий класс с подставленным T. Вот. Я могу так написать. И это проявит все
[01:24:48.480 --> 01:24:52.960]  ошибки компиляции, которые случились бы, если бы я вот заиспользовал этот класс явно. Ну,
[01:24:52.960 --> 01:25:01.840]  давайте, например, я напишу вот здесь вот. Только, по-моему, в локальном скопе нельзя делать.
[01:25:01.840 --> 01:25:27.280]  template class tricky inzip t-1. Вот. Все. Я явно запросил инстанцирование. Вот мы сказали required
[01:25:27.280 --> 01:25:34.680]  from here. Here – это 36-я строчка. 36-я строчка – это вот эта строчка. Он все еще nested не заводил,
[01:25:34.680 --> 01:25:39.800]  если мы хотим еще nested нам отдельно прописывать, да? Да. Если я хочу nested инстанцировать,
[01:25:39.800 --> 01:25:44.760]  я могу и так написать. Это же то же самое, что создать типа переменную такого типа,
[01:25:44.760 --> 01:25:53.240]  только не называть. Нет, это совсем не то же самое. Я не создаю никакую переменную. Я заставляю
[01:25:53.240 --> 01:25:59.840]  компилятор сделать подстановку. Мы просто называем типа, из-за этого он обязан все подставить, да? Да.
[01:25:59.840 --> 01:26:05.920]  Он в этот момент функции все тоже инстанцирует? Нет, конечно. Он делает ровно то, что я его
[01:26:05.920 --> 01:26:12.920]  попросил. Вот сейчас он сделал только инстанцирование класса tricky. Это как если бы я написал вот так.
[01:26:12.920 --> 01:26:20.280]  Но методы его он еще не инстанцировал. Чтобы заставить его еще и метод инстанцировать,
[01:26:20.280 --> 01:26:26.400]  я могу явно попросить инстанцировать метод. Например, я говорю template class такой-то,
[01:26:26.400 --> 01:26:39.440]  а я могу сказать template void tricky int-1, 2.2.int class. А это вот вообще закомментирую.
[01:26:39.440 --> 01:26:46.920]  И это закомментирую. Теперь я его заставил инстанцировать не просто класс, а конкретный
[01:26:46.920 --> 01:26:57.360]  метод этого класса. Вот. И я увидел, что... так, no member function in class. Вот бы можно было еще
[01:26:57.360 --> 01:27:14.480]  заставить его поинстанцировать вообще все. Ну вот, он проинстанцировал in class и,
[01:27:15.120 --> 01:27:23.960]  собственно, напоролся на те ошибки, которые там были. Вопрос. Зачем это может быть нужно?
[01:27:23.960 --> 01:27:33.760]  Это бывает нужно редко. Но зачем может быть нужно explicit instantiation? Кроме как... Во-первых,
[01:27:33.760 --> 01:27:40.560]  первое для чего. Чтобы проверить, что вы правильно написали код с данными подставленными типами.
[01:27:40.680 --> 01:27:46.240]  Потому что, когда вы просто написали шаблонный код, вы, значит, еще не факт, что...
[01:27:53.000 --> 01:27:59.200]  корректно его написали. Компилятор это не проверяет, пока вы не воспользовались. Вы можете таким вот
[01:27:59.200 --> 01:28:03.880]  методом заставить... таким вот способом заставить компилятор для данных конкретных типов сгенерировать
[01:28:03.880 --> 01:28:10.720]  вам определение, чтобы убедиться, что с этими типами все нормально. Вторая причина интересная.
[01:28:10.720 --> 01:28:18.680]  Что на самом деле ведь происходит, когда вы так пишете? Вы заставляете компилятор сгенерировать
[01:28:18.680 --> 01:28:31.960]  конкретный экземпляр этого класса. Вот представьте, у меня этот класс. Он в... ну вот, я пишу
[01:28:31.960 --> 01:28:41.920]  некоторых хедер. Шаблонный класс я определяю в хедере, в Вашнике. И здесь у меня... А мы типа
[01:28:41.920 --> 01:28:49.520]  это вынесем в другой этап компиляции и можно будет не компилировать каждый раз заново? С помощью
[01:28:49.520 --> 01:28:56.440]  явного инстанцирования можно добиться того, что вам не придется определение в хедере писать
[01:28:56.440 --> 01:29:03.280]  для некоторых типов. То есть обычно, когда вы инстанцируете, когда вы пишете шаблонные классы,
[01:29:03.280 --> 01:29:06.320]  вы в хедере пишете определение методов.
[01:29:11.280 --> 01:29:24.720]  Правильно? Потому что вы не можете... вы не можете их писать в cpp-шнике, линкер их не слинкует.
[01:29:24.720 --> 01:29:35.880]  Вам надо, чтобы уже на этапе компиляции были все определения видны. Ну иначе линкер не найдет
[01:29:35.880 --> 01:29:41.520]  соответствующее определение в хедере под тот метод, который вы определили в cpp-шнике. Потому что
[01:29:41.520 --> 01:29:49.920]  в хедере был шаблонный код, а в cpp-шнике вы написали конкретный. Ну или вы тем более в cpp-шнике
[01:29:49.920 --> 01:29:54.800]  написали шаблонный, и в хедере был шаблонный. Линкер не слинкует. Шаблоны — это сущность
[01:29:54.800 --> 01:30:00.840]  времени компиляции. Линкеры не умеют с шаблонами работать. Что вам позволяет делать явное
[01:30:00.840 --> 01:30:07.840]  инстанцирование? Вы можете написать в хедере вот такую штуку, и тогда у вас прям в хедере будет
[01:30:07.840 --> 01:30:16.080]  нешаблонное уже определение. Вы в этот класс подставили конкретные типы, и компилятор
[01:30:16.080 --> 01:30:22.200]  сгенерировал вам здесь определение класса, пока еще без определения методов, шаблон с подставленными
[01:30:22.200 --> 01:30:30.640]  типами. Это дает вам возможность для данных типов определение писать в cpp-шнике, определение методов,
[01:30:30.640 --> 01:30:36.360]  потому что их линкер уже сможет слинковать. Потому что в хедере таким образом появятся конкретные
[01:30:36.360 --> 01:30:42.280]  определения с конкретными типами, конкретные объявления с конкретными типами. А в cpp-шнике у вас
[01:30:42.280 --> 01:30:51.120]  будет определение с этими типами, и линкер слинкует тогда. Он слинкует только вот эти
[01:30:51.120 --> 01:30:57.520]  подставленные шаблоны, да? Конечно, для этих типов конкретных вы сможете слинковать. И на самом
[01:30:57.520 --> 01:31:03.200]  деле вы можете таким образом добиться того, что ваш класс разрешено использовать только с
[01:31:03.200 --> 01:31:09.680]  такими типами. Например, вы написали шаблон в хедере без определений, а дальше перечислили
[01:31:09.680 --> 01:31:14.280]  несколько типов, для которых написали явное инстанцирование. Например, template-void-tricky
[01:31:14.280 --> 01:31:19.120]  от int, template-void-tricky от double, еще там 10 типов. Но это игра копипасты же.
[01:31:19.120 --> 01:31:26.560]  Сейчас, ну еще раз, а любой шаблонный код это копипаста. Компилятор все равно генерирует
[01:31:26.560 --> 01:31:35.560]  конкретные экземпляры, когда вы типа подставляете. Но когда вы написали явное инстанцирование,
[01:31:36.280 --> 01:31:42.600]  и допустим header пользователю менять нельзя, тем самым вы разрешили пользователю определять
[01:31:42.600 --> 01:31:48.480]  методы только для вот этих типов. Вы сказали, мой класс, он шаблонный, но он только для таких
[01:31:48.480 --> 01:31:54.120]  типов работает. И если юзер хочет, он определит для каких типов ему надо, а для других будет
[01:31:54.120 --> 01:32:00.040]  нельзя, потому что в хедере этого не определено, явного инстанцирования нету, и все, уже в cpp-шнике
[01:32:00.040 --> 01:32:14.840]  ты ничего не сделаешь с этим. Вот такие дела. Это что касается чуть более подробно о правилах
[01:32:14.840 --> 01:32:24.840]  инстанцирования шаблонов. Ну а теперь переходим к самому приятному или не знаю какому. Возвращаемся
[01:32:24.960 --> 01:32:34.800]  к метапрограммированию. Теперь, когда мы поговорили про инстанцирование,
[01:32:43.240 --> 01:32:50.640]  самое время начать что-то писать на шаблонах. И пункт 15.2 будет
[01:32:50.640 --> 01:33:00.120]  базовые примитивы для шаблонного метапрограммирования. Что вообще такое шаблонное
[01:33:00.120 --> 01:33:05.400]  метапрограммирование? Ну мы уже так скользь его касались, у нас были функции, а теперь будут
[01:33:05.400 --> 01:33:11.960]  метафункции. Что такое метафункции? Это штуки, это на самом деле структуры, они по типам возвращают
[01:33:11.960 --> 01:33:23.400]  либо значения, либо другие типы. Вот. Самая простая метафункция, это, наверное, такая.
[01:33:31.480 --> 01:33:33.280]  Она называется Type Identity.
[01:33:33.280 --> 01:33:50.480]  В ней написано using type равно t. Это тождественная метафункция.
[01:33:50.480 --> 01:33:56.960]  Они все есть в STL. Начиная с C++20 есть.
[01:34:02.360 --> 01:34:07.920]  Ну какие мы с вами знаем метафункции? Мы, например, знаем функцию Remove Const. Она берет тип,
[01:34:07.920 --> 01:34:16.000]  снимает с него конст. Там написано Remove Const t type. Это то же самое, что и ты, только без конст.
[01:34:16.000 --> 01:34:21.880]  А, ну нам вот эта фигня интересна, когда мы хотим от какого-то выражения узнать, какой он тип,
[01:34:21.880 --> 01:34:29.360]  и вместо decal type можно вот это писать, да? Нет, это не совсем. Decal type — это штука,
[01:34:29.360 --> 01:34:40.080]  которая по значению дает тип, а это штука, которая по типу возвращает его сам. Ну мы со
[01:34:40.080 --> 01:34:50.760]  временем поймем, зачем это может быть нужно. Мы просто хотим, чтобы у нас все операции были,
[01:34:50.760 --> 01:34:59.240]  так сказать, унифицированные, что ли. То есть у нас есть вот, у нас будут какие-нибудь вещи,
[01:34:59.240 --> 01:35:11.960]  которые ожидают класс с using type внутри него. И это может быть, например, Remove Const от чего-то,
[01:35:11.960 --> 01:35:17.280]  и мы в нем залезаем type и посмотрим, какой type. Может быть, typeIdentity. Вот, ну можно сказать,
[01:35:17.280 --> 01:35:27.080]  что еще typeName, typeNameT, как обычно, using typeIdentityT — это то же самое, что typeName,
[01:35:27.080 --> 01:35:38.960]  typeIdentity, а T — 2.2.type. А это тождественная метафункция. Какие еще бывают метафункции?
[01:35:38.960 --> 01:35:53.400]  Ну, например, можно придумать метафункцию conditional. Значит, что такое conditional?
[01:35:53.400 --> 01:36:03.800]  Да, это условно. Ну, давайте напомню. Темплей typeName, не typeName, а bool.
[01:36:03.800 --> 01:36:23.320]  B — typeNameT, typeNameF, struct conditional. И здесь написано using type равно f. А еще и специализация,
[01:36:23.320 --> 01:36:39.480]  в которой написано template уже от двух штук. И здесь написано conditional от true,
[01:36:39.480 --> 01:36:51.240]  t, f. И здесь написано using type равно t. А у нас есть это, как называется? Тернарный оператор constexpr.
[01:36:51.240 --> 01:37:00.680]  Не понимаю вопроса. Что значит это? В плане, сейчас, можно ли написать type равно f, если b,
[01:37:00.680 --> 01:37:07.000]  типа, иначе? Ну, t, если b, иначе f. Как ты предлагаешь это написать? Ну, там,
[01:37:07.000 --> 01:37:21.560]  через тернарный оператор условно. А более конкретно? B? Ладно, окей. Ты понял
[01:37:21.560 --> 01:37:31.000]  проблему, да? Или не понял? Ну, типа, разные типы у тернарных. Да, не разные типы. Это оператор
[01:37:31.000 --> 01:37:46.280]  бывает над expression, а это типы. Ну, в любом случае, возвращаем значение. Нет, нет, это не читается
[01:37:46.280 --> 01:37:59.120]  просто. Проблема глубже гораздо. Это нечитаемая запись. Это не expression. T — это не expression.
[01:38:01.000 --> 01:38:12.080]  Ну, да. Ну, вот. Какой оператор может быть? Я же не могу написать t плюс f, например. Это тебя более...
[01:38:12.080 --> 01:38:19.640]  Ну, хорошо, int плюс f. Оператора плюс... Ну, да, наверное. Точно та же проблема. Я не могу использовать
[01:38:19.640 --> 01:38:26.040]  оператор над типами. В этом и смысл существования метафункций. Conditional — это и есть тернарный
[01:38:26.440 --> 01:38:32.800]  оператор, но над типами, это тернарный метаоператор, это и есть он над типами. Потому что мы не
[01:38:32.800 --> 01:38:37.260]  можем использовать оператор над типами, у нас должен быть метаоператор. Conditional — это он и
[01:38:37.260 --> 01:38:43.940]  есть. Conditional — это и есть аналог тернарного оператора для типа. Ну, по идее, да. Но мы не можем,
[01:38:43.940 --> 01:38:48.000]  конечно же, использовать обычный тернарный оператор, потому что в этом смысл Conditional заменить нам
[01:38:48.000 --> 01:38:55.840]  тернарный оператор для типа. Вот. А что такое Conditional-T? Conditional-T — это вот такая штука.
[01:38:55.840 --> 01:39:02.840]  removeConst, addConst, addRvelUreference, removeRvelUreference и так далее.
[01:39:02.840 --> 01:39:06.840]  Это все функции такие, преобразователи типов.
[01:39:06.840 --> 01:39:15.840]  Бывают метафункции, которые как бы возвращают значения по типу.
[01:39:15.840 --> 01:39:19.840]  Ну, например, template, typeName.
[01:39:19.840 --> 01:39:24.840]  Ну, банальное самое, это isSame, да, то есть проверка равны ли два типа.
[01:39:24.840 --> 01:39:29.840]  Давайте что-нибудь более интересное напишем. Ну, например, template, typeName.
[01:39:29.840 --> 01:39:34.840]  Что написать можно?
[01:39:34.840 --> 01:39:37.840]  Ну, я не знаю, typeName, typeStruct.
[01:39:37.840 --> 01:39:42.840]  Это не очень интересно, но мы это писали в первом семестре.
[01:39:42.840 --> 01:39:48.840]  Стракт из pointer и здесь будет static const bool value.
[01:39:48.840 --> 01:39:53.840]  Равно false.
[01:39:53.840 --> 01:39:54.840]  Вот.
[01:39:54.840 --> 01:40:05.840]  И дальше мы делаем специализацию для т-звездочек и говорим здесь true.
[01:40:05.840 --> 01:40:15.840]  И делаем, значит, опять template, typeName t.
[01:40:15.840 --> 01:40:21.840]  Но на этот раз уже const bool.
[01:40:21.840 --> 01:40:25.840]  Ну, на самом деле constexpr, правильно сказать,
[01:40:25.840 --> 01:40:42.840]  constant времени компиляции bool из pointer v от t равно isPointer от t 2.2.value.
[01:40:42.840 --> 01:40:43.840]  Вот.
[01:40:43.840 --> 01:40:46.840]  Но я не буду перечислять другие.
[01:40:46.840 --> 01:40:54.840]  Мы поняли, что вот это вот такие базовые штуки, которыми мы в принципе и так уже владеем.
[01:40:54.840 --> 01:41:03.840]  Давайте я просто открою список этих штук на cp-reference.
[01:41:03.840 --> 01:41:09.840]  Он находится в файле type-trade, все эти штуки.
[01:41:09.840 --> 01:41:11.840]  Сейчас вы увидите этот списочек.
[01:41:11.840 --> 01:41:13.840]  На самом деле, мы, кажется, его тоже уже открывали.
[01:41:13.840 --> 01:41:23.840]  Ну, то есть вот такие замечательные метафункции.
[01:41:23.840 --> 01:41:28.840]  Is void, is null pointer, is integral, is floating point, is array, is enum, is union class, bla-bla-bla-bla-bla.
[01:41:28.840 --> 01:41:32.840]  Все это интуитивно понятно.
[01:41:32.840 --> 01:41:38.840]  Is pointer, is a value reference, is member object pointer, is member function pointer, is fundamental, is arithmetic, is scalar.
[01:41:38.840 --> 01:41:47.840]  Своиства, связанные с конструированием, можно ли конструировать, нельзя ли.
[01:41:47.840 --> 01:41:52.840]  Значит, is same, is base of, is convertible и так далее.
[01:41:52.840 --> 01:41:59.840]  Впрочем, вам, наверное, должно быть непонятно, как реализована, по крайней мере, часть из них.
[01:41:59.840 --> 01:42:01.840]  На самом деле, большинство.
[01:42:01.840 --> 01:42:04.840]  Вот скажем, как реализована is constructible, мы пока не понимаем.
[01:42:04.840 --> 01:42:06.840]  Такое void-t.
[01:42:06.840 --> 01:42:08.840]  Где?
[01:42:08.840 --> 01:42:10.840]  Там было.
[01:42:13.840 --> 01:42:15.840]  Ну, нам вебуку будет видно.
[01:42:18.840 --> 01:42:20.840]  А, это, скорее всего...
[01:42:25.840 --> 01:42:27.840]  Очень полезно.
[01:42:34.840 --> 01:42:40.840]  Я, к сожалению, забыл пример, когда это нужно.
[01:42:40.840 --> 01:42:44.840]  Такой пример есть, но...
[01:42:52.840 --> 01:42:56.840]  А в чем реально смысл просто будет писать?
[01:42:56.840 --> 01:43:00.840]  Не сейчас, нет. Там есть пример, когда это нужно, я, к сожалению, не помню.
[01:43:01.840 --> 01:43:13.840]  Вот. Я хотел бы обратить внимание, прежде чем перейти к нетривиальным примерам, на парочку важных вещей отсюда.
[01:43:13.840 --> 01:43:17.840]  Для начала вот такой. Мы будем им часто пользоваться.
[01:43:17.840 --> 01:43:19.840]  Struct integral constant.
[01:43:21.840 --> 01:43:23.840]  Что это такое?
[01:43:23.840 --> 01:43:25.840]  Это такой тип...
[01:43:25.840 --> 01:43:27.840]  Играла константы.
[01:43:27.840 --> 01:43:29.840]  Нет.
[01:43:29.840 --> 01:43:30.840]  Это...
[01:43:30.840 --> 01:43:31.840]  Размечтался.
[01:43:31.840 --> 01:43:33.840]  Мы сейчас его реализуем.
[01:43:34.840 --> 01:43:36.840]  Значит, что такое integral constant?
[01:43:36.840 --> 01:43:41.840]  Template type name t, запятая t, v.
[01:43:41.840 --> 01:43:46.840]  Struct integral constant.
[01:43:48.840 --> 01:43:56.840]  И здесь написано static constant t value равно v.
[01:43:56.840 --> 01:43:59.840]  Вот, по сути, что такое integral constant.
[01:44:04.840 --> 01:44:08.840]  Ну, можно сказать, это константа времени компиляции.
[01:44:09.840 --> 01:44:12.840]  Вот. Что такое...
[01:44:13.840 --> 01:44:17.840]  А можно чуть подробнее, в чем смысл? Это вообще непонятно.
[01:44:21.840 --> 01:44:23.840]  Зачем это может быть нужно?
[01:44:23.840 --> 01:44:28.840]  Ну, самый простой пример, для чего это может быть нужно, это для того, чтобы говорить.
[01:44:28.840 --> 01:44:30.840]  Вот, например, isPointer.
[01:44:30.840 --> 01:44:34.840]  Это не static constant bool value равно false.
[01:44:34.840 --> 01:44:36.840]  А просто...
[01:44:38.840 --> 01:44:42.840]  integral constant bool false.
[01:44:42.840 --> 01:44:44.840]  Я говорю, isPointer.
[01:44:44.840 --> 01:44:48.840]  Это не что иное, как integral constant bool false.
[01:44:49.840 --> 01:44:52.840]  И эту строчку просто стираем.
[01:44:53.840 --> 01:44:57.840]  Я не хочу каждый раз писать static constant bool value равно чему-то.
[01:44:57.840 --> 01:45:00.840]  Я хочу писать integral constant с такими-то параметрами.
[01:45:00.840 --> 01:45:04.840]  И это и будет static constant bool value равно false.
[01:45:05.840 --> 01:45:08.840]  Но на самом деле есть еще лучшее.
[01:45:08.840 --> 01:45:15.840]  Есть тип bool constant.
[01:45:15.840 --> 01:45:17.840]  А template type...
[01:45:17.840 --> 01:45:19.840]  Значит, template bool...
[01:45:21.840 --> 01:45:23.840]  Не знаю, bool.
[01:45:23.840 --> 01:45:27.840]  Struct bool constant.
[01:45:29.840 --> 01:45:35.840]  Это integral constant с типом bool и значением bool.
[01:45:37.840 --> 01:45:42.840]  И на самом деле, вот здесь, вместо того, чтобы писать integral constant, я просто пишу bool constant.
[01:45:42.840 --> 01:45:44.840]  От false.
[01:45:44.840 --> 01:45:48.840]  А здесь я просто пишу bool constant от true.
[01:45:53.840 --> 01:45:55.840]  Понимаете теперь, зачем это?
[01:46:01.840 --> 01:46:04.840]  Вопрос, а почему integral constant это именно integral?
[01:46:04.840 --> 01:46:06.840]  Почему другой тип не может быть?
[01:46:07.840 --> 01:46:09.840]  Потому что...
[01:46:09.840 --> 01:46:15.840]  Числовыми параметрами шаблонов могут быть только integral типы до C++20, впрочем.
[01:46:16.840 --> 01:46:18.840]  А то сейчас это может быть не integral constant.
[01:46:18.840 --> 01:46:20.840]  Начиная с C++20...
[01:46:20.840 --> 01:46:21.840]  Я, кстати, не уверен.
[01:46:21.840 --> 01:46:27.840]  Но начиная с C++20, стало можно делать параметрами шаблонов и не только целочисленные типы.
[01:46:27.840 --> 01:46:29.840]  И не только bool.
[01:46:29.840 --> 01:46:30.840]  Но...
[01:46:30.840 --> 01:46:32.840]  К минимум, туда даблы можно, по-моему, запихать.
[01:46:32.840 --> 01:46:33.840]  Да, да.
[01:46:33.840 --> 01:46:35.840]  Да и некоторые классы теперь стало можно.
[01:46:35.840 --> 01:46:38.840]  Чуть позже обсудим, у нас время еще останется, мы обсудим.
[01:46:38.840 --> 01:46:42.840]  Но вот до C++20 integral constant было именно integral constant.
[01:46:42.840 --> 01:46:44.840]  Именно вот такая константа, такого типа.
[01:46:44.840 --> 01:46:45.840]  Вот.
[01:46:45.840 --> 01:46:47.840]  Она не обязательно бывает bool.
[01:46:47.840 --> 01:46:50.840]  Можно, например, придумать метафункцию, которая возвращает int constant.
[01:46:50.840 --> 01:46:51.840]  Например, rank.
[01:46:51.840 --> 01:46:53.840]  Знаете, такая функция rank.
[01:46:54.840 --> 01:46:56.840]  Что такое rank?
[01:46:56.840 --> 01:46:57.840]  Да-да-да.
[01:46:57.840 --> 01:47:00.840]  Максимальное количество линей независимого константа.
[01:47:00.840 --> 01:47:02.840]  Что такое rank?
[01:47:02.840 --> 01:47:03.840]  Да-да-да.
[01:47:03.840 --> 01:47:06.840]  Максимальное количество линей независимых строк.
[01:47:06.840 --> 01:47:07.840]  Нет.
[01:47:08.840 --> 01:47:11.840]  Rank – это другое, ты не понимаешь.
[01:47:11.840 --> 01:47:13.840]  Это количество измерения массива.
[01:47:14.840 --> 01:47:16.840]  Есть такая метафункция rank.
[01:47:18.840 --> 01:47:21.840]  Она говорит, какова размерность массива.
[01:47:21.840 --> 01:47:23.840]  Сколько звездочек, короче?
[01:47:24.840 --> 01:47:25.840]  Ну, типа.
[01:47:27.840 --> 01:47:28.840]  Вот, есть функция rank.
[01:47:28.840 --> 01:47:29.840]  Ну, это понятно.
[01:47:32.840 --> 01:47:33.840]  Да.
[01:47:33.840 --> 01:47:34.840]  Ну, рекурсивно.
[01:47:34.840 --> 01:47:39.840]  Просто мы снимаем одно измерение, и вот вся реализация.
[01:47:40.840 --> 01:47:41.840]  Что такое rank?
[01:47:41.840 --> 01:47:43.840]  Это просто integral constant size t – ноль.
[01:47:43.840 --> 01:47:48.840]  Специализация для массивов – это integral constant.
[01:47:48.840 --> 01:47:54.840]  Size t – такой же rank, как у t, без скобочек уже, и плюс один.
[01:47:54.840 --> 01:47:55.840]  Вот и все.
[01:47:55.840 --> 01:47:57.840]  Вот зачем нужны integral constant.
[01:47:58.840 --> 01:48:01.840]  Отсюда становится понятно, зачем нужен type identity.
[01:48:02.840 --> 01:48:03.840]  Например, для чего?
[01:48:03.840 --> 01:48:12.840]  Да для того же, чтобы мне не писать вот это, а писать этот type identity от f просто.
[01:48:15.840 --> 01:48:24.840]  Чтобы мне не повторять каждый раз using type равно, а говорить, что это type identity от такого-то параметра.
[01:48:24.840 --> 01:48:28.840]  Ну, это типа мы вместо, ну, как бы мы в логику вносим, в логику наследования.
[01:48:28.840 --> 01:48:29.840]  Да.
[01:48:29.840 --> 01:48:37.840]  Ну, у меня просто теперь, я не хочу повторять каждый раз вот этот using, я не хочу повторять каждый раз статик cons что-то там value.
[01:48:37.840 --> 01:48:40.840]  На самом деле здесь cons text поправильнее писать, но пока cons будем писать.
[01:48:40.840 --> 01:48:48.840]  Я просто буду говорить, что это type identity от f, и все понимают, что это имеется в виду, что вот, значит, он просто такая метафункция т.
[01:48:49.840 --> 01:48:52.840]  Вот еще одна прекрасная метафункция, даже две.
[01:48:52.840 --> 01:48:54.840]  Это conjunction и disjunction.
[01:48:56.840 --> 01:48:58.840]  Значит, что такое конъюнция?
[01:49:03.840 --> 01:49:04.840]  Template.
[01:49:09.840 --> 01:49:10.840]  Значит.
[01:49:19.840 --> 01:49:20.840]  Type name.
[01:49:25.840 --> 01:49:26.840]  Сейчас скажу.
[01:49:26.840 --> 01:49:29.840]  Значит, как я хочу пользоваться конъюнцией?
[01:49:29.840 --> 01:49:41.840]  Я хочу, чтобы конъюнция, это была такая штука, которая мне позволяет сделать и по всем типам.
[01:49:41.840 --> 01:49:43.840]  Вот я скажу, type name многоточие types.
[01:49:45.840 --> 01:49:48.840]  Struct conjunction.
[01:49:50.840 --> 01:49:51.840]  И здесь будет.
[01:49:53.840 --> 01:49:57.840]  Все-таки я напишу static const bool value равно.
[01:50:00.840 --> 01:50:02.840]  Types.
[01:50:02.840 --> 01:50:04.840]  Ну, тут может быть, конечно.
[01:50:04.840 --> 01:50:08.840]  Вот так мне надо написать, скорее всего.
[01:50:08.840 --> 01:50:09.840]  Как-то так.
[01:50:18.840 --> 01:50:25.840]  Ну, то есть, например, я говорю conjunction is pointer, запятая из, не знаю, что-то там.
[01:50:25.840 --> 01:50:26.840]  Значит.
[01:50:29.840 --> 01:50:35.840]  Из class, из default constructible, из что-то-нибудь еще.
[01:50:35.840 --> 01:50:37.840]  Из trivial or copyable.
[01:50:37.840 --> 01:50:39.840]  И я все это запихаю в conjunction.
[01:50:39.840 --> 01:50:42.840]  По сути, у нас как бы украли все операторы.
[01:50:42.840 --> 01:50:50.120]  еще из trivially copyable. я все это запихаю в conjunction. но по сути у нас как бы украли все операторы.
[01:50:50.120 --> 01:51:00.080]  я хочу метафункцию, которая принимает типы и делает и по ним по всем, но эти типы они сами
[01:51:00.080 --> 01:51:08.120]  метафункции. то есть я делаю такую функцию второго порядка. из этих метафункций собираю
[01:51:08.120 --> 01:51:16.000]  другую функцию. вот давайте я покажу вам это опять-таки на cpp-reference. вот такая замечательная вещь
[01:51:16.000 --> 01:51:31.200]  conjunction. вот что она делает. берет и ну можно ее вот так реализовать. то есть она берет что
[01:51:31.200 --> 01:51:42.360]  делает. говорит это conditional на самом деле. если value true, то conjunction остальных, а иначе
[01:51:42.360 --> 01:51:56.920]  просто вот это value. но можно сделать и через fold expression, начиная с... я вас обманул. то как я
[01:51:56.920 --> 01:52:01.240]  написал, это плохая реализация. здесь сказано почему. да, ну она правильная, но плохая.
[01:52:01.240 --> 01:52:13.920]  смотрите, вот я написал через fold expression, и это хуже, потому что в таком fold expression
[01:52:13.920 --> 01:52:19.640]  не инстанцируется все. и да, инстанцируется все. он развернет и инстанцирует все. а правильная
[01:52:19.640 --> 01:52:26.200]  реализация conjunction вот такая. тогда она не будет инстанцировать вот это. ну в смысле
[01:52:26.280 --> 01:52:33.040]  она не будет подставлять туда все остальные, если поймет, что ответ уже известен.
[01:52:37.520 --> 01:52:43.560]  она не будет разворачивать все уровни. вот так. не будет разворачивать все conjunction от всего подряд.
[01:52:43.560 --> 01:53:02.960]  да, это я, конечно, облажался, забыл. вот fold expression. это очень коротко, но так
[01:53:02.960 --> 01:53:13.280]  лучше не реализовывать. значит это not lazy. да, ну и последние две штуки. это true type и false
[01:53:13.280 --> 01:53:19.680]  type. вы, возможно, их встречали в своей жизни. что такое true type? это просто bool constant с
[01:53:19.680 --> 01:53:31.920]  параметром true. это уже не шаблон. true type это просто bool constant с параметром true.
[01:53:31.920 --> 01:53:47.560]  а false type это просто bool constant с параметром false. и на самом деле это даже не структура,
[01:53:47.560 --> 01:53:55.000]  это просто using. я просто скажу, что using false type это в точности то же самое,
[01:53:55.000 --> 01:54:01.600]  что bool constant с параметром false. а true type это bool constant с параметром true.
[01:54:01.600 --> 01:54:11.120]  вот. и вместо того, чтобы писать bool constant с параметром false, мы просто будем писать false type.
[01:54:11.120 --> 01:54:17.400]  еще короче, еще проще. вместо того, чтобы писать bool constant с параметром true,
[01:54:17.400 --> 01:54:23.120]  мы будем просто писать true type. по ощущениям мы сейчас делаем миллиард движений, чтобы писать
[01:54:23.120 --> 01:54:29.440]  на два симпла меньше. не два. на два умножить на количество метафункций, которые нам предстоит
[01:54:29.440 --> 01:54:38.840]  реализовать. это называется базовые примитивы для шаблонного метапрограммирования. дальше,
[01:54:38.840 --> 01:54:43.760]  всякий раз, когда вы захотите написать какую-то структуру, которая является метафункцией,
[01:54:43.760 --> 01:54:50.520]  возвращающей true, вы просто пишете это false type и все. такое много раз мы встречали. вот.
[01:54:50.520 --> 01:55:01.840]  пожалуй, это все. ну, аналогично conjunction, есть еще disjunction и negation.
[01:55:01.840 --> 01:55:07.920]  а последнее? negation. отрицание.
[01:55:07.920 --> 01:55:19.280]  вот. ну а теперь мы перейдем к самой замечательной части сегодняшнего вечера 15.3,
[01:55:19.280 --> 01:55:37.920]  которая называется SFINAE и enable if. до сих пор все метафункции, которые мы реализовали,
[01:55:37.920 --> 01:55:46.920]  они были тривиальными в каком-то смысле. все, что там происходило, это мы делали некоторые операции
[01:55:46.920 --> 01:55:56.040]  над какими-то константами, либо мы делали шаблонную рекурсию, уводя дальше, вызывая метафункции от
[01:55:56.040 --> 01:56:07.280]  меньшего числа аргумента. мы пока не делали ничего выходящего за рамки простых вот этих
[01:56:07.280 --> 01:56:14.160]  вот двух вещей. мы либо шаблонную рекурсию делали, специализацию шаблонную, либо просто делали вот так.
[01:56:14.160 --> 01:56:24.320]  все меняется, и к нам приходят новые совершенно неизведанные и огромные невероятные возможности
[01:56:24.320 --> 01:56:32.160]  шаблонного метапрограммирования, если мы внимательно вчитаемся в стандарт и обнаружим
[01:56:32.160 --> 01:56:40.680]  там одно маленькое правило инстанцирования шаблонов, которое я до сих пор не упоминал.
[01:56:40.680 --> 01:56:48.520]  вот я, честно говоря, даже не знаю, опять-таки люди, когда писали стандарт в первый раз, они
[01:56:48.520 --> 01:56:57.320]  осознавали последствия того, к чему приведет этот пункт. я не уверен, но, может, кстати, да,
[01:56:57.320 --> 01:57:07.680]  но маленький такой пунктик есть в правилах инстанцирования шаблонов. так называемое
[01:57:08.680 --> 01:57:15.520]  что это такое? представим себе,
[01:57:15.520 --> 01:57:26.240]  то у меня есть две функции шаблонных, и одна из них,
[01:57:26.240 --> 01:57:37.880]  одна, значит, вот устроена так, она принимает, ну, допустим, Т, а возвращает,
[01:57:37.880 --> 01:57:49.480]  Т, двоеточие, двоеточие, не знаю, value type, только type name надо написать,
[01:57:53.960 --> 01:57:55.080]  ну, не знаю, return,
[01:57:55.080 --> 01:58:13.760]  х, влевое, а вторая функция, она, она даже не шаблонная, она просто возвращает int,
[01:58:13.760 --> 01:58:16.440]  а называются они одинаково.
[01:58:22.440 --> 01:58:23.240]  значит, смотрите,
[01:58:23.240 --> 01:58:47.160]  допустим, я решил вызвать f от вектора, std vector int v равно 1, 2, 3, 4, 5,
[01:58:47.160 --> 01:58:54.200]  имф можно не писать, и так понятно, что int, правда, вектор надо все-таки заинклубить,
[01:58:54.200 --> 01:59:06.960]  вот, и решил вызваться от v, какая версия предпочтительней? ну, конечно же,
[01:59:06.960 --> 01:59:14.480]  вот эта, потому что она от одного аргумента, а вторая вообще от произвольного числа аргумента,
[01:59:14.480 --> 01:59:22.040]  конечно же, лучше выбрать f, хорошо, какой тип она будет возвращать?
[01:59:22.040 --> 01:59:26.160]  t, двоеточие, двоеточие, value type, что такое t? это v, от int тоже получается,
[01:59:26.160 --> 01:59:33.640]  чего? от int тоже, да, подождите, сначала от вектора, значит, какой тип она будет
[01:59:33.640 --> 01:59:43.440]  возвращать? t, value type, value type там int, значит int, и х, нулевое надо вернуть, ну, 1 должно
[01:59:43.440 --> 01:59:56.960]  вернуться, давайте выведем то, что она возвращает, 2 плюс плюс 11, метапрог, надеюсь,
[01:59:56.960 --> 02:00:06.200]  я нигде не совершил больше ошибок компиляции, нет, где-то все-таки совершил, а где в 23 строке
[02:00:06.200 --> 02:00:11.640]  я неправильно реализовал conditional, ну, конечно же, conditional должно быть от трех аргументов,
[02:00:11.640 --> 02:00:20.320]  bool b, я просто удалю это, короче, вы поняли, что она была за ошибка, вот, значит, компилируем,
[02:00:20.320 --> 02:00:46.360]  так что ли, constexpr написал, нет, все равно, там, конечно, просто t не нужно, а, t не нужно,
[02:00:46.360 --> 02:00:59.520]  конечно, нет, constexpr bool, я же шаблон объявляю, мне не нужно t, наконец-то, вернулся 1, а теперь
[02:00:59.520 --> 02:01:13.980]  давайте попробуем вызваться от int, ну, пойдем, наверное, логически c должно быть, да нет, нет,
[02:01:13.980 --> 02:01:31.940]  мы не упали как так и вот это как раз и есть тот так как сказать маленькая маленькая зернышка или
[02:01:31.940 --> 02:01:41.980]  я даже не знаю что маленькая семечка языка из которой произрастет огромное дерево облонного
[02:01:41.980 --> 02:01:51.180]  метапрограммирования это правило говорящие о том как компилятор должен вести себя если
[02:01:51.180 --> 02:01:58.180]  в ней не получилось инстанцировать объявление некоторые функции пусть у нас есть перегрузка
[02:01:58.180 --> 02:02:08.860]  функций и компилятор понимает что предпочтительнее вот некоторые из них выбирает ее тогда он
[02:02:08.860 --> 02:02:23.060]  пытается подставить т в ее объявление и вот тут у него может не получиться потому что при данном
[02:02:23.060 --> 02:02:30.700]  ты объявление некорректно именно объявление вот это супер важно именно объявление не определение
[02:02:30.700 --> 02:02:38.780]  а объявление вот если компилятор при перегрузке функций выбирает некоторую функцию и понимает
[02:02:38.780 --> 02:02:47.540]  что при данном ты ее объявление некорректно именно объявление то он не падает покуда у него
[02:02:47.540 --> 02:02:55.940]  есть другие версии он просто выбирает более предпочтительную из оставшихся а если бы я
[02:02:55.940 --> 02:03:12.300]  сделал вот здесь вот так вот значит x нулевое и вернул его да да результат просто 0 давайте я
[02:03:12.300 --> 02:03:21.500]  просто верну 0 верну result значит вот я даже не обратился квадратными скобками к вектору я
[02:03:21.500 --> 02:03:34.180]  просто сказал значит авто возвращаемый тип и вот так сделал вот сейчас я упаду
[02:03:38.060 --> 02:03:45.380]  потому что int is not a class struct or union type не получается обратиться к t ну нету там
[02:03:45.980 --> 02:03:59.340]  короче это придумал это придумал комитет по стандартизации вот если если во время
[02:03:59.340 --> 02:04:03.420]  инстанцирования объявления при перегрузке функции компилятор понимает что объявление
[02:04:03.420 --> 02:04:12.420]  некорректно он не падает покуда у него есть другие версии функции но если он инстанцировал
[02:04:12.420 --> 02:04:16.980]  объявление и объявление корректно то он начинает инстанцировать определение и вот тогда он уже
[02:04:16.980 --> 02:04:23.100]  падает если там ошибка при данном т раз и мы чтобы инстанцировать определение с аута не нужно
[02:04:23.100 --> 02:04:36.300]  ну типа получить result ну возможно вы правы и возможно здесь он бы упал в любом случае но
[02:04:36.300 --> 02:04:41.700]  тут у меня объявление это само по себе корректно в любом случае то есть вот это правило не сработает
[02:04:41.720 --> 02:04:45.660]  то есть гляда на объявление компилятор не понимает что что-то не так и ты сюда
[02:04:45.660 --> 02:04:50.920]  явно не годится компилятор подставляет в объявление и либо он понимает что ты сюда
[02:04:50.920 --> 02:04:55.700]  не годится либо не понимает и начинает инстанцировать определение вот тогда уже все если он source
[02:04:55.700 --> 02:05:01.020]  там наткнется на проблему он не пойдет другой функции но если он глядя на объявление сразу
[02:05:01.020 --> 02:05:06.420]  понимает что дchet эту версию не подходит хоть она и предпочтительно по правилам перегрузки он
[02:05:06.420 --> 02:05:11.980]  не выбирает ее выбирает оставшуюся а есть какие-то экзистенциальные проблемы в том чтобы еще и
[02:05:11.980 --> 02:05:21.340]  определение скомпилировать и проверить или это просто решили не делать я думаю что забыли слушайте
[02:05:21.340 --> 02:05:27.300]  я не знаю чем рука значит что что мне ну мало ли может просто есть конкретные проблемы почему
[02:05:27.300 --> 02:05:32.660]  нельзя это сделать не знаю что курил комитет когда это придумал я все это я на эти вопросы
[02:05:32.660 --> 02:05:38.900]  не умею я к сожалению не один из них я бы с удовольствием вместе с ними это
[02:05:38.900 --> 02:05:45.860]  попридумывал так или иначе это правило существует в языке c++ еще до исторических времен еще когда
[02:05:45.860 --> 02:05:54.060]  вы не родились оно существовало еще значит c++ 98 оно существовало в самом начале когда
[02:05:54.060 --> 02:06:02.500]  только шаблоны появились оно уже было кажется это правило ну или в 2003 вот или я так ненавязчиво
[02:06:02.500 --> 02:06:18.740]  признался что он хочет попробовать эту дурь вот отсюда сразу следует интересное следствие можно
[02:06:18.740 --> 02:06:27.540]  таким нехитрым способом используя этот ах да это называется с финайя замечательная аббревиатура я
[02:06:27.540 --> 02:06:33.140]  вам говорил что моя любимая тема в курсе тому семантика одна из двух вот это вторая из двух
[02:06:33.140 --> 02:06:43.300]  значит это называется substitution fail и резнотен эррор расшифровывается так ну на самом деле я
[02:06:43.300 --> 02:06:49.180]  даже не знаю что из этого наиболее любимая сейчас мы с вами увидим много всего интересного
[02:06:49.180 --> 02:06:56.980]  я говорю заочно поэтому не настолько к сожалению да к сожалению да к сожалению вот я я уже
[02:06:56.980 --> 02:07:02.540]  говорил что очень жаль что у нас так вот вышло особенно еще эти выходные не получается увидеть
[02:07:02.540 --> 02:07:09.740]  ваши восторженные лица глядящие на это все божественное изобретение тем не менее давайте
[02:07:09.740 --> 02:07:19.340]  теперь придумаем нехитрый из этого вытекающий способ как научиться диспатчить между ну скажем
[02:07:22.980 --> 02:07:23.660]  ну скажем
[02:07:26.860 --> 02:07:28.420]  функция вот
[02:07:32.700 --> 02:07:37.780]  то я могу написать функцию которая принимает int возвращает double и другую которая принимает
[02:07:37.820 --> 02:07:46.620]  возвращает вектор и типа чтобы он выбрал правильную давайте такой я вам задам вопрос вот представьте
[02:07:46.620 --> 02:08:00.340]  что я хочу устроить диспатч следующий я хочу выводить один если моя мой те это коллабл то
[02:08:00.340 --> 02:08:13.340]  есть круглые скобочки применимы к нему и 0 иначе что надо написать ну что что-то типа стд
[02:08:13.340 --> 02:08:26.140]  conditional круглые скобочки какие круглые скобочки и к с точки круглые скобочки значит я хочу чтобы
[02:08:26.140 --> 02:08:31.420]  если у объекта типа t есть оператор круглые скобочки ну допустим без аргументов или от
[02:08:31.420 --> 02:08:44.020]  int то я могу то я попаду сюда а иначе нет как мне этого добиться давайте кто-нибудь это легко мне
[02:08:44.020 --> 02:08:50.700]  надо написать некоторые такой возвращаемый тип чтобы если у их есть круглые скобочки он был
[02:08:50.700 --> 02:08:58.620]  корректен а если нет тот был бы и на и был и нет подожди на был и мы еще и пока декол тайт какой
[02:08:58.620 --> 02:09:07.100]  небо хочу в лоб да смотрите декол тайт а от чего
[02:09:07.100 --> 02:09:21.260]  но видимо а ты в самой дупой реализации круглые скобочки да но если я так напишу у меня получится
[02:09:21.260 --> 02:09:25.420]  возвращаемый тип такой же как у их с круглой скобочки а я хочу чтобы настоящий это возвращаемый
[02:09:25.420 --> 02:09:34.180]  тип все-таки был им что же мне сделать я теперь conditional обернуть ваш ну вот это обернуть
[02:09:34.180 --> 02:09:41.620]  conditional conditional декол тайп от икс запитая инд запитая инд что ли или чего нет подождите
[02:09:41.620 --> 02:09:46.260]  первый аргумент в кондиционе должен быть буль кондициону а бульта какой там будет
[02:09:46.260 --> 02:09:52.260]  одно еще какой-нибудь функцию завести которая проверяет совпадение может быть этот интеграл
[02:09:52.260 --> 02:09:59.660]  что-то там вот этого типа так короче все гораздо проще не надо никаких метафункций у нас есть
[02:09:59.660 --> 02:10:09.500]  оператор запитая помните меня спрашивали в октябре или в сентябре запитая смотрите я делаю очень просто
[02:10:13.980 --> 02:10:23.740]  что ну или вот так спасибо большое ну смотрите я сказал возвращаемый тип этой штуки такой же как
[02:10:23.740 --> 02:10:29.380]  вот такое выражение икс круглые скобочки запитая 0 какой тип этого выражения и конечно потому что
[02:10:29.380 --> 02:10:36.180]  тип этого выражения это тип второй его части что оператор запитая но только это выражение
[02:10:36.180 --> 02:10:45.580]  некорректно если у икс нет круглых скобочек какой у нас вот поэтому теперь давайте я заведу
[02:10:45.580 --> 02:11:02.220]  например стд фанкшн стд фанкшн int f равно вот такому
[02:11:04.900 --> 02:11:13.500]  значит у меня есть функция f так нет f плохо g и я вызываюсь от g а потом вызываюсь от
[02:11:13.500 --> 02:11:19.460]  им та стд фанкшн наверное у меня не за инклуженно сейчас за инклудим
[02:11:19.460 --> 02:11:34.860]  вот теперь если я вызываюсь от g я попадаю сюда ну короче просто просто сами смотрите сейчас будет
[02:11:34.860 --> 02:11:48.300]  все как надо поняли как это работает это называется кома трик трюк с запятой
[02:11:54.300 --> 02:11:59.940]  с помощью оператора запитая я добиваюсь того что у меня возвращаемым типе присутствует некомпилируемые
[02:11:59.940 --> 02:12:04.300]  выражения если мне не нужно чтобы они компилировались но возвращаемый тип настоящий
[02:12:04.300 --> 02:12:09.140]  все-таки такой как мне нужно в итоге потому что запитая она дает такой тип как и правая часть
[02:12:12.140 --> 02:12:12.660]  понятно
[02:12:16.260 --> 02:12:27.100]  понравилось вам но это какой-то хак языка типа да вообще свина это хак языка только я не
[02:12:27.100 --> 02:12:35.980]  могу понять это хорошо или плохо это великолепно значит для использования кажется что это хорошо но
[02:12:35.980 --> 02:12:44.220]  возможно есть некоторые нюансы ну нюансов много сейчас мы их обсудим на самом деле вот до
[02:12:44.220 --> 02:12:52.820]  изобретения c плюс плюс 20 до концептов именно большая часть тайп трейтов которые оперируют
[02:12:52.820 --> 02:12:58.700]  возможностями наличие операции примерно так и были устроены ну то есть они устроены на том что
[02:12:58.700 --> 02:13:06.220]  компилятор от диспанча то в ошибку компиляции то нет он просто за счет свиноге оно отваливается
[02:13:06.220 --> 02:13:18.780]  и вы от нас остается только нужная версия это такое прям в лоб свинайя свиноге а я хочу написать
[02:13:18.780 --> 02:13:32.620]  значит сейчас некоторый гаджет если можно так вырезаться который бы это вот это вот добро
[02:13:32.620 --> 02:13:38.780]  сделал менее коринжевым для использования то есть если вам придется каждый раз самим вот
[02:13:38.780 --> 02:13:44.940]  такую штуку изобретать ну то есть вот с этим декл-тайпом это как-то совсем есть значит готовый
[02:13:45.100 --> 02:13:52.700]  опять-таки шаблончик примитив который позволяет вам во всех большинстве таких ситуаций
[02:13:59.100 --> 02:14:00.340]  ну скажем так
[02:14:00.340 --> 02:14:06.380]  нормально
[02:14:08.620 --> 02:14:18.540]  нормальный код писать называется enable if значит enable if такая штука которая позволяет вам то
[02:14:18.540 --> 02:14:23.020]  выключить то включить версию функций в зависимости от какого-то компл-тайм условия
[02:14:23.020 --> 02:14:33.420]  ну например там этот мы правда еще не умеем с вами реализовывать метафункции в духе из
[02:14:33.420 --> 02:14:41.020]  класс из колоб из инвокабл и так далее но давайте например я вам напишу то же
[02:14:41.020 --> 02:14:46.420]  самое через enable if вот давайте я заведу какую функцию на h у меня будет такая функция
[02:14:46.420 --> 02:14:57.900]  template type name t void h и я хочу чтобы она вызывалась только для вещей которая инвокабл а вторая
[02:14:57.900 --> 02:15:04.540]  чтобы вызывалась только лишь для ну а вторая для всех остальных да ну и к тому же мне здесь
[02:15:04.540 --> 02:15:09.140]  неудобно что мне приходится писать вот здесь вот переменное число аргументов я хочу чтобы
[02:15:09.140 --> 02:15:15.620]  у меня тоже был здесь один аргумент просто вот это бы вызывалась только для инвокабла вот это
[02:15:15.620 --> 02:15:21.060]  только для ней инвокабл что мне делать значит давайте я использую штуку под названием enable if
[02:15:21.060 --> 02:15:40.140]  значит как это пишется значит стд ну пишется это вот так type name равно стд enable if t от
[02:15:40.140 --> 02:15:44.060]  стд инвокабл
[02:15:49.180 --> 02:15:49.860]  от v
[02:15:53.460 --> 02:15:54.540]  без аргументов
[02:15:56.980 --> 02:16:04.740]  а ну аргумент t а больше аргументов не нужно кажется вот так а так это у меня угловая скобка
[02:16:04.740 --> 02:16:09.420]  закрылась от t это угловая скобка это инвокабл это угловая скобка от моего шаблона и
[02:16:09.820 --> 02:16:15.380]  вроде все вот значит
[02:16:20.500 --> 02:16:27.780]  я пока не уверен что это сработает сейчас сейчас я проверю дать не сработала потому что потому что
[02:16:33.180 --> 02:16:36.620]  а потому что это вой а мне надоим
[02:16:39.420 --> 02:16:49.060]  давайте и сделаем а так теперь у меня нету этого значит а потому что я написал инвокабл
[02:16:49.060 --> 02:16:56.420]  надо из инвокабл хорошо давайте напишем из инвокабл из инвокабл напоминаю это метафункция
[02:16:56.420 --> 02:17:00.740]  пока мы не знаем как она реализована мы предполагаем что нужные нам type traits то есть
[02:17:00.740 --> 02:17:07.580]  проверка свойств уже реализованы они сами тоже реализовали нет типа почти ну почти кстати да
[02:17:07.580 --> 02:17:13.460]  мы на самом деле почти и реализовали но можно сказать что мы ее вскоре реализуем нормально ну по
[02:17:13.460 --> 02:17:20.060]  сути да вот но в общем есть метафункция которая примерно так и работает которая проверяет инвокабл
[02:17:20.060 --> 02:17:26.340]  или нет и дальше есть метафункции наиболы в которая вот так вот устроена значит давайте
[02:17:26.340 --> 02:17:33.260]  еще раз третий раз попробую скомпилировать вот это к сожалению работает потому что потому что
[02:17:33.260 --> 02:17:42.620]  непонятно что выбрать непонятно значит действительно ну и это от одного ты и это от одного ты а
[02:17:42.620 --> 02:17:57.780]  мне получается обе подходят вызов неоднозначен давайте я сначала объясню как быть как работать
[02:17:58.380 --> 02:18:04.420]  а потом мы поймем как исправить проблему с ней назначить вызова что такое наиболы наиболы это
[02:18:04.420 --> 02:18:14.300]  такая структура в которой первым параметром передается буль шаблонным а вторым по у нее
[02:18:14.300 --> 02:18:20.740]  еще есть не обязательно и второй параметр но про него пока забудем значит что эта штука делает
[02:18:21.740 --> 02:18:25.540]  она просто в себе
[02:18:28.820 --> 02:18:32.540]  да я ее просто реализую сейчас я вам сейчас покажу как она устроена значит что такое наиболы
[02:18:32.540 --> 02:18:42.780]  это такая штука template буль б type name t равно void и она
[02:18:42.780 --> 02:18:56.980]  стракт enable if устроена так а вот так она устроена но у нее есть специализация на
[02:18:56.980 --> 02:19:11.180]  случай если буль был true значит template type name t enable if true t по моему аргумент по умолчанию можно
[02:19:11.180 --> 02:19:18.860]  уже не писать и тогда она является наследницей type identity от ты
[02:19:27.380 --> 02:19:35.140]  скорее всего ничего не понятно пока как это работает смотрите структура enable if это либо
[02:19:35.140 --> 02:19:44.260]  пустая структура либо структура в которой написано using type равно t вот и весь трюк
[02:19:48.260 --> 02:19:54.860]  если вы enable if мы передаем первым аргументом то есть по сути единственным обязательным
[02:19:54.860 --> 02:20:01.340]  аргументом true то мы попадаем версию в которой написано using type равно t но
[02:20:01.340 --> 02:20:07.300]  т по умолчанию void если мы передаем false то в ней первым аргументом то в ней ничего не
[02:20:07.300 --> 02:20:15.260]  написано это просто пустая структура а дальше у нас есть как обычно using template буль б type name
[02:20:15.260 --> 02:20:23.380]  t равно void кстати может быть даже вот здесь не надо писать так а достаточно только вот
[02:20:23.380 --> 02:20:36.860]  здесь аргумент по умолчанию передать using enable if t равно type name enable if от bt 2.2.type
[02:20:36.860 --> 02:20:49.060]  смотрите что происходит если мы в эту функцию передадим тип который не инвокабл то вы
[02:20:49.060 --> 02:20:55.500]  enable if первым аргументом подставится false это значит что enable if это будет структура с
[02:20:55.500 --> 02:21:02.620]  пустым телом а значит enable if t попробует залезть в type которого там нет ну это похоже на наш
[02:21:02.620 --> 02:21:09.260]  первый пример где было value type которого нет enable if t это штука которая такая enable if с
[02:21:09.260 --> 02:21:15.980]  такими параметрами 2.2.type но там нет 2.2.type там потому что false мы в пустой структуре поэтому
[02:21:15.980 --> 02:21:22.380]  вот этот тип не корректен но это шаблонный аргумент по умолчанию обратить внимание у меня
[02:21:22.380 --> 02:21:29.060]  написано type name не дано имя шаблонного аргумента и написано равно вот это вот хрень это шаблонный
[02:21:29.060 --> 02:21:32.860]  аргумент без имени который имеет вот такое значение по умолчанию соответственно когда
[02:21:32.860 --> 02:21:40.660]  я вызываю эту функцию от же не компилируем если нужен да когда я вызываю функцию от чего-то
[02:21:40.660 --> 02:21:48.060]  инвокабл то это работает потому что enable if t по умолчанию автоматически представляется и там
[02:21:48.060 --> 02:21:56.020]  true ну и хорошо там есть какой-то тип по умолчанию который будет равен void ну и бог с ним но если
[02:21:56.020 --> 02:22:03.580]  я вызовусь от единицы это уже не скомпилируется потому что там нету этого типа вот от int вызваться
[02:22:03.580 --> 02:22:10.220]  нельзя можно только от инвокабл вызваться потому что no type named type и структ enable if false
[02:22:10.220 --> 02:22:10.860]  void
[02:22:18.780 --> 02:22:24.140]  а теперь как я могу сделать перегрузку то есть теперь я таким образом добился функции которая
[02:22:24.140 --> 02:22:29.780]  работает только для инвокабл типов а для ней инвокабл она просто выдает ошибку компиляции но
[02:22:29.780 --> 02:22:34.460]  это пока я не очень многого добился что я мог бы так просто напрямую вызывать ик здесь круглыми
[02:22:34.460 --> 02:22:39.100]  скобочками и оно бы падала если бы это был не вокабл чего интересного но я могу добиться
[02:22:39.100 --> 02:22:48.740]  перегрузки я могу сказать вот здесь вот я давайте эту строчку скопи пащу и здесь напишу вот так
[02:22:48.740 --> 02:22:59.660]  type name равно стэмин т не стд инвокабл в от казалось бы я могу так написать на самом деле так еще
[02:22:59.660 --> 02:23:08.420]  не будет работать сейчас скажу как надо чтобы работал почему не будет вот здесь есть очень
[02:23:08.420 --> 02:23:18.180]  тонкий момент что все еще не понятно что лучше перегрузки а тонкий момент заключается в том что
[02:23:18.180 --> 02:23:22.500]  я переопределяю функцию с таким же набором шаблонных аргументов
[02:23:29.700 --> 02:23:38.140]  сейчас так что ну да у меня была функция с одним шаблонным аргументом обязательным и другим
[02:23:38.140 --> 02:23:43.180]  шаблонным аргументом являющимся типом имеющим такое значение по умолчанию я пытаюсь
[02:23:43.180 --> 02:23:45.460]  переопределить функцию с таким же набором
[02:23:51.060 --> 02:23:54.780]  аргументов но
[02:23:57.860 --> 02:24:04.820]  с другим значит значением аргумента по умолчанию
[02:24:04.820 --> 02:24:13.820]  ну так нельзя ну типа как бы шаблонные сигнатуры не отличаются я пытаюсь сказать нельзя как-нибудь
[02:24:13.820 --> 02:24:19.300]  закостылить это добавить там еще один фейковый тейп на им правильно так мы сейчас и сделаем мы
[02:24:19.300 --> 02:24:25.940]  только костыль заключается вот в чем просто надо написать не так ура а надо написать вот так
[02:24:35.820 --> 02:24:36.860]  что
[02:24:43.820 --> 02:24:50.380]  теперь у меня разные шаблонные сигнатуры но это вообще ну что смотрите а
[02:24:59.820 --> 02:25:03.820]  я написал но во первых давайте проверим что это работает а может я вас обманул да
[02:25:03.820 --> 02:25:09.340]  теперь это работает и в одном случае один другом 0 красиво правда
[02:25:09.340 --> 02:25:19.220]  американская мечта смотрите
[02:25:22.620 --> 02:25:26.860]  ну вопер попробуйте это распарсить вообще почему корректно то что-то написано
[02:25:26.860 --> 02:25:35.460]  здесь написано первый аргумент t а второй аргумент это enable if t с шаблонными параметрами
[02:25:35.460 --> 02:25:41.260]  вот такими которые по умолчанию равен true а что такое enable if t вот с такими шаблонными
[02:25:41.260 --> 02:25:50.660]  параметрами стук только эта структура нет enable if t это using enable if это структура в которой
[02:25:50.660 --> 02:25:58.620]  либо есть тип type либо ничего нет а enable if t это либо буль либо некорректный тип
[02:25:58.620 --> 02:26:07.460]  если я вызываюсь от g я вызываюсь от инвокабл тогда компилятор вот это вот превращает в ну
[02:26:07.460 --> 02:26:14.100]  для компилятора это превращается в стимплей type name t запятая буль равно true потому что
[02:26:14.100 --> 02:26:27.980]  enable if t от true запятая буль это в точности буль я правильно понимаю как бы завел шаблонный
[02:26:27.980 --> 02:26:32.780]  аргумент буль по умолчанию который равен true но я мог бы ему имя дать если хотите но это не
[02:26:32.780 --> 02:26:39.820]  нужно потому что я не использую его а зачем нам нужно что он равен час я просто придал
[02:26:39.820 --> 02:26:49.820]  этому аргументу какое-то значение по умолчанию вот зачем ему вообще какое-то значение по умолчанию
[02:26:49.820 --> 02:26:58.180]  придавать понятно но чтобы функции не писать да да чтобы чтобы мне не приходилось его передавать
[02:26:58.180 --> 02:27:05.100]  явно туда а я правильно понимаю что мы можем тогда на самом деле не только тру написать и false
[02:27:05.100 --> 02:27:09.300]  и даже в этой строчке оно не упадет но потенциально сломается дальше потому что статическое поле
[02:27:09.300 --> 02:27:19.500]  какое стати чего у нас у enable if разве не статик поле у enable if вообще нет поле у него только
[02:27:19.500 --> 02:27:30.900]  using есть using type равно t либо ничего сейчас тогда я перестал понимать как мы туда присвоили true
[02:27:30.900 --> 02:27:38.860]  и вот этот тип если инвокабл это true то вот этот тип это в точке это он равен буль а
[02:27:38.860 --> 02:27:46.180]  если инвокабл это false то это просто некорректный тип и эта перегрузка отваливается но эта версия
[02:27:46.180 --> 02:27:50.940]  функции отваливается компилятор пытается подставить и понять что написано ну он пытается
[02:27:50.940 --> 02:27:55.660]  расшифровать вот эту вот карказиабру чтобы понять какой тип второй у второго шаблонного
[02:27:55.660 --> 02:27:59.980]  аргумента и он видит что в этом случае у второго шаблонного аргумента написано
[02:27:59.980 --> 02:28:06.300]  bool равно true и компилятор говорит окей а у этого написано ничего отваливается просто объявление
[02:28:06.300 --> 02:28:10.700]  и компилятор такой ну забьем тогда на это и у меня стоит только одна версия функции ладно
[02:28:10.700 --> 02:28:18.900]  окей понятно раньше у него было в одном случае написано type name t type name равно что-то там а в
[02:28:18.900 --> 02:28:24.820]  другом случае type name type name равно что-то другое и это не работало компилятор не может различить
[02:28:24.820 --> 02:28:29.700]  две версии лишь по значениям аргумент умолчанию но тут другая ситуация тут первый аргумент
[02:28:29.700 --> 02:28:34.060]  одинаковый а вот второй аргумент либо буль либо вообще некорректный тип и тогда мы просто
[02:28:34.060 --> 02:28:39.620]  забиваем на эту перегрузку поэтому это работает вот так работает перегрузка с помощью enable if
[02:28:39.620 --> 02:28:47.580]  значит если вы хотите в своем коде сделать какую-нибудь функцию работающий только при
[02:28:47.580 --> 02:28:52.460]  условии что ваш ты это какой-то специальный тип то вы можете использовать вот такое вот
[02:28:52.460 --> 02:28:59.100]  заклинание значит enable if с помощью этого же вы можете включать выключать то есть вы можете
[02:28:59.100 --> 02:29:08.740]  делать перегрузку по признаку у ваш ваш тип как бы такой или другой давайте я вам покажу
[02:29:11.740 --> 02:29:14.620]  страничку носить переференс посвященную на и был и фунт
[02:29:22.460 --> 02:29:32.260]  в принципе там похожие примеры приведены ну давайте мы на них глянем вот
[02:29:36.820 --> 02:29:44.860]  ну вот да здесь написано распространенная ошибка это вот объявить два два шаблона
[02:29:44.860 --> 02:29:48.740]  функции которые отличаются только значением шаблонного аргумента по умолчанию так работать не
[02:29:48.740 --> 02:29:56.340]  будет а вот так будет это именно то что мы и сделали вот ну какие еще здесь есть примеры
[02:30:02.380 --> 02:30:06.060]  ну вот да например предположим вам хочется
[02:30:13.060 --> 02:30:17.180]  значит вот вы делаете констракт от некоторого типа который тривили
[02:30:17.180 --> 02:30:29.900]  default constructible значит смотрите как здесь написано я хочу сделать перегрузку вот
[02:30:29.900 --> 02:30:35.100]  если тип тривили default constructible то я просто ничего не делаю вывожу мой тип тривиально
[02:30:35.100 --> 02:30:42.100]  конструируемый я не вызываю плейс нитю а если нет ревел и вход констракт его я вызываю
[02:30:42.100 --> 02:30:47.780]  плейс нитю по этому адресу но из тривили дефолта ничего делать не надо конструктор не надо тратить
[02:30:47.780 --> 02:30:55.140]  время вот например или если он еще конструируемым вот а ну это уже другой пример вот что я пишу
[02:30:55.140 --> 02:30:59.900]  я пишу возвращаемый тип просто вот такой я уже не использую вот этот трюк с шаблонным аргументом
[02:30:59.900 --> 02:31:05.860]  вторым я просто возвращаемым тип пишу вот такое enable if из тривили default constructible t value
[02:31:06.860 --> 02:31:13.180]  какой будет тип у этого у этого будет тип void потому что аргумент по умолчанию у enable if void
[02:31:13.180 --> 02:31:23.780]  вот и соответственно тип этого будет либо void либо некорректный тип в противоположности
[02:31:23.780 --> 02:31:28.780]  этому у этого будет либо некорректный тип либо void то есть из этих функций ровно одна будет с
[02:31:28.780 --> 02:31:33.700]  корректным объявлением туда он и пойдет и это будет работать здесь вместо того правда ли это из
[02:31:33.700 --> 02:31:49.300]  тривили дефолт констракт и ну вот на самом деле мы с вами почти все прайну я в общем
[02:31:49.300 --> 02:31:55.900]  почти сказал то что хотел и наша ближайшая цель это научиться реализовывать вот эти все
[02:31:55.900 --> 02:32:02.260]  тайп трейд и ну не прям вообще все но идеи на научиться реализовывать тайп трейд и в которых
[02:32:02.260 --> 02:32:13.060]  корректность зависит от того есть ли что-то у данного типа особенно вот вот мне сегодня сейчас
[02:32:13.060 --> 02:32:19.900]  надо будет уже пораньше закончить мы кстати без перерыва сегодня наверное минут через 5-10 мы
[02:32:19.900 --> 02:32:28.180]  закончим на сегодня вот как компилятор соблюдает правила что он не должен рассматривать как
[02:32:28.180 --> 02:32:34.500]  кандидат перегрузки данную функцию как соблю а как компилятор все остальные правила соблюдает так
[02:32:34.500 --> 02:32:44.380]  и это почему тебя остальные правила не не задавали не вызывали такого вопроса ну в плане это не
[02:32:44.380 --> 02:32:53.860]  особо сложно или но это просто еще одно правило выбора версии при перегрузке что тебя смущает это
[02:32:53.860 --> 02:33:01.340]  них сложнее чем все то что мы обсуждали раньше для компилятора но просто какой-то трюк но при этом
[02:33:01.340 --> 02:33:11.700]  его кажется поддержать ну словно настолько же легко и как бы но типа в общем я не понимаю вопроса но
[02:33:11.700 --> 02:33:24.900]  ну пилятор поддерживает это несложно я разберу два примера сейчас интересно вот я хочу показать вам
[02:33:24.900 --> 02:33:31.780]  мы вот эти вот штуки мы видимо начнем следующий раз реализации их наш цель научиться реализовывать
[02:33:31.780 --> 02:33:39.780]  проверка наличия методов классе а также вот изнофрому в констракте был но на самом деле мы
[02:33:39.780 --> 02:33:43.060]  это почти уже понимаем как реализовать там только есть некоторые нюансы которые надо
[02:33:43.060 --> 02:33:47.980]  обсудить то есть все делается через вот этот декл-тайп с запятой в принципе идея уже должна
[02:33:47.980 --> 02:33:58.300]  быть вам понятно вот я хочу отдельно на некоторые из этих посмотреть type traits и вот тот type traits
[02:33:58.300 --> 02:34:10.100]  который мне кажется интересным это из класс а посмотрите пожалуйста
[02:34:13.100 --> 02:34:18.700]  как реализовать из класс как проверить что тип является классом
[02:34:18.700 --> 02:34:22.740]  в плане не структурой
[02:34:22.740 --> 02:34:30.420]  нет в плане либо классом либо структурой но не интон например
[02:34:30.420 --> 02:34:39.460]  так стоп какое произведение класса инт это не класс здравствуйте
[02:34:39.460 --> 02:34:47.340]  нет инт это не класс класса но в целом самое время узнать да да да да да но сейчас блин миша
[02:34:47.340 --> 02:34:53.500]  у тебя такие экзистенциальные вопросы то почему синтаксис и фа такой я не знаю нет ладно это
[02:34:53.500 --> 02:34:59.460]  нормально в конце года у людей возникают вопросы там уровня что такое переменная иногда это
[02:34:59.460 --> 02:35:06.380]  нормально но в питоне все этот класс типа а у нас плюсы нет инт это не класс а что некласс
[02:35:06.380 --> 02:35:15.180]  окей прочитай это не класс базовые типы это не класса да значит смотрите как
[02:35:15.180 --> 02:35:26.260]  устроено определение из класс из класс это вот такая структура которая наследник декл-тайп
[02:35:26.260 --> 02:35:31.180]  от detail тест шаблонным параметром тет нал птр что это такое
[02:35:34.180 --> 02:35:43.700]  тест это такая функция которая принимает либо вот это либо ничего
[02:35:56.380 --> 02:36:02.140]  либо переменный 4 аргумент что это такое это указатель на член типа инт
[02:36:04.740 --> 02:36:13.420]  смотрите как мы различаем класс от некласса если наш тип это класс то вот эта версия
[02:36:13.420 --> 02:36:19.100]  предпочтительней но она в любом случае предпочтительней просто если тип это не
[02:36:19.100 --> 02:36:23.820]  класс то это некорректный тип только у классов можно брать указатели на члены
[02:36:27.260 --> 02:36:37.060]  вы понимаете уровень кринжа я не знаю уровень мы делаем перегрузку мы делаем функцию которая
[02:36:37.060 --> 02:36:41.460]  принимает либо инт 2.2006 звездочка либо что угодно каких угодно типов
[02:36:44.740 --> 02:36:53.740]  и пытаемся пытаемся вызвать эту версию от налp tr с шаблонным параметром t конечно же
[02:36:53.740 --> 02:36:58.380]  предпочтительная эта версия в любом случае потому что принять один аргумент всегда лучше чем
[02:36:58.380 --> 02:37:04.940]  принять переменный количество любых типов но только если ты это не класс то это некорректный
[02:37:04.940 --> 02:37:15.540]  тип и мы отваливаемся по сфеное и попадаем в эту версию понимаете у меня есть два вопроса в целом
[02:37:15.540 --> 02:37:20.700]  давай зачем у нас шаблон перед тестом который от многоточего
[02:37:20.700 --> 02:37:28.660]  разве потому что потому что мы вызываем здесь явным указанием шаблонных аргументов если бы
[02:37:28.660 --> 02:37:36.020]  здесь я не сделал шаблоном то это было бы ошибкой функция не шаблонная мне нужно чтобы ты я указал
[02:37:36.020 --> 02:37:42.260]  явно и он попал либо сюда либо сюда но обе функции должны быть шаблонные для этого окей ладно все
[02:37:42.260 --> 02:37:49.980]  понял а еще мы вызываем из union потому что у нас видимо указатель на да потому что указатель на
[02:37:49.980 --> 02:37:57.380]  член можно вызвать и у union это проблема как это работает на самом деле различить класс вот
[02:37:57.380 --> 02:38:03.780]  отличить класс от юниона средствами стандартного c++ мы не можем никак отличить класс от юниона это
[02:38:03.780 --> 02:38:09.860]  компайлер intrinsic только компилятор может отличить то есть мы можем своими руками написать только
[02:38:09.860 --> 02:38:18.540]  type trade из класс о union основу класс or struct or union вот различить класс от юниона никак написать
[02:38:18.540 --> 02:38:26.220]  нельзя на c++ это компайлер компилятор в hard кожан как-то разница между то есть из union в hard
[02:38:26.220 --> 02:38:33.220]  кожан в компилятор как-то мы не можем отличить но отличить класс или union от всего остального мы
[02:38:33.220 --> 02:38:41.300]  можем вот таким трюком понятно я не понимаю указатель на какой член вы берете неважно на
[02:38:41.300 --> 02:38:47.220]  какой раз это и дело что на никакой мы просто мы просто здесь написали некоторый тип который
[02:38:47.220 --> 02:38:53.340]  является корректным типом тогда и только тогда когда t это класс или union и эта версия таким
[02:38:53.340 --> 02:39:02.620]  образом предпочтительно vehicle type от этого будет стд integral constant bool ну то есть это будет это
[02:39:02.620 --> 02:39:09.020]  будет true type если мы в эту версию попали эти здесь разрешается перегрузка какой тип был бы если
[02:39:09.020 --> 02:39:15.180]  бы эта функция вызвалась если бы т был классом или юнионом то выбралась бы эта версия и тип
[02:39:15.180 --> 02:39:21.220]  возвращаемого значения был бы integral constant вот с таким значением то есть true type таким
[02:39:21.220 --> 02:39:27.220]  образом из класс это был бы наследник true type то есть в нем было бы статик using type статик он
[02:39:27.980 --> 02:39:35.300]  если выбралась эта версия то мы получили false type под декл-type декл-type от этого становится
[02:39:35.300 --> 02:39:42.300]  false type и значит мы наследуемся от false type таким образом и у нас таким образом есть статик
[02:39:42.300 --> 02:39:54.820]  у нас был val и равно false нормально идейно понятно но смущает запись т2.2.2 звездочки ну ладно я
[02:39:59.940 --> 02:40:09.260]  так блин а вы все это время видели cpp референс блин а я то показывал это на примере господи я
[02:40:09.260 --> 02:40:20.780]  думал вы видите я это вимск и пастом ладно ну ладно ладно не важно последнее самое что
[02:40:20.780 --> 02:40:26.380]  покажу это вот такой еще мне очень нравится пример ну из function тоже в принципе понятно
[02:40:26.380 --> 02:40:34.060]  ну может быть на нее мы потом посмотрим вот еще мне нравится type-trade из polymorphic отгадайте
[02:40:34.060 --> 02:40:41.820]  как реализовать из polymorphic просто отгадайте как отличить polymorphic от неполиморфного проверить
[02:40:41.820 --> 02:40:50.980]  работает ли на нем dynamic cast конечно смотрите за что помнить бы что такое polymorphic это тип
[02:40:50.980 --> 02:40:55.820]  который у которого есть хотя бы одна виртуальная функция так сейчас вообще не видите как экран да
[02:40:55.820 --> 02:41:05.340]  никакой именно так это тоже неплохо значит давайте последний стяжение значит вот
[02:41:05.340 --> 02:41:15.940]  из polymorphic ну это скопи пастил cpp референс опять смотрите detail detect из polymorphic t от
[02:41:15.940 --> 02:41:27.380]  нал птр а что здесь написано а тут две функции detect из polymorphic от вот такого вот и от чего
[02:41:27.380 --> 02:41:35.180]  угодно другого чего значит по умолчанию конечно же эта функция такая она без тела обратите
[02:41:35.180 --> 02:41:41.740]  внимание вот это функции это объявление функций обычных функций это функция у которой возвращаемый
[02:41:41.740 --> 02:41:49.500]  тип true type название detect из polymorphic и принимаемый тип вот такой принимаемый тип decal type от
[02:41:49.500 --> 02:41:57.540]  dynamic cast к const volatile void звездочки от статика ct звездочки от нал ptr мы ее вызвали с явным указанием
[02:41:57.540 --> 02:42:05.380]  шаблон руменко t и компилятор видя что это функция одного аргумента пытается выбрать ее понимая что
[02:42:05.380 --> 02:42:11.820]  она предпочтительней чтобы не идти сюда и он пытается распарсить какой же это тип то decal type
[02:42:11.820 --> 02:42:19.300]  от вот этого вот вот всего нал ptr статика ct звездочки ok а вот дальше dynamic cast const volatile void
[02:42:19.300 --> 02:42:25.260]  звездочки зачем нужно const volatile чтобы если случайно табл с const или с volatile мы не отловалились
[02:42:25.260 --> 02:42:32.700]  по причине нарушения квалификаторов вот но dynamic cast сработает от т звездочки к void звездочки
[02:42:32.700 --> 02:42:38.020]  только если это было полиморфным типом и значит это корректное выражение лишь когда t это
[02:42:38.020 --> 02:42:44.980]  полиморфный тип и decal type от него ну это какой-то тип это const volatile void звездочки неважно какой
[02:42:44.980 --> 02:42:53.540]  он важно что это корректный тип и он предпочтительнее чем функция переменного количества аргумента а если
[02:42:53.540 --> 02:42:59.740]  бы dynamic cast был некорректным не компилируем выражение потому что не полиморфный компилятор бы
[02:42:59.740 --> 02:43:04.500]  ничего не оставалось как пойти сюда но у этой функции возвращаемый тип true type а у этой функции
[02:43:04.500 --> 02:43:10.220]  возвращаемый тип false type функции нереализованные они не имеют тела но мы их и не вызываем поэтому
[02:43:10.220 --> 02:43:17.180]  потому что мы на самом деле не вызываем их мы только тип смотрим что они возвращают и из полиморфика
[02:43:17.180 --> 02:43:23.660]  наследник decal type от вот этого вот выражения которые либо false type либо true type смотря каким был
[02:43:23.660 --> 02:43:31.380]  t а dynamic cast компилируется вообще к чему угодно что ли нет ну лига базе ну и квад звездочки тоже
[02:43:31.380 --> 02:43:38.900]  можно dynamic cast ну вот непонятно почему квад звездочки вообще можно ну по стандарту можно что кажется
[02:43:38.900 --> 02:43:46.420]  квад звездочки просто можно все да но динамик кастом можно только я ну это опять касты то есть
[02:43:46.420 --> 02:43:52.580]  динамик каст квад звездочки просто закастылин компилятором отдельно да ну да но он компилируется
[02:43:52.580 --> 02:43:59.780]  только если это был полиморфный тип понятно просто странно что для полиморфов все равно можно
[02:43:59.780 --> 02:44:05.580]  квад звездочки это как-то не очень понятно вот так вот такие вот такие вот приколы ну давайте
[02:44:05.580 --> 02:44:13.180]  на этом закончим потому что мне на самом деле надо бежать уже сегодня вот и значит все пока что
[02:44:13.180 --> 02:44:18.460]  следующий раз мы быстренько поговорим о том как реализовать из констракт и был с конверти был
[02:44:18.460 --> 02:44:24.420]  из ноуфро му в констракте было прочее а еще нам предстоит реализовать такую интересную штуку как
[02:44:24.420 --> 02:44:31.420]  из бейзов вот а после этого мы уже поговорим про концепты и про современное метапрограммирование
[02:44:31.420 --> 02:44:36.100]  новомодные все плюс плюс 20 вот
