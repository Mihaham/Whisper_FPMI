[00:00.000 --> 00:11.040]  Все, окей, смотрите. Сегодня мы с вами... Странно будет так говорить, но ладно. Открывайте
[00:11.040 --> 00:19.400]  презентацию, и главное не чатитесь в это время, я все замечу. Я замечу, что вы делаете вот так. Так
[00:19.400 --> 00:25.840]  что давайте. Сегодня мы с вами поговорим про сплей дерева. Я периодически буду тогда часть
[00:25.840 --> 00:31.200]  рисовать здесь, потому что это будет проще, это будет понятнее. Какие-то основные тезисы тоже
[00:31.200 --> 00:47.080]  буду делать именно здесь. Сейчас, момент. Смотрите, на прошлом с вами занятии мы рассматривали... С вами
[00:47.080 --> 00:55.000]  амортизационный анализ. До этого мы рассматривали бинарные деревья. Два получается... Две недели подряд
[00:55.000 --> 01:01.760]  бинарные деревья. Обычные. Потом амортизационный анализ. И для чего-то же амортизационный анализ мы с
[01:01.760 --> 01:09.000]  вами проходили. Так вот, сплей дерева именно об этом. Но это мы узнаем в конце. Пока что давайте поговорим
[01:09.000 --> 01:18.280]  с вами про... Перелистывайте слайд. Про сбалансированность. Смотрите, является ли пермоментная
[01:18.280 --> 01:24.560]  сбалансированность тем самым святым гралем, серебряной пулей, всегда по-разному называется.
[01:24.560 --> 01:30.160]  За которым вообще следует гоняться и следует его использовать. Как вы думаете?
[01:34.160 --> 01:36.200]  Удобная штучечка, так.
[01:42.760 --> 01:50.120]  Ну здесь это не проблема. Не то чтобы проблема, у нас указатели-то все равно лежат на стэке.
[01:50.120 --> 02:00.880]  Эти хранятся просто в динамической памяти. Еще есть идея. Что может быть не так? Долго?
[02:05.600 --> 02:12.800]  Это быстро работает. Мы с вами доказывали это в прошлый раз. Это не так сложно. Это достаточно быстро.
[02:12.800 --> 02:25.560]  Да, да. Вот у нас есть АВЛ-дерево, но пермоментно сбалансировано. Но оно прям сбалансировано-сбалансировано,
[02:25.560 --> 02:33.480]  потому что у нас разница высот всегда не больше единицы. Смотрите, представьте следующий случай.
[02:33.480 --> 02:41.960]  Вот вы, не знаю, являетесь разработчиком какой-нибудь библиотеки. Библиотеки, я имею в виду реально
[02:41.960 --> 02:48.040]  каких-нибудь книжек. Вот электронные книжки. И вот к вам приходят студенты, и вы знаете,
[02:48.040 --> 02:58.200]  что сейчас у вас экзамен по мотану. Какие книжки будут брать студенты? По мотану. Логично, правда?
[02:58.200 --> 03:07.160]  А что делать, если у вас по сути много-много-много разных предметов, много разных книжек. Но вот в данный
[03:07.160 --> 03:13.720]  момент будет все по мотану. Не лучше ли взять и подвинуть, грубо говоря, эту полочку к вам,
[03:13.720 --> 03:19.640]  ну либо вот просто выдать пользователю именно те книги, которые есть, именно связанные с мотаном?
[03:19.640 --> 03:26.840]  Звучит логично, правда? Вот в бинарном дереве поисков, в том числе ВВЛ-дереве, мы бы каждую
[03:26.840 --> 03:32.920]  книжку искали за логарифм. Ну то есть мы попытались быстро пройтись, но искали бы за логарифм.
[03:32.920 --> 03:41.040]  И получается, что если бы нам нужно было сделать n книжек, то это n книжек, это было бы n логен.
[03:41.040 --> 03:50.520]  Согласны? Ну m логен, давайте так, m книжек. А вот если мы точно знаем, что пользователь будет, грубо
[03:50.520 --> 03:55.960]  говоря, брать и постоянно запрашивать чаще всего какую-то информацию, вот либо из какого-то
[03:55.960 --> 04:01.200]  промежутка, либо просто один и тот же файлик, ну вы все будете там ботать. Блин, я не помню,
[04:01.200 --> 04:10.080]  какой мотан. Ну можно сказать, ладно, про линал. Линал по Бекли Мишеву и алгем, скорее. Вот.
[04:10.080 --> 04:18.800]  Ну большинство в стихе будет делать так. К примеру, это, может быть, уже все поменялось и я уже живу
[04:18.800 --> 04:25.120]  типа в старом мире, но опять же, например, это так. И вот вы выдаете все время одну и ту же книгу и
[04:25.120 --> 04:31.080]  один и тот же запрос. И хочется сделать и попробовать сделать так, чтобы на этот запрос повторяющийся,
[04:31.080 --> 04:36.720]  мы не искали его на протяжении всего дерева, а отвечали на этот запрос быстро. То есть,
[04:36.720 --> 04:42.600]  если у нас есть какое-то большое количество запросов, мы знаем, что часть из них будет
[04:42.600 --> 04:48.440]  очень часто повторяться, но в то же время какая-то часть запросов может быть извне, ну не знаю,
[04:48.440 --> 04:53.400]  кто-то уже готов к мотану и он такой, я хочу ботать физику. Вот пришел этот рандомный человек,
[04:54.080 --> 05:02.080]  вот надо ему. Или колгосом подготовиться к последнему экзамену. Опять же, такое возможно,
[05:02.080 --> 05:08.640]  и тогда мы будем искать ровно как со всеми деревьями, то есть просто приходя с помощью рекурсии. Вот это и
[05:08.640 --> 05:14.440]  будет связано со сплей-деревом, то есть сплей-дерево позволяет работать с такими данными, когда у вас
[05:14.440 --> 05:23.080]  какое-то количество запросов есть и есть одни очень часто повторяющиеся. Поэтому, когда мы с вами
[05:23.080 --> 05:30.120]  говорим, что у нас есть, если что, может быть следующий слайд. Если у нас есть каких-то n элементов
[05:30.120 --> 05:36.760]  и m запросов, то в этом случае обычное дерево за m log n работает. Я хочу это делать быстро и
[05:36.760 --> 05:43.560]  попробовать это сделать за линию, как это возможно. И вот с этим мы сегодня будем разбираться,
[05:43.560 --> 05:50.280]  перелистывать еще раз, там написано сплей-дерево. Что такое сплей-дерево? Сплей-дерево это
[05:50.280 --> 05:57.840]  самобалансирующее бинарное дерево поиска. Оно само как-то балансируется. Важные моменты про
[05:57.840 --> 06:05.280]  эти деревья. Эти деревья, они не являются перимоментно сбалансированными. Я имею в виду перимоментно
[06:05.280 --> 06:09.380]  сбалансированными, что каждый момент времени есть какой-то баланс в плане сплей-дерева. Нет,
[06:09.380 --> 06:18.040]  такого нет. У него немного другой характер и в плане овель, тем более, то есть это вообще не всегда
[06:18.120 --> 06:24.360]  возможно в сплей-дере. А на отдельных каких-то видах запросов он работать может действительно
[06:24.360 --> 06:33.520]  линейно, то есть на какой-то определенной выборке. Такое возможно. И для каждого запроса данное
[06:33.520 --> 06:43.800]  дерево будет полностью менять свою структуру. Как вы думаете, как? Есть какие-нибудь идеи? Вот как
[06:43.800 --> 06:48.280]  нам сделать так, вот у нас есть дерево, чтобы повторяющий запрос я делал быстро? Вот откуда я
[06:48.280 --> 07:04.840]  его должен быстро взять? А? Не, это, это... Не. Да. Представим, что мы ищем число 5 типа 100 раз,
[07:04.840 --> 07:12.520]  а число 1 там 1 раз и 100. Вот если я буду число 5 держать в корне, я же всегда его найду сразу.
[07:12.520 --> 07:19.720]  Согласны? Вот. У меня же просто есть некоторое дерево и вот с ним пытаюсь как-то работать. И вот
[07:19.720 --> 07:25.560]  сплей-дерева направлена на то, чтобы после каждого запроса к какому-то конкретному элементу мы бы
[07:25.560 --> 07:33.920]  поднимали это в корень. Но перед тем, как и к этому всему перейти, перелистывайте слайдик. Вот. Там
[07:33.920 --> 07:38.920]  будет некоторое описание узла. Я здесь вам специально вернул parent. Это тоже не обязательно
[07:38.920 --> 07:45.480]  в сплей-дереве, если что. Но иногда бывает полезно. Поэтому я типа и так, и так. Я вот вам
[07:45.480 --> 07:51.920]  по-всякому рассказываю. Выберите, какой путь вам больше нравится. И можете от этого отталкивать. Да.
[07:51.920 --> 08:01.480]  Но вот AVL дерево, оно постоянно сбалансировано. У тебя гарантируется, что на каждом шагу разница
[08:01.480 --> 08:10.120]  высот ни более чем единица в любом поддереве. Ну, перимомента постоянно. Оно постоянно сбалансировано.
[08:10.120 --> 08:15.880]  Вот. Здесь же мы не говорим, что у нас будет балансированность с точки зрения AVL.
[08:15.880 --> 08:20.600]  Описание узла выглядит очень просто. У нас есть ключ, у нас есть левое поддерево, правое поддерево,
[08:20.600 --> 08:28.960]  есть родитель, ну и есть просто небольшой конструктор. Окей. Больше нам чего-то не надо. Вот.
[08:28.960 --> 08:37.160]  Надеюсь, нигде дальше я там не написал какую-то чушь случайно. А, да, написал. Там написано
[08:37.160 --> 08:45.400]  нода void, а это void. Я поправлю попозже. Я объясню, я просто заменял буквку v везде, когда писал,
[08:45.400 --> 08:52.400]  и он случайно заменил везде ее совсем. Это void и это void. Это просто некоторые вспомогательные
[08:52.400 --> 09:01.200]  функции setParent и keepParent. setParent ну просто устанавливает родителя, если это нода не NullPtr,
[09:01.200 --> 09:07.640]  а keepParent, если это нода не NullPtr, то устанавливает взаимосвязь родителя и детей. То есть представим,
[09:07.640 --> 09:12.120]  что у меня есть указатель на детей, мне нужно взять и восстановить родительскую связь. Ну как бы все
[09:12.120 --> 09:23.800]  просто. Понятно, что они делают? С чем непонятно? setParent или... Нет, это void просто. Да просто void.
[09:23.800 --> 09:40.920]  void, keepParent, void, setParent. Согласен. Стрелочка. Ну, видимо, да, я что-то это переборщил. А, да,
[09:40.920 --> 09:54.720]  в действительности это правда. Простите, я исправлю и выложу. Нет, почему? Нода-то сама может
[09:54.720 --> 10:04.560]  быть NullPtr. Мы можем передать туда NullPtr? Можем. Вот. Ровно как с child. Вот. А для того,
[10:04.560 --> 10:10.120]  чтобы обращаться к чему-то, нам нужно обращаться к этому, поэтому там нужна девочка. Надеюсь,
[10:10.120 --> 10:16.000]  дальше у меня получше. Я не помню. Уж простите, я что-то, видимо, когда делал сегодня, сломался.
[10:16.000 --> 10:29.840]  Смотрите, представим, что у меня есть нода и у нее есть дети. Да? Вот keepParent берет и восстанавливает
[10:29.840 --> 10:39.320]  вот эту связь. Если у нас есть родитель и он указывает на своих детей, но эти дети не
[10:39.320 --> 10:44.600]  указывают на это родители. Для того, чтобы поддержать эту взаимосвязь, я делаю keepParent. Понятно?
[10:44.600 --> 10:51.160]  SetParent устанавливает взаимосвязь. У меня есть раз нода, есть два нода. Он устанавливает
[10:51.160 --> 11:05.400]  связь от parent до child. Ой, от child до parent. Прошу прощения. Это потом другой вопрос.
[11:05.400 --> 11:15.200]  Там нигде это будет легко. Вопросы еще есть? Нет. Перелистывайте тогда дальше. Вот у нас есть
[11:15.200 --> 11:24.000]  такие ноды и самое важное, что есть в сплэй-дереве, это Evristic Muf2Root. Evristic Muf2Root означает следующее,
[11:24.000 --> 11:31.520]  что после каждого обращения к любой вершине она поднимается в корень. То есть, если вы сделали
[11:31.520 --> 11:36.280]  find какой-то вершины, она взялась и поднялась в корень. Вы сделали insert какой-то вершины,
[11:36.280 --> 11:42.680]  она взялась и поднялась в корень. И так далее. То есть любые обращения, они поднимают эту вершинку.
[11:42.680 --> 11:49.760]  Неважно, что вы с ней делаете. Вот. И подъем реализовывается через повороты вершин. Повороты,
[11:49.760 --> 11:56.840]  по факту, вам знакомы. Я пишу их немного по-другому. Но повороты здесь правые,
[11:56.840 --> 12:05.600]  левые повороты, большие правые будут присутствовать и так далее. Вот. В действительности для сплэй-деревья
[12:05.600 --> 12:14.120]  эти повороты нужны и важны. И будем смотреть, как это делать. Я хочу объединить и левые повороты,
[12:14.120 --> 12:19.760]  и правый поворот в одну и назвать их rotate просто поворотом. То есть, чтобы мы могли и так, и так
[12:19.760 --> 12:26.840]  делать. Перелистывайте дальше. Вот. Это аналогично тому же, что было в ВВЛ, но я просто все запихнул в rotate.
[12:26.840 --> 12:33.800]  А в каком плане? Ну, во-первых, я сделал там, у меня есть какой-нибудь grandparent, грубо говоря,
[12:33.800 --> 12:41.680]  у меня есть дедушка, родитель и ребенок. Вот. Вот эти три каких-то взаимосвязи. И дальше я говорю,
[12:41.680 --> 12:45.840]  что у меня в зависимости от этого я буду делать как-то взаимосвязь, потому что мне нужно
[12:45.840 --> 12:50.600]  parent восстановить. То есть, к примеру, в ВВЛ дерево мы без parent жили, там нам не нужно было это,
[12:50.600 --> 12:56.720]  здесь нам понадобится для того, чтобы восстанавливать какие-то взаимосвязи. Ну и дальше там несколько ифов.
[12:56.720 --> 13:05.680]  Если у нас grandparent не на lptr, тогда что я должен сделать? Я должен сказать, что левым ребенком
[13:05.680 --> 13:12.200]  нашего дедушки должно стать ребенок или правым ребенком в зависимости от того, где был parent. Ну и
[13:12.200 --> 13:18.480]  дальше все переподвесить. Все достаточно просто. То есть, вот эти взаимосвязи, они ровно такими же остались.
[13:18.480 --> 13:26.360]  Единственное, что мне потом нужно восстановить вот это вот отцовство у узлов? Вопросы есть к поворотам
[13:26.360 --> 13:40.720]  или нужно нарисовать это все? Можно нарисовать. Смотрите. Вот у меня есть parent, есть child,
[13:41.480 --> 13:50.200]  вот у него есть что-то, и вот тут тоже есть. Смотрите, что я вначале смотрю. Я смотрю,
[13:50.200 --> 13:56.680]  есть ли у меня здесь, здесь может быть и с этой стороны, и с этой стороны вершинка grandparent.
[13:56.680 --> 14:04.920]  Правильно? Вот. Я смотрю, есть ли у меня grandparent не на lptr, тогда что я должен сказать? Я должен
[14:04.920 --> 14:13.120]  сказать, что этот grandparent должен теперь указывать на ребенка, не на parent. Согласны? И вот там
[14:13.120 --> 14:25.440]  вот их написано, если grandparent left равен parent, и если grandparent иначе. Grandparent left равен parent,
[14:25.440 --> 14:33.240]  если он является левым ребенком. Вот это является. Понятно? Вот. Аналогично, ну правое это else.
[14:33.240 --> 14:43.480]  И я переподвешиваю вот эту связь, и она становится уже вот такой. Ага. Пока все понятно. Вот.
[14:43.480 --> 14:49.840]  У child еще пока он указывает на parent и все такое. Теперь я смотрю следующее. Я говорю, что parent
[14:49.840 --> 14:56.160]  left равен child, то есть является ли левым ребенком мой child. Если он является, тогда в этом случае
[14:56.160 --> 15:03.760]  я должен что сделать? Я должен сказать, что у меня меняется parent left, вот эта связь,
[15:03.760 --> 15:17.440]  на child right, то есть на вот эту связь. Вот эти связи должны поменяться. И грубо говоря, это будет
[15:17.440 --> 15:21.720]  выглядеть следующим образом, что у меня есть некоторый grandparent, который указывает на child,
[15:21.720 --> 15:31.920]  а теперь child будет связан с его правым ребенком. Становится parent, потому что я поменял вот эти
[15:31.920 --> 15:41.560]  связи между друг дружкой. То есть представьте, что я свопну. Вот. У parent здесь давайте a, b, c. Вот это
[15:41.560 --> 15:54.920]  стало a, вот это стало b, а вот это стало, ой, вот это a, вот это b, вот это c. Вот. У меня пока вот
[15:54.920 --> 16:00.280]  такая связь. Единственное в чем пока проблема в том, что child указывает все еще на parent,
[16:00.280 --> 16:11.880]  а parent указывает на grandparent. Вот это двойные, это как раз таки, ой, пунктирные линии, это как
[16:11.880 --> 16:18.040]  раз взаимосвязь родителей. Мне нужно восстановить. Я восстанавливаю для child, я восстанавливаю для parent.
[16:18.040 --> 16:28.560]  Понятно? Потому что это самый начало такая взаимосвязь была. У тебя есть child, для которого родитель parent,
[16:29.040 --> 16:47.840]  родитель grandparent. Вы поменяли child и parent. Это просто левый поворот. Ой, правый. Простите,
[16:47.840 --> 16:55.440]  я путаю правый и левый иногда. Пока еще не за рулем, так что все хорошо. Да, смотрите,
[16:55.760 --> 17:04.240]  вот эти связи, они подразумеваются как от родителя к детям. Потом мне нужно восстанавливать связь.
[17:04.240 --> 17:16.760]  Вот. Это он и есть, просто здесь описано. Но здесь благодаря этим вот else, которое написано,
[17:16.760 --> 17:22.320]  тут вместе есть и левый поворот. Есть правый поворот, есть и левый поворот. Они аналогичны
[17:22.320 --> 17:28.080]  вот таким вещам. Просто здесь добавились те самые parent, которые нужно держать. Понятно?
[17:28.080 --> 17:41.120]  Вот. Окейшки. Поехали дальше. Смотрите, с точки зрения евристики, что у нас происходит?
[17:41.120 --> 17:51.840]  С точки зрения евристики происходит следующее. Мы будем использовать три вида поворотов. В
[17:51.840 --> 18:00.360]  действительности их можно назвать шесть, но по факту их три. Вот. Это зиг-зиг, зиг-заг и просто
[18:00.360 --> 18:05.960]  либо зиг, либо заг, как хотите называть. Мы сейчас пройдемся по каждому из них, вы поймете,
[18:05.960 --> 18:16.400]  что они делают. Поехали дальше. Первый. Это зиг-зиг поворот. Зиг-зиг это когда ребенок, родитель и
[18:16.400 --> 18:22.720]  grandparent, у них взаимосвязь одна. Они все являются левыми детьми, то есть parent является
[18:22.720 --> 18:35.160]  левым ребенком для grandparent, либо наоборот. Там все правое. Смотрите, зиг-зиг означает следующее,
[18:35.160 --> 18:44.080]  что у нас был child, parent, grandparent, либо мы пойдем вправо, либо мы пойдем влево. Как эти вещи
[18:44.080 --> 18:50.000]  превращаются? Что из этого всего меняется? После того, как мы все повернем, у нас будет наоборот.
[18:50.000 --> 19:05.080]  Child, parent, grandparent. Аналогично здесь, когда мы повернем, у нас будет child сверху, дальше parent,
[19:05.080 --> 19:12.280]  дальше grandparent. Здесь как-то все остальные вещи легко переподвешиваются, то есть все их
[19:12.280 --> 19:19.080]  под деревья. Это понятно пока? Зиг-зиг берет и поворачивает вот так. У нас такого с вами особо
[19:19.080 --> 19:24.680]  не было. Это по сути либо два правых, либо два левых поворота. Мы так не делали в ВВЛ дереве,
[19:24.680 --> 19:32.680]  если вы помните. У нас такого там не было. Вот это считайте, это тот самый зиг-зиг, который есть.
[19:32.680 --> 19:48.280]  Вопросы к зиг-зигу есть? Нет, объясню. Считается, что у них есть зиг-зиг, зиг-заг и заг, а дальше
[19:48.280 --> 19:54.240]  все их комбинации делается. То есть да, возможно такое, что это будет зиг-зиг-зиг-зиг, но это просто
[19:54.240 --> 20:08.360]  называют типа n подряд зиг-зигов. Это важно с точки зрения симпотики работы. Мы когда это оценим,
[20:08.360 --> 20:14.800]  вы поймете. То есть благодаря этому, а это дерево, его придумал Тарьян вместе, не помню с кем, где-то
[20:14.800 --> 20:20.240]  в 80-х годах. Вот, благодаря этим действиям оно так и называется. Оно оттуда и пошло, что они называются
[20:20.240 --> 20:27.920]  зиг-зиг-зиг-заг. Оно там и осталось. Это такая традиция. Никаких больших правых,
[20:27.920 --> 20:34.480]  левых поворотов. Неинтересно так называть. Поэтому в Советском Союзе вот типа четко сказали
[20:34.480 --> 20:39.720]  в математике ВВЛ дереве большой правый поворот, большой левый, левый поворот, правый. Здесь
[20:39.720 --> 21:02.080]  зиг-зиг-зиг-заг-заг-зиг и так далее. Да, так и должно быть. Если я обратился к элементу В,
[21:02.680 --> 21:10.720]  который там написан, то этот элемент В должен стать в корне. Если я сделал find В, то В становится в
[21:10.720 --> 21:17.440]  корне. Понятно? То есть мы не просто на один двигаем вверх, мы двигаем прям до корни.
[21:17.440 --> 21:29.960]  Да, да, да. Вот. Давайте следующий слайд. Там зиг-заг-поворот. Вот зиг-заг-поворот это либо
[21:29.960 --> 21:34.840]  большой левый, либо большой правый поворот. В зависимости от того, как у вас выглядит дерево.
[21:34.840 --> 21:46.280]  Это происходит в тот момент, когда у вас просто элементы находятся, либо parent является левым
[21:46.280 --> 21:53.080]  ребенком, а child является правым ребенком, либо наоборот. То есть когда у вас нарушена вот эта
[21:53.080 --> 21:59.040]  одинаковость. И в зависимости от этого мы с вами говорим, что это будет уже зиг-заг. Зиг-заг,
[21:59.040 --> 22:04.400]  потому что в разные стороны идет. Я думаю, вы понимаете. Зиг-заг по одну сторону, зиг-заг в разную
[22:04.400 --> 22:10.280]  сторону. Они смотрят. Просто, понятно? Но я надеюсь, большим правым поворотом и левым поворотом вы
[22:10.280 --> 22:21.560]  помните еще с прошлой лекции. Еще раз. Смотрите. Давайте следующий. Нам нужно будет подвешивать
[22:21.560 --> 22:28.240]  вершину в корень, которую мы будем с вами там делать find или что-то еще. Если мы с вами это
[22:28.240 --> 22:34.200]  подвешиваем в корень, тогда в этом случае ее необходимо как-то повернуть туда. Чтобы сдвинуть
[22:34.200 --> 22:40.200]  вершинку в корень. Считается, что элементарными движениями с точки зрения вот этих сдвигов будет
[22:40.200 --> 22:48.120]  зиг-зиг, зиг-заг и заг. Все. Объясню попозже, почему, когда мы с вами в действительности остановимся на
[22:48.120 --> 22:56.320]  анализе всего этого алгоритма. Окей? Хорошо. Зиг-загом понятно. Но смотрите, зиг или заг поворот,
[22:56.320 --> 23:04.000]  но это просто типа левый поворот или правый поворот. Понятно? Постройте себе вот эти ассоциации.
[23:04.000 --> 23:08.840]  То есть у вас добавилось только одно. У вас добавилось, что у вас есть теперь зиг-зиг или заг-заг.
[23:08.840 --> 23:17.400]  Как хотите назовите. Вот. И причем зиг или заг делается только в одном случае, если grandparent не
[23:17.400 --> 23:28.400]  существует. То есть parent был тем самым корнем. Понятно? Вот. Теперь переходите дальше. Функция
[23:28.400 --> 23:37.760]  splay, она как раз и делает ровно то, что нам необходимо. Она берет и поднимает нашу вершинку. Она
[23:37.760 --> 23:44.440]  поднимает эту вершину как можно выше и по сути ставит в код. Давайте смотреть, что там происходит.
[23:45.320 --> 23:52.600]  Первое, что вы там видите, если у нас нет родителя. Но если нет родителя, то это означает что? Что
[23:52.600 --> 24:00.000]  это вершина корень. Если она так в корне, то мы ничего не делаем. Логично? Логично.
[24:00.000 --> 24:17.760]  Всего. Но еще раз, в каком случае вершины нет родителя? Это когда у нас нету вершинки
[24:17.760 --> 24:33.400]  выше какой-то. Вот когда вот это отсутствует, это является корнем. Корень. Да. Самый корень. Вот.
[24:33.400 --> 24:40.360]  И splay это делает как раз таки. А дальше смотрите, у меня есть parent, у меня есть grandparent. Ну все
[24:40.360 --> 24:46.520]  достаточно просто. Причем grandparent тоже может быть на lptr. Вот если grandparent равен на lptr,
[24:46.520 --> 24:54.040]  тогда у нас что происходит? Тогда у нас выглядит примерно следующим картином с точностью десиметрии.
[24:54.040 --> 25:05.200]  Что вот это является корнем. Вот этот parent является корнем. Тогда мне достаточно сделать
[25:05.200 --> 25:12.680]  один zig или один zag и это будет корректно. Согласны? Вот. Поэтому вот этот if,
[25:12.680 --> 25:20.800]  который там написано, вот этот rotate parent нода, вот этот rotate parent нода, он и есть здесь. Мы
[25:20.800 --> 25:28.000]  просто повернули, получили, что он сверху. Согласны? Теперь смотрите, что у нас происходит дальше.
[25:28.000 --> 25:32.800]  Если это не так, если у нас действительно существует grandparent, если у нас есть grandparent,
[25:32.800 --> 25:40.320]  тогда в этом случае мы должны сделать либо zig zig, либо zig zag. А как мне проверить,
[25:40.360 --> 25:45.160]  что у меня есть zig zig или zig zag? Ну у меня должно быть либо два левых ребенка, либо два правых
[25:45.160 --> 25:53.480]  ребенка. Согласны? Смотрите, какая там переменная написана. Bool zig zig. И она говорит следующее,
[25:53.480 --> 26:04.400]  если grandparent left равен parent и если parent left равен ноде. То есть grandparent left равен parent,
[26:04.400 --> 26:14.640]  это будет true, если это правда, иначе false. И parent left равен ноде, это true, если это правда.
[26:14.640 --> 26:24.720]  Если у нас true равно true, то левый и левый будет true. А если они будут оба false, то это будет
[26:24.720 --> 26:31.440]  означать, что они все являются правыми детьми. Согласны? То есть false равно false тоже будет true.
[26:31.440 --> 26:37.600]  А вот все остальные комбинации это будет уже zig zag. То есть вот эта переменная zig zig
[26:37.600 --> 26:43.600]  означает, что они находятся вот именно по одну сторону, либо все слева, либо все справа. Понятно
[26:43.600 --> 26:58.600]  пока? Точно понятно? Кто-то уснул, кому-то уже плохо. Ладно, окей. То есть смотрите,
[26:58.600 --> 27:05.400]  у нас есть такой момент. Ну и дальше. Если у нас есть zig zig, тогда мы с вами в начале делаем
[27:05.400 --> 27:11.360]  rotate. Ну для того, чтобы сделать zig zig, оно в какой последовательности происходит? Смотрите,
[27:11.360 --> 27:19.360]  вот у меня есть вот такая последовательность. Тут у меня child parent grandparent. Он переделывает
[27:19.360 --> 27:26.400]  в начале в parent, который будет здесь child grandparent. Первый поворот будет означать. А
[27:26.760 --> 27:37.400]  следующий поворот будет делать child parent grandparent. Вот это zig zig. То есть мы сначала
[27:37.400 --> 27:44.320]  поворачиваем вот просто направо, потом еще направо. Понятно? Вот это там и происходит. То есть вот
[27:44.320 --> 27:50.120]  те два rotate, которые там написано, что мы изначале делаем grandparent и parent, поворачиваем, и он их
[27:50.120 --> 27:55.720]  выставляет таким образом. После чего я делаю поворот parent и node и получаю вот такой вот элемент.
[27:56.040 --> 28:08.560]  Если же у меня будет zig zag, то что я в начале должен буду делать? Какой первый мой шаг будет?
[28:08.560 --> 28:18.520]  Да, у меня в начале будет поворот снизу. У меня будет поменять местами child parent. То есть я
[28:18.520 --> 28:31.560]  буду делать child parent. А после этого я поворачиваю child и grandparent. Поэтому у меня будет вот так.
[28:31.560 --> 28:55.480]  Вот это zig zag. Но он стал выше parent и grandparent. Он стал некоторым корнем вот этого поддерева,
[28:55.520 --> 29:02.040]  которое было здесь. То есть это все является каким-то поддеревом. Может быть это финальное поддерево,
[29:02.040 --> 29:13.720]  может быть нет. Мы будем повторять zig zig, zig zig, zig zig, zig zag и так далее. Будем постоянно
[29:13.720 --> 29:24.600]  повторять это и все. То есть представь следующее, что у тебя есть вот такое какое-нибудь дерево.
[29:25.480 --> 29:31.000]  Мы на fine посмотрим. Это будет рекурсивно просто делать.
[29:31.000 --> 29:42.880]  Но представь я обратился вот к этой вершинке. Давай я ее закрашу. Что я в начале сделаю? Я в
[29:42.880 --> 29:52.640]  начале сделаю zig zig. Я получу, сейчас считать надо. Раз, два, три. После этого получу вот
[29:52.640 --> 30:00.320]  здесь эту вершинку, а от нее будет еще вот так две. Я тебя нумеру. Ноль, один, два, три, четыре,
[30:00.320 --> 30:13.240]  пять. Пять, четыре, три, ноль, один, два. Вот это мой первый zig zig. Следующий опять zig zig будет.
[30:13.240 --> 30:31.360]  А что непонятно? Ну давай сделаем вот так. Так лучше?
[30:31.360 --> 30:42.240]  Ну так понятно, что будет zig zag когда-нибудь. Вроде должно, правда?
[30:42.240 --> 30:49.120]  Ну смотри, в начале у меня будет zig zig. Согласен? То есть в начале я получу пять,
[30:49.120 --> 31:05.160]  четыре, три. А дальше здесь будет эта закрашенная вершинка и влево идет уже один, два. Теперь вот
[31:05.160 --> 31:12.360]  эту вершинку наливаю, я делаю сюда. У меня вот такая вот штука. Это zig zag. Согласен? Давай
[31:12.360 --> 31:21.160]  смотреть, что здесь произойдет. Пятерка останется, если что, на месте. А ты хочешь поэтапный или финальный?
[31:21.160 --> 31:32.240]  Понял, смотри. Что мы делаем здесь? А давайте я лучше, наверное, поэтапный тоже сделаю. В начале,
[31:32.640 --> 31:40.960]  что у меня здесь происходило? Я менял child и parent. Если я меняю здесь child и parent,
[31:40.960 --> 31:50.000]  тогда в этом случае у меня четыре пока остается на месте. А что происходит с child
[31:50.000 --> 31:51.000]  и parent в этом случае?
[31:51.000 --> 32:19.320]  Так, остальные? Все согласны?
[32:21.000 --> 32:44.720]  Что не так? Один, два должно быть правее, чем три. Смотрите, очень просто.
[32:51.000 --> 33:12.000]  Кто там что обсуждает? Скажите тоже. Видите, как перемещается A, B, C? B становится чем? Оно было
[33:12.000 --> 33:22.800]  левыми детьми C, а стало правыми детьми P. Почему? Потому что P должно быть меньше, чем B,
[33:22.800 --> 33:37.000]  правильно? То есть B больше, чем P. А все, что больше лежит где, правее. Поэтому здесь становится вот так.
[33:37.000 --> 33:54.800]  Один, два. А, ой, sorry, я это, да. Извините. Закрашенная клеточка, ту, которую мы ищем как раз,
[33:54.800 --> 34:02.160]  нулевая, которую мы поднимаем. Вот, я сделал один лишь поворот вот этот вот. Теперь мне нужно
[34:02.160 --> 34:22.680]  сюда их повернуть. Когда я это делаю, я с вами получаю здесь пять, здесь что? Ну и так. А слева три.
[34:32.160 --> 34:39.040]  5, 4, 3, 2, 1. Это номера вершин? Это номера вершин? Это не числа? Нет, нет, нет. Это просто номера для того,
[34:39.040 --> 34:45.200]  чтобы нам было легче понимать и воспринимать. Вот, у нас получилась вот такая вот штука, согласен?
[34:45.200 --> 34:54.720]  Но осталось сделать один зиг. Или зак, как хотите назовите. Ок, но это легко уже сделать, согласен?
[34:54.720 --> 35:10.360]  Ну, типа на всякий случай. Вот у меня здесь останется три. Один, два. Вот. А здесь будет 5,
[35:10.360 --> 35:20.600]  и у пятёрки где будет четвёрка? Слева. Вот такое дерево получится. Вот так мы поднимали эту вершинку.
[35:20.600 --> 35:33.080]  Понял? Теперь стал понять, нет? Вообще без разницы. Сейчас без разницы. Я объясню в конце,
[35:33.080 --> 35:38.680]  почему это так выходит. Хорошо? Мы проанализируем. Вот, функция Play работает вот именно по таким
[35:38.680 --> 35:43.440]  концепциям. То есть у нас есть зиг-зиг, у нас есть зиг-заг. И вот в зависимости от того,
[35:43.440 --> 35:48.760]  что происходит, мы с этим делаем. Вот здесь у меня был зиг-зиг, вот дальше у меня здесь был зиг-заг.
[35:49.640 --> 36:03.520]  А, вопрос? Да. Нет. Нам для оценки нужно больше, иначе у нас будет проблема. Окей? Окей.
[36:03.520 --> 36:13.200]  Вот здесь? У нас зиг-заг, но я расписал его по действиям. Сначала вот этот кусочек,
[36:13.200 --> 36:20.160]  потом вот этот, чтобы не запутать вас всех. Хорошо? Готовьтесь к тому,
[36:20.160 --> 36:35.680]  что я вас попрошу поделать эти вещи на контроль. Хорошо? Да, да, да. В виде рисуночков. Я захочу
[36:35.680 --> 36:41.360]  от вас получить итог. Вот. В общем, так работает Play. Теперь переходите на следующий слайд. Там
[36:41.360 --> 36:47.880]  будет Find. Смотрите, Find работает просто рекурсивно. То есть, опять же, нашли ключ,
[36:47.880 --> 36:54.760]  выводим ключ. Нашли, если меньше, тогда идем влево. Если больше, тогда идем вправо. Ну и так далее.
[36:54.760 --> 37:08.280]  Все просто. И здесь единственное, что добавляется, знамите, сплей root. Видите функцию сплей? Вот это
[37:08.280 --> 37:15.440]  сплей и является тем самым отличием от обычного бинарного дерева поиска. Оно показывает,
[37:15.440 --> 37:23.560]  что наша вершина поднимается вверх с помощью рекурсии. Почему? Потому что сплей делает один лишь
[37:23.560 --> 37:32.600]  зиг-зиг, зиг-заг или зиг или заг. Или заг-зиг или заг-заг. Вот. В общем-то, сплей делает только одно.
[37:32.600 --> 37:39.680]  Но важный момент здесь следующий. Так как у нас есть стек рекурсии, то этот стек, когда
[37:39.680 --> 37:45.840]  начнет раскручиваться, этот сплей начнет выполняться последовательно и поднимая нашу вершинку. Понятно?
[37:45.840 --> 37:52.280]  Но это примерно так же, как мы ищем минимум, максимум всякие такие вещи. Вот. То есть, мы здесь
[37:52.280 --> 37:58.000]  будем брать и поднимать эту вершину в корень с помощью зиг-зигов, зиг-загов. И все. Все становится
[37:58.000 --> 38:07.680]  хорошо. То есть, мы тянем ее вверх, все получается. Вопросы есть? Пока что. А? Нет, почему?
[38:07.680 --> 38:20.840]  Подожди. Ты не понял. Смотри, при ретернете делаешь сплей. Этот сплей поднимает вверх. Но важный
[38:20.840 --> 38:30.920]  момент, когда мы нашли ключ. Мы же когда искали ключ, он вызывал еще один файнт рекурсивно. Там еще
[38:30.920 --> 38:39.040]  один сплей. То есть, смотрите, там много сплеев. Эти сплеи будут вот все время браться для этих
[38:39.040 --> 38:45.080]  вершин и поднимать ее вверх. Нам настолько без разницы, как будет выглядеть дерево в любой момент времени.
[38:45.080 --> 39:03.800]  Понятно? Вот. Да. Ищет положение ключа. Да. Ну вот key равно root key. И вот этот файнт, по факту,
[39:03.800 --> 39:09.680]  он берет, находит этот ключ. Ключ-то где он находит? Он возвращает ноду звездочка, он возвращает эту
[39:09.680 --> 39:22.200]  ноду, указательную эту ноду. Но эта нода будет в корне. Сплей возвращает на новый root. Ну то есть,
[39:22.200 --> 39:28.040]  когда он поднял какую-то вершинку, вот после вот этого, к примеру, действия, он вернет указательную
[39:28.040 --> 39:37.240]  вот это. А предполагаем, что все есть. Если нет, тогда все будет хорошо тоже, потому что мы будем
[39:37.240 --> 39:49.520]  поднимать в корень что-то. Подожди. Ты дойдешь до этого. Мы все дойдем до этого момента. Обычно в
[39:49.520 --> 39:55.680]  конце все говорят, что очень плохо. Вот. Но мне очень нравится это дерево, сразу скажу. Прям
[39:55.680 --> 40:02.160]  категорически. Если этого числа, к примеру, нет, тогда он вот этим ифом пройдется по максимуму,
[40:02.160 --> 40:06.240]  по которому есть, и найдет ближайший, и поднимет его, если что. Ну потому что он
[40:06.240 --> 40:16.680]  будет все равно выполнять этот сплей. Понятно? Странная реализация будет. Очень странно это
[40:16.680 --> 40:26.200]  всего. Вот. Поехали дальше. С точки зрения какой-то сложности, у нас осталось две новые вещи. Вставка и
[40:26.200 --> 40:31.080]  удаление. Вставка и удаление нужно их как-то реализовать, нужно понять, как это делать. И на
[40:31.080 --> 40:36.640]  самом деле для реализации вставки и удаления существует такая вещь как сплит и мерч. Вы еще
[40:36.640 --> 40:42.480]  познакомитесь, точнее не познакомитесь, вы будете вспоминать скорее про вот эту лекцию на декартовых
[40:42.480 --> 40:49.960]  деревьях, потому что сплит и мерч тоже применяется. Объясню, что такое сплит и что такое мерч.
[40:49.960 --> 41:01.280]  Смотрите, сплит умеет разделять, думаю вы поняли из названия, разделять дерево. Представим,
[41:01.280 --> 41:07.560]  что у меня есть какое-то единое дерево, и я вот по какому-то ключу K хочу его разделить на два.
[41:07.560 --> 41:22.320]  Я сделаю сплит по этому ключу. Вы там это не буяньте, если скажете, что все совсем плохо и непонятно,
[41:22.320 --> 41:35.040]  лучше скажите. Вот. Я хочу получить из него два дерева T1 и T2. Причем это все еще бинарные деревья
[41:35.040 --> 41:45.120]  поиска и все ключи в T1 меньше, чем T2. Причем вот здесь они меньше, чем K, вот здесь они больше,
[41:45.120 --> 41:55.520]  чем K. Если у нас был равный K, то мы его выкинули. Понятно? То есть сплит занимается именно таким вот
[41:55.520 --> 42:04.960]  делом. Понятно, что он делает. Понятно, что так можно сделать, я надеюсь, правда? Все понимают это.
[42:04.960 --> 42:24.720]  Делим дерево. Нет. Нет, этот ключ не обязательно существует вообще в этом дереве. А если существует,
[42:24.720 --> 42:36.680]  то мы его выкидываем. У меня два дерева в результате T1 и T2. Мы знаем, что в T1 у нас меньше ключа
[42:36.680 --> 42:47.600]  все значения, в T2 все больше. Вот. В результате такое. Два дерева. Он разрезал просто дерево.
[42:47.600 --> 43:01.720]  А в чем проблема вернуть два дерева? Кто вам такое сказал? Зачем вы проходили структуру?
[43:01.720 --> 43:10.240]  Вам нужно вернуть два указателя, два указателя на рут. Правда? Вот два указателя на эти деревья
[43:10.240 --> 43:18.840]  сделать. Пока с этим сделаю. И следующий слайд именно об этом как раз-таки. Сплитет 3, пока вы еще парни
[43:18.840 --> 43:24.040]  знаете и так далее, вот здесь можно использовать это. Там будет указатель на левое дерево, указатель
[43:24.040 --> 43:33.040]  на правое дерево. Ну и просто его конструктор для того, чтобы было проще жить. Понятно? Ну вот,
[43:33.240 --> 43:41.760]  он может вернуть объект сплитет 3. Логично? Логично. Вот. И мы самостоятельно будем гарантировать,
[43:41.760 --> 43:52.640]  что в этом сплитет 3 левое дерево меньше правого. Вот. И разрезана она ключом. Поехали дальше.
[43:52.640 --> 44:00.280]  Теперь реализация. Возможно, вам не нравится эта реализация. Она выглядит чуть-чуть громоздко,
[44:00.280 --> 44:07.280]  но в действительности что здесь вообще происходит? Давайте разберем два таких
[44:07.280 --> 44:17.240]  корнер-кейса. Как этот сплит работает. Смотрите. Предположим, что у меня было некоторое дерево.
[44:17.240 --> 44:28.000]  Вот у меня было дерево и в нем внутри где-то лежал этот ключ K. Ага. Если я сделаю find этого
[44:28.000 --> 44:37.480]  ключа, что у меня произойдет с плей дерева? Всплывет вер и у меня тогда будет ключ здесь. У меня будет
[44:37.480 --> 44:46.120]  левый его кусок и правый его кусок. А теперь смотрите. Согласны ли вы, что в левом куске находится
[44:46.120 --> 44:55.540]  все меньше? Это и есть наш T1. Согласны ли вы, что в правом куске находится все больше? Это и есть
[44:55.540 --> 45:04.580]  наш T2. Осталось удалить ключ. Теперь следующий вопрос. Что будет, если нет ключа?
[45:14.580 --> 45:23.380]  Там left и right. Да, мы удалили root. Sorry. Там left и right. Да, это правда. Я тоже умею лагать.
[45:23.380 --> 45:38.740]  Знаете этот факт. Это бинарное дерево-поиск. Как оно может это не поддерживать? Да, правые-левые
[45:38.740 --> 45:49.980]  повороты абсолютно все всегда сохраняют. Еще раз, тут чиселки означают номера вершин. Не числа.
[45:49.980 --> 46:03.060]  Хорошо. Давайте значение. Я понял вас. Вам сложно. 15. Давайте я буду обводить это. 15.
[46:03.060 --> 46:32.060]  Нет. Сейчас. Момент. Давайте тут 14. Тут 6, 7, 8 и 9. Поехали сюда. 9, 8, 7, 6,
[46:32.060 --> 47:01.540]  14, 15, 15, 14, 9, 6, 8, 7, 15, 14, ой, нет, 9, 14, 6, 8, 7,
[47:02.020 --> 47:11.460]  так стало понятнее. Мы сохраняем. Любые повороты сохраняют это все, а не на той повороте, а не изменения
[47:11.460 --> 47:33.700]  дерева. Вот. Так вот, если мы вдруг нашли ключ, тогда в этом случае мы с вами говорим о том,
[47:33.700 --> 47:40.180]  что у нас есть ключ, все хорошо. Если же такого ключа не существует в нашем дереве,
[47:40.180 --> 47:48.420]  а, заметьте, я делаю все равно find, root и key. Когда я делаю этот find, что он делает? Он тот самый,
[47:48.420 --> 47:55.380]  вот, грубо говоря, ближайшее значение его и выкидывает вверх. Вот этот find все равно его
[47:55.380 --> 48:02.700]  выкидывает наверх. И дальше мы смотрим, это ближайшее значение, оно меньше или больше моего ключа?
[48:02.860 --> 48:20.420]  Если оно меньше, то есть значение, вот тут которое лежит, там x, если оно меньше, то какое дерево оно
[48:20.420 --> 48:29.940]  должно войти? Влево или вправо? Влево. То есть я сделаю так разрез. Если оно войдет, если оно
[48:29.940 --> 48:45.620]  больше, то оно влево или вправо войдет? Тогда я сделаю так разрез. Все. А вот. Поэтому здесь мы можем
[48:45.620 --> 48:59.020]  это делать таким вот образом. Вопросы есть? Нет.
[48:59.020 --> 49:24.700]  Обязательно. У нас нет этого ключа, иначе бы find нашел этот ключ. Понятно? Да. Только не
[49:54.700 --> 50:13.660]  нет. Еще раз, у тебя find кладутся вот так. F там 1, F2, F3, F4. Это все find и так далее. Самый
[50:13.660 --> 50:22.540]  верхний find, что делает? Он делает, вызывает сплей. Сплей того, до чего дошел. Самое близкое нашел. Согласен?
[50:25.020 --> 50:33.660]  Он делает этот сплей. Потом следующий find тоже делает сплей. Того же элемента и так далее.
[50:33.660 --> 50:44.380]  Он либо находит этот элемент, либо если он его не находит, то он берет и делает сплей.
[50:44.540 --> 50:59.620]  Тоже его. Он делает элементы близкие к нашему. Простите, пожалуйста. Смотрите, я спрашиваю, вот
[50:59.620 --> 51:09.660]  find. Давайте еще раз. Мы говорим, что если у нас ключ меньше, чем ключ, который лежит в корне,
[51:09.820 --> 51:19.540]  тогда в этом случае мы идем в левую часть, иначе в правую часть. Вот он идет в левую часть и ищет там,
[51:19.540 --> 51:25.900]  потом ищет еще, ищет еще и так далее. И он находит близкий к нашему ключу значение,
[51:25.900 --> 51:37.260]  самое ближайшее, которое находится. Меньше, больше. Понятно? Да, ближайшее значение.
[51:39.660 --> 51:49.380]  У нас нет балансировки. Забейте пока на нее, типа не существует ее.
[51:49.380 --> 52:00.340]  Балансировка по высоте это ВВЛ деревьев. В ВВЛ деревьев у тебя высота лево-право по
[52:00.340 --> 52:07.300]  дереву отличается не более чем на единицу. Не, все нормально. Так вот, у нас есть сплит. Сплит,
[52:07.300 --> 52:15.380]  я надеюсь, вы поняли сутивый смысл этого сплита. Как он берет и распличивает эти моменты. Понятно?
[52:15.380 --> 52:20.980]  Это было понятно, надеюсь. Отлично. То есть он берет и раскидывает эти элементики. А теперь
[52:20.980 --> 52:27.940]  смотрите, когда он взял их и раскинул. Что у нас есть? У нас есть два дерева. В одном меньше ключ,
[52:27.940 --> 52:35.460]  в другом больше ключа. А теперь представьте, что я должен вставить ключ. Куда мне его вставить,
[52:35.780 --> 52:44.980]  если у меня есть два дерева? У меня есть дерево Т1, у меня есть дерево Т2. И я знаю, что вот этот вот
[52:44.980 --> 52:54.340]  меньше key строго, вот этот больше key. Где у меня должен встать key, если я его вставляю? Корень.
[52:58.340 --> 53:05.220]  Вот этой будет insert. Кто делает insert? Можете следующий слайд посмотреть. Insert делает
[53:05.220 --> 53:10.740]  следующее. Он берет, сплитит наше дерево, разрезая его на два. Где у нас меньше ключ, где у нас
[53:10.740 --> 53:19.940]  больше ключ. После этого, после этого он просто берет и говорит, что я создаю новую ноду. У нее
[53:19.940 --> 53:26.220]  теперь левый ребенок. Это левое под дерево, правое ребенок, правое под дерево. А он становится корнем.
[53:26.220 --> 53:37.740]  Просто. Там и вопрос типа в сплите. Вот если сплит вы понимаете, то все очень просто. Ясненько?
[53:37.740 --> 53:49.420]  Прекрасненько. Поехали дальше. Merge. Смотрите, кроме сплита бывает merge. А когда у нас с вами есть
[53:49.420 --> 53:57.340]  вот два, грубо говоря, таких же дерева, одно меньше, чем другое, то нам необходимо взять и склеить их
[53:57.340 --> 54:02.580]  периодически. То есть мы их могли расплитить. Иногда нужно взять их и склеить. Как мы можем это
[54:02.580 --> 54:08.540]  сделать? Но мы с вами уже подобное проворачивали. Помните, когда мы переподвешивали всякие вершинки?
[54:08.540 --> 54:20.060]  Что может быть корнем у этих двух деревьев? Да, то есть мы можем просто найти здесь вот тот самый
[54:20.060 --> 54:28.580]  минимум и запихнуть его наверх. И сказать, что он будет корнем. Понятно? Потому что мы его найдем,
[54:28.580 --> 54:35.340]  он точно будет больше, чем все остальное. И в то же время он будет меньше, чем здесь. А теперь
[54:35.340 --> 54:42.540]  смотрите, какая хитрость здесь. Мы можем с вами искать это, потом переподвешивать, еще что-то. Зачем
[54:42.540 --> 54:51.820]  нам нужно это делать? Если мы просто можем взять с вами и сделать find в дереве T2 какого-нибудь
[54:51.820 --> 54:58.980]  ключа, например, корня из T1. Что в этом случае он найдет? Он найдет самый ближайший элемент к
[54:58.980 --> 55:06.020]  нашим. А самый ближайший какой будет? Наименьшим, потому что там все элементы меньше ключа, а там все
[55:06.020 --> 55:17.180]  элементы больше. А find мы ищем относительно дерева T2. То есть последовательность действий примерно
[55:17.180 --> 55:28.260]  следующая. Вот здесь. Ну какой-то вот здесь х лежит. Я делаю find х в T2. Если я делаю find х в T2,
[55:28.260 --> 55:35.980]  то он поднимет вот этот минимальный корень, потому что find делает еще display. А если он поднялся в корень,
[55:35.980 --> 55:47.300]  то смотрите, у меня есть вот этот вот минимум. Где все дерево T2 остальное лежит? Правее. Вот этот
[55:47.300 --> 55:57.540]  вот T2 без минимума. И у него левого ребенка-то нет, потому что он поднялся в корень, а левый
[55:57.540 --> 56:05.660]  ребенка быть не может, потому что нет ничего меньше в T2, чем он сам. А значит мы просто сюда подвесим T1.
[56:05.660 --> 56:18.980]  Да, merge должен сделать из двух деревьев в одно. Ну склеивает их. Понятен смысл того,
[56:18.980 --> 56:31.300]  что я сейчас сделал. Ребят, да, нет, смерть, не знаю, что. Типа все плохо, непонятно. Так вот,
[56:31.300 --> 56:35.620]  ну если вы перейдете в реализацию следующий слайдик, то там написано гораздо меньше,
[56:35.620 --> 56:42.300]  чем в сплете. Почему? Потому что мы просто проверяем есть там это имя или нет. Но если
[56:42.300 --> 56:48.100]  что-то какое-то из деревьев на lptr, тогда мы просто возвращаем одно из этих деревьев. Если же у нас
[56:48.100 --> 56:57.620]  они оба не на lptr, тогда в этом случае я возвращаю. Я говорю, что правое дерево у меня равно find в
[56:57.620 --> 57:04.540]  правом поддереве ключа из левого. Он находит ближайший к нему, этот ближайший находится где. Это
[57:04.540 --> 57:10.460]  минимальный элементик. Поэтому у этого минимального элемента нет левого ребенка. Значит, я говорю,
[57:10.460 --> 57:19.220]  что right left равно left. Left это дерево слева, вот тот t1, который я вам нарисовал. Ну и все. Дальше
[57:19.220 --> 57:31.940]  parent восстанавливаем и закончим. Merge очень простой. Согласны или не согласны? Ну ладно. Хорошо.
[57:31.940 --> 57:38.620]  Теперь remove. Ну то есть когда я хочу удалить что-то, следующий слайдик. Для того, чтобы удалить
[57:38.620 --> 57:46.820]  некоторую вершину, вам нужно всего лишь поднять ее наверх, а потом слить ее левое и правое поддерево.
[57:46.820 --> 57:55.660]  Согласны? Вам нужно просто замерзнуть их. Поняли, что я имею ввиду? То есть еще раз,
[57:55.660 --> 58:02.860]  я делаю тот же самый find этой вершинки. Она поднимается наверх и если что потом склеивается.
[58:02.860 --> 58:15.460]  Okay. Remove гарантирует, что у нас такая вершинка есть. А зачем split? Еще раз, если вы делаете
[58:15.460 --> 58:21.620]  find некоторые ключи, которые у вас присутствуют, гарантируется примеру, что у вас присутствует
[58:21.620 --> 58:28.420]  этот ключ, тогда что в этом случае делается? Ну потому что иначе вообще нет смысла. Ну вот
[58:28.420 --> 58:36.180]  вы можете в этот записать типа, не знаю там, если root key не равен кею, тогда выкинуть на
[58:36.180 --> 58:42.180]  SNALPTR. Но еще раз, remove что делает? Когда вы сделаете find key, у вас будет вот этот key.
[58:42.180 --> 58:52.380]  Согласны? Вам нужно удалить этот ключ. Вы берете его, удаляете и делаете merge t1 и merge t2.
[58:52.380 --> 59:05.500]  Ну просто. Ну мы можем сказать, что если у нас корень равен ключу, а не равен, тогда в этом
[59:05.500 --> 59:14.340]  случае SNALPTR выкинь. Ну можно так. Можете добавить, я не против. Но в принципе это все достаточно
[59:14.340 --> 59:21.140]  понятно и просто должно. Согласны? Смотрите, мы с вами разобрались со сплей деревом с точки
[59:21.140 --> 59:30.500]  зрения, вставки, поиска, удаление, элементика. Осталось понять главное, за сколько это работает.
[59:30.500 --> 59:38.580]  И вот тут я сразу прошу прощения, но там доказательства объемные и большое. Я специально
[59:38.580 --> 59:45.260]  выпишу почти все шаги на презентацию для того, чтобы вы потом не сломались мне перед экзаменом и не
[59:45.260 --> 59:49.980]  говорили, что мы ничего не понимаем. Хорошо? Мы могли спокойно сесть и прочитать. Вроде бы там все
[59:49.980 --> 59:58.180]  понятно написано. Поехали. Анализ времени работы алгоритма. Смотрите, заметьте, мы в любом алгоритме
[59:58.180 --> 01:00:05.340]  с вами используем сначала find, а потом какие-то простейшие операции. Завод единички. Согласны?
[01:00:05.340 --> 01:00:13.460]  Вот. А сама по себе функция find работает пропорционально глубине искомой вершины,
[01:00:13.460 --> 01:00:22.060]  после чего делает сплей этих всех вершин. Согласны? Отлично. Вот. И, по сути, вот эта
[01:00:22.060 --> 01:00:27.900]  функция сплей, она тоже работает пропорционально этой глубине. То есть ровно столько же, сколько там
[01:00:27.900 --> 01:00:36.700]  было, если смотреть весь сплей. Ок. То есть нам нужно оценить просто время работы сплей дерева.
[01:00:36.700 --> 01:00:45.820]  Ой, просто сплей. Господи. Функции сплей. Будем оценивать это с помощью нашего любимого
[01:00:45.820 --> 01:00:54.620]  амортизационного анализа. И в особенности с помощью метода потенциалов. И вот здесь потенциалом будет
[01:00:54.620 --> 01:01:04.260]  выступать следующая величина. Представьте, что у нас есть размер под дерево в количестве вершинок.
[01:01:04.620 --> 01:01:13.300]  Количество вершинок. Окей? Вот это вот S я назову. S от V. Вот по дереве с корнем V, S от V вершинок.
[01:01:13.300 --> 01:01:22.060]  Рангом вершинки назовем двоичный логарифм от этого количества вершинок. Всё понятно. Ну просто
[01:01:22.060 --> 01:01:28.260]  логарифм от количества вершинок с корнем в этой вершине. А теперь смотрите. Потенциал дерева
[01:01:28.260 --> 01:01:36.900]  T, то есть состояние, потенциал нашего состояния, он будет сумме всех рангов в этом под дереве.
[01:01:36.900 --> 01:01:50.700]  Ранг это двоичный логарифм от количества вершин в этом под дереве. То есть смотрите. Я же говорил,
[01:01:50.700 --> 01:01:55.780]  что потенциалы это не очень просто и не всегда их можно легко найти. Вот в этой
[01:01:55.780 --> 01:02:17.020]  задаче нужно было подумать на тему того, как это сделать. Что еще раз? Да. Да. Это обычно бильет.
[01:02:26.740 --> 01:02:33.780]  Смотрите. Сплей дерева одно из самых сложных в нашем курсе. Это правда,
[01:02:33.780 --> 01:02:38.300]  но то, что он может вам попасться просто так в билетах, конечно.
[01:02:49.300 --> 01:02:51.820]  Ну давайте про это поговорим попозже, про экзамен. Да.
[01:02:55.780 --> 01:03:05.220]  Ну мы когда докажем, вы поймете, что это работает.
[01:03:05.220 --> 01:03:28.380]  Да, метод мат-индукции ты понимаешь, как для суммы делать, для суммы квадратов. Ты вот понимаешь,
[01:03:28.380 --> 01:03:36.100]  откуда эта формула предполагается? Ну нет. Опять же, нет. На самом деле здесь есть
[01:03:36.100 --> 01:03:42.700]  некоторый смысл. Смысл в том, что мы хотим доказать, что наш сплей работает за логарифм.
[01:03:42.700 --> 01:03:51.620]  Логарифм от количества вершин. Ну то есть мы хотим доказать, что это сплей дерева, в принципе,
[01:03:51.620 --> 01:03:57.660]  отвечает на запросы в амортизационном случае за логарифм. Мы хотим сказать,
[01:03:57.660 --> 01:04:04.020]  что оно не хуже, чем, в общем, другие деревья. Поэтому здесь это так. Но потенциал это сумма логарифма.
[01:04:04.020 --> 01:04:19.500]  Понятно? Да. Не-не-не. Под дерево имеется в виду следующее. Вот у меня есть там, как-то связано было,
[01:04:19.500 --> 01:04:26.620]  вот у меня есть вершина В. Вот у него есть его по деревьям, но все вот это по дереву. Вот это
[01:04:26.620 --> 01:04:43.380]  вопросы. А? Снизу. Снизу в анализе времени работы. Смотрите, а что такое фиатэ? Фиатэ это сумма
[01:04:43.380 --> 01:04:50.500]  всех рангов вершинок, которые вот здесь вот есть. То есть это некоторая сумма таких логарифмов двоичных.
[01:04:50.500 --> 01:04:59.980]  Всех вершин, которые здесь есть. Это сумма логарифм. Это не логарифм. Это сумма логарифм.
[01:04:59.980 --> 01:05:12.460]  Сумма этих рангов. Пока понятно? Это только начало. Поехали дальше. Следующее утверждение,
[01:05:13.020 --> 01:05:17.860]  которое по факту покажет нам то, что будет действительно эта все работа за логарифм.
[01:05:17.860 --> 01:05:30.500]  Амортизационная стоимость операции сплей от вершины В в дереве Т с корнем R. Ну короче,
[01:05:30.500 --> 01:05:37.300]  у вас есть дерево, у него корень R, и вы находите, ну вы делаете сплей от вершинки В. Поднимайте.
[01:05:37.300 --> 01:05:46.620]  Вот амортизационная стоимость этой операции будет 3 на ранг R минус ранг В плюс единичка.
[01:05:46.620 --> 01:05:59.100]  Вот это мы сейчас будем доказывать. Это дальше. Это не утверждение без доказательства. Это
[01:05:59.100 --> 01:06:06.060]  просто то, что мы будем с вами доказывать. Заметьте, пожалуйста, что ранг R это что логарифм.
[01:06:06.060 --> 01:06:16.100]  Ранг R это один логарифм. Логарифм этого всего дерева. Это не потенциал. Ранг это просто логарифм от
[01:06:16.100 --> 01:06:23.580]  суммы всех элементов, которые там есть. Сумма всех узлов. То есть это все узлы. То есть от логарифм N.
[01:06:23.580 --> 01:06:30.980]  От количества, да. То есть логарифм N от количества. И минус ранг В. Ранг В может быть каким угодно.
[01:06:30.980 --> 01:06:37.540]  Хоть ноликом и так далее. Потому что одна вершинка тоже может быть. А может быть и не ноль.
[01:06:37.540 --> 01:06:47.420]  То есть в общем-то ограничено по факту тремя логарифмами. Вот это здесь говорится. Поехали
[01:06:47.420 --> 01:06:54.380]  доказывать. Поехали на следующий слайд. Их будет много с таким большим текстом для того,
[01:06:54.380 --> 01:06:59.780]  чтобы вы могли, если что, сесть почитать. Я сейчас буду вам рассказывать. Вы должны
[01:06:59.780 --> 01:07:07.820]  меня останавливать в моменте, когда вы что-то не понимаете. Хорошо? Смотрите. Если вы это корень,
[01:07:07.820 --> 01:07:13.860]  то утверждение очевидно. Правда? Но все логично. Нам нужно сделать одну проверку и это будет одно и
[01:07:13.860 --> 01:07:22.100]  то самое действие. А дальше логарифм друг друга убьют. Ок. Ок. В противном случае мы разделим
[01:07:22.100 --> 01:07:32.140]  функцию сплей на несколько этапов. У нас возможен один из трех поворотов. Зик, зик-зик,
[01:07:32.140 --> 01:07:40.900]  зик-зак. Зак-зик и зак-зак это одно и то же. Симметрично нас не сильно интересует. На
[01:07:40.900 --> 01:07:49.980]  простой поворот, то есть зик, уходит единичка времени. Для того, чтобы поменять местами вершинки,
[01:07:49.980 --> 01:07:54.260]  мы будем говорить, что у нас единица времени какая-то уходит. На два простых поворота,
[01:07:54.260 --> 01:08:04.820]  то есть на зик-зик или зик-зак две единички времени. Ок. Ок. После каждого этапа ранг вершины будет
[01:08:04.820 --> 01:08:11.740]  меняться. Пусть он в начале равен ранг В0, то есть там, где он находится, то есть ранг В по факту,
[01:08:11.740 --> 01:08:21.100]  ранг В0. А после этого ранг ВИТ. И для каждого этапа, может быть, кроме последнего, мы покажем,
[01:08:21.100 --> 01:08:26.700]  что мортизационное время на его выполнение можно ограничить сверхувеличенной вот этих три ранг
[01:08:26.700 --> 01:08:34.180]  ВИТ, минус ранг ВИТ, плюс единичка. Вот если мы все это покажем, то у нас все получится. Как это
[01:08:34.180 --> 01:08:41.660]  можно показать? Ну, для начала все просто. Если мы возьмем и скажем, что действительно будет так,
[01:08:41.660 --> 01:08:49.300]  тогда эту единичку мы с вами выкинем. В действительности она нам будет не нужна. Это плюс единица, она за суммой.
[01:08:49.300 --> 01:08:57.740]  А дальше там сумма рангов, ну как бы ранг ВИТ, минус ранг ВИ, минус первая, а где-то было плюс ранг ВИ,
[01:08:57.740 --> 01:09:02.980]  минус первая, минус ранг ВИ, минус вторая и так далее. Но это ровно как с потенциалами. Мы получим
[01:09:02.980 --> 01:09:14.980]  итоговое значение, минус начальное значение. Да, нам нужно это показать. Ну, мы в утверждении это
[01:09:14.980 --> 01:09:21.700]  написали, что мы хотим такое показать. Понятно? Теперь поехали следующие. Анализ времени работы
[01:09:21.700 --> 01:09:32.260]  каждого из zig, zigzag, zig, zig, zig, zigzag. Первый zig. Фактическое время единичка. Посмотрим
[01:09:32.260 --> 01:09:37.580]  на рисунке и поймем, как работают у нас здесь ранги. Напомню, потенциал — это сумма всех рангов.
[01:09:37.580 --> 01:09:45.260]  Согласны ли вы, что ранги из А, Альфы, Беты и Гаммы, они не влияют для нас, потому что там
[01:09:45.260 --> 01:09:50.940]  сумма рангов одна и та же. Правда? Ну вот, что была до этого, что и осталось. Там не изменилось
[01:09:50.940 --> 01:09:55.940]  количество вершин, оно ровно такое же осталось. Поэтому мы рассматриваем лишь нашу вершину В и
[01:09:55.940 --> 01:10:10.380]  П. Прошу прощения. В и Р. Ок? Ок. Смотрите, каким стал потенциал? Ну, во-первых, единичка в
[01:10:10.380 --> 01:10:16.500]  начале, которая стоит, это тот самый плюсик от того действия, что мы поменяли. Дальше мы смотрим на
[01:10:16.500 --> 01:10:26.100]  разность потенциалов. Потенциал стал это ранг В штрих плюс ранг Р штрих. Правда? Ну вот справа то,
[01:10:26.100 --> 01:10:34.100]  что нарисовано, потенциал такой. Ранг Альфа, Бета, Гаммы меня не интересует, потому что они вычтутся
[01:10:34.100 --> 01:10:46.300]  друг из дружки. Они не меняются. Альфа — это под дерево, Бета — это под дерево. Ну смотри, АИТО — это
[01:10:46.300 --> 01:10:54.820]  количество времени, которое ты потратил на это действие. Да, помните, как мы искали в амортизационном
[01:10:54.820 --> 01:11:00.740]  анализе с помощью метода потенциалов? Мы говорили, что у нас затрачивается время ТИТ, плюс разница
[01:11:00.740 --> 01:11:09.460]  потенциала ФИСИТА минус ФИСИ-1. Было такое. Да, мы это и считаем. Мы говорим, что у нас единичка — это
[01:11:09.460 --> 01:11:15.940]  та самая единичка из-за того, что мы тут поворачиваем. И у нас есть ранг В штрих плюс ранг Р штрих.
[01:11:15.940 --> 01:11:27.180]  Нет. Еще раз, АИТО как работает? Вы подождите, вы сразу пытаетесь уйти в утверждение. Помните,
[01:11:27.180 --> 01:11:34.060]  мы с вами говорили, что время работы с методи потенциалов — это равно ТИТ, реальное время работы,
[01:11:34.060 --> 01:11:49.700]  плюс ФИСИТА минус ФИСИ-1. Было такое. Вот это ТИТА равно единице. Вот это ФИСИТА — это, по сути,
[01:11:49.700 --> 01:12:06.300]  ранг В штрих плюс ранг Р штрих. Но там есть еще плюс АЛЬФА, БЕТА, ГАМА ранги их. Еще раз,
[01:12:06.300 --> 01:12:18.880]  ПИ — потенциал. Потенциал я как задал? Как сумма рангов. Но это состояние дерева. Это состояние. То
[01:12:18.880 --> 01:12:26.400]  есть то, как выглядит дерево. Я говорю, что мой потенциал равен сумме всех рангов. Что такое ФИСИ-1?
[01:12:26.400 --> 01:12:39.640]  Это ранг В плюс ранг Р плюс АЛЬФА, БЕТА, ГАМА. Тогда АЛЬФА, БЕТА, ГАМА я их никогда не буду
[01:12:39.640 --> 01:12:51.240]  учитывать. Они сразу испаряются. Еще раз, АЛЬФА, БЕТА, ГАМА — это те самые. Они вычитаются друг
[01:12:51.240 --> 01:12:56.520]  из друга. У них не меняется количество элементов. Поэтому у меня там написано ранг В штрих плюс
[01:12:56.520 --> 01:13:11.400]  ранг Р штрих минус ранг В минус ранг Р. Ровно так же. Все потенциалы складываются. Ранг В плюс ранг Р
[01:13:11.400 --> 01:13:23.560]  плюс АЛЬФА, БЕТА, ГАМА. Возьмите две вершинки, которые нарисованы, плюс все по деревьям. Я прошу
[01:13:23.560 --> 01:13:29.000]  прощения, но я вас задержу, потому что потом вы мне скажете, что я вам не объяснил свой дерево.
[01:13:29.000 --> 01:13:42.880]  Да, для всего дерева. Да, потенциал равен сумме всех рангов в нашем дереве. Понятно?
[01:13:42.880 --> 01:13:55.480]  Еще раз, мы анализируем зиг, зиг-зиг и зиг-заг. Мы каждый из этих случаев рассматриваем, а после этого мы
[01:13:55.480 --> 01:14:01.720]  уже сказали на предыдущем слайде, что если мы рассмотрим там, а каждый из них в отдельности,
[01:14:01.720 --> 01:14:06.000]  то там будут ранги эти вычитаться и все будет хорошо. Вы можете посмотреть.
[01:14:06.000 --> 01:14:19.680]  Вы поменять местами должны Р и В. Чтобы поменять местами, вам нужно потратить единичку
[01:14:19.680 --> 01:14:26.440]  времени. Мы считаем, что на переподвешивание у нас единица времени какая-то уходит. Еще вопросы?
[01:14:26.440 --> 01:14:35.560]  Нет. Теперь смотрите, согласны ли вы с тем, что ранг Р равен рангу В штрих?
[01:14:35.560 --> 01:14:43.000]  А остальные?
[01:14:43.000 --> 01:14:54.040]  Хорошо. Но это является корнем, у него количество элементов внутри ровно такое же,
[01:14:54.040 --> 01:15:00.640]  как и было. Поэтому они вычитаются. Поэтому ранг Р и ранг В штрих, они вычитаются и уходят.
[01:15:00.640 --> 01:15:09.000]  Поэтому это равно 1 плюс ранг Р штрих минус ранг В. Чудненько. А теперь смотрите,
[01:15:09.000 --> 01:15:15.000]  согласны ли вы с тем, что ранг Р штрих меньше, чем ранг В штрих?
[01:15:15.000 --> 01:15:32.840]  Потому что В штрих находится в корне, а Р штрих под ним. То есть В штрих априори находится,
[01:15:32.840 --> 01:15:42.920]  как минимум, на 1 узел больше. Согласны? Поэтому я могу это сделать. У меня получается меньше
[01:15:42.920 --> 01:15:49.000]  либо равно, чем 1 плюс ранг В штрих минус ранг В, но я получил наше равенство. Если я
[01:15:49.000 --> 01:15:55.120]  домножу на 3 ранг В штрих минус ранг В, то у меня ничего не изменится. Я доказал свою первую часть
[01:15:55.120 --> 01:16:05.400]  для Зиг Зига. Поехали дальше. Для Зиг Зига и Зиг Зага. Я постараюсь максимально быстро,
[01:16:06.000 --> 01:16:17.360]  и понятно. Давайте так. Согласны ли вы с тем, что фактическое время здесь это 2? Ой, господи,
[01:16:17.360 --> 01:16:23.880]  две единички времени. Потому что я должен 2 раз переподвести вершинки. Согласны? Отлично.
[01:16:23.880 --> 01:16:35.880]  Подсмотрим на рисуночек и поймем, как меняются ранги у вершин В, П и Ж. На всякий случай альфа,
[01:16:35.880 --> 01:16:41.280]  бета, гамма, дельта они тоже не меняются рангами, я их не пишу дальше. Они сокращаются, нам не
[01:16:41.280 --> 01:16:53.960]  интересно. Ну, мы считаем, что один поворот это одно действие, но они все за 1 работают,
[01:16:53.960 --> 01:17:01.240]  поэтому это быстро. В общем-то, смотрите, давайте вернемся с вами к Зиг Зигу. Во-первых,
[01:17:01.240 --> 01:17:05.880]  у нас делается два простых действия, поэтому у меня ТАИТА, давайте прям расписывать это
[01:17:05.880 --> 01:17:16.040]  по чуть-чуть, я думаю, будет полегче и понятнее. Это в действительности одна из самых таких,
[01:17:16.040 --> 01:17:25.000]  но одна из моих любимых тем, поэтому те, кто ко мне подойдут, могут ее спокойно получить.
[01:17:25.000 --> 01:17:37.120]  Вот, смотрите, у нас есть вот это ТИТ, плюс ФИСИТ, минус ФИСИ-1, вот мы с вами это так
[01:17:37.120 --> 01:17:45.560]  определяли. ТИТ, мы говорим, что оно сейчас равно двум, да? Мы делаем два действия. Теперь смотрите,
[01:17:45.560 --> 01:17:52.880]  что у нас такое ФИСИТ? Альфа, бета, гамма, дельта не меняют свои ранги, мы их не учитываем,
[01:17:52.880 --> 01:17:57.840]  потому что они вычислются друг из друга вот здесь. Понятно? Ну, то есть они в сумме убьют друг
[01:17:57.840 --> 01:18:07.520]  другу. Мы смотрим ФИСИТ. А что там есть, что могло меняться? У нас есть В, П и Ж, вершинки В, П и Ж.
[01:18:07.520 --> 01:18:24.840]  Нужно их и рассматривать. Мы говорим, что ФИСИТ это ранг Ж-плюс ранг В-плюс, какой-то
[01:18:24.840 --> 01:18:31.880]  рандомный последователь не спешу, но ладно, ранг П- и минус ФИСИТ это то же самое, что ранг
[01:18:31.880 --> 01:18:50.520]  получается Ж-плюс ранг В-плюс ранг П. Теперь смотрите, что являлось корнем в первом случае? Вот
[01:18:50.520 --> 01:18:58.820]  после изменения, ой, до изменения давайте так Ж-и, а после П-штык. Согласны, что их можно тогда
[01:18:58.820 --> 01:19:05.740]  сократить, потому что они просто являются корнями, а количество элементов у нас никак не менялось,
[01:19:05.740 --> 01:19:13.220]  поэтому я делаю вот так и вот так. Ага, теперь смотрите следующее. У меня это есть, можете перелеснуть
[01:19:13.220 --> 01:19:19.380]  следующий слайдик. Смотрим, что у нас дальше. Вот там много буквок будет, много именно с точки
[01:19:19.380 --> 01:19:30.500]  зрения того, что там формулки. Мы с вами можем знать, что у нас ранг П-штык, он меньше либо равен,
[01:19:30.500 --> 01:19:36.580]  чем В-штык. Если вы взгляните на предыдущий рисунок, то вы знаете, что П-штык меньше,
[01:19:36.580 --> 01:19:45.740]  чем В-штык. Почему? Потому что В-штык стоит выше. Согласны? Вот, кроме того, ранг П больше либо
[01:19:45.740 --> 01:20:00.140]  равен рангу В. Почему? Потому что ровно так же в предыдущем случае. Я просто это сохраняю,
[01:20:00.140 --> 01:20:05.740]  потому что у меня будет неравенство всегда, мне удобно. Так больше. Ну, если П существует.
[01:20:05.740 --> 01:20:17.420]  То есть, смотрите, вот эта часть, то есть ранг П, он больше либо равен, чем ранг В. А вот этот ранг
[01:20:17.420 --> 01:20:29.140]  П-штык, он меньше либо равен, чем ранг В-штык. Согласны? Так как это здесь стоит со знаком минут,
[01:20:29.140 --> 01:20:35.380]  тогда я могу вот это применить. Тут минус ранг П, минус ранг В. Ранг В будет больше,
[01:20:35.380 --> 01:20:45.700]  минус ранг В. Ну, отрицательное число. Тут если 5, тут 3, то минус 3 выше, чем минус 5. Окей? Это понятно.
[01:20:45.700 --> 01:20:53.540]  Поэтому я могу это подставить. И я с вами получаю, если все это подставляю, что АИТ меньше либо
[01:20:53.540 --> 01:21:05.260]  равно, чем 2, плюс. А там что у меня получается? Плюс ранг В-штык, он вот отсюда пришел.
[01:21:05.260 --> 01:21:20.140]  Плюс ранг В-штык, все верно. Плюс ранг Ж-штык, это вот отсюда. И минус, минус два ранга В.
[01:21:24.420 --> 01:21:35.420]  Ага. Окей? Это понятно. Смотрите, я хочу привести к тому, чтобы у меня было 3 ранга В-штык,
[01:21:35.420 --> 01:21:43.300]  минус 3 ранга В. Как я это могу сделать? Давайте. Ну, там ноль меньше либо равно,
[01:21:43.300 --> 01:21:54.380]  минус 2. Вот я попытаюсь сложить два неравенства. Ноль меньше либо равен минус 2, плюс 2 ранга В-штык,
[01:21:54.380 --> 01:22:13.820]  минус ранг Ж-штык, вот. И минус ранг В. Согласны, если я сложу два этих неравенства, то я получу
[01:22:13.820 --> 01:22:21.500]  нужное мне. Ну, то есть, вот этот же штык, он уйдет. Осталось лишь понять, что делать с этим.
[01:22:21.500 --> 01:22:29.780]  И как с этим жить? На самом деле, жить это просто. Если мы перенесем там, оставим минус два здесь,
[01:22:29.780 --> 01:22:34.860]  вот это все туда перенесем, мы получим ранг Ж-штык, плюс ранг В, минус ранг,
[01:22:34.860 --> 01:22:42.820]  минус два ранга В-штык. Меньше либо равно, чем минус два. Смотрите, здесь дальше происходит
[01:22:42.820 --> 01:22:48.500]  следующая хитрость. Вспоминаем, что такое ранг. Ранг — это логарифм от количества вершин. Согласны?
[01:22:48.500 --> 01:22:55.060]  Получаю, что у меня будет логарифм двоичный от количества вершин, если у нас корень Ж-штык,
[01:22:55.060 --> 01:23:02.300]  плюс логарифм от количества вершин В, минус два логарифма В-штык. Когда у вас вычитаются
[01:23:02.300 --> 01:23:08.740]  логарифмы, что делается с одинаком основанием? Деление. Я получаю с вами двоичный логарифм от
[01:23:08.740 --> 01:23:19.060]  деления СЖ-штык на СВ-штык, плюс логарифм СВ на СВ-штык. Ага. Согласны ли вы с тем,
[01:23:19.060 --> 01:23:28.980]  что мы знаем, что СВ-штык больше либо равен, чем СЖ-штык, плюс СВ? Посмотрите на картинку. СВ-штык
[01:23:28.980 --> 01:23:37.180]  больше либо равен, чем СЖ-штык, плюс СВ. Почему? Потому что, смотрите, в СВ входят альфа, бета и В.
[01:23:37.180 --> 01:23:48.940]  Согласны? В Ж-штык входят гамма, дельта и Ж-штык. А вот в В-штык входят все это, плюс еще П-штык.
[01:23:48.940 --> 01:23:57.820]  Понятно, почему больше либо равно количество элементов. То есть, если я с вами посмотрю на это
[01:23:57.820 --> 01:24:04.580]  все, тогда согласны ли вы с тем... Тогда я применю следующее утверждение. Логарифм двоичный Х плюс
[01:24:04.580 --> 01:24:11.580]  логарифм двоичный У меньше либо равен минус двух, для любых х и у положительных, и х плюс у меньше
[01:24:11.580 --> 01:24:20.540]  единички. Согласны, что х плюс у меньше единички? То есть, СЖ-штык плюс СВ делить на СВ-штык это меньше
[01:24:20.540 --> 01:24:30.460]  единицы, потому что там присутствует как минимум П-штык, В-штык. Ага. Вот тогда мы получили нужное
[01:24:30.460 --> 01:24:37.020]  нам неравенство. Потому что мы вот эти логарифмы там посчитали, все хорошо. Вот это минус два,
[01:24:37.020 --> 01:24:39.340]  но действительно будет правдой. Мы доказали это.
[01:24:48.580 --> 01:24:58.300]  Но здесь нам хватит х плюс у меньше единиц. Но в любом случае у нас будет СЖ-СВ. С чем?
[01:25:00.460 --> 01:25:14.860]  Ну да ладно, в чем проблема? В смысле, нормальная? Все хорошо. Но мы складываем потом два неравенства,
[01:25:14.860 --> 01:25:25.540]  получаем нужное нам. У нас будет ААИТ меньше чем 3 ранга В-штрих минус 3 ранга В. Это понятно? То есть,
[01:25:25.540 --> 01:25:30.260]  вот эту логическую цепочку нужно вам в голове простроить. То есть, на какие штуки смотреть.
[01:25:30.260 --> 01:25:52.460]  Но в общем-то все действительно адекватно здесь. ОК? Точно ОК? Да. Ой, это ЗИК или ЗАГ? ЗИК или ЗАГ
[01:25:52.460 --> 01:26:03.980]  на последнем этапе будет. Теперь поехали дальше. Последний анализ это зигзага. Смотрите, анализ зигзага
[01:26:03.980 --> 01:26:09.260]  аналогичен в начале. Два действия у нас будет простейших. Дальше мы складываем все также ранги
[01:26:09.260 --> 01:26:17.780]  и получаем что у нас будет два плюс ранг П-штрих плюс ранг Ж-штрих минус ранг В минус ранг П. Но я все
[01:26:17.780 --> 01:26:25.780]  так же сократил вот эти корни, потому что у них ранги одинаковые. ОК? Это принято. Теперь поехали
[01:26:25.780 --> 01:26:36.860]  с последний слайд. Смотрите, мы с вами получим что у нас АИТ будет два плюс ранг П-штрих плюс ранг Ж-штрих
[01:26:36.860 --> 01:26:42.820]  минус ранг В минус ранг П. Видимо, мне надо было буковками разными назвать. Ну не знаю, хотя бы
[01:26:42.820 --> 01:26:49.620]  соотношение какое-то. Ой, у меня там оскобочка съехала. Смотрите, мы с вами знаем что ранг П больше
[01:26:49.620 --> 01:26:57.700]  либо равен чем ранг В, но это логично. П-ранг был выше вершинки В в самом начале. Согласны? Значит,
[01:26:57.700 --> 01:27:04.340]  я могу так как там опять с минусом, я могу его оставить у меня будет АИТ меньше либо равно чем два
[01:27:04.340 --> 01:27:13.180]  плюс ранг П-штрих плюс ранг Ж-штрих минус два ранга В. ОК? А теперь смотрите, я буду утверждать,
[01:27:13.180 --> 01:27:22.100]  что в этом случае АИТ меньше либо равно чем два ранга В-штрих минус ранга В. Как мне этого добиться?
[01:27:22.100 --> 01:27:28.380]  Мне этого добиться очень просто. Я ровно такое же вот какое-то неравенство попытаюсь сделать,
[01:27:28.380 --> 01:27:36.460]  чтобы убралось вот это ранг П-штрих и ранг Ж-штрих. То есть мне достаточно будет показать, что ранг Ж-штрих
[01:27:36.460 --> 01:27:51.220]  плюс ранг П-штрих минус два ранга В-штрих меньше либо равно чем минус два. Нет, нет, нет. Здесь будет
[01:27:51.220 --> 01:27:56.540]  ровно в такой же последовательности. Вот когда мы получили это неравенство, вы получили ровно то
[01:27:56.540 --> 01:28:03.300]  же самое с логарифами. Ровно такое же утверждение используете, потому что В-штрих это сейчас корень
[01:28:03.300 --> 01:28:12.140]  моего всего дерева, а в Ж-штрих и П-штрих там уже частички их. Понятно? То есть это будет ровно то
[01:28:12.140 --> 01:28:18.700]  же самое доказать, что было в предыдущем. То есть просто расписать те же самые логарифы. Ну и все,
[01:28:18.700 --> 01:28:23.100]  вы получили эту сумму. Получили, что она меньше либо равно чем вообще два умножить на ранги.
[01:28:23.100 --> 01:28:31.740]  Дальше мы говорим следующее в действительности. В два меньше либо равно чем два, но это то же
[01:28:31.740 --> 01:28:37.660]  самое, что меньше либо равно чем в три. Но если у меня было там какое-то число, то умножу я на три,
[01:28:37.660 --> 01:28:47.780]  и оно точно меньше этого числа. Согласны? Число положительное, поэтому все логично. Это нужно для
[01:28:47.780 --> 01:28:54.180]  того, чтобы мы вычитали эти времена друг с дружки хорошо. Чтобы ранги можно было вычислить друг
[01:28:54.180 --> 01:28:59.300]  с другом. Потому что там где-то три ранга, где-то два, у нас проблемы будут. Когда у нас будет три и
[01:28:59.300 --> 01:29:09.180]  три, мы их просто вычитаем друг с другом. Так вот, последний слайд. Итог. Любой ранг,
[01:29:09.180 --> 01:29:17.700]  он просто ограничен логарифмом. В конце мы получаем с вами то самое доказательство того утверждения,
[01:29:17.700 --> 01:29:26.940]  которое было. Что у нас минус ранг V, минус ранг R, минус ранг V, плюс один. Три ранга. Согласны?
[01:29:26.940 --> 01:29:33.740]  Было такое утверждение в самом начале, которое мы и доказывали сейчас. Три ранга R, минус три ранга
[01:29:33.740 --> 01:29:45.740]  V, плюс один. Нет, плюс единичка появилась у тебя только в зиге или только в заге. Вот. Поэтому это важно.
[01:29:45.740 --> 01:29:53.220]  Так вот, мы с вами получаем этот логарифм, мы это доказали. Ну там просто просуммировать все эти
[01:29:53.220 --> 01:29:58.220]  моменты, мы это в самом начале с вами и сделать. И получается, что функция сплей работает, а
[01:29:58.640 --> 01:30:05.260]  амортизационно за логарифм. А если она работает амортизационно за логарифм, то функция Fine работает
[01:30:05.260 --> 01:30:12.860]  за логарифм, функция Insert работает за логарифм, функция Remove работает за логоифм. И все это работает
[01:30:12.860 --> 01:30:18.780]  амортизационно за логоифм. И это хорошая структура данных, потому что в среднем она будет давать вам
[01:30:18.780 --> 01:30:24.540]  результат ровно такой же, какой должен быть с балансированных деревьев. Но важный момент,
[01:30:24.540 --> 01:30:29.740]  эта структура данных лучше всего подходит в моменты, когда вы берете один и тот же
[01:30:29.740 --> 01:30:38.260]  элемент и ищете, грубо говоря, и он всегда находится где-то высоко. Понятно? Надеюсь,
[01:30:38.260 --> 01:30:43.700]  вы преисполнились этой структурой данных. Надеюсь, вам понравилось. Вы сможете ее реализовать.
[01:30:43.700 --> 01:30:51.180]  Надеюсь, что у меня там сильно много багов в коде нет, по-моему, не особо. Вот. А во всем
[01:30:51.180 --> 01:30:56.460]  остальном хорошего вам вечера. Вот. Удачи. Все. Пока-пока.
