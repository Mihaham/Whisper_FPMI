[00:00.000 --> 00:06.640]  Мы начинаем разбираться с вами с деревьями.
[00:06.640 --> 00:14.600]  Деревья. Тогда вводим следующее определение. Первое определение, которое нам понадобится,
[00:14.600 --> 00:30.920]  это что такое граф? Граф. Это просто пара из V и E. Где V? Где V это конечное множество,
[00:30.920 --> 00:39.600]  мы рассматриваем на конечный граф. Конечное множество, которое называется вершинами,
[00:39.600 --> 01:03.040]  которое называется множеством вершин. А E? Что такое E, скажите?
[01:03.760 --> 01:12.880]  Упорядочное множество ребер. Упорядочное множество ребер. Но по факту это некоторое бинарное отношение
[01:12.880 --> 01:27.920]  между вершинами,
[01:27.920 --> 01:56.280]  которое называется множество ребер. Мы будем полагать этот граф именно в таком плане,
[01:56.280 --> 02:02.960]  что у нас просто есть какие-то вершины и у нас есть какие-то ребра. Самое обычное представление
[02:02.960 --> 02:11.800]  графа, я думаю, вам понятное, просто нарисовать что-то такое и для вас будет вот это граф.
[02:11.800 --> 02:18.720]  Вот это есть множество ребер, я их напишу как маленькие элементы E, а это множество вершин.
[02:18.720 --> 02:25.560]  Но так как мы будем говорить именно о деревьях сегодня и алгоритмах графа,
[02:25.560 --> 02:33.040]  хотя действительно у вас там будет чуть позже, то мы должны понять вообще что такое дерево.
[02:33.040 --> 02:54.920]  Следующее определение. Дерево это связный ациклический.
[03:03.920 --> 03:18.760]  Смотрите, если у меня нет в графе каких-то циклов, то мы считаем, что это дерево. Вы можете
[03:18.760 --> 03:28.200]  видеть в разных источниках немножко по-разному, что это не ориентированный или ориентированный
[03:28.200 --> 03:33.040]  граф. Мы на этом не зацикливаемся, мы все же будем считать, что это будет ориентированный граф,
[03:33.040 --> 03:38.800]  но так как, например, если вы будете учить по кормону, там сказано, что это не ориентированный граф,
[03:38.800 --> 03:47.240]  то я точного вот именно этого момента не буду вам говорить. Но что касается дерева. Дерево выглядит
[03:47.800 --> 04:04.800]  вот примерно следующим образом. Это просто ациклический какой-то граф. Вот это дерево и все.
[04:04.800 --> 04:15.200]  То есть воспринимаете дерево просто как висячую такую штуку, в которой что-то есть. Однако
[04:15.200 --> 04:21.200]  деревья бывают на самом деле разные. И вот именно здесь и кроется такая вот штука,
[04:21.200 --> 04:27.960]  которая связана именно с определением. Не у всех деревьев есть корень. Я думаю,
[04:27.960 --> 04:32.120]  часть из вас понимает, что такое корень. Мы сейчас этим разберемся по факту,
[04:32.120 --> 04:39.040]  что это так называемое корневое дерево. Давайте продолжим определение.
[04:39.040 --> 04:50.400]  Корневое, корневое дерево. И определение нам сейчас просто очень много пригодится.
[04:50.400 --> 04:55.760]  Главное, чтобы мы были в одной плоскости обсуждения. Корневое дерево это дерево,
[04:55.760 --> 05:09.880]  в котором, сейчас будет самый гениальный мув с точки зрения определения, выделена одна вершина,
[05:16.600 --> 05:17.200]  вершина,
[05:21.400 --> 05:22.560]  называемая корнем.
[05:26.760 --> 05:34.400]  Это в случае неориентированных графов. В случае ориентированных графов корень,
[05:34.400 --> 05:41.280]  это не просто какая-то выделенная вершина, а корень это та вершина, у которой нет родителей.
[05:41.280 --> 05:46.480]  Но так как мы еще не дали определение родителей и детей, мы сейчас тоже это напишем и напишем,
[05:46.480 --> 05:54.680]  что для нас будет являться корень. Я обещаю, не будет сильно много определений, но они все нам
[05:54.680 --> 06:06.160]  понадобятся просто. Следующее определение. Узел дерева. Давайте сразу поясню, что на английском
[06:06.160 --> 06:13.400]  это нода. На всякий случай, чтобы если вы писали, вы не писали дек кучи разных способов,
[06:13.400 --> 06:20.120]  но все неправильные. Давайте сразу будем английские слова еще учить этому всему. Узел это вершина,
[06:20.120 --> 06:35.800]  вершина, дереве, корнем. Следующее определение, которое нам тоже понадобится. Мы сейчас все их
[06:35.800 --> 06:44.520]  разберем на примере. То есть мы сначала все это запишем и увидим. Любой узел,
[06:44.520 --> 07:14.280]  мы будем, любой узел, у на единственном пути, пути от r, это корень, у нас root, слово root,
[07:14.280 --> 07:41.040]  до x, до x в дереве t, называется, называется предка, предка,
[07:41.040 --> 07:59.000]  предка икса. Смотрите, что такое предок икса? Предок икса, это просто любой узел,
[07:59.000 --> 08:04.400]  который находился чуть выше, если смотреть там от корня. То есть представьте, у нас есть к иксу
[08:04.400 --> 08:10.960]  какой-то путь от корня, и мы по этому пути находим все вершинки, которые выше лежали нашу икса. Это
[08:10.960 --> 08:25.760]  и будет наш предок. Определение, которое нам говорит о том, что такое, это по-английски предок
[08:25.760 --> 08:55.560]  написано. Окей, определение следующее. Если y- предок x, то x потомок y,
[08:55.760 --> 09:01.360]  вот здесь главное понимать, что такое потомок. Потомок все, что лежит ниже.
[09:01.360 --> 09:18.640]  Окей, еще одно определение, сейчас мы скоро перейдем на примерчики. Определение следующее,
[09:18.640 --> 09:45.800]  по деревам с корнем, с корнем в узле x, называется дерево, дерево,
[09:45.800 --> 10:07.840]  порожденное, порожденное, порожденное потомками x.
[10:07.840 --> 10:22.040]  Вот, это то, что нам понадобится. Еще понадобится несколько определений, связанных с тем, что такое
[10:22.040 --> 10:28.360]  родитель, кто такой ребенок, степень вершины, глубина и так далее нашего там дерева и каких-нибудь
[10:28.360 --> 10:34.800]  таких вот вещей. Давайте с вами это напишем и после этого как раз перейдем ко всему остальному.
[10:34.800 --> 10:42.120]  Есть ли какие-то вопросы пока по этим определениям? Вроде все понятно? Да? Нет?
[10:42.120 --> 10:46.880]  Как будет потомок на x? Потомок?
[10:46.880 --> 10:49.200]  Отдесендует.
[10:49.200 --> 10:56.960]  Правильно, сейчас напишу. Потомок. Здесь вот я сверху напишу.
[11:05.400 --> 11:13.320]  Просто правильно их пишите хотя бы у себя в структурках данных, потому что иначе это будет грустно.
[11:13.320 --> 11:19.640]  Просто сам. Сын.
[11:19.640 --> 11:26.800]  Сын это другое, сейчас я объясню в чем разница. Предок и сын, потомок и сын, это разные вещи.
[11:26.800 --> 11:28.760]  Это может быть дочь.
[11:28.760 --> 11:33.240]  Это может быть внук скорее.
[11:33.440 --> 11:48.200]  Так, ребят, окей. Смотрите, давайте с вами определим что такое вообще родитель и что такое сын.
[11:48.200 --> 11:52.240]  Можете на секунду на предыдущий слайд перелеснуть? Да, конечно.
[11:52.240 --> 11:55.240]  Вот последнее.
[11:55.240 --> 12:03.160]  Под деревом с корнем возле x называется дерево, порожденное потомками x.
[12:03.160 --> 12:18.280]  Давайте тогда перейдем дальше.
[12:18.280 --> 12:48.200]  Окей, смотрите, если и при x, это последнее, ребро, ребро на пути, на пути из R корня.
[12:48.200 --> 13:18.120]  Дерево в узел x, а то y, родитель, я надеюсь родитель вы знаете как по-английски это по-армянски, по отношению.
[13:18.120 --> 13:43.040]  По отношению к x, а x это у нас ребенок, по отношению к y.
[13:43.040 --> 13:56.960]  Вот, то есть смотрите, ну или дочерний узел здесь, когда как можно говорить, но в том суть, что мы будем называть родителем и ребенком только те вершины, которые рядом.
[13:56.960 --> 14:06.960]  То есть нельзя говорить, что там, ну мы сейчас на примере поймем, в чем разница потомка и ребенка.
[14:07.880 --> 14:14.880]  То есть ребенок является потомком, но потомок не является ребенком. Вот в чем все будет принципиально у нас разница.
[14:14.880 --> 14:23.880]  Окей, и давайте все последнее определение, я понимаю, что их много, их все нужно запомнить, но я думаю они интуитивно все понятны на самом деле.
[14:23.880 --> 14:50.800]  Вот, первое, количество дочерних узлов, количество дочерних узлов, дочерних узлов, узлов узла x, называется степенью.
[14:53.880 --> 15:20.800]  Следующее определение, следующее определение длина простого пути.
[15:24.800 --> 15:51.800]  А из корня r в узел x называется, называется глубиной узла x.
[15:52.720 --> 16:14.720]  Если вдруг я где-то не очень, вы не понимаете, что я написал, говорите, вот, я вроде бы все все проговариваю.
[16:14.720 --> 16:43.640]  Вот, и последнее определение, которое нам еще понадобится, высота, высота дерева, высота в дереве равна количеству, количество ребер.
[16:45.640 --> 17:07.640]  Ребер в самом, самом длинном, простом, простой путь, бывает непростой.
[17:08.560 --> 17:20.560]  Смотрите, если мы рассматриваем, грубо говоря, неориентированный граф, непростой путь, вот если вы по одному ребру вверх не ссури, мы ходим, вот добавили это, оно не сильно влияет на что-то, но путь увеличился.
[17:22.560 --> 17:33.560]  Мы говорим, что степень, это количество сыновей или это вообще степень вершины, сколько ребер из нее выходит?
[17:34.480 --> 17:41.480]  Степенью узла, степенью узла называется количество его дочерних узлов.
[17:42.480 --> 17:45.480]  Ну, дочерних, то есть, исходящих из него.
[17:46.480 --> 17:48.480]  Ну, то есть, это не степень вершины.
[17:49.480 --> 17:51.480]  Это не степень вершины, все верно.
[17:52.480 --> 17:54.480]  Степень узла это немного другое.
[17:55.400 --> 18:04.400]  Вот, а так, в самом длинном, простом пути, я еще не дописал, ай-ай, сейчас, сейчас нет одной штуки.
[18:08.400 --> 18:22.400]  В самом длинном, простом пути находящимся, нисходящим, да, все правильно, нисходящим, ну, то есть, проложенным.
[18:25.400 --> 18:27.400]  Нисходящим от узла к листу.
[18:28.400 --> 18:33.400]  Вот, узла, узла к листу.
[18:37.400 --> 18:42.400]  Вот, это почти что последнее определение, которое нам нужно будет, вообще, в принципе, сегодня.
[18:43.400 --> 18:47.400]  То есть, смотрите, мы должны познакомиться как раз-таки с самими деревьями, вообще, как они выглядят, что это происходит.
[18:48.400 --> 18:50.400]  Давайте с вами нарисуем просто денег.
[18:51.320 --> 18:53.320]  Что такое?
[18:54.320 --> 19:04.320]  Хорошо, я сейчас не услышал вопрос, но относительно листа, лист, что еще раз?
[19:05.320 --> 19:08.320]  Вы написали от корня к листу.
[19:09.320 --> 19:13.320]  Ой, от корня к листу, от корня к листу, сори, давайте исправлю.
[19:16.320 --> 19:18.320]  От корня.
[19:21.320 --> 19:23.320]  Вот.
[19:24.320 --> 19:26.320]  Прошу прощения.
[19:27.320 --> 19:30.320]  Давайте с вами нарисуем просто обычное дерево.
[19:31.320 --> 19:38.320]  Сейчас мы разберемся, что такое лист и так далее, просто иначе, если мы введем абсолютно все понятия, все будет очень громоздко в этом плане.
[19:39.320 --> 19:41.320]  Лучше просто такие вот основные вещи понимать.
[19:42.320 --> 19:44.320]  Представьте следующее, вот у меня граф.
[19:45.240 --> 19:51.240]  Для меня я буду рисовать ориентированные деревья, ориентированные, почему?
[19:52.240 --> 19:54.240]  Потому что так понятно, что является корнем.
[19:55.240 --> 19:57.240]  Вот и все.
[19:58.240 --> 20:02.240]  Предположим следующее, вот у меня есть вот такое вот дерево.
[20:03.240 --> 20:07.240]  Пусть будет так, здесь будет вот так, здесь будет вот так,
[20:10.240 --> 20:12.240]  здесь просто так,
[20:13.160 --> 20:15.160]  вот так,
[20:16.160 --> 20:18.160]  вот так,
[20:19.160 --> 20:25.160]  вот по нему мы сейчас все как раз-таки поймем, что здесь происходит.
[20:26.160 --> 20:34.160]  Вот, ну давайте обычно, ну деревья просто так, нам не интересны, просто какие-то рандомные вершинки и так далее.
[20:35.160 --> 20:38.160]  Обычно в узлах хранится так называемый ключ.
[20:39.080 --> 20:46.080]  Это означает, что там хранится какое-то значение, которое нам будет необходимо, и мы строим как-то дерево по нему.
[20:47.080 --> 20:50.080]  Вот, мы сегодня построим два таких дерева, видим, что это будет.
[20:51.080 --> 20:59.080]  Вот, ну предположим тут как-то рандомно, мы расставим числа 3, 10, не знаю, там 4, пусть будет тоже 10,
[21:00.000 --> 21:11.000]  2, 8, там 12, не знаю, 1, 2, придут 6 и 9.
[21:12.000 --> 21:17.000]  Вот, смотрите, что называется здесь корнем.
[21:18.000 --> 21:23.000]  Корнем мы по факту будем называть вершину, у которой нет родителей.
[21:24.000 --> 21:26.000]  У нее нет родителей.
[21:27.000 --> 21:29.000]  Вот это корень.
[21:30.000 --> 21:36.000]  Листы – это те вершины, у которых нет детей.
[21:37.000 --> 21:45.000]  Вот то, что я сейчас выделяю, давайте оранженки будем выделять, просто вот это, вот это, вот это,
[21:46.000 --> 21:48.000]  это, это и вот это.
[21:49.000 --> 21:51.000]  Это все листы.
[21:52.000 --> 21:54.000]  А на записание такое определение?
[21:56.000 --> 21:58.000]  Главное, чтобы вы понимали это.
[21:58.920 --> 22:00.920]  Что такое листы корень для вас?
[22:01.920 --> 22:02.920]  Вот.
[22:03.920 --> 22:06.920]  Листы – это те узлы, у которых нет детей.
[22:07.920 --> 22:15.920]  Вот, смотрите, для вершины с номером, давайте пусть будет не 9, 10, 10, а тут примерно будет там, не знаю, 11,
[22:16.920 --> 22:18.920]  чтобы могли их различать просто легко.
[22:19.920 --> 22:20.920]  11.
[22:21.840 --> 22:22.840]  Вот.
[22:23.840 --> 22:29.840]  Смотрите, для вершины, например, с номером, ну, в которой лежит вот наш ключ 2.
[22:31.840 --> 22:34.840]  8 для 2, давайте я прям так и запишу.
[22:35.840 --> 22:36.840]  Для 2.
[22:37.840 --> 22:38.840]  У нас две двойки.
[22:39.840 --> 22:41.840]  Хорошо, тогда для 9.
[22:42.840 --> 22:43.840]  Да.
[22:44.760 --> 22:45.760]  Для 9.
[22:46.760 --> 22:54.760]  8 является, является потомком, ой, предком, предком,
[22:57.760 --> 23:00.760]  но не родителем.
[23:05.760 --> 23:06.760]  Вот.
[23:07.680 --> 23:08.680]  А вот 2.
[23:09.680 --> 23:10.680]  А 2.
[23:11.680 --> 23:12.680]  А 2.
[23:13.680 --> 23:17.680]  Это у нас уже и родитель.
[23:22.680 --> 23:23.680]  И родитель.
[23:25.680 --> 23:27.680]  И предка.
[23:28.600 --> 23:36.600]  Аналогично можно сказать, что для 7 девятка является предка, ой, потомком,
[23:37.600 --> 23:44.600]  девятка является потомком для 7, но не является ее ребенком.
[23:45.600 --> 23:52.600]  Для семерки, для семерки скажите мне, что является ребенком?
[23:53.600 --> 23:56.600]  Какие вершины есть дети данной штуки?
[23:57.520 --> 23:58.520]  3-11-4.
[23:59.520 --> 24:03.520]  3-11-4, да, только у вас прям эхо из-за того, что вы рядышком, ну так ладно.
[24:04.520 --> 24:10.520]  3-11-4, да, то есть смотрите, только то, что находится рядышком и то, что ниже.
[24:11.520 --> 24:13.520]  Вот это будут, будут дети.
[24:14.520 --> 24:16.520]  Именно это необходимо различать.
[24:17.520 --> 24:23.520]  Помимо этого, смотрите, высота дерева, высота дерева, вот моего, вот оно.
[24:24.440 --> 24:26.440]  Высота моего дерева здесь.
[24:27.440 --> 24:28.440]  Высота.
[24:30.440 --> 24:31.440]  У меня 4.
[24:32.440 --> 24:33.440]  Почему?
[24:34.440 --> 24:40.440]  Потому что самый длинный путь, раз, два, три, ну давайте вот так, раз, два, три, четыре.
[24:41.440 --> 24:47.440]  Количество ребер у меня такое, если дерево состоит лишь из одного корня, его высота ноль.
[24:48.440 --> 24:49.440]  Ребер нет.
[24:50.360 --> 24:53.360]  А теперь, что касается именно глубины.
[24:54.360 --> 24:57.360]  Глубина, давайте возьму здесь, к примеру, бордовый такой.
[24:58.360 --> 25:02.360]  Глубина, вот на этом уровне, где у меня есть семерка, это ноль.
[25:04.360 --> 25:06.360]  От корня до корня ребер лежит тоже ноль.
[25:07.360 --> 25:13.360]  Вот на этом уровне, где у меня стоит 3-4-11, глубина один.
[25:14.360 --> 25:15.360]  Глубина.
[25:16.280 --> 25:17.280]  Глубина.
[25:24.280 --> 25:25.280]  Глубина.
[25:27.280 --> 25:28.280]  На вот этом уровне.
[25:31.280 --> 25:32.280]  У меня это два.
[25:33.280 --> 25:34.280]  На вот этом уровне.
[25:35.280 --> 25:37.280]  У меня глубина три.
[25:38.280 --> 25:41.280]  Здесь четыре.
[25:43.280 --> 25:45.280]  Вот в чем вся корня.
[25:46.280 --> 25:51.280]  Смотрите, по факту самая большая глубина есть высота, которая есть в дереве.
[25:52.280 --> 25:53.280]  Это логично.
[25:54.280 --> 25:59.280]  Вот, поэтому деревья очень часто изображаются именно в таком вот виде,
[26:00.280 --> 26:03.280]  чтобы вершины на одной глубине находились на одном уровне.
[26:04.280 --> 26:07.280]  Это удобно с точки зрения прокладывания путей и так далее.
[26:08.280 --> 26:10.280]  Есть ли вопросы к этому сейчас?
[26:11.280 --> 26:14.280]  Наверное, вопрос по пониманию определения.
[26:15.200 --> 26:18.200]  Допустим, если у нас есть еще одна вершина,
[26:19.200 --> 26:21.200]  которая у нее нет родителей,
[26:22.200 --> 26:25.200]  то тогда у нас дерево только не было.
[26:26.200 --> 26:27.200]  А где такую вершину взять?
[26:28.200 --> 26:30.200]  Просто взять, добавить и, например, к четверке привести,
[26:31.200 --> 26:32.200]  то тогда такое дерево перестанет быть корневым.
[26:33.200 --> 26:34.200]  Сейчас.
[26:35.200 --> 26:36.200]  Что делать?
[26:37.200 --> 26:38.200]  Убрать вот здесь?
[26:39.200 --> 26:40.200]  Нет, добавить на нулевом уровне вершину,
[26:41.200 --> 26:43.200]  например, 12, и привести к 4 стрелочку,
[26:44.120 --> 26:46.120]  то тогда такое дерево перестанет быть корневым.
[26:47.120 --> 26:48.120]  Вот так, да?
[26:49.120 --> 26:50.120]  Да.
[26:51.120 --> 26:52.120]  Да, такое дерево перестанет быть корневым, да.
[26:53.120 --> 26:54.120]  Спасибо.
[26:57.120 --> 26:58.120]  Корень мы считаем один.
[26:59.120 --> 27:00.120]  Угу.
[27:01.120 --> 27:02.120]  Так.
[27:03.120 --> 27:04.120]  Еще вопросы?
[27:06.120 --> 27:09.120]  Только один сын может быть, ой, только два сына может быть, да.
[27:10.120 --> 27:12.120]  У меня здесь три есть у семерки.
[27:13.040 --> 27:14.040]  А, да, логично.
[27:15.040 --> 27:19.040]  Количество сыновей никак не зависит от дерева.
[27:20.040 --> 27:22.040]  То есть, если это случайное дерево какое-то,
[27:23.040 --> 27:24.040]  просто именно дерево,
[27:25.040 --> 27:26.040]  то у него может быть хоть сколько сыновей?
[27:27.040 --> 27:30.040]  Может быть ноль, может быть эн, может быть два эн, и так далее.
[27:31.040 --> 27:32.040]  Вот.
[27:33.040 --> 27:34.040]  Родитель только один, правильно?
[27:35.040 --> 27:36.040]  Родитель один, да.
[27:37.040 --> 27:38.040]  Мы считаем, что да.
[27:38.960 --> 27:39.960]  Вот только что этот вопрос задали,
[27:40.960 --> 27:41.960]  и вы сказали, что будет два корня.
[27:42.960 --> 27:46.960]  Прикол в том, что мы от новой вершины направляли к четверку.
[27:47.960 --> 27:48.960]  Да, да, от новой вершины.
[27:49.960 --> 27:50.960]  А, понятно.
[27:51.960 --> 27:52.960]  Вот, ну, родитель, мы будем считать...
[27:53.960 --> 27:55.960]  Если еще одно, то это не является корня.
[27:56.960 --> 27:57.960]  То есть, от четверки.
[27:58.960 --> 27:59.960]  Что еще раз?
[28:00.960 --> 28:05.960]  Если мы не от новой к четверку, а от четвертой в новую проведем,
[28:06.960 --> 28:07.960]  это ведь все окей?
[28:08.960 --> 28:10.960]  От четверки мы возьмем и здесь делаем вот так?
[28:13.960 --> 28:14.960]  Да, да, да, я просто подумал, может быть...
[28:15.960 --> 28:17.960]  Если так, то у него появится новый сын.
[28:18.960 --> 28:19.960]  Да, понял.
[28:20.960 --> 28:22.960]  Ну, типа, у него будет уже три сына, нет, один.
[28:23.960 --> 28:24.960]  Ой, не два.
[28:25.960 --> 28:26.960]  Еще вопросы?
[28:28.960 --> 28:31.960]  Получается, степень каждого зла — это степень вершины минус один.
[28:34.960 --> 28:37.960]  Потому что у нас как бы входящее ребро на ней не учитывается.
[28:38.960 --> 28:42.960]  Смотрите, а степень вообще в ориентированном графе —
[28:43.960 --> 28:44.960]  это не просто количество ребр.
[28:45.960 --> 28:46.960]  Ну, вот если брать там дискоетовую математику,
[28:47.960 --> 28:49.960]  степень в ориентированном графе там может считаться по-разному.
[28:50.960 --> 28:53.960]  Чаще всего их разделяет уходящая степень и не выходящая степень.
[28:54.960 --> 28:59.960]  По факту, по факту, здесь выходящая степень является степенью зла.
[29:01.960 --> 29:02.960]  Понятно?
[29:03.960 --> 29:04.960]  Окей, понятно.
[29:05.880 --> 29:08.880]  Если бы это был неориентированный граф, то да.
[29:11.880 --> 29:12.880]  Еще вопросы?
[29:18.880 --> 29:19.880]  Отсутствует.
[29:20.880 --> 29:21.880]  Отлично.
[29:22.880 --> 29:25.880]  Тогда давайте с вами разберемся, а жду такое бинарное дерево.
[29:25.880 --> 29:26.880]  Бинарное дерево.
[29:31.880 --> 29:35.880]  Последнее определение относительно самого дерева.
[29:36.880 --> 29:38.880]  Бинарное дерево мы зададим вообще рекурсивно.
[29:39.880 --> 29:40.880]  Что такое бинарное дерево?
[29:41.880 --> 29:42.880]  Бинарное дерево.
[29:43.880 --> 29:44.880]  Ой, давайте синьки буду писать.
[29:45.880 --> 29:46.880]  Какую бы я этого делала.
[29:50.880 --> 29:54.880]  Бинарное дерево.
[29:56.880 --> 30:02.880]  По-английски binary tree.
[30:03.880 --> 30:04.880]  Вот.
[30:05.880 --> 30:09.880]  Бинарное дерево t представляет собой.
[30:14.880 --> 30:16.880]  Представляет
[30:16.880 --> 30:17.880]  собой
[30:28.880 --> 30:29.880]  конечное
[30:32.880 --> 30:33.880]  множество
[30:39.880 --> 30:40.880]  множество
[30:43.880 --> 30:44.880]  узлов,
[30:45.880 --> 30:46.880]  которые
[30:51.880 --> 30:52.880]  здесь возможно один из двух вариантов.
[30:53.880 --> 30:54.880]  Первый вариант.
[30:55.880 --> 30:56.880]  Либо не содержит узлов,
[31:10.880 --> 31:11.880]  либо не содержит узлов,
[31:12.880 --> 31:13.880]  либо
[31:15.880 --> 31:16.880]  состоит
[31:18.880 --> 31:19.880]  состоит
[31:22.880 --> 31:23.880]  из трех
[31:25.880 --> 31:26.880]  не пересекающихся
[31:27.880 --> 31:28.880]  не пересекающихся
[31:30.880 --> 31:32.880]  не пересекающихся множество.
[31:37.880 --> 31:38.880]  Первое это корневой узел.
[31:41.880 --> 31:42.880]  Корневой
[31:44.880 --> 31:45.880]  узел.
[31:48.880 --> 31:49.880]  Второе.
[31:50.880 --> 31:51.880]  Бинарное
[31:54.880 --> 31:55.880]  дерево
[31:59.880 --> 32:00.880]  называющееся
[32:04.880 --> 32:05.880]  левым
[32:08.880 --> 32:09.880]  под деревом.
[32:11.880 --> 32:12.880]  Вот.
[32:14.880 --> 32:16.880]  И последнее это бинарное дерево
[32:24.880 --> 32:26.880]  называющееся
[32:28.880 --> 32:29.880]  правым
[32:32.880 --> 32:33.880]  под деревом.
[32:37.880 --> 32:38.880]  Вот.
[32:38.880 --> 32:39.880]  Важный вопрос.
[32:39.880 --> 32:41.880]  Как может быть конечное множество узлов,
[32:42.880 --> 32:44.880]  которые не содержат узлов?
[32:47.880 --> 32:48.880]  Еще раз.
[32:48.880 --> 32:49.880]  Бинарное дерево
[32:50.880 --> 32:51.880]  это
[32:51.880 --> 32:52.880]  конечное множество узлов,
[32:53.880 --> 32:54.880]  которое
[32:55.880 --> 32:56.880]  первое либо не содержит узлов,
[32:57.880 --> 32:59.880]  либо состоит из трех не пересекающихся множества.
[33:01.880 --> 33:03.880]  Ну типа пустое множество, это конечное множество узлов,
[33:04.880 --> 33:05.880]  а
[33:05.880 --> 33:10.880]  Ну, типа пустое множество – это конечное множество, Миша.
[33:10.880 --> 33:13.880]  А, вы про это. Хорошо.
[33:13.880 --> 33:14.880]  Ну да.
[33:14.880 --> 33:18.880]  Я думаю, просто это два одинаковых эквивалентных определения просто.
[33:18.880 --> 33:19.880]  Нет.
[33:22.880 --> 33:25.880]  Что под этим всем подразумевается?
[33:25.880 --> 33:28.880]  Оно задается так, смотрите.
[33:28.880 --> 33:34.880]  Бинарное дерево – это по факту вы можете воспринимать чаще всего следующим образом,
[33:34.880 --> 33:42.880]  что просто у каждого из узлов есть не более чем два ребенка.
[33:47.880 --> 33:52.880]  Вот это будет для нас бинарное какое-то дерево.
[33:52.880 --> 33:55.880]  А так нельзя было определить просто?
[33:55.880 --> 33:58.880]  Есть проблема, которую я хотел бы, чтобы вы поняли.
[33:58.880 --> 34:01.880]  А в чем проблема? Почему нельзя определить просто так?
[34:02.880 --> 34:05.880]  Не более двух детей.
[34:05.880 --> 34:09.880]  Ну, видимо, с неориентированными какие-то проблемы будут.
[34:09.880 --> 34:11.880]  Может быть.
[34:11.880 --> 34:14.880]  Могут циклы образоваться, которых нельзя.
[34:14.880 --> 34:18.880]  Циклы могут образоваться, действительно.
[34:18.880 --> 34:24.880]  То есть здесь много всего, чего может образоваться, если мы будем задавать просто как панаитию.
[34:24.880 --> 34:26.880]  Здесь лучше всего рекурсивно так задать.
[34:26.880 --> 34:28.880]  Давайте, смотрите.
[34:28.880 --> 34:30.880]  Это у меня бинарное дерево.
[34:30.880 --> 34:36.880]  Оно состоит из корня и двух под деревьев, которые являются тоже бинарными деревьями.
[34:36.880 --> 34:37.880]  Почему?
[34:37.880 --> 34:42.880]  Потому что у меня здесь есть, вот здесь в левом под деревья есть корень.
[34:42.880 --> 34:45.880]  И у него есть то ли левое, то ли правое под дерево.
[34:45.880 --> 34:47.880]  А непонятно какое это под дерево.
[34:47.880 --> 34:52.880]  Здесь важно еще понимать – это левый сын или правый сын?
[34:52.880 --> 34:55.880]  В бинарных деревьях это важно.
[34:55.880 --> 35:00.880]  И вот когда я рисую таким вот образом, я не могу сказать, что это бинарное дерево.
[35:00.880 --> 35:03.880]  Для меня еще и важен порядок.
[35:03.880 --> 35:06.880]  Слева находится или справа.
[35:06.880 --> 35:11.880]  Всегда помните об этом, что для того, чтобы у нас что-то здесь работало,
[35:11.880 --> 35:15.880]  нам необходимо задумываться о том, что это левый сын или правый сын.
[35:15.880 --> 35:18.880]  Потому что сама себе структура данных так устроена.
[35:18.880 --> 35:20.880]  Понятно?
[35:20.880 --> 35:23.880]  То есть, смотрите, здесь есть проблема.
[35:24.880 --> 35:26.880]  Что непонятно – левый или правый.
[35:26.880 --> 35:30.880]  Мы должны четко определять, какое это из сценарий.
[35:34.880 --> 35:36.880]  Есть ли вопросы к этому?
[35:41.880 --> 35:43.880]  Сами бинарные деревья.
[35:43.880 --> 35:45.880]  Понятно.
[35:45.880 --> 35:47.880]  Окей.
[35:47.880 --> 35:53.880]  Тогда давайте сейчас кое-что еще запишем, потом у нас будет небольшой перерыв.
[35:58.880 --> 36:00.880]  Делайте такой большой подзаголовок.
[36:00.880 --> 36:02.880]  Это большая тема.
[36:03.880 --> 36:05.880]  Бинарное.
[36:08.880 --> 36:10.880]  Дерево.
[36:11.880 --> 36:13.880]  Поиска.
[36:15.880 --> 36:17.880]  Что такое бинарное дерево?
[36:17.880 --> 36:19.880]  Поиск.
[36:25.880 --> 36:27.880]  Что такое бинарное дерево?
[36:27.880 --> 36:29.880]  Поиск.
[36:29.880 --> 36:31.880]  У него следующее определение есть.
[36:38.880 --> 36:40.880]  Бинарное дерево.
[36:42.880 --> 36:44.880]  Поиска.
[36:45.880 --> 36:48.880]  Не поверите, но это бинарное дерево.
[36:53.880 --> 36:55.880]  Дерево.
[36:56.880 --> 36:58.880]  Удовлетворяющее.
[37:07.880 --> 37:09.880]  Следующему.
[37:09.880 --> 37:11.880]  Своиство.
[37:15.880 --> 37:17.880]  Если
[37:17.880 --> 37:19.880]  Х
[37:19.880 --> 37:21.880]  Узел
[37:25.880 --> 37:27.880]  Бинарного дерева.
[37:27.880 --> 37:29.880]  Поиска.
[37:29.880 --> 37:31.880]  Бинарного дерева. Поиска.
[37:39.880 --> 37:41.880]  Поиска.
[37:42.880 --> 37:44.880]  С ключом К.
[37:46.880 --> 37:48.880]  Хотя давайте с ключом.
[37:48.880 --> 37:50.880]  С ключом К.
[37:58.880 --> 38:00.880]  Еще раз, что такое ключ?
[38:00.880 --> 38:02.880]  Ключ – это значение, которое содержит в себе узел.
[38:02.880 --> 38:04.880]  Значение,
[38:08.880 --> 38:10.880]  которое содержит
[38:12.880 --> 38:14.880]  в себе узел.
[38:14.880 --> 38:16.880]  То,
[38:18.880 --> 38:20.880]  все
[38:24.880 --> 38:26.880]  узлы
[38:28.880 --> 38:30.880]  влево
[38:34.880 --> 38:36.880]  под деревья
[38:38.880 --> 38:40.880]  должны иметь ключи.
[38:44.880 --> 38:46.880]  Должны
[38:50.880 --> 38:52.880]  иметь ключи
[38:56.880 --> 38:58.880]  меньше К.
[39:06.880 --> 39:08.880]  А вправо
[39:14.880 --> 39:16.880]  если мы говорим о том, что
[39:16.880 --> 39:18.880]  эти ключи будут
[39:18.880 --> 39:20.880]  как-то
[39:20.880 --> 39:22.880]  уникальны, то есть они не будут повторяться,
[39:22.880 --> 39:24.880]  то вправо мы будем говорить о том, что
[39:24.880 --> 39:26.880]  больше К.
[39:28.880 --> 39:30.880]  Но, естественно, есть такая возможность,
[39:30.880 --> 39:32.880]  что будет что-то повторяться.
[39:32.880 --> 39:34.880]  Пять и пять, к примеру.
[39:34.880 --> 39:36.880]  То в этом случае вы должны решить,
[39:36.880 --> 39:38.880]  это будет влево или вправо под деревью.
[39:38.880 --> 39:40.880]  Здесь уже, как вы хотите,
[39:40.880 --> 39:42.880]  больше К.
[39:42.880 --> 39:44.880]  Вот.
[39:46.880 --> 39:48.880]  Это важное
[39:48.880 --> 39:50.880]  свойство бинарных
[39:50.880 --> 39:52.880]  деревьев поиска,
[39:52.880 --> 39:54.880]  которое нам
[39:54.880 --> 39:56.880]  и понадобится, которое мы будем
[39:56.880 --> 39:58.880]  больше всего использовать.
[39:58.880 --> 40:00.880]  И перед перерывом
[40:00.880 --> 40:02.880]  давайте сделаем следующее.
[40:02.880 --> 40:04.880]  Как будет выглядеть вообще структура
[40:04.880 --> 40:06.880]  узла
[40:06.880 --> 40:08.880]  у этого
[40:08.880 --> 40:10.880]  дерева поиска?
[40:12.880 --> 40:14.880]  Давайте черную напишу.
[40:14.880 --> 40:16.880]  Структура, которую мы будем с вами
[40:16.880 --> 40:18.880]  использовать, структура,
[40:18.880 --> 40:20.880]  ноды
[40:20.880 --> 40:22.880]  будет очень похожа
[40:22.880 --> 40:24.880]  на
[40:24.880 --> 40:26.880]  разный список.
[40:26.880 --> 40:28.880]  Единственное, что
[40:28.880 --> 40:30.880]  у этой ноды
[40:30.880 --> 40:32.880]  я пишу больше псевдокода,
[40:32.880 --> 40:34.880]  поэтому здесь будет без кобыч,
[40:34.880 --> 40:36.880]  у меня будет какое-то значение
[40:36.880 --> 40:38.880]  ключа.
[40:38.880 --> 40:40.880]  Это не обязательно int, поэтому я пишу здесь
[40:40.880 --> 40:42.880]  любой рандомный тип.
[40:42.880 --> 40:44.880]  Мелу или Чару вам нужно, или Флот,
[40:44.880 --> 40:46.880]  или Бул, и так далее.
[40:46.880 --> 40:48.880]  Вот. Он должен указывать
[40:48.880 --> 40:50.880]  на левую,
[40:50.880 --> 40:52.880]  на левого сына.
[40:52.880 --> 40:54.880]  Он должен указывать
[40:54.880 --> 40:56.880]  на правого сына,
[40:58.880 --> 41:00.880]  на правого ребенка.
[41:00.880 --> 41:02.880]  И
[41:02.880 --> 41:04.880]  он по-хорошему...
[41:04.880 --> 41:06.880]  Левого.
[41:08.880 --> 41:10.880]  Так.
[41:10.880 --> 41:12.880]  Для некоторых операций
[41:12.880 --> 41:14.880]  необходимо...
[41:14.880 --> 41:16.880]  Что еще раз?
[41:16.880 --> 41:18.880]  Еще раз я пишу псевдокод.
[41:18.880 --> 41:20.880]  Ребята.
[41:22.880 --> 41:24.880]  Вы будете писать звездочки.
[41:24.880 --> 41:26.880]  Я здесь поясню указатель.
[41:30.880 --> 41:32.880]  Да.
[41:32.880 --> 41:34.880]  Сына.
[41:34.880 --> 41:36.880]  Сына.
[41:38.880 --> 41:40.880]  Если кому-то не нравится, что это
[41:40.880 --> 41:42.880]  сына, на дочь. Хорошо.
[41:42.880 --> 41:44.880]  Ну или на ребенка.
[41:44.880 --> 41:46.880]  Как вам больше
[41:46.880 --> 41:48.880]  хочется. Вот.
[41:48.880 --> 41:50.880]  Right.
[41:50.880 --> 41:52.880]  Указатель на правого — это указатель
[41:52.880 --> 41:54.880]  на родителя.
[41:58.880 --> 42:00.880]  Указатель
[42:00.880 --> 42:02.880]  на родителя.
[42:06.880 --> 42:08.880]  Вот.
[42:08.880 --> 42:10.880]  Это то, что касается вообще
[42:10.880 --> 42:12.880]  того, как выглядит
[42:12.880 --> 42:14.880]  узел у нас
[42:14.880 --> 42:16.880]  в бинарном дереве поиска.
[42:16.880 --> 42:18.880]  Ну и давайте я сейчас
[42:18.880 --> 42:20.880]  нарисую одно дерево поиска.
[42:20.880 --> 42:22.880]  И вы уйдете на перерыв,
[42:22.880 --> 42:24.880]  думая о том, что является
[42:24.880 --> 42:26.880]  это деревом поиска или нет.
[42:26.880 --> 42:28.880]  Бинарным деревом поиска.
[42:30.880 --> 42:32.880]  Так.
[42:34.880 --> 42:36.880]  Пусть будет так.
[42:36.880 --> 42:38.880]  Пусть будет здесь там
[42:38.880 --> 42:40.880]  один.
[42:42.880 --> 42:44.880]  Шесть.
[42:44.880 --> 42:46.880]  Четыре.
[42:48.880 --> 42:50.880]  Семь.
[42:52.880 --> 42:54.880]  Десять.
[42:56.880 --> 42:58.880]  Четырнадцать.
[42:58.880 --> 43:00.880]  Двенадцать.
[43:00.880 --> 43:02.880]  Пусть будет тут тринадцать.
[43:02.880 --> 43:04.880]  Это влево сейчас.
[43:04.880 --> 43:06.880]  Влево.
[43:10.880 --> 43:12.880]  Тринадцать.
[43:12.880 --> 43:14.880]  Вот.
[43:18.880 --> 43:20.880]  Все. Давайте у нас перерыв.
[43:20.880 --> 43:22.880]  Тогда в шестнадцать тридцать пять
[43:22.880 --> 43:24.880]  мы продолжаем.
[43:24.880 --> 43:26.880]  Что такое бинарное дерево поиска?
[43:26.880 --> 43:28.880]  Я с вами вспомню.
[43:28.880 --> 43:30.880]  Еще раз.
[43:30.880 --> 43:32.880]  Бинарное дерево поиска.
[43:34.880 --> 43:36.880]  Бинарное дерево поиска
[43:36.880 --> 43:38.880]  удовлетворяет следующему свойству.
[43:38.880 --> 43:40.880]  Если х – узел
[43:40.880 --> 43:42.880]  бинарного дерева поиска
[43:42.880 --> 43:44.880]  с ключом k,
[43:44.880 --> 43:46.880]  то все узлы в левом под дереве
[43:46.880 --> 43:48.880]  меньше,
[43:48.880 --> 43:50.880]  имеют ключи меньше,
[43:50.880 --> 43:52.880]  чем в нашем
[43:52.880 --> 43:54.880]  дереве поиска.
[43:54.880 --> 43:56.880]  В правом больше.
[43:56.880 --> 43:58.880]  То есть, смотрите.
[43:58.880 --> 44:00.880]  Я должен смотреть на каждый из
[44:00.880 --> 44:02.880]  корней,
[44:02.880 --> 44:04.880]  так сказать, под деревья.
[44:04.880 --> 44:06.880]  Первый корень. Все
[44:06.880 --> 44:08.880]  в левом под дереве,
[44:08.880 --> 44:10.880]  то есть все в левом под дереве,
[44:10.880 --> 44:12.880]  это вот в этом дереве,
[44:12.880 --> 44:14.880]  должны быть меньше.
[44:14.880 --> 44:16.880]  Удовлетворяет
[44:16.880 --> 44:18.880]  все здесь
[44:18.880 --> 44:20.880]  элементы меньше, чем восемь.
[44:20.880 --> 44:22.880]  В правом по дереве
[44:22.880 --> 44:24.880]  у меня все элементы
[44:24.880 --> 44:26.880]  больше, чем восемь.
[44:26.880 --> 44:28.880]  Отлично. Для корни это работает.
[44:28.880 --> 44:30.880]  Необходимо проверить для всех остальных.
[44:30.880 --> 44:32.880]  Для десяти,
[44:32.880 --> 44:34.880]  к примеру, у него правое
[44:34.880 --> 44:36.880]  под дерево – это 14,13.
[44:36.880 --> 44:38.880]  Правое под дерево, значит,
[44:38.880 --> 44:40.880]  в правом под дереве должно быть все больше.
[44:40.880 --> 44:42.880]  14,13 больше 10. Все правильно.
[44:42.880 --> 44:44.880]  А 13 является левым
[44:44.880 --> 44:46.880]  под деревом, а 14.
[44:46.880 --> 44:48.880]  Если это левое под дерево,
[44:48.880 --> 44:50.880]  то там у нас как раз элемент
[44:50.880 --> 44:52.880]  меньше 13, меньше 14.
[44:52.880 --> 44:54.880]  Теперь смотрим на левое под дерево.
[44:54.880 --> 44:56.880]  Можно вопрос.
[44:56.880 --> 44:58.880]  Как для одного дерева,
[44:58.880 --> 45:00.880]  как для одной
[45:00.880 --> 45:02.880]  ветки потомков
[45:02.880 --> 45:04.880]  определяется левое или правое?
[45:04.880 --> 45:06.880]  Вот 13. Почему это левое, а не правое?
[45:06.880 --> 45:08.880]  Потому что стрелочка левее направлена.
[45:08.880 --> 45:10.880]  Я так изобразил, что оно слева.
[45:10.880 --> 45:12.880]  В своей структуре
[45:12.880 --> 45:14.880]  вы будете
[45:14.880 --> 45:16.880]  указывать, что у вас есть
[45:16.880 --> 45:18.880]  левый сын и правый сын.
[45:18.880 --> 45:20.880]  Если 13 является левым
[45:20.880 --> 45:22.880]  ребенком,
[45:22.880 --> 45:24.880]  то в этом случае вы пишете,
[45:24.880 --> 45:26.880]  что указатель left равен
[45:26.880 --> 45:28.880]  на 13, на эту вершину,
[45:28.880 --> 45:30.880]  а указатель right равен
[45:30.880 --> 45:32.880]  now.
[45:32.880 --> 45:34.880]  Понятно?
[45:34.880 --> 45:36.880]  Вот.
[45:36.880 --> 45:38.880]  Поэтому здесь
[45:38.880 --> 45:40.880]  на самом деле все корректно.
[45:40.880 --> 45:42.880]  Если левое под дерево также разобрать,
[45:42.880 --> 45:44.880]  как и правое, то мы получим, что здесь
[45:44.880 --> 45:46.880]  все корректно.
[45:46.880 --> 45:48.880]  Это является действительно бинарным
[45:48.880 --> 45:50.880]  деревом поиска.
[45:50.880 --> 45:52.880]  Можно тогда вопрос по определению?
[45:52.880 --> 45:54.880]  Да.
[45:54.880 --> 45:56.880]  Мы ставили три условия, что три
[45:56.880 --> 45:58.880]  непересекающегося множества.
[45:58.880 --> 46:00.880]  Корневой узел, бинарное дерево слева,
[46:00.880 --> 46:02.880]  бинарное дерево справа.
[46:02.880 --> 46:04.880]  Может быть только бинарное дерево слева
[46:04.880 --> 46:06.880]  или только бинарное дерево справа?
[46:06.880 --> 46:08.880]  Потому что бинарным деревом
[46:08.880 --> 46:10.880]  там помнишь условия, написано
[46:10.880 --> 46:12.880]  пустое множество.
[46:12.880 --> 46:14.880]  Спасибо.
[46:14.880 --> 46:16.880]  Нет вопросов.
[46:16.880 --> 46:18.880]  Хорошо.
[46:18.880 --> 46:20.880]  Бинарное дерево поиска
[46:20.880 --> 46:22.880]  достаточно полезная штука.
[46:26.880 --> 46:28.880]  Когда под дерево единственное,
[46:28.880 --> 46:30.880]  сложно сказать левое оно или правое.
[46:30.880 --> 46:32.880]  Это правда сложно,
[46:32.880 --> 46:34.880]  но я здесь специально
[46:34.880 --> 46:36.880]  рисовал влево и вправо стрелочки
[46:36.880 --> 46:38.880]  для того, чтобы можно было определить
[46:38.880 --> 46:40.880]  то это или нет.
[46:40.880 --> 46:42.880]  Сразу скажу, что в контрольной
[46:42.880 --> 46:44.880]  скорее всего, я напомню вам,
[46:44.880 --> 46:46.880]  что вас еще ожидает в конце семестра
[46:46.880 --> 46:48.880]  контрольная по алгоритмам,
[46:48.880 --> 46:50.880]  возможны такие вопросы,
[46:50.880 --> 46:52.880]  а является ли это бинарным деревом поиска,
[46:52.880 --> 46:54.880]  к примеру, или укажите
[46:54.880 --> 46:56.880]  бинарные деревья поиска.
[46:56.880 --> 46:58.880]  Может быть все что угодно.
[47:02.880 --> 47:04.880]  Главное, чтобы помнить, что бинарное означает
[47:04.880 --> 47:06.880]  два,
[47:06.880 --> 47:08.880]  два потомка
[47:08.880 --> 47:10.880]  и так далее.
[47:10.880 --> 47:12.880]  Хорошо.
[47:12.880 --> 47:14.880]  Смотрите, действия,
[47:14.880 --> 47:16.880]  которые мы можем вообще совершать
[47:16.880 --> 47:18.880]  со своим деревом.
[47:18.880 --> 47:20.880]  И первое, что нам необходимо на самом деле,
[47:20.880 --> 47:22.880]  это обход дерева.
[47:30.880 --> 47:32.880]  Повторите, пожалуйста,
[47:32.880 --> 47:34.880]  свойство бинарного дерева поиска.
[47:34.880 --> 47:36.880]  В бинарном дереве поиска
[47:36.880 --> 47:38.880]  для любого узла
[47:38.880 --> 47:40.880]  в левом его по дереве
[47:40.880 --> 47:42.880]  стоят все
[47:42.880 --> 47:44.880]  узлы, у которых
[47:44.880 --> 47:46.880]  ключ меньше,
[47:46.880 --> 47:48.880]  чем у моего узла,
[47:48.880 --> 47:50.880]  с которого я смотрю. То есть, если это корень
[47:50.880 --> 47:52.880]  8, к примеру, я смотрю, то в левом его
[47:52.880 --> 47:54.880]  по дереве все элементы меньше
[47:54.880 --> 47:56.880]  имеют ключ,
[47:56.880 --> 47:58.880]  а в правом все больше.
[48:00.880 --> 48:02.880]  Вот.
[48:02.880 --> 48:04.880]  Если у вас вдруг есть равные элементы,
[48:04.880 --> 48:06.880]  они могут на самом деле здесь повторяться
[48:06.880 --> 48:08.880]  в зависимости от вашей реализации
[48:08.880 --> 48:10.880]  вашего бинарного дерева.
[48:10.880 --> 48:12.880]  Вот. Вы можете отправить его либо вправо,
[48:12.880 --> 48:14.880]  либо влево. Хорошо?
[48:14.880 --> 48:16.880]  Окей.
[48:16.880 --> 48:18.880]  Давайте дальше.
[48:20.880 --> 48:22.880]  А равные элементы могут быть одновременно
[48:22.880 --> 48:24.880]  из права и слева? То есть, например, у нас
[48:24.880 --> 48:26.880]  родитель 5, и мы слева и справа отправим
[48:26.880 --> 48:28.880]  пятерки.
[48:28.880 --> 48:30.880]  Это не совсем корректно может быть.
[48:30.880 --> 48:32.880]  Вот. Потому что
[48:32.880 --> 48:34.880]  если вы определяете как это бинарное дерево,
[48:34.880 --> 48:36.880]  лучше убрать не до сказаний, сколько раз
[48:36.880 --> 48:38.880]  слева элементы все меньше, справа
[48:38.880 --> 48:40.880]  не меньше.
[48:40.880 --> 48:42.880]  Вот. Понятно?
[48:42.880 --> 48:44.880]  Хорошо.
[48:44.880 --> 48:46.880]  Окей.
[48:46.880 --> 48:48.880]  Давайте с вами говорить об обходе
[48:48.880 --> 48:50.880]  дерева. Обход
[48:52.880 --> 48:54.880]  бинарного
[48:56.880 --> 48:58.880]  дерева
[49:00.880 --> 49:02.880]  поиска.
[49:04.880 --> 49:06.880]  Первый обход,
[49:06.880 --> 49:08.880]  который мы с вами затронем,
[49:08.880 --> 49:10.880]  это будет
[49:16.880 --> 49:18.880]  симметрический
[49:18.880 --> 49:20.880]  симметрический.
[49:26.880 --> 49:28.880]  Центрированный.
[49:28.880 --> 49:30.880]  Его также называют
[49:30.880 --> 49:32.880]  центрированный.
[49:34.880 --> 49:36.880]  Но
[49:38.880 --> 49:40.880]  обход
[49:42.880 --> 49:44.880]  обход.
[49:44.880 --> 49:46.880]  Это следующий обход,
[49:46.880 --> 49:48.880]  обход дерева,
[49:48.880 --> 49:50.880]  обход
[49:52.880 --> 49:54.880]  узлов,
[49:54.880 --> 49:56.880]  узлов
[49:56.880 --> 49:58.880]  в отсортированном
[50:04.880 --> 50:06.880]  порядке.
[50:10.880 --> 50:12.880]  Обход узлов в отсортированном порядке.
[50:14.880 --> 50:16.880]  Вот. Что это означает?
[50:16.880 --> 50:18.880]  Давайте с вами вернемся к этому
[50:18.880 --> 50:20.880]  дереву. И вот здесь вот будем как раз
[50:20.880 --> 50:22.880]  таки все писать. Давайте я его еще раз нарисую.
[50:22.880 --> 50:24.880]  Только маленьким.
[50:26.880 --> 50:28.880]  Такой зеленый.
[50:28.880 --> 50:30.880]  Восемь.
[50:32.880 --> 50:34.880]  Там у меня было здесь три.
[50:36.880 --> 50:38.880]  Здесь было один.
[50:40.880 --> 50:42.880]  Здесь было шесть.
[50:42.880 --> 50:44.880]  Здесь
[50:46.880 --> 50:48.880]  четыре. Здесь
[50:48.880 --> 50:50.880]  семь.
[50:50.880 --> 50:52.880]  Здесь у меня был правый из
[50:52.880 --> 50:54.880]  десяти.
[50:58.880 --> 51:00.880]  Потом был правый из четырнадцати.
[51:00.880 --> 51:02.880]  И левый сын.
[51:02.880 --> 51:04.880]  Это четырнадцать.
[51:04.880 --> 51:06.880]  Давайте я перепишу, чтобы точно видно было.
[51:08.880 --> 51:10.880]  Четырнадцать.
[51:10.880 --> 51:12.880]  И здесь у меня был тринадцать.
[51:16.880 --> 51:18.880]  Как необходимо обойти
[51:18.880 --> 51:20.880]  дерево для того, чтобы
[51:20.880 --> 51:22.880]  был порядок
[51:22.880 --> 51:24.880]  возраста в отсортированном
[51:24.880 --> 51:26.880]  порядке?
[51:26.880 --> 51:28.880]  И пройтись вот таким
[51:28.880 --> 51:30.880]  образом.
[51:30.880 --> 51:32.880]  Вот так, вот так,
[51:32.880 --> 51:34.880]  вот так, вот так.
[51:34.880 --> 51:36.880]  После чего
[51:36.880 --> 51:38.880]  мы идем вот сюда,
[51:38.880 --> 51:40.880]  сюда, сюда.
[51:40.880 --> 51:42.880]  Сюда сначала.
[51:42.880 --> 51:44.880]  Потом сюда. И вот здесь закончим.
[51:44.880 --> 51:46.880]  Смотрите, вот здесь
[51:46.880 --> 51:48.880]  когда у меня есть выемка,
[51:48.880 --> 51:50.880]  мне считает четырнадцать.
[51:50.880 --> 51:52.880]  И вот здесь у меня не считает шесть.
[51:52.880 --> 51:54.880]  Это не считается.
[51:54.880 --> 51:56.880]  Чего у меня проходит?
[51:56.880 --> 51:58.880]  Показывайте вершины, какие
[51:58.880 --> 52:00.880]  трубы.
[52:00.880 --> 52:02.880]  Нам необходимо,
[52:02.880 --> 52:04.880]  чтобы наш алгоритм
[52:04.880 --> 52:06.880]  обхода вывел
[52:06.880 --> 52:08.880]  следующую последовательность.
[52:08.880 --> 52:10.880]  Давайте сейчас. Один,
[52:10.880 --> 52:12.880]  три, четыре,
[52:12.880 --> 52:14.880]  шесть, семь,
[52:14.880 --> 52:16.880]  восемь, десять,
[52:16.880 --> 52:18.880]  тринадцать и четырнадцать.
[52:20.880 --> 52:22.880]  В отсортированном
[52:22.880 --> 52:24.880]  порядке.
[52:24.880 --> 52:26.880]  И это можно сделать.
[52:26.880 --> 52:28.880]  Это не очень сложно с помощью рекурсии.
[52:28.880 --> 52:30.880]  Вот.
[52:30.880 --> 52:32.880]  Что такое
[52:32.880 --> 52:34.880]  вот этот вот симметрический
[52:34.880 --> 52:36.880]  подход? Смотрите.
[52:36.880 --> 52:38.880]  Нам необходимо обойти сначала левый.
[52:38.880 --> 52:40.880]  После этого, если нет
[52:40.880 --> 52:42.880]  никаких левых, то вернуться
[52:42.880 --> 52:44.880]  к родителю.
[52:44.880 --> 52:46.880]  И дальше пойти вправое под дерево.
[52:46.880 --> 52:48.880]  Опять найти здесь
[52:48.880 --> 52:50.880]  левый кусочек.
[52:50.880 --> 52:52.880]  Если левых под деревьев нет больше,
[52:52.880 --> 52:54.880]  и мы все там обошли,
[52:54.880 --> 52:56.880]  мы возвращаемся к нашему родителю.
[52:56.880 --> 52:58.880]  И идем вправо.
[52:58.880 --> 53:00.880]  Если у правого нет ни левого, ни правого,
[53:00.880 --> 53:02.880]  то мы возвращаемся к родителю, идем наверх-наверх,
[53:02.880 --> 53:04.880]  пока у нас не появится еще раз правое дерево.
[53:04.880 --> 53:06.880]  То есть, смотрите, мы идем как будто бы слева
[53:06.880 --> 53:08.880]  направо.
[53:08.880 --> 53:10.880]  Понятно?
[53:10.880 --> 53:12.880]  По-хорошему,
[53:12.880 --> 53:14.880]  если бы мы, ну, у меня было бы тут
[53:14.880 --> 53:16.880]  чуть побольше расстояния, я бы мог
[53:16.880 --> 53:18.880]  вот это вот все,
[53:18.880 --> 53:20.880]  грубо говоря, спустить вот так вот
[53:20.880 --> 53:22.880]  на координатную плоскость, если бы
[53:22.880 --> 53:24.880]  правильно рисовал,
[53:24.880 --> 53:26.880]  что все правое под дерево лежит правее.
[53:26.880 --> 53:28.880]  И у меня они бы спустились
[53:28.880 --> 53:30.880]  ровно на свои места. То есть у меня было бы
[53:30.880 --> 53:32.880]  1, 3, 4, 6, 7,
[53:32.880 --> 53:34.880]  8, 9, 10, 13, 14.
[53:34.880 --> 53:36.880]  То есть, представьте, я
[53:36.880 --> 53:38.880]  все это спустил, если вот
[53:38.880 --> 53:40.880]  красиво так нарисовать,
[53:40.880 --> 53:42.880]  спустил это все на
[53:42.880 --> 53:44.880]  свою какую-то координатную
[53:44.880 --> 53:46.880]  прямую, и я
[53:46.880 --> 53:48.880]  получил как раз эти
[53:48.880 --> 53:50.880]  значения.
[53:50.880 --> 53:52.880]  Как это делается?
[53:52.880 --> 53:54.880]  Ну, это делается достаточно просто.
[53:56.880 --> 53:58.880]  Давайте напишем
[53:58.880 --> 54:00.880]  с вами функцию.
[54:02.880 --> 54:04.880]  InOrder
[54:04.880 --> 54:06.880]  Волк, например.
[54:06.880 --> 54:08.880]  Обход.
[54:08.880 --> 54:10.880]  InOrder, обход.
[54:10.880 --> 54:12.880]  Куда
[54:12.880 --> 54:14.880]  я передаю какой-то там ключик?
[54:14.880 --> 54:16.880]  Потому что я буду делать рекурсивно.
[54:18.880 --> 54:20.880]  Если вам нужно обойти весь граф,
[54:20.880 --> 54:22.880]  то вы передаете туда
[54:22.880 --> 54:24.880]  корень.
[54:24.880 --> 54:26.880]  Вот.
[54:26.880 --> 54:28.880]  x это не тип нода.
[54:30.880 --> 54:32.880]  Что я говорю, что если у меня
[54:34.880 --> 54:36.880]  если у меня x
[54:36.880 --> 54:38.880]  не равен
[54:38.880 --> 54:40.880]  now,
[54:40.880 --> 54:42.880]  то есть он как бы нода,
[54:42.880 --> 54:44.880]  но указатель на ноду.
[54:44.880 --> 54:46.880]  Звездочка, если хотите.
[54:48.880 --> 54:50.880]  То в этом случае
[54:50.880 --> 54:52.880]  на всякий случай в плюсах
[54:52.880 --> 54:54.880]  указатели сравниваются
[54:54.880 --> 54:56.880]  лучше с nowptr.
[54:56.880 --> 54:58.880]  Если это
[54:58.880 --> 55:00.880]  now, то в этом случае
[55:00.880 --> 55:02.880]  вы делаете
[55:02.880 --> 55:04.880]  InOrder
[55:04.880 --> 55:06.880]  Волк
[55:06.880 --> 55:08.880]  от
[55:08.880 --> 55:10.880]  xLeft
[55:12.880 --> 55:14.880]  после чего
[55:14.880 --> 55:16.880]  печатаете
[55:16.880 --> 55:18.880]  xKey
[55:20.880 --> 55:22.880]  а после чего запускаете
[55:22.880 --> 55:24.880]  InOrder
[55:28.880 --> 55:30.880]  Волк
[55:30.880 --> 55:32.880]  от xRate
[55:32.880 --> 55:34.880]  И тогда вы сможете
[55:34.880 --> 55:36.880]  все напечатать.
[55:36.880 --> 55:38.880]  Для того чтобы понять, а как это вообще работает,
[55:38.880 --> 55:40.880]  давайте с вами напишем стек рекурсии
[55:40.880 --> 55:42.880]  и тогда вам станет ясно.
[55:42.880 --> 55:44.880]  На самом деле вы почти все
[55:44.880 --> 55:46.880]  задали задания.
[55:46.880 --> 55:48.880]  Мы почти все должны были задать задания.
[55:48.880 --> 55:50.880]  Уже первая.
[55:50.880 --> 55:52.880]  Там у вас была задачка с Ханойским башнем.
[55:52.880 --> 55:54.880]  Вот тут похожий принцип на это.
[55:54.880 --> 55:56.880]  То есть если у меня есть
[55:56.880 --> 55:58.880]  какой-то стек рекурсий,
[56:00.880 --> 56:02.880]  первоначально я вызываю
[56:02.880 --> 56:04.880]  от своего корня.
[56:04.880 --> 56:06.880]  Тогда у меня первый стек рекурсий
[56:06.880 --> 56:08.880]  грубо говоря
[56:08.880 --> 56:10.880]  8 печатать когда-то.
[56:10.880 --> 56:12.880]  Я просто буду обозначать,
[56:12.880 --> 56:14.880]  здесь не писать саму функцию, но это стек рекурсий.
[56:14.880 --> 56:16.880]  Вот.
[56:16.880 --> 56:18.880]  Дальше я иду в левый под деревья,
[56:18.880 --> 56:20.880]  потому что первоначально я вызываю рекурсию,
[56:20.880 --> 56:22.880]  а не печатаю что-то.
[56:22.880 --> 56:24.880]  Тогда выше восьмерки у меня будет тройка.
[56:24.880 --> 56:26.880]  Тройка тоже у меня ничего не сделает,
[56:26.880 --> 56:28.880]  потому что когда она войдет в рекурсию,
[56:28.880 --> 56:30.880]  у меня есть левт еще.
[56:30.880 --> 56:32.880]  Он не на лву.
[56:32.880 --> 56:34.880]  Тогда он смотрит на единицу.
[56:34.880 --> 56:36.880]  Единица.
[56:36.880 --> 56:38.880]  У нее нет ни левого под дерево,
[56:38.880 --> 56:40.880]  ни правого под дерево.
[56:40.880 --> 56:42.880]  Он просто печатает в XK.
[56:42.880 --> 56:44.880]  То есть я напечатал здесь
[56:44.880 --> 56:46.880]  единичку.
[56:46.880 --> 56:48.880]  И убираю это из стека.
[56:50.880 --> 56:52.880]  Так, желтый плов.
[56:52.880 --> 56:54.880]  Давайте оранжевый.
[56:54.880 --> 56:56.880]  Так лучше.
[56:56.880 --> 56:58.880]  И я убираю это из стека рекурсии.
[56:58.880 --> 57:00.880]  Возвращаюсь к тройке.
[57:00.880 --> 57:02.880]  У тройки есть еще...
[57:02.880 --> 57:04.880]  Я печатаю тройку, потому что у него
[57:04.880 --> 57:06.880]  деревьев больше нет.
[57:06.880 --> 57:08.880]  Поэтому я здесь печатаю три.
[57:08.880 --> 57:10.880]  Но из стека рекурсии она пока
[57:10.880 --> 57:12.880]  еще не выходит.
[57:12.880 --> 57:14.880]  Потому что у меня есть еще правое под дерево,
[57:14.880 --> 57:16.880]  которое должен прогуляться вот здесь.
[57:16.880 --> 57:18.880]  Значит у меня в этот стек
[57:18.880 --> 57:20.880]  рекурсии сверху добавляется
[57:20.880 --> 57:22.880]  четыре.
[57:22.880 --> 57:24.880]  Ой, шесть сначала.
[57:24.880 --> 57:26.880]  У шестерки есть левое под дерево.
[57:26.880 --> 57:28.880]  Сначала четыре.
[57:28.880 --> 57:30.880]  У четыре нет уже левого под дерево.
[57:30.880 --> 57:32.880]  Ни правого под дерево на самом деле
[57:32.880 --> 57:34.880]  ничего нет, поэтому я просто печатаю
[57:34.880 --> 57:36.880]  четыре.
[57:36.880 --> 57:38.880]  И возвращаюсь к шестерке.
[57:40.880 --> 57:42.880]  После этого у шестерки,
[57:42.880 --> 57:44.880]  так как левых под деревьев левой рекурсии
[57:44.880 --> 57:46.880]  никакой не было, я печатаю
[57:46.880 --> 57:48.880]  х, то есть шесть.
[57:50.880 --> 57:52.880]  И дальше я захожу
[57:52.880 --> 57:54.880]  в семерку.
[57:54.880 --> 57:56.880]  То есть у меня в стеке рекурсии появляется
[57:56.880 --> 57:58.880]  вот эта вот семерка.
[57:58.880 --> 58:00.880]  После чего я печатаю...
[58:00.880 --> 58:02.880]  У семерки ничего нет, я печатаю семь.
[58:02.880 --> 58:04.880]  Убираю ее из своего стека
[58:04.880 --> 58:06.880]  рекурсии.
[58:06.880 --> 58:08.880]  Возвращаюсь к шестерке.
[58:08.880 --> 58:10.880]  У шестерки мы тоже уже все обошли, значит
[58:10.880 --> 58:12.880]  мы убираем её из стека рекурсии.
[58:12.880 --> 58:14.880]  У тройки мы тоже уже все обошли.
[58:14.880 --> 58:16.880]  Возвращаем стек рекурсии.
[58:16.880 --> 58:18.880]  Если мы прошли все левое
[58:18.880 --> 58:20.880]  под дерево, то в этом случае
[58:20.880 --> 58:22.880]  мы печатаем здесь восемь.
[58:22.880 --> 58:24.880]  И дальше идем в правое под дерево.
[58:24.880 --> 58:26.880]  Но правое под дерево
[58:26.880 --> 58:28.880]  аналогично рассматривается. У вас
[58:28.880 --> 58:36.000]  10 13 и 14 есть ли вопрос именно к этой к этому обходу как он работает
[58:36.000 --> 58:43.440]  треть пожалуйста говорили что указатель лучше сравнивать с нал птр да да да спасибо
[58:43.440 --> 58:51.920]  был такой ну ли вы указатели все плюс плюс в одиннадцатых ну стали нал птр ну можно с нулем
[58:51.920 --> 59:02.080]  можно сразу то есть так вы хотите и еще раз просто для удобства ну где у нас
[59:02.080 --> 59:10.640]  все в дакоиде реализовано удаление элемента вот как мы убирали а зачем мы удаляем
[59:10.640 --> 59:19.120]  у нас здесь нет никакого удаления мы обходим дерево мы еще до удаления дошли
[59:19.120 --> 59:28.880]  удаление где реализовываться но почти таким же алгоритмом там с точностью до переставки
[59:28.880 --> 59:39.520]  двухстрок по идее долей не ну да нет удаление с бинарного дерева поиска не так работает а еще
[59:39.520 --> 59:47.640]  раз повторить алгоритм смысле очистку дерево то есть полнодаление дерева ну если вы хотите
[59:47.720 --> 59:54.080]  по полности удалить его туда так можно почти что так но только нужно переставить будет что-то
[59:54.080 --> 01:00:02.000]  да ну здесь нет проблем но на самом деле если начислить туда так давайте еще раз как выглядит
[01:00:02.000 --> 01:00:06.760]  этот алгоритм до всего остального мы с вами дойдем как очистить память я думаю вы справитесь
[01:00:06.760 --> 01:00:15.240]  вот еще раз как работает этот алгоритм первоначально мы идем в самое левое под дерево самым
[01:00:15.240 --> 01:00:21.080]  левым согласно нашему принципу вообще бинарного дерева поиска самым левым находится самый минимальный
[01:00:21.080 --> 01:00:28.760]  элемент поэтому мы должны его сначала вывести после этого мы возвращаемся к родителю этого
[01:00:28.760 --> 01:00:35.320]  минимального элемента и просмат и печатаем его идем в правое под деревом правом под деревья
[01:00:35.320 --> 01:00:42.960]  опять могут находиться левые правые под деревья мы по ним пойдем мы сначала выводим все левое потом
[01:00:42.960 --> 01:00:51.960]  выводим сам элемент потом все правое вот суть алгоритма в этом вот и все вот
[01:00:51.960 --> 01:01:07.440]  да смотрите еще раз я пишу здесь псевдокода вот я вы можете использовать так как хотите но я
[01:01:07.440 --> 01:01:12.320]  пишу здесь просто псевдокод для понимания того чтобы вы понимали как устроен алгоритм
[01:01:12.320 --> 01:01:20.160]  я не пишу здесь прям на конкретных плюсах вот окей давайте с вами продолжим дальше есть ли
[01:01:20.160 --> 01:01:31.680]  еще вопросы к этому обходу видимо нету окей тогда давайте с вами перейдем к следующему
[01:01:31.680 --> 01:01:42.480]  следующий обход который нас ждет это второй обход он прямой по это прямой порядок прямой
[01:01:42.480 --> 01:01:51.360]  порядок есть мне опять придется нарисовать свое это дерево чтобы на нем все сделать
[01:01:51.360 --> 01:02:08.560]  прямой порядок это выводится корень а после чего левая левая левая под дерево
[01:02:12.640 --> 01:02:13.440]  после правая
[01:02:13.440 --> 01:02:43.000]  прошу прощения вот давайте здесь напишем с вами как выглядит прямой
[01:02:43.000 --> 01:02:50.120]  порядок давайте сначала нарисуем вообще как выглядит это сначала еще раз это дерево повторим
[01:02:50.120 --> 01:03:03.720]  давайте пусть будет так у нас было здесь 8 здесь у меня было 3 здесь у меня был 1 здесь 6
[01:03:03.720 --> 01:03:33.160]  6 после чего здесь было 4 7 здесь 10 здесь 14 здесь 13 вот вот и нам необходимо
[01:03:33.480 --> 01:03:38.160]  вывести это вот таком порядке который здесь написано для того чтобы это сделать нам
[01:03:38.160 --> 01:03:43.800]  достаточно также написать просто псевдокод и вы сейчас поймете почему это порядок называется прям
[01:03:43.800 --> 01:03:44.800]  прикордер
[01:03:44.800 --> 01:04:03.640]  там это кса также одно мы говорим что если у меня икс не ноль то в этом случае мы печатаем
[01:04:03.640 --> 01:04:19.080]  сначала икс икс кей после чего мы делаем при ордер прикордер волк начала от левого по дерево то
[01:04:19.080 --> 01:04:36.600]  есть от икс точка левт после чего мы делаем прикордер волк от правого по дереву то есть
[01:04:36.600 --> 01:04:41.920]  смотрите мне нужно чтобы я смог вывести сначала вызывать скорень потом левая под
[01:04:42.920 --> 01:04:50.400]  то есть у меня вывести 8 3 потом левая по дереву 1 потом я возвращаюсь правая здесь
[01:04:50.400 --> 01:05:02.800]  корень 6 потом левая 4 потом 7 потом я иду вправое по дереву там 10 14 13 здесь аналогично работаем
[01:05:02.800 --> 01:05:10.800]  со стеком вызова функции единственное что у нас принц самого начала то есть здесь мы как бы
[01:05:10.800 --> 01:05:19.320]  начинаем но этот порядок выглядит следующим образом на сами на самом дереве я иду с корня и
[01:05:19.320 --> 01:05:29.160]  обхожу свое дерево просто следующим образом вот так вот так вот так 4 потом 7 потом возвращаюсь
[01:05:29.160 --> 01:05:40.920]  сюда 10 14 13 на самом деле был бы правое по дереву я бы сделал вот так вот и заканчивается но
[01:05:40.920 --> 01:05:47.800]  здесь то есть смотрите мы обходим начиная самого корня и абсолютно все вершинки за собой тянем то
[01:05:47.800 --> 01:05:58.360]  есть мы обходим обходим вот и все вот это прямой порядок вызову с этим есть вопросы
[01:05:58.360 --> 01:06:04.840]  получается что если мы проходим если используем симметрический порядок и обход дерева то мы
[01:06:04.840 --> 01:06:13.480]  обязательно нужно дать самую левую чтобы пройти весь граф а для ну и корень туда передаем и везде
[01:06:13.480 --> 01:06:22.800]  корень передаем нет если для симметрического то там же он ведь окончится на том что в смысле
[01:06:22.800 --> 01:06:28.720]  если мы передать такой сильный вызов он найдет самый левый лист и начнет с него да здесь у нас
[01:06:28.720 --> 01:06:35.080]  так построено грид что мы передаем корень сначала в самый левый уйдем а только потом перейдем
[01:06:35.080 --> 01:06:43.640]  во все остальное если вы хотите вывести именно так туда корень
[01:06:43.640 --> 01:06:53.800]  вот это что касается прямого порядка и как вы думаете если есть прямой порядок то есть
[01:06:53.800 --> 01:07:04.600]  какой порядок обратный обратный правильно обратный порядок как вы думаете давайте тут
[01:07:04.760 --> 01:07:14.720]  думаете просто обратный порядок обратный обратный порядок
[01:07:14.720 --> 01:07:33.120]  обратный порядок сначала левая и правая под дерево левая потом правая под деревья
[01:07:33.120 --> 01:07:59.920]  а потом корень после корень если опять нарисую это же дерево 8 3 1 6
[01:08:03.120 --> 01:08:16.040]  4 7 здесь у меня будет 10 14 13
[01:08:16.040 --> 01:08:34.280]  13 вот то есть в каком порядке он мне должен взять и вывести этот массив данных которые у
[01:08:34.280 --> 01:08:40.680]  меня есть вот в этом дереве он мне должен вывести следующим видео сначала левая правая только потом
[01:08:40.680 --> 01:08:52.600]  корень то есть 1 4 7 потом корень этого 6 потом 3 после мы идем вправое под деревом и по
[01:08:52.600 --> 01:09:10.400]  нему ходим здесь 13 14 10 и 8 вот так выглядит обратный порядок вызова то есть мы грубо
[01:09:10.440 --> 01:09:18.800]  говоря сначала идем по листам потом возвращаемся к родителям вот если вы хотите увидеть как здесь
[01:09:18.800 --> 01:09:28.520]  это выглядит на рисуночке то это будет выглядит вот так 1 4 7 потом только 6 потом 3 после чего
[01:09:28.520 --> 01:09:37.720]  мы идем вот сюда и переходим сначала в 13 потом 14 10 8 и на 8 заканчиваем вот
[01:09:40.520 --> 01:09:45.840]  прямой обратный порядок то есть условно симметричный понятно в порядке возрастания
[01:09:45.840 --> 01:09:56.920]  бывания по ходить хотите забавный случай забавный случай следующим я как-то ну вот уже давно давно
[01:09:56.920 --> 01:10:03.120]  получается проходил собесовый яндекс я думаю на кафедру яндекса кто-то из вас все-таки почта
[01:10:03.120 --> 01:10:09.960]  и думает об этом и меня разработчик спросил следующий чуть-чуть отключом с простой темы
[01:10:09.960 --> 01:10:15.480]  спросил следующий представь у меня есть такой огромный огромный граф типа связи в принципе и
[01:10:15.480 --> 01:10:26.280]  мне нужно понять а если в этом огромном графе маленький под граф как это сделать быстро а быстро
[01:10:26.280 --> 01:10:32.240]  это можно сделать с помощью этих обходов если вывести в прямом и обратном порядке и то и то
[01:10:32.240 --> 01:10:38.720]  дерево и посмотреть вообще существует ли такие последовательности то мы получим с вами что если
[01:10:38.720 --> 01:10:46.000]  такое вообще а под граф грубо говоря в этом графе большом поэтому суть на самом деле обратные
[01:10:46.000 --> 01:10:52.360]  порядки прямые порядки достаточно полезные штуки мы так можем понять структуру самого самого
[01:10:52.360 --> 01:11:00.400]  бинарного дерева вот и все то есть если вам будет дан к примеру какая-то последовательности вам
[01:11:00.400 --> 01:11:05.960]  нужно построить по ней типа обратную обратный порядок то вот пожалуйста вы можете как-то
[01:11:05.960 --> 01:11:13.720]  из этого массива данных получить а какое у вас вообще было дерево поиска это не очень вот
[01:11:13.720 --> 01:11:20.280]  получается можно по обратному порядку однозначно установить дерево выходить не по не по обратному
[01:11:20.280 --> 01:11:32.280]  по нескольким вещам можно вот но по обратному порядку мы сможем восстановить какие элементы
[01:11:32.280 --> 01:11:39.560]  являются крайними то есть замыкающими ли как можно сказать листьями вот но здесь тоже не
[01:11:39.560 --> 01:11:44.960]  совсем корректно то есть мы можем точно сказать что такой курить вот это мы точно можно сказать
[01:11:44.960 --> 01:11:50.720]  вот замык последний а вот а дальше здесь же будут вопросы типа того как это именно
[01:11:50.720 --> 01:11:57.760]  выглядит вот и все но то есть на самом деле можно сказать что вот этот вот кусок он разделен то
[01:11:57.760 --> 01:12:02.640]  есть то что больше восьми лежит в правом по дереве меньше восьми в левом по дереве то есть вот сын
[01:12:02.640 --> 01:12:11.360]  и вот на самом деле у этого дерева у восьмерки лично десятки мы тоже начинаем отделять вот
[01:12:11.360 --> 01:12:18.680]  это все лежит в правом по дереве 4 является его сыном у тройки вот так вот является все правом
[01:12:18.680 --> 01:12:23.880]  по дереву все что четырех до шести а единичка левым по деревам значит вот этот сын и вот это
[01:12:23.880 --> 01:12:31.640]  самим все можно восстановить еще между 4 и 7 надо поставить ну у шестерки да у шестерки типа вот
[01:12:31.640 --> 01:12:37.640]  четыре от левая по дереве правая здесь просто необходимо очень много так типа грубо говоря ходить
[01:12:37.640 --> 01:12:43.000]  и смотреть когда заканчивается элементы меньше больше необходимо его только реализовать пост ордера
[01:12:43.000 --> 01:12:59.080]  от какого-то икса мы пишем следующее если у меня икс не равен но то в этом случае я
[01:12:59.080 --> 01:13:13.200]  делаю просто пост ордер пост ордер если мы бы писали обычных код они все в доклад нам надо
[01:13:13.200 --> 01:13:21.400]  было бы рассмотреть если и правый и левый волк ордер не равно нулём то есть указатель на правый
[01:13:22.400 --> 01:13:29.000]  зачем у тебя вот здесь и становка рекурсии ты просто пишешь икс неравен на нау пдр ты
[01:13:29.000 --> 01:13:41.000]  передаешь нау он тебя не выполнит рекурсию просто еще а все понял пост ордер волк икс
[01:13:41.000 --> 01:13:55.520]  и там принц икс точку киев глик что у тебя за чудесная вот так
[01:13:55.520 --> 01:14:04.520]  ахан включай камеру были нелеков да да да
[01:14:04.520 --> 01:14:15.940]  окей это то что касается вообще вот обходов за сколько работают обходы давайте на одном
[01:14:15.940 --> 01:14:22.280]  примере на инордер волк который у меня был вот симметрический проход мы по нему и скажем
[01:14:22.280 --> 01:14:29.920]  вообще за сколько у нас что работает окей ну все остальные будут делаться примерно
[01:14:29.920 --> 01:14:43.520]  аналогично пусть у меня корень икс вот с н узлами н узлами обход будет занимать это от это это
[01:14:43.520 --> 01:14:59.480]  будет им порта в самом деле все остальные тоже смотрите снизу мы можем ограничить следующим
[01:14:59.480 --> 01:15:08.000]  образом мы с вами знаем что он пройдется как минимум по вершину поэтому время работы как
[01:15:08.000 --> 01:15:14.960]  минимум это маленькое омега большое от то есть снизу мы взяли и ограничен он должен пройтись
[01:15:14.960 --> 01:15:25.520]  по всем вот если у меня только лишь при же упрощение если лишь у меня только там нулевой какой-то
[01:15:25.520 --> 01:15:32.360]  элемент то есть нам вот то в этом случае там будет какой-то церковь в выполнении с меня ничего
[01:15:32.360 --> 01:15:37.920]  там будет абсолютно с рекурсии будет какой-то константное время если я возьму и у меня будет
[01:15:37.920 --> 01:15:43.160]  ноль элементов на бути на упр это будет одно сравнение ну пусть одно время какой-то цель занимает
[01:15:43.160 --> 01:15:55.960]  вот если у меня n больше нуля то я говорю следующее у меня левая по дереву и правая по дереву пусть
[01:15:55.960 --> 01:16:12.400]  кауслов кауслов влевом по дереве и тогда в правом по дереве так как у меня в иксе
[01:16:12.400 --> 01:16:20.200]  н узлов то влевом правом по дереве у меня будет n минус ка минус один правом по дереве
[01:16:20.200 --> 01:16:27.960]  минус ка потому что влевом минус один потому что еще корень есть сам по себе правом по дереве
[01:16:27.960 --> 01:16:39.280]  ok тогда мы с вами говорим что если у меня т от n есть то оно будет меньше либо равно
[01:16:39.280 --> 01:16:47.000]  чем некоторые т от к ну время работы левого по дерево плюс время работы n минус ка минус
[01:16:47.000 --> 01:16:54.120]  один наш рекурсивный алгоритм для правого по дерево и плюс какая-то константа д какая-то
[01:16:54.120 --> 01:17:01.040]  константа д где у меня это время выполнения без рекурсии то есть время выполнения моей
[01:17:01.040 --> 01:17:16.680]  функции без рекурсии время выполнения давайте сейчас пояснение сделаем д время выполнения то
[01:17:16.680 --> 01:17:27.400]  есть это приент и фут этот сравнить так далее время выполнения без вызова рекурсии
[01:17:27.400 --> 01:17:41.160]  вот меньше ли она не просто равно ну потому что я д так специально подберу мне нужно ограничить
[01:17:41.160 --> 01:17:45.880]  сверху смотрите если я говорю что я ограничил снизу свое т от n то мне нужно доказать что
[01:17:45.880 --> 01:17:53.360]  т от n это у большое от n правильно и тогда я могу сказать что это это правильно правильно тогда
[01:17:53.360 --> 01:17:58.360]  мне нужно взять ограничение сверху какой-то поэтому мы ограничили вот таким вот образом
[01:17:58.360 --> 01:18:07.280]  т это что логично вот окей у меня есть время выполнения без рекурсии тогда покажем что
[01:18:07.280 --> 01:18:25.960]  т от n меньше либо равно чем c плюс d на n плюс там цепь по индукции индукции базы индукции
[01:18:25.960 --> 01:18:38.280]  следующие база n равная нулю т от нуля меньше либо равно чем ц и плюс д умножить на ноль
[01:18:38.280 --> 01:18:47.960]  плюс ц равная ц ну да логично мы так и говорили чудесно теперь для н больше либо больших нуля
[01:18:47.960 --> 01:19:00.960]  мы говорим что т от н меньше либо равно чем т от к плюс т от n минус к минус 1 плюс д правильно
[01:19:00.960 --> 01:19:10.200]  мы с вами уже объяснили почему к и n минус к минус 1 они меньше n меньше n поэтому это меньше
[01:19:10.200 --> 01:19:16.280]  либо равно для них работает предположение индукции вот это вот предположение которое у меня было то
[01:19:16.280 --> 01:19:28.880]  есть у меня будет меньше чем ц плюс д на к плюс ц и снова пропадает опять сейчас не слышу сейчас
[01:19:28.880 --> 01:19:39.520]  сейчас это нормально хорошо хорошо а окей для т от к мы вот написали для n минус к плюс ц плюс
[01:19:39.520 --> 01:19:54.880]  д n минус к минус 1 плюс ц и плюс ко всему этому д еще плюс да вот это да который был чудесно
[01:19:54.880 --> 01:20:01.360]  смотрите ц плюс д на к и ц плюс д вот здесь вот минус к они сокращаются друг с другом правильно
[01:20:01.360 --> 01:20:15.640]  получается ц плюс д на n это у меня равно равно ц плюс д умножить на n и у меня остается следующее
[01:20:15.640 --> 01:20:29.280]  плюс ц плюс ц плюс д это оставил ц плюс д минус 1 минус ц плюс д ну вот минус 1 здесь был получается
[01:20:29.280 --> 01:20:38.640]  вот это сокращается вот с этим с этим это равно ц плюс д на n плюс ц моё предположение индукции
[01:20:38.640 --> 01:20:45.680]  верну таким образом и сверху ограничили его ц плюс д на n плюс ц то есть мы говорим следовательно
[01:20:45.680 --> 01:20:55.920]  т от н равно о большой от н ну тогда т от н равно о большой от н и т от н равно о нега большой от
[01:20:56.120 --> 01:21:06.880]  значит т от н равно это большой от н то есть она работает за линейное время ясно как это доказано
[01:21:06.880 --> 01:21:19.320]  даже еще раз это мы все доказали верхнее самоутверждение да время работы in order
[01:21:19.320 --> 01:21:29.720]  т от н равно это вот то есть мы показали что на гранично сверху
[01:21:29.720 --> 01:21:40.200]  n ограничено снизу n и тогда оно ограничено в принципе вот и все вот такое вот доказательство есть
[01:21:40.200 --> 01:21:51.960]  и к этому вопрос можно предыдущий слайд приключить там я успел написать кое-что с приордером ну да
[01:21:51.960 --> 01:22:07.520]  еще вот это то что касается вообще а как обходить это дерево но у нас ожидает еще ой-ой блин
[01:22:07.520 --> 01:22:14.440]  пощаде мы сегодня не успеем пирамида ну ладно посмотрим успеем не успеем тут уже как пойдет вот
[01:22:14.440 --> 01:22:24.040]  если что на следующую лекцию оставим пока все понятно с бинарными деревьями они не сложные просто
[01:22:24.040 --> 01:22:31.080]  можно думать с ними еще так что выводится почему зачем мы и для чего вот
[01:22:40.240 --> 01:22:46.240]  окей все давайте с вами продолжим то ты успел хорошо
[01:22:46.240 --> 01:22:59.880]  теперь вообще работа с бинарными деревьями поиска работа с бинарными
[01:23:04.840 --> 01:23:06.360]  деревьями
[01:23:11.320 --> 01:23:11.920]  поиска
[01:23:11.920 --> 01:23:19.720]  скажите что из этих деревьев мы хотим вообще с вами получать кто мне скажет так уметь
[01:23:24.720 --> 01:23:31.080]  что из них удобно получать в лечении ментов деревьев что еще раз проверять наличие
[01:23:31.080 --> 01:23:36.520]  элементов деревьев можно проверять наличие элемента то есть можно сделать поиск элемента
[01:23:36.520 --> 01:23:38.880]  и первая такая по теме это поиск элементов
[01:23:44.000 --> 01:23:52.840]  давайте я опять нарисую наше любимое дерево и мы по нему сделаем поиск 8 3
[01:23:52.840 --> 01:24:01.920]  то очень похоже на сам бинарный поиск который вы знаете вы его прошли еще на
[01:24:01.920 --> 01:24:21.160]  семинарах дополнительно всякий случай 6 до 4 здесь у нас 7 здесь 10 здесь 14
[01:24:21.160 --> 01:24:34.040]  здесь 13 вот у нас с вами есть такое дерево как мы будем искать например здесь четверку вот
[01:24:34.040 --> 01:24:42.160]  я хочу найти 4 вот где находится этот элемент я смотрю на корень корень у меня больше 4 тогда
[01:24:42.160 --> 01:24:52.320]  я должен пойти в левую сторону так у меня 4 меньше 8 потому что у меня все элементы которые
[01:24:52.320 --> 01:25:00.280]  меньше находятся левее а все элементы больше правее вот я иду влево 4 8 я сравниваю теперь
[01:25:00.280 --> 01:25:10.560]  здесь корнем 4 больше 8 больше 3 поэтому я иду вправо а теперь мне нужно пойти влево почему
[01:25:10.560 --> 01:25:23.120]  потому что 4 меньше 6 и вот я нашел эту четверку вот и все вот единственное что если мы не
[01:25:23.120 --> 01:25:31.120]  будем находить какой-то конкретный ключ то мы будем возвращать с вами на лп т ну ну то есть
[01:25:31.120 --> 01:25:40.920]  здесь давайте напишем этот алгоритм выглядит очень просто он тоже рекурсивный здесь очень
[01:25:40.920 --> 01:25:51.960]  много рекурсии достаточно удобно ею использовать мы передаем ну откуда мы ищем и сам ключ к вот и
[01:25:51.960 --> 01:26:01.800]  мы говорим что если у меня икс равен но икс равен но но то есть я не нахожу ничего или
[01:26:01.800 --> 01:26:18.920]  или как равен икс точка к я нашел этот ключ то в этом случае я возвращаю икс то есть сам элемент
[01:26:18.920 --> 01:26:29.160]  сам узел который мы нашли вот иначе что я делаю если у меня ка меньше чем икс точка к
[01:26:29.160 --> 01:26:37.800]  то в этом случае скажи пожалуйста даша в какую решить никого в какую сторону мы идем если у
[01:26:37.800 --> 01:26:49.400]  меня ка меньше чем икс к если скома и меньше чем узел то мы идем вправо вроде не находится все
[01:26:49.400 --> 01:26:58.680]  элементы меньше меньше находится слева лево но у меня ка меньше чем икс к лево то есть мы идем
[01:26:58.680 --> 01:27:15.600]  влево и поэтому здесь мы вызываем ритор возвращаем поиск от икс точка левт и моего ключа к
[01:27:15.600 --> 01:27:38.560]  вот иначе возвращаем поиск от икс точка райд и к ну иначе мы идем вправо но нам не
[01:27:38.560 --> 01:27:46.800]  нужен else получается почему если вдруг а если ка больше икс к а мы а если просто
[01:27:46.800 --> 01:28:03.920]  ритор будет какой а ну ладно я так вот ставил да кстати после риторного вставить а если вы
[01:28:03.920 --> 01:28:11.720]  хотите можете писать здесь типа икс равно икс левт икс равно икс райд и вот здесь вот вызывать
[01:28:11.720 --> 01:28:20.600]  риторный сёрч от икс и к ну или там может еще по третью слове выхода из слове либо
[01:28:20.600 --> 01:28:24.920]  мы пришли в нулевую вершину то есть вот представьте ну нет у меня здесь пятерки
[01:28:24.920 --> 01:28:31.520]  предположим был бы он бы пришел к четыре а четыре мне нужно было бы пойти вправо но тут на
[01:28:31.520 --> 01:28:43.120]  вот то есть у него у 4 икс райд нал правильно это нал если у меня нал то такого не существует
[01:28:43.120 --> 01:28:51.400]  я возвращаю нулевой указатель либо же надо будет потом проверить там не знаю другую вершину
[01:28:51.400 --> 01:29:08.600]  дешево поиска но на той бинарное дерево другое не может быть пятерка может встать лишь только
[01:29:08.600 --> 01:29:15.440]  вот сюда после четверки к примеру если бы я сказал пятерку но ее нет поэтому я верну нал
[01:29:15.440 --> 01:29:26.960]  либо я верну икс которого будет икс к понятно так еще вопросы есть это сергей а если вот он
[01:29:26.960 --> 01:29:36.040]  войдет вот сюда вот в икс равно нал и зеркер нет икс а он ноль просто вернет да он вернет нал
[01:29:36.040 --> 01:29:44.240]  по тр нулевой указатель а то есть мы указатель окей еще я понял еще раз икс это указатель
[01:29:45.240 --> 01:29:55.480]  а тип серч это указатель на ноду тип серч в плане что он вернет да он указатель на ноду вернет
[01:29:55.480 --> 01:30:07.160]  еще вопроса вот окей я думаю вы понимаете что вот этот вот поиск работает за о
[01:30:09.160 --> 01:30:11.880]  от аж где аж это высота дерева
[01:30:11.880 --> 01:30:24.120]  почему за столько он работает а все очень просто смотрите каждый раз мы спускаемся на
[01:30:24.120 --> 01:30:31.080]  уровень ниже то есть наша глубина увеличивается правильно каждую итерацию рекурсии если каждую
[01:30:31.080 --> 01:30:38.200]  итерацию рекурсии мы увеличиваем глубину глубина максимальная это высота нашего дерева все мы
[01:30:38.200 --> 01:30:51.720]  получили это ограничение ясно вот вопросы есть к этому если он заретернет икс а не
[01:30:51.720 --> 01:30:57.360]  все отмена я все понял еще вопросы есть какие-нибудь чтобы не было такого
[01:30:57.360 --> 01:31:10.280]  но видимо мы правда сегодня будем с бинарными деревья с деревьями да разберемся тогда тогда
[01:31:10.280 --> 01:31:18.000]  давайте так сейчас перерыв 10 минут до 17 40 вот после этого продолжим хорошо а какая у нас
[01:31:18.200 --> 01:31:28.400]  должна была быть типа сорт которая да вот ну расскажем и на следующей лекции очень страшно
[01:31:28.400 --> 01:31:36.080]  а получается нам после выполнения алгоритма нужно дополнительно проверять что у нас
[01:31:36.080 --> 01:31:45.960]  серч вернул либо нутер либо необходимую ноду да да конечно так почти все серчи работают все
[01:31:46.440 --> 01:31:52.680]  они возвращают либо нулевой тратор либо там куда-то непонятно либо что-нибудь еще ну вы можете
[01:31:52.680 --> 01:32:00.240]  потом посмотреть когда пройдете стельба примете примерно так и дубов так окей давайте тогда с
[01:32:00.240 --> 01:32:07.400]  вами продолжать с поиском элемента мы с вами разобрались что он возвращает тоже разобрались
[01:32:07.400 --> 01:32:13.440]  то есть мы поняли вообще как это вообще все выглядит и так далее давайте теперь тогда разберемся
[01:32:13.440 --> 01:32:23.840]  с вами а что нас еще ждет с этим деревом поиска смотрите есть еще две вещи которые мы
[01:32:23.840 --> 01:32:29.040]  должны с вами разобрать что вообще хранится деревья поиска первое это поиск минимум
[01:32:29.040 --> 01:32:35.640]  поиск
[01:32:35.640 --> 01:32:51.000]  мини мума скажите где лежит самый минимальный элемент в бинарном дереве поиска софия да мы
[01:32:51.000 --> 01:32:59.720]  левый лист самый левый лист то есть нам нужно просто в самый левый край уйти и там будет самый
[01:32:59.720 --> 01:33:05.200]  минимальный элемент это круто тогда давайте с вами сделаем функции минимум
[01:33:05.200 --> 01:33:13.960]  который будет принимать также но дуэйкс но указательная ту ноду и говорить что если у меня
[01:33:13.960 --> 01:33:32.680]  икс левт равно равно но плохо пишу прошу прощения равно но то в этом случае я беру и возвращаю
[01:33:32.680 --> 01:33:48.720]  ритор икс если это не так тогда я беру и возвращаю ритор минимум от икс точка власть
[01:33:48.720 --> 01:33:57.840]  окей он обязан быть по настоящему самым левым он должен быть на последний а если он будет на
[01:33:57.840 --> 01:34:06.760]  последнем уровне но будет не самым левым то есть в бинарном дереве поиска ну то есть если у нас
[01:34:06.760 --> 01:34:16.640]  есть допустим ну приведи мне пример дерева где такое возможно ну допустим 8 потом идут 3
[01:34:19.400 --> 01:34:27.040]  ну и 4 допустим и от 4 идет 2 такое может быть а как такое возможно
[01:34:27.880 --> 01:34:34.320]  или так как 2 меньше чем 3 такого не может быть меньше чем 8 там должно быть ну больше
[01:34:34.320 --> 01:34:44.520]  а понял все правое под дерево больше 8 вот такого быть не может это не бинарное дерево поиска
[01:34:44.520 --> 01:35:01.560]  не бинарное дерево поиска всегда в самом левом а где находится максимум то есть поиск максимум
[01:35:01.560 --> 01:35:16.800]  самым правым поэтому поиск максимума максимум
[01:35:16.800 --> 01:35:24.360]  это следующее что если у меня икс точка райт
[01:35:24.360 --> 01:35:39.240]  в этом случае ритурн икс в противном случае ритурн максимум
[01:35:39.240 --> 01:35:53.120]  икс точка вот это те операции которые мы можем делать просто с бинарным деревом поиска но вопрос
[01:35:53.200 --> 01:35:57.760]  остается еще следующий но я думаю вы понимаете что и то и то работает в среднем за о от аж
[01:36:01.000 --> 01:36:12.680]  ну то есть просто направо идти просто налево идти о о от аж чудесно теперь вопрос к вам
[01:36:12.680 --> 01:36:20.880]  следующий ну как бы да все хорошо в этом плане у нас есть эта штука но у нас есть проблема еще
[01:36:20.880 --> 01:36:26.080]  следующая мы не можем вставлять элементы и удалять это были давайте сейчас разбираться
[01:36:26.080 --> 01:36:35.320]  со вставкой и удалением элементы из нашего узла вот и первое с чем мы разберемся это у нас будет
[01:36:35.320 --> 01:36:48.560]  вставка элемента смотрите если мы вставляем элемент какой-то он должен быть где вставлен
[01:36:48.680 --> 01:36:54.080]  так вы считаете он может заменить какую-то но до которой у нас уже есть
[01:36:56.080 --> 01:37:05.600]  нет почему ну потому что мы не знаем какие элементы слева и справа от нее и поэтому нам
[01:37:05.600 --> 01:37:11.840]  придется все эти элементы перепроявлять и посмотреть можем ли мы туда ставить наш новый
[01:37:11.920 --> 01:37:23.440]  смотрите действительно самом деле здесь вся суть в том что мы вставляем элемент по факту
[01:37:23.440 --> 01:37:31.880]  как новый лист какой-то куда нам необходимо вот это делается достаточно просто и выглядит
[01:37:31.880 --> 01:37:38.720]  следующим образом вот у нас есть сейчас напишем сначала вот здесь поступим так а после чего
[01:37:38.720 --> 01:37:50.800]  разберем это на пример вот у меня есть insert в дерево там т какого-то элемента z вот пусть
[01:37:50.800 --> 01:37:59.480]  узет так как z у меня какая-то новая но да у него есть какой-то кей там равно не знаю в предположим
[01:37:59.480 --> 01:38:17.040]  а вот z точка там райт равно z точка левт ровно но правильно вот то есть у него все его элементы
[01:38:17.040 --> 01:38:22.000]  налевые что делать с парентом я думаю вы тоже догадываетесь он тоже нал необходимого
[01:38:22.000 --> 01:38:27.680]  будет добавить строчку как его подкрепить правильно это не очень сложно вот что я
[01:38:27.760 --> 01:38:36.800]  делаю у меня будет два указателя первые указательная будет и грековинал а икс равен корню
[01:38:36.800 --> 01:38:48.080]  моего дерева корню моего дерева я делаю следующее пока икс неравен ау
[01:38:48.080 --> 01:39:07.440]  делаю следующее игрек равно икс если у меня z кей меньше чем икс кей то в этом случае я
[01:39:07.440 --> 01:39:15.680]  говорю о том что у меня икс равно икс левт я ищу место куда мне ставить з если у него
[01:39:15.680 --> 01:39:25.320]  ключ меньше и то я иду в левое по дереву если ключ больше иначе говорю что икс равно икс
[01:39:27.480 --> 01:39:34.080]  правая по дереву и говорю что а ну хотя ладно давайте напишем что здесь z там
[01:39:34.080 --> 01:39:48.040]  перрент перрент его равен игреку то откуда мы пришли то есть смотрите икс по факту икс о игрек
[01:39:48.040 --> 01:39:59.160]  игрек это та вершина с которой мы пришли то есть это вот это вот финальная вершина от которой мы
[01:39:59.160 --> 01:40:07.360]  будем как раз к ней подтягивать наше з после чего мы делаем что если у меня был игрек равен ал
[01:40:07.360 --> 01:40:14.840]  что это будет означать скажи мне олег пожалуйста чурик как ты считаешь
[01:40:17.840 --> 01:40:21.600]  вот если у меня игрек остался нули вы после этого ваилу то что происходит
[01:40:30.160 --> 01:40:38.160]  включи микрофон только пожалуйста алик включи микрофон да давай как раз у нас и как остался
[01:40:38.160 --> 01:40:47.640]  нули вы по нас икс с самого начала оказался равен нулю так это значит то что у нас пустой
[01:40:47.640 --> 01:40:56.400]  дерево пустой да то есть это пустое дерево нас с вами тогда у нас получается что корнем этого
[01:40:56.400 --> 01:41:05.800]  нового дерева когда мы вставляем у меня должен оказаться z все иначе ну sorry у меня здесь не
[01:41:05.800 --> 01:41:21.440]  хватает места я продолжу здесь иначе else else и если у меня z кей меньше чем игрек то в этом
[01:41:21.440 --> 01:41:33.680]  случае у меня игрек левый равен z то есть если z кей меньше чем игрек то это в левую часть
[01:41:34.680 --> 01:41:43.520]  а иначе иначе вопросы как мы можем сравнить число и указатель и игреки хорошо да спасибо
[01:41:43.520 --> 01:41:46.440]  греки так лучше
[01:41:51.040 --> 01:42:03.840]  хорошо и теперь иначе мы говорим что игрек райт равен z вот
[01:42:03.840 --> 01:42:12.120]  у нас как бы по стандарту если два числа равны то он идет в правый век
[01:42:12.120 --> 01:42:29.480]  вопрос еще есть то есть смотрите еще раз что мы делаем давайте
[01:42:29.480 --> 01:42:37.160]  предположим пусть у меня есть какое-то дерево как это вообще выглядит давайте
[01:42:37.160 --> 01:42:46.040]  сейчас придумаем какой-нибудь другое дерево которое у нас есть не знаю 12 здесь у меня там
[01:42:46.040 --> 01:42:57.120]  не знаю 3 здесь у меня там в левом значит 1 здесь у меня там 4 здесь у меня там 13 у
[01:42:57.120 --> 01:43:12.680]  него здесь есть под дерево 12 здесь у меня там 16 я хочу вставить а элемент 11 элемент 11 я хочу
[01:43:12.680 --> 01:43:22.640]  сюда вот доставить я его должен ставить ой 12 извините 12 13 давайте здесь делаем 10 так чтобы
[01:43:22.640 --> 01:43:31.200]  нас не было одинаково просто 10 я хочу ставить 11 мне его нужно подцепить вот к этому я в начале
[01:43:31.200 --> 01:43:39.560]  своим иксом прохожусь и дохожу сначала направо потому что 11 больше 10 потом налево потому что
[01:43:39.560 --> 01:43:48.840]  11 меньше 13 здесь 12 говорю что у меня икс стал равен нал вот здесь вот но игрек остался 12 то
[01:43:48.840 --> 01:43:54.360]  есть мы игрек сохраняем в этом плане вот у меня остался игрек равный 12 и к нему необходимо
[01:43:54.360 --> 01:44:03.240]  что-то подцепить и вот я подцепляю этот элемент 11 вот так он становится в моем деле вот это то
[01:44:03.240 --> 01:44:10.720]  что касается вставки возможен следующий момент что у вас будет не совсем дерево такая цепочка
[01:44:10.720 --> 01:44:17.600]  вот из-за таких вот инсерта как это будет выглядеть это будет выглядеть примерно следующий представьте
[01:44:17.600 --> 01:44:28.120]  мы вставили сначала единицу потом мы вставили двойку потом мы вставили тройку потом четыре и
[01:44:28.120 --> 01:44:38.760]  так далее то есть в этом случае моё дерево это по факту такая цепочка грубо говоря если вы
[01:44:38.760 --> 01:44:49.200]  хотите понимать что это как это выглядит ну это такой вот список линей и все вот и здесь высота
[01:44:49.200 --> 01:44:56.280]  дерева равна всем ну количество элементов поэтому здесь будет грубо говоря инсерт нам необходимо же
[01:44:56.280 --> 01:45:06.920]  дойти до самого края и сёрт всегда работает за от аж но вот в этом случае аж равно
[01:45:12.600 --> 01:45:16.920]  потому что мы будем все время вставлять там дальше дальше дальше дальше дальше наши
[01:45:16.920 --> 01:45:25.560]  элементы так далее вот то есть возможен случай бинарных деревьев поиска в наивных бинарных
[01:45:25.560 --> 01:45:31.640]  деревьев поиска мы просмотрим с вами еще потом другие когда у нас будет такая вот длинная длинная
[01:45:31.640 --> 01:45:47.840]  цепочка ясно вот можно предыдущий слайд пожалуйста можно конечно есть ли еще вопросы к вставке элемента
[01:45:47.840 --> 01:46:01.160]  вопрос а вот вы в вайле написали условия и пока икс не нулевой указатель да но это
[01:46:01.160 --> 01:46:08.960]  как будто мы дошли до 100 да так если мы хотим ставить элемент за мне он же не обязательно будет
[01:46:08.960 --> 01:46:28.260]  листом почему он всегда будет листом он всегда вставляется к листу а почему а почему он
[01:46:28.260 --> 01:46:43.900]  обязательно лист как ты думаешь может ли быть он не лист смотри ну дерево бинарное там 7 давай
[01:46:43.900 --> 01:46:51.580]  предложи мне дерево в который я не могу вставить мне листов хорошо от меня дерево 7 слева 6 правого 8
[01:46:51.580 --> 01:47:02.220]  потом из 6 идет 8 четверка я например хочу ставить а просто вправо пойдем то пятерку
[01:47:02.220 --> 01:47:10.500]  вот сюда буду вставлять на у меня будет ну как бы полу лист такой я не знаю смотрите только не
[01:47:10.500 --> 01:47:21.660]  сюда же а если у меня вот вместо восьмерки будет десятка я хочу ставить восьмерку десятка
[01:47:21.660 --> 01:47:31.540]  я хочу ставить восьмерку я дойду до 10 сюда ставлю 8 она все я понял то есть еще раз эти
[01:47:31.540 --> 01:47:39.580]  элементы которые мы вставляем они всегда будут листами это правда можно еще раз пояснить при
[01:47:39.620 --> 01:47:48.580]  пятерку про пятерку но она вот сюда вставится ой не сюда она ставится справа 4 вот сюда вставится
[01:47:48.580 --> 01:48:00.580]  пятерку спасибо и илликсандрич а вот мы структуре которая общая информация о дереве храним получается
[01:48:00.580 --> 01:48:08.460]  адрес корня и что еще глубину там можете хранить что вам нужно если вам нужен сайс постоянно сайс
[01:48:08.460 --> 01:48:15.540]  если он нужен постоянно глубина то глубину но только надпись как глубину типа при всех вот
[01:48:15.540 --> 01:48:23.340]  этих вот модернизациях консерта и так далее правильно считать но по факту там главный
[01:48:23.340 --> 01:48:36.460]  у любого дерева самое главное что еще раз глубину наверное удобно в ноге хранить смотрите
[01:48:36.460 --> 01:48:47.380]  глубина относится к узлу высота относится к дереву не путайте эти понятия глубина это там
[01:48:47.380 --> 01:48:57.860]  где находится сейчас наши наш узел это мы количество ребер от корня до этого элемента до этого узла
[01:48:57.860 --> 01:49:05.980]  вот это глубина высота дерева это максимальный вот этот вот сколько у нас максимум этих
[01:49:05.980 --> 01:49:18.260]  ребер может быть вот глубина смотрите глубина здесь для восьмерки это два глубина именно для
[01:49:18.260 --> 01:49:28.820]  восьмерки для десятки у меня глубина один а вот высота всего дерева высота вот этого всего
[01:49:28.820 --> 01:49:37.340]  дерева криво нарисовал высота всего дерева 3 и возможен такой случай говорю при вставке вот
[01:49:37.340 --> 01:49:42.700]  тем образом который мы делаем вставляем возможен такой случай что мы будем постоянно идти в правое
[01:49:42.700 --> 01:49:55.420]  дерево к примеру там 1 2 3 4 и так далее тогда в этом случае у нас глубина будет равна n
[01:49:58.820 --> 01:50:03.820]  глубина высота извиняюсь я уже сам начинаю заговорить высота n
[01:50:07.580 --> 01:50:16.500]  а вот глубина каждого элемента вот корня 0 2 единичка тройки 2 4 3 поймите вот эту
[01:50:16.500 --> 01:50:22.540]  всю разницу между глубиной высотой дерева высота дерева к дереву глубина к узлу все
[01:50:22.540 --> 01:50:32.260]  еще вопросы есть какие-нибудь вставки чему в левом примере высота будет 3 высота будет 3 вот
[01:50:32.260 --> 01:50:41.700]  у меня самый длинный путь который есть сколько здесь у меня а первый а все понятно 2 3 3 ребра
[01:50:41.700 --> 01:50:51.060]  правым высота будет не n минус 1 что еще раз правым высота не n минус 1 n я имею в виду
[01:50:51.060 --> 01:50:58.300]  количество элементов н минус 1 же будет а да ладно правда да спасибо
[01:51:03.420 --> 01:51:13.340]  а так там вопрос в чате как ставить элемент который равен одному из листов он будет
[01:51:13.340 --> 01:51:19.380]  левым или правым смотрите еще раз с равными элементами в зависимости от того как вы делаете
[01:51:19.420 --> 01:51:25.020]  свою структуру если описывать элементы как мы делали здесь то все элементы равны будут
[01:51:25.020 --> 01:51:32.460]  идти вправо но бинарное дерево поиска она создана для того чтобы искать элементы но
[01:51:32.460 --> 01:51:38.300]  дерево поиска вот поэтому там не вставляется просто так элементы одинаковые только если
[01:51:38.300 --> 01:51:47.100]  какая-то прям сильная надобность в этом есть вот и все еще вопросы есть какие-нибудь
[01:51:47.100 --> 01:52:02.140]  хорошо и тогда у нас последний пункт с бинарными деревьями поиска это удаление элемента запишите
[01:52:02.140 --> 01:52:20.300]  себе пожалуйста удаление удаление элемента узла нам необходимо удалить какой-то элемент по
[01:52:20.300 --> 01:52:27.260]  какому-то ключу примеру с черчем вы нашли это ну вот своим файлом который у вас был вы нашли
[01:52:27.340 --> 01:52:36.620]  какой-то элемент теперь нам нужно его взять удалить здесь может быть несколько вещей когда нам
[01:52:36.620 --> 01:52:42.620]  нужно что-то удалить несколько вариантов которые нам надо будет рассмотреть смотрите давайте я
[01:52:42.620 --> 01:52:50.220]  вернусь к тому дереву который мы все это время писали вот так у нас там было 8 сейчас
[01:52:50.220 --> 01:53:07.140]  дерево 8 из него исходила тройка стройки сюда единичка из шестерки ой здесь шестерка здесь
[01:53:07.140 --> 01:53:18.180]  у меня был элемент 4 здесь 7 здесь у меня элементы ну чуть-чуть криво вышло ну ладно
[01:53:18.180 --> 01:53:32.700]  давайте 10 здесь у меня был правый сын это 14 и сюда 13 смотрите важные моменты для удаления
[01:53:32.700 --> 01:53:40.980]  первые случаи когда мы удаляем это вершина является этот узел является листом предположим
[01:53:40.980 --> 01:53:46.900]  мы хотим удалить 13 что в этом случае мы должны делать давайте первый случай
[01:53:46.900 --> 01:53:51.060]  удаление листа
[01:53:55.060 --> 01:53:55.660]  места
[01:53:59.220 --> 01:54:06.820]  вот и инородская как вы как ты думаешь вот если мне нужно удалить лист что мне нужно сделать
[01:54:06.820 --> 01:54:18.940]  найти его но я его нашел вот 13 вот его выделил даже просто удалить и сделать указатель нулем
[01:54:18.940 --> 01:54:25.700]  у его родители у его родители нужно сделать просто указатель нулем то есть при удалении листа
[01:54:25.820 --> 01:54:41.660]  мы удаляем но до удаляем но то и после этого у родителя у родителя у родителя
[01:54:46.420 --> 01:54:51.860]  делаем указатель указатель
[01:54:55.700 --> 01:55:09.580]  на налп т на т хорошо второе с листом более-менее просто то здесь не сложно что будет если мы
[01:55:09.580 --> 01:55:15.740]  будем удалять лист мы просто его берем удаляем говорим что у родителей больше нет сына ну как же
[01:55:15.740 --> 01:55:26.540]  так но вот так уж получилось что все у нас теперь элемент здесь элемент здесь вот такой теперь
[01:55:26.540 --> 01:55:34.460]  давайте с вами рассмотрим второй случай второй случай удаления это когда давайте здесь сатру
[01:55:36.460 --> 01:55:43.340]  это и второй случай выглядит следующим образом представьте следующее что у этой вершины у этого
[01:55:43.340 --> 01:55:51.300]  узла который мы хотим удалить есть только лишь один сын один ребенок который может быть либо
[01:55:51.300 --> 01:56:06.340]  левым либо правым это без разницы вот либо левым либо правым либо левым либо правым ребенком и
[01:56:06.340 --> 01:56:15.220]  тогда необходимо будет удалить этого эту вершинку этот узел и перед подвесить все остальные которые
[01:56:15.220 --> 01:56:21.820]  были за ним то есть смотрите если я хочу удалить 14 что я должен сделать я должен сделать следующее
[01:56:21.820 --> 01:56:35.180]  убрать вершину 14 и переподвесить 13 следующим образом вот то есть просто если это был правый
[01:56:35.180 --> 01:56:45.940]  сын для кого-то именно тот узел то правый сын стал тем кем был то есть правым сыном теперь
[01:56:45.940 --> 01:56:55.180]  стала вершина стал узел 13 если было бы то есть два ребенка у 14 мы же не можем сделать два
[01:56:55.180 --> 01:57:01.060]  правых элемента момент до этого случая дойдем это еще один случай то есть тут три случая рассматривается
[01:57:01.660 --> 01:57:06.860]  то есть когда у нас всего всего
[01:57:10.420 --> 01:57:12.020]  один ребенок
[01:57:15.460 --> 01:57:17.980]  просто переподвешиваю просто
[01:57:17.980 --> 01:57:25.740]  переехавшим
[01:57:25.740 --> 01:57:35.780]  то есть здесь достаточно тоже просто мы удаляем эту вершину для родителя этой вершины мы говорим
[01:57:35.780 --> 01:57:44.980]  что теперь у тебя твой сын это другой вот и все твой ребенок любой он может быть и правым и
[01:57:44.980 --> 01:57:50.660]  левым здесь без разницы на самом деле потому что он был всего один значит он такая останется так
[01:57:50.660 --> 01:57:58.620]  как для 10 если 14 было правым правым сыном то все что связано с правым под деревом у него все
[01:57:58.620 --> 01:58:05.540]  больше поэтому здесь мы никак баланс не нарушим когда мы будем удалять его теперь остается самый
[01:58:05.540 --> 01:58:17.220]  такой сложный момент связанный с тем а что делать когда у узла есть два ребенка в этом
[01:58:17.220 --> 01:58:25.420]  случае давайте я его сейчас выделю как-нибудь вот предположим мы хотим удалить 3 что должно встать
[01:58:25.420 --> 01:58:35.940]  на место трех как вы думаете вот давайте я спрошу спрошу льва лев миловарцев вот скажи мне
[01:58:35.940 --> 01:58:43.780]  пожалуйста как ты думаешь что должно встать на место трех если удаляй три возможно должно встать
[01:58:43.780 --> 01:58:59.740]  но единичка мейби единичка а если бы у единички здесь справа было бы вот так давайте чуть-чуть
[01:59:00.740 --> 01:59:13.700]  но смысл в том что да последний правый лист сам в общем в левом по дереве самый правый
[01:59:13.700 --> 01:59:22.300]  листок мне кажется в левом по дереве самый правый лист почему но он не нарушит все
[01:59:22.300 --> 01:59:33.420]  ценности бинарный бинарного дерева и все все наоборот он стоит правый лист и
[01:59:33.420 --> 01:59:41.500]  к крайнему левому листу правого листа добавить вторую ветку ага смотрите а точно ли надо брать
[01:59:41.500 --> 01:59:47.700]  левое дерево или правое поддель здесь есть не важно по сути то мы можем просто сказать ну
[01:59:47.700 --> 01:59:53.860]  вспомнить как у нас происходил обход всех элементов что эти два элемента то есть
[01:59:53.860 --> 01:59:58.580]  само правый элемент из левого по дереву и самый левый исправа по дереву являются оба
[01:59:58.580 --> 02:00:05.580]  сахиги не в обходе от тому моменту который мы удаляем да то есть смотрите вспомните
[02:00:05.580 --> 02:00:11.940]  действительно если вспомнить обход то для того чтобы у нас ничего не нарушилось мне
[02:00:11.940 --> 02:00:21.780]  необходимо здесь вот если я выпишу это в порядке в порядке отсортированном 1 2 3 4 там 6 7 8 ну и так
[02:00:21.780 --> 02:00:28.060]  далее то если я удаляю здесь тройку то на место тройки может встать спокойно либо два либо
[02:00:28.060 --> 02:00:38.740]  четыре мы можем взять либо самый правый лист у левого по дерева либо самый левый лист у
[02:00:38.940 --> 02:00:48.700]  правого по дереву здесь без разницы вот то есть мы просто находим здесь
[02:00:48.700 --> 02:00:53.660]  следующий элемент за удаляемым я буду находить именно справа по
[02:00:53.660 --> 02:01:00.140]  дереву находим следующий элемент за удаляемым и удаляем его и вставляем его на это место
[02:01:00.140 --> 02:01:09.740]  то есть здесь я хочу ставить четверку на это место понятно вот то есть удаление есть вот три
[02:01:09.740 --> 02:01:20.180]  таких случая смотрите для удаления я напишу себе функцию функцию которая называется трансплант
[02:01:20.180 --> 02:01:22.940]  а вот
[02:01:32.940 --> 02:01:46.060]  куда я передам свою дерево у и в у и в это некоторые узлы и я хочу заменить одно под дерево другим
[02:01:46.060 --> 02:01:56.220]  под деревом вот то есть здесь у меня как бы ну я хочу просто заменить у на в вот и все что я
[02:01:56.220 --> 02:02:10.020]  делаю я делаю следующее что если у меня родитель уп и его нету то в этом случае я говорю что это
[02:02:10.020 --> 02:02:16.980]  корень поэтому я здесь просто возьму и переподвешу и скажу что а т рут равновая
[02:02:18.980 --> 02:02:36.380]  вот и начин и начин если у меня у равно у п левт то есть оно является левым сыном то в этом
[02:02:36.380 --> 02:02:49.420]  случае я говорю что у п левт у меня равен в вот и начин если это не так то он является правым
[02:02:49.420 --> 02:03:00.980]  сыном и тогда я говорю что у в райт равно но я просто взял и заменил здесь ну я вставил на
[02:03:00.980 --> 02:03:07.380]  место ув вот и все и последнее что мне нужно сказать что если у меня в не равно
[02:03:08.900 --> 02:03:23.060]  на упр то родитель в равен родителю все у меня есть вот такая вот функция я просто на место у
[02:03:23.060 --> 02:03:40.140]  вставляю в что такое в узел у тоже узел вместо узла у я сделаю узел в что
[02:03:42.140 --> 02:03:51.780]  если пишете на плюсах то еще надо удалить здесь у дилей ту написать а просто есть функции транспорт
[02:03:51.780 --> 02:04:06.820]  где мы нет теперь давайте с вами напишем код для удаления это будет наверное последний
[02:04:07.020 --> 02:04:22.940]  вернуть тогда спрашивайте вопрос если у вас есть зачем последние условия и вы не равняетесь
[02:04:22.940 --> 02:04:31.500]  но потому что если вы равняетесь на ну то есть нулевая вершина мы просто присобачили тогда
[02:04:31.500 --> 02:04:39.020]  у нее нет родителей то есть она не начал не указывать сама вершина по себе бесполезно у
[02:04:39.020 --> 02:04:52.500]  нее нет родителей да а что нам мешает вот нас есть самый какой-то правый элемент левой ветки да или
[02:04:52.500 --> 02:05:01.100]  сам самый левый значение его есть перезаписать это значение только это значение тот элемент
[02:05:01.100 --> 02:05:10.100]  который мы уходим хотим удалить а потом удалить нижний так нет это пока не удаление это просто
[02:05:10.100 --> 02:05:18.420]  просто мы в в запихали по факту то что ты сказала мы сделаем но только надо понять
[02:05:18.420 --> 02:05:23.780]  какой что это именно тот случай поймите что нас в одной функции рейс должно быть
[02:05:23.780 --> 02:05:31.980]  все три случая рассмотрено понятно да все вы записали это
[02:05:35.540 --> 02:05:45.300]  надеюсь туда окей тогда давайте с вами продолжать а теперь сама функция рейс рейс
[02:05:45.300 --> 02:05:54.860]  я уже знаю какую я именно удаляю ну то есть за это сама уже но до этого дерева если вам
[02:05:54.860 --> 02:06:00.900]  нужно сначала найти а только потом удалить то вы сначала пишите сёрч то есть поиск свой ну или
[02:06:00.900 --> 02:06:09.660]  файн назовите и потом вы только ее удаляется вот рейс мы сделаем следующим образом если у меня
[02:06:09.660 --> 02:06:21.060]  зед левая часть зед левт равно нау то в этом случае я что делаю у него нет левого сына тогда
[02:06:21.060 --> 02:06:31.340]  мне нужно что взять заменить просто саму зед на вершину которая является его правым ребенком то
[02:06:31.340 --> 02:06:47.700]  есть т трансплант от т зет и на его место на место сет я пишу за трайд просто правую вершину
[02:06:47.700 --> 02:06:58.620]  если у него нет левого ребенка иначе если у зед
[02:07:01.420 --> 02:07:11.220]  смотрите в зет левт равно нау в ходе также и лист лист тут это тоже сделано
[02:07:11.220 --> 02:07:20.860]  потому что у него нет левого ребенка правильно правильно то есть я вставил если что сюда нал
[02:07:20.860 --> 02:07:27.780]  зет райт у меня нал именно поэтому у него родителей нету нау именно поэтому в трансплант было написано
[02:07:27.780 --> 02:07:38.780]  тот и вот если у зет есть правый ребенок ой точнее нету правого ребенка то в этом случае я делаю
[02:07:38.780 --> 02:07:56.300]  трансплант т зет и зет левт левой то есть если нет правого ребенка тогда я левую просто
[02:07:56.300 --> 02:08:07.620]  подвешиваю туда еще раз а вот теперь нам необходимо сделать следующее иначе иначе мы с вами говорим
[02:08:07.620 --> 02:08:15.900]  о том что нам необходимо взять и найти наш минимум у этого правого по дереву то есть смотрите
[02:08:15.900 --> 02:08:24.220]  мы берем самый левый самый левый лист нашего правого по дереву поэтому здесь достаточно сказать
[02:08:24.220 --> 02:08:39.420]  что иначе я делаю так игре кровно минимум вот вот чего вот
[02:08:45.420 --> 02:08:50.780]  если у нас есть два ребенка от зет то есть корнем того под дерево правого является
[02:08:51.380 --> 02:08:58.860]  и в нем я пытаюсь найти минимум я нахожу этот минимум и говорю что если у меня у
[02:08:58.860 --> 02:09:12.260]  игреков родитель не равен z то есть он где-то дальше чем за это вообще сильно то я делаю
[02:09:12.260 --> 02:09:26.940]  трансплант трансплант своего дерева игрек и игрек райт я сначала его должен переподцепить
[02:09:26.940 --> 02:09:36.460]  почему потому что у самого левого листа может быть правый ребенок у самого левого вот это вот
[02:09:37.060 --> 02:09:46.460]  то есть смотрите минимум это не совсем лист если у меня есть вот такое вот дерево вот такое
[02:09:46.460 --> 02:09:57.020]  к примеру то минимум вот это число давайте еще раз вот здесь пусть будет 5 4 2 а здесь 3
[02:09:57.020 --> 02:10:08.140]  минимум это вот это тогда я перецепляю его право ребенка правый ребенок после чего я
[02:10:08.140 --> 02:10:17.580]  делаю я делаю этот трансплант я говорю что у меня игрек райт равно зет райт
[02:10:17.580 --> 02:10:27.740]  когда я уже переподцепил все и игрек райт
[02:10:27.740 --> 02:10:32.620]  п равно игрек
[02:10:37.380 --> 02:10:46.620]  вот и мне осталось еще сделать немножко действий здесь а что если оно игрек z является родителем то
[02:10:46.660 --> 02:10:55.460]  смотрите у меня здесь немножко больше действий я сначала переподцепляю у игрека правое под дерево
[02:10:55.460 --> 02:11:02.380]  я его переподцепил после этого беру и говорю что у меня это запихивается еще в z правый ребенка
[02:11:02.380 --> 02:11:19.380]  з дальше я пишу здесь трансплант от чего как вы думаете ты z и игрек теперь на место z я уже
[02:11:19.380 --> 02:11:28.780]  записываю игрек вот и дальше мне нужно написать здесь еще две строчки к сожалению не могу здесь
[02:11:29.220 --> 02:11:35.340]  то есть смотрите этот трансплант он после ифа то есть этот в этот иф не входит и вот здесь вот
[02:11:35.340 --> 02:11:49.220]  еще две строки две строки следующие игрек левт у меня равен зет левт и игрек левт
[02:11:49.220 --> 02:12:03.180]  райт равен игрек все есть ли вопросы почему так что происходит и как так вышло давайте еще
[02:12:03.180 --> 02:12:10.580]  раз по строчкам что такое игрек можно еще раз игрек это минимальный элемент самым правым под
[02:12:10.580 --> 02:12:14.820]  деревьем самый минимальный элемент правом под деревьем который мы можем безопасно вставить
[02:12:14.820 --> 02:12:24.620]  наше дерево вот он например или если мы смотрели мы смотрели на вот это дерево здесь для тройки то
[02:12:24.620 --> 02:12:31.060]  вот эта четверка это как раз этот минимум мы самое левое пошли на эти самые левой такой кусочек
[02:12:31.060 --> 02:12:40.620]  есть ли вопросы можешь тоже с графом это визуализирует вот последний else еще раз это
[02:12:40.620 --> 02:12:48.820]  с графом просто так ну да ну то есть смотрите давайте хорошо с последним графом вы имеете
[02:12:48.820 --> 02:12:58.140]  в виду а я понял последний else именно да да да тяжел давайте еще раз это порисуем вот у
[02:12:58.140 --> 02:13:04.860]  меня есть тройка вот у меня есть четверка правильно у четверки parent это 6 да
[02:13:04.860 --> 02:13:15.740]  вот что я делаю я вместо четверки я же ее переподвешиваю я делаю трансплант y и y правого
[02:13:15.740 --> 02:13:23.140]  y правого меня на поэтому я просто по факту эту вершину отцепляю ничего с ней не делаю то есть
[02:13:23.140 --> 02:13:33.220]  если здесь смотреть то я просто сейчас момент то я просто удаляю вот эту связь по-хорошему то есть
[02:13:33.220 --> 02:13:39.980]  у меня осталось это четверка где-то здесь теперь нал находится и говорю что у игрека вот у этого
[02:13:39.980 --> 02:13:53.900]  игрека правый равен z правому то есть вот этот кусочек и у правого сына z родителем теперь
[02:13:53.900 --> 02:13:59.620]  является игре то есть я беру и переподвешиваю это так что у меня теперь четверка вот где-то
[02:13:59.620 --> 02:14:09.860]  здесь она пока морфин существует она вот так вот делает после этого я делаю замену z и y я их
[02:14:09.860 --> 02:14:17.620]  меняю местами то есть я беру и теперь у меня восьмерка переподвешенные сюда смотрит единичку
[02:14:17.620 --> 02:14:29.860]  так вот и у игрека я переподвешиваю левой то есть единичку подделываю и говорю что у
[02:14:29.860 --> 02:14:44.780]  левого теперь родитель это четверочка все стало понятнее или нет так еще вопросы то есть я правильно
[02:14:44.780 --> 02:14:58.580]  понял что мы просто самый маленький лист правой ветви переставляем самый маленький элемент правой
[02:14:58.580 --> 02:15:11.860]  ветви вставляем а вопрос а почему мы не можем просто левую ветвь подвесить к минимуму правой
[02:15:11.860 --> 02:15:20.660]  ветви и просто правого ветвь ну собственно поставить место удаленного еще раз можно почему
[02:15:20.660 --> 02:15:30.180]  мы не в нашем случае а я кажется понял шестерку мы не можем просто взять теперь подвесить да
[02:15:30.180 --> 02:15:40.980]  потому что 4 непонятно куда встанет они у нас в этом случае наверное мы можем прийти подвесить
[02:15:40.980 --> 02:15:54.180]  ветвь 1 2 к четверке слева а шестерку подвесить к 8 это сильно больше действий это не ну здесь
[02:15:54.180 --> 02:16:00.660]  в конкретном случае можем но только это увеличит количество действий типа неистово а что в общем
[02:16:00.660 --> 02:16:18.340]  случае делать ну то же то есть мы просто берем получается с этого подвешиваем к минимуму от
[02:16:18.340 --> 02:16:44.940]  а я понял о чем-то правильно 1 2 4 а вот потом всю эту конструкцию вместо тройки да смотри то
[02:16:44.940 --> 02:16:51.700]  что ты пытаешься сделать называется ты пытаешься перед переделать это все во второй случай когда
[02:16:51.700 --> 02:16:59.100]  у верши нету ни левого ни правого сына если ты переподвесишь да ты получишь просто 2 случай
[02:16:59.100 --> 02:17:12.140]  удаления при подвесить можно попробовать только случайно может тоже сильно запутаться можно
[02:17:12.220 --> 02:17:16.420]  потому сначала минимум потом туда запихать потом все еще переделать
[02:17:16.420 --> 02:17:28.340]  понятно и она может немножко нарушить саму конструкцию твоего дерева вот и все ты просто
[02:17:28.340 --> 02:17:35.060]  таким образом берешь и кремляешь свое дерево еще больше а если ты его выпрямляем то все долго
[02:17:36.060 --> 02:17:48.060]  высота увеличивается ну да высоту мы просто типа искусственно зачем-то увеличить так вот
[02:17:48.060 --> 02:17:54.100]  глянуть конечно можно повторить про что такое трансплент трансплент он просто меняет он на
[02:17:54.100 --> 02:17:58.660]  место вот здесь вот у меня написано z это за трайд он на место z записывает за трайд и
[02:17:58.660 --> 02:18:08.620]  переподвешивает все вот еще вот что такое t это дерево это дерево у которого есть как минимум
[02:18:08.620 --> 02:18:19.300]  корень все давайте еще раз типа по строчкам рейса ну типа просто что происходит первые
[02:18:19.300 --> 02:18:25.140]  первые две строчки вот это вот типа за плев трансплент и трансплент рассматривают
[02:18:25.140 --> 02:18:35.060]  случаи когда у узла z нет левого или правого дочернего узла нет у него ребенка если у него
[02:18:35.060 --> 02:18:40.620]  нет ребенка то есть это может быть и лист это может быть и без одного ребенка и так далее вы
[02:18:40.620 --> 02:18:47.700]  просто должны взять и переподвесить трансплент просто берет и переподвешивает вот что касается
[02:18:47.700 --> 02:18:54.860]  строчек 512 ну вот типа вот этих вот минимумы и гриппэ и гриппз это так далее смотрите мы
[02:18:54.860 --> 02:19:04.380]  первоначально смотрим является ли игрек нашим является ли игрек ребенком z то есть у игрек
[02:19:04.380 --> 02:19:12.300]  пэ ну перрент игрек это з если это не так то нам необходимо взять и все еще переподвешивать
[02:19:12.300 --> 02:19:19.740]  если же это будет так то нам необходимо всего один раз взять и переместить туда элемент так
[02:19:19.740 --> 02:19:30.780]  как мы удаляем по факту два элемента если у игрека грубо говоря если мы вместо z подставляем
[02:19:30.780 --> 02:19:39.580]  игрек он является сыном игре сыном за и он является самым левым заметьте самым
[02:19:40.020 --> 02:19:46.420]  всех возможным то мы просто должны его поставить на его место а вот если он не является сыном
[02:19:46.420 --> 02:19:52.660]  находится где-то далеко то нам необходимо взять и переподвесить еще больше то есть
[02:19:52.660 --> 02:19:55.900]  пэ это пэрн да это пэрн все правильно
[02:20:04.540 --> 02:20:05.540]  еще вопросы есть
[02:20:12.300 --> 02:20:19.940]  смотрите по факту рэс работает за у от аж потому что трансплент работает за у от единицы вот все
[02:20:19.980 --> 02:20:27.700]  работает просто за у от единицы но переподвешивание то есть нам необходимо ну здесь абсолютно все
[02:20:27.700 --> 02:20:33.660]  вот эти у штуки вот трансплент трансплент вот здесь вот сравнение трансплент и здесь какие-то
[02:20:33.660 --> 02:20:40.020]  переподвешивания это все за от единички единственное что дает нам здесь сложности алгоритма это вот
[02:20:40.020 --> 02:20:47.140]  поиск вот этого минимума поэтому в этом случае мы говорим о том что рэс работает за о от аж
[02:20:47.140 --> 02:20:49.780]  ясно
[02:20:53.340 --> 02:21:00.780]  вот есть ли еще какие-нибудь вопросы к бинарным деревьям поиска мы с вами хотя бы закончили
[02:21:00.780 --> 02:21:09.100]  что радует чтобы поиск минимум не работал за от нужно периодически просто перемешивать
[02:21:09.100 --> 02:21:16.420]  наши дерево не совсем нужна будет сбалансирована с дерева об этом поговорим через лекцию хорошо
[02:21:17.900 --> 02:21:24.220]  мы поговорим про сбалансированные деревья что это вообще такое да там нужно будет балансировать их
[02:21:26.220 --> 02:21:31.900]  вот и все бывает смысл менять корень дерева чтобы у нас у нас
[02:21:31.900 --> 02:21:40.260]  по одному вопросу сначала антонио был у нас есть смысл иногда но менять корень
[02:21:40.820 --> 02:21:50.940]  смотрите для того чтобы у нас асимптотика улучшалась то есть аж улучшалась используется
[02:21:50.940 --> 02:22:00.420]  сбалансированные деревья поиска это отдельная штука там не просто корень меняется там правильно
[02:22:00.420 --> 02:22:07.900]  все подвешивается и там корень действительно может немножко так все время вилять вот если
[02:22:07.900 --> 02:22:17.580]  будет рандомно просто корень менять не сильно выигрыш во время какой еще вопрос у нас в контесте
[02:22:17.580 --> 02:22:23.340]  вы только бинарные деревья в этом контесте да будут только бинарные деревья обычно не
[02:22:23.340 --> 02:22:31.780]  сбалансированные следующие сбалансированные они всегда будут всегда будут бинарные правда вот
[02:22:31.780 --> 02:22:39.460]  единственное в предыдущем контесте что у нас там в предыдущем контесте были задач
[02:22:39.460 --> 02:22:44.940]  которые по факту тоже это надо полный перебор было делать и там было уже не бинарные мирные
[02:22:44.940 --> 02:22:50.740]  ферзии да мирные ферзии там по факту надо было и аннарные деревья строить рекурсивный
[02:22:50.740 --> 02:22:59.260]  обычная рекурсия там рекурсия которая все писали в задании спойлер типа мистово много
[02:22:59.260 --> 02:23:05.420]  строчек кода решается каждая задача не больше 40 строчек нам нужно было понять
[02:23:05.420 --> 02:23:10.140]  какая делается рекурсия перекрестной или обычной как это считается
[02:23:13.700 --> 02:23:19.980]  не нужна была там не нужны были там деревья но не нужны если вы усложнили себе так жизнь
[02:23:19.980 --> 02:23:27.860]  хорошо вопрос 40 строчек даже электронные часы но нет электронные часы надзейфать было
[02:23:28.100 --> 02:23:35.060]  да я имею в виду обязательные задачи обязательные задачи кроме всяких реализации тэка дэк
[02:23:35.060 --> 02:23:44.460]  и так далее там надо было просто подумать то там просто чисто вот смотрите у вас в контесте будет
[02:23:44.460 --> 02:23:53.220]  который воскресенье мы пришел в 10 утра у вас там будет еще задачи на хипсорп про пирамиды
[02:23:53.220 --> 02:23:55.860]  пирамиды мы с вами рассмотрим на следующем занятии
