[00:00.000 --> 00:21.120]  Следующий пункт называется EnableSharedFromThis Да, смотрите, есть следующая проблема.
[00:21.120 --> 00:28.840]  Когда у вас есть какой-то класс, и вы хотите вернуть из метода этого класса указатель на него,
[00:28.840 --> 00:34.760]  вот вы хотите сделать, типа, return this кому-то, сказать. А 12.4 у нас что было?
[00:34.760 --> 00:51.200]  UQPTR. Make shared. Вот, у вас есть какой-то класс. Вы перешли и все, наступило светлое будущее,
[00:51.200 --> 00:59.400]  и теперь все указатели у вас умные. Нету стишных пойнтеров вообще, вы пользуетесь только shared.ptr
[00:59.400 --> 01:08.480]  и UQPTR, как и хотел Strausdrup. Но у вас есть this еще. Вот если вы имеете дело с указателем на
[01:08.480 --> 01:16.360]  текущий объект, и этот указатель хотите куда-то передать, ну вот вы такие пишете метод класса,
[01:16.360 --> 01:22.440]  и хотите куда-то вернуть this указатель на текущий объект, у вас возникает проблема,
[01:22.440 --> 01:28.400]  потому что этот сишный указатель, а если до этого вы имели дело только с shared.ptr,
[01:28.400 --> 01:39.760]  вы кому-то отдадите сишный указатель, то он просто не сможет его принять. У вас все указатели теперь
[01:39.760 --> 01:45.000]  shared. Если вы кому-то отдадите сишный pointer, а примет он его как shared.ptr, то у вас будет
[01:45.000 --> 01:49.920]  двойное удаление опять, потому что вы создадите таким образом вторую ветку shared.ptr на то же самое.
[01:49.920 --> 01:58.600]  То есть вы не можете возвращать this в чистом виде, вы должны shared.ptr на себя возвращать,
[01:58.600 --> 02:04.880]  чтобы кто-то им дальше там пользовался в какую-то функцию, если хотите передать. Но и написать
[02:04.880 --> 02:11.000]  return shared.ptr от this вы не можете, потому что вы опять получится создадите вторую ветку shared.ptr
[02:11.000 --> 02:16.600]  на то же самое. Короче, если вам надо создать shared.ptr от себя, вот вам нужно сделать
[02:16.600 --> 02:27.640]  вернуть this как shared.ptr, что вам надо сделать? Как это сделать вообще внутри своего собственного класса?
[02:27.640 --> 02:42.440]  Ну это близко. Есть стандартное решение для этого. И для этого существует такой библиотечный класс
[02:42.440 --> 02:54.680]  называется enable shared from this. Решение заключается в следующем. Вы просто пишете,
[02:54.680 --> 03:14.120]  ну, у меня там есть какой-нибудь класс, и я говорю, что это публичный наследник. Не публичный,
[03:14.120 --> 03:17.640]  на самом деле. Я могу сказать, что это приватный наследник, потому что никому особо не надо
[03:17.640 --> 03:42.680]  знать, что я наследник. Публичное наследование, вы говорите, что я частный случай того, и каждый
[03:42.760 --> 03:48.360]  может этот факт использовать. При варпинг наследовании вы говорите, что вы ничего не говорите, вы лишь
[03:48.360 --> 03:54.440]  используете методы поля того в себе, но другим рассказ не хотите о том, что вы их используете.
[03:54.440 --> 04:04.720]  Публичное наследование это значит, что каждый может вызывать методы родителя у вас, когда вы
[04:04.720 --> 04:12.720]  наследник. Так вот, ну давайте я скажу что-то private на самом деле, enable shared from this,
[04:12.720 --> 04:23.280]  потому что не подразумевается, что кто-то должен вызывать. Ну, protected, ладно.
[04:23.280 --> 04:43.360]  std enable shared from this с шаблонным параметром c.
[04:53.360 --> 05:05.600]  Что, я создал класс c, наследник enable shared from this с шаблонным параметром c.
[05:05.600 --> 05:12.480]  Чтобы уметь возвращать shared ptr на себя.
[05:12.480 --> 05:40.400]  Как это вообще работает, да. Вот это называется
[05:40.400 --> 06:10.120]  CRTP. Сейчас я расшифрую. Curiously recursive template pattern. У такого решения есть
[06:10.120 --> 06:15.960]  название, это такой паттерн проектирования объекта ориентированное, вот он называется
[06:15.960 --> 06:23.480]  CRTP. Curiously recursive template pattern. Когда вы делаете класс, наследник другого шаблонного класса
[06:23.480 --> 06:31.160]  шаблонным параметром ваш собственный класс. Почему это корректно работает? Потому что, что по
[06:31.160 --> 06:38.600]  сути означает, что вы инстанцируете вот это с шаблонным параметром вас. Это означает просто,
[06:38.600 --> 06:44.680]  что компилятор генерирует код, формально подставив туда вместо шаблонного параметра это.
[06:44.680 --> 06:52.680]  Но если при этом там не объявляется нигде объект вас, а объявляется лишь указатель на вас, то в этом
[06:52.680 --> 07:21.000]  принципе, ну это нормально, ничего страшного. Вот. Нет, оно само по себе работает. В смысле
[07:21.000 --> 07:31.000]  наследование себя от чего-то шаблонного с шаблонным параметром вы сами, это нормально. Просто. Это
[07:31.000 --> 07:42.640]  нормально, все так делают. Ну просто компилятор формально подставит это в качестве T туда и
[07:42.640 --> 08:05.440]  сгенерирует соответствующий код. Ну он там понятно, он сгенерирует там. Нет, скорее они
[08:05.440 --> 08:09.760]  формально подставляют, просто если в какой-то момент получается, что действительно ты пытаешься
[08:09.760 --> 08:16.360]  создать объект класса, который не объявлен, то это проблема, да. А указатель на объект класса,
[08:16.360 --> 08:21.080]  который не объявлен, нормально. А, который неопределен, нормально. Который неопределен,
[08:21.080 --> 08:44.440]  это нормально, да. Можем. Ну да. Ну указатель, чтобы знать указатель, тебе не надо знать ни
[08:44.440 --> 08:54.600]  size, ни line, ничего. Указатель, это просто число, разыменование которого дает тебе все. Точно так же,
[08:54.600 --> 09:11.320]  как и ссылку. Ну вот, короче, enableSharedFromThis. Теперь, когда мы от этого наследовались,
[09:11.320 --> 09:19.200]  у нас появился метод sharedFromThis. И чтобы получить, собственно, sharedPtr на себя,
[09:19.200 --> 09:28.240]  нужно просто вызывать этот метод sharedFromThis без параметров. Вот. Вопрос, как реализован enable
[09:28.240 --> 09:43.240]  sharedFromThis. Нет, он хранит weakPtr. Смотрите, enableSharedFromThis, ну давайте попробуем реализовать.
[09:43.240 --> 10:01.840]  Да, если вы уже внутри этого класса, значит, если у вас создался C, то sharedPtr на C уже создался,
[10:01.840 --> 10:27.840]  вот так. Тогда бы у вас не было sharedPtr. Сейчас, на стеке. Мы должны weakPtr создать,
[10:27.840 --> 10:37.960]  от чего? От sharedPtr. Что это за sharedPtr будет внутри enableSharedFromThis? Сейчас подумаем.
[10:37.960 --> 10:55.440]  Сейчас напишу enableSharedFromThis. Нет, пока не научились. Да, пока не научились. И
[10:55.440 --> 11:04.440]  я даже не уверен, что, что-то кажется, мы функции сегодня не успеем. Да, как-то затянулось. Наверное,
[11:04.440 --> 11:09.520]  это из-за того, что у нас доска, и из-за этого замедляется. Вообще, на самом деле, когда две пары,
[11:09.520 --> 11:15.120]  а не одна, но как-то время течет как-то по-другому, и получается, что одна тема рассчитывается на две
[11:15.120 --> 11:20.760]  пары, вместо того, чтобы на одну. Это как-то неоптимально. Вроде пар две, а рассказать успел,
[11:20.760 --> 11:41.760]  как будто одна всего прошла. weakPtr, на T я здесь храню. ВП я не знаю. Давайте подумаем. Как работает
[11:41.760 --> 12:00.720]  sharedFromThis? sharedFromThis просто возвращает вот этот вот VP лог. sharedFromThis, ну, он, наверное,
[12:00.720 --> 12:19.400]  const и возвращает VP.log. Причем, тут возникает вопрос, а что, если там был nullPtr? Ну, в смысле,
[12:19.400 --> 12:24.080]  если он был экспарит, так вот давайте подумаем, может ли он быть экспарит. Для начала давайте
[12:24.080 --> 12:34.480]  поймем вообще, как создается этот веб, чем он инициализируется, кто и в какой момент его
[12:34.480 --> 12:50.480]  инициализирует. Вот главный вопрос, кто и в какой момент инициализирует это weakPtr. Вообще, в какой
[12:50.480 --> 12:59.280]  момент создается enableSharedFromThis? EnableSharedFromThis создается тогда, когда создается C. Создание C
[12:59.280 --> 13:05.280]  начинается с того, что создается enableSharedFromThis. То есть, вот этот вот weakPtr на C сейчас надо
[13:05.280 --> 13:32.880]  чем-то проинциализировать. А чем проинциализировать? Когда что? Когда что просто так создаем? Да, это
[13:32.880 --> 13:46.800]  поле. В какой момент, это никакой не момент, это просто поле класса, вот как здесь написано,
[13:46.800 --> 13:51.000]  ты же не спрашиваешь здесь, что произойдет в этот момент, это никакой не момент, это объявление поля.
[13:51.000 --> 14:00.360]  Так вот, теперь уже вопрос в динамике, что будет происходить. Ну, то есть, когда это все реально
[14:00.360 --> 14:08.560]  начинает создаваться, как это инициализируется? Когда создается enableSharedFromThis? Ну, нам надо
[14:08.560 --> 14:21.200]  написать конструктор enableSharedFromThis, наверное. Или что? Ну как? Вот что надо сделать? Смотрите,
[14:21.200 --> 14:35.880]  я утверждаю, что когда создается enableSharedFromThis, уже должен существовать sharedPtr на то, на что нам надо.
[14:35.880 --> 14:57.560]  Потому что, если мы собираемся, если у нас есть sharedPtr на C, то первичное именно создание
[14:57.640 --> 15:08.680]  sharedPtr на C, а не C. Мы и собираемся возвращать sharedPtr на себя. Это значит, что до этого кто-то нас
[15:08.680 --> 15:17.240]  должен был создать через sharedPtr. Сам класс C и владение им происходит через sharedPtr. То есть,
[15:17.240 --> 15:25.760]  кто-то создал sharedPtr на C, после чего начали вызывать sharedFromThis. Бессмысленно, если у нас
[15:25.760 --> 15:39.760]  бы не было sharedPtr на себя, то sharedFromThis вызывать было бы нельзя. Кого? Правильно,
[15:39.760 --> 15:48.920]  нам нужно, чтобы, если создается sharedPtr на C, мы проинициализировали этот weakPtr правильным
[15:48.920 --> 15:58.880]  sharedPtr. Так вот, на самом деле, нам нужен еще один конструктор sharedPtr. Мы сейчас sharedPtr еще
[15:58.880 --> 16:04.480]  модифицируем снова. Мы сейчас добавим в sharedPtr специальный конструктор, еще один приватный,
[16:04.480 --> 16:14.840]  который будет вызываться в случае, если наш класс это... Ой, я виноват, нам конструктор не
[16:14.840 --> 16:19.960]  потребуется, нам просто if один потребуется в конструкторе. Мы просто в конструктор sharedPtr допишем
[16:19.960 --> 16:45.480]  такую вещь. Если constexpr std isBasedOf t enableSharedFromThis t... Значит, isBasedOf – это метафункция,
[16:45.480 --> 16:51.960]  которая проверяет, является ли один тип наследником другого. Причем неважно публичным
[16:51.960 --> 17:13.920]  или приватным наследником, кстати. Ну, получается так, да. Нет, извне нельзя.
[17:13.920 --> 17:28.320]  Статик кастом из внешней функции нельзя, конечно, да. Вы задаете правильные вопросы,
[17:28.320 --> 17:37.960]  но мы реализуем его в очередь несколько пар. Значит, хорошо, std isBasedOf v, что является базой чего?
[17:37.960 --> 17:52.720]  Ну, значит, isBasedOf. Base derived. То есть сначала пишем базу, enableSharedFromThis – это база.
[17:52.720 --> 18:20.360]  EnableSharedFromThis – это база. EnableSharedFromThis t – это база.
[18:20.360 --> 18:34.760]  А это наследник. Так вот, если это так, то надо вызвать… А то надо что сделать?
[18:34.760 --> 18:50.120]  Кстати, отличный вопрос. Проинцелизировать ВП у чего? У t, у нашего объекта. Вот у того t
[18:50.120 --> 19:02.840]  который… А где мы возьмем t? Ну да, у нас есть указатель на что-то там, на control блок, в котором t…
[19:02.840 --> 19:15.040]  Короче, нам надо просто сказать, что base… Ну, вот этот вот наш блок, стрелочка. Блок, стрелочка, object.
[19:15.040 --> 19:27.120]  Точка ВП. Так, object – это база enableSharedFromThis. Значит, у него есть поле ВП.
[19:27.120 --> 19:32.120]  Ну, а если оно проточено через RETAPCAST? Оно проявляется. Оно уже проявляется, кстати.
[19:32.120 --> 19:42.120]  В минимальном процессе никак вообще. Это вообще беда. Не, можно через RETAPCAST.
[19:42.120 --> 19:47.120]  Ну, может, не надо? Это же код, на который никто никогда не будет смотреть.
[19:47.120 --> 20:14.120]  Да, да, да. Кстати, да. А это поможет? Нет.
[20:14.120 --> 20:24.120]  Да, потому что private, потому что вот это private, оно же с точки зрения C.
[20:24.120 --> 20:30.120]  Ну, то есть это C запрещает нам ходить к своему родителю. Вот, что происходит. Ну, окей.
[20:30.120 --> 20:35.120]  Ну, значит, наверное, здесь public все-таки надо, а не private. А protected-то чем поможет?
[20:35.120 --> 20:47.120]  Нет, shared.ptr – это же не наследник C. Вот я здесь из метода shared.ptr пытаюсь обратиться к полю C,
[20:47.120 --> 20:53.120]  которая от родителя. Ну, shared.ptr – это же не наследник C. Короче, надо public все-таки делать, видимо.
[20:53.120 --> 21:02.120]  Нет, можно, конечно, написать, наверное, template class T, friend class T. Нет, наверное, так нельзя.
[21:02.120 --> 21:08.120]  Все мои друзья… Нет, нет, забудьте, так нельзя. Надо, чтобы shared.ptr был другом этого.
[21:08.120 --> 21:22.120]  Ну, значит public. Как не выбрано поле, object.vp. Почему?
[21:22.120 --> 21:32.120]  Господи. Ну, shared.ptr – это public. Ну, а тут друзьями сделаем, кого надо.
[21:32.120 --> 21:39.120]  shared.ptr и enabled.shared.fromthis – мы их друзьями просто сделаем, это нормально.
[21:39.120 --> 21:53.120]  Ну все, говорим, что вот так. Ну да, видимо, публично все-таки, приватно не получится.
[21:53.120 --> 22:04.120]  Так, понятно, вот эта строчка. Что здесь произошло?
[22:05.120 --> 22:11.120]  shared.ptr. Звездочка this сейчас – это shared.ptr. Мы сейчас находимся в конструкторе shared.ptr.
[22:11.120 --> 22:17.120]  И мы этот week.ptr инициализируем вот с собой, то есть тем shared.ptr, который мы сейчас являемся.
[22:17.120 --> 22:24.120]  Таким образом, этот week.ptr будет инициализирован, как только создастся класс C, потому что создастся enabled.shared.fromthis от C.
[22:24.120 --> 22:39.120]  А он, ну, если, виноват, если создастся shared.ptr на C, то в этот момент уже будет инициализирован вот этот.
[22:39.120 --> 22:49.120]  Во всех, конечно. Ну, то есть, да.
[22:54.120 --> 23:03.120]  Как только, короче, как только создастся shared.ptr на C впервые, сразу же будет инициализирован вот этот вот VP shared.ptr вот этим вот.
[23:03.120 --> 23:06.120]  И таким образом мы сможем через функцию shared.fromthis его получать.
[23:06.120 --> 23:13.120]  А если мы создали C не через shared.ptr, то есть просто создали C, shared.ptr на C не создали, просто создали C,
[23:13.120 --> 23:21.120]  тогда эта штука инициализируется по умолчанию, и тогда вызов shared.fromthis будет кидать исключение.
[23:21.120 --> 23:23.120]  Нормально?
[23:23.120 --> 23:25.120]  У тебя исключение не нормально?
[23:25.120 --> 23:28.120]  Ну, можешь не кидать исключение AOB делать?
[23:28.120 --> 23:30.120]  Может, лучше.
[23:30.120 --> 23:33.120]  Ну, каждому свое.
[23:33.120 --> 23:34.120]  А?
[23:34.120 --> 23:48.120]  А, не кидает исключение, да? Ну, значит, я ошибся, да, значит, не кидает исключение.
[23:48.120 --> 23:50.120]  Ну, хорошо, ну вот.
[23:51.120 --> 23:56.120]  Так, ну что, понятно с enabled.shared.fromthis, и как он реализован?
[23:56.120 --> 24:00.120]  В каждом объекте теперь храним два лишних указательных.
[24:00.120 --> 24:02.120]  В каждом каком объекте?
[24:02.120 --> 24:07.120]  Ну, вот, написано C, в нем лишние два указательных.
[24:07.120 --> 24:09.120]  Ну...
[24:09.120 --> 24:14.120]  Ну, видимо, это не страшно, потому что указатели нужны для того, чтобы как раз-таки не влиять объект,
[24:14.120 --> 24:19.120]  но, значит, объект можно самим сделать тяжелее, еще потяжелее, потом еще немного потяжелее.
[24:19.120 --> 24:21.120]  И скоро мы получим...
[24:21.120 --> 24:23.120]  И скоро мы...
[24:23.120 --> 24:26.120]  Да, и так мы постепенно получаем джаву или питон, да?
[24:26.120 --> 24:28.120]  Да.
[24:28.120 --> 24:32.120]  Сейчас какие-нибудь атрибуты появятся, пишите на джаву или питон.
[24:32.120 --> 24:37.120]  Так, мы постепенно сейчас придем к этому.
[24:37.120 --> 24:39.120]  Я уже, знаете...
[24:39.120 --> 24:42.120]  Значит, короче, не только с твоей стороны идет пропаганда питона,
[24:42.120 --> 24:46.120]  но у нас сейчас параллельно нужно сделать примерно одинаковые проекты по плюсовому питону.
[24:46.120 --> 24:48.120]  Ага, в смысле одинаковые проекты?
[24:48.120 --> 24:51.120]  Вам надо лист с аллокатором на питоне написать?
[24:51.120 --> 24:54.120]  Нет, на языке C++, на ТП.
[24:54.120 --> 24:59.120]  И там просят на языке C++ написать, а у некоторых просят строго на языке.
[24:59.120 --> 25:01.120]  Ну, короче, неважно.
[25:01.120 --> 25:05.120]  И вот сейчас многие люди пишут примерно похожие проекты одновременно близок на питоне,
[25:05.120 --> 25:08.120]  увидят, насколько проще писать их на питоне, и все.
[25:08.120 --> 25:10.120]  Дегаше пропало.
[25:11.120 --> 25:19.120]  Так, давайте следующим пунктом и последним в этой теме, наверное, на этот раз обсудим
[25:19.120 --> 25:25.120]  самое болезненное, наверное, что связано с shared PTR.
[25:25.120 --> 25:28.120]  Ну, как бы, все, что помещено красным, все боль.
[25:28.120 --> 25:31.120]  Но это еще не такая большая боль, как то, что будет сейчас.
[25:31.120 --> 25:36.120]  Так, про enable shared from this. Все понятно, да? Все, все поняли?
[25:36.120 --> 25:38.120]  Классно.
[25:38.120 --> 25:41.120]  Вот. Теперь смотрите.
[25:51.120 --> 25:53.120]  Нет, нет, мы же уже говорили про это.
[25:53.120 --> 25:56.120]  Неважно, эта штука в любом случае там будет написана.
[25:56.120 --> 25:57.120]  Вот.
[26:08.120 --> 26:11.120]  Так, следующий пункт.
[26:11.120 --> 26:16.120]  И сейчас я вам вот о чем напомню.
[26:16.120 --> 26:28.120]  Помните, у нас была такая договоренность, что вообще-то иногда мы можем хотеть
[26:28.120 --> 26:32.120]  Ну, вообще-то, короче, библиотечные классы не должны обращаться к оператору Нью напрямую.
[26:32.120 --> 26:40.120]  Потому что вдруг у нас вся память на стэке должна выделяться, на самом деле, а не в динамической памяти.
[26:40.120 --> 26:46.120]  А shared PTR, как выяснилось, вызывает оператор Нью в себе.
[26:46.120 --> 26:48.120]  Это неправильно. Он должен делать это через аллокатор.
[26:48.120 --> 26:53.120]  Нам надо, чтобы shared PTR создавал этот control-блок свой, или что, как он там называется у нас, каунтер,
[26:53.120 --> 26:55.120]  или как он там называется?
[26:55.120 --> 26:57.120]  Каунтер.
[26:57.120 --> 26:59.120]  Каунтер.
[26:59.120 --> 27:01.120]  Каунтер.
[27:01.120 --> 27:03.120]  Каунтер.
[27:03.120 --> 27:05.120]  Каунтер.
[27:05.120 --> 27:07.120]  Каунтер.
[27:07.120 --> 27:09.120]  Каунтер.
[27:09.120 --> 27:11.120]  Каунтер.
[27:11.120 --> 27:13.120]  Каунтер.
[27:13.120 --> 27:15.120]  Каунтер.
[27:15.120 --> 27:17.120]  Каунтер.
[27:17.120 --> 27:19.120]  Через аллокатор.
[27:19.120 --> 27:25.120]  В частности, чтобы функция make shared не делала оператор Нью, не делала Нью control-блок, бла-бла-бла,
[27:25.120 --> 27:27.120]  а делала это через аллокатор.
[27:27.120 --> 27:33.120]  Не, ну, казалось бы, ладно, просто делаем через аллокатор и все.
[27:33.120 --> 27:35.120]  Но.
[27:35.120 --> 27:37.120]  Но.
[27:37.120 --> 27:41.120]  Аллокатор – это не шаблонный параметр shared PTR.
[27:41.120 --> 27:45.120]  Это означает, что.
[27:45.120 --> 27:47.120]  А почему не шаблонный параметр?
[27:47.120 --> 27:51.120]  Потому что в большинстве случаев ты не хочешь думать о нем.
[27:51.120 --> 27:53.120]  И для shared.
[27:57.120 --> 28:01.120]  Ну, в общем, так не сделано.
[28:01.120 --> 28:03.120]  Почему не шаблонный параметром make shared?
[28:03.120 --> 28:07.120]  На самом деле есть функция allocate shared.
[28:07.120 --> 28:09.120]  Еще.
[28:09.120 --> 28:11.120]  Вот давайте функцию allocate shared.
[28:15.120 --> 28:17.120]  Ну, сейчас я до конца, наверное, не расскажу, как это реализовано.
[28:17.120 --> 28:21.120]  Нам надо еще кое-что будет пройти, а потом мы вернемся.
[28:21.120 --> 28:27.120]  Вот как раз это та проблема, решение которой будет, наверное, основную боль составлять.
[28:27.120 --> 28:29.120]  У нас будет функция allocate shared.
[28:29.120 --> 28:35.120]  allocate shared – это функция, которая принимает make shared, а потом еще arcs.
[28:35.120 --> 28:37.120]  Какой make shared?
[28:37.120 --> 28:39.120]  Который принимает allocator, потом arcs.
[28:39.120 --> 28:41.120]  На самом деле make shared – она в одну строчку реализована.
[28:41.120 --> 28:45.120]  Это просто allocate shared от std allocator и тех же самых arcs.
[28:45.120 --> 28:49.120]  И главное интерес.
[28:49.120 --> 28:51.120]  Что такое allocate shared?
[28:51.120 --> 28:53.120]  Смотрите.
[28:53.120 --> 28:55.120]  Давайте напишу.
[28:55.120 --> 28:57.120]  Там template.
[28:57.120 --> 28:59.120]  Ладно, напишу все-таки.
[28:59.120 --> 29:01.120]  Type name t.
[29:01.120 --> 29:03.120]  Type name alloc.
[29:03.120 --> 29:05.120]  Type name arcs.
[29:17.120 --> 29:19.120]  Shared ptr t allocate shared.
[29:19.120 --> 29:27.120]  Allocate unique нет по понятным причинам, потому что у unique ptr нет такой проблемы, что им надо еще какую-то свою память выделить.
[29:27.120 --> 29:29.120]  Shared ptr t allocate shared.
[29:31.120 --> 29:39.120]  Ну и сюда я приму alloc.
[29:51.120 --> 29:55.120]  Make unique не выделяет…
[29:55.120 --> 29:59.120]  Ну, в общем, make unique…
[29:59.120 --> 30:01.120]  Да, ну хорошо.
[30:01.120 --> 30:07.120]  Ну в общем нету make unique, потому что считается, что если вы хотите выделить не на стандартном allocator, то делайте это сами.
[30:07.120 --> 30:09.120]  Вот так.
[30:09.120 --> 30:13.120]  Ну, с shared ptr так вы не сможете.
[30:13.120 --> 30:17.120]  Потому что если вам нужно сделать unique ptr не на стандартном allocator, ну сделайте его просто.
[30:17.120 --> 30:21.120]  Потом unique ptr передайте функцию удалитель там.
[30:21.120 --> 30:23.120]  Не delete, а deal locate и что-то такое.
[30:23.120 --> 30:27.120]  Мы еще, кстати, не обсудили, как кастомные функции delete передавать.
[30:27.120 --> 30:29.120]  Но это мы тоже обсудим.
[30:29.120 --> 30:31.120]  Но в allocate…
[30:31.120 --> 30:33.120]  Но в make shared вы никак не заставите shared ptr…
[30:33.120 --> 30:41.120]  У вас нет способа вручную создать shared ptr так, чтобы он вот этот свой counter не выделил на нестандартном allocator.
[30:41.120 --> 30:43.120]  Вам только через allocate shared придется это делать.
[30:43.120 --> 30:49.120]  Смысл в том, что shared ptr из-за того, что он выделяет дополнительные счетчики к себе,
[30:49.120 --> 30:53.120]  вы никак не можете его заставить это вручную сделать на нестандартном allocator,
[30:53.120 --> 30:55.120]  поэтому вам приходится через allocate shared это делать.
[30:55.120 --> 31:01.120]  Так вот, allocator и arcs.
[31:01.120 --> 31:07.120]  Но allocator я по значению принял, потому что типа он легкий.
[31:07.120 --> 31:09.120]  Вот, теперь смотрите.
[31:09.120 --> 31:15.120]  Теперь у меня есть allocator, но этот allocator – это allocator на t.
[31:15.120 --> 31:19.120]  А мне нужно алоцировать не t, а control block.
[31:19.120 --> 31:25.120]  Значит, я должен из этого allocator создать allocator на control block,
[31:25.120 --> 31:35.120]  алоцировать на нем control block, вызвать там construct t по правильному адресу.
[31:35.120 --> 31:39.120]  Вот, но что самое главное…
[31:39.120 --> 31:41.120]  Ну и все, и казалось бы, и создал shared ptr от этого.
[31:41.120 --> 31:45.120]  Но как потом этот shared ptr удаляться будет?
[31:45.120 --> 31:47.120]  Вот shared ptr умирает.
[31:47.120 --> 31:55.120]  А он должен освободить все за собой, удалить t, удалить…
[31:55.120 --> 32:01.120]  Допустим, он заметил, что evict ptr-ов нет, ему нужно удалить все и control block, освободить память.
[32:01.120 --> 32:09.120]  Но он же должен это сделать тоже тем allocator, который создавал, если изначально, если он не через new.
[32:09.120 --> 32:17.120]  shared ptr-у надо помнить, каким allocator-ом он создавался.
[32:17.120 --> 32:33.120]  Ты вот забываешь кое-что и переспрашиваешь, а почему shared ptr не может?
[32:33.120 --> 32:41.120]  Сколько памяти мы ему выделили, пока всего 2 мт.
[32:41.120 --> 32:45.120]  У меня памяти меньше.
[32:45.120 --> 32:53.120]  У тебя памяти побольше, чем 8 байт, тем не менее, пока ты тоже довольно много забываешь.
[32:53.120 --> 33:01.120]  Так вот, как shared ptr-у удаляться правильным allocator-ом?
[33:01.120 --> 33:17.120]  Да, в блоке сохраним. А что сохраним?
[33:17.120 --> 33:29.120]  Объект какого allocator-а?
[33:29.120 --> 33:37.120]  Объект какого allocator-а?
[33:37.120 --> 33:43.120]  А allocator сам каким будет?
[33:43.120 --> 33:51.120]  Как будет выглядеть твоя структура? Ну, она называлась counter, да? Я зря ее стер.
[33:51.120 --> 33:59.120]  У нас вот эти два счетчика, и давай, третий поле, это будет что конкретно?
[33:59.120 --> 34:09.120]  Какой allocator-то?
[34:09.120 --> 34:19.120]  Хорошо, и тогда здесь будет counter с каким шаблонным параметром?
[34:19.120 --> 34:27.120]  Потому что мы договорились, что у нас счетчики и вся вспомогательная штука лежит в этой структуре.
[34:27.120 --> 34:37.120]  Base control block, это там только T лежит. А тут лежат счетчики и дополнительная всякая вещь.
[34:37.120 --> 34:47.120]  По умолчанию, вот здесь вот.
[34:47.120 --> 34:57.120]  А мы решили, что нельзя.
[34:57.120 --> 35:07.120]  Нет, shared PTR не имеет второго шаблонного параметра. Вот так вот сделано.
[35:07.120 --> 35:17.120]  Он умеет, вот вы можете shared PTR сохранить что-то с помощью одного allocator, а потом присвоить этому shared PTR что-то выделенное на другом allocator.
[35:17.120 --> 35:27.120]  То есть на другом принципиальном allocator.
[35:27.120 --> 35:33.120]  Выделенный стандартным allocator.
[35:33.120 --> 35:43.120]  Ты можешь ему присвоить указатель на T, но ты можешь ему присвоить shared PTR, у которого другой allocator.
[35:43.120 --> 35:53.120]  В общем, ты не думаешь об allocator.
[35:53.120 --> 36:03.120]  Вот такая проблема, и что делать?
[36:03.120 --> 36:09.120]  Можно было бы создать вторым параметром allocator.
[36:09.120 --> 36:19.120]  И просто когда мы делаем присваивание, возвращать...
[36:19.120 --> 36:27.120]  Ну давайте хранить просто... Зачем нам знать, на каком allocator мы выделились?
[36:27.120 --> 36:37.120]  Если у тебя есть оператор равно, то это очень трудно.
[36:37.120 --> 36:47.120]  Если у тебя есть оператор равно, то это очень трудно.
[36:47.120 --> 36:53.120]  Если мы дали без звездочки, я считаю, что она через стол.
[36:53.120 --> 36:57.120]  Нет, я вообще не понимаю.
[36:57.120 --> 37:01.120]  Если мы создаем... Мы забудем про все новые проблемы, которые мы создавали.
[37:01.120 --> 37:05.120]  Если у нас есть T-звездочка, и нам ее дали.
[37:05.120 --> 37:11.120]  Мы теперь за нее ответственны, а мы не знаем, как вы выделили.
[37:11.120 --> 37:19.120]  Нет, в таком случае мы просто сохраним стандартный allocator.
[37:19.120 --> 37:23.120]  Что ты назвал новыми проблемами тогда?
[37:23.120 --> 37:29.120]  Если мы создали T-звездочки, значит мы создали стандартный allocator.
[37:29.120 --> 37:35.120]  Не стандартный allocator можно было создать только через allocate shared.
[37:35.120 --> 37:39.120]  Просто нет способа создать не стандартный allocator не через allocate shared у пользователя.
[37:39.120 --> 37:41.120]  Почему?
[37:41.120 --> 37:43.120]  Как?
[37:43.120 --> 37:55.120]  Пользователь выделил не на не стандартном allocator, а счетчик на стандартном allocator был выделен.
[37:55.120 --> 37:59.120]  Ну тогда пользователь сам виноват.
[37:59.120 --> 38:01.120]  Поэтому лучше make shared использовать.
[38:01.120 --> 38:05.120]  Да, поэтому тоже лучше make shared использовать.
[38:05.120 --> 38:11.120]  Если пользователь выделил на не стандартном allocator, но не сказал нам об этом, не сказал sharedptr о том, что нестандартная функция удаления.
[38:11.120 --> 38:13.120]  Ну извините.
[38:13.120 --> 38:17.120]  sharedptr конечно не обещает тогда корректности.
[38:17.120 --> 38:19.120]  Вот.
[38:19.120 --> 38:25.120]  В общем нам надо сохранить здесь указатель на нечто...
[38:25.120 --> 38:29.120]  Который умеет удалять.
[38:29.120 --> 38:33.120]  Такая проблема с тем, что если нам дали указатель, мы не знаем чем удалять.
[38:33.120 --> 38:35.120]  Решена. Давайте хранить какую-то функцию.
[38:35.120 --> 38:39.120]  Ну не знаю.
[38:39.120 --> 38:43.120]  Давайте хранить функцию, которая умеет удалять.
[38:43.120 --> 38:45.120]  Функцию удалитель.
[38:45.120 --> 38:51.120]  Ну, в принципе да.
[38:51.120 --> 38:55.120]  Ну на самом деле нам бы надо еще хранить destruct.
[38:55.120 --> 38:57.120]  Ну то есть нам надо...
[38:57.120 --> 38:59.120]  А если делал бы стандартный?
[38:59.120 --> 39:03.120]  Нет, нам надо...
[39:03.120 --> 39:07.120]  У allocator же вызывать constra, destroy, вот это вот dialocate.
[39:07.120 --> 39:09.120]  Причем что именно нам надо диалацировать?
[39:09.120 --> 39:15.120]  Нам надо диалацировать то t, то что-то еще.
[39:15.120 --> 39:17.120]  То есть нам же...
[39:17.120 --> 39:19.120]  Иногда нам надо диалацировать просто...
[39:19.120 --> 39:21.120]  А, нет, вру.
[39:21.120 --> 39:25.120]  Если мы не стандартным нокатором, то значит мы через...
[39:25.120 --> 39:27.120]  Можно просто здесь либо ничего...
[39:27.120 --> 39:29.120]  Либо nullptr хранить.
[39:29.120 --> 39:31.120]  Это будет означать, что нет никакой функции, не стандартная.
[39:31.120 --> 39:33.120]  Просто delete.
[39:33.120 --> 39:35.120]  Либо хранить функцию, которая...
[39:35.120 --> 39:37.120]  Ну указатель на функцию.
[39:37.120 --> 39:39.120]  Делать освобождение по адресу...
[39:39.120 --> 39:43.120]  Короче, освобождать control-блок.
[39:45.120 --> 39:49.120]  Ну и можно указатель на destroy тоже делать.
[39:49.120 --> 39:51.120]  Смотрите, давайте тогда поступим вот так.
[39:51.120 --> 39:55.120]  Я сейчас проблему запихаю вглубь.
[39:55.120 --> 39:57.120]  То есть я не объясню как это реализовано внутри.
[39:57.120 --> 40:01.120]  А я лишь скажу, что мы сейчас воспользуемся стандартным классом с defunction.
[40:01.120 --> 40:03.120]  Опа!
[40:03.120 --> 40:05.120]  Ну смотрите, есть такой замечательный класс с defunction.
[40:05.120 --> 40:07.120]  Значит, stdefunction...
[40:09.120 --> 40:11.120]  А вот я не помню, кстати.
[40:11.120 --> 40:13.120]  Может быть function прямо в таком отклоде есть.
[40:13.120 --> 40:15.120]  stdefunction
[40:17.120 --> 40:19.120]  с шаблонными параметрами
[40:19.120 --> 40:21.120]  void
[40:21.120 --> 40:23.120]  от
[40:23.120 --> 40:25.120]  void
[40:25.120 --> 40:27.120]  от
[40:27.120 --> 40:29.120]  void
[40:29.120 --> 40:31.120]  от
[40:31.120 --> 40:33.120]  void
[40:33.120 --> 40:35.120]  от
[40:37.120 --> 40:39.120]  Ну то есть...
[40:39.120 --> 40:41.120]  Как там шаблонные параметры записываются?
[40:41.120 --> 40:43.120]  Вы пишете возвращаемое значение,
[40:43.120 --> 40:45.120]  с кубиц от принимаемых значений.
[40:45.120 --> 40:47.120]  Значит void от
[40:47.120 --> 40:49.120]  от
[40:49.120 --> 40:51.120]  не t звездочки, а
[40:51.120 --> 40:53.120]  control-блок звездочка?
[40:55.120 --> 40:57.120]  Да.
[40:57.120 --> 40:59.120]  void от control-блок звездочка.
[40:59.120 --> 41:01.120]  Вот.
[41:01.120 --> 41:03.120]  Ну вот.
[41:03.120 --> 41:05.120]  Ну это вот такая синтоксическая конструкция,
[41:05.120 --> 41:07.120]  которая вот...
[41:07.120 --> 41:09.120]  Я не знаю больше, где она используется,
[41:09.120 --> 41:11.120]  кроме как в шаблонных параметрах с defunction.
[41:11.120 --> 41:13.120]  То есть ты можешь такой...
[41:27.120 --> 41:29.120]  Короче, вот эта вот штука
[41:29.120 --> 41:31.120]  это будет
[41:31.120 --> 41:33.120]  вещь, которая...
[41:33.120 --> 41:35.120]  Которая...
[41:35.120 --> 41:37.120]  Которая что?
[41:37.120 --> 41:39.120]  Которая вызывается,
[41:39.120 --> 41:41.120]  когда...
[41:53.120 --> 41:55.120]  Верно, что нам всегда их нужно вызвать обе?
[41:55.120 --> 41:57.120]  Верно, что нам всегда их нужно вызвать обе?
[41:57.120 --> 41:59.120]  Ну да.
[42:01.120 --> 42:03.120]  Нет-нет, это только...
[42:11.120 --> 42:13.120]  Нет, ну, в control-блоке
[42:13.120 --> 42:15.120]  обязательно нужно и то, и другое,
[42:15.120 --> 42:17.120]  потому что wikiptr потом должен это делать.
[42:17.120 --> 42:19.120]  Хранить мы должны и хобби.
[42:19.120 --> 42:21.120]  Ладно,
[42:21.120 --> 42:23.120]  это все классно.
[42:23.120 --> 42:25.120]  Мы сохранили, допустим, функцию,
[42:25.120 --> 42:27.120]  аналогично, диалогей пусть будет функцией,
[42:27.120 --> 42:29.120]  но она будет называться диалог,
[42:29.120 --> 42:31.120]  я не знаю, диалог.
[42:31.120 --> 42:33.120]  Вот, хорошо.
[42:33.120 --> 42:35.120]  А чем мы пронициализируем это?
[42:35.120 --> 42:37.120]  Вот мы здесь вот создаемся
[42:37.120 --> 42:39.120]  от этого аллокатора. Чем пронициализировать
[42:39.120 --> 42:41.120]  этот диалог?
[42:51.120 --> 42:53.120]  Ну, нам нужно это пронициализировать
[42:53.120 --> 42:55.120]  чем?
[42:57.120 --> 42:59.120]  Нет, это штука,
[42:59.120 --> 43:01.120]  которой можно присвоить любую функцию,
[43:01.120 --> 43:03.120]  любой функциональный объект, давай так.
[43:05.120 --> 43:07.120]  Ее можно пронициализировать как указателем
[43:07.120 --> 43:09.120]  на C-шную функцию, так указателем на
[43:09.120 --> 43:11.120]  метод, так и указателем
[43:11.120 --> 43:13.120]  не указателем, а
[43:13.120 --> 43:15.120]  просто функциональным объектом. То есть объекту,
[43:15.120 --> 43:17.120]  у которого круглые скобочки определены.
[43:17.120 --> 43:19.120]  Нет, функциональный объект
[43:19.120 --> 43:21.120]  создавать не нужно, вот он. Вот это он и есть.
[43:21.120 --> 43:22.780]  등, то есть это и будет функциональный объект.
[43:22.780 --> 43:25.560]  Его можно tongulitzировать как готовым функциональным
[43:25.560 --> 43:27.320]  объектом, так и любой функции в частности указателем
[43:27.320 --> 43:29.080]  на метод.
[43:29.080 --> 43:31.560]  Мы хотим видимо tongulizировать указателем на метод.
[43:31.560 --> 43:46.420]  А тогда у
[43:46.420 --> 43:49.420]  Ты не решил проблему, что ты аллокатор не хранишь.
[43:49.420 --> 43:52.420]  Тебе нужен объект аллокатора, чтобы вызвать метод аллокатора.
[43:52.420 --> 43:54.420]  От того, что ты сохранишь фанкшн...
[43:54.420 --> 43:56.420]  Какой аллокатор?
[43:56.420 --> 43:58.420]  А, блин!
[44:02.420 --> 44:04.420]  Это присвоение...
[44:04.420 --> 44:06.420]  Войт-звездочки вообще!
[44:06.420 --> 44:08.420]  Что такое?
[44:08.420 --> 44:10.420]  А?
[44:12.420 --> 44:14.420]  Нам нужно как-то когда-то сделать...
[44:14.420 --> 44:16.420]  Мы не понимаем диалогу, какое значение, да?
[44:16.420 --> 44:19.420]  А мы знаем, какой у нас аллокатор, только у аллокейт-шерт.
[44:21.420 --> 44:25.420]  Нам нужно либо сделать конструктор, который принимает аллокатор.
[44:29.420 --> 44:31.420]  Шаблонный конструктор.
[44:31.420 --> 44:33.420]  Особый диструктур надо...
[44:33.420 --> 44:35.420]  Откуда...
[44:35.420 --> 44:37.420]  Не, нам все равно, откуда надо аллокатор.
[44:37.420 --> 44:39.420]  Так что...
[44:39.420 --> 44:42.420]  Может реально шаблонный конструктор, который принимает еще аллокатор.
[44:42.420 --> 44:44.420]  Давайте писаем аллокейт-шерт.
[44:44.420 --> 44:46.420]  Давайте запишем про него.
[44:46.420 --> 44:48.420]  Ну, в смысле?
[44:48.420 --> 44:52.420]  Вот время конструктора прошло, мы сконструировались, что мы положили в себя.
[44:52.420 --> 44:56.420]  Мы не можем положить в себя аллокатор, потому что мы не можем объединить его.
[44:56.420 --> 45:00.420]  Короче, бегом от аллока и запихиваем...
[45:02.420 --> 45:04.420]  Похоже, не можем.
[45:04.420 --> 45:06.420]  Чтобы его вызвать потом, нам нужен объект класса.
[45:08.420 --> 45:10.420]  Зачем нужны функшн?
[45:10.420 --> 45:12.420]  Кажется, что функшн сейчас не поможет.
[45:12.420 --> 45:16.420]  Именно у объекта аллокатора мы можем вызвать аллокейт через точку.
[45:16.420 --> 45:18.420]  Не через аллокейт.
[45:18.420 --> 45:20.420]  Чем еще нужны есть де функшн?
[45:20.420 --> 45:22.420]  Не дестрой.
[45:22.420 --> 45:26.420]  Да, но кажется, что идея этого была неправильной.
[45:26.420 --> 45:28.420]  С де функшн, кажется, у меня не получится сейчас.
[45:28.420 --> 45:30.420]  Что?
[45:30.420 --> 45:32.420]  Как?
[45:48.420 --> 45:50.420]  Шаблонный функшн.
[45:52.420 --> 45:54.420]  Короче, я предложу вот что.
[46:00.420 --> 46:06.420]  Я хочу сделать...
[46:06.420 --> 46:08.420]  Так, сейчас.
[46:16.420 --> 46:18.420]  Не, можно и так, да.
[46:20.420 --> 46:22.420]  Это вариант у меня хранить один из двух типов.
[46:22.420 --> 46:24.420]  Но можно описать SD Any?
[46:30.420 --> 46:32.420]  Как это нам поможет?
[46:34.420 --> 46:36.420]  Как это работает?
[46:50.420 --> 46:52.420]  Я знаю, что это объект аллокатора.
[46:52.420 --> 46:54.420]  Какого аллокатора?
[46:54.420 --> 46:56.420]  Какого угодно.
[46:56.420 --> 47:00.420]  Тебе, чтобы вызвать метод класса, тебе нужно сначала сказать, что за класс.
[47:00.420 --> 47:06.420]  То есть даже если ты используешь Any, тебе нужно сказать AnyCast к такому-то типу точкой диалокейта.
[47:06.420 --> 47:10.420]  А можно как-то хранить именно сам тип через какой-нибудь юзинг или что-то такое?
[47:10.420 --> 47:12.420]  Через юзинг?
[47:12.420 --> 47:14.420]  Ну, чрез юзинг нельзя, потому что мы не можем менять.
[47:14.420 --> 47:16.420]  А как-то записать...
[47:16.420 --> 47:18.420]  Строк выхранить, короче.
[47:18.420 --> 47:20.420]  Название типа.
[47:20.420 --> 47:24.420]  Я же предложил, вот звездочка на аллокаторе и typeof.
[47:24.420 --> 47:26.420]  В общем, знаете, что я хочу сделать?
[47:26.420 --> 47:30.420]  Я хочу на самом деле сейчас сказать, что давайте мы эту проблему отложим.
[47:32.420 --> 47:38.420]  Потому что кажется, что надо про нее рассказывать.
[47:38.420 --> 47:40.420]  Сразу вместе.
[47:40.420 --> 47:42.420]  Это некоторая целая...
[47:42.420 --> 47:46.420]  Короче, есть большая проблема.
[47:46.420 --> 47:48.420]  Нам нужно как-то сохранить аллокатор, но мы не знаем какого типа.
[47:48.420 --> 47:50.420]  Они могут быть разные, динамически подменяющимися.
[47:50.420 --> 47:52.420]  Вот.
[47:52.420 --> 47:56.420]  Давайте я скажу, что эта проблема будет нами решена через две лекции.
[47:56.420 --> 47:58.420]  И вот тогда мы поймем, как это все работает.
[47:58.420 --> 48:02.420]  А заодно поймем, как работает Function, Any и все прочее.
[48:02.420 --> 48:04.420]  Вот.
[48:04.420 --> 48:06.420]  Существует один способ.
[48:06.420 --> 48:08.420]  Это сделать...
[48:08.420 --> 48:10.420]  Ну, сейчас я не хочу про него рассказывать.
[48:10.420 --> 48:12.420]  Но может кто-нибудь выяснил, что придумает до того, как я про него рассказывал.
[48:12.420 --> 48:14.420]  Ну, может кто-нибудь выяснил, что придумает до того, как я про него рассказывал.
[48:14.420 --> 48:18.420]  Ну, короче, мы с вами реализуем.
[48:18.420 --> 48:22.420]  Через две пары мы с вами реализуем Any, во-первых.
[48:22.420 --> 48:24.420]  И реализуем Function.
[48:24.420 --> 48:26.420]  Ну через 3-и.
[48:26.420 --> 48:28.420]  А когда мы это сделаем, мы поймем, как это сделать.
[48:28.420 --> 48:30.420]  Вот так.
[48:30.420 --> 48:34.420]  А то есть у нас возникла вот здесь проблема, которую мы пока не умеем решать.
[48:34.420 --> 48:38.420]  И чтобы ее решить, мы с начала поймем, как вот эти вещи реализованы.
[48:38.420 --> 48:40.420]  Изначально мы решаем все вот эти вещи.
[48:40.420 --> 48:44.880]  И чтобы ее решить, мы сначала поймем, как вообще вот эти вот вещи реализованы изнутри,
[48:44.880 --> 48:48.220]  а потом автоматически мы сразу понимаем, как и эта штука будет работать. Вот так.
[48:48.220 --> 48:53.580]  Вот, короче. Все. На этом я хочу закончить тему умных показателей, но мы к ней еще вернемся, потому что вот.
[48:53.580 --> 49:00.780]  А еще у нас может быть кастомный дилитер. То есть, смотрите, у нас может быть аллокатор нестандартный,
[49:00.780 --> 49:02.780]  а еще может быть дилитер нестандартный. То есть...
[49:02.780 --> 49:04.780]  Мы же убедим, что это птр.
[49:05.420 --> 49:09.620]  Это не шаблонный параметр shared ptr, это шаблонный параметр...
[49:13.120 --> 49:18.960]  Ты можешь создать shared ptr от t звездочка и еще объекта дилитер.
[49:18.960 --> 49:20.960]  Дилитер — это функциональный объект.
[49:20.960 --> 49:25.760]  То есть, это на самом деле может быть и аллокатор, и дилитер еще нестандартный.
[49:25.760 --> 49:27.760]  Что такое нестандартный дилитер?
[49:27.900 --> 49:29.900]  Это...
[49:29.900 --> 49:31.900]  Кажется, что комбинировать их нельзя.
[49:31.900 --> 49:38.280]  То есть, ты можешь либо создать shared ptr с нестандартным дилитером, но тогда обязательно от t звездочки,
[49:38.280 --> 49:43.860]  либо allocate shared, но тогда у тебя нет возможности сделать нестандартный аллокатор, нестандартный дилитер.
[49:43.860 --> 49:45.860]  Что такое нестандартный дилитер?
[49:45.860 --> 49:50.060]  Это означает, что у тебя вместо освобождения памяти вызывается другая штука.
[49:50.060 --> 49:57.500]  Просто функция освобождения. Она не удаление представляет себя, а что-то другое, например, закрытие с его усоединения.
[49:57.500 --> 50:01.280]  А может быть, shared ptr от t звездочки и какой-то функции.
[50:02.720 --> 50:06.640]  А может быть, shared ptr от нестандартного аллокатора.
[50:06.640 --> 50:12.220]  И все это вот здесь вот нужно как-то сохранить, то есть, нужно сохранить некоторую вещь,
[50:12.220 --> 50:17.840]  которой как-то вот динамически обращается, она может быть динамически подменяться на разные типы,
[50:17.840 --> 50:24.360]  и смотря, что там был нестандартный аллокатор, нестандартный дилитер, мы туда ходим в деструкторе и понимаем, что вызвать сейчас.
[50:27.500 --> 50:37.080]  Да, может быть, нужен нестандартный дилитер, если он может быть профессионально просто в деструкторе класса, который нам передали.
[50:37.080 --> 50:42.080]  Почему мы не говорим, если уж ходить в нестандартный дилитер, пишите его в своем деструкторе?
[50:42.080 --> 50:44.080]  Ну, мазохизм, ну, нет.
[50:49.240 --> 50:52.240]  Ты... ну, давай подумаем.
[50:57.800 --> 50:59.800]  Как это?
[51:12.800 --> 51:15.800]  Ам, ну, сейчас.
[51:27.500 --> 51:48.000]  Ну, вот, смотри, есть такой стандартный, наверное, пример, когда нужно RAII, кроме как с выделением памяти.
[51:48.000 --> 51:53.000]  Например, если у тебя есть Mutex. Знаете ли вы, что такое Mutex?
[51:53.500 --> 52:11.000]  Ну, короче, когда у тебя есть блокировка, в смысле, у тебя есть такой класс, которому ты вызываешь метод Lock, и это означает, что никто другой, пока ты не вызовешь Unlock, не сможет сделать Lock, он зависнет просто на этом Lock.
[52:11.000 --> 52:21.000]  Вот, и тебе надо, выходя из функции, обязательно не забыть сделать Unlock, несмотря ни на что.
[52:21.000 --> 52:34.000]  Ну, деструктор Mutex, он... Mutex у тебя в нескольких потоках, это один объект, к которому из нескольких потоков могут обращаться.
[52:34.000 --> 52:40.000]  Вот, сам он не уничтожается, но нужно обязательно Unlock сделать, перед тем, как ты выйдешь из функции, и не забыть.
[52:40.000 --> 52:45.000]  То есть, ты не уничтожаешь T, ты вызываешь некоторую функцию над ним.
[52:45.000 --> 52:52.000]  То есть, у тебя должна быть какая-то операция, которую ты обязательно должен сделать над объектом T, перед тем, как функцию свою покинуть.
[52:52.000 --> 52:59.000]  Вот, и это стандартный пример, как, может быть, нужно RAII не для выделения освобождения памяти.
[53:01.000 --> 53:03.000]  Ну, вот для многопоточности, например.
[53:04.000 --> 53:08.000]  И в связи с этим существует даже класс SharedLock, но ладно.
[53:10.000 --> 53:12.000]  Интересно, интересно.
[53:15.000 --> 53:19.000]  Я не знаю, понятен ли был пример, но, кажется, пример я привел.
[53:22.000 --> 53:26.000]  Так, сколько времени у нас? 11.48.
[53:27.000 --> 53:31.000]  12 минут. Ну, слушайте, мы начали, блин, на 15 минут позже, конечно.
[53:32.000 --> 53:36.000]  И причем не из-за меня, я опоздал всего на 10 минут.
[53:37.000 --> 53:39.000]  Вот, а сейчас 17 минут.
[53:40.000 --> 53:45.000]  Так, короче, вот здесь я пока ставлю ToDo, непонятно, что делать.
[53:49.000 --> 53:52.000]  И все, и сотру это все.
[53:53.000 --> 53:59.000]  И теперь я перейду к следующей теме, а следующая тема это как раз будет про функции и функциональные объекты.
[53:59.000 --> 54:00.000]  Значит, какой план?
[54:00.000 --> 54:06.000]  Сейчас мы плюс-минус поняли, как устроено умные указатели, по-моему, для вот этой вот проблемы,
[54:06.000 --> 54:09.000]  что непонятно, как свой аллокатор и свой делитер туда класть.
[54:10.000 --> 54:15.000]  И сейчас я хочу еще одну рассмотреть языковую фичу.
[54:15.000 --> 54:18.000]  Следующая тема будет называться лямбда-функции.
[54:20.000 --> 54:22.000]  Так, значит, тема 13.
[54:23.000 --> 54:24.000]  Лямбда-функции.
[54:25.000 --> 54:28.000]  Проходили ли вы лямбда-функции на Матлогике уже?
[54:28.000 --> 54:30.000]  Нет. Они в конце года.
[54:30.000 --> 54:32.000]  Блин, ну жалко. Ну ладно.
[54:32.000 --> 54:34.000]  Никто не проходил. Смотрите, есть функции, можно их объявлять.
[54:35.000 --> 54:36.000]  Идем дальше.
[54:37.000 --> 54:42.000]  Значит, лямбда-функции – это тоже, начиная с и плюс-минус 11, фича.
[54:42.000 --> 54:46.000]  Классная фича. Можно же забирать, если будет видео.
[54:48.000 --> 54:50.000]  Не понял пока про что ты, но ладно.
[54:50.000 --> 54:52.000]  Можно же подтягивать в функции.
[54:54.000 --> 54:56.000]  Так-то обычные функции такого не умеют.
[54:56.000 --> 54:57.000]  Ну...
[54:57.000 --> 54:59.000]  Потому что это же не функция, а объект-план.
[55:00.000 --> 55:02.000]  Так, значит, лямбда-функции. Смотрите, план.
[55:02.000 --> 55:10.000]  Сейчас мы поговорим про то, что такое лямбда-функции и, значит, какие дополнительные возможности, какие проблемы они приносят.
[55:11.000 --> 55:13.000]  А потом поговорим как раз про CD-фанкшн.
[55:13.000 --> 55:15.000]  Ну, про CD-фанкшн, в принципе, я уже и так сказал.
[55:16.000 --> 55:20.000]  Ну, я просто скажу, что он есть, и, значит, мы им попользуемся чуть-чуть.
[55:20.000 --> 55:25.000]  А потом еще мы обсудим некоторые другие вещи, например, CD-bind.
[55:25.000 --> 55:31.000]  Ну, то есть, функциональные, библиотечные классы для работы с функциональными объектами.
[55:31.000 --> 55:32.000]  Вот.
[55:32.000 --> 55:35.000]  И у нас останется один большой вопрос, как это все реализовано.
[55:35.000 --> 55:40.000]  Потому что там ровно такая же проблема с CD-фанкшн, как и с...
[55:40.000 --> 55:42.000]  Вот, которая у нас была там.
[55:42.000 --> 55:46.000]  А именно CD-фанкшн можно подменять динамический тип, который нам хранится.
[55:46.000 --> 55:48.000]  Ну, ты можешь присвоить функции одно, потом присвоить другое.
[55:48.000 --> 55:50.000]  Если типа возвращаем в изучение, принимаем их такие же.
[55:50.000 --> 55:51.000]  Вот.
[55:51.000 --> 55:56.000]  И когда мы поймем, что у нас эта проблема возникла второй раз, мы перейдем к разговору о том, а как вообще реализован.
[55:57.000 --> 56:01.000]  Ну, и следующая тема у нас будет называться Type Eraser.
[56:01.000 --> 56:04.000]  И мы как раз обсудим, как реализован Any, во-первых.
[56:04.000 --> 56:06.000]  Как реализована Function.
[56:06.000 --> 56:14.000]  А потом вернемся к разговору про shared pointer и поймем, как реализовать вот эту штуку с дилитером и саллокатором.
[56:14.000 --> 56:15.000]  Вот такой план.
[56:15.000 --> 56:17.000]  Но сначала давайте поговорим про функциональные объекты.
[56:17.000 --> 56:18.000]  Так вот.
[56:18.000 --> 56:20.000]  13.1.
[56:20.000 --> 56:22.000]  Идея.
[56:22.000 --> 56:24.000]  И базовое использование.
[56:26.000 --> 56:28.000]  Так.
[56:28.000 --> 56:30.000]  Ну, что?
[56:30.000 --> 56:32.000]  Что такое лямбда функции?
[56:32.000 --> 56:34.000]  Плюсах.
[56:34.000 --> 56:36.000]  А кто?
[56:36.000 --> 56:38.000]  Нет.
[56:38.000 --> 56:40.000]  Это объекты.
[56:40.000 --> 56:42.000]  Ну, хорошо.
[56:42.000 --> 56:44.000]  Сами функции.
[56:44.000 --> 56:46.000]  Они, наверное, это будут методы.
[56:46.000 --> 56:48.000]  Так.
[56:48.000 --> 56:50.000]  Кто уже умеет пользоваться лямбда функциями в плюсах?
[56:50.000 --> 56:52.000]  Ну, почти все.
[56:52.000 --> 56:54.000]  Все понятно.
[56:54.000 --> 56:56.000]  Ну, хорошо.
[56:56.000 --> 56:58.000]  Ну, хорошо.
[57:04.000 --> 57:06.000]  Ну, вот у меня есть STD-сорт.
[57:06.000 --> 57:08.000]  И я хочу
[57:08.000 --> 57:10.000]  передать туда.
[57:12.000 --> 57:14.000]  Ретерн не нужен.
[57:16.000 --> 57:18.000]  Шариш.
[57:18.000 --> 57:20.000]  В смысле, он правильно все говорит?
[57:20.000 --> 57:22.000]  По стандарту говорят, что можно не писать.
[57:22.000 --> 57:24.000]  По стандарту это все плохо.
[57:24.000 --> 57:26.000]  Может еще нормальный человек должен маску носить всегда?
[57:26.000 --> 57:28.000]  Маски отменили.
[57:28.000 --> 57:30.000]  Так вот и ретерн ноль отменили.
[57:30.000 --> 57:32.000]  Ретерн ноль отменился.
[57:36.000 --> 57:38.000]  Так вот.
[57:38.000 --> 57:40.000]  STD-сорт.
[57:42.000 --> 57:44.000]  Ну, допустим, тут был вектор.
[57:44.000 --> 57:46.000]  Ну, был.
[57:46.000 --> 57:48.000]  В.
[57:48.000 --> 57:50.000]  В.
[57:50.000 --> 57:52.000]  В.
[57:52.000 --> 57:54.000]  В.
[57:54.000 --> 57:56.000]  И вот я хочу передать сюда
[57:56.000 --> 57:58.000]  нестандартный компаратор.
[57:58.000 --> 58:00.000]  Что я тогда
[58:00.000 --> 58:02.000]  должен написать?
[58:02.000 --> 58:04.000]  Ну, я мог бы указательно функцию передать в C-стайле.
[58:04.000 --> 58:06.000]  Но мне это не нравится.
[58:06.000 --> 58:08.000]  Да.
[58:08.000 --> 58:10.000]  Но я не хочу объявлять.
[58:10.000 --> 58:12.000]  У меня огромная простыня кода.
[58:12.000 --> 58:14.000]  Вот большая функция, там много классов.
[58:14.000 --> 58:16.000]  Я внутри какого-то класса нахожусь.
[58:16.000 --> 58:18.000]  Мне, чтобы сюда передать это,
[58:18.000 --> 58:20.000]  мне придется объявлять
[58:20.000 --> 58:22.000]  где-то там заранее
[58:22.000 --> 58:24.000]  в какой-то области видимости функцию,
[58:24.000 --> 58:26.000]  чтобы ее сюда передать.
[58:26.000 --> 58:28.000]  Или еще лучше объявлять функциональный объект,
[58:28.000 --> 58:30.000]  объявлять целый класс с аппаратом
[58:30.000 --> 58:32.000]  круглой скобочки, чтобы его экземпляр сюда
[58:32.000 --> 58:34.000]  передать. Вот чтобы мне такого не писать,
[58:34.000 --> 58:36.000]  у меня есть очень короткая
[58:36.000 --> 58:38.000]  синтоксическая конструкция.
[58:38.000 --> 58:40.000]  Я могу просто передать сюда
[58:40.000 --> 58:42.000]  объект,
[58:42.000 --> 58:44.000]  который будет
[58:44.000 --> 58:46.000]  являться функцией, созданной
[58:46.000 --> 58:48.000]  прямо на месте.
[58:48.000 --> 58:50.000]  Без предварительного объявления
[58:50.000 --> 58:52.000]  типа этого объекта.
[58:52.000 --> 58:54.000]  Давайте я
[58:54.000 --> 58:56.000]  что-нибудь вообще простое.
[58:56.000 --> 58:58.000]  Сортировка по убыванию будет.
[58:58.000 --> 59:00.000]  Я просто верну...
[59:00.000 --> 59:02.000]  СТД грейтер, короче.
[59:02.000 --> 59:04.000]  Я пишу
[59:04.000 --> 59:06.000]  квадратные скобочки пустые.
[59:08.000 --> 59:10.000]  Внезапно.
[59:10.000 --> 59:12.000]  Нет, не всегда, конечно.
[59:12.000 --> 59:14.000]  Это...
[59:14.000 --> 59:16.000]  Да, вот это как раз интересно.
[59:16.000 --> 59:18.000]  Но пока пустые.
[59:18.000 --> 59:20.000]  Дальше круглые скобочки
[59:20.000 --> 59:22.000]  и аргументы.
[59:22.000 --> 59:24.000]  Какие аргументы?
[59:24.000 --> 59:26.000]  Ну, да, ну просто
[59:26.000 --> 59:28.000]  int a, int b.
[59:28.000 --> 59:30.000]  Круглая скобочка закрылась.
[59:30.000 --> 59:32.000]  Фигурная скобочка.
[59:32.000 --> 59:34.000]  И тут я
[59:34.000 --> 59:36.000]  что пишу? А тут я просто пишу
[59:36.000 --> 59:38.000]  return
[59:38.000 --> 59:40.000]  a больше b.
[59:40.000 --> 59:42.000]  Фигурная скобочка закрылась.
[59:42.000 --> 59:44.000]  Круглая скобочка закрылась.
[59:44.000 --> 59:46.000]  Точка запятой.
[59:46.000 --> 59:48.000]  Ну, это вот эта круглая.
[59:48.000 --> 59:50.000]  Вот, это
[59:50.000 --> 59:52.000]  совершенно базовый примитивный использование
[59:52.000 --> 59:54.000]  лямбда функций.
[59:56.000 --> 59:58.000]  Это...
[59:58.000 --> 01:00:00.000]  Ну, пока не будем говорить, что это.
[01:00:00.000 --> 01:00:02.000]  Значит, здесь просто пустые квадратные
[01:00:02.000 --> 01:00:04.000]  скобочки пока оставляем. Они сигнализируют
[01:00:04.000 --> 01:00:06.000]  в том, что лямбда функции начинается.
[01:00:06.000 --> 01:00:08.000]  Дальше список аргументов.
[01:00:08.000 --> 01:00:10.000]  И дальше тело функций. Здесь может быть
[01:00:10.000 --> 01:00:12.000]  произвольное совершенно тело.
[01:00:12.000 --> 01:00:14.000]  И...
[01:00:14.000 --> 01:00:16.000]  Дальше фигурная скобочка закрывается.
[01:00:16.000 --> 01:00:18.000]  Точка запятой. Заметьте, что
[01:00:18.000 --> 01:00:20.000]  я не написал явно какой возвращаемый тип
[01:00:20.000 --> 01:00:22.000]  у этой лямбда функции.
[01:00:22.000 --> 01:00:24.000]  А он автоматически выводится.
[01:00:24.000 --> 01:00:26.000]  Дедукция, да.
[01:00:26.000 --> 01:00:28.000]  Вот.
[01:00:28.000 --> 01:00:30.000]  Можно явно указать
[01:00:30.000 --> 01:00:32.000]  возвращаемый тип, если по какой-то причине
[01:00:32.000 --> 01:00:34.000]  я считаю, что это нужно.
[01:00:34.000 --> 01:00:36.000]  То есть компилятор выведет его сам.
[01:00:36.000 --> 01:00:38.000]  Если бы, например, я сделал что-то в стиле,
[01:00:38.000 --> 01:00:40.000]  ну как у нас было с выводом типов,
[01:00:40.000 --> 01:00:42.000]  if там,
[01:00:42.000 --> 01:00:44.000]  не знаю, a больше b, return...
[01:00:44.000 --> 01:00:46.000]  Ну, короче, в одном случае
[01:00:46.000 --> 01:00:48.000]  вернуть char в другом int.
[01:00:48.000 --> 01:00:50.000]  Ну, в общем, если я сделаю...
[01:00:50.000 --> 01:00:52.000]  А?
[01:00:54.000 --> 01:00:56.000]  Если у меня конфликтующий
[01:00:56.000 --> 01:00:58.000]  return type,
[01:00:58.000 --> 01:01:00.000]  то это будет, конечно же, ce, потому что компилятор
[01:01:00.000 --> 01:01:02.000]  скажет, не могу вывести
[01:01:02.000 --> 01:01:04.000]  возвращаемый тип лямбда функции.
[01:01:04.000 --> 01:01:06.000]  Здесь, вот здесь, после этой закрывающей скобочки,
[01:01:06.000 --> 01:01:08.000]  я еще могу написать
[01:01:08.000 --> 01:01:10.000]  стрелочку и тип.
[01:01:10.000 --> 01:01:12.000]  Явно сказать, какой возвращаемый тип.
[01:01:12.000 --> 01:01:14.000]  Вот это не обязательная часть.
[01:01:14.000 --> 01:01:16.000]  То есть если вы хотите для лямбда функции
[01:01:16.000 --> 01:01:18.000]  указать, какой тип он возвращает,
[01:01:18.000 --> 01:01:20.000]  явно, то после списка аргументов
[01:01:20.000 --> 01:01:22.000]  стрелка и тип.
[01:01:22.000 --> 01:01:24.000]  Это уже третья стрелочка, верно?
[01:01:24.000 --> 01:01:26.000]  Это уже третья, да, стрелочка по смыслу.
[01:01:28.000 --> 01:01:30.000]  Ну, это скорее вторая.
[01:01:30.000 --> 01:01:32.000]  Третья, это вот кастомные
[01:01:32.000 --> 01:01:34.000]  правила вывода шаблонов, это скорее третья.
[01:01:34.000 --> 01:01:36.000]  Это вторая.
[01:01:36.000 --> 01:01:38.000]  Так, ладно.
[01:01:38.000 --> 01:01:40.000]  Хорошо.
[01:01:42.000 --> 01:01:44.000]  Дальше.
[01:01:44.000 --> 01:01:46.000]  Ну,
[01:01:46.000 --> 01:01:48.000]  что...
[01:01:48.000 --> 01:01:50.000]  Кажется, что basic usage закончился,
[01:01:50.000 --> 01:01:52.000]  действительно.
[01:01:52.000 --> 01:01:54.000]  И давайте...
[01:01:58.000 --> 01:02:00.000]  Да, правильно, это правда.
[01:02:00.000 --> 01:02:02.000]  Ну, давайте про это я тоже скажу.
[01:02:04.000 --> 01:02:06.000]  В basic usage.
[01:02:08.000 --> 01:02:10.000]  Вот.
[01:02:10.000 --> 01:02:12.000]  Ну, давайте действительно...
[01:02:12.000 --> 01:02:14.000]  Я могу написать так.
[01:02:14.000 --> 01:02:16.000]  Auto f равно вот это.
[01:02:16.000 --> 01:02:18.000]  То есть вот это
[01:02:18.000 --> 01:02:20.000]  все, это expression.
[01:02:20.000 --> 01:02:22.000]  Да, давайте я еще введу пару
[01:02:22.000 --> 01:02:24.000]  терминов.
[01:02:24.000 --> 01:02:26.000]  Вот это вот.
[01:02:26.000 --> 01:02:28.000]  Expression
[01:02:28.000 --> 01:02:30.000]  это длинное
[01:02:30.000 --> 01:02:32.000]  определение, что мы уже этот вопрос обсуждали
[01:02:32.000 --> 01:02:34.000]  неоднократно.
[01:02:34.000 --> 01:02:36.000]  Вот это вот называется
[01:02:36.000 --> 01:02:38.000]  lambda expression.
[01:02:38.000 --> 01:02:40.000]  Вот это все вместе.
[01:02:40.000 --> 01:02:42.000]  А тут круглоскобочка уже не нужна.
[01:02:42.000 --> 01:02:44.000]  Вот.
[01:02:44.000 --> 01:02:46.000]  А
[01:02:46.000 --> 01:02:48.000]  объект такого типа, как lambda expression,
[01:02:48.000 --> 01:02:50.000]  называется closure.
[01:02:50.000 --> 01:02:52.000]  Замыкание.
[01:02:52.000 --> 01:02:54.000]  Вот.
[01:02:54.000 --> 01:02:56.000]  Значит, closure.
[01:02:56.000 --> 01:02:58.000]  Ну, можно встретить такой термин.
[01:02:58.000 --> 01:03:00.000]  Значит, замыкание.
[01:03:00.000 --> 01:03:02.000]  Ну, замыкание
[01:03:02.000 --> 01:03:04.000]  это вот как раз
[01:03:04.000 --> 01:03:06.000]  эта штука, которая получается...
[01:03:06.000 --> 01:03:08.000]  Не-не, замыкание
[01:03:08.000 --> 01:03:10.000]  это объект того,
[01:03:10.000 --> 01:03:12.000]  что получается.
[01:03:12.000 --> 01:03:14.000]  Нет, closure это объект.
[01:03:16.000 --> 01:03:18.000]  Да, f это closure получается.
[01:03:18.000 --> 01:03:20.000]  По-моему.
[01:03:20.000 --> 01:03:22.000]  Я мог перепутать.
[01:03:22.000 --> 01:03:24.000]  Ну, просто слово closure
[01:03:24.000 --> 01:03:26.000]  иногда употребляется в применении к этому.
[01:03:26.000 --> 01:03:28.000]  Вы можете встретить там
[01:03:28.000 --> 01:03:30.000]  вот бла-бла-бла, вот я сделал замыкание
[01:03:30.000 --> 01:03:32.000]  и потом бла-бла-бла.
[01:03:32.000 --> 01:03:34.000]  Вот что такое замыкание?
[01:03:34.000 --> 01:03:36.000]  Объект lambda функции
[01:03:36.000 --> 01:03:38.000]  это closure.
[01:03:38.000 --> 01:03:40.000]  Что?
[01:03:40.000 --> 01:03:42.000]  Что?
[01:03:42.000 --> 01:03:44.000]  Нет, вот это
[01:03:44.000 --> 01:03:46.000]  это lambda expression.
[01:03:46.000 --> 01:03:48.000]  Но может создать объект
[01:03:48.000 --> 01:03:50.000]  такого типа, как это.
[01:03:50.000 --> 01:03:52.000]  Ну, это же expression.
[01:03:52.000 --> 01:03:54.000]  Оно
[01:03:54.000 --> 01:03:56.000]  порождает какой-то объект.
[01:03:56.000 --> 01:03:58.000]  Вот тот объект, который получается, значит closure.
[01:03:58.000 --> 01:04:00.000]  Какой у него тип?
[01:04:00.000 --> 01:04:02.000]  Непонятно.
[01:04:02.000 --> 01:04:04.000]  Ну, авто подойдет.
[01:04:04.000 --> 01:04:06.000]  Да.
[01:04:06.000 --> 01:04:08.000]  А, кстати, можно ли вот так написать?
[01:04:08.000 --> 01:04:10.000]  Да.
[01:04:10.000 --> 01:04:12.000]  Вы уже прониклись духом.
[01:04:12.000 --> 01:04:14.000]  Вот явно прониклись
[01:04:14.000 --> 01:04:16.000]  духом плюсов. Давайте начнем.
[01:04:16.000 --> 01:04:18.000]  Можно ли так?
[01:04:18.000 --> 01:04:20.000]  Да, это R-value, поэтому так не должно быть.
[01:04:20.000 --> 01:04:22.000]  По стандарту, конечно.
[01:04:22.000 --> 01:04:24.000]  Ну, в смысле,
[01:04:24.000 --> 01:04:26.000]  просто мы когда перечисляли expression,
[01:04:26.000 --> 01:04:28.000]  мы не упомянули lambda expression.
[01:04:28.000 --> 01:04:30.000]  Теперь давайте упомянем.
[01:04:30.000 --> 01:04:32.000]  Скажем, что lambda expression тоже
[01:04:32.000 --> 01:04:34.000]  и помянем, да.
[01:04:34.000 --> 01:04:36.000]  Lambda expression это тоже
[01:04:36.000 --> 01:04:38.000]  ну, constaft %f, разумеется, можно.
[01:04:38.000 --> 01:04:40.000]  По общему правилу.
[01:04:40.000 --> 01:04:42.000]  Ну, тоже можно.
[01:04:42.000 --> 01:04:44.000]  Вот, окей.
[01:04:44.000 --> 01:04:46.000]  Значит...
[01:04:46.000 --> 01:04:48.000]  А, че?
[01:04:48.000 --> 01:04:50.000]  Че?
[01:04:52.000 --> 01:04:54.000]  О, да.
[01:04:54.000 --> 01:04:56.000]  А че вы смеетесь?
[01:04:56.000 --> 01:04:58.000]  Мы будем этим заниматься скоро.
[01:04:58.000 --> 01:05:00.000]  Че же я? О, ноу!
[01:05:02.000 --> 01:05:04.000]  Что я тут делал?
[01:05:04.000 --> 01:05:06.000]  Зашел.
[01:05:06.000 --> 01:05:08.000]  Не хочу, нет.
[01:05:08.000 --> 01:05:10.000]  О, ноу.
[01:05:10.000 --> 01:05:12.000]  А вы зря смеетесь? Это, между прочим, не такая
[01:05:12.000 --> 01:05:14.000]  в смысле операция.
[01:05:14.000 --> 01:05:16.000]  В смысле, это действительно полезная вещь.
[01:05:16.000 --> 01:05:18.000]  Move lambda full, move объекты такие
[01:05:18.000 --> 01:05:20.000]  действительно иногда пригодны.
[01:05:20.000 --> 01:05:22.000]  То есть, это практически полезная штука.
[01:05:22.000 --> 01:05:24.000]  Окей. Ну, все.
[01:05:24.000 --> 01:05:26.000]  Можете создать объект такого типа.
[01:05:30.000 --> 01:05:32.000]  Да, у этого объекта определены круглые скобочки.
[01:05:32.000 --> 01:05:34.000]  От вот таких параметров,
[01:05:34.000 --> 01:05:36.000]  как тут написано.
[01:05:36.000 --> 01:05:38.000]  Можно в пункте с пишем структуру
[01:05:38.000 --> 01:05:40.000]  определяем операцию круглые скобочки.
[01:05:40.000 --> 01:05:42.000]  Вот, у нее какой-то непонятный тип.
[01:05:42.000 --> 01:05:44.000]  То есть, можно
[01:05:44.000 --> 01:05:46.000]  попробовать спросить компилятор,
[01:05:46.000 --> 01:05:48.000]  какой тип у этой вещи.
[01:05:48.000 --> 01:05:50.000]  Ну, то есть...
[01:05:50.000 --> 01:05:52.000]  Кстати, можно ли,
[01:05:52.000 --> 01:05:54.000]  если не дали непонятно что,
[01:05:54.000 --> 01:05:56.000]  вывести на экран его тип?
[01:05:56.000 --> 01:05:58.000]  Пожалуйста.
[01:05:58.000 --> 01:06:00.000]  Самый простой способ, это им звездочка,
[01:06:00.000 --> 01:06:02.000]  звездочка, звездочка, а равно вот этому.
[01:06:02.000 --> 01:06:04.000]  Я, знаете, наверное, я...
[01:06:06.000 --> 01:06:08.000]  Че, че, че, че?
[01:06:08.000 --> 01:06:10.000]  Ну, чтобы узнать тип,
[01:06:10.000 --> 01:06:12.000]  можно писать int звездочка, звездочка,
[01:06:12.000 --> 01:06:14.000]  звездочка, а равно это.
[01:06:14.000 --> 01:06:16.000]  И компилятор тебе выдаст ошибку и скажет,
[01:06:16.000 --> 01:06:18.000]  что ты попытался присвоить.
[01:06:18.000 --> 01:06:20.000]  Да, да, да, да, это правда, да.
[01:06:20.000 --> 01:06:22.000]  То есть, чтобы узнать тип,
[01:06:22.000 --> 01:06:24.000]  как он есть, это
[01:06:24.000 --> 01:06:26.000]  вы просто генерируете намеренно ошибку
[01:06:26.000 --> 01:06:28.000]  компиляции, и компилятор говорит вам, какой был тип.
[01:06:28.000 --> 01:06:30.000]  Тип main, когда скобочки не значены в этой точке,
[01:06:30.000 --> 01:06:32.000]  и в трехскобочках lambda.int, int.
[01:06:32.000 --> 01:06:34.000]  Ну...
[01:06:34.000 --> 01:06:36.000]  Ну, вот умный,
[01:06:36.000 --> 01:06:38.000]  это просто
[01:06:38.000 --> 01:06:40.000]  ну, это просто user-friendly
[01:06:40.000 --> 01:06:42.000]  компилятор тебе объясняет, что. На самом деле, конечно,
[01:06:42.000 --> 01:06:44.000]  тип называется у него не так, но просто
[01:06:44.000 --> 01:06:46.000]  в выводе лога компилятора он пишет так.
[01:06:46.000 --> 01:06:48.000]  Ну, я допомню, что еще есть
[01:06:48.000 --> 01:06:50.000]  оператор typeID. Ты всегда можешь спросить
[01:06:50.000 --> 01:06:52.000]  typeID от объекта
[01:06:52.000 --> 01:06:54.000]  и вывести точку name.
[01:06:54.000 --> 01:06:56.000]  Я вам, наверное, неправильно сказал
[01:06:56.000 --> 01:06:58.000]  closure, это кажется
[01:06:58.000 --> 01:07:00.000]  скорее... вот closure называет... ну, там
[01:07:00.000 --> 01:07:02.000]  путаница есть. Ну, closure
[01:07:02.000 --> 01:07:04.000]  еще называется тип вот того, что получилось как раз.
[01:07:04.000 --> 01:07:06.000]  Да, ну вот то ли тип, то ли объект.
[01:07:06.000 --> 01:07:08.000]  Вот кто-то называет объект,
[01:07:08.000 --> 01:07:10.000]  кто-то называет тип, словом closure.
[01:07:10.000 --> 01:07:12.000]  Тип того, что получилось.
[01:07:12.000 --> 01:07:14.000]  Так, а еще
[01:07:14.000 --> 01:07:16.000]  одна деталь. Вот, смотрите,
[01:07:16.000 --> 01:07:17.000]  есть
[01:07:17.000 --> 01:07:19.000]  объект, который называется
[01:07:19.000 --> 01:07:20.000]  type.
[01:07:20.000 --> 01:07:22.000]  Так, а еще
[01:07:22.000 --> 01:07:24.000]  одна деталь. Вот, смотрите, если я
[01:07:24.000 --> 01:07:26.000]  хочу лямбда функцию использовать как компоратор
[01:07:26.000 --> 01:07:28.000]  для мэпа,
[01:07:28.000 --> 01:07:30.000]  я могу так сделать?
[01:07:30.000 --> 01:07:32.000]  Вот я говорю map, допустим,
[01:07:32.000 --> 01:07:34.000]  от int, запятая int,
[01:07:34.000 --> 01:07:36.000]  запятая,
[01:07:36.000 --> 01:07:38.000]  и что тут надо написать?
[01:07:40.000 --> 01:07:42.000]  Ну, вот
[01:07:42.000 --> 01:07:44.000]  допустим, я тут
[01:07:44.000 --> 01:07:46.000]  вот это вот объявил, а потом
[01:07:46.000 --> 01:07:48.000]  такой map хочу
[01:07:48.000 --> 01:07:50.000]  с таким компоратором.
[01:07:50.000 --> 01:07:52.000]  Что я должен
[01:07:52.000 --> 01:07:54.000]  сделать?
[01:07:54.000 --> 01:07:56.000]  Декл-тайп от этого?
[01:07:56.000 --> 01:07:58.000]  Да, декл-тайп от этого, конечно.
[01:07:58.000 --> 01:08:00.000]  А оно сработает?
[01:08:00.000 --> 01:08:02.000]  Да.
[01:08:02.000 --> 01:08:04.000]  Почему?
[01:08:04.000 --> 01:08:06.000]  Почему?
[01:08:06.000 --> 01:08:08.000]  Мэп требует структуру.
[01:08:08.000 --> 01:08:10.000]  Да, мэп требует структуру.
[01:08:10.000 --> 01:08:12.000]  Мэп требует,
[01:08:12.000 --> 01:08:14.000]  он не примет.
[01:08:14.000 --> 01:08:16.000]  В смысле структуру?
[01:08:16.000 --> 01:08:18.000]  В смысле структуру, где определены
[01:08:18.000 --> 01:08:20.000]  квадраты.
[01:08:20.000 --> 01:08:22.000]  Что значит
[01:08:22.000 --> 01:08:24.000]  он требует?
[01:08:24.000 --> 01:08:26.000]  В мэп
[01:08:26.000 --> 01:08:28.000]  нельзя передать.
[01:08:28.000 --> 01:08:30.000]  В мэп есть шаблонный конструктор
[01:08:30.000 --> 01:08:32.000]  от cmp, который принимает cmp, так?
[01:08:32.000 --> 01:08:34.000]  Ну, так это мы и отдадим
[01:08:34.000 --> 01:08:36.000]  туда. Его тип будет совпадать
[01:08:36.000 --> 01:08:38.000]  с типом того, что мы отдали.
[01:08:38.000 --> 01:08:40.000]  В смысле про то, что нельзя передать bool.
[01:08:40.000 --> 01:08:42.000]  Вот, нельзя написать функцию bool
[01:08:42.000 --> 01:08:44.000]  и передать ее туда.
[01:08:44.000 --> 01:08:46.000]  Он тебе не разрешит.
[01:08:46.000 --> 01:08:48.000]  А, ты не можешь указательно
[01:08:48.000 --> 01:08:50.000]  функцию передать?
[01:08:50.000 --> 01:08:52.000]  В смысле сишную функцию ты не можешь
[01:08:52.000 --> 01:08:54.000]  передать?
[01:08:54.000 --> 01:08:56.000]  Ну да, это же объект,
[01:08:56.000 --> 01:08:58.000]  тип совпадает, значит я могу передать.
[01:09:02.000 --> 01:09:04.000]  Еще он будет ругаться, если там
[01:09:04.000 --> 01:09:06.000]  не конст, вроде
[01:09:06.000 --> 01:09:08.000]  не констант, а персант
[01:09:08.000 --> 01:09:10.000]  или что-то такое.
[01:09:10.000 --> 01:09:12.000]  Нет, не должен.
[01:09:12.000 --> 01:09:14.000]  Были какие-то сложности?
[01:09:14.000 --> 01:09:16.000]  Да, здесь
[01:09:16.000 --> 01:09:18.000]  надо поправить
[01:09:18.000 --> 01:09:20.000]  с констами, ну ладно.
[01:09:20.000 --> 01:09:22.000]  Ну, короче, нормально. Это должно работать.
[01:09:22.000 --> 01:09:24.000]  Это сработает.
[01:09:24.000 --> 01:09:26.000]  То есть, пожалуйста,
[01:09:26.000 --> 01:09:28.000]  лямбда функцию можно использовать как
[01:09:28.000 --> 01:09:30.000]  компаратор для мэпа.
[01:09:30.000 --> 01:09:32.000]  Вот таким образом.
[01:09:32.000 --> 01:09:34.000]  Вы создали f, локально,
[01:09:34.000 --> 01:09:36.000]  вы фактически создали локально функцию,
[01:09:36.000 --> 01:09:38.000]  функциональный объект такой,
[01:09:38.000 --> 01:09:40.000]  типа, который компилятор сам за вас
[01:09:40.000 --> 01:09:42.000]  сгенерировал. А дальше, пожалуйста, пользуйтесь им
[01:09:42.000 --> 01:09:44.000]  как надо.
[01:09:44.000 --> 01:09:46.000]  Окей, это был Basic Usage, ну давайте я расскажу
[01:09:46.000 --> 01:09:48.000]  немножечко не Basic Usage, тоже
[01:09:48.000 --> 01:09:50.000]  чуть-чуть.
[01:09:50.000 --> 01:09:52.000]  Ну, еще пока не Advanced,
[01:09:52.000 --> 01:09:54.000]  скорее Intermediate Usage.
[01:09:56.000 --> 01:09:58.000]  Давайте
[01:09:58.000 --> 01:10:00.000]  я пойду дальше,
[01:10:00.000 --> 01:10:02.000]  что?
[01:10:04.000 --> 01:10:06.000]  Так, следующий пункт
[01:10:06.000 --> 01:10:08.000]  это
[01:10:08.000 --> 01:10:10.000]  Capture
[01:10:10.000 --> 01:10:12.000]  List.
[01:10:16.000 --> 01:10:18.000]  Да.
[01:10:18.000 --> 01:10:20.000]  Ну, ты видимо знаешь, что это такое.
[01:10:20.000 --> 01:10:22.000]  Вот, что такое Capture List?
[01:10:22.000 --> 01:10:24.000]  Есть такое понятие
[01:10:24.000 --> 01:10:26.000]  захват в лямбда функцию.
[01:10:26.000 --> 01:10:28.000]  Capture.
[01:10:28.000 --> 01:10:30.000]  И вот это как раз то,
[01:10:30.000 --> 01:10:32.000]  зачем вот эти квадратные скобочки нужны были.
[01:10:32.000 --> 01:10:34.000]  Это, на самом деле, не просто так.
[01:10:34.000 --> 01:10:36.000]  Сюда тоже можно кое-что вписывать.
[01:10:36.000 --> 01:10:38.000]  Сейчас разберемся.
[01:10:38.000 --> 01:10:40.000]  Вот так по кодстайлу
[01:10:40.000 --> 01:10:42.000]  не надо делать.
[01:10:42.000 --> 01:10:44.000]  Отлично.
[01:10:44.000 --> 01:10:46.000]  Значит, смотрите.
[01:10:46.000 --> 01:10:48.000]  Давайте вообще
[01:10:48.000 --> 01:10:50.000]  поймем,
[01:10:50.000 --> 01:10:52.000]  что происходит.
[01:10:52.000 --> 01:10:54.000]  Что вообще это такое
[01:10:54.000 --> 01:10:56.000]  для компилятора?
[01:10:56.000 --> 01:10:58.000]  Это компилятор, когда это видят, он генерирует какой-то
[01:10:58.000 --> 01:11:00.000]  класс за вас, фактически,
[01:11:00.000 --> 01:11:02.000]  с оператором круглые скобочки вот от таких
[01:11:02.000 --> 01:11:04.000]  аргументов.
[01:11:04.000 --> 01:11:06.000]  А что, если я хочу здесь
[01:11:06.000 --> 01:11:08.000]  пользовать? Ну, вот скажем, у меня было
[01:11:08.000 --> 01:11:10.000]  тут еще какой-нибудь, не знаю,
[01:11:10.000 --> 01:11:12.000]  int c равно 5.
[01:11:12.000 --> 01:11:14.000]  И я хочу написать
[01:11:14.000 --> 01:11:16.000]  не так, а вот так.
[01:11:18.000 --> 01:11:20.000]  У меня c не является параметром
[01:11:20.000 --> 01:11:22.000]  функции, потому что вызывать я ее хочу от двух
[01:11:22.000 --> 01:11:24.000]  аргументов. Ну, то есть, я хочу, чтобы у меня
[01:11:24.000 --> 01:11:26.000]  функция была компаратором,
[01:11:26.000 --> 01:11:28.000]  сравнивающим два ключа.
[01:11:28.000 --> 01:11:30.000]  Но для ее работы
[01:11:30.000 --> 01:11:32.000]  нужен параметр,
[01:11:32.000 --> 01:11:34.000]  который не является параметром функции,
[01:11:34.000 --> 01:11:36.000]  а он скорее является некоторым,
[01:11:36.000 --> 01:11:38.000]  ну, некоторой фиксированной
[01:11:38.000 --> 01:11:40.000]  константой для данной функции.
[01:11:40.000 --> 01:11:42.000]  Но эта константа, она, например, вот отсюда
[01:11:42.000 --> 01:11:44.000]  везет.
[01:11:44.000 --> 01:11:46.000]  Если я так напишу... Да.
[01:11:46.000 --> 01:11:48.000]  Чего мы хотим?
[01:11:48.000 --> 01:11:50.000]  Ну, вот смотри, у меня есть компаратор.
[01:11:52.000 --> 01:11:54.000]  Пусть я после этих строчек
[01:11:54.000 --> 01:11:56.000]  поменяю c,
[01:11:56.000 --> 01:11:58.000]  и вызваю.
[01:11:58.000 --> 01:12:00.000]  Я хочу, чтобы в f, c
[01:12:00.000 --> 01:12:02.000]  поменялась или нет?
[01:12:02.000 --> 01:12:04.000]  Это разные варианты, да.
[01:12:04.000 --> 01:12:06.000]  Смотря по ссылке
[01:12:06.000 --> 01:12:08.000]  или по значению ты принял.
[01:12:08.000 --> 01:12:10.000]  Захватишь, да.
[01:12:10.000 --> 01:12:12.000]  Так вот, ну, вот если я так
[01:12:12.000 --> 01:12:14.000]  напишу сейчас, вот как сейчас напишу, то это не
[01:12:14.000 --> 01:12:16.000]  скомпилируется.
[01:12:16.000 --> 01:12:18.000]  Вот это будет c,
[01:12:18.000 --> 01:12:20.000]  потому что c
[01:12:20.000 --> 01:12:22.000]  из этой области видимости не видна,
[01:12:22.000 --> 01:12:24.000]  ее нет тут.
[01:12:24.000 --> 01:12:26.000]  c в мейне, но то, что в лямбда функции,
[01:12:26.000 --> 01:12:28.000]  это только a и b, вот c нету.
[01:12:28.000 --> 01:12:30.000]  Ну, еще глобальные переменные, понятно. То есть, грубо говоря,
[01:12:30.000 --> 01:12:32.000]  представлять себе это надо так.
[01:12:32.000 --> 01:12:34.000]  Компилятор сгенерировал класс
[01:12:34.000 --> 01:12:36.000]  и поставил его
[01:12:36.000 --> 01:12:38.000]  вот, типа, перед мейном.
[01:12:38.000 --> 01:12:40.000]  Ну, вот, примерно.
[01:12:40.000 --> 01:12:42.000]  И в этом классе
[01:12:42.000 --> 01:12:44.000]  все, что есть, это оператор круглые скобочки,
[01:12:44.000 --> 01:12:46.000]  от этих a и b
[01:12:46.000 --> 01:12:48.000]  и все, никого с c там нет.
[01:12:50.000 --> 01:12:52.000]  Правильно.
[01:12:52.000 --> 01:12:54.000]  Так вот, если я хочу, чтобы у меня в лямбда функции
[01:12:54.000 --> 01:12:56.000]  было доступно что-то из того, что было
[01:12:56.000 --> 01:12:58.000]  локально здесь доступно, мне надо в квадратные
[01:12:58.000 --> 01:13:00.000]  скобочки засунуть. И это называется
[01:13:00.000 --> 01:13:02.000]  capturing, захват в лямбду.
[01:13:02.000 --> 01:13:04.000]  Я здесь пишу c, причем я не пишу int,
[01:13:04.000 --> 01:13:06.000]  я пишу просто c в квадратных скобочках.
[01:13:08.000 --> 01:13:10.000]  И это означает, что у меня,
[01:13:10.000 --> 01:13:12.000]  когда лямбда функция создается,
[01:13:12.000 --> 01:13:14.000]  ну, когда создается этот объект,
[01:13:14.000 --> 01:13:16.000]  то у него в качестве поля
[01:13:16.000 --> 01:13:18.000]  присутствует вот эта c.
[01:13:18.000 --> 01:13:20.000]  То есть, получается,
[01:13:20.000 --> 01:13:22.000]  создается такой, генерируется такой функциональный объект,
[01:13:22.000 --> 01:13:24.000]  в котором a и b это параметры функционального вызова,
[01:13:24.000 --> 01:13:26.000]  а c это поле.
[01:13:26.000 --> 01:13:28.000]  Какого типа?
[01:13:28.000 --> 01:13:30.000]  Int. Такого же, как было это.
[01:13:30.000 --> 01:13:32.000]  Потому что типа этого было int.
[01:13:32.000 --> 01:13:34.000]  А я хочу нет.
[01:13:34.000 --> 01:13:36.000]  Ну нет,
[01:13:36.000 --> 01:13:38.000]  я нигде не передал
[01:13:38.000 --> 01:13:40.000]  type. Я передал это объект.
[01:13:40.000 --> 01:13:42.000]  Ну, того типа
[01:13:42.000 --> 01:13:44.000]  ты можешь, нет,
[01:13:44.000 --> 01:13:46.000]  ты можешь захватить в лямбду,
[01:13:46.000 --> 01:13:48.000]  смысл в чем? Ты хочешь, чтобы из лямбда тебе было
[01:13:48.000 --> 01:13:50.000]  доступно что-то из того, что было доступно
[01:13:50.000 --> 01:13:52.000]  локально. Ты хочешь в лямбде заиспользовать какие-то
[01:13:52.000 --> 01:13:54.000]  переменные, которые у тебя здесь были, помимо этих.
[01:13:54.000 --> 01:13:56.000]  Тогда ты их перечисляешь просто
[01:13:56.000 --> 01:13:58.000]  через запятую здесь.
[01:13:58.000 --> 01:14:00.000]  Ты спрашиваешь, а как мне сделать, чтобы эти перемены еще и другого типа
[01:14:00.000 --> 01:14:02.000]  были? Ну, не знаю.
[01:14:02.000 --> 01:14:04.000]  Например, захватить сюда, потом сказать
[01:14:04.000 --> 01:14:06.000]  double d равно c. Или здесь заранее
[01:14:06.000 --> 01:14:08.000]  сказать double d равно c. Это просто способ
[01:14:08.000 --> 01:14:10.000]  сделать себе здесь доступными что-то, что было
[01:14:10.000 --> 01:14:12.000]  здесь.
[01:14:18.000 --> 01:14:20.000]  К чему? К... А, можешь ли ты передать
[01:14:20.000 --> 01:14:22.000]  выражение?
[01:14:22.000 --> 01:14:24.000]  Ты можешь
[01:14:24.000 --> 01:14:26.000]  не совсем с таким синтаксисом начинать
[01:14:26.000 --> 01:14:28.000]  c++14, но в целом да.
[01:14:28.000 --> 01:14:30.000]  Ну, это
[01:14:30.000 --> 01:14:32.000]  будет еще один из следующих пунктов. То есть можно
[01:14:32.000 --> 01:14:34.000]  здесь написать на самом деле c равно чему-то
[01:14:34.000 --> 01:14:36.000]  и тогда он сам догадается, чему
[01:14:36.000 --> 01:14:38.000]  равно c. Какой
[01:14:38.000 --> 01:14:40.000]  типу c. Но это...
[01:14:40.000 --> 01:14:42.000]  Там некоторые есть с этим тонкости, которые
[01:14:42.000 --> 01:14:44.000]  мы, видимо, уже не сегодня обсудим. Вот, это
[01:14:44.000 --> 01:14:46.000]  я... Так вот теперь твой вопрос.
[01:14:46.000 --> 01:14:48.000]  А если я c поменяю после этого, то здесь оно
[01:14:48.000 --> 01:14:50.000]  поменяется или нет?
[01:14:50.000 --> 01:14:52.000]  А как сделать, чтобы поменялось?
[01:14:52.000 --> 01:14:54.000]  Да, персант нужно
[01:14:54.000 --> 01:14:56.000]  поставить перед c здесь.
[01:14:58.000 --> 01:15:00.000]  Вот это называется захват по ссылке.
[01:15:00.000 --> 01:15:02.000]  Бывает захват по значению,
[01:15:02.000 --> 01:15:04.000]  бывает захват по ссылке.
[01:15:04.000 --> 01:15:06.000]  Ну, в общем случае это выглядит
[01:15:06.000 --> 01:15:08.000]  так. Я пишу авто f
[01:15:08.000 --> 01:15:10.000]  равно... И тут в квадратных скобках
[01:15:10.000 --> 01:15:12.000]  перечисляю
[01:15:12.000 --> 01:15:14.000]  через запятую все, что я хочу
[01:15:14.000 --> 01:15:16.000]  захватить. Каждый из этого
[01:15:16.000 --> 01:15:18.000]  может быть как по ссылке, так и по значению.
[01:15:20.000 --> 01:15:22.000]  Вот.
[01:15:24.000 --> 01:15:26.000]  Поминали про просто равно
[01:15:26.000 --> 01:15:28.000]  и просто амперсант, да. Что если
[01:15:28.000 --> 01:15:30.000]  я не хочу перечислять...
[01:15:32.000 --> 01:15:34.000]  Ну, просто я хочу сказать, пусть
[01:15:34.000 --> 01:15:36.000]  мне будет в лямбда функции видно все, что
[01:15:36.000 --> 01:15:38.000]  было локально доступно.
[01:15:42.000 --> 01:15:44.000]  Ой, а вот это кстати
[01:15:44.000 --> 01:15:46.000]  я не помню.
[01:15:46.000 --> 01:15:48.000]  Нет, можно все захватить
[01:15:48.000 --> 01:15:50.000]  по ссылке, а что-то по значению, вот так
[01:15:50.000 --> 01:15:52.000]  можно, а все, кроме чего то, захватить
[01:15:52.000 --> 01:15:54.000]  такого вроде нельзя.
[01:15:54.000 --> 01:15:56.000]  Я могу написать вот так.
[01:15:56.000 --> 01:15:58.000]  Я могу написать просто
[01:15:58.000 --> 01:16:00.000]  амперсант
[01:16:00.000 --> 01:16:02.000]  в квадратных скобках
[01:16:02.000 --> 01:16:04.000]  Это будет означать, что все локальные переменные
[01:16:04.000 --> 01:16:06.000]  я захватываю по ссылке.
[01:16:06.000 --> 01:16:08.000]  А могу написать просто
[01:16:08.000 --> 01:16:10.000]  равно в квадратных скобках.
[01:16:10.000 --> 01:16:12.000]  Это будет означать, что все локальные переменные
[01:16:12.000 --> 01:16:14.000]  я захватываю по значению, т.е. они все копируются туда.
[01:16:14.000 --> 01:16:19.800]  Там просто будет столько полей, сколько у тебя локальных
[01:16:19.800 --> 01:16:21.440]  переменных, и все они туда скопируются.
[01:16:21.440 --> 01:16:30.800]  На каждой захваченной перемену у тебя поле в классе создастся
[01:16:30.800 --> 01:16:32.800]  функциональным, который компилятор сгенерирует.
[01:16:32.800 --> 01:16:33.800]  Да.
[01:16:33.800 --> 01:16:39.400]  Вот можно провести эксперимент и посмотреть, какой будет
[01:16:39.400 --> 01:16:41.600]  sizeof от f.
[01:16:41.600 --> 01:16:44.400]  Вот я утверждаю, что сейчас он будет 4, потому что там
[01:16:44.400 --> 01:16:46.640]  все, что есть, это одно поле int.
[01:16:46.640 --> 01:16:47.640]  Вот.
[01:16:47.640 --> 01:16:48.640]  Ну можно...
[01:16:48.640 --> 01:16:49.640]  Что?
[01:16:49.640 --> 01:16:50.640]  Нет.
[01:16:50.640 --> 01:16:51.640]  В смысле...
[01:16:51.640 --> 01:16:52.640]  Функция...
[01:16:52.640 --> 01:16:53.640]  Это просто...
[01:16:53.640 --> 01:16:54.640]  Нет, это просто метод класса.
[01:16:54.640 --> 01:16:55.640]  Вот.
[01:16:55.640 --> 01:17:09.920]  Ну да, можно написать вот так, там равно запитаем
[01:17:10.920 --> 01:17:12.840]  Это будет означать, что вы все захватили по значению,
[01:17:12.840 --> 01:17:13.840]  а вот с по ссылке.
[01:17:13.840 --> 01:17:21.840]  К чему именно?
[01:17:21.840 --> 01:17:23.840]  Да, конечно.
[01:17:23.840 --> 01:17:36.320]  f это объект, да.
[01:17:36.320 --> 01:17:38.600]  Ну на стеке у нее только поля лежат.
[01:17:38.600 --> 01:17:40.840]  А оператор он нигде не лежит.
[01:17:40.840 --> 01:17:42.880]  Это просто функция, которая сгенерирована комп...
[01:17:42.880 --> 01:17:43.880]  Ну как это?
[01:17:43.880 --> 01:17:44.880]  Это не виртуальная же функция?
[01:17:44.880 --> 01:17:46.880]  Если была виртуальная, то там бы началось.
[01:17:46.880 --> 01:17:51.880]  Если мы скажем, вернем объект f из функции.
[01:17:51.880 --> 01:17:52.880]  Да.
[01:17:52.880 --> 01:17:54.880]  Который захватил ее локальные перемены.
[01:17:54.880 --> 01:17:55.880]  Ты...
[01:17:55.880 --> 01:17:58.880]  Черт, Евгений, конечно, ты очень правильные вопросы
[01:17:58.880 --> 01:18:00.880]  задаешь, но это следующее, о чем надо здесь сказать.
[01:18:00.880 --> 01:18:01.880]  Ладно.
[01:18:01.880 --> 01:18:02.880]  Значит, все совершенно верно.
[01:18:02.880 --> 01:18:07.360]  Если вы вернете, то есть почему это опасно?
[01:18:07.360 --> 01:18:10.520]  Когда вы что-то захватываете в лямбду, начинается куча
[01:18:10.520 --> 01:18:13.560]  потенциальных проблем, поэтому нужно все делать очень
[01:18:13.560 --> 01:18:14.560]  аккуратно.
[01:18:14.560 --> 01:18:16.760]  Вот это следующая проблема, очевидная, которая возникает,
[01:18:16.760 --> 01:18:20.440]  что если вы были в какой-то функции, в которой создали
[01:18:20.440 --> 01:18:22.480]  лямбду, в которую захотели локальные перемены и по
[01:18:22.480 --> 01:18:26.880]  ссылке вернули лямбду наружу, локальные перемены уничтожились,
[01:18:26.880 --> 01:18:28.760]  конечно, вы получите битую ссылку, соответственно,
[01:18:28.760 --> 01:18:29.760]  битую...
[01:18:29.760 --> 01:18:32.760]  Ну вызов такой лямбда функции будет УБ.
[01:18:32.760 --> 01:18:35.760]  То есть понятно, это еще один способ выстрелить
[01:18:36.200 --> 01:18:39.360]  еще один способ сделать так, чтобы ссылка пережила
[01:18:39.360 --> 01:18:42.040]  время жизни того объекта, на который она ссылается.
[01:18:42.040 --> 01:18:43.040]  Понятно проблема, да?
[01:18:43.040 --> 01:18:47.120]  Если вы захватываете по ссылке, а то, что вы захватили
[01:18:47.120 --> 01:18:49.440]  умирает раньше, чем ваша лямбда, то понятно, у вас
[01:18:49.440 --> 01:18:50.440]  УБ.
[01:18:50.440 --> 01:18:51.440]  Будет битая ссылка.
[01:18:51.440 --> 01:18:55.160]  Но это еще не все, это еще не вся проблема.
[01:18:55.160 --> 01:19:09.160]  Давайте я сейчас вот что сделаю, скажу, что я нахожусь
[01:19:09.160 --> 01:19:23.080]  в классе, и это я в каком-то методе класса, но он автовозвращает.
[01:19:23.080 --> 01:19:31.560]  И в этом методе я такое беру и говорю, я, короче, захватываю
[01:19:31.560 --> 01:19:32.560]  что-то тут.
[01:19:32.560 --> 01:19:38.880]  То есть что я делаю, смотрите, я могу захватить, вот если
[01:19:38.880 --> 01:19:43.640]  я в объекте класса, вот в этом и вопрос, мне могут
[01:19:43.640 --> 01:19:47.920]  быть нужны поля класса, но поля класса, у меня в этом
[01:19:47.920 --> 01:19:53.480]  классе какие-то поля, там не знаю, int опять-таки a.
[01:19:53.480 --> 01:19:56.000]  Допустим я хочу в лямбда функции, вот сейчас я создаю
[01:19:56.000 --> 01:20:01.560]  лямбда функцию, и хочу тут вот там не знаю int b, и вернуть
[01:20:01.560 --> 01:20:04.000]  надо a умножить на b, ну вот я хочу, чтобы у меня было
[01:20:04.000 --> 01:20:05.000]  a отсюда доступно.
[01:20:05.000 --> 01:20:11.600]  Вопрос, как мне этого добиться, понятно, что если я так
[01:20:11.600 --> 01:20:13.280]  напишу, то никакого а не будет здесь.
[01:20:13.280 --> 01:20:40.920]  Тут есть вот какое правило, когда вы сюда что-то записываете,
[01:20:40.920 --> 01:20:47.040]  это может быть лишь локальные переменные, стековые переменные,
[01:20:47.040 --> 01:20:51.680]  нельзя захватить сюда, нельзя написать сюда a, потому
[01:20:51.680 --> 01:20:56.760]  что захватывать можно только переменные со стека, не
[01:20:56.760 --> 01:21:02.360]  поля класса, ну вот не отсюда, и не из какой-то там namespace,
[01:21:02.360 --> 01:21:05.720]  только вот с функцией, вот если у вас что-то локально
[01:21:05.720 --> 01:21:08.320]  было здесь, вы это можете захватить, поле вы не можете
[01:21:08.320 --> 01:21:12.720]  так захватить, но вы можете захватить this, то есть можно
[01:21:12.720 --> 01:21:13.720]  написать вот так.
[01:21:13.720 --> 01:21:21.440]  Это указатель, не важно как его захватить, по ссылке
[01:21:21.440 --> 01:21:22.440]  или по значению.
[01:21:22.440 --> 01:21:51.160]  Это ссылка на int, нет, минуточку, то, что ты пишем, не, это
[01:21:51.160 --> 01:21:56.360]  не expression, это не парсица так, амперсант c это не означает
[01:21:56.360 --> 01:22:00.080]  адрес c, это просто означает, это другой синтаксис совершенно,
[01:22:00.080 --> 01:22:03.360]  это совершенно забудь про это, амперсант c это просто
[01:22:03.360 --> 01:22:05.880]  означает, c захваченный по ссылке, это значит компилятор
[01:22:05.880 --> 01:22:09.560]  создает амперсант, создает int амперсант c, который там
[01:22:09.560 --> 01:22:12.560]  или отсылкой, это ничего общего не имеет с expression
[01:22:12.560 --> 01:22:13.560]  амперсант c.
[01:22:13.560 --> 01:22:17.800]  Так вот, еще раз, я не могу захватывать что-то, не
[01:22:17.800 --> 01:22:19.560]  являясь локальным переменом, могу захватывать только
[01:22:20.400 --> 01:22:24.600]  либо viz, вот еще такое правило, если я из класса хочу захватить
[01:22:24.600 --> 01:22:27.400]  поля, то я должен захватить viz, я не могу написать a как
[01:22:27.400 --> 01:22:28.400]  поле захватить.
[01:22:28.400 --> 01:22:34.680]  Вот поэтому, нет, viz стрелочка, я могу просто написать
[01:22:34.680 --> 01:22:38.960]  либо viz, то есть я могу написать viz и, допустим, запитая еще
[01:22:38.960 --> 01:22:44.000]  какие-то локальные штуки отсюда, по сути, чтобы захватить
[01:22:44.000 --> 01:22:47.160]  поля, у меня выбор только либо захватить viz, либо не
[01:22:47.160 --> 01:22:48.160]  захватывать viz.
[01:22:48.160 --> 01:22:52.160]  Нет, ну в плане, а пощипска к a внутри ляма функции,
[01:22:52.160 --> 01:22:53.160]  через viz?
[01:22:53.160 --> 01:22:54.160]  Просто через a.
[01:22:54.160 --> 01:22:55.160]  А это специальный синтаксис?
[01:22:55.160 --> 01:22:56.160]  Ну, ты специально специальный синтаксис?
[01:22:56.160 --> 01:22:57.160]  viz – это специальный синтаксис, да.
[01:22:57.160 --> 01:22:58.160]  Такой захват нам сразу дает доступ к этим переменам.
[01:22:58.160 --> 01:22:59.160]  А вот если мы напишем viz стрелочка, это не будет значит
[01:22:59.160 --> 01:23:00.160]  другое, потому что мы не можем захватывать viz?
[01:23:00.160 --> 01:23:01.160]  Нет, ну в плане, а пощипска к a внутри ляма функции
[01:23:01.160 --> 01:23:02.160]  может быть как?
[01:23:02.160 --> 01:23:03.160]  Просто через a.
[01:23:03.160 --> 01:23:04.160]  А это специальный синтаксис?
[01:23:04.160 --> 01:23:05.160]  Ну, ты специально специальный синтаксис?
[01:23:05.160 --> 01:23:06.160]  viz – это специальный синтаксис, да.
[01:23:06.160 --> 01:23:07.160]  Окей, все.
[01:23:07.160 --> 01:23:27.680]  Сейчас, я на самом деле засомневался, надо писать a или viz стрелочка
[01:23:27.680 --> 01:23:28.680]  a.
[01:23:28.680 --> 01:23:29.680]  Лучше проверьте.
[01:23:29.680 --> 01:23:31.240]  Я что-то засомневался, может быть, это не будет
[01:23:31.240 --> 01:23:34.240]  работать без viz.
[01:23:34.240 --> 01:23:36.560]  Ну понятно, что пока мы здесь, это нормально.
[01:23:36.720 --> 01:23:39.800]  Я написал a или viz стрелочка, это в принципе без разницы,
[01:23:39.800 --> 01:23:41.880]  ну просто что-то из этого может не скомпилироваться.
[01:23:41.880 --> 01:23:45.840]  Но я захватил viz, тем самым я как бы получил, ну я захватил
[01:23:45.840 --> 01:23:48.080]  фактически указатель на объект, через него я получаю
[01:23:48.080 --> 01:23:49.080]  доступ ко всем полям.
[01:23:49.080 --> 01:23:53.040]  Ну теперь я написал return f.
[01:23:53.040 --> 01:24:03.600]  И вот здесь в мейне такой, создал объект класса c, там
[01:24:03.640 --> 01:24:06.360]  от пяти, то есть это пронициализировал питью, допустим.
[01:24:06.360 --> 01:24:20.440]  Создал авто f равно, так, что я должен сделать?
[01:24:20.440 --> 01:24:28.840]  Ну я хочу, короче, создать ситуацию, что у меня f пережило
[01:24:28.840 --> 01:24:29.840]  объект.
[01:24:30.840 --> 01:24:34.600]  Ну то есть я могу сказать new, давайте я могу сказать
[01:24:34.600 --> 01:24:39.760]  так, c звездочка c равно, ну просто чтобы создать
[01:24:39.760 --> 01:24:42.520]  такую ситуацию искусственно, понятно, что это, c звездочка
[01:24:42.520 --> 01:24:52.960]  cp равно new c от пяти, дальше auto f равно cp стрелочка метод
[01:24:52.960 --> 01:25:01.680]  и метод там от, а что такое, кстати, b, а нет, все нормально,
[01:25:01.680 --> 01:25:08.000]  да, метод без параметров и значит дальше delete cp.
[01:25:08.000 --> 01:25:18.200]  Что будет после этого, если я вызову f?
[01:25:18.200 --> 01:25:21.280]  Ну правильно, да, то есть я могу захватить, то есть
[01:25:21.280 --> 01:25:25.200]  если я из класса захватываю, если я хочу захватить поля
[01:25:25.200 --> 01:25:31.480]  класса, то я захватываю viz по факту, и если я это
[01:25:31.480 --> 01:25:34.400]  все куда-то передаю или возвращаю наружу, то нужно
[01:25:34.400 --> 01:25:37.600]  следить за тем, чтобы этот класс не уничтожился, этот
[01:25:37.600 --> 01:25:43.040]  объект этого класса не уничтожился до того, как я буду пользоваться
[01:25:43.040 --> 01:25:44.040]  этой функцией.
[01:25:44.040 --> 01:26:02.960]  А как бы она это проверила?
[01:26:02.960 --> 01:26:08.000]  Ну как, ты видишь указатель, он какое-то числовое значение
[01:26:08.000 --> 01:26:10.280]  имеет, как ты поймешь под ним объект north или нет,
[01:26:10.280 --> 01:26:13.560]  кажется дежавю, мы, по-моему, это обсуждали сейчас назад,
[01:26:14.560 --> 01:26:21.560]  shared counter, vcounter заведет, да, вот это все, а просто захватит,
[01:26:21.560 --> 01:26:27.560]  господи, как мы его делали, enable shared from this, от this,
[01:26:27.560 --> 01:26:33.560]  что, пусть она захватывает не this, а что, что значит
[01:26:33.560 --> 01:26:36.560]  захватывает enable shared, вот здесь что написать надо,
[01:26:36.560 --> 01:26:41.560]  как эта функция называется, я не могу здесь написать
[01:26:41.560 --> 01:26:43.560]  метод, я не могу здесь написать expression, я здесь должен
[01:26:43.560 --> 01:26:45.560]  написать имя переменной либо this.
[01:26:45.560 --> 01:26:50.560]  Получается, если бы мы вообще захватили какой-нибудь
[01:26:50.560 --> 01:26:53.560]  локальный пример, поскольку это было бы еще хуже, потому
[01:26:53.560 --> 01:26:56.560]  что когда мы просто возвращаем уже обитая ссылка.
[01:26:56.560 --> 01:26:57.560]  Ну да.
[01:26:57.560 --> 01:27:05.560]  А если у нас есть параметры метода, их можно каптюлить?
[01:27:05.560 --> 01:27:08.560]  Да, по-моему, параметры можно.
[01:27:08.560 --> 01:27:20.560]  Ну да, так и будет эта ссылка у нас там пролезать,
[01:27:20.560 --> 01:27:23.560]  и если та штука уничтожится раньше, чем мы вызвали, ну
[01:27:23.560 --> 01:27:24.560]  беда.
[01:27:24.560 --> 01:27:27.560]  Ну хорошо, ладно, давайте, наверное, на сегодня закончим.
