[00:00.000 --> 00:09.600]  Ну что, давайте, наверное, начнем.
[00:09.600 --> 00:21.760]  Я напомню, что я сформулировал две важные теоремы, что
[00:21.760 --> 00:24.400]  множество общезначимых формул неразрешимо и что
[00:24.400 --> 00:28.360]  множество формул истинных в арифметике неперечислимо.
[00:28.360 --> 00:30.640]  Ну вот сегодня, наконец, мы доберемся до доказательств
[00:30.640 --> 00:32.200]  этих теорем.
[00:32.200 --> 00:39.720]  Начнем с неразрешимости общезначимых формул.
[00:39.720 --> 00:42.680]  Я напомню, что в прошлый раз, ну я там две буковки
[00:42.680 --> 00:49.960]  использовал, напомню, обе, я ввел ассоциативные
[00:49.960 --> 00:56.160]  исчисления, в том числе симметричные, вот тут имеется в виду как
[00:56.160 --> 00:59.760]  раз симметричная, давайте я какой-нибудь значок поставлю,
[00:59.760 --> 01:12.800]  и мы связываем с этими исчислениями такую задачу, проверка
[01:12.800 --> 01:19.880]  равенства, дано исчисление, то есть алфавит, правило
[01:19.880 --> 01:21.240]  и два слова.
[01:21.240 --> 01:24.740]  И спрашивается, можно ли построить одно слово, превратить
[01:24.980 --> 01:28.420]  одно слово в другое, подстановками, с помощью этих правил, применяемых
[01:28.420 --> 01:32.980]  в любом из направлений.
[01:32.980 --> 01:40.900]  Напомню также, что мы обсудили в прошлый раз, что с таким
[01:40.900 --> 01:46.480]  симметричным исчислением связана полугруппа, то
[01:46.480 --> 01:50.980]  есть множество с бинарной операцией, которая ассоциативна
[01:50.980 --> 01:54.720]  и в сущности вопрос о достижимости слова, это вопрос о равенстве
[01:54.720 --> 02:01.600]  слов в полугруппе.
[02:01.600 --> 02:06.480]  То есть мы смотрим на слова как на элементы, как представители
[02:06.480 --> 02:08.880]  классовой эквивалентности, которые сами по себе элементы
[02:08.880 --> 02:09.880]  полугруппы.
[02:09.880 --> 02:16.440]  И теперь я напомню обозначение, через valet обозначал множество
[02:16.440 --> 02:32.300]  описаний общезначимого формул, и сейчас я собираюсь
[02:32.300 --> 02:39.180]  доказать такую теорему, что вот это вот равенство
[02:39.180 --> 02:44.340]  слов в полугруппах сводится, м сводится к множеству
[02:44.340 --> 02:47.780]  общезначимых формул.
[02:47.780 --> 02:51.780]  Ну и тогда отсюда мы сразу получаем следствие, что
[02:51.780 --> 02:53.980]  множество общезначимых формул неразрешимо.
[02:53.980 --> 03:02.700]  Друзья, у нас получается такой более длинный путь
[03:02.700 --> 03:04.940]  для оказательства неразрешимости.
[03:04.940 --> 03:07.880]  Мы начинаем не с проблемой остановки машины тюринга,
[03:07.880 --> 03:12.000]  промежуточным образом доказываем эту вот проблему равенства
[03:12.000 --> 03:15.360]  слов в полугруппе, и ее уже сводим valet, но сводимость
[03:15.360 --> 03:18.880]  транзисивна, поэтому мы все равно получаем то, что
[03:18.880 --> 03:19.880]  нам нужно.
[03:19.880 --> 03:23.000]  Мы свели неразрешимую задачу к нашей, значит, наша тоже
[03:23.000 --> 03:24.000]  неразрешима.
[03:24.000 --> 03:28.200]  Ну, уже в прошлый раз у нас сводимости были, и на параллельном
[03:28.200 --> 03:30.800]  курсе теории алгоритма у вас сводимости тоже были,
[03:30.800 --> 03:34.080]  вы понимаете в целом, что нужно делать.
[03:34.080 --> 03:36.920]  Вот у нас есть, то есть что должна делать сводящая
[03:36.920 --> 03:37.920]  функция.
[03:38.600 --> 03:43.600]  Она должна получать описание полугруппы в виде порождающихся
[03:43.600 --> 03:47.280]  соотношений и строить как-то формулу.
[03:47.280 --> 03:55.560]  Ну, так, чтобы формула была общезначима тогда и только
[03:55.560 --> 04:10.360]  тогда, когда слово у достижимое и слово вы.
[04:10.360 --> 04:13.480]  Нужно, как обычно, побеспокоиться о тех словах, которые не
[04:13.480 --> 04:16.520]  являются описаниями симметричных исчислений.
[04:16.520 --> 04:21.140]  Ну, с этими словами мы поступим так же, как поступали в
[04:21.140 --> 04:23.400]  прошлый раз, отправим их в какую-нибудь формулу, которая
[04:23.400 --> 04:25.160]  не является общезначимой.
[04:25.160 --> 04:27.560]  На них ответ отрицательный, поэтому все что нам нужно
[04:27.560 --> 04:32.600]  это сопоставить им к какой-то конкретной формулу, которая
[04:32.600 --> 04:35.600]  не общезначима.
[04:35.600 --> 04:39.880]  Интересная часть, конечно, как задать, то есть по сути
[04:39.880 --> 04:43.160]  дела вопрос такой, как задать утверждениями первого
[04:43.160 --> 04:47.320]  порядка равенство слов в полугруппе.
[04:47.320 --> 04:49.320]  Ну, оказывается, это можно сделать.
[04:49.320 --> 04:50.360]  Я сейчас объясню как.
[04:50.360 --> 04:55.480]  Значит, наша формула будет состоять из нескольких
[04:55.480 --> 04:56.480]  частей.
[04:56.480 --> 05:00.760]  Да, нет, надо начать, конечно, с сигнатуры, это я поторопился.
[05:00.760 --> 05:04.320]  Такие части, если нет сигнатуры.
[05:04.320 --> 05:19.480]  Значит, сигнатура у нас будет бинарный предикатный символ
[05:19.680 --> 05:24.680]  и много унарных функциональных.
[05:24.680 --> 05:34.680]  Значит, сколько много?
[05:34.680 --> 05:39.320]  Я считаю, что алфавит, исчисление, это как раз вот эти символы
[05:39.320 --> 05:40.320]  есть.
[05:40.320 --> 05:43.320]  То есть для каждого символа алфавита я буду заводить
[05:43.320 --> 05:45.520]  специальный функциональный символ.
[05:45.520 --> 05:49.200]  И будет некоторый общепинарный символ, который, ну, по сути
[05:49.200 --> 05:50.840]  дела, будет отвечать за равенство.
[05:50.840 --> 05:55.240]  Ну, давайте выписывать, еще будет состоять формула.
[05:55.240 --> 05:57.520]  Значит, во-первых, нужно будет включить три конкретные
[05:57.520 --> 06:05.120]  формулы, ни от чего независящие, которые выражают просто
[06:05.120 --> 06:12.080]  условия рефлексивности, симметричности и транзитивности.
[06:12.080 --> 06:14.480]  Того отношения, которое задается этим предикатным
[06:14.480 --> 06:15.480]  символом.
[06:15.560 --> 06:28.560]  Ну, и что у нас там транзитивность?
[06:28.560 --> 06:30.800]  Условия совершенно обычные, я их особо подробно и не
[06:30.800 --> 06:34.200]  комментирую, потому что они уже и у нас встречались,
[06:34.200 --> 06:35.720]  и на упражнениях они встречались.
[06:35.720 --> 06:41.160]  Ну, и вообще это свойство, те свойства хорошо известны.
[06:41.320 --> 06:46.000]  Сами формулы, хотя последняя довольно длинная, но ничего
[06:46.000 --> 06:46.840]  в ней сложного нет.
[06:46.840 --> 06:51.960]  Эти части точно будут ходить в ФИ.
[06:51.960 --> 06:54.800]  Значит, я прямо где-нибудь здесь буду выписывать ФИ.
[06:54.800 --> 07:00.640]  В ФИ будет устроена так, конъюнция рефлексивности,
[07:00.640 --> 07:06.440]  симметричности и транзитивности, но это, конечно, не все.
[07:06.440 --> 07:10.120]  А что еще нам нужно?
[07:10.120 --> 07:15.160]  Нам понадобятся такие формулы.
[07:15.160 --> 07:19.480]  Их уже будет много, и они будут уже зависеть от алфавита
[07:19.480 --> 07:20.480]  исчисления.
[07:20.480 --> 07:31.000]  Для любого х, для любого у, из того, что х равен у,
[07:31.000 --> 07:35.080]  ну, я, говоря словами, буду не стесняясь говорить,
[07:35.080 --> 07:38.040]  что в отношении е находятся равные объекты, хотя это,
[07:38.040 --> 07:56.680]  в отношении эквивалентности, ну, что это за формулы?
[07:56.680 --> 08:01.480]  Они говорят, что функции, которые будут задаваться
[08:01.480 --> 08:04.520]  функциональными символами, согласованы с отношением
[08:04.520 --> 08:05.520]  эквивалентности.
[08:05.520 --> 08:08.320]  Если мы с новым эквивалентным x и y применяем функцию одну
[08:08.320 --> 08:13.400]  и ту же, то мы получаем снова эквивалентную.
[08:13.400 --> 08:17.680]  Эти условия согласования мы часто уже с этим сталкивались.
[08:17.680 --> 08:22.280]  По сути дела, мы хотим этим утверждением объяснить,
[08:22.280 --> 08:25.400]  что аито это функция не просто на носителе модели,
[08:25.400 --> 08:29.800]  ну, когда мы будем интерпретировать это, а она функция на классах
[08:29.800 --> 08:32.920]  эквивалентности, потому что это условие согласования
[08:32.920 --> 08:34.800]  гарантирует, что на всем классе эквивалентности
[08:34.800 --> 08:38.960]  это значение будет попадать в один и тот же класс эквивалентности.
[08:38.960 --> 08:44.400]  Ну и наконец, нам понадобятся сложные формулы.
[08:44.400 --> 08:51.840]  Давайте, значит, я вначале задам некоторый шаблон.
[08:51.840 --> 08:57.800]  Значит, вот есть, ну, раз у и в это у нас так и будет,
[08:57.800 --> 09:09.320]  у это, скажем там, у1, уn, v это v1, vn, и мы хотим написать
[09:09.320 --> 09:20.200]  такое равенство, ну, не равенство, формулу, значит, u1, u2, u3, еще
[09:20.200 --> 09:22.760]  вот мы так, сколько у нас тут есть символов, их разное
[09:22.760 --> 09:25.800]  может быть количество, разумеется, я извиняюсь,
[09:25.960 --> 09:30.120]  к иксу, скобки закрыли, это вот получается такой терм,
[09:30.120 --> 09:33.800]  то есть мы, это у нас функциональные символы, мы их применяем
[09:33.800 --> 09:36.120]  в том порядке, в котором они записаны в слове, ну, и в
[09:36.120 --> 09:37.480]  конце применяем к иксу.
[09:39.480 --> 09:42.600]  Да, и я извиняюсь, я забыл квантор.
[09:46.600 --> 09:47.480]  Тут стоит квантор.
[09:49.280 --> 09:52.760]  Но поскольку бинарный предикатный символ, надо писать
[09:52.760 --> 09:55.960]  вот что-то второе, второе это аналогичная цепочка
[09:55.960 --> 10:00.440]  применения функций, но уже тоже к иксу в конечном счете,
[10:00.440 --> 10:02.360]  но уже функции из второго слова.
[10:02.360 --> 10:09.720]  Вот такая формула, и давайте я где-нибудь здесь напишу
[10:09.720 --> 10:13.080]  сразу, как у нас устроены правила, правила это множество
[10:13.080 --> 10:19.880]  вот пар вот такого вида, u1, v1, и теперь к формуле я должен
[10:19.880 --> 10:22.840]  приписать, ну, во-первых, конъюнцию по всем и вот этих
[10:22.840 --> 10:30.360]  формул аитах, а во-вторых, конъюнцию по, ну, допустим,
[10:30.360 --> 10:35.480]  правила у нас там, не знаю, сколько, ну, там, r штук,
[10:35.480 --> 10:40.760]  конъюнцию там, значит, ну, тоже пусть будет по i, единицы
[10:40.760 --> 10:45.240]  до r, вот таких вот как раз формул, которые вот здесь
[10:45.320 --> 10:51.400]  вот написаны в виде шаблона, это все, вот это вот все,
[10:51.400 --> 10:54.840]  вся такая большая конъюнция, посылка нашей формулы,
[10:54.840 --> 10:58.840]  сама формула имеет вид импликации, а в заключение импликации
[10:58.840 --> 11:03.560]  мы напишем вот такую же формулу r, u, v, которая уже
[11:03.560 --> 11:07.320]  определяется по двум словам, которые у нас здесь даны,
[11:07.320 --> 11:10.520]  то есть по исчислению мы определяем посылку, а в
[11:10.520 --> 11:12.920]  заключение мы пишем вот то, что определяется этими
[11:12.920 --> 11:17.640]  двумя словами. Вот так будет выглядеть формула. Ну,
[11:17.640 --> 11:26.520]  понятно, что такая сводимость вычислима. Имея исчисления,
[11:26.520 --> 11:29.160]  написать такую формулу не очень сложно. Вот эти
[11:29.160 --> 11:32.840]  первые три формулы вообще константы, эти формулы,
[11:32.840 --> 11:36.600]  ну, надо просто знать набор функциональных символов,
[11:36.600 --> 11:39.880]  они выписываются, ну, а эти зависят от правил, но если
[11:39.880 --> 11:44.280]  у нас дано правило какое-то, что можно заменять на v и
[11:44.280 --> 11:47.400]  наоборот, ну, эта формула записывается вполне очевидным
[11:47.400 --> 11:53.240]  образом. Таким образом, мы построили сводимость,
[11:53.240 --> 11:55.600]  но теперь, чтобы она была корректной, нам нужно доказать
[11:55.600 --> 12:05.160]  вот это равенство. Давайте доказывать. Первое наблюдение.
[12:05.160 --> 12:10.800]  Поскольку формула является импликацией, если в какой-то
[12:10.800 --> 12:15.720]  модели посылка импликации ложна, формула истина. И
[12:15.720 --> 12:18.560]  такие модели никак не повлияют на то общезначимая формула
[12:18.560 --> 12:22.960]  или нет. Ну, в этих моделях она всегда истина, то есть
[12:22.960 --> 12:24.960]  если она и не общезначима, то по причине какой-то
[12:24.960 --> 12:28.120]  другой модели, где посылка все-таки истина. Значит,
[12:28.120 --> 12:32.280]  что значит, что посылка истина? Это означает, что у нас
[12:32.280 --> 12:39.600]  есть модель, и на этой модели есть отношение эквивалентности,
[12:39.600 --> 12:43.960]  как задают нам первые три формулы, и функции, которые
[12:43.960 --> 12:47.200]  задаются функциональными символами, их, естественно,
[12:47.200 --> 12:50.400]  продолжить до функции на отношениях эквивалентности.
[12:50.400 --> 12:53.480]  Вот эти правила согласования гарантируют нам, что для
[12:53.480 --> 12:56.200]  каждого класса эквивалентности применение функции АИТ будет
[12:56.200 --> 12:59.800]  давать элементы из какого-то определенного класса эквивалентности.
[12:59.800 --> 13:04.120]  Значит, определенная функция. А что нам говорят вот эти
[13:04.120 --> 13:11.200]  вот формулы? Ну, они говорят, что если я взял композицию
[13:11.200 --> 13:15.600]  в каком-то порядке функций и другую композицию, они
[13:15.600 --> 13:18.640]  говорят, что результаты одинаковые, то есть для
[13:18.640 --> 13:23.300]  любого х вот это равно, если мы переходим к классам
[13:23.300 --> 13:26.160]  эквивалентности, но это и означает, что функции
[13:26.240 --> 13:27.440]  просто одни и те же. То есть в любой модели, если посылка
[13:27.440 --> 13:33.160]  истины, мы получаем на самом деле вот некоторое множество
[13:33.160 --> 13:36.560]  классовых эквивалентности носителя этой модели, на
[13:36.560 --> 13:41.560]  нем функции, и вот теперь уже чтобы доказывать корректность,
[13:41.560 --> 13:45.440]  нужно разбираться вот с этими остальными формулами.
[13:45.440 --> 13:50.000]  Ну, хорошо, давайте посмотрим, пусть нам нужно два случая
[13:50.000 --> 13:53.840]  разобрать. Первый случай, что U такие равняются V вот
[13:53.840 --> 13:59.400]  в этой вот полугруппе G. А, проще не равняется начать.
[13:59.400 --> 14:04.480]  Давайте не равняется начать. Пусть U не равняется. Что
[14:04.480 --> 14:14.880]  тогда? Тогда я в качестве модели возьму саму полугруппу,
[14:14.880 --> 14:29.440]  а E это просто отношение равенства. На полугруппе
[14:29.440 --> 14:35.920]  определены функции. Как определены функции? Если
[14:35.920 --> 14:41.120]  у нас есть элемент полугруппы, мы просто умножаем слева
[14:41.120 --> 14:43.560]  в той записи, которая у меня используется на этот
[14:43.560 --> 14:51.080]  элемент. Конечно, это функция на полугруппе, левое умножение.
[14:51.080 --> 14:57.120]  Давайте посмотрим на посылку. Мы знаем, что слова UIT и VIT
[14:57.120 --> 15:03.000]  равны в полугруппе. Ну, тогда равны и соответствующие
[15:03.000 --> 15:08.680]  функции. Наблюдение очень простое, что если U равняется
[15:08.680 --> 15:15.160]  V, это равносильно тому, что U умножить на X, ну, я так
[15:15.160 --> 15:17.680]  пишу U умножить на X, чтобы не писать вот эту длинную
[15:17.680 --> 15:22.600]  композицию, а равняется, поскольку это просто в данном
[15:22.600 --> 15:25.760]  случае это просто умножение в полугруппе, равняется
[15:25.760 --> 15:29.760]  V на X для любого X. Ну, в одну сторону очевидно, если U
[15:29.760 --> 15:32.800]  равняется V, то, конечно, если вы еще справа на что-то
[15:32.800 --> 15:35.640]  умножаете, то ничего не испортится. А в другую
[15:36.040 --> 15:38.760]  сторону достаточно взять подходящий X и, например,
[15:38.760 --> 15:44.360]  пустое слово. U с пустым словом это U, V с пустым словом
[15:44.360 --> 15:50.520]  это V, значит, U равняется V. То есть посылка вся истинна.
[15:50.520 --> 15:57.080]  Но заключение как раз ложно, потому что мы же видим вот
[15:57.080 --> 16:01.360]  из этой эквивалентности, раз U не равняется V, то и
[16:01.360 --> 16:05.920]  вот эта вот формула R от U, V, она тоже ложна. Значит,
[16:05.920 --> 16:16.920]  мы получаем, что phi ложна. Ну, это такая более простая,
[16:16.920 --> 16:19.160]  сводимость в более простую сторону. Теперь давайте
[16:19.160 --> 16:25.120]  посмотрим в более сложную. Пусть уравняется V. Тогда
[16:25.120 --> 16:29.440]  мы знаем, что есть цепочка преобразований. Давайте
[16:29.440 --> 16:36.920]  как-нибудь переобозначим, скажем, Wn. Это вот наши правила
[16:36.920 --> 16:44.160]  нашего исчисления. В конце у нас что-то там, какое-то
[16:44.160 --> 16:51.880]  Wt, которое как раз равняется V. Мне в этом случае надо
[16:51.880 --> 16:57.240]  доказать, что формула абсолютно значима. То есть какая бы
[16:57.320 --> 17:00.400]  ни была модель, тут я мог выбрать модель, когда нужно
[17:00.400 --> 17:02.240]  доказать, что формула не общезначима, просто достаточно
[17:02.240 --> 17:04.840]  в одной модели сделать ее ложной. Теперь мне надо
[17:04.840 --> 17:07.800]  доказать, что она всегда истинна. Но опять-таки, если посылка
[17:07.800 --> 17:11.880]  ложна, то мы про это не думаем. Если посылка истинна, вот
[17:11.880 --> 17:15.520]  мы смотрим на эту ситуацию, у нас есть функции на классах
[17:15.520 --> 17:26.040]  эквивалентности. И что нам теперь нужно доказать?
[17:26.040 --> 17:33.200]  Нам нужно доказать, что если посылка истинна, то композиции
[17:33.200 --> 17:37.720]  слов, функции, отвечающих словам ui и vi равны. И тогда
[17:37.720 --> 17:43.440]  нужно доказать, что и композиции этих слов равны. Для этого
[17:43.440 --> 17:47.000]  надо проверить доказательства индукции по длине вот такого
[17:47.000 --> 17:49.800]  преобразования. Надо проверить, что на каждом шаге, если
[17:49.800 --> 17:57.760]  у нас было равенство, то и будет. То есть, если w i t получилось
[17:57.760 --> 18:03.840]  из w… w i plus 1 получилось из w i t, а то функции одни и
[18:03.840 --> 18:08.920]  те же. Ну, смотрите, давайте запишем w i t как что-то там
[18:08.920 --> 18:36.080]  w i plus 1 получается заменой u i t на v i t. Ну, я сейчас пишу
[18:36.080 --> 18:38.960]  применение правила слева направо, то есть u i t заменяется
[18:38.960 --> 18:42.680]  на v i t. Второй случай совершенно симметричный, если мы v i t заменяем
[18:42.680 --> 18:47.360]  на u i t. В чем рассуждение? Мы знаем, что функция… Давайте
[18:47.360 --> 18:50.480]  теперь я для краткости вот эти вот функции прям так
[18:50.480 --> 18:53.640]  и буду записывать, что это функция, отвечающая слову
[18:53.640 --> 19:00.840]  u, а это функция, отвечающая слову v. И вот мы знаем, что
[19:00.840 --> 19:05.920]  функция, отвечающая слову u i t и v i t одинаковая, а остальные
[19:05.920 --> 19:10.160]  вот эти две функции, они просто одни и те же. Мы же
[19:10.160 --> 19:14.000]  меняем только в одном месте. Ну, тогда функция, которая
[19:14.000 --> 19:18.280]  отвечает слову w i t, как она устроена? Она устроена
[19:18.280 --> 19:22.720]  как композиция функции p i t, композиция с функцией
[19:22.720 --> 19:27.440]  u i t и композиция с функцией s i t. А функция, которая отвечает
[19:27.440 --> 19:30.440]  и плюс первому, устроена как другая композиция
[19:30.440 --> 19:36.880]  p i, где просто в середине записана другая буква.
[19:36.880 --> 19:41.200]  Но вот эти функции равны, поскольку посылка наша
[19:41.200 --> 19:45.720]  истинна. И мы получаем, что w i t и w i plus 1 задают одну
[19:45.720 --> 19:47.880]  и ту же функцию, потому что мы берем композицию одной
[19:47.880 --> 19:51.960]  и той же функции, еще пары одинаковых функций и еще
[19:51.960 --> 19:53.840]  пары одинаковых функций. Ну, естественно, получаем
[19:53.840 --> 19:58.320]  одинаковые функции. Композиция – это функциональное преобразование
[19:58.760 --> 20:09.760]  функций. Значит, мы получаем, что все w i t от x совпадают
[20:09.760 --> 20:13.760]  и с u и с v. u и v – это начало и конец нашей цепочки, поэтому
[20:13.760 --> 20:20.920]  равенство транзитивно. Мы по транзитивности проходим
[20:20.920 --> 20:25.280]  по этой цепочке и получаем равенство. Значит, формула
[20:25.280 --> 20:30.080]  phi – истинна, потому что мы доказали, что истина
[20:30.080 --> 20:36.280]  заключения. Ну вот и все. Пришлось, в общем-то, довольно
[20:36.280 --> 20:39.680]  много потрудиться. Эта сводимость сама по себе не самая сложная
[20:39.680 --> 20:43.640]  часть. Прошлый раз было сложнее с этими счислениями,
[20:43.640 --> 20:46.600]  с переходом к симметричному варианту. Заметьте, что
[20:46.600 --> 20:50.300]  если не переходить к симметричному варианту, так просто записать
[20:50.300 --> 20:53.680]  формулы первого порядка уже не получится, потому
[20:53.760 --> 20:56.600]  что для отношений эквивалентности у нас есть простой способ
[20:56.600 --> 20:59.680]  задать их формулам первого порядка, а для произвольного
[20:59.680 --> 21:02.360]  ориентированного графа непонятно, как его задавать.
[21:02.360 --> 21:05.280]  И когда у нас есть какие-то подстановки односторонние,
[21:05.280 --> 21:07.720]  они могут задавать довольно сложный граф, и какие у
[21:07.720 --> 21:10.080]  него свойства мы заранее сказать не можем. А отношения
[21:10.080 --> 21:12.760]  эквивалентности обладают хорошими свойствами, легко
[21:12.760 --> 21:15.280]  выразивыми в терминах первого порядка.
[21:23.680 --> 21:35.120]  Я бы сказал не совсем. Что нам нужно доказать? Нужно
[21:35.120 --> 21:38.600]  доказать, что формула общезначима. Для этого мы должны взять
[21:38.600 --> 21:42.480]  какую-то модель и проверить, что формула истина. Мы
[21:42.480 --> 21:44.760]  сразу разбиваем на два случая. Первый случай
[21:44.760 --> 21:48.360]  посылка ложна, тогда формула истина. С этим случаем
[21:48.360 --> 21:51.480]  все очень просто. Второй случай посложнее, когда посылка
[21:51.480 --> 21:55.640]  истина. Но тогда мы сразу очень много знаем про модель.
[21:55.640 --> 21:59.880]  Мы знаем, что предикат E задает отношение эквивалентности,
[21:59.880 --> 22:07.320]  а функции a и t их можно определить и на классах эквивалентности.
[22:07.320 --> 22:09.640]  Они переносятся на классы эквивалентности. И более
[22:09.640 --> 22:13.760]  того, мы знаем, что композиции функций, отвечающих правилам
[22:13.760 --> 22:18.400]  замены, они задают одни и те же функции. Вот это
[22:18.480 --> 22:22.240]  последняя часть посылки. А нам нужно отсюда заключить,
[22:22.240 --> 22:25.680]  что тогда и у и в. Теперь мы утверждаем, что если вот
[22:25.680 --> 22:28.960]  такие композиции таких функций равны, то тогда и
[22:28.960 --> 22:33.920]  композиции функций, отвечающих у и в, равны. В сущности,
[22:33.920 --> 22:39.800]  по сути дела, мы так и поступаем. Но просто когда у и в недостижимы,
[22:39.800 --> 22:42.200]  то есть они неравны в полугруппе, нам проще просто предъявить
[22:42.200 --> 22:46.880]  пример вот саму полугруппу и сразу увидеть, что есть
[22:46.880 --> 22:48.640]  пример, когда они неравны. А если…
[22:48.640 --> 22:58.280]  Для любого икса тут существенно, что это же у нас функциональные
[22:58.280 --> 23:03.320]  символы, их надо к чему-то применить, поэтому мы переписываем
[23:03.320 --> 23:06.240]  равенство слов как равенство соответствующих функций.
[23:06.240 --> 23:13.840]  Ну и это применимо всегда, потому что мы дальше будем
[23:13.840 --> 23:17.120]  говорить о композициях этих функций, которые применимы
[23:17.120 --> 23:20.600]  к любому иксу. В модели на полугруппе это прям умножение
[23:20.600 --> 23:24.360]  на икс, ну а в другой модели это может… В общем, не сильно
[23:24.360 --> 23:27.000]  отличается, потому что все достаточно жестко задано,
[23:27.000 --> 23:32.960]  но там надо аккуратнее говорить, что там получается.
[23:32.960 --> 23:36.880]  Таким образом мы доказали. Давайте я где-нибудь здесь
[23:36.880 --> 23:42.040]  зафиксирую это. Вот оно у меня тут написано, но мне
[23:42.040 --> 23:45.120]  место будет нужно, в этом я хочу оставить. Теорема
[23:45.120 --> 23:55.880]  неразрешимых. И мы помним, что оно перечислимо, то есть
[23:55.880 --> 23:59.720]  это еще один пример, их много, перечислимых, неразрешимых
[23:59.720 --> 24:09.280]  множество. Следующая теорема, которую я собирался доказать,
[24:09.280 --> 24:19.760]  называется теорема Тарского, она утверждает, что неперечислимо
[24:19.760 --> 24:24.600]  множество формул, которые истинны в арифметике. Ну
[24:24.600 --> 24:28.080]  я сейчас напомню определение. Значит, арифметика это такая
[24:28.080 --> 24:30.640]  модель натуральных чисел, стандартная модель натуральных
[24:30.640 --> 24:38.480]  чисел с равенством, с умножением, со сложением, с нулем и единицей.
[24:38.480 --> 24:44.240]  И r это множество формул в сигнатуре арифметики,
[24:44.240 --> 24:58.000]  таких, что phi истинно. Тут, как мы видим, ситуация
[24:58.000 --> 25:04.720]  даже хуже. Мы перечислить эти формулы не можем, но
[25:04.720 --> 25:10.720]  как это доказать? Идея, конечно, остается той же. Нужно
[25:10.720 --> 25:15.720]  строить сводимость. Но сводимость чего? Значит, я сразу напишу
[25:15.720 --> 25:21.420]  чего, а потом сейчас немножко обсудим. Значит, сводимость,
[25:21.420 --> 25:26.480]  мы будем строить такой подходящей задачи. Это описание машин
[25:26.480 --> 25:31.760]  тьюринга, которые не останавливаются на пустом входе. То есть
[25:31.760 --> 25:41.440]  мы фиксируем вход и запускаем машину. Сейчас я напишу определение.
[25:41.440 --> 25:55.480]  Давайте я напомню, что h это язык остановки. h эпсилон
[25:55.680 --> 26:09.880]  это язык остановки на пустом входе. Ну и вот это вот h.
[26:09.880 --> 26:17.920]  No эпсилон это описание тех машин, которые не останавливаются
[26:17.920 --> 26:28.040]  на пустом входе. И нам, конечно, нужна лемма, что вот это самое множество, что оно
[26:28.040 --> 26:42.560]  неперечислимо. Потому что я буду потом доказывать, сводить это множество формулам
[26:42.560 --> 26:49.120]  арифметики. И мы знаем из теории алгоритмов, мы знаем, что m-сводимость
[26:49.120 --> 26:52.880]  уважает перечислимость. То есть если мы свели неперечислимое множество к какому-то,
[26:52.880 --> 26:56.640]  это множество тоже неперечислимо. То есть нам нужно знать неперечислимость
[26:56.640 --> 27:01.280]  этого множества. Ну это по сути дела упражнение уже в теории алгоритмов. Я поэтому
[27:01.280 --> 27:07.240]  только коротко напомню. У вас не было прям буквально такого в теории алгоритмов?
[27:07.240 --> 27:15.440]  Нет, не арифметику, что машины Тюринга, которые не останавливаются на пустом входе,
[27:15.440 --> 27:22.440]  неперечислимны. Ну я тогда очень быстро просто напомню, как это делается. Мы вначале строим
[27:22.440 --> 27:26.040]  сводимость проблем и остановки, проблем и остановки на пустом входе. Это тоже у вас
[27:26.040 --> 27:32.520]  почти заведомо было. Нам очень простая сводимость. Надо просто из машины и входа построить машину,
[27:32.520 --> 27:39.760]  которая работает так. Она вначале пишет эти символы х на вход, на пустом входе, а потом работает
[27:39.760 --> 27:49.040]  как предыдущая машина. Ясно, что это работает и с этим все хорошо. Дальше мы помним, что сводимость
[27:49.040 --> 27:58.280]  языков дает одновременно и сводимость дополнений. То есть у нас получается сводимость дополнения k
[27:58.280 --> 28:06.440]  к дополнению k. Тут есть единственная тонкость. Дополнение k это не совсем наш язык ашноу,
[28:06.440 --> 28:11.840]  потому что туда еще входят мусорные слова, которые не являются описаниями машин. Но эта
[28:11.840 --> 28:17.480]  проблема решается легко, потому что описание машин Тюринга разрешимы язык, поэтому нам
[28:17.480 --> 28:24.520]  нужно сводимость доопределить, отправив куда нужно мусорные слова, и мы получим как раз сводимость
[28:24.520 --> 28:29.280]  к тому, что нужно. А с арифметикой конечно у вас не было, это я сейчас буду объяснять. Это дело не
[28:29.280 --> 28:46.800]  такое быстрое на самом деле, но я надеюсь, что мы справимся. Тут конечно нужно... То есть фактически
[28:46.800 --> 28:53.960]  неформально, что мы утверждаем? Мы утверждаем, что высказывание о том, что машина Тюринга какая-то
[28:53.960 --> 28:58.800]  конкретная машина Тюринга не останавливается на пустом входе, можно выразить формулой первого
[28:58.800 --> 29:18.960]  порядка в арифметике. Неверно. Оно и дополнение к нему тоже неперечислимо. Ну смотрите, в арифметической
[29:19.440 --> 29:39.320]  иерархии. Сейчас, секунду. Хороший вопрос, не задумывался он. Нет, ну как, конечно, она
[29:39.320 --> 29:44.000]  потому и называется арифметическая. То есть нам нужен клантор всеобщенности, ну допустим,
[29:44.000 --> 29:49.760]  не останавливается. Для любого момента времени Т машина не останавливается. А условие неостановки,
[29:49.760 --> 29:58.240]  оно когда уже задано, оно мы сейчас увидим, оно записывается достаточно легко. Так что да, нет.
[29:58.240 --> 30:07.880]  Ну да, внутри будут кванторы, но можем посчитать глубину формулы, которая получится.
[30:14.000 --> 30:23.640]  Нет, она должна быть конечной. Сейчас напишем и увидим. Что не коперечислимо, на самом деле очень
[30:23.640 --> 30:31.320]  легко понять, потому что мы формулы от неформулы отличаем легко. То есть формулы образуют
[30:31.320 --> 30:36.040]  разрешимое множество. А что у нас с замкнутыми формулами может быть? Ну они либо истины,
[30:36.040 --> 30:42.640]  либо ложны. Поэтому дополнение с точностью довод разрешимого довеска это просто ложные формулы.
[30:42.640 --> 30:54.320]  Но формула истина тогда и только тогда, когда ее отрицание ложно. Поэтому дополнение это просто
[30:54.320 --> 31:01.320]  ложные формулы. То есть тут очень легко строится свадимость. То есть это и в одну, и в другую сторону,
[31:01.320 --> 31:12.400]  просто нарешиванием знака равенства. Что? Ну да, она где-то, она симметричная, то есть она в каком-то
[31:12.400 --> 31:17.240]  симметричном классе должна лежать. У нас получится какая-то формула, но будет симметрична,
[31:17.240 --> 31:23.000]  потому что за счет этой свадимости мы можем переписать с другими кванторами. Потому что когда мы
[31:23.000 --> 31:27.320]  навешиваем отрицание, потом, если мы навесили отрицание на формулу, которая начинается с квантора
[31:27.320 --> 31:30.680]  всеобщенности, когда мы это отрицание через квантор и перенесем, у нас получится квантор
[31:30.680 --> 31:37.040]  существования. Поэтому получится другой класс арифметической иерархии. Хорошо, а что значит нам
[31:37.040 --> 31:41.200]  нужно сделать? Нам нужно как-то выразить арифметические условия неостановки машины
[31:41.200 --> 31:48.280]  Turing. Ну и более-менее понятно, что основная сложность состоит в том, что машина Turing работает как-то
[31:48.280 --> 31:54.680]  долго. То есть мы не можем написать формулу, которая перечисляет все такты работы машины. Тем более,
[31:54.680 --> 32:03.600]  если она не останавливается, их будет бесконечно много. Эта проблема решаемая, и мы ее сейчас решим,
[32:03.600 --> 32:10.800]  но только начать надо с еще более простых предикатов. Вот у нас была алгебратарская,
[32:10.800 --> 32:16.560]  и она разрешимая, потому что там иллюминируется квантор. И это не доказывал, так только объяснил,
[32:16.560 --> 32:23.600]  что общая схема иллюминации кванторов тоже работает. Почему она проще, чем арифметика? Там
[32:23.600 --> 32:29.600]  разрешима, здесь даже не перечислима. Дело в том, что в арифметике есть деление с остатком. Это
[32:29.600 --> 32:36.920]  принципиальный момент. С действительными числами никакого аналога деления с остатком нет. У вас
[32:36.920 --> 32:45.800]  всегда все делится с остатком 0, если не равно нулю. А тут мы получаем такую формулу. Давайте я ее как
[32:45.800 --> 32:54.160] -нибудь res обозначу. Там x и y, то есть y делим на x, частная q, остаток r. Что это означает? Это
[32:54.160 --> 33:02.760]  означает, что y мы можем представить как q умножить на x плюс r. Ну и вдобавок, это у нас все натуральные
[33:02.760 --> 33:08.960]  числа, поэтому достаточно написать вот такое неравенство. Про неравенство давайте я сразу напомню,
[33:08.960 --> 33:14.920]  что хотя у меня его в сигнатуре нет, но что такое x меньше y, это мы понимаем такую формулу,
[33:14.920 --> 33:20.480]  что существует z. Меньше либо равно давайте я напишу. Ну а строгое неравенство естественно
[33:20.480 --> 33:29.000]  тоже выражается. Существует такой z, что y равняется x плюс z. То есть в случае натуральных чисел у нас
[33:29.000 --> 33:34.840]  нет проблемы, что мы ограничиваемся только равенством. Неравенство тоже выражается. Ну вот,
[33:34.840 --> 33:42.840]  это утверждение, что четверка чисел дает нам деление с остатком y на x. Отсюда сам остаток
[33:42.840 --> 33:50.400]  легко написать. А, тут лучше конечно давайте как-нибудь я div здесь напишу. Хочется рез сохранить
[33:50.400 --> 34:01.200]  для... собственно для остатка, потому что это мне придется писать какие-то формулы. Там лучше
[34:01.200 --> 34:15.960]  конечно рез иметь. Существует такое q, что div x, y, q, r. Ну я думаю понятно. Но отсюда можно написать
[34:15.960 --> 34:25.720]  утверждение о делимости. Тоже конечно слово div может появиться, но я исхищаюсь. Дивизор, делитель.
[34:25.720 --> 34:40.200]  Это значит, что существует такое q, что div x, y, q, 0. Ну самые обычные наши формулы. Значит в первой
[34:40.200 --> 34:46.680]  формуле я конечно написал наш обычный математический жаргон. По-хорошему надо написать формулу первого
[34:46.680 --> 34:54.600]  порядка. То есть как всегда в префиксной форме. То есть написать равенство как предикатный символ,
[34:54.600 --> 35:01.120]  затем два аргумента. Один y, а другой вот такой сложный терм, где мы применяем функцию умножения
[35:01.120 --> 35:06.160]  вначале, потом функцию сложения. Ну а там где написано меньше, надо вот ту формулу подставить.
[35:06.160 --> 35:13.720]  Но это достаточно очевидное преобразование. Я их для наглядности пропускаю. Отсюда я думаю понятно,
[35:13.720 --> 35:19.920]  что можно выразить предикат, что x простое. Просто взять определение простого числа и записать там
[35:19.920 --> 35:26.360]  ничего кроме отношения делимости не нужно. Более интересный вопрос возникает, если мы хотим выразить,
[35:26.360 --> 35:39.840]  ну скажем, такой предикат. Тернарный предикат, что x это какая-то степень y. Ну если это z
[35:39.840 --> 35:45.440]  фиксировано, скажем, 5, ну тогда это легкая формула. x равняется y, ну может на y там 5 раз. А если она
[35:45.440 --> 35:53.480]  произвольная? Не очень понятно, как записывать. Заметьте, что проблема проще, но близка к той,
[35:53.480 --> 35:58.240]  которую мы должны решать для машин тюринга, потому что тоже возникает, если мы будем писать
[35:58.240 --> 36:09.320]  обычным способом, то нам надо написать что-то такое. Нам нужно писать последовательность. Ну как
[36:09.320 --> 36:22.400]  определяется степень индуктивно, мы пишем вот так вот, и последнее у нас будет z. То есть вот
[36:22.400 --> 36:27.440]  такая рекуррентная последовательность, и x просто будет равен последнему члену этой последовательности.
[36:27.440 --> 36:37.440]  Вот нам нужно записать такую вещь. Но проблема в том, что последовательность это функция. Если бы
[36:37.480 --> 36:41.640]  у нас был функциональный символ, если бы у нас была логика второго порядка, и можно было бы
[36:41.640 --> 36:46.800]  брать кванторы по функциональным символам, могли бы сказать что-то такого типа. У нас есть функция,
[36:46.800 --> 36:56.920]  которая обладает вот такими вот свойствами. То есть f от i плюс 1 равняется y умножить на f от
[36:56.920 --> 37:07.920]  i, а x равняется f от z. И это и задавало бы нам соответствующее равенство. Но у нас был бы квантор
[37:07.920 --> 37:13.200]  по функциям, которые у нас запрещены. То есть вся проблема фактически в этом и состоит. Мы хотим
[37:13.200 --> 37:28.400]  ограничиться очень примитивной логикой и тем не менее доказать неперечислимость. Ну можно, конечно,
[37:28.400 --> 37:34.680]  спросить зачем связывать все руки. Ответ примерно такой. Мы не случайно логику первого порядка такую
[37:34.680 --> 37:41.400]  простую рассматриваем. Математики хотели убедиться, что они понимают, о чем они говорят, когда говорят о
[37:41.400 --> 37:46.440]  доказательствах. Поэтому они ограничили себя очень слабыми выразительными средствами, но
[37:46.440 --> 37:51.560]  достаточными, чтобы любые математические теоремы у них были выразимы. И я напомню, я про это уже
[37:51.560 --> 37:57.120]  говорил, программа была такая. Теперь мы, конечно, можем содержательно изучать математику, но если
[37:57.120 --> 38:02.880]  нас волнует вопрос, нет ли там ошибок, то нужно сделать очень просто. Можно все это переписать в
[38:02.880 --> 38:09.840]  таком формализме. И все математические теоремы превращаются в утверждение, что мы можем из одной
[38:09.840 --> 38:16.560]  цепочки символов по некоторым правилам сделать другую цепочку символов, построить доказательства. И тогда,
[38:16.560 --> 38:25.840]  если нам удастся построить такую аксиоматику, скажем, для арифметики, ну мы победили. Конечно,
[38:25.840 --> 38:32.880]  никто прям такие цепочки в таком примитивном виде строить не будет, но мы по крайней мере знаем,
[38:32.880 --> 38:38.520]  что если у нас какие-то сомнения будут потенциальные, мы такую цепочку написать можем. Эта программа не
[38:38.520 --> 38:44.640]  работает. Этим мы выясним. И теория Матарского это простейший намек на то, что эта программа не
[38:44.640 --> 38:52.960]  работает, потому что мы не можем перечислить истинные формулы. Это очень серьезное препятствие. И проблема в
[38:52.960 --> 39:00.680]  том, что, хотя наши формулы выглядят очень слабыми, там только кванторы по натуральным числам,
[39:00.680 --> 39:10.440]  а не по функциональным символам, но мы можем контрабандой поместить в эту самую арифметику
[39:10.440 --> 39:17.120]  первого порядка кванторы по конечным последовательностям. То есть прям в полном объеме
[39:17.120 --> 39:22.120]  логику второго порядка мы не можем лизовать произвольные функциональные символы. Но если
[39:22.120 --> 39:26.920]  нас интересует просто конечная последовательность, существует конечная последовательность, ну как в
[39:26.920 --> 39:35.000]  этом примере. Ну тогда мы это можем реализовать формулами первого порядка. Это удивительное
[39:35.000 --> 39:55.280]  открытие, которое сделал Гедель. И соответствующая лемма называется лемма бета функции Геделя. У него
[39:55.280 --> 40:04.240]  было много функций. Это вот называется бета функция. Но сейчас, наверное, будет перерыв. Давайте
[40:04.240 --> 40:09.960]  я даже формулировку не буду перед перерывом писать. Напишу после перерыва, докажу, и мы продолжим.
[40:09.960 --> 40:22.880]  А и прямо уже. Значит, в чем состоит лемма бета функции? Представьте, что у нас есть последовательность
[40:22.880 --> 40:38.520]  натуральных чисел. Утверждается, что ее можно задать тремя числами. В каком смысле? Вот в каком.
[40:38.520 --> 40:49.640]  Что для любого и, ну и понятно от единицы до n, разумеется, то есть для этой последовательности,
[40:49.640 --> 41:01.840]  выполняется такая вещь, что x и t сравнимо вот с этим числом a по модулю и умножить на b плюс 1. То есть
[41:01.840 --> 41:08.640]  мы задаем нашу последовательность так, мы задаем некоторое одно число, а потом берем его остатки
[41:08.640 --> 41:16.520]  по модулю некоторых чисел, принадлежащих некоторой в геометической прогрессии с разностью b. И остатки
[41:16.520 --> 41:21.880]  будут правильные. Это вот даже я давайте припишу именно остаток, ну чтобы была однозначность,
[41:21.880 --> 41:28.240]  потому что вообще-то сравнимость по модулю это неоднозначно, там много элементов сравнимо,
[41:28.240 --> 41:36.960]  а вот прямо остаток. Ну и это, заметьте, что вот я еще не стер на предыдущей доске, вот ясно,
[41:36.960 --> 41:44.000]  что вот эта формула, это условие точнее выразимо в арифметике. Ну одно число сравнимо с другим по
[41:44.000 --> 41:49.840]  модулю какого-то там несложного арифметического выражения, которое будет термом. Ну и получается так,
[41:49.840 --> 41:55.320]  что если мне нужно сослаться, мы чуть-чуть, когда я докажу Лему, мы это еще раз разберем, но я прямо
[41:55.320 --> 42:00.800]  сразу скажу, чтобы сослаться на x и t, мне нужно написать какую-то формулу такого вида и все будет
[42:00.800 --> 42:08.320]  хорошо. Как это сделать более конкретно, мы посмотрим. Давайте докажем бета-функцию. Ну Лему, а бета-
[42:08.320 --> 42:15.120]  функция это на самом деле не сложное упражнение в теории чисел или в алгебре. Давайте смотреть. Во-первых,
[42:15.120 --> 42:26.120]  я хочу гарантировать, чтобы b было больше любого x и t. Ну у меня остатки получаются по модулю b
[42:26.120 --> 42:32.600]  плюс 1, 2b плюс 1 и так далее, и я сразу хочу гарантировать, что b больше, чем x и t. Для этого я
[42:32.600 --> 42:42.440]  сделаю вот, что я возьму произведение всех x и t плюс 1, ну и по другой причине умножу, наверное,
[42:42.440 --> 42:52.200]  факториал. Вот такое b возьму. Просто b совершенно конкретно. С a чуть сложнее. Значит, чтобы найти a,
[42:52.200 --> 43:03.520]  я вначале хочу доказать такое утверждение, что числа в этой арифметической прогрессии взаимно
[43:03.520 --> 43:09.360]  просты, ну если они различные, если одинаковые, конечно, не могут быть взаимно просты. То есть,
[43:09.360 --> 43:14.080]  вся эта арифметическая прогрессия, ну первая ее энчленов, на самом деле невозможно писать
[43:14.080 --> 43:19.000]  бесконечную арифметическую прогрессию, в которой все члены были бы взаимно просты, но сколь угодно
[43:19.000 --> 43:28.440]  длинную, вот мы написали. Сейчас мы проверим. Почему так? Ну, смотрите, давайте рассмотрим разность этих
[43:28.440 --> 43:37.560]  двух чисел. Это будет и минус g, прошу прощения, на b. Правильно? Разность двух таких чисел, единички
[43:37.560 --> 43:47.200]  сократятся, останется разность и g умножить на b. Так вот, если есть простой делитель общий у этих
[43:47.200 --> 43:56.760]  чисел, то он, конечно, будет и простым делителем вот этого числа. Куда деваться. Но, смотрите, он тогда
[43:56.760 --> 44:02.200]  обязательно будет делителем b. Почему? Потому что он либо сразу делитель b, либо делитель вот этой
[44:02.200 --> 44:11.200]  разности. Но эта разность меньше n, а мы взяли b специально, так заранее умножили на n факториал,
[44:11.200 --> 44:20.000]  поэтому любое число меньше n, оно точно делитель b. Мы об этом позаботились. Значит, приходим к
[44:20.000 --> 44:34.720]  противоречию, потому что вот этот простой делитель, он будет делителем b, но, смотрите, тут у нас число,
[44:34.720 --> 44:42.360]  которое дает в пределении на b остаток 1. Не может простое число быть делителем b и делителем числа,
[44:42.360 --> 44:48.640]  которое дает остаток 1. Если оно делит b, то тогда число, которое мы единичку добавили, оно уж точно не
[44:48.640 --> 44:57.080]  будет на это простое число делиться. Вот такое доказательство от противного. Подождите, это мы
[44:57.080 --> 45:01.880]  проверили, что они взаимопростые, а что дальше? Ну, а дальше известное дело, дальше китайская
[45:01.880 --> 45:07.800]  тарелма об остатках. У нас есть условия, много условий, n штук, но эти условия позаимно простым
[45:07.800 --> 45:13.720]  модулем. Китайская тарелма нам говорит, есть такое число, а что мы все эти условия удовлетворим.
[45:13.720 --> 45:22.760]  Ну и все. Теперь давайте вернемся. Значит, это такая важная функция. Давайте вот посмотрим на примере
[45:22.760 --> 45:33.560]  возведения степень, как ее использовать. Смотрите, я хочу задать эту последовательность. Я это делаю так.
[45:33.560 --> 45:40.600]  Ну, длина у меня уже есть, поэтому я просто пишу, что существует a, существует b. Такие, что
[45:40.600 --> 45:53.160]  для любого и из того, что и, ну я опять-таки пишу обычные математические записи,
[45:53.160 --> 46:12.080]  и лежит вот в таком диапазоне, следует, что следует, следует, что, вот смотрите, мне теперь надо
[46:12.080 --> 46:19.240]  записать рекуррентное соотношение, как я это делаю. Я пишу, существует u, существует там, не знаю, t. Такие,
[46:19.240 --> 46:39.040]  что остаток отделения, значит, а у меня кодирует последовательность, а тут я должен написать и b плюс
[46:39.040 --> 47:00.320]  1, а остаток должен там равняться u, скажем, и остаток i плюс 1, b плюс 1, a, t, значит,
[47:00.320 --> 47:13.600]  вот должны выполняться такие условия, и, нет, лучше следует, лучше тут импликацию написать,
[47:13.600 --> 47:29.120]  то тогда t больше, t равняется y. Это я записал рекурренту, и нужно еще написать отдельно формулу,
[47:29.120 --> 47:41.240]  но я могу с теми же переменными, потому что это, тут вот будет вот такое вот условие, что остаток по
[47:41.240 --> 47:58.880]  модулю z, b плюс 1, а какой-то u, а, ну тут достаточно одного u, и u равняется x. Давайте смотреть,
[47:58.880 --> 48:06.360]  что эта формула означает. Ну, вот эта вот часть, она как раз задает нам рекуррентные условия. Я
[48:06.360 --> 48:12.240]  хотел бы в этом месте написать, вот как я там писал, что следующий член равен предыдущему умножить
[48:12.240 --> 48:18.040]  на y, но буквально я так написать не могу, потому что мне пришлось бы писать что-то такого типа
[48:18.040 --> 48:25.480]  t и плюс первое равно t и t умножить на y. Это вот если вводить функциональные символы,
[48:25.480 --> 48:33.080]  было бы вот так, очень просто записано. Что я делаю вместо этого? Я заменяю, используя функцию
[48:33.080 --> 48:38.560]  йодоля, я заменяю обращение к функциональному символу на такую формулу. Я приписываю кванторы
[48:38.560 --> 48:46.000]  существования по вспомогательным переменным, которые будут как раз указывать на вот эти вот
[48:46.000 --> 48:55.240]  значения вот этих термов. Я говорю, что для них выполняются условия бета функции йодоля, а потом
[48:55.240 --> 49:15.720]  пишу. Нет, тут все-таки нужно конъюнсу написать, а то будет плохо. Нам нужно, чтобы все эти три условия
[49:15.720 --> 49:27.440]  выполнялись. Ну да, как я и написал во второй части. И дальше я пишу уже вот с подставленными
[49:27.440 --> 49:30.960]  этими вспомогательными переменными вместо соответствующих функциональных символов.
[49:30.960 --> 49:36.560]  Почему это одно и то же? Смотрите, мы считаем, что у нас существует вот некоторые a и b,
[49:36.560 --> 49:45.360]  которые кодируют нашу последовательность. А дальше вот здесь остаток же определен однозначно,
[49:45.360 --> 49:52.800]  поэтому такое у, чтобы это было истинным, оно единственное. И ты оно единственное. И у нас
[49:52.800 --> 49:57.960]  конъюнс еще с третьим условием, что они друг другом соотносятся к умножению на какое-то число.
[49:57.960 --> 50:05.800]  Поэтому это получается равносильное утверждение. Ну и последнее, это просто другая тамарная формула,
[50:05.800 --> 50:11.840]  что последний член последовательности равен x, вот как у меня здесь написано. Здесь мне тоже нужно
[50:11.840 --> 50:21.040]  заменить обращение к члену последовательности по индексу на вот такую вот выражение, что у нас
[50:21.040 --> 50:28.520]  есть квантор существования по вот такому предикату. Ну это конкретный пример с возведением степени.
[50:28.520 --> 50:36.920]  Но я надеюсь, становится понятным, что так же можно действовать всегда. Если у вас есть какое-то
[50:36.920 --> 50:42.640]  логическое условие, в котором есть квантор по конечным последовательностям, тут существенно,
[50:42.640 --> 50:49.080]  что мы должны знать ограничение длину последовательности, то мы его можем, мы соответствующую формулу,
[50:49.080 --> 50:55.720]  можем превратить формулу первого порядка, заменив квантор по, вот у нас по-хорошему должен
[50:55.720 --> 51:06.080]  был быть квантор, существует t с некоторым свойством. А я его заменяю такую вот формулу,
[51:06.080 --> 51:12.200]  дальше что-то, вот на такую, где в каждую атомарную формулу делается вот подстановка
[51:12.200 --> 51:20.280]  такого же вида, как здесь. Получаем равносильную формулу, то есть мы получаем возможность выразить
[51:20.280 --> 51:30.040]  утверждение, которое требует использования каких-то последовательностей в виде формулы первого
[51:30.040 --> 51:36.080]  порядка. Вот это очень мощный прием, он на самом деле объясняет, почему арифметика очень выразительная.
[51:36.080 --> 51:42.560]  В арифметике можно самые разные утверждения сформулировать. Ну, например, можно сформулировать
[51:42.560 --> 51:49.080]  формулу арифметики, которая задает асимпатический закон распределения простых чисел. Если вы помните
[51:49.080 --> 52:00.800]  это вот что такое, это π от n это количество простых чисел, которые не превосходит n. Значок
[52:00.800 --> 52:05.920]  эквивалентности здесь, это самый обычный смысл анализа, то есть отношения с тремецкие единицы. Ну,
[52:05.920 --> 52:13.680]  а n это n, а ln это натуральный алгорифм. То есть кажется удивительным, что натуральный алгорифм
[52:13.680 --> 52:19.760]  появляется в пределы. Вот это можно записать в виде формулы арифметики. Используя последовательности.
[52:19.760 --> 52:25.120]  И идею вы уже можете так примерно оценить, что такое предел. Ну, это предел последовательности,
[52:25.120 --> 52:31.240]  значит мы знаем, что для любого эпсила найдется достаточно длинная последовательность, которая
[52:31.240 --> 52:36.680]  хорошо приближает, так можно задать логарифм. Также можно примерно задать саму функцию π от n.
[52:36.680 --> 52:41.600]  То, что их отношения близко к единице тоже можно задать, это тоже некоторое предельное соотношение,
[52:42.080 --> 52:53.080]  которое вот таким вот образом выражается. Нет, у нас только натуральные числа. То есть асинтетические
[52:53.080 --> 52:59.320]  законы распределения простых чисел это про натуральные числа утверждение. Логарифм это так.
[52:59.320 --> 53:08.200]  Логарифм можно выразить, но опять-таки в сущности нужно научиться выражать,
[53:08.360 --> 53:14.800]  число е, которое является пределом, замечательным пределом. Это тоже можно выразить как последняя
[53:14.800 --> 53:20.920]  степень, точнее как отношение. Нам все время нужны рациональные числа, но смотрите, рациональное число
[53:20.920 --> 53:28.560]  это пара целых. И в сущности переписать что-то про рациональные числа в виде утверждений про
[53:28.560 --> 53:35.280]  натуральные достаточно легко. А если нам нужны знаки, ну это еще один бит. Знак всегда можно к
[53:35.280 --> 53:41.760]  натуральному числу добавить. Итак, исторически удобно считать, что мы имеем натуральные числа,
[53:41.760 --> 53:47.840]  которые начинаются с нуля, для индукции. Поскольку для нас основной прием, я говорил про рифметику
[53:47.840 --> 53:53.120]  Пиано, там помимо тривиальных свойств, свойств рифметических операций есть аксиома индукции,
[53:53.120 --> 53:58.680]  а ей нужен ноль. Поэтому логики предпочитают смотреть только на неотрицательные целые числа. Но
[53:58.680 --> 54:04.960]  выразить отрицательный никакой труда нет, если у нас есть все эти возможности формул первого
[54:04.960 --> 54:12.560]  порядка. Хорошо, но нам симпатический закон не нужен, нам нужна машина тюринга, точнее условия,
[54:12.560 --> 54:19.840]  что она не останавливается. И вот теперь я наконец выхожу на финишную прямую в доказательстве
[54:19.840 --> 54:25.600]  теории Амитарского. И тут придется повозиться, потому что ну это так не то чтобы это кажется
[54:25.600 --> 54:32.240]  очень удивительным, но что-то надо сделать, потому что как представить в виде формулы, рифметики,
[54:32.240 --> 54:38.000]  утверждение о том, что машина тюринга не останавливается. Ну давайте представлять,
[54:38.000 --> 54:44.720]  то есть фактически мне нужно построить сводимость. У меня есть машина, которая я напомню, у нас
[54:44.720 --> 54:53.120]  значит там что, алфавит, множество состояний, пустой символ, маркер начала, начальное состояние,
[54:53.200 --> 55:02.240]  финальное состояние, ну и функция переходов. И вот нам надо по такой машине строить опять-таки
[55:02.240 --> 55:11.680]  такую-то формулу в рифметике, которая истинна в рифметике, если машина не останавливается.
[55:11.680 --> 55:22.080]  Ну как это сделать? Во-первых, конечно, нужно как-то машинокомбинаторное понятие,
[55:22.160 --> 55:28.640]  хорошо бы его как-то в числовое превратить. Сейчас я покажу как. Это удобная такая вещь. Я напомню,
[55:28.640 --> 55:39.480]  что конфигурации машины я задавал вот такими словами, где у и в это слова в алфавите, а q это
[55:39.480 --> 55:50.000]  состояние. То есть правило то же самое, что было в прошлый раз. Мы у и в записываем подряд и считаем,
[55:50.000 --> 55:56.960]  что головка находится на первом символе слова v, а правее на ленте, правее символа слова v уже
[55:56.960 --> 56:09.360]  только пусты. Вот такое соглашение. Это конфигурация. Ну теперь мне нужны числа, и я сопоставлю этой
[56:09.360 --> 56:25.440]  конфигурации три числа. Напишу их как функции. Ну q, а c это q. Это легко. У нас всегда есть выделенный q.
[56:25.440 --> 56:32.120]  Чтобы писать дальше, мне сразу нужно договориться о том, какие множества являются алфавитом,
[56:32.120 --> 56:41.440]  какие множеством состояний. Давайте считать, что символы алфавита это числа от нуля до какого-то
[56:41.440 --> 56:56.160]  n-1. Состояние это, ну, следующее число. То есть от n до какого-то числа q. И сразу договоримся,
[56:56.160 --> 57:01.080]  что пустой символ у нас означает ноль, это нам будет удобно, ну а маркер начала-конца пусть
[57:01.080 --> 57:10.440]  будет обозначать единицу, это уже не столь существенно. То есть я первым делом привожу алфавит к числовому
[57:10.440 --> 57:17.160]  виду. Ну понятно, что вопрос об остановке и неостановке машины Тюринга от того, что я переименовал
[57:17.160 --> 57:22.200]  символы алфавита, и состояние никак не изменится. Ну потому что я точно также естественную функцию
[57:22.200 --> 57:33.440]  переходов переопределю. Теперь давайте смотреть. Вот у нас есть лента, вот сюда смотрит головка,
[57:33.440 --> 57:50.360]  вот это вот слово V, это слово U. И вот L это такое число. Мы смотрим на U, как на иночную запись
[57:50.360 --> 58:02.680]  некоторого числа. Ну самым обычным образом, младший бит справа. А R, C определяется чуть хитрее. Это
[58:02.680 --> 58:11.800]  тоже запись, но в другом порядке. Вот тут у нас младшие биты вот здесь, а тут у нас младшие биты
[58:11.800 --> 58:19.440]  слева стоят. Ну я это записал с помощью функции обращения, то есть V от R это значит, что мы слово
[58:19.440 --> 58:25.680]  записали просто в другом порядке. Ну и я предполагаю обычный для математики способ записи, когда старшие
[58:25.680 --> 58:32.200]  разряды идут левее. На самом деле удобнее, чтобы они левее шли, и младшие разряды, но так уж мы
[58:32.200 --> 58:39.680]  привыкли. Давайте какой-нибудь конкретный пример. Вот пусть у нас есть конфигурация. Ну какая, значит
[58:39.680 --> 58:49.720]  у нас маркер конца, во-первых, должен быть, потом 2, 2, 4, 2, 2. Вот это слово задает конфигурацию. Значит,
[58:49.720 --> 58:58.880]  здесь у нас мы видим, что N, ну мы можем положить 3 или, нет, 4 уже не можем. N должно равняться 3,
[58:58.880 --> 59:04.880]  потому что смотрите, у нас хотя бы один символ должен быть в символовом состоянии, а то 4. Но тогда,
[59:04.880 --> 59:15.400]  а нет, ну можем, нет, можем 3. Ну пусть будет равно 3. Для простоты тогда нам нужно что сделать,
[59:15.400 --> 59:27.720]  значит Q это 4, а L это что? Это троичная запись, число, троичная запись, которого 1, 2, 2, это значит 2,
[59:27.720 --> 59:39.520]  это 6, это 8 и еще 9, 17. Ну а R, а ну тут вот давайте я, чтобы было понятно, несимметрично напишу,
[59:39.520 --> 59:46.200]  0, 2. R тогда я должен прочитать в другом порядке, справа налево, снова взять троичную запись,
[59:46.200 --> 59:56.520]  и это будет просто 3 умножить на 2, 6. Вот такие функции. Эти функции почти однозначно задают
[59:56.520 --> 01:00:01.720]  конфигурацию. Давайте подумаем, какую информацию о конфигурации мы теряем. Вот пусть у нас есть
[01:00:01.720 --> 01:00:10.200]  3 числа. Состояние просто задано, это одна из функций. Теперь смотрим на L и R. L это то, что написано
[01:00:10.200 --> 01:00:20.440]  слева от головки, причем последний символ должен быть обязательно единицей. У нас есть маркер
[01:00:20.440 --> 01:00:26.920]  конца, я напомню, слева. Так что тут все однозначно. А справа немножко сложнее, потому что у нас
[01:00:26.920 --> 01:00:37.560]  конечно есть вот это вот слово, которое отвечает о нычной записи R, C. Но вообще говоря, тут могли
[01:00:37.560 --> 01:00:43.520]  стоять еще нули, допустим. Ну и на ленте тоже вот может быть такой бесконечный суффикс из нулей,
[01:00:43.520 --> 01:00:51.400]  из пустых символов. Но это не страшно, потому что мы знаем, что если мы дописываем нулевые цифры
[01:00:51.400 --> 01:00:56.920]  в нычное представление числа, то этого не изменится. Ну в смысле, дописываем самые старшие разряды. Мы
[01:00:56.920 --> 01:01:04.160]  же теперь читаем справа налево, то есть у нас это попадает в старшие разряды, допустим, 2, 0 и,
[01:01:04.160 --> 01:01:11.440]  там скажем, 0, 2, 0. Но это одно и то же число. Поэтому теряем мы информацию, которая нам и не
[01:01:11.440 --> 01:01:17.120]  очень нужна. На самом деле состояние ленты мы по этой тройке чисел восстанавливаем однозначно.
[01:01:17.120 --> 01:01:29.760]  Ну это хороший шаг. Что дальше? Дальше нужно понять, как меняются эти функции за такт работы.
[01:01:41.440 --> 01:01:48.240]  Я утверждаю, что они меняются просто. Просто в том смысле, что изменения можно арифметическими
[01:01:48.240 --> 01:01:53.720]  условиями задавать. Ну так же, как в прошлый раз. У нас есть разные команды переходов,
[01:01:53.720 --> 01:01:59.000]  поэтому мы должны рассмотреть несколько случаев. Допустим, исполняется такая команда.
[01:01:59.000 --> 01:02:15.560]  То есть у нас было вот это вот слово В, самый левый его символ А, вот тут вот слово У. Оно никак не
[01:02:15.560 --> 01:02:23.160]  меняется, значит у нас что изменилось? Тут стало а штрих, у не изменилось, ну оставшаяся часть В
[01:02:23.160 --> 01:02:33.840]  тоже не изменилась. Что произойдет с функциями? Ну давайте смотреть. Значит это у нас была
[01:02:33.840 --> 01:02:40.160]  конфигурация С, это стала конфигурация С штрих. Q от С штрих чему равно? Ну Q штрих, ясное дело,
[01:02:40.160 --> 01:02:48.640]  у нас состояние поменялось на Q штрих. Чему равняется L от С штрих? Тому же самому, что и было.
[01:02:48.640 --> 01:02:56.480]  Слово У у нас вообще не изменилось, головка не сдвинулась. А R изменяется. Давайте посмотрим,
[01:02:56.480 --> 01:03:02.840]  как оно изменяется. Мы должны в самом младшем бите, ну не бите, а там нити,
[01:03:02.840 --> 01:03:12.280]  слово В заменить цифру А на цифру А штрих. Как это делается? Делается это так, мы должны взять
[01:03:12.600 --> 01:03:37.040]  это R от С штрих, взять R от С, вычесть А. А что такое А? А у нас нет. Но у нас есть возможность взять
[01:03:37.040 --> 01:03:46.640]  остаток по модулю N. То есть мы берем R от С и берем остаток по модулю N. Что такое первая цифра в
[01:03:46.640 --> 01:03:55.840]  н-ичной записи? Это остаток отделения числа на N. Так всегда, в любой системе счисления. Ну вот,
[01:03:55.840 --> 01:04:00.840]  то есть мы вычили А, а добавить должны А штрих. Это мы уже можем вот прям так написать, потому что
[01:04:00.840 --> 01:04:06.840]  А штрих — это некоторый конкретный символ, мы его просто так вот как число и добавим. Отлично.
[01:04:06.840 --> 01:04:14.640]  Давай теперь посмотрим, что будет, если мы хотим выразить команду движения, ну куда. Ну давайте,
[01:04:14.640 --> 01:04:25.680]  обычно проще вправо. Давайте посмотрим. Значит, снова решу такую картинку. Значит,
[01:04:25.680 --> 01:04:39.920]  тут у нас А, вот тут В штрих, тут У, тут стоит головка. Теперь мы сдвинулись вправо. Вот само
[01:04:39.920 --> 01:04:44.800]  слово В штрих, от этого движения не изменилось. Изменился вот этот символ. У тоже не изменился,
[01:04:44.800 --> 01:04:50.880]  но изменилось положение головки. Значит, что у нас произойдет с нашими функциями,
[01:04:50.880 --> 01:04:59.280]  которыми кодируется конфигурация. Ну, у изменилось так, как написано в правиле перехода, это всегда так.
[01:04:59.280 --> 01:05:16.400]  А как Р изменилось? Давайте смотреть. Было У, теперь мы сдвинули все на разряд, увеличили,
[01:05:16.400 --> 01:05:22.960]  и на самый младший разряд добавили А штрих. Что это такое? Это такая вещь. Это мы добавили А
[01:05:22.960 --> 01:05:44.600]  штрих плюс Н умножили на РС. А штрих теперь часть У. Мы вправо сдвинули. То есть Р от С
[01:05:44.600 --> 01:05:56.480]  штрих, это Н ищенная запись вот такая. У, а потом А штрих. Все, извиняюсь, извиняюсь,
[01:05:56.480 --> 01:06:03.440]  извиняюсь. Все правильно. Я имел в виду Л, а говорил Р. Все, прошу прощения. С Р хитрее. С Р надо
[01:06:03.440 --> 01:06:14.000]  подумать, что будет, но не сказать, что очень сложно. Мы должны просто-напросто поделить. Смотрите,
[01:06:14.000 --> 01:06:21.880]  мы забываем последний разряд. Это то же самое, что целочистное деление на Н. То есть мы должны
[01:06:21.880 --> 01:06:34.320]  взять Р от С, ну и давайте я как-нибудь это напишу вот так. Див на Н. Заметьте, что все эти условия,
[01:06:34.320 --> 01:06:39.520]  которые я выписываю в рифметике, очень легко выражаются. Ну вот я уже стер вот эти вот простейшие
[01:06:39.520 --> 01:06:45.240]  предикаты. Ну ясно, что целочистное деление, взятие остатка, это все выражается с помощью тех предикатов,
[01:06:45.240 --> 01:07:09.440]  которые я описал. Теперь последний случай. Как мы помним с прошлого раза, он менее приятный.
[01:07:09.440 --> 01:07:26.920]  С 2х влево. Ну тут нужно, значит вот у нас где-то стоит головка. В штрих, тут у, а с штрих. Теперь у
[01:07:26.920 --> 01:07:38.560]  нас головка переехала на один символ сюда. Здесь написано штрих, ну а здесь по-прежнему написано
[01:07:38.560 --> 01:07:46.900]  в штрих. Как это записать? Ну опять-таки нет проблем записать функцию Q, потому что просто Q
[01:07:46.900 --> 01:07:55.800]  штрих. Теперь давайте смотреть с L. Что у нас получается с L? Мы оставляем, ну вот так же как вот
[01:07:55.800 --> 01:08:07.880]  здесь, мы оставляем только часть Q, которая отвечает всему за исключением младшего разряда. Значит мы
[01:08:07.880 --> 01:08:21.400]  должны писать L с, ну вот поделить на N. Потому что вот это уже будет входить в новое V. А что
[01:08:21.400 --> 01:08:27.800]  такое это? Давайте теперь вот самое сложное, это записать R с штрих. Значит тут у меня написано
[01:08:27.800 --> 01:08:36.920]  что-то, давайте я B обозначу. Ну что такое B, мы знаем. B это просто-напросто L с по модулю N. Это
[01:08:36.920 --> 01:08:48.200]  вот B. Оно заведомо добавится. Дальше нам нужно заменить A штрих на A, но это вот как в самом первом
[01:08:48.200 --> 01:08:54.480]  случае. Мы должны писать вот такую довольно замысловатую формулу. Никуда нам от этого не
[01:08:54.480 --> 01:09:15.760]  деть сам R с минус R с по модулю N. Нет, ну можно сразу, можно сразу здесь написать плюс A штрих. То есть можно
[01:09:15.760 --> 01:09:21.160]  же себе это представить так, что мы вначале заменили A на а штрих, вот как в самом первом случае,
[01:09:21.160 --> 01:09:27.840]  не двигая головку. А потом головку сдвинем. Сдвиг головки даст нам умножение на N и добавится вот
[01:09:27.840 --> 01:09:37.280]  это вот самое B. Ну формулы выглядят уже все сложнее и сложнее, но они закончились. Значит у нас
[01:09:37.280 --> 01:09:43.040]  команды трех типов. И этих команд конечное количество. Давайте вернемся к началу, к машине.
[01:09:43.040 --> 01:09:53.160]  Там есть функция дельта, функция переходов. Это набор пар. Первый элемент пары символ алфавита,
[01:09:53.160 --> 01:10:01.240]  то есть число от 0 до N-1. Второе состояние число от N до Q. Соответственно мы можем написать формулу.
[01:10:13.040 --> 01:10:27.520]  От шести параметров. Которая истина тогда и только тогда, когда штрихованные параметры выражаются
[01:10:27.520 --> 01:10:33.800]  через нештрихованные, ну вот соответственно с таблицей перехода в машины Q. Почему мы это можем
[01:10:33.800 --> 01:10:39.600]  сделать? Для того, чтобы применять эти правила нам нужно знать A. Ну про A мы знаем, что это такое,
[01:10:39.600 --> 01:10:48.720]  мы это уже использовали. Это просто-напросто R от C по модулю N. Соответственно мы должны взять
[01:10:48.720 --> 01:11:01.800]  дизьюнцию по всем правилам, там по парам AQ. Каких условий? Что A вот равняется R от C по модулю N.
[01:11:01.800 --> 01:11:11.360]  Ну по Q даже можно не брать, Q у нас есть. Давайте Q я сотру вот дизьюнцию по A. Но конечно не только
[01:11:11.360 --> 01:11:18.880]  это условие, а нужно еще дописать вот условия, как-нибудь звездочка напишу. Одну из этих трех
[01:11:18.880 --> 01:11:28.200]  условий. Какое зависит от пары Q и A? То есть тут будет как-то так выглядеть. Значит,
[01:11:28.200 --> 01:11:41.840]  ну да, все-таки мне нужно написать дизьюнцию еще и по каким-нибудь там tilde Q и A таким,
[01:11:41.840 --> 01:11:54.240]  что вот сдвиг 0. И тут дописывать еще условия, что tilde SQ равняется Q. Потом аналогичную дизьюнцию
[01:11:54.240 --> 01:12:02.360]  сдвиг плюс 1 и аналогичную дизьюнцию сдвиг минус 1. То есть у нас получится такая довольно сложная
[01:12:02.360 --> 01:12:08.440]  логическая формула, но булева. То есть мы получаем дизьюнцию условий. Почему нас устраивает дизьюнция?
[01:12:08.440 --> 01:12:15.560]  Потому что это же однозначно определенная вещь. То есть из этих членов будет истинной только 1. То
[01:12:15.560 --> 01:12:24.480]  есть мы A и Q выберем однозначно способом. А потом уже есть условия связи штрихованных и не
[01:12:24.480 --> 01:12:30.600]  штрихованных. Если какое-то из условий нарушается, ну формула ложна. То есть мы неправильно записали
[01:12:30.600 --> 01:12:50.280]  переход. Прошу прощения. Я заговорился и написал ерунду. Нет, чтобы было понятно из предыдущего,
[01:12:50.280 --> 01:13:06.840]  нужно конечно писать LR и Q'L'R'. Прошу прощения. То есть у нас функции Q, L и R. И вот мы их и задаем.
[01:13:06.840 --> 01:13:15.480]  Но вот этот момент, он очень важный. То есть в сущности он критически важный. Теперь у нас
[01:13:15.480 --> 01:13:19.960]  появилась арифметическая формула, которая выражает корректность перехода от одной тройки к другой.
[01:13:19.960 --> 01:13:30.200]  Тройка задает состояние машины. Как теперь записать условия, что машина остановилась за Т-тактов?
[01:13:30.200 --> 01:13:57.280]  Нам нужно писать так. Для любого И из того, что И меньше Т, следует
[01:13:57.280 --> 01:14:07.600]  вот этот вот, что у нас корректно выполнен шахт перехода.
[01:14:27.280 --> 01:14:38.360]  Но это еще не все. Еще нужно потребовать выполнения начального условия. Какие у нас начальные условия?
[01:14:38.360 --> 01:14:53.360]  Но я напомню в начале. У нас состояние это N, а тут пусто, но вот здесь есть единица, маркер конца.
[01:14:53.360 --> 01:15:06.560]  Поэтому мы должны написать так, что L от нуля равно единице и R от нуля равно нулю и код нуля равно N.
[01:15:06.560 --> 01:15:18.920]  Это начальные условия. Чего нам еще не хватает? Еще нам не хватает условий остановки, что И по Q,
[01:15:18.920 --> 01:15:25.240]  принадлежащим множеству финальных состояний, должно выполняться вот такое условие. Q равняется код T.
[01:15:25.240 --> 01:15:34.800]  Последнее состояние финальное. Вот это условие остановки за Т-тактов. Конечно, я его пишу,
[01:15:34.800 --> 01:15:42.840]  используя функциональные символы. Но для этого вспомним про лему йоделя. То есть на самом деле,
[01:15:42.840 --> 01:15:47.720]  вместо вот этих трех функциональных символов мне пришлось бы написать так.
[01:16:12.840 --> 01:16:21.520]  И дальше, там, где вот я пишу, у меня есть вот такая формула, куда входит 6 выражений с атомарными символами.
[01:16:21.520 --> 01:16:28.520]  Я должен также, как в примере со степенями, повесить соответствующее количество кванторов, выразить,
[01:16:28.520 --> 01:16:38.920]  что вот эти вот места, которые у нас заполнены, они выражаются по бета-функции йоделя через номера.
[01:16:38.920 --> 01:16:45.760]  Ну и дописать то условие, которое у нас в формуле степь, там будут какие-то условия. Вот получается
[01:16:45.760 --> 01:16:51.800]  такая достаточно сложная вещь. Ну и здесь то же самое нужно сделать, избавиться от L, R и Q.
[01:16:51.800 --> 01:17:02.080]  Ну получается вот такая достаточно сложная формула, но она выражает остановку за Т-тактов.
[01:17:02.080 --> 01:17:11.560]  А нам нужна формула, которая выражает не остановку. Давайте вот эту вот всю формулу с остановкой
[01:17:11.560 --> 01:17:24.880]  стоп назову. Ну даже Т я не буду писать, потому что и так параметры-то видно. Для любого Т не стоп.
[01:17:24.880 --> 01:17:35.480]  Вот нужная нам формула. Смотрите, если я по машине построил такую формулу, вот как у меня написано,
[01:17:35.480 --> 01:17:43.280]  что она означает? Что какое бы я не взял число Т, условие остановки будет нарушено.
[01:17:55.760 --> 01:18:03.880]  Условие остановки означает, что мы можем подобрать такие функции или вот такие 6 чисел, чтобы
[01:18:03.880 --> 01:18:09.480]  выполнялись вот эти вот условия. Машины останавливаются тогда и только тогда, когда мы
[01:18:09.480 --> 01:18:15.280]  такой подбор можем сделать. Ну значит она не останавливается за Т-тактов, если взять отрицание этой
[01:18:15.280 --> 01:18:30.040]  формулы. Ну и это доказывает сводимость. То есть мы построили по машине Тюринга, построили
[01:18:30.040 --> 01:18:38.720]  формулу, которая истинна в арифметике, если и только если машина не останавливается на входе.
[01:18:45.280 --> 01:18:50.760]  Ну значит и ремонтарского доказано. Заодно можем выяснить на какой уровне арифметической
[01:18:50.760 --> 01:18:55.320]  иерархии это все дело попадает. Смотрите, мы берем отрицание этой формулы, значит кванторы
[01:18:55.320 --> 01:19:04.160]  существования превратятся в кванторы всеобщенности. Тут появится квантор существования, но здесь опять
[01:19:04.160 --> 01:19:08.400]  появятся кванторы всеобщенности. Вот когда мы делали постановки, помните, там нам были нужны кванторы
[01:19:08.400 --> 01:19:16.360]  существования. Значит получится что-то такого типа. Для любого существует это вот этот, и потом
[01:19:16.360 --> 01:19:36.920]  еще раз для любого. Ну и мне кажется, что все. Нет, он нужен, конечно, значит тут будет стоять
[01:19:36.920 --> 01:19:45.480]  существует, но он вот сюда вот сюда уйдет, как квантор всеобщенности. В общем, я не поручусь,
[01:19:45.480 --> 01:19:50.640]  но вроде бы на третий уровень. То есть это надо, конечно, аккуратнее расписать. Не поручусь,
[01:19:50.640 --> 01:19:54.560]  потому что там еще нужно посмотреть, не произойдет ли какого-то взаимодействия. Вроде бы нет,
[01:19:54.560 --> 01:19:59.320]  мы все кванторы существования просто запишем однородно. Здесь действительно есть квантор
[01:19:59.320 --> 01:20:11.840]  всеобщенности. Он отсюда уйдет, как квантор существования, а когда мы будем брать отрицание,
[01:20:11.840 --> 01:20:20.960]  это превратится в всеобщность. Из посылки, когда мы кванторы существования, мы выносим их как
[01:20:20.960 --> 01:20:25.520]  кванторы существования, они тоже заменятся на кванторы всеобщенности. То есть вроде бы лишнего
[01:20:25.520 --> 01:20:40.160]  уровня там не возникает. Ну вот как-то так. То есть на третий уровень попадает. Ну желающие,
[01:20:40.160 --> 01:20:45.240]  те, кто хорошо понимают по рифметическую иерархию, могут попробовать доказать,
[01:20:45.240 --> 01:20:52.680]  что истинные в рифметике формулы полны на этом уровне. То есть я не думаю, что есть какое-то
[01:20:52.680 --> 01:20:56.640]  препятствие, раз уж оно попало на какой-то уровень, оно, скорее всего, должно быть полным. То есть
[01:20:56.640 --> 01:21:04.360]  любая задача с третьего уровня рифметической иерархии, по идее, должна сводиться. Но там могут быть нюансы,
[01:21:04.360 --> 01:21:22.240]  я не уверен, я, честно говоря, никогда про это не думал. Тут же еще дело такое,
[01:21:22.600 --> 01:21:28.600]  но все, конечно, с рифметической иерархией хорошо, но на самом деле я вас обманываю немножко.
[01:21:39.600 --> 01:21:47.240]  Это же ограниченные все кванторы. Вот и меньше t. Здесь, когда мы будем брать квантор существования.
[01:21:47.240 --> 01:21:56.320]  А вот эти вот кванторы уже не очень понятно, чем ограничены, потому что это коды в бета-функции,
[01:21:56.320 --> 01:22:03.720]  они, бог знает какие, непонятно. То есть у нас есть неограниченная переменная t, и вот здесь вот коды,
[01:22:03.720 --> 01:22:12.400]  которые мы используем, они тоже не очень, а нет, ну подождите, они не понятно, чем ограничены,
[01:22:12.400 --> 01:22:17.120]  потому что lr, они должны кодировать lr, а lr, вообще говорят, сколь угодно, большие числа.
[01:22:17.120 --> 01:22:25.200]  Поэтому, да, у нас, да, ну тогда это квантор существования, вот этот пои пропадает.
[01:22:25.200 --> 01:22:37.160]  Все-таки копии перечислим? Не, ну что не копии перечислим, вроде бы убедительно на уши повесил.
[01:22:37.160 --> 01:22:44.200]  Ой, так, а время уже вышло, я прошу прощения. Ну это мы уже обсуждаем детали, доказательства я
[01:22:44.200 --> 01:22:54.000]  закончил. Сейчас, ну подождите, ну все-таки, ну очевидно, что истинные к ложным сводятся,
[01:22:54.000 --> 01:23:02.000]  просто мы берем навешиваю на отрицание. Соответственно, ложные тем самым тоже не перечислим.
[01:23:02.000 --> 01:23:14.040]  С другой стороны, они отличаются на разрешимое множество, поэтому дополнение к r, оно тоже
[01:23:14.040 --> 01:23:29.800]  не перечислимо, конечно. Что-то я немножко запутался. Ну, тут надо внимательнее посмотреть на определение
[01:23:29.800 --> 01:23:36.520]  арифметической иерархии, может быть, там, мне казалось, что если какой-то квантор ограничен,
[01:23:36.520 --> 01:23:38.400]  уже, ну там, переменная, которая...
