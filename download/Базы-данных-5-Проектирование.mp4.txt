[00:00.000 --> 00:13.440]  Пятая лекция. Немножко некорректная заголовка. Прошу прощения, здесь, конечно, не основа DML.
[00:13.440 --> 00:18.040]  У нас продолжение темы проектирования. Мы ее сегодня заканчиваем. Рассмотрим
[00:18.040 --> 00:23.880]  ссылочную целостность и нормализацию. И на следующей лекции по этому напишем соответственно
[00:23.880 --> 00:32.280]  quiz. Хорошо, проектирование мы, в общем, с вами разбирали на прошлом занятии, в конце. В общем,
[00:32.280 --> 00:38.360]  мы основные шаги рассмотрели. Сейчас просто быстренько пройдемся, вспомним, как это было.
[00:38.360 --> 00:50.280]  Проектирование подразделяется у нас на три этапа. На три этапа концептуальная,
[00:50.280 --> 00:58.760]  аналогическая и физическая по уровню приближения к тому, как наша схема данных, модель данных
[00:58.760 --> 01:06.560]  будет выглядеть непосредственно в базе данных. С точки зрения языка SQL, конечно же. То есть мы
[01:06.560 --> 01:11.800]  от более общего опускаемся к более частному. В конечном итоге, на уровне физического
[01:11.800 --> 01:20.200]  проектирования у нас должен быть готов код DDL, код на языке SQL, соответственно в котором мы
[01:20.200 --> 01:30.280]  создадим необходимые таблицы и наведем между ними функциональные зависимости. Каждая последующая
[01:30.280 --> 01:35.920]  стадия проектирования подразумевает усовершенствование модели, полученные на предыдущей стадии.
[01:35.920 --> 01:46.800]  И на этапе физического проектирования у нас появляются уже конкретные ограничения на данные,
[01:46.800 --> 01:57.080]  какие-то проверки данных, появляются специфические технические таблицы для связывания между собой
[01:57.080 --> 02:03.720]  различных отношений по типу «многие ко многим» или «один к одному». С точки зрения революционной
[02:03.720 --> 02:08.600]  модели такие взаимосвязи не очень хороши, но с точки зрения практики они возникают,
[02:08.600 --> 02:15.400]  поэтому их надо безусловно отражать. И технически это просто делается через дополнительную
[02:15.400 --> 02:21.560]  промежуточную таблицу, к которой у нас связи соответственно получаются «один ко многим»
[02:21.560 --> 02:30.640]  или «многие к одному». Сейчас я покажу уже на примере более конкретно. Концептуально у нас,
[02:30.640 --> 02:45.440]  если начинать с проектирования концептуального, есть два способа нотации для IR-схемы.
[02:45.440 --> 02:54.000]  IR-схема — это Entity Relationship-схема, основанная на Entity Relationship Model. На модели сущность-связь
[02:54.000 --> 03:00.760]  наиболее общий уровень, наиболее общее понятие о предсветной области мы можем таким образом
[03:00.760 --> 03:08.280]  отразить. Это просто для общей информации, что можно отражать в нотации чена, в нотации воронья
[03:08.280 --> 03:14.000]  лапка. Мы используем в нотации воронья лапка, конечно. Вот мы с вами рассматривали концептуальную
[03:14.000 --> 03:23.120]  модель ресторана. В прошлый раз говорили о том, что у нас между сущностями, заключенными графически
[03:23.120 --> 03:28.480]  в прямоугольнике, наличествуют связи изображенных в виде различных дуг. Различия в дугах
[03:28.480 --> 03:35.480]  показывают кардинальность той или иной связи. То есть многие к одному, многие к одному или нулю,
[03:35.480 --> 03:44.160]  или один только один к нулю или ко многим. Круглешок, соответственно, ноль. Две палочки — это один только один.
[03:44.160 --> 03:51.000]  Выглядит концептуальная модель соответственно так. Логическое проектирование. Спускаемся на
[03:51.000 --> 04:04.600]  уровень ниже. Можно представить себе логическую схему вашей базы данных. В общем,
[04:04.600 --> 04:08.880]  логический уровень проектирования можно представить или вернее его результат можно представить,
[04:08.880 --> 04:13.880]  как показано на картинке на слайде. Соответственно, видите, у нас появляется чуть
[04:13.880 --> 04:19.400]  более детализированное представление. У нас появляются уже первичные и внешние ключи,
[04:19.400 --> 04:28.280]  появляются атрибуты на различных отношениях. И конечный уровень. Здесь такой кусок маленький
[04:28.280 --> 04:38.000]  показан, потому что, честно говоря, не нашел какого-то приемлемого представления. И самостоятельно
[04:38.000 --> 04:43.040]  ничего такого простого наглядного, наверное, придумать не смог. Ну, не то, что не смог.
[04:43.040 --> 04:47.600]  Можно, конечно, искусственно сделать две-три таблицы просто здесь. Что интересно,
[04:47.640 --> 04:53.880]  если вы обратите внимание, у нас есть таблица «Дело – нижнее подчеркивание судья». Это фрагмент
[04:53.880 --> 05:02.480]  трекера юродепартамента. Ну, таск трекера. Ну, такой, да, очень отдаленный фрагмент от того,
[05:02.480 --> 05:09.920]  что в принципе там в итоге было. И не финальная стадия. Но, тем не менее, это такая рабочая,
[05:09.920 --> 05:15.960]  в общем-то, модель. А здесь, почему я заостряю ваше внимание, вот «Дело – судья» – таблица,
[05:15.960 --> 05:24.600]  и «судия-судия» – суд-судия, соответственно, вот здесь вот и вот здесь. У них связи многие
[05:24.600 --> 05:31.880]  ко многим как раз. Почему так происходит? Потому что здесь немножко в предметную область придется
[05:31.880 --> 05:38.080]  погрузиться буквально на пару минут. Проблема в том, что у одного судьи может быть много дел,
[05:38.080 --> 05:44.360]  и у одного дела могут сменяться судьи, которые его рассматривают. Либо, наоборот, могут быть
[05:44.360 --> 05:51.680]  коллегиальные составы суда, исходя из специфики данной предметной области, данного таск трекера.
[05:51.680 --> 06:00.800]  Повторюсь, это кусок, он отдаленный кусок дедра, скажем так, логического, реального. Поэтому у нас
[06:00.800 --> 06:07.640]  здесь может быть как-то вот не очень понятно, где здесь таски, где здесь вообще департамент,
[06:07.640 --> 06:14.360]  здесь суд, дело к чему все это, о чем. Но уж на это не обращайте внимание. Здесь самое главное,
[06:14.360 --> 06:23.280]  вот дело судьи, и суд-судья – многие ко многим связь. Это не классическая релиционно-модельная
[06:23.280 --> 06:28.600]  связь, это связь, которую нам приходится моделировать через техническую таблицу,
[06:28.600 --> 06:36.760]  в данном случае две технических таблицы. Ну, такое может быть, такое встречается. Это не то,
[06:36.760 --> 06:42.720]  чтобы прям нормально, наверное, по классике, но это в целом то, к чему нужно быть готовым. То есть
[06:42.720 --> 06:47.880]  когда у нас появляется такое соотношение, что у нас и с одной стороны, и с другой стороны,
[06:47.880 --> 06:57.120]  причем эти технические таблицы, они, как правило, часто состоят просто из двух атрибутов, где один
[06:57.120 --> 07:02.080]  атрибут из одной таблицы является первичным ключом другой атрибут, первичным ключом для
[07:02.080 --> 07:13.280]  другой таблицы, и они таким образом как будто бы джойнятся, соединяются. Ну, хорошо. Для чего нам
[07:13.280 --> 07:20.360]  необходимо вообще проектировать БД? Помимо каких-то общих фраз есть на самом деле теоретически
[07:20.360 --> 07:28.200]  вполне выверенные, теоретические положения, которые обсуждаются в литературе, по релиционным
[07:28.200 --> 07:32.880]  базам данных рассматриваются, которые мы должны тоже с вами понимать не просто на уровне,
[07:32.880 --> 07:36.480]  потому что спроектированная база данных должна работать лучше, а мы должны понимать,
[07:36.480 --> 07:42.720]  почему конкретно лучше ее владеть паникийным аппаратом. А в данном случае мы проектируем
[07:42.720 --> 07:47.000]  для того, чтобы исключить избыточность данных и обеспечить поддержку целостности, ну или в
[07:47.000 --> 07:53.120]  частности ссылочной целостности. Нас интересует в первую очередь, конечно, она, потому что,
[07:53.120 --> 07:58.680]  в общем-то, избыточность и поддержка целостности, поддержка не ссылочная, просто целостность,
[07:58.680 --> 08:07.120]  повторюсь, до некоторой степени перекрещивающееся понятие. В общем, нам нужно исключать избыточность
[08:07.120 --> 08:12.760]  данных, обеспечивать ссылочную целостность. Это важно для поддержания корректности данных
[08:12.760 --> 08:21.200]  при хранении и обработке. Если пренебречь качественным проектированием, прошу прощения,
[08:21.280 --> 08:30.440]  то мы можем столкнуться с аномалиями при добавлении, модификации и удалении данных.
[08:30.440 --> 08:43.600]  Аномалии будут заключаться в том, что вместо локальных действий с отдельными порциями данных нам
[08:43.600 --> 08:48.080]  придется шерстить всю таблицу, а может быть даже взаимосвязанное, какое-то количество
[08:48.080 --> 08:59.920]  взаимосвязанных таблиц, чтобы внести связные изменения везде. Сейчас поговорим обо всем этом
[08:59.920 --> 09:04.520]  подробнее. И для качественного, соответственно, проектирования БД нам необходимо проводить
[09:04.520 --> 09:10.400]  нормализацию данных, использовать средства поддержания ссылочной целостности. Сразу,
[09:10.400 --> 09:16.760]  забегая на несколько слайдов вперед, скажу, что часть этих средств поддержания ссылочной
[09:16.760 --> 09:24.480]  целостности мы на самом деле с вами уже рассматривали и говорили в частности о ограничениях и ключах.
[09:24.480 --> 09:34.280]  И как мы с вами об этом говорили на второй лекции, мы возвращаемся к этим средствам,
[09:34.280 --> 09:39.880]  к ключам для рассмотрения их более подробно именно в контексте проектирования сейчас,
[09:39.960 --> 09:47.360]  на нашей пятой лекции. Что нужно еще знать с точки зрения набора таких общепринятых понятий?
[09:51.360 --> 09:57.760]  Определение представлено, опять же, на экране. Целостность сущности заключается в чем? Это
[09:57.760 --> 10:06.040]  требование к тому, что любое отношение у нас должно обладать потенциальным ключом. У нас
[10:06.040 --> 10:12.080]  должен быть какой-то атрибут или набор атрибутов, которые характеризуются свойствами,
[10:12.080 --> 10:18.000]  как вы помните, уникальности и несократимости, неизбыточности. То есть мы не можем вынуть из
[10:18.000 --> 10:27.680]  нашего первичного ключа данные, которые в нем дублируются, потому что таких данных в нем быть
[10:27.680 --> 10:35.200]  не должно. Если мы говорим о том, что у нас составной потенциальный ключ, то соответственно
[10:35.200 --> 10:41.480]  мы не можем вынуть ни часть, ни целую запись этого составного потенциального ключа тоже под страхом
[10:41.480 --> 10:50.320]  того, что мы нарушим требование к неизбыточности. То есть мы не просто сделаем менее избыточным,
[10:50.320 --> 10:56.040]  а у нас информация будет недоставать. Поддержание целостности осуществляется средствами СУБД,
[10:56.040 --> 11:03.240]  то есть при добавлении записи в таблицу проверяется уникальность первичных ключей и не допускается
[11:03.240 --> 11:08.600]  изменения значения атрибутов, входящих в первичный ключ. Ссылочная целостность — это
[11:08.600 --> 11:14.720]  необходимое качество релиционной базы данных, заключающееся в отсутствии в любом ее отношении
[11:14.720 --> 11:21.680]  внешних ключей, ссылающихся на несуществующие кортежи. То есть здесь важно, что у нас вот это
[11:21.680 --> 11:29.480]  наше ограничение, фаруэн кии, какая-то таблица, какое-то поле, какой-то атрибут не ссылается в
[11:29.480 --> 11:40.480]  пустоту. Это принципиально важная вещь, потому что у нас по сути дела нет каких-то механических
[11:40.480 --> 11:48.920]  связей между нашими отношениями. У нас сама по себе наша база данных, после того, как мы
[11:48.920 --> 11:54.920]  внесли в нее нашу схему данных, создали какое-то количество взаимосвязанных таблиц, или просто
[11:55.560 --> 12:02.040]  для примера возьмем. Она не знает, что с ними делать. Мы должны в явной форме задать зависимости.
[12:02.040 --> 12:12.200]  Задать мы их можем только посредством первичного и внешнего ключа. И только соблюдая ограничения,
[12:12.200 --> 12:17.880]  наложенные отношением внешнего и первичного ключа между собой, мы можем гарантировать,
[12:17.880 --> 12:23.720]  что у нас будет поддерживаться ссылочная целостность. Это необходимое, скажем так,
[12:23.720 --> 12:28.120]  но этого недостаточно. У нас, конечно, есть еще дополнительные средства, о которых сейчас
[12:28.120 --> 12:39.080]  тоже поговорим и вспомним. База данных обладает свойством ссылочной целостности, когда для любой
[12:39.080 --> 12:43.120]  пары связанных внешним ключом отношений вне условия ссылочной целостности выполняется.
[12:43.120 --> 12:51.560]  То есть когда у нас не пустая ссылка, не битая ссылка. Избыточность данных, это по сути дела,
[12:51.880 --> 12:59.000]  просто-напросто дублирование данных в базе. Здесь важно только сказать, что под избыточностью
[12:59.000 --> 13:06.440]  понимается не только дублирование целого кортежа, целой записи, а в том числе дублирование
[13:06.440 --> 13:15.040]  значения части атрибутов кортежа. Сейчас мы посмотрим на это воочию, когда будем рассматривать
[13:15.040 --> 13:23.600]  примеры отдельных аномалий. И аномалия – это ситуация в таблице базы данных,
[13:23.600 --> 13:28.520]  которая приводит к противоречию в базе данных, либо существенно усложняет обработку базы данных.
[13:28.520 --> 13:36.400]  И причиной аномалии является излишнее дублирование данных в таблице. Излишнее взято в скобке,
[13:36.400 --> 13:51.120]  потому что на самом деле у нас за недублирование данных отвечает процесс нормализации. Но проблема
[13:51.120 --> 13:57.560]  в том, что если мы будем нормализовывать наши данные максимально возможным способом, пойдем
[13:57.560 --> 14:03.080]  не просто до второй, до третьей нормальной формы, пойдем еще ниже нормальной формы бойса кода,
[14:03.080 --> 14:10.680]  но это еще не самый низ далеко. Шесть нормальных форм выделяют. Классическая литература базы
[14:10.680 --> 14:15.840]  данных. Если мы пойдем ниже, спускаться все глубже в эту нормализацию, у нас просто получится много
[14:15.840 --> 14:24.120]  таких малоатрибутивных отношений, по которым нам придется делать запросы, просто постоянно
[14:24.120 --> 14:29.360]  их соединяя между собой. У нас из-за этого потенциально может сильно увеличиваться время
[14:29.360 --> 14:39.600]  обработки запроса в чрезвычайно нормализованных ситуациях. На практике на самом деле смотрят
[14:39.600 --> 14:45.120]  исходя из того, где образуется бутылочная горлышка. Потому что, повторюсь, не всегда
[14:45.120 --> 14:55.260]  оптимальным является формальная теоретическая нормализация. Однако, тем не менее, в ваших
[14:55.260 --> 15:01.460]  курсовых проектах и, в принципе, на практике при именно проектировании данных, базы данных,
[15:01.460 --> 15:07.580]  необходимо отталкиваться с сухой теорией и пытаться нормализовать все. Обычно до третьей
[15:07.580 --> 15:17.380]  формы нормальные бойса кода нормализуют. И вот стараться на этапе проектирования так
[15:17.380 --> 15:22.300]  нормализовать. Потом денормализацию провести вы сможете, если провели правильно и корректно
[15:22.300 --> 15:38.660]  нормализацию. Здесь проблем нет. А вот денормализацию провести вы сможете, и при этом вы будете
[15:38.660 --> 15:44.140]  ее проводить уже на каких-то реальных статистических данных по тому, как ваша база данных работает в
[15:44.140 --> 15:50.820]  продакшене. Какие их не запросы, какая статистика, на каких узлах какая нагрузка и так далее и
[15:51.500 --> 15:59.100]  поэтому проектируем мы всегда вот по по инструкции так сказать до третьей как минимум нормальной формы
[15:59.100 --> 16:07.500]  обязательно доходим здесь немного дальше просто обзорной информации да вот чтобы все это как-то
[16:07.500 --> 16:12.300]  еще и графически показать то есть цели проектирования избежать избыточности обеспечить поддержку ну
[16:12.300 --> 16:20.220]  ссылочной до целостности в первую очередь последствия некачественного проектирования это
[16:20.220 --> 16:26.020]  аномалия как мы сказали их три штуки это добавление редактирования и удаления как в это все выглядит
[16:26.020 --> 16:35.740]  опять же повторюсь мы посмотрим сейчас предметные подробно и поддержка корректности данных
[16:35.740 --> 16:40.780]  обеспечивается чем нормализация средства поддержания со слышной целостности одно из
[16:41.700 --> 16:48.820]  важнейших средств это повторюсь ключи позволяющие устанавливать зависимости между отношениями по
[16:48.820 --> 16:54.220]  сути дела у нас нет иных способов установить взаимозависимости между разными отношениями
[16:54.220 --> 17:07.060]  кроме как через ключи и сейчас у нас будет даже ограничение на действия по модификации данных
[17:07.060 --> 17:13.220]  вы увидите и там тоже они устанавливаются при наличии именно внешних ключей то есть
[17:13.220 --> 17:23.380]  ключи внешние ключи до первичный этап связывания отношений в какую-то структуру давайте посмотрим
[17:23.380 --> 17:30.420]  с вами на аномалии обновления в чем они заключаются вот аномалия добавление что из себя представляет
[17:30.420 --> 17:37.140]  возникают такие аномалии когда информацию в таблицу нельзя поместить пока она не полная
[17:37.140 --> 17:43.620]  либо вставка записи требует дополнительного просмотра таблицы о чем идет речь вот у нас
[17:43.620 --> 17:57.020]  есть некоторое отношение в котором перечислено какие-то поставки при этом у нас помимо собственной
[17:57.020 --> 18:05.580]  информации о товаре есть еще название поставчика есть адрес поставщиков и у нас эта таблица одна
[18:05.580 --> 18:13.020]  она ни с чем не связана уже как бы да вы имея определенный практический опыт первого месяца
[18:13.020 --> 18:21.060]  курса должны я думаю понимать что что-то здесь неправильно что-то не очень хорошо это выглядит
[18:21.060 --> 18:30.140]  что здесь не очень хорошего вот мы не можем данную таблицу добавить новую запись если не
[18:30.140 --> 18:35.540]  известно значение первичных ключей например мы заключили контракт с поставщиком 3 и не можем
[18:35.540 --> 18:41.460]  добавить информацию о нем в таблицу так как еще не было поставок то есть но технически конечно
[18:41.460 --> 18:47.180]  здесь стоит оговориться что мы бы в принципе могли бы в принципе могли сказать что у нас все
[18:47.180 --> 18:53.540]  значения будут дефолтными по умолчанию кроме названия поставщика и адреса поставщика и у нас
[18:53.540 --> 18:59.860]  тогда была бы таблица одна наша по типу экселевской книги с ее листами листом даже одним где у нас
[18:59.860 --> 19:07.820]  просто в одной из записей вот здесь 6 строк и седьмой строкой была бы там номер поставки причем
[19:07.820 --> 19:12.580]  первичный причем это первичный ключ до номер поставки у нас бы обработался здесь был бы
[19:13.180 --> 19:21.380]  уже ну 4 поскольку новый поставщик очевидно название товара у нас было бы возможно здесь тоже
[19:21.380 --> 19:28.140]  кстати вопрос какое бы название товара в данном случае по дефолту вот нет получается даже мы
[19:28.140 --> 19:33.060]  не могли бы здесь не могли не могли бы никак дефолтом все это установить у нас все равно была
[19:33.060 --> 19:41.140]  бы ошибка потому что мы бы не знали что внести на этапе когда у нас появился поставщик но нет
[19:41.140 --> 19:47.780]  поставки а при этом внести вот в эти поля мы должны были информацию должны были бы быть здесь
[19:47.780 --> 19:55.940]  был поставщик 3 адрес 3 и обязательно здесь был бы поставка 4 название товара там бумага для
[19:55.940 --> 20:00.940]  принтера цена ну цена количества кейтом не обязательно а при этом он еще ничего не
[20:00.940 --> 20:13.860]  поставлял ну проблемы очевидно проблемы это это не здорово но не то что не здорово да это
[20:13.860 --> 20:23.100]  очевидно не влечет какие-то проблемы связанные с дальнейшей эксплуатации нашей базы мы добавляем
[20:23.100 --> 20:30.500]  туда лишние данные по сути дела которые ничем не обоснованной и не нужны она в части первичных
[20:30.500 --> 20:36.340]  ключей я имею ввиду которые обязательно к заполнению давайте посмотрим дальше аномалии редактирования
[20:36.340 --> 20:41.820]  или модификация такие аномалии проявляются в том что изменение одних данных может повлечь
[20:41.820 --> 20:46.740]  просмотр всей таблицы и соответствующее изменение некоторых записей таблицы так
[20:46.740 --> 20:56.780]  вопрос да совершенно верно вопрос в чате но тогда ведь просто нужна отдельная таблица с
[20:56.780 --> 21:03.320]  поставщиками в чем проблема данной таблицы в том в том и проблема в том и проблема ребят что у нас
[21:03.320 --> 21:11.020]  по условиям данного примера отдельной таблицы с поставщиками нет именно поэтому это ну да это
[21:11.020 --> 21:17.060]  это искусственный пример это пример лекционный то есть по идее там в жизни было бы что-то более
[21:17.060 --> 21:22.580]  более разумные скажем так здесь очевидно напрашивается вывод что вот эти две колонки
[21:22.580 --> 21:29.460]  они должны быть в отдельной таблице и связь там по через внешний ключ потом майди поставщика
[21:29.460 --> 21:36.820]  но здесь примере у нас только одна таблица и поэтому как бы это проблема но пример масштабируем
[21:36.820 --> 21:45.100]  на практике такое возникает сплошь и рядом когда оказывается что в насилие вносили в таблицу вносили
[21:45.100 --> 21:56.500]  вносили там половина записи ну не обязательных налы праймеры киев они просто если суррогатно
[21:56.500 --> 22:07.460]  еще куда не шло а если это праймерики да вот не суррогатные естественные то проблемы возникают
[22:07.460 --> 22:12.860]  чтобы тогда в них заполнить опять же возникают проблемы с тем что даже праймерики ладно бог с
[22:12.860 --> 22:18.380]  ним цена и количество товара там в реальных каких таблицах не может быть может не быть
[22:18.380 --> 22:25.380]  установлены дефолтных значений для тех полей которые не являются первичными ключами но
[22:25.380 --> 22:30.620]  которые все равно таким образом должны были бы быть заполнена реальная информация и что в них
[22:30.620 --> 22:34.740]  вставлять вообще какие-то филлеры там в цену товара тогда пришлось бы нолик вставлять в
[22:34.740 --> 22:43.860]  количество тоже нолик ну лишняя строка причем там лишние там понятно это байты какие-то с
[22:43.860 --> 22:51.500]  точки зрения физического хранения но по факту одна запись другая третья если их десятки тысяч
[22:51.500 --> 22:56.980]  если это вообще какой-то какая-то таблица связанная не знаю с лагированием с которой
[22:56.980 --> 23:06.620]  постоянно ежедневно туда-сюда перезаписывается в общем там возникает возникает проблема поэтому
[23:06.620 --> 23:10.940]  вы сказали вы заметили правильно правильно но повторюсь пример данным случаем несколько
[23:10.940 --> 23:19.620]  искусственный просто целях упрощения нам с вами и наглядности больше аномалии редактирования
[23:19.620 --> 23:24.180]  как я уже сказал да проявляются в том что изменение одних данных может повлечь просмотр всей
[23:24.180 --> 23:28.260]  таблицы и соответствующие изменения некоторых записей в таблице ну вот у нас здесь выделено
[23:28.260 --> 23:36.900]  до по две строки в чем здесь может быть проблема если мы что-то модифицируем проблема простая если
[23:36.900 --> 23:46.340]  мы изменяем данные одной записи и хотим изменить адрес поставщика 1 нам придется менять адреса
[23:46.340 --> 23:55.740]  во всех строках поскольку у нас здесь нет связи по id поставщика с таблицей поставщиков мы вносим
[23:55.740 --> 24:01.140]  вот этот поставщик один адрес один эти записи везде везде везде где у нас поставщик один реально
[24:01.140 --> 24:06.500]  что-то поставлял ну и соответственно опять же это у нас здесь только 6 строк в таблице в реальной
[24:06.500 --> 24:17.340]  таблице это может быть там десятки тысяч строк чтобы причем представляете там город
[24:17.340 --> 24:23.540]  переименовывается например у нас там целый каскад поставщиков просто в этом городе находящихся
[24:23.540 --> 24:34.660]  которые по которым надо менять едва ли не всю таблицу но в части конечно но тем не менее там
[24:34.660 --> 24:41.420]  соответственно блокируются операции какие-то там чтение или записи ну чтение наверное нет в
[24:41.420 --> 24:48.140]  зависимости там от уровня опять же защищенности ну запись скорее всего заблокировалась бы на
[24:48.140 --> 24:58.820]  долго аномалии удаления при удалении какого-либо кортежа из таблицы может пропасть информация
[24:58.820 --> 25:10.340]  которая не связана напрямую с удаляемой записью тоже все в принципе так же тривиально да из-за
[25:10.340 --> 25:17.420]  счет тривиальности примером мы хотим удалить запись о поставках поставщика 2 но проблема в
[25:17.420 --> 25:24.540]  том что информация о поставках у нас зашитов первичный ключ и мы не можем оставить пустой
[25:24.540 --> 25:32.260]  первичный ключ но название поставщика адрес поставщика соответственно у нас удалится вся
[25:32.260 --> 25:38.820]  информация о поставщике 2 его адресе который у нас хранилась в этой общей нашей единственной
[25:38.820 --> 25:45.380]  сизой убогой таблички куда мы носили вообще всю информацию которую только могли и соответственно
[25:45.380 --> 25:49.460]  удаляя только часть по сути ну логически необходимо нам удалить только часть мы удалим
[25:49.460 --> 25:59.940]  вообще все вот собственно три таких три таких варианта аномалии давайте еще раз аномалия
[25:59.940 --> 26:06.860]  добавления когда мы пытаемся что-то добавить локально а не можем ставить потому что нужно
[26:06.860 --> 26:13.140]  нужны дополнительные данные которые у нас требуется по условиям ограничений на нашу
[26:13.140 --> 26:22.500]  таблицу аномалии редактирования когда мы хотим отредактировать только часть записей только часть
[26:22.500 --> 26:26.860]  какой-то записи по сути нам надо отредактировать но за счет того что избыточная информация нам
[26:26.860 --> 26:31.860]  придется менять все записи и аномалии удаления когда мы хотим удалить опять же только часть
[26:31.860 --> 26:36.420]  данных по какой-то записи но нам придется удалять целиком записи потому что она не может быть
[26:36.420 --> 26:42.140]  оставлена в таблице опять же исходя из тех ограничений которые для данной таблицы установлен
[26:42.140 --> 26:53.540]  окей что дальше ссылочная целостности ключи как мы с вами помним со второй лекции и как вы
[26:53.540 --> 27:03.460]  знаете семинаров у нас есть набор средств по формулированию ограничений при создании таблиц
[27:03.460 --> 27:09.700]  вот эти средства у нас перечислены на слайде мы с ними знакомы а подробно останавливаться не
[27:09.700 --> 27:19.220]  будем но да вот то есть мы их рассматривали в контексте как бы базового такого синтаксиса
[27:19.220 --> 27:29.900]  но вот у них есть еще и такое вот логическое до нас и значение с точки зрения модели религационной
[27:29.900 --> 27:39.100]  как вспоможение в проектировании базы данных поэтому это не просто синтаксис это важные
[27:39.100 --> 27:48.860]  важные элементы проектирования которые нужно иметь в виду но помимо перечисленных ограничений
[27:48.860 --> 27:58.420]  есть еще такое такое средство как задание определенного поведения для вашей суббд при
[27:58.420 --> 28:02.940]  удалении некоторые строки или изменения некоторого значения во внешней таблице то есть в
[28:02.940 --> 28:11.580]  таблице на которую у нас ссылается внешний ключ и стекущий при этом если при изменении данных
[28:11.580 --> 28:15.500]  строка изменена но это изменение не затронула целевые столбцы никакое действие производиться
[28:15.500 --> 28:25.260]  не будет ну это такая ремарка на полях я здесь скупках привел как бы такая подстрочное
[28:25.260 --> 28:33.300]  примечание скорее о чем идет речь вот средство поддержание ссылочной ссылочной целостности вот
[28:33.300 --> 28:42.540]  есть еще и такие они у нас формулируются на этапе формулирование ограничения по внешнему ключу
[28:42.540 --> 28:51.020]  здесь синтаксис на слайде приведен только один из как вы должны помнить из прошлой лекции ну
[28:51.020 --> 28:56.220]  со второго по счету дека и знать семинарских занятий и исходя из документации с которой вы
[28:56.220 --> 29:02.900]  должны очевидно были работать у нас синтаксис задания ограничений довольно богатый он
[29:02.900 --> 29:09.460]  предполагает несколько он предполагает вариативность формулирования ограничений
[29:09.460 --> 29:15.500]  данном случае здесь даже нет у нас про инки форейнки ключевых слов да просто
[29:15.500 --> 29:23.060]  референс из с команды предложение референс из и дальше то на что ссылается собственно
[29:23.060 --> 29:30.740]  вот это вот референс из ссылка на что она идет и дальше за него то о чем мы сейчас с вами
[29:30.740 --> 29:42.900]  говорим он delete cascade то есть при удалении либо у нас вариант есть еще он update при удалении в
[29:42.900 --> 29:50.460]  данном случае ну или при изменении таблицы в данном случае это таблицы кастомерс у нас
[29:50.460 --> 30:01.140]  каскадно должны были бы удаляться все строки ссылающиеся на удаляемую запись либо должны
[30:01.140 --> 30:05.900]  были поменяться значения в ссылающихся столбцах на новые значения во внешних столбцах соответствия
[30:05.900 --> 30:14.180]  с операцией он update но в данном случае работает первая часть утверждения повторюсь поскольку
[30:14.180 --> 30:20.620]  в примере он delete что мы еще можем сделать мы можем у нас есть еще такие предложения как но
[30:20.620 --> 30:29.100]  action тогда у нас при удалении или изменении данных во внешней таблице будет система выдавать ошибку и
[30:29.100 --> 30:47.340]  препятствовать изменению данных в основной таблице restrict у нас также выдает запрещает нам
[30:47.340 --> 30:54.060]  удалять данные из внешней таблицы cascade удаляет или изменяет каскадно изменяет да в соответствии
[30:54.060 --> 31:01.060]  с изменяющимися значениями мы также можем установить нал или установить default на
[31:01.060 --> 31:06.380]  значения во всех ссылающихся столбцах или в указанном под множестве ссылающихся столбцов
[31:06.380 --> 31:15.060]  как показано на слайде да то есть мы можем задать перечень именно атрибутов которые мы
[31:15.060 --> 31:22.140]  хотим изменить под множество столбцов при этом можно указать только для действия он delete и
[31:22.140 --> 31:27.220]  для сет default у нас если значение по умолчанию отличный от нал то во внешней таблице должна
[31:27.220 --> 31:33.340]  быть строка соответствующей набору этих значений в противном случае с операция завершится ошибкой
[31:33.340 --> 31:45.620]  так ну в принципе довольно здесь мне кажется все просто там ничего никаких специфических
[31:45.620 --> 31:52.100]  вещей здесь кажется сказать уже дальше больше и не надо с учетом того чтобы с вами разобрали
[31:52.100 --> 31:59.100]  ограничение предыдущие хотелось бы еще немножко освежить потенциальные первичные внешние ключи
[31:59.100 --> 32:08.740]  в вашей памяти да что такое потенциальный ключ это атрибут или под множество атрибутов
[32:08.740 --> 32:17.620]  которые удовлетворяют требования уникальности и несократимости потенциальный ключ у нас
[32:17.620 --> 32:24.580]  существует всегда если он включает все атрибуты отношения и это следует у нас из определений
[32:24.580 --> 32:32.220]  из основных определений определение заданной корреляционной моделью и потенциальных ключей
[32:32.220 --> 32:40.740]  может быть несколько мы здесь соответственно можем выбирать как между потенциальными ключами
[32:40.740 --> 32:51.700]  так и можем составные потенциальные ключи составлять если у нас получается что да вот
[32:51.700 --> 32:59.260]  эти вот там пары тройки и так далее n-ки атрибутов будут уникальны для каждого кортежа в нашем
[32:59.260 --> 33:08.140]  отношении первичный ключ соответственно как вы должны были помнить это у нас потенциальный
[33:08.140 --> 33:13.900]  ключ отношения которые выбран в качестве основного и определение внешнего ключа но опять же да вот
[33:13.900 --> 33:19.060]  повторюсь по сути дела внешний ключ у нас представляет собой не более чем способ задания
[33:19.060 --> 33:29.820]  ссылки между между способ пересыливания да между одной таблицей другой между таблицей
[33:29.820 --> 33:40.260]  которая по ограничению фаренки ссылается на какой-то первичный ключ некий в родительского
[33:40.260 --> 33:49.660]  отношения свойства ключей какое основное свойство ключей с точки зрения реляционной модели это
[33:49.660 --> 33:58.100]  возможность формировать функциональные зависимости между отношениями что это значит что такое
[33:58.100 --> 34:02.940]  функциональная зависимость здесь на самом деле все тоже довольно просто это то что мы с вами все
[34:02.940 --> 34:08.620]  знаем из школьной еще математики то есть когда у нас есть два множества и одно в другое отображается
[34:08.620 --> 34:23.220]  так что значение из множества у определены за счет значений из множества x и для каждого
[34:23.220 --> 34:29.740]  кортежа отношения r если два кортежа отношения совпадают по значению x они совпадают по
[34:29.740 --> 34:34.300]  значению y или что эквивалентно не существует двух разных кортежей которые в атрибуте x
[34:34.300 --> 34:38.380]  имеют совпадающие значения а в атрибуте y имеют разные значения ну вот буквально
[34:38.380 --> 34:43.660]  там математическое определение функциональной зависимости когда у нас есть функция f от x
[34:43.660 --> 34:50.660]  собственно говоря такая же функциональная зависимость по сути своей да вот по логической
[34:50.660 --> 34:59.220]  структуре какой-то им да по своей структуре возникает между отношениями за счет первичных
[34:59.220 --> 35:14.220]  и внешних ключей давайте поговорим с вами про нормализацию в данном случае что это такое для
[35:14.220 --> 35:25.620]  чего нам это нужно казалось бы у нас есть у нас есть способы задания функциональных зависимостей
[35:26.260 --> 35:34.340]  у нас есть и пилу по сути дела говоря более таким огрубляю что ли да у нас есть способ задания
[35:34.340 --> 35:45.060]  ссылок между отношениями у нас есть способ способы для того чтобы проверялись вносимые или
[35:45.060 --> 35:50.780]  изменяемые данные на соответствие каких-то ограничений для чего нам еще нормализация а для
[35:50.780 --> 35:55.620]  того чтобы мы когда мы проектируем нашу базу данных несмотря на все вот эти замечательные
[35:55.620 --> 36:04.700]  средства и возможности как сql так и система управления базами данных для того чтобы у нас
[36:04.700 --> 36:15.420]  после проектирования не было стемантической избыточность избыточности в наших данных причем
[36:15.500 --> 36:21.140]  повторюсь как я говорил в начале лекции не только избыточности с точки зрения дублирующихся
[36:21.140 --> 36:27.140]  кортежей которые в принципе у нас запрещена только теории мы можем создать таблицу в нашей
[36:27.140 --> 36:34.700]  позгресс ql в которой мы будем в которую мы будем вносить абсолютно идентичные записи или
[36:34.700 --> 36:39.060]  например мы можем по всем нашим полям поставить дефолтные значения и просто вносить default
[36:39.060 --> 36:51.180]  insert values там да и insert into такой это такая таблица default значение она будет носить
[36:51.180 --> 36:55.620]  default значение там может быть даже без первичного ключа если мы создали наши отношения даже не
[36:55.620 --> 37:01.020]  будет никакого авто инкриментирование по полю первичного ключа пожалуйста а
[37:01.020 --> 37:12.300]  таким образом чтобы у нас не было ни повторяющихся кортежей не кортежи которые частично пересекаются
[37:12.300 --> 37:19.380]  между собой по содержащимся в себе данным содержащимся в себе элементом вот как мы
[37:19.380 --> 37:24.820]  видели в аномалиях обновления когда у нас этот перехлёст шел за счет поставщика и адреса
[37:24.820 --> 37:30.540]  поставщика хотя таблица посвящена в первую очередь исходя из первичного ключа до продуктом
[37:30.540 --> 37:40.980]  для того чтобы у нас такого перехлёста не было даже частично по отдельным элементам кортежей
[37:40.980 --> 37:51.940]  придумано определенная логическая получается процедура да а которая позволяет нам постепенно
[37:51.940 --> 37:58.140]  продвигаясь от первой нормальной формы и далее по списку но обычно повторюсь доходят на третий
[37:58.140 --> 38:03.180]  или может быть нормальный форма бойса кода нормализовать наши отношения таким образом чтобы
[38:03.180 --> 38:11.220]  поставщики у нас были в одной таблице товар у нас были в другой таблице или как-то еще больше
[38:11.220 --> 38:18.780]  дискритизировать дискритизировать наши данные разбив их по более мелким отношениям ну в
[38:19.780 --> 38:35.420]  области соответственно у нас нормальная форма это свойство отношений в релиционной модели данных
[38:35.420 --> 38:40.780]  характеризующие его с точки зрения избыточности потенциально приводящий к логически ошибочным
[38:40.780 --> 38:45.700]  результатам выборки или изменения данных нормальная форма определяется как совокупность
[38:45.700 --> 38:54.140]  требования которым должно удовлетворять отношения и приведение процесс приведения базы данных
[38:54.140 --> 39:01.100]  к нормальной форме называется нормализация что еще важно здесь сказать то то что ну я уже в принципе
[39:01.100 --> 39:06.820]  об этом упоминал но повторюсь у нас каждая последующая нормальная форма каждая последующая
[39:06.820 --> 39:19.220]  форма включает в себя ограничения всех предшествующих нормализация у нас предназначена
[39:19.220 --> 39:29.780]  отнюдь не для хотя мы говорим про избыточность да но она предназначена отнюдь не для изменений
[39:29.780 --> 39:35.380]  как физического объема данных и в принципе у нас наша релиционная модель наша релиционная база
[39:35.380 --> 39:45.420]  данных она не говорит нам ничего о том что ее конечной целью должна быть их конечными целями
[39:45.420 --> 39:53.900]  должно быть уменьшение съедаемого дискового пространства нет у нас должна быть минимизация
[39:53.900 --> 39:59.220]  логической избыточности и уменьшение потенциальной противоречимости и таким образом напрямую
[39:59.220 --> 40:05.620]  требования по нормализации на производительности на физический объем не влияют но здесь такая
[40:05.620 --> 40:11.260]  нелинейная зависимость есть как я уже говорил да в принципе если мы очень сильно нормализуем
[40:11.260 --> 40:20.820]  наши отношения очень их дискретизируем то у нас потенциальные запросы могут выполняться ну
[40:20.820 --> 40:28.660]  просто ощутимо дольше с другой стороны если мы дискретизируем наши отношения его атрибуты
[40:28.660 --> 40:35.780]  недостаточно сильно то мы просто будем вынуждены по сути дела гонять все время по одной и той же
[40:35.780 --> 40:41.020]  таблице все наши запросы что тоже на производительности скажутся не лучшим образом поэтому здесь должна
[40:41.020 --> 40:47.300]  быть золотая серия середины ну и повторюсь на этапе проектирования максимально стараемся
[40:47.300 --> 40:55.780]  следовать нормализации вплоть до третьей формы за исключением и и в последующем динормализацию
[40:55.780 --> 41:01.900]  проводить мы будем только исходя из каких-то реальных полевых так сказать данных данных
[41:01.900 --> 41:09.420]  полевых испытаний по реальной отзывчивости нашей базы на конкретный запрос пользователей
[41:09.420 --> 41:19.420]  нормализация нам позволяет некоторые типы избыточности исключить устранение некоторых
[41:19.420 --> 41:27.300]  аномалий обновления для разработки проекта база данных которая является качественным
[41:27.300 --> 41:32.020]  представлением реального мира интуитивно понятина легко расширяем в дальнейшем нужно
[41:32.020 --> 41:38.420]  нормализация и упрощение процедуры применения необходимых ограничений целостности тоже
[41:38.420 --> 41:47.100]  достигается за счет грамотной ну по крайней мере последовательной до последовательной
[41:47.100 --> 41:52.220]  нормализации последовательного проведения принципа нормализации в действительности
[41:52.220 --> 41:55.660]  так
[41:55.660 --> 42:06.900]  нормализация базы данных производится за счет декомпозиции как я уже говорил да
[42:06.900 --> 42:18.300]  вернее прошу прощения говорили о денормализации на декомпозиции и у нас здесь появляется
[42:18.300 --> 42:24.580]  эквивалентность операции у нас правильно проведенные декомпозиции должно быть
[42:24.580 --> 42:32.260]  эквивалентно ну вернее обратно прошу прощения она должна быть обратной обратной обратимость
[42:32.260 --> 42:38.980]  операции она должна быть обратно соединению и правильной декомпозиции вернее декомпозиции
[42:38.980 --> 42:45.100]  называется декомпозиции без потерь или правильной если она обратимо путем соединения всех тех
[42:45.100 --> 42:53.540]  результирующих отношений которые мы получили используя правила нормальных форм
[42:53.540 --> 43:01.780]  перечень нормальных форм ну таких в некотором смысле классических да хотя
[43:01.780 --> 43:12.060]  вот на практике ниже третьей и бойса кода ну можно сказать что особо-то и не опускаются
[43:12.060 --> 43:22.340]  вопрос даже наоборот вопрос в том что различные решения тех или иных вендеров и даже опенсорс
[43:22.340 --> 43:29.340]  решения часто могут применяться в одной фирме параллельно разных департаментах все это потом
[43:29.380 --> 43:35.940]  в итоге сводится в какое-то какое-то хранилище либо вообще в озеро и из этого озеро или хранилище
[43:35.940 --> 43:47.420]  или там океана данных достается это все в какие-то о лапубы трансформируется то есть все на самом
[43:47.420 --> 43:53.980]  деле характеризуется скорее хаотичностью причем еще у нас на этапе дата вар хаусс хранилищ
[43:53.980 --> 43:58.300]  данных есть свои требования по проектированию которые немножко отличаются
[44:01.140 --> 44:09.980]  классическом подходе скажем так которые заложили кимбал и инман мы об этом с вами поговорим в конце
[44:09.980 --> 44:18.900]  курса обзор на там есть свои в общем требования и при этом эти требования тоже сами не всегда
[44:18.900 --> 44:25.380]  соблюдаются поэтому говорить о том что у нас вот прям есть какая-то реальная жизнь для там
[44:25.380 --> 44:32.860]  что стоит для доменно ключевой нормальной формы в производстве в реальном продакшене за пределами
[44:32.860 --> 44:38.740]  там теоретических изысканий ну скорее нет скорее нет если только вы там захотите какой-то может
[44:38.740 --> 44:48.140]  быть pet project сделать где вы будете отвечать за все front-end и the back-end и в том числе за
[44:48.140 --> 44:54.500]  модель данных вы там можете конечно нормализовывать как вы захотите реальных в реальном реальной
[44:54.500 --> 45:00.860]  ситуации происходит так что конечно данные не то что тяжело нормализовывать их порой бывает не
[45:00.860 --> 45:08.620]  просто сводить при большом объеме и разнородности лишь используемых решений для хранения не говоря
[45:08.620 --> 45:17.300]  уже про то чтобы нормализовывать все вот этого едино а так ну давайте посмотрим по нормальным
[45:17.660 --> 45:28.500]  что это такое и как так как это применяется применяется ну самое первое нормальное форма
[45:28.500 --> 45:35.420]  самая простая определение проведено на слайде и переменные отношения находятся в первой нормальной
[45:35.420 --> 45:41.900]  форме тогда и только тогда когда значение всех атрибутов отношение а там арды то есть отношения
[45:41.900 --> 45:45.700]  находятся в первом нормальной форме если все его атрибуто являются простые все используемые
[45:45.700 --> 45:55.500]  Домена содержит только скалярные значения, и выглядит это вот так, вернее, это не выглядит
[45:55.500 --> 46:02.780]  вот так, потому что в данном случае у нас нарушено условие определения, у нас не все атрибуты
[46:02.780 --> 46:12.620]  атомарны. И если атрибут-семинарист, несмотря на двусложность, двусловность строки, это все еще
[46:12.620 --> 46:21.180]  строковый литерал, то атрибут группы это на самом деле не строка, ребята, это отдельные числовые
[46:21.180 --> 46:28.820]  значения. То есть в первой строчке у нас три разных числа, а не строка с там получается
[46:28.820 --> 46:39.420]  четырнадцатью символами. Ну и так, соответственно, по каждой строке каждой группы. Первая нормальная
[46:39.420 --> 46:47.540]  форма у нас таким образом должна, для того чтобы ее, для того чтобы наше отношение вот это вот,
[46:47.540 --> 46:56.120]  приведенное на данном сладе нормализовать, мы должны вот этот атрибут группы, его значение
[46:56.120 --> 47:06.620]  развернуть, сделать все это одной большой колонкой, ну вернее колонкой с множеством строк. И таким
[47:06.620 --> 47:25.180]  образом получается вот такой результат. Смотрите, атрибут-семинарист это строка просто. Это строка.
[47:25.180 --> 47:35.420]  То есть не смотрите на пробел, он не дает автоматического разделения. Это строка вот Халляпов
[47:35.900 --> 47:42.780]  от буквы Х до буквы Р. Единая большая строка. А атрибут группы это целочисленные значения,
[47:42.780 --> 47:56.860]  и в данном случае вот они реально в диапазоне от 911 до 952. И мы развернули массив из целочисленных
[47:56.860 --> 48:10.100]  элементов, по сути дела. Нет, там вопрос не в типе. Вопрос не в типе, конечно же, данных. Ну смотрите,
[48:10.100 --> 48:32.660]  да, тип текста, тип блоп, они не будут простыми в таком классическом понимании. Но здесь это
[48:32.660 --> 48:42.860]  вопрос скорее такой, да, логический что ли, нежели вопрос представления. Понятно, что строка это у нас
[48:42.860 --> 48:53.260]  массив символов. Массив символов, которые у нас там, не знаю, наверное, мне кажется, не представляю
[48:53.260 --> 49:00.020]  себе языка программирования, где нельзя было бы обратиться к отдельному символу в строке. Но в
[49:00.020 --> 49:05.420]  данном случае речь идет не о типах данных, которые у нас напрямую завязаны на аппаратную
[49:05.420 --> 49:11.300]  составляющую или на реализацию нашего языка программирования, на его виртуальные машины и
[49:11.300 --> 49:17.420]  так далее, как он взаимодействует с аппаратной составляющей. Нет, здесь вопрос в том, какова
[49:17.420 --> 49:29.180]  логика того, что мы делаем. И с точки зрения типов данных SQL стандартных, тип строка это атомарный
[49:29.180 --> 49:40.740]  тип. Тип число, целое число, это тоже атомарный тип, и поскольку, да, ну окей, давайте так
[49:40.740 --> 49:45.340]  представьте, что у нас в атрибуте семинарист все заключено в одинарной кавычке, а в атрибуте
[49:45.340 --> 49:51.020]  группы не заключено в одинарной кавычке. То есть, чтобы было еще более явно, семинарист у нас все
[49:51.020 --> 49:57.100]  строки с точки зрения стандарта SQL, там строка, причем не просто строка, давайте еще и возьмем
[49:57.100 --> 50:05.860]  какой-нибудь, не знаю, war char конечной длины. Ну тоже, да, я соглашусь, что здесь есть определенная
[50:05.860 --> 50:15.220]  непоследовательность, может быть, но надо, наверное, здесь отталкиваться не от такого прямого аппарата,
[50:15.220 --> 50:22.820]  что ли, взгляда и подхода, а от подхода логического. Мы здесь разделяем сущности. Сущность халяпов
[50:22.820 --> 50:31.580]  Alexander это вид instance, да, экземпляр класса семинарист, условно говоря. Сущность 911,
[50:31.580 --> 50:38.740]  921, 924 это не экземпляр класса группы, это три экземпляра класса группы, и нам нужно эти
[50:38.740 --> 50:43.580]  экземпляры разделить между собой, и в этом будет логика, это будет осмысленное действие с точки
[50:43.580 --> 50:49.740]  зрения нашей модели. Разделение халяпов и Alexander на двух отдельных представителей класса
[50:49.740 --> 50:59.980]  семинарист смысла будет лишь ино, поэтому это с точки зрения релиционной модели, о которой мы говорим,
[50:59.980 --> 51:05.340]  потому что нормализация это операция в рамках модели релиционной, а не в рамках системы управления
[51:05.340 --> 51:11.140]  базой данных. С точки зрения релиционной модели здесь все нормально, нет никакой проблемы с точки
[51:11.140 --> 51:21.860]  зрения того, что строковый литерал у нас вот такой длитый, хотя можем теоретически поизвращаться и
[51:21.860 --> 51:30.180]  попридумывать запросы даже из процедурного расширения постгроса каким-нибудь отдельным
[51:30.180 --> 51:41.380]  символом как-то исхитриться вот этой строки. Вторая нормальная форма, вторая нормальная форма,
[51:41.380 --> 51:47.940]  и здесь о чем идет речь. Переменные отношения у нас находятся во второй нормальной форме тогда,
[51:47.940 --> 51:52.780]  и только тогда, когда она находится в первой нормальной форме, и каждый не ключевой атрибут
[51:52.780 --> 52:00.060]  минимально функционально зависит от потенциального ключа. Давайте разбираться, что это все значит.
[52:00.060 --> 52:06.380]  Функциональную зависимость мы с вами уже описывали, мы рассматривали ее несколькими
[52:06.380 --> 52:15.960]  слайдами ранее. Еще раз просто воспроизведу, что между множествами атрибутов x и y функциональная
[52:15.960 --> 52:19.140]  зависимость и ее наличие означает, что для любого допустимого набора картридж в данном отношении
[52:19.140 --> 52:23.100]  верно следующее. Если два картриджа совпадают по значению x, то они совпадают по значению y.
[52:23.100 --> 52:31.180]  При этом минимальная функциональная зависимость означает, что в составе первичного ключа отсутствует
[52:31.180 --> 52:36.660]  меньшее под множество атрибутов, от которого можно также вывести данную функциональную зависимость.
[52:36.660 --> 52:51.140]  То есть у нас, условно говоря, из первичного ключа, состоящего из трех атрибутов, нельзя сделать
[52:51.140 --> 53:00.020]  первичный ключ, состоящий из двух атрибутов, который будет еще и представлять элемент
[53:00.020 --> 53:04.580]  функциональной зависимости для данного картриджа. Давайте посмотрим на примере.
[53:04.580 --> 53:22.700]  Вопрос, почему это не следует из определения потенциального ключа.
[53:22.700 --> 53:30.820]  Из определения потенциального ключа это не следует, потому что потенциальный ключ у нас
[53:30.820 --> 53:42.820]  говорит о том, что это просто набор атрибутов минимально. Это один атрибут, максимально
[53:42.820 --> 53:50.420]  теоретически неограниченный, под множество атрибутов конкретного отношения, которые
[53:50.420 --> 53:56.180]  характеризуются уникальностью и неизбыточностью. У нас определение не говорит о том, что мы можем
[53:56.180 --> 53:59.300]  добавить в него другие атрибуты, не входящие в потенциальный ключ.
[53:59.300 --> 54:28.060]  Вопрос, что такое допустимый набор картриджей. Смотрите, у нас закончилась мысль про
[54:28.060 --> 54:38.500]  функциональную зависимость и нормальную форму. Потенциальный ключ у нас говорит просто о том,
[54:38.500 --> 54:51.340]  что сами столбцы наши должны минимально один столбец, максимально два-три столбца,
[54:51.340 --> 54:57.780]  вот каждый либо один элемент отдельно в одном столбце, если мы его берем за ключ,
[54:57.780 --> 55:05.540]  первичный рассматриваем в качестве кандидатуры первичного ключа, либо картридж из двух атрибутов,
[55:05.540 --> 55:11.940]  из трех атрибутов, для двух-трех атрибутов рассматриваемых на роль первичного ключа,
[55:11.940 --> 55:21.620]  они должны быть уникальны и мы не можем сократить наш трех элементный картридж до двух элементного
[55:21.620 --> 55:33.780]  картриджа. И здесь нет никакой явной связи между выводимостью, а здесь у нас по сути дела речь
[55:33.780 --> 55:51.740]  идет о том, что мы, если у нас есть x значение и y в двух атрибутах, не обязательно что у нас
[55:51.740 --> 55:59.660]  y входит в потенциальный ключ, он вообще не должен даже входить, но вот x например входит или вообще
[55:59.660 --> 56:05.780]  у нас даже может не быть никакого ключа, то есть это про функциональную зависимость как таковой,
[56:05.780 --> 56:12.540]  и у нас может не быть первичного ключа, но у нас получается, что в одном картридже у нас,
[56:12.540 --> 56:22.220]  если есть x, то есть y, в другом картридже, если у нас есть x, то есть y, в третьем картридже у нас
[56:22.220 --> 56:34.900]  есть y, но нету x, получается, что по x у нас совпадает, по y у нас обратной зависимости нет,
[56:34.900 --> 56:41.700]  то есть это нормально, а это никак не влечет какую-то уникальность, неуникальность с точки
[56:41.700 --> 56:47.060]  зрения определения потенциального ключа, наверное как-то так. Давайте я подумаю,
[56:47.060 --> 56:50.660]  как лучше, наверное, на это еще ответить, в принципе, это такой теоретический вопрос.
[56:50.660 --> 56:59.260]  Ну хорошо, я постараюсь как-то более емко, чтобы это изложить в следующей лекции. В целом,
[56:59.260 --> 57:06.980]  вопрос слевопытный, да, в области, правда, высокой теории, но тем не менее. Для любого
[57:06.980 --> 57:16.100]  допустимого набора картриджей имеется в виду, что картридж соответствует условиям, налагаемым
[57:16.100 --> 57:23.180]  на данное отношение с точки зрения ограничений, с точки зрения, то есть у нас не просто какие-то
[57:23.180 --> 57:30.340]  атрибуты x и y абстрактно существующие, а в рамках какого-то отношения конкретно вам и у конкретного
[57:30.340 --> 57:36.380]  отношения конкретные ограничения, поэтому допустимый набор картриджей. Так, хорошо,
[57:36.380 --> 57:43.660]  давайте посмотрим на табличку, все-таки чтобы было это все на каком-то примере. Любое переменное
[57:43.660 --> 57:48.060]  отношение, находящееся в первой нормальной форме, но не находящееся во второй нормальной
[57:48.060 --> 57:51.860]  форме, может быть приведено к набору переменных отношений, находящихся во второй нормальной форме,
[57:51.860 --> 57:58.540]  а вот такое важное свойство, то есть мы всегда первой формы можем, ну,
[57:58.540 --> 58:08.380]  окей, там если у нас два атрибута, да, можем там, конечно, по ним разделить, провести искусственное
[58:08.380 --> 58:13.980]  разделение, сделать срогатные ключи и как-то функциональные зависимости наводить, но, да, там,
[58:13.980 --> 58:21.660]  понимать вот это условие нужно тоже так немножко широко, что любое переменное отношение как бы
[58:21.660 --> 58:25.260]  теоретически может быть приведено к набору переменных отношений, находящихся во второй форме,
[58:25.260 --> 58:31.860]  но это не всегда реально необходимо, что называется, а в результате этой композиции получим набор
[58:31.860 --> 58:36.020]  проекции исходной переменной отношения, причем обратимый, но это в общем-то по определению
[58:36.020 --> 58:45.460]  правильной декомпозиции, декомпозиции без потерью. Так, а вторая нормальная форма,
[58:45.460 --> 58:54.660]  что у нас здесь есть? Вот название, да, табличка с данными по произведениям и альбомам группы
[58:54.660 --> 59:01.420]  Scorpions. Вот она так выглядит. Ну, что-то здесь, наверное, не так, что-то здесь кажется избыточным,
[59:01.420 --> 59:12.740]  что-то здесь, да, вот Scorpions Worldwide, Worldwide Life, да, три раза повторяется. Здесь какие-то
[59:12.740 --> 59:20.220]  повторения, какие-то перекрещивающиеся данные, как будто немножко похожие на нашу табличку с
[59:20.220 --> 59:28.980]  поставщиками и с адресами, и с их адресами, и с продуктами. А данная таблица находится в первой
[59:28.980 --> 59:33.220]  нормальной форме. Опять же, да, мы уже, как с вами, просуждали, что строка это нормально,
[59:33.220 --> 59:38.460]  нормальное табарное значение, но не во второй нормальной форме, так как автор слов и композитор
[59:38.460 --> 59:46.980]  зависит только от полей названия группы и названия песни. То есть, что это значит? Что у нас, так,
[59:46.980 --> 59:55.100]  что у нас от того, что песня включена на другой CD-диск, значение этих полей никак не изменяется.
[59:55.100 --> 01:00:08.380]  Как мы это видим, да, мы смотрим, ну вот буквально на примере, название группы, название песни совпадают
[01:00:08.380 --> 01:00:17.060]  Scorpions Blackout, Scorpions Blackout, и у нас одинаковые значения по Y. Рудольф Шенкер, Клаус Майне.
[01:00:17.060 --> 01:00:26.620]  А здесь у нас различаются значения, и если мы возьмем вот этот вот картеж целиком из трех
[01:00:26.620 --> 01:00:34.340]  атрибутов состоящий, то, ну, очевидно, да, очевидно, ну, исходя из вот перечисленных всех определений,
[01:00:34.340 --> 01:00:45.460]  что вот это вот у нас нефункциональная зависимость. По сути, здесь у нас X1, это Y, и X2 тоже Y. А у нас
[01:00:45.460 --> 01:00:52.220]  должны совпадать, X1, при этом, должны совпадать с X2 для конституирования функциональной зависимости,
[01:00:52.220 --> 01:00:59.620]  а X1 с X2 не совпадает. Какие здесь еще можно функциональные зависимости попроводить, опять же, да,
[01:00:59.620 --> 01:01:16.060]  например, так, Worldwide Life, Рудольф Шенкер или Scorpions Worldwide Life, Рудольф Шенкер, Клаус Майне.
[01:01:16.060 --> 01:01:23.820]  Тоже функциональная зависимость. Совпадают по X, совпадают по Y. Так, Blackout и Рудольф Шенкер.
[01:01:23.820 --> 01:01:30.460]  Причем здесь у нас не может быть составного первичного ключа, поназвающего D-диск и название песни,
[01:01:30.460 --> 01:01:44.380]  потому что они характеризуются здесь свойством сократимости. У нас, ну, мы можем без потерь выкинуть
[01:01:44.380 --> 01:01:52.260]  название либо одного, либо другого, потому что они идентичны. Что нам нужно в общем сделать для того,
[01:01:52.260 --> 01:01:57.940]  чтобы привести вот это вот отношение, находящееся в первой нормальной форме, в отношение, находящееся во
[01:01:57.940 --> 01:02:08.180]  второй нормальной форме. А, собственно говоря, вот что. Давайте еще раз. Мы здесь название группы,
[01:02:08.180 --> 01:02:17.260]  название D-диска, название песни вынесли отдельно. У нас получается, что при этом название группы и
[01:02:17.340 --> 01:02:27.740]  название песни мы оставили в изначальной таблице. И мы здесь можем посмотреть на
[01:02:27.740 --> 01:02:33.860]  функциональной зависимости. Да вот, ну, здесь, конечно, еще можно нормализовывать еще больше.
[01:02:33.860 --> 01:02:42.820]  Это не предел. Мы здесь взяли только один из возможных вариантов того, что мы здесь видим.
[01:02:42.820 --> 01:02:51.180]  Можем теперь разделить нижнее отношение тоже. Можем верхнее поразделять, поиграться. Но самое
[01:02:51.180 --> 01:02:58.420]  главное, мы вот выявленную проблему, когда у нас Scorpions World White Life Blackout, Scorpions Blackout
[01:02:58.420 --> 01:03:15.340]  не давали функциональную зависимость по автору слов и композитору. То есть вот это вот у нас Y,
[01:03:15.340 --> 01:03:22.900]  это у нас X, это у нас Y. Мы ее разбили. Теперь у нас название слов, название песни, автор слов,
[01:03:22.900 --> 01:03:29.260]  автор-композитора. И всегда функционально зависит вот это вот автор слов, композитора,
[01:03:29.260 --> 01:03:41.060]  название слов, название песни. Ну и, соответственно, здесь тоже это как бы наглядно подчеркивается
[01:03:41.060 --> 01:03:44.620]  тем, что выделяются, собственно говоря, заголовки отношения.
