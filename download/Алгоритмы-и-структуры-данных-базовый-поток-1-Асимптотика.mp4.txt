[00:00.000 --> 00:11.040]  Сегодня мы будем говорить с вами о таком математическом аппарате алгоритмов, то есть
[00:11.040 --> 00:18.760]  то, что нам будет необходимо в этом случае для того, чтобы работать с алгоритмами, чтобы понять,
[00:18.760 --> 00:25.160]  что такое симптотики, как с ними правильно действовать, чтобы вы никогда не сталкивались
[00:25.160 --> 00:38.360]  с проблемами в случае их. Самое главное, что такое алгоритм? Почему здесь написана эта база?
[00:38.360 --> 00:44.680]  Не потому что вы базовый поток, не только поэтому, потому что на самом деле алгоритмы вам понадобятся
[00:44.680 --> 00:53.280]  почти везде. Если посмотреть прагматично на эту точку зрения, если вы захотите пойти
[00:53.280 --> 01:00.120]  стажироваться, вы скорее всего начнете с этого момента, с этого старта и даже типа на джуна,
[01:00.120 --> 01:06.120]  на джуна плюс вам необходима будет алгоритмическая секция. В зе алгоритмической секции вы никуда не
[01:06.120 --> 01:12.400]  пройдете почти, это сложно. То есть не только язык играет, а ваше еще мышление, поэтому это
[01:12.400 --> 01:22.680]  очень важно. И вообще, что такое алгоритм? Есть предположение? Да, последовательность операции,
[01:22.680 --> 01:33.040]  то есть 5 плюс 2 это алгоритм? Последовательность действий. 5 плюс 2 это алгоритм? Решает какую-то
[01:33.040 --> 01:43.520]  задачу. Хорошо, так. Чтобы получить 7, нужно сделать 5 плюс 2. Это алгоритм получения 7. Хорошо,
[01:43.520 --> 01:51.240]  на самом деле я не буду душнить в этом плане, я не буду вас спрашивать типа на экзамене,
[01:51.240 --> 02:00.840]  что же такое алгоритм, какой-то конкретной вещи. Один из достаточно серьезных ученых сказал,
[02:00.840 --> 02:06.680]  что очень много психологических проблем было получено в момент, когда искали разницу между
[02:06.680 --> 02:12.200]  алгоритмом и программой. Запомните этот момент, потому что для вас это может быть плюс-минус одно
[02:12.200 --> 02:17.640]  и то же, и это по факту может быть одно и то же. Но алгоритм это просто действительно какая-то
[02:17.640 --> 02:23.240]  последовательность действий, приводящих к конкретному результату, который мы хотели бы. Можете сказать это
[02:23.240 --> 02:29.160]  примерно так. Никто никогда в жизни вас особо не спросит, что такое алгоритм, а спросит какой-то
[02:29.160 --> 02:36.960]  конкретный алгоритм, алгоритм сортировки. Вот тут будет важно уже. Ну и давайте с вами поговорим дальше.
[02:36.960 --> 02:48.200]  Смотрите, я говорю, алгоритм работает за 0,5 секунды. Много ли информации вы из этого получаете?
[02:48.200 --> 03:03.520]  Хорошая информация, отлично. А что не так с этим всем? С чем? Ну в смысле, ну не знаю, вот раз запустил 0,5 секунды.
[03:07.960 --> 03:14.080]  Давайте еще раз. То есть, когда я говорю время, вам не нравится, что это время работы алгоритма,
[03:14.080 --> 03:28.000]  правильно? Что вам понравится? Количество операций. Каких? Радных. Базовых? Возвращаемся к базе, я понял.
[03:28.000 --> 03:38.880]  Хорошо. На самом деле, здесь мы придем ко всему этому. Сам по себе фраза алгоритм работает за какое-то
[03:38.880 --> 03:45.120]  время, конкретное, очень редко несет информацию. Почему? Потому что это связано, что у вас разное
[03:45.120 --> 03:54.720]  железо. Ну не знаю, кто-то там на компьютере 90-х годов сидит, кто-то там на 2020-м типа, а кто-то вот
[03:54.720 --> 03:59.840]  сейчас, не знаю, с квантовыми компьютерами развлекается. Всех по-разному бывает. Поэтому здесь время
[03:59.840 --> 04:05.880]  работы алгоритма никогда не будет означать конкретное время. Мы не будем говорить о времени, хотя в контестах
[04:05.880 --> 04:12.320]  у вас всегда будет ограничение. Одна секунда, полторы секунды, 0,8 секунды и так далее. Здесь мы с вами
[04:12.320 --> 04:21.560]  научимся говорить о, что же там происходит и как это примерно посчитать. Но, так как маме время не нравится,
[04:21.720 --> 04:31.240]  мы будем говорить про асимптотики. Асимптотики нам помогут говорить о том, за сколько алгоритм работает в
[04:31.240 --> 04:38.880]  зависимости от какого-то параметра. То есть здесь, когда мы будем с вами говорить об этом, мы скажем,
[04:38.880 --> 04:46.600]  что вот у нас есть массив из n элементов, на нем алгоритм работает за n квадрат. Понятно это уже?
[04:46.600 --> 04:56.200]  Понятно. Почему? Потому что если я возьму 10 элементов, мы скажем 100 операций. Если мы возьмем 100
[04:56.200 --> 05:02.040]  элементов, то будет уже 10 в четвертые операции и так далее. То есть в этом плане вам будет это
[05:02.040 --> 05:12.160]  достаточно полезно. Для этого нам нужно окунуться в матан. Такой вот базовый математический аппарат,
[05:12.160 --> 05:18.240]  который используется в алгоритмах. Нам помогут следующее обозначение. Кто знает,
[05:18.240 --> 05:27.440]  как прочитать все буквы? А? Т, Т, О, Омега. Все верно. Сейчас будем останавливаться на
[05:27.440 --> 05:35.560]  каждый из них. И первое у нас будет о-обозначение. Смотрите, что такое о-большое? Вы часто могли
[05:35.560 --> 05:43.400]  сталкиваться с тем, что вам говорят, алгоритм работает за о от n. Что это означает? Смотрите,
[05:43.400 --> 05:52.080]  если я говорю, что у меня есть какие-то функции f и g из натуральных чисел в не отрицательные
[05:52.080 --> 05:57.920]  действительные числа. У меня есть некоторые такие функции. Эти функции обозначают время работы,
[05:57.920 --> 06:04.800]  а они зависят от n. Ну то есть грубо говоря, давайте представим, что у нас есть n элементов,
[06:04.800 --> 06:11.760]  опять же, в массиве или просто число n. И вот от n время работы алгоритма, то есть количество действий,
[06:11.760 --> 06:18.640]  будет зависеть каким-то образом. Мы не знаем точно каким, но вот может быть по-разному. Ну не знаю там,
[06:18.640 --> 06:26.560]  2 умножить на n, может быть такое, да может быть. Нет никакой проблем. Так вот, мы будем говорить,
[06:26.560 --> 06:35.400]  что о-большое от g от n, то есть от любой такой функции, это множество функций f от n. Такое,
[06:35.400 --> 06:45.080]  что существует некоторая константа c больше 0, существует n0 из натуральных чисел, что для
[06:45.080 --> 06:52.160]  любого n больше либо равного n0 мы говорим, что функция, она же у нас не отрицательная,
[06:52.160 --> 07:00.120]  поэтому она больше либо равна 0, больше 0, и она меньше, чем c умножить на g от n. То есть смотрите,
[07:00.120 --> 07:08.800]  о-большое означает, что если я вот это g от n возьму и умножу на какой-то конкретный элементик,
[07:08.800 --> 07:14.960]  ну на какое-то конкретное число, и я знаю, что оно существует и взял именно его, тогда в этом
[07:14.960 --> 07:29.480]  случае я сверху ограничу свою функцию. Вроде пока понятно. Хорошо, а давайте с вами посмотрим на это
[07:29.480 --> 07:39.080]  все. Вот у нас есть некоторые примеры, что с ними делать. Вот кто мне скажет, вот если я пишу равно,
[07:39.080 --> 07:48.160]  я что-нибудь нарушаю из математической логики, вот что-нибудь такое, а справа множество, это правда,
[07:48.160 --> 07:55.520]  то есть по-хорошему я должен писать принадлежит, но это лень. Привыкайте к тому, что программисты
[07:55.520 --> 08:00.640]  ленивые люди, они не будут писать что-то лишнее, поэтому будем писать равно или не равно. Все,
[08:00.720 --> 08:09.720]  все достаточно просто. Давайте с вами разберем какие-нибудь простые примеры. И первая там 1,
[08:09.720 --> 08:21.800]  вторая квадрат, минус n, и как это связано с u от n квадрат. Смотрите, в этом случае достаточно
[08:21.800 --> 08:30.320]  просто что сделать. Достаточно просто брать и делать все по определению. То есть вот у меня есть
[08:30.320 --> 08:40.680]  1, вторая n квадрат, минус n. Я должен найти такое c, что эта функция будет меньше, чем c на n квадрат.
[08:40.680 --> 08:53.480]  Согласны? Ну чисто из определения о большого. Хорошо, вот у меня есть такая вот вещь. Достаточно
[08:53.480 --> 09:00.280]  найти это c. То, что это больше нуля, это очевидно, я надеюсь, правда, начиная с какого-то нулевого.
[09:00.280 --> 09:10.600]  Отлично. То, что здесь мы скажем, что c должно быть больше, чем 1, вторая, минус 1 делить на n.
[09:10.600 --> 09:22.280]  Ну и из этого мы, исходя, можем сказать, что пусть c равно, например, не знаю, единичка.
[09:22.280 --> 09:38.040]  Еще раз. Ну, например, можно взять единицу. Всегда это будет? Да всегда. Таким образом мы
[09:38.040 --> 09:44.640]  ограничим это. Конечно, можно выбрать точно. Никто не спорит. Но это не обязательно. Нам нужно
[09:44.640 --> 09:50.320]  доказать, что просто существует такое c, чтобы это было. Если мы с вами это нарисуем на графике,
[09:50.320 --> 09:56.600]  то это становится ну просто очевидно. Вот у нас есть 1, вторая n квадрат, минус n. Она будет как-то
[09:56.600 --> 10:04.480]  вот так идти на самом деле. Заметьте, она будет вот так по точечкам идти. Ну а n квадрат вот так.
[10:04.480 --> 10:17.840]  Все, вот оно, решение этой задачи. Поэтому давайте ваше предположение. Верно ли второе? Кто за
[10:17.840 --> 10:28.880]  то, что да? Кто за то, что нет? Чудесно. Хорошо. По поводу третьего. Это правда или нет? Давайте.
[10:28.880 --> 10:41.760]  Правда? Неправда. Хорошо. Ладно, а последнее? Ой, нет, давайте n равно u от n квадрат. Это правда?
[10:41.760 --> 10:56.000]  А кто считает, что это неправда? Ага, хорошо. Ну и последнее. Кто считает, что это неправда?
[10:56.000 --> 11:13.320]  Хорошо, принято. Смотрите, давайте рассмотрим вот этот предпоследний хотя бы вариант. Мы говорим,
[11:13.320 --> 11:22.440]  что у нас есть n и n квадрат. Мне нужно просто сделать вот так. Это всегда прецетом, например,
[11:22.440 --> 11:33.680]  единички. Мы возьмем и c будет больше одного на n, начиная с какого n. Ну и ноль возьмем единичку.
[11:33.680 --> 11:43.320]  То есть смотрите, o большое, оно ограничивает как бы сверху, это правда, но я могу бесконечно
[11:43.320 --> 11:51.400]  уходить там до n в степени n. Я могу сказать, что функция o большое от n в степени n. Хорошо это
[11:51.400 --> 11:58.240]  или плохо? Плохо. Мы ничего не понимаем. Ну, типа, очень странно, что у меня алгоритм работает
[11:58.240 --> 12:04.840]  за u от n, за n точнее шагов, а мы говорим, что он работает за u от n в степени n. Так вот,
[12:04.840 --> 12:13.440]  всегда, когда пытаются писать o большое, ищут ту грань, которая является еще самой близкой и
[12:13.440 --> 12:19.040]  необходимой для нашего какого-то множества. Естественно, если я напишу, что это u от n квадрат,
[12:19.040 --> 12:25.440]  а не u от n, ничего не изменится. Это действительно будет все еще правда. Поэтому с этим аккуратно.
[12:25.440 --> 12:31.880]  Если я вдруг вам говорю, что алгоритм работает за u от n в степени n, вы должны сказать,
[12:31.880 --> 12:40.840]  это правда, но есть получше. Вот. Все достаточно легко в этом плане. Есть вопросы к o большому? Да.
[12:49.040 --> 13:00.560]  А когда n будет больше, чем n квадрат? Н не умеет быть больше n квадрата.
[13:00.560 --> 13:24.920]  Хорошо. Так лучше? Да. Начиная с какого-то момента, вы должны к этому прийти. Ну да, смотрите,
[13:24.920 --> 13:31.600]  давайте еще раз, я вернусь назад. Видите, вот здесь я выбрал 0. Видите, синий отмечен. Вот именно
[13:31.600 --> 13:37.640]  с этого момента наша функция c от g от n становится выше. То есть до этого она могла быть ниже,
[13:37.640 --> 13:44.200]  и в этом нет никакой проблемы. Нас интересует момент асимпатический. Асимпатический означает
[13:44.200 --> 13:50.040]  на бесконечности. То есть начиная с какого-то момента и бесконечно, это становится правдой.
[13:50.040 --> 14:04.520]  Что мы выиграем? Мы выиграем в том, что мы не считаем конкретное количество действия,
[14:04.520 --> 14:12.320]  говорим за сколько это работает. Смотрите, объясню. Когда мы будем говорить, что алгоритм работает,
[14:12.320 --> 14:18.080]  к примеру, за o от n, мы еще дойдем до некоторых условностей, которые мы будем использовать при
[14:18.560 --> 14:25.400]  почете, за сколько работают алгоритмы. Это отдельная вещь. Но в том суть, что это нам поможет оценить
[14:25.400 --> 14:33.120]  и как-то сравнивать между собой алгоритмы. Вот и все. Бывают алгоритмы, у которых вот эта константа,
[14:33.120 --> 14:40.120]  грубо говоря, вот эта вот константа очень огромная, прям гигантская. И тогда алгоритмы
[14:40.120 --> 14:47.920]  бесполезны. Это правда. Ну, то есть легче использовать другой. Но если мы рассмотрим это где-то на
[14:47.920 --> 14:54.880]  бесконечность, ну, то есть, не знаю, вы работаете там с пятабайтами, Дана, то там уже этот алгоритм будет
[14:54.880 --> 15:12.040]  выигрывать. Давайте еще раз объясню. У нас есть функция f и g. Она идет из натуральных чисел в
[15:12.040 --> 15:20.960]  неотрицательные числа. Вот эта функция, грубо говоря, подсчитывает количество действий вашего
[15:20.960 --> 15:28.960]  алгоритма. То есть, у меня есть какой-то вход, который зависит от n. Это может быть длина массива
[15:28.960 --> 15:38.240]  n элементов. Это может быть само число n, как из примеров. И что тогда в этом случае происходит?
[15:38.240 --> 15:51.680]  Вот эта функция будет показывать мне количество действий. А так как она показывает количество
[15:51.680 --> 15:58.320]  действий, то я осознаю, если у меня каждое действие работает там за какой-то 1, одну условную единичку,
[15:58.320 --> 16:06.640]  то я осознаю, что на бесконечности это будет как n квадрат вести себя. Понятно? Есть ли еще какие-то
[16:06.640 --> 16:16.400]  вопросы пока к этому кусочку? Нет? Тогда переходим. Вот как бы ответ, на всякий случай. Если будете
[16:16.400 --> 16:24.280]  потом просматривать, запомните. Омегабольшое обозначение. Смотрите, омегабольшое это то же
[16:24.280 --> 16:34.200]  самое, что о-большое, но снизу. То есть, о-большое, оно ограничивает сверху, омегабольшое ограничивает
[16:34.200 --> 16:44.720]  снизу. Вот здесь вы можете видеть такую вот функцию. То есть, мы говорим о том, что у нас существует
[16:44.720 --> 16:59.680]  некоторая константа, что у нас вот так вот все происходит. С точки зрения математического аппарата,
[16:59.680 --> 17:06.520]  мы будем говорить, что это действительные числа. С точки зрения алгоритмов, да, они будут переходить
[17:06.520 --> 17:17.840]  в какие-то числа. Но важный момент, у нас могут возникать вот такие вот коэффициентики. В среднем
[17:17.840 --> 17:23.360]  случае бывает такое, что когда мы будем оценивать с вами средний случай, там будут какие-то коэффициенты,
[17:23.360 --> 17:40.000]  и там будут недействительные числа. Понятно? Смотрите, омегабольшое показывает нам,
[17:40.000 --> 17:47.960]  ниже чего не упадет эта функция. То есть, грубо говоря, мы скажем, что оно не может идти меньше,
[17:47.960 --> 17:55.800]  чем за о от н квадрат. Это означает, что линейно мы никогда этого не сделаем. И это нас устраивает.
[17:55.800 --> 18:03.440]  То есть, мы хотим увидеть тот предел снизу, который нам показывает, что мы вообще можем. Вот и все.
[18:03.440 --> 18:11.000]  Еще какие-нибудь вопросы есть? То есть, по определению, это то же самое, только наоборот.
[18:11.000 --> 18:27.200]  Окей? Да, это существование ко всему. Теперь, что касается омегабольшого. Давайте с вами
[18:27.200 --> 18:43.160]  рассмотрим здесь примеры. Верно ли, первое, кто считает, что да? Раз. А? С можно? Нет. Существует
[18:43.160 --> 18:51.240]  С большее нуля. Иначе мы тогда любые функции писали. Это правда или неправда? Да, давайте. Кто
[18:51.240 --> 19:00.360]  считает, что правда? Ага. А кто считает, что не правда? Ага. Все как на меме. Сначала было радостно,
[19:00.360 --> 19:09.360]  потом становится грустнее. Давайте с вами разберем этот пример. Давайте я вот здесь где-нибудь нарисую.
[19:09.360 --> 19:22.120]  Мы говорим, что в какой-то момент c от n квадрат, что она должна сделать? Она
[19:22.120 --> 19:36.160]  должна быть меньше, чем 1 вторая n квадрат минус n. Ну скажем, что c меньше, чем 1 вторая минус 1 на n.
[19:36.160 --> 19:47.400]  Ну при n, к примеру, равным 2, давайте 3. 0 возьмем 3. У меня c должно быть меньше,
[19:47.400 --> 20:02.360]  чем 1 вторая минус 1 третья. Ну это сколько? 1 шестая. Ну давайте возьмем 1 десятую. Все.
[20:02.360 --> 20:11.360]  Вот оно, что нам помогает. То есть смотрите, здесь мы можем говорить, что мы вот так вот снизу
[20:11.360 --> 20:19.320]  ограничиваем. Поэтому первое это правда. А вот правда ли второе? Правда ли, что 1 вторая n квадрат
[20:19.320 --> 20:29.120]  минус n это омега большое от n? Давайте. Кто да? У нас сегодня соцопроцеп просто, я настроение в целом.
[20:29.400 --> 20:40.880]  Так, хорошо. А кто считает, что не правда? Нет таких людей. Вы не забывайте, что иногда большинство
[20:40.880 --> 20:51.280]  умеет ошибаться. А кто считает, что последнее это правда? А не правда? Хорошо. Сейчас вы на друг друга
[20:51.280 --> 20:56.720]  смотрите и кто поднимет, кто не поднимет. Действительно, первое, второе действительно правда,
[20:56.720 --> 21:06.000]  а третье не правда. Вот. Это достаточно простые вещи. А теперь перейдем к еще более интересной
[21:06.000 --> 21:16.320]  вещью. Т это обозначение. Т это обозначение это то же самое, что омега и о большое вместе взятое.
[21:16.320 --> 21:24.880]  То есть мы можем выбрать константу c1 и c2 для одной функции g, что она зажмет нашу функцию f.
[21:24.880 --> 21:43.160]  Пересечение? Да, это оно и есть. Все правда. То есть смотрите, что такое это большое? Мы просто
[21:43.160 --> 21:50.440]  выбираем некоторые константы c1 и c2, умножаем на нашу функцию g и говорим, что если мы возьмем
[21:50.440 --> 21:57.040]  константу c1, то она будет подпирать нашу функцию снизу. Если мы возьмем нашу константу c2, то она
[21:57.040 --> 22:03.840]  будет подпирать нашу функцию сверху. И мы таким образом выбираем конкретные функции, которые к
[22:03.840 --> 22:10.120]  этому относятся. Т это самые прелестные функции. Они сложнее всего находятся, но они самые чудесные.
[22:10.120 --> 22:18.400]  Почему? Потому что в этом случае мы точно можем сказать, как асимпатически ведет себя функция. То
[22:18.400 --> 22:24.360]  есть да, может быть у нас могут быть некоторые проблемы с коэффициентами, но в то же время
[22:24.360 --> 22:30.280]  асимпатически мы явно указываем, как ведет себя та или иная функция, то есть то или иное количество
[22:30.280 --> 22:46.440]  действий. Классно? Классно. А что? Нет, почему? Это целое множество. Давайте посмотрим с вами на
[22:46.440 --> 22:55.320]  первый пример. Правда это или нет? Да. Отлично. Тогда вы не такая девочка, как здесь. У вас все-таки
[22:55.320 --> 23:11.160]  есть праздник. Вот. Окей. Правда ли последняя? Да. А правда ли второе? Смотрите, не второе,
[23:11.160 --> 23:19.200]  не последнее, не правда. А нет, последняя правда, извините. Там n-куб. То есть в этом случае мы говорим
[23:19.200 --> 23:24.440]  о следующем, что действительности мы можем зажать. Давайте распишем на всякий случай тету,
[23:24.440 --> 23:37.840]  чтобы вы еще раз поняли, как это сделать. Вот у нас есть некоторая функция, одна вторая,
[23:37.840 --> 23:45.000]  n-квадрат минус n. И мы говорим, что она с одной стороны больше, чем c1, n-квадрат,
[23:45.000 --> 23:54.080]  а с другой стороны меньше, чем c2, n-квадрат. Тогда в этом случае опять же разделим на n-квадрат и скажем,
[23:54.080 --> 24:02.640]  что c1 меньше, чем 1 вторая, а минус 1 делить на n и больше, чем c2. Согласны, что если я c2 возьму
[24:02.640 --> 24:12.320]  1 вторая, то всегда все хорошо. То есть это я могу сразу сделать. Ну а это мы уже с вами разбирали.
[24:12.320 --> 24:26.760]  И вот так мы получаем эту вещь. То, что это правда. Окей? Все просто. Как-то у нас очень быстро идет.
[24:26.760 --> 24:34.520]  Есть у меня ощущение, что мы можем очень быстро закончить сегодняшнюю лекцию. Неужели у вас нет вопросов?
[24:34.520 --> 24:44.360]  И вы сейчас спокойно мне будете рассказывать, как и что сделать. Что еще раз?
[24:44.360 --> 24:56.440]  Презы по алгосам будут немного в другом месте, но да, я конечно их скину. Вот. У вас доступ к ним будет,
[24:56.440 --> 25:08.600]  если захотите. Ок. Теперь связь. Взаимосвязь теты, о большой и омега. По факту можно сказать,
[25:08.600 --> 25:15.840]  что если у нас функция лежит во множестве тета большое, то она лежит и в о большом, и в омеге
[25:15.840 --> 25:23.720]  большом. По факту их пересечение равно. Все просто. Вот. Ну здесь я сделал как следствие,
[25:23.720 --> 25:30.440]  что тета лежит и в о множестве тета. Оно является под множеством о большого и под множеством
[25:30.440 --> 25:40.600]  омег большое. Вот. А здесь, кстати, почему-то здесь не отобразилась фигурная скобочка. Извините.
[25:40.600 --> 25:47.560]  Странно. У меня она была. Но ничего страшного. То есть здесь мы просто с вами говорим о том,
[25:47.560 --> 25:53.320]  что эти вещи друг друга заменяют. И если вы нашли тету, то вы сразу знаете и о большое.
[25:53.320 --> 26:02.040]  И омега большая. И это хорошо. Но найти тету категорически сложно. Бывает. Бывает очень просто.
[26:02.040 --> 26:08.560]  Всегда по-разному, в зависимости от алгоритма. Бывают такие алгоритмы, которые не имеют какой-то
[26:08.560 --> 26:16.000]  конкретный тет. Не может быть такого. Например, кто из вас знаком, что такое быстрая сортировка?
[26:16.000 --> 26:25.600]  Есть такие. За сколько в худшем случае она работает? Нет. В худшем случае она работает за
[26:25.600 --> 26:32.600]  n квадрат. Именно из-за этого у нас начинаются вопросы. Поэтому здесь не всегда можно сказать,
[26:32.600 --> 26:38.380]  что у нас алгоритм работает за столько. И мы к этому тоже перейдем. Как нам смотреть,
[26:38.380 --> 26:47.260]  за сколько работает тот или иной алгоритм? Вопрос следующий. Смотрите, у вас есть логарифмы.
[26:47.260 --> 26:57.340]  Очень часто в алгоритмах пишут от логарифма N. Почему я могу так писать? Потому что да,
[26:57.340 --> 27:03.900]  я могу привести к любому основанию, который у нас есть. Я могу взять основание вот здесь,
[27:03.900 --> 27:14.500]  вот A, и получить его из C. Или наоборот. Просто снизу заметьте, что логарифм A по основанию C это
[27:14.500 --> 27:20.580]  всегда константа. Какая-никакая, но константа. А это означает следующее, что если я домножу на
[27:20.580 --> 27:26.460]  константу, то все хорошо. А это уже без разницы, потому что в C2 и в C1 добавлю эту константу.
[27:26.460 --> 27:33.060]  Ладно, ничего страшного. То есть константа здесь для нас не играет большой роли. Именно поэтому
[27:33.060 --> 27:45.740]  всегда в алгоритмах я буду писать что-то вроде алгоритм работает за O от логарифма N. Вот это будет
[27:45.740 --> 28:05.900]  выглядеть именно вот так. Что еще раз? Какой X2? Ну, это ничем не отличается, просто заметьте,
[28:05.900 --> 28:12.820]  что я основание не пишу. Вот типа у X2 хотя бы степень пишу. Если бы я не писал степень,
[28:12.820 --> 28:21.660]  это было бы уже что-то интересное. В данном случае я объясняю лишь это, потому что бывают алгоритмы,
[28:21.660 --> 28:27.860]  которые пополам делят типа бинарного поиска. Пополам делят, пополам. Там двоичный логарифм,
[28:27.860 --> 28:40.780]  но я буду всегда все равно писать логарифм АТ. ОК или есть вопрос и непонимание? Какой? Вот это?
[28:43.780 --> 29:07.540]  Вот это? Еще? Хорошо. Вы говорите, да, если я спишу. А это сложно? Оно долго? А что сложного? Ну,
[29:07.540 --> 29:18.180]  это недолго. Если ты понимаешь, как это выглядит, ты напишешь. Ну, это за минуту мне. Вот. Большая
[29:18.180 --> 29:36.540]  ноль от пресечений того и другого? Да, да, да. Вот. Тета под множество О и тета под множество
[29:36.540 --> 29:52.740]  Омеги большое, да. Что не нравится? Задумайтесь об этом. ОК. Мы реально очень быстро идем. У меня
[29:52.740 --> 30:05.020]  всего там 25 слайдов. Что-то такое. Вот. А? Блин. Ладно. Ну ничего. Сейчас я назову какие-нибудь
[30:05.020 --> 30:10.500]  слова по типу мат ожиданий, вам не понравится, поэтому все будет просто. Ничего страшного.
[30:10.500 --> 30:19.660]  Смотрите. При использовании некоторые модели мы будем проектировать, ну типа,
[30:19.660 --> 30:27.420]  говорите на... Друзья, давайте это чуть-чуть сбавим тон. Спасибо. При исследовании алгоритмов мы
[30:27.420 --> 30:33.500]  будем использовать какую-то конкретную модель, с которой будем работать. Что под этим подразумевается?
[30:33.500 --> 30:39.660]  Под этим подразумевается следующее. На практике мы что будем писать? Мы будем писать какую-то программу
[30:39.660 --> 30:46.700]  на конкретном языке программирования на каком-то конкретном компьютере. Если здесь есть какие-нибудь
[30:46.700 --> 30:56.980]  кто-нибудь из любителей, не знаю, чего-то более старого, скажем, как его, оператор ВМ, вот назовем
[30:56.980 --> 31:03.940]  вас как-нибудь так, если вы хотите, а не разработчик. Что это означает на теории,
[31:03.940 --> 31:09.460]  к чему мы вообще придем? То есть если на практике мы используем именно это, то что будет дальше?
[31:09.460 --> 31:21.900]  Что у нас будет вместо программы? Как вы думаете? Алгоритм. Хорошо. Что у нас будет вместо языка
[31:21.900 --> 31:33.460]  программирования? Смотрите, мы будем писать действительности на псевдокоде. Псевдокод это
[31:33.460 --> 31:40.300]  какая-то помесь питона с плюсами. Будем считать это таким вот образом. Если кому-то очень в кайф
[31:40.300 --> 31:47.420]  школьно-алгоритмический, вот этот вот, восхитительный на русском языке, я откажусь от этого, но вы там
[31:47.420 --> 31:56.180]  можете сами попробовать. Я, пожалуй, не буду. А что вместо компьютера? Как вы думаете? А? Бумага?
[31:56.180 --> 32:20.780]  Нет, нет. Вот что я могу представить тебе? А? Я, конечно, хорошо, но нет, не машина. На самом деле,
[32:20.780 --> 32:28.460]  некоторая модель вычислений. Модель вычислений того, что у нас произойдет. То есть вместо компьютера
[32:28.460 --> 32:34.620]  мы будем представлять некоторую абстракцию сами по себе. Мы не будем использовать чего-то конкретного.
[32:34.620 --> 32:44.060]  И у нашей модели вычисления, что она вообще должна позволять, что она определяет? То есть что
[32:44.060 --> 32:52.580]  определяет вот та или иная модель вычисления? Она определяет допустимые операции и сложность
[32:52.580 --> 32:58.740]  каждой из этих операций. То есть любая модель это делает. В нашем курсе мы будем использовать
[32:58.740 --> 33:17.700]  RAM-модель. Random Access Memory. А? Ладно. Хорошо. RAM-модель это модель, сейчас мы ее посмотрим тут
[33:17.700 --> 33:24.900]  на картиночке. Ее можно представить вот так. У нас есть некоторые такой вот, грубо говоря,
[33:24.900 --> 33:32.180]  регистры. Вот их от нуля доим минус один. У нас есть программа, которая общается с нашим процессором.
[33:32.180 --> 33:38.380]  У него там есть регистры, они как-то внутри там ходят. Вот это все происходит там. Почему она называется
[33:38.380 --> 33:46.060]  Random Access Memory? Потому что мы в любое место можем взять и заглянуть и вот туда записать. Мы не влияем
[33:46.060 --> 33:52.260]  на то, как компьютер выбирает то или иное пространство, грубо говоря. То есть мы здесь просто берем и
[33:52.260 --> 34:00.140]  используем, что типа окей, запишем туда. Потом окей, запишем туда. И мы ничего не будем с ним делать.
[34:00.140 --> 34:09.140]  То есть как он хочет, так он и делает. Давайте я задам, у нас все равно времени много. Задам вам
[34:09.140 --> 34:19.700]  интересный вопрос. Много из вас знают о том, что такое битная система. Сколько бит на вашей
[34:19.700 --> 34:32.660]  системе? Вот у вас винда там 32 бит, 64 бит. Да? Нет? Да? Нет? Да? Ну интересно, что вы этим никогда
[34:32.660 --> 34:39.820]  не интересовали. Смотрите, существуют некоторые системы, ну точнее все, они имеют какую-то
[34:39.820 --> 34:46.700]  разрядность. И вот эта разрядность означает, вот видите W там написано. Это как раз таки машинное
[34:46.700 --> 34:52.940]  слово, с которым идет. То есть какое есть у нас машинное слово. Все равно у нас сегодня такая более
[34:52.940 --> 35:02.020]  развлекательная, надеюсь, лекция. А это машинное слово сколько-то имеет размер. Вообще среди
[35:02.020 --> 35:10.900]  регистров там есть от нуля до M-1. И вот есть такая вещь, что я могу сказать, что если у меня 32-битная
[35:10.900 --> 35:22.980]  система, а у вас почти наверное 64-битная система, то количество оперативной памяти в ней не более
[35:22.980 --> 35:40.660]  4 гигабайт. Как вы думаете, почему это связано? 2 в 32, правильно. Да. А почему это правда? Почему
[35:40.660 --> 36:00.060]  2 в 32? Что происходит? Размер адреса. Вопрос в размере адреса. То есть размер адреса не более 32
[36:00.060 --> 36:04.660]  битов. Но мы не можем больше, чем машинное слово, иметь размер адреса. Иначе как он будет обращаться?
[36:04.660 --> 36:11.540]  То есть вот эти вот вещи будут друг другу как-то сообщаться. Нам необходимо это сделать. Как это
[36:11.540 --> 36:18.780]  сделать? Ну, посредством адресов. Адрес не может иметь значение больше, чем 2 в 32. Потому что у меня
[36:18.780 --> 36:25.780]  слово машинное, оно имеет 32 бита. Там везде 0 или 1, 0 или 1. Количество вариантов 2 в 32. Надеюсь,
[36:25.780 --> 36:38.020]  вы это считать умеете. Это означает, что столько у нас есть памяти. Поэтому сейчас у нас 64-битная
[36:38.020 --> 36:48.460]  система. Там уже 2 в 64. Я думаю, оперативной памяти на всех хватит. Машинное слово это сколько
[36:48.460 --> 36:53.780]  ячейку у нас есть. То есть процессор, там есть некоторые регистры. Вот они расположены по
[36:53.780 --> 36:59.980]  машинному слову, грубо говоря. Вот максимум хранят. Вот. Имеют какие-то, ну, регистры имеют
[36:59.980 --> 37:12.140]  какие-то адреса. И вот максимум, что там можно придумать этим всем, это 2 в 32. Больше нельзя. Да.
[37:12.140 --> 37:30.620]  Да, да. Кроме того, вы столкнетесь с выравнивыми в плюсах однажды, когда будете со структурками
[37:30.620 --> 37:37.500]  общаться. Но мы будем считать на алгоритмах, что мы получаем информацию за это от единицы. Вот. И это
[37:37.500 --> 37:45.100]  сейчас я скажу. Что мы считаем в рамках этой модели? Мы считаем в рамках этой модели, что любые
[37:45.100 --> 37:54.340]  простейшие арифитические операции, плюс, умножить, делить, взять и остатка, это, ну и минус, это,
[37:54.340 --> 38:02.780]  стоит это от единицы времени. Что такое это от единицы? Ну какую-то константу. Ну по факту одно
[38:02.780 --> 38:11.820]  какое-то действие мы считаем, что это одна единичка времени. Вот. Кроме того, записать и считать одно
[38:11.820 --> 38:19.180]  конкретное число тоже будет стоить это от единицы в этой, в условиях этой модели. Я больше к этому не
[38:19.180 --> 38:26.900]  вернусь. Сейчас такая просто вот лекция обо всем, что нас ожидает, но оно выглядит вот именно таким.
[38:26.900 --> 38:43.740]  Понятно, что происходит в этой модели? Да. Не всегда. И что такое большое число?
[38:43.740 --> 38:55.580]  Десять шестой небольшой число. У тебя очень сильные вычислительные мощности. Знаете,
[38:55.580 --> 39:04.580]  типа, как это, как это назвать? У тебя сейчас телефон лучше считает и лучше все делает,
[39:04.580 --> 39:10.580]  чем то, что отправил человек на Луну. Но ты не воспринимаешь это и думаешь, что типа это все
[39:10.580 --> 39:15.540]  равно не очень. Но с помощью этого люди отправили человека на Луну. Просто вот огромная стопка с
[39:15.540 --> 39:22.700]  перфокарт и вычислительной машинкой. А дальше они там всю миссию построили Аполлон. Вот. Можно
[39:22.700 --> 39:33.740]  такое? Ну можно. Поэтому здесь как бы нельзя говорить большое. Скорее так. Число. Вот. Но
[39:33.740 --> 39:38.980]  для интов мы будем считать, что это быстро, все равно все работает. Они считаются вычисления здесь
[39:38.980 --> 40:03.700]  достаточно быстро. Так вот. Да. Это одинаковое по стоимости операции. Да. Ну здесь это будет
[40:03.700 --> 40:09.940]  одинаково. Как бы с точки зрения программы, когда вы ее закинете на контест, ну там разница может
[40:09.940 --> 40:15.860]  быть в милли-милли-милли секунды. Типа очень маленькая. Это не тот случай, когда это будет
[40:15.860 --> 40:22.420]  действительно много-много стоить. Вот. Много-много стоит. На самом деле арифметические операции
[40:22.420 --> 40:30.220]  гораздо больше стоят, чем бинарные операции. Ой, бинарные, господи, побитые операции. Сдвиги,
[40:30.380 --> 40:36.860]  вот такого характера. Это очень быстрая операция, потому что они работают напрямую с битами. Да.
[40:47.860 --> 40:57.340]  Нет. Давайте еще раз. Тетто. Это множество функций. Вот в данном случае это от единички. Что
[40:57.340 --> 41:08.340]  подразумевается? Тетто от единицы. Ну по факту это то же самое, что тетто от n в степени 0. Мы
[41:08.340 --> 41:15.580]  говорим, что это множество функций. Я сейчас кратко напишу. Это множество функций от n. Таких,
[41:15.580 --> 41:26.740]  что там существует для любого и так далее. Что c на n, c1 на n0 меньше, чем f от n, меньше,
[41:26.740 --> 41:35.100]  чем c2 на n0. То есть какое-то константное количество времени. Вот это тетто от единички. Еще раз.
[41:35.100 --> 41:44.300]  Тетто показывает множество функций f, а не вот этих. То есть они по отношению к этому числу ищут
[41:44.300 --> 42:01.740]  множество функций. Вот я только что тебе написал. N в степени 0 чему равно? Единица. Ну если это не
[42:01.740 --> 42:09.620]  0 в степени 0, хорошо, но типа мы не считаем таких случаев. Вот это единица. Я говорю, что моя функция f,
[42:09.620 --> 42:19.500]  по факту, что это означает? Если у меня есть какая-то функция f, то она, вот у меня 1 это c2,
[42:19.500 --> 42:27.140]  вот это c1. Я говорю, что моя функция, которая вот там вот f от n, она вот где-то вот тут вот колебается.
[42:27.140 --> 42:39.580]  Понятно? Так стало понятнее? Тетто от единицы это множество функций. Безусловно.
[42:39.780 --> 42:47.340]  Это множество функций, для которых вот выполнено вот это. Кроме того, существует вот единица. Это тоже
[42:47.340 --> 42:54.100]  самое, только сверху ограничение. То есть оно не выйдет выше какой-то константа. Вот. Да.
[42:54.100 --> 43:05.180]  Еще раз. Это работает, потому что мы работаем.
[43:05.180 --> 43:20.420]  Ну нет, смотрите, мы можем взять любые числа, любые числа, которые работают в нашей типа машинном
[43:20.420 --> 43:26.780]  слове, типа которых хватает. Вот мы возьмем этих, возьмем. И дальше типа тетто от единицы будет
[43:26.780 --> 43:35.060]  показывать, что мы за какое-то константное время их сложим, поделим, умножим. Все. То есть это не
[43:35.060 --> 43:41.060]  такое, что мы точно берем 5 и 7, вот для них оно работает за тетто от единицы, а для 3 и 11 может не так.
[43:41.060 --> 43:51.580]  Да, конечно. Да. Но я более того скажу, если я возьму три числа и сложу их, то первое сложение будет
[43:51.580 --> 43:57.500]  тетто от единицы, второе сложение тетто от единицы. Если я складываю 2 тетто от единицы, я получу тетто от единицы.
[43:57.500 --> 44:03.140]  Просто с более широкими рамками. Но мне не интересуют рамки, меня интересуют и симпатически. Поэтому
[44:03.140 --> 44:10.100]  это тоже самое будет. Вот если я Н раз повторяю, то это уже тетто от Н. Потому что от Н зависит.
[44:10.100 --> 44:23.740]  Еще вопросы есть? Нет. Ну хорошо, тогда это последний слайд, который я для вас сегодня подготовил. Это
[44:23.740 --> 44:29.300]  времена и сложности алгоритма. То, с чем мы будем говорить больше всего. Пусть у нас есть множество
[44:29.300 --> 44:39.020]  входов. Что такое множество входов? Ну вот я могу взять числа от 1 до 10 в 9. Вот это множество входов,
[44:39.020 --> 44:46.180]  к примеру, когда подается одно число. Может быть такое? Может быть. И как-то на нем алгоритм работает.
[44:46.180 --> 44:52.860]  Пусть у меня есть какой-то конкретный input. Вот здесь неправильно немножко написано, здесь не
[44:52.860 --> 45:01.500]  тинпут принадлежит и от Н, а input принадлежит и от Н. У меня есть множество и от Н. Что такое
[45:01.500 --> 45:08.820]  тинпут? Тинпут это количество действий, сколько я сделал. Поэтому оно не лежит во... Вы на меня
[45:08.820 --> 45:17.460]  смотрите, мне страшно, что вы меня не понимаете. Давайте еще раз. Я чуть-чуть перепишу, потому что
[45:17.780 --> 45:31.460]  я ошибся, видимо. Вот у меня есть множество входов. Это сколько я могу вообще делать всего? У меня есть
[45:31.460 --> 45:41.900]  некоторый input, который из этого множество входов. Ну не знаю, я выбрал число 5. Это input. У меня на input
[45:42.260 --> 45:49.900]  ну в одной задаче может подаваться что? Число от 1 до 10, 9 одно число. Могу я так делать? Могу. Вот в
[45:49.900 --> 45:58.860]  этом случае какой-нибудь input, ну 5, 7, 10, 11. Это просто элементы этого множества. А t от input
[45:58.860 --> 46:13.580]  это что? t от input это на самом деле будет время работы, количество действий нашего алгоритма. Да.
[46:13.580 --> 46:24.940]  Множество входов. Давайте еще раз. В задаче сказано, принимается на вход одно число. От 0 до 10 в
[46:24.940 --> 46:33.660]  9. Множество входов. Все числа от 0 до 10, 9. Вот. Если два числа от 0 до 10, 9, то это пересечение
[46:33.660 --> 46:42.260]  Декартовым. Ой, пересечение, господи, умножение. Вот. И что мы тогда можем выделить в этом случае?
[46:42.260 --> 46:51.100]  В этом случае мы можем сказать, что лучшее время это просто минимум по всем input. Да.
[46:51.100 --> 47:12.660]  Еще раз. Если n чисел и 10 в 9, ну да. Ну 10, 9 от 0 до 10, 9 в n, ну типа это умножение просто множество.
[47:12.660 --> 47:22.820]  Вот. Это не 10, 9 в 9n. Нет. Число так и останется 10, 9. Вот. А в лучшем случае, но это минимум по
[47:22.820 --> 47:26.980]  всем input'ам. То есть мы берем по всем input'ам, проходимся и говорим, что вот тут меньше всего
[47:26.980 --> 47:33.180]  количества действий. Может быть такое? Может. Вот. Что такое в худшем случае? В худшем случае это
[47:33.180 --> 47:39.340]  максимум. Вот. Когда я спросил, за сколько на их худшем случае работает быстрая сортировка,
[47:39.340 --> 47:48.780]  она работает за n квадрат. У нее есть такой худший вариант, когда все плохо. Мы его разберем. А? А там
[47:48.780 --> 48:00.100]  невозможно за ноль. Подумай почему. В лучшем с некоторыми добавлениями за o от n, так за n log n.
[48:00.100 --> 48:11.700]  Это в худшем случае. А что происходит в среднем? Вот смотрите, у меня здесь стоит значок суммы,
[48:11.700 --> 48:20.540]  потом p, а потом t. Что такое p? Вероятность. То есть смотрите, насколько вероятен тот или
[48:20.540 --> 48:30.420]  иной вход. Правильно. Это правда. Вот. Но я не буду таких слов говорить. Ничего не знаю. Это вероятность
[48:30.420 --> 48:38.100]  какого-то входа на время этого входа. Пока что мы будем определять среднее время как-то так. Что
[48:38.100 --> 48:44.260]  под этим подразумевается? Почему вероятность умножается на вход, на время этого входа и так
[48:44.260 --> 48:53.620]  далее. Бывает такое, что, к примеру, в задачах на графах вам скажут, у вас будет граф почти плотный.
[48:53.620 --> 49:02.420]  Почти плотный означает, что количество ребер примерно n квадрат в этом графе. Ну, асимпатически.
[49:02.420 --> 49:12.220]  А отсюда разреженный граф. Это где у нас n ребер в графе. То есть разреженный. Мало ребер.
[49:12.220 --> 49:24.140]  Sorry. То есть разреженный. Это еще раз. Мало ребер. Плотно. Это много ребер. Может быть такое может.
[49:24.140 --> 49:31.180]  И тогда в этом случае у вас по факту распределение вот этих input оно смещено. Оно смещено в одну
[49:31.180 --> 49:41.060]  или другую сторону. Или вам сказано, что вам даны все числа от 0 до 10 девятый на вход, но число,
[49:41.060 --> 49:48.220]  не знаю там типа, число выпадает чаще с вероятностью количества цифр в нем. Оно более вероятно,
[49:48.220 --> 49:53.780]  если в нем меньше цифр. Может быть такая задача. Ну, может. Это странная задача, но может быть. И здесь
[49:53.780 --> 49:58.180]  вопрос в input. Чаще всего мы будем говорить, что у нас все равновероятно. То есть нам
[49:58.180 --> 50:06.580]  равновероятно выдали типа массив из 10 чисел, к примеру. И эти числа, они между собой могли бы стоять
[50:06.580 --> 50:13.140]  равновероятно в разных сторонах. Вот. Мы будем рассматривать именно равную вероятность. Чаще всего.
[50:13.140 --> 50:23.260]  Потому что у нас в ход мы не будем какой-то такой особенный делать. Но знать такое надо. Окей. Вопрос.
[50:28.180 --> 50:42.540]  N это количество вершин. Sorry, если не сказал, да. Вот. Таким образом это происходит. А теперь давайте
[50:42.540 --> 50:50.020]  с вами поговорим о самом главном. В чем практическое применение всего, что тут увидели? Для чего это надо?
[50:50.020 --> 50:58.020]  Так как вы чаще всего будете с О большим встречаться, мы поговорим больше про О большое. И что вообще с
[50:58.020 --> 51:10.020]  ним происходит. Сейчас. Смотрите. Представим, что вам сказано. Вот вы сидите на контесте, вам говорят
[51:10.020 --> 51:17.420]  в таком титоге, вы волнуетесь, не понимаете, что происходит, куда что писать. У вас стресс, первая сессия
[51:17.420 --> 51:28.180]  и все. Ну вот вам написано задача. Ограничение 1 секунда. Какой-то конкретный задач. И вы смотрите,
[51:28.180 --> 51:41.500]  что, не знаю, N, от которого зависит весь алгоритм здесь, он может быть от нуля до там 10 в 9. К примеру.
[51:41.500 --> 51:56.980]  Хорошо. Что же делать? Что же делать? Как же быть? Что мне вообще нужно сделать? Предположим,
[51:56.980 --> 52:04.300]  что это сортировка. Это количество элементов в нашем массиве. Вы знаете, ну блин, напишу пузырек.
[52:04.300 --> 52:14.620]  Пузырек топ. Мне надо. Пузырек работает за O от N квадрат. Количество элементов в массиве. Пока я
[52:14.620 --> 52:20.060]  просто говорю рандомные фразы, просто примите, что существует какой-то алгоритм сортировки за N
[52:20.060 --> 52:27.220]  квадрат. Может быть всем известный пузырек. А существует другая сортировка. Например,
[52:27.220 --> 52:39.180]  что мы только QuickSort мучаем? MergeSort. И MergeSort работает всегда за O от N логи. А теперь давайте
[52:39.180 --> 52:46.580]  смотреть. У нас всего одна секунда. Надо нужно прикинуть количество действий. Мы знаем,
[52:46.580 --> 52:53.420]  что там константы плюс-минус небольшие, поэтому можно на них подзабить. Ну так, относительно,
[52:53.420 --> 52:58.860]  если будет где-то большая константа, я вам обязательно скажу, но такого пока нет. А вот
[52:58.860 --> 53:08.620]  здесь вот N квадрат. Что это? Это 10 в 12 действий. Много или мало? Как вы думаете, для плюсов?
[53:08.620 --> 53:21.700]  Много. Плюсы примерно 10 восьмое действие могут выполнить за одну секунду. 10 восьмое,
[53:21.940 --> 53:27.980]  где-то 10 в 9 в лучших случаях. Ну так, плюс-минус. Но ориентироваться лучше на 10 восьмое,
[53:27.980 --> 53:34.740]  потому что у вас константа, можете сыграть еще что-то. А здесь 10 в 12. Кто мне скажет,
[53:34.740 --> 53:43.900]  как дольше, чем одна секунда это будет работать? Это работает 10 в четвертый секунд,
[53:43.900 --> 53:52.740]  что кажется не очень адекватным. Если кто-то хочет, может взять калькулятор, посмотреть,
[53:52.740 --> 54:04.540]  сколько это времени. Не очень приятно, я сразу скажу. Ну, три часика, я бы сказал.
[54:04.540 --> 54:16.700]  Вот. То есть, как бы весь контест потратим на вашу сортировку, чтобы она сделать. Или мы можем
[54:16.700 --> 54:24.220]  рассмотреть другой алгоритм, который работает за N log N. Что в этом случае? Это 10 в 6 на логарифм,
[54:24.220 --> 54:33.500]  но даже двоечный возьмем 10 в 6. Что нам дает эта шестерка? Эта шестерка, вы с логарифмами знакомы,
[54:33.500 --> 54:40.900]  я надеюсь? Да, отлично. Мало ли, все бывает. Это означает следующее, что эта шестерка я могу
[54:40.900 --> 54:49.260]  вынести сюда, а 2 на логарифм 10 по основанию 2, но это не больше 4, потому что 10 меньше 16. Вот.
[54:49.260 --> 54:58.740]  Поэтому я скажу, что это 6 умножить на 4 умножить на 10 в 6. То есть, это будет 2 и 4 на 10 в седьмой
[54:58.740 --> 55:10.980]  действии. И этого мне хватает на одну секунду. То есть, здесь количество действий чудесное. Оно
[55:10.980 --> 55:19.780]  мне дает все, что мне необходимо. И тогда, после того, как вы в голове это быстро сделали, вот это
[55:19.780 --> 55:27.460]  вы должны уметь в голове прокручивать. А тогда в этом случае вы сделаете итоговый контест. Если
[55:27.460 --> 55:39.020]  вы не умеете прокручивать, вы не сделаете. Да. Ну смотри, с точки зрения константы нам не сильно
[55:39.020 --> 55:48.740]  важно, но на самом деле в мерсорте будет основание 2. Ну даже если я возьму здесь 3,
[55:48.740 --> 55:56.100]  ну что сильно, что-то изменится. Ну нет, у нас максимум вот эта константа будет меняться,
[55:56.100 --> 56:04.580]  и то она будет уменьшаться, если взять другое основание. Вот. Ну все. Понятно вам, как вот это
[56:04.580 --> 56:14.580]  вот происходит? Я надеюсь, что вы будете аккуратно использовать те или иные алгоритмы, иначе это будет
[56:14.580 --> 56:23.180]  очень сложно и грустно. Вот. А чего еще вам такого рассказать вообще про алгоритмы? Смотрите,
[56:23.300 --> 56:29.940]  с точки зрения анализа у нас будет еще так называемый амортизационный анализ. Это будет
[56:29.940 --> 56:35.980]  позже, это будет интереснее. Там мы будем в среднем случае что-то искать. Пока до среднего случая
[56:35.980 --> 56:45.020]  мы будем с вами смотреть, наверное, в только в квиксорте когда-то, в быстрой сортировке,
[56:45.020 --> 56:50.900]  как только дойдем. А как у нас вообще будут построены все лекции? Во-первых, я призываю вас
[56:50.900 --> 56:55.740]  приходить очень. Мне очень нравится, когда вы здесь, но если вам очень не нравится, что я могу сделать?
[56:55.740 --> 57:01.820]  Вот. Если что, можете всегда давать какую-нибудь обратную связь, могу вам что-нибудь порассказывать.
[57:01.820 --> 57:07.700]  Я не обижаюсь, я человек спокойный к критике, просто можете рассказывать, что вам нравится,
[57:07.700 --> 57:17.380]  что вам не нравится. Вот. Это раз. Во-вторых, нас ожидает на следующем, мы будем говорить с
[57:17.380 --> 57:24.900]  вами про рекурренты и немножко про бинарный поиск по ответу. Потом мы начинаем уже сортировки.
[57:24.900 --> 57:40.500]  И у нас будет много лекций про сортировки, целых четыре. Как вы думаете, какие? Так. Ну, смотрите,
[57:40.500 --> 57:49.380]  у нас будет на самом деле квадратичные сортировки, их три штучки. У нас будет три штучки
[57:49.380 --> 57:54.340]  логарифмические. Каждую логарифмическую я буду рассматривать отдельно, которая за НЛоган работает.
[57:54.340 --> 58:02.900]  Это быстро, это мерч, это хип-сорт. Вот. А после этого мы будем переходить к интересным темам,
[58:02.900 --> 58:07.220]  уже прям вот интересным-интересным. И в какой-то момент под конец у вас будет,
[58:07.220 --> 58:14.220]  ой, мне так нравится, это называется сплей дерево, но я не знаю, всем оно не нравится больше в какой-то
[58:14.220 --> 58:22.940]  момент. Так что можете спросить у кого-то постарше, кто слушал про сплей дерево, поняли они его или нет.
[58:22.940 --> 58:29.500]  Но это как пример. На самом деле весь курс алгоритмов в этом семестре он не затронет какие-то
[58:29.500 --> 58:38.460]  вещи, связанные с графами. Они будут позже, потому что вы будете писать структуру данных позже. Пока что
[58:38.460 --> 58:45.980]  весь курс алгоритмов будет завязан на чем-то, связанном с массивами и как-то с этим работать. Вот.
[58:45.980 --> 58:48.860]  Есть ли у вас какие-то вопросы?
[59:00.860 --> 59:09.340]  Для алгоритма размеры N. Под N подразумевается вход, тот самый вход N. Ну, то есть, к примеру,
[59:09.340 --> 59:14.060]  это может быть число, когда вы проверяете его на простоту, там зависит от самого числа,
[59:14.060 --> 59:19.420]  сколько оно весит, а может быть количество массивов. Подразумевается здесь вот это N,
[59:19.420 --> 59:24.260]  которое неопонятно. Я не могу сказать, что это обязательно массив, я не могу сказать обязательно,
[59:24.260 --> 59:43.820]  что это число. Вот. Нет, конечно. Только, а здесь у меня будет вопрос к вам, когда мы это
[59:43.820 --> 59:51.900]  пройдем. Почему некоторые алгоритмы сортировки, которые работают за квадрат, работают лучше в
[59:51.900 --> 01:00:09.540]  некоторых условиях, чем алгоритмы за N. Мы не учим просто так. Еще раз. Нет, нет, нет, не только. Я
[01:00:09.540 --> 01:00:18.580]  более того скажу, спасибо, чуть-чуть фальстат. Я более того скажу, что вот есть внутренние STD-сорт
[01:00:18.580 --> 01:00:23.180]  и так далее, которые вы будете использовать уже в следующих семестрах. Ну, это внутренние алгоритмы
[01:00:23.180 --> 01:00:32.340]  уже написаны. И там до 100 элементов будет считаться пузырек, а все, что свыше 100, уже будет считаться с
[01:00:32.340 --> 01:00:41.100]  помощью N log N, быстрой сортировки. Подумайте почему. Ладно, все, не буду вас задерживать. Пока-пока.
