[00:00.000 --> 00:13.920]  Всем здрасьте.
[00:13.920 --> 00:18.120]  Нам сначала нужно доделать суффиксный автомат алгоритм.
[00:18.120 --> 00:21.280]  Давайте напомню, что мы делали.
[00:21.280 --> 00:24.680]  Мы говорим, что мы будем строить автомат дописыванием
[00:24.680 --> 00:27.200]  по одному символу и вот считаем, что для строки
[00:27.200 --> 00:28.680]  С автомат уже построен.
[00:28.680 --> 00:30.680]  Мы дописываем новый символ С, следующую буквовку
[00:30.680 --> 00:31.680]  к нашей строке.
[00:31.680 --> 00:36.000]  Хотим перестроить автомат.
[00:36.000 --> 00:38.720]  Мы поняли, что обязательно появляется новый класс,
[00:38.720 --> 00:42.560]  который отвечает всей строке СС.
[00:42.560 --> 00:43.560]  Обязательно будет такой новый класс.
[00:43.560 --> 00:45.840]  И еще потенциальный какой-то один класс возникает.
[00:45.840 --> 00:49.120]  Давайте напомним, что у нас есть строка С0.
[00:49.120 --> 00:58.360]  Это максимальный суффикс С, который является по
[00:58.360 --> 00:59.360]  строкой С.
[00:59.360 --> 01:11.560]  Так же у нас было, да?
[01:11.560 --> 01:14.440]  Мы понимаем, что вот это СС будет обязательно новый
[01:14.440 --> 01:16.400]  класс, обязательно новая вершинка, которая возникает
[01:16.400 --> 01:17.400]  в нашем автомате.
[01:17.480 --> 01:18.480]  Без нее никак не обойтись.
[01:18.480 --> 01:22.960]  А вот эта С0, она, возможно, образует нам новый класс,
[01:22.960 --> 01:23.960]  возможно, не образует.
[01:23.960 --> 01:26.800]  Зависит от того, являлась ли вот эта строчка в старом
[01:26.800 --> 01:29.080]  автомате лонгистом в своем классе.
[01:29.080 --> 01:31.200]  Если она была лонгист, то ничего не меняется, это
[01:31.200 --> 01:32.720]  состояние остается неизменным.
[01:32.720 --> 01:36.200]  Если же она не была лонгистом, но стала лонгистом, тогда
[01:36.200 --> 01:37.920]  вот это старое состояние расщепляется на два.
[01:37.920 --> 01:41.760]  Вот если у меня было несколько строк в одном состоянии,
[01:41.760 --> 01:44.680]  то несколько самых длинных остаются там же, а вот эти
[01:44.680 --> 01:49.000]  остальные, среди которых самый длинный это С0, они
[01:49.000 --> 01:51.680]  отщепляются в отдельное состояние, соответственно,
[01:51.680 --> 01:55.480]  число состояния увеличивается на два, а не на один.
[01:55.480 --> 02:00.120]  Хорошо, значит, это мы уже делали в прошлый раз.
[02:00.120 --> 02:02.440]  Также я напомню такой полезный факт, что если у меня есть
[02:02.440 --> 02:07.120]  какая-то вершинка В, то множество ребер, которые ведут в нее,
[02:07.120 --> 02:08.120]  устроено следующим образом.
[02:08.120 --> 02:12.360]  Что, во-первых, на них на всех написана одна и та
[02:12.360 --> 02:13.360]  же буква.
[02:13.360 --> 02:17.200]  Давайте не С, давайте какой-нибудь D.
[02:17.200 --> 02:19.680]  На них на всех написана одна и та же буква, во-первых.
[02:19.680 --> 02:22.600]  Во-вторых, вот эти вот вершинки – это часть суффиксного
[02:22.600 --> 02:23.600]  пути.
[02:23.600 --> 02:25.640]  То есть если посмотреть на самую длину из них, то
[02:25.640 --> 02:28.320]  суффислка из нее будет вести во вторую по длине, из нее
[02:28.320 --> 02:30.360]  суффислка ведет в третью по длине, из нее в четвертую
[02:30.360 --> 02:31.360]  и так далее.
[02:31.360 --> 02:33.960]  И это вот все все ребра, ведущие в данную вершинку.
[02:33.960 --> 02:36.160]  Этим мы тоже будем пользоваться.
[02:36.160 --> 02:41.000]  Хорошо, значит, мы многое уже поняли, и теперь давайте
[02:41.000 --> 02:45.040]  поймем, как будут меняться ребра при добавлении вот
[02:45.040 --> 02:46.120]  этого нового символа С.
[02:46.120 --> 02:48.280]  Мы понимаем, как меняется состояние, либо плюс один,
[02:48.280 --> 02:49.280]  либо плюс два.
[02:49.280 --> 02:50.280]  Теперь вопрос, как меняются ребра.
[02:50.280 --> 03:00.600]  Ну, я утверждаю следующее, что после добавления С, большинство
[03:00.600 --> 03:01.840]  ребер как бы не изменятся.
[03:01.840 --> 03:15.000]  Большинство ребер в старом автомате сохранятся.
[03:15.000 --> 03:20.560]  Ну, понятно, если у меня меняются только два состояния,
[03:20.560 --> 03:22.440]  то, наверное, просят какие-то изменения только с ними.
[03:22.440 --> 03:25.200]  Так вот, что может измениться?
[03:26.200 --> 03:35.120]  Во-первых, понятное дело, должны появиться какие-то
[03:35.120 --> 03:38.840]  ребра, ведущие в новое состояние С.
[03:38.840 --> 03:42.360]  Ребра в класс, отвечающие С.
[03:42.360 --> 03:45.160]  Ну, это понятно, появилась новая вершинка, туда явно
[03:45.160 --> 03:46.480]  должны вести какие-то ребра.
[03:46.480 --> 03:47.480]  С одной стороны.
[03:47.480 --> 03:50.040]  С другой стороны, из этого состояния ребра точно не
[03:50.040 --> 03:53.320]  будет, потому что там уже лежит самая длинная строка,
[03:53.320 --> 03:55.640]  если бы было еще какое-то исходящее ребро из нее,
[03:55.640 --> 03:57.440]  это бы означало, что автомат должен применить какую-то
[03:57.440 --> 03:59.600]  еще более длинную строчку, чем все С.
[03:59.600 --> 04:01.880]  Понятно, что такого не бывает, значит, ребер отсюда
[04:01.880 --> 04:02.880]  точно не исходит.
[04:02.880 --> 04:08.080]  Дальше, что может появиться или измениться?
[04:08.080 --> 04:12.720]  Дальше вот эти вот события могут происходить только
[04:12.720 --> 04:15.640]  в случае, если С0 это новый лонгест, то есть не был
[04:15.640 --> 04:16.640]  лонгестом, но стал лонгестом.
[04:16.640 --> 04:18.680]  То есть это в случае, когда у меня какое-то состояние
[04:18.680 --> 04:19.680]  расщепляется.
[04:19.680 --> 04:22.680]  Расщепление.
[04:22.680 --> 04:24.120]  Когда, значит, что может быть?
[04:24.120 --> 04:27.400]  Вот было какое-то состояние Q, оно распалось на два.
[04:27.400 --> 04:29.320]  Там какое-то новое Q и клон.
[04:29.320 --> 04:32.840]  Значит, вот как-то оно расщепилось на два.
[04:32.840 --> 04:34.160]  Тогда как меняться ребра?
[04:34.160 --> 04:36.760]  Ну, во-первых, могут поменяться ребра те, которые входили
[04:36.760 --> 04:39.880]  вот в это, могут теперь перейти в, ну, то есть в одно
[04:39.880 --> 04:40.880]  из них, надо понять, куда.
[04:40.880 --> 04:41.880]  Ребра.
[04:41.880 --> 04:45.240]  Давайте я сразу назову вот эту вот вершинку Q, та
[04:45.240 --> 04:48.320]  вершина, в которой лежала изначальная С0, которая
[04:48.320 --> 04:51.440]  расщепляется в этом случае, давайте назовем ее Q.
[04:51.440 --> 04:54.960]  Так вот, что-то происходит с ребрами в Q.
[04:54.960 --> 04:57.200]  Ребра в Q.
[04:57.200 --> 05:01.840]  Надо с ними понять, куда они теперь ведут?
[05:01.840 --> 05:05.320]  Куда теперь ведут?
[05:05.320 --> 05:07.040]  Раз это состояние расщепилось, там было какое-то множество
[05:07.040 --> 05:09.600]  слов, оно расщепилось, понятно, что тогда ребра, какие-то
[05:09.600 --> 05:13.080]  входящие сюда, должны переместиться сюда, а какие-то входящие
[05:13.080 --> 05:15.160]  тоже сюда должны переместиться в другую вершинку, поскольку
[05:15.160 --> 05:18.400]  здесь расщепилось множество слов, то и множество ребер
[05:18.400 --> 05:24.000]  тоже должно расщепиться. Вот, это входящие ребра в эту вершинку, ну и еще могут быть
[05:24.000 --> 05:27.200]  какие-то исходящие. То есть надо понять, как ведут себя исходящие ребра из этих двух
[05:27.200 --> 05:37.680]  новых версий старой Q. Рёбра из Q тоже. Ну скорее откуда теперь?
[05:37.680 --> 05:44.240]  Откуда теперь? Потому что у меня была старая вершинка, из нее что-то исходило,
[05:44.240 --> 05:47.440]  а теперь старая вершинка расщепилась на две. Ну тоже надо понять, какие ребра
[05:47.440 --> 05:53.640]  теперь исходят из этих двух, из этих новых версий старой вершины. Вот, и больше
[05:53.640 --> 05:57.920]  ничего не изменится в нашем графе, больше никакие ребра не исчезнут, не
[05:57.920 --> 06:01.840]  появятся и не изменятся, потому что какие у нас остаются не учтенными ребра?
[06:01.840 --> 06:05.680]  Ну, только те, которые вели между вершинками, между состояниями, которые
[06:05.680 --> 06:09.680]  не поменялись. Только между состояниями, которые не поменялись, потому что
[06:09.680 --> 06:14.920]  поменялось только вот эта вот SC появилась и Q могла расщепиться. Больше у нас в
[06:14.920 --> 06:18.280]  в автомате с точки зрения состояния и множеств слов, которые лежат в одном
[06:18.280 --> 06:22.440]  состоянии, ничего не поменялось. То есть, если я возьму любую другую вершинку, в
[06:22.440 --> 06:27.280]  которой было какое-то множество слов, то есть правый контекст, у которых одинаковый,
[06:27.280 --> 06:30.520]  и вот все они соответствуют одной вершинке, то это состояние не поменялось.
[06:30.520 --> 06:34.000]  Ну, потому что мы поняли, что меняются только два лонгеса, значит, два
[06:34.000 --> 06:38.360]  состояния. Поэтому здесь ничего не меняется, и значит, никакие входящие рёбра,
[06:38.360 --> 06:42.760]  никакие исходящие рёбра, ведущие ни в Q, ни в SC, они поменяться не могли, поэтому
[06:43.000 --> 06:47.160]  большая часть графа у нас остается. В итоге может меняться только вот эти вот
[06:47.160 --> 06:54.640]  три потенциальные пункта. Хорошо, давайте тогда разбираться с первым. Какие рёбра
[06:54.640 --> 07:13.480]  нужно провести в SC? Ну, понятно, что поскольку мы должны провести рёбра в SC, то все
[07:13.480 --> 07:16.840]  рёбра, которые туда ведут, обязательно на них написана одна и та же буква, это мы уже
[07:16.840 --> 07:21.000]  замечали. И ну какая это буква? Понятно, что это последняя буква во всех этих словах,
[07:21.000 --> 07:25.840]  то есть C. Поэтому в этой SC нужно обязательно провести несколько вот таких рёбер, на всех из
[07:25.840 --> 07:31.280]  которых написан букв КC, и они ещё образуют такой суффиксный путь. Ну, давайте тогда скажем,
[07:31.280 --> 07:37.240]  что я должен провести ребро из, скажем, строки, чего у нас ещё не было, давайте из строки U,
[07:37.240 --> 07:44.120]  из строки U я должен провести, точнее вот так, да, из класса, соответственно,
[07:44.600 --> 07:59.440]  я должен провести ребро по букве C в класс SC. Если, ну если у C это такой суффикс SC,
[07:59.440 --> 08:12.760]  что у C при этом не под строка S, вот так, не под строка S, потому что мы помним,
[08:12.760 --> 08:17.120]  класс SC состоит в точности из всех строк, которые получили новое вхождение, вот раньше не входили,
[08:17.120 --> 08:22.360]  а теперь входят, вот это класс SC, те суффиксы, которые раньше не входили, теперь входят. Поэтому
[08:22.360 --> 08:27.320]  рёбра, ведущие в этот класс, это обязательно рёбра из таких слов U, что дописывание новой
[08:27.320 --> 08:32.440]  символа C как раз переводит меня в этот класс, то есть это такой суффикс, что он не является под
[08:32.440 --> 08:39.880]  строкой S, не является под строкой S. Ну тогда понятно, что незаведомо нужно провести ребро из
[08:39.880 --> 08:46.000]  класса S, вот такое вот, потому что если есть здесь слово S, то при прописывании к нему буквы C мы как
[08:46.000 --> 08:52.120]  раз перемешаемся в класс SC. Затем нужно взять от него суфсылку, мы помним, да, что все вот эти
[08:52.120 --> 08:56.400]  вот рёбра, они обязательно должны образовывать путь по суфсылкам, поэтому я беру суфсылку от этого S,
[08:56.400 --> 09:02.560]  перехожу сюда, и опять, да, если здесь, скажем, нет ребра по C, то я его строю, опять перехожу по
[09:02.560 --> 09:08.040]  суфсылке и так далее. Вот, и что значит, что, то есть я так делаю, пока не найду первую вершинку,
[09:08.040 --> 09:14.200]  из которой есть переход по C. Есть переход по C. Тогда вот для всех вот этих вот, я утверждаю,
[09:14.200 --> 09:17.840]  что мне нужно эту стрелку перенаправить, то есть создать стрелку по C и перевести ее в SC,
[09:17.840 --> 09:26.760]  а для этого ее менять не нужно. Вот почему. Значит, пусть это P, пусть это вершинка P. Для всех вот этих,
[09:26.760 --> 09:33.280]  повторюсь еще раз, для этих вершин не было ребра по C. То есть это такие строки, такие строчки U,
[09:33.280 --> 09:39.400]  что в исходном автомате, в старом автомате, который отвечает строке S, приписать к строке U букву
[09:39.400 --> 09:44.960]  C нельзя. То есть после U не может следовать C. Это как раз означает, что U-C было не под строкой S,
[09:44.960 --> 09:52.680]  но теперь при дописывании C в конец у меня будет U-C, это суффикс SC. И поэтому вот во всех этих
[09:52.680 --> 09:57.400]  вершинках, где не было ребра исходящего, исходящего ребра по букве C, мне нужно его создать и
[09:57.400 --> 10:03.040]  переместить сюда. Потому что это как раз будут такие вершинки, которые раньше вот это U-C не
[10:03.040 --> 10:11.000]  было под строкой S. А теперь станет, поэтому такое ребро нужно завести. Так, ну и здесь давайте сразу
[10:11.000 --> 10:17.040]  же, давайте я напишу такой маленький код. Давайте я напишу маленький код. Я скажу, что P это класс
[10:17.040 --> 10:36.800]  соответствующий S, пока, ну скажем, P не равно минус единице и из P нет перехода по C. Мы делаем
[10:36.800 --> 10:43.440]  следующее. Мы создаем этот переход, говорим, что он ведет в это SC. Я обозначу это так. To P по
[10:43.440 --> 11:01.200]  букве C равно SC. Ну вот так напишу. И P равно link от P. Скопка закрылась. Стал вот сюда и прыгаю
[11:01.200 --> 11:07.040]  после ссылки, пока не найду переход по C. И всюду, где не было такого перехода, создаю его в новую
[11:07.040 --> 11:13.320]  вершинку SC. Теперь, самый простой случай, это когда мы такими вот прыжками дошли до самого корня,
[11:13.320 --> 11:20.880]  до, ну до, до начальной вершины нашего софт-томата, которая, кустарта. И даже если, и вот хорошо,
[11:20.880 --> 11:27.200]  если даже из старта нет этого перехода по C. Это соответствует случаю, потому что P стало
[11:27.200 --> 11:31.520]  равно минус единице, то есть якобы попытался взять ссылку от корня и уже, соответственно, дальше
[11:31.520 --> 11:45.200]  ничего не делаем. Первый случай. Если из корневой вершины, корневой, то есть стартовой,
[11:45.200 --> 12:00.560]  нет перехода по C. Это соответствует тому, что P равно минус единице в конце
[12:00.640 --> 12:04.840]  исполнения этого вала. То есть, я считаю, что я дошел до корня, не нашел у него переход по C и его
[12:04.840 --> 12:09.600]  построил в SC. Потом взял опять сувсылку и сказал, что у меня P стало равно минус единице. То есть,
[12:09.600 --> 12:17.600]  сувсылка от корня как бы это минус один. То есть, тогда картинка вот такая. Я провожу такие рёбра,
[12:17.600 --> 12:23.120]  беру сувсылку, провожу рёбра, беру сувсылку, провожу, провожу, и в конце концов я приду в корень.
[12:23.120 --> 12:30.920]  Это будет корень начальной вершины автомата. Вот, ну тогда я утверждаю, что S0 это просто
[12:30.920 --> 12:38.080]  эпсилон. В таком случае S0 это просто эпсилон. С одной стороны, с другой стороны, C не встречалась
[12:38.080 --> 12:52.240]  в S. Не встречался, да? Наверное, символ C не встречался в S. Ну, когда может быть такое,
[12:52.240 --> 12:56.680]  что я дошел до корня и даже из корня не было перехода по букве C. Только в случае, если C это
[12:56.680 --> 13:01.840]  вообще новый символ, которого не было в строке S. Скажем, в S были только Ашки и Бэшки, пришла
[13:01.840 --> 13:05.640]  новая буква C, ну тогда понятно, что из корня нет перехода по C, потому что его раньше в принципе
[13:05.640 --> 13:09.520]  не было нигде в автомате, не было в строке, не может быть в автомате. Ну и наоборот, да, если
[13:09.520 --> 13:13.520]  нет сейчас перехода, то значит, что нигде раньше этой буквы просто не было, иначе бы этот переход
[13:13.520 --> 13:17.120]  обязательно был бы, потому что у него автомат хранит себя по строке, поэтому все символы точно хранит.
[13:17.120 --> 13:23.200]  Хорошо, получается, что C это какая-то новая буква, которой раньше вообще не было, ну и так дошли до
[13:23.200 --> 13:31.600]  корня, ну и тогда что такое S0? Так, я S0 стёр. Напоминаю, это максимальный суффикс СС, который
[13:31.600 --> 13:38.720]  является по строкой S. Но, извините, я не могу взять никакой нетривиальный суффикс, потому что они
[13:38.720 --> 13:44.400]  все содержат это последнее C, а С раньше нигде не встречалось, поэтому самую длинную строчку,
[13:44.400 --> 13:49.800]  которую я могу в качестве S0 взять, это вот эта пустая строка. Самый длинный суффикс, который
[13:49.800 --> 13:56.760]  является по строкой С, это просто Эпсилон, пустая строка. Ну, а мы ещё в прошлый раз заметили, что
[13:56.760 --> 14:05.640]  сувсылку мы должны определить так, что сувсылка СС это обязательно класс С0. Ну, потому что как раз
[14:05.640 --> 14:10.760]  относительно СС, самый длинный его суффикс, который лежит в другом классе, это вот эта вот С0,
[14:10.760 --> 14:17.840]  поэтому сувсылка ведёт сюда. Значит, мне нужно просто в конце вот этого вот вайла, когда я дошёл
[14:17.840 --> 14:22.040]  до корня, мне нужно сказать, что сувсылкой вот этой вершинкой будет вот это, то есть просто корень,
[14:22.040 --> 14:27.480]  и на этом обработка новой символы С закончилась. То есть я целиком построил все ребра сюда. Понятно,
[14:27.480 --> 14:32.720]  что С0, как было лонгестом, так и осталось лонгестом, оно, собственно, только в корне лежит,
[14:32.720 --> 14:36.760]  поэтому там ничего не расщепляется, и вот эти вот ребра не меняются. Поэтому на этом как бы
[14:36.760 --> 14:42.440]  обработка заканчивается. Мы провели все ребра в СС и говорим, что сувсылка у нас теперь ведёт вот
[14:42.440 --> 15:05.400]  так из СС в корень. Всё, это простой случай разобран. Так, вопросы? Хорошо, значит тогда
[15:05.400 --> 15:10.520]  случай второй, когда мы вот так вот идём и закончили где-то раньше, чем корень, то есть мы
[15:10.520 --> 15:14.800]  так шли-шли-шли, по сувсылкам поднимались, или у меня тут на картинке спускались по сувсылкам,
[15:14.800 --> 15:24.040]  и дошли до какой-то вершинки, из которой есть переход по С. Вот так я давайте это нарисую.
[15:24.040 --> 15:30.280]  Значит, мы проводили ребра по С2 класс соответствующей СС, и дошли до вершинки,
[15:30.280 --> 15:36.440]  из которой уже был такой переход по С, который ввёл в какую-то другую вершинку. Давайте я вот это
[15:36.440 --> 15:39.880]  вот, значит, после нашего цикла, вот это будет как раз П. П — это последняя вершина,
[15:39.880 --> 15:45.120]  точнее первая найденная вершина, из которой есть переход по С. Первая найденная, из которой есть
[15:45.120 --> 15:53.960]  переход по С. Хорошо, значит вот мы её нашли. Тогда я утверждаю, что вот это как раз будет
[15:53.960 --> 16:01.000]  состояние Q, в котором лежит С0. Вот это будет такое состояние Q, в котором лежит С0, тот самый
[16:01.000 --> 16:07.600]  максимальный суффикс, который является по строкой С. Ну, вроде понятно, потому что как у меня
[16:07.600 --> 16:12.520]  устроены вообще все суффиксы строки СС? Это обязательно нужно взять какой-то из суффиксов
[16:12.520 --> 16:19.000]  исходной строки, которая получается по вот этим вот сувсылкам. Вот это вот было С, да? Как
[16:19.000 --> 16:23.960]  получается все суффиксы строки С? Это нужно встать в С и прыгать по суффиксам. Тогда как раз здесь,
[16:23.960 --> 16:28.840]  на этом пути, будут все суффиксы. Это мы тоже обсуждали. Тут будут все суффиксы. Значит,
[16:28.840 --> 16:33.400]  как может быть устроена С0? Это обязательно встать куда-то вот сюда, в одну из этих вершин и
[16:33.400 --> 16:41.160]  приписать С, потому что С0 это вот такая какая-то штука. Какой-то кусочек старого суффикса с приписанием
[16:41.160 --> 16:46.120]  С. То есть я должен встать куда-то сюда и пройти по букве С. Но из этих вершин я пройти по букве С не
[16:46.120 --> 16:51.800]  мог, а из этой уже могу. Ну, значит, тогда понятно, что самая длинная строка вот этой вот С0, это как
[16:51.800 --> 17:02.640]  раз самая длинная строка СП, то есть лонгест от П, плюс С. Значит, С0 равно лонгест от П плюс С. Самый
[17:02.640 --> 17:06.440]  длинный суффикс, к которому можно приписать С. Он обязательно вот здесь. Просто есть такое ребро.
[17:06.440 --> 17:15.240]  Поэтому я напишу так. С0 лежит вот в этом состоянии Q. Принадлежит классу эквивалентности строк,
[17:15.240 --> 17:25.880]  в которой все схлопаются. Вот. И здесь может возникнуть потребность это Q расщепить. Это Q расщепить
[17:25.880 --> 17:30.200]  в случае, если С0 не было лонгестом. То есть мы понимали, что оно не было лонгестом, теперь оно
[17:30.200 --> 17:35.120]  обязательно лонгест. И мне потенциально это нужно расщепить. Давайте рассмотрим хорошую ситуацию,
[17:35.120 --> 17:42.720]  когда не нужно расщеплять. Когда это не нужно делать? Нам не нужно расщеплять Q,
[17:42.720 --> 18:05.320]  если и только если С0 уже была лонгестом. То есть С0 было равно лонгест от Q. Ну и это,
[18:05.320 --> 18:10.640]  с точки зрения чего-то, что можно проверить за вот однице, равносильно такому условию.
[18:10.640 --> 18:21.960]  Лен от Q равно лен от P плюс 1. Мы напоминаем, мы вот эти лонгесты явным образом не храним,
[18:21.960 --> 18:25.880]  потому что если их хранить, то тогда у меня будет квадратичная память. Я храню только лен,
[18:25.880 --> 18:31.800]  только длины этих самых лонгестов. Ну и понятно, что вот эта вот С0, которая получается приписыванием
[18:31.800 --> 18:36.920]  вот сюда буквы С, она будет лонгестом здесь, если и только если выполняется вот такое соотношение
[18:36.920 --> 18:42.760]  на длины наших состояний. Что длина максимальной строки вот здесь ровно на 1 больше, чем вот здесь.
[18:42.760 --> 18:48.800]  Лен от Q равно лен от P плюс 1. Ну потому что С0, это как раз взять вот эту вот строчку длины лен от
[18:48.800 --> 18:52.760]  P, приписать к ней один символ, и мы как раз поводим в Q. И если это самая длинная строка,
[18:52.760 --> 19:00.200]  то собственно вот это равенство должно выполняться. Поэтому второй случай, это как раз случай вот
[19:00.200 --> 19:05.920]  этого равенства, когда лен от Q равно лен от P плюс 1. То есть С0 была уже лонгестом, ничего расщеплять
[19:05.920 --> 19:11.280]  не нужно, и мой автомат больше не меняется, у него состояние не меняется. Тогда как нужно это обработать?
[19:23.280 --> 19:30.760]  Очень просто. Я утверждаю, что в таком случае нужно просто сказать, что линк вот этого С,
[19:30.760 --> 19:41.560]  это просто Q, и на этом закончить. То есть мы сначала вот так вот пропрыгали из вот этого
[19:41.560 --> 19:46.840]  S по субсылкам, провели такие ребра по букве С в СС, а затем дошли до первой вершинки P,
[19:46.840 --> 19:51.880]  с которой уже был переход по С, и пусть выполняется в такой условии. Тогда достаточно просто назначить
[19:51.880 --> 19:59.880]  такую субсылку, и случай целиком разобран. Вот. Ну почему? Почему это так? Мы поняли, что это
[20:00.040 --> 20:04.480]  состояние не меняется, поэтому ребра, входящие в него и исходящие из него, никак не поменяются,
[20:04.480 --> 20:08.360]  это старое состояние, которое не помнялось, поэтому с ним все остается так, как было.
[20:08.360 --> 20:14.720]  Вот, поэтому ребра, которые могут поменяться, появиться, удалиться или измениться, это только
[20:14.720 --> 20:19.240]  ребра ведущие в СС, которых раньше не было, которые теперь появляются. Ну такие вот я провел, а
[20:19.240 --> 20:24.700]  işte ребра, исходящие отсюда, уже было ребро по С, и оно именно что должно вести сюда, а не в СС.
[20:24.700 --> 20:31.140]  да и вообще какие еще могут быть ребра какие еще ребра могут мы потенциально не
[20:31.140 --> 20:38.500]  провели ну вспоминаем какие ребра нужно провести в эсце это такие суффиксы с такие суффиксы с
[20:38.500 --> 20:45.260]  что дописаны к ним буковки ц перестает быть суффиксом с быть под строкой с давайте давайте
[20:45.260 --> 20:52.740]  еще восстановлю это давайте восстановим что я провожу ребро из у в эсце если у меня у ц это
[20:52.740 --> 21:01.140]  не под строка с да не под строка с но еще у это суффикс с это вот у меня было здесь написано я
[21:01.140 --> 21:08.700]  просто восстанавливаем у суффикс с ну все суффиксы лежат в этом пути по ссылкам и теперь мне
[21:08.700 --> 21:13.940]  нужно получается найти только те из них из которых не было перехода по букве ц потому что у ц должно
[21:13.940 --> 21:19.140]  быть не под строкой то есть просто не могло быть там перехода по ц все такие я нашел здесь уже
[21:19.620 --> 21:26.900]  сувсылки многократно тоже будет переход по ц потому что если вот отсюда есть переход по ц значит
[21:26.900 --> 21:32.020]  и у более коротких строк их тоже можно продолжить этой буквой ц да потому что например тут была
[21:32.020 --> 21:39.420]  какая строка вот этой вот лонгестат п и мы знаем что лонгестат п плюс ц это под строка с что лежит
[21:39.420 --> 21:43.900]  здесь здесь как какой-то вот это вот суффикс вот этой строки к нему понятное дело тоже можно
[21:43.900 --> 21:48.400]  Здесь лежит какой-то суффикс, вот это строки, к нему, понятное дело, тоже можно приписать С.
[21:48.400 --> 21:51.400]  Потому что если вот это под строка, то это тем более под строка С.
[21:51.400 --> 21:56.200]  Ну и так далее. Когда мы проходимся по этому суффиксному пути, у меня эта строка всё уменьшается и уменьшается,
[21:56.200 --> 22:02.300]  тогда понятно, что всё это время можно её продлить С, и это всё будет под строка С.
[22:02.300 --> 22:07.500]  Поэтому все вот эти вот ребра, из них уже был переход по С, поэтому его не нужно менять.
[22:07.500 --> 22:09.900]  Нужно менять только те, которых не было.
[22:09.900 --> 22:13.400]  А эти не изменятся.
[22:13.900 --> 22:17.400]  В итоге автомат не поменяется, кроме вот этих ребр.
[22:17.400 --> 22:22.900]  Остаётся только назначить суффсылку, ну а мы уже неоднократно замечали, что суффсылка из СС должна вести в С0.
[22:22.900 --> 22:24.900]  Ну а С0 это как раз вот это ку.
[22:26.900 --> 22:27.900]  Хорошо.
[22:27.900 --> 22:31.900]  Тогда последний случай, который нам остаётся, это плохой случай.
[22:31.900 --> 22:42.900]  То есть, во-первых, из П есть переход по С в вершину ку.
[22:43.400 --> 22:47.400]  Но при этом вот эта равенство не выполняется.
[22:48.400 --> 22:52.400]  Ну я могу написать просто «неравно», могу написать «строго больше».
[22:52.400 --> 22:54.400]  Это будет одно и то же.
[22:58.400 --> 23:02.400]  Понятно, что здесь неравенство, вот такое неравенство всегда выполняется,
[23:02.400 --> 23:05.400]  что лен от ку всегда больше равной лен от П плюс один.
[23:05.400 --> 23:11.400]  Потому что, если вот здесь есть какая-то строка длины лен от П, то строка длины на один больше точно здесь лежит.
[23:11.400 --> 23:13.900]  Поэтому здесь максимальная будет больше равной, чем вот это.
[23:13.900 --> 23:18.900]  Здесь не может быть значка меньше, может быть только больше, если не равенство.
[23:20.900 --> 23:22.900]  Так, окей.
[23:23.900 --> 23:25.900]  Что же тогда происходит?
[23:25.900 --> 23:27.900]  Это как раз случай, когда ку нужно расщепить.
[23:27.900 --> 23:29.900]  Ку нужно расщепить.
[23:34.900 --> 23:36.900]  Давайте я нарисую следующую картинку.
[23:36.900 --> 23:40.900]  Вот была ку, там был какой-то лонгест.
[23:40.900 --> 23:42.900]  И несколько его самых длинных суффиксов.
[23:44.400 --> 23:46.400]  Такая картинка, такая картинка.
[23:47.400 --> 23:52.400]  Так, сейчас я буду рисовать довольно долго.
[23:55.400 --> 23:57.400]  Ну вот что-то такое.
[23:58.400 --> 24:01.400]  Мы поняли, что s0 это не самое длинное из них.
[24:01.400 --> 24:03.400]  То есть скажем, ну вот это вот какое-нибудь s0.
[24:03.400 --> 24:05.400]  Давайте скажем, что вот это вот это s0.
[24:06.400 --> 24:08.400]  Так, и как оно получается?
[24:08.400 --> 24:12.400]  Оно получается переходом из p по букве c.
[24:14.400 --> 24:20.400]  Но здесь вместе с этим s0 в состоянии p могли же идти еще другие строки.
[24:20.400 --> 24:22.400]  Ну там давайте их несколько нарисуем.
[24:22.400 --> 24:24.400]  Вот это вот там и вот это, например.
[24:28.400 --> 24:29.400]  Что мы должны сделать?
[24:29.400 --> 24:32.400]  Мы понимаем, что у меня теперь s0 становится новым лонгестом.
[24:32.400 --> 24:36.400]  Значит мне нужно вот это ку вот здесь расщепить по вот этой линии.
[24:37.400 --> 24:40.400]  Эта строка как была лонгестом, так и осталась.
[24:40.400 --> 24:42.400]  Мы помним, что лонгест у нас сохраняются.
[24:42.400 --> 24:44.400]  То есть если когда-то лонгест, то всегда лонгест.
[24:44.400 --> 24:47.400]  И просто вот эта строка становится новым лонгестом.
[24:47.400 --> 24:49.400]  Тогда расщепление происходит именно по этой линии.
[24:49.400 --> 24:51.400]  s0 стало новым лонгестом.
[24:51.400 --> 24:53.400]  Новой самой длинной строкой для всех более коротких.
[24:54.400 --> 24:57.400]  Ну а все, которые более длинные, остаются там с этим лонгестом от ку.
[24:58.400 --> 25:00.400]  В итоге у меня будет два состояния.
[25:00.400 --> 25:03.400]  Давайте я это состояние оставлю, буду называть ку.
[25:03.400 --> 25:05.400]  А это состояние я назову клон.
[25:06.400 --> 25:11.040]  вот прям клон Q, потому что она будет очень похожа на Q. В ней практически все
[25:11.040 --> 25:18.000]  будет совпадать с с кушкой. Так, это вот случай расщепления. Тогда вспоминаем, как
[25:18.000 --> 25:22.000]  может поменяться мой граф, какие у меня могут появиться или измениться ребра.
[25:22.000 --> 25:27.600]  Во-первых, какие-то ребра, ведущие вот в это вот старое Q, могли перенаправиться
[25:27.600 --> 25:32.480]  и теперь вести в клон. То есть какие-то ребра, ведущие сюда, остаются вести вот
[25:32.480 --> 25:37.040]  в это Q старое, а какие-то должны переместиться вот сюда. То есть это первое,
[25:37.040 --> 25:43.000]  какие-то ребра отсюда должны начать вести вот сюда. Во-вторых, нужно понять, какие
[25:43.000 --> 25:49.920]  ребра из них исходят, из нового Q, из нового клон, и сообразить, как здесь
[25:49.920 --> 25:55.680]  определяется всылка. Это мы все сейчас сделаем.
[26:02.480 --> 26:11.400]  Так, ну первый шаг, самый простой, это как ведут себя ребра, ведущие в исходное Q.
[26:11.400 --> 26:15.440]  Значит, вспоминаем, как ведут себя вообще ребра в автомате, которые ведут в какую-то
[26:15.440 --> 26:19.880]  вершинку. Это часть суффиксного пути, и на всех стрелках написано одно и то же.
[26:19.880 --> 26:25.040]  Мы понимаем, что вот это вот P, это самое длинное состояние, ведущее вот это S0.
[26:25.040 --> 26:30.480]  Соответственно, там от него сувсылка тоже вела куда-то вот сюда. Ну скажем, не знаю, там было,
[26:30.480 --> 26:36.120]  например, одно слово, вот это вот. И еще, когда мы берем сувсылку, тоже есть переход по
[26:36.120 --> 26:43.760]  букве C, которая соответствует этим двум последним словам. Раз, два. Но также этот суффиксный
[26:43.760 --> 26:49.080]  путь можно продолжить как бы вот в сторону более длинных строк. Это будет соответствовать вот
[26:49.080 --> 26:53.400]  этому вот начальному отрезку, который остается в том же самом состоянии Q.
[26:53.400 --> 26:59.200]  То есть тут еще было какое-то предначало. Вот такое начало, да, еще там какие-то более длинные
[26:59.200 --> 27:08.240]  строки, которые тоже переходят по символу C в состоянии Q. Вот такой получается весь кусочек пути,
[27:08.240 --> 27:14.080]  которые описывают все ребра, ведущие в Q. Тогда я утверждаю, что вот эти вот вершинки, которые
[27:14.080 --> 27:20.040]  лежат выше, чем P, соответствуют более длинным состояниям, у них ничего не изменится. Они по
[27:20.040 --> 27:25.560]  прежнему будут вести вот сюда. Ну потому что понятно, что я из Q вот это вот как бы отсек,
[27:25.560 --> 27:31.760]  более короткие строки, начиная с 0 и вниз, я их отсек. Тогда понятно, что вот эти вот ребра,
[27:31.760 --> 27:35.760]  которые соответствуют более длинным строчкам, они не изменятся. Потому что скажем вот здесь,
[27:35.760 --> 27:40.000]  вот эта строка переходила вот в это. Ну значит это ребро и сохранится, да, то есть оно не задействует
[27:40.000 --> 27:44.240]  нижнюю половинку. То же самое, если были там еще какие-то строчки, они все вели обязательно вот
[27:44.240 --> 27:49.280]  сюда. И поэтому нижнюю часть они как бы не задевают, их можно вообще гноевировать. Все вот эти вот строчки,
[27:49.280 --> 28:04.000]  которые длиннее, чем P и ведут в Q, я их оставляю. Ну давайте я напишу букву А. Ребра из вершин
[28:04.000 --> 28:25.720]  с лен больше, чем, наверное, P, ведущие в Q не изменяются. Ну я тут постарался объяснить,
[28:25.720 --> 28:32.960]  да, что вот еще есть какие-то ребра, ведущие в Q, которые, ну сувсылка от которых равна P или там
[28:32.960 --> 28:36.960]  несколько раз взять сувсылку, получишь AP. Тогда они остаются, вот эти стрелки остаются, потому что
[28:36.960 --> 28:41.520]  они ведут вот в этом множество. С ними понятно, их не трогаем. Но есть вот эти вот какие-то,
[28:41.520 --> 28:46.760]  да, от которых раньше мы вели в Q, а теперь, понятное дело, нужно вести в клон. Потому что отсюда мы
[28:46.760 --> 28:51.920]  раньше вели в Q, но вот в эту вот строчку S0. И теперь эта строчка S0, она уже будет лежать в этом клоне.
[28:51.920 --> 28:58.400]  Поэтому все вот эти вот ребра нужно перенести вот сюда. Потому что эти ребра ведут все во все более
[28:58.400 --> 29:02.920]  и более короткие строчки. И поэтому, понятное дело, что они теперь в новом состоянии клон лежат,
[29:02.920 --> 29:16.480]  поэтому нужно эти ребра перевести туда. Давайте я напишу такой цикл. Опять, пока мы не дойдем до упора,
[29:16.480 --> 29:29.560]  и пока переход из P по букве C равен Q, ведет в Q, мы его перенаправляем. Мы говорим, что tool PC
[29:29.560 --> 29:47.200]  это клон. P равно link от P. Это как раз соответствует тому, что мы проходимся по всем с усылком P,
[29:47.200 --> 29:54.120]  и те стрелочки, которые вели раньше в Q, мы перенаправляем в клона. И там в какой-то момент
[29:54.120 --> 29:58.760]  мы дойдем до вершин, которые изначально вели в другое состояние, собственно их мы там оставляем.
[29:58.760 --> 30:03.160]  То есть, если есть ребра отсюда-сюда, в другое состояние, отличное от Q, то мы его оставляем на
[30:03.160 --> 30:07.520]  месте, потому что это неизменившийся состояние, их не нужно менять. Меняются только те, которые вели
[30:07.520 --> 30:15.000]  в Q. Да, вот мы их, собственно, перенаправили в клон. Так, это сделали. Это мы разобрались с ребрами,
[30:15.000 --> 30:24.040]  ведущими в изначальное Q. Какие-то остались на месте, какие-то переместились в клона. Хорошо. Теперь я хочу
[30:24.040 --> 30:37.360]  понять, как ведут себя ребра, наоборот, исходящие из Q и из клона. Давайте пункт B. Ребра исходящие
[30:37.360 --> 30:57.560]  из Q и из клона. Так, ну для этого давайте заметим следующее, что правый контекст в новой строке SC для
[30:57.560 --> 31:08.320]  состояния клон отличается от правого контекста в строке SC состояния Q добавлением пустой строки.
[31:08.320 --> 31:16.600]  Причем оно добавляется дизъюнтно. То есть, раньше его, то есть, здесь нету эпсилон, мы вот насильно
[31:16.600 --> 31:27.920]  добавляем, получаем R от клона. Так, ну почему это так? Почему это так? Нам нужно просто понять,
[31:27.920 --> 31:38.360]  как отличаются множество вхождений в SC вот этих строк и вот этих строк. То есть, вот эти строчки,
[31:38.360 --> 31:43.920]  как бы, были какие-то вхождения там, они остаются, а здесь тоже какие вхождения у вот этих строк в
[31:43.920 --> 31:54.000]  нашу строчку SC. Ну смотрите, понятно, что вот этот вот лонгест от Q, лонгест от Q, оно не получило
[31:54.000 --> 32:00.680]  нового вхождения в SC, потому что это раньше была какая-то по строка S, и теперь она не соответствует
[32:00.680 --> 32:08.680]  никакому суффиксу SC, потому что суффиксы SC, они, ну вот там, сначала была сама строка SC, потом
[32:09.160 --> 32:17.440]  будет идти сюда. То есть, лонгест от Q это точно не суффикс SC. Лонгест от Q это не суффикс SC,
[32:17.440 --> 32:30.640]  поэтому, на самом деле, правый контекст не изменился. Не так. Скорее, множество вхождений Q в SC не
[32:30.640 --> 32:43.800]  изменилось. Множество вхождений лонгест от Q в SC совпадает с множеством вхождений в S.
[32:43.800 --> 33:03.240]  Совпадает с множеством вхождений S, потому что была какая-то строка, да, она не получила
[33:03.240 --> 33:07.680]  нового вхождения, значит, у нее просто никак не поменялось множество вхождений. Что было,
[33:07.680 --> 33:17.240]  то и осталось. А что получается у S0, у этой строки лонгест от клон? Какое у нее вхождение? Ну,
[33:17.240 --> 33:23.800]  а у нее как раз появилось новое вхождение, потому что S0 это максимальный суффикс SC. То есть,
[33:23.800 --> 33:32.480]  сейчас только что при дописывании к S символа С, у меня появилось новое вхождение S0. То есть,
[33:32.480 --> 33:51.400]  раньше его не было, теперь появилось. А у S0 появилось одно новое вхождение. Появилось
[33:51.400 --> 33:57.000]  одно новое вхождение. Ну и тогда как раз получается вот это вот соотношение, что правый контекст клона
[33:57.000 --> 34:02.840]  отличается от правого контекста Q только добавлением эпсилона. Потому что, давайте еще что-нибудь
[34:02.840 --> 34:11.760]  нарисую, да, вот везде, где у меня встречался лонгест от Q, у меня там же встречался S0 в исходной
[34:11.760 --> 34:18.120]  строке. Они раньше были в одном состоянии, потому что S0 лежало просто в состоянии Q,
[34:18.120 --> 34:21.960]  поэтому они встречались в одном и том же множестве мест. А теперь у меня появилось новое вхождение
[34:21.960 --> 34:28.720]  S0, которое заканчивается вот этим символом С, да, концом строки. И больше вот это вот это уже не
[34:28.720 --> 34:34.320]  не лонгест от Q. То есть, просто отличается у них множество вхождений только вот этим вот последним
[34:34.320 --> 34:39.600]  вот вхождением S0. Значит, просто правый контекст отличается тем, что вот здесь эпсилона нету,
[34:39.600 --> 34:44.880]  а здесь есть. Эпсилон это напоминает, что как раз строка заканчивается в конце строки,
[34:44.880 --> 34:50.000]  является суффиксом. Вопрос есть?
[35:04.000 --> 35:14.040]  Хорошо. Так, это мы доказали. Вот, да, значит, тогда на самом деле у меня вообще чем отличаются
[35:14.200 --> 35:20.160]  эти две строчки? Они отличаются только тем, что вот это вот терминальное, а это не терминальное.
[35:20.160 --> 35:26.400]  У них правый контекст отличается только тем, что здесь, в этой вишенке, эпсилон есть, то есть эта
[35:26.400 --> 35:31.880]  вишенка терминальная является суффиксом, а это не является суффиксом, она не терминальная. А значит,
[35:31.880 --> 35:35.880]  множество исходящих ребер у них будет одно и то же, и они будут вести в одни и те же позиции.
[35:35.880 --> 35:47.160]  Значит, из этого соотношения мы получаем, что клон отличается от Q в плане исходящих ребер
[35:47.160 --> 36:07.760]  только тем, что клон терминальная, а Q нет.
[36:07.760 --> 36:21.840]  Потому что, по сути, у этих двух состояний, у Q и у клона одинаковый правый контекст,
[36:21.840 --> 36:25.400]  если не учитывать пустую строчку. То есть, если я из определения правого контекста выкидываю
[36:25.400 --> 36:30.360]  эпсилон, запрещаю дописывать пустую строчку, то у них, по идее, одинаковый правый контекст. То есть,
[36:30.360 --> 36:34.760]  по сути, это практически все еще одно и то же состояние, только что такое правый контекст?
[36:34.920 --> 36:39.840]  Способы отсюда добраться до терминальной. Что можно дописать так, чтобы попасть в терминальную?
[36:39.840 --> 36:43.320]  Поэтому это почти что одно и то же, только одна из них терминальная, другая нет.
[36:43.320 --> 36:47.440]  Значит, множество исходящих ребер и то, куда они ведут, будет точно таким же. Потому что,
[36:47.440 --> 36:52.600]  как бы, именно правый контекст, это множество путей, множество способов попасть до терминальной
[36:52.600 --> 36:56.360]  вершины. Что можно дописать справа, чтобы попасть в терминальную? Но если они одинаковые,
[36:56.360 --> 37:01.000]  за исключением того, что здесь есть эпсилон, а здесь нету, то тогда и все стрелки, нет смысла никак
[37:01.000 --> 37:06.840]  менять. Они будут вести в те же, то есть, стрелки отсюда будут вести туда же, откуда эти вот стрелки
[37:06.840 --> 37:11.560]  там иску. То есть, если это был как символ по Е, то здесь тоже стрелка по Е будет вести в ту же вершинку.
[37:11.560 --> 37:20.920]  Значит, в итоге все, просто все ребра, которые были иску, мы копируем и делаем их ребрами из
[37:20.920 --> 37:29.320]  клона. И это целиком описывает все ребра, исходящие из клона. В итоге, давайте я вот так скажу,
[37:29.320 --> 37:38.920]  что ту от клон просто равно ту от ку. То есть, я целиком все, что было здесь, копировал вот сюда.
[37:38.920 --> 37:44.080]  Все исходящие ребра из клона я перекопировал, все исходящие из ку я перекопировал в клона.
[37:44.080 --> 37:59.280]  Все. Окей? Окей. Так, ну и на это мы разобрались вот с этими ребрами исходящими из клона. То есть,
[37:59.280 --> 38:02.960]  мы поняли, что отличие только в том, что одна терминальная и другая нет. Значит, но что исходящих
[38:02.960 --> 38:10.000]  должно быть одинаково. Все, это мы тоже сделали. И в текущий момент мы уже написали, как меняются
[38:10.000 --> 38:14.920]  все ребра. Как меняются ребра входящие в ку и как меняются ребра теперь исходящие из ку из клона.
[38:14.920 --> 38:20.960]  То есть, просто все, что было в ку, мы копируем в клон. Тогда последнее, что нужно сделать, это
[38:20.960 --> 38:30.720]  простая всякие вот эти вот лены, линки и так далее. Ну, во-первых, что такое лен от клона? Это лен П плюс
[38:30.720 --> 38:39.280]  один. Это лен П плюс один, потому что здесь самая длинная строка является С0, которая как раз
[38:39.280 --> 38:44.160]  получается приписыванием клон Бисту от П, символом С. Поэтому лен от клона на один больше, чем лен от П.
[38:44.160 --> 39:01.560]  Дальше. Что такое линк от клона? Линк от клона, я утверждаю, линк от ку. Раньше у меня было как-то
[39:01.560 --> 39:07.080]  определено линк от ку. Оно вело вот в эту вот строчку, следующую за вот этой вот самой короткой.
[39:07.080 --> 39:11.200]  То есть, я откусываю так по одному символу, пока не поведу в новое состояние. Теперь смотрите,
[39:11.200 --> 39:15.920]  у меня это состояние расщепилось. Тогда как у меня поменялись линки? Ну, линка отсюда должна вести
[39:15.920 --> 39:21.920]  вот сюда, потому что они в разных состояниях. А линка отсюда должна вести вот сюда. Ну, давайте
[39:21.920 --> 39:27.520]  вот я ей скажу, что линк от клона. Вот эта стрелка будет вести сюда, а вот эта стрелка будет вести сюда.
[39:27.520 --> 39:47.320]  Равно клон. Так, ну и последнее, не забываем сказать, что линк от СС, от класса СС, равно клон. Потому
[39:47.320 --> 39:52.360]  что это как раз то самое, где лежит С0. И мне нужно линк отправить отсюда сюда.
[39:57.520 --> 40:03.920]  Вроде все. Мы, кажется, посчитали все, что нужно. Все линки, лены для всех изменившихся вершинок мы
[40:03.920 --> 40:11.440]  посчитали. Так, окей. На самом деле, алгоритм на этом закончился. То есть, мы разобрали все три случая,
[40:11.440 --> 40:16.040]  во всех них сказали, что делать. Вроде блесны нас доказали. Давайте тогда пять минут перерыв,
[40:16.040 --> 40:23.400]  докажем асимпротику и пойдем дальше. Ну что, давайте продолжать. Все, мы построили алгоритм,
[40:23.400 --> 40:28.560]  доказали его корректность в тех местах, где это нужно было. Давайте формулируем следующую
[40:28.560 --> 40:34.160]  теорему, которую оставим без доказательства. Это про максимальное число вершин и максимальное
[40:34.160 --> 40:40.520]  число ребер в автомате, построенном по строке длины n. Так вот, в суффиксном автомате,
[40:40.520 --> 41:08.520]  построенном по строке длины n, не больше, чем 2 и минус одна вершина и не больше,
[41:08.520 --> 41:22.240]  чем 3 и минус 4 ребер. Ну если n там достаточно большое. Я напишу так при n, больше оно, чем n0,
[41:22.240 --> 41:27.280]  потому что точно границу не помню. Ну то есть там для маленьких n наблюдаются какие-нибудь другие
[41:27.280 --> 41:31.080]  эффекты. Например, если n равно единице, то это число вообще отрицательно. Понятно, что число ребер
[41:31.080 --> 41:36.640]  не может быть отрицательным. Ну вот, начиная с какого-то момента, порядок, то есть верхняя оценка на
[41:36.640 --> 41:44.520]  число, оно вот именно такое, что 2n вершин и 3n ребер, ну еще минус константа. Вот, вообще говоря,
[41:44.520 --> 41:51.200]  это про ребра как минимум, это не очень очевидно, потому что вот здесь тонкий момент такой, что когда
[41:51.200 --> 41:58.800]  мы ребра, исходящие из Q, перекопируем в ребра, исходящие из Q1, мы как бы там нужно учитывать,
[41:58.800 --> 42:03.520]  сколько раз мы вот эти вот ребра копируем. То есть мы как бы ребра раздваиваем, и тем самым меня может
[42:03.520 --> 42:08.360]  как бы сильно увеличиться это количество. Если их там было 10 штук, то станет 20. И вот этот скачок
[42:08.360 --> 42:14.000]  нужно как-то аккуратно понимать, сколько именно ребер мы копируем. В худшем случае, там вообще может
[42:14.000 --> 42:19.320]  быть вплоть до размера алфавита, если все возможные исходящие ребра были из Q, то в клон
[42:19.320 --> 42:24.360]  все эти ребра нужно скопировать. Поэтому скачки могут быть довольно резкими. Ну вот, суммарно
[42:24.360 --> 42:32.160]  амортизировано, вы в среднем максимум 3 ребра добавляете. Ну а это там задачка на семинар, если не
[42:32.160 --> 42:40.960]  разбирали, то попросить семинаристов это несложно. Ну здесь имеется ввиду при всех n, начиная с
[42:40.960 --> 42:50.820]  некоторого. То есть существует такое н, что ли, а, а, а. Вот. Хорошо, ну и тогда вот с использованием этой
[42:50.820 --> 42:54.360]  теоремки, которая отдельно доказывается, и на самом деле как бы не обязательно базируется на наш
[42:54.360 --> 43:00.000]  алгоритм, просто можно как бы безотносительно того, как мы строим софтомат, доказать, что в софтомате
[43:00.000 --> 43:04.400]  максимум столько вершины, максимум столько ребер. Так вот, используя эту теоремку, мы сейчас
[43:04.400 --> 43:17.400]  докажем асимптотику нашего алгоритма. Асимптотика алгоритма. Ну здесь либо от n, если вы считаете
[43:17.400 --> 43:24.320]  алфавит константным, либо скажем o на лог сигму или o, sorry, o, n на лог сигма или просто n сигма,
[43:24.320 --> 43:34.880]  если у вас алфавит не константный. Если вы считаете, что алфавит константный, то есть, как мы любим,
[43:34.880 --> 43:39.560]  да, маленькие латинские буквы, тогда можно просто говорить, что от n. Либо же, если у вас алфавит
[43:39.560 --> 43:44.360]  может быть довольно большой, скажем там, ну, в сентуральные числа, тогда нужно немножко аккуратнее
[43:44.360 --> 43:49.600]  быть, так же, как у нас в Боре, собственно, было. Мы либо в каждой вершинке храним, ну не в
[43:49.600 --> 43:54.280]  сентуральных числах, числа, не знаю, от 1 до 1000. Тогда нам нужно либо в каждой вершинке хранить
[43:54.280 --> 43:59.560]  массив длины 1000, чтобы знать, есть ли ребро с таким, ну, по такой букве, либо хранить там какую-нибудь
[43:59.560 --> 44:04.720]  структуру данных, которая по каждой букве может определять, есть ли такое ребро, есть ли есть,
[44:04.720 --> 44:17.760]  куда оно ведет. Короче, здесь, как обычно, будет n на лог сигму или n на сигму. Иначе, если сигма не
[44:17.760 --> 44:25.280]  константа. Вот. Ну, либо аккуратно написать хэш таблицу, тогда тоже асинкротика будет, вроде
[44:25.280 --> 44:30.960]  будет у от n, но если не хочется писать хэш таблицу, то можно с помощью std map сделать логарифом или
[44:30.960 --> 44:39.360]  просто с помощью массива сделать n на сигму. Тоже это там обычно сойдет. Почему? Почему это так? Ну,
[44:39.360 --> 45:00.320]  вот сейчас сделаем. Нужно пройти по всему алгоритму и понять, как бы какие его куски у меня не учтены
[45:00.320 --> 45:06.000]  в вот этих вот, скажем, вершинах или в ребрах. Значит, смотрите, давайте еще раз овервью всего
[45:06.000 --> 45:12.480]  алгоритма. Во-первых, мы на каждом шаге добавляем максимум две вершинки, одну точно, и проводим в нее
[45:12.480 --> 45:19.200]  вот такие вот ребра. И там по какому-то пути из там старой максимальной вершинки s. Проводим такие
[45:19.200 --> 45:24.800]  ребра. Ну, время работы вот этой вот этой итерации, да, то есть проведение ребер, которых раньше не
[45:24.800 --> 45:30.760]  было, оно вот здесь будет учтено. Потому что каждая такая итерация, она заведомо нам добавляет
[45:30.760 --> 45:36.040]  новое ребро. Значит, суммарно, таких шагов будет максимум 3n-4. Это у от n. Такие шаги у нас учтены.
[45:36.040 --> 45:42.280]  Дальше. Если я завершился в корне и даже из корни не было перехода по c, то все, дальше алгоритм
[45:42.280 --> 45:48.160]  ничего не делает. Иначе, вот мы так прошлись, дошли до p, нашли переход по букве c в какое-то
[45:48.160 --> 45:55.000]  состояние q. Если ленод q, это ленод p плюс 1, то тоже ничего не происходит. Мы просто говорим,
[45:55.000 --> 46:00.640]  что всылка отсюда ведет вот сюда, и на этом тоже шаг алгоритма заканчивается. Самое сложное,
[46:00.640 --> 46:05.280]  только возникает в третьем случае, когда q расшепляется. Да, у меня из вот такой картинки,
[46:05.280 --> 46:11.320]  получается какая-то такая картинка. Остается где-то там q в небесах, и у нее возникает копия клон,
[46:11.320 --> 46:19.120]  ребра, и дальше ребра ведут себя так. Все, которые показывали раньше в q и были на пути
[46:19.120 --> 46:24.560]  по всылкам xp, то есть все такие ребра перенаправляются в клон. Если было такое ребро,
[46:24.560 --> 46:28.720]  то оно теперь ведет сюда. Если было такое ребро, то оно теперь ведет сюда, ну и так далее. То есть все
[46:28.720 --> 46:35.280]  вот эти ребра я перенаправляю. И вот это у меня уже не учитывается в количестве проведенных ребер,
[46:35.280 --> 46:38.560]  потому что они и так были учтены, а теперь их просто поменял. То есть я не могу сказать,
[46:38.560 --> 46:44.080]  что я суммарно все это делал за 3 и на 4, потому что они уже когда-то учтены, а я их меняю.
[46:44.080 --> 46:53.720]  Поэтому здесь нужно как-то более тонко это проанализировать. Мы сделаем следующее. Мы поймем,
[46:53.720 --> 47:01.840]  как выглядит вообще путь по всылкам из максимальной вершинки. То есть вот было раньше у нас где-то s,
[47:01.840 --> 47:12.680]  была у него всылка. У него всылка, у него всылка, и так до корни. Теперь появилась новая вершинка
[47:12.680 --> 47:20.520]  s, тоже у нее есть какая-то суфсылка, которая как раз равна клону в нашем сложном случае. У него
[47:20.520 --> 47:30.680]  суфсылка, у него суфсылка, ну и в конце придет тоже корень. Так, у меня какая-то картинка,
[47:30.680 --> 47:37.360]  интересная получилась. В общем, я утверждаю, что на вот этом суфиксном пути число вершин,
[47:37.360 --> 47:47.320]  оно тем меньше, чем больше ребер мы вот так вот перенаправили. Ну а именно, мы понимаем,
[47:47.320 --> 47:52.960]  как ведут себя стрелки. Несколько самых верхних вершин имеют стрелку сюда, потом несколько имеют
[47:52.960 --> 47:58.680]  стрелку сюда, несколько сюда и так далее и так далее. То есть по сути весь вот этот вот старый
[47:58.680 --> 48:05.600]  мой путь развивается на такие кусочки. Давайте я здесь многоточие нарисую, как-то не интересно
[48:05.600 --> 48:11.040]  получилось. Весь старый путь развивается на кусочки, так что внутри каждого кусочка ребра ведут в одну и ту
[48:11.040 --> 48:17.600]  же вершинку. Вот эти ведут в s, эти в клон, эти там вот сюда, эти туда и так далее. Ну и тогда понятно,
[48:17.600 --> 48:23.120]  что время работы, за сколько работало вот то перенаправление ребер, которые вели в ку, теперь ведут
[48:23.120 --> 48:28.920]  в клон. Это время пропорционально просто размеры у этого блока. Время вот этой итерации пропорционально
[48:28.920 --> 48:35.280]  размеры у этого блока. Те ребра, которые теперь ведут в клон. Но тогда смотрите, если здесь было
[48:35.280 --> 48:40.560]  много вершин, для которых мне потребовалось перенаправлять эти ребра в клон, тогда каждое такое
[48:40.560 --> 48:46.320]  действие у меня как бы уменьшает количество вершин вот в этом пути. Потому что чем больше здесь
[48:46.320 --> 48:51.240]  было вершин, тем больше они схлопнут здесь. Значит на этом пути будет меньше вершин. В итоге я хочу
[48:51.240 --> 48:57.400]  сказать следующее, что если на этом шаге у меня было, хотя бы k вершин перенаправлялись, из них
[48:57.400 --> 49:06.200]  ребра стали вести в клон, то и здесь всего было скажем m вершин, то вот на этом пути вершин не
[49:06.200 --> 49:17.680]  больше, чем что-то в стиле m плюс 1 минус k. Ну или там m плюс 2, сейчас я пойму. Нет, вроде просто
[49:17.680 --> 49:25.000]  m плюс 1, потому что у нас появляется новая страница, из этого плюс 1, а вот эти вот все,
[49:25.000 --> 49:31.040]  ну это ладно, давайте плюс 2 на всякий случай напишем, то есть появляется новая c, а затем все вот
[49:31.040 --> 49:36.560]  эти вот k вот этих штучек склеиваются в одну вершинку клон. Получается плюс 1 минус k, вот как раз
[49:36.560 --> 49:42.160]  плюс 1 минус k. Ну и тогда понятно, что чем больше здесь было k, тем меньше станет вершин на вот этом
[49:42.160 --> 49:47.120]  следующем суффиксном пути. И тогда на следующем шаге, когда я буду переходить от s c к s c и
[49:47.120 --> 49:52.520]  следующая буква, у меня опять, если я долго буду работать, то у меня уменьшится количество вершин на
[49:52.520 --> 49:58.920]  вот этом суффиксном пути. Ну и тогда понятно, что поскольку у меня на каждом шаге вот эта вот
[49:58.920 --> 50:05.720]  длина увеличивается максимум на 2 за счет двух новых вершинок, и каждая итерация цикла уменьшает
[50:05.720 --> 50:14.640]  мне эту длину хотя бы на единицу, то таких итераций цикла будет максимум отn. Понятно? Ну значит,
[50:14.640 --> 50:22.880]  суммарно, вот этих вот перенаправлений тоже будет отn. В итоге, перенаправление рёбер
[50:22.880 --> 50:36.120]  тоже будет отn. Ну и всё, тогда мы доказали всё, что нужно. То есть, во-первых, рёбер,
[50:36.120 --> 50:39.760]  который мы проводим, их линейное количество, и перенаправление тоже линейное, и вершин,
[50:39.760 --> 50:46.040]  которые мы создаём, тоже линейные. Поэтому нужная симпотика доказана. Помодлю вот этот
[50:46.040 --> 50:59.680]  теориям. Так, ну хорошо, теперь давайте напишем целиком этот код, на всякий случай. Вот, и наверное
[50:59.680 --> 51:10.720]  пойдём дальше. Я считаю, что у меня у каждой вершинки есть параметры link и множество
[51:10.720 --> 51:15.640]  переходов to. Множество переходов to для каждой вершинки, по каждой букве у меня есть там либо
[51:15.640 --> 51:21.760]  минус один, если перехода нету, либо номер вершинки, куда ведёт это ребро. Ещё давайте я буду
[51:21.760 --> 51:31.200]  хранить переменную last, которая отвечает вот этой штуке. Отвечает самому длинному суффиксу,
[51:31.200 --> 51:35.160]  построенному на текущий момент. То есть, самая вот эта последняя вершинка. Изначально last это вот
[51:35.160 --> 51:47.360]  это, потом last нужно будет переносить вот сюда. Я пишу код, который не претендует на хороший,
[51:47.360 --> 51:54.600]  хороший стиль оформления, но я скорее хочу, чтобы это было написано просто на доске. Итак,
[51:54.600 --> 52:01.040]  как добавить новый символ к нашей строчке? Во-первых, нужно обязательно завести новое
[52:01.040 --> 52:13.440]  состояние. Давайте считать, что... Не так я хочу сделать. Сорри, давайте я немножко поменяю.
[52:13.440 --> 52:21.120]  Напишу, как я привык. Давайте считать, что вот это на самом деле поля у какой-то структуры,
[52:21.120 --> 52:27.600]  то есть у меня есть структ ноде, структуры вершинки, и в каждой вершинке хранится длина link,
[52:27.600 --> 52:37.400]  tu и там еще что-то, если нужно. А все вершинки я буду хранить в векторе. Вектор t будет хранить
[52:37.400 --> 52:44.520]  все вершинки. И изначально там лежит, значит изначально где-то в main я добавлю туда корень,
[52:44.520 --> 53:01.040]  который отвечает просто пустой вершине, стартовой вершинке pushback node. Вот так. То есть изначально
[53:01.040 --> 53:05.520]  в автомате просто лежит одна вершина, которая ничему не соответствует. Теперь добавление символа,
[53:05.520 --> 53:14.400]  add c. Сначала нужно завести новую вершинку, новое состояние, и добавить ее в конец нашего
[53:14.400 --> 53:25.680]  нашего списка. Я сделаю t pushback ноде, добавляю туда свежую вершинку, и создаю новую переменную
[53:25.680 --> 53:30.880]  cur для удобства, которая будет как раз на нее показывать. То есть переменная, которая равна номеру
[53:30.880 --> 53:41.920]  этой вершинки. Ну вот так, например. Это просто номер той вершины, которую мы только что добавили.
[53:41.920 --> 53:55.000]  Дальше p равно last и делаем вот тот самый цикл в поисках первого ребра, исходящего по букве c.
[53:55.000 --> 54:16.240]  Пока p не равно минус 1, и t, p, tu, c не равно тоже минус 1. То есть пока из состояния с
[54:16.240 --> 54:36.040]  номером p есть переход по букве c, я его направляю в cur. tp.tu.c равно cur. Это символ,
[54:36.040 --> 54:46.240]  который мы добавляем к нашей строке s. И переходим к сусылке. p равно t, p, link. Так,
[54:46.240 --> 54:54.700]  первый вал закончился. Мы провели все ребра. Это начало первого случая. Мы проводим все ребра,
[54:54.700 --> 55:14.020]  которые ведут в наше новое состояние cur, в которое соответствует sc. Что дальше? Дальше,
[55:14.020 --> 55:20.060]  первый случай. Если мы дошли до корня, то есть если в конце этого вала p стало равно минус 1,
[55:20.060 --> 55:24.460]  то есть я дошел до корня, и даже из корня не было перехода по c, то я опять сделал сусылку,
[55:24.460 --> 55:32.200]  перешел как бы в неволидный минус 1. В случае p равно минус 1. Тогда мы помним,
[55:32.200 --> 55:43.340]  что нужно сделать. Нужно сказать, что сусылка для cur – это просто корень. t, cur, link равно 0.
[55:43.340 --> 55:55.420]  0 – это вот та самая корневая стартовая вершинка. Это соответствует случаю, когда c впервые вообще в
[55:55.420 --> 55:59.020]  строке появляется. То есть раньше буквы c нигде не было, а теперь это ее первое хождение. Тогда
[55:59.020 --> 56:03.460]  сусылка от вот этого суффикса должна вести в пустую строчку. Ну и в самом конце не забываем
[56:03.460 --> 56:10.140]  сделать last равно cur и return. Я до удобства пишу вот так. То есть этот первый случай целиком
[56:10.140 --> 56:16.300]  закончен, из функции можно выйти и сказать, что теперь last – это cur. Напомню, last – это вот тот
[56:16.300 --> 56:21.220]  самый указатель на последнюю вершинку. Раньше он соответствовал sке, теперь он будет соответствовать
[56:21.220 --> 56:29.860]  sc. Вот как раз last равно cur нужно не забыть сделать. Это первый случай был. Теперь второй случай,
[56:29.860 --> 56:35.180]  когда это не выполняется. То есть мы дошли до вершинки, из которой есть переход по p. Тогда давайте
[56:35.180 --> 56:40.620]  скажем, что это переход, sorry, есть переход по c, извините. Мы дошли до вершинки p, из которой есть
[56:40.620 --> 56:51.180]  переход по bqc. Давайте скажем, что он ведет в cu. То есть cu равно tpt.tu.c. Ладно, наверное 25 строк
[56:51.180 --> 56:58.820]  это я погорячился, но в общем порядок правильный. Ведет в cu. Второй случай – это когда длина вот
[56:58.820 --> 57:12.700]  здесь, вот на 1 больше длина вот здесь. Пишем, если tqt.len равно tpt.len плюс 1. Это второй случай.
[57:12.700 --> 57:23.060]  Тогда, но мы тоже уже все описали, нужно сказать, что сувсылка от cur ведет в cu.
[57:23.060 --> 57:34.660]  И вроде и все. То есть мы понимаем, что ничего не расшепляется. s0 – это как раз
[57:34.660 --> 57:39.780]  longest в cu. Сувсылка – правильно. Ничего делать больше не нужно. Не забываем last равно cur и return.
[57:53.060 --> 58:07.780]  Нет, так там не минус 1. Ой, извините, здесь опечатка, здесь равенство, конечно, извините.
[58:07.780 --> 58:13.420]  Вот здесь было не равенство, здесь должно быть, конечно, равенство. То есть я так делаю, пока
[58:13.420 --> 58:18.140]  нет перехода по c. Да, извините, это я описал. Я вот это вот ребро создаю, если его не было.
[58:18.140 --> 58:23.620]  Соответственно, выход из цикла – это либо доход до несуществующей вершинки, либо до вершинки,
[58:23.620 --> 58:28.100]  из которой этот переход был. А если он был, то я говорю, что cu – это как раз то, что нужно. Да,
[58:28.100 --> 58:44.780]  спасибо. Ну, остался третий случай. Третий случай, когда все плохо. Тогда мне нужно завести новую
[58:44.780 --> 59:08.100]  вершинку clon. Создаем t pushback node. Говорим, что ее номер равен clon. Ну и дальше аккуратненько,
[59:08.100 --> 59:13.340]  давайте мы также в том же порядке. Сначала проведем ребра, которые должны вести в clon.
[59:13.340 --> 59:18.740]  Напоминаю, я стою в p, должен брать в несу ссылки, и все ребра, ведущие в clon,
[59:18.740 --> 59:29.860]  должны перенаправить в clon. Ведущие в cu должны перенаправить в clon. Пока p не минус 1 и tp,
[59:29.860 --> 59:46.020]  tp, tc равно cu. Все ребра, ведущие в cu, я должен перенаправить в clon. tp, tc равно clon. И поднимаюсь
[59:46.020 --> 59:55.100]  по су ссылке. Вроде это кусок воды у нас уже был. Все ребра, ведущие в cu, перенаправляю в clon.
[59:55.100 --> 01:00:07.860]  Это пункт A у нас был, пункт B. Нужно все ребра, ведущие из cu, перекопировать в clon. Напишу так,
[01:00:07.860 --> 01:00:21.620]  tclon.tu равно tcu.tu. Ну подразумеваю, что так можно делать. Если тут есть какой-нибудь вектор,
[01:00:21.620 --> 01:00:30.540]  да, там вектор размера sigma, тогда я могу просто скопировать все, что здесь вот сюда. Ну и третье
[01:00:30.540 --> 01:00:37.620]  это все вот эти поля link, len и так далее. Это я просто переписываю то, что уже было написано.
[01:00:37.620 --> 01:00:49.340]  Значит tclon len равно, так, ну давайте я это напишу, но это будет неверно, сейчас мы это исправим
[01:00:49.340 --> 01:00:57.300]  быстренько. Мы понимаем, что len от clon, len от p плюс 1, только это нужно было сделать до вот этого
[01:00:57.300 --> 01:01:02.460]  while, да, потому что в этом while мы уже взяли p и там несколько раз ее поменяли, взяли су ссылку
[01:01:02.460 --> 01:01:07.820]  многократно, поэтому p изменилась. Это будет корректно только до вот этого, до вот этого while.
[01:01:07.820 --> 01:01:19.300]  То есть это нельзя делать до присвоения len. Есть. Теперь с линками. Во-первых,
[01:01:19.300 --> 01:01:45.580]  link от clon. Это то, что изначально было в link от cu. t от cu.link это clon и t от cur.link это тоже clon.
[01:01:49.300 --> 01:02:00.780]  Мы тоже уже писали. Ну и чего? И вроде мы все присвоили. То есть мы присвоили len, мы присвоили
[01:02:00.780 --> 01:02:05.620]  t, мы присвоили link. И теперь для вершина cu и cur мы тоже обновили линки. Все, больше делать
[01:02:05.620 --> 01:02:12.940]  ничего не нужно. Не забываем еще в конце написать last равно cur. Last равно cur, потому что мы завершили
[01:02:12.940 --> 01:02:26.540]  наш третий случай. Вот вроде все. Вот только эту одну достаточно. То есть можно и все,
[01:02:26.540 --> 01:02:50.380]  но достаточно одну. Вопросы? Кажется, мы написали все. 35 строчек у меня получилось.
[01:02:50.380 --> 01:03:07.140]  Так, хорошо. Если нет вопросов, тогда давайте мы завяжем со строками. Но на чуть-чуть.
[01:03:07.140 --> 01:03:23.580]  Так, вообще наша цель следующая. Мы хотим решить такую задачу. Все,
[01:03:23.580 --> 01:03:29.820]  мы с автомат закончили, забываем про него. Мы хотим решить такую задачу. Есть шаблон p и
[01:03:29.820 --> 01:03:41.540]  текст t. Нам нужно узнать, сколько раз шаблон входит в текст t, если можно ошибаться максимум k раз.
[01:03:41.540 --> 01:03:48.660]  То есть мы пытаемся приложить p везде, где только можно. И если число ошибок не больше чем k,
[01:03:48.660 --> 01:03:53.220]  число несовпадений не больше чем k, где k какая-то константа данная, то мы говорим,
[01:03:53.220 --> 01:03:58.260]  что вот он здесь входит, но там неточное вхождение имеет. То есть вхождение с максимум k ошибками.
[01:03:58.260 --> 01:04:16.820]  Значит, нужно найти все неточные вхождения с не большим k ошибками. Да, они могут идти где угодно.
[01:04:16.820 --> 01:04:24.940]  И причем эти позиции, где возникают ошибки, могут тоже как угодно меняться. То есть тут может быть
[01:04:24.940 --> 01:04:31.260]  три ошибки, тут может быть две, тут может быть тоже три, но в других позициях где угодно. И нужно
[01:04:31.260 --> 01:04:39.740]  найти все такие вхождения с максимум k ошибками. Для этого нам нужно будет научиться быстро
[01:04:39.740 --> 01:04:45.220]  перенажать многочлены. Мы научимся это делать в один из следующих разов с помощью быстрого
[01:04:45.220 --> 01:04:52.740]  преобразования фурье. Ффт, на следующий или через раз лекции мы разберем. И с помощью этого решим
[01:04:52.740 --> 01:04:56.820]  эту задачу. То есть мы как бы все еще решаем задачу на строках, но сначала нам нужно будет
[01:04:56.820 --> 01:05:01.740]  немножко в теорию чисел погрузиться, построить алгоритм быстрого перенаживания многочленов,
[01:05:01.740 --> 01:05:07.660]  вот и сюда мы еще тоже вернемся. Это пока такой анонс того, почему мы сейчас вдруг переходим на
[01:05:07.660 --> 01:05:15.620]  теорию чисел. Вот, но сегодня уже у нас времени особо много не остается, поэтому мы разберем
[01:05:15.620 --> 01:05:28.740]  что-нибудь простое, что либо вы знаете, либо где-то слышали, либо узнаете сегодня. Так,
[01:05:28.740 --> 01:05:41.900]  давайте начнем с простого алгоритма Евклида. У меня есть ощущение, что он у вас не у всех был.
[01:05:41.900 --> 01:05:49.900]  Скажите, пожалуйста, у кого он был? Поднимите руки, пожалуйста. Черт, у всех был. Нет? Или не у всех?
[01:05:49.900 --> 01:05:57.060]  Но все равно, мне кажется, что нам это точно нужно, по крайней мере это просто. Задача такая, у вас
[01:05:57.060 --> 01:06:03.180]  есть какие-то два числа, скажем A и B, и вам нужно найти их наибольший общий делитик, то есть такое
[01:06:03.180 --> 01:06:07.100]  максимальное натуральное число, которое их обоих делит. Давайте пока что жить в парадигме, что у
[01:06:07.100 --> 01:06:18.260]  меня все числа целые, вот, и нужно найти их наибольший общий делитель. Ну что, можно легко заметить,
[01:06:18.260 --> 01:06:24.500]  что если, скажем, B больше справа, чем A, то наибольший общий делитель не поменяется, если я
[01:06:24.500 --> 01:06:34.020]  вычту из второго числа первое. Если B больше справа, чем A. Это легко доказать. Давайте докажем,
[01:06:34.460 --> 01:06:38.800]  что наибольший общий делитель не поменяется. И смотрите, если здесь был какой-то общий делитель
[01:06:38.800 --> 01:06:43.540]  D, то есть D делил и вот это, и вот это, то ясное дело, что он будет делить и вот это и вот это. То есть
[01:06:43.540 --> 01:06:47.720]  A он по-прежнему будет делить, B- un тоже будет делить, как делит разность двух чисел, делящихся на D.
[01:06:47.720 --> 01:06:54.860]  Обратно, если тут какое число G делил, и вот это, и вот это, то G также будет делить A, и будет
[01:06:54.860 --> 01:07:00.340]  делить их сумму. Будет делить Beaut B-аéléста be. Прorable если будет б. Поэтому не просто у них
[01:07:00.340 --> 01:07:02.540]  наибольший общий делитель совпадает, но просто все
[01:07:02.540 --> 01:07:05.060]  множество делителей общих совпадает, все, что делит
[01:07:05.060 --> 01:07:07.100]  это, делит это, и наоборот.
[01:07:07.100 --> 01:07:09.060]  Поэтому такой переход мне не меняет наибольшего
[01:07:09.060 --> 01:07:10.060]  общего делителя.
[01:07:10.060 --> 01:07:13.420]  Тогда алгоритм будет очень простой.
[01:07:13.420 --> 01:07:16.060]  Давайте мы делаем такое вычитание, ну или точнее
[01:07:16.060 --> 01:07:18.500]  будем брать по модулю до тех пор, пока не придем
[01:07:18.500 --> 01:07:19.500]  к чему-то очевидному.
[01:07:19.500 --> 01:07:24.660]  Вот это же утверждение можно обобщить на такое.
[01:07:24.660 --> 01:07:36.380]  То есть вместо вычитания можно взять остаток отделения
[01:07:36.380 --> 01:07:38.260]  по модулю, потому что если я просто много раз буду
[01:07:38.260 --> 01:07:40.540]  вычитать, скажем, это число очень маленькое, это число
[01:07:40.540 --> 01:07:43.620]  очень большое, то когда я буду вычитать много-много-много-много
[01:07:43.620 --> 01:07:46.900]  раз вот это число, а маленькое, то в итоге я по сути просто
[01:07:46.900 --> 01:07:50.180]  дойду до b процента, остатка определений b на а.
[01:07:50.180 --> 01:07:52.500]  Ну и тогда алгоритм будет такой, давайте я его назову
[01:07:52.500 --> 01:08:01.980]  как-нибудь int gcd, int b.
[01:08:01.980 --> 01:08:04.700]  Сначала давайте поменяем числа местами, если вот это
[01:08:04.700 --> 01:08:05.700]  мне нравится, не выполняется.
[01:08:05.700 --> 01:08:17.900]  Давайте я не буду писать std, просто пишу swap a b.
[01:08:18.900 --> 01:08:23.460]  И в конце нужно еще написать условия выхода, условия выхода
[01:08:23.460 --> 01:08:26.020]  будет такое, меняется пери a, это самый маленький звук
[01:08:26.020 --> 01:08:36.180]  чисел, если оно ноль, то я знаю, что gcd равен второму.
[01:08:36.180 --> 01:08:38.540]  Если оно ноль, то gcd равен второму, потому что gcd нуля
[01:08:38.540 --> 01:08:42.460]  и чего угодно, это то самое что угодно, потому что 0 делится
[01:08:42.460 --> 01:08:43.460]  на любое число.
[01:08:43.460 --> 01:08:46.620]  Но в конце, если это не выполнено, то нужно просто вернуть
[01:08:46.620 --> 01:09:01.980]  гcd того, что тут написано, a запятая b процента.
[01:09:01.980 --> 01:09:10.340]  Конечно, да, но я не буду гнаться за константы в большом.
[01:09:10.340 --> 01:09:12.460]  Да, можно сказать, что действительно можно сразу передавать
[01:09:12.460 --> 01:09:15.220]  сначала b процент а, а потом а, то есть я хочу сначала
[01:09:15.220 --> 01:09:17.540]  маленькое, потом большое, и я понимаю, что остаток
[01:09:17.540 --> 01:09:20.260]  предельно а всегда меньше, чем а, то есть если их поменять
[01:09:20.260 --> 01:09:22.740]  местами, то вот здесь у меня не будет слопа, можно
[01:09:22.740 --> 01:09:24.900]  так сделать, но мне лень, давайте не будем переделывать.
[01:09:24.900 --> 01:09:30.100]  Вот, значит работает это за сколько?
[01:09:30.100 --> 01:09:35.580]  Время работы.
[01:09:35.580 --> 01:09:43.260]  Время работы на самом деле будет о от логарифма b, ну
[01:09:43.740 --> 01:09:46.140]  я считаю, что b это максимальный из двух чисел, работает за
[01:09:46.140 --> 01:09:47.940]  логарифм от максимального числа.
[01:09:47.940 --> 01:10:07.420]  Так, почему это верно?
[01:10:07.420 --> 01:10:09.260]  Для того, чтобы доказать такое время работы, мне
[01:10:09.260 --> 01:10:11.860]  нужно как-то оценить, как быстро числа убывают, то
[01:10:11.860 --> 01:10:15.740]  была пара ab, станет пара a и b процента, вот вопрос,
[01:10:15.740 --> 01:10:18.420]  как быстро там уменьшается какое-нибудь число.
[01:10:18.420 --> 01:10:22.300]  Ну, давайте немножко рассмотрим случаев, значит была пара
[01:10:22.300 --> 01:10:25.740]  ab, она переходит в пару, как мы правильно заметили,
[01:10:25.740 --> 01:10:28.740]  b процента запутая a.
[01:10:28.740 --> 01:10:33.380]  Вот, в хорошем случае, если a по сравнению с b очень маленькое,
[01:10:33.380 --> 01:10:36.780]  тогда вот эта вот взятие, взятие остатка, оно уменьшит
[01:10:36.780 --> 01:10:39.540]  b существенно, да, то есть было там, не знаю, если a в 10
[01:10:39.540 --> 01:10:42.780]  раз меньше, чем b, то этот остаток, по крайней мере, в 10 раз
[01:10:42.780 --> 01:10:45.660]  меньше, чем b, то есть b сильно уменьшится.
[01:10:45.660 --> 01:10:50.100]  Давайте скажем следующее, что если a, если b больше
[01:10:50.100 --> 01:10:57.940]  сбравного, чем 2a, то, ну мы понимаем, что b процента
[01:10:57.940 --> 01:11:02.180]  меньше, чем a, меньше сбравного, чем половина b, тогда в этом
[01:11:02.180 --> 01:11:05.140]  случае у меня число b сразу уменьшится хотя бы в два
[01:11:05.140 --> 01:11:08.460]  раза, то есть было какое-то b, а поменялось на число
[01:11:08.540 --> 01:11:11.340]  меньше либо равное, чем 1 вторая b.
[01:11:11.340 --> 01:11:13.060]  Если так было бы всегда, то есть максимальное число
[01:11:13.060 --> 01:11:15.140]  всегда уменьшалось хотя бы в два раза, то понятно,
[01:11:15.140 --> 01:11:17.660]  что с этим точкой будет лог b, да, на каждом шаге делим
[01:11:17.660 --> 01:11:20.300]  максимальное число пополам, тогда в итоге, чтобы дойти
[01:11:20.300 --> 01:11:23.620]  до случая, когда одно из чисел ноль, нам достаточно
[01:11:23.620 --> 01:11:24.620]  логарифминического числа операции.
[01:11:24.620 --> 01:11:30.900]  Значит, что происходит иначе, иначе, у меня b лежит в отрезке
[01:11:30.940 --> 01:11:41.820]  от a до 2a минус 1, тогда b процента это просто b минуса.
[01:11:41.820 --> 01:11:58.780]  Так, b процента это b минуса, но на самом деле тогда выполняется
[01:11:58.860 --> 01:12:03.860]  то же самое, тогда я вычитаю из b хотя бы его половинку,
[01:12:03.860 --> 01:12:08.260]  можно писать так, что a это хотя бы половинка b, даже
[01:12:08.260 --> 01:12:13.260]  строго больше, поэтому b процента меньше либо равно,
[01:12:13.260 --> 01:12:18.580]  чем b минус половинка b, то есть даже в этом случае
[01:12:18.580 --> 01:12:23.860]  взятие остатка это вычитание a, и если a достаточно большое,
[01:12:23.860 --> 01:12:26.940]  это хотя бы половинка b, то тогда у меня этот остаток
[01:12:27.100 --> 01:12:31.100]  хотя бы в два раза меньше, чем исходная b, то есть выполняется
[01:12:31.100 --> 01:12:34.100]  на самом деле то же самое, неважно какой из двух случаев
[01:12:34.100 --> 01:12:37.100]  верен, маленькая или айли, или достаточно большой,
[01:12:37.100 --> 01:12:39.100]  у меня все равно наибольшее число уменьшится хотя бы
[01:12:39.100 --> 01:12:41.100]  в два раза, понятно?
[01:12:41.100 --> 01:12:48.100]  Ну отсюда следует требуемое, симпатотика, вот лог b,
[01:12:48.100 --> 01:12:50.100]  вот, хорошо.
[01:12:50.260 --> 01:13:12.260]  А вы про то, что здесь возможно можно писать как бы меньшую
[01:13:12.260 --> 01:13:15.260]  симптотику, что лог a, а не лог b?
[01:13:15.420 --> 01:13:21.420]  Да, да, ну можно, можно, вы правы, да, да, вы правы,
[01:13:21.420 --> 01:13:25.420]  то есть здесь можно написать там лог a плюс 1, грубо говоря,
[01:13:25.420 --> 01:13:28.420]  да, то же самое, что лог a, да, можно так, ну, опять
[01:13:28.420 --> 01:13:31.420]  же, этого хватает, все равно у нас как бы обычно, если
[01:13:31.420 --> 01:13:34.420]  мы предполагаем, что все вот эти операции типа процента,
[01:13:34.420 --> 01:13:38.420]  сравнение и так далее работают за от идицы, как мы предполагаем,
[01:13:38.420 --> 01:13:40.420]  да, работают на наших компиляторах, мы пишем такое,
[01:13:40.420 --> 01:13:43.420]  предполагаем, что это работает за от идицы, тогда в принципе
[01:13:43.580 --> 01:13:45.580]  все равно все эти числа достаточно маленькие, там помещаются
[01:13:45.580 --> 01:13:47.580]  в какой-нибудь лонг и лонг или что-нибудь такое,
[01:13:47.580 --> 01:13:49.580]  и все равно это логарифм, там не важно от чего брать,
[01:13:49.580 --> 01:13:51.580]  от максимального или минимального из двух чисел,
[01:13:51.580 --> 01:13:53.580]  все равно что-то очень маленькое.
[01:13:54.580 --> 01:13:56.580]  Ну, давайте считаю, что симпточка такая.
[01:13:58.580 --> 01:14:04.580]  Хорошо, тогда давайте еще успеем, наверное, расширенный
[01:14:04.580 --> 01:14:06.580]  алгоритм Евклида.
[01:14:13.580 --> 01:14:17.580]  Значит, это алгоритм, позволяющий сделать следующее.
[01:14:18.580 --> 01:14:22.580]  Давайте считать, что пусть наибольший общий делитель равен d,
[01:14:24.580 --> 01:14:26.580]  тогда нам нужно найти такие целые x и y,
[01:14:29.580 --> 01:14:32.580]  тогда ищем x и y, но я не пишу, что они целые, потому что
[01:14:32.580 --> 01:14:35.580]  здесь мы говорим только про целые числа,
[01:14:35.580 --> 01:14:38.580]  что линейная комбинация a и b с этими коэффициентами
[01:14:38.580 --> 01:14:41.580]  в точности равна их наибольшему общему делителю.
[01:14:43.580 --> 01:14:46.580]  То есть это так называемое линейное представление нот.
[01:14:48.580 --> 01:14:53.580]  Линейное представление наибольшего общего делителя.
[01:15:03.580 --> 01:15:04.580]  Отрицательное.
[01:15:08.580 --> 01:15:09.580]  Меньше чего?
[01:15:10.580 --> 01:15:12.580]  Нет, целое, обязательно целое, конечно целое.
[01:15:13.580 --> 01:15:15.580]  Целое, возможно отрицательное,
[01:15:15.580 --> 01:15:17.580]  но если они не целые, то это не интересно,
[01:15:17.580 --> 01:15:19.580]  можно считать, что здесь 0, а здесь d делить на b.
[01:15:20.580 --> 01:15:22.580]  Они обязательно целые, но, возможно, отрицательные,
[01:15:22.580 --> 01:15:23.580]  да, конечно.
[01:15:24.580 --> 01:15:26.580]  Вот, решение такое, смотрите,
[01:15:26.580 --> 01:15:31.580]  мы можем воспользоваться нашим вот этим алгоритмом Евклида
[01:15:33.580 --> 01:15:35.580]  и считать, что он, то есть он что делает,
[01:15:35.580 --> 01:15:38.580]  он переходит от пары a, b к паре b процента запятая a.
[01:15:39.580 --> 01:15:42.580]  Давайте считать, что рекурсивно он решил эту задачу,
[01:15:42.740 --> 01:15:43.740]  понимаешь, чтобы цена не меняется,
[01:15:43.740 --> 01:15:45.740]  вот это вот d остается тем же самым,
[01:15:45.740 --> 01:15:49.740]  но пусть наш алгоритм решил задачу для пары b процента запятая a.
[01:15:50.740 --> 01:15:52.740]  Пусть найдены,
[01:15:54.740 --> 01:15:58.740]  не знаю, там x с крышкой и y с крышкой,
[01:15:58.740 --> 01:16:00.740]  да, такие что?
[01:16:02.740 --> 01:16:05.740]  Первое число нужно x с крышкой,
[01:16:05.740 --> 01:16:07.740]  плюс второе на y с крышкой,
[01:16:07.740 --> 01:16:09.740]  равно тому же самому d.
[01:16:09.740 --> 01:16:11.740]  То есть я спустился в рекурсии для новой пары
[01:16:11.900 --> 01:16:13.900]  b процента запятая a,
[01:16:14.900 --> 01:16:16.900]  там ГЦД не изменился,
[01:16:16.900 --> 01:16:20.900]  и я считаю, что мне рекурсивно вернули нужную пару x с крышкой и y с крышкой.
[01:16:20.900 --> 01:16:23.900]  Тогда я сейчас по этой паре x с крышкой и y с крышкой
[01:16:23.900 --> 01:16:26.900]  построю исходные x и y, которые мне нужны.
[01:16:27.900 --> 01:16:29.900]  Так, ну давайте вот это вот заменим на
[01:16:30.900 --> 01:16:32.900]  следующие, на b минус
[01:16:32.900 --> 01:16:34.900]  b умножить на
[01:16:36.900 --> 01:16:39.900]  a умножить на b slash a, вот так.
[01:16:41.900 --> 01:16:43.900]  Остаток деления
[01:16:44.900 --> 01:16:47.900]  это разность b и, собственно, не полного частного,
[01:16:47.900 --> 01:16:49.900]  умноженную на делитель.
[01:16:49.900 --> 01:16:51.900]  Это вот это b процента.
[01:16:51.900 --> 01:16:53.900]  И давайте раскроем здесь все скобки.
[01:16:53.900 --> 01:16:55.900]  Тогда мне написано, что b x с крышкой
[01:16:56.900 --> 01:16:58.900]  плюс a y с крышкой
[01:16:58.900 --> 01:17:00.900]  минус
[01:17:00.900 --> 01:17:02.900]  a на b slash a
[01:17:02.900 --> 01:17:04.900]  на x с крышкой
[01:17:04.900 --> 01:17:06.900]  равно d.
[01:17:06.900 --> 01:17:08.900]  Ну и тогда, если я сгруппирую слагаи,
[01:17:08.900 --> 01:17:10.900]  мы правильным образом
[01:17:11.060 --> 01:17:13.060]  сгруппируем слагаи.
[01:17:21.060 --> 01:17:23.060]  У меня получилось то, что нужно.
[01:17:23.060 --> 01:17:25.060]  Вот это x, вот это y.
[01:17:30.060 --> 01:17:32.060]  И в итоге у меня переход, вот этот переход рекурсии
[01:17:32.060 --> 01:17:33.060]  будет выполнен.
[01:17:33.060 --> 01:17:35.060]  Если я для более простой пары
[01:17:35.060 --> 01:17:37.060]  b процент a и a нашел нужный коэффициент x
[01:17:37.060 --> 01:17:39.060]  с крышкой и y с крышкой,
[01:17:39.220 --> 01:17:41.220]  а эти коэффициенты высчитываются вот так.
[01:17:41.220 --> 01:17:43.220]  То есть их нужно поменять местами.
[01:17:43.220 --> 01:17:45.220]  Из первого нужно еще вычесть
[01:17:45.220 --> 01:17:47.220]  какую-то такую подравку.
[01:17:47.220 --> 01:17:49.220]  Все.
[01:17:49.220 --> 01:17:51.220]  И здесь, собственно, это все легко
[01:17:51.220 --> 01:17:53.220]  встраивается в наш алгоритм.
[01:17:53.220 --> 01:17:55.220]  То есть теперь там можем считать, что
[01:17:55.220 --> 01:17:57.220]  gcd возвращает не число, а
[01:17:57.220 --> 01:17:59.220]  тройку x, y и d.
[01:17:59.220 --> 01:18:01.220]  И если вот здесь
[01:18:01.220 --> 01:18:03.220]  рекурсивно мне вернулась тройка,
[01:18:03.220 --> 01:18:05.220]  то мне нужно с ней проделать то преобразование.
[01:18:05.220 --> 01:18:07.220]  То есть gcd не поменяется, а первые два
[01:18:07.380 --> 01:18:09.380]  когда как-то поменяются, мне их нужно
[01:18:09.380 --> 01:18:11.380]  вернуть из рекурсии.
[01:18:11.380 --> 01:18:13.380]  Единственное, нужно еще понять, что
[01:18:13.380 --> 01:18:15.380]  происходит вот здесь. Вот когда я дошел
[01:18:15.380 --> 01:18:17.380]  до шага с нулем, ну тут все просто.
[01:18:17.380 --> 01:18:19.380]  Если у меня a равно нулю, b не равно нулю,
[01:18:19.380 --> 01:18:21.380]  то можно считать, что x равно нулю,
[01:18:21.380 --> 01:18:23.380]  y равно единице
[01:18:23.380 --> 01:18:25.380]  и gcd равно b.
[01:18:27.380 --> 01:18:29.380]  Все. Тогда выход
[01:18:29.380 --> 01:18:31.380]  из рекурсии у меня тоже корректно определен.
[01:18:31.380 --> 01:18:33.380]  То есть если одно число 0,
[01:18:33.380 --> 01:18:35.380]  второе равно b, тогда с какими
[01:18:35.540 --> 01:18:37.540]  коэффициентами их нужно взять, чтобы получить gcd.
[01:18:37.540 --> 01:18:39.540]  Ну первое можно игнорировать или там поставить
[01:18:39.540 --> 01:18:41.540]  сюда что угодно. Второй коэффициент равен единице,
[01:18:41.540 --> 01:18:43.540]  тогда как раз вот эта вот сумма
[01:18:43.540 --> 01:18:45.540]  будет равна b, что я равно
[01:18:45.540 --> 01:18:47.540]  gcd. И тогда вот так
[01:18:47.540 --> 01:18:49.540]  рекурсивно если это раскручивать по той форме,
[01:18:49.540 --> 01:18:51.540]  то у меня получится правильный набор
[01:18:51.540 --> 01:18:53.540]  правильных коэффициентов x, y.
[01:18:55.540 --> 01:18:57.540]  Вот. Ну все,
[01:18:57.540 --> 01:18:59.540]  всем коэффициентам не хочется,
[01:18:59.540 --> 01:19:01.540]  я найду правильную пару x, y,
[01:19:01.540 --> 01:19:03.540]  и все будет хорошо.
[01:19:05.540 --> 01:19:07.540]  Так.
[01:19:07.540 --> 01:19:09.540]  Давайте тогда скажем, что мы нашли
[01:19:09.540 --> 01:19:11.540]  какое-то
[01:19:13.540 --> 01:19:15.540]  какое-то решение
[01:19:15.540 --> 01:19:17.540]  x, y.
[01:19:17.540 --> 01:19:19.540]  Одно из решений.
[01:19:21.540 --> 01:19:23.540]  Одно из решений.
[01:19:23.540 --> 01:19:25.540]  Тогда
[01:19:25.540 --> 01:19:27.540]  все решения описываются следующим образом.
[01:19:27.540 --> 01:19:29.540]  Это x плюс kb
[01:19:29.540 --> 01:19:31.540]  y минус ka
[01:19:31.540 --> 01:19:33.540]  для целых а.
[01:19:33.700 --> 01:19:35.700]  Вот. Ну это тоже упражнение.
[01:19:35.700 --> 01:19:37.700]  Несложное.
[01:19:37.700 --> 01:19:39.700]  Должно быть в семинаре.
[01:19:39.700 --> 01:19:41.700]  Что если мы нашли одно решение, то все остальные
[01:19:41.700 --> 01:19:43.700]  решения описываются как добавить
[01:19:43.700 --> 01:19:45.700]  сколько-то раз b к первому коэффициенту
[01:19:45.700 --> 01:19:47.700]  и вычесть столько же раз а из второго коэффициента.
[01:19:47.700 --> 01:19:49.700]  Ну и это число раз произвольное,
[01:19:49.700 --> 01:19:51.700]  целое.
[01:19:51.700 --> 01:19:53.700]  Если вопросов нету,
[01:19:53.700 --> 01:19:55.700]  то на сегодня все. Спасибо.
[01:19:55.700 --> 01:19:57.700]  До свидания.
