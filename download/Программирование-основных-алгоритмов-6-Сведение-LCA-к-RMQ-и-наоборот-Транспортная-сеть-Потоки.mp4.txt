[00:00.000 --> 00:15.800]  Так, поехали. Лекция хронологически седьмая, идея на шестая. Так, мы сегодня закончим с
[00:15.800 --> 00:24.560]  мы говорить про ЛЦА. Это первое. Второе мы начнем, видимо, о потоке говорить. Так,
[00:24.560 --> 00:36.440]  окей. Первый раздел это вообще сведение. Потом подумаем, кого-кому сводить будем.
[00:36.440 --> 00:47.600]  Еще у нас будет сведение в обе стороны. Будем учиться зная, как решать РМК и ЛЦА и наоборот.
[00:47.600 --> 01:12.200]  Вот, окей. Так, ну давайте научимся решать ЛЦА зная РМК. Так, давайте тогда зная РМК решать
[01:12.200 --> 01:19.560]  ЛЦА. Вот, что мы хотим. Давайте рассмотрим дерево какое-нибудь произвольное. Да,
[01:19.560 --> 01:45.000]  какое-нибудь такое дерево. Вот, я пронумеровал его вершины в ходе обхода ДФС. Вот первое,
[01:45.000 --> 01:51.560]  второе, третье. Это уже посещено. Четвертое, пятое. Зачем все вверх? Шестое. Зачем все вверх? Вверх
[01:51.560 --> 02:02.200]  семь. Вверх. Понятно логика. Вот так, нам потребуется несколько массивов. Давайте взаим их как-нибудь,
[02:02.200 --> 02:16.920]  наверное. Так, окей. Вообще вот такой вот обход. Вот такой вот ДФС. Сейчас мы будем
[02:16.920 --> 02:20.720]  выписывать массив именно вершинок, которые мы прямо встречаем. Явно каждый шаг. Это
[02:20.720 --> 02:34.840]  будет называться Эллеров обход дерева или по-английски Эллер Тур 3. Эллеров обход дерева.
[02:34.840 --> 02:48.640]  Давайте выпишем массив этого обхода. Так, на первом месте единичка, потому что мы сначала
[02:48.760 --> 03:03.880]  единиц находимся. Затем двойка, тройка, двойка, четверка, пятерка, четверка,
[03:03.880 --> 03:18.880]  шестерка, снова прыгаем вверх, снова вверх, четыре, два, семь, два, один, восемь, девять, восемь, один.
[03:18.880 --> 03:28.160]  Чем этот обход хорош? Тем, что в нем под дерево и под отрезок. Доказывается непосредственно по
[03:28.160 --> 03:35.640]  лемме белых путях внезапно. То есть вы выделяете какую-то вершинку, смотрите какой-то под отрезок,
[03:35.640 --> 03:42.440]  выделяем вершинку четыре. Вот берем самое левое и самое правое вхождение четверки в этот массив.
[03:42.440 --> 03:48.480]  Вот он раз, два. Утверждается, что вот здесь вот выписан Эллеров обход под дерево четверки.
[03:48.480 --> 03:54.960]  Ну просто по лемме белых путях, когда вы входите в четверку, вас достижим по белым путям, из нее
[03:54.960 --> 04:01.360]  только вот пять и шесть, все, больше никто. Вот, к моменту, когда вы покрасили четверку в черный,
[04:01.360 --> 04:06.840]  то есть к моменту последнего вхождения, у вас уже эти должны быть покрашены, поэтому они все находятся
[04:06.840 --> 04:18.840]  внутри под отрезки. Так, дальше нам понадобится массив H. H это массив высот.
[04:18.840 --> 04:35.600]  Так, изначально у нас давайте это будет уровень 0, уровень 1, уровень 2, это уровень 3, соответственно.
[04:35.600 --> 04:57.240]  Так, 1, 2, 3, 2, 3, 2, 1, 2, 1, 0, 1, 2, 1, 0, это массив высот. Так, давайте сразу вопросом на засыпку пока,
[04:57.240 --> 05:05.800]  сколько, какой длины будет вообще массив этого Эллерового обхода, если вам дону дерево? 2e плюс 1
[05:05.800 --> 05:20.200]  или 2v минус 1? Так, окей, теперь последнее, что я хочу, это, назовем массив first, first it и давайте
[05:20.200 --> 05:32.400]  подпишем здесь. Ну, по сути, это будет равно то ину этой вершинки, то есть это будет индекс,
[05:32.400 --> 05:39.800]  когда мы впервые ее встретили в массиве Эллерового обхода. Ну, единичку мы встретили на нуле,
[05:39.800 --> 05:45.640]  понятное дело, потому что мы в ней сразу находимся. Дальше в двойку и в тройку мы прыгаем
[05:45.640 --> 06:04.480]  последовательно. А теперь в четверку, 0, 1, 2, 3, 4, 5, 5 получится, 0 это 1, это 2, это 3, 4,
[06:04.480 --> 06:30.880]  вершинки же с единички номируются. Так, шестая вершинка 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14.
[06:30.880 --> 06:45.680]  Вот такие вот у нас индексы получились. А что теперь? Ну, не знаю, я привык его first обозначать
[06:45.680 --> 06:52.560]  в этом контексте, что это как бы первое вхождение в наш массив. Ну, таин это как бы время входа,
[06:52.560 --> 07:00.920]  а здесь у вас именно в массив первое вхождение. Вот это такое. Филистическое просто. Ну,
[07:00.920 --> 07:06.520]  теперь давайте пробулируем утверждение, что ли, которое вроде очевидно плюс-минус.
[07:06.520 --> 07:27.560]  Чему равно са-ту-ве? Это будет... ух, сейчас. Не совсем. Это будет... ну, давайте будем писать,
[07:27.560 --> 07:51.480]  да. РМК на отрезке по И лежащем. First от У, first от В. От чего? От аш-итых. Это получу минимум
[07:51.480 --> 08:01.280]  высоты. Теперь я хочу взять ее индекс. Давайте Арк РМК напишем. То есть он возвращает там индекс,
[08:01.280 --> 08:10.880]  где достигалось значение минимума. И возьму от этого еще всего вот эту штуку. Получу ответ.
[08:10.880 --> 08:24.520]  По такой формуле можно ЛЦА посчитать. Давайте разбирать эту формулу по частям. Так, УВ берется
[08:24.520 --> 08:33.040]  first от У и first от В. Почему это так? Потому что ЛЦА предположим, что мы У посетили первее,
[08:33.040 --> 08:36.800]  чем В. Просто для определенности, что у нас этот отрезок существовал,
[08:36.800 --> 08:46.400]  значит он просто у ИВ свапник. Вот так. Если мы сначала постили У, потом постили В, то очевидно,
[08:46.400 --> 08:51.760]  что мы должны были... когда мы вышли из У, мы сначала прошли через ЛЦА, потом через В. Иначе
[08:51.760 --> 09:11.480]  просто быть не могло. То есть DFS, который айлеров, посещает первым действием вершина У,
[09:11.480 --> 09:30.720]  вторым действием ЛЦА от УВ, и третья вершина В. Поэтому ЛЦА находится где-то на подотреске,
[09:30.720 --> 09:36.360]  с одной стороны. С другой стороны, ЛЦА должна обладать минимум глубины на этом подотреске.
[09:36.360 --> 09:49.280]  Почему это так? Потому что выше вы не будете выпрыгивать просто в ходе DFS. А ниже не будет
[09:49.280 --> 09:54.200]  ЛЦА, потому что вершина есть под деревьях. Здесь надо просто аккуратно посмотреть глазами,
[09:54.200 --> 10:00.800]  понять, что это очевидно. Но раз мы знаем тогда индекс, где достигается минимум по высоте,
[10:00.800 --> 10:09.440]  мы можем взять краски-вершинку, которая в нужном нам месте находится. Ну все, что тогда мы можем
[10:09.440 --> 10:18.560]  делать? Как решать задачу ЛЦА? Давайте выпишем вот эти вот массивы, три штуки. Построим по
[10:19.560 --> 10:39.000]  массиве H разреженную таблицу. Зен Луген. Предподсчет. Ответ на запрос, за сколько разреженная таблица
[10:39.000 --> 10:49.680]  он даст? За единицу, да. Индекс минимума тоже он может дать, если вы будете его явно сохранять в
[10:49.680 --> 11:01.880]  ответе. Вот, поэтому это за единицу, это за единицу. То есть ответ. Вот единица. Окей.
[11:01.880 --> 11:12.200]  Плюс-минус то, что требовалось сделать задачи G в контесте. Ну есть те, кто читерски загнал,
[11:12.200 --> 11:21.800]  поэтому ее надо будет отправить на ревью и забанить всем. Вот. РМК это минимум, а ARC это где
[11:21.800 --> 11:31.760]  у тебя достигается минимум? В нашем случае это индекс минимума. Так, окей. Что теперь хотим? Долго.
[11:31.760 --> 11:40.480]  Давайте ускорять. Сейчас мы будем 30 минут ускорять вот эту штуку до линии. Может больше. А давайте
[11:40.480 --> 11:55.200]  в обратную сторону сводить. Знаю LCA, решать RMQ. Здесь нам придется вспомнить нашу прекрасную
[11:55.200 --> 12:08.080]  конструкцию. Помните, что такое декартовый дерево? Давайте строить его. Построим декартовое дерево.
[12:08.080 --> 12:27.360]  Построим DDNK, декартовое дерево по явному ключу, где приоритеты аиты. Так, еще раз. Мы хотим
[12:27.360 --> 12:36.040]  уметь решать RMQ, уметь решать LCA. Наша задача. Если мы хотим решать RMQ, значит что у нас дано? Нам
[12:36.200 --> 12:50.720]  дано массив. И там какие-то запросы к нему. Аита это массив. Например, вот наш массив прекрасный.
[12:50.720 --> 13:01.720]  Как строилось декартовое дерево по явному ключу? Тут, понятно, какие-то элементы еще есть. Но нам
[13:02.120 --> 13:08.760]  есть приоритеты. Брался максимальный из них, тут минимальный из них и объявлялся, что он в корне
[13:08.760 --> 13:13.240]  находится. У него должен быть самый минимальный приоритет, потому что декартовое дерево по
[13:13.240 --> 13:28.000]  приоритетам это все еще куча. Давайте я еще индексами добавлю. Это будет аиты, это и. Чтобы я мог пары
[13:28.000 --> 13:38.680]  писать. То есть первая пара у меня будет это 6, 0. Тогда в ее правом по дереву все, что правее,
[13:38.760 --> 13:48.200]  а в левом все, что левее. В правом по дереву остается только пара 7, 3. А в левом по дереву
[13:48.200 --> 13:53.560]  выбирается снова минимальный чувак. Но из них там кто-то один будет корнем. Давайте этот для
[13:53.560 --> 14:06.280]  разнообразия. Мы с вами разделили массивно вот такие вот кусочки. Причем этот забрали,
[14:06.280 --> 14:12.480]  этот забрали и этот забрали. Тогда в правом по дереве этого узла находятся вот эти вот две
[14:12.480 --> 14:33.640]  штуки. Минимальный двойка здесь 2, 5. И у него левый 4, 5. Нет, я пишу слева индекс.
[14:33.640 --> 14:47.360]  Да. Спасибо. У меня слева у меня пары и аиты.
[14:47.360 --> 14:59.920]  Нет, 6, 0 нормально написано. И 7, 3 нормально написано.
[15:04.640 --> 15:14.560]  Так еще раз. Здесь будет у нас 3, 1. Здесь правее будет. Нет, будет в корне тот, у кого минимум по
[15:14.560 --> 15:28.520]  приоритету. 4, 5. А нет, мы же смотрим приоритет по значению. 5, 2. И здесь будет тогда 4, 5. Все,
[15:28.600 --> 15:42.000]  разбрались. Так, а слева остается вот эта вот штука. Здесь будет 0, 1. И у него в правом по дереве вот
[15:42.000 --> 15:55.440]  это вот. Это будет то, у нас будет стройка в корне 1, 3. И у него правый сын 2, 7. Получили вот такое
[15:55.440 --> 16:06.960]  вот дерево. Я утверждаю, что если вы возьмете две вершины И, Ж какие-то, два индекса, найдете эти
[16:06.960 --> 16:22.960]  узлы в дереве, то есть вот он 2, 7. Это И, 5, 2 это Ж. То я утверждаю, что минимум это ЛЦА. Вот ЛЦА в
[16:22.960 --> 16:34.480]  каком дереве это 3, 1. И это будет минимум на этом подотреске И, Ж. Минимум их темпоаитам, то есть вот он.
[16:34.480 --> 16:57.360]  Ну это он и есть. 3, 1. Это и ХЛЦА. То есть я утверждаю, что РМКУ от И до Ж. Ну МИН точнее можно описать.
[17:05.440 --> 17:15.960]  МИН по наотреске И, Ж и закатах. Это будет ЛЦА
[17:15.960 --> 17:36.280]  В ИТ и В Ж. То есть В ИТ и В Ж это вершинки дерева. Вершины соответствующие элементам.
[17:36.280 --> 17:47.960]  Вот мы ввели в обратную сторону. То есть умеем решать РМКУ, умеем решать ЛЦА.
[17:47.960 --> 18:02.720]  Но остался последний штрих. Это ускорить РМКУ. Так, второй шаг. РМКУ плюс-минус 1.
[18:02.720 --> 18:28.480]  Поставка такая. Пусть массивя А1, АН для любого И от 1 до N минус 1, АИ плюс 1.
[18:28.480 --> 18:38.320]  Вот такого утверждения верно. Средние элементы отличаются ровно на единицу по модулю.
[18:38.320 --> 18:50.160]  То есть не могут быть как больше единиц, так меньше на единицу. То есть, например, вот такой массив нас устраивает.
[18:50.160 --> 18:58.560]  Если бы здесь что-то поменять, то уже не будет устраивать. Вот.
[18:58.560 --> 19:06.240]  Вот я утверждаю, что на таком массиве умею решать РМКУ за линейный предпочет и за константный ответ.
[19:06.240 --> 19:14.480]  Просто это модуль заканчивается. Просто И.
[19:14.480 --> 19:28.720]  Вот. Мы сейчас покажем, как эту штуку за линию строить. Из-за единицы отвечать на запрос.
[19:28.720 --> 19:38.480]  Потом скажем, что вот у нас есть массив Высот, потом мы применим кучу сведений, все это вместе скомпонуем и получим РМКУ за ОТН на предпочет и от единицы на ответ.
[19:39.440 --> 19:47.760]  Да, план у нас страшный. Ну давайте поймем, как устроен вообще запрос РМКУ.
[19:47.760 --> 20:01.760]  Разобьем на блоке давайте длины К.
[20:01.760 --> 20:03.760]  То есть вот наш был массив.
[20:09.440 --> 20:15.440]  Ну быть может не на целом там последний блок не хватит там такая, это не очень важно.
[20:23.440 --> 20:27.440]  Вот. Давайте посмотрим, как могут быть устроены запросы.
[20:28.400 --> 20:36.400]  В первом случае запросы могут быть устроены как-то вот так вот.
[20:36.400 --> 20:46.400]  То есть они затрагивают какое-то количество блоков целиком, плюс суффикс блока, плюс префикс блока.
[20:47.360 --> 21:03.360]  Это какое-то количество целых блоков.
[21:03.360 --> 21:11.360]  Второе это суффикс блока.
[21:12.320 --> 21:16.320]  Третье это префикс блока.
[21:22.320 --> 21:28.320]  Знаете, что сейчас сделаем? Давайте научимся сначала с первой категории работать.
[21:32.320 --> 21:36.320]  Ну давайте найдем на каждом блоке минимум его позицию.
[21:36.320 --> 21:40.320]  Это в отдельном случае мы его разберем еще.
[21:41.280 --> 21:43.280]  Так.
[21:47.280 --> 21:49.280]  Да, мы ищем в самом блоке ответ.
[21:49.280 --> 21:53.280]  Посчитаем для каждого блока.
[22:03.280 --> 22:05.280]  Минимум на нем.
[22:06.240 --> 22:12.240]  Вроде нам позиция не понадобится, если понадобится, то допишем, что и позицию надо посчитать.
[22:12.240 --> 22:14.240]  Так.
[22:14.240 --> 22:18.240]  Но у нас же этих блоков может быть много подряд.
[22:18.240 --> 22:20.240]  То есть у нас может быть целый подотрезок взят.
[22:20.240 --> 22:24.240]  Значит нам нужно отвечать на подотрезки минимум.
[22:24.240 --> 22:28.240]  Раз нам нужно отвечать минимум на подотрезки, то что мы хотим?
[22:29.200 --> 22:33.200]  На них построим обычную разреженную таблицу.
[22:39.200 --> 22:41.200]  Обычную.
[22:45.200 --> 22:47.200]  Будьте здоровы.
[22:47.200 --> 22:51.200]  Так, разреженную таблицу.
[22:52.160 --> 22:58.160]  Пока что будем писать в терминах k симптотики, потом подберем оптимальное k, чтобы все сошлось.
[23:00.160 --> 23:02.160]  Сколько у нас блоков?
[23:02.160 --> 23:04.160]  n делить на k.
[23:04.160 --> 23:10.160]  По строению у нас отнимается вот столько вот тогда.
[23:14.160 --> 23:16.160]  Окей.
[23:17.120 --> 23:21.120]  Нет, вы нашли в каждом блоке минимум.
[23:21.120 --> 23:25.120]  То есть вы знаете, что минимум где-то тут здесь, например.
[23:25.120 --> 23:27.120]  Здесь тут здесь где-нибудь.
[23:27.120 --> 23:29.120]  Здесь вот здесь.
[23:29.120 --> 23:33.120]  Потом вы взяли эти минимумы и на них построили разреженную таблицу.
[23:33.120 --> 23:37.120]  Потому что нам нужно отвечать на подотрезок блоков.
[23:37.120 --> 23:41.120]  Так, что второе, как со вторым и третьим?
[23:42.080 --> 23:44.080]  Давайте напишем, что 4 здесь еще будет.
[23:44.080 --> 23:46.080]  Это подотрезок блока.
[23:52.080 --> 23:58.080]  Подотрезок блока у вас затрагивается, когда у вас запрос целиком внутри одного блока.
[23:58.080 --> 24:00.080]  Понятно, да?
[24:00.080 --> 24:02.080]  Определение.
[24:04.080 --> 24:06.080]  Блок.
[24:07.040 --> 24:09.040]  АИТ и АИ плюс карты.
[24:09.040 --> 24:11.040]  Это нормализованный?
[24:19.040 --> 24:21.040]  Если
[24:23.040 --> 24:25.040]  АИТ равен нулю.
[24:29.040 --> 24:31.040]  Если
[24:33.040 --> 24:35.040]  АИТ равен нулю.
[24:37.040 --> 24:39.040]  В чем прикол?
[24:39.040 --> 24:41.040]  Нормализованных блоков.
[24:43.040 --> 24:45.040]  Прикол у них очень простой.
[24:45.040 --> 24:47.040]  Их не очень много.
[24:47.040 --> 24:49.040]  Нормализованных блоков.
[24:59.040 --> 25:01.040]  2 степени К-1.
[25:01.040 --> 25:03.040]  Это очевидно или надо пояснить почему?
[25:04.000 --> 25:06.000]  Ну, смотрите.
[25:06.000 --> 25:08.000]  У вас каждый блок, раз все начинается с нуля,
[25:08.000 --> 25:10.000]  он имеет вот такой вот вид.
[25:14.000 --> 25:16.000]  Тогда можно выписать плюс один, плюс один,
[25:16.000 --> 25:18.000]  минус один, минус один,
[25:18.000 --> 25:20.000]  минус один.
[25:20.000 --> 25:22.000]  Массив последовательных разностей.
[25:22.000 --> 25:24.000]  При этом они принимают лишь одно из двух значений.
[25:24.000 --> 25:26.000]  Либо один, либо плюс один, либо минус один.
[25:26.000 --> 25:28.000]  Давайте закодируем просто двичную записью,
[25:28.000 --> 25:30.000]  а разность у вас на минус один.
[25:30.960 --> 25:32.960]  Нет, вообще вот посчитать многообразие.
[25:36.960 --> 25:38.960]  Я покажу, что мне даже с такой лихвой хватит.
[25:38.960 --> 25:40.960]  Я уложусь в линию.
[25:40.960 --> 25:42.960]  Вот как бы плюс-минус один это вообще не считает.
[25:44.960 --> 25:46.960]  Давайте я посчитаю просто.
[25:46.960 --> 25:48.960]  Посчитаем на каждом
[25:50.960 --> 25:52.960]  каждом подотрезке
[25:52.960 --> 25:54.960]  каждом подотрезке
[25:54.960 --> 25:56.960]  каждом подотрезке
[25:56.960 --> 25:58.960]  каждом подотрезке
[25:59.920 --> 26:01.920]  каждом подотрезке
[26:05.920 --> 26:07.920]  каждого блока
[26:11.920 --> 26:13.920]  минимум
[26:17.920 --> 26:19.920]  за от К квадрат
[26:19.920 --> 26:21.920]  на два степняка минус один.
[26:21.920 --> 26:23.920]  Ну красота, да?
[26:23.920 --> 26:25.920]  Не, нормально, мы сейчас подгоним К, чтобы сошлось все.
[26:25.920 --> 26:27.920]  Вы согласны, что если я знаю
[26:27.920 --> 26:29.920]  минимум и его позицию?
[26:31.920 --> 26:33.920]  Вот как раз-таки знаю
[26:33.920 --> 26:35.920]  для каждого блока
[26:35.920 --> 26:37.920]  вот там вот нарисованных
[26:37.920 --> 26:39.920]  к какому классу он относится
[26:39.920 --> 26:41.920]  то есть вот эту кодировку
[26:41.920 --> 26:43.920]  плюс-минус один, я могу четко
[26:43.920 --> 26:45.920]  получить позицию его минимума.
[26:47.920 --> 26:49.920]  А вот позиция минимума не зависит
[26:49.920 --> 26:51.920]  от того, нормализовали ли мы блок,
[26:51.920 --> 26:53.920]  то есть приводили ли мы аи-т
[26:53.920 --> 26:55.920]  или нет.
[26:57.920 --> 26:59.920]  Вроде очевидная идея.
[27:01.920 --> 27:03.920]  Что мы делаем?
[27:03.920 --> 27:05.920]  Вот мы взяли блоки, мы для каждого из них
[27:05.920 --> 27:07.920]  посчитали плюс-минус один, соседняя разность.
[27:09.920 --> 27:11.920]  Мы для всех возможных блоков
[27:11.920 --> 27:13.920]  посчитали позицию минимума,
[27:13.920 --> 27:15.920]  потом взяли какой-то блок,
[27:15.920 --> 27:17.920]  вычисли из него аи-ты,
[27:17.920 --> 27:19.920]  чтобы нормализовать его,
[27:19.920 --> 27:21.920]  чтобы аи-ты оказался равной нулю, то есть блок из массива.
[27:21.920 --> 27:23.920]  Потом такие ага,
[27:23.920 --> 27:25.920]  мы знаем для него ответ
[27:25.920 --> 27:27.920]  на подотрезке, на префиксе
[27:27.920 --> 27:29.920]  или на суффиксе, где именно лежит минимум.
[27:29.920 --> 27:31.920]  Мы знаем позицию.
[27:31.920 --> 27:33.920]  Ну все, тогда я знаю ответ
[27:33.920 --> 27:35.920]  для конкретной этой части.
[27:35.920 --> 27:37.920]  То есть если я опять же разбиваю
[27:37.920 --> 27:39.920]  этот массив на подзапросы,
[27:39.920 --> 27:41.920]  то я умел вот это
[27:41.920 --> 27:43.920]  вот делать, это наша первая
[27:43.920 --> 27:45.920]  часть была.
[27:45.920 --> 27:47.920]  Теперь мы научились
[27:47.920 --> 27:49.920]  вот так вот отвечать на вот этих
[27:49.920 --> 27:51.920]  вот двух частях.
[27:51.920 --> 27:53.920]  Опять же,
[27:53.920 --> 27:55.920]  это мы научились делать за О от единицы,
[27:55.920 --> 27:57.920]  потому что мы просто все предпочитали.
[27:57.920 --> 27:59.920]  А вот на подотрезках у нас
[27:59.920 --> 28:01.920]  разрезанная таблица за О от единицы
[28:01.920 --> 28:03.920]  отвечает, да?
[28:07.920 --> 28:09.920]  Кого?
[28:09.920 --> 28:11.920]  Да.
[28:11.920 --> 28:13.920]  Потом я еще заранее
[28:13.920 --> 28:15.920]  за линию посчитал, для каждого блока
[28:15.920 --> 28:17.920]  к кому класса он относится.
[28:17.920 --> 28:19.920]  Ну вот мы посчитали
[28:19.920 --> 28:21.920]  для того блока,
[28:21.920 --> 28:23.920]  что у него минимум за краем ответа.
[28:25.920 --> 28:27.920]  Нет, я для каждого подотрезка блока
[28:27.920 --> 28:29.920]  знаю ответ.
[28:29.920 --> 28:31.920]  У меня же там как квадрат умножается еще.
[28:33.920 --> 28:35.920]  Ну что, коллеги, осталось совсем немножко.
[28:37.920 --> 28:39.920]  Согласно тогда, что имея всю эту информацию
[28:39.920 --> 28:41.920]  из О от единицы, у меня получает ответ
[28:41.920 --> 28:43.920]  на произвольный запрос.
[28:43.920 --> 28:45.920]  Но осталось это в линию превратить.
[28:45.920 --> 28:47.920]  А давайте
[28:47.920 --> 28:49.920]  Итого.
[28:49.920 --> 28:51.920]  Я получаю
[28:51.920 --> 28:53.920]  от
[28:53.920 --> 28:55.920]  n делить на k
[28:55.920 --> 28:57.920]  log n делить на k
[28:57.920 --> 28:59.920]  плюс k квадрат
[28:59.920 --> 29:01.920]  на 2 в кат и минус 1.
[29:03.920 --> 29:05.920]  Теперь самая тонкая
[29:05.920 --> 29:07.920]  хитрость, так сказать.
[29:15.920 --> 29:17.920]  Возьмем вот такое k.
[29:19.920 --> 29:21.920]  Вот здесь очень важна одна вторая сейчас будет.
[29:21.920 --> 29:23.920]  Поймете, где она вылезет.
[29:25.920 --> 29:27.920]  Так, считаем.
[29:27.920 --> 29:29.920]  От n делить на
[29:29.920 --> 29:31.920]  1 вторую log
[29:31.920 --> 29:33.920]  двоичный n
[29:33.920 --> 29:35.920]  logarithm n делить на
[29:35.920 --> 29:37.920]  1 вторую
[29:37.920 --> 29:39.920]  log двоичный m
[29:39.920 --> 29:41.920]  плюс
[29:41.920 --> 29:43.920]  1 четвертая
[29:43.920 --> 29:45.920]  log двоичный n
[29:45.920 --> 29:47.920]  квадрат
[29:47.920 --> 29:49.920]  на 2 в степени
[29:49.920 --> 29:51.920]  1 вторая log двоичный n
[29:51.920 --> 29:53.920]  минус
[29:53.920 --> 29:55.920]  минус 1.
[29:57.920 --> 29:59.920]  Давайте упрощать.
[30:03.920 --> 30:05.920]  Так, здесь я
[30:05.920 --> 30:07.920]  позволю на одну вторую забить.
[30:07.920 --> 30:09.920]  Потому что это просто будет
[30:09.920 --> 30:11.920]  двойка вылезет в числителе.
[30:13.920 --> 30:15.920]  Так, дальше
[30:15.920 --> 30:17.920]  что я могу себе позволить сказать?
[30:17.920 --> 30:19.920]  Здесь я могу себе позволить сказать, что
[30:19.920 --> 30:21.920]  вот это вот все
[30:21.920 --> 30:23.920]  оно
[30:23.920 --> 30:25.920]  не превосходит n.
[30:25.920 --> 30:27.920]  Согласны?
[30:27.920 --> 30:29.920]  Ну, n делить на log n он как бы меньше n.
[30:29.920 --> 30:31.920]  Поэтому я здесь могу просто написать
[30:31.920 --> 30:33.920]  на log n.
[30:33.920 --> 30:35.920]  Плюс
[30:35.920 --> 30:37.920]  так, константа нас не интересует.
[30:37.920 --> 30:39.920]  Здесь константа тоже не интересует.
[30:39.920 --> 30:41.920]  Поэтому остается
[30:41.920 --> 30:43.920]  1 четвертая log квадрат m
[30:43.920 --> 30:45.920]  на 2 в степени
[30:45.920 --> 30:47.920]  1 вторая log двоичный n.
[30:51.920 --> 30:53.920]  Ну,
[30:53.920 --> 30:55.920]  здесь я должен перейти к логарифму
[30:55.920 --> 30:57.920]  по другому основанию, но это константа,
[30:57.920 --> 30:59.920]  поэтому на нее тоже забиваю.
[31:01.920 --> 31:03.920]  Теперь смотрим, что происходит здесь.
[31:03.920 --> 31:05.920]  Квадрат логарифма
[31:05.920 --> 31:07.920]  умножить на корень из m.
[31:07.920 --> 31:09.920]  Как мы с вами знаем, корень из m
[31:09.920 --> 31:11.920]  к логарифму это o от n.
[31:13.920 --> 31:15.920]  Конец.
[31:17.920 --> 31:19.920]  Все, победа.
[31:19.920 --> 31:21.920]  То есть мы просто хитро подобрали k.
[31:21.920 --> 31:23.920]  Вот здесь вот эта вот тоненькая 1 вторая,
[31:23.920 --> 31:25.920]  которая сделала вам здесь не n,
[31:25.920 --> 31:27.920]  а здесь корень она оставила.
[31:27.920 --> 31:29.920]  Так, окей.
[31:29.920 --> 31:31.920]  То есть это вот, что мы с вами научились делать.
[31:31.920 --> 31:33.920]  Мы с вами научились
[31:33.920 --> 31:35.920]  сводить lc к rmq,
[31:35.920 --> 31:37.920]  rmq к lc,
[31:37.920 --> 31:39.920]  rmq плюс минус 1.
[31:39.920 --> 31:41.920]  Но осталось последнее,
[31:41.920 --> 31:43.920]  это суметь вытереть
[31:43.920 --> 31:45.920]  третью доску,
[31:45.920 --> 31:47.920]  чтобы дописать
[31:47.920 --> 31:49.920]  окончательно то, что мы хотели,
[31:49.920 --> 31:51.920]  в чем мы добивались все это время.
[31:51.920 --> 31:53.920]  rmq
[31:53.920 --> 31:55.920]  за
[31:57.920 --> 31:59.920]  пару
[31:59.920 --> 32:01.920]  o от n, o от единицы.
[32:01.920 --> 32:03.920]  То есть
[32:03.920 --> 32:05.920]  временный предподсчет, временный запрос.
[32:07.920 --> 32:09.920]  Ну что мы с вами делаем
[32:09.920 --> 32:11.920]  первым шагом?
[32:11.920 --> 32:13.920]  Хочется свести,
[32:13.920 --> 32:15.920]  знаете,
[32:15.920 --> 32:17.920]  rmq к чему-нибудь.
[32:17.920 --> 32:19.920]  Рмq к lc сводить,
[32:19.920 --> 32:21.920]  да?
[32:21.920 --> 32:23.920]  То есть умею решать lc,
[32:23.920 --> 32:25.920]  умеем решать rmq, да?
[32:25.920 --> 32:27.920]  Помните, это вот декартовые деревья.
[32:27.920 --> 32:29.920]  То есть первый шаг.
[32:29.920 --> 32:31.920]  Сводим
[32:31.920 --> 32:33.920]  rmq
[32:33.920 --> 32:35.920]  к lc.
[32:37.920 --> 32:39.920]  Строим
[32:39.920 --> 32:41.920]  ddnk.
[32:43.920 --> 32:45.920]  Шаг второй.
[32:47.920 --> 32:49.920]  Давайте
[32:49.920 --> 32:51.920]  сведем lc к rmq
[32:51.920 --> 32:53.920]  уже этим способом.
[32:53.920 --> 32:55.920]  Потому что здесь мы ищем rmq
[32:55.920 --> 32:57.920]  на массиве h.
[32:57.920 --> 32:59.920]  То есть сводим
[33:01.920 --> 33:03.920]  lc к
[33:03.920 --> 33:05.920]  rmq
[33:05.920 --> 33:07.920]  плюс-минус один.
[33:09.920 --> 33:11.920]  Эллеров обхода
[33:11.920 --> 33:13.920]  примерно.
[33:15.920 --> 33:17.920]  Шаг третий.
[33:19.920 --> 33:21.920]  Решаем rmq
[33:21.920 --> 33:23.920]  плюс-минус один.
[33:31.920 --> 33:33.920]  А, я забыл сказать,
[33:33.920 --> 33:35.920]  этот прекрасный алгоритм
[33:35.920 --> 33:37.920]  с оценочкой по времени
[33:37.920 --> 33:39.920]  называется
[33:39.920 --> 33:41.920]  вот так вот.
[33:41.920 --> 33:43.920]  По a, по фамилиям.
[33:51.920 --> 33:53.920]  Farah Colton и Bender.
[33:53.920 --> 33:55.920]  Это два чувакатки.
[33:55.920 --> 33:57.920]  Один Farah Colton, другой Bender.
[33:59.920 --> 34:01.920]  То есть этот алгоритм, который считает блоки
[34:01.920 --> 34:03.920]  ddnk,
[34:03.920 --> 34:05.920]  на них парсы, потом
[34:05.920 --> 34:07.920]  на каждом из блоков суффиксы,
[34:07.920 --> 34:09.920]  это вот эти два чувака придумали.
[34:09.920 --> 34:11.920]  Вот. То есть как бы здесь
[34:11.920 --> 34:13.920]  теперь что мы научились с вами делать? Как отвечать на запрос?
[34:17.920 --> 34:19.920]  Вы такие, окей, ответ на запрос, тогда это просто делаем
[34:19.920 --> 34:21.920]  все то же самое.
[34:21.920 --> 34:23.920]  Нам говорят под отрезок, мы ищем нужные нам
[34:23.920 --> 34:25.920]  вершинки в lc.
[34:25.920 --> 34:27.920]  Нужные вершинки в lc мы ищем
[34:27.920 --> 34:29.920]  вот это вот схеме.
[34:29.920 --> 34:31.920]  Отвечаем с помощью
[34:31.920 --> 34:33.920]  Farah Colton и Bender на запрос.
[34:33.920 --> 34:35.920]  Дальше обратно возвращаем ответ.
[34:35.920 --> 34:37.920]  Получили ответ какой-то
[34:37.920 --> 34:39.920]  индекс.
[34:39.920 --> 34:41.920]  Индекс нам говорит вершинку, вершинка нам говорит
[34:41.920 --> 34:43.920]  собственно номер
[34:43.920 --> 34:45.920]  ответа.
[34:45.920 --> 34:47.920]  Там ничего сложного.
[34:49.920 --> 34:51.920]  Кое-то это не надо, будет сразу я вас предупреждаю.
[34:53.920 --> 34:55.920]  Это первое
[34:55.920 --> 34:57.920]  такое радостное для вас замечание. Второе радостное
[34:57.920 --> 34:59.920]  замечание то, что
[34:59.920 --> 35:01.920]  по сути дела мы все это изучали
[35:01.920 --> 35:03.920]  ради того, что можно сводить
[35:03.920 --> 35:05.920]  вот это вот сведение.
[35:07.920 --> 35:09.920]  Почему? Ну потому что
[35:09.920 --> 35:11.920]  если вы построите декартовое дерево
[35:11.920 --> 35:13.920]  по неявному ключу на массиве,
[35:13.920 --> 35:15.920]  на вот этих вот массивах,
[35:15.920 --> 35:17.920]  то в целом можно брать и что делать?
[35:17.920 --> 35:19.920]  Ну переподвешивать под деревья.
[35:19.920 --> 35:21.920]  Ну просто взять вот отрезок
[35:21.920 --> 35:23.920]  соответствующего по дереву, подвесить его к вершине
[35:23.920 --> 35:25.920]  в 8.
[35:25.920 --> 35:27.920]  И все, ничего не изменится.
[35:29.920 --> 35:31.920]  Вам все также надо будет искать минимум на отрезке,
[35:31.920 --> 35:33.920]  а декартовое дерево по неявному ключу
[35:33.920 --> 35:35.920]  позволит вам просто переставлять под отрезки, например.
[35:37.920 --> 35:39.920]  Та же задача у вас, которая последняя в контесте
[35:39.920 --> 35:41.920]  про удаление и добавление вершин,
[35:41.920 --> 35:43.920]  изначально предполагаю, что вы напишете через это.
[35:45.920 --> 35:47.920]  Но хитрые гении
[35:47.920 --> 35:49.920]  написали хитро-гениально.
[35:49.920 --> 35:51.920]  Что меня конечно разочаровало.
[35:51.920 --> 35:53.920]  В следующем году
[35:53.920 --> 35:55.920]  будет задача типа
[35:55.920 --> 35:57.920]  переподвешивать под деревья и копировать ветки.
[36:01.920 --> 36:03.920]  Зачем это вообще нужно?
[36:03.920 --> 36:05.920]  Задумайтесь.
[36:05.920 --> 36:07.920]  Есть такая классная команда Git Rebase.
[36:07.920 --> 36:09.920]  Она берет и
[36:09.920 --> 36:11.920]  переподвешивает какой-то комит к другому комиту.
[36:11.920 --> 36:13.920]  Она берет под дерево
[36:13.920 --> 36:15.920]  и переподвешивает его к другому под дереву.
[36:15.920 --> 36:17.920]  Вот если нужно это делать очень быстро,
[36:17.920 --> 36:19.920]  Git Rebase
[36:19.920 --> 36:21.920]  вообще медленная операция,
[36:21.920 --> 36:23.920]  то это можно вот так вот делать.
[36:23.920 --> 36:25.920]  Но там это
[36:25.920 --> 36:27.920]  конечно так не делается в силу других причин.
[36:27.920 --> 36:29.920]  Но
[36:29.920 --> 36:31.920]  как сам факт, это можно делать вот так вот.
[36:31.920 --> 36:33.920]  Также можно копировать ветки
[36:33.920 --> 36:35.920]  или черепикать их.
[36:35.920 --> 36:37.920]  Тоже самое будет.
[36:37.920 --> 36:39.920]  Ладно.
[36:39.920 --> 36:41.920]  В общем-то
[36:43.920 --> 36:45.920]  мы закончили
[36:45.920 --> 36:47.920]  менясто, ВЛЦА и вот эту всю лобуду.
[36:47.920 --> 36:49.920]  Наконец-то начались
[36:49.920 --> 36:51.920]  серьезные темы.
[36:51.920 --> 36:53.920]  Потому что сейчас пока что это был такой
[36:53.920 --> 36:55.920]  семестер, мы только вкатывались в темы нормальные.
[36:55.920 --> 36:57.920]  Теперь мы дошли до содержательных тем.
[36:57.920 --> 36:59.920]  Это потоки.
[36:59.920 --> 37:01.920]  Был план рассказывать
[37:01.920 --> 37:03.920]  про сочетание потоки.
[37:03.920 --> 37:05.920]  Но я посмотрел на лекции и понял, что там еще
[37:05.920 --> 37:07.920]  10 мая выпадает.
[37:07.920 --> 37:09.920]  Мне крайне не хочется 10 мая искать
[37:09.920 --> 37:11.920]  доп-лекцию.
[37:11.920 --> 37:13.920]  Потому что это будет конец семестра,
[37:13.920 --> 37:15.920]  у вас зачетная неделя, вы все будете
[37:15.920 --> 37:17.920]  заняты чем-то там.
[37:17.920 --> 37:19.920]  И устраивать вам еще время на доп-лекцию вообще не хочется.
[37:21.920 --> 37:23.920]  Поэтому было решено, что
[37:23.920 --> 37:25.920]  мы не будем рассказывать
[37:25.920 --> 37:27.920]  про сочетание на лекции,
[37:27.920 --> 37:29.920]  а они будут семинарским материалом.
[37:31.920 --> 37:33.920]  Попадет, потому что мы научимся их
[37:33.920 --> 37:35.920]  решать через потоки просто.
[37:37.920 --> 37:39.920]  Конечно.
[37:39.920 --> 37:41.920]  Нет. Не, на экзамен
[37:41.920 --> 37:43.920]  не попадет, потому что это на лекции нет.
[37:43.920 --> 37:45.920]  Это попадет
[37:45.920 --> 37:47.920]  в контесты и в семинары,
[37:47.920 --> 37:49.920]  потому что вам на семинарах расскажут
[37:49.920 --> 37:51.920]  один способ как решать, а потом расскажут,
[37:51.920 --> 37:53.920]  как через потоки это делать.
[37:53.920 --> 37:55.920]  План такой.
[37:57.920 --> 37:59.920]  В чем мотивация потоков?
[37:59.920 --> 38:01.920]  Мотивация возникла
[38:01.920 --> 38:03.920]  из того, что у вас
[38:03.920 --> 38:05.920]  графы это, конечно, круто искать в кратчайшей пути,
[38:09.920 --> 38:11.920]  но давайте нарисуем что-нибудь такое.
[38:15.920 --> 38:17.920]  Вот это сеть городов,
[38:17.920 --> 38:19.920]  карта.
[38:19.920 --> 38:21.920]  И мы знаем, что здесь
[38:21.920 --> 38:23.920]  могут проезжать 6 машин,
[38:23.920 --> 38:25.920]  в единицу времени здесь 10,
[38:25.920 --> 38:27.920]  здесь там 3,
[38:27.920 --> 38:29.920]  здесь 7, здесь 5.
[38:31.920 --> 38:33.920]  Как вопрос в том,
[38:33.920 --> 38:35.920]  сколько можно от старта до финиша
[38:35.920 --> 38:37.920]  максимально опустить машин?
[38:39.920 --> 38:41.920]  Откуда возникла эта идея?
[38:41.920 --> 38:43.920]  Идея возникает в том,
[38:43.920 --> 38:45.920]  разный грузоперевозок.
[38:47.920 --> 38:49.920]  У вас есть карта грузоперевозок
[38:49.920 --> 38:51.920]  между городами,
[38:51.920 --> 38:53.920]  вы знаете, что на каких-то маршрутах
[38:53.920 --> 38:55.920]  можете пустить не больше, чем
[38:55.920 --> 38:57.920]  определенные числа автомобилей.
[38:57.920 --> 38:59.920]  Вы хотите понять,
[38:59.920 --> 39:01.920]  какая у вас максимальная пропускная способность
[39:01.920 --> 39:03.920]  от склада до магазина?
[39:07.920 --> 39:09.920]  Не очевидно, как
[39:09.920 --> 39:11.920]  пускать поток машин.
[39:11.920 --> 39:13.920]  Да, мы считаем,
[39:13.920 --> 39:15.920]  что поток дискретный.
[39:15.920 --> 39:17.920]  Нет, не так, будем считать, что поток непрерывный
[39:17.920 --> 39:19.920]  в общем случае, однако здесь все-таки машинки
[39:19.920 --> 39:21.920]  дискретные, пускать
[39:21.920 --> 39:23.920]  одну треть машинки не очень
[39:23.920 --> 39:25.920]  интеллектуальное занятие.
[39:29.920 --> 39:31.920]  Нет, нельзя.
[39:31.920 --> 39:33.920]  А, ну можно, да, окей.
[39:33.920 --> 39:35.920]  Отлично.
[39:41.920 --> 39:43.920]  Типа вот такого вот.
[39:51.920 --> 39:53.920]  Ну не очевидно.
[39:55.920 --> 39:57.920]  Не, ну понятно, что больше 9
[39:57.920 --> 39:59.920]  не получится.
[39:59.920 --> 40:01.920]  Ну, понятно.
[40:01.920 --> 40:03.920]  Ну да, окей, хорошо.
[40:03.920 --> 40:05.920]  Ну это потому, что сети маленькие.
[40:05.920 --> 40:07.920]  Но сети там будут внезапно чуть-чуть побольше
[40:07.920 --> 40:09.920]  все-таки.
[40:11.920 --> 40:13.920]  Я не про пропускную способность.
[40:13.920 --> 40:15.920]  Нет, там будет до 100 обычно
[40:15.920 --> 40:17.920]  по вершинам ребер.
[40:17.920 --> 40:19.920]  Потому что у нас сейчас будут алгоритмы за М в четвертый.
[40:19.920 --> 40:21.920]  Там ВЕ квадрат
[40:21.920 --> 40:23.920]  алгоритмы сейчас пойдут.
[40:25.920 --> 40:27.920]  Да, действительно, тут люди борются уже 50
[40:27.920 --> 40:29.920]  лет и не эффективно.
[40:29.920 --> 40:31.920]  Так, определение.
[40:33.920 --> 40:35.920]  Транспортная сеть
[40:35.920 --> 40:37.920]  или просто
[40:37.920 --> 40:39.920]  сеть.
[40:41.920 --> 40:43.920]  Назовем.
[40:45.920 --> 40:47.920]  Да, здесь я буду очень
[40:47.920 --> 40:49.920]  формален во всех
[40:49.920 --> 40:51.920]  формулировках и так далее.
[40:51.920 --> 40:53.920]  Потому что это все-таки нам придется понимать.
[40:53.920 --> 40:55.920]  Назовем N.
[40:55.920 --> 40:57.920]  Такая классная буква N.
[40:57.920 --> 40:59.920]  Красивая. От слова network.
[40:59.920 --> 41:01.920]  Сеть.
[41:01.920 --> 41:03.920]  Ух, так сейчас она будет
[41:03.920 --> 41:05.920]  иметь вот такой вот вид.
[41:05.920 --> 41:07.920]  G равный VE
[41:09.920 --> 41:11.920]  C, S, T.
[41:11.920 --> 41:13.920]  Четверка будет такая.
[41:13.920 --> 41:15.920]  Где
[41:19.920 --> 41:21.920]  S и T
[41:21.920 --> 41:23.920]  лежат V
[41:23.920 --> 41:25.920]  это
[41:25.920 --> 41:27.920]  и сток
[41:27.920 --> 41:29.920]  и сток
[41:29.920 --> 41:31.920]  соответственно.
[41:39.920 --> 41:41.920]  То есть это две вершинки.
[41:41.920 --> 41:43.920]  G
[41:43.920 --> 41:45.920]  это ориентированный граф.
[41:47.920 --> 41:49.920]  Такой, что
[41:53.920 --> 41:55.920]  давайте, ориентированный граф
[41:55.920 --> 41:57.920]  без антипараллельных
[41:57.920 --> 41:59.920]  ребер. Что это такое? Поясню чуть дальше.
[42:01.920 --> 42:03.920]  Без антипараллельных
[42:03.920 --> 42:05.920]  ребер.
[42:07.920 --> 42:09.920]  Так, G определение,
[42:09.920 --> 42:11.920]  с T определение осталось
[42:11.920 --> 42:13.920]  C определить. C
[42:13.920 --> 42:15.920]  это функция,
[42:15.920 --> 42:17.920]  которая действует
[42:17.920 --> 42:19.920]  из
[42:19.920 --> 42:21.920]  V на V.
[42:23.920 --> 42:25.920]  В общем, в случае R
[42:25.920 --> 42:27.920]  плюс.
[42:31.920 --> 42:33.920]  При этом
[42:39.920 --> 42:41.920]  для любой пары
[42:41.920 --> 42:43.920]  U, V
[42:43.920 --> 42:45.920]  не из E.
[42:45.920 --> 42:47.920]  C от U, V
[42:47.920 --> 42:49.920]  равна 0.
[42:51.920 --> 42:53.920]  То есть мы полагаем, что у нас нельзя пропускать
[42:53.920 --> 42:55.920]  поток через ребер, которых нет.
[42:55.920 --> 42:57.920]  Так, вроде бы
[42:57.920 --> 42:59.920]  все написали. Не понятно только,
[42:59.920 --> 43:01.920]  что такое антипараллельные ребра.
[43:03.920 --> 43:05.920]  Определение
[43:05.920 --> 43:07.920]  пара
[43:07.920 --> 43:09.920]  ребер
[43:11.920 --> 43:13.920]  U, V и
[43:13.920 --> 43:15.920]  VU
[43:15.920 --> 43:17.920]  называется антипараллельный.
[43:23.920 --> 43:25.920]  Антипараллельный.
[43:27.920 --> 43:29.920]  Да.
[43:29.920 --> 43:31.920]  Потому что у нас G это
[43:31.920 --> 43:33.920]  Orgraph. И нам
[43:33.920 --> 43:35.920]  будет очень неприятно, если у нас будут
[43:35.920 --> 43:37.920]  вот такие вот ситуации.
[43:37.920 --> 43:39.920]  Алгоритмически оно будет разрешимо
[43:39.920 --> 43:41.920]  на раз-два.
[43:41.920 --> 43:43.920]  Но с точки зрения теории, лучше от этого избавиться.
[43:43.920 --> 43:45.920]  Просто нам будет проще
[43:45.920 --> 43:47.920]  некоторые там вещи доказывать.
[43:47.920 --> 43:49.920]  И в целом понимать, как жизнь устроена.
[43:49.920 --> 43:51.920]  Давайте определим поток.
[43:51.920 --> 43:53.920]  Так, определение.
[43:53.920 --> 43:55.920]  Поток
[43:55.920 --> 43:57.920]  5n
[43:59.920 --> 44:01.920]  это
[44:01.920 --> 44:03.920]  такая
[44:03.920 --> 44:05.920]  функция
[44:05.920 --> 44:07.920]  F
[44:07.920 --> 44:09.920]  из V на V
[44:09.920 --> 44:11.920]  в R плюс.
[44:11.920 --> 44:13.920]  Что?
[44:13.920 --> 44:15.920]  Сохранены два свойства.
[44:15.920 --> 44:17.920]  Точнее, она будет называть двум свойствам.
[44:17.920 --> 44:19.920]  Первое
[44:19.920 --> 44:21.920]  сейчас, сейчас,
[44:21.920 --> 44:23.920]  так. Первое свойство
[44:23.920 --> 44:25.920]  то для любой
[44:25.920 --> 44:27.920]  U, V
[44:29.920 --> 44:31.920]  ну, давайте даже не так.
[44:31.920 --> 44:33.920]  Для любых
[44:33.920 --> 44:35.920]  U, V из V
[44:35.920 --> 44:37.920]  F от U, V
[44:37.920 --> 44:39.920]  не превосходит C от
[44:39.920 --> 44:41.920]  V.
[44:41.920 --> 44:43.920]  То есть нельзя пропустить
[44:43.920 --> 44:45.920]  больше, чем вмещается в ребро.
[44:51.920 --> 44:53.920]  Потому что мы C определили
[44:53.920 --> 44:55.920]  на V, F.
[44:55.920 --> 44:57.920]  Можно писать на E.
[44:57.920 --> 44:59.920]  Непринципиально. То есть тогда
[44:59.920 --> 45:01.920]  вы должны определить, что у вас поток
[45:01.920 --> 45:03.920]  не через ребра, не может проходить.
[45:03.920 --> 45:05.920]  И там, что профессиональной способности это ноль.
[45:05.920 --> 45:07.920]  Нам это будет важно
[45:07.920 --> 45:09.920]  потом, потому что у нас возникнут
[45:09.920 --> 45:11.920]  новые ребра.
[45:11.920 --> 45:13.920]  Которые уже не из E, они будут
[45:13.920 --> 45:15.920]  краски обратно ребрам из E.
[45:15.920 --> 45:17.920]  Поэтому проще писать из V квадрат.
[45:19.920 --> 45:21.920]  И второе свойство
[45:21.920 --> 45:23.920]  сейчас, так. Здесь будет
[45:23.920 --> 45:25.920]  интеллектуальнее.
[45:29.920 --> 45:31.920]  Для любой вершинки V, которая
[45:31.920 --> 45:33.920]  не сток и не исток
[45:33.920 --> 45:35.920]  сумма по
[45:35.920 --> 45:37.920]  U, V
[45:41.920 --> 45:43.920]  лежащим
[45:43.920 --> 45:45.920]  давайте даже не так. Зачем?
[45:45.920 --> 45:47.920]  Можно написать круче.
[45:47.920 --> 45:49.920]  Для любой U из V
[45:49.920 --> 45:51.920]  сумма
[45:51.920 --> 45:53.920]  F от U, V
[45:53.920 --> 45:55.920]  равна
[45:55.920 --> 45:57.920]  сумме
[45:57.920 --> 45:59.920]  снова для любой U из V
[45:59.920 --> 46:01.920]  равна
[46:01.920 --> 46:03.920]  сумме F от U.
[46:03.920 --> 46:05.920]  Вот так вот.
[46:09.920 --> 46:11.920]  То есть, как это понимать?
[46:11.920 --> 46:13.920]  Рассматриваются
[46:13.920 --> 46:15.920]  все вершинки U и ребра U, V.
[46:15.920 --> 46:17.920]  То есть вот эта вот часть
[46:17.920 --> 46:19.920]  это у вас есть вершинка V
[46:19.920 --> 46:21.920]  и рассматриваются все ребра
[46:21.920 --> 46:23.920]  в нее.
[46:23.920 --> 46:25.920]  Это вершинки U.
[46:25.920 --> 46:27.920]  Тогда как эта часть
[46:27.920 --> 46:29.920]  этой краски рассматривается
[46:29.920 --> 46:31.920]  V
[46:31.920 --> 46:33.920]  и из нее все возможные
[46:33.920 --> 46:35.920]  ребра U.
[46:35.920 --> 46:37.920]  То есть это значит
[46:37.920 --> 46:39.920]  сколько потока в вершину втекло,
[46:39.920 --> 46:41.920]  а это сколько потока из вершины
[46:41.920 --> 46:43.920]  вытекло.
[46:43.920 --> 46:45.920]  Фичку знаете?
[46:47.920 --> 46:49.920]  Первый закон Киргофа.
[46:49.920 --> 46:51.920]  То есть вот что такое поток.
[46:51.920 --> 46:53.920]  Это такая функция, которая
[46:53.920 --> 46:55.920]  краски удовлетворяет нашим вот этим аксемам.
[46:55.920 --> 46:57.920]  В частности, когда мы тут писали какие-то машинки
[46:57.920 --> 46:59.920]  это мы пускаем поток.
[47:01.920 --> 47:03.920]  Что будет если пустить целую одну машинку?
[47:05.920 --> 47:07.920]  Ну вот, мы будем писать,
[47:07.920 --> 47:09.920]  что мы пустили, справа у нас будет
[47:09.920 --> 47:11.920]  вместимость ребра, слева у нас будет
[47:11.920 --> 47:13.920]  сколько поток пустили.
[47:13.920 --> 47:15.920]  Это значит, что одна машинка, раз она сюда
[47:15.920 --> 47:17.920]  приехала, она должна куда-то вытечь.
[47:17.920 --> 47:19.920]  Допустим, сюда.
[47:21.920 --> 47:23.920]  Она должна снова куда-то вытечь.
[47:23.920 --> 47:25.920]  Вот, один из пяти.
[47:25.920 --> 47:27.920]  Один из пяти.
[47:27.920 --> 47:29.920]  Вот так вот.
[47:29.920 --> 47:31.920]  Так.
[47:33.920 --> 47:35.920]  Теперь нужно определить еще
[47:35.920 --> 47:37.920]  одну штуку.
[47:37.920 --> 47:39.920]  Что такое величина потока?
[47:43.920 --> 47:45.920]  Величина потока.
[47:47.920 --> 47:49.920]  Моду Лев.
[47:49.920 --> 47:51.920]  Я не буду томить вас
[47:51.920 --> 47:53.920]  с ожиданием.
[47:53.920 --> 47:55.920]  Вот такая вот конструкция.
[47:57.920 --> 47:59.920]  То есть, это сколько у вас из вершины
[47:59.920 --> 48:01.920]  С вытекает из стартовой?
[48:01.920 --> 48:03.920]  Это сколько в нее втекает?
[48:07.920 --> 48:09.920]  Странно, зачем втекать в стартовую вершину, да?
[48:11.920 --> 48:13.920]  Ну, пример такой.
[48:13.920 --> 48:15.920]  Ну, пример такой.
[48:25.920 --> 48:27.920]  Вот у меня такая классная сеть.
[48:27.920 --> 48:29.920]  Это мне никто не запрещает
[48:29.920 --> 48:31.920]  делать.
[48:33.920 --> 48:35.920]  Ну, могу добавить промежуточную
[48:35.920 --> 48:37.920]  вершину, не особо важно.
[48:39.920 --> 48:41.920]  Нет, почему?
[48:43.920 --> 48:45.920]  Ну, это вот такая вот ситуация,
[48:45.920 --> 48:47.920]  когда у вас есть ребра из УВ и ВВ.
[48:49.920 --> 48:51.920]  Вот, и здесь я везде построил
[48:51.920 --> 48:53.920]  capacity3.
[48:53.920 --> 48:55.920]  Да, пробушная способность называется capacity
[48:55.920 --> 48:57.920]  по-английски, по этому букву АС.
[49:07.920 --> 49:09.920]  Ну, это запрещено?
[49:09.920 --> 49:11.920]  Да.
[49:11.920 --> 49:13.920]  Ну, поэтому я вынужден
[49:13.920 --> 49:15.920]  вводить эту штуку.
[49:17.920 --> 49:19.920]  Я ограничен, так сказать,
[49:19.920 --> 49:21.920]  средствами своего времени.
[49:21.920 --> 49:23.920]  И своих же рассуждений.
[49:25.920 --> 49:27.920]  То есть, мне никто не мешает пустить
[49:27.920 --> 49:29.920]  поток величины 3 по этому циклу.
[49:29.920 --> 49:31.920]  Тогда суммарно величина потока 0
[49:31.920 --> 49:33.920]  все еще будет, потому что до T никто
[49:33.920 --> 49:35.920]  не добирается. Абсолютно аналогично.
[49:37.920 --> 49:39.920]  Не, ладно, по T
[49:39.920 --> 49:41.920]  и по T по циклу пускать это что-то очень
[49:41.920 --> 49:43.920]  странное.
[49:43.920 --> 49:45.920]  Это слишком странно.
[49:45.920 --> 49:47.920]  Конечно, можно определить, но
[49:47.920 --> 49:49.920]  там вроде как все согласовано будет.
[49:51.920 --> 49:53.920]  Ну, не знаю, короче, так совсем не делается.
[49:53.920 --> 49:55.920]  Вот из старта можно пускать по циклу спокойно.
[49:55.920 --> 49:57.920]  Так, давайте теперь разберемся.
[49:57.920 --> 49:59.920]  А, ну вот, собственно, в чем
[49:59.920 --> 50:01.920]  наша задача теперь будет состоять?
[50:01.920 --> 50:03.920]  Мы будем учиться эту лекцию, следующую
[50:03.920 --> 50:05.920]  и после следующую.
[50:05.920 --> 50:07.920]  После, после следующую уже скорее всего
[50:07.920 --> 50:09.920]  нет.
[50:09.920 --> 50:11.920]  По заданной сети искать максимальный
[50:11.920 --> 50:13.920]  поток. То есть, поток максимальной
[50:13.920 --> 50:15.920]  величины.
[50:15.920 --> 50:17.920]  А, давайте сформулируем, как избавляться
[50:17.920 --> 50:19.920]  от антипараллельных ребер
[50:19.920 --> 50:21.920]  и как работать с
[50:21.920 --> 50:23.920]  множественными источниками.
[50:27.920 --> 50:29.920]  Так, как избавиться от антипараллельных
[50:29.920 --> 50:31.920]  ребер?
[50:31.920 --> 50:33.920]  Допустим, у вас сети, где действительно есть такая
[50:33.920 --> 50:35.920]  и такая штука.
[50:35.920 --> 50:37.920]  Так, давайте это будет
[50:37.920 --> 50:39.920]  3, а это 5.
[50:43.920 --> 50:45.920]  Такую конструкцию просто
[50:45.920 --> 50:47.920]  превращаем
[50:47.920 --> 50:49.920]  розчерком пера.
[50:49.920 --> 50:51.920]  Вот такую вот.
[50:55.920 --> 50:57.920]  Почему это корректно?
[50:57.920 --> 50:59.920]  Потому что, если мне
[50:59.920 --> 51:01.920]  уже раздваивать вершину, надо ставить бесконечность,
[51:01.920 --> 51:03.920]  потому что я хочу сквозь нее сколько угодно
[51:03.920 --> 51:05.920]  поток пускать.
[51:09.920 --> 51:11.920]  Ну, или можно это скопировать,
[51:11.920 --> 51:13.920]  да.
[51:13.920 --> 51:15.920]  Прям в том, что у вас на одной вершине может быть много
[51:15.920 --> 51:17.920]  завязанных таких.
[51:17.920 --> 51:19.920]  То есть, у вас может быть еще здесь.
[51:19.920 --> 51:21.920]  Такая
[51:21.920 --> 51:23.920]  конструкция.
[51:27.920 --> 51:29.920]  Потому что это будет неправильно.
[51:29.920 --> 51:31.920]  Потом будет понятно, почему.
[51:33.920 --> 51:35.920]  Может быть.
[51:41.920 --> 51:43.920]  Может быть.
[51:43.920 --> 51:45.920]  Мне выгоднее для корректности написать бесконечность просто.
[51:45.920 --> 51:47.920]  Это, смотрите,
[51:47.920 --> 51:49.920]  можно оптимизировать, но здесь
[51:49.920 --> 51:51.920]  оптимизация на уровне нуля.
[51:51.920 --> 51:53.920]  Теоретического
[51:53.920 --> 51:55.920]  выгоды гораздо больше, потому что
[51:55.920 --> 51:57.920]  с этим проще жить, чем доказывать,
[51:57.920 --> 51:59.920]  что это корректно и писать какое-то число.
[51:59.920 --> 52:01.920]  Бесконечность гораздо корректнее, гораздо проще
[52:01.920 --> 52:03.920]  читать корректность.
[52:03.920 --> 52:05.920]  Так, окей, допустим, мой смысл задачи
[52:05.920 --> 52:07.920]  в том, что у меня есть несколько из токов.
[52:09.920 --> 52:11.920]  Есть несколько
[52:11.920 --> 52:13.920]  токов.
[52:21.920 --> 52:23.920]  Ну, блин, ладно, не, плохая
[52:23.920 --> 52:25.920]  картинка получилась, слишком большая.
[52:25.920 --> 52:27.920]  Широкая. Давайте
[52:27.920 --> 52:29.920]  ее нарисую поуже чуть-чуть.
[52:29.920 --> 52:31.920]  Вот здесь моя сеть находится какая-то.
[52:39.920 --> 52:41.920]  Вот такая вот у нас ситуация.
[52:43.920 --> 52:45.920]  Вот как мне действовать?
[52:49.920 --> 52:51.920]  Ну, допустим, я не знаю, у меня есть несколько
[52:51.920 --> 52:53.920]  автопарков, откуда я могу машинки пускать,
[52:53.920 --> 52:55.920]  несколько складов, несколько
[52:55.920 --> 52:57.920]  приемных пунктов.
[52:57.920 --> 52:59.920]  Мне в целом не очень важно, сколько
[52:59.920 --> 53:01.920]  попадет, мне главное знать, сколько я могу
[53:01.920 --> 53:03.920]  максимально увести со складов.
[53:05.920 --> 53:07.920]  Ну да, это все превращается
[53:07.920 --> 53:09.920]  опять же в розчерк ампера,
[53:09.920 --> 53:11.920]  делается супер исток,
[53:13.920 --> 53:15.920]  в который проводятся ребра бесконечной пропускной
[53:15.920 --> 53:17.920]  способности.
[53:27.920 --> 53:29.920]  Теперь это входит в сеть.
[53:31.920 --> 53:33.920]  Здесь будет t1,
[53:33.920 --> 53:35.920]  здесь будет tm.
[53:37.920 --> 53:39.920]  Здесь опять же ребра бесконечной
[53:39.920 --> 53:41.920]  пропускной способности
[53:41.920 --> 53:43.920]  к суперстоку
[53:43.920 --> 53:45.920]  t.
[53:47.920 --> 53:49.920]  Ну, легко показать, что любой поток, который
[53:49.920 --> 53:51.920]  вы провели здесь, может проведен бы здесь
[53:51.920 --> 53:53.920]  и наоборот.
[53:53.920 --> 53:55.920]  Здесь как бы легко построить биекцию,
[53:55.920 --> 53:57.920]  поэтому это корректные сведения.
[54:03.920 --> 54:05.920]  А сколько вы хотите?
[54:05.920 --> 54:07.920]  Нет, ноль не хочу,
[54:07.920 --> 54:09.920]  потому что если у меня здесь ноль, то я ничего
[54:09.920 --> 54:11.920]  из t1 не выпущу.
[54:11.920 --> 54:13.920]  Я хочу уметь выпускать все, что дошло до
[54:13.920 --> 54:15.920]  сюда, а дойти
[54:15.920 --> 54:17.920]  могло у меня очень-очень много, я не знаю
[54:17.920 --> 54:19.920]  сколько, но бесконечность точно
[54:19.920 --> 54:21.920]  хватит.
[54:21.920 --> 54:23.920]  Сейчас.
[54:27.920 --> 54:29.920]  Да, давайте даже это в определении
[54:29.920 --> 54:31.920]  наверное запишу, что я с неравнотою.
[54:37.920 --> 54:39.920]  Ну, тогда вы можете пускать
[54:39.920 --> 54:41.920]  сколько угодно из себя в себя потока.
[54:41.920 --> 54:43.920]  Ну, тогда ничего вам не мешает
[54:43.920 --> 54:45.920]  пускать по циклу длины ноль потока, я не знаю.
[54:45.920 --> 54:47.920]  Ну, да.
[54:47.920 --> 54:49.920]  Ну, окей, да.
[54:49.920 --> 54:51.920]  Вы можете разбить его фиктивно,
[54:51.920 --> 54:53.920]  просто на две вершины явно разбить,
[54:53.920 --> 54:55.920]  если очень хочется.
[54:55.920 --> 54:57.920]  Если у вас ССТ равны, то
[54:57.920 --> 54:59.920]  наверное вы делаете что-то не так,
[54:59.920 --> 55:01.920]  потому что можно и ничего не делать.
[55:01.920 --> 55:03.920]  Но если вам зачем-то хотелось погонять машины
[55:03.920 --> 55:05.920]  из гаража в гараж,
[55:05.920 --> 55:07.920]  то ну,
[55:07.920 --> 55:09.920]  представьте, что это два разных гаража.
[55:09.920 --> 55:11.920]  Вот, ну не знаю.
[55:11.920 --> 55:13.920]  Таким приколам я еще не сталкивался.
[55:15.920 --> 55:17.920]  Так, ну вроде бы мы это
[55:17.920 --> 55:19.920]  осветили.
[55:19.920 --> 55:21.920]  У нас остается
[55:21.920 --> 55:23.920]  7 минут.
[55:23.920 --> 55:25.920]  Ладно, давайте следующую часть
[55:25.920 --> 55:27.920]  наверное в следующий раз начнем.
[55:27.920 --> 55:29.920]  Потому что здесь
[55:29.920 --> 55:31.920]  если формулы,
[55:31.920 --> 55:33.920]  потому что там следующая часть,
[55:33.920 --> 55:35.920]  это если говоришь А, говори B, C и D.
[55:35.920 --> 55:37.920]  А если говоришь А, говори B, C и D.
[55:37.920 --> 55:39.920]  Примерно такая.
[55:39.920 --> 55:41.920]  Вот, окей, на следующей лекции
[55:41.920 --> 55:43.920]  тогда мы научимся
[55:43.920 --> 55:45.920]  скорее всего уже искать максимальный поток
[55:45.920 --> 55:47.920]  и быть может
[55:47.920 --> 55:49.920]  научимся это делать
[55:49.920 --> 55:51.920]  плюс-минус быстро.
[55:51.920 --> 55:53.920]  Где VE квадрат
[55:53.920 --> 55:55.920]  это будет очень быстро
[55:55.920 --> 55:57.920]  для нас на этот момент.
[55:57.920 --> 55:59.920]  Ну тогда все на этом
[55:59.920 --> 56:01.920]  в принципе на сегодня.
