[00:00.000 --> 00:16.280]  Да. Параграмм 10.2. Значит, напоминаю, мы закончили в прошлый раз на том, что реализовали move
[00:16.280 --> 00:22.600]  конструктор и move оператор присваивания для строк. Напоминаю еще более общую картину. У нас
[00:22.600 --> 00:40.200]  у нас есть несколько проблем. У нас было несколько проблем, ради которых мы ввели волшебную функцию move,
[00:40.200 --> 00:45.040]  которая каким-то чудом вместо того, чтобы копировать объект, умеет его перемещать. Ну,
[00:45.040 --> 00:55.000]  вызов этой функции приводит к тому, что чудо какое-то происходит, и объект перемещается,
[00:55.000 --> 01:00.600]  чтобы это не значило. Дальше мы ничего не поняли о том, как она работает. Вот,
[01:00.600 --> 01:09.120]  сейчас давайте я допишу, значит, что мы тут делаем. String copy равно std move от str,
[01:09.120 --> 01:29.200]  дальше swap с этой копией и return this. Вот, проверьте быстренько, все ли я правильно воспроизвел. Вроде
[01:29.200 --> 01:34.760]  все правильно. Вот, пояснять я сейчас не буду, что здесь написано, потому что мы на этом закончили в
[01:34.760 --> 01:42.960]  прошлый раз. Значит, мы сказали дальше, что чтобы эта магия работала для своих типов, нужно для
[01:42.960 --> 01:49.800]  них поддержать особые методы. Значит, особые методы – это move конструктор и move оператор
[01:49.800 --> 01:56.200]  присваивания. Move конструктор – это штука, которая вызывается, когда вы пишете string a равно std move
[01:56.200 --> 02:01.880]  от другой строки, а move оператор присваивания – это когда вы делаете присваивание a равно std move
[02:01.880 --> 02:14.200]  от другой строки. Вот. Здесь у нас есть вот такой моментик, непонятно, что это такое. Но утверждается,
[02:14.200 --> 02:23.680]  что если закрыть на это глаза и воспринимать это как еще одно волшебное заклинание, пока непонятно,
[02:24.160 --> 02:29.320]  что все будет нормально происходить. Вот это непонятно. Нам пока непонятно, что это такое,
[02:29.320 --> 02:34.840]  и непонятно, что вот это такое. Но это какие-то заклинания, которые работают, и не трогай,
[02:34.840 --> 02:41.920]  что называется. Ну, это тип, да. Ну, что это за тип такой? Понятно, что это тип, так называется. Но
[02:41.920 --> 02:51.440]  откуда берется этот тип и что он означает? Непонятно. Вот. Ну, да, по всей видимости, да,
[02:51.440 --> 02:56.080]  потому что это как бы из вот написанного. Можно догадаться, что, наверное, после std move
[02:56.080 --> 03:02.440]  получается такой тип. Вот. Ну ладно. Короче, вот если так написать, то будет работать. Теперь,
[03:02.440 --> 03:13.720]  прежде чем копать глубже и, значит, переходить на уровень средней школы, ну, то есть, прежде
[03:13.720 --> 03:18.040]  чем начать разбираться в том, что это такое, значит, наша сегодняшняя цель – понять,
[03:18.040 --> 03:23.720]  что это за тип формально и что он умеет, откуда он берется, а также понять, что делает std move
[03:23.720 --> 03:29.600]  на самом деле. Вот. План на сегодня, ну, на пару, на вот эту примерно такой. Вот если мы за сегодня
[03:29.600 --> 03:35.560]  успеем, каждый из вас успеет понять досконально, что это за тип, а также что реально делает move,
[03:35.560 --> 03:46.840]  это будет победа. Маленькая победа. За пару… два урока. 45-минутных, в смысле. За одну пару,
[03:46.840 --> 04:01.160]  да. А потом придет Федя и будет рассказывать вам про вывод типов. Так. Какой Федя? Какой Федя
[04:01.160 --> 04:11.200]  было лучше? Да что такое этот ваш Федя? Так, господа, прежде чем начать разбираться в том,
[04:11.200 --> 04:16.080]  как это работает, нужно вот еще что сказать. Вот это, ну, это я уже говорил, это называется
[04:16.080 --> 04:22.400]  move constructor, это называется move assignment operator. А что было бы, если бы я не написал, не вообще вот,
[04:22.400 --> 04:27.280]  ну, стринг бы реализовал как раньше и пользовался бы функцией std move для своего стринга? Что бы
[04:27.280 --> 04:32.400]  тогда было? Тогда бы все работало как раньше, а именно было бы все время копирование вместо
[04:32.400 --> 04:38.320]  move'а. Значит, первое, что надо понимать, если вы для своего класса реализовали copy constructor и
[04:38.320 --> 04:44.480]  copy assignment operator, но ничего даже не сказали про вот эти два, то для вашего класса операция move
[04:44.480 --> 04:51.480]  будет работать как копирование. То есть, если у вас в классе нету вот этих методов, то вместо них
[04:51.480 --> 04:55.520]  будут соответствующие копирующие вызываться. Это значит, что ваш класс просто не поддерживает
[04:55.520 --> 05:00.280]  move семантику. Но это для обратной совместимости сделано, потому что все это, вы же понимаете,
[05:00.280 --> 05:08.400]  что это все начиная с C++11. Вообще, на самом деле, так интересно прям вот наблюдать такую вот смену
[05:08.400 --> 05:13.400]  поколений. Я себя чувствую таким стариком, когда рассказываю вот про это, потому что 11 год, как раз
[05:13.400 --> 05:20.160]  когда я поступил на первый курс, и когда я поступил на первый курс, у нас препод, он был одним из немногих
[05:20.160 --> 05:24.640]  людей в России, кто в этом разбирался, он работал в Яндексе и делал там доклад типа, это вообще
[05:24.640 --> 05:29.880]  ноу-хау, вот смотрите, как теперь можно делать. И он пришел и нам про это стал рассказывать, мы ничего
[05:29.880 --> 05:35.880]  не поняли вообще. Вот, но он рассказывал, что это вообще так круто, так круто, так круто, вот смотрите,
[05:35.880 --> 05:42.080]  как клево. Мы сидели такие, что ты несешь, вообще какая move семантика, господи, что они там выдумывали
[05:42.080 --> 05:50.000]  в этом C++. Вот, а сейчас это база, то есть это все знают. Ну то есть, сейчас это реально вот прошло,
[05:50.000 --> 05:57.320]  ну сколько прошло, 12, ну 11 лет, считайте, прошло полных, и с тех пор это реально такая штука,
[05:57.320 --> 06:01.360]  которую на всех собесах спрашивают, типа это обязательно знать надо, иначе какой вы C++
[06:01.360 --> 06:11.480]  разработчик. То есть, прям вот, понимаете, насколько мир меняется быстро. Поступил бы я на год раньше,
[06:11.480 --> 06:16.840]  чем, да, так до этого бы вообще еще не было. Ну тогда это обсуждали, ну как мы сейчас говорим,
[06:16.840 --> 06:23.960]  вот там C++ 23, им добавят такую-то штуку flat map, и она, наверное, будет так круто работать,
[06:23.960 --> 06:28.280]  но пока никто ничего о ней не знает, и вот только там какие-то люди на конференциях докладывают
[06:28.280 --> 06:33.880]  что-то про нее. Вот, вот тогда это была move семантика, вот примерно в таком статусе. Так вот,
[06:33.880 --> 06:40.360]  если вы не определили свою классу move операции, то они будут работать как копирующие операции,
[06:40.360 --> 06:45.560]  но тут есть сложные условия, ну я уж не буду ради этого открывать cpp-reference, но вы сами откроете,
[06:45.680 --> 06:54.600]  а есть, вот раньше было правило трех, а теперь будет правило пяти. Вот раньше было rule of three,
[06:54.600 --> 07:01.640]  теперь будет rule of five. Да, значит, что, а, это было сделано для обратной совместимости, почему? Ну
[07:01.640 --> 07:06.920]  потому что, если вы человек, который ничего не знает о move семантике, то вы можете писать как
[07:06.920 --> 07:14.400]  раньше, и оно будет работать как раньше. Вот как это, принцип такой, не сломай. Вот, то есть,
[07:14.400 --> 07:19.680]  вы можете на c++11 писать как будто вы ничего не знаете о move семантике, и даже если люди будут
[07:19.680 --> 07:23.480]  использовать sdmove над вашими типами, они будут просто работать как раньше, будут просто копировать,
[07:23.480 --> 07:29.640]  ну как и раньше. Вот, но если вы решили использовать эту фичу и написали, то вот у вас может быть выигрыш
[07:29.640 --> 07:35.400]  эффективности. Так вот, что говорит правило пяти, начиная с c++11, оно говорит, ну то же самое,
[07:35.400 --> 07:39.360]  что и правило трех, ну можно догадаться, что оно говорит, если вы помните, что говорит правило
[07:39.360 --> 07:45.120]  трех. Правило трех, напоминаю, говорит, что если в вашем классе реализован нетривиальный копи-конструктор,
[07:45.120 --> 07:49.520]  копи-оператор присваивания или деструктор, хоть что-то одно из этого, то нужно реализовать все три.
[07:49.520 --> 07:56.640]  Что говорит правило пяти, оно говорит, если в вашем классе реализован или копи-конструктор, или копи-оператор
[07:56.640 --> 08:01.920]  присваивания, или деструктор, или move-конструктор, или move-оператор присваивания, хоть что-то одного из
[08:01.920 --> 08:08.640]  этого, то надо реализовать все пять. Ну, в крайнем случае, можно не реализовать эти два, если вам
[08:08.640 --> 08:16.920]  наплевать на производительность, но желательно реализовать все пять. Тут есть следующая, еще одна
[08:16.920 --> 08:22.640]  довольно интересная история с тем, что правило трех, как известно, не является частью прям стандарта,
[08:22.640 --> 08:26.720]  то есть это не ошибка компиляции, если вы реализовали копи-конструктор, например, но не реализовали
[08:26.720 --> 08:33.480]  копи-оператор присваивания. Вот, очевидно. На самом деле, это была большая плошность комитета, что они
[08:33.480 --> 08:39.920]  не сделали это ошибкой компиляции, они пожалели об этом спустя, ну, уже довольно скоро, потому что
[08:39.920 --> 08:45.000]  стало понятно, что это штука, которую нужно было просто добавить, ну, как в стандарт, как нельзя
[08:45.000 --> 08:51.040]  так писать и все, и люди бы не делали ошибок, и не было бы вот этих вот сообщений в октябре в чате
[08:51.040 --> 08:56.200]  первого курса каждый год. А почему у меня все упало с сегментейшн фолтом? Я что, что-то неправильно
[08:56.200 --> 09:01.600]  сделал, когда стэк писал свой? Вот, ну, примерно потому что люди написали копи-конструктор, а про
[09:01.600 --> 09:11.520]  копи-оператор присваивания забыли. А? Что? Ну, на основе люди пишут стэк до того, как проходят опы, и это
[09:11.520 --> 09:22.200]  проблема. Вот. А сейчас эту ЦЕ не могут добавить, потому что все сломается, потому что обратная
[09:22.200 --> 09:26.440]  совместимость сломается, то есть они поняли, что нужно было сделать эту ошибку компиляции, но уже не
[09:26.440 --> 09:35.360]  могут. Но в c++11 все постарались золотать дыры, как могли. Вот. Ну, ворнинг, наверное, есть, но в c++11
[09:35.360 --> 09:46.920]  сделано следующее. Если вы, во-первых, если у вас, ну, в нулевых сначала, move-конструктор и move-оператор
[09:46.920 --> 09:51.800]  присваивания умеют тоже генерироваться копилятором внезапно. То есть вообще-то я могу написать вот здесь
[09:51.800 --> 10:00.840]  равно дефолт и здесь написать равно дефолт. Вопрос. Как вы думаете, что делают move-конструктор и move-оператор
[10:00.840 --> 10:13.000]  присваивания по умолчанию сгенерированного? Нет. Да, да, да, вот. Все то же самое. Вот человек, что у полей
[10:13.000 --> 10:23.400]  вызывают. Ну, move. Да, да, вот. Все, человек правильно. Надо, вот, хороший, хороший. Мыслишь, как комитет, чтобы, чтобы... Надо
[10:23.400 --> 10:33.400]  мыслить, надо мыслить, как комитет постнартизации. Значит, что бы должен делать, что бы должен делать... Да, на вкус, как комитет пахнет, как комитет.
[10:33.400 --> 10:42.040]  Наверное, мы комитет постнартизации с вами. Что должен делать move-оператор присваивания и move-конструктор по умолчанию?
[10:42.040 --> 10:49.440]  Вызывать move у всех полей просто. Ну, то есть, если копирующий конструктор по умолчанию он просто говорит,
[10:49.440 --> 10:57.440]  вот это вот все, и на этом заканчу деятельность, как бы работал copy-конструктор, не равно default, он бы просто сделал вот это
[10:57.440 --> 11:04.320]  copy этого, это copy этого, это copy этого и пустое тело. Так? Что бы сделать... И, конечно, это неправильно бы для строк
[11:04.320 --> 11:14.840]  работало. Что сделает move-конструктор по умолчанию? Он сделает R, std-move от str R, scz, std-move от str scz, cap, std-move
[11:14.840 --> 11:21.880]  от str cap. Что сделает оператор присваивания по умолчанию? То же самое, он просто сделает каждое поле
[11:21.880 --> 11:28.320]  присваивания std-move от соответствующего поля там. Будет ли это корректно работать для строк?
[11:28.320 --> 11:37.080]  Конечно же нет, потому что от этого поля целые строки не очистятся. Тут работает следующее правило,
[11:37.080 --> 11:42.840]  то правило, которое я говорил про то, что если move-операции у типов нет, то они работают как
[11:42.840 --> 11:50.200]  копирующие. Это указатель, а это целые числа. Для них move-операция не определена. Вот это, блин,
[11:50.200 --> 11:55.240]  очень важно понятие запомнить, потому что будет половина из вас в этом ошибаться и чушь какую-то
[11:55.240 --> 12:04.120]  писать и говорить. Вот если у вас типы примитивные, целые числа, даблы, указатели, то есть не классовые,
[12:04.120 --> 12:10.160]  то для них move-ающая операция работает как копирующая. От того, что я сделал один int равно
[12:10.160 --> 12:16.880]  std-move другой int, второй int нулем не станет. Он просто скопируется, потому что для него копирование
[12:16.880 --> 12:24.760]  то же самое, что move. Поэтому для строки, для нашей move-конструктор работать будет так же,
[12:24.760 --> 12:29.240]  как по умолчанию. Он работать будет так же, как и копи-конструктор по умолчанию, то есть неправильно.
[12:29.240 --> 12:34.200]  То есть у вас будет просто два указателя на одно и то же и два одинаковых числа. То же самое с
[12:34.200 --> 12:38.760]  оператором присваивания. Во-первых, он, конечно же, не удалит старую строку, потому что никто delet
[12:38.760 --> 12:43.320]  не вызовет. Он просто сделает все поля равно std-move соответствующие поля, если равно default
[12:43.320 --> 12:52.600]  написать. Вот. Окей, значит, а для каких типов move-конструктор по умолчанию нормально будет
[12:52.600 --> 13:00.360]  работать? Ну, например, вот известных вам big integer. Вот если вы писали big integer на векторе,
[13:00.360 --> 13:07.400]  то для него move будет работать вполне корректно. Ну, правда, он у вас там не занулит поле, возможно,
[13:07.400 --> 13:14.440]  какое-то поле во втором big integer. Вот. Но если у вас big integer на векторе написан, то move для
[13:14.440 --> 13:20.320]  него корректно отработает по умолчанию. Вы можете в свой big integer написать big integer равно default и он
[13:20.320 --> 13:25.800]  будет нормально работать, потому что он просто сделает ваши поли вектор равно std-move от другого
[13:25.800 --> 13:32.280]  вектора. Но вектор-то корректно move поддерживает, поэтому это будет корректно работать. Ну,
[13:32.280 --> 13:41.460]  знак будет... Да, вот. Ну и аналогично, если у вас нету вот этих вот сишной мерзости, сишных
[13:41.460 --> 13:46.560]  поинтеров, референсов и так далее. Ну, это уже и референс, не сишная мерзость. В общем, если у вас
[13:46.560 --> 13:52.200]  нету в классе никаких сишных нискорнивых штук, а просто все поля, это другие объекты, которые move
[13:52.200 --> 13:58.840]  поддерживают, то и для вашего класса move-оператор по умолчанию будет работать правильно. Да. Отличный
[13:58.840 --> 14:03.680]  вопрос. Как это будет работать, если у вас в полях есть ссылки? Да никак, он тоже не сможет
[14:03.680 --> 14:13.720]  это сгенерировать. Здрасте. Нет, про это мы пока не будем говорить. Нет, это будет ошибка компиляции,
[14:13.720 --> 14:20.120]  я думаю. Точно так же, как... Ну, кстати, вот насчет move-конструктора я не уверен, но я думаю,
[14:20.120 --> 14:26.440]  что будет CE. Все-таки это было бы очень грустно, если там не CE. Если у вас в полях есть ссылки или
[14:26.440 --> 14:36.920]  константы или массивы, то я думаю, что это будет CE. Массивы? А, рэ? Да-да-да, сишные массивы,
[14:36.920 --> 14:44.160]  если у тебя поле, это сишный массив. Ну, массиву вообще нельзя присвоить другой массив, даже без
[14:44.160 --> 14:50.120]  move-а, а с move-ом-то и по-давно, я думаю, нельзя. Вот, короче, что-то я затрудняюсь сказать, что будет,
[14:50.120 --> 15:00.320]  если у вас в полях ссылки константны или массивы при move, я думаю, что будет CE. Вопрос, не знаю,
[15:00.320 --> 15:07.960]  это большая проблема, я не знаю как, если честно, надо думать. Ну, надо какую-то логику специальную
[15:07.960 --> 15:18.760]  пойдешь, или запрещать move-операцию просто. Я не знаю, вот что будет, если вообще, блин,
[15:18.760 --> 15:27.080]  короче, я не могу сходу ответить, я могу ответить, понимая, что такое move, вот, короче,
[15:27.080 --> 15:35.240]  мы с вами сейчас напишем код функции std move, и вы, глядя на него, можно догадаться, что будет,
[15:35.240 --> 15:40.120]  если туда подставить ссылку в тип. Ну, короче, ничего хорошего, но я не уверен, будет ли это
[15:40.120 --> 15:45.920]  ошибка компиляции, к сожалению, я что-то никогда не пробовал. Короче, очевидно, что так не надо,
[15:45.920 --> 15:54.880]  все будет плохо, но вот будет ли это прям CE-шкой, не знаю. Надеюсь, что будет. Надеюсь,
[15:54.880 --> 16:03.040]  то, что я не пострадаю, как говорится. Ладно, давайте не будем обсуждать разные варианты,
[16:03.040 --> 16:12.600]  у нас большие планы еще. Ну, короче, ничего хорошего не будет. Так вот, теперь, если,
[16:12.600 --> 16:18.520]  я могу, конечно, написать равно delete. Вот, что будет, если я напишу равно delete сюда и сюда? Ну,
[16:18.520 --> 16:23.400]  тогда понятно, тоже это вопрос, ну, это вы должны понимать, тогда это значит будет CE, такая попытка
[16:23.400 --> 16:27.640]  такое сделать. То есть, если я напишу равно delete, то это уже значит, что move будет работать не как
[16:27.640 --> 16:32.520]  копирование, а просто будет CE вызывать. Если, ну, потому что я явно запретил, если тебя move-уют,
[16:32.520 --> 16:40.880]  выдай CE. Вот, а не делай копирование. Бывают типы, у которых, наоборот, копирование запрещено,
[16:40.880 --> 16:49.720]  а move-ы не разрешено. Кто знает пример такого типа? Да, это классический пример типа, у которого
[16:49.720 --> 16:56.840]  разрешен move, но запрещено копирование. Молодец, второй пример такого типа. Ну, давайте вот это
[16:57.000 --> 17:05.760]  оставим, значит, у вас будет курс многопоточки, там вы это обсудите. Вот, да, ну, потоки, да, потоки
[17:05.760 --> 17:11.240]  исполнения запрещены к копированию, move-ы не только разрешено. Вот, ну, и у нас с вами будут еще несколько
[17:11.240 --> 17:18.680]  примеров типов, у которых копирование запрещено, move-ы не разрешено, но мы попозже их увидим. Вот,
[17:18.680 --> 17:31.280]  вот они слева направо, да. Если у вас в классе реализован хотя бы один из копий конструктора,
[17:31.280 --> 17:35.720]  копий оператора присваивания, move-конструктора и move-оператора присваивания, то компилятор уже
[17:35.720 --> 17:42.320]  не будет генерировать move-конструктор, move-оператор присваивания сам. А вот если ничего не реализовано,
[17:42.320 --> 17:47.920]  то он сгенерирует сам. То есть, если у вас класс такой, что вы не реализовали в нем никакие из этих
[17:47.920 --> 17:53.040]  пяти методов, то он сам сгенерирует вам и копи конструктор, и копи оператор
[17:53.040 --> 17:56.200]  представления, и move конструктор, и move оператор представления без вашей просьбы.
[17:56.200 --> 18:00.800]  Ну потому что если типы такие, что они тривиально, ну они стандартным образом
[18:00.800 --> 18:05.240]  копируются, стандартным образом уничтожаются, то компилятор логично думает, и в
[18:05.240 --> 18:08.920]  целом он прав, как правило, что и move'аются они тоже стандартным образом, если
[18:08.920 --> 18:12.400]  копирование на них стандартно работает, то и move не стандартно работает, но если
[18:12.400 --> 18:16.080]  вы хоть что-то из этого сами реализовали, то move оператор, move
[18:16.080 --> 18:18.720]  операции, уже компилятор не будет реализовывать, только если вы явно не попросите.
[18:18.720 --> 18:23.780]  И они будут работать как копирование, но вы можете явно попросить
[18:23.780 --> 18:26.840]  и тогда я сказал, что они будут делать, а можете написать равно delete, и
[18:26.840 --> 18:31.840]  тогда я тоже сказал, че будет. А можете определить их, в том числе можно
[18:31.840 --> 18:37.160]  написать, что они равно default, а для копирующих написать равно delete, и
[18:37.160 --> 18:42.160]  тогда их не будет. Но кажется, если вы определили move'а, то копирующие сами
[18:42.160 --> 18:49.880]  тоже не сгенерируется. Будут только мувы еще у вас. Вот, это правило 5. Ну, правило 5, это не все то,
[18:49.880 --> 18:53.720]  что я сказал. Правило 5 это, что если у вас есть хоть одна из этих 5, то нужно реализовать остальные,
[18:53.720 --> 19:03.680]  желательно. Вот, но остальные, в остальном правило действует вот так. Вот, ладно, теперь я вот это
[19:03.680 --> 19:11.520]  стираю. Мы пока решили не все наши проблемы, которые были заявлены в пункте 10.1. Тем не менее,
[19:11.520 --> 19:25.280]  мы двигаемся дальше и, конечно же, нам не терпится узнать, что же делает функция
[19:25.280 --> 19:38.720]  std move. Значит, сейчас я на доске просто напишу полную реализацию функции std move. И это частично
[19:38.720 --> 19:46.320]  прояснить дело, но появятся новые вопросы, отвечать на которые нам придется долго. Ну, то есть мы копаем
[19:46.320 --> 19:51.000]  вглубь и по мере того, как мы копаем, мы открываем, мы вроде что-то начинаем понимать, но в то же
[19:51.000 --> 20:00.360]  время у нас возникают более экзистенциальные вопросы. Вот сейчас я напишу функцию std move. И это
[20:00.360 --> 20:07.760]  абсолютно нормально, если у вас сейчас возникнет реакция, типа, что за фигня происходит. Ну,
[20:07.840 --> 20:13.600]  тем не менее, следующим пунктом мне ничего не остается, как просто привести вам std move
[20:13.600 --> 20:26.560]  и implementation. Итак, ну давайте просто представим, что мы заглянули в код функции std move. Вот что там
[20:26.560 --> 20:36.160]  будет написано. Ну, во-первых, у нее должен быть какой-то возвращаемый тип. Ну, этот тип, он
[20:36.200 --> 20:44.960]  должен быть типом того, что нам давали только с двумя амперсандами навешенными. Ну вот, вот эти
[20:44.960 --> 20:50.160]  два амперсандика, это какой-то особый вид ссылки, да, то есть вот этот вот тип string 2 амперсанда,
[20:50.160 --> 21:04.560]  он какой-то, а, ну да, я забыл, начало-то очевидное. Ссылок на ссылку не существует. Нет,
[21:04.560 --> 21:10.680]  ссылок на ссылку не существует. Запрещено стандартом. Амперсанд пишется с буквой D на
[21:10.680 --> 21:28.880]  конце. Правильно говорить амперсанд «да». Я не знаю, почему-то все каждый год говорят
[21:28.880 --> 21:33.320]  амперсанд «та», и мне каждый год людей переучивать приходится, надо говорить амперсанд «да». Я не
[21:33.320 --> 21:45.800]  знаю, почему у людей такая интуиция в этом отношении. Может мне еще и в отношении R-value
[21:45.800 --> 21:50.320]  ссылок переучиться, а то каждый год люди предполагают одно и то же и неверно, предполагают,
[21:50.320 --> 21:55.480]  может мне в какой-то году уже надо уже согласиться и сказать «да, вы правы, так и есть», типа и все. Это
[21:55.480 --> 22:06.320]  ссылка на ссылку. Ладно, начало очевидное. В принципе, начало понятное. Вот, дальше начинается
[22:06.320 --> 22:14.160]  интересное. Нам надо написать возвращаемый тип. Возвращаемый тип. Ну, если бы Федя пришел со
[22:14.160 --> 22:20.880]  своим рассказом про вывод типов попозже, я мог бы написать авто, а потом, значит, отложить этот
[22:20.880 --> 22:29.400]  вопрос, но нет, уж давайте как следует. Напишем возвращаемый тип в начале. Так вот, нам нужен тип,
[22:29.400 --> 22:42.720]  как был у Т, только с двумя амперсандами. Хотелось бы написать нечто такое. Вот, хотелось бы,
[22:42.720 --> 22:48.480]  вот если вы, вот попробуйте проследить за ходом рассуждений, особенно те, кто видео смотрит
[22:48.480 --> 22:56.880]  перед экзаменом, вам это полезно будет. Значит, вот, наверное, вам естественным желанием кажется вот
[22:56.880 --> 23:01.760]  такой тип возвращаемый написать, правильно? Ну, потому что вам нужно сделать тест двумя амперсандами,
[23:01.760 --> 23:10.880]  но это неверно по некоторым причинам, которые пока мы понять не в состоянии, а верным является
[23:10.880 --> 23:15.320]  следующее. Нам нужно сделать сначала убрать все амперсанды и только на то, что получилось,
[23:15.320 --> 23:27.880]  навесить два амперсанды. СТД remove reference Т. Нет, это бы компилировалось, но давало бы не тот тип,
[23:27.880 --> 23:32.880]  который надо. Вот, я утверждаю, что по некоторым причинам написать просто Т2 амперсанды возвращаемый
[23:32.880 --> 23:45.840]  тип. Неверно. Нет, это не ЦЕ. Нет, это не ЦЕ. Это еще некоторый тип, но это не тот тип, который нам
[23:45.840 --> 23:52.280]  нужен. Нам нужен вот такой тип. Вот именно такой тип. Значит, нам нужно, чтобы на результирующем
[23:52.280 --> 23:57.720]  типе было два амперсанды навешано, но просто навесить два амперсанды на Т неверно по причинам,
[23:57.720 --> 24:04.120]  которые я сейчас не готов объяснять. Я утверждаю, что вот так будет работать нормально. Значит,
[24:04.120 --> 24:09.400]  нам нужно снять все амперсанды, если они были, и навесить два. Вы помните, что такое
[24:09.400 --> 24:21.080]  стд remove reference Т? Все, стд remove reference Т, ну мы ее с вами реализовывали только для Т и для Т
[24:21.080 --> 24:27.960]  амперсанд. Но на самом деле стд remove reference Т, она удаляет все амперсанды с типа. Их может
[24:27.960 --> 24:32.920]  быть либо один, либо два. Три не может быть. Если вы навесите один амперсанд на два амперсанды,
[24:32.920 --> 24:40.160]  то у вас... Я сказал, что Т амперсанд и еще два амперсанды — это некоторый тип, который на
[24:40.160 --> 24:44.720]  самом деле эквилинтен типу Т просто с одним амперсандом. Есть правило сворачивания ссылок.
[24:44.720 --> 24:48.520]  Если у вас навешана ссылка на ссылку, то они по некоторым правилам преобразуются в одну или две...
[24:48.520 --> 24:55.840]  Нет, нет, нет. Не надо, пожалуйста, искать ложные аналогии. Не надо пытаться видеть аналогии там,
[24:55.840 --> 25:00.680]  где их нет. Я понимаю, что хороший математик тот, который видит аналогии между аналогиями.
[25:00.680 --> 25:24.440]  В смысле... Там есть функция addLVLUreference, addRVLUreference, но они... Короче, давайте просто вот вы поверите,
[25:24.440 --> 25:32.560]  что надо так. Все со временем образуется. Подождите. Я, значит, написал возвращаемый тип. Теперь,
[25:32.560 --> 25:40.720]  значит, функция называется move. Ну, с этим вы еще могли смириться. Ну, то есть непонятно,
[25:40.720 --> 25:44.480]  мы остается, почему нельзя написать просто Т-двойной амперсанд, а надо именно вот сначала снять,
[25:44.480 --> 25:51.280]  а потом навесить двойной амперсанд. Но то, что я напишу сейчас, совершенно оправдано вызовет
[25:51.280 --> 25:58.240]  у всех buthurt, и вы совершенно, возможно, отчаетесь, но я вас очень прошу потерпеть. Вот сейчас я
[25:58.240 --> 26:03.000]  напишу такой тип, что вы вообще перестанете понимать. Но давайте считать, что просто там тип
[26:03.000 --> 26:07.920]  какой-то, который... Мы пока не понимаем, почему он такой. Ну, вот он таким должен быть и только
[26:07.920 --> 26:12.680]  таким. Вот иначе ничего не будет работать. Просто поверьте, что вот именно такой тип мы должны
[26:12.680 --> 26:20.360]  принять. Нет, тип будет выглядеть так. Т с двумя амперсандами. Значит, мы должны принять Т с двумя
[26:20.360 --> 26:26.440]  амперсандами, а вернуть remove reference от Т с двумя амперсандами. И только так, не как иначе. Вот
[26:26.440 --> 26:37.040]  любая другая компенсация не будет правильно работать. Значит, я предупреждал, что сейчас у вас будет
[26:37.040 --> 26:49.040]  очень много вопросов, но, к сожалению, ничего не поделаешь. Нет-нет-нет-нет. Это приколы, связанные
[26:49.040 --> 26:58.240]  с некоторыми проблемами, о которых мы пока еще не успели подумать. Но пока я могу, к сожалению,
[26:58.240 --> 27:05.080]  вам сказать лишь следующее, что вот на этот тип надо просто закрыть глаза и смириться. Я никак не
[27:05.080 --> 27:10.920]  могу. Нет-нет. Я рассказываю вам в том порядке, в котором, на мой взгляд, это проще всего осознавать.
[27:10.920 --> 27:17.000]  Я не знаю другого порядка, в котором это можно рассказать, где это вызывал бы меньше бадхерта.
[27:17.000 --> 27:22.160]  Тем не менее, вот на данном этапе я вас прошу смириться с этим типом и поверить в то, что вот
[27:22.160 --> 27:27.360]  здесь просто навешивание Т с двумя амперсандами не сработало, нужно именно такое. И если вы в это
[27:27.360 --> 27:37.440]  поверили, то в принципе осталось немного. Ну здесь еще no accept. Нет-нет. А, значит,
[27:37.440 --> 27:50.480]  реализация просто в одну строчку можно в две написать, как вам удобно. Ну давайте я напишу
[27:50.480 --> 28:14.240]  в одну строчку. Ретерн, статик каст. Нет. Вот к этому вот, к СТД рему в референс Т. Я все понимаю,
[28:14.240 --> 28:36.400]  пожалуйста. Я понимаю, что… Значит, вот это вся функция с демоуф. Ну, здесь написано просто
[28:36.400 --> 28:42.160]  сделать статик каст этого Икса вот к этому типу, который нужен. И все. Больше ничего не надо делать.
[28:42.160 --> 28:50.200]  Потому что она не кидает исключений. Эта операция всегда успешна. Статик каст этот всегда отрабатывает
[28:50.200 --> 28:58.560]  успешно. Что зачем писать? No accept значит, это библиотечная функция, она не кидает исключений.
[28:58.560 --> 29:04.240]  Если мы ее вызываем из какой-то no accept функции, то это должен быть корректным. Если бы я не
[29:04.240 --> 29:09.360]  написал no accept, то это бы означало, что попытка вызвать ее из no accept функции, это вообще говоря
[29:09.360 --> 29:14.320]  опасно. Это безопасная операция с точки зрения исключений. Она не кидает исключений никогда. И
[29:14.320 --> 29:19.200]  всегда завершается успешно. Этот статик каст всегда работает корректно и возвращает нужный тип.
[29:19.200 --> 29:41.720]  Ремув референс т это то же самое, что type name std remove reference от t 2.2.type. Вот чтобы не писать
[29:41.720 --> 29:47.360]  type name blah blah blah type, мы пишем remove reference t. Все ссылки убирает? Все ссылки убирает.
[29:47.360 --> 29:55.680]  Remove reference убирает все ссылки и наверх навешивает две. Это тебе так кажется. На самом деле мы
[29:55.680 --> 30:05.960]  сделали очень многое. Был тип такой, а стал такой. Это очень большое действие, очень существенное. Вот
[30:05.960 --> 30:17.800]  вот тип здесь, к сожалению, с ним можно лишь смириться. Я говорю, что статик каст в данном
[30:17.800 --> 30:25.800]  конкретном сценарии, статик каст это просто работает как интерпрет, можно сказать. То есть
[30:25.800 --> 30:33.080]  он просто трактует x как вещь такого типа и все. По стандарту это корректная операция всегда. Вы
[30:33.080 --> 30:40.000]  можете всегда от типа x сделать каст, ну от типа t сделать каст к навешанным 2 амперсандам на t.
[30:40.000 --> 30:46.200]  Ну не к навешанным 2 амперсандам на t, а вот к такой штуковине. Я попробую все-таки дать
[30:46.200 --> 30:51.920]  некоторую интуицию, почему нельзя просто так написать. Потому что если вы навешиваете 2
[30:51.920 --> 30:58.200]  амперсанды на тип, на котором уже были амперсанды, то это работает по странным правилам. Например,
[30:58.280 --> 31:02.600]  если у вас был тип с 1 амперсандам и вы навесили 2 амперсанда, и по правилам
[31:02.600 --> 31:08.860]  преобразования ссылок это станет 1 амперсандам, а не 2. Есть следующие правила преобразования
[31:08.860 --> 31:14.520]  ссылок, которые называются «reference collapsing rules». Если у вас тип был с 1 амперсандом и вы сделали
[31:14.520 --> 31:19.720]  еще 1 амперсант на него, то будет 1 амперсант. Если 1 амперсант а вы на него сделали 2 амперсанда,
[31:19.720 --> 31:25.680]  то будет 1 амперсант. Если же 2, а вы сделали 1, то будет опять 1 амперсант. И только если вы
[31:25.680 --> 31:31.680]  сделали два амперсанды повер двух амперсандов будет два амперсандов вот из-за этих правил почему эти правила
[31:31.680 --> 31:37.840]  такие это тоже хороший вопрос но они такие вот вот если сделать другими все будет плохо но вот правила
[31:37.840 --> 31:44.000]  преобразования ссылок работают так поэтому здесь мы не можем себе позволить написать т2 амперсанды
[31:44.000 --> 31:49.160]  если бы мы написали здесь т2 амперсанды и т уже было бы с амперсандами то мы бы получили реально
[31:49.160 --> 31:54.520]  не два амперсанды в конце а нам нужно гарантированно получить ровно два амперсанды в конце потому мы
[31:54.520 --> 31:59.640]  сняли все амперсанды и навесили два на чистый т без амперсандов и получили т с двумя амперсандами
[31:59.640 --> 32:08.920]  это по стандарту всегда корректная операция любой объект типа т можно скастить такому же
[32:08.920 --> 32:16.360]  типу с двумя амперсандами и это ничего не поменяет самому подожди что подожди что
[32:16.360 --> 32:24.360]  то есть мы по сути делаем два кашля один а вот мы же понимаем т амперсанды и амперсанды
[32:24.360 --> 32:34.440]  есть то есть мы скастили я понимаю но в конструкторе ну не совсем мы не скастили здесь как раз т не обязательно
[32:34.440 --> 32:39.960]  с двумя амперсандами здесь как раз произойдет схлопывание ссылок но оно произойдет по еще
[32:39.960 --> 32:47.160]  более странным правилам забейте короче здесь будет довольно странный тип принят но тем не
[32:47.160 --> 32:55.000]  менее каким бы он ни был в конце получится т с двумя персантами короче если если вам нужно
[32:55.000 --> 33:01.240]  объяснить что делает функция move в двух словах функция move это просто каст к типу с двумя
[33:01.240 --> 33:06.680]  амперсандами все вот больше ничего и эта функция на самом деле даже не генерирует никаких
[33:06.680 --> 33:11.360]  процессорных инструкций это просто хак для компилятора эта функция в рантайме ничего не
[33:11.360 --> 33:18.280]  делает это все компайл тайм штука то есть вызов move в рантайме это 0 это вообще 0 действий это даже
[33:18.280 --> 33:31.680]  не вызов функции это функция вся суть функции move в том чтобы сказать компилятору иди не в эту
[33:31.680 --> 33:39.160]  версию а в эту по сути move можно заменить просто статик кастом к стринг двум амперсандам если вам
[33:39.160 --> 33:46.600]  надо было в той сценарии когда вы пишете когда вы пишете а равно sd move от b где b это стринг вы
[33:46.600 --> 33:51.760]  можете написать с таким же успехом а равно статик каст к стринг два амперсанда от b и это то же
[33:51.760 --> 33:55.920]  самое что сделать move но просто чтобы вот такой фигней не заниматься и не думать каждый раз
[33:55.920 --> 34:01.160]  статик ас сейчас к скольким амперсандам я делаю вы просто пишите move если хотите муфающую операцию
[34:01.160 --> 34:15.640]  к сожалению я не готов сейчас ответить на этот вопрос это это слишком сложно я пока вот пока
[34:15.640 --> 34:22.320]  вынужден просить вас игнорировать этот этот момент я боюсь что мы даже сегодня не успеем
[34:22.320 --> 34:28.800]  это разобрать в общем есть очень неприятные случаи которые к сожалению так просто не объяснить но
[34:28.800 --> 34:34.200]  вот мы сейчас еще некоторое время поговорим о проблемах сопутствующих применение функции и
[34:34.200 --> 34:40.440]  осознаем что здесь именно такой тип нужен был но я мог бы вместо я мог бы чтобы вас не пугать
[34:40.440 --> 34:45.360]  написать есть три знака вопроса сказать что мы просто не знаем какой тип сюда поставить вот
[34:45.360 --> 34:55.520]  авто бы не работала к сожалению тоже не работала бы потому что авто отбрасывает все амперсанды о чем
[34:55.520 --> 35:01.800]  вы узнаете как раз сегодня на второй паре вот авто с двумя амперсандами бы работала но только
[35:01.800 --> 35:07.480]  начинать но только начиная си плюс плюс 20 потому что это было было бы сокращена версия шаблона
[35:07.480 --> 35:12.320]  тогда нужно было бы не писать имплей тейк на и те а и тогда непонятно что было бы писать здесь ну
[35:12.320 --> 35:22.720]  короче все плохо так все я рассказал что делать муф муф это просто статик аск типу с двумя амперсандами
[35:22.720 --> 35:38.760]  нет это не мета функция это нормальная функция вот теперь мне предстоит за оставшееся время
[35:38.760 --> 35:46.640]  попытаться объяснить хоть немного что за дичь происходит и чтобы наконец объяснить что за дичь
[35:46.640 --> 35:56.920]  происходит мне нужно сделать две вещи вот видимо мы оставшуюся часть пары потратим на эти две эти
[35:56.920 --> 36:03.160]  два пункта значит сейчас нам предстоит ввести формальные понятия l-value и r-value наконец-то
[36:03.160 --> 36:08.720]  после чего нам предстоит ввести формальное понятие что такое r-value ссылка и почему она
[36:08.720 --> 36:13.040]  так называется и что с ней можно делать что с ней нельзя делать это частично прояснит ситуацию но
[36:13.040 --> 36:19.280]  не полностью вот а полностью ситуация прояснится видимо уже через неделю когда мы поймем что
[36:19.280 --> 36:26.640]  одними только r-value ссылками проблема не решается иногда нужны некоторые специальные ссылки
[36:26.640 --> 36:33.760]  которые не l-value не r-value а вот такие вот универсальные называется и вот тогда-то мы
[36:33.760 --> 36:45.160]  поймем что вот здесь именно такая ссылка и должна быть отлично все мы закончили третью
[36:45.160 --> 36:57.840]  серию я понимаю что у всех у всех сашок но если что если что если к моменту когда вы все поймете
[36:57.840 --> 37:04.920]  и при исполнении своем познании вы придумаете более удачный порядок изложения в этой теме вы
[37:04.920 --> 37:09.440]  можете мне это рассказать и я подумаю может быть он действительно более удачный потому что я
[37:09.440 --> 37:18.480]  ну вот сам я понял с четвертого раза когда мне это рассказывали и вот тот порядок изложения
[37:18.480 --> 37:23.800]  который я вам сейчас даю это вот лучшее что я мог изобрести за 4 года чтобы минимизировать
[37:23.800 --> 37:29.080]  количество возгласов что за херня в аудитории вот если вы придумаете другой порядок изложения
[37:29.080 --> 37:35.020]  в котором этот число возгласов будет меньше расскажите мне вот я стараюсь минимизировать как
[37:35.020 --> 37:58.580]  могу так вот дальше мы вводим формальное определение l value и r value и так чтобы
[37:58.580 --> 38:02.980]  разобраться в том как же работает вся эта шняга нам нужно понять а что вообще такое
[38:03.580 --> 38:09.740]  ссылки и что они умеют и почему они значит так себя ведут ну что вот эта штука с двумя
[38:09.740 --> 38:16.260]  персантами я сказал что это типа когда называется r value ссылкой на t что это за тип такой какими
[38:16.260 --> 38:20.540]  свойствами обладает чем отличается от обычных ссылок и как он себя ведет и что с ним можно
[38:20.540 --> 38:26.180]  делать что нельзя чтобы объяснить это нужно сначала все-таки окончательно решить вопрос
[38:26.180 --> 38:31.900]  что же такое r value то на самом деле потому что r value и l value и то и другое потому что все время
[38:32.300 --> 38:37.940]  мы говорили ну это такой вот ну это того чем мы нельзя присваивать ну вы же уже понимаете что
[38:37.940 --> 38:42.180]  это неправда у нас с вами уже был пример у нас было дофига примеров l value которым
[38:42.180 --> 38:46.340]  нельзя присваивать и у нас был даже пример r value зар infra у которого можно присваивать
[38:46.340 --> 38:51.000]  кто помнит пример р вл у которому можно присваивать да когда мы вектор был делаем
[38:51.000 --> 38:55.400]  квадратной скобочке получается рвл у которому можно присваивать то есть определения l value
[38:55.400 --> 38:59.900]  рв лу как то что мы можно и нельзя присваить не выдержит критики давайте введем формальное
[38:59.900 --> 39:04.900]  Формальное определение синтоксическое, как ни странно.
[39:04.900 --> 39:12.900]  Первая штука, это самое главное заблуждение, которое у всех есть относительно вот этих вот вещей.
[39:12.900 --> 39:19.900]  Я, кажется, вам это уже говорил в первом семестре, но тогда это не было настолько важно.
[39:19.900 --> 39:23.900]  Вот сейчас я просто, не знаю, нужно красным цветом написать и в рамку обвести,
[39:23.900 --> 39:29.900]  что L-value и R-value это понятие, относящееся к экспрешенам, а не к типам.
[39:29.900 --> 39:37.900]  Это некоторая очень глубокая мысль, которую вы, скорее всего, тоже не сразу осознаете.
[39:37.900 --> 39:43.900]  Не имеет смысла спрашивать про тип. Он L-value или R-value? Это бессмысленный вопрос. Нету такого.
[39:43.900 --> 39:48.900]  Типы не делятся на L-value и R-value. Выражения делятся на R-value и L-value.
[39:48.900 --> 39:52.900]  Кажется, к этому моменту курсик должен был быть уже понятно.
[39:52.900 --> 39:57.900]  Вот. Ну, вот меня спр... Ну, это становится...
[39:59.900 --> 40:04.900]  Люди очень выпадают, значит, из... Представляете, когда они видят вот эту штуку,
[40:04.900 --> 40:08.900]  стринг 2 амперсанда, это же R-value ссылка, а значит, это R-value.
[40:08.900 --> 40:14.900]  Нет, ничего не значит. Это вообще никакое не value. Сам по себе тип, это никакое не value.
[40:14.900 --> 40:20.900]  И то, что у вас есть R-value ссылка, это не значит, что она... Ну, это значит... Нет, это ничего не значит.
[40:20.900 --> 40:25.900]  И L-value ссылка не значит, что она L-value. Никакой тип не значит, что он какой-то value.
[40:25.900 --> 40:30.900]  Value имеет смысл спрашивать только про expression. Вот у вас написано это expression.
[40:30.900 --> 40:34.900]  И вот про expression в целом можно спросить, он какой value?
[40:34.900 --> 40:37.900]  Expression может состоять из разных переменных, разных типов.
[40:37.900 --> 40:40.900]  Вот смотря, что там с ними делается, будут разные value.
[40:40.900 --> 40:44.900]  Но, еще раз повторю, не имеет смысла спрашивать про тип, что он какой-то value.
[40:44.900 --> 40:49.900]  Тип это никакой не value. Так вот теперь, когда мы это осознали, я просто напишу табличку.
[40:49.900 --> 40:52.900]  Ну, на самом деле, я могу открыть ее на cp-reference.
[40:52.900 --> 40:57.900]  Вы можете открыть ее сами, но, наверное, я все-таки на доске попишу какое-то время.
[40:57.900 --> 41:00.900]  А потом, наверное, не знаю, может я ее открою.
[41:00.900 --> 41:07.900]  Значит, все expression делятся на два вида L-value и R-value.
[41:07.900 --> 41:16.900]  И сначала мы перечислим те expression, которые состоят из стандартных типов.
[41:16.900 --> 41:25.900]  Ну, то есть, для своих типов вы можете определить операции так, что у них value будут странными в результате этих операций.
[41:25.900 --> 41:28.900]  Но я сейчас напишу, как это работает для стандартных типов.
[41:28.900 --> 41:39.900]  Ну, во-первых, если у вас есть просто идентификатор, то есть, имя переменной, выражение, которое представляет себя просто имя переменной, это L-value всегда.
[41:40.900 --> 41:45.900]  Напротив, если у вас есть литерал, то это R-value всегда.
[41:45.900 --> 41:46.900]  Литерал?
[41:46.900 --> 41:48.900]  Литерал это, ну, 5.
[41:48.900 --> 41:51.900]  Вот, если у вас есть литерал, то это R-value.
[41:51.900 --> 41:55.900]  А если у вас просто выражение идентификатор, имя переменной, то это L-value.
[41:55.900 --> 41:57.900]  Неважно какой это тип.
[41:57.900 --> 42:01.900]  В двух кавычках ABC это имя переменной.
[42:01.900 --> 42:07.900]  Значит, в двух кавычках ABC это, к сожалению, L-value.
[42:07.900 --> 42:13.900]  Потому что там есть исключение из правила как раз для строковых литералов.
[42:13.900 --> 42:17.900]  И, честно говоря, я сам не знаю или не помню.
[42:19.900 --> 42:21.900]  Значит, я...
[42:24.900 --> 42:27.900]  Давайте просто считать, что любой литерал это R-value.
[42:28.900 --> 42:30.900]  А когда мы дойдем до исключения...
[42:30.900 --> 42:36.900]  Короче, вы можете считать, что любой литерал это R-value без ущерба для понимания всего оставшегося курса.
[42:36.900 --> 42:38.900]  И вообще языка C++...
[42:38.900 --> 42:40.900]  Ну, короче, я не знаю ситуации в жизни.
[42:40.900 --> 42:46.900]  Ни разу не встречал, когда знание о том, что строковый литерал это L-value, а не R-value, что-то меняло.
[42:46.900 --> 42:50.900]  Короче, просто считаем, что любой литерал это R-value пока что.
[42:50.900 --> 42:53.900]  Любой литерал это R-value. Понятненько?
[42:53.900 --> 42:55.900]  Вот.
[42:55.900 --> 42:57.900]  А любой идентификатор это L-value.
[42:57.900 --> 42:58.900]  Дальше.
[42:58.900 --> 43:00.900]  Давайте вспомним, какие мы знаем еще операции.
[43:00.900 --> 43:02.900]  Если у нас есть бинарные операции.
[43:02.900 --> 43:14.900]  Ну, например, сложение, вычитание, бинарная звездочка, бинарный слэш, бинарный процент.
[43:16.900 --> 43:18.900]  Вот такая штука.
[43:18.900 --> 43:20.900]  Вот такая штука.
[43:20.900 --> 43:22.900]  Вот такая штука.
[43:22.900 --> 43:24.900]  Вот такая штука.
[43:24.900 --> 43:26.900]  Вот такая штука.
[43:26.900 --> 43:28.900]  Вот такая штука.
[43:28.900 --> 43:30.900]  Вот такая штука.
[43:30.900 --> 43:32.900]  Это все R-value.
[43:32.900 --> 43:33.900]  Вот.
[43:33.900 --> 43:40.900]  Если у вас выражение на верхнем уровне представляет в себе результат какой-то из этих бинарных операций, то это R-value.
[43:40.900 --> 43:42.900]  Ну, только для стандартных типов.
[43:42.900 --> 43:46.900]  Для своих типов вы, конечно, можете определить операции так, что они будут странные value.
[43:46.900 --> 43:51.900]  Но это все для стандартных типов только пока что.
[43:51.900 --> 43:55.900]  А если вы делаете присваивание?
[43:57.900 --> 43:59.900]  Или составное присваивание?
[44:02.900 --> 44:07.900]  Ну, короче, вот все эти штуки это L-value.
[44:14.900 --> 44:17.900]  Это произвольные expression.
[44:17.900 --> 44:26.900]  Ну, то есть вид value выражения определяется тем, что на верхнем уровне в нем происходит.
[44:26.900 --> 44:34.900]  Ваше выражение, оно синтоксически парщится, и на верхнем уровне это результат какой-то операции над двумя под выражениями.
[44:34.900 --> 44:39.900]  И вот результат финальной операции это и определяет, какой вид value выражения в целиком.
[44:39.900 --> 44:44.900]  Вот если ваше выражение на верхнем уровне представляет в себе результат одной из этих операций, то это R-value.
[44:44.900 --> 44:47.900]  А если результат вот этих, то это L-value.
[44:47.900 --> 44:54.900]  Там A-палка равно B, A-циркумфлекс равно B, и A вот такой сдвиг.
[44:54.900 --> 44:58.900]  Да, этот знак называется циркумфлекс, если кто не знал.
[44:58.900 --> 45:16.900]  А если у вас A равно равно B, а меньше или равно B? Да, сравнение тоже R-value.
[45:16.900 --> 45:27.900]  Это отличный вопрос. Сейчас как раз мы до этого дойдем, но пока мы разберем стандартные операторы.
[45:27.900 --> 45:31.900]  Дальше. А какие у нас еще есть стандартные операторы?
[45:31.900 --> 45:33.900]  Точка.
[45:33.900 --> 45:39.900]  Ну, точка это плохой пример, слишком сложно. Давайте покажем что-нибудь простое.
[45:39.900 --> 45:44.900]  Вот давайте, да, унарный амперсант. Вот унарная звездочка это L-value.
[45:44.900 --> 45:47.900]  А унарный амперсант это R-value.
[45:47.900 --> 45:50.900]  Унарный амперсант, это указатель.
[45:50.900 --> 45:52.900]  Ну, взять адреса, да.
[45:52.900 --> 45:54.900]  А унарная звездочка это L-value.
[45:54.900 --> 46:00.900]  Ну, унарную звездочку к чему можно применять? Ее можно применять к указателям и тому, что ведет себя как указатель.
[46:00.900 --> 46:03.900]  Ну, вот результат унарной звездочки это L-value.
[46:03.900 --> 46:07.900]  А если у нас указатель на указатель, то унарная звездочка...
[46:07.900 --> 46:10.900]  Унарная звездочка это L-value, все, конец разговора.
[46:10.900 --> 46:15.900]  Ну, будет указатель, который является L-value.
[46:15.900 --> 46:22.900]  Вот. Дальше. Какие еще мы знаем стандартные операторы?
[46:23.900 --> 46:28.900]  А, инкременты. Действительно.
[46:28.900 --> 46:31.900]  Префиксный и постфиксный.
[46:31.900 --> 46:36.900]  Префиксный инкремент и декремент это L-value, постфиксный это R-value.
[46:36.900 --> 46:39.900]  Просто по определению.
[46:39.900 --> 46:42.900]  Ну, это хорошо, что для вас уже логично.
[46:42.900 --> 46:45.900]  Вот. Отлично. Ну, сейчас.
[46:45.900 --> 46:48.900]  Запятая относится к числу операторов, про которые так просто не скажешь.
[46:49.900 --> 46:52.900]  Ну, давайте перейдем к этим операторам, про остальные.
[46:52.900 --> 46:55.900]  Ну, там New и Delete, например. Это L-value или R-value?
[46:55.900 --> 46:59.900]  Ну, я не знаю даже, честно говоря.
[46:59.900 --> 47:02.900]  По-моему R-value, но я как-то не задумывался.
[47:02.900 --> 47:05.900]  Throw, да. Throw. Это R-value или R-value?
[47:05.900 --> 47:08.900]  По-моему R-value, но я тоже не уверен, если честно.
[47:08.900 --> 47:11.900]  Ну, может есть какие-то убогие случаи, в которых надо...
[47:11.900 --> 47:17.900]  Ну, то есть понятно, что для этих операторов тоже есть формальная категория значения того, чего они возвращают.
[47:17.900 --> 47:22.900]  Но это чисто техническое определение. Упоротый случай никогда это не нужен.
[47:22.900 --> 47:25.900]  Чего? Void.
[47:25.900 --> 47:29.900]  Ну, тип Void, а категория значения как-то в стандарте определена.
[47:29.900 --> 47:32.900]  То есть результат throw – это какой-то вид value.
[47:32.900 --> 47:36.900]  Но я ни одного случая в жизни не знаю, когда это требовалось бы для чего-то.
[47:36.900 --> 47:41.900]  То есть формально у него какая-то категория есть, но я не знаю вообще, для чего.
[47:41.900 --> 47:43.900]  Поэтому давайте мы это не будем обсуждать.
[47:44.900 --> 47:47.900]  Вот. Сейчас мы обсудим два наиболее интересных оператора.
[47:47.900 --> 47:49.900]  Это тернарный оператор и запятая.
[47:53.900 --> 47:55.900]  И что же мы знаем про тернарный оператор?
[47:57.900 --> 48:00.900]  А, ну прекрасно. То есть тогда вообще отлично.
[48:00.900 --> 48:13.900]  Тернарный оператор, если все, ну давайте так, если оба оператора L-value.
[48:13.900 --> 48:20.900]  То есть вид value тернарного оператора зависит от того, какие виды value у операторов.
[48:20.900 --> 48:29.900]  Если оба оператора L-value, то и результат тернарника это L-value.
[48:29.900 --> 48:36.900]  Соответственно тернарный оператор считается R-value, если хотя бы один.
[48:39.900 --> 48:44.900]  Ну я имею ввиду не левый, а хотя бы один из вот этих.
[48:44.900 --> 48:46.900]  Либо средний, либо правый. Да, понятно.
[48:46.900 --> 48:53.900]  Если хотя бы один из операторов R-value, то тернарный оператор считается R-value.
[48:53.900 --> 48:56.900]  Запятая. Как устроено запятая?
[48:56.900 --> 49:02.900]  Ну кажется, я тоже говорил. Если правый оператор это L-value, то и запятая считается L-value.
[49:02.900 --> 49:05.900]  У запятой вид value такой же, как у правого оператора.
[49:05.900 --> 49:10.900]  Значит, запятая считается L-value, если правый оператор L-value.
[49:10.900 --> 49:26.900]  Так, минуточку.
[49:26.900 --> 49:30.900]  Перечисление параметров функции это не оператор запятая.
[49:30.900 --> 49:36.900]  Это уже надо знать к текущему моменту.
[49:36.900 --> 49:39.900]  Это мы раза три обсуждали, мне кажется, уже на лекции.
[49:40.900 --> 49:44.900]  Оператор запятая только в экспрешенах фигурирует.
[49:44.900 --> 49:47.900]  Перечисление параметров функции это не оператор запятая.
[49:47.900 --> 49:51.900]  Это другой элемент синтезиса, это не оператор.
[49:51.900 --> 49:58.900]  Как использовать оператор запятую? Мы его использовали в комплейтах, но...
[49:58.900 --> 50:01.900]  А запятая в R, а в B запятая в H, чтобы сломать.
[50:01.900 --> 50:18.900]  Это, кстати, хороший вопрос на понимание, как это будет работать в плюсах.
[50:18.900 --> 50:26.900]  У запятой самый низкий приоритет. Это распарщится вот так.
[50:26.900 --> 50:32.900]  Нет, присвоит B самому себе, это может быть много чего действить.
[50:32.900 --> 50:40.900]  То есть можно, чтобы ломать питанистов, периодически такие вещи писать?
[50:40.900 --> 50:42.900]  Ну да.
[50:42.900 --> 50:48.900]  Ты не учитываешь того, что тебя за это сломает ревьюер.
[50:48.900 --> 50:53.900]  Если ревьюер питанист, то как бы все нормально.
[50:53.900 --> 50:58.900]  А потом у вас упадет прод, да? В чем цель?
[50:58.900 --> 51:00.900]  Закоротить человека просто.
[51:00.900 --> 51:07.900]  Так, короче, запятая, если правый оперант это R-value.
[51:14.900 --> 51:18.900]  Вот, окей. А теперь самое интересное.
[51:18.900 --> 51:22.900]  На самом деле все эти пункты не очень интересные.
[51:22.900 --> 51:25.900]  Вот эти пункты совсем не интересные, вот эти пункты чуть поинтереснее.
[51:25.900 --> 51:27.900]  А теперь два самых интересных пункта.
[51:27.900 --> 51:32.900]  Это cast и вызов функции.
[51:32.900 --> 51:34.900]  Cast.
[51:34.900 --> 51:39.900]  Static Castor, Dynamic Castor, Interpret Cast, Const Cast.
[51:39.900 --> 51:46.900]  Значит, предпоследний пункт в определении.
[51:46.900 --> 51:55.900]  Если это Cast Expression, то есть либо Static Cast, либо Dynamic Cast, либо Interpret Cast, либо Const Cast, либо C-Style Cast, прости господи, то
[51:55.900 --> 52:22.900]  cast expression, если результирующий тип имеет вид, как вы думаете, какой, если результирующий тип с одним амперсантом.
[52:22.900 --> 52:27.900]  Если результирующий тип с одним амперсантом.
[52:27.900 --> 52:46.900]  И это R-value, если результирующий тип либо без амперсантов, либо с двумя амперсантами.
[52:46.900 --> 53:03.900]  Ну, давайте так скажу, если результирующий тип это L-value reference.
[53:03.900 --> 53:08.900]  Нет, это не один и тот же тип, в смысле, это разные типы.
[53:08.900 --> 53:14.900]  Нет, мы не договариваемся, что с T и 2 амперсанты это один и тот же тип, это разные типы совершенно.
[53:14.900 --> 53:18.900]  Просто мы договариваемся только о том, что я пишу формально.
[53:18.900 --> 53:33.900]  Вот мы договариваемся, что если у меня Cast Expression и в нем результирующий тип это non-reference или R-value reference, то результат такого каста считается R-value.
[53:33.900 --> 53:40.900]  Понятно.
[53:40.900 --> 53:43.900]  Значит, предпоследний пункт определения.
[53:43.900 --> 53:54.900]  Выражение каста, то есть static, dynamic, reinterpret, const, а также sys-style-cast считается L-value expression, если мы прикастили к типу с одним амперсантом.
[53:54.900 --> 54:04.900]  И это считается R-value expression, если мы прикастили либо к типу вообще без амперсантов, либо к типу с двумя амперсантами.
[54:04.900 --> 54:08.900]  И именно поэтому это называется R-value reference.
[54:08.900 --> 54:12.900]  Ну, это как бы намек на то, почему оно так называется.
[54:12.900 --> 54:20.900]  Это такая ссылка, что прикастив к ней, мы получим R-value.
[54:20.900 --> 54:25.900]  То есть R-value и R-value reference это типы?
[54:25.900 --> 54:28.900]  R-value reference это типы, да.
[54:28.900 --> 54:34.900]  R-value reference называется тип вида что-то и в конце два амперсанта.
[54:34.900 --> 54:41.900]  А L-value reference называется тип вида что-то и в конце один амперсант, но больше, чем два амперсанта не бывает.
[54:41.900 --> 54:51.900]  Если появляется больше, чем два амперсанта, то они схлопываются по правилам, которые я сказал, за исключением случая, о котором я не сказал, но это мы пока опустим.
[54:51.900 --> 55:05.900]  Я говорю, если у вас есть методические рекомендации, как лучше излагать это все, you are welcome.
[55:05.900 --> 55:10.900]  Я с удовольствием послушаю в конце года, потому что я не знаю лучшего порядка.
[55:10.900 --> 55:20.900]  Так вот, cast expression и последнее, function call, вызов функции.
[55:20.900 --> 55:28.900]  Function или метод call.
[55:28.900 --> 55:37.900]  Вызов функции и он по таким же правилам устроен.
[55:37.900 --> 55:41.900]  Ну, cast это не совсем функция.
[55:41.900 --> 55:54.900]  Значит, вызов функции или метода определенного, ну, какого-то точно по таким же правилам работает.
[55:54.900 --> 56:02.900]  Результат вызова function call, то есть вызов чего-то от чего-то, это L-value если,
[56:02.900 --> 56:08.900]  или возвращаемый тип от L-value reference, и R-value, если это либо non-reference, либо R-value reference.
[56:08.900 --> 56:14.900]  И именно поэтому это и намекает, почему эти ссылки так называются.
[56:14.900 --> 56:20.900]  Потому что если вернуть ее из функции или из cast expression, получится R-value выражение.
[56:20.900 --> 56:26.900]  Это одна из особенностей.
[56:27.900 --> 56:32.900]  Теперь давайте попробуем...
[56:32.900 --> 56:38.900]  А, ну, еще мы не сказали про оператор точка и оператор стрелочка.
[56:38.900 --> 56:44.900]  Ну, кажется они L-value.
[56:44.900 --> 56:55.900]  То, чем является оператор точка и оператор стрелочка зависит от того, чем был объект.
[56:55.900 --> 57:01.900]  Ну, например, вот я взял и сказал, не знаю...
[57:01.900 --> 57:06.900]  Ну, вот у меня была какая-то структура S.
[57:06.900 --> 57:09.900]  Это что, L-value или R-value?
[57:09.900 --> 57:13.900]  Нет, зависит от... вот это R-value.
[57:13.900 --> 57:17.900]  Ну, потому что function call же у нас...
[57:17.900 --> 57:19.900]  Ну, нет, это не так.
[57:19.900 --> 57:25.900]  Так, это... тут скорее всего правила слопы... то есть если поле было типа ссылка...
[57:25.900 --> 57:30.900]  Вот если сам X был L-value-reference, то я думаю, это все-таки будет L-value.
[57:30.900 --> 57:35.900]  Но в нормальном случае, то есть когда это не ссылка, когда это обычное поле, это будет R-value.
[57:35.900 --> 57:39.900]  Ну, потому что сам объект R-value, вот это же R-value.
[57:39.900 --> 57:43.900]  И у него точку взяли, это R-value остается.
[57:43.900 --> 57:45.900]  Я же могу описать объект точку.
[57:45.900 --> 57:46.900]  И что?
[57:46.900 --> 57:48.900]  Мы же правда можем написать S.X.
[57:48.900 --> 57:50.900]  Можем, и это будет R-value.
[57:50.900 --> 57:52.900]  В чем у тебя проблема?
[57:52.900 --> 57:55.900]  Ну, потому что присваивание возвращается к хорошему L-value.
[57:55.900 --> 57:57.900]  Какое присваивание?
[57:57.900 --> 57:58.900]  Ну, короче, мы присваиваем...
[57:58.900 --> 58:00.900]  Где здесь присваивание? Здесь обращение к полю.
[58:00.900 --> 58:03.900]  Ты еще раз. Мы к полю можем присвоить.
[58:03.900 --> 58:06.900]  Спокойно. И в этот момент у нас R-value превратится в L-value.
[58:06.900 --> 58:08.900]  Что-то такое...
[58:08.900 --> 58:11.900]  Кто тебе сказал, что присваивать мы можем только L-value?
[58:11.900 --> 58:14.900]  Ты какие-то устаревшие взгляды.
[58:15.900 --> 58:17.900]  Нет, просто...
[58:17.900 --> 58:19.900]  Если у нас по ходу меняется тип операции...
[58:19.900 --> 58:21.900]  Что значит по ходу меняется? По ходу чего?
[58:21.900 --> 58:23.900]  По ходу того, что происходит.
[58:23.900 --> 58:25.900]  Где происходит? В compile-time или в runtime?
[58:25.900 --> 58:27.900]  Зачем нам вообще нужны типы?
[58:27.900 --> 58:28.900]  Это правда.
[58:28.900 --> 58:30.900]  Зачем вообще нужны виды value?
[58:30.900 --> 58:32.900]  Если можно присваивать, можно не присваивать.
[58:32.900 --> 58:34.900]  Можно что-то еще есть.
[58:34.900 --> 58:37.900]  Потому что от вида value зависит, какая операция будет вызываться.
[58:37.900 --> 58:39.900]  Move или Copy.
[58:39.900 --> 58:42.900]  Это типа кастыль, чтобы различать просто разные...
[58:42.900 --> 58:43.900]  Да-да.
[58:43.900 --> 58:46.900]  Так, давайте я все-таки добавлю этот пункт в определение.
[58:46.900 --> 58:48.900]  Значит...
[58:48.900 --> 58:50.900]  А давайте просто cpp-reference...
[58:50.900 --> 58:52.900]  Господи, откроем. Что мы уже...
[58:54.900 --> 58:56.900]  Я вам основные пункты написал.
[58:56.900 --> 58:58.900]  Сейчас мы посмотрим на не основные пункты.
[58:58.900 --> 59:00.900]  Сейчас. Да, какой вопрос?
[59:00.900 --> 59:07.900]  Если у нас в ES-case был constant, то это тоже станет L-value, да?
[59:08.900 --> 59:13.900]  Константность никак не влияет на категорию типа.
[59:13.900 --> 59:15.900]  На категорию expression.
[59:16.900 --> 59:17.900]  Сейчас.
[59:17.900 --> 59:24.900]  Ну, может быть, как-то и влияет, но это какие-то очень тонкие случаи, которые несущественные для понимания.
[59:25.900 --> 59:30.900]  Так, давайте-ка посмотрим на формальное определение теперь полностью.
[59:30.900 --> 59:36.900]  Вообще стандарт написан так, чтобы было потруднее.
[59:36.900 --> 59:38.900]  Понимать его.
[59:38.900 --> 59:41.900]  В стандарте нету четкого определения L-value и R-value.
[59:41.900 --> 59:44.900]  Оно собирается по кусочкам из всего стандарта.
[59:44.900 --> 59:51.900]  Ну, то есть в стандарте нету места, в котором написано L-value называется одно из следующего, а R-value называется одно из следующего. Нет.
[59:51.900 --> 59:56.900]  В стандарте просто про каждый оператор отдельно одним из пунктов сказано, какой он value, и все.
[59:56.900 --> 01:00:00.900]  То есть нету в стандарте прям четкого вот где собрать.
[01:00:00.900 --> 01:00:08.900]  Добрые люди на CPP Reference все-таки сделали эту кропотливую работу и по кусочкам из стандарта собрали понимание, что такое L-value целиком.
[01:00:08.900 --> 01:00:10.900]  Вот что такое L-value.
[01:00:10.900 --> 01:00:14.900]  Значит, страница на CPP Reference называется value category.
[01:00:14.900 --> 01:00:18.900]  Да, если что, это называется категорией значений.
[01:00:18.900 --> 01:00:21.900]  Значит, у каждого выражения есть две характеристики.
[01:00:21.900 --> 01:00:23.900]  Есть тип и есть категория значений.
[01:00:23.900 --> 01:00:24.900]  Это артагональные вещи.
[01:00:24.900 --> 01:00:28.900]  Ну, то есть они как-то связаны друг с другом, но это разные вещи.
[01:00:28.900 --> 01:00:32.900]  Можно отдельно спросить про выражение, какой у него тип, и можно отдельно спрашивать про выражение,
[01:00:32.900 --> 01:00:33.900]  какой у него категория значений.
[01:00:33.900 --> 01:00:38.900]  В десятый раз повторяю, что нельзя спрашивать каким value является этот тип.
[01:00:38.900 --> 01:00:39.900]  Это бессмыслийный вопрос.
[01:00:39.900 --> 01:00:46.900]  Может только про выражения спрашивать, каким оно является типом, а также каким оно является категорией значения.
[01:00:46.900 --> 01:00:51.900]  Так вот, что такое L-value.
[01:00:51.900 --> 01:00:52.900]  Ну здесь в принципе перечислено.
[01:00:52.900 --> 01:01:02.340]  перечислено это имя переменной имя функции или или data member regardless of
[01:01:02.340 --> 01:01:10.140]  type так или data member возможно я вас сейчас
[01:01:10.140 --> 01:01:21.980]  стд сим да возможно я вас все-таки обманул и с с точка x это было l value да
[01:01:21.980 --> 01:01:32.220]  хорошо давайте читать дальше да да наверное я вас обманул извините значит это все-таки
[01:01:32.220 --> 01:01:37.980]  было l value да да да да да или ну если я написал s круглые скобочки точка x это все-таки l value
[01:01:37.980 --> 01:01:50.360]  формально они r value несмотря на то что с было r value да член поля класса это l value значит
[01:01:50.360 --> 01:01:58.100]  вызов функции или перегруженного оператора чей возвращаемый тип это l value референс дальше
[01:01:58.100 --> 01:02:03.900]  результаты вот таких вот присваиваний префиксного инкремента разыменование обращение по индексу
[01:02:03.900 --> 01:02:11.180]  квадратными скобочками к встроенным операторам операторам дальше обращение через точку член
[01:02:11.180 --> 01:02:21.860]  объекта за исключением случая когда m это член перечлен член енума или нестатическая функция
[01:02:21.860 --> 01:02:31.100]  член или когда а нет я вас все-таки не обманул смотрите а точка м это все это все-таки р вл ю
[01:02:31.140 --> 01:02:41.140]  когда a это r well you а aim это нестатический член типа объектомyy мв обращение к точке
[01:02:41.140 --> 01:02:53.300]  обращение точкой к полю это lble ю за исключением ситуации когда
[01:02:53.300 --> 01:03:01.300]  А также, когда a это R-value, а m это нестатическое поле член объектного типа.
[01:03:01.300 --> 01:03:03.300]  Какая нестатическая функция члена?
[01:03:03.300 --> 01:03:06.300]  То есть, ну как это, функция члена, которая является нестатическим?
[01:03:06.300 --> 01:03:10.300]  А, а это переменная всегда R-value?
[01:03:10.300 --> 01:03:12.300]  Нет, а это произвольный expression здесь.
[01:03:12.300 --> 01:03:15.300]  Имеется в виду, если он писал s, круглые скобочки, точка m,
[01:03:15.300 --> 01:03:21.300]  и m имела тип какой-то класс, и вот, ну и тогда это будет R-value.
[01:03:21.300 --> 01:03:26.300]  Ну короче, это довольно тонкий случай, который на самом деле я не предлагаю вам выучивать наизусть.
[01:03:26.300 --> 01:03:35.300]  Что такое a.exe, если a это нестатическая функция члена?
[01:03:38.300 --> 01:03:39.300]  R-value?
[01:03:39.300 --> 01:03:41.300]  Нет, в смысле не R-value.
[01:03:42.300 --> 01:03:47.300]  Давайте забьем, пожалуйста. Ну это какие-то технические детали определений, которые несущественны для понимания.
[01:03:47.300 --> 01:03:49.300]  Ну, существенные случаи мы разобрали.
[01:03:49.300 --> 01:03:55.300]  Значит, вот, стрелочка является L-value, кроме случая, когда m это бла-бла-бла,
[01:03:55.300 --> 01:04:03.300]  значит, точка со звездочкой является L-value, в случае, когда a это L-value, а mp это указатель на член,
[01:04:03.300 --> 01:04:07.300]  стрелочка со звездочки является L-value, ну и так далее.
[01:04:07.300 --> 01:04:13.300]  Значит, запятая, когда b, L-value, тернарный оператор, когда оба являются L-value,
[01:04:13.300 --> 01:04:16.300]  строковый литерал является L-value почему-то.
[01:04:17.300 --> 01:04:18.300]  Ну, забьем.
[01:04:18.300 --> 01:04:24.300]  Cast expression к L-value-reference, а также non-type template-параметр типа L-value-reference.
[01:04:27.300 --> 01:04:30.300]  Ну, если у вас был параметр шаблона типа int&%
[01:04:30.300 --> 01:04:31.300]  int&%?
[01:04:31.300 --> 01:04:34.300]  Ну да, вы сделали int&% параметром шаблона.
[01:04:34.300 --> 01:04:35.300]  Как?
[01:04:35.300 --> 01:04:40.300]  Ну так и написали template в скобочках int&% x, и тогда x это будет L-value.
[01:04:40.300 --> 01:04:45.300]  Вот, а также, ну в общем, в общем, не важно.
[01:04:45.300 --> 01:04:48.300]  Вот, короче, вот это L-value.
[01:04:48.300 --> 01:04:54.300]  Забейте, пожалуйста, это несущественно, если мы будем погрязать детали, мы не доберемся ни до чего.
[01:04:54.300 --> 01:04:58.300]  Вот основные случаи мы разобрали, если вам интересны детали, вы можете читать стандарт.
[01:04:58.300 --> 01:05:02.300]  Я не хочу разбирать эти упоротые случаи сейчас.
[01:05:02.300 --> 01:05:09.300]  Дальше, к сожалению, мне придется приоткрыть вам еще одну неприятную истину.
[01:05:09.300 --> 01:05:13.300]  R-value подразделяется на два подвида, pair-value и x-value.
[01:05:13.300 --> 01:05:19.300]  Но для текущего понимания можно на это забить и просто не разделять их.
[01:05:19.300 --> 01:05:24.300]  То есть, смотрите, есть понятие pair-value и есть понятие x-value.
[01:05:24.300 --> 01:05:28.300]  Pure r-value, а также expired-value.
[01:05:28.300 --> 01:05:36.300]  Но мы не будем сейчас разбирать, почему они подразделяются, просто мы как будто объединим два списка в один.
[01:05:36.300 --> 01:05:38.300]  Вот это считается R-value.
[01:05:38.300 --> 01:05:42.300]  Ну, я не буду перечислять еще раз, но тут все написано, что является R-value.
[01:05:42.300 --> 01:05:45.300]  Что такое R-value, чтобы L-value в принципе по жизни?
[01:05:45.300 --> 01:05:51.300]  Значит, L-value это то, чему можно присваивать, ну, так примеризительно.
[01:05:51.300 --> 01:05:53.300]  Как правило.
[01:05:53.300 --> 01:05:54.300]  Указатель на zis.
[01:05:54.300 --> 01:05:57.300]  Да, да, указатель на viz является R-value.
[01:05:57.300 --> 01:05:58.300]  Отличное R-value.
[01:05:58.300 --> 01:05:59.300]  Да, отличное R-value.
[01:05:59.300 --> 01:06:02.300]  Дальше результат вызова функций.
[01:06:02.300 --> 01:06:07.300]  Ну, тут если вкратце сводится к тому, что все то, что связано с R-value с ссылками, это как раз x-value.
[01:06:07.300 --> 01:06:12.300]  Но забейте, вот пока не надо думать, почему.
[01:06:12.300 --> 01:06:16.300]  Понимать, чем отличается pair-value от x-value на данной стадии не надо.
[01:06:16.300 --> 01:06:21.300]  Надо просто знать, что есть L-value и R-value.
[01:06:21.300 --> 01:06:24.300]  Так, конец четвертой серии.
[01:06:24.300 --> 01:06:29.300]  Мы с вами дали формальное определение L-value и R-value.
[01:06:29.300 --> 01:06:35.300]  Есть ли вопросы по этой части, кроме задротских вопросов, и да, а если я возьму вот такой вот анперсант,
[01:06:35.300 --> 01:06:40.300]  и сделаю функцию член, стрелочку со звездочкой, вот эти я не буду в детали сейчас.
[01:06:40.300 --> 01:06:45.300]  Вот какие-нибудь экзистенциальные вопросы, философские такие, глобальные на уровне.
[01:06:45.300 --> 01:06:54.300]  В том списке с L-value у нас, ну, так сказать, слева можно стоять L-value, а справа все что угодно.
[01:06:54.300 --> 01:06:55.300]  В каком списке?
[01:06:55.300 --> 01:06:57.300]  Ну, на доске, который был.
[01:06:57.300 --> 01:07:00.300]  Плюс равно, равно, равно.
[01:07:00.300 --> 01:07:04.300]  Неважно, что стоит слева и что справа.
[01:07:04.300 --> 01:07:09.300]  Результат операции плюс равно это L-value для всех встроенных типов.
[01:07:09.300 --> 01:07:11.300]  Неважно, да.
[01:07:11.300 --> 01:07:15.300]  Ну, если это компилируется, то ради бога.
[01:07:15.300 --> 01:07:20.300]  Ну, например, для вектора bool обращение по индексу это не L-value, как мы знаем.
[01:07:20.300 --> 01:07:22.300]  И мы уже понимаем, кстати, почему формально.
[01:07:22.300 --> 01:07:27.300]  Обращение по индексу к вектору bool это не L-value, потому что обращение по индексу к вектору bool дает тип без амперсандов.
[01:07:27.300 --> 01:07:30.300]  А он R-value по определению.
[01:07:30.300 --> 01:07:35.300]  Так, последний пункт, который мы сегодня успеем разобрать.
[01:07:35.300 --> 01:07:41.300]  Это все-таки что же такое R-value ссылки и операции над ними.
[01:07:41.300 --> 01:07:50.300]  И после этого пункта вам должно стать понятно все кроме того, почему bool такой странный тип принимает.
[01:07:50.300 --> 01:07:53.300]  И почему такой странный тип...
[01:07:53.300 --> 01:08:02.300]  Ну, короче, все кроме этой вот проблемы, почему в одном месте мы пишем T с двумя амперсандами, а в другом remove reference T с двумя амперсандами.
[01:08:02.300 --> 01:08:14.300]  Но все те загадки, которые были в прошлый раз, к концу этой пары будут у вас разгаданы и останутся лишь новая загадка, почему такие странные типы move принимает и возвращает.
[01:08:14.300 --> 01:08:17.300]  Почему нельзя было просто написать T с двумя амперсандами.
[01:08:17.300 --> 01:08:25.300]  Значит, последнее, что я сейчас расскажу, это что такое R-value референсы.
[01:08:25.300 --> 01:08:35.300]  Значит, пункт 10.5 называется R-value references и операции над ними.
[01:08:42.300 --> 01:08:49.300]  Так, параграф 10.5, R-value references.
[01:08:49.300 --> 01:08:57.300]  И, не знаю, их свойства.
[01:09:02.300 --> 01:09:05.300]  Смотрите, когда-то...
[01:09:05.300 --> 01:09:09.300]  Какие-то вещественные числа получились.
[01:09:09.300 --> 01:09:14.300]  Когда-то мы с вами проходили в этой аудитории обычные ссылки.
[01:09:14.300 --> 01:09:19.300]  И я вам тут говорил, что, понимаете, ссылка это просто другое название для того же объекта.
[01:09:19.300 --> 01:09:24.300]  Что значит, модификация ссылки это и есть модификация того самого объекта и так далее.
[01:09:24.300 --> 01:09:27.300]  Ну, в целом, для R-value ссылок все это верно остается.
[01:09:27.300 --> 01:09:32.300]  То есть они по своим свойствам как к обычной ссылке.
[01:09:32.300 --> 01:09:39.300]  То есть точно так же, если у вас есть R-value ссылка на что-то, то это просто другое название для него.
[01:09:39.300 --> 01:09:43.300]  Модификация R-value ссылки это то же самое, что модификация исходного объекта.
[01:09:43.300 --> 01:09:46.300]  R-value ссылка не может быть перепривязана к другому объекту.
[01:09:46.300 --> 01:09:48.300]  Она не может быть ничем не проинициализирована.
[01:09:48.300 --> 01:09:50.300]  То есть все эти свойства ссылок сохраняются.
[01:09:50.300 --> 01:09:55.300]  Есть два ключевых различия, которыми отличаются R-value ссылки от обычных ссылок.
[01:09:55.300 --> 01:09:57.300]  В принципе, этим все сказано.
[01:09:57.300 --> 01:09:59.300]  А дальше можно просто разбирать примеры.
[01:09:59.300 --> 01:10:04.300]  Два главных отличия, чем отличаются R-value ссылки от обычных ссылок.
[01:10:04.300 --> 01:10:07.300]  Первое отличие уже было произнесено.
[01:10:07.300 --> 01:10:16.300]  R-value ссылка, будучи возвращенная из функции или из каст операции, является R-value выражением.
[01:10:16.300 --> 01:10:22.300]  Это первое из двух главных отличий R-value ссылок от L-value ссылок.
[01:10:22.300 --> 01:10:24.300]  А второе главное отличие.
[01:10:24.300 --> 01:10:30.300]  R-value ссылка может быть проинициализирована только R-value выражением.
[01:10:30.300 --> 01:10:34.300]  В то время как L-value ссылка только L-value выражением.
[01:10:35.300 --> 01:10:37.300]  Не константная.
[01:10:37.300 --> 01:10:42.300]  Константная L-value ссылка может быть проинициализирована как R-value, так и L-value выражением.
[01:10:42.300 --> 01:10:47.300]  Но вот R-value ссылка, любая, может быть проинициализирована лишь R-value выражением.
[01:10:47.300 --> 01:10:51.300]  Например, давайте вспомним какие-нибудь примеры.
[01:10:51.300 --> 01:10:53.300]  Вот я говорю int x равно 0.
[01:10:53.300 --> 01:10:59.300]  И говорю int двойной амперсант y равно x.
[01:10:59.300 --> 01:11:01.300]  Это корректно или нет?
[01:11:01.300 --> 01:11:03.300]  Нет, это CE.
[01:11:04.300 --> 01:11:07.300]  Жестко.
[01:11:07.300 --> 01:11:11.300]  Это CE, потому что...
[01:11:11.300 --> 01:11:13.300]  Да, именно.
[01:11:13.300 --> 01:11:15.300]  Вот это CE.
[01:11:15.300 --> 01:11:17.300]  Это CE.
[01:11:23.300 --> 01:11:25.300]  То это нормально.
[01:11:34.300 --> 01:11:36.300]  Вот это OK.
[01:11:38.300 --> 01:11:40.300]  Что?
[01:11:43.300 --> 01:11:45.300]  Конечно.
[01:11:45.300 --> 01:11:47.300]  Как и константную L-value ссылку, в общем.
[01:11:49.300 --> 01:11:53.300]  Подождите, ну вас же не смущало, ну или смущало, но вы уже забыли.
[01:11:53.300 --> 01:11:55.300]  Вы же можете написать вот так.
[01:11:55.300 --> 01:11:57.300]  Const int амперсант cx равно 1.
[01:11:57.300 --> 01:11:59.300]  Мы же так делали с вами.
[01:11:59.300 --> 01:12:01.300]  И не раз.
[01:12:03.300 --> 01:12:07.300]  Ну, в случае константных ссылок...
[01:12:07.300 --> 01:12:09.300]  Ну да.
[01:12:09.300 --> 01:12:13.300]  R-value ссылки, как и константные ссылки, продлевают жизнь временным значением.
[01:12:15.300 --> 01:12:17.300]  Да.
[01:12:17.300 --> 01:12:19.300]  Нет, double амперсант y равно x это CE.
[01:12:19.300 --> 01:12:21.300]  Вот const double амперсант y равно x.
[01:12:21.300 --> 01:12:23.300]  Это нормально.
[01:12:23.300 --> 01:12:25.300]  Один амперсант.
[01:12:25.300 --> 01:12:27.300]  Один амперсант.
[01:12:27.300 --> 01:12:29.300]  Const double амперсант.
[01:12:29.300 --> 01:12:31.300]  Double амперсант y равно x.
[01:12:31.300 --> 01:12:33.300]  Это нормально.
[01:12:33.300 --> 01:12:35.300]  Создаст современный double из этого x.
[01:12:35.300 --> 01:12:37.300]  И к нему привяжется константная ссылка.
[01:12:37.300 --> 01:12:39.300]  Одинарный амперсант.
[01:12:43.300 --> 01:12:45.300]  Такого типа нет.
[01:12:45.300 --> 01:12:47.300]  Ты имеешь в виду вот это?
[01:12:47.300 --> 01:12:49.300]  Это некорректно.
[01:12:53.300 --> 01:12:55.300]  Что-что?
[01:12:55.300 --> 01:12:57.300]  Имеет ли смысл константная R-value ссылка?
[01:12:57.300 --> 01:12:59.300]  А что такое имеет смысл?
[01:13:03.300 --> 01:13:07.300]  Что ты называешь имеющим смысл, а что ты называешь не имеющим смысл?
[01:13:07.300 --> 01:13:09.300]  Имеет ли это применение практическое?
[01:13:11.300 --> 01:13:13.300]  Ну, бывает.
[01:13:13.300 --> 01:13:15.300]  Редко, но бывает.
[01:13:15.300 --> 01:13:17.300]  А чем они вообще отличаются?
[01:13:19.300 --> 01:13:23.300]  Ну, у тебя, когда ты пишешь какой-нибудь библиотечный код,
[01:13:23.300 --> 01:13:27.300]  формально тебе нужно разобрать все четыре случая,
[01:13:27.300 --> 01:13:29.300]  когда мы будем писать какие-нибудь библиотечные функции,
[01:13:29.300 --> 01:13:33.300]  у нас может в виду наложение константности на move
[01:13:33.300 --> 01:13:35.300]  получиться константный R-value,
[01:13:35.300 --> 01:13:37.300]  да, константный двойной амперсант.
[01:13:37.300 --> 01:13:39.300]  Такое бывает,
[01:13:39.300 --> 01:13:41.300]  и это приводит к тому, что оно ведет себя как копирование.
[01:13:41.300 --> 01:13:43.300]  То есть целенаправленно
[01:13:43.300 --> 01:13:45.300]  константные R-value ссылки
[01:13:45.300 --> 01:13:47.300]  никто не создает, мне кажется,
[01:13:47.300 --> 01:13:49.300]  но они могут возникнуть как комбинация
[01:13:49.300 --> 01:13:51.300]  наложения константности на move,
[01:13:51.300 --> 01:13:53.300]  и в этот случай иногда бывает нужно
[01:13:53.300 --> 01:13:55.300]  отдельно обрабатывать, например.
[01:13:55.300 --> 01:13:57.300]  Вот.
[01:13:57.300 --> 01:13:59.300]  То есть это вполне себе корректный тип,
[01:13:59.300 --> 01:14:01.300]  да, и он может существовать.
[01:14:01.300 --> 01:14:03.300]  Так, окей.
[01:14:03.300 --> 01:14:05.300]  Да.
[01:14:05.300 --> 01:14:07.300]  Пожалуйста, почему
[01:14:07.300 --> 01:14:09.300]  нельзя создавать R-value ссылки
[01:14:09.300 --> 01:14:11.300]  на временные значения на R-value?
[01:14:11.300 --> 01:14:13.300]  Мы обсуждали это
[01:14:15.300 --> 01:14:17.300]  в октябре.
[01:14:17.300 --> 01:14:19.300]  Ну, хорошо, давайте я напомню.
[01:14:19.300 --> 01:14:21.300]  Почему L-value ссылки не константные,
[01:14:21.300 --> 01:14:23.300]  не продлевают жизнь объектам?
[01:14:23.300 --> 01:14:25.300]  Мы обсуждали, у нас был
[01:14:25.300 --> 01:14:27.300]  пример, почему так нельзя делать.
[01:14:27.300 --> 01:14:29.300]  Это было еще на заре остановления C++,
[01:14:29.300 --> 01:14:31.300]  когда Страустер пришел, как
[01:14:31.300 --> 01:14:33.300]  должны ссылки продлевать жизнь объектам.
[01:14:33.300 --> 01:14:35.300]  А именно пример такой.
[01:14:35.300 --> 01:14:37.300]  Напоминаю о нем уже, по-моему,
[01:14:37.300 --> 01:14:39.300]  даже не во второй раз, но
[01:14:39.300 --> 01:14:41.300]  я, по-моему, все забываю. Значит, если у нас есть вот такая
[01:14:41.300 --> 01:14:43.300]  штука,
[01:14:43.300 --> 01:14:45.300]  а потом мы вызываем f от x,
[01:14:45.300 --> 01:14:47.300]  а f принимает
[01:14:47.300 --> 01:14:49.300]  double ampersand,
[01:14:51.300 --> 01:14:53.300]  то если бы мы умели не константными
[01:14:53.300 --> 01:14:55.300]  L-value ссылками продлевать жизнь объектам,
[01:14:55.300 --> 01:14:57.300]  у нас была бы
[01:14:57.300 --> 01:14:59.300]  проблема, потому что мы бы создали
[01:14:59.300 --> 01:15:01.300]  временный double из этого int
[01:15:01.300 --> 01:15:03.300]  и думали бы, что мы получили ссылку на то,
[01:15:03.300 --> 01:15:05.300]  что передали, а на самом деле
[01:15:05.300 --> 01:15:07.300]  нет.
[01:15:07.300 --> 01:15:09.300]  Это причина,
[01:15:09.300 --> 01:15:11.300]  по которой C++ запретил не константными
[01:15:11.300 --> 01:15:13.300]  L-value ссылками продлевать жизнь объектам.
[01:15:13.300 --> 01:15:15.300]  Потому что в случае неявного каста
[01:15:15.300 --> 01:15:17.300]  мы бы никак не смогли опечить ситуацию,
[01:15:17.300 --> 01:15:19.300]  что мы ссылку на временный объект сейчас
[01:15:19.300 --> 01:15:21.300]  получили или ссылку на настоящий объект.
[01:15:21.300 --> 01:15:23.300]  И мы бы очень трудно дебажили это.
[01:15:23.300 --> 01:15:25.300]  Но в случае константных
[01:15:25.300 --> 01:15:27.300]  мы можем так себе позволить делать,
[01:15:27.300 --> 01:15:29.300]  потому что мы все равно менять ее не собираемся.
[01:15:29.300 --> 01:15:31.300]  Какая нам разница? Мы с реальным объектами
[01:15:31.300 --> 01:15:33.300]  делали или с временным.
[01:15:33.300 --> 01:15:35.300]  Но вот в случае с R-value ссылками
[01:15:35.300 --> 01:15:37.300]  нам принципиально, чтобы они умели
[01:15:37.300 --> 01:15:39.300]  инициализироваться R-value значениями.
[01:15:39.300 --> 01:15:41.300]  В этом весь их смысл.
[01:15:41.300 --> 01:15:43.300]  Нам как раз нужно, чтобы они умели инициализироваться R-value значениями.
[01:15:43.300 --> 01:15:45.300]  Потому что именно благодаря этому
[01:15:45.300 --> 01:15:47.300]  мы по R-value ссылке
[01:15:47.300 --> 01:15:49.300]  можем принимать результаты CDMOV в функцию.
[01:15:49.300 --> 01:15:51.300]  Именно благодаря тому,
[01:15:51.300 --> 01:15:53.300]  что R-value ссылки
[01:15:53.300 --> 01:15:55.300]  инициализируются R-value значениями и только ими,
[01:15:55.300 --> 01:15:57.300]  у нас правильно работает перегрузка.
[01:15:57.300 --> 01:15:59.300]  Когда у нас есть какая-нибудь функция,
[01:15:59.300 --> 01:16:01.300]  принимающая string
[01:16:01.300 --> 01:16:03.300]  двойной амперсант,
[01:16:03.300 --> 01:16:05.300]  а также функция, принимающая
[01:16:05.300 --> 01:16:07.300]  const string амперсант,
[01:16:07.300 --> 01:16:09.300]  то мы,
[01:16:09.300 --> 01:16:11.300]  имея R-value,
[01:16:11.300 --> 01:16:13.300]  попадаем сюда,
[01:16:13.300 --> 01:16:15.300]  а не сюда.
[01:16:15.300 --> 01:16:17.300]  И в этом как раз и есть суть
[01:16:17.300 --> 01:16:19.300]  R-value ссылок.
[01:16:19.300 --> 01:16:21.300]  Вся суть R-value ссылок
[01:16:21.300 --> 01:16:23.300]  в том, чтобы они
[01:16:23.300 --> 01:16:25.300]  при перегрузке
[01:16:25.300 --> 01:16:27.300]  забирали себе
[01:16:27.300 --> 01:16:29.300]  ту версию,
[01:16:29.300 --> 01:16:31.300]  которая вызвана
[01:16:31.300 --> 01:16:33.300]  от R-value.
[01:16:33.300 --> 01:16:35.300]  Вот если мы вызвались от R-value,
[01:16:35.300 --> 01:16:37.300]  и у нас прописана
[01:16:37.300 --> 01:16:39.300]  вот такая версия foots,
[01:16:39.300 --> 01:16:41.300]  то мы обязательно попадем сюда.
[01:16:41.300 --> 01:16:43.300]  Вот эта версия годится и для R-value,
[01:16:43.300 --> 01:16:45.300]  и для L-value.
[01:16:45.300 --> 01:16:47.300]  Но она менее предпочтительна,
[01:16:47.300 --> 01:16:49.300]  потому что эта версия годится только для R-value.
[01:16:49.300 --> 01:16:51.300]  И если у нас есть R-value,
[01:16:51.300 --> 01:16:53.300]  то мы попадем
[01:16:53.300 --> 01:16:55.300]  как раз сюда.
[01:16:55.300 --> 01:16:57.300]  Если у нас есть эта версия наряду с этой,
[01:16:57.300 --> 01:16:59.300]  то при вызове от R-value предпочтение будет
[01:16:59.300 --> 01:17:01.300]  на этой версии.
[01:17:01.300 --> 01:17:03.300]  Именно поэтому, если у вас есть в классе
[01:17:03.300 --> 01:17:05.300]  и вы от R-value что-то делаете,
[01:17:05.300 --> 01:17:07.300]  вы попадаете сюда.
[01:17:07.300 --> 01:17:09.300]  Но если бы у вас не было этой версии,
[01:17:09.300 --> 01:17:11.300]  то вы попадали сюда по общему правилу,
[01:17:11.300 --> 01:17:13.300]  потому что эта версия годится и для того, и для другого.
[01:17:13.300 --> 01:17:15.300]  А если бы у вас
[01:17:15.300 --> 01:17:17.300]  была еще и вот такая версия,
[01:17:17.300 --> 01:17:19.300]  то в нее бы вы попадали только когда
[01:17:19.300 --> 01:17:21.300]  у вас L-value.
[01:17:21.300 --> 01:17:23.300]  Вот это версия годится
[01:17:23.300 --> 01:17:29.300]  Вот эта версия годится только для L-value expression, вот эта версия годится только для R-value expression, а эта годится и для тех, и для других.
[01:17:29.300 --> 01:17:31.300]  Но вы тогда в центральный никогда не попадали?
[01:17:31.300 --> 01:17:35.300]  Нет, если у вас тип константный стринг, то вы бы попадали в центральную.
[01:17:35.300 --> 01:17:37.300]  Константный стринг?
[01:17:37.300 --> 01:17:42.300]  Ну если вы вызвались от const-string, то вы бы попали сюда.
[01:17:42.300 --> 01:17:47.300]  Но если вы вызвались от обычного стринг, то вы бы попали либо сюда, либо сюда, смотря какой вид value был.
[01:17:47.300 --> 01:17:51.300]  Вот.
[01:17:51.300 --> 01:18:01.300]  Понятно, почему R-value ссылки обладают таким свойством, что это главное их свойство, они только через R-value могут быть проинциализированы.
[01:18:01.300 --> 01:18:04.300]  Сейчас мы с вами, сейчас еще парочка примеров.
[01:18:04.300 --> 01:18:06.300]  Что-то Федя все нет и нет.
[01:18:06.300 --> 01:18:09.300]  А если я вызову const-string, то будет SE?
[01:18:09.300 --> 01:18:11.300]  Если ты вы...
[01:18:11.300 --> 01:18:13.300]  Что такое SE?
[01:18:14.300 --> 01:18:17.300]  Я это почувствовал просто.
[01:18:17.300 --> 01:18:19.300]  Какую букву ты назвал буквой S?
[01:18:19.300 --> 01:18:21.300]  Ты как бы разворачивался сейчас просто.
[01:18:21.300 --> 01:18:24.300]  Ну в смысле, ну я не могу.
[01:18:24.300 --> 01:18:27.300]  Почему ты это читаешь как SE?
[01:18:27.300 --> 01:18:29.300]  Solo extension.
[01:18:29.300 --> 01:18:30.300]  Это по-русски.
[01:18:30.300 --> 01:18:33.300]  Это буква C, это не S.
[01:18:33.300 --> 01:18:35.300]  Это C, это CE.
[01:18:35.300 --> 01:18:38.300]  Это человек, который говорит OK.
[01:18:38.300 --> 01:18:42.300]  Я знаю человека, который говорит CCH.
[01:18:42.300 --> 01:18:43.300]  Это что?
[01:18:46.300 --> 01:18:52.300]  Если мы вызовемся от const-string 2A, ты хочешь спросить, что ты спросил?
[01:18:52.300 --> 01:18:54.300]  Да, const-string 2A.
[01:18:54.300 --> 01:19:00.300]  Если мы вызовемся от const-string 2A, мы попадем...
[01:19:00.300 --> 01:19:03.300]  Мы вызвались от R-value или от L-value для начала?
[01:19:03.300 --> 01:19:05.300]  Это же R-value.
[01:19:05.300 --> 01:19:06.300]  Минуточку.
[01:19:06.300 --> 01:19:08.300]  Тип не является каким value сам по себе.
[01:19:08.300 --> 01:19:11.300]  Мы вызвались от какого expression, ты мне скажи?
[01:19:11.300 --> 01:19:13.300]  Мы вызвались от sigma.
[01:19:13.300 --> 01:19:14.300]  Минуточку.
[01:19:14.300 --> 01:19:19.300]  То, куда мы попадем, зависит не только от того, какой тип был, но и от того, какое value было.
[01:19:19.300 --> 01:19:21.300]  В смысле? Да? Что?
[01:19:21.300 --> 01:19:23.300]  Так я только что 5 минут про это говорил.
[01:19:23.300 --> 01:19:29.300]  Если мы вызываемся от строки, которая является R-value, то мы попадем сюда.
[01:19:29.300 --> 01:19:33.300]  А если мы вызываемся от строки, которая является L-value, мы попадем сюда.
[01:19:33.300 --> 01:19:39.300]  Но при этом тип строки может быть как string, так и string 1A, так и string 2A.
[01:19:39.300 --> 01:19:41.300]  Тяжело отрезать...
[01:19:41.300 --> 01:19:46.300]  Нет, у меня есть переменная const int 2A.
[01:19:46.300 --> 01:19:54.300]  Вот смотри, у тебя есть переменная const int 2A, R, допустим, равно 0.
[01:19:54.300 --> 01:19:57.300]  И что ты пишешь? Ты пишешь f от чего?
[01:19:57.300 --> 01:19:58.300]  От R.
[01:19:58.300 --> 01:20:01.300]  Тогда ты вызываешься от L-value.
[01:20:01.300 --> 01:20:02.300]  И мы попадаем в string.
[01:20:02.300 --> 01:20:04.300]  И ты попадаешь в эту версию.
[01:20:04.300 --> 01:20:07.300]  В эту ты не можешь попасть, потому что это нарушение константности.
[01:20:07.300 --> 01:20:11.300]  В эту ты не можешь попасть, потому что это не R-value у тебя, а L-value.
[01:20:11.300 --> 01:20:13.300]  Значит единственное, куда ты попадаешь, это сюда.
[01:20:13.300 --> 01:20:15.300]  Если бы он был не константный, то мы попали в нижнюю.
[01:20:15.300 --> 01:20:25.300]  Если бы вот здесь не было этого, то мы бы попали вот сюда, потому что мы вызвались от L-value.
[01:20:25.300 --> 01:20:27.300]  Сейчас здесь глобально даже будет.
[01:20:27.300 --> 01:20:30.300]  Чтобы отличать временное объект от невременное.
[01:20:30.300 --> 01:20:33.300]  Чтобы отличать R-value от L-value.
[01:20:33.300 --> 01:20:35.300]  Это же какая-то очень празматичная цель.
[01:20:38.300 --> 01:20:40.300]  А мы на чем пишем, по-двоему?
[01:20:40.300 --> 01:20:44.300]  Мы же не ждем, что у нас будет разная идея, когда мы вызываемся от R и от R+.
[01:20:44.300 --> 01:20:45.300]  Да, именно.
[01:20:45.300 --> 01:20:46.300]  В этом разном поводе.
[01:20:46.300 --> 01:20:48.300]  Нет, ждем, конечно.
[01:20:48.300 --> 01:20:50.300]  Просто R это невре...
[01:20:50.300 --> 01:20:51.300]  Так, смотрите.
[01:20:51.300 --> 01:20:54.300]  Вот сейчас нужно понять одну важную вещь.
[01:20:54.300 --> 01:21:02.300]  Вот я формально все это проговорил, но тем не менее это пока пример не покажешь, люди не поверят.
[01:21:02.300 --> 01:21:03.300]  Демонстрирую на примере.
[01:21:03.300 --> 01:21:04.300]  Вот смотрите.
[01:21:04.300 --> 01:21:12.300]  Вот у меня допустим есть R-value ссылка на ноль.
[01:21:12.300 --> 01:21:14.300]  Вот у меня есть такая R-value ссылка.
[01:21:14.300 --> 01:21:17.300]  Я написал int2&y равно 0.
[01:21:17.300 --> 01:21:20.300]  И я говорю f от y.
[01:21:20.300 --> 01:21:31.300]  При этом у меня есть f от int&, f от constant& и f от 2&.
[01:21:31.300 --> 01:21:33.300]  Куда я попаду?
[01:21:40.300 --> 01:21:42.300]  Ты именно такой пример сделал.
[01:21:49.300 --> 01:21:53.300]  У тебя функции строки принимают, а я от intа вызываюсь.
[01:21:53.300 --> 01:21:57.300]  Это не важно.
[01:21:57.300 --> 01:22:00.300]  А, значит вопрос.
[01:22:00.300 --> 01:22:01.300]  У меня есть три функции.
[01:22:01.300 --> 01:22:03.300]  Вот такая, такая и такая.
[01:22:03.300 --> 01:22:04.300]  И я написал вот это.
[01:22:04.300 --> 01:22:06.300]  В какую версию я попаду?
[01:22:06.300 --> 01:22:08.300]  Ну да.
[01:22:08.300 --> 01:22:10.300]  Вот не в эту.
[01:22:10.300 --> 01:22:15.300]  Ну, я тут может быть, короче, я не уверен на сто процентов, что в эту...
[01:22:15.300 --> 01:22:19.300]  Вот тут может быть, может быть там есть правило, что какая-то неоднозначная.
[01:22:19.300 --> 01:22:20.300]  Но главное, что не в эту.
[01:22:20.300 --> 01:22:22.300]  Вот самое главное, надо понимать, что не в третью.
[01:22:22.300 --> 01:22:26.300]  Если я напишу так, я попаду куда угодно, но точно не сюда.
[01:22:26.300 --> 01:22:29.300]  Это слово мозги.
[01:22:29.300 --> 01:22:30.300]  Потому что...
[01:22:30.300 --> 01:22:31.300]  Да, что?
[01:22:31.300 --> 01:22:34.300]  А как мы вообще можем во вторую попасть?
[01:22:34.300 --> 01:22:36.300]  Во вторую, я думаю, не можем.
[01:22:36.300 --> 01:22:41.300]  Ну, может я забыл какое-нибудь правило в стандарте, какое-нибудь исключение из правил?
[01:22:41.300 --> 01:22:42.300]  Ты проверил?
[01:22:42.300 --> 01:22:43.300]  Нет, нет, нет.
[01:22:43.300 --> 01:22:45.300]  Ну, проверь, проверь, что мы в первую попадаем.
[01:22:45.300 --> 01:22:48.300]  Почему?
[01:22:49.300 --> 01:22:51.300]  Значит, еще раз.
[01:22:53.300 --> 01:22:55.300]  А почему мы попадаем...
[01:22:55.300 --> 01:22:58.300]  Почему мы точно не в третью попадаем, понимаете?
[01:22:58.300 --> 01:23:00.300]  Потому что Y это не R-value.
[01:23:00.300 --> 01:23:04.300]  Потому что Y это не R-value, а эта штука только от R-value вызывается.
[01:23:04.300 --> 01:23:06.300]  Ну, это K-value.
[01:23:06.300 --> 01:23:08.300]  Y это L-value.
[01:23:08.300 --> 01:23:10.300]  Первый пункт определения L-value, это переменная.
[01:23:10.300 --> 01:23:12.300]  А, это же сдохнет дом.
[01:23:14.300 --> 01:23:17.300]  Это пример очень, просто пример реальной жизни.
[01:23:17.300 --> 01:23:19.300]  Но это же сломает мозг всем.
[01:23:19.300 --> 01:23:22.300]  Да, я же предупреждал.
[01:23:22.300 --> 01:23:24.300]  И что?
[01:23:27.300 --> 01:23:29.300]  По-моему, она в третью попадает.
[01:23:29.300 --> 01:23:31.300]  Нет, в третью, но точно не попадает.
[01:23:31.300 --> 01:23:33.300]  А у меня попадает.
[01:23:33.300 --> 01:23:35.300]  Может, он там тоже снимет?
[01:23:37.300 --> 01:23:39.300]  Я тебе не доверяю.
[01:23:41.300 --> 01:23:43.300]  Она попадает в третью.
[01:23:43.300 --> 01:23:45.300]  Сейчас, ну он пишет локас.
[01:23:45.300 --> 01:23:47.300]  А у нас уже обычный ссылка.
[01:23:47.300 --> 01:23:49.300]  А, у меня третья, это ваша первая.
[01:23:49.300 --> 01:23:51.300]  Угу.
[01:23:51.300 --> 01:23:53.300]  Короче, он попадает в эту.
[01:23:53.300 --> 01:23:56.300]  Блин, как вообще тебе доверять?
[01:23:56.300 --> 01:23:58.300]  Ну-ка дай письмо.
[01:23:58.300 --> 01:24:00.300]  Все нормально.
[01:24:00.300 --> 01:24:02.300]  Да, все.
[01:24:02.300 --> 01:24:04.300]  Мы проверили, что мы попадаем сюда.
[01:24:04.300 --> 01:24:06.300]  Давайте выясним.
[01:24:06.300 --> 01:24:08.300]  Еще раз, вот это очень важный пример.
[01:24:08.300 --> 01:24:10.300]  Видимо, на нем мы сегодня и закончим.
[01:24:10.300 --> 01:24:12.300]  Почему мы попадаем именно сюда?
[01:24:12.300 --> 01:24:14.300]  И не сюда, и не сюда.
[01:24:16.300 --> 01:24:18.300]  Я ломаю, доламываю всем мозг просто.
[01:24:24.300 --> 01:24:26.300]  Мы точно не сюда попадаем,
[01:24:26.300 --> 01:24:28.300]  потому что Y это L-value.
[01:24:28.300 --> 01:24:30.300]  Мы не можем попасть сюда.
[01:24:30.300 --> 01:24:32.300]  Сюда мы попадаем только от R-value.
[01:24:32.300 --> 01:24:34.300]  Дальше у нас варианты.
[01:24:34.300 --> 01:24:36.300]  Мы можем попасть либо сюда, либо сюда.
[01:24:36.300 --> 01:24:38.300]  Но чтобы попасть сюда,
[01:24:38.300 --> 01:24:40.300]  нам нужно сделать дополнительный каст
[01:24:40.300 --> 01:24:42.300]  навесив const.
[01:24:42.300 --> 01:24:44.300]  Мы можем попасть как сюда, так и сюда.
[01:24:44.300 --> 01:24:46.300]  Но попасть сюда, это значит
[01:24:46.300 --> 01:24:48.300]  сделать const-cast, const-intu, неявный.
[01:24:48.300 --> 01:24:50.300]  А сюда мы попадаем
[01:24:50.300 --> 01:24:52.300]  без кастов каких-либо.
[01:24:52.300 --> 01:24:54.300]  Сюда нужно добавить
[01:24:54.300 --> 01:24:56.300]  навесить тип.
[01:24:56.300 --> 01:24:58.300]  Это более частная версия.
[01:24:58.300 --> 01:25:00.300]  Это более общая версия, чем это,
[01:25:00.300 --> 01:25:02.300]  потому что она годится для константных int.
[01:25:02.300 --> 01:25:04.300]  А это только для неконстантных.
[01:25:04.300 --> 01:25:06.300]  А у нас не константный.
[01:25:06.300 --> 01:25:08.300]  У нас же не int, у нас какой-то очень странный тип.
[01:25:08.300 --> 01:25:10.300]  Почему нет кастов?
[01:25:10.300 --> 01:25:12.300]  Почему нет кастов?
[01:25:12.300 --> 01:25:14.300]  Ну, формально,
[01:25:14.300 --> 01:25:16.300]  там
[01:25:16.300 --> 01:25:18.300]  я боюсь, что
[01:25:18.300 --> 01:25:20.300]  я вам очень сильно упрощаю
[01:25:20.300 --> 01:25:22.300]  на самом деле
[01:25:22.300 --> 01:25:24.300]  мир.
[01:25:24.300 --> 01:25:26.300]  Спасибо.
[01:25:28.300 --> 01:25:30.300]  Сейчас я
[01:25:30.300 --> 01:25:32.300]  давайте напоследок.
[01:25:34.300 --> 01:25:36.300]  Ты не помнишь в каком разделе стандарта
[01:25:36.300 --> 01:25:38.300]  написаны правила
[01:25:38.300 --> 01:25:40.300]  выбора версии вот в этих случаях,
[01:25:40.300 --> 01:25:42.300]  в этой ситуации.
[01:25:42.300 --> 01:25:44.300]  Сейчас я попробую.
[01:25:56.300 --> 01:25:58.300]  Давайте откроем главу
[01:25:58.300 --> 01:26:00.300]  overloading, 276-я страница.
[01:26:02.300 --> 01:26:04.300]  Тут в стандарте есть
[01:26:04.300 --> 01:26:06.300]  параграф.
[01:26:30.300 --> 01:26:32.300]  Где тут эта
[01:26:32.300 --> 01:26:34.300]  эта штука?
[01:27:02.300 --> 01:27:04.300]  Ладно, я не найду быстро.
[01:27:04.300 --> 01:27:06.300]  Ну, в общем, вы можете открыть главу
[01:27:06.300 --> 01:27:08.300]  16-ю в стандарте, overloading она
[01:27:08.300 --> 01:27:10.300]  называется, она занимает страниц 30.
[01:27:10.300 --> 01:27:12.300]  И там, значит, все формально
[01:27:12.300 --> 01:27:14.300]  описано, включая правила, как быть,
[01:27:14.300 --> 01:27:16.300]  если у вас вот всякие ссылки
[01:27:16.300 --> 01:27:18.300]  и прочее.
[01:27:24.300 --> 01:27:26.300]  Без амперсантов.
[01:27:26.300 --> 01:27:28.300]  Да, это airvalue будет.
[01:27:32.300 --> 01:27:34.300]  Если
[01:27:34.300 --> 01:27:36.300]  написать вот так,
[01:27:38.300 --> 01:27:40.300]  то да, мы попадем
[01:27:40.300 --> 01:27:42.300]  вот в эту версию.
[01:27:42.300 --> 01:27:44.300]  А если мы напишем вот так, то мы попадем в эту версию.
[01:27:44.300 --> 01:27:46.300]  Это не очень логично,
[01:27:46.300 --> 01:27:48.300]  потому что, по идее,
[01:27:48.300 --> 01:27:50.300]  каст к тому же типу, который
[01:27:50.300 --> 01:27:52.300]  есть, не должен менять.
[01:27:52.300 --> 01:27:54.300]  Он меняет категорию expression.
[01:27:56.300 --> 01:27:58.300]  Все, давайте на сегодня закончим, значит.
[01:27:58.300 --> 01:28:00.300]  Живите с этим пока, как хотите.
[01:28:00.300 --> 01:28:02.300]  Можете накопить вопросов,
[01:28:02.300 --> 01:28:04.300]  в следующий раз мы о них ответим.
[01:28:04.300 --> 01:28:06.300]  Ну вот пока живите с этим.
[01:28:10.300 --> 01:28:12.300]  Мы начинаем главу 11-ю.
[01:28:12.300 --> 01:28:14.300]  Торжественно открываем. Вывод типов.
[01:28:16.300 --> 01:28:18.300]  Так как у нас формально семинары,
[01:28:18.300 --> 01:28:20.300]  все-таки вопросы какие-то.
[01:28:20.300 --> 01:28:22.300]  Вы вообще
[01:28:22.300 --> 01:28:24.300]  подробно разбирали,
[01:28:24.300 --> 01:28:26.300]  как выводится тип шавлонного
[01:28:26.300 --> 01:28:28.300]  аргумента?
[01:28:30.300 --> 01:28:32.300]  Ну типа, если вы напишете какую-то функцию,
[01:28:32.300 --> 01:28:34.300]  template, type name,
[01:28:34.300 --> 01:28:36.300]  t, void,
[01:28:36.300 --> 01:28:38.300]  f, t, x, return,
[01:28:38.300 --> 01:28:40.300]  x, нет, не return,
[01:28:40.300 --> 01:28:42.300]  x, не суть. Вы понимаете,
[01:28:42.300 --> 01:28:44.300]  как это t,
[01:28:44.300 --> 01:28:46.300]  в каких случаях, к чему он равен?
[01:28:46.300 --> 01:28:48.300]  Хоть какое-то представление.
[01:28:52.300 --> 01:28:54.300]  Ну хоть в каком-то плане.
[01:28:54.300 --> 01:28:56.300]  Я, например, вопрос
[01:28:56.300 --> 01:28:58.300]  плохо понимаю.
[01:28:58.300 --> 01:29:00.300]  Окей, хорошо.
[01:29:00.300 --> 01:29:02.300]  Ну сейчас тогда выясним. Смотрите.
[01:29:02.300 --> 01:29:04.300]  Собственно,
[01:29:04.300 --> 01:29:06.300]  11.1 пункт,
[01:29:06.300 --> 01:29:08.300]  это ключевое
[01:29:08.300 --> 01:29:10.300]  слово авто
[01:29:10.300 --> 01:29:12.300]  в его, да.
[01:29:12.300 --> 01:29:14.300]  Сейчас там глава 11,
[01:29:14.300 --> 01:29:16.300]  типа параграф 1 или как, не так у нас.
[01:29:16.300 --> 01:29:18.300]  Кто заполнил телефон?
[01:29:18.300 --> 01:29:20.300]  Там лежал
[01:29:20.300 --> 01:29:22.300]  девайс.
[01:29:24.300 --> 01:29:26.300]  Вот.
[01:29:26.300 --> 01:29:28.300]  Собственно,
[01:29:28.300 --> 01:29:30.300]  у ключевого слова авто, на самом деле,
[01:29:30.300 --> 01:29:32.300]  есть несколько смыслов. Его смыслы менялись
[01:29:32.300 --> 01:29:34.300]  с...
[01:29:34.300 --> 01:29:36.300]  Закройте
[01:29:36.300 --> 01:29:38.300]  дверь-то, пожалуйста, в итоге.
[01:29:38.300 --> 01:29:40.300]  Вот.
[01:29:40.300 --> 01:29:42.300]  Смысл ключевого слова авто,
[01:29:42.300 --> 01:29:44.300]  на самом деле, менялись с развитием языка.
[01:29:44.300 --> 01:29:46.300]  Сейчас
[01:29:46.300 --> 01:29:48.300]  у него есть
[01:29:48.300 --> 01:29:50.300]  основных
[01:29:50.300 --> 01:29:52.300]  три значения, с которых мы на два
[01:29:52.300 --> 01:29:54.300]  сегодня посмотрим.
[01:29:54.300 --> 01:29:56.300]  Третью уже, наверное, не успеем.
[01:29:56.300 --> 01:29:58.300]  Какой этап называется официально?
[01:29:58.300 --> 01:30:00.300]  11 вывод
[01:30:00.300 --> 01:30:02.300]  типов, 11.1
[01:30:02.300 --> 01:30:04.300]  авто.
[01:30:08.300 --> 01:30:10.300]  Вот.
[01:30:10.300 --> 01:30:12.300]  Сейчас посмотрим на
[01:30:14.300 --> 01:30:16.300]  первое.
[01:30:16.300 --> 01:30:18.300]  Это, значит, так называемый
[01:30:18.300 --> 01:30:20.300]  placeholder, то есть такое
[01:30:20.300 --> 01:30:22.300]  слово, которое заменяет произвольный тип.
[01:30:22.300 --> 01:30:24.300]  То есть, ну...
[01:30:24.300 --> 01:30:26.300]  И простейшее
[01:30:26.300 --> 01:30:28.300]  его...
[01:30:28.300 --> 01:30:30.300]  Разберись сам, с чем мы это называем.
[01:30:30.300 --> 01:30:32.300]  Ну, более-менее.
[01:30:32.300 --> 01:30:34.300]  Сейчас рассмотрим, что мы конкретно
[01:30:34.300 --> 01:30:36.300]  говорим компилятору. Значит, есть
[01:30:36.300 --> 01:30:38.300] , наверное, три основных варианта,
[01:30:38.300 --> 01:30:40.300]  как в такой ипостасе, для меня это слово авто.
[01:30:40.300 --> 01:30:42.300]  Первое, это в параметрах функций.
[01:30:42.300 --> 01:30:44.300]  Значит, смотрите.
[01:30:44.300 --> 01:30:46.300]  Вот. Я решил начать
[01:30:46.300 --> 01:30:48.300]  с этого, хотя это, на самом деле, самое позднее
[01:30:48.300 --> 01:30:50.300]  из введений. То есть оно...
[01:30:50.300 --> 01:30:52.300]  Вот такой синтаксис появился в 20-м
[01:30:52.300 --> 01:30:54.300]  стандарте, но, мне кажется, его проще всего понять.
[01:30:54.300 --> 01:30:56.300]  Почему? Потому что это
[01:30:56.300 --> 01:30:58.300]  просто, вот, эквивалентно
[01:30:58.300 --> 01:31:00.300]  тому, что мы напишем...
[01:31:08.300 --> 01:31:10.300]  Что такое string?
[01:31:10.300 --> 01:31:12.300]  Ну, считай, что string.
[01:31:12.300 --> 01:31:14.300]  Не суть.
[01:31:14.300 --> 01:31:16.300]  Здесь это не принципиально.
[01:31:18.300 --> 01:31:20.300]  Вот.
[01:31:20.300 --> 01:31:22.300]  Значит, вот запись ниже.
[01:31:22.300 --> 01:31:24.300]  Ну, все-таки я напишу string view, чтобы было
[01:31:24.300 --> 01:31:26.300]  одинаково.
[01:31:26.300 --> 01:31:28.300]  Если коротко, то это не владеющая строка.
[01:31:30.300 --> 01:31:32.300]  Вот запись
[01:31:32.300 --> 01:31:34.300]  на 14 строке просто
[01:31:34.300 --> 01:31:36.300]  раскрывается в запись на 9 и 10
[01:31:36.300 --> 01:31:38.300]  строке.
[01:31:38.300 --> 01:31:40.300]  Вот это самое простое, что происходит.
[01:31:42.300 --> 01:31:44.300]  Абсолютно эквивалентные вещи.
[01:31:44.300 --> 01:31:46.300]  Соответственно,
[01:31:46.300 --> 01:31:48.300]  мы можем навесить конст,
[01:31:48.300 --> 01:31:50.300]  навесить конст на персант.
[01:31:50.300 --> 01:31:52.300]  Ну, нет,
[01:31:52.300 --> 01:31:54.300]  не при процессор,
[01:31:54.300 --> 01:31:56.300]  это уже делает компилятор.
[01:31:56.300 --> 01:31:58.300]  При процессор занимается только макросами и всякими
[01:31:58.300 --> 01:32:00.300]  директивами по хэштегу.
[01:32:00.300 --> 01:32:02.300]  По решетке.
[01:32:02.300 --> 01:32:04.300]  Это уже встроено в язык, это круче, чем макросы,
[01:32:04.300 --> 01:32:06.300]  но это вот такое преобразование
[01:32:06.300 --> 01:32:08.300]  кода.
[01:32:12.300 --> 01:32:14.300]  Ну, я утверждаю, что такое.
[01:32:14.300 --> 01:32:16.300]  Что ты имеешь ввиду?
[01:32:16.300 --> 01:32:18.300]  Ну, только, ну в смысле tail у вас не будет.
[01:32:18.300 --> 01:32:20.300]  Какое-то имя
[01:32:20.300 --> 01:32:22.300]  для этого типа придумается,
[01:32:22.300 --> 01:32:24.300]  для этого шаблонного аргумента,
[01:32:24.300 --> 01:32:26.300]  но вы его не знаете.
[01:32:26.300 --> 01:32:28.300]  Есть вопрос, что если у нас
[01:32:28.300 --> 01:32:30.300]  стрек функция, как сейчас
[01:32:30.300 --> 01:32:32.300]  на 10-й строке, то есть мы ее можем вызывать
[01:32:32.300 --> 01:32:34.300]  в целом для
[01:32:34.300 --> 01:32:36.300]  разных типов данных, и она просто
[01:32:36.300 --> 01:32:38.300]  будет новая создаваться
[01:32:38.300 --> 01:32:40.300]  каждый раз.
[01:32:40.300 --> 01:32:42.300]  Это все, все еще происходит на темпе компиляции.
[01:32:42.300 --> 01:32:44.300]  На самом деле, посмотрите, как это все работает.
[01:32:46.300 --> 01:32:48.300]  Это я написал просто функцию, чтобы меньше
[01:32:48.300 --> 01:32:50.300]  занимать времени и места
[01:32:50.300 --> 01:32:52.300]  на экране. Она принтирует строку
[01:32:52.300 --> 01:32:54.300]  двоеточие, тоже справа.
[01:32:54.300 --> 01:32:56.300]  То, что справа...
[01:32:56.300 --> 01:32:58.300]  Давайте посмотрим, что делает функция f,
[01:32:58.300 --> 01:33:00.300]  чтобы мы поняли, что я с ней собираюсь делать.
[01:33:00.300 --> 01:33:02.300]  Она принимает аргумент и возвращает
[01:33:02.300 --> 01:33:04.300]  название его типа. Это тоже кастомная
[01:33:04.300 --> 01:33:06.300]  штука, я написал.
[01:33:06.300 --> 01:33:08.300]  Она немножко...
[01:33:08.300 --> 01:33:10.300]  Если останется время, посмотрим.
[01:33:10.300 --> 01:33:12.300]  Она возвращает прям строкой имя типа
[01:33:14.300 --> 01:33:16.300]  вот, аргумента.
[01:33:16.300 --> 01:33:18.300]  Вот, соответственно,
[01:33:18.300 --> 01:33:20.300]  можем в таком случае
[01:33:20.300 --> 01:33:22.300]  посмотреть.
[01:33:22.300 --> 01:33:24.300]  Как вы считаете, что...
[01:33:24.300 --> 01:33:26.300]  Несколько простых примеров, чтобы я проверил,
[01:33:26.300 --> 01:33:28.300]  чтобы вы не спите. Вот f от единицы, что
[01:33:28.300 --> 01:33:30.300]  вернет?
[01:33:30.300 --> 01:33:32.300]  Int. Справедливо.
[01:33:32.300 --> 01:33:34.300]  Там, значит, если я...
[01:33:34.300 --> 01:33:36.300]  Вот у меня есть const integer, это
[01:33:36.300 --> 01:33:38.300]  для всех примеров сегодняшних будет
[01:33:38.300 --> 01:33:40.300]  есть const integer и массив
[01:33:40.300 --> 01:33:42.300]  с пяти интов.
[01:33:42.300 --> 01:33:44.300]  Вот, если я функцию передаю
[01:33:44.300 --> 01:33:46.300]  const integer,
[01:33:46.300 --> 01:33:48.300]  просто const int, const integer
[01:33:48.300 --> 01:33:50.300]  равно 1. Что вы увидите?
[01:33:50.300 --> 01:33:52.300]  const int.
[01:33:52.300 --> 01:33:54.300]  После этого
[01:33:54.300 --> 01:33:56.300]  возникает вопрос. Илья, ты рассказывал им,
[01:33:56.300 --> 01:33:58.300]  как появляются шаблонные
[01:33:58.300 --> 01:34:00.300]  типы?
[01:34:00.300 --> 01:34:02.300]  Нет? Хорошо.
[01:34:02.300 --> 01:34:04.300]  Тогда я должен
[01:34:04.300 --> 01:34:06.300]  сказать, что
[01:34:06.300 --> 01:34:08.300]  значит, на самом деле
[01:34:08.300 --> 01:34:10.300]  будет не const int.
[01:34:12.300 --> 01:34:14.300]  На самом деле будет просто int.
[01:34:16.300 --> 01:34:18.300]  И это то, почему
[01:34:18.300 --> 01:34:20.300]  нужно об этом поговорить чуть поподробнее.
[01:34:20.300 --> 01:34:22.300]  Смотрите, какие правила?
[01:34:22.300 --> 01:34:24.300]  Правил много, как всегда, но
[01:34:24.300 --> 01:34:26.300]  основные следующие. Если у вас
[01:34:26.300 --> 01:34:28.300]  тип не ссылочный,
[01:34:28.300 --> 01:34:30.300]  у него
[01:34:30.300 --> 01:34:32.300]  отбрасываются
[01:34:32.300 --> 01:34:34.300]  CV-квалификаторы.
[01:34:36.300 --> 01:34:38.300]  const volatile.
[01:34:38.300 --> 01:34:40.300]  const отбрасывается, про volatile
[01:34:40.300 --> 01:34:42.300]  мы, скорее всего, не говорили.
[01:34:44.300 --> 01:34:46.300]  Но const, что важно, отбрасывается
[01:34:46.300 --> 01:34:48.300]  тот, который самый внешний.
[01:34:48.300 --> 01:34:50.300]  Что это значит?
[01:34:50.300 --> 01:34:52.300]  Если я передам в f,
[01:35:00.300 --> 01:35:02.300]  я передам
[01:35:02.300 --> 01:35:04.300]  что-то вроде
[01:35:04.300 --> 01:35:06.300]  const int
[01:35:06.300 --> 01:35:08.300]  звездочка
[01:35:08.300 --> 01:35:10.300]  const pter.
[01:35:12.300 --> 01:35:14.300]  Вот
[01:35:14.300 --> 01:35:16.300]  что здесь вы видите?
[01:35:18.300 --> 01:35:20.300]  const int звездочка, правильно.
[01:35:22.300 --> 01:35:24.300]  Если же тип
[01:35:24.300 --> 01:35:26.300]  ссылочный,
[01:35:26.300 --> 01:35:28.300]  вернется то, что под ссылкой
[01:35:28.300 --> 01:35:30.300]  не сама ссылка.
[01:35:30.300 --> 01:35:32.300]  Вот.
[01:35:32.300 --> 01:35:34.300]  То есть ссылки тоже отбрасываются,
[01:35:34.300 --> 01:35:36.300]  когда мы вводим...
[01:35:40.300 --> 01:35:42.300]  Ну,
[01:35:42.300 --> 01:35:44.300]  известным, наверное, вам исключением.
[01:35:44.300 --> 01:35:46.300]  Что такое универсальная ссылка, вы же знаете?
[01:35:46.300 --> 01:35:48.300]  Нет.
[01:35:48.300 --> 01:35:50.300]  Вы не успели.
[01:35:50.300 --> 01:35:52.300]  Тогда за одним исключением.
[01:35:52.300 --> 01:35:54.300]  Нет.
[01:35:54.300 --> 01:35:56.300]  Это не xv.
[01:35:56.300 --> 01:35:58.300]  Сейчас
[01:35:58.300 --> 01:36:00.300]  перейдемся.
[01:36:00.300 --> 01:36:02.300]  Значит, смотрите, есть
[01:36:02.300 --> 01:36:04.300]  в языке особая запись.
[01:36:04.300 --> 01:36:06.300]  Давайте перейдем сейчас, тогда посмотрим.
[01:36:06.300 --> 01:36:08.300]  Мы можем написать
[01:36:14.300 --> 01:36:16.300]  вот так.
[01:36:22.300 --> 01:36:24.300]  Вот.
[01:36:24.300 --> 01:36:26.300]  И это особая конструкция языка внезапно,
[01:36:26.300 --> 01:36:28.300]  которая работает не так, как обычно.
[01:36:32.300 --> 01:36:34.300]  Так, ладно, я не буду.
[01:36:34.300 --> 01:36:36.300]  Давайте напишу.
[01:36:40.300 --> 01:36:42.300]  Чтобы
[01:36:42.300 --> 01:36:44.300]  он не ругался.
[01:36:44.300 --> 01:36:46.300]  На что ругался? На то, что у меня не
[01:36:46.300 --> 01:36:48.300]  использована переменная. Видите?
[01:36:48.300 --> 01:36:50.300]  Желтенькое. Желтенькое плохо.
[01:36:50.300 --> 01:36:52.300]  Нет, желтенького хорошо.
[01:36:52.300 --> 01:36:54.300]  Asystile это хорошо, да?
[01:36:54.300 --> 01:36:56.300]  Просто если я напишу как надо,
[01:36:56.300 --> 01:36:58.300]  у вас будет еще больше вопросов.
[01:37:00.300 --> 01:37:02.300]  Нет, к такому вопросов нет.
[01:37:02.300 --> 01:37:04.300]  Ну, хорошо.
[01:37:04.300 --> 01:37:06.300]  Окей, не суть.
[01:37:06.300 --> 01:37:08.300]  Суть в чем?
[01:37:08.300 --> 01:37:10.300]  Суть в том, что
[01:37:10.300 --> 01:37:12.300]  когда у нас написано вот так,
[01:37:12.300 --> 01:37:14.300]  именно так, никаких дополнительных
[01:37:14.300 --> 01:37:16.300]  констов, именно rvalue ссылка,
[01:37:16.300 --> 01:37:18.300]  и это именно шаблонный аргумент,
[01:37:18.300 --> 01:37:20.300]  после которого стоит два амперсанда.
[01:37:20.300 --> 01:37:22.300]  Это универсальная ссылка, она
[01:37:22.300 --> 01:37:24.300]  выводится по другим правилам.
[01:37:24.300 --> 01:37:26.300]  И она внезапно,
[01:37:26.300 --> 01:37:28.300]  тип, который вы получите в value,
[01:37:28.300 --> 01:37:30.300]  будет зависеть от того,
[01:37:30.300 --> 01:37:32.300]  какую категорию выражения
[01:37:32.300 --> 01:37:34.300]  вы передадите в функцию.
[01:37:38.300 --> 01:37:40.300]  Обычно у вас тип
[01:37:40.300 --> 01:37:42.300]  от категории не зависит. Здесь зависит.
[01:37:46.300 --> 01:37:48.300]  Соответственно, если коротко,
[01:37:48.300 --> 01:37:50.300]  то если вы передадите
[01:37:50.300 --> 01:37:52.300]  в эту функцию rvalue,
[01:37:52.300 --> 01:37:54.300]  то у value будет тип t2 амперсанда.
[01:37:54.300 --> 01:37:56.300]  Если вы передадите функцию
[01:37:56.300 --> 01:37:58.300]  lvalue, у value будет тип
[01:37:58.300 --> 01:38:00.300]  10%.
[01:38:06.300 --> 01:38:08.300]  Не совсем.
[01:38:08.300 --> 01:38:10.300]  В смысле, да, правила сложения
[01:38:10.300 --> 01:38:12.300]  амперсандов там есть, но то,
[01:38:12.300 --> 01:38:14.300]  как выводится сам по себе t,
[01:38:16.300 --> 01:38:18.300]  ломает правило то, как обычно
[01:38:18.300 --> 01:38:20.300]  выводится.
[01:38:24.300 --> 01:38:26.300]  Если туда передать const int
[01:38:26.300 --> 01:38:28.300]  амперсант,
[01:38:28.300 --> 01:38:30.300]  то будет именно он.
[01:38:34.300 --> 01:38:36.300]  К чему я это сказал? К тому,
[01:38:36.300 --> 01:38:38.300]  что это правило, в том числе
[01:38:38.300 --> 01:38:40.300]  работает с авто.
[01:38:40.300 --> 01:38:42.300]  Соответственно, эта функция
[01:38:44.300 --> 01:38:46.300]  работает по тем же правилам.
[01:38:48.300 --> 01:38:50.300]  Сейчас мы посмотрим чуть подробнее.
[01:39:00.300 --> 01:39:02.300]  Сейчас посмотрим чуть подробнее.
[01:39:02.300 --> 01:39:04.300]  Давайте дойдем здесь до конца.
[01:39:06.300 --> 01:39:08.300]  Как думаете, что выведет
[01:39:08.300 --> 01:39:10.300]  это f?
[01:39:12.300 --> 01:39:14.300]  Нет, это она, к сожалению, не выведет.
[01:39:18.300 --> 01:39:20.300]  Мы передали lvalue.
[01:39:20.300 --> 01:39:22.300]  Я напомню, что f пока просто
[01:39:22.300 --> 01:39:24.300]  авто.
[01:39:24.300 --> 01:39:26.300]  Что?
[01:39:26.300 --> 01:39:28.300]  Статик?
[01:39:32.300 --> 01:39:34.300]  const char звездочка, все правильно.
[01:39:38.300 --> 01:39:40.300]  Смотри, здесь главный тип,
[01:39:40.300 --> 01:39:42.300]  это звездочка, самый внешний.
[01:39:42.300 --> 01:39:44.300]  Поэтому он бы убрал вот этот
[01:39:44.300 --> 01:39:46.300]  const, но не внутренний.
[01:39:48.300 --> 01:39:50.300]  Итак,
[01:39:50.300 --> 01:39:52.300]  int.
[01:39:52.300 --> 01:39:54.300]  Напомните, как выглядят int?
[01:39:54.300 --> 01:39:56.300]  Да, это массив
[01:39:56.300 --> 01:39:58.300]  из пяти int.
[01:39:58.300 --> 01:40:00.300]  Видите сверху?
[01:40:00.300 --> 01:40:02.300]  int звездочка или
[01:40:02.300 --> 01:40:04.300]  квадратные скобки?
[01:40:04.300 --> 01:40:06.300]  int звездочка или квадратные скобки?
[01:40:06.300 --> 01:40:08.300]  Смотрите,
[01:40:08.300 --> 01:40:10.300]  я могу рассказать следующее.
[01:40:10.300 --> 01:40:12.300]  Здесь в начале программы всегда будут
[01:40:12.300 --> 01:40:14.300]  вводиться типы каких-то базовых вещей,
[01:40:14.300 --> 01:40:16.300]  какие они есть. Здесь выведется
[01:40:16.300 --> 01:40:18.300]  на самом деле int 5.
[01:40:22.300 --> 01:40:24.300]  Несмотря на это, вот здесь
[01:40:24.300 --> 01:40:26.300]  действительно выведется int звездочка.
[01:40:26.300 --> 01:40:28.300]  Потому что это еще одно правило вывода аргументов.
[01:40:28.300 --> 01:40:30.300]  Если мы получаем массив, мы его
[01:40:30.300 --> 01:40:32.300]  дикеем к указателю.
[01:40:32.300 --> 01:40:34.300]  Именно стишный массив.
[01:40:34.300 --> 01:40:36.300]  Просто вот такое правило
[01:40:36.300 --> 01:40:38.300]  у вывода шаблонных аргументов.
[01:40:38.300 --> 01:40:40.300]  Это когда мы функции получаем,
[01:40:40.300 --> 01:40:42.300]  в смысле, если как шаблон мы получаем
[01:40:42.300 --> 01:40:44.300]  массив, то мы считаем, что это указание?
[01:40:44.300 --> 01:40:46.300]  Когда еще раз
[01:40:46.300 --> 01:40:48.300]  как выведется type?
[01:40:48.300 --> 01:40:50.300]  Потом.
[01:40:50.300 --> 01:40:52.300]  Она с помощью
[01:40:52.300 --> 01:40:54.300]  некоторой магии возвращает имя типа.
[01:40:54.300 --> 01:40:56.300]  Пока мы не знаем, как она выглядит.
[01:40:56.300 --> 01:40:58.300]  Когда у нас еще раз массив,
[01:40:58.300 --> 01:41:00.300]  когда у нас
[01:41:00.300 --> 01:41:02.300]  случай, когда массив не указатель,
[01:41:02.300 --> 01:41:04.300]  не очень было видно по коду.
[01:41:04.300 --> 01:41:06.300]  В смысле, массив не указатель.
[01:41:06.300 --> 01:41:08.300]  Вот смотри, здесь int.
[01:41:08.300 --> 01:41:10.300]  А, когда я просто вызываю
[01:41:10.300 --> 01:41:12.300]  вот здесь, я просто вызываю
[01:41:12.300 --> 01:41:14.300]  type of int. Он выведет int 5.
[01:41:14.300 --> 01:41:16.300]  А там мы что делаем?
[01:41:16.300 --> 01:41:18.300]  Что, где мы что делаем?
[01:41:18.300 --> 01:41:20.300]  В предыдущем коне мы тоже
[01:41:20.300 --> 01:41:22.300]  написали. А, здесь мы вызываем f от int.
[01:41:22.300 --> 01:41:24.300]  f выводит тип
[01:41:24.300 --> 01:41:26.300]  и вот видите f. f выводит
[01:41:26.300 --> 01:41:28.300]  тип
[01:41:28.300 --> 01:41:30.300]  от аргумента. Аргумент она
[01:41:30.300 --> 01:41:32.300]  преобразует в int звездочку.
[01:41:32.300 --> 01:41:34.300]  Вот.
[01:41:34.300 --> 01:41:36.300]  typeof это функция,
[01:41:36.300 --> 01:41:38.300]  которую просто типа делает. typeof
[01:41:38.300 --> 01:41:40.300]  да. Это функция
[01:41:40.300 --> 01:41:42.300]  нет. Это моя функция.
[01:41:42.300 --> 01:41:44.300]  Которую я частично стыдил
[01:41:44.300 --> 01:41:46.300]  стасакой и рухлоу.
[01:41:46.300 --> 01:41:48.300]  Просто это немного странно. Ты говоришь, вот мы запихем тип
[01:41:48.300 --> 01:41:50.300]  в мою функцию и получаем вот это.
[01:41:50.300 --> 01:41:52.300]  Нет. Ну, в смысле
[01:41:52.300 --> 01:41:54.300]  я говорю, ну пока примите, что это
[01:41:54.300 --> 01:41:56.300]  магическая штука, которая принимает значение
[01:41:56.300 --> 01:41:58.300]  и возвращает его тип.
[01:41:58.300 --> 01:42:00.300]  Строкой.
[01:42:04.300 --> 01:42:06.300]  Но она не очень красиво сделана. Там просто на макросах.
[01:42:06.300 --> 01:42:08.300]  Так, ну
[01:42:08.300 --> 01:42:10.300]  пока это особо красивее не сделаешь.
[01:42:12.300 --> 01:42:14.300]  Не суть.
[01:42:16.300 --> 01:42:18.300]  Вот то, что она возвращает, это просто для визуализации
[01:42:18.300 --> 01:42:20.300]  и потом проверим, что все правильно. Вот.
[01:42:20.300 --> 01:42:22.300]  Что еще?
[01:42:22.300 --> 01:42:24.300]  Значит, смотрите, у нас есть f от add.
[01:42:24.300 --> 01:42:26.300]  add это что? add.
[01:42:26.300 --> 01:42:28.300]  Смотри, add это функция. Она говорит, что
[01:42:28.300 --> 01:42:30.300]  складывает, но она врет, но это не важно.
[01:42:30.300 --> 01:42:32.300]  Вот. Это функция, которая принимает
[01:42:32.300 --> 01:42:34.300]  int со ст возвращает ноль.
[01:42:34.300 --> 01:42:36.300]  Если вы помните, у нас в прошлом семестре была
[01:42:36.300 --> 01:42:38.300]  контрольная, на которой нужно было написать тип
[01:42:38.300 --> 01:42:40.300]  функции, которая принимает массивы, вот это вот все.
[01:42:40.300 --> 01:42:42.300]  Вот. Очень
[01:42:42.300 --> 01:42:44.300]  удобно, когда есть авто, и не нужно этого делать.
[01:42:44.300 --> 01:42:46.300]  И можно просто
[01:42:46.300 --> 01:42:48.300]  передать функцию, которая принимает
[01:42:48.300 --> 01:42:50.300]  штуки, возвращает int.
[01:42:50.300 --> 01:42:52.300]  И...
[01:42:52.300 --> 01:42:54.300]  И посмотреть тип. Нам разве
[01:42:54.300 --> 01:42:56.300]  указательна функция?
[01:42:58.300 --> 01:43:00.300]  Функции и указательна
[01:43:00.300 --> 01:43:02.300]  функцию кастуются к друг другу очень просто.
[01:43:02.300 --> 01:43:04.300]  Не нужно для этого специально ничего делать.
[01:43:04.300 --> 01:43:06.300]  Вот.
[01:43:06.300 --> 01:43:08.300]  Да, ну, смотрите,
[01:43:08.300 --> 01:43:10.300]  вот что сейчас вы видите? Это все
[01:43:10.300 --> 01:43:12.300]  скомпилируется.
[01:43:12.300 --> 01:43:14.300]  Вот. Смотрите, мы вызываем f от add.
[01:43:22.300 --> 01:43:24.300]  Вот.
[01:43:24.300 --> 01:43:26.300]  Кажется, что здесь оно тоже
[01:43:26.300 --> 01:43:28.300]  кастанется на самом деле автоматически
[01:43:28.300 --> 01:43:30.300]  из вывода типов к...
[01:43:30.300 --> 01:43:32.300]  Ну, и это будет не sizeT
[01:43:32.300 --> 01:43:34.300]  на самом деле, потому что sizeT это просто
[01:43:34.300 --> 01:43:36.300]  using. Настоящий тип там
[01:43:36.300 --> 01:43:38.300]  unsigned
[01:43:38.300 --> 01:43:40.300]  long.
[01:43:40.300 --> 01:43:42.300]  Да. Ну, на моей машине
[01:43:42.300 --> 01:43:44.300]  так. Ну, на моей машине так кажется.
[01:43:44.300 --> 01:43:46.300]  Да.
[01:43:46.300 --> 01:43:48.300]  Никто не запрещает.
[01:43:48.300 --> 01:43:50.300]  Вот.
[01:43:50.300 --> 01:43:52.300]  Значит дальше,
[01:43:52.300 --> 01:43:54.300]  смотрите, у меня есть вторая категория.
[01:43:54.300 --> 01:43:56.300]  Мы функцию f меняем, добавляя
[01:43:56.300 --> 01:43:58.300]  к ней вот здесь const.
[01:44:00.300 --> 01:44:02.300]  Ну, соответственно,
[01:44:02.300 --> 01:44:04.300]  давайте быстро.
[01:44:06.300 --> 01:44:08.300]  const int, верно.
[01:44:08.300 --> 01:44:10.300]  const integer.
[01:44:10.300 --> 01:44:12.300]  const int снова.
[01:44:12.300 --> 01:44:14.300]  Что логично, как бы.
[01:44:14.300 --> 01:44:16.300]  Но нужно помнить, что раньше это было не так.
[01:44:16.300 --> 01:44:18.300]  Вот. Здесь что будет?
[01:44:20.300 --> 01:44:22.300]  char звездочка const,
[01:44:22.300 --> 01:44:24.300]  все так.
[01:44:24.300 --> 01:44:26.300]  C,
[01:44:26.300 --> 01:44:28.300]  int звездочка const.
[01:44:28.300 --> 01:44:30.300]  Только что показывал CF.
[01:44:30.300 --> 01:44:32.300]  CF это как f, только перед авто const стоит.
[01:44:32.300 --> 01:44:34.300]  int звездочка
[01:44:34.300 --> 01:44:36.300]  const, нет?
[01:44:36.300 --> 01:44:38.300]  int звездочка
[01:44:38.300 --> 01:44:40.300]  const.
[01:44:40.300 --> 01:44:42.300]  Ну, мы же набрасываем на верхний тип const.
[01:44:42.300 --> 01:44:44.300]  int звездочка const. Окей.
[01:44:44.300 --> 01:44:46.300]  Сейчас посмотрим.
[01:44:46.300 --> 01:44:48.300]  И add.
[01:44:48.300 --> 01:44:50.300]  Вот здесь что будет?
[01:44:50.300 --> 01:44:52.300]  Тоже очень простое упражнение,
[01:44:52.300 --> 01:44:54.300]  на самом деле. Никого под лоха.
[01:44:58.300 --> 01:45:00.300]  Все, все так.
[01:45:00.300 --> 01:45:02.300]  У нас const просто добавится
[01:45:02.300 --> 01:45:04.300]  после звездочки.
[01:45:10.300 --> 01:45:12.300]  Вот.
[01:45:12.300 --> 01:45:14.300]  const добавится вот сюда.
[01:45:14.300 --> 01:45:16.300]  Вот.
[01:45:16.300 --> 01:45:18.300]  И, значит,
[01:45:18.300 --> 01:45:20.300]  в последний случай добавляется
[01:45:20.300 --> 01:45:22.300]  ampersand auto.
[01:45:26.300 --> 01:45:28.300]  Добавляется ampersand auto.
[01:45:28.300 --> 01:45:30.300]  Ну, наверное,
[01:45:30.300 --> 01:45:32.300]  можем, на самом деле, пока запустить,
[01:45:32.300 --> 01:45:34.300]  посмотреть, что у нас сейчас получилось.
[01:45:38.300 --> 01:45:40.300]  Ну, ничего страшного.
[01:45:40.300 --> 01:45:42.300]  Значит, посмотрим то, что надо.
[01:45:42.300 --> 01:45:44.300]  Значит, смотрите, вот у нас.
[01:45:44.300 --> 01:45:46.300]  Какие типы были? int literal, int
[01:45:46.300 --> 01:45:48.300]  string literal внезапно.
[01:45:48.300 --> 01:45:50.300]  Это не char звездочка,
[01:45:50.300 --> 01:45:52.300]  а вообще это тоже массив.
[01:45:54.300 --> 01:45:56.300]  int и это int 5, как я обещал.
[01:45:56.300 --> 01:45:58.300]  И const и даже const int.
[01:45:58.300 --> 01:46:00.300]  Значит, первая секция.
[01:46:02.300 --> 01:46:04.300]  const звездочка.
[01:46:04.300 --> 01:46:06.300]  Сошлось. int literal int int
[01:46:06.300 --> 01:46:08.300]  const char звездочка int вот.
[01:46:08.300 --> 01:46:10.300]  Здесь все тоже сошлось.
[01:46:10.300 --> 01:46:12.300]  Почти.
[01:46:12.300 --> 01:46:14.300]  Да.
[01:46:14.300 --> 01:46:16.300]  Не long int.
[01:46:16.300 --> 01:46:18.300]  Long int, да.
[01:46:18.300 --> 01:46:20.300]  Дальше мы добавили const.
[01:46:20.300 --> 01:46:22.300]  Везде навесилось const.
[01:46:22.300 --> 01:46:24.300]  И вот сюда добавилось const.
[01:46:28.300 --> 01:46:30.300]  Да, кажется, сошлось.
[01:46:30.300 --> 01:46:32.300]  Значит, const auto.
[01:46:34.300 --> 01:46:36.300]  Здесь, на самом деле, начинаются некоторые
[01:46:36.300 --> 01:46:38.300]  хитрости, потому что, как я уже говорил,
[01:46:38.300 --> 01:46:40.300]  если мы принимаем
[01:46:40.300 --> 01:46:42.300]  по имперсанду...
[01:46:44.300 --> 01:46:46.300]  Ну, давайте посмотрим.
[01:46:46.300 --> 01:46:48.300]  Что будет здесь?
[01:46:48.300 --> 01:46:50.300]  const int имперсант.
[01:46:50.300 --> 01:46:52.300]  Ничего необычного.
[01:46:56.300 --> 01:46:58.300]  Print просто печатает
[01:46:58.300 --> 01:47:00.300]  в консоль две вещи.
[01:47:00.300 --> 01:47:02.300]  Первую и вторую.
[01:47:02.300 --> 01:47:04.300]  Мы берем f по auto
[01:47:04.300 --> 01:47:06.300]  какой-то const
[01:47:06.300 --> 01:47:08.300]  и auto само сжирает
[01:47:08.300 --> 01:47:10.300]  const.
[01:47:10.300 --> 01:47:12.300]  Погоди, ты про print спрашиваешь,
[01:47:12.300 --> 01:47:14.300]  или про что?
[01:47:14.300 --> 01:47:16.300]  Вот там у нас наверху сжирался const,
[01:47:16.300 --> 01:47:18.300]  сейчас перестал. Это из-за того, что мы принимали
[01:47:18.300 --> 01:47:20.300]  просто по auto, оно сжирало, а потом
[01:47:20.300 --> 01:47:22.300]  начало передавать по const auto, да?
[01:47:22.300 --> 01:47:24.300]  Почему появился const?
[01:47:24.300 --> 01:47:26.300]  Потому что он все еще сжирается, но мы навешиваем
[01:47:26.300 --> 01:47:28.300]  руками чему угодно еще один const.
[01:47:28.300 --> 01:47:30.300]  OK?
[01:47:30.300 --> 01:47:32.300]  Print тут вообще не причем.
[01:47:32.300 --> 01:47:34.300]  Print тут вообще не причем.
[01:47:34.300 --> 01:47:36.300]  Print вообще строка приходит.
[01:47:36.300 --> 01:47:38.300]  Да, он просто печатает строки.
[01:47:38.300 --> 01:47:40.300]  Все.
[01:47:40.300 --> 01:47:42.300]  OK.
[01:47:44.300 --> 01:47:46.300]  Дальше что?
[01:47:48.300 --> 01:47:50.300]  const char звездочка.
[01:47:50.300 --> 01:47:52.300]  Так, вот здесь вот const char звездочка,
[01:47:52.300 --> 01:47:54.300]  думаете?
[01:47:54.300 --> 01:47:56.300]  А что мы еще f добавляем?
[01:47:56.300 --> 01:47:58.300]  Мы теперь
[01:47:58.300 --> 01:48:00.300]  кроме const добавили амперсант.
[01:48:04.300 --> 01:48:06.300]  А я вам напомню,
[01:48:06.300 --> 01:48:08.300]  что вообще-то,
[01:48:08.300 --> 01:48:10.300]  вообще-то, строка это не
[01:48:10.300 --> 01:48:12.300]  const char звездочка сишная, изначально.
[01:48:14.300 --> 01:48:16.300]  Это массив.
[01:48:16.300 --> 01:48:18.300]  Это массив.
[01:48:20.300 --> 01:48:22.300]  Из раз, два, три, четыре, пять,
[01:48:22.300 --> 01:48:24.300]  шесть, семь, восемь, девять, десять.
[01:48:24.300 --> 01:48:26.300]  Из раз, два, три, четыре, пять, шестнадцать
[01:48:26.300 --> 01:48:28.300]  элементов.
[01:48:30.300 --> 01:48:32.300]  const char
[01:48:32.300 --> 01:48:34.300]  шестнадцать
[01:48:34.300 --> 01:48:36.300]  амперсант const.
[01:48:36.300 --> 01:48:38.300]  Амперсант const.
[01:48:38.300 --> 01:48:40.300]  Вот народная
[01:48:40.300 --> 01:48:42.300]  мудрость. Навешивать const на амперсант
[01:48:42.300 --> 01:48:44.300]  нельзя.
[01:48:46.300 --> 01:48:48.300]  Амперсант всегда const.
[01:48:48.300 --> 01:48:50.300]  Вы не можете менять то, на что строка
[01:48:50.300 --> 01:48:52.300]  ссылается.
[01:48:54.300 --> 01:48:56.300]  Мы можем перепривязывать ссылку.
[01:48:56.300 --> 01:48:58.300]  Вы не можете перепривязывать ссылку.
[01:48:58.300 --> 01:49:00.300]  Не можем, но можем менять то, на что строка.
[01:49:00.300 --> 01:49:02.300]  Да.
[01:49:02.300 --> 01:49:04.300]  Но, типа, если бы тут был указатель,
[01:49:04.300 --> 01:49:06.300]  если вы меняете указатель, вы меняете то, на что
[01:49:06.300 --> 01:49:08.300]  он указывает.
[01:49:08.300 --> 01:49:10.300]  В смысле, сам указатель меняете, а не
[01:49:10.300 --> 01:49:12.300]  то, что под ним. Ссылкой так нельзя.
[01:49:12.300 --> 01:49:14.300]  Ссылкой всегда. Типа константная.
[01:49:16.300 --> 01:49:18.300]  Если мы ее меняем, то мы меняем
[01:49:18.300 --> 01:49:20.300]  тот объект, что под ним.
[01:49:20.300 --> 01:49:22.300]  В общем, хорошо. Давайте посмотрим, что выявилось.
[01:49:22.300 --> 01:49:24.300]  Значит, что у нас здесь?
[01:49:24.300 --> 01:49:26.300]  const.
[01:49:26.300 --> 01:49:28.300]  const.char.amper.16
[01:49:28.300 --> 01:49:30.300]  Ну,
[01:49:30.300 --> 01:49:32.300]  почти угадали с индексом, нормально.
[01:49:32.300 --> 01:49:34.300]  const.int.amper.15
[01:49:34.300 --> 01:49:36.300]  Вот, заметьте, у нас под
[01:49:36.300 --> 01:49:38.300]  амперсантом оригинальный тип сохранился.
[01:49:40.300 --> 01:49:42.300]  И здесь у нас просто
[01:49:42.300 --> 01:49:44.300]  звездочка заменилась на амперсант. Это теперь ссылка
[01:49:44.300 --> 01:49:46.300]  на функцию, а не указатель.
[01:49:46.300 --> 01:49:48.300]  Почему когда был const, там был указатель
[01:49:48.300 --> 01:49:50.300]  в верхней секции,
[01:49:50.300 --> 01:49:52.300]  так.
[01:49:54.300 --> 01:49:56.300]  Ну, вот.
[01:49:58.300 --> 01:50:00.300]  Окей.
[01:50:00.300 --> 01:50:02.300]  Вопрос в том, почему
[01:50:02.300 --> 01:50:04.300]  у нас раньше было вот так,
[01:50:04.300 --> 01:50:06.300]  а стало вот так?
[01:50:08.300 --> 01:50:10.300]  Ну, смотри, оригинальный
[01:50:10.300 --> 01:50:12.300]  тип у строки вот такой.
[01:50:12.300 --> 01:50:14.300]  Окей?
[01:50:14.300 --> 01:50:16.300]  По правилам вывода типов
[01:50:16.300 --> 01:50:18.300]  в шагловных аргументах,
[01:50:18.300 --> 01:50:20.300]  если у нас тип
[01:50:20.300 --> 01:50:22.300]  не ссылка
[01:50:22.300 --> 01:50:24.300]  и
[01:50:26.300 --> 01:50:28.300]  массив,
[01:50:28.300 --> 01:50:30.300]  то мы
[01:50:30.300 --> 01:50:32.300]  из массива его кастим в указатель.
[01:50:36.300 --> 01:50:38.300]  По правилам вывода шаблонных
[01:50:38.300 --> 01:50:40.300]  аргументов, если шаблонный аргумент у нас
[01:50:40.300 --> 01:50:42.300]  получается массив,
[01:50:44.300 --> 01:50:46.300]  то мы его кастуем в указатель.
[01:50:46.300 --> 01:50:48.300]  Вот это и происходит вот здесь.
[01:50:50.300 --> 01:50:52.300]  Окей? Окей.
[01:50:52.300 --> 01:50:54.300]  Соответственно, здесь происходит ровно то же самое,
[01:50:54.300 --> 01:50:56.300]  просто еще один const навешиваем.
[01:50:56.300 --> 01:50:58.300]  Дальше. Вот здесь
[01:50:58.300 --> 01:51:00.300]  у нас уже это правило не работает.
[01:51:00.300 --> 01:51:02.300]  Потому что у нас
[01:51:02.300 --> 01:51:04.300]  автоамперсант. Автоамперсант это уже
[01:51:04.300 --> 01:51:06.300]  ссылочный тип. Если тип ссылочный,
[01:51:06.300 --> 01:51:08.300]  мы выводим просто то, что под ссылкой.
[01:51:08.300 --> 01:51:10.300]  Строго.
[01:51:10.300 --> 01:51:12.300]  Собственно, мы вывели
[01:51:12.300 --> 01:51:14.300]  то, что под ссылкой, кажется.
[01:51:14.300 --> 01:51:16.300]  Вот идентично то же самое.
[01:51:16.300 --> 01:51:18.300]  const char
[01:51:18.300 --> 01:51:20.300]  ampersand 16
[01:51:20.300 --> 01:51:22.300]  const char ampersand 16.
[01:51:22.300 --> 01:51:24.300]  Точно так же с int.
[01:51:24.300 --> 01:51:26.300]  const int ampersand 5
[01:51:26.300 --> 01:51:28.300]  const int
[01:51:28.300 --> 01:51:30.300]  ну ладно,
[01:51:30.300 --> 01:51:32.300]  ну мы ссылку навесили,
[01:51:32.300 --> 01:51:34.300]  раньше он был не ссылочным.
[01:51:34.300 --> 01:51:36.300]  Вывелось
[01:51:36.300 --> 01:51:38.300]  const int 5,
[01:51:38.300 --> 01:51:40.300]  мы навешали еще
[01:51:40.300 --> 01:51:42.300]  нет, вывелось int 5,
[01:51:42.300 --> 01:51:44.300]  мы навесили ampersand и const.
[01:51:44.300 --> 01:51:46.300]  Получилось const int 5.
[01:51:46.300 --> 01:51:48.300]  Все.
[01:51:48.300 --> 01:51:50.300]  Вроде все сходится.
[01:51:50.300 --> 01:51:52.300]  Понятно, да?
[01:51:52.300 --> 01:51:54.300]  И вот теперь тогда самое
[01:51:54.300 --> 01:51:56.300]  неочевидное.
[01:51:56.300 --> 01:51:58.300]  Мы делаем вот эту вот самую универсальную ссылку,
[01:51:58.300 --> 01:52:00.300]  которая работает по-другому.
[01:52:00.300 --> 01:52:02.300]  Подожди, Федя, а вот то, что там было с функцией,
[01:52:02.300 --> 01:52:04.300]  оно тоже как-то странно сработало?
[01:52:04.300 --> 01:52:06.300]  Оно тоже как-то странно сработало.
[01:52:06.300 --> 01:52:08.300]  Как именно? Здесь просто указатель заменился на ampersand.
[01:52:12.300 --> 01:52:14.300]  Ну, смотри.
[01:52:14.300 --> 01:52:16.300]  Опять же, функция кастуется в указатель на функцию.
[01:52:16.300 --> 01:52:18.300]  Если она просто выводится как
[01:52:18.300 --> 01:52:20.300]  шаблонная штука.
[01:52:24.300 --> 01:52:26.300]  Теперь мы добавили ampersand, значит должен
[01:52:26.300 --> 01:52:28.300]  вернуться просто тип.
[01:52:28.300 --> 01:52:30.300]  Ну какой тип у функции?
[01:52:30.300 --> 01:52:32.300]  Ну, собственно, вот такой
[01:52:32.300 --> 01:52:34.300]  только без ampersanda.
[01:52:34.300 --> 01:52:36.300]  Плюс мы
[01:52:36.300 --> 01:52:38.300]  навесили ampersand.
[01:52:46.300 --> 01:52:48.300]  Нет.
[01:52:48.300 --> 01:52:50.300]  Ну, хорошо, давайте вот здесь делаем
[01:52:50.300 --> 01:52:52.300]  такую же функцию.
[01:52:52.300 --> 01:52:54.300]  int
[01:52:54.300 --> 01:52:56.300]  not add
[01:52:56.300 --> 01:52:58.300]  int
[01:52:58.300 --> 01:53:00.300]  not add
[01:53:00.300 --> 01:53:02.300]  int size t
[01:53:06.300 --> 01:53:08.300]  Так, что там?
[01:53:08.300 --> 01:53:10.300]  Size t.
[01:53:10.300 --> 01:53:12.300]  Да, и давайте выведем
[01:53:16.300 --> 01:53:18.300]  function type
[01:53:20.300 --> 01:53:22.300]  type of
[01:53:24.300 --> 01:53:26.300]  not add
[01:53:28.300 --> 01:53:30.300]  int size t.
[01:53:34.300 --> 01:53:36.300]  Вот, что у нас появилось?
[01:53:36.300 --> 01:53:38.300]  function type
[01:53:38.300 --> 01:53:40.300]  вот, просто int
[01:53:40.300 --> 01:53:42.300]  от штуки, никаких звездочек.
[01:53:42.300 --> 01:53:44.300]  Ну, а почему
[01:53:44.300 --> 01:53:46.300]  должна быть звездочка?
[01:53:46.300 --> 01:53:48.300]  Потому что мы разбирали синдексы с
[01:53:48.300 --> 01:53:50.300]  первым семестрем.
[01:53:50.300 --> 01:53:52.300]  Наверное, потому что мы взяли не указатель
[01:53:52.300 --> 01:53:54.300]  на функцию, то есть не адрес ее,
[01:53:54.300 --> 01:53:56.300]  а просто... Ну да, типа я
[01:53:56.300 --> 01:53:58.300]  могу с тем же успехом написать
[01:53:58.300 --> 01:54:00.300]  адрес функции.
[01:54:00.300 --> 01:54:02.300]  Тогда
[01:54:02.300 --> 01:54:04.300]  там будет звездочка.
[01:54:12.300 --> 01:54:14.300]  Еще раз, в чем вопрос заключается?
[01:54:26.300 --> 01:54:28.300]  По факту это указательная функция.
[01:54:28.300 --> 01:54:30.300]  А, мы, наверное, говорили указательная функция.
[01:54:30.300 --> 01:54:32.300]  Видимо, вопрос отпал в процессе
[01:54:32.300 --> 01:54:34.300]  задавания. Окей. Ну, опять же,
[01:54:34.300 --> 01:54:36.300]  тут в плюсах у нас
[01:54:36.300 --> 01:54:38.300]  так сделано, что функция,
[01:54:38.300 --> 01:54:40.300]  ссылка на функцию, указатель на функцию,
[01:54:40.300 --> 01:54:42.300]  они практически
[01:54:42.300 --> 01:54:44.300]  неотличимы на самом деле. Кроме каких-то
[01:54:44.300 --> 01:54:46.300]  супер выдуманных
[01:54:46.300 --> 01:54:48.300]  случаев вы можете
[01:54:48.300 --> 01:54:50.300]  от всего этого вызывать
[01:54:50.300 --> 01:54:52.300]  круглые скобки,
[01:54:52.300 --> 01:54:54.300]  вы можете все это кастить друг к другу
[01:54:54.300 --> 01:54:56.300]  имплиситно, так что
[01:54:56.300 --> 01:54:58.300]  это, кажется,
[01:54:58.300 --> 01:55:00.300]  никогда не важно.
[01:55:04.300 --> 01:55:06.300]  Ну, функция по природе своей
[01:55:06.300 --> 01:55:08.300]  это указательное место в коге.
[01:55:10.300 --> 01:55:12.300]  Но вообще, я подозреваю,
[01:55:12.300 --> 01:55:14.300]  что это на следе C.
[01:55:16.300 --> 01:55:18.300]  Ну, плюс, это дает возможность
[01:55:18.300 --> 01:55:20.300]  если зачем-то нужно
[01:55:20.300 --> 01:55:22.300]  делать переменную указатель
[01:55:22.300 --> 01:55:24.300]  на функцию и делать его в какой-то момент
[01:55:24.300 --> 01:55:26.300]  nullptr.
[01:55:26.300 --> 01:55:28.300]  Прикольно, наверное.
[01:55:28.300 --> 01:55:30.300]  Ну, вообще, кроме шуток, я
[01:55:30.300 --> 01:55:32.300]  в продакшн коде видел такое, что у нас есть какая-то
[01:55:32.300 --> 01:55:34.300]  функция. На самом деле указатель на функцию
[01:55:34.300 --> 01:55:36.300]  просто лежит где-то, доступный
[01:55:36.300 --> 01:55:38.300]  всем. И когда программа включается,
[01:55:38.300 --> 01:55:40.300]  в зависимости от каких-то настроек,
[01:55:40.300 --> 01:55:42.300]  от каких-то конфигураций
[01:55:42.300 --> 01:55:44.300]  в рантайме, в этот указатель
[01:55:44.300 --> 01:55:46.300]  задумывается одна из разных функций. Не знаю,
[01:55:46.300 --> 01:55:48.300]  логировать файл и логировать по сети.
[01:55:48.300 --> 01:55:50.300]  Ну, банальный пример.
[01:55:52.300 --> 01:55:54.300]  Да.
[01:55:56.300 --> 01:55:58.300]  Нет, ничего.
[01:55:58.300 --> 01:56:00.300]  Да.
[01:56:04.300 --> 01:56:06.300]  Да.
[01:56:06.300 --> 01:56:08.300]  Да.
[01:56:08.300 --> 01:56:10.300]  Вот. На самом деле
[01:56:10.300 --> 01:56:12.300]  это не просто какая-то глупое
[01:56:12.300 --> 01:56:14.300]  и бесполезное правило, потому что
[01:56:16.300 --> 01:56:18.300]  вы не можете
[01:56:18.300 --> 01:56:20.300]  в коде
[01:56:20.300 --> 01:56:22.300]  делать что-то такое.
[01:56:24.300 --> 01:56:26.300]  Ладно, я даже не знаю, как это нормально
[01:56:26.300 --> 01:56:28.300]  писать. Ну, в общем, если у вас
[01:56:28.300 --> 01:56:30.300]  получился тип
[01:56:30.300 --> 01:56:32.300]  именно массив,
[01:56:32.300 --> 01:56:34.300]  вы, кажется, не можете приравнять его другому массиву.
[01:56:34.300 --> 01:56:36.300]  То есть, ну, не произойдет
[01:56:36.300 --> 01:56:38.300]  по символному копированию, это просто
[01:56:38.300 --> 01:56:40.300]  тишная структура, у него нет оператора равно.
[01:56:40.300 --> 01:56:42.300]  Поэтому, на самом деле, в большинстве случаев
[01:56:42.300 --> 01:56:44.300]  с указанием работать действительно удобнее.
[01:56:44.300 --> 01:56:46.300]  Правда, теряется информация о
[01:56:46.300 --> 01:56:48.300]  его размере, что неприятно.
[01:56:50.300 --> 01:56:52.300]  Если мы
[01:56:52.300 --> 01:56:54.300]  в функцию, которая
[01:56:54.300 --> 01:56:56.300]  const, auto, percent вызовем
[01:56:56.300 --> 01:56:58.300]  от
[01:56:58.300 --> 01:57:00.300]  int, auto, percent, она станет
[01:57:00.300 --> 01:57:02.300]  const, int, auto, percent.
[01:57:02.300 --> 01:57:04.300]  Сейчас, сейчас, какую функцию?
[01:57:04.300 --> 01:57:06.300]  Ну, вот эту функцию, которая
[01:57:06.300 --> 01:57:08.300]  CRF, кажется.
[01:57:08.300 --> 01:57:10.300]  CRF, которая const, auto, percent.
[01:57:10.300 --> 01:57:12.300]  Да, если мы вызовем от int, auto, percent.
[01:57:12.300 --> 01:57:14.300]  Так.
[01:57:14.300 --> 01:57:16.300]  То будет const, int, auto, percent?
[01:57:16.300 --> 01:57:18.300]  Если мы ее вызовем от int, auto, percent. То есть,
[01:57:18.300 --> 01:57:20.300]  мы делаем int, auto, percent,
[01:57:22.300 --> 01:57:24.300]  ref равно 5.
[01:57:24.300 --> 01:57:26.300]  Так, да?
[01:57:26.300 --> 01:57:28.300]  Потом мы делаем CRF от
[01:57:28.300 --> 01:57:30.300]  5.
[01:57:30.300 --> 01:57:32.300]  И грим
[01:57:32.300 --> 01:57:34.300]  print.
[01:57:34.300 --> 01:57:36.300]  Давай попробуем разобраться.
[01:57:38.300 --> 01:57:40.300]  Значит,
[01:57:40.300 --> 01:57:42.300]  только нет 5 от ref,
[01:57:42.300 --> 01:57:44.300]  видимо.
[01:57:48.300 --> 01:57:50.300]  Так, что такое ref?
[01:57:50.300 --> 01:57:52.300]  Ref, int, percent, percent.
[01:57:52.300 --> 01:57:54.300]  CRF вызывается.
[01:57:54.300 --> 01:57:56.300]  const, auto, percent, аргумент.
[01:57:56.300 --> 01:57:58.300]  Ну...
[01:58:00.300 --> 01:58:02.300]  Ну, const, int, percent,
[01:58:02.300 --> 01:58:04.300]  конечно, будет.
[01:58:08.300 --> 01:58:10.300]  Да.
[01:58:10.300 --> 01:58:12.300]  То есть, он инициализирует
[01:58:14.300 --> 01:58:16.300]  снуку из...
[01:58:16.300 --> 01:58:18.300]  Давай так, почему это должно быть
[01:58:18.300 --> 01:58:20.300]  CE?
[01:58:20.300 --> 01:58:22.300]  Окей.
[01:58:26.300 --> 01:58:28.300]  Это не то же самое, что int, да?
[01:58:28.300 --> 01:58:30.300]  В смысле, не то же самое, что int?
[01:58:30.300 --> 01:58:32.300]  Ref сейчас имеет тип
[01:58:32.300 --> 01:58:34.300]  не такой же, как...
[01:58:34.300 --> 01:58:36.300]  Ref сейчас
[01:58:36.300 --> 01:58:38.300]  имеет тип не такой же, как...
[01:58:38.300 --> 01:58:40.300]  Просто int.
[01:58:40.300 --> 01:58:42.300]  Ну, вроде нет. С чего бы.
[01:58:42.300 --> 01:58:44.300]  Ну, давайте вот так сделаем.
[01:58:44.300 --> 01:58:46.300]  Посмотрим,
[01:58:46.300 --> 01:58:48.300]  что нам первое выведет
[01:58:48.300 --> 01:58:50.300]  последний блок.
[01:58:50.300 --> 01:58:52.300]  int, percent, percent.
[01:58:52.300 --> 01:58:54.300]  Ну, по факту,
[01:58:54.300 --> 01:58:56.300]  все, что бы мы с ней не сделали,
[01:58:56.300 --> 01:58:58.300]  то же самое, что с обычным int.
[01:58:58.300 --> 01:59:00.300]  Да.
[01:59:00.300 --> 01:59:02.300]  Что по факту происходит?
[01:59:02.300 --> 01:59:04.300]  Компилятор создает, типа, временную
[01:59:04.300 --> 01:59:06.300]  переменную.
[01:59:06.300 --> 01:59:08.300]  Да. В целом, это
[01:59:08.300 --> 01:59:10.300]  практически эквивалентно
[01:59:10.300 --> 01:59:12.300]  к тому, чтобы написать int. Но
[01:59:12.300 --> 01:59:14.300]  не совсем эквивалентно, потому что вот как-то я могу
[01:59:14.300 --> 01:59:16.300]  выяснить, видишь, что это int, percent, percent.
[01:59:22.300 --> 01:59:24.300]  Так, сейчас, стоп.
[01:59:24.300 --> 01:59:26.300]  Что значит передать функцию универсальную ссылку?
[01:59:30.300 --> 01:59:32.300]  Окей, хорошо.
[01:59:32.300 --> 01:59:34.300]  Значит, смотрите, у нас есть теперь универсальная
[01:59:34.300 --> 01:59:36.300]  ссылка.
[01:59:36.300 --> 01:59:38.300]  Почему я функцию назвал frf?
[01:59:38.300 --> 01:59:40.300]  Ну, я думаю, до этого должно было бы понять.
[01:59:40.300 --> 01:59:42.300]  f функция, cf
[01:59:42.300 --> 01:59:44.300]  добавили константу,
[01:59:44.300 --> 01:59:46.300]  crf добавили константу и референс.
[01:59:46.300 --> 01:59:48.300]  И frf
[01:59:48.300 --> 01:59:50.300]  это потому что forwarding
[01:59:50.300 --> 01:59:52.300]  референс она называется иногда.
[01:59:52.300 --> 01:59:54.300]  Потому что позволяет
[01:59:54.300 --> 01:59:56.300]  удобно передавать аргументы,
[01:59:56.300 --> 01:59:58.300]  но об этом, видимо, еще чуть позже скажем.
[02:00:00.300 --> 02:00:02.300]  Так вот.
[02:00:02.300 --> 02:00:04.300]  Смотрите, единица это что?
[02:00:04.300 --> 02:00:06.300]  Это тип int,
[02:00:06.300 --> 02:00:08.300]  но value категория
[02:00:08.300 --> 02:00:10.300]  rvalue.
[02:00:12.300 --> 02:00:14.300]  Что у нас значит выведется?
[02:00:14.300 --> 02:00:16.300]  Какой тип
[02:00:16.300 --> 02:00:18.300]  нам вернет?
[02:00:18.300 --> 02:00:20.300]  After percent, percent.
[02:00:20.300 --> 02:00:22.300]  Нет, она ведет int, percent, percent, выведет.
[02:00:26.300 --> 02:00:28.300]  Const integer мы туда закидываем.
[02:00:28.300 --> 02:00:30.300]  Какой будет тип?
[02:00:32.300 --> 02:00:34.300]  Просто int, percent, percent.
[02:00:34.300 --> 02:00:36.300]  Вот, у нас уже две версии.
[02:00:38.300 --> 02:00:40.300]  Все, да, int, percent, percent.
[02:00:40.300 --> 02:00:42.300]  Int, percent, percent. Хорошо.
[02:00:42.300 --> 02:00:44.300]  C string.
[02:00:46.300 --> 02:00:48.300]  Не const, int, percent, percent.
[02:00:48.300 --> 02:00:50.300]  Может const, тут два мнения
[02:00:50.300 --> 02:00:52.300]  не поковоюют.
[02:00:52.300 --> 02:00:54.300]  Мне кажется, что int, percent,
[02:00:54.300 --> 02:00:56.300]  percent мы так константные как.
[02:00:56.300 --> 02:00:58.300]  Нет,
[02:00:58.300 --> 02:01:00.300]  int, percent, percent.
[02:01:00.300 --> 02:01:02.300]  Он бы его не накидывал.
[02:01:02.300 --> 02:01:04.300]  Он не накидывает сверху
[02:01:04.300 --> 02:01:06.300]  константу.
[02:01:06.300 --> 02:01:08.300]  Мы подали констант,
[02:01:08.300 --> 02:01:10.300]  и ее уберет.
[02:01:10.300 --> 02:01:12.300]  Но auto убирает
[02:01:12.300 --> 02:01:14.300]  все консты, и поэтому он
[02:01:14.300 --> 02:01:16.300]  убирает.
[02:01:16.300 --> 02:01:18.300]  Auto без референсов убирает все консты.
[02:01:18.300 --> 02:01:20.300]  Мы вообще не знаем, что такое
[02:01:20.300 --> 02:01:22.300]  тип int. Поэтому const.
[02:01:24.300 --> 02:01:26.300]  Подожди, Миша, тип int, percent,
[02:01:26.300 --> 02:01:28.300]  это rvalue.
[02:01:28.300 --> 02:01:30.300]  Нет.
[02:01:30.300 --> 02:01:32.300]  Ну, в смысле
[02:01:32.300 --> 02:01:34.300]  Миша, видимо, имел в виду, что мы
[02:01:34.300 --> 02:01:36.300]  в чем вопрос?
[02:01:36.300 --> 02:01:38.300]  Почему один имперсант?
[02:01:38.300 --> 02:01:40.300]  Почему один имперсант?
[02:01:40.300 --> 02:01:42.300]  Ну, хорошо. Какой у этого
[02:01:42.300 --> 02:01:44.300]  тип? const, int.
[02:01:44.300 --> 02:01:46.300]  Какая у этого категория? lvalue.
[02:01:46.300 --> 02:01:48.300]  Это просто переменная.
[02:01:48.300 --> 02:01:50.300]  В смысле?
[02:01:50.300 --> 02:01:52.300]  Да.
[02:01:52.300 --> 02:01:54.300]  Просто переменная это самое базовое
[02:01:54.300 --> 02:01:56.300]  lvalue. Какое только есть.
[02:01:56.300 --> 02:01:58.300]  Категория lvalue выводится один имперсант.
[02:01:58.300 --> 02:02:00.300]  Окей?
[02:02:02.300 --> 02:02:04.300]  Да.
[02:02:04.300 --> 02:02:06.300]  Я начал
[02:02:06.300 --> 02:02:08.300]  наш разговор с того, что это особенная
[02:02:08.300 --> 02:02:10.300]  штука, которая работает
[02:02:10.300 --> 02:02:12.300]  в зависимости от категории, которую мы
[02:02:12.300 --> 02:02:14.300]  передаем.
[02:02:14.300 --> 02:02:16.300]  Значит, один.
[02:02:20.300 --> 02:02:22.300]  В каком комментарии?
[02:02:22.300 --> 02:02:24.300]  60.
[02:02:24.300 --> 02:02:26.300]  А, да.
[02:02:26.300 --> 02:02:28.300]  Тогда у нас и в первой строке
[02:02:28.300 --> 02:02:30.300]  должны быть.
[02:02:30.300 --> 02:02:32.300]  А в первой строке изменить lvalue.
[02:02:32.300 --> 02:02:34.300]  1 это rvalue.
[02:02:34.300 --> 02:02:36.300]  Вы сказали, что const отбрасывается
[02:02:36.300 --> 02:02:38.300]  когда?
[02:02:38.300 --> 02:02:40.300]  Когда тип не ссылочный.
[02:02:40.300 --> 02:02:42.300]  Не ссылочный.
[02:02:42.300 --> 02:02:44.300]  Тип, который мы
[02:02:44.300 --> 02:02:46.300]  подаем.
[02:02:48.300 --> 02:02:50.300]  Тип, который
[02:02:50.300 --> 02:02:52.300]  получается.
[02:02:56.300 --> 02:02:58.300]  Нет, смотри. Видишь?
[02:02:58.300 --> 02:03:00.300]  Даже учитывая, что мы передавали
[02:03:00.300 --> 02:03:02.300]  не ссылочный тип, и то, что мы навесили
[02:03:02.300 --> 02:03:04.300]  имперсант, уже изменило то, как он выводится.
[02:03:04.300 --> 02:03:06.300]  Так что не совсем.
[02:03:06.300 --> 02:03:08.300]  То есть имперсант в конце,
[02:03:08.300 --> 02:03:10.300]  он с констами может что-то делать.
[02:03:12.300 --> 02:03:14.300]  А имперсант после авто...
[02:03:14.300 --> 02:03:16.300]  С ним не будет отбрасываться, на самом деле.
[02:03:16.300 --> 02:03:18.300]  Если мы просто вот здесь напишем имперсант,
[02:03:18.300 --> 02:03:20.300]  уже const не отбрасывается.
[02:03:22.300 --> 02:03:24.300]  Дальше.
[02:03:26.300 --> 02:03:28.300]  Так, что в строке это выйдет?
[02:03:28.300 --> 02:03:30.300]  У нас тут literal.
[02:03:32.300 --> 02:03:34.300]  Literal lvalue.
[02:03:34.300 --> 02:03:36.300]  Literal lvalue, верно.
[02:03:36.300 --> 02:03:38.300]  Что-то вы знаете.
[02:03:38.300 --> 02:03:40.300]  Это хорошо.
[02:03:42.300 --> 02:03:44.300]  Размер.
[02:03:44.300 --> 02:03:46.300]  Нужен ли размер?
[02:03:46.300 --> 02:03:48.300]  Мне кажется, нужен.
[02:03:52.300 --> 02:03:54.300]  Только вот здесь, по-моему, 16 будет.
[02:04:00.300 --> 02:04:02.300]  Да, ссылка на массив.
[02:04:04.300 --> 02:04:06.300]  Вот так он выводит.
[02:04:06.300 --> 02:04:08.300]  Что я сделаю?
[02:04:08.300 --> 02:04:10.300]  Передай ссылу.
[02:04:14.300 --> 02:04:16.300]  Окей, ну собственно все.
[02:04:16.300 --> 02:04:18.300]  Мы остальное посмотрели.
[02:04:18.300 --> 02:04:20.300]  Что тут? Абсолютно то же самое.
[02:04:20.300 --> 02:04:22.300]  С int и с
[02:04:22.300 --> 02:04:24.300]  функцией ничего не поменялось.
[02:04:24.300 --> 02:04:26.300]  Потому что это lvalue.
[02:04:26.300 --> 02:04:28.300]  Имя функции это lvalue.
[02:04:28.300 --> 02:04:30.300]  Окей.
[02:04:30.300 --> 02:04:32.300]  Хорошо. Это был
[02:04:32.300 --> 02:04:34.300]  в теории самый простой и понятный.
[02:04:34.300 --> 02:04:36.300]  С точки зрения
[02:04:36.300 --> 02:04:38.300]  чистой работы авто,
[02:04:38.300 --> 02:04:40.300]  я надеюсь, у вас нет вопросов.
[02:04:40.300 --> 02:04:42.300]  Вот в этом варианте авто
[02:04:42.300 --> 02:04:44.300]  просто буквально
[02:04:44.300 --> 02:04:46.300]  синтактически раскрывается в понятную конструкцию.
[02:04:46.300 --> 02:04:48.300]  Окей?
[02:04:48.300 --> 02:04:50.300]  Все согласны?
[02:04:52.300 --> 02:04:54.300]  Правила, да.
[02:04:54.300 --> 02:04:56.300]  Ну я надеюсь,
[02:04:56.300 --> 02:04:58.300]  что с этими примерами немножко,
[02:04:58.300 --> 02:05:00.300]  с правилами тоже немножко
[02:05:00.300 --> 02:05:02.300]  стало понятно, что происходит.
[02:05:02.300 --> 02:05:04.300]  Смотрите, где еще
[02:05:04.300 --> 02:05:06.300]  можно писать авто?
[02:05:10.300 --> 02:05:12.300]  Значит, второй
[02:05:12.300 --> 02:05:14.300]  пример, который я решил показать,
[02:05:14.300 --> 02:05:16.300]  потому что я думал, что он очень простой.
[02:05:16.300 --> 02:05:18.300]  Не тут-то было.
[02:05:18.300 --> 02:05:20.300]  Да.
[02:05:20.300 --> 02:05:22.300]  Это плюсы. Так, не будем показывать самое страшное.
[02:05:22.300 --> 02:05:24.300]  Смотрите, вы можете
[02:05:24.300 --> 02:05:26.300]  делать вот так.
[02:05:26.300 --> 02:05:28.300]  То есть вы можете писать авто
[02:05:28.300 --> 02:05:30.300]  в возвращаемом значении
[02:05:30.300 --> 02:05:32.300]  функции.
[02:05:32.300 --> 02:05:34.300]  Ну это вроде логично.
[02:05:34.300 --> 02:05:36.300]  Вот. Вроде логично.
[02:05:36.300 --> 02:05:38.300]  Когда мы пишем
[02:05:38.300 --> 02:05:40.300]  return, мы можем понять,
[02:05:40.300 --> 02:05:42.300]  что мы забрали. Да.
[02:05:42.300 --> 02:05:44.300]  Соответственно, какие есть ограничения?
[02:05:46.300 --> 02:05:48.300]  Все
[02:05:48.300 --> 02:05:50.300]  не отброшенные
[02:05:50.300 --> 02:05:52.300]  значения return
[02:05:52.300 --> 02:05:54.300]  должны возвращать один и тот же тип.
[02:05:54.300 --> 02:05:56.300]  Что это значит?
[02:05:56.300 --> 02:05:58.300]  Что если у меня есть
[02:05:58.300 --> 02:06:00.300]  то есть не тестоваться к одному?
[02:06:00.300 --> 02:06:02.300]  Да.
[02:06:02.300 --> 02:06:04.300]  Например, если я возвращаю int и long-long,
[02:06:04.300 --> 02:06:06.300]  то оно будет на меня материться.
[02:06:06.300 --> 02:06:08.300]  Именно так.
[02:06:08.300 --> 02:06:10.300]  Вот смотрите. Подожди,
[02:06:10.300 --> 02:06:12.300]  можно проведу, пожалуйста, пару?
[02:06:12.300 --> 02:06:14.300]  Спасибо.
[02:06:14.300 --> 02:06:16.300]  Смотри.
[02:06:16.300 --> 02:06:18.300]  Мы можем принимать какой-нибудь bool.
[02:06:28.300 --> 02:06:30.300]  Вот так нельзя.
[02:06:42.300 --> 02:06:44.300]  Вот так делать нельзя
[02:06:44.300 --> 02:06:46.300]  несмотря на то, что
[02:06:46.300 --> 02:06:48.300]  вообще-то вот так делать можно.
[02:06:58.300 --> 02:07:00.300]  Вот так делать можно.
[02:07:00.300 --> 02:07:02.300]  Вот так делать нельзя.
[02:07:02.300 --> 02:07:04.300]  Потому что
[02:07:04.300 --> 02:07:06.300]  тернарник выводит
[02:07:06.300 --> 02:07:08.300]  общий тип и кастует
[02:07:08.300 --> 02:07:10.300]  к нему результат.
[02:07:10.300 --> 02:07:12.300]  Да, конечно.
[02:07:12.300 --> 02:07:14.300]  В смысле выводит тип во время компиляции, но в рантайме
[02:07:14.300 --> 02:07:16.300]  кастанет, если надо.
[02:07:16.300 --> 02:07:18.300]  Ну вот у int
[02:07:18.300 --> 02:07:20.300]  с ist это будет очевидно
[02:07:20.300 --> 02:07:22.300]  int.
[02:07:24.300 --> 02:07:26.300]  Что?
[02:07:26.300 --> 02:07:28.300]  Нет? Ты думаешь нет? Давай проверим.
[02:07:32.300 --> 02:07:34.300]  Смотри.
[02:07:42.300 --> 02:07:44.300]  Будет, будет, да.
[02:07:44.300 --> 02:07:46.300]  Сейчас.
[02:07:46.300 --> 02:07:48.300]  Я уверен,
[02:07:48.300 --> 02:07:50.300]  что это все еще...
[02:07:50.300 --> 02:07:52.300]  вообще const в возвращаемом значении имеет мало смысла
[02:07:52.300 --> 02:07:54.300]  на самом деле.
[02:07:54.300 --> 02:07:56.300]  Но, допустим, давай.
[02:08:04.300 --> 02:08:06.300]  Можно.
[02:08:06.300 --> 02:08:08.300]  CV-квалификаторы, значит, можно.
[02:08:08.300 --> 02:08:10.300]  А если вернуть в одном
[02:08:10.300 --> 02:08:12.300]  branch lvalues
[02:08:12.300 --> 02:08:14.300]  и в другом lvalues?
[02:08:16.300 --> 02:08:18.300]  Хорошо, давай выясним.
[02:08:20.300 --> 02:08:22.300]  Так, во-первых, вот так уже можно?
[02:08:22.300 --> 02:08:24.300]  Нет, стоп, так в обоих.
[02:08:24.300 --> 02:08:26.300]  Ну нет, подождите, вот это вообще
[02:08:26.300 --> 02:08:28.300]  не ссылка.
[02:08:28.300 --> 02:08:30.300]  Ну ладно.
[02:08:34.300 --> 02:08:36.300]  Нормально же вообще.
[02:08:46.300 --> 02:08:48.300]  Переденную раму
[02:08:48.300 --> 02:08:50.300]  создали? Нет.
[02:08:52.300 --> 02:08:54.300]  Я скажу короткий ответ.
[02:08:54.300 --> 02:08:56.300]  Просто авто отбрасывает все ссылки,
[02:08:56.300 --> 02:08:58.300]  поэтому возвращаем эти бутыни.
[02:08:58.300 --> 02:09:00.300]  Что авто делает?
[02:09:00.300 --> 02:09:02.300]  Что справедливое?
[02:09:02.300 --> 02:09:04.300]  Авто здесь работает ровно
[02:09:04.300 --> 02:09:06.300]  по тем же правилам.
[02:09:06.300 --> 02:09:08.300]  Значит...
[02:09:08.300 --> 02:09:10.300]  Ну в смысле вывод типов авто.
[02:09:12.300 --> 02:09:14.300]  Хорошо, а если
[02:09:14.300 --> 02:09:16.300]  возвращаемый тип авто апельсанта?
[02:09:16.300 --> 02:09:18.300]  В смысле? Возвращаемый тип
[02:09:18.300 --> 02:09:20.300]  не может... А, в смысле если добавить
[02:09:20.300 --> 02:09:22.300]  авто апельсанта?
[02:09:22.300 --> 02:09:24.300]  Ну, тогда вернется...
[02:09:24.300 --> 02:09:26.300]  Нет, в плане тогда он уже не будет отбрасывать ссылки.
[02:09:26.300 --> 02:09:28.300]  Он все еще будет отбрасывать, а потом
[02:09:28.300 --> 02:09:30.300]  помыть сверху.
[02:09:30.300 --> 02:09:32.300]  Хорошо, давайте я объясню,
[02:09:32.300 --> 02:09:34.300]  как это примерно работает. Значит,
[02:09:34.300 --> 02:09:36.300]  у вас
[02:09:36.300 --> 02:09:38.300]  берется return.
[02:09:38.300 --> 02:09:40.300]  Представляется, как будто вот этот
[02:09:40.300 --> 02:09:42.300]  значение return, этот expression,
[02:09:42.300 --> 02:09:44.300]  как будто это аргумент функции,
[02:09:44.300 --> 02:09:46.300]  у которой template typeNameT
[02:09:46.300 --> 02:09:48.300]  t
[02:09:48.300 --> 02:09:50.300]  x выводятся типы
[02:09:50.300 --> 02:09:52.300]  и вот этот тип
[02:09:52.300 --> 02:09:54.300]  подставляется возвращаемое значение.
[02:09:54.300 --> 02:09:56.300]  Если тип вывелся одинаковый,
[02:09:56.300 --> 02:09:58.300]  то все хорошо. Собственно, поэтому у нас
[02:09:58.300 --> 02:10:00.300]  и CV-квалификатор нам разрешили взять,
[02:10:00.300 --> 02:10:02.300]  потому что const
[02:10:02.300 --> 02:10:04.300]  отбросился,
[02:10:04.300 --> 02:10:06.300]  потому что авто отбрасывает const.
[02:10:12.300 --> 02:10:14.300]  Давай вспомним.
[02:10:14.300 --> 02:10:16.300]  Вот здесь был пример. const int мы передаем,
[02:10:16.300 --> 02:10:18.300]  авто отбрасывает const.
[02:10:18.300 --> 02:10:20.300]  Помнишь такое было?
[02:10:32.300 --> 02:10:34.300]  Что значит в авто передавать тяжелую структуру нельзя?
[02:10:34.300 --> 02:10:36.300]  Ну вот у меня есть структура
[02:10:36.300 --> 02:10:38.300]  очень тяжелая.
[02:10:38.300 --> 02:10:40.300]  А я ее хочу передать,
[02:10:40.300 --> 02:10:42.300]  и она у меня скопируется вместо того,
[02:10:42.300 --> 02:10:44.300]  что даже если я захочу...
[02:10:44.300 --> 02:10:46.300]  Ты пишешь autoAmpersand,
[02:10:46.300 --> 02:10:48.300]  ты передаешь. Сейчас, если ты хочешь из функции
[02:10:48.300 --> 02:10:50.300]  вернуть lvalue или
[02:10:50.300 --> 02:10:52.300]  ты хочешь из функции вернуть
[02:10:52.300 --> 02:10:54.300]  тяжелую структуру?
[02:10:54.300 --> 02:10:56.300]  Вы в функцию?
[02:10:56.300 --> 02:10:58.300]  Напиши autoAmpersand.
[02:10:58.300 --> 02:11:00.300]  Да, наверное, свободно.
[02:11:00.300 --> 02:11:02.300]  Оно будет просто все по ссылке принимать.
[02:11:02.300 --> 02:11:04.300]  Сказали, какая интуиция
[02:11:04.300 --> 02:11:06.300]  вокруг этого, а не то, как это реально работает.
[02:11:06.300 --> 02:11:08.300]  Вот, значит...
[02:11:08.300 --> 02:11:10.300]  А, лямдовый...
[02:11:14.300 --> 02:11:16.300]  Если я буду представлять не так, как это работает,
[02:11:16.300 --> 02:11:18.300]  то это мне может не помочь.
[02:11:18.300 --> 02:11:20.300]  Вот, смотрите, в чем большие плюсы.
[02:11:20.300 --> 02:11:22.300]  Опять же, можно не писать сложные типы.
[02:11:22.300 --> 02:11:24.300]  Вот мы тут возвращаем массив
[02:11:24.300 --> 02:11:26.300]  из int. Мы не задумывались о том,
[02:11:26.300 --> 02:11:28.300]  что лучше кастомить на звездочку, нормально.
[02:11:28.300 --> 02:11:30.300]  Мы делаем return int.
[02:11:30.300 --> 02:11:32.300]  Мы возвращаем функцию из функции.
[02:11:32.300 --> 02:11:34.300]  Опять, очень удобно.
[02:11:34.300 --> 02:11:36.300]  Можно из функции вернуть
[02:11:36.300 --> 02:11:38.300]  итератор. Супер!
[02:11:42.300 --> 02:11:44.300]  Здесь у нас небольшая развилочка.
[02:11:44.300 --> 02:11:46.300]  У нас есть простые примеры,
[02:11:46.300 --> 02:11:48.300]  а есть вопросики.
[02:11:50.300 --> 02:11:52.300]  Ну, давайте быстренько с простыми примерами
[02:11:52.300 --> 02:11:54.300]  развернемся.
[02:11:54.300 --> 02:11:56.300]  Почему функция
[02:11:56.300 --> 02:11:58.300]  high и higher order? Потому что функции
[02:11:58.300 --> 02:12:00.300]  в других порядках те, которые принимают
[02:12:00.300 --> 02:12:02.300]  и возвращают другие функции.
[02:12:02.300 --> 02:12:04.300]  Что здесь вернется?
[02:12:06.300 --> 02:12:08.300]  Type of high, high
[02:12:08.300 --> 02:12:10.300]  результат вызова higher order.
[02:12:22.300 --> 02:12:24.300]  int это массив из 5 чисел.
[02:12:24.300 --> 02:12:26.300]  Это не СЕ случаем?
[02:12:26.300 --> 02:12:28.300]  Что?
[02:12:30.300 --> 02:12:32.300]  Нет, это не СЕ. Мы этот код...
[02:12:32.300 --> 02:12:34.300]  Смотри, каждый раз, когда я компилировал код до этого,
[02:12:34.300 --> 02:12:36.300]  этот код тоже компилировался.
[02:12:36.300 --> 02:12:38.300]  Почему это должен быть СЕ?
[02:12:38.300 --> 02:12:40.300]  Потому что у нас return int
[02:12:40.300 --> 02:12:42.300]  определен... Он разный
[02:12:42.300 --> 02:12:44.300]  для разных... У нас же несколько версий
[02:12:44.300 --> 02:12:46.300]  return int, в зависимости от того...
[02:12:46.300 --> 02:12:48.300]  А, сейчас, стоп.
[02:12:48.300 --> 02:12:50.300]  Что?
[02:12:50.300 --> 02:12:52.300]  Нет, не...
[02:12:52.300 --> 02:12:54.300]  А, ну да, он его выведет сразу просто.
[02:12:54.300 --> 02:12:56.300]  Хорошо.
[02:12:56.300 --> 02:12:58.300]  Сейчас, видимо, один...
[02:12:58.300 --> 02:13:00.300]  он возвращает на значение тоже массив
[02:13:00.300 --> 02:13:02.300]  и приводит... Да,
[02:13:02.300 --> 02:13:04.300]  ровно по тем же правилам.
[02:13:04.300 --> 02:13:06.300]  Кажется, это указатель на функцию.
[02:13:06.300 --> 02:13:08.300]  Это будет указатель на функцию?
[02:13:08.300 --> 02:13:10.300]  Какой-то не указатель.
[02:13:10.300 --> 02:13:12.300]  Указатель на функцию, которая возвращает
[02:13:12.300 --> 02:13:14.300]  указатель на функцию,
[02:13:14.300 --> 02:13:16.300]  которая возвращает
[02:13:16.300 --> 02:13:18.300]  видимо, массив.
[02:13:18.300 --> 02:13:20.300]  Нет, мы тут берем...
[02:13:20.300 --> 02:13:22.300]  Мы берем только результат.
[02:13:24.300 --> 02:13:26.300]  Просто указатель на функцию,
[02:13:26.300 --> 02:13:28.300]  которая возвращает
[02:13:28.300 --> 02:13:30.300]  указатель на массив,
[02:13:30.300 --> 02:13:32.300]  а принимаем значение где-то.
[02:13:32.300 --> 02:13:34.300]  Да, все так.
[02:13:36.300 --> 02:13:38.300]  Ну вот, давайте запустим
[02:13:38.300 --> 02:13:40.300]  вторую часть нашего семинара.
[02:13:40.300 --> 02:13:42.300]  Вот, мы возвращаем
[02:13:42.300 --> 02:13:44.300]  указатель на функцию, которая возвращает
[02:13:44.300 --> 02:13:46.300]  не указатель на массив, а указатель
[02:13:46.300 --> 02:13:48.300]  на инты. Конечно же, потому что опять же
[02:13:48.300 --> 02:13:50.300]  массив дикеется к указателю.
[02:13:52.300 --> 02:13:54.300]  Это важно.
[02:13:54.300 --> 02:13:56.300]  В данном контексте это важно, раз мы
[02:13:56.300 --> 02:13:58.300]  разбираем, как это работает.
[02:13:58.300 --> 02:14:00.300]  Соответственно,
[02:14:00.300 --> 02:14:02.300]  здесь все по-старому.
[02:14:04.300 --> 02:14:06.300]  Дальше.
[02:14:06.300 --> 02:14:08.300]  Смотрите.
[02:14:08.300 --> 02:14:10.300]  Да, что ж такое? Это все самое интересное.
[02:14:10.300 --> 02:14:12.300]  Показываю.
[02:14:12.300 --> 02:14:14.300]  Вот сюда давайте.
[02:14:14.300 --> 02:14:16.300]  Туда смотрите, туда не смотрите.
[02:14:16.300 --> 02:14:18.300]  Вот у меня есть функция
[02:14:18.300 --> 02:14:20.300]  add.
[02:14:22.300 --> 02:14:24.300]  Которая принимает
[02:14:24.300 --> 02:14:26.300]  что-то и что-то, и что-то возвращает.
[02:14:28.300 --> 02:14:30.300]  У вас будет несколько этих функций,
[02:14:30.300 --> 02:14:32.300]  в зависимости от принимаемых значений.
[02:14:32.300 --> 02:14:34.300]  Да, конечно.
[02:14:34.300 --> 02:14:36.300]  Какой тип будет у самодин?
[02:14:36.300 --> 02:14:38.300]  Я сегодня уже
[02:14:38.300 --> 02:14:40.300]  проспелерил. Это будет инт.
[02:14:40.300 --> 02:14:42.300]  Возвращает инт? Да.
[02:14:44.300 --> 02:14:46.300]  Здесь будет sizeT.
[02:14:48.300 --> 02:14:50.300]  Вот.
[02:14:50.300 --> 02:14:52.300]  Дальше что?
[02:14:52.300 --> 02:14:54.300]  На самом деле,
[02:14:54.300 --> 02:14:56.300]  вот такой синтаксис
[02:14:56.300 --> 02:14:58.300]  с возвращаемым значением, это может сказать
[02:14:58.300 --> 02:15:00.300]  неполная версия
[02:15:00.300 --> 02:15:02.300]  синтаксиса вот такого.
[02:15:02.300 --> 02:15:04.300]  Когда мы пишем
[02:15:06.300 --> 02:15:08.300]  автовозвращаемым значением,
[02:15:08.300 --> 02:15:10.300]  а после функции
[02:15:10.300 --> 02:15:12.300]  стрелочку и что она вернет?
[02:15:12.300 --> 02:15:14.300]  Сейчас разберем, зачем
[02:15:14.300 --> 02:15:16.300]  это делается.
[02:15:16.300 --> 02:15:18.300]  Во-первых, это просто новый синтаксис указать
[02:15:18.300 --> 02:15:20.300]  с возвращаемым значением.
[02:15:20.300 --> 02:15:22.300]  Если я пишу a.size-3,
[02:15:22.300 --> 02:15:24.300]  оно не кастуется.
[02:15:24.300 --> 02:15:26.300]  a.size-3.
[02:15:26.300 --> 02:15:28.300]  Что такое a?
[02:15:28.300 --> 02:15:30.300]  Ну, в любом массиве.
[02:15:30.300 --> 02:15:32.300]  a.size-3 не кастуется к инту.
[02:15:34.300 --> 02:15:36.300]  a.size-3.
[02:15:36.300 --> 02:15:38.300]  a.size-3.
[02:15:38.300 --> 02:15:40.300]  Тоже не кастуется.
[02:15:40.300 --> 02:15:42.300]  G, ты мне утверждаешь,
[02:15:42.300 --> 02:15:44.300]  что не кастуется, а после этого спрашиваешь,
[02:15:44.300 --> 02:15:46.300]  кастуется ли.
[02:15:46.300 --> 02:15:48.300]  Давай проверим.
[02:15:48.300 --> 02:15:50.300]  Хорошо.
[02:15:50.300 --> 02:15:52.300]  Потому что если мы напишем for int q
[02:15:52.300 --> 02:15:54.300]  равно 0,
[02:15:54.300 --> 02:15:56.300]  q меньше,
[02:15:56.300 --> 02:15:58.300]  чем a.size-3,
[02:15:58.300 --> 02:16:00.300]  это будет бесконечный цикл, если a пустой, например.
[02:16:00.300 --> 02:16:02.300]  Это более-менее понятно,
[02:16:02.300 --> 02:16:04.300]  потому что sizeT
[02:16:04.300 --> 02:16:06.300]  это более широкий тип.
[02:16:06.300 --> 02:16:08.300]  Если бы у нас
[02:16:08.300 --> 02:16:10.300]  оставалось инт,
[02:16:10.300 --> 02:16:12.300]  у нас было бы минус 2,
[02:16:12.300 --> 02:16:14.300]  и бесконечного числа не было.
[02:16:14.300 --> 02:16:16.300]  А a остается в sizeT,
[02:16:16.300 --> 02:16:18.300]  потому что sizeT это более широкий тип.
[02:16:18.300 --> 02:16:20.300]  А тут нам сказали,
[02:16:20.300 --> 02:16:22.300]  что size плюс int кастуется в инту.
[02:16:22.300 --> 02:16:24.300]  Да, действительно.
[02:16:24.300 --> 02:16:26.300]  Почему-то нет.
[02:16:26.300 --> 02:16:28.300]  Но он кастуется же.
[02:16:28.300 --> 02:16:30.300]  В чем еще раз был вопрос?
[02:16:30.300 --> 02:16:32.300]  Миша, можешь повторить?
[02:16:32.300 --> 02:16:34.300]  Вопрос был в том, что тут сказали,
[02:16:34.300 --> 02:16:36.300]  что sizeT кастуется в инту,
[02:16:36.300 --> 02:16:38.300]  как минимум в некоторых примерах можно?
[02:16:38.300 --> 02:16:40.300]  Да, вопрос.
[02:16:40.300 --> 02:16:42.300]  И какой контент?
[02:16:42.300 --> 02:16:44.300]  Запущенный код.
[02:16:44.300 --> 02:16:46.300]  Ну, смотрите, вот здесь
[02:16:46.300 --> 02:16:48.300]  скаставалось.
[02:16:48.300 --> 02:16:50.300]  А вот здесь не скаставалось.
[02:16:54.300 --> 02:16:56.300]  Честно говоря, я не знаю, почему.
[02:17:02.300 --> 02:17:04.300]  Ну, смотри, вот видишь, у меня есть функция add,
[02:17:04.300 --> 02:17:06.300]  да?
[02:17:06.300 --> 02:17:08.300]  Принимает int и sizeT.
[02:17:08.300 --> 02:17:10.300]  Здесь должны вывести
[02:17:10.300 --> 02:17:12.300]  int и sizeT.
[02:17:12.300 --> 02:17:14.300]  Авто возвращает, a плюс b.
[02:17:16.300 --> 02:17:18.300]  И авто принимает сумму.
[02:17:18.300 --> 02:17:20.300]  И тип суммы int.
[02:17:24.300 --> 02:17:26.300]  Int плюс sizeT,
[02:17:26.300 --> 02:17:28.300]  typo в самом 1.
[02:17:28.300 --> 02:17:30.300]  Int плюс sizeT, int.
[02:17:34.300 --> 02:17:36.300]  Плюс язык возможностей.
[02:17:38.300 --> 02:17:40.300]  И язык возможностей и функции typo.
[02:17:40.300 --> 02:17:42.300]  Что еще раз?
[02:17:42.300 --> 02:17:44.300]  Вдруг функция typo реализована не вверх.
[02:17:44.300 --> 02:17:46.300]  Вдруг...
[02:17:46.300 --> 02:17:48.300]  Может быть и так.
[02:17:48.300 --> 02:17:50.300]  Стоп, а sizeT это же using?
[02:17:50.300 --> 02:17:52.300]  Да, но это на long consigned
[02:17:52.300 --> 02:17:54.300]  using, а не на int.
[02:17:56.300 --> 02:17:58.300]  Окей.
[02:17:58.300 --> 02:18:00.300]  Ладно, это мистика, честно говоря.
[02:18:00.300 --> 02:18:02.300]  Я попробую разобраться, почему так.
[02:18:02.300 --> 02:18:04.300]  Но к следующему разу уже.
[02:18:08.300 --> 02:18:10.300]  Что еще раз?
[02:18:18.300 --> 02:18:20.300]  Нет.
[02:18:20.300 --> 02:18:22.300]  Этот авто теперь ничего не делает.
[02:18:22.300 --> 02:18:24.300]  Возвращается ровно то, что справа написано.
[02:18:28.300 --> 02:18:30.300]  Зачем тогда вообще авто?
[02:18:30.300 --> 02:18:32.300]  Сразу поговорим об этом.
[02:18:32.300 --> 02:18:34.300]  Смотрите.
[02:18:36.300 --> 02:18:38.300]  В чем разница между
[02:18:38.300 --> 02:18:40.300]  тем, чтобы вот здесь писать тип
[02:18:40.300 --> 02:18:42.300]  и вот здесь писать тип?
[02:18:42.300 --> 02:18:44.300]  Разница, на самом деле, в одном.
[02:18:46.300 --> 02:18:48.300]  Разница в том, есть ли у нас
[02:18:48.300 --> 02:18:50.300]  доступ к вот этим объявлениям или нет.
[02:18:52.300 --> 02:18:54.300]  Вот здесь есть.
[02:18:54.300 --> 02:18:56.300]  Как это можно использовать?
[02:19:00.300 --> 02:19:02.300]  Ну, что-то вроде того.
[02:19:02.300 --> 02:19:04.300]  Мы можем вызвать
[02:19:04.300 --> 02:19:06.300]  какие-то функции над типами
[02:19:06.300 --> 02:19:08.300]  A и B
[02:19:08.300 --> 02:19:10.300]  и сказать, что мы возвращаем вот это.
[02:19:14.300 --> 02:19:16.300]  Чуть позже мы сегодня
[02:19:16.300 --> 02:19:18.300]  дойдем до того, как
[02:19:18.300 --> 02:19:20.300]  это прям можно использовать
[02:19:20.300 --> 02:19:22.300]  использовать.
[02:19:22.300 --> 02:19:24.300]  Но идея такая.
[02:19:26.300 --> 02:19:28.300]  Окей.
[02:19:38.300 --> 02:19:40.300]  Еще раз.
[02:19:44.300 --> 02:19:46.300]  Нет.
[02:19:46.300 --> 02:19:48.300]  Да.
[02:19:52.300 --> 02:19:54.300]  Хорошо.
[02:19:56.300 --> 02:19:58.300]  С одной стороны немножко раз, с другой стороны немножко
[02:19:58.300 --> 02:20:00.300]  удивлен, что вы не спросили,
[02:20:00.300 --> 02:20:02.300]  а что будет с трикурсивными функциями,
[02:20:02.300 --> 02:20:04.300]  например.
[02:20:08.300 --> 02:20:10.300]  Да, в общем-то даже...
[02:20:12.300 --> 02:20:14.300]  Смотрите, что я могу сделать?
[02:20:18.300 --> 02:20:20.300]  Что могу сделать? Значит,
[02:20:20.300 --> 02:20:22.300]  if i
[02:20:22.300 --> 02:20:24.300]  равно 0
[02:20:24.300 --> 02:20:26.300]  turn i
[02:20:26.300 --> 02:20:28.300]  иначе return
[02:20:28.300 --> 02:20:30.300]  rec
[02:20:30.300 --> 02:20:32.300]  i
[02:20:32.300 --> 02:20:34.300]  минус 1
[02:20:34.300 --> 02:20:36.300]  плюс 1.
[02:20:38.300 --> 02:20:40.300]  Нет, все будет хорошо.
[02:20:44.300 --> 02:20:46.300]  Зачем inline?
[02:20:46.300 --> 02:20:48.300]  Смотрите, если я не делаю
[02:20:48.300 --> 02:20:50.300]  inline, все-все еще работает.
[02:20:50.300 --> 02:20:52.300]  Я получаю warning. Какой warning я получаю?
[02:20:52.300 --> 02:20:54.300]  Эта функция
[02:20:54.300 --> 02:20:56.300]  определена в header файле.
[02:20:56.300 --> 02:20:58.300]  Правильно? Если этот...
[02:20:58.300 --> 02:21:00.300]  Это HPP-файл, он инклюдится.
[02:21:00.300 --> 02:21:02.300]  Если он заинклюдится в несколько
[02:21:02.300 --> 02:21:04.300]  cpp-шников, у меня одна и та же функция будет
[02:21:04.300 --> 02:21:06.300]  определена... Ну, короче, один и тот же
[02:21:06.300 --> 02:21:08.300]  символ будет иметь разное определение. Если
[02:21:08.300 --> 02:21:10.300]  я говорю inline, я говорю
[02:21:10.300 --> 02:21:12.300]  компилятор, я понимаю,
[02:21:12.300 --> 02:21:14.300]  что может быть так, пожалуйста, сделай так,
[02:21:14.300 --> 02:21:16.300]  что все было хорошо.
[02:21:16.300 --> 02:21:18.300]  Он не будет инлайнить
[02:21:18.300 --> 02:21:20.300]  собственно.
[02:21:22.300 --> 02:21:24.300]  Он все равно не сможет ее заинлайнить.
[02:21:24.300 --> 02:21:26.300]  Это, ну, типа указание
[02:21:26.300 --> 02:21:28.300]  линковщику, можно сказать.
[02:21:30.300 --> 02:21:32.300]  Вот, смотрите.
[02:21:32.300 --> 02:21:34.300]  Вот здесь что
[02:21:34.300 --> 02:21:36.300]  выведется? Выведется
[02:21:36.300 --> 02:21:38.300]  int rec
[02:21:38.300 --> 02:21:40.300]  int.
[02:21:40.300 --> 02:21:42.300]  Да?
[02:21:42.300 --> 02:21:44.300]  Но есть один нюанс.
[02:21:44.300 --> 02:21:46.300]  Как обычно.
[02:21:48.300 --> 02:21:50.300]  Да, смотрите.
[02:21:50.300 --> 02:21:52.300]  Что я могу сделать? Как я могу перевисать эту функцию,
[02:21:52.300 --> 02:21:54.300]  в эквалентном виде?
[02:21:54.300 --> 02:21:56.300]  Значит, я могу написать...
[02:21:56.300 --> 02:21:58.300]  Если int больше 0, давайте
[02:21:58.300 --> 02:22:00.300]  ретерним rec
[02:22:00.300 --> 02:22:02.300]  от i-1
[02:22:02.300 --> 02:22:04.300]  плюс 1, а иначе
[02:22:04.300 --> 02:22:06.300]  ретерним 0.
[02:22:08.300 --> 02:22:10.300]  И это ошибка компиляции.
[02:22:10.300 --> 02:22:12.300]  Потому что когда мы дошли
[02:22:12.300 --> 02:22:14.300]  до сюда, мы парсим файл сверху вниз.
[02:22:14.300 --> 02:22:16.300]  Дошли до сюда.
[02:22:16.300 --> 02:22:18.300]  Ага, мы должны вернуть rec.
[02:22:18.300 --> 02:22:20.300]  Давайте посмотрим, что возвращает rec.
[02:22:20.300 --> 02:22:22.300]  А я вычисляю, что возвращает rec.
[02:22:22.300 --> 02:22:24.300]  Хрень какая-то, я не буду это вычислять,
[02:22:24.300 --> 02:22:26.300]  говорит компилятор.
[02:22:32.300 --> 02:22:34.300]  Ну да.
[02:22:34.300 --> 02:22:36.300]  Да.
[02:22:36.300 --> 02:22:38.300]  То есть будет еще?
[02:22:38.300 --> 02:22:40.300]  Да.
[02:22:42.300 --> 02:22:44.300]  Ретерн 0?
[02:22:44.300 --> 02:22:46.300]  Да.
[02:22:46.300 --> 02:22:48.300]  Если мы сейчас вот здесь напишем
[02:22:48.300 --> 02:22:50.300]  if false
[02:22:50.300 --> 02:22:52.300]  ретерн 0,
[02:22:52.300 --> 02:22:54.300]  все будет хорошо.
[02:22:56.300 --> 02:22:58.300]  Потому что...
[02:22:58.300 --> 02:23:00.300]  Ну как бы самый тупой ответ.
[02:23:00.300 --> 02:23:02.300]  Потому что так решил комитет.
[02:23:02.300 --> 02:23:04.300]  Но что это дает?
[02:23:04.300 --> 02:23:06.300]  Это дает, например, там какую-нибудь скорость компиляции.
[02:23:08.300 --> 02:23:10.300]  Вот.
[02:23:10.300 --> 02:23:12.300]  Но, в общем, вот так.
[02:23:18.300 --> 02:23:20.300]  В смысле, еще раз.
[02:23:20.300 --> 02:23:22.300]  Как работает авто?
[02:23:22.300 --> 02:23:24.300]  Нам говорят, все ретерны должны
[02:23:24.300 --> 02:23:26.300]  иметь один тип,
[02:23:26.300 --> 02:23:28.300]  который выявится в авто.
[02:23:28.300 --> 02:23:30.300]  Мы такие смотрим, ага, ретерны есть, 0, int.
[02:23:30.300 --> 02:23:32.300]  Считай, что ретерны этой функции 0.
[02:23:32.300 --> 02:23:34.300]  В смысле, int.
[02:23:34.300 --> 02:23:36.300]  Иду дальше. Ага, ретерны этой функции int.
[02:23:36.300 --> 02:23:38.300]  Так, я должен вернуть int.
[02:23:38.300 --> 02:23:40.300]  Все сходится. int равно int.
[02:23:40.300 --> 02:23:42.300]  Дальше идет ретерн 0, int равно int.
[02:23:42.300 --> 02:23:44.300]  Все сходится, все работает.
[02:23:48.300 --> 02:23:50.300]  Я не готов обещать, что это самое логичное
[02:23:50.300 --> 02:23:52.300]  поведение, но это то поведение, которое есть.
[02:23:54.300 --> 02:23:56.300]  Вот. И есть
[02:23:56.300 --> 02:23:58.300]  еще один интересный нюанс.
[02:23:58.300 --> 02:24:00.300]  Значит,
[02:24:00.300 --> 02:24:02.300]  с этим вариантом авто.
[02:24:02.300 --> 02:24:04.300]  Смотрите, какая есть прекрасная функция у меня.
[02:24:04.300 --> 02:24:06.300]  Бранч ретерн.
[02:24:06.300 --> 02:24:08.300]  И здесь возвращаю разные
[02:24:08.300 --> 02:24:10.300]  типы.
[02:24:10.300 --> 02:24:12.300]  По ифу, по булу.
[02:24:12.300 --> 02:24:14.300]  И вообще разные, даже не
[02:24:14.300 --> 02:24:16.300]  кастуются друг к другу. Но на меня компилятор не ругается.
[02:24:16.300 --> 02:24:18.300]  Вот.
[02:24:18.300 --> 02:24:20.300]  Да.
[02:24:20.300 --> 02:24:22.300]  И с иф констекстуром
[02:24:22.300 --> 02:24:24.300]  так можно.
[02:24:24.300 --> 02:24:26.300]  Кажется, начиная с C++17
[02:24:26.300 --> 02:24:28.300]  так можно.
[02:24:30.300 --> 02:24:32.300]  На самом деле, странно, что раньше
[02:24:32.300 --> 02:24:34.300]  что раньше.
[02:24:34.300 --> 02:24:36.300]  Почему не сразу
[02:24:36.300 --> 02:24:38.300]  так можно было?
[02:24:38.300 --> 02:24:40.300]  Ну,
[02:24:40.300 --> 02:24:42.300]  а в чем проблема?
[02:24:42.300 --> 02:24:44.300]  Проблема в том, что у нас
[02:24:44.300 --> 02:24:46.300]  выведется
[02:24:46.300 --> 02:24:48.300]  функция с одним названием разными возвращаемыми
[02:24:48.300 --> 02:24:50.300]  значениями. Ну, то есть в смысле
[02:24:50.300 --> 02:24:52.300]  это не проблема. Все нормально. То есть вот
[02:24:52.300 --> 02:24:54.300]  что у нас есть. Смотрите.
[02:24:56.300 --> 02:24:58.300]  Вот. То есть я говорю first branch return
[02:24:58.300 --> 02:25:00.300]  at true, second branch return at false.
[02:25:00.300 --> 02:25:02.300]  Type of first у нас
[02:25:02.300 --> 02:25:04.300]  будет один,
[02:25:04.300 --> 02:25:06.300]  type of second второй. Там будет int и строка.
[02:25:06.300 --> 02:25:08.300]  Вот.
[02:25:08.300 --> 02:25:10.300]  Собственно.
[02:25:10.300 --> 02:25:12.300]  Вот. Видите.
[02:25:12.300 --> 02:25:14.300]  True branch basic string,
[02:25:14.300 --> 02:25:16.300]  false branch int.
[02:25:20.300 --> 02:25:22.300]  Вот.
[02:25:22.300 --> 02:25:24.300]  Что?
[02:25:24.300 --> 02:25:26.300]  Что?
[02:25:28.300 --> 02:25:30.300]  Что значит
[02:25:30.300 --> 02:25:32.300]  branch return?
[02:25:36.300 --> 02:25:38.300]  Никакой.
[02:25:38.300 --> 02:25:40.300]  Это не функция. Это шаблон функции.
[02:25:40.300 --> 02:25:42.300]  Нельзя вызвать шаблон функции.
[02:25:42.300 --> 02:25:44.300]  Можно вызвать только функцию. Чтобы вызвать функцию,
[02:25:44.300 --> 02:25:46.300]  все ее шаблонные аргументы должны быть
[02:25:46.300 --> 02:25:48.300]  известны.
[02:25:48.300 --> 02:25:50.300]  Известны не значит, опять же,
[02:25:50.300 --> 02:25:52.300]  как бы
[02:25:52.300 --> 02:25:54.300]  явно написаны, но
[02:25:54.300 --> 02:25:56.300]  должны быть известны. Если ты просто напишешь
[02:25:56.300 --> 02:25:58.300]  branch return,
[02:25:58.300 --> 02:26:00.300]  это не функция.
[02:26:00.300 --> 02:26:02.300]  Окей.
[02:26:02.300 --> 02:26:04.300]  Все.
[02:26:04.300 --> 02:26:06.300]  И у нас остается последнее
[02:26:06.300 --> 02:26:08.300]  простое использование авто.
[02:26:12.300 --> 02:26:14.300]  Которое
[02:26:14.300 --> 02:26:16.300]  на самом деле обычно используется.
[02:26:16.300 --> 02:26:18.300]  Это переменные.
[02:26:18.300 --> 02:26:20.300]  Вот.
[02:26:20.300 --> 02:26:22.300]  Если коротко,
[02:26:22.300 --> 02:26:24.300]  правила вывода ровно те же самые.
[02:26:24.300 --> 02:26:26.300]  Мы представляем,
[02:26:26.300 --> 02:26:28.300]  что
[02:26:28.300 --> 02:26:30.300]  это на самом деле не переменная аргумент
[02:26:30.300 --> 02:26:32.300]  функции, выводим типы
[02:26:32.300 --> 02:26:34.300]  и подставляем тип, который получается
[02:26:34.300 --> 02:26:36.300]  слева
[02:26:36.300 --> 02:26:38.300]  пишем переменное равно
[02:26:38.300 --> 02:26:40.300]  штука. Вот. Соответственно, с этими
[02:26:40.300 --> 02:26:42.300]  знаниями
[02:26:42.300 --> 02:26:44.300]  const auto tu выведет нам
[02:26:44.300 --> 02:26:46.300]  очевидно
[02:26:46.300 --> 02:26:48.300]  const int.
[02:26:48.300 --> 02:26:50.300]  Поэтому с х нам выведет
[02:26:50.300 --> 02:26:52.300]  просто int.
[02:26:54.300 --> 02:26:56.300]  Что нам интересно, что
[02:26:58.300 --> 02:27:00.300]  вот здесь вот у нас есть, смотрите,
[02:27:00.300 --> 02:27:02.300]  const int number, авто
[02:27:02.300 --> 02:27:04.300]  будет типа
[02:27:04.300 --> 02:27:06.300]  конечно же просто int.
[02:27:08.300 --> 02:27:10.300]  Потому что константы мы отбрасываем.
[02:27:10.300 --> 02:27:12.300]  А да, но тут не int, да-да-да-да,
[02:27:12.300 --> 02:27:14.300]  здесь будет onSineClone, да.
[02:27:16.300 --> 02:27:18.300]  Вот. А да, смотрите,
[02:27:18.300 --> 02:27:20.300]  при этом у нас синтаксис,
[02:27:20.300 --> 02:27:22.300]  мы можем писать
[02:27:22.300 --> 02:27:24.300]  автоназвание равно
[02:27:24.300 --> 02:27:26.300]  инициализатор,
[02:27:26.300 --> 02:27:28.300]  автоназвание
[02:27:28.300 --> 02:27:30.300]  равно в фигурных скобочках
[02:27:30.300 --> 02:27:32.300]  инициализатор, автоназвание
[02:27:32.300 --> 02:27:34.300]  в фигурных скобочках инициализатор.
[02:27:34.300 --> 02:27:36.300]  Это все одно и то же.
[02:27:36.300 --> 02:27:38.300]  До сих пор пока в этом инициализаторе ровно
[02:27:38.300 --> 02:27:40.300]  одно значение.
[02:27:48.300 --> 02:27:50.300]  Да, могу.
[02:27:56.300 --> 02:27:58.300]  Что если хочешь завести таким образом
[02:27:58.300 --> 02:28:00.300]  инициализер лист? Так, давай
[02:28:00.300 --> 02:28:02.300]  я из головы скажу, что если ты делаешь переменную,
[02:28:02.300 --> 02:28:04.300]  то ты можешь.
[02:28:04.300 --> 02:28:06.300]  Вот это будет инициализер
[02:28:06.300 --> 02:28:08.300]  лист от int.
[02:28:08.300 --> 02:28:10.300]  Но кажется, это работает
[02:28:10.300 --> 02:28:12.300]  только в переменных.
[02:28:12.300 --> 02:28:14.300]  По-моему...
[02:28:14.300 --> 02:28:16.300]  Чем это отличается от строки 16?
[02:28:16.300 --> 02:28:18.300]  Чем это отличается от строки 16?
[02:28:18.300 --> 02:28:20.300]  А, ну конечно же тем, что тут у нас
[02:28:20.300 --> 02:28:22.300]  несколько значений, а не одно.
[02:28:22.300 --> 02:28:24.300]  А если я хочу инициализер лист из одного значения?
[02:28:24.300 --> 02:28:26.300]  Тогда пиши std инициализер
[02:28:26.300 --> 02:28:28.300]  лист от int.
[02:28:28.300 --> 02:28:30.300]  Все, что
[02:28:30.300 --> 02:28:32.300]  я могу тебе посоветовать.
[02:28:32.300 --> 02:28:34.300]  Да.
[02:28:36.300 --> 02:28:38.300]  Да.
[02:28:38.300 --> 02:28:40.300]  Вот это будет такой
[02:28:40.300 --> 02:28:42.300]  тип и std инициализер лист. Кажется, про него
[02:28:42.300 --> 02:28:44.300]  вы говорили про него?
[02:28:44.300 --> 02:28:46.300]  А, ну вы матрицы писали.
[02:28:46.300 --> 02:28:48.300]  Так что да, это будет инициализер
[02:28:48.300 --> 02:28:50.300]  лист.
[02:28:52.300 --> 02:28:54.300]  Так, что еще тут есть интересного?
[02:28:54.300 --> 02:28:56.300]  Ну правила
[02:28:56.300 --> 02:28:58.300]  те же самые.
[02:28:58.300 --> 02:29:00.300]  В том числе правила с
[02:29:00.300 --> 02:29:02.300]  универсальной ссылкой.
[02:29:02.300 --> 02:29:04.300]  Auto%&& работает так же.
[02:29:06.300 --> 02:29:08.300]  Вот. Поэтому давайте быстренько
[02:29:08.300 --> 02:29:10.300]  угадаем вот эти вещи.
[02:29:12.300 --> 02:29:14.300]  И?
[02:29:14.300 --> 02:29:16.300]  И?
[02:29:16.300 --> 02:29:18.300]  Нет, блин, просто
[02:29:18.300 --> 02:29:20.300]  int, да.
[02:29:20.300 --> 02:29:22.300]  Просто int? Почему просто int?
[02:29:24.300 --> 02:29:26.300]  Почему %&&?
[02:29:26.300 --> 02:29:28.300]  Потому что это...
[02:29:28.300 --> 02:29:30.300]  Потому что
[02:29:30.300 --> 02:29:32.300]  он сам добавил 2 %&&.
[02:29:32.300 --> 02:29:34.300]  А бы факто %&&
[02:29:34.300 --> 02:29:36.300]  наверное.
[02:29:36.300 --> 02:29:38.300]  Нет, в смысле, единица
[02:29:38.300 --> 02:29:40.300]  это int.
[02:29:40.300 --> 02:29:42.300]  Это не const. Но единица
[02:29:42.300 --> 02:29:44.300]  единица это Rvalue, да.
[02:29:44.300 --> 02:29:46.300]  И поэтому у нас должно
[02:29:46.300 --> 02:29:48.300]  прибавиться 2 %&&
[02:29:48.300 --> 02:29:50.300]  это значит... Но const и на есть.
[02:29:50.300 --> 02:29:52.300]  Да, ну я не знаю
[02:29:52.300 --> 02:29:54.300]  откуда вы взяли const.
[02:29:54.300 --> 02:29:56.300]  Нигде нет слова const.
[02:29:56.300 --> 02:29:58.300]  Просто нет. Но действительно должно быть Rvalue.
[02:29:58.300 --> 02:30:00.300]  Это должен быть %&&.
[02:30:00.300 --> 02:30:02.300]  Если мы берем ee, то что у нас стоит справа?
[02:30:02.300 --> 02:30:04.300]  Справа стоит lvalue, название переменной.
[02:30:04.300 --> 02:30:06.300]  Значит, должен быть %&&.
[02:30:08.300 --> 02:30:10.300]  ee
[02:30:10.300 --> 02:30:12.300]  Понятно.
[02:30:12.300 --> 02:30:14.300]  Move всегда 2 %&&.
[02:30:14.300 --> 02:30:16.300]  Move всегда 2 %&&.
[02:30:16.300 --> 02:30:18.300]  Ну, типа того.
[02:30:18.300 --> 02:30:20.300]  Из функции возвращается
[02:30:20.300 --> 02:30:22.300]  ссылка %&&.
[02:30:22.300 --> 02:30:24.300]  Это Rvalue, просто правило.
[02:30:24.300 --> 02:30:26.300]  Если из функции возвращается Rvalue ссылка,
[02:30:26.300 --> 02:30:28.300]  то это выражение является Rvalue.
[02:30:32.300 --> 02:30:34.300]  Вот.
[02:30:34.300 --> 02:30:36.300]  Класс.
[02:30:40.300 --> 02:30:42.300]  Да, в форике тоже можно так писать.
[02:30:50.300 --> 02:30:52.300]  Почему здесь
[02:30:52.300 --> 02:30:54.300]  вектор bool?
[02:30:58.300 --> 02:31:00.300]  Вектор bool здесь потому, что
[02:31:00.300 --> 02:31:02.300]  в отличие от любого другого вектора, вы не можете
[02:31:02.300 --> 02:31:04.300]  написать вот так.
[02:31:08.300 --> 02:31:10.300]  Вот.
[02:31:10.300 --> 02:31:12.300]  Потому что вектор
[02:31:12.300 --> 02:31:14.300]  нанесен Rvalue в данном случае.
[02:31:14.300 --> 02:31:16.300]  Нужно будет писать, например,
[02:31:16.300 --> 02:31:18.300]  вот так, если вы хотите что-то менять.
[02:31:18.300 --> 02:31:20.300]  Либо вот так, если вы не хотите ничего не менять.
[02:31:22.300 --> 02:31:24.300]  Почему это именно с bool-овским вектором?
[02:31:24.300 --> 02:31:26.300]  Смотри.
[02:31:30.300 --> 02:31:32.300]  Что тебе bool-овский вектор возвращает по квадратным
[02:31:32.300 --> 02:31:34.300]  скобочкам?
[02:31:34.300 --> 02:31:36.300]  Новый объект.
[02:31:36.300 --> 02:31:38.300]  Если функция возвращает
[02:31:38.300 --> 02:31:40.300]  неосылочный тип,
[02:31:40.300 --> 02:31:42.300]  это выражение является Rvalue.
[02:31:42.300 --> 02:31:44.300]  Значит нельзя взять
[02:31:44.300 --> 02:31:46.300]  Rvalue ссылку.
[02:31:52.300 --> 02:31:54.300]  Не совсем.
[02:32:00.300 --> 02:32:02.300]  Сейчас в смысле зануляться объект?
[02:32:12.300 --> 02:32:14.300]  Да, но у тебя bool никто
[02:32:14.300 --> 02:32:16.300]  не зануляется. У тебя есть bit-reference,
[02:32:16.300 --> 02:32:18.300]  который можно мувать.
[02:32:18.300 --> 02:32:20.300]  Его внутреннее состояние будет муваться.
[02:32:20.300 --> 02:32:22.300]  Какие-то указатели. Указатели тоже будут
[02:32:22.300 --> 02:32:24.300]  на самом деле тупо копироваться.
[02:32:32.300 --> 02:32:34.300]  Я не понимаю, что значит это предложение.
[02:32:36.300 --> 02:32:38.300]  Вопросительное предложение.
[02:32:44.300 --> 02:32:46.300]  Еще раз.
[02:32:46.300 --> 02:32:48.300]  Смотрите. Что такое move?
[02:32:48.300 --> 02:32:50.300]  Действие move. Вызов move конструктора
[02:32:50.300 --> 02:32:52.300]  или move оператора
[02:32:52.300 --> 02:32:54.300]  присваивания.
[02:32:54.300 --> 02:32:56.300]  Когда он вызывается.
[02:32:56.300 --> 02:32:58.300]  При выборе
[02:32:58.300 --> 02:33:00.300]  перегрузки функции вы понимаете,
[02:33:00.300 --> 02:33:02.300]  что у вас
[02:33:02.300 --> 02:33:04.300]  значение имеет
[02:33:04.300 --> 02:33:06.300]  Rvalue
[02:33:06.300 --> 02:33:08.300]  категорию.
[02:33:10.300 --> 02:33:12.300]  Rvalue категория
[02:33:12.300 --> 02:33:14.300]  может быть
[02:33:14.300 --> 02:33:16.300]  достигнута тем, что откуда-то
[02:33:16.300 --> 02:33:18.300]  у вас Rvalue ссылка. При этом
[02:33:18.300 --> 02:33:20.300]  Rvalue ссылка может быть
[02:33:20.300 --> 02:33:22.300]  частью Lvalue выражения.
[02:33:22.300 --> 02:33:24.300]  Тогда не вызовется move.
[02:33:24.300 --> 02:33:26.300]  Это коррелирующие
[02:33:26.300 --> 02:33:28.300]  понятия, но не строго
[02:33:28.300 --> 02:33:30.300]  связанные.
[02:33:32.300 --> 02:33:34.300]  Тебе явно нужно помедитировать на эту тему.
[02:33:38.300 --> 02:33:40.300]  Так, мы про это поговорили. Кажется, это
[02:33:40.300 --> 02:33:42.300]  просто правда, это все.
[02:33:42.300 --> 02:33:44.300]  Давайте посмотрим,
[02:33:44.300 --> 02:33:46.300]  что у нас идет дальше.
[02:33:56.300 --> 02:33:58.300]  У нас есть еще кое-что.
[02:33:58.300 --> 02:34:00.300]  Собственно, пункт...
[02:34:00.300 --> 02:34:02.300]  Так, какой у нас был?
[02:34:02.300 --> 02:34:04.300]  Почему 8?
[02:34:04.300 --> 02:34:06.300]  Ты мне врешь.
[02:34:06.300 --> 02:34:08.300]  Сейчас будет 11 и 2.
[02:34:08.300 --> 02:34:10.300]  Ключевое слово decal type.
[02:34:12.300 --> 02:34:14.300]  Значит,
[02:34:14.300 --> 02:34:16.300]  сразу же говорю,
[02:34:16.300 --> 02:34:18.300]  decal type есть два вида,
[02:34:18.300 --> 02:34:20.300]  которые работают по-разному.
[02:34:20.300 --> 02:34:22.300]  Вот.
[02:34:22.300 --> 02:34:24.300]  Пишутся одинаково, выглядят одинаково,
[02:34:24.300 --> 02:34:26.300]  работают по-разному.
[02:34:26.300 --> 02:34:28.300]  А ключевом слове
[02:34:28.300 --> 02:34:30.300]  decal type?
[02:34:30.300 --> 02:34:32.300]  Окей.
[02:34:32.300 --> 02:34:34.300]  Смотрите.
[02:34:34.300 --> 02:34:36.300]  В самых общих словах,
[02:34:36.300 --> 02:34:38.300]  интуитивно, decal type
[02:34:38.300 --> 02:34:40.300]  принимает какое-то выражение
[02:34:40.300 --> 02:34:42.300]  и возвращает его тип.
[02:34:42.300 --> 02:34:44.300]  Примерно.
[02:34:44.300 --> 02:34:46.300]  То есть делаешь это
[02:34:46.300 --> 02:34:48.300]  похоже на авто, на самом деле.
[02:34:50.300 --> 02:34:52.300]  Вот.
[02:34:52.300 --> 02:34:54.300]  Какие есть два типа у decal type?
[02:34:54.300 --> 02:34:56.300]  Decal type от
[02:34:56.300 --> 02:34:58.300]  просто объекта,
[02:34:58.300 --> 02:35:00.300]  то есть названия какого-то,
[02:35:00.300 --> 02:35:02.300]  типа от названия переменной.
[02:35:02.300 --> 02:35:04.300]  И туда же вы можете делать
[02:35:04.300 --> 02:35:06.300]  доступ
[02:35:06.300 --> 02:35:08.300]  к членам этой
[02:35:08.300 --> 02:35:10.300]  переменной или разыменовании
[02:35:10.300 --> 02:35:12.300]  или доступ по указателю.
[02:35:12.300 --> 02:35:14.300]  В общем, либо название переменной, либо просто доступ.
[02:35:14.300 --> 02:35:16.300]  Либо произвольное выражение.
[02:35:16.300 --> 02:35:18.300]  Вот давайте сначала поговорим
[02:35:18.300 --> 02:35:20.300]  про то, как это работает с
[02:35:20.300 --> 02:35:22.300]  переменными.
[02:35:24.300 --> 02:35:26.300]  Смотрите.
[02:35:26.300 --> 02:35:28.300]  Вот type name это опять моя функция,
[02:35:28.300 --> 02:35:30.300]  которая принимает тип
[02:35:30.300 --> 02:35:32.300]  и возвращает его имя строкой.
[02:35:34.300 --> 02:35:36.300]  Окей?
[02:35:36.300 --> 02:35:38.300]  Окей.
[02:35:40.300 --> 02:35:42.300]  Вот здесь я взял примеры
[02:35:42.300 --> 02:35:44.300]  из предыдущего файлика,
[02:35:44.300 --> 02:35:46.300]  где у нас были
[02:35:46.300 --> 02:35:48.300]  переменные с авто.
[02:35:48.300 --> 02:35:50.300]  Мы увидим,
[02:35:50.300 --> 02:35:52.300]  в чем разница. Вот смотрите.
[02:35:52.300 --> 02:35:54.300]  У нас есть const int 2,
[02:35:54.300 --> 02:35:56.300]  decal type at 2.
[02:35:56.300 --> 02:35:58.300]  Так, это был
[02:35:58.300 --> 02:36:00.300]  четвертый.
[02:36:02.300 --> 02:36:04.300]  У нас увиделся const int.
[02:36:06.300 --> 02:36:08.300]  Все, мы не отбросили const.
[02:36:08.300 --> 02:36:10.300]  Мы на самом деле ничего не отбрасываем.
[02:36:10.300 --> 02:36:12.300]  Когда мы попадаем в decal type
[02:36:12.300 --> 02:36:14.300]  от entity, мы просто возвращаем
[02:36:14.300 --> 02:36:16.300]  тип entity, какой он есть.
[02:36:16.300 --> 02:36:18.300]  Ничего не меняем в нем.
[02:36:18.300 --> 02:36:20.300]  Очень удобно.
[02:36:22.300 --> 02:36:24.300]  Когда мы передаем функцию...
[02:36:24.300 --> 02:36:26.300]  В какую функцию?
[02:36:26.300 --> 02:36:28.300]  Сейчас, зачем
[02:36:28.300 --> 02:36:30.300]  это нам нужно бывает?
[02:36:30.300 --> 02:36:32.300]  Зачем нам узнать
[02:36:32.300 --> 02:36:34.300]  тип выражения?
[02:36:34.300 --> 02:36:36.300]  Нет, узнать тип
[02:36:36.300 --> 02:36:38.300]  мы не могли бы просто type name
[02:36:38.300 --> 02:36:40.300]  от 2 сделать.
[02:36:40.300 --> 02:36:42.300]  Нет, type name это моя функция,
[02:36:42.300 --> 02:36:44.300]  которая возвращает имя,
[02:36:44.300 --> 02:36:46.300]  а decal type конструкция языка, которая
[02:36:46.300 --> 02:36:48.300]  возвращает тип.
[02:36:52.300 --> 02:36:54.300]  Да, здесь будет const int.
[02:36:54.300 --> 02:36:56.300]  Что значит тип? Ну, смотри.
[02:36:56.300 --> 02:36:58.300]  Это значит, что я могу написать вот так.
[02:36:58.300 --> 02:37:00.300]  Она возвращает класс,
[02:37:00.300 --> 02:37:02.300]  который является типом,
[02:37:02.300 --> 02:37:04.300]  или что?
[02:37:04.300 --> 02:37:06.300]  Нет, объект класса.
[02:37:06.300 --> 02:37:08.300]  Она возвращает тип.
[02:37:08.300 --> 02:37:10.300]  В каком виде?
[02:37:10.300 --> 02:37:12.300]  Вот в таком.
[02:37:12.300 --> 02:37:14.300]  Можно написать вот так.
[02:37:14.300 --> 02:37:16.300]  Decal type от выражения 1 плюс 1.
[02:37:16.300 --> 02:37:18.300]  Ну, давайте, ладно,
[02:37:18.300 --> 02:37:20.300]  просто decal type от...
[02:37:20.300 --> 02:37:22.300]  Не знаю, вот у меня есть int a равно 5.
[02:37:22.300 --> 02:37:24.300]  Потом я говорю decal type от a.
[02:37:24.300 --> 02:37:26.300]  Хочу, чтобы мой variable был ровно
[02:37:26.300 --> 02:37:28.300]  того же типа, что и a. Как я могу это написать?
[02:37:28.300 --> 02:37:30.300]  Вот так.
[02:37:30.300 --> 02:37:32.300]  Такой же тип, как у a, пусть будет variable.
[02:37:32.300 --> 02:37:34.300]  Теперь variable это int.
[02:37:34.300 --> 02:37:36.300]  Unused переменная.
[02:37:42.300 --> 02:37:44.300]  lvalue и rvalue это категории выражения,
[02:37:44.300 --> 02:37:46.300]  это не тип.
[02:37:46.300 --> 02:37:48.300]  Тип и value категории
[02:37:48.300 --> 02:37:50.300]  разные вещи.
[02:37:50.300 --> 02:37:52.300]  Да, амперсанды все сохраняют.
[02:37:52.300 --> 02:37:54.300]  Я смешил вот так.
[02:37:54.300 --> 02:37:56.300]  Теперь...
[02:37:56.300 --> 02:37:58.300]  Он работает не так,
[02:37:58.300 --> 02:38:00.300]  он выводит по-другому.
[02:38:00.300 --> 02:38:02.300]  Вот.
[02:38:06.300 --> 02:38:08.300]  Собственно.
[02:38:08.300 --> 02:38:10.300]  Да, в данном случае variable
[02:38:10.300 --> 02:38:12.300]  будет иметь тип
[02:38:12.300 --> 02:38:14.300]  int%
[02:38:16.300 --> 02:38:18.300]  Вот.
[02:38:20.300 --> 02:38:22.300]  Собственно говоря,
[02:38:22.300 --> 02:38:24.300]  здесь я...
[02:38:26.300 --> 02:38:28.300]  В этих всех примерах показывается
[02:38:28.300 --> 02:38:30.300]  ровно, что тип сохраняется.
[02:38:30.300 --> 02:38:32.300]  Вот.
[02:38:32.300 --> 02:38:34.300]  Ровно такой, какой есть. Вот у меня там, например, есть структура s,
[02:38:34.300 --> 02:38:36.300]  у которой есть int, int% и char
[02:38:36.300 --> 02:38:38.300]  амперсанд, амперсанд.
[02:38:38.300 --> 02:38:40.300]  Я там смотрю,
[02:38:40.300 --> 02:38:42.300]  какой тип будет у вот этого выражения.
[02:38:42.300 --> 02:38:44.300]  Вот у этого выражения будет ровно такой тип.
[02:38:44.300 --> 02:38:46.300]  Смотрите.
[02:38:46.300 --> 02:38:48.300]  s и int
[02:38:48.300 --> 02:38:50.300]  это int% char амперсанд, амперсанд.
[02:38:50.300 --> 02:38:52.300]  Все точно так же.
[02:38:52.300 --> 02:38:54.300]  Через точку тоже так же.
[02:38:54.300 --> 02:38:56.300]  Все. Если мы вызываем
[02:38:56.300 --> 02:38:58.300]  декл-тайп от имени
[02:38:58.300 --> 02:39:00.300]  какого-то объекта, либо от
[02:39:02.300 --> 02:39:04.300]  доступа к этому объекту,
[02:39:04.300 --> 02:39:06.300]  все. Вернули просто его тип.
[02:39:06.300 --> 02:39:08.300]  Видите, здесь
[02:39:08.300 --> 02:39:10.300]  сохраняются все массивы,
[02:39:10.300 --> 02:39:12.300]  сохраняются даже
[02:39:12.300 --> 02:39:14.300]  const char это массив. Все хорошо.
[02:39:16.300 --> 02:39:18.300]  Нет, это все
[02:39:18.300 --> 02:39:20.300]  в компайл-тайме.
[02:39:22.300 --> 02:39:24.300]  Для экспрешена другие правила.
[02:39:24.300 --> 02:39:26.300]  Сейчас мы до них дойдем.
[02:39:32.300 --> 02:39:34.300]  У тебя у любого экспрешена
[02:39:34.300 --> 02:39:36.300]  его тип известен в компайл-тайме.
[02:39:44.300 --> 02:39:46.300]  Да, да.
[02:39:48.300 --> 02:39:50.300]  Вот.
[02:39:50.300 --> 02:39:52.300]  Точно так же. Вот пример.
[02:39:52.300 --> 02:39:54.300]  У меня сентенс, видите,
[02:39:54.300 --> 02:39:56.300]  через авто выведен и
[02:39:56.300 --> 02:39:58.300]  сразу же напрямую декл-тайпом.
[02:39:58.300 --> 02:40:00.300]  И первый выводит еще раз
[02:40:00.300 --> 02:40:02.300]  char звездочку, второй массив.
[02:40:02.300 --> 02:40:04.300]  Вот.
[02:40:04.300 --> 02:40:06.300]  After after const char звездочка
[02:40:06.300 --> 02:40:08.300]  массив.
[02:40:08.300 --> 02:40:10.300]  Окей, декл-тайп экспрешен.
[02:40:14.300 --> 02:40:16.300]  Так, где он начинается?
[02:40:16.300 --> 02:40:18.300]  Вот он начинается.
[02:40:18.300 --> 02:40:20.300]  декл-тайп от экспрешена зависит
[02:40:20.300 --> 02:40:22.300]  от value категории
[02:40:22.300 --> 02:40:24.300]  выражения, которое ему передали.
[02:40:24.300 --> 02:40:26.300]  Если экспрешена
[02:40:26.300 --> 02:40:28.300]  lvalue
[02:40:28.300 --> 02:40:30.300]  категория, ну
[02:40:30.300 --> 02:40:32.300]  glvalue на самом деле,
[02:40:32.300 --> 02:40:34.300]  то он навесит
[02:40:34.300 --> 02:40:36.300]  1%. Если rvalue,
[02:40:36.300 --> 02:40:38.300]  то навесит 2%.
[02:40:38.300 --> 02:40:40.300]  Соответственно,
[02:40:40.300 --> 02:40:42.300]  смешное, так сказать,
[02:40:42.300 --> 02:40:44.300]  нюанс.
[02:40:44.300 --> 02:40:46.300]  Если я добавлю скобочки
[02:40:46.300 --> 02:40:48.300]  вокруг, вот здесь вот, что написано?
[02:40:48.300 --> 02:40:50.300]  Здесь написаны примеры, которые были раньше.
[02:40:50.300 --> 02:40:52.300]  Только я везде добавил скобочки.
[02:40:52.300 --> 02:40:54.300]  Вот раньше у меня был
[02:40:54.300 --> 02:40:56.300]  se, это
[02:40:56.300 --> 02:40:58.300]  ну что-то вот такое.
[02:40:58.300 --> 02:41:00.300]  А теперь se в скобочках.
[02:41:00.300 --> 02:41:02.300]  Что делают скобочки? Скобочки
[02:41:02.300 --> 02:41:04.300]  изменяют тот
[02:41:04.300 --> 02:41:06.300]  декл-тайп, в который мы попадаем, потому что больше это не просто
[02:41:06.300 --> 02:41:08.300]  название объекта, это уже какое-то
[02:41:08.300 --> 02:41:10.300]  выражение. Более того, это
[02:41:10.300 --> 02:41:12.300]  lvalue выражение в данном случае.
[02:41:12.300 --> 02:41:14.300]  Вот.
[02:41:14.300 --> 02:41:16.300]  Соответственно,
[02:41:16.300 --> 02:41:18.300]  вот единичка там в скобочках
[02:41:18.300 --> 02:41:20.300]  нам выдает
[02:41:20.300 --> 02:41:22.300]  просто int.
[02:41:22.300 --> 02:41:24.300]  Потому что я вам набрал.
[02:41:24.300 --> 02:41:26.300]  Тут тонкий момент, значит.
[02:41:26.300 --> 02:41:28.300]  Ладно, давайте сначала не тонкий момент
[02:41:28.300 --> 02:41:30.300]  разберем. Видите, у нас все это
[02:41:30.300 --> 02:41:32.300]  lvalue выражение мы просто навесили 1%.
[02:41:32.300 --> 02:41:34.300]  То есть
[02:41:34.300 --> 02:41:36.300]  раньше у нас se выдавал int,
[02:41:36.300 --> 02:41:38.300]  теперь se выдает int%.
[02:41:38.300 --> 02:41:40.300]  С стрелочка
[02:41:40.300 --> 02:41:42.300]  i выдавал int, выдает int%.
[02:41:42.300 --> 02:41:44.300]  С стрелочка r, референс,
[02:41:44.300 --> 02:41:46.300]  выдавал int%,
[02:41:46.300 --> 02:41:48.300]  навесили еще 1%, они не схлопнулись.
[02:41:48.300 --> 02:41:50.300]  Все еще int%.
[02:41:50.300 --> 02:41:52.300]  был char
[02:41:52.300 --> 02:41:54.300]  навесили 1%,
[02:41:54.300 --> 02:41:56.300]  стал 1%, по правилу
[02:41:56.300 --> 02:41:58.300]  схлопывания амперсантов.
[02:41:58.300 --> 02:42:00.300]  Скобочки навешивают 1%,
[02:42:00.300 --> 02:42:02.300]  правильно? Нет.
[02:42:02.300 --> 02:42:04.300]  Скобочки в зависимости от
[02:42:04.300 --> 02:42:06.300]  категории выражения навешивают
[02:42:06.300 --> 02:42:08.300]  на самом деле от 0 до 2 амперсантов.
[02:42:08.300 --> 02:42:10.300]  Если это lvalue, то всегда 1%.
[02:42:16.300 --> 02:42:18.300]  Вот, от 0, потому что, смотрите,
[02:42:18.300 --> 02:42:20.300]  у нас раньше был int literal,
[02:42:20.300 --> 02:42:22.300]  он возвращал нам
[02:42:22.300 --> 02:42:24.300]  с скобочками тоже возвращает.
[02:42:24.300 --> 02:42:26.300]  Это на самом деле всегда выражение,
[02:42:26.300 --> 02:42:28.300]  скобочки ничего не меняют.
[02:42:28.300 --> 02:42:30.300]  Для rvalue
[02:42:30.300 --> 02:42:32.300]  в разных ситуациях они могут навесить либо 0
[02:42:32.300 --> 02:42:34.300]  амперсантов, либо 2 амперсанта.
[02:42:38.300 --> 02:42:40.300]  Он не смотрит.
[02:42:40.300 --> 02:42:42.300]  Значит, смотрите,
[02:42:42.300 --> 02:42:44.300]  для xvalue
[02:42:44.300 --> 02:42:46.300]  мы навешиваем
[02:42:46.300 --> 02:42:48.300]  2 амперсанта.
[02:42:48.300 --> 02:42:50.300]  А для rvalue, который не xvalue,
[02:42:50.300 --> 02:42:52.300]  мы навешиваем 0 амперсанта.
[02:43:00.300 --> 02:43:02.300]  На самом деле, давайте
[02:43:02.300 --> 02:43:04.300]  более понятным языком.
[02:43:08.300 --> 02:43:10.300]  Я попробую коротко объяснить,
[02:43:10.300 --> 02:43:12.300]  что такое xvalue.
[02:43:12.300 --> 02:43:14.300]  У нас есть rvalue.
[02:43:14.300 --> 02:43:16.300]  Какие у нас бывают rvalue?
[02:43:16.300 --> 02:43:18.300]  rvalue это либо что-то возвращается из какой-то функции
[02:43:18.300 --> 02:43:20.300]  или оператора, правильно? Объект просто
[02:43:20.300 --> 02:43:22.300]  бессылочный.
[02:43:22.300 --> 02:43:24.300]  Либо объект возвращается с навешанными
[02:43:24.300 --> 02:43:26.300]  двумя ссылками.
[02:43:26.300 --> 02:43:28.300]  Вот, если
[02:43:28.300 --> 02:43:30.300]  в тупую
[02:43:30.300 --> 02:43:32.300]  и без подробностей, то
[02:43:32.300 --> 02:43:34.300]  xvalue это, если у нас
[02:43:34.300 --> 02:43:36.300]  возвращается штука с двумя ссылками,
[02:43:36.300 --> 02:43:38.300]  а prvalue это, если
[02:43:38.300 --> 02:43:40.300]  возвращается просто тип
[02:43:40.300 --> 02:43:42.300]  бессылочный.
[02:43:42.300 --> 02:43:44.300]  Все.
[02:43:46.300 --> 02:43:48.300]  Если xvalue, то
[02:43:48.300 --> 02:43:50.300]  вот если здесь поставлю
[02:43:50.300 --> 02:43:52.300]  sudo move,
[02:43:52.300 --> 02:43:54.300]  то скобочки добавят 2.
[02:43:56.300 --> 02:43:58.300]  Да.
[02:44:00.300 --> 02:44:02.300]  Вот.
[02:44:02.300 --> 02:44:04.300]  Видите, теперь int%
[02:44:06.300 --> 02:44:08.300]  2 на 2.
[02:44:08.300 --> 02:44:10.300]  Да.
[02:44:12.300 --> 02:44:14.300]  Сейчас.
[02:44:14.300 --> 02:44:16.300]  Почему
[02:44:16.300 --> 02:44:18.300]  скобочки это всегда так работает, да?
[02:44:18.300 --> 02:44:20.300]  А почему, допустим,
[02:44:20.300 --> 02:44:22.300]  если мы подадим...
[02:44:22.300 --> 02:44:24.300]  Нет, скобочки, еще раз, скобочки сами по себе
[02:44:24.300 --> 02:44:26.300]  ничего не делают. Вот, возможно,
[02:44:26.300 --> 02:44:28.300]  совершил ошибку. Скобочки ничего не делают.
[02:44:28.300 --> 02:44:30.300]  Скобочки просто изменяют
[02:44:30.300 --> 02:44:32.300]  тот декл-тайп, в который мы попали.
[02:44:32.300 --> 02:44:34.300]  Есть 2 версии
[02:44:34.300 --> 02:44:36.300]  декл-тайпа. Одна просто
[02:44:36.300 --> 02:44:38.300]  типа наименований,
[02:44:38.300 --> 02:44:40.300]  а другая от выражений.
[02:44:40.300 --> 02:44:42.300]  И вот скобочки
[02:44:42.300 --> 02:44:44.300]  превращают наименование в выражение.
[02:44:46.300 --> 02:44:48.300]  Да. Значит, поэтому
[02:44:48.300 --> 02:44:50.300]  сейчас вот будет следующая тема.
[02:44:52.300 --> 02:44:54.300]  Да.
[02:44:58.300 --> 02:45:00.300]  А сейчас сколько?
[02:45:00.300 --> 02:45:02.300]  Ага, окей, хорошо.
[02:45:04.300 --> 02:45:06.300]  Еще сейчас часик.
[02:45:06.300 --> 02:45:08.300]  Быстро говорю. Смотрите, можно
[02:45:08.300 --> 02:45:10.300]  писать декл-тайп от авто? Ну, мы начали
[02:45:10.300 --> 02:45:12.300]  позже, между прочим.
[02:45:12.300 --> 02:45:14.300]  Мы начали позже. Можно
[02:45:14.300 --> 02:45:16.300]  писать декл-тайпа от авто, например, в возвращаемом значении
[02:45:16.300 --> 02:45:18.300]  функции. Что это значит?
[02:45:18.300 --> 02:45:20.300]  Это значит,
[02:45:20.300 --> 02:45:22.300]  что
[02:45:22.300 --> 02:45:24.300]  мы просим компилятор здесь
[02:45:24.300 --> 02:45:26.300]  выводить возвращаемое значение
[02:45:26.300 --> 02:45:28.300]  не как по правилам авто, а по
[02:45:28.300 --> 02:45:30.300]  правилам декл-тайпа.
[02:45:30.300 --> 02:45:32.300]  Да.
[02:45:32.300 --> 02:45:34.300]  Ну, мы просто просим компилятор
[02:45:34.300 --> 02:45:36.300]  выводить возвращаемое значение не по правилам авто
[02:45:36.300 --> 02:45:38.300]  с отбрасыванием констам, с отбрасыванием
[02:45:38.300 --> 02:45:40.300]  амперсандов, а по правилам декл-тайпа
[02:45:40.300 --> 02:45:42.300]  с трушным типом.
[02:45:42.300 --> 02:45:44.300]  Окей? Соответственно,
[02:45:44.300 --> 02:45:46.300]  важное замечание. Если у вас есть какая-то функция
[02:45:46.300 --> 02:45:48.300]  voidf,
[02:45:48.300 --> 02:45:50.300]  которая, значит,
[02:45:50.300 --> 02:45:52.300]  возвращает декл-тайп авто,
[02:45:52.300 --> 02:45:54.300]  то у вас есть
[02:45:54.300 --> 02:45:56.300]  функция,
[02:45:56.300 --> 02:45:58.300]  которая, значит,
[02:45:58.300 --> 02:46:00.300]  возвращает декл-тайп авто.
[02:46:00.300 --> 02:46:02.300]  То вот это
[02:46:04.300 --> 02:46:06.300]  void
[02:46:06.300 --> 02:46:08.300]  лишний.
[02:46:08.300 --> 02:46:10.300]  То вот это
[02:46:10.300 --> 02:46:12.300]  не то же самое, что вот это.
[02:46:12.300 --> 02:46:14.300]  Окей?
[02:46:14.300 --> 02:46:16.300]  Поэтому просто так лишний раз
[02:46:16.300 --> 02:46:18.300]  скобочки позаретерна не пишите.
[02:46:20.300 --> 02:46:22.300]  Да.
[02:46:22.300 --> 02:46:24.300]  Я буквально
[02:46:24.300 --> 02:46:26.300]  не понимаю,
[02:46:26.300 --> 02:46:28.300]  что это значит.
[02:46:28.300 --> 02:46:30.300]  Я буквально на той неделе
[02:46:30.300 --> 02:46:32.300]  на баш за такую фигню.
[02:46:36.300 --> 02:46:38.300]  Нет.
[02:46:38.300 --> 02:46:40.300]  Здесь будет 0 амперсандов.
[02:46:44.300 --> 02:46:46.300]  Так.
[02:46:48.300 --> 02:46:50.300]  Что мы не успели
[02:46:50.300 --> 02:46:52.300]  с вами рассказать?
[02:46:58.300 --> 02:47:00.300]  А, нет.
[02:47:00.300 --> 02:47:02.300]  Этого уже сегодня точно не успеем.
[02:47:02.300 --> 02:47:04.300]  Давайте я скажу, что
[02:47:06.300 --> 02:47:08.300]  смотрите.
[02:47:08.300 --> 02:47:10.300]  Соответственно, декл-тайп авто
[02:47:10.300 --> 02:47:12.300]  работает тоже в объявлении
[02:47:12.300 --> 02:47:14.300]  переменных. Его можно писать.
[02:47:14.300 --> 02:47:16.300]  В аргументах функции нельзя.
[02:47:16.300 --> 02:47:18.300]  И еще
[02:47:18.300 --> 02:47:20.300]  одна его особенность. Если вы пишете декл-тайп авто,
[02:47:20.300 --> 02:47:22.300]  вы никак не можете его изменять. Вы не можете
[02:47:22.300 --> 02:47:24.300]  написать constant декл-тайп авто.
[02:47:24.300 --> 02:47:26.300]  Так нельзя. Вы не можете написать
[02:47:26.300 --> 02:47:28.300]  декл-тайп авто амперсанд.
[02:47:28.300 --> 02:47:30.300]  Так нельзя.
[02:47:30.300 --> 02:47:32.300]  Декл-тайп авто должен быть сам по себе.
[02:47:34.300 --> 02:47:36.300]  Нет.
[02:47:36.300 --> 02:47:38.300]  Нельзя.
[02:47:42.300 --> 02:47:44.300]  Нельзя.
[02:47:46.300 --> 02:47:48.300]  А зачем?
[02:47:48.300 --> 02:47:50.300]  Да.
[02:47:50.300 --> 02:47:52.300]  Декл-тайп от авто
[02:47:52.300 --> 02:47:54.300]  это вот такая конструкция языка.
[02:47:54.300 --> 02:47:56.300]  Нет.
[02:48:02.300 --> 02:48:04.300]  Ну, типа.
[02:48:06.300 --> 02:48:08.300]  Вот.
[02:48:10.300 --> 02:48:12.300]  Собственно говоря,
[02:48:14.300 --> 02:48:16.300]  если коротко, то все.
[02:48:16.300 --> 02:48:18.300]  Соответственно, вот здесь можно
[02:48:18.300 --> 02:48:20.300]  проходить по вектору булов даже.
[02:48:20.300 --> 02:48:22.300]  Типа
[02:48:22.300 --> 02:48:24.300]  не рекомендую, но можно.
[02:48:24.300 --> 02:48:26.300]  Вот.
[02:48:26.300 --> 02:48:28.300]  Тогда давайте, наверное, заканчивать.
[02:48:28.300 --> 02:48:30.300]  Я вам
[02:48:30.300 --> 02:48:32.300]  вышлю еще тогда в чатик этот
[02:48:32.300 --> 02:48:34.300]  код и еще
[02:48:34.300 --> 02:48:36.300]  некоторый другой.
[02:48:36.300 --> 02:48:38.300]  Да, я вам вышлю код,
[02:48:38.300 --> 02:48:40.300]  где используется
[02:48:40.300 --> 02:48:42.300]  возвращаемый значение декл-тайп. Еще, значит,
[02:48:42.300 --> 02:48:44.300]  быстренько с них пикну вот такую штуку,
[02:48:44.300 --> 02:48:46.300]  которая с помощью, вот это вот квинтэссенция
[02:48:46.300 --> 02:48:48.300]  всей этой пары. Значит, вы можете
[02:48:48.300 --> 02:48:50.300]  вот
[02:48:50.300 --> 02:48:52.300]  у нас добавились, кажется, в 20 или 23
[02:48:52.300 --> 02:48:54.300]  плюсах
[02:48:54.300 --> 02:48:56.300]  вывод ЗИСа.
[02:48:56.300 --> 02:48:58.300]  Конст, не конст. Можно было раньше
[02:48:58.300 --> 02:49:00.300]  так сделать. Вот здесь
[02:49:00.300 --> 02:49:02.300]  у нас как-то
[02:49:02.300 --> 02:49:04.300]  вы когда пишете квадратные скобочки, вам обычно нужно копировать
[02:49:04.300 --> 02:49:06.300]  код
[02:49:06.300 --> 02:49:08.300]  два раза. Для константной версии,
[02:49:08.300 --> 02:49:10.300]  для неконстантной версии. Либо делать конст-каст.
[02:49:10.300 --> 02:49:12.300]  Вот эта версия делать
[02:49:12.300 --> 02:49:14.300]  без конд-каста автоматически
[02:49:16.300 --> 02:49:18.300]  копию одной и той же функции для
[02:49:18.300 --> 02:49:20.300]  константового и неконстантного типа.
[02:49:20.300 --> 02:49:22.300]  Вот нужно посидеть, подумать,
[02:49:22.300 --> 02:49:24.300]  как это работает.
[02:49:24.300 --> 02:49:26.300]  Если вы это поймете, мне кажется, вы поняли,
[02:49:26.300 --> 02:49:28.300]  что было сегодня за пары.
[02:49:30.300 --> 02:49:32.300]  Вот.
[02:49:34.300 --> 02:49:36.300]  Все.
