[00:00.000 --> 00:11.000]  Продолжаем туризм по деревья поиска, и в следующий раз тоже у нас будет дерево поиска, в последний раз, на последний лекции.
[00:11.000 --> 00:19.000]  Значит, сегодня мы договорим про B-дерево, которое в прошлый раз начали, и Декартово дерево тоже обсудим.
[00:19.000 --> 00:25.000]  Начинаем с B-дерева. Давайте я быстренько напомню, что это такое.
[00:25.000 --> 00:32.000]  Во-первых, мы договорились, что в каждом узле у меня теперь может быть не один ключ, ни одного значения, а довольно много.
[00:32.000 --> 00:36.000]  Первый ключ, второй ключ и так далее, вплоть до там S-ключей.
[00:36.000 --> 00:51.000]  И вот это S, оно обычно, то есть вне корневой вершинки, должно быть от T-1 до 2T-1, если это не корень.
[00:51.000 --> 00:56.000]  Если это корень, то должно быть от 1 до 2T-1.
[00:56.000 --> 01:00.000]  S больше 1, не больше 2T-1.
[01:00.000 --> 01:04.000]  Это условие на количество ключей в каждом узле.
[01:04.000 --> 01:08.000]  Еще у нас было адекватное требование, чтобы все листины на одной глубине.
[01:13.000 --> 01:15.000]  На одной глубине.
[01:15.000 --> 01:19.000]  Напоминаю, как работает много ключей в одном узле.
[01:19.000 --> 01:27.000]  Если у нас есть много чисел K1, K2 и так далее, то между каждым двумя есть какая-то стрелочка на следующий узел.
[01:27.000 --> 01:30.000]  Если исходный не лист, то обязательно есть отсюда какой-то указатель.
[01:30.000 --> 01:36.000]  То же самое есть какой-то указатель из этой точки, которая стоит левее K1.
[01:37.000 --> 01:39.000]  Здесь будет S плюс один указатель.
[01:39.000 --> 01:46.000]  Все числа, скажем, располагающиеся в этой вершинке, даже во всем этом поддереве, которые идут ниже этой стрелки,
[01:46.000 --> 01:50.000]  здесь все числа должны быть больше, чем K1, но меньше, чем K2.
[01:50.000 --> 01:56.000]  Все числа здесь действительно находятся между K1 и K2, в том интервале между K1 и K2.
[01:56.000 --> 02:00.000]  Соответственно, здесь все числа должны быть меньше, чем K1.
[02:00.000 --> 02:04.000]  Здесь в правом поддереве все числа должны быть больше, чем Ks.
[02:04.000 --> 02:06.000]  А можно на время помнить, что такое T?
[02:06.000 --> 02:10.000]  T – это произвольный фиксированный параметр.
[02:10.000 --> 02:15.000]  Просто какое-то число. Обычно оно выбирается порядка тысячи.
[02:15.000 --> 02:20.000]  А стрелка между K1 и K2 от чего ведет?
[02:20.000 --> 02:27.000]  Нам нужна просто структура данных, которая задает нам каждый узел, структ ноди, структура вершинки.
[02:27.000 --> 02:31.000]  И в этой вершинке будет S чисел просто и S плюс один указатель на остальные ноды.
[02:31.000 --> 02:35.000]  Соответственно, здесь будет там нулевой указатель, здесь будет первый указатель, и так далее.
[02:35.000 --> 02:38.000]  Здесь будет S-ты указатель в ноль ноксации.
[02:38.000 --> 02:40.000]  То есть фактически они не связаны?
[02:40.000 --> 02:43.000]  Ну так просто есть S-ты и S плюс один указатель.
[02:43.000 --> 02:45.000]  В двух разных массивах лежат.
[02:45.000 --> 02:47.000]  Просто их так удобно, удобнее рисовать.
[02:47.000 --> 02:51.000]  В плане реализации это просто отдельные сущности, они не связаны.
[02:51.000 --> 02:53.000]  Вот. Хорошо.
[02:53.000 --> 02:59.000]  Здесь же, да, тут, во-первых, можно пояснить немножко, почему это называется B дерево.
[02:59.000 --> 03:03.000]  Что такое B? Хотя у нас, казалось бы, естественно, было бы называть T деревом.
[03:03.000 --> 03:10.000]  Во-первых, B – это классическое название переменной,
[03:10.000 --> 03:15.000]  которое означает страницу памяти, которую вы можете легко подгружать в вашу оперативку.
[03:15.000 --> 03:21.000]  Я говорю в прошлый раз, что у вас простая операция – это считать описание одной вершины до одного узла.
[03:21.000 --> 03:28.000]  То есть порядка 2T ключей вы можете легко прочитать и, соответственно, узнать, куда идут все эти стрелки.
[03:28.000 --> 03:31.000]  Просто как число указателей.
[03:31.000 --> 03:39.000]  И это вы как бы можете считать за одну простую операцию – выгрузки этой страницы данных в вашу оперативку.
[03:39.000 --> 03:45.000]  То есть вы просто берете какой-то блок памяти, B – блок памяти,
[03:45.000 --> 03:50.000]  подгружаете себе в оперативку, как одну страницу оперативной памяти, и с ней работать.
[03:50.000 --> 03:55.000]  И это просто классическое обозначение для переменной, которое означает размер страницы памяти,
[03:55.000 --> 04:01.000]  которую вы можете на халяву, грубо говоря, за одну операцию, за один такт подгружать в оперативку.
[04:01.000 --> 04:07.000]  И есть отдельная область в теории алгоритмов – это алгоритмы во внешней памяти.
[04:07.000 --> 04:10.000]  Алгоритмы во внешней памяти.
[04:10.000 --> 04:15.000]  Мы вот ими, к сожалению, не особенно занимаемся, кроме этого B дерева во внешней памяти.
[04:15.000 --> 04:25.000]  Это как раз задачей, когда объем данных слишком велик для того, чтобы весь поддерживать в какой-то малооперативной памяти.
[04:25.000 --> 04:28.000]  У вас есть огромная база данных на флешке или на диске,
[04:28.000 --> 04:34.000]  и вам нужно с ней что-то сделать, использовать только вашу маленькую оперативную память в единице гигабайт.
[04:34.000 --> 04:39.000]  И тогда B обычно как раз таки называется какой-нибудь размер памяти,
[04:39.000 --> 04:44.000]  который вы можете быстро подгрузить в оперативку.
[04:44.000 --> 04:48.000]  Ну, это просто такая традиция, что это называется буквой B.
[04:48.000 --> 04:53.000]  Хорошо, давайте тогда обсудим, как делать find сначала в таком дереве.
[04:53.000 --> 04:55.000]  Find в B дереве.
[04:55.000 --> 04:56.000]  И за сколько это делать?
[04:56.000 --> 04:58.000]  Ну, смотрите, встанем в корень.
[04:58.000 --> 05:01.000]  Давайте find какого-то ключа X.
[05:01.000 --> 05:04.000]  Встали в корень, прошли по всем ключам.
[05:04.000 --> 05:07.000]  Если один из ключей равен X, то мы уже нашли этот X в нашем дереве.
[05:07.000 --> 05:11.000]  Иначе мы однозначно можем локализовать, между какими двумя ключами этот X находится.
[05:11.000 --> 05:14.000]  Скажем, вот прошлись просто вступуя по всему этому узлу.
[05:14.000 --> 05:17.000]  Напоминаю, что здесь не особо есть смысл делать бинпоиск.
[05:17.000 --> 05:21.000]  Хоть наши ключи в каждом узле и упорядочены, нет смысла делать бинпоиск,
[05:21.000 --> 05:24.000]  потому что нам все равно нужно эти ключи сначала откуда-то считать.
[05:24.000 --> 05:29.000]  Ну, это я не веду в таком реальном случае, когда у нас огромное дерево не помещается в нашей памяти.
[05:29.000 --> 05:33.000]  Конечно, в наших хантестах на WebForces там можно писать B дерево,
[05:33.000 --> 05:37.000]  целиком выхраняя в оперативной памяти, поэтому то, что я говорю, не совсем валидно.
[05:37.000 --> 05:40.000]  Но, тем не менее, давайте считать, что вот в таком в реале
[05:40.000 --> 05:43.000]  нам не обязательно здесь искать X бинарным поиском.
[05:43.000 --> 05:47.000]  Можно просто пройти слева-направо по этой вершине и найти просто два средних элемента,
[05:47.000 --> 05:49.000]  так вот что левый меньше, и микс правый больше.
[05:49.000 --> 05:53.000]  Скажем, вот этот элемент меньше, чем X, этот больше, чем X.
[05:53.000 --> 05:57.000]  Значит, если X где-то в дереве находится, то он гарантированно лежит в поддереве,
[05:57.000 --> 05:59.000]  которое получается вот в этой стрелке.
[05:59.000 --> 06:01.000]  То есть мы смотрим стрелки между этими двумя элементами,
[06:01.000 --> 06:06.000]  то есть если этот элемент ИТ, это И плюс первый, то соответственно нам нужна ИТ-стрелка.
[06:06.000 --> 06:08.000]  Или там И минус первая. Ну, короче, что-то такое.
[06:08.000 --> 06:11.000]  Нам нужна стрелка, разделяющая это И плюс второй элемент.
[06:11.000 --> 06:13.000]  Просто спускаемся сюда и запускаемся тем же самым.
[06:13.000 --> 06:19.000]  Просто находим X в вершине, если он есть, то мы его нашли, иначе нужно куда-то спуститься.
[06:19.000 --> 06:24.000]  Простейший файнк, собственно, точно так же, как мы делали в обычном бинарном двоичном дереве поиска,
[06:24.000 --> 06:26.000]  когда у каждой вершины два сына.
[06:26.000 --> 06:31.000]  Только здесь сыновей больше, нужно просто понять, в какого из сыновей нужно переходить.
[06:31.000 --> 06:36.000]  Соответственно, асимптотика будет этого этой процедуры.
[06:36.000 --> 06:41.000]  То есть я напишу так, T умножить на лог N по основанию T.
[06:41.000 --> 06:46.000]  Мы в прошлый раз обосновали, что вот эта вот глубина, да, оценка на глубину.
[06:46.000 --> 06:50.000]  Ну, а это соответственно то, за сколько мы каждую вершину там считываем в память
[06:50.000 --> 06:53.000]  и находим указатель, по которому нужно сдвинуться.
[06:53.000 --> 06:56.000]  Вот, T на лодерифм N по основанию T.
[06:56.000 --> 06:58.000]  Ну и повторюсь, обычно T считается какой-то константой,
[06:58.000 --> 07:05.000]  поэтому здесь как бы я напишу тогда, ну, я напишу просто равно от log N, если T константа.
[07:05.000 --> 07:08.000]  То есть обычно T берется действительно какой-то константой,
[07:08.000 --> 07:15.000]  ну просто T такое, что вы можете очень быстро подгрузить один узел размера линейного по T в вашу память.
[07:15.000 --> 07:18.000]  Ну, соответственно, T, какая-то константа, зависит от характеристики компьютера,
[07:18.000 --> 07:22.000]  ну и удачи, когда это будет логерифм от размера дерева.
[07:22.000 --> 07:24.000]  Так, вопрос в чате.
[07:24.000 --> 07:31.000]  Как узнать, сколько реальных существует элементов в левой части дерева относительно стрелки?
[07:31.000 --> 07:35.000]  Сколько на самом деле существует элементов в левой части дерева относительно стрелки?
[07:35.000 --> 07:37.000]  Не понял вопрос.
[07:37.000 --> 07:40.000]  Ну, то есть допустим, у нас огромное B дерево, там одно ряда миллиарда,
[07:40.000 --> 07:44.000]  мы типа закинули два, потом 20 тысяч, потом 200 тысяч,
[07:44.000 --> 07:48.000]  и пошли искать, например, по стрелке, которая указывает там, ну, 40.
[07:48.000 --> 07:50.000]  Что значит закинули? Сделали инсерт?
[07:50.000 --> 07:52.000]  Да, типа того.
[07:52.000 --> 07:54.000]  Они обсуждали, инсерт делать более сложно.
[07:54.000 --> 07:56.000]  Мы пока что считаем, что у меня есть корректное B дерево.
[07:56.000 --> 07:58.000]  Вот, пока что мы в нем сделали самую простую операцию Find.
[07:58.000 --> 08:00.000]  Инсерты и Ray сейчас будут чуть позже.
[08:02.000 --> 08:06.000]  Итак, ну вот, Find работает за, ну, грубо говоря, за логарифм.
[08:06.000 --> 08:08.000]  Начинается операция самая простая.
[08:08.000 --> 08:10.000]  Теперь давайте перейдем к реализации инсерта.
[08:10.000 --> 08:15.000]  Дарас как раз спрашивает, как производится инсерт, каков-то ключа X.
[08:15.000 --> 08:17.000]  Значит, идеальная ситуация была бы следующей.
[08:17.000 --> 08:23.000]  Давайте запустим процедуру Find X, и в поисках этого X,
[08:23.000 --> 08:27.000]  ну, то есть, если X есть в дереве, то, понятно, добавлять ничего не нужно.
[08:27.000 --> 08:29.000]  Мы считаем, что мы храним именно множество, а не мультимножество,
[08:29.000 --> 08:31.000]  поэтому кратности мы не храним.
[08:31.000 --> 08:33.000]  Если X был в дереве, то делать ничего не нужно.
[08:33.000 --> 08:37.000]  Иначе, если X в дереве не было, то мы, получается, как дело?
[08:37.000 --> 08:39.000]  Мы встали в корень, там X не нашли, спустились куда-то,
[08:39.000 --> 08:41.000]  опять X не нашли, куда спустились, и так далее, и так далее,
[08:41.000 --> 08:43.000]  дошли до листа.
[08:43.000 --> 08:45.000]  То есть, мы в поисках X-а прошли всю глубину дерева, дошли до какого-то листа.
[08:45.000 --> 08:47.000]  И даже в этом листе X-а нет.
[08:47.000 --> 08:51.000]  Тогда самый простой способ, это давайте просто вставим X в то место в листе,
[08:51.000 --> 08:53.000]  где он должен был находиться.
[08:53.000 --> 08:55.000]  То есть, если есть лист, порядочный список ключей,
[08:55.000 --> 08:59.000]  давайте просто найдем два средних ключа, между которыми должен стоять X,
[08:59.000 --> 09:01.000]  и вот это поместим.
[09:01.000 --> 09:05.000]  Давайте я кратко это, как вы пишу, запускаем.
[09:05.000 --> 09:15.000]  Если X был в дереве, то делать ничего не нужно.
[09:15.000 --> 09:17.000]  Делать ничего не нужно.
[09:17.000 --> 09:23.000]  Иначе, мы спустились до листа, и даже в этом листе нету X-а.
[09:23.000 --> 09:29.000]  Мы спустились до листа, и даже в этом листе нету X-а.
[09:29.000 --> 09:31.000]  Дальше я отражаю следующее.
[09:31.000 --> 09:35.000]  Что если в этом листе меньше, чем 2t-1 ключ,
[09:35.000 --> 09:39.000]  тогда туда можно на халяву вставить X.
[09:39.000 --> 09:47.000]  Если в этом листе меньше, чем 2t-1 ключ,
[09:47.000 --> 09:51.000]  просто ставим в него X.
[09:51.000 --> 09:53.000]  Вот тогда инвариант нашего дерева сохранится.
[09:53.000 --> 09:57.000]  То есть, по-прежнему в каждой вершине не больше, чем 2t-1 ключ.
[09:57.000 --> 10:01.000]  Все требования на бытелье выполняются.
[10:01.000 --> 10:03.000]  Структуру мы не перестроили.
[10:03.000 --> 10:05.000]  Соответственно, все листья остались на одной глубине,
[10:05.000 --> 10:07.000]  если не раньше были на одной глубине.
[10:07.000 --> 10:09.000]  Поэтому осталось корректное бытелье.
[10:09.000 --> 10:11.000]  То есть, если в таком идеальном случае мы дошли до листа,
[10:11.000 --> 10:13.000]  и лист у нас не запустился,
[10:13.000 --> 10:15.000]  то лист у нас не запустился,
[10:15.000 --> 10:17.000]  то лист у нас не запустился.
[10:17.000 --> 10:19.000]  Если в таком идеальном случае мы дошли до листа,
[10:19.000 --> 10:21.000]  и лист у нас не целиком заполненный,
[10:21.000 --> 10:23.000]  и у него можно вставить еще один новый элемент X,
[10:23.000 --> 10:25.000]  тогда вот такая очень простая операция.
[10:25.000 --> 10:27.000]  Мы просто спускаемся и в нужное вершину вставляем X.
[10:27.000 --> 10:29.000]  В смысле, в нужное место.
[10:29.000 --> 10:31.000]  Что у нас было?
[10:31.000 --> 10:33.000]  У нас был лист.
[10:33.000 --> 10:37.000]  Здесь был какой-то отсортированный список чисел K1, K2, Ks.
[10:37.000 --> 10:39.000]  Дальше мы определяем двух соседей,
[10:39.000 --> 10:41.000]  между которыми нужно вставить X.
[10:41.000 --> 10:43.000]  И просто создаем новый список.
[10:43.000 --> 10:45.000]  В него перекопируем K1, K2, Ki.
[10:45.000 --> 10:47.000]  Потом пишем X, потом Ki плюс 1,
[10:47.000 --> 10:49.000]  и так далее Ks.
[10:49.000 --> 10:51.000]  Поскольку все равно мы работаем за время
[10:51.000 --> 10:53.000]  пропорционально T в каждом листике,
[10:53.000 --> 10:55.000]  в каждом узле,
[10:55.000 --> 10:57.000]  то я могу заново создать новое описание этого листа,
[10:57.000 --> 10:59.000]  перекопировать туда все старые ключи,
[10:59.000 --> 11:01.000]  вставить X, перекопировать все
[11:01.000 --> 11:03.000]  старые ключи больше X
[11:03.000 --> 11:05.000]  и поставить этот лист на место того предыдущего.
[11:05.000 --> 11:07.000]  То есть,
[11:07.000 --> 11:09.000]  не нужно никаких хитрых вставок делать.
[11:09.000 --> 11:11.000]  Не нужно, например, еще одно
[11:11.000 --> 11:13.000]  дерево поиска внутри каждого узла.
[11:13.000 --> 11:15.000]  Это не нужно, мы просто храним там какой-то массив,
[11:15.000 --> 11:17.000]  который явно перестраиваем.
[11:17.000 --> 11:19.000]  Копируем префикс, вставляем X,
[11:19.000 --> 11:21.000]  копируем софикс. И это все безобразие.
[11:21.000 --> 11:23.000]  Теперь помещаем на место старого листа.
[11:23.000 --> 11:25.000]  Вот это простой случай,
[11:25.000 --> 11:27.000]  когда действительно мы дошли до низа.
[11:27.000 --> 11:29.000]  Нужно разумеется дать вершинку
[11:29.000 --> 11:31.000]  собственно соответствующую X.
[11:31.000 --> 11:33.000]  Нет, смотри,
[11:33.000 --> 11:35.000]  у нас вершин сильно меньше,
[11:35.000 --> 11:37.000]  чем ключей. Примерно в T раз меньше.
[11:37.000 --> 11:39.000]  Потому что каждая вершина
[11:39.000 --> 11:41.000]  соответствует примерно от T
[11:41.000 --> 11:43.000]  до двух T ключей.
[11:43.000 --> 11:45.000]  И в случае как раз, когда эта вершина недозаполнена
[11:45.000 --> 11:47.000]  и в ней меньше, чем два тайма своим ключ,
[11:47.000 --> 11:49.000]  то можно просто ничего, ну как бы,
[11:49.000 --> 11:51.000]  не нужно вставать новую вершинку, можно просто этот текст
[11:51.000 --> 11:53.000]  вклинить в старую.
[11:53.000 --> 11:55.000]  Здесь только множество ключей
[11:55.000 --> 11:57.000]  внутри этой вершины.
[11:57.000 --> 11:59.000]  Обычно ключи соответствуют значения.
[11:59.000 --> 12:01.000]  То есть, мы по ключу храним какое значение.
[12:01.000 --> 12:03.000]  Значит ли это то, что в одной вершине мы храним
[12:03.000 --> 12:05.000]  много значений?
[12:05.000 --> 12:07.000]  Вместе с много ключами.
[12:07.000 --> 12:09.000]  Если мы храним...
[12:09.000 --> 12:11.000]  Это вы про другую задачу.
[12:11.000 --> 12:13.000]  То есть, скажу так.
[12:13.000 --> 12:15.000]  Сейчас скажу.
[12:15.000 --> 12:17.000]  Вообще задачу,
[12:17.000 --> 12:19.000]  которую мы сейчас решаем,
[12:19.000 --> 12:21.000]  это научиться реализовывать структуру данных,
[12:21.000 --> 12:23.000]  которую умеет делать find, insert и erase.
[12:23.000 --> 12:25.000]  И там вот то, что вы говорите,
[12:25.000 --> 12:27.000]  у нас не нужно
[12:27.000 --> 12:29.000]  поддерживать значение. Если нужно,
[12:29.000 --> 12:31.000]  то просто давайте хранить пару X,
[12:31.000 --> 12:33.000]  запятая Y от X.
[12:33.000 --> 12:35.000]  И тогда у нас будут пары, но эти Y никак не влияют
[12:35.000 --> 12:37.000]  на структуру дерева. То есть доп информацию можно хранить,
[12:37.000 --> 12:39.000]  но она к нам
[12:39.000 --> 12:41.000]  в рамках нашей задачи
[12:41.000 --> 12:43.000]  не относится.
[12:43.000 --> 12:45.000]  Еще вопрос в чате. Есть ли смысл писать
[12:45.000 --> 12:47.000]  ячейку с связанным списком, а не массивом?
[12:47.000 --> 12:49.000]  Насколько я знаю, нет.
[12:49.000 --> 12:51.000]  Потому что вам же все равно нужно
[12:51.000 --> 12:53.000]  вставить...
[12:53.000 --> 12:55.000]  Еще раз повторюсь,
[12:55.000 --> 12:57.000]  что здесь все равно самая сложная
[12:57.000 --> 12:59.000]  операция, это подгрузка вот этих
[12:59.000 --> 13:01.000]  T-элементов в вашу оперативку.
[13:01.000 --> 13:03.000]  Если вы все равно это делаете за время
[13:03.000 --> 13:05.000]  пропорционально T, то внутри неважно, как оно устроено,
[13:05.000 --> 13:07.000]  или массивом, хоть списком, хоть
[13:07.000 --> 13:09.000]  чем угодно, вы все равно уже
[13:09.000 --> 13:11.000]  потратили T-операцию, чтобы прочитать эти
[13:11.000 --> 13:13.000]  T-ключей, ну значит там
[13:13.000 --> 13:15.000]  потратите еще T-операцию на то, чтобы сделать
[13:15.000 --> 13:17.000]  вставку X внутрь,
[13:17.000 --> 13:19.000]  неважно, то есть можно и массивом.
[13:19.000 --> 13:21.000]  Все равно асимптотика
[13:21.000 --> 13:23.000]  уже не станет лучше от того, что там
[13:23.000 --> 13:25.000]  вы будете делать какие-то оптимизации, поэтому можно
[13:25.000 --> 13:27.000]  писать так, как вам удобно, а массив скорее удобнее,
[13:27.000 --> 13:29.000]  чем список. По крайней мере, не нужно
[13:29.000 --> 13:31.000]  реализовывать там всякие указатели.
[13:31.000 --> 13:33.000]  Хорошо.
[13:33.000 --> 13:35.000]  Это очень простой случай,
[13:35.000 --> 13:37.000]  но в общем случае такого не будет.
[13:37.000 --> 13:39.000]  Вполне возможно, что мы дошли до листа, лист
[13:39.000 --> 13:41.000]  целиком заполненный, в нем 2T-1 ключ,
[13:41.000 --> 13:43.000]  и тогда в него никого больше нельзя вставить
[13:43.000 --> 13:45.000]  с учетом сохранения свойств обой дерева.
[13:45.000 --> 13:47.000]  Если мы вставим, то лист переполнится.
[13:47.000 --> 13:49.000]  Вместо этого мы будем делать следующее.
[13:51.000 --> 13:53.000]  Давайте каждый раз,
[13:55.000 --> 13:57.000]  каждый раз,
[13:59.000 --> 14:01.000]  когда алгоритм
[14:03.000 --> 14:05.000]  спускается,
[14:05.000 --> 14:07.000]  попадает
[14:09.000 --> 14:11.000]  в заполненную вершину,
[14:13.000 --> 14:15.000]  это означает, что в ней ровно
[14:15.000 --> 14:17.000]  2T-1 ключ.
[14:17.000 --> 14:19.000]  То есть максимально
[14:19.000 --> 14:21.000]  возможное количество будет в заполненную вершину.
[14:21.000 --> 14:23.000]  Так вот, давайте каждый раз,
[14:23.000 --> 14:25.000]  когда алгоритм попадает в заполненную вершину,
[14:29.000 --> 14:31.000]  как бы это сказать?
[14:31.000 --> 14:33.000]  Делать так,
[14:35.000 --> 14:37.000]  чтобы в ней,
[14:37.000 --> 14:39.000]  чтобы она стала не заполненной.
[14:39.000 --> 14:41.000]  Чтобы она стала
[14:41.000 --> 14:43.000]  не заполненной.
[14:45.000 --> 14:47.000]  То есть мы поняли, что наша проблема
[14:47.000 --> 14:49.000]  это заполненные вершины, в которых максимально возможное количество ключей,
[14:49.000 --> 14:51.000]  то есть 2T-1.
[14:51.000 --> 14:53.000]  Так вот, давайте тогда, когда мы запустили
[14:53.000 --> 14:55.000]  Find.x, спускаемся сверху вниз,
[14:55.000 --> 14:57.000]  давайте для каждой вершинки на пути,
[14:57.000 --> 14:59.000]  которая была заполнена, мы что-то с ней сделаем так,
[14:59.000 --> 15:01.000]  чтобы вершина стала не заполнена,
[15:01.000 --> 15:03.000]  и тогда, соответственно, в нее можно было бы вставлять x,
[15:03.000 --> 15:05.000]  если нужно.
[15:05.000 --> 15:07.000]  Так вот, как мы делаем эту операцию,
[15:07.000 --> 15:09.000]  как мы заставляем вершину стать не заполненной?
[15:09.000 --> 15:11.000]  Здесь идея очень простая, смотрите,
[15:11.000 --> 15:13.000]  пусть есть какая-то вершинка,
[15:13.000 --> 15:15.000]  и она заполнена, то есть в ней ровно 2T-1 ключ.
[15:17.000 --> 15:19.000]  Можно с ней сделать следующее,
[15:19.000 --> 15:21.000]  давайте эта вершина,
[15:21.000 --> 15:23.000]  в, она заполнена,
[15:23.000 --> 15:25.000]  и, скажем,
[15:25.000 --> 15:27.000]  есть какой-то родитель у нее,
[15:27.000 --> 15:29.000]  родитель P,
[15:29.000 --> 15:31.000]  ну и здесь, соответственно, есть какая-то стрелка.
[15:31.000 --> 15:33.000]  Тогда мы сделаем следующее,
[15:33.000 --> 15:35.000]  давайте мы разобьем нашу вершинку
[15:35.000 --> 15:37.000]  на T-1 ключ
[15:37.000 --> 15:39.000]  слева, назовем этот массив A,
[15:39.000 --> 15:41.000]  дальше будет центральный элемент Y,
[15:41.000 --> 15:43.000]  и, соответственно, будет массив B,
[15:43.000 --> 15:45.000]  тоже размером T-1,
[15:45.000 --> 15:47.000]  и мы сделаем следующее,
[15:47.000 --> 15:49.000]  мы этот Y поместим вверх в родителя,
[15:49.000 --> 15:51.000]  то есть перетащим в родителя,
[15:51.000 --> 15:53.000]  а для A и для B построим
[15:53.000 --> 15:55.000]  собственные независимые вершинки.
[15:55.000 --> 15:57.000]  У нас старая вершинка,
[15:57.000 --> 15:59.000]  вот эта вот вершинка V,
[15:59.000 --> 16:01.000]  распалась на две вершинки A и B,
[16:01.000 --> 16:03.000]  а разделитель между ними, Y,
[16:03.000 --> 16:05.000]  переместился в родителя.
[16:05.000 --> 16:07.000]  Более подробная картинка такая,
[16:07.000 --> 16:09.000]  был родитель P,
[16:09.000 --> 16:11.000]  и, значит,
[16:11.000 --> 16:13.000]  между какими-то двумя элементами,
[16:15.000 --> 16:17.000]  ну не знаю, скажем, C и D,
[16:17.000 --> 16:19.000]  была стрелка в вершинку V.
[16:21.000 --> 16:23.000]  Была стрелка в вершинку V.
[16:23.000 --> 16:25.000]  И мы понимаем,
[16:25.000 --> 16:27.000]  мы предполагаем, что вершина V заполнена,
[16:27.000 --> 16:29.000]  то есть не ровно дватым своим ключем.
[16:29.000 --> 16:31.000]  Тогда мы рассматриваем левую половинку,
[16:31.000 --> 16:33.000]  центральный элемент и правую половинку.
[16:33.000 --> 16:35.000]  То есть это то, что было,
[16:35.000 --> 16:37.000]  то, что станет, сейчас я тоже нарисую,
[16:37.000 --> 16:39.000]  станет вот такое.
[16:39.000 --> 16:41.000]  Мы в P засовываем,
[16:41.000 --> 16:43.000]  то есть вот между как раз этими C и D
[16:43.000 --> 16:45.000]  мы засунем этот Y,
[16:45.000 --> 16:47.000]  то есть мы его поднимаем вверх,
[16:47.000 --> 16:49.000]  как раз на то место,
[16:49.000 --> 16:51.000]  из которого как будто бы шла стрелка V.
[16:51.000 --> 16:53.000]  Дальше разделитель между C и Y
[16:53.000 --> 16:55.000]  показывает на A,
[16:55.000 --> 16:57.000]  разделитель между Y и D
[16:57.000 --> 16:59.000]  будет показывать на B.
[16:59.000 --> 17:01.000]  Вот такой, ну по сути, мы как бы
[17:01.000 --> 17:03.000]  вершинку V расплитили на две,
[17:03.000 --> 17:05.000]  и разделитель между ними подняли в родителя.
[17:07.000 --> 17:09.000]  А в P всегда можем что-то добавить?
[17:09.000 --> 17:11.000]  Да, и как раз за счет того,
[17:11.000 --> 17:13.000]  что мы так делаем для каждой вершинки
[17:13.000 --> 17:15.000]  при проходе сверху вниз,
[17:15.000 --> 17:17.000]  у нас сейчас будет верно,
[17:17.000 --> 17:19.000]  что в P меньше, чем дватым своим ключем.
[17:19.000 --> 17:21.000]  Поскольку мы идем сверху вниз
[17:21.000 --> 17:23.000]  и в каждой текущей вершине,
[17:23.000 --> 17:25.000]  если мы только что пришли в вершину,
[17:25.000 --> 17:27.000]  мы делаем так, что в ней после нашей операции
[17:27.000 --> 17:29.000]  будет меньше дватым своим ключем.
[17:29.000 --> 17:31.000]  То есть это в P выполнялось.
[17:31.000 --> 17:33.000]  Дальше мы спустились вниз,
[17:33.000 --> 17:35.000]  опять встретили вершинку с дватым своим ключом,
[17:35.000 --> 17:37.000]  и теперь поскольку в родительской вершине
[17:37.000 --> 17:39.000]  меньше, чем дватым своим ключем,
[17:39.000 --> 17:41.000]  мы имеем право так сделать,
[17:41.000 --> 17:43.000]  мы имеем право так расплитить
[17:43.000 --> 17:45.000]  и поднять одну вершинку вверх.
[17:45.000 --> 17:47.000]  Теперь здесь у меня опять обе новые вершины.
[17:47.000 --> 17:52.460]  заполненные. Соответственно, там дальше, если как-то спускаю, то опять вот эта предыдущая вершина,
[17:52.460 --> 17:57.920]  то есть если ниже имеется вершина с 2 t-1 ключом, то ее родители имеют всего t-1 ключ,
[17:57.920 --> 18:04.600]  поэтому точно можно сделать вынос элементов родителей. Хорошо, просто про корень. Давайте
[18:04.600 --> 18:10.600]  чуть-чуть позже я это скажу. Так вот, значит, так сделали. Еще нужно немножко с указателями,
[18:10.600 --> 18:15.120]  вот этими старыми указателями, повозиться. Значит, смотрите, были какие-то указатели вот такие,
[18:15.920 --> 18:20.060]  давайте 네 рисую. Были указатели здесь, дальше был указатель слева от y, справа от y.
[18:20.060 --> 18:30.100]  И указатели вот чисто c 1-1. Тогда эти указатели, собственно, те указатели, которые были слева,
[18:30.100 --> 18:35.520]  я оставляю вообще так же. Дальше вот это указатель, который был слева от y, я говорю,
[18:35.520 --> 18:39.760]  что он находится справа от a. Вот этот указатель, который был справа от y, он теперь справа от b,
[18:39.760 --> 18:46.440]  но все указатели с b я тоже перекопирую. короче у меня собственно вот а и b это вот эта вот
[18:46.440 --> 18:50.720]  штука, вместе со всеми указателями вниз, и b это вот эта штука вместе со всеми указателями вниз,
[18:50.720 --> 18:57.240]  собственно я их вот сюда перенес. вот нужно убедиться что выполняются все свойства
[18:57.240 --> 19:03.640]  b дерева, да ну во-первых как мы уже отметили, раз родительская вершина имела меньше 2х-1 ключ,
[19:03.640 --> 19:08.680]  теперь они будут меньше заправно чем 2х-1 ключ, все хорошо, выполняется линия вариант. дальше
[19:08.840 --> 19:15.640]  вот эти две вершинки новые, в них теперь по ровно t-1 ключу, поэтому инвариант тоже сохраняется,
[19:15.640 --> 19:22.240]  для внутренних вершин у нас должно быть хотя бы t-1 ключ, это верно. ну и дальше там нужно проверить,
[19:22.240 --> 19:27.760]  что все неравенства также выполняются, да то есть скажем как у нас было раньше, раз вот эта вот
[19:27.760 --> 19:33.400]  вершинка лежала между c и d, то получается что все числа здесь, вот эти все числа, они с одной
[19:33.720 --> 19:39.400]  стороны больше c, а с другой стороны меньше c и d. теперь я это расплитил и у меня теперь должны
[19:39.400 --> 19:45.400]  лежать элементы меньше чем c, больше чем c но меньше чем y, а здесь больше чем y но меньше чем d,
[19:45.400 --> 19:49.880]  ну это собственно так и будет выполняться, потому что поскольку а лежало левее y,
[19:49.880 --> 19:54.940]  значит все элементы здесь строго меньше чем y, да поэтому это верно. здесь b лежало правее
[19:54.940 --> 20:02.220]  поэтому все все элементы здесь большими, все они раньше выполнены, в смысле, что это
[20:02.220 --> 20:06.820]  опять корректное по дереву, в плане того, что все ключи там правильно, порядочно, дальше инвариант
[20:06.820 --> 20:14.740]  сохранены, глубина листьев не изменилась, поэтому такая операция нам доступна, так, то есть при
[20:14.740 --> 20:19.300]  операции инферс, производится починка дерева, устраняющие полностью выполненные, нет, в смысле те,
[20:19.300 --> 20:24.980]  которые мы проходим, то есть смотрите, вот у нас есть какой-то путь, да, от корня до листа, в котором
[20:24.980 --> 20:29.940]  как бы нет икса, и куда нужно положить, мы идем так сверху вниз, встретили заполненную, так ее
[20:29.940 --> 20:33.380]  посплитили, что она теперь не заполнена, дальше спускаемся вниз, встретили заполненную, опять
[20:33.380 --> 20:37.380]  посплитили, так что она не заполнена, и так далее, спустились до листа, то же самое, если она заполнена,
[20:37.380 --> 20:41.540]  если он заполнен, мы его распличиваем, и он становится не заполнен, и теперь в него можно вставить икс,
[20:41.540 --> 20:47.460]  мы идем сверху вниз, каждую заполненную делаем не заполненной, и так спускаемся вплоть до листа,
[20:47.460 --> 20:53.460]  и тогда в листике то же самое можно сделать, так, да, значит здесь один есть крайний случай с корнем,
[20:53.460 --> 21:05.380]  вот был вопрос в чате, на самом деле, если в корень, то здесь отдельный случай, потому что если в корень,
[21:05.380 --> 21:10.860]  когда у него нет родителя, их дыр и как бы некуда поднимать, но в таком случае, если в корень, давайте
[21:10.860 --> 21:17.620]  я все-таки отдельный слайд заведу, потому что тоже важно это проговорить, то есть если в корень, то картинка
[21:17.620 --> 21:24.340]  такая, есть заполненный корень с дватым с одним ключом, и я хочу сейчас его расплитить, вот, но,
[21:24.340 --> 21:30.500]  собственно, я это делаю точно так же, я выделяю центральный элемент y, а также левую правую часть
[21:30.500 --> 21:36.180]  а и б, только теперь я y не могу поднять родителя, потому что родителя в принципе нету, вместо этого я
[21:36.640 --> 21:41.700]  просто завожу новую вершинку, которая являет корнем, и в этом корне будет один только y, соответственно,
[21:41.700 --> 21:47.620]  левое указание будет показывать на а, правый на b, то есть в случае, когда нужно посплитить корень,
[21:47.620 --> 21:53.120]  у меня появляется новый корень, то есть v перестает быть корнем, новый вот этот центральный y,
[21:53.120 --> 21:57.340]  я перемещаю в новый корень, заводится новый корень, эта вот вершинка будет новый корень,
[21:57.340 --> 22:03.980]  новый корень дерева, вот, ну и тем самым мы опять посплитили, и все варианты вновь сохранены,
[22:03.980 --> 22:10.180]  потому что в корне у нас должно быть от 1 до 2t минус 1 ключа, это выполняется, у нас есть один
[22:10.180 --> 22:14.980]  ключ в корне, все хорошо, но во всех внутренних все правильно, и собственно глубина не изменилась,
[22:14.980 --> 22:20.020]  потому что, ну по сути, я просто как бы глубину увеличу на 1, было какое-то такое дерево,
[22:20.020 --> 22:25.940]  я взял и все, ну по сути, как бы у всех решин поднял глубину на единицу, потому что я подвесил
[22:25.940 --> 22:30.620]  какой-то кольц сверху дерева, значит глубина у всех листьев выросла на 1, значит глубина всех
[22:30.620 --> 22:35.380]  листьев осталась одинаковой, если она раньше была у всех одинаковой, то теперь тоже одинаковая,
[22:35.380 --> 22:41.900]  вот такой отдельный случай с корнем, хорошо, значит мы так делаем, спускаемся, разделяем
[22:41.900 --> 22:47.140]  заполненные вершинки, ну и в конце, когда мы дошли до листа, мы опять, если он был заполненный,
[22:47.140 --> 22:52.180]  сделали его не заполненным, подняв нужный элемент в родительскую вершину, ну теперь эта вершинка
[22:52.180 --> 22:59.780]  опять не заполненная, и значит в нее можно вставить x в нужное место, не заполнена, значит в нее можно
[22:59.780 --> 23:07.300]  вставить x, а собственно этого мы и хотели, мы хотели вставить x в лист, и теперь, поскольку он не
[23:07.300 --> 23:12.620]  заполненный, в нем меньше 1 ключ, то работает наше первое наблюдение, что просто можно его вставить
[23:12.620 --> 23:22.380]  в нужное место, будет корректная вершина, вот такая реализация инсерта, спуск и поддержка то,
[23:22.380 --> 23:29.860]  что текущая вершина не заполнена. Вот здесь важное замечание, ну такое интересное замечание,
[23:29.860 --> 23:35.820]  что в этой процедуре нам нужен всего один рекурсивный спуск, всего один рекурсивный спуск,
[23:35.820 --> 23:46.180]  без подъема, без подъема, то есть если вот, например, вспомнить какой-нибудь AVL дерево,
[23:46.180 --> 23:52.180]  как там работал инсерт, мы сначала спускались от корня в поисках того места, куда нужно
[23:52.180 --> 23:58.860]  подвесить новый ключ x, подвешивали его, а потом шли обратно снизу вверх, так перед, ну там как бы
[23:58.860 --> 24:03.980]  делать какие-то повороты, да, переподвешивать вот эти все по деревья, чтобы уравнять балансы,
[24:03.980 --> 24:08.460]  чтобы ни у какой вершины не было дельта плюс или минус. То есть там мы сначала спустились сверху
[24:08.460 --> 24:14.260]  вниз, потом сниз шли снизу вверх, исправляя все дисбалансы. То же самое было в сплее деревя,
[24:14.260 --> 24:19.100]  мы сначала нашли место, куда нужно подвесить x, подвесили, а потом с помощью наших зигзигов и
[24:19.100 --> 24:25.140]  зигзагов, и в конце, возможно, одного зиг так попровращали дерево, чтобы вставленная вишенка
[24:25.140 --> 24:29.660]  стала корнем. То есть в предыдущих реализациях у нас обязательно нужно не только сверху вниз
[24:29.660 --> 24:34.220]  пройтись, но и снизу вверх, чтобы все исправиться. Здесь же нам достаточно всего одного спуска сверху
[24:34.220 --> 24:39.300]  вниз, потому что, ну вот как при поддержке этого инварианта, да, что текущая вишена не заполненная,
[24:39.300 --> 24:43.460]  мне просто нужно будет вставить x в лист, и все хорошо, у меня будет сразу корректное дерево,
[24:43.460 --> 24:48.580]  не нужно будет подниматься вверх, чтобы что-то исправиться. Вот это такое небольшое преимущество,
[24:48.900 --> 24:55.500]  что-либо дерево по сравнению с тем, что у нас было до этого. Да, без подъема. Хорошо.
[24:55.500 --> 25:04.860]  Хорошо, тогда едем дальше. Нам нужна третья наша операция, это erase. Тут будет чуть больше случаев,
[25:04.860 --> 25:11.500]  но идейно все плюс-минус так же. То есть наша задача это сделать так, чтобы из вершины,
[25:11.500 --> 25:17.820]  откуда нужно удалить x, было можно это сделать. То есть чтобы в ней было не t-1 ключ,
[25:17.820 --> 25:22.740]  а хотя бы t, если в вершине хотя бы t ключей, то можно сделать удаление, потому что у нас
[25:22.740 --> 25:26.940]  требование, что хотя бы t-1 в каждой вершине, значит, чтобы удалить нужно, чтобы было хотя бы t.
[25:26.940 --> 25:35.140]  Вот, хорошо. Ну и соответственно, то, что мы поддерживаем, это вот как раз то, что я сказал,
[25:35.300 --> 25:55.420]  значит, давайте спускаться, давайте спускаться от корня в поисках x и делать так, чтобы в текущей вершине
[25:55.420 --> 26:12.900]  было хотя бы t ключей, было хотя бы t ключей, ну если это не корень, если это не корень. Ну потому
[26:12.900 --> 26:18.020]  что в корне, в принципе, у меня нет ограничения, то есть там сказано, что от 1 до 2-1 ключа, то есть
[26:18.020 --> 26:22.140]  по сути у меня нет нижнего значения на количество ключей в корне, поэтому вот это больше 0t должно
[26:22.140 --> 26:27.660]  быть только для корня выполняться, только для не корня, для всех остальных вершин должно выполняться,
[26:27.660 --> 26:36.340]  для корня это не должно быть, ну в смысле, не обязательно. Вот, ну тогда что, смотрите,
[26:36.340 --> 26:43.580]  как можно добиться того, чтобы в вершине, в которой t-1 ключ, вдруг стало хотя бы t ключей,
[26:43.580 --> 26:47.700]  то есть понятно, если в корне мало ключей, то мы с ними ничего не делаем, потому что на корне у нас
[26:47.700 --> 26:52.740]  нет требования снизу, ну то есть там есть требования, что хотя бы, хотя бы 1, хотя бы 1 ключ,
[26:52.740 --> 26:57.780]  но это и так всегда будет верно, потому что мы не будем хранить вершины без ключей вообще. Ну так вот,
[26:57.780 --> 27:06.220]  пусть есть какая-то вершина не корневая v, и в ней t-1 ключ, t-1 ключ, значит, раз она не корневая,
[27:06.220 --> 27:11.540]  то у нее есть какой-то родитель, есть какой-то родитель, да, в этой вершинке, и, соответственно,
[27:12.040 --> 27:15.980]  у этой вершинки есть, в общем случае, два брата, есть брат правый, есть брат левый.
[27:15.980 --> 27:23.620]  Что такое правый-левый брат? Ну, понятно, это просто, как бы, то куда указывает следующий
[27:23.620 --> 27:27.940]  или предыдущий указатель, то есть, а смотрите, здесь был какой-то указатель из родителя,
[27:27.940 --> 27:31.560]  указывающий на вершинку v. Если рассмотреть следующий указатель, то он показывает,
[27:31.560 --> 27:36.420]  как бы, направо брата. Если рассмотреть предыдущий, то он указывает на левого брата. То есть просто,
[27:36.420 --> 27:42.420]  в буквальном смысле правые и левые братья, то есть самые близкие вершинки на том же уровне.
[27:42.420 --> 27:50.420]  То есть это будет правый брат, правый брат и левый брат.
[27:50.420 --> 27:58.420]  Здесь идея такая, если, допустим, в правом брате хотя бы t ключей, давайте предположим, что здесь хотя бы t ключей.
[27:58.420 --> 28:05.420]  Тогда можно будет проделать следующее. Вот здесь взять самый маленький ключ z, то есть самое левое число в правом брате,
[28:05.420 --> 28:14.420]  поднять его на место вот этого y, который являлся разделителем между вершинкой v и правым братом вершинки v,
[28:14.420 --> 28:19.420]  а сам y спустить в эту вершинку v.
[28:19.420 --> 28:29.420]  То есть мы z подняли в родительскую вершинку, то есть мы z поставили на место y, а y приписали в конец v.
[28:29.420 --> 28:37.420]  То есть в v у меня увеличилось сколько ключей на единицу, в z, оттуда можно было исключить z, в правом брате можно было исключить z,
[28:37.420 --> 28:43.420]  потому что там хотя бы t ключей, значит все хорошо. Давайте подробнее картинку нарисуем.
[28:43.420 --> 28:54.420]  Вот был родитель, вот был какой-то ключ, разделяющий нашу вершинку v и ее правого брата, то есть вот была какая-то вершинка v,
[28:54.420 --> 29:03.420]  вот был правый брат v, v это правый брат, правый брат v.
[29:03.420 --> 29:11.420]  И это значит то, что было. Давайте еще стрелки нарисую, какие здесь были вниз, значит вот эти стрелки я нарисую красненьким.
[29:11.420 --> 29:17.420]  Вот здесь была одна стрелка синяя, самая левая, и все остальные я нарисую красненьким, потому что я их не буду менять.
[29:17.420 --> 29:30.420]  Это было. А вот что станет. Вот что станет. В родителе вместо y будет z, вот этот вот z, который самый левый в правом сыне.
[29:30.420 --> 29:41.420]  Дальше ссылка здесь останется на v, но к v еще припишется новый элемент y. То есть я по сути просто y спускаю вот сюда, а z поднимаю вместо y.
[29:41.420 --> 29:47.420]  Ну а в правом сыне z удалится, то есть правый сын будет без z.
[29:47.420 --> 29:52.420]  Значит, что со стрелочками. Эти две стрелки сохраняются, здесь все стрелки красные остаются.
[29:52.420 --> 30:01.420]  И единственное, что здесь такое тонкий момент, это что вот эта синяя стрелка, которая раньше исходила из, ну как бы самой левой стрелки в правом сыне,
[30:01.420 --> 30:06.420]  она теперь является самой правой в левом сыне, то есть в вершинке v.
[30:06.420 --> 30:12.420]  То есть вот эта синяя стрелка, она переподвешивается и теперь находится вот здесь.
[30:12.420 --> 30:18.420]  Ну а все остальные стрелки, вот эти красные, они остаются в правом дате.
[30:18.420 --> 30:26.420]  Вот так работает наша операция. То есть по сути мы перебросили элемент z в родителя, а y опустили в вершинку v.
[30:26.420 --> 30:30.420]  Ну давайте кратко посмотрим, почему здесь все хорошо.
[30:30.420 --> 30:34.420]  То есть ну во-первых, так можно сделать, потому что теперь в правом рате t-minus, ну хотя бы t-minus 1 ключ,
[30:34.420 --> 30:43.420]  поэтому так можно сделать. Дальше, что с неравенствами?
[30:43.420 --> 30:51.420]  Ну значит здесь, не так, вот здесь, то есть правее z, все числа были больше, чем z.
[30:51.420 --> 31:02.420]  Ну значит, если я как раз, по сути, я вот это вот поддерево, вот это синее поддерево,
[31:02.420 --> 31:05.420]  переподвесил влево, а здесь как раз были числа меньше, чем z, но больше чем люгий, потому что они слева от z, но справа от у.
[31:05.420 --> 31:09.420]  И как раз они вот здесь, и будут находиться справа от y, а слева от z.
[31:09.420 --> 31:11.420]  И отсюда они как бы отклеятся, переклеятся сюда.
[31:11.420 --> 31:15.420]  Ну а здесь будут все элементы больше, чем z. То есть с неравенствами все хорошо,
[31:15.420 --> 31:25.420]  спорное дерево туда, куда нужно и, собственно, в общем, просто, если не верите, то просто аккуратно посмотрите за всеми неравенствами, которые должны выполняться, убедитесь, что они выполняются.
[31:25.420 --> 31:34.420]  Потому что в каждой решении ключи посорчены. Дальше, что слева вот каждого элемента стоят только меньше, числа справа только больше.
[31:34.420 --> 31:38.420]  Вот так. Как левый малый левый пород.
[31:38.420 --> 31:44.420]  Кстати, да, рог, кстати, да, действительно, да, то есть мы, ну,
[31:44.420 --> 31:50.420]  ну да, да, и там тоже такое же переподвешение, да, кстати, действительно, да.
[31:50.420 --> 32:00.420]  Так, еще вопрос в чате. Почему еще раз в левом брате было до изъятия Z хотя бы T? Это предположение, предположение, что если у вершинки В
[32:00.420 --> 32:07.420]  был такой крутой правый брат, что в нем хотя бы T ключей, то мы один можем так перебросить. Если, то можем.
[32:07.420 --> 32:12.420]  Пока что я ничего другого не утверждал. То же самое происходит с левым братом.
[32:12.420 --> 32:17.420]  То есть мы поняли, что если у вершинки В есть правый брат хотя бы с T ключами, то мы можем так сделать.
[32:17.420 --> 32:22.420]  То же самое, если, наоборот, левый брат содержит хотя бы T ключей.
[32:23.420 --> 32:37.420]  Давайте пропишем. Тоже происходит, ну, в смысле тоже, в смысле аналогично, тоже происходит, если у В в левом брате хотя бы T ключи.
[32:37.420 --> 32:42.420]  То есть там работает то же самое. Нам нужно из левого брата извлечь самый большой элемент,
[32:42.420 --> 32:47.420]  поместить его на место Y, на место разделяющего элемента в родителя и этот разделяющий элемент спустить в В.
[32:47.420 --> 32:53.420]  Тогда В у меня станет на один ключ больше, а в левом брате на один ключ меньше.
[32:53.420 --> 32:59.420]  То есть это такой простой случай, когда есть брат, из которого можно перетащить, и тогда наш вариант сохранится.
[32:59.420 --> 33:05.420]  Мы хотели, чтобы в текущей вершине В стало хотя бы так ключей, мы что-то сделали так, чтобы в ней стало хотя бы так ключей.
[33:05.420 --> 33:09.420]  Это такой простой случай относительно. Теперь второй случай плохой.
[33:09.420 --> 33:17.420]  Пусть теперь это неверно и в обоих наших братьях, и в левом, и в правом минимально возможное количество T-in ключ.
[33:17.420 --> 33:26.420]  Пусть теперь в обоих братьях, братьях по T-1 ключу. Ну, либо вообще брата нету.
[33:26.420 --> 33:32.420]  Скажем, если в это самое левое вершине у него вообще нет левого брата, поэтому там ну как бы ниоткуда ничего перебрасывать.
[33:32.420 --> 33:38.420]  То есть в братья либо брата нету, либо там минимально возможное T-in ключ.
[33:39.420 --> 33:46.420]  Так, вот мы в таком случае сделаем просто объединение наших двух братьев.
[33:46.420 --> 33:51.420]  В таком случае, ну легко показать, что хотя бы один такой брат есть.
[33:51.420 --> 33:59.420]  В таком случае, давайте сейчас, нехорошо я написал, давайте немножко в прошлое предложение исправлю.
[34:00.420 --> 34:19.420]  Точнее, каждый брат либо не существует, либо не существует, либо в нем ровно T-in ключ.
[34:20.420 --> 34:30.420]  Хорошо, значит тогда легко показать, в таком случае, легко показать, что хотя бы один брат есть.
[34:30.420 --> 34:34.420]  Есть хотя бы один брат.
[34:34.420 --> 34:39.420]  Ну потому что мы договорились, что в корне есть хотя бы один ключ.
[34:39.420 --> 34:46.420]  Значит из корни исходят хотя бы две стрелки, значит у каждой вершины есть либо левый, либо правый брат.
[34:46.420 --> 34:51.420]  То есть не бывает такого, что у вершины нет ни левого, ни правого брата, потому что иначе она была бы T-in сыном родителя,
[34:51.420 --> 34:54.420]  а такого не бывает, потому что в каждой вершине хотя бы один ключ есть.
[34:54.420 --> 35:02.420]  И давайте склеим с любым из них, то есть если есть правый брат, то мы склеим с правым, если есть левый, то склеим с левым, не важно с каким.
[35:02.420 --> 35:05.420]  Какая будет картинка?
[35:05.420 --> 35:12.420]  Вот есть текущая V, вот есть у нее правый брат R, и давайте я здесь тоже нарисую.
[35:12.420 --> 35:17.420]  Здесь есть разделитель Y, то что было слева будет C, то что было справа будет D.
[35:17.420 --> 35:20.420]  Значит это родитель, это родительская вершина.
[35:20.420 --> 35:25.420]  Дальше есть вокруг этого Y два указателя на V и на, скажем, правого брата.
[35:25.420 --> 35:32.420]  И мы предполагаем, что в обеих вершинках V и R ровно по T-ин сыному ключу.
[35:32.420 --> 35:37.420]  Ну если V больше, чем T-ин сыни, то нам делать ничего не нужно, в ней уже нужное количество ключей есть.
[35:37.420 --> 35:43.420]  Итак, тогда это было. Вот что станет.
[35:43.420 --> 35:48.420]  Мы возьмем, склеим V и R, а также спустим Y вниз.
[35:48.420 --> 35:56.420]  То есть вместо V и R у нас будет одна такая объемная вершинка, а также в нее спустим Y из родителя.
[35:56.420 --> 36:09.420]  Теперь в родителе будет C, D без этого Y, и будет одна жирная вершина, в которой написано сначала V, потом Y, потом R.
[36:09.420 --> 36:15.420]  То есть сначала вершинка, потом вот этот элемент, который мы спускаем из родительской вершины, потом R.
[36:15.420 --> 36:22.420]  Что со стрелками? Ну здесь опять есть разделитель между C и D, он показывает просто на эту большую вершинку, V, Y, R.
[36:22.420 --> 36:26.420]  Дальше здесь были какие-то указатели.
[36:26.420 --> 36:30.420]  Здесь просто надо позабоиться о том, что происходит с крайними указателями.
[36:30.420 --> 36:32.420]  Эти все остаются такими, как были.
[36:32.420 --> 36:36.420]  Указатель, который был самый правый, из V, он теперь указатель между V и R.
[36:36.420 --> 36:44.420]  Дальше указатель, самый левый, в R, он теперь между Y и R, а все остальные указатели остаются без изменений.
[36:44.420 --> 36:46.420]  Опять можно убедиться, что все не раньше выполняются.
[36:46.420 --> 36:51.420]  Ну, например, потому что почему, например, вот в этой вершине все ключи упорядочены?
[36:51.420 --> 36:57.420]  Потому что мы знаем, что вот эта стрелочка находится левее Y, значит все элементы здесь меньше Y.
[36:57.420 --> 37:02.420]  Значит здесь какой-то старый список, потом Y, то есть все элементы из V меньше Y.
[37:02.420 --> 37:08.420]  То же самое, наоборот, R находится правее Y, значит все элементы здесь больше Y, все элементы в R больше Y.
[37:08.420 --> 37:11.420]  Значит так же все не раньше очевидно выполняются.
[37:11.420 --> 37:15.420]  Ну и что мы получше сделали? Мы по сути взяли, просто склеили две вершинки.
[37:16.420 --> 37:22.420]  Здесь теперь ровно 2t-1 ключ, да, магия чисел, было t-1, 3-1, мы их склеили и еще один добавили,
[37:22.420 --> 37:26.420]  стало ровно 2t-1, максимально возможное количество, но все равно допустимо.
[37:26.420 --> 37:30.420]  А в родителе стало на 1 ключ меньше, минус 1 ключ.
[37:30.420 --> 37:37.420]  Ну и в родителе, поскольку мы так спускаемся сверху вниз и поддерживаем, что в каждой типу вершин хотя бы t ключей, мы можем так сделать.
[37:37.420 --> 37:44.420]  Опять та же самая идея, если в родителе хотя бы t ключей, значит мы можем оттуда удалить один новый ключ.
[37:44.420 --> 37:50.420]  Точно так же, как было в инсерте. В инсерте нам нужно было вставлять родителя, при условии, что он не заполненный, и это можно было сделать.
[37:50.420 --> 37:55.420]  Здесь, наоборот, нужно удалять из родителя, но мы поддерживаем, что в родителе хотя бы t-1 ключи, значит так можно сделать.
[37:56.420 --> 37:57.420]  Вот и все.
[37:57.420 --> 38:02.420]  Так, ну и также здесь есть отдельный случай, когда родители это корень.
[38:03.420 --> 38:07.420]  Так, давайте расскажу потом на вопрос, чей я отвечу.
[38:07.420 --> 38:14.420]  Если родители это корень, то здесь нужно немножко аккуратнее рассудить.
[38:14.420 --> 38:20.420]  Значит, вот у меня было v, вот у него был, скажем, правый брат, либо правый, либо левый, оба случая нужно разобрать.
[38:20.420 --> 38:25.420]  И вот был, скажем, родитель, родители, являющиеся корнем.
[38:26.420 --> 38:33.420]  Здесь, по сути, мы что сделали? Мы y утащили вниз, в нашей дочерней вершины v и r.
[38:33.420 --> 38:41.420]  И в случае, если y был единственным ключом в корне, тогда на место старого корня нужно поставить вот эту вершину.
[38:41.420 --> 38:48.420]  То есть, если y был единственным ключом в корне,
[38:48.420 --> 38:54.420]  то, получается, я из корня удалил один единственный ключ, спустил его вниз.
[38:54.420 --> 38:59.420]  Ну, значит, нужно просто удалить ту старую вершину и новым корнем назначить v, y.
[39:00.420 --> 39:02.420]  То старый корень нужно удалить.
[39:05.420 --> 39:07.420]  Старый корень нужно удалить.
[39:08.420 --> 39:17.420]  А новым корнем назначить вот эту новую большую вершинку v, y.
[39:17.420 --> 39:24.420]  Но опять все работает. Да, то есть, поскольку мы удалили корень и новым корнем назначили единственный его сына,
[39:24.420 --> 39:27.420]  то получается, что глубина всех листьев уменьшилась на единицу.
[39:27.420 --> 39:30.420]  Значит, если она у всех была одинаковая, то теперь тоже одинаковая.
[39:30.420 --> 39:32.420]  Так, вопрос в чате.
[39:33.420 --> 39:35.420]  Так, вопрос в чате.
[39:35.420 --> 39:38.920]  к этому решение не будет очень плохо, если постоянно удалять элементы, вызывая разделение ячеек
[39:38.920 --> 39:44.320]  и потом вновь добавляя в новую вершину, вызывая его разделение
[39:44.400 --> 39:47.780]  есть постоянно удалять элементы, вызывая разделение ячеек
[39:47.780 --> 39:54.240]  а потом вновь добавляя в новую вершину элементы вызывая его разделение
[39:59.580 --> 40:01.480]  удалять элементы, это что значит?
[40:01.480 --> 40:06.480]  удалять узлы или что? Ну, не будет плохо, короче.
[40:06.480 --> 40:10.480]  Вам все равно нужно, как бы у вас было три вершины,
[40:10.480 --> 40:13.480]  вам нужно сделать из них две вершины, то есть какие-то
[40:13.480 --> 40:18.480]  две склеить и как-то что-то перетащить.
[40:18.480 --> 40:21.480]  Но не будет плохо, потому что вы все равно работаете
[40:21.480 --> 40:25.480]  с тремя объектами, каждый из них имеет размер O от T,
[40:25.480 --> 40:28.480]  там можно просто их явно удалить, перестроить,
[40:28.480 --> 40:31.480]  то есть как у вас должны выглядеть эти объекты вновь,
[40:31.480 --> 40:35.480]  то есть после изменений и их положить на место старых.
[40:35.480 --> 40:38.480]  В плане времени работы это все равно все,
[40:38.480 --> 40:41.480]  то есть эта операция она линейна от размера узла,
[40:41.480 --> 40:43.480]  от T все это занимает.
[40:43.480 --> 40:45.480]  Поэтому ничего плохого здесь не вижу.
[40:45.480 --> 40:48.480]  И, собственно, здесь не будет ничего плохого.
[40:48.480 --> 40:51.480]  Итак, хорошо. Так еще вопрос в чате.
[40:51.480 --> 40:54.480]  Итак, хорошо. Чего мы добились? Мы добились того,
[40:54.480 --> 40:57.480]  что если мы спускаемся, если мы дошли до какой-то вершинки
[40:57.480 --> 40:59.480]  и она не корень, то в ней хотя бы до ключей.
[40:59.480 --> 41:01.480]  Это мы научились поддерживать.
[41:01.480 --> 41:03.480]  Теперь это что? Мне нужно научиться удалять.
[41:09.480 --> 41:11.480]  Извините, пожалуйста.
[41:11.480 --> 41:13.480]  По инсерту.
[41:13.480 --> 41:15.480]  Ну там...
[41:15.480 --> 41:17.480]  Давайте.
[41:17.480 --> 41:21.480]  Не по инсерту, а по...
[41:21.480 --> 41:26.480]  Короче, что мы делаем, когда...
[41:26.480 --> 41:30.480]  Короче, когда есть какая-то вершина,
[41:30.480 --> 41:35.480]  у нее меньше либо равно, чем T-1 ключ,
[41:35.480 --> 41:40.480]  и правого и левого брата не существует.
[41:40.480 --> 41:42.480]  Такого не бывает. Такого не бывает.
[41:42.480 --> 41:44.480]  Обязательно хотя бы один брат есть.
[41:44.480 --> 41:45.480]  Окей, спасибо.
[41:45.480 --> 41:47.480]  Так, вопрос в чате. Логерехмических сложно сохранить,
[41:47.480 --> 41:49.480]  если будем рандомно удалять.
[41:49.480 --> 41:52.480]  Ну, посмотрите, мы доказали раньше, на прошлый лекции с вами доказали,
[41:52.480 --> 41:54.480]  что если у нас есть корректное B-дерево,
[41:54.480 --> 41:56.480]  то его глубина логерехмическая.
[41:56.480 --> 41:58.480]  А мы работаем...
[41:58.480 --> 42:00.480]  Ну, как бы в наше время работаем в пропорциональной глубине.
[42:00.480 --> 42:03.480]  Поэтому, конечно, у нас будет логерехмическая симпатика всегда.
[42:03.480 --> 42:05.480]  Итак, значит, что мы... Чего мы добились?
[42:05.480 --> 42:07.480]  Мы добились, что когда мы в поисках X,
[42:07.480 --> 42:09.480]  который нужно удалить, шли по дереву,
[42:09.480 --> 42:11.480]  вот как-то мы шли-шли-шли,
[42:11.480 --> 42:13.480]  в итоге дошли до вершинки, которая либо корень...
[42:13.480 --> 42:16.480]  Ну да, то есть мы нашли где-то X в какой-то вершине.
[42:16.480 --> 42:19.480]  Тогда она либо корень, либо в ней хотя бы T ключей.
[42:19.480 --> 42:21.480]  Либо корень.
[42:23.480 --> 42:26.480]  Либо, оговорился, либо хотя бы T ключей.
[42:26.480 --> 42:28.480]  Да, либо корень, либо хотя бы T ключей.
[42:29.480 --> 42:31.480]  Так, хорошо.
[42:31.480 --> 42:33.480]  Тогда дальше можно сделать следующее.
[42:33.480 --> 42:35.480]  То есть, смотрите, если бы это был лист,
[42:35.480 --> 42:37.480]  то опять было бы все идеально.
[42:37.480 --> 42:39.480]  Мы просто удаляем X из этого списка, и все хорошо.
[42:39.480 --> 42:41.480]  Это новый лист, в нем хотя бы T-1 ключ,
[42:41.480 --> 42:43.480]  если это не корень.
[42:43.480 --> 42:46.480]  И все хорошо. Для листа у нас как раз такой.
[42:46.480 --> 42:48.480]  Но, к сожалению, это может быть не лист.
[42:48.480 --> 42:51.480]  И тогда мне как бы нужно опять все это переделать.
[42:51.480 --> 42:53.480]  Ну давайте сделаем следующее.
[42:53.480 --> 42:55.480]  Давайте посмотрим на стрелке вокруг X.
[42:55.480 --> 42:57.480]  То есть есть стрелка на левого сына,
[42:57.480 --> 42:59.480]  то есть на числа меньше X.
[42:59.480 --> 43:01.480]  Есть ссылка на правого сына, на числа больше X.
[43:07.480 --> 43:09.480]  Давайте скажем следующее.
[43:09.480 --> 43:12.480]  Давайте предположим, что в левом сыне хотя бы T ключей.
[43:12.480 --> 43:14.480]  Пусть здесь хотя бы T ключей.
[43:14.480 --> 43:18.480]  Тогда можно рекурсивно запуститься вот от этого поддерева,
[43:18.480 --> 43:20.480]  найти в нем самый максимальный элемент,
[43:20.480 --> 43:22.480]  просто максимальный элемент в поддереве.
[43:22.480 --> 43:24.480]  Это мы знаем как делать.
[43:24.480 --> 43:26.480]  Нужно просто каждый раз идти по самой правой стрелке.
[43:26.480 --> 43:28.480]  И, собственно, вот самый последний элемент,
[43:28.480 --> 43:30.480]  самым правым узлом, и будет максимальный.
[43:30.480 --> 43:32.480]  И дальше что мы сделаем?
[43:32.480 --> 43:34.480]  Мы как бы по сути этот максимум поставим вот сюда,
[43:34.480 --> 43:36.480]  на месте X,
[43:36.480 --> 43:38.480]  а максимальный элемент отсюда удалим.
[43:38.480 --> 43:40.480]  То есть по сути как можно это представлять?
[43:40.480 --> 43:42.480]  Если в левом сыне хотя бы T ключей,
[43:42.480 --> 43:44.480]  то тогда давайте в нем мы найдем максимальный элемент,
[43:44.480 --> 43:46.480]  вот это число.
[43:46.480 --> 43:48.480]  Поставим его на место X,
[43:48.480 --> 43:50.480]  тем самым X удалив.
[43:50.480 --> 43:52.480]  А дальше запустимся рекурсивно вот в этого поддерева
[43:52.480 --> 43:54.480]  с запросом удаления максимум.
[43:54.480 --> 43:56.480]  Erase максимум.
[43:56.480 --> 43:58.480]  Erase максимум.
[43:58.480 --> 44:00.480]  И как раз, поскольку в этой вершине хотя бы T ключей,
[44:00.480 --> 44:02.480]  мы опять поддерживаем наш вариант,
[44:02.480 --> 44:04.480]  что если мы пытаемся что-то удалить из вершины,
[44:04.480 --> 44:06.480]  точнее в поддере какой-то вершины,
[44:06.480 --> 44:10.480]  то в текущей позиции нужно, чтобы было хотя бы T ключей.
[44:10.480 --> 44:12.480]  И так будет верно по предположению,
[44:12.480 --> 44:14.480]  если здесь хотя бы T ключей.
[44:14.480 --> 44:16.480]  Тогда по сути у меня задача связалась
[44:16.480 --> 44:18.480]  с удалением из листа, а такое мы уже умеем делать.
[44:18.480 --> 44:20.480]  Если удаление происходит из листа,
[44:20.480 --> 44:22.480]  то нужно просто поддерживать вариант,
[44:22.480 --> 44:24.480]  что в текущей решении хотя бы T ключей,
[44:24.480 --> 44:26.480]  потом дошли до листа и нужно просто данное число удалить.
[44:26.480 --> 44:28.480]  То же самое,
[44:28.480 --> 44:30.480]  если, скажем, левый листик,
[44:30.480 --> 44:32.480]  левый сын у нас маленький,
[44:32.480 --> 44:34.480]  но в правом хотя бы T ключей,
[44:34.480 --> 44:36.480]  тогда нужно точно также найти
[44:36.480 --> 44:38.480]  минимальный элемент здесь,
[44:38.480 --> 44:40.480]  вот здесь, на той же глубине,
[44:40.480 --> 44:42.480]  нужно найти здесь минимальный элемент,
[44:42.480 --> 44:44.480]  скопировать его на место X,
[44:44.480 --> 44:46.480]  а дальше запуститься от этого поддерева
[44:46.480 --> 44:48.480]  с запросом resmin.
[44:48.480 --> 44:50.480]  То есть мы знаем это число, нашли его просто спуском,
[44:50.480 --> 44:52.480]  потом запускаемся от этого поддерева
[44:52.480 --> 44:54.480]  с запросом удаления минимального элемента.
[44:54.480 --> 44:56.480]  И опять, поскольку в этой вершине,
[44:56.480 --> 44:58.480]  по предположению хотя бы T ключей,
[44:58.480 --> 45:00.480]  мы можем так сделать,
[45:00.480 --> 45:02.480]  то есть наша вся эта штука работает точно так же.
[45:02.480 --> 45:04.480]  В случае, если в левом сыне
[45:04.480 --> 45:06.480]  или в правом сыне хотя бы T ключей,
[45:06.480 --> 45:08.480]  то мы начали решать задачу.
[45:08.480 --> 45:10.480]  Теперь что делать, если это неверно?
[45:10.480 --> 45:12.480]  Если в обоих сыновьях по T ключу,
[45:12.480 --> 45:14.480]  по минимально возможному количеству.
[45:14.480 --> 45:16.480]  Вот есть X, вот есть два указателя вокруг него
[45:16.480 --> 45:18.480]  на левое и правое сына.
[45:18.480 --> 45:20.480]  Кстати, я скажу,
[45:20.480 --> 45:22.480]  что вот это похоже на наивное дерево поиска.
[45:22.480 --> 45:24.480]  Наивное дерево поиска.
[45:24.480 --> 45:26.480]  Потому что как мы делаем наивное дерево поиска,
[45:26.480 --> 45:28.480]  мы, скажем, спускались в правое сына,
[45:28.480 --> 45:30.480]  доставали там минимальное число,
[45:30.480 --> 45:32.480]  копировали его на место X,
[45:32.480 --> 45:34.480]  и по сути удаляли его из вот этого правого поддерева.
[45:34.480 --> 45:36.480]  Ровно это мы здесь и делаем.
[45:36.480 --> 45:38.480]  Взяли элемент, скопировали его на место X,
[45:38.480 --> 45:40.480]  и дальше его удалили из дерева.
[45:40.480 --> 45:42.480]  Теперь плохой случай,
[45:42.480 --> 45:44.480]  когда в обоих сыновьях по теминственному ключу.
[45:44.480 --> 45:46.480]  По теминственному ключу.
[45:46.480 --> 45:48.480]  Тогда сделаем следующее.
[45:48.480 --> 45:50.480]  Мы уже умеем объединять две вершинки,
[45:50.480 --> 45:52.480]  спуская в них X.
[45:52.480 --> 45:54.480]  Давайте слияние вершин.
[45:54.480 --> 45:56.480]  Слияние вершин мы такое уже делали.
[45:56.480 --> 45:58.480]  У нас есть уже процедура,
[45:58.480 --> 46:00.480]  которая сливает две средние вершинки.
[46:00.480 --> 46:02.480]  Будет следующее. Если левее X было C, правее было D,
[46:02.480 --> 46:04.480]  то теперь в вождительской вершинке будет C,
[46:04.480 --> 46:06.480]  а в дочерней вершинке
[46:06.480 --> 46:08.480]  будет L, R,
[46:08.480 --> 46:10.480]  разделенный X.
[46:10.480 --> 46:12.480]  Мы просто взяли вот такую вот большую вершинку,
[46:12.480 --> 46:14.480]  склеили это в одну,
[46:14.480 --> 46:16.480]  L, X, R.
[46:16.480 --> 46:18.480]  И вместо этих двух указателей
[46:18.480 --> 46:20.480]  будет один указатель.
[46:20.480 --> 46:22.480]  То есть вместо этих двух будет один вот такой.
[46:22.480 --> 46:24.480]  Тем самым, что мы сделали?
[46:24.480 --> 46:26.480]  Мы склеили две вершинки,
[46:26.480 --> 46:28.480]  и наш X опустили на глубину 1 вниз.
[46:28.480 --> 46:30.480]  И теперь, получается,
[46:30.480 --> 46:32.480]  запускаемся опять рекурсивно от этого поддерева
[46:32.480 --> 46:34.480]  с запросом удаления X.
[46:34.480 --> 46:36.480]  Но теперь в этой вершинке опять,
[46:36.480 --> 46:38.480]  в ней ровно 2T-1 ключ на самом деле,
[46:38.480 --> 46:40.480]  но главное, чтобы в нем хотя бы D ключи.
[46:40.480 --> 46:42.480]  И такой алгоритм
[46:42.480 --> 46:44.480]  будет так делать.
[46:44.480 --> 46:46.480]  То есть он будет видеть, что есть вершинка,
[46:46.480 --> 46:48.480]  в которой находится X. Он опять смотрит на вот эти
[46:48.480 --> 46:50.480]  две стрелки, исходящие из X.
[46:50.480 --> 46:52.480]  Стрелка левее правее X.
[46:52.480 --> 46:54.480]  И если в одном из сыновей хотя бы D ключи,
[46:54.480 --> 46:56.480]  то он делает вот эту штуку,
[46:56.480 --> 46:58.480]  которая здесь есть, либо максимум, либо минимум ищет.
[46:58.480 --> 47:00.480]  И опять он склеивает двух сыновей,
[47:00.480 --> 47:02.480]  спускает X вниз и так далее.
[47:02.480 --> 47:04.480]  В итоге у меня X,
[47:04.480 --> 47:06.480]  либо мы понимаем, что можно
[47:06.480 --> 47:08.480]  просто взять максимум, поставить его на место X
[47:08.480 --> 47:10.480]  и запустить за рекурсивно от одного из поддеревев,
[47:10.480 --> 47:12.480]  либо мы спускаем X
[47:12.480 --> 47:14.480]  на один уровень вниз
[47:14.480 --> 47:16.480]  от D действий.
[47:16.480 --> 47:18.480]  То есть мы склеим какие-то две вершинки,
[47:18.480 --> 47:20.480]  перетаскиваем X, но главное, что у нас
[47:20.480 --> 47:22.480]  глубина X увеличилась.
[47:22.480 --> 47:24.480]  И так мы сделаем, суммарно, наше количество действий,
[47:24.480 --> 47:26.480]  ну, количество шагов нашего алгоритма
[47:26.480 --> 47:28.480]  будет пропорционально глубине,
[47:28.480 --> 47:30.480]  потому что X просто спускается каждый раз
[47:30.480 --> 47:32.480]  на единичку глубины.
[47:32.480 --> 47:34.480]  Вот и всё.
[47:34.480 --> 47:36.480]  Получается опять алгоритм
[47:36.480 --> 47:38.480]  за T лог T.
[47:38.480 --> 47:40.480]  В смысле T лог
[47:40.480 --> 47:42.480]  N по основанию T.
[47:42.480 --> 47:44.480]  Вот так.
[47:46.480 --> 47:48.480]  Вот есть ли вопросы по кой-то кусочкам,
[47:48.480 --> 47:50.480]  то есть на самом деле всё, мы с Razim разобрались полностью.
[47:56.480 --> 47:58.480]  Хорошо.
[47:58.480 --> 48:00.480]  Вроде как нет.
[48:00.480 --> 48:02.480]  Итак, B-дереву мы обсудили,
[48:02.480 --> 48:04.480]  Insert и Raz делать научились,
[48:04.480 --> 48:06.480]  да, согласен, тут нет ничего простого,
[48:06.480 --> 48:08.480]  тут много случаев, надо аккуратно с ним повозиться,
[48:08.480 --> 48:10.480]  но вот, по крайней мере, с теоретической точки зрения
[48:10.480 --> 48:12.480]  мы всё это обсудили.
[48:12.480 --> 48:14.480]  И применение тоже поняли,
[48:14.480 --> 48:16.480]  зачем это может быть нужно.
[48:16.480 --> 48:18.480]  Хорошо, значит, тогда наше новое дерево поиска,
[48:18.480 --> 48:20.480]  которое, думаю, многие из вас
[48:20.480 --> 48:22.480]  уже знают,
[48:22.480 --> 48:24.480]  со школы,
[48:24.480 --> 48:26.480]  с олимпиадных кружков,
[48:26.480 --> 48:28.480]  это декартовое дерево.
[48:28.480 --> 48:30.480]  Декартовое дерево.
[48:32.480 --> 48:34.480]  Как удалять из корня?
[48:34.480 --> 48:36.480]  Ну, смотрите, мы умеем удалять из...
[48:36.480 --> 48:38.480]  Вот, смотрите,
[48:38.480 --> 48:40.480]  вот здесь, как мы дошли до вершинки,
[48:40.480 --> 48:42.480]  в ней находится X,
[48:42.480 --> 48:44.480]  что нам было нужно?
[48:44.480 --> 48:46.480]  Либо что это корень, либо что в ней хотя бы так ключи.
[48:46.480 --> 48:48.480]  Ну, опять, если в левом сыне хотя бы так ключи,
[48:48.480 --> 48:50.480]  то мы запускаемся вот этой штукой,
[48:50.480 --> 48:52.480]  RazMax, если в правом сыне хотя бы так ключи,
[48:52.480 --> 48:54.480]  то мы запускаемся в этот X,
[48:54.480 --> 48:56.480]  который с мимом в нем.
[48:56.480 --> 48:58.480]  Иначе в этих двух сыновьях подойдет в своем ключу,
[48:58.480 --> 49:00.480]  и что мы сделаем?
[49:00.480 --> 49:02.480]  Мы взяли вот этот X, опустили его вниз,
[49:02.480 --> 49:04.480]  и получается, ну, как бы,
[49:04.480 --> 49:06.480]  из корня вытащили этот элемент,
[49:06.480 --> 49:08.480]  и теперь вот этот наш новый ребенок.
[49:08.480 --> 49:10.480]  То есть, по сути, корень ничем не отличается
[49:10.480 --> 49:12.480]  от всех остальных вершинок.
[49:12.480 --> 49:14.480]  То есть, точно так же мы перетаскиваем X вниз
[49:14.480 --> 49:16.480]  и запускаемся рекурсивно от этой новой вершинки.
[49:16.480 --> 49:18.480]  Здесь корень ничем не исключительный.
[49:18.480 --> 49:22.480]  Смотрите, это опять-таки дерево поиска.
[49:22.480 --> 49:24.480]  Дерево поиска.
[49:24.480 --> 49:26.480]  Я напишу так.
[49:26.480 --> 49:28.480]  Средняя глубина которого
[49:28.480 --> 49:30.480]  средняя, скажем, ожидаемая.
[49:36.480 --> 49:38.480]  Глубина которого
[49:40.480 --> 49:42.480]  есть отлоган.
[49:42.480 --> 49:44.480]  То есть, по горифму мы читаем все.
[49:44.480 --> 49:46.480]  Мы отказываемся от нашей парадигмы,
[49:46.480 --> 49:48.480]  что у нас очень большая база данных.
[49:48.480 --> 49:50.480]  Давайте вернемся к нашим простым случаям,
[49:50.480 --> 49:52.480]  типа AVL с плей-деревом,
[49:52.480 --> 49:54.480]  когда все помещается в оперативку,
[49:54.480 --> 49:56.480]  и мы спокойно с этим работаем, как всегда до этого.
[49:56.480 --> 49:58.480]  Декартово дерево — это еще одно дерево поиска
[49:58.480 --> 50:00.480]  наравне с AVL деревом и с плей-деревом,
[50:00.480 --> 50:02.480]  которое имеет в среднем логарифмическую глубину.
[50:02.480 --> 50:04.480]  Ну вот что значит средняя?
[50:04.480 --> 50:06.480]  Это означает, что математическое ожидание глубины
[50:06.480 --> 50:08.480]  логарифмично.
[50:08.480 --> 50:10.480]  Значит, мат ожидания глубины.
[50:16.480 --> 50:18.480]  Равно отлоган.
[50:18.480 --> 50:20.480]  И это мат ожидания в том же смысле,
[50:20.480 --> 50:22.480]  в каком мы говорили про мат ожидания,
[50:22.480 --> 50:24.480]  когда говорили про, скажем,
[50:24.480 --> 50:26.480]  QuickSort или QuickSelect.
[50:26.480 --> 50:28.480]  Значит, вспоминаем QuickSort — это какой-то алгоритм,
[50:28.480 --> 50:30.480]  который выбирает случайный пивот,
[50:30.480 --> 50:32.480]  как-то делит, что-то как-то запускается.
[50:32.480 --> 50:34.480]  И мы формулировали теорему без доказательств,
[50:34.480 --> 50:36.480]  пока что, потому что мы не можем со случайностью работать
[50:36.480 --> 50:38.480]  должным образом,
[50:38.480 --> 50:40.480]  что этот алгоритм в среднем работает за нлоган.
[50:40.480 --> 50:42.480]  То есть, грубо говоря, если вы его запускаете
[50:42.480 --> 50:44.480]  на реально случайных пивотах,
[50:44.480 --> 50:46.480]  то его время работы ограничено
[50:46.480 --> 50:48.480]  констандов damn Logan.
[50:48.480 --> 50:50.480]  То есть, просто работает всегда за нлоган,
[50:50.480 --> 50:52.480]  на случайном наборе.
[50:52.480 --> 50:54.480]  И если у вас реально случайность у Murakami генерируется,
[50:54.480 --> 50:56.480]  то время работы будет от нлоган.
[50:56.480 --> 50:58.480]  То же самое и здесь.
[50:58.480 --> 51:00.480]  Здесь будет какая-то случайность.
[51:00.480 --> 51:02.480]  И можно доказать,
[51:02.480 --> 51:04.480]  что средняя глубина, то есть мат ожидания глубины,
[51:04.480 --> 51:06.480]  будет логарифмическим.
[51:06.480 --> 51:08.480]  То есть на практике, если вы реально будете
[51:08.480 --> 51:10.480]  случайно генерировать то, что нужно исключать,
[51:10.480 --> 51:12.480]  то ваша глубина будет очень редко отклоняться
[51:12.480 --> 51:20.480]  то есть с Данельза смешной вероятности, Данельза маленькой вероятностью у вас будет то, что глубина будет
[51:20.480 --> 51:24.480]  с сильным большим логарифом, и ей можно принимать пренебрегательную практику.
[51:24.480 --> 51:34.480]  Ну так вот, это дерево поиска, но теперь у нас с каждым ключом, скажем, х, будет также ассоциирован некий приоритет y.
[51:34.480 --> 51:40.480]  Значит, тогда вот декартовое дерево, давайте определение напишем, определение декартового дерева.
[51:40.480 --> 51:56.480]  Это обычное двоичное дерево поиска по ключам, двоичное дерево поиска по ключам, которые мы будем обозначать х.
[51:56.480 --> 52:10.480]  И куча с минимумом в корне, ну наша обычная куча, по приоритетам, которые мы будем обозначать y.
[52:10.480 --> 52:17.480]  Значит, что это значит? Это значит, что у нас есть настоящие нормальные ключи х, которые вставляются, удаляются в наши множки,
[52:17.480 --> 52:24.480]  про которые нужно сообщать, лежат они в множке или нет, и в пары к ним, то есть к каждому х, я еще в дополнение
[52:24.480 --> 52:29.480]  генерирую случайный приоритет y. Вот эти приоритеты y мы будем случайно генерировать в программе.
[52:29.480 --> 52:38.480]  Случайно сгенерированы для каждого х. То есть для каждого ключа свой приоритет сгенерирован,
[52:38.480 --> 52:43.480]  и соответственно декартовое дерево строится как двоичное дерево по х, и при этом куча по y.
[52:43.480 --> 52:48.480]  То есть каждый элемент теперь это, ну по сути, точка на плоскости x и y.
[52:48.480 --> 52:53.480]  Точка на плоскости x и y, ключ запятая приоритет. Ну какой-нибудь пример давайте нарисуем.
[52:53.480 --> 53:01.480]  Вот если я так расположу координатные оси x и y, то что получается?
[53:01.480 --> 53:13.480]  Ну давайте я что-нибудь нарисую, потом задам координаты x и y, и вот что-нибудь такое, например.
[53:13.480 --> 53:20.480]  Тогда, например, вот это будет точка там 10 запятая 3, то есть я сначала пишу x, потом y, как всегда.
[53:20.480 --> 53:38.480]  То есть действие будет там 5, 7, 3, 10, 8, 14, и здесь что-нибудь в стиле там 20 запятая 5, 17 запятая 8.
[53:38.480 --> 53:44.480]  Вот, например, это будет декартовый дерево. То есть смотрите, в принципе, существенная информация нам для ответа на наши запросы,
[53:44.480 --> 53:50.480]  insert, erase и find, важны только вот эти x, 10, 5, 3, 8. Ну, короче, понятно.
[53:50.480 --> 53:58.480]  Вот эти первые компоненты, они отвечают ключам. Это, собственно, то, почему мы делаем наши запросы, find и insert, erase.
[53:58.480 --> 54:03.480]  Вот, а вот эти вторые компоненты, они просто искусственно, ну как мы их случайно геемим, 3, 5, 7, ну короче, вот эти числа,
[54:03.480 --> 54:10.480]  вот эти числа, вторые компоненты, они случайно геемим на скрине ринка. Вот, ну и дальше, раз это дерево поиска по x и куча по y,
[54:10.480 --> 54:16.480]  то получается в корне обязательно находится элемент с минимальным приоритетом, тройкой минимальных приоритетов.
[54:16.480 --> 54:24.480]  Дальше, слева находится только элемент, у которых ключ меньше чем 10, да, то есть мы, по сути, можем проехать такую вертикальную прямую
[54:24.480 --> 54:30.480]  и сказать, что слева, ну, как бы влевом по дереве могут находиться только элементы, у которых ключ меньше чем 10, да, x меньше чем 10.
[54:30.480 --> 54:34.480]  Справа, наоборот, x больше чем 10, потому что все дерево поиска.
[54:34.480 --> 54:40.480]  Ну и при этом они должны лежать ниже, чем на шкоре, не потому что у них должен быть больший приоритет, да, больший приоритет ниже 9.
[54:40.480 --> 54:45.480]  Соответственно, здесь там 5, 7, соответственно, здесь ниже.
[54:45.480 --> 54:48.480]  С одной стороны ключ должен быть меньше, чем 5, с другой стороны приоритет большим 7.
[54:48.480 --> 54:53.480]  Это и выполняется здесь, ключ больше чем 5, но большим 7.
[54:53.480 --> 55:01.400]  ключ 8 и приоритет 14. все. ключ больше чем 5 приоритет больше чем 7. вот и так
[55:01.400 --> 55:06.220]  строится наше декартовое дерево. повторюсь, это дерево поиска по
[55:06.220 --> 55:12.960]  иксам и куча по иксам. давайте сравниваем террорему еще раз без заказательства.
[55:12.960 --> 55:20.940]  давайте сначала скажу так. давайте скажу упражнения на
[55:21.000 --> 55:25.000]  семинар, что если все ключи все приоритеты
[55:25.000 --> 55:27.540]  различны
[55:28.020 --> 55:31.560]  все приоритеты различны
[55:31.920 --> 55:38.380]  попарно различны, то декартовое дерево строится однозначно
[55:40.420 --> 55:46.740]  декартовое дерево строится однозначно более того за линейное время
[55:46.740 --> 55:59.740]  Более того, можно построить декартовое дерево по заданному набору х и у за от и при условии, что там у вас х посортирован.
[55:59.740 --> 56:09.740]  И теорема, если в декартовом дереве все приоритеты изгенерированы случайно,
[56:09.740 --> 56:21.740]  то раз они изгенерированы случайно, то с одной стороны, и считаем, что все ключи различны,
[56:21.740 --> 56:30.740]  потому что у нас нет дубликатов в нашем множестве, то вероятность того, что среди случайно изгенерированных чисел будут два равных числа,
[56:31.740 --> 56:42.740]  она, конечно, принадлежит мало. Если вы генерируете числа порядка от 1 до 10 в 9, и так 10 в 5 раз, то вероятность того, что у вас есть два одинаковых числа, то она, конечно, очень-очень маленькая.
[56:42.740 --> 56:56.740]  Получается, что почти всегда у вас дерево единственным образом определено, значит, у него корректно определено глубина, если вы случайно все изгенерировали, то дальше глубина определяется однозначно.
[56:56.740 --> 57:14.740]  Так вот, в таком случае математическое ожидание глубины декартового дерева нашего, давайте я напишу декартовое дерево, математическое ожидание глубины есть от логарифмы, от логарифмы.
[57:14.740 --> 57:16.740]  Матоматическое ожидание глубины логарифмично порой.
[57:22.740 --> 57:31.740]  Значит, чем декартовое дерево нам интересно? Оно интересно, я бы сказал, своей максимальной простотой. Давайте отметим ее плюсы.
[57:32.740 --> 57:39.740]  Плюс – это простота в написании, мне кажется, это самое простое для написания дерева в сравнении со всем предыдущими.
[57:39.740 --> 57:46.740]  Ну, минусы здесь очевидны, у нас все вероятностные, минусы все вероятностные.
[57:46.740 --> 57:58.740]  То есть мы не можем ничего сказать про то, что наш алгоритм всегда работает не больше, чем два логен действий, потому что с какой-то вероятностью он может работать дольше.
[57:58.740 --> 58:10.740]  Ну, это такой типичная проблема для вероятностных алгоритмов, что иногда они работают редко, да, очень редко, да, на практике этим можно поднимлечь, но все-таки по крайней мере в рамках теории про это нельзя забывать.
[58:10.740 --> 58:18.740]  Итак, значит, в декартовом дереве базовыми операциями обычно называются плит и мерч.
[58:19.740 --> 58:21.740]  Да, давайте.
[58:24.740 --> 58:28.740]  Сначала мы просто для каждого х генерируем, а дальше устроим, да?
[58:28.740 --> 58:41.740]  Да, да, у нас есть n ключей, n х, для каждого х случайно генерируем свой приоритет y, а дальше с вероятностью близкой к единице это дерево однозначно определено, да, потому что все приоритеты будут различны с большой вероятностью,
[58:41.740 --> 58:48.740]  и раз дерево однозначно определено, то у него корректно определена высота, и им от ожидания высоты утверждается теоремой есть отлогарифм.
[58:50.740 --> 59:01.740]  Так вот, значит, в декартовом дереве самые простые операции это split и мерч. Раньше мы делали все через insert и erase, давайте мы сделаем здесь наоборот, мы сделаем через split и мерч.
[59:02.740 --> 59:11.740]  Значит, надеюсь на семинаре вы научились делать split и мерч для сплей дерева, если нет, то ничего страшного, мы сейчас это сделаем для декартов.
[59:11.740 --> 59:25.740]  Значит, как сделать мерч и вообще что это значит? Это значит, что у вас есть два декартовых дерева, скажем, t1 и t2, причем ключи у них разнесены, то есть все ключи здесь, строго меньше, все ключи здесь.
[59:25.740 --> 59:39.740]  Все иксы в левом дереве строго меньше всех ключей правого дерева. Вот пусть откуда-то у вас есть две такие декарты, тогда я утверждаю, что их можно довольно эффективно слить в одно большое декартовое дерево за время пропорциональной сумми глубин t1 и t2.
[59:39.740 --> 59:53.740]  K это иксы в смысле? Да, да, ключи. Ключи иксы. Y и не важны, да. Ключи, иксы, key это все одно и то же. Y и не важны, главное, что ключи влево меньше, чем все ключи вправо.
[59:53.740 --> 01:00:05.740]  Итак, значит, как работает мерч? Ну, по сути мы поняли, давайте считать, что у меня все ключи попарно различные, все приоритеты попарно различные, тогда декартовое дерево всегда корректно относится к определенному упражнению.
[01:00:06.740 --> 01:00:17.740]  Тогда как оно может выглядеть? Ну, давайте посмотрим на наши вот эти вот два корня. Давайте скажем, что это точка A, это точка B. Соответственно, у каждой точки есть там x координаты, y координаты, то есть ключ приоритет.
[01:00:17.740 --> 01:00:31.740]  Давайте поймем, кто из них может быть корнем. Ну, понятно, ровно та вершина, у которой приоритет меньше, да, потому что в корне, поскольку декарта дерева это куча по y, куча по приоритетам, то в корне обязательно должна быть вершина с минимально возможным приоритетом.
[01:00:31.740 --> 01:00:42.740]  Ну, а раз A это вершина с минимальным приоритетом в своем дереве, B это вершина с минимальным приоритетом в своем дереве, то корень нового дерева это либо A, либо B, в зависимости от того, у кого из них приоритет меньше.
[01:00:42.740 --> 01:00:54.740]  То есть, например, если A y меньше, чем B y, то A это новый корень. A это корень результата обязательно, потому что у него просто минимальный приоритет.
[01:00:55.740 --> 01:01:05.740]  Ну хорошо, вот есть A. Мы понимаем, что это наш новый корень. Тогда в левом поддереве должны находиться все элементы меньше, чем A, а в правом все больше, потому что дерево поиска по x.
[01:01:05.740 --> 01:01:12.740]  То есть, здесь должны быть все элементы, которые меньше по x, чем A, а справа все, которые больше по x, чем A.
[01:01:12.740 --> 01:01:27.740]  Ну, тогда что за элементы, которые меньше по x элемента A? Это просто левое поддерево A, A.L, потому что только элементы, которые лежат в левом поддереве A, являются меньше, чем A, потому что правое поддерево больше, чем A, и здесь все элементы тоже больше, чем A по ключу.
[01:01:28.740 --> 01:01:35.740]  А справа мне нужно каким-то образом передать информацию и о правом поддереве A, и обо всем дереве B.
[01:01:35.740 --> 01:01:42.740]  Тогда давайте просто здесь в качестве правого сына подвесим merge A.right и B.
[01:01:42.740 --> 01:01:53.740]  То есть, мы понимаем, что справа, поскольку это дерево поиска по x, справа мне нужно как-то объединить информацию о дереве B и о правом по дереве A, то есть спуститься вниз-направо и взять вот по дереву.
[01:01:53.740 --> 01:02:02.740]  Давайте тогда просто запустим опять процедуру merge, которая нам склеит вот это вот поддерево вот с этим, и подвесим это в качестве правого сына.
[01:02:02.740 --> 01:02:12.740]  То есть merge считаем, что возвращает какой-то указатель на корень нового дерева, мы взяли вот эти вот две штуки, склеили их в одно большое дерево и подвесили в качестве нового сына, нового правого сына A.
[01:02:12.740 --> 01:02:19.740]  Вот и весь merge. Поняли, кто корень, склеили там нужные поддеревья и подвесили в качестве сына.
[01:02:19.740 --> 01:02:31.740]  Вот это случай, когда AY меньше, чем B.Y. В противоположный случай очень просто также разбирается, если AY больше, чем B.Y, ну или больше или равно, можно формально написать.
[01:02:31.740 --> 01:02:40.740]  Если равность, то понятно, что там уже неоднозначности возникают, но они возникают с вероятностью, стремяющейся к нулю.
[01:02:40.740 --> 01:02:43.740]  А если у вас число денежного случания, то вероятность такая будет почти 0.
[01:02:43.740 --> 01:02:48.740]  Так вот, тогда мы понимаем, что корнем должен стать, наоборот, B.
[01:02:48.740 --> 01:02:57.740]  Окей, кто справа от него? Ну понятно правое под дерево B, потому что элементы, которые больше, чем B.X по ключу, они лежат только в правом под дереве B.
[01:02:57.740 --> 01:03:01.740]  А слева должно лежать все A, а еще левое под дерево B.
[01:03:01.740 --> 01:03:12.740]  Поэтому здесь должно быть мерч от A запятая B.Left. Нам просто взяли все элементы, которых ключи меньше, чем B.X, ну и склеили их в одно большое дерево.
[01:03:12.740 --> 01:03:18.740]  С помощью той же самой процедуры мерч. То есть мы рекурсивно так спускаемся, объединяем нужные по деревьям и что-то там переподвешивает.
[01:03:18.740 --> 01:03:29.740]  Вот такая простейшая процедура. Корректность следует, собственно, из того, что дерево однозначно определено, и мы каждый раз понимаем, что корень, понимаем, куда нужно отнести все вершинки влево или вправо.
[01:03:29.740 --> 01:03:45.740]  То есть асимптотика O от суммы глубин depth, depth T1 плюс depth T2, потому что по сути я просто на каждом шаге либо спускаюсь вправо в дереве A, либо влево в дереве B.
[01:03:45.740 --> 01:03:57.740]  Можно теоретически взять формулу, которая дает рандомные числа в заднем диагнозоне и никогда не повторяется.
[01:03:57.740 --> 01:04:13.740]  Я не уверен, но на практике, если вам прям сильно хочется, чтобы все приоритеты были различны, наверное лучше сделать так.
[01:04:13.740 --> 01:04:19.740]  Наверное, просто генерировать приоритеты, проверять новый приоритет или нет.
[01:04:19.740 --> 01:04:33.740]  На практике скорее проще сделать так. Сгенерировать 3n или 5n приоритетов, посортировать, удалить дубликаты.
[01:04:33.740 --> 01:04:41.740]  То есть если вдруг сгенерировались повторные приоритеты, то мы их удаляем, а дальше опять рандомно перемешиваем.
[01:04:42.740 --> 01:04:50.740]  Если у нас количество запросов больше, чем длина диапазона, то такой формулы не существует.
[01:04:50.740 --> 01:04:52.740]  Ну в частности, да.
[01:04:52.740 --> 01:04:59.740]  Если меньше и нам не важно, настолько она случайна, то мы говорим, что она просто возвращает номер запроса.
[01:04:59.740 --> 01:05:05.740]  Можно просто номера запросов перемешать все. Ну не номера запросов, а все x и y.
[01:05:06.740 --> 01:05:13.740]  Тут много способов. Давайте считать, что реально мы просто генируем случайные y и с вероятностью почти ноль они могут совпадать.
[01:05:13.740 --> 01:05:20.740]  Можно написать функцию балансировки и сказать, что если длина очень много раз превышает логарифм, то она вызывается.
[01:05:20.740 --> 01:05:23.740]  А как перебалансировка работает?
[01:05:23.740 --> 01:05:28.740]  Для этого мы все значения вкидываем сейчас.
[01:05:28.740 --> 01:05:36.740]  Но тут получается множество, а потом, ну она за большую симпатику работает, поэтому вызывается только если большое превышение.
[01:05:36.740 --> 01:05:41.740]  А дальше мы рассчитываем веса искусственно для каждого.
[01:05:41.740 --> 01:05:45.740]  Я писал только для неявного ключа, когда лассив.
[01:05:45.740 --> 01:05:51.740]  Да-да-да, я понял, но кажется это все равно не обязательно, ну то есть случайно.
[01:05:51.740 --> 01:05:53.740]  Малая вероятность вызовется.
[01:05:54.740 --> 01:06:01.740]  Еще вопрос, конец рекурсии. Да, конец рекурсии, я часто люблю опускать конец рекурсии, но конец рекурсии, когда a или b пусто.
[01:06:01.740 --> 01:06:05.740]  Если a пусто или b пусто, тогда merge это соответственно второй из них.
[01:06:05.740 --> 01:06:11.740]  А если a пусто, то ответ это b, если b пусто, то ответ это a.
[01:06:11.740 --> 01:06:13.740]  Хорошо, merge обсудили.
[01:06:13.740 --> 01:06:20.740]  Ну и поскольку, если мы знаем, что глубина обоих деревьев логарифмична, то точка тоже будет от логарифма, в среднем от логарифма.
[01:06:20.740 --> 01:06:22.740]  Теперь переходим к операции split.
[01:06:22.740 --> 01:06:28.740]  Я думаю, я немножко ускорюсь, потому что нам нужно еще неявно дерево как-то обсудить, вот давайте split обсудим.
[01:06:28.740 --> 01:06:29.740]  Что такое split?
[01:06:29.740 --> 01:06:37.740]  Split это процедура, которая по данному дереву t и ключу x разбивает это дерево на два дерева, извините, l и r.
[01:06:37.740 --> 01:06:42.740]  Так что в левом дереве все ключи меньше и равны x, а в правом дереве все ключи больше x.
[01:06:42.740 --> 01:06:48.740]  То есть, по сути, мы проводим вертикальную такую линию на нашей плоскости, как раз декарту, потому что на плоскости хорошо изображается.
[01:06:48.740 --> 01:06:56.740]  А проводим вертикальную линию, все ключи, которые левее этой прямой, включая эту прямую, мы относим в одно дерево, все остальное относим в второе дерево.
[01:06:56.740 --> 01:06:58.740]  И вот как работает split в декартовом деле.
[01:06:58.740 --> 01:07:06.740]  Здесь опять давайте встанем в корень root нашего дерева t и сравним root.x с x.
[01:07:06.740 --> 01:07:09.740]  Но давайте считать, что root.x, скажем, больше, чем x.
[01:07:09.740 --> 01:07:15.740]  Это означает, что прямая разделение, разделяющая прямая, лежит левее root.x.
[01:07:16.740 --> 01:07:24.740]  И наше разделение, наш split, по сути, разделяет только левое под дерево, а правое под дерево вообще не меняет.
[01:07:24.740 --> 01:07:30.740]  Ну, потому что если вот эта вертикальная прямая находится левее корня, то, значит, она вообще не затрагивает наше правое дерево.
[01:07:30.740 --> 01:07:37.740]  Потому что декартовое дерево, соответственно, все, что правее лежит, все в правом под дереве, лежит только справа от корня.
[01:07:37.740 --> 01:07:44.740]  Вот, значит, можно запуститься рекурсивно от левого сына, здесь подразбить это дерево на a и b.
[01:07:44.740 --> 01:07:50.740]  Дальше сказать, что a это l, а b подвесить к корню в качестве левого сына и сказать, что все вот это r.
[01:07:50.740 --> 01:07:56.740]  Значит, давайте считать, что split возвращает l и r, то есть возвращает пару деревьев l и r.
[01:07:56.740 --> 01:08:00.740]  Значит, тогда что здесь происходит? Как работает split?
[01:08:00.740 --> 01:08:13.740]  Если root.x больше x, то давайте скажем, что пара ab это split root.l, то есть от левого под дерева с x,
[01:08:13.740 --> 01:08:22.740]  с тем же ключом мы вызываем split. Дальше говорим, что root.left это b, то есть переподвешиваем b в качестве левого сына к корню,
[01:08:22.740 --> 01:08:33.740]  ну и return пару abt root. То есть в качестве l мы возвращаем то самое a, все элементы, ключи, которых меньше, в общем, x.
[01:08:33.740 --> 01:08:38.740]  А в качестве r мы возвращаем корень, поскольку у него теперь, ну то есть здесь был ключ больше x,
[01:08:38.740 --> 01:08:43.740]  здесь опять в качестве левого сына опять все элементы, у которых ключ больше x, и здесь справа тем более ключ больше x.
[01:08:43.740 --> 01:08:46.740]  Поэтому как раз root это будет корнем правого дерева.
[01:08:46.740 --> 01:08:51.740]  Иначе, если картинка наоборот какая-то вот такая, давайте ее красным нарисуем.
[01:08:51.740 --> 01:08:57.740]  Вот был корень, вот была разделяющая прямая, она находится наоборот правее нашего корня.
[01:08:57.740 --> 01:09:00.740]  Извините, кто такой root.x?
[01:09:00.740 --> 01:09:02.740]  Еще раз.
[01:09:02.740 --> 01:09:04.740]  Кто такой root.x?
[01:09:04.740 --> 01:09:11.740]  Ну смотрите, root это корневая вершина нашего дерева, а x это его ключ. У нас у каждой вершины есть ключ и приоритет.
[01:09:11.740 --> 01:09:14.740]  root.x это ключ вершинки root.
[01:09:14.740 --> 01:09:16.740]  А, все, извините.
[01:09:16.740 --> 01:09:18.740]  Вот.
[01:09:18.740 --> 01:09:23.740]  Значит, что здесь? Здесь нам нужно, наоборот, запустить со сплитом от правого сына, если вот это a это b,
[01:09:23.740 --> 01:09:28.740]  то нам нужно a переподвести качество правого сына к root'у, и сказать, что вот это l и вот это r.
[01:09:28.740 --> 01:09:38.740]  Здесь, да, иначе. Пусть опять ab это сплит, только теперь уже правого сына, root.r.x.
[01:09:38.740 --> 01:09:46.740]  Дальше говорим, что новым правым сыном корня выступает a, и в качестве ответа возвращаем пару root, запятая b.
[01:09:46.740 --> 01:09:56.740]  Потому что ключи меньшего равна x как раз лежат, ну, это по дереву корня, а ключи больше x, а это вот это b, который я вам уже прощитил.
[01:09:56.740 --> 01:10:04.740]  Сейчас мы типа переподвешиваем все дерево за сына, за левого сына или за правого сына?
[01:10:04.740 --> 01:10:06.740]  Ну, смотрите. Что?
[01:10:06.740 --> 01:10:08.740]  Это очень наповорот, похоже, что мы делаем.
[01:10:08.740 --> 01:10:12.740]  Нет, я бы так не сказал. Смотрите, переподвешивание здесь, на самом деле, только одно.
[01:10:12.740 --> 01:10:17.740]  Смотрите, вот, например, вот в этом случае. Мы запустились от правого сына рекурсивно.
[01:10:17.740 --> 01:10:24.740]  Что это значит? Это значит, что в конце нам выдали два дерева a и b. Это просто какие-то два дерева a и b.
[01:10:24.740 --> 01:10:29.740]  Такие, что в дереве a все ключи меньше равны x, в дереве b все ключи больше чем x.
[01:10:29.740 --> 01:10:33.740]  И дальше я просто вместо старого правого сына root'а подвешиваю a.
[01:10:33.740 --> 01:10:35.740]  То есть тут даже нет никаких поворотов.
[01:10:35.740 --> 01:10:38.740]  В конце нам выдали два дерева.
[01:10:38.740 --> 01:10:43.740]  Да-да-да. То есть мы запустились рекурсивно от какого-то дерева.
[01:10:43.740 --> 01:10:45.740]  Нам вернули пару a и b, и мы подвешиваем.
[01:10:45.740 --> 01:10:50.740]  То есть тут b подвешиваем в качестве левого сына, а в качестве правого сына.
[01:10:50.740 --> 01:10:54.740]  Вот такой опять-таки простой алгоритм. Корректность следует просто из того, что дерево единственное.
[01:10:54.740 --> 01:11:00.740]  И вот эта веризикальная разделяющая прямая, она как раз находится либо левее, либо правее.
[01:11:00.740 --> 01:11:05.740]  Асимптотика будет пропорциально приступлива.
[01:11:05.740 --> 01:11:06.740]  Еще раз.
[01:11:06.740 --> 01:11:09.740]  Как будет выглядеть дерево после операции?
[01:11:09.740 --> 01:11:14.740]  Будет два дерева. Будет два несвязанных дерева LR.
[01:11:14.740 --> 01:11:17.740]  Давайте чуть-чуть примерно нарисуем.
[01:11:17.740 --> 01:11:19.740]  Давайте примерно нарисуем.
[01:11:19.740 --> 01:11:26.740]  Сначала скажем, что глубина алгоритмична, потому что время работает в среднем алгоритме, потому что глубина алгоритмична.
[01:11:26.740 --> 01:11:28.740]  Чуть-чуть пример давайте нарисуем.
[01:11:28.740 --> 01:11:33.740]  Или давайте просто я промотаю назад и покажу вот это наше дерево.
[01:11:33.740 --> 01:11:43.740]  Например, если бы я здесь вызвал сплит вот этого дерева по ключу key равному семерке, то как это выглядело?
[01:11:43.740 --> 01:11:46.740]  Я выражу вертикальную прямую x равно 7.
[01:11:46.740 --> 01:11:48.740]  Она выглядит как-то вот так.
[01:11:48.740 --> 01:11:50.740]  Так что и будет сложно, но вот как-то так она выглядит.
[01:11:50.740 --> 01:11:54.740]  То есть она слева оставляет вот эти две вершинки, потому что у них ключи 3 и 5.
[01:11:54.740 --> 01:11:57.740]  А справа все остальные, потому что у них ключи больше чем 7.
[01:11:57.740 --> 01:12:00.740]  Результат будет так.
[01:12:00.740 --> 01:12:05.740]  Вот это будет левое под дерево L, а R будет вот это вот.
[01:12:05.740 --> 01:12:08.740]  Только где эта штука подвесится к корму.
[01:12:08.740 --> 01:12:10.740]  У меня же не может быть несвязанное дерево.
[01:12:10.740 --> 01:12:12.740]  Я тут в рекурсии.
[01:12:12.740 --> 01:12:18.740]  Когда вот это вот по дереву буду разбивать, у меня вот это вернется в качестве B, и я его подвешу в качестве левого сына к корму.
[01:12:18.740 --> 01:12:22.740]  В итоге вот это будет правой компонентой R, а это будет левой компонентой L.
[01:12:22.740 --> 01:12:24.740]  Все, у меня два несвязанных дерева.
[01:12:24.740 --> 01:12:26.740]  Слева все ключи меньше равные чем 7.
[01:12:26.740 --> 01:12:28.740]  Справа все больше чем 7.
[01:12:30.740 --> 01:12:32.740]  Вот пример того, как это работает.
[01:12:34.740 --> 01:12:37.740]  Хорошо, значит мы поняли, как делать split и merge.
[01:12:37.740 --> 01:12:40.740]  Теперь давайте через них выразим insert и erase.
[01:12:40.740 --> 01:12:43.740]  Через них insert и erase выражается очень просто.
[01:12:43.740 --> 01:12:45.740]  Значит, как, например, сделать insert.
[01:12:45.740 --> 01:12:47.740]  Insert, кого заключает x.
[01:12:47.740 --> 01:12:49.740]  Вот было корректное какое-то дикартовое дерево.
[01:12:49.740 --> 01:12:51.740]  Я хочу вставить ему x.
[01:12:51.740 --> 01:12:55.740]  Давайте мы в пару с x сгенируем y.
[01:12:55.740 --> 01:12:57.740]  Generate y.
[01:12:57.740 --> 01:13:01.740]  Мы договорились, что если мы вставляем новый ключ, то у него должен быть новый случайный приоритет.
[01:13:01.740 --> 01:13:02.740]  Давайте его сгенируем.
[01:13:02.740 --> 01:13:06.740]  Дальше мы вызовем у старого дерева split по ключу x.
[01:13:06.740 --> 01:13:10.740]  Соответственно, здесь будут все ключи меньше равные x, а здесь будут все ключи больше x.
[01:13:10.740 --> 01:13:12.740]  Получается два дерева, LR.
[01:13:12.740 --> 01:13:14.740]  Слева все ключи меньше равных, а справа все больше x.
[01:13:14.740 --> 01:13:19.740]  В самом начале давайте проверим, что x в исходном дереве не было, потому что если он был, то вставлять нечего.
[01:13:19.740 --> 01:13:22.740]  Значит, тут не просто меньше равные, а строго меньше, чем x.
[01:13:24.740 --> 01:13:31.740]  А дальше нужно нарисовать дерево из одной вершинки с координатами x и y и запустить merge.
[01:13:31.740 --> 01:13:38.740]  Если это новая вершинка v, нужно запустить merge lv, а потом еще эту штуку смержить с r.
[01:13:40.740 --> 01:13:41.740]  Вот и все.
[01:13:41.740 --> 01:13:44.740]  То есть мы посплитили так, что у нас как раз дерево разошлось на два.
[01:13:44.740 --> 01:13:46.740]  И между ними вклиниваем новую вершинку x и y.
[01:13:46.740 --> 01:13:48.740]  Потом склеим в нужном порядке.
[01:13:48.740 --> 01:13:50.740]  Сначала l с новой вершинкой, потом результат с r.
[01:13:50.740 --> 01:13:51.740]  Все.
[01:13:51.740 --> 01:13:53.740]  Один сплит, два мерж.
[01:13:53.740 --> 01:13:55.740]  Теперь как работает race?
[01:13:55.740 --> 01:13:56.740]  Race x.
[01:13:58.740 --> 01:14:00.740]  Давайте мы сначала посплитим по x.
[01:14:01.740 --> 01:14:03.740]  Опять, да, сплит по x.
[01:14:04.740 --> 01:14:05.740]  Сплит по x.
[01:14:05.740 --> 01:14:06.740]  У меня будут два дерева.
[01:14:06.740 --> 01:14:10.740]  В l ключи меньше равных x, в r ключи больше x.
[01:14:10.740 --> 01:14:15.740]  Теперь мы понимаем, что этот x, ну опять, да, в самом начале давайте сделаем проверку, что x есть в дереве,
[01:14:15.740 --> 01:14:17.740]  если его нет в дереве, то его ничего не нужно.
[01:14:17.740 --> 01:14:19.740]  Иначе x есть в дереве.
[01:14:19.740 --> 01:14:23.740]  И ну давайте вызовем вот в этом дереве сплит по ключу x-1.
[01:14:23.740 --> 01:14:27.740]  То есть если у меня все числа целые, то можно вызвать сплит x-1,
[01:14:27.740 --> 01:14:32.740]  и тогда единственное число, которое лежит в этом по дереве a и будет справа вот x-1,
[01:14:32.740 --> 01:14:33.740]  это тот самый x.
[01:14:33.740 --> 01:14:36.740]  Вот этот элемент выйдет мне в отдельные по дереву.
[01:14:36.740 --> 01:14:38.740]  И будет получается три дерева у меня.
[01:14:38.740 --> 01:14:42.740]  Там какой-то l штрих, будет отдельно x располагаться и отдельно r.
[01:14:42.740 --> 01:14:46.740]  Потому что после вот этого сплита у меня как раз x отдельно высплесывает в отдельную вершинку.
[01:14:46.740 --> 01:14:51.740]  Потом я эту вершинку удаляю, очищаю память и склеиваю lr.
[01:14:51.740 --> 01:14:54.740]  Merge lr.
[01:14:54.740 --> 01:14:55.740]  Все.
[01:14:55.740 --> 01:14:57.740]  Два сплита, один merge.
[01:15:00.740 --> 01:15:04.740]  И поскольку все эти товарищи и сплит и merge работают в среднем золотом рифе,
[01:15:04.740 --> 01:15:09.740]  то и соответственно insert и res тоже работают в среднем золотом рифе.
[01:15:09.740 --> 01:15:12.740]  Вот так можно реализовать все в дикартном деле.
[01:15:12.740 --> 01:15:17.740]  В принципе, там есть процедуры, которые без merge и сплит это делают.
[01:15:17.740 --> 01:15:24.740]  То есть insert и res можно реализовать без этих штук с merge и сплитом.
[01:15:24.740 --> 01:15:29.740]  Там чуть более аккуратно нужно пройтись по дереву, понять, куда нужно вставить, что-то еще поделать.
[01:15:29.740 --> 01:15:34.740]  Будет чуть эффективнее, чуть быстрее, но дольше объяснять и дольше писать.
[01:15:34.740 --> 01:15:38.740]  А с точки зрения симптотики ни на что не влияет.
[01:15:38.740 --> 01:15:40.740]  Поэтому давайте оставим так.
[01:15:42.740 --> 01:15:43.740]  Вот.
[01:15:43.740 --> 01:15:46.740]  И последнее, что хочу рассказать, это неявное дерево поиска.
[01:15:48.740 --> 01:15:50.740]  Неявное дерево поиска.
[01:15:51.740 --> 01:15:54.740]  Ну или, точнее, дерево поиска по неявному ключу.
[01:15:55.740 --> 01:15:59.740]  Дерево поиска по неявному ключу.
[01:16:00.740 --> 01:16:04.740]  Тоже надеюсь на синергию у кого-то было через сплит дерева.
[01:16:04.740 --> 01:16:07.740]  Вот мы сделаем это сейчас через дикартный деле.
[01:16:08.740 --> 01:16:11.740]  Ну что, идея очень простая, мы не будем хранить ключи.
[01:16:11.740 --> 01:16:15.740]  Не будем хранить ключи.
[01:16:18.740 --> 01:16:20.740]  Задача, которую мы хотим решать, например.
[01:16:21.740 --> 01:16:25.740]  Задача такая, есть у вас массив какой-то A1, A2, и так далее, An.
[01:16:25.740 --> 01:16:28.740]  И к нему поступают запросы трех типов.
[01:16:28.740 --> 01:16:32.740]  Первый это insert какого-то числа вал на позицию pos.
[01:16:32.740 --> 01:16:36.740]  То есть, скажем, нужно вставить число pos так, чтобы оно теперь стало...
[01:16:36.740 --> 01:16:40.740]  Продолжно, нужно вставить число вал так, чтобы оно теперь стало pos.
[01:16:40.740 --> 01:16:45.740]  То есть, там найти a pos минус первое, a pos, и между ними вклинить новое число вал.
[01:16:45.740 --> 01:16:48.740]  Ну, короче, вставка в произвольное место массива.
[01:16:48.740 --> 01:16:53.740]  Дальше, erase pos, то есть, удалить a pos.
[01:16:53.740 --> 01:16:56.740]  И, наконец-то, найти сумму на отрезке.
[01:16:56.740 --> 01:17:00.740]  Найти сумму с L по R.
[01:17:00.740 --> 01:17:05.740]  Вставка в произвольное место, удаление из произвольного места и сумма на отрезке.
[01:17:07.740 --> 01:17:13.740]  Так, если у двух элементов обычно дд совпали ключи, программа падает.
[01:17:13.740 --> 01:17:15.740]  А у нас такого не будет никогда.
[01:17:15.740 --> 01:17:20.740]  Поскольку мы поддерживаем, возможно, вы имели в виду приоритеты.
[01:17:20.740 --> 01:17:25.740]  Но с ключами там нет проблем, потому что у нас не будет кратных ключей никогда.
[01:17:25.740 --> 01:17:27.740]  Да, а приоритеты нет.
[01:17:27.740 --> 01:17:31.740]  Там все нормально будет, просто будут неоднозначности, и, возможно, глубина будет чуть больше.
[01:17:31.740 --> 01:17:33.740]  Ну, в смысле, она все равно...
[01:17:33.740 --> 01:17:35.740]  Такое будет редко, мы дожидаем все равно логарифм.
[01:17:35.740 --> 01:17:39.740]  Но нет, там все будет нормально, но просто она неоднозначно определяется.
[01:17:39.740 --> 01:17:41.740]  Никаких проблем с этим тоже нет.
[01:17:41.740 --> 01:17:42.740]  То есть, можно даже не париться.
[01:17:42.740 --> 01:17:44.740]  На практике, когда вы пишете картовое дерево,
[01:17:44.740 --> 01:17:47.740]  не обязательно следите за тем, что у вас все приоритеты по параметрам различны.
[01:17:47.740 --> 01:17:49.740]  Просто их в случае генерите, и все хорошо будет.
[01:17:49.740 --> 01:17:52.740]  То есть, там проблем не будет, просто редко такое бывает.
[01:17:54.740 --> 01:17:55.740]  Такая задача.
[01:17:55.740 --> 01:18:00.740]  Есть массив, вставка удаления в произвольное место и с произвольного места и сумма на отрезке.
[01:18:00.740 --> 01:18:01.740]  Ну, давайте сделаем следующее.
[01:18:01.740 --> 01:18:04.740]  Давайте мы откажемся от ключей.
[01:18:04.740 --> 01:18:09.740]  То есть, неявно будем говорить, что вот каждое число массива...
[01:18:09.740 --> 01:18:13.740]  Ключ у него, это его позиция в массиве.
[01:18:13.740 --> 01:18:17.740]  То есть, этот элемент имеет ключ 1, этот элемент имеет ключ 2, и так далее.
[01:18:17.740 --> 01:18:19.740]  Это пост минус 1, это пост, и так далее.
[01:18:19.740 --> 01:18:24.740]  Но поскольку эти ключи, эти позиции будут меняться при вставках и при удалениях,
[01:18:24.740 --> 01:18:26.740]  например, когда я вот здесь вставляю новый элемент,
[01:18:26.740 --> 01:18:30.740]  у всех этих товарищей индекс увеличится на единичку.
[01:18:30.740 --> 01:18:33.740]  Все ключи увеличатся на единицу, никим проходом.
[01:18:33.740 --> 01:18:35.740]  Поэтому я ключи просто не буду хранить.
[01:18:35.740 --> 01:18:40.740]  И в, скажем, декартовом дереве у меня каждая вершина В,
[01:18:40.740 --> 01:18:44.740]  она будет характеризоваться следующими штуками.
[01:18:44.740 --> 01:18:48.740]  Во-первых, вершина отвечает какому-то элементу, какому-то апосту.
[01:18:48.740 --> 01:18:51.740]  Соответственно, я буду хранить это значение апостуя.
[01:18:51.740 --> 01:18:55.740]  Дальше буду хранить случайный приоритет Y, как всегда случайный.
[01:18:55.740 --> 01:19:01.740]  Дальше мне нужна будет сумма в поддереве, сумма ашек в поддереве,
[01:19:01.740 --> 01:19:04.740]  чтобы находить сумму на отрезке.
[01:19:04.740 --> 01:19:10.740]  И последнее, что мне нужно, это размер поддерева, размер поддерева.
[01:19:10.740 --> 01:19:13.740]  И как бы не явно, раз я храню размер поддерева,
[01:19:13.740 --> 01:19:17.740]  то по сути я все равно буду знать, какой номер у каждой, у каждой на вершинке.
[01:19:17.740 --> 01:19:18.740]  Потому что что такое номер?
[01:19:18.740 --> 01:19:23.740]  Это количество элементов, которые левее меня, ну скажем, там плюс один,
[01:19:23.740 --> 01:19:27.740]  у второго элемента, левее него есть только один и плюс один, так и раз двойка.
[01:19:27.740 --> 01:19:29.740]  То есть мне нужно знать, сколько элементов левее меня.
[01:19:29.740 --> 01:19:32.740]  То есть это все левое поддерево.
[01:19:32.740 --> 01:19:35.740]  Сейчас, не так.
[01:19:35.740 --> 01:19:39.740]  Ну да, короче, номер каждого элемента, это просто количество точек в дикартовом дереве,
[01:19:39.740 --> 01:19:43.740]  которые левее него находятся, если не упорядочно все по координату.
[01:19:43.740 --> 01:19:45.740]  Мы хотим размер поддерева.
[01:19:45.740 --> 01:19:46.740]  Еще раз.
[01:19:46.740 --> 01:19:49.740]  Мы храним размеры и левые, и правого поддерева.
[01:19:49.740 --> 01:19:51.740]  Ну нет, в каждой вершине просто сумма.
[01:19:51.740 --> 01:19:53.740]  Просто суммарный размер всего поддерева.
[01:19:53.740 --> 01:19:58.740]  То есть и левое, и правое, и еще вершинковое тоже учитывается.
[01:19:58.740 --> 01:20:00.740]  Вот, значит, тогда как это будет устроено?
[01:20:00.740 --> 01:20:01.740]  Как будет работать наш логеретик?
[01:20:01.740 --> 01:20:05.740]  Ну давайте, во-первых, поймем, что мерч не меняется.
[01:20:05.740 --> 01:20:08.740]  Не меняется, так как он не смотрит на ключи.
[01:20:08.740 --> 01:20:15.740]  Так как он не смотрит, не смотрит на ключи.
[01:20:15.740 --> 01:20:18.740]  Если мы вспомним наши ифы, которые мы делали в мерже,
[01:20:18.740 --> 01:20:21.740]  то единственное, что там важно, это только приоритеты.
[01:20:21.740 --> 01:20:24.740]  Ну а ключи, раз мы сказали, как у нас происходит мерч.
[01:20:24.740 --> 01:20:27.740]  То есть есть какие-то два куска массива, да, левый, правый.
[01:20:27.740 --> 01:20:30.740]  Мы говорим, что все элементы левого левее, чем все элементы правого.
[01:20:30.740 --> 01:20:32.740]  И мы хотим их склеить ровно в таком порядке,
[01:20:32.740 --> 01:20:35.740]  что сначала идет левый под массив, потом правый.
[01:20:35.740 --> 01:20:39.740]  И когда мы их так склеим, просто с помощью того же мержа, который был раньше,
[01:20:39.740 --> 01:20:43.740]  у меня как раз так и будет, что левее будут находиться все элементы из L,
[01:20:43.740 --> 01:20:45.740]  правее все элементы из R.
[01:20:45.740 --> 01:20:48.740]  И поскольку я не храню, не поддерживаю явным образом ключи,
[01:20:48.740 --> 01:20:51.740]  то ключи это просто будет порядковый номер в этом дереве.
[01:20:51.740 --> 01:20:55.740]  И как раз это и будет, они будут соответствовать индексам в моем массиве.
[01:20:55.740 --> 01:20:57.740]  То есть мерж вообще никак не изменится.
[01:20:57.740 --> 01:20:59.740]  Немножко поменяется сплит.
[01:20:59.740 --> 01:21:04.740]  Но сплит теперь, давайте я напишу, что это будет split by size.
[01:21:04.740 --> 01:21:08.740]  То есть раньше у меня был сплит по ключу, теперь будет сплит по размеру.
[01:21:08.740 --> 01:21:11.740]  Дерево T и скажем какое-то число K.
[01:21:11.740 --> 01:21:12.740]  Эта штука делает следующее.
[01:21:12.740 --> 01:21:15.740]  У вас есть дерево с каким-то большим количеством элементов.
[01:21:15.740 --> 01:21:19.740]  Давайте первые K элементов у вас пойдут в левое дерево,
[01:21:19.740 --> 01:21:20.740]  а все стороны в правое.
[01:21:20.740 --> 01:21:26.740]  То есть эта процедура откусывает первые L элементов из нашего дерева.
[01:21:26.740 --> 01:21:30.740]  Да, X нет, ключей нет, X нет.
[01:21:30.740 --> 01:21:33.740]  Они как бы не явно высчитываются через размеры поддеремов.
[01:21:33.740 --> 01:21:37.740]  Итак, как делать сплит по размеру, по количеству K?
[01:21:37.740 --> 01:21:42.740]  Давайте тоже картинки порисуем.
[01:21:42.740 --> 01:21:48.740]  Если у левого поддерева корня размер поддерева хотя бы K,
[01:21:48.740 --> 01:21:50.740]  то есть если здесь хотя бы K-вершин,
[01:21:50.740 --> 01:21:54.740]  тогда вот эта линия разреза точно проходит где-то в этом левом сырье.
[01:21:54.740 --> 01:22:05.740]  Итак, если root.L.Size больше равно K, root.L это левый сын.
[01:22:05.740 --> 01:22:08.740]  И если у него в поддереве хотя бы K элементов,
[01:22:08.740 --> 01:22:11.740]  значит линия разреза будет проходить где-то в левом сыне.
[01:22:11.740 --> 01:22:20.740]  Тогда давайте мы опять посчитаем рекурсивно сплит root.L запятая K.
[01:22:20.740 --> 01:22:24.740]  Высплитим из левого сына нужные мне две штучки LR.
[01:22:24.740 --> 01:22:30.740]  Дальше скажем, что root.L это B, ну и соответственно return A и root.
[01:22:30.740 --> 01:22:33.740]  Точно так же как у нас было в обычном сплите A и root.
[01:22:33.740 --> 01:22:42.740]  Иначе линия разреза находится правее корня.
[01:22:42.740 --> 01:22:47.740]  То есть все что левее, здесь слишком мало элементов, здесь меньше чем K элементов.
[01:22:47.740 --> 01:22:50.740]  Поэтому все вот это мне нужно точно отнести в левое поддерево,
[01:22:50.740 --> 01:22:56.740]  а здесь высплитить K-root.L.Size-1 элементов.
[01:22:57.740 --> 01:23:03.740]  Вот что мы напишем. Мы напишем, что AB это сплит root.R.
[01:23:03.740 --> 01:23:10.740]  Вот здесь меняется параметр. Здесь будет K-root.L.Size-1.
[01:23:10.740 --> 01:23:15.740]  Потому что смотрите, вот уже столько элементов я уже поместил в левое поддерево.
[01:23:15.740 --> 01:23:20.740]  Я понимаю, что это будет в L, а значит отсюда мне нужно привести только вот столько.
[01:23:20.740 --> 01:23:23.740]  Потому что тогда в сумме они будут давать ровно K.
[01:23:23.740 --> 01:23:33.740]  Ну и тогда я делаю root.R равно A и return root.B.
[01:23:33.740 --> 01:23:39.740]  Я опять переподвешиваю эту штуку сюда. Это будет L, это будет R.
[01:23:39.740 --> 01:23:42.740]  Какое слово основано в K-рекурсии?
[01:23:42.740 --> 01:23:48.740]  То же самое. Если я пытаюсь посплитить пустое дерево,
[01:23:48.740 --> 01:23:51.740]  то нужно вернуть пару пустое дерево, запятая пустое дерево.
[01:23:51.740 --> 01:23:56.740]  То есть если сплитить нечего, то у нас остановка только если одно из деревьев пустое.
[01:23:56.740 --> 01:24:02.740]  Если текущий дерево T пустое, то нужно вернуть на L,P,R.
[01:24:06.740 --> 01:24:09.740]  Ну и тогда что? У нас будет как решать нашу исходную задачу.
[01:24:09.740 --> 01:24:12.740]  Давайте я здесь немножко проговорю быстро.
[01:24:12.740 --> 01:24:15.740]  Как я вот инсерт в данную позицию pos?
[01:24:15.740 --> 01:24:19.740]  Давайте мы запустим split by size pos-1.
[01:24:19.740 --> 01:24:22.740]  И тогда наш исходный массив разведется на два.
[01:24:22.740 --> 01:24:25.740]  Слева будет первый посплитцовый элемент, а справа будут все остальные.
[01:24:25.740 --> 01:24:29.740]  Вот это у меня будет два декартовых дерева, как раз левая половинка, правая половинка.
[01:24:29.740 --> 01:24:33.740]  Я завожу новый элемент вот сюда, вставляю его.
[01:24:33.740 --> 01:24:36.740]  Соответственно у него там новое значение вал, новый приоритет.
[01:24:36.740 --> 01:24:39.740]  Ну там сумма ашек тоже, короче, своя и так далее.
[01:24:39.740 --> 01:24:42.740]  И делаем мерч. Просто мерч этих трех деревьев.
[01:24:42.740 --> 01:24:44.740]  То есть мы смогли вставить в нужную позицию.
[01:24:44.740 --> 01:24:47.740]  Дальше arrays. Если нужно сделать arrays, то мы тоже самое.
[01:24:47.740 --> 01:24:49.740]  Мы посплитили нужным образом.
[01:24:49.740 --> 01:24:52.740]  Потом высплитили опять тот элемент, который нужно удалить.
[01:24:52.740 --> 01:24:53.740]  Вот эта вот апостая.
[01:24:53.740 --> 01:24:55.740]  И склеили два дерева без учета pos.
[01:24:55.740 --> 01:24:58.740]  Но чтобы найти сумму...
[01:24:58.740 --> 01:25:00.740]  Попробуйте уже сами додумать.
[01:25:00.740 --> 01:25:03.740]  Если в каждой вершине поддерживается сумма ашек,
[01:25:03.740 --> 01:25:06.740]  то тогда чтобы найти сумму на отрезке с l по r,
[01:25:06.740 --> 01:25:09.740]  давайте мы высплитим сначала элементы с первого по r.
[01:25:09.740 --> 01:25:13.740]  Потом отсюда, с помощью еще одного split by size,
[01:25:13.740 --> 01:25:15.740]  высплитим отрезок с i по ar.
[01:25:15.740 --> 01:25:19.740]  И с помощью этого дерева будет находиться в точности сумма всего этого под деревом.
[01:25:19.740 --> 01:25:22.740]  Если в каждой вершине хранится сумма ашек под деревом,
[01:25:22.740 --> 01:25:24.740]  то после сплита, после двух сплитов,
[01:25:24.740 --> 01:25:27.740]  у вас будет вершина, целиком отвечающая отрезку l.
[01:25:27.740 --> 01:25:29.740]  Вы знаете на нём сумму.
[01:25:29.740 --> 01:25:30.740]  Печатаете этот ответ.
[01:25:30.740 --> 01:25:32.740]  А дальше обратно всё склеиваете,
[01:25:32.740 --> 01:25:35.740]  так чтобы ваш декартный деревьев был такой, как был изначально.
[01:25:35.740 --> 01:25:36.740]  Вот так всё работает.
[01:25:36.740 --> 01:25:39.740]  То есть с помощью вот такого неявного декартного дерева
[01:25:39.740 --> 01:25:41.740]  или неявного сплея дерева,
[01:25:41.740 --> 01:25:44.740]  любое дерево, которое позволяет делать split и merge,
[01:25:44.740 --> 01:25:45.740]  такие задачи.
[01:25:45.740 --> 01:25:47.740]  По сути, у вас есть динамический массив
[01:25:47.740 --> 01:25:49.740]  со вставками и ударениями в произвольное место.
[01:25:49.740 --> 01:25:52.740]  А также подсчетом каких-то сумм на отрезке и чего-то подобное.
[01:25:54.740 --> 01:25:55.740]  Вот, тогда на сегодня всё.
[01:25:55.740 --> 01:25:56.740]  Спасибо за внимание.
[01:25:56.740 --> 01:25:58.740]  А сумму, кажется, причитываем как-то?
[01:25:58.740 --> 01:25:59.740]  Что-что?
[01:25:59.740 --> 01:26:03.740]  Сумму, кажется, причитываем, когда оставляем новый элемент.
[01:26:03.740 --> 01:26:05.740]  Ну да, на этом просто причитывается.
[01:26:05.740 --> 01:26:08.740]  Просто если аккуратно проследить, что у вас меняется,
[01:26:08.740 --> 01:26:12.740]  у вас по сути просто у вершинки может поменяться там правый сын.
[01:26:12.740 --> 01:26:15.740]  Если был какой-то старый правый сын, не знаю, там alt,
[01:26:15.740 --> 01:26:18.740]  у вас как бы переподвешивание на правого сына,
[01:26:18.740 --> 01:26:19.740]  тогда как меняется сумма?
[01:26:19.740 --> 01:26:21.740]  Ну, у вас левый сын, скажем, остаётся.
[01:26:21.740 --> 01:26:23.740]  Нужно учесть ашку, которая находится в этом элементе,
[01:26:23.740 --> 01:26:25.740]  и прибавить сумму из этого.
[01:26:25.740 --> 01:26:26.740]  То есть там всё просто причитывается.
[01:26:26.740 --> 01:26:27.740]  Если в каждом решении хранить,
[01:26:27.740 --> 01:26:28.740]  понимать, как всё переподвешивается,
[01:26:28.740 --> 01:26:30.740]  в нужном образом нужно просто складывать нужные числа,
[01:26:30.740 --> 01:26:31.740]  и всё получится.
[01:26:34.740 --> 01:26:35.740]  Да, ну вот сумму кратко.
[01:26:35.740 --> 01:26:37.740]  Если я в каждом решении вот это поддерживаю,
[01:26:37.740 --> 01:26:39.740]  сумму ашек в под дереве,
[01:26:39.740 --> 01:26:40.900]  то, звалили ли сюда сумму в под дереве,
[01:26:40.900 --> 01:26:41.900]  conclusions days we have,
[01:26:41.900 --> 01:26:42.900]  а тамerna이나 и oleh?..
[01:26:48.900 --> 01:26:50.900]  Надо просто проследить, что меняется в нашем дереве.
[01:26:50.900 --> 01:26:52.900]  По сути просто какие-то ребра удаляются,
[01:26:52.900 --> 01:26:54.900]  какие-то появляются.
[01:26:54.900 --> 01:26:57.700]  Но если я в каждом поддерervе знаю сумму,
[01:26:57.700 --> 01:26:59.700]  скажем, я знаю сумму здесь, знаю сумму здесь,
[01:26:59.700 --> 01:27:01.700]  и знаю, что あ это ребро удалилось ideology уробило такое.
[01:27:01.700 --> 01:27:05.700]  Значит, сумма в этой верш dugga извинилась на минус вот это
[01:27:05.700 --> 01:27:06.700]  плюс вот это.
[01:27:06.700 --> 01:27:08.700]  books как-то что-то удали until добавилось.
[01:27:08.700 --> 01:27:15.700]  Так, а у вас в SplitBySize просто непременно написано Return Root, он же, как сказать, просто Root.
[01:27:15.700 --> 01:27:17.700]  Сейчас, секунду. Где, где?
[01:27:17.700 --> 01:27:22.700]  Вот у вас там, объясни, просто Root, запятая B, просто это не чей-то должен быть?
[01:27:22.700 --> 01:27:28.700]  Нет, ну как, SplitBySize, это же, не нужно же два, два дерева вернуться.
[01:27:28.700 --> 01:27:32.700]  Левое дерево определяется корнем Root, правое определяется корнем B, вроде все хорошо.
[01:27:32.700 --> 01:27:35.700]  Ну так же, как у нас было в сплите, мы посплитили на два кусочка,
[01:27:35.700 --> 01:27:40.700]  левый кусочек это дерево с корнем Root, а правый кусочек это дерево с корнем B, все хорошо.
[01:27:40.700 --> 01:27:44.700]  SplitBySize он за логарифмом в квадрате работает?
[01:27:44.700 --> 01:27:49.700]  Нет, просто логарифм, это же тоже спуск, это все логарифм, конечно, потому что это просто спуск.
[01:27:49.700 --> 01:27:54.700]  То есть каждый шаг, либо мы вправо спускаемся, либо влево, ну вот влево или вправо,
[01:27:54.700 --> 01:27:59.700]  поэтому суммарное количество запусков, это глубина просто логарифмическая.
