[00:00.000 --> 00:08.160]  Поехали, пришло время концептов.
[00:08.160 --> 00:09.680]  Концепты это невероятно просто.
[00:09.680 --> 00:18.240]  Сейчас, а вот часть, которую мы прошли, это гуд, бетт или агет?
[00:18.240 --> 00:21.040]  Это все пока гуд было.
[00:21.040 --> 00:24.200]  Так.
[00:24.200 --> 00:26.240]  А сейчас бетт, да?
[00:26.240 --> 00:31.760]  Нет, ну бетт, но это аналогия.
[00:31.760 --> 00:35.920]  Вот ключевое слово концепт, оно не отличается от пары ключевых слов
[00:35.920 --> 00:38.920]  constexpr bool, кроме угадайте чего.
[00:38.920 --> 00:45.480]  Да, вот эти две палочки и два амперсандра работают по-другому, единственное отличие между ними.
[00:45.480 --> 00:55.960]  Да, для этого и ввели новое ключевое слово, долгое время даже говорили, зачем новое ключевое слово,
[00:55.960 --> 01:02.040]  давайте просто constexpr bool переменной использовать, все будет хорошо и казалось бы нормально.
[01:02.680 --> 01:13.080]  Но деталечки с тем, что не или не выинстанцируется все, что там в бинарных бульевских операторах,
[01:13.080 --> 01:15.880]  из-за этого пришлось все-таки ввести новое ключевое слово.
[01:15.880 --> 01:18.920]  Ну а зачем это все вообще?
[01:18.920 --> 01:25.160]  Ну принципиально концепты нужны, чтобы выделять какие-то подмножество типов всех.
[01:25.160 --> 01:27.160]  Это предикат на типах.
[01:27.800 --> 01:32.440]  Он говорит нам, какие типы подходят, какие не подходят, какие хорошие, какие плохие.
[01:32.440 --> 01:38.760]  Ну чуть поподробнее об этом будет потом, сейчас наверное просто посмотрим, как это может выглядеть,
[01:38.760 --> 01:40.760]  да вот так может выглядеть.
[01:40.760 --> 01:43.960]  Ну вот типичное определение концепта, оно вот такое.
[01:43.960 --> 01:51.960]  Концепт тыры-пыры равно requires, набор переменных, которые вам нужны и просто вот этот requires expression
[01:51.960 --> 01:53.960]  внутри чет пишете.
[01:54.200 --> 01:59.240]  Ну и все они в принципе дальше будут так выглядеть, мы на них сегодня еще много посмотрим.
[01:59.240 --> 02:07.880]  А на удивление можно концепты определять не только на типах, но и на всяких вот этих дурацких интах,
[02:07.880 --> 02:10.840]  можно на шаблонных-шаблонных аргументах.
[02:10.840 --> 02:12.840]  Какая функция должна быть?
[02:12.840 --> 02:14.840]  Справа?
[02:14.840 --> 02:21.560]  Ну справа может быть, да, вызов context про конставал функции, другой концепт,
[02:21.560 --> 02:26.280]  или там конъюнкция, дизюнкция, еще, да, короче, все что угодно может быть.
[02:26.280 --> 02:33.000]  Да, да, да, это констэкспер булт, вот с этого все началось, то, что справа, строго в компайл тайме вычисляется.
[02:35.000 --> 02:47.160]  Так, да, ну нужно это, чтобы явно, вообще в принципе концепты нужны, чтобы явно имена давать вот этим
[02:47.240 --> 02:51.880]  подмножеством, да, что выделить под множество типов мы могли и раньше каким-нибудь лютым сфенае,
[02:51.880 --> 02:57.720]  но теперь мы можем вот этим вот хорошим набором типов давать какое-то разумное имя.
[02:57.720 --> 03:04.520]  Ну вот subtractible это не очень разумное имя, сразу скажу, но читающему код уже понятно,
[03:04.520 --> 03:12.040]  что вот эта вот функция, она принимает аргументы, которые можно вычитать друг из друга.
[03:12.680 --> 03:19.400]  Ну вот просто из одного слова понятно. Достаточно тривиальный пример, но когда там вот такая функция на 200 строк,
[03:19.400 --> 03:25.480]  достаточно ценно иметь такую вот возможность вместо комментария просто вот симантически,
[03:25.480 --> 03:33.400]  ну, синтаксически обозначить, что имеется в виду. Ну вот сюрприз, можно писать вот так.
[03:34.280 --> 03:38.760]  Ну это неправильно, мы же не из-за убрать, то получается...
[03:38.760 --> 03:44.840]  Ну да, не по-английски получается, но вот так было, да, это мы все видели, это все понятно,
[03:44.840 --> 03:49.960]  просто концепт теперь, но еще ключевое слово концепт отличается тем, что можно делать вот так.
[03:49.960 --> 03:53.720]  Видите, куда он передвинулся, а?
[03:53.720 --> 03:56.440]  Это похоже на джемерики в росте.
[03:56.440 --> 04:03.000]  Ага, нет, ну на самом деле это все берет корни в каких-то старых языках, которые там еще 50 лет назад,
[04:03.000 --> 04:07.720]  вот это все имели и спокойно этим орудовали. Ну вот C++ наконец-то дорос.
[04:11.720 --> 04:16.680]  Ну, очевидно, да, что берется, подставляется it как бы вот туда, и это все одно и то же эквелентно.
[04:16.680 --> 04:26.680]  Знаете, менее очевидные кейсы. Вот концепт constructable from. Тут сразу навалилось, да, там врядик эти,
[04:27.560 --> 04:34.520]  и первое T это что мы пытаемся конструировать. То есть мы проверяем T, и в фигурных скобках написали
[04:34.520 --> 04:40.120]  аргументы типа args. Будет ли конструктор запущен и все сработает или ошибка компиляции.
[04:40.120 --> 04:46.680]  Можно вот так сделать. Понимаете, что тут написано?
[04:46.680 --> 04:56.600]  Нет, нет, нет. Да, здесь написано, можно ли контейнер с конструированной конструкцией.
[04:56.600 --> 05:06.520]  Вот этот контейнер, то, что мы вместо type name теперь пишем концепт, и то, к чему мы это применяем,
[05:06.520 --> 05:12.200]  вот этот контейнер, он всегда первым аргументом подставляется. Остальные аргументы, вы не поверите,
[05:12.200 --> 05:21.480]  карируются. Кто функциональным программированием занимался? Ну, давай не будем об этом говорить.
[05:21.480 --> 05:33.800]  Частичное применение функции. То есть мы фиксируем некоторое количество аргументов и рассматриваем эту
[05:33.800 --> 05:40.320]  функцию как новую функцию от меньшего количества аргументов. В мотоне такое иногда делали, типа
[05:40.320 --> 05:46.120]  давайте вот возьмем нашу многомерную функцию, там палку ставим, и зафиксируем x равно нулю. Теперь
[05:46.120 --> 05:51.360]  это функция одного аргумента y. Вот это как бы есть карирование. И здесь в каком-то смысле вот это
[05:51.360 --> 05:58.120]  вот выражение constructible from vector, оно как бы карирует вот этот вот концепт, и мы получаем как бы
[05:58.120 --> 06:06.240]  новый концепт уже только от одного аргумента, который мы потом подставляем отдельно. Ну, что-то
[06:06.240 --> 06:13.000]  общее есть, но в целом далеко на таком карировании не уедешь. Ну, жалко, но...
[06:13.000 --> 06:23.400]  Ну да, но в плане, когда как бы человек, любящий функциональное программирование,
[06:23.400 --> 06:27.520]  видит карирование, его сознание сразу будоражится, и он хочет какие-нибудь
[06:27.520 --> 06:34.200]  монады выразить через это. Не получится. Ничего не выйдет. Это слишком ограниченная штука. Она сделана
[06:34.200 --> 06:40.200]  исключительно, чтобы проще читать было. Потому что слева направо. В шаблону нужно
[06:40.200 --> 06:47.880]  constructible from vector, контейнер. То есть нужен контейнер, который можно сконструировать от
[06:47.880 --> 06:51.600]  вектора. Ну, на английском нормально читается, на русском у нас другой порядок слов и что-то
[06:51.600 --> 06:59.680]  все ломается. Окей, ну вот такое это преобразуется. Я уже все это проговорил, взглянули, закрепили,
[06:59.680 --> 07:06.200]  пошли дальше. А ну и все, в принципе, про концепты. Вот это все, что они умеют. Какой?
[07:06.200 --> 07:12.440]  Сейчас, у нас же ты говорил, что если у нас два requires вычисляются в true, то это
[07:12.440 --> 07:18.600]  ambiguous call. Но в случае с концептами это не так. Про это будет позже.
[07:18.600 --> 07:35.440]  Я думаю, там все имплисит касты наши любимые. Про то, что int имплисит ли кастец к булу,
[07:35.840 --> 07:45.560]  если ноль, то false. Все это работает. Мне кажется, да. Но проверьте лучше это в Годбалте. Потому
[07:45.560 --> 07:51.960]  что я наизусть как Библию стандарт не учу. И Библию я тоже не учу, если что. Есть люди,
[07:51.960 --> 07:58.480]  которые учат. Но вообще аналогия с церковью хорошая. Вот я как такой дичок из деревни вам,
[07:58.480 --> 08:04.520]  прихожанам проповедую. А есть вот там, где-то вот там вот поп, который вот, а еще выше,
[08:04.520 --> 08:11.920]  там есть вот этот, как это? Кто самый главный у нас в церкви? Патриарх. Вот где-то там есть
[08:11.920 --> 08:18.400]  патриархи, которые сидят на синоде своем и вот разрабатывают эти все вещи. Решают,
[08:18.400 --> 08:26.480]  как правильно интерпретировать Библию. А мы тут так. Где? Что?
[08:26.480 --> 08:41.280]  Я просто пока не до конца рассказал, как работают волшебные две палки и два
[08:41.280 --> 08:45.560]  амперсанда. Они еще более волшебные, чем я сказал. Сейчас будет про них еще,
[08:45.560 --> 08:53.040]  но для начала про более сложное, что можно в Requires Expression еще написать. А внезапно очень
[08:53.040 --> 09:00.720]  много чего можно написать. Такое мы уже видели. Достаточно обыкновенная фигня. Потребовали два
[09:00.720 --> 09:11.200]  две переменные T и U. Причем пафос-то в чем? Это будут универсальные ссылки, как бы в каком-то
[09:11.200 --> 09:17.880]  смысле. Потому что оно работает так же, как у вас работают функции. Если вы вот такой код написали,
[09:17.880 --> 09:27.960]  то это вам гарантирует, что приняв функцию T и U, которые Swappable, вы вот такой код функции
[09:27.960 --> 09:34.080]  напишете, приняв причем по универсальным ссылкам их, вот такой код напишете, он будет работать.
[09:34.080 --> 09:39.400]  Наверное, это даже самый правильный взгляд на Requires Expression.
[09:39.400 --> 09:49.440]  Что? Смотри, про что я говорю. Если ты вот это вот... Смотри, предположим, мы удовлетворили вот
[09:49.440 --> 09:55.680]  этому концепту нашими типами. Тогда если мы вот это все зачеркнем, Requires и концепт, все это
[09:55.680 --> 10:02.080]  зачеркнули и написали здесь просто функция foo, void foo, то это скомпилируется. В этом смысл. Но если
[10:02.080 --> 10:08.800]  здесь уже не вот это вот все, а void foo, то это универсальные ссылки, так? Ну вот. Значит,
[10:08.800 --> 10:13.960]  и в концепте они как бы работают в кавычках как универсальные ссылки. В каком-то смысле. На
[10:13.960 --> 10:19.520]  самом деле это просто обычные R-value ссылки и просто мы их forward'ем. И мы как бы понимаем,
[10:19.520 --> 10:25.960]  что T и U, они вообще-то могут быть сами ссылками, причем L-value. И тогда вот это схлопнется,
[10:25.960 --> 10:37.520]  вот это схлопнется и все как бы как обычно. Короче, да, это универсальные ссылки. Они выводятся,
[10:37.520 --> 10:42.440]  когда ты вот этот концепт функции будешь использовать. Ты же концепты не просто так
[10:42.440 --> 10:48.600]  где-то ставишь, ты пишешь функцию какую-то, которой нужно что-то с чем-то свопнуть. Вот ты в этой
[10:48.600 --> 10:53.400]  функции поставишь концепт swapable, а типы-то выведутся, наверное, в этой функции. И тогда
[10:53.400 --> 11:02.600]  вот они будут как бы универсальными ссылками. В этом смысле. Я чувствую непонимание. Возможно,
[11:02.600 --> 11:08.200]  вам просто надо это на практике потрогать, пописать код, и тогда будет понятней. А мы поедем
[11:08.200 --> 11:14.880]  дальше, потому что вот это все мы видели, а вот это не видели. Можно писать так. Догадайтесь,
[11:14.880 --> 11:26.680]  что это значит. Да, проверка, что следующее выражение называет тип. Вот так вот даже.
[11:26.680 --> 11:32.120]  То есть справа пишется любое выражение, а мы проверяем, что это имя какого-то типа. Ну,
[11:32.120 --> 11:37.760]  заметьте, просто какой-то шаблон инстанцировать тоже можно. А когда вот это вот вообще может быть
[11:37.760 --> 11:52.400]  фолс нижнее. Да, но вот я не уверен, что тогда в этом случае произойдет, потому что у тебя
[11:52.400 --> 12:03.640]  форбрек-декларация все равно будет. Вот статик ассорт, по-моему, вообще тут все сломает,
[12:03.640 --> 12:11.440]  но я не уверен. Вот с этим надо экспериментировать. Вот концептами покрыт, да, а еще с может быть
[12:11.440 --> 12:17.800]  переменной вообще-то. Вы не забывайте, что мы работаем с именами. Это просто какие-то имена.
[12:17.800 --> 12:28.160]  С чего вы взяли, что это вообще тип? С переменная. Нет, просто есть глобальный шаблон переменной,
[12:28.160 --> 12:35.560]  с. У вас концепт проверяет, что в глобальный, в имя глобального шаблона какого-то вот в этот
[12:35.560 --> 12:44.320]  шаблон можно подставить t и получится тип, а мы подставили и получилась переменная. Что?
[12:44.320 --> 12:57.120]  Справа тип, выражение, которое называет тип, то будет фолс и все это вместе будет фолс. Тоже
[12:57.120 --> 13:16.200]  самое с инером. Смотри, да, про то вообще зачем писать концепт, а не просто впендюривать, да,
[13:16.200 --> 13:26.080]  почему бы не впендюрить это все в саму функцию, два раза requires написав. Нет, нет, нет, лучше аналогии
[13:26.080 --> 13:35.360]  есть. Это интерфейсы. Вот ВОП есть интерфейсы, где вы описываете там требования, которые вам
[13:35.360 --> 13:43.600]  позволяют что-то там делать с какими-то объектами. Аналог интерфейсов ВОП для метапроги это концепты,
[13:43.600 --> 13:50.640]  они описывают список требований к типу. Но зачем вообще ВОП интерфейсы? Все же можно по ссылке на
[13:50.640 --> 13:55.680]  объект передать, ну в джаве по крайней мере, да, там любой класс наследует объект, давайте из ДО
[13:55.680 --> 14:01.440]  объекта передавать. Зачем нам интерфейсы? Ну и тут такая же примерная идея, да, зачем нам
[14:01.440 --> 14:08.720]  передавать, зачем нам указывать какие-то концепты требования, когда можно просто как бы любой
[14:08.720 --> 14:14.320]  шаблонный аргумент принять, а дальше уже компилятор разберется, скомпилируется оно или нет. Смысл этого
[14:14.320 --> 14:19.960]  в том, чтобы выделять разумные абстракции, чтобы у человека в голове образовывалась концепция,
[14:19.960 --> 14:26.600]  что есть такое вот понятие как итератор. Некоторые типы являются итераторами, и вот тебе говорят, что это
[14:26.600 --> 14:31.720]  итератор, и сразу понятно как с этим работать, что это значит вообще, что это за тип такой. Это вот
[14:31.720 --> 14:38.360]  абстракция, абстракция выделенная при помощи концепта, ну и много еще таких можно назвать,
[14:38.360 --> 14:42.960]  да, собственно они дальше будут. Мы сейчас будем смотреть концепты стандартной библиотеки, вот там
[14:42.960 --> 14:49.320]  мы увидим кучу уже выделенных абстракций, выделенных в концепты, с которыми удобно работать и
[14:49.320 --> 14:56.960]  мыслить. То есть тут даже цель не как-то механически на уровне языка чего-то добиться, а добиться более
[14:56.960 --> 15:01.640]  плавного взаимодействия кода с вашими мозгами, вот так скажем.
[15:01.640 --> 15:13.640]  Еще такой момент, вспомнил у нас как концептор, вот это не твой ответ, а пока мы здесь, что если мы пишем
[15:13.640 --> 15:26.440]  функцию, у которой вариантик шаблон, и делаем там концепт, ну то есть концепт фу какой-то есть у нас
[15:26.440 --> 15:35.560]  функция, сигнатура там плей, многоточие, full types, если мы хотим несколько таких имен написать, то концепты не вкладываются друг
[15:35.560 --> 15:45.200]  друга, даже если они более строгие. Многоточие ломает перегрузку по более строгим. Я еще не рассказал про
[15:45.200 --> 15:50.000]  перегрузку по более строгим концептам, а ты уже лезешь вперед, но это да, вот ровно то, что там
[15:50.000 --> 15:57.360]  Андрей приходил, говорил, да, я вспомнил теперь о чем он там маялся, давай не будем пока про это, никто
[15:57.360 --> 16:03.920]  ничего не понял же, ну и нормально, сейчас все будет. Так, про type name все поняли, просто можно проверить,
[16:03.920 --> 16:09.360]  тип это или не тип, да, последнее, что я говорил, а меня прервали, inner тоже может быть переменной,
[16:09.360 --> 16:16.520]  да, а может быть функций, а мы хотим, чтобы именно тип был, а можно вот так еще писать, вот это самые
[16:16.520 --> 16:28.080]  забавные мощные синтаксис. То есть мы в фигурных скобках пишем некоторое выражение, которое может
[16:28.080 --> 16:37.080]  вернуть какой-то тип, вот у этого выражения есть тип, да, и после стрелочки мы пишем другой концепт
[16:37.080 --> 16:48.520]  и говорим, что тип, который вернула это выражение, он должен удовлетворять вот тому концепту, то есть здесь
[16:48.520 --> 16:56.440]  написано, хэша т объект создали, вызвали от а, в итоге должны получить что-то, что convertible2 size t,
[16:56.440 --> 17:01.960]  ну что такое концепт convertible2, я думаю, интуитивно, понятно, пока детали не нужны.
[17:01.960 --> 17:14.160]  Окей, да, что-то тут выделяю, можно вот так, то есть не суть важна, что угодно пишете и круто, вопрос,
[17:14.160 --> 17:21.560]  тоже ли это самое, что вот так вот ручками взять и расписать, мнение да.
[17:21.560 --> 17:37.760]  Я тоже думал, что здесь есть подвох, но раз за разом убеждаюсь, что его нету, хотя это могут быть баги в компиляторах,
[17:37.760 --> 17:45.280]  но в общем и целом кажется это одно и то же, просто вот здесь очень чистенько, очень понятненько, ну и тут у вас может
[17:45.280 --> 17:52.680]  быть список и будет список из там пяти разных выражений и как-то видно, вот это написали, получили это, это написали, получили это,
[17:52.680 --> 18:02.280]  а здесь какой-то ужас, и все это вот какими-то словами непонятными разбавлено, какие-то деколвалы, деколтайпы,
[18:02.280 --> 18:04.680]  но если вы...
[18:04.680 --> 18:09.280]  Сейчас нельзя ли тогда написать компактные типа low-crizal какие-нибудь?
[18:09.280 --> 18:17.480]  Да можно, но все равно это менее удобно, чем вот это, но в целом, если вам не нравится так, можете писать так, я не буду изникать.
[18:17.480 --> 18:19.480]  А это еще не скомпилируется я себе?
[18:19.480 --> 18:25.280]  Скомпилируется, в том-то и прикол, все, что справа от концепта, оно работает опять же волшебным образом,
[18:25.280 --> 18:32.480]  и если где-то что-то произошла ошибка, оно на самом деле false сделает, но я не уверен, что так задумано стандартом,
[18:32.680 --> 18:40.680]  местами мне кажется, что должна быть все-таки ошибка компиляции, но на моем опыте все компиляторы просто false в концепт возвращают, и все.
[18:40.680 --> 18:47.680]  То есть вот тут, конечно, надо перепроверить 10 раз, но лучше с реальностью мириться,
[18:47.680 --> 18:53.680]  все компиляторы, что я пробовал, просто делают false, какая бы здесь ошибка не происходила, и чтобы вообще не было написано.
[18:53.680 --> 18:56.680]  Но он репортит, что именно пошло не так?
[18:56.880 --> 18:59.880]  Ну да, возвращает false, но репортит.
[18:59.880 --> 19:04.880]  Ну да, репорты, вот здесь, репорты самое важное, когда вы используете вот эту машинерию,
[19:04.880 --> 19:11.880]  у вас будут очень понятные репорты, вам напишут, вот в этой строчке вот это выражение вернуло такой тип,
[19:11.880 --> 19:15.880]  вы потребовали, чтобы он был секой, а у него не хватает вот этого и вот этого.
[19:15.880 --> 19:22.880]  То есть тут максимально красивые будут сообщения об ошибках, а вот здесь вы получите, я не спок.
[19:23.080 --> 19:26.080]  Evoluted to false, sorry.
[19:26.080 --> 19:29.080]  Потому что для компилятора это все прозрачно.
[19:29.080 --> 19:32.080]  Какие-то шаблоны друг друга подставляют.
[19:36.080 --> 19:42.080]  Ну same as, evaluated to false, because, ну вообще зависит от компилятора.
[19:42.280 --> 19:49.280]  Скорее всего он скажет, что есть вот этот тип, где компилятор, скажет, что он просто не SST.
[19:49.280 --> 19:57.280]  Ну я говорю, зависит, да, зависит от крутости компилятора, потому что частенько и то и другое одно и то же дает.
[19:57.280 --> 20:03.280]  Но мне кажется, задумка всего этого в целом была в первую очередь сделать более удобную жизнь компиляторам,
[20:03.280 --> 20:06.280]  ну и пользователям, писать проще, читать проще ошибки.
[20:06.280 --> 20:09.280]  Ну есть бонус небольшой.
[20:09.480 --> 20:12.480]  Я сомневаюсь, что только из этого бонуса добавили эту фичу, но он есть.
[20:12.480 --> 20:19.480]  Вы можете написать noexcept после фигурных скобок, и компилятор еще и проверит вам, что вся эта фигня в скобках noexcept.
[20:19.480 --> 20:23.480]  Можно написать noexcept, констрация.
[20:23.480 --> 20:26.480]  Да.
[20:26.480 --> 20:29.480]  Вопрос какой-то.
[20:29.480 --> 20:36.480]  То есть получается у нас, я просто удивлен, вот эти вот фигурные скобки, которые окружают какой-то expression,
[20:36.680 --> 20:39.680]  это нововведение 20 плюсов тоже, правильно?
[20:39.680 --> 20:41.680]  Да, и только внутри requires, может.
[20:41.680 --> 20:43.680]  А как это называется?
[20:43.680 --> 20:57.680]  Вот этого, ой, что-то типа complex или compound, compound requires expression, что-то такое.
[20:57.680 --> 21:05.680]  Ну, в том, что вот этот синтез, ну короче, это все нововведение, все сейчас, что мы смотрим, это 20-ые плюсы.
[21:05.880 --> 21:07.880]  Ну да, у этого всего есть какие-то названия умные.
[21:07.880 --> 21:09.880]  Ты посмотри это на cpp-reference лучше.
[21:09.880 --> 21:14.880]  Просто я чему-то прошу, чуть-чуть чужерогому кажется это плюсов.
[21:14.880 --> 21:16.880]  Да, да.
[21:16.880 --> 21:23.880]  Да, мне тоже кажется, что вот этот весь синтаксис, он как-то, ну, нигде в других местах в плюсах вот такого синтаксиса не встречается,
[21:23.880 --> 21:26.880]  что в фигурных скобках выражение и стрелочка потом.
[21:26.880 --> 21:28.880]  Но вот так решили.
[21:28.880 --> 21:30.880]  Возможно, это заделка на будущее какое-то.
[21:30.880 --> 21:32.880]  Ну, посмотрим.
[21:32.880 --> 21:34.880]  Вот, можно вообще без стрелки.
[21:35.080 --> 21:37.080]  Просто в фигурных скобках что-то noexcept.
[21:37.080 --> 21:38.080]  И оно проверит.
[21:38.080 --> 21:40.080]  Это должно быть noexcept.
[21:40.080 --> 21:45.080]  Проверяет, что тип вот этого выражения удовлетворяет концепту.
[21:45.080 --> 21:49.080]  Ну, причем сюда оно подставляет его первым аргументом.
[21:49.080 --> 21:51.080]  Такое же карирование происходит, да, как и раньше.
[21:51.080 --> 21:53.080]  Чего?
[21:53.080 --> 21:55.080]  Наличие атрибутов.
[21:55.080 --> 21:57.080]  Наличие атрибутов?
[21:57.080 --> 21:59.080]  Нет.
[21:59.080 --> 22:02.080]  Ну, атрибуты, это которые в двух квадратных скобках.
[22:02.280 --> 22:04.280]  Нет, они не являются частью языка
[22:04.280 --> 22:06.280]  и могут безопасно игнорироваться,
[22:06.280 --> 22:08.280]  как бы, абстрактные машины.
[22:08.280 --> 22:10.280]  Муть.
[22:10.280 --> 22:12.280]  Можно нет шаблонные концепты?
[22:12.280 --> 22:14.280]  Нет, концепт, только шаблонные.
[22:18.280 --> 22:20.280]  Здесь есть какой-то слайд.
[22:22.280 --> 22:24.280]  А, да.
[22:24.280 --> 22:26.280]  На слайде загадочное выделение.
[22:26.280 --> 22:28.280]  Я не понимаю, что значит это выделение,
[22:28.280 --> 22:30.280]  но это еще одна штука,
[22:30.280 --> 22:32.280]  которую можно написать
[22:32.280 --> 22:34.280]  в requires expression.
[22:34.280 --> 22:36.280]  Видите?
[22:36.280 --> 22:38.280]  Второй раз requires написан.
[22:38.280 --> 22:40.280]  И requires, и дальше какой-то концепт.
[22:40.280 --> 22:42.280]  Ну, или более вообще, какой-то буль,
[22:42.280 --> 22:44.280]  наверное, тоже можно.
[22:44.280 --> 22:46.280]  Ну, это по референсу только такой пример.
[22:46.280 --> 22:48.280]  Ну, что это значит?
[22:48.280 --> 22:50.280]  Ну, это то же самое, что
[22:50.280 --> 22:52.280]  через два амперсанды еще раз написать
[22:52.280 --> 22:54.280]  same test звездочка и вот это вот.
[22:54.280 --> 22:56.280]  Ага.
[22:56.280 --> 22:58.280]  Выделение, наверное, про то, что в второй строке
[22:58.280 --> 23:00.280]  еще требовали концепт.
[23:04.280 --> 23:06.280]  Ну, да, да.
[23:06.280 --> 23:08.280]  Здесь не явно накладывается еще одно требование,
[23:08.280 --> 23:10.280]  что вот это вот newt скомпилируется.
[23:10.280 --> 23:12.280]  Но как бы
[23:12.280 --> 23:14.280]  хотелось сказать, что оно не накладывается,
[23:14.280 --> 23:16.280]  если мы снаружи это напишем
[23:16.280 --> 23:18.280]  через два амперсанды, но на самом деле
[23:18.280 --> 23:20.280]  тоже накладывается.
[23:20.280 --> 23:22.280]  Поэтому вот тут какой-то тонкий момент.
[23:22.280 --> 23:24.280]  Ну, то же самое, что два амперсанды,
[23:24.280 --> 23:26.280]  просто можно вот так писать. Зачем?
[23:26.280 --> 23:28.280]  Читайте, зачем это
[23:28.280 --> 23:30.280]  заключается от запися без requires?
[23:30.280 --> 23:32.280]  Нет, если ты просто вот такую запись делаешь,
[23:32.280 --> 23:34.280]  то это будет очень плохо.
[23:34.280 --> 23:36.280]  Потому что это самый распространенный
[23:36.280 --> 23:38.280]  источник ошибок, когда ты пишешь
[23:38.280 --> 23:40.280]  концепты. Вот без ключевого
[23:40.280 --> 23:42.280]  слова requires ты просто потребуешь,
[23:42.280 --> 23:44.280]  что инстанцировать
[23:44.280 --> 23:46.280]  концепт можно.
[23:46.280 --> 23:48.280]  А концепт всегда можно
[23:48.280 --> 23:50.280]  инстанцировать. Просто
[23:50.280 --> 23:52.280]  может быть true, может быть false.
[23:52.280 --> 23:54.280]  Но инстанцировать можно всегда.
[23:54.280 --> 23:56.280]  Просто написать такую строку
[23:56.280 --> 23:58.280]  это все равно, что ничего не написать.
[23:58.280 --> 24:00.280]  Ну или грубо говоря,
[24:00.280 --> 24:02.280]  это то же самое, что написать только
[24:02.280 --> 24:04.280]  newt. Вот так вот.
[24:04.280 --> 24:06.280]  А вот здесь именно требуется, что и вот это
[24:06.280 --> 24:08.280]  все инстанцировалось нормально,
[24:08.280 --> 24:10.280]  и вернуло true.
[24:10.280 --> 24:12.280]  То есть если вы вот с таким
[24:12.280 --> 24:14.280]  синтаксисом забудете где requires написать,
[24:14.280 --> 24:16.280]  то это баг, и у вас все будет
[24:16.280 --> 24:18.280]  плохо. Ну, то есть
[24:18.280 --> 24:20.280]  мне кажется, стоило бы оставить это
[24:20.280 --> 24:22.280]  через два амперсанды, а не добавлять вообще такой
[24:22.280 --> 24:24.280]  синтаксис, потому что, ну реально, очередная
[24:24.280 --> 24:26.280]  пушка, направленная нам на ноги,
[24:26.280 --> 24:28.280]  спасибо, блин.
[24:28.280 --> 24:30.280]  Ну, есть так есть.
[24:30.280 --> 24:32.280]  А...
[24:32.280 --> 24:34.280]  Да, да, да, да, да, да.
[24:34.280 --> 24:36.280]  Ну нужно как-то вот себя в тонусе
[24:36.280 --> 24:38.280]  держать так, уф.
[24:42.280 --> 24:44.280]  Это некрасиво выглядит, когда мы пишем
[24:44.280 --> 24:46.280]  много для них амперсандов.
[24:46.280 --> 24:48.280]  Если нам нужно,
[24:48.280 --> 24:50.280]  чтобы requires...
[24:50.280 --> 24:52.280]  Но вообще,
[24:52.280 --> 24:54.280]  это может быть, наверное, тем
[24:54.280 --> 24:56.280]  удобно, чтобы пусть мы пишем
[24:56.280 --> 24:58.280]  в requires
[24:58.280 --> 25:00.280]  какой-то список методов
[25:00.280 --> 25:02.280]  и...
[25:02.280 --> 25:04.280]  Ну, блин, это было бы странно,
[25:04.280 --> 25:06.280]  если бы мы где-то в середине хотели бы
[25:06.280 --> 25:08.280]  проверить...
[25:08.280 --> 25:10.280]  Ну, бывает. Видимо, для этого и добавили.
[25:10.280 --> 25:12.280]  Ну, просто для красоты. Так удобно.
[25:12.280 --> 25:14.280]  Один requires пишешь, и туда все пихаешь, и...
[25:14.280 --> 25:16.280]  Вот, мы пока на слайд
[25:16.280 --> 25:18.280]  смотрим, да?
[25:20.280 --> 25:22.280]  Что, вы как думаете, здесь происходит?
[25:24.280 --> 25:26.280]  Ин звездочка ноль,
[25:26.280 --> 25:28.280]  это 0ptr или что?
[25:28.280 --> 25:30.280]  Ну, да.
[25:30.280 --> 25:32.280]  Я просто хотел, чтобы это был
[25:32.280 --> 25:34.280]  не 0ptrt тип, а именно
[25:34.280 --> 25:36.280]  ин звездочка тип.
[25:38.280 --> 25:40.280]  Ну, что?
[25:40.280 --> 25:42.280]  Что скажете
[25:42.280 --> 25:44.280]  об этом коде?
[25:44.280 --> 25:46.280]  Что?
[25:46.280 --> 25:48.280]  Про более частая
[25:48.280 --> 25:50.280]  скомпилируется.
[25:50.280 --> 25:52.280]  Ну, да, код скомпилируется. Что в первом случае
[25:52.280 --> 25:54.280]  будет вызвано? Первая
[25:54.280 --> 25:56.280]  F или вторая?
[25:56.280 --> 25:58.280]  Первая.
[25:58.280 --> 26:00.280]  Почему?
[26:02.280 --> 26:04.280]  Окей, а во втором случае что будет вызвано?
[26:06.280 --> 26:08.280]  А почему?
[26:10.280 --> 26:12.280]  Да, да.
[26:12.280 --> 26:14.280]  То есть, если мы пишем requires внутри,
[26:14.280 --> 26:16.280]  то у нас нет такого наследования?
[26:16.280 --> 26:18.280]  Или оно включено?
[26:18.280 --> 26:20.280]  Нет, все есть.
[26:20.280 --> 26:22.280]  Смотри, два амперсанда
[26:22.280 --> 26:24.280]  в requires просто здесь
[26:24.280 --> 26:26.280]  или вот здесь и в концепте,
[26:26.280 --> 26:28.280]  они одинаково работают.
[26:28.280 --> 26:30.280]  Для этого нужно ключевое слово концепт, чтобы везде все одинаково работало.
[26:30.280 --> 26:32.280]  Нет, я про то, что мы можем
[26:32.280 --> 26:34.280]  написать то же самое, что requires t
[26:34.280 --> 26:36.280]  большой от маленькой,
[26:36.280 --> 26:38.280]  а внутри, кстати, require, например,
[26:38.280 --> 26:40.280]  от t. И в таком случае будет происходить
[26:40.280 --> 26:42.280]  концепция.
[26:42.280 --> 26:44.280]  О, как же ты прав.
[26:44.280 --> 26:46.280]  Действительно.
[26:46.280 --> 26:48.280]  Да, видимо, тот синтаксис
[26:48.280 --> 26:50.280]  нужен, чтобы запретить вот это.
[26:50.280 --> 26:52.280]  Гениально.
[26:52.280 --> 26:54.280]  Нет, эта мысль
[26:54.280 --> 26:56.280]  неважная. Давайте сначала разберемся
[26:56.280 --> 26:58.280]  с тем, что вот здесь происходит, а потом к ней вернемся.
[27:00.280 --> 27:02.280]  Вот, что значит более частное?
[27:02.280 --> 27:04.280]  Так, ребят,
[27:04.280 --> 27:06.280]  если у вас вопрос, давайте задавать. Нет? Все.
[27:06.280 --> 27:08.280]  Более частное. Ну, тут как бы
[27:08.280 --> 27:10.280]  интуитивно видно, что если что-то
[27:10.280 --> 27:12.280]  rev итератор, то оно автоматом
[27:12.280 --> 27:14.280]  decrementable. Так?
[27:14.280 --> 27:16.280]  Есть импликация.
[27:16.280 --> 27:18.280]  Ну, и когда у нас
[27:18.280 --> 27:20.280]  как бы
[27:20.280 --> 27:22.280]  эта импликация есть,
[27:22.280 --> 27:24.280]  она и распространяется на вызовы вот этих функций.
[27:24.280 --> 27:26.280]  То есть любой тип, для которого можно
[27:26.280 --> 27:28.280]  вызвать что-то от rev итератора,
[27:28.280 --> 27:30.280]  то есть нижнее,
[27:32.280 --> 27:34.280]  если нижнюю f можно вызвать для t,
[27:34.280 --> 27:36.280]  то верхнюю тоже можно. Верно?
[27:36.280 --> 27:38.280]  А вот если верхнюю
[27:38.280 --> 27:40.280]  можно вызвать, это не значит, что можно
[27:40.280 --> 27:42.280]  нижнюю. То есть если нам
[27:42.280 --> 27:44.280]  пришел какой-то тип, который приходит в обе,
[27:44.280 --> 27:46.280]  наверное, лучше нижнюю запустить,
[27:46.280 --> 27:48.280]  потому что она более частная, она больше
[27:48.280 --> 27:50.280]  требований накладывает.
[27:50.280 --> 27:52.280]  Ага.
[27:52.280 --> 27:54.280]  Да.
[28:00.280 --> 28:02.280]  Не будет работать.
[28:02.280 --> 28:04.280]  Вот.
[28:06.280 --> 28:08.280]  Давайте посмотрим
[28:08.280 --> 28:10.280]  сюда.
[28:12.280 --> 28:14.280]  Констраинты влияют
[28:14.280 --> 28:16.280]  на overload resolution. Про это мы
[28:16.280 --> 28:18.280]  не говорили еще.
[28:18.280 --> 28:20.280]  Помните три этапа того, как мы функцию
[28:20.280 --> 28:22.280]  ищем? Там было
[28:22.280 --> 28:24.280]  составление всего множества имен,
[28:24.280 --> 28:26.280]  потом инстанциация всех шаблонов
[28:26.280 --> 28:28.280]  в нем, а потом overload
[28:28.280 --> 28:30.280]  resolution. Вот с 20 плюсами
[28:30.280 --> 28:32.280]  второй шаг поменялся. У нас там
[28:32.280 --> 28:34.280]  констраинты проверяются. Поменялся
[28:34.280 --> 28:36.280]  теперь и третий шаг. Из всех
[28:36.280 --> 28:38.280]  шаблонов, для которых констраинты
[28:38.280 --> 28:40.280]  прошли, нужно выбрать самый
[28:40.280 --> 28:42.280]  подходящий.
[28:42.280 --> 28:44.280]  Внезапно. То есть вот здесь
[28:44.280 --> 28:46.280]  в случае второго вызова
[28:46.280 --> 28:48.280]  оба этих имени,
[28:48.280 --> 28:50.280]  оба этих шаблонов
[28:50.280 --> 28:52.280]  функции, они будут найдены,
[28:52.280 --> 28:54.280]  оба они пройдут инстанциацию
[28:54.280 --> 28:56.280]  успешно, проверку констраинтов
[28:56.280 --> 28:58.280]  оба тоже пройдут, и оба
[28:58.280 --> 29:00.280]  попадут в итоговый overload set.
[29:00.280 --> 29:02.280]  Множество перегрузок.
[29:02.280 --> 29:04.280]  Надо выбрать в этом множестве
[29:04.280 --> 29:06.280]  перегрузок наиболее подходящую
[29:06.280 --> 29:08.280]  функцию. Без
[29:08.280 --> 29:10.280]  каких-то изменений
[29:10.280 --> 29:12.280]  не обойтись. Изменение следующее
[29:12.280 --> 29:14.280]  ввели. По импликации
[29:14.280 --> 29:16.280]  между
[29:16.280 --> 29:18.280]  атомами,
[29:18.280 --> 29:20.280]  который
[29:20.280 --> 29:22.280]  матлок атомы,
[29:22.280 --> 29:24.280]  строится граф.
[29:24.280 --> 29:26.280]  И в этом графе выбирается наименьшая
[29:26.280 --> 29:28.280]  перегрузка.
[29:28.280 --> 29:30.280]  Вот здесь сейчас все слова важны.
[29:30.280 --> 29:32.280]  Все слова важны, потому что
[29:34.280 --> 29:36.280]  частичный порядок строится
[29:36.280 --> 29:38.280]  по импликации на атомах,
[29:38.280 --> 29:40.280]  где атомам считается
[29:40.280 --> 29:42.280]  выражение, написанное в коде,
[29:42.280 --> 29:44.280]  в том месте, где оно написано.
[29:46.280 --> 29:48.280]  А вершины этого
[29:48.280 --> 29:50.280]  графа импликаций...
[29:50.280 --> 29:52.280]  Хорошо.
[29:52.280 --> 29:54.280]  Вершины это функции.
[29:54.280 --> 29:56.280]  Overload set
[29:56.280 --> 29:58.280]  это вершины графа.
[29:58.280 --> 30:00.280]  Мы строим ребра. Где мы строим ребра?
[30:00.280 --> 30:02.280]  Где мы можем доказать, что есть
[30:02.280 --> 30:04.280]  импликация между
[30:04.280 --> 30:06.280]  констраинтами?
[30:06.280 --> 30:08.280]  Концептом и внутри концепта
[30:08.280 --> 30:10.280]  к этимологическим операциям?
[30:10.280 --> 30:12.280]  Да.
[30:12.280 --> 30:14.280]  Да.
[30:14.280 --> 30:16.280]  Мы как бы работаем здесь
[30:16.280 --> 30:18.280]  на уровне исчисления высказываний,
[30:18.280 --> 30:20.280]  не предикатов.
[30:20.280 --> 30:22.280]  Поняли, что я сказал?
[30:22.280 --> 30:24.280]  Мы
[30:24.280 --> 30:26.280]  не залезаем внутрь вот этих элементарных
[30:26.280 --> 30:28.280]  термов, вот этих атомов.
[30:28.280 --> 30:30.280]  Внутри requires expression. Мы работаем
[30:30.280 --> 30:32.280]  с ними как вот просто символ.
[30:32.280 --> 30:34.280]  Символ исчисления высказываний.
[30:36.280 --> 30:38.280]  Ищем импликации.
[30:38.280 --> 30:40.280]  И вот здесь, если вы там
[30:40.280 --> 30:42.280]  распишете на бумажке, обозначив
[30:42.280 --> 30:44.280]  вот этот терм за символ
[30:44.280 --> 30:46.280]  A, а вот тот терм
[30:46.280 --> 30:48.280]  requires... за символ
[30:48.280 --> 30:50.280]  B, и посмотрите,
[30:50.280 --> 30:52.280]  общезначим или формула
[30:52.280 --> 30:54.280]  re-iterator, стрелка,
[30:54.280 --> 30:56.280]  decrementable. Вы обнаружите,
[30:56.280 --> 30:58.280]  что да, она общезначима.
[30:58.280 --> 31:00.280]  Я бы даже, наверное, написал,
[31:00.280 --> 31:02.280]  но я не знаю. Вот тут какие-то
[31:02.280 --> 31:04.280]  доски, наверное, ничего не выйдет.
[31:04.280 --> 31:06.280]  Да.
[31:06.280 --> 31:08.280]  Проверка импликации исчисления
[31:08.280 --> 31:10.280]  высказываний, она
[31:10.280 --> 31:12.280]  сильно дешевле, чем там проверка.
[31:12.280 --> 31:14.280]  Ну, она вычислима хотя бы. Этому
[31:14.280 --> 31:16.280]  уже радуйся. Ну, ладно,
[31:16.280 --> 31:18.280]  это не особо быстро. Это там...
[31:18.280 --> 31:20.280]  Это экспоненциально.
[31:20.280 --> 31:22.280]  Да, да. Ну, давайте, кто
[31:22.280 --> 31:24.280]  будет хорошо там теорию сложностей
[31:24.280 --> 31:26.280]  вычислений, вот за сколько проверяется
[31:26.280 --> 31:28.280]  SAT-задача? Это задача
[31:28.280 --> 31:30.280]  SAT, да? Нам нужно проверить
[31:30.280 --> 31:32.280]  общезначимость формулы. Сейчас я даже
[31:32.280 --> 31:34.280]  ее напишу.
[31:34.280 --> 31:36.280]  Сад?
[31:36.280 --> 31:38.280]  Ну,
[31:38.280 --> 31:40.280]  3SAT это же...
[31:40.280 --> 31:42.280]  3SAT быстро вроде, да?
[31:42.280 --> 31:44.280]  3SAT это
[31:44.280 --> 31:46.280]  NP полное значение. 3SAT это NP
[31:46.280 --> 31:48.280]  полное, а 2SAT, по-моему, P.
[31:48.280 --> 31:50.280]  Вот. Ну, короче, мы NP
[31:50.280 --> 31:52.280]  полную задачу решаем. Давайте я нарисую.
[31:56.280 --> 31:58.280]  Ну, SAT-солвер
[31:58.280 --> 32:00.280]  в компиляторе
[32:00.280 --> 32:02.280]  теперь есть. Вот это символ
[32:02.280 --> 32:04.280]  A.
[32:04.280 --> 32:06.280]  Вот это символ
[32:10.280 --> 32:12.280]  Вот это символ B.
[32:12.280 --> 32:14.280]  Мы хотим проверить.
[32:14.280 --> 32:16.280]  Сейчас.
[32:18.280 --> 32:20.280]  Да, давайте вот это за D
[32:20.280 --> 32:22.280]  обозначим, вот это за R обозначим.
[32:22.280 --> 32:24.280]  Ага.
[32:28.280 --> 32:30.280]  Нет, сюда
[32:30.280 --> 32:32.280]  подставится вот это вот сам... Вот это будет D.
[32:32.280 --> 32:34.280]  Вот это как
[32:34.280 --> 32:36.280]  бы будет D, да?
[32:36.280 --> 32:38.280]  Вот эти вот они как раз совпадают за счет
[32:38.280 --> 32:40.280]  того, что мы здесь использовали еще раз
[32:40.280 --> 32:42.280]  концепт, они заново написали
[32:42.280 --> 32:44.280]  терм, они как бы
[32:44.280 --> 32:46.280]  один и тот же символ.
[32:46.280 --> 32:48.280]  Если бы мы заново написали вот это выражение,
[32:48.280 --> 32:50.280]  то ничего бы не сработало. Ага.
[32:50.280 --> 32:52.280]  И что мы проверять хотим?
[32:52.280 --> 32:54.280]  Мы хотим проверить импликацию вот в эту сторону.
[32:54.280 --> 32:56.280]  Видите в какую?
[32:56.280 --> 32:58.280]  Ну, как эта импликация
[32:58.280 --> 33:00.280]  будет выглядеть? R стрелка D.
[33:02.280 --> 33:04.280]  Раскрываем определение R.
[33:04.280 --> 33:06.280]  Это D и
[33:06.280 --> 33:08.280]  B.
[33:08.280 --> 33:10.280]  Стрелка
[33:10.280 --> 33:12.280]  D.
[33:12.280 --> 33:14.280]  Стрелка D.
[33:14.280 --> 33:16.280]  Ага.
[33:16.280 --> 33:18.280]  Ну, это общезначимая формула.
[33:18.280 --> 33:20.280]  Доказали.
[33:20.280 --> 33:22.280]  Ну так, Сёма даже.
[33:22.280 --> 33:24.280]  Да, теперь
[33:24.280 --> 33:26.280]  надо вычислять экспедиционную штуку
[33:26.280 --> 33:28.280]  во время overload resolution функций.
[33:28.280 --> 33:30.280]  Да, все компиляторы
[33:30.280 --> 33:32.280]  теперь так делают.
[33:32.280 --> 33:34.280]  Ну так.
[33:34.280 --> 33:36.280]  Да нет, просто не пиши дурацкий код,
[33:36.280 --> 33:38.280]  а все нормально будет.
[33:38.280 --> 33:40.280]  Ну, вообще, да,
[33:40.280 --> 33:42.280]  а что вас смущает
[33:42.280 --> 33:44.280]  то, собственно, у вас NP
[33:44.280 --> 33:46.280]  полный язык шаблонов есть
[33:46.280 --> 33:48.280]  во время компиляции, как вот тут люди говорят.
[33:48.280 --> 33:50.280]  Вы можете свой сад
[33:50.280 --> 33:52.280]  solver на нем написать.
[33:52.280 --> 33:54.280]  Никто не запретит. Теперь он
[33:54.280 --> 33:56.280]  стройный есть. Ну, неплохо.
[33:56.280 --> 33:58.280]  Чего?
[33:58.280 --> 34:00.280]  Ну,
[34:00.280 --> 34:02.280]  ну,
[34:02.280 --> 34:04.280]  ну,
[34:04.280 --> 34:06.280]  ну,
[34:06.280 --> 34:08.280]  Ну,
[34:08.280 --> 34:10.280]  ну,
[34:22.280 --> 34:24.280]  ну,
[34:24.280 --> 34:26.280]  ну,
[34:26.280 --> 34:28.280]  ну,
[34:28.280 --> 34:30.280]  ну,
[34:30.280 --> 34:32.280]  ну,
[34:32.280 --> 34:34.280]  ну,
[34:34.280 --> 34:36.280]  Это в тех местах, где...
[34:38.080 --> 34:40.080]  Короче, там нормально всё.
[34:40.200 --> 34:43.200]  Я не могу это срагументированно объяснить.
[34:43.840 --> 34:47.360]  Эмпирически было выяснено, что это не так больно, как кажется,
[34:47.440 --> 34:49.280]  не так долго, как кажется,
[34:49.360 --> 34:51.600]  если вы, конечно, целенаправленно не будете писать
[34:51.680 --> 34:54.560]  какой-то супердурадский код с супердурадскими хаками,
[34:54.640 --> 34:56.360]  где суперогромный граф.
[34:56.440 --> 35:00.160]  Может, там какие-то обвенчания на более уфоро, которые придут в концепцию?
[35:01.480 --> 35:04.000]  По-моему, там никаких ограничений нет.
[35:04.320 --> 35:06.320]  А если это был пустырад?
[35:07.720 --> 35:09.400]  Нет, просто вот надо проверить.
[35:09.480 --> 35:12.440]  Любое... Восчленение высказываний формулы,
[35:12.520 --> 35:14.520]  надо проверить, что вообще значимое, да, и решаем сад.
[35:14.600 --> 35:16.000]  Ну, что поделать?
[35:16.080 --> 35:21.240]  Это всё равно быстро, потому что у вас максимум 100, наверное, функций.
[35:21.320 --> 35:24.320]  Нет, ладно, бывают и по тысяче функций в оверлот-сете.
[35:25.120 --> 35:25.920]  Нет, не так.
[35:26.000 --> 35:29.200]  Проблема в том, что у вас концептов столько не наберётся разумных.
[35:30.120 --> 35:32.520]  Вот максимальная цепочка концептов по включению,
[35:32.520 --> 35:36.320]  которую мы сможем найти, наверное, будет где-то 10.
[35:37.160 --> 35:38.600]  А то и меньше.
[35:38.680 --> 35:42.520]  И там достаточно быстро можно выяснить, кто в кого включается.
[35:42.600 --> 35:44.680]  Потому что они все выглядят одинаково.
[35:44.760 --> 35:49.560]  То есть никто не пишет сверхдурадские выражения в концептах, да?
[35:49.640 --> 35:53.560]  Пишут в основном только амперсанды или редко бывает.
[35:54.160 --> 35:56.720]  Поэтому в целом это не страшно.
[35:56.800 --> 35:58.520]  Но это очередная пушка вам на ногу.
[35:58.600 --> 36:00.800]  Да, вы можете взять и с лёгкостью написать код,
[36:00.800 --> 36:02.640]  который там положит компилятор.
[36:05.680 --> 36:06.680]  Прикол.
[36:08.360 --> 36:09.160]  Опасно.
[36:09.240 --> 36:10.480]  Всё, давайте пойдём дальше.
[36:10.560 --> 36:14.360]  Я надеюсь, вы про этого поняли, что тут с перегрузками всякая магия происходит.
[36:14.440 --> 36:17.400]  Вы идёте в какую версию функций этой каждой?
[36:17.480 --> 36:20.640]  А, да, мы же выяснили.
[36:23.480 --> 36:29.240]  Ой, мы выяснили, что здесь есть импликация.
[36:29.320 --> 36:30.320]  Она прошла.
[36:31.080 --> 36:34.800]  А из верхней F следует нижняя.
[36:35.880 --> 36:37.160]  По-моему, мы так доказали.
[36:37.240 --> 36:38.120]  Если F не сразу...
[36:38.200 --> 36:39.200]  А, да.
[36:40.320 --> 36:42.680]  Да, ты права, абсолютно права.
[36:42.760 --> 36:44.800]  Есть такая импликация.
[36:44.880 --> 36:50.840]  И мы выбираем на И большей.
[36:50.920 --> 36:53.680]  На И... Короче, вторая выберется.
[36:53.760 --> 36:55.040]  Самая общая.
[36:55.120 --> 36:55.960]  Самая общая.
[36:56.040 --> 36:57.040]  Да.
[36:57.120 --> 36:59.760]  Самая частая.
[36:59.800 --> 37:02.960]  Тут сложно сказать, в какую сторону частности, в какую общность.
[37:03.040 --> 37:04.080]  По-разному можно интерпретировать.
[37:04.160 --> 37:05.160]  Короче...
[37:05.240 --> 37:06.640]  Самая занициализированная.
[37:06.720 --> 37:09.840]  Короче, инициальный объект в категории.
[37:09.920 --> 37:12.640]  То, откуда все стрелки растут.
[37:13.880 --> 37:14.880]  Корень, типа дерева.
[37:14.960 --> 37:16.440]  Да, как бы корень.
[37:16.520 --> 37:17.640]  Исток.
[37:17.720 --> 37:19.120]  Будет выбран исток.
[37:20.400 --> 37:21.480]  Окей?
[37:21.560 --> 37:25.720]  Ну, давайте просто дальше договоримся, что это там наибольшее.
[37:26.080 --> 37:29.600]  Идем дальше.
[37:30.920 --> 37:31.920]  Куда мы идем?
[37:34.360 --> 37:36.280]  О, никуда мы не идем.
[37:36.360 --> 37:36.960]  Вот.
[37:37.040 --> 37:38.200]  Я написал наименьшее.
[37:38.280 --> 37:39.360]  Пусть будет наименьшее.
[37:39.440 --> 37:41.200]  Развернем порядок в крайнем случае.
[37:41.280 --> 37:43.720]  Понимаете, почему написано наименьшее, да?
[37:43.800 --> 37:47.000]  Порядок частичный, может что-то быть не так.
[37:47.080 --> 37:52.440]  Если у вас нету наименьшего, то это ошибка компиляции Ambiguous Call.
[37:52.520 --> 37:55.520]  Может быть, наименьшее выключение типа...
[37:55.640 --> 37:56.720]  Наименьшее выключение типа...
[37:56.800 --> 37:59.400]  Да, наименьшее выключение типа...
[37:59.480 --> 38:00.960]  Короче, как-то так.
[38:01.040 --> 38:02.640]  Я, кажется, как сказала.
[38:02.720 --> 38:05.800]  Ну да, по-моему, сказали, что-то аналогичное есть.
[38:05.880 --> 38:09.280]  А вот про это вопрос.
[38:09.360 --> 38:10.960]  Вообще скомпилируется это?
[38:12.200 --> 38:14.520]  Прямо, это же раз, прямо.
[38:14.600 --> 38:17.440]  Нет, кажется, если объект сверху более общий,
[38:17.520 --> 38:19.640]  либо просто класс В,
[38:19.720 --> 38:21.520]  это будет как специализация, то да.
[38:21.600 --> 38:22.920]  И потом обелится более часто.
[38:23.000 --> 38:25.320]  Ну, как бы да, по дефолту это скомпилируется,
[38:25.320 --> 38:27.200]  а зависит от того, от чего звать будем.
[38:27.280 --> 38:29.800]  А, видимо, мы тут ничего звать не будем.
[38:29.880 --> 38:31.160]  Давайте я спрошу.
[38:31.240 --> 38:34.000]  От 63 это скомпилируется?
[38:35.080 --> 38:36.480]  Да.
[38:36.560 --> 38:38.200]  А от 20?
[38:38.280 --> 38:39.440]  Уже нет.
[38:39.520 --> 38:42.200]  Потому что компилятор внутрь термов не заглядывает,
[38:42.280 --> 38:45.680]  он не понимает, что вообще-то здесь есть импликация.
[38:45.760 --> 38:48.640]  Импликация строится только на уровне исчисления высказываний,
[38:48.720 --> 38:51.720]  чтобы еще раз вдолбить вам это совершенно точно.
[38:52.560 --> 38:53.560]  Вот.
[38:55.760 --> 38:57.040]  Здесь есть ссылка.
[38:57.120 --> 39:00.240]  Ну, в репозитории есть ссылка на папку с презами.
[39:00.320 --> 39:05.000]  Там преза, вот можете пройти, если хотите, тут или просто нагуглить.
[39:05.080 --> 39:07.320]  Там есть целая статья, где все это очень подробно описано
[39:07.400 --> 39:08.760]  на SPAP-референс.
[39:08.840 --> 39:10.640]  Когда надо освежить память, освежайте.
[39:10.720 --> 39:13.560]  И мораль всего, что было сейчас,
[39:13.640 --> 39:16.560]  это с финай мы больше вообще не пишем, нигде, никогда.
[39:16.640 --> 39:18.160]  Оно не нужно.
[39:18.240 --> 39:19.240]  Да.
[39:20.600 --> 39:21.600]  Так.
[39:25.360 --> 39:29.360]  Если мы вынесем в концепт вот этот отрывок меньше 32,
[39:29.440 --> 39:33.880]  и здесь потребуем и меньше 32, и меньше 64.
[39:33.960 --> 39:37.800]  Нет, наоборот, очень легко перепутать порядок.
[39:37.880 --> 39:41.120]  Мы вынесем в концепт меньше 64.
[39:41.200 --> 39:43.200]  Так будет концепт С.
[39:43.280 --> 39:47.960]  Здесь поставим С, а здесь поставим С и влево.
[39:48.040 --> 39:51.800]  И вот здесь мы вынесем в концепт меньше 64.
[39:51.840 --> 39:56.040]  Здесь поставим С, а здесь поставим С и вот это.
[39:56.120 --> 39:59.920]  То есть мы и С потребуем, и меньше 64, и меньше 32.
[40:00.000 --> 40:02.000]  Тогда сработает.
[40:02.080 --> 40:04.040]  А здесь еще есть указание, что у него порядок,
[40:04.120 --> 40:07.120]  потому что там ленивый или неразрешенный?
[40:08.400 --> 40:14.200]  Да, да, но вообще мы не подставляем никакие термы, да.
[40:14.280 --> 40:17.600]  Для нас каждый терм, каждое вот это выражение булевое
[40:17.680 --> 40:20.560]  или что-то еще, они полностью прозрачные.
[40:20.600 --> 40:24.280]  Мы с ними работаем как с символами исчисления высказываний
[40:24.360 --> 40:26.760]  и проверяем общезначенность формулы.
[40:26.840 --> 40:30.800]  Мы сами вот эти вот выражения не вычисляем.
[40:31.840 --> 40:34.960]  Вот эти высказывания, мы их истинность или ложность не проверяем.
[40:35.040 --> 40:38.720]  Мы проверяем общезначенность формулы импликации из одного другого.
[40:41.080 --> 40:42.280]  Да.
[40:43.040 --> 40:44.560]  Еще на один.
[40:44.640 --> 40:46.080]  Еще на один.
[40:46.120 --> 40:51.200]  То есть в момент, когда мы заменяем в определении рефлактератора
[40:51.280 --> 40:54.240]  документу ЛУТ на определение документу ЛУТ,
[40:54.320 --> 40:55.720]  и у нас предстоит работать.
[40:55.800 --> 41:01.040]  Проблема в том, что он не может увидеть, что у нас одно и то же написано.
[41:01.120 --> 41:02.440]  Да.
[41:02.520 --> 41:07.400]  Да, если я не ошибаюсь, он не может увидеть, что одно и то же написано.
[41:07.480 --> 41:09.160]  Вот тут я могу ошибаться.
[41:09.240 --> 41:11.400]  Проверьте это, пожалуйста, в годбалте у кого он открыт.
[41:11.480 --> 41:12.880]  Ни у кого он не открыт, да.
[41:12.960 --> 41:14.280]  Я могу очень быстро открыть.
[41:14.360 --> 41:15.360]  Ладно.
[41:15.440 --> 41:19.240]  Как раз то, что я говорил, здесь в слайде можно монетрирует,
[41:19.320 --> 41:22.800]  если поставить многоточки после документа, после фотората.
[41:22.880 --> 41:26.240]  Да, давайте вкратце вот то, о чем Аркадий говорит.
[41:27.160 --> 41:29.040]  Как только вы используете вриадики,
[41:29.120 --> 41:31.480]  вот эта вся технология с импликациями и прочим
[41:31.560 --> 41:33.240]  ломается к чертовой бабушке.
[41:33.320 --> 41:36.880]  Починить, возможно, хотят к 26-м плюсам.
[41:38.160 --> 41:42.520]  То есть будьте осторожны, в домашке вам придется писать вриадики,
[41:43.480 --> 41:45.040]  и вы на это наткнетесь.
[41:45.640 --> 41:49.280]  Вам нужно будет написать концепт, нужны вриадики,
[41:49.360 --> 41:53.480]  следствия не будет, и вам будут говорить, ой, все сломалось, амбигиоз.
[41:53.560 --> 41:54.560]  Ну вот надо...
[41:54.640 --> 41:55.640]  Что он так делает?
[41:55.720 --> 41:57.960]  Не допилили стандарт просто и все.
[41:58.040 --> 42:01.160]  Вы не допилили или там типа написал какой-то код,
[42:01.240 --> 42:05.720]  который ломается за то, что в теории можно ничего не передать?
[42:05.800 --> 42:08.200]  Не допилили стандарт.
[42:08.280 --> 42:10.440]  Просто там недопродумали,
[42:10.480 --> 42:13.360]  потому что стандарт невозможно просто взять и что-то впилить.
[42:13.440 --> 42:18.200]  Нужно продумать взаимодействие этого со всеми возможными корнер-кейсами.
[42:18.280 --> 42:21.240]  Вот этот вот корнер-кейс не успели продумать.
[42:21.320 --> 42:23.160]  Специализация шаблонов есть?
[42:23.240 --> 42:24.720]  Специализация чего?
[42:24.800 --> 42:26.360]  Ну, явно специализация шаблонов.
[42:26.440 --> 42:28.360]  Концептов? Нет.
[42:29.880 --> 42:32.040]  Таким извращением нельзя.
[42:34.240 --> 42:36.880]  Ну, это буквально специализация сейчас.
[42:36.960 --> 42:38.760]  Что, в концептах нельзя писать концепты?
[42:38.840 --> 42:40.120]  Нет, не совсем.
[42:40.200 --> 42:41.200]  Это о чем?
[42:41.280 --> 42:43.960]  Ну, если ты пишешь типа template, type-name,
[42:44.040 --> 42:46.560]  type-concept, то в концептах нельзя писать другой концепт.
[42:46.640 --> 42:48.360]  Вот это я нигде не упомянул.
[42:50.080 --> 42:53.360]  Вот сюда вместо type-name другой концепт писать нельзя.
[42:55.000 --> 42:57.400]  И require все тоже писать нельзя.
[42:58.360 --> 43:00.000]  Иначе бы вы обнаглели.
[43:00.080 --> 43:01.800]  Такого не дозволено.
[43:02.440 --> 43:03.440]  Все.
[43:04.240 --> 43:07.800]  Свиная запрещено, не пользуемся им,
[43:07.880 --> 43:09.400]  пользуемся концептами.
[43:09.440 --> 43:10.600]  И в домашках тоже.
[43:10.680 --> 43:13.080]  Я хочу, чтобы весь этот материал,
[43:13.160 --> 43:15.880]  как бы конкретной домашки на него не будет.
[43:15.960 --> 43:19.640]  Но во всех домашках мы пишем шаблоны.
[43:19.720 --> 43:23.320]  Соответственно, хочу, чтобы вы в этих шаблонах писали концепты,
[43:23.400 --> 43:25.560]  constraints и прочее-прочее.
[43:25.640 --> 43:28.720]  Но... Сколько у нас времени осталось, скажите мне?
[43:28.800 --> 43:29.800]  Полчаса.
[43:29.880 --> 43:31.960]  Ну, пробежаться попробую.
[43:32.040 --> 43:35.280]  Но свои концепты изобретать – это тяжело.
[43:35.360 --> 43:38.560]  Потому что это дизайн кода, это архитектура кода,
[43:38.600 --> 43:41.360]  это выделение хороших абстракций удачных.
[43:41.440 --> 43:44.200]  Вот абстракция итератора крайне удачная,
[43:44.280 --> 43:46.400]  и выделили ее далеко не сразу.
[43:46.480 --> 43:50.560]  Свою такую же классную абстракцию вы вряд ли сможете придумать
[43:50.640 --> 43:54.520]  в субботу вечером, пиша домашку по метапроге.
[43:54.600 --> 43:56.960]  Поэтому мы идем смотреть,
[43:57.880 --> 44:02.720]  какие уже есть концепты, именованные наборы требований в стандарте.
[44:04.200 --> 44:05.200]  Да.
[44:05.280 --> 44:06.280]  Вопрос можно?
[44:06.280 --> 44:09.480]  Но перед этим... Да, вопрос. Давай-давай-давай.
[44:09.560 --> 44:13.160]  То, что вы с Аркадией только что обсуждали про...
[44:13.240 --> 44:15.080]  Это у нас там ворядик...
[44:15.160 --> 44:16.160]  Как бы это...
[44:16.240 --> 44:19.600]  В случае с финайеном, будет как-то нормально или нет?
[44:19.680 --> 44:21.480]  Не понимаю вопроса.
[44:21.560 --> 44:23.320]  С финайеном истарляется порядок.
[44:23.400 --> 44:25.920]  Значит, я, видимо, не понял, о чем вы сомневались.
[44:26.000 --> 44:29.040]  О том, что вся эта технология с построением ипликаций
[44:29.120 --> 44:31.360]  умирает, если у тебя ворядик функция.
[44:31.440 --> 44:33.840]  Вот она принимает произвольное количество аргументов.
[44:33.880 --> 44:36.720]  Наверное, проще буквально на этом примере продемонстрировать,
[44:36.800 --> 44:39.920]  вернуться к нему и сказать, что нужно сделать,
[44:40.000 --> 44:41.960]  чтобы код перестал компилироваться.
[44:42.040 --> 44:45.920]  Вот если мы после decrementable и после ref-этератора
[44:46.000 --> 44:49.600]  напишем многоточие, а в сигнатуре функции после t многоточие,
[44:49.680 --> 44:51.920]  чтобы она стала ворядической, да?
[44:52.000 --> 44:53.000]  Да.
[44:53.080 --> 44:55.120]  То и больше вообще никаких изменений сделаем,
[44:55.200 --> 44:58.080]  у нас будет ошибка компиляции с ambiguous whole.
[45:01.720 --> 45:03.200]  Ну, это бак стандарта.
[45:03.280 --> 45:05.000]  Все, кто понял хорошо, кто не понял,
[45:05.080 --> 45:07.600]  сами споткнетесь в домашке, это не страшно.
[45:08.840 --> 45:11.120]  На своих шишках гораздо лучше, понимаешь.
[45:11.720 --> 45:12.800]  Давайте идти дальше.
[45:12.880 --> 45:14.680]  Да, вот тут вопрос глобальный,
[45:14.760 --> 45:17.840]  что концепт — это у нас такой именованный набор требований.
[45:18.400 --> 45:20.200]  Вот вопрос каких?
[45:20.280 --> 45:23.040]  И все, что мы пока что видели,
[45:23.520 --> 45:26.200]  это лишь одна сторона того, что такое концепт.
[45:26.680 --> 45:29.320]  У нас есть синтоксические требования в концепте.
[45:29.680 --> 45:32.640]  И мы их пишем с помощью этих всех requires прямо в коде.
[45:33.840 --> 45:36.680]  Но это ведь на самом деле не единственное, чего мы ожидаем,
[45:36.760 --> 45:38.960]  когда говорим слово итератор.
[45:39.680 --> 45:41.160]  Вот представляя в голове итератор,
[45:41.240 --> 45:45.560]  вы автоматически ожидаете, что сдвинув его на единичку вперед,
[45:45.640 --> 45:50.600]  потом еще раз на единичку и сдвинув его такой же или его копию на двоечку,
[45:50.680 --> 45:52.360]  у вас получится одно и то же, да?
[45:53.240 --> 45:55.000]  Это семантические свойства.
[45:55.080 --> 45:58.960]  Вот окей, компилируются эти выражения, класс.
[45:59.040 --> 46:00.880]  Синтаксис, понятно, какой.
[46:00.960 --> 46:03.800]  Но как оно работает, непонятно.
[46:04.600 --> 46:07.240]  Мы не можем вот эти вот семантические требования...
[46:08.800 --> 46:11.040]  Да, я начал дальше говорить.
[46:12.120 --> 46:15.000]  Когда синтаксическим требованиям мы удовлетворили,
[46:15.080 --> 46:16.800]  то есть концепт true в коде,
[46:17.840 --> 46:19.960]  мы говорим, что он удовлетворен, satisfied.
[46:20.320 --> 46:22.320]  А вот есть семантические требования,
[46:22.400 --> 46:24.240]  в коде мы их проверить никак не можем,
[46:24.320 --> 46:27.000]  потому что это опять же все к теореме к линии сводится
[46:27.080 --> 46:28.360]  и к проблеме останова.
[46:28.720 --> 46:31.160]  Не можем мы в коде проверить семантические требования,
[46:31.240 --> 46:35.400]  что итератор любой мы от такого типа полученный откуда угодно,
[46:35.480 --> 46:38.600]  если его там двигать так и двигать сяк, то получится одно и то же.
[46:38.680 --> 46:40.160]  Невозможно это проверять.
[46:42.320 --> 46:44.200]  Ну и вот, собственно, для семантических требований говорят,
[46:44.280 --> 46:46.280]  что концепт смоделирован.
[46:47.120 --> 46:51.080]  И для всех концептов определенных в стандартной библиотеке
[46:51.760 --> 46:54.840]  как бы есть их определение, которое вот просто код,
[46:54.920 --> 46:58.720]  концепт ла-ла-ла равно и так далее.
[46:58.800 --> 47:01.200]  И это только синтоксические требования.
[47:01.560 --> 47:04.200]  А есть еще набор семантических требований отдельных
[47:04.280 --> 47:06.800]  для каждого концепта в стандартной библиотеке.
[47:07.120 --> 47:08.840]  И вот ровно на них мы сейчас будем смотреть.
[47:08.920 --> 47:10.600]  Ну и на то и другое, собственно.
[47:10.680 --> 47:11.880]  Ну и к чему это все?
[47:11.960 --> 47:13.680]  Ты сказал, что концепт это...
[47:15.080 --> 47:17.000]  Так контингенстератор это несложно.
[47:17.080 --> 47:20.520]  Я сказал, что концепт это абстракция.
[47:21.000 --> 47:22.760]  Ну вот абстракция она и синтоксическими свойствами,
[47:22.840 --> 47:24.680]  и семантическими должна обладать.
[47:25.360 --> 47:28.240]  Одно мы теперь в коде умеем писать,
[47:28.320 --> 47:30.320]  другое вряд ли когда-то научимся.
[47:30.760 --> 47:33.000]  Поэтому вы все еще, если пишете свой концепт,
[47:33.080 --> 47:34.680]  вы должны сесть и задуматься,
[47:34.760 --> 47:38.720]  а какие семантические требования я накладываю?
[47:38.800 --> 47:41.400]  Как я ожидаю, что вот эта штука будет работать?
[47:42.360 --> 47:44.680]  Понятно вот это вот различие, о чем я сейчас говорю.
[47:45.360 --> 47:49.760]  Ну типа чтобы там в сортировке или там прочее,
[47:49.840 --> 47:52.440]  сравнение было удовлетворяло ксиомам.
[47:53.120 --> 47:55.040]  Да, ксиомы, вот это хорошее слово.
[47:55.120 --> 47:56.840]  Тут можно другой пример привести.
[47:58.720 --> 48:00.120]  Знаете, что такое маноид?
[48:01.200 --> 48:03.840]  Нет, группа. Давайте группу.
[48:03.920 --> 48:06.000]  Вот какие синтоксические требования к тому,
[48:06.080 --> 48:09.160]  чтобы у нас был класс группой в каком-то смысле?
[48:10.120 --> 48:11.960]  Ну да, должно быть определено умножение.
[48:12.040 --> 48:15.760]  Еще, наверное, какая-нибудь инверс-функция должна быть определенна.
[48:16.640 --> 48:17.640]  И единица, да?
[48:17.720 --> 48:20.920]  Ну давайте, c2,1.
[48:21.920 --> 48:23.760]  Такой концепт легко написать, правда?
[48:25.000 --> 48:27.840]  Но этот концепт – только синтоксические требования того,
[48:27.920 --> 48:30.440]  что такое группа инкапсулирует в себе.
[48:30.520 --> 48:33.480]  Мы же хотим еще, чтобы это умножение нормально работало,
[48:33.560 --> 48:35.800]  чтобы умножение на единицу давало тот же элемент,
[48:35.880 --> 48:39.320]  чтобы умножение на обратный давало единицу.
[48:39.400 --> 48:42.640]  Вот эти семантические требования мы все равно в коде никак не запишем,
[48:42.720 --> 48:45.760]  поэтому они должны быть в комментарии перед концептом,
[48:45.840 --> 48:47.640]  написаны на английском языке.
[48:48.320 --> 48:52.080]  А начнем жестить.
[48:52.920 --> 48:55.720]  Первое смешное семантическое требование,
[48:55.800 --> 48:59.320]  которое требуется много где в стандарте.
[49:00.440 --> 49:03.560]  Называется оно equality preservation.
[49:04.200 --> 49:08.040]  Про выражение говорят, что оно сохраняет равенство,
[49:08.480 --> 49:14.680]  если из равенства набора каких-то аргументов
[49:15.160 --> 49:19.920]  следует равенство этого выражения,
[49:20.000 --> 49:24.200]  вычисленного от этих аргументов, причем в широком смысле.
[49:24.920 --> 49:28.160]  Вот значение выражения здесь имеется в виду
[49:28.240 --> 49:33.400]  не только то, что вернулось, но и измененное глобальное состояние,
[49:34.000 --> 49:36.400]  и аргументы, модифицированные по ссылке.
[49:37.120 --> 49:40.800]  То есть весь результат работы функции для равных аргументов
[49:40.880 --> 49:42.200]  должен быть такой же.
[49:42.720 --> 49:43.960]  Это свойство чего?
[49:44.040 --> 49:45.680]  Это свойство выражений.
[49:45.760 --> 49:47.640]  Если не произошло оба?
[49:47.720 --> 49:48.720]  Что?
[49:48.800 --> 49:50.320]  То есть как это соответствует субботу?
[49:50.400 --> 49:52.600]  То есть условно говоря, если оба не разматываются,
[49:52.680 --> 49:54.520]  это в контексте с C++ программы?
[49:54.600 --> 49:57.440]  Это свойство выражения.
[49:57.520 --> 50:00.680]  Выражения в C++, корректные выражения в C++,
[50:00.760 --> 50:03.240]  бывают equality preserving, а бывают нет.
[50:04.720 --> 50:08.960]  Например, сложение для интов – это equality preserving выражения.
[50:09.480 --> 50:12.080]  А плюс B. Это equality preserving выражения.
[50:12.080 --> 50:15.680]  Потому что если мы одинаковые A1, A2, B1, B2 возьмем,
[50:16.960 --> 50:19.800]  подставим, то результат получится один и тот же.
[50:19.880 --> 50:22.280]  Глобального состояния не модифицировано,
[50:22.360 --> 50:26.360]  по ссылкам инты плюсик не принимает и их не модифицируют.
[50:27.440 --> 50:28.440]  А вот...
[50:32.040 --> 50:37.280]  Надо проверить, что результат вычисления выражений один и тот же, равный.
[50:37.360 --> 50:40.960]  Для равных аргументов результат вычисления выражения равный.
[50:42.360 --> 50:46.040]  Относительно оператор равенства.
[50:47.040 --> 50:48.040]  Пока так.
[50:49.280 --> 50:50.680]  Вот это сами переговоры.
[50:52.560 --> 50:55.080]  Ну как бы да. Про это сейчас поговорим еще.
[50:58.600 --> 51:00.640]  Окей, вот это понятие ясно.
[51:00.720 --> 51:05.520]  Приведите пример equality preserving выражения.
[51:05.840 --> 51:06.840]  Рандом.
[51:06.920 --> 51:07.920]  Рандом, да.
[51:09.120 --> 51:10.120]  Вот с консоли.
[51:11.120 --> 51:15.120]  Оно очевидно не equality preserving, потому что ввести на могут что угодно.
[51:15.200 --> 51:17.240]  Считывание чего-то из сети.
[51:17.320 --> 51:19.720]  Вот это все оно как бы не equality preserving.
[51:19.800 --> 51:23.000]  Если оно глобальный счетчик увеличивает и возвращает разные результаты,
[51:23.080 --> 51:25.760]  в зависимости от этого, не equality preserving.
[51:25.840 --> 51:26.840]  Если...
[51:28.920 --> 51:29.920]  Чего?
[51:30.760 --> 51:32.760]  Да, вот ты абсолютно прав.
[51:32.840 --> 51:36.280]  Даже если оно увеличивает глобальный счетчик, но никак его не возвращает,
[51:36.360 --> 51:38.200]  оно все равно не будет equality preserving.
[51:38.280 --> 51:43.040]  Потому что измененное состояние внешнее тоже считается частью результата.
[51:43.120 --> 51:45.080]  Состояние в целом же, все системы...
[51:45.160 --> 51:46.160]  Ну как бы да.
[51:46.240 --> 51:48.280]  Но если они одинаково изменяют этот счетчик,
[51:48.360 --> 51:49.960]  то это все еще equality preserving.
[51:51.080 --> 51:55.480]  Да, если они меняют этот счетчик, присваивают ему единицу,
[51:55.560 --> 51:57.000]  тогда это equality preserving.
[51:57.080 --> 51:58.240]  Если увеличивают, то нет.
[51:58.320 --> 51:59.600]  Сейчас, подожди.
[51:59.680 --> 52:03.680]  Ты понимаешь, это странно, как мы это понимаем.
[52:03.760 --> 52:06.920]  Мы понимаем, что если мы упали на программе,
[52:07.000 --> 52:09.280]  напишем два последовательных...
[52:09.360 --> 52:10.360]  Если...
[52:10.440 --> 52:11.440]  Да.
[52:11.520 --> 52:13.000]  ...совпадут и сайд-эффекты...
[52:13.080 --> 52:14.600]  Да. Да.
[52:14.680 --> 52:17.480]  Но просто здесь можно было бы предложить...
[52:17.560 --> 52:18.560]  Завернулось.
[52:18.640 --> 52:21.680]  И сказав, что мы написали две программы,
[52:21.760 --> 52:25.760]  если плюс-плюс и в одной это вот этот объект,
[52:25.840 --> 52:27.880]  а в другой другой объект.
[52:27.960 --> 52:32.120]  Нет, мы как бы в рамках одной программы требуем, чтобы было равенство.
[52:32.200 --> 52:34.760]  Это были последовательные вызовы?
[52:34.840 --> 52:35.840]  Типа того, да.
[52:36.960 --> 52:40.680]  А лучше откройте это, если интересно, в стандарте
[52:40.760 --> 52:42.400]  и прочитайте точную формулировку.
[52:42.480 --> 52:44.200]  Она убойная, но да.
[52:44.280 --> 52:47.040]  То есть у нас, как в рамках какой-либо, в какой-либо потоке
[52:47.120 --> 52:48.600]  мы увеличиваем счетчик,
[52:50.160 --> 52:52.320]  состояние системы меняется,
[52:52.400 --> 52:54.280]  но только меняется не в этой функции?
[52:54.360 --> 52:56.360]  Да, все равно не equality preserving.
[52:56.440 --> 52:57.760]  Да, даже так.
[52:57.840 --> 53:00.920]  Нельзя все это писать ни в операторах присваивания,
[53:00.920 --> 53:03.560]  ни в операторах сравнения, нигде.
[53:03.640 --> 53:04.840]  Сейчас узнаем, почему.
[53:04.920 --> 53:08.400]  Второе определение, тоже убойное, но которое, опять же,
[53:08.480 --> 53:10.480]  ну сейчас скажу,
[53:10.560 --> 53:11.760]  стабильное выражение.
[53:11.840 --> 53:13.760]  Выражение называется стабильным,
[53:13.840 --> 53:15.840]  если выполнила следующая фигня.
[53:17.000 --> 53:18.520]  Был у нас объект,
[53:18.600 --> 53:21.560]  и мы два раза от одного и того же объекта
[53:21.640 --> 53:24.800]  подряд посчитали это выражение.
[53:24.880 --> 53:26.920]  Вот результат должен быть один и тот же,
[53:27.000 --> 53:28.520]  опять в широком смысле.
[53:29.200 --> 53:31.560]  То есть опять мы еще какие-то виды
[53:31.640 --> 53:34.240]  глобальных изменений состояния запрещаем.
[53:35.320 --> 53:36.320]  Окей?
[53:36.400 --> 53:37.400]  Мораль.
[53:37.480 --> 53:39.560]  Ну, выражение, короче,
[53:39.640 --> 53:41.080]  которое и то, и другое,
[53:41.160 --> 53:44.320]  они просто как чистые функции считаете, математические.
[53:44.400 --> 53:47.000]  И сейчас нам хочется как-то формализировать тогда,
[53:47.080 --> 53:51.600]  что вкладывается в понятие глобального состояния.
[53:51.680 --> 53:52.760]  Формализируйте.
[53:52.840 --> 53:54.840]  Ответ был ясен, вы читали.
[53:54.920 --> 53:57.440]  Ну да, как бы это...
[53:58.280 --> 54:00.880]  Это очень формально написано в стандарте.
[54:00.960 --> 54:02.920]  Если хочешь формализировать, формализируй.
[54:03.000 --> 54:05.000]  Нам нужно вот на этом остановиться и пойти дальше,
[54:05.080 --> 54:06.880]  иначе мы ничего не успели.
[54:06.960 --> 54:07.960]  Что?
[54:08.040 --> 54:09.320]  Операторы не стабильные считаются.
[54:09.400 --> 54:10.400]  Что оператор?
[54:10.480 --> 54:11.680]  Оператор перемещения.
[54:11.760 --> 54:13.560]  Присваивание, муф, присваивание.
[54:13.640 --> 54:14.840]  Нет, он стабильный.
[54:14.920 --> 54:18.400]  Но мы не можем есть два раза одного объекта подряд.
[54:18.480 --> 54:21.920]  Ну, значит, я неправильно выписал определение.
[54:28.360 --> 54:30.920]  Сейчас там как-то хитро было.
[54:34.640 --> 54:37.000]  Да, кажется, здесь должен быть не один, это тот же obj,
[54:37.080 --> 54:39.800]  а два, как бы, клона.
[54:39.880 --> 54:43.080]  Да, потому что по ссылке можно изменять объекты, когда...
[54:43.160 --> 54:46.080]  Нет, нет, если будут равные,
[54:46.160 --> 54:48.040]  то мы получим все еще quality preserving.
[54:48.120 --> 54:50.840]  Тут важно, что именно два раза подряд вызвали.
[54:53.920 --> 54:55.640]  Посмотри стандарт, пожалуйста.
[54:55.800 --> 54:57.640]  Это в бойная вещь,
[54:57.720 --> 55:01.040]  но почему я так настойчиво про нее рассказываю?
[55:01.120 --> 55:03.160]  Потому что каждое выражение,
[55:03.240 --> 55:05.720]  написанное в любом концепте стандартной библиотеки,
[55:05.800 --> 55:10.240]  от него каждого требуется, чтобы оно было equality preserving.
[55:10.320 --> 55:12.000]  И кажется все-таки да.
[55:13.560 --> 55:15.360]  Хотя... Ну ладно, сейчас разберемся.
[55:15.920 --> 55:18.480]  А что значит написанное в интернете для концепта?
[55:18.560 --> 55:22.160]  Ну, сейчас мы будем смотреть концепты стандартной библиотеки.
[55:22.200 --> 55:25.480]  Там определяют концепты movable, copyable, еще какие-то.
[55:26.200 --> 55:28.320]  В каждом из них написаны какие-то выражения.
[55:29.160 --> 55:30.720]  В синтаксических требованиях.
[55:30.800 --> 55:31.800]  А, в приквалинах.
[55:31.880 --> 55:34.280]  Да, в синтаксических требованиях написаны выражения.
[55:34.360 --> 55:37.600]  От всех них требуется и equality preservation, и stability.
[55:38.600 --> 55:40.960]  Но это же не учисляемая.
[55:41.040 --> 55:42.440]  Да, да.
[55:42.520 --> 55:44.600]  Это опять проблема останова.
[55:45.440 --> 55:48.320]  Если вы нарушили эти требования, у вас не defined behavior.
[55:49.320 --> 55:53.840]  Ну, то есть мораль этого не считайте random в операторе сравнения, пожалуйста.
[55:53.920 --> 55:57.040]  Или в операторе присваивания какого-нибудь. Вот не надо.
[55:57.760 --> 56:00.160]  Есть вопрос, как глобальный счетчик увеличиваем.
[56:00.240 --> 56:03.200]  Да, тоже не надо. Не увеличивайте глобальный счетчик.
[56:03.280 --> 56:07.240]  И статик переменный не трогайте в операторах присваивания.
[56:07.640 --> 56:08.640]  А если хочется...
[56:08.720 --> 56:10.640]  Смотреть сколько раз нельзя написать?
[56:10.720 --> 56:12.600]  Нельзя смотреть, сколько раз вызвали.
[56:12.680 --> 56:14.400]  Все, это убея по стандарту.
[56:14.480 --> 56:15.480]  Несколько запрещают.
[56:15.560 --> 56:16.560]  Ну вот.
[56:16.800 --> 56:19.480]  Если вы это нарушите, наверное, ничего плохого не будет.
[56:19.560 --> 56:22.400]  Но со временем компиляторы начнут оптимизировать код
[56:22.480 --> 56:24.760]  относительно предположений, что все нормально.
[56:25.320 --> 56:27.400]  И тогда мы можем пострадать.
[56:27.480 --> 56:29.040]  Но не факт.
[56:29.920 --> 56:31.920]  Да, все, начинаем смотреть.
[56:32.000 --> 56:35.840]  Вот как бы сейчас было немножко bad, потому что...
[56:36.360 --> 56:38.240]  Сейчас пойдет ugly, да, постепенно.
[56:38.320 --> 56:40.320]  И bad, и ugly, все в перемешку.
[56:40.400 --> 56:42.400]  Ну вот простые, понятные концепты.
[56:42.480 --> 56:44.000]  Вы их сами написать сможете.
[56:45.000 --> 56:47.360]  Ну, то есть тут, конечно, специализации какие-то
[56:47.440 --> 56:50.720]  нужно будет пописать, чтобы проверить, что типы одинаковые.
[56:51.280 --> 56:55.280]  Про convertible2 не очень очевидно, про drive-from тоже.
[56:55.880 --> 56:58.440]  Ну, есть оговорочка, convertible2,
[56:58.520 --> 57:01.040]  оно должно быть и имплиситле, и эксплиситле.
[57:01.120 --> 57:03.560]  Помните, что есть имплисит-каст,
[57:03.640 --> 57:08.520]  когда вы просто пихаете в аргумент одного типа значения другого,
[57:08.600 --> 57:11.880]  и имплисит кастует неявный каст.
[57:11.960 --> 57:15.640]  А есть эксплисит, где какой-нибудь статик, каст, что-нибудь такое.
[57:15.720 --> 57:18.360]  Ну вот convertible2 и то и другое требуют.
[57:18.440 --> 57:21.440]  Ну и draft-from только публичное наследование проверяет.
[57:22.240 --> 57:24.960]  Но, кажется, и другие и не надо, а зачем?
[57:26.120 --> 57:30.600]  Идем дальше. Еще простая кучка, какие-то для типов примитивных.
[57:30.680 --> 57:34.040]  Integral, signed integral, unsigned integral, floating point.
[57:34.120 --> 57:38.280]  Кстати, вы, наверное, не сказали, что requires тоже,
[57:38.360 --> 57:40.840]  если метод публичный, то его наличие нельзя.
[57:40.920 --> 57:41.920]  А, ну, конечно.
[57:42.920 --> 57:44.800]  Нет, это надо было самому догадаться.
[57:45.800 --> 57:48.760]  Потому что, если вы такой код напишете с приватным методом,
[57:48.840 --> 57:51.920]  он не скомпилируется, а requires проверяет компиляцию.
[57:52.000 --> 57:56.080]  Соответственно, понятно, что он как бы не сможет.
[57:56.560 --> 57:58.120]  А destructible?
[57:58.200 --> 58:01.560]  Шаблонный из base, он в том числе приватный.
[58:02.320 --> 58:04.200]  Из base приватный умеет.
[58:04.280 --> 58:07.400]  Да, потому что ошибка вылетает на другом репиляции,
[58:07.480 --> 58:08.480]  и он это отличает.
[58:09.480 --> 58:11.680]  Прикол. Забавно.
[58:11.760 --> 58:14.160]  Ну да, такие детали обычно cpp-референс
[58:14.240 --> 58:17.640]  каждый раз заново смотришь, наизусть невозможно.
[58:17.720 --> 58:18.720]  Destructible.
[58:20.320 --> 58:22.560]  Ну, noexcept destructible, да.
[58:23.320 --> 58:26.240]  Вот мы его даже... А, нет, смотреть мы его не будем.
[58:26.320 --> 58:29.000]  Ну, я думаю, вы представляете, как выглядит этот концепт.
[58:29.080 --> 58:32.440]  Там тильда T, в фигурных скобках noexcept, все.
[58:32.520 --> 58:34.120]  Может быть, не destructible.
[58:34.200 --> 58:36.480]  Что? А приватный деструктор.
[58:37.200 --> 58:39.320]  Это достаточно полезный трюк.
[58:39.400 --> 58:42.840]  А еще это может быть... А, нет, ладно, все.
[58:42.920 --> 58:45.160]  Вроде из base только публичное проверяет.
[58:45.240 --> 58:47.560]  Там просто нужно было еще в один слот ворачивать,
[58:47.640 --> 58:49.640]  чтобы на приватном не ломаться.
[58:51.120 --> 58:52.120]  Вот, давайте...
[58:52.200 --> 58:54.480]  А в чем смысл приватного деструктора?
[58:54.560 --> 58:59.200]  Приватного деструктора в том, чтобы только определенные сущности
[58:59.280 --> 59:02.400]  могли вызвать дилит на твоем типе.
[59:03.960 --> 59:04.960]  Типа...
[59:05.480 --> 59:09.480]  Нет, когда это просто... Когда это может быть необходимо.
[59:09.560 --> 59:13.400]  Сейчас у меня были хорошие примеры, но я уже подустал,
[59:13.480 --> 59:17.120]  и, кажется, они где-то дальше по сходу лекций нам встретятся.
[59:17.200 --> 59:19.120]  Поэтому откладывается вопрос.
[59:19.200 --> 59:22.560]  А в каком примере не деспрактно выучить?
[59:22.640 --> 59:27.520]  Ну, как бы можно, но как бы нет.
[59:27.600 --> 59:29.360]  Ладно, нельзя, да, ты прав.
[59:29.440 --> 59:32.720]  Вот тогда просто сказать, что приватный деструктор,
[59:32.760 --> 59:36.600]  когда мы хотели зафорсить родителей из-за этого объекта?
[59:36.680 --> 59:39.480]  Да не форсится там ничего.
[59:39.560 --> 59:42.600]  Ладно, я не помню, честно, у меня был очень хороший пример,
[59:42.680 --> 59:44.680]  я специально его помнил и забыл.
[59:44.760 --> 59:47.760]  Поэтому в один из следующих разов вернемся к этому,
[59:47.840 --> 59:48.840]  поговорим об этом.
[59:48.920 --> 59:50.440]  Констракт был фром.
[59:51.960 --> 59:53.240]  Сингл тон.
[59:53.320 --> 59:54.800]  Ну, как бы хорошая идея, да.
[59:54.880 --> 59:57.120]  Вроде сингл тону не нужен публичный деструктор,
[59:57.200 --> 59:59.040]  можно его спрятать.
[59:59.120 --> 01:00:01.040]  А, я... Что?
[01:00:03.040 --> 01:00:06.200]  Разрушится на статической дестракшене,
[01:00:06.280 --> 01:00:07.920]  когда программа завершает работу.
[01:00:08.000 --> 01:00:10.280]  Так она уже будет пробивать.
[01:00:10.360 --> 01:00:14.280]  Ну, это не помешает ронтайму запустить деструктор.
[01:00:14.360 --> 01:00:17.040]  Сейчас, вы так хотите пример...
[01:00:17.120 --> 01:00:20.640]  Стоит ли говорить, что имеется на самом деле приватный деструктор,
[01:00:20.720 --> 01:00:24.920]  когда какой-то другой объект выманижит лайфсайдл?
[01:00:25.000 --> 01:00:29.360]  Ну, как бы да, но это не информативно.
[01:00:29.440 --> 01:00:32.200]  Ну, у симмофора, например, иногда...
[01:00:32.240 --> 01:00:35.080]  Есть у нас какой-то референс каунт,
[01:00:35.160 --> 01:00:39.040]  кто нам вообще будет показывать, что только про него надо делать?
[01:00:39.120 --> 01:00:43.760]  Я вспомнил, у интерфейсов виртуальных в ООП
[01:00:43.840 --> 01:00:47.200]  периодически надо делать приватный деструктор.
[01:00:47.280 --> 01:00:48.280]  Почему?
[01:00:49.920 --> 01:00:53.640]  Чтобы можно было вызвать только конкретно типов наследования?
[01:00:53.720 --> 01:00:57.520]  Типа того, чтобы никто не мог сохранить объект
[01:00:57.600 --> 01:01:00.000]  по указателю на этот интерфейс
[01:01:00.080 --> 01:01:03.080]  и потом его удалить по указателю на этот интерфейс.
[01:01:04.640 --> 01:01:07.040]  То есть бывает так, что вы используете интерфейс
[01:01:07.120 --> 01:01:09.600]  просто чтобы две части кода разъединить друг от друга.
[01:01:09.680 --> 01:01:13.160]  И вы знаете, что вот этим интерфейсом только вот этот класс лежит.
[01:01:13.240 --> 01:01:15.960]  Ну, и удаляет его он сам как бы.
[01:01:16.040 --> 01:01:18.360]  Например, Fiber. Fiber сам себя удаляет.
[01:01:18.440 --> 01:01:19.920]  Помните такое?
[01:01:20.000 --> 01:01:22.600]  Если вам нужно вызвать что-то на Fiber,
[01:01:22.680 --> 01:01:26.520]  но как бы по ссылке и не зная, что это Fiber,
[01:01:26.600 --> 01:01:28.440]  вы можете сделать интерфейс,
[01:01:28.520 --> 01:01:32.160]  у него приватный деструктор, и как бы кому-то это передать,
[01:01:32.960 --> 01:01:35.080]  он что-то вызовет какой-то виртуальный метод,
[01:01:35.160 --> 01:01:38.040]  но сохранить или удалить этот Fiber не сможет.
[01:01:38.120 --> 01:01:39.600]  Вы ему это запретили.
[01:01:40.160 --> 01:01:42.960]  А вот Detach еще проще вариант.
[01:01:44.240 --> 01:01:45.560]  Detach.
[01:01:48.320 --> 01:01:50.760]  Там что-то тоже было, по-моему, это еще сложнее.
[01:01:50.840 --> 01:01:52.080]  Не помню. Да?
[01:01:52.160 --> 01:01:54.520]  Если я правильно понял, вот этот пример,
[01:01:54.520 --> 01:01:57.560]  это обычно советуют виртуальный деструктор.
[01:01:57.640 --> 01:01:59.960]  Да, а я советую его делать приватным.
[01:02:00.040 --> 01:02:01.840]  А мы не хотим соответственно виртуальности?
[01:02:01.920 --> 01:02:04.600]  Да, мы не хотим виртуальный вызов дополнительный на разрушение,
[01:02:04.680 --> 01:02:07.920]  потому что мы знаем, какой тип в момент разрушения этого объекта.
[01:02:13.040 --> 01:02:14.800]  Короче, ладно, вы поняли, да?
[01:02:14.880 --> 01:02:18.520]  Многие говорят, всегда делай виртуальные деструкторы,
[01:02:18.600 --> 01:02:22.680]  я говорю, нет, это тупая мантра, делай их приватными, если нужно.
[01:02:23.200 --> 01:02:25.680]  Если знаешь, какой тип будет в момент удаления,
[01:02:25.760 --> 01:02:27.960]  то кастуй к этому типу и удаляй явно.
[01:02:28.040 --> 01:02:29.800]  А деструктор просто сделай приватным,
[01:02:29.880 --> 01:02:32.040]  чтобы нечаянно никто не написал плохой код,
[01:02:32.120 --> 01:02:34.240]  который по ссылке на интерфейс что-то удаляет.
[01:02:34.320 --> 01:02:36.560]  Все, давайте идти дальше. ConstructibleFrom.
[01:02:36.640 --> 01:02:39.600]  Первый концепт, который мы реально посмотрим.
[01:02:39.680 --> 01:02:40.720]  Смотрите, какой он классный.
[01:02:40.800 --> 01:02:43.440]  Он требует destructible и destructiblev.
[01:02:44.320 --> 01:02:46.560]  Ну, вот первое неожиданно, кажется, да?
[01:02:47.280 --> 01:02:48.680]  Ну, вот почему-то требует.
[01:02:48.760 --> 01:02:51.920]  Второе, это в принципе вот такое выражение в общем и целом,
[01:02:52.000 --> 01:02:56.320]  примерно, типа, ну, там можно запустить конструктор,
[01:02:56.400 --> 01:02:59.280]  и оно как-нибудь разберется, может, и конструктор вызовет,
[01:02:59.360 --> 01:03:02.800]  а может, и не конструктор, может, оно там оператор каста
[01:03:02.880 --> 01:03:05.760]  какой-нибудь вызовет, неважно.
[01:03:07.240 --> 01:03:09.040]  Default initializable.
[01:03:10.240 --> 01:03:11.600]  Простая штука, да?
[01:03:12.560 --> 01:03:14.520]  ConstructibleFrom.t внезапно.
[01:03:15.000 --> 01:03:19.120]  Ну, мы помним, что это на самом деле просто вот так вот будет.
[01:03:20.120 --> 01:03:22.760]  Там был вырядик, а мы ноль аргументов ему дали,
[01:03:22.840 --> 01:03:25.640]  то есть мы просто проверяем, что t и круглые скобки компилируются.
[01:03:25.720 --> 01:03:28.040]  Еще раз на синтаксис. Можно предучитать?
[01:03:29.240 --> 01:03:30.240]  Ничего, просто...
[01:03:31.040 --> 01:03:32.040]  А, все, нормально.
[01:03:32.120 --> 01:03:33.120]  Ага.
[01:03:34.080 --> 01:03:38.080]  А зачем тогда еще тот концепт, ну, предыдущий, destructiblev?
[01:03:38.160 --> 01:03:39.880]  Зачем? Чтобы импликация была.
[01:03:40.960 --> 01:03:41.960]  Ага.
[01:03:42.280 --> 01:03:44.840]  Тут вот в этом все кроется как бы.
[01:03:45.440 --> 01:03:46.440]  Какой второй?
[01:03:47.000 --> 01:03:48.000]  Вторая строчка.
[01:03:48.080 --> 01:03:51.000]  А, вторая строчка, потому что initializer через круглые скобки,
[01:03:51.080 --> 01:03:53.360]  через фигурные, это разные вещи.
[01:03:53.920 --> 01:03:56.560]  Есть как такая книжка, типа там 250 способов
[01:03:56.640 --> 01:03:58.760]  унициализировать переменную C++.
[01:03:59.960 --> 01:04:02.040]  Возможно, я как-нибудь кину вам ссылку на нее.
[01:04:02.120 --> 01:04:03.120]  Но вот так надо.
[01:04:03.520 --> 01:04:06.600]  Вот это место объяснить какой-то логикой невозможно.
[01:04:07.000 --> 01:04:10.360]  Это вот реально типа такая бюрократия по вышкребыванию стандарта
[01:04:10.440 --> 01:04:13.080]  и поиску всех крайних углов и лазеек.
[01:04:13.080 --> 01:04:16.520]  В смысле? Зачем мы тут можем initialize?
[01:04:17.360 --> 01:04:18.360]  Нет, окей.
[01:04:18.440 --> 01:04:20.080]  И с круглыми и фигурными понятно.
[01:04:20.160 --> 01:04:22.160]  Окей. Третий зачем нужен?
[01:04:23.160 --> 01:04:25.160]  Почему через Нью еще должно быть?
[01:04:25.240 --> 01:04:27.840]  Ну, вот тут как бы ответ мы нашкребли,
[01:04:27.920 --> 01:04:31.080]  не помню, Яли или прошлый препод, который метапрога вел.
[01:04:31.520 --> 01:04:34.080]  Но кто-то из нас в общем обнаружил, что это значит вот это.
[01:04:34.800 --> 01:04:37.560]  А ну, групповый вариант даже может быть перегружен в Нью.
[01:04:38.000 --> 01:04:40.240]  А мы его перегрузили и хотим, чтобы с ним можно было работать.
[01:04:40.280 --> 01:04:41.280]  Как здесь?
[01:04:44.120 --> 01:04:46.440]  Да, здесь как бы не про это.
[01:04:46.520 --> 01:04:49.640]  Здесь вот именно про то, что вот такое выражение, statement,
[01:04:49.720 --> 01:04:53.400]  statement объявления переменной без фигурных скобок, без круглых,
[01:04:53.480 --> 01:04:54.720]  просто скомпилируется.
[01:04:56.240 --> 01:04:58.320]  Ну, почему это так странно написано, да?
[01:04:59.080 --> 01:05:01.720]  Ну, надо радоваться, конечно, что это за вас все продумали,
[01:05:01.800 --> 01:05:05.360]  вот этот концепт, вам не нужно вот это все самому догадываться и выяснять.
[01:05:05.920 --> 01:05:06.920]  Но почему так?
[01:05:07.280 --> 01:05:08.840]  Вот такой код скомпилируется?
[01:05:09.680 --> 01:05:12.680]  Нет, потому что не expression, это statement.
[01:05:12.760 --> 01:05:15.080]  Statement нельзя писать, поэтому вот так странно.
[01:05:18.480 --> 01:05:19.480]  Громче?
[01:05:21.640 --> 01:05:24.920]  Нет, просто в requires expression нельзя писать statement.
[01:05:33.800 --> 01:05:34.800]  Чего у них нету?
[01:05:35.360 --> 01:05:38.120]  Все есть, для int этот концепт пройдет.
[01:05:38.840 --> 01:05:40.640]  Так когда мы по всей штуке можем что-нибудь скачать?
[01:05:40.720 --> 01:05:42.760]  Бюрократия, бюрократия.
[01:05:42.840 --> 01:05:46.680]  Я говорю, не очевидно абсолютно, почему все три нужны,
[01:05:46.760 --> 01:05:49.680]  почему если выкинуть одно из них, то этого не хватает.
[01:05:49.760 --> 01:05:53.160]  Это абсолютно не очевидно, это лютая бюрократия стандарта.
[01:05:53.240 --> 01:05:55.040]  Потому что есть какие-то крайние случаи,
[01:05:55.120 --> 01:05:58.400]  когда кто-то какую-то гадость специально вот так намешивает
[01:05:58.480 --> 01:05:59.920]  и получается плохо.
[01:06:00.000 --> 01:06:01.680]  Вот я предлагаю об этом не думать,
[01:06:01.760 --> 01:06:04.440]  а если хотите, то, опять же, дома в ванной запершись,
[01:06:04.520 --> 01:06:07.080]  читайте стандарт, чтобы никто не видел.
[01:06:08.000 --> 01:06:08.960]  В это надо поверить.
[01:06:09.040 --> 01:06:11.040]  Вот есть хороший концепт, default initializable,
[01:06:11.120 --> 01:06:14.240]  используйте его и никогда сами не пишите его с нуля,
[01:06:14.320 --> 01:06:16.560]  потому что вы до этого не додумаетесь, как я, в принципе,
[01:06:16.640 --> 01:06:18.640]  как любой другой человек нормальный.
[01:06:18.720 --> 01:06:19.720]  Да.
[01:06:19.800 --> 01:06:25.920]  Почему вот это странное выражение с new дает нам то, что tt – это well-formed?
[01:06:26.000 --> 01:06:27.800]  Вопрос отклоняется.
[01:06:28.360 --> 01:06:30.360]  Я один раз в этом разобрался.
[01:06:30.440 --> 01:06:32.840]  Мы знаем, что tt буквально называет конструкцию по адресу.
[01:06:32.920 --> 01:06:35.480]  Да, а у нас адрес не ttr.
[01:06:35.560 --> 01:06:36.680]  По адресу?
[01:06:36.760 --> 01:06:39.560]  Это placement new на какой-то адрес любой,
[01:06:39.640 --> 01:06:42.280]  который нам подойдет, потому что вот так надо.
[01:06:42.360 --> 01:06:45.880]  Я не знаю, что более читаемым было бы просто написать функцию,
[01:06:45.960 --> 01:06:47.440]  где происходит...
[01:06:47.520 --> 01:06:51.680]  Тут нет, вызов функции, это всегда скомпилируется.
[01:06:52.360 --> 01:06:54.840]  У тебя функции здесь вызываться не будет.
[01:06:54.920 --> 01:06:56.200]  А, то есть тут...
[01:06:56.280 --> 01:06:57.800]  Да.
[01:06:57.880 --> 01:07:00.320]  Да, смотри, если ты здесь вызов функции напишешь,
[01:07:00.400 --> 01:07:03.840]  то у тебя проверят, скомпилируется ли отрывок кода, вызывающий функцию.
[01:07:03.920 --> 01:07:05.520]  Да, он скомпилируется.
[01:07:05.640 --> 01:07:07.960]  А саму-то функцию вызывать никто не будет?
[01:07:08.040 --> 01:07:09.520]  А что за well-formed?
[01:07:11.000 --> 01:07:14.400]  Это такой бюрократический термин, скомпилируется.
[01:07:16.240 --> 01:07:19.760]  То есть умный способ сказать, так писать можно.
[01:07:21.600 --> 01:07:25.120]  Вот, ну то есть это нельзя, поэтому вот так вот кружимся,
[01:07:25.200 --> 01:07:28.320]  в итоге мораль такая, вот у нас три штуки требуется,
[01:07:28.400 --> 01:07:29.800]  посмотрели, забили.
[01:07:29.880 --> 01:07:31.400]  Move constructable.
[01:07:32.280 --> 01:07:34.400]  Ну, тоже не сильно плохо, да?
[01:07:35.040 --> 01:07:37.600]  То есть constructable.from сам себя,
[01:07:37.680 --> 01:07:39.400]  и видимо там в этом constructable.from
[01:07:39.480 --> 01:07:41.840]  зашита как бы инициализация outer-value, на самом деле,
[01:07:41.920 --> 01:07:44.000]  но мы этого не заметили, ну ладно.
[01:07:44.080 --> 01:07:47.600]  И convertible.to в обратную сторону.
[01:07:49.000 --> 01:07:51.960]  Ну, в принципе, можно поверить, что все нормально.
[01:07:54.440 --> 01:07:56.080]  Надеюсь, да.
[01:07:57.000 --> 01:07:59.400]  Что я хотел сказать? Ничего не хотел, неважно.
[01:07:59.480 --> 01:08:01.840]  Импликация работает, все хорошо, требования.
[01:08:02.560 --> 01:08:05.760]  Тут, внезапно, есть дополнительные требования на move constructable.
[01:08:05.840 --> 01:08:09.440]  Семантические, которые я анонсировал изначально.
[01:08:09.520 --> 01:08:13.560]  А требования следующие, давайте попробуем в них чуть-чуть разобраться.
[01:08:13.640 --> 01:08:17.840]  Значит, нам дано T, тип объекта.
[01:08:17.920 --> 01:08:19.440]  Что это значит?
[01:08:20.400 --> 01:08:25.960]  Не void, не указатель на функцию, а что-то нормальное.
[01:08:26.040 --> 01:08:29.120]  Не базовый тип, наверное, тоже, int, float.
[01:08:29.200 --> 01:08:31.680]  Их можно, нет, они тоже считаются объектами.
[01:08:31.680 --> 01:08:35.800]  Не объект, это void, не объект, это указатель на функцию.
[01:08:35.880 --> 01:08:37.160]  Все остальные объекты.
[01:08:37.240 --> 01:08:40.240]  Rv – это некоторое rvalue типа T.
[01:08:40.320 --> 01:08:42.160]  А u2 – это...
[01:08:43.280 --> 01:08:47.640]  Некоторый другой объект, не тот, на который ссылается rv,
[01:08:47.720 --> 01:08:49.280]  но равный rv.
[01:08:49.840 --> 01:08:51.640]  Да? То есть, setting.
[01:08:51.720 --> 01:08:55.040]  U2 – это объект, объект.
[01:08:55.120 --> 01:08:57.720]  А rv – это expression, rvalue.
[01:08:57.880 --> 01:09:02.200]  rvalue ссылается на что-то, равное u2, но не то же самое.
[01:09:03.480 --> 01:09:08.120]  Требуется, чтобы после объявления tu равно rv,
[01:09:09.160 --> 01:09:11.080]  u было равно u2.
[01:09:11.160 --> 01:09:14.120]  То есть, объект, инициализированный с помощью rvalue,
[01:09:15.240 --> 01:09:19.680]  равного какому-то объекту u2, в свою очередь, тоже станет равным u2.
[01:09:21.440 --> 01:09:25.640]  Ну вот, заметьте, про вопрос с equality preservation and stability,
[01:09:26.400 --> 01:09:30.120]  в концепте...
[01:09:32.080 --> 01:09:34.600]  В концепте синтетических требованиях
[01:09:34.680 --> 01:09:38.600]  там вообще равенства, по-моему, не было приравнивания.
[01:09:38.680 --> 01:09:41.240]  Либо там было оно зашито в convertible tu,
[01:09:41.320 --> 01:09:44.280]  с оговоркой не требуется equality preservation.
[01:09:44.360 --> 01:09:45.680]  Такие места тоже есть.
[01:09:45.760 --> 01:09:48.080]  То есть, требуется везде, кроме оговорок,
[01:09:48.160 --> 01:09:51.040]  где прямо под слышами написано «здесь не требуем».
[01:09:51.120 --> 01:09:53.560]  Скорее всего, там действительно не требуем.
[01:09:53.640 --> 01:09:55.640]  Вот, второе.
[01:09:56.400 --> 01:10:00.200]  Просто временную переменную типа t, если от rv инициализируем,
[01:10:00.280 --> 01:10:03.480]  как функцию послали, тоже равно u2.
[01:10:03.560 --> 01:10:10.040]  И третье, это вот какая-то жесть, что тыры-тыры после вот этих выражений,
[01:10:10.120 --> 01:10:17.200]  если t не const, rv в валидном, но он специфирует состояние.
[01:10:17.280 --> 01:10:20.680]  Сложно переводить бюрократические термины на русский.
[01:10:20.760 --> 01:10:22.960]  Ну, он специфирует это как не…
[01:10:23.840 --> 01:10:25.840]  Как антифальт, только чуть более…
[01:10:25.920 --> 01:10:26.920]  Как вектор после…
[01:10:27.000 --> 01:10:28.800]  Любой, да, как вектор после move.
[01:10:28.880 --> 01:10:31.960]  То есть, тут говорится, что любой тип после move, а он как вектор.
[01:10:32.040 --> 01:10:36.040]  В каком-то состоянии, непонятно каком, но валидном.
[01:10:36.920 --> 01:10:38.240]  Вот.
[01:10:38.320 --> 01:10:43.000]  Теперь мы знаем, что такое правильный класс, который можно move-ать.
[01:10:43.080 --> 01:10:46.280]  И всякий раз, когда вы делаете какой-то класс, который можно move-ать,
[01:10:46.360 --> 01:10:48.720]  вы обязаны все это проверять формально.
[01:10:48.800 --> 01:10:50.440]  Понятное дело, что…
[01:10:50.720 --> 01:10:52.240]  Ты лично инженера проверяете.
[01:10:52.320 --> 01:10:53.800]  Глазками проверяй. Ты что?
[01:10:53.880 --> 01:10:56.440]  Доказательства пиши. Вот у тебя стандарты-таксиомы.
[01:10:56.520 --> 01:10:59.240]  Из них пишешь вывод, доказываете утверждение.
[01:10:59.320 --> 01:11:02.520]  Я бы не указывал, что вы просто пишете, что главная конструкция.
[01:11:02.600 --> 01:11:04.000]  Это вот самая главная конструкция,
[01:11:04.080 --> 01:11:06.000]  в которой я вообще лично не работаю.
[01:11:06.080 --> 01:11:11.520]  Смотри, да, у тебя есть несколько кейсов.
[01:11:11.600 --> 01:11:15.080]  Первый кейс. Ты не удовлетворил синтоксические требования.
[01:11:15.160 --> 01:11:18.160]  Тогда ты точно не move-констракте был, и все нормально.
[01:11:18.240 --> 01:11:20.680]  Кейс второй. Самый ужасный.
[01:11:20.760 --> 01:11:25.880]  Ты удовлетворил синтоксическим требованиям, но нарушил симантические.
[01:11:25.960 --> 01:11:30.520]  Это самый ужасный кейс. Это УБ, но которые никак не диагностируются.
[01:11:30.600 --> 01:11:32.480]  Ну и вряд ли что-то сломает на самом деле.
[01:11:32.560 --> 01:11:35.280]  Но может сломать. Это же УБ. Вдруг.
[01:11:35.360 --> 01:11:38.640]  Ты не move-констракт был, но компилятор не умел.
[01:11:38.720 --> 01:11:41.360]  Да, но компилятор не может понять, что ты не move-констракте был.
[01:11:41.440 --> 01:11:43.920]  Поэтому он ложно-положительно срабатывает.
[01:11:44.000 --> 01:11:45.360]  Типа «да, это move-констракте был».
[01:11:45.440 --> 01:11:48.120]  Но на самом деле нет, потому что вот это вот не пройдено.
[01:11:48.200 --> 01:11:51.680]  Или какой-нибудь quality preservation нарушен где-нибудь, не знаю.
[01:11:51.760 --> 01:11:55.760]  То есть вот такие проблемы могут быть, но по факту не возникают.
[01:11:55.840 --> 01:11:59.760]  Ну русская войска здесь работает вот так.
[01:11:59.840 --> 01:12:01.200]  Так что все хорошо.
[01:12:01.280 --> 01:12:03.360]  Давайте дальше двинемся. Сколько у нас времени осталось?
[01:12:03.440 --> 01:12:04.840]  У нас 5 минут.
[01:12:04.920 --> 01:12:08.360]  5 минут, 5 минут. Это очень плохо.
[01:12:08.440 --> 01:12:10.720]  Давайте торопиться.
[01:12:10.800 --> 01:12:14.400]  Копик констракт был. Что может быть проще?
[01:12:14.480 --> 01:12:16.040]  Чат тоже самое будет, наверное, да?
[01:12:16.080 --> 01:12:17.520]  Ну там просто...
[01:12:17.600 --> 01:12:19.600]  Ну ссылки какие-нибудь добавятся и нормально.
[01:12:23.080 --> 01:12:25.160]  Ну как бы да, но как бы нет.
[01:12:25.240 --> 01:12:33.640]  То есть вот move-констракт был и все комбинации констов и ссылок.
[01:12:33.720 --> 01:12:37.040]  Ну в принципе не так плохо пока что.
[01:12:37.120 --> 01:12:39.440]  Ну и конечно же там опять требования.
[01:12:39.520 --> 01:12:42.680]  А требования опять точно такие же в принципе.
[01:12:42.720 --> 01:12:46.040]  Только вот про valid-button-specify третий пункт убавился, да?
[01:12:46.120 --> 01:12:47.320]  Но осталось два пункта.
[01:12:47.400 --> 01:12:51.240]  Про то, что мы говорим, что после инициализации новой переменной
[01:12:51.320 --> 01:12:53.560]  с помощью v, где теперь это lvalue,
[01:12:53.640 --> 01:12:56.320]  раньше было rvalue, теперь это lvalue,
[01:12:56.400 --> 01:13:00.080]  u будет равно v и v не изменился.
[01:13:00.160 --> 01:13:02.880]  Внимание, какой класс,
[01:13:02.960 --> 01:13:06.360]  который удален был из стандарта c++ в какой-то момент,
[01:13:06.440 --> 01:13:08.280]  не удовлетворяет вот этому пункту,
[01:13:08.280 --> 01:13:12.920]  хотя синтоксически будет моделировать copyable.
[01:13:13.000 --> 01:13:14.160]  Автоптр.
[01:13:14.240 --> 01:13:16.320]  Автоптр. Почему?
[01:13:16.400 --> 01:13:19.120]  Потому что он на самом деле винил птр и он умолился.
[01:13:19.200 --> 01:13:22.040]  Да, он менял v вот в этом выражении.
[01:13:22.120 --> 01:13:24.640]  t равно v, автоптр в этом месте, v менял.
[01:13:24.720 --> 01:13:27.520]  А тут написано v is not modified.
[01:13:27.600 --> 01:13:29.560]  Вот вам пример, собственно,
[01:13:29.640 --> 01:13:32.640]  класса, который синтоксические требования с нура проходят,
[01:13:32.720 --> 01:13:34.480]  а симонтические нет.
[01:13:34.560 --> 01:13:37.000]  Ну и такие классы, они всегда плохие.
[01:13:37.080 --> 01:13:39.320]  Это, кстати, ещё одна такая глубокая философская мысль,
[01:13:39.400 --> 01:13:40.840]  в которую вы можете только поверить.
[01:13:40.920 --> 01:13:45.320]  Если ваш класс нарушает симонтические требования,
[01:13:45.400 --> 01:13:46.400]  то он автоматно плохой.
[01:13:46.480 --> 01:13:47.640]  Плохой класс, выкинуть его,
[01:13:47.720 --> 01:13:49.840]  его неудобно людям будет использовать.
[01:13:49.920 --> 01:13:52.800]  Они не будут ожидать того, что он делает.
[01:13:52.880 --> 01:13:55.520]  В премьере серая я трепелился домом без майка.
[01:13:55.600 --> 01:13:56.320]  Да.
[01:13:56.400 --> 01:14:00.040]  Но он работал неожиданно, и от него люди офигевали.
[01:14:00.120 --> 01:14:03.040]  И это свойство общее для всех таких классов,
[01:14:03.120 --> 01:14:05.200]  которые нарушают симонтические требования.
[01:14:05.240 --> 01:14:06.920]  Обычно это всегда плохой код.
[01:14:08.000 --> 01:14:10.880]  Ну и тут вот Т от В, опять же, точно так же модифици...
[01:14:10.960 --> 01:14:13.880]  Такая инициализация временной переменной, и тыры-пыры.
[01:14:15.680 --> 01:14:18.840]  Ну, очевидный пример, там вот так, вот сяк.
[01:14:21.240 --> 01:14:23.040]  Да, нет, не очевидный.
[01:14:23.120 --> 01:14:24.120]  Где не очевидно?
[01:14:27.200 --> 01:14:29.960]  Видите, С, копик инстрактибл.
[01:14:31.840 --> 01:14:34.400]  А Ц, наоборот.
[01:14:35.040 --> 01:14:36.520]  С не копик констрактибл.
[01:14:36.600 --> 01:14:40.200]  Мы удалили оператор копирования, конструктор копирования.
[01:14:40.880 --> 01:14:43.480]  А Ц с имперсантом уже копируемо.
[01:14:43.560 --> 01:14:45.440]  Потому что ссылку копировать можно.
[01:14:46.680 --> 01:14:47.680]  Опасно, да?
[01:14:47.760 --> 01:14:49.800]  То есть когда какой-то шаблонный код пишете,
[01:14:49.880 --> 01:14:52.640]  нужно здесь вот где-то не забыть в районе вот этого всего
[01:14:52.720 --> 01:14:55.040]  рему в референс какой-то, скорее всего.
[01:14:56.280 --> 01:14:57.280]  Возможно.
[01:14:58.120 --> 01:14:59.520]  Ну и здесь то же самое, да?
[01:14:59.600 --> 01:15:03.520]  То есть ссылка, как бы она спокойно мувается внезапно.
[01:15:04.200 --> 01:15:05.200]  Ну...
[01:15:06.800 --> 01:15:07.800]  Что?
[01:15:08.040 --> 01:15:09.440]  Нет, ссылку нельзя мывать.
[01:15:10.160 --> 01:15:11.160]  Ну, то есть...
[01:15:12.680 --> 01:15:15.240]  Короче, не пихайте ссылки в эти вот концепты морали.
[01:15:17.920 --> 01:15:21.280]  Это значит новую ссылку, но забиндить на ту же самую ссылку.
[01:15:21.880 --> 01:15:23.280]  Ты как бы ее скопировал?
[01:15:28.800 --> 01:15:31.400]  Да, да, как бы вот эти 8 байт ты спокойно муваешь.
[01:15:31.440 --> 01:15:32.840]  Вот это подводный камень.
[01:15:32.920 --> 01:15:33.920]  Будьте осторожны.
[01:15:34.520 --> 01:15:35.520]  Assignable from.
[01:15:36.360 --> 01:15:38.600]  Ну, английский знаем, понятно, что имеется в виду.
[01:15:38.680 --> 01:15:40.520]  Можно написать lhs равно rhs.
[01:15:40.920 --> 01:15:41.920]  Интуитивно.
[01:15:42.280 --> 01:15:43.280]  А по факту...
[01:15:44.080 --> 01:15:45.160]  Ну как, неплохо.
[01:15:45.240 --> 01:15:47.400]  Мы требуем, чтобы lhs был lvalue-ссылкой.
[01:15:47.920 --> 01:15:50.240]  Ну да, к lvalue-ссылкам присваивать нельзя.
[01:15:50.720 --> 01:15:52.400]  К просто типам, скорее всего, тоже.
[01:15:52.480 --> 01:15:53.680]  Нужна lvalue-ссылка.
[01:15:54.840 --> 01:15:57.560]  И компилирует соображение, где мы берем и присваиваем.
[01:15:58.240 --> 01:16:00.440]  Просто типам нельзя присваивать?
[01:16:01.120 --> 01:16:02.480]  Ну как бы да.
[01:16:02.560 --> 01:16:06.400]  Если ты напишешь выражение, у которого тип просто t,
[01:16:06.480 --> 01:16:08.120]  то ему ничего присвоить не получится.
[01:16:08.760 --> 01:16:12.720]  Например, типа инициализируешь переменную и попытаешь ей что-то присваивать.
[01:16:13.080 --> 01:16:14.880]  А там не просто t?
[01:16:15.440 --> 01:16:16.920]  Нет, нет.
[01:16:17.000 --> 01:16:19.640]  Ну, короче, это опять бюрократическая деталь языка.
[01:16:19.720 --> 01:16:22.560]  Всегда, где можно присваивать, считается, что это lvalue-ссылка.
[01:16:25.560 --> 01:16:27.160]  Вот это понятно, понятно.
[01:16:27.960 --> 01:16:29.520]  Same as lhs.
[01:16:29.600 --> 01:16:33.640]  Ну, вам теперь запрещается возвращать из оператора присваивания
[01:16:33.720 --> 01:16:35.480]  что-то, кроме указателя на this.
[01:16:35.560 --> 01:16:38.240]  Ну, вернее, что-то, кроме указателя на такой же тип.
[01:16:38.320 --> 01:16:40.480]  Или ссылки на такой же тип.
[01:16:40.560 --> 01:16:42.000]  Ну, сейчас дальше увидим.
[01:16:42.080 --> 01:16:45.480]  Чего-то не хватает. Можете догадаться, чего не хватает?
[01:16:45.560 --> 01:16:46.840]  Ну, я не могу.
[01:16:48.000 --> 01:16:50.040]  Потому что это просто невозможно.
[01:16:52.840 --> 01:16:54.040]  Это бука.
[01:16:54.640 --> 01:16:57.840]  Это бяка бука, которая вот призвана сейчас всех кокнуть.
[01:16:57.920 --> 01:16:59.760]  Это ее цель в этой жизни.
[01:17:00.360 --> 01:17:04.120]  А что такое common reference?
[01:17:04.200 --> 01:17:05.760]  Давайте смотреть.
[01:17:06.640 --> 01:17:07.960]  Пока посмотрим вот на это.
[01:17:08.040 --> 01:17:10.600]  Assignable from B и A.
[01:17:10.680 --> 01:17:12.880]  Оператор присваивания сделали.
[01:17:12.960 --> 01:17:15.240]  А assignable from проваливается.
[01:17:16.360 --> 01:17:19.200]  Потому что мы не бэкерсан, а бэкерсан.
[01:17:19.280 --> 01:17:20.120]  Что-то такое?
[01:17:20.200 --> 01:17:21.440]  Нет, нет, нет, нет.
[01:17:21.480 --> 01:17:24.800]  Ну, как бы все нормально. Мы пытаемся присвоить к B, A.
[01:17:26.120 --> 01:17:27.680]  Не с констом.
[01:17:28.640 --> 01:17:31.520]  Просто мы неправильно используем этот концепт.
[01:17:31.600 --> 01:17:33.600]  Он не предназначен для использования
[01:17:33.680 --> 01:17:37.080]  с вот такой вот мерзостью, как перегруженные операторы присваивания.
[01:17:37.160 --> 01:17:40.800]  Да и в принципе перегруженные операторы присваивания делать не надо.
[01:17:40.880 --> 01:17:45.160]  Если вы хотите, чтобы B можно было инициализировать от A,
[01:17:45.240 --> 01:17:46.880]  сделайте конструктор.
[01:17:46.960 --> 01:17:48.600]  Не оператор присваивания.
[01:17:48.680 --> 01:17:50.640]  Implicit конструктор.
[01:17:50.720 --> 01:17:53.120]  Или сделайте оператор каста у B.
[01:17:53.200 --> 01:17:54.640]  Знаете про оператора каста?
[01:17:54.720 --> 01:17:55.440]  Да, вот.
[01:17:55.520 --> 01:17:58.040]  Или его сделайте. Вот так делать не надо.
[01:17:58.120 --> 01:18:00.720]  Потому что вы резко нарушите вот эти все требования.
[01:18:00.800 --> 01:18:01.800]  А...
[01:18:03.600 --> 01:18:06.920]  В том, что с точки зрения обывателя ты пишешь код B,
[01:18:07.000 --> 01:18:09.440]  B маленькая равно там что-то типа A.
[01:18:09.520 --> 01:18:12.600]  И он работает, он компилируется из-за оператора присваивания.
[01:18:12.680 --> 01:18:15.640]  А концепт assignable from будет говорить false.
[01:18:16.400 --> 01:18:18.160]  Потому что он не про это.
[01:18:18.200 --> 01:18:21.320]  Он на самом деле проверяет не просто, есть ли там оператор присваивания
[01:18:21.400 --> 01:18:24.560]  и работает ли он, а есть ли адекватное присваивание.
[01:18:24.640 --> 01:18:28.480]  Какое присваивание считается адекватным в этом контексте?
[01:18:28.560 --> 01:18:30.920]  Вот такое считается адекватным.
[01:18:31.000 --> 01:18:33.960]  Когда у нас B наследует A.
[01:18:34.040 --> 01:18:35.720]  То есть A это какой-то интерфейс, может быть.
[01:18:35.800 --> 01:18:39.040]  Тогда к ссылке на A можно присвоить B.
[01:18:39.120 --> 01:18:40.960]  Да? Правда ведь?
[01:18:43.560 --> 01:18:44.720]  Ну в целом да.
[01:18:45.960 --> 01:18:47.680]  Вот это считается адекватным.
[01:18:47.760 --> 01:18:51.800]  Присваивание через имплисит касты интов к лангам
[01:18:51.880 --> 01:18:54.440]  и вот это все тоже считается адекватным.
[01:18:54.520 --> 01:18:57.520]  А вот ваши свои собственные операторы присваивания кастомные
[01:18:57.600 --> 01:18:59.160]  адекватными не считаются.
[01:18:59.240 --> 01:19:02.200]  Это достаточно странно, но пока поверим.
[01:19:02.280 --> 01:19:04.400]  Есть еще куча требований внезапно.
[01:19:04.480 --> 01:19:07.280]  Целая стена на этот assignable from.
[01:19:07.360 --> 01:19:10.040]  В целом говорят, что вернуть вы должны this,
[01:19:10.120 --> 01:19:12.200]  звездочка this обязательно.
[01:19:12.280 --> 01:19:16.120]  Ну тут какие-то про адресов, понятно, что ровно это.
[01:19:16.200 --> 01:19:20.680]  И дальше опять говорят, что в зависимости от rvalue
[01:19:20.760 --> 01:19:24.720]  или lvalue у вас RHS должно произойти либо move,
[01:19:24.800 --> 01:19:27.320]  либо копия.
[01:19:27.400 --> 01:19:29.080]  И типа либо вы там move-нули,
[01:19:29.160 --> 01:19:32.840]  valid non-specified и все нормально, либо ничего не изменилось.
[01:19:32.920 --> 01:19:34.040]  То есть то же самое, что было раньше,
[01:19:34.120 --> 01:19:35.880]  только вот герократия переформулирована
[01:19:35.960 --> 01:19:39.840]  под именно оператор присваивания, а не конструкторы, как там было.
[01:19:42.160 --> 01:19:44.680]  Окей, все-таки что такое common reference width?
[01:19:46.280 --> 01:19:48.320]  Ну это такой простой тип, который говорит,
[01:19:48.400 --> 01:19:50.320]  что должен быть common reference t.
[01:19:50.400 --> 01:19:52.560]  Это простой концепт.
[01:19:52.640 --> 01:19:54.320]  Ну и какой-то convertible to.
[01:19:55.400 --> 01:19:59.360]  То есть должен быть некоторый общий тип ссылки.
[01:19:59.440 --> 01:20:00.760]  Что такое common reference t?
[01:20:00.840 --> 01:20:02.840]  Сейчас, должен быть общий тип ссылки,
[01:20:02.920 --> 01:20:05.320]  к которому и то, и другое конвертируются.
[01:20:05.400 --> 01:20:07.160]  Что такое convertible to?
[01:20:07.240 --> 01:20:09.320]  Фу, что такое common reference t?
[01:20:09.400 --> 01:20:13.120]  Ну то есть ссылка на cpp-reference вы можете открыть и просто сдохнуть.
[01:20:13.240 --> 01:20:14.720]  Я не советую.
[01:20:14.800 --> 01:20:17.040]  Нас спасет Эричи.
[01:20:17.120 --> 01:20:20.120]  Вот он на stacker flow ответил.
[01:20:20.200 --> 01:20:22.960]  Если у нас было бы время, я бы сейчас открыл и вам все зачитал,
[01:20:23.040 --> 01:20:24.200]  и стало бы понятно.
[01:20:24.280 --> 01:20:26.440]  Времени нет, поэтому вот у вас даже те задания.
[01:20:26.520 --> 01:20:30.640]  Откройте и прочитайте, что такое common reference t, вам понравится.
[01:20:30.720 --> 01:20:35.240]  А еще есть вот эта вот ссылка на вот конкретную статью,
[01:20:35.320 --> 01:20:40.200]  где самый правильный пример того, зачем эта сложность была введена.
[01:20:40.240 --> 01:20:42.600]  Зачем, вот если дальше будем смотреть,
[01:20:42.680 --> 01:20:45.760]  ну сейчас, наверное, чуть-чуть досмотрим еще и все.
[01:20:45.840 --> 01:20:51.840]  Половина стандартных концептов, они где-то и доиспользуют common reference with.
[01:20:51.920 --> 01:20:53.880]  Просто он повсюду.
[01:20:53.960 --> 01:20:56.800]  И возникает вопрос, нафига так сложно?
[01:20:56.880 --> 01:20:59.560]  Вот ответ на него есть вот здесь.
[01:20:59.640 --> 01:21:01.600]  Это в 23-е плюсы добавили,
[01:21:01.680 --> 01:21:07.120]  и там вот прям нормальное обоснование, зачем все эти свистопляски были.
[01:21:07.200 --> 01:21:08.120]  Окей.
[01:21:08.120 --> 01:21:12.600]  А вот чел на свадьбе назад еще...
[01:21:12.680 --> 01:21:13.880]  Эрик Нибблер.
[01:21:13.960 --> 01:21:17.360]  Это чувак, который сначала Ranges пилил,
[01:21:17.440 --> 01:21:21.920]  ну совместно с другими людьми, но он достаточно много в Ranges поконтрибутил.
[01:21:22.000 --> 01:21:25.800]  А потом пилил Lunifex и P2300.
[01:21:25.880 --> 01:21:27.480]  Это мужик из NVIDIA.
[01:21:27.560 --> 01:21:29.960]  Теперь это мужик из NVIDIA, был мужик из Фейсбука.
[01:21:30.040 --> 01:21:34.200]  Короче, он и крутой и в конкарнсе, и в метапроге,
[01:21:34.280 --> 01:21:37.240]  и вот крутой мужик, в принципе, много чего хорошего сделал.
[01:21:37.280 --> 01:21:39.320]  Не один, конечно, но, в принципе, да.
[01:21:40.480 --> 01:21:44.200]  Короче, мы к нему еще вернемся, у нас в честь него даже термин будет.
[01:21:44.280 --> 01:21:45.480]  Нибблойды.
[01:21:48.040 --> 01:21:50.200]  Да, ну хватит его ЧСВ тешить,
[01:21:50.280 --> 01:21:52.200]  надеюсь, он этот запись не увидит.
[01:21:54.280 --> 01:21:56.720]  Концепты простые. Вот Swappable.
[01:21:56.800 --> 01:21:59.480]  А вот то, о чем я говорил. Есть Swappable with,
[01:21:59.560 --> 01:22:03.360]  где разные типы и где common reference with должен быть.
[01:22:03.440 --> 01:22:04.920]  И так везде будет.
[01:22:05.000 --> 01:22:10.680]  А еще немножко терминологии, чтобы вы могли читать preference хотя бы.
[01:22:10.760 --> 01:22:13.440]  Вот есть Boolean testable.
[01:22:13.520 --> 01:22:15.360]  Такой концепт, но не концепт.
[01:22:15.440 --> 01:22:17.520]  В стандартной библиотеке его нет.
[01:22:17.600 --> 01:22:20.520]  И тут такое понятие в стандарте есть exposition only.
[01:22:20.600 --> 01:22:22.400]  Типа, мы эту сущность ввели,
[01:22:22.480 --> 01:22:24.920]  в стандарте в библиотеке ее быть не должно,
[01:22:25.000 --> 01:22:28.520]  но нам ей удобно пользоваться, чтобы определить то, что будет дальше.
[01:22:28.600 --> 01:22:31.760]  А сущность говорит, B конвертируется к Bulu,
[01:22:31.840 --> 01:22:36.320]  и можно восклицательный знак писать, и тоже конвертируется к Bulu.
[01:22:36.400 --> 01:22:39.200]  Ага. Тупо. Очень тупо.
[01:22:39.280 --> 01:22:42.280]  Что-то, похожее на Bool, конвертируется в Bool.
[01:22:44.000 --> 01:22:46.400]  Вот убойные концепты.
[01:22:46.480 --> 01:22:48.320]  Equality comparable, equality comparable with.
[01:22:48.400 --> 01:22:51.640]  Мы только первый смотрим, второй, понятно, там common reference.
[01:22:51.720 --> 01:22:55.240]  А это там, где-то участок, где есть,
[01:22:55.320 --> 01:22:58.120]  что нужно правильно делать характер одного равно?
[01:22:58.200 --> 01:22:59.960]  Не-не-не, про это потом будем говорить.
[01:23:00.080 --> 01:23:03.880]  Equality comparable, ну, равенство должно быть и неравенство.
[01:23:04.440 --> 01:23:06.920]  Все просто, да, boolean, testable, все хорошо.
[01:23:07.400 --> 01:23:08.480]  У меня вопрос.
[01:23:08.560 --> 01:23:09.560]  Да.
[01:23:11.120 --> 01:23:13.200]  Получается, у нас возможна ситуация,
[01:23:13.280 --> 01:23:18.680]  когда equality comparable true, а второй нету?
[01:23:18.760 --> 01:23:22.200]  Нет, если ты два разных типа сюда, это два разных типа должны быть.
[01:23:22.280 --> 01:23:24.720]  Этот концепт нужно, чтобы проверить, можно ли одну фигню
[01:23:24.800 --> 01:23:27.000]  сравнивать с другой, когда не разных типов.
[01:23:27.040 --> 01:23:28.720]  А если один одинаковый тип остался?
[01:23:28.800 --> 01:23:30.640]  То это будет то же самое, что вот это.
[01:23:30.720 --> 01:23:32.600]  Несмотря на common reference.
[01:23:32.680 --> 01:23:36.680]  Да, да, common reference для двух одинаковых, тот и возвращает.
[01:23:36.760 --> 01:23:39.960]  Так, самый catharsis, самое убойное.
[01:23:40.040 --> 01:23:41.640]  Могу я вот это вот подвинуть?
[01:23:43.600 --> 01:23:45.160]  О, ушло.
[01:23:45.240 --> 01:23:50.800]  Catharsis, ну, какие-то правила для вот этого equality comparable,
[01:23:50.880 --> 01:23:55.200]  что там можно поменять местами у и т, да, симметричное отношение.
[01:23:56.120 --> 01:24:02.000]  Ну, восклицательный знак можно вынести и будет ровно то, что мы хотели, да?
[01:24:02.080 --> 01:24:03.080]  Нормально, да?
[01:24:03.160 --> 01:24:05.520]  Заметьте, везде здесь пишется каст к булу.
[01:24:05.600 --> 01:24:09.560]  А мы помним, что там boolean testable написано, а не same as bool.
[01:24:09.640 --> 01:24:11.920]  И, то есть, в принципе, у нас оператор сравнивания может возвращать
[01:24:12.000 --> 01:24:13.440]  не bool, а вообще что угодно.
[01:24:13.520 --> 01:24:18.160]  И, например, не важно, может строку вернуть, вполне окей.
[01:24:18.240 --> 01:24:21.680]  Ну, и тут тоже симметрично неравенство.
[01:24:21.760 --> 01:24:24.040]  А вот теперь внимание.
[01:24:24.080 --> 01:24:26.160]  Читаем вот это вот дословно.
[01:24:26.240 --> 01:24:28.200]  Пусть A и B объекты типа T.
[01:24:28.280 --> 01:24:31.240]  T моделирует equality comparable тогда и...
[01:24:31.320 --> 01:24:39.240]  А только если bool от A равно равно B верно, когда A равно B.
[01:24:40.560 --> 01:24:42.520]  Что это значит?
[01:24:44.160 --> 01:24:47.800]  A равно B is true when A is equal to B.
[01:24:48.320 --> 01:24:51.440]  Ну, как бы да, но по-моему, я по этой сноске прошел,
[01:24:51.520 --> 01:24:53.480]  ничего хорошего не увидел там.
[01:24:55.560 --> 01:24:58.800]  Они же везде пишут equal to вместо...
[01:25:00.880 --> 01:25:03.960]  Ну, как бы да, там везде было equal to.
[01:25:04.040 --> 01:25:06.440]  И равно равно, оказывается, определено через equal to.
[01:25:06.520 --> 01:25:09.960]  И вот я ему когда-то сказал, что equal to, это значит оператор равенства.
[01:25:10.040 --> 01:25:12.920]  А тут оказывается, что оператор равенства корректно определен,
[01:25:13.000 --> 01:25:15.000]  только если есть какое-то обстоятельство.
[01:25:15.040 --> 01:25:16.480]  Оператор равенства корректно определен,
[01:25:16.560 --> 01:25:19.160]  только если есть какой-то абстрактный equal to.
[01:25:19.240 --> 01:25:20.400]  А откуда этот equal to берет?
[01:25:20.480 --> 01:25:22.720]  Ну, циклические определения почувствовали?
[01:25:23.720 --> 01:25:25.320]  Хигня какая-то.
[01:25:25.400 --> 01:25:27.720]  Вот тут уже начинается спекуляция,
[01:25:27.800 --> 01:25:30.440]  потому что за два года ведения этого курса
[01:25:30.520 --> 01:25:33.760]  так и не вышло однозначно дать на этот вопрос ответ,
[01:25:33.840 --> 01:25:36.160]  который вот прям бы железно ставил точку.
[01:25:37.000 --> 01:25:39.680]  Текущее мое мнение с прошлого года не поменялось.
[01:25:39.760 --> 01:25:44.120]  Определение слова equal для нашего типа мы уводим руками.
[01:25:44.200 --> 01:25:48.000]  Это наше интуитивное понимание того, что такое равенство для этого типа.
[01:25:49.360 --> 01:25:54.200]  Например, если мы моделируем целые числа, рациональные числа,
[01:25:54.280 --> 01:25:59.760]  то две четверти и одна вторая equal –
[01:25:59.840 --> 01:26:04.120]  это могут быть разные битовые представления в памяти,
[01:26:04.200 --> 01:26:08.200]  но они equal с точки зрения значения нашего типа.
[01:26:08.680 --> 01:26:09.680]  Ага.
[01:26:11.600 --> 01:26:18.840]  И мы хотим, чтобы равенство через этот оператор равно-равно
[01:26:18.920 --> 01:26:24.400]  было полностью согласовано с нашим вот этим вот определением равенства в голове.
[01:26:24.480 --> 01:26:26.440]  Вот они должны быть согласованы.
[01:26:27.520 --> 01:26:29.680]  Вот, понятие значения типа.
[01:26:29.760 --> 01:26:31.320]  Ага, представление.
[01:26:31.400 --> 01:26:33.400]  Если типа мы вектор с вектором сравниваем,
[01:26:33.480 --> 01:26:36.960]  мы должны сравнить бухера, а не показатели?
[01:26:37.000 --> 01:26:38.000]  Да.
[01:26:38.920 --> 01:26:41.720]  Потому что это нормальное, интуитивное представление
[01:26:41.800 --> 01:26:43.640]  о том, что такое равные вектора.
[01:26:45.320 --> 01:26:51.160]  А там он их прописал, да, и получается…
[01:26:51.240 --> 01:26:54.280]  Короче, вот три пункта, они должны быть все согласованы,
[01:26:54.360 --> 01:26:57.200]  что при копировании получается то же самое,
[01:26:57.280 --> 01:26:59.600]  что оператор равенства, если определён,
[01:26:59.680 --> 01:27:02.960]  он как бы согласован с вот этим вот и нормально себя ведёт,
[01:27:03.040 --> 01:27:06.040]  и что интуитивное понимание, что такое значение типа
[01:27:06.120 --> 01:27:08.280]  со всем этим хорошо соотносится.
[01:27:08.360 --> 01:27:10.240]  Если у вас…
[01:27:12.680 --> 01:27:16.160]  рациональные числа, то у них есть представление в памяти.
[01:27:16.240 --> 01:27:19.320]  Оно может быть две четверти, может быть одна вторая.
[01:27:19.400 --> 01:27:23.520]  Представления разные, а значения одинаковые.
[01:27:23.600 --> 01:27:25.640]  Да, вот разница между этими терминами.
[01:27:25.720 --> 01:27:27.200]  Но если вы напишете функцию,
[01:27:27.280 --> 01:27:30.560]  которая во вне позволяет вытащить именно представление,
[01:27:30.640 --> 01:27:33.520]  как два отдельных инта, а не значение,
[01:27:33.560 --> 01:27:35.280]  то вы внезапно наткнётесь на нарушение
[01:27:35.360 --> 01:27:38.200]  equality preservation где-нибудь.
[01:27:38.280 --> 01:27:43.320]  Потому что вы определили equality так, что как бы равные дроби равны,
[01:27:43.400 --> 01:27:47.160]  но вы смогли вычислить ли знаменатель одинаковых дробей,
[01:27:47.240 --> 01:27:50.200]  которые на самом деле разные, и всё нарушилось.
[01:27:50.280 --> 01:27:52.120]  И вот тут нужно быть дико аккуратным
[01:27:52.200 --> 01:27:55.520]  и делать абстракции, которые не текут.
[01:27:55.600 --> 01:27:57.960]  И тогда у вас всё будет хорошо.
[01:27:58.040 --> 01:27:59.520]  Давайте про это всё.
[01:27:59.600 --> 01:28:01.960]  По-моему, это вообще последний слайд.
[01:28:02.040 --> 01:28:06.080]  Я понимаю, устали, надо досмотреть книжка.
[01:28:06.160 --> 01:28:08.440]  Total ordered, опять, помним про импликацию,
[01:28:08.520 --> 01:28:10.800]  всегда надо надстраивать это семейство,
[01:28:10.880 --> 01:28:13.120]  всё больше и больше требований накидывать.
[01:28:13.200 --> 01:28:14.600]  И quality comparable требуем.
[01:28:14.680 --> 01:28:17.840]  Ну и просто вот эти вот меньше, больше, меньше либо равно.
[01:28:17.920 --> 01:28:21.360]  А опять же из MatLogo или OKTCH
[01:28:21.440 --> 01:28:25.080]  помним, что total ordered – это линейный порядок,
[01:28:25.160 --> 01:28:26.560]  он же полный порядок,
[01:28:26.640 --> 01:28:29.600]  и нам нужно, чтобы любой элемент с любым был сравним.
[01:28:29.680 --> 01:28:32.520]  Нам нужно, чтобы ровно одно из трёх было,
[01:28:32.600 --> 01:28:34.800]  меньше, больше и равно, верно.
[01:28:37.680 --> 01:28:39.280]  Типа транзитивность должна быть,
[01:28:39.360 --> 01:28:42.640]  и вот это очевидное требование на то,
[01:28:42.720 --> 01:28:45.520]  что меньше либо равно, как один оператор,
[01:28:45.600 --> 01:28:47.200]  адекватно определён.
[01:28:47.280 --> 01:28:48.880]  Ну и всё, в принципе.
[01:28:51.040 --> 01:28:53.400]  Вот, вот это точно последнее.
[01:28:53.480 --> 01:28:56.360]  Давайте я… Нет, я не смогу посмотреть, точно ли?
[01:28:56.400 --> 01:28:59.000]  Ну, это, судя за свой слайд, все-таки и есть.
[01:29:00.160 --> 01:29:01.640]  Откуда там так много?
[01:29:05.280 --> 01:29:06.960]  Блин, ну мы чуть позже начали.
[01:29:07.040 --> 01:29:08.440]  Давайте… Очень хочу закончить,
[01:29:08.520 --> 01:29:11.200]  потому что это тяжело будет на следующий раз перекидывать.
[01:29:11.280 --> 01:29:14.000]  Семейство из четырёх концептов.
[01:29:14.080 --> 01:29:17.000]  Я ускоряюсь, а вы меньше вопросов задаёте.
[01:29:17.080 --> 01:29:20.400]  Четыре концепта movable, copyable, semi-regular, regular.
[01:29:20.480 --> 01:29:22.680]  Они все в друг друга как бы вложены и нарастают,
[01:29:22.760 --> 01:29:24.680]  и больше требований накладывают.
[01:29:24.720 --> 01:29:26.920]  movable — это, во-первых, объект, void,
[01:29:27.000 --> 01:29:29.560]  и указатели на функции запрещены.
[01:29:29.640 --> 01:29:32.560]  movconstructable, assignable from — это…
[01:29:33.520 --> 01:29:36.400]  Ну, короче, movassignable, считайте, и swapable.
[01:29:37.360 --> 01:29:40.440]  Внезапно отдельно. Он здесь написан для импликации.
[01:29:40.520 --> 01:29:42.440]  Всё понятно, всё просто.
[01:29:43.120 --> 01:29:45.520]  Да, вот тут подробно написано.
[01:29:45.600 --> 01:29:48.480]  Copyable — ну, примерно то же самое.
[01:29:48.560 --> 01:29:49.960]  Во-первых, movable добавился,
[01:29:50.040 --> 01:29:53.760]  а во-вторых, вот тут какие-то консты и опять перестановочки их.
[01:29:53.920 --> 01:29:54.920]  Всё.
[01:29:55.720 --> 01:29:57.240]  Да, и тут assignable, соответственно.
[01:29:57.320 --> 01:29:58.920]  Там было…
[01:29:59.000 --> 01:30:02.920]  copyconstructable — это именно конструктор, а тут присвоение.
[01:30:03.520 --> 01:30:06.560]  Окей, semi-regular — это копируемый,
[01:30:06.640 --> 01:30:10.000]  и можно по умолчанию унициализировать.
[01:30:10.080 --> 01:30:12.840]  И последнее, добавляется равенство.
[01:30:12.920 --> 01:30:15.360]  Regular is a quality comparable.
[01:30:16.080 --> 01:30:19.240]  То есть вот такие семейства, да, ещё…
[01:30:19.320 --> 01:30:21.520]  Ну, это сейчас словами скажу.
[01:30:22.520 --> 01:30:23.520]  Столбцы.
[01:30:23.600 --> 01:30:25.920]  Все эти семейства утверждаются,
[01:30:26.000 --> 01:30:31.440]  что 99,9% случаев ваш тип должен попадать в одно из них.
[01:30:32.480 --> 01:30:35.760]  Или ещё пятое, которое вообще ничего не удовлетворяет.
[01:30:35.840 --> 01:30:38.360]  movable — это всё, что похоже на Unique PTR.
[01:30:38.440 --> 01:30:41.120]  copyable — это всё, что похоже на структурку,
[01:30:41.200 --> 01:30:43.000]  где кто-то написал ссылку.
[01:30:44.240 --> 01:30:45.240]  Да?
[01:30:45.320 --> 01:30:48.760]  То есть, заметьте, копировать можно,
[01:30:48.840 --> 01:30:51.400]  а по умолчанию унициализировать нельзя.
[01:30:51.720 --> 01:30:52.720]  Дальше идём.
[01:30:52.800 --> 01:30:54.800]  Если по умолчанию унициализировать можно,
[01:30:54.880 --> 01:30:56.960]  то это, наверное, просто какая-то структурка,
[01:30:57.040 --> 01:30:58.880]  но сравнить её нельзя.
[01:30:58.960 --> 01:31:01.640]  А если мы regular, то с нами можно делать всё,
[01:31:01.720 --> 01:31:03.800]  и мы ведём себя как любые примитивные типы —
[01:31:03.880 --> 01:31:06.960]  инты, булы и прочее, ну или как Shert PTR.
[01:31:07.040 --> 01:31:10.240]  То есть вот все эти категории, они привычные программисту на C++.
[01:31:10.320 --> 01:31:13.480]  Если вы пишете что-то выбывающееся из этих категорий,
[01:31:13.560 --> 01:31:15.640]  то вас не поймут просто.
[01:31:15.720 --> 01:31:18.800]  И ещё раз напоминая, здесь и конструктор,
[01:31:18.880 --> 01:31:20.880]  и оператор требует mov,
[01:31:20.960 --> 01:31:22.720]  здесь и конструктор копирования,
[01:31:22.800 --> 01:31:25.120]  и оператор присваивания с копированием.
[01:31:25.920 --> 01:31:28.200]  Одно из них, если пишете, то вы не правы.
[01:31:30.520 --> 01:31:31.960]  Да, дальше пачка.
[01:31:32.040 --> 01:31:35.640]  Invokable — это что-то, что можно вызвать как функцию.
[01:31:35.720 --> 01:31:38.560]  Ну и там аргумент, соответственно, надо писать через запятую.
[01:31:38.640 --> 01:31:40.200]  Я думаю, вы такое уже писали.
[01:31:40.280 --> 01:31:43.360]  Regular Invokable — это тот же самый Invokable,
[01:31:43.440 --> 01:31:45.440]  но с equality preservation.
[01:31:45.520 --> 01:31:47.920]  Потому что вообще-то, бывает так,
[01:31:47.960 --> 01:31:50.280]  что вы хотите принять какую-то лямбду-функтор
[01:31:50.360 --> 01:31:51.520]  или ещё что-то в функцию,
[01:31:51.600 --> 01:31:54.440]  которая, в свою очередь, не equality preserving.
[01:31:54.520 --> 01:31:55.520]  Бывает.
[01:31:56.560 --> 01:31:59.360]  Вот для этого есть Invokable, не equality preserving,
[01:31:59.440 --> 01:32:01.680]  а Regular Invokable как бы подразумевает,
[01:32:01.760 --> 01:32:05.760]  что ваша лямбда не меняет никакие глобальные состояния и нормальное.
[01:32:05.840 --> 01:32:06.920]  Проверяется.
[01:32:07.000 --> 01:32:08.920]  Ну он подразумевает, но ничего не проверяет.
[01:32:09.000 --> 01:32:10.400]  Просто для экспозиции.
[01:32:10.480 --> 01:32:13.520]  Да, как бы это для того, чтобы программист проверил.
[01:32:13.600 --> 01:32:16.240]  Predicate — это просто аббревиатура типа что-то,
[01:32:16.280 --> 01:32:18.840]  что принимает T и возвращает буль.
[01:32:18.920 --> 01:32:21.720]  Equivalence Relation — это опять такая аббревиатура,
[01:32:21.800 --> 01:32:24.760]  что-то, что принимает пару T-шек и возвращает буль.
[01:32:24.840 --> 01:32:26.600]  Типа меньше или нет.
[01:32:26.680 --> 01:32:29.320]  Ну и вот этого вообще не будем про это потом.
[01:32:29.400 --> 01:32:31.320]  Вот, всё, пачка выводов.
[01:32:32.120 --> 01:32:35.320]  У нас плюсы вообще делятся на две такие половинки.
[01:32:35.400 --> 01:32:39.640]  Если мы их изучаем, то половинка про технику и половинка про дизайн.
[01:32:39.720 --> 01:32:43.040]  Сейчас я много-много техники набросал в начале,
[01:32:43.120 --> 01:32:44.680]  и в прошлый раз было много техники.
[01:32:44.760 --> 01:32:48.800]  Всякие вот наследования, шаблоны, виртуальные вызовы RTTI,
[01:32:48.880 --> 01:32:52.400]  всё эти фичи синтоксических языка — это всё техника,
[01:32:52.480 --> 01:32:55.280]  которая позволяет вам решать какие-то задачи.
[01:32:55.360 --> 01:32:57.640]  Ну такие мелкие, да, локальные.
[01:32:57.720 --> 01:32:58.920]  А есть отдельный дизайн,
[01:32:59.000 --> 01:33:01.400]  который при решении глобальных и крупных задач.
[01:33:01.480 --> 01:33:04.880]  Если вам пришли и сказали, нужна система, которая делает это,
[01:33:04.960 --> 01:33:06.880]  нужно такую систему раздизайнить,
[01:33:06.960 --> 01:33:09.120]  разбить на подкомпоненты, разбить на подзадачи,
[01:33:09.200 --> 01:33:11.920]  придумать абстракции, с которыми будет удобно работать и сейчас
[01:33:12.000 --> 01:33:13.280]  в рамках этой системы,
[01:33:13.360 --> 01:33:15.720]  и которые помогут вам эволюционировать её в будущем
[01:33:15.800 --> 01:33:18.160]  и не переписывать всё с нуля десять раз.
[01:33:18.240 --> 01:33:20.280]  То есть вот такие вот выделения абстракции, обобщения,
[01:33:20.360 --> 01:33:22.960]  построение архитектуры, это всё про дизайн.
[01:33:23.040 --> 01:33:26.000]  Вот если первому технике я вас легко могу научить
[01:33:26.080 --> 01:33:29.000]  или вы сами можете прочитать цепь референс и всё будет здорово,
[01:33:29.080 --> 01:33:31.600]  то вот этому почти невозможно научиться.
[01:33:31.680 --> 01:33:33.040]  Это такое ремесло.
[01:33:33.120 --> 01:33:36.480]  Нужно это делать десять раз, сто раз, тысяча раз,
[01:33:36.560 --> 01:33:38.520]  и в какой-то момент оно щёлкает.
[01:33:38.600 --> 01:33:41.280]  Поэтому сейчас мы долго и внимательно смотрели
[01:33:41.360 --> 01:33:44.280]  на существующие стандартные концепты.
[01:33:44.360 --> 01:33:46.120]  Из них должны сделать какой-то вывод,
[01:33:46.200 --> 01:33:49.920]  про то, как это вообще дизайнили, как это получилось
[01:33:50.000 --> 01:33:55.760]  и как этот инструмент технических концептов правильно использовать.
[01:33:55.840 --> 01:33:58.880]  То есть всё, что в стандартную библиотеку включено,
[01:33:58.960 --> 01:34:02.680]  считается правильными концептами, пока не доказано обратное.
[01:34:02.760 --> 01:34:05.480]  Когда вы пишете свои, берите с них пример, пожалуйста.
[01:34:06.000 --> 01:34:12.240]  Да, и соответственно, как ответы на все эти вопросы дать,
[01:34:12.320 --> 01:34:14.360]  вы можете только сами по ходу дела научиться,
[01:34:14.440 --> 01:34:16.280]  используя эти инструменты, пиша код,
[01:34:16.360 --> 01:34:18.520]  становляясь сеньорами-помидорами,
[01:34:18.600 --> 01:34:21.680]  по ходу дела как-то оно всё к вам придёт.
[01:34:21.760 --> 01:34:25.080]  Я как-то помочь могу, но не думаю, что сильно.
[01:34:25.160 --> 01:34:26.440]  Есть такая ссылка.
[01:34:26.520 --> 01:34:27.920]  Там немножко написано про то,
[01:34:28.000 --> 01:34:30.560]  как правильно применять инструменты концептов,
[01:34:30.640 --> 01:34:31.640]  а как неправильно.
[01:34:31.720 --> 01:34:35.200]  Мы сегодня уже видели какие-то отрывки оттуда.
[01:34:35.240 --> 01:34:37.360]  Да, и выстрелить себе в ногу здесь очень легко.
[01:34:37.440 --> 01:34:40.520]  Как обычно, будьте аккуратны, берегите себя и своих близких.
[01:34:40.600 --> 01:34:41.600]  И всё.
[01:34:42.920 --> 01:34:44.920]  Всем спасибо, все свободны.
