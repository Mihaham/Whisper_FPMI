[00:00.000 --> 00:08.500]  9 задача для этого вообще вспомним машины тюринга
[00:13.700 --> 00:21.000]  что это такое машина тюринга это один из способов формализовать понятие
[00:21.000 --> 00:30.000]  вычисления мы определяли его следующим образом входной алфавит сигма гамма
[00:30.000 --> 00:39.200]  ленточный алфавит дальше у нас было множество состояний букв кс от слова
[00:39.200 --> 00:49.600]  states с нулевое стартовое состояние мы говорили есть с accepted есть с rejected
[00:49.600 --> 00:58.480]  допускающие и отвергающие состояние есть функции дельта функции переходов и
[00:58.480 --> 01:18.920]  вроде бы все у нас будет ограничение следующее что гамма принадлежит к гамма без специально
[01:18.920 --> 01:34.760]  выделенного символа что с нулевое с а и с rejected это все некоторое состояние множество гамма меньше
[01:34.760 --> 01:42.840]  оно конечно аналогично множество с
[01:42.840 --> 01:54.120]  каких-то группу даже были кардиналы в этом году помним поэтому сохраним значки функцию дельту мы
[01:54.120 --> 02:05.480]  определяли следующим образом что сейчас давайте я взгляну что было раньше потому что сейчас я
[02:05.480 --> 02:24.720]  порядок изменил 100 процентов с гамма все я понял хорошо функция переходов она брала в себя
[02:24.720 --> 02:34.680]  некоторые состояния брала в себя некоторые символ и говорила что вот мы сейчас находимся
[02:34.680 --> 02:41.040]  в некотором состоянии с некоторым символом тогда мы переходим в новое состояние меняем
[02:41.040 --> 02:54.640]  этот символ на новый и выбираем одно из движений лево на месте права вот это наша классическая
[02:54.640 --> 03:06.000]  модель вычисления это все конечно хорошо прекрасно но это вообще неудобно ну то есть
[03:06.000 --> 03:15.800]  это совсем например у нас уже просто на уровне там процесса мы процесс-то какой-то приложение
[03:15.800 --> 03:21.400]  ой какая-то программа работающая у нас уже на уровне программы есть что у нас есть некоторая
[03:21.400 --> 03:39.320]  программа процесс у него есть input стд in есть стд out есть стд r и логично нам было бы их
[03:39.320 --> 03:46.480]  действительно как-то сепарировать чтобы были отдельные места где у нас хранится информация
[03:46.480 --> 03:51.640]  которая к нам пришла в качестве хода где-то мы отдельно пишем информацию качестве вывода
[03:51.640 --> 04:01.080]  ну вот например да еще где-то отдельно информацию напишем о том чтобы делать вывод более того это
[04:01.080 --> 04:18.920]  вот просто процесс у нас есть еще один момент у нас есть процессор у нас есть машиночка в нашей
[04:18.920 --> 04:29.760]  тачке там лежит цепу в этом цепу есть регистр и что как можно насмотреть вот на какой-нибудь
[04:29.760 --> 04:39.040]  ядро этого цепу что у нас есть входные данные они прям приходят такой пачкой пачка там столько
[04:39.040 --> 04:50.240]  сколько принимает этот регистр вот на регистр пиши данные у нас например 64 битная тачка обычный
[04:50.240 --> 05:01.560]  регистр не xmm ymm zmm а вот просто обычный там какой-нибудь ну давайте в что там x86 там
[05:01.560 --> 05:13.680]  какой-нибудь регистр rci вот 64 битика ему к нему прилетела вот такие вот ленты 64
[05:13.680 --> 05:21.600]  дальше он как-то там производит вычисление у себя соответственно для вычислений условно мы скажем
[05:21.600 --> 05:27.000]  что давайте вот здесь меня что-то будет как-то там с ним вычисляться и он выдаёт информацию
[05:27.000 --> 05:43.520]  но ведь на цепу там не один регистр а куча регистров и можем по идее как бы сказать
[05:43.520 --> 05:50.360]  что ну ок нам могут данные прийти которые больше чем и мы их равномерно разнесем по регистрам
[05:50.360 --> 05:58.640]  которые вычислят и соберут вместе тогда что же получается нас по сути своего рода многоленточная
[05:58.640 --> 06:12.760]  машина тюринга у которой есть венда входа input дальше у нее есть несколько лент для вычислений
[06:12.760 --> 06:19.360]  калк один от английского calculations
[06:19.360 --> 06:31.560]  калкен и у нас есть аутпут что такое не могу нормально рисовать
[06:31.560 --> 06:41.160]  здесь у нас мы можем только читать нам сюда только информацию подвезли
[06:41.160 --> 06:48.920]  здесь мы можем оперировать как угодно а здесь мы должны будем записать то есть
[06:48.920 --> 06:56.480]  начально здесь мы пустая лента а в конце она должна стать не пустой и пользователь будет
[06:56.480 --> 07:09.720]  ожидать что вывод машины тюринга на этой ленте как нам формализовать подобный агрегат ну если
[07:09.720 --> 07:11.720]  одна лента это вот оно
[07:22.720 --> 07:34.040]  то много лент это что это по сути одна большая лента вот такая вот считайте одна большая лента
[07:34.040 --> 07:43.120]  но в которой мы просто сделали или вот так вот полосочки и работаем как бы ячейка у нас
[07:43.120 --> 07:50.640]  теперь это одновременно склеенные раз два три сколько у нас здесь n плюс две ячейки в данном
[07:50.640 --> 08:00.040]  примере вот такими вот векторами нас ходит ну примерно как смотанализом сначала в первом
[08:00.040 --> 08:05.160]  семестре мы там с одновременными функциями потом во втором семестре hello world у нас
[08:05.160 --> 08:14.640]  пространство rn вот теперь мы начинаем работать в пространстве rn только в пространстве лента
[08:14.640 --> 08:30.360]  что же начнем погружаться в этот мордр итак у нас снова будет некоторые фавит сигма гамма
[08:30.360 --> 08:35.680]  точно также состояние ну то есть мы снова работаем как бы с одной лентой поэтому состояние не
[08:35.680 --> 08:45.440]  поменяется здесь accepted is rejected и дельта ну дельта это просто обозначение поэтому пока дельта
[08:45.440 --> 08:52.360]  не поменялась афавит и ну как раньше писали так и сейчас можно да на самом деле сказать давайте
[08:52.360 --> 09:00.480]  здесь будет алфавит для каждой ленты свой но давайте возьмем объединение всех этих фавитов
[09:00.480 --> 09:05.080]  положим его за сигмой будем жить в такой более простой модели не будем ему сына себе жизнь
[09:05.080 --> 09:09.960]  и у нас коленточная машина
[09:09.960 --> 09:15.040]  коленточная
[09:15.040 --> 09:24.200]  машина тюринга
[09:24.200 --> 09:38.520]  ну вот эти вот все условия про сигму гамму конечностей сохраняется
[09:38.520 --> 09:54.320]  а меняется главным образом именно тот элемент в котором зашифрована та интерпретация с
[09:54.320 --> 10:01.920]  бесконечными лентами это функции переходов на самом деле дельта она и есть своего рода
[10:01.920 --> 10:12.440]  формализация нашего нашей попытки интерпретировать вычисление как движение по бесконечной ленте и
[10:12.440 --> 10:22.120]  изменение символов что теперь какие у нас движение у нас движение мы все также можем двигаться либо
[10:22.120 --> 10:28.840]  влево либо вправо но теперь уже мы будем это делать по каждой ячейки то есть где-то мы здесь
[10:29.040 --> 10:35.000]  где-то мы сюда пройдем получается по каждой ячейке нам нужно будет совершать эти действия
[10:35.000 --> 10:42.400]  окей если по каждой ячейке мы говорим что это вектор вектор как у нас делается вот так вот
[10:42.400 --> 10:55.320]  хорошо состояние состояние мы помним что мы живем в том мире когда состояние как были раньше так
[10:55.320 --> 11:03.520]  и сейчас сейчас просто у нас лента теперь состоит не из ячейки а из вектора ячейки тогда
[11:03.520 --> 11:16.760]  гамма это символ станет вектором здесь гамма тоже станет вектор на этом все то есть мы буквально
[11:16.760 --> 11:26.640]  просто теперь работаем с многомерной ленты здесь
[11:35.160 --> 11:45.720]  пока сложно я думаю понять что происходит очень абстрактно далеко от жизни но
[11:45.720 --> 11:51.160]  рассмотрим сейчас пример и надеюсь все станет на свои места
[11:51.160 --> 11:57.000]  сейчас загляну где у меня сам пример
[11:57.000 --> 12:01.560]  вот
[12:01.560 --> 12:11.400]  сейчас
[12:11.400 --> 12:21.160]  ух
[12:21.160 --> 12:24.280]  я найду весна
[12:24.280 --> 12:28.200]  но она
[12:32.440 --> 12:39.880]  потерялся так здесь же те условия которые нужны
[12:39.880 --> 12:52.080]  на 29 я помню
[12:52.840 --> 12:54.400]  как
[12:54.400 --> 12:57.400]  у
[12:57.440 --> 13:04.400]  для
[13:04.400 --> 13:18.400]  можно
[13:18.400 --> 13:33.800]  О, хорошо. Поехали. Вот задача, будет следующая. Нам нужно будет построить машину тюринга,
[13:33.800 --> 13:55.400]  которая... Нет, я не то решал. Это не интересная задача,
[13:55.400 --> 14:13.600]  вот. Которая проверяет, что на вход пришло число вида 0 в степени n, 1 в степени m,
[14:13.600 --> 14:29.320]  0 в степени минимум из n и m. Что происходит? У нас получается, нам нужно быть сначала
[14:29.320 --> 14:38.560]  определить n, потом определить m, потом подсчитать функцию минимума и вывести...
[14:38.560 --> 14:50.920]  А, нам даже не выводить. Не нужно выводить. Если проверяет, то s-accepted, s-rejected. Мы просто
[14:50.920 --> 14:56.400]  проверим, что это так. Нам s-addout не понадобится. Поэтому поехали. Первое, что мы делаем,
[14:56.400 --> 15:15.160]  определяем какие у нас ленты в машине тюринга. Первое, стандартный вход. Второе. Итак, на
[15:15.160 --> 15:30.240]  первой ленте вычислений мы будем вычислять n. На второй ленте входа мы будем вычислять m. В чем
[15:30.240 --> 15:36.640]  плюс того, что я под каждое число выделяю свою ленту? Как только я его подсчитаю, у меня оно будет
[15:36.640 --> 15:43.480]  уже сохранено на этой ленте. Все. Я теперь смогу просто использовать соответствующую ленту движением
[15:43.480 --> 15:55.240]  головки. Дальше. Мне нужно будет вычислять минимум. Тогда завожу под него ленту. s-addout мне
[15:55.240 --> 16:10.840]  не нужно, поэтому все. Вот 4 ленты. Ну, определились. 4 ленты есть. Алфавит гамма. Задаем 0, 1,
[16:10.840 --> 16:30.000]  символ пустой. Дальше sigma 0, 1 и все. Еще, конечно, множество состояния мне нужно будет задавать,
[16:30.000 --> 16:42.160]  но я его задам в конце, когда я пойму, сколько всего состояния мне понадобится. Начнем. Начинается
[16:42.160 --> 16:58.560]  все с того, что нужно определить, как мы будем подсчитывать nm. Что мне выбрать в качестве базиса.
[16:58.560 --> 17:04.920]  Там, например, числа можно раскладывать в различные системы счастливее. В зависимости
[17:04.920 --> 17:11.360]  того, в какой системе счастливее мы раскладываем, по-разному будут вестись там вычисления. Я
[17:11.360 --> 17:17.040]  предлагаю, так как нам нужно вычитывать минимум, использовать унарную систему счастливее. То есть,
[17:17.040 --> 17:24.040]  мы просто поставим n палочек, m палочек, а минимум это наименьший из них. В таком случае минимум
[17:24.040 --> 17:36.200]  будет высчитываться каким образом. Вот у меня есть просто числа палочек. Мы начнем с края и вправо до
[17:36.200 --> 17:43.120]  тех пор, пока на одной из лент мы не встретим решетку. Как только мы встретили решетку,
[17:43.120 --> 17:51.040]  мы остановимся. Перед этим мы будем просто брать и записывать подряд единички.
[17:51.040 --> 18:04.240]  Встретили эту, остановились. У нас есть минимум.
[18:04.240 --> 18:19.880]  Аналогичным способом, но если мы будем хранить в бинарной системе счастливее, то есть там 0 единицы,
[18:19.880 --> 18:28.360]  как двоичный код, то аналогичным способом можно вычислять функцию побитого сложения.
[18:28.360 --> 18:37.440]  Побитое сложение вычисляется следующим образом, пока в обеих лентах не встретим вланг.
[18:37.440 --> 18:54.600]  Сумму уже сложнее. Сумму нам нужно будет, например, суммой. Сумма на самом деле проще в унарной.
[18:54.600 --> 19:01.600]  Что такое сумма в унарной? Это мы переписали все палочки сюда, потом стали переписывать все палочки
[19:01.960 --> 19:19.640]  Закончили. Начнем и начинаем мы с прочтения. Итак, у нас что? Должна принять состояние и какие-то данные.
[19:19.640 --> 19:34.880]  Говорим, что вот функция Delta, мы ее сдаем. Мы принимаем состояние с 0, на трех лентах у нас ничего нет.
[19:34.880 --> 19:41.680]  Давайте дополнительно укажем какое вообще начальное состояние у нашей машины.
[19:41.680 --> 19:55.040]  На лентах 2-4 произвольное место.
[19:55.040 --> 20:23.200]  На ленте 1 пишущая головка указывает на начало.
[20:23.200 --> 20:40.240]  Все, пояснили какое начальное состояние у машины тюринга.
[20:40.240 --> 21:02.280]  На самом деле состояние с 0, оно может сначала принимать вот такие два вариации.
[21:02.320 --> 21:12.320]  Когда у нас на входе 0, то есть мы сейчас считываем 0, в таком случае нам нужно будет перейти к 0.
[21:12.320 --> 21:24.320]  Ленту входа мы не изменяем, мы по ней только читаем. Мы сдвинулись вправо, прочитали, перешли к следующему.
[21:24.360 --> 21:30.360]  Здесь, тогда что? Если мы прочитали 0, нам нужно увеличить на 1 количество единиц.
[21:30.360 --> 21:36.360]  Количество единиц у нас в второй ленте. Тогда мы записали сюда единичку, сдвинулись вправо.
[21:36.360 --> 21:44.360]  В унарной системе увеличение на 1, это просто до запись еще одной единицы.
[21:44.360 --> 21:52.360]  Остальное все не изменно.
[21:52.400 --> 21:58.400]  И мы переходим в какое состояние? В состояние с 0.
[21:58.440 --> 22:04.440]  С 0 у нас чтение.
[22:07.440 --> 22:12.440]  Хорошо. С 0 могло на самом деле встретить единицу.
[22:12.480 --> 22:22.480]  Что в таком случае?
[22:22.480 --> 22:38.480]  Если единица, мы оставим единицу, но будем в некотором смысле соответствовать принципу единственности ответственности.
[22:38.520 --> 22:46.520]  У нас есть одно состояние, плюс это одно состояние отвечает какой-то одной задачи.
[22:46.520 --> 22:50.520]  Не будем в одно состояние пихать много заданий.
[22:50.520 --> 22:58.520]  Легко запутаемся и не сможем написать нормальную машину тюринга.
[22:58.560 --> 23:04.560]  Тогда что? Давайте сушать ответственность.
[23:04.560 --> 23:10.560]  С теперь будет не просто чтением, а чтением нулей.
[23:10.560 --> 23:16.560]  В начале. У нас же есть нули в начале, нули в конце.
[23:16.600 --> 23:22.600]  Сейчас я все отмечу, чтобы не забыть пункт.
[23:28.600 --> 23:34.600]  Так вот, мы уже закончили.
[23:34.640 --> 23:40.640]  Если мы вдруг дошли до единицы, нам нужно перейти в новое состояние.
[23:40.640 --> 23:46.640]  Как мы перейдем в новое состояние? Мы ничего не изменим на ленте.
[23:46.640 --> 23:54.640]  По сути, применили функцию identity и сменили на новое состояние S1.
[23:54.680 --> 23:58.680]  Как будет работать S1?
[23:58.680 --> 24:02.680]  С1. Его задача следующая.
[24:02.680 --> 24:06.680]  Посчитать теперь единицы.
[24:06.680 --> 24:12.680]  С1. Чтение единиц.
[24:14.680 --> 24:18.680]  Буха.
[24:18.720 --> 24:22.720]  S1 должен принимать один.
[24:22.720 --> 24:26.720]  Здесь пустоту.
[24:26.720 --> 24:30.720]  Тогда он не изменяет ленту входа, но сдвигается вправо.
[24:30.720 --> 24:34.720]  Мучили эту единицу.
[24:34.720 --> 24:40.720]  Он должен...
[24:40.760 --> 25:00.760]  Он должен не изменить количество нулей и увеличить на один число единиц.
[25:00.760 --> 25:06.760]  Лент, конечно же, ответственную за минимум не меняем.
[25:06.800 --> 25:14.800]  Хорошо. Дальше S1 может встретить у нас ноль.
[25:18.800 --> 25:22.800]  В таком случае мы должны будем остановиться, потому что все.
[25:22.800 --> 25:26.800]  На этом чтение единиц закончено.
[25:26.800 --> 25:34.800]  Применяем функцию identity и меняем состояние на S2.
[25:36.800 --> 25:40.800]  На S2 пока мы остановим.
[25:40.800 --> 25:44.800]  Потому что дальше S2, что она должна будет сделать?
[25:44.800 --> 25:52.800]  Она должна будет переключиться на вычисление минимума.
[25:52.800 --> 25:54.800]  То есть здесь это мы прочли.
[25:54.800 --> 25:56.800]  Теперь нам нужно будет прочесть это.
[25:56.800 --> 26:01.800]  Но для того, чтобы прочесть оставшуюся единицу,
[26:01.840 --> 26:03.840]  нам нужно подсчитать минимум.
[26:03.840 --> 26:11.840]  Значит, мы будем переходить в состояние, которое начнем считать минимумом.
[26:21.840 --> 26:23.840]  Начнем.
[26:23.880 --> 26:26.880]  Я думаю, просто сейчас сделать или нет.
[26:26.880 --> 26:30.880]  Давайте сейчас я попробую сразу сказать.
[26:30.880 --> 26:33.880]  У нас здесь рассмотрено в случае нулей и единиц.
[26:33.880 --> 26:35.880]  Здесь тоже 1 и 0.
[26:35.880 --> 26:38.880]  Но ведь у нас могут быть плохие строки.
[26:38.880 --> 26:42.880]  Например, у нас может прийти строка из только нулей.
[26:42.920 --> 26:50.920]  В таком случае, если нам пришла строка из n, вот такая,
[26:50.920 --> 26:54.920]  нам нужно проверить, что n делится на 2.
[26:54.960 --> 26:57.960]  Для этого мы просто перейдем в новое состояние.
[26:57.960 --> 26:59.960]  Я пока его не запишу.
[26:59.960 --> 27:03.960]  Запишем после того, как пройдем нужное число.
[27:05.960 --> 27:10.960]  В таком случае, если нам пришла строка из n, вот такая,
[27:10.960 --> 27:14.960]  нам нужно проверить, что n делится на 2.
[27:15.000 --> 27:17.000]  Мы просто перейдем в новое состояние.
[27:17.000 --> 27:19.000]  Я пока его не запишу.
[27:19.000 --> 27:23.000]  Запишем после того, как пройдем нужное число.
[27:25.000 --> 27:27.000]  Пока оставим.
[27:27.000 --> 27:34.000]  В случае единиц, в случае с 1, мы также можем встретить пустое.
[27:34.000 --> 27:40.000]  То есть это означает, что мы прошли 0, дальше встретили n.
[27:40.040 --> 27:46.040]  А дальше мы пришли в состояние пусто.
[27:46.040 --> 27:48.040]  То есть здесь нет нулей.
[27:48.040 --> 27:55.040]  Как мы понимаем, что, например, n в таком случае будет уже хотя бы единица.
[27:55.040 --> 28:00.040]  Ну, потому что мы в 1 попадаем, когда мы точно встретили единицу.
[28:00.040 --> 28:06.040]  Тогда справа должно быть уже больше 1 нуля, а его нет.
[28:06.040 --> 28:09.040]  Значит, это число уже не подходит.
[28:09.080 --> 28:15.080]  А значит, мы можем уже один выход из вычисления написать.
[28:15.080 --> 28:17.080]  S1.
[28:17.080 --> 28:20.080]  Если оно встретит внезапно решетку.
[28:22.080 --> 28:25.080]  Решетка, решетка, решетка.
[28:25.080 --> 28:31.080]  То мы ничего делать не будем.
[28:33.080 --> 28:36.080]  Но перейдем в состояние Sr.
[28:36.080 --> 28:38.080]  Все.
[28:38.120 --> 28:46.120]  Вышли из подсчета.
[29:00.120 --> 29:04.120]  Начнем подсчитывать минимум.
[29:08.120 --> 29:13.120]  Минимум я уже сказал, что мы начнем просто двигаться по лентам, пока не есть.
[29:13.120 --> 29:18.120]  Но чтобы двигаться по лентам, скажу.
[29:19.120 --> 29:24.120]  У нас на лентах имеется следующее состояние.
[29:25.120 --> 29:27.120]  Денички.
[29:28.120 --> 29:31.120]  Это лента n, это лента m.
[29:31.160 --> 29:34.160]  Это лента n, это лента m.
[29:39.160 --> 29:44.160]  И у нас сейчас мы лежим в этой ячейке, а здесь в этой ячейке.
[29:45.160 --> 29:51.160]  Мы начнем постепенно сдвигаться по двум ячейкам сразу вправо.
[29:53.160 --> 29:56.160]  До тех пор, пока одна из них не встретит
[29:56.200 --> 30:00.200]  символ решетки.
[30:01.200 --> 30:10.200]  Причем каждый раз, когда мы сдвигаемся, мы будем записывать единицу в ленту минимума.
[30:17.200 --> 30:19.200]  Давайте это как-то формулизуем.
[30:19.200 --> 30:22.200]  У нас вот состояние S2.
[30:22.240 --> 30:24.240]  S2.
[30:29.240 --> 30:35.240]  Я скажу так, чтобы не было сверху прочерк.
[30:37.240 --> 30:41.240]  Здесь один, здесь один.
[30:44.240 --> 30:46.240]  Прошу прощения.
[30:46.280 --> 30:51.280]  Нам нужно будет как раз здесь сделать не n, а l.
[30:53.280 --> 30:55.280]  Для чего мы это делаем?
[30:57.280 --> 31:06.280]  У нас каждый раз, когда мы записывали в эту ленту, мы записали единицу в ячейку и сдвинулись в следующее соседнее вправо.
[31:07.280 --> 31:11.280]  Теперь мы должны будем идти, пока у нас встречается единица.
[31:11.320 --> 31:18.320]  Поэтому для того, чтобы начать следующую терацию, нам нужно будет вернуться обратно на единицу.
[31:19.320 --> 31:21.320]  Вот ровно это мы сделаем на S и L.
[31:22.320 --> 31:27.320]  Если внезапно там оказалось, что их нету,
[31:30.320 --> 31:39.320]  ну то есть ну, нулей не было, единиц не было, ну мы просто попадем в пустоту, значит, ничего не прочитали.
[31:39.360 --> 31:46.360]  Тогда и у нас терация не пойдет в следующее для вычисления минимума, ну и мы получим, по сути, ноль.
[31:47.360 --> 31:48.360]  Так что все хорошо.
[31:49.360 --> 31:51.360]  Итак, S2.
[31:52.360 --> 31:54.360]  Она принимает что-либо на первой ленте.
[31:56.360 --> 32:03.360]  Дальше, на второй ленте она принимает единицу, единицу.
[32:03.400 --> 32:04.400]  Единицу.
[32:05.400 --> 32:06.400]  Единицу.
[32:07.400 --> 32:13.400]  Здесь будет символ решетка и сдвигается следующим образом.
[32:16.400 --> 32:21.400]  Мы сохраняем то, что было на первой ленте, записываем 1, 1 здесь.
[32:22.400 --> 32:28.400]  И также записываем 1 в вправо к ленте минимума.
[32:28.440 --> 32:33.440]  Здесь мы сдвинемся в R, здесь в L, здесь на месте.
[32:34.440 --> 32:42.440]  Нам важно сохранить позицию в ленте вода, поэтому мы пишем ZN.
[32:45.440 --> 32:47.440]  Два других случая, когда...
[32:47.480 --> 32:57.480]  Если здесь у нас что-либо, у нас решетка, снизу что-либо, здесь решетка.
[32:58.480 --> 33:00.480]  Мы переходим следующим образом.
[33:01.480 --> 33:08.480]  Здесь остались на месте, остались на месте, остались на месте.
[33:08.520 --> 33:16.520]  И перешли, здесь нужно не звать, здесь S2 будет, а здесь мы перейдем в новостное состояние, в S3.
[33:17.520 --> 33:22.520]  И аналогично в симметричном случае.
[33:28.520 --> 33:31.520]  Если у нас встретилась решетка снизу,
[33:31.560 --> 33:34.560]  если у нас встретилась решетка снизу,
[33:38.560 --> 33:41.560]  то мы также завершаемся.
[33:41.600 --> 33:49.600]  На момент перехода в состоянии S3 мы теперь имеем подсчитанный минимум на 4 ленте.
[34:00.600 --> 34:08.600]  На момент перехода в состояние S3 мы теперь имеем подсчитанный минимум на 4 ленте.
[34:11.560 --> 34:28.080]  что мы теперь делаем теперь если мы имеем подсчетный минимум мы знаем что
[34:28.080 --> 34:41.160]  сверху у нас нули нули единицы то нужно будет просто проверить что у нулей
[34:41.160 --> 34:54.360]  оставшихся ровно нужное число как мы это будем делать на ленте минимума мы стоим здесь а дальше
[34:54.360 --> 35:03.120]  ровно столько единичек сколько должно быть нулей то есть мы можем делать следующим образом давайте
[35:03.120 --> 35:13.000]  аналогично вернемся в единичку и дальше начнем шагать следующим образом 1 0 двигаемся вот сюда и
[35:13.000 --> 35:22.080]  мы должны будем дойти до состояния когда одновременно упремся в решетке в таком случае победа
[35:22.080 --> 35:31.840]  если мы пришли в состояние 0 решетка или решетка 1 значит у нас количество нулей и
[35:31.840 --> 35:41.960]  количества минимумов не совпало берем здесь исправляем что нам нужно будет в случае завершения
[35:41.960 --> 35:55.280]  с подсчета числа сдвинуться вправо бжух ой прошу прощения это мы сдвигались сюда нам
[35:55.280 --> 36:04.760]  нужно будет сдвигаться влево сдвигаться влево здесь у нас да нужно будет на врат найти здесь
[36:04.760 --> 36:23.600]  влево здесь влево има состояние с 3 поехали с 3 как она работает с 3 должно работать следующим
[36:23.600 --> 36:34.200]  образом если мы встретили 0 не пойми что здесь не пойми что что угодно здесь что угодно здесь и
[36:34.200 --> 36:47.560]  один здесь то мы можем спокойно сдвигаться а здесь влево у нас к сожалению здесь придется идти в
[36:47.560 --> 37:01.440]  обратном порядке а по ленте входа вправо и двигаться с 3 если с 3 встретит внезапно 0 здесь решет
[37:01.440 --> 37:14.720]  вот беда у нас не совпало минимум и тот значит мы ну по традиции сохраняем все как есть и завершаем
[37:14.720 --> 37:31.920]  работу если с 3 решетка что угодно 0 аналогично прошлому завершаем выполнение
[37:31.920 --> 37:48.040]  0 там этого появиться не может здесь ну для
[37:48.040 --> 38:01.080]  здесь один же только да здесь все и опять же остался только один интересный случай мы встретили
[38:01.080 --> 38:09.160]  единицу где-то если мы встретили внезапно единицу и что угодно здесь то беда мы не должны были
[38:09.160 --> 38:20.360]  встречать единицу дальше только нули идут то сохраняем позиции конечно нет числа плохое
[38:20.360 --> 38:36.080]  останется один интересный случай когда мы одновременно пришли в и там и там одновременно
[38:36.080 --> 39:00.160]  свершились то это победа это с accept осталось одно важное но которое мы как раз тогда были
[39:00.160 --> 39:21.040]  как быть в случае если у нас только нули тогда нам нужно будет отвезти сейчас скажу
[39:21.040 --> 39:36.640]  особое состояние здесь 0 0 0 0 0 это с 0 давайте мы сделаем следующие с 2
[39:36.640 --> 39:48.280]  если она встретила решетку то значит все слово которое нам подали это нули что угодно что угодно
[39:48.280 --> 40:06.400]  что угодно мы перейдем в куда оставим все как есть и нам нужно будет теперь понять как нам
[40:06.400 --> 40:12.520]  проверить начетность что значит проверить начетность проверить начетность можно следующим
[40:12.520 --> 40:18.680]  образом как я предлагаю делать что мы будем идти в обратном направлении то есть по нулям
[40:18.680 --> 40:47.840]  и поочередно записывать один в кудам я буду постепенно записывать один
[40:47.840 --> 40:55.600]  сначала а потом я буду то один стирать и в конце мне останется проверить вообще у меня есть ли
[40:55.600 --> 41:03.800]  один или нет то есть что буду происходить когда я делаю один шаг я записываю один когда я делаю
[41:03.800 --> 41:11.080]  второй шаг я этот единичку стираю я делаю снова новый нечетный шаг я заново записываю
[41:11.080 --> 41:19.680]  единицу делаю четный шаг стираю если у меня будет в итоге четное число шагов то единицы не
[41:19.680 --> 41:30.160]  будет если нечетная то у меня будет один мне нужно будет на какой-то это ленте писать причем
[41:30.160 --> 41:37.960]  мне нужна гарантия что изначально вообще там ничего не было для этого мне идеально подойдет
[41:37.960 --> 41:45.880]  лента которая точно еще нигде не используется и пустая это лента минимум поэтому теперь она не
[41:45.880 --> 41:54.640]  только лентам минимум но и лет лента четности я могу вообще вынести в отдельную ленту например
[41:54.640 --> 42:04.440]  подсчет четности но сейчас я не хочу усложнять модель и писать еще пятый пятую строку абсолютно
[42:04.440 --> 42:10.960]  бесполезно везде просьба там будет сохранение и на месте поэтому я просто переиспользую уже
[42:10.960 --> 42:21.360]  имеющиеся ресурсы так у меня есть но не новое некоторое состояние здесь я сгинусь влево снова
[42:21.360 --> 42:30.920]  все тот же трюк когда мы прошлись стоим сразу после окончания последовательности и движением
[42:30.920 --> 42:37.040]  назад мы на него возвращаемся и нужно новое состояние последнее состояние которое мы
[42:37.040 --> 42:47.320]  использовали это было эстей значит я теперь леша есть 4 и так есть 4 есть 4 может принимать только
[42:47.320 --> 43:09.920]  0 0 что угодно как что угодно здесь будет пусто на ленте четности мы идем 0 влево все сохраняем
[43:09.920 --> 43:22.720]  на месте а здесь записываем один и вправо то есть на ленте минимума случилось следующее была
[43:22.720 --> 43:38.240]  решетка я на нее указывал теперь стала единица я остаюсь здесь дальше я перехожу уже в новое
[43:38.240 --> 43:43.560]  состояние потому что ну здесь будет пусто поэтому конфигурация храницы мне запустится
[43:43.560 --> 44:06.520]  стани с 4 мне нужно новое с 5 если с 5 получит 0 ой на месте давайте сохранюсь там не нужно
[44:06.520 --> 44:14.120]  сохраняться на месте и тогда мне не нужна с 5 я буду использовать с 4 здесь на решетке а
[44:14.120 --> 44:25.480]  здесь с 4 на единицы мы поменяем четность будет 0 влево на месте на месте опустошу
[44:25.480 --> 44:39.760]  4 теперь выход и состояние с 4 с 4 может выходить только в состоянии решетки на первой ленте
[44:39.760 --> 44:48.240]  здесь нам без разницы что а снизу у нас два варианта либо это решетка тогда победа это
[44:48.240 --> 44:57.680]  четное число значит такое возможно скажу сейчас погодите что это плюм
[44:57.680 --> 45:11.880]  0 в степени n 1 0 это 0 в нулевой это просто 0 вн ты все нам даже не нужно
[45:12.240 --> 45:23.400]  на четности это я начал тупить это 0 вн тей поэтому любая последность из просто нулей она подходит
[45:23.400 --> 45:38.600]  тогда нам нужно будет сделать следующие с 0 сучьей решетки ну просто где где где где где где где
[45:38.600 --> 45:48.440]  у меня какой с 2 0 сучьей решетки это просто победа
[45:48.440 --> 46:02.600]  я с 1 0 сюда мы прошли прошли прошли прошли прошли прошли прошли мне кажется я просто
[46:02.600 --> 46:24.800]  сейчас с 3 а где за использовать штуку давайте думать я где-то это определил где я не помню
[46:24.800 --> 46:44.400]  где вот не оно ли это с 1 с 1 перешло вот 2 с 2 дальше оно работает так
[46:44.400 --> 46:58.440]  с 2 подсчет минимум да вот это с 0 это не с 1 это вот с 0 и в данном случае просто ничего не
[46:58.440 --> 47:08.280]  делаю я перехожу с accepted потому что это в таком случае у меня просто строка из нулей а строка
[47:08.280 --> 47:20.200]  из нулей удовлетворяет этому соотношению именно поэтому даже случай 0 1 0 0 равняется
[47:20.200 --> 47:30.960]  и все но все ок вот это вот ненужное
[47:30.960 --> 47:47.120]  в итоге вот наше писание машины тюринга отсюда до сюда дальше ну если предположим там придется
[47:47.120 --> 47:53.160]  где-то понадобится счетность здесь вот мы так в бите просчитали счетность и зависимости от того
[47:53.160 --> 48:02.840]  что мы увидели нужно будет просто все сохраняем это было решетка ты четность поэтому это было
[48:02.960 --> 48:16.720]  accepted а с4 решетка ничего ничего один решетка ничего ничего один все сохранили как есть но выше
[48:16.720 --> 48:30.200]  уже срежать если вы пытались это записать на там одноляточной машине тюринга я более чем
[48:30.200 --> 48:39.240]  уверен что вы мне обошлись таким часом состояние а каким именно самое время записать здесь нужно
[48:39.240 --> 48:53.480]  будет оказать что множество s этом с с а ср это дефолтные плюс нам понадобились от 1 до 3
[48:53.480 --> 49:06.560]  3 дополнительных состояние это очень мало все достаточно компактно мы понимаем что
[49:06.560 --> 49:11.120]  вот каждое состояние это какое-то действие у нас есть особые случаи
[49:11.120 --> 49:26.080]  здесь все дальше s3 у нас за что отвечал у нас с 3 за
[49:26.080 --> 49:54.480]  равенство 0 или в конце часа нулей минимум из n я вот настоятельно
[49:54.480 --> 49:59.920]  рекомендую в этой задаче попробовать подумать про многоленточную машину тюринга она должна
[49:59.920 --> 50:07.080]  упростить более того вообще почему она упрощает у нас есть теория мы про то как можно модифицировать
[50:07.080 --> 50:15.480]  машины тюринга у нас есть произвольная машина тюринга одноленточная мы можем первым делом ее
[50:15.480 --> 50:22.520]  перевести в ограниченную давайте слева
[50:32.200 --> 50:43.080]  как нам это сделать нам рассказать что они эквалентны нам просто нужно в этой машине тюринга
[50:45.480 --> 50:56.960]  выделить некоторые некоторую ячейку и дальше сейчас скажу
[50:56.960 --> 51:11.800]  да здесь мы разобьем их почетности соответственно здесь аналогично относительно этого нуля мы пойдем
[51:11.800 --> 51:29.080]  в одну сторону например четно другую нечетно и сейчас да и подсчитывая что движение сюда мы
[51:29.080 --> 51:35.160]  можем почитать сколько мы двинулись здесь соответственно на нужное число раз отодвинуться
[51:35.160 --> 51:42.240]  в соответственности отчетности и посчитать многоленточные машины тюринга удобно делать
[51:42.240 --> 51:50.160]  следующим образом одну ленту превращаем в бесконечную одну сторону дальше бесконечно
[51:50.160 --> 52:00.320]  одну сторону дробим по какому-нибудь модулю то есть выделяем отсюда там числа сравнимый с
[52:00.320 --> 52:08.880]  один по некоторым модуле модуле это число лент там 1 будет 2 3 так далее и 1 2 3 так далее
[52:08.880 --> 52:25.080]  им дальше их все мы начинаем превращать в ленты м штук и потом каждую из них раскрываем в
[52:25.080 --> 52:37.320]  полноценную ленту и вот таким вот транзитивным способом мы имеем эквивалентность многоленточных
[52:37.320 --> 52:48.560]  машин тюринга одноленточных если честно вот сейчас насчет этого я возможно где-то ошибся
[52:48.560 --> 52:59.160]  не совсем помню как эквалентность прям четко доказывается это точно так это прям факт здесь
[52:59.160 --> 53:07.240]  мог немножко наложать поэтому если будете готовиться почему-то проверьте что в теории так
[53:07.240 --> 53:17.920]  у кого-то может быть есть вопросы по
[53:17.920 --> 53:25.320]  щас скажу по многоленточную машину тюринга
[53:25.320 --> 53:43.400]  а я вообще жив
[53:51.400 --> 53:55.040]  супер вопросов нету получается да
[53:55.320 --> 53:56.160]  все понятно
[54:05.320 --> 54:19.040]  супер хорошо в общем тогда надеюсь 29 номер хорошо пройдет поехали в этот раз мы разбираемся
[54:19.040 --> 54:37.280]  с щас скажу чем мы разбираемся можно глянуть мы будем разбираться с универсальностью
[54:37.280 --> 54:53.240]  главное универсальное мне почему-то триггеры что я в прошлый раз это уже рассказывал про
[54:53.240 --> 55:08.920]  универсальность числи мы странно я думал уже рассказывать текст идем дальше тогда начнем
[55:08.920 --> 55:26.800]  говорить про универсальность так у нас есть понятие универсальность универсальность это
[55:26.800 --> 55:33.880]  свойства машин тюринга свойства мы помним что такое свойства
[55:33.880 --> 55:45.760]  свойства из окотача первого семестра это у нас предикат унарный
[55:45.760 --> 55:59.880]  с одной стороны мы помним что предикат и мы можем интерпретировать как функции из некоторого
[55:59.880 --> 56:12.520]  носителя в это в 0 1 где 0 1 были его константы либо как некоторые под множество n ты степень
[56:13.080 --> 56:18.720]  данном случае мы будем интерпретировать именно вторым способом свойства это
[56:18.720 --> 56:26.320]  некоторое под множество давайте я скажу что у нас есть
[56:26.320 --> 56:33.800]  countable
[56:33.800 --> 56:43.320]  вроде сейчас я проверю
[56:43.320 --> 56:50.560]  это их сейчас путаю
[56:50.560 --> 57:00.760]  вычислимые функции это
[57:00.760 --> 57:09.880]  компьютер был все я плыву
[57:09.880 --> 57:28.080]  компьют это был множество всех вычислимых функций ну множество опять же такое страшные
[57:28.080 --> 57:41.720]  слова скажем что это все вычислимые функции не будем говорить точно множество это или нет
[57:41.720 --> 57:52.840]  это некий некий такой класс функций причем мы скажем что не все вычислимые функции там на
[57:52.840 --> 57:58.680]  самом деле можно говорить что там все вычислимые функции такого-то количество аргументов вот мы
[57:58.680 --> 58:07.000]  сейчас будем рассматривать для количества аргументов где n равняется 1 универсально
[58:07.200 --> 58:23.920]  функции для функций одного аргумента этого у нас были обычные f из n в какие требования
[58:23.920 --> 58:45.440]  к универсальной вычислимой функции у в почти как увы но только у в в в давайте дадим более
[58:45.440 --> 58:56.240]  абстрактное определение поэтому скажем для класса c у нас не есть некоторый класс функций
[58:56.240 --> 59:06.440]  так вот универсальные функции для некоторой класса ц должна была дать для нас свойственные первое
[59:06.440 --> 59:33.120]  что она вычислима причем давайте класс c из унарных вот n вен это вот какой-то функции да давайте вот
[59:33.120 --> 59:51.360]  даже не так некоторые под множество давайте просто из она она вычислима как функции двух
[59:51.360 --> 01:00:02.760]  аргументов не будем просто писать то есть у нас универсальная функция она будет иметь на
[01:00:02.760 --> 01:00:08.640]  один аргумент больше она будет бинарной и поэтому теперь вычислимость нам нужна не просто что она
[01:00:08.640 --> 01:00:13.360]  будет вычислима а что она вычислима как функции двух аргументов что теперь по сеточке мы можем
[01:00:13.360 --> 01:00:22.880]  это его вычислять нормально все также теперь главное почему она универсальная это что для
[01:00:22.880 --> 01:00:39.880]  любой функции с класса c будет существовать ее номер такой что f это есть вот давайте
[01:00:40.080 --> 01:00:47.320]  у в ф будут называть как у у н нулевого
[01:00:47.320 --> 01:01:03.880]  то есть функция она будет по второму аргументу 1 мы зафиксируем второй сохраним также мы
[01:01:03.880 --> 01:01:12.800]  договоримся использовать следующую нотацию что у n t от x это есть не что иное как у n x
[01:01:33.880 --> 01:01:47.400]  я реально определённо это рассказывал хорошо и дальше у нас появляется более сильное условие
[01:01:47.400 --> 01:01:54.560]  которое заключается в том что мы хотим главность
[01:01:54.560 --> 01:02:09.640]  главную универсально участимая функция и так снова для класса c
[01:02:09.640 --> 01:02:21.240]  ну если это главная универсально участимая функция то теперь мы требуем что не в санкции
[01:02:21.240 --> 01:02:33.280]  функции как здесь у нас была участимая функция участима универсально участимая
[01:02:33.280 --> 01:02:48.320]  универсально участима все и теперь нам нужна главность что было такого в uvf в чем она могла
[01:02:48.320 --> 01:02:57.800]  быть нехорошей у нас для каждой функции c мы ее можем поместить проекцию в сечение то есть у нас
[01:02:57.800 --> 01:03:09.400]  у это табличка функции все появлялись как коризонтальные сечения если здесь у нас
[01:03:09.400 --> 01:03:23.480]  здесь здесь здесь n здесь x то вот они были сечениями но могло оказаться что у нас вдруг
[01:03:23.480 --> 01:03:29.960]  затаилось где-то лишние сечения которые выходят из этого класса и сама функция содержит что-то
[01:03:29.960 --> 01:03:46.160]  лишнее поэтому теперь мы говорим что давайте теперь любое сечение для любого n выполняется
[01:03:46.160 --> 01:03:54.520]  что у n вот функции по второму аргументу она лежит в классе заданном
[01:03:54.520 --> 01:04:06.480]  еще
[01:04:06.480 --> 01:04:22.000]  нет я это все я не что-то плыву что-то я плыву и сильно это третье условие в
[01:04:22.000 --> 01:04:39.040]  это было третье условие для класса то есть первые условия численности второе это условия
[01:04:39.040 --> 01:04:42.600]  универсальности а третье что она для класса то есть мы не выходим за класс
[01:04:42.600 --> 01:05:06.760]  универсально учителя функции универсально учителя для класса а второе это что для любого вычислителя
[01:05:13.500 --> 01:05:19.720]  это же что такое то компьютобл
[01:05:19.720 --> 01:05:40.440]  бинарных найдется такое t из класса тотальных функций что для любого n
[01:05:40.440 --> 01:05:50.840]  для любого x будет выполняться следующее что универсальные числи мы главные универсальные
[01:05:50.840 --> 01:06:00.480]  числа моя функция мы пытаемся творить некоторый беспорядок на не беспорядок
[01:06:00.480 --> 01:06:15.520]  короче некоторую такую перемешанину на ее строчках это будет какая-то вот такая функция
[01:06:15.520 --> 01:06:26.280]  то есть идея в чем что какой бы мы другую теперь не взяли бинар какой бы другой бинарный
[01:06:26.280 --> 01:06:35.960]  учителя мы не взяли мы сможем его получить из универсально учителя функции поэтому она
[01:06:35.960 --> 01:06:53.960]  главная то есть любой другой к ней сведется есть на касательно этой функции интересная теорема
[01:06:53.960 --> 01:06:56.280]  называется теорема к линии неподвижной точки
[01:06:56.280 --> 01:07:10.160]  звучит на следующем образом что пусть у
[01:07:10.160 --> 01:07:19.880]  nx главная универсально учтимая функция у нас есть некоторые тотальные функции
[01:07:19.880 --> 01:07:27.400]  тогда для любого nx
[01:07:27.400 --> 01:07:47.200]  сейчас тогда найдется такое n дайте назовем его n с чертой что у n с чертой x будет равняться
[01:07:47.200 --> 01:08:00.880]  у от t от nx идея следующая что что какой бы мы тотальные функции не пытались в ней двигать
[01:08:00.880 --> 01:08:11.520]  столбцы какой-то из этих столбцов обязательно сохранить свою позицию в этом ее тотальность
[01:08:11.520 --> 01:08:33.320]  давайте такой вопрос сейчас касательно универсально учтимых функций главный
[01:08:34.320 --> 01:08:39.080]  все понятно потому что все хорошо мы вот их сейчас задание проишаем и про них забудем вообще
[01:08:39.080 --> 01:08:42.000]  прям нас совсем
[01:08:42.000 --> 01:08:51.600]  мы видим раз никто ничего не говорит вопросов нет
[01:08:51.600 --> 01:09:00.360]  сегодня сумбурника получилось
[01:09:09.080 --> 01:09:21.600]  первое задание это попытка вас запутать теоремой к линии задание на внимательность задание
[01:09:21.600 --> 01:09:35.760]  неприятное ставлю желтый короче 2929 задание это определенно не сложная задача на то чтобы
[01:09:35.760 --> 01:09:43.760]  запрограммировать машину тюринга если делать с многоленточной если пытаться одноленточную
[01:09:43.760 --> 01:09:49.360]  там есть определенный вариант в которых вы сделаете 40 за 40 состояний просто решите забить на
[01:09:49.360 --> 01:10:03.640]  это нужно быть умнее там и так вот у нас тоже самое значение как мы делали раньше есть гув и
[01:10:03.640 --> 01:10:15.360]  нам нужно сказать что не зависит от выбора у существует такое и он что для всех x выполнено
[01:10:15.360 --> 01:10:29.640]  но это вот так вот даже не так дайте чуть стину чтобы было корректно утверждение
[01:10:29.640 --> 01:10:50.920]  это просто ремок линии существует такое x что для всех n выполнено ну конечно же это неверно
[01:10:50.920 --> 01:11:14.680]  но эти первые пункта чуть больше я там объясню что у нас есть f от n равное 2 n плюс 1 она принадлежит
[01:11:14.680 --> 01:11:24.200]  тотальным но не f это она принадлежит тотальным поэтому все хорошо она отрабатывает это вот
[01:11:24.200 --> 01:11:33.560]  буквально применение в пункте b мы уже видим что n и x они не совпадают поэтому скорее всего
[01:11:34.560 --> 01:11:57.400]  это все лажа но здесь немножко хитрее что у нас будет фиксировано но некоторые x должно остаться но
[01:11:57.960 --> 01:12:12.200]  у нас есть какая-то номерация там функции например инкримент а там принадлежит
[01:12:12.200 --> 01:12:26.200]  компьютер был тогда для него найдется некоторые и ну и понятно что таких x вообще существовать
[01:12:26.200 --> 01:12:37.080]  не может за счет того что это инкримент в пункт д стабильный то мы его не отмечаем в пункте
[01:12:37.080 --> 01:12:50.840]  в у нас он и и и и поменялась и я поменялась только там по сути разными стами давайте делать
[01:12:51.480 --> 01:13:04.880]  я вот черчу буквально мою универсальную чесим и функцию у меня есть у меня есть пусть там и она
[01:13:04.880 --> 01:13:19.480]  1 и n 3 у меня есть какой-то x
[01:13:25.480 --> 01:13:27.800]  и есть
[01:13:27.800 --> 01:13:42.040]  до х плюс 1 что от меня хотят что в первом случае существует такое x что для всех
[01:13:42.040 --> 01:13:57.120]  и он будет это выполнено ну давайте что сделаем сделаем вот вот эти должны совпадать у нас
[01:13:57.120 --> 01:14:08.280]  f n x и так скажу и он 9 плюс 1 и вот они должны совпадать
[01:14:08.280 --> 01:14:27.800]  ну в таком случае мне достаточно привести сказать что для любого x найдется n которые
[01:14:27.800 --> 01:14:41.080]  будут неравно ну что не что для любого x будет существовать такое n что f
[01:14:41.080 --> 01:14:51.480]  н от x и не равняется f n 2 n плюс 1 2 x плюс 1
[01:14:51.480 --> 01:15:11.480]  сейчас ну пусть так существует что для всех и он выполнено
[01:15:11.480 --> 01:15:19.960]  какой бы я не выбрал
[01:15:27.960 --> 01:15:32.680]  но однозначно у меня все функции на одном аргументе не могут равняться у меня есть
[01:15:32.680 --> 01:15:41.800]  две какие-то функции которые неравны ну давайте я возьму и скажу что здесь будет эта функция
[01:15:41.800 --> 01:15:52.480]  тождественного нуля здесь функции тождественной единицы тогда я могу взять такую главную
[01:15:53.080 --> 01:16:04.080]  функцию что вот на единицы это будет на тройке у меня будут записаны 0 1 это вот я фиксировал
[01:16:04.080 --> 01:16:21.000]  в такой фиксации у меня получится что что должно существовать такой x что они должны где-то
[01:16:21.000 --> 01:16:27.600]  совпасть но естественно нигде не совпадут поэтому вы неверный в случае пункта g что для любого
[01:16:27.600 --> 01:16:35.160]  n существует такой x что они совпадут но опять же если я зафиксировал такую вот функцию универсально
[01:16:35.160 --> 01:16:42.280]  главную универсальную числему что у меня здесь есть функции тотального нуля и функции тотальной
[01:16:42.280 --> 01:16:51.440]  единицы они расположены соответствующим образом и поэтому они должны совпадать но
[01:16:51.440 --> 01:17:06.520]  бред они такого не совпадут идея здесь следующая что либо это теория маклини либо пытаемся вот
[01:17:06.520 --> 01:17:12.280]  например как здесь фиксировать какие-то две позиции у тривиальных функций то есть у функции
[01:17:12.280 --> 01:17:19.600]  везде равные нулю функции везде равные единицы как чтобы они были неравны там функцию которые
[01:17:19.600 --> 01:17:33.000]  например как здесь когда последовательны придумаем функцию чтобы сейчас скажем чтобы не совпадали
[01:17:33.000 --> 01:17:38.760]  вот эти вот значения там какую-то строго растущую очень быстро растущую там экспонент то есть
[01:17:38.760 --> 01:17:46.400]  возьмите вот как здесь инкримент чтобы не было возможности такого совпадения на больше строго
[01:17:46.400 --> 01:18:11.040]  монотонно вот что нужно 41 все на этом все на самом деле или не все не все сейчас будет
[01:18:11.040 --> 01:18:13.680]  самая приятная задача в курсе просто
[01:18:23.680 --> 01:18:38.360]  чтобы научиться решать нужно просто запомнить следующую мантру так оформляем ее в виде теория
[01:18:41.040 --> 01:18:56.000]  пусть у икс главная специальность на мою функцию в икс
[01:18:56.000 --> 01:19:14.680]  учтем и функции двух аргументов тогда существует такое п что для
[01:19:14.680 --> 01:19:28.120]  любого икс выполняется что у по икс равняется в по икс доказательств
[01:19:28.120 --> 01:19:43.640]  ну если мы видим у есть вы в самое время используете рему к линии
[01:19:58.120 --> 01:20:14.280]  для начала воспользуемся определение гув что у главно универсально учтемая функции
[01:20:14.280 --> 01:20:21.720]  следовательно по определению будет существовать некоторая тотальная функция
[01:20:21.720 --> 01:20:36.600]  что для любого икса будет выполняться следующим что у тн икс для любого икса для любого и
[01:20:36.600 --> 01:20:54.040]  равняется в икс по теориями к линии будет существовать такое п но нас же вот теперь
[01:20:54.040 --> 01:21:00.640]  есть тотально есть главный универсально учтем и есть компьютер был от двух аргументов то будет
[01:21:00.640 --> 01:21:27.680]  считать такой п что у а т от п икс равняется в п икс обобщение не в п а уп и теперь осталось
[01:21:27.680 --> 01:21:42.560]  записать транзитивную цепочку уп икс равняется у т от п от икс равняется в от п от икс
[01:21:42.560 --> 01:21:57.120]  причем до говорится что здесь существует такое п что для любого икс чета д
[01:21:58.640 --> 01:22:05.000]  вот это вот просто запомнили здесь расписали по определению применили теория муклине получили
[01:22:05.000 --> 01:22:15.440]  вывод запомнили это доказательство тогда задача наша просто применить теперь эту теорию так
[01:22:15.440 --> 01:22:26.800]  формуировка существует некоторые машины тюринга с номером n который вычисляет функцию f от n
[01:22:27.160 --> 01:22:33.320]  и так если с номером n то этот номер пришел с некоторой главной универсально учтем и функции
[01:22:33.320 --> 01:22:50.840]  хорошо у нас есть ун икс тогда что нам нужно нам нужно
[01:22:50.840 --> 01:23:09.320]  делать следующее рассматриваем правую часть как следующее f от x равняется в от tx справа
[01:23:09.320 --> 01:23:16.840]  может быть написано абсолютно произвольная функция она будет от двух аргументов нам нужно
[01:23:17.000 --> 01:23:34.640]  сказать что она комбинарная функция вычислим и и тогда мы можем воспользоваться с этим утверждением
[01:23:35.200 --> 01:23:49.760]  существует такое n что ун икс равняется в пх то есть будет существовать некоторое ун икс равное
[01:23:49.760 --> 01:24:10.920]  в икс а это есть f с номером n именно то что нам сказали то есть задача буквально просто выучить
[01:24:10.920 --> 01:24:22.600]  теорему ее написать а дальше сослаться на нее явно показав что вот это вот вы это вот ун и это
[01:24:23.600 --> 01:24:42.760]  все задача максимально простая дальше начинается более сложный блок арифметика и арифметической
[01:24:42.760 --> 01:24:58.400]  иерархии начнем с арифметической иерархии у нас есть арифметической иерархии
[01:25:11.160 --> 01:25:11.920]  иерархия
[01:25:13.080 --> 01:25:22.880]  она она на слово у нас на следующих двух моментах есть сигмака есть пика это не
[01:25:22.880 --> 01:25:33.280]  п это п большая буквы заговна сигма мы помним это сумма от сумма сложения сложение у нас
[01:25:33.280 --> 01:25:45.000]  логики дизъюнция это квантор всеобщенности это умножение это дизъюнция ой-ой-ой-ой существование
[01:25:45.000 --> 01:25:59.720]  ту всеобщенности как мы определяем что какой-то класс сигмака или пика определяем и следующим
[01:25:59.720 --> 01:26:13.360]  образом пусть у нас есть некоторый разрешимый предикат x1 xn и перед ним идет следующая
[01:26:13.360 --> 01:26:25.800]  последовательность существует ой-ой-ой дайте y x1 так далее xn то есть это все равно в некотором
[01:26:25.800 --> 01:26:33.760]  смысле функции от одной одной от одной переменной остальные все будут поедены кванторами здесь
[01:26:33.760 --> 01:26:43.240]  существует дальше для любого существует и так далее в таком случае мы говорим что первый знак
[01:26:43.240 --> 01:26:54.120]  существует следовательно это класс сигма здесь n следовательно это сигма если у нас здесь будет
[01:26:54.120 --> 01:27:05.800]  для любого x1 так далее то это класс p и отметил сразу несколько важных моментов что есть у нас
[01:27:05.800 --> 01:27:17.960]  идут подряд несколько кванторов то вот это вот все равносильно одному квантору по паре аргументов
[01:27:17.960 --> 01:27:27.400]  поэтому в реальности мы делаем следующим образом что у нас идет некоторый блок существования
[01:27:27.400 --> 01:27:36.240]  дальше идет некоторый блок любых
[01:27:36.240 --> 01:27:50.880]  потом снова блок с квантор существования так далее вот доходит до предиката разрешимого
[01:27:50.880 --> 01:27:54.840]  и такое мы называем вот
[01:27:54.840 --> 01:28:02.840]  сигма n где n количество таких блоков
[01:28:02.840 --> 01:28:16.760]  сейчас нм были здесь давайте по депо количестве блоков интересный вопрос возникает о том как это
[01:28:16.760 --> 01:28:24.040]  вообще связано например с решимостью и там перечислимость ко перечислимость понятно что
[01:28:24.040 --> 01:28:34.640]  сигма 0 равняется пиноль кванторов нету и у нас ты только разрешимый предикат но если разрешимый
[01:28:34.640 --> 01:28:45.800]  предикат то очевидно это есть разрешимый deducible по-моему короче назовем просто разрешимый
[01:28:45.800 --> 01:29:04.960]  сигма 1 пересечь сигма с п1 это дайте не так скажу сначала сигма 1 скажу что это перечислимая
[01:29:04.960 --> 01:29:20.760]  п1 это ко перечислимая в принципе понятно же что вот эти штуки они дополняют себя там если
[01:29:20.760 --> 01:29:35.880]  один то ко это вот мы смену квантор тогда сигма 1 пересечь с п1 это одновременно перечислимый
[01:29:35.880 --> 01:29:49.640]  ко перечислимый по теореме поста это класс разрешимых вот а теперь начинается самое интересное
[01:29:49.640 --> 01:29:59.800]  начинается кукуруза у нас уже были елочки самое время познакомиться с новым овощем
[01:29:59.800 --> 01:30:12.920]  самое время научиться рисовать початок кукурузу вот у нас словно початок кукурузы и он как идет
[01:30:12.920 --> 01:30:16.520]  вот у него есть листья
[01:30:16.520 --> 01:30:30.600]  нормально это сделано
[01:30:30.600 --> 01:30:39.240]  вот тут у него жухта
[01:30:39.240 --> 01:31:05.040]  вот у нас класс сигма 1 вот класс сигма п1 здесь у нас лежит конечно же вот класс разрешимых
[01:31:05.040 --> 01:31:13.440]  которые перечислим дальше у нас идет расширение сигма 2 которая включит нас все есть
[01:31:13.440 --> 01:31:27.200]  п2 которая себя включит тоже там все так далее потом начнется там еще
[01:31:27.200 --> 01:31:39.680]  сигма 3 какая-нибудь там интересненькая
[01:31:39.680 --> 01:31:53.680]  п3 и так далее до бесконечности вот как кукуруза у нас все больше больше чаще чаще чаще это все
[01:31:53.680 --> 01:31:58.680]  образуют как раз вот такой вот вложенность цепочки что мы знаем про вложенность этих
[01:31:58.680 --> 01:32:11.320]  цепочек что сигма 0 равняется п0 равняется сигма 1 пересечь с п1 вложено строго в сигма 1 п1
[01:32:11.320 --> 01:32:24.920]  вложено строго в сигма 2 пересечь в п2 вложено строго в объединения в их вложено строго в
[01:32:24.920 --> 01:32:33.680]  пересечения следующих и так далее вот такая вот цепочка
[01:32:33.680 --> 01:32:58.400]  самое время заняться классификацией арифметической иерархии
[01:33:03.680 --> 01:33:18.180]  у
[01:33:18.180 --> 01:33:42.060]  все что касается этого задания там скажем так неприятно
[01:33:48.180 --> 01:33:59.020]  начнем множество программ с конечной области определения то есть нужно как-то сказать что
[01:33:59.020 --> 01:34:04.180]  конечную область определения конечная область определения значит мы можем ее ограничить сверху
[01:34:04.180 --> 01:34:14.740]  нашу сен значит это какой-то вот префикс больше существует некоторые границы b что для любого
[01:34:14.740 --> 01:34:23.140]  и он выполняется что что если n меньше чем b
[01:34:44.740 --> 01:34:55.580]  сейчас для любого n для любого m что если n меньше b нет наоборот больше то есть для
[01:34:55.580 --> 01:35:02.300]  всех чисел больше у нас не должно останавливаться функция если n больше m то
[01:35:02.300 --> 01:35:16.900]  дайте любого x что x больше n то у nt от x
[01:35:16.900 --> 01:35:33.540]  у nt от x не останавливается за м шагов
[01:35:33.540 --> 01:35:46.900]  обращаю внимание на этот момент эту штуку мы можем реально проверить здесь m шагов
[01:35:46.900 --> 01:35:51.060]  это конечное число мы можем это проверить если мы только говорим что не останавливается это
[01:35:51.060 --> 01:36:01.260]  проверить нельзя это неразрешимое свойство здесь существует дальше это очевидно sigma 2
[01:36:01.260 --> 01:36:12.100]  множество параград которые на входе 5 равны пяти ну что это это множество таких n
[01:36:12.100 --> 01:36:19.900]  которые находе равны то есть не должно стыд существует некоторое время остановки что
[01:36:19.900 --> 01:36:33.220]  то у n на входе 10 равняется пяти останавливается за м шагов
[01:36:33.220 --> 01:36:51.220]  это один контрсуществование sigma 1 потому что программ который на ходе равны 5 или не
[01:36:51.220 --> 01:37:05.020]  останавливаются это очевидно sigma 1 не останавливается множество таких программ что для любого
[01:37:05.020 --> 01:37:23.420]  m не останавливаешься для любого x что у n но опять же тут вообще на самом деле вопрос не останавливается
[01:37:23.420 --> 01:37:28.620]  не останавливается на каком-то конкретном числе мы тогда считаем не останавливается или что не
[01:37:28.620 --> 01:37:47.260]  должны на всех у n от x вот давайте я скажу так что я считаю не останавливается если не останавливается
[01:37:47.260 --> 01:37:58.500]  на всех все что на больших ничего не знаю что на лучше всех не останавливается за м шагов
[01:37:58.500 --> 01:38:16.180]  это п 1 ну смотрите или это у нас магическое объединение поэтому здесь мы имеем к раз
[01:38:16.180 --> 01:38:18.180]  sigma 1 объединить п 1
[01:38:18.180 --> 01:38:47.580]  дальше множество программ область которых спадается множеством простых чисел
[01:38:47.580 --> 01:39:00.260]  проверка на простоту это вычислимо поэтому говорим что множество таких n что для любого
[01:39:00.260 --> 01:39:27.820]  x для любого m что есть и у n t от x остановилась за m шагов то x принадлежит п и последнее но это
[01:39:27.820 --> 01:39:37.300]  что это нас п 1 может программа из которых является экзотической прогрессии ух тут я просто
[01:39:37.300 --> 01:39:47.820]  выпишу формулу это множество таких n что существует а нулевое существует дельта то есть мы задали
[01:39:47.820 --> 01:39:56.860]  археологическую прогрессию что для любого x для любого m то есть задали вход задали число шагов
[01:39:56.860 --> 01:40:09.140]  найдется к ну задали соответственно вот шаг в археологической прогрессии такое что если у n t от
[01:40:09.140 --> 01:40:24.140]  x остановилась за m шагов то у n t от x равняется а нуль плюс дельта к
[01:40:24.140 --> 01:40:42.180]  вот что здесь произошло здесь есть существование любого существования это sigma t
[01:40:42.180 --> 01:40:59.660]  а теперь задача 38 дача 38 заключается в том что нужно просто четко по заданию выписать все
[01:40:59.660 --> 01:41:05.260]  в пантерах оно не сложное но можно наплести лишнего
[01:41:19.260 --> 01:41:24.100]  арифметическое рахимонус можно тюрьма определенных всех точек не бесконечной
[01:41:24.100 --> 01:41:28.380]  фактической прогрессии с не нулевой разностью для которых при этом множество значений этой прогрессии
[01:41:28.380 --> 01:41:34.700]  является не некоторых часа бесконечной фактической прогрессии с не нулевыми разниц ух
[01:41:34.700 --> 01:41:49.260]  первое что мы говорим в этой задаче зафиксируем у n x главную честная функция
[01:41:49.260 --> 01:42:07.100]  а теперь во всех точках некоторые бесконечные фактической прогрессии ну существует а нуль дельта
[01:42:07.100 --> 01:42:17.620]  я впишу сюда но скажу так оно потом внесет должно вноситься внутрь но я просто не буду
[01:42:17.620 --> 01:42:26.660]  делать потому что мне не несколько это неудобно что для любого к существует м
[01:42:26.660 --> 01:42:33.380]  смотрите здесь сказано определенное во всех точках некоторые фактической прогрессии но
[01:42:33.380 --> 01:42:45.220]  ничего не сказано про метод поэтому ну на остальном множестве мы не специфицируем
[01:42:45.220 --> 01:42:51.300]  предвидение это зафиксировали сказали вот теперь что сейчас мы будем пробегаться по
[01:42:51.300 --> 01:42:58.580]  и и магической прогрессии количество шагов зафиксирует за которые должна останавливаться что
[01:42:58.580 --> 01:43:06.860]  мы делаем мы говорим что я перейду к записи в яму формате потому что иначе мы вообще не поймем
[01:43:06.860 --> 01:43:18.980]  что происходит у n а 0 плюс дельта ка останавливается за м шагов дальше и
[01:43:18.980 --> 01:43:29.260]  теперь нам нужно говорить что объединение вот этих вот арифенической рейс существует некоторые
[01:43:29.260 --> 01:43:42.660]  а нулевое дайте так а существует некоторая дельта так неравную нулю существует некоторая ка
[01:43:54.660 --> 01:43:55.220]  что
[01:43:59.620 --> 01:44:10.540]  у от n а 0 плюс дельта ка равняется а 0 плюс дельта ка то есть мы сказали что это равняется
[01:44:10.540 --> 01:44:19.660]  некото значение не на некоторых и последовательности но теперь нам понадобится сказать что что если мы
[01:44:19.660 --> 01:44:23.180]  один раз приняли мы должны все остальные тоже взять потому что это же объединение
[01:44:23.980 --> 01:44:30.660]  и для любого ка теперь нужно новая ка ну давайте
[01:44:30.660 --> 01:44:42.500]  ка я не люблю такое вот сопряжение поставим ка существует м число шагов и
[01:44:42.500 --> 01:45:00.460]  будет существовать ка ее сейчас сопряжение полюсик хорошо
[01:45:00.460 --> 01:45:12.980]  давай точе что у n т от а 0 плюс дельта
[01:45:12.980 --> 01:45:22.960]  каплюсик ну то есть для какого-то ка то есть для всех остальных должно
[01:45:22.960 --> 01:45:26.920]  найти найти какой-то пара вопрос но говорим вот существует пара вопрос останавливается
[01:45:26.920 --> 01:45:45.680]  за и он с удовельствием шагов и у н а 0 плюс дельта ка плюс равняется а 0 черта плюс дельта черта
[01:45:45.680 --> 01:45:53.440]  ка сопряжение ну и наконец-то теперь это мы просто берем все выносим наверх
[01:45:53.440 --> 01:46:09.520]  прошлое что там у нас было у нас было то что называлось этим скажу ее
[01:46:09.520 --> 01:46:19.200]  приведение предваренно нормальной форме но здесь нам нужно переводить не просто
[01:46:19.200 --> 01:46:28.480]  предваренно нормальной форме ак предваренно нормальной форме где кванторы будут стоять
[01:46:28.480 --> 01:46:33.520]  максимально оптимально то есть нам нужно будет во первых поддерживать внутри вот этих вот всех
[01:46:33.520 --> 01:46:43.280]  соответствующий порядок а остальное мы должны просто правильно выставить вот здесь например все
[01:46:43.280 --> 01:46:49.480]  существует здесь заканчивается существует поэтому идеально слепляется для любого сюда ну
[01:46:49.480 --> 01:46:57.200]  к сожалению не получится слепить нужно будет писать квантор у нас там каким существует а 0
[01:46:57.200 --> 01:47:12.960]  существует дельта существует к и тут нет любого ка существует им существует
[01:47:12.960 --> 01:47:25.760]  существует и он существует к что для любого к звезда существует м звезда существует к плюс
[01:47:25.760 --> 01:47:42.520]  время разбираться в кванторах плюсики существует 5 штук первые первая сигма ответ
[01:47:42.520 --> 01:48:01.400]  sigma 5 иногда могут получаться вот такие вот ответы в таком случае как это может
[01:48:01.400 --> 01:48:16.960]  получиться когда у нас здесь есть еще один момент мне кажется я сдаю все это на пуду да здесь же
[01:48:16.960 --> 01:48:29.440]  пересечение все это я топлю в общем идея в чем что здесь у нас будет квантор существования здесь
[01:48:29.440 --> 01:48:36.560]  будет квантор для любого или это дизьюн ц и мы приводим пнф как мы приводим мы выкидываем
[01:48:36.560 --> 01:48:43.920]  квантор существования выкидываю квантор с общности мы можем выкинуть их формате существует для
[01:48:43.920 --> 01:48:55.120]  любого а может для любого существует и так и так валидно но в этом случае это sigma 2 в этом
[01:48:55.120 --> 01:49:03.560]  случае это п 2 поэтому ответ здесь правильный не то что я написал изначально sigma 2 пересечь с
[01:49:03.560 --> 01:49:12.120]  п 2 вот за счет того что можно кванторы переносить в разном порядке
[01:49:12.120 --> 01:49:35.160]  здесь у нас не получится переносить кванторы в разном порядке именно потому что они лежат
[01:49:35.160 --> 01:49:42.520]  на разных уровня вот как можно заметить у нас не получится их нормально вынести можно выносить
[01:49:42.520 --> 01:49:51.640]  квантор в произвольном порядке когда вот они на одном уровне тогда их можно нормально их переносить
[01:49:51.640 --> 01:50:03.160]  если нас например вот здесь вот было бы какой тут любого мы могли вынести с одной стороны существует
[01:50:03.160 --> 01:50:13.720]  потом до любого а могли бы вынести сначала для любого а потом существует и было бы у нас там
[01:50:13.720 --> 01:50:17.120]  объединение какой-нибудь окей
[01:50:17.120 --> 01:50:40.720]  сейчас глянуть что происходит это есть это есть это есть это есть жух
[01:50:40.720 --> 01:50:50.240]  38 42 задание это на
[01:50:50.240 --> 01:51:02.080]  тему которая называется арифметика у нас была рифметическая иерархия теперь просто рифметика
[01:51:02.080 --> 01:51:11.600]  формальная рифметика она лежит на основе аксиоматики она то есть у нас есть следующая
[01:51:11.600 --> 01:51:27.440]  сигнатура саксессор сложение унижение равенство константа 0 1 и есть соответственно правила
[01:51:27.440 --> 01:51:43.080]  там вывода аксиом есть аксиомы 1 13 из оп исчисления предикатов дальше есть аксиомы равенство это у нас
[01:51:43.080 --> 01:51:57.240]  рефлексивность транзитивность рефлексивность транзитивность симметричность
[01:51:57.240 --> 01:52:06.280]  ну как отношение к валентности дальше связь с аксессором
[01:52:12.800 --> 01:52:17.160]  и связь со сложением и унижением
[01:52:27.240 --> 01:52:43.760]  икс плюс игрек равняется z мне не нравится в плюс дубль у плюс дубль в
[01:52:43.760 --> 01:52:53.960]  следовательно саксессор от икс плюс игрек равняется равняется саксессор от у плюс
[01:52:53.960 --> 01:53:02.720]  дубль в аналогично у нас доваряется еще аксиом когда здесь умножение но я писать не буду и
[01:53:02.720 --> 01:53:22.560]  у нас есть 3 аксиом пиано первая аксиом пиано она нам ограничивает натуральный чисто снизу
[01:53:22.560 --> 01:53:35.440]  не натуральный чисто в общем да мы говорим что 0 он ограничивается снизу дальше что мы говорим
[01:53:35.440 --> 01:53:49.960]  саксессор увеличивает что неверно что икс нравится игреку ой что саксессор сейчас
[01:53:49.960 --> 01:54:02.240]  не хочу разбираться пофиг это по моему из как раз из равенства саксессоров чета туда
[01:54:02.240 --> 01:54:18.400]  нафиг общего и самое главное это аксиома индукции я научить так что есть у нас некоторый
[01:54:18.400 --> 01:54:36.560]  предикат если он верен нуле им для любого икс из верности предиката для него следует
[01:54:36.560 --> 01:54:47.000]  истинность предиката для следующего в таком случае утверждается что для всех икс этот
[01:54:47.000 --> 01:55:02.480]  предикат верен ну снова воспоминания транзитивный ой конус сейчас мозг уже
[01:55:02.480 --> 01:55:15.000]  все пристает работать сейчас не транзитивная какая трансфинитная индукция вот да вот у нас
[01:55:15.000 --> 01:55:25.040]  есть следующие индукции теперь от нас хотят чтобы мы вот формальные аэфметики
[01:55:25.040 --> 01:55:41.560]  задали интерпретацию данной сигнатуры и проверили какие аксиомы вообще в этой
[01:55:41.560 --> 01:55:54.480]  интерпретации выполняются какие нет вот что здесь произошло давайте в таком случае советую
[01:55:54.480 --> 01:56:03.400]  рисовать бамбуки вот например у нас аксессор это он к некоторым сроде задает порядок с отн n плюс
[01:56:03.400 --> 01:56:28.160]  1 0 1 2 жутко вот то поменьше а для меньше нуля у нас минус один жутко у нас получились такие
[01:56:28.160 --> 01:56:34.200]  два графа эти графы показывают что у нас происходит вообще с данной интерпретации
[01:56:34.200 --> 01:56:46.840]  проверяем что любого икс но не равняется следующим она выполняется действительно перед
[01:56:47.040 --> 01:56:58.960]  предыдущих нет одна спросит вот очень важно нарушается внимательно надо быть дальше что для
[01:56:58.960 --> 01:57:07.160]  любого игрека из это вот та самая эксилон пиано по-другому записан и там при помощи применения того
[01:57:07.160 --> 01:57:24.160]  как он называется законов доморгана любого экса любого игрека я подозреваю что игрек
[01:57:24.160 --> 01:57:35.760]  должен быть здесь очень странно стоит ну я буду интерпретировать так тут странно все это лежит
[01:57:35.760 --> 01:57:48.760]  верно так что если следующие совпадают то эти совпадают но действительно нас нету такого
[01:57:48.760 --> 01:58:00.520]  чтобы у нас мы переходили во что-то дно поэтому нарушений нету для любого икса вообще это говорит
[01:58:00.520 --> 01:58:14.520]  о том что инъективность функции с с на самом деле на некотором смысле функции
[01:58:14.520 --> 01:58:27.320]  для любого ирека для любого у экса не существует такой игрека что икс равняется с от игрек следовательно
[01:58:28.120 --> 01:58:34.680]  вот это неверно у нас же есть минус один поэтому нарушили не существует такой и что их сравняется
[01:58:34.680 --> 01:58:53.080]  с нет такого нету у нас нету нигде колечко принцип индукции ну смотрите это же это n это n это в
[01:58:53.080 --> 01:59:03.840]  некотором смысле и он дизью нас n это фундировано это фундировано вместе все фундировано поэтому
[01:59:03.840 --> 01:59:17.640]  принцип индукции выполнено он не будет нарушаться и последнее что если не расскажу снова новая тема
[01:59:17.640 --> 01:59:26.440]  я уже немножко стал короче дешки рассказывать не буду как делаются простите
[01:59:26.440 --> 01:59:34.640]  если будут вопросы можете написать я не расскажу
[01:59:34.640 --> 01:59:53.960]  это просто абсолютно новая иная тема задача зеленая ее прям надо делать она легко лутает
[01:59:53.960 --> 02:00:13.560]  баллы и эта задача на тем кто называется бета кодирование геодоля в чем идее бета кодирования
[02:00:13.560 --> 02:00:20.960]  геодоля у нас есть некоторая последовательность это 0 тогда ли это
[02:00:20.960 --> 02:00:35.400]  мы хотим закодировать у нас есть последовательность есть функции перехода
[02:00:35.400 --> 02:00:49.200]  которая от это й и переходит к это й с 1 тогда мы можем закодировать все последовательность
[02:00:49.200 --> 02:00:58.880]  следующим образом существует n существует а существует б такое что
[02:00:58.880 --> 02:01:23.000]  бета функция геодоля от а б 0 равняется это 0 и бета функция от а б n равняется от это n и
[02:01:23.000 --> 02:01:44.840]  для любого й меньше н выполняется что бета а б й плюс один равняется правила перехода
[02:01:44.840 --> 02:01:54.400]  вот бета а б й вот
[02:01:54.400 --> 02:02:07.680]  то есть что на самом деле бета функции геодоля там под капотом вроде китайской
[02:02:07.680 --> 02:02:18.080]  в остатках попытка кодировать технические прогрессии вроде да намогу шеваться у нас вот
[02:02:18.080 --> 02:02:26.920]  а и б это некотором смысле вот из там прогрессии прошло это у нас итератор то есть вот й это
[02:02:26.920 --> 02:02:35.440]  нулевая поэтому у нас здесь 0 это nt поэтому здесь n здесь это й а здесь это й плюс первая вот как раз
[02:02:36.320 --> 02:02:47.480]  поэтому в нашем случае если мы хотим закодировать там какое-то множество нам нужно задать его
[02:02:47.480 --> 02:02:57.240]  качество последовательности и назвать продукцию мы хотим
[02:02:57.240 --> 02:03:21.000]  кодировать мы хотим кодировать n степени n степени с одной стороны кажется что давайте
[02:03:21.000 --> 02:03:31.920]  мы й будем превращать эту й давайте превращать там в какую-нибудь
[02:03:31.920 --> 02:03:57.120]  й плюс 1 на n й так мы получим вообще факториал это не то что нам нужно поэтому мы будем
[02:03:57.120 --> 02:04:05.080]  переходить следующим образом что у нас это й это будет n степень й и переход у нас будет
[02:04:05.080 --> 02:04:26.680]  следующий n й на n это й поэтому если мы так записали мы можем явно задать вот это вот добро
[02:04:26.680 --> 02:04:37.520]  поехали существует n существует существует а b существует что там
[02:04:37.520 --> 02:04:58.680]  существует n существует b и а да уже пофиг на самом деле есть бета дальше а б 0 оно должно
[02:04:58.680 --> 02:05:17.080]  равняться чему в n в нулевой степени значит один дальше и б б n n в степени n у нас n и и правило
[02:05:17.080 --> 02:05:32.960]  перехода что для любого й от меньше и он выполняется что бета а б и от плюс один равняется
[02:05:32.960 --> 02:05:54.800]  n бета а б ажух все на этом все это вот такое формулировка на самом деле не бывает посложнее
[02:05:54.800 --> 02:05:59.760]  там нужно подумать как именно правильно закодировать годы как именно представить это
[02:05:59.760 --> 02:06:07.600]  в виде последовательности и найти правила перехода все на этом у меня все если есть
[02:06:07.600 --> 02:06:11.600]  вопросы welcome если нет вопросов то все
[02:06:33.600 --> 02:06:35.240]  что тогда всем спасибо всем пока
