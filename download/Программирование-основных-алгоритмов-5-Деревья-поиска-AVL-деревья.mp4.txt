[00:00.000 --> 00:10.840]  Так ну окей, давайте начнем. Собственно у нас закончились сортировки и куча, вот,
[00:10.840 --> 00:16.120]  контест закончился и поздравляю вас, нового контеста сегодня не будет, и завтра не будет,
[00:16.120 --> 00:21.200]  и даже послезавтра. Да, у нас как минимум неделя перерыва от контестов, чтобы вы могли
[00:21.200 --> 00:29.680]  все-таки наконец-то порешать другие предметы. Вот. Да, у вас есть целая неделя, надо то,
[00:29.680 --> 00:37.760]  чтобы потом сделать матан и прочее. Окей, а теперь о чем мы с вами будем говорить? Мы
[00:37.760 --> 00:45.360]  будем с вами говорить о деревьях поиска в ближайшие несколько занятий. Так сказать,
[00:45.360 --> 00:53.200]  мы продолжаем играть на тематике сортировок. Единственное, мы все усложняем и усложняем и
[00:53.200 --> 01:03.880]  усложняем. Собственно, что такое дерево поиска? Давайте вернем на определение. Дерево поиска,
[01:03.880 --> 01:15.520]  и мы поначалу будем говорить только о бинарных деревьях, быть может потом у нас останутся силы
[01:15.520 --> 01:41.120]  и на не бинарные. Это что такое? Это корневое, в скобочках бинарное дерево,
[01:41.120 --> 02:05.360]  в котором для любого узла x верно, что слева, ну или в левом поддереве, если у нас бинарное
[02:05.360 --> 02:15.720]  дерево. Вот для не бинарных пока что не будем обобщать. Что слева элементы меньше x, а справа
[02:15.720 --> 02:26.160]  больше x. Давайте нарисуем пример простенький, что-нибудь типа такого.
[02:36.360 --> 02:40.640]  Например, такое дерево, оно является деревом поиска, потому что если вы посмотрите в любой узел,
[02:40.640 --> 02:47.120]  то в левом поддереве элементы все меньше, чем элемент в данном узле, а в правом все больше.
[02:47.120 --> 02:55.800]  Ну и так верно для любого узла. Собственно, зачем нам это надо? Вообще в идеале, почему мы стремимся?
[02:55.800 --> 03:01.120]  Наша цель построить некоторую структуру данных, которая будет удовлетворять следующему протоколу,
[03:01.120 --> 03:08.520]  назовем это так. Операция. Время работы.
[03:08.520 --> 03:26.080]  Операция будет типа find, проверить есть ли элемент множества за логорифом.
[03:26.080 --> 03:34.000]  Собственно, вот вы писали там в куче декрестки, вам нужно было что-то типа удаления по значению,
[03:34.000 --> 03:45.320]  поиска по значению, вот это оно. Дальше это insert, добавить элемент множества, тоже за логорифом хотим.
[03:45.320 --> 03:55.400]  И erase, то есть удалить элемент из множества по значению, тоже за логорифом хотим. Вот к
[03:55.440 --> 04:01.200]  этому мы будем стремиться. Ну к этому мы придем и будем приходить разными способами.
[04:01.200 --> 04:19.640]  Окей, ну давайте обсудим все эти операции. Давайте начнем с операции find. Вот как делать
[04:19.640 --> 04:33.800]  плоскость в таком дереве. Да, если вы равен, то возвращаем там какой-нибудь флажочек, что он есть,
[04:33.800 --> 04:39.920]  все. То есть у вас есть указатель на корень и дальше уйдете либо влево, либо вправо в зависимости
[04:39.920 --> 04:50.520]  от значения элемента. Ну, например, давайте напишем реализацию, что ли. Такую псевдокодовскую.
[04:50.520 --> 05:06.760]  Окей, мы смотрим просто что лежит в ноде. Ну, в какой-то момент времени понятное дело,
[05:06.760 --> 05:15.440]  что там у листовых узлов нет детей, вот они будут указывать на noopter. То есть если мы на noopter,
[05:15.440 --> 05:29.840]  там return false. Вот, иначе мы действительно находимся в алином узле и нам надо проверить. То есть if,
[05:29.840 --> 05:42.360]  ну там ноды, какая-нибудь структурка будет, в которой есть поле value, ну или elem. То есть
[05:42.360 --> 05:56.400]  если его значение равно равно value, то return true. Вот, окей. Ну и дальше, как вы уже сказали,
[05:56.400 --> 06:09.600]  либо влево, либо вправо пойти. Если, понимаете, вот такое соотношение, то есть наше значение,
[06:09.600 --> 06:14.480]  которое мы ищем, например, мы ищем девятку, она меньше десятки, значит она где-то вот здесь
[06:14.480 --> 06:34.560]  должна находиться. То верни что? Верни find от левого под дерево и того же значения.
[06:38.560 --> 06:39.720]  Ну иначе верни от правого.
[06:44.480 --> 06:59.120]  Ну все, как бы элементарный алгоритм. За сколько он работает?
[06:59.120 --> 07:17.080]  Ваше дерево может быть бамбуком. Ну, выродится прямую ветку. Вот, и выстав у него будет линейный.
[07:17.080 --> 07:22.960]  В идеале, конечно, мы хотим, чтобы выстав был алгоритмический, тогда все будет хорошо. Вот.
[07:22.960 --> 07:40.120]  Время от аш, где аш то высота дерева. Окей, ну find это легко, давайте insert обсудим.
[07:40.120 --> 07:52.360]  Здесь я уже, наверное, код писать не буду, просто поясню словами. Вот я хочу вставить
[07:52.360 --> 08:07.480]  девятку. Что мне делать? Вот, допустим, я добрался до узла, у которого там детей нет. Например,
[08:07.480 --> 08:13.120]  вот я девятку хочу вставить, я вот пришел в семерку и вижу, что справа нет ребенка. Ну да,
[08:13.120 --> 08:32.720]  абсолютно логично. Я просто припишу девятку. То есть у нас спуск аналогичен find, только если
[08:32.720 --> 09:01.720]  пытаемся пройти по нуптер, то подвешиваем новый лист. Ну, собственно, не трудно догадаться тогда,
[09:01.760 --> 09:11.280]  как построить пример, чтобы у вас дерево выродилось в ветку. Ну да, и все, вы будете каждый раз подвешивать
[09:11.280 --> 09:23.120]  1, 2, 3, 4, 5 и у вас дерево превратилось в нечто, во что ему не стоит превращаться. Вот. Но опять же
[09:23.120 --> 09:36.680]  insert работает за оатаж, потому что у вас просто спуск и подвешивание листа. Теперь разберемся
[09:36.680 --> 09:49.240]  с ирейсом. Вот тут уже будет интереснее. У него будет три случая. Первый случай, что удаляемый
[09:49.240 --> 10:01.640]  элемент, ну первый случай самый простой, что удаляемый элемент одет детей. Удаляемый
[10:01.640 --> 10:10.080]  элемент без детка просто. Вот. В таком случае ваша жизнь крайне проста, вы просто самоудаляетесь.
[10:10.080 --> 10:24.120]  Например, вы хотите удалить девятку, вы ее нашли и такие, ну все, меня нет. Как бы самый простой
[10:24.120 --> 10:42.960]  случай. Окей. То есть если бездетный, просто удалить лист. Вот. Случай второй, он уже чуть
[10:42.960 --> 10:52.920]  сложнее и осложняется он наличием ребенка, но одного пока что. То есть удаляемый.
[10:54.960 --> 10:59.960]  Элемент имеет одного ребенка.
[11:04.960 --> 11:13.040]  Ну вот, например, ситуация с узлом 11. Как его удалить?
[11:13.040 --> 11:32.680]  Просто вот так вот сделать. И все. Здесь все. Ну не прям уж просто, потому что не просто вы перейти
[11:32.680 --> 11:55.600]  и что-то переподвесить уже. Связываем родителя удаляемого элемента и его ребенка.
[11:55.600 --> 12:19.920]  Вот. Третий случай, это когда вы обременены целыми двумя детьми. Вот. Что тогда по-вашему надо сделать?
[12:25.600 --> 12:46.440]  Ну сейчас. 8,6 какой-нибудь, не знаю. Вот такое вот дерево вы хотите удалить пятерку.
[12:46.440 --> 13:08.760]  Кого? Куда? К чему подвешивать четверку? Почему четверку? Хорошо, вот вы хотите уговорить
[13:08.760 --> 13:20.640]  мне подвесить четверку, да? Сейчас я чуть-чуть поправлю дерево, извините. Как я вам подвешу четверку,
[13:20.640 --> 13:34.200]  если у нее тоже может быть два ребенка? Ну 9, какая разница? Направду похоже? А, ну тут
[13:34.200 --> 13:45.880]  что-то должно быть больше. Сейчас. Здесь так, здесь так и здесь так. Вот, вроде на правду похоже.
[13:45.880 --> 14:08.360]  Кого? Вот это вот сюда вот? Так это же неправда, у вас тогда 10,9 будут будто бы меньше 8. Почему девятку?
[14:08.360 --> 14:24.400]  Ой, тройки тоже нет детей, что? Вот. То есть смотрите, очень хочется сделать, что на самом деле.
[14:24.400 --> 14:30.920]  Хочется сюда посадить кого-то, кто в этих поддеревьях не нарушит порядок, если их слапнуть.
[14:30.920 --> 14:38.120]  Ну кто это такой? Это либо наименьший элемент больше данного, вот если мы его сюда посадим,
[14:38.120 --> 14:44.760]  то все будет хорошо. Либо наибольший элемент меньше данного. Вот как найти вот эти вот элементы?
[14:44.760 --> 15:11.320]  Ну вот да. А почему у этого узла не может быть двух детей? А один ребенок может быть? Ну вот да.
[15:11.320 --> 15:16.240]  Да, есть так как известный анекдот про физиков и математиков, которые чай себе наливают.
[15:18.240 --> 15:24.760]  Не знаете анекдот? Грустная история. Вот. Но анекдот типа в том, что вот спрашивают,
[15:24.760 --> 15:29.960]  ну вот физика спрашивает, ну как заварить, у физика спрашивают, как заварить чай.
[15:29.960 --> 15:33.360]  Ну он говорит, там наливаю воду в чайник и кипячу.
[15:41.320 --> 15:49.320]  Какая разница? Да не все одинаково мысли. Вот. Ну короче, суть анекдота в том, что вот спрашивают,
[15:49.320 --> 15:54.520]  вот если чайник пустой, что делать? Вот говорят, ну налью воду, закипячу, да. А если в чайнике уже
[15:54.520 --> 15:59.960]  есть вода? Ну физик говорит, ну просто поставлю кипятиться и все. Математик говорит, что я вылью
[15:59.960 --> 16:05.280]  воду сначала, потом налью, потому что я свел задачу предыдущую уже, которую умел решать. Вот.
[16:05.280 --> 16:12.080]  И скептид-чайник. Здесь мы примерно тем же будем заниматься. То есть алгоритм в случае Ирейза
[16:18.840 --> 16:24.760]  такой. Шаг первый — это найти
[16:24.760 --> 16:44.880]  наименьший элемент больше данного. Ищется, да, он гениальным алгоритмом. То есть что значит
[16:44.880 --> 16:49.040]  элемент больше данного? Значит он где-то в правом поддереве. То есть нам нужно спуститься на один раз
[16:49.040 --> 16:52.280]  вправо. Хорошо, как найти из них наименьший? Идти влево до упора.
[16:52.280 --> 17:13.560]  1 шаг вправо и 100 шагов назад. И влево до упора. Вот. Ну тогда утверждается, что у этого узла не больше
[17:13.560 --> 17:33.760]  одного ребенка. Не больше одного ребенка.
[17:33.760 --> 17:56.040]  Свапаем значение и удаляем. То есть схематически 1 шаг вправо, 1000 шагов влево. Меняйте девятку с
[17:56.040 --> 18:09.280]  восьмеркой местами. Вот. Ну и теперь вырезайте вот этот узел. Ну у него может быть максимум один
[18:09.280 --> 18:29.800]  ребенок. Возвращаемся к второму случаю. Либо случай 1, либо 2. Вот такая вот простенькая
[18:29.800 --> 18:40.120]  структурка. Опять же, насколько и рейс работает? Ну да, от высоты, потому что вы один раз тут спустились
[18:40.120 --> 18:46.520]  что-то, нашли узел, посмотрели, есть ли у него там дети, если даже их оба. Вы там дальше спустились,
[18:46.520 --> 18:57.280]  но вы явно спустились не дальше, чем на высоту, чем один раз. Время и рейс.
[18:57.280 --> 19:09.400]  Вот аж. То есть мы с вами построили структуру, которая умеет find, insert и рейс, но здесь вместо
[19:09.400 --> 19:15.720]  log n стоит высота. Какая-то загадочная буква аж, которую мы пока что не умеем оценивать. И в целом
[19:15.720 --> 19:22.480]  выясняем, что в плохом случае, если нам подают insert в отсортированном порядке, то высота будет
[19:22.480 --> 19:28.000]  линейная. То есть как бы все совсем грустно, мы вырождаемся, даже не знаю, это не массив, это список
[19:28.000 --> 19:36.400]  какой-то. Вот. Собственно, вторую половину лекции мы потратим на то, чтобы построить дерево, которое
[19:36.400 --> 19:41.680]  будет аж от log n составлять. Вот, а первую половину мы пока что будем дальше развлекаться с деревьями,
[19:41.680 --> 19:50.080]  и что с ними можно делать. Вот, в частности, мы с вами обсудим вопрос, как корректно подчищать
[19:50.080 --> 19:53.560]  память за деревьями, потому что я понял по чату, что вы не умеете это делать.
[20:06.960 --> 20:12.840]  Ладно, будем считать, что это чистая доска. И у нас сейчас с вами будем говорить об обходах дерева.
[20:20.080 --> 20:28.240]  Вот, их есть три штуки. Давайте просто напишем функцию.
[20:28.240 --> 20:43.680]  И она будет выглядеть так, что если мы в NullPTL,
[20:43.680 --> 20:58.080]  то просто закончим выполнение свое. Вот, если мы не в NullPTL, мы будем делать следующее.
[21:14.640 --> 21:20.880]  Дальше у нас будет запуск от левого дерева, от дерева.
[21:28.640 --> 21:30.480]  Дальше мы зачем-то еще раз выведем элемент.
[21:38.920 --> 21:42.480]  Так, и остер, да, дерево? Блин, что новое рисовать что-то?
[21:44.680 --> 21:48.080]  Ладно, дальше будет запуск от правого по дереву.
[21:56.760 --> 21:58.440]  И снова выводим элемент.
[21:58.440 --> 22:17.040]  И заканчиваем функцию. Собственно, я не зря их пометил 1, 2 и 3, потому что это три разных обхода.
[22:17.040 --> 22:25.680]  Вот, есть когда ставят перед всеми рекурсийными визами, есть когда между ними, есть когда после всех.
[22:25.680 --> 22:31.240]  Давайте нарисуем какое-нибудь дерево, чтобы проиллюстрировать моему примеру.
[22:31.240 --> 22:36.280]  Не знаю, думаю 15 мне точно хватит в форне.
[22:55.680 --> 23:05.280]  Ладно, я пишу. Ну, выглядит достаточно страшно, как по мне, давайте без этого, без этих звуков.
[23:05.280 --> 23:13.280]  Вот, и сейчас мы будем с вами разбираться, что будет, если оставить только один из трех сяутов в каждом случае.
[23:13.280 --> 23:16.600]  Что будет получено, где у нас массивы выведутся.
[23:22.640 --> 23:28.800]  Вот, давайте, если у нас сяут стоит только где строчка 1, как будем расширять его?
[23:28.800 --> 23:32.600]  Мы будем расширять его, если у нас будет только один из трех сяутов.
[23:32.600 --> 23:41.720]  Вот, давайте, если у нас сяут стоит только где строчка 1, как будем массив получать?
[23:41.720 --> 23:53.920]  Это 13. Ну, то есть, да, сначала то, что в корне, дальше будет 10, потому что мы будем расширять его,
[23:54.240 --> 24:04.040]  дальше снова отлево, отлево, дальше мы поймем, что у нас нет детей, мы упрыгнем сюда и запустимся от правого ребенка.
[24:04.040 --> 24:11.840]  Снова нет детей, мы выпрыгнем, десятки уже были, выпрыгиваем, идем вправо ребенка,
[24:12.040 --> 24:18.760]  25, 20, 19, 21 и 30. Вроде бы всё. Что будет, если где цифра 2?
[24:18.760 --> 24:30.760]  Мы будем расширять его, если у нас будет только один из трех сяутов, то есть, что будет получено, где у нас массив будет?
[24:30.760 --> 24:38.760]  Вот, давайте, если у нас будет только один из трех сяутов, то, что будет получено, что мы будем расширять его,
[24:38.760 --> 24:45.760]  что будет, если где цифра 2?
[24:54.280 --> 24:57.480]  то есть вы сначала уйдете до конца влево
[24:57.480 --> 25:01.880]  когда у вас не будет левого сына, вы выведете элемент
[25:01.880 --> 25:06.280]  дальше у вас нет ни левого, ни правого сына, вы не запускайте, поднимайте вверх
[25:06.280 --> 25:08.680]  выводите элемент
[25:08.680 --> 25:13.680]  и обрабатываете правого сына. его тоже нет, снова идете сюда
[25:13.680 --> 25:14.560]  10
[25:14.560 --> 25:17.160]  выводите десятку
[25:17.160 --> 25:18.880]  идете в право сына обрабатывать
[25:18.880 --> 25:23.280]  вывели 13, потому что у нее нет детей
[25:23.280 --> 25:27.080]  дальше снова вернитесь в корень 15
[25:27.080 --> 25:32.240]  и пойдете обрабатывать право ребенка
[25:32.240 --> 25:37.800]  я думаю, уже многие догадались, что будет в итоге
[25:37.800 --> 25:42.120]  вы получили отсортированный массив из элементов, которые лежат в дереве
[25:42.120 --> 25:44.360]  но это, казалось бы, логично
[25:44.360 --> 25:46.040]  потому что
[25:46.040 --> 25:50.240]  вы говорите себе, что вот все, что меньше 15, сначала выведем
[25:50.240 --> 25:51.320]  я выведу все
[25:51.320 --> 25:53.440]  что меньше 15 сначала
[25:53.440 --> 25:56.840]  выведу 15, потому что все, что больше 15
[25:56.840 --> 26:03.240]  и так вы для каждого узла гарантируете себе это
[26:03.240 --> 26:05.160]  ну и давайте для
[26:05.160 --> 26:12.160]  гармонии третий случай выпишем
[26:15.520 --> 26:20.640]  вот что делать, если у нас вся вот вообще здесь стоит
[26:20.680 --> 26:27.000]  выводите, мы будем, когда закончили, уже обрабатывать под дерево
[26:27.000 --> 26:30.040]  то есть мы сначала спустились самое левое
[26:30.040 --> 26:34.000]  не обнаружили детей, вывели
[26:34.000 --> 26:38.840]  дальше поднялись вверх, попытались обработать правого сына, его нет
[26:38.840 --> 26:40.440]  вывели элемент
[26:40.440 --> 26:41.560]  дальше сюда
[26:41.560 --> 26:44.960]  попытались обработать правого сына, а он есть
[26:44.960 --> 26:48.440]  поэтому 13, 10
[26:48.440 --> 26:50.080]  дальше поднимаетесь сюда
[26:50.080 --> 26:53.040]  смотрите, есть ли правый сын, он есть
[26:53.040 --> 26:56.080]  окей, тогда выведем 15 потом
[26:56.080 --> 26:59.840]  идем сюда обрабатывать этого чувака, у него есть дети, да
[26:59.840 --> 27:02.600]  идет влево, идет влево
[27:02.600 --> 27:08.080]  добрался до узла, вывел его
[27:08.080 --> 27:10.920]  добрался до двадцатки, видит, что есть правый сын
[27:10.920 --> 27:12.800]  выводит его
[27:12.800 --> 27:15.320]  затем только сам элемент
[27:15.320 --> 27:16.880]  и поднимается вверх
[27:16.880 --> 27:22.040]  видит, что снова есть правый сын, идет сюда
[27:22.040 --> 27:27.240]  25 и 15
[27:27.240 --> 27:30.600]  будто бы бесполезно
[27:30.600 --> 27:33.720]  но на самом деле
[27:33.720 --> 27:38.120]  не то чтобы это прям бесполезно, давайте я выпишу их название
[27:38.120 --> 27:40.160]  preorder
[27:40.160 --> 27:43.160]  inorder
[27:43.200 --> 27:48.200]  давайте через def пишу
[27:48.200 --> 27:51.560]  и postorder
[27:51.560 --> 27:54.840]  здесь будто бы в порядке возрастания элементов
[27:54.840 --> 27:59.920]  а preorder и postorder, их названия порождены тем, что вы пишете либо
[27:59.920 --> 28:07.040]  перед всеми рекурсивными визами, либо после
[28:07.040 --> 28:12.880]  понятно, зачем нужен inorder-обход, если у вас есть дерево, вы можете вывести отсортированный массив
[28:12.920 --> 28:16.760]  внезапно это очень удобный способ дебага
[28:16.760 --> 28:20.880]  если у вас есть дерево, когда вы пишете свое дерево в поисках
[28:20.880 --> 28:24.240]  делаете его inorder-обход и у вас массив не отсортирован, то
[28:24.240 --> 28:29.880]  сто процентов у вас что-то не так в вашем дереве идет
[28:29.880 --> 28:37.120]  зачем нужен postorder-обход, как вы думаете?
[28:37.120 --> 28:42.560]  ну вот он хорош тем, что вы сначала обработали всех детей, а потом уже себя
[28:42.640 --> 28:48.120]  когда вы будете писать деструктор, страшное для вас слово, которое вы может еще не знаете
[28:48.120 --> 28:51.840]  штука, которая чистит память в дереве
[28:51.840 --> 28:57.280]  вы будете здесь писать, назовете ее clear-функцию
[28:57.280 --> 29:01.720]  и здесь будете вместо вот этого вот seout писать delete от ноды
[29:01.720 --> 29:05.440]  и у вас все очистится спокойно
[29:05.440 --> 29:08.040]  здесь очень простой способ удаления
[29:08.040 --> 29:11.760]  с точки зрения кода, с точки зрения интуиции он не очевиден
[29:11.760 --> 29:15.120]  а preorder-обход я не знаю зачем нужен, если честно
[29:15.120 --> 29:18.440]  он просто есть для гармонии
[29:18.440 --> 29:22.440]  он нам вроде как нигде не нужен будет
[29:24.000 --> 29:28.640]  у нас с вами вторая часть, и мы с вами
[29:28.640 --> 29:34.560]  будем на самом деле вот эту лекцию, оставшую эту половину лекции
[29:34.560 --> 29:38.760]  следующую лекцию, еще может быть еще следующую лекцию
[29:38.760 --> 29:43.440]  будем с вами строить разные деревья поиска
[29:43.440 --> 29:46.720]  в которых высота будет логарифм или около того
[29:46.720 --> 29:53.640]  и смотреть в каких ситуациях нам то или иное пригождается
[29:53.640 --> 29:55.040]  собственно окей
[29:55.040 --> 29:57.960]  и первое дерево это будет самое простое
[29:57.960 --> 30:02.040]  и все то, что самое простое, оно нигде не применяется
[30:02.040 --> 30:05.040]  это AVL дерево
[30:09.440 --> 30:13.440]  там у него есть три автора
[30:13.440 --> 30:17.960]  собственно AVL это их первая буква
[30:17.960 --> 30:20.960]  буква их фамилии
[30:20.960 --> 30:22.960]  в чем смысл AVL дерева?
[30:22.960 --> 30:25.960]  давайте назовем за определением
[30:25.960 --> 30:28.960]  AVL дерево
[30:30.960 --> 30:33.960]  это такое дерево поиска
[30:39.760 --> 30:44.760]  что для любого узла х
[30:50.760 --> 30:55.760]  вот такая вот величина дельта от х
[30:55.760 --> 30:59.760]  по модулю не превосходит единичке
[30:59.760 --> 31:02.760]  где дельта от х
[31:02.760 --> 31:06.760]  это разность
[31:06.760 --> 31:10.760]  высоты левого по дереву и правого по дереву
[31:12.760 --> 31:15.760]  а что высота?
[31:17.760 --> 31:20.760]  это левый ребенок
[31:22.760 --> 31:25.760]  это правый ребенок
[31:29.760 --> 31:33.760]  вот такое вот интересное дерево
[31:34.760 --> 31:38.760]  давайте для начала докажем, что если такое дерево можно построить
[31:38.760 --> 31:41.760]  то его высота будет логарифмической
[31:41.760 --> 31:44.760]  если говорить о ремо
[31:45.760 --> 31:48.760]  высота аж AVL дерева
[31:48.760 --> 31:51.760]  составляет от логарифма n
[31:51.760 --> 31:54.760]  где n это число элементов
[31:54.760 --> 31:57.760]  вот
[31:57.760 --> 32:00.760]  окей
[32:00.760 --> 32:03.760]  ну как это доказывать?
[32:03.760 --> 32:06.760]  ну как это доказывать?
[32:06.760 --> 32:09.760]  ну как это доказывать?
[32:10.760 --> 32:13.760]  окей
[32:13.760 --> 32:16.760]  ну как это доказывать?
[32:19.760 --> 32:22.760]  здесь вот такую интересную величину
[32:22.760 --> 32:25.760]  s от h это
[32:25.760 --> 32:28.760]  минимальное число
[32:28.760 --> 32:31.760]  элементов
[32:31.760 --> 32:34.760]  ну или вершин, как вам угодно
[32:34.760 --> 32:37.760]  узлов, вершин в AVL дереве
[32:39.760 --> 32:42.760]  высоты
[32:42.760 --> 32:45.760]  h
[32:45.760 --> 32:48.760]  мы сейчас будем с вами оценивать эту величину
[32:51.760 --> 32:54.760]  ну давайте выводите, с чего она состоит
[32:54.760 --> 32:57.760]  вот у вас есть дерево
[32:57.760 --> 33:00.760]  и вы знаете, что высота h
[33:00.760 --> 33:03.760]  представим, что здесь под дерево
[33:03.760 --> 33:06.760]  у него есть левый и правый ребенок
[33:09.760 --> 33:12.760]  очевидно, что у одного из них
[33:12.760 --> 33:15.760]  хотя бы высота h-1
[33:15.760 --> 33:18.760]  но чтобы у всего дерева была высота h
[33:18.760 --> 33:21.760]  допустим, у левого
[33:21.760 --> 33:24.760]  насколько очевиден факт, что s от h
[33:24.760 --> 33:27.760]  растет с ростом h?
[33:27.760 --> 33:30.760]  ну значит, тогда
[33:30.760 --> 33:33.760]  если мы хотим достичь минимальной оценки, то здесь мы можем себе позволить
[33:33.760 --> 33:36.760]  высоту поменьше, чем h-1
[33:36.760 --> 33:39.760]  но какую?
[33:39.760 --> 33:42.760]  вот h-2 можем
[33:42.760 --> 33:45.760]  и в целом мы здесь можем себе позволить высоту h-2 и h
[33:45.760 --> 33:48.760]  и h-1, извините
[33:48.760 --> 33:51.760]  высоту h сюда нельзя, потому что дерево было бы высоты h
[33:51.760 --> 33:54.760]  плюс 1 просто
[33:54.760 --> 33:57.760]  поэтому можно все, что меньше h, то есть h-1, h-2
[33:57.760 --> 34:00.760]  а h-3 нельзя по этому определению
[34:00.760 --> 34:03.760]  тогда у вас дисбаланс высот будет равен 2
[34:04.760 --> 34:07.760]  ну и так, мы хотим минимальности
[34:07.760 --> 34:10.760]  из этого следует, что
[34:10.760 --> 34:13.760]  есть вот такое вот соотношение
[34:20.760 --> 34:23.760]  вот, такая вот рекурренция интересная
[34:23.760 --> 34:26.760]  ну почему плюс 1?
[34:26.760 --> 34:29.760]  потому что вот у вас есть один узелок, который их связывает
[34:29.760 --> 34:32.760]  это понятно?
[34:32.760 --> 34:35.760]  вот сейчас нам нужно как-то
[34:35.760 --> 34:38.760]  оценить, как себя ведет вот s от h
[34:38.760 --> 34:41.760]  за эту великую рекурренту
[34:46.760 --> 34:49.760]  что?
[34:49.760 --> 34:52.760]  ну вот очень похоже на фибоначи будто бы, да?
[34:52.760 --> 34:55.760]  число фибоначи они вот так вот записывают
[34:55.760 --> 34:58.760]  с такой рекуррентой
[35:02.760 --> 35:05.760]  то есть там нет плюс 1, вот вопрос будет ли это плюс 1
[35:05.760 --> 35:08.760]  влиять на что-то
[35:11.760 --> 35:14.760]  хорош
[35:14.760 --> 35:17.760]  можно и логарифм вычесть и вообще высоту нулевой получить
[35:20.760 --> 35:23.760]  ну да, методы
[35:23.760 --> 35:26.760]  нет, настолько явно обманывать я вас не могу на алгоритмах
[35:26.760 --> 35:29.760]  ну давайте я докажу, что
[35:29.760 --> 35:32.760]  с ссс от h
[35:32.760 --> 35:35.760]  так сейчас будет великий подгон
[35:35.760 --> 35:38.760]  это что-то типа
[35:38.760 --> 35:41.760]  короче я поставлю равно, вот
[35:41.760 --> 35:44.760]  потом если окажется что-то не так, я переделаю
[35:44.760 --> 35:47.760]  что это число фибоначи
[35:47.760 --> 35:50.760]  что-то вот такое вот, h плюс 2 и минус 1
[35:50.760 --> 35:53.760]  давайте докажем по индукции
[35:54.760 --> 35:57.760]  что по индукции
[36:00.760 --> 36:03.760]  давайте базу проделаем
[36:03.760 --> 36:06.760]  дерево нулевой высоты
[36:06.760 --> 36:09.760]  это что такое
[36:09.760 --> 36:12.760]  ну сколько пустых деревьев существует
[36:12.760 --> 36:15.760]  ну дерево высоты 0, в нем 0 элементов
[36:15.760 --> 36:18.760]  поэтому 0
[36:18.760 --> 36:21.760]  да, видимо вот я вас тут и обманул
[36:21.760 --> 36:24.760]  минус 1 должно быть
[36:24.760 --> 36:27.760]  дальше s от единицы
[36:27.760 --> 36:30.760]  сколько может быть элементов дерева высоты 1
[36:30.760 --> 36:33.760]  ну 1 да, это корень просто его
[36:33.760 --> 36:36.760]  не, ну а что звучит
[36:36.760 --> 36:39.760]  да
[36:39.760 --> 36:42.760]  ну что подгоним
[36:42.760 --> 36:45.760]  так s от 2
[36:45.760 --> 36:48.760]  к чему равно
[36:48.760 --> 36:51.760]  ну видимо 2
[36:51.760 --> 36:54.760]  что
[36:54.760 --> 36:57.760]  не, мы базу подгоняем
[36:57.760 --> 37:00.760]  я хочу сейчас понять откуда надо брать числа, чтобы все сошлось
[37:00.760 --> 37:03.760]  так, ну а числа фибоначи
[37:03.760 --> 37:06.760]  f первая
[37:06.760 --> 37:09.760]  блин, плохо
[37:09.760 --> 37:12.760]  да
[37:12.760 --> 37:15.760]  ща, надо подогнать
[37:15.760 --> 37:18.760]  то есть нам нужно все-таки их сдвинуть
[37:18.760 --> 37:21.760]  щас
[37:21.760 --> 37:24.760]  аж плюс 2 все-таки
[37:24.760 --> 37:27.760]  да
[37:27.760 --> 37:30.760]  ну ладно, я поверю вам
[37:33.760 --> 37:36.760]  в смысле нет
[37:36.760 --> 37:39.760]  у вас единицы накапливаются кучу раз
[37:39.760 --> 37:42.760]  при каждом рекуссивном наборе
[37:45.760 --> 37:48.760]  я, к сожалению, ничего не понял
[37:48.760 --> 37:51.760]  но вот это похоже на правду
[37:51.760 --> 37:54.760]  и видимо это похоже на то, что вы сказали
[37:54.760 --> 37:57.760]  к сожалению, это невозможно распарсить
[37:57.760 --> 38:00.760]  в устной речи
[38:00.760 --> 38:03.760]  потому что, скажем так, это надо видеть
[38:03.760 --> 38:06.760]  а слышать этого мало
[38:06.760 --> 38:09.760]  вот, ну вот
[38:09.760 --> 38:12.760]  так
[38:12.760 --> 38:15.760]  а слышать этого мало
[38:15.760 --> 38:18.760]  короче, я поверю, что
[38:18.760 --> 38:21.760]  давайте договоримся на экзамене, что это правда
[38:21.760 --> 38:24.760]  так будет проще всем нам жить
[38:24.760 --> 38:27.760]  давайте доказывать, докажем по индукции
[38:30.760 --> 38:33.760]  база очевидна
[38:33.760 --> 38:36.760]  вот так вот напишем
[38:36.760 --> 38:39.760]  и все
[38:39.760 --> 38:42.760]  я развязываю себе руки
[38:42.760 --> 38:45.760]  в этом плане
[38:45.760 --> 38:48.760]  ну на самом деле да
[38:48.760 --> 38:51.760]  давайте распишем s от h, что это такое
[38:51.760 --> 38:54.760]  это s от h минус 1
[38:54.760 --> 38:57.760]  плюс s от h минус 2 плюс 1
[38:57.760 --> 39:00.760]  пользуемся индукцией
[39:00.760 --> 39:03.760]  вот здесь раскрываем по этой формуле
[39:03.760 --> 39:06.760]  в смысле переход
[39:06.760 --> 39:09.760]  и вот это слагаемо по этой формуле
[39:09.760 --> 39:12.760]  типа f h плюс 1
[39:12.760 --> 39:15.760]  минус 1
[39:15.760 --> 39:18.760]  плюс f h
[39:18.760 --> 39:21.760]  просто f h будет
[39:21.760 --> 39:24.760]  минус 1 плюс 1
[39:24.760 --> 39:27.760]  типа f h плюс 1
[39:27.760 --> 39:30.760]  плюс f h
[39:30.760 --> 39:33.760]  плюс 1
[39:33.760 --> 39:36.760]  ну внезапно вот это вот
[39:36.760 --> 39:39.760]  это f h плюс 2
[39:42.760 --> 39:45.760]  доказали, вау
[39:45.760 --> 39:48.760]  я считаю, что это было самое сложное доказательство в курсе
[39:51.760 --> 39:54.760]  где?
[39:54.760 --> 39:57.760]  это минус
[39:57.760 --> 40:00.760]  он просто слился с доской
[40:00.760 --> 40:03.760]  здесь надо
[40:03.760 --> 40:06.760]  ну не знаю, она уже даже отсвечивает от остатков маркера
[40:06.760 --> 40:09.760]  вот здесь надо по хорошему доску
[40:09.760 --> 40:12.760]  это очистить просто, ну ладно
[40:12.760 --> 40:15.760]  вот доказали
[40:15.760 --> 40:18.760]  вопрос в студию
[40:18.760 --> 40:21.760]  надо ли выводить вам формулу чисел Фибоначчо?
[40:21.760 --> 40:24.760]  о господи
[40:24.760 --> 40:27.760]  ладно, ну я сошлись на основную теорему рекуррентных соотношений
[40:28.760 --> 40:31.760]  ну в смысле
[40:31.760 --> 40:34.760]  теоремой доказывать не буду, само очевидно
[40:34.760 --> 40:37.760]  я выведу просто числа Фибоначчо из нее
[40:40.760 --> 40:43.760]  кого?
[40:43.760 --> 40:46.760]  я формулу думаешь помню?
[40:46.760 --> 40:49.760]  ладно, окей, я напишу, что теорема BD
[40:49.760 --> 40:52.760]  я сейчас напишу скорее всего какую-нибудь улажу
[40:52.760 --> 40:55.760]  но вы простите меня
[40:55.760 --> 40:58.760]  что числа Фибоначчо
[40:58.760 --> 41:01.760]  это фи в степени n
[41:01.760 --> 41:04.760]  что не такое?
[41:04.760 --> 41:07.760]  в каком там формуле?
[41:07.760 --> 41:10.760]  вот
[41:10.760 --> 41:13.760]  где фи?
[41:13.760 --> 41:16.760]  это корень из 5 минус 1 пополам
[41:16.760 --> 41:19.760]  ставлю голову на отсечение, что здесь есть ошибка
[41:19.760 --> 41:22.760]  вот, но
[41:22.760 --> 41:25.760]  ну это не особо важно
[41:25.760 --> 41:28.760]  скажем так
[41:28.760 --> 41:31.760]  ну вот типа минус фи это что такое?
[41:31.760 --> 41:34.760]  ну это что-то отрицательное, но при этом оно в степени минус m
[41:34.760 --> 41:37.760]  вообще маленькое какое-то, да?
[41:37.760 --> 41:40.760]  ну давайте напишем так, может так будет правильно
[41:40.760 --> 41:43.760]  ну ладно, неважно
[41:43.760 --> 41:46.760]  правильно?
[41:46.760 --> 41:49.760]  ничего себе, я помню
[41:49.760 --> 41:52.760]  ну из этого следует в частности
[41:52.760 --> 41:55.760]  что fn равно от фи в степени n
[41:58.760 --> 42:01.760]  или логарифм fn
[42:04.760 --> 42:07.760]  от фи что ли?
[42:07.760 --> 42:10.760]  сейчас, если возьму логарифм отсюда и отсюда
[42:10.760 --> 42:13.760]  ну это забываем, очевидно
[42:13.760 --> 42:16.760]  я получаю n лог фи
[42:16.760 --> 42:19.760]  вот n
[42:20.760 --> 42:23.760]  ну это похоже, да
[42:30.760 --> 42:33.760]  ну это 1 делить на фи будет
[42:33.760 --> 42:36.760]  вот первая из второго получается через 1 делить на фи
[42:36.760 --> 42:39.760]  вот корень из 5 минус 1 пополам
[42:39.760 --> 42:42.760]  и корень из 5 плюс 1 пополам, оно
[42:42.760 --> 42:45.760]  вы получаете одно из другого, выполняя 1 делить на х
[42:45.760 --> 42:48.760]  вот
[42:48.760 --> 42:51.760]  ну нам важно, короче говоря, что числа f иначе растут экспоненциально
[42:51.760 --> 42:54.760]  вот это самое главное из этого всего дела
[42:57.760 --> 43:00.760]  то есть
[43:00.760 --> 43:03.760]  f от h
[43:03.760 --> 43:06.760]  от фи в степени h
[43:06.760 --> 43:09.760]  вот
[43:09.760 --> 43:12.760]  ну из этого что тогда следует?
[43:12.760 --> 43:15.760]  из этого следует, что h
[43:17.760 --> 43:20.760]  что-то типа
[43:21.760 --> 43:24.760]  ну мы сами знаем, что
[43:24.760 --> 43:27.760]  если s от h равно o от phi от h
[43:30.760 --> 43:33.760]  давайте даже так напишем
[43:35.760 --> 43:38.760]  мы же не на дискретках, чтобы мучиться
[43:38.760 --> 43:41.760]  напишем вот так вот, очень сильная оценка
[43:41.760 --> 43:44.760]  вот, и мы знаем, что n оно
[43:44.760 --> 43:47.760]  число элементов, n маленькое
[43:47.760 --> 43:50.760]  оно очевидно больше либо равно, чем s от h
[43:50.760 --> 43:53.760]  что равно фи в степени h
[43:53.760 --> 43:56.760]  приблизительно
[43:56.760 --> 43:59.760]  откуда следует, что h
[43:59.760 --> 44:02.760]  равно от лог n
[44:03.760 --> 44:06.760]  вот так вот
[44:07.760 --> 44:10.760]  безумно строго
[44:10.760 --> 44:13.760]  достаточно для алгоритмов
[44:13.760 --> 44:16.760]  вот мы с вами доказали
[44:16.760 --> 44:19.760]  что если такое дерево можно как-то строить быстро
[44:19.760 --> 44:22.760]  то его уста будет хороший
[44:22.760 --> 44:25.760]  давайте разберемся с тем, как его строить
[44:25.760 --> 44:28.760]  а что, звучит?
[44:28.760 --> 44:31.760]  ну такие вещи
[44:31.760 --> 44:34.760]  помнить наизусть вообще страшно
[44:34.760 --> 44:37.760]  есть вещи, которые лучше помнить наизусть, чем формула Бене
[44:37.760 --> 44:40.760]  вот
[44:40.760 --> 44:43.760]  ну окей
[44:43.760 --> 44:46.760]  собственно, вопрос-то
[44:46.760 --> 44:49.760]  пробьем в чем? Пробьем в том, что у нас есть
[44:49.760 --> 44:52.760]  в том, что у нас есть
[44:52.760 --> 44:55.760]  вот ваш прекрасный дерево в форме шапки
[44:55.760 --> 44:58.760]  или паруса
[44:58.760 --> 45:01.760]  вот вы к нему подвесили элемент
[45:01.760 --> 45:04.760]  наивно
[45:04.760 --> 45:07.760]  проблема в том, что у вас здесь
[45:07.760 --> 45:10.760]  может оказаться у его родителей
[45:10.760 --> 45:13.760]  дисбаланс высот теперь
[45:13.760 --> 45:16.760]  ну или не у его родителей, а у его деда
[45:16.760 --> 45:19.760]  ну типа у деда здесь не было детей
[45:20.760 --> 45:23.760]  ну типа у деда здесь не было детей
[45:23.760 --> 45:26.760]  вот у него был один ребенок, все было хорошо
[45:26.760 --> 45:29.760]  теперь у него появился внук и деду стало плохо
[45:29.760 --> 45:32.760]  ну да, у нас
[45:32.760 --> 45:35.760]  в деревьях поиска у нас будут с вами такие
[45:35.760 --> 45:38.760]  родственные связи, назовем это
[45:38.760 --> 45:41.760]  и просьба не ржать слишком громко
[45:41.760 --> 45:44.760]  окей
[45:44.760 --> 45:47.760]  собственно нужно как-то это все сбалансировать
[45:47.760 --> 45:50.760]  вот деду нужно дать спокойствие
[45:50.760 --> 45:53.760]  выполнить что-нибудь такое
[45:53.760 --> 45:56.760]  типа давайте это x, y, z
[45:56.760 --> 45:59.760]  вот хочется будто бы вместо
[45:59.760 --> 46:02.760]  деда поставить отца
[46:02.760 --> 46:05.760]  и сделать деда молодым
[46:05.760 --> 46:08.760]  снова ребенком
[46:08.760 --> 46:11.760]  что-нибудь такое сделать хочется
[46:11.760 --> 46:14.760]  вот, и такие вот операции, они называются повороты
[46:14.760 --> 46:17.760]  вот
[46:17.760 --> 46:20.760]  вообще это все будет называться балансировкой
[46:24.760 --> 46:27.760]  вот у разных деревьев поиска она по-разному проходит
[46:27.760 --> 46:30.760]  у кого-то это повороты, например у АВЛ
[46:30.760 --> 46:33.760]  или красночерного дерева
[46:33.760 --> 46:36.760]  у кого-то там за счет других вещей, типа у дикартового дерева будет
[46:36.760 --> 46:39.760]  что там балансировка вообще из нее откуда берется
[46:39.760 --> 46:42.760]  мы доказывать даже скорее всего не будем откуда она берется
[46:42.760 --> 46:45.760]  как факт это
[46:45.760 --> 46:48.760]  окей теперь
[46:48.760 --> 46:51.760]  что мы сделаем с вами
[46:51.760 --> 46:54.760]  рассмотрим как можно балансировать
[46:54.760 --> 46:57.760]  а именно здесь мне придется подглянуть
[46:57.760 --> 47:00.760]  потому что там какие-то очень красивые картиночки
[47:03.760 --> 47:06.760]  и они у меня закрылись
[47:06.760 --> 47:09.760]  сейчас минутку
[47:12.760 --> 47:15.760]  вот
[47:15.760 --> 47:18.760]  давайте рассмотрим вот такую вот ситуацию
[47:18.760 --> 47:21.760]  это узел А
[47:21.760 --> 47:24.760]  это узел В
[47:24.760 --> 47:27.760]  это узел С
[47:27.760 --> 47:30.760]  даже не так, здесь будет не узел, а целое поддерево
[47:30.760 --> 47:33.760]  В
[47:33.760 --> 47:36.760]  и у него будет два ребенка Q
[47:36.760 --> 47:39.760]  и R
[47:39.760 --> 47:42.760]  и треугольничками целые поддеревья
[47:42.760 --> 47:45.760]  сейчас мы расставим высоты
[47:51.760 --> 47:54.760]  то есть первый случай у нас будет дельта от А
[47:54.760 --> 47:57.760]  равно чему
[47:57.760 --> 48:00.760]  аж минус три минус вот эта вот штука
[48:00.760 --> 48:03.760]  блин, это сложно, помогите
[48:03.760 --> 48:06.760]  минус два, да, по-моему
[48:06.760 --> 48:09.760]  когда вы допустим сюда всунули узел новый
[48:09.760 --> 48:12.760]  и этому стало плохо
[48:12.760 --> 48:15.760]  у него нарушилась внутренняя гармония
[48:26.760 --> 48:29.760]  и мы будем рассматривать сами сейчас две ситуации
[48:32.760 --> 48:35.760]  то есть баланс вот этого правого ребенка
[48:35.760 --> 48:38.760]  либо минус один, либо ноль
[48:38.760 --> 48:41.760]  то есть все хорошо, у этого чувака, у этого все плохо
[48:41.760 --> 48:44.760]  что тогда предлагают сделать
[48:44.760 --> 48:47.760]  предлагают вам сделать такой вот поворот
[48:47.760 --> 48:50.760]  он называется малый левый
[48:50.760 --> 48:53.760]  поворот
[48:53.760 --> 48:56.760]  и получаете вот такую вот штуку
[48:56.760 --> 48:59.760]  это П
[48:59.760 --> 49:02.760]  вру, нет, не так
[49:02.760 --> 49:05.760]  здесь будет А, у него будет П
[49:05.760 --> 49:08.760]  у него будет Q
[49:08.760 --> 49:11.760]  и здесь у него будет R
[49:11.760 --> 49:14.760]  но казалось бы
[49:14.760 --> 49:17.760]  будто соотношения в плане сравнения элементов
[49:17.760 --> 49:20.760]  не ухудшились, не изменились никак
[49:20.760 --> 49:23.760]  почему? потому что все элементы Q
[49:23.760 --> 49:26.760]  они должны быть больше А и меньше B
[49:26.760 --> 49:29.760]  а не меньше B, потому что в левом поддереве
[49:30.760 --> 49:33.760]  но аналогично П и R рассматриваются
[49:33.760 --> 49:36.760]  П был самым маленьким и остался, R был самым большим и остался
[49:36.760 --> 49:39.760]  давайте расставим высоты
[49:39.760 --> 49:42.760]  у П высота была h-3
[49:42.760 --> 49:45.760]  у Q h-2, у R h-2
[49:45.760 --> 49:48.760]  тогда какая здесь высота?
[49:48.760 --> 49:51.760]  в смысле h?
[49:51.760 --> 49:54.760]  h-1, да, вы берете максимум из этих двух и прибавляете единичку
[49:54.760 --> 49:57.760]  тогда здесь h
[49:57.760 --> 50:00.760]  и как видите у вас
[50:00.760 --> 50:03.760]  дисбаланс устранился, все узлы сбалансированы
[50:03.760 --> 50:06.760]  почему здесь может быть
[50:06.760 --> 50:09.760]  минус 1?
[50:09.760 --> 50:12.760]  потому что если здесь минус 1 дисбаланс, значит здесь высота h-3
[50:12.760 --> 50:15.760]  а если здесь высота h-3
[50:15.760 --> 50:18.760]  значит здесь будет h-3, значит здесь h-2
[50:18.760 --> 50:21.760]  значит здесь h-1 и вообще все прекрасно
[50:21.760 --> 50:24.760]  они вообще поровну будут
[50:24.760 --> 50:27.760]  в плюс-минус 1 еще
[50:27.760 --> 50:30.760]  вот, отлично
[50:30.760 --> 50:33.760]  угадайте в словосочетании малый-левый поворот
[50:33.760 --> 50:36.760]  сколько слов можно менять
[50:36.760 --> 50:39.760]  и получите все наборы поворотов, которые в этом есть дереве
[50:39.760 --> 50:42.760]  малый можно менять на большой, а левый на правый
[50:42.760 --> 50:45.760]  всего два на два-четыре комбинации
[50:45.760 --> 50:48.760]  все четыре поворота есть
[50:48.760 --> 50:51.760]  и они нужны будут для балансировки
[50:51.760 --> 50:54.760]  сейчас разберу большой-левый
[50:54.760 --> 50:57.760]  воспользуюсь гениальной фразой, что правый зеркально
[50:57.760 --> 51:00.760]  давайте я объясню
[51:00.760 --> 51:03.760]  почему левый
[51:03.760 --> 51:06.760]  потому что вы вращаете в этом направлении
[51:06.760 --> 51:09.760]  относительно вот этого вот ребра
[51:09.760 --> 51:12.760]  то есть вы берете вот это вот ребро
[51:12.760 --> 51:15.760]  и прокручиваете его вот так вот
[51:15.760 --> 51:18.760]  в этом направлении оно у вас вместо такого остается таким
[51:19.760 --> 51:22.760]  потому что будет большой сейчас
[51:25.760 --> 51:28.760]  сейчас увидите, вы куда торопитесь
[51:28.760 --> 51:31.760]  видите, я чищу доску, у меня сейчас картинка большая будет
[51:31.760 --> 51:34.760]  ну большой поворот
[51:34.760 --> 51:37.760]  я спойлерную сразу, он состоит из двух маленьких
[51:37.760 --> 51:40.760]  или малых
[51:40.760 --> 51:43.760]  а-та-та-та
[51:43.760 --> 51:46.760]  я снова воспользуюсь подсказкой
[51:46.760 --> 51:49.760]  потому что здесь еще хуже картинка будет
[51:49.760 --> 51:52.760]  чем тогда
[51:58.760 --> 52:01.760]  это A, это P
[52:02.760 --> 52:05.760]  это B
[52:05.760 --> 52:08.760]  это D
[52:08.760 --> 52:11.760]  это B
[52:11.760 --> 52:14.760]  это C
[52:14.760 --> 52:17.760]  это здесь 1, здесь 2
[52:17.760 --> 52:20.760]  здесь 3
[52:20.760 --> 52:23.760]  B, Q, R, S
[52:24.760 --> 52:27.760]  здесь h-3, здесь h-1
[52:27.760 --> 52:30.760]  высота у этого, потому что мы все еще рассмотрим
[52:30.760 --> 52:33.760]  в случае дельта от A равно минус 2
[52:33.760 --> 52:36.760]  только теперь дельта от B будет равно 1
[52:38.760 --> 52:41.760]  а-та-та
[52:41.760 --> 52:44.760]  а-та-та
[52:44.760 --> 52:47.760]  а-та-та
[52:47.760 --> 52:50.760]  а-та-та
[52:50.760 --> 52:53.760]  ну здесь уже не важно, какая высота
[52:53.760 --> 52:56.760]  главное, чтобы здесь хотя бы у одного было аж минус 3
[52:56.760 --> 52:59.760]  вот
[52:59.760 --> 53:02.760]  и все это под действием большого
[53:02.760 --> 53:05.760]  левого поворота
[53:08.760 --> 53:11.760]  большой
[53:11.760 --> 53:14.760]  левый поворот
[53:14.760 --> 53:17.760]  что получится?
[53:17.760 --> 53:20.760]  сейчас
[53:20.760 --> 53:23.760]  что-нибудь типа такого
[53:23.760 --> 53:26.760]  T, сюда B
[53:26.760 --> 53:29.760]  сюда A, сюда P
[53:29.760 --> 53:32.760]  сюда Q
[53:32.760 --> 53:35.760]  сюда R
[53:35.760 --> 53:38.760]  сюда Q
[53:38.760 --> 53:41.760]  сюда R, сюда S
[53:41.760 --> 53:44.760]  давайте расставим высоту
[53:44.760 --> 53:47.760]  h-3, Q h-3
[53:47.760 --> 53:50.760]  R
[53:50.760 --> 53:53.760]  h-4, h-3
[53:53.760 --> 53:56.760]  здесь h-2, здесь h-2
[53:56.760 --> 53:59.760]  h-1
[53:59.760 --> 54:02.760]  ну видите, дисбаланса нет нигде, мы исправили эту проблему
[54:02.760 --> 54:05.760]  окей
[54:05.760 --> 54:08.760]  как, собственно, этот поворот выполняется?
[54:08.760 --> 54:11.760]  ну внезапно он состоит из двух поворотов, как я вам сказал
[54:11.760 --> 54:14.760]  здесь есть малый правый вокруг этого ребра
[54:14.760 --> 54:17.760]  первым шагом выполняется
[54:17.760 --> 54:20.760]  то есть у вас C встает в корень этого подерева вместо B
[54:20.760 --> 54:23.760]  а дальше выполняется вторым шагом
[54:23.760 --> 54:26.760]  здесь малый левый поворот
[54:26.760 --> 54:29.760]  то есть у вас C сначала сюда пробросилась, а потом еще сюда
[54:30.760 --> 54:33.760]  мы храним высоты под деревьев
[54:33.760 --> 54:36.760]  в узле
[54:36.760 --> 54:39.760]  нода хранит еще высоту, да
[54:39.760 --> 54:42.760]  ну и что мы тогда сравниваем?
[54:42.760 --> 54:45.760]  вот смотрите, у вас есть узел, да
[54:45.760 --> 54:48.760]  вот вы находитесь в каком-то узле
[54:48.760 --> 54:51.760]  у каждого узела знают высоту своего поддерева
[54:51.760 --> 54:54.760]  вы смотрите влево ребёнка высоту, вправо ребёнка высоту
[54:54.760 --> 54:57.760]  смотрите, ну и вы читаете одно из другого
[54:57.760 --> 55:00.760]  у вас получается дельта от A
[55:00.760 --> 55:03.760]  если оно равно минус 2, вам нужно применять либо малый левый
[55:03.760 --> 55:06.760]  либо большой левый
[55:06.760 --> 55:09.760]  дальше идете вправо ребёнка и спрашиваете, какой у тебя дисбаланс, чувак
[55:09.760 --> 55:12.760]  он говорит, либо это, либо это
[55:12.760 --> 55:15.760]  либо 1, либо остальное
[55:22.760 --> 55:25.760]  не тем, что здесь дельта от B, либо минус 1, либо 0
[55:25.760 --> 55:28.760]  а тут единичка
[55:28.760 --> 55:31.760]  и нам приходится по-разному с ними разбираться
[55:31.760 --> 55:34.760]  то есть если бы у вас здесь была единица, то у вас здесь было бы что-то типа
[55:34.760 --> 55:37.760]  h-2, здесь h-3, допустим, да
[55:37.760 --> 55:40.760]  и если бы вы сюда переставили, у вас было бы здесь h-3
[55:40.760 --> 55:43.760]  и вы бы не избавились бы дисбаланса так просто
[55:43.760 --> 55:46.760]  то есть вам нужно вовлекать на один уровень больше
[55:46.760 --> 55:49.760]  глубже лезть в структуру, чтобы ее поменять
[55:50.760 --> 55:53.760]  вот
[55:53.760 --> 55:56.760]  это все, конечно, классно
[55:58.760 --> 56:03.760]  балансировка делается не просто одним из четырех видов поворотов
[56:07.760 --> 56:10.760]  а на самом деле делается она следующим образом
[56:15.760 --> 56:18.760]  берем
[56:18.760 --> 56:21.760]  самый нижний
[56:23.760 --> 56:26.760]  затронутый узел
[56:29.760 --> 56:32.760]  ну вот, например, при удалении, когда у вас там два ребенка есть
[56:32.760 --> 56:35.760]  вы же там делаете 1 шаг вправо и 1000 шагов влево
[56:35.760 --> 56:38.760]  нужно вот это вот, самый нижний брать его
[56:44.760 --> 56:47.760]  далее
[56:48.760 --> 56:51.760]  вызываем
[56:51.760 --> 56:54.760]  от него один из поворотов
[57:02.760 --> 57:05.760]  при необходимости, естественно
[57:14.760 --> 57:17.760]  рекурсивно повторить от родителя
[57:18.760 --> 57:21.760]  вот
[57:21.760 --> 57:24.760]  давайте я нарисую картинку какую-нибудь, чтобы было понятно
[57:24.760 --> 57:27.760]  вот ваше прекрасное дерево
[57:27.760 --> 57:30.760]  вот у вас есть какой-то путь до координата узла х
[57:30.760 --> 57:33.760]  вы хотите сделать и рейс от х
[57:36.760 --> 57:39.760]  дальше у него есть там левый сын
[57:39.760 --> 57:42.760]  и правый сын
[57:42.760 --> 57:45.760]  и вот здесь
[57:45.760 --> 57:48.760]  у вас есть один сын и правый сын
[57:48.760 --> 57:51.760]  в котором, вот этот узел, у которого есть путь
[57:51.760 --> 57:54.760]  до узла z
[57:54.760 --> 57:57.760]  у которого нет правого ребенка
[57:57.760 --> 58:00.760]  тут нет левого, извините, правого может быть
[58:00.760 --> 58:03.760]  вот тогда вам нужно сделать
[58:03.760 --> 58:06.760]  вызвать от z повороты, если они вам необходимы
[58:06.760 --> 58:09.760]  и дальше рекурсивно по всему этому пути вверх пробежаться
[58:09.760 --> 58:12.760]  сделать эти повороты
[58:12.760 --> 58:15.760]  соответственно, у вас после поворотов высоты в под деревьях обновляются
[58:15.760 --> 58:18.760]  вам может
[58:18.760 --> 58:21.760]  раньше не надо было делать поворота, а теперь стало надо
[58:21.760 --> 58:24.760]  вот
[58:24.760 --> 58:27.760]  за сколько это работает?
[58:27.760 --> 58:30.760]  все повороты работают за 1
[58:30.760 --> 58:33.760]  просто немножко большие
[58:33.760 --> 58:36.760]  большие от 1, потому что вам нужно здесь какие-то указатели
[58:36.760 --> 58:39.760]  переподвешивать, а указатели это всегда не быстрая история
[58:39.760 --> 58:42.760]  вот
[58:42.760 --> 58:45.760]  а раз вам нужно просто подняться вверх на высоту
[58:45.760 --> 58:48.760]  то время работы
[58:48.760 --> 58:51.760]  под лог
[58:51.760 --> 58:54.760]  n
[58:54.760 --> 58:57.760]  вот такая вот история
[58:57.760 --> 59:00.760]  то есть мы с вами научились
[59:00.760 --> 59:03.760]  что происходит? вы делаете вставку и удаление
[59:03.760 --> 59:06.760]  как в наивном дереве поиска, о котором мы обсуждали на первой половине лекции
[59:06.760 --> 59:09.760]  дальше вы вызываете от самого нижнего затронутого узла балансировку
[59:09.760 --> 59:12.760]  вот
[59:12.760 --> 59:15.760]  и утверждается, что все время будет все корректно
[59:15.760 --> 59:18.760]  но как это можно доказывать? доказывать это нужно по индукции
[59:18.760 --> 59:21.760]  пустое дерево корректно
[59:21.760 --> 59:24.760]  оно удовлетворяет определение AVL дерева, согласны?
[59:24.760 --> 59:27.760]  ставить один элемент и вызвать от него балансировку
[59:27.760 --> 59:30.760]  все будет хорошо
[59:30.760 --> 59:33.760]  то есть у вас в каждый момент времени дерево
[59:33.760 --> 59:36.760]  перед следующим запросом будет
[59:36.760 --> 59:39.760]  в органическом состоянии
[59:39.760 --> 59:42.760]  в кондиции
[59:42.760 --> 59:45.760]  теперь нужно понять, а что будет
[59:45.760 --> 59:48.760]  если мы сделали какую-то операцию и дерево стало не в кондиции
[59:48.760 --> 59:51.760]  почему оно станет внезапно здоровым?
[59:51.760 --> 59:54.760]  давайте это докажем
[59:54.760 --> 59:57.760]  вот у вас путь до элемента X
[59:57.760 --> 01:00:00.760]  самый нижний затронутый элемент
[01:00:00.760 --> 01:00:03.760]  где у вас мог измениться баланс?
[01:00:06.760 --> 01:00:09.760]  только в этом под деревья, правда?
[01:00:09.760 --> 01:00:12.760]  во всех остальных местах все хорошо
[01:00:12.760 --> 01:00:15.760]  вот в этом под деревья может быть все плохо
[01:00:15.760 --> 01:00:18.760]  а во всех остальных местах все хорошо
[01:00:18.760 --> 01:00:21.760]  давайте мы здесь поправим поворотами
[01:00:21.760 --> 01:00:24.760]  потому что здесь с ниже тоже все хорошо
[01:00:24.760 --> 01:00:27.760]  так и в этом узле все плохо
[01:00:27.760 --> 01:00:30.760]  потому что вы здесь что-то покрутили
[01:00:30.760 --> 01:00:33.760]  у вас высоты изменились
[01:00:33.760 --> 01:00:36.760]  например, было h, а стало h-1
[01:00:36.760 --> 01:00:39.760]  и у вас баланс изменился, у вас высоты изменились
[01:00:39.760 --> 01:00:42.760]  поэтому этому чуваку может стать плохо
[01:00:42.760 --> 01:00:45.760]  то есть у вас плохо вот в этом под деревья
[01:00:45.760 --> 01:00:48.760]  ну вы пофиксили поворотом и здесь все хорошо
[01:00:48.760 --> 01:00:51.760]  дальше, может быть снова чоку стать плохо
[01:00:51.760 --> 01:00:54.760]  тогда вы утверждаете, что вот в этом под деревья
[01:00:54.760 --> 01:00:57.760]  все фиксируется за счет поворота
[01:00:57.760 --> 01:01:00.760]  и так далее, и у вас все фиксируется во всем дереве
[01:01:00.760 --> 01:01:03.760]  когда вы дошли до корня
[01:01:06.760 --> 01:01:09.760]  конечно
[01:01:09.760 --> 01:01:12.760]  алгоритмисты это великие обманщики, это большой логен
[01:01:12.760 --> 01:01:15.760]  мы проходим логен
[01:01:15.760 --> 01:01:18.760]  мы спускаемся логен
[01:01:18.760 --> 01:01:21.760]  дальше балансируем здесь от единицы
[01:01:21.760 --> 01:01:24.760]  высоту
[01:01:24.760 --> 01:01:27.760]  сколько мы спустились, столько и поднялись
[01:01:27.760 --> 01:01:30.760]  поэтому все логен работает
[01:01:30.760 --> 01:01:33.760]  почему это?
[01:01:33.760 --> 01:01:36.760]  ну...
[01:01:36.760 --> 01:01:39.760]  сейчас
[01:01:39.760 --> 01:01:42.760]  вот если здесь delta от b равно 0
[01:01:42.760 --> 01:01:45.760]  если здесь delta от b равно минус 1
[01:01:45.760 --> 01:01:48.760]  то здесь h-3
[01:01:48.760 --> 01:01:51.760]  то в куб было бы h-3
[01:01:51.760 --> 01:01:54.760]  здесь было бы h-2
[01:01:54.760 --> 01:01:57.760]  здесь было бы h-1
[01:01:57.760 --> 01:02:00.760]  и высота поменялась бы
[01:02:00.760 --> 01:02:03.760]  то есть вам не нужно делать дальше повороты
[01:02:03.760 --> 01:02:06.760]  если у вас delta от a равно минус 2
[01:02:06.760 --> 01:02:09.760]  и delta от b равно 0
[01:02:09.760 --> 01:02:12.760]  тогда действительно вам больше не нужно делать поворотов
[01:02:12.760 --> 01:02:15.760]  потому что у вас высоты не изменятся
[01:02:15.760 --> 01:02:18.760]  ну да
[01:02:18.760 --> 01:02:21.760]  у вас будет на семинаре подробная задача
[01:02:21.760 --> 01:02:24.760]  доказать, что там будут вот единицы поворотов
[01:02:24.760 --> 01:02:27.760]  во вставке
[01:02:27.760 --> 01:02:30.760]  при рейзе это неправда
[01:02:30.760 --> 01:02:33.760]  но сначала вы будете доказывать, что если у вас в какой-то момент времени
[01:02:33.760 --> 01:02:36.760]  вы поднимаетесь по этому пути
[01:02:36.760 --> 01:02:39.760]  и выяснили, что вам здесь не нужно делать поворотов
[01:02:39.760 --> 01:02:42.760]  то и выше не нужно будет делать поворотов, но это очевидно
[01:02:42.760 --> 01:02:45.760]  дальше вы будете доказывать, что если у вас вставка элементов
[01:02:45.760 --> 01:02:48.760]  достаточно от единиц поворотов сделать
[01:02:48.760 --> 01:02:51.760]  но это на семинаре останется
[01:02:51.760 --> 01:02:54.760]  окей, ладно, тогда сколько у нас времени осталось?
[01:02:54.760 --> 01:02:57.760]  10 минут целых
[01:02:57.760 --> 01:03:00.760]  впервые что лекцию раньше закончить
[01:03:00.760 --> 01:03:03.760]  или что-нибудь еще рассказать?
[01:03:03.760 --> 01:03:06.760]  да
[01:03:06.760 --> 01:03:09.760]  да
[01:03:09.760 --> 01:03:12.760]  да
[01:03:12.760 --> 01:03:15.760]  еще раз
[01:03:15.760 --> 01:03:18.760]  вы храните в узле высоту под дерево
[01:03:18.760 --> 01:03:21.760]  вы спрашиваете у узла
[01:03:21.760 --> 01:03:24.760]  какая высота под дерево левого ребенка
[01:03:24.760 --> 01:03:27.760]  какая высота под дерево правого ребенка
[01:03:27.760 --> 01:03:30.760]  у вас же дельта от х
[01:03:30.760 --> 01:03:33.760]  это h от xl
[01:03:33.760 --> 01:03:36.760]  минус h от xr
[01:03:36.760 --> 01:03:39.760]  вы спрашиваете у xl и у xr какие у них высоты
[01:03:39.760 --> 01:03:42.760]  они вам отвечают
[01:03:42.760 --> 01:03:45.760]  раз с ним ответили вы можете посчитать дельту
[01:03:45.760 --> 01:03:48.760]  в зависимости от ситуации у вас будут разные
[01:03:48.760 --> 01:03:51.760]  давайте сразу скажем
[01:03:51.760 --> 01:03:54.760]  что малый правый поворот
[01:03:54.760 --> 01:03:57.760]  если у вас будет дельта от а равно 2
[01:03:57.760 --> 01:04:00.760]  и дельта от b 0 или 1
[01:04:00.760 --> 01:04:03.760]  все будет симметрично с точностью до знака
[01:04:03.760 --> 01:04:06.760]  ну и большой правый
[01:04:06.760 --> 01:04:09.760]  дельта от а равно 2
[01:04:09.760 --> 01:04:12.760]  дельта от b равно минус 1
[01:04:12.760 --> 01:04:15.760]  давайте тогда обсудим с вами
[01:04:15.760 --> 01:04:18.760]  еще одну вещь
[01:04:18.760 --> 01:04:21.760]  я так понял, что вы все полюбили
[01:04:21.760 --> 01:04:24.760]  поиск катой порядковой статистики
[01:04:24.760 --> 01:04:27.760]  в контесте
[01:04:27.760 --> 01:04:30.760]  давайте научимся искать ее за логорифом
[01:04:30.760 --> 01:04:33.760]  есть дерево поиска
[01:04:33.760 --> 01:04:36.760]  мы хотим искать каты
[01:04:36.760 --> 01:04:39.760]  по возрастанию элементов
[01:04:55.760 --> 01:04:58.760]  смотрите, что вам нужно сделать
[01:04:58.760 --> 01:05:01.760]  на самом деле достаточно хранить
[01:05:01.760 --> 01:05:04.760]  храним
[01:05:04.760 --> 01:05:07.760]  число
[01:05:07.760 --> 01:05:10.760]  элементов
[01:05:10.760 --> 01:05:13.760]  в поддереве
[01:05:16.760 --> 01:05:19.760]  ну круто храним
[01:05:19.760 --> 01:05:22.760]  и что теперь
[01:05:22.760 --> 01:05:25.760]  допустим уничтожим катую порядковую
[01:05:25.760 --> 01:05:28.760]  у него есть левый ребенок
[01:05:28.760 --> 01:05:31.760]  есть правый
[01:05:31.760 --> 01:05:34.760]  назовем эту пункцию cnt от x
[01:05:34.760 --> 01:05:37.760]  ну cnt по узлу будет возвращать
[01:05:37.760 --> 01:05:40.760]  на сколько у него элементов по дереве
[01:05:40.760 --> 01:05:43.760]  вот мы просто спрашиваем
[01:05:43.760 --> 01:05:46.760]  чувачок
[01:05:46.760 --> 01:05:49.760]  cnt от x
[01:05:49.760 --> 01:05:52.760]  точка l больше k
[01:05:52.760 --> 01:05:55.760]  если выясняется, что да
[01:05:55.760 --> 01:05:58.760]  то есть в левом ребенке элементов больше, чем k
[01:05:58.760 --> 01:06:01.760]  то значит нам нужно идти в левое поддерево
[01:06:01.760 --> 01:06:04.760]  потому что справа все элементы больше
[01:06:04.760 --> 01:06:07.760]  а здесь меньше
[01:06:07.760 --> 01:06:10.760]  да
[01:06:10.760 --> 01:06:13.760]  идем влево
[01:06:13.760 --> 01:06:16.760]  дальше спрашиваем вопрос
[01:06:16.760 --> 01:06:19.760]  cnt от x совпадает с k
[01:06:19.760 --> 01:06:22.760]  если да
[01:06:22.760 --> 01:06:25.760]  то
[01:06:25.760 --> 01:06:28.760]  вернем x
[01:06:28.760 --> 01:06:31.760]  ну и последний вопрос
[01:06:31.760 --> 01:06:34.760]  мы его даже не задаем
[01:06:34.760 --> 01:06:37.760]  если мы до него дошли
[01:06:37.760 --> 01:06:40.760]  то вызываем
[01:06:40.760 --> 01:06:43.760]  от
[01:06:43.760 --> 01:06:46.760]  x.l поиск
[01:06:46.760 --> 01:06:49.760]  от правого зала мы запускаем
[01:06:49.760 --> 01:06:52.760]  k-x.l-1
[01:06:52.760 --> 01:06:55.760]  статистику
[01:06:55.760 --> 01:06:58.760]  как на это можно смотреть
[01:06:58.760 --> 01:07:01.760]  на самом деле
[01:07:01.760 --> 01:07:04.760]  давайте я нарисую
[01:07:04.760 --> 01:07:07.760]  где-нибудь здесь дерево
[01:07:07.760 --> 01:07:10.760]  что-то страшное
[01:07:10.760 --> 01:07:13.760]  а где именно
[01:07:13.760 --> 01:07:16.760]  я задаю вопрос
[01:07:16.760 --> 01:07:19.760]  я ответ не слышу
[01:07:19.760 --> 01:07:22.760]  спрашиваю если да, то иду в левое поддерево
[01:07:22.760 --> 01:07:25.760]  мы хотим найти катую порядковую
[01:07:25.760 --> 01:07:28.760]  статистику
[01:07:28.760 --> 01:07:31.760]  в дереве поиска
[01:07:31.760 --> 01:07:34.760]  вам нужно построить структуру данных
[01:07:34.760 --> 01:07:37.760]  и найти катую порядковую
[01:07:37.760 --> 01:07:40.760]  вот такая вот задача
[01:07:40.760 --> 01:07:43.760]  она у вас будет в контесте следующем
[01:07:43.760 --> 01:07:46.760]  она будет с наворотами
[01:07:46.760 --> 01:07:49.760]  там будет еще побольше запросов
[01:07:49.760 --> 01:07:52.760]  вернем x
[01:07:52.760 --> 01:07:55.760]  статистика найдена
[01:07:55.760 --> 01:07:58.760]  иначе мы вызываемся от правого ребенка
[01:07:58.760 --> 01:08:01.760]  только ищем уже не катую порядковую в нем
[01:08:01.760 --> 01:08:04.760]  а катую размера левого поддерева
[01:08:04.760 --> 01:08:07.760]  минус 1
[01:08:07.760 --> 01:08:10.760]  как на это можно смотреть
[01:08:10.760 --> 01:08:13.760]  допустим у вас есть массив
[01:08:13.760 --> 01:08:16.760]  я буду очень оригинален
[01:08:16.760 --> 01:08:19.760]  пускай будет 10 элементов
[01:08:19.760 --> 01:08:22.760]  я построю на нем какой-нибудь дерево поиска
[01:08:22.760 --> 01:08:25.760]  вообще какое-то произвольное
[01:08:25.760 --> 01:08:28.760]  потому что строить AVL это думать надо
[01:08:28.760 --> 01:08:31.760]  тройку пихну
[01:08:31.760 --> 01:08:34.760]  сюда двойку, сюда единичку
[01:08:34.760 --> 01:08:37.760]  четырку, пятерку
[01:08:37.760 --> 01:08:40.760]  сюда еще шестерку
[01:08:40.760 --> 01:08:43.760]  такое дерево прекрасное
[01:08:43.760 --> 01:08:46.760]  очевидно оно не AVL
[01:08:46.760 --> 01:08:49.760]  например из этого узла
[01:08:49.760 --> 01:08:52.760]  а еще здесь из этого узла
[01:08:52.760 --> 01:08:55.760]  а я еще десятку никуда не всунул
[01:08:55.760 --> 01:08:58.760]  вот теперь вроде все
[01:08:58.760 --> 01:09:01.760]  что делал Quick Select
[01:09:01.760 --> 01:09:04.760]  он вам искал pivot
[01:09:04.760 --> 01:09:07.760]  и дальше делали partition
[01:09:07.760 --> 01:09:10.760]  разделяли элементы на меньшее
[01:09:10.760 --> 01:09:13.760]  меньшее влево, большее вправо
[01:09:13.760 --> 01:09:16.760]  допустим мы в качестве пивота выбрали семерку
[01:09:16.760 --> 01:09:19.760]  тогда все меньше элементы влево
[01:09:19.760 --> 01:09:22.760]  все большее вправо
[01:09:22.760 --> 01:09:25.760]  дерево поиска является некоторым деревом
[01:09:25.760 --> 01:09:28.760]  Quick Select
[01:09:28.760 --> 01:09:31.760]  дерево Quick Select
[01:09:31.760 --> 01:09:34.760]  является построением одной из веток дерева поиска
[01:09:37.760 --> 01:09:40.760]  такая глубокая идея
[01:09:40.760 --> 01:09:43.760]  вы взяли семерку, то есть выбрали pivot в качестве корня
[01:09:43.760 --> 01:09:46.760]  и зафиксировали его в качестве корня
[01:09:46.760 --> 01:09:49.760]  все что меньше отправили влево, все что больше отправили вправо
[01:09:49.760 --> 01:09:52.760]  и вызвались рекурсивно от одной из половин
[01:09:52.760 --> 01:09:55.760]  Quick Sort что делает?
[01:09:55.760 --> 01:09:58.760]  только он вызвался рекурсивно от обеих половин
[01:09:58.760 --> 01:10:01.760]  дальше он выбрал pivot
[01:10:01.760 --> 01:10:04.760]  этот и этот элементов в соответствующих подмассивах
[01:10:04.760 --> 01:10:07.760]  допустился рекурсивно от их детей
[01:10:07.760 --> 01:10:10.760]  то есть по сути перед вами
[01:10:10.760 --> 01:10:13.760]  портировочное дерево в некотором плане
[01:10:13.760 --> 01:10:16.760]  на них на дереве поиска еще может смотреть вот так
[01:10:16.760 --> 01:10:19.760]  а дальше Quick Sort
[01:10:19.760 --> 01:10:22.760]  просто вводит и нордер обход
[01:10:22.760 --> 01:10:25.760]  это все, что он делает
[01:10:25.760 --> 01:10:28.760]  поэтому это не какой-то гениальный алгоритм
[01:10:28.760 --> 01:10:31.760]  который типа вау, как до этого можно было дойти
[01:10:31.760 --> 01:10:34.760]  я так думаю, что дошли с помощью этой штуки
[01:10:34.760 --> 01:10:37.760]  возможно я неправ и обижаю автора
[01:10:42.760 --> 01:10:45.760]  то есть у вас поиск катой порядковой
[01:10:45.760 --> 01:10:48.760]  это спуск по дереву
[01:10:48.760 --> 01:10:51.760]  если у вас AVL дерево стало логарифмическое
[01:10:51.760 --> 01:10:54.760]  еще вы на семинаре будете обсуждать запросы
[01:10:54.760 --> 01:10:57.760]  по типу, наименьший элемент больше x
[01:10:57.760 --> 01:11:00.760]  x подается в запросе
[01:11:00.760 --> 01:11:03.760]  или наибольший элемент меньше x
[01:11:03.760 --> 01:11:06.760]  но это все будет уже на семинаре
[01:11:06.760 --> 01:11:09.760]  у вас будет одна большая задача написать дерево поиска
[01:11:09.760 --> 01:11:12.760]  который умеет все это делать
[01:11:15.760 --> 01:11:18.760]  ну еще пару слов скажу
[01:11:18.760 --> 01:11:21.760]  о сетей мапе
[01:11:21.760 --> 01:11:24.760]  сет и мап внутри содержит дерево поиска
[01:11:24.760 --> 01:11:27.760]  на самом деле
[01:11:27.760 --> 01:11:30.760]  единственный нюанс, там не AVL дерево, а красно-черное дерево
[01:11:30.760 --> 01:11:33.760]  красно-черное дерево оно прекрасно
[01:11:33.760 --> 01:11:36.760]  во-первых
[01:11:36.760 --> 01:11:39.760]  это в смысле все случаи
[01:11:39.760 --> 01:11:42.760]  когда оно прекрасно
[01:11:42.760 --> 01:11:45.760]  тем, что у нас было 4 вида поворотов
[01:11:45.760 --> 01:11:48.760]  в красном дереве при удалении
[01:11:48.760 --> 01:11:51.760]  7 разных видов ситуации может возникнуть
[01:11:51.760 --> 01:11:54.760]  и там как бы авторов надо уважать
[01:11:54.760 --> 01:11:57.760]  за то, что все это разобрали
[01:11:57.760 --> 01:12:00.760]  я не думаю, что мы будем в курсе разбирать
[01:12:00.760 --> 01:12:03.760]  красно-черное дерево если честно
[01:12:03.760 --> 01:12:06.760]  потому что я устану 7 случаев удаления
[01:12:06.760 --> 01:12:09.760]  слушать на экзамене
[01:12:09.760 --> 01:12:12.760]  потому что в среднем делается меньше
[01:12:12.760 --> 01:12:15.760]  переносов указателей в нем
[01:12:15.760 --> 01:12:18.760]  ну типа проверить if это легко
[01:12:18.760 --> 01:12:21.760]  поменять указатели местами это сложно
[01:12:21.760 --> 01:12:24.760]  потому что это надо лезть в оперативную память
[01:12:24.760 --> 01:12:27.760]  это долго, но это физически уже причина
[01:12:27.760 --> 01:12:30.760]  алгоритмически там тоже будет луген
[01:12:30.760 --> 01:12:33.760]  так, ну все, тело мы на сегодня на сегодня закончили
