[00:00.000 --> 00:22.200]  Продолжаем про потоки говорить. Вот, и первое, первое оно такая, даже не то, что алгоритм,
[00:22.200 --> 00:27.360]  скорее техника, ускорение времени работы. Это так называемая техника масштабирования.
[00:27.360 --> 00:46.680]  Вот, идея такая. Давайте мы будем пытаться пускать поток какими-то большими порциями. Ну,
[00:46.680 --> 00:52.360]  и эти порции будут у нас степенями двойки, и мы будем идти по ним сверху вниз. То есть,
[00:52.360 --> 00:56.640]  сначала будем пытаться пустить поток какой-нибудь величины, не знаю, там 128,
[00:56.640 --> 01:01.040]  потом все такие потоки пустили, какие могли, потом уменьшаем наши требования,
[01:01.040 --> 01:06.480]  пытаемся искать поток величины 64. Ну и так далее, по всем степням двойки до 1, понятно,
[01:06.480 --> 01:11.440]  что в конце, когда будем пытаться пускать поток длины 1, то у нас найдется, собственно,
[01:11.440 --> 01:19.240]  максимальный поток воссташной сети. Ну, формально напишем примерно следующее. Пусть
[01:19.240 --> 01:30.280]  какой-нибудь с большой, это верхнее ограничение на все capacity, верхнее ограничение на все пропускные
[01:30.280 --> 01:49.800]  способности. Дальше. Для каждого АК в цикле от 26 логарифма С до 0, так, я думаю, куда округлить,
[01:49.800 --> 01:57.800]  видимо к низу, потому что вверх это будет нулевая сеть. От 26 логарифма С до 0 мы делаем следующее.
[01:57.800 --> 02:05.400]  Мы сначала переопределяем наши все capacity так, чтобы они были кратны 2 в степенька. То есть мы
[02:05.400 --> 02:12.160]  уменьшаем все capacity до наибольшего числа, делящегося на 2 в степенька. Формально напишу так.
[02:12.160 --> 02:25.880]  С-штрих от ребра Е это следующее. Остаточное capacity этого ребра, деленное на 2 вкатой и умноженное на 2 вкатой.
[02:25.880 --> 02:34.160]  То есть СФ это сколько, какая остаточная capacity, сколько можно еще по нему протолкнуть. Дальше
[02:34.160 --> 02:38.400]  деленное на 2 вкатой, берем целую часть вниз и умножаем на 2 вкатой. Это как раз в точности есть
[02:38.400 --> 02:47.480]  наибольшее число, меньше либо равное вот этому, кратное 2 в степенька. То есть мы там что-то
[02:47.480 --> 02:52.680]  отрезали и оставили только делящиеся на 2 в степенька. Ну и соответственно в графе с такими
[02:52.680 --> 02:59.000]  capacity мы пускаем максимальный поток. Соответственно если у меня все ребра сейчас имеют capacity кратные
[02:59.000 --> 03:04.240]  до 2 вкатой, то и поток будет делиться на 2 в степенька в этой сети. Находим максимальный поток,
[03:04.240 --> 03:10.560]  потом переходим к следующему капросту. То есть вот в этой сети найти max поток. Найти max поток.
[03:10.560 --> 03:18.520]  Ну и в конце все это просуммировать. То есть вот мы там много сетей строили, каждый раз меняются как-то
[03:18.520 --> 03:23.040]  остаточные capacity, потому что я прибру какую-то часть потока пускаю и все эти потоки потом
[03:23.040 --> 03:41.200]  суммирует и будет ответ. Ответ это сумма потоков по всем к. Вот такая идея. Корректность здесь
[03:41.200 --> 03:45.320]  очевидна, потому что, ну то есть сначала мы делаем что-то странное. Мы как-то уменьшаем
[03:45.320 --> 03:50.320]  наше capacity, там по степням 2 идем 2 вкатой, 2 вк-1 и так далее и так далее. Но главное,
[03:50.320 --> 03:55.000]  что на последней итерации, когда k будет равно нулю, у меня c штрих будет просто совпадать с
[03:55.000 --> 03:59.360]  c остаточным. Потому что если k равно нулю, то вот эта единичка и мы соответственно делим,
[03:59.360 --> 04:04.680]  умножаем на единицу, ничего не меняется. Поэтому на последней итерации я ищу поток просто в
[04:04.680 --> 04:09.480]  остаточной сети. Без всяких ограничений, что он должен делиться на степень 2, потому что степень
[04:09.480 --> 04:16.120]  2 будет равна единице. Корректность следует просто опять из теоремы Форда Фалкерсона,
[04:16.120 --> 04:21.080]  что мы в конце все равно рассматриваем остаточную сеть, и пока в ней есть путь из s в t,
[04:21.080 --> 04:28.440]  мы проталкиваем поток. А время работы оказывается здесь будет такое. Время работы
[04:28.440 --> 04:42.280]  можно оценить как e2 на лог c. Лог c это мы видим количество итераций, количество разных k,
[04:42.280 --> 04:47.680]  и вот оказывается, что каждая итерация работает максимум за e2. Причем тут неважно,
[04:47.680 --> 04:53.480]  какой алгоритм. Вот внутри каждой итерации, вот здесь, когда мы ищем max поток, внутри каждой
[04:53.480 --> 04:58.120]  итерации пока, тут неважно, какой именно мы используем алгоритм, Форт Фалкерсона или Эдман
[04:58.120 --> 05:02.840]  Скарпа. Здесь можно как Форт Фалкерсона написать, так и Эдман Скарпа. Это неважно,
[05:02.840 --> 05:16.880]  симплотика будет все равно e2 лог c. Давайте это поймем. Почему время работы каждой итерации
[05:16.880 --> 05:41.400]  это от e2. Для этого покажем следующее. Пусть f большое, это поток в исходной сети, настоящий
[05:41.600 --> 05:54.680]  max поток. Давайте так напишем настоящий максимальный поток. А fкат это то, что мы нашли после ката
[05:54.680 --> 06:02.600]  итерации. То, что мы нашли после ката итерации, то есть сумма потоков, которые мы упустили на
[06:02.600 --> 06:21.840]  итерациях с номерами 0, 1 и так далее к. Суммарный поток на итерациях 0, 1 и так далее к. Так вот
[06:21.840 --> 06:35.240]  тогда f настоящее не больше, чем f уже найденное, плюс 2 вкатой на e, где e это число ребер. То есть
[06:35.240 --> 06:40.960]  вот мы делаем такое наше масштабирование, идем по степеням дворки от больших к меньшим и пусть
[06:40.960 --> 06:46.760]  там после первых ка итерации мы нашли поток вылеченной fкат. Так вот тогда настоящий поток
[06:46.760 --> 06:55.880]  отличается от вот этого вот найденного не больше, чем на 2 вкатой умножить на e. Почему это так? Ну
[06:55.880 --> 07:03.320]  смотрите, давайте мы нарисуем остаточную сеть после вот этой ката итерации. Остаточная сеть
[07:03.320 --> 07:14.120]  после ката итерации. Поскольку мы уже нашли максимальный поток на этой ката итерации,
[07:14.120 --> 07:20.360]  то значит в остаточной сети у меня нет пути из s в t. Значит можно нарисовать как-то вот так
[07:20.360 --> 07:27.320]  нашу остаточную сеть. Есть s маленькая, t маленькая, вот они. И между ними нет пути в этой
[07:27.320 --> 07:33.840]  самоостаточной сети. Но что значит нет пути? Это значит, что все вот эти вот ребра имеют
[07:33.840 --> 07:40.880]  остаточную capacity в терминах эссотного графа меньше, чем 2 вкатой. Потому что если бы здесь
[07:40.880 --> 07:45.320]  была остаточная capacity хотя бы 2 вкатой, то значит это ребро имело бы, ну собственно, если бы тут
[07:45.320 --> 07:50.000]  было хотя бы 2 вкатой, то значит и в этом графе у меня было бы это ребро с capacity 2 вкатой, соответственно
[07:50.000 --> 07:57.160]  я мог бы, ну то есть это не все ребра здесь насыщенные. Мы знаем, что есть разрез, который пересекает
[07:57.160 --> 08:03.880]  в общем только насыщенные ребра. Чтобы в общем поток был равен разрезу, мне нужно чтобы все эти
[08:03.880 --> 08:11.280]  ребра были насыщенные. Ну вот, значит по этому ребру, на этом ребре остаточная capacity может быть
[08:11.280 --> 08:19.480]  только меньше, чем 2 в степеника. Подпишем, что остаточная capacity меньше, чем 2 в степеника,
[08:19.480 --> 08:40.000]  иначе ребро не насыщено. Вот, ну и все, а суммарно здесь ребер их максимум е, поэтому остаточная capacity у
[08:40.000 --> 08:50.180]  них у всех максимум 2 вкатый умножить на е, значит, так сейчас, момент. Ну да, а собственно, то есть мы
[08:50.180 --> 09:01.120]  нашли разрез величины не больше, чем 2 вкатый умножить на е. Значит есть разрез величины не
[09:01.120 --> 09:10.960]  больше, чем 2 вкатый умножить на е. А мы знаем, что величина любого разреза это оценка сверху на
[09:10.960 --> 09:17.040]  величину максимального потока. Поэтому то, сколько мне осталось протолкнуть потока для того, чтобы
[09:17.040 --> 09:21.440]  найти максимальные из СВТ не больше, чем величина вот этого разреза, то есть не больше, чем вот столько.
[09:21.440 --> 09:26.600]  Значит для того, чтобы найти истинное значение потока, к тому, что я уже нашел, нужно добавить не
[09:26.600 --> 09:41.680]  больше, чем вот это. Ну все. Значит, остаточный поток меньше, чем 2 вкатый умножить на е. А это ровно то,
[09:41.680 --> 09:57.280]  что написано в том утверждении. Окей? Так, ну отсюда следует сразу, что на каждой итерации, так,
[09:57.280 --> 10:12.480]  сейчас скажу. В общем, что каждая итерация находит нам от е-путей. То есть пусть мы вот это, скажем,
[10:12.480 --> 10:27.600]  знаем для нашего ака, рассмотрим каплю с первой итерации. Каплю с первой итерации. Ну там, что такое
[10:27.600 --> 10:33.920]  работа внутри итерации? Это вот мы построили остаточную сеть с капастями кратными 2 в степени,
[10:33.920 --> 10:40.680]  сейчас, 2 в степени log2c-k-1, ну что-то такое. То есть очередной степени двойки мы должны
[10:40.680 --> 10:55.040]  быть кратны. Так, момент. У меня здесь, понял, я, нет. А вот здесь давайте исправлю. У меня итерации,
[10:55.040 --> 11:01.280]  они как бы сверху вниз номируются, поэтому здесь итерации скорее от логарифма до к, вот так. И
[11:01.280 --> 11:09.480]  соответственно, там тогда к-1 итерация, простите, к-1 итерация. Да, ну как бы я уменьшаю, поэтому если
[11:09.480 --> 11:18.400]  там было k, то теперь к-1. В конце будет нулевая. Итак, я рассматриваю к-1 итерацию, то есть строю
[11:18.400 --> 11:29.280]  сеть, в которой все капасити кратные 2 в степень k-1. Все капасити кратные 2 в степень k-1. Внутри
[11:29.280 --> 11:34.680]  этой итерации происходит следующее. Скажем, алгоритм Форда Фалкерсона просто находит несколько
[11:34.680 --> 11:39.480]  путей из СФТ. Каждый из них тоже, понятное дело, имеет хотя бы вот такую пропускную способность,
[11:39.480 --> 11:44.400]  поэтому каждый путь, который мы нашли, мы по нему пускаем ну хотя бы столько потока.
[11:44.400 --> 12:07.440]  Каждый найденный путь увеличивает поток хотя бы на 2 в степень k-1. Потому что раз все капасити
[12:07.440 --> 12:12.680]  делятся на это, то значит любой путь проходит по ребрам не нулевого веса, поэтому у них все хотя
[12:12.680 --> 12:17.360]  бы столько, значит и поток тоже хотя бы столько. Ну и тогда смотрите, а вот тут у меня написано,
[12:17.360 --> 12:24.360]  что если вдруг я нашел на предыдущей итерации, какой был поток, то настоящий поток отличается от
[12:24.360 --> 12:28.680]  него не больше, чем настолько. Но мы видим, что каждый путь, который мы находим на следующей
[12:28.680 --> 12:34.000]  итерации, он хотя бы 2 в степень k-1. Значит, суммарно, вот этих штук я могу сделать максимум 2e.
[12:34.000 --> 12:41.040]  Потому что если осталось мне 2 вкаты на e, и каждый путь это хотя бы 2 в k-1, то значит суммарно,
[12:41.040 --> 12:57.720]  ну сколько сюда помещается 1-2 в k-1, ну ровно 2e. Значит, путей найдем не больше, чем 2e. Понятно,
[12:57.720 --> 13:05.960]  откуда взялось? Хорошо, вот, значит каждая итерация находит максимум 2e путей. Ну а что
[13:05.960 --> 13:11.280]  такое итерация? Это поиск увеличивающего пути, пока он есть. Если мы видим, что путей максимум 2e,
[13:11.280 --> 13:16.240]  то тогда каждая итерация – это просто максимум 2e раз найти какой-то увеличивший путь из s в t,
[13:16.240 --> 13:22.120]  что работает за линейное время. Что форт Фалкерсон – это просто dfs, что Эдман Скарп – это просто bfs.
[13:22.120 --> 13:27.200]  Ну а поэтому вот это вот нужно умножить на время работы dfs или bfs, будет как раз e квадрат,
[13:27.200 --> 13:33.640]  ну и мы получили время работы одной итерации e квадрат. Все, все доказали. Так, ну давайте
[13:33.640 --> 13:48.240]  напишем, что время работы итерации есть от e, вот оно, сколько путей мы можем найти,
[13:48.240 --> 14:00.760]  умножить на время работы dfs или bfs, что есть e квадрат, ну потому что здесь это как бы e
[14:00.760 --> 14:05.360]  плюс v, суммарный вершин плюс ребер, здесь тоже суммарный вершин плюс ребер у нас была оценка,
[14:05.360 --> 14:13.600]  но повторюсь, из этих двух слагаемых e зачастую больше, потому что иначе можно было в исходной
[14:13.600 --> 14:18.400]  сети, представьте, что у нас там e сильно меньше, чем v, тогда давайте просто в исходной сети оставим
[14:18.400 --> 14:23.240]  только вершины, достижимые из s, тогда у нас e и v сравняются, ну там с точностью 2 плюс минус 1,
[14:23.240 --> 14:31.760]  и они будут одного порядка, поэтому можно будет всюду вместо v писать e. Ну все,
[14:31.760 --> 14:37.600]  значит каждый тратится за квадрат, суммарный алгорифм, поэтому время работает такое. Ну и понятно,
[14:37.600 --> 14:43.280]  что это может быть выгодно нам, например, если log c меньше, чем v, да, потому что у нас была
[14:43.280 --> 14:49.040]  оценка на Эдман Скарпа вот такая, давайте я здесь восстановлю, Эдман Скарп работал за e квадрат v,
[14:49.120 --> 14:55.520]  и соответственно, если мы вдруг знаем, что log c сильно меньше, чем v, то вот вам,
[14:55.520 --> 14:59.280]  пожалуйста, алгоритм, который теоретически чуть быстрее работает, чем Эдман Скарп.
[14:59.280 --> 15:06.840]  Окей, хорошо.
[15:06.840 --> 15:30.200]  Так, теперь еще один алгоритм поиска максимального потока, это алгоритм Деница.
[15:36.840 --> 15:46.120]  Пожалуйста, не говорите, что это алгоритм Деницы или что автора фамилия Деница. Автор вот такой,
[15:46.120 --> 15:55.040]  чувак, поэтому, пожалуйста, говорите родительный падеж правильно, а то меня немножко бесит,
[15:55.040 --> 16:02.680]  когда говорят Деницы или что-нибудь такое, вот, не надо так. Ну нам тут будут нужны опять
[16:02.680 --> 16:15.640]  несколько определений. Определение. Сначала определим слоистую сеть. Слоистая сеть сети g,
[16:15.640 --> 16:23.640]  это вот что такое. Ну, сеть, напоминаю, это у нас обычный граф с капаситами, где выделен две
[16:23.640 --> 16:32.120]  вершинки s и t. Вот, давайте мы посчитаем кратчайшее расстояние от s до всех вершин и оставим
[16:32.120 --> 16:38.680]  только ребра между слоями, то есть ребра между вершинками на расстоянии i и на расстоянии i
[16:38.680 --> 16:44.640]  плюс 1. Давайте я нарисую картинку сначала. Значит, вот есть s, вершины на расстоянии 0,
[16:44.640 --> 16:50.920]  затем есть какие-то вершины на расстоянии 1, я оставляю в них во все ребра. Есть вершины на
[16:50.920 --> 16:58.120]  расстоянии 2, я оставляю ребра только между, ну, точнее, из первого слоя во второй, все обратно
[16:58.120 --> 17:02.240]  удаляю. Есть вершины на расстоянии 3, опять оставляю только ребра из второго в третий,
[17:02.240 --> 17:10.120]  ну и так далее. Где-то здесь там будет t, я оставляю ребра из предыдущего слоя в него. Ну,
[17:10.120 --> 17:17.520]  формально тоже это давайте запишем. Значит, пусть v и это множество вершин на расстоянии ровно i от
[17:17.520 --> 17:25.920]  s. Да, да, ребра неизвешенные, расстояние меряем, как будто они все имеют v с 1, ну, неизвешенные,
[17:25.920 --> 17:31.240]  да. Собственно, так же, как у нас в Эдманскарпе, мы ищем короче расстояние по числу ребер просто,
[17:31.240 --> 17:38.000]  невзвешенные расстояния. Итак, значит, v и это множество таких вершин v, что расстояние от
[17:38.000 --> 17:45.040]  s до v равно i. Да, расстояние невзвешенное. Ну и, соответственно, ребра оставляем только из
[17:45.040 --> 18:01.640]  этого v плюс 1 для каждого i. Оставляем ребра из v и v плюс 1 для каждого i. Ну, вот с теми
[18:01.640 --> 18:29.000]  же капастями, которые были исходно в графе. Второе определение – это блокирующий поток.
[18:31.640 --> 18:44.520]  Блокирующий поток в сети – это такой поток, который нельзя увеличить без введения обратных
[18:44.520 --> 18:51.600]  ребер. Сейчас нарисую картинку.
[19:14.880 --> 19:22.180]  Но мы знаем, что если как бы мы вводим обратные ребра, то любой поток можно расширить до максимального,
[19:22.180 --> 19:25.380]  потому что появляются вот эти обратные ребра, с помощью которых можно отменять неправильно
[19:25.380 --> 19:30.240]  потекший поток. И, собственно, любой поток можно увеличить до максимального, просто отменив то,
[19:30.240 --> 19:34.420]  что мы сделали неправильно. А если мы не вводим вот эти обратные ребра, например,
[19:34.420 --> 19:40.100]  например, картиночка наша любимая. Представьте, что
[19:40.100 --> 19:42.820]  мы пустили вот такую неправильную днику потока, как мы это
[19:42.820 --> 19:46.180]  часто можем делать. Этот поток блокирующий, потому
[19:46.180 --> 19:48.980]  что чтобы его увеличить, мне необходимо вот эту
[19:48.980 --> 19:51.780]  днику отменить. Если ее не отменять, то здесь нет
[19:51.780 --> 19:55.100]  больше никакого пути из СВТ. Не вводя обратное ребро,
[19:55.100 --> 19:59.220]  я не смогу найти больше никакой пути из СВТ. Ну,
[19:59.220 --> 20:02.380]  собственно, это пример блокирующего потока. Если
[20:02.380 --> 20:05.100]  мы не переходим к остаточной сети, а все еще живем в
[20:05.100 --> 20:07.580]  этом исходном графе без обратного ребра, тогда вот
[20:07.580 --> 20:09.940]  здесь вот как бы нет пути из СВТ, но только в исходном
[20:09.940 --> 20:11.820]  графе, не в остаточной сети, а в исходном графе.
[20:11.820 --> 20:22.420]  Вот, и тогда алгоритм Динец описывается очень просто.
[20:22.420 --> 20:25.980]  Мы будем строить слоистую сеть по остаточной сети
[20:25.980 --> 20:28.420]  и в ней находить блокирующий поток. И так столько раз,
[20:28.420 --> 20:36.980]  пока, собственно, есть хотя бы один путь из СВТ.
[20:36.980 --> 20:45.260]  Алгоритм Динец. Ну, пока не найден поток. Пока не найден
[20:45.260 --> 20:52.700]  поток. Мы строим слоистую сеть и находим в ней блокирующий
[20:52.700 --> 21:12.900]  поток. Находим в ней блокирующий поток. Все. Ну, и суммарно,
[21:12.900 --> 21:15.700]  сколько потока мы протолкнули, это и есть ответ на задачу.
[21:15.700 --> 21:27.380]  Вот, асимптотика будет лучше, чем в Эдманскарпе. У нас
[21:27.380 --> 21:29.660]  будет сейчас В квадрат Е. Это мы сейчас будем доказывать.
[21:29.660 --> 21:39.300]  Получается асимптотика В квадрат Е. То есть, по
[21:39.300 --> 21:42.180]  сравнению с Эдманскарпом, мы квадрат скинули с числа
[21:42.180 --> 21:44.980]  ребер на число вершин, но это, понятное дело, выгодно,
[21:44.980 --> 21:48.140]  потому что зачастую вершин меньше, чем ребер. Мы перенесли
[21:48.140 --> 21:50.620]  квадрат на число поменьше, тем самым, асимптотика
[21:50.620 --> 21:57.180]  лучше. Так, ну хорошо. Чтобы это сделать, давайте, то
[21:57.180 --> 22:00.180]  есть понятно, что алгоритм состоит из нескольких итераций.
[22:00.180 --> 22:03.500]  Каждая итерация — это построение слоистой сети плюс поиск
[22:03.500 --> 22:06.180]  блокирующего потока в этой самой слоистой сети. Давайте
[22:06.180 --> 22:09.900]  тут я имею в виду, что сеть строится по остаточной
[22:10.260 --> 22:17.140]  сети, по остаточной сети. То есть да, вот здесь,
[22:17.140 --> 22:19.820]  когда еще блокируюший поток, я забываю вообще, что бывают
[22:19.820 --> 22:22.780]  обратные ребра, мне просто дали граф, я не ввожу обратные
[22:22.780 --> 22:25.500]  ребра, просто пускаю, блокирующий поток пока могу. Но, когда
[22:25.500 --> 22:28.020]  мы строим слоистую сеть и, соответственно, переходим
[22:28.020 --> 22:30.460]  между итерациями, мы не забываем, что мы решаем нормальную
[22:30.460 --> 22:33.180]  задачу — у нас бывают обратные ребра, и они, соответственно,
[22:33.180 --> 22:35.220]  нам нужны, чтобы сначала построить остаточную сеть,
[22:35.220 --> 22:37.940]  по ней слоистую, и уже в ней шкальблокирующие. И
[22:37.940 --> 22:44.900]  раз. Опять несколько итераций, столько раз, сколько встроим
[22:44.900 --> 22:47.420]  слоистую сеть. Ну и вот давайте теперь разберемся, как
[22:47.420 --> 22:49.540]  работать внутри одной итерации, как искать блокирующий
[22:49.540 --> 22:55.540]  поток для данной сети. Поиск блокирующего потока
[22:55.540 --> 23:13.540]  за VE. Блокируешь поток за VE. Так, сейчас будет алгоритм
[23:13.540 --> 23:16.340]  во многом похожий на то, что мы делали с эйлеровыми
[23:16.340 --> 23:22.780]  циклами. Идея такая, смотрите, вот есть какая-то вершина,
[23:22.780 --> 23:25.820]  и я пытаюсь как бы протолкнуть из нее какой-то поток. Ну
[23:25.820 --> 23:28.300]  не знаю, пусть в нее сколько-то потока пришло, какой-то
[23:28.300 --> 23:33.060]  f. И я хочу этот поток максимально протолкнуть до конца, до
[23:33.060 --> 23:38.420]  t. И соответственно из V есть какие-то ребра. Давайте
[23:38.420 --> 23:43.340]  попробуем просто по первым поважься пройти и это f протолкнуть.
[23:43.340 --> 23:46.180]  Какие бывают случаи? Бывают случаи, что это ребро, скажем,
[23:46.180 --> 23:49.100]  плохое. Плохое в том смысле, что оно не лежит в слоистой
[23:49.100 --> 23:52.700]  сети. То есть, я как бы мой граф не буду явно перестраивать,
[23:52.700 --> 23:56.500]  не заводить новый инстанс графа, я буду по-прежнему
[23:56.500 --> 23:59.180]  хранить всевозможные ребра, но только буду проверять,
[23:59.180 --> 24:01.580]  а лежит это ребро в слоистой сети или нет. Это легко
[24:01.580 --> 24:06.260]  проверить, нужно просто проверить, что эта вершина
[24:06.260 --> 24:08.780]  лежит в слое с номером на 1 меньше чем это. То есть,
[24:08.780 --> 24:11.940]  я ребра явно удалять не буду, чтобы построить слоистую
[24:11.940 --> 24:14.940]  сеть. Я не буду явно удалять ребра, я буду просто, чтобы
[24:14.940 --> 24:17.540]  проверить есть ребро или нет, проверять, что вот
[24:17.540 --> 24:21.700]  эти вот вершины находятся на соседних уровнях. Итак,
[24:21.700 --> 24:24.500]  я пытаюсь протокнуть F-потока, смотрю на ребро, если вижу,
[24:24.500 --> 24:26.980]  что оно, скажем, не в слоистой сети, то я его просто игнорирую
[24:26.980 --> 24:30.220]  и теперь буду рассматривать вот это. Дальше, пытаюсь
[24:30.220 --> 24:33.020]  по нему протокнуть, а оно пусть в слоистой сети. Пытаюсь
[24:33.020 --> 24:37.100]  протокнуть F-потока и как-нибудь рекурсивно пытаюсь найти
[24:37.100 --> 24:41.220]  путь отсюда до T. И пусть у меня не получилось, пусть,
[24:41.220 --> 24:44.540]  например, вообще из этой вершины, то и недостижимо.
[24:44.540 --> 24:46.940]  Тогда понятно, что это ребро можно в каком-то смысле
[24:46.940 --> 24:50.820]  удалить, то есть, можно игнорировать. Если мы не смогли найти
[24:50.860 --> 24:55.220]  путь отсюда до T, то дальше никогда не сможем, если мы
[24:55.220 --> 24:57.740]  ищем блокирующий поток. Поэтому это ребро можно как-бы
[24:57.740 --> 25:00.500]  удалить и дальше рассматривать только вот это ребро.
[25:02.020 --> 25:04.020]  Ну и, соответственно, аналогия здесь такая, мы для каждой
[25:04.020 --> 25:08.220]  вершины просто храним поинтер какой-то, PTR от V, это номер
[25:08.340 --> 25:10.580]  первого ребра, которое интересно рассматривать.
[25:10.980 --> 25:13.620]  Соответственно, мы скипаем те ребра, которые не лежат
[25:13.620 --> 25:17.140]  в слоистой сети или из конца которых недостижимо T, мы
[25:17.140 --> 25:20.260]  их просто пропускаем, тем самым увеличивая PTR.
[25:20.620 --> 25:23.100]  Ну и вот, соответственно, если отсюда мы нашли путь
[25:23.100 --> 25:25.820]  до T, то значит, окей, там сколько потоку мы протолкнули,
[25:26.020 --> 25:26.940]  PTR оставили здесь.
[25:31.060 --> 25:39.220]  Ну все, давайте запишем, что PTR от V это номер первого
[25:39.860 --> 25:41.500]  интересного ребра, я так напишу.
[25:44.780 --> 25:46.780]  Интересного ребра из V.
[25:47.460 --> 25:50.980]  Интересного, то есть, потенциально полезного, что из
[25:50.980 --> 25:54.580]  него может быть, по нему точнее, вот по этому ребру мы
[25:54.580 --> 25:56.140]  сможем потенциально что-то протолкнуть.
[25:56.180 --> 25:59.060]  Если не можем, то сразу PTR увеличиваем, игнорируя это
[25:59.060 --> 25:59.740]  ребро в дальнейшем.
[26:02.020 --> 26:03.660]  Вот, тогда алгоритм будет следующий.
[26:03.660 --> 26:18.900]  Так, ну мне лень придумать какое-нибудь оригинальное
[26:18.900 --> 26:20.740]  название, поэтому я им им зву ДФС.
[26:23.740 --> 26:27.660]  А еще он принимает вершину, и то вот, то самое F, сколько
[26:27.660 --> 26:30.220]  потока я до нее смог довести.
[26:30.660 --> 26:34.620]  Сколько я потока F смог довести от S до текущей вершинки
[26:34.620 --> 26:34.780]  V.
[26:36.740 --> 26:40.540]  Первая проверка, если V равно T, то я просто сделаю
[26:40.540 --> 26:41.180]  return F.
[26:43.380 --> 26:47.260]  Это значит, что я смог найти с помощью моего вот этого
[26:47.260 --> 26:50.020]  какого-то обхода, с помощью какого-то ДФС, смог найти
[26:50.020 --> 26:52.820]  путь из S до T величины F.
[26:53.020 --> 26:57.180]  Ну вот давайте это значение и будет величиной, который
[26:57.180 --> 26:58.220]  я возвращаю из рекурсии.
[26:58.220 --> 26:59.580]  Сколько потока я протолкнул.
[27:00.620 --> 27:02.260]  В моей сети, то есть тут будет F.
[27:03.420 --> 27:05.780]  Вот иначе, это какая-то промежуточная вершина, и я
[27:05.780 --> 27:07.820]  должен это F-поток куда-то передать.
[27:09.740 --> 27:10.900]  Для этого сделаем следующее.
[27:11.740 --> 27:17.820]  Пока PTRV меньше, чем GVTSIZE.
[27:20.860 --> 27:23.620]  Так, ну G от V это как всегда у меня список ребер, торчащих
[27:23.620 --> 27:27.500]  из V, а G от V всегда список ребер, которые из V исходят.
[27:27.900 --> 27:30.180]  PTRV это номер ребра в этом списке.
[27:30.220 --> 27:31.900]  Номер первого интересного ребра в этом списке.
[27:32.300 --> 27:35.060]  Если у меня вдруг PTR сравнялась с размером, значит я все
[27:35.060 --> 27:38.140]  ребра просмотрел, мне все ребра не интересны, поэтому
[27:38.140 --> 27:40.180]  я больше ничего из этой вершинки сделать не могу.
[27:41.580 --> 27:46.060]  Ну хорошо, тогда пусть E это ребро вот с этим вот
[27:46.060 --> 27:48.900]  номером, то самое ребро, которое мне интересно.
[27:50.900 --> 27:56.540]  Так, напишу так, ребро с номером PTR от V.
[27:56.540 --> 27:59.740]  Писки GV.
[28:02.740 --> 28:04.780]  Ну это вот то самое ребро, которое мне сейчас интересно.
[28:06.820 --> 28:11.260]  Если оно не лежит в остаточной сети, ну точнее в слейской
[28:11.260 --> 28:13.980]  сети, или скажем на нем нулевая капасти, то мы его
[28:13.980 --> 28:16.140]  можем просто скипнуть и увеличить PTR на единичку.
[28:17.140 --> 28:26.980]  Я напишу так, если level от V плюс один не равно level
[28:28.380 --> 28:35.300]  от E.tu, да, E.tu это то, куда ведет мое ребро.
[28:35.860 --> 28:39.660]  Давайте его нарисую из V.tu.
[28:40.500 --> 28:41.940]  Ну просто в ту давайте напишем.
[28:41.940 --> 28:50.340]  Если это ребро не из слейской сети, или оно насыщено, то
[28:50.340 --> 28:57.740]  есть по нему ничего уже нельзя передать, или E.capacity
[28:57.740 --> 29:01.060]  равно E.flow.
[29:01.060 --> 29:07.740]  Вот, тогда можно просто сделать плюс плюс PTR V и
[29:07.740 --> 29:08.340]  continue.
[29:14.340 --> 29:17.300]  То есть мы как бы посмотрели на ребро, поняли, что на
[29:17.300 --> 29:20.020]  самом деле тоже неинтересно, ну и скипаем его, просто
[29:20.020 --> 29:21.460]  увеличиваем этот указатель на единичку.
[29:21.460 --> 29:39.180]  Так, теперь содержательный случай, когда это ребро
[29:39.180 --> 29:41.380]  из слейской сети и на нем не нулевая сетчаная
[29:41.380 --> 29:45.380]  капасти, значит можно сколько-то протолкнуть, причем сколько?
[29:46.900 --> 29:48.380]  Ну вот сколько.
[29:51.980 --> 29:58.860]  Минимум из F и E.capacity минус E.flow.
[30:07.580 --> 30:09.860]  Вот, то есть смотрите, у меня есть ребро, я понимаю,
[30:09.860 --> 30:11.740]  что по нему можно протолкнуть максимум вот столько
[30:11.740 --> 30:14.260]  потока, да, это вот та самая остаточная капасти, с
[30:14.260 --> 30:18.180]  штрих, но при этом не больше чем F, да, не больше чем
[30:18.180 --> 30:19.780]  это, не больше чем это, беру из них двух минимум.
[30:20.380 --> 30:21.980]  Соответственно, пытаюсь протолкнуть вдоль этого
[30:21.980 --> 30:25.580]  ребра столько потока, и этот поток, давайте сюда вернусь,
[30:26.380 --> 30:29.780]  этот поток, начиная от 100, пытаюсь докинуть до T.
[30:31.580 --> 30:35.380]  Я просто рекурсивно вызываю DFS 2, запятая вот, вот та
[30:35.380 --> 30:39.580]  штука. И X это то, сколько потока я умудрился протолкнуть,
[30:39.580 --> 30:41.980]  то есть по всему вот этому пути я протолкнул X-поток.
[30:42.580 --> 30:47.380]  Ну, если X равно нулю, то получается я не смог ничего
[30:47.380 --> 30:49.180]  сделать, нужно сделать плюс плюс ПТР от V.
[30:50.780 --> 30:51.480]  И continue.
[30:55.680 --> 30:59.780]  Иначе я нашел какой-то путь, и мне нужно не забыть,
[30:59.780 --> 31:02.980]  что вот на этом ребре E, мне нужно проставить плюс X,
[31:02.980 --> 31:05.080]  да, что я протолкнул X-поток.
[31:05.680 --> 31:16.780]  Ну, я напишу так, E точка flow плюс равно X, а reverse E, reverse E flow
[31:17.780 --> 31:18.780]  минус равно X.
[31:25.880 --> 31:29.980]  То есть я по ребру проталкиваю X, значит по обратному, ну,
[31:29.980 --> 31:32.780]  просто гарантированно должен протолкнуть минус X, reverse E
[31:32.780 --> 31:33.880]  это обратное ребро.
[31:35.280 --> 31:38.880]  Вот, и все, и возвращаю X как знак того, что я смог протолкнуть
[31:38.880 --> 31:42.680]  ровно X-поток. Дальше, если у меня вайл закончился и мы
[31:42.680 --> 31:44.980]  из него вышли, то значит мы ничего не нашли, просто делаем
[31:44.980 --> 31:49.480]  return 0, return 0, конец.
[32:03.380 --> 32:03.880]  Вопросы?
[32:07.980 --> 32:09.980]  Хорошо, тогда последнее замечание, вот здесь скажу,
[32:09.980 --> 32:15.980]  что reverse E можно делать опять так же, как когда мы искали
[32:15.980 --> 32:19.180]  эйлера в цикл, у нас там прямое ребро и обратное всегда
[32:19.180 --> 32:22.980]  имели номера противоположной четности и соседние, и они
[32:22.980 --> 32:26.680]  тогда, если одно имело номер E, то второе имело номер E-41,
[32:26.680 --> 32:29.580]  да, если мы просто каждый раз, когда какое-то ребро
[32:29.580 --> 32:33.980]  добавляется в граф, мы сразу же добавляем ему противоположное,
[32:33.980 --> 32:36.780]  то они всегда имеют, то противоположное всегда имеет
[32:36.780 --> 32:40.080]  соседние номера, отличающиеся четностью последнего бита.
[32:40.080 --> 32:43.580]  Добавили бро и сразу ему обратное, значит они в массиве
[32:43.580 --> 32:47.080]  всех ребер всегда в соседние, и поэтому можно очень
[32:47.080 --> 32:48.080]  легко извлечь его номер.
[32:53.080 --> 32:56.580]  Ну вот, это поиск блокирующего потока в слоистой сети.
[32:56.580 --> 33:00.580]  Теперь давайте покажем, что это работает за от VE.
[33:00.580 --> 33:04.780]  Вот этот алгоритм, да, ну то есть как получается тогда
[33:04.780 --> 33:07.580]  ищется блокирующий поток, блокирующий поток.
[33:07.580 --> 33:14.580]  Ну давайте напишем wild true.
[33:14.580 --> 33:20.580]  Совсем плохо напишем, но тем не менее, wild true.
[33:20.580 --> 33:24.580]  Запускаем DFS от S с каким-то там, с бесконечной копастью,
[33:24.580 --> 33:26.980]  то есть мы в S можем изначально, как бы, сколько год намного
[33:26.980 --> 33:30.180]  потока передать, а X это то, сколько смогли пропустить.
[33:30.180 --> 33:33.780]  То есть вот мы пытаемся из S протолкнуть сколько-то
[33:33.780 --> 33:36.780]  потока, исходно сколько угодно, но получилось только
[33:36.780 --> 33:37.780]  X.
[33:37.780 --> 33:40.780]  Вот, ну и если X равно нулю, то нужно сделать break.
[33:40.780 --> 33:45.780]  А иначе войти в цикл.
[33:45.780 --> 33:48.780]  То есть просто пока можно, мы из S пытаемся найти какой-то
[33:48.780 --> 33:49.780]  путь.
[33:49.780 --> 33:52.780]  Находим, находим, находим, находим, пока у них у всех
[33:52.780 --> 33:55.780]  поток больше нуля, который мы пустили, мы продолжаем
[33:55.780 --> 33:56.780]  это делать.
[33:56.780 --> 33:58.780]  Как только мы нашли, что нет ни одному такого пути,
[33:58.780 --> 34:00.780]  то есть X равно нулю, то значит мы закончили, больше
[34:00.780 --> 34:01.780]  пути нет.
[34:01.780 --> 34:02.780]  И мы нашли блокирующий поток.
[34:02.780 --> 34:06.780]  Вот, тогда утверждаю, что это работает за ОТВЕ.
[34:06.780 --> 34:23.780]  Вот этот вайл суммарно работает за ОТВЕ.
[34:23.780 --> 34:27.780]  Почему?
[34:27.780 --> 34:32.780]  А потому что давайте скажем следующее.
[34:32.780 --> 34:36.780]  Пусть в результате одного вот такого DFS-а у меня суммарно
[34:36.780 --> 34:39.780]  все поинтеры увеличились на K.
[34:39.780 --> 34:41.780]  Да, то есть напоминаю, у меня вот есть вот эти вот
[34:41.780 --> 34:43.780]  строчки типа плюс плюс PTR от V.
[34:43.780 --> 34:46.780]  Вот пусть суммарно в результате одного такого DFS-а все
[34:46.780 --> 34:51.780]  поинтеры увеличились на K, суммарно на K.
[34:51.780 --> 35:03.780]  Пусть все PTR в результате одного такого DFS-а увеличились
[35:03.780 --> 35:10.780]  на K.
[35:10.780 --> 35:14.780]  Так вот, тогда время работы этой итерации есть у ОТВ
[35:14.780 --> 35:20.780]  плюс К.
[35:20.780 --> 35:26.780]  Потому что смотрите, что такое K?
[35:26.780 --> 35:30.780]  K-это то, сколько fees мы просмотрели и пометили
[35:30.780 --> 35:31.780]  бесполезными.
[35:31.780 --> 35:34.780]  То есть мы на них посмотрели, поняли, что дальше идти
[35:34.780 --> 35:37.780]  нет смысла, и пометили как бы ну, использовоными
[35:37.780 --> 35:39.780]  что больше их не рассматривают.
[35:39.780 --> 35:42.780]  О-кей, но как тогда вообще работает этот DFS?
[35:42.780 --> 35:46.780]  Это вот этот ДФС, я не знаю.
[35:46.780 --> 35:47.780]  рассматривает.
[35:47.780 --> 35:51.100]  Окей, но как тогда вообще работает вот этот ДФС?
[35:51.100 --> 35:55.020]  Он в идеале находит какой-то путь из С в Т, длины не больше
[35:55.020 --> 35:58.740]  чем В, и еще какие-то ребра рассматривает выше этого
[35:58.740 --> 36:00.900]  пути, которые помечают бесполезными, которые помечают
[36:00.900 --> 36:03.860]  пройденными, увеличивает с них ПТР, если ПТР был
[36:03.860 --> 36:06.260]  тут, то увеличил сюда, потом сюда, то есть все эти ребра
[36:06.260 --> 36:07.260]  пометил неиспользованными.
[36:07.260 --> 36:10.780]  Поэтому вот это число, это просто то, насколько ребр
[36:10.780 --> 36:11.780]  мы посмотрим.
[36:11.780 --> 36:14.740]  Ка это то, сколько ребр мы посмотрели и пропустили,
[36:14.740 --> 36:17.740]  а В это сколько ребр мы посмотрели и положили в
[36:17.740 --> 36:24.740]  тот самый путь из С в Т.
[36:24.740 --> 36:27.620]  Нет-нет, я имею ввиду суммар, вот смотрите, мы для каждой
[36:27.620 --> 36:30.340]  вершинки увеличили ПТР и суммарные изменения на
[36:30.340 --> 36:34.420]  К, поэтому здесь просто плюс К.
[36:34.420 --> 36:42.900]  Ну вот, значит почему, потому что В плюс К это количество
[36:42.900 --> 36:47.860]  просмотренных ребр.
[36:47.860 --> 36:48.860]  Просмотренных ребр.
[36:48.860 --> 36:49.860]  Вот.
[36:49.860 --> 36:59.620]  Ну и все, а дальше, значит, как у нас работает алгоритм.
[36:59.620 --> 37:03.460]  Пока есть путь из С в Т в нашей следствии сети, мы
[37:03.460 --> 37:06.300]  пускаем ДФС, который работает вот за столько, надо понять
[37:06.300 --> 37:09.740]  тогда, сколько суммарно будет работать все эти ДФСы.
[37:10.540 --> 37:12.840]  Итак, ну вот эти К, сумма Кашек, она ограничена, видимо,
[37:12.840 --> 37:15.740]  O от E, потому что суммарный ребр E, значит суммарно все
[37:15.740 --> 37:18.440]  указатели могут завинуться максимум на E.
[37:18.440 --> 37:22.300]  Суммарно вот эта вот сумма Кашек это максимум E, вот.
[37:22.300 --> 37:24.540]  Ну а В что такое?
[37:24.540 --> 37:28.740]  Ну собственно значит, а нет, не так.
[37:28.740 --> 37:29.740]  Да.
[37:29.740 --> 37:31.100]  И суммарно еще можно сказать, что итерация максимуму
[37:31.100 --> 37:33.820]  O от E, потому что каждая итерация насекает хотя одно ребро.
[37:33.820 --> 37:36.460]  Значит суммарно итерация будет максимум E и поэтому
[37:36.460 --> 37:39.340]  симпатика будет VE плюс E, что максимально будет VE.
[37:39.340 --> 37:49.740]  И так, вот этих напишем, суммарно таких итераций,
[37:49.740 --> 37:55.900]  суммарно, ну не хочу писать слово итераций, но суммарное
[37:55.900 --> 38:08.800]  количество запусков DFS есть от E, так как каждый такой
[38:08.800 --> 38:11.320]  запуск насыщает хотя бы одно ребро, как работает
[38:11.320 --> 38:12.320]  DFS.
[38:12.320 --> 38:15.120]  Он что-то просматривает, находит какой-то путь из
[38:15.120 --> 38:17.760]  SFT и пропускает по нему максимально возможный поток.
[38:17.760 --> 38:20.280]  То есть, среди всех вот этих вот остаточных капаситей
[38:20.280 --> 38:23.240]  он выбирает минимальное и пускает поток такой величины.
[38:23.240 --> 38:25.080]  Значит, то самое ребро, которое было с минимальной
[38:25.080 --> 38:26.400]  капаситей, он насыщается.
[38:26.400 --> 38:30.200]  В общем, как всегда, нашли путь и хотя бы одно ребро
[38:30.200 --> 38:31.200]  насытилось.
[38:31.200 --> 38:34.400]  Так как хотя бы одно ребро насыщается.
[38:34.400 --> 38:50.200]  Значит, DFS запускается от E раз, каждый запуск работает
[38:50.200 --> 38:51.200]  вот за столько.
[38:51.200 --> 38:54.000]  Значит, суммарное время работы вот этого всего
[38:54.000 --> 39:00.160]  алгоритма поиска блокирующего потока есть от VE плюс сумма
[39:00.160 --> 39:01.160]  кашек.
[39:02.160 --> 39:04.640]  Точнее, насколько мы вот эти вот все кашки увеличили.
[39:04.640 --> 39:08.840]  Насколько мы запустили после первого DFS, после второго
[39:08.840 --> 39:09.840]  и так далее после этого.
[39:09.840 --> 39:15.960]  Ну а это тоже понятно, есть от E, потому что, ну я проговорил
[39:15.960 --> 39:18.160]  уже, потому что суммарное изменение указателей только
[39:18.160 --> 39:19.160]  от E.
[39:19.160 --> 39:22.880]  У каждой вершины есть там несколько ребер, сначала
[39:22.880 --> 39:24.880]  ПТР здесь, потом здесь, потом здесь, потом здесь, потом
[39:24.880 --> 39:25.880]  здесь, потом здесь.
[39:25.880 --> 39:27.920]  Сумма изменения на максимум просто число ребер в графе.
[39:28.920 --> 39:31.920]  Значит, это все есть то самое от VE.
[39:38.920 --> 39:39.920]  Давайте.
[39:41.920 --> 39:42.920]  Как?
[39:51.920 --> 39:52.920]  Давайте подумаем.
[39:58.920 --> 40:00.920]  Ну да, да, да.
[40:00.920 --> 40:01.920]  Да, я понял.
[40:11.920 --> 40:12.920]  Я понял, да.
[40:15.920 --> 40:16.920]  Видимо, да.
[40:16.920 --> 40:17.920]  Я пока, я пока.
[40:17.920 --> 40:19.920]  Окей, я не готов сказать, что это.
[40:21.920 --> 40:22.920]  Сейчас.
[40:27.920 --> 40:33.920]  Ну похоже, да, я не вижу никаких проблем.
[40:33.920 --> 40:36.920]  Единственное, что, возможно, там анализ был бы чуть сложнее
[40:36.920 --> 40:39.920]  делать, потому что, ну это вот эти там суммарные изменения
[40:39.920 --> 40:40.920]  указателей, не понятно, как считать.
[40:40.920 --> 40:43.920]  Но вообще, да, действительно похоже, что можно вот эти
[40:43.920 --> 40:47.920]  вот четыре строчки превратить просто в одну, запустить
[40:47.920 --> 40:50.920]  такой DFS, который пытается, ну собственно, вот это сразу
[40:50.920 --> 40:52.920]  и делает, пытается пустить сразу столько потока, сколько
[40:52.920 --> 40:53.920]  может.
[40:53.920 --> 40:54.920]  Пришел в вершину.
[41:00.920 --> 41:01.920]  Сейчас, ну.
[41:08.920 --> 41:09.920]  Сложно.
[41:10.920 --> 41:12.920]  Мне не очень нравится, потому что, смотрите, вот не знаю,
[41:12.920 --> 41:15.920]  как-нибудь вот пусть, пусть можно вот так вот дойти
[41:15.920 --> 41:16.920]  до какой-то вершинки.
[41:18.920 --> 41:22.920]  У меня, соответственно, DFS от нее запустится дважды,
[41:22.920 --> 41:24.920]  пытаясь протокнуть вот этот поток и вот этот поток.
[41:25.920 --> 41:27.920]  В принципе, мы тоже так делаем, да.
[41:29.920 --> 41:31.920]  Ну ладно, похоже, но все равно непонятно, как это
[41:31.920 --> 41:35.920]  анализировать, потому что тут тогда, то есть без вот
[41:35.920 --> 41:38.920]  этих рассуждений непонятно, сколько раз мы вообще DFS
[41:38.920 --> 41:40.920]  запустим от каждой вершины, как бы, на первый взгляд,
[41:40.920 --> 41:41.920]  много.
[41:43.920 --> 41:44.920]  Ну ладно.
[41:52.920 --> 41:54.920]  Ну вот, смотрите, значит, мы что сделали?
[41:54.920 --> 41:57.920]  Мы нашли какой-то алгоритм поиска блокирующего потока
[41:57.920 --> 41:58.920]  за VE.
[41:58.920 --> 42:00.920]  Теперь надо еще понять, что сколько суммарно раз нужно
[42:00.920 --> 42:03.920]  будет найти блокирующий поток в слоистой сети.
[42:04.920 --> 42:07.920]  Потому что динец, он много раз строит слоистую сеть
[42:07.920 --> 42:09.920]  и в каждой из них ищет блокирующий поток.
[42:09.920 --> 42:12.920]  Так вот, я утверждаю, что суммарно слоистых сетей мы построим
[42:12.920 --> 42:15.920]  от V, тогда будет как раз асимботика V квадрат E.
[42:15.920 --> 42:18.920]  Потому что, в общем-то, если мы будем строить слоистую
[42:18.920 --> 42:21.920]  сеть, тогда будет как раз асимботика V квадрат E.
[42:21.920 --> 42:25.920]  Потому что после выполнения вот этого вот поиска блокирующего
[42:25.920 --> 42:29.920]  потока у меня увеличивается обязательно дистанс от
[42:29.920 --> 42:30.920]  S до T.
[42:31.920 --> 42:32.920]  Такое утверждение.
[42:33.920 --> 42:36.920]  После проталкивания
[42:42.920 --> 42:43.920]  блокирующего потока
[42:43.920 --> 42:44.920]  в слоистой сети
[42:48.920 --> 42:49.920]  в слоистой сети
[42:54.920 --> 42:55.920]  имеем
[42:56.920 --> 42:59.920]  ну, я так напишу, дист новая СТ
[43:00.920 --> 43:02.920]  больше, чем дист старая
[43:03.920 --> 43:04.920]  СТ.
[43:05.920 --> 43:08.920]  То есть, вот если в этой слоистой сети
[43:09.920 --> 43:12.920]  было такое-то расстояние между СТ, то после того, как я
[43:12.920 --> 43:15.920]  ввел обратные ребра и перестроил слоистую сеть, то есть, я, по сути,
[43:15.920 --> 43:17.920]  рассматриваю слоистую сеть между двумя соседними
[43:17.920 --> 43:20.920]  итерациями. Вот здесь и следующую. Так вот, тогда дист
[43:20.920 --> 43:21.920]  обязательно увеличится.
[43:24.920 --> 43:27.920]  Дист в слоистой сети увеличивается между итерациями.
[43:29.920 --> 43:31.920]  Ну, и поскольку он не может увеличиться больше, чем на V, значит,
[43:31.920 --> 43:32.920]  итерация суммарна от V.
[43:34.920 --> 43:37.920]  Доказательств. Ну, давайте опять нарисуем слоистую сеть.
[43:38.920 --> 43:40.920]  А вот было у меня какое-то там
[43:41.920 --> 43:43.920]  разбиение такое, скажем, в L.
[43:43.920 --> 43:46.920]  И, соответственно, был путь от S до T длины L.
[43:46.920 --> 43:47.920]  L и ребер.
[43:48.920 --> 43:50.920]  Все пути имели длину L.
[43:51.920 --> 43:54.920]  Теперь я, по сути, что сделал. Я нашел блокирующий поток в этой сети.
[43:54.920 --> 43:58.920]  То есть, я в каком-то смысле все вот эти пути длины L
[43:58.920 --> 44:00.920]  исчерпал. То есть, любой путь
[44:00.920 --> 44:02.920]  содержит хотя бы одно насыщенное ребро.
[44:02.920 --> 44:06.920]  Потому что иначе, если бы был путь
[44:06.920 --> 44:09.920]  без насыщенных ребер, то я, соответственно, по нему я мог бы
[44:09.920 --> 44:11.920]  протолкнуть хотя бы единичку потока.
[44:11.920 --> 44:13.920]  То есть, все вот эти пути как бы исчерпаны.
[44:13.920 --> 44:16.920]  Я больше не могу в этой сети ничего найти, поскольку найден блокирующий поток.
[44:18.920 --> 44:21.920]  И я после этого перестраиваю слоистую сеть.
[44:21.920 --> 44:23.920]  Хочу показать, что расстояние увеличится.
[44:24.920 --> 44:27.920]  Но что вообще происходит, когда я ввожу такие обратные ребра?
[44:27.920 --> 44:30.920]  Когда я все-таки строю обратные,
[44:30.920 --> 44:32.920]  сори, остаточную сеть строю?
[44:32.920 --> 44:35.920]  Ну, понятно, какие-то ребра исчезают, потому что они строятся насыщенными,
[44:35.920 --> 44:38.920]  и к каким-то ребрам еще появляются обратные.
[44:38.920 --> 44:41.920]  Потому что, если я пропустил поток по ребру, то обязательно
[44:41.920 --> 44:43.920]  появляется обратная остаточная сеть.
[44:45.920 --> 44:48.920]  Ну и, соответственно, что тогда может произойти с расстоянием,
[44:48.920 --> 44:52.920]  если я удаляю какие-то ребра слева направо и добавляю какие-то ребра справа налево?
[44:53.920 --> 44:57.920]  Ну, понятно, но никак не могло уменьшиться или остаться таким, как было.
[44:58.920 --> 45:02.920]  Потому что, ну, как может, не знаю, пусть оно уменьшилось.
[45:02.920 --> 45:05.920]  Пусть дистанция новая, меньше дистанция старая.
[45:06.920 --> 45:09.920]  При этом, какие-то ребра слева направо я удалил,
[45:09.920 --> 45:11.920]  и добавил какие-то ребра справа налево.
[45:11.920 --> 45:15.920]  Ну, такого быть не может, потому что как может быть устроено,
[45:15.920 --> 45:18.920]  как может быть устроен путь из СВТ меньше длины?
[45:18.920 --> 45:21.920]  Значит, он должен как-то переходить по вот этим вот облачкам,
[45:21.920 --> 45:23.920]  V1, V2 и так далее, VL в каком-то порядке.
[45:23.920 --> 45:26.920]  При этом обязательно, если дистанция уменьшился,
[45:26.920 --> 45:29.920]  то ему нужно было хотя бы один вот такое перепрыгивание сделать.
[45:29.920 --> 45:33.920]  Не посетить хотя бы один из слоев.
[45:33.920 --> 45:38.920]  То есть нужно было сделать переход между двумя не соседними слоями,
[45:38.920 --> 45:40.920]  что невозможно в исходном графе.
[45:40.920 --> 45:42.920]  У меня таких ребер через слой нету,
[45:42.920 --> 45:44.920]  потому что иначе тогда это было бы...
[45:44.920 --> 45:46.920]  Ну, если есть вот такое ребро,
[45:46.920 --> 45:49.920]  то тогда вот эта вершина должна быть не в третьем слое, а во втором.
[45:50.920 --> 45:52.920]  Значит, дистанция не мог уменьшиться.
[45:52.920 --> 45:54.920]  Он также не мог остаться,
[45:54.920 --> 45:56.920]  ну, потому что, собственно, мы сказали,
[45:56.920 --> 46:00.920]  что все пути от S до T длины ровно L мы исчерпали,
[46:00.920 --> 46:03.920]  и на каждом таком пути удалилось хотя бы одно ребро.
[46:03.920 --> 46:06.920]  А вот эти вот обратные ребра справа налево,
[46:06.920 --> 46:10.920]  они, конечно, не могут оставить путь такой длины.
[46:10.920 --> 46:14.920]  То есть, возможно, теперь путь какой-то крошайший выглядит вот так.
[46:14.920 --> 46:17.920]  Сначала сюда, то есть вот это могло удалиться,
[46:17.920 --> 46:19.920]  потом пришлось идти сюда, и потом как-то вот так.
[46:19.920 --> 46:22.920]  Только так мог наш новый путь выглядеть.
[46:22.920 --> 46:26.920]  Мне, чтобы добраться до T, нужно было...
[46:26.920 --> 46:29.920]  То есть все пути слева направо как бы исчерпаны,
[46:29.920 --> 46:31.920]  значит, нужно хоть раз пойти назад,
[46:31.920 --> 46:33.920]  использовать вот одно из обратных ребер.
[46:33.920 --> 46:35.920]  Ну, значит, мой путь мог только увеличиться.
[46:38.920 --> 46:40.920]  Вопросы?
[46:44.920 --> 46:46.920]  Хорошо, ну, давайте я что-нибудь здесь напишу.
[46:46.920 --> 46:48.920]  Напишу, что... Да.
[46:49.920 --> 46:52.920]  Сейчас, давайте подумаем.
[46:56.920 --> 46:59.920]  Внутри слоя, да, еще бывает, да, действительно.
[47:02.920 --> 47:09.920]  Так вот, значит, все пути длины L исчерпаны.
[47:11.920 --> 47:14.920]  Ну, я вот так схематично пишу, все пути длины L исчерпаны,
[47:14.920 --> 47:16.920]  значит, нужно...
[47:18.920 --> 47:20.920]  Новый путь...
[47:23.920 --> 47:25.920]  Не проходит...
[47:26.920 --> 47:29.920]  Ну, вот так вот, идеально он проходить не может.
[47:29.920 --> 47:31.920]  Из S-V1 в V2 и так далее T.
[47:31.920 --> 47:33.920]  Вот так проходить он не может,
[47:33.920 --> 47:35.920]  значит, он использует хотя бы еще одно ребро,
[47:35.920 --> 47:37.920]  там, либо внутри слоя, да, как правильно было замечено,
[47:37.920 --> 47:39.920]  либо вообще одно из обратных использует,
[47:39.920 --> 47:42.920]  ну, и тем самым наша длина увеличилась.
[47:44.920 --> 47:46.920]  Так, ну и все, тогда следствие.
[47:47.920 --> 47:50.920]  Число итерации в L у единица есть от V.
[48:14.920 --> 48:16.920]  Вот так вот.
[48:16.920 --> 48:18.920]  Ну, вот так вот.
[48:18.920 --> 48:20.920]  Ну, вот так вот.
[48:20.920 --> 48:22.920]  Ну, вот так вот.
[48:22.920 --> 48:24.920]  Ну, вот так вот.
[48:24.920 --> 48:26.920]  Ну, вот так вот.
[48:26.920 --> 48:28.920]  Ну, вот так вот.
[48:28.920 --> 48:30.920]  Ну, вот так вот.
[48:30.920 --> 48:32.920]  Ну, вот так вот.
[48:32.920 --> 48:34.920]  Ну, вот так вот.
[48:34.920 --> 48:36.920]  Ну, вот так вот.
[48:36.920 --> 48:38.920]  Ну, вот так вот.
[48:38.920 --> 48:40.920]  Ну, вот так вот.
[48:40.920 --> 48:42.920]  Вот так вот.
[48:42.920 --> 48:44.920]  Ну, вот так вот.
[48:44.920 --> 48:46.920]  Ну, вот так вот.
[48:46.920 --> 48:48.920]  Ну, вот так вот.
[48:48.920 --> 48:50.920]  Ну, вот так вот.
[48:50.920 --> 48:52.920]  Ну, вот так вот.
[48:52.920 --> 48:54.920]  Ну, вот так вот.
[48:54.920 --> 48:56.920]  Ну, вот так вот.
[48:56.920 --> 48:58.920]  Ну, вот так вот.
[48:58.920 --> 49:00.920]  Ну, вот так вот.
[49:00.920 --> 49:02.920]  Ну, вот так вот.
[49:02.920 --> 49:04.920]  Ну, вот так вот.
[49:04.920 --> 49:06.920]  Ну, вот так вот.
[49:06.920 --> 49:08.920]  Ну, вот так вот.
[49:08.920 --> 49:10.920]  Вот так вот.
[49:10.920 --> 49:12.920]  Ну, вот так вот.
[49:12.920 --> 49:14.920]  Ну, вот так вот.
[49:14.920 --> 49:16.920]  Ну, вот так вот.
[49:16.920 --> 49:18.920]  Ну, вот так вот.
[49:18.920 --> 49:20.920]  Ну, вот так вот.
[49:20.920 --> 49:22.920]  Ну, вот так вот.
[49:22.920 --> 49:24.920]  Ну, вот так вот.
[49:24.920 --> 49:26.920]  Ну, вот так вот.
[49:26.920 --> 49:28.920]  Ну, вот так вот.
[49:28.920 --> 49:30.920]  Ну, вот так вот.
[49:30.920 --> 49:32.920]  Ну, вот так вот.
[49:32.920 --> 49:34.920]  Ну, вот так вот.
[49:34.920 --> 49:36.920]  Ну, вот так вот.
[49:36.920 --> 49:38.920]  Ну, вот так вот.
[49:38.920 --> 49:40.920]  Ну, вот так вот.
[49:40.920 --> 49:42.920]  Ну, вот так вот.
[49:42.920 --> 49:44.920]  Ну, вот так вот.
[49:44.920 --> 49:46.920]  Ну, вот так вот.
[49:46.920 --> 49:48.920]  Ну, вот так вот.
[49:48.920 --> 49:50.920]  Ну, вот так вот.
[49:50.920 --> 49:52.920]  Ну, вот так вот.
[49:52.920 --> 49:54.920]  Ну, вот так вот.
[49:54.920 --> 49:56.920]  Ну, вот так вот.
[49:56.920 --> 49:58.920]  Ну, вот так вот.
[49:58.920 --> 50:00.920]  Ну, вот так вот.
[50:00.920 --> 50:02.920]  Ну, вот так вот.
[50:02.920 --> 50:04.920]  Ну, вот так вот.
[50:04.920 --> 50:06.920]  Ну, вот так вот.
[50:06.920 --> 50:08.920]  Ну, вот так вот.
[50:08.920 --> 50:10.920]  Ну, вот так вот.
[50:10.920 --> 50:12.920]  Ну, вот так вот.
[50:12.920 --> 50:14.920]  Ну, вот так вот.
[50:14.920 --> 50:16.920]  Ну, вот так вот.
[50:16.920 --> 50:18.920]  Ну, вот так вот.
[50:19.920 --> 50:20.920]  Ну, вот так вот.
[50:20.920 --> 50:22.920]  Ну, вот так вот.
[50:22.920 --> 50:24.920]  Ну, вот так вот.
[50:24.920 --> 50:26.920]  Ну, вот так вот.
[50:27.920 --> 50:28.920]  Ну, вот так вот.
[50:28.920 --> 50:30.920]  Ну, вот так вот.
[50:30.920 --> 50:32.920]  Ну, вот так вот.
[50:32.920 --> 50:34.920]  Ну, вот так вот.
[50:34.920 --> 50:36.920]  Ну, вот так вот.
[50:37.920 --> 50:39.420]  Ну, вот так вот.
[50:39.420 --> 50:41.920]  Ну, вот так вот.
[50:43.920 --> 50:45.920]  Ну, вот так вот.
[50:45.920 --> 50:47.920]  Ну, вот так вот.
[50:47.920 --> 50:52.920]  Это так называемые теоремы Корзанова. Мы рассмотрим пока что только одну из них.
[50:52.920 --> 51:01.920]  Теорема Корзанова, первая. Их всего две. Вторая, ну, в семинаре будет.
[51:01.920 --> 51:07.920]  Значит, теорема такая. Число итераций алгоритма 1.
[51:07.920 --> 51:19.920]  Алгоритма 1. Есть от корни СП, где П мы сейчас определим.
[51:19.920 --> 51:25.920]  П сейчас определим и докажем теорему, и все будет хорошо.
[51:25.920 --> 51:40.920]  Определение. Давайте мы для каждой вершины, отличной от С и Т, мы определим входящую
[51:40.920 --> 51:46.920]  capacity и исходящую capacity. Вот, собственно, очень естественные штуки.
[51:46.920 --> 51:52.920]  Это ограничение на то, сколько потока может втечь в В и сколько может вытечь из В.
[51:52.920 --> 51:58.920]  То есть это сумма capacity по всем входящим ребрам, это сумма capacity по всем исходящим ребрам.
[51:58.920 --> 52:06.920]  Значит, сумма по УСУВ, здесь сумма по ВСВВ.
[52:06.920 --> 52:13.920]  Значит, это как бы то, ну, оценка сверху, сколько может потока протечь как бы через вершинку В.
[52:13.920 --> 52:19.920]  Вот если здесь может втечь максимум СИН, может вытечь максимум САУТ, значит точно есть оценка
[52:19.920 --> 52:25.920]  сверху, не больше чем это, не больше чем это.
[52:25.920 --> 52:35.920]  Мы можем определить потенциал вершинки В, это вот тот самый минимум из САУТ.
[52:35.920 --> 52:40.920]  Оценка сверху на велесину потока, протекающего через вершинку.
[52:40.920 --> 52:46.920]  Вот, ну и наконец вот это вот П. Это есть сумма потенциалов по всем вершинкам.
[52:46.920 --> 52:51.920]  Неравным СТ, потенциал вершины В.
[52:57.920 --> 53:02.920]  И если мы вот так определим этот самый наш потенциал, то оказывается, что число итераций, в частности,
[53:02.920 --> 53:08.920]  можно оценить как от корни СП. То есть можно оценить как от В, это все верно,
[53:08.920 --> 53:12.920]  но еще можно оценить как от корни СП. Соответственно, можно выбрать любой из двух оценок,
[53:12.920 --> 53:19.920]  та из них, которая точнее и будет, ну, наиболее точно оценивать ваш время работы алгоритма.
[53:23.920 --> 53:26.920]  Значит, чтобы это доказать, нам нужны пару лемм.
[53:26.920 --> 53:35.920]  Лемма первая. Пусть L это длина кратчайшей пути.
[53:36.920 --> 53:38.920]  Дист просто СТ.
[53:44.920 --> 53:48.920]  Дальше F это величина МАКС потока.
[53:53.920 --> 53:55.920]  Ну а П вот тот самый потенциал.
[53:55.920 --> 53:57.920]  Тогда есть неравенство их связывающее.
[54:01.920 --> 54:04.920]  L не больше, чем потенциал, деленный на поток, плюс один.
[54:14.920 --> 54:16.920]  Доказательства.
[54:16.920 --> 54:19.920]  Ну как выглядит наш граф?
[54:19.920 --> 54:21.920]  Давайте нарешим слоистую сеть, нашу любимую.
[54:25.920 --> 54:27.920]  Вот здесь где-то Т.
[54:30.920 --> 54:35.920]  Смотрите, эта лемма работает для произвольного сети.
[54:35.920 --> 54:39.920]  Вот есть у вас сеть, вы в ней определяете кратчайшее состояние.
[54:39.920 --> 54:43.920]  Максимальный поток в принципе, ну как у нас был Fortfalk's максимальный поток,
[54:43.920 --> 54:45.920]  и потенциал.
[54:45.920 --> 54:47.920]  Так вот тогда вот это верно.
[54:47.920 --> 54:49.920]  Это работает для любого графа.
[54:49.920 --> 54:51.920]  Без значительно перехода к какой-то сети и так далее.
[54:51.920 --> 54:53.920]  Вот.
[54:53.920 --> 54:55.920]  Рассмотрим вот эту слоистую сеть.
[54:55.920 --> 54:57.920]  Тогда можно написать следующее.
[54:57.920 --> 55:01.920]  Смотрите, давайте рассмотрим какой-нибудь там итый слой.
[55:01.920 --> 55:05.920]  Если я напишу, что ПИТ,
[55:05.920 --> 55:07.920]  то я напишу ПИТ,
[55:07.920 --> 55:11.920]  если я напишу, что ПИТ
[55:11.920 --> 55:17.920]  равно сумме потенциалов вершин из этого слоя,
[55:17.920 --> 55:23.920]  то я могу заведомо сказать, что эта штука больше равна, чем поток.
[55:23.920 --> 55:29.920]  Потому что что такое сумма потенциалов потока через этот слой?
[55:29.920 --> 55:33.920]  Вот есть наш слой.
[55:33.920 --> 55:35.920]  Я здесь рассматриваю все вершинки.
[55:35.920 --> 55:43.920]  Я рассматриваю здесь все вершинки.
[55:43.920 --> 55:45.920]  И вот эта сумма П,
[55:45.920 --> 55:51.920]  это какая-то оценка сверху на то, сколько потока может протекать сквозь наш слой.
[55:51.920 --> 55:57.920]  Ну и тогда понятно, что поток не может быть больше, чем этот самый потенциал, чем ПИТ.
[55:57.920 --> 56:01.920]  Потому что вообще как устроена любая единичка потока в этой сети?
[56:01.920 --> 56:05.920]  Ну да, она может там как-то находиться.
[56:05.920 --> 56:09.920]  Мы вспоминаем, что есть еще ребра не из ИТВ слоя, вы плюс первый.
[56:09.920 --> 56:11.920]  Но тогда какие еще бывают ребра?
[56:11.920 --> 56:13.920]  Бывают ребра как бы назад,
[56:13.920 --> 56:17.920]  и бывают ребра где-то внутри слоя.
[56:17.920 --> 56:19.920]  Но они все в этой сумме как бы учтутся,
[56:19.920 --> 56:21.920]  потому что когда мы проводим какой-то поток,
[56:21.920 --> 56:23.920]  у меня точно вот к этой вершине добавится,
[56:23.920 --> 56:26.920]  вышлится какой-то F из осащенной капасти,
[56:26.920 --> 56:28.920]  и вот отсюда вышлится F из осащенной капасти.
[56:28.920 --> 56:30.920]  Поэтому у меня все равно этот поток,
[56:30.920 --> 56:33.920]  он как бы должен, я вот так неформально объясняю,
[56:33.920 --> 56:35.920]  должен пересечь наш слой.
[56:35.920 --> 56:37.920]  То есть как бы втечь и вытечь.
[56:37.920 --> 56:40.920]  Вот это F должно как бы в него попасть и уйти оттуда.
[56:40.920 --> 56:44.920]  Поэтому суммарно, если у меня по сути вот эта сумма,
[56:44.920 --> 56:48.920]  это есть ограничение на то, сколько может втечь и сколько может вытечь из этого слоя.
[56:48.920 --> 56:50.920]  Но оно все равно должно втечь и потом вытечь.
[56:51.920 --> 56:53.920]  Значит, это все не больше, чем F.
[56:53.920 --> 56:55.920]  И так, и это верно для каждого i.
[56:55.920 --> 56:58.920]  Верно для любого i, ну скажем, от 1 до l-1.
[57:00.920 --> 57:02.920]  Тогда если я сложу это все по всем i,
[57:02.920 --> 57:04.920]  то у меня что получится?
[57:04.920 --> 57:06.920]  У меня получится, что, давайте напишем,
[57:06.920 --> 57:08.920]  сумму по i, сумму по v из vi.
[57:09.920 --> 57:11.920]  И у меня будет от 1 до l-1.
[57:13.920 --> 57:16.920]  Сумма всех потенциалов больше, если про нас,
[57:16.920 --> 57:18.920]  соответственно, чем l-1F.
[57:19.920 --> 57:22.920]  Ну а это все, это не больше, чем просто весь потенциал светит.
[57:22.920 --> 57:25.920]  Потому что у меня здесь сумма каких-то там вершин,
[57:25.920 --> 57:27.920]  слоев с 1 по l-1.
[57:27.920 --> 57:29.920]  Есть еще и другие вершины, скажем.
[57:29.920 --> 57:30.920]  Вот здесь все они учтены.
[57:30.920 --> 57:32.920]  Возможно, есть вершины еще правее.
[57:32.920 --> 57:35.920]  Вот они не учтены, поэтому здесь будет эта оценка снизу на потенциал.
[57:35.920 --> 57:39.920]  Ну и того получили, что потенциал больше, в общем, l-1 умножить на F.
[57:39.920 --> 57:41.920]  А это в точность тоже написано здесь.
[57:46.920 --> 57:49.920]  Да, еще раз, значит, вот это для каждого слоя верно.
[57:49.920 --> 57:51.920]  Суммируем по всем i от 1 до l-1.
[57:51.920 --> 57:56.920]  Видим, что это больше, ну, соответственно, просто вот l-1 раз такое неравенство складываем.
[57:56.920 --> 57:58.920]  Остается справа l-1 умножить на F.
[57:58.920 --> 58:02.920]  И все это оценим еще сверху через P, потому что потенциал не, ну, как бы...
[58:02.920 --> 58:06.920]  Здесь учитывается потенциал всех вершин, кроме, возможно, там, каких-то, которые не учтены.
[58:06.920 --> 58:08.920]  Значит, это оценка снизу на потенциал.
[58:08.920 --> 58:10.920]  Все доказали.
[58:19.920 --> 58:25.920]  Вот, и вторая лемма говорит нам, что потенциал сети — это константа после проталкивания потоков.
[58:25.920 --> 58:31.920]  То есть вот есть у меня какая-то сеть, я там пустил какой-то поток, соответственно, добавил обратные ребра,
[58:31.920 --> 58:33.920]  построил статочную сеть и так далее.
[58:33.920 --> 58:35.920]  Но потенциал всегда, всегда постоянный.
[58:36.920 --> 58:40.920]  Значит, потенциал сети не изменяется.
[58:40.920 --> 58:42.920]  А потенциал сети не изменяется.
[58:42.920 --> 58:44.920]  Но потенциал всегда, всегда постоянный.
[58:45.920 --> 58:49.920]  Значит, потенциал сети не изменяется.
[58:54.920 --> 58:56.920]  При проталкивании потока...
[59:02.920 --> 59:04.920]  Ну, с учетом обратных ребер.
[59:05.920 --> 59:07.920]  С учетом обратных ребер.
[59:12.920 --> 59:14.920]  Ну, доказательство совсем простое.
[59:14.920 --> 59:18.920]  Давайте вот пусть мы вдоль какого-то пути протолкнули поток.
[59:18.920 --> 59:21.920]  И рассмотрим для конкретной вершины на этом пути, что поменялось.
[59:21.920 --> 59:26.920]  То есть я в нее, как бы, ну, через нее протолкнул F-потока.
[59:26.920 --> 59:30.920]  Значит, соответственно, на вот этих вот ребрах появился поток плюс F,
[59:30.920 --> 59:35.920]  а на обратных к ним поток, наоборот, уменьшился на F.
[59:35.920 --> 59:39.920]  Ну, тогда давайте попытаемся понять, как поменялось C-in и C-out для вот этой конкретной вершины.
[59:39.920 --> 59:42.920]  Мы сейчас покажем, что для каждой конкретной вершины
[59:42.920 --> 59:45.920]  ни C-in не поменялся, ни C-out не поменялся.
[59:45.920 --> 59:48.920]  А значит, для всех вершин ничего не поменялось, потенциалы всех вершин сохранились.
[59:48.920 --> 59:51.920]  Значит, потенциал всей сети тоже остался таким, как был.
[59:52.920 --> 59:54.920]  Так вот.
[59:55.920 --> 59:58.920]  Ну, тут, собственно, видно, как поменялось C-in для этой вершинки.
[59:58.920 --> 01:00:00.920]  Ну, вот это все.
[01:00:01.920 --> 01:00:05.920]  Ну, тут, собственно, видно, как поменялось C-in для этой вершинки.
[01:00:05.920 --> 01:00:09.920]  У меня уменьшилась остаточная капаситет этого ребра на F,
[01:00:09.920 --> 01:00:12.920]  но зато увеличилась остаточная капаситет этого ребра на F.
[01:00:12.920 --> 01:00:17.920]  Да, потому что здесь плюс F-потоку, то есть минус F-capacity,
[01:00:17.920 --> 01:00:19.920]  а здесь минус F-потоку, то есть плюс F-capacity.
[01:00:19.920 --> 01:00:22.920]  Поэтому давайте я как-нибудь напишу, да.
[01:00:23.920 --> 01:00:32.920]  Давайте напишу так, что остаточная капаситет ребра у В, она уменьшилась на F,
[01:00:32.920 --> 01:00:36.920]  остаточная капаситет ребра В у увеличилась на F,
[01:00:36.920 --> 01:00:41.920]  остаточная капаситет ребра Вw уменьшилась на F,
[01:00:41.920 --> 01:00:44.920]  а Ww увеличилась на F.
[01:00:45.920 --> 01:00:48.920]  Ну, и значит, C-in от В
[01:00:49.920 --> 01:00:53.920]  с одной стороны уменьшилось на F, потому что вот это ребро стало меньше на F,
[01:00:53.920 --> 01:00:56.920]  с другой стороны увеличилось на F, потому что это ребро стало больше на F.
[01:00:56.920 --> 01:00:59.920]  Значит, это, давайте я напишу так, плюс равно F-F,
[01:00:59.920 --> 01:01:01.920]  минус F, то есть не изменилось.
[01:01:01.920 --> 01:01:03.920]  И то же самое с C-out от В.
[01:01:04.920 --> 01:01:06.920]  Да, с C-out, смотрим на исходящие ребра.
[01:01:06.920 --> 01:01:09.920]  Здесь capacity упало на F, а здесь выросло на F.
[01:01:09.920 --> 01:01:12.920]  Значит, сумма capacity осталась такой, какая была.
[01:01:12.920 --> 01:01:14.920]  Тоже, плюс равно F-F.
[01:01:18.920 --> 01:01:22.920]  Все, значит, у каждой вершины, какие были вот эти оценки C-in от В и C-out от В,
[01:01:22.920 --> 01:01:24.920]  они такие же и остались.
[01:01:24.920 --> 01:01:26.920]  Поэтому все потенциалы сохранились.
[01:01:26.920 --> 01:01:28.920]  Значит, P от V сохранилось.
[01:01:29.920 --> 01:01:31.920]  Сохранилось.
[01:01:32.920 --> 01:01:34.920]  Значит, P сохранилось.
[01:01:35.920 --> 01:01:38.920]  P не меняется после протолкания потока.
[01:01:38.920 --> 01:01:41.920]  Вот, и теперь мы наконец готовы доказать теорему Корзанова.
[01:01:52.920 --> 01:01:54.920]  Доказать теоремы.
[01:01:54.920 --> 01:01:57.920]  Нам надо доказать, что число уитарации есть от корни ИСП.
[01:01:58.920 --> 01:01:59.920]  А давайте сделаем следующее.
[01:01:59.920 --> 01:02:03.920]  Давайте мы насильно в нашем алгоритме доказать теорему Корзанова.
[01:02:03.920 --> 01:02:05.920]  То есть, от корни ИСП.
[01:02:05.920 --> 01:02:07.920]  А давайте сделаем следующее.
[01:02:07.920 --> 01:02:10.920]  Давайте мы насильно в нашем алгоритме сделаем просто первые корень ИСП-итерации.
[01:02:12.920 --> 01:02:22.920]  Сделаем первые корень ИСП-итерации алгоритма Деница.
[01:02:26.920 --> 01:02:30.920]  То есть, просто столько раз найдем слоистую сеть, пустим блокирующий поток.
[01:02:30.920 --> 01:02:33.920]  слоистую сеть, пустим блокирующий поток. Итак, корень ИСП раз.
[01:02:33.920 --> 01:02:37.920]  Если алгоритм успел завершиться, то мы победили. Нам достаточно такого числа
[01:02:37.920 --> 01:02:41.920]  итерации, чтобы алгоритм завершился. Это простой случай, я его даже не буду записывать.
[01:02:41.920 --> 01:02:46.920]  Если алгоритм завершился, то мы уже победили. Иначе нам надо еще что-то делать.
[01:02:46.920 --> 01:02:52.920]  Но смотрите, если мы сделали столько итераций, значит вот в оставшейся сети,
[01:02:52.920 --> 01:02:56.920]  в остаточной сети, которая осталась после этих итераций, мы точно знаем,
[01:02:56.920 --> 01:03:03.920]  что ДИСТ хотя бы корень ИСП. Потому что каждый раз увеличивает ДИСТ хотя бы на единичку,
[01:03:03.920 --> 01:03:07.920]  а мы сделали столько итераций, поэтому в результате ДИСТ хотя бы такой.
[01:03:07.920 --> 01:03:13.920]  Так как каждая итерация увеличивает этот самый ДИСТ.
[01:03:13.920 --> 01:03:19.920]  Увеличивает ДИСТ.
[01:03:19.920 --> 01:03:27.920]  И это вот то, что мы обзовем за L.
[01:03:27.920 --> 01:03:32.920]  Ну а дальше мы знаем, что наш P не изменился.
[01:03:32.920 --> 01:03:38.920]  И давайте скажем, что пусть F это сколько потока осталось протолкнуть до конца.
[01:03:39.920 --> 01:03:45.920]  Сколько осталось пустить потока.
[01:03:49.920 --> 01:03:56.920]  Когда по вот этой первой лемме мы знаем, что L не больше, чем P на F плюс...
[01:03:56.920 --> 01:04:02.920]  Сейчас, плюс один. Да, плюс один.
[01:04:02.920 --> 01:04:07.920]  Это просто первая лемма. То есть смотрите, я запустил столько итераций, у меня остался какой-то граф.
[01:04:07.920 --> 01:04:12.920]  Вот для этого графа, который остается после такой итерации, я применяю вот эту лемму.
[01:04:12.920 --> 01:04:16.920]  В ней L – это тот самый ДИСТ, который хотя бы корень ИСП.
[01:04:16.920 --> 01:04:20.920]  P – это тот же самый потенциал, который был с самого начала, потому что P не меняется.
[01:04:20.920 --> 01:04:25.920]  А F – это то, сколько потока осталось пропустить. Остаточный поток в остаточной сети.
[01:04:25.920 --> 01:04:32.920]  Вот я его написал. И это все хотя бы корень ИСП.
[01:04:32.920 --> 01:04:39.920]  Ну тогда, что мы получили? Мы получили, что P делит на F плюс один больше равно, чем корень ИСП.
[01:04:39.920 --> 01:04:44.920]  Но отсюда видно, что F по величине не больше, чем корень ИСП.
[01:04:44.920 --> 01:04:51.920]  Давайте немножко перепишу. Что написано? Написано, что P делит на F больше равно, чем корень ИСП минус один.
[01:04:51.920 --> 01:04:59.920]  То есть F меньше либо равно P делит на корень ИСП минус один.
[01:04:59.920 --> 01:05:06.920]  Что есть от корня ИСП.
[01:05:06.920 --> 01:05:13.920]  Итого, что получилось. С помощью наших лем мы поняли, что остаточный поток после вот этих вот корня ИСП итераций
[01:05:13.920 --> 01:05:17.920]  по величине сам по себе равен от корня ИСП.
[01:05:17.920 --> 01:05:24.920]  Ну значит, если я просто буду пускать наш алгоритм Динница дальше и дальше, то поскольку на каждой итерации мы находим хотя бы один путь,
[01:05:24.920 --> 01:05:30.920]  у нас на каждой итерации есть путь в остаточной сети, значит мы по нему хотя бы что-то протолкнем.
[01:05:30.920 --> 01:05:34.920]  Значит, каждая итерация хотя бы единичку потока нам добавляет.
[01:05:34.920 --> 01:05:39.920]  Ну а если всего осталось столько единиц потока, значит осталось после вот этих итераций еще максимум от корня ИСП.
[01:05:39.920 --> 01:05:46.920]  Поэтому суммарно от корня ИСП итераций. Согласны?
[01:05:46.920 --> 01:06:01.920]  Ну вот. И соответственно эта оценка может быть нам выгодна, если корень ИСП меньше, чем В, тогда мы получили более точную оценку на целую итерацию алгоритма Динница.
[01:06:01.920 --> 01:06:19.920]  Вот, и сейчас применим это в каком-то частном случае. Давайте посмотрим на единичные сети.
[01:06:19.920 --> 01:06:27.920]  Значит, определение. Сеть единична, если в ней вся капаситет 0 или единица.
[01:06:27.920 --> 01:06:39.920]  Если вся капаситет равна 0 или единице.
[01:06:39.920 --> 01:06:46.920]  Первое замечание.
[01:06:46.920 --> 01:06:58.920]  Потенциал такой сети не больше, чем О от Е.
[01:06:58.920 --> 01:07:08.920]  Ну это совсем просто, потому что вот есть какая-то вершина. Мы можем легко сказать, что ее, значит, Син, это просто сколько ребер в нее входит.
[01:07:08.920 --> 01:07:17.920]  Ну давайте оставим только ребра с единичной капасти. Син это сколько ребер входит, Цао это сколько выходит.
[01:07:17.920 --> 01:07:25.920]  Поэтому можем гарантированно написать, ну давайте я совсем в тупую напишу, что потенциал любой вершины не больше, чем О от Е.
[01:07:26.920 --> 01:07:33.920]  Не больше, чем входящая степень от вершины В.
[01:07:33.920 --> 01:07:37.920]  Плюс исходящая степень от вершины В.
[01:07:37.920 --> 01:07:42.920]  То есть, на самом деле, тут можно было писать минимум из этих двух. Но я давайте для удобства напишу Сумму.
[01:07:42.920 --> 01:07:46.920]  Потенциал вершины не больше, чем сколько ребер в нее вошло, плюс сколько ребер вышло.
[01:07:46.920 --> 01:07:52.920]  Еще раз, на самом деле, минимум из этих двух. Но я загрублю неравенство и напишу не больше, чем Сумма.
[01:07:52.920 --> 01:08:02.800]  Поэтому сумма по всем вершинам неравным s и t, p от v, просто не больше чем 2e, потому что
[01:08:02.800 --> 01:08:06.480]  каждое ребро, оно учтется в этой большей сумме ровно два раза, ну не больше чем два раза,
[01:08:06.480 --> 01:08:13.920]  от начала и от конца. Сумма потенциалов не больше, чем сумма как бы всех степеней,
[01:08:13.920 --> 01:08:23.320]  что ограничено сверху двумя e. Вот поэтому потенциал есть от e, а значит по теориям
[01:08:23.320 --> 01:08:30.680]  Картанова число итерации есть ну максимум от корни из e. Это первая мысль.
[01:08:30.680 --> 01:08:47.720]  Вторая мысль такая, что на таких сетях алгоритм поиска блокирующего потока
[01:08:47.720 --> 01:09:01.080]  плейстой сети работает за от e. Поиск блок потока плейстой сети, на самом деле неважно в какой,
[01:09:01.080 --> 01:09:12.280]  пусть будет слоистой сети, работает за от e. Повторюсь, это только если у нас сеть единичная.
[01:09:12.280 --> 01:09:18.560]  Если единичная сеть, мы по ней построили слоистую в какой-то момент времени, то тогда вот тот
[01:09:18.560 --> 01:09:29.360]  самый алгоритм поиска блокирующего потока, который мы писали, работает за от e. Почему?
[01:09:29.360 --> 01:09:37.400]  Потому что каждый ребро рассмотрится максимум один раз. Давайте вспомним, как у нас работал
[01:09:37.560 --> 01:09:47.000]  ДФС внутри поиска блокирующего потока. Он в итоге находил какой-то путь из СВТ в нашей
[01:09:47.000 --> 01:09:53.000]  слоистой сети и при этом еще какие-то ребра скипал, увеличивал ПТР для вершинок, помечая, что эти
[01:09:53.000 --> 01:09:58.200]  ребра больше никогда не нужно рассматривать. Но тогда понятно, что я не только эти ребра никогда
[01:09:58.200 --> 01:10:02.680]  не буду рассматривать, но и вот эти, по которым я только что пустил единичку потока. Потому что
[01:10:02.680 --> 01:10:07.440]  если у меня все капасти это нули или единицы, и я пустил здесь поток, значит все эти ребра
[01:10:07.440 --> 01:10:12.200]  скопом сразу стали насыщенными. Раньше у меня насыщенное могло стать всего одно ребро,
[01:10:12.200 --> 01:10:19.240]  если сеть произвольное, но если единичное, то сразу все вот эти ребра стали насыщенными. Все эти
[01:10:19.240 --> 01:10:35.200]  ребра становятся насыщенными. Значит, каждое ребро в нашем ДФСе, во всех наших ДФСах,
[01:10:35.200 --> 01:10:40.280]  поучаствует максимум один раз. Мы либо переключим для него ПТР, либо сразу насытим,
[01:10:40.280 --> 01:10:44.240]  и соответственно опять тоже сразу увеличим ПТР. То есть если я его насытил, то я могу сразу
[01:10:44.240 --> 01:10:50.400]  увеличить наш ПТР и как бы его больше не рассматривать. Поэтому суммарно каждый
[01:10:50.400 --> 01:10:55.760]  ребро рассмотрится максимум один раз. Значит, и время работы всех вот этих ДФСов есть у ЛАТЕ.
[01:10:55.760 --> 01:11:05.680]  Значит, следствие. Алгоритм диница на единичной сети работает за Е корниз Е.
[01:11:14.680 --> 01:11:30.680]  Потому что суммарно итерацией корни из Е по терями Карданова, и каждый поиск глубок縮 потока за ООД Е.
[01:11:30.680 --> 01:11:39.240]  Поэтому замечаем, что каждый ребро максимум один раз поучаствует в нашем ДФСе.
[01:11:39.240 --> 01:11:42.960]  за от Е, вот поэтому замечание, что каждое левро максимум один раз поучаствует в нашем ДФСе.
[01:11:44.520 --> 01:11:49.480]  Вот, это уже, ну скажем так, сильно круче, чем все, что было до этого, чем всякие там
[01:11:50.000 --> 01:11:52.000]  Эдманс Карп, ну по крайней мере теоретические оценки
[01:11:52.640 --> 01:11:54.980]  Эдманса Карпа или даже Найденица в общем случае.
[01:12:09.240 --> 01:12:11.240]  Четверть стр안 галward Syntax
[01:12:25.000 --> 01:12:31.000]  Так, ну и последнее тогда.
[01:12:31.000 --> 01:12:42.980]  карпа. Это решение задачи о максимальном просочетании
[01:12:42.980 --> 01:12:50.340]  в дудольном графе с помощью потоков. Поиск максимального
[01:12:50.340 --> 01:13:05.860]  просочетания в дудольном графе. Мы должны помнить,
[01:13:05.860 --> 01:13:10.140]  что у нас есть алгоритм Куна, который делает это
[01:13:10.140 --> 01:13:14.220]  за VE. По крайней мере, теоретическая оценка у нас там получалась
[01:13:14.220 --> 01:13:20.580]  VE, число вершин на число ребер. Давайте теперь решим
[01:13:20.580 --> 01:13:24.700]  эту же задачу с помощью потока и с помощью техники
[01:13:24.700 --> 01:13:27.900]  параллельничной сети мы поймем, что алгоритм Динница
[01:13:27.900 --> 01:13:30.020]  на соответствующей сети будет работать еще круче,
[01:13:30.020 --> 01:13:35.540]  чем вот это. Сеть будет такая. Есть у меня исходный дудольный
[01:13:35.540 --> 01:13:40.300]  граф, вот такой какой-то. Тут есть какие-то ребра
[01:13:40.300 --> 01:13:46.780]  между вершинками разных долей. Я ввожу две эффективные
[01:13:46.780 --> 01:13:51.820]  вершины S и T. Что-то слева, что-то справа. И провожу
[01:13:51.820 --> 01:13:58.380]  ребра единичной capacity из S во все вершины левой доли.
[01:13:58.380 --> 01:14:03.100]  Здесь у всех capacity единичка. И capacity единичка из вершин
[01:14:03.100 --> 01:14:09.900]  правой доли в T. Здесь опять все capacity единички. Но вот
[01:14:10.060 --> 01:14:12.460]  эти ребра я тоже ориентирую слева направо и на них на
[01:14:12.460 --> 01:14:15.860]  всех рисую capacity единичка. Все ориентируюсь слева
[01:14:15.860 --> 01:14:20.300]  направо, они все имеют capacity единичка. Так вот, я тогда
[01:14:20.300 --> 01:14:23.900]  утверждаю, что максимальный поток в этой сети соответствует
[01:14:23.900 --> 01:14:27.020]  максимальному просочетанию. Ну и вообще, любой поток,
[01:14:27.020 --> 01:14:29.900]  какой бы мы тут не пустили из S в T, он обязательно соответствует
[01:14:29.900 --> 01:14:32.300]  какому-то просочетанию в исходном моем дудольном
[01:14:33.100 --> 01:15:02.100]  графе. Поток соответствует просочетанию. Ну почему?
[01:15:02.100 --> 01:15:04.500]  Надо всего лишь понять, как просто выглядит любой
[01:15:04.500 --> 01:15:06.500]  поток. Давайте попробуем что-нибудь порисовать. Вот
[01:15:06.500 --> 01:15:16.100]  есть S, есть T. Как может выглядеть любой поток? Ну давайте
[01:15:16.100 --> 01:15:18.500]  проследим просто историю какой-нибудь единички потока.
[01:15:18.500 --> 01:15:21.500]  Вот она сначала вышла из S, попала куда-то в какую-то
[01:15:21.500 --> 01:15:24.500]  из вершин левой доли. Потом какие есть из нее ребра?
[01:15:24.500 --> 01:15:26.300]  Понятно, только в правую долю. Куда-то вот сюда
[01:15:26.300 --> 01:15:29.700]  она могла переместиться. Это самая единичка. И потом
[01:15:29.700 --> 01:15:31.900]  ей опять же не остается выбора, кроме как просто
[01:15:31.900 --> 01:15:36.900]  стечь в сток T. Вот это история поведения каждой единичке
[01:15:36.900 --> 01:15:41.700]  потока. Ну и поскольку у нас поток складывается
[01:15:41.700 --> 01:15:44.700]  из всех таких путей, то все пути, они вот ровно так
[01:15:44.700 --> 01:15:47.700]  и устроены. Сначала мы попадаем в левую долю, потом куда-то
[01:15:47.700 --> 01:15:51.700]  в вершину правой доли, и потом стекаем в T. При этом,
[01:15:51.700 --> 01:15:54.700]  смотрите, все вершины левой доли, которые я посетил,
[01:15:54.700 --> 01:15:57.500]  они должны быть попарно различны. Потому что, скажем, не может
[01:15:57.500 --> 01:16:00.500]  быть такого, что я два раза попал в одну и ту же вершину
[01:16:00.500 --> 01:16:02.500]  левой доли. Потому что здесь у меня ограничение
[01:16:02.500 --> 01:16:05.500]  копасти единичка вот на этом ребре. Значит, я не могу
[01:16:05.500 --> 01:16:08.500]  сразу две единицы передать в одну и ту же вершину. Поэтому
[01:16:08.500 --> 01:16:11.500]  все вершины вот этих вот левых, ну точнее вершины
[01:16:11.500 --> 01:16:13.500]  всех этих путей, которые находятся в левой доле,
[01:16:13.500 --> 01:16:17.500]  они все разные. То же самое справа. Вот здесь, не знаю,
[01:16:17.500 --> 01:16:20.500]  там я еще что-нибудь нарисую. Все эти вершины должны
[01:16:20.500 --> 01:16:24.500]  быть различными. Потому что опять из них и из всех,
[01:16:24.500 --> 01:16:26.500]  если я пустил вершину, то единственный способ дойти
[01:16:26.500 --> 01:16:30.500]  до конца, это сразу провести ребро в T. Ну и опять же,
[01:16:30.500 --> 01:16:32.500]  не может быть такого, что, скажем, какие-нибудь, давайте
[01:16:32.500 --> 01:16:36.500]  тут нарисую. Два разных пути пришли в одну вершину
[01:16:36.500 --> 01:16:39.500]  правой доли, и потом оба стекли в T. Такого быть не
[01:16:39.500 --> 01:16:41.500]  может, потому что здесь не может течь две единички
[01:16:41.500 --> 01:16:45.500]  потока, здесь копасти единицы. Поэтому эти все вершины
[01:16:45.500 --> 01:16:49.500]  тоже различны. Значит, что мы получили? Мы получили,
[01:16:49.500 --> 01:16:52.500]  что у меня слева выбрано несколько вершин левой доли,
[01:16:52.500 --> 01:16:54.500]  справа выбрано столько же вершин правой доли, и они
[01:16:54.500 --> 01:16:56.500]  как-то друг с другом вот такое парасочетание образуют.
[01:16:56.500 --> 01:16:59.500]  То есть каждый слева соответствует кто-то справа, причем
[01:16:59.500 --> 01:17:02.500]  это соответственно описывается ребрами исходного графа.
[01:17:02.500 --> 01:17:06.500]  Вот это вот, это ребра исходного графа. Значит, по потоку
[01:17:06.500 --> 01:17:08.500]  мы сразу можем построить парасочетание. Просто те
[01:17:08.500 --> 01:17:11.500]  ребра, которые вот здесь вот насыщены, между долями,
[01:17:11.500 --> 01:17:15.500]  это и есть парасочетание. Тем самым мы показали, что
[01:17:15.500 --> 01:17:17.500]  из любого потока можно построить парасочетание
[01:17:17.500 --> 01:17:23.500]  той же величины. Ну теперь обратно. Если есть
[01:17:23.500 --> 01:17:25.500]  какое-то парасочетание, то как построить поток?
[01:17:25.500 --> 01:17:27.500]  Ну вот, собственно, ровно так. Если есть какое-то
[01:17:27.500 --> 01:17:33.500]  парасочетание, то давайте просто пустим по единичке
[01:17:33.500 --> 01:17:37.500]  потока в каждую насыщенную вершину левой доли, затем
[01:17:37.500 --> 01:17:40.500]  пропустим эти единички вдоль ребер парасочетания,
[01:17:40.500 --> 01:17:45.500]  и потом из всех этих опять сольем воду в Т. Каждую
[01:17:45.500 --> 01:17:48.500]  единичку потока мы просто сольем в Т. То есть наоборот,
[01:17:49.500 --> 01:17:54.500]  по каждому парасочетанию можно построить поток той
[01:17:54.500 --> 01:17:58.500]  же величины. А значит, максимальный поток равен
[01:17:58.500 --> 01:18:00.500]  максимальному парасочетанию.
[01:18:00.500 --> 01:18:18.500]  Значит, максимальный поток равен максимальному
[01:18:18.500 --> 01:18:28.500]  парасочетанию. Ровно максимальный.
[01:18:28.500 --> 01:18:32.500]  Окей. Значит, тогда давайте мы запустим алгоритм
[01:18:32.500 --> 01:18:36.500]  Деницы на нашей сети и поймем, за сколько он работает.
[01:18:36.500 --> 01:18:44.500]  Ну, для этого надо понять две вещи. Во-первых, что
[01:18:44.500 --> 01:18:47.500]  наша сеть единичная, значит, каждый раз работает
[01:18:47.500 --> 01:18:50.500]  за от Е. Этому вот уже писали. Ну, видно, что здесь все
[01:18:50.500 --> 01:18:53.500]  капасти единичные. Те, которые есть, они все единичные.
[01:18:53.500 --> 01:18:57.500]  Значит, каждый итерация алгоритма Деницы работает
[01:18:57.500 --> 01:19:05.500]  за от Е. Сеть единичная. Следовательно, итерация
[01:19:05.500 --> 01:19:12.500]  за от Е. Но при этом давайте еще посчитаем потенциал
[01:19:12.500 --> 01:19:15.500]  и оценим число итераций по теореме Корзанова.
[01:19:15.500 --> 01:19:19.500]  Как тут можно найти потенциал вот в этой сети?
[01:19:19.500 --> 01:19:28.500]  Ну, я утверждаю, что он просто равен от В. Потому что,
[01:19:28.500 --> 01:19:31.500]  смотрите, напоминаю, как работает потенциал. Мне
[01:19:31.500 --> 01:19:37.500]  нужно для каждой вершины отлично от С и Т взять минимум
[01:19:37.500 --> 01:19:41.500]  из входящей суммарной капасти и изходящей. Но понятно,
[01:19:41.500 --> 01:19:44.500]  что для этих вершин входящая капасти это единица. Ребра
[01:19:44.500 --> 01:19:50.500]  вне входящая только ребра из С в эту сама левой долю.
[01:19:50.500 --> 01:19:54.500]  А для этих чуваков, наоборот, и изходящая
[01:19:54.500 --> 01:19:57.500]  капасти единица. Потому что из них изходящаяauft,
[01:19:57.500 --> 01:20:00.500]  для каждой вершины сумма изходящих
[01:20:00.500 --> 01:20:03.500]  капастей – это единица. Соответственно, для каждой
[01:20:03.500 --> 01:20:07.500]  вершины, я беру минимум из C и С, я получаю для каждой
[01:20:07.500 --> 01:20:13.500]  вершина единицу на все потенциалы единицы, потому что для нее 3 на едице, а целое какое-то,
[01:20:13.500 --> 01:20:18.500]  поэтому минимум равен единице. Ну, не больше единицы, скажем так, потому что может быть вершина
[01:20:18.500 --> 01:20:24.500]  без вообще сходящих ревер, значит у нее потенциал будет нулевой, то есть не больше чем 1.
[01:20:24.500 --> 01:20:30.500]  Итого, для каждой вершины у меня потенциал не больше чем 1, тогда общий потенциал это максимум от v,
[01:20:30.500 --> 01:20:36.500]  не больше чем от v. Значит, итерацией, сюда перемещаюсь, число итераций
[01:20:40.500 --> 01:20:42.500]  по тереме Корзанова
[01:20:46.500 --> 01:20:48.500]  есть от корни из v,
[01:20:50.500 --> 01:20:54.500]  от корни из v. Да, итоговая символика получилась е корни из v.
[01:20:54.500 --> 01:21:00.500]  Е корни из v.
[01:21:04.500 --> 01:21:11.500]  Что даже еще лучше, чем было в Куне, потому что в Куне было, напомню, е умножить на v.
[01:21:12.500 --> 01:21:14.500]  А здесь е на корень из v.
[01:21:17.500 --> 01:21:19.500]  Вопросы?
[01:21:20.500 --> 01:21:25.500]  Да, это хороший вопрос. Что?
[01:21:25.500 --> 01:21:31.500]  Ну, в каком-то смысле да, еще, сейчас скажу.
[01:21:35.500 --> 01:21:39.500]  Вообще, вот это как бы оценка, ну и понятно, что это только теоретически оценка в Куне все равно,
[01:21:39.500 --> 01:21:44.500]  то есть там в каких-то графах, наверное, можно все равно оценить получше, чем тупое е умножить на v.
[01:21:45.500 --> 01:21:52.500]  Скажу так, когда-то в жизни я видел задачу, где кун заходил, а денец нет.
[01:21:52.500 --> 01:21:55.500]  Я не смог себе объяснить, к сожалению, почему это так.
[01:21:55.500 --> 01:21:59.500]  То есть, ну, с теоретической точки зрения, вот это должно заходить точно.
[01:21:59.500 --> 01:22:02.500]  Если кун заходит, то и денец должен.
[01:22:02.500 --> 01:22:05.500]  Но вот почему-то было не так. Возможно, я, конечно, где-то набогал.
[01:22:05.500 --> 01:22:10.500]  Но бывает, ну то есть повторюсь, что, во-первых, конечно, здесь константа меньше.
[01:22:11.500 --> 01:22:14.500]  Константа меньше.
[01:22:14.500 --> 01:22:21.500]  Во-вторых, на каких-то специфических графах вполне может быть вот этот чувак аффективнее, чем вот этот.
[01:22:23.500 --> 01:22:25.500]  Ну, собственно, все.
[01:22:27.500 --> 01:22:31.500]  Вот, тогда давайте на этом закончим. Новую тему уже нет смысла начинать.
[01:22:31.500 --> 01:22:33.500]  Всем спасибо за внимание.
