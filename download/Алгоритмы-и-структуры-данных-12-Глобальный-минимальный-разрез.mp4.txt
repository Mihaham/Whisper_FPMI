[00:00.000 --> 00:15.600]  Так, ну что, здравствуйте. Давайте начинать. Я продолжу говорить про потоки. Первое, что мы
[00:15.600 --> 00:29.760]  сделаем, это найдем так называемый глобальный минимальный разрез с помощью алгоритма Шторвагнера.
[00:29.760 --> 00:55.360]  Мы имеем искать минимальный разрез как бы между двумя вершинами. Есть граф,
[00:55.360 --> 01:00.120]  фиксированная с маленькой и t маленькая. И задача там была такая, разбить все множество вершин на два
[01:00.120 --> 01:07.720]  куска. Так что s в одном куске, t в другом куске. И при этом нужно было минимизировать суммарную
[01:07.720 --> 01:16.600]  capacity ребер слева направо между множествами. Здесь постановка похожая, только у нас не
[01:16.600 --> 01:21.360]  фиксировано вот эти с маленькой и t маленькая. У нас просто есть какой-то большой граф, и нам
[01:21.360 --> 01:26.240]  нужно в нем найти минимальный разрез в том смысле, что просто нужно как-то поделить все множество
[01:26.240 --> 01:36.880]  вершин на два куска, s и t, так чтобы минимизировать суммарную capacity всех ребер из s в t. Вот такая
[01:36.880 --> 01:40.480]  задача. То есть мы отказываемся от ограничений на s маленькой и t маленькой, что они должны
[01:40.480 --> 01:44.240]  лежать в разных кусках. Мы просто говорим, что нужно просто найти какое-нибудь такое разбиение,
[01:44.240 --> 01:58.480]  минимизирующее величину такого разреза. Поэтому он глобальный, то есть мы среди всех разрезов
[01:58.480 --> 02:05.480]  выбираем минимальный по величине. Но давайте формализуем. Во-первых, давайте я для лопаста скажу,
[02:05.480 --> 02:15.720]  что уже у меня неориентированный граф. Так же, как всегда, у меня есть какая-то не отрицательная
[02:15.720 --> 02:31.680]  функция capacity из ребер в не отрицательное целое число. И определение, что такое глобальный
[02:31.680 --> 02:48.520]  минимальный разрез. Это такая пара множеств s и t, что они, во-первых, так же как раньше в
[02:48.520 --> 02:52.480]  дизюктом объединении давали бы все множество вершин, то есть они не пересекаются и суммарно
[02:52.480 --> 03:02.320]  покрывают все. Ну и при этом, наверное, нужно сказать, что они не пустые, потому что если
[03:02.320 --> 03:07.280]  позволить кому-то из них быть пустым, тогда разрез нулевой, просто никакие ребра не пересекаются,
[03:07.280 --> 03:12.280]  это выраженный неинтересный случай. Но если сказать, что оба не пустые, это уже интересно.
[03:12.280 --> 03:22.960]  Дальше, как обычно, величина разреза c с t это сумма capacity всех ребер с с в т, сумма по у с с в с т,
[03:22.960 --> 03:30.840]  с ув. Ну и соответственно, нужно найти такой разрез, на котором достигается минимум вот
[03:30.840 --> 03:44.120]  этой вот штуки. Вот эта штука минимальная. Так, такое определение. Понятно? Хорошо,
[03:44.120 --> 03:52.440]  ну, наверное, если мы умеем искать минимальные разрезы, то глобальный минимальный разрез хоть
[03:52.440 --> 03:59.720]  за какую-нибудь символику мы точно найти сможем. Как, например, можно было бы в тупую его найти?
[03:59.720 --> 04:15.240]  Да, перебрать что? Ну, разделение их, наверное, 2 в n. Всего суммарно вот этих вот разбиений
[04:15.240 --> 04:20.520]  всех вершин на 2 множества, их 2 в степени n, это многовато. Можно как-нибудь получше, хотя бы
[04:20.520 --> 04:29.520]  запыленном какой-нибудь. Ну да, мы же умеем искать, если у меня добавляется допограничение,
[04:29.520 --> 04:34.120]  что s маленькая вот здесь вот, а t маленькая здесь вот, и мы умеем находить mincut. Мы знаем,
[04:34.120 --> 04:39.920]  что mincut связан с maxflow из s в t. Если мы находим одно, то мы находим другое автоматически.
[04:39.920 --> 04:44.480]  По теориям Форда Фалкерса у нас есть двойственность между максимальным потоком и минимальным разрезом.
[04:44.480 --> 04:48.920]  Вот, поэтому можно было бы, скажем, просто перебрать все пары s маленькая и t маленькая,
[04:48.920 --> 04:57.560]  найти максимальный поток между ними, и после этого выбрать минимальный среди найденных
[04:57.560 --> 05:03.720]  максимальных потоков. Понятно? Ну, просто потому что если s большой и t большой не пустые,
[05:03.720 --> 05:07.680]  то какие-то две вот хотя бы по одной вершинке в них должно быть, значит, их можно перебрать.
[05:07.680 --> 05:14.360]  Вот, значит, это было бы, грубо говоря, что-то типа квадрат умножить на время работы потока.
[05:14.360 --> 05:17.800]  Если я все пары перебираю, потом умножаю на поток, будет квадрат на поток. В смысле,
[05:17.800 --> 05:25.280]  в квадрат умножен поток. Ну, конечно, да, можно сказать, что, скажем, вот вершина номер один,
[05:25.280 --> 05:30.480]  ее можно застолбить, присвоить ее обязательно первому множеству s большое. Потому что граф не
[05:30.480 --> 05:34.960]  ориентированный, да, от того что я перекину единичку, ну, от того что я поменяю местами s и t,
[05:34.960 --> 05:39.640]  у меня capacity, величина разреза не увеличится, поэтому можно считать, что единичка всегда в s
[05:39.640 --> 05:45.320]  большом. Ну и тогда можно просто перебирать, можно s фиксировать равным единице, а t перебирать
[05:45.320 --> 05:54.000]  в каждой всех вершин. И тогда будет время работы n, уже умножен на поток. Вот, значит, ну и здесь
[05:54.000 --> 05:58.840]  можно было бы тоже немножко схитрить, с этой точки зрения это бесполезно, но в нашем алгоритме
[05:58.840 --> 06:05.680]  это понадобится. Значит, смотрите, вот пусть давайте я в самом общем виде скажу, что я нашел какой-то
[06:05.680 --> 06:12.960]  минимальный разрез между s и t. Пусть я нашел минимальный разрез. Понятно тогда, что либо это
[06:12.960 --> 06:20.800]  глобальный минимальный разрез, то есть либо это то, что я ищу, либо мое предположение о том,
[06:20.800 --> 06:26.640]  что s и t находятся в разных долях неверно, то есть вот фиксирование их по разной
[06:26.640 --> 06:33.280]  стороны от разреза было неоптимально. Значит, у меня всего два варианта, либо s и t в разных долях,
[06:33.280 --> 06:41.480]  либо в одной. Вот если в разных, я уже нашел mincut, а если в одной, то значит можно их как бы склеить.
[06:41.480 --> 06:48.480]  Вот если я считаю, что их было неоптимально разделять в разрезе, то значит их можно склеить.
[06:48.480 --> 06:53.440]  Тогда можно было бы сделать буквально следующее. Давайте вот эти две вершинки просто объедини,
[06:53.440 --> 06:58.000]  мы скажем, что это одна большая вершина. Ну как я это сделаю? Ну вот просто если была
[06:58.000 --> 07:02.680]  s маленькая, t маленькая, тут были какие-то ребра, тут были какие-то ребра, давайте я просто
[07:02.680 --> 07:08.720]  эти две вершины склею и ребра объединю. Да, ну формально, значит, если у меня было какое-то ребро,
[07:08.720 --> 07:15.000]  значит, если ребра у них, если были какие-то ребра ведущие в одну и ту же вершинку, скажем,
[07:15.000 --> 07:21.840]  u, и здесь было написано x, здесь y, тогда после склейки у меня будет просто одно ребро веса x
[07:21.840 --> 07:28.920]  плюс y. Ну то есть я как бы объединяю и суммирую capacity в том случае, если ребра у меня склеились.
[07:28.920 --> 07:36.560]  То есть вот эти два ребра схлопнутся и станут одним большим ребром с capacity x плюс y. Ну и тогда
[07:36.560 --> 07:41.440]  можно было бы сказать следующее, окей, значит, если s и t не в разных долях, то их можно склеить,
[07:41.440 --> 07:50.320]  и дальше уже решают задачу на меньшем графе. То есть уже задача на графе на n-1 вершинке,
[07:50.320 --> 07:57.320]  потому что я одну удалил. Понятная идея? Вот, значит, еще раз, да, либо я точно знаю,
[07:57.320 --> 08:02.040]  что они по разные стороны от резреза, тогда поток между ними, это глобальный менткат,
[08:02.040 --> 08:06.480]  ну потому что можно было бы фиксировать, я смаленькая здесь, ты маленькая здесь,
[08:06.480 --> 08:12.120]  либо же они должны быть в одной доле, ну тогда их могу склеить, потому что если они в одной доле,
[08:12.120 --> 08:16.480]  то том �ет не изменится от того, что я склею, то есть да, от того,
[08:16.480 --> 08:20.000]  что они в одной доле, у меня все равно все вот эти вот ребра, они либо одновременно не
[08:20.000 --> 08:24.020]  перецекают разрез, то есть либо они вот такие, либо они вот такие, тогда можно склеить это все в одно
[08:24.020 --> 08:33.300]  толстое ребро. Вот. Вот эту идею мы будем использовать. Хорошо. Ну, собственно, вот такие вот
[08:33.300 --> 08:37.620]  потоки в алгоритме, их, конечно, можно реализовать, но они будут не самыми оптимальными. Вот можно
[08:37.620 --> 08:48.020]  получше сделать алгоритм Шторвагнера. Как работает алгоритм? Он устроен следующим образом. Значит,
[08:48.020 --> 09:01.420]  он строит некую перестановку вершин. А1, А2, А3 и так далее, АН. Да, это перестановка вершин.
[09:01.420 --> 09:18.220]  Значит, как он ее строит? Ну, А1 он выбирает произвольный. Неважно. Вот. А дальше АИТ каждый
[09:18.220 --> 09:24.140]  раз выбирается так, чтобы суммарная капасити всех ребер между АИТ и всеми предыдущими было
[09:24.140 --> 09:32.220]  как можно больше. То есть вот мне нужно взять такую АИ, чтобы сумма капасити всех ребер между АИ и
[09:32.220 --> 09:38.020]  всеми предыдущими, то есть А1, А2 и так далее, АИ-1, чтобы суммарная капасити была как можно больше.
[09:38.020 --> 09:47.340]  Вот я выбираю АИ таким образом. Значит, как я это формализую? Ну, давайте я, во-первых, обозначу,
[09:47.340 --> 09:55.900]  чтобы не очень громоздкая была запись. Я, во-первых, обозначу, что для произвольных подмножеств,
[09:55.900 --> 10:11.940]  множество вершин, величина, давайте скажем, просто ЦАТБ, это сумма, как обычно, ЦАБ. То есть это как
[10:11.940 --> 10:16.740]  величина разреза, только величина пары, любой пары множеств. Они обязательно А и Б образуют
[10:16.740 --> 10:23.340]  разрез, просто любая пара множеств. Тогда Ц это сумма капасити между ними. Вот, ну еще давайте я
[10:23.340 --> 10:34.660]  буду считать, что АИТ, АИ-1 это множество вершин с первого по Иту. Вот, тогда в качестве АИ я
[10:34.660 --> 10:57.660]  выбираю такую вершину В, для которой вот такая вот вещь максимальна. Будьте здоровы. Что написано,
[10:57.660 --> 11:02.660]  да? Арг максимум, то есть выбираю ту вершину, на которой достигается максимум, вот этой величины,
[11:02.660 --> 11:09.940]  значит, где В у меня пробегает по всем вершинам, кроме уже набранных. АИ-1 это набранные до этого
[11:09.940 --> 11:15.860]  момента, 1, 2 и так далее, АИ-1. Значит, В любая, кроме вот этих. Ну а здесь написано в точности вот
[11:15.860 --> 11:22.740]  то, что я здесь словами проговорил. Суммарный вес всех ребер между вершинкой В и всеми уже набранными.
[11:22.740 --> 11:34.100]  Вот. Ну вот давайте таким странным образом определим нашу последовательность. То есть я
[11:34.100 --> 11:40.420]  сначала выбираю А1 произвольно, а каждое следующее уже определяю через предыдущее. Ну здесь,
[11:40.420 --> 11:43.980]  возможно, некая неоднозначность, потому что, возможно, на нескольких вершинах достигается
[11:43.980 --> 11:48.660]  максимум. Ну не важно, выберем любую из них. То есть если максимум в нескольких точках достигается,
[11:48.660 --> 11:59.860]  выберем любую из вершин. Вот. Ну тогда, вот если я построил такую перестановку, тогда оказывается,
[11:59.860 --> 12:16.300]  что разрез, найденный на самом последнем шаге, то есть разрез между последней вершиной и всеми,
[12:16.380 --> 12:29.020]  кроме нее, это на самом деле минимальный разрез между двумя последними вершинами.
[12:39.020 --> 12:40.860]  Вот такой забавный факт. Мы его сейчас докажем.
[12:40.860 --> 12:49.100]  Вот. Ну что здесь утверждается? Смотрите, мы как-то набираем вершинки, мы их как-то
[12:49.100 --> 12:55.620]  занумировали, А1, А2 и так далее, Аn. Вот давайте посмотрим на две последние. Аn и Аn-1. Вот утверждается,
[12:55.620 --> 13:03.740]  что когда мы выбирали Аn и смотрели вот эту ситуацию, для i равно n я посмотрю, тогда у меня
[13:03.740 --> 13:09.620]  здесь находится Аn, а здесь все остальные. Вот оказывается, что вот этот разрез, когда Аn отдельно,
[13:09.620 --> 13:13.460]  а все остальные в другой доле, вот этот разрез оказывается минимальный, если бы я искал
[13:13.460 --> 13:19.100]  минимальный разрез между Аn и Аn-1. Между этими двумя вершинками мин разрез, это в точности вот это вот.
[13:19.100 --> 13:30.100]  Вот. Ну если в это поверить, а мы докажем чуть позже, значит, если в это поверить,
[13:30.100 --> 13:34.140]  тогда что получается, смотрите. Это значит, что если я построил такую перестановку,
[13:34.140 --> 13:40.860]  то мне известны две вершины, между которыми я знаю минимальный разрез. То есть перестановка
[13:40.860 --> 13:44.700]  построена, значит, я знаю, что между двумя вот этими конкретными вершинами я знаю
[13:44.700 --> 13:49.420]  мин разрез. А значит, можно использовать вот ту идею. То есть я нашел какой-то мин разрез,
[13:49.420 --> 13:54.260]  либо он уже оптимальный, можно завершиться и печатать ответ, либо их можно склеить и перейти
[13:54.260 --> 13:59.860]  графу на 0-1 вершине, решать там рекурсивно. Соответственно, алгоритм, ну там не знаю, ans
[13:59.860 --> 14:12.340]  равно минимум из ans и вот того, что мы, того, что я здесь посчитал, да. Вот. Затем, значит, склеить
[14:12.340 --> 14:26.500]  an-1 и an, объединив ребра, ну и рекурсивно запуститься на вот этом графе с 1 вершиной.
[14:26.500 --> 14:45.940]  Рекурсивно запуститься на графе с 1 вершиной. Вот. Ну и так делать пока, скажем, в графе не
[14:45.940 --> 14:50.340]  останется две вершины. Если в графе всего две вершины, то, наверное, понятно, как выглядит мин
[14:50.340 --> 14:56.060]  кат, да, минимальный разрез. Ну, это просто вот такое разбиение. Если их всего две, то никак по
[14:56.060 --> 15:01.460]  другому их разбить нельзя, значит, величина разреза будет просто равна стоимости вот этого ребра.
[15:01.460 --> 15:16.220]  Ну вот, смотрите, вот давайте в этой картинке я скажу i равно n. Это что значит? Значит, an, ну как бы
[15:16.220 --> 15:23.980]  вот эта вот величина, которую я мерю, это суммарный вес всех ребер между an и всеми остальными. Вот.
[15:23.980 --> 15:27.260]  Вот утверждается, что вот в этот момент времени как раз, когда здесь находится одна по себе
[15:27.260 --> 15:31.980]  an, а здесь все остальные, вот этот разрез тривиальный, когда вот эта сама по себе, а все остальные
[15:31.980 --> 15:37.380]  отдельно, вот этот разрез будет минимальным между двумя последними. То есть его величина равна
[15:37.380 --> 15:50.380]  минимальным возможному разрезу между этими двумя. Ну, на две части, да. Нет, ну смотрите,
[15:50.380 --> 15:58.860]  у меня картинка будет такая просто. Вот одна доля, вот другая. an и an-1 в разных долях,
[15:58.860 --> 16:09.220]  все вершины разбиты, величина разреза равна сумме вот этих вот ребер просто. У меня все вершины
[16:09.220 --> 16:13.860]  уже распределены, у меня всего n вершины в графе, я их просто как-то занумеровал. Сначала a1,
[16:13.860 --> 16:19.780]  потом a2, потом a3 и так далее. На n-ом шаге я все вершины уже исчерпал, поэтому an будет одна
[16:19.780 --> 16:32.340]  сама по себе, а здесь все остальные. Так, еще вопросы. Хорошо, ну давайте тогда сначала симпточку
[16:32.340 --> 16:49.020]  посчитаем. Кажется, здесь что-то будет порядка n куба. Ну почему? У меня глубина рекурсии будет n,
[16:49.020 --> 16:53.500]  потому что на каждом шаге я склеиваю две вершинки, и так делаю n раз, получается,
[16:53.500 --> 16:57.780]  суммарно. Вот, а дальше мне нужно посчитать, за какое время я вот эту перестановку нахожу.
[16:57.780 --> 17:07.420]  Ну вот за квадрат, видимо. Как можно эту перестановку за квадрат найти?
[17:07.420 --> 17:22.620]  Ну вот явно считать, наверное, не получится, потому что вот эта вот штука, если вот это
[17:22.620 --> 17:27.460]  каждый раз за линию считать, тогда максимум находится за квадрат, не нужно это n раз сделать.
[17:27.460 --> 17:41.460]  Ну можно оптимизировать, наверное. Ничего не напоминает, кстати, вот эту формулу,
[17:41.460 --> 17:55.500]  как мы находим очередную вершину. Ну и ладно. Это похоже на dx или на prima, на самом деле,
[17:55.500 --> 18:03.820]  потому что, ну чего, как в prima, например, мы работали, мы каждый раз выбирали вершину,
[18:03.820 --> 18:10.420]  из которой ребро во все предыдущие минимально возможно. Среди всех ребер из текущей во все
[18:10.420 --> 18:14.860]  предыдущие, вот я минимальное ребро выбираю, но должно быть как можно меньше. Тут что-то похоже,
[18:14.860 --> 18:19.260]  только тут не минимум, а сумма, и максимум берется. То есть я рассматриваю все ребра во все уже
[18:19.260 --> 18:24.580]  рассмотренные вершинки, суммирую их и нахожу такулы, для которой это максимально. Ну можно
[18:24.580 --> 18:30.540]  сделать так же, как в prima. Можно просто для каждой вершины v хранить сумму этих ребер в уже полученные,
[18:30.540 --> 18:36.100]  доставать максимум, ну и обновлять можно тоже легко, потому что когда я очередную вершинку a и
[18:36.100 --> 18:42.420]  t добавляю вот сюда, то есть добавляю в множество уже изученных, у меня понятно, как изменяются все
[18:42.420 --> 18:52.780]  величины для остальных вершин. Давайте, как обычно, считать, что d от v это сумма, просто скажу,
[18:52.780 --> 19:03.740]  c между v и a текущим каким-то, тогда когда у меня очередная вершинка, скажем, a и плюс один
[19:03.740 --> 19:09.580]  добавляется вот сюда, когда я расширяю мое текущее множество a и t на a плюс первое,
[19:09.580 --> 19:14.180]  тогда мне нужно просто рассмотреть все ребра, исходящие из a плюс первого, и до вот этих всех
[19:14.180 --> 19:19.180]  вершин увеличить d, потому что добавились вот такие ребра, значит для этих вершин изменилось d.
[19:19.180 --> 19:25.660]  Ну то есть если я просто для каждой вершины храню вот эту величину, текущую величину,
[19:25.660 --> 19:30.700]  разреза между ней и всеми уже рассмотренными, тогда ее легко динамически поддерживать,
[19:30.700 --> 19:33.980]  просто добавляя очередную вершинку, ну и находить максимум можно за линию,
[19:33.980 --> 19:48.860]  просто. Вот, тогда как раз будет квадрат суммарно. Так, надо повторить? А? Надо? Шок. Хорошо,
[19:48.860 --> 19:56.940]  значит еще раз давайте я перепишу. Да, вот пусть d, v это вот такая вот вещь. Я для каждой вершинки,
[19:56.940 --> 20:03.060]  значит a и это у меня какой-то внешний глобальный счетчик, который вот a1, a2, a3 и так далее a и. Давайте
[20:03.060 --> 20:09.660]  пусть для каждой вершинки у меня хранится вот это вот. Тогда, чтобы найти на следующем и плюс первом
[20:09.660 --> 20:16.100]  шаге вот это argmaximum, мне нужно просто взять вершину v с максимальным d от v. Это идет за линию.
[20:16.100 --> 20:22.020]  Соответственно вот этот шаг у меня будет работать за o от m. Просто нужно пройтись по всем
[20:22.020 --> 20:29.900]  неиспользованным вершинам и взять максимальное значение d от v. Дальше. Дальше я v добавляю в аи,
[20:29.900 --> 20:35.300]  в аи плюс первое точнее, у меня появляется новая рассмотренная вершина. И значит вот если раньше у
[20:35.300 --> 20:42.220]  меня было аи вот таким, то теперь у меня здесь появляется одна новая вершинка, я перехожу к новому
[20:42.220 --> 20:48.620]  мнению аи плюс первое. Значит тогда мне нужно пересчитать все вот эти d с учетом того, что
[20:48.620 --> 20:53.940]  вот эта мнение расширилась за счет добавления новой вершинки. Ну для этого я просто рассматриваю все
[20:53.940 --> 21:03.460]  ребра, исходящие из вот этой вот вершинки, и для всех концов всех этих ребер увеличиваю d. Ну а если они
[21:03.460 --> 21:11.700]  лежат, то их игнорирую. Ну это неважно, смотрите, у меня может просто для каждой вершины хранится
[21:11.700 --> 21:17.900]  булистский флаг, взял ее в перестановку или нет. Если я ее взял, то здесь в argmaximum она не учитывается.
[21:17.900 --> 21:36.380]  Потому что смотрите, у меня перестановка за квадрат находится. Для каждого i я за линию
[21:36.380 --> 21:42.860]  нахожу argmaximum, за линию обновляю дешки для всех соседей. Итого для каждого i я за линию нахожу
[21:42.860 --> 21:48.900]  аито. Так делаю n раз, потому что у меня перестановка длины n, значит вот эта часть работает за квадрат.
[21:48.900 --> 21:57.260]  И так я делаю n раз, потому что у меня рекурсивные спуски в графе на все меньшем числе вершин. Да,
[21:57.260 --> 22:06.980]  да, да, перестановка за квадрат и на одну вершину уменьшаем. Итак, n раз. Так, хорошо. Вот, отлично.
[22:06.980 --> 22:11.020]  Теперь давайте доказывать вот это утверждение. Если мы это докажем, то алгоритм получается уже
[22:11.020 --> 22:19.300]  закончился, потому что мы знаем вот это, значит мы знаем, что он будет корректным. Так, хорошо. Ну,
[22:19.300 --> 22:28.140]  для этого мне нужно, видимо, будет сначала следующее утверждение. А, не так. Не так.
[22:28.140 --> 22:43.700]  Я сначала скажу следующее. Пусть s большое, t большое – это какой-то разрез между двумя последними вершинами.
[22:43.700 --> 22:56.900]  Значит, я хочу показать, что его величина будет больше равна, чем то, что я уже нашел.
[22:56.900 --> 23:05.980]  Да, я хочу показать, что это минимальное, то есть что это меньше, чем любое другое. Это
[23:05.980 --> 23:22.300]  моя цель. Давайте фиксирую конкретный разрез st. Так вот, утверждение. Назовем аи активной,
[23:22.300 --> 23:35.580]  если аи и аи-1 лежат в разных множествах s и t, то есть одно в s, другое в t. Ну, давайте вот так
[23:35.580 --> 23:50.340]  напишу. Значит, если аи-1 лежит в s, а it в t, или наоборот, а it в s, аi-1 в t. Активная – это если она
[23:50.340 --> 24:06.260]  и предыдущая в разных долях. Одна в s, другая в t. Так вот, тогда утверждается, что для активной
[24:06.260 --> 24:32.660]  вершинки а верно будет вот такое неравенство. Да, для активной, для активной аи-t. Если аи-t активна.
[24:36.980 --> 24:42.860]  Пока давайте просто формально это воспринимать. Да, вот один разрез, вот другой разрез утверждается,
[24:42.860 --> 24:50.460]  что эта штука не больше, чем вот это. Доказательства. Индукция по активным вершинам.
[24:50.460 --> 25:04.220]  Давайте рассмотрим первую активную вершину. Вот а1, а2, а3 и так далее. Давайте рассмотрим
[25:04.220 --> 25:11.340]  первую активную. Что значит первая активная? Это такая, что все предыдущие лежат в другой доле,
[25:11.340 --> 25:16.580]  а вот она в какой-то новый. То есть это что-то такое. Вот пусть ажитое – это первая активная. Да,
[25:16.580 --> 25:25.900]  давайте база индукции. Ажитое – это первая активная. Что это значит? Это значит, скажем,
[25:25.900 --> 25:38.140]  что она лежит в t, а все остальные предыдущие лежат в s. Ну или наоборот. Это в s, а эти в t.
[25:38.140 --> 25:45.660]  Неважно. Первая активная. Все предыдущие были в одной доле, и вот впервые мы переключились
[25:45.660 --> 25:52.660]  с одной долей на другую, когда переходим к ажи. Так, ну тогда здесь вроде тривиальное
[25:52.660 --> 25:58.020]  равенство достигается, потому что что вот здесь написано? Здесь написано суммарный вес всех
[25:58.020 --> 26:04.620]  рёбер между ажи и всеми предыдущими. Да, это вот то, что написано здесь. А справа что написано?
[26:04.620 --> 26:10.420]  Справа написано s пересечь с ажи, то есть как раз вот эти вершинки. t пересечь с ажи – это
[26:10.420 --> 26:14.780]  будет как раз эта одна вершина. Поэтому здесь написано просто сумму всех вот этих рёбер,
[26:14.780 --> 26:18.640]  а здесь написано величина вот такого разреза. Ну понятно, что поскольку других рёбер нет,
[26:18.640 --> 26:26.200]  то она же в точности просто равна сумме всех таких ребер. Понятно? Ну вот, база тривиальна,
[26:26.200 --> 26:45.760]  то есть даже равенство получается. Даже равенство. Чудно. Переход. Пусть аута и аветая
[26:45.760 --> 26:56.680]  это две последовательно активные вершины. Две последовательно активные вершины.
[26:56.680 --> 27:09.160]  Что это значит? Значит, ау активно, то есть ау и ау-1 в разных долях. Затем ау-1, ау-2 и так далее,
[27:09.160 --> 27:15.080]  вплоть до ав-1 будут там же, где ау, потому что они не активны, то есть доля не сменяется. А вот
[27:15.080 --> 27:20.680]  ав уже сменяется, ав в другой доле. Ну поэтому я давайте вот такую картинку нарисую, большую.
[27:20.680 --> 27:35.040]  Значит, это у меня будет s пересечь с ав, это t пересечь с ав. Вот эта маленькая, это s пересечь
[27:35.040 --> 27:42.760]  с ау и t пересечь с ау. Ну тогда я могу нарисовать примерно так, что поскольку у меня все между
[27:42.800 --> 27:50.160]  ними не активные, с у-1 до в-1, все между ними не активные, значит они там же, где у. Если у у меня,
[27:50.160 --> 27:58.960]  скажем, вот здесь, то у меня все остальные вот здесь, ау-1 и так далее, ав-1, они все в той же доле,
[27:58.960 --> 28:15.560]  что и у. Ну а ав где-то вот здесь. Понятно? Ну либо опять же там, возможно, s и t поменены местами,
[28:15.560 --> 28:18.400]  но это неважно, поскольку у меня граф не ориентированный, s и t у меня можно всегда
[28:18.400 --> 28:23.400]  менять местами, и я могу считать, не умоляя общности, что ау-t лежит ровно вот здесь, в s.
[28:23.400 --> 28:39.920]  Ну вот, хорошо, тогда давайте что-нибудь писать. Я хочу оценить сверху вот такую вот величину.
[28:39.920 --> 28:51.840]  Сначала давайте я ее распишу следующим образом. Я разобью вот это множество на 2 не пересекающих
[28:51.840 --> 29:11.600]  куска, будет ау-1 и, соответственно, все остальное. Ну могу так сделать, потому что c по определению
[29:11.600 --> 29:16.000]  линейная функция, если я вот это множество разбиваю на 2 куска, ау-1 и все остальное,
[29:16.000 --> 29:25.560]  тогда c просто суммут этих вот. Дальше я буду каждый этих слагаемых по отдельности оценивать.
[29:25.560 --> 29:45.720]  Первое, я могу оценить сверху вот такой вот вещью. Почему? Я поменял v на u вот здесь.
[29:45.720 --> 30:07.320]  Почему нерависть выполняется? Да, по определению. Потому что ау- это как раз в момент рассмотрения
[30:07.320 --> 30:14.360]  вот этого множества, ау- это вершина с максимальным вот этим значением, а v когда-то в более позднем
[30:14.360 --> 30:19.560]  моменте времени выбрано. У нас сначала ау, потом аv, значит для ау достигается максимально возможное
[30:19.560 --> 30:25.520]  значение вот этой величины. Значена, в частности, больше, чем вот это. Ну давайте подпишу в силу
[30:25.520 --> 30:39.840]  выбора ау. Так, хорошо. Это простой момент был. Второй момент. Мне нужно доказать, чтобы неравенство
[30:39.840 --> 30:44.520]  сошлось, чтобы вот это было не больше, чем вот это. Мне хотелось бы, чтобы здесь было написано
[30:44.520 --> 30:59.120]  следующее. Не больше, чем c, а в это. Нет, нет, нет. А, надо это продолжить. Да, сейчас, надо еще продолжить
[30:59.120 --> 31:04.560]  и вот здесь по индукции договорить. Надо, я поторопился. Значит, смотрите, можно вот, поскольку ау-
[31:04.560 --> 31:11.920]  ты активна, то я могу к ней применить предпочтение индукции и записать, что c, ау и ау-1 не больше,
[31:11.920 --> 31:23.560]  чем cs пересечь с ау-1. Нет, просто ау и t пересечь с ау. Ну а это просто предпочтение индукции.
[31:23.560 --> 31:34.040]  Так, правда? Правда. Поскольку она предыдущая активна, для нее можно применять предпочтение индукции,
[31:34.040 --> 31:45.880]  ау. Здесь ау и здесь и здесь. Так, вот, хорошо. Первое слагаемое оценили, теперь я хочу оценить
[31:45.880 --> 31:50.280]  второе. Чтобы неравенство у меня сошлось, мне нужно, чтобы здесь было написано не больше, чем.
[31:50.280 --> 32:08.120]  Минус то, что написано здесь. Вот это я хочу.
[32:20.280 --> 32:28.920]  Потому что, если это будет верно, то у меня как раз после сложения вот эти штуки сократятся,
[32:28.920 --> 32:33.480]  и останется, что вот эта c-шка не больше, чем вот эта c-шка, а это ровно то, что мне
[32:33.480 --> 32:45.600]  нужно для индукции. А это ровно вот это утверждение. Так, хорошо. Почему вот это верно? Давайте
[32:45.920 --> 32:53.120]  перепишу более удобно. Давайте я вот это перенесу сюда. Я хочу доказать следующее. Хочу, что c
[32:53.120 --> 33:08.040]  аv и аv-1 без ау-1, вот это я сюда переписал, плюс то, что написано здесь с минусом, пересечь с ау,
[33:08.040 --> 33:30.880]  меньше либо равно, чем вот это вот. Вот это я хочу доказать. Ну вот, а это очевидно,
[33:30.880 --> 33:36.480]  если на картинку посмотреть просто. Давайте я все вот эти вот вещи здесь нарисую. Вот первое,
[33:36.880 --> 33:45.920]  это c между аv и множеством аv-1 без ау-1. То есть первая слагаемая, это на самом деле суммарный
[33:45.920 --> 33:55.760]  вес всех вот этих вот ребер. Между аv и всеми с v-1 по утру. Это суммарный вес вот этих вот ребер.
[33:55.760 --> 34:02.200]  Это первая слагаемая. Вторая слагаемая, это суммарная величина вот этого разразия между вот этими
[34:02.200 --> 34:07.480]  долями. То есть суммарная стоимость всех вот этих ребер между вот этими маленькими облачками.
[34:07.480 --> 34:16.360]  А справа написана суммарная величина вот этого общего разреза. Ну понятно, что одно не больше
[34:16.360 --> 34:22.920]  чем второе. То есть слева до знака неравенства я посчитал вот эти вот ребра по одному разу и
[34:22.920 --> 34:28.160]  вот эти ребра по одному разу. А справа у меня вообще все ребра между долями посчитаны по
[34:28.160 --> 34:34.600]  одному разу. То есть в частности вот здесь вот еще вот эта больше чем вот правая часть неравенства,
[34:34.600 --> 34:38.440]  больше чем левая, по крайней мере вот на все вот эти вот ребра. Потому что у меня же такие
[34:38.440 --> 34:43.280]  ребра еще есть в графе. Вот они все не учитываются слева, а справа учитываются. Поэтому правая только
[34:43.280 --> 34:47.960]  больше чем левая. Ну опять, если все ребра не отрицательны, тогда у меня правая только может
[34:47.960 --> 35:13.000]  быть больше. Ну и тогда если я вот это доказал, то я вот это доказал. А значит после сложения у
[35:13.000 --> 35:16.920]  меня вот эти вот товарищи сокращаются и остается, что вот это не больше чем вот это,
[35:16.920 --> 35:29.200]  что и нужно для индукции. Так, нормально? Кайф. Ну все, значит уже не доказали, а теперь можно
[35:29.200 --> 35:39.400]  использовать. Зачем оно нам было нужно? Зачем оно нам нужно? Ну оно нужно нам для следующего. Можно
[35:39.400 --> 35:49.300]  заметить, что аэнная всегда активна, потому что я знаю, что s и t это разрез между вот этими
[35:49.300 --> 35:55.160]  двумя. Значит аэнная в одной доле, аэносовин в другой. Ну по определению разреза. Они в разных
[35:55.160 --> 36:02.160]  долях. Значит аэнная точно активна, значит для нее можно написать неравенство. Значит для нее можно
[36:02.160 --> 36:12.520]  написать неравенство из утверждения. Не больше чем. Но вот здесь, когда я пересекаю s и t с аэнным,
[36:12.520 --> 36:16.920]  я пересекаю просто со всеми вершинами, значит я ничего не делаю. Поэтому здесь можно пересечения
[36:16.920 --> 36:28.600]  отбросить и просто написать c, s, t по утверждению. А это то, что нужно. Это ровно то, что нужно.
[36:28.600 --> 36:39.320]  Потому что у меня s, t разрез между двумя вот этими вот вершинами, значит они точно в разных
[36:39.320 --> 36:48.840]  долях s и t. А активная это ровно это и значит, что она и предыдущая в разных долях. Все. И раз она
[36:48.840 --> 36:53.640]  активная, то для нее выполняется утверждение. А значит верен факт про то, что, ну по факту вот это
[36:53.640 --> 36:59.600]  вот, как раз вот это и значит, что вот этот вот тупой разрез, где все вершины кроме аэнной в
[36:59.600 --> 37:05.920]  одной доле, аэнная в другой, здесь все кроме нее, вот это самый оптимальный разрез, разделяющий
[37:05.920 --> 37:22.440]  вот эту и вот эту вершину. Так, вроде все тогда. Так, вопросы можете? Ну хорошо, тогда давайте
[37:22.440 --> 37:23.720]  перерывчик и потом следующая тема.
[37:52.440 --> 38:00.800]  Это то, сколько стоит каждая единица потока. Если я передаю по этому каналу столько, ну там,
[38:00.800 --> 38:06.240]  одну личку водички, тогда эта передача стоит по ступе. Если две лички, два коста, если три
[38:06.240 --> 38:15.000]  лички, то три коста каждая. А то есть, если я пускаю без потока, тогда у меня там штраф, за это единица будет
[38:15.000 --> 38:31.920]  без мостов. Вот. Ну и задача следующая. Давайте возьмем кост ка холл. Это найти поток
[38:31.920 --> 38:37.320]  уничтоженной карты, минимально возможной стоимости. Ну где стоимость, это сумма штрафов по всем
[38:37.320 --> 39:07.320]  городам. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот. Ну вот
[39:07.320 --> 39:09.320]  oy
[39:09.320 --> 39:11.320]  can
[39:11.320 --> 39:12.980]  harder
[39:12.980 --> 39:15.140]  buldings
[39:15.140 --> 39:20.140] end
[39:20.140 --> 39:22.140]  gust
[39:22.140 --> 39:28.140] ф extensive
[39:28.140 --> 39:31.060]  그렇죠
[39:31.060 --> 39:32.820] clock
[39:32.820 --> 39:36.820]  Почему к слову? Почему я фиксирую вещество потока?
[39:36.820 --> 39:40.820]  Если мне нужно сказать максимальный поток минимальных стойностей,
[39:40.820 --> 39:46.820]  то можно сначала найти максимальное к, то есть максимальную вещество потока,
[39:46.820 --> 39:50.820]  а потом найти кост к слову, вот в этом как.
[39:50.820 --> 39:54.820]  Но давайте осмотрим более утонченную задачу, где к фиксируем.
[39:54.820 --> 39:58.820]  Вот это максимальный кост, а вот какой-то конкретный вещество.
[39:58.820 --> 40:03.820]  Вот, а в этом будет очень простой.
[40:03.820 --> 40:07.820]  Ну, давайте сначала я скажу, что делать с обратными ребрами,
[40:07.820 --> 40:11.820]  потоковую задачу.
[40:11.820 --> 40:17.820]  Ну, давайте скажем, что если у меня было ребро с параметрами капасик и кост,
[40:17.820 --> 40:21.820]  то у меня к нему всегда добавляется обратное ребро.
[40:21.820 --> 40:25.820]  Понятность, мы любим капасик, как всегда.
[40:25.820 --> 40:30.820]  А вот стойность я делаю просто минус кост.
[40:30.820 --> 40:35.820]  Ну, и это более-менее соответствует интуитивному пониманию того, что такое обратное ребро.
[40:35.820 --> 40:39.820]  Это возможность отменить поток текущий по применению ребра.
[40:39.820 --> 40:43.820]  И значит, скажем, если я слева-направо упустил какой-то поточек
[40:43.820 --> 40:47.820]  и потратил кост рублей на это, чтобы его отменить, я могу его отменить,
[40:47.820 --> 40:51.820]  пройдя справа-налево, и тем самым заплатить минус кост,
[40:51.820 --> 40:54.820]  ну, те самые кост рублей, которые отменили.
[40:54.820 --> 40:59.820]  А, поэтому, как всегда, обратное ребро позволяет отменять уже текущий поток по данному ребру.
[40:59.820 --> 41:03.820]  Поэтому здесь твой метод интуитивный.
[41:03.820 --> 41:09.820]  Вот, теперь у меня задача такая, там есть граф, как всегда с обратными ребрами.
[41:09.820 --> 41:13.820]  Но теперь уже у меня косты бывают всякие разные.
[41:13.820 --> 41:17.820]  Даже изначально, если у меня косты были положительные, не отрицательные,
[41:17.820 --> 41:20.820]  тут уже хочешь-не хочешь, придется работать с отрицательными.
[41:20.820 --> 41:25.820]  А если я перешлю на круглый кост, у меня знаки бывают всякие разные.
[41:25.820 --> 41:28.820]  Ну и тут нам придется повозиться.
[41:28.820 --> 41:33.820]  Понятно, что что-то нужно будет с кратчачьими куфтями делать,
[41:33.820 --> 41:36.820]  в графах с отрицательными, а не с отрицательными ребрами.
[41:36.820 --> 41:39.820]  С ребрами отрицательные стоят.
[41:39.820 --> 41:43.820]  Но, в Англии здесь, тем не менее, весьма простой.
[41:44.820 --> 41:47.820]  В Англии это работает так.
[41:47.820 --> 41:55.820]  Я просто, как раз, нахожу в оставшем сети самую дешевую путь из SFD
[41:55.820 --> 41:58.820]  и пускаю для него единичку потока.
[41:58.820 --> 42:03.820]  То есть, ну, как бы вот, жадная вещь.
[42:03.820 --> 42:06.820]  Я буду пускать, вот я кафлово заглю на 5 лучек,
[42:06.820 --> 42:10.820]  и каждую, каждую единичку потока буду пускать вдоль самого выменного пути.
[42:10.820 --> 42:12.820]  То есть вдоль того, который дешевле всего с доль.
[42:12.820 --> 42:16.820]  Из SFD самую дешевую путь, ну, вот в сернах костя.
[42:16.820 --> 42:19.820]  То есть, я просто найду самую дешевую путь в сернах костя из SFD,
[42:19.820 --> 42:21.820]  пущу для него единичку потока.
[42:21.820 --> 42:23.820]  Если перестрою все, я добавлю обратную еду.
[42:23.820 --> 42:27.820]  Опять, нахожу новый, кратчачий путь, пускаю для него единичку потока,
[42:27.820 --> 42:30.820]  провожу обратную еду, и так далее, карта.
[42:30.820 --> 42:36.820]  Да, давайте, так, с моим единичкой пушкой пустить единицу потока
[42:37.820 --> 42:41.820]  вдоль кратчайшего людей из SFD.
[42:43.820 --> 42:48.820]  Ну, останутся движения.
[42:48.820 --> 42:50.820]  Вот это карта.
[42:57.820 --> 43:00.820]  Такая история будет, если не оптимальна,
[43:00.820 --> 43:04.820]  то жарный моим дельтритом будет находить правильный объект.
[43:05.820 --> 43:09.820]  Вот. Ну, а кратчайший путь мы будем как-нибудь искать,
[43:09.820 --> 43:11.820]  например, Фордом Уэллом.
[43:11.820 --> 43:14.820]  Потому что у меня здесь бывают отрицательные хосты,
[43:14.820 --> 43:16.820]  поэтому, наверное, DX-треку умолчания не обойдешься,
[43:16.820 --> 43:19.820]  раз есть отрицательные стоимости, DX у меня работает отрицательные стоимости.
[43:19.820 --> 43:21.820]  Ну, можно, например, Фордом Уэллом пустить,
[43:21.820 --> 43:23.820]  он как раз все это спокойно обрабатывает.
[43:23.820 --> 43:26.820]  Надо еще обсудить, что делать с отрицательными циклами.
[43:26.820 --> 43:28.820]  Ну, вот скажем, если их не появляется,
[43:28.820 --> 43:31.820]  если отрицательный цикл сжевельно крикается,
[43:31.820 --> 43:34.820]  тогда можно просто на каждый раз искать Фордом Уэллом,
[43:34.820 --> 43:37.820]  находить кратчайший путь и по нему пускать в дичь.
[43:39.820 --> 43:41.820]  Вот. Ну, как мы делаем?
[43:43.820 --> 43:46.820]  Почему вы обратно говорите «брат», или вот так?
[43:46.820 --> 43:48.820]  Ну, так же, как и раньше.
[43:49.820 --> 43:51.820]  Потому что...
[43:51.820 --> 43:53.820]  В чем смысл, да? В чем здесь ноль?
[43:53.820 --> 43:55.820]  Значит, ноль.
[43:55.820 --> 43:57.820]  Смысл вот этой «брат» в том,
[43:57.820 --> 43:59.820]  что мы позволили отменять поток по прямой.
[43:59.820 --> 44:02.820]  И если, скажем, я вот здесь пустил единичку потока,
[44:03.820 --> 44:07.820]  тогда по антисимметричности у меня вот здесь в черт минус единичку потока.
[44:08.820 --> 44:12.820]  Но тогда это значит, что остаточная капаситей этой игры — это один.
[44:12.820 --> 44:14.820]  Капаситей минус flow — это один.
[44:15.820 --> 44:18.820]  Это как раз и значит, что я могу единичку отменить.
[44:18.820 --> 44:20.820]  И только ноль мне как раз таки не свойственно угладать, да,
[44:20.820 --> 44:25.820]  чтобы капаситей минус минус flow было flow равно.
[44:25.820 --> 44:27.820]  Поэтому здесь ноль.
[44:27.820 --> 44:29.820]  Так, ну хорошо.
[44:29.820 --> 44:32.820]  Давайте двигаться в сторону и показать сроковеренности.
[44:32.820 --> 44:34.820]  Проверить манну.
[44:34.820 --> 44:36.820]  То есть для этого мы сначала совершим ретейлизм.
[44:36.820 --> 44:38.820]  Теперь минимальность потока.
[44:40.820 --> 44:41.820]  Ретейлизм.
[44:41.820 --> 44:43.820]  Минимальность.
[44:43.820 --> 44:45.820]  Стойный поток.
[44:49.820 --> 44:51.820]  Ну что, пусть.
[44:51.820 --> 44:53.820]  Ну что?
[44:53.820 --> 44:55.820]  Ну что?
[44:56.820 --> 44:58.820]  Ну что, пусть.
[44:58.820 --> 45:00.820]  Этична потока ровно так.
[45:02.820 --> 45:07.820]  Тогда, если это ноль костка flow.
[45:12.820 --> 45:14.820]  Если и только если.
[45:15.820 --> 45:17.820]  Уже f.
[45:17.820 --> 45:19.820]  И мне цикл подэффектной стоимости.
[45:25.820 --> 45:27.820]  Вот.
[45:33.820 --> 45:35.820]  То есть перед тем, как двигаться к осознанию самолётов,
[45:35.820 --> 45:38.820]  давайте выведем характеристики внимальности.
[45:38.820 --> 45:40.820]  Жечь то, что поток минимален в плане стоимости.
[45:40.820 --> 45:43.820]  Если достаточно сети нет, то обязательно сети.
[45:43.820 --> 45:46.820]  Если только сети нет, то обязательно сети.
[45:50.820 --> 45:51.820]  Вот.
[45:51.820 --> 45:53.820]  Ну, по одному сторону будет очевидно.
[45:53.820 --> 45:55.820]  Откуда? Куда?
[45:57.820 --> 45:59.820]  Загадка.
[46:08.820 --> 46:10.820]  Куда?
[46:12.820 --> 46:14.820]  А в Ж5 нет пути из СТ?
[46:14.820 --> 46:16.820]  Нет, нет.
[46:16.820 --> 46:18.820]  Можете ездить.
[46:18.820 --> 46:20.820]  Тут никакого посуды.
[46:20.820 --> 46:22.820]  Слева и правая.
[46:23.820 --> 46:25.820]  Слева и права очевидно,
[46:25.820 --> 46:27.820]  потому что если лезвый кост,
[46:27.820 --> 46:29.820]  ну, в Жf есть отрицатель цикла,
[46:29.820 --> 46:31.820]  то можно просто вдоль этого цикла
[46:31.820 --> 46:33.820]  прибавить единичку потока
[46:33.820 --> 46:35.820]  и получить поток меньше и меньше стоимости.
[46:37.820 --> 46:41.820]  Значит, если в Жf есть отрицатель цикла,
[46:45.820 --> 46:47.820]  то вдоль него можно пустить единицу потока.
[46:53.820 --> 46:57.820]  Значит, тогда величина потока не изменится.
[46:59.820 --> 47:01.820]  Ну, потому что я просто добавил единый замок
[47:01.820 --> 47:04.820]  по маршруту, он не влияет на величину потока.
[47:04.820 --> 47:06.820]  Вот, но при этом стоимость уменьшится.
[47:17.820 --> 47:19.820]  Поличнее.
[47:20.820 --> 47:22.820]  Поличнее.
[47:28.820 --> 47:30.820]  Ну, если есть циклы,
[47:30.820 --> 47:32.820]  то можно по ним пустить поток,
[47:32.820 --> 47:34.820]  но меньше стоимости.
[47:34.820 --> 47:36.820]  А что на твоей фиге?
[47:36.820 --> 47:38.820]  О, извини, Сергей.
[47:47.820 --> 47:49.820]  Вот, ну здесь справа налево.
[47:49.820 --> 47:51.820]  Жаль, что верный обратно.
[47:51.820 --> 47:53.820]  Если нет циклов, то обязательно понимать.
[47:54.820 --> 47:56.820]  Ну, давайте верно противного пойдем.
[47:58.820 --> 48:00.820]  Да, вот эти переходы,
[48:00.820 --> 48:02.820]  дарный, очевидный.
[48:03.820 --> 48:05.820]  Давай.
[48:13.820 --> 48:15.820]  А что нам мешает?
[48:19.820 --> 48:21.820]  На самом деле, мы не обязаны.
[48:21.820 --> 48:24.820]  Потому что в определении потока у нас есть просто три свойства.
[48:24.820 --> 48:26.820]  Непривышение капазити,
[48:26.820 --> 48:28.820]  антимитричность хранения потока.
[48:28.820 --> 48:30.820]  В частности, там не в нигде ограничения,
[48:30.820 --> 48:32.820]  что там потом должен быть функция связи
[48:32.820 --> 48:34.820]  или что-то такое.
[48:34.820 --> 48:36.820]  А, даже если у вас есть одна нинчика потока вдоль пути,
[48:36.820 --> 48:38.820]  и висящий будет цикл,
[48:38.820 --> 48:40.820]  это корректный подход.
[48:40.820 --> 48:42.820]  Главное, что выполняешь все свойства.
[48:42.820 --> 48:44.820]  То есть связи не произойдут.
[48:46.820 --> 48:48.820]  Так, ну теперь обратно.
[48:48.820 --> 48:50.820]  В обратную сторону давайте вход противного.
[48:50.820 --> 48:52.820]  Пойдем.
[48:54.820 --> 48:56.820]  Значит, пусть уже вверх и нет интересных циклов.
[49:00.820 --> 49:02.820]  Но при этом f не минимальный.
[49:02.820 --> 49:04.820]  Давайте скажем тогда,
[49:04.820 --> 49:06.820]  это где звездочка, понимаете?
[49:08.820 --> 49:10.820]  Значит, f звездочка,
[49:10.820 --> 49:12.820]  это непоскорпорный.
[49:16.820 --> 49:18.820]  У нас, соответственно, его стоимость,
[49:18.820 --> 49:20.820]  строго меньшим, стоимость f.
[49:20.820 --> 49:22.820]  Возьмем какое-то
[49:22.820 --> 49:24.820]  настоящее внимание.
[49:26.820 --> 49:28.820]  Давайте я поделим следующее.
[49:30.820 --> 49:32.820]  Давайте скажем,
[49:32.820 --> 49:34.820]  g,
[49:34.820 --> 49:36.820]  это звездочка, не в секс.
[49:40.820 --> 49:42.820]  Просто давайте формально,
[49:42.820 --> 49:44.820]  лучше в один поток из другого.
[49:44.820 --> 49:46.820]  Ну, то есть для каждого,
[49:46.820 --> 49:48.820]  для каждого, для каждого,
[49:48.820 --> 49:50.820]  ну то есть для каждого и правда,
[49:50.820 --> 49:52.820]  я скажу, что увеличена потока
[49:52.820 --> 49:54.820]  g на этой игре равна разности
[49:54.820 --> 49:56.820]  в этих двух ключах.
[49:56.820 --> 49:58.820]  А на этой игре g неожиданно,
[49:58.820 --> 50:00.820]  это разность звездочки и f.
[50:04.820 --> 50:06.820]  Я утверждаю, что это,
[50:06.820 --> 50:08.820]  во-первых, поток,
[50:10.820 --> 50:12.820]  во-вторых, поток влеченой.
[50:18.820 --> 50:20.820]  Давайте это
[50:20.820 --> 50:22.820]  поймем, что это так.
[50:22.820 --> 50:24.820]  Ну, надо уточнить,
[50:24.820 --> 50:26.820]  не а вы где, а g.
[50:26.820 --> 50:28.820]  Это важно.
[50:28.820 --> 50:30.820]  Не вышкодом драть,
[50:30.820 --> 50:32.820]  а именно в остатке 10 g.
[50:34.820 --> 50:36.820]  Ну, почему? Что происходит в этом потоке?
[50:36.820 --> 50:38.820]  Надо просто присвоиться, доверите?
[50:38.820 --> 50:40.820]  Значит,
[50:40.820 --> 50:42.820]  первое, что в этом потоке не большим
[50:42.820 --> 50:44.820]  компасити. Ну, я знаю,
[50:44.820 --> 50:46.820]  что g и f, это разность
[50:46.820 --> 50:48.820]  f звездочки и f.
[50:50.820 --> 50:52.820]  Дальше, я знаю, что f звездочки не большими
[50:52.820 --> 50:54.820]  целки и f.
[50:56.820 --> 50:58.820]  Но это в точности остатчная компаси.
[51:06.820 --> 51:08.820]  Я живу в графе g и f
[51:08.820 --> 51:10.820]  в остатчной сети.
[51:10.820 --> 51:12.820]  Здесь у меня остатчная компаси
[51:12.820 --> 51:14.820]  ровно вот такая, c-f,
[51:14.820 --> 51:16.820]  что значит g не больше, чем остатчная компаси.
[51:18.820 --> 51:20.820]  Дальше, вот дальше, ребята, дальше
[51:20.820 --> 51:22.820]  антисимметричность, очевидно,
[51:22.820 --> 51:24.820]  если у вас f звездочки антисимметричны,
[51:24.820 --> 51:26.820]  то это разность f звездочки антисимметричны.
[51:26.820 --> 51:28.820]  Да, ну, хорошо.
[51:28.820 --> 51:30.820]  g в q в
[51:32.820 --> 51:34.820]  равно f звездочки в q в r
[51:34.820 --> 51:36.820]  минус f в q в r.
[51:36.820 --> 51:38.820]  Дальше, если я меня
[51:38.820 --> 51:40.820]  местами u и v, то у меня выносится минус
[51:40.820 --> 51:42.820]  за знак потока
[51:42.820 --> 51:44.820]  антисимметричности потока.
[51:44.820 --> 51:46.820]  Здесь написано, минус f звездочки
[51:46.820 --> 51:48.820]  v u
[51:48.820 --> 51:50.820]  плюс f v u.
[51:50.820 --> 51:52.820]  Ну, и это в точности
[51:52.820 --> 51:54.820]  минус zhu v u.
[52:02.820 --> 52:04.820]  Так, ну и третье
[52:04.820 --> 52:06.820]  сохранение.
[52:06.820 --> 52:08.820]  Сохранение тоже давайте даже бесспорно надышу.
[52:08.820 --> 52:10.820]  Значит, идея, смотрите какая.
[52:10.820 --> 52:14.820]  question
[52:14.820 --> 52:16.820]  ...
[52:16.820 --> 52:18.820]  ...
[52:18.820 --> 52:20.820]  ...
[52:20.820 --> 52:22.820]  ...
[52:22.820 --> 52:24.820]  ...
[52:24.820 --> 52:26.820]  ...
[52:26.820 --> 52:28.820]  ...
[52:28.820 --> 52:30.820]  ...
[52:30.820 --> 52:32.820]  ...
[52:32.820 --> 52:34.820]  ...
[52:34.820 --> 52:36.820]  ...
[52:36.820 --> 52:38.820]  ...
[52:38.820 --> 52:51.820]  Ну или формально просто, что мне нужно, мне нужно чтобы сумма вот этих вот всех потоков была нулика, точнее сумма вот этих, равнял сумму вот этих. Ходячка равна исходячку.
[52:51.820 --> 52:59.820]  Ну я знаю, что для редзвездочка это так, и для этого это так. То есть если я хочу что-то из любого, то для радости что-то я не буду делать.
[53:00.820 --> 53:07.820]  Сохранение тоже. Сохранение потока тоже, например.
[53:11.820 --> 53:16.820]  Ну все, начнем с потока. В оставшемся теже.
[53:17.820 --> 53:20.820]  Почему она лишь не ноль?
[53:21.820 --> 53:27.820]  Ну понятно, что у меня есть два потока дельчинка, каждая. Я один с дельчинками встаю, и конечно ноль должен получиться.
[53:28.820 --> 53:37.820]  Да, в общем, потому что поток, поскольку есть какая-нибудь старта, я знаю, что здесь я не толокаю старта, и здесь я не толокаю старта, если одно из двух будет, чтобы как раз ноль остался.
[53:37.820 --> 53:41.820]  Поэтому то поток дельчинной ноль вознашивает.
[53:42.820 --> 53:43.820]  Чудесно.
[53:43.820 --> 53:46.820]  Но что такое поток дельчинной ноль?
[53:46.820 --> 53:49.820]  Мы с вами помним лему о декомозиции потока.
[53:49.820 --> 53:56.820]  Если есть некий поток, то он всегда предстоит в виде суммы нескольких путей из st и нескольких циклов.
[53:57.820 --> 54:01.820]  Но поскольку здесь у меня поток дельчинной ноль, то g просто нескольких циклов.
[54:01.820 --> 54:04.820]  Они не одного пути, потому что каждый путь это плюс один поток.
[54:05.820 --> 54:07.820]  Значит, просто нескольких циклов.
[54:08.820 --> 54:11.820]  Нескольких циклов по старшему теже.
[54:13.820 --> 54:18.820]  Ну, кстати говоря, что можно сказать про стоимость этого потока?
[54:19.820 --> 54:20.820]  По старшему теже.
[54:21.820 --> 54:27.820]  Плюс, понятно, что просто из-за единения с ним, стоимость этого звёздочного минуты превратится.
[54:30.820 --> 54:33.820]  Потому что на каждом дельче у меня стоимость...
[54:34.820 --> 54:36.820]  Ну, как раз это будет считаться.
[54:36.820 --> 54:38.820]  А это не считается.
[54:40.820 --> 54:42.820]  Потому что это будет нежелательно.
[54:50.820 --> 54:52.820]  Вот. Получается, что...
[54:54.820 --> 55:00.820]  Получается, что это какой-то поток дельчины ноль отрицательной стоимости.
[55:02.820 --> 55:04.820]  То есть, получается, у меня в шее отрыв...
[55:05.820 --> 55:07.820]  Выбираем несколько циклов.
[55:08.820 --> 55:10.820]  По ним дельчинная единица потока, ну...
[55:11.820 --> 55:15.820]  Считается, не важно, несколько циклов, суммарная стоимость меньше нуля.
[55:15.820 --> 55:18.820]  Ну, значит, в частности, есть такой деканулетор меньше нуля.
[55:19.820 --> 55:22.820]  В противоречии с тем, что уже в некую церковь.
[55:24.820 --> 55:25.820]  Да, давайте обещаем.
[55:26.820 --> 55:30.820]  Значит, уже в 10-11 церкови.
[55:36.820 --> 55:37.820]  В противоречии.
[55:45.820 --> 55:46.820]  Стоимость.
[55:59.820 --> 56:00.820]  Так.
[56:01.820 --> 56:02.820]  Да-да.
[56:04.820 --> 56:06.820]  Ну хорошо, значит, мы показали наши смятения.
[56:06.820 --> 56:09.820]  И мы поняли, что минимальная стоимость потока достигается ровно тогда.
[56:10.820 --> 56:12.820]  Когда в остаточной сети нет циклов дельчатин.
[56:15.820 --> 56:21.820]  Ну хорошо, тогда чтобы наш алгоритм работал в этом, в общем, здоровом, алгоритм такой
[56:21.820 --> 56:25.820]  Просто выпускаем каждый раз только в чаще, в нижнюю потоку
[56:25.820 --> 56:32.820]  Мне нужно доказать, что если изначально не было отрицательных циклов, то их никогда не будет появляться
[56:32.820 --> 56:36.820]  Потому что минимальность, то же самое, что отсутствует из этих циклов
[56:36.820 --> 56:41.820]  Мне нужно показать, что если изначально поток был минимален, если изначально нет циклов отрицательных
[56:41.820 --> 56:45.820]  То каждый раз после пускания в нижнюю потоку кит не появляется
[56:46.820 --> 56:48.820]  Ну вот давайте покажем
[56:49.820 --> 56:51.820]  Подожди
[56:51.820 --> 56:52.820]  Пусти
[56:52.820 --> 56:53.820]  Уже?
[56:53.820 --> 56:55.820]  Нет
[56:55.820 --> 56:57.820]  Ааа, опять пускай лодку
[57:00.820 --> 57:04.820]  Пусть п, а чаще пути засыпляли
[57:11.820 --> 57:15.820]  Соответственно пусть есть поток в нижней 1 доль в том числе
[57:17.820 --> 57:19.820]  Пусть есть
[57:19.820 --> 57:21.820]  Поток в нижней 1
[57:23.820 --> 57:25.820]  Доль в этом
[57:27.820 --> 57:33.820]  Тогда в остаточной сети позже нету циклов отрицательных
[57:41.820 --> 57:43.820]  Вот
[57:47.820 --> 57:53.820]  Вот, но этот движение как раз будет нам означать, что если мы пускаем поток в только чаще пути
[57:53.820 --> 57:58.820]  То если он изначально был минимален, да, минимальность отрицательных циклов на предыдущем шаге
[57:58.820 --> 58:01.820]  То и дальше будет минимален, потому что отрицательных циклов не появляется
[58:01.820 --> 58:05.820]  Значит каждый минуток будет минимален, так как на каждом шаге будет продолжать быть минимален
[58:05.820 --> 58:08.820]  Отсюда будет немедленно все предкорректировать
[58:09.820 --> 58:12.820]  Так, вот эта задача вроде тоже будет сложная
[58:12.820 --> 58:14.820]  Давайте, ребята, потихоньку пойдем
[58:18.820 --> 58:21.820]  Давайте скажем, что пусть какой-то С
[58:21.820 --> 58:23.820]  Это циклон F
[58:23.820 --> 58:25.820]  Вот так
[58:37.820 --> 58:39.820]  Так, вот так
[58:54.820 --> 58:56.820]  Да
[58:56.820 --> 58:58.820]  Вот так
[58:58.820 --> 59:00.820]  Вот так
[59:20.820 --> 59:22.820]  Значит, теперь посмотрите, что в основном есть
[59:22.820 --> 59:25.820]  Есть, есть, есть, есть, есть, есть путь
[59:25.820 --> 59:27.820]  И есть еще один цикл C
[59:27.820 --> 59:29.820]  Где-то он там, не знаю
[59:29.820 --> 59:31.820]  Вот как-то так вот выглядит
[59:31.820 --> 59:32.820]  На нем тоже 1
[59:32.820 --> 59:34.820]  Ну, давайте считать, что на нем 1 поток
[59:34.820 --> 59:36.820]  Тогда давайте сложим
[59:36.820 --> 59:38.820]  Так же просто чисто арифитически сложим W3C
[59:38.820 --> 59:42.820]  То есть на каждом репелленте пишем поток равный сумме P и C
[59:42.820 --> 59:46.820]  Тогда я скажу, что в сумме это тоже будет поток
[59:46.820 --> 59:49.820]  В исходном нашем графе уже
[59:49.820 --> 59:50.820]  Мы решили 1
[59:50.820 --> 59:52.820]  Ну, понятно, потому что мы решили 1
[59:52.820 --> 59:55.820]  И при этом его стоимость будет меньше, чем стоимость P
[59:55.820 --> 59:57.820]  Отдайте, очевидно, потому что
[59:57.820 --> 59:59.820]  Стоимость C отрицательна
[59:59.820 --> 01:00:02.820]  Значит, их сумма вместе меньше, чем стоимость P
[01:00:04.820 --> 01:00:06.820]  Ну, а это бред, потому что, смотрите
[01:00:06.820 --> 01:00:08.820]  Потому что P, а это что?
[01:00:08.820 --> 01:00:10.820]  Это был кратчайший путь из СС
[01:00:10.820 --> 01:00:12.820]  То есть по факту F это
[01:00:12.820 --> 01:00:14.820]  Ну, поток вычисления 1
[01:00:14.820 --> 01:00:16.820]  Долька кратчайшего пути
[01:00:16.820 --> 01:00:19.820]  А P плюс С, это только кратчайший путь из СС
[01:00:19.820 --> 01:00:21.820]  Долька кратчайшего пути
[01:00:21.820 --> 01:00:23.820]  А P плюс С, вот другой поток
[01:00:23.820 --> 01:00:25.820]  Вычисления 1, еще более дешевый
[01:00:25.820 --> 01:00:28.820]  То есть у меня есть вот этот вот
[01:00:28.820 --> 01:00:30.820]  Доль самого дешевого пути
[01:00:30.820 --> 01:00:32.820]  А есть какой-то еще более дешевый
[01:00:32.820 --> 01:00:33.820]  Ну, как он может выглядеть?
[01:00:33.820 --> 01:00:35.820]  А это все равно какой-то путь
[01:00:35.820 --> 01:00:37.820]  Точнее, поток вдоль какого-то пути
[01:00:37.820 --> 01:00:39.820]  И еще, может, какие-то циклы
[01:00:39.820 --> 01:00:43.820]  Но поскольку все циклы не отрицательные
[01:00:43.820 --> 01:00:45.820]  Значит, стоимость здесь может быть только больше
[01:00:45.820 --> 01:00:47.820]  Потому что еще и путь не кратчайший
[01:00:49.820 --> 01:00:51.820]  Да, сейчас я повторюсь
[01:00:53.820 --> 01:00:55.820]  Значит, смотрите, вот с этим можно согласиться?
[01:00:55.820 --> 01:00:57.820]  Пока что нет
[01:00:57.820 --> 01:00:58.820]  Пока что нет, хорошо
[01:00:58.820 --> 01:01:00.820]  Значит, смотрите
[01:01:00.820 --> 01:01:02.820]  P плюс С, это просто чисто ритмически
[01:01:02.820 --> 01:01:04.820]  Также я на каждом любе складываю
[01:01:04.820 --> 01:01:06.820]  Поток вдоль пути
[01:01:06.820 --> 01:01:08.820]  Плюс путь кратчайшего пути
[01:01:08.820 --> 01:01:10.820]  Давайте перейдем к тому, что будет поток в G
[01:01:10.820 --> 01:01:11.820]  Ну, давайте как-то трогать
[01:01:11.820 --> 01:01:13.820]  Давайте тоже так на звуку, если будет G мальча
[01:01:13.820 --> 01:01:15.820]  А, ну нет, как?
[01:01:15.820 --> 01:01:17.820]  А, хорошо
[01:01:17.820 --> 01:01:19.820]  Ну, кстати, путь он не кратчайший
[01:01:19.820 --> 01:01:21.820]  Да, и не кратчайший путь
[01:01:21.820 --> 01:01:23.820]  Еще раз, знаете, P плюс С
[01:01:23.820 --> 01:01:25.820]  Также ритмически можно проявить, что этот поток в G ниже
[01:01:25.820 --> 01:01:27.820]  Это О?
[01:01:27.820 --> 01:01:28.820]  Да
[01:01:28.820 --> 01:01:30.820]  Вот, дальше понять, что его стоимость меньше
[01:01:30.820 --> 01:01:31.820]  Стоимость P
[01:01:31.820 --> 01:01:33.820]  Потому что она отличается на
[01:01:33.820 --> 01:01:35.820]  Плюс по С, но она отличается
[01:01:35.820 --> 01:01:37.820]  Потому что С отличается
[01:01:37.820 --> 01:01:39.820]  Сейчас тоже есть
[01:01:39.820 --> 01:01:41.820]  Тогда давайте рассчитаем на звуку
[01:01:41.820 --> 01:01:43.820]  Пусть это будет там G мальча
[01:01:43.820 --> 01:01:45.820]  Значит, это будет поток
[01:01:45.820 --> 01:01:47.820]  В G
[01:01:47.820 --> 01:01:49.820]  В G
[01:01:49.820 --> 01:01:51.820]  Давайте мы нарисуем
[01:01:51.820 --> 01:01:53.820]  Я знаю, что такое поток в G один
[01:01:53.820 --> 01:01:55.820]  Это путь и несколько циклов
[01:01:55.820 --> 01:01:57.820]  Кстати, по линии ригмпозиции
[01:01:57.820 --> 01:01:59.820]  Если у меня поток в G один, то это один путь
[01:01:59.820 --> 01:02:01.820]  И несколько металлических циклов
[01:02:01.820 --> 01:02:03.820]  Давайте вот здесь
[01:02:03.820 --> 01:02:05.820]  Это какой-то путь
[01:02:05.820 --> 01:02:07.820]  И какие-то циклы
[01:02:07.820 --> 01:02:09.820]  Зачем они не мальча?
[01:02:09.820 --> 01:02:11.820]  И какие-то циклы
[01:02:11.820 --> 01:02:13.820]  Ну, это все происходит в исходном графике
[01:02:13.820 --> 01:02:15.820]  Тогда, что здесь со стоимостью?
[01:02:15.820 --> 01:02:17.820]  Смотрите, все циклы не отрицательные
[01:02:17.820 --> 01:02:19.820]  По предположению
[01:02:19.820 --> 01:02:21.820]  А, потому что G нет
[01:02:21.820 --> 01:02:23.820]  Значит, все циклы не отрицательные
[01:02:23.820 --> 01:02:25.820]  Ну, и П штрих
[01:02:25.820 --> 01:02:27.820]  Это какой-то путь
[01:02:27.820 --> 01:02:29.820]  Вес которого, понятно, делает
[01:02:29.820 --> 01:02:31.820]  Больше равен, чем вес П
[01:02:31.820 --> 01:02:33.820]  Потому что П это кратчайшая
[01:02:33.820 --> 01:02:35.820]  По штриху какой?
[01:02:35.820 --> 01:02:37.820]  Значит, стоимость П штриха
[01:02:37.820 --> 01:02:39.820]  Больше равна, чем стоимость П
[01:02:39.820 --> 01:02:41.820]  Потому что это кратчайшая
[01:02:41.820 --> 01:02:43.820]  Это какое?
[01:02:43.820 --> 01:02:45.820]  Ну, все, противоречие
[01:02:45.820 --> 01:02:47.820]  Потому что суммальная стоимость G тогда
[01:02:47.820 --> 01:02:49.820]  Получается, хотя бы у нас П
[01:02:49.820 --> 01:02:51.820]  Плюс еще столько не отрицательных дольцев
[01:02:51.820 --> 01:02:53.820]  Но при этом это меньше, чем П
[01:02:53.820 --> 01:02:55.820]  Противоречие
[01:02:55.820 --> 01:02:57.820]  Противоречие
[01:03:03.820 --> 01:03:05.820]  Противоречие вот с этим
[01:03:09.820 --> 01:03:11.820]  То есть, штрих это любой путь?
[01:03:11.820 --> 01:03:13.820]  Ну, не любой
[01:03:13.820 --> 01:03:15.820]  А тот, который получается при складывании
[01:03:15.820 --> 01:03:17.820]  В какой-то путь
[01:03:17.820 --> 01:03:19.820]  Значит, в частности
[01:03:19.820 --> 01:03:21.820]  Более дорогой, чем самый короткий
[01:03:25.820 --> 01:03:27.820]  Так
[01:03:27.820 --> 01:03:29.820]  Считаю, что доказал
[01:03:29.820 --> 01:03:31.820]  Нормально?
[01:03:37.820 --> 01:03:39.820]  Вот так вот
[01:03:39.820 --> 01:03:41.820]  Все, суммольное
[01:03:41.820 --> 01:03:43.820]  Что отрицательных циклов не появляется
[01:03:43.820 --> 01:03:45.820]  Если пускать какой-то кратчайший путь
[01:03:45.820 --> 01:03:47.820]  Значит, отсюда
[01:03:47.820 --> 01:03:49.820]  Сразу следует корректность
[01:03:49.820 --> 01:03:51.820]  Нашего исходного алгоритма
[01:03:51.820 --> 01:03:53.820]  Что если в исходном графе
[01:03:53.820 --> 01:03:55.820]  В самом первом же
[01:03:55.820 --> 01:03:57.820]  Нету отрицательных циклов
[01:03:57.820 --> 01:03:59.820]  Нет циклов отрицательного веса
[01:03:59.820 --> 01:04:01.820]  Просто кара спускает в фордегалонах
[01:04:01.820 --> 01:04:03.820]  Пускай там одни чехол
[01:04:03.820 --> 01:04:05.820]  Циклы с ним появляются отрицательными
[01:04:05.820 --> 01:04:07.820]  Значит, на каждом шаге будут вот так минимальные
[01:04:07.820 --> 01:04:09.820]  А на отрицательных циклах
[01:04:09.820 --> 01:04:11.820]  Вызывает с учетом подошвы?
[01:04:11.820 --> 01:04:13.820]  Нет
[01:04:13.820 --> 01:04:15.820]  Только
[01:04:15.820 --> 01:04:17.820]  Вес цикла
[01:04:17.820 --> 01:04:19.820]  Только с точки зрения
[01:04:19.820 --> 01:04:21.820]  Сольности
[01:04:21.820 --> 01:04:23.820]  Ну да
[01:04:23.820 --> 01:04:25.820]  На каждом шаге
[01:04:25.820 --> 01:04:27.820]  Какая-то стоимость
[01:04:27.820 --> 01:04:29.820]  Она не лучшая
[01:04:33.820 --> 01:04:35.820]  Ну, смотрите еще раз
[01:04:35.820 --> 01:04:37.820]  Вот у вас есть исход, игра в G
[01:04:37.820 --> 01:04:39.820]  Давайте для простыды
[01:04:39.820 --> 01:04:41.820]  Все кости положительные
[01:04:43.820 --> 01:04:45.820]  Изначально понятно
[01:04:45.820 --> 01:04:47.820]  Все стоимости положительные
[01:04:47.820 --> 01:04:49.820]  А понятно, что циклов с задних нет
[01:04:49.820 --> 01:04:51.820]  Но потом, когда вы пускаете по очереди
[01:04:51.820 --> 01:04:53.820]  У вас появляются обратные ребра
[01:04:55.820 --> 01:04:57.820]  Да?
[01:04:57.820 --> 01:04:59.820]  И на них отрицательные косты
[01:04:59.820 --> 01:05:01.820]  Появились отрицательные ребра
[01:05:01.820 --> 01:05:03.820]  Потенциально они возили с задних циклов
[01:05:03.820 --> 01:05:05.820]  Вот я доказываю, что такого не бывает
[01:05:05.820 --> 01:05:07.820]  Хотя отрицательные ребра и появляются
[01:05:07.820 --> 01:05:09.820]  Но циклов не появляются
[01:05:09.820 --> 01:05:11.820]  А значит, на каждом шаге
[01:05:11.820 --> 01:05:13.820]  Потом понимают
[01:05:13.820 --> 01:05:15.820]  Вот
[01:05:15.820 --> 01:05:17.820]  Хорошо
[01:05:17.820 --> 01:05:19.820]  Если
[01:05:19.820 --> 01:05:21.820]  Если в исходном G нет
[01:05:21.820 --> 01:05:23.820]  В исходном G
[01:05:23.820 --> 01:05:25.820]  Не было
[01:05:25.820 --> 01:05:27.820]  Отрицательных циклов
[01:05:27.820 --> 01:05:29.820]  То отрицательные косты
[01:05:41.820 --> 01:05:43.820]  Так, ну
[01:05:43.820 --> 01:05:45.820]  Пасим с точки
[01:05:47.820 --> 01:05:49.820]  На питотика
[01:05:49.820 --> 01:05:51.820]  Можно писать таков
[01:05:51.820 --> 01:05:53.820]  Можно в G
[01:05:53.820 --> 01:05:55.820]  Потому что
[01:05:55.820 --> 01:05:57.820]  У меня так раз
[01:05:57.820 --> 01:05:59.820]  Сидит в фордону
[01:05:59.820 --> 01:06:01.820]  А фордон как раз в стоке работает
[01:06:07.820 --> 01:06:09.820]  Вот это в нейми реализация
[01:06:09.820 --> 01:06:11.820]  На, если просто так раз
[01:06:11.820 --> 01:06:13.820]  Сидит в фордон
[01:06:13.820 --> 01:06:15.820]  Теперь давайте обсудим
[01:06:15.820 --> 01:06:17.820]  Как это можно
[01:06:17.820 --> 01:06:19.820]  Оптимизировать
[01:06:21.820 --> 01:06:23.820]  Значит
[01:06:23.820 --> 01:06:25.820]  Оказывается, что
[01:06:25.820 --> 01:06:27.820]  Можно перед образом использовать
[01:06:27.820 --> 01:06:29.820]  Дэйвстрок
[01:06:29.820 --> 01:06:31.820]  Если хитренько
[01:06:31.820 --> 01:06:33.820]  Что-то в этом графе поменим
[01:06:33.820 --> 01:06:35.820]  А именно
[01:06:35.820 --> 01:06:37.820]  Давайте рассмотрим
[01:06:37.820 --> 01:06:39.820]  Пенсионалы дросс
[01:06:39.820 --> 01:06:41.820]  Возможно, на семинарах это рассмотрим
[01:06:43.820 --> 01:06:45.820]  Значит, смотрите
[01:06:45.820 --> 01:06:47.820]  Моя цель сейчас
[01:06:47.820 --> 01:06:49.820]  Это избавиться вот вот
[01:06:49.820 --> 01:06:51.820]  Вот этого вот большого множителя
[01:06:51.820 --> 01:06:53.820]  И свести его к дэйвстру
[01:06:53.820 --> 01:06:55.820]  Мы помним, что
[01:06:55.820 --> 01:06:57.820]  Дэйвстр работает в идеальной реализации
[01:06:57.820 --> 01:06:59.820]  За делу G
[01:06:59.820 --> 01:07:01.820]  А если начать с пучки
[01:07:01.820 --> 01:07:03.820]  Работает за делу G, чтобы сильно лучше
[01:07:03.820 --> 01:07:05.820]  Я хочу двигаться в сторону
[01:07:05.820 --> 01:07:07.820]  Оптимизации фордону
[01:07:07.820 --> 01:07:09.820]  За дэйвстр
[01:07:09.820 --> 01:07:11.820]  Что я для этого сделаю?
[01:07:11.820 --> 01:07:13.820]  Давайте просто
[01:07:13.820 --> 01:07:15.820]  Я скажу, что в каждой вершине
[01:07:15.820 --> 01:07:17.820]  Написано какое-то число
[01:07:17.820 --> 01:07:19.820]  Какое-то целое число
[01:07:19.820 --> 01:07:21.820]  И тогда
[01:07:21.820 --> 01:07:23.820]  Измененная функция
[01:07:23.820 --> 01:07:25.820]  Весовая функция кост
[01:07:25.820 --> 01:07:27.820]  С учетом вот этого потенциала
[01:07:27.820 --> 01:07:29.820]  Будет вести себя так
[01:07:29.820 --> 01:07:31.820]  Это изначальная
[01:07:31.820 --> 01:07:33.820]  Стоимость гибра
[01:07:33.820 --> 01:07:35.820]  Плюс потенциал начала
[01:07:35.820 --> 01:07:37.820]  Минус потенциал конца
[01:07:37.820 --> 01:07:39.820]  Я думаю, будет верно
[01:07:41.820 --> 01:07:43.820]  Формально
[01:07:43.820 --> 01:07:45.820]  Во всех вершинах написано
[01:07:45.820 --> 01:07:47.820]  Какие-то числа
[01:07:47.820 --> 01:07:49.820]  И стоимость гибр
[01:07:49.820 --> 01:07:51.820]  Изменены в соответствии с этим правилом
[01:07:51.820 --> 01:07:53.820]  Каждый гибр увеличивается
[01:07:53.820 --> 01:07:55.820]  Что хорошего в таком преобразовании
[01:07:55.820 --> 01:07:57.820]  Как минимум следующее
[01:07:57.820 --> 01:07:59.820]  Такое преобразование
[01:07:59.820 --> 01:08:01.820]  Сохраняет
[01:08:01.820 --> 01:08:03.820]  Кратчайший путь
[01:08:07.820 --> 01:08:09.820]  В следующем смысле
[01:08:09.820 --> 01:08:11.820]  Я скажу про измольный путь
[01:08:13.820 --> 01:08:15.820]  В исходной весовой функции
[01:08:15.820 --> 01:08:17.820]  Кост
[01:08:17.820 --> 01:08:19.820]  Или новая обновленная кост
[01:08:19.820 --> 01:08:21.820]  Там стоимость потенциала
[01:08:21.820 --> 01:08:23.820]  У меня
[01:08:23.820 --> 01:08:25.820]  Стоимость пути предсказуемо поменяется
[01:08:25.820 --> 01:08:27.820]  Если изначально была такая сумма
[01:08:27.820 --> 01:08:29.820]  Стоимость всех этих преобразований
[01:08:29.820 --> 01:08:31.820]  То дальше как она поменяется
[01:08:31.820 --> 01:08:33.820]  При переходе к потенциальным функциям
[01:08:33.820 --> 01:08:35.820]  Добавится все отец, вышлится вот это
[01:08:35.820 --> 01:08:37.820]  Добавится вот это, вышлится вот это
[01:08:37.820 --> 01:08:39.820]  Поэтому все промежущие
[01:08:39.820 --> 01:08:41.820]  У меня будут цена плюс-минус
[01:08:41.820 --> 01:08:43.820]  Поэтому они как бы попору
[01:08:43.820 --> 01:08:45.820]  Там потенциалы промежущие
[01:08:45.820 --> 01:08:47.820]  Не учитываются
[01:08:47.820 --> 01:08:49.820]  И получается, что суммарный вес
[01:08:49.820 --> 01:08:51.820]  Этого пути изменится
[01:08:51.820 --> 01:08:53.820]  Плюс все отец, плюс все отец
[01:08:53.820 --> 01:08:55.820]  Если всего это большой путь P
[01:08:55.820 --> 01:08:57.820]  То новая стоимость
[01:08:57.820 --> 01:08:59.820]  Пути P
[01:08:59.820 --> 01:09:01.820]  Это старая его стоимость
[01:09:01.820 --> 01:09:03.820]  Плюс все отец, плюс все отец
[01:09:03.820 --> 01:09:05.820]  Вне зависимости от того
[01:09:05.820 --> 01:09:07.820]  Вне зависимости от того
[01:09:07.820 --> 01:09:09.820]  Какие конкретно промежуточные вершины он насыщает
[01:09:09.820 --> 01:09:11.820]  Потому что все промежуточные сокращаются
[01:09:11.820 --> 01:09:13.820]  Согратятся
[01:09:15.820 --> 01:09:17.820]  В частности это означает
[01:09:17.820 --> 01:09:19.820]  Что какие пути изначально
[01:09:19.820 --> 01:09:21.820]  Были кратчайшими
[01:09:21.820 --> 01:09:23.820]  До перехода к потенциальным функциям
[01:09:23.820 --> 01:09:25.820]  Какие пути были кратчайшими, такие остаются
[01:09:25.820 --> 01:09:27.820]  Ну и наоборот, какие стали такие
[01:09:27.820 --> 01:09:29.820]  У меня все пути вместо вот ftr
[01:09:29.820 --> 01:09:31.820]  Изменились на константу
[01:09:31.820 --> 01:09:33.820]  Значит чтобы
[01:09:33.820 --> 01:09:35.820]  Но минимизирую одно, я не минимизирую другое
[01:09:35.820 --> 01:09:37.820]  Давай
[01:09:43.820 --> 01:09:45.820]  Идеальная такая
[01:09:45.820 --> 01:09:47.820]  Давайте попробуем ввести
[01:09:47.820 --> 01:09:49.820]  Такую констанционную систему
[01:09:49.820 --> 01:09:51.820]  Так выводит это
[01:09:51.820 --> 01:09:53.820]  Поставление в вершину чисел
[01:09:53.820 --> 01:09:55.820]  Чтобы новая весовая функция
[01:09:55.820 --> 01:09:57.820]  Была у себя не отрицательна
[01:09:57.820 --> 01:09:59.820]  Это моя мечта
[01:09:59.820 --> 01:10:01.820]  Сделать, чтобы всегда все по фигу не отрицательны
[01:10:03.820 --> 01:10:05.820]  Если кости фиг все не отрицательны
[01:10:05.820 --> 01:10:07.820]  Тогда можно было
[01:10:07.820 --> 01:10:09.820]  На вот этом графе
[01:10:09.820 --> 01:10:11.820]  Измененной, обновленной весовой функции
[01:10:11.820 --> 01:10:13.820]  Пускать dx
[01:10:13.820 --> 01:10:15.820]  Ну а поскольку у меня кратчайшими
[01:10:15.820 --> 01:10:17.820]  Пути не изменились
[01:10:17.820 --> 01:10:19.820]  То dx я бы нашел те же самые
[01:10:19.820 --> 01:10:21.820]  Пути в исходном графе
[01:10:21.820 --> 01:10:23.820]  То есть то, что мы делаем dx
[01:10:23.820 --> 01:10:25.820]  Было бы тем, что нашел в исходном графе
[01:10:25.820 --> 01:10:27.820]  А dx лучше и быстрее
[01:10:27.820 --> 01:10:29.820]  Поэтому ее используем в реакции
[01:10:33.820 --> 01:10:35.820]  Вот
[01:10:37.820 --> 01:10:39.820]  Давайте это сделаем
[01:10:39.820 --> 01:10:41.820]  Мне нужна какая-то такая
[01:10:41.820 --> 01:10:43.820]  Потенциальная функция phi
[01:10:43.820 --> 01:10:45.820]  Я которую выполняю
[01:10:45.820 --> 01:10:47.820]  С этой границей
[01:10:47.820 --> 01:10:49.820]  Чтобы всегда не отрицательны
[01:10:49.820 --> 01:10:51.820]  То есть значит, что подойдет следующее
[01:10:51.820 --> 01:10:53.820]  Давайте просто возьмем
[01:10:53.820 --> 01:10:55.820]  И потенциально отрицаю
[01:10:55.820 --> 01:10:57.820]  А проделим вот так
[01:10:57.820 --> 01:10:59.820]  Дист и страх
[01:10:59.820 --> 01:11:01.820]  Ну, дист в терминах
[01:11:01.820 --> 01:11:03.820]  Исходные стоимость на функции course
[01:11:05.820 --> 01:11:07.820]  То есть у меня будет граф
[01:11:07.820 --> 01:11:09.820]  В начале же
[01:11:09.820 --> 01:11:11.820]  Там были своими стремностями
[01:11:11.820 --> 01:11:13.820]  Давайте посчитаем
[01:11:13.820 --> 01:11:15.820]  Простояние от S$
[01:11:15.820 --> 01:11:17.820]  Ну, как посчитаем
[01:11:17.820 --> 01:11:19.820]  Видим с помощью форда Беллона
[01:11:19.820 --> 01:11:21.820]  Все-таки один раз в год
[01:11:21.820 --> 01:11:23.820]  Их не придется
[01:11:23.820 --> 01:11:25.820]  Вот я один раз запущу форда Беллона
[01:11:25.820 --> 01:11:27.820]  Дист и страх
[01:11:27.820 --> 01:11:29.820]  Посчитаю все расстояния
[01:11:29.820 --> 01:11:31.820]  Вот этого всех решения
[01:11:31.820 --> 01:11:33.820]  Положу phi of V равным этому расстоянию
[01:11:33.820 --> 01:11:35.820]  А дальше
[01:11:35.820 --> 01:11:37.820]  Если я ввел такую
[01:11:37.820 --> 01:11:39.820]  потенциальную функцию
[01:11:39.820 --> 01:11:41.820]  То я отрицаю, что когда автоматически
[01:11:41.820 --> 01:11:43.820]  Все обновленные стоимости будут не отрицательны
[01:11:45.820 --> 01:11:47.820]  Вот почему я это делаю
[01:11:49.820 --> 01:11:51.820]  Что такое
[01:11:51.820 --> 01:11:53.820]  Коску вверх
[01:11:53.820 --> 01:11:55.820]  Плюс phi of U
[01:11:55.820 --> 01:11:57.820]  А мне нужно, чтобы больше phi of V
[01:11:57.820 --> 01:11:59.820]  А вот если это вверх
[01:11:59.820 --> 01:12:01.820]  То все обновленные стоимости будут не отрицательны
[01:12:05.820 --> 01:12:07.820]  Ну понятно, почувствую phi of V
[01:12:07.820 --> 01:12:09.820]  Это кратчайшее расстояние от S$
[01:12:09.820 --> 01:12:11.820]  А что написано слева
[01:12:11.820 --> 01:12:13.820]  Это кратчайшее от S$
[01:12:13.820 --> 01:12:15.820]  Плюс phi of S$
[01:12:15.820 --> 01:12:17.820]  Ну тогда понятно, что
[01:12:17.820 --> 01:12:19.820]  Оптимальная, самая короткая
[01:12:19.820 --> 01:12:21.820]  Стояние от S$
[01:12:21.820 --> 01:12:23.820]  Слева написано потом в путь
[01:12:23.820 --> 01:12:25.820]  Сначала от S$
[01:12:25.820 --> 01:12:27.820]  И потом плюс phi of U
[01:12:27.820 --> 01:12:29.820]  А справа написано как-то
[01:12:29.820 --> 01:12:31.820]  Самый короткий от S$
[01:12:33.820 --> 01:12:35.820]  Значит это вверх
[01:12:35.820 --> 01:12:37.820]  Мораль такая, что
[01:12:37.820 --> 01:12:39.820]  Если у меня потенциальная функция
[01:12:39.820 --> 01:12:41.820]  Совтадает с функцией расстояния
[01:12:41.820 --> 01:12:43.820]  То обновленные
[01:12:43.820 --> 01:12:45.820]  Стояния всегда не отрицательны
[01:12:45.820 --> 01:12:47.820]  То есть из этого
[01:12:47.820 --> 01:12:49.820]  Следует, что
[01:12:49.820 --> 01:12:51.820]  Сюда не отрицательны
[01:12:53.820 --> 01:12:55.820]  Мы считаем, что у нас к вам граждан
[01:12:55.820 --> 01:12:57.820]  Не было отрицательных
[01:12:57.820 --> 01:12:59.820]  Да
[01:12:59.820 --> 01:13:01.820]  Ну, собственно, у меня и вот этот инженер
[01:13:01.820 --> 01:13:03.820]  Работает только в предположенном состоянии
[01:13:03.820 --> 01:13:05.820]  Что где-то есть
[01:13:05.820 --> 01:13:07.820]  Упражнение 17
[01:13:11.820 --> 01:13:13.820]  А в последнем у нас записано
[01:13:13.820 --> 01:13:15.820]  Кост phi
[01:13:15.820 --> 01:13:17.820]  Да, кост phi
[01:13:17.820 --> 01:13:19.820]  Кост УВ
[01:13:19.820 --> 01:13:21.820]  А, просто кост
[01:13:21.820 --> 01:13:23.820]  Да, просто кост, phi, phi, phi
[01:13:27.820 --> 01:13:29.820]  А Дист СВ это
[01:13:29.820 --> 01:13:31.820]  В терминах стоимость
[01:13:31.820 --> 01:13:33.820]  Да
[01:13:33.820 --> 01:13:35.820]  Давайте подишем терминку
[01:13:47.820 --> 01:13:49.820]  Так же
[01:13:49.820 --> 01:13:51.820]  Ну, хорошо
[01:13:51.820 --> 01:13:53.820]  Значит, тогда
[01:13:53.820 --> 01:13:55.820]  Как будет устроено дарение?
[01:13:55.820 --> 01:13:57.820]  Сначала, ну, если я все-таки хочу
[01:13:57.820 --> 01:13:59.820]  Использовать потенциалы, то мне сначала
[01:13:59.820 --> 01:14:01.820]  Нужно будет впустить хотя бы раздольчик
[01:14:01.820 --> 01:14:03.820]  Который добавлен, чтобы найти вот эту функцию
[01:14:03.820 --> 01:14:05.820]  Давайте его запущу, найдет все потенциалы
[01:14:05.820 --> 01:14:07.820]  Тогда, что после этого
[01:14:07.820 --> 01:14:09.820]  Происходит?
[01:14:09.820 --> 01:14:11.820]  После этого я перехожу
[01:14:11.820 --> 01:14:13.820]  К обновленной сети, где уже все
[01:14:13.820 --> 01:14:15.820]  Стоимости не отрицательны
[01:14:15.820 --> 01:14:17.820]  Стоимости не отрицательны
[01:14:19.820 --> 01:14:21.820]  Тогда понятно, что
[01:14:21.820 --> 01:14:23.820]  Кращевший курс ЗСФ
[01:14:23.820 --> 01:14:25.820]  Он на самом деле
[01:14:25.820 --> 01:14:27.820]  Будет идти по ребраму
[01:14:27.820 --> 01:14:29.820]  Строго нулевого веса
[01:14:31.820 --> 01:14:33.820]  Все ребра на этой пути будут иметь
[01:14:33.820 --> 01:14:35.820]  Строго нулевой вес
[01:14:35.820 --> 01:14:37.820]  Терминах новой весовой зоны
[01:14:37.820 --> 01:14:39.820]  Ну, почему?
[01:14:39.820 --> 01:14:41.820]  Потому что phi это просто
[01:14:41.820 --> 01:14:43.820]  И они идти
[01:14:43.820 --> 01:14:45.820]  Вот на этом прочахе пути
[01:14:45.820 --> 01:14:47.820]  На настоящем прочахе пути
[01:14:47.820 --> 01:14:49.820]  ЗСФ
[01:14:49.820 --> 01:14:51.820]  Я на каждом ремне написал
[01:14:51.820 --> 01:14:53.820]  Стоимость, плюс расстояние до начала
[01:14:53.820 --> 01:14:55.820]  И минус расстояние до конца
[01:14:55.820 --> 01:14:57.820]  Потому что потенциалы в этих точках
[01:14:57.820 --> 01:14:59.820]  Отличаются на месте этого ребра
[01:14:59.820 --> 01:15:01.820]  И я здесь отставал вес и минус
[01:15:01.820 --> 01:15:03.820]  Разный потенциал
[01:15:03.820 --> 01:15:05.820]  Поэтому все обновленные стоимости
[01:15:05.820 --> 01:15:07.820]  Будут на этом где отрицательны
[01:15:07.820 --> 01:15:09.820]  Значит, что? Ну, окей
[01:15:09.820 --> 01:15:11.820]  Вот у меня сегодня будет ЗСФ
[01:15:11.820 --> 01:15:13.820]  У меня есть ЗСФ
[01:15:13.820 --> 01:15:15.820]  Потому что все ребра нулевого веса
[01:15:15.820 --> 01:15:17.820]  Когда я протягиваю дичьку потока
[01:15:17.820 --> 01:15:19.820]  У меня возникает обратные ребра
[01:15:21.820 --> 01:15:23.820]  Но на них тоже получается нулевой
[01:15:23.820 --> 01:15:25.820]  Нулевать
[01:15:25.820 --> 01:15:27.820]  Потому что у меня всегда кости
[01:15:27.820 --> 01:15:29.820]  Минус кость получается
[01:15:29.820 --> 01:15:31.820]  Значит, в этом графе
[01:15:31.820 --> 01:15:33.820]  Эти серебра тоже имеют нулевой кост
[01:15:35.820 --> 01:15:37.820]  Ну, нулевую в стоимости
[01:15:37.820 --> 01:15:39.820]  В терминах новой
[01:15:39.820 --> 01:15:41.820]  Потому что если я пустил дичьку потока
[01:15:41.820 --> 01:15:43.820]  на другого ребра
[01:15:43.820 --> 01:15:45.820]  Появилась обратная тоже в стоимости
[01:15:47.820 --> 01:15:49.820]  Вот
[01:15:49.820 --> 01:15:51.820]  Ну, и там возможно какие-то из этих пропали
[01:15:51.820 --> 01:15:53.820]  Потому что они нашитились
[01:15:53.820 --> 01:15:55.820]  Какие-то из ребров с левого права могли пропасть
[01:15:55.820 --> 01:15:57.820]  Но при этом пока что отрицательных фермеров
[01:15:57.820 --> 01:15:59.820]  Не появились
[01:15:59.820 --> 01:16:01.820]  Но зато у меня
[01:16:01.820 --> 01:16:03.820]  Возможно, могло сломаться эту тарабища
[01:16:05.820 --> 01:16:07.820]  Потому что граф как-то поменялся
[01:16:07.820 --> 01:16:09.820]  Если бы я не добавил фермеров
[01:16:09.820 --> 01:16:11.820]  Возможно, вот эта тарабища бы нарушилась
[01:16:11.820 --> 01:16:13.820]  Но граф по-прежнему
[01:16:13.820 --> 01:16:15.820]  Не отрицательный
[01:16:15.820 --> 01:16:17.820]  Поэтому
[01:16:17.820 --> 01:16:19.820]  Чтобы пересчитать
[01:16:19.820 --> 01:16:21.820]  Чтобы обновить
[01:16:21.820 --> 01:16:23.820]  Чтобы вот эта возраста сохранялась
[01:16:23.820 --> 01:16:25.820]  Я могу уже дейсты пускать
[01:16:25.820 --> 01:16:27.820]  Поскольку у меня серебра не отрицательная
[01:16:27.820 --> 01:16:29.820]  Вместо того чтобы еще раз считать потенциалы
[01:16:29.820 --> 01:16:31.820]  Я могу здесь пустить дейсту
[01:16:31.820 --> 01:16:33.820]  И пересчитать потенциалы уже по дейсту
[01:16:33.820 --> 01:16:35.820]  И после этого будет выполняться это свойство
[01:16:35.820 --> 01:16:37.820]  И значит можно будет еще и еще раз
[01:16:37.820 --> 01:16:39.820]  Пускать поток
[01:16:39.820 --> 01:16:41.820]  Пускать поток, пока что не будет
[01:16:49.820 --> 01:16:51.820]  Ну, давайте, во-первых, запишу какую-то процедуру
[01:16:51.820 --> 01:16:53.820]  И будет
[01:16:53.820 --> 01:16:55.820]  Применить потенциалы с ним
[01:16:55.820 --> 01:16:57.820]  Да, но это просто вот это преобразование
[01:16:57.820 --> 01:16:59.820]  Что я доказываю ребра
[01:16:59.820 --> 01:17:01.820]  Его вес
[01:17:01.820 --> 01:17:03.820]  Его вес
[01:17:03.820 --> 01:17:05.820]  Кибу вверх
[01:17:05.820 --> 01:17:07.820]  И изменяю на потенциал начало
[01:17:07.820 --> 01:17:09.820]  И потенциал конца
[01:17:09.820 --> 01:17:11.820]  И это министерная
[01:17:13.820 --> 01:17:15.820]  Вот
[01:17:15.820 --> 01:17:17.820]  А дальше, как у меня тут работа по коридору
[01:17:17.820 --> 01:17:19.820]  Я сначала один раз
[01:17:19.820 --> 01:17:21.820]  Запускаю форда Белман
[01:17:21.820 --> 01:17:23.820]  Из точки с
[01:17:23.820 --> 01:17:25.820]  Применяю этот потенциал
[01:17:25.820 --> 01:17:27.820]  То есть я не веду, что
[01:17:27.820 --> 01:17:29.820]  Форда Белман вовершает мне
[01:17:29.820 --> 01:17:31.820]  Список расстояния
[01:17:31.820 --> 01:17:33.820]  Список расстояния
[01:17:33.820 --> 01:17:35.820]  Дальше я ему применяю
[01:17:35.820 --> 01:17:37.820]  Как потенциал
[01:17:37.820 --> 01:17:39.820]  То есть я считаю, что потенциал равен расстоянию
[01:17:39.820 --> 01:17:41.820]  Поменял все стоимости всех ребер
[01:17:41.820 --> 01:17:43.820]  С помощью этой процедуры
[01:17:43.820 --> 01:17:45.820]  А дальше у вас только раз будут стоящие
[01:17:47.820 --> 01:17:49.820]  Вот так
[01:17:51.820 --> 01:17:53.820]  Ну, мне сложно сделать
[01:17:53.820 --> 01:17:55.820]  Нужно пустить днику потока
[01:17:55.820 --> 01:17:57.820]  Вдоль пути нулевого веса
[01:17:59.820 --> 01:18:01.820]  Вот я так и так и так и решу
[01:18:01.820 --> 01:18:03.820]  Пусти
[01:18:03.820 --> 01:18:05.820]  Днику потока
[01:18:07.820 --> 01:18:09.820]  Вдоль
[01:18:09.820 --> 01:18:11.820]  Пути
[01:18:11.820 --> 01:18:13.820]  Вдоль
[01:18:19.820 --> 01:18:21.820]  Вот, ну, там
[01:18:21.820 --> 01:18:23.820]  Например, можно сохранить было вот здесь
[01:18:23.820 --> 01:18:25.820]  Потому что я же только что пустил форда Белмана
[01:18:25.820 --> 01:18:27.820]  Я только что ушел пустить эти пути
[01:18:27.820 --> 01:18:29.820]  И так можно было бы сохранить
[01:18:29.820 --> 01:18:31.820]  Как выглядят все конкретные пути
[01:18:31.820 --> 01:18:33.820]  Вот вдоль вот этой пустить днику потока
[01:18:33.820 --> 01:18:35.820]  То есть я пускаю поток
[01:18:35.820 --> 01:18:37.820]  У меня возникают обратные ребра
[01:18:37.820 --> 01:18:39.820]  Вот
[01:18:39.820 --> 01:18:41.820]  Призникают
[01:18:43.820 --> 01:18:45.820]  Обратные
[01:18:45.820 --> 01:18:47.820]  Ребра
[01:18:47.820 --> 01:18:49.820]  Ну, а дальше просто беру
[01:18:49.820 --> 01:18:51.820]  Считаю номер потенциала с помощью DX
[01:18:51.820 --> 01:18:53.820]  И применяю его
[01:19:13.820 --> 01:19:15.820]  Вот, я буквально сделал
[01:19:15.820 --> 01:19:17.820]  То, что я сказал
[01:19:17.820 --> 01:19:19.820]  А я сначала перешел к новой
[01:19:19.820 --> 01:19:21.820]  Стоимость этой функции
[01:19:21.820 --> 01:19:23.820]  И я считаю, что все косты теперь мне не отрицают
[01:19:23.820 --> 01:19:25.820]  Вот в этот момент все косты не отрицают
[01:19:25.820 --> 01:19:27.820]  Дальше
[01:19:27.820 --> 01:19:29.820]  Я должен буду пускать по единичке потока
[01:19:29.820 --> 01:19:31.820]  Вдоль кратчайших пути из SVT
[01:19:31.820 --> 01:19:33.820]  Посмотрите, поскольку
[01:19:33.820 --> 01:19:35.820]  Я сюда захожу
[01:19:35.820 --> 01:19:37.820]  Либо после вот этого форда Белмана, либо после вот этого Dexter
[01:19:37.820 --> 01:19:39.820]  Ну, значит, к этому моменту
[01:19:39.820 --> 01:19:41.820]  Я вот только что посчитал все кратчайшие состояния в графе
[01:19:41.820 --> 01:19:43.820]  Значит, я знаю кратчайший путь из SVT
[01:19:43.820 --> 01:19:45.820]  Я по нему могу пустить днику потока
[01:19:45.820 --> 01:19:47.820]  Я пускаю поток
[01:19:47.820 --> 01:19:49.820]  Граф перестроился
[01:19:49.820 --> 01:19:51.820]  Но в нем все еще
[01:19:51.820 --> 01:19:53.820]  Все стоимости не отрицательны
[01:19:53.820 --> 01:19:55.820]  Ну, например, нарушиваются
[01:19:55.820 --> 01:19:57.820]  Ну, хорошо, а давайте пущу Dexter
[01:19:57.820 --> 01:19:59.820]  Поскольку все стоимости не отрицательны
[01:19:59.820 --> 01:20:01.820]  Я могу его пускать
[01:20:01.820 --> 01:20:03.820]  Я пущу Dexter, посчитал саму функцию
[01:20:03.820 --> 01:20:05.820]  Опять-таки, да, посчитал все состояния
[01:20:05.820 --> 01:20:07.820]  И применил ее, чтобы опять
[01:20:07.820 --> 01:20:09.820]  То есть я опять пересчитал все стоимости
[01:20:09.820 --> 01:20:11.820]  Так, чтобы
[01:20:13.820 --> 01:20:15.820]  Ну, то есть с учетом такого потенциала
[01:20:15.820 --> 01:20:17.820]  А значит, когда все опять все стоимости не отрицательны
[01:20:17.820 --> 01:20:19.820]  Я могу опять пускать поток
[01:20:19.820 --> 01:20:21.820]  Дольни волны
[01:20:23.820 --> 01:20:25.820]  То есть вы пускаете поток
[01:20:25.820 --> 01:20:27.820]  И потом пропишешься
[01:20:27.820 --> 01:20:29.820]  И работаем сразу с функцией, да?
[01:20:29.820 --> 01:20:31.820]  Ну, конечно, да, конечно
[01:20:35.820 --> 01:20:37.820]  Вот
[01:20:37.820 --> 01:20:39.820]  Ну, учетом асинтозика давайте ставим
[01:20:39.820 --> 01:20:41.820]  Скорее всего это не понятно
[01:20:41.820 --> 01:20:43.820]  Асинтозика
[01:20:43.820 --> 01:20:45.820]  Ну, как раз Dexter
[01:20:45.820 --> 01:20:47.820]  С Fordown мы работаем за V&E
[01:20:47.820 --> 01:20:49.820]  А Dexter, ну, если заморочится
[01:20:49.820 --> 01:20:51.820]  И, кстати, мы начнем пущу, то
[01:20:51.820 --> 01:20:53.820]  Делаем V&E
[01:20:57.820 --> 01:20:59.820]  Понятно, это у Ксилия лучше, чем KV&E
[01:20:59.820 --> 01:21:01.820]  Что было исходно в Fordown
[01:21:09.820 --> 01:21:11.820]  Не, ну почему?
[01:21:11.820 --> 01:21:13.820]  Сколько у нас работает?
[01:21:13.820 --> 01:21:15.820]  А, я финиш сказал
[01:21:15.820 --> 01:21:17.820]  Это как-то без финиш
[01:21:17.820 --> 01:21:19.820]  Это с бинарной пущей
[01:21:21.820 --> 01:21:23.820]  Вот, если заморочится
[01:21:23.820 --> 01:21:25.820]  Другую выводую
[01:21:25.820 --> 01:21:27.820]  Если заморочится
[01:21:27.820 --> 01:21:29.820]  Другую выводую
[01:21:33.820 --> 01:21:35.820]  Но даже без V&E все равно получается хорошей
[01:21:37.820 --> 01:21:39.820]  Ну, вот на этом все, спасибо
