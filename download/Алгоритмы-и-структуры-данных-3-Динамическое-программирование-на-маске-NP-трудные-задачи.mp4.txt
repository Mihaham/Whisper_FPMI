[00:00.000 --> 00:08.000]  Что мы научились кодировать эффективно под множество
[00:08.000 --> 00:13.880]  маленького множества, то есть если у меня есть множество
[00:13.880 --> 00:16.800]  из этих n элементов, то я могу любому под множество
[00:16.800 --> 00:20.180]  сопоставить битовую строчку, где на этом месте стоит
[00:20.180 --> 00:22.440]  единица, если элемент включен в множестве, ноль если не
[00:22.440 --> 00:23.440]  включен.
[00:23.440 --> 00:25.240]  Ну и соответственно эту битовую строчку могу воспринимать
[00:25.240 --> 00:29.560]  как число в дольше системе числения и хранить подножие
[00:29.560 --> 00:30.560]  как числа.
[00:30.560 --> 00:34.720]  Ну вот, я буду жить обычно в парадигме, что n там какой-нибудь
[00:34.720 --> 00:39.600]  маленький, а пора это 30 или 60, так чтобы это число помещалось
[00:39.600 --> 00:43.800]  в какой-нибудь простой тип, маленький там int или long
[00:43.800 --> 00:46.800]  clonk.
[00:46.800 --> 00:53.840]  Ну давайте начнем с такой видимо задачи, поиск максимальных
[00:53.840 --> 00:54.840]  клики в графе.
[00:54.840 --> 01:20.600]  Задача такая, у вас есть граф, наверное, на вершинах,
[01:20.600 --> 01:22.960]  и между какими-то парами из них проведены ребра,
[01:23.120 --> 01:25.640]  то есть просто какие-то вершины соединены отрезками,
[01:25.640 --> 01:26.640]  соединили ребрами.
[01:26.640 --> 01:31.560]  Еще вам сказано, какие есть ребра, ну скажем, граф
[01:31.560 --> 01:42.320]  задан на матрице смежности своей, вот, и кликой в графе
[01:42.320 --> 01:46.160]  называется какое-то множество вершин, которые попарно
[01:46.160 --> 01:47.160]  соединены ребрами.
[01:47.160 --> 01:51.040]  Например, вот эти три вершинки образуют клику, потому что
[01:51.320 --> 01:54.400]  между каждой парой из них есть ребро, есть такое-такое-такое
[01:54.400 --> 01:56.360]  ребро, между каждой парой есть ребро.
[01:56.360 --> 02:00.160]  А, например, если бы я рассмотрел вот эти три вершины, то они
[02:00.160 --> 02:02.600]  клик уже не образуют, потому что вот здесь вот нет ребра.
[02:02.600 --> 02:08.440]  Ну и задача, собственно, найти клику максимального
[02:08.440 --> 02:11.120]  размера в данном графе, на вершинах.
[02:11.120 --> 02:23.240]  Вот, ну давайте сразу напишем решение за что-то в стиле
[02:23.240 --> 02:24.240]  два в степени N.
[02:24.240 --> 02:30.200]  Ну, значит, про эту задачу тоже известно, что она NP-трудная,
[02:30.200 --> 02:33.720]  то есть пока что никому никаких полинональных алгоритмов
[02:33.720 --> 02:38.000]  для нее не известно, и, ну, в общем, есть большой
[02:38.880 --> 02:41.240]  скептицизм в отношении того, что они вообще, такие
[02:41.240 --> 02:42.240]  алгоритмы существуют.
[02:42.240 --> 02:45.000]  Поэтому, ну, вот экспонентов в таких случаях обычно
[02:45.000 --> 02:47.240]  лучше, на что можем рассчитывать.
[02:47.240 --> 02:51.200]  Вот, ну, остальная идея здесь очень простая.
[02:51.200 --> 02:52.720]  Давайте просто переберем все возможные подножия
[02:52.720 --> 02:56.200]  вершин, их будет ровно два в степени N, и для каждого
[02:56.200 --> 02:58.400]  подножия проверим, хорошее оно или нет, то есть проверим,
[02:58.400 --> 02:59.400]  является оно клик или нет.
[02:59.400 --> 03:04.480]  И затем просто из всех хороших подножий, всех клик
[03:04.480 --> 03:07.040]  выберем максимальное по мощности, то, где наибольшее
[03:07.080 --> 03:08.080]  число битов хранится.
[03:08.080 --> 03:12.360]  Вот, ну, как проверить, что данное множество вершин
[03:12.360 --> 03:13.360]  является кликой?
[03:13.360 --> 03:16.920]  То есть надо, видимо, проверить, ну, наивно, можно было просто
[03:16.920 --> 03:19.000]  пробежаться по всем вершинам и проверить, что между каждой
[03:19.000 --> 03:22.960]  парой вершин есть ребро, если они в множестве лежат.
[03:22.960 --> 03:26.520]  Вот, ну, это было бы что-то в стиле два в степени N на
[03:26.520 --> 03:29.200]  N в квадрате, потому что если я каждую пару вершин перебираю,
[03:29.200 --> 03:34.200]  то там N в квадрате будет все множить.
[03:34.360 --> 03:38.800]  Ну, можно как-то делать.
[03:38.800 --> 03:49.800]  А что мы делаем в прошлом семестре?
[03:49.800 --> 03:52.040]  Ну тут они отрезки, тут же как бы комбинаторный
[03:52.040 --> 03:56.280]  прямоугольник, типа у вас там 1, 10, 13 вершина, ну в смысле
[03:56.280 --> 03:59.760]  вот такие столцы, такие строки, это как бы, ну,
[03:59.760 --> 04:03.400]  подматрица вот такого именно, вот такого вида, да, это
[04:03.600 --> 04:05.600]  уже не прямоугольник, а что-то вот такое.
[04:05.600 --> 04:08.600]  И тут считать сумму как-то быстро непонятно как.
[04:11.600 --> 04:12.600]  Вот.
[04:16.600 --> 04:18.600]  Ну, мы давайте сделаем примерно следующее.
[04:18.600 --> 04:22.800]  Давайте мы ведем динамику, которая нам для любого множества
[04:22.800 --> 04:26.700]  вершин говорит множество тех, которые являются соседями
[04:26.700 --> 04:29.700]  всех вершин этого множества.
[04:30.000 --> 04:33.000]  Ну, и правильно давайте напишу, что dp вот в какой-нибудь
[04:33.000 --> 04:37.000]  маске, где маска это множество вершин, да, какое это множество
[04:37.000 --> 04:44.000]  вершин, значит, это множество всех вершин графа,
[04:48.000 --> 04:51.000]  которые соединились со всеми вершинами из маски.
[04:59.700 --> 05:16.200]  Так, мы, видимо, на всякий случай давайте еще вторую
[05:16.200 --> 05:17.200]  динамику.
[05:17.200 --> 05:20.200]  Значит, это будет что-то типа int, да, потому что у меня,
[05:20.200 --> 05:22.200]  ну, я буду хранить множество, но множество я храню как
[05:22.200 --> 05:24.200]  число, да, как обычно.
[05:24.200 --> 05:27.200]  Вот, поэтому это будет что-то intовское, и мне нужна еще
[05:27.700 --> 05:30.700]  видимо вторая динамика, булевская, просто является
[05:30.700 --> 05:31.700]  ли множество клика.
[05:31.700 --> 05:35.700]  Да, это просто булевский флаг является ли множество
[05:35.700 --> 05:36.700]  клика или нет.
[05:36.700 --> 05:40.700]  Вот, тогда что можно сделать?
[05:40.700 --> 05:43.700]  Смотрите, вот представьте, что мы рассматриваем какое-то
[05:43.700 --> 05:46.700]  множество вершин маск, мы хотим проверить, является
[05:46.700 --> 05:47.700]  ли оно клика или нет.
[05:47.700 --> 05:52.700]  Тогда нам достаточно сделать на самом деле следующее,
[05:52.700 --> 05:56.700]  мы можем отщипать отсюда одну-любую вершинку v и проверить
[05:57.200 --> 06:01.200]  во-первых, что все остальное это клика, во-вторых, что
[06:01.200 --> 06:04.200]  v соединяется с ними со всеми.
[06:04.200 --> 06:09.200]  Так, это я даже получается лишним, ну ладно, бог с ним,
[06:09.200 --> 06:10.200]  пусть останется.
[06:10.200 --> 06:14.200]  Значит, еще раз, чтобы маска была кликой, я могу выкинуть
[06:14.200 --> 06:17.200]  любую вершину из нее, проверить, что все, что осталось, это
[06:17.200 --> 06:20.200]  клика, а также, что v со всеми ними соединена.
[06:20.200 --> 06:23.200]  Это как раз и будет означать, что все ребра в этом множестве
[06:23.200 --> 06:26.200]  есть, то есть все ребра внутри здесь есть и между v и всеми
[06:26.200 --> 06:27.700]  ними тоже есть.
[06:27.700 --> 06:31.700]  Вот, тогда мне достаточно сделать следующее.
[06:31.700 --> 06:35.700]  Клик от маски равно true, если, ну давайте пишем, равно
[06:35.700 --> 06:50.700]  true, если для некоторой вершины v, лежащей в маске, выполнено
[06:50.700 --> 06:51.700]  две вещи.
[06:51.700 --> 07:00.700]  Во-первых, маска без вершины v это клика, ее так очень
[07:00.700 --> 07:01.700]  вольно напишу.
[07:01.700 --> 07:06.200]  Ну понятно, чем я имею в виду маска, это множество
[07:06.200 --> 07:12.200]  вершин, set-minus это разность множеств, v это множество
[07:12.200 --> 07:13.200]  вершин.
[07:13.200 --> 07:16.200]  В коде это надо было бы, наверное, реализовать как-то
[07:17.200 --> 07:20.700]  маск, xor, 1 меньше меньше v.
[07:20.700 --> 07:22.700]  Ну вот что-то такое, потому что 1 меньше меньше v это как
[07:22.700 --> 07:26.200]  раз маска, отвечающая только вершинке v, потому что здесь
[07:26.200 --> 07:29.700]  есть только один бит на v этом месте, это как раз маска,
[07:29.700 --> 07:30.700]  содержащая только v.
[07:30.700 --> 07:34.700]  Ну и поскольку v лежала в маске, то их xor как раз вот
[07:34.700 --> 07:38.700]  эту вот единичку на v этом месте уничтожит и останется
[07:38.700 --> 07:39.700]  как раз маской без v.
[07:39.700 --> 07:42.700]  Значит, это нормально?
[07:43.200 --> 07:48.200]  Во-первых, вот эта штука должна быть равна true, во-вторых,
[07:48.200 --> 07:54.200]  v должна принадлежать dp от маск без v.
[07:58.200 --> 08:01.200]  Да, мне нужно, чтобы v была вот в этом множестве как
[08:01.200 --> 08:05.200]  раз, чтобы v попало в множество вершин, каждая из которых
[08:05.200 --> 08:08.200]  соединяется с каждой вершиной маск без v.
[08:08.200 --> 08:11.200]  Похоже на правду.
[08:11.700 --> 08:15.700]  Второе слово как раз означает, что все вот эти вот ребра есть.
[08:17.700 --> 08:19.700]  Так, ну хорошо.
[08:19.700 --> 08:22.700]  Значит, тогда как бы клик мы более-менее через клик
[08:22.700 --> 08:25.700]  уже пересчитали, выразили, точнее, надо теперь понять,
[08:25.700 --> 08:28.700]  как dp-шку посчитать, то есть как для данного множества
[08:28.700 --> 08:32.700]  вершин найти множество тех, которые с ними со всеми соединены.
[08:38.700 --> 08:40.700]  Ну давайте тоже какие-нибудь предложения жду.
[08:40.700 --> 08:43.200]  Вот, если у нас есть какая-нибудь v, то как выразить dp-маск
[08:43.200 --> 08:45.200]  через dp-маск без v?
[08:51.200 --> 08:54.200]  Ну пересечь скорее, да, пересечь.
[08:54.200 --> 09:02.200]  Значит, можно заметить, что dp-маск это dp для маски
[09:02.200 --> 09:08.200]  без v, а в пересечении с, ну по факту можно просто
[09:08.200 --> 09:14.200]  описать dp просто для v, да, фигурную скобку все-таки дорисую
[09:14.200 --> 09:16.200]  для приличия.
[09:20.200 --> 09:23.200]  Ну а потому что еще раз, что такое dp от маски?
[09:23.200 --> 09:28.200]  Это все такие чуваки, все такие вершины, которые соединены
[09:28.200 --> 09:30.200]  со всеми вершинами этого множества.
[09:30.200 --> 09:33.200]  Но при этом, если я для вот этой меньшей маски, для маски
[09:33.200 --> 09:36.200]  для множества меньшего размера знаю все вершины,
[09:36.200 --> 09:39.200]  соединенные с ними со всеми, то есть вот есть у меня маска
[09:39.200 --> 09:45.200]  без v, есть все вершины, которые соединены со всеми вершинами
[09:45.200 --> 09:47.200]  этого множества, вот они.
[09:47.200 --> 09:50.200]  Тогда если у меня в маску вот этого добавляется новая
[09:50.200 --> 09:53.200]  вершина v, то мне нужно, у меня появляется новое требование,
[09:53.200 --> 09:55.200]  что все эти вершины должны быть не только соедены,
[09:55.200 --> 09:56.200]  но еще и с v-шкой.
[09:56.200 --> 09:59.200]  Поэтому на них докладываются допусловия, ну и по факту
[09:59.200 --> 10:01.200]  я пересекаю просто два множества, те, которые соединены
[10:01.200 --> 10:04.200]  со всеми здесь, и еще и соедены с v.
[10:04.200 --> 10:06.200]  Вот это у меня есть dp-шка v.
[10:09.200 --> 10:11.200]  Ну, что-то такое.
[10:13.200 --> 10:15.200]  Значит, тогда можно сделать следующее.
[10:15.200 --> 10:17.200]  Давайте напишем алгоритм.
[10:18.200 --> 10:19.200]  Как он будет устроен?
[10:19.200 --> 10:23.200]  Ну, во-первых, раз я выражаю dp для каждой маски через dp
[10:23.200 --> 10:27.200]  по одноэлементным множествам, давайте я изначально для каждого v
[10:27.200 --> 10:33.200]  найду dp от множества из вершинки v.
[10:34.200 --> 10:36.200]  Ну, это понятно, как сделать, можно за квадрат.
[10:36.200 --> 10:37.200]  Это просто сделать.
[10:37.200 --> 10:40.200]  Я для каждой вершины v перебираю все вершинки u.
[10:40.200 --> 10:44.200]  Если есть ребро uv, то я в эту маску включаю, иначе не включаю.
[10:44.200 --> 10:46.200]  Да, это еза за квадрат.
[10:46.200 --> 10:49.200]  Для каждой вершины насчитываю маску соседей, по факту.
[10:50.200 --> 10:53.200]  Вот. Дальше мне нужно...
[10:56.200 --> 11:00.200]  Ну, и можно здесь же написать, что, скажем, клики
[11:00.200 --> 11:02.200]  от одноэлементных множеств.
[11:04.200 --> 11:07.200]  Ну, точнее, любое одноэлементное множество это клика.
[11:07.200 --> 11:12.200]  Если мы берем одну вершину, то там любые две вершины соединены ребром между собой,
[11:12.200 --> 11:14.200]  потому что там всего одна вершина.
[11:14.200 --> 11:17.200]  Значит, каждое одноэлементное множество это клика, ну и все.
[11:17.200 --> 11:20.200]  А дальше вот эти формулы пересчета для dp для клики.
[11:20.200 --> 11:28.200]  Дальше для всех маск в порядке...
[11:32.200 --> 11:34.200]  Ну, явно все в порядке возрастания.
[11:38.200 --> 11:41.200]  Мы, собственно, пишем вот эти две штуки, вот это и вот это.
[11:43.200 --> 11:45.200]  Насчитываем.
[11:50.200 --> 11:51.200]  Вот.
[11:58.200 --> 12:01.200]  Вот. По формулам с прошлой доски.
[12:04.200 --> 12:08.200]  Вот. Ну, и когда я пишу в порядке возрастания, можно буквально написать цикл
[12:08.200 --> 12:12.200]  для всех масок от нуля до два степени на минус один.
[12:12.200 --> 12:15.200]  Ну, и буквально перебирать их как чисто в порядке возрастания,
[12:15.200 --> 12:23.200]  потому что, смотрите, у нас обе dp и клика, и dp выражаются через маски,
[12:23.200 --> 12:25.200]  которые являются под множеством текущей маски.
[12:25.200 --> 12:27.200]  То есть маска без какой-то вершины v.
[12:27.200 --> 12:31.200]  Ну, понятно, что если мы просто маской перебираем в порядке возрастания как чисел,
[12:31.200 --> 12:35.200]  тогда в момент рассмотрения маски вот это уже будет рассмотрено,
[12:35.200 --> 12:37.200]  потому что это меньшее число просто.
[12:37.200 --> 12:41.200]  Оно включено сюда, значит, как число, ну там, в дешней системе числения.
[12:41.200 --> 12:42.200]  Оно меньше.
[12:42.200 --> 12:46.200]  Поэтому к моменту рассмотрения маски мы все предыдущие уже рассмотрели,
[12:46.200 --> 12:48.200]  все предыдущие нужные значения уже посчитаны.
[12:51.200 --> 12:53.200]  Так. Нормально?
[12:57.200 --> 13:01.200]  Вот. Теперь вопрос, да, как находить вот это?
[13:04.200 --> 13:10.200]  Ну, нам на самом деле не нужно перебирать все вершины, нам достаточно какую-то одну найти.
[13:10.200 --> 13:14.200]  То есть чтобы завершить решение, мне нужно показать, как я для любой маски
[13:14.200 --> 13:17.200]  нахожу какой-нибудь bit в ней,
[13:17.200 --> 13:19.200]  какую-нибудь вершина, которая в ней включена.
[13:19.200 --> 13:21.200]  Ну, делается тоже не очень сложно.
[13:21.200 --> 13:23.200]  Можно делать, например, так.
[13:23.200 --> 13:26.200]  Давайте раз мы маской перебираем в порядке возрастания,
[13:26.200 --> 13:30.200]  давайте хранить старший включенный bit в маске.
[13:33.200 --> 13:35.200]  Давайте не пишу oldest.
[13:35.200 --> 13:42.200]  Это старший bit в текущей маске.
[13:46.200 --> 13:49.200]  Ну, поскольку у меня здесь есть некая свобода выбора,
[13:49.200 --> 13:52.200]  я в качестве V могу выбирать любую вершину множества,
[13:52.200 --> 13:54.200]  давайте я буду выбирать вершину с наибольшим номером.
[13:54.200 --> 13:58.200]  Ну, то есть по факту старший bit в маске, который там есть, старшую 1.
[14:00.200 --> 14:02.200]  Ну, а этот oldest очень легко насчитывать,
[14:02.200 --> 14:06.200]  если мы перебираем маски в порядке возрастания, 1, 2, 3, 4 и так далее.
[14:06.200 --> 14:08.200]  Потому что когда у вас меняется oldest,
[14:08.200 --> 14:11.200]  вот вы перебираете маски в порядке возрастания,
[14:11.200 --> 14:15.200]  когда у вас в этом двоичном числе сменяется старший bit?
[14:17.200 --> 14:19.200]  Ну понятно, когда.
[14:20.200 --> 14:22.200]  Понятно же?
[14:22.200 --> 14:24.200]  Когда?
[14:24.200 --> 14:32.200]  Можно сказать так, да.
[14:32.200 --> 14:34.200]  Можно сказать так, да, действительно.
[14:34.200 --> 14:36.200]  Начну, давайте еще что-нибудь напишу.
[14:36.200 --> 14:39.200]  Вот у меня есть сначала такая маска, потом вот такая маска,
[14:39.200 --> 14:42.200]  потом вот такая маска, потом такая маска, ну и так далее.
[14:42.200 --> 14:46.200]  Понятно, что старший bit переключается, когда мы переходим к следующей степени двойки.
[14:46.200 --> 14:50.200]  Вот у меня здесь старший bit был, теперь вот этот старший bit,
[14:50.200 --> 14:53.200]  когда мы перешли в степень двойки такую-то.
[14:53.200 --> 14:57.200]  Следующий старший bit, когда мы переходим в следующую степень двойки и так далее.
[14:57.200 --> 15:01.200]  Вот, ну то есть у нас старший bit переключается, когда у нас маска переваливает за новую степень двойки.
[15:01.200 --> 15:05.200]  Да, можно, например, чтобы проверить, что текущий число этой степени двойки,
[15:05.200 --> 15:09.200]  ну мы когда это делали, когда спар стейбл писали, кажется,
[15:09.200 --> 15:11.200]  как проверить, что число является степень двойки?
[15:11.200 --> 15:14.200]  Например, можно поцелуете его с предыдущим,
[15:14.200 --> 15:17.200]  и если получится 0, то значит степень двойки.
[15:18.200 --> 15:22.200]  Давайте напишем, что oldest увеличивается на 1.
[15:29.200 --> 15:31.200]  И, да, спасибо, спасибо.
[15:32.200 --> 15:40.200]  Когда маска и маска минус 1 равно 0.
[15:41.200 --> 15:47.200]  Ну, потому что если маска это степень двойки,
[15:47.200 --> 15:51.200]  то маска минус 1 это как раз 0 и все единички, их AND будет нулевой.
[15:51.200 --> 15:56.200]  Если маска не степень двойки, то там, ну, старшая единица сохранится.
[15:56.200 --> 15:59.200]  Если маска не степень двойки, то там есть по крайней мере две единицы в личной записи,
[15:59.200 --> 16:04.200]  и эта старшая единица останется здесь и здесь, и тогда AND будет не нулевой.
[16:04.200 --> 16:08.200]  Ну вот, поэтому мы получили критерий переключения старшего бита.
[16:08.200 --> 16:10.200]  Но если мы знаем старший бит, то мы можем просто сказать,
[16:10.200 --> 16:14.200]  что вот этот вот V здесь – это просто тот oldest, который мы насчитали.
[16:20.200 --> 16:22.200]  Так, понятно?
[16:25.200 --> 16:27.200]  Хорошо.
[16:27.200 --> 16:32.200]  Вот, ну, мы получили даже получается для каждого множества,
[16:32.200 --> 16:34.200]  мы узнали, является нуклика или нет.
[16:34.200 --> 16:35.200]  То есть по факту у меня есть отдельный массив,
[16:35.200 --> 16:39.200]  человек, который хранит просто флаг того, является ли это множество клика или не является.
[16:39.200 --> 16:42.200]  Дальше нужно из всех этих множеств выбрать самое большое,
[16:42.200 --> 16:45.200]  являющийся кликой.
[16:45.200 --> 16:47.200]  Ну, это, наверное, как-нибудь тоже можно сделать.
[16:47.200 --> 16:52.200]  Либо найти какую-нибудь встроенную функцию в вашем языке программирования,
[16:52.200 --> 16:55.200]  которая для маски находит количество включенных в ней бит,
[16:55.200 --> 16:57.200]  то есть размер множества узнает.
[16:57.200 --> 17:00.200]  Либо можно просто насчитать еще одну динамику,
[17:00.200 --> 17:04.200]  которая для каждого множества хранит размер множества.
[17:04.200 --> 17:07.200]  То есть можно для каждой маски просто хранить размер.
[17:07.200 --> 17:10.200]  И тоже понятно, как он пересчитывается.
[17:10.200 --> 17:12.200]  Если вы знаете, что V – это один из битов,
[17:12.200 --> 17:16.200]  тогда размер маски – это размер маски без V плюс один,
[17:16.200 --> 17:18.200]  потому что одна вершинка новая добавится.
[17:18.200 --> 17:22.200]  Либо просто как-нибудь понять,
[17:22.200 --> 17:27.200]  по факту нам надо узнать, сколько в этом числе единичек удачной записи.
[17:27.200 --> 17:35.200]  Ну, 32 – это все-таки не от единицы, наверное.
[17:35.200 --> 17:41.200]  Ну, константа. Все константа.
[17:41.200 --> 17:43.200]  Нет, тут так лучше не говорить,
[17:43.200 --> 17:45.200]  потому что у нас получается на самом деле N действия.
[17:45.200 --> 17:47.200]  Вы сделаете.
[17:47.200 --> 17:50.200]  Поэтому лучше это либо предпочитать,
[17:50.200 --> 17:51.200]  либо вызвать какую-нибудь функцию,
[17:51.200 --> 17:52.200]  которая это у меня делать.
[17:52.200 --> 17:54.200]  В плюсах такое точно есть.
[17:54.200 --> 17:57.200]  Какой-то поп-каунт считает как раз число единичек.
[17:57.200 --> 17:59.200]  Ну вот.
[18:04.200 --> 18:07.200]  Еще раз? Да, да, да.
[18:10.200 --> 18:12.200]  Еще раз?
[18:12.200 --> 18:15.200]  Потому что вот здесь я никаких условий на V не накладываю.
[18:15.200 --> 18:17.200]  V была произвольной вершиной из маски.
[18:17.200 --> 18:20.200]  То есть какая бы V ни была,
[18:20.200 --> 18:23.200]  вот это все является клика, если только если верно вот это вот.
[18:23.200 --> 18:25.200]  Это верно для любого V.
[18:25.200 --> 18:27.200]  Ну и дальше я просто для удобства выбираю V таким,
[18:27.200 --> 18:31.200]  какой мне удобнее всего хранить.
[18:35.200 --> 18:37.200]  Ну, могу им сказать для любого.
[18:37.200 --> 18:39.200]  Ну, это типа одно и то же.
[18:43.200 --> 18:45.200]  Ничего не меняется.
[18:45.200 --> 18:47.200]  Просто, ну, смотрите, вот здесь я как бы…
[18:47.200 --> 18:49.200]  Тут слово «некоторое» можно понять на «любое».
[18:49.200 --> 18:51.200]  Ничего не поменяется от этого.
[18:54.200 --> 18:57.200]  Не то что надо, нам достаточно получить для oldest.
[18:57.200 --> 18:59.200]  Можно было бы для любого другого бита,
[18:59.200 --> 19:01.200]  можно было бы, например, как-нибудь по-умному
[19:01.200 --> 19:03.200]  вычислять младший включенный бит в маске.
[19:03.200 --> 19:06.200]  Это как-то тоже наверное делается, но более сложно.
[19:06.200 --> 19:09.200]  И можно было бы вместо V использовать младший включенный бит.
[19:09.200 --> 19:12.200]  Ну вот я использую старший, потому что его проще всего находить.
[19:13.200 --> 19:15.200]  Можно любой другой.
[19:16.200 --> 19:19.200]  Так. Понятно? Да.
[19:20.200 --> 19:22.200]  Ну вот, это я говорю.
[19:22.200 --> 19:24.200]  Либо вы вызываете какую-то встроенную функцию,
[19:24.200 --> 19:27.200]  которая по числу определяет, сколько в нем единичек.
[19:28.200 --> 19:30.200]  Либо вы еще одну DP-шку насчитываете,
[19:30.200 --> 19:33.200]  которая для маски возвращает количество единиц.
[19:33.200 --> 19:35.200]  И она как-то так же пересчитывается,
[19:35.200 --> 19:37.200]  что если вы знаете вот сколько единиц здесь,
[19:37.200 --> 19:40.200]  то вот здесь на одну больше и все.
[19:44.200 --> 19:45.200]  Так.
[19:46.200 --> 19:49.200]  Хорошо. Теперь давайте обсудим решение
[19:49.200 --> 19:51.200]  за ассинточку покруче.
[19:54.200 --> 19:56.200]  Два степени напополам.
[19:58.200 --> 20:01.200]  Соответственно, если это адекватно работало там
[20:01.200 --> 20:04.200]  для N порядка 20-25,
[20:04.200 --> 20:07.200]  то здесь уже N порядка 50-60 возможно.
[20:07.200 --> 20:09.200]  Будет нормально работать.
[20:09.200 --> 20:11.200]  Вот.
[20:13.200 --> 20:16.200]  Ну, здесь основная идея называется
[20:16.200 --> 20:18.200]  meet in the middle.
[20:20.200 --> 20:22.200]  То есть давайте мы разделим
[20:22.200 --> 20:25.200]  нашу задачу на две примерно равные части.
[20:25.200 --> 20:27.200]  Поделим нашу задачу пополам.
[20:27.200 --> 20:29.200]  Скажем, вот здесь N пополам
[20:29.200 --> 20:30.200]  первых решенграфов,
[20:30.200 --> 20:33.200]  и здесь N пополам оставшихся решенграфов.
[20:33.200 --> 20:35.200]  Ну, если они нечетные, то там
[20:35.200 --> 20:37.200]  примерно поровну поделим.
[20:38.200 --> 20:40.200]  Давайте поделим все вершины
[20:40.200 --> 20:42.200]  на две равные части, например.
[20:43.200 --> 20:46.200]  Тогда любая клика выглядит
[20:46.200 --> 20:48.200]  ну, как-то так.
[20:48.200 --> 20:50.200]  Ну, это сколько-то вершин в левой доле
[20:50.200 --> 20:52.200]  и сколько-то вершин в правой доле.
[20:55.200 --> 20:57.200]  Причем для того, чтобы все это вместе
[20:57.200 --> 20:59.200]  была клика, мне нужно выполнить
[20:59.200 --> 21:00.200]  три условия.
[21:00.200 --> 21:02.200]  Во-первых, вот это вот эта клика.
[21:02.200 --> 21:04.200]  Во-вторых, вот это вот эта клика.
[21:04.200 --> 21:06.200]  И в-третьих, для любой пары
[21:06.200 --> 21:08.200]  отсюда и отсюда есть ребро.
[21:10.200 --> 21:12.200]  Чтобы были все попарные ребра,
[21:12.200 --> 21:14.200]  мне нужно, чтобы это было кликой,
[21:14.200 --> 21:15.200]  это было кликой.
[21:15.200 --> 21:17.200]  Ну, и все ребра слева направо тоже.
[21:24.200 --> 21:26.200]  Ну, тогда давайте сделаем примерно следующее.
[21:28.200 --> 21:30.200]  Смотрите, мне нужно будет
[21:30.200 --> 21:32.200]  несколько вещей.
[21:32.200 --> 21:34.200]  Первая идея такая. Давайте перебирать
[21:34.200 --> 21:36.200]  вот это вот множество.
[21:36.200 --> 21:38.200]  Потому что эта левая доля
[21:38.200 --> 21:40.200]  имеет размер примерно на пополам,
[21:40.200 --> 21:42.200]  то под множество у него как раз примерно
[21:42.200 --> 21:44.200]  два степени на пополам. Давайте переберем
[21:44.200 --> 21:46.200]  какое-нибудь под множество, которое является кликой.
[21:46.200 --> 21:48.200]  Давайте переберем здесь какое-то под множество.
[21:50.200 --> 21:52.200]  Дальше мне хочется понять,
[21:52.200 --> 21:54.200]  как его можно продолжить
[21:54.200 --> 21:56.200]  до клики справа. То есть какие вершины
[21:56.200 --> 21:58.200]  из правой доли можно к нему подсоединить,
[21:58.200 --> 22:00.200]  чтобы все вместе была одна большая клика.
[22:00.200 --> 22:02.200]  Мне нужно вот здесь там кого-то взять,
[22:02.200 --> 22:04.200]  во-первых, это была кликой,
[22:04.200 --> 22:06.200]  во-вторых, они все были попарно соединены
[22:06.200 --> 22:08.200]  между долями.
[22:08.200 --> 22:10.200]  Мне нужно как-то найти вот такое самое большое множество
[22:10.200 --> 22:12.200]  из правой доли, которое, во-первых,
[22:12.200 --> 22:14.200]  само клика, во-вторых, соединено
[22:14.200 --> 22:16.200]  вот с этими со всеми товарищами.
[22:32.200 --> 22:34.200]  Так.
[22:36.200 --> 22:38.200]  Окей.
[22:38.200 --> 22:40.200]  Значит, иду дальше. Давайте я
[22:40.200 --> 22:42.200]  для удобства реализации введу
[22:42.200 --> 22:44.200]  одинаковую нумерацию на обеих долях, скажу,
[22:44.200 --> 22:46.200]  что здесь вершины пронумерованы
[22:46.200 --> 22:48.200]  числами от навязанных пополам у нас один.
[22:48.200 --> 22:50.200]  И здесь тоже вершины также пронумерованы.
[22:58.200 --> 23:00.200]  Теперь я введу
[23:00.200 --> 23:02.200]  первую штуку.
[23:06.200 --> 23:08.200]  Давайте я ее назову DP просто.
[23:10.200 --> 23:12.200]  Значит, первая DP-шка следующая.
[23:12.200 --> 23:14.200]  Это вот как раз
[23:14.200 --> 23:16.200]  для каждой маски вершин левой доли, пусть вот
[23:16.200 --> 23:18.200]  этот вот маск.
[23:18.200 --> 23:20.200]  Первое, что я хочу сделать, это определить множество
[23:20.200 --> 23:22.200]  всех вообще допустимых вершин справа.
[23:22.200 --> 23:24.200]  То есть я хочу узнать, какие
[23:24.200 --> 23:26.200]  вершины справа соединены со всеми вершинной
[23:26.200 --> 23:28.200]  маски.
[23:28.200 --> 23:30.200]  Это вот на самом деле то, что у меня было
[23:30.200 --> 23:32.200]  в прошлом случае.
[23:32.200 --> 23:34.200]  DP вот маск, где маска это какое-то под множество
[23:34.200 --> 23:36.200]  левой доли, это множество
[23:38.200 --> 23:40.200]  всех вершин
[23:40.200 --> 23:42.200]  из R,
[23:42.200 --> 23:44.200]  которые соединены со всеми вершинами маски.
[23:54.200 --> 23:56.200]  Но это буквально то же, что было
[23:56.200 --> 23:58.200]  в прошлый раз, только там у меня
[23:58.200 --> 24:00.200]  не было такого разделения на левую и правую долю,
[24:00.200 --> 24:02.200]  а здесь я ищу как бы не все вершины,
[24:02.200 --> 24:04.200]  а только те, которые в правую долю лежат.
[24:04.200 --> 24:06.200]  Ну это вот понятно, у меня
[24:06.200 --> 24:08.200]  две доли левая и правая, я их просто
[24:08.200 --> 24:10.200]  назвал так неярко.
[24:16.200 --> 24:18.200]  Насчитывается тоже примерно так же.
[24:18.200 --> 24:20.200]  Если я
[24:20.200 --> 24:22.200]  для всех меньших масок знаю DP-шку,
[24:22.200 --> 24:24.200]  то как посчитать DP от маски?
[24:24.200 --> 24:26.200]  Ну вот если у меня какая-то маска
[24:26.200 --> 24:28.200]  в левой доле,
[24:28.200 --> 24:30.200]  я могу в ней точно так же выбрать любую
[24:30.200 --> 24:32.200]  вершину V, для удобства
[24:32.200 --> 24:34.200]  буду выбирать старший бит.
[24:34.200 --> 24:36.200]  Чтобы посчитать DP от этой объединенной маски,
[24:36.200 --> 24:38.200]  мне достаточно взять DP
[24:38.200 --> 24:40.200]  для маски без V,
[24:40.200 --> 24:42.200]  взять DP
[24:42.200 --> 24:44.200]  для вершинки V, ну то есть по факту
[24:44.200 --> 24:46.200]  множество соседей этой вершинки V вот здесь,
[24:46.200 --> 24:48.200]  и пересечивать два множества. То есть я знаю
[24:48.200 --> 24:50.200]  всех чуваков, которые соединены вот с этим множеством
[24:50.200 --> 24:52.200]  вершин, и знаю все вершины,
[24:52.200 --> 24:54.200]  которые соединены с V-шкой.
[24:54.200 --> 24:56.200]  Значит их пересечение и будет как раз множество
[24:56.200 --> 24:58.200]  тех, которые соединены со всеми.
[24:58.200 --> 25:00.200]  Ну это вот то же самое, что было раньше, пока что.
[25:00.200 --> 25:02.200]  Хорошо?
[25:02.200 --> 25:04.200]  Вот.
[25:04.200 --> 25:06.200]  Это первая вещь.
[25:06.200 --> 25:08.200]  А дальше, смотрите, мне нужно, ну DP-шка
[25:08.200 --> 25:10.200]  это хорошо, но это не всем то, что мне нужно.
[25:10.200 --> 25:12.200]  Пока что DP от маски,
[25:12.200 --> 25:14.200]  это множество всех допустимых
[25:14.200 --> 25:16.200]  вершин справа, которые со всеми из маски соединены.
[25:16.200 --> 25:18.200]  Но теперь мне нужно в этом множестве
[25:18.200 --> 25:20.200]  выбрать какую-то подмаску,
[25:20.200 --> 25:22.200]  которая является кликой сама по себе.
[25:22.200 --> 25:24.200]  То есть если я фиксирую, что маска
[25:24.200 --> 25:26.200]  это клика, если я взял
[25:26.200 --> 25:28.200]  DP от маски как множество всех потенциально
[25:28.200 --> 25:30.200]  возможных соседей, мне осталось
[25:30.200 --> 25:32.200]  здесь выбрать самую большую подмаску,
[25:32.200 --> 25:34.200]  самую большую клику, самую большую под клику.
[25:34.200 --> 25:36.200]  Остается
[25:36.200 --> 25:38.200]  выбрать
[25:40.200 --> 25:42.200]  максимальную
[25:42.200 --> 25:44.200]  клику
[25:44.200 --> 25:46.200]  внутри
[25:46.200 --> 25:48.200]  DP от маски.
[25:50.200 --> 25:52.200]  Вот.
[25:54.200 --> 25:56.200]  И если я это еще как-то сделаю,
[25:56.200 --> 25:58.200]  если я для каждого множества вершин
[25:58.200 --> 26:00.200]  правой доли смогу найти в нем самую большую
[26:00.200 --> 26:02.200]  под клику, лежащую
[26:02.200 --> 26:04.200]  внутри этого множества, если я смогу найти самую большую
[26:04.200 --> 26:06.200]  под клику для вот этой вот
[26:06.200 --> 26:08.200]  объемлющей маски,
[26:08.200 --> 26:10.200]  то я просто перебираю маску слева, узнаю
[26:10.200 --> 26:12.200]  с кем потенциально можно ее соединить и дальше
[26:12.200 --> 26:14.200]  выбираю в ней наибольшую подмаску, наибольшую
[26:14.200 --> 26:16.200]  под клику. Тем самым я перебираю
[26:16.200 --> 26:18.200]  вообще все возможные максимальные клики. То есть я перебираю
[26:18.200 --> 26:20.200]  вершины слева
[26:20.200 --> 26:22.200]  и дальше справа выбираю максимальное
[26:22.200 --> 26:24.200]  по размеру множество, которое с ними
[26:24.200 --> 26:26.200]  со всеми соединено.
[26:30.200 --> 26:32.200]  Теперь как вот это насчитать?
[26:40.200 --> 26:42.200]  Давайте подумаем.
[26:44.200 --> 26:46.200]  То есть я что хочу?
[26:46.200 --> 26:48.200]  Давайте я еще как-нибудь назову
[26:48.200 --> 26:50.200]  subclick как-нибудь.
[26:52.200 --> 26:54.200]  Значит давайте я
[26:54.200 --> 26:56.200]  еще как-нибудь
[26:56.200 --> 26:58.200]  назову это множество, не маск,
[26:58.200 --> 27:00.200]  чтобы было.
[27:02.200 --> 27:04.200]  Давайте я назову set.
[27:06.200 --> 27:08.200]  Я хочу для каждого множества вершин правой
[27:08.200 --> 27:10.200]  доли, где set это подносит
[27:10.200 --> 27:12.200]  вершин правой доли,
[27:12.200 --> 27:14.200]  я хочу определить максимальную
[27:14.200 --> 27:16.200]  размеру подмаску, размер
[27:16.200 --> 27:18.200]  под клику точнее,
[27:18.200 --> 27:20.200]  размер максимальной
[27:20.200 --> 27:22.200]  клики
[27:22.200 --> 27:24.200]  внутри set.
[27:40.200 --> 27:42.200]  Если у вас идея, как можно
[27:42.200 --> 27:44.200]  это посчитать?
[27:52.200 --> 27:54.200]  Смотрите, я свел задачу
[27:54.200 --> 27:56.200]  к следующему. Мне достаточно
[27:56.200 --> 27:58.200]  для каждого
[27:58.200 --> 28:00.200]  подмножества вершин правой доли,
[28:00.200 --> 28:02.200]  для каждого множества set, найти максимальную
[28:02.200 --> 28:04.200]  под клику внутри него.
[28:04.200 --> 28:06.200]  Сейчас я рассматриваю эту задачу. Для каждого
[28:06.200 --> 28:08.200]  подмножества вершин правой доли, найти
[28:08.200 --> 28:10.200]  максимальную под клику в ней.
[28:12.200 --> 28:14.200]  Как предыдущая задача
[28:14.200 --> 28:16.200]  поможет?
[28:18.200 --> 28:20.200]  Не совсем, она
[28:20.200 --> 28:22.200]  определяла,
[28:22.200 --> 28:24.200]  булистский флаг является
[28:24.200 --> 28:26.200]  множество клика или нет.
[28:26.200 --> 28:28.200]  А здесь надо максимальное
[28:28.200 --> 28:30.200]  подмножество являющееся клика выбрать.
[28:32.200 --> 28:34.200]  Не совсем это
[28:34.200 --> 28:36.200]  делала, но
[28:36.200 --> 28:38.200]  как-то должно помочь, наверное.
[28:38.200 --> 28:40.200]  Давайте фиксируем какой-нибудь set,
[28:40.200 --> 28:42.200]  давайте фиксируем какой-то множество вершин из
[28:42.200 --> 28:44.200]  правой доли.
[28:44.200 --> 28:46.200]  Во-первых, понятно, что если она
[28:46.200 --> 28:48.200]  сама по себе клика, то
[28:48.200 --> 28:50.200]  subclick вот сет просто ее размер.
[28:50.200 --> 28:52.200]  Если
[28:52.200 --> 28:54.200]  set клика
[28:54.200 --> 28:56.200]  и
[28:56.200 --> 28:58.200]  подмножество вершин
[28:58.200 --> 29:00.200]  правой доли,
[29:00.200 --> 29:02.200]  то сет просто его размер.
[29:02.200 --> 29:04.200]  Если
[29:04.200 --> 29:06.200]  сет клика
[29:06.200 --> 29:08.200]  то
[29:10.200 --> 29:12.200]  размер максимальной
[29:12.200 --> 29:14.200]  под клики в ней, это она сама.
[29:14.200 --> 29:16.200]  Да, это просто
[29:16.200 --> 29:18.200]  размер множества сет.
[29:18.200 --> 29:20.200]  Ну, размер опять как-нибудь мы умеем считать, наверное.
[29:20.200 --> 29:22.200]  Теперь, если она
[29:22.200 --> 29:24.200]  не клика,
[29:24.200 --> 29:26.200]  если она не клика, то из нее явно надо
[29:26.200 --> 29:28.200]  что-то удалить.
[29:30.200 --> 29:32.200]  Чтобы получить
[29:32.200 --> 29:34.200]  максимальную под клику,
[29:34.200 --> 29:36.200]  по крайней мере, одну вершину точно надо удалить.
[29:36.200 --> 29:38.200]  Но давайте рассмотрим какую-то одну.
[29:38.200 --> 29:40.200]  Давайте пусть v какать вершину.
[29:44.200 --> 29:46.200]  Тогда, как выглядят
[29:46.200 --> 29:48.200]  все подмножества, как выглядят все
[29:48.200 --> 29:50.200]  под клики, они либо v содержат, либо
[29:50.200 --> 29:52.200]  не содержат, тогда
[29:52.200 --> 29:54.200]  с одной стороны, можно попробовать v просто выкинуть
[29:54.200 --> 29:56.200]  и взять максимальную под клику в сете
[29:56.200 --> 29:58.200]  без v. Во-первых, мы можем
[29:58.200 --> 30:00.200]  взять просто максимальную под клику
[30:00.200 --> 30:02.200]  в сет
[30:02.200 --> 30:04.200]  без вершинки v.
[30:04.200 --> 30:06.200]  Можно просто сказать, что v не существует.
[30:06.200 --> 30:08.200]  Если у меня
[30:08.200 --> 30:10.200]  определена максимальная под клика для этого множества,
[30:10.200 --> 30:12.200]  то, в частности, одним из вариантов является
[30:12.200 --> 30:14.200]  просто выкинуть v и взять вот здесь максимальную
[30:14.200 --> 30:16.200]  под клику.
[30:16.200 --> 30:18.200]  Либо же,
[30:18.200 --> 30:20.200]  если это действие не опсимально,
[30:20.200 --> 30:22.200]  то мне нужно
[30:22.200 --> 30:24.200]  обязательно v взять.
[30:24.200 --> 30:26.200]  То есть, если v выкинуть не имею права,
[30:26.200 --> 30:28.200]  я ее тогда обязательно оставляю.
[30:28.200 --> 30:30.200]  И что можно
[30:30.200 --> 30:32.200]  сделать тогда?
[30:44.200 --> 30:46.200]  Да, да, да, все верно.
[30:46.200 --> 30:48.200]  Значит, если у меня, соответственно,
[30:48.200 --> 30:50.200]  давайте подпишу, что это v не лежит
[30:50.200 --> 30:52.200]  в под клике.
[30:52.200 --> 30:54.200]  Если
[30:54.200 --> 30:56.200]  она лежит в под клике, если я выбираю
[30:56.200 --> 30:58.200]  под клики содержащий v, то
[30:58.200 --> 31:00.200]  под клика обязательно включена в множество
[31:00.200 --> 31:02.200]  соседей вершинки v. То есть, вот есть
[31:02.200 --> 31:04.200]  ее какие-то соседи,
[31:04.200 --> 31:06.200]  то есть она с кем-то соединена, с кем-то не соединена.
[31:10.200 --> 31:12.200]  Ну и понятно тогда, что
[31:12.200 --> 31:14.200]  если мне нужно выбрать максимальную под клику содержащую v,
[31:14.200 --> 31:16.200]  то я v беру,
[31:16.200 --> 31:18.200]  и дальше просто нахожу максимальную под клику вот здесь.
[31:18.200 --> 31:20.200]  Это какое-то меньшее множество.
[31:20.200 --> 31:22.200]  Если я действую по индукции, для меньших множеств
[31:22.200 --> 31:24.200]  уже нашел максимальную под клику,
[31:24.200 --> 31:26.200]  то здесь оно тоже посчитано.
[31:26.200 --> 31:28.200]  Либо я
[31:28.200 --> 31:30.200]  пишу единичку плюс
[31:30.200 --> 31:32.200]  subclick
[31:32.200 --> 31:34.200]  для множества
[31:34.200 --> 31:36.200]  set
[31:36.200 --> 31:38.200]  в пересечении с
[31:38.200 --> 31:40.200]  ну давайте пишу n от v,
[31:40.200 --> 31:42.200]  где n от v это маска
[31:42.200 --> 31:44.200]  соседей вершины v.
[31:44.200 --> 31:46.200]  Вот.
[31:46.200 --> 31:48.200]  И из этих двух чисел выбираю максимум.
[31:48.200 --> 31:50.200]  Потому что
[31:50.200 --> 31:52.200]  максимальная под клика
[31:52.200 --> 31:54.200]  либо содержит v,
[31:54.200 --> 31:56.200]  либо не содержит v,
[31:56.200 --> 31:58.200]  тогда это вот этот вот случай.
[31:58.200 --> 32:00.200]  Ну как-то это тоже посчитаем там.
[32:00.200 --> 32:02.200]  Ну как писать маску соседей,
[32:02.200 --> 32:04.200]  можно просто в самом начале
[32:04.200 --> 32:06.200]  для всех вершин, ну как мы в самом начале
[32:06.200 --> 32:08.200]  делали тоже просто задачу.
[32:08.200 --> 32:10.200]  Мне нужно для каждой v обращать
[32:10.200 --> 32:12.200]  маску соседей,
[32:12.200 --> 32:14.200]  просто задачу. Мне нужно для каждой v
[32:14.200 --> 32:16.200]  определить маску, с кем она соединяется здесь.
[32:16.200 --> 32:18.200]  Ну за n квадрата легко посчитать. В самом начале
[32:18.200 --> 32:20.200]  для каждой v я просто насчитываю n от v за n квадрат.
[32:20.200 --> 32:22.200]  Вот.
[32:30.200 --> 32:32.200]  Ну мы как бы
[32:32.200 --> 32:34.200]  сами этого не знаем, но мы точно знаем,
[32:34.200 --> 32:36.200]  что ответ от либо вот это, либо вот это.
[32:36.200 --> 32:38.200]  То есть если v лежит в максимальной
[32:38.200 --> 32:40.200]  под клике, то ответ это вот это, с ней лежит вот это.
[32:40.200 --> 32:42.200]  Но если я возьму максимум из этих двух вещей,
[32:42.200 --> 32:44.200]  я как раз переберу оба варианта.
[32:46.200 --> 32:48.200]  Итого. Получается,
[32:48.200 --> 32:50.200]  что я теперь
[32:50.200 --> 32:52.200]  научился считать вот эту вот динамику subclick.
[32:52.200 --> 32:54.200]  Я умею для каждого множества вершин
[32:54.200 --> 32:56.200]  правой доли, для каждого сета внутри
[32:56.200 --> 32:58.200]  правой доли умею находить
[32:58.200 --> 33:00.200]  максимальный размер под клики внутри нее.
[33:00.200 --> 33:02.200]  Ну по факту здесь
[33:02.200 --> 33:04.200]  три случая. Первый случай,
[33:04.200 --> 33:06.200]  когда сет сам ап себе клика, а это мы проверять умеем.
[33:06.200 --> 33:08.200]  Мы в прошлой задаче за
[33:08.200 --> 33:10.200]  два в степени размера множества
[33:10.200 --> 33:12.200]  научились определять
[33:12.200 --> 33:14.200]  для каждого подножия, является ли он клик или нет.
[33:14.200 --> 33:16.200]  Если клика, то можно сразу положить,
[33:16.200 --> 33:18.200]  что она сама по себе является максимальной
[33:18.200 --> 33:20.200]  под кликой. Дальше я выбираю
[33:20.200 --> 33:22.200]  любую вершинку v. Опять же, любую вершину
[33:22.200 --> 33:24.200]  я умею выбирать. Например, можно
[33:24.200 --> 33:26.200]  oldest брать. Oldest мы насчитывать умеем.
[33:26.200 --> 33:28.200]  И для вот этого старшего бита
[33:28.200 --> 33:30.200]  я выбираю просто максимум из этих двух величин.
[33:32.200 --> 33:34.200]  И тем самым я вот этот subclick
[33:34.200 --> 33:36.200]  насчитал за два в степени
[33:36.200 --> 33:38.200]  n пополам.
[33:42.200 --> 33:44.200]  Потому что это столько, сколько
[33:44.200 --> 33:46.200]  всего есть под массой в правой доле.
[33:52.200 --> 33:54.200]  Теперь, если я вот эту динамику
[33:54.200 --> 33:56.200]  под кликом посчитал,
[33:56.200 --> 33:58.200]  остальное уже очень просто
[33:58.200 --> 34:00.200]  доделывается. Я просто перебираю
[34:00.200 --> 34:02.200]  все вершины левой доли,
[34:02.200 --> 34:04.200]  у меня есть все под множество вершин
[34:04.200 --> 34:06.200]  левой доли. Для них
[34:06.200 --> 34:08.200]  с помощью
[34:08.200 --> 34:10.200]  DP-шки нахожу множество допустимых
[34:10.200 --> 34:12.200]  соседей справа,
[34:12.200 --> 34:14.200]  я нахожу множество тех
[34:14.200 --> 34:16.200]  вершин справа, которые соединяются
[34:16.200 --> 34:18.200]  со всеми вершинами текущей маски
[34:18.200 --> 34:20.200]  с помощью DP-шки еще одной.
[34:20.200 --> 34:22.200]  А дальше, внутри этой DP-шки выделяю
[34:22.200 --> 34:24.200]  максимальную под клику
[34:24.200 --> 34:26.200]  с помощью gsubclick.
[34:28.200 --> 34:30.200]  Получается, что чтобы найти ответ,
[34:30.200 --> 34:32.200]  я делаю следующее.
[34:34.200 --> 34:36.200]  Значит, ответ
[34:38.200 --> 34:40.200]  это максимум
[34:40.200 --> 34:42.200]  по всем маскам
[34:42.200 --> 34:44.200]  вершин левой доли
[34:44.200 --> 34:46.200]  являющимся кликой.
[34:50.200 --> 34:52.200]  Размер маски
[34:52.200 --> 34:54.200]  плюс,
[34:54.200 --> 34:56.200]  ну, видимо, subclick
[34:56.200 --> 34:58.200]  от DP
[34:58.200 --> 35:00.200]  от маски.
[35:06.200 --> 35:08.200]  Потому что я буквально выбрал сначала
[35:08.200 --> 35:10.200]  какую-то маску слева,
[35:10.200 --> 35:12.200]  затем посчитал DP-шку
[35:12.200 --> 35:14.200]  это тех, с кем оно в принципе может быть
[35:14.200 --> 35:16.200]  соединено справа,
[35:16.200 --> 35:18.200]  и дальше
[35:18.200 --> 35:20.200]  внутри этого множества, внутри вот этого сета
[35:20.200 --> 35:22.200]  выбрал максимальную под клику
[35:22.200 --> 35:24.200]  с помощью subclick.
[35:24.200 --> 35:26.200]  На этом у меня есть еще отдельная динамика,
[35:26.200 --> 35:28.200]  которая тоже это считает.
[35:34.200 --> 35:36.200]  Ну что?
[35:38.200 --> 35:40.200]  Номана? Нет?
[35:42.200 --> 35:44.200]  Что?
[35:48.200 --> 35:50.200]  Что с этим точком? Давайте аккуратно
[35:50.200 --> 35:52.200]  посчитаем.
[35:52.200 --> 35:54.200]  Смотрите, вот давайте начнем
[35:54.200 --> 35:56.200]  с subclick.
[35:56.200 --> 35:58.200]  Вот я утверждаю, что subclick считается за 2 в степени пополам.
[35:58.200 --> 36:00.200]  Хорошо.
[36:00.200 --> 36:02.200]  Просто потому что я перебираю все подносы,
[36:02.200 --> 36:04.200]  что сет, и вот этот динамик я насчитываю
[36:04.200 --> 36:06.200]  за вот единицы. Там три случая,
[36:06.200 --> 36:08.200]  это все за единицу обрабатывается.
[36:08.200 --> 36:10.200]  Теперь мне что нужно? Мне нужно для каждой
[36:10.200 --> 36:12.200]  маски слева, во-первых, проверить, что она клика,
[36:12.200 --> 36:14.200]  это мы умеем делать за 2 в степени
[36:14.200 --> 36:16.200]  размер множества. Значит, я
[36:16.200 --> 36:18.200]  еще одну DP-шку за 2 в степени
[36:18.200 --> 36:20.200]  пополам проверяю, для каждой маски является она клик или нет.
[36:20.200 --> 36:22.200]  Размер маски я умею
[36:22.200 --> 36:24.200]  искать.
[36:24.200 --> 36:26.200]  DP от маски, точнее subclick у меня
[36:26.200 --> 36:28.200]  почитано, осталось только DP от маски работает.
[36:28.200 --> 36:30.200]  За сколько работает DP от маски?
[36:30.200 --> 36:32.200]  Ну, это мы тоже
[36:32.200 --> 36:34.200]  писали. Давайте повторю формулу,
[36:34.200 --> 36:36.200]  что DP от маски
[36:36.200 --> 36:38.200]  это
[36:38.200 --> 36:40.200]  DP от маски без
[36:40.200 --> 36:42.200]  произвольной вершинки v
[36:42.200 --> 36:44.200]  пересечь с
[36:44.200 --> 36:46.200]  DP от этой самой
[36:46.200 --> 36:48.200]  вершинки v.
[36:48.200 --> 36:50.200]  Это тоже еще одна динамика,
[36:50.200 --> 36:52.200]  которая работает еще за 2 в степени пополам.
[36:52.200 --> 36:54.200]  Ну и в итоге вот такая симпатичка.
[36:54.200 --> 36:56.200]  Без всяких умножений
[36:56.200 --> 36:58.200]  на n.
[36:58.200 --> 37:00.200]  За чисто 2 в степени пополам,
[37:00.200 --> 37:02.200]  на какую-то константу, потому что несколько DP-шек,
[37:02.200 --> 37:04.200]  там типа 4 или 5 DP-шек,
[37:04.200 --> 37:06.200]  ну все констант.
[37:10.200 --> 37:12.200]  Ну, потому что я несколько
[37:12.200 --> 37:14.200]  заметаю под ковер, мне нужно еще
[37:14.200 --> 37:16.200]  для каждой маски знать,
[37:16.200 --> 37:18.200]  является она клика или нет. Это еще DP-шка
[37:18.200 --> 37:20.200]  на самом деле внутренняя.
[37:20.200 --> 37:22.200]  И вот здесь
[37:22.200 --> 37:24.200]  мне это нужно тоже сделать, для каждой
[37:24.200 --> 37:26.200]  сет из правой доли
[37:26.200 --> 37:28.200]  надо тоже определять, она клика или нет.
[37:28.200 --> 37:30.200]  Ну, это мы в прошлой задаче делали за 2 в степени размером
[37:30.200 --> 37:32.200]  множества, мы это умеем делать. Но это вот
[37:32.200 --> 37:34.200]  еще какая-то внутренняя DP-шка, которая там есть.
[37:34.200 --> 37:36.200]  Ну вот.
[37:36.200 --> 37:38.200]  Аманна?
[37:40.200 --> 37:42.200]  Еще раз?
[37:46.200 --> 37:48.200]  Хороший вопрос, но он вроде не получается.
[37:50.200 --> 37:52.200]  Он вроде не получается.
[37:52.200 --> 37:54.200]  Ну,
[37:54.200 --> 37:56.200]  а что же все время делить пополам?
[37:56.200 --> 37:58.200]  Ну вот там, ну не знаю, пусть мы посчитали, да,
[37:58.200 --> 38:00.200]  нашли здесь максимальную клику, здесь максимальную клику,
[38:00.200 --> 38:02.200]  а как их склеить?
[38:02.200 --> 38:04.200]  То есть даже если мы там вот эти как-то
[38:04.200 --> 38:06.200]  рекурсивные еще поделили и нашли ответ
[38:06.200 --> 38:08.200]  внутри них, то как мне склеить ответ
[38:08.200 --> 38:10.200]  отсюда и отсюда?
[38:10.200 --> 38:12.200]  Ну вот быстрее, чем за столько, непонятно как.
[38:16.200 --> 38:18.200]  А я
[38:18.200 --> 38:20.200]  такого ни разу не утверждал.
[38:20.200 --> 38:22.200]  Я
[38:22.200 --> 38:24.200]  говорю, что максимальная клика во
[38:24.200 --> 38:26.200]  всем графе, понятно, ну
[38:26.200 --> 38:28.200]  слева содержит какую-то клику.
[38:28.200 --> 38:30.200]  То есть ее прищение слевой доли, как клика.
[38:30.200 --> 38:32.200]  Вот я все перебираю.
[38:32.200 --> 38:34.200]  Я перебираю все возможные маски слева, которые являются
[38:34.200 --> 38:36.200]  кликами, соответственно, которые являются левыми
[38:36.200 --> 38:38.200]  частями максимальной клики. И дальше их
[38:38.200 --> 38:40.200]  оптимально, ну
[38:40.200 --> 38:42.200]  в каком-то смысле жадно, продолжаю направо.
[38:46.200 --> 38:48.200]  Так, ну ладно, давайте перерыв
[38:48.200 --> 38:50.200]  тогда сделаем, пять минут.
[38:54.200 --> 38:56.200]  Значит, постановка следующая. У нас опять
[38:56.200 --> 38:58.200]  есть какой-то граф на вершинах.
[39:00.200 --> 39:02.200]  И мы хотим
[39:02.200 --> 39:04.200]  раскрасить все вершины в
[39:04.200 --> 39:06.200]  несколько цветов,
[39:06.200 --> 39:08.200]  в как можно меньше число цветов.
[39:08.200 --> 39:10.200]  Так, чтобы концы любого ребра были
[39:10.200 --> 39:12.200]  разноцветные.
[39:16.200 --> 39:18.200]  То есть формально
[39:18.200 --> 39:20.200]  нужно найти такое минимальное k,
[39:20.200 --> 39:22.200]  для которого существует раскраска
[39:22.200 --> 39:24.200]  всех вершин, не больше чем в k цветов.
[39:26.200 --> 39:28.200]  Раскраска вершин
[39:30.200 --> 39:32.200]  в k цветов.
[39:32.200 --> 39:34.200]  Ну такая, что для любого
[39:34.200 --> 39:36.200]  ребра его концы разных цветов.
[39:36.200 --> 39:38.200]  То есть нет одноцветных ребер.
[39:42.200 --> 39:44.200]  Вот.
[39:44.200 --> 39:46.200]  Значит, это тоже
[39:46.200 --> 39:48.200]  NP трудная задача.
[39:48.200 --> 39:50.200]  Пока что никто ее решать быстро не умеет.
[39:50.200 --> 39:52.200]  Мы научимся за что-то в стиле
[39:52.200 --> 39:54.200]  ну давайте я вот так вот
[39:54.200 --> 39:56.200]  напишу. Два степени
[39:56.200 --> 39:58.200]  на полинома, там какая-то
[39:58.200 --> 40:00.200]  N или N квадрата будет, ну там
[40:00.200 --> 40:02.200]  неважно.
[40:02.200 --> 40:04.200]  Посмотрим по дороге.
[40:08.200 --> 40:10.200]  Вот. Задача понятна?
[40:10.200 --> 40:12.200]  Хорошо.
[40:14.200 --> 40:16.200]  Значит здесь основное соображение следующее.
[40:16.200 --> 40:18.200]  Любую
[40:18.200 --> 40:20.200]  раскраску, любую правильную раскраску
[40:20.200 --> 40:22.200]  графа можно воспринимать
[40:22.200 --> 40:24.200]  как разбиение всех вершин на множество
[40:24.200 --> 40:26.200]  точнее на несколько независимых
[40:26.200 --> 40:28.200]  множеств.
[40:28.200 --> 40:30.200]  Потому что если я скажем
[40:30.200 --> 40:32.200]  для каждого цвета рассмотрю множество
[40:32.200 --> 40:34.200]  вершин покрашенных в этот цвет.
[40:34.200 --> 40:36.200]  Вот я нарисую все вершины первого цвета, все вершины
[40:36.200 --> 40:38.200]  второго цвета, все вершины третьего цвета
[40:38.200 --> 40:40.200]  и так далее.
[40:40.200 --> 40:42.200]  То понятное дело, что каждое это множество
[40:42.200 --> 40:44.200]  является независимым, то есть внутри множества нет ребер.
[40:44.200 --> 40:46.200]  Множество, внутри которого
[40:46.200 --> 40:48.200]  нет ребер я буду называть независимым.
[40:48.200 --> 40:50.200]  То есть это все независимые множества.
[40:52.200 --> 40:54.200]  И по факту у меня задача
[40:54.200 --> 40:56.200]  ее можно переформулировать
[40:56.200 --> 40:58.200]  так. Нужно найти минимальное
[40:58.200 --> 41:00.200]  K, для
[41:00.200 --> 41:02.200]  которого все вершины можно разбить на
[41:02.200 --> 41:04.200]  K не пересекающихся независимых
[41:04.200 --> 41:06.200]  множеств.
[41:06.200 --> 41:08.200]  То есть переформулировка
[41:10.200 --> 41:12.200]  найти минимальное
[41:12.200 --> 41:14.200]  K
[41:14.200 --> 41:16.200]  такое, что
[41:16.200 --> 41:18.200]  V можно разбить
[41:22.200 --> 41:24.200]  на K
[41:26.200 --> 41:28.200]  независимых множеств.
[41:36.200 --> 41:38.200]  Вот.
[41:38.200 --> 41:40.200]  Хорошо.
[41:40.200 --> 41:42.200]  Ну, на самом деле
[41:42.200 --> 41:44.200]  вот эта вот оговорка
[41:44.200 --> 41:46.200]  про то, что V нужно разбить
[41:46.200 --> 41:48.200]  на
[41:48.200 --> 41:50.200]  не пересекающие множества,
[41:50.200 --> 41:52.200]  на самом деле ее можно опустить.
[41:52.200 --> 41:54.200]  И вот эта вот формировка
[41:54.200 --> 41:56.200]  эквалентна такой, что
[41:56.200 --> 41:58.200]  V просто покрывается
[41:58.200 --> 42:00.200]  несколькими независимыми множествами.
[42:00.200 --> 42:02.200]  Вот.
[42:02.200 --> 42:04.200]  Вот.
[42:04.200 --> 42:06.200]  Независимыми множествами.
[42:06.200 --> 42:08.200]  V можно покрыть
[42:10.200 --> 42:12.200]  K
[42:12.200 --> 42:14.200]  независимыми множествами.
[42:22.200 --> 42:24.200]  То есть мне не обязательно требовать, что они
[42:24.200 --> 42:26.200]  не пересекаются. Они, в принципе, могут как-то пересекаться.
[42:26.200 --> 42:28.200]  Почему?
[42:28.200 --> 42:30.200]  Ну, понятно, что если есть разбиение на K независимых,
[42:30.200 --> 42:32.200]  то есть и покрытие с помощью K независимых.
[42:32.200 --> 42:34.200]  Разбиение является покрытием.
[42:34.200 --> 42:36.200]  Кождая вершина где-то участвует.
[42:36.200 --> 42:38.200]  Ну и, наоборот, если есть покрытиe независимыми,
[42:38.200 --> 42:40.200]  то если какие-то два независимых
[42:40.200 --> 42:42.200]  пересекаются,
[42:42.200 --> 42:44.200]  можно просто из одного подадать вершинки так, чтобы это
[42:44.200 --> 42:46.200]  вершинeulate исчезла, и будет
[42:46.200 --> 42:48.200]  как раз разбиение.
[42:48.200 --> 42:50.200]  То есть можно сделать так, чтобы они не пересекались,
[42:50.200 --> 42:52.200]  потому что независимым множеством можно удалять вершинки,
[42:52.200 --> 42:54.200]  оно останется при этом независимым.
[42:54.200 --> 42:56.200]  Будет вот эта вот множество и вот это.
[42:56.200 --> 42:58.200]  И как раз мы избавимся от пересечения,
[42:58.200 --> 43:00.200]  и таким образом пересекаются множества,
[43:00.200 --> 43:04.200]  пересекающиеся. Поэтому как бы найти минимальное k такое, то же самое, что найти
[43:04.200 --> 43:08.080]  минимальное k такое. Но это считать будет попроще, потому что ну как бы мы
[43:08.080 --> 43:11.960]  избавились от дополнительного требования. Мы избавились от требований того, что они не
[43:11.960 --> 43:16.000]  пересекаются, теперь мы можем просто покрыть все вершины В, возможно по несколько
[43:16.000 --> 43:19.720]  раз, то есть каждая вершина может войти в несколько независимых множеств, но главное, чтобы
[43:19.720 --> 43:37.840]  каждый блакок раз покрыть. Понятно? Вот, ну давайте это считать. Моя цель, это вот здесь мне
[43:37.840 --> 43:41.320]  удобно будет посчитать не просто узнать, существует такое покрытие или нет, а
[43:41.320 --> 43:52.320]  посчитать количество будет проще всего. Давайте я скажу, что скажем c от k, c от k это
[43:52.320 --> 44:06.920]  количество наборов, давайте назову их g1, g2 и так далее, gkt, таких, что все жишки, это
[44:06.920 --> 44:26.960]  независимое множество, их объединение это В. Вот, ну я просто определяю, сколько существует
[44:26.960 --> 44:35.440]  таких вот покрытий. Ну и понятно тогда, что минимальное, мне по факту нужно теперь найти
[44:35.440 --> 44:41.800]  минимальное k, такое, что c от k положительно, на что существует хотя бы один набор из ка независимых
[44:41.800 --> 44:47.200]  множеств, который покрывает суммарно все вершины. Вот, такую задачу теперь будем решать.
[45:05.440 --> 45:18.600]  Так, ну хорошо. Да, c от k, смотрите, я хочу посчитать, сколькими способами можно покрыть В с помощью k независимых
[45:18.600 --> 45:25.680]  множеств. То есть формально, сколько существует таких кортежей длины k, что каждая g и t это независимое
[45:25.680 --> 45:31.000]  множество, и при этом их объединение покрывает все В, то есть их объединение равно В. Каждая вершина
[45:31.000 --> 45:36.280]  вошла хотя бы в какое-то независимое множество. Ну и тогда понятно, что положительность c от k
[45:36.280 --> 45:42.600]  равносильна тому, что можно так покрыть все k независимым множествами, а значит хроматическое
[45:42.600 --> 45:47.320]  число не больше чем k. То есть можно их вот так вот разбить, можно покрыть этими k цветами. Вот,
[45:47.320 --> 45:59.640]  значит хроматическое число не больше чем k. Если я найду минимальное, то я найду ответ. Вот. А считать вот
[45:59.640 --> 46:10.320]  это количество наборов, я буду с помощью формулы включения исключений. Потому что проверять вот это
[46:10.320 --> 46:18.280]  требование надо думать как, а с помощью формулы включения исключения это делается довольно просто.
[46:18.280 --> 46:25.360]  Смотрите, ну вот вообще сколько, вот если я отброшу вот это условие про объединение, про то,
[46:25.360 --> 46:29.920]  что объединение равно В, то сколько существует таких наборов из k множеств, что каждая из них
[46:29.920 --> 46:36.760]  независимая. Вот если я это отброшу, то наверное это как-то можем посчитать. Если я знаю сколько
[46:36.760 --> 46:44.160]  вообще всего в графе независимых множеств, то количество наборов без вот этого условия,
[46:44.160 --> 46:53.240]  это просто там m в степени k, где m это количество независимых множеств. Значит пусть в графе всего,
[46:53.240 --> 47:05.160]  м независимых множеств. Как найти m, ну мы на самом деле знаем. У нас есть алгоритм,
[47:05.160 --> 47:10.360]  который находит все клики в графе за два в степени n или даже за два в степени n пополам. Нет,
[47:10.360 --> 47:15.400]  там не все, ну короче не важно. За два в степени n мы точно умеем узнавать все клики. Но клика и
[47:15.400 --> 47:18.920]  независимое множество очень похожие объекты. В клике все ребра должны быть, а в независимом
[47:18.920 --> 47:24.680]  обороте всех должно не быть. Поэтому как бы это задача абсолютно эквивалентная. Если мы умеем
[47:24.680 --> 47:30.800]  находить все клики, то все независимые множества мы точно также умеем находить. Вот, ну вот пусть их
[47:30.800 --> 47:43.920]  всего m. Значит тогда всего наборов таких, что каждая жижка это независимое множество, их m в
[47:43.920 --> 47:50.160]  степени k. На каждый из k мест можно поставить одно из независимых множеств. Я не буду заботиться о
[47:50.160 --> 47:54.600]  том, что они должны быть все попарно различные. Этого здесь у меня не написано. Если там даже
[47:54.600 --> 48:01.680]  что-то повторяется, ну и бог с ним. Вот их в степени k. Но какие-то из них плохие, какие-то из них
[48:01.680 --> 48:06.800]  не накрывают все v. То есть их объединение может быть слишком маленьким, может не покрывать все v.
[48:06.800 --> 48:16.320]  Давайте их вычтем. Давайте вычтем те, которые не накрывают v. То есть которые вложены во что-то
[48:16.320 --> 48:39.200]  меньше. Вычтем те, которые, ну объединение которых, да, точнее, объединение которых вложено в v без v и
[48:39.200 --> 48:50.520]  для каждого i. Ну то есть как бы мне нужны те, которые в объединении дают все v, но если я просто
[48:50.520 --> 48:55.640]  рассмотрю все это, какие-то плохие, плохие те, которые скажем, какой-то v-тей не содержат. Вот я их все
[48:55.640 --> 49:06.920]  вычту. Потом мне нужно добавить те, которые вложены в v без двух элементов. Добавим обратно те,
[49:06.920 --> 49:16.440]  объединения которых вложено в v без v и v жития. Потому что если объединение вот этих штук вложено вот
[49:16.440 --> 49:21.080]  сюда вот, то я его здесь один раз учел, здесь два раза вычтил. То есть мне нужно еще раз его вычесть,
[49:21.080 --> 49:33.440]  чтобы был коэффициент нулевой. Ну и так далее. Вот. Ну и все дальше. Я просто перебираю все
[49:33.440 --> 49:40.200]  подносства v, считаю сколько есть наборов вложенных в полностью. Ну, точнее, не в, а в подносство v.
[49:40.200 --> 49:46.280]  И беру их там с нужным коэффициентом плюс или минус один. Вот. И так по пробам в включении
[49:46.280 --> 49:54.280]  исключений я насчитываю количество хороших наборов. Такая идея. Вот. Идея понятна. Сейчас я буду
[49:54.280 --> 50:05.600]  это доформализовывать. Почему наборов в раме степеника? Ну, смотрите, я считаю, я хочу посчитать,
[50:05.600 --> 50:10.120]  вот если я вот эту условию отбросил, вот эту последнюю, если я про него забуду, то мне нужно
[50:10.120 --> 50:16.960]  просто узнать сколько есть наборов из k независимых множеств. Ну, если всего в природе m независимых
[50:16.960 --> 50:23.040]  множеств, то сколько есть кортежей длинный k, каждый из которых независимый множество. На каждый из них
[50:23.040 --> 50:29.760]  можно поставить одно из m множеств. Вот. Я не заботюсь о том, чтобы они были различные, просто даже
[50:29.760 --> 50:39.480]  если есть одинаковые, я считаю это хорошим набором. Еще раз? Не, вообще все, вообще все. Ну, можно было бы
[50:39.480 --> 50:45.600]  брать, видимо, максимализ по включению, но я для простыди беру просто все, чтобы лишних условий
[50:45.600 --> 50:53.200]  не писать, просто все. Потому что вот здесь, когда я вот это говорю, я здесь нигде не следил за
[50:53.200 --> 50:59.200]  максимальностью по включению, и лучше, ну, короче, можно этого не делать. Вот, значит, идея такая,
[50:59.200 --> 51:03.000]  теперь давайте формализуем. Значит, смотрите, давайте я введу какое-нибудь обозначение.
[51:03.000 --> 51:27.920]  Пусть a от s это количество наборов g1 и т.д. и gk таких, что их объединение вложено в v без s.
[51:33.000 --> 51:47.080]  Значит, тогда ответ равен, тогда c от k равно следующей сумме m в степени k минус, значит, сумма
[51:47.080 --> 51:54.520]  по одноэлементным множествам, давайте напишу, по всем s размера 1, а вот s плюс сумма по всем
[51:54.520 --> 52:08.800]  s размера 2, а вот с минус сумма по всем s размера 3, а вот с ну и т.д. вплоть до минус 1 в степени v на
[52:08.800 --> 52:22.320]  ну единственное множество размера v, а вот с. Ну почему это так? Это в точности формы включения
[52:22.320 --> 52:28.560]  исключений. Мне что нужно? c от k это все такие наборы, которые покрывают все. Как они выглядят?
[52:28.560 --> 52:33.640]  Ну давайте сначала возьмем вообще все возможные наборы искания зависимых множеств. Из них нужно
[52:33.640 --> 52:39.880]  выкинуть те, которые хоть что-то не содержат, то есть нужно выкинуть те, объединения которых не все
[52:39.880 --> 52:44.160]  v, то есть они вложены в какое-то меньшее под множество, не содержат хотя бы какую-то вершину. Но давайте
[52:44.160 --> 52:48.800]  переберем ту вершину, которая не содержит. Мы знаем сколько таких наборов есть, мы знаем сколько
[52:48.800 --> 52:53.680]  из наборов, объединения которых вложено в v без одной вершинки. Давайте их вычтем. Это все плохие
[52:53.680 --> 52:58.960]  наборы, они нас не интересуют, потому что их объединений меньше, чем все v. Но при этом мы что-то
[52:58.960 --> 53:04.240]  выкинули дважды. Например, если объединение было в v без двух вершин, тогда мы его здесь дважды
[53:04.240 --> 53:10.080]  выкинули и добавили один раз. Надо его один раз вернуть. Ну вот вернем все а от s под двум
[53:10.080 --> 53:21.080]  элементам под множеством. Но потом то же самое с тремя и так далее. Ну вот, поэтому если я каким-то
[53:21.080 --> 53:27.200]  образом смогу насчитать вот это вот а от s, то я свою задачу для фиксированного ка решил за два
[53:27.200 --> 53:33.760]  степени n примерно. Ну потому что здесь, здесь примерно два степени н слагаемых, даже ровно два
[53:33.760 --> 53:38.000]  степени н слагаемых, потому что каждое множество встречается ровно в одной сумме и всех множеств
[53:38.000 --> 53:47.680]  ровно два степени с. Значит тогда вот эта вот штука вычисляется за два степени n, ну там,
[53:47.680 --> 53:57.120]  в сложении слэш вычитаний. Вот.
[53:57.120 --> 54:09.720]  Осталось как-то быстро насчитать ашки.
[54:09.720 --> 54:18.000]  Давайте посчитаем.
[54:27.120 --> 54:44.240]  Так, давайте еще одно обозначение веду. Пусть b от, пусть будет от s также. Это просто количество
[54:44.240 --> 55:03.120]  независимых множеств, вложенных в v без s. Тогда а от s, это просто к этой степени b.
[55:14.240 --> 55:20.000]  К это вот, вот то самое к, у меня фиксированное какое-то число. Я пытаюсь проверить, можно ли
[55:20.000 --> 55:26.040]  покрасить в к цветов. Вот. Ну почему? Ну понятно, у меня как бы мне нужно а от s, это буквально
[55:26.040 --> 55:31.080]  количество таких наборов, что их объединение вложено в v без s. Объединение вложено в v без s,
[55:31.080 --> 55:35.880]  если только если каждый из них вложено в v без s. Если я посчитаю, сколько есть таких g, которые
[55:35.880 --> 55:40.400]  вложены в v без s и дальше, ну просто возведу в какую-то степень, это будет в точности число
[55:40.400 --> 55:56.840]  таких наборов. Это вот тут написано. Поэтому достаточно вот эти b посчитать. Вот. Что-то
[55:56.840 --> 56:07.240]  похоже должно было быть на семинаре, по идее. То есть, смотрите, у меня есть какие-то независимые
[56:07.240 --> 56:16.680]  множества. Мне нужно для каждого s, для каждого подмножества множества v, найти количество
[56:16.680 --> 56:25.920]  независимых лежащих вот здесь вот. Вот это буквально следующее. Значит b вот s. Это сумма
[56:25.920 --> 56:37.560]  по всем подмножествам v без s. Но здесь написано единица, если маска это независимое множество,
[56:37.680 --> 56:51.960]  если не является независимым. Если маска это независимое множество, нулик иначе. Это буквально
[56:51.960 --> 57:03.360]  количество подмасок v без s, которые являются независимым множеством. Ну а симптотика у меня
[57:03.360 --> 57:09.160]  будет вот как у нас. Мы уже вот за столько это считаем, поэтому два в степени мы себе позволяем.
[57:09.160 --> 57:13.920]  Тут не очень хорошая симптотика, но я вначале написал, что два в степени наполиноматен.
[57:13.920 --> 57:20.240]  Вот. Ну что, узнаете, нет?
[57:43.920 --> 58:00.360]  Ой, как хочется переобозначить еще разочек. Давайте я,
[58:00.360 --> 58:29.560]  давайте я просто напишу b'. Ну я просто переобозвал. Вот я сказал, что вот здесь вместо
[58:29.560 --> 58:35.800]  v без s я буду писать просто t. Ну и тогда понятно, что b от s и b' от t очень легко связаны,
[58:35.800 --> 58:40.840]  надо просто с поменять на v без s и получится что там. Если я сюда поставлю вместо t в v без s,
[58:40.840 --> 58:44.760]  у меня получится как раз b от s. То есть это по факту тоже самое. Но теперь смотрите,
[58:44.760 --> 58:56.600]  теперь b' от t это сумма по подмаскам чего-то там. Вот.
[58:56.600 --> 59:18.160]  Ну связь простая. Ну я по факту просто переобозначил вот это вот за t. Но теперь
[59:18.160 --> 59:25.000]  смотри, теперь b' от множества t это по факту просто количество независимых подмножеств множество t.
[59:25.000 --> 59:30.800]  Это сумма по всем подмаскам под множество t, единица если маска независима,
[59:30.800 --> 59:35.200]  ноль если не независима. Поэтому по факту b' от t это просто количество независимых
[59:35.200 --> 59:41.800]  внутри t. Вот. Ну такое мы вроде умеем делать.
[59:41.800 --> 01:00:06.880]  Ну нет. Ну все-таки в мебесе еще минцы единички бывают?
[01:00:06.880 --> 01:00:33.760]  Ну понятно, но кажется здесь она не помогает. Но неважно. Нет, мебес тут не нужен точно.
[01:00:33.760 --> 01:00:47.760]  Так это что-что? Кто она? Да блин, это обозначение просто. Давайте b' с волной,
[01:00:47.760 --> 01:01:13.280]  если вас это путает. Это непроизводно. B' от s это количество клик в s? Почему? Это правда.
[01:01:13.280 --> 01:01:19.760]  Но при инверсии всего графа, когда вы ребра заменяете на отсутствие ребра,
[01:01:19.760 --> 01:01:29.840]  а наоборот если не было ребра, то добавляете его. Не совсем оно. Ну окей. Так или иначе,
[01:01:29.840 --> 01:01:36.840]  давайте я сформулирую следующую задачу. Такая задача. Вот просто давайте у меня для каждой
[01:01:36.840 --> 01:01:41.720]  маски, то есть смотрите, мне по факту для каждой маски определено какое число 1 или 0. Является
[01:01:41.720 --> 01:01:53.160]  оно независимо нашим или нет. Давайте это обзову за какой-нибудь x. Пусть x от маск даёт какое-то
[01:01:53.160 --> 01:02:06.400]  число для каждой маски. Число, отвечающее каждой маске. Каждой маске. А дальше мне нужно для каждого
[01:02:06.400 --> 01:02:16.880]  множества t определить сумму x по подмаскам. Дальше B' от t это сумма по всем подмаскам x от
[01:02:16.880 --> 01:02:22.720]  маски просто. То есть у меня есть какая-то величина определенная для каждого множества,
[01:02:22.720 --> 01:02:33.160]  для каждой маски. И дальше мне нужно найти сумму вот этих x внутри, по всем подмостам t. Вот такой
[01:02:33.400 --> 01:02:41.280]  был на семинарах или должно быть. Как решается? Давайте решим с помощью динамики. Давайте я веду
[01:02:41.280 --> 01:02:52.960]  вот такую вещь. Для каждого множества t и для, скажем, и битов, я определю такую же сумму,
[01:02:52.960 --> 01:02:57.480]  только наложу на маску ограничение, что нас совпадает с t, по крайней мере, в первых и битах.
[01:02:57.480 --> 01:03:06.920]  Это та же самая сумма x по маскам, где маска вложена в t. Но при этом первые и бит у них
[01:03:06.920 --> 01:03:17.360]  совпадают, по крайней мере первые и бит у них совпадают. Ну вот этих двух товарищей. Давайте
[01:03:17.360 --> 01:03:46.680]  я словами напишу лучше. Старшие i, бит, маск и t совпадают. Вот. Тогда скажите мне,
[01:03:46.680 --> 01:04:04.320]  пожалуйста, чему равно dp t n, где n – это число битов во всех масках. Вся маска, да, просто x от
[01:04:04.320 --> 01:04:10.600]  всей маски t. Потому что если я в индексе суммирования накладываю дополнительные ограничения,
[01:04:10.600 --> 01:04:15.560]  что маска – это не просто подмаска t, но еще и совпадает с ней в первых и битах, то просто
[01:04:15.560 --> 01:04:23.440]  маска равно t. Единственное слагаемое во всей сумме – только x от t. Хорошо. Теперь давайте,
[01:04:23.440 --> 01:04:30.160]  зная вот эту вот вещь, давайте попробуем считать dp, ну, короче, там какие-то другие маски, будем
[01:04:30.160 --> 01:04:38.320]  уменьшать n. Потому что по факту понятно, что вот это вот просто dp, t – это и нулевое. С другой
[01:04:38.320 --> 01:04:45.840]  стороны. То есть ответ будет вот здесь. Ну, потому что если я здесь напишу вместо i ноль, то это все
[01:04:45.840 --> 01:04:52.720]  подмаски, у которых совпадают хотя бы первые ноль битов. Но это просто все подмаски. Вот. Теперь
[01:04:52.720 --> 01:05:01.480]  как я буду считать эту dp-шку? Ну, вот есть какая-то маска t. Вот сколько-то первых и битов у нее
[01:05:01.480 --> 01:05:10.600]  фиксированы, точнее наоборот, сколько-то много битов у нее фиксированы, я хочу перейти к i на 1
[01:05:10.600 --> 01:05:15.720]  поменьше. Ну понятно, надо тогда просто перебирать какое значение вот этого бита в подмаске и все.
[01:05:15.720 --> 01:05:26.880]  А именно я утверждаю следующее, что dp, t, t и минус первое – это примерно следующее. Давайте вот я
[01:05:26.880 --> 01:05:40.320]  рассмотрю вот этот вот бит. И ты бит сначала. Если он ноль, то он и в маске должен быть нулем.
[01:05:40.320 --> 01:05:46.560]  Значит можно было бы сказать, что если у меня первый i минус 1 бит совпадает, а здесь стоит
[01:05:46.560 --> 01:05:52.600]  ноль, то они и в битах просто совпадают. Потому что если здесь в маске t ноль, то значит он в
[01:05:52.600 --> 01:05:56.360]  подмаске тоже должен быть нулем. И значит, если у них i минус 1 совпадает, то и тоже
[01:05:56.360 --> 01:06:04.080]  подобно совпадает. Я могу написать, что вот это просто dp, t, t и t. Если и ты бит в маске t – это ноль.
[01:06:04.080 --> 01:06:21.240]  Если и ты бит t равен нулю. Ну а иначе, если здесь стоит единица, в этом бите в этом стоит единица,
[01:06:21.240 --> 01:06:29.200]  то тогда как выглядит подмаска, у которой первый i минус 1 бит совпадает с t? Надо просто перебирать
[01:06:29.200 --> 01:06:34.360]  значение вот этого бита, здесь стоит 0 или 1. Если 1, то значит она просто совпадает с t,
[01:06:34.360 --> 01:06:39.200]  опять-таки в i битах уже. А если здесь стоит ноль, то она совпадает с t без этого бита,
[01:06:39.200 --> 01:06:50.480]  а таки в i первых битах. В этом случае dp, t и t, точнее t и минус 1, это что такое? Еще раз,
[01:06:50.480 --> 01:06:56.000]  первый случай – это когда я продлеваю вот эти первые i минус 1 бит на еще один битик и говорю,
[01:06:56.000 --> 01:07:03.520]  что это тоже совпадает. Это просто dp, t и t. Либо же, то есть это все такие маски,
[01:07:03.520 --> 01:07:09.680]  которые совпадают не просто в i минус 1 битах, а в i битах сразу. В i первых битах. Плюс мне
[01:07:09.680 --> 01:07:14.960]  нужно учесть те маски, которые в первых i минус 1 совпали, а в i там уже не совпали. Значит у них
[01:07:14.960 --> 01:07:22.400]  здесь стоит ноль. Но если у них здесь стоит ноль, то можно было бы просто взять dp, t без i бита,
[01:07:22.400 --> 01:07:32.400]  в параметр мы. Потому что вот эта слагаемая отвечает всем таким маскам, которые вот здесь
[01:07:32.400 --> 01:07:38.160]  такие же как t, а здесь нолик. Ну потому что если они вот с этой маской совпадают в i битах,
[01:07:38.160 --> 01:07:42.960]  то они как раз ровно такие. Первые i минус 1 бит такие же как были в t, здесь нолик, но дачка те
[01:07:42.960 --> 01:07:53.960]  угодно. А потому что если здесь стоит ноль, то мы никак по-другому не можем продолжить,
[01:07:53.960 --> 01:07:58.880]  кроме как нулем. А поскольку мы рассматриваем под маски, то сюда единицу в маске, ну как бы вот,
[01:07:58.880 --> 01:08:06.120]  если в t этот бит нулевой, то в маске он тоже нулевой. Потому что мы под множество рассматриваем.
[01:08:12.960 --> 01:08:33.360]  Ну что? Ну вроде все. Тогда смотрите, мы получается ввели такую динамику, вот это вот ее база,
[01:08:33.360 --> 01:08:40.800]  мы считаем как бы динамику от больших и к меньшим. То есть я знаю для n, вычисляю,
[01:08:40.880 --> 01:08:45.480]  что это форма для n минус 1, н минус 2 и так далее вплоть до нуля. Ну если вот просто я делаю такие
[01:08:45.480 --> 01:08:51.840]  переходы, то в конце я для каждого t знаю дп t нулевое. А это и есть тот самый больший штрих,
[01:08:51.840 --> 01:09:01.320]  который я искал. Значит в итоге получилось следующее. За 2 в степени n на n, я посчитал всю вот эту
[01:09:01.320 --> 01:09:06.480]  дпшку, ну почему за столько? Потому что у меня первый аргумент это произвольное множество,
[01:09:06.480 --> 01:09:11.880]  то есть тут 2 в степени n возможных аргументов, здесь n возможных аргументов, ну n плюс 1. И
[01:09:11.880 --> 01:09:17.120]  переход у меня за единичку работает, поэтому вся дпшка насчитывается за 2 в степени n на n.
[01:09:17.120 --> 01:09:28.400]  За такое время я по факту насчитал все больших штрихи. За такое время найдем все больших штриха t.
[01:09:28.400 --> 01:09:36.360]  Ну вот, а это то, что мне было нужно. Если я знаю больших штриха t, то я знаю, вот у меня там есть
[01:09:36.360 --> 01:09:47.240]  форму выражения a через b, ну а дальше у меня есть форму выражения c через а. Профит. Сейчас алгоритм
[01:09:47.240 --> 01:10:03.080]  такой. Давайте быстренько еще раз произведу. Я перебираю всевозможные k за вот столько. Кстати,
[01:10:03.080 --> 01:10:07.640]  вот это можно вынести, потому что это от k не зависит. Это можно вынести в самое начало. Давайте
[01:10:07.640 --> 01:10:22.560]  я сначала это и сделаю. Насчитаем b штрих от t и b от s. Да, потому что здесь я внутри никак не
[01:10:22.560 --> 01:10:28.960]  пользовался значением k. Это вообще не зависит от задачи, не зависит от хроматического числа. Это
[01:10:28.960 --> 01:10:33.200]  просто отдельная k-дп-шка вспомогательная. Ну а дальше уже как раз перебираю всевозможные k.
[01:10:33.200 --> 01:10:49.160]  В порядке возрастания вычисляем а от s как k-той степень b. Вычисляем c от k. Если c от k положительно,
[01:10:49.160 --> 01:11:11.920]  то значит k это ответ. Ну что, сойдет?
[01:11:11.920 --> 01:11:26.560]  Там была формула, я вот стер. Там была явная формула через ашки. Вот вроде все.
[01:11:26.560 --> 01:11:42.920]  Тут еще надо сделать пара замечаний на самом деле, потому что вот если мы посмотрим внимательно
[01:11:42.920 --> 01:11:50.320]  формулу для c от k, как мы ее считали, там были довольно большие числа. Там было m в степени k
[01:11:50.320 --> 01:11:56.080]  слагаемое, но и вот эти все ашки тоже там это какая-то k-той степень чего-то. Эти все числа
[01:11:56.080 --> 01:12:02.240]  могут быть довольно большие. В частности, вот здесь было слагаемое m в степени k, где про m я
[01:12:02.240 --> 01:12:06.080]  знаю только лишь, что оно не больше 2 в степени n, потому что было количество независимых множеств.
[01:12:06.080 --> 01:12:12.880]  Если возвожу ее в k-той степень, где k может быть вплоть до n видимо, то это будет что-то в стиле 2
[01:12:12.880 --> 01:12:21.120]  в степени квадрат может быть довольно много, даже если он маленько. Вот и поэтому тут надо сказать
[01:12:21.120 --> 01:12:29.120]  примерно следующее. Либо мы, то есть здесь чтобы аккуратно оценить симпатику, мне в идеале нужно
[01:12:29.120 --> 01:12:33.960]  было бы сказать, какого размера у нас получаются все числа, потому что если считаем степени k,
[01:12:33.960 --> 01:12:38.320]  то мне видимо ни нитов, ни лонг-лонгов ничего не хватит. Нужно переходить в какую-то длинную
[01:12:38.320 --> 01:12:43.760]  рифметику, считать длину от этого числа. И соответственно, чем длиннее числа, тем дольше
[01:12:43.760 --> 01:12:49.920]  работает алгоритм. И поэтому надо было бы аккуратно посчитать длину от этого числа, посчитать,
[01:12:49.920 --> 01:12:55.320]  за сколько мы это умножаем, вычитаем и так далее. Либо можно поступить хитрее и сказать следующее.
[01:12:55.320 --> 01:13:04.120]  Ну, смотрите, давайте не считать точный ответ, а давайте посчитаем его в большом модулю, 10-9 или
[01:13:04.120 --> 01:13:09.120]  что-нибудь такое. Тогда все эти числа, они остаются маленькие, их можно спокойно в инде хранить и
[01:13:09.120 --> 01:13:15.080]  возродить. В степенях можно быстро, и складывать, вычитать можно довольно быстро. Ну, тогда понятно,
[01:13:15.080 --> 01:13:18.440]  что если у вас было какое-то положительное число, и вы взяли его в какую-нибудь модулю,
[01:13:18.660 --> 01:13:24.040]  случайному модулю например, вместо 10-9 давайте иду в случайный модуль. Тогда с какой вероятностью
[01:13:24.040 --> 01:13:29.480]  положительное число занулиться по случайному модулю? Ну, с маленькой, наверное. А если вы взяли
[01:13:29.480 --> 01:13:33.720]  достаточно большой модуль, но при этом случайный, тогда вероятность того, что положительное число
[01:13:33.720 --> 01:13:38.840]  занулилось, она при небрежиме маленькая. И вместо того, чтобы явным образом считать длинную рифметику,
[01:13:38.840 --> 01:13:44.120]  можно было бы просто посчитать ответ по модулю П, для большого П. Если он не нулевой, то значит,
[01:13:44.120 --> 01:13:48.000]  то исходное число не нулевое. А если нулевой, то исходное тоже было, наверное, нулевое.
[01:13:48.000 --> 01:14:06.780]  Понятно? Вот, хорошо. Ну, тогда давайте последнее, что скажу. Это очень родственная задача, называется
[01:14:06.780 --> 01:14:20.700]  set cover. Задача, собственно, о покрытии множественной. Задача о покрытии множественной.
[01:14:20.700 --> 01:14:35.260]  Set cover. Значит, задача такая. Представьте, что у вас есть несколько множеств, с 1, с 2 и так далее,
[01:14:35.260 --> 01:14:42.820]  с к, объединение которых, ну это там какой-нибудь универсум у. То есть они все лежат в коробочке у
[01:14:42.820 --> 01:14:51.820]  и как-то его накрывают. В объединении дают все у. Задача такая. Нужно выбрать минимальные их
[01:14:51.820 --> 01:15:04.460]  подмножества, которые по-прежнему в объединении дают все у. Ка у меня уже занято, давайте назову
[01:15:04.460 --> 01:15:18.780]  д. Минимальное д такое, что объединение каких-то д из них дает все у. Вот, то есть у вас есть много
[01:15:18.780 --> 01:15:23.260]  множеств, к множеств, объединения которых есть у. Вам нужно выбрать как можно меньше из них,
[01:15:23.260 --> 01:15:34.060]  чтобы сохранить это условие, что их объединение все еще у. Вот. Решается точно так же. Ну, например,
[01:15:34.060 --> 01:15:48.620]  можно так же решать. Ну, можно так, можно так, можно так, да, можно так. А можно, если у вас к
[01:15:48.620 --> 01:15:55.700]  большое универсум маленький, вот если я скажу, что у вот эту штуку у вас маленькая достаточно,
[01:15:55.700 --> 01:16:03.100]  то можно за подобным алгоритмом, ну то же самое сделать с помощью формулки исключения,
[01:16:03.100 --> 01:16:10.020]  посчитать сколько есть накрытий у с помощью там к из них, с помощью д из них. Решается аналогично.
[01:16:10.020 --> 01:16:19.180]  Потому что в прошлой задаче я как раз ровно это и делал. Да, у меня было несколько хороших множеств,
[01:16:19.180 --> 01:16:24.980]  вот теперь с-ками выступают все независимые, как бы можно взять вместо с независимые множества. Да,
[01:16:24.980 --> 01:16:28.820]  и мне как раз нужно было взять как можно меньше из них, так чтобы в объединении они покрыли все
[01:16:28.820 --> 01:16:33.780]  множество вишен В. Ну, то же самое, просто как бы, просто об общении. Я по факту ровно эту
[01:16:33.780 --> 01:16:39.900]  задачу решил. Вот, значит, проект-задача тоже известна, что она, наверное, трудная. И лучше,
[01:16:39.900 --> 01:16:44.220]  на что можно надеяться, это вот что-то такое экспенсиальное. Ну, у нас и получается что-то в стиле
[01:16:44.220 --> 01:16:54.180]  2n на n. Ну, короче, что-то примерно такое по симптомике. Вот, тогда все. Спасибо.
