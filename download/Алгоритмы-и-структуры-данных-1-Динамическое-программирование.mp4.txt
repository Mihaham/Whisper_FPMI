[00:00.000 --> 00:29.000]  Так, вы знаете, сегодня довольно на расслабоне, будет несколько простых задач, поэтому я надеюсь, что многое из этого вам откуда-нибудь будет знакомо, поэтому удивляйтесь, если будет не очень узнавательное.
[00:29.000 --> 00:33.000]  Ну, будем на несколько прикрыть.
[00:43.000 --> 00:45.000]  Я разберу просто несколько задач.
[00:45.000 --> 00:48.000]  Плотнично-клёво плотнично.
[00:48.000 --> 00:53.000]  Так, потому что нормального определения, что такое девичка проиграет, можно применять.
[00:53.000 --> 00:56.000]  А может, где-то есть, но оно точно бесполезно.
[00:56.000 --> 01:01.000]  Вот, просто на некоторых примерах посмотрим, как этим можно пользоваться и что с этим можно делать.
[01:02.000 --> 01:05.000]  Первое.
[01:09.000 --> 01:12.000]  Представьте, что у вас есть массив чисел.
[01:14.000 --> 01:17.000]  Пусть они где-то не предпочитаются, возможно, официально.
[01:20.000 --> 01:26.000]  Вот, и есть у вас перед этим массивом стоит кого-нибудь человек, кто-нибудь нечего.
[01:26.000 --> 01:30.000]  Какая точка проигрывает весь этот массив?
[01:30.000 --> 01:36.000]  Направится максимальную сумму, но при этом за каждую спальню может быть вернёт на предпочтительность или нет.
[01:36.000 --> 01:38.000]  Либо в плотную стельницу.
[01:38.000 --> 01:40.000]  То есть свой понятие величины один или два.
[01:40.000 --> 01:42.000]  Сложно.
[01:44.000 --> 01:46.000]  Один или два вперёд.
[01:46.000 --> 01:48.000]  Закончить.
[01:48.000 --> 01:52.000]  Ну, давайте мы попросим, чтобы мы начали заканчивать в последнем элементе.
[01:52.000 --> 01:54.000]  Конечно, выжираем.
[01:54.000 --> 01:57.000]  Заканчиваем в последнем элементе.
[01:57.000 --> 02:02.000]  Ну, и мы хотим максимизировать сумму тех элементов, которые мы просмотрели.
[02:02.000 --> 02:08.000]  Масимизируем сумму посещённых элементов.
[02:08.000 --> 02:13.000]  Масимизируем сумму посещённых элементов.
[02:21.000 --> 02:25.000]  Давайте сумму не подключать в дальнейшее время.
[02:25.000 --> 02:26.000]  Ага.
[02:26.000 --> 02:27.000]  Ну, не всем.
[02:27.000 --> 02:28.000]  Хорошо.
[02:28.000 --> 02:31.000]  Кому-то будет фалет.
[02:31.000 --> 02:33.000]  Что же я должен сказать?
[02:37.000 --> 02:44.000]  В крайней мере, какие-то базовые вещи, которые будут во всех остальных задачах, которые можно проинвестировать.
[02:44.000 --> 02:46.000]  Итак, значит, вопрос.
[02:46.000 --> 02:49.000]  Давайте я скажу, что пусть мой пузнечик прыгает-прыгает-прыгает.
[02:49.000 --> 02:51.000]  И в этот момент я его на сильно останавливаю.
[02:51.000 --> 02:53.000]  Вот, например, такую-то запрыгал.
[02:53.000 --> 02:55.000]  Сейчас мы пустим её здесь.
[02:55.000 --> 02:57.000]  Я знаю всю историю его победения.
[02:58.000 --> 03:02.000]  Вот вопрос.
[03:02.000 --> 03:06.000]  Чтобы дальше он действовал как-то оптимально.
[03:06.000 --> 03:09.000]  Чтобы нам дальше было понятно, как оно нужно себя вести.
[03:09.000 --> 03:10.000]  Вопрос.
[03:10.000 --> 03:12.000]  Что из этой всей информации нам достаточно проявить?
[03:12.000 --> 03:15.000]  Вот из всего этого пути, из всех элементов, которые он посетил.
[03:15.000 --> 03:17.000]  Что нам достаточно проявить?
[03:17.000 --> 03:20.000]  Ну да, конечно, не очень много информации.
[03:20.000 --> 03:23.000]  В частности, какой элемент он проявил, нам не очень интересно.
[03:23.000 --> 03:28.000]  Если мы закручиваем в каком-то аитном элементе, то нам не важно, как именно мы сюда попадем.
[03:28.000 --> 03:30.000]  Вот так, когда прыгает.
[03:30.000 --> 03:32.000]  В принципе, не очень важно.
[03:32.000 --> 03:35.000]  Если мы знаем какую-то сумму, которую набрали, то этого достаточно.
[03:35.000 --> 03:37.000]  Вот, ну вот, значит, отсюда такая идея.
[03:37.000 --> 03:44.000]  Давайте, чтобы хранить ответ, я хочу для каждого айти знать максимально возможную сумму, которую можно набрать.
[03:44.000 --> 03:48.000]  Если я начинаю вот здесь вот и закреплюсь в его айтичеке.
[03:48.000 --> 03:50.000]  Мы поняли, какой информации нам достаточно проявить.
[03:50.000 --> 03:52.000]  Давайте я его хранить.
[03:52.000 --> 03:56.000]  Поэтому я вошу в айтичек.
[03:56.000 --> 03:58.000]  Собственно, данный метод.
[03:58.000 --> 04:01.000]  Вот и эта максимальная сумма.
[04:03.000 --> 04:05.000]  Можем набрать.
[04:12.000 --> 04:14.000]  Вот старта.
[04:14.000 --> 04:16.000]  Долг.
[04:17.000 --> 04:21.000]  Ну, и причем, имеется в виду, что наш путь заканчивается именно здесь.
[04:21.000 --> 04:23.000]  Вот в этом предыдущем последовательстве.
[04:25.000 --> 04:27.000]  Ввели такую величину.
[04:27.000 --> 04:32.000]  Ну, дальше, например, можно сказать, что такой нулевой экономик.
[04:32.000 --> 04:35.000]  Да, что это обратная база нашей знаменики.
[04:35.000 --> 04:36.000]  База нашего настига.
[04:36.000 --> 04:40.000]  Потому что в самом начале, когда у меня нет еще элементов, мы стоим здесь.
[04:40.000 --> 04:43.000]  Единственный способ остаться в нуле, это никуда не ходить.
[04:43.000 --> 04:45.000]  Поэтому сумма нулевая.
[04:45.000 --> 04:48.000]  Ну, и дальше можно, например, написать следующее.
[05:00.000 --> 05:06.000]  Потому что если я обещаю себе, что я заканчиваюсь в этом элементе, то как я мог туда пропасть?
[05:06.000 --> 05:09.000]  Ну, либо прыжком плюс один, либо прыжком плюс два.
[05:09.000 --> 05:13.000]  Да, и соответственно, если я знаю, что мой последний прыг был вот такой вот.
[05:13.000 --> 05:16.000]  То есть я пришел из элемента с номеров не минус один.
[05:16.000 --> 05:19.000]  Тогда нам нужно было сначала, от начала, как туда прыгать, до сюда.
[05:19.000 --> 05:22.000]  Потом сделать один прыжок плюс один, вот сюда.
[05:22.000 --> 05:26.000]  Ну, тогда ясно делал, что нам нужно было от начала до сюда прыгать, и оптимально возможное.
[05:26.000 --> 05:28.000]  Что у нас тут, в принципе, в детдажке.
[05:28.000 --> 05:35.000]  Потому что если я максимизирую сумму, заканчивается на аи, при этом я знаю, что предпоседнее слогами это аи минус один,
[05:35.000 --> 05:38.000]  то значит мне нужно оптимальным образом пропрыгать от нуля до аи минус один.
[05:38.000 --> 05:40.500]  что уже хранится в массиве ДП и уничтожение.
[05:40.500 --> 05:44.500]  Это на второй случай, наоборот, когда я последний шаг сделаю на плюс два,
[05:44.500 --> 05:45.500]  вот так вот скачу,
[05:45.500 --> 05:48.500]  тогда мне нужно было от начала выпрыгать до и-минус два,
[05:48.500 --> 05:50.000]  вот этого вот величина,
[05:50.000 --> 05:53.500]  и потом сделать прыжок в последние вещи и подавать консету i.
[05:54.500 --> 05:55.500]  Понятно?
[05:56.500 --> 05:58.500]  Ну, естественно, это переход в коллекцию,
[05:58.500 --> 06:00.500]  не только если и, видимо, хотя бы двойка,
[06:01.500 --> 06:04.500]  мы вспоминаем, как будет обращение к минус первому элементу.
[06:04.500 --> 06:07.500]  Но вот я не буду подробно прописывать, что это верно.
[06:07.500 --> 06:09.000]  Давайте один раз сделаю.
[06:09.000 --> 06:12.000]  То есть форма, наверное, верна только если у тебя будет двойка.
[06:12.000 --> 06:15.000]  А если единица, то у меня вот эта величина неопределена,
[06:15.000 --> 06:18.500]  потому что нельзя в единицу прийти с помощью прыжка плюс два.
[06:18.500 --> 06:21.000]  Ну, тогда просто у меня в массиве вот этой величины не будет.
[06:21.000 --> 06:24.000]  Я не могу брать ДП с индексом минус один,
[06:24.000 --> 06:26.000]  поэтому просто из массива эта величина как-то удаляется,
[06:26.000 --> 06:28.000]  я ее там не раскручиваю.
[06:28.000 --> 06:30.000]  Ну, а вот в общем случае именно такая же.
[06:32.000 --> 06:33.000]  Вот.
[06:33.000 --> 06:34.000]  Ну и все, просто это выглядит очень просто.
[06:34.000 --> 06:36.000]  Мы делаем просто вот это.
[06:38.000 --> 06:41.000]  Потом в тыпле вот ам.
[06:41.000 --> 06:43.000]  Вот эту строчку просто записываем,
[06:43.000 --> 06:47.000]  аккуратно выбирая случай, когда вот эта вот штука не существует.
[06:48.000 --> 06:50.000]  Вот. В остальных случаях, собственно, основная форма.
[06:52.000 --> 06:53.500]  Сюда копируем.
[06:53.500 --> 06:54.500]  Окей?
[06:56.500 --> 06:58.000]  Вот. Хорошо.
[06:58.000 --> 07:01.500]  Ну и тогда понятно, что ответ это просто ДП с индексом bm.
[07:02.500 --> 07:07.500]  Потому что, потому что мне нужно обязательно закончиться в бельной ячейке.
[07:07.500 --> 07:08.500]  Вот.
[07:08.500 --> 07:11.500]  И, собственно, там ровно эта величина или нет.
[07:12.500 --> 07:13.500]  Конец.
[07:15.500 --> 07:18.500]  Значит, несколько, несколько замечаний.
[07:18.500 --> 07:23.500]  Во-первых, ну это более-менее единственное решение этой задачи.
[07:23.500 --> 07:28.500]  С той точки зрения, что если бы мы пытались реализовать какой-нибудь жарный алдемитом,
[07:28.500 --> 07:33.500]  в стиле не пытаться для каждого кинфредного пьет находить оптимальные ответы,
[07:33.500 --> 07:35.500]  потом из двух оптимальных что-то выбирать.
[07:35.500 --> 07:36.500]  А если как-то жарно.
[07:36.500 --> 07:38.500]  Там, например, вот есть у меня мой массид,
[07:38.500 --> 07:40.500]  а есть в зале аинда.
[07:41.500 --> 07:44.500]  И я как-то хочу, просто смотря на два в одном варианта,
[07:44.500 --> 07:47.500]  куда я могу перейти, куда я могу прыгнуть,
[07:47.500 --> 07:48.500]  выбирать на них оптимальный.
[07:48.500 --> 07:50.500]  Ну, например, если там здесь есть отрицательное число,
[07:50.500 --> 07:52.500]  то его хочется, хотелось бы скипать.
[07:52.500 --> 07:56.500]  Если это отрицательное положение, то я буду по всю прыгнуть.
[07:56.500 --> 07:57.500]  И наоборот.
[07:57.500 --> 07:59.500]  Если это отрицательное положение, то я буду сюда прыгнуть.
[07:59.500 --> 08:02.500]  В общем, что-то такое, вот такая локальная оптимизация,
[08:02.500 --> 08:08.500]  когда мы пытаемся, смотря только на возможные варианты вперед,
[08:08.500 --> 08:10.500]  сравнить их и как это вперед прыгнуть.
[08:11.500 --> 08:13.500]  Так вот, на самом деле, никакой такой жарный алдемитом,
[08:13.500 --> 08:14.500]  как бы вы не придумали,
[08:14.500 --> 08:19.500]  если он смотрит на два впереди стоящего числа
[08:19.500 --> 08:21.500]  и выбирает, извините, каким-то образом оптимальное,
[08:21.500 --> 08:23.500]  то можно всегда подобрать фронтер тест, который,
[08:23.500 --> 08:27.500]  ну, собственно, на котором найденный вами путь
[08:27.500 --> 08:30.500]  будет менее оптимальным, чем тот, который нашли с помощью DPI.
[08:30.500 --> 08:33.500]  Вот в DPI-шке можно очень легко оказать корректность.
[08:33.500 --> 08:36.500]  Собственно, здесь ничего не получится.
[08:36.500 --> 08:37.500]  А здесь легко оказать корректность,
[08:37.500 --> 08:40.500]  ну, потому что там можно конкретно индукцией показать,
[08:40.500 --> 08:45.500]  что к моменту времени, когда у меня пройдены и перитратные цикла,
[08:45.500 --> 08:47.500]  у меня будет корректно найдена DPI.
[08:47.500 --> 08:49.500]  Ну, собственно, очень легко доказаться по индукции,
[08:49.500 --> 08:51.500]  потому что вначале у меня DPI 0,
[08:51.500 --> 08:53.500]  на базной индукции.
[08:53.500 --> 08:54.500]  Дальше.
[08:54.500 --> 08:57.500]  Если у меня для всех шагов от первого до и минус первого DPI-шка
[08:57.500 --> 08:58.500]  правильная найдена,
[08:58.500 --> 09:01.500]  то DPI-то мы вот здесь подробно разбирали.
[09:01.500 --> 09:02.500]  Чему равно оптимальная DPI-то?
[09:02.500 --> 09:04.500]  Надо просто перебрать последний шаг,
[09:04.500 --> 09:06.500]  и в зависимости от того, какой он имеет длину,
[09:06.500 --> 09:08.500]  взять и будет вылучшить динамики.
[09:08.500 --> 09:10.500]  И если они пощипнут неправильно,
[09:10.500 --> 09:11.500]  а это так по предположению индукции,
[09:11.500 --> 09:14.500]  то, собственно, DPI-то выражается правильно по такой факт.
[09:16.500 --> 09:17.500]  Да.
[09:17.500 --> 09:19.500]  А вот как динамика значит?
[09:19.500 --> 09:21.500]  Ну, вот тут тяжело сформулировать
[09:21.500 --> 09:23.500]  какого-то конкретного жадника.
[09:23.500 --> 09:25.500]  Если он не скажет какой-нибудь конкретный алгоритм,
[09:25.500 --> 09:28.500]  то мы можем попробовать построить конкретный тест.
[09:28.500 --> 09:29.500]  А в общем случае?
[09:29.500 --> 09:32.500]  Ну, в общем случае, типа, тяжело,
[09:32.500 --> 09:34.500]  потому что он не банярский алгоритм.
[09:34.500 --> 09:36.500]  Хотя этот алгоритм, тем более жадный алгоритм,
[09:36.500 --> 09:37.500]  не очень приятный.
[09:37.500 --> 09:38.500]  То есть, скорее наоборот,
[09:38.500 --> 09:40.500]  вы обгодите какой-то конкретный аппарат,
[09:40.500 --> 09:42.500]  который действует так-то,
[09:42.500 --> 09:45.500]  и в зависимости от этого можно придумать конкретный тест.
[09:45.500 --> 09:46.500]  Так.
[09:48.500 --> 09:50.500]  Я это сказал.
[09:50.500 --> 09:53.500]  Да, давайте еще очень точку на всякий случай оценим.
[09:57.500 --> 09:59.500]  Ну, по времени-то все понятно.
[10:04.500 --> 10:06.500]  Может, просто один линию тыквы.
[10:06.500 --> 10:09.500]  Вот, а с памятью можно добиться,
[10:09.500 --> 10:11.500]  на самом деле, вот, и денницы памяти.
[10:12.500 --> 10:14.500]  И это очень распространено
[10:14.500 --> 10:16.500]  это очень распространенный трюк
[10:16.500 --> 10:18.500]  от вакционно-динамичного программирования.
[10:18.500 --> 10:21.500]  Если мы аккуратно посмотрим на те значения DPI,
[10:21.500 --> 10:23.500]  которые нам важны с каждого конкретного момента,
[10:23.500 --> 10:25.500]  то мы поймем, что их все как бы три штуки.
[10:25.500 --> 10:27.500]  Потому что, чтобы найти DPI,
[10:27.500 --> 10:29.500]  мне нужно знать только два предыдущих.
[10:29.500 --> 10:31.500]  Поэтому если я храню их,
[10:31.500 --> 10:33.500]  через них высчитываю третья,
[10:33.500 --> 10:35.500]  да, так в том числе вот этого DPI,
[10:35.500 --> 10:36.500]  мне уже будет не нужен.
[10:36.500 --> 10:38.500]  Поэтому вместо хранения всего массива DPI,
[10:38.500 --> 10:40.500]  я могу бы позволить себе хранить
[10:40.500 --> 10:42.500]  только три вот этих подпаседливых значения.
[10:42.500 --> 10:44.500]  Предыдущие, предыдущие и текущие.
[10:44.500 --> 10:46.500]  Когда я перейду к следующему,
[10:46.500 --> 10:48.500]  мне, соответственно, вот это значение DPI,
[10:48.500 --> 10:50.500]  все будет интересно, я его забываю,
[10:50.500 --> 10:52.500]  или там, на его месте записываю новую информацию.
[10:52.500 --> 10:54.500]  Поэтому память можно добиться просто
[10:54.500 --> 10:56.500]  константной, храня несколько
[10:56.500 --> 10:58.500]  последних значенных элементов массива DPI.
[11:02.500 --> 11:04.500]  Окей?
[11:04.500 --> 11:06.500]  Ну, все, хорошо, давайте тогда
[11:06.500 --> 11:08.500]  быстро еще вторую долгу создать.
[11:08.500 --> 11:10.500]  Это уже будет задача
[11:10.500 --> 11:12.500]  на табличке.
[11:12.500 --> 11:14.500]  Представьте, что у нас есть
[11:14.500 --> 11:16.500]  табличка NL.
[11:16.500 --> 11:18.500]  Опять-таки в каждой ячейке
[11:18.500 --> 11:20.500]  написано число.
[11:26.500 --> 11:28.500]  Вот, мы с Тайли, ну давайте, например,
[11:28.500 --> 11:30.500]  вот здесь вот изначально численно 1 на 1,
[11:30.500 --> 11:32.500]  хотим попасть вот сюда,
[11:32.500 --> 11:34.500]  и можем мы ходить
[11:34.500 --> 11:36.500]  только, например, вниз или вправо.
[11:40.500 --> 11:42.500]  В предоступной ходе
[11:42.500 --> 11:44.500]  я могу пойти либо
[11:44.500 --> 11:46.500]  строго вниз на 1,
[11:46.500 --> 11:48.500]  либо строго вправо.
[11:58.500 --> 12:00.500]  Ошибать общее правило.
[12:00.500 --> 12:02.500]  Давайте, допустим,
[12:02.500 --> 12:04.500]  наш товарищ, который ходит,
[12:04.500 --> 12:06.500]  допустим,
[12:06.500 --> 12:08.500]  наш путь,
[12:08.500 --> 12:10.500]  и в какой-то момент его остановим.
[12:14.500 --> 12:16.500]  Опять-таки, чтобы продолжить
[12:16.500 --> 12:18.500]  наше движение, из всего этого пути нам
[12:18.500 --> 12:20.500]  достаточно знать две вещи. Где мы закончились
[12:20.500 --> 12:22.500]  и какую набрали сумму.
[12:22.500 --> 12:24.500]  Потому что как именно мы сюда попали
[12:24.500 --> 12:26.500]  с точки зрения
[12:26.500 --> 12:28.500]  дополнения ответа до конца нам не очень интересно.
[12:28.500 --> 12:30.500]  Мы пошли вот так вот, или вот так вот,
[12:30.500 --> 12:32.500]  или вот так вот, неважно. Важно только последний ответ
[12:32.500 --> 12:34.500]  и сумму.
[12:34.500 --> 12:36.500]  Ну, поэтому давайте, собственно, эти величины
[12:36.500 --> 12:38.500]  в массиве db.
[12:38.500 --> 12:40.500]  Пусть db не держится.
[12:42.500 --> 12:44.500]  Это максимальная сумма
[12:48.500 --> 12:50.500]  на пути
[12:50.500 --> 12:52.500]  от
[12:52.500 --> 12:54.500]  с этим
[12:54.500 --> 12:56.500]  до иши.
[13:02.500 --> 13:04.500]  Будет уже
[13:04.500 --> 13:06.500]  квадратный дизайн,
[13:06.500 --> 13:08.500]  по нашей табличке, по нашим админансам.
[13:14.500 --> 13:16.500]  Это, собственно,
[13:16.500 --> 13:18.500]  начало нашего пути. В этом случае
[13:18.500 --> 13:20.500]  это будет dp1,1 равно a1,1.
[13:20.500 --> 13:22.500]  Этот элемент, мы когда еще не делали
[13:22.500 --> 13:24.500]  одного шага, у нас уже есть одно число.
[13:24.500 --> 13:26.500]  Оно взято в сумме, поэтому, собственно,
[13:26.500 --> 13:28.500]  мы его взяли в админанс.
[13:28.500 --> 13:30.500]  Это будет начало нашего дизайна,
[13:30.500 --> 13:32.500]  ну и переход
[13:32.500 --> 13:34.500]  давайте в таком же стиле.
[13:36.500 --> 13:38.500]  Вот вопрос. Если я зафиксировал
[13:38.500 --> 13:40.500]  некую ячейку иши,
[13:40.500 --> 13:42.500]  то как я мог в нее попасть?
[13:42.500 --> 13:44.500]  Давайте рассмотрим последний шаг,
[13:44.500 --> 13:46.500]  который нас привел в эту конкретную клетку иши.
[13:46.500 --> 13:48.500]  Ну, откуда я мог попасть в эту клетку?
[13:48.500 --> 13:50.500]  Либо слева, либо сверху.
[13:50.500 --> 13:52.500]  То есть, если здесь были входи вниз
[13:52.500 --> 13:54.500]  и вправо, то, наоборот,
[13:54.500 --> 13:56.500]  обратно это
[13:56.500 --> 13:58.500]  слева
[13:58.500 --> 14:00.500]  или сверху.
[14:00.500 --> 14:02.500]  Но мы не знаем, как мы сюда попали.
[14:02.500 --> 14:04.500]  Давайте переберем последний шаг.
[14:04.500 --> 14:06.500]  Соответственно,
[14:06.500 --> 14:08.500]  если я вдруг откуда-то знаю, что
[14:08.500 --> 14:10.500]  оптимальный шаг был вот такой вот,
[14:10.500 --> 14:12.500]  вот так надо было сюда прийти,
[14:12.500 --> 14:14.500]  тогда мне нужно просто из 1,1
[14:14.500 --> 14:16.500]  оптимальным пунктом добраться сюда
[14:16.500 --> 14:18.500]  до этой клетки иши-1.
[14:18.500 --> 14:20.500]  Потом с помощью вот этого
[14:20.500 --> 14:22.500]  ребра вправо попасть сюда.
[14:22.500 --> 14:24.500]  Потому что если я откуда-то знаю,
[14:24.500 --> 14:26.500]  что это ребро оптимальное,
[14:26.500 --> 14:28.500]  то начало пути
[14:28.500 --> 14:30.500]  из 1,1 и иши-1.
[14:30.500 --> 14:32.500]  Ну и, наоборот, если я откуда-то знаю,
[14:32.500 --> 14:34.500]  что оптимальное ребро это вот такое,
[14:34.500 --> 14:36.500]  вертикальное, то мне нужно из 1,1
[14:36.500 --> 14:38.500]  сначала попасть в эту клетку,
[14:38.500 --> 14:40.500]  как натуральный иши-1, и потом
[14:40.500 --> 14:42.500]  это ребро последний использовать.
[14:42.500 --> 14:44.500]  Но поскольку я на самом деле не знаю,
[14:44.500 --> 14:46.500]  какой из этих вариантов оптимальный,
[14:46.500 --> 14:48.500]  мне нужно ни в кого посмотреть, понять,
[14:48.500 --> 14:50.500]  какие они производят ответы,
[14:50.500 --> 14:52.500]  то есть вот такая сумма чему бы равна,
[14:52.500 --> 14:54.500]  вот такая сумма чему бы равна,
[14:54.500 --> 14:56.500]  из них выбрать просто оптимальный.
[14:56.500 --> 14:58.500]  Ну так и делаем.
[15:00.500 --> 15:02.500]  Dp, Dn, Dt.
[15:02.500 --> 15:04.500]  Это что?
[15:04.500 --> 15:06.500]  Ну здесь опять число i и j у меня гарантированно
[15:06.500 --> 15:08.500]  будет в сумме, поэтому я его насильно сюда вписываю.
[15:08.500 --> 15:10.500]  И дальше нужно просто
[15:10.500 --> 15:12.500]  из двух веществ выбрать максимум.
[15:12.500 --> 15:16.500]  Максимум из Dp и иши-1,
[15:16.500 --> 15:20.500]  Dp и иши-1.
[15:22.500 --> 15:24.500]  Я не знаю, откуда конкретно я пришел,
[15:24.500 --> 15:26.500]  но из этих двух веществ надо выбрать максимум.
[15:34.500 --> 15:36.500]  Хорошо.
[15:38.500 --> 15:40.500]  Еще я скажу про вот это вот
[15:40.500 --> 15:42.500]  конкретно
[15:42.500 --> 15:44.500]  i-1, j-1.
[15:44.500 --> 15:46.500]  Я подразумеваю, что
[15:46.500 --> 15:48.500]  это переход валиден,
[15:48.500 --> 15:50.500]  когда вот эти два перехода валидны.
[15:50.500 --> 15:52.500]  То есть можно было прийти вверх, можно было прийти вверх.
[15:52.500 --> 15:54.500]  Но это не работает
[15:54.500 --> 15:56.500]  в частности для лечей
[15:56.500 --> 15:58.500]  этой первого столбца
[15:58.500 --> 16:00.500]  или первой строки.
[16:00.500 --> 16:02.500]  Для этих лечей я не мог прийти
[16:02.500 --> 16:04.500]  либо слева, либо справа.
[16:04.500 --> 16:06.500]  Для них я не мог прийти слева,
[16:06.500 --> 16:08.500]  для них не мог прийти сверху.
[16:08.500 --> 16:10.500]  А именно если вот это вот есть,
[16:10.500 --> 16:12.500]  то есть если клетка слева была,
[16:12.500 --> 16:14.500]  если именно с 1,
[16:14.500 --> 16:16.500]  наоборот это клетка сверху получается,
[16:16.500 --> 16:18.500]  то есть если вот эту клетку все струит,
[16:18.500 --> 16:20.500]  тогда ее надо рассматривать максимум.
[16:20.500 --> 16:22.500]  Иначе просто надо как бы стереть отсюда
[16:22.500 --> 16:24.500]  и не рассматривать.
[16:24.500 --> 16:26.500]  То же самое здесь.
[16:26.500 --> 16:28.500]  Если клетка слева присутствует,
[16:28.500 --> 16:30.500]  тогда она присутствует максимум,
[16:30.500 --> 16:32.500]  иначе надо просто стереть.
[16:32.500 --> 16:34.500]  И там будет тупая строчка в стиле i-1
[16:34.500 --> 16:36.500]  плюс максимум из просто одного элемента.
[16:36.500 --> 16:38.500]  То есть если я вот этого сотру,
[16:38.500 --> 16:40.500]  и максимум можно опустить,
[16:40.500 --> 16:42.500]  будет просто вот так.
[16:42.500 --> 16:44.500]  В общем, ну тут
[16:44.500 --> 16:46.500]  общая форму отраски такая,
[16:46.500 --> 16:48.500]  а в частном случае,
[16:48.500 --> 16:50.500]  если значений динамики у меня просто нету,
[16:50.500 --> 16:52.500]  надо просто изымповать.
[16:52.500 --> 16:54.500]  Либо же более такой
[16:54.500 --> 16:56.500]  универсальный способ,
[16:56.500 --> 16:58.500]  можно наш МДП
[16:58.500 --> 17:00.500]  продлить на те самые неопределенные значения.
[17:00.500 --> 17:02.500]  Можно просто МДП расширить
[17:02.500 --> 17:04.500]  на клетку влево и вверх.
[17:08.500 --> 17:10.500]  Или там даже лучше не нули,
[17:10.500 --> 17:12.500]  а минус бесконечности,
[17:12.500 --> 17:14.500]  потому что числа сами могут быть отрицательны.
[17:14.500 --> 17:16.500]  Поэтому давайте лучше здесь поставлю
[17:16.500 --> 17:18.500]  МДП.
[17:18.500 --> 17:20.500]  Давайте вот здесь вот вверх
[17:20.500 --> 17:22.500]  и поставлю минус бесконечности.
[17:22.500 --> 17:24.500]  В массиве МДП.
[17:26.500 --> 17:28.500]  И тогда
[17:28.500 --> 17:30.500]  если я буду пытаться
[17:30.500 --> 17:32.500]  перейти в контентные ячейки нежи
[17:32.500 --> 17:34.500]  из несуществующей ячейки,
[17:34.500 --> 17:36.500]  то я по факту буду брать вот здесь
[17:36.500 --> 17:38.500]  вместо одного из значений
[17:38.500 --> 17:40.500]  минус бесконечности.
[17:40.500 --> 17:42.500]  Но это то же самое, как если бы вообще в случае не рассматривать.
[17:42.500 --> 17:44.500]  Потому что если это сколько именно бесконечности,
[17:44.500 --> 17:46.500]  то можно просто перейти в контентные ячейки.
[17:50.500 --> 17:52.500]  Можно по-разному избавляться
[17:52.500 --> 17:54.500]  от невалидных шагов.
[17:54.500 --> 17:56.500]  Наверное, самый удобный в данном примере
[17:56.500 --> 17:58.500]  это поставить на массиве МДП
[17:58.500 --> 18:00.500]  здесь минус бесконечности,
[18:00.500 --> 18:02.500]  когда там нельзя влевать.
[18:02.500 --> 18:04.500]  Если тогда если я буду припить,
[18:04.500 --> 18:06.500]  то пагами надо сделать очень-очень-очень маленький.
[18:06.500 --> 18:08.500]  Большим помогает рецепт.
[18:14.500 --> 18:16.500]  Рецепт понятно где.
[18:16.500 --> 18:18.500]  ДП и НМ,
[18:18.500 --> 18:20.500]  потому что мне сказали, что надо закончить свой рецепт.
[18:28.500 --> 18:30.500]  НМ времени погиб на деле.
[18:32.500 --> 18:34.500]  А потому что каждое конкретное значение ДП
[18:34.500 --> 18:36.500]  перехвили за 1,
[18:36.500 --> 18:38.500]  за каждое конкретное значение нежи
[18:38.500 --> 18:40.500]  мне нужно какие-то ригмидические операции сделать.
[18:40.500 --> 18:42.500]  Ну а с памятью здесь
[18:42.500 --> 18:44.500]  похожий прикол.
[18:44.500 --> 18:46.500]  Можно делать вступлую
[18:46.500 --> 18:48.500]  за такое же количество памяти.
[18:54.500 --> 18:56.500]  Но можно заметить, например,
[18:56.500 --> 18:58.500]  что если я буду идти по строкам
[19:00.500 --> 19:02.500]  то мне достаточно будет
[19:02.500 --> 19:04.500]  справиться только две последние строки.
[19:04.500 --> 19:06.500]  Потому что значение ДП
[19:06.500 --> 19:08.500]  зависит только от значения ДП
[19:08.500 --> 19:10.500]  вот здесь.
[19:10.500 --> 19:12.500]  Если я окажусь в этой строке,
[19:12.500 --> 19:14.500]  то мне достаточно свернуть только с первой.
[19:14.500 --> 19:16.500]  Мне не нужно там и минус с второй, и с третьей и так далее.
[19:16.500 --> 19:17.960]  Поэтому если я
[19:17.960 --> 19:19.960]  науcially делаю у течки,
[19:19.960 --> 19:21.960]  я могу хранить только две последние строки.
[19:24.500 --> 19:26.500]  Пересчитывать через предпоследнюю,
[19:26.500 --> 19:28.500]  потом предпоследнюю забывать
[19:28.500 --> 19:30.500]  и новую пересчитывать через последнюю, ну и так далее.
[19:30.500 --> 19:32.500]  Поэтому в каждом моменте мне нужно сегодня
[19:32.500 --> 19:34.500]  две строки хранить, поэтому память
[19:34.500 --> 19:36.500]  можно сэкономить до просто ОТ.
[19:38.500 --> 19:58.500]  Если хранить только две последние строки в ДП, то есть текущие и предыдущие, там
[19:58.500 --> 20:09.100]  там вверх, тут хватит. Вот, хорошо.
[20:28.500 --> 20:38.500]  Что здесь можно сделать? Здесь можно реализовать динамику не так, как мы сделали, это я буду
[20:38.500 --> 20:52.500]  называть динамика назад. Можно делать динамику вперед. Вот здесь, смотрите, когда я говорил про этот последний шаг, если я заканчиваю
[20:52.500 --> 20:58.500]  сплетки ежи, то я перебираю, какой был последний шаг. Либо он слева, либо он сверху. То есть мне помогло
[20:58.500 --> 21:04.500]  сфотографировать вот эти вот действия, если они раньше были вниз и вправо, то мне нужно как бы наоборот понять
[21:04.500 --> 21:14.500]  откуда они были сверху или слева. Вот. Я могу делать наоборот. Я могу не разворачивать вот эти мои стрелки и
[21:14.500 --> 21:19.500]  ставить пример на следующий. Каждый раз, когда мне посчиталось ДП вот здесь, я могу через это значение
[21:19.500 --> 21:25.500]  обновить значение ДП вот здесь. Ну и то же самое со стрелками вправо. Если у меня есть значение ДП здесь,
[21:25.500 --> 21:32.500]  давайте я как бы обновлю, попытаюсь обновить значение ДП здесь через эту стрелку. То есть не буду для каждого
[21:32.500 --> 21:40.500]  конкретного ежи в момент прихода к нему его выщепить через предыдущие. А наоборот, если я пошел в ежи, я буду обновлять все
[21:40.500 --> 21:46.500]  следующие. Все, что достижено из него. То есть в случае, если я иду вперед, я наоборот буду делать такой и такой.
[21:46.500 --> 21:50.500]  Вниз и вправо. Ну вот давайте напишу.
[21:50.500 --> 22:09.500]  Опять-таки у меня будет любой вариант. Вариантный такой. После просмотрения вверх и вниз.
[22:20.500 --> 22:28.500]  У меня будут уничтожены все пути предпостыдней интерпретации.
[22:50.500 --> 23:06.500]  То есть давайте специально здесь носить ДП за полмени с конечностью.
[23:06.500 --> 23:16.500]  Я знаю, что это равно А1 и А2.
[23:16.500 --> 23:24.500]  Вот. Опять-таки нашему конкретному элементу я буду делать шаг вправо и вниз.
[23:24.500 --> 23:29.500]  И обновлять соответствующий значение ДП через эти соответствующие стрелки.
[23:29.500 --> 23:35.500]  То есть если я находусь в ленте в ежи, я могу обновить ответ ДП для ленты справа.
[23:35.500 --> 23:41.500]  То есть ежи в высоте. И ленту сниз пусть идут один жир.
[23:41.500 --> 23:45.500]  То есть у меня в цепи будет примерно вот такой.
[23:45.500 --> 23:53.500]  Максим жир. Я делал обновление для ДП.
[24:15.500 --> 24:23.500]  То есть это обновление вправо или вниз, то есть обновление вниз.
[24:45.500 --> 24:53.500]  Вот такой интерпретация.
[24:53.500 --> 25:11.500]  Смотрите, почему я не пишу максимум, то есть я это делал.
[25:11.500 --> 25:17.500]  Я для клетки справа и клетки снизу значение ДП в них обновил через максимум,
[25:17.500 --> 25:21.500]  то есть через нового появившегося пути через клетку ежи.
[25:21.500 --> 25:35.500]  То есть вот здесь я могу теперь попасть вот сюда, в клетку ежи 31.
[25:35.500 --> 25:41.500]  Еще раз. Вот это значение ДП обновил через то, что там уже и так лежало.
[25:41.500 --> 25:45.500]  Так же значение ДП ежи плюс этот мет.
[25:45.500 --> 25:49.500]  По сути, я сохранил то, что там уже и так было, добавил сюда какой-то один новый пути.
[25:49.500 --> 25:53.500]  Потому что как минимально пути вот до сюда?
[25:53.500 --> 25:57.500]  Он проходит либо так, либо так. Возможно, я уже там с вами правильный ответ,
[25:57.500 --> 25:59.500]  потому что вот эта стрелка уже была учтена.
[25:59.500 --> 26:02.500]  Но, возможно, правильный ответ – нешедший пэкс.
[26:02.500 --> 26:05.500]  Поэтому мне нужно обновить это через то, что там уже лежит.
[26:05.500 --> 26:09.500]  И, собственно, то, что я сейчас включу, новый пути через вот эту ребровку.
[26:09.500 --> 26:19.500]  Это что-то удобнее, когда вам не хочется, например, вот такие развороты делать.
[26:19.500 --> 26:23.500]  То есть вы не хотите пытаться понять, как я могу попасть в клетку ежи,
[26:23.500 --> 26:25.500]  соответственно, эти все ребра разворачивают.
[26:25.500 --> 26:29.500]  Когда вы просто в тупую делаете все вот такие вот обновления,
[26:29.500 --> 26:33.500]  если вы знаете ответ здесь, то вы обновляете ответ в конце, соответственно, ребра.
[26:33.500 --> 26:35.500]  Если вы знаете ответ здесь, то вы обновляете ответ здесь.
[26:35.500 --> 26:38.500]  Это может быть очень удобно, если у вас переходов много.
[26:38.500 --> 26:42.500]  Не как у меня сейчас просто их два, а там, не знаю, много.
[26:42.500 --> 26:49.500]  Например, из каждой клетки есть свое множество возможных переходов по каким-то стрелкам.
[26:49.500 --> 26:52.500]  Но тогда вы не хотите их все разворачивать, вы можете просто,
[26:52.500 --> 26:55.500]  зная ответ здесь, обновить ответ через все возможные концы стрелок,
[26:55.500 --> 26:58.500]  которые прикалываются в этой конкретной клетке.
[26:58.500 --> 27:01.500]  Может быть удобнее сделать именно так.
[27:06.500 --> 27:09.500]  Хорошо.
[27:17.500 --> 27:20.500]  Так, перейдем дальше.
[27:25.500 --> 27:28.500]  Следующая задача, кроны и множество подходов.
[27:35.500 --> 27:37.500]  Смотрите볼.
[27:45.500 --> 27:48.500]  Эти две строки или там два мотива.
[27:48.500 --> 27:54.500]  Вы хотите найти их или более общую подпоследующуюся.
[27:54.500 --> 27:56.500]  Подпоследующаяся, понятно. Что такое?
[27:56.500 --> 28:00.500]  Например, кто-нибудь какая-то последующаяся,
[28:00.500 --> 28:02.500]  которая получается вычеркн GetData.
[28:02.500 --> 28:08.160]  Например, можете какие-то элементы вычеркнуть, получит подпоследствия, и всё, всё осталось склеить, это будет подпоследствия.
[28:08.160 --> 28:16.160]  Ну, наибольшая общая, значит, вам нужно рассмотреть, каковы подпоследствия, которые общие в обеих строчках, есть и здесь, есть и здесь, и из таких наибольших подленивых.
[28:21.160 --> 28:28.160]  Давайте вот здесь за номерок как-нибудь уже садимся в зале tn, а здесь в зале tn.
[28:38.160 --> 28:58.160]  Вот, значит, можно не нужно всё вот такое, значит, смотрите, мы можем обрубить насквозь обе строчки на них первоначальных отрезков, вот здесь, вот здесь, вот здесь.
[28:58.160 --> 29:03.160]  То есть рассмотреть элементы с первого кубитого в первой строке и с первого кубитого в второй строке.
[29:04.160 --> 29:23.160]  И для конкретной пары единиц навести значение динамика для поезжей, это будет, собственно, длина ног, длина наибольшей общей подпоследствия, для того, чтобы, ну, соответственно, t с первого кубитого и t с первого элемента кубитого.
[29:28.160 --> 29:33.160]  Если мы такой динаметр не считаем, то понятное дело, что это просто dpnm.
[29:40.160 --> 29:52.160]  А это dpnm, потому что, когда я рассматриваю всю строку с целиком, от начала до конца, всю строку с целиком, рассматриваю длину и сно, то ровно то, что мне нужно есть.
[29:58.160 --> 30:13.160]  Значит, база нашей динамики. Давайте я эту строку вывезу.
[30:13.160 --> 30:28.160]  Для удобства я стараюсь, чтобы dp ноль жил. Ну, для любого жил. И, наоборот, dp и ноль это тоже ноль для любого жил.
[30:28.160 --> 30:45.160]  Потому что, когда я рассматриваю, бустую одну из строчек, то есть это в случае с соответствием того, что у меня строка s пустая, я ее врубил даже в первые секунды.
[30:45.160 --> 30:57.160]  Когда понятно, что ноль пустой строки и чего угодно, это ноль. И то же самое здесь у меня вторая строка пустая, первая кота, это, конечно же, длина наибольшего в процессе.
[30:57.160 --> 31:16.160]  Вот, теперь переход. Как выглядит dp и ноль жил? Как можно получить dp и ноль жил? Есть у меня префикс длины i в строке s, префикс длины j в строке f.
[31:16.160 --> 31:28.160]  Как выглядит длина наибольшего процесса в данный момент? Ну, можно стоять, например, так. Давайте посмотрим на эти последние элементы.
[31:28.160 --> 31:38.160]  Давайте спросим себя, а включены ли они в ноль? Включены ли они в ту самую наибольшую общую процессу, которую мы ищем?
[31:38.160 --> 31:48.160]  Ну, соответственно, есть там несколько вариантов. Этот включен, этот не включен. И, наоборот, и с этим тоже самое, включен или не включен.
[31:48.160 --> 31:57.160]  Смотрите, значит, в случае, когда я открыто знаю, что с it не участвует кнопка, я точно могу сказать, что dp равно dp и минус 1 j.
[31:57.160 --> 32:04.160]  То есть, если этот элемент точно не участвует, то я могу его откусить, забыть про него и написать dp и минус 1 j.
[32:04.160 --> 32:09.160]  Потому что этот элемент не важен, а для двух поставшихся строк мне нужна кнопка.
[32:09.160 --> 32:18.160]  Поэтому один из способов получить dp и d it – это найти dp и минус 1 j. Это в случае, если s it не участвует.
[32:18.160 --> 32:22.160]  А если? s it не участвует.
[32:26.160 --> 32:29.160]  Второй случай симметричный, когда d j не участвует.
[32:29.160 --> 32:36.160]  Если мне откуда-то известно, что этот элемент вновь не участвует, я могу отрезать его из второй строки, уменьшить нашу задачу.
[32:36.160 --> 32:42.160]  И соответственно сказать, что dp в точности вот этого dp равно в точности d it и минус 1 j.
[32:42.160 --> 32:49.160]  А потому что его можно откусить. И если это в значении dp уже известно, то нужно просто его скопировать.
[32:49.160 --> 32:52.160]  Если даже это важно.
[32:52.160 --> 32:57.160]  Значит, что не разводится?
[32:57.160 --> 33:01.160]  Какой случай не разводится?
[33:01.160 --> 33:04.160]  Когда оба участвуют.
[33:04.160 --> 33:11.160]  Мне осталось понять в чём будет равна длина ног, если неизвестно, что они оба участвуют.
[33:11.160 --> 33:18.160]  Но если они оба участвуют, то они друг другу должны соответствовать, потому что это самый правый элемент обеих строк.
[33:19.160 --> 33:26.160]  Если мы рассматриваем подпосредственность и эти два элемента участвуют, то они обязательно последние в обеих предпосредственностях.
[33:26.160 --> 33:28.160]  Значит, они обязательно должны совпадать.
[33:28.160 --> 33:32.160]  И в этом случае, если они совпадают, я могу сказать, что они друг другу соответствуют.
[33:32.160 --> 33:34.160]  Добавить в это ничку.
[33:34.160 --> 33:38.160]  И потом одновременно откусить и взять dp и минус 1 j и минус 1.
[33:38.160 --> 33:40.160]  То есть я их друг другу сопоставляю.
[33:40.160 --> 33:43.160]  Говорю, что это последний элемент обеих подпосредственностях.
[33:43.160 --> 33:51.160]  Да, и дальше нужно, забыв про них, найти длину ног, уже типа трексов с длиной 1 по меньшему в обеих строках.
[33:52.160 --> 33:54.160]  Так, ну давайте об этом в следующем образов.
[33:59.160 --> 34:03.160]  Как такой программист, лучше вот так.
[34:03.160 --> 34:22.160]  То есть в случае, если подпрытия не два отнима совпали, я могу обновить значение dp через на 1 плюс dp и минус 1 j и минус 1.
[34:22.160 --> 34:28.160]  Потому что я уже объяснил, да, эти два последних элемента откусились, они друг другу соответствуют, я их уже взял подпосредственность.
[34:28.160 --> 34:33.160]  Поэтому все остальное, все что остается, это взять подпосредственность еще вот этих строк.
[34:33.160 --> 34:37.160]  s с первым элементом до минус 1, вот t с первым элементом до минус 1.
[34:37.160 --> 34:42.160]  Вот аноды b и плюс ничка за счет того, что я вот эти два символа друг друга сопоставил.
[34:42.160 --> 34:46.160]  И это работает только если выполняется вот эта проверка.
[34:46.160 --> 34:49.160]  А если два символа равны, тогда их можно друг другу сопоставить, иначе нельзя.
[34:49.160 --> 34:54.160]  Ну и соответственно, если это не работает, то это разрешает false, false на что угодно.
[34:55.160 --> 34:57.160]  То есть оно оказывается конту здесь.
[34:57.160 --> 35:02.160]  Конечно так нельзя писать, да, нельзя его умножать более на интеджер, но он не может.
[35:05.160 --> 35:10.160]  А если здесь это верно, здесь 1 умножается на значение 6, получается просто это значение.
[35:11.160 --> 35:14.160]  Вот, собственно и все получается тогда вот такой.
[35:14.160 --> 35:26.160]  Так, ну да, значение, когда у меня один из элементов пары, один из аргументов стоков нулевой, мы уже все разобрали,
[35:26.160 --> 35:29.160]  поэтому мне можно какую-нибудь любую рассматривать.
[35:31.160 --> 35:34.160]  Ну и дальше, я думаю, что добытая жизнь – это максимум из генера всего.
[35:38.160 --> 35:42.160]  Это максимум, если я куда-то подрегу еще.
[35:42.160 --> 35:48.160]  А поскольку я не знаю, какой именно из трех достигается, я думаю, что это верно, если там есть какое-то условие.
[35:48.160 --> 35:52.160]  Например, если это сыты не участвуют, если это жито, это все оба участвуют.
[35:53.160 --> 35:59.160]  Но я не знаю, какой из них, но какой-то из них точно достигается, потому что это как бы все возможности, если здесь я разобрал.
[35:59.160 --> 36:05.160]  Раз меня интересует длинная мощь, то мне нужно выбрать из них максимально затягчить сил, чтобы заположить воду в какой-то же.
[36:06.160 --> 36:09.160]  Еще раз, последние силы выпадают, но...
[36:14.160 --> 36:17.160]  Тогда вот один из этих сыграет.
[36:17.160 --> 36:19.160]  Еще раз, последние темы впадают, но...
[36:26.160 --> 36:28.160]  Когда вот один из этих сыграет?
[36:34.160 --> 36:36.160]  Не, мы явным образом никакие проверки не делаем.
[36:36.160 --> 36:38.160]  То есть, смотри, еще раз.
[36:38.160 --> 36:41.160]  Собственно, так же, как и будут задачи про табличку, предыдущие задачи.
[36:41.160 --> 36:44.160]  Мы же не знаем, какой именно переход правиль сверху или слева.
[36:44.160 --> 36:47.160]  Мы точно знаем, что один из них правильный.
[36:47.160 --> 36:50.160]  Поэтому мы с ним выбираем как бы оптимально, тот, который дает мне большую сумму.
[36:50.160 --> 36:51.160]  Нам в ответ.
[36:51.160 --> 36:52.160]  То же самое и здесь.
[36:52.160 --> 36:54.160]  Мы не знаем, какой именно за этот второй случай достигается.
[36:54.160 --> 36:56.160]  Но один из них точно достигается.
[36:56.160 --> 37:01.160]  То есть, либо не участвует последний в нашей ноге, в строке S.
[37:01.160 --> 37:03.160]  Либо в строке T последний не участвует.
[37:03.160 --> 37:05.160]  Либо они оба участвуют.
[37:05.160 --> 37:07.160]  То есть, они оба участвуют и друг другу соответствуют.
[37:07.160 --> 37:09.160]  Значит, вот в этом случае достигается.
[37:09.160 --> 37:12.160]  А то, что вы говорите, когда последние символы равны,
[37:12.160 --> 37:14.160]  но один из них не участвует в ноге,
[37:17.160 --> 37:20.160]  когда, например, в ноге у меня будет вот такая.
[37:20.160 --> 37:22.160]  И вот этот последний не участвует.
[37:22.160 --> 37:25.160]  Тогда это то же самое, что последний символ здесь просто откусить.
[37:25.160 --> 37:27.160]  А это у меня разобрано как раз.
[37:29.160 --> 37:31.160]  То есть, независимо от того, равны последние символы или нет,
[37:31.160 --> 37:35.160]  я точно могу любой из них отбросить за бесплатно.
[37:35.160 --> 37:38.160]  Соответственно, вот это и вот это у меня в ответе в члёте.
[37:39.160 --> 37:41.160]  Ну как?
[37:43.160 --> 37:45.160]  Окей.
[37:51.160 --> 37:53.160]  Ну длины, длины.
[38:13.160 --> 38:16.160]  Ну я же здесь пятраскопаю элементы спокойно.
[38:21.160 --> 38:23.160]  Да, конечно.
[38:23.160 --> 38:25.160]  Да, но я здесь протрудил.
[38:25.160 --> 38:27.160]  Что такое подпасы?
[38:27.160 --> 38:29.160]  Я говорю, можно вычислить любой набор элементов.
[38:29.160 --> 38:31.160]  Остальные склеить или будут подпасы.
[38:31.160 --> 38:33.160]  Не подотрез, а как бы в подможество скорее.
[38:33.160 --> 38:35.160]  Окей?
[38:35.160 --> 38:37.160]  Если задача про подсловы,
[38:37.160 --> 38:39.160]  это мы в следующем смеси не будем про строку говорить,
[38:39.160 --> 38:41.160]  мы задачу про подсловы решим.
[38:41.160 --> 38:43.160]  Там надо что-то типа субмасса построить,
[38:43.160 --> 38:45.160]  или что-то такое.
[38:45.160 --> 38:47.160]  Здесь просто...
[38:47.160 --> 38:49.160]  Так, значит, смотрите.
[38:49.160 --> 38:51.160]  В этот момент мы с вами найдём длину.
[38:51.160 --> 38:53.160]  Наибольшую длину.
[38:53.160 --> 38:55.160]  А теперь вдруг нам нужно найти длину
[38:55.160 --> 38:57.160]  а, собственно, саму наибольшую длину.
[38:57.160 --> 38:59.160]  Или предыдущих задачах.
[38:59.160 --> 39:01.160]  И просто сумму там снимаем.
[39:01.160 --> 39:03.160]  А саму.
[39:03.160 --> 39:06.160]  Так, как именно здесь нужно брать символы,
[39:06.160 --> 39:09.160]  чтобы получить самую наибольшую длину.
[39:09.160 --> 39:11.160]  Вот.
[39:11.160 --> 39:13.160]  Ну, давайте сделаем
[39:13.160 --> 39:15.160]  очень простую вещь.
[39:15.160 --> 39:17.160]  Давайте вот здесь всегда,
[39:17.160 --> 39:19.160]  когда мы находимся в значении dp,
[39:19.160 --> 39:21.160]  будем запоминать, откуда нам получше.
[39:21.160 --> 39:23.160]  То есть вот здесь я беру максимум из трёх величин.
[39:23.160 --> 39:25.160]  На максимум из вот этого и вот этого.
[39:27.160 --> 39:29.160]  А давайте так бы я заведу второй массив,
[39:29.160 --> 39:31.160]  который я назову par.
[39:33.160 --> 39:35.160]  Ну, типа привес или какой-нибудь.
[39:35.160 --> 39:37.160]  Par.
[39:37.160 --> 39:39.160]  Это каким из трёх способов
[39:39.160 --> 39:41.160]  мы получили максимальный значение dp.
[39:43.160 --> 39:45.160]  Ну или...
[39:45.160 --> 39:47.160]  Ну да, короче, это ноль,
[39:47.160 --> 39:49.160]  если вот этот максимум равен вот этому,
[39:49.160 --> 39:51.160]  единица если вот этому,
[39:51.160 --> 39:53.160]  двойка если вот этому.
[39:53.160 --> 39:55.160]  Давайте я не буду конкретно писать,
[39:55.160 --> 39:57.160]  то есть как именно это реализовательный вопрос
[39:57.160 --> 39:59.160]  именно к воду.
[39:59.160 --> 40:01.160]  Давайте я напишу просто,
[40:01.160 --> 40:03.160]  как именно
[40:03.160 --> 40:05.160]  получен
[40:05.160 --> 40:07.160]  максимум
[40:07.160 --> 40:09.160]  dp.
[40:09.160 --> 40:11.160]  То есть и внутри трёх величин,
[40:11.160 --> 40:13.160]  какая именно из этих трёх величин
[40:13.160 --> 40:15.160]  даёт максимальный значение.
[40:15.160 --> 40:17.160]  Пусть вот p и j указывают на
[40:17.160 --> 40:19.160]  этот значение.
[40:19.160 --> 40:21.160]  Вот. Тогда как нам
[40:21.160 --> 40:23.160]  найти ноль
[40:23.160 --> 40:25.160]  саму подпасственности для строчек s и t?
[40:25.160 --> 40:27.160]  Чуть ноль p и s.
[40:27.160 --> 40:29.160]  Ну вот, мы знаем её длину,
[40:29.160 --> 40:31.160]  она имеют в dp и nm.
[40:31.160 --> 40:33.160]  dp и nm это её длина.
[40:35.160 --> 40:37.160]  Значит, да, мы знаем,
[40:37.160 --> 40:39.160]  как ему произведена длина была получена.
[40:39.160 --> 40:41.160]  Мы можем посмотреть на
[40:41.160 --> 40:43.160]  p и nm.
[40:43.160 --> 40:45.160]  Собственно,
[40:45.160 --> 40:47.160]  в этом массиве будет храниться,
[40:47.160 --> 40:49.160]  как именно она была получена.
[40:49.160 --> 40:51.160]  Если там указать, что вот так она была получена,
[40:51.160 --> 40:53.160]  значит я могу смело откусить
[40:53.160 --> 40:55.160]  последний элемент в строке s
[40:55.160 --> 40:57.160]  и от этого у меня ног не изменится.
[40:57.160 --> 40:59.160]  Если p говорит, что вот так оно было получено,
[40:59.160 --> 41:01.160]  то я могу напротив откусить
[41:01.160 --> 41:03.160]  последний символ в строке t
[41:03.160 --> 41:05.160]  и ног не изменится.
[41:05.160 --> 41:07.160]  И, наконец, если вот эта штука указывает,
[41:07.160 --> 41:09.160]  что вот это вот, это был максимум
[41:09.160 --> 41:11.160]  при содержании j,
[41:11.160 --> 41:13.160]  то оптимальный способ это вот эти два
[41:13.160 --> 41:15.160]  последних символа заматчивать,
[41:15.160 --> 41:17.160]  сказать, что это последний символ в ноб
[41:17.160 --> 41:19.160]  и построить ноб для вот этого концепции.
[41:19.160 --> 41:21.160]  Ну, поэтому я могу написать
[41:21.160 --> 41:23.160]  какую-то следующую.
[41:23.160 --> 41:25.160]  Давайте я приду две переменные j,
[41:25.160 --> 41:27.160]  это текущие координаты.
[41:27.160 --> 41:29.160]  Два указательных координат?
[41:29.160 --> 41:31.160]  Ну, это громкое слово,
[41:31.160 --> 41:33.160]  громкое слово два указателя,
[41:33.160 --> 41:35.160]  ну, типа того, совсем типа.
[41:35.160 --> 41:37.160]  Дальше, пока
[41:37.160 --> 41:39.160]  dp и drg
[41:39.160 --> 41:41.160]  положительно
[41:41.160 --> 41:43.160]  я смотрю
[41:43.160 --> 41:45.160]  на p и j.
[41:45.160 --> 41:47.160]  Ой.
[41:47.160 --> 41:49.160]  Ну, давайте я
[41:49.160 --> 41:51.160]  немножко напишу, да?
[41:51.160 --> 41:53.160]  Если p и drg
[41:53.160 --> 41:55.160]  говорит,
[41:57.160 --> 41:59.160]  что
[41:59.160 --> 42:01.160]  dp и drg
[42:01.160 --> 42:03.160]  получено
[42:05.160 --> 42:07.160]  давайте вот так, по первому правилу,
[42:07.160 --> 42:09.160]  вот ему первое правило,
[42:11.160 --> 42:13.160]  по первому правилу,
[42:15.160 --> 42:17.160]  то это означает,
[42:17.160 --> 42:19.160]  что оптимальный ноб
[42:19.160 --> 42:21.160]  для p и j
[42:21.160 --> 42:23.160]  вместо первого s и j.
[42:23.160 --> 42:25.160]  Значит, я могу последний символ c и s откусить
[42:25.160 --> 42:27.160]  и перейти дальше к цепи.
[42:27.160 --> 42:29.160]  То есть, я понимаю,
[42:29.160 --> 42:31.160]  что если это
[42:31.160 --> 42:33.160]  бесполезный символ,
[42:33.160 --> 42:35.160]  я его убираю
[42:35.160 --> 42:37.160]  из рассмотрения, перейду к dp и j,
[42:37.160 --> 42:39.160]  наносим, соответственно, дальше к трупсу.
[42:39.160 --> 42:41.160]  Вот это был беглый случай.
[42:41.160 --> 42:43.160]  Второй случай.
[42:43.160 --> 42:45.160]  Если что-то самое,
[42:45.160 --> 42:47.160]  нужно по второму правилу,
[42:51.160 --> 42:53.160]  то есть, вот это вот.
[42:53.160 --> 42:55.160]  Да, так наступит, наоборот,
[42:55.160 --> 42:57.160]  текучая dp получена
[42:57.160 --> 42:59.160]  над браком int.
[42:59.160 --> 43:01.160]  Значит, мне нужно уменьшить длину и
[43:01.160 --> 43:03.160]  выставить континент.
[43:05.160 --> 43:07.160]  Если оптимально всего не рассматривать
[43:07.160 --> 43:09.160]  int в ответе, то я просто обновил
[43:09.160 --> 43:11.160]  dp и j.
[43:11.160 --> 43:13.160]  Ну, и наконец, в последний случай,
[43:13.160 --> 43:15.160]  если по третьему правилу.
[43:15.160 --> 43:17.160]  По третьему правилу.
[43:21.160 --> 43:23.160]  То есть, собственно, означает,
[43:23.160 --> 43:25.160]  что если dp не ноль,
[43:25.160 --> 43:27.160]  потому что здесь был не ноль,
[43:27.160 --> 43:29.160]  значит, символы равны.
[43:29.160 --> 43:31.160]  И они как раз являются последними,
[43:31.160 --> 43:33.160]  совпадают с символами к нашему.
[43:33.160 --> 43:35.160]  Поэтому можно сделать что-то типа такого.
[43:35.160 --> 43:37.160]  Напечатать в конце тск.
[43:37.160 --> 43:39.160]  Напечатать в конец.
[43:39.160 --> 43:41.160]  Напечатать.
[43:45.160 --> 43:47.160]  В конец тск.
[43:47.160 --> 43:49.160]  Ну, потом сделать
[43:49.160 --> 43:51.160]  минус-минус-ки, минус-минус-ы,
[43:51.160 --> 43:53.160]  а то есть, если
[43:53.160 --> 43:55.160]  dp-шка текущая получена
[43:55.160 --> 43:57.160]  по третьему правилу, значит,
[43:57.160 --> 43:59.160]  у меня последние два символа
[43:59.160 --> 44:01.160]  состыковались. Они являются
[44:01.160 --> 44:03.160]  последним символом нашей небольшой
[44:03.160 --> 44:05.160]  последней части. Я не могу уже как бы
[44:05.160 --> 44:07.160]  учесть, а так напечатать туда.
[44:07.160 --> 44:09.160]  И, соответственно, уменьшить обе координаты
[44:09.160 --> 44:11.160]  и перенесу.
[44:11.160 --> 44:13.160]  Потому что я отпустил два символа,
[44:13.160 --> 44:15.160]  если перенесу.
[44:15.160 --> 44:17.160]  И дальше dp-шка инвестируется в конце.
[44:17.160 --> 44:19.160]  Да, единственное, что
[44:19.160 --> 44:21.160]  вот тут в конце я не очень
[44:21.160 --> 44:23.160]  нормально писал. Написать в конец, это значит,
[44:23.160 --> 44:25.160]  что я не отвечаю в таком порядке, чтобы они
[44:25.160 --> 44:27.160]  образовались красно. Я не буду просто
[44:27.160 --> 44:29.160]  в строках сохранять. В конце нужно будет
[44:29.160 --> 44:31.160]  развернуть, потому что, как бы, с конца
[44:31.160 --> 44:33.160]  это все равно.
[44:33.160 --> 44:35.160]  Я не буду без конца строки. И первый символ,
[44:35.160 --> 44:37.160]  который я найду, это последний лучший
[44:37.160 --> 44:39.160]  символ в нуб.
[44:39.160 --> 44:41.160]  То есть, если я добавлю пер,
[44:41.160 --> 44:43.160]  это, в самом деле, последний символ ответа.
[44:43.160 --> 44:45.160]  Потом найду предпоследний презент и следи, и так далее.
[44:45.160 --> 44:47.160]  То есть, либо вы в строках с конца
[44:47.160 --> 44:49.160]  куда-то записываете ее справа-наделом,
[44:49.160 --> 44:51.160]  либо просто добавляете слева-направо,
[44:51.160 --> 44:53.160]  и потом любишь в конце. Это уже
[44:53.160 --> 44:55.160]  детальная инвестиция.
[44:59.160 --> 45:01.160]  Собственно, универсальный
[45:01.160 --> 45:03.160]  способ, как можно обсудить ответ.
[45:03.160 --> 45:05.160]  То есть, если вас интересует не только
[45:05.160 --> 45:07.160]  длина, а не только сумма,
[45:07.160 --> 45:09.160]  но и способ, каким образом
[45:09.160 --> 45:11.160]  получена длина или сумма,
[45:11.160 --> 45:13.160]  универсальный рецепт такой,
[45:13.160 --> 45:15.160]  запоминаете, как именно было
[45:15.160 --> 45:17.160]  получено каждое значение dp в отдельном массивчике,
[45:17.160 --> 45:19.160]  как именно было получено
[45:19.160 --> 45:21.160]  каждое конкретное значение.
[45:21.160 --> 45:23.160]  И с его помощью, начиная
[45:23.160 --> 45:25.160]  от конца и как бы разворачиваясь
[45:25.160 --> 45:27.160]  к началу, то есть,
[45:27.160 --> 45:29.160]  от последнего элемента я крышал,
[45:29.160 --> 45:31.160]  восстанавливаете как именно вашу дп-паспорт.
[45:31.160 --> 45:33.160]  Там же вы поймете,
[45:33.160 --> 45:35.160]  ну, то есть, вы в этом
[45:35.160 --> 45:37.160]  раздомеете все, кем нужно построить,
[45:37.160 --> 45:39.160]  и таким образом можно посчитать ноб,
[45:39.160 --> 45:41.160]  конкретный ноб, пульсус,
[45:41.160 --> 45:43.160]  что надо, то всегда сможете найти.
[45:45.160 --> 45:47.160]  Окей?
[45:51.160 --> 45:53.160]  Так, хорошо.
[45:53.160 --> 45:55.160]  Хорошо.
[45:59.160 --> 46:01.160]  Следующая задача.
[46:03.160 --> 46:05.160]  Пусть нигде больше возрастает
[46:05.160 --> 46:07.160]  в последующем.
[46:07.160 --> 46:09.160]  Нигде больше возрастает
[46:09.160 --> 46:11.160]  в последующем.
[46:15.160 --> 46:17.160]  Задача.
[46:17.160 --> 46:19.160]  Есть массив.
[46:21.160 --> 46:23.160]  Нужно в нем выбрать
[46:23.160 --> 46:25.160]  подпоследовательность.
[46:25.160 --> 46:27.160]  Опять подпоследовательность.
[46:27.160 --> 46:29.160]  Когда надо, мы какие-то элементы вычеркиваем,
[46:29.160 --> 46:31.160]  остальные склеиваемся в нишки подряд.
[46:31.160 --> 46:33.160]  То есть, мне не обязательно
[46:33.160 --> 46:35.160]  подотвердить именно подпоследовательность.
[46:35.160 --> 46:37.160]  Надо выбрать подпоследовательность,
[46:37.160 --> 46:39.160]  которая возрастала, то есть,
[46:39.160 --> 46:41.160]  все элементы в ней идут слева-направо
[46:41.160 --> 46:43.160]  про это увеличение, и при этом
[46:43.160 --> 46:45.160]  формально нужны институты.
[46:45.160 --> 46:47.160]  Так, подпоследовательность
[46:49.160 --> 46:51.160]  с ней может указать.
[46:51.160 --> 46:53.160]  Двигаем, чтобы все было в порядке системы.
[46:55.160 --> 46:57.160]  Это не так.
[46:59.160 --> 47:01.160]  Подпоследовательность, чтобы все элементы
[47:01.160 --> 47:03.160]  темнота уничтожили.
[47:03.160 --> 47:05.160]  Так.
[47:09.160 --> 47:11.160]  Ну, давайте начнем с
[47:13.160 --> 47:15.160]  какого решения?
[47:33.160 --> 47:35.160]  Давайте веду следующее.
[47:35.160 --> 47:37.160]  Любой любительный академик
[47:39.160 --> 47:41.160]  это минимальная возможность
[47:41.160 --> 47:43.160]  решения последних элементов
[47:43.160 --> 47:45.160]  в возрастающих подпоследовательствах
[47:45.160 --> 47:47.160]  длины ровно как,
[47:47.160 --> 47:49.160]  которые используют только
[47:49.160 --> 47:51.160]  первый элемент.
[47:51.160 --> 47:53.160]  То есть, минимальное значение
[47:55.160 --> 47:57.160]  последнего элемента
[48:01.160 --> 48:03.160]  в возрастающих подпоследовательствах
[48:03.160 --> 48:05.160]  длины как,
[48:07.160 --> 48:09.160]  если можно использовать только элементы
[48:09.160 --> 48:11.160]  в возрастающих подпоследовательствах
[48:11.160 --> 48:13.160]  длины ровно как,
[48:13.160 --> 48:15.160]  которые используют только элементы
[48:15.160 --> 48:17.160]  в возрастающих подпоследовательствах
[48:17.160 --> 48:19.160]  длины ровно как,
[48:19.160 --> 48:21.160]  если можно использовать только
[48:21.160 --> 48:23.160]  один экзолеакадемик.
[48:33.160 --> 48:35.160]  То есть, смотрите,
[48:35.160 --> 48:37.160]  если я сначала хочу начать
[48:37.160 --> 48:39.160]  расследовать моего массива,
[48:39.160 --> 48:41.160]  там бывают разные
[48:41.160 --> 48:43.160]  возрастающие подпоследовательства.
[48:43.160 --> 48:45.160]  Они бывают разной длины.
[48:45.160 --> 48:47.160]  И мы не знаем, какая именность
[48:47.160 --> 48:49.160]  них сам нападет.
[48:49.160 --> 48:51.160]  Например, здесь может быть что-нибудь,
[48:51.160 --> 48:53.160]  мы возрастающие подпоследовательства
[48:53.160 --> 48:55.160]  длины, например, 3, вот такая,
[48:55.160 --> 48:57.160]  1,5, но тогда понятно,
[48:57.160 --> 48:59.160]  что это, наверное, не очень оптимально,
[48:59.160 --> 49:01.160]  потому что это в соне нам очень сильно
[49:01.160 --> 49:03.160]  мешает на 20%
[49:03.160 --> 49:05.160]  А, например, если мы хотели бы
[49:05.160 --> 49:07.160]  изменить длину шва,
[49:09.160 --> 49:11.160]  так, давайте вот так сделаем,
[49:11.160 --> 49:13.160]  если мы хотели бы делать длину 2,
[49:13.160 --> 49:15.160]  например, у нас есть вот такая, пассис 1,3,
[49:15.160 --> 49:17.160]  может быть, такое,
[49:17.160 --> 49:19.160]  есть, в которой-то сложной праве этой сонни,
[49:19.160 --> 49:21.160]  то, возможно, 3 это минимальное
[49:21.160 --> 49:23.160]  подследнее значение, да,
[49:23.160 --> 49:25.160]  в этом случае пассис длины 2.
[49:25.160 --> 49:27.160]  В общем, как-то здесь четко понятно.
[49:27.160 --> 49:29.160]  Мы не знаем, какую кокаиную систему
[49:29.160 --> 49:31.160]  нужна длина, чтобы оптимально
[49:31.160 --> 49:33.160]  попросту продавать,
[49:33.160 --> 49:35.160]  но понятно, что если длина 2 сделана,
[49:35.160 --> 49:37.160]  то нам выгодно как можно
[49:37.160 --> 49:39.160]  изменить этот последний элемент,
[49:39.160 --> 49:41.160]  чтобы дальше было жить как можно проще.
[49:41.160 --> 49:43.160]  То есть, если я знаю, что длина ровно так,
[49:43.160 --> 49:45.160]  и я могу закончить
[49:45.160 --> 49:47.160]  в нескольких элементах
[49:47.160 --> 49:49.160]  вот этот пассис длины, да,
[49:49.160 --> 49:51.160]  но что если я кончу в нескольких элементах,
[49:51.160 --> 49:53.160]  то понятно, что из них нужно выбрать ту,
[49:53.160 --> 49:55.160]  которая самая маленькая,
[49:55.160 --> 49:57.160]  потому что дальше я могу наиболее
[49:57.160 --> 49:59.160]  свободно считать.
[49:59.160 --> 50:01.160]  Если здесь можно только строить 3,5,
[50:01.160 --> 50:03.160]  потому что это значит, что вот здесь
[50:03.160 --> 50:05.160]  я могу только добавить немножко пассис.
[50:05.160 --> 50:07.160]  А в этом случае длина.
[50:07.160 --> 50:09.160]  Вот, ну, давайте
[50:09.160 --> 50:11.160]  идем попромосить.
[50:11.160 --> 50:13.160]  Так, да.
[50:13.160 --> 50:15.160]  Ну, во-первых,
[50:15.160 --> 50:17.160]  я не говорю, конечно,
[50:17.160 --> 50:19.160]  что ровно.
[50:19.160 --> 50:21.160]  Если такой пассис не существует,
[50:21.160 --> 50:23.160]  то там, в принципе, плюс бесконечности.
[50:23.160 --> 50:25.160]  Так, и здесь.
[50:25.160 --> 50:27.160]  Ну, вот,
[50:27.160 --> 50:29.160]  и здесь.
[50:29.160 --> 50:31.160]  Ну, вот,
[50:31.160 --> 50:33.160]  и здесь.
[50:33.160 --> 50:35.160]  Ну, вот,
[50:35.160 --> 50:37.160]  и здесь.
[50:37.160 --> 50:39.160]  Ну, вот, и здесь.
[50:39.160 --> 50:41.160]  И плюс бесконечности.
[50:41.160 --> 50:43.160]  Это стандартное положение,
[50:43.160 --> 50:45.160]  что если я пытаюсь
[50:45.160 --> 50:47.160]  хранить там минимальное значение чего-то,
[50:47.160 --> 50:49.160]  а этого чего-то вообще не существует,
[50:49.160 --> 50:51.160]  то я буду хранить там промоложение плюс бесконечности
[50:51.160 --> 50:53.160]  как знак того, что оно, в принципе,
[50:53.160 --> 50:55.160]  не достижено.
[50:55.160 --> 50:57.160]  Так вот, я вот считаю,
[50:57.160 --> 50:59.160]  что в любом времени, в любом одни,
[50:59.160 --> 51:01.160]  вот этот массивчик,
[51:01.160 --> 51:03.160]  деперитая первая, вторая, третья и так далее,
[51:03.160 --> 51:05.160]  это строго возрастающий массив,
[51:05.160 --> 51:07.160]  если я буду генерировать плюс бесконечности.
[51:09.160 --> 51:11.160]  Так, деперитая точка
[51:11.160 --> 51:13.160]  это возрастающий массив.
[51:19.160 --> 51:21.160]  Ну, то есть, он имеет какой-то
[51:21.160 --> 51:23.160]  такой, давайте
[51:23.160 --> 51:25.160]  с ней будем кушать.
[51:27.160 --> 51:29.160]  А с какого-то момента
[51:29.160 --> 51:31.160]  парк симптует бесконечности.
[51:33.160 --> 51:35.160]  То есть, это деперитая первая,
[51:35.160 --> 51:37.160]  это деперитая вторая, это деперитая третья, четвертая, пятая
[51:37.160 --> 51:39.160]  и так далее.
[51:39.160 --> 51:41.160]  Значит, ну почему?
[51:41.160 --> 51:43.160]  Это вроде бы трибиально.
[51:43.160 --> 51:45.160]  Понятно, что если у меня есть массовый дымный кар,
[51:45.160 --> 51:47.160]  который заканчивается где-то,
[51:47.160 --> 51:49.160]  есть массовый дымный кар плюс один, который где-то еще заканчивается,
[51:49.160 --> 51:51.160]  то, конечно, это число может быть
[51:51.160 --> 51:53.160]  только больше, чем это.
[51:53.160 --> 51:55.160]  Потому что, иначе, если вот это
[51:55.160 --> 51:57.160]  вот, например, да, то есть, как можно противнное,
[51:57.160 --> 51:59.160]  пусть Db и Dk
[51:59.160 --> 52:01.160]  больше равно Db и Dk
[52:01.160 --> 52:03.160]  плюс D.
[52:03.160 --> 52:05.160]  Давайте рассмотрим
[52:05.160 --> 52:07.160]  Db и Dk плюс D. Что это такое?
[52:07.160 --> 52:09.160]  Это какая-то посетка
[52:09.160 --> 52:11.160]  с длины k плюс один,
[52:11.160 --> 52:13.160]  которая заканчивается вот на таком элементе.
[52:13.160 --> 52:15.160]  То есть там что-то что-то с длиной k плюс один,
[52:15.160 --> 52:17.160]  которая заканчивается на Db и Dk плюс D.
[52:19.160 --> 52:21.160]  Но тогда вот это последний элемент.
[52:23.160 --> 52:25.160]  Это последний элемент
[52:25.160 --> 52:27.160]  возрастающего с длины k.
[52:27.160 --> 52:29.160]  Потому что если это была
[52:29.160 --> 52:31.160]  посетка с длины k плюс один,
[52:31.160 --> 52:33.160]  то это будет уже с длины k.
[52:33.160 --> 52:35.160]  Поэтому вот этот элемент
[52:35.160 --> 52:37.160]  это, в частности, одну из
[52:37.160 --> 52:39.160]  возможностей совершения
[52:39.160 --> 52:41.160]  под последней с длины k.
[52:41.160 --> 52:43.160]  Поэтому эта штука должна быть точно меньше
[52:43.160 --> 52:45.160]  набравной, чем вот эта.
[52:45.160 --> 52:47.160]  Но за счет того, что здесь значок будет
[52:47.160 --> 52:49.160]  такой строго меньше, потому что это строго
[52:49.160 --> 52:51.160]  возрастает с посеткой, а это еще меньше
[52:51.160 --> 52:53.160]  набравной, чем вот эта,
[52:53.160 --> 52:55.160]  ну, то мы получим противоречие.
[52:55.160 --> 52:57.160]  То есть, получается, что минимальная
[52:57.160 --> 52:59.160]  возможность совершения под след с длины k
[52:59.160 --> 53:03.160]  собственно, возможно совершать. Там противоречие.
[53:03.160 --> 53:06.160]  Давайте еще раз чуть подробнее.
[53:06.160 --> 53:13.160]  Вот если это x, то x меньше, чем dp, если я каплюсь первым.
[53:13.160 --> 53:17.160]  Потому что они были в одной возрастающей процедуре, длиной ка плюс один.
[53:17.160 --> 53:24.160]  Ну и потом, по предположению, это меньше вравно, чем dp или diakata.
[53:24.160 --> 53:27.160]  В итоге x строго меньше, чем dp или diakata,
[53:27.160 --> 53:30.160]  но x это одно из возможных завершений процентов длины ка,
[53:30.160 --> 53:33.160]  а это минимально возможный х-слок, в котором заканчивается процент длины ка.
[53:33.160 --> 53:38.160]  Там противоречие. Это 1 из, а это минималь. Не может быть 1 из меньше.
[53:38.160 --> 53:39.160]  Противоречие.
[53:39.160 --> 53:42.160]  Значит, нужно всегда идти в такое возрастающее.
[53:42.160 --> 53:45.160]  Сначала там числа возрастают, потом будет бесконечность.
[53:45.160 --> 53:49.160]  А, конечно, если в какой-то момент будет бесконечность, то дальше тоже будет бесконечность.
[53:49.160 --> 53:51.160]  Хорошо.
[53:57.160 --> 54:02.160]  Значит, что происходит с этим массивом, когда мы переходим от i к плюс 1?
[54:16.160 --> 54:19.160]  А, да, я пишу с этим массивом.
[54:19.160 --> 54:29.160]  При переходе от i к плюс 1.
[54:29.160 --> 54:44.160]  Вот вопрос.
[54:44.160 --> 54:55.160]  Какие принципы гипнотических значений может принимать вот это вот значение?
[54:55.160 --> 54:57.160]  То есть, если у меня...
[54:57.160 --> 55:01.160]  Вот раньше я рассматривал в массиве все роковые элементы.
[55:01.160 --> 55:04.160]  Теперь добавляю логу i к плюс 1.
[55:04.160 --> 55:10.160]  И хочу найти dp или плюс первая карта.
[55:10.160 --> 55:14.160]  Какие значения может принимать это значение dp?
[55:14.160 --> 55:24.160]  Либо i к плюс первая, либо предыдущая dp. Все правильно.
[55:24.160 --> 55:28.160]  Я утверждаю, что гарантированно вот эта штука это либо вот это, либо вот это.
[55:28.160 --> 55:30.160]  Ну, это очень просто.
[55:30.160 --> 55:32.160]  Как именно? Что это такое?
[55:32.160 --> 55:36.160]  Это минимально возможное завершение под последствием с длины k.
[55:36.160 --> 55:38.160]  Что такое возрастающая, конечно.
[55:38.160 --> 55:40.160]  Что такое возрастающая под последствием с длины k?
[55:40.160 --> 55:43.160]  Она либо содержит, а я предыдущая, либо не содержит.
[55:43.160 --> 55:48.160]  Если содержит, то она на него заканчивается, поэтому это оно и есть.
[55:48.160 --> 55:53.160]  Либо она его не содержит, и мне нужно найти наибольшее, то точнее, наоборот, наименьшее завершение
[55:53.160 --> 55:56.160]  для возрастающих под последствием с длины k вот в этом массиве.
[55:56.160 --> 56:00.160]  А это dp у меня уже почти.
[56:00.160 --> 56:04.160]  Ну а поэтому в новом флоте, то есть для нового i,
[56:04.160 --> 56:07.160]  каждое значение dp принимать одно из двух значений.
[56:07.160 --> 56:08.160]  Либо вот это, либо вот это.
[56:08.160 --> 56:13.160]  Либо значение нового элемента, либо значение наследника из предыдущего массива.
[56:13.160 --> 56:16.160]  То есть при переходе от i к плюс 1 у меня значение сохранится.
[56:20.160 --> 56:22.160]  Давайте я напишу даже вот так.
[56:27.160 --> 56:28.160]  Вот, хорошо.
[56:28.160 --> 56:32.160]  Но, смотрите, мы же с вами знаем, что этот массив тоже должен быть возрастающим.
[56:32.160 --> 56:36.160]  Мы с вами доказали, что массив dp i t возрастающий,
[56:36.160 --> 56:39.160]  то же самое, конечно, работает и для i к плюс 1.
[56:40.160 --> 56:43.160]  Dp i t плюс 1, как массив, тоже возрастающий.
[56:47.160 --> 56:53.160]  Значит, в частности, я могу заменить его значение на i к плюс 1 не больше, чем один раз.
[56:53.160 --> 56:57.160]  Потому что, если я два каких-то различных элемента здесь заменяю на i к плюс 1,
[56:57.160 --> 57:00.160]  то массив уже возрастающий, строго возрастающий быть не может.
[57:00.160 --> 57:04.160]  Если есть два одинаковые значения где-то, он точно не возрастающий.
[57:04.160 --> 57:05.160]  Но он не строго возрастающий.
[57:05.160 --> 57:08.160]  Если есть два одинаковые, то он не может возрастать.
[57:08.160 --> 57:15.160]  Поэтому получается, что массив новый от предыдущего отвечает максимум в одной позиции.
[57:15.160 --> 57:21.660]  То есть я знаю, что каждое новое значение dp, x, y каты, это либо предыдущие dp, y, z каты, либо i, y, y.
[57:21.660 --> 57:25.660]  Но это не может больше, чем один раз встречаться, то и два раза не встречаться не может,
[57:25.660 --> 57:28.660]  потому что иначе обнаруживаются свойства возрастания.
[57:28.660 --> 57:32.660]  Значит у меня максимум один раз от предыдущего встречается.
[57:33.160 --> 57:33.660]  Вывод.
[57:37.660 --> 57:38.660]  Dp и п.
[57:42.160 --> 57:43.660]  Отличается от dp читого
[57:50.160 --> 57:51.660]  не более, чем в одной позиции.
[58:03.660 --> 58:05.160]  Надо понять, какой.
[58:24.160 --> 58:26.160]  Начнем с какой. Давайте посмотрим примере этого массива.
[58:27.660 --> 58:28.660]  Вот был у меня предыдущий dp.
[58:29.660 --> 58:30.660]  Dp и п.
[58:31.660 --> 58:33.660]  И допустим, я на веру, что предполагаю новое значение.
[58:35.660 --> 58:38.160]  Прошло число 20. Следующий число массива это 20.
[58:38.660 --> 58:43.160]  Но вопрос, как это меняет этот массив dp при переходе и плюс один.
[58:44.160 --> 58:48.160]  Смотрите, единственное, что я могу сделать, это какой-то из этих чисел поменять на 20.
[58:49.660 --> 58:52.660]  Понятно, что вот эти вот числа, которые меньше, чем 20, менять я не могу.
[58:52.660 --> 58:56.160]  Потому что если я что-то из них поменяю, то вот это за что могу поменять.
[58:56.660 --> 59:00.160]  Ну короче, если я поменяю что-то из них на 20, то у меня нарушено свойство возрастания.
[59:00.660 --> 59:02.160]  Поэтому их на 20 поменять нельзя.
[59:02.660 --> 59:05.160]  Это на 20 поменять можно, но это как-то глупо.
[59:05.660 --> 59:10.160]  Потому что если у меня раньше была возрастающая последовательная длина 4, которая заканчивается на 17,
[59:10.660 --> 59:13.160]  а теперь появилась такая же, которая заканчивается на 20,
[59:13.660 --> 59:15.160]  то понятно, что нужно оставить 17.
[59:15.660 --> 59:18.160]  А нет смысла увеличивать те числа, которые там уже и так есть.
[59:18.660 --> 59:23.160]  То есть если была последовательная длина 17, то последовательная длина 20 нам не выйдет.
[59:23.660 --> 59:25.160]  Мы ее игнорируем.
[59:25.660 --> 59:29.160]  Но я вот даже в таком случае надо 22 поменять на 20.
[59:30.660 --> 59:38.160]  Потому что у меня раньше была последовательная длина 4, которая заканчивается на 17,
[59:38.660 --> 59:41.160]  и теперь я книжу справа и буду писать на это число 20.
[59:41.660 --> 59:44.160]  У меня будет последовательная длина 5, которая заканчивается на 20.
[59:44.660 --> 59:46.160]  А раньше была только на 22.
[59:46.660 --> 59:48.160]  Понятно, что было из этих двух.
[59:48.660 --> 59:50.160]  Надо выбрать 2.
[59:50.660 --> 59:55.160]  На этом примере мы делаем вот примерно следующее.
[59:55.160 --> 59:58.660]  Нужно в текущей массиве Db взять число,
[59:59.160 --> 01:00:01.660]  наименьшее число, больше или равное, чем i equals 1,
[01:00:02.160 --> 01:00:03.660]  и заменить его на i equals 1.
[01:00:05.160 --> 01:00:06.660]  Значит алгоритм не такой.
[01:00:10.160 --> 01:00:11.660]  Да.
[01:00:17.160 --> 01:00:20.660]  Давайте, чтобы не было конфликта по значению чужих,
[01:00:26.160 --> 01:00:29.660]  пусть P до минимальных позиций,
[01:00:32.160 --> 01:00:34.660]  пока что Db,
[01:00:35.160 --> 01:00:38.660]  давайте он не Db будет взять, как он по другому массиву делал.
[01:00:40.160 --> 01:00:42.660]  Пусть будет массив B.
[01:00:46.160 --> 01:00:50.660]  Pt больше всего равно a.
[01:00:51.660 --> 01:00:55.160]  Тогда я делаю Pt равно a.
[01:01:01.660 --> 01:01:03.160]  Извините за новое подношение.
[01:01:03.660 --> 01:01:04.160]  Что я сделал?
[01:01:04.660 --> 01:01:07.160]  Чтобы не хранить, я не буду хранить двумерную динамику,
[01:01:07.660 --> 01:01:11.160]  потому что я понимаю, что массив только в одном элементе меняется каждый раз.
[01:01:11.660 --> 01:01:13.160]  Я не буду его много раскопировать.
[01:01:13.660 --> 01:01:15.160]  Я скажу, что у меня вот это текущая Pt.
[01:01:15.660 --> 01:01:18.160]  Когда соответственно в массиве D у меня было одно число,
[01:01:18.660 --> 01:01:20.160]  одно за другим меняется.
[01:01:20.660 --> 01:01:23.160]  B это текущая массив Dp.
[01:01:23.660 --> 01:01:27.160]  Я на этом уровне вынимаю эту пиксу, которая больше равна числа a,
[01:01:27.660 --> 01:01:29.160]  и ее меняю на a.
[01:01:29.660 --> 01:01:31.160]  Где же это?
[01:01:31.660 --> 01:01:35.160]  Новый рассматриваемый уровень.
[01:01:39.660 --> 01:01:41.160]  Все.
[01:01:41.660 --> 01:01:43.160]  Значит почему это будет работать?
[01:01:43.660 --> 01:01:47.160]  Ну смотрите, давайте я нарисую подробнее.
[01:01:47.660 --> 01:01:49.160]  Вот был у меня такой массив.
[01:01:50.660 --> 01:01:52.660]  Там какой-нибудь Pt,
[01:01:53.160 --> 01:01:55.160]  первая и так далее.
[01:01:55.660 --> 01:01:59.160]  И вот это число, это наименьшее число больше равное, чем a же.
[01:02:00.660 --> 01:02:02.160]  Больше равное, чем a же.
[01:02:02.660 --> 01:02:05.160]  Значит, ну тогда соответственно работает все то же самое.
[01:02:05.660 --> 01:02:09.160]  Все числа, стоящие вот здесь вот, левее, чем Bp,
[01:02:09.660 --> 01:02:11.160]  они точно меньше, чем a же.
[01:02:11.660 --> 01:02:14.160]  Но потому что Bp это первое большее равное.
[01:02:14.660 --> 01:02:16.660]  Если Bp это первое большее равное, то все предыдущие меньше.
[01:02:17.160 --> 01:02:19.160]  Значит вот эти меньше, нет смысла увеличивать до a.
[01:02:19.160 --> 01:02:21.660]  Нет смысла маленькие числа поднимать, которые большие.
[01:02:22.160 --> 01:02:24.660]  Потому что если была подпасенность закончена в маленьком числе,
[01:02:25.160 --> 01:02:27.660]  нет смысла ее последний элемент увеличить.
[01:02:29.160 --> 01:02:33.660]  Вот эту штуку мы можем спокойно и беспрепятственно уменьшить до a же.
[01:02:34.160 --> 01:02:37.660]  Потому что у меня было Bp-1 меньше Bp,
[01:02:38.160 --> 01:02:41.660]  у меня есть подпасенность длинной Bp-1,
[01:02:42.160 --> 01:02:43.660]  которая закончена в таком числе,
[01:02:44.160 --> 01:02:45.660]  и эта штука меньше, чем a же.
[01:02:45.660 --> 01:02:49.160]  Я могу продлить с помощью нового, только что прошедшего лимита a же,
[01:02:49.660 --> 01:02:51.160]  до последнего длины B.
[01:02:51.660 --> 01:02:54.160]  Поэтому по этой Bp я смогу смело заменить на a.
[01:02:54.660 --> 01:02:55.160]  Вот.
[01:02:55.660 --> 01:02:59.160]  Но если больше, я уже менять не имею права.
[01:02:59.660 --> 01:03:03.160]  Да, ну понятно, что если здесь произошла замена,
[01:03:03.660 --> 01:03:05.160]  то есть если здесь было скажем больше,
[01:03:05.660 --> 01:03:07.160]  то я не могла заменить, и может тогда нарушилась бы...
[01:03:07.660 --> 01:03:09.160]  А ну нет, что я...
[01:03:09.660 --> 01:03:11.160]  Просто если здесь произошла замена,
[01:03:11.660 --> 01:03:13.160]  то нигде правее замена произносить не могла,
[01:03:13.160 --> 01:03:15.660]  потому что иначе у меня нарушил свой связь с возрастанием.
[01:03:16.160 --> 01:03:18.660]  Поэтому замена матчу 1, и она вот здесь.
[01:03:20.160 --> 01:03:20.660]  Все.
[01:03:22.160 --> 01:03:23.660]  Вот такой алгоритм.
[01:03:24.160 --> 01:03:27.660]  Значит, ну надо еще позабыть свой том, с чем начинаем.
[01:03:30.160 --> 01:03:31.660]  Я, наверное,
[01:03:32.160 --> 01:03:34.660]  мы с ним B вот так вот определю.
[01:03:35.660 --> 01:03:37.160]  Видимо, мы так можем сделать.
[01:03:40.660 --> 01:03:43.160]  То есть я скажу, что B0 это минус бесконечность.
[01:03:43.660 --> 01:03:46.160]  Что означает, что как бы патент длины 0,
[01:03:46.660 --> 01:03:48.160]  она не имеет последнего элемента,
[01:03:48.660 --> 01:03:49.160]  ее можно продолжать чем угодно,
[01:03:49.660 --> 01:03:53.160]  поэтому я скажу, что это как будто бы последний элемент
[01:03:53.660 --> 01:03:54.160]  не имеет бесконечности.
[01:03:54.660 --> 01:03:59.160]  А все остальные элементы, как бы патент длины 1, 2 и так далее,
[01:03:59.660 --> 01:04:01.160]  они еще не существуют, поэтому там будет бесконечность.
[01:04:02.160 --> 01:04:03.660]  Вот это означает массив.
[01:04:04.160 --> 01:04:06.660]  Потом я в N раз делаю вот эту штуку.
[01:04:07.160 --> 01:04:08.660]  Посмотрите, это просто бинарный пояс, да?
[01:04:09.160 --> 01:04:10.660]  Это просто бинарный пояс.
[01:04:12.160 --> 01:04:14.660]  Ну, потому что это пояс какого-то числа,
[01:04:15.160 --> 01:04:16.660]  а вот цифрованного массива.
[01:04:17.160 --> 01:04:18.660]  Мы знаем, что массив B всегда возрастающий.
[01:04:19.160 --> 01:04:20.660]  Мне нужно в нем найти наименьшую позицию пояса,
[01:04:21.160 --> 01:04:21.660]  которая равна данному числу.
[01:04:22.160 --> 01:04:22.660]  А это бинт пояс.
[01:04:23.160 --> 01:04:24.660]  Целый алгоритм просто.
[01:04:26.160 --> 01:04:26.660]  Вот.
[01:04:26.660 --> 01:04:30.160]  И у этого цикла в массиве B подняться оптимально для каждой бинты.
[01:04:31.660 --> 01:04:33.160]  Вот, и тогда ответ.
[01:04:35.660 --> 01:04:38.160]  Это, видимо, максимально такой P,
[01:04:38.660 --> 01:04:43.160]  что ВПТ неравном плюс бесконечность.
[01:04:50.660 --> 01:04:52.160]  Да, потому что...
[01:04:52.660 --> 01:04:54.160]  Что же такое ВПТ?
[01:04:54.160 --> 01:04:59.660]  ВПТ – это либо минимальное соглашение по смыслу ВПТ,
[01:05:00.160 --> 01:05:01.660]  либо плюс бесконечность, и это ее так и не существует.
[01:05:02.160 --> 01:05:03.660]  В соответствии с возможным максимальным ВПТ,
[01:05:04.160 --> 01:05:04.660]  который ему существует,
[01:05:05.160 --> 01:05:07.660]  это будет как раз таки бинарный пояс.
[01:05:08.160 --> 01:05:09.660]  Это бинарный пояс.
[01:05:15.160 --> 01:05:17.660]  Итого, мы в данный момент построили...
[01:05:20.160 --> 01:05:22.660]  алгоритм, находящийся в собственном двинном доме.
[01:05:25.160 --> 01:05:26.660]  Вопросы?
[01:05:32.160 --> 01:05:32.660]  Скоро.
[01:05:33.160 --> 01:05:33.660]  Всю неделю, я надеюсь.
[01:05:34.160 --> 01:05:34.660]  А это именно?
[01:05:35.160 --> 01:05:35.660]  Да.
[01:05:36.160 --> 01:05:36.660]  Ну, я знаю.
[01:05:37.160 --> 01:05:37.660]  Вечи видны.
[01:05:40.160 --> 01:05:41.660]  Еще одно алгоритм алгоритма?
[01:05:44.160 --> 01:05:44.660]  Вот.
[01:05:45.160 --> 01:05:45.660]  Хорошо.
[01:05:46.160 --> 01:05:49.660]  Давайте мы теперь сделаем новое алгоритм.
[01:05:51.160 --> 01:05:53.660]  Короче, чуть более для понимания.
[01:05:55.160 --> 01:05:57.660]  Ну, используем фруктуры данного.
[01:05:58.160 --> 01:05:59.660]  Решение нужно два.
[01:06:05.160 --> 01:06:06.660]  Нас будет зачем другая фруктура?
[01:06:16.160 --> 01:06:17.660]  Значит, пусть такое ИТ,
[01:06:19.160 --> 01:06:20.660]  это длина,
[01:06:20.660 --> 01:06:21.660]  это длина,
[01:06:22.160 --> 01:06:23.660]  наибольшая длина возрастающих от последовательностей,
[01:06:24.660 --> 01:06:26.660]  если мы можем использовать только первые две элементы,
[01:06:27.160 --> 01:06:28.660]  и при этом последние элементы нельзя взять.
[01:06:31.660 --> 01:06:33.160]  Наибольшая длина
[01:06:34.660 --> 01:06:36.160]  возрастающих от последовательностей,
[01:06:36.660 --> 01:06:37.160]  в следствии,
[01:06:38.660 --> 01:06:39.660]  можно использовать
[01:06:46.160 --> 01:06:47.160]  только
[01:06:48.660 --> 01:06:50.160]  1 и так далее аин,
[01:06:50.660 --> 01:06:52.160]  причем аин обязательно вся
[01:06:53.660 --> 01:06:55.160]  в возрастающих последовательностях.
[01:07:11.160 --> 01:07:11.660]  Значит, тогда,
[01:07:12.160 --> 01:07:14.160]  если мне, например, известно значение ДПС на всех
[01:07:15.660 --> 01:07:17.660]  начальник отряда 1 до И,
[01:07:18.160 --> 01:07:19.160]  ну или когда имя не сходится,
[01:07:19.160 --> 01:07:20.660]  то имя сходится в какое-то длинное.
[01:07:22.160 --> 01:07:23.160]  Я хочу построить
[01:07:23.660 --> 01:07:25.160]  какой-то возрастающий пасет,
[01:07:25.660 --> 01:07:27.160]  который заканчивается в аи.
[01:07:27.660 --> 01:07:29.660]  Давайте продолжаем, берем последний элемент.
[01:07:30.160 --> 01:07:32.660]  Тогда предпоследний элемент это какой-то клиник слева,
[01:07:33.160 --> 01:07:35.160]  который меньше, чем аин.
[01:07:37.660 --> 01:07:39.160]  Поэтому мы будем церковно выражать,
[01:07:39.660 --> 01:07:42.160]  максимум пасета х меньше, чем и,
[01:07:42.660 --> 01:07:45.160]  и такие, что а х меньше, чем аин.
[01:07:45.660 --> 01:07:47.160]  То есть они идут в плюс ДПЖ.
[01:07:49.160 --> 01:07:50.160]  Например.
[01:07:58.160 --> 01:08:00.160]  Например, если я заканчиваю все аин.
[01:08:02.160 --> 01:08:03.160]  Давайте я, конечно, рисую.
[01:08:03.660 --> 01:08:05.160]  Я хочу измерить в том, что я имею все аин.
[01:08:05.660 --> 01:08:08.160]  Давайте переберу предпоследний элемент.
[01:08:08.160 --> 01:08:10.160]  Вот, сейчас я смотаю их.
[01:08:10.660 --> 01:08:12.160]  Тогда будут два условия.
[01:08:12.660 --> 01:08:14.160]  В-первых, мы находимся в элемент, который подмен patriot.
[01:08:15.160 --> 01:08:16.160]  Если для всех таких,
[01:08:16.660 --> 01:08:18.160]  если я же, что я как бы предзаканчиваю
[01:08:18.160 --> 01:08:22.920]  заканчивается в мой предпоследний этаж, и мне нужно просто найти максимальную дыну
[01:08:22.920 --> 01:08:28.040]  позаходящей поцелусти напрямую с первого положительного элемента, где h включено.
[01:08:28.040 --> 01:08:33.080]  Ну, это как раз просто DP6. В плюсы гейта за счет того, что я вытолкнул.
[01:08:33.080 --> 01:08:35.080]  Да?
[01:08:35.080 --> 01:08:37.080]  Вот.
[01:08:37.080 --> 01:08:42.760]  Сейчас вот тут мы сразу вновь получили квадратичное решение.
[01:08:42.760 --> 01:08:46.680]  Потому что я могу просто ямой для каждого из них перебирать все предыдущие жиры,
[01:08:46.680 --> 01:08:51.280]  которые имеющие магни, из них убрать максимум и прибавить на крючок.
[01:08:51.280 --> 01:08:53.280]  Это уже будет квадрат.
[01:08:53.280 --> 01:08:57.280]  Вот это можно тоже до венбоквен межировать. Давайте сделаем.
[01:09:16.680 --> 01:09:18.680]  Так.
[01:09:18.680 --> 01:09:20.680]  Значит, двум приемом.
[01:09:20.680 --> 01:09:22.680]  Смотрите.
[01:09:22.680 --> 01:09:28.680]  Я вижу, что DP8 выражается в DP для тех, у кого aj меньше, чем aj.
[01:09:28.680 --> 01:09:32.680]  Поэтому раздумно рассматривать все элементы нашего массива в порядке увеличения.
[01:09:32.680 --> 01:09:38.680]  Сначала минимальный, потом второй, да, вторая порядка, третья, четвертая и так далее.
[01:09:38.680 --> 01:09:44.680]  И тогда, к моменту рассмотрения aj, как раз такие просмотры будут только такие, которые ай меньше, чем aj.
[01:09:44.680 --> 01:09:48.680]  Ну и, соответственно, будут только условия, с которыми нас падает только те, которые любят.
[01:09:48.680 --> 01:09:50.680]  Поэтому давайте делаем вот это следующее.
[01:09:50.680 --> 01:09:56.680]  Давайте мы изначально все к DP заполняем венбоквен.
[01:09:56.680 --> 01:09:58.680]  Убьем все элементы.
[01:09:58.680 --> 01:10:02.680]  И будем их восстанавливать и воскрешать порядке увеличения.
[01:10:10.680 --> 01:10:14.680]  Значит, ну здесь надо аккуратно ввести ай, ай, ай, ай.
[01:10:14.680 --> 01:10:16.680]  Ай, ай, ай.
[01:10:16.680 --> 01:10:18.680]  Ай, ай, ай.
[01:10:18.680 --> 01:10:20.680]  Ай, ай, ай, ай.
[01:10:20.680 --> 01:10:22.680]  Ай, ай, ай, ай, ай.
[01:10:22.680 --> 01:10:24.680]  Ай, ай, ай, ай.
[01:10:24.680 --> 01:10:26.680]  Ай, ай, ай, ай.
[01:10:26.680 --> 01:10:30.680]  Значит, ну здесь надо аккуратно вспоминать, что происходит с элементами равными.
[01:10:30.680 --> 01:10:34.680]  Давайте я буду считать, что у меня нет равных.
[01:10:34.680 --> 01:10:36.680]  У меня равных нет.
[01:10:38.680 --> 01:10:44.680]  Но если они равны, то на самом деле равные, то можно воскрешать порядок справа налево.
[01:10:46.680 --> 01:10:54.680]  Если есть ту равную, то воскрешаем порядок справа налево.
[01:10:56.680 --> 01:11:12.680]  Значит, нужно знать тем, что в момент рассмотрения ай, у меня должны быть слева все элементы, которые имеющие ай.
[01:11:12.680 --> 01:11:14.680]  Я их должен был все раскрыть.
[01:11:14.680 --> 01:11:20.680]  И чтобы как раз элементы равные ай не мешали, я хочу иметь их справа налево.
[01:11:20.680 --> 01:11:24.680]  Воскрешаю элементы равные ай и иду справа налево, чтобы те, которые я вижу, не мешали иметь слева.
[01:11:24.680 --> 01:11:30.680]  Если я иду справа налево, то они будут не мешать.
[01:11:30.680 --> 01:11:32.680]  Если я иду справа налево, то они будут не мешать.
[01:11:32.680 --> 01:11:34.680]  Вот.
[01:11:34.680 --> 01:11:36.680]  Ну и все.
[01:11:36.680 --> 01:11:44.680]  Дальше нужно просто придумать какую-нибудь структуру данных, которая позволяет делать изменения в точке и находить максимум на отрезке.
[01:11:44.680 --> 01:11:52.680]  Потому что вот здесь вот у меня предстоит представление ленты H&K, а здесь максимум на отрезке по всем вымещеним.
[01:11:52.680 --> 01:11:54.680]  Что это за структура такая?
[01:11:54.680 --> 01:11:56.680]  Ну что угодно.
[01:11:56.680 --> 01:11:58.680]  Например, дерево отрезка или дерево феновика.
[01:11:58.680 --> 01:12:04.680]  Феновик тоже годится, потому что здесь в нашей структурке все значения будут только увеличиваться.
[01:12:04.680 --> 01:12:06.680]  И запрос максимум только на префиксе будет происходить.
[01:12:06.680 --> 01:12:10.680]  То есть мы видим, что здесь же меньше мыд префикс.
[01:12:10.680 --> 01:12:12.680]  Поэтому даже хватит феновика.
[01:12:12.680 --> 01:12:16.680]  Ну давайте я это напишу.
[01:12:16.680 --> 01:12:18.680]  На прямой работе I.
[01:12:22.680 --> 01:12:24.680]  На ходе.
[01:12:26.680 --> 01:12:28.680]  Просто максимум по всем вымещеним.
[01:12:32.680 --> 01:12:34.680]  Как раз вот это вот условие.
[01:12:34.680 --> 01:12:42.680]  Я могу это сделать, потому что все элементы, которые больше либо равны, они как бы не рассмотрены.
[01:12:42.680 --> 01:12:44.680]  И для них Db равна 0.
[01:12:44.680 --> 01:12:46.680]  Db равну 0.
[01:12:46.680 --> 01:12:48.680]  Поэтому иногда вот я напишу в максимум.
[01:12:48.680 --> 01:12:52.680]  То есть вот здесь, из-за того, что они здесь появляются, я максимум не изменяю.
[01:12:52.680 --> 01:12:54.680]  Потому что там появляются нулевые элементы, у меня максимум не меняется.
[01:12:54.680 --> 01:12:58.680]  Поэтому я могу просто рассматривать максимум на отрезке.
[01:12:58.680 --> 01:13:02.680]  Значит при обработке I находим вот эту штуку.
[01:13:02.680 --> 01:13:04.680]  Ну и дальше обновляю.
[01:13:04.680 --> 01:13:06.680]  Обновляю.
[01:13:06.680 --> 01:13:10.680]  Dp и t равно 1.
[01:13:10.680 --> 01:13:16.680]  Найду другую тупую цель с длиной x и ее дополняю новым элементом I.
[01:13:16.680 --> 01:13:18.680]  Здесь сгодится...
[01:13:18.680 --> 01:13:22.680]  Каждую структуру сгодится делим отрезков.
[01:13:26.680 --> 01:13:30.680]  Или берем феновика.
[01:13:30.680 --> 01:13:36.680]  Потому что мне нужно уметь делать увеличение элемента и макро на префиксах.
[01:13:36.680 --> 01:13:40.680]  А это уметь делать и фен, и пт.
[01:13:44.680 --> 01:13:46.680]  Понятно?
[01:13:48.680 --> 01:13:52.680]  Хорошо, тогда сгодится у меня будут нлубы.
[01:13:52.680 --> 01:13:58.680]  Потому что я один раз делаю запросы типа getMax и update.
[01:13:58.680 --> 01:14:02.680]  У меня n запросов марш на отрезке, и n запросов обновляю.
[01:14:04.680 --> 01:14:06.680]  Вот.
[01:14:06.680 --> 01:14:10.680]  А, надо сказать еще ответ.
[01:14:10.680 --> 01:14:12.680]  Ответ, скорее всего, где лежит?
[01:14:12.680 --> 01:14:14.680]  Где?
[01:14:14.680 --> 01:14:16.680]  Где?
[01:14:16.680 --> 01:14:18.680]  Где?
[01:14:18.680 --> 01:14:20.680]  Ответ, скорее всего, где лежит?
[01:14:20.680 --> 01:14:22.680]  Где?
[01:14:22.680 --> 01:14:26.680]  Не, он же не прав.
[01:14:26.680 --> 01:14:30.680]  Да, max и max, потому что мы не знаем, где мы, на самом деле, должны заканчиваться.
[01:14:30.680 --> 01:14:36.680]  То есть Dp и t у меня насильно предполагают, что I и t это последний элемент моей последовательства.
[01:14:36.680 --> 01:14:42.680]  Я не знаю, где, на самом деле, мы заканчиваемся, поэтому из всех нужно выбрать максимально.
[01:14:42.680 --> 01:14:44.680]  Max, max, I и t.
[01:14:48.680 --> 01:14:52.680]  Ну и, собственно, все.
[01:14:52.680 --> 01:14:56.680]  Здесь, например, точно так же можно поставить ответ.
[01:14:56.680 --> 01:15:00.680]  Я это делал в предыдущем способе, через BinBoys.
[01:15:00.680 --> 01:15:04.680]  Там, собственно, я чуть похитрее, потому что мне нужно в каком-то смысле куда-то пересекать массив.
[01:15:04.680 --> 01:15:06.680]  Не буду подробнее.
[01:15:06.680 --> 01:15:10.680]  Но вот здесь, на основании ответа, все довольно прозрачно.
[01:15:10.680 --> 01:15:20.680]  Нужно просто, как обычно, в момент присвоения Dp и t уметь определять,
[01:15:20.680 --> 01:15:22.680]  а каким образом я получил этот максимум.
[01:15:22.680 --> 01:15:24.680]  То есть, за счет чего, вот здесь написано 1,2x.
[01:15:24.680 --> 01:15:28.680]  За счет того, что я нашел здесь какой-то произведенной ж, что Dp и t равно x.
[01:15:28.680 --> 01:15:34.680]  Поэтому мне нужно как бы на этой структуре уметь не только максимум, но и позицию максимум.
[01:15:34.680 --> 01:15:38.680]  Если я это у меня делаю, то я вот здесь вот также обновляю, чтобы i и t равно x.
[01:15:38.680 --> 01:15:46.680]  То есть, я запоминаю, как именно был получено в текущей начине Dp в вспомогательной массиве P.
[01:15:46.680 --> 01:15:54.680]  На и опять-то, любого D, узнаем, как именно получен x.
[01:15:54.680 --> 01:15:58.680]  Ну, скорее, где именно?
[01:15:58.680 --> 01:16:00.680]  Где именно получен x?
[01:16:00.680 --> 01:16:10.680]  Мы тогда кладем Piter, но Piter уже держит вот та самая ячейка, где получен x.
[01:16:10.680 --> 01:16:18.680]  Но если я знаю, как именно получит каждая начинка Dp, то Dp и t получатся, по сути, через Dp и t.
[01:16:18.680 --> 01:16:24.680]  Тогда то же самое, просто у меня с восстановлением с конца работает, я знаю, где левоответ, это максимальная Dp.
[01:16:24.680 --> 01:16:28.680]  И дальше по одному откусываю последний элемент, переходя к предыдущему в моей поцелусти.
[01:16:28.680 --> 01:16:30.680]  И я могу целиком восстановить нашу Dp.
[01:16:33.680 --> 01:16:35.680]  Все, спасибо.
