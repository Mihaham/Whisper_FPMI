[00:00.000 --> 00:09.440]  Кто-нибудь помнит, когда у нас лекция по счету? Пускай будет десятая. И будем ее...
[00:09.440 --> 00:15.560]  Посветим сегодня немножко другое задачу, чем в прошлый раз. Если в прошлый раз у нас было
[00:15.560 --> 00:21.600]  все про то, как искать точное вхождение одной строки в другую, то есть паттерна в текст,
[00:21.600 --> 00:28.320]  в этот раз мы будем искать вхождение множества строк в текст. То есть задача наша идейна,
[00:28.320 --> 00:45.960]  на текущий, наверное, час, данный n-строк, s1, sn. Хотим найти либо факт вхождения,
[00:45.960 --> 01:00.540]  либо все вхождения. Вот так у нас будет задача. Что вы здесь можете вообще с точки
[01:00.540 --> 01:06.800]  зрения применимости этой задачи сказать? Например, если у нас есть s и t заданы каким-то
[01:06.800 --> 01:11.840]  регулярным условием, регулярным выражением, и при этом он там какой-то специфичного вида такой,
[01:11.840 --> 01:17.160]  что он не может очень много раскрываться раз, то тогда можно по сути собрать все вот эти вот
[01:17.160 --> 01:25.200]  коротенькие строчки и искать их вхождение. В тексте, например, во все возможные пути. Вот,
[01:25.200 --> 01:32.680]  это так называемый греб, то что внутри используется. Вот, а пока что мы отступим от этой задачи и
[01:32.680 --> 01:47.320]  научимся в такой структуре данных, как bore. Определение по-английски 3e, потому что Google
[01:47.320 --> 01:54.560]  переводчик переводит как boron, и не тот немножко, не тот bore будет. Вот. Так, bore или 3e, или префиксное
[01:54.560 --> 02:05.000]  дерево его еще называют. Кто это такой? Для строк, то есть у вас есть анстрок, и вы под ним
[02:05.000 --> 02:31.920]  строите bore. Это такое подвешенное дерево, что на каждой, на каждом ребре написано
[02:31.920 --> 02:43.480]  буква. Что еще есть? Из одной вершины не может выходить два ребра по одной букве,
[02:43.480 --> 03:04.600]  нет двух ребер по одной букве. Что еще можно сказать про bore? Окей, то есть корневое дерево,
[03:04.600 --> 03:28.920]  где на ребрах написаны буквы. Чтение по bore от корня вниз. Вершины, соответствующие с итом,
[03:28.920 --> 03:41.360]  терминальные. Вот как-то так примерно можно отлить bore. Давайте для примера. Так, ну давайте
[03:41.360 --> 03:52.360]  какой-нибудь множество строк рассмотрим. Да, просто bore будет ставить. Здесь идеи на никакого смысла нет
[03:52.360 --> 04:00.680]  терминальности. Какой-нибудь вот такой вот набор строк. Да, тогда у нас есть корневая вершинка, дальше
[04:00.680 --> 04:19.320]  будут эти переходы по буквам. Ну давайте выпишем сначала первую строку abac. И так как это конец строки,
[04:19.320 --> 04:39.560]  она будет терминальной. Дальше у нас будет ba, ba. Ну она тоже терминальная. Дальше просто a. Она будет
[04:39.560 --> 04:44.120]  тоже терминальная, потому что у нас есть строка a в наборе, значит можем ее просто прочесть. Дальше будет
[04:44.120 --> 04:53.600]  аа. Идем по а, есть переход, отлично переходим по а. Перехода по а нет, строим новый переход,
[04:53.600 --> 05:01.640]  и вернемся, что это терминал. И ab, переходим из корня по а, по b, считали, пришли вершинку,
[05:01.640 --> 05:10.160]  ее тоже делаем терминально. Вот такой вот bore. Ну так его назвали. По-английски префиксное дерево,
[05:10.160 --> 05:20.440]  или 3e. Зачем эта штука нужна? Во-первых, эта штука легко строится, у нее есть просто функция добавь
[05:20.440 --> 05:27.200]  строку в набор. Называется иди из корня, пока есть переходы. Переходим переходом, когда нет
[05:27.200 --> 05:33.600]  перехода, выписывай все остальное новыми ветками. Просто ветку рисуй. Все. Если вам сейчас скажут,
[05:33.600 --> 05:39.840]  ходим в слово b, b, что-то там, вы идете по b, дальше у вас нет перехода по b, вы строите новый и
[05:39.840 --> 05:48.480]  дописываете до конца ваше слово. Вот это добавление в bore. Соответственно, что еще можно сказать?
[05:48.480 --> 05:53.520]  Помимо добавления в bore есть, понятное дело, поиск в bore. То есть вам нужно проверить, правда ли,
[05:53.520 --> 05:58.080]  что есть строка в множестве? Ну вы просто берете, идете по bore и смотрите, правда ли, что вы в конце
[05:58.080 --> 06:04.200]  концов пришли в терминал и всегда могли идти по веткам, ну по ребрам. Если да, то значит строка
[06:04.200 --> 06:10.800]  есть в наборе. Например, есть ли в этом наборе строка a-b-a? Вы идете a-b-a, но это не терминал,
[06:10.800 --> 06:18.400]  поэтому нет в наборе. Аналогично можно спросить, есть ли a-b, а-b в наборе есть, потому что пришли в
[06:18.400 --> 06:26.240]  терминал. Есть ли b-b? b, а тут нет перехода, не смогли перейти, значит очевидно нет. Вот мы все.
[06:26.240 --> 06:32.600]  Очень интеллектуальная структура данных позволяет вам, во-первых, добавлять строку за ее длину,
[06:32.600 --> 06:39.800]  во-вторых, искать строку за ее длину. То есть есть строка в множестве. Что еще можно сказать? Можно
[06:39.800 --> 06:46.160]  удалять строки из bore. Это чуть менее тривиально и оставим это на семинар, потому что нужно два
[06:46.160 --> 06:58.080]  случая разобрать целых. Ну нет, там типа вы идете по строке, смотрите, правда ли, что этой вершины
[06:58.080 --> 07:02.960]  нет больше других детей. Если нет, то поднимаетесь на уровень вверх, смотрите, снова нет ли у нее
[07:02.960 --> 07:09.320]  детей или не является ли она терминалом. И если с этим там откусываете по ребру или в какой-то
[07:09.320 --> 07:17.160]  момент вы остановитесь и закончилась удаление. Вот так. Что еще здесь нужно сказать? Ну,
[07:17.160 --> 07:26.600]  про bore в целом все на самом деле. Что можно сказать? Давайте напишем еще табличку, а именно хранение
[07:26.600 --> 07:33.240]  переходов или хранение ребер. То есть в каком контейнере мы будем хранить ребра? Потому что
[07:33.240 --> 07:40.080]  мы можем хранить их в мапе по букве вершинку, в аннорной мапе по букве вершинку и в векторе,
[07:40.080 --> 07:45.320]  если у нас там аффект какой-то маленький, мы можем четко сказать индекс буквы. Например,
[07:45.320 --> 07:54.280]  а это нулевая буква, б это первая буква, z это 25-я буква будет. Вот, хранение ребер, память,
[07:54.280 --> 08:05.280]  поиск. Ну и что еще можно сказать? Ну, в целом, это все, что нужно. То есть вот такие две штуки,
[08:05.280 --> 08:10.520]  память и поиск. Потому что что поиск, что вставка, что удаление, оно будет за одно и то же время
[08:10.520 --> 08:20.200]  работать. Так, хранение ребер первое, это вектор. Тогда какая память будет? В каждой вершинке вы
[08:20.200 --> 08:33.760]  нужно хранить сигма вершины, где сигма это размер алфавита. Так, но зато поиск у вас четко
[08:33.760 --> 08:38.680]  переход за единичку по одному ребру делается, золотые единицы. Потому что вы знаете, какую вам
[08:38.680 --> 08:43.840]  букву нужно сейчас добавлять, вы просто смотрите по этому индексу. Ну, какую букву искать точнее.
[08:43.840 --> 08:55.240]  Поиск строки q. Ну q это слово query будет. Дальше будет мап
[08:55.240 --> 09:18.320]  из чара в ноду. Ну какая память будет здесь, как вы думаете? Ну да, именно так,
[09:18.320 --> 09:29.840]  потому что вы ничего лишнего не храните в общем-то. Это вообще ни о чем. Это укладывается в константу.
[09:29.840 --> 09:37.680]  Вы забыли главную мантуру алгоритмистов. Алгоритмисты это главные лжицы, они все
[09:37.680 --> 09:52.800]  прячут в константу. Вот так, теперь поиск строки запроса. Ну сколько нам стоит переход по одному
[09:52.800 --> 10:10.720]  ребру? Да, кулок сигма. Ну последнее, что можно здесь искать, это unordered map. Ну и конечно же,
[10:10.720 --> 10:17.600]  конечно, бицеп, как всегда, будут отличаться своими лучшими характеристиками, в исключении того,
[10:17.600 --> 10:22.880]  что она безумно медленная и поэтому примерно никогда не используется, потому что здесь константа
[10:22.880 --> 10:29.800]  огромная внутри. Ну все-таки писать это будете. Я вам просто заранее говорю, что когда вы будете
[10:29.800 --> 10:35.880]  писать либо это, либо это использовать, это обычно не проходит таймлимита, потому что очень долгое.
[10:35.880 --> 10:43.360]  Тем более, у вас обычно a-z, поэтому вектор всегда устраивает всех. Так, и ладно, с Бором
[10:43.360 --> 10:52.480]  разобрались? Есть вопросы по этой штуке? Ну видимо нет, превосходно. Тогда теперь небольшое
[10:52.480 --> 10:59.160]  напоминание второму курсу, небольшое введение первому курсу о том, кто такие автоматы и зачем
[10:59.160 --> 11:28.120]  они нужны. Определение. Недетерминированный. Конечный автомат. Далее НКА. Это картеж
[11:28.120 --> 11:46.840]  такого вида. Пятерка получается. Где модуль Q меньше бесконечности состояния. Дальше Сигма.
[11:46.840 --> 11:53.680]  Давайте считать его тоже конечным. Альфавит, потому что бесконечный алфавит это что-то не то.
[11:53.680 --> 12:04.080]  Дельта. Это вот такая вот интересная штука. Подножство декартового произведения Q на Сигма на Q.
[12:04.080 --> 12:26.800]  Это переходы. Дальше Q0. Стартовое состояние. Что еще можно сказать? Q0 лежит в Q и
[12:26.800 --> 12:40.400]  F будет под множеством Q. Конечное состояние или терминальное состояние или принимающее состояние.
[12:40.400 --> 12:47.440]  Так, все. Это очень страшное определение. Забыли его, поэтому я перемещусь сразу на другую доску.
[12:47.440 --> 12:56.040]  Теперь как это нужно понимать в голове? У вас есть ориентированный граф, в котором есть вершинки.
[12:56.040 --> 13:01.560]  Это состояние. Стартовое состояние обычно вот так обозначают. Дальше есть какой-то граф,
[13:01.560 --> 13:06.720]  где на ребрах написаны буквы. Как раз таки дельта это функция перехода, которая берет Q,
[13:06.720 --> 13:13.920]  берет состояние откуда вы стартуете, берет Сигму, буковку из алфавита и переходит снова в какой-то
[13:13.920 --> 13:24.560]  элемент Q, то есть какую-то вершинку. Например, можно построить вот такой вот автомат. Ну и
[13:24.560 --> 13:33.280]  крестиком помещаем терминальные вершины. Это прекрасный автомат. Он принимает в себя вот такие
[13:33.280 --> 13:53.920]  строки A, AB, ABB и так далее. То есть A и какое-то куча B. Что? Кто? Значит нельзя принять. Все.
[13:55.160 --> 14:01.040]  Ну, возможно это так называется, я уже не помню. Короче говоря, нельзя принять просто это слово,
[14:01.040 --> 14:06.440]  не принимается. Вот мы говорим, что слово принимается автоматом. Там есть огромное
[14:06.440 --> 14:13.200]  формальное определение. Мы будем говорить на детском научпопском. Если есть путь из стартового
[14:13.200 --> 14:18.280]  вершины в какой-то терминал по буквам. Все. Там по хорошему определению надо писать не Сигма,
[14:18.280 --> 14:23.720]  а Сигма со звездой, потому что у вас на ребрах могут быть написаны пустые строки, целые слова,
[14:23.960 --> 14:29.560]  однако давайте будем считать, что по одной букве везде написано. Эпсимум перехода их можно сжать,
[14:29.560 --> 14:35.000]  длинные переходы можно раскрыть. Вот. Окей, мы с вами определили, что такое слово принимается
[14:35.000 --> 14:41.240]  автоматом. Соответственно, язык, который принимает автомат, это все слова, которые принимаются. Вау.
[14:41.240 --> 14:48.680]  Отлично. Ну давайте простенького утверждения. Правда ли, что если язык принимаем автоматом
[14:48.680 --> 14:58.480]  бесконечен, то в нем есть цикл? В автомате. В графе автомата цикл. А вернули обратное,
[14:58.480 --> 15:04.000]  что если в графе автомата есть цикл, то язык бесконечен, который он принимает. Это неверно,
[15:04.000 --> 15:08.720]  потому что просто у вас из этого цикла могут быть недостижимы терминальные вершины, или наоборот
[15:08.720 --> 15:13.480]  цикл может быть недостижимый стартовых вершин. По приколу, вот так его нарисовали. Далее мы будем
[15:13.480 --> 15:19.760]  считать, что у нас вообще язык будет всегда конечен на самом деле, но это не очень важно. Окей,
[15:19.760 --> 15:24.120]  кто такой детерминированный автомат? Там написано детерминированный конечный автомат. Конечный,
[15:24.120 --> 15:29.840]  потому что у вас сейчас состояние конечное. А детерминированный, это значит, что у вас из каждой
[15:29.840 --> 15:34.440]  вершины по каждой букве выходит не более одного ребра. То есть у вас не может быть такого,
[15:34.440 --> 15:41.160]  что у вас сюда по букве А и сюда по букве А. Потому что тогда просто автомату непонятно в какую
[15:41.160 --> 15:47.560]  вершину идти, когда он придет сюда и встретит букву А в слое. Вот таких ситуаций мы себе не
[15:47.560 --> 15:55.760]  позволяем, потому что у нас дельта – это однозначная функция. Если она принимает в себя состояние Q и
[15:55.760 --> 16:08.720]  букву сигму, то мощность значений, то есть для любой Q из Q, для любой сигма из сигма дельта от Q
[16:08.720 --> 16:18.720]  сигма, мощность таких не превосходит единичке. То есть может не быть вообще такого, не определено.
[16:18.720 --> 16:24.720]  Тогда просто у вас автомат сломался, когда вы пытались читать слово. Может быть определено
[16:24.720 --> 16:30.400]  тогда только одна вершина ему соответствует этому ребру. Если больше у вас получается
[16:30.400 --> 16:35.280]  многозначная функция, по теории таких приколов вы будете изучать в третьем курсе,
[16:35.280 --> 16:39.600]  в теории сложностей, когда будете говорить про детермированную машину тюринга.
[16:39.600 --> 16:45.920]  Вот. Так, окей. Пам-пам-пам. Что здесь? Ну, с автоматами все получается.
[16:45.920 --> 17:03.360]  Так. Тем, что в боре – это дерево. А тут можем петли себе вообще рисовать. Продолжим. Так,
[17:03.360 --> 17:14.160]  кто такой автомат Аха Карасик, собственно? Возможно, вы слышали алгоритм Аха Карасик.
[17:14.160 --> 17:20.440]  Вот вы не поверите, что он делал, потому что это автомат Аха Карасик. Вот. Собственно,
[17:20.440 --> 17:28.400]  Ахо – это, по-моему, Ульфред или Альфред, я не помню. Ахо и Маргарет Карасик. Поэтому Карасик
[17:28.400 --> 17:38.960]  не склоняется фамилию. Не автомат Аха Карасика. Вот. Соответственно, можно очень много разных
[17:38.960 --> 17:43.440]  названий придумать к этой штуке, типа Хахакасарик и так далее. Давайте нормально его обзывать сразу.
[17:43.440 --> 17:51.600]  Вот. Что мы хотим? Идеи на наши будут, значит, следующие. Помните, как мы с вами искали
[17:51.600 --> 17:58.080]  вхождение строки в текст с помощью префикс-функции? Мы писали строка, решетка текст, считали префикс-функцию
[17:58.080 --> 18:05.080]  и побеждали. Сейчас на смысл будет примерно похоже, однако мы хотим теперь построить в некотором
[18:05.080 --> 18:10.560]  плане префикс-функцию не для одной строки, а для набора строк, а в общенную префикс-функцию. Вот.
[18:10.560 --> 18:16.240]  Да, сразу скажу, что автомат Аха Карасик для одной строки будет автоматом префикс-функции. Вот. Ну,
[18:16.240 --> 18:27.840]  потом мы это поймем. Так, давайте определять. Определение. Так, наверное, начнем с такой штуки.
[18:27.840 --> 18:52.840]  Суфиксная ссылка вершины В. Это такая вершина У, что
[18:52.840 --> 19:20.320]  слово, прочитанное в Боре, до вершины У, это наибольший по длине
[19:20.320 --> 19:45.200]  не собственный суфикс такого слова В. Например, давайте рассмотрим опять же для этого Бора. То есть
[19:45.200 --> 19:49.760]  у нас есть Бор, у нас есть набор строк вообще. Потом мы будем построили Бор. Собственно, суть
[19:49.760 --> 19:53.960]  автомата Карасик в том, чтобы построить суфиксные ссылки, а потом построить функцию перехода по
[19:53.960 --> 20:01.440]  автомату. А давайте посмотрим вот здесь вот. Вот для строки АА рассмотрим все ее суффиксы. Не
[20:01.440 --> 20:07.720]  собственные. Первый суффикс это длина А. Можно ли его прочесть в Боре? Ну да, можно. Вот у вас есть
[20:07.720 --> 20:16.160]  переход по А. Быть может не в терминал, это не особо важно. Дальше. Давайте вот для этой вершины
[20:16.160 --> 20:26.800]  посмотрим суффиксную ссылку. Можем ли прочесть суффикс БАЦ в Боре? Нет. АЦ в Боре? Ну тоже нет.
[20:26.800 --> 20:36.520]  Ц в Боре? Тоже нет. Поэтому только корень, пустое слово мы себя прочесть можем. Так,
[20:36.520 --> 20:45.960]  давайте теперь для АБА. Суффикс БА. Прочесть можем в Боре? Да, можем. Вот он БА. Дальше. Строка АБ.
[20:45.960 --> 20:57.000]  Вне суффикс БА. Можем прочесть? Да, можем. Вроде бы для всех нашел. А нет, еще вот сюда суффиксная ссылка будет вести.
[20:57.000 --> 21:02.040]  Вот теперь для всех вершин нашел суффиксные ссылки. Что?
[21:06.520 --> 21:17.360]  Который не равен длине строки. Ну ладно. Значит собственную определение надо написать. Который не равен длине строки.
[21:17.360 --> 21:26.840]  Не равен всей строке. Вот так вот. Потому что понятно, если вы разрешаете быть равными всей строке, вы сами в себя придете.
[21:26.840 --> 21:35.640]  Просто по определению. Вот. Это понятие суффиксной ссылки. И теперь вводится функция перехода, так называемая,
[21:35.760 --> 21:49.760]  Дельта из нашего пленни автомата. Она вводится рекурсивным образом. Точнее не так. Из вершинки В по букве Сигма.
[21:49.760 --> 21:59.760]  Куда она нас должна привести? Давайте определим просто как функцию, рекурсивным.
[22:05.760 --> 22:17.760]  То есть если в Боре у вас есть переход из вершины В по букве Сигма, вы просто переходите как в Боре.
[22:17.760 --> 22:33.760]  Очень интеллектуально. Иначе это ту от линк от В. Сигма. Вот так вот. Интересным образом она определяется.
[22:33.880 --> 22:37.880]  То есть если вы можете пройти по букве в Боре, то идете как в Боре.
[22:37.880 --> 22:42.880]  Если нет, вы идете в суффиксную ссылку и дальше смотрите, можно ли прыгнуть или нет.
[22:42.880 --> 22:46.880]  Допустим нет, тогда вы еще раз будете прыгать по суффиксной ссылке.
[22:47.000 --> 22:57.000]  Итого. То есть допустим нам нужно отсюда перейти по букве В.
[22:58.000 --> 23:03.000]  Вот эта вот вершинка В, мы хотим посчитать ту от В по букве В.
[23:05.000 --> 23:13.000]  Смотрим, есть ли переход в Боре? Нет? Хорошо. Тогда раскрывается по второй ветке определение.
[23:13.120 --> 23:19.120]  Так, суффиксная ссылка вершины В, вот она. Это вершина У.
[23:24.120 --> 23:29.120]  Смотрим, есть ли из У переход по букве В? Нет. Грустная история.
[23:29.120 --> 23:33.120]  Значит раскрывается по второй ветке определение.
[23:33.240 --> 23:39.240]  Ну, суффиксная ссылка У это корень.
[23:42.240 --> 23:46.240]  Есть ли переход из корня по букве В? Это будет вершина У.
[23:46.240 --> 23:49.240]  Вот как это нужно понимать, это определение.
[23:56.240 --> 23:59.240]  Да, вот действительно непонятно, что такое суффиксная ссылка от корня.
[23:59.360 --> 24:01.360]  Не понятно, как это определить. Это раз.
[24:01.360 --> 24:07.360]  Два, непонятно, как определять переходы из корня по буквам, которых нет в Боре.
[24:08.360 --> 24:11.360]  И здесь есть два подхода.
[24:11.360 --> 24:17.360]  Чуть более формалистский и менее костыльный, есть чуть более костыльный.
[24:18.360 --> 24:24.360]  Считается, что все переходы, что суффиксная ссылка корня, зацикливаются сама на себе.
[24:24.480 --> 24:26.480]  Вот.
[24:26.480 --> 24:29.480]  Ну тогда прямо в том, что вы будете бесконечно по ней петлять.
[24:29.480 --> 24:32.480]  Поэтому обычно вводят фейковую вершину пред корень,
[24:32.480 --> 24:36.480]  такую, что из нее переходы есть по всем буквам алфавитов корень,
[24:36.480 --> 24:38.480]  а суффиксная ссылка корня – это вот эта вершина.
[24:38.480 --> 24:41.480]  Тогда у вас никогда не встретится вторая ветка из этой вершины,
[24:41.480 --> 24:44.480]  потому что из нее всегда есть переход по любой букве.
[24:44.480 --> 24:47.480]  Вот, это самый такой каноничный вариант, как-то можно определить,
[24:47.480 --> 24:50.480]  чтобы не противоречить никаким определениям.
[24:50.600 --> 24:51.600]  Вот.
[24:51.600 --> 24:54.600]  Или можно считать, что если вы пришли в корень и нет перехода по букве,
[24:54.600 --> 24:56.600]  и дописать туда третью ветку в определении,
[24:56.600 --> 25:00.600]  что если у вас в это корень и нет перехода, то останься в корне.
[25:01.600 --> 25:07.600]  Вот. Как делать? Считайте сами, как вам кажется более консистентным.
[25:09.600 --> 25:12.600]  Ну я там обычно делаю, скорее, что завожу просто фейковую вершину у себя в коде,
[25:12.600 --> 25:17.600]  и из нее провожу ребра во все в корень, чтобы не петлять бесконечно.
[25:20.600 --> 25:23.600]  Нет, смотрите, если у меня из корня переход по С,
[25:23.600 --> 25:27.600]  я раскрою по этой ветке, потому что и нет по букве С перехода.
[25:27.600 --> 25:30.600]  А линк от корня – это корень. Я вернулся в себя.
[25:30.600 --> 25:33.600]  Тот же вопрос спрашиваю – то отрут по букве С.
[25:33.600 --> 25:34.600]  Вот.
[25:35.600 --> 25:38.600]  Чтобы выйти из рекурса, нужно либо так, либо так определить.
[25:38.600 --> 25:42.600]  Можно сделать так, чтобы из букв, в которых нет перехода в борь,
[25:42.600 --> 25:45.600]  из корня ввести правильно в корень.
[25:45.600 --> 25:48.600]  То есть тут как бы много вариантов, как пофиксить это на самом деле.
[25:48.720 --> 25:52.720]  И опять же, это просто дописывается вот третьей буквой определения вот сюда.
[25:53.720 --> 25:54.720]  Третьей веткой.
[25:54.720 --> 25:57.720]  Потому что если у вас В – это корень, то отрут по С.
[25:57.720 --> 25:59.720]  Если есть переход, то это переход.
[25:59.720 --> 26:01.720]  Если нет перехода, то это корень.
[26:02.720 --> 26:04.720]  Или дописываются ребра туда.
[26:05.720 --> 26:08.720]  Тут много способов обойти формализм определения.
[26:10.720 --> 26:13.720]  Однако главное так, чтобы в итоге для конечного пользователя
[26:13.720 --> 26:15.720]  все это работало и не зацикливалось вечно.
[26:15.840 --> 26:19.840]  Как именно вы поправите эту коллизию – это уже ваше право абсолютно.
[26:21.840 --> 26:22.840]  Вот.
[26:23.840 --> 26:26.840]  Так, ну теперь нам нужно доказать самое интересное утверждение,
[26:26.840 --> 26:29.840]  на котором будет базироваться построение автомата, собственно.
[26:29.840 --> 26:32.840]  Я хочу посмотреть, что такое линк.
[26:35.840 --> 26:38.840]  Отту из вершины С по букве В.
[26:39.840 --> 26:44.840]  Я хочу показать, что это вот такая вот интересная величина.
[26:45.840 --> 26:56.840]  Утверждение, упражнение, очевидность.
[27:00.840 --> 27:02.840]  Вот, это то, что я хочу, собственно.
[27:02.840 --> 27:03.840]  Если я это делаю, все.
[27:03.840 --> 27:07.840]  Дальше алгоритм построения автомата – написать BFS.
[27:09.840 --> 27:10.840]  Окей.
[27:11.840 --> 27:14.840]  Теперь здесь нам пригодится видимо понять,
[27:14.960 --> 27:16.960]  что значит это вот определение линка.
[27:19.960 --> 27:22.960]  Тот ВС – это переход по вершине С.
[27:24.960 --> 27:26.960]  Вот, и давайте рассмотрим.
[27:28.960 --> 27:29.960]  Так, сейчас.
[27:32.960 --> 27:34.960]  Ну давайте попробуем это доказать как-нибудь.
[27:35.960 --> 27:38.960]  То есть, смотрите, вот это вот у нас вторая ветка определения.
[27:38.960 --> 27:41.960]  Давайте я хочу доказать равенство просто в обратную сторону.
[27:42.080 --> 27:45.080]  То есть, я хочу доказать то, что не это равно этому,
[27:45.080 --> 27:46.080]  а наоборот это равно этому.
[27:47.080 --> 27:49.080]  Да, перейдем из пустого в порожнее.
[27:49.080 --> 27:51.080]  Ну в смысле, тут как бы неважно, что чему равно.
[27:51.080 --> 27:53.080]  Просто у нас здесь есть слева уже вот такая вот штука.
[27:54.080 --> 27:56.080]  Поэтому я хочу переписать это утверждение,
[27:56.080 --> 27:57.080]  что у нас была слева эта штука.
[27:58.080 --> 28:02.080]  Хорошо, давайте определим, что такое тот линк от В по С
[28:02.080 --> 28:04.080]  или линк от ТОС.
[28:05.080 --> 28:10.080]  Давайте напишем сначала линк от ТОС в С.
[28:10.200 --> 28:12.200]  С это что такое?
[28:13.200 --> 28:17.200]  Наибольший суффикс
[28:22.200 --> 28:25.200]  тот ВС, который есть в Боре.
[28:28.200 --> 28:30.200]  Ну просто по определению линк, да?
[28:31.200 --> 28:33.200]  Который заканчивается на букву С при этом.
[28:34.200 --> 28:36.200]  Он заканчивается на букву С.
[28:40.200 --> 28:54.200]  Если его длина хотя бы единичка.
[28:54.200 --> 28:56.200]  Может, если у вас общий суффикс пустой,
[28:56.200 --> 28:58.200]  то он, понятно, из корня у вас будет идти.
[28:59.200 --> 29:00.200]  То есть, случай какой?
[29:00.200 --> 29:05.200]  Можно рассмотреть длину линка тот ВС,
[29:05.200 --> 29:07.200]  если она равна...
[29:07.200 --> 29:09.200]  Так, сейчас, окей, что теперь нужно говорить?
[29:09.320 --> 29:11.320]  Как устроим суффикс?
[29:11.320 --> 29:13.320]  Так, давайте...
[29:15.320 --> 29:17.320]  Здесь нужно рассмотреть две ветки.
[29:18.320 --> 29:21.320]  Первая ветка, что у нас в Боре есть переход по С.
[29:23.320 --> 29:25.320]  Это у нас будет В.
[29:25.320 --> 29:27.320]  Это С.
[29:30.320 --> 29:32.320]  ВС в Боре.
[29:34.320 --> 29:37.320]  Тогда, если тот ВС в Боре,
[29:37.440 --> 29:41.440]  то линк от него, это просто линк от дочерней вершинки.
[29:42.440 --> 29:43.440]  Вот, хорошо.
[29:43.440 --> 29:45.440]  Тогда, что у нас здесь есть?
[29:45.440 --> 29:47.440]  У нас есть какие-то суффиксы.
[29:51.440 --> 29:53.440]  И вот какой-то из них...
[29:53.440 --> 29:55.440]  И, по сути, что делают суффиксные ссылки?
[29:55.440 --> 29:57.440]  Они перебирают все суффиксы, которые есть в Боре.
[29:59.440 --> 30:02.440]  То есть, суффиксная ссылка сначала берет вот этот максимальный суффикс,
[30:02.440 --> 30:04.440]  потом его максимальный суффикс какой-нибудь,
[30:04.440 --> 30:06.440]  этот, который есть в Боре,
[30:06.560 --> 30:08.560]  и так далее, и так далее, и так далее.
[30:08.560 --> 30:10.560]  Оно переберет во вложенности все суффиксы, которые есть в Боре.
[30:12.560 --> 30:14.560]  Аналогично с этой будет строкой.
[30:14.560 --> 30:16.560]  Тоже все суффиксы переберутся.
[30:16.560 --> 30:18.560]  И вы возьмете самый первый суффикс,
[30:18.560 --> 30:20.560]  который можно дописать буквой С.
[30:21.560 --> 30:23.560]  То есть, вот, допустим, ваш...
[30:25.560 --> 30:27.560]  линк от В.
[30:28.560 --> 30:30.560]  Дальше у вас будет еще
[30:32.560 --> 30:34.560]  линк от линк от В.
[30:36.560 --> 30:38.560]  Суффиксная ссылка сюда, суффиксная ссылка сюда.
[30:38.560 --> 30:41.560]  И вы выбираете первую, которую можно буквой С продолжить.
[30:43.560 --> 30:45.560]  Ну, собственно, это есть определение.
[30:46.560 --> 30:47.560]  Вот.
[30:47.560 --> 30:49.560]  Но я утверждаю, что это и есть то, что вам нужно.
[30:50.560 --> 30:53.560]  То есть, мы берем ту от линка от В и С.
[30:53.560 --> 30:56.560]  Смотрим, правда ли, что удастся в первый раз продолжить буквой С.
[30:56.560 --> 30:59.560]  Если нет, значит, такого перехода в Боре нет.
[30:59.560 --> 31:01.560]  Мы пользуемся второй веткой определения.
[31:02.560 --> 31:04.560]  Значит, мы спустимся еще раз
[31:04.680 --> 31:06.680]  и пытаемся продолжить буквой С.
[31:06.680 --> 31:07.640]  И так далее.
[31:07.640 --> 31:09.640]  То есть, по этому вроде это случай очевиден,
[31:09.640 --> 31:11.640]  что это то, что мы именно хотели.
[31:11.640 --> 31:13.640]  Потому что все остальные суффиксы
[31:13.640 --> 31:15.640]  продолжить буквой С нельзя было.
[31:15.640 --> 31:18.640]  Мы перебрали все вот эти кусочки,
[31:18.640 --> 31:20.640]  которые вообще были в Боре.
[31:20.640 --> 31:22.640]  И из них выбрали наибольший,
[31:22.640 --> 31:24.640]  который можно продолжить буквой С.
[31:24.640 --> 31:26.640]  Потому что остальные буквой С架ть было нельзя.
[31:26.640 --> 31:28.640]  Вот.
[31:28.640 --> 31:30.640]  Им перебрали все суффиксы, которые были в Боре.
[31:30.640 --> 31:32.640]  Поэтому здесь все окей.
[31:32.640 --> 31:46.640]  А, так, второй случай. Это ту от vc не вборе, но внезапно логика вообще не меняется, вообще, просто все абсолютно то же самое рассуждение у вас будет проходить.
[31:46.640 --> 32:01.640]  Если у вас ту от vc не вборе, вы сначала посчитаете ту от vc, то есть наибольший суффикс, который можно продолжить буквой c, получите его опять же, но ведь это и есть вот эта вот штука.
[32:01.640 --> 32:07.640]  То, что вы могли продолжить буквой c. Ну и все. То есть это просто два разных взгляда на одну и ту же вершину.
[32:07.640 --> 32:19.640]  То есть если вы пришли к ней вот так вот, то что она есть вборе, и поэтому берете от нее кучу раслинг, либо же вы берете от самой v кучу раслинг, пока вы не смогли продолжить c, то есть абсолютно та же логика.
[32:19.640 --> 32:21.640]  В каких строках мы будем строить?
[32:22.640 --> 32:31.640]  В задачах, на исытых мы будем строить. То есть на то, на какие запросы у нас будут. У нас будет запрос типа, да он множество строк, мы хотим найти все вхождения этого множества строк в текст.
[32:31.640 --> 32:35.640]  Будем строить на этом множестве строк и далее прогонять текст по автомату.
[32:37.640 --> 32:43.640]  Так, давайте теперь, собственно, алгоритм построения автомата. Ваша любимая индукция по длине слова.
[32:44.640 --> 32:49.640]  База индукции. Это слово длина 0, слова длина 1.
[32:54.640 --> 33:11.640]  Так, линк. Вот. Вершины v равно root, где v, длина слова соответствующей буквы v, равна единичке.
[33:12.640 --> 33:19.640]  То есть база индукции, это у нас наш корень, есть какие-то у него дети.
[33:20.640 --> 33:24.640]  Тогда у него база индукции в том, что все суффиксные ссылки ведут в корень.
[33:26.640 --> 33:28.640]  Это первое, что нужно определить.
[33:29.640 --> 33:41.640]  Второе нужно определить, что tun от root по букве c равно по c, если в боре.
[33:45.640 --> 33:52.640]  А теперь, если не в боре. Если в боре, есть ребро из root в c по букве c.
[33:52.640 --> 34:01.640]  Если у нас нет этого перехода, ну давайте просто зациклимся на корне, останемся.
[34:06.640 --> 34:12.640]  То есть база индукции такая, что у нас известны переходы по всем буквам.
[34:13.640 --> 34:20.640]  То есть у нас построена наша дельта для корня по всем буквам, и есть везде суффиксные ссылки.
[34:23.640 --> 34:25.640]  Переход.
[34:31.640 --> 34:33.640]  А стоим в вершине v.
[34:38.640 --> 34:40.640]  Вот мы стоим в вершине v.
[34:43.640 --> 34:45.640]  Мы хотим понять следующее.
[34:45.640 --> 34:52.640]  То есть предположение индукции такое, что к моменту, когда мы рассматриваем вершину v, нам известна ее суффиксная ссылка.
[34:56.640 --> 34:58.640]  Очень интеллектуальное предположение.
[34:59.640 --> 35:05.640]  Стоим в вершине v. Ну база индукции, конечно, когда вы стоите здесь, вам известна ее суффиксная ссылка.
[35:06.640 --> 35:09.640]  Окей, так, стоим в вершине v, что происходит?
[35:10.640 --> 35:24.640]  Определяем tu v. То есть для всех букв мы определяем tu из вершины v.
[35:26.640 --> 35:30.640]  Так как если это в боре, то нам известен переход.
[35:31.640 --> 35:35.640]  А если это не в боре, значит вся суффиксная ссылка куда-то вела.
[35:36.640 --> 35:39.640]  Причем вершину хотя бы на один уровень выше.
[35:42.640 --> 35:45.640]  А из этого следует, что из нее уже все переходы по буквам известны.
[35:46.640 --> 35:48.640]  Потому что она была уже рассмотрена выше.
[35:52.640 --> 35:54.640]  По длине слова.
[35:55.640 --> 35:58.640]  У нас грубая индукция по длине слова сейчас происходит.
[35:59.640 --> 36:01.640]  Просто я формально не выписываю.
[36:02.640 --> 36:04.640]  Определяем tu от v точки.
[36:05.640 --> 36:07.640]  Что? Почему индукцию формально не выписываю?
[36:08.640 --> 36:09.640]  Могу себе позволить.
[36:10.640 --> 36:12.640]  Ну если очень хотите, здесь не очень сложно провести.
[36:13.640 --> 36:16.640]  Вы говорите, окей, хорошо, пусть длина рассмотрена, слово равно k, мы закончились в вершине v.
[36:17.640 --> 36:19.640]  Тогда говорим, что длина линка от v хотя бы k-1.
[36:20.640 --> 36:22.640]  Из этого следует, что про нее уже все известно.
[36:23.640 --> 36:25.640]  А значит, можно вот это вот написать.
[36:26.640 --> 36:28.640]  Доска, к сожалению, не резиновая.
[36:28.640 --> 36:30.640]  Стирать по ней очень сложно.
[36:31.640 --> 36:35.640]  Вот, и для поддержания темпа я не пишу вот это все.
[36:36.640 --> 36:37.640]  Так, определяем tu от v точки.
[36:38.640 --> 36:41.640]  Окей, определили по всем буквам, мы знаем теперь переходы из вершинки v.
[36:42.640 --> 36:43.640]  Что дальше нужно сказать?
[36:44.640 --> 36:48.640]  Ну мы утверждали, что к моменту, когда мы спускаемся в вершину, мы знаем все ссылки от нее.
[36:49.640 --> 36:50.640]  Давайте их определим просто.
[36:50.640 --> 37:14.640]  Определяем tu, ой, наоборот, link от tu от v точка, как вот по этому утверждению tu от link от v точка.
[37:15.640 --> 37:16.640]  Конец, все.
[37:17.640 --> 37:18.640]  Это шаг индукции.
[37:18.640 --> 37:19.640]  Это шаг индукции.
[37:20.640 --> 37:22.640]  То есть, вы для вершины узнали все, что нужно.
[37:23.640 --> 37:29.640]  То есть, к моменту, когда вы придете дальше рассматривать вот эту вершину, вы суффиксную ссылку ее уже знаете.
[37:30.640 --> 37:36.640]  Вот, допустим, у вас здесь есть вершинка tu от link от v сигма.
[37:37.640 --> 37:42.640]  Тогда вы знаете четко, что у вас за этой вершинкой идет вот сюда вот суффиксная ссылка.
[37:43.640 --> 37:45.640]  То есть, к моменту почтения этой вершинки вы знаете ее суффиксную ссылку.
[37:46.640 --> 37:51.640]  И все, это все, что вам нужно знать по сути, благодаря вот этому утверждению.
[37:52.640 --> 37:55.640]  А базовая индукция вам задана на уровне 1, вы знаете суффиксную ссылку вершин.
[37:56.640 --> 37:58.640]  Ну все, весь алгоритм.
[37:59.640 --> 38:01.640]  Теперь у нас в слове идет слово c c c c c.
[38:02.640 --> 38:04.640]  Слово, вот эти c мы можем игнорить.
[38:05.640 --> 38:06.640]  Это нормальная ситуация.
[38:07.640 --> 38:09.640]  Потому что мы же ищем вхождение строк в текст.
[38:10.640 --> 38:11.640]  Вот, поэтому это будет нормально.
[38:12.640 --> 38:13.640]  Еще раз.
[38:14.640 --> 38:18.640]  Ну смотрите, вот вы стоите в вершинке, у вас есть какие-то переходы по бору.
[38:19.640 --> 38:22.640]  Вот у вас переход по букве, который нет в боре.
[38:25.640 --> 38:26.640]  В смысле нет?
[38:27.640 --> 38:30.640]  Вот вы спустились в вершину, вы прочитали.
[38:31.640 --> 38:33.640]  Не знаю, у вас слова есть a b a, a b b.
[38:34.640 --> 38:35.640]  Вам дали слово a b c.
[38:36.640 --> 38:38.640]  Вы вот спустились a b и пытаетесь идти по c.
[38:39.640 --> 38:40.640]  В боре нет перехода по c.
[38:40.640 --> 38:43.640]  Есть только по a из этой вершины и по b из этой вершины.
[38:45.640 --> 38:46.640]  Ну блин, страдаем.
[38:47.640 --> 38:49.640]  У суффиксной ссылки может быть переход по c.
[38:50.640 --> 38:51.640]  Мы так определили ее.
[38:55.640 --> 38:56.640]  В боре.
[38:57.640 --> 38:58.640]  В боре.
[38:59.640 --> 39:00.640]  Там у каких-то других вершин может быть переход по c.
[39:04.640 --> 39:07.640]  В смысле, то от v точка определяем вот так вот.
[39:07.640 --> 39:08.640]  Абсолютно.
[39:09.640 --> 39:10.640]  Только вместо root пишите v.
[39:18.640 --> 39:20.640]  По определению.
[39:28.640 --> 39:30.640]  По определению имеется в виду вот эти вот формулы.
[39:35.640 --> 39:36.640]  OK.
[39:37.640 --> 39:38.640]  Ну все, теперь давайте...
[39:39.640 --> 39:41.640]  Собственно, как этот алгоритм теперь реализовывать?
[39:42.640 --> 39:46.640]  Какой обход у нас обходит в вершины графа в порядке увеличения достиженности?
[39:49.640 --> 39:50.640]  BFS?
[39:51.640 --> 39:52.640]  Не DFS, да.
[39:53.640 --> 39:55.640]  Ну DFS, он, типа, смотрел вершинку.
[39:56.640 --> 39:58.640]  Он не рассмотрит сначала все вершины на одном уровне, потом все вершины на втором.
[40:01.640 --> 40:02.640]  И что?
[40:03.640 --> 40:04.640]  Нам нужно к моменту, когда мы рассмотрели...
[40:05.640 --> 40:07.640]  Когда мы рассматриваем эту вершину, рассмотреть все вершины выше.
[40:08.640 --> 40:10.640]  Потому что у нее есть суффиксная ссылка, которая куда-то там идет.
[40:12.640 --> 40:15.640]  Понятное дело, что это можно писать просто ленивой рекурсией.
[40:16.640 --> 40:20.640]  Просто вы хотите посчитать тот vc какой-то, вообще произвольный вершины v по букве c.
[40:21.640 --> 40:24.640]  Вы просто берете эту вершину и считаете просто рекурсивно.
[40:26.640 --> 40:27.640]  И это будет работать.
[40:28.640 --> 40:29.640]  Быть может не эффективно, но будет работать.
[40:30.640 --> 40:32.640]  А если вы будете запоминать результат, то оно же активно работать будет.
[40:33.640 --> 40:34.640]  Однако это удобно строить BFS.
[40:35.640 --> 40:37.640]  То есть вы обозначили базу, вот она.
[40:38.640 --> 40:41.640]  И дальше у вас BFS просто идет, берет вершинку очередную,
[40:42.640 --> 40:45.640]  делает форум по букве, определяет tu и линка tu.
[40:46.640 --> 40:49.640]  Все, то есть алгоритм BFS, и вам нужно эту штуку прописать.
[40:50.640 --> 40:52.640]  Как вы знаете, BFS определяется с чем?
[40:53.640 --> 40:54.640]  Правильно, визитором.
[40:55.640 --> 40:56.640]  Затравочка на успех.
[40:57.640 --> 40:59.640]  Сейчас я напишу второе определение.
[40:59.640 --> 41:02.640]  И понятно будет, что нужно будет просто переиспользовать его.
[41:03.640 --> 41:04.640]  Так, следующее определение.
[41:05.640 --> 41:07.640]  Сжатая суффиксная ссылка.
[41:15.640 --> 41:16.640]  Сжатая суффиксная ссылка.
[41:18.640 --> 41:19.640]  Ну как мы ее обозначим?
[41:20.640 --> 41:22.640]  Если у нас была линк, давайте Compressed.
[41:23.640 --> 41:25.640]  Compressed сжатый, поэтому давайте Comp будет от f.
[41:29.640 --> 41:30.640]  Нет, это долго.
[41:31.640 --> 41:35.640]  Понятно, что в коде у вас будет Compressed суффикс линк, если что.
[41:36.640 --> 41:37.640]  Какой линк?
[41:38.640 --> 41:39.640]  Что?
[41:40.640 --> 41:41.640]  У меня это Comp будет.
[41:42.640 --> 41:44.640]  Я уже настроил мозг на Comp.
[41:46.640 --> 41:47.640]  А, тогда как она определяется?
[41:48.640 --> 41:49.640]  Comp от v.
[41:49.640 --> 42:09.640]  Линк от v, если линк от v – терминал, терминал или корень.
[42:13.640 --> 42:14.640]  И второй вариант.
[42:20.640 --> 42:21.640]  Иначе.
[42:27.640 --> 42:31.640]  Кому понятно, как считать Comp от v в этом куске кода?
[42:37.640 --> 42:38.640]  Нет.
[42:40.640 --> 42:43.640]  К моменту вычисления Comp от v, вы знаете, кто такой линк от v?
[42:44.640 --> 42:46.640]  Значит, вы можете знать корень это или терминал.
[42:46.640 --> 42:48.640]  Если то и то, вы заканчиваете вычисление.
[42:49.640 --> 42:55.640]  Иначе вы берете Comp от линк от v, но на момент вычисления вот этой штуки она у вас уже известна,
[42:56.640 --> 42:57.640]  потому что линк от v выше была.
[42:58.640 --> 43:00.640]  Поэтому у вас не будет второго уровня рекурсии.
[43:01.640 --> 43:03.640]  Вот, поэтому эта штука тоже быстро считается.
[43:10.640 --> 43:11.640]  Вот эту?
[43:12.640 --> 43:14.640]  Так нет, вы уже знаете линк от v.
[43:15.640 --> 43:17.640]  Этот штуку вы уже знаете на этот момент времени.
[43:18.640 --> 43:19.640]  Да, мы строим линк для детей.
[43:20.640 --> 43:23.640]  То есть вы стоите в вершинке, вы для всех сигма перебираете детей,
[43:24.640 --> 43:26.640]  и когда берете ребенка, считаете его суть на ссылку тут же.
[43:27.640 --> 43:28.640]  Это делаем к BFS, да?
[43:29.640 --> 43:30.640]  Да, BFS это делает.
[43:31.640 --> 43:32.640]  То есть BFS за одну итерацию вот это вот вычисляет.
[43:33.640 --> 43:36.640]  То есть итерация BFS – это фор по буквам афабита из вершины.
[43:37.640 --> 43:41.640]  И он считает для каждой буквы эту штуку и эту штуку.
[43:41.640 --> 43:45.640]  Ну еще потом будет в конце, после всех букв, компот v еще считать.
[43:46.640 --> 43:49.640]  А нет, для каждой ребенка компот v считать он будет.
[43:50.640 --> 43:51.640]  Вот, так же как и линк.
[43:53.640 --> 43:55.640]  Ну, он считается абсолютно так же, как вот это вот.
[43:56.640 --> 43:59.640]  Потому что либо вы смотрите в линк от v, если это терминал, то все ок.
[44:00.640 --> 44:03.640]  Если не терминал, значит вы уже знаете, кто такой компот линк от v на этом моменте.
[44:04.640 --> 44:09.640]  А, ну очевидно, что здесь для вершин уровня 1, для базы индукции,
[44:09.640 --> 44:11.640]  жар за ссылку на ссылку – это корень.
[44:12.640 --> 44:14.640]  Просто по определению той штуки подходит.
[44:15.640 --> 44:16.640]  Давайте определение нарисуем.
[44:18.640 --> 44:20.640]  У нас будут вот такие вот строки.
[44:30.640 --> 44:32.640]  То есть у нас будет одна строка C, переход из корня.
[44:33.640 --> 44:34.640]  И все.
[44:35.640 --> 44:37.640]  То есть у нас африт, абс, если что.
[44:37.640 --> 44:39.640]  То есть у нас африт, абс, если что.
[44:40.640 --> 44:41.640]  Так, тогда у меня что получается.
[44:42.640 --> 44:46.640]  Есть корень, то есть переход по C такой, отщепенец.
[44:47.640 --> 44:48.640]  Есть все остальное.
[44:50.640 --> 44:51.640]  То есть по букве А.
[44:52.640 --> 44:54.640]  У него есть АБАБ.
[45:04.640 --> 45:06.640]  Дальше есть БАБАБ.
[45:07.640 --> 45:08.640]  Да.
[45:17.640 --> 45:20.640]  Я хочу посчитать ту из этой вершины по букве С.
[45:23.640 --> 45:25.640]  Давайте просто весь алгоритм вообще проведу, да и все.
[45:26.640 --> 45:28.640]  Только без сжатых ссылок, иначе просто загромодится рисунок.
[45:34.640 --> 45:36.640]  Так, дальше. Иду из этой вершины, иду по всем буквам.
[45:37.640 --> 45:38.640]  Окей, ту из этой буквы по Б.
[45:39.640 --> 45:40.640]  Так, и по букве А сначала, да.
[45:41.640 --> 45:42.640]  Из этой вершины хочу по букве А пройти.
[45:43.640 --> 45:44.640]  Смотрю, правда ли это?
[45:45.640 --> 45:46.640]  Хорошо, понимаю, что я не могу пройти по букве А.
[45:47.640 --> 45:50.640]  Иду в суффиксную ссылку, иду по букве А, все ок.
[45:51.640 --> 45:54.640]  Поэтому суффиксная ссылка отсюда по букве А сам в себя перешел.
[45:55.640 --> 45:56.640]  И это нормально.
[45:57.640 --> 46:01.640]  Ну просто по всем определениям схлопывается, что мы можем перейти сами в себя.
[46:02.640 --> 46:03.640]  Это нормально.
[46:04.640 --> 46:06.640]  Окей, хорошо, по букве Б перехожу.
[46:07.640 --> 46:09.640]  Смотрю, Б я могу прочитать в Боре, да?
[46:10.640 --> 46:11.640]  Чего не так? Я беру сначала суффиксную ссылку.
[46:12.640 --> 46:14.640]  Потом смотрю, можно ли из нее пройти по Б? Ну да, могу.
[46:15.640 --> 46:17.640]  А вы сами в себя не рисуете, или вы его по букве А не рисуете?
[46:18.640 --> 46:19.640]  Это переход по букве А.
[46:20.640 --> 46:26.640]  Нет, он, короче говоря, его в памяти и в коде у вас будет использоваться как переход по букве А здесь.
[46:27.640 --> 46:28.640]  Если вы про это.
[46:29.640 --> 46:30.640]  Переход по букве С отсюда, это кто?
[46:30.640 --> 46:31.640]  Это суффиксная ссылка.
[46:32.640 --> 46:33.640]  Потому что там перехода нет по букве С.
[46:34.640 --> 46:35.640]  Переход по букве С.
[46:36.640 --> 46:37.640]  Поэтому переход по букве С вообще вот сюда вот.
[46:38.640 --> 46:40.640]  По сути вы получите полный автомат.
[46:41.640 --> 46:43.640]  С каждой большинкой по каждой букве перехода.
[46:44.640 --> 46:45.640]  Б, Д, К, да.
[46:46.640 --> 46:47.640]  Вот, ну окей.
[46:50.640 --> 46:52.640]  Ну такое себе.
[46:53.640 --> 46:54.640]  Такая себе минимальность, если честно.
[46:55.640 --> 46:56.640]  Потому что здесь не понятно, что такое минимальность.
[46:57.640 --> 46:59.640]  Ну точнее понятно, что такое минимальность здесь.
[47:00.640 --> 47:01.640]  И я не уверен, что он минимален.
[47:03.640 --> 47:04.640]  Ладно.
[47:05.640 --> 47:07.640]  Можно теперь я не буду рисовать переходы, которые не в Боре.
[47:08.640 --> 47:09.640]  Потому что они понятно, как вычисляются.
[47:10.640 --> 47:11.640]  Я просто суффиксные ссылки порисую.
[47:13.640 --> 47:14.640]  Так.
[47:15.640 --> 47:17.640]  Из этой вершины мы вычислили для всех детей.
[47:19.640 --> 47:20.640]  Так, теперь для этой вершины считаем.
[47:23.640 --> 47:25.640]  Точнее вот для вот этой вершины для всех детей считаем.
[47:26.640 --> 47:27.640]  А.
[47:28.640 --> 47:29.640]  Смотрим, кто суффиксная ссылка.
[47:30.640 --> 47:31.640]  По букве А это сюда.
[47:32.640 --> 47:33.640]  Суффиксная ссылка этой вершины это вот это вот.
[47:34.640 --> 47:35.640]  По остальным детям перехода нет.
[47:36.640 --> 47:37.640]  Однако, если бы я захотел отсюда перейти по букве Б.
[47:38.640 --> 47:41.640]  Я бы поднялся бы вверх и перешел по букве Б в себя же.
[47:44.640 --> 47:45.640]  Так.
[47:46.640 --> 47:48.640]  Ну по букве С я бы перешел бы сюда аналогично.
[47:49.640 --> 47:50.640]  Так, дальше.
[47:51.640 --> 47:52.640]  Вот эта вершина.
[47:53.640 --> 47:54.640]  Кто не суффиксная ссылка?
[47:54.640 --> 47:55.640]  Это ту.
[47:56.640 --> 47:57.640]  Из этой вершины по букве А.
[47:58.640 --> 47:59.640]  Суффиксную ссылку.
[48:00.640 --> 48:01.640]  По букве А. Переход.
[48:02.640 --> 48:03.640]  Вот оно.
[48:04.640 --> 48:05.640]  Ну здесь будет вот так вот сразу скажу.
[48:06.640 --> 48:07.640]  Здесь будет.
[48:08.640 --> 48:09.640]  Пам-а-б.
[48:10.640 --> 48:11.640]  Здесь будет вот сюда вот переход.
[48:14.640 --> 48:15.640]  Вот они суффиксные ссылки.
[48:16.640 --> 48:20.640]  Да, как видите, если у вас есть какие-то общие ветки, они будут вот по ним суффиксные ссылки параллельно так идут.
[48:21.640 --> 48:22.640]  Верно.
[48:24.640 --> 48:30.640]  А, давайте вот так напишем.
[48:31.640 --> 48:33.640]  Если не в Боре, то мы просто линк от нее не считаем.
[48:34.640 --> 48:35.640]  Потому что это бессмысленное занятие.
[48:36.640 --> 48:37.640]  У нас совершенно нет в целом в Боре.
[48:38.640 --> 48:41.640]  Если есть в Боре, вы хотите посчитать вот эту вот величину.
[48:42.640 --> 48:43.640]  Она вам неизвестна.
[48:44.640 --> 48:45.640]  Так, ладно.
[48:46.640 --> 48:49.640]  Давайте решим задачу собственно теперь.
[48:49.640 --> 48:51.640]  Вот такой набор строк у меня очень классный.
[48:52.640 --> 48:54.640]  А, Б, А, Б, Б, А.
[48:57.640 --> 49:02.640]  Он специально взят попроще, но при этом он очень неприятный бы с точки зрения анализа сейчас.
[49:03.640 --> 49:04.640]  Да.
[49:05.640 --> 49:07.640]  Чтобы разобрать все возможные варианты.
[49:08.640 --> 49:11.640]  Ну, кроме, естественно, тех, где почему-то приятнее.
[49:12.640 --> 49:13.640]  Ну, в общем, я не знаю.
[49:13.640 --> 49:14.640]  Да.
[49:15.640 --> 49:16.640]  Чтобы разобрать все возможные варианты.
[49:17.640 --> 49:21.640]  Ну, кроме, естественно, тех, где почему-то приходит не в корень суффиксной ссылки.
[49:32.640 --> 49:33.640]  Чего?
[49:34.640 --> 49:35.640]  Это Бор.
[49:43.640 --> 49:44.640]  Нет.
[49:47.640 --> 49:48.640]  Здесь все вершины кроме корни терминальные.
[49:49.640 --> 49:50.640]  Может, еще добавим?
[49:51.640 --> 49:52.640]  Не.
[49:53.640 --> 49:56.640]  Кто добавляет Epsilon в язык, тот вообще уже делает совсем какие-то странные вещи.
[49:57.640 --> 49:58.640]  Надо еще доллары поставить.
[49:59.640 --> 50:00.640]  Нет, это будет в следующий раз.
[50:01.640 --> 50:04.640]  Не, ладно, в следующий раз даже долларов не будет на самом деле.
[50:05.640 --> 50:06.640]  Евро будет?
[50:07.640 --> 50:08.640]  Нет.
[50:09.640 --> 50:10.640]  У нас не будет в целом значков валют.
[50:11.640 --> 50:12.640]  Нам не понадобится.
[50:13.640 --> 50:14.640]  Так.
[50:15.640 --> 50:17.640]  Так, давайте сразу проиндексирую слова.
[50:19.640 --> 50:21.640]  И выпишу сразу возле каждого терминала.
[50:22.640 --> 50:24.640]  У меня будет стоять индекс, в какой строке он соответствует.
[50:35.640 --> 50:37.640]  Очевидно, что у меня может быть много строк в наборе одинаковых.
[50:38.640 --> 50:39.640]  Может быть, много индексов в терминале.
[50:40.640 --> 50:42.640]  Но я пока что опущу, чтобы просто он один.
[50:44.640 --> 50:45.640]  Вот это не терминал.
[50:46.640 --> 50:49.640]  Это не номерация совершенно, это строк, который у нас есть в наборе.
[50:50.640 --> 50:51.640]  Окей, так, что теперь?
[50:52.640 --> 50:54.640]  Сразу строим суффиксные ссылки.
[50:58.640 --> 50:59.640]  Так.
[51:10.640 --> 51:11.640]  Теперь я хочу прогнать текст.
[51:13.640 --> 51:27.640]  И хочу найти все вхождения всех строк из набора в этот текст.
[51:29.640 --> 51:37.640]  Да, сразу скажу, этот пример был специально нарисован, чтобы все терминалы были, кроме корня, чтобы у меня сжатые суффиксные ссылки совпадали с обычными.
[51:38.640 --> 51:39.640]  Вот это важно.
[51:40.640 --> 51:41.640]  Здесь будет сейчас.
[51:42.640 --> 51:47.640]  Потому что, если у меня не было B, например, у меня была сжатая суффиксная ссылка отсюда, я отсюда ввел бы сразу в корень.
[51:48.640 --> 51:49.640]  Давайте B уберем.
[51:56.640 --> 51:58.640]  Ну, и буду считать, что сжатая суффиксная ссылка у меня уже посчитана.
[51:59.640 --> 52:01.640]  Просто их не буду рисовать, иначе рисунок станет совсем огромным.
[52:03.640 --> 52:05.640]  У меня нет просто второго цвета.
[52:07.640 --> 52:08.640]  Что?
[52:09.640 --> 52:10.640]  Как у нас старебра?
[52:12.640 --> 52:13.640]  Ну, я не очень хочу это делать.
[52:14.640 --> 52:16.640]  Ну, давайте вот так вот.
[52:27.640 --> 52:28.640]  Это сжатые суффиксные ссылки.
[52:29.640 --> 52:30.640]  Да, я убрал B.
[52:33.640 --> 52:34.640]  Ну да.
[52:35.640 --> 52:36.640]  Индекс я сдвигать не буду, сразу говорю.
[52:37.640 --> 52:40.640]  На этот развод вам меня уже не развести на такое.
[52:41.640 --> 52:43.640]  Окей, теперь я запускаю текст.
[52:44.640 --> 52:46.640]  Я просто текстом иду по автомату.
[52:47.640 --> 52:57.640]  И каждый раз, когда я совершаю переход, я прохожусь из вершины по всем сжатым суффиксам вплоть до корня и выписываю ответы.
[52:58.640 --> 52:59.640]  Как это понимать?
[53:00.640 --> 53:01.640]  Поехали.
[53:02.640 --> 53:03.640]  По букве A.
[53:04.640 --> 53:05.640]  Иду из корня всегда.
[53:06.640 --> 53:07.640]  Смотрю. По букве A.
[53:08.640 --> 53:09.640]  Пришел в терминал.
[53:10.640 --> 53:12.640]  Который соответствует вершине 1.
[53:13.640 --> 53:16.640]  Выписываю. Вхождение соответствует позиции 1.
[53:17.640 --> 53:20.640]  Прыгаю по сжатой суффиксной ссылке.
[53:21.640 --> 53:23.640]  Пришел в корень. Закончили.
[53:24.640 --> 53:26.640]  Иду дальше. Следующая буква B.
[53:27.640 --> 53:30.640]  Вижу A, B. Пришел в терминал номер 3.
[53:31.640 --> 53:33.640]  Говорю, значит, что для третьего появилось...
[53:34.640 --> 53:37.640]  Дайте я буду читать окончание вхождения. Понятно, как начало посчитать для строки.
[53:38.640 --> 53:39.640]  Вы должны просто вычесть длину строки.
[53:40.640 --> 53:41.640]  Два.
[53:42.640 --> 53:43.640]  То есть вот оно.
[53:44.640 --> 53:45.640]  1, 2, A, B входят.
[53:46.640 --> 53:48.640]  Позиция окончания вхождения равна 2.
[53:50.640 --> 53:52.640]  Прыгаю по сжатой суффиксной ссылке. Это корень.
[53:54.640 --> 53:56.640]  Все. Дальше нахожусь снова здесь.
[53:57.640 --> 53:58.640]  Иду по букве C.
[53:59.640 --> 54:02.640]  Спрашиваю, кто такой ту из этой вершины по букве C?
[54:03.640 --> 54:05.640]  До этого там пропрыгал по суффиксным ссылкам.
[54:06.640 --> 54:07.640]  Посмотрел что-нибудь перехода по букве C.
[54:08.640 --> 54:09.640]  И остался в корне.
[54:10.640 --> 54:13.640]  Прыжок по букве C завершен в корне.
[54:14.640 --> 54:17.640]  И пытаюсь пройти из него снова по сжатым ссылкам.
[54:18.640 --> 54:19.640]  Но их нет.
[54:20.640 --> 54:22.640]  Поэтому новых вхождений я не добавил.
[54:23.640 --> 54:24.640]  Я не пришел в терминал.
[54:25.640 --> 54:28.640]  И ни одна сжатая суффиксная ссылка не привела меня в терминал.
[54:29.640 --> 54:32.640]  Поэтому новых вхождений, когда добавил букву C, не нашлось.
[54:33.640 --> 54:34.640]  Как это можно понимать?
[54:35.640 --> 54:38.640]  Как вы знаете, каждая подстрока это суффикс какого-то префикса.
[54:39.640 --> 54:42.640]  Когда мы рассмотрели какое-то начало, то есть прошли по автомату им,
[54:43.640 --> 54:49.640]  мы теперь смотрим, какие есть суффиксы у текущего вхождения, которые добавились.
[54:50.640 --> 54:54.640]  То есть, помните, у вас на семинаре была задача, где нужно было посчитать число подстрок с помощью префикс-функции.
[54:55.640 --> 55:00.640]  И там мы рассматривали с вами, что вы сначала берете строку, затем записываете к ней символ.
[55:01.640 --> 55:02.640]  И что дальше вы делали?
[55:03.640 --> 55:07.640]  Мы брали и искали суффикс максимальной длины, который все еще входит.
[55:08.640 --> 55:19.640]  Здесь вы делаете точно так же, так как вы перебираете все суффиксы, которые могут входить как куски этих штук, как суффиксы этих строк.
[55:20.640 --> 55:21.640]  Просто перебирайте, возможно, все эти строки.
[55:22.640 --> 55:28.640]  А так как вы прыгаете только по сжатым суффикам ссылкам, вы каждый раз либо увеличиваете ответ на 1, потому что вы прыгаете в терминал,
[55:28.640 --> 55:34.640]  либо же, что делаете, правильно, прыгаете в корень этой сжатой суффиксной ссылкой.
[55:35.640 --> 55:40.640]  Пока что это рассуждение мы оставим в воздухе, потом это ружье выстрелит обязательно.
[55:41.640 --> 55:42.640]  А потом будем читать асимптотику.
[55:43.640 --> 55:45.640]  А пока мы перешли по букве С.
[55:46.640 --> 55:47.640]  Вот мы здесь находимся.
[55:48.640 --> 55:50.640]  Дальше считываем еще одну букву С.
[55:51.640 --> 55:54.640]  Ту из корня по С снова в корня нас зацикливают.
[55:55.640 --> 55:57.640]  Снова пропрыгали по терминалу, ничего не нашли.
[55:58.640 --> 56:03.640]  Но если бы здесь был Эпсилон в наборе, у вас корень был бы терминальным,
[56:04.640 --> 56:10.640]  и вы бы каждый раз своими суффиксными сжатыми ссылками допрыгивали бы до корня,
[56:11.640 --> 56:17.640]  и каждый раз должны были бы учитывать Эпсилон в ответе, потому что Эпсилон входит ровно в каждой позиции.
[56:19.640 --> 56:21.640]  Ну это только для Эпсилон, для остальных еще сложно.
[56:22.640 --> 56:24.640]  Так, окей, вот мы читали А, Б, Ц, С.
[56:25.640 --> 56:26.640]  Читаем букву С.
[56:26.640 --> 56:27.640]  Чуть букву Б, сори.
[56:28.640 --> 56:29.640]  Так, пришли сюда.
[56:31.640 --> 56:36.640]  Прыгаем из нее по сжатым суффиксным ссылкам, припрыгали в корень, нет вхождения новых.
[56:37.640 --> 56:38.640]  Пошли дальше, Б, Б.
[56:40.640 --> 56:42.640]  Мы находились здесь, идем сюда.
[56:44.640 --> 56:46.640]  Окей, новое вхождение Б, Б.
[56:47.640 --> 56:48.640]  У шестого появилось новое вхождение, что это?
[56:49.640 --> 56:50.640]  1, 2, 3, 4, 5, 6.
[56:50.640 --> 56:57.640]  То есть, прыгаем по сжатым суффиксным ссылкам, переходим в корень.
[56:58.640 --> 56:59.640]  Он не терминальный, новых вхождений нет.
[57:02.640 --> 57:03.640]  Дальше.
[57:05.640 --> 57:06.640]  Так, па-па-пам.
[57:07.640 --> 57:08.640]  Буква А.
[57:09.640 --> 57:10.640]  Кто такой?
[57:11.640 --> 57:13.640]  Ту из буквы Б по букве А.
[57:14.640 --> 57:15.640]  Суффиксную ссылку.
[57:16.640 --> 57:18.640]  Хоба оказались здесь.
[57:20.640 --> 57:27.640]  Вот вы здесь пытаетесь перейти по букве А, ее нет.
[57:28.640 --> 57:31.640]  Тогда по формуле вы должны перейти по букве А из нее.
[57:32.640 --> 57:33.640]  Такой переход в Боре есть.
[57:36.640 --> 57:38.640]  Потому что в формуле по обычной ссылке переходят.
[57:39.640 --> 57:42.640]  Сжатая ссылка, она просто нужна для подсчета ответов будет нам.
[57:43.640 --> 57:44.640]  Больше не для чего.
[57:45.640 --> 57:46.640]  Она не нужна как конструктив автомату.
[57:47.640 --> 57:48.640]  Но она нужна для быстрого подсчета ответов.
[57:50.640 --> 57:51.640]  Так, раз-два.
[57:52.640 --> 57:53.640]  Пришли.
[57:54.640 --> 57:55.640]  Смотрим.
[57:56.640 --> 57:57.640]  Ага, вхождение 4.
[57:58.640 --> 57:59.640]  У нее новый индекс вхождения.
[58:00.640 --> 58:03.640]  Это 4, 6, 8, 7.
[58:04.640 --> 58:06.640]  Это мы одну А прочитали пока что.
[58:07.640 --> 58:08.640]  У нее 7 вхождения.
[58:09.640 --> 58:10.640]  Дальше.
[58:11.640 --> 58:12.640]  Прыгаем по сжатой суффиксной ссылке.
[58:13.640 --> 58:14.640]  Опа, вхождение еще одно.
[58:15.640 --> 58:17.640]  У днички добавилось вхождение в 7.
[58:17.640 --> 58:18.640]  Прыгаем.
[58:19.640 --> 58:20.640]  Прыгаем по сжатой суффиксной ссылке вновь.
[58:21.640 --> 58:22.640]  Корень и терминал закончили путешествие.
[58:23.640 --> 58:24.640]  Окей, находились здесь.
[58:25.640 --> 58:26.640]  Снова читаем букву А.
[58:27.640 --> 58:28.640]  Смотрим, кто такой ту отсюда по А.
[58:29.640 --> 58:30.640]  Хоба.
[58:35.640 --> 58:36.640]  Запускаем.
[58:37.640 --> 58:38.640]  Пятое.
[58:39.640 --> 58:40.640]  Значит, пятое входит в позиции 8.
[58:41.640 --> 58:42.640]  Дальше.
[58:43.640 --> 58:44.640]  Прыжок по сжатой суффиксной ссылке.
[58:45.640 --> 58:46.640]  Первое входит в позиции 8.
[58:47.640 --> 58:48.640]  Снова прыжок по сжатой суффиксной ссылке.
[58:49.640 --> 58:50.640]  Закончили.
[58:51.640 --> 58:52.640]  Переход по букве Б.
[58:53.640 --> 58:54.640]  Окей.
[58:55.640 --> 58:56.640]  Хоба.
[58:57.640 --> 58:58.640]  Пришли снова сюда.
[58:59.640 --> 59:00.640]  Оказались здесь.
[59:01.640 --> 59:02.640]  Третье еще входит в позиции 9.
[59:04.640 --> 59:05.640]  Прыгаем по суффиксной ссылке.
[59:06.640 --> 59:07.640]  Расчет окончен.
[59:08.640 --> 59:09.640]  Это ответ.
[59:10.640 --> 59:11.640]  Других подстрок нет.
[59:12.640 --> 59:14.640]  Вхождение, точнее вот этих строк в текст.
[59:15.640 --> 59:16.640]  Нет.
[59:17.640 --> 59:23.640]  Чтобы быстро проскакивать слои суффиксных ссылок.
[59:24.640 --> 59:26.640]  Потому что в общем случае суффиксная ссылка может вести не в терминал.
[59:27.640 --> 59:28.640]  То есть раз не терминал.
[59:29.640 --> 59:30.640]  Дальше два не терминал, три не терминал.
[59:31.640 --> 59:32.640]  Это огромные пути суффиксных ссылок могут быть.
[59:33.640 --> 59:35.640]  Такого не очень хочется.
[59:36.640 --> 59:37.640]  Все-таки хочется сразу прыгать и учить.
[59:38.640 --> 59:39.640]  Вот ответ новый.
[59:40.640 --> 59:41.640]  Поэтому нужно сжатые суффиксные ссылки.
[59:42.640 --> 59:43.640]  Поэтому время построения.
[59:44.640 --> 59:45.640]  То есть за сколько мы вообще решаем задачу?
[59:45.640 --> 59:46.640]  Восьми.
[59:47.640 --> 59:48.640]  Автомата.
[59:51.640 --> 59:53.640]  Я сейчас выпущу все составляющие.
[01:00:00.640 --> 01:00:01.640]  Дальше.
[01:00:05.640 --> 01:00:06.640]  Время переходов.
[01:00:12.640 --> 01:00:14.640]  От модуль Т если у вас переход за единичку делается по букве.
[01:00:15.640 --> 01:00:18.760]  Под словами «переход» под называется именно чисто
[01:00:18.760 --> 01:00:22.660]  взятие tu от вершины и буквы, потому что вы все время ходите
[01:00:22.660 --> 01:00:25.240]  по функции tu здесь, именно поэтому она вам была нужна.
[01:00:25.240 --> 01:00:29.200]  Так у вас уже все тушки посчитаны, у вас переход
[01:00:29.200 --> 01:00:32.000]  за единицу делается, поэтому здесь длина текста.
[01:00:32.000 --> 01:00:35.880]  И смотрите, что мы с вами еще делали.
[01:00:35.880 --> 01:00:38.120]  Мы с вами еще прыгали по суффиксным ссылкам.
[01:00:38.120 --> 01:00:39.120]  Зачем?
[01:00:39.120 --> 01:00:44.280]  Чтобы найти все возможные слова, которые заканчиваются
[01:00:44.280 --> 01:00:46.160]  при прочтении текущего префикса.
[01:00:46.160 --> 01:00:49.840]  Потому что у нас могут входить это слово, это слово, это
[01:00:49.840 --> 01:00:50.840]  слово, входить.
[01:00:50.840 --> 01:00:52.600]  И нам нужно их все собрать.
[01:00:52.600 --> 01:00:56.000]  Но прием может быть том, что у нас может ходить, например,
[01:00:56.000 --> 01:00:59.360]  вот такое вот слово, вот такое вот и вот такое вот.
[01:00:59.360 --> 01:01:02.480]  И зачем мне по суффиксным ссылкам тут по одному прыгать?
[01:01:02.480 --> 01:01:04.880]  Ну, допустим, как-то так набор строк устроен, чтобы
[01:01:04.880 --> 01:01:05.880]  я по одному везде прыгать наверх.
[01:01:05.880 --> 01:01:10.760]  Если я могу сразу прыгать по сжатой суффиксной ссылке
[01:01:10.760 --> 01:01:14.120]  и либо увеличивать ответ на единицу, либо прилетать
[01:01:14.120 --> 01:01:15.120]  в корень.
[01:01:15.120 --> 01:01:24.880]  Поэтому время прыжков, я утверждаю, что оно ограничено.
[01:01:24.880 --> 01:01:30.040]  Суммарное число прыжков давайте, число прыжков по
[01:01:30.040 --> 01:01:38.840]  суффиксным ссылкам не превосходит два на суммарное число
[01:01:38.840 --> 01:01:39.840]  входения.
[01:01:39.840 --> 01:01:48.200]  То есть вот анс, где анс – это суммарное число входения.
[01:01:48.200 --> 01:01:50.200]  Вот какой-то алгоритм, который зависит именно от числа
[01:01:50.200 --> 01:01:51.200]  входения.
[01:01:51.200 --> 01:01:54.120]  К сожалению, да, здесь такое есть.
[01:01:54.120 --> 01:02:05.440]  Ну вот, то есть у нас везде линия по сути, здесь линия
[01:02:05.440 --> 01:02:11.480]  от суммарного размера, здесь линия от длины текста
[01:02:11.480 --> 01:02:13.400]  и здесь линия от длины ответа.
[01:02:13.400 --> 01:02:16.400]  Как мы могли решать эту сдачу по-другому?
[01:02:16.400 --> 01:02:18.760]  Просто для каждой строки найти все вхождения в текст
[01:02:18.760 --> 01:02:20.440]  путем алгоритмов с прошлой лекции.
[01:02:20.440 --> 01:02:24.680]  В чем проблема, у вас получается размер множества на длину
[01:02:24.680 --> 01:02:26.800]  текста во симптотике, потому что вам каждый раз придется
[01:02:26.800 --> 01:02:27.800]  заново перестраивать все.
[01:02:27.800 --> 01:02:33.160]  Этот алгоритм этим не страдает.
[01:02:33.240 --> 01:02:34.240]  Боль-то он детерминированный.
[01:02:34.240 --> 01:02:43.720]  То есть с чем суть?
[01:02:43.720 --> 01:02:48.800]  Суть в том, что мы каждый раз при переходе в автомате
[01:02:48.800 --> 01:02:51.960]  выбираем такой путь, который соответствует самому длинному
[01:02:51.960 --> 01:02:57.440]  суффиксу, который можно встретить как кусочек этих
[01:02:57.440 --> 01:02:58.440]  строк.
[01:02:58.440 --> 01:02:59.640]  Как префикс какой-то из этих строк.
[01:02:59.640 --> 01:03:03.120]  В некотором плане это обобщенная префикс-функция.
[01:03:03.120 --> 01:03:04.120]  Почему?
[01:03:04.120 --> 01:03:07.400]  Потому что там у вас было каждый раз супрефиксы вы
[01:03:07.400 --> 01:03:08.400]  прыгали.
[01:03:08.400 --> 01:03:14.320]  А здесь вы прыгаете из вершинки в наибольший префикс,
[01:03:14.320 --> 01:03:15.320]  который существует.
[01:03:15.320 --> 01:03:20.920]  То есть вы берете вот этот кусок пути и ищете суффикс,
[01:03:20.920 --> 01:03:22.400]  который может быть префиксом во всех строках.
[01:03:22.400 --> 01:03:27.160]  И в качестве примера здесь нужно проиллюстрировать
[01:03:27.160 --> 01:03:30.600]  ахакарасик для одной строки и его мощи в префикс-функции.
[01:03:31.600 --> 01:03:33.200]  Так, для строки абатсаба рисуем.
[01:03:33.200 --> 01:03:42.520]  Как вы можете догадаться, вор будет гирляндой.
[01:03:42.520 --> 01:03:57.800]  Абатсаба, вот он.
[01:03:57.800 --> 01:04:03.720]  Может было горизонтально нарисовать, но уже ладно.
[01:04:03.720 --> 01:04:07.800]  Так, суффиксная ссылка для этой понятно сюда.
[01:04:07.800 --> 01:04:10.640]  Суффиксная ссылка для этой штуки.
[01:04:10.760 --> 01:04:12.960]  Смотрим из этой, тупо Б сюда перейдет.
[01:04:12.960 --> 01:04:14.960]  У этой штуки.
[01:04:14.960 --> 01:04:18.200]  Смотрим суффиксную ссылку, переход по А нашли.
[01:04:18.200 --> 01:04:23.160]  Дальше у этой снова в корень прыгаем.
[01:04:23.160 --> 01:04:35.320]  У этой, у этой и у этой какой-то снатах ахакарасику
[01:04:35.320 --> 01:04:36.320]  нет.
[01:04:37.000 --> 01:04:42.000]  Она одна.
[01:04:42.000 --> 01:04:46.280]  Гармония на душе достигнута.
[01:04:46.280 --> 01:04:51.800]  Окей, теперь давайте посчитаем префикс-функцию для этой
[01:04:51.800 --> 01:04:52.800]  штуки.
[01:04:52.800 --> 01:04:54.800]  Я думаю, вы уже догадываетесь к чему это приведет.
[01:04:55.280 --> 01:05:09.280]  Ахакарасик превращается в автомат префикс-функции.
[01:05:09.280 --> 01:05:11.680]  Потому что вы четко знаете, куда из каждой буквы вы
[01:05:11.680 --> 01:05:12.680]  можете пойти.
[01:05:12.680 --> 01:05:20.720]  Аналогично, только теперь вы берете себе максимальный
[01:05:20.720 --> 01:05:23.160]  суффикс, равный префикс не в своей строке, а вообще
[01:05:23.520 --> 01:05:24.520]  во всех строках.
[01:05:24.520 --> 01:05:27.520]  Поэтому это можно назвать обобщенной префикс-функцией.
[01:05:27.520 --> 01:05:31.560]  И это, в общем-то, та идея, которую мы сами реализуем,
[01:05:31.560 --> 01:05:33.600]  этот вот проход текстом по автомату.
[01:05:33.600 --> 01:05:37.360]  По сути, мы же что делаем, когда пишем паттер, решетка,
[01:05:37.360 --> 01:05:40.720]  текст и считаем их общую префикс-функцию?
[01:05:40.720 --> 01:05:42.720]  Вы не поверите, но мы просто ходим текстом по этому
[01:05:42.720 --> 01:05:43.720]  автомату.
[01:05:43.720 --> 01:05:46.960]  Потому что это совсем не очевидно, когда вы это
[01:05:46.960 --> 01:05:47.960]  делаете.
[01:05:47.960 --> 01:05:50.240]  Вот вы решеткой говорите, все, я пошел в корень, то
[01:05:50.240 --> 01:05:53.040]  есть я построил себе автомат, пойду-ка я ходить текстом
[01:05:53.040 --> 01:05:56.560]  по этому автомату каждый раз и все.
[01:05:56.560 --> 01:06:00.440]  И каждый раз выписывать себе, что у меня входит
[01:06:00.440 --> 01:06:04.720]  такая-то вершинка, такая-то, такая-то, прыгнул назад
[01:06:04.720 --> 01:06:07.560]  там, например, что-нибудь такое и так далее.
[01:06:07.560 --> 01:06:19.760]  Вот, итого, осталось утверждение Михаила про ту и линке.
[01:06:19.760 --> 01:06:27.400]  То есть, что утверждается, что если я, мы вроде разобрались,
[01:06:27.400 --> 01:06:30.720]  что если у меня есть переход по букве, то все окей, вроде
[01:06:30.720 --> 01:06:31.720]  бы.
[01:06:31.720 --> 01:06:37.560]  Да, то есть мы сами выписывали определение ту от в по букве
[01:06:37.560 --> 01:06:39.560]  с, это кто такой?
[01:06:39.560 --> 01:06:45.560]  Это то от в по с, если есть из в, с в боре, иначе это
[01:06:45.560 --> 01:06:52.920]  ту от линк от в по с, да, и что мы сами выписали?
[01:06:52.920 --> 01:07:03.000]  Мы сами выписали такое утверждение, что линк от ту от в с, это
[01:07:03.000 --> 01:07:10.840]  ту от линк от в с, и Михаил говорит, окей, вот я хочу
[01:07:10.840 --> 01:07:14.160]  посчитать вот эту штуку.
[01:07:14.160 --> 01:07:18.600]  Вдруг у меня ту от в с отсутствует в боре?
[01:07:18.600 --> 01:07:23.520]  Ту от в с не в боре.
[01:07:23.520 --> 01:07:25.640]  Откуда вот ту от в с?
[01:07:25.640 --> 01:07:30.040]  Так, наверное, плохо видно, значит возьму другой маркер,
[01:07:30.040 --> 01:07:32.040]  возможно этот.
[01:07:32.040 --> 01:07:44.040]  равно по определению ту от линк от в с, да, еще хуже,
[01:07:44.040 --> 01:07:53.080]  сейчас я, понимаете, здесь куча маркеров, и все плохие.
[01:07:53.080 --> 01:08:00.800]  Умеется в виду переход из в по с не в боре.
[01:08:00.800 --> 01:08:05.720]  Так, да, вроде бы это пожелал Михаил, тогда ту от в с равно
[01:08:05.720 --> 01:08:09.280]  ту от линк от в с, просто по определению, тогда что
[01:08:09.280 --> 01:08:14.120]  говоря, давайте поставим это сюда, да, тогда получается
[01:08:14.120 --> 01:08:30.360]  линк, ой, я нашел маркер, равно ту от в с.
[01:08:30.360 --> 01:08:39.400]  Действительно такое может быть, что у вас суффиксная
[01:08:39.400 --> 01:08:44.240]  ссылка вершины ведет самужеб себя, это правда, нет, сейчас
[01:08:44.240 --> 01:08:47.880]  не так, вообще по идее суффиксная ссылка должна вести во
[01:08:47.880 --> 01:08:52.040]  что-то выше, вот, поэтому тогда получается, что это
[01:08:52.040 --> 01:08:55.160]  корень, да, эта вершинка тогда корень, только тогда
[01:08:55.160 --> 01:09:02.720]  это возможно, то есть тогда получается, что ту от линк
[01:09:02.720 --> 01:09:09.640]  от в с это корень, когда это возможно вообще, что ту
[01:09:09.640 --> 01:09:16.760]  от линк от в с это корень, вообще, это ситуация по-хорошему,
[01:09:16.760 --> 01:09:19.520]  когда буквы от с вообще не входят никогда, кроме
[01:09:19.520 --> 01:09:22.200]  как первый раз, точнее, вообще никогда не входят,
[01:09:22.200 --> 01:09:26.800]  то, что мы сейчас снимем на Боре, вроде бы, ладно,
[01:09:26.800 --> 01:09:30.680]  не суть, окей, ту от линк от в с это корень, ту от в
[01:09:30.680 --> 01:09:34.200]  с не в Боре, значит, ту от линк от в по с это корень,
[01:09:34.200 --> 01:09:46.520]  так, мы получали, что из этого следует это, ну, понятно,
[01:09:46.520 --> 01:09:48.920]  что суффиксная ссылка несуществующей машины, она в корень ведет,
[01:09:48.920 --> 01:09:57.640]  скорее всего, нет, еще раз, если ту от в с, то ту от в с
[01:09:57.640 --> 01:09:59.960]  это несуществующая вершина, можно сказать, если у вас
[01:09:59.960 --> 01:10:02.560]  ту от в с это несуществующая вершина, то есть ее нет в
[01:10:02.560 --> 01:10:05.920]  Боре, значит, суффиксная ссылка ведет в корень, ну,
[01:10:05.920 --> 01:10:08.400]  и в целом, можно определить, что из несуществующих вершин
[01:10:08.400 --> 01:10:14.040]  все переходы в корень ведут, для согласованности, в плане
[01:10:14.040 --> 01:10:18.840]  ее нет в Боре, ну да, в Боре его нет, но она в корень
[01:10:18.840 --> 01:10:20.840]  она определена, но для нее уже линк определен, да.
[01:10:20.840 --> 01:10:31.720]  Да, функции не существуют, реброна может не существовать,
[01:10:31.720 --> 01:10:32.720]  да.
[01:10:32.720 --> 01:10:39.720]  Ну, имеется в виду, что, да, ребро, но не из Бора.
[01:10:39.720 --> 01:10:47.840]  Ну, короче говоря, что полностью формально убрать все противоречия,
[01:10:47.840 --> 01:10:51.880]  проще сказать, что вот это утверждение верно, если
[01:10:51.880 --> 01:10:55.280]  из вершины в есть ребро по букве с в Боре, тогда оно
[01:10:55.280 --> 01:10:57.840]  действительно верно, если нет, то действительно
[01:10:57.840 --> 01:10:59.840]  видимо какие-то коллизии получаются, еще что-то неприятное.
[01:10:59.840 --> 01:11:03.840]  Ну, линк от корня это корень, и вроде все работает.
[01:11:03.840 --> 01:11:07.840]  Ну, линк от корня это корень, это правда, можно так определить.
[01:11:07.840 --> 01:11:14.840]  У нас какие-то приколы в правилах, если у нас из вершины
[01:11:14.840 --> 01:11:21.840]  в Боре нет перехода в С, то у нас тогда линк от этой
[01:11:21.840 --> 01:11:24.840]  вершины всегда корень, но это странно.
[01:11:24.840 --> 01:11:26.840]  Ну, я понял, о чем это.
[01:11:26.840 --> 01:11:30.840]  Если мы возьмем вот эту вершину, у нас есть у тебя переход.
[01:11:30.840 --> 01:11:32.840]  Давайте вот эту вершину возьмем, да.
[01:11:32.840 --> 01:11:36.840]  Мы в алгоритме вообще пользуемся тем, что у нас все переходы
[01:11:36.840 --> 01:11:37.840]  приколены?
[01:11:37.840 --> 01:11:39.840]  Да, пользуемся.
[01:11:39.840 --> 01:11:41.840]  Ну, вообще, да, мы пользуемся.
[01:11:41.840 --> 01:11:42.840]  Почему?
[01:11:42.840 --> 01:11:45.840]  Потому что у нас есть переход не по букве сбора.
[01:11:45.840 --> 01:11:46.840]  Вот.
[01:11:46.840 --> 01:11:48.840]  Окей, давайте посмотрим, что такое переход.
[01:11:48.840 --> 01:11:49.840]  Отсюда по С, да?
[01:11:49.840 --> 01:11:50.840]  Куда он приведет вообще?
[01:11:54.840 --> 01:11:56.840]  Сейчас, я скажу так.
[01:11:58.840 --> 01:11:59.840]  Не-не-не.
[01:11:59.840 --> 01:12:01.840]  Понятно, что он приведет сюда.
[01:12:01.840 --> 01:12:06.840]  Я сейчас хочу построить случай, когда это не работает.
[01:12:06.840 --> 01:12:09.840]  Хочу построить вот такой вот случай еще.
[01:12:12.840 --> 01:12:14.840]  Пусть у меня добавилось АС.
[01:12:15.840 --> 01:12:18.840]  Тогда у меня суффиксная ссылка, она ведет вот сюда вот.
[01:12:19.840 --> 01:12:24.840]  Тогда у этой штуки по букве С переход ведет снова сюда.
[01:12:24.840 --> 01:12:28.840]  Потому что вот линк от этой штуки по букве С сюда ведет.
[01:12:31.840 --> 01:12:34.840]  А теперь я хочу почитать от этой штуки тупо С, да.
[01:12:35.840 --> 01:12:40.840]  Я иду по суффиксной ссылке, и у меня уже определен переход по букве С.
[01:12:41.840 --> 01:12:44.840]  Вот я хочу отсюда по букве С посчитать, куда оно ведет.
[01:12:45.840 --> 01:12:49.840]  Ту от этой вершинки В, да.
[01:12:57.840 --> 01:13:00.840]  А, ну окей, я определил как ту от линк от В по С, да.
[01:13:06.840 --> 01:13:07.840]  Окей?
[01:13:08.840 --> 01:13:11.840]  Дальше я смотрю, ну у меня уже ту определен здесь по С.
[01:13:12.840 --> 01:13:15.840]  Именно как функция, не как ребро.
[01:13:18.840 --> 01:13:20.840]  Да, да, мы уже посчитали, когда для этой штуки...
[01:13:20.840 --> 01:13:22.840]  Не, смотрите, еще раз.
[01:13:22.840 --> 01:13:24.840]  Для этой штуки мы ту по С посчитали.
[01:13:24.840 --> 01:13:27.840]  Да, просто корень ссылка.
[01:13:28.840 --> 01:13:29.840]  Для этой.
[01:13:32.840 --> 01:13:35.840]  А, ну теперь да, она появилась, хорошо. Справедливо.
[01:13:36.840 --> 01:13:39.840]  Тогда у этой штуки куда приведет по С?
[01:13:40.840 --> 01:13:42.840]  Оно приведет вот сюда вот.
[01:13:44.840 --> 01:13:45.840]  Да?
[01:13:46.840 --> 01:13:47.840]  Ну будто бы да.
[01:13:48.840 --> 01:13:52.840]  Потому что я возьму суффиксную ссылку сюда и перейду по букве С.
[01:13:53.840 --> 01:13:55.840]  Дальше, я считаю, здесь по букве С переход.
[01:13:55.840 --> 01:13:58.840]  Я беру суффиксную ссылку, и у меня определен переход по букве С.
[01:13:59.840 --> 01:14:00.840]  Уже.
[01:14:00.840 --> 01:14:04.840]  То есть здесь ту имеется в виду не в контексте ребра, а в контексте функции ту.
[01:14:05.840 --> 01:14:07.840]  Да, но у нас в первом.
[01:14:12.840 --> 01:14:15.840]  Ну здесь, мне кажется, да, действительно проблемы в том, как подметили,
[01:14:15.840 --> 01:14:18.840]  что у нас коллизия обозначений, что такое ребро, что такое функция ту.
[01:14:19.840 --> 01:14:22.840]  Но я утверждаю, что к моменту, когда мы рассматриваем вершину В,
[01:14:23.840 --> 01:14:28.840]  для всех вершин выше нее и для всех букв определена функция ту.
[01:14:29.840 --> 01:14:32.840]  А тогда, значит, у нас никаких противоречий с этим нет.
[01:14:33.840 --> 01:14:35.840]  Вот, я предлагаю суетись на этом.
[01:14:36.840 --> 01:14:39.840]  Если все-таки возникнет непонятный момент, то, наверное, проясню в следующий раз.
[01:14:40.840 --> 01:14:42.840]  Хотя в следующий раз у нас там еще более сложная тема.
[01:14:43.840 --> 01:14:47.840]  Вот, а пока что поздравляю вас с тем, что вы это поняли.
[01:14:48.840 --> 01:14:50.840]  Наверное, это самое сложное, что было в этом году.
[01:14:51.840 --> 01:14:52.840]  Все, всем пока.
