[00:00.000 --> 00:06.640]  Собственно, содержание того, о чем мы с вами будем
[00:06.640 --> 00:09.120]  говорить на лекциях, вот примерно оно в таком
[00:09.120 --> 00:12.160]  виде, в тезисном виде представлено на слайде.
[00:12.160 --> 00:18.000]  Поговорим с вами об общих понятиях и концепциях,
[00:18.000 --> 00:21.080]  на которых строится не то чтобы теория баз данных
[00:21.080 --> 00:25.240]  – это прям громкое словосочетание, но учение что ли о базах
[00:25.240 --> 00:28.560]  данных некое такое.
[00:28.560 --> 00:38.000]  И поговорим с вами о SQL запросах, синтаксисе, о группах
[00:38.000 --> 00:43.160]  операторов по множеству языка SQL отдельно, посмотрим
[00:43.160 --> 00:46.440]  как проектируются базы данных, разберем более
[00:46.440 --> 00:50.280]  менее продвинутые запросы, их оптимизацию, что происходит
[00:50.280 --> 00:57.280]  под капотом базы данных, еще раз прошу прощения,
[00:57.280 --> 01:02.480]  и коснемся более таких глобальных, что ли может
[01:02.480 --> 01:07.120]  быть тем, это хранилища данных, ну вот именно data
[01:07.120 --> 01:12.320]  warehouses, потому что есть еще data lakes, data oceans, различные
[01:12.320 --> 01:17.760]  варианты метафора на тему того, что делать с огромным
[01:17.760 --> 01:20.360]  количеством данных из разных департаментов большой-большой
[01:20.360 --> 01:24.440]  компании, все мы там посмотреть не успеем, скорее всего
[01:24.440 --> 01:28.640]  это будет одна, может быть две лекции по тоже таким
[01:28.640 --> 01:40.800]  основам Инману и Ки, ну в общем, авторов мы вспомним
[01:40.800 --> 01:44.040]  уже на соответствующей лекции, и немного поговорим
[01:44.040 --> 01:49.480]  про нереляционные базы данных, и посмотрим, я думаю,
[01:49.480 --> 01:53.600]  парочек-троечек примеров, чтобы на контрасте немножко
[01:53.600 --> 01:57.640]  оценить для себя, сделать какие-то данные, иметь в
[01:57.640 --> 02:03.280]  виду какие-то общие представления, как и что происходит в
[02:03.280 --> 02:07.080]  нереляционных базах данных.
[02:07.080 --> 02:12.720]  Окей, общие моменты, почему вообще мы с вами изучаем
[02:12.720 --> 02:18.880]  базы данных, зачем и кому это нужно, здесь довольно
[02:18.880 --> 02:25.880]  понятные, наверное даже очевидные практически предпосылки
[02:25.880 --> 02:28.520]  с развитием информационных технологий, с развитием
[02:28.520 --> 02:34.360]  техники электронно-вычислительной, появлялось все больше
[02:34.360 --> 02:37.600]  информации, которую нужно было обрабатывать, чтобы
[02:37.600 --> 02:42.360]  обрабатывать нужно было где-то ее хранить, и чем
[02:42.440 --> 02:45.560]  больше, ну, мы не берем там какие-то совсем дремучие
[02:45.560 --> 02:50.040]  времена, а что было до электронных вычислительных машин,
[02:50.040 --> 02:56.000]  до компьютеров, до ячеек памяти, как все складируется
[02:56.000 --> 02:58.960]  в библиотеке, что происходит с библиотечным фондом,
[02:58.960 --> 03:02.680]  нас интересует вопрос исключительно, конечно, в том, почему появились
[03:02.680 --> 03:05.800]  электронные базы данных на компьютерах, ну, потому
[03:05.800 --> 03:09.760]  что у нас, как я уже сказал, информации было все больше
[03:09.760 --> 03:16.360]  с развитием техники, и в начале базы данных возникли
[03:16.360 --> 03:20.560]  как попытка абстрагироваться от непосредственной работы
[03:20.560 --> 03:24.680]  с адресацией памяти, причем буквально прямой адресацией,
[03:24.680 --> 03:29.360]  буквально с прямой адресацией, когда прям адреса, чуть
[03:29.360 --> 03:33.680]  ли не адреса ячеек записывались в те или иные команды, то
[03:33.680 --> 03:37.600]  есть они возникли, базы данных, как попытка абстрагироваться
[03:38.160 --> 03:43.080]  и предоставить аппаратно независимый набор инструкций
[03:43.080 --> 03:48.120]  команд, как для проектировщиков баз данных, так и для пользователей,
[03:48.120 --> 03:55.240]  которые бы упростили всем первым проектировщикам
[03:55.240 --> 03:58.240]  проектирование баз данных, а вторым пользователям
[03:58.240 --> 04:02.600]  упростили бы, соответственно, работу с данными, получение
[04:02.600 --> 04:09.040]  баз данных по запросам, но что такое вообще базы
[04:09.040 --> 04:12.000]  данных, о чем мы с вами будем говорить, на самом деле,
[04:12.000 --> 04:15.200]  как незабавно, какого-то такого стоявшегося определения
[04:15.200 --> 04:19.720]  нет, если говорить про базы данных, систему управления
[04:19.720 --> 04:26.240]  баз данными, модели данных, а вещи это часто пересекающиеся
[04:26.240 --> 04:31.000]  в зависимости от контекста, и конечно, формально есть
[04:31.000 --> 04:34.880]  определение, есть госстандарты, если вы будете участвовать
[04:34.880 --> 04:38.120]  в разработке тех доков, вы этими госстандартами
[04:38.120 --> 04:40.320]  будете пользоваться, чтобы определить, что вы вообще
[04:40.320 --> 04:52.000]  делаете, но, ребят, в чат, пожалуйста, не пишите сообщения
[04:52.000 --> 04:59.800]  такие-то, бессодержательные, это отвлекает, так вот,
[04:59.800 --> 05:05.400]  на самом деле понять, что имеется в виду, можно в зависимости
[05:05.400 --> 05:08.200]  от того, что имеет в виду ваш собеседник и что вы
[05:08.200 --> 05:14.080]  делаете, но, тем не менее, как можно определить, если
[05:14.080 --> 05:19.360]  мы возьмем какие-то наиболее известные курсы по базам
[05:19.360 --> 05:23.600]  данных, то определение можно сформулировать, вернее,
[05:23.600 --> 05:26.440]  привести несколько определений, что это некоторый набор,
[05:26.440 --> 05:28.280]  Кристофер Дейт, например, говорит, что это некоторый
[05:28.280 --> 05:31.040]  набор перманентных данных, используемых прикладными
[05:31.040 --> 05:33.440]  программными системами какого-либо предприятия.
[05:33.440 --> 05:38.080]  В альтернативных курсах есть еще несколько определений,
[05:38.080 --> 05:39.400]  но они, в принципе, довольно похожи.
[05:39.400 --> 05:47.480]  Довольно похоже, все, везде речь идет о том, что это
[05:47.480 --> 05:54.280]  какие-то данные хранимые где-то и о том, что база
[05:54.280 --> 05:57.680]  данных предоставляет некий набор операций, которые
[05:57.680 --> 05:59.680]  пользователь может совершать над данными.
[05:59.680 --> 06:06.680]  И вот, собственно, Благословенная Википедия предлагает пару
[06:06.680 --> 06:10.280]  своих вариантов определений, наша статья о русскоязычной
[06:10.280 --> 06:13.960]  википедии опирается на ГОСТ, соответственно, но
[06:13.960 --> 06:18.280]  когда ГОСТ, это, наверное, полезно для разработки
[06:18.280 --> 06:22.880]  техдокументации, в первую очередь.
[06:22.880 --> 06:25.960]  Не будем на этом останавливаться сильно, в принципе, нужно,
[06:26.860 --> 06:30.060]  чтобы нам понимать, что есть, собственно, базы данных,
[06:30.060 --> 06:32.960]  есть система управления базами данных и есть,
[06:32.960 --> 06:35.960]  в релиционных базах данных, система управления релиционными
[06:35.960 --> 06:40.200]  базами данных, соответственно, есть распространенные агремиатуры
[06:40.200 --> 06:45.360]  СОБД и РСОБД, и БД, понятно, база данных реализовывenne.
[06:47.960 --> 06:50.360]  Про базу данных мы кратенько сказали, а реалливационной
[06:50.360 --> 06:53.560]  базы данных — это база данных, реализующая релиционную
[06:53.560 --> 07:03.560]  Система управления базой данных – это совокупность программных и лингвистических средств общего и специального назначения обеспечивающих управление созданием и использованием баз данных.
[07:03.560 --> 07:11.560]  Ух! Релиационная СУБД, соответственно, поддерживает такая система управления, которая поддерживает релиционную модель данных.
[07:12.560 --> 07:21.560]  Немножко тавтология, немножко такое топанье на месте, но вот немножко тем не менее скучных вводных вещей.
[07:21.560 --> 07:36.560]  Надо, наверное, о них сказать по неким формальным соображениям, чтобы у вас было общее понимание хотя бы, что такое аббревиатура СУБД и РСУБД.
[07:36.560 --> 07:42.560]  Повторюсь еще раз. База данных – это просто набор сведений, определенным образом хранимых.
[07:42.560 --> 07:48.560]  И, как правило, не разделяют систему управления базой данных или база данных в литературе.
[07:48.560 --> 07:53.560]  То есть, по большому счету, слова – синонимы. И часто бывает.
[07:53.560 --> 08:00.560]  Поэтому, если говорят база данных, часто подразумевают целую систему.
[08:01.560 --> 08:05.560]  Когда говорят база данных, подразумевают систему управления базой данных.
[08:05.560 --> 08:12.560]  И наоборот. Ну да ладно. Более интересная, более глубокая, что ли, вещь.
[08:12.560 --> 08:15.560]  Модель данных. Что это, собственно, такое?
[08:18.560 --> 08:23.560]  Мы с вами еле-еле попытались как-то разобраться и определить, что такое база данных.
[08:23.560 --> 08:27.560]  Более или менее, наверное, у нас кто-то из этого получилось.
[08:27.560 --> 08:32.560]  А можно уточнить, что значит релиционная модель?
[08:32.560 --> 08:42.560]  Релиционная модель – это модель, которая реализует, построенная на отношениях,
[08:42.560 --> 08:47.560]  построенная на определенной математической абстракции,
[08:47.560 --> 08:57.560]  описанная Джеймсом Кодом в своей статье программной 1969-1980 года.
[08:57.560 --> 09:03.560]  И вот, наверное, ответ такой.
[09:03.560 --> 09:08.560]  То есть, модель данных, основанная на отношениях, в неком математическом смысле.
[09:08.560 --> 09:11.560]  Мы сейчас об этом поговорим.
[09:11.560 --> 09:12.560]  Спасибо.
[09:12.560 --> 09:19.560]  Эдгаром Кодом. Прошу прощения, конечно, Эдгаром.
[09:19.560 --> 09:26.560]  Собственно, как Эдгар Код, да, и вообще, кто такой Эдгар Код?
[09:26.560 --> 09:36.560]  Я уже немножко забежав вперед, раскрыл личность нашего, наверное, главного автора по теме, скажем так,
[09:36.560 --> 09:38.560]  Майлстоун.
[09:38.560 --> 09:43.560]  Главного с точки зрения концептуальной автора по теме.
[09:43.560 --> 09:47.560]  То есть, человек, который, по большому счету, в своей статье 1969-1970 года.
[09:47.560 --> 09:55.560]  Почему 1969-1970? Потому что в 1969-ом она вышла внутри IBM, по-моему, тогда он работал в IBM,
[09:55.560 --> 09:59.560]  а в 1970-ом она уже была опубликована в широкой печати.
[09:59.560 --> 10:11.560]  Эдгар Код, собственно, эту модель придумал, изобрел, как-то вот последовательно описал.
[10:11.560 --> 10:15.560]  И, в принципе, я вам всем рекомендую ознакомиться с этой статьей.
[10:15.560 --> 10:20.560]  Она довольно легко гуглится. В лекции будет название.
[10:20.560 --> 10:27.560]  По названию можно найти 12 страниц, его немного. Довольно легко прочитать, быстро можно.
[10:27.560 --> 10:31.560]  А что такое модель данных, тем не менее, по Эдгару Коду?
[10:31.560 --> 10:35.560]  Он выделял три признака модели данных в 1981 году.
[10:35.560 --> 10:40.560]  Наличие коллекции набора типов структур данных, наличие набора операторов или правил вывода,
[10:40.560 --> 10:44.560]  с помощью которых можно манипулировать имеющимися экземплярами типов структур данных.
[10:44.560 --> 10:49.560]  И набор правил поддержания целостности, которые определяют множество согласованных состояний базы данных.
[10:49.560 --> 10:53.560]  Или переходы из одного состояния в другое. Почему нам это важно?
[10:53.560 --> 10:58.560]  Модель данных – это штука междисциплинарная, наверное.
[10:58.560 --> 11:05.560]  Мы здесь, в нашей лекции о ней поговорим. Наверное, вернемся еще немножко, когда поговорим про проектирование.
[11:05.560 --> 11:10.560]  Но модель данных – это не совсем даже напрямую относительно то, что относится к базам данных.
[11:10.560 --> 11:14.560]  Это такая подлежащая абстракция или надстоящая абстракция,
[11:14.560 --> 11:22.560]  которая у нас может реализоваться в той или иной мере, в той или иной базе данных, в системе управления базой данных.
[11:22.560 --> 11:27.560]  А может и нет. Как революционная модель, тем более, особенно с доработками Эдгаро Кода,
[11:27.560 --> 11:36.560]  который он в своих статьях в 70-х годах делал и дальше, в 80-х тоже, она реализована не в полной мере на данный момент.
[11:36.560 --> 11:44.560]  И в принципе, нет базы данных, которые в полной мере реализуют модель Эдгаро Кода в том виде,
[11:44.560 --> 11:50.560]  которым он закончил. У него последние статьи 90-ми даже годами датируются.
[11:50.560 --> 11:58.560]  В которой он вот... Нет, то есть такой базы данных сейчас вышли,
[11:58.560 --> 12:04.560]  который бы полностью реализовал там все идеи Эдгаро Кода как основателя ясного положника революционной модели.
[12:04.560 --> 12:13.560]  Ну, с другой стороны, с другой стороны, можно сказать, что, в принципе, база данных даже стандарта SQL в полной мере не реализует.
[12:13.560 --> 12:17.560]  Имеют свои особенности, но это уже, наверное, другая история.
[12:17.560 --> 12:23.560]  Тем не менее, Эдгар Код предложил такой подход к модели данных.
[12:23.560 --> 12:29.560]  То есть модель данных, она должна описывать какой-то набор типов данных,
[12:29.560 --> 12:35.560]  должна иметь правила работы с этими типами в виде, например, каких-то операторов.
[12:35.560 --> 12:39.560]  И должна иметь правила поддержания целостности, что важно, тоже очень важно.
[12:39.560 --> 12:43.560]  Поддержание целостности состояний, когда мы там что-то меняем.
[12:43.560 --> 12:50.560]  Меняем, совершаем какие-то транзакции, чтобы у нас были правила и ограничения
[12:50.560 --> 12:58.560]  на препятствующие нам изменить что-то чрезмерно существенное.
[12:58.560 --> 13:04.560]  А хорошо, есть также формальное определение ГОСТовской модели данных,
[13:04.560 --> 13:08.560]  графическое или словесное представление данных, задающее их структуру и взаимосвязи.
[13:08.560 --> 13:12.560]  Очень такое приятное лаконичное определение.
[13:12.560 --> 13:20.560]  А также различные курсы предлагают свои подходы к определению модели данных.
[13:20.560 --> 13:25.560]  Но нам важно запомнить то, что сказал, наверное, Эдгар Код.
[13:25.560 --> 13:32.560]  Это типы, варианты операции над типами и способы поддержания целостности.
[13:32.560 --> 13:40.560]  В этом курсе, в нашем курсе мы будем изучать только одну, подробно будем изучать только одну модель данных.
[13:40.560 --> 13:42.560]  Это релиционная модель.
[13:42.560 --> 13:50.560]  И посмотрим на то, как она реализуется в такой системе управления базами данных,
[13:50.560 --> 13:55.560]  или в такой базе данных, как Postgresql.
[13:55.560 --> 13:58.560]  С ней вы будете работать и на семинарах.
[13:58.560 --> 14:08.560]  В первую очередь мы немножко, совсем чуть-чуть, наверное, будем касаться, что происходит в смежных релиционных базах данных,
[14:08.560 --> 14:11.560]  на лекциях, пожалуй.
[14:11.560 --> 14:15.560]  Но у нас как таковой такой цели не будет.
[14:15.560 --> 14:24.560]  Поэтому, если хотите, в принципе, стандарты, не стандарт, прошу прощения, тех документаций, тех или иных решений,
[14:24.560 --> 14:27.560]  она в свободном доступе есть.
[14:27.560 --> 14:36.560]  Можете посмотреть сами, но по большому счету изменения не сказать, чтобы прям какие-то, раздачтение различий,
[14:36.560 --> 14:39.560]  не сказать, чтобы какие-то принципиальные, но они есть.
[14:39.560 --> 14:43.560]  И когда вы будете работать с той или иной системой, их, конечно, нужно учитывать.
[14:43.560 --> 14:49.560]  И смотрите документацию.
[14:49.560 --> 14:55.560]  Модель, как я уже сказал, была в основном сформулирована Adgram Code, его программной статьей 70-го года,
[14:55.560 --> 15:00.560]  Relational Model of Data for Large Shared Data Banks.
[15:00.560 --> 15:02.560]  Прошу прощения за мой английский.
[15:02.560 --> 15:12.560]  Еще раз настоятельно вам рекомендую взять в руки Google и найти статью и ее прочитать.
[15:12.560 --> 15:21.560]  Хотя бы, по крайней мере, там какие-то отдельные моменты из нее, глазами по ней пробежаться за что-то зацепится,
[15:21.560 --> 15:24.560]  может быть, в ваш взгляд, потому что штука интересная.
[15:24.560 --> 15:36.560]  Позволяет понять вообще, почему и как возникла вот эта вот концепция релиционной базы данных.
[15:36.560 --> 15:47.560]  В начале Adgram Code пишет о том, какие зависимости данных он считает критическим и хочет от них избавиться.
[15:47.560 --> 15:58.560]  И на примере существовавших тогда систем управления данными они назывались, Data Management Systems,
[15:58.560 --> 16:04.560]  а на примере существующих систем он показывает, что вот такая система у нее какие-то проблемы,
[16:04.560 --> 16:05.560]  вот такая система у нее какие-то проблемы.
[16:05.560 --> 16:09.560]  Ну, кратенько все, но довольно любопытно.
[16:09.560 --> 16:17.560]  Позже Code расширял и дополнял свою основную модель 70-го года.
[16:17.560 --> 16:22.560]  Как я уже говорил, там не одна на самом деле из сегодня существующих промышленных СОБД,
[16:22.560 --> 16:28.560]  в полной мере его строгий подход формально не реализует.
[16:28.560 --> 16:34.560]  Ну и вообще Adgram Code был прям таким инженером-математиком, наверное даже математиком-инженером,
[16:34.560 --> 16:44.560]  и поэтому он довольно строго подходил к вопросу логической неприватительной противоречивости собственной теории,
[16:44.560 --> 16:50.560]  собственной модели, что на практике не всегда удобно и выполнимо.
[16:51.560 --> 16:55.560]  Релиционные реляции, отношения, ребята.
[16:55.560 --> 17:01.560]  Отношения, если совсем просто, и дальше сейчас будут слайды на эту тему, и мы об этом поговорим,
[17:01.560 --> 17:07.560]  если совсем просто и на пальцах, в модели релиционные реляции, отношения, это просто таблица.
[17:11.560 --> 17:15.560]  А если прям хотите подробное пояснение такой математического плана,
[17:15.560 --> 17:18.560]  ну у нас будут тоже еще слайды на эту тему,
[17:18.560 --> 17:23.560]  но здесь мне не кажется, что оно какое-то принципиальное,
[17:23.560 --> 17:26.560]  просто имейте в виду, что реляция это отношение между чем-то и чем-то, да,
[17:26.560 --> 17:29.560]  подробное математическое описание смотрите в статье Adgram Code,
[17:30.560 --> 17:32.560]  а мы пока продолжим.
[17:33.560 --> 17:37.560]  Так, бывает еще и множество других моделей, на самом деле,
[17:37.560 --> 17:42.560]  и релиционная она у нас на сегодняшний момент, ну не то чтобы,
[17:43.560 --> 17:48.560]  как бы сказать, знаете, она не то чтобы прям доминирующая вообще везде и во всем,
[17:48.560 --> 17:53.560]  но она, наверное, вот самая распространенная и на уровне каком-то таком
[17:54.560 --> 17:58.560]  среднего объема предприятия, наверное, можно сказать, что будут высталкнётесь
[17:58.560 --> 18:04.560]  только с набором каких-то релиционных баз данных в некотором количестве департаментов,
[18:04.560 --> 18:15.560]  без каких-то существенных отступлений в какие-нибудь, не знаю, колончатые базы данных,
[18:15.560 --> 18:20.560]  какие-нибудь хранилища данных, у каждого департамента будет своя база данных
[18:20.560 --> 18:26.560]  и просто нужно будет ее обслуживать, ну как Postgres, MySQL, что-нибудь такое,
[18:26.560 --> 18:32.560]  но у крупных компаний есть более сложное, конечно, решение, ну ладно, это все уже лирика,
[18:32.560 --> 18:44.560]  главное, что модели есть и другие, и мы буквально чуть-чуть коснемся двух еще моделей,
[18:44.560 --> 18:50.560]  которые, ну, наверное, нужно не то чтобы как-то хорошо представлять, но просто иметь в виду,
[18:50.560 --> 18:58.560]  опять же, это то, в том числе, почему релиционная модель появилась, то есть до нее файлы,
[18:58.560 --> 19:03.560]  данные как-то хранились, хранились как-то первоначально там в файлах, в файловой системе,
[19:03.560 --> 19:12.560]  вообще изначально это были отдельные такие большие скопления информации в виде мастер файлов,
[19:12.560 --> 19:23.560]  то есть не было разделения на то, что сейчас подразумевается в вашей системе хранения данных
[19:23.560 --> 19:28.560]  по умолчанию, что вы можете ограничивать какой-то набор информации в виде файла,
[19:28.560 --> 19:36.560]  и он у вас там будет иметь определенные системные данные для того, чтобы ваше драйвер управления
[19:36.560 --> 19:41.560]  жестким диском, операционная система это индексировала, все удобно хранила, удобно считывала,
[19:41.560 --> 19:46.560]  раньше все, конечно, все начиналось с совсем простых решений и все хранилось, грубо говоря,
[19:46.560 --> 19:52.560]  в плотском таком коризонтальном виде, но все усложнялось, усложнялось, усложнялось в связи с тем,
[19:52.560 --> 19:58.560]  что нужно было данные, как я уже говорил, обрабатывать большие и быстро,
[19:58.560 --> 20:01.560]  и данных становилось все больше, обрабатывать нужно было все быстрее.
[20:01.560 --> 20:08.560]  Какие были варианты? Какие были варианты, чтобы не работать с прямой адресацией?
[20:08.560 --> 20:13.560]  Эрархическая модель данных. Появилась в результате обобщения подхода,
[20:13.560 --> 20:16.560]  использована IBM для своей системы управления данными.
[20:17.560 --> 20:30.560]  Вот IMS это то, что в 60-х годах, в 60-х годах была разработана компания IBM.
[20:30.560 --> 20:40.560]  Можно сказать, что это такая вот, такой предок с баз данных, использующий право нерелационные,
[20:40.560 --> 20:43.560]  а иные концепции в своей основе.
[20:43.560 --> 20:49.560]  Что интересно, в принципе, вот говорят об эрархической модели,
[20:49.560 --> 20:55.560]  но если говорить о том, как она возникла, это по сути дело описание тех принципов,
[20:55.560 --> 21:00.560]  на которых была разработана система. То есть сначала разработали систему IMS,
[21:00.560 --> 21:05.560]  а уже потом вышла такая как бы программная статья, которая описывала принципы,
[21:05.560 --> 21:08.560]  на которых эта IMS-система была сформулирована.
[21:09.560 --> 21:15.560]  Поэтому здесь получается, что даже модель данных возникла как следствие работы
[21:15.560 --> 21:24.560]  над конкретным прикладным программом обеспечения.
[21:24.560 --> 21:29.560]  Здесь у нас будет такое довольно подробное описание, правда,
[21:29.560 --> 21:33.560]  на трех, по-моему, всего слайдах эрархической модели,
[21:33.560 --> 21:39.560]  в том представлении, в котором Уильям Мак-Ги или Мак-Джи на русский язык
[21:39.560 --> 21:49.560]  по-разному переводят, будет описание на нескольких слайдах того,
[21:49.560 --> 21:54.560]  как Уильям Мак-Ги эту модель сформулировала в своей программной статье.
[21:54.560 --> 21:57.560]  Не будем, пожалуй, на этом останавливаться.
[21:57.560 --> 22:02.560]  Вот наглядно просто покажу из буквально статьи,
[22:02.560 --> 22:09.560]  как это представлялось с точки зрения хранения физической структуры данных,
[22:09.560 --> 22:11.560]  с точки зрения схемы данных.
[22:11.560 --> 22:15.560]  Буквально хранилось все таким образом, древовидно, как на левой части слайда.
[22:15.560 --> 22:18.560]  То есть просто было пересыливание с одного кускодиска на другой,
[22:18.560 --> 22:22.560]  и вот такая эрархическая структура образовывалась.
[22:22.560 --> 22:24.560]  Схема данных здесь немножко посложнее.
[22:24.560 --> 22:28.560]  Там, опять же, если прям сильно вам будет интересно, что, наверное,
[22:28.560 --> 22:31.560]  вряд ли вы можете посмотреть статью.
[22:31.560 --> 22:37.560]  Тоже небольшая, но в схеме данных, как вы видите, здесь схлопываются
[22:37.560 --> 22:44.560]  просто, грубо говоря, однотипные инстанции, экземпляры некой сущности,
[22:44.560 --> 22:53.560]  и там используются в скобках маркеры специфические,
[22:53.560 --> 23:00.560]  которые там обозначают специфические для модели параметры.
[23:00.560 --> 23:03.560]  Ну, помимо эрархической модели данных...
[23:03.560 --> 23:06.560]  Ну и да, опять же, что здесь можно сказать?
[23:06.560 --> 23:10.560]  Эрархическая модель данных была, есть и будет.
[23:10.560 --> 23:13.560]  Это, в общем-то, такой очень простой, понятный,
[23:13.560 --> 23:21.560]  нативный в некотором роде способ похоронения и обобщения информации.
[23:21.560 --> 23:24.560]  Если говорить про сейчас, то, грубо говоря,
[23:24.560 --> 23:29.560]  это то, как у вас в файловой системе расположены файлы.
[23:29.560 --> 23:31.560]  Ну, так очень-очень грубо.
[23:31.560 --> 23:36.560]  Так, вопрос субтитров будут.
[23:36.560 --> 23:39.560]  Не могу вам подсказать по поводу субтитров.
[23:39.560 --> 23:42.560]  Вроде бы, да, вроде бы должны быть.
[23:42.560 --> 23:47.560]  Сетевая модель данных, еще можно остановиться немножко на ней.
[23:47.560 --> 23:50.560]  Хронологически она была даже чуть раньше эрархической.
[23:50.560 --> 23:52.560]  Ну, хронологически в плане, опять же,
[23:52.560 --> 23:55.560]  здесь такая же ситуация, как с эрархической моделью.
[23:55.560 --> 23:59.560]  General Electric разрабатывали свою базу данных.
[23:59.560 --> 24:01.560]  На тот момент, опять же, такого термина не было,
[24:01.560 --> 24:06.560]  поэтому система менеджмента данных называлась их программное решение.
[24:06.560 --> 24:15.560]  По итогам разработки, инженеры-разработчики формулировали свою статью,
[24:15.560 --> 24:17.560]  написали статью, выпустили ее.
[24:17.560 --> 24:19.560]  Вот на слайде она тоже представлена.
[24:19.560 --> 24:21.560]  Тоже, как видите, два года.
[24:21.560 --> 24:23.560]  То есть первый год это то, что было опубликовано.
[24:23.560 --> 24:25.560]  Как с кодом, с Эдгаром кодом.
[24:25.560 --> 24:27.560]  В 1964 году вышла статья в печати.
[24:27.560 --> 24:31.560]  Ну, не в печати, а для узкого круга, для внутреннего пользования.
[24:31.560 --> 24:33.560]  В 1965 опубликована широкопечать.
[24:34.560 --> 24:37.560]  Такие технические подробности.
[24:37.560 --> 24:45.560]  Сетевая модель данных здесь тоже не будем на ней как-то очень сильно останавливаться.
[24:45.560 --> 24:53.560]  Она даже в описании том, в том техническом плюс-минус-описании 1965 года,
[24:53.560 --> 24:57.560]  она еще, наверное, более низкоуровневая, чем, пожалуй, сетевая.
[24:57.560 --> 24:59.560]  Но смысл в чем?
[24:59.560 --> 25:04.560]  В чем разница между сетевой и иерархической принципиальная?
[25:04.560 --> 25:07.560]  В том, что, вот как видите на правой части слайда,
[25:07.560 --> 25:13.560]  сетевая позволяла делать вот такие вот связанные графы,
[25:13.560 --> 25:17.560]  не просто деревья, а более общее представление данных,
[25:17.560 --> 25:24.560]  когда мы соответственно могли соединять, причем соединять буквально напрямую,
[25:24.560 --> 25:28.560]  опять же, через практически прямое пересыливание из отдельных записей,
[25:28.560 --> 25:30.560]  из одних записей на другие.
[25:30.560 --> 25:33.560]  Там были определенные формальные правила построения структуры записи.
[25:33.560 --> 25:40.560]  Но, тем не менее, можно было прямыми адресными ссылками сцеплять вот эти вот,
[25:40.560 --> 25:45.560]  как на рисунке показа, круги, сцеплять их друг с другом,
[25:45.560 --> 25:51.560]  и вот получалась такая, если прибегать к каким-то визуальным аналогиям,
[25:51.560 --> 25:54.560]  с сеточкой сетевая, поэтому сетевая.
[25:54.560 --> 25:59.560]  Но в чем главное различие между сетевыми и иерархическими моделями?
[25:59.560 --> 26:03.560]  Это в том, что в иерархических моделях данные организуются в виде деревьев.
[26:03.560 --> 26:05.560]  Один предок множество потомков.
[26:05.560 --> 26:09.560]  А в сетевых моделях данных допустимо и множественность потомков, и множественность...
[26:09.560 --> 26:26.560]  А с субтитрами вроде бы должны быть, да, да, да. Вроде бы должны быть.
[26:26.560 --> 26:33.560]  Так, что еще важно про сетевую иерархическую?
[26:33.560 --> 26:40.560]  Смотрите, ребят, мы ближе к концу лекции увидим довольно любопытную штуку,
[26:40.560 --> 26:50.560]  что у нас такая вот сетевая, скажем так, модель, она в некотором роде возвращается,
[26:50.560 --> 26:57.560]  пытается проявиться в релиционной модели. Я поясню, что это значит, когда мы дойдем до этого места.
[26:57.560 --> 27:02.560]  А с другой стороны, что интересно, опять же, если вы откроете статью кода,
[27:02.560 --> 27:10.560]  начнете ее читать, то там довольно любопытное рассуждение у него,
[27:10.560 --> 27:16.560]  как в релиционный вид перевести графовое представление данных.
[27:16.560 --> 27:21.560]  И вот он там берет, на примере, у него граф, вершина, это работник,
[27:21.560 --> 27:27.560]  и начинают потомки множества. У работника может быть жалование,
[27:27.560 --> 27:31.560]  у него там может быть ребенок, у жалований может быть валюта и так далее.
[27:31.560 --> 27:34.560]  Он говорит, как это перевести в релиционную модель.
[27:34.560 --> 27:44.560]  Ну, опять же, просто от меня рекомендация, поскольку если вы хотите прям что-то почитать емкое и краткое,
[27:44.560 --> 27:51.560]  по теме вот статья кода, отсылаю вас к ней, еще раз всем настоятельно рекомендую.
[27:51.560 --> 27:56.560]  Во всяком случае, она гораздо-гораздо меньше объема занимает, чем учебники дейта.
[27:56.560 --> 28:02.560]  Да, можно сказать так, получается, что иерархическое под множество сетевых.
[28:02.560 --> 28:07.560]  Ну, как бы формально говоря. Ну, опять же, ребят, в данном случае проблема, наверное, заключается в том,
[28:07.560 --> 28:14.560]  что модель и иерархическая, и сетевая, они являются следствием рассуждений о том,
[28:14.560 --> 28:22.560]  как люди программировали конкретное ПО. И вот конкретно получилось так, что у General Electric
[28:22.560 --> 28:28.560]  у General Electric получилась сетевая, у IBM вышла иерархическая.
[28:28.560 --> 28:35.560]  Они не думали изначально в терминах, они разработают ли мне программное обеспечение,
[28:35.560 --> 28:40.560]  которое будет функционировать, реализуя сетевую модель данных. Не было такого.
[28:40.560 --> 28:48.560]  Поэтому можно говорить, рассуждая, что оказывается, это вот такие модели, там были реализованы,
[28:48.560 --> 29:04.560]  одна является видом другой и так далее. Одна является видом другой, но, в принципе,
[29:04.560 --> 29:09.560]  это такие рассуждения, что ли, досужие, они какого-то практического смысла не несут, но у нас,
[29:09.560 --> 29:17.560]  прошу прощения, у нас есть небольшой пунктик на тему, что помимо реализационной есть другие модели,
[29:17.560 --> 29:23.560]  есть, да, они есть. Вот они вот такие, как минимум такие. Нужно просто держать в голове,
[29:23.560 --> 29:30.560]  но заборачиваться на этом не надо. Опять же, в слайдах есть информация по тем или иным
[29:30.560 --> 29:36.560]  каким-то основополагающим статьям. Можете, если хотите, углубиться, но, честно говоря,
[29:36.560 --> 29:44.560]  если есть свободное время, если его нет, почитайте коды. У него, в принципе, там тоже кратенько есть
[29:44.560 --> 29:50.560]  отсылки к тому, что было до реализованной модели. Какие еще есть модели? Ну, их много, их много,
[29:50.560 --> 29:59.560]  причем вопрос в том, что, как бы, да, что еще мы под этим под всем подразумеваем? Мы подразумеваем
[29:59.560 --> 30:05.560]  организацию данных на этапе проектирования, на организацию данных в конкретной базе данных или нет,
[30:05.560 --> 30:10.560]  и так далее. Вот entity relationship model – это то, о чем мы будем говорить с вами при вопросе
[30:10.560 --> 30:17.560]  проектирования модели, вернее реальной базы данных. Но можно ли сказать, что это модель данных?
[30:17.560 --> 30:21.560]  Да, можно. Мы тоже таким образом данные наши первично как-то обрабатываем, мы их, по крайней мере,
[30:21.560 --> 30:26.560]  для себя где-то на листочке расписываем и агрегируем по тем или иным группам.
[30:26.560 --> 30:40.560]  В сетевой модели, смотрите, и там, и там, это ссылки, ссылки по памяти, вообще ничего, вопрос, да,
[30:40.560 --> 30:45.560]  как осуществляется доступ к данным в сетевой модели в случае иерархической, это спуск по веткам дерева,
[30:45.560 --> 30:54.560]  и там, и там, это просто почти прямая адресация, то есть это очень зависимые модели в плане вот
[30:54.560 --> 30:59.560]  тогда, когда они возникли в конкретных системах, очень зависимые с точки зрения того,
[30:59.560 --> 31:05.560]  как строится сама, как строится само программное обеспечение и как строится уже внутри него
[31:05.560 --> 31:17.560]  складируются данные. Но здесь даже, знаете, нет какого-то, какой-то проблемы в том смысле,
[31:17.560 --> 31:23.560]  что вы можете там написать что-то свое и реализовать там переходы между данными как-то по-своему,
[31:23.560 --> 31:35.560]  по большому счету, и можно говорить, что ирреалиционная модель это некий перевертыш от сетевой.
[31:35.560 --> 31:48.560]  Почему? Потому что, вот смотрите, мы можем придумать некую базу данных, графовую, например,
[31:48.560 --> 31:54.560]  для простоты в Neo4j, вот если вы туда зайдете на сайт Neo4j, посмотрите руководство,
[31:54.560 --> 32:00.560]  туториал для начинающих, там прям предлагается создать графовую базу данных по кинофильмам.
[32:00.560 --> 32:08.560]  Может быть, это не очень актуально, я, честно говоря, не перепроверял на 24-й год, что там с туториалом,
[32:08.560 --> 32:16.560]  но там это точно было, и там, соответственно, вы создаете свой граф по кинофильмам,
[32:16.560 --> 32:22.560]  по актерам, режиссерам, создаете вот такую графовую структуру, и там такие концептуальные пересыливания идут.
[32:23.560 --> 32:30.560]  Мы можем говорить об этом как о некой верхней уровне абстракции по отношению к реалиционной модели?
[32:30.560 --> 32:37.560]  Можем. Что это значит? Это значит, что мы можем это развернуть так, что у нас вершины этого графа на рисунке
[32:37.560 --> 32:43.560]  будут представлять собой таблички, и тогда у нас кинофильм, это будет табличка с кинофильмами,
[32:43.560 --> 32:45.560]  продюсер, табличка с продюсерами и так далее.
[32:45.560 --> 32:50.560]  Между ними все равно останутся отношения, там будут первичные ключи, внешние ключи,
[32:50.560 --> 32:58.560]  а вот эти вот взаимосвязи по ключам, они будут формировать дуги графа, вершины графа будут представлены в таблицах,
[32:58.560 --> 33:04.560]  и по большому счету, о чем мы с вами говорим. Это все такое, знаете, интеллектуальное упражнение, что ли,
[33:04.560 --> 33:07.560]  небольшая эквилибристика интеллектуальная.
[33:07.560 --> 33:17.560]  Поэтому просто следует знать, что у нас есть разные варианты представления данных,
[33:17.560 --> 33:24.560]  есть, можно точно выделить иерархический, сетевой и реалиционный, они друг от друга отличаются,
[33:24.560 --> 33:30.560]  иерархический сетевой они, вот иерархический является подможеством сетевого, да, с логической точки зрения,
[33:30.560 --> 33:40.560]  в сетевом можно данные, между ними там строить, взаимосвязи допускающие закольцовывание, в иерархической модели,
[33:40.560 --> 33:48.560]  это последовательная такая вертикальная структура, грубо говоря, там, ну, едва ли не от общего к частному,
[33:48.560 --> 33:58.560]  а реалиционная модель, она основана на отношениях между, она основана на таблицах.
[33:58.560 --> 34:07.560]  Давайте вот так, для простоты, реалиционная, соответственно, иерархическая сетевая на таблицах не основана, вот, примерно так.
[34:07.560 --> 34:14.560]  Хорошо, так, сетевые модели иногда не возвращаются в виде графовых моделей в графовые УПД, да,
[34:14.560 --> 34:21.560]  и вот из официального туториала, прям, как интерпретировать реалиционные данные в графовые,
[34:21.560 --> 34:35.560]  переводя там из, не знаю, позгресса, условно того же, в Neo4j, вот, строка таблицы, это вершина, имя таблицы,
[34:35.560 --> 34:43.560]  то есть, имя отношения, это label name, ну там, с label там своя, есть такая, как бы, свои метки специальные для внутри узлов,
[34:44.560 --> 34:52.560]  внутри вершин в Neo4j, и join, операция объединения или внешние ключи, это, собственно, отношения, ну, грубо говоря, дуга,
[34:52.560 --> 34:59.560]  между двумя вершинами в Neo4j, ну, поэтому все это так, как бы, из одного в другой перетекает.
[34:59.560 --> 35:09.560]  Хорошо, ура, так, реалиционная модель, основные концепции сформулированы в статье кодом,
[35:09.560 --> 35:18.560]  тогда уже он сказал, что такое атрибут, отношения, домен, или домен, как уж хотите, понятие нормальной формы,
[35:18.560 --> 35:26.560]  ну, нормальная форма у него, наверное, вот, первая нормальная форма, наверное, вот так, я бы сказал, описана в первую очередь в этой работе,
[35:26.560 --> 35:37.560]  а их, в принципе, много, мы будем с вами говорить о трех, четырех, но их там вплоть до восьми, девяти, что-то, не скажу точно, не перепроверял,
[35:37.560 --> 35:49.560]  там просто можно дальше нормализовывать то, как данные представлены, но об этом мы поговорим с вами позже, пока можно на этом не зацикливаться сильно.
[35:49.560 --> 36:00.560]  Так, описал также применимые теоретико-множественные операции, и вот журнал Forbes поместил реалиционную модель в список важнейших инноваций последних 85 лет.
[36:00.560 --> 36:12.560]  Еще раз читаем кода. Сейчас, подождите, так, реалиционная модель состоит из трех аспектов, структурного, целостного и манипуляционного,
[36:12.560 --> 36:24.560]  в принципе, это похоже на то, что говорил Код в 80-м году, что данные, операции и поддержание целостности. Что такое структурный аспект?
[36:24.560 --> 36:39.560]  Вот основные понятия. Domain – это множество допустимых значений, фактически то же самое, что и тип данных. Атрибут – это наименование домена, грубо говоря, заголовок столбца.
[36:39.560 --> 36:53.560]  Cartesian – порядочный набор фиксированной длины, примерно то же самое, что строка в таблице. Отношение – это множество картежей на декартовом произведении некоторых множеств атрибутов.
[36:53.560 --> 37:12.560]  Отношение состоит из заголовка и тела, и примерно это равно таблице. Так что вот дословно реалиционная модель, модель таблиц, ребята.
[37:12.560 --> 37:30.560]  Вот для простоты здесь нет какой-то глубокой теории, на этом даже можно не останавливаться. Вот отношение таблицы, картежа строка, атрибут, заголовок столбца, домен, то, что можно в ячейку положить.
[37:30.560 --> 37:57.560]  Целостный аспект подразумевает, что реалиционная модель обеспечивает целостность сущности и ссылочную целостность. Ну, грубо говоря, она обеспечивает возможность сохранения данных непротиворечивыми, возможность проведения транзакций без потери целостности данных, сохранение состоянией базы данных, сохранение состоянией данных между транзакциями.
[37:57.560 --> 38:20.560]  Манипуляционный аспект модели, именно модели это реалиционные алгебры или реалиционные исчисления, но мы об этом поговорим с вами кратенько, но главное, помнить надо, наверное, следующую штуку очень интересную, но на практике вы ее не будете использовать, кроме университета, едва ли, разве, пожалуй, что никогда.
[38:20.560 --> 38:49.560]  Ну вот, sad but true. На самом деле это такая шутка юмора, на самом деле это нужно знать, ну это как бы определенный показатель, по крайней мере, того, что вы понимаете, о чем идет речь. Мы сейчас с вами должны посмотреть немножко реалиционные алгебры, а реалиционные исчисления мы не будем затрагивать, но в принципе оно семантически эквивалентное и основано на логике претикатов.
[38:50.560 --> 38:55.560]  Счислений претикатов первого порядка. Реалиционные алгебры основаны на теоретике множественном подходе.
[38:55.560 --> 39:14.560]  Пример реалиционной модели. Вот вам реляция, вот вам отношения, вот таблица. Заголовок это таблицы, заголовок остальные строки это телоотношения, каждая строка кортеж.
[39:14.560 --> 39:33.560]  Наименование заголовков это атрибуты некоего отношения, а в каждой ячейке содержится соответственно значение своего домена. Вот домен натуральные числа в атрибуте ID.
[39:33.560 --> 39:47.560]  Тут, в общем, наверное, все, мне кажется, здесь наглядно и просто. Какой-то особо глубокой теории за этим не стоит. Это не математический анализ.
[39:47.560 --> 39:59.560]  И в принципе достаточно для эффективной работы просто представлять, что отношения это таблицы.
[39:59.560 --> 40:09.560]  Пример кортежа, соответственно, тоже на рисунке. Операция реалиционной алгебры. Теоретика множественная и реалиционная.
[40:09.560 --> 40:22.560]  Теоретика множественная, объединение, разность, пересечение. Реалиционные добавлены кодом. Они не совсем новые по отношению к теоретикам множественным, но они несколько специфические.
[40:23.560 --> 40:30.560]  И принято говорить о том, что они такие специфические для данной модели.
[40:30.560 --> 40:49.560]  Нам нужно для рассмотрения реалиционной алгебры понимать, что такое декартовое произведение. Не будем на этом тоже сильно останавливаться, потому что я думаю, что если вы попали до наших курс, вы знаете, что такое декартовое произведение.
[40:49.560 --> 41:08.560]  Определение формальное представлено на слайде. Расширенное декартовое произведение. То есть когда у нас появляются множество видов того, что мы с вами видели выше. То есть то, что представимо в виде таблиц.
[41:08.560 --> 41:30.560]  И появляется несколько множеств. Расширенное декартовое произведение на примере конкретной таблицы. Вот у нас таблица Q, таблица R, результирующая таблица Z.
[41:30.560 --> 41:41.560]  Мы видим, что у нас все строки таблицы Q сцепляются со всеми строками таблицы R. У нас появляются в таблице Z два Ивановых, два Петровых, два Васильевых.
[41:41.560 --> 41:59.560]  Потому что у нас в таблице R два значения. Мы должны продублировать каждую строку так, чтобы... Мы должны строки задублировать так, чтобы у нас каждая строка с каждой соединилась.
[41:59.560 --> 42:19.560]  Сцепление кортежей здесь довольно просто. Буквально практически конкатенация. Формальное определение отношения для тех, кого очень интересно.
[42:19.560 --> 42:32.560]  От себя скажу, что запоминать его смысл, наверное, для экзамена имеет смысл. Для практики достаточно того, что это таблица.
[42:32.560 --> 42:44.560]  Опять же, для большей, может быть, какой-то наглядности, рекомендую, отсылая вас опять к первоисточнику, к Эдгару Коду, у него все это кажется, что написано менее сухо.
[42:44.560 --> 42:57.560]  И повторюсь, статья тема интересна, что человек в своей работе пытался решить какие-то практические проблемы и подогнал под это дело, разработал, доработал под это дело математический аппарат.
[42:57.560 --> 43:08.560]  И это просто интересно с такой инженерной точки зрения, как разрабатываются такого рода модели и в последствии системы.
[43:08.560 --> 43:22.560]  Ну, формальное определение отношения. Отношение R, определенное на атрибутах a1, a2, an. Мы помним, атрибуты это наши столбцы. Не все целиком, а именно заголовки.
[43:22.560 --> 43:31.560]  Называется под множество расширенного декартового произведения данных доменов.
[43:31.560 --> 43:47.560]  Вот краткий ответ, что такое революционная модель. Революционная модель, использующая, реализующая операции с отношениями, так как они определены на слайде.
[43:47.560 --> 43:58.560]  Свойства отношений. Нет двух одинаковых кортежей. Порядок отри... Ну и да, да, да. Давайте еще все-таки вернемся немножко, чтобы было на контрасте поярче видно.
[43:58.560 --> 44:15.560]  Мы здесь говорим про множество под множество декартового произведения. О чем бы мы с вами говорили в сетевой иерархической модели, если бы они разрабатывались не прикладными инженерами-программистами, а математиками тоже, как Эдгар Кот по аналогии.
[44:15.560 --> 44:26.560]  И шла бы разработка от математической основы к реальному воплощению. Вы бы с вами говорили о теории графов, конечно же. Здесь мы с вами говорим о теории множества.
[44:26.560 --> 44:36.560]  Ну понятно, там все можно представить одно через другое. Как бы тоже не будем на этом останавливаться. Это такая уже побочная тема.
[44:36.560 --> 44:44.560]  Но тем не менее, реляция это множество. Сетевая иерархическая модель это графы.
[44:44.560 --> 44:53.560]  Свойства отношений. Нет двух одинаковых кортежей. Порядок атрибутов в заголовке не определен. Порядок кортежей не определен. То есть у нас главное, что кортежи не дублируются.
[44:53.560 --> 45:05.560]  А что внутри отношения происходит с точки зрения атрибутов, какой порядок. И какой порядок записей в таблице. В общем случае, нас это не интересует.
[45:05.560 --> 45:17.560]  И в принципе, это даже не является каким-то стандартом. И вы можете получать ответы на свои запросы, исходя из этих предпосылок.
[45:17.560 --> 45:32.560]  То есть у вас может быть, если вы не специфицируете, при определенных условиях может быть разный набор, разная последовательность выходных данных, последовательность столбцов в таблице.
[45:32.560 --> 45:43.560]  Релиционные алгебры, формальные определения. Ну, ребят, давайте так. Слайды будут на GitLab. Со слайдами сможете ознакомиться.
[45:43.560 --> 45:55.560]  Опять же сможете почитать что-то подробнее, если кого-то интересует. Повторюсь, что в данном случае, в нашем курсе у нас математики будет минимум.
[45:55.560 --> 46:01.560]  И формальное определение нам здесь не особо нужно, но вот на слайде оно представлено, если кому-то очень интересно.
[46:01.560 --> 46:19.560]  А некоторые простейшие операции, о которых мы поговорим, это объединение отношений. Мы здесь в данном случае объединили две таблицы с семинаристами и получили результирующую таблицу.
[46:19.560 --> 46:27.560]  Здесь, обратите внимание, у нас не задублировались строки по умолчанию, вот такое вот поведение, поскольку у нас не должно быть двух одинаковых кортежей.
[46:27.560 --> 46:35.560]  А у нас, да, Меркурьева Надежда входит в две таблицы. Она, соответственно, не входит в результирующую дважды, по умолчанию во всяком случае.
[46:35.560 --> 46:47.560]  Она вошла, записи они вошла только один раз. Ну, довольно просто. Мы здесь, стоит сразу оговориться, это не Декартовы произведение, это вот именно объединение.
[46:47.560 --> 47:01.560]  То есть мы здесь просто по большому счёту дописали к первоначальной таблице или ко второй, к РЛС, что вы возьмёте за основу, это уже ваше дело, дописали недостающие записи из, соответственно, другой таблицы.
[47:01.560 --> 47:11.560]  Пересечение отношений. Мы, соответственно, нашли записи, которые у нас и в той, и в другой таблице находятся.
[47:17.560 --> 47:35.560]  Нашли записи, которые находятся в обеих, идентичные для обеих таблиц записи. Так, разность отношений. Нашли записи, которые у нас не повторяются для двух таблиц.
[47:35.560 --> 47:42.560]  Ну, кажется, наверное, что здесь всё довольно просто и интуитивно с точки зрения развития теоретика множественных подходов.
[47:42.560 --> 47:51.560]  Единственное, с чем здесь такая вот проблема в итоге может возникнуть. Сейчас, конечно, не возникнет. Здесь у нас всего два атрибута.
[47:51.560 --> 48:02.560]  Но когда атрибутов много, вот эти вот операции проводить сложнее. Когда атрибуты у нас пересекаются, то есть отдельные атрибуты пересекаются, но в целом кортежи не дублируют друг друга.
[48:02.560 --> 48:10.560]  Ну, если они не дублируют, то можно сказать, что они отличны друг от друга. А вот если они частично дублируют, тогда что?
[48:10.560 --> 48:19.560]  Ну, мы уже сказали, они вроде отличны друг от друга. Но вот воспринимать это, что называется, на листочке бумаги становится гораздо сложнее.
[48:19.560 --> 48:29.560]  Поэтому за счет столбцов, за счет наличия нескольких атрибутов здесь может быть некая такая непривычность и трудность.
[48:29.560 --> 48:42.560]  Но, на самом деле, она, ну, не знаю, наверное, посетит вас только при работе над какими-то примерами релиционной алгебры, которые вы будете решать на первом, может быть, втором семинаре.
[48:42.560 --> 48:58.560]  Применение нескольких операций тоже. Здесь просто последовательно, ну, как последовательно, в соответствии с правилами определения последовательности совершения математических операций мы вычисляем, что у нас должно быть в результате.
[48:58.560 --> 49:15.560]  Две разности и потом соответственно объединение. Здесь не будем тоже останавливаться. Можете проверить потом на слайде, так или не так, но вроде бы до вас пока еще здесь ошибок никто не нашел.
[49:15.560 --> 49:25.560]  Хорошо. Релиционные операции ограничения. Построение нового отношения, в которого входит картежа, удовлетворяющаясь заданному условию.
[49:25.560 --> 49:41.560]  Опять же, обращаю ваше внимание, здесь у нас уже не теоретико-множественные, чисто теоретико-множественные операции, это уже такие операции специфичные для того, что мы с вами рассматриваем.
[49:41.560 --> 49:56.560]  Определение приведено на слайде. В принципе, что здесь? Ну вот проблема, наверное, давайте слух проговорим, что допустимо только сравнение между собой значений составных атрибутов в рамках одного картежа.
[49:56.560 --> 50:20.560]  Ну да, да, да, да, да. То есть мы в принципе, что мы здесь ограничиваем наш отношение некоторым набором атрибутов и мы можем буквально это сделать.
[50:20.560 --> 50:42.560]  Здесь сложно, наверное, что-то добавить концептуальное. Вот математические выкладки, они опять же у вас на слайдах. Есть вот различного рода вариации ограничений, но по большому счету важно то, что нам это дает.
[50:42.560 --> 50:59.560]  Нам это дает вот что. Мы можем сделать запрос, в котором мы поставим некое условие, ну в данном случае на количество баллов, полученных за какую-то академическую активность.
[50:59.560 --> 51:14.560]  Вот и все, вот так работает ограничение. Много символов, много и красивые с первого взгляда математики, на практике довольно тривиальная, наверное, операция.
[51:14.560 --> 51:38.560]  Проекция, ребята, тоже давайте мы, наверное, с математикой не будем здесь как-то особо заморачиваться, просто покажем уже, что есть по факту. По факту происходит вот что. Мы можем выбрать конкретный атрибут, то есть мы можем сделать результирующее отношение Q, сказав, что мы хотим взять из R только определенный атрибут.
[51:38.560 --> 51:55.560]  Тогда по правилам революционной алгебры у нас останется, по правилам даже революционной модели у нас останется, останутся кортежи, которые не дублируют друг друга. Вот из всех, из множества вот этих записей, восьми слева, у нас осталось только четыре уникальные записи.
[51:55.560 --> 52:24.560]  Проекция. И соединение. Собственно вот, мы здесь соединили по UID две таблицы и получили мы таблицу результирующую Q, в которой у нас получается, мы взяли, здесь уже работает Декартово как раз произведение.
[52:24.560 --> 52:48.560]  Здесь мы взяли у каждой таблицы, у каждой записи в таблице R1, по UID мы взяли каждую запись в таблице R2 и присоединили недостающий атрибут к результирующему отношению таким образом, чтобы у нас для каждой итоговой записи он соответствовал атрибут.
[52:48.560 --> 53:10.560]  Вот запись в атрибуте StudentNM соответствовала userID, UID, за счет которого у нас происходит соединение. Мы по сути дела поставили условия на соединение, чтобы у нас UID совпадало в каждой таблице. Вот получили такое результирующее отношение.
[53:10.560 --> 53:32.560]  Деление здесь уже для общего виденья, потому что такая не очень распространенная, не то что с точки зрения практики, а с точки зрения формального описания операция.
[53:32.560 --> 53:55.560]  Деление, хотим получить сериалы из отношения 1, которые транслировались по всем каналам из отношения 2. Берем, делим одно на другое и получается, что мы выбрали по сути дела только The Simpsons и The Griffins.
[53:55.560 --> 54:20.560]  Не будем тоже на этом особо останавливаться. У вас, наверное, на семинарских занятиях будет подробнее, практически вы будете это делать подробнее, но в принципе, повторюсь, для какой-то специфики нашего курса, для каких-то принципиальных моментов нашего курса,
[54:20.560 --> 54:49.560]  понимание специфик, специфики революционной алгебры, оно не играет принципиальной роли, потому что это, конечно, подлежащая теория, ее нужно знать для общего понимания, но на практике то, с чем вы будете работать, оно довольно далеко и довольно, довольно даже не то что, наоборот, приближено к человеческому пониманию и языку. Правда, английскому, к сожалению, не русскому.
[54:50.560 --> 55:13.560]  Ну, ребята, это не за какую асимпточку выполняются все эти операции. Здесь это вопрос, знаете, он бессодержательный, применительный к математическим операциям, за какую асимпточку выполняется та или иная операция.
[55:13.560 --> 55:35.560]  Если вы помните CLRS, то там начинается все не с того, сколько стоит конкретный алгоритм, там идет описание того, какая формальная модель будет использована в дальнейшем в книге, какая формальная модель, на которой работают вот эти отношения.
[55:35.560 --> 55:51.560]  Мы с вами это не определяли, поэтому здесь нельзя говорить об асимптотике. Если вы хотите порассуждать о том, сколько конкретно займет та или иная операция, нам надо посмотреть реализацию этих операций внутри баз данных, посмотреть на конкретные алгоритмы и этим заниматься.
[55:51.560 --> 56:03.560]  А так, если мы говорим, грубо говоря, вставка в таблицу это единичка времени, удаление из таблицы единичка времени и так далее, ну давайте мы просто посчитаем что-нибудь простое.
[56:03.560 --> 56:22.560]  Так, ах, не в ту сторону, ну вот не знаю, вот 8 строк мы из них удалили, даже не так, вставка удаления изменения в каждой ячейке это единичка, мы из 24 ячейок удалили, сколько, 20 получается, правильно, да?
[56:22.560 --> 56:39.560]  Время 20, какие там будут циклы вложены или не вложены. Ребята, алгоритмы построения и анализ.
[56:39.560 --> 56:59.560]  У вас же алгоритмы и структуры данных курс был или идет, я надеюсь, там для этого всегда определяется какая-то некая модель формальная, в рамках которой происходит исполнение запросов.
[56:59.560 --> 57:11.560]  Поэтому здесь, ну без, не могу вам ответить, вот так вот без контекста, контекста нет, поэтому это чистая математика.
[57:11.560 --> 57:21.560]  Можете еще раз повторить про отделение, как получается из одной таблицы другая, то есть что мы выкидываем?
[57:21.560 --> 57:50.560]  Так, мы выкидываем, так у нас с Rantv и 2х2, сериалы из первого отношения мы хотим получить, мы делим таким образом, да, мы берем, нам нужно чтобы у нас и Rantv и 2х2 оставалось условие, да, что у нас по двум каналам это должно крутиться, поэтому у нас DuckTales не проходит.
[57:50.560 --> 58:04.560]  Мы берем только те сериалы, которые у нас по ChannelNM попадают, смотрите, курсор виден на экране, ребят?
[58:04.560 --> 58:07.560]  Нет, не виден.
[58:07.560 --> 58:27.560]  Так, ладно, хорошо, тогда без курса. Ну, обратите просто внимание, у нас должна быть вот пара, у нас не, в нашей, представьте себе, что у нас есть выделение ячейки, вот у нас выделение только будет не одной ячейки, а двух, вот по ChannelNM у нас будет выделение двух ячейок, Rantv и 2х2.
[58:27.560 --> 58:46.560]  И мы должны вот этим вот двойным выделением пройтись по таблице R, и у нас туда попадут все те двойные, сдвоенные, грубо говоря, ну, вот на пальцах, сдвоенные строки, которые есть в таблице R.
[58:46.560 --> 58:53.560]  Здесь сдвоенных строк Rantv и 2х2 только четыре получается, ну или две сдвоенных, это The Simpsons и Family Guy.
[58:53.560 --> 59:06.560]  С DuckTales так не получается, у нас не находятся двух кортежей, которые бы соответствовали условию для ChannelNM, у нас он только один кортеж, DuckTales и 2х2.
[59:06.560 --> 59:30.560]  Примерно так, что ли? Если вы хотите какой-то алгоритм деления, давайте так, если это будет прям сильно интересно, давайте я прям целый слайд посвящу на следующей лекции, а сейчас уже, наверное, уже 31 минуты.
[59:30.560 --> 59:53.560]  Давайте на этом мы тогда будем заканчивать, к сожалению, довольно много еще информации мы не успели. Ну хорошо, смотрите. У вас когда следующая пара? 13.45?
[59:53.560 --> 59:57.560]  13.55, у нас вообще пара без 15.
[59:57.560 --> 01:00:16.560]  Хорошо. А, все, извините, да, прошу прощения, извините, ребят. Все, тогда замечательно, смотрите, по делению, давайте алгоритм мы отложим, не готов вам сейчас вот так вот на, как бы более просто объяснить, не могу.
[01:00:16.560 --> 01:00:35.560]  Давайте мы двинемся дальше, к делению вернемся, как я сказал, следующую субботу. Смотрите, реляционные базы данных и реляционные СОБД. То есть мы спускаемся по нашей лестнике все ниже, ниже и ниже.
[01:00:35.560 --> 01:00:59.560]  Мы начали с того, что такое базы данных, модели данных, просмотрели, кратенько пробежались по тому, что такое модель, какие модели данных есть и что такое реляционная модель, какие у нее специфические элементы и какие операции она предполагает, операции реляционной алгебры.
[01:00:59.560 --> 01:01:17.560]  По ним тоже кратенько мы посмотрели, пробежались. Там, повторюсь, ничего сложного нет, сложность только в том, что у нас в отличие от просто таких вот до плоских множеств, что ли, которые состоят из дискретных элементов, у нас получается множество множеств.
[01:01:17.560 --> 01:01:30.560]  И у нас условия идут по этим вот вложенным множествам и пробегаться приходится по ним, поэтому это немножко бывает контринтуитивно, если нет практики обращения с реляционными операциями.
[01:01:30.560 --> 01:01:43.560]  Вот так вот. Смотрите, теперь спускаемся еще ниже, спускаемся на уровень уже конкретных, уже реляционных систем управления базами данных.
[01:01:43.560 --> 01:02:02.560]  И как это в общем случае так? Да, Корман, Корман, да, путаю все время его, то Кроман, Корман, тоже меня извините, но CLRS в общем по-английски по-моему так по первым буквам, ну или алгоритм построения анализов.
[01:02:02.560 --> 01:02:17.560]  Как-то сложно сказали, смотрите еще раз, ребят, по асимптотике нельзя определить асимптотику математических операций, не имея какой-то модели их исполнения.
[01:02:17.560 --> 01:02:28.560]  Мы модель исполнения не рассматриваем, мы только математические операции рассматриваем. Если мы сформулируем с вами модель исполнения, среду выполнения, среду исполнения какую-то и скажем, что там такая-то операция столько-то стоит,
[01:02:28.560 --> 01:02:43.560]  мы тогда сможем посчитать там B-CODE и так далее и тому подобное. Не построить какой-то формализованный алгоритм, мы даже алгоритма не видели, мы просто, ну так там были теоретикам множество, вернее мат-логика там была немножко,
[01:02:43.560 --> 01:02:55.560]  предикативная, но тоже мат-логику мы не переведем даже по-моему напрямую. Ну да, нужно какие-то процедурные алгоритмы вписать обобщенно. Ладно, все, извините.
[01:02:55.560 --> 01:03:23.560]  Ребят, я, вопрос DZ, можно будет за O экспоненциально от N, ну за O в Н в степени E? Не совсем тоже, понимаю вопрос, если у вас что-то в DZ есть связанное с определением
[01:03:23.560 --> 01:03:43.560]  времени исполнения, ну не готов сейчас это обсуждать, может быть, на следующей лекции. Хорошо, либо я не понял вопроса, извините. Можно будет написать и к следующей, уже там куда-нибудь в чат, следующую лекцию попробуем обсудить.
[01:03:43.560 --> 01:04:06.560]  Так вот, система управления базами данных, в частности, реляционными, но, в принципе, наверное, они плюс-минус такие же были бы и есть для нереляционных. Смотрите, общая схема какая? У нас есть разные уровни, отвечающие за разные элементы обработки.
[01:04:06.560 --> 01:04:16.560]  Начнем, наверное, с самого низа. Это storage engine, который у нас отвечает за работу с физическим уровнем, за работу с памятью непосредственно.
[01:04:16.560 --> 01:04:38.560]  Дальше идет уровень выполнения, уровень процессора запросов и транспортный уровень, ну это уже такой, знаете, транспортный уровень этой серии, как это все распределено по сети, какие есть интерфейсы для коммуникации.
[01:04:38.560 --> 01:05:07.560]  А что здесь, наверное, можно отметить, что у нас уровень движка хранилища, он в Postgres неизменяемый. Например, в MySQL можно разные storage engines втыкать, грубо говоря, извините за сленг, в MySQL, и, ну, как бы немножко варьируется это все в зависимости от среды, в зависимости от того, как та или иная база, где она развернута и как функционирует.
[01:05:08.560 --> 01:05:37.560]  Процессор запросов у нас он занимается партингом и оптимизацией, переводит все это во внутреннее представление, какой-то вот внутренний, внутренний исходный там, ну в оригинале там прям говорится source code, исходный код, но переводит какой-то внутреннее машины читания.
[01:05:38.560 --> 01:06:03.560]  Ну, в общем, в общем, это выглядит вот так вот. Движок выполнения execution engine за неимение, за неимение, за неимение, за неимение, за неимение, за неимение, за неимение, за неимение, за неимение, за неимение.
[01:06:03.560 --> 01:06:24.560]  Движок выполнения execution engine за неимением, да, такой калькируемый, калькированный перевод, он у нас отвечает за, собственно, отправление запросов куда-то по сети, за, там, следить за временем, следить за нагрузкой.
[01:06:24.560 --> 01:06:40.560]  Ну, такие, да, промежуточные какие-то вещи между, выполняют между процессором запросов и движком хранилища. В принципе, наверное, мне кажется, из схемы плюс-минус должно быть понятно, что за что отвечает.
[01:06:40.560 --> 01:06:55.560]  Ну, еще раз, транспортный уровень – это уровень сети и уровень отдельных клиентских машин, которые посылают запросы. Уровень процессора запросов – это парсинг и оптимизация.
[01:06:55.560 --> 01:07:19.560]  Уровень исполнения – это распределение запросов по сети, по работающим каким-то или неработающим узлам, отслеживание выполнения. Уровень хранилища – это непосредственно самый низкоуровневый элемент, когда база работает с тем, с файлами на конкретных дисках.
[01:07:20.560 --> 01:07:40.560]  Так, обобщенная схема обработки запроса. Выглядит она вот следующим образом. Мы посылаем запрос, запрос идет в парсер, проверяется синтаксис, проверяется семантика, то есть правильная расстановка точек с запятой, отступы, скобки.
[01:07:40.560 --> 01:08:09.560]  Использование правильных семантических конструкций и проверка наличия в пуль запросов. Что это такое? Это оптимизационные механизмы, когда проверяется, есть ли аналогичный запрос уже в некоем пространстве исполнения, и можно ли просто его повторить, не проводя там шаг оптимизации.
[01:08:10.560 --> 01:08:34.560]  Если нет, то идет оптимизация, генерируется несколько различных планов запроса, выбирается на основе некоторых внутренних данных, статистических баз данных, потому что база ваша следит за тем, что выполняется в ней, какие команды она совершает, за какое время это происходит, какая идет нагрузка на те или иные элементы.
[01:08:34.560 --> 01:08:56.560]  Ну, понятно, сеть она вам отслеживать всю не будет, но, тем не менее, у нее определенный селфатеншн механизм, что называется, есть, и статистику свою она ведет, соответственно, она может генерировать тот или иной план, тот или иной способ выполнения одного и того же запроса в зависимости от того, в каком она сейчас состояние, насколько она нагружена.
[01:08:56.560 --> 01:09:05.560]  Далее это все транслируется в низкоуровневое представление, происходит непосредственное выполнение работы с непосредственной информацией, хранящейся на диске, и вам возвращается результат.
[01:09:05.560 --> 01:09:28.560]  Так, рейтинг релиционных СОБД по сайту, ой, 2023 год, прошу прощения, в лекции на слайде обновлю, но вот, по большому счету, состояние года назад рейтинг вот такой, но он вряд ли сильно поменялся.
[01:09:28.560 --> 01:09:58.560]  Далее это все транслируется в низкоуровневое представление, происходит непосредственное выполнение работы с непосредственной информацией, хранящейся на диске, по большому счету, состояние года назад рейтинг релиционных СОБД по сайту, но вот, по большому счету, состояние года назад рейтинг
[01:09:58.560 --> 01:10:16.560]  релиционной памяти, это буквально один файл на вашем диске и буквально один файл библиотечки. Для каких-то маленьких ПЭД-проектов или для мобильных приложений вообще очень приятная классная штука.
[01:10:16.560 --> 01:10:45.560]  Повторюсь, мы будем использовать Postgres. В нашем курсе все рассматриваемые БД поддерживают основные функции, но есть некоторые различия. SQLite, как я уже сказал, это встраиваемая база данных, не использует клиент серверную модель, ну, понятно, что вы можете ее закинуть на сервер, как бы вы можете сделать свой сервер базы данных используя SQLite, вам никто не запрещает.
[01:10:45.560 --> 01:11:05.560]  Изначально из коробки у нее нет отдельного процесса, который у вас работает фоном, и другие процессы клиента обращаются к этому серверному процессу на одной или этой машине, на разных, такого нет. Это просто файл, который выполняется в вашей программе непосредственно, практически.
[01:11:05.560 --> 01:11:20.560]  Ну, так вот, не вдаваясь в детали, такое очень грубое описание файла, выполняющееся в вашей программе, извините, сразу оговорюсь, что это просто в таких педагогических целях упрощения, ограбления.
[01:11:20.560 --> 01:11:34.560]  Вся база хранится в одном файле, БД полностью блокируется при записи, но может поддерживать конкурентное чтение. MySQL поддерживает разные storage-engine, storage-engine показывает лучшие результаты в операциях чтения файлов,
[01:11:34.560 --> 01:11:39.560]  но не так хорошо в конкурентных запросах, как Postgres.
[01:11:39.560 --> 01:11:46.560]  Ну, также более сложная репликация, меньше устойчивость к конкурентным операциям, наименее соответствует стандарту SQL.
[01:11:46.560 --> 01:12:02.560]  Ну и Postgres, наша стандартная база, с которой, повторюсь, вы будете работать, совмещает в себе достоинство предыдущих двух до некоторой степени.
[01:12:02.560 --> 01:12:18.560]  Ну вот, была выбрана именно она, поскольку все-таки сейчас Postgres это является таким, ну, де-факто, что ли, современным, по крайней мере, стандартом MySQL, хоть она и была на втором месте в предыдущем графике,
[01:12:18.560 --> 01:12:28.560]  но вот как-то на практике кажется, что отходит она все-таки подальше в каких-то реальных и новых проектах.
[01:12:29.560 --> 01:12:51.560]  Конкурентные, одновременные запросы, то есть просто выполняемые, как сразу, многопоточность, многозадачность, ребята, конкурентное выполнение, вы как там, на какой стадии изучения всех этих прибудных вещей.
[01:12:51.560 --> 01:13:11.560]  Конкурентные запросы, то есть запросы, одновременные запросы, ну или запросы с небольшим интервалом времени, к одному ресурсу, например, или просто запросы одновременные, к разным ресурсам, но выполняемые одной средой, в данном случае, одним программом обеспечения, в данном случае, системы управления базой данных.
[01:13:11.560 --> 01:13:21.560]  В этом смысле они конкурентные. То есть конкурентные запросы, это когда нужно одновременно либо что-то прочитать, либо что-то записать, либо что-то удалить.
[01:13:21.560 --> 01:13:38.560]  Соответственно встает вопрос, что делать, в чем проблема сама по себе. Встает вопрос, как здесь быть, если один пользователь говорит базе, что перепиши мне эту строку, а другой пользователь в этот же самый момент говорит базе, выдай мне эту строку.
[01:13:38.560 --> 01:13:48.560]  Вот пользователю выдать старую версию или новую версию, и пользователь, который хочет что-то записать, его заставить подождать, или наоборот его пропустить вперед.
[01:13:48.560 --> 01:14:06.560]  И вот здесь разные способы решения бывают. Ну буквально разные, там разные алгоритмы, есть разные подходы к ограничению операции чтения записи, разные уровни блокировки.
[01:14:06.560 --> 01:14:25.560]  СQL, собственно. Тоже немного истории. В общем виде разработан в 1973-1974 годах. Звонок был. Все, ребята, я вас понял. Давайте тогда просто два слова об SQL.
[01:14:25.560 --> 01:14:51.560]  Немного мы, к сожалению, не дошли до конца. Ну как немного, прилично. Ладно. Что интересно, он был разработан вот с намерением, видите, выжарено на шрифте, на слайде написано, что инженеры-разработчики хотели сделать настолько простой язык, насколько это было бы возможно, чтобы обычный человек просто как бы пришел, сел и начал бы направлять запросы к базе данных.
[01:14:51.560 --> 01:15:08.560]  И у них объем статьи, в которой они из SQL предложили, было всего 16 страниц. Там буквально несколько страниц было на формальное описание синтаксиса. Вот всего две страницы, как указано. Сегодня же стандарт SQL занимает несколько тысяч страниц.
