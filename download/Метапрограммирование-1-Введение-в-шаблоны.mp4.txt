[00:00.000 --> 00:13.000]  Теперь, надеюсь, хорошо. Как и было анонсировано в прошлый раз, мы будем продолжать с шаблонами разбираться.
[00:13.000 --> 00:19.000]  Вот просто механика шаблонов. Сейчас там какие-то выяснения. Давайте чуть-чуть подождем.
[00:19.000 --> 00:36.000]  Все, да? Отлично. Вот. Я не могу собраться с мыслями, если хотя бы еще один человек параллельно со мной говорит, поэтому, пожалуйста, не делайте этого. Окей? Спасибо.
[00:36.000 --> 00:45.000]  Ну, это абсолютно у всех так работает, мне кажется. Давайте идти. Мы будем повторять паттерны в первую очередь, потом пойдем к шаблонам.
[00:45.000 --> 00:55.000]  Эти паттерны здесь постольку, поскольку они исторически здесь появились, о чем я вроде в прошлый раз сказал. Есть замечательная книжка Александреску.
[00:55.000 --> 01:06.000]  Сегодня вечером я выложу репозиторий, там все ссылки будут. Где он, соответственно, рассуждает о том, как всякие разные паттерны в шаблонах реализовывать и получать от этого профит.
[01:06.000 --> 01:14.000]  Ну или, наоборот, можно сказать, он рассуждает о том, как использовать шаблоны, чтобы с этими паттернами было удобнее работать.
[01:14.000 --> 01:24.000]  Ну, давайте просто сначала повторим подряд все сплошняком паттерны. Вот за полчаса, я надеюсь, мы управимся. Вы же умные и, конечно же, их знаете уже давно.
[01:24.000 --> 01:35.000]  И, конечно же, вы их не могли забыть. Начнем с видов. Там три категоризации, они мутные, ничего особо не значат, там одно сюда запихнуто, другое туда.
[01:35.000 --> 01:42.000]  Ну, так сложилось исторически. Порождающие структурно и поведенческие. Ничего нового. Поехали с порождающих.
[01:42.000 --> 01:56.000]  Фабричный метод. Еще с курса ТП я заметил, а еще с ГОСов, а еще с экзамена по ТП, что у людей нет понимания, что такое фабрика, что такое фабричный метод, почему там вообще два разных паттерна.
[01:56.000 --> 02:05.000]  Давайте про фабричный метод. Это один метод. Вот то, что здесь какой-то диалог Windows Box, все это не имеет отношения к фабричному методу.
[02:06.000 --> 02:10.000]  Вот Create Button. Вот это фабричный метод. Все остальное это декорация.
[02:10.000 --> 02:17.000]  Кто-нибудь может объяснить нам в двух словах, зачем вот этот Create Button и в чем состоит, собственно, паттерн?
[02:17.000 --> 02:22.000]  Смотря на эту диаграмму. Она для вас не должна быть новой. Правда, Вить?
[02:23.000 --> 02:31.000]  Дебе черная кнопка, белая кнопка. И там хочется во время исполнения понимать.
[02:31.000 --> 02:35.000]  Кнопки, кнопки они везде одинаковые, поэтому нам не нужно...
[02:35.000 --> 02:48.000]  Не хочется явно вызывать конструктор объектов. Хочется иметь метод, который создавал бы его. Возможно, если конструктор какой-то нетривиальный, или нужно создать объект в системе, то нужна вот эта вот фабрика.
[02:48.000 --> 02:54.000]  Что-то вы такое говорите, оба близко к правде, но вот беда.
[03:00.000 --> 03:05.000]  Это опять общие слова. Вот вы сейчас описываете просто, что есть такое понятие как Interface.
[03:05.000 --> 03:15.000]  Если мы не хотим иметь изолированный объект, если мы хотим иметь доступ к объекту тока в системе, то мы не должны уметь создавать объект через конструктор.
[03:15.000 --> 03:24.000]  Нет, это ты описываешь... Похожий на этот паттерн по названию штуку, но абсолютно отличающийся от него существом.
[03:24.000 --> 03:34.000]  То же не то. Это все трюки, которые появились позже, чем вот этот паттерн, который не имеет отношения к ОП вообще никакого.
[03:34.000 --> 03:42.000]  И это трюки скорее как C++-у специфичные, что мы делаем конструктор приватным, делаем глобальную функцию, create что-нибудь.
[03:42.000 --> 03:48.000]  Ну, такое видели уже, make shared. Вот это вот некоторые люди называют фабричным чем-то там.
[03:48.000 --> 03:54.000]  Но мы не об этом сейчас. Это просто неловкое совпадение, что это называется одним и тем же словом.
[03:54.000 --> 03:58.000]  Ну окей, я не услышал ответа, который я хотел услышать, а он очень простой.
[03:58.000 --> 04:08.000]  У вас с консоли пользователь ввел чиселку 1, 2, 3, 4 или 5. Вы хотите в зависимости от этой чиселки создать разного наследника интерфейса button.
[04:08.000 --> 04:19.000]  Как это сделать? Сделать switch. Switch по чиселке. И в зависимости от этого делать либо new windows, либо new HTML button и все работает.
[04:19.000 --> 04:21.000]  Чем этот подход плох?
[04:22.000 --> 04:26.000]  Больше цифр, больше свичей.
[04:26.000 --> 04:29.000]  Ну как бы да, но почему это плохо-то?
[04:29.000 --> 04:34.000]  Блин, захотел новую кнопку добавить, иди дописывай свич-кейс новый. В чем проблема?
[04:34.000 --> 04:38.000]  Можно перекомпилировать новые функции, придется за них все перекомпилировать?
[04:38.000 --> 04:45.000]  Это тоже не особо большая проблема. Я предлагаю сейчас думать об OOP-абстрактном, а не конкретике плюсов, где с перекомпиляцией.
[04:45.000 --> 04:48.000]  Это тоже вообще-то не теряется.
[04:48.000 --> 04:56.000]  У вас есть место в коде, где написан свич, который ответственен за то, чтобы понять, в зависимости от ввода пользователя,
[04:56.000 --> 04:59.000]  что делать, какую кнопку создавать.
[04:59.000 --> 05:03.000]  Мы кнопку новую добавляем, и в десяти местах свич должен изменить.
[05:03.000 --> 05:10.000]  Ну, хорошо, давай сделаем функцию, в которой этот свич сохраним, и в одном месте придется менять.
[05:10.000 --> 05:15.000]  Не чувствуете? Беда!
[05:15.000 --> 05:19.000]  Но я этого ожидал, в принципе, поэтому все это здесь и есть.
[05:19.000 --> 05:24.000]  Тут просто есть очень простая истина, которая не только к OOP относится, не только к этим паттернам,
[05:24.000 --> 05:32.000]  и вообще некоторые наблюдения, что хорошее понимание этих паттернов, хоть не позволяет их использовать на практике,
[05:32.000 --> 05:36.000]  потому что, ну, нафига, но позволяет на практике другие вещи с ними лучше справляться.
[05:37.000 --> 05:40.000]  Вот о чем я всем говорю сейчас.
[05:40.000 --> 05:46.000]  Код расширяемый должен быть. У вас есть библиотека одна, в которой интерфейс-батон,
[05:46.000 --> 05:51.000]  а дальше есть несколько библиотек с HTML-батоном, Windows-батоном и прочим-прочим.
[05:51.000 --> 05:59.000]  Есть библиотека, которая там, ну, это все какой-то юзер, пользовательский интерфейс, кнопочки.
[06:00.000 --> 06:05.000]  Вы хотите ваше приложение под плойку адаптировать, но вот этот код под плойку
[06:05.000 --> 06:09.000]  он вообще никак не должен упоминаться в вашем основном коде.
[06:09.000 --> 06:13.000]  Почему? А потому что, да, если у вас какой-нибудь open-source-проект,
[06:13.000 --> 06:16.000]  то вы должны строго разделить его на две половины.
[06:16.000 --> 06:23.000]  Привет! Open-source-ная база и все, что специально для плойки, ни слова вообще не должно упоминаться
[06:23.000 --> 06:27.000]  в вашем open-source-ном этом, ну, иначе вас засудят мгновенно.
[06:27.000 --> 06:33.000]  Поэтому мы не можем просто сделать там PlayStation-батон, его инклюдить в основном коде программы
[06:33.000 --> 06:37.000]  и в свече создавать новый PlayStation-батон, вот здесь вот.
[06:37.000 --> 06:41.000]  Нам нужно, чтобы можно было создавать новые вот эти вот виды кнопок,
[06:41.000 --> 06:44.000]  в зависимости от пользовательского ввода, не меняя старый код вообще,
[06:44.000 --> 06:52.000]  не упомяная никак конкретных вот этих вот наследников интерфейса в общем коде.
[06:52.000 --> 06:56.000]  Ну и, в принципе, это правильный дизайн, что вы хотите систему расширить,
[06:56.000 --> 06:59.000]  только расширить, да, а вам почему-то старый код менять надо.
[06:59.000 --> 07:02.000]  Вот это признак плохого дизайна, вообще говоря.
[07:02.000 --> 07:06.000]  Расширяемость должна без изменений каких-то там вообще других мест,
[07:06.000 --> 07:11.000]  ну, по там разным причинам, это, конечно, само по себе наблюдение бесполезное.
[07:11.000 --> 07:16.000]  Ну вот, поэтому что мы делаем? Мы делаем другую иерархию,
[07:16.000 --> 07:20.000]  ну, вернее, тут уже какая-то иерархия была.
[07:20.000 --> 07:25.000]  Вот и кнопку создавать, оказывается, нужно, ну, не где-то в абстрактном месте в коде,
[07:25.000 --> 07:31.000]  а вот именно в рамках этой иерархии, в зависимости там от чего-то.
[07:31.000 --> 07:38.000]  Ну и вам нужно просто добавить метод, который возвращает button.
[07:38.000 --> 07:44.000]  И вот в базовом классе диалог там, ну, собственно, весь код, да, вся логика,
[07:44.000 --> 07:48.000]  что вот вы там с каким-то диалогом работаете, кнопку нажимаешь, что-то происходит,
[07:48.000 --> 07:51.000]  оно зашито здесь, но это как бы абстрактный класс.
[07:51.000 --> 07:56.000]  Он, когда ему нужно создать кнопку, ну, тут я простой пример привел,
[07:56.000 --> 08:00.000]  что в зависимости от циферки на консоль введён, на деле же, конечно же, не так,
[08:00.000 --> 08:04.000]  в зависимости от какой-нибудь конфига или платформы или ещё чего-нибудь такого, не важно.
[08:04.000 --> 08:07.000]  Но вот в какой-то момент диалогу нужно создать кнопку.
[08:07.000 --> 08:12.000]  Он не создаёт настоящую кнопку, а просто вызывает виртуальный метод.
[08:12.000 --> 08:18.000]  И всё. А дальше оказывается, что на самом деле в объект такого типа мы никогда не создаём,
[08:18.000 --> 08:22.000]  а создаём объекты типов наследников, которые живут уже в ваших библиотеках
[08:22.000 --> 08:27.000]  для конкретных платформ, для там Windows, для Web.
[08:27.000 --> 08:34.000]  Перегружаете там этот метод, и в нём создаёте кнопку нужную для нужной платформы.
[08:34.000 --> 08:39.000]  Понятно ли сейчас стало? Я чувствую, что нет.
[08:39.000 --> 08:45.000]  Ещё раз, можно оточнить как диалог, вот это диалоговое окно и батон, как они связаны?
[08:45.000 --> 08:49.000]  Связаны следующим образом. Диалогу хочется в какой-то момент создавать кнопки.
[08:49.000 --> 08:53.000]  Диалог хранит кнопку? Ему хочется создать кнопку.
[08:53.000 --> 08:58.000]  Но у него не хранится. Мы создали новый диалог, у него пока кнопок нет.
[08:58.000 --> 09:02.000]  В какой-то момент по ходу своей работы он захотел создать новую кнопку.
[09:02.000 --> 09:06.000]  Может в конструкторе даже, это не проблема. Но как ему её создать?
[09:06.000 --> 09:13.000]  Хранится как бы да, хранится. Как-то. По интерфейсу главное что?
[09:13.000 --> 09:16.000]  Абстрактную кнопку хранит, по интерфейсу у нас ОП.
[09:16.000 --> 09:21.000]  А вот по интерфейсу экземпляр создать нельзя, нужна какая-то конкретная кнопка.
[09:21.000 --> 09:24.000]  Мы говорим, что не он решает, какую кнопку создавать.
[09:24.000 --> 09:27.000]  Он это делегирует через виртуальный метод своим наследником.
[09:27.000 --> 09:34.000]  И вот этот виртуальный метод, который создаёт кнопки, он и называется как бы фабричным методом.
[09:34.000 --> 09:41.000]  ОК. То есть вы можете новую платформу сюда прилепить, просто отнаследовав диалог, отнаследовав кнопку.
[09:41.000 --> 09:46.000]  Вот внаследовании диалога вы ровно одну функцию кастомизируете, create button.
[09:46.000 --> 09:53.000]  То есть минимум усилий прикладываете к тому, чтобы можно было, чтобы расширить эту систему.
[09:53.000 --> 09:58.000]  То есть как? Switch был заменён на виртуальный вызов.
[09:58.000 --> 10:05.000]  Это в принципе общая схема всего вот этого замечательной бодяги с паттернами и ООП подходом.
[10:05.000 --> 10:11.000]  Ну кто-то из вас, я посмотрел по чату, оказывается ходил ко мне много лет назад на ООП.
[10:11.000 --> 10:14.000]  На ТП, извиняюсь, на ТП.
[10:14.000 --> 10:20.000]  И там я тоже самое примерно загонял, поэтому очень странно, что никто не помнит.
[10:20.000 --> 10:23.000]  Но с другой стороны, 4 года прошло.
[10:23.000 --> 10:29.000]  ОК. Есть ли какие-то вопросы про вот это вот? Вы поняли идейно, что происходит?
[10:29.000 --> 10:34.000]  ОК. Дальше начинается... А, ну это то же самое, да?
[10:34.000 --> 10:39.000]  Да, это то же самое, но с абстрактными какими-то разметками.
[10:39.000 --> 10:42.000]  Что у нас есть какая-то иерархия тех, кто хочет создавать объекты.
[10:42.000 --> 10:46.000]  Есть какая-то иерархия объектов.
[10:46.000 --> 10:52.000]  Ну и вот мы за счёт добавления виртуального метода createProduct умеем его кастомизировать на следниках.
[10:52.000 --> 10:57.000]  ОК. А вот это фабрика. То есть до этого была не фабрика.
[10:57.000 --> 11:00.000]  Был фабричный метод. А теперь фабрика.
[11:00.000 --> 11:07.000]  Где мы говорим, что мы уже не будем просто в какую-то существующую иерархию типа диалогов вшивать новый метод,
[11:07.000 --> 11:09.000]  когда нам понадобилось кнопки создавать.
[11:09.000 --> 11:15.000]  А мы прямо отдельную специальную иерархию сделаем для создания кнопок. Да?
[11:15.000 --> 11:19.000]  WinFactory, GUI Factory, MacFactory.
[11:19.000 --> 11:25.000]  И в этой иерархии даже может быть несколько разных функций создания чего-то.
[11:25.000 --> 11:30.000]  Тут есть для баттона, для чекбокса. Можно то создать, можно другое.
[11:30.000 --> 11:32.000]  Ну и на чём-то всё.
[11:32.000 --> 11:38.000]  Теперь вы в коде своём прикладном просто прокидываете разным подсистемам вот эти объекты в факторе.
[11:38.000 --> 11:40.000]  Ну, прокидываете по интерфейсу, конечно же.
[11:40.000 --> 11:46.000]  И теперь ваш прикладной код может просто у этого интерфейса позвать метод какой-то создай мне чё-то
[11:46.000 --> 11:52.000]  и получить некоторую абстрактную кнопку или абстрактный чекбокс, не зная какая там имплементация.
[11:54.000 --> 11:55.000]  Важный вопрос.
[11:55.000 --> 11:56.000]  Давай.
[11:56.000 --> 11:58.000]  Вот все эти объекты, которые создаёт абстракт фабрики.
[11:58.000 --> 12:04.000]  Может вопрос глупый, но сами в фабрике хранят в себе объекты, которые они создали?
[12:04.000 --> 12:06.000]  Нет.
[12:06.000 --> 12:13.000]  Их роль – это быть просто диспетчером вызовов, грубо говоря.
[12:13.000 --> 12:17.000]  Мы хотим диспетчеризовать вызов конструктора, по сути.
[12:17.000 --> 12:23.000]  Ну а потом забыть, какой конкретно объект получился после этого вызова, зная ли что получился,
[12:23.000 --> 12:27.000]  что есть интерфейс-батон, которому этот объект удовлетворяет.
[12:27.000 --> 12:30.000]  Ну и вот как-то так это и работает.
[12:30.000 --> 12:33.000]  Вот эта диаграмма в целом вам понятна же, правда?
[12:35.000 --> 12:41.000]  Я искренне надеюсь, что я сейчас нудные вещи, которые так понятно рассказываю, кроме вот этого вот…
[12:41.000 --> 12:42.000]  Можно вопрос?
[12:42.000 --> 12:43.000]  Да.
[12:43.000 --> 12:50.000]  То есть, предположим, мы сделали какую-то привожуху, которая вот сейчас мы под Windows ее делаем,
[12:50.000 --> 12:53.000]  и мы хотим всегда создавать одинаковые окна под Windows.
[12:53.000 --> 12:54.000]  Да.
[12:54.000 --> 13:01.000]  А потом мы когда переедем на Mac, мы хотим просто заменить вот эту фабрику,
[13:01.000 --> 13:04.000]  и у нас автоматом начнут создаваться окна под Mac.
[13:04.000 --> 13:05.000]  В этом идее?
[13:05.000 --> 13:07.000]  Да, не меняя старый код.
[13:07.000 --> 13:09.000]  Но тут есть еще одна важная деталь.
[13:09.000 --> 13:12.000]  Что мы пишем вообще-то на плюсах, а не на джаве.
[13:12.000 --> 13:15.000]  И нам такой подход, ну нафиг не сдался, если честно.
[13:15.000 --> 13:17.000]  Кто может догадаться, почему?
[13:17.000 --> 13:23.000]  Почему мы не будем с помощью ООП, интерфейсов и вот этого всего, вот этой машинерии,
[13:23.000 --> 13:27.000]  никогда в жизни не будем под разные платформы адаптировать приложения?
[13:29.000 --> 13:31.000]  Мы можем цппшник подменить?
[13:31.000 --> 13:38.000]  Ну раз, цппшник можно, два, можно эти FDF, да, там с линковщиком и цппшником подменой.
[13:38.000 --> 13:42.000]  Три можно там, ну вообще как-нибудь шаблонами и в констекспроме обойтись.
[13:42.000 --> 13:44.000]  Но почему мы всем этим страдаем?
[13:46.000 --> 13:48.000]  Потому что это все-таки Compel Time.
[13:49.000 --> 13:50.000]  Ну подростной системой.
[13:50.000 --> 13:51.000]  С целью какой?
[13:51.000 --> 13:53.000]  С целью какой?
[13:53.000 --> 13:55.000]  Почему мы не можем все это обернуть?
[13:57.000 --> 13:59.000]  Ну да, вот ключевое Compel Runtime.
[13:59.000 --> 14:00.000]  В Runtime дорого.
[14:00.000 --> 14:06.000]  Если у вас все приложение, ну как бы, приложение, как правило, оно часто стучится в операционку, правда?
[14:06.000 --> 14:09.000]  Вот и часто нужно как-то взаимодействовать с внешним миром.
[14:09.000 --> 14:13.000]  По крайней мере, на моем опыте я как бы сервера не особо пишу.
[14:13.000 --> 14:14.000]  Больше клиента.
[14:16.000 --> 14:24.000]  Ну и если это стучание в операционной системе у вас запрятано за десятью слоями вот таких вот интерфейсов и виртуальных вызовов,
[14:24.000 --> 14:26.000]  то первого вы хорошего не получите.
[14:27.000 --> 14:29.000]  У вас будут постоянные промахи по кышам и прочее.
[14:29.000 --> 14:31.000]  Поэтому в плюсах мы по-другому делаем.
[14:31.000 --> 14:33.000]  Но это Джава.
[14:33.000 --> 14:35.000]  Мы представляем, что мы как бы пишем на Джаве.
[14:35.000 --> 14:37.000]  И получается вот так.
[14:37.000 --> 14:39.000]  Что такое промах по кышу?
[14:39.000 --> 14:41.000]  Что такое промах по кышу?
[14:41.000 --> 14:50.000]  Смотри, у тебя на процессоре от процессора до оперативной памяти это как сходить за пивом в соседний город.
[14:50.000 --> 14:52.000]  По времени.
[14:52.000 --> 14:53.000]  Для масштаба, да?
[14:53.000 --> 15:01.000]  А вот от процессора до кэша маленького кусочка типа оперативной памяти,
[15:01.000 --> 15:05.000]  но находящийся прямо в чипе процессора, это как в соседний ларек сгонять.
[15:05.000 --> 15:07.000]  Да.
[15:07.000 --> 15:10.000]  А вот если ты просто какую-то инструкцию на процессоре выполняешь,
[15:10.000 --> 15:12.000]  что это там просто холодильник, открыть и достать пиво.
[15:12.000 --> 15:14.000]  Ну по таймингам, да?
[15:14.000 --> 15:17.000]  Что вот в оперативную память ходить это там в другой город,
[15:17.000 --> 15:19.000]  а просто инструкцию на процессоре выполнить.
[15:19.000 --> 15:21.000]  Это до холодильника дойти.
[15:21.000 --> 15:24.000]  Очень плохо будет, если тебе там нужно сложить десять чисел,
[15:24.000 --> 15:28.000]  и ты на каждое из этих сложений сначала там типа сходил два раза в другой город,
[15:28.000 --> 15:31.000]  потом к холодильнику подошел, все.
[15:31.000 --> 15:35.000]  Теперь еще там два-три раза в другой город, чтобы достать новые числа,
[15:35.000 --> 15:37.000]  а потом ну быстро их сложилось дойдя до холодильника.
[15:37.000 --> 15:42.000]  Поэтому в процессорах есть кэши, они вот прям внутрь процессора зашиты,
[15:42.000 --> 15:46.000]  работают так же как оперативная память, но прозрачно для вас.
[15:46.000 --> 15:50.000]  И если вы пишете ООП-код, где куча виртуальных вызовов,
[15:50.000 --> 15:53.000]  то эти кэши вас будут очень ненавидеть.
[15:53.000 --> 15:57.000]  Ну давайте потом к этому вернемся, возможно, я не знаю.
[15:57.000 --> 15:59.000]  А именно промах.
[15:59.000 --> 16:01.000]  А, промах что такое?
[16:01.000 --> 16:08.000]  Ну ты попытался получить доступ к памяти, которая сейчас не загружена в кэш.
[16:08.000 --> 16:10.000]  Почему такое могло произойти?
[16:10.000 --> 16:13.000]  Ну а тебе реально нужна новая память, с которой ты раньше не работал,
[16:13.000 --> 16:15.000]  поэтому откуда она в кэше может взяться?
[16:15.000 --> 16:18.000]  Промах, то есть это попытка обратиться к памяти?
[16:18.000 --> 16:22.000]  Попытка к доступу, и ты типа, ну как бы вот, интуиция такая,
[16:22.000 --> 16:25.000]  из доска для дарца это кэш, все остальное вокруг памяти.
[16:25.000 --> 16:28.000]  Ты такой стреляешь, попал, не попал.
[16:28.000 --> 16:32.000]  Ну, короче, да, мне казалось, это термин очень широко известный.
[16:32.000 --> 16:33.000]  Ну да.
[16:33.000 --> 16:34.000]  Ну если какие-то…
[16:34.000 --> 16:36.000]  Нет, возможно я…
[16:36.000 --> 16:38.000]  Окей, ну это не проблема.
[16:38.000 --> 16:41.000]  Если какие-то слова вас смущают, обязательно задавайте вопрос.
[16:41.000 --> 16:44.000]  У нас должен быть здесь диалог, а не монолог меня.
[16:44.000 --> 16:46.000]  Так будет эффективнее, мне кажется.
[16:46.000 --> 16:48.000]  Можем вернуться к фабричному?
[16:48.000 --> 16:49.000]  Давай.
[16:49.000 --> 16:50.000]  Давай.
[16:50.000 --> 16:56.000]  Ты приводил пример, когда мы принимаем вводы от пользователя…
[16:56.000 --> 16:57.000]  Да, да, да, да.
[16:57.000 --> 16:59.000]  Вот я ровно про это хотел сказать.
[16:59.000 --> 17:03.000]  Задержи вопрос в голове, вот я к этому подводил, но мы отвлеклись.
[17:03.000 --> 17:07.000]  В целом, вся вот эта машинерия фабрик и фабричных методов,
[17:07.000 --> 17:12.000]  и фабрик абстрактных, она нужна ровно для того, чтобы в рантайме
[17:12.000 --> 17:15.000]  диспетчеризироваться по тому, какой конструктор запускать.
[17:15.000 --> 17:18.000]  Например, если вам в зависимости от ввода пользователя
[17:18.000 --> 17:22.000]  разные сущности создавать, когда вы в зависимости от платформы
[17:22.000 --> 17:25.000]  что-то делаете, то это не нужно делать в рантайме.
[17:25.000 --> 17:28.000]  Вы до рантайма знаете, до какой платформы вы релизите
[17:28.000 --> 17:30.000]  свое приложение на плюсах.
[17:30.000 --> 17:34.000]  На джаве у вас один джарник, он должен везде работать, и вот так вот.
[17:34.000 --> 17:39.000]  Это хороший пример для джавы и плохой пример для плюсов,
[17:39.000 --> 17:41.000]  потому что на плюсах так никто писать не будет.
[17:41.000 --> 17:45.000]  Хороший пример для плюсов – это спавнер в Майнкрафте.
[17:45.000 --> 17:47.000]  Все играли в Майнкрафт.
[17:47.000 --> 17:50.000]  Там спавнер, можно у него яичком кликнуть, он будет спавнить
[17:50.000 --> 17:53.000]  либо коровок, либо свинок, либо зомби.
[17:53.000 --> 17:56.000]  Как думаете, как они определяют, какого моба спавнить?
[17:56.000 --> 18:00.000]  Потому что моб в Майнкрафте – это просто такая же кнопка, по сути.
[18:00.000 --> 18:04.000]  Есть интерфейс, там моб, его наследуют, есть зомби-класс,
[18:04.000 --> 18:07.000]  есть класс свинка, и вот.
[18:07.000 --> 18:10.000]  Как в зависимости от того, каким яичком кликнул пользователь,
[18:10.000 --> 18:12.000]  спавнить разных мобов?
[18:12.000 --> 18:18.000]  Но ровно так, давайте хранить абстрактную фабрику, вот такую.
[18:18.000 --> 18:21.000]  Прямо внутри спавнера.
[18:21.000 --> 18:25.000]  При клике яичком каким-то мы у яичка спросим,
[18:25.000 --> 18:27.000]  а какая фабрика к тебе привязана?
[18:27.000 --> 18:29.000]  А он говорит, а вот эта фабрика. Ее сохраним в спавнер.
[18:29.000 --> 18:31.000]  А дальше спавнер будет звать фабрику.
[18:31.000 --> 18:33.000]  Эй, создай мне нового моба.
[18:33.000 --> 18:36.000]  И вот теперь мы написали класс спавнера, который ничего не знает
[18:36.000 --> 18:39.000]  ни про зомби, ни про коровок, ни про кого.
[18:39.000 --> 18:42.000]  Он просто работает с абстрактными фабриками мобов, и все ок.
[18:42.000 --> 18:45.000]  Вот. То есть хорошее типа применение вот этого всего,
[18:45.000 --> 18:48.000]  это когда у вас строго в рантайме все происходит,
[18:48.000 --> 18:50.000]  ну а это обычно в зависимости от ввода из сети,
[18:50.000 --> 18:52.000]  или в зависимости от ввода пользователя.
[18:52.000 --> 18:55.000]  А вот этот пример, ну такой себе.
[18:55.000 --> 18:58.000]  Давай вопрос, если на него не ответил еще.
[18:58.000 --> 19:00.000]  Мне кажется, нет.
[19:00.000 --> 19:03.000]  Вот, например, у тебя был свитч, и в зависимости от цифрки
[19:03.000 --> 19:05.000]  мы рано нахнулся за дверь.
[19:05.000 --> 19:07.000]  И ты сказал, что фабричный метод,
[19:07.000 --> 19:09.000]  это мы от этого свитча избавимся.
[19:09.000 --> 19:10.000]  Да.
[19:10.000 --> 19:12.000]  Я пока не чувствую, как мы избавились.
[19:15.000 --> 19:16.000]  Окей.
[19:16.000 --> 19:17.000]  Куда мы свитч тянем сейчас?
[19:17.000 --> 19:20.000]  Свитч мы заменим на вызов виртуальной функции.
[19:21.000 --> 19:24.000]  Хочет распилить мир на много маленьких библиотек,
[19:24.000 --> 19:28.000]  которые друг друга зовут, но как бы никуда не вылезают,
[19:28.000 --> 19:30.000]  не вылезают в свой код. Вот.
[19:30.000 --> 19:33.000]  В Compile Time можно вспроходить эту виртуальность или что?
[19:33.000 --> 19:35.000]  В Compile Time пока вообще не говорим.
[19:35.000 --> 19:39.000]  Мы пытаемся понять про паттерны и вообще вот это вот.
[19:41.000 --> 19:42.000]  Все сломалось?
[19:42.000 --> 19:43.000]  Да все нормально, живем.
[19:43.000 --> 19:46.000]  Назад он включился, назад он с нами пишется.
[19:46.000 --> 19:48.000]  Это что-то странное было.
[19:49.000 --> 19:50.000]  Окей.
[19:50.000 --> 19:53.000]  Давай подзапись еще раз про свитч с цифрками.
[19:53.000 --> 19:55.000]  Свитч с цифрками.
[19:55.000 --> 19:58.000]  Я хотел сказать, что пример свитчом с цифрками,
[19:58.000 --> 20:00.000]  он, конечно, все равно...
[20:00.000 --> 20:03.000]  Ну, невозможно его решить только инструментами ОП,
[20:03.000 --> 20:05.000]  но во всяком случае где-то в коде нужно написать,
[20:05.000 --> 20:08.000]  в зависимости от ввода пользователя,
[20:08.000 --> 20:10.000]  что должно происходить.
[20:10.000 --> 20:12.000]  Такая табличка все равно должна быть.
[20:13.000 --> 20:15.000]  Ну, в этом месте мы тоже можем придумывать, конечно,
[20:15.000 --> 20:17.000]  что-то очень хитрое, например,
[20:18.000 --> 20:22.000]  сделать возможность регистрироваться разным модулям нашей программы,
[20:22.000 --> 20:25.000]  говоря на какую цифру они что возвращают.
[20:26.000 --> 20:28.000]  Ну, какие-то такие вещи.
[20:29.000 --> 20:31.000]  Но пойнт всего этого в общем и целом в том,
[20:31.000 --> 20:33.000]  что после того, как вы вот этот механизм
[20:33.000 --> 20:35.000]  какого-то диспетчеризации
[20:37.000 --> 20:40.000]  по вводу пользователя сделали,
[20:40.000 --> 20:42.000]  какой-то...
[20:43.000 --> 20:45.000]  Я говорил, что я не могу думать,
[20:45.000 --> 20:47.000]  когда кто-то еще говорит параллельно.
[20:47.000 --> 20:49.000]  Вот у меня просто мысли вылетают.
[20:49.000 --> 20:51.000]  Все? Хорошо.
[20:51.000 --> 20:53.000]  Пойнт чем? Есть какая-то диспетчеризация
[20:53.000 --> 20:55.000]  по данным, которые вел пользователь,
[20:55.000 --> 20:58.000]  а дальше мы летим по виртуальным вызовам всяких интерфейсов,
[20:58.000 --> 21:00.000]  и все абстрактно.
[21:00.000 --> 21:02.000]  И в какой-то момент мы вталкиваемся в то,
[21:02.000 --> 21:04.000]  что нужно что-то создать, какой-то объект.
[21:04.000 --> 21:06.000]  Ну вот конструкторами виртуальными не бывают,
[21:06.000 --> 21:08.000]  поэтому мы называем фабричный метод
[21:08.000 --> 21:10.000]  и получаем разные объекты,
[21:10.000 --> 21:12.000]  в зависимости от того,
[21:12.000 --> 21:14.000]  кто там...
[21:14.000 --> 21:16.000]  Никогда не делайте об общем идеологии, это ошибка.
[21:16.000 --> 21:18.000]  Да.
[21:18.000 --> 21:20.000]  Вот проходящий мимо человек тоже согласен,
[21:20.000 --> 21:23.000]  что все примеры, в принципе, которые здесь будут конкретные,
[21:23.000 --> 21:25.000]  они фигня, если честно.
[21:25.000 --> 21:28.000]  Я на практике никому так не посоветую делать.
[21:30.000 --> 21:32.000]  Ну вот проблема Апатора,
[21:32.000 --> 21:34.000]  потому что их объясняют,
[21:34.000 --> 21:36.000]  это вообще непонятно.
[21:36.000 --> 21:38.000]  Да, а потому что все какие-то, более-менее здравые примеры,
[21:38.000 --> 21:40.000]  они слишком сложные.
[21:40.000 --> 21:42.000]  Мне нравится пример со спавнером в Майнкрафте.
[21:42.000 --> 21:44.000]  Вот это вот просто лучший,
[21:44.000 --> 21:46.000]  он абсолютно понятный.
[21:46.000 --> 21:48.000]  Только непонятно, откуда изначально берется вот это вот фактори,
[21:48.000 --> 21:50.000]  и кто там говорит,
[21:50.000 --> 21:52.000]  какого предмета, какая фактория, какого моба.
[21:54.000 --> 21:56.000]  Ну вот да.
[21:56.000 --> 21:58.000]  Да, какие-то там
[21:58.000 --> 22:00.000]  с конфигов что-то читается,
[22:00.000 --> 22:02.000]  как-то оно инициализируется,
[22:02.000 --> 22:04.000]  все равно где-то там свич в итоге кроется.
[22:04.000 --> 22:06.000]  Но как бы...
[22:06.000 --> 22:08.000]  И вся идея это отталкивает свичи как можно дальше.
[22:08.000 --> 22:10.000]  Возможно, где-то полностью от них избавляться.
[22:10.000 --> 22:12.000]  Давайте дальше идти,
[22:12.000 --> 22:14.000]  потому что мне наскучило немножко.
[22:14.000 --> 22:16.000]  Но если все еще какие-то вопросы есть.
[22:16.000 --> 22:18.000]  Нет.
[22:18.000 --> 22:20.000]  Хорошо.
[22:20.000 --> 22:22.000]  Да, почему про все это говорим?
[22:22.000 --> 22:24.000]  Вот это вот писать, это шлютая морока, правда?
[22:24.000 --> 22:26.000]  Ну, лютая просто.
[22:26.000 --> 22:28.000]  Куча классов надо делать.
[22:28.000 --> 22:30.000]  Куча какой-то фигни писать.
[22:30.000 --> 22:32.000]  И все это сводится к тому, чтобы просто
[22:32.000 --> 22:34.000]  в каждом из вот этих вот конкретных
[22:34.000 --> 22:36.000]  классов
[22:36.000 --> 22:38.000]  написать типа
[22:38.000 --> 22:40.000]  вызов new что-то там.
[22:40.000 --> 22:42.000]  То есть просто конструктор вызвать.
[22:42.000 --> 22:44.000]  Да.
[22:44.000 --> 22:46.000]  Да.
[22:46.000 --> 22:48.000]  Да.
[22:48.000 --> 22:50.000]  Окей.
[22:50.000 --> 22:52.000]  Абстрактная фабрика пишется
[22:52.000 --> 22:54.000]  с нуля,
[22:54.000 --> 22:56.000]  когда мы поняли, что нам в будущем
[22:56.000 --> 22:58.000]  в приложении понадобится как-то
[22:58.000 --> 23:00.000]  диспетчеризировать
[23:00.000 --> 23:02.000]  создание разных объектов.
[23:02.000 --> 23:04.000]  Например, когда мы спавнер в
[23:04.000 --> 23:06.000]  Майнкрафте делаем, мы заранее продумываем систему
[23:06.000 --> 23:08.000]  и говорим, ага, мы будем фабрики мобов
[23:08.000 --> 23:10.000]  делать, и через них будем конкретных мобов
[23:10.000 --> 23:12.000]  уже выбирать и спавнить.
[23:12.000 --> 23:14.000]  Фабричный метод
[23:14.000 --> 23:16.000]  обычно вписывается уже
[23:16.000 --> 23:18.000]  постфактум. У вас есть какая-то иерархия,
[23:18.000 --> 23:20.000]  и внезапно оказалось,
[23:20.000 --> 23:22.000]  что в этой иерархии нужно создать какой-то
[23:22.000 --> 23:24.000]  новый объект.
[23:24.000 --> 23:26.000]  Какую-то новую фичу прикручивать, и нужно новый объект
[23:26.000 --> 23:28.000]  создать. В этот момент вы в иерархию
[23:28.000 --> 23:30.000]  вписываете один метод
[23:30.000 --> 23:32.000]  виртуальный, который возвращает
[23:32.000 --> 23:34.000]  по интерфейсу тот объект,
[23:34.000 --> 23:36.000]  который вам нужно создать.
[23:36.000 --> 23:38.000]  А в наследниках
[23:38.000 --> 23:40.000]  реализуйте уже конкретные
[23:40.000 --> 23:42.000]  вызовы
[23:42.000 --> 23:44.000]  конструкторов. Вот так вот.
[23:44.000 --> 23:46.000]  То есть я правильно понимаю, что
[23:46.000 --> 23:48.000]  в идеале фабричный метод
[23:48.000 --> 23:50.000]  должен был бы быть абстрактной фабрикой,
[23:50.000 --> 23:52.000]  а зачем?
[23:52.000 --> 23:54.000]  Нет, нет, нет, не надо так на это
[23:54.000 --> 23:56.000]  смотреть. Иногда вот так удобно.
[23:56.000 --> 23:58.000]  Иногда вот так удобно.
[23:58.000 --> 24:00.000]  Но в большинстве случаев и то, и другое
[24:00.000 --> 24:02.000]  полная фигня, и писать код вы будете по-другому.
[24:02.000 --> 24:04.000]  Но некоторое абстрактное
[24:04.000 --> 24:06.000]  понимание вот этого, оно полезно,
[24:06.000 --> 24:08.000]  и вы постфактум взглянете
[24:08.000 --> 24:10.000]  на свой код и такие, ой,
[24:10.000 --> 24:12.000]  а я же изобрел фабричный метод. Какой
[24:12.000 --> 24:14.000]  молодец. Или ой, я же изобрел
[24:14.000 --> 24:16.000]  абстрактную фабрику. Класс.
[24:16.000 --> 24:18.000]  Да, про что я говорил?
[24:18.000 --> 24:20.000]  Вот это писать Марокко,
[24:20.000 --> 24:22.000]  и анонс того, что будет в будущем.
[24:22.000 --> 24:24.000]  Мы сделаем шаблон,
[24:24.000 --> 24:26.000]  который вам просто по списку типов,
[24:26.000 --> 24:28.000]  ну просто через запятую перечисляйте,
[24:28.000 --> 24:30.000]  какие вот там есть.
[24:30.000 --> 24:32.000]  Есть там интерфейсы button и checkbox.
[24:32.000 --> 24:34.000]  Перечислили список.
[24:34.000 --> 24:36.000]  Дальше есть у них конкретные
[24:36.000 --> 24:38.000]  наследники. Mac button, Mac checkbox.
[24:38.000 --> 24:40.000]  Тоже перечислили в списке.
[24:40.000 --> 24:42.000]  И win button, win checkbox.
[24:42.000 --> 24:44.000]  Тоже перечислили. Три списка есть,
[24:44.000 --> 24:46.000]  в один шаблон все это запихиваете,
[24:46.000 --> 24:48.000]  получайте всю эту иерархию.
[24:48.000 --> 24:50.000]  Вот все, что здесь на картинке нарисовано,
[24:50.000 --> 24:52.000]  мы сгенерируем шаблонами.
[24:52.000 --> 24:54.000]  А реализация?
[24:54.000 --> 24:56.000]  Она одинаковая везде.
[24:56.000 --> 24:58.000]  В этом и point.
[24:58.000 --> 25:00.000]  Вот в этих методах, в этих реализациях
[25:00.000 --> 25:02.000]  вы не делаете ровным счетом ничего,
[25:02.000 --> 25:04.000]  как сделать new Mac checkbox,
[25:04.000 --> 25:06.000]  new Mac button, ну и return
[25:06.000 --> 25:08.000]  new Mac button. Вот все.
[25:08.000 --> 25:10.000]  В этих классах
[25:10.000 --> 25:12.000]  ничего нет.
[25:12.000 --> 25:14.000]  Это все boilerplate, тупейший.
[25:14.000 --> 25:16.000]  Поэтому Александреску придумал,
[25:16.000 --> 25:18.000]  как его автоматизировать.
[25:18.000 --> 25:20.000]  Но лучше бы не придумывал, потому что на практике
[25:20.000 --> 25:22.000]  такое конечно же не стоит использовать.
[25:22.000 --> 25:24.000]  Всегда можно придумать что-то более гибридное,
[25:24.000 --> 25:26.000]  современное, используя не только
[25:26.000 --> 25:28.000]  ООП подход.
[25:28.000 --> 25:30.000]  Окей, давайте ехать дальше, пожалуйста.
[25:30.000 --> 25:32.000]  Мы уже столько времени здесь.
[25:32.000 --> 25:34.000]  Целый час. Это провал.
[25:36.000 --> 25:38.000]  Едем дальше.
[25:38.000 --> 25:40.000]  Строитель. Ну про строитель вы должны мне рассказать,
[25:40.000 --> 25:42.000]  потому что кто-то уже говорил, что такое строитель, зачем он нужен.
[25:44.000 --> 25:46.000]  Ну да,
[25:46.000 --> 25:48.000]  по частям собирает целый объект.
[25:48.000 --> 25:50.000]  То есть мы хотим
[25:50.000 --> 25:52.000]  какой-то сложный конструктор
[25:52.000 --> 25:54.000]  с двадцатью аргументами
[25:54.000 --> 25:56.000]  или какой-то даже сложный вызов функции
[25:56.000 --> 25:58.000]  с двадцатью аргументами
[25:58.000 --> 26:00.000]  взять и разбить на кусочки.
[26:00.000 --> 26:02.000]  Ну и в этот момент мы что-то такое изобретаем.
[26:02.000 --> 26:04.000]  У нас у билдера есть
[26:04.000 --> 26:06.000]  какие-то сеты
[26:06.000 --> 26:08.000]  или ады, ад что-нибудь,
[26:08.000 --> 26:10.000]  сет что-нибудь. И каждый из них
[26:10.000 --> 26:12.000]  в свою очередь возвращает обратно такой же билдер.
[26:12.000 --> 26:14.000]  Ну вы такое, надеюсь, видели.
[26:14.000 --> 26:16.000]  И просто вызывается функция
[26:16.000 --> 26:18.000]  makeBuilder.add что-то,
[26:18.000 --> 26:20.000]  .add что-то, и вот так подряд пишется
[26:20.000 --> 26:22.000]  все эти ады. Вот это максимально
[26:22.000 --> 26:24.000]  прикладной паттерн, но такой ОП отсюда
[26:24.000 --> 26:26.000]  выкинуть надо, а вот так очень полезная
[26:26.000 --> 26:28.000]  штука.
[26:28.000 --> 26:30.000]  Если навернуть шаблонов,
[26:30.000 --> 26:32.000]  еще более полезно.
[26:32.000 --> 26:34.000]  Но об этом потом.
[26:36.000 --> 26:38.000]  Вот, а что здесь нарисовано
[26:38.000 --> 26:40.000]  с ОП-шной такой точки зрения?
[26:40.000 --> 26:42.000]  Чем это в ОП вообще было изначально придумано?
[26:42.000 --> 26:44.000]  Чтобы разные системы
[26:44.000 --> 26:46.000]  потихоньку инициализировали
[26:46.000 --> 26:48.000]  какой-то крупный объект.
[26:48.000 --> 26:50.000]  Поняли, что я сказал?
[26:50.000 --> 26:52.000]  Вот у вас три библиотеки, каждая из них
[26:52.000 --> 26:54.000]  должна немножко привнести свой вклад
[26:54.000 --> 26:56.000]  в построение вот этой вот машины.
[26:58.000 --> 27:00.000]  Нужно делегировать заполнение
[27:00.000 --> 27:02.000]  информации аргументов конструктора
[27:02.000 --> 27:04.000]  разным сущностям.
[27:04.000 --> 27:06.000]  Ага, вот это делается через
[27:06.000 --> 27:08.000]  билдер. Все.
[27:10.000 --> 27:12.000]  Если вы не поняли, что я сказал,
[27:12.000 --> 27:14.000]  сообщите об этом или молчите вечно.
[27:16.000 --> 27:18.000]  Мы будем считать, что все поняли.
[27:18.000 --> 27:20.000]  Вот, но такое не особо
[27:20.000 --> 27:22.000]  часто нужно, а вот просто
[27:22.000 --> 27:24.000]  сделать код более понятным и красивым
[27:24.000 --> 27:26.000]  без конструктора на 20
[27:26.000 --> 27:28.000]  аргументов, это да.
[27:28.000 --> 27:30.000]  Иногда же требуется.
[27:30.000 --> 27:32.000]  Это может быть полезно еще, наверное, когда
[27:32.000 --> 27:34.000]  мы хотим создать объект, который
[27:34.000 --> 27:36.000]  будет составной частью у нескольких
[27:36.000 --> 27:38.000]  других объектов. То есть мы хотим сделать
[27:38.000 --> 27:40.000]  например, ногу, нога будет
[27:40.000 --> 27:42.000]  там у Барби, у Кена.
[27:44.000 --> 27:46.000]  А зачем билдер для этого?
[27:46.000 --> 27:48.000]  Чтобы мы типа сконфигурировали ее
[27:48.000 --> 27:50.000]  и потом такие сказали, сделай еще одну, сделай еще одну.
[27:50.000 --> 27:52.000]  Ну, можно так сделать.
[27:52.000 --> 27:54.000]  А можно просто скопировать ногу
[27:54.000 --> 27:56.000]  и все.
[28:00.000 --> 28:02.000]  Ну да, если есть какой-то изначальный набор
[28:02.000 --> 28:04.000]  конфигураций, который общий, а потом
[28:04.000 --> 28:06.000]  нужно чуть-чуть докастомизировать для
[28:06.000 --> 28:08.000]  конкретных целей, то вот туда
[28:08.000 --> 28:10.000]  идеально подходит билдер.
[28:10.000 --> 28:12.000]  Потому что вы в общем коде какие-то куски
[28:12.000 --> 28:14.000]  сеттаете, а потом каким-то другим
[28:14.000 --> 28:16.000]  ребятам делегируете, доконфигурируете
[28:16.000 --> 28:18.000]  для Барби, доконфигурируете для Кена.
[28:18.000 --> 28:20.000]  И все в принципе,
[28:20.000 --> 28:22.000]  ну да, нормальное применение.
[28:22.000 --> 28:24.000]  Дальше. Ну, это в абстрактном
[28:24.000 --> 28:26.000]  виде, не будем смотреть.
[28:26.000 --> 28:28.000]  Есть синглтоны, есть прототипы.
[28:28.000 --> 28:30.000]  Они тривиальные, правда? Вы все знаете, что такое
[28:30.000 --> 28:32.000]  синглтон и все знаете, что такое прототип.
[28:32.000 --> 28:34.000]  А я не верю вам.
[28:34.000 --> 28:36.000]  Чем отличается прототип
[28:36.000 --> 28:38.000]  от конструктора копирования?
[28:42.000 --> 28:44.000]  Вот можно конструктор
[28:44.000 --> 28:46.000]  копирования вызвать в класс. Зачем нам какой-то
[28:46.000 --> 28:48.000]  прототип, там какой-то метод клоун говорят
[28:48.000 --> 28:50.000]  писать, зачем это все?
[28:56.000 --> 28:58.000]  Что значит изменить прототип?
[28:58.000 --> 29:00.000]  Ну, потом прототип состоит в чем?
[29:00.000 --> 29:02.000]  У вас есть интерфейс, у вас есть наследники.
[29:02.000 --> 29:04.000]  Вы добавляете в
[29:04.000 --> 29:06.000]  интерфейс метод клоун.
[29:06.000 --> 29:08.000]  Так, в наследниках
[29:08.000 --> 29:10.000]  его реализуйте, делая объект, который
[29:10.000 --> 29:12.000]  точно такой же, как текущий.
[29:12.000 --> 29:14.000]  И возвращаете его по ссылке,
[29:14.000 --> 29:16.000]  по интерфейсу.
[29:16.000 --> 29:18.000]  Зачем это?
[29:18.000 --> 29:20.000]  Почему нельзя?
[29:20.000 --> 29:22.000]  Вот, это правильное замечание,
[29:22.000 --> 29:24.000]  абсолютно. В этом все разница.
[29:24.000 --> 29:26.000]  Да?
[29:26.000 --> 29:28.000]  Конструктор копирования, он ничего не знает
[29:28.000 --> 29:30.000]  ни про какую виртуальность, ни про какое наследование,
[29:30.000 --> 29:32.000]  ни про какое ОП.
[29:32.000 --> 29:34.000]  Конкретный тип берет и копирует.
[29:34.000 --> 29:36.000]  Когда у вас иерархия,
[29:36.000 --> 29:38.000]  есть указательный интерфейс какой-то,
[29:38.000 --> 29:40.000]  то а как, собственно, понять,
[29:40.000 --> 29:42.000]  что под этим интерфейсом кроется,
[29:42.000 --> 29:44.000]  и как вообще у него вызвать конструктор копирования?
[29:44.000 --> 29:46.000]  Он же не виртуальный.
[29:46.000 --> 29:48.000]  Поэтому клоун это просто виртуализация
[29:48.000 --> 29:50.000]  конструктора копирования.
[29:50.000 --> 29:52.000]  Точно так же, как там вот эта вся фабричная муть,
[29:52.000 --> 29:54.000]  это виртуализация
[29:54.000 --> 29:56.000]  просто конструктора.
[29:56.000 --> 29:58.000]  А? Давайте ехать дальше.
[30:00.000 --> 30:02.000]  Компоновщик. Это дерево.
[30:02.000 --> 30:04.000]  Ну, дерево, у которого
[30:04.000 --> 30:06.000]  есть какой-то интерфейс ноды,
[30:06.000 --> 30:08.000]  а дальше эти ноды могут быть разные.
[30:08.000 --> 30:10.000]  Где вы видели компоновщики в жизни?
[30:10.000 --> 30:12.000]  HTML.
[30:12.000 --> 30:14.000]  Ну, в принципе, да. Если вы парсите HTML,
[30:14.000 --> 30:16.000]  да,
[30:16.000 --> 30:18.000]  то у вас дом дерева получится ровно компоновщик.
[30:18.000 --> 30:20.000]  А еще? Аиста дерева.
[30:20.000 --> 30:22.000]  Лисп.
[30:22.000 --> 30:24.000]  Ну, да. Ну, вот это все компоновщики.
[30:24.000 --> 30:26.000]  Триально, тривиально. Едем дальше.
[30:26.000 --> 30:28.000]  Декоратор.
[30:28.000 --> 30:30.000]  Тут, конечно,
[30:30.000 --> 30:32.000]  должно быть очередной
[30:32.000 --> 30:34.000]  монолог про то, чем отличается декоратор
[30:34.000 --> 30:36.000]  от адаптера, от прокси,
[30:36.000 --> 30:38.000]  от... Давайте декоратор в абстракте.
[30:38.000 --> 30:40.000]  А кто-нибудь помнит, что это?
[30:40.000 --> 30:42.000]  Питонячий декоратор.
[30:42.000 --> 30:44.000]  Нет, питонячий декоратор это не декоратор.
[30:44.000 --> 30:46.000]  Ну, в каком-то смысле это декоратор, но не в полном.
[30:48.000 --> 30:50.000]  Ну, мы
[30:50.000 --> 30:52.000]  хотим добавить какой-то функционал
[30:52.000 --> 30:54.000]  к объекту, не
[30:54.000 --> 30:56.000]  меняя сам объект.
[30:56.000 --> 30:58.000]  Сам класс его.
[30:58.000 --> 31:00.000]  И поэтому мы наворачиваем этот декоратор.
[31:00.000 --> 31:02.000]  Типа как extension
[31:02.000 --> 31:04.000]  методы. Ну, типа того.
[31:04.000 --> 31:06.000]  Но держится все на том, что есть интерфейс.
[31:06.000 --> 31:08.000]  Вот с этого надо начинать. Есть интерфейс.
[31:08.000 --> 31:10.000]  У нас есть его, какой-то
[31:10.000 --> 31:12.000]  наследник его реализует, что-то
[31:12.000 --> 31:14.000]  там делает. Мы хотим делать чуть
[31:14.000 --> 31:16.000]  больше. Ну, тут
[31:16.000 --> 31:18.000]  какой-то writeData, readData. Мы хотим
[31:18.000 --> 31:20.000]  дату шифровать перед записью и чтением.
[31:20.000 --> 31:22.000]  Да? Поэтому мы берем
[31:22.000 --> 31:24.000]  ну, как бы,
[31:24.000 --> 31:26.000]  простое решение это взять, переписать,
[31:26.000 --> 31:28.000]  скопировать вот этот весь класс.
[31:28.000 --> 31:30.000]  Добавить вот это вот
[31:30.000 --> 31:32.000]  шифрование, и вы
[31:32.000 --> 31:34.000]  справились в принципе. Хорошее
[31:34.000 --> 31:36.000]  решение это, ну,
[31:36.000 --> 31:38.000]  вот тут что-то какая-то фигня нарисована.
[31:38.000 --> 31:40.000]  Можно просто взять и...
[31:40.000 --> 31:42.000]  Ладно, нет, мне не получится так объяснить
[31:42.000 --> 31:44.000]  из-за этой диаграммы. Хорошее решение.
[31:44.000 --> 31:46.000]  Вы делаете новый класс.
[31:46.000 --> 31:48.000]  Encryption...
[31:48.000 --> 31:50.000]  EncryptionDecoraтор можно его назвать.
[31:50.000 --> 31:52.000]  Можно просто EncryptionDataSource.
[31:52.000 --> 31:54.000]  Неважно. И
[31:54.000 --> 31:56.000]  храните
[31:56.000 --> 31:58.000]  внутри него другой DataSource.
[31:58.000 --> 32:00.000]  Вот как бы
[32:00.000 --> 32:02.000]  оборачивайте другой класс,
[32:02.000 --> 32:04.000]  другой интерфейс.
[32:04.000 --> 32:06.000]  Другой объект того же
[32:06.000 --> 32:08.000]  интерфейса. Вы его оборачиваете
[32:08.000 --> 32:10.000]  и при этом сами реализуете этот же интерфейс
[32:10.000 --> 32:12.000]  тоже.
[32:12.000 --> 32:14.000]  Посредством методов того, кого вы обернули.
[32:14.000 --> 32:16.000]  Вот такая идея.
[32:16.000 --> 32:18.000]  Понятно, что я сказал?
[32:18.000 --> 32:20.000]  Оборачивающий класс всегда наследник
[32:20.000 --> 32:22.000]  того, кого он оборачивал?
[32:22.000 --> 32:24.000]  Нет, он его хранит в том-то и дело.
[32:24.000 --> 32:26.000]  Мы не наследуем FileDataSource.
[32:26.000 --> 32:28.000]  Мы храним любой DataSource.
[32:28.000 --> 32:30.000]  Вообще любой.
[32:30.000 --> 32:32.000]  Но мы наследуем DataSource, получается.
[32:32.000 --> 32:34.000]  Да, мы наследуем интерфейс.
[32:34.000 --> 32:36.000]  Тут отличевой момент
[32:36.000 --> 32:38.000]  всей этой конструкции в том, что есть какой-то
[32:38.000 --> 32:40.000]  интерфейс. Если интерфейса нет, то
[32:40.000 --> 32:42.000]  Decoraтор...
[32:42.000 --> 32:44.000]  FileDataSource вообще тут это...
[32:44.000 --> 32:46.000]  Да, это конкретный пример какого-то DataSource.
[32:46.000 --> 32:48.000]  Но вот был какой-то один DataSource.
[32:48.000 --> 32:50.000]  Другой, третий, четвертый.
[32:50.000 --> 32:52.000]  И все их нужно уметь шифровать.
[32:52.000 --> 32:54.000]  В этом тоже как бы
[32:54.000 --> 32:56.000]  point. Поэтому мы делаем вот такой
[32:56.000 --> 32:58.000]  EncryptionDecoraтор, который внутри себя
[32:58.000 --> 33:00.000]  хранит DataSource,
[33:00.000 --> 33:02.000]  воврайт-даты
[33:02.000 --> 33:04.000]  и рид-дата.
[33:04.000 --> 33:06.000]  Что-то там шифрует, а потом называет
[33:06.000 --> 33:08.000]  уврапи.
[33:08.000 --> 33:10.000]  Понятно?
[33:10.000 --> 33:12.000]  Рукомахательно.
[33:12.000 --> 33:14.000]  Это хорошо.
[33:14.000 --> 33:16.000]  Четыре года уже как должны все знать.
[33:16.000 --> 33:18.000]  Поэтому было бы плохо, если было не понятно.
[33:18.000 --> 33:20.000]  Ну и вот тут какие-то
[33:20.000 --> 33:22.000]  общие рассуждения, что можно вот этот общий
[33:22.000 --> 33:24.000]  класс вынести. Он на прошлом слайде уже был.
[33:24.000 --> 33:26.000]  Такой BaseDecoraтор.
[33:26.000 --> 33:28.000]  Потому что в каждом декораторе должно быть
[33:28.000 --> 33:30.000]  поле в раппи.
[33:30.000 --> 33:32.000]  Поэтому мы же против копипасты. Мы сделаем
[33:32.000 --> 33:34.000]  специальный промежуточный класс,
[33:34.000 --> 33:36.000]  у которого ровно одно поле есть
[33:36.000 --> 33:38.000]  в раппи. И все.
[33:38.000 --> 33:40.000]  Чтобы не писать его заново.
[33:40.000 --> 33:42.000]  Очень полезно.
[33:42.000 --> 33:44.000]  Прекрасно.
[33:44.000 --> 33:46.000]  Можно весь boilerplate написать.
[33:46.000 --> 33:48.000]  Какой?
[33:48.000 --> 33:50.000]  С повторной реализации интерфейса,
[33:50.000 --> 33:52.000]  который мы передаем в раппи.
[33:52.000 --> 33:54.000]  Так нет. В том-то идея, что мы в повторной реализации
[33:54.000 --> 33:56.000]  интерфейса хотим...
[33:56.000 --> 33:58.000]  А, нет, ну ты прав.
[33:58.000 --> 34:00.000]  Да, если у нас 10 разных
[34:00.000 --> 34:02.000]  методов вот здесь,
[34:02.000 --> 34:04.000]  ну вот в этом интерфейсе 10 разных методов,
[34:04.000 --> 34:06.000]  мы может хотим только один из них
[34:06.000 --> 34:08.000]  как-то кастомизировать.
[34:08.000 --> 34:10.000]  Добавить какое-нибудь поведение новое
[34:10.000 --> 34:12.000]  на запуске.
[34:12.000 --> 34:14.000]  Или просто к в раппи прокинуть, как они и были.
[34:14.000 --> 34:16.000]  Вот тогда их можно в этот бейс-декоратор
[34:16.000 --> 34:18.000]  запихнуть.
[34:18.000 --> 34:20.000]  Но это уже как-то не про дизайн,
[34:20.000 --> 34:22.000]  а просто какую-то специфику того, как вообще
[34:22.000 --> 34:24.000]  код на джабы пишется.
[34:24.000 --> 34:26.000]  И на имплисах в принципе тоже. Окей.
[34:26.000 --> 34:28.000]  Мост.
[34:28.000 --> 34:30.000]  Вот я утверждаю, что мост это тривиальный паттерн,
[34:30.000 --> 34:32.000]  его вообще не нужно учить, не нужно знать, что это паттерн.
[34:32.000 --> 34:34.000]  Это просто здравый смысл.
[34:34.000 --> 34:36.000]  Кто-нибудь помнит, что такое мост?
[34:36.000 --> 34:38.000]  Нет.
[34:38.000 --> 34:40.000]  Ну и правильно.
[34:40.000 --> 34:42.000]  Пример?
[34:42.000 --> 34:44.000]  Вот этот?
[34:44.000 --> 34:46.000]  Нет.
[34:46.000 --> 34:48.000]  Это не мост.
[34:48.000 --> 34:50.000]  Ну почему?
[34:50.000 --> 34:52.000]  Потому что, возможно, его кто-то
[34:52.000 --> 34:54.000]  называет мостом,
[34:54.000 --> 34:56.000]  но имеет в виду совсем другое,
[34:56.000 --> 34:58.000]  нежели имеют в виду авторы книжки по паттернам
[34:58.000 --> 35:00.000]  вот этой вот, ну вы поняли о чем.
[35:00.000 --> 35:02.000]  Я от банды четырех, вроде так называется.
[35:04.000 --> 35:06.000]  Наверное, ты другой мост имеешь в виду.
[35:06.000 --> 35:08.000]  А тут
[35:08.000 --> 35:10.000]  мост очень тупой.
[35:10.000 --> 35:12.000]  Что у нас значит есть иерархия окон,
[35:14.000 --> 35:16.000]  ну окно для X,
[35:16.000 --> 35:18.000]  окно там для, я не знаю, что такое
[35:18.000 --> 35:20.000]  PM, может вы знаете.
[35:20.000 --> 35:22.000]  Ну это что-то странное.
[35:22.000 --> 35:24.000]  Ну ладно.
[35:24.000 --> 35:26.000]  А потом решили добавить
[35:26.000 --> 35:28.000]  иконки.
[35:28.000 --> 35:30.000]  Вот что окон должны быть иконки.
[35:30.000 --> 35:32.000]  И делайте
[35:32.000 --> 35:34.000]  icon window, и от него заново наследуете
[35:34.000 --> 35:36.000]  x icon window, PM icon window.
[35:36.000 --> 35:38.000]  Ну вот если вы такой код увидите,
[35:38.000 --> 35:40.000]  вы, наверное, матом покроете
[35:40.000 --> 35:42.000]  автора, правда ведь?
[35:42.000 --> 35:44.000]  Это же бред полный.
[35:44.000 --> 35:46.000]  Ну иконки должны как-то
[35:46.000 --> 35:48.000]  храниться в окнах, ну или наоборот.
[35:48.000 --> 35:50.000]  Окна в конце концов
[35:50.000 --> 35:52.000]  могут храниться в иконках, если очень хочется.
[35:52.000 --> 35:54.000]  Мост про это.
[35:54.000 --> 35:56.000]  Тут просто прекрасно
[35:56.000 --> 35:58.000]  придумано, что вот мол есть
[35:58.000 --> 36:00.000]  окно,
[36:00.000 --> 36:02.000]  у него есть там вот
[36:02.000 --> 36:04.000]  окно с оконкой наследник,
[36:04.000 --> 36:06.000]  есть икно с
[36:06.000 --> 36:08.000]  какой-то другой,
[36:08.000 --> 36:10.000]  трансин, ну пропадающее окно,
[36:10.000 --> 36:12.000]  виды окон.
[36:12.000 --> 36:14.000]  Вот иерархия видов окон.
[36:14.000 --> 36:16.000]  Икно с оконкой, икно с чем-то другим, икно с чем-то еще.
[36:16.000 --> 36:18.000]  А дальше есть вот
[36:18.000 --> 36:20.000]  иксы и какой-то PM,
[36:20.000 --> 36:22.000]  наверное, это виндовое окно.
[36:22.000 --> 36:24.000]  Вот это отдельная иерархия будет.
[36:24.000 --> 36:26.000]  Вот и все. Какой-то window impel.
[36:26.000 --> 36:28.000]  И вот
[36:28.000 --> 36:30.000]  просто window хранит в себе поле
[36:30.000 --> 36:32.000]  window impel и прокидывает ему всякие
[36:32.000 --> 36:34.000]  иерархии, вызову, чтобы там что-то сделать.
[36:34.000 --> 36:36.000]  То есть делайте много разных иерархий,
[36:36.000 --> 36:38.000]  храните их друг к другу полями,
[36:38.000 --> 36:40.000]  а не запихивайте все в одну иерархию.
[36:40.000 --> 36:42.000]  Вот и весь pattern bridge.
[36:42.000 --> 36:44.000]  Декомпозируйте код правильно,
[36:44.000 --> 36:46.000]  иначе говоря.
[36:46.000 --> 36:48.000]  Достаточно тривиальная вещь,
[36:48.000 --> 36:50.000]  не нужно о ней думать вообще, вы просто
[36:50.000 --> 36:52.000]  когда пишете код, у вас у самих должно быть
[36:52.000 --> 36:54.000]  желание так делать, даже
[36:54.000 --> 36:56.000]  не вспоминая, что это ведь название какое-то есть.
[36:56.000 --> 36:58.000]  Вот.
[36:58.000 --> 37:00.000]  Тут есть еще целый список.
[37:00.000 --> 37:02.000]  Если вы хотите, могу что-нибудь про них сказать,
[37:02.000 --> 37:04.000]  но я бы хотел скипнуть.
[37:06.000 --> 37:08.000]  Помните их?
[37:08.000 --> 37:10.000]  Ну так в целом.
[37:10.000 --> 37:12.000]  Кто все эти люди?
[37:12.000 --> 37:14.000]  Ну адаптер, так когда у вас есть два интерфейса,
[37:14.000 --> 37:16.000]  вы хотели бы дружить?
[37:16.000 --> 37:18.000]  Да. Причем важная оговорка,
[37:18.000 --> 37:20.000]  два интерфейса в принципе одно и то же делают.
[37:22.000 --> 37:24.000]  Звучит как бред, да, но
[37:24.000 --> 37:26.000]  это паттерны для того, чтобы работать с legacy в том числе.
[37:26.000 --> 37:28.000]  Это когда у вас есть
[37:28.000 --> 37:30.000]  какой-то legacy, у вас полным-полно
[37:30.000 --> 37:32.000]  будет мест, где 10 функций,
[37:32.000 --> 37:34.000]  названия почти одинаковые,
[37:34.000 --> 37:36.000]  аргументы почти одинаковые, делают
[37:36.000 --> 37:38.000]  почти одинаковые вещи, но все какие-то чуть-чуть
[37:38.000 --> 37:40.000]  по-разному и типа
[37:40.000 --> 37:42.000]  это плохо. То же самое с интерфейсами.
[37:42.000 --> 37:44.000]  Два-три интерфейса, которые по сути одно и то же,
[37:44.000 --> 37:46.000]  но так сложилось исторически, что они разные.
[37:46.000 --> 37:48.000]  Вот нужно заткнуть одно в другое,
[37:48.000 --> 37:50.000]  вот адаптер прекрасно.
[37:50.000 --> 37:52.000]  Ну.
[37:52.000 --> 37:54.000]  Апрокси, это по-моему, когда у нас есть два
[37:54.000 --> 37:56.000]  взаимодействующих с собой интерфейса,
[37:56.000 --> 37:58.000]  а третий между ними, который делает какую-то
[37:58.000 --> 38:00.000]  ворикулу.
[38:00.000 --> 38:02.000]  Знаешь, если честно,
[38:02.000 --> 38:04.000]  прокси, это та
[38:04.000 --> 38:06.000]  штука, которую я вообще ни разу на практике
[38:06.000 --> 38:08.000]  не применил, не видел применения,
[38:08.000 --> 38:10.000]  не смог понять, зачем оно,
[38:10.000 --> 38:12.000]  то я предлагаю просто считать, что прокси не существует.
[38:12.000 --> 38:14.000]  Это какой-то типа
[38:14.000 --> 38:16.000]  странный гибрид из много чего.
[38:20.000 --> 38:22.000]  У меня в проекте есть штука,
[38:22.000 --> 38:24.000]  которая называется прокси,
[38:24.000 --> 38:26.000]  но она делает много чего.
[38:26.000 --> 38:28.000]  Ну вот именно.
[38:28.000 --> 38:30.000]  Тут совсем этим проблема, что каждая из этих вещей,
[38:30.000 --> 38:32.000]  она там, слово классное,
[38:32.000 --> 38:34.000]  но эти ребята, они
[38:34.000 --> 38:36.000]  не запатентовали эти слова,
[38:36.000 --> 38:38.000]  поэтому эти слова используют еще
[38:38.000 --> 38:40.000]  куча других ребят для совсем других значений
[38:40.000 --> 38:42.000]  и все такие, сделай фабрику, да,
[38:42.000 --> 38:44.000]  сделаю фабрику, делает make shirt
[38:44.000 --> 38:46.000]  или что-нибудь такое, и как бы, это
[38:46.000 --> 38:48.000]  вообще про разное. Ну, ладно.
[38:48.000 --> 38:50.000]  Дальше идем, дальше идем.
[38:50.000 --> 38:52.000]  Я хочу побыстрее пройти все.
[38:52.000 --> 38:54.000]  Паттерн команда.
[38:54.000 --> 38:56.000]  Он вообще вам должен быть знаком
[38:56.000 --> 38:58.000]  и роден, как я не знаю что,
[38:58.000 --> 39:00.000]  потому что мы, собственно, в одной из домашних
[39:00.000 --> 39:02.000]  будем с нуля писать. Паттерн фабрика
[39:02.000 --> 39:04.000]  на шаблонах, очень интересно.
[39:04.000 --> 39:06.000]  Ну, что он делает? Кто-нибудь помнит?
[39:08.000 --> 39:10.000]  Он обращивает какую-то функцию, действие
[39:10.000 --> 39:12.000]  в класс, в объект.
[39:12.000 --> 39:14.000]  Ну да.
[39:14.000 --> 39:16.000]  Ну да, и в принципе все.
[39:16.000 --> 39:18.000]  То есть тут предлагаются еще
[39:18.000 --> 39:20.000]  обвесы, которые можно сделать поверх вот этой
[39:20.000 --> 39:22.000]  основной идеи, что, мол,
[39:22.000 --> 39:24.000]  если вы представляете действие
[39:24.000 --> 39:26.000]  в виде объектов,
[39:26.000 --> 39:28.000]  то вы можете там откатывать
[39:28.000 --> 39:30.000]  эти действия, делать анду
[39:30.000 --> 39:32.000]  или какие-то бэкапы сохранять
[39:32.000 --> 39:34.000]  или серилизовать эти действия, да.
[39:34.000 --> 39:36.000]  То есть мало ли у вас там какая-нибудь
[39:36.000 --> 39:38.000]  последовательность действий,
[39:38.000 --> 39:40.000]  которые должен совершить какой-то
[39:40.000 --> 39:42.000]  манипулятор рука, и вы хотите вот там
[39:42.000 --> 39:44.000]  сохранить эту последовательность
[39:44.000 --> 39:46.000]  или исполнить эту последовательность.
[39:46.000 --> 39:48.000]  И вот вы их храните объектами,
[39:48.000 --> 39:50.000]  и это вам классно.
[39:50.000 --> 39:52.000]  Ну, в целом,
[39:52.000 --> 39:54.000]  самая такая...
[39:54.000 --> 39:56.000]  самая
[39:56.000 --> 39:58.000]  часто встречаемый,
[39:58.000 --> 40:00.000]  самый часто встречаемый вид этого паттерна
[40:00.000 --> 40:02.000]  это STD Function,
[40:02.000 --> 40:04.000]  потому что это чистые воды
[40:04.000 --> 40:06.000]  команда.
[40:06.000 --> 40:08.000]  STD Function это объект, который делает какое-то действие.
[40:08.000 --> 40:10.000]  У него есть стейт, у него есть какие-то ссылки
[40:10.000 --> 40:12.000]  куда-то вовне. Это тоже бывает
[40:12.000 --> 40:14.000]  нужно, чтобы
[40:14.000 --> 40:16.000]  что-то посчитать или сделать.
[40:16.000 --> 40:18.000]  STD Function будем писать в какой-то момент.
[40:18.000 --> 40:20.000]  Это абстрактный
[40:20.000 --> 40:22.000]  вид всего этого.
[40:22.000 --> 40:24.000]  На него смотреть тяжело, давайте не будем.
[40:24.000 --> 40:26.000]  Шаблонный метод.
[40:26.000 --> 40:28.000]  Ну, мне это в дипломе пригодилось.
[40:28.000 --> 40:30.000]  Полезная штука.
[40:30.000 --> 40:32.000]  Идея тупейшая.
[40:32.000 --> 40:34.000]  Кто-нибудь может догадаться
[40:34.000 --> 40:36.000]  о ней из картинки?
[40:36.000 --> 40:38.000]  Я сомневаюсь,
[40:38.000 --> 40:40.000]  что кто-то запомнил с курса ТП
[40:40.000 --> 40:42.000]  вот это вот.
[40:46.000 --> 40:48.000]  Нет,
[40:48.000 --> 40:50.000]  никто не помнит,
[40:50.000 --> 40:52.000]  что это такое, зачем
[40:52.000 --> 40:54.000]  тут три какие-то класса.
[40:54.000 --> 40:56.000]  Все очень тупо.
[40:56.000 --> 40:58.000]  У вас есть алгоритм какой-то.
[40:58.000 --> 41:00.000]  В дипломе, скажем,
[41:00.000 --> 41:02.000]  как у меня.
[41:02.000 --> 41:04.000]  И этот алгоритм делится на шаги.
[41:04.000 --> 41:06.000]  И вы...
[41:06.000 --> 41:08.000]  Каждый из этих шагов
[41:08.000 --> 41:10.000]  тоже отдельный алгоритм,
[41:10.000 --> 41:12.000]  и по каждому из них вы 10 статей нашли,
[41:12.000 --> 41:14.000]  как реализовать.
[41:14.000 --> 41:16.000]  Вы можете все варианты попробовать,
[41:16.000 --> 41:18.000]  по-разному их комбинировать.
[41:18.000 --> 41:20.000]  Ну и что вы делаете?
[41:20.000 --> 41:22.000]  Вы основной алгоритм пишете в главном классе сверху,
[41:22.000 --> 41:24.000]  а все шаги делаете
[41:24.000 --> 41:26.000]  виртуальными методами.
[41:26.000 --> 41:28.000]  Потом делаете наследников
[41:28.000 --> 41:30.000]  и какие-то комбинации этих шагов.
[41:30.000 --> 41:32.000]  И по-разному эти шаги делаете.
[41:32.000 --> 41:34.000]  Тут вот
[41:34.000 --> 41:36.000]  какая-то последовательность действий в игре.
[41:36.000 --> 41:38.000]  Take turn,
[41:38.000 --> 41:40.000]  collect resources, что там.
[41:40.000 --> 41:42.000]  И предполагается, что где-то здесь есть...
[41:42.000 --> 41:44.000]  Наверное, take turn имеется в виду как этот метод,
[41:44.000 --> 41:46.000]  который все остальные подряд
[41:46.000 --> 41:48.000]  запускают.
[41:48.000 --> 41:50.000]  Возможно, с каким-то ифами еще, какой-то логикой,
[41:50.000 --> 41:52.000]  в цикле чего-нибудь.
[41:52.000 --> 41:54.000]  Но суть take turn — какой-то код,
[41:54.000 --> 41:56.000]  который запускает заглушки,
[41:56.000 --> 41:58.000]  которые ниже.
[41:58.000 --> 42:00.000]  Дальше эти заглушки чем-то надо заполнить,
[42:00.000 --> 42:02.000]  мы в наследниках их заполняем. Шаблонный метод.
[42:02.000 --> 42:04.000]  Все тупо.
[42:04.000 --> 42:06.000]  А, ну собственно, вот.
[42:06.000 --> 42:08.000]  Шаблонный метод,
[42:08.000 --> 42:10.000]  в нем какие-то шаги, шаги виртуальные,
[42:10.000 --> 42:12.000]  в наследниках переопределяем. Все.
[42:12.000 --> 42:14.000]  Идем дальше.
[42:14.000 --> 42:16.000]  Визитор. Визитор — самый классный паттерн,
[42:16.000 --> 42:18.000]  как по мне. В нем есть что-то волшебное.
[42:20.000 --> 42:22.000]  — И есть мнение, что это
[42:22.000 --> 42:24.000]  предусложенный паттерн?
[42:24.000 --> 42:26.000]  — Ну, в принципе, да.
[42:26.000 --> 42:28.000]  Но ты должен знать, что такое
[42:28.000 --> 42:30.000]  визитор, правда ведь? Напомни нам,
[42:30.000 --> 42:32.000]  что такое визитор. Ты же пишешь компиляторы.
[42:34.000 --> 42:36.000]  — Сейчас.
[42:36.000 --> 42:38.000]  — А?
[42:38.000 --> 42:40.000]  — Да, я такого могу ожидать,
[42:40.000 --> 42:42.000]  потому что это
[42:42.000 --> 42:44.000]  пишется один раз и забывается дальше.
[42:44.000 --> 42:46.000]  Насколько я сужу.
[42:46.000 --> 42:48.000]  — Не, я просто помню, что это,
[42:48.000 --> 42:50.000]  как пример, у нас есть паттери типа.
[42:56.000 --> 42:58.000]  Я хочу привести пример
[42:58.000 --> 43:00.000]  из компиляторной сферы.
[43:00.000 --> 43:02.000]  Мы пишем токенайзер, который нам
[43:02.000 --> 43:04.000]  выплевывает последовательность токенов.
[43:04.000 --> 43:06.000]  У нас токены совсем разные
[43:06.000 --> 43:08.000]  могут быть, они могут охранять разные
[43:08.000 --> 43:10.000]  поля, могут не хранить поля,
[43:10.000 --> 43:12.000]  могут иметь там какие-то свои методы и так далее.
[43:12.000 --> 43:14.000]  И мы
[43:14.000 --> 43:16.000]  хотим иметь подпоряжение
[43:16.000 --> 43:18.000]  к какой-то последовательности токенов.
[43:18.000 --> 43:20.000]  В ООП-шнем подходе мы имеем
[43:20.000 --> 43:22.000]  CD-вектор, а указатель
[43:22.000 --> 43:24.000]  на базовый класс.
[43:26.000 --> 43:28.000]  И дальше мы хотим,
[43:28.000 --> 43:30.000]  чтобы мы какую-то штуку
[43:30.000 --> 43:32.000]  делали с этими токенами
[43:32.000 --> 43:34.000]  по-разному, в зависимости от типа этого токена.
[43:34.000 --> 43:36.000]  То есть
[43:36.000 --> 43:38.000]  типичный пример
[43:38.000 --> 43:40.000]  это мы хотим, условно говоря,
[43:40.000 --> 43:42.000]  вывести в лог нашу последовательность
[43:42.000 --> 43:44.000]  токенов, и мы хотим,
[43:44.000 --> 43:46.000]  когда у нас токен, который отвечает
[43:46.000 --> 43:48.000]  за стримковый литерат, мы выводили строчку,
[43:48.000 --> 43:50.000]  которую он внутри себя хранит. Если он
[43:50.000 --> 43:52.000]  отвечает за интовский литерат, он должен
[43:52.000 --> 43:54.000]  выводить чиселку, которую в себе хранит.
[43:54.000 --> 43:56.000]  Если это просто скобочка
[43:56.000 --> 43:58.000]  литерат. Ну окей, есть токены,
[43:58.000 --> 44:00.000]  иерархия, есть действия.
[44:00.000 --> 44:02.000]  Где визитер?
[44:02.000 --> 44:04.000]  Ну визитер
[44:04.000 --> 44:06.000]  это, соответственно,
[44:06.000 --> 44:08.000]  визитер, он
[44:08.000 --> 44:10.000]  отвечает за действия, и у нас есть
[44:10.000 --> 44:12.000]  метод visit.
[44:12.000 --> 44:14.000]  У нас каждый из
[44:14.000 --> 44:16.000]  наследников его парты определяют,
[44:16.000 --> 44:18.000]  чтобы диспетченизация произошла
[44:18.000 --> 44:20.000]  и внутри...
[44:20.000 --> 44:22.000]  Наследников чего?
[44:22.000 --> 44:24.000]  Наследники токенов.
[44:24.000 --> 44:26.000]  Наследники токенов, метод visit, окей.
[44:26.000 --> 44:28.000]  Вот, и потом, соответственно,
[44:28.000 --> 44:30.000]  визитер, он в зависимости от того,
[44:30.000 --> 44:32.000]  с каким токеном работает, он по-разному
[44:32.000 --> 44:34.000]  его партует.
[44:34.000 --> 44:36.000]  Ну, короче-то, я описал только что
[44:36.000 --> 44:38.000]  то, что здесь нарисовано, в принципе.
[44:38.000 --> 44:40.000]  Но это абсолютно не объясняет, зачем
[44:40.000 --> 44:42.000]  все это нужно. Вот, если честно, я
[44:42.000 --> 44:44.000]  из твоих объяснений не понял,
[44:44.000 --> 44:46.000]  зачем мне нужен визитер.
[44:48.000 --> 44:50.000]  Мы просто хотим на каждой AST ноде
[44:50.000 --> 44:52.000]  разных пасов делать разную логику.
[44:52.000 --> 44:54.000]  И мы можем эту логику просто
[44:54.000 --> 44:56.000]  вписать каждый раз разно,
[44:56.000 --> 44:58.000]  и у нас визитер будет сам ходить и вызывать
[44:58.000 --> 45:00.000]  вот эти арбудочки.
[45:00.000 --> 45:02.000]  Давайте тогда чуть-чуть проскролим.
[45:02.000 --> 45:04.000]  Не-не-не-не-не-не.
[45:04.000 --> 45:06.000]  Каждый тип, который реализует метод
[45:06.000 --> 45:08.000]  accept, внутри знает, какой метод
[45:08.000 --> 45:10.000]  визитер дергает на себя.
[45:10.000 --> 45:12.000]  Ну, это все
[45:12.000 --> 45:14.000]  в правильную сторону мысли,
[45:14.000 --> 45:16.000]  но я главную суть хочу, нафиг
[45:16.000 --> 45:18.000]  это все нужно.
[45:18.000 --> 45:20.000]  Вот у нас есть такая картинка.
[45:20.000 --> 45:22.000]  Вот два примера там про AST и про токены.
[45:22.000 --> 45:24.000]  Это все из этой области.
[45:24.000 --> 45:26.000]  У вас есть данные, и у вас есть поведение.
[45:26.000 --> 45:28.000]  И вам нужно каждой из каждом их
[45:28.000 --> 45:30.000]  декартово перемножить
[45:30.000 --> 45:32.000]  и написать код.
[45:32.000 --> 45:34.000]  Вопрос. Где этот код писать?
[45:34.000 --> 45:36.000]  Как вот это все
[45:36.000 --> 45:38.000]  организовать в фактический код?
[45:38.000 --> 45:40.000]  То есть это будут
[45:40.000 --> 45:42.000]  какие-то тела функций, но куда их вписывать?
[45:42.000 --> 45:44.000]  В какие функции?
[45:44.000 --> 45:46.000]  Два ответа на этот вопрос есть.
[45:46.000 --> 45:48.000]  ОПшный ответ.
[45:48.000 --> 45:50.000]  Давайте сделаем интерфейс,
[45:50.000 --> 45:52.000]  данные будут наследовать
[45:52.000 --> 45:54.000]  этот интерфейс,
[45:54.000 --> 45:56.000]  а код будет методами.
[45:56.000 --> 45:58.000]  Поведения будут методами этого интерфейса.
[46:00.000 --> 46:02.000]  Просто и понятно.
[46:02.000 --> 46:04.000]  Почему я так обвел по горизонтали?
[46:04.000 --> 46:06.000]  Потому что
[46:06.000 --> 46:08.000]  один из этих данных организует все поведения.
[46:08.000 --> 46:10.000]  Ну да, это группировка.
[46:10.000 --> 46:12.000]  Красное означает,
[46:12.000 --> 46:14.000]  что эти штуки рядом находятся в коде.
[46:14.000 --> 46:16.000]  В одном модуле, в одном объекте,
[46:16.000 --> 46:18.000]  в одном чем-то. Здесь по горизонтали
[46:18.000 --> 46:20.000]  группировка. И что это значит?
[46:20.000 --> 46:22.000]  Это значит, что нам очень легко
[46:22.000 --> 46:24.000]  не меняя старый код добавить новые данные.
[46:24.000 --> 46:26.000]  Так? Легко.
[46:26.000 --> 46:28.000]  А вот
[46:28.000 --> 46:30.000]  добавить новое поведение
[46:30.000 --> 46:32.000]  нам очень сложно.
[46:32.000 --> 46:34.000]  Потому что нам нужно пройтись
[46:34.000 --> 46:36.000]  по всем уже существующим данным
[46:36.000 --> 46:38.000]  и везде вписать новый метод.
[46:38.000 --> 46:40.000]  Не забыть. Иначе там ничего
[46:40.000 --> 46:42.000]  работать не будет.
[46:42.000 --> 46:44.000]  Такая группировка имеет
[46:44.000 --> 46:46.000]  смысл. Если вам хочется
[46:46.000 --> 46:48.000]  часто добавлять данные
[46:48.000 --> 46:50.000]  и не хочется часто добавлять поведения,
[46:50.000 --> 46:52.000]  то есть отличная группировка.
[46:52.000 --> 46:54.000]  В компиляторах получилось по-другому.
[46:54.000 --> 46:56.000]  АСТ, в него не часто
[46:56.000 --> 46:58.000]  добавляются новые данные,
[46:58.000 --> 47:00.000]  зато очень часто пытаются добавить
[47:00.000 --> 47:02.000]  какие-то новые поведения, которые
[47:02.000 --> 47:04.000]  проходятся по нему и что-то там
[47:04.000 --> 47:06.000]  преобразуют, оптимизируют, добавляют,
[47:06.000 --> 47:08.000]  переставляют. Вот такие вещи.
[47:08.000 --> 47:10.000]  То есть им было важно, чтобы было легко новые
[47:10.000 --> 47:12.000]  поведения добавлять.
[47:12.000 --> 47:14.000]  Поэтому они придумали Visitor.
[47:14.000 --> 47:16.000]  Теперь можно посмотреть на эту картинку.
[47:16.000 --> 47:18.000]  Visitor инкапсулирует
[47:18.000 --> 47:20.000]  стратегию того,
[47:20.000 --> 47:22.000]  как мы делаем действия над
[47:22.000 --> 47:24.000]  данными.
[47:24.000 --> 47:26.000]  То есть
[47:26.000 --> 47:28.000]  у каждого Visitor
[47:28.000 --> 47:30.000]  для каждого вида данных
[47:30.000 --> 47:32.000]  должен быть метод Visit.
[47:32.000 --> 47:34.000]  Посетить эти данные.
[47:34.000 --> 47:36.000]  То есть Element A, Element B — это
[47:36.000 --> 47:38.000]  разные данные. А Visitor — это интерфейс
[47:38.000 --> 47:40.000]  для действий.
[47:40.000 --> 47:42.000]  Дальше для каждого конкретного
[47:42.000 --> 47:44.000]  действия, в той табличке
[47:44.000 --> 47:46.000]  вертикальные столбцы. Для каждого конкретного
[47:46.000 --> 47:48.000]  действия вы делаете наследника.
[47:48.000 --> 47:50.000]  Конкрет Visitor и вписываете туда код.
[47:50.000 --> 47:52.000]  И вот уже
[47:52.000 --> 47:54.000]  на эти две штуки смотря, группировка
[47:54.000 --> 47:56.000]  получается по вертикали.
[47:56.000 --> 47:58.000]  Мы сказали, что
[47:58.000 --> 48:00.000]  поведение — это класс.
[48:00.000 --> 48:02.000]  Назвали этот класс Visitor.
[48:02.000 --> 48:04.000]  И сделали у него методы Visit,
[48:04.000 --> 48:06.000]  которые делают действия над
[48:06.000 --> 48:08.000]  каждым видом данных.
[48:12.000 --> 48:14.000]  Теперь как это запустить?
[48:14.000 --> 48:16.000]  То есть мы организовали этот код,
[48:16.000 --> 48:18.000]  но вопрос, а как нам запустить?
[48:18.000 --> 48:20.000]  Удобно.
[48:20.000 --> 48:22.000]  Отличная идея.
[48:22.000 --> 48:24.000]  Нет, будет
[48:24.000 --> 48:26.000]  проще. У Element
[48:26.000 --> 48:28.000]  мы сделаем, ну или у данных.
[48:28.000 --> 48:30.000]  Они тоже будут террархией,
[48:30.000 --> 48:32.000]  потому что это OP. Мы сделаем
[48:32.000 --> 48:34.000]  метод Accept.
[48:34.000 --> 48:36.000]  Он будет принимать какой-то Visitor.
[48:36.000 --> 48:38.000]  А дальше мы попросим
[48:38.000 --> 48:40.000]  всех наследников реализовать
[48:40.000 --> 48:42.000]  этот метод Accept
[48:42.000 --> 48:44.000]  и дёргать в этом интерфейсе
[48:44.000 --> 48:46.000]  нужный метод
[48:46.000 --> 48:48.000]  от себя.
[48:48.000 --> 48:50.000]  Element A будет в этом
[48:50.000 --> 48:52.000]  интерфейсе дёргать в Ascept
[48:52.000 --> 48:54.000]  из интерфейса Visitor
[48:54.000 --> 48:56.000]  Visit Element A.
[49:00.000 --> 49:02.000]  Это просто нужно,
[49:02.000 --> 49:04.000]  Accept, вот эта вся фигня,
[49:04.000 --> 49:06.000]  просто чтобы упростить запуск этого кода.
[49:08.000 --> 49:10.000]  Ну ладно, вы не могли.
[49:10.000 --> 49:12.000]  Ладно, оно здесь нужно фундаментально,
[49:12.000 --> 49:14.000]  я фигню какую-то сказал,
[49:14.000 --> 49:16.000]  прошу прощения.
[49:16.000 --> 49:18.000]  Итого, вам дали два
[49:18.000 --> 49:20.000]  абстрактных вещи, Element непонятно какой
[49:20.000 --> 49:22.000]  и Visitor непонятно какой.
[49:22.000 --> 49:24.000]  Вы с одной стороны хотите запустить какой-то метод
[49:24.000 --> 49:26.000]  Visit, один из этих двух.
[49:26.000 --> 49:28.000]  Но вы же не знаете, какой элемент вам дали?
[49:28.000 --> 49:30.000]  Не знаете, поэтому не можете
[49:30.000 --> 49:32.000]  запустить ни один из них.
[49:32.000 --> 49:34.000]  Поэтому вы пихаете Visitor в Ascept.
[49:34.000 --> 49:36.000]  Ascept проходит
[49:36.000 --> 49:38.000]  виртуальную диспетчеризацию и уже знает,
[49:38.000 --> 49:40.000]  кто я, Element A или Element B.
[49:40.000 --> 49:42.000]  А дальше он вызывает второй раз виртуальную диспетчеризацию
[49:42.000 --> 49:44.000]  уже на Visitor,
[49:44.000 --> 49:46.000]  вызывая конкретный метод Visit
[49:46.000 --> 49:48.000]  и определяет, какое я поведение.
[49:48.000 --> 49:50.000]  То есть такая двойная диспетчеризация,
[49:50.000 --> 49:52.000]  чтобы понять и поведение,
[49:52.000 --> 49:54.000]  и данные, и запустить нужный код.
[49:54.000 --> 49:56.000]  И такая группировка получается.
[49:56.000 --> 49:58.000]  А я не ожидаю,
[49:58.000 --> 50:00.000]  что вы это когда-то в жизни писать будете,
[50:00.000 --> 50:02.000]  но мне почему-то это прикалывает,
[50:02.000 --> 50:04.000]  потому что очень симметрично получается, очень красиво.
[50:04.000 --> 50:06.000]  ОП классическая по горизонтали
[50:06.000 --> 50:08.000]  группируют, а Visitor позволяет сгруппировать по вертикали.
[50:08.000 --> 50:10.000]  По-моему, это прикольно.
[50:10.000 --> 50:12.000]  Ещё, конечно, можно...
[50:12.000 --> 50:14.000]  О, так, стоп. Ещё можно
[50:14.000 --> 50:16.000]  группировать каждую ячейку по отдельности,
[50:16.000 --> 50:18.000]  вообще ничего не группируя.
[50:18.000 --> 50:20.000]  Про это у нас...
[50:20.000 --> 50:22.000]  Диагональ.
[50:22.000 --> 50:24.000]  Что вы всех расстроите.
[50:24.000 --> 50:26.000]  Чтобы все были недовольны.
[50:26.000 --> 50:28.000]  Нет, можно вообще без группировки,
[50:28.000 --> 50:30.000]  чтобы в любой момент, где угодно,
[50:30.000 --> 50:32.000]  когда угодно можно было взять
[50:32.000 --> 50:34.000]  и написать...
[50:34.000 --> 50:36.000]  Ну и реализовать
[50:36.000 --> 50:38.000]  какую-то ячейку этой таблицы.
[50:38.000 --> 50:40.000]  А там нереализованные ячейки по дефолту
[50:40.000 --> 50:42.000]  ничего не делают, например.
[50:42.000 --> 50:44.000]  Такое можно сделать при желании.
[50:44.000 --> 50:46.000]  И мы это будем делать на каком-то из семинаров
[50:46.000 --> 50:48.000]  потом в будущем.
[50:48.000 --> 50:50.000]  Вы видите перед собой бинпоиск уже некоторое время.
[50:50.000 --> 50:52.000]  Запись идёт,
[50:52.000 --> 50:54.000]  запись идёт.
[50:54.000 --> 50:56.000]  А к чему это здесь?
[50:56.000 --> 50:58.000]  Это конкретный алгоритм, он работает с Entami.
[50:58.000 --> 51:00.000]  Наша общая задача по жизни
[51:00.000 --> 51:02.000]  будет, среди прочих,
[51:02.000 --> 51:04.000]  на этом курсе это обобщать алгоритмы.
[51:04.000 --> 51:06.000]  Да?
[51:06.000 --> 51:08.000]  Ну, данные обобщать как-то
[51:08.000 --> 51:10.000]  не особо имеет смысл.
[51:10.000 --> 51:12.000]  А всё программирование, оно состоит
[51:12.000 --> 51:14.000]  только из данных и структур...
[51:14.000 --> 51:16.000]  Фу. Из данных и
[51:16.000 --> 51:18.000]  алгоритмов.
[51:18.000 --> 51:20.000]  Ча цитата знаете?
[51:20.000 --> 51:22.000]  Ну вот я не знаю.
[51:22.000 --> 51:24.000]  То есть я записал,
[51:24.000 --> 51:26.000]  но наизусть не помню.
[51:26.000 --> 51:28.000]  Умного мужика, короче.
[51:28.000 --> 51:30.000]  Вот, и
[51:30.000 --> 51:32.000]  Мы хотим обобщать алгоритмы, чтобы они
[51:32.000 --> 51:34.000]  работали с большим количеством данных
[51:34.000 --> 51:36.000]  без нужды нам что-то переписывать
[51:36.000 --> 51:38.000]  и менять.
[51:38.000 --> 51:40.000]  Понятно общая цель?
[51:44.000 --> 51:46.000]  Это максимально абстрактная
[51:46.000 --> 51:48.000]  формулировка.
[51:48.000 --> 51:50.000]  То есть, неважно.
[51:50.000 --> 51:52.000]  Просто мы хотим обобщить, чтобы
[51:52.000 --> 51:54.000]  больше кейсов можно было покрыть
[51:54.000 --> 51:56.000]  одним и тем же кодом.
[51:56.000 --> 51:58.000]  Вот этот код покрывает один кейс
[51:58.000 --> 52:00.000]  и, в принципе, всё.
[52:00.000 --> 52:02.000]  Ну, я думаю, ничего нового
[52:02.000 --> 52:04.000]  в самом коде вы не видите.
[52:04.000 --> 52:06.000]  Ну и нам надо обобщить.
[52:06.000 --> 52:08.000]  Как мы это будем делать?
[52:08.000 --> 52:10.000]  Вот на прошлой паре
[52:10.000 --> 52:12.000]  мы уже...
[52:12.000 --> 52:14.000]  Да, я думаю, камеру надо
[52:14.000 --> 52:16.000]  повернуть или меня видно?
[52:16.000 --> 52:18.000]  Видно. Хорошо.
[52:18.000 --> 52:20.000]  На прошлой паре мы уже что-то подобное
[52:20.000 --> 52:22.000]  видели, правда?
[52:22.000 --> 52:24.000]  Можно взять и запихнуть
[52:24.000 --> 52:26.000]  всё в macros, где указывается тип
[52:26.000 --> 52:28.000]  вместо int.
[52:28.000 --> 52:30.000]  А дальше вот такое сделать.
[52:30.000 --> 52:32.000]  И хоба! У нас появился...
[52:34.000 --> 52:36.000]  И macros закомменчено.
[52:36.000 --> 52:38.000]  Да.
[52:38.000 --> 52:40.000]  Наверное...
[52:44.000 --> 52:46.000]  Я не уверен, что хотел со всем этим
[52:46.000 --> 52:48.000]  комментированием добиться.
[52:50.000 --> 52:52.000]  Запустили macros, получили функцию,
[52:52.000 --> 52:54.000]  можно использовать.
[52:54.000 --> 52:56.000]  Обратите внимание на inline, про которое
[52:56.000 --> 52:58.000]  я говорил.
[52:58.000 --> 53:00.000]  Всё в хедре будете писать, поэтому inline.
[53:00.000 --> 53:02.000]  А ещё маленькое дополнение
[53:02.000 --> 53:04.000]  к прошлой паре, кстати.
[53:04.000 --> 53:06.000]  Inline в языке C и C++ работает
[53:06.000 --> 53:08.000]  абсолютно по-разному.
[53:08.000 --> 53:10.000]  Поэтому всё, что я рассказывал на прошлой паре,
[53:10.000 --> 53:12.000]  применимо только к C++.
[53:12.000 --> 53:14.000]  Если вы будете когда-нибудь писать на
[53:14.000 --> 53:16.000]  чистом C, почитайте отдельно
[53:16.000 --> 53:18.000]  о том, как это работает там.
[53:18.000 --> 53:20.000]  Окей. Едем дальше.
[53:20.000 --> 53:22.000]  Вернее, нет, не едем.
[53:22.000 --> 53:24.000]  Давайте попробуем назвать
[53:24.000 --> 53:26.000]  минусы, какие-то и плюсы у этого подхода.
[53:26.000 --> 53:28.000]  Вот именно вы.
[53:28.000 --> 53:30.000]  Если мы вот так будем выписать наш код,
[53:30.000 --> 53:32.000]  какие проблемы нас ожидают?
[53:32.000 --> 53:34.000]  И чего хорошего у нас вообще будет?
[53:34.000 --> 53:36.000]  Проблема первая, что делается, если он
[53:36.000 --> 53:38.000]  в типе стоит больше, чем у одного слова.
[53:42.000 --> 53:44.000]  Мы можем только от типов, чтобы
[53:44.000 --> 53:46.000]  верить и будет что-то поперяться.
[53:48.000 --> 53:50.000]  Да, вот проблемы с...
[53:52.000 --> 53:54.000]  Вот это главный минус.
[53:54.000 --> 53:56.000]  И про сложные типы
[53:56.000 --> 53:58.000]  это примерно в эту же стезю,
[53:58.000 --> 54:00.000]  потому что если вы сюда
[54:00.000 --> 54:02.000]  какую-нибудь пару из intа-инта подставите,
[54:02.000 --> 54:04.000]  как я в прошлый раз говорил, всё ломается.
[54:04.000 --> 54:06.000]  Ещё.
[54:10.000 --> 54:12.000]  Сейчас будет ещё много вещей,
[54:12.000 --> 54:14.000]  которым будет вопрос, зачем это нужно,
[54:14.000 --> 54:16.000]  когда можно шаблон.
[54:22.000 --> 54:24.000]  Ну да.
[54:28.000 --> 54:30.000]  Ещё что-нибудь.
[54:30.000 --> 54:32.000]  Ну это всё проблемы с непонятными
[54:32.000 --> 54:34.000]  ошибками компиляции.
[54:34.000 --> 54:36.000]  Perit'ом можно, просто надо его в круглые скобки
[54:36.000 --> 54:38.000]  ещё одни запихать.
[54:38.000 --> 54:40.000]  И вот не user-friendly, сложные ошибки компиляции.
[54:44.000 --> 54:46.000]  Может плюсы какие-то есть у этого?
[54:48.000 --> 54:50.000]  Ну в принципе да.
[54:50.000 --> 54:52.000]  Ну inline просто,
[54:52.000 --> 54:54.000]  короче да, все это не будет работать, если честно.
[54:56.000 --> 54:58.000]  То есть тут надо будет написать static inline все.
[55:06.000 --> 55:08.000]  Ну давайте я назову минус.
[55:14.000 --> 55:16.000]  Наш отрывок кода нужно заново скомпилировать для каждого
[55:16.000 --> 55:18.000]  нового типа, который мы сюда подставим.
[55:18.000 --> 55:20.000]  Это может быть долго.
[55:22.000 --> 55:24.000]  Ну да.
[55:30.000 --> 55:32.000]  Ну же.
[55:36.000 --> 55:38.000]  Так.
[55:42.000 --> 55:44.000]  Умеет, но всё равно это проблематично.
[55:44.000 --> 55:46.000]  Ну ты обычный код пишешь, всё хорошо.
[55:46.000 --> 55:48.000]  А когда вот такое начинаешь вытворять,
[55:48.000 --> 55:50.000]  ну как-то всё-таки IDE не любит такое.
[55:50.000 --> 55:52.000]  Где тогда сломается?
[56:00.000 --> 56:02.000]  Def it and def it?
[56:02.000 --> 56:04.000]  Ну не знаю.
[56:10.000 --> 56:12.000]  Почему?
[56:12.000 --> 56:14.000]  Мы не пытаемся разные функции для разных типов сделать.
[56:14.000 --> 56:16.000]  Мы пытаемся алгоритмом общить,
[56:16.000 --> 56:18.000]  чтобы туда больше всякой фигни можно было запихнуть.
[56:18.000 --> 56:20.000]  Какой ценой нам не важно.
[56:26.000 --> 56:28.000]  Ну да.
[56:34.000 --> 56:36.000]  Сейчас будет не очевидное.
[56:40.000 --> 56:42.000]  Знаете что такое iCache?
[56:44.000 --> 56:46.000]  Потому что инструкции, которые вы исполняете на процессоре,
[56:46.000 --> 56:48.000]  они тоже
[56:48.000 --> 56:50.000]  загружаются в cache
[56:50.000 --> 56:52.000]  перед тем, как собственно на процессоре
[56:52.000 --> 56:54.000]  исполняться.
[56:54.000 --> 56:56.000]  И если у вас очень много кода,
[56:56.000 --> 56:58.000]  который делает примерно одно и то же,
[56:58.000 --> 57:00.000]  но с чуть-чуть разными данными,
[57:00.000 --> 57:02.000]  одна с нотами, другая
[57:02.000 --> 57:04.000]  с флотами, третья с слонгами
[57:04.000 --> 57:06.000]  каким-нибудь, то вот этот iCache
[57:06.000 --> 57:08.000]  он будет недоволен вами.
[57:08.000 --> 57:10.000]  Потому что почти одни и те же инструкции загружаются,
[57:10.000 --> 57:12.000]  но чуть-чуть разные,
[57:12.000 --> 57:14.000]  и из-за этого разная память и все плохо.
[57:14.000 --> 57:16.000]  Поняли, о чем я?
[57:16.000 --> 57:18.000]  В шаблонах тоже самое.
[57:18.000 --> 57:20.000]  Да, и в Rasty тоже самое.
[57:20.000 --> 57:22.000]  У нас образовательный курс.
[57:22.000 --> 57:24.000]  Если вы хотите
[57:24.000 --> 57:26.000]  затроллить
[57:26.000 --> 57:28.000]  пользователя Rasta, обязательно поговорите с ним
[57:28.000 --> 57:30.000]  об instruction cache и влиянии
[57:30.000 --> 57:32.000]  монумерфизации на него.
[57:32.000 --> 57:34.000]  То есть Rasty
[57:34.000 --> 57:36.000]  тоже типа шаблоны, но чуть-чуть другие.
[57:36.000 --> 57:38.000]  Но там
[57:38.000 --> 57:40.000]  фактически получается, что на каждый
[57:40.000 --> 57:42.000]  пук создается новая инстанциация.
[57:42.000 --> 57:44.000]  Вот что угодно.
[57:44.000 --> 57:46.000]  Пишите, постоянно что-то там
[57:46.000 --> 57:48.000]  шаблонизируется, инстанцируется вообще без повода.
[57:48.000 --> 57:50.000]  И
[57:50.000 --> 57:52.000]  instruction cache от этого очень больно.
[57:52.000 --> 57:54.000]  Вот, ну ладно, давайте
[57:54.000 --> 57:56.000]  закончим на это смотреть.
[57:56.000 --> 57:58.000]  Какие-то понятные в принципе недостатки, очевидно,
[57:58.000 --> 58:00.000]  что так плохо делать. Поэтому все так и не
[58:00.000 --> 58:02.000]  делают толком-то. Все делают по-другому
[58:02.000 --> 58:04.000]  бинпоиск. Вот так его делают.
[58:04.000 --> 58:06.000]  А никак.
[58:06.000 --> 58:08.000]  Нафиг.
[58:08.000 --> 58:10.000]  Не делаю.
[58:10.000 --> 58:12.000]  Не делаю. Просто не делаю. Вот он.
[58:12.000 --> 58:14.000]  Видите, что-то
[58:14.000 --> 58:16.000]  происходит.
[58:16.000 --> 58:18.000]  Заменили все на указательную свою память.
[58:18.000 --> 58:20.000]  Да.
[58:20.000 --> 58:22.000]  Ну а что как бы?
[58:22.000 --> 58:24.000]  Так чтобы это был стиль, нужно вместо
[58:24.000 --> 58:26.000]  cd-span там более звездочки сделать.
[58:26.000 --> 58:28.000]  Ну понятное дело, но
[58:28.000 --> 58:30.000]  это очень смешной гибрид
[58:30.000 --> 58:32.000]  idc и
[58:32.000 --> 58:34.000]  синтаксис kc++20.
[58:34.000 --> 58:36.000]  Мне это кажется
[58:36.000 --> 58:38.000]  забавным.
[58:42.000 --> 58:44.000]  Ну что?
[58:44.000 --> 58:46.000]  Про это тоже нужно поговорить.
[58:46.000 --> 58:48.000]  Какие недостатки, преимущества?
[58:48.000 --> 58:50.000]  Очень большие сигнатуры
[58:50.000 --> 58:52.000]  тяжелости, мне кажется.
[58:52.000 --> 58:54.000]  Ну да, прям все.
[58:54.000 --> 58:56.000]  Бой по вякуле
[58:56.000 --> 58:58.000]  статистической проверки.
[58:58.000 --> 59:00.000]  Потому что если мы можем
[59:00.000 --> 59:02.000]  указать на байкингу, мы можем
[59:02.000 --> 59:04.000]  вякулить.
[59:04.000 --> 59:06.000]  И в этом
[59:06.000 --> 59:08.000]  знаете, как брендайна?
[59:08.000 --> 59:10.000]  Уб можно очень легко
[59:10.000 --> 59:12.000]  сравнить. На сравнении с двух
[59:12.000 --> 59:14.000]  имтов будет вызывать кол.
[59:14.000 --> 59:16.000]  Это скорее более частая проблема, что
[59:16.000 --> 59:18.000]  у меня в принципе ОС специализированных
[59:18.000 --> 59:20.000]  по типу оптимизации.
[59:20.000 --> 59:22.000]  Нет, ну как
[59:22.000 --> 59:24.000]  бы тут про то, что indirect кол
[59:24.000 --> 59:26.000]  будет, ну компилятор может догадаться
[59:26.000 --> 59:28.000]  и соптимизировать. Потому что в большинстве случаев
[59:28.000 --> 59:30.000]  вы сюда впишете просто какой-то конкретный
[59:30.000 --> 59:32.000]  фикс функции. А вот эта вся фигня
[59:32.000 --> 59:34.000]  заинлайнится?
[59:34.000 --> 59:36.000]  А дальше он увидит,
[59:36.000 --> 59:38.000]  ой, а функция-то мы знаем какая, и indirect кола
[59:38.000 --> 59:40.000]  не будет.
[59:40.000 --> 59:42.000]  Если компромат условно убежит от другого файла
[59:42.000 --> 59:44.000]  или трансляции, то его никак не заинлайнится.
[59:44.000 --> 59:46.000]  Ну а в такой ситуации шаблонизирование
[59:46.000 --> 59:48.000]  какое-нибудь вам никак не поможет
[59:48.000 --> 59:50.000]  для использования макросов.
[59:50.000 --> 59:52.000]  Потому что все равно будет, инлайнинга не произойдет,
[59:52.000 --> 59:54.000]  вы куда-то далеко пойдете.
[59:56.000 --> 59:58.000]  То есть тут вопрос только в том, что вот это может быть
[59:58.000 --> 01:00:00.000]  дополнительный indirect кол,
[01:00:00.000 --> 01:00:02.000]  но я утверждаю, что нет.
[01:00:02.000 --> 01:00:04.000]  В современных компиляторах уже не важно.
[01:00:04.000 --> 01:00:06.000]  Нельзя, чтобы
[01:00:06.000 --> 01:00:08.000]  на функцию, которая вылезает, что она наинлайнится?
[01:00:08.000 --> 01:00:10.000]  Что-что?
[01:00:10.000 --> 01:00:12.000]  Шаблон, шаблон функции,
[01:00:12.000 --> 01:00:14.000]  которая вылезает, нет?
[01:00:14.000 --> 01:00:16.000]  Да, в этом вся идея этого подхода
[01:00:16.000 --> 01:00:18.000]  в том, что никаких шаблонов, мы просто с
[01:00:18.000 --> 01:00:20.000]  байтиками работаем. Знаете,
[01:00:20.000 --> 01:00:22.000]  какой плюс у этого?
[01:00:22.000 --> 01:00:24.000]  iQishook хорошо.
[01:00:28.000 --> 01:00:30.000]  Тут один и тот же bytecode будет
[01:00:30.000 --> 01:00:32.000]  заимечен для всех типов.
[01:00:34.000 --> 01:00:36.000]  Кроме этой одной функции,
[01:00:36.000 --> 01:00:38.000]  которая там будет разная.
[01:00:38.000 --> 01:00:40.000]  Ну как бы в данном примере
[01:00:40.000 --> 01:00:42.000]  все рассуждения про iQish
[01:00:42.000 --> 01:00:44.000]  это лукавство полное, здесь
[01:00:44.000 --> 01:00:46.000]  не повлияет.
[01:00:46.000 --> 01:00:48.000]  Программисту будет плохо, мы уже вроде как
[01:00:48.000 --> 01:00:50.000]  и сказали.
[01:00:50.000 --> 01:00:52.000]  Да, рассуждение про iQish относится
[01:00:52.000 --> 01:00:54.000]  на более большие масштабы, более крупные
[01:00:54.000 --> 01:00:56.000]  какие-то отрывки кода
[01:00:56.000 --> 01:00:58.000]  про проекты.
[01:00:58.000 --> 01:01:00.000]  Размер Benign и iQish
[01:01:00.000 --> 01:01:02.000]  тоже.
[01:01:02.000 --> 01:01:04.000]  Это все в одно и то же место
[01:01:04.000 --> 01:01:06.000]  можно вписать.
[01:01:12.000 --> 01:01:14.000]  Потому что
[01:01:14.000 --> 01:01:16.000]  если у вас экзешник игры
[01:01:16.000 --> 01:01:18.000]  весит 20 гигов, пользователь будет
[01:01:18.000 --> 01:01:20.000]  недоволен.
[01:01:20.000 --> 01:01:22.000]  Если 100, то он будет рад.
[01:01:22.000 --> 01:01:24.000]  Я про экзешника,
[01:01:24.000 --> 01:01:26.000]  не про ресурсы к игре.
[01:01:26.000 --> 01:01:28.000]  Ну, не важно.
[01:01:28.000 --> 01:01:30.000]  Разве игры упираются по размеру
[01:01:30.000 --> 01:01:32.000]  самой игры в бинарии?
[01:01:32.000 --> 01:01:34.000]  Чем меньше
[01:01:34.000 --> 01:01:36.000]  ты всякого мусора в свой бинарий
[01:01:36.000 --> 01:01:38.000]  вложишь, тем больше HD текстурок
[01:01:38.000 --> 01:01:40.000]  4К разрешения ты сможешь
[01:01:40.000 --> 01:01:42.000]  напихать, чтобы пользователь не
[01:01:42.000 --> 01:01:44.000]  ворчал. По-моему этот
[01:01:44.000 --> 01:01:46.000]  трейдов понятный.
[01:01:46.000 --> 01:01:48.000]  Ну что,
[01:01:48.000 --> 01:01:50.000]  еще придумаем что-нибудь про это?
[01:01:52.000 --> 01:01:54.000]  Идейно,
[01:01:54.000 --> 01:01:56.000]  мы отложили,
[01:01:56.000 --> 01:01:58.000]  два подхода уже увидели,
[01:01:58.000 --> 01:02:00.000]  в этом подходе мы отложили решение
[01:02:00.000 --> 01:02:02.000]  о том, как конкретно будет алгоритм
[01:02:02.000 --> 01:02:04.000]  себя вести до фактически
[01:02:04.000 --> 01:02:06.000]  времени при процессинге.
[01:02:06.000 --> 01:02:08.000]  А здесь мы отложили момент
[01:02:08.000 --> 01:02:10.000]  решения, как конкретно алгоритм
[01:02:10.000 --> 01:02:12.000]  себя будет вести
[01:02:12.000 --> 01:02:14.000]  до рантайма,
[01:02:14.000 --> 01:02:16.000]  что тут компаратор,
[01:02:16.000 --> 01:02:18.000]  он в рантайме может любой вообще получиться.
[01:02:18.000 --> 01:02:20.000]  Как бы да,
[01:02:20.000 --> 01:02:22.000]  а может и нет.
[01:02:24.000 --> 01:02:26.000]  Да,
[01:02:26.000 --> 01:02:28.000]  но ты же можешь сюда любой компаратор
[01:02:28.000 --> 01:02:30.000]  пихнуть,
[01:02:30.000 --> 01:02:32.000]  пихнуть сюда вызов функции
[01:02:32.000 --> 01:02:34.000]  другой, который из сложной логики
[01:02:34.000 --> 01:02:36.000]  выбирает один из десяти компараторов.
[01:02:38.000 --> 01:02:40.000]  Да,
[01:02:40.000 --> 01:02:42.000]  я об этом и говорю, что здесь
[01:02:42.000 --> 01:02:44.000]  в рантайме выбор, вот тут,
[01:02:44.000 --> 01:02:46.000]  а в верхнем только при процессинге.
[01:02:46.000 --> 01:02:48.000]  Что ты хотел сказать?
[01:02:50.000 --> 01:02:52.000]  Да, да, и все равно iCache
[01:02:52.000 --> 01:02:54.000]  будет плохо. Ну это да, это трейдов,
[01:02:54.000 --> 01:02:56.000]  невозможно
[01:02:56.000 --> 01:02:58.000]  как бы и съесть торт, и остаться
[01:02:58.000 --> 01:03:00.000]  с ним.
[01:03:06.000 --> 01:03:08.000]  Да, но не всегда же оно заинлайнится.
[01:03:08.000 --> 01:03:10.000]  Чтобы понять, что что-то заинлайнилось,
[01:03:10.000 --> 01:03:12.000]  есть ровно один выход, это пойти прочитать
[01:03:12.000 --> 01:03:14.000]  Assembler.
[01:03:14.000 --> 01:03:16.000]  По-другому не догадаться.
[01:03:18.000 --> 01:03:20.000]  Ну и с другой стороны, возможно вы и не хотите,
[01:03:20.000 --> 01:03:22.000]  чтобы оно инлайнилось,
[01:03:22.000 --> 01:03:24.000]  напишите в cpp-шник, и тогда все будет
[01:03:24.000 --> 01:03:26.000]  без онлайна.
[01:03:26.000 --> 01:03:28.000]  Ну короче, какие-то профиты есть
[01:03:28.000 --> 01:03:30.000]  и у этого подхода, какие-то и у того.
[01:03:30.000 --> 01:03:32.000]  Есть наша любимая ООП.
[01:03:34.000 --> 01:03:36.000]  Вы не понимали, почему написать
[01:03:36.000 --> 01:03:38.000]  нельзя просто этот?
[01:03:38.000 --> 01:03:40.000]  Ну все, все сломалось.
[01:03:40.000 --> 01:03:42.000]  Почему нельзя
[01:03:42.000 --> 01:03:44.000]  написать шаблон, потому что можно по-другому
[01:03:44.000 --> 01:03:46.000]  обобщать код?
[01:03:46.000 --> 01:03:48.000]  Вот мы берем,
[01:03:48.000 --> 01:03:50.000]  делаем интерфейс,
[01:03:50.000 --> 01:03:52.000]  iCompareable,
[01:03:52.000 --> 01:03:54.000]  и делаем compare to другой
[01:03:54.000 --> 01:03:56.000]  iCompareable.
[01:03:56.000 --> 01:03:58.000]  Для этого нужно по варианту идти.
[01:03:58.000 --> 01:04:00.000]  Тут будет проблема, что мы не всегда хотим сравнить
[01:04:00.000 --> 01:04:02.000]  любые два iCompareables.
[01:04:02.000 --> 01:04:04.000]  Но iCompareable для каждого типа.
[01:04:04.000 --> 01:04:06.000]  Ну тут сразу есть
[01:04:06.000 --> 01:04:08.000]  бедыш,
[01:04:08.000 --> 01:04:10.000]  который уже написан в коде,
[01:04:10.000 --> 01:04:12.000]  а так в какие-нибудь моменты
[01:04:12.000 --> 01:04:14.000]  пары?
[01:04:14.000 --> 01:04:16.000]  Ну,
[01:04:16.000 --> 01:04:18.000]  ну или от динамикаста может быть
[01:04:18.000 --> 01:04:20.000]  еще не так страшно.
[01:04:20.000 --> 01:04:22.000]  Больше проблема, что если кто-то
[01:04:22.000 --> 01:04:24.000]  где-то написал тип, который
[01:04:24.000 --> 01:04:26.000]  не дубовку, а где-то iCompareable,
[01:04:26.000 --> 01:04:28.000]  то нужно писать датку над этим типом.
[01:04:28.000 --> 01:04:30.000]  Вот именно да.
[01:04:30.000 --> 01:04:32.000]  Я бы сказал,
[01:04:32.000 --> 01:04:34.000]  больше проблема в том, что вы
[01:04:34.000 --> 01:04:36.000]  насиловать компьютера
[01:04:36.000 --> 01:04:38.000]  будете вот такими действиями.
[01:04:38.000 --> 01:04:40.000]  Ну просто нельзя так писать код.
[01:04:40.000 --> 01:04:42.000]  А джависты пишут.
[01:04:42.000 --> 01:04:44.000]  Да? Внезапно.
[01:04:44.000 --> 01:04:46.000]  Для тех, кто не знает,
[01:04:46.000 --> 01:04:48.000]  процессор
[01:04:48.000 --> 01:04:50.000]  загружает память,
[01:04:50.000 --> 01:04:52.000]  память из компьютера блоками
[01:04:52.000 --> 01:04:54.000]  4 байта. Меньше он не умеет.
[01:04:54.000 --> 01:04:56.000]  Если вы пишете
[01:04:56.000 --> 01:04:58.000]  вот такой код, а я надеюсь, вы понимаете, что это значит,
[01:04:58.000 --> 01:05:00.000]  да, у нас есть
[01:05:00.000 --> 01:05:02.000]  контейнер с указателями на
[01:05:02.000 --> 01:05:04.000]  инты, и каждый инт
[01:05:04.000 --> 01:05:06.000]  хранится где-то непонятно где на кучу,
[01:05:06.000 --> 01:05:08.000]  в произвольном месте.
[01:05:08.000 --> 01:05:10.000]  Что это значит? Итерируясь по этому...
[01:05:10.000 --> 01:05:12.000]  Фабрика использована,
[01:05:12.000 --> 01:05:14.000]  они хранятся рядом.
[01:05:14.000 --> 01:05:16.000]  Ну,
[01:05:16.000 --> 01:05:18.000]  если повезло, а если ты еще какие-то действия
[01:05:18.000 --> 01:05:20.000]  подделал, то все сломается.
[01:05:20.000 --> 01:05:22.000]  Так вот, что будет происходить,
[01:05:22.000 --> 01:05:24.000]  когда вы будете что-то искать
[01:05:24.000 --> 01:05:26.000]  в таком массиве, как-то по нему
[01:05:26.000 --> 01:05:28.000]  ходить? Каждая загрузка любого
[01:05:28.000 --> 01:05:30.000]  инта из этого массива — это промах
[01:05:30.000 --> 01:05:32.000]  по кышу и загрузка 64
[01:05:32.000 --> 01:05:34.000]  байт лишних, из которых вам нужно
[01:05:34.000 --> 01:05:36.000]  примерно 4.
[01:05:36.000 --> 01:05:38.000]  То есть вы понимаете, что вы замедлите код
[01:05:38.000 --> 01:05:40.000]  таким образом. Вот 64
[01:05:40.000 --> 01:05:42.000]  делить не 4. Сколько будет? 16.
[01:05:42.000 --> 01:05:44.000]  В 16 раз замедлите код.
[01:05:44.000 --> 01:05:46.000]  Но очевидно, что оно здесь в память
[01:05:46.000 --> 01:05:48.000]  будет упираться, правда?
[01:05:48.000 --> 01:05:50.000]  Процессорных инструкций здесь нету
[01:05:50.000 --> 01:05:52.000]  фактически.
[01:05:52.000 --> 01:05:54.000]  Значит, единственное, что нас интересует, это
[01:05:54.000 --> 01:05:56.000]  насколько мы хорошо
[01:05:56.000 --> 01:05:58.000]  читаем память.
[01:05:58.000 --> 01:06:00.000]  Почему мы на самом деле сильнее
[01:06:00.000 --> 01:06:02.000]  замедлим код, если вспомнить нашу
[01:06:02.000 --> 01:06:04.000]  майнинг?
[01:06:06.000 --> 01:06:08.000]  Ну да, тоже верно.
[01:06:08.000 --> 01:06:10.000]  Просто из того,
[01:06:10.000 --> 01:06:12.000]  как мы работаем с памятью,
[01:06:14.000 --> 01:06:16.000]  каждый доступ к инту из этого
[01:06:16.000 --> 01:06:18.000]  массива — это промах по кышу, загрузка
[01:06:18.000 --> 01:06:20.000]  48,
[01:06:20.000 --> 01:06:22.000]  60 лишних байт,
[01:06:22.000 --> 01:06:24.000]  которые вам не нужны, которые вы
[01:06:24.000 --> 01:06:26.000]  выкидываете. А если бы мы написали вот так?
[01:06:26.000 --> 01:06:28.000]  Разведите только там
[01:06:28.000 --> 01:06:30.000]  маленький...
[01:06:30.000 --> 01:06:32.000]  Да, да, да, да. Тут должен был быть
[01:06:32.000 --> 01:06:34.000]  линейный поиск, чтобы аргумент был более
[01:06:34.000 --> 01:06:36.000]  весомый. Потому что бинпоиск, он так и так
[01:06:36.000 --> 01:06:38.000]  прыгает вот так вот по массиву. Но когда
[01:06:38.000 --> 01:06:40.000]  вы уже сузили свой диапазон поиска
[01:06:40.000 --> 01:06:42.000]  до 64 байт,
[01:06:42.000 --> 01:06:44.000]  да, вот этот подход
[01:06:44.000 --> 01:06:46.000]  нужно делать линейный поиск вообще-то,
[01:06:46.000 --> 01:06:48.000]  потому что это будет быстрее.
[01:06:48.000 --> 01:06:50.000]  Но во всяком случае,
[01:06:50.000 --> 01:06:52.000]  когда вы сузились до 64 байт,
[01:06:52.000 --> 01:06:54.000]  вы хотите просто вот один раз загрузить
[01:06:54.000 --> 01:06:56.000]  их и всё, и прыгайте там как хотите.
[01:07:00.000 --> 01:07:02.000]  А здесь, даже когда мы сузились
[01:07:02.000 --> 01:07:04.000]  до 64 байт в нашем диапазоне,
[01:07:04.000 --> 01:07:06.000]  мы будем постоянно
[01:07:06.000 --> 01:07:08.000]  загружать каждый инд заново из памяти.
[01:07:08.000 --> 01:07:10.000]  Это будет очень медленно.
[01:07:10.000 --> 01:07:12.000]  Надеюсь, я вас как-то убедил, что
[01:07:12.000 --> 01:07:14.000]  у ОП очень плохо получается
[01:07:14.000 --> 01:07:16.000]  на самом деле обобщать какие-то
[01:07:16.000 --> 01:07:18.000]  элементарные алгоритмы.
[01:07:18.000 --> 01:07:20.000]  У ОП хорошо получается
[01:07:20.000 --> 01:07:22.000]  моделировать какие-то сложные системы
[01:07:22.000 --> 01:07:24.000]  высокоуровневые,
[01:07:24.000 --> 01:07:26.000]  но таким вы занимаетесь
[01:07:26.000 --> 01:07:28.000]  как правило в нормальных компаниях
[01:07:28.000 --> 01:07:30.000]  минимум времени.
[01:07:30.000 --> 01:07:32.000]  Вы не сидите и не делаете абстрактные
[01:07:32.000 --> 01:07:34.000]  менеджеры, фабрик,
[01:07:34.000 --> 01:07:36.000]  медиаторов, адаптеров,
[01:07:36.000 --> 01:07:38.000]  чего-то там
[01:07:38.000 --> 01:07:40.000]  над систем.
[01:07:40.000 --> 01:07:42.000]  Вы данные обрабатываете.
[01:07:42.000 --> 01:07:44.000]  Кто не согласен с этим утверждением?
[01:07:44.000 --> 01:07:46.000]  Вдруг я не прав?
[01:07:46.000 --> 01:07:48.000]  Почему ты не согласен?
[01:07:48.000 --> 01:07:50.000]  Я хранил только данные.
[01:07:50.000 --> 01:07:52.000]  А, ты только хранишь.
[01:07:52.000 --> 01:07:54.000]  То есть ты пишешь базы данных
[01:07:54.000 --> 01:07:56.000]  и тебе их нужно только сохранить.
[01:07:56.000 --> 01:07:58.000]  Они же пришли по сети, их нужно приложить в память.
[01:07:58.000 --> 01:08:00.000]  Ты обрабатываешь данные.
[01:08:00.000 --> 01:08:02.000]  Мы все занимаемся обработкой данных
[01:08:02.000 --> 01:08:04.000]  по сути. Написанием алгоритмов
[01:08:04.000 --> 01:08:06.000]  по большей части.
[01:08:06.000 --> 01:08:08.000]  Когда мы там уже доросли, мы начинаем системы
[01:08:08.000 --> 01:08:10.000]  дизайнах делать.
[01:08:10.000 --> 01:08:12.000]  Там паттерны ОП, вот это все.
[01:08:12.000 --> 01:08:14.000]  А когда вы просто пишете код,
[01:08:14.000 --> 01:08:16.000]  нам в первую очередь важно, чтобы
[01:08:16.000 --> 01:08:18.000]  а, простой,
[01:08:18.000 --> 01:08:20.000]  все.
[01:08:20.000 --> 01:08:22.000]  В попытке обобщить бинпоиск
[01:08:22.000 --> 01:08:24.000]  ОП не справилось абсолютно.
[01:08:24.000 --> 01:08:26.000]  Чистое ОП.
[01:08:26.000 --> 01:08:28.000]  Поэтому, конечно же, и
[01:08:28.000 --> 01:08:30.000]  все минусы
[01:08:30.000 --> 01:08:32.000]  вы уже назвали,
[01:08:32.000 --> 01:08:34.000]  я их забыл записать,
[01:08:34.000 --> 01:08:36.000]  но будем считать, что мы помним.
[01:08:36.000 --> 01:08:38.000]  Все очень плохо здесь, короче.
[01:08:38.000 --> 01:08:40.000]  Так вот, три подхода.
[01:08:40.000 --> 01:08:42.000]  Все из них не очень хорошие.
[01:08:42.000 --> 01:08:44.000]  Нужно сделать новый подход,
[01:08:44.000 --> 01:08:46.000]  который все проблемы решит.
[01:08:46.000 --> 01:08:48.000]  Нет.
[01:08:48.000 --> 01:08:50.000]  Ну все, шаблоны.
[01:08:52.000 --> 01:08:54.000]  Это была отсылка, если вы не поняли.
[01:08:54.000 --> 01:08:56.000]  Про 14 стандартов нужно сделать один,
[01:08:56.000 --> 01:08:58.000]  который все объединит и все проблемы решит.
[01:08:58.000 --> 01:09:00.000]  Результат 15 конкурирующих стандартов.
[01:09:02.000 --> 01:09:04.000]  Тут та же самая ситуация.
[01:09:04.000 --> 01:09:06.000]  Несмотря на то, что шаблоны многие вещи
[01:09:08.000 --> 01:09:10.000]  делают хорошо,
[01:09:10.000 --> 01:09:12.000]  в других мечах они такие же проблематичные.
[01:09:12.000 --> 01:09:14.000]  Но вот давайте...
[01:09:14.000 --> 01:09:16.000]  Блин, надо выписать все-таки.
[01:09:16.000 --> 01:09:18.000]  С Макасом я вижу только одну проблему удобства.
[01:09:18.000 --> 01:09:20.000]  Да.
[01:09:20.000 --> 01:09:22.000]  Они сильно удобнее.
[01:09:22.000 --> 01:09:24.000]  Они раньше проверяются, всякий синтаксис чекается,
[01:09:24.000 --> 01:09:26.000]  вызывать удобно.
[01:09:26.000 --> 01:09:28.000]  Фактически все эти минусы, кроме iCache, они ушли.
[01:09:28.000 --> 01:09:30.000]  Давайте...
[01:09:30.000 --> 01:09:32.000]  Они читаемые.
[01:09:32.000 --> 01:09:34.000]  Да-да-да.
[01:09:34.000 --> 01:09:36.000]  Ну...
[01:09:36.000 --> 01:09:38.000]  Плюс-минус не читаемые.
[01:09:38.000 --> 01:09:40.000]  Чуть-чуть плюс-минус
[01:09:40.000 --> 01:09:42.000]  Концерты.
[01:09:42.000 --> 01:09:44.000]  Ну, смотрите, как бы...
[01:09:44.000 --> 01:09:46.000]  Не копируемые.
[01:09:46.000 --> 01:09:48.000]  А что?
[01:09:48.000 --> 01:09:50.000]  Почему...
[01:09:50.000 --> 01:09:52.000]  Ну, это ко всем относится, что выше была.
[01:09:52.000 --> 01:09:54.000]  А почему ты... Где я копирую?
[01:09:54.000 --> 01:09:56.000]  ТВЛ.
[01:09:56.000 --> 01:09:58.000]  Ну, можно ссылку поставить, если хочешь.
[01:09:58.000 --> 01:10:00.000]  Концссылку.
[01:10:02.000 --> 01:10:04.000]  Так, по-моему, такой код ставил.
[01:10:04.000 --> 01:10:06.000]  Ну и все.
[01:10:06.000 --> 01:10:08.000]  Нет, это не проблема.
[01:10:08.000 --> 01:10:10.000]  Вот какие-то общие свойства того,
[01:10:10.000 --> 01:10:12.000]  на какой класс типов мы обобщаем наш алгоритм,
[01:10:12.000 --> 01:10:14.000]  они как бы ну...
[01:10:14.000 --> 01:10:16.000]  Абстрактные.
[01:10:20.000 --> 01:10:22.000]  Я бы сказал, что
[01:10:22.000 --> 01:10:24.000]  Visual Studio
[01:10:24.000 --> 01:10:26.000]  будет плохо.
[01:10:26.000 --> 01:10:28.000]  Потому что это именно она
[01:10:28.000 --> 01:10:30.000]  нифига не умеет нормально
[01:10:30.000 --> 01:10:32.000]  подсвечивать синтаксис, подсказывать
[01:10:32.000 --> 01:10:34.000]  в рамках шаблонов.
[01:10:34.000 --> 01:10:36.000]  Два года назад с Vimeo было плохо.
[01:10:36.000 --> 01:10:38.000]  Я с ClangD
[01:10:38.000 --> 01:10:40.000]  живу просто в S-коде
[01:10:40.000 --> 01:10:42.000]  и в принципе нормально.
[01:10:42.000 --> 01:10:44.000]  Самый правильный код — это выключить
[01:10:44.000 --> 01:10:46.000]  апеллисансы. Да, и писать весь код в ВИМИ.
[01:10:46.000 --> 01:10:48.000]  Ладно.
[01:10:48.000 --> 01:10:50.000]  Любой IDE на самом деле будет немножко плохо,
[01:10:50.000 --> 01:10:52.000]  но гораздо лучше, чем с макросами.
[01:10:52.000 --> 01:10:54.000]  Это тоже, ну, чуть-чуть
[01:10:54.000 --> 01:10:56.000]  хуже, чем у макросов.
[01:10:56.000 --> 01:10:58.000]  Вот, блин,
[01:10:58.000 --> 01:11:00.000]  мы так не записали, что было проблематично.
[01:11:04.000 --> 01:11:06.000]  Да...
[01:11:08.000 --> 01:11:10.000]  Вот так вот.
[01:11:10.000 --> 01:11:12.000]  Наверное, неправильно
[01:11:12.000 --> 01:11:14.000]  написал, да?
[01:11:14.000 --> 01:11:16.000]  Нет, наверное, правильно.
[01:11:16.000 --> 01:11:18.000]  Что вы еще называли про ОП?
[01:11:20.000 --> 01:11:22.000]  Сложно вызывать, да?
[01:11:22.000 --> 01:11:24.000]  Что-то такое говорили.
[01:11:24.000 --> 01:11:26.000]  Ну, да-да-да.
[01:11:30.000 --> 01:11:32.000]  Ну, медленно.
[01:11:32.000 --> 01:11:34.000]  Ну, в принципе у нас
[01:11:34.000 --> 01:11:36.000]  какие-то минимальные классы,
[01:11:36.000 --> 01:11:38.000]  если так на все делать,
[01:11:38.000 --> 01:11:40.000]  разрастаются до огромных.
[01:11:40.000 --> 01:11:42.000]  Что разрастается?
[01:11:42.000 --> 01:11:44.000]  Ну, у нас минимальные какие-то классы,
[01:11:44.000 --> 01:11:46.000]  просто из-за того, что нам все это нужно еще
[01:11:46.000 --> 01:11:48.000]  виртуально включать, разрастаются до каких-то огромных.
[01:11:48.000 --> 01:11:50.000]  Такой класс, который делает минимум,
[01:11:50.000 --> 01:11:52.000]  разрастается до сотен байков.
[01:11:52.000 --> 01:11:54.000]  Сотен байков.
[01:11:54.000 --> 01:11:56.000]  Просто потому, что мы подключили пять таких функционалов.
[01:11:58.000 --> 01:12:00.000]  Не уверен о чем-то.
[01:12:00.000 --> 01:12:02.000]  Где здесь класс?
[01:12:02.000 --> 01:12:04.000]  Если у нас iCompare,
[01:12:04.000 --> 01:12:06.000]  то мы потом еще будет фичу.
[01:12:06.000 --> 01:12:08.000]  И у нас в итоге там на каждый идет по 8-16 байков
[01:12:08.000 --> 01:12:10.000]  и виртуальное наследование.
[01:12:10.000 --> 01:12:12.000]  А не надо делать виртуальное наследование, ты чего?
[01:12:12.000 --> 01:12:14.000]  Не всегда получается виртуальное наследование.
[01:12:14.000 --> 01:12:16.000]  Ну, если не получается, то это все.
[01:12:16.000 --> 01:12:18.000]  Это храм с точки зрения ОП.
[01:12:18.000 --> 01:12:20.000]  Ты уже не ОП занимаешься чем-то более
[01:12:20.000 --> 01:12:22.000]  общим, абстрактным.
[01:12:22.000 --> 01:12:24.000]  То есть в ОП есть один класс
[01:12:24.000 --> 01:12:26.000]  и много интерфейсов.
[01:12:26.000 --> 01:12:28.000]  Тут речь именно о том,
[01:12:28.000 --> 01:12:30.000]  что интерфейсы.
[01:12:34.000 --> 01:12:36.000]  Ну, медленно, да.
[01:12:36.000 --> 01:12:38.000]  Ну, короче, вот это все.
[01:12:38.000 --> 01:12:40.000]  Кажется, что вот это все мы шаблонами
[01:12:40.000 --> 01:12:42.000]  лечим, то есть мы ближе к макросам
[01:12:42.000 --> 01:12:44.000]  в плане...
[01:12:50.000 --> 01:12:52.000]  В плане всего.
[01:12:52.000 --> 01:12:54.000]  Шаблоны больше похожи на макросы,
[01:12:54.000 --> 01:12:56.000]  поэтому проблем, связанных с ОП
[01:12:56.000 --> 01:12:58.000]  и всяким этим, нет.
[01:12:58.000 --> 01:13:00.000]  Но не все проблемы
[01:13:00.000 --> 01:13:02.000]  макросов до конца решены.
[01:13:02.000 --> 01:13:04.000]  Давайте еще вот на это посмотрим.
[01:13:04.000 --> 01:13:06.000]  Есть ли вот о этой штуке
[01:13:06.000 --> 01:13:08.000]  плюсы по сравнению с шаблонами?
[01:13:08.000 --> 01:13:10.000]  Кажется, есть. Если все типы стереть
[01:13:10.000 --> 01:13:12.000]  и работать с байтами, то iCache
[01:13:12.000 --> 01:13:14.000]  будет счастлив.
[01:13:14.000 --> 01:13:16.000]  Ну, вот про выбор компаратора.
[01:13:20.000 --> 01:13:22.000]  Может быть проблема, что
[01:13:22.000 --> 01:13:24.000]  если мы используем стандартный тип,
[01:13:24.000 --> 01:13:26.000]  у него есть
[01:13:26.000 --> 01:13:28.000]  дефолт на определенный
[01:13:28.000 --> 01:13:30.000]  оператор меньше.
[01:13:30.000 --> 01:13:32.000]  А мы можем хотеть
[01:13:32.000 --> 01:13:34.000]  другой оператор меньше?
[01:13:34.000 --> 01:13:36.000]  Ну да, примерно такие вещи.
[01:13:36.000 --> 01:13:38.000]  Можно пофиксить опциональным аргументом?
[01:13:38.000 --> 01:13:40.000]  Пофиксить можно.
[01:13:40.000 --> 01:13:42.000]  Я бы даже обобщил этот вопрос
[01:13:42.000 --> 01:13:44.000]  до того, что... Ну, если вот ровно так
[01:13:44.000 --> 01:13:46.000]  написать, то
[01:13:46.000 --> 01:13:48.000]  вы ровно один конкретный компаратор
[01:13:48.000 --> 01:13:50.000]  можете использовать с конкретным типом.
[01:13:52.000 --> 01:13:54.000]  Но это решается.
[01:13:54.000 --> 01:13:56.000]  Есть еще один важный моментик,
[01:13:56.000 --> 01:13:58.000]  который мы вот как-то проскользнули
[01:13:58.000 --> 01:14:00.000]  по нему... Ой, я не туда открыл.
[01:14:00.000 --> 01:14:02.000]  Проскользнули по нему про
[01:14:02.000 --> 01:14:04.000]  открытость и закрытость.
[01:14:04.000 --> 01:14:06.000]  Вот это,
[01:14:06.000 --> 01:14:08.000]  что называется закрытый алгоритм.
[01:14:08.000 --> 01:14:10.000]  Потому что нам нужно
[01:14:10.000 --> 01:14:12.000]  явно пойти и...
[01:14:12.000 --> 01:14:14.000]  Ладно, я не уверен, что это конкретно
[01:14:14.000 --> 01:14:16.000]  так корректно называть.
[01:14:16.000 --> 01:14:18.000]  Давайте так это все-таки называть.
[01:14:18.000 --> 01:14:20.000]  Чтобы тип наш впихнуть
[01:14:20.000 --> 01:14:22.000]  в этот алгоритм, надо пойти
[01:14:22.000 --> 01:14:24.000]  отнаследовать его от iComparable, либо написать обертку.
[01:14:24.000 --> 01:14:26.000]  То есть нам необходимо менять
[01:14:26.000 --> 01:14:28.000]  чужие типы данных, чтобы они подходили
[01:14:28.000 --> 01:14:30.000]  к нашему алгоритму.
[01:14:30.000 --> 01:14:32.000]  Плохое обобщение, вам не кажется?
[01:14:32.000 --> 01:14:34.000]  То есть ну...
[01:14:36.000 --> 01:14:38.000]  Подключив библиотеку какую-то, где уже
[01:14:38.000 --> 01:14:40.000]  есть какой-то тип данных, вы не сможете
[01:14:40.000 --> 01:14:42.000]  просто его использовать с таким обобщением.
[01:14:42.000 --> 01:14:44.000]  Грустно.
[01:14:44.000 --> 01:14:46.000]  Взяли, написали хитрый аккомпаратор,
[01:14:46.000 --> 01:14:48.000]  все работает.
[01:14:48.000 --> 01:14:50.000]  И в шаблонах тоже сможете.
[01:14:50.000 --> 01:14:52.000]  Написав свой там
[01:14:52.000 --> 01:14:54.000]  оператор меньше или
[01:14:54.000 --> 01:14:56.000]  перегрузив чего-нибудь, ну или
[01:14:56.000 --> 01:14:58.000]  вообще функцию здесь какую-то вызывать.
[01:14:58.000 --> 01:15:00.000]  Вот.
[01:15:02.000 --> 01:15:04.000]  На этом, мне кажется, все про вот это вот
[01:15:04.000 --> 01:15:06.000]  сравнение.
[01:15:06.000 --> 01:15:08.000]  Я хотел, чтобы вы почувствовали, что обобщать...
[01:15:08.000 --> 01:15:10.000]  Ну, нас покидать начинают.
[01:15:10.000 --> 01:15:12.000]  Удачи.
[01:15:12.000 --> 01:15:14.000]  Я хотел, чтобы вы прочувствовали, что
[01:15:14.000 --> 01:15:16.000]  вообще говоря, наша цель
[01:15:16.000 --> 01:15:18.000]  она обобщать алгоритмы.
[01:15:18.000 --> 01:15:20.000]  Делать это можно по-разному.
[01:15:20.000 --> 01:15:22.000]  У этого есть разные плюсы, разные минусы.
[01:15:22.000 --> 01:15:24.000]  Я очень сильно сейчас полил грязью ОП,
[01:15:24.000 --> 01:15:26.000]  но это, конечно, ну так,
[01:15:26.000 --> 01:15:28.000]  лукавство.
[01:15:28.000 --> 01:15:30.000]  Нет, какие-то плюсы ОП есть.
[01:15:30.000 --> 01:15:32.000]  Какие-то вопросы, какие-то проблемы
[01:15:32.000 --> 01:15:34.000]  оно решает хорошо, но надо чувствовать
[01:15:34.000 --> 01:15:36.000]  какие конкретно.
[01:15:36.000 --> 01:15:38.000]  Вот.
[01:15:38.000 --> 01:15:40.000]  И дальше мы будем, в принципе,
[01:15:40.000 --> 01:15:42.000]  пользоваться не только шаблонами
[01:15:42.000 --> 01:15:44.000]  для обобщения алгоритмов.
[01:15:48.000 --> 01:15:50.000]  Чувствуется, что какое-то вот
[01:15:50.000 --> 01:15:52.000]  заключительное слово нужно, но у меня его нет.
[01:15:52.000 --> 01:15:54.000]  Поэтому мы просто возвращаемся к презентации,
[01:15:54.000 --> 01:15:56.000]  потому что
[01:15:56.000 --> 01:15:58.000]  время подходит к...
[01:15:58.000 --> 01:16:00.000]  Это что такое? Это не то.
[01:16:00.000 --> 01:16:02.000]  И это не то.
[01:16:02.000 --> 01:16:04.000]  Вот так.
[01:16:04.000 --> 01:16:06.000]  Да, время подходит к концу.
[01:16:06.000 --> 01:16:08.000]  Нам нужно пройти презентацию.
[01:16:08.000 --> 01:16:10.000]  Так что какие-то...
[01:16:12.000 --> 01:16:14.000]  Какие-какие-какие...
[01:16:14.000 --> 01:16:16.000]  Я хотел спросить у вас, знаете ли,
[01:16:16.000 --> 01:16:18.000]  в эму в семантику.
[01:16:18.000 --> 01:16:20.000]  Да?
[01:16:20.000 --> 01:16:22.000]  Я не хочу.
[01:16:24.000 --> 01:16:26.000]  Что значит знаем?
[01:16:26.000 --> 01:16:28.000]  Ну, давайте...
[01:16:28.000 --> 01:16:30.000]  Мы знаем, что...
[01:16:30.000 --> 01:16:32.000]  Как ее писать? Знаем, как она работает.
[01:16:32.000 --> 01:16:34.000]  Честно, я не особо...
[01:16:34.000 --> 01:16:36.000]  Давай, работай.
[01:16:36.000 --> 01:16:38.000]  Давайте, контрольный вопрос.
[01:16:40.000 --> 01:16:42.000]  Не как работает, это как...
[01:16:42.000 --> 01:16:44.000]  Да, блин, работай. Что такое?
[01:16:44.000 --> 01:16:46.000]  Совсем.
[01:16:46.000 --> 01:16:48.000]  Выбрали, видимо,
[01:16:48.000 --> 01:16:50.000]  скринт.
[01:16:50.000 --> 01:16:52.000]  Надо вернуть туда обратно.
[01:16:54.000 --> 01:16:56.000]  У вас есть?
[01:16:56.000 --> 01:16:58.000]  Давайте...
[01:16:58.000 --> 01:17:00.000]  У вас есть?
[01:17:18.000 --> 01:17:20.000]  Тише, давай, работай.
[01:17:20.000 --> 01:17:22.000]  Контрольный вопрос
[01:17:22.000 --> 01:17:24.000]  на знание.
[01:17:24.000 --> 01:17:26.000]  Мы в семантике.
[01:17:26.000 --> 01:17:28.000]  L-value, R-value.
[01:17:28.000 --> 01:17:30.000]  Это прилагательное, на самом деле, да?
[01:17:30.000 --> 01:17:32.000]  Что они описывают?
[01:17:32.000 --> 01:17:34.000]  Expression. Ура!
[01:17:34.000 --> 01:17:36.000]  Ну, значит, все знают.
[01:17:36.000 --> 01:17:38.000]  Ладно, что такое expression?
[01:17:38.000 --> 01:17:40.000]  Часть AST дерева?
[01:17:40.000 --> 01:17:42.000]  Да, это часть просто кодопрограммы.
[01:17:42.000 --> 01:17:44.000]  Часть AST дерева.
[01:17:44.000 --> 01:17:46.000]  L-value, R-value категоризируют
[01:17:46.000 --> 01:17:48.000]  по сути вершина AST дерева.
[01:17:48.000 --> 01:17:50.000]  Для вас это шок или
[01:17:50.000 --> 01:17:52.000]  примерно понятно?
[01:17:52.000 --> 01:17:54.000]  Хорошо.
[01:17:54.000 --> 01:17:56.000]  Похоже на то, что вы все знаете.
[01:17:56.000 --> 01:17:58.000]  Не будем больше говорить про
[01:17:58.000 --> 01:18:00.000]  семантику.
[01:18:00.000 --> 01:18:02.000]  Будем говорить про неработающий проектор.
[01:18:02.000 --> 01:18:04.000]  Какого черта? Работай.
[01:18:16.000 --> 01:18:18.000]  Теперь надо переключить...
[01:18:24.000 --> 01:18:26.000]  Так.
[01:18:34.000 --> 01:18:36.000]  Что это такое?
[01:18:40.000 --> 01:18:42.000]  Моя беда в том, что этот монитор
[01:18:42.000 --> 01:18:44.000]  вдвое большего разрешения, чем мой.
[01:18:44.000 --> 01:18:46.000]  И когда я переключаюсь в OBS между
[01:18:46.000 --> 01:18:48.000]  записью моего монитора и этого,
[01:18:48.000 --> 01:18:50.000]  у меня разрастается
[01:18:50.000 --> 01:18:52.000]  вот так,
[01:18:52.000 --> 01:18:54.000]  вот за пределы
[01:18:54.000 --> 01:18:56.000]  зоны записи.
[01:18:56.000 --> 01:18:58.000]  Какой-то непродуманчик.
[01:18:58.000 --> 01:19:00.000]  Ну ладно.
[01:19:00.000 --> 01:19:02.000]  Все, пошли дальше.
[01:19:02.000 --> 01:19:04.000]  Надо закончить. Я чувствую,
[01:19:04.000 --> 01:19:06.000]  вы устали.
[01:19:06.000 --> 01:19:08.000]  Закончим мы вот с
[01:19:08.000 --> 01:19:10.000]  тупых вещей.
[01:19:10.000 --> 01:19:12.000]  Обычно с них начинают, а мы ими закончим.
[01:19:12.000 --> 01:19:14.000]  Вот это заголовочек
[01:19:14.000 --> 01:19:16.000]  шаблона.
[01:19:16.000 --> 01:19:18.000]  Можно туда всякие имтики писать,
[01:19:18.000 --> 01:19:20.000]  type-name. А что дальше можно писать?
[01:19:20.000 --> 01:19:22.000]  Еще раз можно писать
[01:19:22.000 --> 01:19:24.000]  template.
[01:19:24.000 --> 01:19:26.000]  Это правильно.
[01:19:26.000 --> 01:19:28.000]  А кто-нибудь
[01:19:28.000 --> 01:19:30.000]  сможет назвать кейс,
[01:19:30.000 --> 01:19:32.000]  в котором нужно после этого еще раз
[01:19:32.000 --> 01:19:34.000]  писать template? Точно такое же.
[01:19:34.000 --> 01:19:36.000]  Да.
[01:19:36.000 --> 01:19:38.000]  Нет,
[01:19:38.000 --> 01:19:40.000]  никогда template-template параметр, когда
[01:19:40.000 --> 01:19:42.000]  класс шаблонный и метод
[01:19:42.000 --> 01:19:44.000]  внутри него шаблонный. Вот тогда два раза
[01:19:44.000 --> 01:19:46.000]  может быть подряд.
[01:19:46.000 --> 01:19:48.000]  Да, и мы все это вне класса определяем.
[01:19:48.000 --> 01:19:50.000]  Ну а более просто.
[01:19:50.000 --> 01:19:52.000]  Какие сущности могут быть шаблонами?
[01:19:52.000 --> 01:19:54.000]  Алиас.
[01:19:54.000 --> 01:19:56.000]  Сигнатура функции.
[01:19:56.000 --> 01:19:58.000]  Класс, функция.
[01:19:58.000 --> 01:20:00.000]  Метод, концепт.
[01:20:00.000 --> 01:20:02.000]  Ну в принципе да.
[01:20:02.000 --> 01:20:04.000]  Я бы сказал, что класс и структура
[01:20:04.000 --> 01:20:06.000]  это все одно и то же.
[01:20:06.000 --> 01:20:08.000]  Сигнатура функции это та же самая
[01:20:08.000 --> 01:20:10.000]  функция, но тут конечно
[01:20:10.000 --> 01:20:12.000]  есть деталь.
[01:20:12.000 --> 01:20:14.000]  Шаблоном может быть как определение,
[01:20:14.000 --> 01:20:16.000]  так и объявление функции.
[01:20:18.000 --> 01:20:20.000]  Ну вот я хотел
[01:20:20.000 --> 01:20:22.000]  это после вот этого отрывка презентации
[01:20:22.000 --> 01:20:24.000]  поговорить насчет этого, но мы не успеем уже.
[01:20:24.000 --> 01:20:26.000]  Поэтому давайте просто презентацию досмотрим
[01:20:26.000 --> 01:20:28.000]  и пойдем по домам спать.
[01:20:28.000 --> 01:20:30.000]  Да,
[01:20:30.000 --> 01:20:32.000]  про шаблоны
[01:20:32.000 --> 01:20:34.000]  переменных. Вас это не шокирует, правда?
[01:20:34.000 --> 01:20:36.000]  Вы видели такие уже?
[01:20:38.000 --> 01:20:40.000]  А вот что будет если без слова
[01:20:40.000 --> 01:20:42.000]  constexpr написать? Что это вообще значит?
[01:20:42.000 --> 01:20:44.000]  Логически?
[01:20:48.000 --> 01:20:50.000]  Получается
[01:20:50.000 --> 01:20:52.000]  biome
[01:20:52.000 --> 01:20:54.000]  и сравнивать
[01:20:54.000 --> 01:20:56.000]  размер кого-то типа
[01:20:56.000 --> 01:20:58.000]  с данным ксом.
[01:20:58.000 --> 01:21:00.000]  Нет, нет, нет. Сейчас.
[01:21:04.000 --> 01:21:06.000]  Во.
[01:21:06.000 --> 01:21:08.000]  Я про это хотел сказать. Вот это закрыть можно.
[01:21:08.000 --> 01:21:10.000]  Вопрос был другой.
[01:21:10.000 --> 01:21:12.000]  Просто что такое шаблонная глобальная
[01:21:12.000 --> 01:21:14.000]  переменная?
[01:21:14.000 --> 01:21:16.000]  Да.
[01:21:16.000 --> 01:21:18.000]  Мы в бинаре будем резервировать место
[01:21:18.000 --> 01:21:20.000]  под каждую инстанциацию. Это такой способ
[01:21:20.000 --> 01:21:22.000]  автоматизировать выделение
[01:21:22.000 --> 01:21:24.000]  памяти в глобальной секции
[01:21:24.000 --> 01:21:26.000]  вашей программы.
[01:21:26.000 --> 01:21:28.000]  Да. В каком-то смысле.
[01:21:28.000 --> 01:21:30.000]  И вы не поверите, это даже
[01:21:30.000 --> 01:21:32.000]  используется на практике. У нас есть
[01:21:32.000 --> 01:21:34.000]  такое. Против крутится.
[01:21:34.000 --> 01:21:36.000]  Я хочу отпилить уже давно, потому что это
[01:21:36.000 --> 01:21:38.000]  жесть. Но есть.
[01:21:38.000 --> 01:21:40.000]  Окей. Все это можно
[01:21:40.000 --> 01:21:42.000]  писать. Ну вот шаблон класса.
[01:21:42.000 --> 01:21:44.000]  Знаете
[01:21:44.000 --> 01:21:46.000]  что? Я встану здесь, пожалуй, потому что мне
[01:21:46.000 --> 01:21:48.000]  нужен презентер вью, чтобы не забыть,
[01:21:48.000 --> 01:21:50.000]  что там дальше идет по плану.
[01:21:52.000 --> 01:21:54.000]  Какой-то он неудобный
[01:21:54.000 --> 01:21:56.000]  здесь. Ну ладно.
[01:21:56.000 --> 01:21:58.000]  Да. Шаблон класса. Внутри него можно
[01:21:58.000 --> 01:22:00.000]  написать метод.
[01:22:02.000 --> 01:22:04.000]  Соответственно, все шаблонные
[01:22:04.000 --> 01:22:06.000]  аргументы можно где угодно использовать в
[01:22:06.000 --> 01:22:08.000]  рамках той сущности, которую вы определили.
[01:22:08.000 --> 01:22:10.000]  Вот вообще где угодно.
[01:22:10.000 --> 01:22:12.000]  Для некоторых это может быть шоком.
[01:22:12.000 --> 01:22:14.000]  Шаблон, я надеюсь, нет. Можно отнаследоваться от С.
[01:22:14.000 --> 01:22:16.000]  Можно завести
[01:22:16.000 --> 01:22:18.000]  поля типа С. Можно
[01:22:18.000 --> 01:22:20.000]  аргументы типа С в функции принимать.
[01:22:20.000 --> 01:22:22.000]  Можно возвращать типа С.
[01:22:22.000 --> 01:22:24.000]  Можно создавать объекты типа С. Что угодно.
[01:22:24.000 --> 01:22:26.000]  Просто в рамках этого
[01:22:26.000 --> 01:22:28.000]  тела у вас как будто бы есть
[01:22:28.000 --> 01:22:30.000]  вот такой тип.
[01:22:32.000 --> 01:22:34.000]  Чтобы использовать
[01:22:34.000 --> 01:22:36.000]  такой тип, у нас есть такой синтаксис.
[01:22:36.000 --> 01:22:38.000]  Окей?
[01:22:38.000 --> 01:22:40.000]  Окей. Ничего нового.
[01:22:40.000 --> 01:22:42.000]  Да, и вот накину
[01:22:42.000 --> 01:22:44.000]  еще раз терминологию.
[01:22:44.000 --> 01:22:46.000]  Давайте так с вами будем говорить в рамках этого курса,
[01:22:46.000 --> 01:22:48.000]  что мол, сущность
[01:22:48.000 --> 01:22:50.000]  это одно из всего, что мы перечислили,
[01:22:50.000 --> 01:22:52.000]  и у нас есть
[01:22:52.000 --> 01:22:54.000]  шаблоны сущностей.
[01:22:54.000 --> 01:22:56.000]  Вот
[01:22:56.000 --> 01:22:58.000]  то, что после темплейта идет.
[01:22:58.000 --> 01:23:00.000]  Темплейт это как бы заголовок шаблона,
[01:23:00.000 --> 01:23:02.000]  а дальше идет шаблон сущности.
[01:23:02.000 --> 01:23:04.000]  И нет шаблонных функций,
[01:23:04.000 --> 01:23:06.000]  есть шаблоны функций.
[01:23:06.000 --> 01:23:08.000]  Про это я уже понудил.
[01:23:08.000 --> 01:23:10.000]  Инстанциация и специализация,
[01:23:10.000 --> 01:23:12.000]  пожалуйста, не говорите
[01:23:12.000 --> 01:23:14.000]  посмотри на эту инстанциацию.
[01:23:14.000 --> 01:23:16.000]  Потому что инстанциация это процесс,
[01:23:16.000 --> 01:23:18.000]  а результат это специализация.
[01:23:18.000 --> 01:23:20.000]  Ну, почему
[01:23:20.000 --> 01:23:22.000]  акцентирую внимание, потому что
[01:23:22.000 --> 01:23:24.000]  в некоторых вопросах нашего курса
[01:23:24.000 --> 01:23:26.000]  придется залазить в стандарт.
[01:23:26.000 --> 01:23:28.000]  Там это строго соблюдается терминология,
[01:23:28.000 --> 01:23:30.000]  и чтобы не запутаться, пожалуйста, тоже
[01:23:30.000 --> 01:23:32.000]  вот соблюдайте.
[01:23:32.000 --> 01:23:34.000]  Окей.
[01:23:34.000 --> 01:23:36.000]  Вопрос к вам.
[01:23:36.000 --> 01:23:38.000]  Ну, если до этого было скучно
[01:23:38.000 --> 01:23:40.000]  и все старое, то возможно сейчас будет
[01:23:40.000 --> 01:23:42.000]  что-то новое. Возможно, вы не
[01:23:42.000 --> 01:23:44.000]  задумывались об этом.
[01:23:44.000 --> 01:23:46.000]  Ну, зависит от типа цена.
[01:23:46.000 --> 01:23:48.000]  Если нет, то есть, то... Нет, а я просто вот такой код
[01:23:48.000 --> 01:23:50.000]  написал в Main.cpp и все.
[01:23:50.000 --> 01:23:52.000]  Это скомпилист.
[01:23:52.000 --> 01:23:54.000]  Скомпилист, да.
[01:23:54.000 --> 01:23:56.000]  Ну да, это правильно.
[01:23:56.000 --> 01:23:58.000]  Ну код на самом деле нет.
[01:23:58.000 --> 01:24:00.000]  Ну да, это все скомпилируется,
[01:24:00.000 --> 01:24:02.000]  потому что у нас по шаблону...
[01:24:02.000 --> 01:24:04.000]  Ну как бы...
[01:24:04.000 --> 01:24:06.000]  То есть, иногда
[01:24:06.000 --> 01:24:08.000]  он требуется по линии типов, например,
[01:24:08.000 --> 01:24:15.800]  при
[01:24:15.800 --> 01:24:17.800]  Я не очень понял, что ты хочешь сказать.
[01:24:17.800 --> 01:24:19.800]  Скорее всего, то же самое, что я сейчас на следующих
[01:24:19.800 --> 01:24:21.800]  слайдах скажу, только другими словами.
[01:24:21.800 --> 01:24:23.800]  Здесь мы не знаем, какой
[01:24:23.800 --> 01:24:25.800]  C.
[01:24:25.800 --> 01:24:27.800]  Мы не знаем, есть ли у C member,
[01:24:27.800 --> 01:24:29.800]  или нету.
[01:24:29.800 --> 01:24:31.800]  Ну и поэтому такой
[01:24:31.800 --> 01:24:33.800]  код чисто сам по себе скомпилируется.
[01:24:33.800 --> 01:24:35.800]  Почему?
[01:24:35.800 --> 01:24:37.800]  Потому что, когда подставим конкретно
[01:24:37.800 --> 01:24:39.800]  C, вот тогда уже можно понять,
[01:24:39.800 --> 01:24:41.800]  есть ли member, нет ли, ошибка, или все нормально.
[01:24:41.800 --> 01:24:43.800]  А просто сам шаблон
[01:24:43.800 --> 01:24:45.800]  с ним все ок. Че?
[01:24:45.800 --> 01:24:47.800]  Тоже верно, да.
[01:24:47.800 --> 01:24:49.800]  А вот так.
[01:24:49.800 --> 01:24:51.800]  А вот так.
[01:24:59.800 --> 01:25:01.800]  Он записывается.
[01:25:07.800 --> 01:25:09.800]  Так. Куда я ушел?
[01:25:09.800 --> 01:25:11.800]  Сюда я ушел.
[01:25:11.800 --> 01:25:13.800]  Дальше.
[01:25:13.800 --> 01:25:15.800]  Вот так.
[01:25:17.800 --> 01:25:19.800]  Скомпилируется.
[01:25:25.800 --> 01:25:27.800]  Почему да, почему нет?
[01:25:27.800 --> 01:25:29.800]  Давайте, кто говорил.
[01:25:29.800 --> 01:25:31.800]  Потому что он уже
[01:25:31.800 --> 01:25:33.800]  доисканственно может проявить, что такой member нет.
[01:25:33.800 --> 01:25:35.800]  Ну так в предыдущем тоже самое
[01:25:35.800 --> 01:25:37.800]  было. Почему там что-то?
[01:25:37.800 --> 01:25:39.800]  Нет, в предыдущем он
[01:25:39.800 --> 01:25:41.800]  не знал C, если
[01:25:41.800 --> 01:25:43.800]  он не инстанцировали.
[01:25:43.800 --> 01:25:45.800]  Я думаю, он проявить может, но не будет,
[01:25:45.800 --> 01:25:47.800]  потому что мы этот сам кучу нигде не используем.
[01:25:47.800 --> 01:25:49.800]  Ну, короче, это все абсолютно
[01:25:49.800 --> 01:25:51.800]  верно. Потому что уже вот этот
[01:25:51.800 --> 01:25:53.800]  код, только объявление шаблона,
[01:25:53.800 --> 01:25:55.800]  она уже не скомпилируется.
[01:25:55.800 --> 01:25:57.800]  Потому что мы знаем, что у нас
[01:25:57.800 --> 01:25:59.800]  завалью, знаем, что у него
[01:25:59.800 --> 01:26:01.800]  тип B, знаем, что вот он B,
[01:26:01.800 --> 01:26:03.800]  и вот у него нет никакого member.
[01:26:03.800 --> 01:26:05.800]  И мы заранее выдадим ошибку,
[01:26:05.800 --> 01:26:07.800]  еще до того, как вы инстанцировали шаблон.
[01:26:07.800 --> 01:26:09.800]  Вы почувствовали разницу?
[01:26:09.800 --> 01:26:11.800]  Если вот сюда
[01:26:11.800 --> 01:26:13.800]  то самое B подставить в качестве шаблона,
[01:26:13.800 --> 01:26:15.800]  то ошибку нам дадут уже
[01:26:15.800 --> 01:26:17.800]  после инстанциации,
[01:26:17.800 --> 01:26:19.800]  а вот здесь ошибку нам дают
[01:26:19.800 --> 01:26:21.800]  до инстанциации,
[01:26:21.800 --> 01:26:23.800]  в момент парсинга самого шаблона.
[01:26:23.800 --> 01:26:25.800]  Вот мы просто
[01:26:25.800 --> 01:26:27.800]  вершины AST
[01:26:27.800 --> 01:26:29.800]  для этого шаблона составляем,
[01:26:29.800 --> 01:26:31.800]  и уже в этот момент выдаем ошибку.
[01:26:31.800 --> 01:26:33.800]  Вот эта вся технология
[01:26:33.800 --> 01:26:35.800]  называется двухфазный lookup имен.
[01:26:35.800 --> 01:26:37.800]  Вот это первая фаза.
[01:26:37.800 --> 01:26:39.800]  В момент парсинга шаблона
[01:26:39.800 --> 01:26:41.800]  мы пытаемся
[01:26:41.800 --> 01:26:43.800]  найти все имена, про которые
[01:26:43.800 --> 01:26:45.800]  все понятно.
[01:26:45.800 --> 01:26:47.800]  Вот про value все понятно,
[01:26:47.800 --> 01:26:49.800]  про member все понятно,
[01:26:49.800 --> 01:26:51.800]  все нашли, вот он B.
[01:26:51.800 --> 01:26:53.800]  Сейчас чуть подробнее будет.
[01:26:53.800 --> 01:26:55.800]  А вот здесь ничего не понятно
[01:26:55.800 --> 01:26:57.800]  про C. C может быть любой,
[01:26:57.800 --> 01:26:59.800]  поэтому на момент парсинга шаблона
[01:26:59.800 --> 01:27:01.800]  мы не можем ничего понять
[01:27:01.800 --> 01:27:03.800]  и откладываем до момента инстанциации.
[01:27:03.800 --> 01:27:05.800]  А почему?
[01:27:05.800 --> 01:27:07.800]  Я уже ответил.
[01:27:07.800 --> 01:27:09.800]  Если чуть более точнее
[01:27:09.800 --> 01:27:11.800]  сказать,
[01:27:11.800 --> 01:27:13.800]  в какие моменты
[01:27:13.800 --> 01:27:15.800]  на второй фазе идет
[01:27:15.800 --> 01:27:17.800]  lookup имен,
[01:27:17.800 --> 01:27:19.800]  а в какие фазы...
[01:27:19.800 --> 01:27:21.800]  Я заговариваюсь.
[01:27:21.800 --> 01:27:23.800]  В каких случаях
[01:27:23.800 --> 01:27:25.800]  на первой фазе идет lookup,
[01:27:25.800 --> 01:27:27.800]  а в каких случаях
[01:27:27.800 --> 01:27:29.800]  на второй фазе идет lookup.
[01:27:29.800 --> 01:27:31.800]  Зависит это от того,
[01:27:31.800 --> 01:27:33.800]  что имя.
[01:27:33.800 --> 01:27:35.800]  Термин имя пока может быть не очень понятен.
[01:27:35.800 --> 01:27:37.800]  Это строгий термин, в стандарте определенный.
[01:27:37.800 --> 01:27:39.800]  Идейно, member – это имя,
[01:27:39.800 --> 01:27:41.800]  value – это имя,
[01:27:41.800 --> 01:27:43.800]  value.member – все вместе имя.
[01:27:43.800 --> 01:27:45.800]  Причем именно вот этот
[01:27:45.800 --> 01:27:47.800]  expression, написанный вот здесь,
[01:27:47.800 --> 01:27:49.800]  как SLVALUE, RVALUE.
[01:27:49.800 --> 01:27:51.800]  Мы не говорим про вот это
[01:27:51.800 --> 01:27:53.800]  конкретное поле у какой-то структуры B.
[01:27:53.800 --> 01:27:55.800]  У нее даже нет такого поля.
[01:27:55.800 --> 01:27:57.800]  Мы говорим именно
[01:27:57.800 --> 01:27:59.800]  об expression, написанном здесь.
[01:27:59.800 --> 01:28:01.800]  Это имя является именем.
[01:28:01.800 --> 01:28:03.800]  И это имя может быть двух видов
[01:28:03.800 --> 01:28:05.800]  в рамках объявления шаблона.
[01:28:05.800 --> 01:28:07.800]  Зависимое и независимое.
[01:28:07.800 --> 01:28:09.800]  Понятно, от чего зависимое.
[01:28:09.800 --> 01:28:13.800]  От шаблонных аргументов.
[01:28:13.800 --> 01:28:15.800]  Если у нас имя зависит
[01:28:15.800 --> 01:28:17.800]  от шаблонных аргументов,
[01:28:17.800 --> 01:28:19.800]  то в момент парсинга шаблона ничего не понятно.
[01:28:19.800 --> 01:28:21.800]  Мы откладываем
[01:28:21.800 --> 01:28:23.800]  resolving имен до инстанциации.
[01:28:23.800 --> 01:28:25.800]  Иначе сразу.
[01:28:25.800 --> 01:28:27.800]  Просто.
[01:28:27.800 --> 01:28:29.800]  Давайте пример рассмотреть.
[01:28:29.800 --> 01:28:31.800]  Где здесь зависимые имена?
[01:28:33.800 --> 01:28:35.800]  T маленькая.
[01:28:35.800 --> 01:28:37.800]  Почему T маленькая зависимая?
[01:28:37.800 --> 01:28:39.800]  У нас есть
[01:28:39.800 --> 01:28:41.800]  шаблонный параметр T большое.
[01:28:41.800 --> 01:28:43.800]  Ну да, потому что тип
[01:28:43.800 --> 01:28:45.800]  у T маленького
[01:28:45.800 --> 01:28:47.800]  T большое.
[01:28:47.800 --> 01:28:49.800]  А T большое это шаблонный параметр.
[01:28:49.800 --> 01:28:51.800]  Поэтому T маленькое зависимое имя.
[01:28:51.800 --> 01:28:53.800]  Так, еще.
[01:28:53.800 --> 01:28:55.800]  Что?
[01:28:55.800 --> 01:28:57.800]  C.
[01:28:57.800 --> 01:28:59.800]  C большое.
[01:28:59.800 --> 01:29:01.800]  Ну и C маленькое тоже зависимое.
[01:29:01.800 --> 01:29:03.800]  Ну тут надо
[01:29:03.800 --> 01:29:05.800]  чуть аккуратнее быть.
[01:29:05.800 --> 01:29:07.800]  Да, C маленькое зависимое,
[01:29:07.800 --> 01:29:09.800]  потому что T2,2.C.
[01:29:09.800 --> 01:29:11.800]  Вот это все вместе зависимое имя.
[01:29:11.800 --> 01:29:13.800]  То есть само C по отдельности
[01:29:13.800 --> 01:29:15.800]  не рассматривается, грубо говоря.
[01:29:15.800 --> 01:29:17.800]  Все вместе зависимое имя.
[01:29:17.800 --> 01:29:19.800]  Вот про FU там что-то сказали.
[01:29:19.800 --> 01:29:21.800]  T.FU или зависимое?
[01:29:21.800 --> 01:29:23.800]  T.FU, вот да.
[01:29:23.800 --> 01:29:25.800]  T.FU зависимое, потому что T зависимое,
[01:29:25.800 --> 01:29:27.800]  соответственно вызов функции на
[01:29:27.800 --> 01:29:29.800]  зависимом объекте
[01:29:29.800 --> 01:29:31.800]  тоже зависимое имя.
[01:29:31.800 --> 01:29:33.800]  А вот это FU.
[01:29:35.800 --> 01:29:37.800]  Вот это независимое.
[01:29:39.800 --> 01:29:41.800]  По-моему,
[01:29:41.800 --> 01:29:43.800]  вы не правы.
[01:29:45.800 --> 01:29:47.800]  Да, может быть перегрузка.
[01:29:47.800 --> 01:29:49.800]  Более того.
[01:29:51.800 --> 01:29:53.800]  FU может быть много разных.
[01:29:55.800 --> 01:29:57.800]  Как у нас в языке C++,
[01:29:57.800 --> 01:29:59.800]  что у нас
[01:29:59.800 --> 01:30:01.800]  такой вызов вызывает в языке C++?
[01:30:03.800 --> 01:30:05.800]  Да, там куча всего может быть вызвана.
[01:30:05.800 --> 01:30:07.800]  Про DL вы что-нибудь
[01:30:07.800 --> 01:30:09.800]  слышали?
[01:30:09.800 --> 01:30:11.800]  А DL потом поговорим.
[01:30:11.800 --> 01:30:13.800]  Короче, правило,
[01:30:13.800 --> 01:30:15.800]  как понять в C++ по
[01:30:15.800 --> 01:30:17.800]  вот такой строке
[01:30:17.800 --> 01:30:19.800]  и по вот такому имени.
[01:30:19.800 --> 01:30:21.800]  Какую функцию конкретно вызывать
[01:30:21.800 --> 01:30:23.800]  на самом деле?
[01:30:23.800 --> 01:30:25.800]  Они просто сногсшибательные, эти правила.
[01:30:25.800 --> 01:30:27.800]  Там просто с ума сойти можно,
[01:30:27.800 --> 01:30:29.800]  и мы о них обязательно поговорим.
[01:30:29.800 --> 01:30:31.800]  И вот ровно потому, что они очень сложные,
[01:30:31.800 --> 01:30:33.800]  все это зависимое имя тоже.
[01:30:35.800 --> 01:30:37.800]  То есть FU не будем выбирать,
[01:30:37.800 --> 01:30:39.800]  пока не инстанцируем с конкретным T
[01:30:39.800 --> 01:30:41.800]  этот шаблон.
[01:30:41.800 --> 01:30:43.800]  Это, думаю, вообще очевидно,
[01:30:43.800 --> 01:30:45.800]  что вот это FU тоже зависимое,
[01:30:45.800 --> 01:30:47.800]  потому что тут явно T указан,
[01:30:47.800 --> 01:30:49.800]  почему вот FU,
[01:30:49.800 --> 01:30:51.800]  который там вызов FU отстояет
[01:30:51.800 --> 01:30:53.800]  в виде, но это же не имя,
[01:30:53.800 --> 01:30:55.800]  вызов FU.
[01:30:55.800 --> 01:30:57.800]  В функциях
[01:30:57.800 --> 01:30:59.800]  работает как-то смешно.
[01:30:59.800 --> 01:31:01.800]  То ли говорят,
[01:31:01.800 --> 01:31:03.800]  что весь вызов функции — это одно большое
[01:31:03.800 --> 01:31:05.800]  имя,
[01:31:05.800 --> 01:31:07.800]  то ли сказано, что
[01:31:07.800 --> 01:31:09.800]  имя функции
[01:31:09.800 --> 01:31:11.800]  оно не может быть просто так нигде употреблено,
[01:31:11.800 --> 01:31:13.800]  после него обязательно есть
[01:31:13.800 --> 01:31:15.800]  какой-то контекст, и вот если в этом контексте
[01:31:15.800 --> 01:31:17.800]  есть зависимые аргументы,
[01:31:17.800 --> 01:31:19.800]  то вот это имя тоже само становится зависимым.
[01:31:19.800 --> 01:31:21.800]  Ну, в этом стандарте
[01:31:21.800 --> 01:31:23.800]  нужно вычислить, если ты хочешь совершенно точно
[01:31:23.800 --> 01:31:25.800]  понять, что там.
[01:31:25.800 --> 01:31:27.800]  Но как
[01:31:29.800 --> 01:31:31.800]  point, который нужно понять,
[01:31:31.800 --> 01:31:33.800]  это то, что когда вы такую FU
[01:31:33.800 --> 01:31:35.800]  от T вызываете, где T — зависимый аргумент,
[01:31:35.800 --> 01:31:37.800]  лукап имени FU
[01:31:37.800 --> 01:31:39.800]  он будет происходить потом.
[01:31:39.800 --> 01:31:41.800]  То есть мы будем искать функцию,
[01:31:41.800 --> 01:31:43.800]  которая это имя называет,
[01:31:43.800 --> 01:31:45.800]  после того, как инстанцируем шаблон.
[01:31:47.800 --> 01:31:49.800]  Ну, то есть, да, правильный ответ,
[01:31:49.800 --> 01:31:51.800]  где здесь зависимые имена — везде.
[01:31:51.800 --> 01:31:53.800]  Вот они все зависимые.
[01:31:55.800 --> 01:31:57.800]  Едем дальше.
[01:31:57.800 --> 01:31:59.800]  Вот это скомпилируется.
[01:32:03.800 --> 01:32:05.800]  Ребусы, да, тут
[01:32:05.800 --> 01:32:07.800]  у нас весь курс из ребусов состоит.
[01:32:07.800 --> 01:32:09.800]  Выскажите мнение.
[01:32:13.800 --> 01:32:15.800]  Почему скомпилируется?
[01:32:19.800 --> 01:32:21.800]  Где?
[01:32:27.800 --> 01:32:29.800]  Что, нет, подождите.
[01:32:29.800 --> 01:32:31.800]  Имена — это когда вы называете
[01:32:31.800 --> 01:32:33.800]  какую-то переменную функцию или другой класс.
[01:32:35.800 --> 01:32:37.800]  Ну, наследование есть.
[01:32:39.800 --> 01:32:41.800]  Вот это
[01:32:41.800 --> 01:32:43.800]  вот это имя
[01:32:43.800 --> 01:32:45.800]  G круглые скобочки.
[01:32:45.800 --> 01:32:47.800]  Вы видите где-то вот
[01:32:47.800 --> 01:32:49.800]  в этом выражении упоминание
[01:32:49.800 --> 01:32:51.800]  чего-то, зависящего от шаблонных аргументов?
[01:32:51.800 --> 01:32:53.800]  Нет, и я не вижу.
[01:32:53.800 --> 01:32:55.800]  Значит, это имя независимое,
[01:32:55.800 --> 01:32:57.800]  оно на первой фазе будет лукапиться.
[01:33:01.800 --> 01:33:03.800]  Ну, да, да, могут.
[01:33:05.800 --> 01:33:07.800]  Да, оно не скомпилируется.
[01:33:07.800 --> 01:33:09.800]  Нет, еще раз,
[01:33:09.800 --> 01:33:11.800]  не скомпилируется этот код.
[01:33:11.800 --> 01:33:13.800]  Почему?
[01:33:13.800 --> 01:33:15.800]  Вот здесь все имена были зависимыми
[01:33:15.800 --> 01:33:17.800]  от чего?
[01:33:17.800 --> 01:33:19.800]  И почему они на вторую фазу попадали?
[01:33:19.800 --> 01:33:21.800]  Почему они стали
[01:33:21.800 --> 01:33:23.800]  зависимыми? Потому что везде
[01:33:23.800 --> 01:33:25.800]  как-то упоминалось T.
[01:33:25.800 --> 01:33:27.800]  Тут T упомянулось, тут T упомянулось,
[01:33:27.800 --> 01:33:29.800]  тут T маленькая,
[01:33:29.800 --> 01:33:31.800]  но T большую тоже зависит.
[01:33:31.800 --> 01:33:33.800]  Да, везде где-то именно
[01:33:33.800 --> 01:33:35.800]  в выражении вызова функции
[01:33:35.800 --> 01:33:37.800]  написано что-то, относящееся к T.
[01:33:37.800 --> 01:33:39.800]  Увидели? Прямо на уровне
[01:33:39.800 --> 01:33:41.800]  буквок.
[01:33:41.800 --> 01:33:43.800]  А вот...
[01:33:43.800 --> 01:33:45.800]  Чего?
[01:33:55.800 --> 01:33:57.800]  Вот здесь написать?
[01:33:57.800 --> 01:33:59.800]  Нет, вот здесь
[01:33:59.800 --> 01:34:01.800]  как метод G отдельно
[01:34:01.800 --> 01:34:03.800]  voidG.
[01:34:03.800 --> 01:34:05.800]  То у вас вызовется этот voidG.
[01:34:05.800 --> 01:34:07.800]  И тогда оно скомпилируется.
[01:34:07.800 --> 01:34:09.800]  Да, но вы же хотели это уже вызвать.
[01:34:09.800 --> 01:34:11.800]  То есть оно сейчас будет искать
[01:34:11.800 --> 01:34:13.800]  какой-то глобальный уже?
[01:34:13.800 --> 01:34:15.800]  Оно будет на первой фазе пытаться найти
[01:34:15.800 --> 01:34:17.800]  функцию, соответствующую этому
[01:34:17.800 --> 01:34:19.800]  выражению, этому имени.
[01:34:19.800 --> 01:34:21.800]  На первой фазе вы не знаете, какой у вас
[01:34:21.800 --> 01:34:23.800]  T. Соответственно, вы не знаете
[01:34:23.800 --> 01:34:25.800]  на самом деле,
[01:34:25.800 --> 01:34:27.800]  что вот это за класс.
[01:34:27.800 --> 01:34:29.800]  А, T.
[01:34:29.800 --> 01:34:31.800]  Почему вы не знаете, что это за класс?
[01:34:37.800 --> 01:34:39.800]  Да, абсолютно верно.
[01:34:39.800 --> 01:34:41.800]  Да, этот класс действительно
[01:34:41.800 --> 01:34:43.800]  лукапится на второй фазе. Почему?
[01:34:43.800 --> 01:34:45.800]  Почему мы не можем на первой фазе,
[01:34:45.800 --> 01:34:47.800]  увидев шаблон A, пойти найти
[01:34:47.800 --> 01:34:49.800]  какой-то шаблон A
[01:34:49.800 --> 01:34:51.800]  и использовать его?
[01:34:51.800 --> 01:34:53.800]  Ну мы же вот видим, вот у нас шаблон A.
[01:34:53.800 --> 01:34:55.800]  Ну какая разница?
[01:34:55.800 --> 01:34:57.800]  Специализация.
[01:34:57.800 --> 01:34:59.800]  Именно в этом point.
[01:34:59.800 --> 01:35:01.800]  Выбор,
[01:35:01.800 --> 01:35:03.800]  какую A от T использовать здесь
[01:35:03.800 --> 01:35:05.800]  в качестве наследника, откладывается
[01:35:05.800 --> 01:35:07.800]  на вторую фазу. Потому что бывают
[01:35:07.800 --> 01:35:09.800]  специализации в зависимости от T
[01:35:09.800 --> 01:35:11.800]  у A. Вы можете специализировать
[01:35:11.800 --> 01:35:13.800]  A от Nта и сделать его другим.
[01:35:13.800 --> 01:35:15.800]  И у него уже же не будет.
[01:35:15.800 --> 01:35:17.800]  Да?
[01:35:17.800 --> 01:35:19.800]  Так что да.
[01:35:19.800 --> 01:35:21.800]  Мы не знаем, какой у нас родитель.
[01:35:21.800 --> 01:35:23.800]  Поэтому на первой фазе
[01:35:23.800 --> 01:35:25.800]  G мы не найдем.
[01:35:27.800 --> 01:35:29.800]  Либо так, либо сяк.
[01:35:29.800 --> 01:35:31.800]  Любым образом вам нужно
[01:35:31.800 --> 01:35:33.800]  в это имя добавить зависимость
[01:35:33.800 --> 01:35:35.800]  от шаблонного аргумента. Почему
[01:35:35.800 --> 01:35:37.800]  зависимость зависимая здесь?
[01:35:37.800 --> 01:35:39.800]  Потому что это указательный объект шаблонный.
[01:35:39.800 --> 01:35:41.800]  Да, это объект типа
[01:35:41.800 --> 01:35:43.800]  порожденного из шаблона C
[01:35:43.800 --> 01:35:45.800]  подставлением T, ну короче
[01:35:45.800 --> 01:35:47.800]  C от T у него тип.
[01:35:47.800 --> 01:35:49.800]  Мы как бы путем того, что G дело зависимое,
[01:35:49.800 --> 01:35:51.800]  мы покидываем его на вторую фазу.
[01:35:51.800 --> 01:35:53.800]  Да, мы его откладываем на вторую фазу.
[01:35:53.800 --> 01:35:55.800]  И на второй фазе, если нам повезет
[01:35:55.800 --> 01:35:57.800]  и нет специализации у A,
[01:35:57.800 --> 01:35:59.800]  мы уже найдем вот эту конкретную G
[01:35:59.800 --> 01:36:01.800]  и все будут довольны.
[01:36:01.800 --> 01:36:03.800]  Сложно, правда?
[01:36:03.800 --> 01:36:05.800]  Ну вот, шаблонный кажется
[01:36:05.800 --> 01:36:07.800]  это просто, а когда начинаешь вот такие вещи
[01:36:07.800 --> 01:36:09.800]  влезать,
[01:36:09.800 --> 01:36:11.800]  начинается жесть. Но гораздо
[01:36:11.800 --> 01:36:13.800]  неприятнее, когда вы на них натыкаетесь
[01:36:13.800 --> 01:36:15.800]  на практике, не зная их существования,
[01:36:15.800 --> 01:36:17.800]  чем когда заранее кто-то предупредил,
[01:36:17.800 --> 01:36:19.800]  что такое будет,
[01:36:19.800 --> 01:36:21.800]  домашко будет, вероятно.
[01:36:21.800 --> 01:36:23.800]  Будьте готовы вписать this куда надо.
[01:36:23.800 --> 01:36:25.800]  Но помимо this можно еще вписать
[01:36:25.800 --> 01:36:27.800]  что-нибудь другое, а A, T тоже
[01:36:27.800 --> 01:36:29.800]  вполне.
[01:36:29.800 --> 01:36:31.800]  Дальше.
[01:36:31.800 --> 01:36:33.800]  По-моему
[01:36:33.800 --> 01:36:35.800]  нет.
[01:36:35.800 --> 01:36:37.800]  По-моему никакой разницы нет.
[01:36:39.800 --> 01:36:41.800]  This, он все равно не явно дописывается,
[01:36:41.800 --> 01:36:43.800]  когда вы делаете вот этот this.
[01:36:43.800 --> 01:36:45.800]  Ну короче, разницы нет,
[01:36:45.800 --> 01:36:47.800]  ни в чем нет разницы.
[01:36:47.800 --> 01:36:49.800]  Есть только,
[01:36:49.800 --> 01:36:51.800]  скорее всего есть эзотерические какие-то
[01:36:51.800 --> 01:36:53.800]  места, где оно по-разному чуть-чуть работает
[01:36:53.800 --> 01:36:55.800]  и что-то никак не сломается. Ну это C++, тут
[01:36:55.800 --> 01:36:57.800]  всегда так.
[01:36:57.800 --> 01:36:59.800]  Подробнее вот здесь
[01:36:59.800 --> 01:37:01.800]  надо читать, потому что я вам
[01:37:01.800 --> 01:37:03.800]  набросал общими мозгами, если у вас
[01:37:03.800 --> 01:37:05.800]  что-то не работает
[01:37:05.800 --> 01:37:07.800]  к этому имеющее отношение,
[01:37:07.800 --> 01:37:09.800]  то есть где-то глубоко в шаблонах,
[01:37:09.800 --> 01:37:11.800]  вам говорят, ой, я не знаю, что это такое.
[01:37:11.800 --> 01:37:13.800]  Возможно вам нужно вот эту статью
[01:37:13.800 --> 01:37:15.800]  перечитать, но уже когда вы будете
[01:37:15.800 --> 01:37:17.800]  на практике сидеть и писать код,
[01:37:17.800 --> 01:37:19.800]  а не вот просто по приколу.
[01:37:19.800 --> 01:37:21.800]  Так что да.
[01:37:21.800 --> 01:37:23.800]  Дальше идем.
[01:37:23.800 --> 01:37:25.800]  Еще один ребус.
[01:37:27.800 --> 01:37:29.800]  Нет.
[01:37:29.800 --> 01:37:31.800]  Не скомпилиться.
[01:37:31.800 --> 01:37:33.800]  Потому что у нас
[01:37:33.800 --> 01:37:35.800]  произойдет лукап, мы посмотрим, что у интернет
[01:37:35.800 --> 01:37:37.800]  мембера.
[01:37:37.800 --> 01:37:39.800]  Вот и все.
[01:37:39.800 --> 01:37:41.800]  Мы же не узнаем,
[01:37:41.800 --> 01:37:43.800]  что тут
[01:37:43.800 --> 01:37:45.800]  кто-то неуверенно сказал
[01:37:45.800 --> 01:37:47.800]  правильный ответ.
[01:37:47.800 --> 01:37:49.800]  Get some member
[01:37:49.800 --> 01:37:51.800]  Get some member
[01:37:51.800 --> 01:37:53.800]  Get some member
[01:37:53.800 --> 01:37:55.800]  Смотрите, когда мы объявляем какую-то
[01:37:55.800 --> 01:37:57.800]  сущность про зависимость или независимость
[01:37:57.800 --> 01:37:59.800]  этого имени, говорить бессмысленно.
[01:37:59.800 --> 01:38:01.800]  Вот зависимость, независимость имен,
[01:38:01.800 --> 01:38:03.800]  она, когда мы используем
[01:38:03.800 --> 01:38:05.800]  какую-то другую сущность,
[01:38:05.800 --> 01:38:07.800]  и хотим понять, где эта сущность на самом деле лежит.
[01:38:07.800 --> 01:38:09.800]  Get member
[01:38:09.800 --> 01:38:11.800]  Get member
[01:38:15.800 --> 01:38:17.800]  Смотрите, на первой и второй фазе
[01:38:17.800 --> 01:38:19.800]  мы находим какие-то
[01:38:19.800 --> 01:38:21.800]  чужие методы.
[01:38:21.800 --> 01:38:23.800]  Вот вы вызвали функцию,
[01:38:23.800 --> 01:38:25.800]  вызвали метод. Нам нужно понять,
[01:38:25.800 --> 01:38:27.800]  какую конкретно код вызвать.
[01:38:27.800 --> 01:38:29.800]  У вас может быть в программе на C++
[01:38:29.800 --> 01:38:31.800]  10 разных функций G
[01:38:31.800 --> 01:38:33.800]  с разными аргументами, и это все равно корректно.
[01:38:33.800 --> 01:38:35.800]  Поэтому есть вот эта процедура
[01:38:35.800 --> 01:38:37.800]  лукапа имен. Мы пытаемся
[01:38:37.800 --> 01:38:39.800]  понять по имени G
[01:38:39.800 --> 01:38:41.800]  и аргументам, какую из G
[01:38:41.800 --> 01:38:43.800]  надо вызывать.
[01:38:43.800 --> 01:38:45.800]  Вот это лукап имен.
[01:38:45.800 --> 01:38:47.800]  Про Get C member говорить
[01:38:47.800 --> 01:38:49.800]  зависимо-независимо бессмысленно,
[01:38:49.800 --> 01:38:51.800]  потому что в этом месте
[01:38:51.800 --> 01:38:53.800]  мы никакого лукапа не делаем.
[01:38:53.800 --> 01:38:55.800]  Мы не вызываем
[01:38:55.800 --> 01:38:57.800]  функцию, поэтому лукап имен не происходит.
[01:38:59.800 --> 01:39:01.800]  Value member – это доступ
[01:39:01.800 --> 01:39:03.800]  на чтение какого-то там поля.
[01:39:03.800 --> 01:39:05.800]  Нужен лукап имен.
[01:39:05.800 --> 01:39:07.800]  А вот объявление какой-то
[01:39:07.800 --> 01:39:09.800]  переменной – здесь никакой
[01:39:09.800 --> 01:39:11.800]  лукап имен не нужен,
[01:39:11.800 --> 01:39:13.800]  кроме как для C. Value
[01:39:13.800 --> 01:39:15.800]  лукап не делается, потому что это
[01:39:15.800 --> 01:39:17.800]  введение нового имени.
[01:39:17.800 --> 01:39:19.800]  Вот здесь тоже введение нового имени.
[01:39:19.800 --> 01:39:21.800]  А для C да, мы делаем лукап
[01:39:21.800 --> 01:39:23.800]  и видим, что это
[01:39:23.800 --> 01:39:25.800]  вот этот C.
[01:39:25.800 --> 01:39:27.800]  Я надеюсь, я непонимание
[01:39:27.800 --> 01:39:29.800]  чуть-чуть подправил.
[01:39:29.800 --> 01:39:31.800]  За это время вы должны были
[01:39:31.800 --> 01:39:33.800]  правильный ответ сформулировать,
[01:39:33.800 --> 01:39:35.800]  как это компилируется или нет.
[01:39:35.800 --> 01:39:37.800]  Так это компилируется.
[01:39:39.800 --> 01:39:41.800]  Можно еще раз про фазу?
[01:39:41.800 --> 01:39:43.800]  Вот здесь вот.
[01:39:43.800 --> 01:39:45.800]  То есть вот B нам
[01:39:45.800 --> 01:39:47.800]  выявляется зависимо,
[01:39:47.800 --> 01:39:49.800]  C Value тоже зависимо.
[01:39:49.800 --> 01:39:51.800]  Нет, смотри, про вот это
[01:39:51.800 --> 01:39:53.800]  вот выражение Value
[01:39:53.800 --> 01:39:55.800]  говорить зависимо и независимо бессмысленно,
[01:39:55.800 --> 01:39:57.800]  потому что эта строчка вводит новое имя.
[01:39:57.800 --> 01:39:59.800]  А про зависимо и независимо
[01:39:59.800 --> 01:40:01.800]  мы говорим, когда используем какое-то другое имя.
[01:40:01.800 --> 01:40:03.800]  Вот здесь мы получаем доступ
[01:40:03.800 --> 01:40:05.800]  к какому-то полю,
[01:40:05.800 --> 01:40:07.800]  хотим получить доступ к другой сущности.
[01:40:07.800 --> 01:40:09.800]  Здесь вот уже надо понимать
[01:40:09.800 --> 01:40:11.800]  зависимо и независимо.
[01:40:11.800 --> 01:40:13.800]  А это введение нового имени.
[01:40:13.800 --> 01:40:15.800]  Когда мы там рассматривали с тэшками,
[01:40:15.800 --> 01:40:17.800]  у нас было как раз где-то T человеком
[01:40:17.800 --> 01:40:19.800]  еще раньше.
[01:40:19.800 --> 01:40:21.800]  Здесь да,
[01:40:21.800 --> 01:40:23.800]  типа T вводили перемену
[01:40:23.800 --> 01:40:25.800]  маленькую T и мы говорили, что это зависимо.
[01:40:25.800 --> 01:40:27.800]  Она дальше будет в коде зависимая.
[01:40:27.800 --> 01:40:29.800]  Я, наверное, плохо сформулировал.
[01:40:29.800 --> 01:40:31.800]  Я буду снять это выделение.
[01:40:31.800 --> 01:40:33.800]  Да, то есть вот здесь
[01:40:33.800 --> 01:40:35.800]  вот тут
[01:40:35.800 --> 01:40:37.800]  в этой строчке только T большое зависимое.
[01:40:37.800 --> 01:40:39.800]  Про T маленькое бессмысленно
[01:40:39.800 --> 01:40:41.800]  говорить зависимое оно или нет,
[01:40:41.800 --> 01:40:43.800]  потому что оно пока только объявляется.
[01:40:43.800 --> 01:40:45.800]  А вот дальше мы вот здесь его использовали
[01:40:45.800 --> 01:40:47.800]  и вот тут оно становится зависимым.
[01:40:49.800 --> 01:40:51.800]  Поняли логику.
[01:40:51.800 --> 01:40:53.800]  В момент объявления нам неважно.
[01:40:53.800 --> 01:40:55.800]  Мы новое имя вводим. Какая разница?
[01:40:55.800 --> 01:40:57.800]  Какое оно будет?
[01:40:57.800 --> 01:40:59.800]  Вот тут был пример.
[01:40:59.800 --> 01:41:01.800]  Я спрашивал,
[01:41:01.800 --> 01:41:03.800]  скомпилируется оно или нет.
[01:41:03.800 --> 01:41:05.800]  И вы в недоумении,
[01:41:05.800 --> 01:41:07.800]  почему оно скомпилируется?
[01:41:11.800 --> 01:41:13.800]  Да,
[01:41:13.800 --> 01:41:15.800]  тут все хором сейчас, кажется,
[01:41:15.800 --> 01:41:17.800]  одно и то же сказали.
[01:41:17.800 --> 01:41:19.800]  Шаблоны классов
[01:41:19.800 --> 01:41:21.800]  инстанцируются кусками.
[01:41:21.800 --> 01:41:23.800]  Не полностью сразу.
[01:41:23.800 --> 01:41:25.800]  Когда мы вот такой код пишем,
[01:41:25.800 --> 01:41:27.800]  единственное, что у нас инстанцируется,
[01:41:27.800 --> 01:41:29.800]  это поля
[01:41:29.800 --> 01:41:31.800]  и конструктор.
[01:41:31.800 --> 01:41:33.800]  Все.
[01:41:33.800 --> 01:41:35.800]  Все остальные методы, которые вы здесь написали,
[01:41:35.800 --> 01:41:37.800]  вы их не использовали, они инстанцированы не будут.
[01:41:39.800 --> 01:41:41.800]  Да.
[01:41:41.800 --> 01:41:43.800]  Лениво каждый
[01:41:43.800 --> 01:41:45.800]  по отдельности.
[01:41:45.800 --> 01:41:47.800]  Почему?
[01:41:47.800 --> 01:41:49.800]  Давай рассмотрим
[01:41:49.800 --> 01:41:51.800]  вектор. Вектор UniquePTR
[01:41:51.800 --> 01:41:53.800]  и вектор NTOF.
[01:41:53.800 --> 01:41:55.800]  Почему вообще,
[01:41:55.800 --> 01:41:57.800]  если вектор NTOF работает,
[01:41:57.800 --> 01:41:59.800]  почему работает вектор UniquePTR?
[01:42:01.800 --> 01:42:03.800]  Задумайтесь.
[01:42:05.800 --> 01:42:07.800]  Конструктор копирования
[01:42:07.800 --> 01:42:09.800]  лениво инстанцируется,
[01:42:09.800 --> 01:42:11.800]  поэтому в векторе NTOF
[01:42:11.800 --> 01:42:13.800]  он инстанцируется, а в векторе UniquePTR
[01:42:13.800 --> 01:42:15.800]  если вы не попытаетесь
[01:42:15.800 --> 01:42:17.800]  скопировать вектор UniquePTR,
[01:42:17.800 --> 01:42:19.800]  он инстанцируется и не будет.
[01:42:19.800 --> 01:42:21.800]  Да?
[01:42:21.800 --> 01:42:23.800]  Поняли, о чем я.
[01:42:23.800 --> 01:42:25.800]  И то есть получается, если мы здесь
[01:42:25.800 --> 01:42:27.800]  следующей строчкой концепции
[01:42:27.800 --> 01:42:29.800]  самим решим вызвать метод
[01:42:29.800 --> 01:42:31.800]  в метод пяти лет семя,
[01:42:31.800 --> 01:42:33.800]  то тогда у нас уже нет проблем?
[01:42:33.800 --> 01:42:35.800]  Да. Мы уже как раз попытаемся инстанцировать этот метод
[01:42:35.800 --> 01:42:37.800]  и уже получим ошибку.
[01:42:37.800 --> 01:42:39.800]  Вот. То есть, общее правило
[01:42:39.800 --> 01:42:41.800]  А.
[01:42:41.800 --> 01:42:43.800]  Ну, невозможно выучить
[01:42:43.800 --> 01:42:45.800]  свои слайды. Я много лет пытаюсь,
[01:42:45.800 --> 01:42:47.800]  но никогда не получается.
[01:42:47.800 --> 01:42:49.800]  Общее правило такое.
[01:42:49.800 --> 01:42:51.800]  Всегда в специализацию
[01:42:51.800 --> 01:42:53.800]  в результате инстанциации
[01:42:53.800 --> 01:42:55.800]  попадают поля и алиасы.
[01:42:55.800 --> 01:42:57.800]  Это, кстати, важно, что
[01:42:57.800 --> 01:42:59.800]  алиасы всегда попадают
[01:42:59.800 --> 01:43:01.800]  в одно из домашек. Вы будете проклинать
[01:43:01.800 --> 01:43:03.800]  то, что оно так работает,
[01:43:03.800 --> 01:43:05.800]  а может и не будете. Зависит тот.
[01:43:05.800 --> 01:43:07.800]  А методы статической переменной,
[01:43:07.800 --> 01:43:09.800]  внимание, вы помните,
[01:43:09.800 --> 01:43:11.800]  что такое статическая переменная в классе?
[01:43:11.800 --> 01:43:13.800]  Да.
[01:43:13.800 --> 01:43:15.800]  Ну, глобальная, по сути.
[01:43:15.800 --> 01:43:17.800]  Можно напомнить, пожалуйста?
[01:43:17.800 --> 01:43:19.800]  Ну, вот. Все сказали
[01:43:19.800 --> 01:43:21.800]  все правильно.
[01:43:21.800 --> 01:43:23.800]  Что можно среди
[01:43:23.800 --> 01:43:25.800]  рядом с полями типом кассер
[01:43:25.800 --> 01:43:27.800]  написать?
[01:43:27.800 --> 01:43:29.800]  Что?
[01:43:29.800 --> 01:43:31.800]  Статик кассер написать, как в диком поле.
[01:43:31.800 --> 01:43:33.800]  Ну, можно, да.
[01:43:33.800 --> 01:43:35.800]  Статик кассер ты где угодно можно написать.
[01:43:37.800 --> 01:43:39.800]  А. Слушай,
[01:43:39.800 --> 01:43:41.800]  это ты прекрасную общую вещь заметил.
[01:43:41.800 --> 01:43:43.800]  Мне это надо вписать сюда.
[01:43:43.800 --> 01:43:45.800]  Я не могу отредактировать,
[01:43:45.800 --> 01:43:47.800]  да.
[01:43:49.800 --> 01:43:51.800]  Мы под статик переменной имеем
[01:43:51.800 --> 01:43:53.800]  именно статик переменной или
[01:43:53.800 --> 01:43:55.800]  статик поля в классе?
[01:43:55.800 --> 01:43:57.800]  Статик поля в классах.
[01:43:57.800 --> 01:43:59.800]  Да.
[01:44:01.800 --> 01:44:03.800]  А это когда ты в одном классе
[01:44:03.800 --> 01:44:05.800]  делаешь другой класс.
[01:44:05.800 --> 01:44:07.800]  Прямо внутри одного класса объявляешь
[01:44:07.800 --> 01:44:09.800]  другую структурку. Вот это тоже
[01:44:09.800 --> 01:44:11.800]  лениво инстанцируется.
[01:44:11.800 --> 01:44:13.800]  Ну ладно.
[01:44:13.800 --> 01:44:15.800]  Это все-таки хорошее замечание.
[01:44:15.800 --> 01:44:17.800]  Я не помню. По-моему они
[01:44:17.800 --> 01:44:19.800]  как концепты работают.
[01:44:19.800 --> 01:44:21.800]  Они сразу по-моему
[01:44:21.800 --> 01:44:23.800]  вместе с полями.
[01:44:23.800 --> 01:44:25.800]  Ладно.
[01:44:25.800 --> 01:44:27.800]  Давайте ехать дальше.
[01:44:27.800 --> 01:44:29.800]  Осталось чуть-чуть совсем.
[01:44:29.800 --> 01:44:31.800]  Я же не вру, правда?
[01:44:37.800 --> 01:44:39.800]  Да, нам осталось совсем
[01:44:39.800 --> 01:44:41.800]  чуть-чуть.
[01:44:41.800 --> 01:44:43.800]  Ехать, ехать, ехать вперед.
[01:44:43.800 --> 01:44:45.800]  Вывод типов.
[01:44:45.800 --> 01:44:47.800]  Не поехали, да?
[01:45:01.800 --> 01:45:03.800]  Теперь поехали.
[01:45:05.800 --> 01:45:07.800]  Очевидно, так
[01:45:07.800 --> 01:45:09.800]  писать можно. Сделали шаблон,
[01:45:09.800 --> 01:45:11.800]  явно указали ему аргументы.
[01:45:11.800 --> 01:45:13.800]  Все встроено логично, понятно.
[01:45:13.800 --> 01:45:15.800]  Но, оказывается,
[01:45:15.800 --> 01:45:17.800]  можно делать и так. Я надеюсь,
[01:45:17.800 --> 01:45:19.800]  для вас это не новость, потому что, когда вы пишете
[01:45:19.800 --> 01:45:21.800]  std min для минимума
[01:45:21.800 --> 01:45:23.800]  из двух чисел, происходит
[01:45:23.800 --> 01:45:25.800]  ровно это.
[01:45:25.800 --> 01:45:27.800]  Иногда приходится писать типы? Иногда.
[01:45:27.800 --> 01:45:29.800]  Но это удобно,
[01:45:29.800 --> 01:45:31.800]  что оно и выводит. Это прекрасно.
[01:45:31.800 --> 01:45:33.800]  А вот если вы для такой штуки
[01:45:33.800 --> 01:45:35.800]  попытаетесь ничего не написать, то
[01:45:35.800 --> 01:45:37.800]  конечно ошибка будет.
[01:45:37.800 --> 01:45:39.800]  Еще раз про предыдущую?
[01:45:39.800 --> 01:45:41.800]  Просто был метод abs.
[01:45:41.800 --> 01:45:43.800]  У него один шаблонный параметр.
[01:45:43.800 --> 01:45:45.800]  Этот шаблонный параметр он принимает как
[01:45:45.800 --> 01:45:47.800]  аргумент. Что происходит?
[01:45:47.800 --> 01:45:49.800]  Компилятор видит,
[01:45:49.800 --> 01:45:51.800]  у вас единственный аргумент,
[01:45:51.800 --> 01:45:53.800]  типа...
[01:45:53.800 --> 01:45:55.800]  А мы нигде не имплементировали abs.
[01:45:55.800 --> 01:45:57.800]  Что не имплементировали?
[01:45:57.800 --> 01:45:59.800]  Там, где-то есть.
[01:45:59.800 --> 01:46:01.800]  Все нормально.
[01:46:01.800 --> 01:46:03.800]  Компилятор видит тип аргумента,
[01:46:03.800 --> 01:46:05.800]  понимает, что, наверное, ты хотел вызвать abs
[01:46:05.800 --> 01:46:07.800]  с конкретным таким типом,
[01:46:07.800 --> 01:46:09.800]  то есть здесь load, здесь double, здесь unsigned.
[01:46:09.800 --> 01:46:11.800]  И все сам генерирует,
[01:46:11.800 --> 01:46:13.800]  инстанцирует, и все хорошо.
[01:46:15.800 --> 01:46:17.800]  Здесь ошибка.
[01:46:17.800 --> 01:46:19.800]  Я думаю, тоже должно быть абсолютно
[01:46:19.800 --> 01:46:21.800]  понятно интуитивно, почему.
[01:46:21.800 --> 01:46:23.800]  Потому что он не знает,
[01:46:23.800 --> 01:46:25.800]  чем от этого.
[01:46:25.800 --> 01:46:27.800]  Даже если авто поменять,
[01:46:27.800 --> 01:46:29.800]  будет...
[01:46:29.800 --> 01:46:31.800]  Что?
[01:46:31.800 --> 01:46:33.800]  Если авто на конкретный тип...
[01:46:33.800 --> 01:46:35.800]  Тоже будет ошибка, да.
[01:46:35.800 --> 01:46:37.800]  Если вы авто на инт замените,
[01:46:37.800 --> 01:46:39.800]  это никак не поможет вам.
[01:46:39.800 --> 01:46:41.800]  Потому что...
[01:46:41.800 --> 01:46:43.800]  Да, потому что у нас не раст.
[01:46:43.800 --> 01:46:45.800]  В расте, насколько я знаю, оно умеет
[01:46:45.800 --> 01:46:47.800]  понимать, что, ой,
[01:46:47.800 --> 01:46:49.800]  результат присвоили инту, значит, хотели
[01:46:49.800 --> 01:46:51.800]  скастить к инту.
[01:46:51.800 --> 01:46:53.800]  Или там флот.
[01:46:53.800 --> 01:46:55.800]  Присвоили к флоту, значит, хотели изначально флот запустить.
[01:46:57.800 --> 01:46:59.800]  Что?
[01:46:59.800 --> 01:47:01.800]  В расте вообще проблемы с неявными кастами?
[01:47:01.800 --> 01:47:03.800]  Нет, я...
[01:47:03.800 --> 01:47:05.800]  Я про вызовы функций,
[01:47:05.800 --> 01:47:07.800]  а не про касты вообще сейчас.
[01:47:07.800 --> 01:47:09.800]  Когда...
[01:47:09.800 --> 01:47:11.800]  В плюсах нельзя так...
[01:47:11.800 --> 01:47:13.800]  Не всегда так уже делал, потому что, собственно,
[01:47:13.800 --> 01:47:15.800]  есть неявная кастка.
[01:47:15.800 --> 01:47:17.800]  А, ну, да.
[01:47:17.800 --> 01:47:19.800]  Нет, проблем там много.
[01:47:19.800 --> 01:47:21.800]  Они в том числе, они, конечно, нам все
[01:47:21.800 --> 01:47:23.800]  ломают, потому что мало ли мы хотели
[01:47:23.800 --> 01:47:25.800]  вызвать с другим аргументом,
[01:47:25.800 --> 01:47:27.800]  потом скастить неявно к чему-то третьему.
[01:47:27.800 --> 01:47:29.800]  Ну, с булими это особо...
[01:47:29.800 --> 01:47:31.800]  Ну, да.
[01:47:31.800 --> 01:47:33.800]  На днях я рефакторил
[01:47:33.800 --> 01:47:35.800]  функцию, которая применяла
[01:47:35.800 --> 01:47:37.800]  на вход int флаги.
[01:47:37.800 --> 01:47:39.800]  Ну, понятное дело, что подразумевалось
[01:47:39.800 --> 01:47:41.800]  из конкретного enum флаги туда
[01:47:41.800 --> 01:47:43.800]  вписывать, да?
[01:47:43.800 --> 01:47:45.800]  Ну, был на дворе 2005
[01:47:45.800 --> 01:47:47.800]  год, поэтому написали int
[01:47:47.800 --> 01:47:49.800]  flags, enum безымянные сделали,
[01:47:49.800 --> 01:47:51.800]  и флаги прообъявили, ну, просто
[01:47:51.800 --> 01:47:53.800]  с префиксом там, my flags,
[01:47:53.800 --> 01:47:55.800]  что-то там.
[01:47:55.800 --> 01:47:57.800]  Вот рефакторю-рефакторю нахожу одно место.
[01:47:57.800 --> 01:47:59.800]  Там вызов этой функции
[01:47:59.800 --> 01:48:01.800]  с этим аргументом.
[01:48:01.800 --> 01:48:03.800]  Bool. True.
[01:48:03.800 --> 01:48:05.800]  Просто. Вот вписали true.
[01:48:05.800 --> 01:48:07.800]  Ну, я думаю,
[01:48:07.800 --> 01:48:09.800]  можно догадаться, как такое исторически сложилось.
[01:48:09.800 --> 01:48:11.800]  Там были вначале на були, потом
[01:48:11.800 --> 01:48:13.800]  префакторили на enum, но история
[01:48:13.800 --> 01:48:15.800]  поучительная. Не принимайте...
[01:48:15.800 --> 01:48:17.800]  Нет, не так. Не рефакторите були
[01:48:17.800 --> 01:48:19.800]  в int, потому что були обратно
[01:48:19.800 --> 01:48:21.800]  в int кастятся неявно. Это очень плохо.
[01:48:21.800 --> 01:48:23.800]  Давайте дальше ехать.
[01:48:23.800 --> 01:48:29.800]  Где?
[01:48:33.800 --> 01:48:35.800]  Нет, потому что смысл
[01:48:35.800 --> 01:48:37.800]  этой функции
[01:48:37.800 --> 01:48:39.800]  в том, что ты выбираешь, к чему кастовать.
[01:48:39.800 --> 01:48:41.800]  Это функция с какого-то C++ 20,
[01:48:41.800 --> 01:48:43.800]  23, 26, не помню.
[01:48:43.800 --> 01:48:45.800]  Ну, короче, такая функция теперь есть.
[01:48:45.800 --> 01:48:47.800]  Она побитого кастует одни int
[01:48:47.800 --> 01:48:49.800]  к другим. Более явная
[01:48:49.800 --> 01:48:51.800]  такая, типа, чтобы...
[01:48:53.800 --> 01:48:55.800]  Ну да, да.
[01:48:55.800 --> 01:48:57.800]  Но...
[01:48:57.800 --> 01:48:59.800]  Тут смысл в том, что есть имплейнтный аргумент,
[01:48:59.800 --> 01:49:01.800]  про который мы ничего не знаем. То, что он возвращается,
[01:49:01.800 --> 01:49:03.800]  вообще нас не волнует. По выводимому
[01:49:03.800 --> 01:49:05.800]  типу определять не умеем.
[01:49:07.800 --> 01:49:09.800]  Вот. Вывод типов работает
[01:49:09.800 --> 01:49:11.800]  и для классов.
[01:49:11.800 --> 01:49:13.800]  Это, кажется, 17-ые плюсы.
[01:49:13.800 --> 01:49:15.800]  Поправьте меня, если не прав.
[01:49:17.800 --> 01:49:19.800]  А это даже 20-ые, по-моему.
[01:49:19.800 --> 01:49:21.800]  Там было для
[01:49:21.800 --> 01:49:23.800]  классов, а с 20-ых у нас и для структуры
[01:49:23.800 --> 01:49:25.800]  работает. То есть
[01:49:25.800 --> 01:49:27.800]  просто структура с двумя какими-то шнягами,
[01:49:27.800 --> 01:49:29.800]  когда вы ее фигурными скобками
[01:49:29.800 --> 01:49:31.800]  создаете экземпляр ее с этими
[01:49:31.800 --> 01:49:33.800]  шнягами, оно само выведет какое-то
[01:49:33.800 --> 01:49:35.800]  у вас должно быть.
[01:49:35.800 --> 01:49:37.800]  Не надо.
[01:49:37.800 --> 01:49:39.800]  Просто
[01:49:39.800 --> 01:49:41.800]  вот так работает.
[01:49:41.800 --> 01:49:43.800]  Даже
[01:49:43.800 --> 01:49:45.800]  более сложно работает.
[01:49:45.800 --> 01:49:47.800]  Ну, то есть
[01:49:47.800 --> 01:49:49.800]  как на самом деле вывод вот этих вот
[01:49:49.800 --> 01:49:51.800]  стаблонных аргументов класса работает,
[01:49:51.800 --> 01:49:53.800]  мы выводим через конструктор.
[01:49:53.800 --> 01:49:55.800]  Мы видим, что конструктор
[01:49:55.800 --> 01:49:57.800]  вызван от
[01:49:57.800 --> 01:49:59.800]  какого-то вектора int,
[01:49:59.800 --> 01:50:01.800]  а тут вызывают от просто любого вектора.
[01:50:01.800 --> 01:50:03.800]  Ну, сопоставляем их
[01:50:03.800 --> 01:50:05.800]  и видим, что t значит int должен быть равен.
[01:50:05.800 --> 01:50:07.800]  Правда?
[01:50:07.800 --> 01:50:09.800]  И этот int сюда впендюриваем.
[01:50:09.800 --> 01:50:11.800]  И все довольны.
[01:50:11.800 --> 01:50:13.800]  Окей?
[01:50:13.800 --> 01:50:15.800]  Окей. То есть, коль скоро
[01:50:15.800 --> 01:50:17.800]  компилятор может доказать, что
[01:50:17.800 --> 01:50:19.800]  такой вызов конструктора
[01:50:19.800 --> 01:50:21.800]  мог быть только если
[01:50:21.800 --> 01:50:23.800]  такой t был, он
[01:50:23.800 --> 01:50:25.800]  с удовольствием вам выведет
[01:50:25.800 --> 01:50:27.800]  и подставит и все будет хорошо.
[01:50:27.800 --> 01:50:29.800]  Но иногда все не так хорошо.
[01:50:29.800 --> 01:50:31.800]  Здесь, конечно же,
[01:50:31.800 --> 01:50:33.800]  будет ошибка.
[01:50:33.800 --> 01:50:35.800]  Очевидно ли это вам?
[01:50:35.800 --> 01:50:37.800]  Да.
[01:50:37.800 --> 01:50:39.800]  Мы ему
[01:50:39.800 --> 01:50:41.800]  не сказали, как из итератора понять
[01:50:41.800 --> 01:50:43.800]  какой t будет на самом деле
[01:50:43.800 --> 01:50:45.800]  внутри.
[01:50:45.800 --> 01:50:47.800]  Вы-то сами знаете, что по итератору
[01:50:47.800 --> 01:50:49.800]  можно понять t, если его разыменовать.
[01:50:49.800 --> 01:50:51.800]  Или если два двуи точки
[01:50:51.800 --> 01:50:53.800]  в value type сделать.
[01:50:53.800 --> 01:50:55.800]  О том, что из этого более правильное,
[01:50:55.800 --> 01:50:57.800]  вы лучше в домашке подумайте.
[01:50:57.800 --> 01:50:59.800]  Но value type, по-моему,
[01:50:59.800 --> 01:51:01.800]  самое правильное.
[01:51:01.800 --> 01:51:03.800]  Поэтому нам надо подсказать компилятору.
[01:51:03.800 --> 01:51:05.800]  Вот про это уже кто-то
[01:51:05.800 --> 01:51:07.800]  сказал вроде, и, скорее всего, вы знаете
[01:51:07.800 --> 01:51:09.800]  в самом низу штучка.
[01:51:09.800 --> 01:51:11.800]  Непонятно, да, что это такое?
[01:51:15.800 --> 01:51:17.800]  Непонятно, да?
[01:51:17.800 --> 01:51:19.800]  Это называется
[01:51:19.800 --> 01:51:21.800]  deduction guide.
[01:51:21.800 --> 01:51:23.800]  Это правило, на самом деле.
[01:51:23.800 --> 01:51:25.800]  И вот эту стрелочку надо считать
[01:51:25.800 --> 01:51:27.800]  как следствие.
[01:51:27.800 --> 01:51:29.800]  Если
[01:51:29.800 --> 01:51:31.800]  конструктор slice
[01:51:31.800 --> 01:51:33.800]  вызвали от
[01:51:33.800 --> 01:51:35.800]  каких-то непонятных двух
[01:51:35.800 --> 01:51:37.800]  шаблонных аргументов,
[01:51:37.800 --> 01:51:39.800]  ну,
[01:51:39.800 --> 01:51:41.800]  вернее так, вызвали от любых двух
[01:51:41.800 --> 01:51:43.800]  одинаковых типов.
[01:51:43.800 --> 01:51:45.800]  Мы какой-то набор
[01:51:45.800 --> 01:51:47.800]  таких свободных
[01:51:47.800 --> 01:51:49.800]  переменных заводим.
[01:51:49.800 --> 01:51:51.800]  В смысле математической логики.
[01:51:51.800 --> 01:51:53.800]  И вот вообще эта надпись
[01:51:53.800 --> 01:51:55.800]  template класса итера, вот в этом контексте
[01:51:55.800 --> 01:51:57.800]  надо как для любых
[01:51:57.800 --> 01:51:59.800]  читать. То есть для любых
[01:51:59.800 --> 01:52:01.800]  итераторов, любых классов итеров,
[01:52:01.800 --> 01:52:03.800]  если вызвали
[01:52:03.800 --> 01:52:05.800]  конструктор slice от
[01:52:05.800 --> 01:52:07.800]  двух таких типов,
[01:52:07.800 --> 01:52:09.800]  то есть, грубо говоря, если
[01:52:09.800 --> 01:52:11.800]  slice инициализировали от одинаковых
[01:52:11.800 --> 01:52:13.800]  аргументов,
[01:52:13.800 --> 01:52:15.800]  то надо в
[01:52:15.800 --> 01:52:17.800]  шаблоне класса подставить
[01:52:17.800 --> 01:52:19.800]  аргумент either value type.
[01:52:25.800 --> 01:52:27.800]  Тут?
[01:52:27.800 --> 01:52:29.800]  Где?
[01:52:31.800 --> 01:52:33.800]  Если у тебя много deduction
[01:52:33.800 --> 01:52:35.800]  гайдов и где-то из них
[01:52:35.800 --> 01:52:37.800]  свинае, ну, нет. Давай так не будешь делать.
[01:52:37.800 --> 01:52:39.800]  Пиши requires.
[01:52:39.800 --> 01:52:41.800]  Нет, это скорее такое вопрос.
[01:52:41.800 --> 01:52:43.800]  Допустим, у меня
[01:52:43.800 --> 01:52:45.800]  именно сложен.
[01:52:45.800 --> 01:52:47.800]  Ладно, свинае тут работает.
[01:52:47.800 --> 01:52:49.800]  Да, это механизм,
[01:52:49.800 --> 01:52:51.800]  который позволяет вам подсказать
[01:52:51.800 --> 01:52:53.800]  компилятору, как
[01:52:53.800 --> 01:52:55.800]  по вот такому вызову конструктора
[01:52:55.800 --> 01:52:57.800]  понять, какой шаблонный аргумент
[01:52:57.800 --> 01:52:59.800]  вы хотите видеть у самого
[01:52:59.800 --> 01:53:01.800]  класса.
[01:53:01.800 --> 01:53:03.800]  Я смог придумать, зачем я это мог бы хотеть.
[01:53:03.800 --> 01:53:05.800]  Можно
[01:53:05.800 --> 01:53:07.800]  вернуться? На самом деле здесь
[01:53:07.800 --> 01:53:09.800]  уже используется свинае.
[01:53:09.800 --> 01:53:11.800]  Потому что
[01:53:11.800 --> 01:53:13.800]  если у итератора не окажется value type,
[01:53:13.800 --> 01:53:15.800]  то, по-моему, это не будет ошибкой.
[01:53:15.800 --> 01:53:17.800]  Да, я как раз про это
[01:53:17.800 --> 01:53:19.800]  и хотел сказать. Где я увижу
[01:53:19.800 --> 01:53:21.800]  ошибку? Я увижу, что
[01:53:21.800 --> 01:53:23.800]  deduction гайд сломался или что
[01:53:23.800 --> 01:53:25.800]  внутри что-то...
[01:53:25.800 --> 01:53:27.800]  Я почти уверен, что оно будет перебирать
[01:53:27.800 --> 01:53:29.800]  deduction гайды, пока не найдет тот, который...
[01:53:29.800 --> 01:53:31.800]  Кто-то просто напишет, типа, стяло текста,
[01:53:31.800 --> 01:53:33.800]  что все попробовал, ничего не получилось.
[01:53:33.800 --> 01:53:35.800]  Да.
[01:53:35.800 --> 01:53:37.800]  Поняли, о чем мы сейчас разговаривали?
[01:53:37.800 --> 01:53:39.800]  Да. Круто.
[01:53:39.800 --> 01:53:41.800]  Можно взять тоже? Да.
[01:53:41.800 --> 01:53:43.800]  В deduction гайды можно
[01:53:43.800 --> 01:53:45.800]  requires вписывать, насколько я помню.
[01:53:45.800 --> 01:53:47.800]  Это поможет.
[01:53:47.800 --> 01:53:49.800]  Стоп, то есть если я здесь напишу
[01:53:49.800 --> 01:53:51.800]  requires, то он мне... Нет,
[01:53:51.800 --> 01:53:53.800]  это не поможет с той проблемой, с которой я сказал.
[01:53:53.800 --> 01:53:55.800]  А какая проблема?
[01:53:55.800 --> 01:53:57.800]  Ну, если
[01:53:57.800 --> 01:53:59.800]  нет value type, то он будет перебирать
[01:53:59.800 --> 01:54:01.800]  все подряд. Да.
[01:54:01.800 --> 01:54:03.800]  Но в этом смысл.
[01:54:03.800 --> 01:54:05.800]  В смысле...
[01:54:05.800 --> 01:54:07.800]  Даст вам лишь возможность
[01:54:07.800 --> 01:54:09.800]  перегрузить deduction гайды.
[01:54:09.800 --> 01:54:11.800]  Короче, так и задумано. Это by design.
[01:54:11.800 --> 01:54:13.800]  Это не бага, не проблема. Так надо.
[01:54:13.800 --> 01:54:15.800]  Это правильно.
[01:54:15.800 --> 01:54:17.800]  Если назад проблема не проблема, то это не проблема?
[01:54:17.800 --> 01:54:19.800]  Да нет, это...
[01:54:19.800 --> 01:54:21.800]  Это с 17-х.
[01:54:21.800 --> 01:54:23.800]  В домашке вам придется это написать.
[01:54:23.800 --> 01:54:25.800]  Так что вот, если пока не понятно,
[01:54:25.800 --> 01:54:27.800]  то просто вот...
[01:54:27.800 --> 01:54:29.800]  Там простая задача будет, вы за один вечер
[01:54:29.800 --> 01:54:31.800]  поймете, что такое deduction гайды,
[01:54:31.800 --> 01:54:33.800]  а за второй вечер и третий
[01:54:33.800 --> 01:54:35.800]  прокачайте свое понимание, когда вторая задача
[01:54:35.800 --> 01:54:37.800]  будет выложена.
[01:54:37.800 --> 01:54:39.800]  Да, и после этого такой код работает.
[01:54:39.800 --> 01:54:41.800]  Потому что мы написали, если вызвали
[01:54:41.800 --> 01:54:43.800]  от двух одинаковых аргументов,
[01:54:43.800 --> 01:54:45.800]  а тут одинаковые begin и end типы
[01:54:45.800 --> 01:54:47.800]  имеют да,
[01:54:47.800 --> 01:54:49.800]  то тип нужно вывести как
[01:54:49.800 --> 01:54:51.800]  тыры-пыры-пыры. Ну, у итераторов, конечно,
[01:54:51.800 --> 01:54:53.800]  есть value type, у вектора.
[01:54:53.800 --> 01:54:55.800]  Но кстати, это неправда.
[01:54:57.800 --> 01:54:59.800]  Знаете, про что я?
[01:54:59.800 --> 01:55:01.800]  Вот такой код, на самом деле,
[01:55:01.800 --> 01:55:03.800]  не соответствует стандарту.
[01:55:03.800 --> 01:55:05.800]  Плохо писать такой код.
[01:55:05.800 --> 01:55:07.800]  На каком стандарте?
[01:55:07.800 --> 01:55:09.800]  На любом.
[01:55:09.800 --> 01:55:11.800]  Итератор trades, да.
[01:55:11.800 --> 01:55:13.800]  Потому что
[01:55:13.800 --> 01:55:15.800]  так сказать, compliant implementation
[01:55:15.800 --> 01:55:17.800]  языка C++
[01:55:17.800 --> 01:55:19.800]  может в качестве итераторов
[01:55:19.800 --> 01:55:21.800]  для вектора использовать указатели.
[01:55:21.800 --> 01:55:23.800]  И мы даже так делаем на работе.
[01:55:23.800 --> 01:55:25.800]  Ну ладно.
[01:55:25.800 --> 01:55:27.800]  Последняя тема
[01:55:27.800 --> 01:55:29.800]  это что можно все-таки вписывать в шаблоны?
[01:55:29.800 --> 01:55:31.800]  Вы думаете, что вы знаете?
[01:55:31.800 --> 01:55:33.800]  Автом можно писать.
[01:55:33.800 --> 01:55:35.800]  Автом можно писать.
[01:55:35.800 --> 01:55:37.800]  Подожди.
[01:55:37.800 --> 01:55:39.800]  Типом можно писать.
[01:55:39.800 --> 01:55:41.800]  Да, ну можно
[01:55:41.800 --> 01:55:43.800]  typeName класс
[01:55:43.800 --> 01:55:45.800]  можно писать int.
[01:55:45.800 --> 01:55:47.800]  А
[01:55:47.800 --> 01:55:49.800]  про разницу между typeName и class знаете?
[01:55:49.800 --> 01:55:51.800]  Нету.
[01:55:51.800 --> 01:55:53.800]  TypeName и class одно и то же
[01:55:53.800 --> 01:55:55.800]  в данном контексте, но есть такое
[01:55:55.800 --> 01:55:57.800]  мнимоническое правило. В некоторых код базах
[01:55:57.800 --> 01:55:59.800]  ему следует typeName, когда
[01:55:59.800 --> 01:56:01.800]  вы имеете в виду любой тип,
[01:56:01.800 --> 01:56:03.800]  а class, когда вы именно хотите
[01:56:03.800 --> 01:56:05.800]  типа ООП, чтобы там именно класс был,
[01:56:05.800 --> 01:56:07.800]  а не int.
[01:56:07.800 --> 01:56:09.800]  Но это так.
[01:56:09.800 --> 01:56:11.800]  Как вам удобнее пишите?
[01:56:11.800 --> 01:56:13.800]  Int понятно.
[01:56:13.800 --> 01:56:15.800]  А вот про такое.
[01:56:15.800 --> 01:56:17.800]  Знаете, что такое?
[01:56:19.800 --> 01:56:21.800]  Это указатель
[01:56:21.800 --> 01:56:23.800]  на member function.
[01:56:23.800 --> 01:56:25.800]  Это указатель на
[01:56:25.800 --> 01:56:27.800]  member function.
[01:56:27.800 --> 01:56:29.800]  Да, можно их
[01:56:29.800 --> 01:56:31.800]  передавать. Указатель на функции.
[01:56:31.800 --> 01:56:33.800]  Как пользоваться, в смысле?
[01:56:33.800 --> 01:56:35.800]  Ну это указатель на функции.
[01:56:35.800 --> 01:56:37.800]  Ну, ну, на F.
[01:56:37.800 --> 01:56:39.800]  Ну, на F.
[01:56:39.800 --> 01:56:41.800]  Ну, на F.
[01:56:41.800 --> 01:56:43.800]  Ну, на F.
[01:56:43.800 --> 01:56:45.800]  Ну, на F.
[01:56:45.800 --> 01:56:47.800]  Ну, на F.
[01:56:47.800 --> 01:56:49.800]  Шаблонные параметры.
[01:56:49.800 --> 01:56:51.800]  Я предлагаю...
[01:56:51.800 --> 01:56:53.800]  Есть сайт, короче, где все это
[01:56:53.800 --> 01:56:55.800]  объясняется, но у него неприличное
[01:56:55.800 --> 01:56:57.800]  название, поэтому под запись я не скажу.
[01:56:57.800 --> 01:56:59.800]  Но на гуглите.
[01:56:59.800 --> 01:57:01.800]  Но на гуглите.
[01:57:01.800 --> 01:57:03.800]  Возможно, я в чат скину, да,
[01:57:03.800 --> 01:57:05.800]  если не забуду.
[01:57:05.800 --> 01:57:07.800]  Как этим пользоваться, лучше
[01:57:07.800 --> 01:57:09.800]  сами разберитесь.
[01:57:09.800 --> 01:57:11.800]  Например, можно написать этот
[01:57:11.800 --> 01:57:13.800]  view, который проходит по всем
[01:57:13.800 --> 01:57:15.800]  полям в структуре.
[01:57:15.800 --> 01:57:17.800]  Много чего можно сделать,
[01:57:17.800 --> 01:57:19.800]  но вот у нас сейчас на это времени нет.
[01:57:19.800 --> 01:57:21.800]  Я с радостью объясню,
[01:57:21.800 --> 01:57:23.800]  но только в следующий раз или после
[01:57:23.800 --> 01:57:25.800]  следующий раз.
[01:57:25.800 --> 01:57:27.800]  Да, можно
[01:57:27.800 --> 01:57:29.800]  написать авто.
[01:57:29.800 --> 01:57:31.800]  Понимаете,
[01:57:31.800 --> 01:57:33.800]  что происходит?
[01:57:41.800 --> 01:57:43.800]  Нет, нельзя. Я тебе запрещаю.
[01:57:43.800 --> 01:57:45.800]  Кланг уронишь.
[01:57:45.800 --> 01:57:47.800]  В кланге будет внутренняя ошибка,
[01:57:47.800 --> 01:57:49.800]  если ты лямду сюда начнешь отправлять.
[01:57:49.800 --> 01:57:51.800]  Я проверял. До сих пор.
[01:57:51.800 --> 01:57:53.800]  Да, в кланге
[01:57:53.800 --> 01:57:55.800]  с этим пока баги.
[01:57:55.800 --> 01:57:57.800]  В компиляторе.
[01:57:57.800 --> 01:57:59.800]  Фродик получше, но тоже не увидит.
[01:57:59.800 --> 01:58:01.800]  Ну, короче...
[01:58:07.800 --> 01:58:09.800]  А что ты захватывать в такую лямду будешь?
[01:58:09.800 --> 01:58:11.800]  Честно?
[01:58:11.800 --> 01:58:13.800]  Ладно.
[01:58:13.800 --> 01:58:15.800]  Ну, это то же самое, что
[01:58:15.800 --> 01:58:17.800]  указатели на функции будут.
[01:58:17.800 --> 01:58:19.800]  Ну, короче, это да.
[01:58:21.800 --> 01:58:23.800]  Так тоже можно.
[01:58:23.800 --> 01:58:25.800]  Много чем,
[01:58:25.800 --> 01:58:27.800]  но в данном контексте
[01:58:27.800 --> 01:58:29.800]  ничем.
[01:58:29.800 --> 01:58:31.800]  Давайте сосредоточимся.
[01:58:31.800 --> 01:58:33.800]  Победный рвок, буквально там 5 слайдов,
[01:58:33.800 --> 01:58:35.800]  по-моему, осталось.
[01:58:35.800 --> 01:58:37.800]  Или 6. Надо добить.
[01:58:37.800 --> 01:58:39.800]  И разойдемся с чистой совестью.
[01:58:39.800 --> 01:58:41.800]  Декл-тайп от авто
[01:58:41.800 --> 01:58:43.800]  можно сюда писать.
[01:58:43.800 --> 01:58:45.800]  И авто можно писать. Разницы никакой.
[01:58:45.800 --> 01:58:47.800]  Но смысл все этого
[01:58:47.800 --> 01:58:49.800]  в том, что вы можете любой
[01:58:49.800 --> 01:58:51.800]  тип сюда закинуть.
[01:58:51.800 --> 01:58:53.800]  Можно инд, можно офлоут.
[01:58:53.800 --> 01:58:55.800]  Можно? К вам вопрос.
[01:58:55.800 --> 01:58:57.800]  Нет?
[01:58:57.800 --> 01:58:59.800]  Снова стандартный пункт.
[01:58:59.800 --> 01:59:01.800]  Можно. Только не нужно.
[01:59:01.800 --> 01:59:03.800]  Потому что флоты не бывают равными.
[01:59:03.800 --> 01:59:05.800]  Вы в курсе?
[01:59:05.800 --> 01:59:07.800]  Да. Если вы там 3 умножите на 2
[01:59:07.800 --> 01:59:09.800]  и 12 поделите на 2,
[01:59:09.800 --> 01:59:11.800]  то вы разный результат получите.
[01:59:11.800 --> 01:59:13.800]  И будут разные шаблоны. Разные специализации.
[01:59:13.800 --> 01:59:15.800]  Да и большими не бывают.
[01:59:15.800 --> 01:59:17.800]  Ну, короче, да.
[01:59:17.800 --> 01:59:19.800]  И то, и другое можно. Работает одинаково.
[01:59:19.800 --> 01:59:21.800]  Разворачивается вот в такой вот отрывок кода.
[01:59:21.800 --> 01:59:23.800]  То есть оно как бы за вас
[01:59:23.800 --> 01:59:25.800]  вот такую штуку пишет,
[01:59:25.800 --> 01:59:27.800]  где вот этот инд первый.
[01:59:27.800 --> 01:59:29.800]  Вводится автоматом.
[01:59:29.800 --> 01:59:31.800]  И да, если для вас это новость, то
[01:59:31.800 --> 01:59:33.800]  когда вы какой-то шаблонный аргумент уже написали,
[01:59:33.800 --> 01:59:35.800]  в последующих шаблонных аргументах
[01:59:35.800 --> 01:59:37.800]  вы его можете использовать.
[01:59:37.800 --> 01:59:39.800]  Такое забавное наблюдение.
[01:59:45.800 --> 01:59:47.800]  Да, не помню.
[01:59:47.800 --> 01:59:49.800]  Я не помню. Там шаблонный-шаблонный параметр или...
[01:59:53.800 --> 01:59:55.800]  Короче, в домашних тоже используйте,
[01:59:55.800 --> 01:59:57.800]  скорее всего, там столько всего намешанного,
[01:59:57.800 --> 01:59:59.800]  что тоже пригодится.
[01:59:59.800 --> 02:00:01.800]  Можно указатели передавать внезапно.
[02:00:03.800 --> 02:00:05.800]  То есть
[02:00:05.800 --> 02:00:07.800]  то, где в бинаре
[02:00:07.800 --> 02:00:09.800]  будет лежать
[02:00:09.800 --> 02:00:11.800]  какая-то переменная,
[02:00:11.800 --> 02:00:13.800]  это оказывается,
[02:00:13.800 --> 02:00:15.800]  статическая переменная, это оказывается
[02:00:15.800 --> 02:00:17.800]  compile-time-информация,
[02:00:17.800 --> 02:00:19.800]  и можно ее и в шаблоны запихать.
[02:00:19.800 --> 02:00:21.800]  И вот для меня это, если честно, было сюрпризом.
[02:00:23.800 --> 02:00:25.800]  Я надеюсь, это не вранье.
[02:00:25.800 --> 02:00:27.800]  Я сейчас задумался, а как это?
[02:00:27.800 --> 02:00:29.800]  Каждый год, видимо, задумываюсь.
[02:00:29.800 --> 02:00:31.800]  Каждый раз удивляюсь.
[02:00:31.800 --> 02:00:33.800]  Там нужно, наверное, чтобы
[02:00:33.800 --> 02:00:35.800]  у указываемой величины
[02:00:35.800 --> 02:00:37.800]  были кратст-экспорт
[02:00:37.800 --> 02:00:39.800]  каким-нибудь методом.
[02:00:39.800 --> 02:00:41.800]  Вот так работает.
[02:00:41.800 --> 02:00:43.800]  Если тут int заменить, то там уже начинаются детали.
[02:00:43.800 --> 02:00:45.800]  Было бы просто странно,
[02:00:45.800 --> 02:00:47.800]  если бы оно работало всегда,
[02:00:47.800 --> 02:00:49.800]  потому что мы можем взять, например,
[02:00:49.800 --> 02:00:51.800]  STD string нельзя шаблонным параметром сделать.
[02:00:51.800 --> 02:00:53.800]  А указатель на STD string?
[02:00:53.800 --> 02:00:55.800]  Может.
[02:00:55.800 --> 02:00:57.800]  Мне кажется, да.
[02:00:57.800 --> 02:00:59.800]  Так это же число просто.
[02:00:59.800 --> 02:01:01.800]  А string это...
[02:01:01.800 --> 02:01:03.800]  Давайте.
[02:01:05.800 --> 02:01:07.800]  Что? Амперсант?
[02:01:07.800 --> 02:01:09.800]  Нет, ссылки сюда пихать нельзя.
[02:01:09.800 --> 02:01:11.800]  Потому что...
[02:01:11.800 --> 02:01:13.800]  Не знаю. Даже с указателями
[02:01:13.800 --> 02:01:15.800]  это странно достаточно, если задуматься.
[02:01:15.800 --> 02:01:17.800]  Куда мы указываем?
[02:01:17.800 --> 02:01:19.800]  Вот эта вот...
[02:01:19.800 --> 02:01:21.800]  Подстановка шаблонов
[02:01:21.800 --> 02:01:23.800]  происходит в момент
[02:01:23.800 --> 02:01:25.800]  интерпретации кода AST
[02:01:25.800 --> 02:01:27.800]  компилятором.
[02:01:27.800 --> 02:01:29.800]  Куда мы указываем-то?
[02:01:29.800 --> 02:01:31.800]  Непонятно.
[02:01:31.800 --> 02:01:33.800]  Видимо, оно семантически
[02:01:33.800 --> 02:01:35.800]  таскает за собой... Помните, мы говорили,
[02:01:35.800 --> 02:01:37.800]  что вообще-то адреса всяких разных штук
[02:01:37.800 --> 02:01:39.800]  это заглушки, а потом на этапе линковки
[02:01:39.800 --> 02:01:41.800]  они подставляются.
[02:01:41.800 --> 02:01:43.800]  Рискну предположить,
[02:01:43.800 --> 02:01:45.800]  что здесь эта самая заглушка
[02:01:45.800 --> 02:01:47.800]  именованная вместо адреса
[02:01:47.800 --> 02:01:49.800]  таскается за собой, и везде,
[02:01:49.800 --> 02:01:51.800]  где она используется, эта заглушка будет потом
[02:01:51.800 --> 02:01:53.800]  подставлена линковщикам.
[02:01:53.800 --> 02:01:55.800]  А, то есть мы теперь еще и
[02:01:55.800 --> 02:01:57.800]  в процессе линковки будем расставлены?
[02:01:57.800 --> 02:01:59.800]  Ну, чем больше мы используем
[02:01:59.800 --> 02:02:01.800]  здесь
[02:02:01.800 --> 02:02:03.800]  этот указатель,
[02:02:03.800 --> 02:02:05.800]  тем, видимо, да, тем больше линковщику
[02:02:05.800 --> 02:02:07.800]  работы будет.
[02:02:07.800 --> 02:02:09.800]  Что?
[02:02:09.800 --> 02:02:11.800]  Адрес на пространстве?
[02:02:11.800 --> 02:02:13.800]  Да нет, просто про то, что
[02:02:13.800 --> 02:02:15.800]  вот это может быть не какая-то статическая переменная,
[02:02:15.800 --> 02:02:17.800]  а какая-то экстерна. И тогда мы не знаем.
[02:02:17.800 --> 02:02:19.800]  Фиксированная может быть
[02:02:19.800 --> 02:02:21.800]  реферия?
[02:02:21.800 --> 02:02:23.800]  А, или компиляция фиксирована?
[02:02:23.800 --> 02:02:25.800]  На этапе компиляции фиксирована
[02:02:25.800 --> 02:02:27.800]  должна быть. Ну, вернее, на этапе линковки
[02:02:27.800 --> 02:02:29.800]  оно уже понятно какое.
[02:02:29.800 --> 02:02:31.800]  А вот на этапе компиляции
[02:02:31.800 --> 02:02:33.800]  подстановка происходит, да, поэтому там вот есть
[02:02:33.800 --> 02:02:35.800]  некоторые детали. Ладно, давайте дальше. Мы опять
[02:02:35.800 --> 02:02:37.800]  надо наращивать темп.
[02:02:37.800 --> 02:02:39.800]  Теперь можно так. Смотрите,
[02:02:39.800 --> 02:02:41.800]  не говорите, что не видели.
[02:02:43.800 --> 02:02:45.800]  Структура
[02:02:45.800 --> 02:02:47.800]  запихнута в
[02:02:47.800 --> 02:02:49.800]  шаблонный
[02:02:49.800 --> 02:02:51.800]  аргумент другой структуры.
[02:02:51.800 --> 02:02:53.800]  Есть ограничение.
[02:02:53.800 --> 02:02:55.800]  Да, это должен быть какой-то супертривиальный
[02:02:55.800 --> 02:02:57.800]  подтип там со всеми ограничениями,
[02:02:57.800 --> 02:02:59.800]  что только можно.
[02:02:59.800 --> 02:03:01.800]  Много чего можно.
[02:03:01.800 --> 02:03:03.800]  Да.
[02:03:03.800 --> 02:03:05.800]  Да, внимание, вот тут
[02:03:05.800 --> 02:03:07.800]  как бы возникает вопрос,
[02:03:07.800 --> 02:03:09.800]  а когда мы считаем
[02:03:09.800 --> 02:03:11.800]  две инстанциации шаблона,
[02:03:11.800 --> 02:03:13.800]  я сказал плохо,
[02:03:13.800 --> 02:03:15.800]  две специализации,
[02:03:15.800 --> 02:03:17.800]  да, когда
[02:03:17.800 --> 02:03:19.800]  мы считаем, что вот
[02:03:19.800 --> 02:03:21.800]  два набора шаблонных аргументов
[02:03:21.800 --> 02:03:23.800]  должны нам в итоге дать
[02:03:23.800 --> 02:03:25.800]  одинаковую специализацию.
[02:03:25.800 --> 02:03:27.800]  Когда специализации равны,
[02:03:27.800 --> 02:03:29.800]  когда нет, да, побитого.
[02:03:29.800 --> 02:03:31.800]  Вот всегда. То есть
[02:03:31.800 --> 02:03:33.800]  если вы, может
[02:03:33.800 --> 02:03:35.800]  такая надежда у вас возникнуть, что если вы оператор
[02:03:35.800 --> 02:03:37.800]  равенства для определить,
[02:03:37.800 --> 02:03:39.800]  то он равный,
[02:03:39.800 --> 02:03:41.800]  вот здесь вот значение v запихнет в одну
[02:03:41.800 --> 02:03:43.800]  как бы специализацию, но нет,
[02:03:43.800 --> 02:03:45.800]  такого не будет.
[02:03:45.800 --> 02:03:47.800]  Наверное, когда это сделают,
[02:03:47.800 --> 02:03:49.800]  если еще не заложишь,
[02:03:49.800 --> 02:03:51.800]  если констакт сколько будет,
[02:03:51.800 --> 02:03:53.800]  нет, не надо.
[02:03:53.800 --> 02:03:55.800]  А еще да,
[02:03:55.800 --> 02:03:57.800]  но ты там
[02:03:57.800 --> 02:03:59.800]  можешь выдернуть какие-то
[02:03:59.800 --> 02:04:01.800]  непонятную, скрытую информацию,
[02:04:01.800 --> 02:04:03.800]  ты можешь достать, потому что бывает
[02:04:03.800 --> 02:04:05.800]  вика, квалит и всякие.
[02:04:05.800 --> 02:04:07.800]  Это следующая или после следующей лекция, короче,
[02:04:07.800 --> 02:04:09.800]  про равенство и что это такое.
[02:04:11.800 --> 02:04:13.800]  Да, ну на это посмотрели,
[02:04:13.800 --> 02:04:15.800]  вроде понятно, да, сюда подставили
[02:04:15.800 --> 02:04:17.800]  а инициализированный ничкой-двойкой.
[02:04:17.800 --> 02:04:19.800]  Следите за руками,
[02:04:19.800 --> 02:04:21.800]  сейчас будет сложно.
[02:04:23.800 --> 02:04:25.800]  Давайте,
[02:04:25.800 --> 02:04:27.800]  скажите, если назад нужно
[02:04:27.800 --> 02:04:29.800]  отмотать
[02:04:29.800 --> 02:04:31.800]  для сравнения.
[02:04:31.800 --> 02:04:33.800]  Было так?
[02:04:35.800 --> 02:04:37.800]  Стало так.
[02:04:39.800 --> 02:04:41.800]  Ну все хорошо.
[02:04:41.800 --> 02:04:43.800]  Ну окей, ну добавили шаблон, да?
[02:04:43.800 --> 02:04:45.800]  Нормально, но тут-то ничего не изменилось.
[02:04:51.800 --> 02:04:53.800]  Вам не кажется это безумием,
[02:04:53.800 --> 02:04:55.800]  что мы выводим шаблонный
[02:04:55.800 --> 02:04:57.800]  аргумент шаблонного аргумента в момент
[02:04:57.800 --> 02:04:59.800]  подстановки шаблонного аргумента?
[02:04:59.800 --> 02:05:01.800]  Мне кажется, это прекрасно.
[02:05:03.800 --> 02:05:05.800]  Да, последнее, что
[02:05:05.800 --> 02:05:07.800]  видимо мы сегодня успеваем, потому что нас сейчас уже выгонять будут.
[02:05:09.800 --> 02:05:11.800]  Что?
[02:05:13.800 --> 02:05:15.800]  Ну короче говоря,
[02:05:15.800 --> 02:05:17.800]  вот у нас в S есть A,
[02:05:17.800 --> 02:05:19.800]  у A шаблонный параметр T.
[02:05:19.800 --> 02:05:21.800]  Вот можем как-то, может быть, с ним
[02:05:21.800 --> 02:05:23.800]  поменять, чтобы внутри S-T использовать,
[02:05:23.800 --> 02:05:25.800]  если у A не нафисно юзинга?
[02:05:25.800 --> 02:05:27.800]  Думаю, нет.
[02:05:27.800 --> 02:05:29.800]  Напиши юзинг.
[02:05:29.800 --> 02:05:31.800]  Как бы, нет, в плюсах
[02:05:31.800 --> 02:05:33.800]  такими вещами не занимаются.
[02:05:33.800 --> 02:05:35.800]  Может дикл-тайп от FST?
[02:05:37.800 --> 02:05:39.800]  Побитого.
[02:05:39.800 --> 02:05:41.800]  Должны T совпасть?
[02:05:41.800 --> 02:05:43.800]  Должны совпасть T,
[02:05:43.800 --> 02:05:45.800]  а потом должны совпасть побитого
[02:05:45.800 --> 02:05:47.800]  представления.
[02:05:47.800 --> 02:05:49.800]  Да, и последнее,
[02:05:49.800 --> 02:05:51.800]  последнее, кажется.
[02:05:51.800 --> 02:05:53.800]  Шаблонные, шаблонные параметры.
[02:05:53.800 --> 02:05:55.800]  Любите шаблонные, шаблонные параметры?
[02:05:55.800 --> 02:05:57.800]  Да.
[02:06:01.800 --> 02:06:03.800]  Ну, давайте,
[02:06:03.800 --> 02:06:05.800]  про то, как это надо понимать в голове.
[02:06:07.800 --> 02:06:09.800]  Вот есть значение,
[02:06:09.800 --> 02:06:11.800]  а есть функции.
[02:06:11.800 --> 02:06:13.800]  Функция это отображение между значениями, так?
[02:06:13.800 --> 02:06:15.800]  На вход даете одно значение,
[02:06:15.800 --> 02:06:17.800]  на выход получаете новое значение.
[02:06:17.800 --> 02:06:19.800]  Есть типы,
[02:06:19.800 --> 02:06:21.800]  а есть отображение между типами.
[02:06:21.800 --> 02:06:23.800]  Это шаблоны.
[02:06:23.800 --> 02:06:25.800]  На вход шаблоны вы даете один тип,
[02:06:25.800 --> 02:06:27.800]  на выход получаете другой тип.
[02:06:27.800 --> 02:06:29.800]  Согласны?
[02:06:29.800 --> 02:06:31.800]  Ну, шаблон
[02:06:31.800 --> 02:06:33.800]  тогда очень похож на функцию.
[02:06:33.800 --> 02:06:35.800]  Шаблон для типов
[02:06:35.800 --> 02:06:37.800]  это то же самое, что и функция
[02:06:37.800 --> 02:06:39.800]  для значений.
[02:06:39.800 --> 02:06:41.800]  Вот абсолютно то же самое.
[02:06:41.800 --> 02:06:43.800]  То есть это нужно понимать
[02:06:43.800 --> 02:06:45.800]  как такой указатель
[02:06:45.800 --> 02:06:47.800]  на метафункцию.
[02:06:47.800 --> 02:06:49.800]  Некоторая метафункция,
[02:06:49.800 --> 02:06:51.800]  которая на вход берет один класс,
[02:06:51.800 --> 02:06:53.800]  а на выход выдает другой класс
[02:06:53.800 --> 02:06:55.800]  и имя этой функции T.
[02:06:55.800 --> 02:06:57.800]  А дальше мы вот здесь
[02:06:57.800 --> 02:06:59.800]  берем и вызываем эту функцию
[02:06:59.800 --> 02:07:01.800]  от int.
[02:07:01.800 --> 02:07:03.800]  На выход получаем какой-то другой тип
[02:07:03.800 --> 02:07:05.800]  и заводим переменную такого типа.
[02:07:05.800 --> 02:07:07.800]  Не уверен, где здесь композиция.
[02:07:07.800 --> 02:07:09.800]  Не уверен, где здесь композиция.
[02:07:09.800 --> 02:07:11.800]  Не уверен, где здесь композиция.
[02:07:11.800 --> 02:07:13.800]  Ну, скорее не композиция,
[02:07:13.800 --> 02:07:15.800]  а отображение из шаблонов
[02:07:15.800 --> 02:07:17.800]  во что-то еще.
[02:07:17.800 --> 02:07:19.800]  Ну, короче, это функция.
[02:07:19.800 --> 02:07:21.800]  Ладно, нет, вру.
[02:07:21.800 --> 02:07:23.800]  Так, по одному,
[02:07:23.800 --> 02:07:25.800]  по одному.
[02:07:25.800 --> 02:07:27.800]  Давайте дальше
[02:07:27.800 --> 02:07:29.800]  вот оставим на потом.
[02:07:29.800 --> 02:07:31.800]  Вот это?
[02:07:31.800 --> 02:07:33.800]  Презентация все будет.
[02:07:33.800 --> 02:07:35.800]  Презентация все будет.
[02:07:35.800 --> 02:07:37.800]  Я сегодня вечером все выложу.
[02:07:37.800 --> 02:07:39.800]  Так.
[02:07:39.800 --> 02:07:41.800]  Какие-то вопросы были.
[02:07:41.800 --> 02:07:43.800]  Проблема в том, что...
[02:07:43.800 --> 02:07:45.800]  Логика такая. У тебя есть типы...
[02:07:45.800 --> 02:07:47.800]  Стоп, нет.
[02:07:47.800 --> 02:07:49.800]  У тебя есть значения.
[02:07:49.800 --> 02:07:51.800]  Значения это некоторые абстрактные шняги.
[02:07:51.800 --> 02:07:53.800]  Их можно отображать друг в друга функциями.
[02:07:53.800 --> 02:07:55.800]  На вход функция
[02:07:55.800 --> 02:07:57.800]  ты дала одно значение,
[02:07:57.800 --> 02:07:59.800]  на выход получил другое значение.
[02:07:59.800 --> 02:08:01.800]  Теперь поднимаемся на уровень выше.
[02:08:01.800 --> 02:08:03.800]  Мета начинается.
[02:08:03.800 --> 02:08:05.800]  Есть типы.
[02:08:07.800 --> 02:08:09.800]  Если...
[02:08:09.800 --> 02:08:11.800]  Да, есть шаблоны.
[02:08:11.800 --> 02:08:13.800]  Шаблон это такая метафункция,
[02:08:13.800 --> 02:08:15.800]  которая на вход получает один тип,
[02:08:15.800 --> 02:08:17.800]  на выход подает другой.
[02:08:17.800 --> 02:08:19.800]  Точно так же, как обычная функция
[02:08:19.800 --> 02:08:21.800]  на вход значения получает,
[02:08:21.800 --> 02:08:23.800]  и на выход другие значения.
[02:08:23.800 --> 02:08:25.800]  Мета функция на вход типы получает,
[02:08:25.800 --> 02:08:27.800]  и на выход типы дает.
[02:08:27.800 --> 02:08:29.800]  Вот это указатель на метафункцию.
[02:08:31.800 --> 02:08:33.800]  Наш шаблон.
[02:08:33.800 --> 02:08:35.800]  Да.
[02:08:35.800 --> 02:08:37.800]  Грубо говоря.
[02:08:37.800 --> 02:08:39.800]  Ну, как указатель на функцию
[02:08:39.800 --> 02:08:41.800]  можно передать в другую функцию.
[02:08:41.800 --> 02:08:43.800]  Так мы в один шаблон.
[02:08:43.800 --> 02:08:45.800]  Сколько конкретно указатель на шаблон?
[02:08:45.800 --> 02:08:47.800]  T.
[02:08:47.800 --> 02:08:49.800]  Вот это вот имя T,
[02:08:49.800 --> 02:08:51.800]  это указатель на шаблон.
[02:08:51.800 --> 02:08:53.800]  Какой шаблон?
[02:08:53.800 --> 02:08:55.800]  Шаблоны разные бывают.
[02:08:55.800 --> 02:08:57.800]  Который берет на вход один класс
[02:08:57.800 --> 02:08:59.800]  и дает на выход другой класс.
[02:08:59.800 --> 02:09:01.800]  То есть это как указатель
[02:09:01.800 --> 02:09:03.800]  на функцию который ты передаешь
[02:09:03.800 --> 02:09:05.800]  в другую функцию,
[02:09:05.800 --> 02:09:07.800]  только указатель на шаблон,
[02:09:07.800 --> 02:09:09.800]  который ты передаешь в другой шаблон.
[02:09:09.800 --> 02:09:11.800]  У нас в качестве шаблона
[02:09:11.800 --> 02:09:13.800]  идет указатель на другой шаблон.
[02:09:13.800 --> 02:09:15.800]  Да, в качестве шаблонного аргумента
[02:09:15.800 --> 02:09:17.800]  идет указатель на другой шаблон.
[02:09:17.800 --> 02:09:19.800]  Да, только его указателем обычно не называют,
[02:09:19.800 --> 02:09:21.800]  но это хорошая интуиция.
[02:09:21.800 --> 02:09:23.800]  Оно как указатель на функцию,
[02:09:23.800 --> 02:09:25.800]  то только на шаблон.
[02:09:25.800 --> 02:09:27.800]  И как разница между функцией
[02:09:27.800 --> 02:09:30.800]  только вот здесь класса и шаблон класса.
[02:09:30.800 --> 02:09:32.800]  Ну, тоже может быть.
[02:09:32.800 --> 02:09:34.800]  Мне не очень нравится такая интуиция.
[02:09:34.800 --> 02:09:37.800]  Ну, все, что поможет вам помочь,
[02:09:37.800 --> 02:09:40.800]  поможет вам понять, все хорошо.
[02:09:40.800 --> 02:09:42.800]  Но мы эту функцию можем использовать.
[02:09:42.800 --> 02:09:43.800]  Мета-функция, да?
[02:09:43.800 --> 02:09:45.800]  Мета-функции вызывают с треугольными скобками.
[02:09:45.800 --> 02:09:48.800]  Вызвав эту мета-функцию от типа,
[02:09:48.800 --> 02:09:51.800]  получаем другой тип.
[02:09:51.800 --> 02:09:52.800]  Да?
[02:09:52.800 --> 02:09:53.800]  Это я напоминаю.
[02:09:53.800 --> 02:09:54.800]  Это может быть алиас.
[02:09:54.800 --> 02:09:57.800]  И этот алиас может все инты отображать в буль.
[02:09:57.800 --> 02:10:00.800]  Или все другие типы отображать в буль.
[02:10:00.800 --> 02:10:02.800]  То есть не надо думать, что это какой-то вот именно
[02:10:02.800 --> 02:10:03.800]  строго шаблон-шаблон.
[02:10:03.800 --> 02:10:05.800]  Это просто отображение куда-то,
[02:10:05.800 --> 02:10:07.800]  непонятно куда.
[02:10:07.800 --> 02:10:09.800]  А можно так писать указания или автозиции?
[02:10:09.800 --> 02:10:11.800]  Ну, то есть, короче, вот после
[02:10:11.800 --> 02:10:13.800]  deplay класса,
[02:10:13.800 --> 02:10:16.800]  какая-нибудь сигнатура?
[02:10:18.800 --> 02:10:20.800]  С шаблонами функции нет.
[02:10:20.800 --> 02:10:21.800]  Пока нельзя?
[02:10:21.800 --> 02:10:22.800]  Нельзя.
[02:10:22.800 --> 02:10:24.800]  Куда мы отображаем?
[02:10:24.800 --> 02:10:25.800]  Только типом.
[02:10:25.800 --> 02:10:27.800]  Вот в этом ограничении этой системы.
[02:10:27.800 --> 02:10:28.800]  Казалось бы.
[02:10:28.800 --> 02:10:30.800]  А что мешает вот здесь вместо класс написать, например,
[02:10:30.800 --> 02:10:31.800]  буль?
[02:10:31.800 --> 02:10:33.800]  И передавать шаблон переменной?
[02:10:33.800 --> 02:10:34.800]  Вот было бы классно.
[02:10:34.800 --> 02:10:35.800]  Нельзя пока.
[02:10:35.800 --> 02:10:36.800]  Не сделали.
[02:10:36.800 --> 02:10:39.800]  А может, чтобы отображение к классу еще
[02:10:39.800 --> 02:10:41.800]  возвращало мета-функцию?
[02:10:41.800 --> 02:10:42.800]  Нет.
[02:10:42.800 --> 02:10:44.800]  Тоже нельзя.
[02:10:44.800 --> 02:10:45.800]  Я понимаю.
[02:10:45.800 --> 02:10:48.800]  Ты, видимо, функционально увлекаешься, да?
[02:10:48.800 --> 02:10:50.800]  Нет?
[02:10:50.800 --> 02:10:53.800]  Ну, есть что-то, какая-то зерно в тебе.
[02:10:53.800 --> 02:10:54.800]  Чего?
[02:10:54.800 --> 02:10:56.800]  У тебя ограничение, кажется, не должно,
[02:10:56.800 --> 02:10:58.800]  потому что мы всегда можем просто делать шаблонный класс,
[02:10:58.800 --> 02:11:00.800]  у которого будет вот эта единственная функция.
[02:11:00.800 --> 02:11:01.800]  Да, да.
[02:11:01.800 --> 02:11:02.800]  Аккумулятор мог бы за нас оборачивать.
[02:11:02.800 --> 02:11:04.800]  Да, хаками можно все ограничения обойти,
[02:11:04.800 --> 02:11:07.800]  поэтому не хотят добавлять новые вот эти вот всякие сущности,
[02:11:07.800 --> 02:11:08.800]  но вот как есть.
[02:11:08.800 --> 02:11:11.800]  Слушайте, я хотел про специализацию успеть еще сегодня,
[02:11:11.800 --> 02:11:13.800]  но нифига мы не успеваем.
[02:11:13.800 --> 02:11:16.800]  Мне очень грустно.
[02:11:16.800 --> 02:11:19.800]  Отвалилась, да?
[02:11:19.800 --> 02:11:20.800]  Про явные специализации.
[02:11:20.800 --> 02:11:22.800]  Не хотим, не успеем.
[02:11:22.800 --> 02:11:25.800]  А ты хочешь камеру забрать, да?
[02:11:25.800 --> 02:11:27.800]  Нет, просто пришел посмотреть.
[02:11:27.800 --> 02:11:30.800]  Мне в целом неважно, если...
[02:11:30.800 --> 02:11:33.800]  Давайте за 4 минуты.
[02:11:33.800 --> 02:11:38.800]  Вот сейчас прогоним.
[02:11:38.800 --> 02:11:41.800]  Вот специализации есть.
[02:11:41.800 --> 02:11:42.800]  Есть явные...
[02:11:42.800 --> 02:11:44.800]  Да, все это называется явные специализации, если что.
[02:11:44.800 --> 02:11:46.800]  То, что вы до сих пор просто специализации говорили,
[02:11:46.800 --> 02:11:48.800]  добавьте слово явное.
[02:11:48.800 --> 02:11:51.800]  Потому что просто специализация, как мы уже выяснили,
[02:11:51.800 --> 02:11:55.800]  это любой тип или функция, получаемая по шаблону.
[02:11:55.800 --> 02:12:00.800]  Можно написать явную специализацию для каких-то конкретных аргументов шаблона.
[02:12:00.800 --> 02:12:03.800]  И есть там полные, соответственно, и частичные.
[02:12:03.800 --> 02:12:05.800]  Ну, я надеюсь, вы это видели уже раньше.
[02:12:05.800 --> 02:12:07.800]  Не новости для вас.
[02:12:07.800 --> 02:12:09.800]  Вот для функций нету частичных специализаций.
[02:12:09.800 --> 02:12:12.800]  Так сделано специально, потому что иначе можно сдохнуть.
[02:12:12.800 --> 02:12:14.800]  Реально.
[02:12:14.800 --> 02:12:18.800]  Правила вызова функций и понятия, какую функцию по какому имени вызывать,
[02:12:18.800 --> 02:12:20.800]  в ней уже космические, мы это увидим.
[02:12:20.800 --> 02:12:25.800]  Если бы к ним еще частичные специализации шаблонов добавились...
[02:12:25.800 --> 02:12:27.800]  Они бы были бы вообще разрешены.
[02:12:27.800 --> 02:12:29.800]  Ну, наверное.
[02:12:29.800 --> 02:12:31.800]  Просто бомба была бы.
[02:12:31.800 --> 02:12:32.800]  Короче, невозможно работать.
[02:12:32.800 --> 02:12:34.800]  Тем более функции перегружать можно.
[02:12:34.800 --> 02:12:37.800]  Вы можете два разных шаблона функций сделать
[02:12:37.800 --> 02:12:41.800]  с одним именем, и они будут друг к другу перегружать
[02:12:41.800 --> 02:12:43.800]  специализации, получающиеся из них.
[02:12:43.800 --> 02:12:45.800]  И все будет ток.
[02:12:45.800 --> 02:12:49.800]  А алиасы и концепты вообще нельзя, да?
[02:12:49.800 --> 02:12:54.800]  Про алиасы, по-моему, это не совсем правда.
[02:12:54.800 --> 02:12:58.800]  По-моему, можно все-таки специализации писать для...
[02:12:58.800 --> 02:13:00.800]  Да.
[02:13:00.800 --> 02:13:05.800]  Можно явные специализации писать, по-моему, полные для юзингов.
[02:13:05.800 --> 02:13:06.800]  С недавних пор.
[02:13:06.800 --> 02:13:08.800]  Надо поправить презентацию.
[02:13:08.800 --> 02:13:11.800]  Для концептов специализации делать нельзя явных.
[02:13:11.800 --> 02:13:14.800]  Кажется, в 2017 году вроде нельзя было, а в 2020 можно.
[02:13:14.800 --> 02:13:15.800]  Ну, вот да.
[02:13:15.800 --> 02:13:16.800]  Кажется, я забыл обновить.
[02:13:16.800 --> 02:13:17.800]  Надо...
[02:13:17.800 --> 02:13:18.800]  А вот еще раз.
[02:13:18.800 --> 02:13:20.800]  Неявная специализация — это что?
[02:13:20.800 --> 02:13:21.800]  Явная специализация.
[02:13:21.800 --> 02:13:22.800]  Неявная.
[02:13:22.800 --> 02:13:28.800]  А это когда вы просто используете этот тип с каким-то шаблонным
[02:13:28.800 --> 02:13:32.800]  аргументом, и компилятор за вас идет, находит главный
[02:13:32.800 --> 02:13:36.800]  шаблон, и из него генерируют путем инстанциации новую
[02:13:36.800 --> 02:13:37.800]  специализацию.
[02:13:37.800 --> 02:13:40.800]  Наверное, просто функция качества аргумента передает
[02:13:40.800 --> 02:13:44.800]  какое-то значение, и он понимает тип этого значения
[02:13:44.800 --> 02:13:46.800]  и подставляет шаблон в бликах.
[02:13:46.800 --> 02:13:49.800]  Когда компилятору надо вывести тип, тогда это не явно.
[02:13:49.800 --> 02:13:50.800]  Да.
[02:13:50.800 --> 02:13:51.800]  Ну, на самом деле нет.
[02:13:51.800 --> 02:13:54.800]  Наверное, проще сказать, что понимается под явной
[02:13:54.800 --> 02:13:55.800]  специализацией.
[02:13:55.800 --> 02:13:56.800]  Да.
[02:13:56.800 --> 02:13:58.800]  Неявные специализации — это те, которые генерируются
[02:13:58.800 --> 02:13:59.800]  по главному шаблону.
[02:13:59.800 --> 02:14:04.800]  Плохо, да?
[02:14:04.800 --> 02:14:05.800]  Короче, вот.
[02:14:05.800 --> 02:14:10.800]  Все, что будет сгенерировано из этого шаблона, например,
[02:14:10.800 --> 02:14:13.800]  вот таким путем, это неявные специализации.
[02:14:13.800 --> 02:14:16.800]  Они сами сгенерированы компилятором.
[02:14:16.800 --> 02:14:20.800]  Код для них просто по шаблону получается.
[02:14:20.800 --> 02:14:21.800]  Ну и, соответственно, вопрос.
[02:14:21.800 --> 02:14:22.800]  Что это за код?
[02:14:22.800 --> 02:14:23.800]  Будет работать?
[02:14:23.800 --> 02:14:24.800]  Не будет?
[02:14:24.800 --> 02:14:25.800]  Что-то происходит.
[02:14:25.800 --> 02:14:28.800]  Ну, работает он будет?
[02:14:28.800 --> 02:14:29.800]  Нет.
[02:14:29.800 --> 02:14:30.800]  Почему?
[02:14:30.800 --> 02:14:39.800]  Да, потому что, чтобы про TypeCheck вот это выражение,
[02:14:39.800 --> 02:14:45.800]  нам нужно понять, какой тип имеет каждый из под выражений.
[02:14:45.800 --> 02:14:46.800]  Так?
[02:14:46.800 --> 02:14:48.800]  Ну, компилятор TypeCheck делает, чтобы убедиться, что у вас
[02:14:48.800 --> 02:14:49.800]  нет ошибок с типами.
[02:14:49.800 --> 02:14:50.800]  Да?
[02:14:50.800 --> 02:14:53.800]  Ну, то есть нужно и n-2, и n-1 инстанцировать, чтобы
[02:14:53.800 --> 02:14:55.800]  понять, какой тип у них.
[02:14:55.800 --> 02:14:58.800]  Ну, то есть понять, какая специализация и какой тип.
[02:14:58.800 --> 02:14:59.800]  Сразу понять нельзя.
[02:14:59.800 --> 02:15:02.800]  Как и раньше, зависимые имена, вот это все, мы не знаем,
[02:15:02.800 --> 02:15:03.800]  какая специализация будет.
[02:15:03.800 --> 02:15:06.800]  Ну, поэтому оно будет до бесконечности брать и в
[02:15:06.800 --> 02:15:09.800]  обе ветки идти, и обе их инстанцировать.
[02:15:09.800 --> 02:15:16.800]  Ну, как бы да, но это не поможет.
[02:15:16.800 --> 02:15:17.800]  Просто сдохнем.
[02:15:17.800 --> 02:15:22.800]  Поэтому, чтобы поправить, как раз вот эти штуки есть.
[02:15:22.800 --> 02:15:24.800]  Вот это явные специализации.
[02:15:24.800 --> 02:15:28.800]  Мы взяли и выбрали конкретный набор аргументов, для которых
[02:15:28.800 --> 02:15:31.800]  тело сущности написали руками.
[02:15:31.800 --> 02:15:34.800]  Оно не по основному шаблону генерируется.
[02:15:34.800 --> 02:15:38.800]  А мы явно выписали, как эта специализация должна выглядеть.
[02:15:38.800 --> 02:15:41.800]  То есть специализация для нуля выглядит вот так.
[02:15:41.800 --> 02:15:43.800]  Специализация для единички выглядит вот так.
[02:15:43.800 --> 02:15:47.800]  Вот, собственно, почему явное и неявное, говорится.
[02:15:47.800 --> 02:15:50.800]  То есть большая часть специализаций, получающихся
[02:15:50.800 --> 02:15:53.800]  в результате инстанциации этого шаблона, они по главному
[02:15:53.800 --> 02:15:56.800]  вот этому вот главной части.
[02:15:56.800 --> 02:15:59.800]  Да, они не явно получаются из главной части.
[02:15:59.800 --> 02:16:02.800]  По-моему, это тоже называют главной специализацией.
[02:16:02.800 --> 02:16:04.800]  Но это плохо так.
[02:16:04.800 --> 02:16:06.800]  Надо уточнить терминологию.
[02:16:06.800 --> 02:16:08.800]  Но, короче, они вот из этого куска получаются.
[02:16:08.800 --> 02:16:11.800]  И только два случая, когда вот нам не подходит общий
[02:16:11.800 --> 02:16:15.800]  алгоритм получения специализации, мы явно прописываем
[02:16:15.800 --> 02:16:18.800]  какой-то каштомный способ получить специализацию.
[02:16:18.800 --> 02:16:22.800]  — А вот там уставить, чтобы у нас не было в бинареи, да?
[02:16:22.800 --> 02:16:25.800]  — Чтобы они в компелтами считались.
[02:16:25.800 --> 02:16:28.800]  Конст-экспорт-переменные инициализируются в компайл-тайме,
[02:16:28.800 --> 02:16:30.800]  а также являются константами.
[02:16:30.800 --> 02:16:33.800]  То есть их варентаймер менять нельзя, а инициализация
[02:16:33.800 --> 02:16:36.800]  их происходит в момент компиляции прямо.
[02:16:36.800 --> 02:16:39.800]  — А если не писать, почему будет?
[02:16:39.800 --> 02:16:42.800]  Там же тоже будет комплей-тайм?
[02:16:42.800 --> 02:16:45.800]  — Ну, вообще да, но как бы...
[02:16:45.800 --> 02:16:47.800]  — И не было в бинареи?
[02:16:47.800 --> 02:16:51.800]  — Да нет, конст-экспорт-переменные в бинареи включиться могут.
[02:16:51.800 --> 02:16:54.800]  Например, если ты адрес возьмешь.
[02:16:55.800 --> 02:16:59.800]  Давайте отложим этот разговор, опять в детали вдаемся.
[02:16:59.800 --> 02:17:02.800]  Разговор про конст-экспорт в следующий раз, возможно, будет.
[02:17:02.800 --> 02:17:05.800]  Но вот то, что на прошлом слайде было, это всё фигня,
[02:17:05.800 --> 02:17:08.800]  потому что теперь так можно делать.
[02:17:08.800 --> 02:17:11.800]  Это просто функция, которая вычисляет рекурсивные числа Фибоначчи.
[02:17:11.800 --> 02:17:14.800]  Я наляпнул сюда конст-экспорт, ну и всё.
[02:17:14.800 --> 02:17:17.800]  Я уже могу её в статических контекстах использовать
[02:17:17.800 --> 02:17:20.800]  в константных выражениях, можно в другой шаблон
[02:17:20.800 --> 02:17:23.800]  подставить в качестве аргумента вызов этой функции.
[02:17:23.800 --> 02:17:26.800]  Просто потому что конст-экспорт.
[02:17:26.800 --> 02:17:29.800]  Про конст-экспорт потом будет ещё, либо сами почитайте.
[02:17:29.800 --> 02:17:32.800]  — Там же ещё главное преимущество, что мы можем эту функцию
[02:17:32.800 --> 02:17:35.800]  юзать, когда мы эти 49 в рантайме-то поузнаем.
[02:17:35.800 --> 02:17:37.800]  — Да. — Шаблоны бы так не получили.
[02:17:37.800 --> 02:17:40.800]  — Да, вот такую функцию можно и в рантайме, и в компайл-тайме
[02:17:40.800 --> 02:17:43.800]  юзать, это здорово. — В конст-вал есть?
[02:17:43.800 --> 02:17:46.800]  — Есть, потом про него поговорим.
[02:17:46.800 --> 02:17:49.800]  Зачем нужны вообще специализации?
[02:17:49.800 --> 02:17:52.800]  Например, вектор булей делать. Узнайте, как вектор булей работает.
[02:17:52.800 --> 02:17:55.800]  Любите вектор булей? Ну вот да, он особенный.
[02:17:55.800 --> 02:17:58.800]  Это вежливо так говорить сейчас.
[02:17:58.800 --> 02:18:01.800]  Да, да, да.
[02:18:01.800 --> 02:18:04.800]  Но можно ещё всякие тайп-трейцы делать.
[02:18:04.800 --> 02:18:07.800]  Например, снимать указатель с типов.
[02:18:07.800 --> 02:18:10.800]  Вот это вот частичная уже специализация.
[02:18:10.800 --> 02:18:13.800]  Там была полная, а это частичная.
[02:18:13.800 --> 02:18:16.800]  Чувствуете, в чём разница?
[02:18:16.800 --> 02:18:19.800]  — Мы сказали, что теперь для любого указателя.
[02:18:19.800 --> 02:18:23.800]  — Да. То есть мы как бы берём и не конкретный один набор аргументов.
[02:18:23.800 --> 02:18:26.800]  Явно прописываем специализацию ему.
[02:18:26.800 --> 02:18:30.800]  А все наборы аргументов, которые выглядят примерно так, вот как указатели.
[02:18:30.800 --> 02:18:33.800]  — Получается, сейчас можно всё упрать в просто алиасы?
[02:18:33.800 --> 02:18:36.800]  — Сейчас не уверен.
[02:18:36.800 --> 02:18:39.800]  — Или полное? — Не уверен. По-моему только полное.
[02:18:39.800 --> 02:18:42.800]  Поиграйте сами.
[02:18:42.800 --> 02:18:45.800]  Понятно, что это делает, да?
[02:18:45.800 --> 02:18:48.800]  Если мы подставили аргументу, у которого есть звёздочка,
[02:18:48.800 --> 02:18:51.800]  то это будет в другое правило.
[02:18:51.800 --> 02:18:54.800]  Если нет, то в другое правило, и будет какая-нибудь ошибка.
[02:18:54.800 --> 02:18:57.800]  Если вы когда-нибудь писали на Хаскеле или чём-нибудь подобном,
[02:18:57.800 --> 02:19:00.800]  это вам, на удивление, кажется знакомым.
[02:19:00.800 --> 02:19:03.800]  В этом есть глубокая истина, но у нас нет времени на неё.
[02:19:03.800 --> 02:19:06.800]  Да, это именно он.
[02:19:06.800 --> 02:19:09.800]  Это последний слайд.
[02:19:09.800 --> 02:19:12.800]  Вы представляете, это последний слайд.
[02:19:12.800 --> 02:19:15.800]  На нём я хотел показать следующую мысль,
[02:19:15.800 --> 02:19:18.800]  вот класс T, его можно дальше использовать,
[02:19:18.800 --> 02:19:21.800]  как угодно, в других шаблонных аргументах.
[02:19:21.800 --> 02:19:24.800]  Давайте его в буль засунем,
[02:19:24.800 --> 02:19:27.800]  вернее, какое-то выражение,
[02:19:27.800 --> 02:19:30.800]  зависящее от вот этого T, засунем в буль.
[02:19:30.800 --> 02:19:33.800]  А потом сделаем две специализации частичные,
[02:19:33.800 --> 02:19:36.800]  одну для true, другую для false.
[02:19:36.800 --> 02:19:39.800]  То есть мы таким образом можем выбрать,
[02:19:39.800 --> 02:19:42.800]  порезать пополам семейство множества специализаций,
[02:19:42.800 --> 02:19:45.800]  которые могут получиться в результате инстанциации нашего шаблона.
[02:19:45.800 --> 02:19:48.800]  Мы его пополам бьём вот этим бульом.
[02:19:48.800 --> 02:19:51.800]  Одну половину здесь реализуем, другую половину тут.
[02:19:51.800 --> 02:19:54.800]  А можно и не пополам, можно и на четыре, на восемь частей,
[02:19:54.800 --> 02:19:57.800]  вообще как хотите.
[02:19:57.800 --> 02:20:00.800]  Да, конечно, тут всё compile-time должно быть.
[02:20:00.800 --> 02:20:03.800]  Вот, на этом у меня всё.
[02:20:03.800 --> 02:20:06.800]  Не кодить мы не идём,
[02:20:06.800 --> 02:20:09.800]  мы слишком долго, слишком долго.
[02:20:09.800 --> 02:20:12.800]  Все, что пришли, все свободны.
