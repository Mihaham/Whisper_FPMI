[00:00.000 --> 00:10.620]  Здравствуйте! Давайте начинать. Мы продолжаем говорить про деревоотресков, то, что начали в
[00:10.620 --> 00:18.200]  прошлый раз. Сегодня посмотрим всякие разные модификации, как можно в разных задачах это
[00:18.200 --> 00:35.080]  использовать. Давайте начнем с динамического деревоотресков. Возможно, кому-то из вас привычнее
[00:35.080 --> 00:42.200]  название неявное деревоотресков, но я предпочитаю динамическое. Задача, на самом деле, такая же,
[00:42.200 --> 00:48.280]  как обычно. Давайте самую простую рассмотрим, потому что остальные более-менее так же просто
[00:48.280 --> 00:53.280]  переносится. Представьте, что у вас массив был изначально не маленький, типа размера n,
[00:53.280 --> 00:58.000]  который можно было сохранить в памяти, а представьте, что у вас был очень большой какой-то массив,
[00:58.000 --> 01:08.120]  скажем там, размера 10 в 9. Ну и понятно, вы в памяти его сохранить не можете, но, допустим,
[01:08.120 --> 01:11.960]  вы знаете, что изначально все элементы нулевые, и дальше с элементами происходит все то же
[01:11.960 --> 01:17.360]  самое, что обычно, то есть обновление в точке суммы на отрезке. Короче, как обычная задача для
[01:17.360 --> 01:24.920]  деревоотресков, только массив большой, грубо говоря, и изначально заполнен нулями. Давайте
[01:24.920 --> 01:37.460]  напишем, что а0, а1 и так далее, а с индексом c-1, или не хочу я c писать. Давайте c как-то
[01:37.460 --> 01:51.000]  необычно. Значит, изначально нули, ну и те же два типа запросов, это обновление в точке и сумма
[01:51.000 --> 02:07.200]  на отрезке. Ну понятно, мы не можем создать деревоотресков на n элементах, потому что
[02:07.200 --> 02:11.720]  слишком много, оно там даже в какую-то адекватную память не поместится. Тем более сверху надо
[02:11.720 --> 02:17.480]  этим еще что-то достраивать. Давайте сделаем такую простую вещь. Давайте мы деревоотресков
[02:17.480 --> 02:23.360]  наши, как будто бы виртуально построим на вот этом всем большом массиве. Но понятно, что изначально
[02:23.360 --> 02:28.120]  там будет куча вершин, и во всех вершинах будут нули, потому что сумма в каждой точке будет 0,
[02:28.120 --> 02:35.760]  ну потому что в поддереве все нули. Давайте нули не хранить. Давайте вот те вершины, в которых,
[02:35.760 --> 02:40.760]  грубо говоря, в поддеревях которых еще ничего не происходило, то есть если вершина контролирует
[02:40.760 --> 02:45.000]  какой-то вот такой вот подотрезок, и здесь ничего не происходило, к этим элементам не было
[02:45.000 --> 02:50.240]  вообще никаких обращений, ну давайте просто эту вершину как бы не хранить. В ней все равно 0. Если
[02:50.240 --> 02:56.000]  внезапно в какой-то момент времени мы захотим до нее дойти, то ее отсутствие нам однозначно говорит,
[02:56.000 --> 03:00.320]  что там ничего не было, там все нули. Ну давайте так и сделаем. Давайте изначально заведем только
[03:00.320 --> 03:06.200]  корень, давайте на всем нашем большом массиве. Изначально заведем только корневую вершину,
[03:06.200 --> 03:15.560]  скажем, что она отвечает подотрезку всего массива от 0 до 1-1, ну и скажем, что в ней сумма 0.
[03:15.560 --> 03:27.840]  Вот. А левого правого сына этой вершины просто нет. Левого правого сына нет. Ну и дальше,
[03:27.840 --> 03:32.040]  когда будут поступать какие-то запросы, типа там обновление в точке, нам надо будет,
[03:32.480 --> 03:36.840]  обновление в точке просто, надо от корня дойти до того самого листа, где хранится значение.
[03:36.840 --> 03:42.120]  Давайте просто встанем в корень, ну и вот пойдем по тому пути, который надо. Если в какой-то
[03:42.120 --> 03:46.220]  момент я пытаюсь перейти в вершину, которой нет, которую я еще не создал, ну давайте ее создадим,
[03:46.220 --> 03:50.600]  мы и так понимаем, что там как бы 0, ее можно в любой момент создать, если надо, и пойдем дальше
[03:50.600 --> 03:55.420]  просто. Так до листа спустимся. В момент, когда я пытаюсь перейти в еще не созданную вершину,
[03:55.420 --> 04:00.780]  я всегда могу ее создать, сказать, что там сумма нулевая, ну и пойти дальше в ее поддерево,
[04:00.780 --> 04:05.580]  туда, куда нужно. Вот такая очень простая идея. Просто давайте не хранить то, к чему
[04:05.580 --> 04:08.700]  еще не было никаких обращений. Вершины, в которых мы еще не бывали,
[04:08.700 --> 04:12.020]  давайте их просто не хранить.
[04:13.900 --> 04:19.420]  Но они изначально все нули, поэтому их можно не хранить. Мы скажем, что у нас
[04:19.420 --> 04:23.260]  такое соответствие, что если вершина еще не существует, значит к ней не было
[04:23.260 --> 04:26.420]  запросов, значит сумма по дереве ноль. Ну и соответственно это для листьев тоже
[04:26.420 --> 04:30.500]  верно. А если нам нужно что-то в листике поменять, ну давайте встанем в корень,
[04:30.500 --> 04:34.700]  пойдем по той веточке, которая надо, чтобы дойти до того самого листа, ну и по
[04:34.700 --> 04:37.780]  дороге все вот эти вот вершины создадим. Все вершины вот здесь, которые изначально
[04:37.780 --> 04:41.060]  не созданы, давайте их создадим. В частности, создадим вершины, отвечающую
[04:41.060 --> 04:45.580]  листу. Ну и там будет храниться то значение, которое надо.
[04:46.580 --> 04:56.580]  Еще раз? Повторите, пожалуйста. Не понял, лог?
[04:56.660 --> 05:01.860]  А, ну давайте разберемся, как это хранить. Храниться очень просто. Мы заводим
[05:01.860 --> 05:08.620]  структурку, внутри которой, ну соответственно структура вершины какая-нибудь там,
[05:08.620 --> 05:13.220]  структнот. Да, вот черный ящик, который хранит вершину. Что мне нужно хранить
[05:13.220 --> 05:19.460]  в вершине? Давайте хранить координаты контролируемого подотреска. Что я
[05:19.460 --> 05:25.180]  внутри храню? Я храню TLTR, координаты вот эти вот. Я храню сумму в подотреске,
[05:25.180 --> 05:30.940]  и давайте буду хранить указатели на обоих сыновей, левого и правого. Давайте
[05:30.940 --> 05:38.860]  я в C-стиле напишу. Note звездочка left, sun как-нибудь, и note звездочка right, sun.
[05:38.860 --> 05:46.660]  То есть в каком-то смысле буду хранить указатели или какие-то ссылки на
[05:46.660 --> 05:51.300]  детей. По умолчанию детей нет, по умолчанию здесь какие-то там нулевые
[05:51.300 --> 05:56.220]  значения, обозначающие, что просто нет ни того сына, ни другого. И в момент, если
[05:56.220 --> 06:01.540]  мне нужно будет перейти в какого-то из сыновей, если там не нулевой указатель,
[06:01.540 --> 06:06.100]  то я могу в него перейти, я знаю, что это за сын. А если его нет, то я могу создать и
[06:06.100 --> 06:09.540]  сказать, что теперь вот эта вот текущая вершина ссылается в качестве нового сына
[06:09.540 --> 06:14.180]  туда-то. Я создаю новую вершинку и провожу указатель, что вот эта вершина
[06:14.180 --> 06:17.980]  своим левым сыном имеет такую-то вершину. И как раз, если я храню указатель
[06:17.980 --> 06:22.980]  на соседнюю, ну как на какого-то левого сына, я умею с стрелочками переходить.
[06:22.980 --> 06:26.740]  Так же, как у нас было в, ну как бы, как в односвязанном списке у нас было, у нас
[06:26.740 --> 06:30.660]  просто есть стрелочки в следующую вершину. Вот те же самые стрелочки я буду хранить.
[06:30.660 --> 06:35.500]  Стрелку влево, стрелку вправо. По умолчанию они показывают в пустоту, а если есть
[06:35.500 --> 06:39.900]  ребенок, то я его создаю, у меня указатель показывает туда, куда надо. Вот такая идея
[06:39.900 --> 06:44.980]  простая. Вот, давайте напишем какой-нибудь апдейт, например. Как работает апдейт?
[06:48.980 --> 06:56.620]  Ну, там как-нибудь вершину какую-нибудь принимаем. Не знаю, можно по указателю,
[06:56.620 --> 07:02.060]  но не важно. Значит, принимаем позицию, где нужно изменить, и принимаем дельту,
[07:02.060 --> 07:05.660]  на которой, принимаем х, на которой надо увеличивать значение. То есть это я буду
[07:05.660 --> 07:12.300]  делать аппостой, плюс равно х. Вот. Ну, условия выхода из рекурса. Если мы пришли в лист,
[07:12.300 --> 07:17.340]  то надо просто в этом листе сделать плюс равно. И давайте я в любом случае скажу, что v сам,
[07:17.340 --> 07:22.660]  да, все-таки надо по указателю, да, потому что я не хочу копировать эту вершину, я хочу вот ту
[07:22.660 --> 07:27.740]  самую вершину, которая, которая есть в дереве, я в ней хочу какие-то поля менять. Значит, поэтому
[07:27.740 --> 07:35.180]  мне нужно будет вот так вот v сумм плюс равно х сделать, да, то есть я в вершинке v увеличу поле
[07:35.180 --> 07:42.220]  сумм на х. Вот. Если пишите на джаве, то просто точка здесь. Вот это поле этой вершины изменяется
[07:42.220 --> 07:52.260]  на х. Затем, если мы спустились в лист, то можно сделать return. Да, если vtl равно vtr,
[07:52.260 --> 08:00.260]  тогда return. Мы спустились до листа, ниже идти не надо. Ну вот, а иначе понимаем, куда надо пойти в
[08:00.260 --> 08:10.780]  лево или вправо, то есть скажем, как обычно, tm это полусумма координат t или tr, кругленно вниз. Ну
[08:10.780 --> 08:15.340]  и понимаем, что если пост меньше либо равно tm, то надо пойти влево и, если что, лево сына создать,
[08:15.340 --> 08:24.500]  а если больше, то надо пойти вправо и, если что, его тоже создать. Да? Вот, то есть если пост меньше
[08:24.500 --> 08:29.620]  либо равно tm, то значит надо пойти влево, как обычно. Но давайте еще проверим, что левый сын
[08:29.620 --> 08:35.220]  существует, а если не существует, то его создадим, потому что его несуществование просто значит,
[08:35.220 --> 08:40.540]  что к нему еще не было никаких запросов, там ноль, в его всем под дереве ноль, поэтому можно просто
[08:40.540 --> 08:46.020]  завести и все вот эти вот поля, там, сумму поставить нулевой. Ну давайте я не буду писать код, давайте
[08:46.020 --> 08:54.060]  я напишу, что если левого сына нет, то его надо создать. Если левого сына нет, его надо создать.
[08:54.060 --> 09:12.220]  Вот. Ну и просто запускаемся рекурсивно для левого сына, штаб date, where left sun, post x. Вот. Ну и
[09:12.220 --> 09:16.380]  аналогично для права, давайте я не буду писать, там то же самое, только ну как бы здесь будет
[09:16.380 --> 09:20.580]  противоположное условие, если правого сына нет, то его надо создать и спуститься вправо сына.
[09:20.580 --> 09:41.460]  Значит, аналогично для правого сына. Кажется, все. Ну просто else можно писать. Ну да, вообще,
[09:41.460 --> 09:47.100]  если пост больше чем tm, это правда. Ну вот вроде все, как обычно дерево отрезков, прям вообще
[09:47.100 --> 09:53.460]  полностью. Только давайте не хранить вершины, к которым еще не поступало запросов. Если мы в них
[09:53.460 --> 09:57.700]  не были, мы не храним. А если хочется, да, вот в момент, если мне хочется пойти в левого сына,
[09:57.700 --> 10:02.380]  которого еще не существует, давайте его создадим. Благо мы знаем, какие у него все параметры. Мы
[10:02.380 --> 10:07.820]  знаем, какой подотрезок он контролирует, стл птм в этом случае. Мы знаем, что там сумма нулевая,
[10:07.820 --> 10:12.420]  потому что запросов не было. Ну и по умолчанию у него ни левого ни правого сына нету, потому что это
[10:12.420 --> 10:22.780]  как бы пустая вершина, в ней ничего нет. И детей тоже нет. Все. Согласны? Вот, хорошо. Давайте скажем,
[10:22.780 --> 10:31.500]  что это работает за log n времени и log n памяти. Ну log n времени понятно, потому что просто спуск
[10:31.500 --> 10:38.020]  в дереве. Но по пути в худшем случае, я посещаю логарифмическое количество вершин, и в худшем
[10:38.020 --> 10:44.500]  случае мне их все нужно создать. Поэтому вот здесь вот может потребоваться заведение, создание еще
[10:44.500 --> 10:53.460]  логарифмического количества новых вершин. То есть, возможно, плюс от log n до памяти. В отличие от
[10:53.460 --> 10:57.860]  обычного стандартного деревоотрезков, мне здесь приходится создавать новые вершины, у меня выделяется
[10:57.860 --> 11:03.940]  новая память в процессе обработки апдейта. Поэтому здесь надо учитывать, что память выделяется.
[11:04.580 --> 11:17.060]  Я создаю сыновей, поэтому память я из системы забираю. Ну вот. Ну, понятно. Ну, хорошо. С гетсамом
[11:17.060 --> 11:24.140]  не сильно хитрее. Гетсам делается так же, как в обычном деревеотрезков. Только можно даже сделать
[11:24.140 --> 11:28.580]  так. В момент, когда мы пытаемся спуститься в вершину, которой нет, вот, например, как в этом
[11:28.580 --> 11:33.140]  случае, я пытаюсь пойти в левого сына, а левого сына нету. Можно просто туда не идти, потому что
[11:33.140 --> 11:38.660]  если левого сына нет, то на самом деле это означает, что там все нули. В его подделе все нули. И если
[11:38.660 --> 11:43.140]  я хочу узнать там сумму с какого-то подотрезка, то я автоматически знаю, что он нулевая. Если там
[11:43.140 --> 11:47.780]  ничего не происходило, там все нули. Сумма автоматически с любого подотрезка нулевая. Поэтому
[11:47.780 --> 11:54.980]  когда мы пишем get some, надо сделать проверку, что, если мы хотим пойти в левого сына и он есть,
[11:54.980 --> 12:00.340]  тогда переходим. Иначе просто его скипаем, потому что если левого сына нет, то там сумма ноль. Вот.
[12:00.340 --> 12:03.180]  Там даже никаких новых вершин заводить не нужно,
[12:03.180 --> 12:08.180]  там просто это делается за логарифом времени, что
[12:08.180 --> 12:12.500]  отлоган времени, ну и без ду памяти.
[12:12.500 --> 12:19.260]  То есть там что-то тратится на стек рекурсии и так
[12:19.260 --> 12:23.780]  далее, но новых вершин в дереве не создаётся.
[12:23.780 --> 12:28.140]  С точки зрения структуры у меня ничего не увеличивается,
[12:28.180 --> 12:29.740]  я так вольно напишу, что без ду памяти.
[12:29.740 --> 12:41.900]  Мы ничего не удаляем, если вершину создали, то она у нас есть, мы ничего не удаляем.
[12:41.900 --> 12:45.340]  Единственное в самом конце, когда у нас закончилась обработка всех запросов,
[12:45.340 --> 12:49.620]  тогда чтобы память у нас не утекла, надо всё дерево очистить, ну просто все вершинки удалить.
[12:49.620 --> 12:54.140]  А до этого момента мы ничего не удаляем, вот если вершина создалась, значит она есть,
[12:54.700 --> 12:58.620]  для неё всё корректное будет, у неё будут корректные поля ТЛТР, у неё всегда будет
[12:58.620 --> 13:02.260]  корректная сумма, у неё будут какие-то указатели лево-направо, мы её никогда не удаляем,
[13:02.260 --> 13:04.820]  кроме вот в самом конце, когда заканчиваем обработку всего.
[13:04.820 --> 13:09.380]  Так у нас какой-то момент памяти сломается, мы же не сможем создать всё дерево?
[13:09.380 --> 13:18.220]  Ну, тогда мы не сможем сломать дерево, если у нас запросов, типа там, не знаю, очень много, порядка N.
[13:18.220 --> 13:26.980]  Ну, наверное, такого не будет. Ну, скорее всего, имеется в виду, что у вас есть большой массив,
[13:26.980 --> 13:32.300]  и в нём только к какому-то маленькому числу элементов вступают запросы, ну там, не знаю,
[13:32.300 --> 13:38.620]  N10 в 9, а запросов у вас, типа, 10 в 6. Ну и тогда у вас не очень много будет вершин,
[13:38.620 --> 13:43.700]  и с этим можно спокойно работать. Ну а если у вас ко всем элементам появляются запросы,
[13:43.700 --> 13:48.260]  то ничего лучше, чем обычный дерево отрезков, конечно, не получится, если там, не знаю,
[13:48.260 --> 13:52.380]  если запросов столько же, сколько элементов, то в худшем случае у вас всё дерево будет живое,
[13:52.380 --> 13:57.340]  все элементы будут живые, ну ничего лучше, чем явно дерево отрезков хранить, ну как бы не получится.
[13:57.340 --> 14:01.580]  Ну, это и запросов много, а если у вас много запросов, очень много времени на их обработку,
[14:01.580 --> 14:09.620]  ну просто их надо все считать, по крайней мере. Короче, это обычно так не работает.
[14:09.620 --> 14:20.500]  Так, дальше идем? Вот, хорошо. Значит, представьте себе теперь, что у нас можно было бы запросы знать
[14:20.500 --> 14:25.460]  заранее. Вот, то есть сейчас я живу в такой парадигме, что у меня запросы поступают один за другим,
[14:25.460 --> 14:28.580]  и мне нужно в каждом момент времени отвечать на тот запрос, который только что поступил.
[14:28.580 --> 14:33.500]  Пришел запрос, я ответил. Пришел запрос, ответил. Пришел запрос гетсуммы, я запустил процедуру,
[14:33.500 --> 14:38.100]  вывел, что она вывела. Больше ничего не делал, ну как бы, и жду следующую. Вот, а представьте,
[14:38.100 --> 14:46.980]  что если все запросы известны заранее, внезапно. Значит, пусть все запросы известны заранее.
[14:46.980 --> 14:56.500]  Вообще говоря, в реальных задачах это довольно вольное допущение, потому что, ну обычно там вам
[14:56.500 --> 15:00.180]  поступают к вашей структуре какие-то запросы, приходят какие-то пользователи, что-то от вас
[15:00.180 --> 15:04.700]  хотят, вы хотите им как можно быстрее отвечать. Вы не можете сначала дождаться всех запросов от
[15:05.280 --> 15:10.660]  всех пользователей, и потом уже там что-то с ними делать. Обычно вам надо онлайн, но в некоторых
[15:10.660 --> 15:14.340]  задачах, особенно в некоторых подзадачах, можно считать, что запросы есть в оффлайне,
[15:14.340 --> 15:20.780]  например, вы там что-то делаете и вам нужна какая-то вот подпроцедура, которая делает
[15:20.780 --> 15:25.300]  что-то такое. Но при этом вы знаете, какие запросы вы делаете ко всей вашей структуре. Ну вот если
[15:25.300 --> 15:32.700]  у вас какая-то очень большая задача, и вы знаете какие запросы будут поступать к вашей структуре.
[15:32.700 --> 15:35.700]  Ну, бывают такие ситуации.
[15:35.700 --> 15:39.700]  Либо, например, не знаю, у вас какая-нибудь именно,
[15:39.700 --> 15:41.700]  что какой-нибудь офлайновый протокол.
[15:41.700 --> 15:43.700]  Представьте, что у вас есть какой-нибудь сервер,
[15:43.700 --> 15:45.700]  к нему клиенты отправляют свои запросы.
[15:45.700 --> 15:47.700]  Например, какой-нибудь аукцион закрытый.
[15:47.700 --> 15:50.700]  Сначала все клиенты присылают свои ставки,
[15:50.700 --> 15:53.700]  за сколько они готовы купить.
[15:53.700 --> 15:55.700]  Вы все это узнаете, вы все это прочитываете,
[15:55.700 --> 15:57.700]  никакую информацию не публикуете.
[15:57.700 --> 16:00.700]  И потом только после этого на все внезапно как-то отвечаете.
[16:00.700 --> 16:03.700]  Это редко, но бывает, скажем так.
[16:03.700 --> 16:06.700]  Что тогда можно сделать в таком случае?
[16:06.700 --> 16:09.700]  Можно сделать то, что называется сжатие координат.
[16:17.700 --> 16:18.700]  Но это очень простая штука.
[16:18.700 --> 16:20.700]  Давайте мы считаем все запросы,
[16:20.700 --> 16:23.700]  сохраним все те координаты, все те точки,
[16:23.700 --> 16:25.700]  с которыми мы что-то вообще делаем,
[16:25.700 --> 16:28.700]  к которым что-то поступало, какие-то запросы поступали.
[16:30.700 --> 16:34.700]  И на этих координатах построим обычное дерево отрезков.
[16:34.700 --> 16:36.700]  Поскольку координат мало, если мы считаем,
[16:36.700 --> 16:38.700]  что запросов не очень много.
[16:38.700 --> 16:40.700]  Если запросы можно быстро обработать,
[16:40.700 --> 16:41.700]  если их не очень много,
[16:41.700 --> 16:43.700]  то активных координат,
[16:43.700 --> 16:45.700]  активных точек, к которым что-то происходило,
[16:45.700 --> 16:46.700]  будут не очень много.
[16:46.700 --> 16:48.700]  И давайте на них построим обычные дерево отрезков.
[16:48.700 --> 16:51.700]  Например, был у вас огромный какой-то массив,
[16:51.700 --> 16:55.700]  вы считали все запросы, и знаете, что активными,
[16:55.700 --> 16:58.700]  то есть те элементы, в которых хоть что-то будет изменяться
[16:58.700 --> 17:04.460]  это там вот этот, вот этот, вот этот, вот этот и вот этот. Ну, какое-то маленькое подмножество,
[17:04.460 --> 17:10.020]  если запросов мало, то и активных элементов тоже мало. Вот. Тогда давайте просто все перенумеруем,
[17:10.020 --> 17:14.360]  скажем, что это элемент нулевой, это первый, это второй, это третий, это четвертый. Ну, слева
[17:14.360 --> 17:20.060]  направо их занумеруем сплошными целыми числами. Вот. И дальше уже вот на этих пяти элементах
[17:20.060 --> 17:25.540]  построим обычное деревоотресков, и потом будем отвечать на все запросы используя маленькое такое
[17:25.540 --> 17:33.780]  удобное деревоотресков. Вот. Такая идея. Значит, это можно спокойно реализовать. Ну, давайте я сделаю
[17:33.780 --> 17:41.500]  что-нибудь, например, такое. Давайте я заведу массив, не знаю, какой-нибудь координаты. Да,
[17:41.500 --> 17:48.820]  это список вот всех тех позиций, вот на запросы pos, на запросы обновления в точке, которые
[17:48.820 --> 17:54.620]  характеризуются двумя числами pos и x. Давайте все pos я сохранил в какой-то вектор. Значит,
[17:54.620 --> 18:14.980]  cord это список всех значений pos. Всех значений pos по запросам первого типа. Вот. Ну, то есть я
[18:14.980 --> 18:20.740]  просто отчитываю все запросы, все эти pos добавляю в список координат, потом если что сортирую и
[18:20.740 --> 18:26.980]  дубликаты удаляю. Если в какую-то точку несколько раз происходили запросы, то мне достаточно только
[18:26.980 --> 18:32.140]  один раз сохранить, мне нужны ее дубликаты. Она будет по одному разу. Давайте скажем, что
[18:32.140 --> 18:38.580]  удаляем, сортируем, в конце вот этот список сортируем, удаляем дубликаты. Сортируем,
[18:38.580 --> 18:48.380]  удаляем дубликаты. Ну вот. Потом на этих координатах, их вот так вот номируем сплошными
[18:48.380 --> 18:53.860]  числами 0, 1, 2, 3 и так далее. Строим на этих координатах уже новое дерево отрезков, маленькое,
[18:53.860 --> 18:59.460]  обычное. И дальше как обрабатывать запросы. Но если приходит запрос update, то есть мы дальше опять,
[18:59.460 --> 19:04.780]  мы все запросы считали, теперь разрушаемся в начало и начинаем на них отвечать. Если приходит
[19:04.780 --> 19:10.660]  запрос update в точке, то мы сначала понимаем, вот скажем, пришел какой-то pos, нам надо a pos
[19:10.660 --> 19:16.180]  увеличить на x. Давайте сначала с помощью, например, бинарного поиска поймем, какой номер у этой
[19:16.180 --> 19:21.340]  позиции в списке всех координат. Вот не знаю, например, если мне сказали pos вот это вот, то я с
[19:21.340 --> 19:26.460]  помощью бинпоиска всех вот этих точек, ну по этим, по всем этим точкам, знаю, что pos имеет номер 3 в
[19:26.460 --> 19:36.860]  списке координат. То есть, например, если это там, ну давайте напишем 0, 1, 2, 3, 4, 5, 6, 7, 8. Вот.
[19:36.860 --> 19:42.100]  Значит, это все координаты массива. Координаты используемых у меня будут, получается, вот там,
[19:42.100 --> 19:51.500]  где стрелочки. 2, 4, 6, 9, 13. Вот. Если мне приходит обновление в девятой точке, то я с помощью бинпоиска
[19:51.500 --> 19:55.460]  в списке координат нахожу, что девятка находится на третьем месте, значит знаю, что она соответствует
[19:55.460 --> 20:01.900]  третьему элементу в дереве отрезков. И дальше просто запускаю обычный update в элементе 3. Не в
[20:01.900 --> 20:07.260]  девятке, а в тройке, потому что я все перенумеровал. Я сжал, я сжал вот этот большой массив до массива
[20:07.260 --> 20:15.020]  размера 5, и дальше в этом сжатом массиве уже делаю какие-то обновления. Ну окей. Вот. Это будет
[20:15.020 --> 20:23.260]  уже за логарифом от длины вот этого списка сжатого. Ну давайте скажу вот logq. Если всего было q
[20:23.260 --> 20:29.580]  запросов, то максимум q элементов в этом списке, ну и отвечаю я за логарифом, потому что сначала
[20:29.580 --> 20:36.140]  один бинпоиск по вот этому списку, потом за логарифом я в дереве отрезков делаю ответный запрос.
[20:36.140 --> 20:54.500]  Ну вот. А если приходит getSum какой-нибудь, например, давайте напишем. Какой-нибудь getSum 5, 10. Вот. То есть
[20:54.500 --> 21:00.180]  вот на таком отрезке меня просят найти сумму. Ну понятно, тогда как бы меня не интересует все,
[21:00.180 --> 21:05.460]  что слева, все, что справа, и вот эти элементы, которые пустые, их тоже можно отбросить, потому
[21:05.460 --> 21:10.100]  что там и так нули. Значит мы можем найти первый элемент больше либо равной пятерке в нашем списке
[21:10.100 --> 21:17.140]  координат. Это шестерка будет. И последний меньше либо равной десятки. Это будет девятка. И на отрезке
[21:17.140 --> 21:21.540]  между шестеркой и девяткой, то есть на самом деле на отрезке со второго по третий элемент в новой
[21:21.540 --> 21:27.180]  номерации, я делаю запрос на getSum. Потому что как бы все элементы от пятого до шестого мне не
[21:27.180 --> 21:32.220]  интересны, потому что там не было запросов, они нулевые всегда. Все элементы с девятого по десятой
[21:32.220 --> 21:36.620]  тоже пустые, ну как бы здесь не было запросов, там ноль. Я их могу смело отбросить, искать сумму
[21:36.620 --> 21:42.740]  только вот на этом отрезке, но это отрезок между вторым и третьим элементом. Соответственно опять я
[21:42.740 --> 21:49.180]  делаю два бинпоиска, сдвигаю границы вот это вот пять до шестерки, десять до девятки, определяю в
[21:49.180 --> 21:53.420]  каких-то позициях находится 2 и 3, дальше getSum на отрезке 2 и 3 в маленьком дереве отрезков.
[21:53.420 --> 22:12.500]  Нормально? Ну хорошо, да. Массив очень большой, его нет в памяти, но он нулями изначально заполнен.
[22:12.500 --> 22:29.580]  Дальше те, к которым поступали какие-то запросы обновления, мы только на них храним DO. Так, ну вот
[22:29.580 --> 22:34.460]  такие дела. То есть если внезапно у вас запрос известен заранее, то можно не писать вот такую
[22:34.460 --> 22:40.820]  более тяжеловесную структуру, можно не заводить отдельный класс для вершинки, можно написать
[22:40.820 --> 22:46.460]  обычные DO, которые мы делали в прошлый раз. Но это работает быстрее, потому что, ну по крайней
[22:46.460 --> 22:51.140]  мере у вас логарифм от другой величины. У вас здесь был логарифм от n, где n это длина исходного
[22:51.140 --> 22:55.780]  массива, а здесь логарифм q, где q количество запросов. Но если там q сильно меньше чем n, то это выгоднее.
[22:55.780 --> 23:14.180]  Хорошо. Так, ладно. Теперь давайте поговорим про персистентность.
[23:14.180 --> 23:33.460]  Дальше GetSum в обычном дереве отрезков запускаем. Да, мы нашли элементы, но мы знаем их номера в
[23:33.460 --> 23:42.660]  списке координат. Ну окей, давайте другой пример. Вот не 5, 10. Давайте что-нибудь поинтереснее возьму.
[23:42.660 --> 23:51.180]  Давайте 3, 12. Вот такой большой отрезок с этого по вот этот вот. Значит, я бинпоиском определяю
[23:51.180 --> 23:57.620]  наименьшее число большей и равной тройки. Это вот это вот. И наибольший и не большее 12. Это вот это
[23:57.620 --> 24:03.060]  вот. Ну то есть, грубо говоря, я вот на отрезке с 3 по 12 нашел первый активный элемент слева и
[24:03.060 --> 24:09.780]  последний справа. Вот. Значит, я знаю, что вот они. Я знаю их номера в списке вот этом вот. Ну значит,
[24:09.780 --> 24:15.580]  это 1, это 3. И дальше в обычном дереве отрезков запускаем GetSum на отрезке с 1 по 3 элементов.
[24:15.580 --> 24:20.580]  Ну потому что это отрезок с 1 по 3 элементов в вот этом вот сжатом массиве. Когда я все вот эти
[24:20.580 --> 24:25.340]  нули выкинул нафиг. Когда вот этого всего нет. У меня есть только 1, 2, 3 на этом отрезке. Я на
[24:25.340 --> 24:36.300]  отрезке с 1 по 3 элемент суммирую. Потому что все остальные выкинул. Сжал. Дальше персистентные
[24:36.300 --> 24:56.060]  структуры данных. Персистентные структуры. Значит, персистентность означает, что структура в
[24:56.060 --> 25:05.940]  каком-то виде хранит информацию обо всех своих предыдущих версиях. Хранится информация обо
[25:05.940 --> 25:17.460]  всех предыдущих версиях. То есть на примере дерева отрезков у нас там изначально какие-то
[25:17.460 --> 25:23.340]  элементы. Потом постепенно происходит запрос изменения. И вот мне хочется иметь, если что,
[25:23.340 --> 25:28.460]  иметь доступ ко всем предыдущим версиям. То есть если надо, я должен уметь откатываться
[25:28.460 --> 25:34.300]  к какой-то прошлой и той версии. То есть у меня было изначальное ДО. Потом что-то изменилось один
[25:34.300 --> 25:38.740]  раз, второй раз, третий раз и так далее. И вот если что, я хочу уметь откатываться к какой-то старой
[25:38.740 --> 25:44.060]  версии. Не знаю, второй, например. Или не откатываться, а просто что-то про нее узнавать. Вот что было в
[25:44.060 --> 25:51.220]  момент времени тогда-то-тогда-то. Как выглядел дерево. Вот. Ну, например, просто система контроля
[25:51.220 --> 25:56.620]  версии какая-нибудь. Вам надо делать какие-то комиты, вам надо изменять какой-то код, вы многократно
[25:56.620 --> 26:00.860]  делаете какие-то правки, у вас сохраняются все эти изменения. И вы, если надо, имейте доступ ко
[26:00.860 --> 26:10.700]  всем вот этим вот предыдущим версиям. Вот то же самое. Так, ну давайте начнем, например, с массива.
[26:10.700 --> 26:34.140]  Сейчас. Момент. Ну ладно. Ну представьте себе, был какой-то массив изначально. 0, 1 и так далее,
[26:34.140 --> 26:42.540]  а не минус 1. Давайте следующие очень простые два типа запросов сделаем. Значит, во-первых,
[26:42.540 --> 26:50.620]  это обновление, ну изменение какого-то элемента в момент времени t. Ну давайте скажем, или давайте
[26:50.620 --> 27:00.780]  в этой версии вот так. Значит, у меня поступают v, pos и x. Мне нужно заменить post элемент на число
[27:00.780 --> 27:15.700]  x, где v это новый номер версии. Новый номер версии. Ну то есть у меня все версии нумерованы вот это,
[27:15.700 --> 27:18.740]  скажем, нулевая, потом первая, вторая, третья, четвертая и так далее, и вот эти v идут в порядке
[27:18.740 --> 27:24.060]  возрастания. Все в новой, то есть я создаю новую версию массива, как бы копирую всю старую информацию
[27:24.060 --> 27:29.380]  в новый массив, и в новом выполняю присваивание posто равно x. То есть v у меня каждый раз увеличивается
[27:29.380 --> 27:41.820]  на единичку. Все новые и новые версии добавляются. Ну это правда, конечно. Я просто подчеркиваю,
[27:41.820 --> 27:47.300]  что каждый раз создастся новый массив, и его номер это вот его версия номер v. Это можно
[27:47.300 --> 27:51.260]  не передавать, можно локально, ну в смысле внутри программы хранить. Просто я хотел подчеркнуть,
[27:51.260 --> 28:15.940]  что вот есть какой-то номер v у каждой версии. Так, сейчас, момент. Это чуть сложнее делать.
[28:15.940 --> 28:23.100]  Давайте покажите в идее, что у меня, ну как бы, вот есть один массив, он постепенно как-то меняется.
[28:23.100 --> 28:26.980]  Вот была первая версия, ну не знаю, что Вы соцзакомители, у Вас поменялся код на такой-то,
[28:26.980 --> 28:30.580]  массив стал таким-то, потом такой-то массив, такой-то массив, и так далее. То есть он меняется
[28:30.580 --> 28:37.740]  непрерывно версия к версии, и все, что Вы хотите, это иметь, узнавать какое было значение в старый
[28:37.740 --> 28:45.980]  момент времени в какой-то позиции. Не знаю, там get v pos, это просто вывести значение апостова в этой
[28:45.980 --> 28:59.260]  версии, вывести значение элемента apos в версии v. То есть скорее мы не хотим менять какие-то старые
[28:59.260 --> 29:07.700]  версии, мы хотим, мы хотим просто к ним доступ иметь, и если что, да, то есть не знаю, я смотрю
[29:07.700 --> 29:11.980]  какую-то старую версию своего кода, и если надо, его перекопирую в новый массив, то есть создаю новую
[29:11.980 --> 29:16.140]  версию и в него перемещаю то, что было в старом массиве. Поэтому, как бы, старые версии я менять
[29:16.140 --> 29:20.940]  не хочу, я буду менять только новые, создавать только новые, но имею доступ к старым. Вот так сделаем.
[29:29.260 --> 29:47.220]  Еще раз. Ну, это вопрос про реализацию уже, как мы это будем делать. Давайте скажу, как мы это
[29:47.220 --> 29:54.100]  будем делать. На самом деле, конкретно эту задачу можно решать следующим образом. Давайте просто для
[29:54.100 --> 29:58.900]  каждого элемента хранить список всех его изменений, его истории изменений. Давайте для
[29:58.900 --> 30:14.940]  любого поз храним историю его изменений. Ну, изначально мы знаем, что в нулевой версии каждый
[30:14.940 --> 30:20.940]  элемент имел такое-то значение. Изначально нулевой элемент был такой-то, первый такой-то и так далее.
[30:20.940 --> 30:28.020]  Вот. Что происходит, когда поступает запрос изменения? Ну, очень просто. Меняется один конкретный
[30:28.020 --> 30:33.940]  элемент, и поэтому мы можем сказать, что для постового элемента в его истории появляется новая,
[30:33.940 --> 30:39.540]  не знаю, новая веха. Он изначально был там какой-то, а потом как-то менялся, и вот на в этой итерации
[30:39.540 --> 30:46.340]  его значение поменялось на х. То есть, скажем там, вот этот запрос обрабатывается так, что пост
[30:46.340 --> 30:53.100]  элемент как-то себя вел до этого момента, а потом, в момент времени в, он стал равен х. Давайте я
[30:53.100 --> 31:06.100]  просто такую пару добавлю, что в этой версии, версии номер в, значение стало равно х. Значение
[31:06.100 --> 31:12.740]  стало равно х. Вот. И все. А у остальных элементов, понятно, история не поменялась, потому что они не
[31:12.740 --> 31:17.340]  изменили своих значений. Их история остается такой же, как была, я их просто не меняю. То есть,
[31:17.340 --> 31:22.380]  на самом деле, я просто буду для каждого элемента поз, для каждого индекса массива хранить список
[31:22.380 --> 31:30.580]  пар, ну это массив пар, вектор пар, вектор пар, момент времени, в который произошло изменение,
[31:30.580 --> 31:36.340]  и на какое значение поменялось, собственно, это число. Когда произошло изменение, и на какое
[31:36.340 --> 31:41.500]  значение произошло изменение. Вот. И все. Поэтому, соответственно, это я буду обрабатывать просто за
[31:41.500 --> 31:46.100]  единицу, pushback-ая соответствующий вектор правильную пару, потому что в такой-то версии значение
[31:46.100 --> 31:54.500]  поменялось на х. А для ответа на такой запрос, я смотрю на список, соответствующий постому
[31:54.500 --> 32:00.660]  элементу, и мне что нужно смотреть? Ну вот, пост и элемент имеет какую-то историю. На что изначально
[32:00.660 --> 32:06.260]  в нулевой версии он был, скажем, равен х, потом, не знаю, в четвертой версии стал равен y, в десятой
[32:06.260 --> 32:13.940]  стал равен z, в какой-нибудь шестнадцатой стал равен a. Так, a занято, b. Ну вот, короче, какая-то
[32:13.940 --> 32:19.020]  история, что в какие-то моменты времени он менял свои значения. И меня, скажем, спрашивают,
[32:19.020 --> 32:24.740]  а чему равно апостол в момент времени 8? Ну вот, какое было его значение в восьмом момент времени?
[32:24.740 --> 32:32.660]  Да, давайте бинпоиском определим наибольшей и меньшей равной в. В нашем случае это будет вот
[32:32.660 --> 32:37.580]  эта вот четверка. То есть у меня можно запустить бинпоиск по первым элементам пар и понять,
[32:37.580 --> 32:42.820]  что на четвертой, как бы в четвертой версии значение было равно y, потом оно не менялось
[32:42.820 --> 32:47.860]  вплоть до десятой итерации, и только на десятом шаге, в десятой версии его значение стало равно z.
[32:47.860 --> 32:53.020]  Но поскольку восьмерка меньше, чем десять, то оно еще не успело поменяться с y на z,
[32:53.020 --> 32:59.060]  поэтому ответ это просто y. То есть формально для каждого в, точнее для поступающего в,
[32:59.060 --> 33:09.300]  мне нужно найти последний номер версии не больше, чем в. Потому что если в этой
[33:09.300 --> 33:14.380]  версии он поменялся, то надо в включительно. Последний номер версии не больше, чем в,
[33:14.380 --> 33:19.220]  и вывести вот второй элемент этой пары. То есть на таком-то шаге оно поменялось на данное
[33:19.220 --> 33:23.820]  значение, и потом уже не успеет поменяться, до в этой версии дальше изменений не будет,
[33:23.820 --> 33:27.780]  только когда-то в будущем они будут, но до этого момента еще нас не спрашивают. У нас v меньше,
[33:27.780 --> 33:35.660]  чем следующий. Ау? Ну конечно, я просто для каждого пост храню вот такой вектор пар. Для каждого
[33:35.660 --> 33:43.220]  поста я храню историю в виде вектора пар. Вот это вот, это вектор пар. Вектор, но вектор,
[33:43.220 --> 33:50.140]  который pushback в конец умеет, то, что у нас было, добавлять новый элемент в конец. Когда приходит
[33:50.140 --> 33:55.380]  такая штука, я просто в соответствии вектор pushback au, номер версии, новое значение, а когда приходит
[33:55.380 --> 34:02.060]  запрос get, я делаю bin поиск в соответствующем векторе и понимаю, какое изменение предшествовало
[34:02.060 --> 34:08.740]  в этой версии, соответственно, какое значение в этом элемент. Кажется, все. Значит, тогда эта штука
[34:08.740 --> 34:14.060]  работает за единичку, давайте здесь напишем, вот эта единичка, потому что просто pushback,
[34:14.060 --> 34:21.060]  ну амортизировано, потому что pushback работает на самом деле за амортизированную единицу. Давайте
[34:21.060 --> 34:29.260]  так для красцы напишем, для точности вернее. Вот, ну а здесь просто логарифм. Причем логарифм от чего?
[34:29.260 --> 34:36.660]  Ну, в каком-то смысле, да, давайте напишу логарифм q, где q это общее количество запросов,
[34:36.660 --> 34:44.940]  вот так. Или скажем, ну то есть, не обязательно лог v, потому что если v маленькая, то у нас
[34:44.940 --> 34:49.500]  bin поиск по большому массиву, не совсем лог v, скорее именно лог q, где q это общее количество
[34:49.500 --> 35:00.460]  запросов. Потому что в худшем случае у меня история одного элемента может иметь длину q,
[35:00.460 --> 35:10.500]  и я вот на массиве длины q делаю bin поиск. Поэтому лог q. Потому что здесь на самом деле pushback,
[35:10.500 --> 35:17.260]  pushback вектор работает только за учетную единицу, а не за чистую, поэтому по этому звездочку. Да,
[35:17.260 --> 35:22.300]  да, да, потому что там внутри какой-то массив, его в худшем случае надо в два раза расширять,
[35:22.300 --> 35:34.060]  да, и поэтому это учетно только. Вот. Так, понятно с массивом? Знаю как хранить. Хорошо,
[35:34.060 --> 35:48.540]  теперь давайте попробуем перстентный stack придумать. Перстентный stack. Честно говоря,
[35:48.540 --> 35:53.620]  я не уверен, что получится, ну ладно, давайте попробуем. Мне просто пришло в голову, почему бы
[35:53.620 --> 36:21.180]  нет. Справедливо, да.
[36:23.620 --> 36:48.580]  Таким мы не будем заниматься, конечно. Сейчас, один момент. А, понятно, почему. Да. Какую хранить
[36:48.580 --> 36:54.460]  информацию? Ну вообще, что умеет делать stack? Он умеет там типа push, pop и top узнавать, да, ну
[36:54.460 --> 37:02.380]  и видимо надо добавить запрос типа top в этой версии. То есть это функционально как у обычного stack,
[37:02.380 --> 37:07.220]  только еще с доступом к информации про предыдущей версии. Вся информация, только только top у меня
[37:07.220 --> 37:17.580]  может быть. Да. Справедливо, можно здесь вместо q написать количество запроса типа get. Да, это
[37:17.580 --> 37:23.540]  правда, но q это оценка сверху, поэтому лог q общая, можно написать точнее, что q, qget можно так написать.
[37:23.540 --> 37:30.380]  Вы правы, да. Будет лучше оценка, но как бы зависит от задачи, мы как бы априори не можем сказать,
[37:30.380 --> 37:34.740]  сколько будет таких запросов, сколько таких, возможно их примерно поровну, и эта оценка нам
[37:34.740 --> 37:38.380]  не улучшит ничего особенного. Если у вас q в два раза уменьшится, то то же самое будет.
[37:38.380 --> 38:01.700]  В каком смысле, да, только даже можно без поисков. Смотрите, что можно сделать, можно на самом деле
[38:01.700 --> 38:08.820]  просто каждый раз не stack топов, а скорее список топов, ну вектор топов будем хранить. Да, то есть
[38:08.820 --> 38:14.780]  смотрите, вот если я stack храню в виде списка, как обычно, например, у меня stack в таком виде хранится,
[38:14.780 --> 38:20.100]  вот здесь вот дно, вот здесь вот топ, куда элементы добавляются, откуда они удаляются и считываются.
[38:20.100 --> 38:27.220]  Значит, можно что сделать? Давайте мы просто будем хранить список всех вот этих вот верхних
[38:27.220 --> 38:33.700]  элементов. Тогда как обрабатывать новый запрос? Если у меня топ удаляется, то есть происходит
[38:33.700 --> 38:40.940]  операция pop, тогда у меня новым топом становится вот это, я его добавляю в вектор топов. Давайте храним
[38:40.940 --> 38:52.300]  список топов. Что происходит, если происходит запрос pop? У меня верхний элемент удаляется,
[38:52.300 --> 38:58.140]  новым топом становится его сын, и вот его, то есть это удаляется, топом становится этот товарищ,
[38:58.140 --> 39:13.220]  мне нужно его добавить в список. Надо добавить новый топ в список. То же самое значит с запросом
[39:13.220 --> 39:19.340]  на самом деле push. Если какой-то новый элемент добавляется в качестве нового топа, то его надо
[39:19.340 --> 39:29.260]  добавить в список топов. То же самое. Теперь как отвечать на запрос get топ в какой-то версии? У
[39:29.260 --> 39:35.900]  нас есть список всех всех версий, они занумерованы числами 1, 2, 3 и так далее, и мне нужно просто
[39:35.900 --> 39:41.940]  как бы посмотреть на значение в этого элемента. У меня как раз они все хранятся, у меня все топы
[39:41.940 --> 39:47.660]  хранятся у всех версий стеков, которые были за все время работы программы, у меня хранятся
[39:47.660 --> 39:54.020]  указательно все вот эти вот топы во все времена, во все моменты истории. Я знаю в каждом момент
[39:54.020 --> 40:01.420]  времени, чему равно значение в топе. Когда приходит запрос там, не знаю, get топ в момент времени v,
[40:01.420 --> 40:08.220]  я просто смотрю на этот список, смотрю в нем в этот элемент, и это будет ответ. Кажется даже так.
[40:08.220 --> 40:21.020]  Похоже? Да, ну наверное можно было бы и на массиве это сделать. Тогда мы даже больше умеем,
[40:21.020 --> 40:28.060]  получается тогда мы для каждого элемента знаем, то есть как бы если для каждой позиции опять-таки
[40:28.060 --> 40:33.780]  завести список всю историю его изменений, что там нулевой элемент 1, 2, 3 и так далее, историю
[40:33.780 --> 40:37.660]  изменений этого элемента, когда он отсутствует, когда он присутствует с таким-то значением,
[40:37.660 --> 40:42.500]  когда с другим, и там можно было бы тоже пускать bin поиск, но был бы лишний логарифм, потому что
[40:42.500 --> 40:47.820]  здесь мы умеем за единицу отвечать на запросы, просто потому что у нас все топы хранятся в одном
[40:47.820 --> 40:53.580]  массиве в каком-то, и чтобы найти в эту версию, надо просто посмотреть на wet элемент этого списка,
[40:53.580 --> 41:07.580]  этого массива. Нет, потому что если у нас какой-то элемент был топом там в какой-то
[41:07.580 --> 41:14.540]  в этой итерации, у вас есть для этого элемента его история всех изменений, когда он был какой,
[41:14.540 --> 41:19.980]  когда его не было, когда он был x, когда он был y и так далее, его надо в этом длинном списке найти
[41:19.980 --> 41:26.100]  его положение в этот момент времени, это bin поиск. Вот, а здесь вроде будет чисто единичка, то есть
[41:26.100 --> 41:31.380]  если хранить, ну грубо говоря, хранить указатели на топы во все моменты времени, тогда мы можем
[41:31.380 --> 41:42.740]  быстренько на все отвечать. Так, нормально? Вот, хорошо, ну и теперь давайте что-то содержательное,
[41:42.740 --> 42:08.740]  персидентное дерево отрезков посмотрим. Вот, значит, ну мы хотим делать, давайте так, опять же,
[42:08.740 --> 42:16.060]  у меня будут запросы обновления, да, update в точке, и с каждым update у меня обновляется номер версии,
[42:16.060 --> 42:19.540]  типа вот у меня была какая-то нулевая версия дерево отрезков, потом пришел первый update,
[42:19.540 --> 42:24.260]  стала первая версия дерево отрезков, пришел еще один update, стал вторая, еще и так далее и так далее. То
[42:24.260 --> 42:29.940]  есть версии у меня меняются с апдейтами, а get some, давайте позволим себе, ну давайте научимся
[42:29.940 --> 42:35.860]  отвечать на get some к любой старой версии. То есть у меня update так и остается, да, update в точке,
[42:35.860 --> 42:41.940]  после запятая x, значит в это время создается новая версия, да, создается новая версия,
[42:41.940 --> 42:53.740]  так же как в массиве, да, у меня при изменении создается новая версия. Вот, а get some пусть научится
[42:53.740 --> 42:58.820]  обрабатывать любые старые версии, то есть get some и передается не только l и r, но и номер версии v,
[42:58.820 --> 43:05.100]  вот. Ну найти сумму в этой версии, найти сумму элемент в этом отрезке в этой версии DO.
[43:05.100 --> 43:13.460]  А в чем у вас отложенная операция заключается?
[43:13.460 --> 43:34.060]  Это может, непонятно как это делать, на самом деле. Мне кажется, что нет, потому что, да, ну список
[43:34.060 --> 43:41.380]  изменений в подделье, да, как бы. Или так, да.
[43:43.460 --> 43:50.220]  Да, хорошо, но это будет тогда лог квадрат, да, в худшем случае?
[43:50.220 --> 44:02.660]  Ну да, то есть естественно у меня будет логарифом вершин в DO, которые я рассматриваю в каждой,
[44:02.660 --> 44:07.180]  я еще запускаю один поиск, это лог квадрат. Вот, причем это, наверное, не оптимизится,
[44:07.180 --> 44:12.820]  потому что у меня неизвестны заранее запросы, и там трюк, как во Fractional Cascading не пройдет,
[44:12.820 --> 44:17.460]  чтобы до логарифма это уменьшить. Наверное, будет лог квадрат. Но в целом, да, то есть можно применить
[44:17.460 --> 44:21.460]  то же самое. Можно в каждой вершине хранить историю изменения, изменения суммы в ней,
[44:21.460 --> 44:26.380]  и делать те же самые бинарные поиски в каждой вершине. Но это лог квадрат, давайте так не будем.
[44:26.380 --> 44:32.860]  Давайте мы сделаем что-то поэффективнее с точки зрения времени. А именно, ну давайте мы просто
[44:32.860 --> 44:40.260]  будем, когда что-то в вершине изменяется, давайте мы вместо изменения значений в вершине,
[44:40.260 --> 44:44.860]  давайте создадим новую вершину просто. И в ней сохраним всю информацию, которая должна быть.
[44:44.860 --> 44:50.060]  Вот, например, было какое-то изначальное дерево отрезков. Правильная DO, нулевая версия DO.
[44:50.060 --> 44:55.660]  Дальше мне приходит запрос апдейта, и мне нужно, скажем, вот на таком-то пути конкретном каком-то,
[44:55.660 --> 45:00.260]  во все элементы поставить сумму плюс х. То есть апдейт в этой точке прошел на х,
[45:00.260 --> 45:05.580]  у меня все вот эти вот суммы на этом пути увеличиваются на х. Тогда что я сделаю?
[45:05.580 --> 45:11.460]  Давайте я просто возьму, продублирую этот путь, создам новые вершины, вот ровно такой же структуры,
[45:11.460 --> 45:18.980]  отвечающие этому пути. В этом DO я ничего менять не буду, я поменяю только на новом пути,
[45:18.980 --> 45:25.700]  во все эти вершинки поставлю плюс х. То есть я только в новых вершинах увеличу значение суммы на х.
[45:25.700 --> 45:33.580]  Вот, и дальше смотрите, у меня был изначальный корень, давайте его назову root 0, изначальный
[45:33.580 --> 45:40.420]  корень моего деревоотресков. И теперь появляется новый root 1, новый корень деревоотресков вот с уже
[45:40.420 --> 45:47.180]  этим обновлением, с изменения на этом пути. Причем, смотрите, по большей части эти два дерева должны
[45:47.180 --> 45:52.660]  совпадать, потому что они отличаются только поведением на этом пути. А все остальные вершины,
[45:52.660 --> 45:57.340]  ну как бы было бы очень неразумно просто все остальное копировать сюда. Я не хочу создавать
[45:57.340 --> 46:02.940]  новое DO линейного размера, и все остальные вершины просто тупо копировать. Вместо этого давайте я буду
[46:02.940 --> 46:08.060]  просто ссылаться, что теперь у меня корень, ну скажем вот, если у меня здесь левый сын менялся,
[46:08.060 --> 46:12.780]  то есть если у меня в левом сыне произошло плюс х, то правый у меня остался на месте, остался таким же как
[46:12.780 --> 46:18.060]  был, там значение осталось. Так вот, давайте тогда скажем, что в качестве правого сына вот этого корня
[46:18.060 --> 46:22.900]  выступает правый сын старого корня. То есть у меня вот такой указатель будет вести вот сюда вот.
[46:22.900 --> 46:30.140]  Просто потому что нет смысла все вот это под дерево сюда перекопировать. Я могу явно сказать,
[46:30.140 --> 46:34.900]  что, окей, правое под дерево вот этой штуки такое же, как было вот здесь. То есть по факту просто в
[46:34.900 --> 46:41.140]  качестве правого сына будет выступать правый сын старого корня. И в каком-то смысле я сделал вот
[46:41.140 --> 46:45.940]  то самое перекопирование, ничего не заводя новой память. Я просто сказал, что теперь правым сыном
[46:45.940 --> 46:51.500]  выступает вот этот вот. Ну и там дальше, если мне нужно будет пойти как-то в правого сына, то он как
[46:51.500 --> 46:55.860]  раз переместится сюда и будет вести себя здесь так же как надо. То есть я не копирую, я сделал то,
[46:55.860 --> 47:03.100]  что надо. Да, добился такого же поведения. Ну вот так и будем делать. То есть когда происходит
[47:03.100 --> 47:08.740]  апдейт, я завожу новый корень. То есть я опять буду хранить список корней всех версий DO. Я завожу
[47:08.740 --> 47:13.500]  новый корень. Вдоль того пути, на котором происходят изменения, создаю новые вершины. То есть вместо
[47:13.500 --> 47:18.860]  этих вершин создаю новые. В них делаю апдейт. В них во всех суммы изменяется, делаю в них во всех
[47:18.860 --> 47:25.380]  плюс х. Вот, а все остальные вершины этого дерева соответствуют вершинам вот этого дерева. То есть
[47:25.380 --> 47:30.500]  какие они здесь были, такие они здесь и остаются. Например, вот здесь у этой вершинки левый сын оставался
[47:30.500 --> 47:37.140]  на месте, значит здесь левый сын должен идти на самом деле вот сюда вот. Ну и так далее. Все, короче,
[47:37.140 --> 47:41.700]  вот во всех моментах, когда у меня есть неиспользованный сын, который непонятно какой,
[47:41.700 --> 47:47.500]  я его просто назначаю таким же, как он был в левом дереве, в предыдущем дереве. То есть в момент,
[47:47.500 --> 47:53.060]  когда у вершины скажем вот здесь вот, один сын изменяется на плюс х, а другой надо оставить
[47:53.060 --> 47:57.620]  такой же, как был, давайте просто перенаправлю его на соответствующего сына в предыдущем дереве.
[47:57.620 --> 48:07.900]  Вот и все. То есть у меня опять же будет храниться некая структурка нот, которая хранит указатели на
[48:07.900 --> 48:17.340]  левое правое сына, значит left sun, right sun. Ну и соответственно каждый сын это либо новая вершина,
[48:17.340 --> 48:22.380]  которая отличается от старой добавлением х, либо это указатель на того же самого старого
[48:22.380 --> 48:35.740]  правого сына. Вот здесь вот right sun такой же, как здесь right sun. Еще раз? Код писать в смысле?
[48:35.740 --> 48:43.980]  Не-не-не, у меня нет. Будем прописывать. Right sun у меня все всегда определены. Мы считаем,
[48:43.980 --> 48:50.820]  что здесь массив маленький. У меня как обычное DO, то есть не динамическое. Обычное DO, все у меня
[48:50.820 --> 48:55.100]  вершины определены, у меня нет никаких неопределенностей. И просто в момент,
[48:55.100 --> 49:00.220]  вот когда у вершины скажем, вот я завел новый корень, я понимаю, что изменение поз лежит в
[49:00.220 --> 49:05.420]  левом поддереве. Тогда я просто правого сына копирую отсюда, ну не копирую, а перенаправляю
[49:05.420 --> 49:11.020]  указатель на правого сына вот здесь вот, а в левого рекурсивно запускаюсь и запускаю апдейт от него.
[49:11.020 --> 49:17.740]  То есть я перенаправил этот указатель, ну то есть я его явно прописываю, да, вместо того, чтобы
[49:17.740 --> 49:21.540]  показывать на какую-то новую вершину, он бы показывать туда же, куда показывал раньше,
[49:21.540 --> 49:30.660]  а в левом поддереве я запускаю изменение рекурсивно и делаю там плюс х на пути. Вот, значит,
[49:30.660 --> 49:39.740]  ну тогда соответственно апдейт у меня работает за лог времени, потому что я точно так же просто
[49:39.740 --> 49:47.580]  иду вдоль какого-то пути DO, но опять-таки за плюс логарифм до памяти, потому что мне придется
[49:47.580 --> 49:51.740]  вот, ну как бы я этот путь перекопирую и создаю новую вершину в количестве таком же, как было
[49:51.740 --> 50:12.140]  здесь, поэтому я добавляю еще от логен до памяти. Вот. Ну а потом, чтобы отвечать на GetSum,
[50:12.140 --> 50:20.020]  ничего девать не нужно, потому что у меня, смотрите, у меня есть версии. Для каждой версии v у меня есть
[50:20.020 --> 50:25.420]  соответствующая версия корня, то есть у меня есть root 0 для нулевой версии DO, root1 для первой
[50:25.420 --> 50:30.200]  версии, для второй, для третьей и так далее. В каждой версии у меня есть свой корень. Все, что я
[50:30.200 --> 50:35.260]  вижу стоя в соответствующем корне, это его поддерево, то есть здесь, скажем, левый сын, это
[50:35.260 --> 50:40.080]  вот это вот, правый сын, это то же самое, что было в прошлый. То есть вообще говоря, всё его поддерево
[50:40.080 --> 50:45.360]  корректно определено. Поэтому, когда у меня приходит запрос getSum в lr, я просто встаю в
[50:45.360 --> 50:51.080]  этой корень и запускаю там обычный getSum lr. Потому что у меня корректное DO, у меня корректно
[50:51.080 --> 50:56.320]  определены все левые правые сыновья, и мне нужно в этом дереве отрезков, в этом дереве отрезков,
[50:56.320 --> 51:00.280]  найти сумму на отрезке с lpr. Но это, я вам и даю, это обычный запрос к DO. Да.
[51:00.280 --> 51:09.280]  А если у нас достаточно большое количество таких версий, и мы раз за разом ссылаемся в каком-то элементе?
[51:09.280 --> 51:19.080]  Это не страшно. Это не страшно, потому что на самом деле, что только ссылаемся. Ну, давайте картинку еще раз нарисуем.
[51:19.080 --> 51:35.320]  Мы ничего ничто? Да, не расходуем. Потому что, вот смотрите, вот было одно DO, было другое. Скажем,
[51:35.320 --> 51:39.880]  пусть изменения происходят только в левом поддереве. Было третье, вот было четвертое. И,
[51:39.880 --> 51:44.240]  например, всегда правый сын у меня один и то же. Правое поддереве у меня, например, не менялось.
[51:44.240 --> 51:49.280]  Тогда как это на самом деле реализовано? Это реализовано так, что просто у меня указатель отсюда
[51:49.280 --> 51:55.080]  на правого сына ведет вот сюда. И, значит, когда я иду отсюда направо, я сразу попадаю сюда.
[51:55.080 --> 52:02.920]  Здесь правый сын у меня, допустим, не изменяется, он указывает вот сюда вот, но что такое это? Это,
[52:03.400 --> 52:11.540]  просто вот это. Они у меня равны. Когда я перехожу в правого сына, это указатель. На самом деле здесь
[52:11.540 --> 52:17.440]  его нет, потому что указатель ведет сразу вот сюда. Дальше я что делаю? Я указываю,
[52:17.440 --> 52:21.960]  что правый сын нового дерева — это то что было правым сыном предыдущего, а правый сын предыдущего
[52:21.960 --> 52:28.340]  вот он. Поэтому я указываю не сюда а сразу вот туда. Вот здесь, тоже самое. Что такое правый сын
[52:28.340 --> 52:33.740]  предыдущего по дереву. Это вот то вот. Поэтому я вот так вот сразу делаю указатель, и у меня как бы
[52:33.740 --> 52:37.860]  переход за единицу именно что? Потому что у меня в правильное дерево оно переходит, и там все это
[52:37.860 --> 52:54.680]  по дереву автоматически рассматривается. Вот. Кажется, все. Так, окей. Давайте с помощью такой
[52:54.680 --> 53:01.360]  штуки вернемся чуть назад, и по-другому решим задачу, которая была про fractional cascading.
[53:01.360 --> 53:13.120]  Напомню задачу. У нас был массив, и мне нужно было находить количество чисел не больше, чем x,
[53:13.120 --> 53:23.800]  на отрезке с L по R. На отрезке с A L по A R. Вот. Значит, это было в конце прошлой лекции. Мы там
[53:23.800 --> 53:29.840]  построили дерево мерч сорта, то есть склеивали, сортировали векторы, объединяли их с помощью мерч
[53:29.840 --> 53:33.960]  в один отсортированный, и там как-то хитрым бинпоиском, храня как-то стрелочек, как-то это
[53:33.960 --> 53:39.800]  за логарифом отвечали. Теперь давайте применим персидентное дерево отрезка, решим ту же задачу,
[53:39.800 --> 53:46.760]  ну чуть-чуть меньше подумав, скажем так. Писать, наверное, здесь побольше, потому что вот с этими
[53:46.760 --> 54:01.800]  указателями надо возиться, но думать меньше. Так. Ну давайте я сделаю следующее. Давайте,
[54:01.800 --> 54:17.240]  значит, шаг нулевой, я все элементы убью. Что бьем? Все элементы. Дальше я пойду по массиву в порядке
[54:17.240 --> 54:22.320]  возрастания элементов. Сначала найду, где лежит минимум, потом где лежит вторая порядковая статистика,
[54:22.320 --> 54:27.040]  третья, четвертая и так далее, и буду один за другим постепенно оживлять элементы. То есть я
[54:27.040 --> 54:31.560]  сначала оживлю минимальные, потом второй по минимальности, третий и так далее. Дальше, значит,
[54:31.560 --> 54:49.520]  оживляем элементы по одному в порядке возрастания. То есть, например, если был массив, скажем, 5, 1, 3, 4, 2,
[54:49.520 --> 54:55.680]  то я сначала оживлю единичку, то есть изначально все мертвые, потом единичка живая, потом двойка,
[54:55.680 --> 55:00.720]  вместе с единицей живая, тройка, ну и так далее. Короче, изначально все мертвые, потом иду не слева
[55:00.720 --> 55:08.040]  направо, а в порядке увеличения. Сначала один оживает, потом два, потом три, четыре, пять. Вот. И давайте,
[55:08.040 --> 55:13.960]  значит, я заведу дерево отрезков и в каждой вершине буду хранить количество живых под деревья. В вершине
[55:13.960 --> 55:32.440]  ДО храним количество живых элементов под деревья. То есть изначально все нули, и дальше они постепенно
[55:32.440 --> 55:40.560]  превращаются в единички. Один ожил, сделал плюс один на пути, второй ожил плюс один на пути и так далее. Вот.
[55:43.960 --> 55:49.360]  Нет, нам обычного хватит, потому что длины Н всего лишь, и у меня все элементы оживут, поэтому динамическая
[55:49.360 --> 55:56.320]  бессмысленно. Потому что они все равно все оживают, мы ничего не выигрываем за счет динамичности. Вот.
[55:56.320 --> 56:01.880]  Ну и все. И мы сделаем это с помощью персидентного ДО. Значит, это будет персидентное ДО, мы будем помнить
[56:01.880 --> 56:09.720]  все версии. Вот. А дальше очень просто. Приходит запрос, сколько чисел не больше, чем х. Давайте мы
[56:09.720 --> 56:15.800]  с помощью бинпоиска поймем, что за версия в качестве живых элементов содержит только те самые числа,
[56:15.800 --> 56:23.040]  не больше чем х. То есть у меня изначально все мертвы, потом они постепенно оживают один за другим. И вот в
[56:23.040 --> 56:27.720]  какой-то момент, давайте найдем тут момент времени, когда живые это в точности те, которые не больше
[56:27.720 --> 56:35.400]  чем х. Вот есть х. У меня ДО оживает, в ДО элементы оживают один за другим в порядке возрастания. В какой-то
[56:35.400 --> 56:42.120]  момент живые это в точности те, которые не больше чем х. Смотрим в эту версию ДО и изучим суммы на
[56:42.120 --> 56:47.180]  отрезке. Потому что там единички это живые, то есть те, которые не больше чем х, нолики это мертвые те,
[56:47.180 --> 56:51.360]  которые больше чем х. Сумма на отрезке есть количество живых на отрезке, то есть количество тех самых
[56:51.360 --> 56:58.920]  чисел, которые мне надо. То есть. Значит, теперь ответ на запрос. Находим версию,
[56:58.920 --> 57:10.760]  в которой все элементы не больше, чем x живы, в которой живы все не больше, чем x, ну дальше просто
[57:10.760 --> 57:30.960]  get some на треске LR. Get some на треске LR. Все. Ну, бинарным поиском, например. Представьте,
[57:30.960 --> 57:36.560]  что вот у нас есть массив чисел. Что мне, значит, как я делаю вот этот первый шаг? Как я по всем
[57:36.560 --> 57:40.400]  элементам иду в порядке возрастания? Ну, нужно, наверное, этот массив отсердствовать и запомнить,
[57:40.400 --> 57:45.160]  где какой элемент лежал. То есть я все равно знаю, где минимум, где вторая статистика, где третья,
[57:45.160 --> 57:49.520]  и так далее. То есть я этот массив посортировал и знаю, в каком месте каждый элемент лежит
[57:49.520 --> 57:55.040]  относительно исхода нумерации. Дальше, когда приходит x, я просто запускаю бинпоиск по вот
[57:55.040 --> 58:00.320]  этому отсоршенному массиву и понимаю, в каком месте, в какой версии все элементы не больше,
[58:00.320 --> 58:06.720]  чем x живы, а те, которые больше, еще мертвы, а мы их еще не оживили. Ну и, собственно, вот эта
[58:06.720 --> 58:11.320]  версия, мы знаем ее номер, мы знаем номер позиции такой, что вот в этой позиции все не больше,
[58:11.320 --> 58:20.840]  чем x живые. Мы знаем этот номер, мы в этой версии DO делаем запрос. Давайте посчитаем, на самом
[58:20.840 --> 58:32.240]  деле, не очень много. Да. Не, на самом деле, просто n log n и будет. Значит, я утверждаю,
[58:32.240 --> 58:37.200]  что предподсчет у меня работает за n log n, потому что у меня, на самом деле, просто n запросов к
[58:37.200 --> 58:46.960]  DO. Вот таких вот запросов обновлений у меня n, так как всего n апдейтов. Да, у меня изначально все
[58:46.960 --> 58:54.200]  мертвы, потом я n элементов оживляю. Каждый запрос обрабатывается за логарифом, ну при этом,
[58:54.200 --> 58:59.080]  да, еще логарифом n памяти добавляет, потому что я изменяю путь, у меня плюс log n памяти,
[58:59.080 --> 59:08.320]  поэтому здесь n log n времени и n log n памяти. Временней памяти. Ну все, а потом на запрос я за
[59:08.320 --> 59:13.640]  log n просто отвечаю, потому что я сначала бин поиском нахожу x в массиве отсортированном и потом
[59:13.640 --> 59:20.280]  делаю еще за логарифом get some в соответствующей версии DO. Поэтому на запрос я отвечаю за логарифом.
[59:20.280 --> 59:42.840]  На запрос логарифом. Вот, вроде не очень много, не очень страшно. Да. Ну два log n получилось как раз.
[59:42.840 --> 59:51.280]  А у меня версия-то n. А у меня версия столько, сколько элементов в массиве, их n. За log n бин поиск и
[59:51.280 --> 01:00:03.960]  потом еще log n в DO. Все правильно. Вот, понятно? То есть, смотрите, мы как бы в задаче, которое явным
[01:00:03.960 --> 01:00:08.720]  образом не апеллирует к версиям, да, как бы нам, ну тут не написано храните версии какие-то, да, вот
[01:00:08.720 --> 01:00:14.400]  как здесь. Явным образом это написано. Вот, но мы как бы, если что, можем какие-то задачи, используя
[01:00:14.400 --> 01:00:19.440]  персистентное, используя как бы знания о всех предыдущих версиях, можем какие-то другие задачи
[01:00:19.440 --> 01:00:37.640]  решать. Вот так тоже бывает. Так, хорошо. Хорошо. Ну давайте такую еще вариацию посмотрим. Давайте
[01:00:37.640 --> 01:00:53.740]  посмотрим на двумерное дерево отрезков. Задача аналогична одномерной, когда у нас есть массив,
[01:00:53.740 --> 01:01:00.320]  только теперь у нас есть табличка. Скажем, у нас есть квадратная табличка чисел n на n.
[01:01:00.320 --> 01:01:07.640]  Вот здесь стоят какие-то числа. Табличка n на n. Она изначально заполнена числами, скажем там,
[01:01:07.640 --> 01:01:13.360]  а и та житая, и поступает также два запроса. Update в точке, то есть надо поменять конкретно а и та житая
[01:01:13.360 --> 01:01:19.600]  на что-нибудь. И второе, но если раньше была сумма на подотреске, то теперь естественно сделать
[01:01:19.600 --> 01:01:25.280]  сумму на подматрице, на подпрямоугольнике. Ну то есть скажем, найдите, пожалуйста, сумму вот в
[01:01:25.280 --> 01:01:35.440]  таком вот прямоугольнике. Ну просто об общении на двумерный случай, скажем так. Ну не обязательно,
[01:01:35.440 --> 01:01:40.880]  в общем случае может любой прямоугольник быть. Ну давайте что, вот что-то такое может быть. Любой
[01:01:40.880 --> 01:01:50.240]  прямоугольник. Вот, то есть у меня есть update в точке, update в точке и get sum на прямоугольнике,
[01:01:50.240 --> 01:02:06.040]  скажем так. Get sum на прямоугольнике. Вот. Да, да, да. Прямоугольник задан координатами там своих
[01:02:06.040 --> 01:02:11.600]  концов. Лево, верхне, право, нижне надо найти на нем сумму, да. Вот, ну смотрите, поскольку у меня
[01:02:11.600 --> 01:02:16.280]  здесь вход уже имеет размер n на n, то есть у меня есть такая квадратная табличка, я считаю,
[01:02:16.280 --> 01:02:21.960]  что они все какие-то изначально имеют какие-то значения, то есть в них во всех что-то изначально
[01:02:21.960 --> 01:02:27.040]  записано. Ну поэтому как бы у меня уже будет квадрат в симптотике, хочешь не хочешь. У меня там
[01:02:27.040 --> 01:02:30.960]  есть матрица квадратного размера, поэтому мы сейчас будем работать за что-то типа n в квадрате,
[01:02:30.960 --> 01:02:40.200]  умноженными кинтлагарифмами. Вот. Ну идея на самом деле очень прозрачная. Мы сделаем дерево отрезков
[01:02:40.200 --> 01:02:46.160]  по одной координате, скажем. Давайте я введу какую-нибудь здесь нумерацию. Например, вот так вот.
[01:02:46.160 --> 01:02:55.240]  Скажем x, это скажем y. А нет, не хочу. Давайте обычные ивклидово введу. Вот здесь вот x,
[01:02:55.240 --> 01:03:03.960]  вот здесь вот y. Вот. Смотрите, по x-ам у меня есть нумерация столбцов 0, 1, 2 и так далее, n-1.
[01:03:03.960 --> 01:03:11.200]  Давайте я вот на этих столбцах построю дерево отрезков. Что это значит? Как бы в обычной версии
[01:03:11.200 --> 01:03:18.200]  DO, в одномерной, у меня вершина отвечает под отрезку чисел. Теперь, если я строю дерево отрезков на
[01:03:18.200 --> 01:03:23.520]  x-ах, то у меня вершина будет соответствовать под отрезку столбцов. Не под отрезку чисел, а под
[01:03:23.520 --> 01:03:30.920]  отрезку столбцов. Ну вот, например, давайте что-нибудь простое нарисуем. У меня есть 4 столбца. Вот такая
[01:03:30.920 --> 01:03:37.160]  матрица 4 на 4, еще разбитая вот такими горизонтальными тоже линиями. Значит, у меня будет DO,
[01:03:37.160 --> 01:03:46.800]  который выглядит как-то вот так вот. Вот. То есть у меня одна вершина отвечает этому столбцу,
[01:03:46.800 --> 01:03:51.000]  одна вот этому, одна вот этому, одна вот этому. Дальше вершина отвечает вот этим двум столцам
[01:03:51.000 --> 01:03:57.680]  одновременно. Это вот этим двум столцам, а это всем четырем столцам одновременно. Ну то есть,
[01:03:57.680 --> 01:04:04.600]  как одномерно, только на столбцах, скажем так. Каждая вершина теперь отвечает отрезку столбцов,
[01:04:04.600 --> 01:04:13.480]  там с какого-то по какой-то. А дальше давайте мы в каждой вершине вот этого DO, внешнего по x-ам,
[01:04:13.480 --> 01:04:20.480]  что такое вершина DO? Это какой-то отрезок столбцов. Давайте теперь здесь внутри
[01:04:20.480 --> 01:04:28.960]  сделаем внутреннее DO по y-кам. То есть вот у меня вершина DO, давайте я здесь нарисую какая-то вершина,
[01:04:28.960 --> 01:04:35.840]  она отвечает некоторому под отрезку столбцов. Давайте теперь вот на этом отрезке столбцов
[01:04:35.840 --> 01:04:42.600]  построим дерево по y-ку. То есть у меня будет дерево, которое контролирует его вот здесь,
[01:04:42.600 --> 01:04:50.000]  вот сбоку. Давайте опять какой-нибудь пример. Пусть будет здесь четыре элемента. Нет, давайте пять,
[01:04:50.000 --> 01:04:59.600]  раз, два. Вот так. Будут отдельные вершинки, отвечающие вот таким вот строчкам размера 3.
[01:04:59.600 --> 01:05:05.280]  Потом как-то они так вот склеются, например. Вот так вот склеются, например. И вот так вот склеются,
[01:05:05.280 --> 01:05:14.640]  например. Вот. То есть теперь внутри каждой вершины по x-у я храню вложенное такое дерево отрезков на вот
[01:05:14.640 --> 01:05:20.760]  таком вот соответствующем этой вершине отрезку, вот на таком отрезке столбцов. И дальше я опять этот,
[01:05:20.760 --> 01:05:26.320]  как бы рассматриваю это все как некая неделимая, неделимую табличку по x-ам и делю по y-кам. Вот
[01:05:26.320 --> 01:05:31.360]  внутреннее DO в этой точке v будет делить по y-кам. Соответственно, каждая вершина здесь отвечает
[01:05:31.360 --> 01:05:37.960]  некоторому подотреску y-ков. Ну а x у меня фиксирован, да, x от такого-то до такого. Вот. То есть как бы
[01:05:37.960 --> 01:05:43.240]  именно что двумерное дерево отрезков. В каждой вершине DO по x-ам у меня будет храниться DO по
[01:05:43.240 --> 01:05:49.680]  y-кам. То есть я вот некий подотрезок фиксировал, некий подотрезок с x-ин до x-max я вырезал из таблицы,
[01:05:49.680 --> 01:05:55.600]  дальше как бы склеил это все в неделимую штуку по x-ам и дальше режу по y-кам с помощью вот такого
[01:05:55.600 --> 01:06:05.360]  DO горизонтального. Вот. И давайте теперь в каждой вершине вот этого вложенного DO хранить сумму
[01:06:05.360 --> 01:06:11.120]  соответствующего под прямоугольника. То есть здесь будет храниться сумма вот такая, здесь сумма вот
[01:06:11.120 --> 01:06:18.440]  такая, ну и так далее. То есть в каждой вершине внутреннего DO я храню сумму вот с того под
[01:06:18.440 --> 01:06:28.600]  матрицей таблицы, которая ею контролируется. Вот я утверждаю, что такого хватит. Ну почему,
[01:06:28.600 --> 01:06:33.520]  давайте разберемся, как делать апдейт в точке. Что такое апдейт в точке? Вот у меня была какая-то
[01:06:33.520 --> 01:06:44.560]  матрица. Какая-то матрица. Где-то в какой-то точке надо сделать плюс x. Давайте плюс z,
[01:06:44.560 --> 01:06:52.280]  потому что x, y у меня координаты. Я делаю плюс x в точке. Что меняется? Какие вот эти вот вершины,
[01:06:52.280 --> 01:06:59.080]  в каких вершинах происходит изменение? В каких вершинах сумма увеличивается на z? Ну те, которые
[01:06:59.080 --> 01:07:07.120]  и по x-у контролируют вот эту точку. То есть мне нужны такие вершины, которые отвечают отрезку
[01:07:07.120 --> 01:07:13.200]  столбцов, содержащему этот столбец. Вот этот вот. Давайте там. Какой-то иный столбец. То есть мне
[01:07:13.200 --> 01:07:18.640]  нужны все такие вершины. Но мы знаем, что если у меня по x-ам построено дерево отрезков, то все
[01:07:18.640 --> 01:07:25.840]  такие вершины, содержащие конкретный итый столбец, это путь просто от этой точки до корня.
[01:07:25.840 --> 01:07:31.960]  Ну или, например, от корня до итого столбца. Мы знаем, что изменение в дереве отрезков по x-у
[01:07:31.960 --> 01:07:38.640]  происходит только в этом логарифме вершин. От корня до итого столбца. Вот на таком пути.
[01:07:38.640 --> 01:07:45.680]  Вот здесь вот во всех точках надо сделать плюс z в соответствующей координате. Хорошо. То есть у меня
[01:07:45.680 --> 01:07:50.440]  есть логарифмическое количество вершин внешнего DO, которые по x-ам построены. Каждая вершина
[01:07:50.440 --> 01:07:56.600]  внешнего DO это на самом деле DO по y. Вот такое вот. И где-то здесь происходит плюс z. Вот в какой-то
[01:07:56.600 --> 01:08:04.160]  там точке делается плюс z. Значит мне нужно теперь в этом внутреннем DO всем вершинам, которые
[01:08:04.160 --> 01:08:09.640]  содержат эту строчку, сделать плюс z. Ну потому что этот плюс z и так лежит в этой таблице. Мне
[01:08:09.640 --> 01:08:14.960]  нужно во все вершины, контролирующие эту строчку, сделать плюс z. Это вот это, вот это, вот это,
[01:08:14.960 --> 01:08:21.160]  вот это. То есть опять некий путь от корня до житой строки в этот раз. От корня соответствующего вот
[01:08:21.160 --> 01:08:33.240]  это вот дерева до житой строки. Да, да, да. Все правильно. Вот давайте я какие-то слова напишу,
[01:08:33.240 --> 01:08:45.200]  потому что я много говорил. Что-нибудь давайте зафиксируем. Да, да, да, да, все правильно.
[01:08:45.200 --> 01:08:52.160]  Ну давайте пару слов я все-таки зафиксирую. Значит внешнее дерево отрезков по x. Внешнее дерево
[01:08:52.160 --> 01:09:14.880]  отрезков по x. Каждая вершина внешнего DO соответствует внутреннему DO по y. Вот.
[01:09:14.880 --> 01:09:24.900]  Когда происходит апдейт в точке? Апдейт в точке и жи. Апдейт в точке и жи. Ну давайте так в два
[01:09:24.900 --> 01:09:30.480]  этапа и напишу, что сначала я определяю все вершины внешнего DO, которые контролирует
[01:09:30.480 --> 01:09:50.520]  и ты столбец. Определяем все вершины внешнего DO, контролирующие и ты столбец. И потом для
[01:09:50.520 --> 01:09:55.480]  каждой из них переходим в соответствующее внутреннее дерево отрезков, которое свое для
[01:09:55.480 --> 01:10:03.160]  каждой вершины внешнего. И дальше вот в этом внутреннем, в каждом внутреннем делаем, ну обновляем
[01:10:03.160 --> 01:10:09.040]  ответ для всех вершин, контролирующих и житую строчку. Для каждого из них, для каждой из них
[01:10:09.040 --> 01:10:28.920]  в соответствующем DO обновляем ответ для всех вершин, контролирующих и житую строчку.
[01:10:39.040 --> 01:10:47.320]  Вот. Ну из такого описания, кажется, видно, что это работает за лог квадрат, потому что я
[01:10:47.320 --> 01:10:51.600]  сначала выделяю логарифмическое количество вершин во внешнем DO, здесь будет лог вершин. И
[01:10:51.600 --> 01:10:56.720]  дальше для каждой из них, во внутреннем, это еще логарифм. Ну потому что, потому что это путь
[01:10:56.720 --> 01:11:10.160]  от корня до листа. Значит, суммарно это работает за лог квадрат. На запрос типа update. Вот. Согласны?
[01:11:10.160 --> 01:11:23.200]  Супер. Удивительно. Ну ладно. Ну а с get some ничего хитрого нет. Значит, мы знаем, давайте get some.
[01:11:23.200 --> 01:11:34.520]  Ну во-первых, а это неважно, неважно. Но что здесь большая табличка? Мне нужно найти сумму вот на
[01:11:34.520 --> 01:11:42.760]  таком, скажем, прямоугольнике. Давайте я сначала порежу этот прямоугольник на координаты по x,
[01:11:42.760 --> 01:11:48.520]  ну на как бы на подотреске по x. Вот у меня есть координата x. Я знаю, что если я смотрю,
[01:11:48.520 --> 01:11:54.480]  если я рассмотрю вот это набор столбцов, вот с этого по этот. Рассмотрю такой набор столбцов,
[01:11:54.480 --> 01:11:59.040]  то он покрывается логарифмическим количеством вершин в дереве отрезков. То есть там выделяется
[01:11:59.040 --> 01:12:03.860]  какое-то логарифмическое количество во внешнем DO. Такие, что, скажем, это контролирует целиком
[01:12:03.860 --> 01:12:11.280]  этот столбец, а этот целиком вот эти два. То есть первое, что я делаю, то я разделяю диапазон по
[01:12:11.280 --> 01:12:14.280]  налогарифмическое количество вершин во внешнем DO.
[01:12:14.280 --> 01:12:17.280]  А дальше я понимаю, что каждый из этих вершин
[01:12:17.280 --> 01:12:19.280]  соответствует внутреннему DO,
[01:12:19.280 --> 01:12:21.280]  и мне теперь нужно в каждом из них
[01:12:21.280 --> 01:12:23.280]  вычленить сумму на отрезки
[01:12:23.280 --> 01:12:25.280]  с такого-то y под такое-то.
[01:12:25.280 --> 01:12:27.280]  То есть я сначала покрыл
[01:12:27.280 --> 01:12:29.280]  небольшим числом вершин
[01:12:29.280 --> 01:12:31.280]  отрезок по x, и дальше в каждое из них
[01:12:31.280 --> 01:12:33.280]  запускаю то же самое по y.
[01:12:33.280 --> 01:12:35.280]  То есть я вычлениваю какой-то вот, скажем,
[01:12:35.280 --> 01:12:37.280]  вот такой подотрезок по x,
[01:12:37.280 --> 01:12:39.280]  и дальше мне нужно внутри сделать сумму
[01:12:39.280 --> 01:12:41.280]  с такого-то элемента под такое-то.
[01:12:41.280 --> 01:12:43.280]  А это гетсам во внутреннем DO.
[01:12:47.280 --> 01:12:49.280]  Тоже лог квадрат поэтому.
[01:12:49.280 --> 01:12:51.280]  То есть еще раз, я сначала разделяю диапазон по x
[01:12:51.280 --> 01:12:53.280]  на вершины внешнего DO,
[01:12:53.280 --> 01:12:55.280]  потом в каждом из них
[01:12:55.280 --> 01:12:57.280]  запускаю гетсам просто на отрезки по y.
[01:12:57.280 --> 01:12:59.280]  С y минимально, а по y максимально.
[01:13:01.280 --> 01:13:03.280]  Понятно?
[01:13:03.280 --> 01:13:05.280]  Супер.
[01:13:05.280 --> 01:13:07.280]  Это тоже лог квадрат получается.
[01:13:07.280 --> 01:13:09.280]  Потому что опять, я сначала внешне
[01:13:09.280 --> 01:13:11.280]  покрыл логарифмическим числом вершин,
[01:13:11.280 --> 01:13:13.280]  а мы знаем, что любой отрезок
[01:13:13.280 --> 01:13:15.280]  покрывается жадным образом логарифмическим числом вершин
[01:13:15.280 --> 01:13:17.280]  во внешнем DO, и в каждом из них
[01:13:17.280 --> 01:13:19.280]  еще один гетсам, это еще лог квадрат.
[01:13:19.280 --> 01:13:21.280]  Ну, как бы, еще логарифм, всего лог квадрат получился.
[01:13:27.280 --> 01:13:29.280]  А их можно не искать,
[01:13:29.280 --> 01:13:31.280]  можно просто явным образом
[01:13:31.280 --> 01:13:33.280]  завести дерево отрезков на x.
[01:13:33.280 --> 01:13:35.280]  Вот как я здесь рисовал,
[01:13:35.280 --> 01:13:37.280]  вот таким образом такой DO храним.
[01:13:37.280 --> 01:13:39.280]  А у меня каждая вершина отвечает
[01:13:39.280 --> 01:13:41.280]  некоторому диапазону x, диапазону столбцов.
[01:13:41.280 --> 01:13:43.280]  Дальше, каждый из этих вершин
[01:13:43.280 --> 01:13:45.280]  либо ссылается
[01:13:45.280 --> 01:13:47.280]  на внутреннее DO,
[01:13:47.280 --> 01:13:49.280]  то есть имеет некий номер v,
[01:13:49.280 --> 01:13:51.280]  и мы для номера v создаем в это дерево отрезков
[01:13:51.280 --> 01:13:53.280]  внутреннее, либо просто эта вершина
[01:13:53.280 --> 01:13:55.280]  и есть DO, то есть
[01:13:55.280 --> 01:13:57.280]  вместо вершины можно хранить коробочку,
[01:13:57.280 --> 01:13:59.280]  которая является деревом отрезков внутреннем
[01:13:59.280 --> 01:14:01.280]  просто, и дальше внутри этой коробочки
[01:14:01.280 --> 01:14:03.280]  что-то делать.
[01:14:05.280 --> 01:14:07.280]  Ну, вот так вот как-то.
[01:14:09.280 --> 01:14:11.280]  Так, нормально?
[01:14:11.280 --> 01:14:13.280]  Ну, и соответственно можно,
[01:14:13.280 --> 01:14:15.280]  если очень хочется,
[01:14:15.280 --> 01:14:17.280]  можно сделать
[01:14:17.280 --> 01:14:19.280]  то же самое трехмерное,
[01:14:19.280 --> 01:14:21.280]  четырехмерное, ну и так далее.
[01:14:21.280 --> 01:14:23.280]  Ну, и камерное, да, тоже можно.
[01:14:23.280 --> 01:14:25.280]  Н-мерное можно, но это
[01:14:25.280 --> 01:14:27.280]  N в N уже будет какая-то,
[01:14:27.280 --> 01:14:29.280]  что-то не очень приятное.
[01:14:31.280 --> 01:14:33.280]  Вот, хорошо.
[01:14:33.280 --> 01:14:35.280]  Так.
[01:14:35.280 --> 01:14:37.280]  Ну, и давай тогда последний сюжет,
[01:14:37.280 --> 01:14:39.280]  рядышком с этим, связанный.
[01:14:41.280 --> 01:14:43.280]  Так, где мой мил?
[01:14:43.280 --> 01:14:45.280]  Где мой мил?
[01:15:03.280 --> 01:15:05.280]  Так, давайте еще такую задачу посмотрим.
[01:15:07.280 --> 01:15:09.280]  Похожая вот на то,
[01:15:09.280 --> 01:15:11.280]  что мы сейчас сделали,
[01:15:11.280 --> 01:15:13.280]  чуть-чуть еще это обобщим.
[01:15:13.280 --> 01:15:15.280]  Значит, смотрите, представьте, друбо говоря,
[01:15:15.280 --> 01:15:17.280]  смесь динамического и вот этого двумерного.
[01:15:17.280 --> 01:15:19.280]  Представьте, что у вас таблица большая была,
[01:15:19.280 --> 01:15:21.280]  не как раньше N на N,
[01:15:21.280 --> 01:15:23.280]  и вы могли N квадрат в памяти хранить.
[01:15:23.280 --> 01:15:25.280]  Она прям большая, ну скажем,
[01:15:25.280 --> 01:15:27.280]  не знаю, 10-9, 10-9.
[01:15:27.280 --> 01:15:29.280]  Это плоскость,
[01:15:29.280 --> 01:15:31.280]  координатная плоскость.
[01:15:31.280 --> 01:15:33.280]  И здесь есть мало точек.
[01:15:37.280 --> 01:15:39.280]  Здесь есть мало точек,
[01:15:39.280 --> 01:15:41.280]  с которыми происходят какие-то изменения.
[01:15:41.280 --> 01:15:43.280]  То есть изначально у вас даны координаты
[01:15:43.280 --> 01:15:45.280]  всех этих точек,
[01:15:45.280 --> 01:15:47.280]  изначально в них лежат какие-то значения,
[01:15:47.280 --> 01:15:49.280]  и вам надо делать два типа запросов.
[01:15:49.280 --> 01:15:51.280]  Как обычно, изменить в точке,
[01:15:51.280 --> 01:15:53.280]  вот, только update не в произвольной точке,
[01:15:53.280 --> 01:15:55.280]  а вот в одной из тех N, которые,
[01:15:55.280 --> 01:15:57.280]  ну или там давайте их,
[01:15:57.280 --> 01:15:59.280]  ну да, пусть их будет N,
[01:15:59.280 --> 01:16:01.280]  в одной из тех N точек,
[01:16:01.280 --> 01:16:03.280]  которые изначально нарисованы.
[01:16:03.280 --> 01:16:05.280]  То есть есть большая плоскость,
[01:16:05.280 --> 01:16:07.280]  и в ней всего N точек.
[01:16:09.280 --> 01:16:11.280]  Update в одной из них,
[01:16:11.280 --> 01:16:13.280]  либо сумма в прямоугольнике.
[01:16:19.280 --> 01:16:21.280]  То есть единственное отличие,
[01:16:21.280 --> 01:16:23.280]  что у вас, грубо говоря, табличка большая,
[01:16:23.280 --> 01:16:25.280]  вам нельзя ее полностью хранить в памяти,
[01:16:25.280 --> 01:16:27.280]  но в ней мало точек.
[01:16:27.280 --> 01:16:29.280]  В ней мало точек,
[01:16:29.280 --> 01:16:31.280]  в которых будет просветить изменения.
[01:16:31.280 --> 01:16:33.280]  Их всего N.
[01:16:33.280 --> 01:16:35.280]  Вот.
[01:16:35.280 --> 01:16:37.280]  На что здесь можно сделать?
[01:16:39.280 --> 01:16:41.280]  Ну, на самом деле...
[01:16:45.280 --> 01:16:47.280]  Смотрите, поскольку точки нам известны заранее,
[01:16:47.280 --> 01:16:49.280]  давайте мы запустим
[01:16:49.280 --> 01:16:51.280]  сперва сжатие координат.
[01:16:51.280 --> 01:16:53.280]  Сжатие координат.
[01:16:55.280 --> 01:16:57.280]  Мы можем все эти координаты,
[01:16:57.280 --> 01:16:59.280]  мы можем все эти точки считать,
[01:16:59.280 --> 01:17:01.280]  можем посортировать их по X, по Y,
[01:17:01.280 --> 01:17:03.280]  ну и соответственно, вместо того,
[01:17:03.280 --> 01:17:05.280]  чтобы иметь координаты порядка 10 в 9,
[01:17:05.280 --> 01:17:07.280]  у нас будут координаты порядка N,
[01:17:07.280 --> 01:17:09.280]  и на этом уже можно будет построить дерево отрезков.
[01:17:09.280 --> 01:17:11.280]  Первое, что я сделаю,
[01:17:11.280 --> 01:17:13.280]  это я сожму координаты по X только пока что.
[01:17:13.280 --> 01:17:15.280]  Сожмем.
[01:17:15.280 --> 01:17:17.280]  Координаты.
[01:17:17.280 --> 01:17:19.280]  По X.
[01:17:21.280 --> 01:17:23.280]  Вот.
[01:17:23.280 --> 01:17:25.280]  То есть все X-координаты свалю в один вектор,
[01:17:25.280 --> 01:17:27.280]  посортирую, удалю дубликаты.
[01:17:27.280 --> 01:17:29.280]  Теперь для каждой точки я знаю,
[01:17:29.280 --> 01:17:31.280]  какой ее номер в этом списке отсортированных X.
[01:17:31.280 --> 01:17:33.280]  Какой у нее X в списке.
[01:17:33.280 --> 01:17:35.280]  Вот.
[01:17:35.280 --> 01:17:37.280]  Дальше давайте построим внешнее DO.
[01:17:37.280 --> 01:17:39.280]  Значит, строим внешнее DO по X.
[01:17:43.280 --> 01:17:45.280]  Внешнее DO
[01:17:47.280 --> 01:17:49.280]  по X.
[01:17:49.280 --> 01:17:51.280]  Поскольку я это сжал,
[01:17:51.280 --> 01:17:53.280]  у меня табличка стала примерно такой,
[01:17:53.280 --> 01:17:55.280]  то есть у нее маленькое количество столбцов.
[01:17:55.280 --> 01:17:57.280]  И здесь, на этой вот X-координате,
[01:17:57.280 --> 01:17:59.280]  я могу построить обычный дерево отрезков.
[01:17:59.280 --> 01:18:01.280]  Какая-то такая штука у меня будет.
[01:18:01.280 --> 01:18:03.280]  Что-то такое.
[01:18:07.280 --> 01:18:09.280]  Значит, теперь опять каждая вершина
[01:18:09.280 --> 01:18:11.280]  дерево отрезков отвечает
[01:18:11.280 --> 01:18:13.280]  какому-то под набору столбцов,
[01:18:13.280 --> 01:18:15.280]  под отрезку столбцов, точнее.
[01:18:15.280 --> 01:18:17.280]  Каждая вершина отвечает вот такому отрезку столбцов.
[01:18:19.280 --> 01:18:21.280]  Теперь давайте мы
[01:18:21.280 --> 01:18:23.280]  для каждой вершины внешнего DO.
[01:18:25.280 --> 01:18:27.280]  Смотрите, у меня здесь на самом деле
[01:18:27.280 --> 01:18:29.280]  в среднем точек не очень много.
[01:18:29.280 --> 01:18:31.280]  У меня всего суммарно в этой таблице N точек.
[01:18:31.280 --> 01:18:33.280]  И если я высеку только такой
[01:18:33.280 --> 01:18:35.280]  маленький диапазон X-ов,
[01:18:35.280 --> 01:18:37.280]  такой подотрезочек,
[01:18:37.280 --> 01:18:39.280]  скорее всего здесь точек будет еще сильно меньше.
[01:18:39.280 --> 01:18:41.280]  Если всего их N, а я выделяю такой подотрезок,
[01:18:41.280 --> 01:18:43.280]  то здесь точек меньше,
[01:18:43.280 --> 01:18:45.280]  чем во всей таблице.
[01:18:45.280 --> 01:18:47.280]  Так вот, давайте мы построим дерево отрезков
[01:18:47.280 --> 01:18:49.280]  не на всем вот этом вот
[01:18:49.280 --> 01:18:51.280]  диапазоне Y-ов,
[01:18:51.280 --> 01:18:53.280]  а только на тех Y-ах, которые есть в этом столбце.
[01:18:55.280 --> 01:18:57.280]  То есть, грубо говоря,
[01:18:57.280 --> 01:18:59.280]  смотрите, я для этой точки, для этой вершины
[01:18:59.280 --> 01:19:01.280]  знаю, какие точки попали
[01:19:01.280 --> 01:19:03.280]  в эту полосочку, в этот диапазон столбцов.
[01:19:03.280 --> 01:19:05.280]  Я теперь
[01:19:05.280 --> 01:19:07.280]  сортирую их по Y-кам,
[01:19:07.280 --> 01:19:09.280]  и только на этих сжатых Y-ках
[01:19:09.280 --> 01:19:11.280]  построю внутреннее DO.
[01:19:11.280 --> 01:19:13.280]  То есть у меня внутреннее DO в этой точке
[01:19:13.280 --> 01:19:15.280]  устроено не по всей таблице,
[01:19:15.280 --> 01:19:17.280]  а только по вот этой вот полосочке.
[01:19:17.280 --> 01:19:19.280]  И, соответственно, там будет точек
[01:19:19.280 --> 01:19:21.280]  меньше, чем
[01:19:21.280 --> 01:19:23.280]  во всей таблице.
[01:19:23.280 --> 01:19:25.280]  Значит,
[01:19:25.280 --> 01:19:27.280]  каждая вершина В,
[01:19:29.280 --> 01:19:31.280]  каждая вершина
[01:19:31.280 --> 01:19:33.280]  внешнего DO
[01:19:35.280 --> 01:19:37.280]  соответствует
[01:19:39.280 --> 01:19:41.280]  вертикальной полоске,
[01:19:45.280 --> 01:19:47.280]  значит,
[01:19:47.280 --> 01:19:49.280]  запоминаем, давайте запомним
[01:19:49.280 --> 01:19:51.280]  все точки,
[01:19:51.280 --> 01:19:53.280]  попадающие в эту полоску.
[01:19:57.280 --> 01:19:59.280]  Запомним
[01:19:59.280 --> 01:20:01.280]  все точки,
[01:20:01.280 --> 01:20:03.280]  попадающие в эту полоску.
[01:20:03.280 --> 01:20:05.280]  У них
[01:20:13.280 --> 01:20:15.280]  сожмем координаты по Y-кам
[01:20:15.280 --> 01:20:17.280]  и построим внутреннее DO по Y-кам.
[01:20:19.280 --> 01:20:21.280]  У них сожмем
[01:20:21.280 --> 01:20:23.280]  Y-координаты
[01:20:23.280 --> 01:20:25.280]  и построим
[01:20:25.280 --> 01:20:27.280]  внутреннее DO по Y-кам.
[01:20:27.280 --> 01:20:35.980]  Построим внутреннее DO по Y.
[01:20:35.980 --> 01:20:41.780]  Ну а дальше уже отвечаем так же, как и раньше.
[01:20:41.780 --> 01:20:51.660]  То есть единственное отличие по сравнению с задачей на
[01:20:51.660 --> 01:20:55.420]  таблице N на N, это то, что я вот это внутреннее DO
[01:20:55.420 --> 01:20:59.020]  строю не на всех точках всей таблицы, которая есть,
[01:20:59.020 --> 01:21:01.340]  а только на те, которые попали внутри вот этой узенькой
[01:21:01.340 --> 01:21:06.100]  полосочки, которая высекается конкретно вершиной внешнего
[01:21:06.100 --> 01:21:07.100]  DO.
[01:21:07.100 --> 01:21:08.900]  Вот в этой полоске я считаю все точки, сортирую их по
[01:21:08.900 --> 01:21:12.140]  Y, они приобретают новый порядок внутри этой полоски,
[01:21:12.140 --> 01:21:15.140]  и я вот на этих точках строю DO, вот такой внешне горизонтальный.
[01:21:15.140 --> 01:21:22.700]  Ну тогда я утверждаю, что вот это вот все, весь этот
[01:21:22.700 --> 01:21:29.900]  предпочет можно устроить за N лог N, кажется, ну давайте
[01:21:29.900 --> 01:21:30.900]  посчитаем.
[01:21:30.900 --> 01:21:33.900]  Вот я утверждаю, что это можно сделать за N лог N.
[01:21:33.900 --> 01:21:34.900]  Почему?
[01:21:34.900 --> 01:21:37.620]  На самом деле потому что, вот давайте посчитаем
[01:21:37.620 --> 01:21:41.340]  вообще просто, сколько раз каждая конкретная точка
[01:21:41.340 --> 01:21:42.340]  куда-то входит.
[01:21:42.340 --> 01:21:47.900]  Да, она входит в логарифмическое количество таких полосочек
[01:21:47.900 --> 01:21:50.260]  вертикальных, потому что это значит, что она должна
[01:21:50.440 --> 01:21:51.820]  попасть в какой-то из Ella's.
[01:21:51.820 --> 01:21:54.760]  보이, она должна контролируется вершиной их логарифмическое
[01:21:54.760 --> 01:21:58.740]  количество, значит получается, что каждая точка I, будет
[01:21:58.740 --> 01:22:01.900]  находиться всего в логарифмическом количестве внутрен original
[01:22:01.900 --> 01:22:02.900]  DO.
[01:22:02.900 --> 01:22:05.220]  Потому, что внутреннее соответствует вершинам внешнего.
[01:22:05.220 --> 01:22:07.720]  Значит, каждая точка будет в соответствующем списке
[01:22:07.720 --> 01:22:10.620]  всего лишь в логарифм раз, поэтому память N лог N.
[01:22:10.620 --> 01:22:13.280]  Оно каждая точка всего в логарифмическом количестве
[01:22:13.280 --> 01:22:16.860]  вершин DO хранится, значит памяти всего N лог N.
[01:22:16.860 --> 01:22:20.860]  И более того, можно это построить тоже за n log n.
[01:22:20.860 --> 01:22:25.860]  Ну почему? Потому что, что я сделал? Я сначала посортил по x.
[01:22:25.860 --> 01:22:29.860]  Дальше мне что нужно? На самом деле, мне нужно просто в каждой вершине
[01:22:29.860 --> 01:22:32.860]  вычислить те точки, попавшие в эту полосочку,
[01:22:32.860 --> 01:22:36.860]  и сжать их по y, то есть посортить по y.
[01:22:36.860 --> 01:22:40.860]  Но это сделать очень просто. Смотрите, если, например, в таких вот тривиальных
[01:22:40.860 --> 01:22:44.860]  полосочках из одного столбца все это сделаю, то есть, ну, построю внутреннее
[01:22:44.860 --> 01:22:47.860]  DO для всех вот этих вот листиков.
[01:22:47.860 --> 01:22:50.860]  Во всех таких тривиальных столбцах я нашел ответ.
[01:22:50.860 --> 01:22:53.860]  Что мне надо делать дальше? Дальше мне нужно просто слить вот эти два списка.
[01:22:53.860 --> 01:22:57.860]  То есть, если я знаю список точек здесь, список точек здесь,
[01:22:57.860 --> 01:23:01.860]  в отсортированном по y порядке, то дальше, чтобы получить список точек здесь,
[01:23:01.860 --> 01:23:03.860]  мне надо их просто слить с помощью merge.
[01:23:03.860 --> 01:23:06.860]  Потому что они здесь посорщены по y, здесь посорщены по y,
[01:23:06.860 --> 01:23:09.860]  и я их могу склеить за линейное время от их суммарного количества.
[01:23:10.860 --> 01:23:16.860]  Значит, я здесь знаю список точек в этой полоске в порядке возрастания по y.
[01:23:16.860 --> 01:23:19.860]  То есть, они уже сжаты, и на этом можно строить DO.
[01:23:19.860 --> 01:23:23.860]  Получается, что суммарно, ну, как бы, то есть, я по факту просто делаю merge
[01:23:23.860 --> 01:23:28.860]  вот в этом внешнем DO, на этом мне нужно log n времени и log n памяти.
[01:23:28.860 --> 01:23:30.860]  Нет, просто подождите.
[01:23:30.860 --> 01:23:34.860]  Сама сортировка во всех каждом из столцов триллиамета,
[01:23:34.860 --> 01:23:37.860]  ну, сумма всех сортировок будет на log n?
[01:23:37.860 --> 01:23:40.860]  Еще раз, смотрите, я сортирую, на самом деле, только один раз,
[01:23:40.860 --> 01:23:42.860]  только по x.
[01:23:42.860 --> 01:23:46.860]  Внутри, смотрите, ну, для вот этих вот листиков у меня нет сортировки никакой.
[01:23:46.860 --> 01:23:49.860]  Я просто знаю, какая единственная точка лежит в каждом столбце.
[01:23:53.860 --> 01:23:55.860]  Справедливо.
[01:24:02.860 --> 01:24:06.860]  Скажем так, если считать, что все координаты по x,
[01:24:06.860 --> 01:24:08.860]  по парам различные, то такого не бывает.
[01:24:11.860 --> 01:24:15.860]  Хорошо, на самом деле можно сказать, что, типа, это на самом деле работает,
[01:24:15.860 --> 01:24:17.860]  и если у вас есть совпадающие координаты.
[01:24:21.860 --> 01:24:25.860]  Смотрите, можно просто сделать так, что у вас вершина отличает не целиком полоски,
[01:24:25.860 --> 01:24:29.860]  а, ну, короче, вершина отличает точки.
[01:24:31.860 --> 01:24:33.860]  Подумайте.
[01:24:33.860 --> 01:24:35.860]  Все, спасибо.
[01:24:36.860 --> 01:24:38.860]  Аплодисменты.
