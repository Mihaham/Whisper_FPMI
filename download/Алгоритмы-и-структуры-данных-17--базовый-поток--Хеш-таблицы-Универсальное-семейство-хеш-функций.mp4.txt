[00:00.000 --> 00:09.440]  сегодня будет очень очень много математики которая возможно вам еще не сильно была вы не
[00:09.440 --> 00:18.200]  сильно встречали вот а попрошу внимательно относиться к тому что здесь будет потому что
[00:18.200 --> 00:25.200]  это достаточно сложная тема для восприятия будет именно с точки зрения математики не с точки
[00:25.200 --> 00:31.880]  зрения того как это запрогася что-то с этим сделать а именно с точки зрения математики вот
[00:31.880 --> 00:37.240]  поэтому с этим всем нужно считаться вам нужно будет уметь это доказывать вам нужно понимать
[00:37.240 --> 00:44.560]  почему это работает быстро почему тот или иной метод работает в принципе и так далее а прошу
[00:44.560 --> 00:49.920]  прощения но да сегодня мы задержимся но мы зато пройдем сразу две лекции по всему что нам
[00:49.920 --> 00:57.280]  необходимо я надеюсь что мы это сделаем вот все зависит от того как мы будем идти по необходимому
[00:57.280 --> 01:03.240]  нам материалам я знаю что у вас уже на семинарах должны были быть хэш таблицы еще у кого-то не
[01:03.240 --> 01:10.120]  было ага кого-то значит они будет тогда мы сегодня говорим про в принципе хэш таблицы все что с
[01:10.120 --> 01:18.040]  ними связано это еще не конец типа будут еще несколько будет еще пару тем на эту тему вот
[01:18.040 --> 01:26.320]  а какая какую проблему вообще решает любая хэш таблица она решает проблему следующую что если
[01:26.320 --> 01:33.440]  у меня есть какой-то массив в котором у нас есть какие-то элементы я хочу быстро уметь
[01:33.440 --> 01:41.280]  понимать есть ли какой-то конкретный элемент в данном массиве конечно мы можем просто взять
[01:41.280 --> 01:50.280]  обычные массивы и тогда это будет работать за за уатен просто обычный поиск в массиве можно
[01:50.280 --> 02:00.680]  придумать что-нибудь другое можно делать какие-нибудь не только массивы за уатен но
[02:00.680 --> 02:07.240]  к примеру можно ассортировать массивы тогда давайте результат за логен в помощи бинарного
[02:07.240 --> 02:12.680]  поиска все верно но в этом случае мы будем очень долго вставлять элементы в наш массив вот это
[02:12.680 --> 02:19.520]  тоже нам не очень подходит а если какие-нибудь структуру данных давайте вспомните пожалуйста
[02:19.520 --> 02:29.080]  а где у вас будет поиск за логарифм а вставка быстрее чем за уатен бинарное дерево поиска
[02:29.080 --> 02:35.520]  действительности это так но бинарном дереве поиска проблема в том что мы все время сохраняем
[02:35.520 --> 02:39.760]  структуру вот этого сравнения все что у нас там происходит и так далее занимает много места
[02:39.760 --> 02:48.280]  плюс логарифм тоже не очень круто хочется сделать так чтобы у нас вставка удаления и
[02:48.280 --> 02:57.000]  нахождения элемента было за о от единички это и решает проблема это и решает хэш таблицы
[02:57.000 --> 03:05.200]  смотрите какая идея с хэш таблицами допустим что мы хотим хранить какие-то числа от нуля до
[03:05.200 --> 03:13.560]  там м-1 где в принципе м-1 ну в принципе м давайте так потому что там чисел м оно в контексте
[03:13.560 --> 03:19.880]  памяти достаточно мало как можно быстро хранить такие числа вот чтобы мы понимали есть такое число
[03:19.880 --> 03:33.000]  нет такого числа да по сути массив из true false где мы будем хранить по каждому индексу есть
[03:33.000 --> 03:40.200]  такой элемент в нашей в нашей копилочке или нету если мы будем вставлять элемент то это означает
[03:40.200 --> 03:47.720]  что у нас массив мы вставляем элемент x значит b от x оно будет равно true если мы удаляем
[03:47.720 --> 03:53.240]  элемент мы говорим что он будет в полс ну и поиск элемента то есть есть элемент или нет
[03:53.240 --> 04:00.040]  элемента в нашей какой вот табличке мы будем делать просто с помощью ретерна это тоже за от
[04:00.040 --> 04:06.280]  единицы вот самое первое приближение к хэш таблице вообще все ячейки вот этого массива которые у
[04:06.280 --> 04:13.120]  нас есть они будут называться корзинами но весь мир к сожалению не построен на числах от нуля до
[04:13.120 --> 04:19.600]  м-1 и еще чтобы м было маленькое к сожалению она не та вот стоит много разных чисел и тогда это
[04:19.600 --> 04:27.800]  становится не круто но как обобщенно должна выглядеть хэш таблица смотрите пусть некоторые
[04:27.800 --> 04:35.800]  к это произвольное множество ключей а для которого хочется сделать аналогичное действие чтобы
[04:35.800 --> 04:41.720]  были до этого то есть к это то с чем нам могут приходить это могут быть функции это был может
[04:41.720 --> 04:48.920]  быть массив чисел это могут просто числа какие-то которые просто по одному приходит и так далее вот
[04:48.920 --> 04:58.680]  а и я хочу построить как раз таки функцию отображения в эти корзинки то есть когда у меня
[04:58.680 --> 05:06.920]  приходит какой-то элемент x он из как раз таки который у меня есть то я просто беру делаю
[05:06.920 --> 05:16.960]  функцию h от x и кладу его куда-то от нуля до м-1 потому что с от нуля до м-1 мы понимаем как
[05:16.960 --> 05:25.760]  работать то есть я хочу вот это сопоставление сделать м называется размером нашей хэш таблице вот
[05:25.760 --> 05:32.400]  ну а весь тут массивчик который у нас здесь будет напомню что вот здесь вот у нас будут эти самые
[05:32.400 --> 05:42.760]  корзинки вот куда хэш функция h от x это хэш функция она будет просто складывать наше значение вот и
[05:42.760 --> 05:52.960]  показывать есть какой-то элемент или нет чем здесь может быть проблема да если количество
[05:52.960 --> 06:02.560]  элементов к начинает быть больше чем м потому что у нас будут так называемые коллизии то есть
[06:02.560 --> 06:10.920]  в случае когда у нас будут различные элементы из к x какой-нибудь y но хэш функция для них
[06:10.920 --> 06:16.720]  будет одинаково в особенности проблема когда у нас к сильно больше м у нас коллизии становится
[06:16.720 --> 06:25.360]  очень много и тогда какая-либо эффективность этой хэш таблицы вообще становится под вопросом вот
[06:25.360 --> 06:34.760]  то есть никакого такого инъективного отображения вы сделать не можете что грустно для разрешения
[06:34.760 --> 06:41.840]  коллизии существует так называемый метод цепочек что такое метод цепочек метод цепочек достаточно
[06:41.840 --> 06:55.600]  просто смотрите вас есть вот ваш массив b будьте здоровы вас есть массив б у него там и минус один
[06:55.600 --> 07:01.760]  элемент как только вы встречаете коллизию и в принципе все элементы вы храните следующим
[07:01.760 --> 07:09.000]  образом вот вам пришел элемент x вы его положили сюда после этого если у вас появится какой-нибудь
[07:09.000 --> 07:17.040]  y который не равен x во первых а во вторых находится хэш функция отображает в то же место то в этом
[07:17.040 --> 07:27.960]  случае вы просто таким листом кладете y благодаря этому мы понимаем что у нас вот в этой части именно
[07:27.960 --> 07:34.840]  с этим хэшом находится x и y и дальше чтобы определить есть ли x или нет y я должен взять и
[07:34.840 --> 07:42.120]  просто пройтись по всему по всей этой цепочке и сказать встретил я такой элемент или нет это пока
[07:42.120 --> 07:51.840]  понятно не сложно это отлично вот это и будет называться методом цепочек для разрешения коллизий
[07:51.840 --> 08:03.320]  что такое время время работы с методом цепочек но нужно понимать что insert и erase всегда будут
[08:03.320 --> 08:10.160]  совпадать с find то есть вы если находите элемент то ничего не делаете вставки в
[08:10.160 --> 08:18.120]  разе вы просто убираете один элемент если вы не находите какой-то элемент то есть вы все равно
[08:18.120 --> 08:26.400]  до начала делаете find то insert должен вставить этот элемент а erase должен как раз таки ничего
[08:26.400 --> 08:32.240]  не сделать потому что этого элемента у нас нет вот поэтому будем оценивать время find всегда
[08:32.240 --> 08:40.080]  и для нас это самое важное что есть какое время find время find и следующее мы в начале
[08:40.080 --> 08:49.040]  находим h от x это находится за о от единички согласны а дальше мы должны пройтись по всей
[08:49.040 --> 08:57.640]  цепочке который у нас есть поэтому а вот это вот длина цепочки lx которая здесь есть это и
[08:57.640 --> 09:06.480]  будет наше время работы то есть время работы поиска будет о от единицы плюс lx в худшем случае
[09:06.480 --> 09:12.480]  когда у вас все элементы складываются в одну и ту же корзинку то есть у вас настолько маленькая
[09:12.480 --> 09:20.840]  х-табличка что у вас просто одна большая цепочка у вас будет время работы о отн что не круто
[09:20.840 --> 09:30.400]  а и все упирается как раз таки здесь либо вас не очень хорошая хэш функция и все упирается здесь
[09:30.400 --> 09:38.680]  в хэш функцию нужно ее выбрать очень правильно очень корректно для того чтобы у вас все работало
[09:38.680 --> 09:48.000]  что должна делать такая хэш функция равномерно распределять то есть да для того чтобы у нас как
[09:48.000 --> 09:53.760]  можно больше элементы расходились между собой она должна как-то равномерно раскидывать
[09:53.760 --> 10:02.960]  элементы между корзинами которые у нас есть но предположим что у нас есть x это unsigned int
[10:02.960 --> 10:09.000]  вопрос к вам такой нам подойдет функция h от x которая берет просто остаток отделения
[10:09.000 --> 10:19.080]  равномерно или она распределяет данные в зависимости от задач в плане
[10:19.080 --> 10:34.680]  ага да вся проблема действительности в том что какие у нас есть конкретно входные данные мы
[10:34.680 --> 10:42.400]  можем подавать просто на вход м 2 м 3 м 4 м и так далее они будут все классы в одну корзину то есть
[10:42.400 --> 10:51.280]  все зависит также от этих данных но мы хотим сделать h от x максимально независящий от данных
[10:51.280 --> 10:59.520]  величин и попробовать это сделать как-то по-другому и для этого вводится так называемое простое
[10:59.520 --> 11:07.240]  равномерное хеширование это первое самое важное что вам нужно знать у него существует два
[11:07.240 --> 11:13.320]  определения не эквивалентно между собой первое определение говорится следующим что у нас аж просто
[11:13.320 --> 11:23.800]  выбирается рандомно из всех хэш функций которые есть в наше множество всевозможных всем понятно
[11:23.800 --> 11:33.280]  запись вот это вот в степени к множество степени к это есть вот эти отображения между собой окей то
[11:33.280 --> 11:39.960]  есть мы расслабить абсолютно все хэш функции которые у нас есть вот и аж выбираться будет
[11:39.960 --> 11:47.200]  случайно из этого множество мы выбираем это случайно вроде бы что-то должно получиться то
[11:47.200 --> 11:52.920]  есть благодаря вот этой случайности которая есть она может нам помочь вспомните с quicksort например
[11:52.920 --> 11:59.680]  как было если мы всегда фиксировали какой элемент мы берем там первый там последний середину и так
[11:59.680 --> 12:09.040]  далее мы всегда могли придумать такую расстановку чисел для quicksort что она будет работать в лучшем
[12:09.040 --> 12:17.360]  случае за m квадрат и мы pivot выбирали рандомно был такое то есть в лучшем случае во лучше
[12:17.360 --> 12:23.160]  выбирать рандомно какое-нибудь число вот в этом случае аналогично когда мы хэш функцию будем
[12:23.160 --> 12:28.480]  выбирать из какого-то множества всевозможных функций в этом случае нам может повезти и все
[12:28.480 --> 12:34.960]  будет хорошо и ну как бы от рандома никто не защищен но может повезти может нет но чаще повезет
[12:34.960 --> 12:43.840]  скорее потому что таких функций сколько много согласны вот второе определение следующее ну что
[12:43.840 --> 12:51.640]  у вас есть какой-нибудь ашат икс вам нужно еще важно что понимать что у вас ашат икс должно
[12:51.640 --> 12:57.920]  быть одно и то же для любого для одного и того же икса оно не должно меняться между собой поэтому
[12:57.920 --> 13:05.680]  мы должны всегда фиксировать вот это ашат икс который у нас есть поэтому грубо говоря если у нас
[13:05.680 --> 13:11.600]  икс приходит какой-то новый ключ то есть у нас вот find мы сделали у нас не получается такого икса
[13:11.600 --> 13:18.440]  найти грубо говоря то ашат икс будет рандомно выкидывать какое число из м рандом всегда
[13:18.440 --> 13:25.560]  помогает в равномерности иначе не работает вот а иначе если у нас икс уже есть который к нам
[13:25.560 --> 13:33.560]  приходил то в этом случае мы будем использовать ровно тот же хэш который был ранее просто выглядит
[13:33.560 --> 13:51.040]  ашат икс рандомно но это другой вопрос как это делать вот но в действительности здесь нет
[13:51.040 --> 13:58.400]  пока никакой проблемы то есть мы просто выкидываем рандомно числа но да это это вопрос правильный
[13:58.400 --> 14:06.680]  который мы подойдем в конце хорошо окей для того чтобы продолжать дальше нам необходимо
[14:06.680 --> 14:12.080]  окунуться в теорвер который у вас будет чуть-чуть попозже здесь будут введены краткие какие-то
[14:12.080 --> 14:21.280]  сводки с теорвера назову это так которые вам должны помочь понять все что у нас происходит оно
[14:21.280 --> 14:27.240]  может немного отличаться с точки зрения теорвера потому что ну совсем вас убить не хочется вот и
[14:27.240 --> 14:35.200]  иначе будут некоторые проблемы ну смотрите первое что вводится вводится что такое омега омега это
[14:35.200 --> 14:40.560]  просто а некоторые там множество равновероятных экспериментов которые у нас есть но не знаю вы
[14:40.560 --> 14:46.720]  кубик подкидываете вот у вас число от одного до шести может выпасть правильно вот у вас омега
[14:46.720 --> 14:52.680]  мы рассматриваем сейчас именно равновероятные исходы ну потому что мы находимся в таком мире
[14:52.680 --> 14:57.960]  где у нас рандом рандом равновероять событием какого-то множества это является под множеством
[14:57.960 --> 15:04.400]  омега ну не знаю типа просто четные числа должны выпасть на кубики это 246 вот это
[15:04.400 --> 15:11.560]  является событием мы кидаем оно случилось не случилось вот вероятность какого-то события это
[15:11.560 --> 15:17.120]  мощность множество этого события разделить на множество всевозможных событий я думаю тут
[15:17.120 --> 15:27.280]  понятно да мощность множество знакомое слово хорошо вот сегодня вот типа я говорю самая
[15:27.280 --> 15:34.960]  проблема хэш функции и хэш табличек это всегда такой математический аппарат вот здесь нужно
[15:34.960 --> 15:41.440]  очень аккуратно поэтому останавливает если что-то не понимать дальше пусть у нас x будет
[15:41.440 --> 15:47.960]  результатом некоторого измерения вот здесь вот написано я от x кто знает какой называется
[15:47.960 --> 15:56.760]  это правда воспринимаете это как среднее пока что воспринимать будем такие таким способом
[15:56.760 --> 16:02.080]  потому что это некоторые дискретные случаи поэтому здесь можно сделать так это действительно просто
[16:02.080 --> 16:08.720]  среднее число которое выпадет вот то есть вы ожидаете что выпадет что-то грубо говоря это
[16:08.720 --> 16:17.000]  само число на вероятность того того что выпало какой-то там исход ну например у вас есть кубик и
[16:17.000 --> 16:23.640]  тогда мат ожидания от случайной величины x ну то есть вот вы подкинули кубик вы хотите понять
[16:23.640 --> 16:29.000]  сколько в среднем будет выпадать чиселка что за чиселка будет выпадать оно будет равно там а
[16:29.000 --> 16:37.360]  один плюс умножено на одну шестую плюс два на одну шестую плюс так далее 6 умножить на одну
[16:37.360 --> 16:46.760]  шестую это откуда это получилось вот ну дальше получится какое число это будет это и будет
[16:46.760 --> 16:56.760]  мат ожидания мат ожидания того числа который у вас выпадет кубики вот здесь либо вы вам не
[16:56.760 --> 17:03.320]  нравится либо я не понимаю ваши лица вот вы озадачены во всяком случае но хорошо воспринимайте
[17:03.320 --> 17:12.840]  это так что важно понимать про мат ожидания про мат ожидания важно понимать следующее ну давайте
[17:12.840 --> 17:19.280]  так среднее буду говорить среднее чтобы не пугать другими словами вот средняя от двух случайных
[17:19.280 --> 17:24.440]  величин от суммы двух случайных величин это средняя каждый из них и просуммировать необходимо
[17:24.440 --> 17:31.880]  но если мы говорим про дискретный случай ну как бы просто сложим x 1 плюс y 1 плюс там x
[17:31.880 --> 17:39.360]  n плюс y и так далее разделим на н ну мы получим то же самое вот разделим просто на две дроби тогда
[17:39.360 --> 17:47.120]  у нас получается необходимая нам средняя вот а это то что нам тоже нужно и последнее что важно
[17:47.120 --> 17:55.800]  если у нас x и y это независимые равно вероятные события и они принимают значение а вот здесь
[17:55.800 --> 18:02.720]  а нет все правильно они принимают значение грубо говоря от нуля там до m минус 1 то вероятность
[18:02.720 --> 18:13.880]  того что x равен y равно 1 на m правда это просто хотя бы отлично но как бы доказывается это из
[18:13.880 --> 18:21.600]  первого пункта но нам нужно взять одинаковые пары одинаковых пар всего m различных пар m квадрат
[18:21.600 --> 18:37.720]  m делить на m квадрат получаем 1 на m ok ok отлично хорошо теперь очень интересная вещь а когда мы
[18:37.720 --> 18:45.520]  используем простое равномерное хэширование то в этом случае среднее время поиска файнда по
[18:45.520 --> 18:55.640]  факту составляет о от 1 плюс альфа где альфа это n делить на m n это количество элементов в
[18:55.640 --> 19:03.200]  хэштаблице ну то есть грубо говоря сколько элементов мы приняли м размер хэштаблицы альфа
[19:03.200 --> 19:10.080]  само по себе называется loadFactor когда вы будете проходить не знаю на плюсах а нордерцеты еще
[19:10.080 --> 19:17.360]  же не прошли нет вот когда вы будете проходить вот там вот тоже будут свои методы там тоже будет
[19:17.360 --> 19:23.000]  loadFactor loadFactor это вот это вот как раз таки n делить на m только у нас есть элементов и сколько у нас
[19:23.000 --> 19:28.160]  есть корзинок вот то есть мы пытаемся оценить вот эту равномерность не знаю сколько элементов
[19:28.160 --> 19:38.560]  цепочки будет в среднем нам 3 4 2 1 и так далее вот мы хотим это доказать как такое доказывается
[19:38.560 --> 19:47.600]  но пусть у нас есть множество x это x1 xn которая является элементами хэштаблицы то есть теми
[19:47.600 --> 19:55.040]  элементами которые у нас передаются в хэш функцию которые у нас принимаются давайте выразим длину
[19:55.040 --> 20:03.760]  цепочки как можно выразить длину цепочки вот смотрите вот как вы думаете что у меня за сумма
[20:03.760 --> 20:20.200]  там написано вам знакома буковка и индикатор слышали такое слово хорошо да это просто индикаторная
[20:20.200 --> 20:33.880]  функция практически что такое и там h от x равно h от x и t она принимает значение 0 если h от x
[20:33.880 --> 20:52.400]  не равно h от x и t и единицу если h от x равно h от x и t ну такой да переведены в нты вот
[20:52.400 --> 20:58.840]  но в общем-то смотрите индикатор это достаточно просто согласны ли вы с тем что длина цепочки
[20:58.840 --> 21:08.680]  равна сумме всех индикатору суммы индикаторов для конкретного x ну потому что мы просто вот
[21:08.680 --> 21:16.440]  смотрим все возможные вот эти вот вещи это чудесно давайте теперь выразим маты средняя
[21:16.440 --> 21:22.920]  среднюю длину цепочки чему равна средняя длина цепочки видите я просто беру и подставляю это
[21:22.920 --> 21:34.600]  вот ел x видите да вот средняя дальше я подставляю вот этот индикатор а средняя сумме равно сумме
[21:34.600 --> 21:42.960]  средних да значит я могу внести это под сумму вот по третьему свойству которое у нас было
[21:42.960 --> 21:57.440]  до этого окей окей это первое и теперь следующее я говорю так что а что такое средняя величина
[21:57.440 --> 22:08.480]  того что у меня h от x равен h от y это вероятность этого события все может случиться может нет и
[22:08.480 --> 22:17.320]  вероятность этого события и есть то самое среднее которое возможно нужно принимают 0 1 ну вот мы
[22:17.320 --> 22:22.760]  понимаем что вероятность это событие есть будет где-то там понятно почему это происходит
[22:22.760 --> 22:36.400]  что именно непонятно куда делать е ну смотрите мне нужно найти среднюю величину индикатора
[22:36.400 --> 22:51.040]  да отлично ну вот вот так грубо говоря я должен понять но он может получиться 0 может 1 вот
[22:51.040 --> 22:59.600]  вероятностью 0 оно получается ну не знаю там п1 да с этого это п2 а теперь смотрите чему равно
[22:59.600 --> 23:13.520]  этом от ожидания она равно 0 умножить на п1 плюс 1 умножить на п2 получается вероятность когда
[23:13.520 --> 23:23.120]  они одинаковые теперь понятнее отлично вот благодаря вот этому вот свойству мы получаем
[23:23.120 --> 23:30.040]  что у нас просто есть сумма вероятности ну и чему равна эта сумма вероятности смотрите h от
[23:30.040 --> 23:48.920]  x и h от x y это разные события или нет независимые события или нет ну да они разные они разные кроме
[23:48.920 --> 24:01.400]  одного случая когда они одинаковые все правильно нет смотрите когда когда они одинаковые ну как бы
[24:01.400 --> 24:10.480]  аж от пяти аж от пяти логично что это одинаковый х х значение правильно согласны то есть в этом
[24:10.480 --> 24:21.440]  случае у нас будет единичка когда x равно x и t а в других случаях это 1 делить на m все просто мы
[24:21.440 --> 24:29.680]  смотрим эту сумму получается в одном случае у нас там будет один плюс там n минус один делить на
[24:29.680 --> 24:41.000]  м если у нас x вообще лежит в множестве x-ов большое а иначе у нас будет n делить на m но все это меньше
[24:41.000 --> 25:02.520]  чем 1 плюс n делить на м понятно или непонятно это самое начало вопросы есть на экзамене вам это
[25:02.520 --> 25:16.240]  доказывать не мне предпоследний это из когда сумма получилось вот это из одной
[25:16.240 --> 25:25.560]  системы в другую но смотрите а если у меня x лежит в этом множестве то у меня что будет то у
[25:25.560 --> 25:33.600]  меня будет когда x равно x и t это единичка правильно а сколько вероятно сколько случаев что x не
[25:33.600 --> 25:47.400]  равно x и t сколько таких случаев я кроме одного сколько всего их там было n да получается таких
[25:47.400 --> 25:58.880]  n минус 1 вот получается что сумма этого всего это 1 плюс n минус 1 делить на m потому что у меня
[25:58.880 --> 26:06.320]  вероятность одного такого события 1 на m когда ашат икс равно ашат икс это ага это первое но
[26:06.320 --> 26:15.000]  а второе когда x не лежит в множестве x у нас все события между собой 1 на m значит n делить на
[26:15.000 --> 26:22.280]  м понятно да где
[26:22.280 --> 26:40.000]  так 1 делить на m минус 1 не n m n минус 1 смотрите давайте еще раз ашат икс принимает какие значения
[26:46.000 --> 26:59.560]  нет нет вероятность исхода когда они равны между собой еще раз очень важна это вероятность какое
[26:59.560 --> 27:09.480]  назначение принимает ашат икс и какой ашат икс икс это это все оно принимает значение там от нуля
[27:09.480 --> 27:18.680]  до m минус 1 согласны они не зависит между собой как хотят так и принимают это рандомные числа
[27:18.680 --> 27:30.560]  они не зависящие между собой получается сколько у нас одинаковых парта м а разных пар ну точнее
[27:30.560 --> 27:40.960]  всевозможных пар м квадрат поэтому здесь получится 1 на м как раз ага еще есть вопросы
[27:40.960 --> 27:49.600]  доказательств понятно вот а ну важный момент типа все что связано с хэш таблицами это все
[27:49.600 --> 27:55.520]  математика вот тут нужно ее очень хорошо представлять какое следствие из этого всего
[27:55.520 --> 28:01.600]  мы получаем следствие такое что у нас результат работы всех операций это 1 плюс n делить на m
[28:01.600 --> 28:13.560]  значит что мы хотим сделать с этими операциями хороший вариант есть вопросик что с ним в этом
[28:13.560 --> 28:22.160]  случае делать но да а правильно что мы хотим вообще сделать с м как мы можем ее выбирать
[28:22.160 --> 28:31.840]  чтобы load фактор был меньше единицы окей и тогда временная сложность у от единички как это
[28:31.840 --> 28:43.800]  гарантировать м чему равно сделать n множить на 2 хорошо в действительности да как бы а так
[28:43.800 --> 28:50.760]  как у нас множество x может все время пополняться нам необходимо будет перехышировать нашу таблицу
[28:50.760 --> 28:58.800]  всегда поэтому здесь будет очень похоже на динамически расширяющийся массив у вас
[28:58.800 --> 29:06.040]  еще не было векторов правильно ага но какая суть динамически расширяющийся массивом давайте
[29:06.040 --> 29:13.520]  я сейчас буду почувствовать и мы с вами еще его потом об отдельно обсудим
[29:13.520 --> 29:29.640]  смотрите суть примерно следующее как только у вас грубо говоря количество элементов количество
[29:29.640 --> 29:42.040]  бакетов станет равная n то в этом случае вы делаете новый массив которым m будет равно уже 2
[29:42.040 --> 29:50.760]  и перехашируйте все элементы которые у вас есть и переносите их каким-то образом а динамически
[29:50.760 --> 29:56.400]  расширяющимся массивы переносите прям вниз а здесь вы выбираете новую хэш функции и перекидываете
[29:56.400 --> 30:04.280]  их между собой понятно выбирайте с ними что-то делать вот это нужно для того ну то есть это
[30:04.280 --> 30:09.120]  мультипликативная схема которая увеличивает все время на 2 чаще всего убирают коэффициент 2 но там
[30:09.120 --> 30:18.320]  можно выбрать 1 и 7 ничего не такое вот самое эффективное где-то 1 и 7 если не ошибаюсь это
[30:18.320 --> 30:23.840]  нужно делать потому что в этом случае у вас амортизационно будет тратиться всего лишь у
[30:23.840 --> 30:31.280]  от единички ресурсов почему поговорим об этом в динамически расширяемся динамически
[30:31.280 --> 30:39.280]  расширяющимся массиве хорошо вот здесь поверьте просто увеличивайте на два да
[30:39.280 --> 30:57.680]  наша хэш функция рандомно выбирает число для любого икса мы должны брать новые мы должны
[30:57.680 --> 31:02.920]  перехашировать абсолютно все мы не должны заново перекидывать иначе вы будете заново все
[31:02.920 --> 31:18.760]  перекидывать то у вас будет неравномерно понятно то мы берем новые хэш функции да ну когда как
[31:18.760 --> 31:29.160]  ну типа но я говорю мы ответим на этот вопрос в конце вот в общем-то как-то так идея следующая
[31:29.160 --> 31:38.120]  но то есть фактически алгоритм будет выглядеть так ну find erase понятно типа найти элемент понятно
[31:38.120 --> 31:45.560]  erase понятно если вы убираете вы не увеличиваете размер m поэтому все легко вот сенсор там нужно
[31:45.560 --> 31:52.200]  здесь чуть-чуть повозиться повозиться в каком случае если у вас x уже лежит в хэш табличке
[31:52.200 --> 31:58.000]  тогда вы просто возвращаете ничего не происходит если у вас n плюс один делить на m то есть при
[31:58.000 --> 32:02.840]  добавление этого элемента оно меньше либо равно единиц то вставляем просто в нашу корзину типа
[32:02.840 --> 32:10.440]  все как обычно методом цепочек а иначе если вот как раз таки у меня вот это равенство достигается
[32:10.440 --> 32:21.600]  я увеличиваю наше количество корзин на два и у меня становится два n вот а мы перегенерируем все
[32:21.600 --> 32:30.800]  хэш функции которые есть перевставляем старые элементы в новую хэш таблицу рандомно раскидывая
[32:30.800 --> 32:39.720]  элементы и вставляем потом x тоже в нашу хэш таблицу понятно вот время работы будет это за о от единички
[32:39.720 --> 32:49.800]  в амортизационном случае если вы легко вытаскиваете хэш функции откуда-нибудь окей понятно вам
[32:49.800 --> 32:55.560]  необходимы просто хэш функция представим что у нас есть вот это банк хэш функции я просто вытаскивать
[32:55.560 --> 33:03.160]  на данный момент вопросы есть мы кстати очень бодро идем я скажу да
[33:03.160 --> 33:24.200]  мы специально хотим сделать так чтобы мы находили вставляли удаляли элементы за вот единицы да
[33:24.200 --> 33:29.720]  мы не хотим искать это долго мы не хотим это делать основная функция хэш табличек это
[33:29.720 --> 33:38.120]  всегда find race insert для того чтобы быстро общаться между собой типа что там происходит понятно есть
[33:38.120 --> 33:55.960]  еще вопросы смотрите давайте еще раз а вот у меня есть некоторая таблица b в самом начале
[33:55.960 --> 34:05.160]  вы добавляете сюда элементы и решаете коллизии между собой метам цепочку да
[34:05.160 --> 34:19.840]  что одно и то же клетку но когда у вас одинаковая ну хэш функция аш от x равна аш от y когда x не
[34:19.840 --> 34:25.720]  равен y вот это коллизия у вас количество бакетов не обязательно одинаковая ну возьмем
[34:25.720 --> 34:34.840]  функцию не знаю тот же процент у тебя для ну от процент м например у тебя для единицы для
[34:34.840 --> 34:48.920]  м плюс один один и тот же бакет хэш функция еще раз это функция из множества иксо там ключей было
[34:48.920 --> 35:00.280]  множество к в вот это хэш функция у нас 6 и у кай это все количество ключей которые приходят к
[35:00.280 --> 35:10.520]  нам а здесь нуля да и минус 1 это просто некоторая функция за шесть чиселка вот еще а да да
[35:10.520 --> 35:16.200]  рассказать что здесь происходит вот у вас есть типа методы цепочек типа оно там как-то разрешает
[35:16.200 --> 35:24.640]  эти коллизии то есть вот тут вот x y вот здесь какой-нибудь их стрих y штрих z штрих там да вот
[35:24.640 --> 35:31.040]  вас есть вот эти вот коллизии и так далее в какой-то момент вы достигаете и амортизационно вы
[35:31.040 --> 35:40.000]  знаете что у вас работает за у от 1 плюс м делить на м значит вам нужно увеличить м в какой-то
[35:40.000 --> 35:45.000]  момент когда у вас станет перебор элементов для того чтобы была какая-то равномерность у меня
[35:45.000 --> 35:50.000]  здесь не равномерно но такое тоже случается потому что рандомно мы что-то выбирали может такое
[35:50.000 --> 35:54.960]  получиться но в случае когда у вас вот тут вот появится еще какой-нибудь элемент всего 5
[35:54.960 --> 36:06.160]  бакетов не на т вот но элемент стало больше вы создаете новую хэш таблицу который уже будет там
[36:06.160 --> 36:19.300]  ну тут 10 элементов должно быть вот вы создаете 10 элементов и перекидываете все элементы и
[36:19.300 --> 36:30.280]  x y и так далее уже в новую хэш таблицу да потому что у вас изменилась м то есть у вас до этого был
[36:31.280 --> 36:52.640]  а теперь у вас должна быть а штрих какая-то функция из к в 0 2 м минус 2 ой вот то есть вы должны
[36:52.640 --> 36:57.920]  уже брать хэш функцию отсюда для того чтобы вас опять же вот эта штука заполнялась равномерно
[36:57.920 --> 37:11.600]  хэш таблица иначе у вас будут проблемы еще раз хэш функция просто рандом выкидывает числа это
[37:11.600 --> 37:17.160]  все еще простое равномерное хэширование когда мы просто с помощью рандома берем числа рандомные
[37:17.160 --> 37:25.760]  числа они всегда равномерно не равномерно распределяются между собой вот еще есть
[37:25.760 --> 37:34.600]  вопросы здесь понятно хорошо какие есть технические здесь тонкости назовем это
[37:34.600 --> 37:44.040]  смотрите вот у меня есть хэш табличка за сколько будет работать вы вот всех элементов у от n
[37:44.040 --> 37:58.120]  плюс m это правда а хорошо ли это почему что еще раз м может быть большим так какие есть решения
[37:58.120 --> 38:06.760]  раз у кого-то был семинар давайте поговорим о том как это решать то можно указатели хранительные
[38:06.760 --> 38:16.320]  элементы да смотрите решением все эти вещи является примерно следующим давайте в хэш таблице
[38:16.320 --> 38:26.400]  который у нас есть а мы будем хранить указатели на элементы а сами все элементы которые приходят
[38:26.400 --> 38:45.680]  к нам в хэш таблицу мы будем хранить списки ну и так далее вот у нас есть список а согласны ли
[38:45.680 --> 38:51.040]  вы что у нас есть метод цепочек как бы все ок нужно просто его как-то здесь применить как
[38:51.040 --> 38:59.720]  мы это делаем вот у меня есть массив вот этот вот б а у меня нету здесь мелков классных поэтому
[38:59.720 --> 39:06.880]  буду чиселки проставлять вот у меня есть первая хэш функция я знаю что у нее у коллизии там не две
[39:06.880 --> 39:15.840]  я говорю что пусть она показывает мне на начало и вот это и вот это относится к первой хэш функции
[39:15.840 --> 39:23.960]  к первому моему бакету второй бакет ну не знаю там пусто пусть будет у них к нему ничего не
[39:23.960 --> 39:31.240]  пришло еще третьему бакету всего там не знаю одна то есть здесь в чем суть у меня все элементы
[39:31.240 --> 39:40.680]  с одним и тем же хэшом идут подряд а 4 но пусть тоже не было пятый два вот этих вот которые у
[39:40.680 --> 39:47.040]  меня здесь есть ну там что и седьмой может есть может нет не знаю вот у меня есть вот такие вот
[39:47.040 --> 39:59.800]  вещи что мне позволяет делать список проход делать за отэм то есть мы можем вывести все
[39:59.800 --> 40:17.160]  элементы за о отэм еще вставка и удаление на самом деле тоже за единичку и поиск ну как бы как
[40:17.160 --> 40:23.400]  здесь искать элементы мы просто будем сравнивать еще хэши как мы поймем что мы вышли в другую
[40:23.400 --> 40:31.240]  цепочку а другой хэш будет то есть у меня хэш здесь мы знаем там он конкретно и здесь
[40:31.240 --> 40:39.720]  хэш вообще другой становится согласны вот поэтому здесь все достаточно понятно как это делать но
[40:39.720 --> 40:48.640]  для того чтобы удалять и вставлять элементы скажите мне пожалуйста давайте так продолжу что да мы
[40:48.640 --> 40:53.920]  просто будем проверять хэши а какой список нам здесь необходимо хранить как вы думаете
[40:53.920 --> 41:05.040]  а сейчас давайте еще раз можно одна связанная буду спрашивать как на двух связанных а почему
[41:05.040 --> 41:20.640]  а предыдущему хешу чтобы вот так вот перевязать правильно хорошо а это правда но есть проблемы с
[41:20.640 --> 41:30.960]  двух связанного списка смотрите помимо самого элемента вы будете хранить следующий предыдущий
[41:30.960 --> 41:41.360]  а еще возможно хэш функции очень много не кажется давайте сокращать память мы пытаемся
[41:41.360 --> 41:46.480]  работать с памятью тоже эффективно можно действительность на односвязанном списке как
[41:46.480 --> 41:55.720]  как сделать на односвязанном списке удалять элемент но вот смотрите вот у меня тройка указывает
[41:55.720 --> 42:02.240]  сюда как мне вот вот типа удалить вот этот элемент и перевязать вот этот вот элементик
[42:02.240 --> 42:19.720]  а как здесь еще раз у меня хэш функции лежит вот тут это долго и как ты будешь находить предыдущую
[42:19.720 --> 42:31.560]  цепочку то еще назад то потом еще назад это становится у отем так не подходит от
[42:31.560 --> 42:36.120]  логарифмонт не подходит хочу вот единица
[42:44.680 --> 42:50.360]  а почти но нет давайте еще предложение
[42:50.360 --> 43:06.360]  какую вот тут а нет потому что в этом случае у вас будет вывод не за у отем не за у от
[43:06.560 --> 43:15.440]  элемента всех мне нужно чтобы все элементы выводились типа за отн да нет
[43:15.440 --> 43:27.640]  сейчас неприятно а
[43:27.640 --> 43:39.400]  тогда вставку как не делать ну типа это такая проблема курица яйца поменяем
[43:39.400 --> 43:52.480]  направление мне нужно вставить будет элемент еще поменяем направление куда
[43:52.480 --> 44:04.680]  какому да да а если мне нужно удалить хорошо элемент типа какой-то другой
[44:08.680 --> 44:21.760]  например там а какой методом цепочек еще раз у нас есть три сейчас момент нас есть три вот
[44:21.760 --> 44:28.600]  у меня хэша треху вот оно относится вот сюда к примеру но три условно это звездочка это
[44:28.600 --> 44:36.240]  какой-то элемент третьей так бакет третьей вот то есть нет так хэша тыкс равно три вот так
[44:36.240 --> 44:50.680]  должно быть в этом случае здесь у меня лежит указатель на лист конечно если у вас бакет зафиксировано
[44:50.680 --> 45:01.080]  туда если вы перехожи ручь то нет ну конечно иначе будет не работала как искать элементы еще раз
[45:01.080 --> 45:12.680]  у меня было определение вот тут если x новый ключ то мы считаем хэш функцию если старый то старый
[45:12.680 --> 45:40.840]  хэш хэш используем больше указатель и богу указатель неприкольно
[45:40.840 --> 45:50.360]  неприкольно неприкольно все равно нужно где-то хранить еще ладно смотрите действительность
[45:50.360 --> 46:07.080]  идея следующая давайте хранить указатель просто предыдущий предлагала хранить не тут а тут тогда
[46:07.080 --> 46:13.240]  прости тогда прости я думал ты вот тут имела в виду что хочешь здесь вот и тогда это в
[46:13.240 --> 46:20.640]  действительности так работает у вас forward листах будет типа insert авто erase авто и так далее вот
[46:20.640 --> 46:27.960]  существуют такие вот у него методы в действительности когда вы дойдете до стли вам булат это все расскажет
[46:27.960 --> 46:34.600]  вот тогда в этом случае удалять гораздо проще если вам нужно удалить первый элемент то все хорошо
[46:34.760 --> 46:42.280]  в этот первый элемент удаляйте и перекидывайте вот этот указатель через него все окей вот если
[46:42.280 --> 46:50.360]  вам нужно вставить ну ставьте здесь нет никакой проблемы вставьте просто вот сюда же скиньте
[46:50.360 --> 46:56.160]  на него указатель это сюда это все будет работать за у от единичку поэтому это делается вообще на
[46:56.160 --> 47:13.200]  односвязных списках вот это да чтобы экономить память да да
[47:13.200 --> 47:31.320]  память небезгранична время тоже константы важны а еще раз типа а симпатически не всегда означает
[47:31.320 --> 47:38.040]  хорошо по константе мы с вами познакомимся с фибоначевой пирамидой в этом семестре она
[47:38.040 --> 47:47.160]  будет давать хорошие результаты для не знаю алгоритма д экстре а симпатически но это работает
[47:47.160 --> 47:53.800]  только симпатически в реальном мире оно не работает но на бумажке работает симпатически
[47:53.800 --> 48:01.800]  константа очень важна константу тоже нужно беречь грубо говоря вы будете использовать не знаю 3 гигабайт
[48:01.800 --> 48:11.480]  или 4 гигабайта оперативной памяти все одно и то же но вот тут вот 4 чиселка или 3 вот все играет на
[48:11.480 --> 48:31.760]  масштабах конечно но это судьба я часть да именно такая вот оно это все что
[48:31.760 --> 48:38.520]  касается простого равномерного хеширования мы даже с вами уложились в 40 с чем-то нет 50 чем-то
[48:38.520 --> 48:47.120]  минута вот но почти все глобальная проблема в следующем а существует ли простое равномерное
[48:47.120 --> 48:59.720]  хеширование как вы думаете все в даран дом все дела такое себе чудо а почему нет
[48:59.720 --> 49:18.560]  не пойму здесь причем оно но ладно и что там написано почему главный результат помню все
[49:18.560 --> 49:30.160]  правильно нет здесь не в этом проблема ну рандомы к сортам тоже рандомно получится а примеры
[49:30.160 --> 49:36.160]  потом вы перезапустите он заработает в этом сути рандома вот когда-то работа когда-то нет
[49:36.160 --> 49:46.720]  в действительности следующее ну как бы по-хорошему для того чтобы выбирать рандомную хеш функцию вам
[49:46.720 --> 49:57.720]  нужно их как хранять правильно вот предположим что не знаю у вас вот есть какой-нибудь к а не
[49:57.720 --> 50:05.680]  знаю там интовая к примеру а вот какая-то ну типа над каким ножем мы работаем множество ключей
[50:05.680 --> 50:14.920]  ну вас 6 int просто там у него 10 в 9 если мы возьмем мощность множество хэш функций у тебя сколько
[50:14.920 --> 50:24.920]  всего существует то это будет а м в степени а то это в степени м степеньем модуль к для того
[50:24.920 --> 50:34.440]  чтобы какое-то множество размером n с помощью бит нам необходим логарифм бит согласны у вас
[50:34.440 --> 50:41.000]  есть любое число какое-то вы хотите записать его в битах логарифм нужно во степени двоечки
[50:41.000 --> 50:52.920]  там появляются согласны или не согласны беда скорее согласны хорошо ладно подумайте над этим
[50:52.920 --> 50:59.000]  фактом сегодня вечером в общем-то если мы возьмем логарифм от этого всего то у нас получится
[50:59.000 --> 51:09.040]  мощность к на логарифм м но мощность к это все значения это 4 на 10 девятый примерно бит это
[51:09.040 --> 51:21.960]  очень много бит это очень проблемно понятно ну то есть это там что 2 в 30 то есть чем-то даже
[51:21.960 --> 51:33.560]  так 233 наверное где-то а бит ну вот и посчитайте вас будет там что байт ну где-то килогигабайт
[51:33.560 --> 51:54.360]  что не очень хорошо длинта да это есть сами функции мы должны как-то вот типа ну хранить
[51:54.360 --> 52:02.080]  внутри но это вот первое объяснение теоретической такой теоретической информатике то есть просто
[52:02.080 --> 52:07.720]  сколько у нас есть место для того чтобы сохранить все функции которые есть я же
[52:07.720 --> 52:13.680]  рандомно выкидываю функцию тоже беру это любая рандомная функция поэтому на рандомное выкидывать
[52:13.680 --> 52:21.880]  число вот поэтому это не подходит это не прикольно ну а последнее как понять что встречался ли икс
[52:21.880 --> 52:28.920]  для того чтобы старый хэш посчитать ну для этого по-хорошему тоже нужна хэш функция вот
[52:28.920 --> 52:34.360]  а для этой функции хэш таблицы нужно еще одна хэш таблица ну и так далее мы рекурсивно идем в
[52:34.360 --> 52:40.400]  хэш таблице чтобы тоже не очень круто поэтому ну как бы с двумя этими определениями мы выжить
[52:40.400 --> 52:49.080]  нормально не можем это то что касается простого равномерного хэширования есть ли у вас тут
[52:49.080 --> 52:55.000]  вопроса очень кратко пытаюсь вам изложить всю информацию потому что была презентация надеюсь
[52:55.000 --> 53:04.560]  вы видели задавайте вопрос хорошо тогда мы переходим ко второй теме это вторая лекция
[53:04.560 --> 53:12.280]  должна быть я бы с вами побольше говорил но тут получается чуть поменьше мы с вами поняли что у
[53:12.280 --> 53:18.720]  нас нету простого равномерного хэширования это плохо для нас потому что для нее мы такую
[53:18.720 --> 53:24.120]  восхитительную теорию доказали что она все работает может быстро просто надо взять m равно n
[53:24.120 --> 53:30.320]  грубо говоря и тогда все будет работать отлично но здесь у нас так не работает и мы переходим к
[53:30.320 --> 53:37.480]  так называемому универсальному хэшированию а которая у нас есть старый не работает возьмем
[53:37.480 --> 53:45.280]  новое но будем строить его на основе старого смотрите мы хотим найти какое-то небольшое
[53:45.280 --> 53:51.360]  семейство являюсь под множеством вот всех вот этих хэш функций которая обладала бы все теми
[53:51.360 --> 54:00.800]  же свойствами что и простое равномерное хэширование то есть нам необходимо так взять и придумать что-то вот
[54:00.800 --> 54:08.960]  мы хотим вот из этого всего кусочка кусочка их нить хэш функции мы хотим выбрать маленький
[54:08.960 --> 54:18.120]  который обладает теми же свойствами ага вот и нам нужно придумать что это такое ну смотрите
[54:18.120 --> 54:24.960]  а в каком случае вот универсальным семейством как раз таки это и называется мы пытаемся найти
[54:24.960 --> 54:31.680]  это универсальное семейство семейство называется универсальным если при выборе какой-то хэш
[54:31.680 --> 54:38.640]  функции из этого семейства выполнялось бы свойство что для любого x и y из нашего множества ключей
[54:38.640 --> 54:47.440]  а вероятность того что случилась коллизия меньше либо равна чем один делить на м м количество
[54:47.440 --> 54:54.960]  бакетов понятно вот мы хотим сделать так чтобы у нас вот универсальное семейство существовало
[54:54.960 --> 55:05.440]  именно в этой концепции мира и попробовать с ней что-то сделать напомню про простой равномерное
[55:05.440 --> 55:12.240]  хэширование вот у нас была с вами теорема что там работает за у от 1 плюс альфа мы говорим что
[55:12.240 --> 55:19.000]  если мы заменим простой равномерное хэширование в этой теореме на универсальные семейства хэш
[55:19.000 --> 55:28.800]  функций то в этом случае все будет хорошо и все будет работать ровно так же то есть для универсального
[55:28.800 --> 55:36.560]  семейства работает ровно та же теорема мы можем сказать что это все работает за о от 1 плюс альфа
[55:36.560 --> 55:46.360]  ага как это сделать но это сделать достаточно просто смотрите не меняются почти никакие пункты
[55:46.360 --> 56:01.120]  кроме быть может а вот этот вот где 4 написано почему как бы да из-за того у нас было равенство
[56:01.120 --> 56:09.080]  стало неравенством просто из-за того что у нас универсальное семейство здесь имеет неравенство
[56:09.080 --> 56:15.360]  меньше либо равно 1 делить на м окей вот из-за этого получилось неравенство во всем остальном это
[56:15.360 --> 56:29.720]  одинаковое это пока понятно ясно что это работает взяли кусочек заработал хорошо давайте тогда
[56:29.760 --> 56:36.800]  разбираться с примерами которые есть вам их нужно будет реализовывать так что подумайте о том что
[56:36.800 --> 56:45.680]  это вам полезно смотрите я хочу взять множество у меня здесь слайды почти без интриг у вас сразу
[56:45.680 --> 56:52.600]  идет доказательства с ним учу и так далее вот поэтому думайте о том почему там так написано
[56:52.600 --> 57:04.440]  вот а я хочу взять множество ключей как zp то есть множество вычитов пп где п это
[57:04.440 --> 57:15.000]  простое число именно простое число я хочу взять в качестве а аж то есть моего множество
[57:15.000 --> 57:26.360]  х функции это будет функция вида а икс плюс б процент п процент м п из предыдущего по какому
[57:26.360 --> 57:36.640]  вычету нас было м это количество бакетов где а это тоже входит множество вычитов по п без нуля
[57:36.640 --> 57:42.880]  только то есть у меня должно быть все-таки не просто б процент по процентам вот а икс
[57:42.880 --> 57:51.000]  какой-нибудь вот и бы я тоже лежит в этом множестве zp и тогда я утверждаю что это множество аж оно
[57:51.000 --> 58:10.400]  универсальное а и б мы берем разные п это множество ключей откуда принимает икс оно
[58:10.400 --> 58:26.720]  не может увеличиваться у вас м может увеличиваться по нет ага да да для конкретной
[58:26.720 --> 58:37.200]  подзадачи если брать конкретнее то поверьте мне вы с такой сталкнетесь вот мы говорим о том что
[58:37.200 --> 58:44.040]  вот такое множество х функции оно является у нас универсальным то есть какую функцию оттуда не
[58:44.040 --> 58:52.760]  восьми у них вероятность того что будут коллизия 1 делить на м для конкретного множества ключей как
[58:52.760 --> 58:58.560]  мы это делаем мы делаем следующим образом мы возьмем рандомный x и грек что они неравны между
[58:58.560 --> 59:05.840]  собой и скажем что икс трих это вот как раз без процента м х функция и грек штрих это без процента
[59:05.840 --> 59:13.200]  м тоже ну то есть это а икс плюс б процент п и а и грек плюс б процент п выясним друг из друга
[59:13.200 --> 59:20.000]  икс штрих и грек штрих что я получу я получу ну как бы я могу все внести под одну скобочку получу
[59:20.000 --> 59:28.840]  а от икс минус игрек процент п а не ноль икс не равен игрек поэтому икс минус игрек не ноль п
[59:28.840 --> 59:36.080]  простое все хорошо у нас не будет ничего оно не выйдет за границу мою zp получается это не нулевая
[59:36.080 --> 59:45.280]  часть правильно то есть икс трих минус игрек штрих не нулевые а значит икс штрих не равны игрек
[59:45.280 --> 01:00:01.560]  штрих понятно да отлично вот следующее мое утверждение я говорю что существует биекция
[01:00:01.560 --> 01:00:09.880]  между всем возможными икс трих игрек штрих и а бы но то есть грубо говоря когда у меня есть какие-нибудь
[01:00:09.880 --> 01:00:17.120]  икс игрек я могу подобрать любые обе получив любые икс штрих игрек штрих эти множества одинаковые
[01:00:17.120 --> 01:00:22.560]  между собой то есть я с помощью одного могу перейти в другое и определить что там было понятно что
[01:00:22.560 --> 01:00:31.640]  я делаю а да отлично хорошо ну как это сделать ну давайте просто решим стим линейных уравнений
[01:00:31.640 --> 01:00:38.800]  можно ее решить подставить вот как здесь написано я просто не знал бы на линале прошли систему
[01:00:38.800 --> 01:00:47.480]  линейных уравнений или нет еще да да хорошо ну в общем-то можно сказать что здесь матрица матрица
[01:00:47.480 --> 01:00:55.520]  не вырожденная просто если очень хочется но одно из двух короче вот ну как бы вы можете все
[01:00:55.520 --> 01:01:01.560]  подставить получить и здесь будет действительно какое-то число оно все не нулевое это хорошо и
[01:01:01.560 --> 01:01:08.800]  мы получаем единственное решение для а и б через икс игрек икс штрих игрек штрих икс игрек у
[01:01:08.800 --> 01:01:14.160]  меня фактически зафиксировано я взял произвольные вот я с ними ввожусь их штрих игрек штрих я
[01:01:14.160 --> 01:01:19.960]  говорю что через них я получаю а и б единственным способом что логично оно не может быть не
[01:01:19.960 --> 01:01:28.320]  единственным в этом случае окей принято хорошо ну и а для того чтобы сказать что действительно
[01:01:29.280 --> 01:01:34.920]  нам нужно еще что нам нужно еще все-таки сказать что у нас размер множества одинаковые то есть
[01:01:34.920 --> 01:01:39.720]  меня в одну сторону должно быть правда и в другую сторону должно быть правда но как нам сказать это
[01:01:39.720 --> 01:01:47.800]  ну давайте посчитаем мощность множество мощность множество а и б какое почему
[01:01:47.800 --> 01:01:58.720]  всевозможные ну то есть а может принимать п-1 вариант б может принимать п согласны а икс
[01:01:58.720 --> 01:02:04.520]  штрих игрек штрих вот та пара которая там находится она может принимать аналогичное значение почему
[01:02:04.520 --> 01:02:09.880]  потому что они не равны все правильно если я икс штрих фиксирую то там становится у игрек
[01:02:09.880 --> 01:02:28.000]  штрих п-1 вариант круто какого порядка а ты имеешь в виду с точки зрения реализации или что
[01:02:28.000 --> 01:02:42.340]  точки зрения м здесь все зависит от того что ты хочешь получить напомню мы доказываем для
[01:02:42.340 --> 01:02:50.760]  какой серии для вот этой правильно n делить на м n это что количество элементов сколько у нас
[01:02:50.760 --> 01:03:03.960]  количество элементов zp я ответил на твой вопрос вот видишь как хорошо отлично в общем-то перейдем
[01:03:03.960 --> 01:03:11.880]  к икс штрих игрек штрих нам нужно понять какая вероятность того что икс штрих процент м равен
[01:03:11.880 --> 01:03:18.320]  икс штрих процент м потому что мне нужно понять коллизию хэш функции согласны ну икс штрих игрек
[01:03:18.320 --> 01:03:25.200]  штрих они вот этот первый кусок хэш функции который в квадратных скобочках правильно это
[01:03:25.200 --> 01:03:35.400]  понятно пока вот я просто беру вот этот процент м мне нужно понять вероятность того сколько у них
[01:03:35.400 --> 01:03:42.000]  может быть коллизий но здесь все достаточно просто икс штрих мы можем выбрать п различными
[01:03:42.000 --> 01:03:48.080]  способами ну логично у меня п вариантов мы переходим просто от икс игрека к икс штрих игрек
[01:03:48.080 --> 01:03:53.480]  штрих они взаимосвязаны между собой там нет никаких проблем вот икс штрих можно выбрать
[01:03:53.480 --> 01:04:00.480]  по различным способам потому что у нас вычет по п правильно правильно вот какими способами
[01:04:00.480 --> 01:04:03.600]  мы можем выбрать игрек чтобы у нас было равенство
[01:04:13.600 --> 01:04:25.680]  ну типа того да но вот к вот здесь вот у меня просто написано для примера это правда но
[01:04:25.680 --> 01:04:31.360]  действительности п делить на м почему потому что вот эти кусочки я выбираю единственное
[01:04:31.360 --> 01:04:36.960]  чему не может быть равен игрек штрих от чему это икс штрих правильно поэтому я должен буду
[01:04:36.960 --> 01:04:46.840]  вычитать еще минус единицу я округляю это вверх окей ну типа все здесь понятно надеюсь вот максимальное
[01:04:46.840 --> 01:04:52.680]  количество раз это такое но мощность множество у меня какая п на п минус 1 мы только что с вами
[01:04:52.680 --> 01:05:04.640]  про это говорили да да отлично продолжаем это веселье я я я обещал математику я ее приношу вот
[01:05:04.640 --> 01:05:13.560]  продолжаем это же веселье смотрите мы говорим что п делить на м округленное ну во первых
[01:05:13.560 --> 01:05:19.280]  п я могу сократить между собой я думаю вы это понимаете это отлично п делить на м минус 1 ну как
[01:05:19.280 --> 01:05:25.600]  я могу п делить на м представить верхнюю оценку это п плюс м минус 1 делить на м согласны
[01:05:25.600 --> 01:05:33.840]  это максимальная оценка вот делаю минус единицу делю на п минус 1 эту минус единицу я подставляю
[01:05:33.840 --> 01:05:43.080]  туда дальше я получаю что п плюс м минус 1 минус м и все это делить на м п минус 1 окей ну а теперь
[01:05:43.080 --> 01:05:53.160]  вычитаем получаем п минус 1 делить на м п минус 1 получая 1 на м то есть у меня вот это универсальное
[01:05:53.160 --> 01:06:01.720]  семейство хэш функций вероятность их коллизий если я возьму вот зафиксировать эту хэш функцию
[01:06:01.720 --> 01:06:09.120]  какой-нибудь вероятность коллизий там будет всего лишь один делить на м меньше либо равно все
[01:06:09.120 --> 01:06:17.080]  правильно а значит это семейство универсальное а если оно универсальное то у меня за сколько
[01:06:17.080 --> 01:06:26.640]  работает поиск 1 плюс альфа альфа не забывайте n делить на им ну здесь п делить на им в этом
[01:06:26.640 --> 01:06:38.200]  случае принято это принято чудно тогда давайте чуть-чуть дальше существует пример естественно
[01:06:38.200 --> 01:06:49.720]  не универсального хэш семейства давайте просто бы уберем вот уберем бы и все оставим тоже множество
[01:06:49.720 --> 01:06:57.080]  ключей все будет также все то же самое что а без нуля но мы убираем бы что в этом случае происходит
[01:06:57.080 --> 01:07:02.800]  как доказать что семейство не является универсальным нужно найти такие иксы иксы и игреки что у нас
[01:07:02.800 --> 01:07:08.320]  вероятность будет больше чем один делить на м согласны м я могу фиксировать как хочу п могу
[01:07:08.320 --> 01:07:17.640]  фиксировать как хочу а могу выбирать какой хочу x и y аналогично вот но вот это а оно и будет вот
[01:07:17.640 --> 01:07:27.680]  этой вероятностью которую мы вытаскиваем ну смотрите давайте зафиксирую п 7 м 2 x 1 y 3 ну вот
[01:07:27.680 --> 01:07:36.720]  такие вот числа мне пришли в голову догадаться до них но это пример как не знаю ну типа как вы
[01:07:36.720 --> 01:07:43.800]  любите догадываться до по в эмоциональном анализе когда вы выбираете потенциал вот плюс
[01:07:43.800 --> 01:07:52.320]  минус также вот типа взято с потолка покажем что вот поэтому это ближе туда в общем-то мы смотрим
[01:07:52.320 --> 01:07:59.440]  при всех значениях а так у нас выглядит х функции аш от x и аш от y у меня всего две корзины поэтому
[01:07:59.440 --> 01:08:06.680]  это 0 и 0 единички вероятность должна быть меньше чем 1 вторая если бы это было универсальное
[01:08:06.680 --> 01:08:13.880]  семейство х функции в этом же случае если я подставляю а аш от x и аш от y я получаю что
[01:08:13.880 --> 01:08:23.800]  вероятность здесь будет 2 третьих ага а если вероятность 2 третьих это больше чем 1 вторая
[01:08:23.800 --> 01:08:34.520]  получается семейство не универсальное принято вот вот такой вот тут маленький пример а естественно
[01:08:34.520 --> 01:08:41.320]  вы можете по упражняться доказать обратное что давайте мы бы оставим а уберем если вам будет
[01:08:41.320 --> 01:08:50.120]  очень интересно дома по упражняйтесь кто знает может быть вас ждет такой на контрольный вот так
[01:08:50.120 --> 01:09:07.400]  сказать тонко намекаем а подумайте об этом нет а если а равно единички да да я понял под множество
[01:09:07.400 --> 01:09:10.600]  но кто сказал что под множество универсального множества это универсальное множество
[01:09:12.320 --> 01:09:14.560]  по-моему я нигде не утверждал то
[01:09:27.440 --> 01:09:40.720]  да но ты должна понимать что у меня а выбирается единицей но ты ее фиксируешь тогда эту единицу
[01:09:40.840 --> 01:09:53.200]  а я не фиксирую здесь ничего да принято так что подумайте над этим на досуге
[01:09:53.200 --> 01:09:59.880]  окей ну и последнее смотрите мы с вами поговорили про простой равномерное хэширование мы с
[01:09:59.880 --> 01:10:06.480]  вами поговорили про универсальное хэширование теперь перейдем к идеальному хэшированию куда
[01:10:06.480 --> 01:10:13.600]  уж может быть лучше смотрите как работает идеальное хэширование я поверьте я даже
[01:10:13.600 --> 01:10:22.920]  до 2000 закончу хотя посмотрим вот давайте так посмотрим на идеальное хэширование статического
[01:10:22.920 --> 01:10:28.720]  множество идеальное хэширование может работать только вот для статического множества не работает
[01:10:28.720 --> 01:10:32.520]  когда у нас оставляются какие-то элементы потому что они все-таки увеличиваются или что-то с ним
[01:10:32.520 --> 01:10:38.760]  происходит поэтому я фиксирую какое-то множество то есть оно у меня зафиксировано множество вот
[01:10:38.760 --> 01:10:49.440]  этих вот иксов которые принимается я хочу на этом множестве построить хэш таблицу без коллизий вот
[01:10:49.440 --> 01:10:55.840]  это будет универсально идеально потому что тогда я смогу находить элементы за это от единички согласны
[01:10:55.840 --> 01:11:08.280]  понятно то есть никакой операции insert и erase нет у вас есть только поиск понятно вот вы смотрите
[01:11:08.280 --> 01:11:16.720]  вот по этим элементам есть они нет нужно что-то для них тоже доказывать для этих элементов смотрите
[01:11:16.720 --> 01:11:26.840]  пусть это число коллизий в хэш таблице вот когда-нибудь я это поправлю число коллизий в хэш
[01:11:26.840 --> 01:11:33.640]  таблице тогда согласны ли вы с тем что количество коллизий это вот эта сумма с индикатором
[01:11:33.640 --> 01:11:46.360]  аха перебор всех пар но типа в одну сторону что у нас первое всегда меньше число без повторов
[01:11:46.360 --> 01:11:54.840]  все верно согласны с индикатором понятно давайте посчитаем среднее число коллизий в хэш таблицы
[01:11:54.840 --> 01:12:00.720]  размеры м при выборе какого-то аж из универсального семейства то есть я универсальные
[01:12:00.720 --> 01:12:07.920]  семейства все еще держу себя но вот я хочу понять количество коллизий которые у нас есть я выбираю
[01:12:07.920 --> 01:12:14.360]  средняя ну то есть я считаю среднее число коллизий это средняя по сумме индикаторов значит я
[01:12:14.360 --> 01:12:24.920]  могу так как средняя суммы это сумма средних я вношу это среднее внутрь средняя индикатора это
[01:12:24.920 --> 01:12:37.640]  вероятность правильно вернемся к этому же вероятность того что они равны между собой а вероятность
[01:12:37.640 --> 01:12:44.840]  того что равны между собой хэши в универсальном семействе множеств у универсальной семействе
[01:12:44.840 --> 01:12:53.280]  хэшей и горе господи прости оно меньше либо равно одной делить на м правильно поэтому у меня
[01:12:53.280 --> 01:13:04.920]  получается сумма 1 делить на м да ну и получается всего это n на n минус 1 пополам 1 делить на м
[01:13:04.920 --> 01:13:12.920]  согласна принято вот столько у нас может быть коллизий в универсальном семействе хэш функции
[01:13:12.920 --> 01:13:25.680]  окей хотите небольшой перерывчик можете можем устроить типа или вам нужно добить и все
[01:13:25.680 --> 01:13:38.240]  нет у вас сегодня две лекции если что это вторая уже идет ну то есть это вот те два кусочка
[01:13:38.240 --> 01:13:45.440]  которые я должен был вам рассказать побольше а тогда не но все принято хорошо
[01:13:55.680 --> 01:14:00.600]  если знаем туда
[01:14:18.600 --> 01:14:22.920]  а проблема в том что ты должен сначала считать все вот эти вот элементы которые к тебе придут
[01:14:22.920 --> 01:14:33.200]  ты не можешь работать без вся нет вставки в идеальном хэширование еще раз ага вот есть
[01:14:33.200 --> 01:14:40.760]  проблема в общем-то что нам нужно еще нам нужно кое-что еще есть и р вера называется это леммой
[01:14:40.760 --> 01:14:49.240]  маркова слышал кто-нибудь такое слышал познакомитесь более обобщенном виде в действительности
[01:14:49.240 --> 01:14:54.880]  что такое леммаркова леммаркова говорит следующее что пусть у меня x это какая-то случайная
[01:14:54.880 --> 01:15:04.960]  величина там вот мы будем рассматривать на натуральных числах с ноликом вот тогда для
[01:15:04.960 --> 01:15:11.280]  любого эпсилон больше нуля вероятность того что x больше чем эпсилон вот эта случайная величина
[01:15:11.280 --> 01:15:17.840]  больше чем эпсилон она меньше либо равна чем средний x делить на эпсилон понятно
[01:15:17.840 --> 01:15:28.240]  вот суть такая как это доказывается доказать через среднее икса средний икса это просто
[01:15:28.240 --> 01:15:37.520]  сумма всех вероятностей к сов на x да это больше либо равно чем я икс ограничусь снизу икс больше
[01:15:38.160 --> 01:15:45.720]  согласно ну я просто типа убрал кусочек нижний отлично а если я брал кусочек нижний то это больше
[01:15:45.720 --> 01:15:54.840]  либо равно чем я бы взял x равный эпсилон ага эпсилон я могу вынести у меня остается просто
[01:15:54.840 --> 01:16:02.840]  сумма всех вероятностей x равно x на сумму всех вероятностей это вероятность того что x больше
[01:16:02.840 --> 01:16:12.560]  бравен а тут эпсилон ссоре не x маленькая и эпсилон окей как бы это логично да
[01:16:12.560 --> 01:16:19.560]  понятно почему сумма вероятности что x больше эпсилон это то же самое что вероятность что x
[01:16:19.560 --> 01:16:32.880]  больше эпсилон не страшно не отвечаете да в действительности это так хорошо давайте я
[01:16:32.880 --> 01:16:39.280]  утвержду этот момент вот да там x маленькая это некорректно вот этот кусочек там неправильно
[01:16:40.280 --> 01:16:53.280]  да конечно но это маленький кусок ну типа здесь очень просто вам она понадобится это
[01:16:53.280 --> 01:16:56.680]  лемма понимаете типа я не даю просто так вот в чем проблема
[01:16:56.680 --> 01:17:14.960]  вас ну смотрите это не мотана тярвера другое понимая но что поделать пока что вот так поверьте
[01:17:14.960 --> 01:17:20.440]  концу семестры мы будем рассказывать и показывать на руках но вот когда-то кто-то ко мне подходил
[01:17:20.440 --> 01:17:32.600]  говорил очень нематематично непонятно почему вот математика нужно с ней жить в общем-то про
[01:17:32.600 --> 01:17:44.100]  идеальное хэширование что важно помнить давайте спокойнее спокойнее друзья ага в общем-то а
[01:17:44.100 --> 01:17:51.020]  какая здесь теорема с идеальным хэшированием это вот теорема 2 я назвал смотрите пусть h из
[01:17:51.020 --> 01:17:58.380]  универсального семейства и m это n квадрат то есть количество бакетов это n квадрат тогда
[01:17:58.380 --> 01:18:07.260]  вероятность коллизии что количество коллизии больше единички меньше чем 1 вторая интересный
[01:18:07.260 --> 01:18:15.820]  факт как-то мы можем доказать мы можем доказать просто следующим образом посмотрите вероятность
[01:18:15.820 --> 01:18:21.540]  того что це больше либо равно 1 1 то есть количество коллизии больше либо равно 1 оно
[01:18:21.540 --> 01:18:30.660]  полиеми маркова меньше либо равно чем средняя ци делить на единицу согласны согласны отлично
[01:18:30.660 --> 01:18:39.860]  а что такое средняя по ц ну средняя ц мы уже тоже посчитали это n на n минус 1 пополам на 1
[01:18:39.860 --> 01:18:54.060]  дельтаем согласны а ну травну а не больше да сори лага вот не больше дальше просто
[01:18:54.060 --> 01:19:02.940]  вместо m подставляю n квадрат но я надеюсь что вы справите что n минус 1 делить на n делить
[01:19:02.940 --> 01:19:13.940]  на 2 n это меньше 1 и 2 правильно нет на 2 n n минус 1 делить на 2 но n шутки 1 я сократить
[01:19:13.940 --> 01:19:22.140]  могу да ладно извините но я надеюсь этот факт вам понятен получается это меньше 1
[01:19:22.620 --> 01:19:31.460]  отлично то есть у нас в случае m равны n квадрат вероятность того что количество коллизии будет
[01:19:31.460 --> 01:19:42.540]  больше единиц и больше либо равно это 1 2 меньше 1 2 это очень мало у вас грубо говоря за две
[01:19:42.540 --> 01:19:47.860]  итерации вот если вы один раз сделали у вас не получилось и у вас появились коллизии сделайте
[01:19:47.860 --> 01:19:54.580]  второй раз и у вас скорее всего получится построить нужную хэштаблицу без коллизий согласны
[01:19:54.580 --> 01:20:00.540]  то есть я все также беру универсальное семейство хэш функции просто размер бакет в делу n квадрат
[01:20:00.540 --> 01:20:13.100]  вот но в чем проблема здесь ну не памяти много действительность у нас проблема в том что m
[01:20:13.100 --> 01:20:18.660]  равно n квадрат вы представьте что у вас количество ключей возможных типа которые приходят вам это
[01:20:18.660 --> 01:20:30.100]  там 10 9 это кошмар это очень очень много поэтому здесь есть проблема память проблема действительно
[01:20:30.100 --> 01:20:38.300]  с памятью какая идея решений проблема с этой памятью а давайте мы сделаем следующее что мы
[01:20:38.300 --> 01:20:51.380]  заведем хэштаблицу каждый ячейки который будем хранить другую хэштаблицу вот и для того чтобы то
[01:20:51.380 --> 01:20:58.220]  есть грубо говоря мы не будем вот так вот делать методом цепочек которые у нас там есть а если у
[01:20:58.220 --> 01:21:05.940]  нас будут какие-нибудь коллизии то мы внутри еще раз захешируем элементики то есть у нас был
[01:21:05.940 --> 01:21:13.860]  один хэш есть коллизия мы переходим к маленьким хэшам типа вот и мы перехешируем их и тогда
[01:21:13.860 --> 01:21:20.300]  у меня внутри там n квадрат согласны ли вы с тем что если я возьму там новую хэш функцию грубо
[01:21:20.300 --> 01:21:27.900]  говоря и постараюсь переделать что-то то там будет вероятность коллизии 1 2 меньше 1 2 по
[01:21:27.900 --> 01:21:35.220]  той теореме которая была согласна то есть давайте еще раз в чем суть его часть вот этого всего
[01:21:41.500 --> 01:21:47.020]  вот представьте что у меня есть вот этот кусок у меня здесь ашат икс какой-то он может быть равен
[01:21:47.020 --> 01:21:55.020]  там не на ашат игрек для того чтобы разрешить эту коллизию я хочу здесь вести новую хэштаблицу
[01:21:55.020 --> 01:22:11.860]  где у меня будет x и y аш штрих от аш от икс и аш штрих от аш от игрек а нет нет не ашат игрек
[01:22:11.860 --> 01:22:23.020]  ашат аш трих от игрек и аш трих от икс сори вот так а если у меня размер вот этого кусочка
[01:22:23.020 --> 01:22:32.540]  м квадрат ой н квадрат н и т в квадрате н и т это количество коллизий по факту вот в тот
[01:22:32.540 --> 01:22:38.420]  или иной момент времени вот если у меня н и т в квадрате то вот это количество коллизий здесь
[01:22:38.420 --> 01:22:48.580]  вероятность коллизий меньше чем 1 2 согласны понятно как я пришел к этому выводу задайте вопрос
[01:22:48.580 --> 01:23:05.700]  да потому что через цепочки оно все-таки занимает время я хочу для идеально сделать
[01:23:05.700 --> 01:23:16.300]  за это от единички я хочу сделать прям вот это от единицы честная вот что мы в этом случае
[01:23:16.300 --> 01:23:22.860]  вообще будем делать и как вообще жить вот смотрите я для каждой вот такой вот ячейки
[01:23:22.860 --> 01:23:36.220]  которые у меня есть буду делать свои хэштаблички вот и буду делать эти хэштаблички на там м1 равно
[01:23:36.220 --> 01:23:45.380]  н1 в квадрате ну и так далее там м и т равно н и т квадрате я вот создаю такие вот хэштаблички
[01:23:45.380 --> 01:23:50.940]  внутри когда у меня появляются коллизии в этом случае у меня все отлично все хорошо потому что
[01:23:50.940 --> 01:23:56.980]  у меня вероятность коллизии маленькая и если вдруг будет какая-то коллизия внутри вот этих
[01:23:56.980 --> 01:24:03.980]  маленьких хэштабличек тогда в случае я просто перехаширую мою таблицу и где-то на второй
[01:24:03.980 --> 01:24:13.700]  террации вас точно должно все заработать ну в хорошем случае если вы не заработает
[01:24:13.700 --> 01:24:27.580]  да но это достаточно не много вот окей последняя теорема 3 а кто нам вообще сказал что вот это вот
[01:24:27.580 --> 01:24:43.060]  эффективно по памяти ну по сути своей частично тогда вот но нам нужно по-хорошему просто показать
[01:24:43.060 --> 01:24:52.740]  что вероятно ну что если у меня m равно n вот это вот м глобально то есть количество бакетов аж
[01:24:52.740 --> 01:25:00.740]  это универсальное семейство хэш функции и в корзину и ты попала и ты элементиков тогда средняя сумма
[01:25:00.740 --> 01:25:09.380]  н и т в квадрате оно меньше чем 2 н почему это мне важно потому что для меня n квадрат это много
[01:25:09.380 --> 01:25:16.500]  но все-таки 2 н это не н квадрат это удобно правильно все должны показать что сумма вот этих квадратов
[01:25:16.500 --> 01:25:23.700]  которые у меня здесь будет она будет не более чем 2 н а мне нужно это посчитать ну как я это
[01:25:23.700 --> 01:25:36.700]  посчитаю смотрите я беру среднее от н и т в квадрате давайте я перепишу что мы раскладываем
[01:25:36.700 --> 01:25:45.900]  просто квадрат в начале смотрите у меня 2 на н и т н и т минус 1 пополам плюс н и т ну как бы если
[01:25:45.900 --> 01:25:54.700]  вы все это сложите получите н и т в квадрат согласны заметим что все правильно очевидно что все верно
[01:25:54.700 --> 01:26:04.220]  вот а дальше мы смотрим на все это чудо и смотрите что такое н и т на н и т минус 1 пополам это количество
[01:26:04.220 --> 01:26:13.780]  коллизий внутри одного кусочка согласны да вот я делаю сумму по всем этим кусочкам это есть
[01:26:13.780 --> 01:26:22.300]  количество коллизий согласны вот ваше количество коллизий которое возможно получается это у меня
[01:26:22.300 --> 01:26:28.340]  два средних количество коллизий но а н и т ну мы просуммируем н и т и все это сколько у нас
[01:26:28.340 --> 01:26:41.940]  элементов есть нашим x правильно это n согласны вот отлично получается два средних c плюс n что
[01:26:41.940 --> 01:26:55.780]  такое средняя ц это n на n минус 1 пополам 1 на m двоечки сокращаются я говорю что m равно n поэтому
[01:26:55.780 --> 01:27:03.740]  у меня получается здесь что здесь получается n минус 1 плюс n это 2 n минус 1 это меньше чем 2 n
[01:27:03.740 --> 01:27:14.340]  согласны все верно именно так понимаю что может быть трудно но это последнее все больше
[01:27:14.340 --> 01:27:24.860]  никакой мы никакой математики на сегодня вот вроде когда если я не ошибаюсь какое здесь
[01:27:24.860 --> 01:27:35.420]  важное следствие важное следствие здесь следующее что вероятность того что н и
[01:27:35.420 --> 01:27:45.700]  т сумма н и т в квадрате больше либо равно чем 4 н меньше чем 1 вторая благодаря тому среднему
[01:27:45.700 --> 01:27:50.660]  который мы посчитали то есть мы посчитали среднее количество объектов н и т в квадрате теперь
[01:27:50.660 --> 01:27:56.020]  я говорю что у меня вероятность тоже она меньше одной второй почему ну потому что я просто применю
[01:27:56.020 --> 01:28:04.940]  лен маркова окей просто применил лен маркова у меня был 4 н я делаю 2 н делить на 4 н получаю
[01:28:04.940 --> 01:28:17.380]  одну вторую понятно запомните этот факт для этого вам здесь помогают а этот факт этот факт нам
[01:28:17.380 --> 01:28:24.020]  нужен для следующего что у нас не будет количество вот этих вот бакетов то смотреть
[01:28:24.020 --> 01:28:29.260]  средний это мы посчитаем нас интересует вероятность того что вот это не огромная какая-то
[01:28:29.260 --> 01:28:36.500]  штука по памяти потому что ну чисто случайно у вас может быть что все-таки н квадрат будет
[01:28:36.500 --> 01:28:45.820]  вот а мне не нужно мне нужно сказать что у меня должно быть 4 н вот но в действительности короче
[01:28:45.940 --> 01:28:55.180]  появляется так что вот это называется алгоритм фкс честно не помню фамилия но когда-то на
[01:28:55.180 --> 01:29:01.220]  экзамене мне сказали что это алгоритм ки и все от этого меня прям порвало в тот момент поэтому
[01:29:01.220 --> 01:29:10.380]  не делайте так пожалуйста вот запомните последовательность буквок в общем-то смотрите
[01:29:10.380 --> 01:29:17.100]  какой алгоритм вот этого двойного хэширования по сути алгоритм следующий мы строим внешнюю
[01:29:17.100 --> 01:29:24.020]  хэш таблицу m равно n выбирая случайно какое-то универсальное семейство хэш функций существуют
[01:29:24.020 --> 01:29:28.700]  универсальные семейства хэш функций для строк для всего остального мы смотрим рассмотреть только
[01:29:28.700 --> 01:29:37.660]  для чисел например вот выбираем хэшируем все необходимые нам данные которые даны вот самого
[01:29:37.660 --> 01:29:44.220]  начала то есть от x1 до xn смотрим на количество коллизий мы понимаем сколько здесь элементов
[01:29:44.220 --> 01:29:53.300]  каждым бакете лежит согласны я их смотрю и такой ага если их больше чем 4 н то мне не нравится эта
[01:29:53.300 --> 01:30:02.060]  хэш функция я и перед перебираю новую и беру новую эту хэш функцию то есть повторяем первый
[01:30:02.060 --> 01:30:08.460]  пункт заново для чего мы это делаем для того чтобы вот здесь было линейно благодаря тому что мы
[01:30:08.460 --> 01:30:15.540]  сказали что вероятность того что больше чем 4 н меньше чем 1 вторая это означает что за
[01:30:15.540 --> 01:30:21.740]  пару итераций мы точно эту найдем хэш функцию мы не будем бесконечно долго ходить это пару итераций
[01:30:21.740 --> 01:30:30.740]  окей понятно зачем мы доказывали вот это меньше 1 вторая вот то есть нас не будет какой-то большой
[01:30:30.740 --> 01:30:37.340]  большой здесь хэш табличек отлично что мы делаем дальше дальше мы просто для каждой ячейки и ты
[01:30:37.340 --> 01:30:47.140]  строим свою хэш табличку а размера м это равно н это в квадрате и выбираем ошитое то с тем
[01:30:47.140 --> 01:30:53.060]  фиксируем конкретно ошитое выбираем из универсального семейства хэш функции но если
[01:30:53.060 --> 01:30:59.540]  на числах то это просто а и б мы просто рандомно выбираем и дальше если у нас есть коллизии в
[01:30:59.540 --> 01:31:10.500]  хэш таблице то в этом случае мы перехашируем ее благо вероятность коллизии меньше чем 1 2 помните
[01:31:10.500 --> 01:31:18.580]  этот факт помните вот поэтому это займет тоже пару итераций таким образом вот вы может быть
[01:31:18.580 --> 01:31:24.140]  и террироваться будете типа какое-то время но в то же время для вот этого статического множества
[01:31:24.140 --> 01:31:34.860]  вы построите хэш таблицу который вы за у от единицы сможете найти необходимые вам вещи вот поэтому
[01:31:34.860 --> 01:31:44.700]  find в этом алгоритме будет работать достаточно просто это нужно проверить что x равно б ошитое от x
[01:31:44.700 --> 01:31:55.700]  то есть тот элементик который там хранится мы же по индексам ходим все вот как-то так вот
[01:31:55.700 --> 01:32:05.020]  здесь возможно скобочек только не хватает но это ладно а что важно про этот алгоритм знать
[01:32:05.020 --> 01:32:11.260]  знаю важно знать что время работает в алгоритм от это отн почему ну потому что построить хэш
[01:32:11.260 --> 01:32:17.900]  это вот это это даже отн то есть мы не сверху просто ограничим и снизу ограничен нам нужно
[01:32:17.900 --> 01:32:25.780]  пересчитать все хэши которые есть этот отн дальше перестроить хэш таблички вот здесь вот
[01:32:25.780 --> 01:32:30.820]  который у меня есть ну для каждого это тоже займет там n 1 в квадрате но когда мы просуммируем
[01:32:30.820 --> 01:32:38.940]  это не больше чем n это отн не больше чем 4 н мы будем делать отлично там мы тоже перехашируем ну
[01:32:38.940 --> 01:32:43.900]  получим через какое-то количество итерации получаем это отн памяти это занимает это отн
[01:32:43.900 --> 01:32:53.220]  но отн точнее вот и последнее но поиск в лучшем случае этот этот единички потому что у нас есть
[01:32:53.220 --> 01:33:00.140]  нет коллизий мы не смотрим элементы дальше мы всегда просто заходим мы берем элемент понятно
[01:33:00.140 --> 01:33:09.140]  вот это алгоритма в кс это все будет будет на экзамене все доказательства тоже будут вот да
[01:33:09.140 --> 01:33:22.820]  до вы его будете делать как раз вот я вам просто последнее время специально не пишу код чтобы вы
[01:33:22.820 --> 01:33:29.460]  посидели почитали и сами написали вот на этом в принципе все я вас даже не сильно задержал
