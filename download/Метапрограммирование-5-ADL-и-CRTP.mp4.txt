[00:00.000 --> 00:19.440]  Давайте поговорим, поговорим про ругательственное слово
[00:19.440 --> 00:23.360]  на три буквы A, D, L.
[00:23.360 --> 00:26.360]  Слышали про такой?
[00:27.000 --> 00:30.000]  Класс!
[00:30.640 --> 00:33.360]  Вот это вот мы видели, по-моему, уже слайд.
[00:33.360 --> 00:35.240]  В три этапа идем.
[00:35.240 --> 00:39.360]  Набираем множество имен, делаем постановки шаблонов
[00:39.360 --> 00:41.960]  и резолвим,
[00:41.960 --> 00:45.760]  кто лучше все подходит из полученных имен.
[00:45.760 --> 00:49.480]  Ну, пришло время узнать, как первый этап работает
[00:49.480 --> 00:50.840]  в деталях.
[00:50.840 --> 00:53.720]  Работает он следующим смешным образом.
[00:53.880 --> 00:57.880]  Видели вызов и пошли вверх по namespace.
[00:57.880 --> 01:02.880]  В текущем namespace ищем, в родительском namespace ищем,
[01:02.880 --> 01:05.880]  в глобальном namespace ищем.
[01:05.880 --> 01:06.880]  Можно секундочку?
[01:06.880 --> 01:07.880]  Да.
[01:07.880 --> 01:10.880]  Вот до этого мы говорим про spaceship.
[01:10.880 --> 01:17.880]  Где-то тут будет сакральный момент того, что нужно было знать про spaceship?
[01:17.880 --> 01:20.880]  Или это просто две разные темы?
[01:21.040 --> 01:24.040]  Нет, вот здесь spaceship не нужен.
[01:24.040 --> 01:27.040]  Просто я сказал так, вкинул, типа,
[01:27.040 --> 01:32.040]  давайте всегда писать spaceship как friend внутри класса.
[01:32.040 --> 01:36.040]  Вот почему я попытаюсь через это объяснить.
[01:36.040 --> 01:39.040]  Эхе-хех.
[01:39.040 --> 01:41.040]  Но вы не сильно опоздали.
[01:41.040 --> 01:45.040]  Мы собрались говорить про то, где происходит name lookup.
[01:45.040 --> 01:48.040]  Где мы набираем это самое корзину имен,
[01:48.200 --> 01:51.200]  с которой потом идем выбирать самое лучшее.
[01:54.200 --> 01:55.200]  Здесь.
[01:55.200 --> 01:58.200]  Идем вверх по всем namespace,
[01:58.200 --> 02:01.200]  набираем все бары, что увидим.
[02:01.200 --> 02:03.200]  Ну, тут вызов бара.
[02:03.200 --> 02:05.200]  Надо, соответственно, отсюда бар забрать,
[02:05.200 --> 02:07.200]  отсюда бар забрать, оттуда бар забрать.
[02:07.200 --> 02:08.200]  Все подходят.
[02:08.200 --> 02:10.200]  А потом выбрать из них наилучшее.
[02:10.200 --> 02:13.200]  Ну, это если так в целом.
[02:13.200 --> 02:17.200]  А тут, кажется, ответ очевиден.
[02:17.360 --> 02:22.360]  Найдется ли вот это вот имя бар при вот этом вызове?
[02:22.360 --> 02:23.360]  Нет.
[02:23.360 --> 02:25.360]  Нет, ну вообще другой namespace какой-то,
[02:25.360 --> 02:27.360]  не имеет отношения.
[02:27.360 --> 02:29.360]  Туда мы смотреть не будем.
[02:29.360 --> 02:32.360]  А вот в такой ситуации что будет?
[02:36.360 --> 02:39.360]  Тут можно догадаться, если быть очень смекалистым.
[02:39.360 --> 02:42.360]  Но вряд ли.
[02:42.520 --> 02:45.520]  Ну как бы да.
[02:45.520 --> 02:48.520]  Но как и что это значит?
[02:48.520 --> 02:51.520]  Просто поглядите внимательно.
[02:54.520 --> 02:57.520]  Ну вот да.
[02:57.520 --> 03:00.520]  Вот здесь же мы не пошли в namespace n.
[03:00.520 --> 03:02.520]  А тут почему-то пошли.
[03:02.520 --> 03:05.520]  Ну вот ответ, конечно же, что есть.
[03:05.520 --> 03:08.520]  А здесь же мы не пошли в namespace n.
[03:08.520 --> 03:11.520]  А тут почему-то пошли.
[03:11.680 --> 03:14.680]  А тут, конечно же, что здесь бар найдется и нормально вызовется.
[03:14.680 --> 03:17.680]  Вопрос почему?
[03:17.680 --> 03:20.680]  Может так же, например, поиск было с зависимыми именами.
[03:20.680 --> 03:23.680]  Здесь поиск зависимый на namespace, и тут крещение.
[03:23.680 --> 03:26.680]  Ну нет, тут термин...
[03:26.680 --> 03:29.680]  Просто потому что мы уже один раз залезли.
[03:29.680 --> 03:32.680]  В смысле, что на этой строчке?
[03:32.680 --> 03:34.680]  Нет, вот это точно никакого отношения не имеет.
[03:34.680 --> 03:37.680]  То, что на предыдущих строчках мы как-то залезали куда-то,
[03:37.680 --> 03:40.680]  никак, никогда не влияет на следующие строчки.
[03:40.840 --> 03:43.840]  Типа аргумента.
[03:43.840 --> 03:46.840]  Зависимые имена, это тут как бы правильная идея,
[03:46.840 --> 03:49.840]  но термин зависимые имена, вот кто-то про него сказал сейчас,
[03:49.840 --> 03:52.840]  он именно про шаблоны.
[03:52.840 --> 03:55.840]  Здесь шаблонов нет, ни одного.
[03:55.840 --> 03:58.840]  Поэтому здесь чуть другие термины будут.
[03:58.840 --> 04:01.840]  Перед этим поговорим про имена.
[04:01.840 --> 04:04.840]  Тут я регулярку написал, наверное, правильно.
[04:04.840 --> 04:07.840]  А, ну да, там еще что-то подчеркивание ниже.
[04:08.000 --> 04:11.000]  А, ну да, там еще что-то подчеркивание нижнее,
[04:11.000 --> 04:14.000]  какие-то теперь... Нет, да?
[04:14.000 --> 04:17.000]  Нет, это что-то как уни-код.
[04:17.000 --> 04:20.000]  А, ну это так.
[04:20.000 --> 04:23.000]  Сейчас, там теперь любой уни-код символы
[04:23.000 --> 04:26.000]  можно использовать, да, в именах?
[04:26.000 --> 04:29.000]  Отлично.
[04:29.000 --> 04:32.000]  Отлично.
[04:32.000 --> 04:35.000]  Да, а к чему эта регулярка-то?
[04:35.000 --> 04:37.000]  Имена бывают двух видов.
[04:37.160 --> 04:39.160]  Qualified and unqualified.
[04:39.160 --> 04:42.160]  Понимаете, что эти слова значат?
[04:42.160 --> 04:45.160]  Квалифицированные и неквалифицированные.
[04:45.160 --> 04:48.160]  Не помогает, да?
[04:48.160 --> 04:51.160]  Квалифицированные – это те, в которых namespace явно прописано.
[04:51.160 --> 04:54.160]  То есть мы полностью пишем, что мы собрались вызвать.
[04:54.160 --> 04:57.160]  То есть совсем полная квалификация –
[04:57.160 --> 05:00.160]  это два двуюточия.
[05:00.160 --> 05:03.160]  Первый namespace – два двуюточия. Второй namespace – два двуюточия.
[05:03.160 --> 05:06.160]  Третий – два двуюточия. Класс – два двуюточия.
[05:06.320 --> 05:09.320]  Мы полностью всю цепочку вложенности прописать.
[05:09.320 --> 05:12.320]  Это вот qualified name.
[05:12.320 --> 05:15.320]  Unqualified – когда мы просто пишем какое-то имя.
[05:15.320 --> 05:18.320]  Фу – это unqualified.
[05:18.320 --> 05:21.320]  Здесь bar – это unqualified имя.
[05:21.320 --> 05:24.320]  Ага.
[05:24.320 --> 05:27.320]  Operator – это тоже unqualified имена.
[05:27.320 --> 05:30.320]  То есть когда вы пишете цин две стрелки hello world,
[05:30.320 --> 05:33.320]  вот эти две стрелки – это тоже unqualified имя.
[05:33.480 --> 05:36.480]  Какие-то мелкие детали есть, нам они несущественны.
[05:36.480 --> 05:39.480]  А qualified – это все, что можно записать в виде z.
[05:39.480 --> 05:42.480]  Qualified – а дальше пошли два двуюточия namespace,
[05:42.480 --> 05:45.480]  два двуюточия namespace.
[05:45.480 --> 05:48.480]  Еще тут нужно упомянуть, что в самом начале тоже можно поставить
[05:48.480 --> 05:51.480]  два двуюточия, но ничего перед ними не написав.
[05:51.480 --> 05:54.480]  А если z for global namespace,
[05:54.480 --> 05:57.480]  тогда это unqualified?
[05:57.480 --> 06:00.480]  Два двуюточия z.
[06:00.640 --> 06:03.640]  Неважно, что где находится. Мы сейчас говорим об именах.
[06:03.640 --> 06:06.640]  То есть в выражениях, которые написаны.
[06:06.640 --> 06:09.640]  Мы пытаемся вызвать функцию или пытаемся переменную достать.
[06:09.640 --> 06:12.640]  Мы смотрим на выражение имени.
[06:12.640 --> 06:15.640]  Если выражение выглядит как просто z,
[06:15.640 --> 06:18.640]  которое unqualified,
[06:18.640 --> 06:21.640]  то оно unqualified.
[06:21.640 --> 06:24.640]  А если мы перед ним хотя бы одно-два двуюточия имеем,
[06:24.640 --> 06:27.640]  то это qualified. Критерий такой для строк.
[06:27.800 --> 06:30.800]  Если есть внутри два двуюточия, то qualified.
[06:30.800 --> 06:33.800]  Окей?
[06:33.800 --> 06:36.800]  Скажите мне, что значит два двуюточия?
[06:36.800 --> 06:39.800]  Вот без namespace просто два двуюточия и какое-то имя.
[06:39.800 --> 06:42.800]  Да, мы форсируем именно global namespace,
[06:42.800 --> 06:45.800]  а не какой-нибудь другой вложенный.
[06:45.800 --> 06:48.800]  Тут еще и трюк, что может быть,
[06:48.800 --> 06:51.800]  здесь компилятор за нас каких-то namespace потом допишет,
[06:51.800 --> 06:54.800]  но нам это несущественно сейчас.
[06:54.960 --> 06:57.960]  А как форсировать локальный namespace?
[06:57.960 --> 07:00.960]  Никак.
[07:00.960 --> 07:03.960]  Форсирую глобально и полностью выпишу путь до локального.
[07:03.960 --> 07:06.960]  Но вообще про то,
[07:06.960 --> 07:09.960]  как форсировать, какая функция будет вызвана,
[07:09.960 --> 07:12.960]  в C++, казалось бы, базовая вещь, которую мы делаем,
[07:12.960 --> 07:15.960]  это вызываем к функции.
[07:15.960 --> 07:18.960]  Но вот убедиться, что будет вызвана именно та функция,
[07:18.960 --> 07:21.960]  которая вы хотите, это оказывается настолько нетривиальное занятие,
[07:22.120 --> 07:25.120]  но об этом мы узнаем в следующих сериях.
[07:25.120 --> 07:28.120]  У меня сегодня и сил не хватит на это.
[07:30.120 --> 07:33.120]  Про первый этап,
[07:33.120 --> 07:36.120]  где мы ищем список корзину имен,
[07:36.120 --> 07:39.120]  с которыми дальше будем работать.
[07:41.120 --> 07:44.120]  Процедура поиска их называется namelookup,
[07:44.120 --> 07:47.120]  и для qualify и unqualify имен она отличается.
[07:47.120 --> 07:50.120]  Что сначала идет?
[07:50.280 --> 07:53.280]  Смотри, ты видишь в коде имя.
[07:56.280 --> 07:59.280]  Ты в коде смотришь вот сюда, это вызов,
[07:59.280 --> 08:02.280]  имя здесь bar, надо понять, что вызывает.
[08:07.280 --> 08:10.280]  Нет, сейчас смотри.
[08:13.280 --> 08:16.280]  Речь идет не об имене.
[08:16.280 --> 08:19.280]  Короче, когда ты видишь объявление функции,
[08:19.440 --> 08:22.440]  тут нет уже понятия qualify, это имя или unqualify.
[08:22.440 --> 08:25.440]  Оно есть, но оно не про другое совсем.
[08:25.440 --> 08:28.440]  Нас интересует qualify для имя в месте вызова.
[08:28.440 --> 08:31.440]  В точке вызова мы явно прописали n2.bar,
[08:31.440 --> 08:34.440]  тогда это qualify, если просто bar, unqualify.
[08:39.440 --> 08:42.440]  То оба добавятся в корзину.
[08:42.440 --> 08:45.440]  А кто вызовется?
[08:45.440 --> 08:48.440]  Это решит overload resolution,
[08:48.600 --> 08:51.600]  если они будут одинаковые, то будет ambiguous,
[08:51.600 --> 08:54.600]  call ошибка.
[08:57.600 --> 09:00.600]  Сейчас будут два кейса, qualify и unqualify.
[09:00.600 --> 09:03.600]  Это про точку вызова функции.
[09:03.600 --> 09:06.600]  Где вы вызов функции написали,
[09:06.600 --> 09:09.600]  вы там полностью прописали имя функции
[09:09.600 --> 09:12.600]  со всеми квалификациями, или только само имя собственное.
[09:12.600 --> 09:15.600]  Вот от этого зависит.
[09:15.760 --> 09:18.760]  То есть со всеми namespace и 7777.
[09:18.760 --> 09:21.760]  Ну, ладно, не всеми.
[09:21.760 --> 09:24.760]  Хотя бы с одним namespace, если написали.
[09:24.760 --> 09:27.760]  То есть хотя бы одно-два-двую точью, если есть.
[09:27.760 --> 09:30.760]  То процедура такая.
[09:30.760 --> 09:33.760]  Мы сначала ищем в X...
[09:33.760 --> 09:36.760]  Что, потом qual внутри?
[09:36.760 --> 09:39.760]  Но сначала ищем X, очевидно.
[09:39.760 --> 09:42.760]  Фу, да, все, я туплю.
[09:42.920 --> 09:45.920]  Здесь сказано, что идет рекурсия.
[09:45.920 --> 09:48.920]  Потому что namespace это тоже нужно находить.
[09:48.920 --> 09:51.920]  Поэтому, когда у вас написана какая-то qual,
[09:51.920 --> 09:54.920]  эта функция какая-то, qual и перед ней два-двую точи X,
[09:54.920 --> 09:57.920]  надо сначала запустить рекурсивность себя,
[09:57.920 --> 10:00.920]  чтобы найти, где у нас Y, два-двую точи X.
[10:00.920 --> 10:03.920]  То есть вот от префекса себя запустили,
[10:03.920 --> 10:06.920]  нашли, где namespace.
[10:06.920 --> 10:09.920]  В нем уже запускаем поиск qual.
[10:10.080 --> 10:13.080]  Если вот такой идет,
[10:13.080 --> 10:16.080]  то X строго в глобальном namespace.
[10:16.080 --> 10:19.080]  И когда сделано вот такое,
[10:19.080 --> 10:22.080]  то есть перед первым namespace нету два-двую точи,
[10:22.080 --> 10:25.080]  то идет поиск qual.
[10:25.080 --> 10:28.080]  Если вам покажется, что это
[10:28.080 --> 10:31.080]  хреново сформулированная индукция, так и есть.
[10:31.080 --> 10:34.080]  Но я это переписывал со стандарта, по-моему.
[10:34.080 --> 10:37.080]  И там как-то вот эта индукция очень плохо...
[10:37.240 --> 10:40.240]  Я правильно понимаю, что qualify,
[10:40.240 --> 10:43.240]  чтобы на всех шагах
[10:43.240 --> 10:46.240]  рекурсии был qualify,
[10:46.240 --> 10:49.240]  нужно везде поставить две-двую точи.
[10:49.240 --> 10:52.240]  Да, чтобы совершенно точно
[10:52.240 --> 10:55.240]  выбрать, какую функцию ты вызываешь,
[10:55.240 --> 10:58.240]  нужно начать с глобального namespace
[10:58.240 --> 11:01.240]  и полностью прописать, куда ты хочешь прийти.
[11:01.240 --> 11:04.240]  Иначе у тебя для самого первого namespace
[11:04.400 --> 11:06.400]  qualified lookup,
[11:06.400 --> 11:09.400]  который будет на следующем слайде,
[11:09.400 --> 11:12.400]  мы находим какой-то namespace,
[11:12.400 --> 11:15.400]  и дальше в нем ищем следующий namespace,
[11:15.400 --> 11:18.400]  следующий, следующий, следующий,
[11:18.400 --> 11:21.400]  и в последнем из них ищем уже функцию,
[11:21.400 --> 11:24.400]  просто по списку функций в этом namespace.
[11:24.400 --> 11:27.400]  Как это словами даже понятнее,
[11:27.400 --> 11:30.400]  чем перевод формулировки из стандарта,
[11:30.400 --> 11:33.400]  я думаю, вы поняли.
[11:33.560 --> 11:36.560]  Интереснее, что происходит,
[11:36.560 --> 11:39.560]  когда мы inQualify lookup делаем,
[11:39.560 --> 11:42.560]  когда у нас не указаны namespaces.
[11:42.560 --> 11:45.560]  Начинаем идти наверх,
[11:45.560 --> 11:48.560]  в поисках того, что подойдет.
[11:48.560 --> 11:51.560]  Соответственно,
[11:51.560 --> 11:54.560]  это про namespaces,
[11:54.560 --> 11:57.560]  есть класс, внутри него функция,
[11:57.560 --> 12:00.560]  внутри функции вызов.
[12:00.720 --> 12:03.720]  На уровне namespaces посмотрим,
[12:03.720 --> 12:06.720]  нет ли совпадающих имен и выше, выше, выше,
[12:06.720 --> 12:09.720]  как пример самый первый был.
[12:09.720 --> 12:12.720]  В родительские классы мы тоже пойдем.
[12:12.720 --> 12:15.720]  Вы уже умны, да?
[12:15.720 --> 12:18.720]  Тут звездочка должна быть.
[12:18.720 --> 12:21.720]  Что за звездочка про поиск в родительских классах имен?
[12:21.720 --> 12:24.720]  Нет, там вот да, называл человек.
[12:24.720 --> 12:27.720]  Чего?
[12:27.880 --> 12:30.880]  Я не расслышал.
[12:30.880 --> 12:33.880]  Если имя зависимое
[12:33.880 --> 12:36.880]  и родитель зависимый,
[12:36.880 --> 12:39.880]  то мы туда не пойдем.
[12:39.880 --> 12:42.880]  Если имя inQualify
[12:42.880 --> 12:45.880]  и родитель зависимый,
[12:45.880 --> 12:48.880]  то мы туда не пойдем,
[12:48.880 --> 12:51.880]  потому что мы не знаем родителя.
[12:51.880 --> 12:54.880]  На первой фазе в смысле.
[12:55.040 --> 12:58.040]  Это вставит в текущую область видимости,
[12:58.040 --> 13:01.040]  где ты этот using написал.
[13:01.040 --> 13:04.040]  И если там и там одинаковые абсолютно функции,
[13:04.040 --> 13:07.040]  имя и родитель зависимы.
[13:07.040 --> 13:10.040]  Суть этого одна функция.
[13:10.040 --> 13:13.040]  Одной функцией может быть много деклараций.
[13:13.040 --> 13:16.040]  Как это понять?
[13:16.040 --> 13:19.040]  Если есть глобальная функция,
[13:19.040 --> 13:22.040]  есть ровно такая же,
[13:22.200 --> 13:25.200]  мы искали using, space, вот это.
[13:25.200 --> 13:28.200]  Тогда ты, кажется...
[13:28.200 --> 13:31.200]  Нет, оно приоритет возьмет.
[13:31.200 --> 13:34.200]  Потому что на этом шаге
[13:34.200 --> 13:37.200]  изнутри, наружу идет.
[13:37.200 --> 13:40.200]  Нет, все равно волшебно, непонятно.
[13:40.200 --> 13:43.200]  Если мы пишем using declaration,
[13:43.200 --> 13:46.200]  мы создаем новый, маленький скоп,
[13:46.200 --> 13:49.200]  который начинается с using и идет дальше.
[13:49.360 --> 13:52.360]  Он же не остановится набирать имена,
[13:52.360 --> 13:55.360]  когда найдет хотя бы одно подходящее.
[13:55.360 --> 13:58.360]  Он пойдет дальше, насколько я помню.
[13:58.360 --> 14:01.360]  Если остановится на этом шаге, то я уже путаю.
[14:01.360 --> 14:04.360]  Наверное, должен остановиться.
[14:04.360 --> 14:07.360]  Если это unqualifying имя, то он остановится
[14:07.360 --> 14:10.360]  и посмотрит, на кого он давно шел.
[14:10.360 --> 14:13.360]  Наверное, все-таки я сейчас соображаю.
[14:13.360 --> 14:16.360]  Да, оно остановится.
[14:16.520 --> 14:19.520]  Оно остановится и дальше не пойдет.
[14:19.520 --> 14:22.520]  Ладно, нам это не интересно.
[14:22.520 --> 14:25.520]  Тут есть вот оговорочка маленькая.
[14:25.520 --> 14:28.520]  Я про friend definition вам сказал.
[14:28.520 --> 14:31.520]  Есть friend definition.
[14:31.520 --> 14:34.520]  Прямо внутри класса делаем friend функция
[14:34.520 --> 14:37.520]  и объявляем ее.
[14:37.520 --> 14:40.520]  Где область видимости, в которой живет эта функция?
[14:40.520 --> 14:43.520]  Просто снаружи класса.
[14:43.680 --> 14:45.680]  Какая вот friend definition?
[14:45.680 --> 14:48.680]  Он туда и кладется.
[14:48.680 --> 14:51.680]  Для зависимых имен там еще какие-то приколы.
[14:51.680 --> 14:54.680]  И последним самым шагом
[14:54.680 --> 14:57.680]  начинается некоторый загадочный ADL.
[14:57.680 --> 15:00.680]  Что такое ADL?
[15:00.680 --> 15:03.680]  Мы начинаем искать функцию foo,
[15:03.680 --> 15:06.680]  увидев unqualified вызов foo от bar
[15:06.680 --> 15:09.680]  в различных местах,
[15:09.680 --> 15:12.680]  которые как-то связаны с аргументом,
[15:12.840 --> 15:15.840]  да, при этом из всего предыдущего
[15:15.840 --> 15:18.840]  мораль какая?
[15:18.840 --> 15:21.840]  До ADL мы дойдем, только если все остальное не сработало,
[15:21.840 --> 15:24.840]  тут вот такие правила.
[15:24.840 --> 15:27.840]  Если нашлась какая-нибудь внешняя функция,
[15:27.840 --> 15:30.840]  то она подавит ADL.
[15:34.840 --> 15:37.840]  ADL ищет в следующих местах
[15:37.840 --> 15:40.840]  связанных с bar функцию foo,
[15:41.000 --> 15:44.000]  класс, в котором внутри самого класса bar,
[15:44.000 --> 15:47.000]  снаружи от этого класса,
[15:47.000 --> 15:50.000]  то есть в namespace его содержащим,
[15:50.000 --> 15:53.000]  во всех родительских классах
[15:53.000 --> 15:56.000]  или курсивно во всех namespace родительских классов.
[15:56.000 --> 15:59.000]  Вот этой переменной bar.
[15:59.000 --> 16:02.000]  Если bar – это какой-то шаблон,
[16:02.000 --> 16:05.000]  и в этот шаблон подставлены какие-то аргументы,
[16:05.000 --> 16:08.000]  то есть тип bar – это специализация шаблона,
[16:08.160 --> 16:11.160]  и в namespace, где лежат аргументы,
[16:11.160 --> 16:14.160]  вот этого шаблона для bar,
[16:14.160 --> 16:17.160]  кто-то там крестится уже на задних рядах,
[16:17.160 --> 16:20.160]  нет, показалось.
[16:20.160 --> 16:23.160]  Если у нас какие-нибудь указатели на функции
[16:23.160 --> 16:26.160]  или указатели на методы,
[16:26.160 --> 16:29.160]  вы знаете, что такое указатели на методы?
[16:29.160 --> 16:32.160]  В них тоже все типы,
[16:32.160 --> 16:35.160]  которые упоминаются, мы их всех тоже возьмем
[16:35.320 --> 16:38.320]  и в них идем, и в их namespace идем.
[16:38.320 --> 16:41.320]  И вот все эти места называются
[16:41.320 --> 16:44.320]  ассоциированные с bar скопы.
[16:44.320 --> 16:47.320]  То есть примерно все, что хоть как-то известно
[16:47.320 --> 16:50.320]  про bar в compile-time,
[16:50.320 --> 16:53.320]  все сущности, которые вообще хоть малейшеньким образом
[16:53.320 --> 16:56.320]  как-то относятся к bar,
[16:56.320 --> 16:59.320]  в них мы пойдем искать имя функции,
[16:59.320 --> 17:02.320]  в них мы пойдем искать имя функции,
[17:02.480 --> 17:05.480]  в них мы пойдем искать имя Foo.
[17:08.480 --> 17:11.480]  Ну не буду про них, слишком сложно.
[17:14.480 --> 17:17.480]  Почему этот код компилируется?
[17:20.480 --> 17:23.480]  Почему он компилируется, я не понимаю.
[17:23.480 --> 17:26.480]  Вот cout, он namespace std,
[17:26.480 --> 17:29.480]  я пишу std cout, мне говорят, да, есть такое.
[17:29.640 --> 17:32.640]  Если я просто cout напишу, работа не будет.
[17:32.640 --> 17:35.640]  А оператор меньше-меньше, он тоже на namespace std определен.
[17:35.640 --> 17:38.640]  Почему мы можем вызвать оператора меньше-меньше,
[17:38.640 --> 17:41.640]  не указав, что он на namespace std?
[17:46.640 --> 17:49.640]  Да, вы можете написать hello world на C++
[17:49.640 --> 17:52.640]  исключительно за счет того, что существует ADL.
[17:59.640 --> 18:02.640]  Ой, началось, нет.
[18:02.640 --> 18:05.640]  То есть вот этот оператор меньше-меньше,
[18:05.640 --> 18:08.640]  он определен на namespace std,
[18:08.640 --> 18:11.640]  но это анквалифает имя.
[18:11.640 --> 18:14.640]  Операторы, мы где-то упомянули, что это анквалифает имя.
[18:14.640 --> 18:17.640]  Значит, мы посмотрим на аргументы.
[18:17.640 --> 18:20.640]  Второй аргумент неинтересный,
[18:20.640 --> 18:23.640]  по концу char звездочка,
[18:23.640 --> 18:26.640]  там нет никаких ассоциированных классов и namespaces,
[18:26.800 --> 18:29.800]  но очень интересный аргумент.
[18:29.800 --> 18:32.800]  У него есть ассоциированный класс,
[18:32.800 --> 18:35.800]  cout stream какой-нибудь.
[18:35.800 --> 18:38.800]  Самое главное, что в std там написано, что он в std.
[18:38.800 --> 18:41.800]  Да, в каком порядке оно все находится.
[18:41.800 --> 18:44.800]  Мы берем класс этой переменной,
[18:44.800 --> 18:47.800]  тип этой переменной, смотрим в нем,
[18:47.800 --> 18:50.800]  а потом идем наружу в namespace,
[18:50.800 --> 18:53.800]  который для этого класса относится.
[18:53.960 --> 18:56.960]  Это класс определенного std.
[18:56.960 --> 18:59.960]  Но и не только это.
[18:59.960 --> 19:02.960]  Эта переменная сама в namespace каком-то живет.
[19:02.960 --> 19:05.960]  Этот namespace тоже считается ассоциированным.
[19:05.960 --> 19:08.960]  Как аргумент, оператора меньше-меньше.
[19:08.960 --> 19:11.960]  А меньше-меньше это имеет?
[19:11.960 --> 19:14.960]  Нет, не факт.
[19:14.960 --> 19:17.960]  Да, по-моему, квалификация...
[19:17.960 --> 19:20.960]  Нет, может...
[19:21.120 --> 19:24.120]  Ну ладно, тогда не будем.
[19:24.120 --> 19:27.120]  Из того, что точно здесь было за факт чекано,
[19:27.120 --> 19:30.120]  по всяким...
[19:30.120 --> 19:33.120]  Я правильно понимаю, что мы пойдем в std,
[19:33.120 --> 19:36.120]  даже потому, что меньше-меньше он квалифает,
[19:36.120 --> 19:39.120]  потому что один из его аргументов
[19:39.120 --> 19:42.120]  имеет в себе тип, который лежит в std.
[19:42.120 --> 19:45.120]  То есть если ты напишешь auto ampersand x
[19:45.120 --> 19:48.120]  равно std cout, а потом вот сюда x подставишь
[19:48.280 --> 19:51.280]  и std cout.
[19:51.280 --> 19:54.280]  Все равно сработает.
[19:54.280 --> 19:57.280]  Оператор меньше-меньше найдется через ADL.
[19:57.280 --> 20:00.280]  Вот, поздравляю.
[20:00.280 --> 20:03.280]  Мне кажется, на данном этапе
[20:03.280 --> 20:06.280]  те из вас, кто понял, что такое ADL,
[20:06.280 --> 20:09.280]  наконец-то до конца понимают,
[20:09.280 --> 20:12.280]  как на C++ написать hello world.
[20:12.280 --> 20:15.280]  Да, там везде есть маленькие детальки,
[20:15.440 --> 20:18.440]  которые, чтобы до конца понять,
[20:18.440 --> 20:21.440]  нужно стать самым бюрократом дурацким,
[20:21.440 --> 20:24.440]  который пишет стандарт.
[20:24.440 --> 20:27.440]  Но понимание, что ADL есть
[20:27.440 --> 20:30.440]  и что он идет в тип переменной аргумента
[20:30.440 --> 20:33.440]  достаточно, на самом деле.
[20:33.440 --> 20:36.440]  Кстати, мы будем еще и упражняться
[20:36.440 --> 20:39.440]  очень интересным образом в следующий раз.
[20:39.440 --> 20:42.440]  Упражняться, в смысле, я оговорился.
[20:42.600 --> 20:45.600]  Да, если ты...
[20:45.600 --> 20:48.600]  Да, если ты передаешь в...
[20:48.600 --> 20:51.600]  Не факт, потому что тип вектор begin,
[20:51.600 --> 20:54.600]  вектор end, он implementation defined.
[20:54.600 --> 20:57.600]  Может быть, имплементация стандартной библиотеки,
[20:57.600 --> 21:00.600]  где вектор.begin возвращает t звездочку.
[21:00.600 --> 21:03.600]  Но в целом, да, если у тебя
[21:03.600 --> 21:06.600]  в функцию передается какой-то тип,
[21:06.600 --> 21:09.600]  который точно в std лежит,
[21:09.760 --> 21:12.760]  а не писать, в вызове функции std 222.
[21:12.760 --> 21:15.760]  Вопрос, нужно ли это делать?
[21:15.760 --> 21:18.760]  Я бы сказал, что нет.
[21:18.760 --> 21:21.760]  Да, тут всякие обозначения, без ADL,
[21:21.760 --> 21:24.760]  жизнь вообще не кайф.
[21:24.760 --> 21:27.760]  А как же using std операции?
[21:27.760 --> 21:30.760]  Ну, можно так было, да.
[21:30.760 --> 21:33.760]  Давайте пробежечкой.
[21:33.760 --> 21:36.760]  Вот такая штука замечательная.
[21:36.920 --> 21:39.920]  В какой книжке?
[21:39.920 --> 21:42.920]  Ну, вот, видимо.
[21:42.920 --> 21:45.920]  Зачем это нужно?
[21:48.920 --> 21:51.920]  И второй первый, да.
[21:51.920 --> 21:54.920]  Для стандартных вещей из std.
[21:54.920 --> 21:57.920]  Да, в using...
[21:57.920 --> 22:00.920]  А если без using,
[22:00.920 --> 22:03.920]  то второй сработал бы только из объекта.
[22:04.080 --> 22:07.080]  Да, нам не интересны
[22:07.080 --> 22:10.080]  объекты из std и примитивные типы.
[22:10.080 --> 22:13.080]  Нам интересно, что будет для наших типов.
[22:13.080 --> 22:16.080]  Вот мы свой namespace сделали,
[22:16.080 --> 22:19.080]  и в нем сделали свой тип.
[22:19.080 --> 22:22.080]  И то и другое будет работать одинаково, да?
[22:22.080 --> 22:25.080]  Но теперь мы можем взять
[22:25.080 --> 22:28.080]  и в нашем же namespace объявить свою функцию swap.
[22:28.240 --> 22:31.240]  И вот этот код снизу
[22:31.240 --> 22:34.240]  вызовет нашу функцию swap вместо std.
[22:36.240 --> 22:39.240]  Абигиус не будет.
[22:39.240 --> 22:42.240]  Не будет, да.
[22:42.240 --> 22:45.240]  Ну, почему?
[22:45.240 --> 22:48.240]  Такие приоритеты.
[22:48.240 --> 22:51.240]  Абигиус не будет,
[22:51.240 --> 22:54.240]  потому что у нас найдется
[22:54.240 --> 22:57.240]  std swap, который шаблонный,
[22:57.400 --> 23:00.400]  и найдется наш swap, который не шаблонный,
[23:00.400 --> 23:03.400]  который для конкретного типа.
[23:03.400 --> 23:06.400]  То есть в множество имен и то и другое попадет.
[23:06.400 --> 23:09.400]  А потом уже на этапе overload resolution
[23:09.400 --> 23:12.400]  мы посмотрим.
[23:12.400 --> 23:15.400]  То есть в множестве имен std swap будет
[23:15.400 --> 23:18.400]  и любые наши штуки swap, которые мы определим.
[23:18.400 --> 23:21.400]  Это и есть то, что называется точка кастомизации,
[23:21.400 --> 23:24.400]  за исключением некоторых деталей.
[23:24.560 --> 23:27.560]  На самом деле std swap это тоже точка кастомизации.
[23:27.560 --> 23:30.560]  Вы слышали про std begin и std end функции?
[23:30.560 --> 23:33.560]  Они тоже точки кастомизации.
[23:33.560 --> 23:36.560]  Вы можете определить std begin и std end
[23:36.560 --> 23:39.560]  для каких-то своих структур,
[23:39.560 --> 23:42.560]  которые не имеют метода begin и end.
[23:42.560 --> 23:45.560]  И за счет чего это работает?
[23:45.560 --> 23:48.560]  За счет вот такой технологии,
[23:48.560 --> 23:51.560]  что стандартные алгоритмы вызывают begin и end
[23:51.720 --> 23:54.720]  вторым способом.
[23:54.720 --> 23:57.720]  Не знаю, делают ли на самом деле.
[23:57.720 --> 24:00.720]  И вы, когда пишете шаблонный код на самом деле,
[24:00.720 --> 24:03.720]  если вы хотите, чтобы пользователь мог чуть-чуть
[24:03.720 --> 24:06.720]  подкастомизировать и подкрутить, как именно что там происходит,
[24:06.720 --> 24:09.720]  например, подменить swap на какой-то свой кастомный,
[24:09.720 --> 24:12.720]  который работает на один такт процессора быстрее,
[24:12.720 --> 24:15.720]  а это важно, когда у вас сортировка пузыряком,
[24:15.720 --> 24:18.720]  то вам нужно код вот так писать.
[24:18.880 --> 24:21.880]  Поэтому swap вот только такой должен быть, не такой.
[24:21.880 --> 24:24.880]  Интересно язык C++, да?
[24:24.880 --> 24:27.880]  А шаблон-то так легко и интересно.
[24:27.880 --> 24:30.880]  В общем...
[24:30.880 --> 24:33.880]  Почему такой, а не такой?
[24:33.880 --> 24:36.880]  Потому что здесь ты найдешь пользовательские кастомизации.
[24:36.880 --> 24:39.880]  Если obj1 и obj2 это какие-то чужие типы,
[24:39.880 --> 24:42.880]  лежащие в namespace n,
[24:42.880 --> 24:45.880]  то автор этого namespace n может захотеть
[24:46.040 --> 24:49.040]  всю кастомную реализацию функции swap сделать
[24:49.040 --> 24:52.040]  в этом же namespace,
[24:52.040 --> 24:55.040]  который работает быстрее, чем стандартный swap.
[24:55.040 --> 24:58.040]  Все, я понял, я понял.
[24:58.040 --> 25:01.040]  Более узкий специализация может быть эффективной.
[25:01.040 --> 25:04.040]  Да, потому что мы знаем там структуру всего нашего внутри,
[25:04.040 --> 25:07.040]  мы сделаем быстрее, круче.
[25:07.040 --> 25:10.040]  Вот я чувствую катарсису одного человека, это...
[25:10.040 --> 25:13.040]  А вот это DL вообще не изданное?
[25:13.200 --> 25:16.200]  Сколько лет ты можешь написать hello world, столько о DL существует.
[25:16.200 --> 25:19.200]  Вам может...
[25:19.200 --> 25:22.200]  Я не знаю.
[25:36.200 --> 25:39.200]  Да, я, к сожалению, не знаю немецкого,
[25:39.200 --> 25:42.200]  поэтому шутка не зашла.
[25:42.360 --> 25:45.360]  Что я хотел сказать?
[25:45.360 --> 25:48.360]  Я хотел подытожить,
[25:48.360 --> 25:51.360]  что DL это на самом деле лютый костыль,
[25:51.360 --> 25:54.360]  какая-то ну типа кастомизация
[25:54.360 --> 25:57.360]  частых функций, типа чтобы их как-то вот
[25:57.360 --> 26:00.360]  подменить на лету, что-то сделать.
[26:00.360 --> 26:03.360]  И как бы жизнь он облегчает, но...
[26:06.360 --> 26:09.360]  код становится писать как минимум неприятно,
[26:09.520 --> 26:12.520]  и своп нормально в шаблонном коде вызвать не можете,
[26:12.520 --> 26:15.520]  не написав какое-то заклинание.
[26:18.520 --> 26:21.520]  Ну, в общем, DL достался нам по наследству.
[26:21.520 --> 26:24.520]  Сейчас очень много обсуждений о том,
[26:24.520 --> 26:27.520]  что это хрень, и надо это выкинуть из C++,
[26:27.520 --> 26:30.520]  но пока ничего такого не предвидится на горизонте даже близко,
[26:30.520 --> 26:33.520]  и поэтому живем с ним.
[26:33.680 --> 26:36.680]  Нет, в родительских классах
[26:36.680 --> 26:39.680]  своп у тебя вряд ли будет объявлен.
[26:45.680 --> 26:48.680]  Нет, если у тебя obj1 и obj2
[26:48.680 --> 26:51.680]  это зависимые имена,
[26:51.680 --> 26:54.680]  то своп автоматом зависимый.
[26:54.680 --> 26:57.680]  Нет, если у тебя obj1 и obj2
[26:57.680 --> 27:00.680]  это зависимые имена, то своп
[27:00.840 --> 27:03.840]  автоматом зависимый.
[27:17.840 --> 27:20.840]  Как бы вызов функций, в нем
[27:20.840 --> 27:23.840]  в имя включены еще аргументы, но не совсем,
[27:23.840 --> 27:26.840]  но как бы да, потому что эти аргументы
[27:26.840 --> 27:29.840]  влияют и на то dependent или нет,
[27:30.000 --> 27:33.000]  и на lookup влияют, как мы узнали из ADL,
[27:33.000 --> 27:36.000]  потому что lookup зависит от аргументов,
[27:36.000 --> 27:39.000]  поэтому эти аргументы и часть
[27:39.000 --> 27:42.000]  имени, и как бы нет, и тут сложно сказать,
[27:42.000 --> 27:45.000]  что конкретно правильно, какая терминология официальная.
[27:45.000 --> 27:48.000]  Ну да, вот как факт,
[27:48.000 --> 27:51.000]  аргументы влияют на lookup,
[27:51.000 --> 27:54.000]  и аргументы влияют на то, зависимое
[27:54.000 --> 27:57.000]  имя функции будет или нет. Если аргументы зависимые,
[27:57.160 --> 28:00.160]  то вот имя функции, вот здесь этот вызов считается зависимым.
[28:06.160 --> 28:09.160]  Да, это некоторое подобие extension
[28:09.160 --> 28:12.160]  методов в каком-то смысле.
[28:16.160 --> 28:19.160]  Extension методы есть не только в Kotlin,
[28:19.160 --> 28:22.160]  еще в C-sharp и Java теперь вроде.
[28:22.160 --> 28:25.160]  Это возможность написать метод внутри класса,
[28:25.320 --> 28:28.320]  то есть пишете методы вне класса,
[28:28.320 --> 28:31.320]  но появляется он как будто бы внутри.
[28:35.320 --> 28:38.320]  Ну да, и так даже можно,
[28:38.320 --> 28:41.320]  C-sharp убойный язык.
[28:41.320 --> 28:44.320]  Просто кажется, что extension
[28:44.320 --> 28:47.320]  и то, что в предыдущем свадьбе было,
[28:47.320 --> 28:50.320]  оно может решать одни и те же проблемы.
[28:50.320 --> 28:53.320]  Да, как бы проблемы здесь примерно
[28:53.480 --> 28:56.480]  те же пытаются решить, это некоторая расширяемость
[28:56.480 --> 28:59.480]  и подписывание старых
[28:59.480 --> 29:02.480]  абстракций на новые контракты какие-то,
[29:02.480 --> 29:05.480]  на новые интерфейсы.
[29:07.480 --> 29:10.480]  Потому что он плохо работает, когда ты его начинаешь
[29:10.480 --> 29:13.480]  пытаться использовать для чего-то, кроме Hello World.
[29:13.480 --> 29:16.480]  Если ты не веришь, то ты убедишься в этом
[29:16.480 --> 29:19.480]  через пару семинаров или лекций,
[29:19.480 --> 29:22.480]  если я все-таки не решу это выпилить.
[29:23.480 --> 29:26.480]  То есть это неожиданно еще не работает,
[29:26.480 --> 29:29.480]  когда у тебя есть какая-нибудь функция 2,
[29:29.480 --> 29:32.480]  которая лежит у тебя где-то локально.
[29:43.480 --> 29:46.480]  Короче, это какая-то проклятая фича C++,
[29:46.480 --> 29:49.480]  на первом курсе из-за нее
[29:49.480 --> 29:52.480]  невозможно объяснить человеку, как работает Hello World.
[29:52.640 --> 29:55.640]  Но это уже как бы показатель, мне кажется, надо что-то делать, но...
[30:01.640 --> 30:04.640]  Я потерял всякую надежду сегодня успеть пописать код,
[30:04.640 --> 30:07.640]  поэтому код будем писать в следующий раз,
[30:07.640 --> 30:10.640]  сегодня добьем вот эти вот мелкие темы,
[30:10.640 --> 30:13.640]  потому что вот эта конкретная тема вам поможет с домашками.
[30:15.640 --> 30:18.640]  Да нет, с третью рана.
[30:18.640 --> 30:21.640]  Третья, видимо, будет не на этой неделе, а на следующей.
[30:21.800 --> 30:24.800]  Во второй можно по-разному написать код.
[30:24.800 --> 30:27.800]  Один из способов его написать, это вот через вот эту штуку.
[30:29.800 --> 30:32.800]  Некоторые ее видели, возможно, уже, некоторые нет.
[30:32.800 --> 30:35.800]  Давайте познакомимся.
[30:35.800 --> 30:38.800]  Вот эта штука называется curiously recurring template pattern.
[30:38.800 --> 30:41.800]  Почему так?
[30:41.800 --> 30:44.800]  Потому что весьма любопытно, что подобный код
[30:44.800 --> 30:47.800]  постоянно появляется и появляется заново в разных код-базах,
[30:47.800 --> 30:50.800]  абсолютно независимо, заново открываемое разными людьми.
[30:50.960 --> 30:53.960]  Поэтому его так и назвали, любопытный и заново
[30:53.960 --> 30:56.960]  постоянно возникающий паттерн использования шаблонов.
[30:59.960 --> 31:02.960]  Вот, молодцы.
[31:02.960 --> 31:05.960]  Нет, это прекрасный паттерн.
[31:05.960 --> 31:06.960]  Нет, он нормальный.
[31:06.960 --> 31:09.960]  Ну, вы видите, что происходит?
[31:09.960 --> 31:12.960]  Вот если кто-то в первый раз видит такое вот,
[31:12.960 --> 31:15.960]  мы делаем базу шаблонную и наследуем ребенка
[31:15.960 --> 31:18.960]  от шаблонной базы с аргументом самого себя.
[31:19.120 --> 31:22.120]  Класс, наследуем от базы с аргументом самого себя.
[31:22.120 --> 31:25.120]  Проклятое что-то в этом есть, да.
[31:25.120 --> 31:28.120]  Но это работает.
[31:35.120 --> 31:38.120]  В этом вся проклятость.
[31:38.120 --> 31:41.120]  Каким-то образом, да, мы как бы
[31:41.120 --> 31:44.120]  наследуемся от base and derived и как бы в момент
[31:44.120 --> 31:47.120]  работы с базой мы тоже увидим,
[31:47.280 --> 31:50.280]  что derived уже определен вообще-то.
[31:50.280 --> 31:53.280]  Хочется сказать,
[31:53.280 --> 31:56.280]  ой, ну тут derived, вот тут это,
[31:56.280 --> 31:59.280]  когда будет какой-то incomplete и ничего работать не будет.
[31:59.280 --> 32:02.280]  Ну проклятость-то в этом и заключается, что оно работает, блин.
[32:12.280 --> 32:15.280]  Что?
[32:15.440 --> 32:18.440]  Вот как поле здесь завести drive, ты, конечно же, не можешь.
[32:22.440 --> 32:25.440]  Да, а вот так сделать можешь.
[32:29.440 --> 32:32.440]  Ну, поле мы сказали, вот поле типа T,
[32:32.440 --> 32:35.440]  в base завести не получится.
[32:35.440 --> 32:38.440]  А вот использовать в методах можно. Почему?
[32:38.440 --> 32:41.440]  Вспоминаем.
[32:41.440 --> 32:44.440]  Нет.
[32:44.600 --> 32:47.600]  Не угадай.
[32:47.600 --> 32:50.600]  Ленивая инстанциация методов.
[32:50.600 --> 32:53.600]  Да, у вас инстанцируется вот в этом месте
[32:53.600 --> 32:56.600]  только сам class, но не инстанцируются
[32:56.600 --> 32:59.600]  его методы.
[32:59.600 --> 33:02.600]  Да?
[33:02.600 --> 33:05.600]  Вообще ничего не инстанцируется, просто.
[33:05.600 --> 33:08.600]  А вот когда вы где-то в коде
[33:08.600 --> 33:11.600]  уже напишете interface или static func
[33:11.760 --> 33:14.760]  у derived, например, вот в этот момент
[33:14.760 --> 33:17.760]  уже будет инстанцироваться вот это вот или вот это вот.
[33:17.760 --> 33:20.760]  Но к тому-то моменту у нас derived уже определен
[33:20.760 --> 33:23.760]  полностью, работает.
[33:23.760 --> 33:26.760]  Что, после base?
[33:26.760 --> 33:29.760]  Вызов static sub?
[33:29.760 --> 33:32.760]  Да нет, все равно будет работать, наверное,
[33:32.760 --> 33:35.760]  нет, не будет, потому что derived вообще не определен.
[33:41.760 --> 33:44.760]  Да, кстати, кассир на свойство t, кажется, не работает.
[33:44.760 --> 33:47.760]  Не должен, потому что вот на самом деле
[33:47.760 --> 33:50.760]  в момент инстанциации base derived он incomplete.
[33:50.760 --> 33:53.760]  Мы пока не знаем какие там поля и не знаем
[33:53.760 --> 33:56.760]  какие там методы. Мы только знаем, что такая
[33:56.760 --> 33:59.760]  структура есть, ничего больше о ней не знаем.
[33:59.760 --> 34:02.760]  Нет, в смысле?
[34:02.760 --> 34:05.760]  И same?
[34:05.760 --> 34:08.760]  Нет, не должно, и same это уб будет.
[34:08.920 --> 34:11.920]  Same от d и d.
[34:11.920 --> 34:14.920]  Может быть alias?
[34:14.920 --> 34:17.920]  То есть это тоже нужно, чтобы у тебя класс был?
[34:17.920 --> 34:20.920]  Нет, incomplete-тип не может быть alias.
[34:20.920 --> 34:23.920]  Короче...
[34:23.920 --> 34:26.920]  Кажется, там никакие вообще нельзя.
[34:26.920 --> 34:29.920]  Нет, вроде можно, потому что все места, где нам не требуется полнота t,
[34:29.920 --> 34:32.920]  почему быть? Давайте, ну таких мест крайне мало.
[34:32.920 --> 34:35.920]  Давайте прервем вот эту дискуссию.
[34:36.080 --> 34:39.080]  Почему это работает?
[34:39.080 --> 34:42.080]  Потому что на момент наследования,
[34:42.080 --> 34:45.080]  мы инстанцируем шаблон base, но не его методы.
[34:45.080 --> 34:48.080]  Методы инстанцируются лениво,
[34:48.080 --> 34:51.080]  по мере нужды. А в самом шаблоне base,
[34:51.080 --> 34:54.080]  кроме этих методов, ничего нет.
[34:54.080 --> 34:57.080]  Ну и в этот момент инстанциации base, вот это вот t,
[34:57.080 --> 35:00.080]  которое derived будет, это incomplete-type.
[35:00.080 --> 35:03.080]  То есть тип, про который мы знаем, что он тип,
[35:03.240 --> 35:06.240]  знаем, что это структура или класс,
[35:06.240 --> 35:09.240]  но не знаем, какие там поля или какие методы.
[35:09.240 --> 35:12.240]  То есть если ты попытаешься здесь в качестве поля t сохранить,
[35:12.240 --> 35:15.240]  то это работать перестанет, потому что чтобы сохранить тип,
[35:15.240 --> 35:18.240]  как у себя поле, нужно и его поля тоже знать.
[35:18.240 --> 35:21.240]  Размер нужно знать этого типа.
[35:21.240 --> 35:24.240]  А мы не знаем на момент вот инстанциации base.
[35:24.240 --> 35:27.240]  Но когда...
[35:27.240 --> 35:30.240]  Я только что говорил, а ты в это время болтал.
[35:30.400 --> 35:33.400]  Если бы ты послушал, ты бы, наверное, уже понял.
[35:33.400 --> 35:36.400]  Повторяю третий раз.
[35:36.400 --> 35:39.400]  Идет двухфазная инстанциация.
[35:39.400 --> 35:42.400]  Ленивая.
[35:42.400 --> 35:45.400]  Сначала инстанцируется сам класс в момент наследования.
[35:45.400 --> 35:48.400]  Класс без всяких методов инстанцируется.
[35:48.400 --> 35:51.400]  Это вот на первом занятии было, что
[35:51.400 --> 35:54.400]  когда вот так пишете, у вас инстанцируется класс,
[35:54.400 --> 35:57.400]  его поля, его алиасы внутренние, но не методы.
[35:57.560 --> 36:00.560]  В этот момент, как бы, тут t есть,
[36:00.560 --> 36:03.560]  но он incomplete.
[36:03.560 --> 36:06.560]  Как будто forward declaration только был.
[36:06.560 --> 36:09.560]  И использовать его как-то по-нормальному не получится.
[36:09.560 --> 36:12.560]  Не получится с какой-то стати кассир на свойство t написать.
[36:12.560 --> 36:15.560]  Не получится t как поле здесь сохранить.
[36:15.560 --> 36:18.560]  Requires тоже не будут работать, если вы их
[36:18.560 --> 36:21.560]  вне методов напишете.
[36:21.560 --> 36:24.560]  В методах requires можно написать, опять же, из-за ленивости.
[36:24.560 --> 36:27.560]  Если какой-нибудь using напишете,
[36:27.560 --> 36:30.560]  и в нем requires на t, то не будет.
[36:30.560 --> 36:33.560]  В общем, ленивая инстанциация,
[36:33.560 --> 36:36.560]  методы отложены, инстанцируется сам класс.
[36:36.560 --> 36:39.560]  В этот момент t это incomplete type,
[36:39.560 --> 36:42.560]  но мы с ним ничего не делаем тут, мы делаем все в методах.
[36:42.560 --> 36:45.560]  А вот в момент, когда мы уже будем звать эти функции,
[36:45.560 --> 36:48.560]  interface и static func,
[36:48.560 --> 36:51.560]  ну, наверное, мы создадим экземпляр класса derived,
[36:51.560 --> 36:54.560]  и будем звать вот эти методы у него,
[36:54.560 --> 36:57.560]  в этот момент-то и derived тоже полностью определен,
[36:57.560 --> 37:00.560]  и шаблон полностью определен, и мы просто берем
[37:00.560 --> 37:03.560]  и инстанцируем только один метод, который нам нужен.
[37:03.560 --> 37:06.560]  Все.
[37:06.560 --> 37:09.560]  Тоже все работает абсолютно так же,
[37:09.560 --> 37:12.560]  потому что это абсолютно артагональные вещи.
[37:12.560 --> 37:15.560]  Вот все OP, вирчол,
[37:15.560 --> 37:18.560]  pure virtual, оверайды,
[37:18.560 --> 37:21.560]  это все настолько артагонально тому, что мы обсуждаем,
[37:21.560 --> 37:24.560]  что, да, здесь можно пихнуть еще и всякой виртуальности
[37:24.560 --> 37:27.560]  и будет тогда вообще убой.
[37:27.560 --> 37:30.560]  Теплэйтные методы они тоже типа не инстанцируются?
[37:30.560 --> 37:33.560]  Да.
[37:33.560 --> 37:36.560]  Не темплэйтные методы в шаблоне типа
[37:36.560 --> 37:39.560]  они инстанцируются только по нужде.
[37:39.560 --> 37:42.560]  Их инстанциация откладывается. Это было на первой лекции.
[37:42.560 --> 37:45.560]  Там есть запись, можешь ее посмотреть,
[37:45.560 --> 37:48.560]  наверное, достаточно для таких вопросов.
[37:50.560 --> 37:53.560]  Немтя, какой-нибудь оператор копирования в векторе.
[37:53.560 --> 37:56.560]  Вот если бы методы не лениво инстанцировались,
[37:56.560 --> 37:59.560]  а сразу, то вектор UniquePTR бы не скомпилировался,
[37:59.560 --> 38:02.560]  потому что у вектора есть оператор копирования,
[38:02.560 --> 38:05.560]  оператор присваивания с копированием,
[38:05.560 --> 38:08.560]  и там ты пытаешься копировать UniquePTR.
[38:08.560 --> 38:11.560]  Нельзя, ой, не должно компилироваться, но за счет этой ленивой инстанциации оно работает.
[38:11.560 --> 38:14.560]  И здесь тоже за счет этого работает.
[38:15.560 --> 38:18.560]  Это все круто, но зачем это нужно?
[38:18.560 --> 38:21.560]  Вот это абсолютно верно.
[38:21.560 --> 38:24.560]  Да, enableSharedFromThis ровно так работает.
[38:24.560 --> 38:27.560]  В целом, на самом деле понятно, что мы можем делать.
[38:27.560 --> 38:30.560]  Мы можем здесь написать кучу кода и здесь написать кучу кода.
[38:30.560 --> 38:36.560]  И использовать какие-то методы из ребенка прямо посреди этого кода.
[38:36.560 --> 38:39.560]  А потом в ребенке их как бы переопределить
[38:39.560 --> 38:42.560]  и что-то как бы такие, заглушки заткнуть.
[38:42.560 --> 38:45.560]  А если вам это похоже на виртуальные функции?
[38:45.560 --> 38:48.560]  Вот очень похоже.
[38:48.560 --> 38:51.560]  Внимание.
[38:51.560 --> 38:54.560]  Это как бы другой вид полиморфизма.
[38:54.560 --> 38:57.560]  Один из трех китов ООП это полиморфизм,
[38:57.560 --> 39:00.560]  но если быть точнее, это динамический run-time закрытый полиморфизм.
[39:00.560 --> 39:03.560]  Там много конкретных слов нужно поставить,
[39:03.560 --> 39:06.560]  чтобы описать, какой конкретного ООП подразумевается полиморфизм.
[39:06.560 --> 39:09.560]  А это другой вид полиморфизма.
[39:09.560 --> 39:12.560]  Внезапно паттерны ООП, которые были у нас в самом начале,
[39:12.560 --> 39:15.560]  они работают не только с динамическим полиморфизмом
[39:15.560 --> 39:18.560]  на виртуальных вызовах.
[39:18.560 --> 39:21.560]  К чему весь разговор?
[39:21.560 --> 39:24.560]  Вот на таком полиморфизме можно попробовать написать каких-нибудь паттернов.
[39:24.560 --> 39:27.560]  Итератор.
[39:27.560 --> 39:30.560]  Нет, это не нужно.
[39:30.560 --> 39:33.560]  Каких-то более содержательных паттернов, таких структурных, что ли.
[39:33.560 --> 39:36.560]  А, например, шаблонный метод абсолютно понятно,
[39:37.560 --> 39:40.560]  как на этом сделать. Правда?
[39:40.560 --> 39:43.560]  Вот здесь пишете какой-то алгоритм, и в нем используете какие-то там шажочки.
[39:43.560 --> 39:46.560]  А дальше в наследниках эти шажочки дергаете.
[39:46.560 --> 39:49.560]  Пожалуйста, паттерн шаблонный метод без оверхеда
[39:49.560 --> 39:52.560]  на виртуальную диспетчеризацию.
[40:00.560 --> 40:03.560]  Те методы, которые используются в базе, чтобы дефолтные были?
[40:06.560 --> 40:09.560]  Как наследуется от класса, где определен метод size,
[40:09.560 --> 40:12.560]  чтобы в базе можно было использовать метод size?
[40:12.560 --> 40:15.560]  Да, вот эти вот имплементации
[40:15.560 --> 40:18.560]  можно выдвинуть в другой тип,
[40:18.560 --> 40:21.560]  и от него наследоваться тоже. Независимо.
[40:21.560 --> 40:24.560]  Это тоже, кажется, будет работать.
[40:24.560 --> 40:27.560]  Да, это работает.
[40:27.560 --> 40:30.560]  Очень много чего можно натворить с этим. Давайте пойдем по слайдам все-таки.
[40:30.560 --> 40:33.560]  Можно на этот base class смотреть
[40:33.560 --> 40:36.560]  как на некий интерфейс.
[40:36.560 --> 40:39.560]  Вы как бы наследуетесь от интерфейса,
[40:39.560 --> 40:42.560]  но статического, а не динамического.
[40:42.560 --> 40:45.560]  И можно через такой забавный концепт статически проверять,
[40:45.560 --> 40:48.560]  удовлетворяет ли там класс вашему интерфейсу.
[40:51.560 --> 40:54.560]  Но это скорее упражнение по приколу.
[40:54.560 --> 40:57.560]  Можно вот так сделать.
[40:57.560 --> 41:00.560]  Вот этот самый простой вариант развития идеи
[41:00.560 --> 41:03.560]  можно сделать имплементацию по умолчанию.
[41:03.560 --> 41:06.560]  Соответственно, если в дочернем классе
[41:06.560 --> 41:09.560]  есть implementation,
[41:09.560 --> 41:12.560]  то он будет использоваться.
[41:12.560 --> 41:15.560]  А если нету, то будет использоваться из родительского.
[41:15.560 --> 41:18.560]  Вот тут может сломаться
[41:18.560 --> 41:21.560]  в некоторых ситуациях, по-моему.
[41:21.560 --> 41:24.560]  Еще раз, если у нас
[41:24.560 --> 41:27.560]  в дочернем классе
[41:27.560 --> 41:30.560]  определенный implementation, то он вызовется.
[41:30.560 --> 41:33.560]  Да. А если нет, то вызовется вот этот из родительского.
[41:33.560 --> 41:36.560]  Мы же родительский, вот этот вот. Родительский.
[41:36.560 --> 41:39.560]  Нет, не виртуальный.
[41:39.560 --> 41:42.560]  Это статическое происходит.
[41:45.560 --> 41:48.560]  Что void.interface?
[41:48.560 --> 41:51.560]  Я имею ввиду, чтобы функции интерфейса static func
[41:51.560 --> 41:54.560]  не сломаются при вызове.
[41:54.560 --> 41:57.560]  Потому что в этот момент уже все определено.
[41:57.560 --> 42:00.560]  Давайте дальше.
[42:00.560 --> 42:03.560]  На самом деле, ну да, это как бы aboost two-phase lookup
[42:03.560 --> 42:06.560]  по большей части. В частности того,
[42:06.560 --> 42:09.560]  что для корректного two-phase lookup необходимо
[42:09.560 --> 42:12.560]  откладывать инстанциацию методов.
[42:12.560 --> 42:15.560]  Почему это важно осознавать?
[42:15.560 --> 42:18.560]  Потому что на MSWC некорректно реализован
[42:18.560 --> 42:21.560]  two-phase lookup и некоторые,
[42:21.560 --> 42:24.560]  по-моему, да.
[42:24.560 --> 42:27.560]  И некоторые шаблонные трюки, которые у нас
[42:27.560 --> 42:30.560]  на гцц и кланге прекрасно работают на MSWC,
[42:30.560 --> 42:33.560]  работать не будут. Или работать по-другому.
[42:33.560 --> 42:36.560]  Врут.
[42:36.560 --> 42:39.560]  Ну, возможно, это какая-то совсем bleeding-gauge версия,
[42:39.560 --> 42:42.560]  потому что я на работе наткнулся недавно.
[42:42.560 --> 42:45.560]  Не помню.
[42:45.560 --> 42:48.560]  Свежая. Мы часто обновляем компиляторы.
[42:48.560 --> 42:51.560]  Да, по-моему, да. Ладно.
[42:51.560 --> 42:54.560]  Не факт.
[42:54.560 --> 42:57.560]  В общем, да, долгое время в MSWC точно
[42:57.560 --> 43:00.560]  был сломан two-phase lookup, поэтому трюки с CRTP
[43:00.560 --> 43:03.560]  на MSWC могут работать либо как-то иначе,
[43:03.560 --> 43:06.560]  либо совсем не работать. Будьте внимательны
[43:06.560 --> 43:09.560]  в кроссплатформенных проектах.
[43:09.560 --> 43:12.560]  В принципе, такой техникой
[43:12.560 --> 43:15.560]  можно просто подмешивать какой-то контент
[43:15.560 --> 43:18.560]  новый в дочерний класс.
[43:18.560 --> 43:21.560]  При этом этот контент еще и может пользоваться
[43:21.560 --> 43:24.560]  какими-то свойствами дочернего класса.
[43:24.560 --> 43:27.560]  То есть работать как статический интерфейс.
[43:27.560 --> 43:30.560]  И главное, что это замена такая виртуальным вызовом.
[43:30.560 --> 43:33.560]  Вот в некоторых местах вам на самом деле не нужно
[43:33.560 --> 43:36.560]  в runtime ничего определять. У вас все в compile-time
[43:36.560 --> 43:39.560]  известно. Поэтому можно взять и заменить
[43:39.560 --> 43:42.560]  от OP, просто выдрав интерфейс, заменив на CRTP,
[43:42.560 --> 43:45.560]  и в принципе продолжит работать,
[43:45.560 --> 43:48.560]  но будет быстрее, бесплатно.
[43:48.560 --> 43:51.560]  Ну, зависит от того, как вы это написали, конечно.
[43:51.560 --> 43:54.560]  Это все нормально будет.
[43:54.560 --> 43:57.560]  Вопрос.
[43:57.560 --> 44:00.560]  Вот если мы в этой базе CRTP-шной
[44:00.560 --> 44:03.560]  напишем обращение к фаузу методу,
[44:03.560 --> 44:06.560]  а в базе этот метод не определим,
[44:06.560 --> 44:09.560]  насколько накрученную ошибку
[44:10.560 --> 44:13.560]  Ну, такую неприятненькую, что типа
[44:13.560 --> 44:16.560]  я не нашел метод.
[44:16.560 --> 44:19.560]  Да.
[44:19.560 --> 44:22.560]  Нет, концептом нельзя проверить,
[44:22.560 --> 44:25.560]  что в derived есть нужное.
[44:25.560 --> 44:28.560]  Хотя нет, можно.
[44:28.560 --> 44:31.560]  Что?
[44:31.560 --> 44:34.560]  Но если хочется
[44:34.560 --> 44:37.560]  подсказки
[44:37.560 --> 44:40.560]  то, кажется,
[44:40.560 --> 44:43.560]  короткий ответ нельзя,
[44:43.560 --> 44:46.560]  а длинный можно сделать отдельный класс,
[44:46.560 --> 44:49.560]  который реализует контракт,
[44:49.560 --> 44:52.560]  задаваемый концептом,
[44:52.560 --> 44:55.560]  и тот объект, который мы используем,
[44:55.560 --> 44:58.560]  он будет наследоваться CRTP базы
[44:58.560 --> 45:01.560]  с шаблонным параметром
[45:01.560 --> 45:04.560]  этого объекта.
[45:04.560 --> 45:07.560]  То и на это нормально,
[45:07.560 --> 45:10.560]  потому что вот это вот надо самому написать,
[45:10.560 --> 45:13.560]  и тогда станешь понимать, о чем речь идет.
[45:13.560 --> 45:16.560]  А пока ты сам не написал, абсолютно неясно.
[45:16.560 --> 45:19.560]  Да, что ты говорил.
[45:19.560 --> 45:22.560]  Я хотел сказать, что можно же
[45:22.560 --> 45:25.560]  сделать интерфейс в олд-вишном понимании
[45:25.560 --> 45:28.560]  с пьюр-виртюровыми методами,
[45:28.560 --> 45:31.560]  а просто в наследнике, по-моему, файл.
[45:31.560 --> 45:34.560]  Да, есть такое...
[45:34.560 --> 45:37.560]  Если я что-то не определю,
[45:37.560 --> 45:40.560]  будет читаемая ошибка, и при этом вроде бы
[45:40.560 --> 45:43.560]  ректуализация в рандеме не будет.
[45:43.560 --> 45:46.560]  Нет, она все равно будет, потому что
[45:46.560 --> 45:49.560]  ключевое слово «файнал» — это подсказка,
[45:49.560 --> 45:52.560]  ну и гарантия, что других наследников дальше не будет.
[45:52.560 --> 45:55.560]  Но...
[45:55.560 --> 45:58.560]  Вот где можно.
[45:58.560 --> 46:01.560]  А периодически пишется код, в котором нельзя понять
[46:01.560 --> 46:04.560]  в Compile Time, что на самом деле за объект
[46:04.560 --> 46:07.560]  придет по интерфейсу.
[46:07.560 --> 46:10.560]  Ну, такой код очень легко написать, правда,
[46:10.560 --> 46:13.560]  и несмотря на то, что фактически там может быть
[46:13.560 --> 46:16.560]  всегда только один единственный вариант
[46:16.560 --> 46:19.560]  по логике вашего кода компилятора,
[46:19.560 --> 46:22.560]  до этого догадаться не может,
[46:22.560 --> 46:25.560]  из-за того, что там информация по нескольким
[46:25.560 --> 46:28.560]  кодам раскидана, и в итоге вы получаете
[46:28.560 --> 46:31.560]  виртуальные вызовы, хотя они вам не нужны.
[46:31.560 --> 46:34.560]  Да.
[46:34.560 --> 46:37.560]  Просто если не написать «файнал»,
[46:37.560 --> 46:40.560]  и мы будем обращаться по указателю на дирайта,
[46:40.560 --> 46:43.560]  там все равно будет виртуализация, потому что, возможно, дирайта есть какой-то наследник,
[46:43.560 --> 46:46.560]  и там мы скастили, короче, базу.
[46:46.560 --> 46:49.560]  Вот дирайт тоже может быть больше, чем кого-то.
[46:49.560 --> 46:52.560]  А если мы написали «файнал», то это уже невозможно,
[46:53.560 --> 46:56.560]  Опять же, это все работает,
[46:56.560 --> 46:59.560]  если только у тебя простой код, и компилятор видит,
[46:59.560 --> 47:02.560]  что ты вот в этот указательный интерфейс
[47:02.560 --> 47:05.560]  сохранил объект, который на самом деле вот такой,
[47:05.560 --> 47:08.560]  и на самом деле у него там все final,
[47:08.560 --> 47:11.560]  и компилятору сложно догадываться в ОП коде,
[47:11.560 --> 47:14.560]  что на самом деле будет вызвано. Я бы даже сказал, невозможно.
[47:14.560 --> 47:17.560]  Нет, если ты просто создал экземпляр derived,
[47:17.560 --> 47:20.560]  и у него что-то помечено final, и ты его вызвал,
[47:20.560 --> 47:23.560]  то, да, конечно, там виртуального вызова не будет,
[47:23.560 --> 47:26.560]  но это не сильно поможет. Обычно там интерфейсы начинают накручивать,
[47:26.560 --> 47:29.560]  и вот из-за них всякие беды,
[47:29.560 --> 47:32.560]  что там что-то приходит по интерфейсу, и все перестает работать.
[47:32.560 --> 47:35.560]  Да, я не сказал самого главного,
[47:35.560 --> 47:38.560]  вы все еще с CRTP как бы можете
[47:38.560 --> 47:41.560]  передавать штуки по ссылке на база T.
[47:41.560 --> 47:44.560]  Только T это вам будет известен уже,
[47:44.560 --> 47:47.560]  но это все равно в некоторой степени прикольно,
[47:47.560 --> 47:50.560]  что вы как бы прячете сам T и говорите,
[47:50.560 --> 47:53.560]  только из этого набора методов что-то вызывай,
[47:53.560 --> 47:56.560]  но самого derived ничего не смей вызывать.
[47:56.560 --> 47:59.560]  Ну и, конечно, это требует шаблонизации всего,
[47:59.560 --> 48:02.560]  если вы хотите с любым T работать.
[48:02.560 --> 48:05.560]  По-моему, еще условие, что это должны быть полей наследника.
[48:05.560 --> 48:08.560]  Иначе это...
[48:08.560 --> 48:11.560]  Что?
[48:11.560 --> 48:14.560]  Наследника поля могут быть наследник любой.
[48:14.560 --> 48:17.560]  Давайте про полезное применение этого.
[48:17.560 --> 48:20.560]  Это паттерн-прототип.
[48:20.560 --> 48:23.560]  Помните его.
[48:23.560 --> 48:26.560]  Когда вы его реализуете, вам нужно вот этот pure virtual
[48:26.560 --> 48:29.560]  метод взять и завернуть
[48:29.560 --> 48:32.560]  и вернуть отсюда new square,
[48:32.560 --> 48:35.560]  отсюда вернуть new circle,
[48:35.560 --> 48:38.560]  ну и запустив там конструктор копирования.
[48:38.560 --> 48:41.560]  Давайте не будем копипастить,
[48:41.560 --> 48:44.560]  сделаем вот так.
[48:44.560 --> 48:47.560]  Это
[48:47.560 --> 48:50.560]  CRTP промежуточный класс
[48:50.560 --> 48:53.560]  на следующий abstract shape.
[48:53.560 --> 48:56.560]  Он все еще pure virtual, но он шаблонный.
[48:56.560 --> 48:59.560]  И подмешивает в свой
[48:59.560 --> 49:02.560]  дочерний класс функцию clone,
[49:02.560 --> 49:05.560]  которая возвращает по интерфейсу
[49:05.560 --> 49:08.560]  abstract shape
[49:08.560 --> 49:11.560]  копию себя, но скачанного derived.
[49:11.560 --> 49:14.560]  Понятно, да?
[49:14.560 --> 49:17.560]  Нет? Внимательно смотрите.
[49:20.560 --> 49:23.560]  Да, потому что задумано,
[49:23.560 --> 49:26.560]  что ты из square и circle наследуешь от shape
[49:26.560 --> 49:29.560]  с собой CRTP.
[49:29.560 --> 49:32.560]  И автоматом получишь в них метод clone правильный.
[49:32.560 --> 49:35.560]  Это очень мощный подход
[49:35.560 --> 49:38.560]  к дедупликации всякой копипасты,
[49:38.560 --> 49:41.560]  которая у вас одинаковая примерно,
[49:41.560 --> 49:44.560]  но в этой копипасте необходимо знать
[49:44.560 --> 49:47.560]  статический тип.
[49:50.560 --> 49:53.560]  Да, я и сомневаюсь, что много кто
[49:53.560 --> 49:56.560]  открыл, кроме тебя.
[49:56.560 --> 49:59.560]  О, два человека.
[49:59.560 --> 50:02.560]  Потому что люди не открывают ссылки в чате,
[50:02.560 --> 50:05.560]  если это кому-то другому ответ.
[50:05.560 --> 50:08.560]  Но с этим можно еще и визитер очень круто написать.
[50:08.560 --> 50:11.560]  Либо посмотрите в чате, либо сами попробуйте.
[50:11.560 --> 50:14.560]  В визитере ассепт был, который надо копипастить.
[50:14.560 --> 50:17.560]  Точно такая же техника.
[50:17.560 --> 50:20.560]  Так, нужно еще про это что-то сказать? Нет?
[50:20.560 --> 50:23.560]  Все. Ура.
[50:23.560 --> 50:26.560]  Стало чуть получше.
[50:26.560 --> 50:29.560]  Она применяется практически повсюду,
[50:29.560 --> 50:32.560]  но когда пытаешься найти, найти очень сложно.
[50:32.560 --> 50:35.560]  Потому что никто не называет этот CRTP в коде,
[50:35.560 --> 50:38.560]  все просто пишут коды такие.
[50:38.560 --> 50:41.560]  Написал, сделал, классно.
[50:41.560 --> 50:44.560]  Из того, что удалось за пять публей найти,
[50:44.560 --> 50:47.560]  это в стандартной библиотеке есть shared from this,
[50:47.560 --> 50:50.560]  уже сказали про него, и view interface.
[50:50.560 --> 50:53.560]  Сейчас в 26-ые предлагают добавить итератор interface.
[50:53.560 --> 50:56.560]  Там итераторы вообще все на CRTP работают.
[50:56.560 --> 50:59.560]  Вот непроверенная информация,
[50:59.560 --> 51:02.560]  но ссылка кликабельна, поэтому можете пойти посмотреть.
[51:02.560 --> 51:05.560]  Я уже не помню, что там было.
[51:08.560 --> 51:11.560]  Там разбития для ксемы.
[51:11.560 --> 51:14.560]  Пока.
[51:14.560 --> 51:17.560]  Маленький трюк, маленький прикол,
[51:17.560 --> 51:20.560]  который соединяет вместе все, что было до этого,
[51:20.560 --> 51:23.560]  чтобы лекция была такой состоятельной.
[51:23.560 --> 51:26.560]  Можно добавить CRTP, ADL и друзья вместе,
[51:26.560 --> 51:29.560]  и получить прикол.
[51:29.560 --> 51:32.560]  И операторы сравнения тоже.
[51:32.560 --> 51:35.560]  Это не очень актуальный прикол,
[51:35.560 --> 51:38.560]  немножко протухший, баянистый, но все равно прикольно.
[51:38.560 --> 51:41.560]  Мы сделаем CRTP-класс
[51:41.560 --> 51:44.560]  с френдами,
[51:44.560 --> 51:47.560]  с френд-дефинишенами, обратите внимание,
[51:47.560 --> 51:50.560]  которые сравнивают
[51:50.560 --> 51:53.560]  два экземпляра t,
[51:53.560 --> 51:56.560]  где t – это draft,
[51:56.560 --> 51:59.560]  через некоторый метод equal to.
[52:02.560 --> 52:05.560]  Поняли, что вот это такая бодяга?
[52:05.560 --> 52:08.560]  Теперь как его использовать?
[52:08.560 --> 52:11.560]  Приватно наследуем
[52:11.560 --> 52:14.560]  нашу шнягу от equal comparable
[52:14.560 --> 52:17.560]  с собой,
[52:17.560 --> 52:20.560]  и один метод реализуем.
[52:20.560 --> 52:23.560]  equal to.
[52:23.560 --> 52:26.560]  Да, френды.
[52:26.560 --> 52:29.560]  Тут еще раз важно оговориться,
[52:29.560 --> 52:32.560]  что когда где-то кто-то в коде
[52:32.560 --> 52:35.560]  будет писать,
[52:35.560 --> 52:38.560]  ваш value type равно равно
[52:38.560 --> 52:41.560]  еще один какой-то объект value type,
[52:41.560 --> 52:44.560]  то у вас появляются эти операторы,
[52:44.560 --> 52:47.560]  вот эти вот френды.
[52:47.560 --> 52:50.560]  Это важная деталь про вот этих френдов,
[52:50.560 --> 52:53.560]  которые я не сказал.
[52:53.560 --> 52:56.560]  Их невозможно вызвать квалифицированно.
[52:56.560 --> 52:59.560]  Когда вот пишете friend и объявляете метод
[52:59.560 --> 53:02.560]  прямо в классе,
[53:02.560 --> 53:05.560]  квалифицированного имени у них нет.
[53:05.560 --> 53:08.560]  И вызвать их можно только через ADL.
[53:08.560 --> 53:11.560]  Через ADL по value type
[53:11.560 --> 53:14.560]  мы находим ассоциированный
[53:14.560 --> 53:17.560]  родительский класс,
[53:17.560 --> 53:20.560]  а идем сюда,
[53:20.560 --> 53:23.560]  а вот эти френды попадают во внешний
[53:23.560 --> 53:26.560]  namespace, поэтому они найдутся.
[53:26.560 --> 53:29.560]  Понятно, что произошло, да?
[53:29.560 --> 53:32.560]  Ничего не понятно.
[53:32.560 --> 53:35.560]  Говорите со мной, понятно, почему нашлись эти френды
[53:35.560 --> 53:38.560]  и пробросились уже к equal to,
[53:38.560 --> 53:41.560]  который мы один реализовали.
[53:41.560 --> 53:44.560]  Итого, мы научились вместо того, чтобы писать два оператора
[53:44.560 --> 53:47.560]  ручками, когда хотим наш класс сделать сравнимым,
[53:47.560 --> 53:50.560]  писать одну такую строчку простую
[53:50.560 --> 53:53.560]  и один оператор сравнения.
[53:53.560 --> 53:56.560]  Угадайте, что дальше? Можно то же самое сделать и для…
[53:56.560 --> 53:59.560]  Да, вот, кстати, почему вот эти френды здорово?
[53:59.560 --> 54:02.560]  А потому что вообще не стоит засорять
[54:03.560 --> 54:06.560]  Зачем вам лишние имена добавлять, которые можно найти?
[54:06.560 --> 54:09.560]  Более того, в определенный момент,
[54:09.560 --> 54:12.560]  когда вы увлекаетесь слишком сильной метапрогой,
[54:12.560 --> 54:15.560]  вы начинаетесь по производительности программы
[54:15.560 --> 54:18.560]  упираться в ее время компиляции.
[54:18.560 --> 54:21.560]  Сбор множества имен
[54:21.560 --> 54:24.560]  и overload resolution на нем
[54:24.560 --> 54:27.560]  периодически оказывается ботлнеком в этом вопросе,
[54:27.560 --> 54:30.560]  потому что слишком много имен в каждом namespace, их слишком много
[54:30.560 --> 54:33.560]  находится, то есть пишете какой-нибудь оператор равно-равно,
[54:33.560 --> 54:36.560]  и там вываливается у вас из всех хедеров
[54:36.560 --> 54:39.560]  тысячи разных операторов равно-равно.
[54:39.560 --> 54:42.560]  Вот этот вот сет на тысячи имен мы идем там что-то инстанцируем
[54:42.560 --> 54:45.560]  еще шаблонное, еще overload resolution запускаем.
[54:45.560 --> 54:48.560]  Долго. Поэтому можно делать вот так.
[54:48.560 --> 54:51.560]  Вот эти френды, их невозможно найти, вот эти функции,
[54:51.560 --> 54:54.560]  невозможно найти ни по какому имени, кроме как
[54:54.560 --> 54:57.560]  ассоциированному с equal comparable
[54:57.560 --> 55:00.560]  или его namespace'ом.
[55:00.560 --> 55:03.560]  По-моему токсика comparable.
[55:03.560 --> 55:06.560]  И это здорово.
[55:06.560 --> 55:09.560]  Меньше засорения namespace, но какой ценой.
[55:09.560 --> 55:12.560]  Да, но ты, по-моему, не сможешь их найти
[55:12.560 --> 55:15.560]  через ассоциацию с другим классом, я не уверен.
[55:15.560 --> 55:18.560]  Это опять лютая деталь.
[55:18.560 --> 55:21.560]  Да, квалифицировано
[55:21.560 --> 55:24.560]  обратиться к ним вообще нельзя.
[55:24.560 --> 55:27.560]  Они волшебные.
[55:27.560 --> 55:30.560]  Тихо, Андрей, подожди.
[55:30.560 --> 55:33.560]  Да, они волшебные, это просто магия,
[55:33.560 --> 55:36.560]  их нельзя достать квалифицированно.
[55:36.560 --> 55:39.560]  По-настоящему магия, в стандарте написано,
[55:39.560 --> 55:42.560]  когда у вас friend definition, qualify lookup невозможен,
[55:42.560 --> 55:45.560]  но считается, что функция лежит
[55:45.560 --> 55:48.560]  во внешнем namespace'е.
[55:48.560 --> 55:51.560]  Просто так.
[55:51.560 --> 55:54.560]  В основном namespace'е объявления этой функции нет.
[55:54.560 --> 55:57.560]  Ты на namespace смотришь, а в нем ничего нет.
[55:57.560 --> 56:00.560]  В контексте класса объявление есть,
[56:00.560 --> 56:03.560]  в контексте namespace объявления нет.
[56:03.560 --> 56:06.560]  Именно объявление не сущности, а ее объявление.
[56:06.560 --> 56:09.560]  Ну как бы да, но мне такое не добавляет понимание.
[56:09.560 --> 56:12.560]  Я смирился с этим как просто, с реальностью.
[56:12.560 --> 56:15.560]  Оно работает вот так.
[56:15.560 --> 56:18.560]  Friend'ы находятся только через EDL, но это нам не помеха,
[56:18.560 --> 56:21.560]  меньше засорения namespace'ов.
[56:21.560 --> 56:24.560]  Да, следующий шаг, это просто взять
[56:24.560 --> 56:27.560]  и через такую же технику операторы меньше, больше,
[56:27.560 --> 56:30.560]  все остальное все определить через нее.
[56:30.560 --> 56:33.560]  Итого вместо шести операторов можно написать сколько?
[56:33.560 --> 56:36.560]  Примерно, можно один,
[56:36.560 --> 56:39.560]  если это будет ваш ручной аналог 3-way compare.
[56:39.560 --> 56:42.560]  Да, то есть
[56:42.560 --> 56:45.560]  как бы до оператора spaceship'а
[56:45.560 --> 56:48.560]  люди, которые очень любили сравнивать разные типы,
[56:48.560 --> 56:51.560]  они тоже как-то выкручивались, ну вот примерно так.
[56:51.560 --> 56:54.560]  Что?
[56:54.560 --> 56:57.560]  В том, что мы не пишем не равно или что?
[56:57.560 --> 57:00.560]  Да, в том, что мы не пишем не равно.
[57:00.560 --> 57:03.560]  Да, а сейчас ты просто spaceship'ы используй
[57:03.560 --> 57:06.560]  и не парься. Но в целом это вот
[57:06.560 --> 57:09.560]  как бы хорошее применение, все, что мы только что видели.
[57:09.560 --> 57:12.560]  Тут EDL и вот эти вот front definitions
[57:12.560 --> 57:15.560]  и сравнения участвуют
[57:15.560 --> 57:18.560]  и с RTP и вообще так классно.
[57:18.560 --> 57:21.560]  И все это называется Barton-Nachman-Trick.
[57:24.560 --> 57:27.560]  Ну как бы вот
[57:27.560 --> 57:30.560]  мораль, я не знаю, как еще прокомментировать.
[57:30.560 --> 57:33.560]  Да, наверное, все-таки суть этого трюка в первую очередь
[57:33.560 --> 57:36.560]  в том, что не как бы не в операторах сравнения,
[57:36.560 --> 57:39.560]  а в том, что мы генерируем внешние функции
[57:39.560 --> 57:42.560]  по отношению к классу. Можно генерирует не только операторы.
[57:42.560 --> 57:45.560]  Если у вас есть какое-нибудь соглашение
[57:45.560 --> 57:48.560]  о том, что через EDL должна находиться функция
[57:48.560 --> 57:51.560]  bar, ну вот как в стандарте swap есть
[57:51.560 --> 57:54.560]  begin и end, вы свою такую функцию сделали bar
[57:54.560 --> 57:57.560]  и решили ее там как-то выражать через что-то.
[57:57.560 --> 58:00.560]  Ну вот тут точно так же ее можно
[58:00.560 --> 58:03.560]  френдами нагенерить для произвольного класса.
[58:03.560 --> 58:06.560]  Мне кажется, здесь лучше все
[58:06.560 --> 58:09.560]  сформулировано, вот это вот не в усталом виде писалось,
[58:09.560 --> 58:12.560]  и сейчас я устал.
[58:12.560 --> 58:15.560]  Да, вот генерирование внешних функций,
[58:15.560 --> 58:18.560]  это, наверное, самая правильная фраза.
[58:18.560 --> 58:21.560]  Финалочка, которую я добавил вчера ночью,
[58:21.560 --> 58:24.560]  перед тем, как понял, что надо
[58:24.560 --> 58:27.560]  заполнять вот этот вот
[58:27.560 --> 58:30.560]  интплан замечательный.
[58:30.560 --> 58:33.560]  Ну это 23 плюсы.
[58:33.560 --> 58:36.560]  У нас они пока не включены.
[58:36.560 --> 58:39.560]  Я не уверен, что стоит пытаться,
[58:39.560 --> 58:42.560]  потому что очень все сыро.
[58:42.560 --> 58:45.560]  Но знать про это надо, потому что
[58:45.560 --> 58:48.560]  это как бы захайпит вас как-то продавливать
[58:48.560 --> 58:51.560]  обновления на новые стандарты на работе
[58:51.560 --> 58:54.560]  и в разных проектах ваших.
[58:54.560 --> 58:57.560]  Значит, есть такая структурка старая,
[58:57.560 --> 59:00.560]  есть метод, сколько у него аргументов?
[59:00.560 --> 59:03.560]  Один? Это правильно.
[59:03.560 --> 59:06.560]  Есть неявный аргумент this, первый.
[59:06.560 --> 59:09.560]  А теперь можно его сделать явным.
[59:09.560 --> 59:12.560]  Вот это вся фича.
[59:12.560 --> 59:15.560]  Вы просто пишите this, тип должен быть
[59:15.560 --> 59:18.560]  такой же, как у структурки,
[59:18.560 --> 59:21.560]  и какое-нибудь название свое придумаете.
[59:21.560 --> 59:24.560]  Можно self, можно me, I, как хотите.
[59:24.560 --> 59:27.560]  Что-что?
[59:27.560 --> 59:30.560]  Ну, тут сейчас понятно будет,
[59:30.560 --> 59:33.560]  почему это мощно.
[59:33.560 --> 59:36.560]  Что так-то это...
[59:36.560 --> 59:39.560]  Что?
[59:39.560 --> 59:42.560]  Ну, нет.
[59:42.560 --> 59:45.560]  Ну ссылки и покупатели в этом плане
[59:45.560 --> 59:48.560]  одинаково работают. Не в этом суть.
[59:48.560 --> 59:51.560]  Кажется, что это так, типа какая-то мелочь,
[59:51.560 --> 59:54.560]  зачем ее добавили.
[59:55.560 --> 59:58.560]  Как бы обращаться внутри такого метода
[59:58.560 --> 01:00:01.560]  нужно чуть-чуть по-другому к полям и к другим функциям.
[01:00:01.560 --> 01:00:04.560]  У вас пропадает вот эта фишка,
[01:00:04.560 --> 01:00:07.560]  что вы можете имя упомянуть
[01:00:07.560 --> 01:00:10.560]  и обратиться к методам, если я не ошибаюсь.
[01:00:10.560 --> 01:00:13.560]  Теперь нужно явно писать self.x строго.
[01:00:13.560 --> 01:00:16.560]  Ключевое слово this тоже перестает работать
[01:00:16.560 --> 01:00:19.560]  в рамках вот этого вот, по-моему.
[01:00:19.560 --> 01:00:22.560]  То есть это даже целый новый вид объявлений методов,
[01:00:22.560 --> 01:00:25.560]  которые по-другому принципу работают
[01:00:25.560 --> 01:00:28.560]  и механика у них другая.
[01:00:28.560 --> 01:00:31.560]  Интересно, что происходит с заплатой ляма в этом случае.
[01:00:31.560 --> 01:00:34.560]  Лям-дизис дает некоторые возможности быть фундомом.
[01:00:34.560 --> 01:00:37.560]  А что здесь происходит?
[01:00:37.560 --> 01:00:40.560]  Можно рекурсированный лям делать.
[01:00:40.560 --> 01:00:43.560]  Сейчас все будет.
[01:00:43.560 --> 01:00:46.560]  Ну, вот такая функция.
[01:00:46.560 --> 01:00:49.560]  Теперь настал вот такой.
[01:00:49.560 --> 01:00:52.560]  Да.
[01:00:52.560 --> 01:00:55.560]  Или даже такой.
[01:00:55.560 --> 01:00:58.560]  Это как-то да, это вот как-то сильно удобнее,
[01:00:58.560 --> 01:01:01.560]  чем то, что было раньше с вот этим вот приписыванием,
[01:01:01.560 --> 01:01:04.560]  где-то справа непонятным.
[01:01:04.560 --> 01:01:07.560]  Тут теперь простой синтаксис, как во всем другом языке.
[01:01:07.560 --> 01:01:10.560]  Пока шаблон мы сюда не делили,
[01:01:10.560 --> 01:01:13.560]  всё сильно куча не стало.
[01:01:13.560 --> 01:01:16.560]  Теперь мы только что реализовали 4 разных метода
[01:01:16.560 --> 01:01:19.560]  в одном.
[01:01:19.560 --> 01:01:22.560]  Потому что раньше вам нужно было руками где-то там костылять
[01:01:22.560 --> 01:01:25.560]  вот этот вот имперсандик, словоконст там дописывать.
[01:01:25.560 --> 01:01:28.560]  Да тоже почему нет?
[01:01:28.560 --> 01:01:31.560]  Можешь оператор квадратной скобки сделать
[01:01:31.560 --> 01:01:34.560]  как бы...
[01:01:34.560 --> 01:01:37.560]  Всё, то есть это и константное lvalue,
[01:01:37.560 --> 01:01:40.560]  и просто lvalue, и rvalue,
[01:01:40.560 --> 01:01:43.560]  и даже если вы извращенец,
[01:01:43.560 --> 01:01:46.560]  то это константное rvalue, ссылка.
[01:01:46.560 --> 01:01:49.560]  Волотайл покрыли.
[01:01:49.560 --> 01:01:52.560]  Вот там у вас t,
[01:01:52.560 --> 01:01:55.560]  мы говорим this, t,
[01:01:55.560 --> 01:01:58.560]  у нас есть self,
[01:01:58.560 --> 01:02:01.560]  у нас теперь self
[01:02:01.560 --> 01:02:04.560]  в качестве this, но при этом
[01:02:04.560 --> 01:02:07.560]  типа t2%
[01:02:07.560 --> 01:02:10.560]  Когда ты сделаешь,
[01:02:10.560 --> 01:02:13.560]  смотри, пусть у нас есть объект x
[01:02:13.560 --> 01:02:16.560]  типа new and shiny,
[01:02:16.560 --> 01:02:19.560]  вот ты делаешь x.doSomething,
[01:02:19.560 --> 01:02:22.560]  ну x это lvalue, да?
[01:02:22.560 --> 01:02:25.560]  будет lvalue, ссылка.
[01:02:25.560 --> 01:02:28.560]  Теперь делаешь std move x.doSomething,
[01:02:28.560 --> 01:02:31.560]  теперь x будет rvalue.
[01:02:31.560 --> 01:02:34.560]  Если вызвать эту функцию шаблоном параметром других,
[01:02:34.560 --> 01:02:37.560]  не new and shiny,
[01:02:37.560 --> 01:02:40.560]  а хороший вопрос.
[01:02:40.560 --> 01:02:43.560]  Я понятия не имею, что произойдёт.
[01:02:43.560 --> 01:02:46.560]  Что будет, если подставить в этот метод
[01:02:46.560 --> 01:02:49.560]  шаблонный аргумент не new and shiny,
[01:02:49.560 --> 01:02:52.560]  а какой-то совсем левый,
[01:02:52.560 --> 01:02:55.560]  и попытаться вызвать?
[01:02:55.560 --> 01:02:58.560]  Он мне кажется даст...
[01:02:58.560 --> 01:03:01.560]  даст синтезировать новый список аргументов
[01:03:01.560 --> 01:03:04.560]  из двух элементов,
[01:03:04.560 --> 01:03:07.560]  который может помочь.
[01:03:07.560 --> 01:03:10.560]  Если new and shiny указалось...
[01:03:10.560 --> 01:03:13.560]  кажется да.
[01:03:13.560 --> 01:03:16.560]  Просто тебе скажут, что ты неправ,
[01:03:16.560 --> 01:03:19.560]  потому что твой тип не костуется к тому,
[01:03:19.560 --> 01:03:22.560]  что ты указал.
[01:03:22.560 --> 01:03:25.560]  t не костуется к new and shiny.
[01:03:25.560 --> 01:03:28.560]  t по умолчанию выводится из того,
[01:03:28.560 --> 01:03:31.560]  на чём ты .doSomething сделал.
[01:03:31.560 --> 01:03:34.560]  Не совпадает.
[01:03:37.560 --> 01:03:40.560]  Из expression,
[01:03:40.560 --> 01:03:43.560]  который стоит слева от точки.
[01:03:56.560 --> 01:03:59.560]  Тут дело в том,
[01:03:59.560 --> 01:04:02.560]  что у меня есть new and shiny,
[01:04:02.560 --> 01:04:05.560]  у меня есть derived 1,
[01:04:05.560 --> 01:04:08.560]  есть derived 2.
[01:04:08.560 --> 01:04:11.560]  Про наследников пока не говори ничего,
[01:04:11.560 --> 01:04:14.560]  всё будет.
[01:04:14.560 --> 01:04:17.560]  Я говорю, что если просто какой-то
[01:04:17.560 --> 01:04:20.560]  рандомную мусорную фигню указать,
[01:04:20.560 --> 01:04:23.560]  интересно, а другая сторона нет.
[01:04:23.560 --> 01:04:26.560]  Как стереть?
[01:04:26.560 --> 01:04:29.560]  Нет.
[01:04:29.560 --> 01:04:32.560]  Тут нет ластика.
[01:04:32.560 --> 01:04:35.560]  Хорошо.
[01:04:35.560 --> 01:04:38.560]  Bright only память, наша любимая.
[01:04:38.560 --> 01:04:41.560]  Если мы здесь укажем какой-то рандомный мусор
[01:04:41.560 --> 01:04:44.560]  типа int,
[01:04:44.560 --> 01:04:47.560]  то нам, конечно, скажут, что это неправ.
[01:04:47.560 --> 01:04:50.560]  Вот это не является int.
[01:04:50.560 --> 01:04:53.560]  Но если мы тогда ничего в треугольной скобке не написали,
[01:04:53.560 --> 01:04:56.560]  то мы будем вводить из вот этого выражения,
[01:04:56.560 --> 01:04:59.560]  какой тип нам нужен.
[01:04:59.560 --> 01:05:02.560]  Здесь это какой-то x типа new and shiny.
[01:05:02.560 --> 01:05:05.560]  Что-то вообще кроме new and shiny
[01:05:05.560 --> 01:05:08.560]  может быть в t-подставе?
[01:05:08.560 --> 01:05:11.560]  Да, сейчас будет.
[01:05:11.560 --> 01:05:14.560]  Да, может.
[01:05:14.560 --> 01:05:17.560]  Нет, мы не настолько крутые.
[01:05:17.560 --> 01:05:20.560]  В этом весь убойный эффект.
[01:05:21.560 --> 01:05:24.560]  Внимание, то, чего я вас лишил на прошлой паре,
[01:05:24.560 --> 01:05:27.560]  то, как можно делать на пазо прошлой.
[01:05:27.560 --> 01:05:30.560]  Из 20 плюсов можно, оказывается,
[01:05:30.560 --> 01:05:33.560]  писать авто в аргументах.
[01:05:33.560 --> 01:05:36.560]  Раньше это у лямп можно было только,
[01:05:36.560 --> 01:05:39.560]  а теперь вообще у любых функций.
[01:05:39.560 --> 01:05:42.560]  Это тот же самый код.
[01:05:42.560 --> 01:05:45.560]  И это для всех шаблонов верно.
[01:05:45.560 --> 01:05:48.560]  Вот любые шаблонные функции вы можете вместо того, чтобы руками
[01:05:48.560 --> 01:05:51.560]  не смазывать, можно написать авто.
[01:05:51.560 --> 01:05:54.560]  Только тогда придется в форвардах делать декл-тайп от селфи,
[01:05:54.560 --> 01:05:57.560]  это не очень удобно.
[01:05:57.560 --> 01:06:00.560]  Досточек костюм.
[01:06:00.560 --> 01:06:03.560]  Сделать макрос, который будет вот это вот форвард
[01:06:03.560 --> 01:06:06.560]  от декл-тайп.
[01:06:06.560 --> 01:06:09.560]  Вы смеетесь, есть библиотеков, которые так весь код написан,
[01:06:09.560 --> 01:06:12.560]  и люди себя прекрасно чувствуют.
[01:06:12.560 --> 01:06:15.560]  Юнифекс.
[01:06:15.560 --> 01:06:18.560]  Там весь код измазан макросом ФВД,
[01:06:18.560 --> 01:06:21.560]  который делает ровно вот эту операцию.
[01:06:21.560 --> 01:06:24.560]  Ладно, нас ждет парочка катарсисов
[01:06:24.560 --> 01:06:27.560]  на ночь перед сном.
[01:06:27.560 --> 01:06:30.560]  Собственно, вот они.
[01:06:30.560 --> 01:06:33.560]  Это CRTP.
[01:06:33.560 --> 01:06:36.560]  Нет, ну, это есть.
[01:06:36.560 --> 01:06:39.560]  Тимплейт, вот тимплейт.
[01:06:39.560 --> 01:06:42.560]  А я-то спрятал тимплейт.
[01:06:42.560 --> 01:06:45.560]  Бейс-нетиплейт.
[01:06:45.560 --> 01:06:48.560]  Да, это более мощная поддержка
[01:06:48.560 --> 01:06:51.560]  CRTP.
[01:06:59.560 --> 01:07:02.560]  Ты сможешь здесь взять
[01:07:02.560 --> 01:07:05.560]  и написать?
[01:07:05.560 --> 01:07:08.560]  Да, можно.
[01:07:08.560 --> 01:07:11.560]  Наверное, да, но...
[01:07:11.560 --> 01:07:14.560]  Должен смочь.
[01:07:14.560 --> 01:07:17.560]  Тогда это вроде лучше сердечки.
[01:07:17.560 --> 01:07:20.560]  Возможно.
[01:07:20.560 --> 01:07:23.560]  Нет, ничего ты не можешь,
[01:07:23.560 --> 01:07:26.560]  потому что мы здесь наследуемся от бейс-нешаблонного.
[01:07:26.560 --> 01:07:29.560]  Значит, в момент тайп-чека вот этого вот всего,
[01:07:29.560 --> 01:07:32.560]  когда мы собственно концепту будем проверять...
[01:07:32.560 --> 01:07:35.560]  А, нет, это шаблон. Все будет работать.
[01:07:35.560 --> 01:07:38.560]  То есть сюда вместо авто
[01:07:38.560 --> 01:07:41.560]  подставится derived?
[01:07:41.560 --> 01:07:44.560]  Когда ты на derived вызовешь вот этот метод,
[01:07:44.560 --> 01:07:47.560]  подставится derived.
[01:07:47.560 --> 01:07:50.560]  А если ты его вызовешь не на derived, а на базе,
[01:07:50.560 --> 01:07:53.560]  то подставится base.
[01:07:53.560 --> 01:07:56.560]  Ты можешь создать экземпляр base
[01:07:56.560 --> 01:07:59.560]  и вызвать этот метод.
[01:07:59.560 --> 01:08:02.560]  А как оно вызовется, если...
[01:08:02.560 --> 01:08:05.560]  Ну, не скомпилируешь, не бывает.
[01:08:05.560 --> 01:08:08.560]  Ну, дефолтную ты имплементацию сюда какой-то напиши.
[01:08:08.560 --> 01:08:11.560]  А, если она написана, то скомпилируется.
[01:08:11.560 --> 01:08:14.560]  А здесь будет derived.
[01:08:14.560 --> 01:08:17.560]  Но при этом если derived.interface делаю,
[01:08:17.560 --> 01:08:20.560]  то в авто подставится derived.
[01:08:20.560 --> 01:08:23.560]  Да.
[01:08:23.560 --> 01:08:26.560]  Но кажется, это не то, что появилось в появлении
[01:08:26.560 --> 01:08:29.560]  в проекте.
[01:08:29.560 --> 01:08:32.560]  Ты считаешь, шаблоны интерфейс,
[01:08:32.560 --> 01:08:35.560]  в котором используется имплементация,
[01:08:35.560 --> 01:08:38.560]  скормить его.
[01:08:38.560 --> 01:08:41.560]  Нет, еще раз, ты теперь не указываешь
[01:08:41.560 --> 01:08:44.560]  шаблонный...
[01:08:44.560 --> 01:08:47.560]  Это могло быть методом без лист стати.
[01:08:47.560 --> 01:08:50.560]  Да.
[01:08:50.560 --> 01:08:53.560]  Да, это могло быть методом статическим,
[01:08:53.560 --> 01:08:56.560]  поэтому надо просто явно self прокидывать,
[01:08:56.560 --> 01:08:59.560]  но теперь это можно через точку делать.
[01:08:59.560 --> 01:09:02.560]  Это удобнее.
[01:09:02.560 --> 01:09:05.560]  Внезапно пришел на ему кап,
[01:09:05.560 --> 01:09:08.560]  его статические функции,
[01:09:08.560 --> 01:09:11.560]  таких он немного конфликтует.
[01:09:11.560 --> 01:09:14.560]  Короче, вот так можно, это прикольно.
[01:09:14.560 --> 01:09:17.560]  Это альтернативный CRTP новый, модный.
[01:09:17.560 --> 01:09:20.560]  Но в задачах пока так вы не сможете сделать.
[01:09:20.560 --> 01:09:23.560]  Можно это пообьюзить.
[01:09:23.560 --> 01:09:26.560]  Вот это последняя череда слайдов,
[01:09:26.560 --> 01:09:29.560]  три-четыре штуки.
[01:09:29.560 --> 01:09:32.560]  Есть... Да нет, не с визитером.
[01:09:32.560 --> 01:09:35.560]  Визитера пока не будет.
[01:09:35.560 --> 01:09:38.560]  С тд-визит будет. Дерево.
[01:09:38.560 --> 01:09:41.560]  Есть лифы, есть ноды.
[01:09:41.560 --> 01:09:44.560]  Само дерево это вариант,
[01:09:44.560 --> 01:09:47.560]  либо лист, либо нода,
[01:09:47.560 --> 01:09:50.560]  и нода сама из себя представляет
[01:09:50.560 --> 01:09:53.560]  два дерева, право и лево.
[01:09:53.560 --> 01:09:56.560]  Я думаю, вы не видели еще такой способ
[01:09:56.560 --> 01:09:59.560]  создать дерево.
[01:09:59.560 --> 01:10:02.560]  Ну, по крайней мере, когда олимпиадки,
[01:10:02.560 --> 01:10:05.560]  решаешь точно не так.
[01:10:05.560 --> 01:10:08.560]  Это просто стиль написания кода такой пока что.
[01:10:08.560 --> 01:10:11.560]  Ну, это никак...
[01:10:11.560 --> 01:10:14.560]  Ну да, да.
[01:10:14.560 --> 01:10:17.560]  Да, украдено
[01:10:17.560 --> 01:10:20.560]  с блогика Microsoft, если кому интересно.
[01:10:20.560 --> 01:10:23.560]  Перед тем, как перейти
[01:10:23.560 --> 01:10:26.560]  к смаку, вот такое наблюдение.
[01:10:26.560 --> 01:10:29.560]  В стандарте есть функция визит.
[01:10:29.560 --> 01:10:32.560]  Знаете, что она делает? Она пытается на объекте
[01:10:32.560 --> 01:10:35.560]  вызвать оператора круглые скобки
[01:10:35.560 --> 01:10:38.560]  от настоящего типа, который лежит в варианте.
[01:10:38.560 --> 01:10:41.560]  То есть, визиту нужно первым аргументом
[01:10:41.560 --> 01:10:44.560]  создать функциональный объект, у которого есть оператор круглые скобки
[01:10:44.560 --> 01:10:47.560]  для всех различных тэшечек,
[01:10:47.560 --> 01:10:50.560]  которые в варианте перечислены.
[01:10:53.560 --> 01:10:56.560]  Ну да, для всех альтернатив.
[01:10:56.560 --> 01:10:59.560]  Слово альтернатива правильное.
[01:10:59.560 --> 01:11:02.560]  Можно руками написать класс
[01:11:02.560 --> 01:11:05.560]  с этими операторами круглые скобки,
[01:11:05.560 --> 01:11:08.560]  а можно сделать такую забавную фигню под названием overloaded,
[01:11:08.560 --> 01:11:11.560]  это класс. В конструктор мы ему
[01:11:11.560 --> 01:11:14.560]  передаем две лямды.
[01:11:14.560 --> 01:11:17.560]  Нет, с двадцатых плюсов нет.
[01:11:24.560 --> 01:11:27.560]  Две лямды передаем, одна для листа,
[01:11:27.560 --> 01:11:30.560]  другая для ноды. Варианты перебрали.
[01:11:30.560 --> 01:11:33.560]  Лист нода.
[01:11:33.560 --> 01:11:36.560]  Этот overloaded волшебным образом делает объект,
[01:11:36.560 --> 01:11:39.560]  а круглые скобки для той и другой лямды.
[01:11:39.560 --> 01:11:42.560]  Как? Просто наследуется от них всех.
[01:11:46.560 --> 01:11:49.560]  В блоге написали overload,
[01:11:49.560 --> 01:11:52.560]  у нас preference overloaded используется,
[01:11:52.560 --> 01:11:55.560]  но не стыковочка.
[01:11:55.560 --> 01:11:58.560]  Тут должно быть overloaded
[01:11:58.560 --> 01:12:01.560]  и фигурные скобки.
[01:12:01.560 --> 01:12:04.560]  Либо функция,
[01:12:04.560 --> 01:12:07.560]  или костыль.
[01:12:07.560 --> 01:12:10.560]  Вы поняли суть, да? Мы наследуемся от пака лямд,
[01:12:10.560 --> 01:12:13.560]  сколько угодно их может быть.
[01:12:13.560 --> 01:12:16.560]  Используем вот такую конструкцию,
[01:12:16.560 --> 01:12:19.560]  которая с нашей высокой башней понимания того,
[01:12:19.560 --> 01:12:22.560]  как name.lookup работает. Должно быть понятно,
[01:12:22.560 --> 01:12:25.560]  что это такое.
[01:12:25.560 --> 01:12:28.560]  Мы собираем все...
[01:12:28.560 --> 01:12:31.560]  Да, это зависимые родительские классы,
[01:12:31.560 --> 01:12:34.560]  и в дефолту, когда мы делаем name.lookup внутри overloaded,
[01:12:34.560 --> 01:12:37.560]  мы не найдем на первой фазе ничего.
[01:12:37.560 --> 01:12:40.560]  Поэтому нам нужно собрать
[01:12:40.560 --> 01:12:43.560]  все эти родительские операторы круглые скобки
[01:12:43.560 --> 01:12:46.560]  из всех родителей и все их перетащить
[01:12:46.560 --> 01:12:49.560]  в скоб видимости overloaded.
[01:12:49.560 --> 01:12:52.560]  И тогда они все будут считаться
[01:12:52.560 --> 01:12:55.560]  валидным overload сетом.
[01:12:55.560 --> 01:12:58.560]  Они все друг друга перегружают.
[01:12:58.560 --> 01:13:01.560]  Пойдем
[01:13:01.560 --> 01:13:04.560]  выбирать одну из них.
[01:13:04.560 --> 01:13:07.560]  А вот они.
[01:13:07.560 --> 01:13:10.560]  Стд принт никого не напряг? Нет.
[01:13:10.560 --> 01:13:13.560]  Нет? Хорошо. В 23-х плюсах есть стд принт.
[01:13:13.560 --> 01:13:16.560]  Ура, наконец.
[01:13:16.560 --> 01:13:19.560]  Тридцать лет развития.
[01:13:19.560 --> 01:13:22.560]  Съели петалиста, да?
[01:13:22.560 --> 01:13:25.560]  Мы букву f убрали.
[01:13:25.560 --> 01:13:28.560]  Стд принт f-то и раньше был, букву f убрали.
[01:13:31.560 --> 01:13:34.560]  К чему это все было?
[01:13:34.560 --> 01:13:37.560]  А вот к чему это было.
[01:13:37.560 --> 01:13:40.560]  Это функция,
[01:13:40.560 --> 01:13:43.560]  считающее количество листьев.
[01:13:46.560 --> 01:13:49.560]  Мы визитируем
[01:13:49.560 --> 01:13:52.560]  одно из двух
[01:13:52.560 --> 01:13:55.560]  и захватываем
[01:13:55.560 --> 01:13:58.560]  шаблонные ссылки self.
[01:13:58.560 --> 01:14:01.560]  Понимаете, какой тип выведется вот здесь?
[01:14:01.560 --> 01:14:04.560]  Нет. Внутренний. Какой?
[01:14:04.560 --> 01:14:07.560]  Почему?
[01:14:07.560 --> 01:14:10.560]  Выведется overloaded.
[01:14:10.560 --> 01:14:13.560]  Понимаете, что происходит?
[01:14:14.560 --> 01:14:17.560]  Это прикольно. Что?
[01:14:17.560 --> 01:14:20.560]  Потому что у нас overloaded
[01:14:20.560 --> 01:14:23.560]  наследуется от лямбды.
[01:14:23.560 --> 01:14:26.560]  Поэтому мы берем самый последний наследник.
[01:14:26.560 --> 01:14:29.560]  Overloaded наследуется от вот этих двух лямбд.
[01:14:29.560 --> 01:14:32.560]  И к себе перетаскивает их операторы круглые скобки.
[01:14:32.560 --> 01:14:35.560]  Поэтому, когда визит вызовет один из этих операторов круглые скобки,
[01:14:35.560 --> 01:14:38.560]  но вот этот второй,
[01:14:38.560 --> 01:14:41.560]  объект, на котором он его будет вызывать, это overloaded.
[01:14:41.560 --> 01:14:44.560]  И, соответственно, здесь внутри
[01:14:44.560 --> 01:14:47.560]  мы спокойно можем взять и рекурсивно запуститься.
[01:14:47.560 --> 01:14:50.560]  Потому что self это overloaded,
[01:14:50.560 --> 01:14:53.560]  и в нем все еще есть две функции.
[01:14:53.560 --> 01:14:56.560]  Одна для листа, другая для ноды.
[01:14:56.560 --> 01:14:59.560]  Убойно.
[01:14:59.560 --> 01:15:02.560]  То есть это прекрасно, кажется.
[01:15:02.560 --> 01:15:05.560]  А как выведется self?
[01:15:05.560 --> 01:15:08.560]  Как self выведется?
[01:15:08.560 --> 01:15:11.560]  Вот внутри std-vizit есть код,
[01:15:11.560 --> 01:15:14.560]  который на объекте вот этом overloaded,
[01:15:14.560 --> 01:15:17.560]  который мы передали ему, на этом объекте
[01:15:17.560 --> 01:15:20.560]  вызовет оператор круглые скобки.
[01:15:20.560 --> 01:15:23.560]  Ну там какая-то переменная есть, где хранится вот этот overloaded.
[01:15:23.560 --> 01:15:26.560]  Давай O ее назовем.
[01:15:26.560 --> 01:15:29.560]  И делается O круглые скобки от чего-то.
[01:15:29.560 --> 01:15:32.560]  Это какой-то альтернатива.
[01:15:32.560 --> 01:15:35.560]  O в этот момент какой тип имеет?
[01:15:36.560 --> 01:15:39.560]  Это лямбда передается
[01:15:39.560 --> 01:15:42.560]  аргументом overloaded.
[01:15:42.560 --> 01:15:45.560]  А overloaded наследуется от типов этих лямбд,
[01:15:45.560 --> 01:15:48.560]  и мы конструируем такой объект overloaded,
[01:15:48.560 --> 01:15:51.560]  в котором подряд лежат эти лямбды.
[01:15:51.560 --> 01:15:54.560]  И все операторы круглые скобки этих лямбд,
[01:15:54.560 --> 01:15:57.560]  они втащены в этот дочерний класс.
[01:15:57.560 --> 01:16:00.560]  Вот, наследуется от всех лямбд.
[01:16:00.560 --> 01:16:03.560]  Вот этот синтаксис смешной
[01:16:03.560 --> 01:16:06.560]  инициализирует первого родителя первой лямбдой
[01:16:06.560 --> 01:16:09.560]  и второго родителя второй лямбдой.
[01:16:09.560 --> 01:16:12.560]  А вот этот смешной синтаксис
[01:16:12.560 --> 01:16:15.560]  собирает операторы круглые скобки в класс overloaded.
[01:16:15.560 --> 01:16:18.560]  То есть у него теперь есть два оператора круглые скобки,
[01:16:18.560 --> 01:16:21.560]  пришедшие из родителей.
[01:16:21.560 --> 01:16:24.560]  Причем второй оператор круглые скобки это не функция.
[01:16:24.560 --> 01:16:27.560]  На вот этой картинке
[01:16:27.560 --> 01:16:30.560]  первый оператор круглые скобки это функция,
[01:16:30.560 --> 01:16:33.560]  а второй не функция,
[01:16:33.560 --> 01:16:36.560]  это шаблон функции.
[01:16:36.560 --> 01:16:39.560]  Тут авто.
[01:16:39.560 --> 01:16:42.560]  То есть вот в этой области видимости overloaded есть две сущности.
[01:16:42.560 --> 01:16:45.560]  Одна функция, один шаблон функции.
[01:16:45.560 --> 01:16:48.560]  Дальше вот этот вот вызов происходит о круглой скобке.
[01:16:48.560 --> 01:16:51.560]  Где-то внутри visit глубоко есть вызов на вот этом объекте
[01:16:51.560 --> 01:16:54.560]  оператора круглой скобки.
[01:16:54.560 --> 01:16:57.560]  Врубается overload resolution,
[01:16:57.560 --> 01:17:00.560]  сразу видит.
[01:17:00.560 --> 01:17:03.560]  Так вот у нас в этой области видимости есть одна функция
[01:17:03.560 --> 01:17:06.560]  оператора круглой скобки, один шаблон оператора круглой скобки.
[01:17:06.560 --> 01:17:09.560]  Их и возьмем.
[01:17:09.560 --> 01:17:12.560]  Дальше происходит инстанциация второй сущности.
[01:17:12.560 --> 01:17:15.560]  Шаблон надо инстанцировать, чтобы все было функциями.
[01:17:15.560 --> 01:17:18.560]  Вот этот шаблонный аргумент надо вывести.
[01:17:18.560 --> 01:17:21.560]  Мы смотрим, как вызов выглядел о круглой скобке.
[01:17:21.560 --> 01:17:24.560]  Какой тип о?
[01:17:24.560 --> 01:17:27.560]  Overloaded.
[01:17:27.560 --> 01:17:30.560]  У него тип должен быть вот ровно такой overloaded.
[01:17:30.560 --> 01:17:33.560]  Теперь имеем две функции уже.
[01:17:33.560 --> 01:17:36.560]  Одна из которых принимает вот это вот.
[01:17:36.560 --> 01:17:39.560]  Другая из которых вот это, но вместо авто здесь
[01:17:39.560 --> 01:17:42.560]  подставлен overloaded от все еще этих же двух лямп.
[01:17:42.560 --> 01:17:45.560]  И ссылка указывает
[01:17:45.560 --> 01:17:48.560]  на сам этот объект overloaded,
[01:17:48.560 --> 01:17:51.560]  с которого все началось.
[01:17:52.560 --> 01:17:55.560]  Используем себя дальше
[01:17:55.560 --> 01:17:58.560]  в следующих двух визитах, чтобы процедура повторилась.
[01:18:14.560 --> 01:18:17.560]  Да, это шаблон.
[01:18:17.560 --> 01:18:20.560]  Это лямпда, которая порождает некоторый класс,
[01:18:20.560 --> 01:18:23.560]  а оператор круглой скобки шаблонный,
[01:18:23.560 --> 01:18:26.560]  а сам класс не шаблонный.
[01:18:26.560 --> 01:18:29.560]  Да.
[01:18:29.560 --> 01:18:32.560]  Лямда это объект.
[01:18:32.560 --> 01:18:35.560]  С типом, который там рандомный.
[01:18:35.560 --> 01:18:38.560]  На каждую лямду генерируется свой новый тип.
[01:18:38.560 --> 01:18:41.560]  Тип этот обычный, просто класс.
[01:18:41.560 --> 01:18:44.560]  Зато в нем есть метод шаблонный.
[01:18:44.560 --> 01:18:47.560]  Шаблонный оператор круглой скобки.
[01:18:47.560 --> 01:18:50.560]  На этом у меня наконец-то все.
[01:18:50.560 --> 01:18:53.560]  Мы с вами очень много сегодня говорили.
[01:18:53.560 --> 01:18:56.560]  Опять начали на 15 минут позже
[01:18:56.560 --> 01:18:59.560]  и закончили на 15 минут позже.
[01:18:59.560 --> 01:19:02.560]  Наверное, это стоит политикой партии официально сделать,
[01:19:02.560 --> 01:19:05.560]  чтобы мы просто в 5-15 собирались.
[01:19:05.560 --> 01:19:08.560]  Да?
[01:19:08.560 --> 01:19:11.560]  Блин, ну ладно.
[01:19:11.560 --> 01:19:14.560]  В общем, всем спасибо, все свободны.
[01:19:17.560 --> 01:19:20.560]  До свидания.
