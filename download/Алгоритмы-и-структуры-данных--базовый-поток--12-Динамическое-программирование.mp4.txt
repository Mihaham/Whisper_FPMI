[00:00.000 --> 00:10.760]  Смотрите, мы с вами по факту закончили все, что касается деревьев в этом семестре. У нас еще
[00:10.760 --> 00:19.440]  появится фибоначевая куча. Мы посмотрим, что это такое, но это такое теоретическое знание больше.
[00:19.440 --> 00:25.080]  Сейчас мы переходим к такому достаточно большому блоку, связанному с динамическим
[00:25.080 --> 00:30.840]  программированием. Те, кто занимался олимпиадами когда-нибудь и что-то встречал из них, подозреваю,
[00:30.840 --> 00:38.960]  знают, что такое динамическое программирование. Правда? А есть кто встречался? Расскажите. Вот.
[00:38.960 --> 00:48.520]  Понимаю. И у нас будет три лекции, посвященные динамическому программированию. На первый
[00:48.520 --> 00:55.040]  сегодняшний. Мы с вами так обобщенно посмотрим, что это такое, какие у нас там есть принципы,
[00:55.040 --> 01:01.520]  что нам необходимо для динамики. А на второй и третий разберем конкретные задачи, потому что у них
[01:01.520 --> 01:07.440]  очень много различных применений. Если очень интересно, то следующая лекция будет про НУП,
[01:07.440 --> 01:16.160]  НВП через одну задачу о рюкзаке. Может быть кому-то что-то это скажет, кому-то может ничего не
[01:16.160 --> 01:25.000]  скажет. Но в действительности, как бы, это задачи такие на грани с олимпиадами очень часто,
[01:25.000 --> 01:29.440]  поэтому вы можете сказать, что они сложные и не тривиальные не с точки зрения кода скорее,
[01:29.440 --> 01:35.720]  а с точки зрения идеи, потому что самое главное в динамике это идея. Если вы придумали, то вы
[01:35.720 --> 01:43.640]  решили задачу. Если вы не придумали, то вы, к сожалению, проиграли. Вот. И другого исхода скорее здесь нет.
[01:43.640 --> 01:53.320]  Не совсем. А если мы с вами знаем какой-нибудь овел дерева и работаем с бинарным деревом поиска,
[01:53.320 --> 01:59.040]  то там достаточно очевидно и понятно, что нам нужно сделать, грубо говоря. Если задача конкретно
[01:59.040 --> 02:06.240]  на дерево, вы знаете это. Если у вас задача на динамику, то тут начинается слишком много но и
[02:06.240 --> 02:12.400]  слишком много вопросов. Вот. Мы разберем с этим всем. Но начать сегодняшнюю лекцию я хотел бы с
[02:12.400 --> 02:18.840]  такой вот фразой, что динамическое программирование это по сути, когда у вас есть задача, которая непонятно
[02:18.840 --> 02:25.400]  как решать, вы разбиваете ее на более мелкие подзадачи, которые тоже непонятно как решать. Именно
[02:25.400 --> 02:32.160]  в этом вся суть динамики на самом деле. Именно в этом, может быть, вам покажется, что это такая
[02:32.160 --> 02:38.560]  странная фраза, но в действительности в ней заключен весь смысл того, что происходит в динамическом
[02:38.560 --> 02:45.360]  программировании. И мы будем по факту смотреть сегодня на три такие какие-то обобщенные задачки,
[02:45.360 --> 02:53.320]  четыре, в которых есть какой-то интерес, какой-то какой-то вопрос, который нам нужно будет
[02:53.320 --> 02:58.680]  ответить. Но для начала, чуть более формально, что такое динамическое программирование? Вообще
[02:58.680 --> 03:05.080]  динамическое программирование это способ решения каких-то сложных задачек, когда мы пытаемся их
[03:05.080 --> 03:13.040]  разбивать на более простые подзадачи. И вот собираем то самое итоговое, а нужное нам решение
[03:13.040 --> 03:20.800]  благодаря результатам из предыдущих. Вот критериям применимости динамического программирования мы
[03:20.800 --> 03:28.040]  не везде его можем применить. Это важный момент. Но его критериями являются таких два пункта,
[03:28.040 --> 03:34.240]  про которые вам всегда нужно помнить. Первый пункт — это наличие оптимальной подструктуры,
[03:34.240 --> 03:42.480]  и без них никак. И второй пункт — это перекрывающиеся подзадачи. Это похожие друг на друга пункты.
[03:42.480 --> 03:48.880]  Единственное, что вам нужно понять, что оптимальная подструктура, то есть есть какая-то, грубо говоря,
[03:48.880 --> 03:54.520]  формула, по которой вы из предыдущих результатов что-то получаете. А есть другой вариант
[03:54.520 --> 04:00.520]  перекрывающейся подзадачи, когда вы можете действительно взять задачу и разбить ее на какие-то
[04:00.600 --> 04:06.720]  внутренние подзадачки. Кто представляет, что является аналогом в математике динамического
[04:06.720 --> 04:17.280]  программирования? Ну, почти. Индукция. На самом деле индукция. Вот все, что нужно в динамике — это
[04:17.280 --> 04:23.280]  какое-то начальное значение, а дальше у нас есть предположение, что мы будем делать вот таким-то
[04:23.280 --> 04:28.920]  образом и благодаря этому что-то получим. Именно от этого отталкиваясь, мы с вами и получаем что-то.
[04:28.920 --> 04:35.480]  То есть, когда вы... Все же знакомы с методом математической индукции. Надеюсь,
[04:35.480 --> 04:42.520]  все в школе выучили, это хорошо. А на матологике она звучит немного по-другому, но, типа,
[04:42.520 --> 04:47.840]  суть остается та же. У вас есть какая-то база индукции и у вас есть переход индукции.
[04:47.840 --> 04:54.120]  Вы предполагаете, что это верно для какого-то числа, значит, докажем, что верно для числа
[04:54.120 --> 05:02.000]  больше на единичку, например. Вот. И с этим мы будем с вами сегодня работать. Если говорить
[05:02.000 --> 05:09.840]  с практической точки зрения, что вам нужно в динамике для того, чтобы что-то решить. По-хорошему,
[05:09.840 --> 05:16.320]  при решении каждой задачи динамики вам нужно выделить вот эти пять пунктов, которые перечислены
[05:16.320 --> 05:23.520]  здесь и их определить. А некоторые из них достаточно просты, некоторые нет. Первый вопрос
[05:23.520 --> 05:29.920]  состояния динамики. Состояние динамики подразумевается в следующее. Что хранится в данный момент в той или
[05:29.920 --> 05:37.040]  иной ячейке? Чаще всего вы будете работать с массивами, одномерными, двумерными, но иногда вы
[05:37.040 --> 05:43.320]  работаете с конкретным одним числом. Вам нужно понять, что в нем хранится и что, на каком шаге,
[05:43.320 --> 05:51.720]  там будет находиться. В зависимости от этого состояния динамики вы и будете отталкиваться,
[05:51.720 --> 05:57.120]  потому что вы легко руками можете посчитать для каких-то начальных условий. Вот у вас есть
[05:57.120 --> 06:04.640]  состояние динамики, которая показывает какой-то ответ на момент, там не знаю, этой вашего цикла.
[06:04.640 --> 06:13.200]  И вот если вы знаете на момент к этому циклу все до него, попробуйте тогда узнать, что будет на
[06:13.200 --> 06:18.440]  и плюс первым. Это первый пример. Начание начальных состояний, это чаще всего самый простой пункт,
[06:18.440 --> 06:28.200]  потому что его действительно очень легко посчитать руками, почти всегда. Бывает исключение, конечно,
[06:28.200 --> 06:37.560]  но чаще всего очень легко посчитать руками. Дальше идет переход между состояниями. По факту это та
[06:37.560 --> 06:45.560]  самая идея, которая лежит в той или иной задаче на динамику. Вот без этой формулы пересчета вы не
[06:45.560 --> 06:50.880]  получите ровным счетом ничего. У вас будут некоторые проблемы с тем, чтобы понять,
[06:50.880 --> 06:59.560]  а что там происходит. Понятно? Вот надеюсь, что в задачах на динамику вы сможете взять и придумать
[06:59.560 --> 07:05.840]  везде как, что и почему и откуда, что происходит. В этом случае вы решите абсолютно все задачки.
[07:05.840 --> 07:12.000]  И на итоговом контесте, скорее всего, у вас тоже будут задачки на динамику. Это важно понимать,
[07:12.000 --> 07:18.160]  важно всегда думать. И в этот момент можно сказать, что программистам все-таки нужно
[07:18.160 --> 07:25.120]  знать математику, потому что сегодня будет такая задача, которая очень близка математикам,
[07:25.120 --> 07:31.680]  но очень не близка программистам. И без какого-то такого, знаете, интересного факта, поднятого из
[07:31.680 --> 07:37.200]  ниоткуда, вы не сможете решить задачу. Но это как пример будет показан вам для того,
[07:37.200 --> 07:42.960]  чтобы вы поняли, в чем основная суть здесь. Дальше идет порядок пересчета. Порядок пересчета мы
[07:42.960 --> 07:49.120]  сейчас остановимся на них поподробнее. Их бывает всего три. И важно вам тоже понимать,
[07:49.120 --> 07:54.320]  в каком порядке вы хотите считать значение. Я объясню, что это будет значить на каждом из
[07:54.320 --> 07:59.480]  примеров. Каждую задачу можно свести к любому порядку пересчета. И дальше самый важный момент
[07:59.800 --> 08:07.440]  положение ответа. Не всегда ответ лежит в конкретной ячейке. Не всегда ответ является вот просто одним
[08:07.440 --> 08:12.440]  числом, которое вы зафиксировали. Нет, это может быть сумма, это может быть произведение, это может
[08:12.440 --> 08:19.960]  быть максимум, это может быть все что угодно. И это тоже важно понимать и осознавать здесь. Мы еще
[08:19.960 --> 08:25.080]  не раз встретимся на самом деле задачами на динамику. Вы можете их скрыто не увидеть, не понять,
[08:25.080 --> 08:30.480]  что это именно они, но в действительности это будут они самые. Чаще всего какая-то
[08:30.480 --> 08:36.080]  простая идея, которая лежит в решении задачек, она помогает нам понять, что типа как красиво
[08:36.080 --> 08:41.640]  решается задача. Но в этот момент вы не представляете, сколько мучений стоит за тем,
[08:41.640 --> 08:47.640]  сколько раз перепридумывали решение той или иной задачки для того, чтобы красиво ее решить.
[08:47.640 --> 08:56.040]  Это важный момент. Теперь поговорим про порядок пересчета. Как с этим жить? Встает три порядка
[08:56.040 --> 09:04.240]  пересчета. Прямой, обратный и ленивая динамика. Прямой порядок это когда вы на основе предыдущих
[09:04.240 --> 09:11.640]  результатов получаете текущий. Обратный порядок это когда вы находитесь в каком-то состоянии и
[09:11.640 --> 09:16.240]  знаете, что оно влияет там не знаю на и плюс второе, на и плюс пятое и на и плюс седьмое и
[09:16.240 --> 09:22.560]  прибавляете или там убавляете или умножаете или что-то делаете это к результату вот тому,
[09:22.560 --> 09:28.600]  который есть там дальше. Вот есть ленивая динамика, ленивая динамика по сути типа вы
[09:28.600 --> 09:36.280]  делаете ту же самую рекурсию, потому что вы знаете рекурренту, которая у вас есть зависимости,
[09:36.280 --> 09:45.080]  делаете эту рекурсию, но с одной большой оговоркой вы не будете позволять разрастаться дереву
[09:45.080 --> 09:50.920]  рекурсии и если вдруг какой-то результат у вас уже посчитан, то вы его сохраняете куда-нибудь. То
[09:50.920 --> 10:01.920]  есть вам нужно создать вот эти вот кыши для каждой из задачек. Понятно? Пока все легко или нелегко?
[10:01.920 --> 10:14.640]  Нормально? Хорошо. Либо вы все очень уставшие, понимая конец семестра. Но ничего, самая
[10:14.640 --> 10:22.240]  жесть будет в самой последней лекции, обещаю, хотя что-то типа с плыдерева вот такой же характер
[10:22.240 --> 10:28.000]  будет, только обобщенный теоретически. Про прямой порядок, то есть смотрите вот тут вот
[10:28.000 --> 10:37.400]  вы можете увидеть там, например, желтенький вопросик и зелененький, а стоят восхитительные
[10:37.400 --> 10:41.280]  знаки. Восхитительные знаки известные нам результаты, вопросик это то, что нужно найти.
[10:41.280 --> 10:46.000]  И вот прямой порядок пересчета на примере чисел Фибоначчи. На примере чисел Фибоначчи мы
[10:46.000 --> 10:52.840]  разберем все эти три порядка и поймем типа просто, не просто, как, что происходит. Вот. Как бы вы
[10:52.840 --> 10:58.480]  задаете в самом начале те самые начальные значения. Я теперь возвращаюсь к тому псевдокоду,
[10:58.480 --> 11:05.120]  который писал всегда ранее. Вот. Потому что здесь уже код достаточно простой. А дальше я циклом
[11:05.120 --> 11:10.800]  просто буду проходиться и использовать предыдущие результаты для того, чтобы получить результат в
[11:10.800 --> 11:23.720]  иный момент. Просто понятно. Я думаю, вы с этим сталкивались. Это не сложно. Окей, ладно.
[11:23.720 --> 11:30.240]  Что касается обратного порядка. Вот в обратном порядке здесь, смотрите, уже немного по-другому.
[11:30.240 --> 11:37.320]  Я говорю о том, что у меня есть одно начальное значение и больше мне особо-то и не надо. Почему
[11:37.320 --> 11:43.400]  это так? Потому что есть еще нулевой, на самом деле, который тоже ноль, оно там сверху указано. Вот.
[11:43.400 --> 11:51.080]  А дальше вы, когда находитесь на итом шаге, здесь единственное, что... А, да, все верно. Вы,
[11:51.080 --> 11:59.280]  когда находитесь на итом шаге, смотрите, вы знаете, что итое число Фибоначчи участвует в результате
[11:59.280 --> 12:09.600]  и плюс первого и и плюс второго числа. Согласны? Поэтому вы это итое число Фибоначчи прибавляете
[12:09.600 --> 12:15.600]  и плюс первому и и плюс второму результату. Вы не знаете, что там конкретно лежит, но вы знаете,
[12:15.600 --> 12:20.520]  что туда нужно прибавить. То есть вот обратный порядок, это когда я вот знаю этот результат и я
[12:20.520 --> 12:27.960]  знаю, как он влияет на другие и использую его. Так можно делать. Окей? Вопросы?
[12:27.960 --> 12:36.280]  Получившееся значение используем в зависящих результатах?
[12:36.280 --> 12:50.040]  Еще раз. А, Фибоначчи от 0 до n плюс 1, это массив от 0 до n плюс 1 и все заполнены нулями. Так
[12:50.040 --> 12:58.600]  понятнее? Отлично. Вот. Окей. И последнее. Эта ленивая динамика, в действительности,
[12:58.600 --> 13:02.680]  ленивая динамика выглядит примерно так. Вот если посмотрим какой-нибудь стек рекурсии,
[13:02.680 --> 13:09.840]  оно будет похоже, когда подальше поучитесь в алгоритмах. Я надеюсь, что многие из вас дойдут
[13:09.840 --> 13:18.000]  до второго семестра. Вот. В этом случае, грубо говоря, у вас там будет DFS. Вот оно что-то
[13:18.000 --> 13:25.400]  похоже всегда на самом деле в рекурсии происходит. А здесь вы просто пишете ту самую рекурсивную
[13:25.400 --> 13:31.680]  функцию. У вас есть условия остановки рекурсии. Это как раз те самые начальные значения. И вы
[13:31.680 --> 13:39.720]  сохраняете все в какой-то массив. Массив данных. Вот тут у меня числа Фибоначчи сохраняются. И вы
[13:39.720 --> 13:45.480]  смотрите, что если это число Фибоначчи не было найдено, то я запускаю рекурсию. А если было,
[13:45.480 --> 13:53.600]  то рекурсию я не запускаю, а просто возвращаю сразу результат. Понятно? Помните, в чем проблема
[13:53.600 --> 14:07.240]  рекурсивного поиска числа Фибоначчи? В чем? Так, да. Хорошо. Да. Забивается именно память,
[14:07.240 --> 14:13.560]  стек рекурсии очень сильно растет. Там получается константов степени N. Это константа больше единички,
[14:13.560 --> 14:19.680]  это, к сожалению, очень быстро растет. Если быть точнее, там, по-моему, снизу ограничено полтора
[14:19.680 --> 14:25.800]  степени N. Вот. Поэтому здесь очень важно всегда это оценивать и понимать, как с этим работать.
[14:25.800 --> 14:33.600]  Вот. Это то, что касается порядков пересчета. Все просто. Все просто. Смотрите, как у нас сейчас
[14:33.600 --> 14:38.360]  будет построена лекция. Может быть, она частично будет похожа на семинар. Но, в принципе, все,
[14:38.360 --> 14:45.200]  что связано с динамическим программированием, это по факту нарешивание задач. Я вам покажу общие
[14:45.200 --> 14:51.320]  плюс-минус механизмы того, как рассуждать лучше при решении задач на конкретных задачах. Но это
[14:51.320 --> 14:56.640]  не будет означать, что я покрою абсолютно все, и вы скажете, что я бог динамического программирования.
[14:56.640 --> 15:03.360]  Вот. А, к сожалению, никто так сказать не может, потому что это очень нетривиальная вещь. И всегда
[15:03.360 --> 15:11.320]  нужно думать о том, как и что там сделать. Первая задача, она самая понятная всегда. Это лесенка.
[15:11.320 --> 15:20.000]  Представьте, что вы можете подниматься на одну или две ступеньки. Сколько у вас возможных путей до
[15:20.000 --> 15:32.640]  этой ступеньки? Правильно. По факту, по факту здесь это все те же числа Фибоначчи. Но мы сейчас
[15:32.640 --> 15:37.960]  рассмотрим эту задачу ровно потому, что я вам рассказывал. Определим тебе пять пунктов для того,
[15:37.960 --> 15:43.400]  чтобы нам было понятнее, что с этим делать. Идея здесь достаточно простая. Как я могу попасть на
[15:43.400 --> 15:52.920]  Н ту ступеньку, на Иту? Либо с И-1, либо с И-2. И вот сумма вариантов, сколько я попал на ту
[15:52.920 --> 15:59.280]  или иную ступеньку, будет результатом того, сколько я попал как раз таки на Иту ступеньку. Это идея
[15:59.280 --> 16:05.640]  решения этой задачи. А дальше от этой идеи мы отталкиваемся и получаем следующее. Что у нас
[16:05.640 --> 16:18.360]  будет состоянием динамики? Что будет храниться в ДП ИТ? Нет, количество способов добраться до И
[16:18.360 --> 16:25.720]  этой ступеньки. В ДП ИТ хранится количество способов добраться до этой ступеньки, потому что
[16:25.720 --> 16:38.240]  от этого мы будем отталкиваться. Какое значение начальных состояний? Вот видите, столько
[16:38.240 --> 16:44.520]  предположений сразу в такой момент. Я буду считать, что на нулевой ступеньке я могу быть одним
[16:44.520 --> 16:50.160]  способом, но я там просто стою. И на первой ступеньке я тоже могу оказаться одним способом. Дальше я буду
[16:50.160 --> 16:57.400]  пересчитывать. Понятно? Можно сказать, что на первую ступеньку я одним способом могу попасть на вторую
[16:57.400 --> 17:02.760]  двумя и дальше пересчитывать после них. Нет никакой проблем, вы можете делать именно таким образом.
[17:02.760 --> 17:11.320]  Какая у нас формула пересчета здесь будет? С самых двух предыдущих, все верно. А порядок пересчета
[17:11.320 --> 17:18.280]  какой вам больше всего нравится? Прямой. Понимаю, я тоже люблю больше всего прямой. А и где будет
[17:18.280 --> 17:29.080]  храниться результат? На этом месте, нам нужно на эту ступеньку. То есть ступя достаточно просто и
[17:29.080 --> 17:34.640]  очевидно в этой задачке. Ну и решение этой задачи, аналогичное числом Фибоначчи, как бы все понятно.
[17:34.640 --> 17:41.680]  Вот оно вот ровно такое же. Ничего здесь не изменилось. Мы с вами получили это решение. Но
[17:41.680 --> 17:46.800]  дальше начнутся более нетривиальные задачи. Я специально подавал их разного типа для того,
[17:46.800 --> 17:57.320]  чтобы вы не расслаблялись. Подсчет бита. Смотрите, здесь задача немного другого характера. Вам
[17:57.320 --> 18:09.680]  необходимо рассмотреть N чиселок от 0 до N, включая, и вернуть массив, где каждый элемент массива это
[18:09.680 --> 18:23.400]  количество единиц в двоичном представлении числа И. Кто понял условия? А все остальные? Давайте с
[18:23.400 --> 18:33.200]  вами поймем, что это означает. Например, у меня есть число 5. Мне нужно для нуля 1, 2, 3, 4 и 5 вернуть
[18:33.200 --> 18:39.560]  количество единиц в двоичной запись числа. В нуле это 0, в единичке это 1, в двойке это 1, в тройке
[18:39.560 --> 18:57.800]  четверке 1, в пятерке 2. Я такой массив должен вернуть. Что делать? Каждый раз переводить каждое
[18:57.800 --> 19:06.360]  число в двоичную запись, это смерть. Чтобы перевести число в двоичную запись, нужно там
[19:06.360 --> 19:09.560]  алгоритм действия. То есть у нас получится N log N.
[19:09.560 --> 19:39.320]  Так. А как посчитать? Вот представьте, я нахожусь в этом месте. Да? Я знаю результаты,
[19:39.320 --> 20:04.400]  от нуля там да и минус 1. Как посчитать в этом? Да. Что такое N по модулю 2? Ну давай еще раз,
[20:04.400 --> 20:32.560]  типа то есть dpi t равно плюс и процент 2. Смотрите, да, это правда. Суть именно в этом. Кто понимает,
[20:32.560 --> 20:41.320]  почему? А кто вообще не обращает внимания сейчас, что здесь происходит и просто не хочет понимать?
[20:41.320 --> 20:50.080]  Отлично. Давайте тогда разберемся с этой формулой, почему она работает. Смотрите,
[20:50.080 --> 20:57.600]  если я запишу число в двоичной записи и вот просто не буду смотреть на последний бит,
[20:57.600 --> 21:09.800]  к примеру, то что это позволит мне? Вот это число, оно во сколько раз меньше? В два. Причем ну тут
[21:09.800 --> 21:15.680]  минус один и делить на два. Но когда я делю целочисленное, как бы вот это не считается.
[21:15.680 --> 21:22.520]  Вот эта половинка мне не нужна. Вот. А вот это число, оно явно меньше, чем и. А если оно явно
[21:22.520 --> 21:30.080]  меньше, чем и, то оно уже подсчитано само по себе. Осталось понять, у меня в конце стоит единичка или
[21:30.080 --> 21:37.120]  нолик. Нужно мне прибавить ту самую плюс единичку или нет? И в зависимости от этого я как бы могу это
[21:37.120 --> 21:45.720]  рассматривать. То есть вот это показывает, что у нас стоит в конце нолик или единица. То есть нужно
[21:45.720 --> 21:52.000]  увеличить или не нужно увеличить. А вот это показывает, сколько единиц стоит кроме последнего бита.
[21:52.000 --> 22:03.480]  Но это не самая красивая формулка здесь. Я имею в виду, с точки зрения смысла, это корректно. С точки
[22:03.480 --> 22:07.640]  зрения плюсов, можно подумать побыстрее. Мы все-таки работаем с битами.
[22:07.640 --> 22:28.000]  Побитовые сдвиги. Можно сдвинуть здесь на единицу вправо. Вы просто убиваете вот этот последний бит.
[22:28.000 --> 22:41.600]  Это первое. Второе. Вот это, это то же самое, что и и единица. Почему это лучше?
[22:41.600 --> 23:00.360]  То же самое. Почему это лучше? Быстрее. Вот это и, амперсант. Одиночное и, это не логическое уже и, а
[23:00.360 --> 23:09.840]  побитовое и. Ну и как бы типа последний бит единичка или нет. Он выдаст либо 0, либо 1. Все битовые
[23:09.840 --> 23:18.040]  операции всегда быстрее. Здесь я уже немного ухожу в то, что типа мы все-таки работаем с вами по
[23:18.040 --> 23:24.080]  программированию, не по математике, поэтому нужно все-таки возвращаться в реальный мир тоже. И это
[23:24.080 --> 23:29.440]  будет работать чуть быстрее, поэтому это лучше. Если с вами говорить о том, как это выглядит,
[23:29.440 --> 23:37.640]  ну здесь все достаточно просто. ДПИ это количество единиц в итом, уитого числа в двоечной запися.
[23:37.640 --> 23:45.160]  Начальное значение, что у нуля это 0, а формула пересчета достаточно простая, что мы просто
[23:45.160 --> 23:53.600]  смотрим на сдвиг, плюс добавляем вот эту последнюю единицу, если она есть, либо 0, если это 0. Вот прямой
[23:53.600 --> 24:00.560]  порядок пересчета. Ну и положение ответа, это просто весь массив по факту. Здесь не максимум, ничего, а сам
[24:00.560 --> 24:08.800]  массив. Нас так просят задачи. И мы можем с вами это получить. Ну и все решение это вот. Ну на плюсах
[24:08.800 --> 24:16.360]  чуть-чуть побольше может выглядеть. Массив все-таки вывести надо. Но опять же, здесь все решение этой
[24:16.360 --> 24:24.120]  задачи, к примеру, сводится не к тому, что вам нужно взять и написать какой-то огромный код,
[24:24.120 --> 24:33.400]  а вам нужно подумать. Как только вы подумали, это становится очень просто. Поехали дальше. Еще
[24:33.400 --> 24:40.720]  какую-нибудь простенькую задачку посмотрим. Двумерная динамика. С двумерной динамика как-то
[24:40.720 --> 24:47.640]  задачку только не называют. Это и задачка с черепашкой, еще с чем-нибудь. Но по факту звучит
[24:47.640 --> 25:00.000]  следующим образом. У нас с вами есть какое-то поле. Вот просто поле N на M. И вам нужно построить
[25:00.000 --> 25:10.840]  какой-то такой путь из левой верхней ячейки в правую нижнюю. Таким образом, чтобы максимизировать
[25:10.840 --> 25:19.800]  стуму по этому пути. Потому что в каждой ячейке лежит, не знаю, монетки, деньги, ну как хотите
[25:19.800 --> 25:26.640]  назовите. Вот, конечно, любому человеку хочется разбогатеть. И в этом случае нужно увеличить
[25:26.640 --> 25:34.080]  количество монет. Тогда в этом случае мы как бы идем по этому пути. Ну здесь какие-то числа там,
[25:34.080 --> 25:49.080]  не знаю. Ну и так далее. Не суть важна. Мы можем ходить только вниз и вправо. Благодаря этому условию,
[25:49.080 --> 25:54.480]  что мы можем ходить только вниз и вправо, мы действительно можем гарантировать, что у нас есть
[25:54.480 --> 26:00.160]  перекрывающиеся подзадачи, оптимальные подзадачи. Мы можем действительно использовать предыдущие
[26:00.160 --> 26:06.880]  результаты. Потому что, если мы находимся в какой-то точке здесь, то мы не можем попасть вот
[26:06.880 --> 26:13.920]  во всю вот эту выделяемую мной область, к примеру. Понятно? Потому что мы не можем ни вверх, ни влево.
[26:13.920 --> 26:28.400]  А, хорошо. Вот так, давайте. Вот так, вот так, вот так и вот так. Так лучше. Вот. Да,
[26:28.400 --> 26:35.960]  в действительности это так. И поэтому здесь тоже нужно использовать ту самую динамику. Как я могу
[26:35.960 --> 26:45.360]  попасть в каждую из ячеек? Ну, я мог прийти либо отсюда, либо отсюда. Как мне выгоднее? Так как это
[26:45.360 --> 26:52.880]  все уже подсчитано здесь каким-то образом, я не знаю каким, то в этом случае как мне лучше поступить?
[26:52.880 --> 26:59.840]  Откуда прийти? Сверху или слева? Там, где денег больше. Правильно? Я поздравляю, что на работу вы
[26:59.840 --> 27:05.240]  можете выбирать в какой-то момент примерно так же. Там, где денег больше, там и лучше. Вот. Но
[27:05.240 --> 27:14.400]  осторожно, это не всегда правда. Так что всегда думайте об этом. Но если это так, то в этом случае
[27:14.400 --> 27:24.200]  мы с вами просто будем смотреть каждую из ячеек и смотреть. Мы пришли в нужное время, ой, мы пришли
[27:24.200 --> 27:31.640]  в эту ячейку из какой? Из левой или справой? И дальше с этим работать. Все достаточно просто.
[27:31.640 --> 27:38.920]  Если мы опять же пройдемся, ну, это ровно то, что я сейчас рассказывал. Если мы опять же пройдемся
[27:38.920 --> 27:46.400]  здесь по всему тому, что у нас есть, то состояние динамики это уже двумерный массивчик, где у нас
[27:46.400 --> 27:52.640]  будет в этой житой ячейке хранится максимальное количество монет, которое можно получить,
[27:52.640 --> 28:09.960]  если мы пойдем из ячейки 00 и дойдем до этой житой ячейки. А? Да, извините, перепутала. Ну,
[28:09.960 --> 28:18.360]  видимо, без очков дело. Вот, не увидел. Извините. Да, начальные значения понятны. Начальное значение
[28:18.360 --> 28:25.880]  это то, что хранится, по сути, вот здесь. Но важный момент здесь, примерно следующий. Смотрите,
[28:25.880 --> 28:35.040]  вот в эту ячейку я могу прийти сбоку вот в эту? Нет. А вот в эту прийти сверху мог бы? Нет. Поэтому
[28:35.040 --> 28:43.800]  фактически можно отнести к начальным условиям и вот этот ряд, и вот этот ряд. Как они переподсчитываются?
[28:43.800 --> 28:55.720]  Да, можно сказать, что вот в этой ячейке у нас хранится сумма, ну, вот это число, которое здесь,
[28:55.720 --> 29:01.640]  плюс сумма с предыдущего. Здесь сумма с предыдущего, плюс число, которое тут хранится и так далее. То есть
[29:01.640 --> 29:06.880]  можно таким вот образом сделать первую строчку и первый столбец. И в зависимости от этого это
[29:06.880 --> 29:11.520]  будет посчитать. То есть это может относиться к тем самым начальным условиям. Ну, порядок пересчета
[29:11.520 --> 29:17.040]  достаточно прост. Мы смотрим максимальное либо слева, либо сверху. То есть либо и минус первое
[29:17.040 --> 29:22.200]  вычитаем, либо же и минус первое вычитаем. И прибавляем ту монетку, которая у нас там есть. Ну,
[29:22.200 --> 29:28.280]  и дальше положение ответа у нас будет храниться вот в этой самой правой ячейке.
[29:28.280 --> 29:44.760]  Поэтому выглядит все достаточно просто. Ну, как бы решение очень простое. А? Кому не просто?
[29:44.760 --> 29:52.320]  Нет, хорошо, давайте так. У кого возникают вопросы и сложности к тому, что мы сейчас делаем?
[29:52.320 --> 30:05.160]  Не возникает. Хорошо, будет так. А, тогда у меня к вам вопрос. А что будет, если я хочу
[30:05.160 --> 30:13.440]  минимизировать эту сумму? Если максимум поставить с минимумом, этого будет достаточно. А что,
[30:13.440 --> 30:24.120]  если я захочу здесь восстановить ответ? Восстановить ответ по тому, как я должен пройти. То есть я
[30:24.120 --> 30:35.640]  должен там вывести, не знаю, не номера ячейка, вот индекс их там. Да, то есть смотрите, мы идем
[30:35.640 --> 30:41.000]  с конца в начало. Мы будем вот в этой ячейке находиться и смотрим, мы отсюда пришли сверху
[30:41.000 --> 30:47.840]  или слева. С максимума кто из них больше. И в зависимости от этого оттуда идем. И так мы сзади,
[30:47.840 --> 30:54.240]  с конца придем к началу. То есть здесь обратный такой порядок будет для восстановления ответа.
[30:54.240 --> 31:06.320]  Понятно? Отлично. Ну, а теперь последняя задачка на сегодня. Дальше мы поговорим с вами, потому что
[31:06.320 --> 31:15.160]  очень быстрая лекция у нас получилась. Может, оно и лучше, я хоть не помру к концу. У меня голос
[31:15.160 --> 31:23.600]  все будет существовать. Смотрите, задача следующая. Требуется найти количество разложений числа n на
[31:23.600 --> 31:37.200]  различные слагаемые. Что еще раз ты сказал? Это правда. Это правда. Кто знает такие слова,
[31:37.200 --> 31:46.560]  как диаграмма Юнга? Два человека получили. Вот в этом проблема. А это задача. Смотрите. Задача
[31:46.560 --> 31:52.040]  звучит следующей. Задача очень простая с точки зрения того, что там происходит. Я имею в виду
[31:52.040 --> 32:01.440]  ее формулировки. Задача стоит корректно, понятно, всего в одну строчку. Много бы таких задач,
[32:01.440 --> 32:07.840]  но, к сожалению, это не всегда хорошо. Ну, на примере числа 7 мы можем увидеть, что таких
[32:07.840 --> 32:22.760]  разбиений 5. Это само число 7. Это 3 плюс 4, 2 плюс 5, 1 плюс 6 и 1 плюс 2 плюс 4. Различных слагаемых.
[32:22.760 --> 32:32.480]  Да. Каждая слагаемая должна быть различна. И вот здесь нужно как-то нам что-то получить.
[32:32.480 --> 32:53.480]  Зачем нам искать легкий путь с ней? Вот если вы двое знаете диаграммы Юнга,
[32:53.480 --> 33:14.480]  чем это здесь может помочь? В принципе, можно. Но вообще из этого всего стоит очень интересный,
[33:14.480 --> 33:20.800]  там связанный с диаграммами Юнга, отдельный вывод того, что любое число, ну, как бы,
[33:20.800 --> 33:26.680]  что такое диаграмма Юнга? Я вам покажу сейчас там дальше. По факту это будет выглядеть вот такими
[33:26.680 --> 33:44.120]  столбиками. Точнее, лесенками я бы сказал. Правду говорю? Вот. А вот каждая такая строчка,
[33:44.120 --> 33:49.920]  это будет у нас означать число некоторое. Ну, а вся сумма это будет вот само число,
[33:49.920 --> 33:57.280]  которое здесь есть. Ну, количество вот этих кубиков, по факту. Вот. И все, что можно делать,
[33:57.280 --> 34:08.360]  это либо сдвинуть все кубики вправо и добавить по факту ко всем 1. Вот так вот. Либо же можно
[34:08.360 --> 34:17.600]  сдвинуть все кубики и сверху добавить еще один. Предположим, что у нас существует два таких действия.
[34:17.600 --> 34:29.040]  То есть мы либо все сдвигаем, либо сдвигаем и делаем еще плюс один. Так вот, говорится следующее,
[34:29.040 --> 34:34.880]  что при помощи этих двух действий единственным способом можно получить каждое число. То есть
[34:34.880 --> 34:43.320]  можно разбить это на большое количество способов. Но благодаря этим двум простым действиям мы можем
[34:43.320 --> 34:51.200]  получить все возможные случаи, которые у нас есть. Для конкретной задачи. То есть вот только лишь
[34:51.200 --> 34:57.240]  вот этим вот сдвигом по факту добавлением единиц ко всему. Либо же сверху надстроить еще кубик.
[34:57.240 --> 35:14.720]  После добавления единиц. Понятно, что я сейчас сказал? На всякий случай. Нет, ты можешь добавлять кубики,
[35:14.720 --> 35:22.920]  я говорю. Либо плюс один ко всему, либо плюс один ко всему и сверху еще один. По факту,
[35:23.000 --> 35:31.360]  что это означает? Если у меня есть число один, то я из единицы что могу получить? Один это просто
[35:31.360 --> 35:40.600]  вот такой вот кубик. Либо два, либо три. Если это два, тогда у меня получается, что это просто так.
[35:40.600 --> 35:53.480]  Если это три, тогда я получаю это вот так. Можно, можно. Именно семь так и получится.
[35:56.800 --> 36:04.640]  Вот эти количество строчек, это и есть количество слагаемых по факту. Из двойки что можно получить?
[36:04.640 --> 36:12.280]  Из двойки можно получить там ту же тройку, просто сдвинувся. А можно получить четыре,
[36:12.280 --> 36:24.760]  получив вот таким вот образом. А из троечки здесь можно получить, получается пять. Это когда у вас
[36:24.760 --> 36:39.080]  будет вот так и вот так. А можно получить вообще шесть. Когда у вас будет вот так, вот так и вот так.
[36:39.080 --> 36:52.040]  Нет, конечно. Можем получать здесь количество. Вот благодаря тому, что я сказал. Что мы можем
[36:52.240 --> 37:09.160]  хранить в ДП. Вот это тоже является нужным вариантом. То есть смотрите, вот так вот разбивает
[37:09.160 --> 37:14.480]  одной единичке, я могу сказать, что тройка раз имеет разложение, два имеет разложение,
[37:14.480 --> 37:24.920]  других разложений она не имеет. У двойки есть только одно разложение, это два. У четыре вот есть здесь,
[37:24.920 --> 37:40.560]  на самом деле вот тут еще будет еще одно. Их тоже два. Это отдельная доказывается вещь,
[37:40.560 --> 37:49.560]  я говорю, поэтому нужна математика. Ну смотрите, я вам говорю, знаете такой забавный факт,
[37:49.560 --> 37:54.240]  типа друзья, вы можете использовать такой забавный факт. Именно поэтому я говорю,
[37:54.240 --> 38:02.160]  что математика очень полезна всегда, особенно в динамике. Вы знали об этом факте или нет?
[38:02.160 --> 38:17.040]  Ну смотрите, очень ли полезно это? Ну такой вопрос. Это прикольная тема, мало ли вы там можете
[38:17.040 --> 38:23.840]  что-нибудь для себя интересное откроете, грубо говоря. Но из него складывается такая вот вещь. Как
[38:23.840 --> 38:39.080]  мне это использовать? Идеи-то у меня есть теперь. Как суммы что?
[38:39.080 --> 38:54.200]  Да неприкольно. Просто количество чего?
[38:54.200 --> 39:08.120]  Из одного количества в другое ты не получишь нормальный пересчет.
[39:08.120 --> 39:20.240]  Число клеток влевом тоже не всегда хорошо. Я вам больше скажу, здесь у нас получается уже двумерная
[39:20.240 --> 39:27.000]  динамика. Для такой простой задачи вы все равно получите ту самую двумерную динамику.
[39:27.000 --> 39:38.120]  На всякий случай я не перелистываю. Вот диаграммы Юнга, вот они. А? Не, какой хип. Не надо, забудь.
[39:38.120 --> 39:48.640]  Вот как бы из диаграмм Юнга вы получите именно вот это, то что мы сейчас с вами разобрали.
[39:48.640 --> 40:05.240]  Смотрите, мы можем сказать следующее. Пусть наша динамика сама по себе
[40:08.120 --> 40:17.320]  видимо надо было побольше задач к вам добавить. Все понятно. Но считайте, что сегодня я отпускаю
[40:17.320 --> 40:26.000]  грехи типа за сплей дерева. Потому что там я вас очень сильно задержал. Смотрите, пусть у меня будет
[40:26.000 --> 40:45.600]  некоторое ДПНКТ. И я скажу, что у меня в ДПНКТ лежит количество разложений на х слагаемых. Ну,
[40:45.600 --> 40:59.560]  различные. Чем мне это поможет? Н это число. А, количество разложений. Н на х слагаемых.
[41:02.880 --> 41:03.380]  Как?
[41:15.600 --> 41:24.040]  Ты хочешь прямой пересчет? Ой, обратный пересчет. А я хочу теперь прямой пересчет. Вы же говорили,
[41:24.040 --> 41:33.120]  что больше нравится. Я на самом деле... Да, по факту это так. То есть смотрите, мы же сдвигаем
[41:33.120 --> 41:40.480]  к чисел. Вот тут, если посмотреть на диаграммке, из 5-6 как получается. Мы сдвигаем к чисел,
[41:40.480 --> 41:47.600]  например. И вот из тройки получается 5. Мы сдвигаем эти два числа. И мы всегда можем сдвинуть
[41:47.600 --> 41:56.120]  вот все числа, которые у нас есть. Если я сдвигаю все числа на 1, то я прибавляю к. Согласны? То есть
[41:56.120 --> 42:06.240]  первый вариант это n-k прийти. И на к слагаемых. Правильно? А второй вариант какой?
[42:11.480 --> 42:18.480]  Все верно. То есть мы можем прийти либо оттуда, либо оттуда. И в зависимости от этого мы с вами
[42:18.480 --> 42:32.120]  уже что-то получаем. Только там будет dp n-k. k-1. Вот. А? Ну смотрите, давайте еще раз. Я могу
[42:32.120 --> 42:38.880]  получить, вот исходя из того, что вам тут вот рисовал, из одного числа могу получить что? Могу
[42:38.880 --> 42:45.680]  просто сдвинуть его и сделать плюс один. Ну плюс вообще k вот этих рядов, сколько у нас есть.
[42:45.680 --> 42:59.040]  Правильно? А могу сделать плюс k рядов и еще плюс один сверху добавить. Вот. И все. Таким образом.
[42:59.040 --> 43:20.360]  У нас там k-1 одно слагаемое будет. Вот. Мы уменьшили это слагаемое количество. Вот. Самое
[43:20.360 --> 43:26.920]  важное здесь, что ответом является сумма вот этого последнего ряда, который у вас есть. Потому
[43:27.000 --> 43:40.600]  что я могу число n разложить там на 1, на 2, на 3, на сколько хочешь слагаемое. Понятно? А? Еще раз.
[43:40.600 --> 44:05.640]  Вот. Смотрите, вот это все решение задачки. Но в начале задача казалась странной. Получается
[44:05.760 --> 44:21.840]  это именно так. Понятно? А важный здесь момент какой? Важный момент здесь с динамикой. Какой связано
[44:21.840 --> 44:29.600]  на самом деле? Что когда мы с вами говорим про количество слагаемых и так далее,
[44:29.600 --> 44:42.880]  сколько работает этот алгоритм? Да. Я про это и хотел сейчас рассказать. Да. Смотрите. Вот сейчас
[44:42.880 --> 44:50.600]  это работает за n квадрат. По факту. Правильно? Мы можем уменьшить это количество. Какое у нас
[44:50.600 --> 44:58.720]  максимальное количество разложений есть числа и. Максимальное количество слагаемых. И. И то это
[44:58.720 --> 45:10.600]  все единицы. По факту это корень. Почему? Да. Потому что максимум, как мы можем разложить число,
[45:10.600 --> 45:23.000]  это 1, плюс 2, плюс 3, плюс 4 и так далее. Согласны? То есть там будет n на n-1,5. Вот. Это первый
[45:23.000 --> 45:30.640]  нюанс здесь. А тогда вот тут получится там корень из n. Тогда вот этот весь алгоритм можно
[45:30.640 --> 45:45.760]  чуть-чуть переписать лучше. И он будет работать за n корень из n. Классно. Вот. Таким образом это
[45:45.760 --> 45:51.720]  одно из самых быстрых решений, которые есть на самом деле с разложением чисел. Стоит решение,
[45:51.720 --> 45:59.600]  которое типа работает за куб. Еще за что-то. Тут мне очень нравится вот красивая математика. Всегда. Вот.
[45:59.600 --> 46:06.760]  Теперь смотрите. По факту моя презентация заканчивается, но я еще кое-что порассказываю.
[46:06.760 --> 46:14.760]  Помните самую первую задачу с лесенками? Представьте, что тот, кто ходит на 1 и 2
[46:14.760 --> 46:27.040]  ступеньки, ходит на 1 и k ступенек. Как там устраивает пересчет? Да. Сумма от n-1-k. А представьте,
[46:27.040 --> 46:32.680]  ну не знаю, что вы еще играете типа pool это лава на определенных ступеньках, не можете там ходить.
[46:32.680 --> 46:43.200]  Да. В них всегда поставить просто ноль. И тогда вы получите нужный вам результат.
[46:43.720 --> 46:52.240]  Вот. То есть с точки зрения динамики все достаточно нетрудно сводится ко всему остальному,
[46:52.240 --> 46:58.840]  ко всем задачам по динамике, которые у нас есть. Их существует большое множество. Существует динамика
[46:58.840 --> 47:06.280]  по профилю, по изломанному профилю. Вы даже можете это посмотреть. Мы, честно, на лекциях этого
[47:06.280 --> 47:14.760]  почти не коснемся, сразу скажу вам. Вот. Но почитайте очень забавные эти вещи. Они очень
[47:14.760 --> 47:20.840]  математические по факту подходят к тому, что там необходимо. Так как среди вас есть математики,
[47:20.840 --> 47:26.320]  я думаю, вам будет весело. Вот на этом блоке, который у нас есть, связанный с динамикой,
[47:26.320 --> 47:33.960]  вы встретитесь еще не один раз с ней. Мы с вами лишь дадим такой толчок тому, чтобы вы начали
[47:33.960 --> 47:41.040]  думать в задачках на тему того, что вы делаете. А после этого у вас будут более интересные алгоритмы,
[47:41.040 --> 47:48.440]  которые тоже используются по сути принцип некоторой динамики. Вот. Ну что ж, давайте тогда
[47:48.440 --> 47:54.360]  поступим следующим образом. Я вас отпущу, потому что с плей деревья у вас было целых плюс 30 минут.
[47:54.360 --> 48:02.720]  Вот. Выстановим этот вселенский баланс. Хорошего вам вечера. Не болейте только.
