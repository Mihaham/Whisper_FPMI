[00:00.000 --> 00:15.920]  Итак, всем еще раз здрасте. Сегодня 12-я лекция и 25-е число. Значит, мы в прошлый раз
[00:15.920 --> 00:21.480]  обсудили AV-дерево. Сегодня мы продолжаем наше изыскание по деревьям поиска, и сегодня
[00:21.480 --> 00:25.400]  будут еще два из них. Я надеюсь, оба успеем. Будет у нас SP-дерево и B-дерево.
[00:25.400 --> 00:36.440]  Итак, мы начнем со SP-дерево. И повторюсь, что мы находимся все в одной и той же парадигме,
[00:36.440 --> 00:41.840]  когда нам нужно разработать какую-то структуру данных, которая, напомню, умеет поддерживать
[00:41.840 --> 00:47.240]  некоторое множество S. Давайте считаем, что чисел. В общем случае, это просто произвольное множество
[00:47.240 --> 00:51.800]  каких-то ключей, которые мы можем сравнивать между собой. И нам нужно уметь обрабатывать
[00:51.800 --> 00:59.560]  операции insert, erase и find. Find – это операция запрос проверки, входит ли данное число в ваше множество S.
[00:59.560 --> 01:04.360]  Соответственно, вы над ним как-то изгаляетесь, делаете разные запросы к нему, изменения датам,
[01:04.360 --> 01:09.280]  insert и erase. И вот иногда поступают запросы find, найти, есть ли данный элемент в множестве.
[01:09.280 --> 01:19.400]  Ну хорошо, что такое будет SP-дерево? SP-дерево – это просто еще одна реализация того же, что у
[01:19.400 --> 01:23.800]  нас было в прошлый раз. В прошлый раз мы рассмотрели AV-дерево. Это какой-то из подходов к тому,
[01:23.800 --> 01:28.080]  чтобы отвечать на все эти запросы эффективно. Мы хранили какое-то дерево, дерево поиска,
[01:28.080 --> 01:32.960]  с каким-то там вариантом, что глубина лево и глубина права, точнее, глубина лево и глубина
[01:32.960 --> 01:37.880]  права, слижается максимально на единичку. SP-дерево – это тоже будет дерево поиска, двоичное.
[01:37.880 --> 01:47.800]  SP-дерево – это тоже двоичное дерево поиска. Но в явном виде у него нет никакого инварианта.
[01:47.800 --> 01:53.760]  Нет варианта в стиле того, что было у AV-дерево. Единственное, что мы будем делать – это следующее,
[01:53.760 --> 01:59.960]  что если какой-то элемент X потрогался, группа игроков, мы вызвали find от X и нашли элемент X в
[01:59.960 --> 02:06.080]  нашем деле, то перед тем, как обрабатывать следующий запрос, мы этот X поднимем в корень. То есть после,
[02:06.080 --> 02:11.720]  скажем, find от X, если мы его нашли, мы вызовем процедуру, которая называется splay от X. И смысл
[02:11.800 --> 02:22.360]  такой, что она X поднимает в корень. Ну вот помним с прошлого раза, что у нас в AV-L просто куча всяких
[02:22.360 --> 02:28.720]  вращений. Там этого сделать, то есть если у нас там был вершинка A, то у нас был такой поворот,
[02:28.720 --> 02:33.440]  который делал наоборот, вершинку B делал предком вершинки A. Ну и там как-то переподвешивался ледерей.
[02:33.440 --> 02:39.600]  То же самое будет здесь, деревья много всяких поворотов, много всяких вращений, рёбер относительно
[02:39.600 --> 02:44.720]  друг друга. И мы хотим сделать вот этот элемент X, который мы только что потрогали, который мы
[02:44.720 --> 02:50.880]  только что нашли, самым верхним, поместить его в корень. Вот это может быть полезно, например,
[02:50.880 --> 02:58.640]  когда вы работаете с каким-нибудь базой данных, к которой запросы поступают, скажем так, неравномерно.
[02:58.640 --> 03:02.560]  Например, у вас есть какой-нибудь сайт, на который заходят пользователи, и понятно,
[03:02.560 --> 03:07.840]  что пользователи можно как-то праранжировать по посещаемости сайта. Чем чаще он посещает сайт,
[03:07.840 --> 03:13.840]  тем, наверное, быстрее хотелось бы отвечать на все его запросы. Тем быстрее нужно выдавать ему любую
[03:13.840 --> 03:19.880]  информацию, которую он попросит. И поэтому хотелось бы пользователей, которые часто пользуются вашим
[03:19.880 --> 03:25.120]  сайтом, хранить в вашем дереве где-то ближе к корню. Потому что время ответа на запрос для каждого
[03:25.120 --> 03:32.120]  человека — это глубина вот этого элемента X, который ему соответствует. То есть если он там ищет
[03:32.120 --> 03:36.200]  какую-то информацию, которая хранится у него в аккаунте, вам нужно найти его в своем дереве и
[03:36.200 --> 03:41.960]  выдать, соответственно, всю информацию, которая ему соответствует. Логин, пароль, дату рождения,
[03:41.960 --> 03:46.280]  которую он вдруг почему-то забыл, ну и так далее. И, соответственно, чем глубже эта вершина, тем
[03:46.280 --> 03:50.320]  дольше вы будете работать. И, наоборот, чем выше эта вершина, чем ближе она к корню, тем быстрее вы
[03:50.320 --> 03:56.240]  будете работать. Поэтому оптимально было бы частых пользователей хранить ближе к корню. Ну и, собственно,
[03:56.240 --> 04:01.320]  ровно это в сплей дерева и происходит. Вы того пользователя, который только что сделал запрос,
[04:02.320 --> 04:07.280]  он спросил какие-то данные про себя, что он там когда-то записал на ваш сайт, но забыл про себя.
[04:07.280 --> 04:11.280]  Вот он говорит, покажи мне, пожалуйста, мою страничку, я там вспомню, что мне там написано.
[04:11.280 --> 04:17.160]  Значит, он смотрит, открывает, и, соответственно, в дереве поиска, которое неявно хранится внутри
[04:17.160 --> 04:21.840]  вашего сайта, этот элемент поднимается в корню. И потом, скажем, если этот пользователь еще много
[04:21.840 --> 04:26.360]  раз идет на ваш сайт, прямо вот сразу, без других запросов, просто он же заходит на сайт
[04:26.360 --> 04:31.760]  вопросы, то вы сможете отвечать на его запросы за от единицы, потому что он и так в корне, и вам
[04:31.760 --> 04:36.280]  не нужно никуда спускаться. Это очень удобно, очень быстро. Вот. Потом, когда приходит какой-нибудь
[04:36.280 --> 04:42.040]  второй пользователь, он его поднимает в корню, соответственно, от того старого куда-то опускает.
[04:42.040 --> 04:46.320]  Но все равно он не может его опустить слишком сильно. Если у вас какие-то пользователи частые,
[04:46.320 --> 04:50.040]  то они всегда будут довольно близко к корню. Ну это вот такое неформальное описание того, зачем нам
[04:50.040 --> 05:00.600]  это нужно. Вот. Ну а сплей — это по-английски так типа... Все эти названия довольно условные.
[05:00.600 --> 05:07.440]  Сплей — это типа раздвинуть. Сплей Apart — это что-то в стиле расширить какие-то элементы между
[05:07.440 --> 05:12.640]  собой. И сплей не то, что происходит расширение, но можно считать, что если у нас там было какое-то
[05:12.640 --> 05:18.640]  дерево с корнем в X, мы X вытаскиваем, насильно берем и поднимаем в корень, и, соответственно,
[05:18.640 --> 05:23.000]  все остальное раздвигается как левый и правый сын. Ну вот так можно понимать, почему здесь такое
[05:23.000 --> 05:30.840]  название сплой. И так. Это просто дерево поиска, который последний элемент, который был в запрос,
[05:30.840 --> 05:35.520]  поднимает в корень перед тем, как перейти к следующему запросу. Вот. Значит, для этого,
[05:35.520 --> 05:42.400]  для сплея нам нужно будет четыре операции. Четыре операции поворота. Значит, они очень странно
[05:42.400 --> 05:48.560]  называются. Первый называется зиг. Это поворот, просто на самом деле маленький поворот вправо.
[05:48.560 --> 05:55.880]  Значит, если есть какая-то вишенка X, и у нее есть родитель P, который является корнем дерева,
[05:55.880 --> 06:02.640]  значит, если P корень, рассмотрим вот, ну пусть X является левым сыном корня. Тогда вот этот
[06:02.640 --> 06:07.880]  поворот направо работает так. Вот представьте, что у вас это ребро между X и P является как бы
[06:07.880 --> 06:13.720]  шарнижчиком, и вы его двигаете так, что X становится теперь верхней вишенкой, а P нижней. То есть
[06:13.720 --> 06:20.120]  у вас теперь X вверху, а P внизу справа. Вот. Остальные вот эти вот A, B, C как-то переподвешиваются,
[06:20.120 --> 06:25.440]  ну C остается справа здесь, A остается слева здесь, а B, ну она, к сожалению, ей приходится
[06:25.440 --> 06:29.960]  переподвешиваться к P. Так же, как у нас было в ВВД дереве, она не может остаться ребенком X,
[06:29.960 --> 06:34.960]  потому что иначе у X будет три ребенка. Поэтому мы B сюда переподвешиваем. Это вот так называемый,
[06:34.960 --> 06:45.760]  на самом деле, просто правый малый поворот. Правый малый поворот. Маленький правый поворот.
[06:45.760 --> 06:51.680]  Вот смысл такой, что мы X-X как бы вытащили чуть повыше, и если он был сыном корня,
[06:51.680 --> 06:57.480]  то теперь X стал корнем. Если он был сыном корня, то теперь после одного такого поворота он стал сам
[06:57.480 --> 07:04.000]  по себе корнем. Вот. Ну соответственно, то же самое, если X это правый сын корня, нам нужно делать
[07:04.000 --> 07:11.360]  левый поворот. Ну, в общем, картинка симметрична, я ее даже рисовать не буду. Хорошо. Ну и понятно,
[07:11.360 --> 07:16.920]  да, мы тоже это, когда рисовали все правое дерево, мы поняли, что все такие повороты, они сохраняют нам
[07:16.920 --> 07:23.360]  инвариант дерева. Что левее, ну вот скажем, посмотрим на этот X. Здесь в левом по дереве все
[07:23.360 --> 07:29.400]  элементы меньше, чем X, в правом должны быть все больше, чем X. Что здесь, да, выполняется легнее
[07:29.400 --> 07:33.200]  равенство здесь. Ну здесь у меня по-прежнему находятся элементы, все элементы из A меньше,
[07:33.200 --> 07:37.960]  чем X, потому что они были такими раньше. Вот. А что происходит с B? Здесь должны быть элементы больше
[07:37.960 --> 07:44.520]  X, но меньше B, да, потому что B находится в правом по дереве X, но в левом по дереве P. Ну, собственно,
[07:44.520 --> 07:49.600]  оно так было изначально и раньше, оно было в правом по дереве X, а в левом по дереве P. Поэтому никакое
[07:49.600 --> 07:54.000]  неравенство не нарушится. В общем, все неравенства, которые должны быть в дереве поиска, они выполняются
[07:54.000 --> 08:02.480]  при таком маленьком повороте. Вот это операция ZIG, которая сына корня делает корнем. Хорошо. Теперь
[08:02.480 --> 08:07.240]  предполагаем, что вершина не является сыном корня, а у нее есть дедушка, то есть она сама не корень,
[08:07.240 --> 08:14.320]  родители не корень, значит есть дедушка. Тогда возникают два случая. Так, я как-нибудь вот так
[08:14.320 --> 08:24.000]  постараюсь их уместить. Значит, первый случай это ZIG-ZIG, когда X и родители X находятся от своего
[08:24.000 --> 08:29.720]  родителя по одну сторону. Ну, например, может быть такое, что X является левым сыном своего отца P,
[08:29.720 --> 08:36.320]  и P является левым сыном своего отца ZIG. Это parent, это grandparent. Тогда поворот работает так,
[08:36.320 --> 08:42.560]  A, B, C, D. Вот эти под деревья у нас есть. Поворот работает так, что мы сначала делаем маленький
[08:42.560 --> 08:47.280]  поворот направо вот здесь, потом маленький поворот направо вот здесь. И получается у нас такой
[08:47.280 --> 08:57.120]  результат. Я сразу нарисую, какая будет картинка в конце. Ну, то есть можно для практики честно
[08:57.120 --> 09:01.400]  сделать сначала первый поворот, собственно, по правилам, которые были нарисованы выше,
[09:01.400 --> 09:05.920]  потом сделать такой второй поворот и понять, что получится ровно такая картинка, как я сейчас
[09:05.920 --> 09:15.320]  нарисую. B, G, C, D. Вот получается такое преобразование. Ну и, собственно, идея та же. У нас был какой-то
[09:15.320 --> 09:21.320]  X, и мы с помощью каких-то двух поворотов сделали X корнем вот этого под деревом. То есть там,
[09:21.320 --> 09:25.040]  возможно, есть еще какое-то продолжение наверх, какой-то путь наверх. Но главное, что мы глубину
[09:25.040 --> 09:30.880]  X как бы уменьшим. Мы его подняли на вершинке вверх. И то же самое, поскольку каждый отдельный
[09:30.880 --> 09:35.880]  поворот, первый и второй, каждый из них отдельно сохраняет инвариант дерева, дерево поиска, что
[09:35.880 --> 09:40.920]  слева все меньше, справа все больше, то, собственно, и это будет тоже корректное преобразование. Это
[09:40.920 --> 09:46.280]  можно называть... Так, ну я не буду говорить, что это... Короче, это большой правый поворот, когда у нас
[09:46.280 --> 09:52.280]  сначала сверху направо, потом снизу направо. Вот это зиг-зиг. И, наконец, зиг-заг. Когда у меня
[09:52.280 --> 10:02.200]  X и родитель XA находятся по разные стороны от своих родителей. То есть, например, вот есть X. Он,
[10:02.200 --> 10:07.360]  скажем, является правым сыном своего родителя, но родитель является левым сыном своего родителя,
[10:07.360 --> 10:12.720]  налевым сыном G. Так, давайте я немножко сдвину, чтобы у меня поместилось все на одном слайде.
[10:12.720 --> 10:26.640]  Так, X, P, G. Ну и тогда здесь есть какие-то поддеревья, A, B, C, D. Тогда зиг-зиг работает так.
[10:26.640 --> 10:32.480]  Мне сейчас, блин, сейчас, на секундочку.
[10:36.320 --> 10:41.040]  Да, мне кажется, что нужно сначала сделать вот этот поворот, потом вот этот поворот. Вот, и тогда
[10:41.040 --> 10:49.560]  у нас результат будет такой. Значит, X вылезет в корень, слева будет P с поддеревьями AB, справа
[10:49.560 --> 10:54.480]  будет G с поддеревьями CD. То есть, опять, мы как-то здесь переподвешиваем все вот эти вот ссылочки,
[10:54.480 --> 11:01.240]  так переназначаем всех детей у вершинок X, P и G, чтобы получился вот такое дерево, чтобы получился
[11:01.240 --> 11:04.720]  вот такое новое дерево. Ну и можно, как всегда, проверить, что в январе или в январе дерево
[11:04.720 --> 11:12.040]  сохраняется. Так, наверное, дерево сохраняется, что слева от любой вершинки лежат только меньшие
[11:12.040 --> 11:16.960]  числа, а справа только больше. Вот, таких трех операций нам будет достаточно, чтобы любую вершинку
[11:16.960 --> 11:23.120]  поднять в корень. Значит, как будет работать процедура сплой? Она вызывает по очереди зиг-зиг или
[11:23.120 --> 11:29.080]  зиг-заг в зависимости от того, по одну ли сторону лежат X и его родители от своих родителей. То есть,
[11:29.080 --> 11:34.120]  если X и родитель X лежат, скажем, оба по левую сторону от родителей, то есть X это левый сын P,
[11:34.360 --> 11:40.440]  а P это левый сын G, тогда вызываем зиг-заг. То же самое, если у меня, например, X это правый сын P,
[11:40.440 --> 11:47.320]  а P это правый сын G, то есть, если оба перехода идут направо, то тоже происходит зиг-зиг. Там все
[11:47.320 --> 11:50.960]  то же самое, только зеркально нужно отразить, вот эту картинку нужно симметрично отразить,
[11:50.960 --> 11:56.180]  чтобы получить поворот, когда у меня оба, куска направо. Вот, а если у меня, наоборот,
[11:56.180 --> 12:01.360]  скажем, X это правый сын P, а P это правый сын G, тогда нужен зиг-заг, ну и наоборот, если
[12:01.360 --> 12:08.120]  у меня x это левый сын p, а p это правый сын g, тогда тоже зигзаг. То есть вот для каждого из четырех
[12:08.120 --> 12:13.120]  возможных случаев, как у меня происходит подъем к родителю x и как происходит подъем к родителю
[12:13.120 --> 12:18.160]  p, в каждом из четырех случаев не нужно применить либо зигзаг, либо зигзаг. Ну если, соответственно,
[12:18.160 --> 12:25.000]  сплей от данной вершинки делает следующее. Он смотрит на текущую глубину вершины, если она
[12:25.000 --> 12:30.040]  хотя бы два, то есть есть и родитель, и дедушка, тогда он применяет либо зигзаг, либо зигзаг,
[12:30.040 --> 12:37.320]  в зависимости от того, какие там идут повороты. То есть если нужно подниматься влево и влево,
[12:37.320 --> 12:42.360]  или вправо и вправо, тогда он делает зигзаг. Если влево-вправо или вправо-влево, то нужно
[12:42.360 --> 12:47.120]  зигзаг. Тем самым мы как бы уменьшили глубину x на два, мы его подняли на две вершины вверх.
[12:48.120 --> 12:54.000]  И так поднимаем-поднимаем, пока либо x не окажется в корне, либо x не станет сыном корня. Ну а если
[12:54.000 --> 13:00.720]  он является сыном корня, то мы просто делаем одну операцию и зиг, и x становится корнем. То есть
[13:00.720 --> 13:06.440]  сплей от x, давайте напишем, что это несколько раз зиг-зиг и зиг-заг, несколько раз зиг-зиг и
[13:06.440 --> 13:15.720]  зиг-заг, и потом, ну как это написать, какого-то количества раз, и потом максимум один раз зиг,
[13:15.720 --> 13:31.240]  один раз. Вот так работает сплей. Хорошо. Зачем вот нам эти двойные, почему нельзя просто какие-то
[13:31.240 --> 13:41.120]  там зиги-заги делать? Ну с ними ничего не сойдется, там не сойдется асимплатика. Мы докажем чуть позже,
[13:41.120 --> 13:48.000]  что вот при таких сплоях, да, возможно странных, неестественных, асимплатика будет амортизированный
[13:48.000 --> 13:54.000]  логарифм на запрос. Если бы мы делали просто зиги или просто заги, да, ну то есть вот подъем
[13:54.000 --> 13:58.720]  просто в родителя, то там, к сожалению, была бы хуже асимплатика, мы бы не смогли доказать.
[13:58.720 --> 14:05.760]  У нас же зиг-зиг расписывается как два зига, а зиг-заг как один зиг и один заг. Вот прям можно
[14:05.760 --> 14:15.520]  даже выразить через них. Вы правы? Сейчас, одну секунду тогда. А нет, смотрите, здесь важен порядок,
[14:15.520 --> 14:20.520]  потому что если бы мы просто, вот смотрите, вот в случае зиг-зиг у меня поворот происходит сначала
[14:20.520 --> 14:28.160]  от отца к дедушке, а потом поворот от меня к отцу, да, то есть вот один-два. То есть тут важно
[14:28.160 --> 14:33.480]  получается в каком порядке применять эти зиги. Да, все равно как бы у меня любой маленький, как бы
[14:33.480 --> 14:38.280]  что зиг-зиг, что зиг-заг, он складывается из там двух маленьких поворотов, но важно в каком
[14:38.280 --> 14:44.040]  порядке их применять. Вот, и если не определять зиг-зиг и зиг-заг, то ничего не получится. То есть
[14:44.040 --> 14:54.360]  ну тут важен порядок у них. Понятно? То есть это такой чистый уровень абстракции, чтобы мы потом не думали о порядке?
[14:54.360 --> 15:07.600]  Так, фразу уровень абстракции я не понимаю. То есть мы создаем вот зиг-зиги и зиг-заг только
[15:07.600 --> 15:13.160]  для того, чтобы создать уровень абстракции над зигом и загом, чтобы потом использовать уже зиг-зиги
[15:13.160 --> 15:17.800]  и зиг-заг, не задумываясь о том, в каком порядке внутри применяются зиги и заги. Так что ли?
[15:17.800 --> 15:25.640]  Можно сказать, что так, да. Но уровень абстракции мне не нравятся фразы, потому что это ну как бы можно
[15:25.640 --> 15:30.680]  считать, что они не связаны. То есть можно не думать о том, что они как-то завязаны на зиг и заг. Это
[15:30.680 --> 15:35.800]  просто какие-то отдельные процедуры, которые вот поднимают х на два уровня вверх. И при этом мы
[15:35.800 --> 15:42.200]  можем, не потеряя симптомики, выразить их через зиги и заги. Так ведь? Можем, но это для нас не
[15:42.200 --> 15:51.680]  существенно. Ладно. Ну можем, да. Вот, значит, теперь давайте поймем, как использовать этот сплей,
[15:51.680 --> 15:56.480]  который поднимает данную вершинку х в корень с помощью этих странных операций. Можно реализовать,
[15:56.480 --> 16:03.160]  так вопрос в чате. Почему обязательно зиг делаем в конце? Если предпоследний корень был дедушкой,
[16:03.160 --> 16:08.080]  разве последний зиг нужен? Нет-нет, я сказал, я не написал здесь. Хорошо, давайте подпишем,
[16:08.080 --> 16:13.400]  что не больше чем один раз, если х стал корнем после зиг-зигов и зиг-загов, то, возможно,
[16:13.400 --> 16:17.520]  зиг не нужен. То есть если мы уже корень, то, конечно, последний зиг не нужен. То есть он не
[16:17.520 --> 16:23.400]  больше чем один раз применяется. Итак, как мы делаем insert в нашем сплей дереве? Insert х. Ну,
[16:23.400 --> 16:32.400]  сначала мы вставляем х так же, как в наивном дереве. Вставляем х так же, как в наивном дереве
[16:32.400 --> 16:41.880]  поиска. В наивном дереве поиска. То есть мы просто спускаемся в поисках х, пытаемся, ну,
[16:41.880 --> 16:45.600]  когда-то пытаемся пойти в неисуществующую вершинку и там искать х, ну, тогда вот на место
[16:45.600 --> 16:50.720]  неисуществующей вершинки подвешиваем х. А дальше в конце вызовем сплей от х. То есть вот давайте
[16:50.720 --> 16:56.840]  нарисую. Мы как-нибудь там шли-шли-шли искали, дошли до вершинки, куда нужно подвесить х и сюда его
[16:56.840 --> 17:01.960]  подвешиваем. А дальше вызываем сплей и поднимаем его в корень. То есть там какие-то зиги, зиг-зиги
[17:01.960 --> 17:07.560]  и так далее, подъемы. Так что теперь х становится корнем. И что нам очень важно в этом случае,
[17:07.560 --> 17:15.400]  это что время работы инсерта, оно ограничено сверху времени работы сплея. Ну, потому что если
[17:15.400 --> 17:19.360]  инсерт работает, мы знаем, что инсерт работает за глубину, собственно, которую мы опустились,
[17:19.360 --> 17:24.040]  то есть мы просто прошли сверху вниз. Да, если глубина этого пути, длина этого пути равна
[17:24.040 --> 17:28.240]  времени работы инсерта. Просто сколько раз нам нужно пойти вниз. А дальше мы делаем сплей,
[17:28.240 --> 17:34.480]  который как-то поочередно этот х поднимает вверх, с помощью каких-то поворотов. Ну, понятно тогда,
[17:34.480 --> 17:38.440]  что время работы сплея, оно тоже пропорционально глубине, собственно, этого пути, просто длине
[17:38.440 --> 17:45.120]  этого пути. А значит, можно, если мы после каждого инсерта будем вызывать сплей, можно в суммарной
[17:45.120 --> 17:49.360]  асимптотике, поскольку мы все равно работаем в терминах О большого и мультиприкритинные
[17:49.360 --> 17:55.680]  константы мы обрасываем, можно считать, что инсерты не вносят вклад, потому что у нас есть
[17:55.680 --> 18:00.640]  все равно сплей, потому что каждая вставка сопровождается непосредственно вставкой в дерево,
[18:00.640 --> 18:07.400]  а потом сплеем этой вершинки, вытаскиваем ее вверх. Поэтому если суммарно сложить все
[18:07.400 --> 18:12.880]  временные работы всех этих процедур, то это максимум в два раза хуже, в два раза больше,
[18:12.880 --> 18:17.240]  чем просто сумма временной работы сплайов. Потому что каждая операция, вот этот инсерт,
[18:17.240 --> 18:22.880]  соответствует ограниченно сверху своим сплаймам. Поэтому суммарное время работы мы будем
[18:22.880 --> 18:30.000]  измерить в количествах шагов, которые сделал сплей, а не сделали инсерт или рейс. С инсертом
[18:30.000 --> 18:36.680]  разобрались, мы ограничим время работы инсерта, время работы сплая. Что делать с рейсом? Рейс х.
[18:36.680 --> 18:42.920]  На самом деле здесь будет удаление тоже точно такое же, как в наивном дереве поиска. Удаляем
[18:42.920 --> 18:59.400]  удаляем х так же, как в наивном дереве поиска. Как это работает, напоминаю, вот есть какое-то
[18:59.400 --> 19:06.040]  дерево, скажем, и мы нашли в нем х, нашли х. Если у х нет левого или правого сына, тогда мы просто
[19:06.040 --> 19:13.400]  имеющегося сына подвешиваем на место х, и на этом заканчиваем. Если у х есть и левый и
[19:13.400 --> 19:20.280]  правый сын, давайте, скажем, спустимся в правого сына, найдем в нем минимальный элемент у. У
[19:20.280 --> 19:26.720]  запишем на место х, а правого сына у запишем на место у. Это мы обсуждали тоже в прошлый раз,
[19:26.720 --> 19:30.640]  про наивное дерево поиска. Давайте повторю. Если есть какой-то элемент х, вот мы нашли его в
[19:30.640 --> 19:36.480]  дереве, элемент х, и у него есть оба сына, левый и правый. Тогда давайте спустимся в правого сына,
[19:36.480 --> 19:41.720]  вот это вот р, спустились в правого сына. Затем в правом поддерега, в этом правом сыне, найдем
[19:41.720 --> 19:45.680]  самый минимальный элемент, просто спусками влево, идем влево-влево-влево, пока есть левый сын.
[19:45.680 --> 19:52.800]  Дошли до кого-то у без левого сына. Теперь просто берем у и копируем на место х. Х удаляем,
[19:52.800 --> 19:58.840]  пишем на его место у, а вместо у подвешиваем его правого сына. Если здесь был какой-то z,
[19:58.840 --> 20:05.600]  то мы z подвешиваем на место у. Ровно так же, как у нас было в наивном дереве поиска.
[20:05.600 --> 20:14.000]  Вот, мы сделали это, и в конце мы запустили сплей от z. И тогда работает то же самое. Время
[20:14.000 --> 20:19.720]  работы ирейза ограничено сверху временем того, чтобы нам поднять этот z в корень. Потому что,
[20:19.720 --> 20:24.280]  что такое время работы ирейза? Мы спустились до х, потом спустились до у и еще взяли z. Ну то есть,
[20:24.280 --> 20:28.680]  мы просто по сути спустились вниз как-то по дереву, что-то там переподвесили. z у перекопировано
[20:28.680 --> 20:35.760]  на место х, z на место у. Но тогда теперь, если я запущу сплей от z, то время работы как раз будет
[20:35.760 --> 20:40.320]  ну такое же. Мы просто поднимаемся обратно по этому пути и что-то там переподвешиваем. Поэтому вновь
[20:40.320 --> 20:46.080]  время работы ирейза ограничено временем работы сплея. И поэтому в общей сумме, когда мы говорим
[20:46.080 --> 20:50.280]  в тернах о большого, можно считать, что слагаемый соответствующий ирейза просто отсутствует. Есть
[20:50.280 --> 20:57.240]  только сплей. Есть только операции сплей. Так, ну и последнее, про что я уже неявно говорил,
[20:57.240 --> 21:03.320]  то что если есть операция find х, то мы сначала находим, если х в дереве, находим, а потом запускаем
[21:03.320 --> 21:11.440]  сплей от х. Нашли его в дереве, запустили сплей и сделали его корнем. То же самое, время спуска
[21:11.440 --> 21:17.560]  оценивается сверху временем работы операции сплей. Поэтому в итоге все операции, они оцениваются
[21:17.560 --> 21:24.040]  сверху сплаями. И давайте мы просто вместо всех операций анализируем только сплей. Так, вопрос
[21:24.040 --> 21:28.600]  тщательный. Кого мы поднимаем при удалении? Можно еще раз, пожалуйста. Давайте я нарисую картинку
[21:28.600 --> 21:34.080]  побольше на следующем слайде. Надеюсь, они поймают. Значит, вот есть большое дерево поиска. Сначала
[21:34.080 --> 21:42.280]  мы находим где-то в нем х. Тот элемент, который нужно удалить. Race х, запрос. Здесь есть два
[21:42.280 --> 21:51.840]  случая. А, при помощи сплей. Все окей. Сплей от z. Нет, все-таки мне нужна будет картинка. Давайте еще
[21:51.840 --> 21:58.720]  раз. Если у х есть оба сына, то я спускаюсь в правого сына, затем нахожу в нем минимального
[21:58.720 --> 22:08.600]  потомка y. У него может быть правый сын z. И что тогда я делаю? Я y перемещаю на место х, z
[22:08.600 --> 22:18.360]  переподвешено на место y и запускаю сплей от z. То есть правило очень простое. Самая глубокая
[22:18.360 --> 22:24.720]  потроганная вершинка должна переместиться в корень. Раз у нас время работы рейса пропорционально длине
[22:24.720 --> 22:29.200]  вот этого пути, то теперь мне достаточно будет вызвать сплей от этой вершинки, которая поднялась
[22:29.200 --> 22:34.320]  сюда. И тогда время работы сплея тоже будет примерно такое же. Но в терминах тетты большой
[22:34.320 --> 22:38.640]  будет пропорционально просто в длине пути. Соответственно, рейс ограничивает сверху сплею.
[22:38.640 --> 22:45.720]  А у нас z может быть не листом? z может быть не листом, да. Ну, тогда мы просто все вот это
[22:45.720 --> 22:50.280]  под дерево переподвешиваем сюда. То есть просто говорим, что теперь левым сыном вот этого старой
[22:50.280 --> 22:54.880]  вершинки p является z. То есть там нужно будет просто перенаправить одну стрелку, забыть про y,
[22:54.880 --> 23:04.000]  и все уже хорошо. А зачем, когда мы удаляем делать сплей? Это для симптотики тоже или вообще зачем?
[23:04.000 --> 23:10.120]  Ну да, для симптотики, потому что иначе мы никак не сможем оценить время работы рейсов. То есть если
[23:10.120 --> 23:15.040]  мы ничего не будем делать и просто удалять, как на ином дереве поиска, то... Ну собственно, а тоже вопрос,
[23:15.040 --> 23:20.800]  а зачем в инсерте делать сплей? У нас же получается мы только замедляем для того,
[23:20.800 --> 23:27.720]  чтобы было удобнее считать симптотику. Давайте вставим сортируем пузырьком,
[23:27.720 --> 23:36.920]  тогда вообще легко будет. Сейчас, но мы не то, что замедляем. Нет, но когда мы вставляем,
[23:36.920 --> 23:41.680]  то понятно, что логично добавился какой-то новый пользователь, мы его сразу наверх докидываем.
[23:41.680 --> 23:48.200]  Примеряем, но когда мы удаляем, то мы какого-то левого непонятно подняли на самый верх. Да, именно так.
[23:48.200 --> 23:53.480]  Ну окей, если бы мы так не делали, то не просто было бы тяжело проводить анализ, а это было бы
[23:53.480 --> 23:58.760]  невозможно, потому что время работы операции рейс мы бы вообще ничем не смогли оценить.
[23:58.760 --> 24:08.720]  А если мы, допустим, говорим, что операция рейс состоит из некоторого действия по удалению и
[24:08.720 --> 24:15.440]  операции сплей, причем сплей явно не меньше, чем действие удаления. И мы говорим, что симптотика
[24:15.440 --> 24:21.440]  сплея равна симптотике удаления. Да, так можно сделать. Тогда мы говорим, что если мы удалим
[24:21.440 --> 24:29.880]  сплей из операции рейс, то асимптотика не уменьшится, то есть О от сплей получится. Здесь
[24:29.880 --> 24:40.600]  будет труднее вычислить тету, но вот О от сплей вполне нормально. Секунду. То есть не больше,
[24:40.600 --> 24:45.040]  чем сплей. И все-таки мне кажется, где-то обман в вашем рассуждении, потому что если, скажем,
[24:45.880 --> 24:51.360]  рейopen.ru и вы их все по отдельности удалите и не вызовите ни раз сплей, то ну типа нельзя
[24:51.360 --> 24:55.180]  сказать, что время работы рейс меньше, чем время сплей, потому что сплея у вас вообще нет.
[24:55.180 --> 25:01.380]  Но если вы доказали, что время работы этого рейса меньшеineshmm,
[25:01.380 --> 25:07.160]  чем время работы сплей, то... Мы же не делим сплей, если мы не запускаем сплей,
[25:07.160 --> 25:11.280]  то у нас не понятно с чем мы сравним. Если мы не запускаем сплей, то не понятно, что мы делаем.
[25:11.280 --> 25:16.680]  Короче, смотрите, давайте мы не будем пытаться переизобретать дерево, в общем, есть такой алгоритм,
[25:16.680 --> 25:21.520]  он работает, мы сейчас обратно все докажем, почему все сходится. Если делать не так,
[25:21.520 --> 25:26.920]  то соответственно не сойдется, или там просто в каком-то месте будет дырка, и время рейза не
[25:26.920 --> 25:33.040]  получится о чем-нибудь оценить. Итак, значит, что мы сказали? Мы сказали, что время работы каждой
[25:33.040 --> 25:39.360]  операции, ну, t-operation, да, любое, любой операции ограничивается сверху времени работы сплея,
[25:39.380 --> 25:43.620]  поэтому давайте вместо того, чтобы считать суммарно время работы всех оперiferации,
[25:43.620 --> 25:49.280]  будем считать суммарно время работы всех сплеёв. И я утверждаю, что время работы,
[25:49.280 --> 25:56.400]  амортизированное время работы каждого сплея это алгоритм, а ozvylezhashka, напоминаю,
[25:56.400 --> 26:06.500]  что это у нас обозначает амортизированную сложность. То есть, если, скажем, вы делаете
[26:06.500 --> 26:10.580]  к изначально пустому сплэй-дереву к запросов, то суммарно можно считать,
[26:10.580 --> 26:16.380]  неважно каких, да, там insert, erase или find, то суммарно вы на все запросы отвечаете за от колока.
[26:25.620 --> 26:27.780]  Так, ну Дмитрий задает тот же вопрос, оно...
[26:36.500 --> 26:46.020]  Да, оно влияет на асимптотику, да, оно влияет на асимптотику, потому что если так не делать, то время работы может вырыться в квадрат.
[26:46.020 --> 26:51.420]  Да, кстати, вот это правильный вопрос, то есть, если мы не будем делать сплэй, то вы можете сам придумать пример,
[26:51.420 --> 26:59.060]  когда время работы вырождается в линейное на запрос. Да, это важное замечание, надо было его сказать, да, спасибо за уточнение.
[26:59.060 --> 27:04.580]  Итак, вот докажем сейчас, что суммарно все будет работать за лоберифом амортизирования.
[27:05.460 --> 27:12.460]  Мы воспользуемся методом потенциалов, который мы когда-то рассматривали, метод потенциалов.
[27:14.740 --> 27:25.780]  Значит, давайте скажем, что пусть s от x это количество вершин в подделье x, количество вершин.
[27:26.660 --> 27:29.700]  Так, давайте я перейду на следующий слайд, у меня не хватает здесь места.
[27:34.580 --> 27:56.740]  Пусть s от x, количество вершин в подделье x, ну мы считаем, что x лежит в своем подделье, x тоже входит в подделье.
[27:56.740 --> 28:13.940]  Дальше, скажем, что r от x это двоичный логарифм этого s от x, ну и поскольку s от x это хотя бы единица, раз x самоходит в своем подделье,
[28:13.940 --> 28:22.980]  значит, это чтобы всегда не отписать. И когда наконец потенциалом нашего сплэй-дерева мы объявим сумму всех этих вот r, сумму всех рангов по всем вершинам.
[28:23.780 --> 28:32.340]  Сумму по всем x из множества вершин r от x. Это потенциал с плэй-деревом, с плэй-деревом.
[28:34.980 --> 28:43.540]  Вот, и наша задача теперь с этим потенциалом понять, что амортизировано каждый сплэй работает за отлогарифмом, за отлогарифм,
[28:43.540 --> 28:54.260]  значит, напоминаю, как мы рассуждаем, когда работаем с потенциалом. Мы ввели какой-то потенциал. Дальше, пусть t и t это реальное время обработки этого запроса,
[28:54.260 --> 29:14.980]  реальное время обработки этого запроса. Ну а там phi, скажем, с производительным индексом phi жита, это потенциал после житого запроса.
[29:15.700 --> 29:24.660]  После житого запроса. Тогда мы определяем i и t, как раз-таки вот эту учетную амортизационную сложность, амортизационную стоимость, как t и t,
[29:24.660 --> 29:32.900]  плюс phi после этого запроса, минус то, что было до него, минус phi, минус 1. То есть это сколько реального времени мы потратили,
[29:32.900 --> 29:39.700]  плюс изменение потенциала delta phi в момент времени i. Насколько потенциал изменился при выполнении этого запроса.
[29:40.420 --> 29:48.420]  И вот эта ашка, если мы докажем, что эта ашка оценится сверху от логарифма, оценивается сверху константа у нашего логарифма,
[29:48.420 --> 29:54.420]  тогда получится как раз-таки то, что нужно. Амортизационная сложность будет у нас логарифмической.
[29:54.420 --> 30:00.420]  Амортизационная сложность логарифмической. Ну что, давайте этим займемся.
[30:01.140 --> 30:17.140]  Докажем, докажем, что амортизационное время работы операции splay от x не больше чем 1 плюс 3 r' от x минус r' от x,
[30:17.140 --> 30:25.140]  где r это старый ранг вершинки x до запроса, а r' это новый ранг вершинки x, то есть после splay.
[30:25.860 --> 30:31.860]  Давайте подпишем это до splay, до выполнения процедуры splay, это после splay, это после splay.
[30:35.860 --> 30:41.860]  Вот, значит, это мы докажем чуть-чуть позже, но давайте сразу заметим, что если мы это докажем, то отсюда немедленно следует,
[30:41.860 --> 30:47.860]  что эта штука оценится сверху единицей плюс 3 log2n.
[30:48.580 --> 30:56.580]  Значит, вот почему. Что такое r' от x? Ну, вспоминаем, что splay от x поднимает данную вершинку x всегда в корень дерева,
[30:56.580 --> 31:04.580]  всегда вершинку x поднимает в корень, но тогда r' от x это двоихистный логарифм от числа вершин в подделе, ну, в новом подделе x.
[31:04.580 --> 31:12.580]  Ну теперь, раз x это корень, то просто r' это логарифм от n, все вершинки лежат в этом подделе, все вершинки лежат в подделе x.
[31:13.300 --> 31:19.300]  Ну а здесь идет там какой-то минус r' от x, минус какое-то недооцентное число, поэтому здесь будет оценка сверху.
[31:19.300 --> 31:25.300]  Здесь будет оценка сверху. Ну и как раз это и означает, что амортизационное время работы каждой операции каждого splay'а
[31:25.300 --> 31:33.300]  оценивается сверху от логарифма, от log2n. Значит, если мы докажем вот это вот неравенство, вот это вот красненькое,
[31:33.300 --> 31:39.300]  тогда мы победим. Отсюда будет следует, что амортизационно мы работаем за логарифм на запрос.
[31:40.020 --> 31:46.020]  У нас же потенциал всего дерева это сумма по всем вершинкам.
[31:46.020 --> 31:53.020]  Вот, у нас потенциал изменился не только у вершины x, а еще у той, с которой мы ее поменяли.
[31:53.020 --> 31:56.020]  Типа там же мы много вершин мы поменяли, разве нет?
[31:56.020 --> 32:02.020]  Да, конечно, но смотрите, вот если это утверждение будет верно, то мы победили. Вы с этим согласны? Или нет?
[32:02.020 --> 32:04.020]  А, то есть мы еще не доказали?
[32:04.020 --> 32:06.020]  Мы доказали, докажем.
[32:10.020 --> 32:12.020]  Так, дальше не услышал, три.
[32:12.020 --> 32:14.020]  А, все, все, хорошо, если докажем, то хорошо.
[32:14.020 --> 32:17.020]  Да, да, если мы докажем, то мы победим. Сейчас будем доказывать.
[32:17.020 --> 32:21.020]  Там непростое доказательство, это там на несколько слайдов точно будет.
[32:22.020 --> 32:27.020]  Вот, ну хорошо, мы помним с вами, что splay' это последовательность всяких сложных операций.
[32:27.020 --> 32:29.020]  Зиг-зиг, зиг-заг и зиг.
[32:29.020 --> 32:35.020]  Давайте тогда все их аккуратно проанализируем и поймем учетное вот это амортизированное время работы каждой из них.
[32:35.740 --> 32:37.740]  Значит, начнем с a вот зиг.
[32:37.740 --> 32:40.740]  Амортизационное время работы, процедура зиг.
[32:40.740 --> 32:44.740]  Ну хорошо, давайте я ее так кратко восстановлю.
[32:44.740 --> 32:48.740]  Значит, было p, было x, тут какие-то под деревья были.
[32:48.740 --> 32:52.740]  И мы вот такое вращение делаем, соответственно, x становится новым корнем.
[32:52.740 --> 32:56.740]  p уходит вправо, ну и здесь будет там a, b, c.
[32:56.740 --> 32:58.740]  Значит, что такое тогда вот это учетное время?
[32:58.740 --> 33:00.740]  Это реальное время работы.
[33:01.460 --> 33:05.460]  Давайте я напишу здесь единицу, как знак того, что мы сделали один маленький поворот.
[33:05.460 --> 33:07.460]  Да, один маленький поворот.
[33:07.460 --> 33:09.460]  А дальше плюс изменение потенциала.
[33:09.460 --> 33:11.460]  И вот здесь как раз то, о чем вы говорили.
[33:11.460 --> 33:13.460]  Извините, ну да, изменение потенциала.
[33:13.460 --> 33:15.460]  Как меняется потенциал при таком повороте?
[33:15.460 --> 33:21.460]  Ну у меня у каких-то вершинок поменялся размер под дерево, а значит поменялся r, поменялся рамк.
[33:21.460 --> 33:23.460]  Но у каких вершин это поменялось?
[33:23.460 --> 33:25.460]  Только у x и у p.
[33:25.460 --> 33:29.460]  Понятно, что мы под дерево a не трогали, и поэтому там сумма всех этих r такая же, как была раньше.
[33:30.180 --> 33:32.180]  То же самое с b, то же самое с c.
[33:32.180 --> 33:34.180]  Там все потенциалы, все r не поменяются.
[33:34.180 --> 33:36.180]  Поэтому изменилось что-то только для x и p.
[33:36.180 --> 33:38.180]  Ну давайте это напишем.
[33:38.180 --> 33:40.180]  Давайте мы напишем, что здесь изменение потенциала
[33:40.180 --> 33:42.180]  это r' от x плюс r' от p,
[33:42.180 --> 33:44.180]  минус r от x, минус r от p.
[33:46.180 --> 33:52.180]  Где опять штрих означает, что это рамк в обновленной версии дерева,
[33:52.180 --> 33:54.180]  а r' это рамк вот здесь,
[33:54.180 --> 33:56.180]  а r от x это рамк вот здесь.
[33:56.900 --> 34:00.900]  В старой версии до вот этой операции зиг.
[34:00.900 --> 34:02.900]  Так, хорошо.
[34:02.900 --> 34:14.900]  Давайте здесь заметим, что r' от p меньше или равно, чем r от p.
[34:14.900 --> 34:16.900]  Ну это почти очевидно, потому что что такое r от p?
[34:16.900 --> 34:20.900]  Это двоечисленный рифм всего вот этого размера вот этого под деревом.
[34:20.900 --> 34:22.900]  А r' от p это размер только вот этого под деревом.
[34:23.620 --> 34:25.620]  Ну понятно, что у меня размер под деревом p только уменьшился.
[34:25.620 --> 34:27.620]  Давайте еще раз.
[34:27.620 --> 34:29.620]  Раньше в нем было все вот это.
[34:29.620 --> 34:31.620]  И p, и x, и i, и b, и c.
[34:31.620 --> 34:33.620]  А теперь стало только p, b, и c.
[34:33.620 --> 34:35.620]  Значит размер под деревом уменьшился.
[34:35.620 --> 34:37.620]  Значит двоечисленный рифм тоже уменьшился.
[34:37.620 --> 34:39.620]  Поэтому выполняется вот такое неравенство, что r' не больше, чем r' от p.
[34:39.620 --> 34:41.620]  Поэтому можно вот это неравенство продолжить.
[34:43.620 --> 34:47.620]  И сказать, что вот эта вот штука меньше или равно 0.
[34:47.620 --> 34:49.620]  Если мы прибавляем что-то маленькое, считаем что-то большое,
[34:50.340 --> 34:52.340]  значит мы прибавили что-то от...
[34:56.340 --> 34:58.340]  Сейчас, секунду.
[34:58.340 --> 35:00.340]  Ну да, короче, вот эта вот разность,
[35:00.340 --> 35:02.340]  то, что я волнистый подчеркнул,
[35:02.340 --> 35:04.340]  она, конечно, не положительная, меньше она 0.
[35:04.340 --> 35:06.340]  Поэтому можно продолжить неравенство и написать,
[35:06.340 --> 35:08.340]  что здесь написано 1 плюс r' от x,
[35:08.340 --> 35:10.340]  минус r от x.
[35:10.340 --> 35:12.340]  Вот.
[35:12.340 --> 35:14.340]  Ну а эта штука, конечно, не больше, чем 1 плюс
[35:14.340 --> 35:16.340]  утроенная r' от x,
[35:16.340 --> 35:18.340]  минус r от x.
[35:19.060 --> 35:21.060]  Вот.
[35:21.060 --> 35:23.060]  Это очевидно.
[35:23.060 --> 35:25.060]  Потому что, ну, как бы, я беру вот эту вот
[35:25.060 --> 35:27.060]  разность, r' минус r от x.
[35:27.060 --> 35:29.060]  Понятное дело, что она не отрицательна,
[35:29.060 --> 35:31.060]  поскольку у меня размер по дереву x только вырос.
[35:31.060 --> 35:33.060]  Давайте посмотрим сюда.
[35:33.060 --> 35:35.060]  Вот это был старый r от x,
[35:35.060 --> 35:37.060]  двоичным грифом этого размера.
[35:37.060 --> 35:39.060]  А новый r' от x, это размер вот этого,
[35:39.060 --> 35:41.060]  двоичным грифом вот этого размера по дереву.
[35:41.060 --> 35:43.060]  Понятно, что тогда такая разность не отрицательна.
[35:43.060 --> 35:45.060]  Значит, если нужно 3, то я ответ только увеличу.
[35:45.060 --> 35:47.060]  Хорошо, значит, мы получили
[35:47.780 --> 35:49.780]  оценку на zig точно такой, как нам нужно.
[35:49.780 --> 35:51.780]  1 плюс утроенная разность
[35:51.780 --> 35:53.780]  нового r' из старого.
[35:53.780 --> 35:55.780]  Значит, для zig у нас все есть.
[35:55.780 --> 35:57.780]  Давайте обведу.
[35:57.780 --> 35:59.780]  Для zig мы получили оценку.
[35:59.780 --> 36:01.780]  Едем дальше.
[36:01.780 --> 36:03.780]  Теперь анализируем zig-zig.
[36:03.780 --> 36:05.780]  Out-zig-zig.
[36:05.780 --> 36:07.780]  Давайте я восстановлю картинку.
[36:07.780 --> 36:09.780]  Значит, был grandparent, parent и x.
[36:09.780 --> 36:11.780]  У них были там какие-то
[36:11.780 --> 36:13.780]  поддеревья.
[36:13.780 --> 36:15.780]  A, B, C, D.
[36:16.500 --> 36:18.500]  И мы сделали такие повороты,
[36:18.500 --> 36:20.500]  что x вылезла в корень.
[36:20.500 --> 36:24.500]  p и g это правая ветка, а здесь A, B, C, D.
[36:24.500 --> 36:26.500]  Хорошо, тогда что такое
[36:26.500 --> 36:28.500]  учетная стоимость операции zig-zig?
[36:28.500 --> 36:30.500]  Сначала мы пишем
[36:30.500 --> 36:32.500]  реальное время работы этой операции.
[36:32.500 --> 36:34.500]  Это, конечно, двойка, потому что, ну,
[36:34.500 --> 36:36.500]  как мы не доказали, но так,
[36:36.500 --> 36:38.500]  сказали, эта операция
[36:38.500 --> 36:40.500]  складывается из двух маленьких поворотов.
[36:40.500 --> 36:42.500]  То есть, если раньше мы делали 1 zig,
[36:42.500 --> 36:44.500]  то теперь там нужно сделать 2 операции zig.
[36:45.220 --> 36:47.220]  Здесь время, ну, как бы реальный
[36:47.220 --> 36:49.220]  время работы будет двойкой.
[36:49.220 --> 36:51.220]  Плюс обменяем потенциал.
[36:51.220 --> 36:53.220]  Ну, опять, поскольку в поддеревьях A, B, C, D
[36:53.220 --> 36:55.220]  у меня ничего не меняется, мне нужно просто
[36:55.220 --> 36:57.220]  написать r' x, plus r' p,
[36:57.220 --> 36:59.220]  plus r' g,
[36:59.220 --> 37:01.220]  минус r' x,
[37:01.220 --> 37:03.220]  минус r' p, минус r' g.
[37:03.220 --> 37:05.220]  Да, потенциал изменился ровно на такую разность.
[37:05.220 --> 37:07.220]  Штрихованные
[37:07.220 --> 37:09.220]  ранги для x, p и g,
[37:09.220 --> 37:11.220]  и обычные старые ранги для
[37:11.220 --> 37:13.220]  x, p и g, ну, с минусом.
[37:13.940 --> 37:15.940]  Вот, хорошо.
[37:15.940 --> 37:17.940]  Дальше мне нужны здесь два неравенства.
[37:17.940 --> 37:19.940]  Штрих – это новый потенциал.
[37:19.940 --> 37:21.940]  Да, да, штрих – это потенциал в новом дереве.
[37:21.940 --> 37:23.940]  Вот это всегда штрихи, все, что справа,
[37:23.940 --> 37:25.940]  это штрихи, а просто r – это старый.
[37:28.940 --> 37:30.940]  Значит, мне нужны два неравенства, что r' p больше
[37:30.940 --> 37:32.940]  равно r' x,
[37:32.940 --> 37:36.940]  и еще, что r' p меньше
[37:36.940 --> 37:38.940]  равно r' x.
[37:39.940 --> 37:41.940]  Давайте поймем оба эти неравенства.
[37:42.660 --> 37:44.660]  Во-первых, что такое r' p и r' x?
[37:44.660 --> 37:46.660]  Ну, вот это вот r' p –
[37:46.660 --> 37:48.660]  двоичный алгорифм размера
[37:48.660 --> 37:50.660]  вот этого поддерева.
[37:50.660 --> 37:52.660]  А вот это r' x – двоичный алгорифм размера этого поддерева.
[37:52.660 --> 37:54.660]  Ну, тогда извините, это очевидно.
[37:54.660 --> 37:56.660]  Да, раз p является родителем x,
[37:56.660 --> 37:58.660]  то, понятное дело, что в поддереве p-шки
[37:58.660 --> 38:00.660]  вершинок больше, чем в поддереве x.
[38:00.660 --> 38:02.660]  Поэтому это неравенство, ну, тривиально.
[38:02.660 --> 38:04.660]  Значит, то же самое с r' p,
[38:04.660 --> 38:06.660]  r' x.
[38:06.660 --> 38:08.660]  Вот это вот r' x,
[38:08.660 --> 38:10.660]  двоичный алгорифм вот этого поддерева.
[38:11.380 --> 38:13.380]  Ну, опять-таки, да?
[38:13.380 --> 38:15.380]  Раз теперь x стал родителем p,
[38:15.380 --> 38:17.380]  то, ну, здесь, соответственно,
[38:17.380 --> 38:19.380]  неравенство в другую сторону.
[38:19.380 --> 38:21.380]  Кто родитель, того ранг и больше.
[38:21.380 --> 38:23.380]  Хорошо.
[38:23.380 --> 38:25.380]  Тогда, значит, в нашем этом неравенстве
[38:25.380 --> 38:27.380]  мы можем
[38:27.380 --> 38:29.380]  оценить вот это вот сверху
[38:29.380 --> 38:31.380]  минус 2 r' x,
[38:31.380 --> 38:33.380]  как я понимаю.
[38:33.380 --> 38:35.380]  Сейчас, секунду.
[38:35.380 --> 38:37.380]  Да, то есть минус
[38:37.380 --> 38:39.380]  r' x.
[38:40.100 --> 38:42.100]  Минус r', да, да, да.
[38:42.100 --> 38:44.100]  Это будет меньше, чем минус 2 r' x.
[38:44.100 --> 38:46.100]  И r' вот
[38:46.100 --> 38:48.100]  это вот мы оценим
[38:48.100 --> 38:50.100]  тоже сверху
[38:50.100 --> 38:52.100]  двумя r' от x.
[38:54.100 --> 38:56.100]  Да, значит, в итоге у меня получится
[38:56.100 --> 38:58.100]  такое неравенство. Меньше ли бы равно?
[38:58.100 --> 39:00.100]  Меньше ли бы равно?
[39:00.100 --> 39:02.100]  Два плюс.
[39:04.100 --> 39:06.100]  Так, сейчас, на секунду.
[39:06.820 --> 39:08.820]  А, pardon.
[39:08.820 --> 39:10.820]  Мне нужно еще...
[39:10.820 --> 39:12.820]  Извините.
[39:12.820 --> 39:14.820]  Я торопился.
[39:14.820 --> 39:16.820]  Давайте пока так не будем делать.
[39:16.820 --> 39:18.820]  Давайте пока заметим, что у меня
[39:18.820 --> 39:20.820]  вот это вот
[39:22.820 --> 39:24.820]  равно вот этому.
[39:24.820 --> 39:26.820]  Вот как.
[39:26.820 --> 39:28.820]  Ну, это тоже просто.
[39:28.820 --> 39:30.820]  Что такое r' g?
[39:30.820 --> 39:32.820]  Это двоечисленный грифм всего под дерево
[39:32.820 --> 39:34.820]  до операции, а r' от x
[39:35.540 --> 39:37.540]  это двоечисленный грифм размера всего по дереву
[39:37.540 --> 39:39.540]  после операции. Ну, конечно, это одно и то же.
[39:39.540 --> 39:41.540]  Раз мы само дерево не меняем, мы не меняем
[39:41.540 --> 39:43.540]  качество вершины в нем. Значит, r' от x
[39:43.540 --> 39:45.540]  вот это вот. И r' g это одно и то же.
[39:45.540 --> 39:47.540]  Хорошо. Значит, в итоге
[39:47.540 --> 39:49.540]  мы это можем сократить. Они идут с противоположными
[39:49.540 --> 39:51.540]  знаками, и это одно и то же слагаемое. Мы это сокращаем.
[39:51.540 --> 39:53.540]  Остается два плюс.
[39:53.540 --> 39:55.540]  Дальше r' от q мы оценим через вот
[39:55.540 --> 39:57.540]  это неравенство. Будет r' от x.
[39:59.540 --> 40:01.540]  r' g оставляем.
[40:01.540 --> 40:03.540]  Ну, а здесь, как я сказал, да, у меня
[40:04.260 --> 40:06.260]  минус r' от x минус r' от p.
[40:06.260 --> 40:08.260]  Минус r' от p я оценивался сверху
[40:08.260 --> 40:10.260]  через минус два, минус r' от x. Получился
[40:10.260 --> 40:12.260]  минус 2r' от x.
[40:12.260 --> 40:14.260]  Минус 2r' от x.
[40:14.260 --> 40:16.260]  Отбавим атмосферу из 2 плюс r' от x
[40:16.260 --> 40:18.260]  плюс r' от g минус
[40:18.260 --> 40:20.260]  2r' от x. Да.
[40:20.260 --> 40:22.260]  Давайте перепишем.
[40:22.260 --> 40:24.260]  Значит, мы поняли, что аутик-зик
[40:26.260 --> 40:28.260]  меньше либо равно, чем 2 плюс
[40:28.260 --> 40:30.260]  r' от x
[40:30.260 --> 40:32.260]  плюс r' от g минус
[40:32.980 --> 40:34.980]  2r' от x.
[40:34.980 --> 40:36.980]  Так.
[40:36.980 --> 40:38.980]  Дальше, дальше, дальше.
[40:38.980 --> 40:40.980]  Докажем,
[40:40.980 --> 40:42.980]  что вот эта вот штука
[40:42.980 --> 40:44.980]  меньше либо равна
[40:44.980 --> 40:46.980]  3r' от x
[40:46.980 --> 40:48.980]  минус r' от x.
[40:48.980 --> 40:50.980]  Ну, если мы это докажем,
[40:50.980 --> 40:52.980]  то дальше продолжение очевидно,
[40:52.980 --> 40:54.980]  что эта штука не больше, а нет, нет, нет.
[40:54.980 --> 40:56.980]  Мы так не можем делать. Мы просто докажем вот
[40:56.980 --> 40:58.980]  это неравенство.
[40:58.980 --> 41:00.980]  Так, ну, чтобы доказать, это неравенство, конечно,
[41:01.700 --> 41:03.700]  мы начнем с следующей штуки.
[41:03.700 --> 41:05.700]  Переносим все налево,
[41:05.700 --> 41:07.700]  а 2 переносим направо.
[41:07.700 --> 41:09.700]  Будет вот что.
[41:09.700 --> 41:11.700]  Будет r' от g
[41:11.700 --> 41:13.700]  плюс r' от x
[41:13.700 --> 41:15.700]  минус 2r' от x.
[41:15.700 --> 41:17.700]  Меньше равно, чем минус 2.
[41:17.700 --> 41:19.700]  Вот это мы хотим доказать.
[41:19.700 --> 41:21.700]  Проверяйте за мной.
[41:21.700 --> 41:23.700]  Я раскрыл здесь скобки.
[41:23.700 --> 41:25.700]  Перенес 3r' от x сюда.
[41:25.700 --> 41:27.700]  Оно сократилось
[41:27.700 --> 41:29.700]  и стало минус 2r' от x.
[41:29.700 --> 41:31.700]  Перенес плюс 3r' от x сюда,
[41:31.700 --> 41:33.700]  стало плюс r' от x. Вроде все правильно.
[41:33.700 --> 41:35.700]  И минус 2 перенес направо.
[41:35.700 --> 41:37.700]  Я хочу доказать такое неравенство.
[41:37.700 --> 41:39.700]  Ну, давайте я его представляю
[41:39.700 --> 41:41.700]  в таком виде, что это r' от g
[41:41.700 --> 41:43.700]  минус r' от x
[41:43.700 --> 41:45.700]  плюс r' от x минус r' от x.
[41:45.700 --> 41:47.700]  Что это меньше, в общем,
[41:47.700 --> 41:49.700]  минус 2.
[41:49.700 --> 41:51.700]  Вот, а дальше
[41:51.700 --> 41:53.700]  мне нужна опять эта картинка.
[41:53.700 --> 41:55.700]  Давайте ее скопируем с прошлого слайда.
[41:55.700 --> 41:57.700]  Вот, я просто скопировал.
[41:57.700 --> 41:59.700]  Теперь смотрите, что такое r' от g
[41:59.700 --> 42:01.700]  минус r' от x.
[42:01.700 --> 42:03.700]  Значит, вот оно, r' от g.
[42:03.700 --> 42:05.700]  Вот оно, r' от x.
[42:07.700 --> 42:09.700]  Давайте тогда
[42:09.700 --> 42:11.700]  запишем, что это
[42:11.700 --> 42:13.700]  минус r' от x
[42:13.700 --> 42:15.700]  минус r' от x.
[42:15.700 --> 42:17.700]  Вот оно, r' от x.
[42:17.700 --> 42:19.700]  Вот оно, r' от x.
[42:19.700 --> 42:21.700]  Давайте тогда
[42:21.700 --> 42:23.700]  запишем, что это
[42:23.700 --> 42:25.700]  это логарифмы размеров по деревьев.
[42:25.700 --> 42:27.700]  То есть, на самом деле, вот эта вот разность
[42:27.700 --> 42:29.700]  это логарифм минус логарифм,
[42:29.700 --> 42:31.700]  то есть, по сути, логарифм отношения.
[42:31.700 --> 42:33.700]  Логарифм s' от g,
[42:33.700 --> 42:35.700]  то есть, нового размера под дерево g,
[42:35.700 --> 42:37.700]  деленное на
[42:37.700 --> 42:39.700]  размер нового под дерево x.
[42:39.700 --> 42:41.700]  Вот эта вот разность.
[42:41.700 --> 42:43.700]  Это такой логарифм.
[42:43.700 --> 42:45.700]  Значит, дальше.
[42:45.700 --> 42:47.700]  У меня r' от x минус r' от x.
[42:47.700 --> 42:49.700]  Вот это было
[42:49.700 --> 42:51.700]  старая r' от x.
[42:51.700 --> 42:53.700]  А вот это
[42:53.700 --> 42:55.700]  новая r' от x.
[42:55.700 --> 42:57.700]  Здесь будет плюс
[42:57.700 --> 42:59.700]  логарифм
[42:59.700 --> 43:01.700]  старого размера x,
[43:01.700 --> 43:03.700]  деленный на новый размер x.
[43:03.700 --> 43:05.700]  И вот это мы хотим доказать, что это не больше
[43:05.700 --> 43:07.700]  минус 2.
[43:07.700 --> 43:09.700]  Ну а здесь уже
[43:09.700 --> 43:11.700]  все просто.
[43:11.700 --> 43:13.700]  Давайте мы вот это вот
[43:13.700 --> 43:15.700]  x, вот это s' от x, расположен
[43:15.700 --> 43:17.700]  в нашем новом дереве, штрихованном.
[43:17.700 --> 43:19.700]  Вот он, s' от x. Это a, b и x.
[43:19.700 --> 43:21.700]  Значит, это s' от x,
[43:21.700 --> 43:23.700]  это s' от g.
[43:23.700 --> 43:25.700]  И смотрите, что здесь написано.
[43:25.700 --> 43:27.700]  Мы поделили какую-то часть дерева,
[43:27.700 --> 43:29.700]  ну, размер какой-то части дерева
[43:29.700 --> 43:31.700]  на всю дерево, вот это s' от x.
[43:31.700 --> 43:33.700]  Взяли логарифм. Потом прибавили
[43:33.700 --> 43:35.700]  опять логарифм, опять к какой-то
[43:35.700 --> 43:37.700]  части дерева, которая не пересекалась со старой,
[43:37.700 --> 43:39.700]  ну, то есть, вот в слоге
[43:39.700 --> 43:41.700]  s' от g. И опять поделили на все под дерево,
[43:41.700 --> 43:43.700]  на s' от x. И взяли логарифм.
[43:43.700 --> 43:45.700]  Ну, тогда, если я просто скажу,
[43:45.700 --> 43:47.700]  что давайте вот это обозначу за a,
[43:47.700 --> 43:49.700]  давайте обозначу за b,
[43:49.700 --> 43:51.700]  то есть, какая доля вершин
[43:51.700 --> 43:53.700]  лежит в s' от g,
[43:53.700 --> 43:55.700]  какая доля вершин лежит в s' от x,
[43:55.700 --> 43:57.700]  тогда понятно, что a плюс b не больше 1,
[43:57.700 --> 43:59.700]  потому что они, суммарно, они не пересекаются,
[43:59.700 --> 44:01.700]  и, суммарно, оба вложены в
[44:01.700 --> 44:03.700]  s' от x.
[44:03.700 --> 44:05.700]  То есть, вот эти два множества,
[44:05.700 --> 44:07.700]  они не пересекаются и вложены в s' от x.
[44:07.700 --> 44:09.700]  Значит, сумма отношений их
[44:09.700 --> 44:11.700]  к s' от x
[44:11.700 --> 44:13.700]  не больше 1.
[44:13.700 --> 44:15.700]  Ну, а дальше мне написано следующее,
[44:15.700 --> 44:17.700]  что это два не отрицательных числа a и b,
[44:17.700 --> 44:19.700]  сумма не больше 1.
[44:19.700 --> 44:21.700]  И я вдруг хочу доказать, что сумма
[44:21.700 --> 44:23.700]  изглочных логарифмов не больше, чем
[44:23.700 --> 44:25.700]  минус 2.
[44:25.700 --> 44:27.700]  Не больше минус 2.
[44:27.700 --> 44:29.700]  Но это уже простое упражнение,
[44:29.700 --> 44:31.700]  простое утверждение.
[44:31.700 --> 44:33.700]  Давайте мы его докажем, давайте скажем,
[44:33.700 --> 44:35.700]  что если у меня a плюс b не больше 1,
[44:35.700 --> 44:37.700]  то произведение a на b
[44:37.700 --> 44:39.700]  оно не больше, чем
[44:39.700 --> 44:41.700]  что там?
[44:41.700 --> 44:43.700]  Значит,
[44:43.700 --> 44:45.700]  1 четверть
[44:45.700 --> 44:47.700]  a плюс b в квадрате.
[44:51.700 --> 44:53.700]  Правда же?
[44:53.700 --> 44:55.700]  Так, окей, давайте я...
[44:55.700 --> 44:57.700]  То произведение будет максимально,
[44:57.700 --> 44:59.700]  когда они реагируют?
[44:59.700 --> 45:01.700]  Ну, конечно, да, конечно. То есть, тут, на самом деле,
[45:01.700 --> 45:03.700]  просто скрыто неравенство между средним арифметическим
[45:03.700 --> 45:05.700]  и средним геометрическим.
[45:05.700 --> 45:07.700]  Мы точно знаем вот такое неравенство, что корень из a b
[45:07.700 --> 45:09.700]  не больше, чем 1 вторая a плюс b.
[45:09.700 --> 45:11.700]  Дальше, если возведу в квадрат,
[45:11.700 --> 45:13.700]  будет a b не больше, чем 1 четверть a плюс b в квадрате.
[45:13.700 --> 45:15.700]  Ну, теперь, если я все про логарифм...
[45:15.700 --> 45:17.700]  Значит, это я понимаю, что это не больше,
[45:17.700 --> 45:19.700]  чем 1 четверть, раз у меня сумма ограничена
[45:19.700 --> 45:21.700]  единичкой сверху.
[45:21.700 --> 45:23.700]  Ну, а это просто... Если я все про логарифмирую,
[45:23.700 --> 45:25.700]  у меня слева получится лог a плюс лог b
[45:25.700 --> 45:27.700]  не больше минус 2,
[45:27.700 --> 45:29.700]  потому что 1 четверть это как раз логарифм
[45:29.700 --> 45:31.700]  от... Продон...
[45:31.700 --> 45:33.700]  Минус 2 это логарифм по основанию 2,
[45:33.700 --> 45:35.700]  а вот 1 четверть. Короче, отсюда нужно
[45:35.700 --> 45:37.700]  взять логарифм по основанию 2 и победить.
[45:39.700 --> 45:41.700]  Давайте раскрутим цепочку обратно.
[45:41.700 --> 45:43.700]  Значит, мы знаем вот это вот.
[45:43.700 --> 45:45.700]  Мы хотим доказать, что эта штука
[45:45.700 --> 45:47.700]  оценится сверху вот такой вещью.
[45:47.700 --> 45:49.700]  Значит, чтобы это сделать,
[45:49.700 --> 45:51.700]  мы просто перенесли все в удобные стороны,
[45:51.700 --> 45:53.700]  представили это в виде,
[45:53.700 --> 45:55.700]  что сумма логарифма в небольшом константе,
[45:55.700 --> 45:57.700]  поняли, что аргумент логарифма
[45:57.700 --> 45:59.700]  в сумме идет максимально единичку,
[45:59.700 --> 46:01.700]  но дальше доказали простое неравенство
[46:01.700 --> 46:03.700]  из теории чисел, арифметики,
[46:03.700 --> 46:05.700]  что угодно, алгебры.
[46:05.700 --> 46:07.700]  И поняли, что это верно.
[46:07.700 --> 46:09.700]  Значит, и все это исходное верно,
[46:09.700 --> 46:11.700]  и мы доказали, что время работы зиг-зига,
[46:11.700 --> 46:13.700]  давайте тоже выделю синим,
[46:13.700 --> 46:15.700]  не больше, чем утройная разность рангов
[46:15.700 --> 46:17.700]  икса.
[46:17.700 --> 46:19.700]  R' от X минус R от X.
[46:19.700 --> 46:21.700]  Вот, шикарно.
[46:21.700 --> 46:23.700]  Теперь, последнее,
[46:23.700 --> 46:25.700]  что нам надо сделать для сплоя,
[46:25.700 --> 46:27.700]  это зигзаг.
[46:27.700 --> 46:29.700]  А вот зигзаг.
[46:29.700 --> 46:31.700]  Ну, здесь тоже ничего...
[46:31.700 --> 46:33.700]  Все такое же, как было в зиг-зиге.
[46:33.700 --> 46:35.700]  Давайте эти рассуждения тоже
[46:35.700 --> 46:37.700]  начнем с продела.
[46:37.700 --> 46:39.700]  Нарисую картинку.
[46:43.700 --> 46:45.700]  После зиг-зига
[46:45.700 --> 46:47.700]  дерево будет таким.
[46:47.700 --> 46:49.700]  Я просто восстанавливаю то, что у нас было раньше.
[46:51.700 --> 46:53.700]  АВЦ.
[46:53.700 --> 46:55.700]  Так, хорошо. Значит, смотрим,
[46:55.700 --> 46:57.700]  что здесь происходит.
[46:57.700 --> 46:59.700]  Пишем учет на время работы
[46:59.700 --> 47:01.700]  зиг-зига.
[47:01.700 --> 47:03.700]  Ну, сначала мы понимаем, что нам нужно сделать два малых поворота,
[47:03.700 --> 47:05.700]  поэтому реальное время работы мы пишем, что это двойка.
[47:05.700 --> 47:07.700]  Дальше, как всегда,
[47:07.700 --> 47:09.700]  плюс R' от X,
[47:09.700 --> 47:11.700]  плюс R' от P,
[47:11.700 --> 47:13.700]  плюс R' от G,
[47:13.700 --> 47:15.700]  минус R' от X,
[47:15.700 --> 47:17.700]  минус R' от P, минус R' от G,
[47:17.700 --> 47:19.700]  потому что, как всегда, другие ранги не меняются.
[47:19.700 --> 47:21.700]  Хорошо.
[47:21.700 --> 47:23.700]  Вновь замечаем, что R' от X
[47:23.700 --> 47:25.700]  можно...
[47:25.700 --> 47:27.700]  Так, давайте я вот так легонечко
[47:27.700 --> 47:29.700]  что R' от X
[47:29.700 --> 47:31.700]  равно R' от G,
[47:31.700 --> 47:33.700]  потому что что такое R' от G?
[47:33.700 --> 47:35.700]  Это двоичный гриф вот этого размера по дереву,
[47:35.700 --> 47:37.700]  а R' от X это двоичный гриф вот этого размера по дереву.
[47:37.700 --> 47:39.700]  Суммарно, это одно и то же по дереву,
[47:39.700 --> 47:41.700]  просто как-то переставлено в дыршинке.
[47:41.700 --> 47:43.700]  Значит, двоичный гриф одинаковый,
[47:43.700 --> 47:45.700]  поэтому их можно сократить.
[47:45.700 --> 47:47.700]  Ну, а еще мне нужно одно неравенство в этом случае.
[47:47.700 --> 47:49.700]  Так.
[47:49.700 --> 47:51.700]  Да, мне нужно одно неравенство,
[47:51.700 --> 47:53.700]  что R' от P больше равно,
[47:53.700 --> 47:55.700]  чем R' от X.
[47:55.700 --> 47:57.700]  Кажется, у нас это тоже уже где-то было.
[47:57.700 --> 47:59.700]  Что такое R' от P?
[47:59.700 --> 48:01.700]  Это двоичный гриф вот этого размера.
[48:01.700 --> 48:03.700]  Понятно, что он больше равен двоичному грифу вот этого размера.
[48:03.700 --> 48:05.700]  Да, если P это родитель X в старом деле,
[48:05.700 --> 48:07.700]  то R' от P больше равно, чем R' от X.
[48:07.700 --> 48:09.700]  Это очевидно.
[48:09.700 --> 48:11.700]  Значит, тогда дальше вот это можно продолжить.
[48:11.700 --> 48:13.700]  Вот эту штуку можно продолжить.
[48:15.700 --> 48:17.700]  И оценить R' от P через R' от X
[48:17.700 --> 48:19.700]  будет 2 плюс R' от P
[48:21.700 --> 48:23.700]  плюс R' от G.
[48:25.700 --> 48:27.700]  Минус 2 R' от P.
[48:33.700 --> 48:35.700]  Минус R' от P меньше равно,
[48:35.700 --> 48:37.700]  чем минус R' от X.
[48:37.700 --> 48:39.700]  Как раз получается оценка сферы.
[48:39.700 --> 48:41.700]  И мы теперь докажем,
[48:41.700 --> 48:43.700]  что вот эта штука
[48:43.700 --> 48:45.700]  меньше равна, чем удвоенная
[48:45.700 --> 48:47.700]  R' от X
[48:47.700 --> 48:49.700]  минус R' от X.
[48:49.700 --> 48:51.700]  Ну, а если мы это доказали,
[48:51.700 --> 48:53.700]  то, конечно, это не больше, чем удвоенная R' от X
[48:53.700 --> 48:55.700]  То есть здесь нам для доказательств
[48:55.700 --> 48:57.700]  будет удобнее написать двойку,
[48:57.700 --> 48:59.700]  и там тоже будет, не раясь от того же вида,
[48:59.700 --> 49:01.700]  удобнее доказывать с двойкой,
[49:01.700 --> 49:03.700]  а потом это загрубить до тройки.
[49:03.700 --> 49:05.700]  Так, ну чтобы это доказать,
[49:05.700 --> 49:07.700]  давайте опять все перенесем,
[49:07.700 --> 49:09.700]  все R' перенесем влево.
[49:09.700 --> 49:11.700]  Кажется, что это будет оценка снизу,
[49:11.700 --> 49:13.700]  потому что ведь R' от P больше, чем R' от X.
[49:13.700 --> 49:15.700]  Типа, допустим, R' от X3, а R' от P5.
[49:15.700 --> 49:17.700]  То есть мы вычитали минус 3 было,
[49:17.700 --> 49:19.700]  стало минус 5.
[49:19.700 --> 49:21.700]  Там, по-моему, все перегащено.
[49:21.700 --> 49:23.700]  А, извините, это описка просто, да, извините.
[49:23.700 --> 49:25.700]  Спасибо, что заметили, да, это я просто описался.
[49:25.700 --> 49:27.700]  Об этом долго искали.
[49:29.700 --> 49:31.700]  Да, давайте еще раз повторю.
[49:31.700 --> 49:33.700]  Вот здесь у меня R' от P
[49:33.700 --> 49:35.700]  ограничено снизу, значит,
[49:35.700 --> 49:37.700]  минус R' от P ограничено сверху,
[49:37.700 --> 49:39.700]  минус R' от X.
[49:39.700 --> 49:41.700]  Тогда как раз минус R' от X, минус R' от X
[49:41.700 --> 49:43.700]  будет минус 2 R' от X. Да, спасибо, описался.
[49:43.700 --> 49:45.700]  Так, хорошо, значит, здесь
[49:45.700 --> 49:47.700]  давайте все перенесем,
[49:47.700 --> 49:49.700]  поймем, что сокращается,
[49:49.700 --> 49:51.700]  и, значит, как с этим работать.
[49:51.700 --> 49:53.700]  Но вот здесь будет минус 2 R' от X одинаковое,
[49:53.700 --> 49:55.700]  да, минус 2 R' от X в обеих частях мы это сокращаем.
[49:55.700 --> 49:57.700]  Остается R' от P
[49:57.700 --> 49:59.700]  плюс R' от G
[49:59.700 --> 50:01.700]  минус 2 R' от X.
[50:01.700 --> 50:03.700]  И это мы хотим сказать, что
[50:03.700 --> 50:05.700]  меньше набравно, чем минус 2.
[50:05.700 --> 50:07.700]  Правда ли это?
[50:07.700 --> 50:09.700]  Значит, если это верно, то мы доказали
[50:09.700 --> 50:11.700]  все для зигзага, для зигзага.
[50:11.700 --> 50:13.700]  Хорошо.
[50:13.700 --> 50:15.700]  Значит, я могу написать точно также, что это
[50:15.700 --> 50:17.700]  дуичный алгорифм S' от P
[50:17.700 --> 50:19.700]  делить на S' от X
[50:19.700 --> 50:21.700]  плюс двоичный алгорифм
[50:21.700 --> 50:23.700]  S' от G
[50:23.700 --> 50:25.700]  минус S' от X.
[50:25.700 --> 50:27.700]  И что это вопрос не больше минус 2.
[50:27.700 --> 50:29.700]  Здесь логика точно такая же.
[50:29.700 --> 50:31.700]  Значит, рисуем S' от P.
[50:31.700 --> 50:33.700]  Вот оно, и мы делим это
[50:33.700 --> 50:35.700]  на все S' от X.
[50:35.700 --> 50:37.700]  Рисуем S' от G, вот оно,
[50:37.700 --> 50:39.700]  и мы это делим на все S' от X.
[50:39.700 --> 50:41.700]  Тогда, вновь, если вот эти вот штучки
[50:41.700 --> 50:43.700]  обозначить за A и B,
[50:43.700 --> 50:45.700]  вот это A,
[50:45.700 --> 50:47.700]  вот это B,
[50:47.700 --> 50:49.700]  тогда видно, что A плюс B не больше, чем 1.
[50:49.700 --> 50:51.700]  Потому что мы берем два
[50:51.700 --> 50:53.700]  непересекающихся куска
[50:53.700 --> 50:55.700]  дерева, делим их на
[50:55.700 --> 50:57.700]  размер всего дерева, тогда понятна сумма этих
[50:57.700 --> 50:59.700]  долей не больше 1, потому что они не пересекались
[50:59.700 --> 51:01.700]  и были вложены в исходное дерево.
[51:01.700 --> 51:03.700]  Значит, работает то же самое. У меня есть два
[51:03.700 --> 51:05.700]  неопределительных числа с суммой не больше, чем 1.
[51:05.700 --> 51:07.700]  Значит, сумма двоичных алгорифмов
[51:07.700 --> 51:09.700]  лог 2 плюс лог 2B
[51:09.700 --> 51:11.700]  не больше минус 2.
[51:11.700 --> 51:13.700]  Ровно из тех же самых соображений,
[51:13.700 --> 51:15.700]  которые были в предыдущем пути.
[51:15.700 --> 51:17.700]  Все, мы доказали для zigzag.
[51:17.700 --> 51:19.700]  Но это еще...
[51:19.700 --> 51:21.700]  Нужно еще кое-что сделать,
[51:21.700 --> 51:23.700]  чтобы завершить все доказательства
[51:23.700 --> 51:25.700]  просплей.
[51:25.700 --> 51:27.700]  Итак, давайте наши результаты
[51:27.700 --> 51:29.700]  суммируем. Значит, здесь мы доказали
[51:29.700 --> 51:31.700]  вот это.
[51:31.700 --> 51:33.700]  И теперь я
[51:33.700 --> 51:35.700]  это все напишу в одном месте.
[51:35.700 --> 51:37.700]  Значит, что мы поняли? Мы поняли, что
[51:37.700 --> 51:39.700]  время работы операции zig
[51:39.700 --> 51:41.700]  не больше 1 плюс 3
[51:41.700 --> 51:43.700]  h' от x минус r от x.
[51:43.700 --> 51:45.700]  Дальше.
[51:45.700 --> 51:47.700]  Время работы zig-zig.
[51:47.700 --> 51:49.700]  Не больше, чем просто утройное
[51:49.700 --> 51:51.700]  h' от x минус r от x.
[51:51.700 --> 51:53.700]  А zigzag
[51:55.700 --> 51:57.700]  тоже не больше, чем утройное
[51:57.700 --> 51:59.700]  h' от x минус r от x.
[51:59.700 --> 52:01.700]  Где, я повторю, r' это ранг
[52:01.700 --> 52:03.700]  x в дереве после операции
[52:03.700 --> 52:05.700]  ну, там, соответствующей операции.
[52:05.700 --> 52:07.700]  А r от x это дерево, это ранг
[52:07.700 --> 52:09.700]  в дереве до этой операции.
[52:09.700 --> 52:11.700]  И здесь, смотрите,
[52:11.700 --> 52:13.700]  если бы мы
[52:13.700 --> 52:15.700]  не вводили отдельно zig-zig
[52:15.700 --> 52:17.700]  и zigzag, как вот меня в самом начале спрашивали,
[52:17.700 --> 52:19.700]  почему нельзя просто, конечно, zig-zig это там,
[52:19.700 --> 52:21.700]  zig и zig, а zigzag это zig и zag.
[52:21.700 --> 52:23.700]  Потому что
[52:23.700 --> 52:25.700]  у нас бы вот здесь вот везде была бы единичка
[52:25.700 --> 52:27.700]  1 плюс. То есть,
[52:27.700 --> 52:29.700]  если бы мы ограничились только вот этой штукой,
[52:29.700 --> 52:31.700]  у меня была бы плюс один везде, в каждом из действий.
[52:31.700 --> 52:33.700]  Но за счет того, что мы вот так
[52:33.700 --> 52:35.700]  хитро делаем, что если у меня
[52:35.700 --> 52:37.700]  два раза левый синт, мы делаем в таком порядке,
[52:37.700 --> 52:39.700]  то есть левый-правый в другом порядке,
[52:39.700 --> 52:41.700]  делаем поворота, у меня так хитро
[52:41.700 --> 52:43.700]  получается, что оценка более точнее,
[52:43.700 --> 52:45.700]  вот эта единичка не вылезает.
[52:45.700 --> 52:47.700]  И это нам будет очень важно.
[52:47.700 --> 52:49.700]  Итак, теперь, чему же равно время
[52:49.700 --> 52:51.700]  работы операции с плей?
[52:51.700 --> 52:53.700]  Ну, как работает с плей?
[52:53.700 --> 52:55.700]  Это несколько zig-zig и zigzag,
[52:55.700 --> 52:57.700]  и в конце максимум один zig.
[52:57.700 --> 52:59.700]  Хорошо.
[52:59.700 --> 53:01.700]  Тогда давайте скажем, что
[53:01.700 --> 53:03.700]  ну, вот там, не знаю, r0 от x
[53:03.700 --> 53:05.700]  это ранг
[53:05.700 --> 53:07.700]  это рянь R0
[53:07.700 --> 53:09.700]  до всех поворотов,
[53:09.700 --> 53:12.420]  до всех ease-gig и zigg pup.
[53:12.420 --> 53:15.380]  Р1 от x
[53:15.380 --> 53:17.380]  это ранг XA
[53:17.380 --> 53:19.380]  после первого поворота.
[53:19.380 --> 53:21.380]  То есть после первого вот phones
[53:21.380 --> 53:23.380]  процедуры поворота
[53:23.380 --> 53:25.380]  zig-zig, zig-zag и так далее.
[53:25.380 --> 53:27.380]  R2 от x
[53:27.380 --> 53:29.380]  это тоже самое, после второго поворота,
[53:29.380 --> 53:31.380]  ну и так далее, dem Rk
[53:31.380 --> 53:33.380]  после последнего поворота.
[53:33.380 --> 53:41.580]  последний. тогда смотрите, вот эти вот все ребята это либо зигзиги, либо зигзаги, а это либо зигзиг,
[53:41.580 --> 53:53.740]  а это что угодно. здесь зигзиги, или зигзаги. вот, ну тогда что такое arts.play? надо просто
[53:53.740 --> 54:00.980]  просуммировать вот эти вот все оценки на вот эти все времен, на работы учетные, и тогда получится,
[54:00.980 --> 54:09.540]  что все вот эти вот старые, все вот эти вот, кроме последнего, это утройная разность r, там 3r1 от x
[54:09.540 --> 54:22.500]  минус r0 от x, плюс 3r2 от x минус r1 от x, и так далее, вплоть до там утройного rk-1 от x минус rk-2 от x.
[54:22.500 --> 54:29.900]  ну и остается последний поворот, это либо зигзиг, либо зигзаг, либо зиг, но главное, что у них у
[54:29.900 --> 54:37.020]  всех есть сверху вот такая оценка, 1 плюс утройная разность р, здесь будет плюс 1, плюс 3rk от x,
[54:37.020 --> 54:47.220]  минус rk-1 от x. ну и как говорят классики, шлёп-шлёп, шлёп-шлёп, значит все вот эти товарищи
[54:47.220 --> 54:53.980]  сократились, и у нас остается в разности, смотрите, единица, три новых ранга, то есть три ранга
[54:53.980 --> 55:03.660]  после всего, минус три исходных ранга, минус 3r0 от x, значит получается, так давайте я вот здесь
[55:03.660 --> 55:16.700]  напишу, получается что a от splay не больше чем 1, плюс 3rk от x, минус 3r0 от x, это ровно то, что мы хотели
[55:16.700 --> 55:24.900]  доказать, что после одного сплея у нас, точнее у нас просто учетное время работы одного сплея не больше
[55:24.900 --> 55:30.260]  чем единица, плюс утройный новый ранг x, то есть после всех этих поворотов, после сплея целиком,
[55:30.260 --> 55:37.540]  минус утройный ранг x в начале, а это ровно то, что мы хотели, из этого следует, что учетное время
[55:37.540 --> 55:43.500]  работы каждого сплея это логарифм, значит просто амортизировано, каждый раз обрабатывается за от
[55:43.500 --> 55:53.400]  логарифма, на этом мы на самом деле все просто и доказали, давайте еще раз повторим, мы доказали,
[55:53.400 --> 55:59.620]  что каждый зигзиг или зигзаг мы поняли, как его учетное время работы, оценили сверху, затем
[55:59.620 --> 56:04.700]  поняли, как сплей распадается на вот такие зигзиги, зигзаги и так далее, сложили все эти оценки и
[56:04.700 --> 56:10.820]  получили вот такой оценок, что красивый оценок для a от splay, что чему аценция, которая в квадратике
[56:11.120 --> 56:19.620]  примерно равна логарифму. possible questions? Почему аценка, которая в квадратике примерно равна
[56:19.620 --> 56:24.780]  логарифму? Да, потому что, смотрите у нас что такое rank, вспоминаем, это двуечный логарифм размера
[56:24.780 --> 56:30.020]  поддерева, ну вот здесь написан логарифм размера поддерева, который, ну там на самом деле просто
[56:30.020 --> 56:37.140]  равен размеру всего дерева, но раз берет какой-то поддерева, то это не больше чем логн, значит это
[56:37.140 --> 56:45.900]  это максимум log n, здесь еще вы считаете что-то там, порядка log n, вот значит амортизационно
[56:45.900 --> 56:49.980]  каждый из плей работает за логарифм и значит мы доказали то что хотели, что раз каждый
[56:49.980 --> 56:54.900]  из плей амортизационно за логарифм, значит и наши вот эти исходные запросы insert, erase и find, раз мы их
[56:54.900 --> 56:59.780]  оценили сверху тоже с плейами, то значит и наши исходные запросы тоже исходно работают за
[56:59.780 --> 57:07.940]  учетной отлогой, а можете повторить почему важно все-таки делать display, почему это позволяет его
[57:07.940 --> 57:13.380]  оценить, только потому что мы делаем с плей, позволяет нам оценить сверху erase с плейом,
[57:13.380 --> 57:22.900]  ну и черт, ладно, вот erase, почему и выполнение его позволяет оценить сверху, нет, ну смотрите,
[57:22.900 --> 57:27.860]  здесь и есть очень простая, вот пусть мы сделали какой-то erase, там мы спустились на глубину k,
[57:28.120 --> 57:30.540]  ну сколько-то шагов прошли, соответственно время работы в пропорциональной
[57:30.540 --> 57:34.420]  глубине, пропорциональна на k, а дальше мы запускаем сплей, вот вот этот последний
[57:34.420 --> 57:38.500]  пистелин на вершинах, понятное что время работы сплея, оно пропорционально на k тоже, ну раз мы
[57:38.500 --> 57:42.580]  делаем вот эти подъёмы, вершинки на глубине k которые мы поднимаем вверх, понятное, что время
[57:42.580 --> 57:55.820]  работы тоже в пропорциональной ко
[57:55.820 --> 57:59.460]  удвоенное время сплея, то есть arrays plus splay не больше
[57:59.460 --> 58:01.300]  чем два сплея, потому что arrays работает не больше
[58:01.300 --> 58:04.580]  чем splay, а значит, суммарно, когда мы анализируем все
[58:04.580 --> 58:10.460]  операции, мы можем все insert и arrays оценить сверху соответствующими
[58:10.460 --> 58:13.060]  им сплеям, и раз каждый сплей за логарифм, то и все
[58:13.060 --> 58:18.540]  эти тоже за логарифм. Есть контакт?
[58:18.540 --> 58:22.180]  Ну окей, да. Так, в чате еще важное
[58:22.260 --> 58:24.180]  Ну, точнее, почему потенциал в конце больше начального?
[58:24.180 --> 58:29.180]  Да, потому что чтобы у нас был корректный метод потенциалов,
[58:29.180 --> 58:31.180]  нам нужно, чтобы потенциал всегда был разный, потенциал,
[58:31.180 --> 58:34.180]  чтобы была в конце минус начало, была всегда интересна.
[58:34.180 --> 58:37.180]  Ну здесь очень просто, потенциал в начале это ноль,
[58:37.180 --> 58:40.180]  потому что мы считаем, что у нас изначально есть пустое
[58:40.180 --> 58:43.180]  дерево, пустое множество, там нет ни одной вершинки,
[58:43.180 --> 58:47.180]  соответственно, нет ни одного икса, и все ранги, нет рангов,
[58:47.180 --> 58:50.180]  мы берем пустую сумму, а потом, когда мы делаем всякие запросы,
[58:50.180 --> 58:53.180]  рейзер и так далее, потом делаем сплей, то у меня потенциал
[58:53.180 --> 59:00.180]  становится не отрицательным, потенциал это сумма рангов,
[59:00.180 --> 59:02.180]  каждый ранг это логарифм чего-то, что больше на 1,
[59:02.180 --> 59:05.180]  то есть потенциал всегда не отрицательный, ну а изначально он ноль,
[59:05.180 --> 59:08.180]  то есть изначально дерево пустое, а после запросов он
[59:08.180 --> 59:15.180]  становится каким-то там, вот, хорошо.
[59:15.180 --> 59:21.180]  Тогда я считаю, что сплей мы обсудили, сплей мы обсудили,
[59:21.180 --> 59:27.180]  и я повторю, что в принципе, с точки зрения теоретической симптотики,
[59:27.180 --> 59:31.180]  здесь нет ничего лучшего, чем овельдия, но с точки зрения практики,
[59:31.180 --> 59:35.180]  вот если этот пример с товарищами, которые там часто приходят на сайт,
[59:35.180 --> 59:38.180]  их нужно быстро обслуживать, это довольно важно, что
[59:38.180 --> 59:42.180]  часто элементы будут ближе к коем, вот это такое замечательное
[59:42.180 --> 59:47.180]  свойство сплейдели. Хорошо, тогда давайте мы теперь перейдем к П-дереву,
[59:47.180 --> 59:49.180]  сколько успеем, столько успеем.
[59:49.180 --> 59:54.180]  На секундочку, вот мы с Ашками мы разобрались, что они примерно как логарифм,
[59:54.180 --> 59:59.180]  а почему само время как логарифм мы как-то там выражали, а через время вот на пол.
[59:59.180 --> 01:00:02.180]  Ну, вспоминайте, так работает метод потенциалов, да, что такое А,
[01:00:02.180 --> 01:00:08.180]  если мы ведем А как Т плюс дельта Фи, и вот это А будет там не большим логарифм,
[01:00:08.180 --> 01:00:11.180]  тогда мы просто по определению говорим, что учет на время работы
[01:00:11.180 --> 01:00:14.180]  каждой литрации это логарифм. Что это значит? Да, возможно,
[01:00:14.180 --> 01:00:17.180]  каждая конкретная Т может быть вполне большим, хоть линейной,
[01:00:17.180 --> 01:00:20.180]  но тогда это значит, что у вас потенциал сильно упадет,
[01:00:20.180 --> 01:00:24.180]  то есть если здесь примерно N, тогда здесь дельта Фи, оно там примерно
[01:00:24.180 --> 01:00:27.180]  минус N плюс лог N, чтобы Ашка была логарифмической,
[01:00:27.180 --> 01:00:31.180]  то есть если у вас долго время работы, то у вас сильно падает потенциал.
[01:00:31.180 --> 01:00:37.180]  Значит, суммарно, если вы сделали, скажем, К операций, то можно считать,
[01:00:37.180 --> 01:00:42.180]  ну, это мы доказывали, нужно обратиться к лекции про амортизационный анализ,
[01:00:42.180 --> 01:00:45.180]  там будет метод монеток и метод потенциалов, тогда можно просто считать,
[01:00:45.180 --> 01:00:47.180]  что вот эти Ашки и есть как раз амортизированное время,
[01:00:47.180 --> 01:00:51.180]  но это просто определение, что такое амортизация, что можно так перераспределить
[01:00:51.180 --> 01:00:55.180]  все время вот этих всех запросов, что суммарно как будто бы каждый логарифм.
[01:00:55.180 --> 01:00:58.180]  Да, на самом деле каждый конкретный может хоть за линию работать,
[01:00:58.180 --> 01:01:02.180]  но суммарно из-за вот этого анализа мы показываем, что суммарно они все будут
[01:01:02.180 --> 01:01:06.180]  работать за МЛГ, ну, за К, если К, то что за вопрос?
[01:01:09.180 --> 01:01:13.180]  Сейчас, а вот еще такой вопрос, вот если у нас дерево, у каждого,
[01:01:13.180 --> 01:01:18.180]  у каждого один всего сын там, ну, все влево и все вправо идет,
[01:01:18.180 --> 01:01:24.180]  у нас такое очень длинное дерево, и мы запускаемся то от самого левого элемента,
[01:01:24.180 --> 01:01:31.180]  то от самого правого паянт делаем, не будет ли тогда, ну, низлогарифм?
[01:01:34.180 --> 01:01:38.180]  Ну, на самом деле не будет, потому что, даже не знаю, если у вас так...
[01:01:44.180 --> 01:01:47.180]  Ну вот есть у вас какое-то такое дерево, например, идущее чисто влево,
[01:01:47.180 --> 01:01:51.180]  вы запустите отсюда, тогда у вас тут будут какие-то зигзиги,
[01:01:51.180 --> 01:01:54.180]  и там Х поднимется сюда, но, конечно, надо понять, как пристроится дерево,
[01:01:54.180 --> 01:01:57.180]  мне кажется, оно будет примерно таким, примерно две ветки длины паянта по полу.
[01:01:57.180 --> 01:02:01.180]  Дальше вы запускаетесь отсюда, и там эта ветка тоже за линию время
[01:02:01.180 --> 01:02:05.180]  сокращается по длине две ветки длины N на 4,
[01:02:05.180 --> 01:02:09.180]  и тогда суммарно у вас глубина будет довольно быстро станет логарифмической,
[01:02:09.180 --> 01:02:12.180]  и поэтому, как бы, то есть, да, первые операции какие-то тяжелые,
[01:02:12.180 --> 01:02:14.180]  но в среднем будет логарифм.
[01:02:14.180 --> 01:02:16.180]  Ага, понял, спасибо.
[01:02:22.180 --> 01:02:27.180]  Это единственное преимущество сплэйдерева, это даже что такое быстрое доступ.
[01:02:27.180 --> 01:02:29.180]  Ну, быстрое доступ к сплэйдереву.
[01:02:29.180 --> 01:02:35.180]  Тех того, да, да, ну, смотрите, давайте, давайте не будем ограничивать,
[01:02:35.180 --> 01:02:38.180]  что это единственное преимущество, это одно из преимуществ.
[01:02:38.180 --> 01:02:41.180]  Возможно, есть какие-то другие, просто я о них играть не знаю,
[01:02:41.180 --> 01:02:45.180]  то есть они все эти деревья используются в зависимости, собственно, от ваших задач.
[01:02:45.180 --> 01:02:48.180]  Вот если у вас такая задача, если у вас реально есть частые пользователи,
[01:02:48.180 --> 01:02:50.180]  то это прям оптимальный вариант.
[01:02:50.180 --> 01:02:54.180]  Если вам нужно еще что-то другое, да, то, возможно, как-то можно проанализировать,
[01:02:54.180 --> 01:02:56.180]  где сплэйд тоже будет, скажем, выгоднее, чем АВ.
[01:02:56.180 --> 01:02:58.180]  Почему АВ, а где АВ, выгоднее, чем сплэйд?
[01:02:58.180 --> 01:03:05.180]  Вот, да, вот ответ в чате, да, что мерш и сплэйд адекватнее для сплэя.
[01:03:05.180 --> 01:03:09.180]  То есть если вам нужно делать еще мерш и сплэйд, мы про это еще поговорим на лекциях,
[01:03:09.180 --> 01:03:11.180]  когда будем про дикартовый дерево говорить.
[01:03:11.180 --> 01:03:16.180]  Мерш и сплэйд у сплэйдерева проще, да, и там не возникает точно лог квадрата никакого.
[01:03:16.180 --> 01:03:22.180]  Наверное, если запросы ко всем элементам равновероятны, то АВ лучше, чем сплэйд.
[01:03:24.180 --> 01:03:26.180]  Ну, типа того, да.
[01:03:26.180 --> 01:03:30.180]  Ну, как бы здесь, сейчас, одну секунду.
[01:03:34.180 --> 01:03:38.180]  Да, ну, АВ может быть лучше, чем сплэйд в следующем понимании,
[01:03:38.180 --> 01:03:42.180]  что если у вас нет вот этого вот перекоса в сторону частых пользователей,
[01:03:42.180 --> 01:03:45.180]  и так, как вы предложили, действительно более-менее равновероятны все запросы,
[01:03:45.180 --> 01:03:48.180]  то есть у вас нету там ярко выраженных популярных элементов,
[01:03:48.180 --> 01:03:53.180]  тогда АВ будет лучше, потому что у АВЛ есть свойство, что глубина как сигнала рифмическая.
[01:03:53.180 --> 01:03:57.180]  Мы доказывали в прошлый раз, что глубина-то максимум от лог-логен,
[01:03:57.180 --> 01:04:03.180]  и тогда неважно какие запросы, у вас всегда время работы любой операции максимум алгорифмы.
[01:04:03.180 --> 01:04:07.180]  А в сплэйд дереве, к сожалению, у вас может быть такое, что само дерево вырождается.
[01:04:07.180 --> 01:04:10.180]  И вот ваш пример, я хочу сказать, что у вас может быть такое,
[01:04:10.180 --> 01:04:14.180]  что само дерево вырождается. И вот ваш пример, я, к сравнению, не вижу ваших имен,
[01:04:14.180 --> 01:04:18.180]  спрашивали, что делать, если дерево вот такое в бамбу превращается,
[01:04:18.180 --> 01:04:20.180]  просто сын-сын-сын влево-влево-влево.
[01:04:20.180 --> 01:04:24.180]  Такое может быть в сплэйд дереве, и тогда, когда вы запуститесь вот отсюда,
[01:04:24.180 --> 01:04:28.180]  у вас на одну конкретную операцию уйдет линейное время.
[01:04:28.180 --> 01:04:34.180]  Да, такое будет происходить редко, но здесь зависит от того, что вам нужно.
[01:04:34.180 --> 01:04:39.180]  Если вам нужно быстро обслуживать частых клиентов, и вам пофиг на редких клиентов,
[01:04:39.180 --> 01:04:44.180]  если вам нужно, чтобы вы всегда обрабатывали всех не больше, чем за логарифом,
[01:04:44.180 --> 01:04:47.180]  то ваш вариант овэй. Вот, собственно, и все.
[01:04:47.180 --> 01:04:51.180]  То есть если вам нужно, чтобы любой запрос был не больше, чем сколько-то,
[01:04:51.180 --> 01:04:55.180]  то овэй. Если вам на какие-то запросы пофиг, и вы их можете обрабатывать долго, то сплэй.
[01:04:55.180 --> 01:04:57.180]  Вот и все.
[01:04:57.180 --> 01:04:58.180]  Овэй на такой стабильник.
[01:04:58.180 --> 01:05:00.180]  Да, именно так.
[01:05:02.180 --> 01:05:05.180]  Так, ну хорошо, значит, Б-дерево все-таки мы переходим к нему.
[01:05:06.180 --> 01:05:10.180]  Тоже у него есть свои преимущества, я про все это расскажу.
[01:05:10.180 --> 01:05:17.180]  Значит, давайте мы теперь предположим, что в каждой вершине мы можем хранить не один ключ, а несколько.
[01:05:17.180 --> 01:05:24.180]  И вот давайте скажем, что в вершине, в узле, теперь я буду здесь перемешивать понятие вершины и узел,
[01:05:24.180 --> 01:05:26.180]  это одно и то же будет у нас.
[01:05:26.180 --> 01:05:29.180]  В узле мы будем хранить много ключей.
[01:05:29.180 --> 01:05:33.180]  Ключ К1, К2 и так далее КС.
[01:05:33.180 --> 01:05:39.180]  Причем эти ключи будут упоряточены. К1 меньше, чем К2, меньше, чем и так далее, меньше, чем КС.
[01:05:39.180 --> 01:05:42.180]  И из этого узла будет много стрелок в детей.
[01:05:42.180 --> 01:05:50.180]  Будет стрелка левее, чем К1, будет стрелка между К1 и К2, будет стрелка между К2 и К3 и так далее.
[01:05:50.180 --> 01:05:55.180]  Все вот такие стрелки между всеми интервалами, между ключами, а также с левой и справа.
[01:05:55.180 --> 01:06:01.180]  И смысл такой. Все элементы, лежащие левее вот этого вот левого элемента,
[01:06:01.180 --> 01:06:11.180]  должны иметь ключ меньше, чем k1. Дальше все лежащие вот в этом вот между k1 и k2 должны иметь значение в интервале от k1 до k2.
[01:06:11.180 --> 01:06:22.180]  Все лежащие вот в этом подделе обязаны иметь ключи от k2 до k3, ну и так далее. В последнем вот этом дереве все ключи имеют, ну все ключи только больше, чем ks.
[01:06:22.180 --> 01:06:29.180]  То есть это такое обобщение по сути двоичного дерева поиска. Мы здесь уже отказываемся от двоичности, у меня бывает много детей у каждой вершинки.
[01:06:29.180 --> 01:06:35.180]  Также и ключей в каждой вершинке много, но зато у меня вот такое более полное подразбиение, что ли.
[01:06:35.180 --> 01:06:46.180]  То есть раньше я просто по одному x сверял, куда нужно идти влево или вправо. А теперь как бы я вот если, если честно, буду нарисовать, то я поставил на ней s засечек.
[01:06:46.180 --> 01:06:55.180]  И если мне нужно идти к какой-то x, я понимаю между какими двумя засечками этот x лежит, скажем вот между k1 и k2, когда это означает, что я должен пуститься вот сюда.
[01:06:55.180 --> 01:06:59.180]  То есть оно такое, у меня дерево гораздо более ветвистое, гораздо больше детей у каждой вершинки.
[01:06:59.180 --> 01:07:04.180]  И это в частности позволяет мне спускаться, ну как бы у меня вот меньше операции спуска на самом деле,
[01:07:04.180 --> 01:07:14.180]  потому что если я в каждой вершинке более подробно подраздыл мою бесчастную прямую, тогда у меня как бы меньше будет операции спуска, меньше глубина дерева.
[01:07:14.180 --> 01:07:21.180]  Вот, значит идея такая, в каждой вершинке у нас будет много ключей.
[01:07:21.180 --> 01:07:28.180]  И давайте тогда определим, что такое, что такое b дерево, значит определение b дерево.
[01:07:28.180 --> 01:07:35.180]  Это дерево поиска в том смысле, как было на прошлом слайде. Дерево поиска.
[01:07:35.180 --> 01:07:42.180]  Так, давайте еще b дерево будет с параметром t.
[01:07:42.180 --> 01:07:45.180]  А у нас там ключи это предназначение, да?
[01:07:45.180 --> 01:07:52.180]  Да, ну это какие-то числа просто. Можно пользоваться бинпоиском, можно просто пройтись по массиву и даже без бинпоиска это делать.
[01:07:52.180 --> 01:07:58.180]  Там все равно будет t не очень большое, чтобы его оптимизировать до бинпоиска, там t будет примерно 100 или 1000.
[01:07:58.180 --> 01:08:04.180]  В принципе не сильно страшно, если вы вместо бинпоиска будете просто проходить по всему массиву и искать там точку.
[01:08:04.180 --> 01:08:10.180]  Потому что у нас все равно будет гораздо более сложная операция, и можно без бинпоиска делать просто линейный проход.
[01:08:10.180 --> 01:08:15.180]  Итак, b дерево с параметром t. Это дерево поиска в том смысле, как было на прошлом слайде.
[01:08:15.180 --> 01:08:19.180]  Что у каждой вышки может быть много детей, но они вот так подразбивают, что слева все меньше.
[01:08:19.180 --> 01:08:24.180]  Дальше по интервалам разбивается вся вещастная примарка.
[01:08:24.180 --> 01:08:35.180]  И выполняется еще дополнительно следующее свойство, что в любой некорневой вершине
[01:08:35.180 --> 01:08:45.180]  количество ключей в количестве этих кашек лежит в отрезке от t-1 до 2t-1.
[01:08:45.180 --> 01:08:50.180]  Ну где t, t вот какой-то параметр целочисленных хотя бы двоих.
[01:08:50.180 --> 01:08:57.180]  То есть в каждом некорне, в каждой вершине, которая является некорним, у меня количество ключей от t-1 до 2t.
[01:08:57.180 --> 01:09:11.180]  Это первое условие. Второе условие в корне, количество ключей лежит в отрезке от 1 до 2t-1.
[01:09:11.180 --> 01:09:17.180]  То есть 2t-1 у меня ограничений остается, но теперь в корне может быть меньше, чем t-1 ключ, может быть просто 1 ключ.
[01:09:17.180 --> 01:09:20.180]  От 1 до 2t-1 в любое число.
[01:09:20.180 --> 01:09:30.180]  И наконец третье условие, это что все листья на одной глубине.
[01:09:30.180 --> 01:09:37.180]  Здесь опять можно задать вопрос, почему так, почему t-1, t-2, t-1, почему в корне отдельно.
[01:09:37.180 --> 01:09:46.180]  Я предлагаю сильно над этими думать, давайте просто из книжки возьмем такие свойства и поймем, что это дерево умеет
[01:09:46.180 --> 01:09:49.180]  за логарифм, отвечает на запросы и обладает хорошими искусствами.
[01:09:49.180 --> 01:09:52.180]  То есть не задумываясь о том, как это получено, почему именно так.
[01:09:52.180 --> 01:09:57.180]  Листья совсем на одной глубине или не более какой-то глубины?
[01:09:57.180 --> 01:09:58.180]  Еще раз.
[01:09:58.180 --> 01:10:01.180]  Листья совсем на одной глубине или не более одной глубины?
[01:10:01.180 --> 01:10:09.180]  Нет, нет, все на одной. То есть вот есть у вас корень какой-то, есть у него там несколько сыновей, есть у них там дети.
[01:10:09.180 --> 01:10:14.180]  Ну и значит там, если вот это листья, то они все на одной глубине, то есть вот прям все на фиксированной глубине, на одной и той же.
[01:10:14.180 --> 01:10:19.180]  То есть при необходимости мы где-то можем линию дотянуть, лишь бы была нужна глубина.
[01:10:19.180 --> 01:10:21.180]  Что значит линию дотянуть?
[01:10:21.180 --> 01:10:31.180]  Ну то есть если у нас, допустим, не совсем равномерное, то есть в ВВЛ дереве, например, разрешено отличие на один, а тут прям вот совсем.
[01:10:31.180 --> 01:10:35.180]  Да, тут не будет отличия, тут прям фиксировано, с левой и с правой будет одинаково всегда.
[01:10:35.180 --> 01:10:38.180]  Да, более жестко.
[01:10:38.180 --> 01:10:41.180]  Получается дети Б дерева тоже Б деревни?
[01:10:42.180 --> 01:10:50.180]  В частности, да. Ну то есть если у вас есть большое дерево, и вы берете его любую под дерево, то тоже Б дерево, да, это правда.
[01:10:50.180 --> 01:10:54.180]  А в первом пункте, не гарневая вершина, имеется в виду не самая верхняя?
[01:10:54.180 --> 01:10:56.180]  Да, ну любая, кроме самой верхней.
[01:10:56.180 --> 01:10:59.180]  Так точно будет?
[01:10:59.180 --> 01:11:00.180]  Что?
[01:11:00.180 --> 01:11:02.180]  Да, да, да, действительно.
[01:11:02.180 --> 01:11:08.180]  Хорошо. Вот, значит такие странные условия, которые откуда-то нам взялись с неба.
[01:11:08.180 --> 01:11:17.180]  Давайте докажем, что если дерево обладает такими свойствами, то у него глубина примерно логерифм N по основанию T.
[01:11:17.180 --> 01:11:30.180]  Значит, простое утверждение, что если в Б дереве N ключей, если в нем N значение лежит, то его глубина...
[01:11:30.180 --> 01:11:34.180]  А мы предполагаем, что T сильно меньше, чем N, да?
[01:11:34.180 --> 01:11:43.180]  Да, да, да. Мы предполагаем, что T это какая-то константа в районе 100 или 1000, а N может быть очень-очень большим, там сотни тысяч, миллионы и даже миллиарды.
[01:11:43.180 --> 01:11:49.180]  То есть брать T в 10 в шестой, потом получать единиц не выйдет?
[01:11:49.180 --> 01:11:55.180]  Ну 10 стоит, да, все-таки слишком много. Обычно вот, как я сказал, в районе тысячи. Обычно T в районе тысячи.
[01:11:58.180 --> 01:12:03.180]  Да, то есть это скорее константа, чем параметра от N.
[01:12:04.180 --> 01:12:13.180]  Вот, значит, утверждение, что если в Б дереве N ключей, то глубина этого дерева ограничена сверху логерифмом T этой степени от N.
[01:12:13.180 --> 01:12:22.180]  Ну и соответственно, чем больше T, тем у меня меньше глубина. Чем больше T, тем больше основание логерифма, значит, тем меньше само значение логерифма, тем меньше глубина.
[01:12:22.180 --> 01:12:46.180]  Начну доказательства. Пусть B дерево имеет глубину H, какое в нем может быть минимальное число ключей.
[01:12:46.180 --> 01:12:55.180]  Тут я, к сожалению, возможно, буду иногда оговариваться, потому что раньше всегда у меня, когда было двоичное дерево, у меня ключ и вершина была одно и то же.
[01:12:55.180 --> 01:13:00.180]  В каждой вершине ровно один ключ, ровно одно число. Ну и наоборот, каждый ключ стоит в какой-то вершине.
[01:13:00.180 --> 01:13:11.180]  А здесь наоборот, у меня каждый вершин – это много ключей. И вот тут важно, что N – это ключи, а не вершин, потому что в вершине может быть аж T ключей, поэтому вершин примерно в T раз меньше, чем ключей.
[01:13:11.180 --> 01:13:16.180]  Вот мы считаем именно ключей. Вопрос, какое может быть минимальное число ключей, вершина ключей.
[01:13:16.180 --> 01:13:25.180]  Ну, чтобы было минимальное количество, прификсированное глубине, понятно, что мне нужно в каждом момент времени иметь как можно меньше ключей в каждой вершине.
[01:13:25.180 --> 01:13:35.180]  Значит, я в корне говорю, что всего один ключ. Дальше у корня, получается, есть два ребенка, в каждом из которых минимально возможное количество ключей – это T-1, T-1 ключ в каждом из них.
[01:13:35.180 --> 01:13:40.180]  А какое числоוא quiz That is possible? Это минимально возможно или максимально возможно, или вообще все случаи?
[01:13:40.180 --> 01:13:49.180]  Это минимальное число. Какое может быть минимальное число вершин в этом деле?
[01:13:49.180 --> 01:13:58.180]  Ну, как раз, зак suffering. Такойinen и falling times even, roles often happen often.
[01:13:58.180 --> 01:14:00.180]  минимально возможным числом че, и так далее.
[01:14:00.180 --> 01:14:04.180]  Значит, если у меня в детях по t-1 ключу, то, соответственно, из них выходит по t-стрелок.
[01:14:04.180 --> 01:14:08.180]  Значит, здесь t-стрелок, и здесь тоже t-стрелок.
[01:14:08.180 --> 01:14:13.180]  Потому что если t-1 ключ, то промежутка между ними ровно t.
[01:14:13.180 --> 01:14:17.180]  Здесь тоже t-стрелок. Получается, здесь тоже находятся какие-то дети.
[01:14:17.180 --> 01:14:22.180]  В каждом из них по t-стрелок, и из каждого из них выходит по t-стрелок.
[01:14:22.180 --> 01:14:26.180]  Ну, раз мы хотим минимально возможное число вершин, значит, я в каждой вершине располагаю
[01:14:26.180 --> 01:14:33.180]  внимание, что ключей, то я в каждой вершине располагаю t-1 ключ, минимум возможный,
[01:14:33.180 --> 01:14:37.180]  и, соответственно, дальше вниз t-стрелок.
[01:14:37.180 --> 01:14:40.180]  Ну и так все это до глубины h.
[01:14:40.180 --> 01:14:43.180]  Хорошо, давайте тогда посчитаем, сколько у нас получается вершин.
[01:14:43.180 --> 01:14:48.180]  Значит, здесь одна вершина на этом уровне, один ключ, один ключ от корня.
[01:14:48.180 --> 01:14:55.180]  Дальше здесь 2 на t-1 ключей, 2 на t-1, потому что две вершины в каждой вершине по t-1 ключ.
[01:14:55.180 --> 01:14:57.180]  Дальше сколько у меня ключей вот здесь?
[01:14:57.180 --> 01:15:00.180]  Ну, смотрите, число вершин, это, видимо, 2t.
[01:15:00.180 --> 01:15:05.180]  Потому что на прошлом уровне было две вершины, каждая из них породила t новых детей,
[01:15:05.180 --> 01:15:07.180]  и в каждом ребенке по t-1 ключу.
[01:15:07.180 --> 01:15:10.180]  Поэтому вот это количество ключей на вот этом вот третьем уровне.
[01:15:10.180 --> 01:15:13.180]  Ну, дальше, соответственно, будет 2t квадрат на t-1,
[01:15:13.180 --> 01:15:16.180]  потому что если здесь было 2t вершин,
[01:15:16.180 --> 01:15:20.180]  потом каждая из них порождает еще по t сыновей, значит будет 2t квадрат вершин.
[01:15:20.180 --> 01:15:22.180]  И в каждой из них будет по t-1 ключу.
[01:15:23.180 --> 01:15:28.180]  Ну и так далее. Последнее будет, видимо, 2t в степени h-1 на t-1.
[01:15:28.180 --> 01:15:35.180]  Так, в итоге сумма равна 1 плюс 2 на t-1,
[01:15:38.180 --> 01:15:41.180]  плюс 2t на t-1, плюс и так далее.
[01:15:41.180 --> 01:15:46.180]  Ну, короче, здесь будет геометрическая прогрессия t h-1 t-1.
[01:15:47.180 --> 01:15:52.180]  Что я хочу? Я хочу, видимо, вынести за скобку,
[01:15:52.180 --> 01:15:57.180]  ну, я ставлю единица, я напишу 2t-1, вынесу за скобку,
[01:15:57.180 --> 01:16:03.180]  и в скобках останется 1 плюс t плюс t в квадрате,
[01:16:03.180 --> 01:16:06.180]  плюс так далее, плюс t в степени h-1.
[01:16:06.180 --> 01:16:11.180]  Так? То есть я вынес, я оставил ничку, я вынес за скобку 2t-1,
[01:16:11.180 --> 01:16:13.180]  в скобке осталась сумма степеней t.
[01:16:13.180 --> 01:16:16.180]  1t t в степени h-1.
[01:16:20.180 --> 01:16:23.180]  Едем дальше. Значит, давайте сумму перепишу здесь.
[01:16:27.180 --> 01:16:30.180]  Сейчас мне нужна будет сумма геометрической прогрессии,
[01:16:30.180 --> 01:16:32.180]  чтобы эту форму упростить.
[01:16:32.180 --> 01:16:37.180]  Ну, это что такое? Это t в степени h-1 делит на t-1.
[01:16:37.180 --> 01:16:40.180]  Ну, это просто сумма геометрической прогрессии.
[01:16:40.180 --> 01:16:43.180]  Значит, t-1 чудесным образом сократилась,
[01:16:43.180 --> 01:16:48.180]  и получается, что сумма – это 1 плюс удвоенное t в степени h-1.
[01:16:48.180 --> 01:16:53.180]  И это, смотрите, это минимально возможное число вершин в дереве глубины h.
[01:16:53.180 --> 01:17:00.180]  Ну, значит, если в дереве глубины h n ключей, извините, это минимально возможное число ключей.
[01:17:00.180 --> 01:17:04.180]  Минимально, я опять уговорился, минимально возможное, извините, пожалуйста,
[01:17:04.180 --> 01:17:08.180]  ничего не могу сделать, минимально возможное количество ключей.
[01:17:08.180 --> 01:17:14.180]  Но если в дереве глубины h, если мы предполагаем, что в дереве с n ключами глубина h,
[01:17:14.180 --> 01:17:17.180]  то тогда получается, что эта штука меньше равна, чем n.
[01:17:17.180 --> 01:17:22.180]  То есть это минимально возможное, а это какой-то конкретный, что в нем n ключей.
[01:17:22.180 --> 01:17:26.180]  Тогда, выполняясь такого неравенства, давайте что-нибудь здесь перенесем.
[01:17:29.180 --> 01:17:31.180]  Потом еще единичку перенесем.
[01:17:32.180 --> 01:17:38.180]  И получается, что h не больше, чем логарифм по основанию t от n плюс 1 пополам.
[01:17:38.180 --> 01:17:47.180]  То есть, если в дереве n ключей, то глубина этого дерева не больше, чем логарифм по основанию t от n плюс 1 пополам.
[01:17:47.180 --> 01:17:51.180]  Что и требовалось. Да, нужно было показать, что глубина ограничена сверху.
[01:17:51.180 --> 01:17:54.180]  О от логарифм по основанию t от n.
[01:17:54.180 --> 01:17:59.180]  Ну здесь как раз пополам поделилось с точки зрения асимптотики.
[01:17:59.180 --> 01:18:03.180]  Основная часть это как раз лог t от n.
[01:18:04.180 --> 01:18:06.180]  Все, доказали.
[01:18:08.180 --> 01:18:09.180]  Доказали.
[01:18:11.180 --> 01:18:16.180]  Так, ну хорошо. Давайте тогда я скажу, зачем это может быть нужно.
[01:18:16.180 --> 01:18:19.180]  Мы поймем, как работает find и на этом закончим.
[01:18:19.180 --> 01:18:21.180]  Значит, зачем нужно?
[01:18:22.180 --> 01:18:24.180]  Зачем это дерево?
[01:18:26.180 --> 01:18:29.180]  А вот зачем. Чтобы хранить очень большие базы данных.
[01:18:30.180 --> 01:18:36.180]  Чтобы хранить очень большие.
[01:18:36.180 --> 01:18:41.180]  Ну я напишу базы данных, но имеется в виду просто любые большие хранические информации.
[01:18:42.180 --> 01:18:44.180]  Любые большие деревья.
[01:18:45.180 --> 01:18:50.180]  Значит, такие большие, что само дерево не может уместиться в вашу оперативную память.
[01:18:51.180 --> 01:18:54.180]  То есть вы не можете с ним работать очень быстро.
[01:18:54.180 --> 01:18:58.180]  И лучше, что вы можете сказать, то, что дерево располагается у вас где-то на жестком диске.
[01:18:58.180 --> 01:19:05.180]  Либо вы вставляете флешку и там какая-то база данных, не знаю, какого-нибудь всего мира.
[01:19:05.180 --> 01:19:08.180]  Сколько, чего, какой человек купил.
[01:19:08.180 --> 01:19:10.180]  Ставили на флешке и вот с этим работаете в оперативку.
[01:19:10.180 --> 01:19:12.180]  Вы это не можете подгрузить, там слишком много информации.
[01:19:12.180 --> 01:19:16.180]  Либо это просто информация из жесткого диска, тоже какая-нибудь там большая база данных,
[01:19:16.180 --> 01:19:19.180]  которая вы себе в оперативную память не подгрузится никак.
[01:19:19.180 --> 01:19:21.180]  Там нет слишком много данных.
[01:19:22.180 --> 01:19:25.180]  Тогда будет работать все примерно следующим образом.
[01:19:25.180 --> 01:19:29.180]  Вы можете встать в данное место диска.
[01:19:29.180 --> 01:19:31.180]  Ну, ваще всего у вас все на жестком диске.
[01:19:31.180 --> 01:19:34.180]  Вы встали в данное место диска, которое соответствует какой-то вершинке.
[01:19:34.180 --> 01:19:37.180]  Это вот вершина вашего дерева.
[01:19:37.180 --> 01:19:38.180]  Вершина Б дерева.
[01:19:38.180 --> 01:19:41.180]  И вот здесь ключей в этой вершинке, в принципе, немного.
[01:19:41.180 --> 01:19:42.180]  Их здесь Т.
[01:19:42.180 --> 01:19:45.180]  Эти ключи вы можете подгрузить себе в оперативку.
[01:19:45.180 --> 01:19:47.180]  Значит, подгружаем, подгружаем.
[01:19:49.180 --> 01:19:51.180]  В оперативную память.
[01:19:52.180 --> 01:19:53.180]  Дальше.
[01:19:53.180 --> 01:19:58.180]  Если нам нужно сделать find X, то мы находим, где в этом массиве должен располагаться X.
[01:19:58.180 --> 01:20:01.180]  То есть, если тут K1, K2 и так далее.
[01:20:03.180 --> 01:20:04.180]  Ks.
[01:20:04.180 --> 01:20:06.180]  Где S там от T до 2T примерно.
[01:20:06.180 --> 01:20:08.180]  То мы или бинпоиском, или чем угодно.
[01:20:08.180 --> 01:20:10.180]  Или просто линиями проходом.
[01:20:10.180 --> 01:20:14.180]  Понимаем, между какими двумя ключами, соседними, должен располагаться тот X, который вы ищете.
[01:20:14.180 --> 01:20:17.180]  Ну, соответственно, мы понимаем, куда нужно перейти.
[01:20:17.180 --> 01:20:22.180]  Мы понимаем, какой переход к какому следующему узлу нужно сделать в поисках X.
[01:20:23.180 --> 01:20:24.180]  Вот это мы поняли.
[01:20:24.180 --> 01:20:25.180]  Но дальше смотрите.
[01:20:25.180 --> 01:20:28.180]  У нас вот отсюда стоит какая-то стрелка, которая указывает на какую-то другую вершину.
[01:20:28.180 --> 01:20:38.180]  И, в принципе, если у меня эта база данных огромная, то положение вот этой новой вершинки, следующей вершины, оно может быть довольно далекое.
[01:20:38.180 --> 01:20:45.180]  Соответственно, там просто даже чтобы вам взять головку, которая указывает на нужную позицию в области памяти, на жестком диске,
[01:20:45.180 --> 01:20:49.180]  вам нужно ее поднять, переместить очень-очень далеко и опустить.
[01:20:49.180 --> 01:20:55.180]  Если у вас большая база данных, то у вас могут быть всякие разные ссылки на очень далекие вершинки.
[01:20:55.180 --> 01:20:58.180]  Ну, просто физически далекие, для которых нужно далеко двигаться.
[01:20:58.180 --> 01:21:01.180]  Вот вам нужно так взять и оттуда подвинуться.
[01:21:01.180 --> 01:21:06.180]  Ну и, соответственно, самое тяжелое здесь – это как раз получаются вот эти переходы.
[01:21:06.180 --> 01:21:11.180]  То есть подгрузить T-элементов, прочитать T-элементов, найти, где тут X – это все просто.
[01:21:11.180 --> 01:21:12.180]  Это делается за от T.
[01:21:12.180 --> 01:21:21.180]  А дальше вам нужно взять и передвинуть указатель, то есть прочитать какую-то новую область памяти на жестком диске,
[01:21:21.180 --> 01:21:24.180]  чтобы ее прочитать, чтобы дадут дойти.
[01:21:24.180 --> 01:21:27.180]  Вот это довольно дорогая операция.
[01:21:27.180 --> 01:21:32.180]  То есть да, конечно, если у вас все в оперативке, то это фигня.
[01:21:32.180 --> 01:21:38.180]  Вы можете в любое место тыкаться довольно быстро, считать, что это дешево.
[01:21:38.180 --> 01:21:41.180]  А если у вас все это на жестком диске, то это может быть довольно долго.
[01:21:41.180 --> 01:21:44.180]  Поэтому эта операция дорога, и нам хочется ее минимизировать.
[01:21:44.180 --> 01:21:47.180]  Нам хочется минимизировать количество раз, в которые я это делаю,
[01:21:47.180 --> 01:21:51.180]  когда я перемещаюсь к какой-нибудь другой вершинке, когда спускаюсь в дерево.
[01:21:51.180 --> 01:21:56.180]  Но поэтому логично, что нужно сделать дерево таким более ветвистым и менее глубоким.
[01:21:56.180 --> 01:22:00.180]  То есть в каждой вершинке расположить больше ключей, и при этом глубина уменьшится.
[01:22:00.180 --> 01:22:03.180]  То есть да, у вас увеличится время обработки каждой вершинки.
[01:22:03.180 --> 01:22:07.180]  Она будет обработаться за от T, чтобы понять, где там находится X.
[01:22:08.180 --> 01:22:11.180]  Но все равно здесь самое сложное – это подгрузить в память.
[01:22:11.180 --> 01:22:15.180]  Если у вас есть область данных, вам нужно сначала это все прочитать,
[01:22:15.180 --> 01:22:19.180]  подгрузить себе в память и только потом делать бинпоиск, если хотите.
[01:22:19.180 --> 01:22:21.180]  Но именно поэтому здесь бинпоиск даже не нужен.
[01:22:21.180 --> 01:22:25.180]  Вы можете просто линейно пройтись, раз вы все равно это все считываете.
[01:22:25.180 --> 01:22:28.180]  Можете линейно пройтись и понять, где там должен быть X.
[01:22:28.180 --> 01:22:34.180]  И соответственно за от T вы обработали вершинку, и дальше понимаете, куда нужно перейти.
[01:22:34.180 --> 01:22:38.180]  Ну это как раз переход довольно дорогой, и вам таких переходов хочется как можно меньше.
[01:22:38.180 --> 01:22:42.180]  Ну и давайте тогда T сделаем достаточно большим, чтобы таких переходов было поменьше.
[01:22:53.180 --> 01:22:57.180]  Я имел в виду, что пятиэтажки обычно длинные, невысокие.
[01:22:58.180 --> 01:23:04.180]  Ну то есть это похоже на отличие этого дерева.
[01:23:04.180 --> 01:23:10.180]  А, да, да, да, я понял, типа вот это вот это B дерево, когда у вас мало этажей, но много подъездов.
[01:23:10.180 --> 01:23:14.180]  А вот это A-V-L дерево, когда там два подъезда, но много этажей.
[01:23:14.180 --> 01:23:16.180]  Я так понял.
[01:23:16.180 --> 01:23:22.180]  Так, вопрос про такие баз данных не на SSD, не на SSD.
[01:23:23.180 --> 01:23:33.180]  Слушайте, ладно, я не эксперт по русским дискам SSD, но вот идея такая, что нам нужно такая просто мысль,
[01:23:33.180 --> 01:23:40.180]  что вот если нам тяжело переключаться между разными областями памяти, то вот хочется их минимизировать.
[01:23:44.180 --> 01:23:48.180]  А в контесте будут задачи, где данных там 256 гигабайт?
[01:23:48.180 --> 01:23:50.180]  Нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, нет, ход просто такого не умеет.
[01:23:50.180 --> 01:23:53.180]  Нет, можно будет просто за бонус мне баллы написать B дерево.
[01:23:53.180 --> 01:23:57.180]  То есть, конечно, для наших таких учебных задач такого не будет.
[01:23:57.180 --> 01:24:00.180]  То есть там можно писать XA, XB, XC, что угодно.
[01:24:00.180 --> 01:24:05.180]  Надо будет построить дерево на всех данных серверов VK.
[01:24:07.180 --> 01:24:10.180]  Ну, если хотите, построите и поставим вам бонус.
[01:24:12.180 --> 01:24:17.180]  Смотрите, мы хотим, чтобы переходов было поменьше, чтобы спусков по стрелочкам было поменьше, вот это будет LOCK-T.
[01:24:17.180 --> 01:24:21.740]  блок t. Каждая вершинка обрабатывается за o от t, потому что нужно подгрузить блок памяти,
[01:24:21.740 --> 01:24:26.980]  но соответственно find мы поняли как делать. Мы встали в корень, нашли между какими-то
[01:24:26.980 --> 01:24:31.380]  двумя элементами располагается наш x, спустились, причитали новую вершинку. Опять там нашли,
[01:24:31.380 --> 01:24:38.020]  спустились и так далее и так далее. Нашли до листа, если там есть x, то мы победили, иначе x
[01:24:38.020 --> 01:24:44.860]  нигде нет. Вот, ну тогда все, на этом спасибо за внимание, до следующего раза продолжим пробовать
[01:24:44.860 --> 01:24:53.220]  дерево. Дальше вы расскажете, что, ну как там сохраняется инвариант? Да, конечно, конечно.
