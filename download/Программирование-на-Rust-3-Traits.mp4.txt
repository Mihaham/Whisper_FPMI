[00:00.000 --> 00:12.000]  К сожалению, у нас сегодня нет на лекции никаких девочек, поэтому некого поздравить с Международным женским днём.
[00:12.000 --> 00:18.000]  Поздравляем тех, кто в записи, если такие будут смотреть девочки.
[00:18.000 --> 00:26.000]  На этой лекции мы посмотрим на трейты и посмотрим на такую штуку, как называется интервью ментабилити.
[00:26.000 --> 00:32.000]  Мы это успеем сделать, потому что слайдов у нас на этот раз достаточно много.
[00:32.000 --> 00:39.000]  Собственно, план такой. Сначала посмотрим на трейты, потом посмотрим на такую штуку, как Exotically Sized Types.
[00:39.000 --> 00:47.000]  В Rust'е дело в том, что некоторые объекты могут быть unsized, то есть мы на этапе компиляции не знаем их размера.
[00:47.000 --> 00:53.000]  Поэтому у нас для этого есть специальный трейт, и мы с ним разберёмся.
[00:53.000 --> 00:59.000]  У нас есть некоторый набор трейтов стандартной библиотеки, о которой мы рассмотрим также.
[00:59.000 --> 01:07.000]  Они необходимы для того, чтобы, например, перегружать операторы или какие-то фундаментальные вещи в языке менять.
[01:07.000 --> 01:14.000]  Сравнимся с тем, что у нас есть в плюсах, ну и потом поговорим про интервью ментабилити.
[01:15.000 --> 01:19.000]  Такс.
[01:19.000 --> 01:24.000]  Трейты это что-то вроде интерфейса в других языках.
[01:24.000 --> 01:30.000]  Это не совсем правда, но давайте пока что в первом приближении, пока мы не узнали всё о трейтах, будем считать, что это вроде интерфейса.
[01:30.000 --> 01:36.000]  Смотрите, я объявляю такой трейт. Я назвал его Animal.
[01:36.000 --> 01:41.000]  Обратите внимание, что я не написал ключевого слова перед функциями Pub.
[01:41.000 --> 01:51.000]  Потому что по умолчанию публичность функций, которые трейт им даёт, она зависит от того, публичен ли сам трейт.
[01:51.000 --> 01:56.000]  То есть, если у вас трейт публичен, то у вас все его функции публичны.
[01:56.000 --> 01:58.000]  Вот.
[01:58.000 --> 02:07.000]  Ну вот, я сделал такие два метода, Name и Noise, которые принимают на вход Self и возвращают стринг.
[02:07.000 --> 02:09.000]  Какого типа Self, скажите?
[02:16.000 --> 02:20.000]  Ну да, типа, который наследуется в кавычках.
[02:20.000 --> 02:25.000]  Который на самом деле, правильно сказать, имплементирует трейт. Сейчас мы это увидим.
[02:25.000 --> 02:26.000]  Вот.
[02:26.000 --> 02:29.000]  Также мы можем всякие дефолтные имплементации писать.
[02:29.000 --> 02:34.000]  Это очень часто используется в стандартной библиотеке, потому что у нас есть какой-то набор базовых функций.
[02:34.000 --> 02:39.000]  На основе этих базовых функций мы уже имплементируем какие-то дополнительные.
[02:39.000 --> 02:45.000]  Например, в случае итератора мы можем по умолчанию имплементировать такие штуки как Map.
[02:45.000 --> 02:48.000]  Мы же знаем, что итератор возвращает нас Next.
[02:48.000 --> 02:53.000]  Мы вызываем Next и возвращает Option Item.
[02:53.000 --> 02:55.000]  То есть, Option на следующий объект.
[02:55.000 --> 02:59.000]  На основе этого мы можем, например, какой-нибудь Map устроить уже.
[02:59.000 --> 03:01.000]  Ну, вы, наверное, видели в домашке, да?
[03:01.000 --> 03:05.000]  Каждому объекту что-то применить, какую-то функцию. Изменить типа.
[03:07.000 --> 03:12.000]  Вот. Давайте попробуем какую-нибудь структурку создать и имплементировать для нее такой трейт.
[03:13.000 --> 03:16.000]  Вот. Я создал такую структурку. Назвал ее Ship.
[03:16.000 --> 03:19.000]  И, смотрите, написал Impl.AnimalForShip.
[03:20.000 --> 03:23.000]  Ключевого слова, заметьте, опять же, Pub нет.
[03:23.000 --> 03:26.000]  Потому что это зависит от публичности трейта.
[03:27.000 --> 03:32.000]  Я имплементировал Name так, что я просто клонирую Name, который внутри,
[03:32.000 --> 03:36.000]  и возвращаю его, и Noize как какую-то строчку.
[03:36.000 --> 03:40.000]  Бах. То, что говорит у нас овца.
[03:41.000 --> 03:43.000]  Вот. Тут, кажется, все просто.
[03:45.000 --> 03:47.000]  Давайте пойдем дальше.
[03:47.000 --> 03:49.000]  У нас есть такой UsageExample.
[03:49.000 --> 03:53.000]  Вот давайте создадим овцу, назовем ее Dolly.
[03:53.000 --> 03:57.000]  Мы можем проверить, что, например, у нее появились новые функции,
[03:57.000 --> 03:59.000]  которые мы не имплементировали у самой овцы.
[03:59.000 --> 04:01.000]  Они зависели от трейта.
[04:01.000 --> 04:03.000]  ShipName это Dolly.
[04:03.000 --> 04:06.000]  Если мы вызовем ShipTalk, то тогда она станет...
[04:06.000 --> 04:08.000]  Ага. DollySaysBug.
[04:08.000 --> 04:10.000]  Да, это...
[04:10.000 --> 04:11.000]  Ну да, все правильно.
[04:11.000 --> 04:15.000]  Вот, видите, у нас Talk вызывает Name и Noize.
[04:15.000 --> 04:17.000]  То есть NameSaysNoize.
[04:17.000 --> 04:21.000]  И у нас, когда мы вызовем Talk, то у нас получится DollySaysBug.
[04:23.000 --> 04:25.000]  Понятно?
[04:25.000 --> 04:27.000]  У нас дефолтная имплементация у Talk есть.
[04:31.000 --> 04:33.000]  Теперь давайте попробуем так.
[04:33.000 --> 04:35.000]  У нас есть структурка Doc.
[04:35.000 --> 04:38.000]  Мы ей тоже какой-то Name имплементировали.
[04:38.000 --> 04:40.000]  Добавили какой-то Noize.
[04:41.000 --> 04:47.000]  И даже мы можем дефолтные методы тоже как-то переимплементировать, как нам захочется.
[04:47.000 --> 04:50.000]  Вот, например, на этот раз мы не будем там...
[04:50.000 --> 04:52.000]  NameSaysNoize делать.
[04:52.000 --> 04:58.000]  А вызовем PrintLens какой-то вот такой заранее заданной строчкой.
[05:00.000 --> 05:01.000]  Вот.
[05:01.000 --> 05:04.000]  Вот так вот это работает с дефолтными имплементациями.
[05:04.000 --> 05:06.000]  Тут понятно, да?
[05:08.000 --> 05:10.000]  Смотрите, а теперь я сделаю так.
[05:10.000 --> 05:12.000]  Я создам такую структуру Human.
[05:12.000 --> 05:14.000]  Человек.
[05:14.000 --> 05:16.000]  Так, напишу Name.
[05:16.000 --> 05:18.000]  Ну, Talk у нас какой-то тоже есть.
[05:18.000 --> 05:20.000]  У нас тоже есть MyName, SelfName.
[05:20.000 --> 05:22.000]  Самое интересное для нас Noize.
[05:22.000 --> 05:24.000]  Смотрите, у нас Human имеет тип...
[05:24.000 --> 05:27.000]  Ну, мы имплементировали TradeClone.
[05:27.000 --> 05:29.000]  ThriveClone сделать.
[05:29.000 --> 05:32.000]  Из домашнего, наверное, вы уже помните, что такое clone.
[05:32.000 --> 05:34.000]  Мы обсуждали его две лекции.
[05:34.000 --> 05:40.000]  Поэтому примерно помните, что если я вызову SelfClone, то тогда я склонирую человек.
[05:40.000 --> 05:43.000]  Получается, да? Получается тип Human.
[05:43.000 --> 05:45.000]  Ну, это вызывает...
[05:45.000 --> 05:49.000]  Результат таких вот действий будет, по сути, то же самое, что просто написать SelfName.
[05:49.000 --> 05:56.000]  Но, как видите, я могу внутри имплементации Human использовать его какие-то Trade.
[05:56.000 --> 05:58.000]  Особенно для него.
[05:58.000 --> 06:00.000]  Потом имплементирует clone.
[06:00.000 --> 06:03.000]  Я могу внутри имплементации Trade Animal использовать clone.
[06:03.000 --> 06:05.000]  Так как у Human есть clone.
[06:05.000 --> 06:07.000]  Понятия на тот момент.
[06:07.000 --> 06:09.000]  Ну, просто там какая-то дополнительная имплементация,
[06:09.000 --> 06:11.000]  которая просто клонирует каждый объект.
[06:11.000 --> 06:13.000]  Thrive так работает.
[06:15.000 --> 06:17.000]  А если мы сделаем так,
[06:17.000 --> 06:20.000]  ну, возьмем тот же Same Trade Animal
[06:20.000 --> 06:23.000]  и попробуем в ток воспользоваться clone.
[06:23.000 --> 06:25.000]  Во-первых, если вы попробуете написать clone,
[06:25.000 --> 06:27.000]  то равняется SelfClone,
[06:27.000 --> 06:29.000]  то эта строчка скомпилируется,
[06:29.000 --> 06:31.000]  она будет внезапно иметь тип не Self,
[06:31.000 --> 06:33.000]  то есть не объекта.
[06:33.000 --> 06:35.000]  С строчкой скомпилируется,
[06:35.000 --> 06:37.000]  она будет внезапно иметь тип не Self,
[06:37.000 --> 06:39.000]  то есть не объекта, который имплементирует Trade,
[06:39.000 --> 06:41.000]  а ссылочки на Self.
[06:41.000 --> 06:43.000]  Референс, точнее, на Self.
[06:43.000 --> 06:45.000]  Это не очень очевидно с первого взгляда.
[06:45.000 --> 06:47.000]  На этой лекции еще разберемся.
[06:47.000 --> 06:49.000]  То есть мы типа можем отдельно клонить ссылку
[06:49.000 --> 06:51.000]  и отдельно клонить сам объект?
[06:52.000 --> 06:54.000]  Вообще да.
[06:54.000 --> 06:57.000]  Ну, если что, обычные которые Redone или ссылочки,
[06:57.000 --> 06:59.000]  они копии являются.
[06:59.000 --> 07:01.000]  Потому что у нас heardmm.
[07:01.000 --> 07:07.000]  Потому что у нас может быть сколько угодно читателей, ну естественно, если мы создадим еще одного, никакой проблемы не будет.
[07:07.000 --> 07:14.000]  А вот mutable reference уже не клонируем, потому что мы не можем иметь несколько писателей.
[07:14.000 --> 07:19.000]  Это не очень очевидно, почему у нас клонируется ссылочка на self здесь.
[07:19.000 --> 07:24.000]  Мы здесь чуть-чуть дальше по лекции это обсудим, поговорим.
[07:24.000 --> 07:28.000]  Там работает такой trait, называется дерев.
[07:28.000 --> 07:33.000]  И он нам чуть-чуть непредсказуемо работает.
[07:33.000 --> 07:37.000]  Увидим, какие у него правила.
[07:37.000 --> 07:41.000]  Но если вы попробуете сделать все так, то есть смотрите, я разыменовал self,
[07:41.000 --> 07:45.000]  то есть тем самым я гарантированно получил тип self здесь.
[07:45.000 --> 07:47.000]  Не ссылочку на self, а именно self.
[07:47.000 --> 07:49.000]  И сделаю clone, то раз, надо пожаловать.
[07:49.000 --> 07:53.000]  Слушайте, вот у вас типа self, нет clone.
[07:53.000 --> 08:00.000]  Действительно, мы же типа, который self ничего не затребовали при имплементации трейта.
[08:00.000 --> 08:05.000]  У вас появляются в голове какие-нибудь ассоциации с плюсовыми концептами прямо сейчас?
[08:10.000 --> 08:16.000]  Ну вот здесь вот просто у нас раз по умолчанию ничего для типа не имплементирует.
[08:16.000 --> 08:19.000]  Ну ничего не требует от типа.
[08:19.000 --> 08:21.000]  Это нам нужно затребовать самостоятельно.
[08:21.000 --> 08:23.000]  То есть давайте мы так и сделаем.
[08:23.000 --> 08:27.000]  В плюсах, если что, подобный код, но там, конечно, не clone было бы, прекрасно бы скомпилировался.
[08:27.000 --> 08:32.000]  Ну и так бы работало до тех пор, пока бы мы не засунули объект, который нельзя копировать.
[08:36.000 --> 08:39.000]  В плюсах, например, конструктор копированный.
[08:45.000 --> 08:50.000]  Смотри, если этот метод есть у типа, то в плюсах бы все прекрасно скомпилировалось.
[08:50.000 --> 08:52.000]  Ты бы ни о чем не узнал.
[08:52.000 --> 08:59.000]  А если такого типа нет, ну ты случайно засунул, не знаю, написал код, засунул какой-то типа,
[08:59.000 --> 09:07.000]  которого нет конструктора копирования, допустим, и ты получишь такую ошибку при инстециализации шаблона.
[09:13.000 --> 09:15.000]  В общем-то у нас нет такого метода.
[09:16.000 --> 09:23.000]  Давайте попробуем и self затребовать clone, чтобы мы смогли склонировать объект.
[09:23.000 --> 09:29.000]  Вот смотрите, у меня есть pop-trade-animal, я написал такое замечательное ключевое слово where.
[09:29.000 --> 09:33.000]  Я сказал, теперь self у нас должно имплеметировать clone.
[09:33.000 --> 09:35.000]  И это будет прекрасно компилироваться.
[09:35.000 --> 09:43.000]  Обратите внимание, что теперь я пишу self clone, и у меня клонируется именно объект self, а не reference to self.
[09:43.000 --> 09:47.000]  То есть уже наоборот по сравнению с этим вот поведением.
[09:47.000 --> 09:53.000]  У нас тут было именно клонирование ссылки.
[09:53.000 --> 09:57.000]  Мы это обсудим чуть позже, там просто есть такой замечательный мем.
[10:02.000 --> 10:05.000]  Обсудим, в общем, как работает reference чуть позже.
[10:05.000 --> 10:11.000]  Это отлично скомпилируется, потому что раз понимает, self имплеметирует clone.
[10:13.000 --> 10:22.000]  Ну, where означает, что pop-trade-animal, где мы ожидаем, что self clone.
[10:26.000 --> 10:32.000]  Да, но на самом деле чуть другое, потому что require строго что-то запрещает либо что-то разрешает.
[10:32.000 --> 10:38.000]  Например, а вот какие-то вещи, которые ты не указал, он будет по умолчанию разрешать.
[10:38.000 --> 10:40.000]  Мы тоже сравним это чуть позже.
[10:43.000 --> 10:47.000]  Вот, а если мы попробуем, помните, у нас ship и dock были типы.
[10:47.000 --> 10:55.000]  Вот мы возьмем вот такую вот имплементацию трейта и попробуем ship и dock, которые у нас были до этого, у которых не было clone.
[10:55.000 --> 10:57.000]  Мы не писали derived clone на них.
[10:57.000 --> 10:58.000]  Скомпилировать.
[10:58.000 --> 11:02.000]  Вот тут примерно такие ошибки, что ship это не clone тип.
[11:02.000 --> 11:05.000]  Если у нас пишут, что trade bound ship clone, значит свайп.
[11:07.000 --> 11:10.000]  И мы будем получать такие вот от раз-то очевидные ошибки.
[11:10.000 --> 11:13.000]  Еще на этапе, когда вы засовываете тип.
[11:15.000 --> 11:22.000]  Он нам не даст сделать не очевидную ошибку, какую-то глубокую, которую нам потом очень долго читать от компилятора.
[11:27.000 --> 11:30.000]  А еще мы можем попробовать какие-то написать банды в generic.
[11:32.000 --> 11:34.000]  Вот смотрите, например, у меня есть такая вот функция.
[11:34.000 --> 11:38.000]  Я у нее затребовал вот обратить внимание, что ti двоеточие, я тоже пишу какие-то требования.
[11:40.000 --> 11:42.000]  Это работает точно так же, как where.
[11:42.000 --> 11:48.000]  Я бы мог, по сути, написать вот здесь вот ниже, where, ti это clone, plus hash, plus iterator.
[11:48.000 --> 11:50.000]  Запитает ti это clone.
[11:52.000 --> 11:54.000]  Так, вы не потеряли сейчас.
[11:54.000 --> 11:56.000]  Что такое ti?
[11:56.000 --> 11:58.000]  Что еще раз?
[11:58.000 --> 12:00.000]  Что такое ti?
[12:01.000 --> 12:06.000]  Ti, смотри, у нас просто я затребовал, что это итератор.
[12:06.000 --> 12:12.000]  Как жалко, что он не показал сам trait итератор, но в общем-то он внутри содержит тип item.
[12:12.000 --> 12:19.000]  Он требует, чтобы для каждого во время имплементации этого trait это еще указало, какой тип у item.
[12:19.000 --> 12:22.000]  Ну, то есть это какой-то тип, как using в плюсах.
[12:26.000 --> 12:27.000]  Что еще раз?
[12:31.000 --> 12:34.000]  Нет, он бы сказал, что у ti нет item.
[12:40.000 --> 12:43.000]  Ну, вообще лучше делать это trait, наверное.
[12:43.000 --> 12:50.000]  Потому что, насколько я помню, ассоциированных типов со структурами нет, поэтому нужно это именно в trait писать.
[12:54.000 --> 12:59.000]  Обратите внимание, что сверху я бы никак не написал, что ti это clone.
[12:59.000 --> 13:01.000]  Я бы просто не мог здесь что-то написать.
[13:01.000 --> 13:04.000]  То есть в баундовых женериках они более ограничены, чем var.
[13:04.000 --> 13:07.000]  Var это такой строго более сильный синтаксис.
[13:09.000 --> 13:15.000]  Просто иногда будет быстрее написать в этих угловатых скобочках что-то, если там пара баундов и все.
[13:16.000 --> 13:17.000]  Что еще раз?
[13:19.000 --> 13:21.000]  Блин, на эту лекцию не успеем.
[13:25.000 --> 13:27.000]  Да, да, прям посмотрим.
[13:30.000 --> 13:35.000]  Там внутри будет trait и traitor, и внутри там будет написано type item.
[13:35.000 --> 13:42.000]  Это будет означать, что когда ты будешь имплементировать traitor, то тебе нужно будет написать какой-то тип для item.
[13:42.000 --> 13:44.000]  Ассоциированный тип.
[13:49.000 --> 13:53.000]  Вот. У нас есть внутри там какой-то new, который возвращает self.
[13:54.000 --> 13:59.000]  Ну и вот я ровно сказал то, что можно перенести это сюда.
[13:59.000 --> 14:02.000]  Вот оно как раз тут перенесено в качестве примера.
[14:04.000 --> 14:05.000]  Это понятно?
[14:09.000 --> 14:12.000]  У нас нет как такового наследования в расте.
[14:12.000 --> 14:15.000]  У нас такой не объектно-ориентированный язык раст.
[14:15.000 --> 14:19.000]  Но тем не менее мы можем делать такую штуку, назвать support trait.
[14:20.000 --> 14:24.000]  Ну смотрите, у меня есть такой trait person, trait programmer.
[14:24.000 --> 14:27.000]  И как вы видите, я могу их наследовать.
[14:27.000 --> 14:36.000]  То есть, например, я создал trait student, который затребовал то, чтобы у объекта также был имплементирован person.
[14:38.000 --> 14:43.000]  В принципе, это то же самое, что и написать where self person.
[14:45.000 --> 14:47.000]  На самом деле даже не то же самое.
[14:47.000 --> 14:49.000]  Нет, это когда вы требуете.
[14:49.000 --> 14:51.000]  Я вам соврал, это не то же самое.
[14:51.000 --> 14:56.000]  Но это именно как бы приплюсовать между собой trait.
[14:56.000 --> 15:01.000]  То есть, если вы имплементируете student, то у вас обязательно должен быть имплементирован person.
[15:01.000 --> 15:03.000]  И Rast будет об этом знать.
[15:03.000 --> 15:05.000]  То есть, вы сделали балл такой.
[15:05.000 --> 15:06.000]  А как это отличается?
[15:06.000 --> 15:08.000]  А как это отличается?
[15:08.000 --> 15:09.000]  Да.
[15:09.000 --> 15:14.000]  От where отличается тем, ну там будут сейчас у нас еще trait объекты.
[15:14.000 --> 15:20.000]  И Rast в общем-то в таком случае не поймет, что у вас, если вы будете писать dean student,
[15:20.000 --> 15:24.000]  то Rast не поймет, что person тоже имплементирован.
[15:24.000 --> 15:27.000]  Поэтому желательно super trait именно делать.
[15:27.000 --> 15:29.000]  Чтобы он делал vtable на это все дело.
[15:29.000 --> 15:31.000]  Ну, мы сейчас поймем.
[15:33.000 --> 15:35.000]  А как это все отличается от плюсовых классов?
[15:35.000 --> 15:39.000]  Как вы сказали, что это наследование, а это...
[15:40.000 --> 15:45.000]  Ну, наследование плюсовых классов, оно именно плюсует, грубо говоря, классы между собой.
[15:45.000 --> 15:47.000]  Там же появляются...
[15:47.000 --> 15:49.000]  Ну, если, например, публичное наследование,
[15:49.000 --> 15:54.000]  тогда у тебя будут все приватные методы переедут, функции и все такое.
[15:54.000 --> 16:03.000]  И даже, которые внутри находятся, как их назвать, переменные, ну, поля, да.
[16:03.000 --> 16:06.000]  Вот, поля тоже будут как бы смержены.
[16:06.000 --> 16:12.000]  А здесь именно trait, он как интерфейс, он то, что умеет делать структуру, показывает.
[16:12.000 --> 16:16.000]  Да, естественно, плюсах в памяти размещения это может быть, ну, не как два класса,
[16:16.000 --> 16:19.000]  то в Rast это будет просто два класса, да, нет?
[16:20.000 --> 16:22.000]  В плане, два класса, да.
[16:22.000 --> 16:25.000]  В плане, то, что, ну, вот как раз то, что нет.
[16:27.000 --> 16:29.000]  В проблеме в том, что trait в поле нет,
[16:29.000 --> 16:33.000]  и поэтому интересно, как просто двигаешь концепты, учили его, решили другие концепты.
[16:33.000 --> 16:37.000]  Ну, что-то типа того, да, концепт концептом усиливаешь.
[16:39.000 --> 16:40.000]  Вот.
[16:40.000 --> 16:44.000]  А в депоте имплементации в трейдер чем нагоняется EOTP?
[16:45.000 --> 16:48.000]  Так, вот с этим вот понятно, да?
[16:48.000 --> 16:52.000]  Примером, здесь вот у нас programmer plus student это computer science student,
[16:52.000 --> 16:55.000]  ну, то есть я могу много трейдеров завтребовать.
[16:55.000 --> 17:00.000]  Более того, я могу, например, не написать функцию, я ставлю только фигурные скобочки.
[17:00.000 --> 17:03.000]  Когда бы это означало, что computer science student это кто-то,
[17:03.000 --> 17:06.000]  кто имплементирует programmer plus student, например.
[17:06.000 --> 17:10.000]  А еще я могу, соответственно, добавлять какие-то дополнительные функции.
[17:11.000 --> 17:14.000]  А в чем мотивированное отсутствие наследования?
[17:17.000 --> 17:20.000]  Наследование в плане наследования структур, в меньшую очередь.
[17:22.000 --> 17:26.000]  Ну, это на самом деле такой способ очень легко делать ошибки.
[17:26.000 --> 17:30.000]  Ну, даже, например, в Java запрещено множественное наследование.
[17:30.000 --> 17:35.000]  А если ты захочешь сделать имплементацию для нескольких интерфейсов в плюсах,
[17:35.000 --> 17:40.000]  ну, читай для нескольких структур с какими-то функциями,
[17:40.000 --> 17:43.000]  то в таком случае у тебя будет множественное наследование,
[17:43.000 --> 17:45.000]  это как-то не очень хорошо.
[17:46.000 --> 17:51.000]  Я, опять же, хочу, наверное, это снести ближе, ну, этот разговор к концу трейдов,
[17:51.000 --> 17:55.000]  чтобы мы все выяснили о трейдах, а после этого мы как бы это все просуммировали.
[17:55.000 --> 17:57.000]  Если вы не против.
[17:57.000 --> 18:01.000]  Ну, то есть, чтобы я не забегал наперед, пока я вам рассказываю про разницу с плюсами.
[18:04.000 --> 18:06.000]  Вот. Давайте дальше пойдем.
[18:07.000 --> 18:10.000]  А давайте вот так вот сделаем. У нас есть какая-то структурка форм,
[18:10.000 --> 18:14.000]  которая есть username-age, есть два трейда, username-widget и age-widget.
[18:15.000 --> 18:17.000]  Обратите внимание, что у меня есть два гета.
[18:20.000 --> 18:21.000]  Так, да.
[18:21.000 --> 18:24.000]  Ну, вот я имплементирую username-widget и age-widget.
[18:25.000 --> 18:28.000]  Вот возвращает username, возвращает age.
[18:29.000 --> 18:32.000]  А потом я делаю вот такую вот штуку.
[18:32.000 --> 18:36.000]  Я создаю форму, а потом вызываю get. Что произойдет?
[18:41.000 --> 18:44.000]  Кажется, у get разные return-types.
[18:44.000 --> 18:46.000]  Что, return-types?
[18:46.000 --> 18:48.000]  Кажется, у get разные return-types.
[18:48.000 --> 18:51.000]  Да, там разные return-types, но там даже если одинаковые,
[18:51.000 --> 18:54.000]  если одинаковые, то тем более было бы все плохо.
[18:54.000 --> 18:58.000]  Здесь, конечно же, точно так же, как и вы не знаете, что произойдет,
[18:58.000 --> 19:01.000]  так же и компилятор rasta не знает, что вы от него хотите.
[19:03.000 --> 19:05.000]  В общем, он на вас пожалуется.
[19:05.000 --> 19:08.000]  Он скажет, что знает несколько get-ов.
[19:08.000 --> 19:11.000]  От username-widget и от age-widget.
[19:12.000 --> 19:16.000]  Соответственно, нам нужно ему сказать, про какой мы get-говорим все-таки.
[19:16.000 --> 19:18.000]  Есть для этого два таких способа.
[19:18.000 --> 19:20.000]  Во-первых, мы можем сделать...
[19:20.000 --> 19:22.000]  У меня комментарий остался, неужели?
[19:22.000 --> 19:25.000]  А, ну это просто комментировал то, что было старое.
[19:27.000 --> 19:29.000]  Во-первых, я могу это вызвать от трейта.
[19:29.000 --> 19:31.000]  Смотрите, username-widget-get.
[19:32.000 --> 19:35.000]  То есть я написал трейт username-widget, запросил у него get,
[19:35.000 --> 19:38.000]  в качестве self передал ссылку на форму.
[19:38.000 --> 19:41.000]  Rasta поймет, о каком трейте идет речь.
[19:41.000 --> 19:43.000]  Какой именно get вы вызываете.
[19:43.000 --> 19:45.000]  Что еще раз было раньше?
[19:45.000 --> 19:47.000]  Ну да, вот он в комментариях.
[19:47.000 --> 19:48.000]  Form-get.
[19:48.000 --> 19:49.000]  Он не знал, какой get вызвать.
[19:49.000 --> 19:52.000]  То есть теперь мы ему сказали, вот здесь вот я хочу username-widget-get.
[19:54.000 --> 19:57.000]  Теперь понял, что мы имеем в виду именно это.
[19:57.000 --> 19:59.000]  И оно скомпилируется прекрасно.
[19:59.000 --> 20:01.000]  И выведет rasta с ним.
[20:02.000 --> 20:04.000]  Потом у нас есть еще age.
[20:05.000 --> 20:07.000]  И мы можем сделать это.
[20:07.000 --> 20:09.000]  Выведет rasta с ним.
[20:10.000 --> 20:12.000]  Потом у нас есть еще age.
[20:14.000 --> 20:18.000]  Ну вот смотрите, я здесь вот использовал такой особенный синтаксис,
[20:18.000 --> 20:20.000]  который называется fully qualified.
[20:21.000 --> 20:23.000]  Давайте мы его собственно обсудим.
[20:24.000 --> 20:26.000]  Я взял нашу форму.
[20:27.000 --> 20:32.000]  Смотрите, я уточнил, что формы я рассматриваю как age-widget.
[20:33.000 --> 20:36.000]  То есть я рассматриваю как объект, который имплементирует
[20:37.000 --> 20:39.000]  trait-age-widget.
[20:39.000 --> 20:41.000]  Ну форм действительно имплементирует эту штуку.
[20:42.000 --> 20:45.000]  То есть я что-то типа приведения сделал примитивного.
[20:46.000 --> 20:48.000]  И потом я вызываю get на форме.
[20:48.000 --> 20:51.000]  То есть я знаю, что я на форме вызываю age-widget теперь.
[20:52.000 --> 20:55.000]  Это такой fully qualified синтакс называется.
[20:57.000 --> 20:58.000]  Сейчас мы его еще обсудим.
[20:58.000 --> 21:01.000]  Вот конкретно на этом слайде примерно понятно, что происходит в этой строчке.
[21:01.000 --> 21:03.000]  Сейчас еще будет.
[21:03.000 --> 21:07.000]  Если написать вместо age-widget-form, то он не заработает?
[21:08.000 --> 21:10.000]  Вместо age-widget-form, то есть форма с форм?
[21:11.000 --> 21:13.000]  Нет, не сработает.
[21:13.000 --> 21:15.000]  Ну во-первых, там должен быть trait.
[21:16.000 --> 21:18.000]  А у нас там структура, то есть форма как структура.
[21:18.000 --> 21:20.000]  Структура как структура, это было бы странно.
[21:21.000 --> 21:26.000]  Сейчас еще раз, у меня здесь не чарик, а вот это вот форм приводится к age-widget,
[21:26.000 --> 21:28.000]  и потом get называется.
[21:29.000 --> 21:31.000]  Не, ну вот это вот, это только для компилятора.
[21:31.000 --> 21:35.000]  Для компилятора мы говорим, что мы сейчас будем от форм вызывать age-widget.
[21:37.000 --> 21:45.000]  Этот синтакс заключается от первого тем, что мы сначала проверяем тип аргумента, что это форм.
[21:47.000 --> 21:51.000]  Во-первых, проверяем форму, а во-вторых, мы проверяем age-widget, то есть то, что get действительно есть.
[21:52.000 --> 21:55.000]  И вызываем именно get от age-widget в этой форме.
[21:55.000 --> 21:57.000]  Вот так вот.
[22:00.000 --> 22:03.000]  Ну это все, естественно, на этапе компиляции происходит, а не в runtime.
[22:05.000 --> 22:07.000]  Смотрите, это очень похоже на turbofish.
[22:07.000 --> 22:09.000]  В первой лекции у нас было упоминание о нем.
[22:09.000 --> 22:12.000]  Даже не упоминание, мы чуть-чуть его посмотрели, когда были в женерике.
[22:13.000 --> 22:15.000]  На самом деле...
[22:18.000 --> 22:20.000]  Даже не знаю как...
[22:20.000 --> 22:22.000]  Какой вы способ, так сказать, инстанцировать?
[22:24.000 --> 22:28.000]  Ну давай пока что это проедем, побежим дальше, потому что у нас много слайдов.
[22:29.000 --> 22:31.000]  Все равно это не совсем turbofish.
[22:31.000 --> 22:34.000]  На самом деле это называется polyqualified syntax, то есть в данном случае.
[22:34.000 --> 22:37.000]  Оно хоть и похоже на turbofish, но turbofish'ем не является.
[22:37.000 --> 22:43.000]  Еще если будете читать где-то в интернете, то раньше это называлось universal function syntax.
[22:45.000 --> 22:48.000]  И это самый общий способ вызывать функции в расте.
[22:50.000 --> 22:52.000]  То есть более общего способа нет.
[22:52.000 --> 22:57.000]  Большую часть времени раз за вас понимает, какую вы вызываете функцию.
[22:59.000 --> 23:01.000]  Иногда, когда он не понимает, вам приходится указывать.
[23:01.000 --> 23:08.000]  В первом случае вызвали это от трейта, во второй раз тоже от трейта, но это еще более общий способ.
[23:09.000 --> 23:11.000]  Как-то так.
[23:20.000 --> 23:22.000]  Сейчас.
[23:22.000 --> 23:24.000]  Я подзабыл, что я хотел сказать.
[23:26.000 --> 23:30.000]  Да, ну мы требуем AT, что он имплементирует трейт.
[23:35.000 --> 23:37.000]  Мы это все вроде бы уже сказали, да?
[23:40.000 --> 23:44.000]  Ну да, если это просто идентификатор, то это может быть пропущено.
[23:46.000 --> 23:48.000]  Ну тут понятно, да, примерно.
[23:49.000 --> 23:53.000]  Ну вы не говорите, просто понятно. Если что-то непонятно, лучше спросите.
[24:02.000 --> 24:04.000]  В плане edgeVisitGet мы можем, конечно, так сделать.
[24:04.000 --> 24:05.000]  Оно сработает.
[24:05.000 --> 24:09.000]  Я просто показал, что еще можно вот так вот еще более общий способ для вызыва функций есть.
[24:10.000 --> 24:14.000]  То есть вот этот и этот синтаксис, они работают абсолютно одинаково в данном случае.
[24:19.000 --> 24:21.000]  Так.
[24:22.000 --> 24:27.000]  А что если мы хотим зацепить какой-то тип, который имплементирует какой-то трейт?
[24:28.000 --> 24:34.000]  Ну, собственно, помните, я писал, что в дженериках можно вот такие вот ограничения вводить.
[24:35.000 --> 24:39.000]  Ну здесь вот я какой-то myTrade требую и clone.
[24:40.000 --> 24:43.000]  Тоже вы, наверное, видели это в домашке.
[24:44.000 --> 24:47.000]  Только здесь вот обратите внимание, мы это уже делаем не в структуре, а в функции.
[24:48.000 --> 24:53.000]  То есть мы в функции тоже можем делать дженерик и требовать какие-то там сложные на трейты ограничения.
[24:54.000 --> 24:56.000]  В том числе мы можем тут написать where.
[24:57.000 --> 25:03.000]  У меня примера с where, наверное, нет, но мы можем написать в общем t и после этого написать where t, это myTrade прес clone.
[25:03.000 --> 25:05.000]  myTrade прес clone.
[25:20.000 --> 25:22.000]  Структуру вместо трейта?
[25:23.000 --> 25:25.000]  Как понять?
[25:25.000 --> 25:29.000]  Ну, в общем, что у нас у тебя в структуре? То есть там поля нельзя просто...
[25:30.000 --> 25:33.000]  Ну, трейт это какая-то абстракция на уровне компилятора, по сути.
[25:34.000 --> 25:36.000]  То есть нет никакой поля в структуре?
[25:37.000 --> 25:41.000]  Ну, в трейте, да. В трейте он только ассоциирует типы, константы и функции.
[25:42.000 --> 25:46.000]  Функции мы посмотрели, типы еще посмотрим, константы попозже посмотрим.
[25:46.000 --> 25:53.000]  А вот если мы в структуре используем все, не потребуем clone и при этом в теле функции будем планировать с t, то это будет...
[25:54.000 --> 25:56.000]  То расскажешь, что не имплементирует clone.
[25:58.000 --> 26:00.000]  Причем... Да, да.
[26:01.000 --> 26:05.000]  Ну, то есть это в каком-то смысле преимущество перед плюсами, потому что мы получаем ошибку сразу же.
[26:06.000 --> 26:08.000]  В том месте, в котором мы еще используем тип.
[26:09.000 --> 26:12.000]  Ну да, а не в том месте, в котором мы еще используем тип.
[26:12.000 --> 26:14.000]  Да, кстати вот...
[26:15.000 --> 26:17.000]  Вот mytrade плюс clone еще можно писать так.
[26:18.000 --> 26:19.000]  Impl.
[26:20.000 --> 26:21.000]  То есть такое ключевое слово.
[26:22.000 --> 26:25.000]  Impl делает ровно то же самое, это просто синтактический сад.
[26:26.000 --> 26:33.000]  То есть оно точно так же создаст какой-то там тип t после функции, который mytrade плюс clone и импл.
[26:34.000 --> 26:36.000]  То есть импл делает ровно то же самое, это просто синтактический сад.
[26:36.000 --> 26:41.000]  То есть оно точно так же создаст какой-то там тип t после функции, который mytrade плюс clone.
[26:42.000 --> 26:44.000]  И этот t подставит на место импл. mytrade плюс clone.
[26:45.000 --> 26:48.000]  То есть вот эта вот запись и вот эта вот запись, это одно и то же.
[26:49.000 --> 26:50.000]  Просто второй вариант это синтактический сахар.
[26:51.000 --> 26:54.000]  Что такое синтактический сахар? Мне сразу видно, что это женерис.
[26:55.000 --> 26:56.000]  Сейчас, можно еще раз?
[26:57.000 --> 26:58.000]  Так.
[26:59.000 --> 27:00.000]  Тут видно, что это женерис, а там нет.
[27:05.000 --> 27:08.000]  Получается, это неудобно, если у нас несколько элементов.
[27:10.000 --> 27:11.000]  В плане.
[27:12.000 --> 27:14.000]  Да, такой вопрос. Мы можем несколько имплов?
[27:15.000 --> 27:16.000]  Да, можем.
[27:17.000 --> 27:19.000]  Ну t, он естественно раз называет это не t.
[27:20.000 --> 27:21.000]  Там какой-то у него интернал.
[27:22.000 --> 27:24.000]  Мы вот здесь пишем, вот на этом слайде.
[27:27.000 --> 27:29.000]  Вот мы пишем импл. t.
[27:30.000 --> 27:32.000]  И вот, допустим, мы хотим еще output. t.
[27:33.000 --> 27:35.000]  Вот на следующем слайде мы тогда что, должны дважды написать?
[27:36.000 --> 27:39.000]  А ты имеешь в виду, чтобы мы и там и там требовали один и тот же тип t?
[27:40.000 --> 27:41.000]  Да.
[27:42.000 --> 27:45.000]  Нет, тогда нужен generic. Импл, он просто такой синтактический сахар в одно место, что-то вставить.
[27:47.000 --> 27:48.000]  Что еще раз?
[27:49.000 --> 27:50.000]  Потом обращаться к типу переменной.
[27:51.000 --> 27:53.000]  К типу переменной? Ну это generic.
[27:54.000 --> 27:56.000]  Да, ну как он называется?
[27:57.000 --> 27:58.000]  Не, подожди.
[27:59.000 --> 28:02.000]  Подожди, тип t ты не можешь выяснить, если ты в генерике.
[28:03.000 --> 28:06.000]  Все, что ты знаешь о типе t, это то, что он имплимитирует mytrade плюс clone.
[28:07.000 --> 28:10.000]  Ну если я хочу создать другую переменную типа t.
[28:11.000 --> 28:13.000]  Ну другую просто создавай ее.
[28:14.000 --> 28:15.000]  Нет, ты ее я хочу написать.
[28:16.000 --> 28:17.000]  Я хочу написать tnew.
[28:18.000 --> 28:19.000]  tnew?
[28:20.000 --> 28:21.000]  Ну, предположим t имеет...
[28:22.000 --> 28:24.000]  Ну, допустим tclone хочешь написать, clone имплементирован, да?
[28:25.000 --> 28:26.000]  Ну...
[28:27.000 --> 28:30.000]  Ну ты просто напишешь input letig, сравняйте input clone, и оно прекрасно будет работать.
[28:31.000 --> 28:33.000]  Нет, какой-то статический метод.
[28:34.000 --> 28:35.000]  Статический метод, в плане.
[28:36.000 --> 28:42.000]  Ну, мне не нужен экземпляровать. Мне не нужен input, я хочу t.
[28:43.000 --> 28:47.000]  Короче, вопрос, как в засахаренном коде достать тип аргумента, который был засахарен.
[28:48.000 --> 28:50.000]  Ух, примерно так.
[28:51.000 --> 28:52.000]  Ох.
[28:53.000 --> 28:54.000]  То есть вот в предыдущем таблице...
[28:55.000 --> 28:57.000]  Не, я понял, что вы хотите, то есть достать тип t.
[28:58.000 --> 29:00.000]  Вот я сходу вообще не знаю, как это сделать, я никогда так не делал.
[29:01.000 --> 29:02.000]  Да.
[29:03.000 --> 29:07.000]  Нет, скорее всего, там есть что-то такое, чтобы достать, но я так ни разу не делал.
[29:08.000 --> 29:10.000]  По-моему, звучит очень проще написать генерик.
[29:11.000 --> 29:16.000]  Ну, так это вот реально, ну это как когда в плюсы втащили возможность аргумента и пункции.
[29:17.000 --> 29:19.000]  Ну, вот это полезно в основном, когда он, например, возвращает итератор.
[29:20.000 --> 29:24.000]  Вы пишете там стрелочка, импл итератор. У нас такое было в чате как раз.
[29:25.000 --> 29:27.000]  Тогда мы будем возвращать итератор, в общем-то.
[29:28.000 --> 29:30.000]  Что-то, что возвращает итератор.
[29:33.000 --> 29:34.000]  Вот.
[29:35.000 --> 29:40.000]  А что если мы хотим какие-то дополнительные методы в зависимости от того, что t что-то имплементирует?
[29:43.000 --> 29:44.000]  В компиляторе это выглядит...
[29:45.000 --> 29:47.000]  Не в компиляторе, точнее в стандартной библиотеке.
[29:48.000 --> 29:50.000]  Это выглядит, конечно, не совсем так, но в принципе достаточно.
[29:51.000 --> 29:52.000]  Похоже.
[29:53.000 --> 29:54.000]  У нас есть и нам option.
[29:55.000 --> 29:56.000]  Так.
[29:57.000 --> 29:58.000]  Я сделал какую-то имплементацию, какие-то функции option.
[29:59.000 --> 30:03.000]  А теперь я хочу при условии, что t что-то имплементирует, ну имплементирует default,
[30:04.000 --> 30:05.000]  а у нас есть какие-то еще функции.
[30:06.000 --> 30:08.000]  Вот я могу написать импл t, option t, vrt, default.
[30:09.000 --> 30:15.000]  Если t имплементирует default, тогда у типа option t появится дополнительная метода из этого блока.
[30:16.000 --> 30:18.000]  То есть они объединяются все такие...
[30:19.000 --> 30:24.000]  Да. Все, что имплементирует t, они там, сам компилятор выяснит, что это имплементировано.
[30:26.000 --> 30:27.000]  Вот.
[30:28.000 --> 30:30.000]  Сейчас еще какая разница между там, где vr есть и нет vr?
[30:31.000 --> 30:32.000]  Повтори.
[30:32.000 --> 30:33.000]  А.
[30:34.000 --> 30:37.000]  Есть ли разница между, где есть vr и нет vr? То есть мы можем...
[30:38.000 --> 30:41.000]  Ну смотри, вот здесь у нас произвольный тип t, мы от него ничего вообще не требуем.
[30:42.000 --> 30:43.000]  А вот здесь мы требуем default.
[30:44.000 --> 30:48.000]  И, ну типа, мы можем либо тот, либо тот использовать.
[30:49.000 --> 30:54.000]  Нет, мы можем, если t не имплементирует default, то нам будет доступна только функция из этого блока.
[30:55.000 --> 30:56.000]  А если имплементирует?
[30:57.000 --> 30:58.000]  А если имплементирует, то и то.
[30:58.000 --> 31:02.000]  Ну получается, мы можем так, ну, сколько угодно наканустроить, и компилятор все правильно подмешает.
[31:03.000 --> 31:04.000]  Ну он будет добавлять.
[31:05.000 --> 31:06.000]  Ну если у вас так получится...
[31:09.000 --> 31:15.000]  Ясно, просто какой-то произвольно-сложный технический граф по специализации, и компилятор подмешает правильно под граф, да?
[31:16.000 --> 31:19.000]  Я вот подзабыл, конечно, какой хороший пример здесь можно произвести.
[31:20.000 --> 31:21.000]  Да не важно, как хороший или нет.
[31:22.000 --> 31:23.000]  Не, не про это.
[31:23.000 --> 31:28.000]  Там может быть такое, что у вас компилятор не понимает что-то про имплей.
[31:29.000 --> 31:34.000]  Я подзабыл, я подзабыл, что именно, поэтому, наверное, не буду на всякий случай вас путать, потому что в чате добавлю.
[31:35.000 --> 31:36.000]  Вот.
[31:37.000 --> 31:40.000]  Но это, в общем, знаете, что вот эта вся фигня, она аддитивна.
[31:41.000 --> 31:48.000]  То есть если у вас там будет default плюс clone, допустим, ниже, то в таком случае это нормально приплюсуется.
[31:48.000 --> 31:54.000]  А если у вас будут как-то пересекаться имплы, то тогда компилятор будет отжаловаться.
[31:55.000 --> 31:59.000]  Он-то разрешит, причем еще на этапе, до того, как вы хоть какой-то тэп ставите.
[32:00.000 --> 32:02.000]  Какая была комплиментация, которая вам пользуется?
[32:04.000 --> 32:06.000]  Обе, либо обе, либо только тэ.
[32:07.000 --> 32:08.000]  Объединение всех имплов, которые подходят.
[32:09.000 --> 32:12.000]  Да, объединение всех имплов, которые подходят под тип тэ.
[32:13.000 --> 32:17.000]  Можно делать отдельную реализацию для тех, у которых чего-то нет.
[32:18.000 --> 32:19.000]  Дело, когда нет default.
[32:20.000 --> 32:21.000]  Да, там есть not default.
[32:22.000 --> 32:27.000]  Ну, там есть такой значок, например, вопросик будет означать, что не обязательно имплементируют.
[32:28.000 --> 32:31.000]  Это используют для сайст почти всегда.
[32:34.000 --> 32:36.000]  Нет, есть вопросик, есть восклицательный знак.
[32:37.000 --> 32:38.000]  Восклицательный знак означает не имплементируйте.
[32:39.000 --> 32:41.000]  Это уже, конечно, вопросик к началу.
[32:42.000 --> 32:44.000]  Онрос прищелся как сахар конкретно для уксана.
[32:45.000 --> 32:46.000]  Ну да, наверное.
[32:47.000 --> 32:54.000]  Ну, вопросик именно тут имеют. Вопросик к default здесь будет, если не обязательно имплементировать default.
[32:54.000 --> 32:57.000]  Восклицательный знак не имплементирует default.
[33:02.000 --> 33:06.000]  А вот это уже больше похоже на то, что в стандартной библиотеке.
[33:06.000 --> 33:08.000]  Библиотеки. Ну, не больше, в принципе.
[33:08.000 --> 33:10.000]  Тоже самое, что в стандартной библиотеке.
[33:10.000 --> 33:12.000]  Если T
[33:12.000 --> 33:14.000]  имплементирует default, то в таком случае
[33:14.000 --> 33:16.000]  будет включена вот такая вот функция.
[33:16.000 --> 33:18.000]  До этого у нас были импл блоки, а теперь у нас
[33:18.000 --> 33:20.000]  есть два импл блока. Теперь у нас один импл блок
[33:20.000 --> 33:22.000]  и есть вот функция Android power
[33:22.000 --> 33:24.000]  default. Она действительно есть в
[33:24.000 --> 33:26.000]  опшене. Она действительно принимает self
[33:26.000 --> 33:28.000]  и возвращает либо T, если
[33:28.000 --> 33:30.000]  у нас опшен, то сам.
[33:30.000 --> 33:32.000]  Либо default-ное значение
[33:32.000 --> 33:34.000]  T, если у нас там now.
[33:34.000 --> 33:36.000]  То есть мы можем
[33:36.000 --> 33:38.000]  делать еще более точечные?
[33:38.000 --> 33:40.000]  Да, мы можем функции
[33:40.000 --> 33:42.000]  включать-выключать,
[33:42.000 --> 33:44.000]  в зависимости от этого.
[33:44.000 --> 33:46.000]  А зачем нам здесь у каждого
[33:46.000 --> 33:48.000]  это и у импл, и у опшен?
[33:50.000 --> 33:52.000]  А, вот это про это?
[33:52.000 --> 33:54.000]  Помню, на первой лекции говорил,
[33:54.000 --> 33:56.000]  что мол, это выглядит нелогично,
[33:56.000 --> 33:58.000]  что мы дважды повторяем один и тот же список
[33:58.000 --> 34:00.000]  аргументов. Но сейчас
[34:00.000 --> 34:02.000]  чуть подальше мы увидим, что у
[34:02.000 --> 34:04.000]  трейтов тоже есть дженерики.
[34:04.000 --> 34:06.000]  И что это нужно будет расфасовывать.
[34:06.000 --> 34:08.000]  То есть импл — это все почему мы
[34:08.000 --> 34:10.000]  дженерик, а дальше просто расставляется
[34:10.000 --> 34:12.000]  тип. Мы увидим это,
[34:12.000 --> 34:14.000]  когда будем говорить, например, про
[34:14.000 --> 34:16.000]  сравнение.
[34:18.000 --> 34:20.000]  Свиная врасти нет.
[34:24.000 --> 34:26.000]  Так, понятно ли
[34:26.000 --> 34:28.000]  вот такие вот базы трейтов?
[34:32.000 --> 34:34.000]  Окей, я просто
[34:34.000 --> 34:36.000]  посмотрю, где в ВЭР можно
[34:36.000 --> 34:38.000]  писать?
[34:38.000 --> 34:40.000]  В ВЭР можно в функциях писать,
[34:40.000 --> 34:42.000]  в трейтах писать.
[34:42.000 --> 34:44.000]  Можно в структуру включать
[34:44.000 --> 34:46.000]  или отключать структуру для каких-то
[34:46.000 --> 34:48.000]  типов.
[34:48.000 --> 34:50.000]  А, как в ВЭР?
[34:50.000 --> 34:52.000]  В плане структуры написать
[34:52.000 --> 34:54.000]  в дженерике, например, стракт-тест
[34:54.000 --> 34:56.000]  и внутри написать тиклон.
[34:56.000 --> 34:58.000]  И в таком случае, если засунуть
[34:58.000 --> 35:00.000]  при инстанциализации структуру
[35:00.000 --> 35:02.000]  какой-то тип, который не клон, компилятор скажет,
[35:02.000 --> 35:04.000]  что для этой структуры нужен обязательно
[35:04.000 --> 35:06.000]  клон тип.
[35:08.000 --> 35:10.000]  Давайте поговорим
[35:10.000 --> 35:12.000]  про exotically sized types.
[35:20.000 --> 35:22.000]  Большую часть времени
[35:22.000 --> 35:24.000]  у нас размеры типов врасти
[35:24.000 --> 35:26.000]  положительные, строго положительные
[35:26.000 --> 35:28.000]  какие-то натуральные числа.
[35:28.000 --> 35:30.000]  Это, на самом деле, не всегда правда.
[35:30.000 --> 35:32.000]  В-первых, у нас есть типы нулевого размера,
[35:32.000 --> 35:34.000]  во-вторых, у нас есть типы размера, которых
[35:34.000 --> 35:36.000]  мы не знаем на этапе компиляции.
[35:38.000 --> 35:40.000]  Всего у нас есть такие вот,
[35:40.000 --> 35:42.000]  по крайней мере, в стабильном расти,
[35:42.000 --> 35:44.000]  есть такие вот четыре типа.
[35:44.000 --> 35:46.000]  Там вроде бы есть еще пропозалы дополнительные
[35:46.000 --> 35:48.000]  для того, чтобы работать с FFI,
[35:48.000 --> 35:50.000]  но я тут уже слабо разбираюсь,
[35:50.000 --> 35:52.000]  не буду вам
[35:52.000 --> 35:54.000]  рассказывать про это.
[35:54.000 --> 35:56.000]  В-вторых, если мы используем FFI,
[35:56.000 --> 35:58.000]  то мы, в общем, почему-то не можем сказать,
[35:58.000 --> 36:00.000]  кто он такой.
[36:00.000 --> 36:02.000]  А это что FFI?
[36:02.000 --> 36:04.000]  Это foreign-function interface,
[36:04.000 --> 36:06.000]  когда взаимодействует с другими языками.
[36:08.000 --> 36:10.000]  А что у нас в последние две категории?
[36:10.000 --> 36:12.000]  Zero-sized types и empty types.
[36:12.000 --> 36:14.000]  Empty type это, ну, сейчас увидим,
[36:14.000 --> 36:16.000]  пустой енам, который нельзя инцелизировать вообще.
[36:20.000 --> 36:22.000]  Например, есть структура, которая просто
[36:22.000 --> 36:24.000]  не в смысле в пакете.
[36:24.000 --> 36:26.000]  Нет вариантов у енама.
[36:26.000 --> 36:28.000]  То есть ты его не машинит.
[36:28.000 --> 36:30.000]  В бюджетах типа тип пустой,
[36:30.000 --> 36:32.000]  если у тебя все объекты с этого типа пустые,
[36:32.000 --> 36:34.000]  а тут просто значение пустое.
[36:34.000 --> 36:36.000]  Получается как, как бы сказать, ненак.
[36:36.000 --> 36:38.000]  Да-да, это как раз то, что с первой лекции.
[36:40.000 --> 36:42.000]  Вот.
[36:42.000 --> 36:44.000]  Нас из этого особенно интересует Dynamic
[36:44.000 --> 36:46.000]  и size types.
[36:46.000 --> 36:48.000]  Бразируя size types, там, в принципе, достаточно
[36:48.000 --> 36:50.000]  все понятно.
[36:50.000 --> 36:52.000]  Мы даже на первой лекции поговорили.
[36:52.000 --> 36:54.000]  Нас интересует 10.
[36:54.000 --> 36:56.000]  В первую очередь. Сегодня.
[36:56.000 --> 36:58.000]  Это такие типы, у которых
[36:58.000 --> 37:00.000]  неизвестны размерные этапы компиляции.
[37:00.000 --> 37:02.000]  Есть два главных типа 10.
[37:02.000 --> 37:04.000]  Даже более того, это
[37:04.000 --> 37:06.000]  два единственных типа 10 вообще на весь раз.
[37:08.000 --> 37:10.000]  Это slice и trait-объекты.
[37:10.000 --> 37:12.000]  Вот когда мы проходили slice
[37:12.000 --> 37:14.000]  и проходили строковая slice,
[37:14.000 --> 37:16.000]  мы же, наверное, когда на это смотрели,
[37:16.000 --> 37:18.000]  думали, а почему это у нас
[37:18.000 --> 37:20.000]  это ссылочка постоянно пишется
[37:20.000 --> 37:22.000]  перед tr и перед u8.
[37:22.000 --> 37:24.000]  Ну, может быть, да.
[37:24.000 --> 37:26.000]  Но казалось, что это просто обычные
[37:26.000 --> 37:28.000]  скриньки юхи, там есть, ну, и span,
[37:28.000 --> 37:30.000]  и spilso. Нет, это не совсем так.
[37:30.000 --> 37:32.000]  Потому что для того, чтобы было
[37:32.000 --> 37:34.000]  все корректно, с точки зрения
[37:34.000 --> 37:36.000]  теории типов, у нас же строковая slice
[37:36.000 --> 37:38.000]  не понятного размера
[37:38.000 --> 37:40.000]  во время компиляции. Мы не знаем в зависимости
[37:40.000 --> 37:42.000]  от user input и все.
[37:42.000 --> 37:44.000]  А вот ссылка на строковая slice,
[37:44.000 --> 37:46.000]  она уже понятна, что из себя представляет.
[37:46.000 --> 37:48.000]  Она представляет из себя указатель
[37:48.000 --> 37:50.000]  и размер, допустим, slice.
[37:50.000 --> 37:52.000]  А, что бы это,
[37:52.000 --> 37:54.000]  ссылка на slice имеет указатель
[37:54.000 --> 37:56.000]  и размер. Да, ссылка на slice-то
[37:56.000 --> 37:58.000]  умеет, а сам slice- это какой-то
[37:58.000 --> 38:00.000]  участок памяти с точки зрения теории
[38:00.000 --> 38:02.000]  типов raster. Он не знает, какого размера slice.
[38:02.000 --> 38:04.000]  Он not sized.
[38:08.000 --> 38:10.000]  Ну, еще есть такая штука, называется
[38:10.000 --> 38:12.000]  trait-объекты, на которую мы еще посмотрим.
[38:12.000 --> 38:14.000]  Это, в общем-то, у нас
[38:14.000 --> 38:16.000]  кемическая диспетчеризация.
[38:22.000 --> 38:24.000]  Эти типы не имплементируют такой trait,
[38:24.000 --> 38:26.000]  называется sized.
[38:26.000 --> 38:28.000]  Это так называемый маркерный trait.
[38:28.000 --> 38:30.000]  Припоминайте копию.
[38:30.000 --> 38:32.000]  Я вот говорил, что у нас
[38:32.000 --> 38:34.000]  копия- это маркерный trait,
[38:34.000 --> 38:36.000]  с точки зрения компилятора.
[38:36.000 --> 38:38.000]  Да, он имеет
[38:38.000 --> 38:40.000]  с точки зрения компилятора
[38:40.000 --> 38:42.000]  особенную семантику.
[38:42.000 --> 38:44.000]  Если вы имплементируете копию,
[38:44.000 --> 38:46.000]  то это что-то говорит компилятору,
[38:46.000 --> 38:48.000]  что можно копировать просто по байтовой типы,
[38:48.000 --> 38:50.000]  что у него другая семантика внутри языка.
[38:52.000 --> 38:54.000]  Sized тоже самое говорит.
[38:54.000 --> 38:56.000]  Это маркерный trait, который что-то
[38:56.000 --> 38:58.000]  влияет внутри компилятора самого.
[39:00.000 --> 39:02.000]  И на самом деле, когда он говорил raster,
[39:02.000 --> 39:04.000]  ничего не требует помолчания типов, я
[39:04.000 --> 39:06.000]  капельку соврал. Все-таки raster
[39:06.000 --> 39:08.000]  помолчания типов требует то, что они sized.
[39:08.000 --> 39:10.000]  Это он делает,
[39:10.000 --> 39:12.000]  потому что у вас примерно все, что вы будете
[39:12.000 --> 39:14.000]  создавать, будет sized.
[39:14.000 --> 39:16.000]  То есть будут действительно редкие ситуации,
[39:16.000 --> 39:18.000]  когда вам нужно будет писать, что тип
[39:20.000 --> 39:22.000]  не обязательно sized.
[39:26.000 --> 39:28.000]  Да, может быть, мы посмотрим сейчас.
[39:28.000 --> 39:30.000]  Вопросительный знак
[39:30.000 --> 39:32.000]  у B
[39:32.000 --> 39:34.000]  для частности
[39:34.000 --> 39:36.000]  не обязательно
[39:36.000 --> 39:38.000]  по умолчанию.
[39:40.000 --> 39:42.000]  Вопросительный знак, как раз вопрос
[39:42.000 --> 39:44.000]  Sized, это самый частый паттерн.
[39:44.000 --> 39:46.000]  Мы его будем очень часто
[39:46.000 --> 39:48.000]  видеть сегодня, когда мы будем в стандартной
[39:48.000 --> 39:50.000]  блядевку смотреть.
[39:52.000 --> 39:54.000]  Как я говорил, запомните,
[39:54.000 --> 39:56.000]  в raster очень строгая система типов.
[39:56.000 --> 39:58.000]  Следите за типами.
[39:58.000 --> 40:00.000]  У нас slice,
[40:00.000 --> 40:02.000]  как я говорю, это
[40:02.000 --> 40:04.000]  вещь, которую непонятная размера.
[40:04.000 --> 40:06.000]  И для того, чтобы с точки зрения
[40:06.000 --> 40:08.000]  теории типов все было правильно, мы не пытаемся
[40:08.000 --> 40:10.000]  как в плюсах, допустим, сделать string view,
[40:10.000 --> 40:12.000]  у которого там пара указателей,
[40:12.000 --> 40:14.000]  допустим, внутри.
[40:14.000 --> 40:16.000]  Мы именно создаем отдельный тип,
[40:16.000 --> 40:18.000]  который unsized размера, и
[40:18.000 --> 40:20.000]  делаем ссылку на его, который уже sized размера.
[40:20.000 --> 40:22.000]  То есть чтобы все было корректно с точки зрения
[40:22.000 --> 40:24.000]  теории типов, ничего не ломалось, soundness
[40:24.000 --> 40:26.000]  работает, все прекрасно.
[40:26.000 --> 40:28.000]  Safe raster получился.
[40:28.000 --> 40:30.000]  В том числе у нас
[40:30.000 --> 40:32.000]  как я сказал,
[40:32.000 --> 40:34.000]  t и ссылка на t это разная вещь.
[40:34.000 --> 40:36.000]  И то, что у нас ссылка
[40:36.000 --> 40:38.000]  на str и str это разная вещь.
[40:42.000 --> 40:44.000]  Вообще,
[40:44.000 --> 40:46.000]  внутри raster я вам, конечно, говорил, что это
[40:46.000 --> 40:48.000]  два указателя на какое-то время, кажется.
[40:48.000 --> 40:50.000]  Я вам чуть-чуть собрал, это все-таки
[40:50.000 --> 40:52.000]  указатели и размер.
[40:52.000 --> 40:54.000]  То есть указатель на начало
[40:54.000 --> 40:56.000]  слайса и число батиков,
[40:56.000 --> 40:58.000]  которые у вас дальше идут.
[41:02.000 --> 41:04.000]  Ссылка на t
[41:06.000 --> 41:08.000]  Нет, это правда только для unsized
[41:08.000 --> 41:10.000]  типов.
[41:10.000 --> 41:12.000]  Это будет, как минимум,
[41:12.000 --> 41:14.000]  по очереди будем идти,
[41:14.000 --> 41:16.000]  это правда для слайсов.
[41:16.000 --> 41:18.000]  Для слайсов это правда.
[41:18.000 --> 41:20.000]  Еще там будет чуть-чуть другое
[41:20.000 --> 41:22.000]  ссылок на
[41:22.000 --> 41:24.000]  trait объект.
[41:26.000 --> 41:28.000]  Ну и естественно...
[41:30.000 --> 41:32.000]  Да, это все для того, чтобы у нас
[41:32.000 --> 41:34.000]  получился в итоге safe raster.
[41:34.000 --> 41:36.000]  Мы делаем тип t, который unsized
[41:36.000 --> 41:38.000]  и потом делаем ссылочку, которая уже
[41:38.000 --> 41:40.000]  sized.
[41:40.000 --> 41:42.000]  Чтобы у нас все в сумме получилось
[41:42.000 --> 41:44.000]  корректно.
[41:44.000 --> 41:46.000]  Давайте посмотрим на вот такой примерчик.
[41:46.000 --> 41:48.000]  Я создал trait hello.
[41:48.000 --> 41:50.000]  Теперь хочу в функциях
[41:50.000 --> 41:52.000]  принять слайс
[41:52.000 --> 41:54.000]  объектов, которые имплементируют hello.
[41:54.000 --> 41:56.000]  Все объекты, которые...
[41:56.000 --> 41:58.000]  Ну, просто чтобы везде
[41:58.000 --> 42:00.000]  вывести строчку hello.
[42:00.000 --> 42:02.000]  Как вы думаете, это скомпилируется?
[42:08.000 --> 42:10.000]  Ну, скорее всего, да. Не скомпилируется.
[42:12.000 --> 42:14.000]  Это не скомпилируется, потому что
[42:14.000 --> 42:16.000]  раз должен именно типа получать
[42:16.000 --> 42:18.000]  внутри слайсов.
[42:20.000 --> 42:22.000]  Он не знает размера типа hello.
[42:22.000 --> 42:24.000]  Он не знает...
[42:24.000 --> 42:26.000]  Дело в том, что много объектов может
[42:26.000 --> 42:28.000]  имплементировать trait hello.
[42:28.000 --> 42:30.000]  У них у всех могут быть разные размеры.
[42:30.000 --> 42:32.000]  В слайсах, естественно, не засунешь.
[42:34.000 --> 42:36.000]  Компилятор не понимает, что значит слайс
[42:36.000 --> 42:38.000]  объектов hello.
[42:38.000 --> 42:40.000]  И соответственно, ему нужно
[42:40.000 --> 42:42.000]  какая-то... Нужна какая-то другая информация.
[42:42.000 --> 42:44.000]  Давайте для начала пробуем
[42:44.000 --> 42:46.000]  сделать так.
[42:46.000 --> 42:48.000]  Засунем generic, скажем, что у нас
[42:48.000 --> 42:50.000]  какой-то tag, который имплементирует hello.
[42:50.000 --> 42:52.000]  Какой-то конкретный tag.
[42:52.000 --> 42:54.000]  И у нас будет слайс таких объектов.
[42:54.000 --> 42:56.000]  Скомпилируется ли такой вариант?
[43:06.000 --> 43:08.000]  Да. Да, это скомпилируется,
[43:08.000 --> 43:10.000]  потому что раз знает о том...
[43:10.000 --> 43:12.000]  На самом деле, мы здесь, напоминаю,
[43:12.000 --> 43:14.000]  не явно требуем, что t это size.
[43:16.000 --> 43:18.000]  Здесь на самом деле плюс size
[43:18.000 --> 43:20.000]  еще есть.
[43:20.000 --> 43:22.000]  Потому что у нас почти все объекты size
[43:22.000 --> 43:24.000]  на практике.
[43:26.000 --> 43:28.000]  Вот.
[43:28.000 --> 43:30.000]  Он будет для каждого отдельного типа t,
[43:30.000 --> 43:32.000]  так как это generic, имплементировать свою
[43:32.000 --> 43:34.000]  вот эту вот функцию.
[43:34.000 --> 43:36.000]  И, соответственно,
[43:36.000 --> 43:38.000]  вызывать нужную вариацию.
[43:38.000 --> 43:40.000]  Ну, все еще
[43:40.000 --> 43:42.000]  это же не то, что мы хотели.
[43:42.000 --> 43:44.000]  Это не то...
[43:44.000 --> 43:46.000]  Просто слайс
[43:46.000 --> 43:48.000]  объектов, которые выполняют
[43:48.000 --> 43:50.000]  trade.
[43:50.000 --> 43:52.000]  Это
[43:52.000 --> 43:54.000]  какой-то конкретный
[43:54.000 --> 43:56.000]  отдельный тип. А как получить так,
[43:56.000 --> 43:58.000]  чтобы у нас были
[43:58.000 --> 44:00.000]  разные типы?
[44:00.000 --> 44:02.000]  Кстати, еще
[44:02.000 --> 44:04.000]  подсмотрю, что у меня там в следующем.
[44:04.000 --> 44:06.000]  Да, это как раз тот вопрос, который задал.
[44:06.000 --> 44:08.000]  Вот.
[44:08.000 --> 44:10.000]  Да.
[44:10.000 --> 44:12.000]  Вот, давайте посмотрим сразу же на ответ.
[44:12.000 --> 44:14.000]  Так что мы его не угадаем.
[44:14.000 --> 44:16.000]  В Rasty есть такое ключевое слово,
[44:16.000 --> 44:18.000]  называется din.
[44:18.000 --> 44:20.000]  Оно означает, что этот объект
[44:20.000 --> 44:22.000]  динамический, то есть
[44:22.000 --> 44:24.000]  он будет в run-timer.
[44:24.000 --> 44:26.000]  В частности, у нас din hello
[44:26.000 --> 44:28.000]  это unsized
[44:28.000 --> 44:30.000]  тип, потому что мы не знаем, какой
[44:30.000 --> 44:32.000]  размер у типа,
[44:32.000 --> 44:34.000]  который имплементирует hello.
[44:34.000 --> 44:36.000]  А вот ссылка на din hello
[44:36.000 --> 44:38.000]  это уже понятная штука.
[44:38.000 --> 44:40.000]  Еще раз, у нас какой был вопрос,
[44:40.000 --> 44:42.000]  с чем проблема была?
[44:42.000 --> 44:44.000]  Смотри, а как нам сделать
[44:44.000 --> 44:46.000]  такой слайс, чтобы в нем были
[44:46.000 --> 44:48.000]  разные объекты и все имплементировали hello?
[44:48.000 --> 44:50.000]  Здесь же у нас конкретный тип,
[44:50.000 --> 44:52.000]  который имплементирует hello, они все одинаковые.
[44:52.000 --> 44:54.000]  Что если я хочу разные?
[44:54.000 --> 44:56.000]  Если в одном слайсе
[44:56.000 --> 44:58.000]  предъявляют разные объекты?
[44:58.000 --> 45:00.000]  Да.
[45:00.000 --> 45:02.000]  Алеотипы?
[45:02.000 --> 45:04.000]  Нет.
[45:18.000 --> 45:20.000]  Смотрите, у нас ссылка на din hello.
[45:20.000 --> 45:22.000]  Din hello, как я говорил, unsized тип.
[45:22.000 --> 45:24.000]  Это непонятная какая-то структура,
[45:24.000 --> 45:26.000]  которая имплементирует trade hello.
[45:26.000 --> 45:28.000]  А вот ссылочка на din hello
[45:28.000 --> 45:30.000]  это уже понятная штука, которая
[45:30.000 --> 45:32.000]  представляет 2 указателя.
[45:32.000 --> 45:34.000]  Это указатель на сам объект
[45:34.000 --> 45:36.000]  и указатель на vtable.
[45:36.000 --> 45:38.000]  Ponte virtual table.
[45:38.000 --> 45:40.000]  Что такое?
[45:40.000 --> 45:42.000]  Вот как раз
[45:42.000 --> 45:44.000]  будет виртуальная табличка
[45:44.000 --> 45:46.000]  методов hello.
[45:46.000 --> 45:48.000]  И мы будем вызывать их.
[45:48.000 --> 45:50.000]  То есть подставлять указатель на наш объект,
[45:50.000 --> 45:52.000]  находить нужную нам функцию,
[45:52.000 --> 45:54.000]  которую мы хотим вызвать,
[45:54.000 --> 45:56.000]  подставлять и вызывать
[45:56.000 --> 45:58.000]  правильную функцию.
[45:58.000 --> 46:00.000]  Попросим, какой массив
[46:00.000 --> 46:02.000]  это динамический массив?
[46:02.000 --> 46:04.000]  Мой?
[46:04.000 --> 46:06.000]  Нет, не может.
[46:06.000 --> 46:08.000]  Это точно такой же слайс, как если бы я
[46:08.000 --> 46:10.000]  написал, что вот здесь у tuple из U64
[46:10.000 --> 46:12.000]  и U64, по сути.
[46:12.000 --> 46:14.000]  По размерам будет тоже самое.
[46:14.000 --> 46:16.000]  Din hello это просто какой-то
[46:16.000 --> 46:18.000]  тип, который означает, что у нас
[46:18.000 --> 46:20.000]  указатель на trade объект.
[46:20.000 --> 46:22.000]  Это называется вообще trade объект.
[46:22.000 --> 46:24.000]  Din trade.
[46:24.000 --> 46:26.000]  Соответственно, какой-то trade.
[46:28.000 --> 46:30.000]  Дин создает
[46:30.000 --> 46:32.000]  trade объект,
[46:32.000 --> 46:34.000]  который имплементирует hello.
[46:36.000 --> 46:38.000]  Как я говорил, что
[46:38.000 --> 46:40.000]  din hello это какой-то
[46:40.000 --> 46:42.000]  unsized тип, потому что мы не знаем
[46:42.000 --> 46:44.000]  размер объекта, который его имплементирует.
[46:44.000 --> 46:46.000]  А вот ссылочка на din hello,
[46:46.000 --> 46:48.000]  это уже понятная вещь.
[46:48.000 --> 46:50.000]  Это virtual table и сам объект.
[46:50.000 --> 46:52.000]  Эта штука называется
[46:52.000 --> 46:54.000]  fat pointer.
[46:54.000 --> 46:56.000]  Если что, толстый указатель.
[46:56.000 --> 46:58.000]  В этом смысле
[46:58.000 --> 47:00.000]  мы можем раз встречаться, если будете
[47:00.000 --> 47:02.000]  читать про раз.
[47:02.000 --> 47:04.000]  В этом смысле.
[47:08.000 --> 47:10.000]  Ну да, можно сделать
[47:10.000 --> 47:12.000]  вектор ссылок на din hello.
[47:18.000 --> 47:20.000]  Смотри, на первой лекции мы говорили,
[47:20.000 --> 47:22.000]  что в расте ссылка это
[47:22.000 --> 47:24.000]  first class object.
[47:24.000 --> 47:26.000]  Потому что rast проверяет
[47:26.000 --> 47:28.000]  валидность этих ссылок.
[47:32.000 --> 47:34.000]  А в плюсах это reference for wrapper.
[47:34.000 --> 47:36.000]  Если только
[47:36.000 --> 47:38.000]  хочется так сделать.
[47:40.000 --> 47:42.000]  Более того, мы
[47:42.000 --> 47:44.000]  отсмотрели на ссылочку, но можем сделать даже так.
[47:44.000 --> 47:46.000]  Вот смотрите, я имплементировал hello для str.
[47:46.000 --> 47:48.000]  Обратите внимание, что str
[47:48.000 --> 47:50.000]  это unsized тип.
[47:50.000 --> 47:52.000]  Имплементировал для строкового slice
[47:52.000 --> 47:54.000]  hello.
[47:54.000 --> 47:56.000]  Ну и вывожу просто hello str.
[47:56.000 --> 47:58.000]  Ссылочка тут лишняя,
[47:58.000 --> 48:00.000]  я хотел просто str оставить.
[48:02.000 --> 48:04.000]  Потом я создаю slice
[48:04.000 --> 48:06.000]  и вызываю там
[48:06.000 --> 48:08.000]  создаю reference 1, reference 2
[48:08.000 --> 48:10.000]  и reference 3. R1 понятно,
[48:10.000 --> 48:12.000]  что такое. Мы с этим уже разобрались.
[48:12.000 --> 48:14.000]  Более того, мы можем
[48:14.000 --> 48:16.000]  создавать умные указатели
[48:16.000 --> 48:18.000]  на трейд объекта.
[48:18.000 --> 48:20.000]  То есть что-то,
[48:20.000 --> 48:22.000]  что имплементирует hello,
[48:22.000 --> 48:24.000]  у нас это
[48:24.000 --> 48:26.000]  box.new.xclone.
[48:26.000 --> 48:28.000]  Это на самом деле
[48:28.000 --> 48:30.000]  просто особенный синтаксис.
[48:30.000 --> 48:32.000]  Box во время
[48:32.000 --> 48:34.000]  инстанциализации своей
[48:34.000 --> 48:36.000]  он знает, сколько ему нужно выделить памяти
[48:36.000 --> 48:38.000]  под объект.
[48:38.000 --> 48:40.000]  Но после того, как мы ему сказали,
[48:40.000 --> 48:42.000]  что он теперь din.hello, он содержит
[48:42.000 --> 48:44.000]  указатель на vetable.
[48:44.000 --> 48:46.000]  То есть, когда мы говорим ему,
[48:46.000 --> 48:48.000]  что он создает
[48:48.000 --> 48:50.000]  какой-то din.hello объект,
[48:50.000 --> 48:52.000]  он выделяет память под t,
[48:52.000 --> 48:54.000]  но мы же знаем в данный момент,
[48:54.000 --> 48:56.000]  что у нас является
[48:56.000 --> 48:58.000]  строковым slice.
[49:00.000 --> 49:02.000]  Я выделяю память под этот тип t,
[49:02.000 --> 49:04.000]  а потом я еще добавляю
[49:04.000 --> 49:06.000]  vetable.
[49:06.000 --> 49:08.000]  И то же самое с rc.
[49:10.000 --> 49:12.000]  Reference counting.
[49:14.000 --> 49:16.000]  Box это уникальное владение rc,
[49:16.000 --> 49:18.000]  это много может быть.
[49:18.000 --> 49:20.000]  Chef.ptr, но
[49:20.000 --> 49:22.000]  однопоточный.
[49:22.000 --> 49:24.000]  Строго однопоточный.
[49:24.000 --> 49:26.000]  Еще, конечно,
[49:26.000 --> 49:28.000]  плохо, что на слайде не показало.
[49:28.000 --> 49:30.000]  Если вы где-нибудь сверху изvtx.hello,
[49:30.000 --> 49:32.000]  то, естественно, раз уж я имплементировал dester.hello,
[49:32.000 --> 49:34.000]  то оно успешно будет работать.
[49:38.000 --> 49:40.000]  Так, никто ли не потерялся?
[49:40.000 --> 49:42.000]  Точно никаких вопросов нет?
[49:44.000 --> 49:46.000]  Это мне кажется,
[49:46.000 --> 49:48.000]  что, наверное,
[49:48.000 --> 49:50.000]  все потерялись уже.
[49:58.000 --> 50:00.000]  Там почти везде
[50:00.000 --> 50:02.000]  в стандартной библиотеке
[50:02.000 --> 50:04.000]  подданца есть типы,
[50:04.000 --> 50:06.000]  так или иначе что-то.
[50:06.000 --> 50:08.000]  Ну, в общем, специальная есть
[50:08.000 --> 50:10.000]  и проблема.
[50:22.000 --> 50:24.000]  Если я возьму din.hello,
[50:24.000 --> 50:26.000]  то это объект непонятного размера.
[50:26.000 --> 50:28.000]  Это какая-то структура, которая имплементирует hello.
[50:28.000 --> 50:30.000]  Это может быть str,
[50:30.000 --> 50:32.000]  это может быть какой-то мой объект,
[50:32.000 --> 50:34.000]  который непонятного размера.
[50:34.000 --> 50:36.000]  din.hello непонятного размера.
[50:36.000 --> 50:38.000]  А если я беру ссылку на din.hello,
[50:38.000 --> 50:40.000]  то это trait.object,
[50:40.000 --> 50:42.000]  то есть это указатель на сам объект,
[50:42.000 --> 50:44.000]  ну, указатель понятного размера,
[50:44.000 --> 50:46.000]  и указатель на vtable.
[50:46.000 --> 50:48.000]  Vtable тоже, ну, указатель на vtable тоже понятного размера.
[50:48.000 --> 50:50.000]  Поэтому, соответственно, din.hello понятного размера
[50:50.000 --> 50:52.000]  мы можем его инициализировать на стеке,
[50:52.000 --> 50:54.000]  раз все понимает и все получается.
[50:54.000 --> 50:56.000]  А вот неизвестного размера,
[50:56.000 --> 50:58.000]  то есть trait может быть разных размеров,
[50:58.000 --> 51:00.000]  мы мылим, что
[51:00.000 --> 51:02.000]  в немногих переменах,
[51:02.000 --> 51:04.000]  а размер будет увеличиваться, есть функции будут создаваться,
[51:04.000 --> 51:08.000]  то есть почему может быть у трейта разный размер?
[51:08.000 --> 51:10.000]  В плане у трейта.
[51:10.000 --> 51:12.000]  Это у объектов,
[51:12.000 --> 51:14.000]  у объектов, которые имплементируют трейта,
[51:14.000 --> 51:16.000]  могут быть разные размеры.
[51:20.000 --> 51:22.000]  Так.
[51:22.000 --> 51:24.000]  Мы можем ключевым слове din.
[51:24.000 --> 51:26.000]  Извините.
[51:26.000 --> 51:28.000]  Прямо вопрос появился.
[51:28.000 --> 51:30.000]  В предыдущем слаге вот
[51:30.000 --> 51:32.000]  вот это din.hello,
[51:32.000 --> 51:34.000]  он вообще где будет хранить?
[51:34.000 --> 51:36.000]  Это на стеке.
[51:36.000 --> 51:38.000]  Ну, то есть это все разворачивается
[51:38.000 --> 51:40.000]  на этапе компиляции, он понимает,
[51:40.000 --> 51:42.000]  что на самом деле...
[51:42.000 --> 51:44.000]  Он на этапе компиляции создает vtable.hello
[51:44.000 --> 51:46.000]  где-то, кладет его.
[51:46.000 --> 51:48.000]  И когда он будет
[51:48.000 --> 51:50.000]  это компилировать, он, соответственно, положит
[51:50.000 --> 51:52.000]  в din.hello, то есть в r1,
[51:52.000 --> 51:54.000]  ссылочку на x где-то
[51:54.000 --> 51:56.000]  и рядышком он положит ссылочку на vtable.
[51:56.000 --> 51:58.000]  Он же знает, где
[51:58.000 --> 52:00.000]  hello vtable и знает,
[52:00.000 --> 52:02.000]  какой объект мы берем.
[52:02.000 --> 52:04.000]  Соответственно, получается
[52:04.000 --> 52:06.000]  два osize по размеру.
[52:06.000 --> 52:08.000]  Два указателя.
[52:08.000 --> 52:10.000]  Ну, и все будет на стеке.
[52:12.000 --> 52:14.000]  Так.
[52:16.000 --> 52:18.000]  Мы можем еще у din.trait
[52:18.000 --> 52:20.000]  требовать какие-то дополнительные...
[52:20.000 --> 52:22.000]  Ну, попробовать
[52:22.000 --> 52:24.000]  затребовать дополнительные
[52:24.000 --> 52:26.000]  трейты.
[52:26.000 --> 52:28.000]  Давайте попробуем это сделать.
[52:28.000 --> 52:30.000]  Создаем так x
[52:30.000 --> 52:32.000]  и пусть... Ну, hello
[52:32.000 --> 52:34.000]  и какой-то я там trait world создал так,
[52:34.000 --> 52:36.000]  чтобы вы не видели, да.
[52:36.000 --> 52:38.000]  Неважно, что он там имплементирует.
[52:38.000 --> 52:40.000]  Если я напишу din.hello plus world
[52:40.000 --> 52:42.000]  расскажет, что
[52:42.000 --> 52:44.000]  мы не можем затребовать
[52:44.000 --> 52:46.000]  больше, чем один trait здесь, не auto-trait.
[52:46.000 --> 52:48.000]  Что такое auto-trait?
[52:48.000 --> 52:50.000]  Ну, это такие штуки как send, sync.
[52:50.000 --> 52:52.000]  Мы с ними попозже познакомимся
[52:52.000 --> 52:54.000]  и включим словом auto.
[52:54.000 --> 52:56.000]  В общем,
[52:56.000 --> 52:58.000]  просто знайте, что пока что на данный момент
[52:58.000 --> 53:00.000]  все, что вы можете сделать, затребует только один trait.
[53:00.000 --> 53:02.000]  Включим слов 1.
[53:02.000 --> 53:04.000]  Если вы хотите больше трейтов,
[53:04.000 --> 53:06.000]  то вам нужно создать супертрейт и имплементировать.
[53:06.000 --> 53:08.000]  И тогда Rust корректно
[53:08.000 --> 53:10.000]  сделает vtable для этого дела.
[53:12.000 --> 53:14.000]  Кажется, как что-то, что очень легко
[53:14.000 --> 53:16.000]  добавить как фичу.
[53:16.000 --> 53:18.000]  Но, типа, это же...
[53:18.000 --> 53:20.000]  Почему не может сгенерировать
[53:20.000 --> 53:22.000]  hello world самостоятельно,
[53:22.000 --> 53:24.000]  если мы пишем hello plus world?
[53:24.000 --> 53:26.000]  Раз, за явность, поэтому
[53:26.000 --> 53:28.000]  тебе нужно будет явно создать такой trait.
[53:28.000 --> 53:30.000]  Все, что
[53:30.000 --> 53:32.000]  имплементирует hello world.
[53:32.000 --> 53:34.000]  Скажем так.
[53:34.000 --> 53:36.000]  Просто такой синтез,
[53:36.000 --> 53:38.000]  синтез-синтез-синтез-синтез.
[53:38.000 --> 53:40.000]  Ну, мне что-то кажется,
[53:40.000 --> 53:42.000]  что в связи с этим будут какие-то проблемы,
[53:42.000 --> 53:44.000]  если мы не будем прям явно
[53:44.000 --> 53:46.000]  создавать это дело.
[53:48.000 --> 53:50.000]  Так.
[53:50.000 --> 53:52.000]  Мы можем затребовать какие-то auto-trait.
[53:52.000 --> 53:54.000]  Вот, как я сказал, например, send и sync есть.
[53:54.000 --> 53:56.000]  Это такие для многопоточности трейта.
[53:56.000 --> 53:58.000]  Сильно опускаться пока не будем.
[53:58.000 --> 54:00.000]  Ну, маркерные трейты, они тоже для компилятора
[54:00.000 --> 54:02.000]  существуют.
[54:02.000 --> 54:04.000]  Ну, и мы тут пишем plus send,
[54:04.000 --> 54:06.000]  и оно все отлично скомпилируется и будет работать.
[54:10.000 --> 54:12.000]  Вот.
[54:12.000 --> 54:14.000]  Окей, давайте попробуем такой от код
[54:14.000 --> 54:16.000]  скомпилировать.
[54:16.000 --> 54:18.000]  Как вы думаете, скомпилируется?
[54:18.000 --> 54:20.000]  Я предыдущий момент.
[54:20.000 --> 54:22.000]  А вот вы же говорили, что
[54:22.000 --> 54:24.000]  только один можно
[54:24.000 --> 54:26.000]  трейд показать.
[54:26.000 --> 54:28.000]  Ну, я сказал, что можно только один,
[54:28.000 --> 54:30.000]  не auto-trait. Send это auto-trait.
[54:30.000 --> 54:32.000]  Его можно указывать.
[54:32.000 --> 54:34.000]  Ну, я просто так вот говорю, что вот есть такие трейты,
[54:34.000 --> 54:36.000]  типа send и sync, которые можно дописывать.
[54:36.000 --> 54:38.000]  То есть мы чуть попозже
[54:38.000 --> 54:40.000]  ознакомимся.
[54:40.000 --> 54:42.000]  Нам, по сути, на данный момент можно считать,
[54:42.000 --> 54:44.000]  что мы можем только один трейд дописывать,
[54:44.000 --> 54:46.000]  потому что мы не ознакомлены
[54:46.000 --> 54:48.000]  больше ни с чем.
[54:48.000 --> 54:50.000]  Интересно, вот это скомпилируется или нет?
[54:50.000 --> 54:52.000]  В принципе, наверное, плохо то, что я дописал тут send.
[54:52.000 --> 54:54.000]  Можете считать, что его тут нет.
[54:54.000 --> 54:56.000]  Все равно не скомпилируется.
[54:56.000 --> 54:58.000]  Скомпилируется.
[54:58.000 --> 55:00.000]  Чем это отличается от того,
[55:00.000 --> 55:02.000]  там был пт, какой-то.
[55:02.000 --> 55:04.000]  Тут просто клоун.
[55:04.000 --> 55:06.000]  Да, тут вот есть
[55:06.000 --> 55:08.000]  нюансик. Попробуйте догадаться,
[55:08.000 --> 55:10.000]  что тут не так.
[55:12.000 --> 55:14.000]  Сейчас отберешь то, что send на ответ
[55:14.000 --> 55:16.000]  не влияет.
[55:16.000 --> 55:18.000]  Да, send не влияет на ответ, поэтому
[55:18.000 --> 55:20.000]  я говорю, что его можно убрать.
[55:20.000 --> 55:22.000]  Убираем, думаю.
[55:22.000 --> 55:24.000]  Может быть, функционированные боксы,
[55:24.000 --> 55:26.000]  что-то еще.
[55:26.000 --> 55:28.000]  Логично, что для клоуна
[55:28.000 --> 55:30.000]  не будет работать. Как же он будет клонировать то,
[55:30.000 --> 55:32.000]  что не знает?
[55:32.000 --> 55:34.000]  Вот, нам дали точный ответ.
[55:34.000 --> 55:36.000]  Как мы можем узнать то, что мы клонируем вообще?
[55:36.000 --> 55:38.000]  Мы же не знаем тип, который мы будем возвращать.
[55:38.000 --> 55:40.000]  Мы когда делаем один клоун,
[55:40.000 --> 55:42.000]  то мы стираем тип.
[55:42.000 --> 55:44.000]  То есть, соответственно, а клоун что делает?
[55:44.000 --> 55:46.000]  Он берет self и возвращает клоун.
[55:46.000 --> 55:48.000]  Ну, возвращает self.
[55:48.000 --> 55:50.000]  То есть, это касается любых трейдов,
[55:50.000 --> 55:52.000]  у которого функции возвращают
[55:52.000 --> 55:54.000]  этот тип
[55:54.000 --> 55:56.000]  за трейдчину?
[55:56.000 --> 55:58.000]  Да. То есть, там есть
[55:58.000 --> 56:00.000]  некоторый набор правил, которые мы сейчас посмотрим.
[56:00.000 --> 56:02.000]  Это называется все правило object-safety.
[56:02.000 --> 56:04.000]  Давайте мы посмотрим
[56:04.000 --> 56:06.000]  на ошибку компиляции.
[56:06.000 --> 56:08.000]  Нам Rust явно говорит,
[56:08.000 --> 56:10.000]  что клоун не может
[56:10.000 --> 56:12.000]  стать объектом, скажем так.
[56:14.000 --> 56:16.000]  Cannot be made into object,
[56:16.000 --> 56:18.000]  потому что мы не знаем
[56:18.000 --> 56:20.000]  как сказать.
[56:20.000 --> 56:22.000]  Здесь, видите, есть второй ноут.
[56:22.000 --> 56:24.000]  Чтобы трейд был
[56:24.000 --> 56:26.000]  object-safe, ему необходимо
[56:28.000 --> 56:30.000]  чтобы мы могли
[56:30.000 --> 56:32.000]  зарезолвить типу динамически.
[56:32.000 --> 56:34.000]  Мы не можем зарезолвить тип динамически,
[56:34.000 --> 56:36.000]  потому что его стерли.
[56:36.000 --> 56:38.000]  Вот.
[56:38.000 --> 56:40.000]  Мы бы могли бы зарезолвить,
[56:40.000 --> 56:42.000]  если бы у нас был какой-нибудь, не знаю,
[56:42.000 --> 56:44.000]  один hello, и hello бы мы могли
[56:44.000 --> 56:46.000]  просто обратиться в vtable,
[56:46.000 --> 56:48.000]  у нас бы все работало.
[56:48.000 --> 56:50.000]  А здесь мы не можем, потому что у нас
[56:50.000 --> 56:52.000]  клоун возвращает self. Мы не знаем, какой
[56:52.000 --> 56:54.000]  self он возвращает.
[56:54.000 --> 56:56.000]  Давайте уточним конкретно,
[56:56.000 --> 56:58.000]  что происходит.
[56:58.000 --> 57:00.000]  Чтобы быть object-safe,
[57:00.000 --> 57:02.000]  никакие методы
[57:02.000 --> 57:04.000]  трейд не должны
[57:04.000 --> 57:06.000]  использовать тип self.
[57:06.000 --> 57:08.000]  Потому что если мы будем его
[57:08.000 --> 57:10.000]  использовать, то в таком случае мы не будем знать
[57:10.000 --> 57:12.000]  какой тип нам приходит
[57:12.000 --> 57:14.000]  на вход. Ну, например,
[57:14.000 --> 57:16.000]  не на вход, а вообще какой тип
[57:16.000 --> 57:18.000]  возвращать. Например, если мы будем
[57:18.000 --> 57:20.000]  возвращать self, как
[57:20.000 --> 57:22.000]  клоун, или, например, принимать
[57:22.000 --> 57:24.000]  на вход какой-нибудь второй аргумент, который
[57:24.000 --> 57:26.000]  тоже self. Откуда мы знаем, какой self?
[57:28.000 --> 57:30.000]  Более того, это трейд
[57:30.000 --> 57:32.000]  не может
[57:32.000 --> 57:34.000]  иметь никаких статических методов.
[57:34.000 --> 57:36.000]  Опять же, потому что мы не знаем
[57:36.000 --> 57:38.000]  никаких...
[57:40.000 --> 57:42.000]  не знаем типа self.
[57:42.000 --> 57:44.000]  Ну, у трейда можно тоже статик методов
[57:44.000 --> 57:46.000]  добавлять. Это получается
[57:46.000 --> 57:48.000]  я уже наперед забежал этими словами.
[57:52.000 --> 57:54.000]  И, например, у нас есть такой трейд,
[57:54.000 --> 57:56.000]  fromIterator. Если мы будем
[57:56.000 --> 57:58.000]  вызывать fromIterator, то мы не будем
[57:58.000 --> 58:00.000]  в таком примере, мы не будем знать
[58:00.000 --> 58:02.000]  какой код нам запустить.
[58:02.000 --> 58:04.000]  Потому что мы не знаем
[58:04.000 --> 58:06.000]  типа self.
[58:08.000 --> 58:10.000]  В общем, раз
[58:10.000 --> 58:12.000]  за вас будет за этим следить,
[58:12.000 --> 58:14.000]  за object safety, если вы будете
[58:14.000 --> 58:16.000]  динамически пытаться там какие-нибудь вещи
[58:16.000 --> 58:18.000]  типа клоун засунуть,
[58:18.000 --> 58:20.000]  то в таком случае он
[58:20.000 --> 58:22.000]  вас ударит по рукам.
[58:24.000 --> 58:26.000]  Вы знаете, что типа self
[58:26.000 --> 58:28.000]  нельзя использовать там, где у вас динамический
[58:28.000 --> 58:30.000]  хересолвик.
[58:30.000 --> 58:32.000]  Ну, по понятным причинам
[58:32.000 --> 58:34.000]  мы не знаем типа.
[58:34.000 --> 58:36.000]  В общем, это все как-то напоминает
[58:36.000 --> 58:38.000]  сложности в использовании стандарений плюсов.
[58:38.000 --> 58:40.000]  Кстати говоря, есть
[58:40.000 --> 58:42.000]  any врасти даже. И он даже
[58:42.000 --> 58:44.000]  умеет его типа выводить.
[58:46.000 --> 58:48.000]  Ну, там будет одна даже задача домашняя.
[58:48.000 --> 58:50.000]  Просто инханит.
[58:50.000 --> 58:52.000]  Намечение каска как-то
[58:52.000 --> 58:54.000]  можно полно объяснить вот этим приколом, что
[58:54.000 --> 58:56.000]  мы
[58:56.000 --> 58:58.000]  знаем.
[58:58.000 --> 59:00.000]  Так. С object safety
[59:00.000 --> 59:02.000]  вам все понятно? Ну, примерно
[59:02.000 --> 59:04.000]  понятно, да?
[59:04.000 --> 59:06.000]  Примерно, да.
[59:06.000 --> 59:08.000]  Примерно только, да.
[59:08.000 --> 59:10.000]  Ну, с этим надо положить.
[59:10.000 --> 59:12.000]  Это как SDMove.
[59:12.000 --> 59:14.000]  Ну, SDMove
[59:14.000 --> 59:16.000]  очень просто, наверное.
[59:16.000 --> 59:18.000]  Ну, нет, ну потом просто.
[59:18.000 --> 59:20.000]  Ну, да.
[59:20.000 --> 59:22.000]  А потом приходит кооперижинг такой, нет,
[59:22.000 --> 59:24.000]  все, закрываем.
[59:24.000 --> 59:26.000]  Так.
[59:26.000 --> 59:28.000]  Так еще раз. Есть ли вопросы про
[59:28.000 --> 59:30.000]  public safety?
[59:30.000 --> 59:32.000]  Окей. Дальше.
[59:32.000 --> 59:34.000]  Мы можем даже добавлять
[59:34.000 --> 59:36.000]  исключительно для
[59:36.000 --> 59:38.000]  trait-объектов какие-то дополнительные функции.
[59:38.000 --> 59:40.000]  И раз, то их запишет vtable.
[59:40.000 --> 59:42.000]  Например, я сделал
[59:42.000 --> 59:44.000]  какой-то trait-example.
[59:44.000 --> 59:46.000]  Я его
[59:46.000 --> 59:48.000]  не вместил на слайд, видимо, да.
[59:48.000 --> 59:50.000]  Вот у меня есть какой-то trait-example.
[59:50.000 --> 59:52.000]  Потом я добавил impaldine-example.
[59:54.000 --> 59:56.000]  И у меня есть там
[59:56.000 --> 59:58.000]  функция
[59:58.000 --> 01:00:00.000]  isDin, которая говорит, что у меня
[01:00:00.000 --> 01:00:02.000]  объект динамический. Ну, естественно,
[01:00:02.000 --> 01:00:04.000]  это будет труп, потому что у нас будет доступно
[01:00:04.000 --> 01:00:06.000]  только для динамических объектов.
[01:00:06.000 --> 01:00:08.000]  Создал какую-то структуру
[01:00:08.000 --> 01:00:10.000]  test, имплементировал для нее
[01:00:10.000 --> 01:00:12.000]  example. Создал
[01:00:12.000 --> 01:00:14.000]  x и y. x это
[01:00:14.000 --> 01:00:16.000]  вполне конкретная штука. Это тест.
[01:00:16.000 --> 01:00:18.000]  А y это boxDinExample.
[01:00:18.000 --> 01:00:20.000]  Внутри
[01:00:20.000 --> 01:00:22.000]  тоже тест содержит.
[01:00:22.000 --> 01:00:24.000]  Но мы об этом не знаем.
[01:00:24.000 --> 01:00:26.000]  Конечно, если мы напишем x из
[01:00:26.000 --> 01:00:28.000]  din, то, так как у нас
[01:00:28.000 --> 01:00:30.000]  это не динамический объект, расскажешь,
[01:00:30.000 --> 01:00:32.000]  что такой функции нет.
[01:00:32.000 --> 01:00:34.000]  А вот y из din уже скомпилируется,
[01:00:34.000 --> 01:00:36.000]  потому что dinExample у нас
[01:00:36.000 --> 01:00:38.000]  имплементирует dinExample.
[01:00:38.000 --> 01:00:40.000]  Вот так вот.
[01:00:44.000 --> 01:00:46.000]  В плане размер.
[01:00:46.000 --> 01:00:48.000]  Это просто штука, которая
[01:00:48.000 --> 01:00:50.000]  говорит, что вот
[01:00:50.000 --> 01:00:52.000]  в эту штуку нужно засунуть
[01:00:52.000 --> 01:00:54.000]  variable.
[01:01:00.000 --> 01:01:02.000]  Смотрите, у тест
[01:01:02.000 --> 01:01:04.000]  какие функции?
[01:01:04.000 --> 01:01:06.000]  Я не вместил.
[01:01:06.000 --> 01:01:08.000]  Это просто какой-то пустой трейд.
[01:01:08.000 --> 01:01:10.000]  У него нет никаких функций.
[01:01:10.000 --> 01:01:12.000]  А я еще добавил имплDinExample.
[01:01:12.000 --> 01:01:14.000]  Там есть из din. Соответственно, у x
[01:01:14.000 --> 01:01:16.000]  нет вообще никаких методов.
[01:01:16.000 --> 01:01:18.000]  А у y будет из din.
[01:01:18.000 --> 01:01:20.000]  Потому что я добавил
[01:01:20.000 --> 01:01:22.000]  vtable метод из din.
[01:01:26.000 --> 01:01:28.000]  ИмплDin означает,
[01:01:28.000 --> 01:01:30.000]  что мы имплементируем для трейд-объектов
[01:01:30.000 --> 01:01:32.000]  эту функцию.
[01:01:32.000 --> 01:01:34.000]  Только для трейд-объектов.
[01:01:34.000 --> 01:01:36.000]  То есть для того, что dinExample.
[01:01:36.000 --> 01:01:38.000]  Для них будет доступна эта функция.
[01:01:38.000 --> 01:01:40.000]  ИмплDinExample
[01:01:40.000 --> 01:01:42.000]  это какой-то
[01:01:42.000 --> 01:01:44.000]  тип, который
[01:01:44.000 --> 01:01:46.000]  реализует example.
[01:01:46.000 --> 01:01:48.000]  ИмплDinExample
[01:01:48.000 --> 01:01:50.000]  это какой-то
[01:01:50.000 --> 01:01:52.000]  трейд-объект.
[01:01:52.000 --> 01:01:54.000]  Это какой-то
[01:01:54.000 --> 01:01:56.000]  dinExample.
[01:01:56.000 --> 01:01:58.000]  Ну, а вот как
[01:01:58.000 --> 01:02:00.000]  в box он поймет
[01:02:00.000 --> 01:02:02.000]  размер
[01:02:02.000 --> 01:02:04.000]  dinExample?
[01:02:04.000 --> 01:02:06.000]  Там же нужно при создании box
[01:02:06.000 --> 01:02:08.000]  знать размер типа...
[01:02:08.000 --> 01:02:10.000]  Он же создает, когда box new
[01:02:10.000 --> 01:02:12.000]  он знает, что тест имеет нулевой размер
[01:02:12.000 --> 01:02:14.000]  и что, по факту, раз даже не будет
[01:02:14.000 --> 01:02:16.000]  ничего лоцировать, потому что там нулевой размер.
[01:02:16.000 --> 01:02:18.000]  Такая оптимизация будет.
[01:02:18.000 --> 01:02:20.000]  И в итоге там будет
[01:02:20.000 --> 01:02:22.000]  только ссылочка на vtable.
[01:02:22.000 --> 01:02:24.000]  А если у нас
[01:02:24.000 --> 01:02:26.000]  example2 реализовывал example?
[01:02:26.000 --> 01:02:28.000]  Этот метод был у dinExample2?
[01:02:28.000 --> 01:02:30.000]  Еще раз.
[01:02:30.000 --> 01:02:32.000]  Если у нас example2 реализовывал
[01:02:32.000 --> 01:02:34.000]  example?
[01:02:34.000 --> 01:02:36.000]  example2 это какая-то структура?
[01:02:36.000 --> 01:02:38.000]  Трейд.
[01:02:38.000 --> 01:02:40.000]  Он требует это супертрейд, он
[01:02:40.000 --> 01:02:42.000]  example требует.
[01:02:42.000 --> 01:02:44.000]  У dinExample2 был вот этот метод?
[01:02:44.000 --> 01:02:46.000]  В плане...
[01:02:46.000 --> 01:02:48.000]  Подожди, я создаю супертрейд.
[01:02:48.000 --> 01:02:50.000]  Наследует ли супертрейд
[01:02:50.000 --> 01:02:52.000]  содержимое имплемента отсвете номеров?
[01:02:52.000 --> 01:02:54.000]  Ну да, будет.
[01:03:02.000 --> 01:03:04.000]  Так.
[01:03:04.000 --> 01:03:06.000]  Вот есть такой еще интересный вопрос.
[01:03:06.000 --> 01:03:08.000]  Когда нам предпочитать трейд-объекты
[01:03:08.000 --> 01:03:10.000]  генериком и наоборот?
[01:03:12.000 --> 01:03:14.000]  Да,
[01:03:14.000 --> 01:03:16.000]  это именно этот вопрос.
[01:03:16.000 --> 01:03:18.000]  Ну раз уж мы уже знаем
[01:03:18.000 --> 01:03:20.000]  про какой вопрос речь, давайте попробуем
[01:03:20.000 --> 01:03:22.000]  ответить.
[01:03:22.000 --> 01:03:24.000]  Чем же генерики лучше?
[01:03:24.000 --> 01:03:26.000]  Ой, ну ничего.
[01:03:26.000 --> 01:03:28.000]  Капиллятор
[01:03:28.000 --> 01:03:30.000]  помогает с ними.
[01:03:32.000 --> 01:03:34.000]  С динобъектами, как видишь, у нас тоже
[01:03:34.000 --> 01:03:36.000]  помогает.
[01:03:42.000 --> 01:03:44.000]  Так. Ладно, тогда давайте
[01:03:44.000 --> 01:03:46.000]  я буду за вас отвечать.
[01:03:46.000 --> 01:03:48.000]  Я немного не понимаю вопрос.
[01:03:48.000 --> 01:03:50.000]  Там создавать условно функции
[01:03:50.000 --> 01:03:52.000]  принимающих генериков?
[01:03:52.000 --> 01:03:54.000]  Да, ты можешь создавать функции, которые
[01:03:54.000 --> 01:03:56.000]  принимают dinTrade.
[01:03:56.000 --> 01:03:58.000]  Можешь сказать, например, функция,
[01:03:58.000 --> 01:04:00.000]  которая принимает tMyTrade,
[01:04:00.000 --> 01:04:02.000]  а можешь сказать, функция,
[01:04:02.000 --> 01:04:04.000]  которая принимает dinMyTrade.
[01:04:06.000 --> 01:04:08.000]  Например.
[01:04:10.000 --> 01:04:12.000]  Мы используем, что негр получит,
[01:04:12.000 --> 01:04:14.000]  пожалуй, по фигуре пользователь
[01:04:14.000 --> 01:04:16.000]  и код за счет конкретных
[01:04:16.000 --> 01:04:18.000]  типов. Да, это может
[01:04:18.000 --> 01:04:20.000]  помочь.
[01:04:20.000 --> 01:04:22.000]  За счет того, что мы знаем конкретный
[01:04:22.000 --> 01:04:24.000]  tpt, мы можем делать для него специальные
[01:04:24.000 --> 01:04:26.000]  оптимизации и, соответственно, ускорять код.
[01:04:26.000 --> 01:04:28.000]  Какие минусы у генериков?
[01:04:32.000 --> 01:04:34.000]  Нет вот этой гиторогенности, типа,
[01:04:34.000 --> 01:04:36.000]  что нельзя делать массив
[01:04:36.000 --> 01:04:38.000]  имплементов одного генерика, не использовать
[01:04:38.000 --> 01:04:40.000]  ритм. Давай предположим,
[01:04:40.000 --> 01:04:42.000]  что мы рассматриваем только ситуации, где и то
[01:04:42.000 --> 01:04:44.000]  и то возможно использовать.
[01:04:46.000 --> 01:04:48.000]  Интересно.
[01:05:06.000 --> 01:05:08.000]  Так, давайте попробуем.
[01:05:08.000 --> 01:05:10.000]  Сейчас.
[01:05:12.000 --> 01:05:14.000]  Ну, что-то типа вот это.
[01:05:16.000 --> 01:05:18.000]  Ну, вот как-то...
[01:05:18.000 --> 01:05:20.000]  Ну, смотрите. Во-первых, трейд объекта
[01:05:20.000 --> 01:05:22.000]  это только одна функция.
[01:05:22.000 --> 01:05:24.000]  То есть мы создадим только один
[01:05:24.000 --> 01:05:26.000]  экземпляр функции.
[01:05:26.000 --> 01:05:28.000]  Ну, если там, конечно, нет каких-то дополнительных генериков
[01:05:28.000 --> 01:05:30.000]  или что-то в этом, то будет один экземплярчик
[01:05:30.000 --> 01:05:32.000]  функции, который будет
[01:05:32.000 --> 01:05:34.000]  сравнительно небольшой.
[01:05:34.000 --> 01:05:36.000]  Если у нас в случае генерика
[01:05:36.000 --> 01:05:38.000]  может функцию
[01:05:38.000 --> 01:05:40.000]  100 типов, допустим, разных
[01:05:40.000 --> 01:05:42.000]  передаваться, то у нас будет 100 разных
[01:05:42.000 --> 01:05:44.000]  инстанцев. А в случае
[01:05:44.000 --> 01:05:46.000]  динамической диспетчеризации
[01:05:46.000 --> 01:05:48.000]  у нас будет только одна функция.
[01:05:48.000 --> 01:05:50.000]  И это, на самом деле,
[01:05:50.000 --> 01:05:52.000]  хорошо в том смысле,
[01:05:52.000 --> 01:05:54.000]  что это трейд объекта,
[01:05:54.000 --> 01:05:56.000]  они мешают код bloat.
[01:05:56.000 --> 01:05:58.000]  Ну, знаете, когда у нас
[01:05:58.000 --> 01:06:00.000]  очень-очень много разных типов,
[01:06:00.000 --> 01:06:02.000]  то в таком случае у нас на каждого
[01:06:02.000 --> 01:06:04.000]  есть своя функция и, соответственно, очень-очень
[01:06:04.000 --> 01:06:06.000]  много кода. У нас становится
[01:06:06.000 --> 01:06:08.000]  огромный бинарник, мы перестаем
[01:06:08.000 --> 01:06:10.000]  влезать в кэшпроцессор,
[01:06:10.000 --> 01:06:12.000]  и это плохо.
[01:06:12.000 --> 01:06:14.000]  А вот одна функция
[01:06:14.000 --> 01:06:16.000]  динамической диспетчеризации уже будет
[01:06:16.000 --> 01:06:18.000]  прекрасно влезать, и даже, возможно,
[01:06:18.000 --> 01:06:20.000]  какие-то специальные
[01:06:20.000 --> 01:06:22.000]  оптимизации никакой
[01:06:22.000 --> 01:06:24.000]  речи не играют,
[01:06:24.000 --> 01:06:26.000]  когда у нас все влезает в кэшпроцессор.
[01:06:26.000 --> 01:06:28.000]  С другой стороны, нам
[01:06:28.000 --> 01:06:30.000]  наверное не очень нравится постоянно ходить
[01:06:30.000 --> 01:06:32.000]  по указателю в объект.
[01:06:32.000 --> 01:06:34.000]  Ладно, по указателю в объект нам не нужно
[01:06:34.000 --> 01:06:36.000]  ходить, но вот vtable нам нужно ходить.
[01:06:36.000 --> 01:06:38.000]  vtable ходить
[01:06:38.000 --> 01:06:40.000]  достаточно плохо.
[01:06:40.000 --> 01:06:42.000]  Вот, мы не хотим
[01:06:42.000 --> 01:06:44.000]  диреференситься.
[01:06:44.000 --> 01:06:46.000]  Вот, как я сказал, у нас
[01:06:46.000 --> 01:06:48.000]  стоит объекты дают меньше кода,
[01:06:48.000 --> 01:06:50.000]  соответственно,
[01:06:50.000 --> 01:06:52.000]  но они требуют того, чтобы
[01:06:52.000 --> 01:06:54.000]  мы читали vtable.
[01:06:54.000 --> 01:06:56.000]  С другой стороны, дженерики
[01:06:56.000 --> 01:06:58.000]  они обычно быстрее,
[01:06:58.000 --> 01:07:00.000]  потому что они
[01:07:00.000 --> 01:07:02.000]  type-specific оптимизации
[01:07:02.000 --> 01:07:04.000]  включают для компилятора.
[01:07:06.000 --> 01:07:08.000]  Вот.
[01:07:08.000 --> 01:07:10.000]  Но
[01:07:10.000 --> 01:07:12.000]  есть проблема, что
[01:07:12.000 --> 01:07:14.000]  когда есть много типов, которые
[01:07:14.000 --> 01:07:16.000]  имплементируют дженерик-функции, в таком случае у нас
[01:07:16.000 --> 01:07:18.000]  становится много функций,
[01:07:18.000 --> 01:07:20.000]  и они не влезают просто в память процессора,
[01:07:20.000 --> 01:07:22.000]  в кэш.
[01:07:22.000 --> 01:07:24.000]  И в этом кейсе уже
[01:07:24.000 --> 01:07:26.000]  trait-объекты будут быстрее, конечно же.
[01:07:26.000 --> 01:07:28.000]  Но, как вы понимаете,
[01:07:28.000 --> 01:07:30.000]  общий ответ, это, в общем-то,
[01:07:30.000 --> 01:07:32.000]  всегда профилируете код.
[01:07:32.000 --> 01:07:34.000]  Вы заранее,
[01:07:34.000 --> 01:07:36.000]  ну, возможно, если глаз наметом
[01:07:36.000 --> 01:07:38.000]  ответите, конечно, на этот вопрос.
[01:07:40.000 --> 01:07:42.000]  Но, in general,
[01:07:44.000 --> 01:07:46.000]  лучше попрофилируйте код, чтобы
[01:07:46.000 --> 01:07:48.000]  понять.
[01:07:50.000 --> 01:07:52.000]  Никто не потерялся?
[01:07:58.000 --> 01:08:00.000]  Так. Понятно ли
[01:08:00.000 --> 01:08:02.000]  примерно с типами
[01:08:02.000 --> 01:08:04.000]  необычного размера?
[01:08:06.000 --> 01:08:08.000]  Что они примерно в себе представляют?
[01:08:10.000 --> 01:08:12.000]  Ужас какой.
[01:08:14.000 --> 01:08:16.000]  Может, закроем дверь?
[01:08:32.000 --> 01:08:34.000]  Так, давайте поговорим про
[01:08:34.000 --> 01:08:36.000]  типы
[01:08:36.000 --> 01:08:38.000]  traits, то есть стандартной библиотеки.
[01:08:38.000 --> 01:08:40.000]  Поговорим примерно минут 10,
[01:08:40.000 --> 01:08:42.000]  после этого пойдем на перерыв.
[01:08:44.000 --> 01:08:46.000]  Вот. В первой лекции я вам говорил
[01:08:46.000 --> 01:08:48.000]  про средства кода генерации, например,
[01:08:48.000 --> 01:08:50.000]  про bring.tlm.
[01:08:50.000 --> 01:08:52.000]  В том числе вы и в домашней
[01:08:52.000 --> 01:08:54.000]  это видели, и в примерах лекции есть
[01:08:54.000 --> 01:08:56.000]  такой macros derived, который позволяет
[01:08:56.000 --> 01:08:58.000]  автоматически выводить какие-то стандартные
[01:08:58.000 --> 01:09:00.000]  библиотечные traits.
[01:09:00.000 --> 01:09:02.000]  Ну, и не только библиотечные.
[01:09:02.000 --> 01:09:04.000]  Вы можете написать свои macros.
[01:09:04.000 --> 01:09:06.000]  Такие macros называются процедурными,
[01:09:06.000 --> 01:09:08.000]  то есть они генерируют за нас код.
[01:09:10.000 --> 01:09:12.000]  Вот. В то время как macros вроде
[01:09:12.000 --> 01:09:14.000]  bring.tlm это декларативное,
[01:09:14.000 --> 01:09:16.000]  подробнее мы поговорим про это попозже.
[01:09:16.000 --> 01:09:18.000]  Но просто чтобы вы не пугались,
[01:09:18.000 --> 01:09:20.000]  derived macros это вещь, которая
[01:09:20.000 --> 01:09:22.000]  автоматически как-то имплементирует
[01:09:22.000 --> 01:09:24.000]  trait, ну, для нас.
[01:09:24.000 --> 01:09:26.000]  Обычно там какой-то очень
[01:09:26.000 --> 01:09:28.000]  линейный простой характер имплементации,
[01:09:28.000 --> 01:09:30.000]  то есть, например, в случае клон
[01:09:30.000 --> 01:09:32.000]  склонировать каждый тип отдельно.
[01:09:38.000 --> 01:09:40.000]  Нет, свою версию macros не можем,
[01:09:40.000 --> 01:09:42.000]  но можно написать macros под свои traits.
[01:09:42.000 --> 01:09:44.000]  Будем это делать.
[01:09:46.000 --> 01:09:48.000]  То есть, чтобы пользователю было удобно
[01:09:48.000 --> 01:09:50.000]  писать derived и какой-нибудь наш macros.
[01:09:54.000 --> 01:09:56.000]  Вот.
[01:09:56.000 --> 01:09:58.000]  Давайте начнем с default, самый простой.
[01:09:58.000 --> 01:10:00.000]  У него есть drive default macro.
[01:10:00.000 --> 01:10:02.000]  Если у нас все типы внутри структуры
[01:10:02.000 --> 01:10:04.000]  имплементировать default, то в таком случае
[01:10:04.000 --> 01:10:06.000]  default имплементирован.
[01:10:06.000 --> 01:10:08.000]  Все, что делает default, это
[01:10:08.000 --> 01:10:10.000]  просто возвращает
[01:10:10.000 --> 01:10:12.000]  какую-то default имплементацию объекта.
[01:10:12.000 --> 01:10:14.000]  Для чисел там будут нули,
[01:10:14.000 --> 01:10:16.000]  для options будут
[01:10:16.000 --> 01:10:18.000]  noun, да.
[01:10:18.000 --> 01:10:20.000]  Мы можем
[01:10:20.000 --> 01:10:22.000]  trait default имплементировать
[01:10:22.000 --> 01:10:24.000]  самостоятельными руками.
[01:10:24.000 --> 01:10:26.000]  Например, если у нас default имплементация
[01:10:26.000 --> 01:10:28.000]  по нашему мнению
[01:10:28.000 --> 01:10:30.000]  должна содержать какие-то единички
[01:10:30.000 --> 01:10:32.000]  там внутри, не знаю,
[01:10:32.000 --> 01:10:34.000]  как нам хочется,
[01:10:34.000 --> 01:10:36.000]  то мы можем это написать ручками.
[01:10:36.000 --> 01:10:38.000]  Вот.
[01:10:40.000 --> 01:10:42.000]  Да.
[01:10:42.000 --> 01:10:44.000]  Ну, это удобно в том смысле,
[01:10:44.000 --> 01:10:46.000]  что, например, как мы
[01:10:46.000 --> 01:10:48.000]  видели с options, там есть unwrap for default
[01:10:48.000 --> 01:10:50.000]  и вообще
[01:10:50.000 --> 01:10:52.000]  очень много всяких структур
[01:10:52.000 --> 01:10:54.000]  в библиотеке,
[01:10:54.000 --> 01:10:56.000]  смотрят на наличие trait default.
[01:11:00.000 --> 01:11:02.000]  Вот. Ну, просто чтобы
[01:11:02.000 --> 01:11:04.000]  нам было удобно. Это такое...
[01:11:04.000 --> 01:11:06.000]  Знаете, мы не можем
[01:11:06.000 --> 01:11:08.000]  абстрагироваться по всем типам,
[01:11:08.000 --> 01:11:10.000]  которые имеет конструктор new,
[01:11:10.000 --> 01:11:12.000]  но мы можем абстрагироваться по всем,
[01:11:12.000 --> 01:11:14.000]  в которых есть default какой-то конструктор.
[01:11:14.000 --> 01:11:16.000]  Это, грубо говоря, наличие
[01:11:16.000 --> 01:11:18.000]  default-ного конструктора.
[01:11:20.000 --> 01:11:22.000]  Еще давайте, чтобы закрепить
[01:11:22.000 --> 01:11:24.000]  obj-safe-ли это trait.
[01:11:26.000 --> 01:11:28.000]  Да, это не obj-safe-trait,
[01:11:28.000 --> 01:11:30.000]  потому что он защищает self.
[01:11:40.000 --> 01:11:42.000]  А если у тебя будет din-default,
[01:11:42.000 --> 01:11:44.000]  то это не скомпилируется по той причине,
[01:11:44.000 --> 01:11:46.000]  что когда ты будешь пытаться вызвать у объекта
[01:11:46.000 --> 01:11:48.000]  default, то не будешь знать, какой тип
[01:11:48.000 --> 01:11:50.000]  возвращать. Тип stirred.
[01:11:50.000 --> 01:11:52.000]  То есть только указатель на объект и указатель
[01:11:52.000 --> 01:11:54.000]  на vetable.
[01:12:04.000 --> 01:12:06.000]  Default имплементировали.
[01:12:10.000 --> 01:12:12.000]  Да, он скажет, один из объектов
[01:12:12.000 --> 01:12:14.000]  не имплементировал default.
[01:12:16.000 --> 01:12:18.000]  Ну, это eror. Просто скажет, ну вот
[01:12:18.000 --> 01:12:20.000]  я не знаю, имплементируют default
[01:12:20.000 --> 01:12:22.000]  либо руками, либо имплементируют для этого типа
[01:12:22.000 --> 01:12:24.000]  для начала.
[01:12:28.000 --> 01:12:30.000]  Ну, конечно, удобнее
[01:12:30.000 --> 01:12:32.000]  default имплементировать для того единственного
[01:12:32.000 --> 01:12:34.000]  типа, но если
[01:12:34.000 --> 01:12:36.000]  default категорически для того типа
[01:12:36.000 --> 01:12:38.000]  нельзя, то, к сожалению, придется руками.
[01:12:38.000 --> 01:12:40.000]  Default предназначен для такого линейного,
[01:12:40.000 --> 01:12:42.000]  максимально простого имплементации.
[01:12:42.000 --> 01:12:44.000]  Вот.
[01:12:46.000 --> 01:12:48.000]  Это как раз то, что я сказал.
[01:12:48.000 --> 01:12:50.000]  Мы не можем абстрагироваться по всему,
[01:12:50.000 --> 01:12:52.000]  что имеет new, но мы можем абстрагироваться по всему,
[01:12:52.000 --> 01:12:54.000]  что имеет default.
[01:12:56.000 --> 01:12:58.000]  Вот. А почему этот trait по умолчанию
[01:12:58.000 --> 01:13:00.000]  не выводится в расти?
[01:13:00.000 --> 01:13:02.000]  Вот, если все имплементирует default,
[01:13:02.000 --> 01:13:04.000]  почему бы там не вывести default?
[01:13:08.000 --> 01:13:10.000]  Ну, стандартный билотичный
[01:13:10.000 --> 01:13:12.000]  библиотип вроде бы все имплементируют.
[01:13:12.000 --> 01:13:14.000]  Vector имплементирует, option имплементирует,
[01:13:14.000 --> 01:13:16.000]  всякие числа имплементирует.
[01:13:16.000 --> 01:13:18.000]  Вот. Ну, очень-очень много
[01:13:18.000 --> 01:13:20.000]  объектов имплементирует.
[01:13:20.000 --> 01:13:22.000]  То есть, можно считать, что практически
[01:13:22.000 --> 01:13:24.000]  вся стандартная библиотека этим traitом
[01:13:24.000 --> 01:13:26.000]  пользуется.
[01:13:26.000 --> 01:13:28.000]  Вот.
[01:13:50.000 --> 01:13:52.000]  Так, что у меня там дальше будет?
[01:13:52.000 --> 01:13:54.000]  Там будет call.
[01:13:54.000 --> 01:13:56.000]  Вот.
[01:13:56.000 --> 01:13:58.000]  Ну, на самом деле, просто потому, что Rast
[01:13:58.000 --> 01:14:00.000]  не хочет ничего автоматически за вас
[01:14:00.000 --> 01:14:02.000]  имплементировать. Он хочет, чтобы
[01:14:02.000 --> 01:14:04.000]  все указали руками.
[01:14:04.000 --> 01:14:06.000]  Это на самом деле несложно дописать
[01:14:06.000 --> 01:14:08.000]  derive default, если вам это нужно.
[01:14:08.000 --> 01:14:10.000]  Либо, если у вас какой-то custom-naked
[01:14:10.000 --> 01:14:12.000]  behavior, то вы напишите
[01:14:12.000 --> 01:14:14.000]  самостоятельно.
[01:14:14.000 --> 01:14:16.000]  Ну, то есть, это нужно для того,
[01:14:16.000 --> 01:14:18.000]  чтобы продолжать
[01:14:18.000 --> 01:14:20.000]  то, что Rast ничего умолчания
[01:14:20.000 --> 01:14:22.000]  от типов не требует.
[01:14:22.000 --> 01:14:24.000]  И в том числе
[01:14:24.000 --> 01:14:26.000]  еще есть проблема, что если у вас
[01:14:26.000 --> 01:14:28.000]  default все-таки другой, он у вас
[01:14:28.000 --> 01:14:30.000]  имплементировался автоматически.
[01:14:30.000 --> 01:14:32.000]  В таком случае, а вдруг у вас
[01:14:32.000 --> 01:14:34.000]  не устраивает default имплементация,
[01:14:34.000 --> 01:14:36.000]  а вы об этом забыли просто.
[01:14:36.000 --> 01:14:38.000]  Забыли ее изменить.
[01:14:38.000 --> 01:14:40.000]  Или удалить. И в таком случае у вас
[01:14:40.000 --> 01:14:42.000]  будет ошибка в коде.
[01:14:42.000 --> 01:14:44.000]  Ну, то есть, здесь Rast
[01:14:44.000 --> 01:14:46.000]  явно от вас требует.
[01:14:46.000 --> 01:14:48.000]  Чтобы вывели
[01:14:48.000 --> 01:14:50.000]  default.
[01:14:50.000 --> 01:14:52.000]  Вот.
[01:14:52.000 --> 01:14:54.000]  Есть еще clone.
[01:14:54.000 --> 01:14:56.000]  У него тоже есть macros.
[01:14:56.000 --> 01:14:58.000]  У него есть
[01:14:58.000 --> 01:15:00.000]  clone, как мы уже видели.
[01:15:00.000 --> 01:15:02.000]  А еще есть такой вот clone from,
[01:15:02.000 --> 01:15:04.000]  у которого есть default имплементация.
[01:15:04.000 --> 01:15:06.000]  Это достаточно такое
[01:15:06.000 --> 01:15:08.000]  общее правило для стандартной библиотеки.
[01:15:08.000 --> 01:15:10.000]  Бывают дополнительные
[01:15:10.000 --> 01:15:12.000]  удобные методы, которые
[01:15:12.000 --> 01:15:14.000]  default-но как-то имплементированы.
[01:15:14.000 --> 01:15:16.000]  На основе того, что
[01:15:16.000 --> 01:15:18.000]  уже вот есть.
[01:15:18.000 --> 01:15:20.000]  Например, на основе clone, который есть в этом трейде,
[01:15:20.000 --> 01:15:22.000]  мы создаем clone from.
[01:15:24.000 --> 01:15:26.000]  Ну и почему же этот трейд по default-у
[01:15:26.000 --> 01:15:28.000]  не имплементировается?
[01:15:28.000 --> 01:15:30.000]  Да, по той же причине, абсолютно.
[01:15:30.000 --> 01:15:32.000]  Причем с clone
[01:15:32.000 --> 01:15:34.000]  на самом деле ситуация даже
[01:15:34.000 --> 01:15:36.000]  хуже, чем с default-ом, потому что
[01:15:36.000 --> 01:15:38.000]  clone еще
[01:15:38.000 --> 01:15:40.000]  в общем такая вещь, которая может вас
[01:15:40.000 --> 01:15:42.000]  вызвать даже unsafety
[01:15:42.000 --> 01:15:44.000]  в Rast.
[01:15:44.000 --> 01:15:46.000]  Если вы будете очень...
[01:15:46.000 --> 01:15:48.000]  Напоминаю, в save Rast невозможно
[01:15:48.000 --> 01:15:50.000]  вызвать undefinedBehaviour и memory
[01:15:50.000 --> 01:15:52.000]  unsafety, но если вы будете как-то
[01:15:52.000 --> 01:15:54.000]  очень некорректно использовать clone и unsave,
[01:15:54.000 --> 01:15:56.000]  даже не очень некорректно,
[01:15:56.000 --> 01:15:58.000]  если у вас где-то будет unsave и clone,
[01:15:58.000 --> 01:16:00.000]  то в таком случае очень легко сделать ошибку.
[01:16:00.000 --> 01:16:02.000]  Мы там чуть-чуть попозже
[01:16:02.000 --> 01:16:04.000]  посмотрим, как можно просто банально
[01:16:04.000 --> 01:16:06.000]  когда вы проектируете стандартную
[01:16:06.000 --> 01:16:08.000]  библиотеку, затребовать чуть-чуть
[01:16:08.000 --> 01:16:10.000]  больше, чем нужно, и за счет этого
[01:16:10.000 --> 01:16:12.000]  получить
[01:16:12.000 --> 01:16:14.000]  случайный memory unsafety в Rast.
[01:16:14.000 --> 01:16:16.000]  Ну, такого нет, конечно,
[01:16:16.000 --> 01:16:18.000]  в Rast. В Rast нет memory unsafety,
[01:16:18.000 --> 01:16:20.000]  но просто будет пример такой
[01:16:20.000 --> 01:16:22.000]  inocelec, который мы посмотрим.
[01:16:24.000 --> 01:16:26.000]  Вот.
[01:16:26.000 --> 01:16:28.000]  Есть такой тип копия.
[01:16:28.000 --> 01:16:30.000]  Вот.
[01:16:30.000 --> 01:16:32.000]  У него есть derived-копия macro.
[01:16:32.000 --> 01:16:34.000]  Ну, этот macro, по сути, просто пишет там,
[01:16:34.000 --> 01:16:36.000]  что impo copy for type
[01:16:36.000 --> 01:16:38.000]  и все. То есть там же нет никаких
[01:16:38.000 --> 01:16:40.000]  типов. Это маркерный
[01:16:40.000 --> 01:16:42.000]  trait. Он для компилятора существует.
[01:16:42.000 --> 01:16:44.000]  И он означает то, что мы просто
[01:16:44.000 --> 01:16:46.000]  копируем бита.
[01:16:46.000 --> 01:16:48.000]  То, что вы говорили,
[01:16:48.000 --> 01:16:50.000]  ну вот, вас спутало.
[01:16:50.000 --> 01:16:52.000]  Есть такая штука в Rast как move
[01:16:52.000 --> 01:16:54.000]  semantics, а есть такая штука,
[01:16:54.000 --> 01:16:56.000]  которая называется copy semantics.
[01:16:56.000 --> 01:16:58.000]  Copy semantics,
[01:16:58.000 --> 01:17:00.000]  то помните, мы там делали let x
[01:17:00.000 --> 01:17:02.000]  равняется 42, потом let y
[01:17:02.000 --> 01:17:04.000]  равняется x, и
[01:17:04.000 --> 01:17:06.000]  если с вектором, допустим, там происходил move
[01:17:06.000 --> 01:17:08.000]  и x был больше недоступен,
[01:17:08.000 --> 01:17:10.000]  то в данном случае у нас
[01:17:10.000 --> 01:17:12.000]  x остается доступен, а y копируется
[01:17:12.000 --> 01:17:14.000]  просто. Ну, то есть это уже
[01:17:14.000 --> 01:17:16.000]  copy semantics.
[01:17:16.000 --> 01:17:18.000]  Как видите, это такой маркерный trait, который
[01:17:18.000 --> 01:17:20.000]  меняет то, как компилятор работает с вашим
[01:17:20.000 --> 01:17:22.000]  типом.
[01:17:30.000 --> 01:17:32.000]  Нет, если
[01:17:32.000 --> 01:17:34.000]  copy это еще более сильно, чем
[01:17:34.000 --> 01:17:36.000]  clone.
[01:17:40.000 --> 01:17:42.000]  Ну, смотри,
[01:17:42.000 --> 01:17:44.000]  если у тебя
[01:17:44.000 --> 01:17:46.000]  клонирование в случае
[01:17:46.000 --> 01:17:48.000]  какого-то примитивного типа, это просто копировать
[01:17:48.000 --> 01:17:50.000]  битики, а trait copy
[01:17:50.000 --> 01:17:52.000]  это просто маркерный trait,
[01:17:52.000 --> 01:17:54.000]  который говорит, ну вот, я только что просто
[01:17:54.000 --> 01:17:56.000]  скопировал битики и больше ничего не сделал.
[01:17:56.000 --> 01:17:58.000]  То есть, если
[01:17:58.000 --> 01:18:00.000]  типы имплементируют копию, то можно, соответственно,
[01:18:00.000 --> 01:18:02.000]  его клонировать, но это логично, да?
[01:18:02.000 --> 01:18:04.000]  А что значит
[01:18:04.000 --> 01:18:06.000]  маркерный trait?
[01:18:06.000 --> 01:18:08.000]  Означает, что он для компилятора.
[01:18:08.000 --> 01:18:10.000]  Меняет что-то в компиляторе.
[01:18:10.000 --> 01:18:12.000]  Это такая языковая фишка.
[01:18:12.000 --> 01:18:14.000]  Ну, я, помнишь,
[01:18:14.000 --> 01:18:16.000]  вот сказал пару минут назад про
[01:18:16.000 --> 01:18:18.000]  пример с x и y, как у нас
[01:18:18.000 --> 01:18:20.000]  вектор moveался,
[01:18:20.000 --> 01:18:22.000]  а 42 копировалось.
[01:18:22.000 --> 01:18:24.000]  Помнишь? Ну, вот
[01:18:24.000 --> 01:18:26.000]  она меняет даже семантику внутри языка.
[01:18:26.000 --> 01:18:28.000]  Имплементация такого trait.
[01:18:30.000 --> 01:18:32.000]  Вот.
[01:18:32.000 --> 01:18:34.000]  Ну, то, что copy clone, это потому, что
[01:18:34.000 --> 01:18:36.000]  clone в данном случае будет просто копировать
[01:18:36.000 --> 01:18:38.000]  битики, а copy говорит, что я только что
[01:18:38.000 --> 01:18:40.000]  скопировал битики. Верь мне, компилятор.
[01:18:40.000 --> 01:18:42.000]  Грубо говоря.
[01:18:50.000 --> 01:18:52.000]  Ну, числа копируемые типы, да, просто
[01:18:52.000 --> 01:18:54.000]  битики скопировать, числа скопировалась.
[01:18:54.000 --> 01:18:56.000]  А вот вектор скопировать просто не получится, потому что
[01:18:56.000 --> 01:18:58.000]  у нас получится внутри два указателя на одну и ту же память.
[01:18:58.000 --> 01:19:00.000]  Но нужно клонировать, то есть
[01:19:00.000 --> 01:19:02.000]  с буфером внутри.
[01:19:02.000 --> 01:19:04.000]  То есть, copy это более сильное
[01:19:04.000 --> 01:19:06.000]  условие.
[01:19:10.000 --> 01:19:12.000]  Ну да, он проверяет, что
[01:19:12.000 --> 01:19:14.000]  каждый тип внутри копии, и, соответственно,
[01:19:14.000 --> 01:19:16.000]  делает копию для
[01:19:16.000 --> 01:19:18.000]  всего типа.
[01:19:20.000 --> 01:19:22.000]  Вот. Есть еще
[01:19:22.000 --> 01:19:24.000]  partial и co.
[01:19:24.000 --> 01:19:26.000]  Это такая штука,
[01:19:26.000 --> 01:19:28.000]  которая предназначена для сравнения объектов.
[01:19:28.000 --> 01:19:30.000]  Обратите внимание, до этого у нас не было
[01:19:30.000 --> 01:19:32.000]  генериков третий. У нас появились
[01:19:32.000 --> 01:19:34.000]  генерики. То есть, мы можем
[01:19:34.000 --> 01:19:36.000]  затребовать какой-то RFS, который
[01:19:36.000 --> 01:19:38.000]  полночайное self правую часть сравнения.
[01:19:38.000 --> 01:19:40.000]  Обратите внимание,
[01:19:40.000 --> 01:19:42.000]  что стандартная библиотека продумана,
[01:19:42.000 --> 01:19:44.000]  поэтому у нас RFS не обязательно сайсит.
[01:19:44.000 --> 01:19:46.000]  Мы можем сравнить между собой два слайса.
[01:19:46.000 --> 01:19:48.000]  А никто не мешает.
[01:19:48.000 --> 01:19:50.000]  Вот.
[01:19:50.000 --> 01:19:52.000]  От partial и co
[01:19:52.000 --> 01:19:54.000]  мы требуем equal и not equal.
[01:19:54.000 --> 01:19:56.000]  Ну, not equal, соответственно, имплементируется
[01:19:56.000 --> 01:19:58.000]  как not equal на внутри
[01:19:58.000 --> 01:20:00.000]  дополнительную имплементацию.
[01:20:00.000 --> 01:20:02.000]  И этот trait одновременно
[01:20:02.000 --> 01:20:04.000]  он перегружает оператора
[01:20:04.000 --> 01:20:06.000]  равно и неравно. То есть,
[01:20:06.000 --> 01:20:08.000]  если вы его имплементируете, вам не нужно писать там
[01:20:08.000 --> 01:20:10.000]  x equal y, хотя вы можете
[01:20:10.000 --> 01:20:12.000]  через точку.
[01:20:12.000 --> 01:20:14.000]  Вы можете написать x равенство y.
[01:20:18.000 --> 01:20:20.000]  Вот. То есть, это способ перегрузки
[01:20:20.000 --> 01:20:22.000]  оператора в RASP. Более того,
[01:20:22.000 --> 01:20:24.000]  по-моему, дальше имплементация есть.
[01:20:24.000 --> 01:20:26.000]  Да.
[01:20:26.000 --> 01:20:28.000]  Ну, правильно. Как работает?
[01:20:32.000 --> 01:20:34.000]  Сейчас.
[01:20:34.000 --> 01:20:36.000]  Как macros работает?
[01:20:36.000 --> 01:20:38.000]  Он для self просто лексиграфически сравнивает
[01:20:38.000 --> 01:20:40.000]  вот поля, как ты их
[01:20:40.000 --> 01:20:42.000]  объявил. Он также просто поля,
[01:20:42.000 --> 01:20:44.000]  при условии, что они partial equal
[01:20:44.000 --> 01:20:46.000]  имплементируют, будет имплементировать.
[01:20:48.000 --> 01:20:50.000]  Вот.
[01:20:50.000 --> 01:20:52.000]  Давайте, ну, понятно,
[01:20:52.000 --> 01:20:54.000]  если в partial equal нам
[01:20:54.000 --> 01:20:56.000]  не нужно, чтобы
[01:20:56.000 --> 01:20:58.000]  правая часть была другим типом.
[01:20:58.000 --> 01:21:00.000]  Что если мы хотим,
[01:21:00.000 --> 01:21:02.000]  чтобы справа был какой-нибудь другой тип?
[01:21:02.000 --> 01:21:04.000]  Давайте попробуем что-нибудь имплементировать.
[01:21:06.000 --> 01:21:08.000]  Ну, для начала давайте попробуем,
[01:21:08.000 --> 01:21:10.000]  когда у нас правый тип совпадает.
[01:21:10.000 --> 01:21:12.000]  Вот у нас есть какая-то структура a,
[01:21:12.000 --> 01:21:14.000]  у нее есть x, который
[01:21:14.000 --> 01:21:16.000]  i32.
[01:21:16.000 --> 01:21:18.000]  Вот. И я имплементирую ручками
[01:21:18.000 --> 01:21:20.000]  partial equal для a.
[01:21:20.000 --> 01:21:22.000]  Это, кстати говоря, ровно то, что сделает
[01:21:22.000 --> 01:21:24.000]  derived partial equal.
[01:21:24.000 --> 01:21:26.000]  Вот. Внутри там вот я имплементирую
[01:21:26.000 --> 01:21:28.000]  equal.
[01:21:28.000 --> 01:21:30.000]  И, соответственно,
[01:21:30.000 --> 01:21:32.000]  я говорю, что self x equal
[01:21:32.000 --> 01:21:34.000]  other x.
[01:21:34.000 --> 01:21:36.000]  Можно, если что, написать просто равенство.
[01:21:36.000 --> 01:21:38.000]  Здесь. То есть, self x равняется
[01:21:38.000 --> 01:21:40.000]  other x. Я просто
[01:21:40.000 --> 01:21:42.000]  написал полностью, чтобы вам
[01:21:42.000 --> 01:21:44.000]  было понятно, что это и эта запись.
[01:21:44.000 --> 01:21:46.000]  По сути, равенство — это просто
[01:21:46.000 --> 01:21:48.000]  синтоксический сахар.
[01:21:48.000 --> 01:21:50.000]  Вот.
[01:21:52.000 --> 01:21:54.000]  Так.
[01:21:56.000 --> 01:21:58.000]  Ну, а теперь давайте сделаем
[01:21:58.000 --> 01:22:00.000]  так.
[01:22:00.000 --> 01:22:02.000]  Это одно и то ли?
[01:22:02.000 --> 01:22:04.000]  А, да, это просто
[01:22:04.000 --> 01:22:06.000]  более подробное чуть-чуть. Я скопировал.
[01:22:06.000 --> 01:22:08.000]  Вот этот слайд
[01:22:08.000 --> 01:22:10.000]  лучше удалить и вот этот вот оставить.
[01:22:10.000 --> 01:22:12.000]  Да, я просто
[01:22:12.000 --> 01:22:14.000]  Вот.
[01:22:14.000 --> 01:22:16.000]  Вот. И теперь давайте сделаем
[01:22:16.000 --> 01:22:18.000]  back.
[01:22:18.000 --> 01:22:20.000]  У него, смотрите, я сделал
[01:22:20.000 --> 01:22:22.000]  derived partial equal. То есть,
[01:22:22.000 --> 01:22:24.000]  то, что произойдет, у меня появится
[01:22:24.000 --> 01:22:26.000]  какая-то имплементация partial equal,
[01:22:26.000 --> 01:22:28.000]  которая сравнивает x.
[01:22:28.000 --> 01:22:30.000]  А теперь давайте сделаем так,
[01:22:30.000 --> 01:22:32.000]  чтобы у меня partial equal
[01:22:32.000 --> 01:22:34.000]  имплементировался для
[01:22:34.000 --> 01:22:36.000]  b при условии,
[01:22:36.000 --> 01:22:38.000]  что правая часть — это a.
[01:22:38.000 --> 01:22:40.000]  Вот. Я сделал так.
[01:22:40.000 --> 01:22:42.000]  Я сделал partial equal a fo b.
[01:22:42.000 --> 01:22:44.000]  У нас fn equal есть какой-то.
[01:22:44.000 --> 01:22:46.000]  Потом мы сравниваем
[01:22:46.000 --> 01:22:48.000]  на равенство.
[01:22:48.000 --> 01:22:50.000]  А, мы видим, что у нас получается
[01:22:50.000 --> 01:22:52.000]  не generic имплементация, а generic
[01:22:52.000 --> 01:22:54.000]  trade.
[01:22:54.000 --> 01:22:56.000]  Да, да. Ну, когда будет смотреть
[01:22:56.000 --> 01:22:58.000]  на правую часть, то он вызовет
[01:22:58.000 --> 01:23:00.000]  определенную имплементацию
[01:23:00.000 --> 01:23:02.000]  partial equal, у которой правая
[01:23:02.000 --> 01:23:04.000]  часть определенная.
[01:23:04.000 --> 01:23:06.000]  Вот.
[01:23:06.000 --> 01:23:08.000]  А до этого у нас не было generic?
[01:23:08.000 --> 01:23:10.000]  Ну, в плане не было.
[01:23:10.000 --> 01:23:12.000]  Да, у нас здесь не было generic,
[01:23:12.000 --> 01:23:14.000]  потому что, смотри, у нас есть
[01:23:14.000 --> 01:23:16.000]  требование, что RHS
[01:23:16.000 --> 01:23:18.000]  это self. Ну, просто мы сказали default
[01:23:18.000 --> 01:23:20.000]  на RHS это self.
[01:23:20.000 --> 01:23:22.000]  Да, и соответственно мы его здесь не
[01:23:22.000 --> 01:23:24.000]  написали.
[01:23:24.000 --> 01:23:26.000]  Вот. А вот здесь мы уже хотим, чтобы
[01:23:26.000 --> 01:23:28.000]  мы могли сравнить
[01:23:28.000 --> 01:23:30.000]  b равняется a.
[01:23:30.000 --> 01:23:32.000]  Так?
[01:23:32.000 --> 01:23:34.000]  Ну, теперь давайте
[01:23:34.000 --> 01:23:36.000]  задефиниваем структуру и
[01:23:36.000 --> 01:23:38.000]  trade.
[01:23:38.000 --> 01:23:40.000]  Всякие, да.
[01:23:40.000 --> 01:23:42.000]  Ну, структуру эти
[01:23:42.000 --> 01:23:44.000]  стационизируем.
[01:23:44.000 --> 01:23:46.000]  Вот.
[01:23:46.000 --> 01:23:48.000]  Я создал a1 и a2. Это какие-то
[01:23:48.000 --> 01:23:50.000]  x42 и x43.
[01:23:50.000 --> 01:23:52.000]  Мне пройдет сравнение на неравенство,
[01:23:52.000 --> 01:23:54.000]  потому что я имплементировал partial equal.
[01:23:54.000 --> 01:23:56.000]  А теперь я создаю b.
[01:23:56.000 --> 01:23:58.000]  b, где x равняется
[01:23:58.000 --> 01:24:00.000]  42. И, смотрите, я b
[01:24:00.000 --> 01:24:02.000]  сравнил с a1.
[01:24:02.000 --> 01:24:04.000]  И все коллектно прошло и скажет, что это
[01:24:04.000 --> 01:24:06.000]  будет true.
[01:24:06.000 --> 01:24:08.000]  Вот если я пробую a1 сравнить с b, то уже не
[01:24:08.000 --> 01:24:10.000]  получится, потому что у a1
[01:24:10.000 --> 01:24:12.000]  не имплементирован partial equal
[01:24:12.000 --> 01:24:14.000]  для b справа.
[01:24:14.000 --> 01:24:16.000]  То есть это уже нужно для a
[01:24:16.000 --> 01:24:18.000]  имплементировать.
[01:24:20.000 --> 01:24:22.000]  А, ну, в плане переставка,
[01:24:22.000 --> 01:24:24.000]  да?
[01:24:24.000 --> 01:24:26.000]  Не, вообще там есть
[01:24:26.000 --> 01:24:28.000]  требования некоторые, чтобы оно
[01:24:28.000 --> 01:24:30.000]  равнялось.
[01:24:30.000 --> 01:24:32.000]  То есть вы формально можете так сделать,
[01:24:32.000 --> 01:24:34.000]  но не формально, раз-то он
[01:24:34.000 --> 01:24:36.000]  тоже формально, раз-то он говорит
[01:24:36.000 --> 01:24:38.000]  документации, что если вы будете использовать
[01:24:38.000 --> 01:24:40.000]  стандартную библиотеку, то у вас есть некоторые требования
[01:24:40.000 --> 01:24:42.000]  на имплитацию partial equal.
[01:24:42.000 --> 01:24:44.000]  У нас как в списках, что концепты можно
[01:24:44.000 --> 01:24:46.000]  подсыпать интокрически, а можно
[01:24:46.000 --> 01:24:48.000]  наделировать магически. Если ты наделиваешь концепты,
[01:24:48.000 --> 01:24:50.000]  то это и помедляем.
[01:24:50.000 --> 01:24:52.000]  Давайте досмотрим partial equal,
[01:24:52.000 --> 01:24:54.000]  наверное, и пойдем на перерывчик.
[01:24:54.000 --> 01:24:56.000]  Что, вот это?
[01:24:56.000 --> 01:24:58.000]  Ну, говоришь,
[01:24:58.000 --> 01:25:00.000]  импл partial equal
[01:25:00.000 --> 01:25:02.000]  b for a,
[01:25:02.000 --> 01:25:04.000]  и у тебя все получилось.
[01:25:04.000 --> 01:25:06.000]  Нет, раз-то
[01:25:06.000 --> 01:25:08.000]  он только в одну часть.
[01:25:10.000 --> 01:25:12.000]  Так, это
[01:25:12.000 --> 01:25:14.000]  последний стандарт?
[01:25:16.000 --> 01:25:18.000]  Ну, не всегда,
[01:25:18.000 --> 01:25:20.000]  иногда ты хочешь по-разному сравнить.
[01:25:22.000 --> 01:25:24.000]  Ну, в общем, как есть,
[01:25:24.000 --> 01:25:26.000]  раз-ли будет явно.
[01:25:30.000 --> 01:25:32.000]  Если реализовать
[01:25:32.000 --> 01:25:34.000]  некорректно, то точно
[01:25:34.000 --> 01:25:36.000]  так же, как мы говорили со структурами
[01:25:36.000 --> 01:25:38.000]  на прошлой реакции.
[01:25:40.000 --> 01:25:42.000]  В общем, у нас не будет
[01:25:42.000 --> 01:25:44.000]  на варианте fc undefined behavior, но у нас может быть
[01:25:44.000 --> 01:25:46.000]  некорректное поведение
[01:25:46.000 --> 01:25:48.000]  нашего кода. Ну, в плане,
[01:25:48.000 --> 01:25:50.000]  что он может некорректно отработать,
[01:25:50.000 --> 01:25:52.000]  просто логическая ошибка будет какая-то.
[01:25:52.000 --> 01:25:54.000]  Оборты, паники и так далее.
[01:25:54.000 --> 01:25:56.000]  Но undefined behavior в варианте fc не будет,
[01:25:56.000 --> 01:25:58.000]  то есть у нас код не взорвется,
[01:25:58.000 --> 01:26:00.000]  не разломает на них.
[01:26:02.000 --> 01:26:04.000]  То, что мы требуем от partial equal,
[01:26:04.000 --> 01:26:06.000]  это a не равно b, например,
[01:26:06.000 --> 01:26:08.000]  тогда и только тогда, когда
[01:26:08.000 --> 01:26:10.000]  не a равняется b.
[01:26:12.000 --> 01:26:14.000]  Ну, это если вы хотите, что у вас
[01:26:14.000 --> 01:26:16.000]  корректно работала имплементация,
[01:26:16.000 --> 01:26:18.000]  то это нужно требовать.
[01:26:18.000 --> 01:26:20.000]  Потом симметричность. Если у вас есть
[01:26:20.000 --> 01:26:22.000]  в обе стороны сравнение, то в таком случае
[01:26:22.000 --> 01:26:24.000]  a равняется b, если b равняется a.
[01:26:24.000 --> 01:26:26.000]  Ну, b равняется a,
[01:26:26.000 --> 01:26:28.000]  если a равняется b.
[01:26:28.000 --> 01:26:30.000]  То есть из одного следует другого.
[01:26:30.000 --> 01:26:32.000]  Одного следует другое, да.
[01:26:32.000 --> 01:26:34.000]  Ну, если мы умеем
[01:26:34.000 --> 01:26:36.000]  сравнить a с b, b с c там,
[01:26:36.000 --> 01:26:38.000]  ну, то есть подряд,
[01:26:38.000 --> 01:26:40.000]  то в таком случае, если a равняется b
[01:26:40.000 --> 01:26:42.000]  и b равняется c, тогда мы должны
[01:26:42.000 --> 01:26:44.000]  иметь a равняется c.
[01:26:44.000 --> 01:26:46.000]  Теперь очень важный вопрос.
[01:26:46.000 --> 01:26:48.000]  У нас все это время
[01:26:48.000 --> 01:26:50.000]  мы смотрели название partial equal.
[01:26:50.000 --> 01:26:52.000]  Partial equal.
[01:26:52.000 --> 01:26:54.000]  Как бы частичное равенство, да.
[01:26:54.000 --> 01:26:56.000]  Как оно там математически называется,
[01:26:56.000 --> 01:26:58.000]  я уже подзабыл.
[01:26:58.000 --> 01:27:00.000]  А почему нам в это вообще нужно вразиться?
[01:27:06.000 --> 01:27:08.000]  Не, это нужно с точки зрения
[01:27:08.000 --> 01:27:10.000]  математики ответить на этот вопрос.
[01:27:14.000 --> 01:27:16.000]  А почему у нас не просто equal?
[01:27:16.000 --> 01:27:18.000]  Просто вот trade equal
[01:27:18.000 --> 01:27:20.000]  равно и не равно.
[01:27:20.000 --> 01:27:22.000]  У нас есть trade equal.
[01:27:22.000 --> 01:27:24.000]  Что?
[01:27:24.000 --> 01:27:26.000]  Эти дополнительные требования
[01:27:26.000 --> 01:27:28.000]  потом появляются,
[01:27:28.000 --> 01:27:30.000]  когда уже дальше идем по иерархии.
[01:27:30.000 --> 01:27:32.000]  Ну, вот мы сейчас как раз на этот вопрос
[01:27:32.000 --> 01:27:34.000]  идем. Да, вот отношение календ
[01:27:34.000 --> 01:27:36.000]  сейчас мы с ними разберемся.
[01:27:36.000 --> 01:27:38.000]  Почему нам нужен partial equal?
[01:27:38.000 --> 01:27:40.000]  В том случае,
[01:27:40.000 --> 01:27:42.000]  вот я говорю вам, сейчас мы будем смотреть еще
[01:27:42.000 --> 01:27:44.000]  на equal, почему если у нас есть equal,
[01:27:44.000 --> 01:27:46.000]  то есть еще и partial equal.
[01:27:48.000 --> 01:27:50.000]  На каком моменте мы свернули на туда?
[01:27:56.000 --> 01:27:58.000]  Ну, короче,
[01:27:58.000 --> 01:28:00.000]  вспомните про float, например.
[01:28:02.000 --> 01:28:04.000]  А помните, у них есть специальное значение,
[01:28:04.000 --> 01:28:06.000]  наны там всякие.
[01:28:06.000 --> 01:28:08.000]  Ну, как сравнивать наны с обычными float?
[01:28:14.000 --> 01:28:16.000]  Нет, почему?
[01:28:16.000 --> 01:28:18.000]  Ну, интервалы тебе нужно, чтобы
[01:28:18.000 --> 01:28:20.000]  один приезжал в интервале другого.
[01:28:20.000 --> 01:28:22.000]  А в сравнении уже вроде
[01:28:22.000 --> 01:28:24.000]  работает не интервально,
[01:28:24.000 --> 01:28:26.000]  а прям по дикталу.
[01:28:26.000 --> 01:28:28.000]  Ну, в общем, мы требуем вот equal, partial equal.
[01:28:28.000 --> 01:28:30.000]  Да, у нас есть проблема в том,
[01:28:30.000 --> 01:28:32.000]  что нан не равен никому, в частности,
[01:28:32.000 --> 01:28:34.000]  он не равен сам себе.
[01:28:34.000 --> 01:28:36.000]  Поэтому у нас
[01:28:36.000 --> 01:28:38.000]  выполнено частичное равенство, но не equal.
[01:28:40.000 --> 01:28:42.000]  И это в каком-то плане
[01:28:42.000 --> 01:28:44.000]  удобно, потому что если вы попробуете
[01:28:44.000 --> 01:28:46.000]  посортить float,
[01:28:46.000 --> 01:28:48.000]  то не на всех данных
[01:28:48.000 --> 01:28:50.000]  у вас будет корректная сортировка,
[01:28:50.000 --> 01:28:52.000]  например.
[01:28:52.000 --> 01:28:54.000]  Ну, потому что у вас наны не сравниваются.
[01:28:54.000 --> 01:28:56.000]  Вот будет там нам,
[01:28:56.000 --> 01:28:58.000]  и он сломает сортировку.
[01:28:58.000 --> 01:29:00.000]  Поэтому раз требует
[01:29:00.000 --> 01:29:02.000]  в сортировках для типов,
[01:29:02.000 --> 01:29:04.000]  что они должны быть кмп.
[01:29:04.000 --> 01:29:06.000]  Мы чуть позже посмотрим. То есть это прям уже
[01:29:06.000 --> 01:29:08.000]  полный порядок на типах,
[01:29:08.000 --> 01:29:10.000]  чтобы можно было их сортировать.
[01:29:10.000 --> 01:29:12.000]  А вот на нанах
[01:29:12.000 --> 01:29:14.000]  имплементирована только partial кмп.
[01:29:14.000 --> 01:29:16.000]  Мы их можем только частично сравнить,
[01:29:16.000 --> 01:29:18.000]  не все. И если вы хотите
[01:29:18.000 --> 01:29:20.000]  сравнить их,
[01:29:20.000 --> 01:29:22.000]  ну, то есть посортить float,
[01:29:22.000 --> 01:29:24.000]  то вам нужно явно сделать
[01:29:24.000 --> 01:29:26.000]  компаратор, в котором будет написано,
[01:29:26.000 --> 01:29:28.000]  что вы делаете partial equal и делаете
[01:29:28.000 --> 01:29:30.000]  unwrap.
[01:29:30.000 --> 01:29:32.000]  То есть обратите внимание, что вот здесь мы
[01:29:32.000 --> 01:29:34.000]  возвращаем, а не здесь
[01:29:34.000 --> 01:29:36.000]  bool возвращаем точно, и потом
[01:29:36.000 --> 01:29:38.000]  это кмп будет.
[01:29:38.000 --> 01:29:40.000]  Там нужно будет делать unwrap и
[01:29:42.000 --> 01:29:44.000]  чтобы явно показать, что
[01:29:44.000 --> 01:29:46.000]  мы запаникуем, если у нас там будут
[01:29:46.000 --> 01:29:48.000]  какие-нибудь наны и несравнимые типы.
[01:29:52.000 --> 01:29:54.000]  Примерно понятно?
[01:29:54.000 --> 01:29:56.000]  А, если
[01:29:56.000 --> 01:29:58.000]  на названии стекла было будет,
[01:29:58.000 --> 01:30:00.000]  будет ли это
[01:30:00.000 --> 01:30:02.000]  booger?
[01:30:02.000 --> 01:30:04.000]  Нет, если ты сравнишь
[01:30:04.000 --> 01:30:06.000]  два float на нан, то они будут
[01:30:06.000 --> 01:30:08.000]  нан с наном float,
[01:30:08.000 --> 01:30:10.000]  тогда ты получишь false.
[01:30:10.000 --> 01:30:12.000]  То есть
[01:30:12.000 --> 01:30:14.000]  не true, несмотря на то, что это два нана.
[01:30:14.000 --> 01:30:16.000]  Потому что некорректно сравнивать между собой
[01:30:16.000 --> 01:30:18.000]  на на number.
[01:30:20.000 --> 01:30:22.000]  Вот это то, что я сказал,
[01:30:22.000 --> 01:30:24.000]  это хорошо
[01:30:24.000 --> 01:30:26.000]  для абстракции на алгоритмах
[01:30:26.000 --> 01:30:28.000]  всяких.
[01:30:28.000 --> 01:30:30.000]  То есть алгоритмы
[01:30:30.000 --> 01:30:32.000]  порой им не хватает всяких
[01:30:32.000 --> 01:30:34.000]  partial equal, например, и им нужно
[01:30:34.000 --> 01:30:36.000]  более сильные условия.
[01:30:36.000 --> 01:30:38.000]  Если вы любите математику алгоритма,
[01:30:38.000 --> 01:30:40.000]  то, наверное, вы порадуетесь этому свойству,
[01:30:40.000 --> 01:30:42.000]  потому что вам
[01:30:42.000 --> 01:30:44.000]  не нужно предусматривать что-то
[01:30:44.000 --> 01:30:46.000]  от пользователя или требовать что-то неявное
[01:30:46.000 --> 01:30:48.000]  от пользователя, как в плюсах.
[01:30:48.000 --> 01:30:50.000]  Вот так вот.
[01:30:52.000 --> 01:30:54.000]  Кажется, дальше Нику.
[01:30:54.000 --> 01:30:56.000]  Ну что, пойдем на перерыв?
[01:30:56.000 --> 01:30:58.000]  Вот, смотрите, у нас есть такой вот
[01:30:58.000 --> 01:31:00.000]  trait, который я назвал важно
[01:31:00.000 --> 01:31:02.000]  в кавычках маркерным, потому что
[01:31:02.000 --> 01:31:04.000]  он, с точки зрения компилятора, не является.
[01:31:04.000 --> 01:31:06.000]  Копи что-то менял в компиляторе.
[01:31:06.000 --> 01:31:08.000]  Есть еще send и sync, которые что-то
[01:31:08.000 --> 01:31:10.000]  меняют в том, как типа можно
[01:31:10.000 --> 01:31:12.000]  пользоваться
[01:31:12.000 --> 01:31:14.000]  именно на уровне компиляции.
[01:31:14.000 --> 01:31:16.000]  Equal я называю маркерным
[01:31:16.000 --> 01:31:18.000]  только в кавычках, потому что он
[01:31:18.000 --> 01:31:20.000]  ну, формально
[01:31:20.000 --> 01:31:22.000]  он что-то маркирует, но при этом
[01:31:22.000 --> 01:31:24.000]  для компилятора ничего не говорит.
[01:31:24.000 --> 01:31:26.000]  Вот, специально.
[01:31:26.000 --> 01:31:28.000]  У него есть derived equal macro,
[01:31:28.000 --> 01:31:30.000]  который просто имплементирует
[01:31:30.000 --> 01:31:32.000]  Нику автоматически.
[01:31:34.000 --> 01:31:36.000]  Самое главное, что он дает,
[01:31:36.000 --> 01:31:38.000]  это то, что у нас a теперь обязательно
[01:31:38.000 --> 01:31:40.000]  равняется a.
[01:31:40.000 --> 01:31:42.000]  Вот и все.
[01:31:42.000 --> 01:31:44.000]  В каком смысле тут равняется?
[01:31:44.000 --> 01:31:46.000]  Ну, например, что
[01:31:46.000 --> 01:31:48.000]  none не равно none на случай флотов.
[01:31:48.000 --> 01:31:50.000]  А здесь у нас обязательно равенство,
[01:31:50.000 --> 01:31:52.000]  соответственно, флот сюда не подходит, а какое-нибудь число
[01:31:52.000 --> 01:31:54.000]  уже подходит.
[01:31:54.000 --> 01:31:56.000]  То есть у нас есть полноценное равенство,
[01:31:56.000 --> 01:31:58.000]  можем сравнить.
[01:31:58.000 --> 01:32:00.000]  Сейчас, почему еще раз флот сюда подходит?
[01:32:00.000 --> 01:32:02.000]  None не равно none.
[01:32:02.000 --> 01:32:04.000]  А, то есть это
[01:32:04.000 --> 01:32:06.000]  именно во всех
[01:32:06.000 --> 01:32:08.000]  значениях?
[01:32:08.000 --> 01:32:10.000]  Ну, none никому не равен
[01:32:10.000 --> 01:32:12.000]  вообще. Даже себя.
[01:32:12.000 --> 01:32:14.000]  И, соответственно, получается,
[01:32:14.000 --> 01:32:16.000]  что мы не подходим под
[01:32:16.000 --> 01:32:18.000]  частичное равенство,
[01:32:18.000 --> 01:32:20.000]  определение математическое.
[01:32:20.000 --> 01:32:22.000]  Поэтому у нас есть equal для этого отдельно,
[01:32:22.000 --> 01:32:24.000]  который требует отдельной рефлексивности.
[01:32:24.000 --> 01:32:26.000]  Ну, это означает,
[01:32:26.000 --> 01:32:28.000]  вот обратите внимание,
[01:32:28.000 --> 01:32:30.000]  вот у меня есть теперь возможность
[01:32:30.000 --> 01:32:32.000]  отделять. У нас вот есть
[01:32:32.000 --> 01:32:34.000]  partial equal.
[01:32:34.000 --> 01:32:36.000]  Мы требуем имплементации
[01:32:36.000 --> 01:32:38.000]  partial equal. Сами в equal
[01:32:38.000 --> 01:32:40.000]  ничего абсолютно не добавляем.
[01:32:40.000 --> 01:32:42.000]  Единственное, что
[01:32:42.000 --> 01:32:44.000]  это говорит,
[01:32:44.000 --> 01:32:46.000]  то, что наша имплементация partial equal
[01:32:46.000 --> 01:32:48.000]  еще и рефлексивна.
[01:32:48.000 --> 01:32:50.000]  И все получается.
[01:32:50.000 --> 01:32:52.000]  В каком-то смысле, опять же, в кавычках
[01:32:52.000 --> 01:32:54.000]  он маркерный.
[01:32:54.000 --> 01:32:56.000]  Только в кавычках.
[01:32:56.000 --> 01:32:58.000]  Вот.
[01:32:58.000 --> 01:33:00.000]  Давайте теперь поговорим про такую стуку
[01:33:00.000 --> 01:33:02.000]  перед тем, как перейти к сравнению
[01:33:02.000 --> 01:33:04.000]  про ordering. Это такой специальный
[01:33:04.000 --> 01:33:06.000]  enum. В плюсах у нас
[01:33:06.000 --> 01:33:08.000]  для этого используется минус 1, 0 и 1.
[01:33:08.000 --> 01:33:10.000]  Ну, точно так же, как FC. Просто числа.
[01:33:10.000 --> 01:33:12.000]  В Rust у нас есть
[01:33:12.000 --> 01:33:14.000]  enum, у которого есть
[01:33:14.000 --> 01:33:16.000]  less, equal и greater значения.
[01:33:16.000 --> 01:33:18.000]  У него есть немножко
[01:33:18.000 --> 01:33:20.000]  функций. Это is equal, is not equal,
[01:33:20.000 --> 01:33:22.000]  is less than equal,
[01:33:22.000 --> 01:33:24.000]  lt это, по-моему,
[01:33:24.000 --> 01:33:26.000]  строго меньше.
[01:33:26.000 --> 01:33:28.000]  Зачем такие маленькие названия?
[01:33:28.000 --> 01:33:30.000]  Ну,
[01:33:30.000 --> 01:33:32.000]  equal и not equal понятно,
[01:33:32.000 --> 01:33:34.000]  lt мне тоже не нравится,
[01:33:34.000 --> 01:33:36.000]  но is less или less or equal
[01:33:36.000 --> 01:33:38.000]  это, наверное,
[01:33:38.000 --> 01:33:40.000]  less еще нормально, а less or equal уже как-то
[01:33:40.000 --> 01:33:42.000]  длинно.
[01:33:42.000 --> 01:33:44.000]  На сме писали, прибудьте,
[01:33:44.000 --> 01:33:46.000]  я покажу.
[01:33:46.000 --> 01:33:48.000]  Ну, в общем, как есть.
[01:33:48.000 --> 01:33:50.000]  Наверное, название здесь
[01:33:50.000 --> 01:33:52.000]  нравится не так
[01:33:52.000 --> 01:33:54.000]  сильно, как хотелось бы.
[01:33:54.000 --> 01:33:56.000]  Но это, на самом деле,
[01:33:56.000 --> 01:33:58.000]  в общих чертах Rust очень хорошее
[01:33:58.000 --> 01:34:00.000]  название.
[01:34:02.000 --> 01:34:04.000]  Zen это, смотри, у тебя есть
[01:34:04.000 --> 01:34:06.000]  ordering. Это такая
[01:34:06.000 --> 01:34:08.000]  штука, которая, если у тебя
[01:34:08.000 --> 01:34:10.000]  твой текущий ordering
[01:34:10.000 --> 01:34:12.000]  equal, то тогда он возвращает второй.
[01:34:14.000 --> 01:34:16.000]  Понял?
[01:34:16.000 --> 01:34:18.000]  Так, смотри, у тебя есть 2 ordering
[01:34:18.000 --> 01:34:20.000]  a и b. Если ты пишешь
[01:34:20.000 --> 01:34:22.000]  a, then b,
[01:34:22.000 --> 01:34:24.000]  то в таком случае, если у тебя a
[01:34:24.000 --> 01:34:26.000]  это equal, то тогда вернется b, иначе
[01:34:26.000 --> 01:34:28.000]  вернется a. То есть точно так же,
[01:34:28.000 --> 01:34:30.000]  как ты в графическом порядке сравнишь.
[01:34:30.000 --> 01:34:32.000]  Если у тебя раньше, то ты идешь дальше.
[01:34:32.000 --> 01:34:34.000]  Нет.
[01:34:34.000 --> 01:34:36.000]  Я считаю, что красота нужна
[01:34:36.000 --> 01:34:38.000]  очень, ну, как
[01:34:38.000 --> 01:34:40.000]  в принципе, как один шаг
[01:34:40.000 --> 01:34:42.000]  в графическом сравнении.
[01:34:42.000 --> 01:34:44.000]  Что такое ordering?
[01:34:44.000 --> 01:34:46.000]  Это мощная функция?
[01:34:46.000 --> 01:34:48.000]  ZenVif это просто то же самое, но с функцией.
[01:34:48.000 --> 01:34:50.000]  Функция только что?
[01:34:50.000 --> 01:34:52.000]  Да.
[01:34:52.000 --> 01:34:54.000]  Но она берет, ну, не то же самое
[01:34:54.000 --> 01:34:56.000]  но с функцией, она берет наш текущий ordering,
[01:34:56.000 --> 01:34:58.000]  что-то с ним делает, возвращает ordering.
[01:35:00.000 --> 01:35:02.000]  Ну, там есть...
[01:35:02.000 --> 01:35:04.000]  Что еще?
[01:35:04.000 --> 01:35:06.000]  Да.
[01:35:06.000 --> 01:35:08.000]  Наверное, вам по названию тоже понятно,
[01:35:08.000 --> 01:35:10.000]  greater превратит в less, и наоборот equal
[01:35:10.000 --> 01:35:12.000]  сам себя перейдет.
[01:35:12.000 --> 01:35:14.000]  ZenVif?
[01:35:14.000 --> 01:35:16.000]  Да.
[01:35:16.000 --> 01:35:18.000]  Берет текущий ordering,
[01:35:18.000 --> 01:35:20.000]  применяет к нему функцию f.
[01:35:20.000 --> 01:35:22.000]  Функция f возвращает ordering.
[01:35:22.000 --> 01:35:24.000]  А просто Zen?
[01:35:24.000 --> 01:35:26.000]  А просто Zen это
[01:35:26.000 --> 01:35:28.000]  лексиграфическое сравнение.
[01:35:28.000 --> 01:35:30.000]  Если self это equal,
[01:35:30.000 --> 01:35:32.000]  то это equal возвращает other,
[01:35:32.000 --> 01:35:34.000]  иначе возвращает self.
[01:35:34.000 --> 01:35:36.000]  Ну, там есть еще
[01:35:36.000 --> 01:35:38.000]  какие-то функции, кроме equal,
[01:35:38.000 --> 01:35:40.000]  not equal, там есть greater, less,
[01:35:40.000 --> 01:35:42.000]  ну, в общем, штук 6 примерно
[01:35:42.000 --> 01:35:44.000]  еще какие-то есть.
[01:35:44.000 --> 01:35:46.000]  А и b?
[01:35:50.000 --> 01:35:52.000]  Так, a и b это просто абстрактные
[01:35:52.000 --> 01:35:54.000]  какие-то вещи,
[01:35:54.000 --> 01:35:56.000]  когда я говорил, ну, то есть a, d и b.
[01:35:56.000 --> 01:35:58.000]  a и b это какие-то ordering.
[01:35:58.000 --> 01:36:00.000]  Здесь вот den не a, это self, а b это other.
[01:36:02.000 --> 01:36:04.000]  Я просто назвал a и b,
[01:36:04.000 --> 01:36:06.000]  для того, чтобы попроще было.
[01:36:14.000 --> 01:36:16.000]  В плане...
[01:36:16.000 --> 01:36:18.000]  Просто параметры Zen, а и b,
[01:36:18.000 --> 01:36:20.000]  как сколько?
[01:36:20.000 --> 01:36:22.000]  Нет, den это функция yinamo.
[01:36:22.000 --> 01:36:24.000]  Соответственно, если ты от yinamo вызовешь
[01:36:24.000 --> 01:36:26.000]  then, тогда получится...
[01:36:26.000 --> 01:36:28.000]  Then, тогда ты внутри пишешь
[01:36:28.000 --> 01:36:30.000]  какой-то ordering, и возвращается ordering.
[01:36:30.000 --> 01:36:32.000]  В общем, подразберись, ты, наверное, запутался
[01:36:32.000 --> 01:36:34.000]  в том, как функции возвращаются,
[01:36:34.000 --> 01:36:36.000]  как работает функция
[01:36:36.000 --> 01:36:38.000]  в имплахах.
[01:36:50.000 --> 01:36:52.000]  Ну, это просто импл-ордеринг.
[01:36:52.000 --> 01:36:54.000]  Это то, что находится в импл-ордеринг.
[01:36:54.000 --> 01:36:56.000]  Соответственно, если у вас есть a,
[01:36:56.000 --> 01:36:58.000]  какой-то ordering, тогда вы можете вызвать
[01:36:58.000 --> 01:37:00.000]  a из equal.
[01:37:00.000 --> 01:37:02.000]  Вы можете вызвать a, den.
[01:37:08.000 --> 01:37:10.000]  Так, давайте поговорим
[01:37:10.000 --> 01:37:12.000]  про partial-ord теперь.
[01:37:12.000 --> 01:37:14.000]  Обратите внимание, что partial-ord
[01:37:14.000 --> 01:37:16.000]  в partial-kmp-свм возвращает
[01:37:16.000 --> 01:37:18.000]  option-ordering.
[01:37:18.000 --> 01:37:20.000]  Почему? Потому что у нас какие-то числа
[01:37:20.000 --> 01:37:22.000]  могут быть несравнимые.
[01:37:22.000 --> 01:37:24.000]  У него есть derived-macro, соответственно.
[01:37:24.000 --> 01:37:26.000]  Точно так же
[01:37:26.000 --> 01:37:28.000]  вот здесь у нас возникает
[01:37:28.000 --> 01:37:30.000]  vers-not...
[01:37:30.000 --> 01:37:32.000]  Ну, не обязательно size-типа.
[01:37:32.000 --> 01:37:34.000]  RHS. То есть, опять же, можем
[01:37:34.000 --> 01:37:36.000]  сравнить всякие слайсы.
[01:37:38.000 --> 01:37:40.000]  Вот. И, в общем-то,
[01:37:40.000 --> 01:37:42.000]  наверное, это все,
[01:37:42.000 --> 01:37:44.000]  что нужно знать на этом слайде.
[01:37:44.000 --> 01:37:46.000]  Примерно понятно, как объявлен этот trait.
[01:37:46.000 --> 01:37:48.000]  Сортировки требуют partial-ord?
[01:37:50.000 --> 01:37:52.000]  Нет, сортировки требуют ord.
[01:37:52.000 --> 01:37:54.000]  Прямо линейный порядок.
[01:37:54.000 --> 01:37:56.000]  Это мы сейчас посмотрим еще.
[01:37:58.000 --> 01:38:00.000]  Ну, partial-ord, смотрите,
[01:38:00.000 --> 01:38:02.000]  еще от partial-equal уходит.
[01:38:02.000 --> 01:38:04.000]  То есть, наследуется
[01:38:04.000 --> 01:38:06.000]  от partial-equal, грубо говоря, супертрейд.
[01:38:06.000 --> 01:38:08.000]  И, соответственно,
[01:38:08.000 --> 01:38:10.000]  у нас еще равенство есть
[01:38:10.000 --> 01:38:12.000]  у объекта, который имплементирует
[01:38:12.000 --> 01:38:14.000]  partial-ord.
[01:38:14.000 --> 01:38:16.000]  То есть, если вы можете сравнить объект,
[01:38:16.000 --> 01:38:18.000]  то в таком случае вы можете его сравнить
[01:38:18.000 --> 01:38:20.000]  чисто-логически на равенство.
[01:38:20.000 --> 01:38:22.000]  Так?
[01:38:24.000 --> 01:38:26.000]  Ну, это то, что мы требуем, да?
[01:38:26.000 --> 01:38:28.000]  Это уже такая формальная, более-менее, математика.
[01:38:28.000 --> 01:38:30.000]  Если a равно b
[01:38:30.000 --> 01:38:32.000]  только тогда, когда у нас
[01:38:32.000 --> 01:38:34.000]  partial-qmp возвращается
[01:38:34.000 --> 01:38:36.000]  some-equal. То есть, тогда и только тогда.
[01:38:38.000 --> 01:38:40.000]  То же самое с a меньше b
[01:38:40.000 --> 01:38:42.000]  и a больше b.
[01:38:42.000 --> 01:38:44.000]  Заметьте, в скобчиках написал
[01:38:44.000 --> 01:38:46.000]  ensured by default implementation.
[01:38:46.000 --> 01:38:48.000]  Это из документации.
[01:38:48.000 --> 01:38:50.000]  Это означает то, что derive
[01:38:50.000 --> 01:38:52.000]  вам обещает, что это условие
[01:38:52.000 --> 01:38:54.000]  обязательно будет выполнено, если вы
[01:38:54.000 --> 01:38:56.000]  сделаете derive.
[01:38:58.000 --> 01:39:00.000]  Оно не может быть неимплементировано.
[01:39:02.000 --> 01:39:04.000]  Да, что?
[01:39:04.000 --> 01:39:06.000]  partial-cmb
[01:39:06.000 --> 01:39:08.000]  это что? Это аналог меньше?
[01:39:08.000 --> 01:39:10.000]  Это сравнение.
[01:39:10.000 --> 01:39:12.000]  Он возвращает ordering.
[01:39:12.000 --> 01:39:14.000]  Он возвращает less, equal, or greater.
[01:39:14.000 --> 01:39:16.000]  Причем общий.
[01:39:16.000 --> 01:39:18.000]  А почему?
[01:39:18.000 --> 01:39:20.000]  У нас ordering,
[01:39:20.000 --> 01:39:22.000]  напоминаю, вот такая вот штука.
[01:39:22.000 --> 01:39:24.000]  Ордеринг less, equal, greater.
[01:39:24.000 --> 01:39:26.000]  Мы возвращаем общий ordering.
[01:39:28.000 --> 01:39:30.000]  Так.
[01:39:30.000 --> 01:39:32.000]  Ну и, соответственно,
[01:39:32.000 --> 01:39:34.000]  а меньше либо равно,
[01:39:34.000 --> 01:39:36.000]  ну и так далее.
[01:39:36.000 --> 01:39:38.000]  С равенством, default implementation
[01:39:38.000 --> 01:39:40.000]  не может вам гарантировать,
[01:39:40.000 --> 01:39:42.000]  потому что вам нужно для начала имплементировать partial.
[01:39:42.000 --> 01:39:44.000]  Логично, да?
[01:39:44.000 --> 01:39:46.000]  Вы можете его имплементировать руками неправильно.
[01:39:46.000 --> 01:39:48.000]  Но, тем не менее, если даже
[01:39:48.000 --> 01:39:50.000]  неправильно имплементировать руками,
[01:39:50.000 --> 01:39:52.000]  все остальное default implementation вам правильно выведет.
[01:39:54.000 --> 01:39:56.000]  Ну, конечно, при условии, что
[01:39:56.000 --> 01:39:58.000]  у вас равенство корректно.
[01:40:02.000 --> 01:40:04.000]  В общем, следите за тем, чтобы у вас правильно
[01:40:04.000 --> 01:40:06.000]  все, правильно работали такие вещи.
[01:40:06.000 --> 01:40:08.000]  Иначе
[01:40:08.000 --> 01:40:10.000]  у вас может, раз код работает,
[01:40:10.000 --> 01:40:12.000]  просто логически некорректно.
[01:40:12.000 --> 01:40:14.000]  Ну, логическая ошибка, это логическая ошибка,
[01:40:14.000 --> 01:40:16.000]  вы никак не избавитесь.
[01:40:16.000 --> 01:40:18.000]  Сейфти, тем не менее, остается у вас всегда,
[01:40:18.000 --> 01:40:20.000]  даже если вы неправильное сравнение делаете.
[01:40:22.000 --> 01:40:24.000]  Так.
[01:40:24.000 --> 01:40:26.000]  Теперь ORD.
[01:40:26.000 --> 01:40:28.000]  Заметьте, ORD требует equal
[01:40:28.000 --> 01:40:30.000]  плюс partial ORD.
[01:40:30.000 --> 01:40:32.000]  Так.
[01:40:32.000 --> 01:40:34.000]  То есть у нас partial ORD
[01:40:34.000 --> 01:40:36.000]  требовал partial equal
[01:40:36.000 --> 01:40:38.000]  плюс какие-то дополнительные функции.
[01:40:38.000 --> 01:40:40.000]  А теперь, если мы еще говорим, что у нас
[01:40:40.000 --> 01:40:42.000]  equality корректная,
[01:40:42.000 --> 01:40:44.000]  то в таком случае у нас есть полноценный KMP.
[01:40:44.000 --> 01:40:46.000]  У нас, с точки зрения математики,
[01:40:46.000 --> 01:40:48.000]  мы можем прям возвращать ordering,
[01:40:48.000 --> 01:40:50.000]  потому что мы уверены в том, что у нас все объекты сравнимы.
[01:40:52.000 --> 01:40:54.000]  Плюс ко всему, раз что они все сравнимы,
[01:40:54.000 --> 01:40:56.000]  то в таком случае у нас есть, ну, у нас же loom,
[01:40:56.000 --> 01:40:58.000]  получается, да? Мы от логику вспоминаем.
[01:40:58.000 --> 01:41:00.000]  Вот. У нас есть minimum,
[01:41:00.000 --> 01:41:02.000]  maximum и clamp.
[01:41:02.000 --> 01:41:04.000]  Еще как дополнительная функция.
[01:41:04.000 --> 01:41:06.000]  Они имплементируются дефолтно?
[01:41:14.000 --> 01:41:16.000]  Ну, то есть если ты не входишь, уберешь minimum,
[01:41:16.000 --> 01:41:18.000]  уберешь maximum. Если ты не входишь в этот диапазон,
[01:41:18.000 --> 01:41:20.000]  тогда он, соответственно, к нему подвинет.
[01:41:20.000 --> 01:41:22.000]  Либо ставит том, как он есть.
[01:41:22.000 --> 01:41:24.000]  Ну, и вот, соответственно,
[01:41:24.000 --> 01:41:26.000]  некоторые условия.
[01:41:28.000 --> 01:41:30.000]  Наверное, первая нам не особо
[01:41:30.000 --> 01:41:32.000]  интересна.
[01:41:34.000 --> 01:41:36.000]  Точно так же у нас дефолтная имплементация
[01:41:36.000 --> 01:41:38.000]  все гарантирует.
[01:41:38.000 --> 01:41:40.000]  При условии, конечно, чтобы
[01:41:40.000 --> 01:41:42.000]  equal и partial.lord корректно
[01:41:42.000 --> 01:41:44.000]  имплементировали.
[01:41:46.000 --> 01:41:48.000]  Ну, дефолтная имплементация, еще раз напоминаю,
[01:41:48.000 --> 01:41:50.000]  это macros.
[01:41:50.000 --> 01:41:52.000]  Который мы пишем dirifort.
[01:41:58.000 --> 01:42:00.000]  Max.buy
[01:42:00.000 --> 01:42:02.000]  помнишь, мы говорили
[01:42:02.000 --> 01:42:04.000]  на второй лекции,
[01:42:04.000 --> 01:42:06.000]  что у нас, например, есть
[01:42:06.000 --> 01:42:08.000]  sort,
[01:42:08.000 --> 01:42:10.000]  есть sort.buy метод.
[01:42:10.000 --> 01:42:12.000]  Что мы можем ordering какой-то
[01:42:12.000 --> 01:42:14.000]  добавить. Здесь kmpeg
[01:42:14.000 --> 01:42:16.000]  это какая-то функция сравнения.
[01:42:16.000 --> 01:42:18.000]  То есть наш max
[01:42:18.000 --> 01:42:20.000]  работает точно так же, как kmpeg.
[01:42:22.000 --> 01:42:24.000]  То есть это в точности
[01:42:24.000 --> 01:42:26.000]  означает то, что у нас
[01:42:26.000 --> 01:42:28.000]  ort и partial.ort относительно
[01:42:28.000 --> 01:42:30.000]  друг друга консистентно работают.
[01:42:30.000 --> 01:42:32.000]  Здесь это написано.
[01:42:32.000 --> 01:42:34.000]  То есть они согласованы.
[01:42:36.000 --> 01:42:38.000]  Я думаю, что если что,
[01:42:38.000 --> 01:42:40.000]  вы дома разберетесь с этим.
[01:42:40.000 --> 01:42:42.000]  Просто это математика, если что,
[01:42:42.000 --> 01:42:44.000]  можете вспомнить на википедии
[01:42:44.000 --> 01:42:46.000]  определение.
[01:42:46.000 --> 01:42:48.000]  В принципе, там понятно
[01:42:48.000 --> 01:42:50.000]  частичный порядок и полный порядок
[01:42:50.000 --> 01:42:52.000]  как работают.
[01:42:52.000 --> 01:42:54.000]  Еще есть такая специальная структурка
[01:42:54.000 --> 01:42:56.000]  называется reverse.
[01:42:56.000 --> 01:42:58.000]  Смотрите, как я объявляю
[01:42:58.000 --> 01:43:00.000]  забавную структурку. Я пишу reverseT
[01:43:00.000 --> 01:43:02.000]  и после этого не фигурные скобочки, а внутри
[01:43:02.000 --> 01:43:04.000]  какой-то публичный тип T.
[01:43:04.000 --> 01:43:06.000]  То есть я объявляю
[01:43:06.000 --> 01:43:08.000]  по сути, наша структура
[01:43:08.000 --> 01:43:10.000]  reverse
[01:43:10.000 --> 01:43:12.000]  является
[01:43:12.000 --> 01:43:14.000]  тюплом,
[01:43:14.000 --> 01:43:16.000]  которого первое
[01:43:16.000 --> 01:43:18.000]  поле
[01:43:18.000 --> 01:43:20.000]  это наш T.
[01:43:20.000 --> 01:43:22.000]  Чем нам
[01:43:22.000 --> 01:43:24.000]  reverse полезен, это тем, что
[01:43:24.000 --> 01:43:26.000]  например, мы хотим вектор отсортировать
[01:43:26.000 --> 01:43:28.000]  в обратном порядке. Причем не только
[01:43:28.000 --> 01:43:30.000]  в обратном порядке, но еще и
[01:43:30.000 --> 01:43:32.000]  при условии, что у нас
[01:43:32.000 --> 01:43:34.000]  с самого начала все элементы, которые меньше
[01:43:34.000 --> 01:43:36.000]  трех, а потом все элементы, которые больше трех.
[01:43:36.000 --> 01:43:38.000]  Смотрите, какой у меня такой
[01:43:38.000 --> 01:43:40.000]  хитрый компаратор.
[01:43:40.000 --> 01:43:42.000]  Подождите, можете пояснить
[01:43:42.000 --> 01:43:44.000]  синтаксиз структуры?
[01:43:44.000 --> 01:43:46.000]  Я надеюсь, сейчас не отрубится.
[01:43:46.000 --> 01:43:48.000]  Вроде бы
[01:43:48.000 --> 01:43:50.000]  запись работает.
[01:43:50.000 --> 01:43:52.000]  Так, какой синтаксиз?
[01:43:56.000 --> 01:43:58.000]  Смотри, это называется new type,
[01:43:58.000 --> 01:44:00.000]  чтобы не соврать, мы следующий слайд
[01:44:00.000 --> 01:44:02.000]  буквально. Пока что просто поверьте,
[01:44:02.000 --> 01:44:04.000]  что это структурка, которой мы один.
[01:44:04.000 --> 01:44:06.000]  Это не то, что вы должны знать.
[01:44:06.000 --> 01:44:08.000]  Это не то, что вы должны знать.
[01:44:08.000 --> 01:44:10.000]  Этот синтаксиз
[01:44:10.000 --> 01:44:12.000]  мы сейчас обсудим.
[01:44:12.000 --> 01:44:14.000]  Давайте посмотрим лучше на примеры
[01:44:14.000 --> 01:44:16.000]  использования.
[01:44:16.000 --> 01:44:18.000]  Реверс
[01:44:18.000 --> 01:44:20.000]  делает реверс ордеринг. У него
[01:44:20.000 --> 01:44:22.000]  имплементирован орд,
[01:44:22.000 --> 01:44:24.000]  причем имплементирован так, что
[01:44:24.000 --> 01:44:26.000]  он делает внутри реверс.
[01:44:28.000 --> 01:44:30.000]  То есть вместо less он будет возвращать greater,
[01:44:30.000 --> 01:44:32.000]  вместо greater less.
[01:44:32.000 --> 01:44:34.000]  Это удобно такой в раппер,
[01:44:34.000 --> 01:44:36.000]  когда сортирую,
[01:44:36.000 --> 01:44:38.000]  сначала сортирую больше трех,
[01:44:38.000 --> 01:44:40.000]  чтобы было видно.
[01:44:40.000 --> 01:44:42.000]  Здесь все элементы меньше, тройки
[01:44:42.000 --> 01:44:44.000]  получаются, здесь все больше тройки.
[01:44:44.000 --> 01:44:46.000]  Это тюпл.
[01:44:46.000 --> 01:44:48.000]  Второе это reverse нам.
[01:44:48.000 --> 01:44:50.000]  Соответственно, у меня внутри
[01:44:50.000 --> 01:44:52.000]  отрезка будет реверсный порядок.
[01:44:52.000 --> 01:44:54.000]  Если бы вместо этого тюпла
[01:44:54.000 --> 01:44:56.000]  просто написал reverse нам, то у меня
[01:44:56.000 --> 01:44:58.000]  получилось от 6 до 1 массивчик.
[01:45:00.000 --> 01:45:02.000]  Это бывает удобно.
[01:45:02.000 --> 01:45:04.000]  Просто вернуть что-то в реверс
[01:45:04.000 --> 01:45:06.000]  и все хорошо, красиво работает.
[01:45:06.000 --> 01:45:08.000]  Это зерокост abstraction.
[01:45:08.000 --> 01:45:10.000]  Так что вы можете в любую позицию.
[01:45:10.000 --> 01:45:12.000]  Без вреда
[01:45:12.000 --> 01:45:14.000]  производительности.
[01:45:14.000 --> 01:45:16.000]  Примерным понятием пример.
[01:45:22.000 --> 01:45:24.000]  Какое замыкание?
[01:45:26.000 --> 01:45:28.000]  Sort by key возвращает ключ
[01:45:28.000 --> 01:45:30.000]  сортировки.
[01:45:30.000 --> 01:45:32.000]  В данном случае он возвращает
[01:45:32.000 --> 01:45:34.000]  пару из була и
[01:45:34.000 --> 01:45:36.000]  реверс.
[01:45:36.000 --> 01:45:38.000]  Где-то это и 32.
[01:45:38.000 --> 01:45:40.000]  Реверс и 32.
[01:45:50.000 --> 01:45:52.000]  Теперь делаем new type.
[01:45:52.000 --> 01:45:54.000]  Посмотрели?
[01:45:54.000 --> 01:45:56.000]  Это не совсем понятное объявление.
[01:45:56.000 --> 01:45:58.000]  Это на самом деле бывает удобно.
[01:45:58.000 --> 01:46:00.000]  Это какая-то функциональщина.
[01:46:02.000 --> 01:46:04.000]  Смотрите, у нас есть структурка
[01:46:04.000 --> 01:46:06.000]  years, которая
[01:46:06.000 --> 01:46:08.000]  I64 себя представляет.
[01:46:08.000 --> 01:46:10.000]  На самом деле тип.
[01:46:10.000 --> 01:46:12.000]  И структурка days, которая I64
[01:46:12.000 --> 01:46:14.000]  представляет.
[01:46:14.000 --> 01:46:16.000]  По сути я структурку объявляю как
[01:46:16.000 --> 01:46:18.000]  какой-то новый тип.
[01:46:18.000 --> 01:46:20.000]  Я просто приименовываю тип I64,
[01:46:20.000 --> 01:46:22.000]  но при этом стираю все, что я знаю
[01:46:22.000 --> 01:46:24.000]  об I64.
[01:46:24.000 --> 01:46:26.000]  Смотрите, я сделал импл для years.
[01:46:26.000 --> 01:46:28.000]  И теперь я, когда
[01:46:28.000 --> 01:46:30.000]  делаю todays, то в таком случае
[01:46:30.000 --> 01:46:32.000]  я создаю структурку days,
[01:46:32.000 --> 01:46:34.000]  которые... Вот видите, опять же, как tuple
[01:46:34.000 --> 01:46:36.000]  обращаюсь. Здесь можно через запятую
[01:46:36.000 --> 01:46:38.000]  объявить несколько типов.
[01:46:38.000 --> 01:46:40.000]  То есть точно так же, как помните, мы в
[01:46:40.000 --> 01:46:42.000]  янамчике на первой лекции, там тоже в скобочках
[01:46:42.000 --> 01:46:44.000]  что-то могли написать через запятую.
[01:46:44.000 --> 01:46:46.000]  А с теплами
[01:46:46.000 --> 01:46:48.000]  .0.1 только работает?
[01:46:48.000 --> 01:46:50.000]  С теплами только .0.1
[01:46:50.000 --> 01:46:52.000]  работает. Ты не можешь
[01:46:52.000 --> 01:46:54.000]  писать в квадратных скобочках.
[01:46:54.000 --> 01:46:56.000]  Ну, знаешь, в плюсах
[01:46:56.000 --> 01:46:58.000]  еще хуже с гетом.
[01:46:58.000 --> 01:47:00.000]  Да, да.
[01:47:00.000 --> 01:47:02.000]  Ты такие вещи
[01:47:02.000 --> 01:47:04.000]  просто в гет не говори.
[01:47:04.000 --> 01:47:06.000]  Все там хорошо.
[01:47:06.000 --> 01:47:08.000]  Так.
[01:47:08.000 --> 01:47:10.000]  Значит, у нас здесь
[01:47:10.000 --> 01:47:12.000]  видите
[01:47:12.000 --> 01:47:14.000]  умножение на 365.
[01:47:14.000 --> 01:47:16.000]  Получается, что years
[01:47:16.000 --> 01:47:18.000]  перевели в days.
[01:47:18.000 --> 01:47:20.000]  И потом мы можем days, например,
[01:47:20.000 --> 01:47:22.000]  tu years сделать и поделить на 365,
[01:47:22.000 --> 01:47:24.000]  поделить на 365, получить
[01:47:24.000 --> 01:47:26.000]  целое число дней. Смотрите,
[01:47:26.000 --> 01:47:28.000]  здесь зависит такая структура к example, в которой я
[01:47:28.000 --> 01:47:30.000]  даже generic объявил.
[01:47:30.000 --> 01:47:32.000]  У нас и 32, и 64, и какой-то
[01:47:32.000 --> 01:47:34.000]  t, и это все будет такой
[01:47:34.000 --> 01:47:36.000]  tuple на самом деле.
[01:47:36.000 --> 01:47:38.000]  А модификатор public
[01:47:38.000 --> 01:47:40.000]  в этом списке что делал?
[01:47:40.000 --> 01:47:42.000]  public давай мы это обсудим на следующей лекции.
[01:47:42.000 --> 01:47:44.000]  Ну, по сути, давай
[01:47:44.000 --> 01:47:46.000]  опять же я очень упрощенную
[01:47:46.000 --> 01:47:48.000]  модель мира сделаю, скажу, что
[01:47:48.000 --> 01:47:50.000]  pub говорит о том, что это доступно
[01:47:50.000 --> 01:47:52.000]  не только внутри этого файла, но и внутри других.
[01:47:52.000 --> 01:47:54.000]  Это не до конца, правда?
[01:47:54.000 --> 01:47:56.000]  Там модули.
[01:47:56.000 --> 01:47:58.000]  Обсудим это на следующей лекции.
[01:48:00.000 --> 01:48:02.000]  Ну, в плюсах там
[01:48:02.000 --> 01:48:04.000]  просто, если заимпортировал, там
[01:48:04.000 --> 01:48:06.000]  private-public элементарно работает.
[01:48:06.000 --> 01:48:08.000]  И, кстати говоря, еще в
[01:48:08.000 --> 01:48:10.000]  расте, вот почему-то во многих чатах
[01:48:10.000 --> 01:48:12.000]  видел,
[01:48:12.000 --> 01:48:14.000]  что люди для себя открывали,
[01:48:14.000 --> 01:48:16.000]  что доступность имени типа это разные вещи
[01:48:16.000 --> 01:48:18.000]  в плюсах.
[01:48:18.000 --> 01:48:20.000]  В том числе в чате
[01:48:20.000 --> 01:48:22.000]  concurrency это было.
[01:48:24.000 --> 01:48:26.000]  Это было еще в чате второго
[01:48:26.000 --> 01:48:28.000]  курса плюсов.
[01:48:28.000 --> 01:48:30.000]  Текущего, кажется, второго типа.
[01:48:30.000 --> 01:48:32.000]  Там есть чат по плюсам,
[01:48:32.000 --> 01:48:34.000]  просто уже плюсы прошли. Я видел, что там
[01:48:34.000 --> 01:48:36.000]  люди тоже для себя открывали такую новую вещь.
[01:48:36.000 --> 01:48:38.000]  В расте у вас так не получится.
[01:48:38.000 --> 01:48:40.000]  Он обратит внимание на то, что вы приватную
[01:48:40.000 --> 01:48:42.000]  структурку, которая
[01:48:42.000 --> 01:48:44.000]  недоступна этому коду.
[01:48:44.000 --> 01:48:46.000]  Выкидывайте и скажете,
[01:48:46.000 --> 01:48:48.000]  что сделайте ее публично, если вы хотите
[01:48:48.000 --> 01:48:50.000]  ее вернуть. Причем он это сделает
[01:48:50.000 --> 01:48:52.000]  до того, как вы попробуете вообще
[01:48:52.000 --> 01:48:54.000]  этой функции воспользоваться. Скажет, что вы возвращаете
[01:48:54.000 --> 01:48:56.000]  что-то с
[01:48:56.000 --> 01:48:58.000]  более узкой области
[01:48:58.000 --> 01:49:00.000]  видимости.
[01:49:00.000 --> 01:49:02.000]  Поэтому и у пап удобен.
[01:49:02.000 --> 01:49:04.000]  Потом мы об этом поговорим.
[01:49:06.000 --> 01:49:08.000]  Про Newtype еще что-нибудь поговорить?
[01:49:08.000 --> 01:49:10.000]  С ним все понятно?
[01:49:10.000 --> 01:49:12.000]  Это удобно.
[01:49:12.000 --> 01:49:14.000]  Обстрагировал years, days,
[01:49:14.000 --> 01:49:16.000]  потом, например, в стандартной библиотеке
[01:49:16.000 --> 01:49:18.000]  для time есть duration.
[01:49:18.000 --> 01:49:20.000]  Такая штука.
[01:49:20.000 --> 01:49:22.000]  Там все просто удобно.
[01:49:22.000 --> 01:49:24.000]  Такие имплы есть.
[01:49:24.000 --> 01:49:26.000]  Всякие перегруженные плюсы для
[01:49:26.000 --> 01:49:28.000]  правой и левой части.
[01:49:28.000 --> 01:49:30.000]  Это такой функциональный стиль
[01:49:30.000 --> 01:49:32.000]  достаточно.
[01:49:32.000 --> 01:49:34.000]  И позволяет, например,
[01:49:34.000 --> 01:49:36.000]  если в случае плюсов,
[01:49:36.000 --> 01:49:38.000]  если бы вы записали
[01:49:38.000 --> 01:49:40.000]  например, int64t,
[01:49:40.000 --> 01:49:42.000]  то у вас бы все работало,
[01:49:42.000 --> 01:49:44.000]  то в Rust за счет Newtype у вас все
[01:49:44.000 --> 01:49:46.000]  будет прекрасно.
[01:49:46.000 --> 01:49:48.000]  У вас там будет прям отдельная
[01:49:48.000 --> 01:49:50.000]  структурка, которая будет прям называться
[01:49:50.000 --> 01:49:52.000]  так, как вам хочется.
[01:49:52.000 --> 01:49:54.000]  Вот. Смотрите.
[01:49:54.000 --> 01:49:56.000]  Еще в Rust можно хэшировать объекты.
[01:49:58.000 --> 01:50:00.000]  TradeHasher выглядит вот так.
[01:50:00.000 --> 01:50:02.000]  Ну, хэшировать объекты
[01:50:02.000 --> 01:50:04.000]  мы сначала начнем, конечно,
[01:50:04.000 --> 01:50:06.000]  с
[01:50:06.000 --> 01:50:08.000]  того, что
[01:50:08.000 --> 01:50:10.000]  само по себе хэшируют.
[01:50:10.000 --> 01:50:12.000]  То есть вы же понимаете,
[01:50:12.000 --> 01:50:14.000]  что у нас бывают разные
[01:50:14.000 --> 01:50:16.000]  типы хэшей. Разные алгоритмы
[01:50:16.000 --> 01:50:18.000]  хэширования.
[01:50:18.000 --> 01:50:20.000]  Да.
[01:50:20.000 --> 01:50:22.000]  На Hasher и Hashable по сути разбивают.
[01:50:22.000 --> 01:50:24.000]  Давайте сначала посмотрим на Hasher.
[01:50:24.000 --> 01:50:26.000]  Hasher это такая штука, которая
[01:50:26.000 --> 01:50:28.000]  умеет, во-первых,
[01:50:28.000 --> 01:50:30.000]  писать какие-то произвольные байты.
[01:50:30.000 --> 01:50:32.000]  Это самая главная функция.
[01:50:32.000 --> 01:50:34.000]  Она берет какой-то слайс байтов и
[01:50:34.000 --> 01:50:36.000]  пишет их.
[01:50:36.000 --> 01:50:38.000]  И есть структурка Finish,
[01:50:38.000 --> 01:50:40.000]  которая, собственно, возвращает
[01:50:40.000 --> 01:50:42.000]  U64 результат хэширования.
[01:50:42.000 --> 01:50:44.000]  Возможно, если вы
[01:50:44.000 --> 01:50:46.000]  помните о COS, у вас был
[01:50:46.000 --> 01:50:48.000]  OpenSSL. Вы тоже, когда хэшировали,
[01:50:48.000 --> 01:50:50.000]  вы записывали частями
[01:50:50.000 --> 01:50:52.000]  по байтову, да?
[01:50:52.000 --> 01:50:54.000]  Все это кусочками, там, какими-то слайсами
[01:50:54.000 --> 01:50:56.000]  байтов. Здесь то же самое. Здесь также
[01:50:56.000 --> 01:50:58.000]  абстрагировано. Вы можете хэшировать
[01:50:58.000 --> 01:51:00.000]  произвольные наборы байтов. За счет этого
[01:51:00.000 --> 01:51:02.000]  Hasher потенциально может работать
[01:51:02.000 --> 01:51:04.000]  с любым типом.
[01:51:04.000 --> 01:51:06.000]  Закисывать куда-нибудь?
[01:51:06.000 --> 01:51:08.000]  Или куда записывать?
[01:51:08.000 --> 01:51:10.000]  Ты
[01:51:10.000 --> 01:51:12.000]  отрабатывал когда-нибудь с OpenSSL
[01:51:12.000 --> 01:51:14.000]  например?
[01:51:14.000 --> 01:51:16.000]  У кого-то
[01:51:16.000 --> 01:51:18.000]  у кого-то у вас закончился второй
[01:51:18.000 --> 01:51:20.000]  субъект РАКОСА?
[01:51:20.000 --> 01:51:22.000]  У всех.
[01:51:22.000 --> 01:51:24.000]  У всех.
[01:51:24.000 --> 01:51:26.000]  Возможно, там
[01:51:26.000 --> 01:51:28.000]  должна была быть
[01:51:28.000 --> 01:51:30.000]  подача на OpenSSL, если первым один еще не убрал.
[01:51:30.000 --> 01:51:32.000]  Там же как-то она была.
[01:51:32.000 --> 01:51:34.000]  Было прикольно.
[01:51:34.000 --> 01:51:36.000]  Просто смотри, нам плохо, если у нас
[01:51:36.000 --> 01:51:38.000]  Hasher будет специализироваться для каждого
[01:51:38.000 --> 01:51:40.000]  отдельного типа. Например, там
[01:51:40.000 --> 01:51:42.000]  для E-size, для U-size
[01:51:42.000 --> 01:51:44.000]  отдельно. Мы хотим просто, чтобы наш Hasher
[01:51:44.000 --> 01:51:46.000]  имел какой-то абстрактный
[01:51:46.000 --> 01:51:48.000]  алгоритм, который хэширует произвольные
[01:51:48.000 --> 01:51:50.000]  байты.
[01:51:50.000 --> 01:51:52.000]  И после этого мы можем и U8
[01:51:52.000 --> 01:51:54.000]  тип
[01:51:54.000 --> 01:51:56.000]  захэшировать просто слайс из одного байта
[01:51:56.000 --> 01:51:58.000]  отправив. И U64,
[01:51:58.000 --> 01:52:00.000]  и слайс строковый, и что хочешь.
[01:52:00.000 --> 01:52:02.000]  Просто произвольные наборы байтов.
[01:52:02.000 --> 01:52:04.000]  То есть Hasher это такая штука, которая
[01:52:04.000 --> 01:52:06.000]  хэширует, по сути, произвольные наборы байтов.
[01:52:06.000 --> 01:52:08.000]  И она тогда действует?
[01:52:08.000 --> 01:52:10.000]  Ну, у нее
[01:52:10.000 --> 01:52:12.000]  есть какой-то стрейт? Ну, у этого трейта, да,
[01:52:12.000 --> 01:52:14.000]  есть какой-то, ну, у самого трейта
[01:52:14.000 --> 01:52:16.000]  нет, но у той структуры, которая имплеметирует Hasher
[01:52:16.000 --> 01:52:18.000]  должен быть какой-то стейт, который
[01:52:18.000 --> 01:52:20.000]  она будет содержать внутри себя.
[01:52:20.000 --> 01:52:22.000]  Точно так, то, что должно быть, следует
[01:52:22.000 --> 01:52:24.000]  изновищим функциям финиш, который, если не хочет
[01:52:24.000 --> 01:52:26.000]  разрешить константов,
[01:52:26.000 --> 01:52:28.000]  например.
[01:52:32.000 --> 01:52:34.000]  Что еще раз?
[01:52:36.000 --> 01:52:38.000]  И это просто какой-то
[01:52:38.000 --> 01:52:40.000]  набор байтов, которые ты хочешь
[01:52:40.000 --> 01:52:42.000]  захэшировать.
[01:52:42.000 --> 01:52:44.000]  Например, если ты делаешь write U32,
[01:52:44.000 --> 01:52:46.000]  все, что, по сути, внутри происходит, это вызов
[01:52:46.000 --> 01:52:48.000]  write со слайсом
[01:52:48.000 --> 01:52:50.000]  из четырех байтов.
[01:52:50.000 --> 01:52:52.000]  Да.
[01:52:52.000 --> 01:52:54.000]  Ну, просто для удобства
[01:52:54.000 --> 01:52:56.000]  вашего, чтобы могли просто запихнуть
[01:52:56.000 --> 01:52:58.000]  там то, что вам удобнее.
[01:52:58.000 --> 01:53:00.000]  Ну, там есть еще какие-то имплементации,
[01:53:00.000 --> 01:53:02.000]  я там все не выписывал, просто показал
[01:53:02.000 --> 01:53:04.000]  какие-то из них.
[01:53:04.000 --> 01:53:06.000]  А нельзя оставить просто,
[01:53:06.000 --> 01:53:08.000]  типа, вот write и разные
[01:53:08.000 --> 01:53:10.000]  типы, оно не будет, как вот,
[01:53:10.000 --> 01:53:12.000]  переопределять функции нельзя
[01:53:12.000 --> 01:53:14.000]  в write, правильно?
[01:53:14.000 --> 01:53:16.000]  Да, переопределять нельзя.
[01:53:16.000 --> 01:53:18.000]  И типа, чтобы оно само определило.
[01:53:18.000 --> 01:53:20.000]  Да, перегрузок функций не отразится.
[01:53:22.000 --> 01:53:24.000]  Смотрите, вот давайте
[01:53:24.000 --> 01:53:26.000]  попробуем использовать хэшер из
[01:53:26.000 --> 01:53:28.000]  hashMap'а. Он чуть-чуть
[01:53:28.000 --> 01:53:30.000]  запрятан, поэтому нам придется его достать
[01:53:30.000 --> 01:53:32.000]  таким образом. U-System Decollections hashMap
[01:53:32.000 --> 01:53:34.000]  default-hash.
[01:53:34.000 --> 01:53:36.000]  Вот, это тот самый медленный хэшер,
[01:53:36.000 --> 01:53:38.000]  который нам замедляет хэштабличку.
[01:53:38.000 --> 01:53:40.000]  Тем не менее, который
[01:53:40.000 --> 01:53:42.000]  дает мало коллизий.
[01:53:42.000 --> 01:53:44.000]  Создаем
[01:53:44.000 --> 01:53:46.000]  дефолтный хэшер, и смотрите, я и U32
[01:53:46.000 --> 01:53:48.000]  записал, и U8,
[01:53:48.000 --> 01:53:50.000]  и еще один U8, да, хэшер
[01:53:50.000 --> 01:53:52.000]  с несколькими записями.
[01:53:52.000 --> 01:53:54.000]  Потом еще, смотрите,
[01:53:54.000 --> 01:53:56.000]  я об этом не рассказывал, можно литералы
[01:53:56.000 --> 01:53:58.000]  делать, строковые, байтовые.
[01:53:58.000 --> 01:54:00.000]  Если вы дописываете B перед
[01:54:00.000 --> 01:54:02.000]  строковым литералом, то это означает, что
[01:54:02.000 --> 01:54:04.000]  компилятор будет
[01:54:04.000 --> 01:54:06.000]  на это смотреть, как на слайс U8,
[01:54:06.000 --> 01:54:08.000]  а не на слайс строки.
[01:54:08.000 --> 01:54:10.000]  То есть, по сути, приведет просто время
[01:54:10.000 --> 01:54:12.000]  компиляции.
[01:54:12.000 --> 01:54:14.000]  Ну что-то.
[01:54:14.000 --> 01:54:16.000]  Я не понимаю, что делать в Write,
[01:54:16.000 --> 01:54:18.000]  в Write от строки
[01:54:18.000 --> 01:54:20.000]  он что делает?
[01:54:20.000 --> 01:54:22.000]  Как он?
[01:54:22.000 --> 01:54:24.000]  В Write от строки он берет байты,
[01:54:24.000 --> 01:54:26.000]  ну, получается, что там 4 байта
[01:54:26.000 --> 01:54:28.000]  внутри строчки,
[01:54:28.000 --> 01:54:30.000]  и он вызовет в Write
[01:54:30.000 --> 01:54:32.000]  от 4-х байтового слайса.
[01:54:32.000 --> 01:54:34.000]  Ну, а сам Write уже как-то прожевывает
[01:54:34.000 --> 01:54:36.000]  эти байты.
[01:54:36.000 --> 01:54:38.000]  Сам Write там зависит
[01:54:38.000 --> 01:54:40.000]  от алгоритма хэширования, там, например,
[01:54:40.000 --> 01:54:42.000]  может боксорить все байты, ну, чисто для примера.
[01:54:42.000 --> 01:54:44.000]  А статистически он
[01:54:44.000 --> 01:54:46.000]  должен получить хэш по этой игре,
[01:54:46.000 --> 01:54:48.000]  или что?
[01:54:48.000 --> 01:54:50.000]  Он должен дописать
[01:54:50.000 --> 01:54:52.000]  байты. Ну, представь, что у тебя в итоге
[01:54:52.000 --> 01:54:54.000]  это то же самое,
[01:54:54.000 --> 01:54:56.000]  что если бы я, например, в самом начале
[01:54:56.000 --> 01:54:58.000]  дал 4 байта, потом еще один байт,
[01:54:58.000 --> 01:55:00.000]  потом еще один байт, потом еще 4 байта,
[01:55:00.000 --> 01:55:02.000]  то этот вот кусок, если бы я сразу в Write записал,
[01:55:02.000 --> 01:55:04.000]  было бы то же самое.
[01:55:04.000 --> 01:55:06.000]  То есть, по сути, в случае, когда мы хэшируем данные,
[01:55:06.000 --> 01:55:08.000]  они не помещаются в память разом
[01:55:08.000 --> 01:55:10.000]  или по недоступным разом, поэтому мы их вот так
[01:55:10.000 --> 01:55:12.000]  давайте я проговорю, чтобы
[01:55:12.000 --> 01:55:14.000]  это, наверное, Андрея не слышно.
[01:55:14.000 --> 01:55:16.000]  Просто потому, что эта память
[01:55:16.000 --> 01:55:18.000]  не всегда вмещается, поэтому
[01:55:18.000 --> 01:55:20.000]  нам удобно
[01:55:20.000 --> 01:55:22.000]  иметь именно такой дизайн
[01:55:22.000 --> 01:55:24.000]  трейд хэш.
[01:55:24.000 --> 01:55:26.000]  Вот. Ну, если вы
[01:55:26.000 --> 01:55:28.000]  выведете, получится вот какой-то
[01:55:28.000 --> 01:55:30.000]  вот такой вот хэш.
[01:55:30.000 --> 01:55:32.000]  Ну, вроде да.
[01:55:32.000 --> 01:55:34.000]  Я вроде раз background запускал,
[01:55:34.000 --> 01:55:36.000]  получался такой хэш.
[01:55:36.000 --> 01:55:38.000]  Ну, я не гарантирую, что он потом
[01:55:38.000 --> 01:55:40.000]  не изменится, конечно.
[01:55:40.000 --> 01:55:42.000]  На момент создания лекции
[01:55:42.000 --> 01:55:44.000]  было так.
[01:55:44.000 --> 01:55:46.000]  Для Write есть какие-то требования
[01:55:46.000 --> 01:55:48.000]  на гарантии?
[01:55:48.000 --> 01:55:50.000]  Требования гарантии, что
[01:55:50.000 --> 01:55:52.000]  неважно,
[01:55:52.000 --> 01:55:54.000]  какими кусками ты подавал отсутствие байтов.
[01:55:56.000 --> 01:55:58.000]  Ну да, если
[01:55:58.000 --> 01:56:00.000]  в самом начале, ну, если
[01:56:00.000 --> 01:56:02.000]  у 32 подавать по 1 байту,
[01:56:02.000 --> 01:56:04.000]  то все равно все получится.
[01:56:04.000 --> 01:56:06.000]  Еще, кстати говоря, хэшер в Rust
[01:56:06.000 --> 01:56:08.000]  гарантирует, что от запуска к запуску будет
[01:56:08.000 --> 01:56:10.000]  один и тот же хэш.
[01:56:10.000 --> 01:56:12.000]  Но он гарантирует то, что внутри одного запуска
[01:56:12.000 --> 01:56:14.000]  одни и те же типы будут
[01:56:14.000 --> 01:56:16.000]  гарантировать, ну,
[01:56:16.000 --> 01:56:18.000]  давать один и тот же хэш. Ну, это сделано просто
[01:56:18.000 --> 01:56:20.000]  с точки зрения безопасности.
[01:56:20.000 --> 01:56:22.000]  Вам такое
[01:56:22.000 --> 01:56:24.000]  требование зачастую не надо просто,
[01:56:24.000 --> 01:56:26.000]  чтобы у вас хэш постоянно давал свою
[01:56:26.000 --> 01:56:28.000]  знаку.
[01:56:28.000 --> 01:56:30.000]  Ну, это как обзор,
[01:56:30.000 --> 01:56:32.000]  в котором, наверное, хэш там
[01:56:32.000 --> 01:56:34.000]  объедется, там хэш сидится
[01:56:34.000 --> 01:56:36.000]  так.
[01:56:36.000 --> 01:56:38.000]  Так.
[01:56:38.000 --> 01:56:40.000]  Теперь у нас есть трейд-хэш.
[01:56:40.000 --> 01:56:42.000]  Это, собственно,
[01:56:42.000 --> 01:56:44.000]  объекты, которые мы можем хэшировать.
[01:56:44.000 --> 01:56:46.000]  Ну, то, что хэш был.
[01:56:46.000 --> 01:56:48.000]  Только называется оно хэш.
[01:56:48.000 --> 01:56:50.000]  Вот.
[01:56:50.000 --> 01:56:52.000]  Для начала у нас есть вот такая вот штука.
[01:56:52.000 --> 01:56:54.000]  Это функция хэш,
[01:56:54.000 --> 01:56:56.000]  которая принимает какой-то стейт.
[01:56:56.000 --> 01:56:58.000]  Стейт это, собственно, и есть сам
[01:56:58.000 --> 01:57:00.000]  хэшер.
[01:57:00.000 --> 01:57:02.000]  Если вы хотите что-то захэшировать,
[01:57:02.000 --> 01:57:04.000]  тогда вы передаете
[01:57:04.000 --> 01:57:06.000]  стейт, ну, то есть сам хэшер,
[01:57:06.000 --> 01:57:08.000]  и записываете у него и делаете
[01:57:08.000 --> 01:57:10.000]  final,
[01:57:10.000 --> 01:57:12.000]  чтобы получить результат.
[01:57:12.000 --> 01:57:14.000]  Вот.
[01:57:14.000 --> 01:57:16.000]  Ну, точнее, final вы не делаете,
[01:57:16.000 --> 01:57:18.000]  просто
[01:57:18.000 --> 01:57:20.000]  запись происходит.
[01:57:20.000 --> 01:57:22.000]  Кстати, а вот тут по синтезу мы не могли
[01:57:22.000 --> 01:57:24.000]  не писать,
[01:57:24.000 --> 01:57:26.000]  где h это хэшер,
[01:57:26.000 --> 01:57:28.000]  а написать в...
[01:57:28.000 --> 01:57:30.000]  Ну, вот.
[01:57:30.000 --> 01:57:32.000]  Мы могли hash,
[01:57:32.000 --> 01:57:34.000]  двоеточие хэша написать.
[01:57:34.000 --> 01:57:36.000]  Вот.
[01:57:36.000 --> 01:57:38.000]  Ну, есть еще hash slice,
[01:57:38.000 --> 01:57:40.000]  который позволяет slice таких объектов
[01:57:40.000 --> 01:57:42.000]  хэшировать.
[01:57:42.000 --> 01:57:44.000]  Ну,
[01:57:44.000 --> 01:57:46.000]  он имплементируется через hash просто тем,
[01:57:46.000 --> 01:57:48.000]  что мы имплементируемся по slice.
[01:57:48.000 --> 01:57:50.000]  Смотрите, по всему кому-то было очень удобно,
[01:57:50.000 --> 01:57:52.000]  он добавил эту функцию до форта.
[01:57:52.000 --> 01:57:54.000]  Давайте попробуем имплементировать
[01:57:54.000 --> 01:57:56.000]  hash
[01:57:56.000 --> 01:57:58.000]  ручками.
[01:57:58.000 --> 01:58:00.000]  Смотрите.
[01:58:00.000 --> 01:58:02.000]  Берем person,
[01:58:02.000 --> 01:58:04.000]  в person быть стадийшник,
[01:58:04.000 --> 01:58:06.000]  имя и какой-то номер мобильного.
[01:58:06.000 --> 01:58:08.000]  Смотрите, что я делаю.
[01:58:08.000 --> 01:58:10.000]  Как раз h-hash у меня, кстати, написано.
[01:58:10.000 --> 01:58:12.000]  Как раз ответ на вопрос,
[01:58:12.000 --> 01:58:14.000]  можно так делать?
[01:58:14.000 --> 01:58:16.000]  Ну, и что я делаю?
[01:58:16.000 --> 01:58:18.000]  Я просто хэширую сначала ID, а потом фолл.
[01:58:18.000 --> 01:58:20.000]  Обратите внимание, на имя я не хэширую.
[01:58:20.000 --> 01:58:22.000]  Я могу так сделать,
[01:58:22.000 --> 01:58:24.000]  никто не запрещает, это у меня
[01:58:24.000 --> 01:58:26.000]  хэш игнорирует просто имя.
[01:58:26.000 --> 01:58:28.000]  А как возвращать?
[01:58:28.000 --> 01:58:30.000]  А, возвращать как раз.
[01:58:30.000 --> 01:58:32.000]  Чтобы вернуть сам результат хэширования,
[01:58:32.000 --> 01:58:34.000]  нужно в стейд постучаться уже.
[01:58:34.000 --> 01:58:36.000]  Попросить стейд, пожалуйста, верни мне.
[01:58:36.000 --> 01:58:38.000]  Сделаю финиш.
[01:58:38.000 --> 01:58:40.000]  Вот.
[01:58:40.000 --> 01:58:42.000]  Когда вы имплементируете
[01:58:42.000 --> 01:58:44.000]  одновременно и hash, и equal,
[01:58:44.000 --> 01:58:46.000]  очень-очень важный момент вам
[01:58:46.000 --> 01:58:48.000]  нужно предусмотреть, что если у вас 2 ключа равны,
[01:58:48.000 --> 01:58:50.000]  то у вас hash и равный.
[01:58:50.000 --> 01:58:52.000]  Значит, это бред, конечно.
[01:58:52.000 --> 01:58:54.000]  Что? Звучит как бред?
[01:58:54.000 --> 01:58:56.000]  Ну да, это будет...
[01:58:56.000 --> 01:58:58.000]  Соответственно получается hash не hash,
[01:58:58.000 --> 01:59:00.000]  если у нас будет не равенство,
[01:59:00.000 --> 01:59:02.000]  но вам обязательно нужно это...
[01:59:02.000 --> 01:59:04.000]  Обязательно это нужно учесть,
[01:59:04.000 --> 01:59:06.000]  в том числе hash map и hash set,
[01:59:06.000 --> 01:59:08.000]  они на это полагаются.
[01:59:12.000 --> 01:59:14.000]  Так.
[01:59:14.000 --> 01:59:16.000]  Потом у нас есть дроп.
[01:59:16.000 --> 01:59:18.000]  Дроп мы уже видели.
[01:59:18.000 --> 01:59:20.000]  Обратите внимание.
[01:59:20.000 --> 01:59:22.000]  Очень важно, у вас дроп
[01:59:22.000 --> 01:59:24.000]  не принимает здесь self.
[01:59:24.000 --> 01:59:26.000]  У вас принимает drop mute self.
[01:59:26.000 --> 01:59:28.000]  Потому что дроп
[01:59:28.000 --> 01:59:30.000]  это просто такая фигня,
[01:59:30.000 --> 01:59:32.000]  которая вызывается компилятором.
[01:59:32.000 --> 01:59:34.000]  То есть вы не видите
[01:59:34.000 --> 01:59:36.000]  явно этих вызовов,
[01:59:36.000 --> 01:59:38.000]  но когда у вас переменная drop,
[01:59:38.000 --> 01:59:40.000]  у вас вызывается функция drop перед этим.
[01:59:40.000 --> 01:59:42.000]  Ну и она там что-то делает,
[01:59:42.000 --> 01:59:44.000]  а потом же компилятор
[01:59:44.000 --> 01:59:46.000]  только делалакцирует поля.
[01:59:46.000 --> 01:59:48.000]  Еще, кстати говоря,
[01:59:48.000 --> 01:59:50.000]  был, кажется, на второй лекции
[01:59:50.000 --> 01:59:52.000]  вопрос про то, когда же переменная
[01:59:52.000 --> 01:59:54.000]  дропается, как это все работает.
[01:59:54.000 --> 01:59:56.000]  Кажется, наверное,
[01:59:56.000 --> 01:59:58.000]  мне не получилось адекватно этот вопрос ответить.
[01:59:58.000 --> 02:00:00.000]  Тут есть ссылочка
[02:00:00.000 --> 02:00:02.000]  на REST Reference, как оно прямо подробно
[02:00:02.000 --> 02:00:04.000]  работает. Там вообще никакой
[02:00:04.000 --> 02:00:06.000]  магии нет, там все просто.
[02:00:06.000 --> 02:00:08.000]  Но правила есть.
[02:00:08.000 --> 02:00:10.000]  Много правил, в общем, есть.
[02:00:10.000 --> 02:00:12.000]  Вкратце, просто
[02:00:12.000 --> 02:00:14.000]  если у вас овнер выходит из
[02:00:14.000 --> 02:00:16.000]  скопа, то есть его нужно
[02:00:16.000 --> 02:00:18.000]  дропнуть владельцем.
[02:00:18.000 --> 02:00:20.000]  Если у вас переменная вышла из скопа,
[02:00:20.000 --> 02:00:22.000]  тогда то, чем владеет переменная,
[02:00:22.000 --> 02:00:24.000]  нужно дропнуть. Собственно, ровно это и происходит.
[02:00:24.000 --> 02:00:26.000]  Ну и там специфицируется, когда
[02:00:26.000 --> 02:00:28.000]  drop вызывается, все такое.
[02:00:28.000 --> 02:00:30.000]  Я думаю, вы ничего неожиданного не найдете,
[02:00:30.000 --> 02:00:32.000]  но если вам интересно подробно,
[02:00:32.000 --> 02:00:34.000]  можете почитать.
[02:00:34.000 --> 02:00:36.000]  Да.
[02:00:40.000 --> 02:00:42.000]  Так, давайте мы
[02:00:42.000 --> 02:00:44.000]  drop by hand
[02:00:44.000 --> 02:00:46.000]  имплементируем.
[02:00:46.000 --> 02:00:48.000]  Сначала просто какую-то структуру
[02:00:48.000 --> 02:00:50.000]  hasDrop, которая будет нам принять, что
[02:00:50.000 --> 02:00:52.000]  ее дропают.
[02:00:52.000 --> 02:00:54.000]  Ну и давайте hasToDrops.
[02:00:54.000 --> 02:00:56.000]  Сделали какую-то
[02:00:56.000 --> 02:00:58.000]  структуру hasToDrops, у которой есть
[02:00:58.000 --> 02:01:00.000]  drop,
[02:01:00.000 --> 02:01:02.000]  который принять, что
[02:01:02.000 --> 02:01:04.000]  мы hasToDrops дропаем.
[02:01:04.000 --> 02:01:06.000]  Ну и соответственно, если мы это
[02:01:06.000 --> 02:01:08.000]  запустим,
[02:01:08.000 --> 02:01:10.000]  вот так вот, тогда сначала у нас создастся
[02:01:10.000 --> 02:01:12.000]  hasToDrops.
[02:01:12.000 --> 02:01:14.000]  Потом у нас будет running.
[02:01:14.000 --> 02:01:16.000]  Ну и если, соответственно, у нас
[02:01:16.000 --> 02:01:18.000]  запустится running, вызывается running, потом
[02:01:18.000 --> 02:01:20.000]  мы выйдем из копы и мы начнем drop
[02:01:20.000 --> 02:01:22.000]  hasToDrops. Сначала вызовется hasToDrops,
[02:01:22.000 --> 02:01:24.000]  потом вызовется
[02:01:24.000 --> 02:01:26.000]  hasDrop, вызовется hasDrop
[02:01:26.000 --> 02:01:28.000]  от 1, а потом от 2.
[02:01:28.000 --> 02:01:30.000]  Вот так вот это работает.
[02:01:34.000 --> 02:01:36.000]  Ну тут все очень просто,
[02:01:36.000 --> 02:01:38.000]  1, 2, это hasDrop, hasDrop.
[02:01:40.000 --> 02:01:42.000]  Какие-то поля.
[02:01:44.000 --> 02:01:46.000]  Ну да.
[02:01:46.000 --> 02:01:48.000]  Да.
[02:01:48.000 --> 02:01:50.000]  Еще есть
[02:01:50.000 --> 02:01:52.000]  бывает такое, что вам хочется, чтобы
[02:01:52.000 --> 02:01:54.000]  drop не вызывался компилятором
[02:01:54.000 --> 02:01:56.000]  автоматически.
[02:01:56.000 --> 02:01:58.000]  Вот. Для этого есть такая
[02:01:58.000 --> 02:02:00.000]  структурка, называется manualDrop.
[02:02:00.000 --> 02:02:02.000]  Она такая для компилятора
[02:02:02.000 --> 02:02:04.000]  особенная. Компилятор знает, что
[02:02:04.000 --> 02:02:06.000]  то, что обернуто в эту
[02:02:06.000 --> 02:02:08.000]  структурку, в общем, от этой структурки
[02:02:08.000 --> 02:02:10.000]  не нужно вызывать drop.
[02:02:10.000 --> 02:02:12.000]  От нее нужно вызывать только руками.
[02:02:12.000 --> 02:02:14.000]  Можно только руками.
[02:02:14.000 --> 02:02:16.000]  Вот.
[02:02:16.000 --> 02:02:18.000]  Ну, вы можете создать с произвольным значением
[02:02:18.000 --> 02:02:20.000]  tag на тремене или drop,
[02:02:20.000 --> 02:02:22.000]  потом intoInner,
[02:02:22.000 --> 02:02:24.000]  там всякие.
[02:02:24.000 --> 02:02:26.000]  Еще обратите внимание, тут есть unsaved
[02:02:26.000 --> 02:02:28.000]  функции take и drop.
[02:02:28.000 --> 02:02:30.000]  Вот.
[02:02:30.000 --> 02:02:32.000]  Ну,
[02:02:32.000 --> 02:02:34.000]  это сделана структурка,
[02:02:34.000 --> 02:02:36.000]  во-первых, для того, чтобы это было очевидно
[02:02:36.000 --> 02:02:38.000]  для пользователя, то, что в этой структурке
[02:02:38.000 --> 02:02:40.000]  не вызывается drop.
[02:02:42.000 --> 02:02:44.000]  Во-вторых, так как
[02:02:44.000 --> 02:02:46.000]  вы руками
[02:02:46.000 --> 02:02:48.000]  управляете manualDrop,
[02:02:48.000 --> 02:02:50.000]  вам никто не мешает вызвать drop,
[02:02:50.000 --> 02:02:52.000]  а потом сделать take.
[02:02:52.000 --> 02:02:54.000]  И тогда бы было memory unsaved.
[02:02:54.000 --> 02:02:56.000]  Поэтому эти две функции
[02:02:56.000 --> 02:02:58.000]  unsaved.
[02:03:02.000 --> 02:03:04.000]  Вот у нас есть поле
[02:03:04.000 --> 02:03:06.000]  в структуре, который manualDrop.
[02:03:06.000 --> 02:03:08.000]  Когда структуру
[02:03:08.000 --> 02:03:10.000]  уничтожается, она не уничтожает, ведь
[02:03:10.000 --> 02:03:12.000]  это поле.
[02:03:12.000 --> 02:03:14.000]  Well, manualDrop у нас
[02:03:14.000 --> 02:03:16.000]  особенный просто. Раз знать, что
[02:03:16.000 --> 02:03:18.000]  не нужно вызывать на нем drop.
[02:03:18.000 --> 02:03:20.000]  У него особенного поведения.
[02:03:20.000 --> 02:03:22.000]  Ну, просто мы таким образом не получим
[02:03:22.000 --> 02:03:24.000]  утечку памяти?
[02:03:24.000 --> 02:03:26.000]  Ну, у нас есть структура,
[02:03:26.000 --> 02:03:28.000]  у нее есть поле, которое manualDrop.
[02:03:30.000 --> 02:03:32.000]  Ну, поле имеет такое, да.
[02:03:34.000 --> 02:03:36.000]  Нет, ну, утечку памяти ты можешь получить.
[02:03:36.000 --> 02:03:38.000]  Утечка памяти — это save,
[02:03:38.000 --> 02:03:40.000]  как я говорил на прошлый лет.
[02:03:40.000 --> 02:03:42.000]  Да, раст — это
[02:03:42.000 --> 02:03:44.000]  считает save. Ну, это правда,
[02:03:44.000 --> 02:03:46.000]  потому что утечка памяти — это просто
[02:03:46.000 --> 02:03:48.000]  плохо, но это не ломает
[02:03:48.000 --> 02:03:50.000]  код.
[02:03:50.000 --> 02:03:52.000]  А что в целом будет происходить в такой ситуации?
[02:03:52.000 --> 02:03:54.000]  Дропнутся все поля, кроме manualDrop.
[02:03:54.000 --> 02:03:56.000]  manualDrop не будет
[02:03:56.000 --> 02:03:58.000]  вызываться.
[02:04:02.000 --> 02:04:04.000]  Да, нужно реализовать самому, писать
[02:04:04.000 --> 02:04:06.000]  ручками, это все.
[02:04:08.000 --> 02:04:10.000]  Если manualDrop
[02:04:10.000 --> 02:04:12.000]  мне нужно там написать,
[02:04:12.000 --> 02:04:14.000]  что я unsaved.
[02:04:16.000 --> 02:04:18.000]  Что еще раз? Если я использую manualDrop?
[02:04:18.000 --> 02:04:20.000]  manualDrop использует unsaved
[02:04:20.000 --> 02:04:22.000]  функцию.
[02:04:22.000 --> 02:04:24.000]  Как этим воспользоваться, Миша?
[02:04:24.000 --> 02:04:26.000]  Ну, тебе, чтобы воспользоваться unsaved функцией,
[02:04:26.000 --> 02:04:28.000]  нужен блок unsaved. Ты пишешь unsaved,
[02:04:28.000 --> 02:04:30.000]  и там фигуристые скобочки.
[02:04:30.000 --> 02:04:32.000]  Я вам просто для примера показываю, что здесь вот
[02:04:32.000 --> 02:04:34.000]  так как это небезопасно,
[02:04:34.000 --> 02:04:36.000]  это отмечено unsaved.
[02:04:36.000 --> 02:04:38.000]  Если вы unsaved сильно не знакомы,
[02:04:38.000 --> 02:04:40.000]  вам manualDrop нигде не понадобится.
[02:04:40.000 --> 02:04:42.000]  Пока что.
[02:04:42.000 --> 02:04:44.000]  Поэтому не пугайтесь.
[02:04:44.000 --> 02:04:46.000]  Вам это
[02:04:46.000 --> 02:04:48.000]  просто для справочки, что в расте
[02:04:48.000 --> 02:04:50.000]  можно и руками вызывать дроп
[02:04:50.000 --> 02:04:52.000]  без компилятора.
[02:04:56.000 --> 02:04:58.000]  Есть еще trade at.
[02:04:58.000 --> 02:05:00.000]  Это способ имплементировать
[02:05:00.000 --> 02:05:02.000]  плюс.
[02:05:02.000 --> 02:05:04.000]  Ну и смотрите, здесь
[02:05:04.000 --> 02:05:06.000]  вот у нас уже есть ассоциированный тип.
[02:05:06.000 --> 02:05:08.000]  В итераторе у нас, помните, был
[02:05:08.000 --> 02:05:10.000]  тоже item, и здесь у нас есть typeOutput.
[02:05:12.000 --> 02:05:14.000]  И мы возвращаем в ад какой-то
[02:05:14.000 --> 02:05:16.000]  selfOutput.
[02:05:16.000 --> 02:05:18.000]  А, это та самая
[02:05:18.000 --> 02:05:20.000]  штука, там где next
[02:05:20.000 --> 02:05:22.000]  был?
[02:05:22.000 --> 02:05:24.000]  Да-да, там next возвращал
[02:05:24.000 --> 02:05:26.000]  общем на item, на selfItem.
[02:05:26.000 --> 02:05:28.000]  Сейчас, а оно о чем говорит?
[02:05:28.000 --> 02:05:30.000]  О том, что структура,
[02:05:30.000 --> 02:05:32.000]  которая использует это, обязательно должна иметь
[02:05:32.000 --> 02:05:34.000]  поле. Нет, она должна не иметь
[02:05:34.000 --> 02:05:36.000]  поле, она должна сказать, что
[02:05:36.000 --> 02:05:38.000]  typeOutput равняется чему-то.
[02:05:38.000 --> 02:05:40.000]  То есть она должна специфицировать
[02:05:40.000 --> 02:05:42.000]  какой типу output.
[02:05:44.000 --> 02:05:46.000]  Сейчас, наверное, пример будет.
[02:05:46.000 --> 02:05:48.000]  Да, будет как раз пример. В данном случае
[02:05:48.000 --> 02:05:50.000]  я вот явно прописал, что output
[02:05:50.000 --> 02:05:52.000]  равняется self.
[02:05:52.000 --> 02:05:54.000]  Тип self.
[02:05:54.000 --> 02:05:56.000]  Вот у нас есть структурка point, у которой
[02:05:56.000 --> 02:05:58.000]  x и y это какие-то типы t.
[02:05:58.000 --> 02:06:00.000]  И я
[02:06:00.000 --> 02:06:02.000]  имплементирую для add
[02:06:02.000 --> 02:06:04.000]  ну для point
[02:06:04.000 --> 02:06:06.000]  trade add. Я указал, что output
[02:06:06.000 --> 02:06:08.000]  это self, потом функция add
[02:06:08.000 --> 02:06:10.000]  написал
[02:06:10.000 --> 02:06:12.000]  достаточно банальным образом.
[02:06:12.000 --> 02:06:14.000]  Кстати, обратите еще внимание,
[02:06:14.000 --> 02:06:16.000]  что мне пришлось для того,
[02:06:16.000 --> 02:06:18.000]  чтобы вот это вот работало. Раз же по умолчанию
[02:06:18.000 --> 02:06:20.000]  ничего не требует от
[02:06:20.000 --> 02:06:22.000]  типа, поэтому нам
[02:06:22.000 --> 02:06:24.000]  нужно явно сказать, что t
[02:06:24.000 --> 02:06:26.000]  это на самом деле add с output
[02:06:26.000 --> 02:06:28.000]  равным t. То есть
[02:06:28.000 --> 02:06:30.000]  именно то, что я здесь вот сделал.
[02:06:30.000 --> 02:06:32.000]  Почему не тебе было просто
[02:06:32.000 --> 02:06:34.000]  импл т сделать?
[02:06:34.000 --> 02:06:36.000]  Импл т, потому что он бы тогда
[02:06:36.000 --> 02:06:38.000]  сказал, почему это ты суммируешь,
[02:06:38.000 --> 02:06:40.000]  при том, что у нас t не умеет
[02:06:40.000 --> 02:06:42.000]  суммироваться.
[02:06:52.000 --> 02:06:54.000]  Соответственно, еще есть такая add assign.
[02:06:54.000 --> 02:06:56.000]  Это уже плюс равно.
[02:06:56.000 --> 02:06:58.000]  Соответственно, берет
[02:06:58.000 --> 02:07:00.000]  правую часть и записывает
[02:07:00.000 --> 02:07:02.000]  какой-то результат лево.
[02:07:08.000 --> 02:07:10.000]  Потом usage exam.
[02:07:10.000 --> 02:07:12.000]  Ну тоже вот какой-то я пишу
[02:07:12.000 --> 02:07:14.000]  результат. Я в self записываю
[02:07:14.000 --> 02:07:16.000]  результат суммирования точно
[02:07:16.000 --> 02:07:18.000]  такой же, как и до этого.
[02:07:18.000 --> 02:07:20.000]  Вот.
[02:07:24.000 --> 02:07:26.000]  Здесь оператор присваивает
[02:07:26.000 --> 02:07:28.000]  к self присваивает значение
[02:07:28.000 --> 02:07:30.000]  к self присваивает значение
[02:07:30.000 --> 02:07:32.000]  point, где x это self x
[02:07:32.000 --> 02:07:34.000]  присадр x и y это self y
[02:07:34.000 --> 02:07:36.000]  присадр y.
[02:07:36.000 --> 02:07:38.000]  Что еще раз?
[02:07:38.000 --> 02:07:40.000]  Эту штуку тоже можно перегрузить, да?
[02:07:42.000 --> 02:07:44.000]  Оператор равно нельзя.
[02:07:44.000 --> 02:07:46.000]  Ровно не перегружается.
[02:07:48.000 --> 02:07:50.000]  Так.
[02:07:50.000 --> 02:07:52.000]  Конечно, в расе ее можно перегрузить
[02:07:52.000 --> 02:07:54.000]  примерно любой такой рефинитический оператор.
[02:07:54.000 --> 02:07:56.000]  А отца в мул, то есть там
[02:07:56.000 --> 02:07:58.000]  сложение.
[02:08:02.000 --> 02:08:04.000]  Он просто делает мулы.
[02:08:04.000 --> 02:08:06.000]  Он просто делает мулы и копирует битики.
[02:08:10.000 --> 02:08:12.000]  Муф нет.
[02:08:14.000 --> 02:08:16.000]  Это ремайндер остаток
[02:08:16.000 --> 02:08:18.000]  в делении.
[02:08:20.000 --> 02:08:22.000]  Да, это shift left и shift right.
[02:08:24.000 --> 02:08:26.000]  Вот, это всякие рефинитические
[02:08:26.000 --> 02:08:28.000]  операторы. Соответственно, у них есть
[02:08:28.000 --> 02:08:30.000]  assign варианты, типа bit or assign.
[02:08:30.000 --> 02:08:32.000]  Такие вот варианты.
[02:08:32.000 --> 02:08:34.000]  Еще есть
[02:08:34.000 --> 02:08:36.000]  перегрузка операторов not и
[02:08:36.000 --> 02:08:38.000]  negative. Ну, not понятно,
[02:08:38.000 --> 02:08:40.000]  это
[02:08:40.000 --> 02:08:42.000]  отрицание
[02:08:42.000 --> 02:08:44.000]  логическое, а negative это просто минус.
[02:08:44.000 --> 02:08:46.000]  То есть, не минус один, не минус два.
[02:08:46.000 --> 02:08:48.000]  У них, конечно,
[02:08:48.000 --> 02:08:50.000]  уже нет assign вариации, потому что это
[02:08:50.000 --> 02:08:52.000]  все-таки унарные операторы.
[02:08:52.000 --> 02:08:54.000]  Поэтому у них не может быть assign варианта.
[02:08:56.000 --> 02:08:58.000]  Вот.
[02:08:58.000 --> 02:09:00.000]  Ну, если что, почитайте.
[02:09:00.000 --> 02:09:02.000]  Они там абсолютно точно так же устроены,
[02:09:02.000 --> 02:09:04.000]  как и add. Просто там
[02:09:04.000 --> 02:09:06.000]  перегружают другие операторы.
[02:09:06.000 --> 02:09:08.000]  Тут понятно?
[02:09:08.000 --> 02:09:10.000]  Так.
[02:09:10.000 --> 02:09:12.000]  У нас есть индекс.
[02:09:12.000 --> 02:09:14.000]  Индекс – это то, что перегружает
[02:09:14.000 --> 02:09:16.000]  квадратные скобочки.
[02:09:16.000 --> 02:09:18.000]  Причем в immutable
[02:09:18.000 --> 02:09:20.000]  контекстах.
[02:09:20.000 --> 02:09:22.000]  Сейчас посмотрим, что такое immutable
[02:09:22.000 --> 02:09:24.000]  контекст. Вот, смотрите.
[02:09:24.000 --> 02:09:26.000]  У нас стоит, который
[02:09:26.000 --> 02:09:28.000]  индексируется каким-то типом
[02:09:28.000 --> 02:09:30.000]  индекс. Ну, idx.
[02:09:30.000 --> 02:09:32.000]  В случае всяких там
[02:09:32.000 --> 02:09:34.000]  векторов idx – это
[02:09:34.000 --> 02:09:36.000]  usize.
[02:09:36.000 --> 02:09:38.000]  Плюс ко всему у нас, видите, idx
[02:09:38.000 --> 02:09:40.000]  не обязательно что сайсит,
[02:09:40.000 --> 02:09:42.000]  и output тоже не обязательно сайсит.
[02:09:42.000 --> 02:09:44.000]  Интересно.
[02:09:44.000 --> 02:09:46.000]  Потом у нас есть функция
[02:09:46.000 --> 02:09:48.000]  индекс.
[02:09:48.000 --> 02:09:50.000]  Собственно, когда вы пишете
[02:09:50.000 --> 02:09:52.000]  контейнер индекс, как я сверху написал,
[02:09:52.000 --> 02:09:54.000]  то если вы напишете
[02:09:54.000 --> 02:09:56.000]  контейнер.индекс в скобочках индекс,
[02:09:56.000 --> 02:09:58.000]  то в таком случае это будет то же самое,
[02:09:58.000 --> 02:10:00.000]  что вызвать квадратные скобочки.
[02:10:00.000 --> 02:10:02.000]  На самом деле в расти сети плюс равно
[02:10:02.000 --> 02:10:04.000]  умножить и так далее – это все
[02:10:04.000 --> 02:10:06.000]  просто синтактический сахар для трейтов,
[02:10:06.000 --> 02:10:08.000]  в которых через точку вот это
[02:10:08.000 --> 02:10:10.000]  вызывается.
[02:10:10.000 --> 02:10:12.000]  Вот.
[02:10:12.000 --> 02:10:14.000]  Индексу разрешено
[02:10:14.000 --> 02:10:16.000]  паниковать, когда он выходит
[02:10:16.000 --> 02:10:18.000]  за границы.
[02:10:18.000 --> 02:10:20.000]  Ну, то есть если вы вышли за какие-то
[02:10:20.000 --> 02:10:22.000]  условные границы, которые вы сами себе придумали,
[02:10:22.000 --> 02:10:24.000]  то РАСТ вам разрешает паникуйте.
[02:10:24.000 --> 02:10:26.000]  Это адекватное
[02:10:26.000 --> 02:10:28.000]  поведение. В принципе, вы можете паниковать
[02:10:28.000 --> 02:10:30.000]  где хотите, но просто в документации
[02:10:30.000 --> 02:10:32.000]  местами в РАСТе написано, как лучше имплементировать,
[02:10:32.000 --> 02:10:34.000]  чтобы
[02:10:34.000 --> 02:10:36.000]  поведение было предсказуемым
[02:10:36.000 --> 02:10:38.000]  для пользователей одинаково.
[02:10:38.000 --> 02:10:40.000]  То есть в панике вот если
[02:10:40.000 --> 02:10:42.000]  запаниковало все, это упало?
[02:10:42.000 --> 02:10:44.000]  Ну, на самом деле нет.
[02:10:44.000 --> 02:10:46.000]  Мы потом посмотрим на то,
[02:10:46.000 --> 02:10:48.000]  как ловить панику. Там можно такие вещи
[02:10:48.000 --> 02:10:50.000]  делать. Но это вообще нормальная практика
[02:10:50.000 --> 02:10:52.000]  ловить панику? Не.
[02:10:52.000 --> 02:10:54.000]  Паника – это unrecoverable
[02:10:54.000 --> 02:10:56.000]  error. То есть, конечно,
[02:10:56.000 --> 02:10:58.000]  так можно делать, но не надо.
[02:10:58.000 --> 02:11:00.000]  Я вот не понимаю,
[02:11:00.000 --> 02:11:02.000]  вообще он не знает вопроса size
[02:11:02.000 --> 02:11:04.000]  вообще, но он сплоткует информацию
[02:11:04.000 --> 02:11:06.000]  новую. Да, если бы ты не
[02:11:06.000 --> 02:11:08.000]  написал, то тогда бы у тебя было требование,
[02:11:08.000 --> 02:11:10.000]  что IDX – это size тип.
[02:11:10.000 --> 02:11:12.000]  А так ты можешь в качестве IDX, например,
[02:11:12.000 --> 02:11:14.000]  слайз засунуть.
[02:11:16.000 --> 02:11:18.000]  Ну, и индекс возвращает
[02:11:18.000 --> 02:11:20.000]  ссылку на опыт.
[02:11:20.000 --> 02:11:22.000]  Давайте попробуем воспользоваться.
[02:11:22.000 --> 02:11:24.000]  У нас есть какой-то янам нуклеотид,
[02:11:24.000 --> 02:11:26.000]  то есть структурка нуклеотид count.
[02:11:26.000 --> 02:11:28.000]  Ну, соответственно,
[02:11:28.000 --> 02:11:30.000]  ACGT, я там не помню из биологии,
[02:11:30.000 --> 02:11:32.000]  примерно так называются нуклеотиды.
[02:11:36.000 --> 02:11:38.000]  Ну, и то же самое там
[02:11:38.000 --> 02:11:40.000]  какие-то count.
[02:11:40.000 --> 02:11:42.000]  Ну, давайте импенсируем
[02:11:42.000 --> 02:11:44.000]  индекс для нуклеотид count.
[02:11:44.000 --> 02:11:46.000]  Обратите внимание, что у меня
[02:11:46.000 --> 02:11:48.000]  индекс принимает на обход нуклеотид.
[02:11:48.000 --> 02:11:50.000]  То есть, я отдаю ему
[02:11:50.000 --> 02:11:52.000]  в качестве типа, по которому
[02:11:52.000 --> 02:11:54.000]  индексируюсь нуклеотид.
[02:11:54.000 --> 02:11:56.000]  И после этого,
[02:11:56.000 --> 02:11:58.000]  когда меня индексирует нуклеотидом,
[02:11:58.000 --> 02:12:00.000]  принимаю наход
[02:12:00.000 --> 02:12:02.000]  матчем.
[02:12:02.000 --> 02:12:04.000]  Понимаю наход нуклеотид, матчусь по нему
[02:12:04.000 --> 02:12:06.000]  и возвращаю соответствующий тип.
[02:12:08.000 --> 02:12:10.000]  Ну, соответствующее число.
[02:12:12.000 --> 02:12:14.000]  Понятно?
[02:12:16.000 --> 02:12:18.000]  Ну, надеюсь, что понятно.
[02:12:20.000 --> 02:12:22.000]  Так.
[02:12:22.000 --> 02:12:24.000]  Теперь есть еще индекс mute.
[02:12:24.000 --> 02:12:26.000]  Сейчас разберемся, в чем у меня отличается
[02:12:26.000 --> 02:12:28.000]  mutable and mutable context.
[02:12:28.000 --> 02:12:30.000]  У меня есть
[02:12:30.000 --> 02:12:32.000]  примерчик.
[02:12:32.000 --> 02:12:34.000]  Здесь, как вы можете заметить, разница в том,
[02:12:34.000 --> 02:12:36.000]  что, во-первых, индекс mute требует реализации
[02:12:36.000 --> 02:12:38.000]  индекс, потому что если вы не умеете
[02:12:38.000 --> 02:12:40.000]  индексироваться, то к чему вам индекс mute?
[02:12:42.000 --> 02:12:44.000]  Потом отличие в том, что у нас не просто индекс,
[02:12:44.000 --> 02:12:46.000]  а индекс mute называется функция внутри.
[02:12:46.000 --> 02:12:48.000]  И возвращаем ему табельную ссылочку.
[02:12:50.000 --> 02:12:52.000]  А не просто ссылку на cellpal.
[02:12:54.000 --> 02:12:56.000]  Давайте попробуем
[02:12:56.000 --> 02:12:58.000]  разобраться с индекс индекс mute.
[02:12:58.000 --> 02:13:00.000]  Сделаем какую-то структурку тест,
[02:13:00.000 --> 02:13:02.000]  в которой внутри x.
[02:13:02.000 --> 02:13:04.000]  Это усайс.
[02:13:04.000 --> 02:13:06.000]  Потом сделаем имплементацию
[02:13:06.000 --> 02:13:08.000]  для теста.
[02:13:08.000 --> 02:13:10.000]  Вот.
[02:13:10.000 --> 02:13:12.000]  Ну, принимаем наход усайс, и потом
[02:13:12.000 --> 02:13:14.000]  просто возвращаем self x.
[02:13:14.000 --> 02:13:16.000]  То есть, по сути, я ничего не делаю с индексом,
[02:13:16.000 --> 02:13:18.000]  который мне выдали, а просто возвращаю текущий
[02:13:18.000 --> 02:13:20.000]  x у теста.
[02:13:20.000 --> 02:13:22.000]  И принчу, что я об индексе.
[02:13:22.000 --> 02:13:24.000]  Понятно, как
[02:13:24.000 --> 02:13:26.000]  имплементировано?
[02:13:28.000 --> 02:13:30.000]  Мы возвращаем
[02:13:30.000 --> 02:13:32.000]  с индекса.
[02:13:32.000 --> 02:13:34.000]  Ну, просто на x у той некоторые
[02:13:34.000 --> 02:13:36.000]  тесты. Я даже индекс,
[02:13:36.000 --> 02:13:38.000]  по которому индексируюсь, просто игнорирую
[02:13:38.000 --> 02:13:40.000]  в качестве примера.
[02:13:42.000 --> 02:13:44.000]  Ну, и примерно то же самое
[02:13:44.000 --> 02:13:46.000]  с индекс mute, только отличие в том, что
[02:13:46.000 --> 02:13:48.000]  я возвращаю табельную ссылочку и вывожу
[02:13:48.000 --> 02:13:50.000]  то, что в индекс mute.
[02:13:50.000 --> 02:13:52.000]  Сейчас потресим, что же у нас будет
[02:13:52.000 --> 02:13:54.000]  в каком случае выводиться, индекс или индекс mute.
[02:14:00.000 --> 02:14:02.000]  Да, вот он.
[02:14:04.000 --> 02:14:06.000]  Так.
[02:14:06.000 --> 02:14:08.000]  Вот, у нас тест 1, это какой-то
[02:14:08.000 --> 02:14:10.000]  x 42, и потом есть mute
[02:14:10.000 --> 02:14:12.000]  тест 2, это x 42.
[02:14:12.000 --> 02:14:14.000]  Ну, давайте вызовем тест 1.0.
[02:14:14.000 --> 02:14:16.000]  И это, конечно же,
[02:14:16.000 --> 02:14:18.000]  будет иммутабельный контекст,
[02:14:18.000 --> 02:14:20.000]  потому что у нас переменная не мутабельная.
[02:14:20.000 --> 02:14:22.000]  Соответственно, у нас вызовется
[02:14:22.000 --> 02:14:24.000]  индекс.
[02:14:24.000 --> 02:14:26.000]  Потом, если я вызову тест 2.0,
[02:14:26.000 --> 02:14:28.000]  при своем значении нулю,
[02:14:28.000 --> 02:14:30.000]  в таком случае это будет индекс mute.
[02:14:30.000 --> 02:14:32.000]  Потому что мы мутируем.
[02:14:32.000 --> 02:14:34.000]  Нам нужна мутабельная ссылка.
[02:14:34.000 --> 02:14:36.000]  Раст это вывел. Если вы напишете
[02:14:36.000 --> 02:14:38.000]  сверху просто тест 2.0,
[02:14:38.000 --> 02:14:40.000]  то в таком случае, точка из битой,
[02:14:40.000 --> 02:14:42.000]  то у вас вызовется просто индекс.
[02:14:42.000 --> 02:14:44.000]  Потому что Раст понимает, что вы ничего не мутируете,
[02:14:44.000 --> 02:14:46.000]  и вернуть
[02:14:46.000 --> 02:14:48.000]  нужно просто индекс.
[02:14:48.000 --> 02:14:50.000]  Иммутабельную ссылку.
[02:14:52.000 --> 02:14:54.000]  Давайте возьму
[02:14:54.000 --> 02:14:56.000]  ссылочку на
[02:14:56.000 --> 02:14:58.000]  тест 2.x. И попробую
[02:14:58.000 --> 02:15:00.000]  тест 2.0 при своем значении
[02:15:00.000 --> 02:15:02.000]  единичку.
[02:15:12.000 --> 02:15:14.000]  Еще раз, что?
[02:15:14.000 --> 02:15:16.000]  У нас нарушение правил
[02:15:16.000 --> 02:15:18.000]  владения.
[02:15:18.000 --> 02:15:20.000]  У нас получается, что мы пытаемся
[02:15:20.000 --> 02:15:22.000]  взять мутабельную ссылку, когда у нас есть
[02:15:22.000 --> 02:15:24.000]  не мутабельную.
[02:15:26.000 --> 02:15:28.000]  Потом вызовем тест 2.0
[02:15:28.000 --> 02:15:30.000]  и
[02:15:30.000 --> 02:15:32.000]  Раст выяснил, что нам нужен индекс.
[02:15:32.000 --> 02:15:34.000]  Во-первых, потому что у нас есть
[02:15:34.000 --> 02:15:36.000]  ссылка в R.
[02:15:36.000 --> 02:15:38.000]  Во-вторых, потому что мы ничего не мутируем.
[02:15:38.000 --> 02:15:40.000]  Вот.
[02:15:42.000 --> 02:15:44.000]  Ну и, соответственно, если мы выведем R,
[02:15:44.000 --> 02:15:46.000]  то мы получим ноль, потому что мы тест 2.0
[02:15:46.000 --> 02:15:48.000]  при своем значении ноль.
[02:15:50.000 --> 02:15:52.000]  Вот так вот.
[02:15:52.000 --> 02:15:54.000]  Раст просто понимает из контекста, что вы хотите.
[02:15:54.000 --> 02:15:56.000]  Иммутабельную ссылку или не мутабельную?
[02:16:00.000 --> 02:16:02.000]  Смотри, у тебя есть
[02:16:02.000 --> 02:16:04.000]  не мутабельная ссылка на тест 2.x.
[02:16:04.000 --> 02:16:06.000]  А теперь ты пытаешься
[02:16:06.000 --> 02:16:08.000]  на x внутри,
[02:16:08.000 --> 02:16:10.000]  мутировать. Смотри, у тебя мутабельная
[02:16:10.000 --> 02:16:12.000]  ссылка на x возвращается здесь.
[02:16:12.000 --> 02:16:14.000]  Соответственно, ты по мутабельной ссылке x
[02:16:14.000 --> 02:16:16.000]  пытаешься сейчас мутировать.
[02:16:16.000 --> 02:16:18.000]  То есть, имеешь прямо сейчас не мутабельную
[02:16:18.000 --> 02:16:20.000]  ссылку, ты пытаешься
[02:16:20.000 --> 02:16:22.000]  мутировать переменно. Это нарушение правил
[02:16:22.000 --> 02:16:24.000]  владения, потому что есть либо одна мутабельная ссылка, либо
[02:16:24.000 --> 02:16:26.000]  сколько года много
[02:16:26.000 --> 02:16:28.000]  не мутабельных.
[02:16:32.000 --> 02:16:34.000]  Так.
[02:16:34.000 --> 02:16:36.000]  Ну, с этим понятно.
[02:16:38.000 --> 02:16:40.000]  Теперь давайте Read&Write.
[02:16:42.000 --> 02:16:44.000]  Мы можем страгироваться, потому что
[02:16:44.000 --> 02:16:46.000]  умеет писать либо читать.
[02:16:46.000 --> 02:16:48.000]  Давайте посмотрим для начала на
[02:16:48.000 --> 02:16:50.000]  TradeRead. У него есть
[02:16:50.000 --> 02:16:52.000]  одна очень важная функция,
[02:16:52.000 --> 02:16:54.000]  называется Read. Принимает
[02:16:54.000 --> 02:16:56.000]  на вход какой-то slice
[02:16:56.000 --> 02:16:58.000]  байтов, которые нужно записать.
[02:16:58.000 --> 02:17:00.000]  Ну, которые нужно
[02:17:00.000 --> 02:17:02.000]  прочитать и записать
[02:17:02.000 --> 02:17:04.000]  бухер. Ну, и соответственно
[02:17:04.000 --> 02:17:06.000]  возвращает сколько прочитали,
[02:17:06.000 --> 02:17:08.000]  либо ошибку.
[02:17:08.000 --> 02:17:10.000]  И всякие на основе этого Read
[02:17:10.000 --> 02:17:12.000]  есть дефолтные имплементации.
[02:17:12.000 --> 02:17:14.000]  Это какие-то примеры.
[02:17:14.000 --> 02:17:16.000]  Читать мы можем для REST-файла,
[02:17:16.000 --> 02:17:18.000]  или с TCP Stream,
[02:17:18.000 --> 02:17:20.000]  с CDN, и даже
[02:17:20.000 --> 02:17:22.000]  можем читать из всяких строковых слайсов,
[02:17:22.000 --> 02:17:24.000]  векторов и так далее.
[02:17:24.000 --> 02:17:26.000]  Ну, то есть,
[02:17:26.000 --> 02:17:28.000]  рас в этом плане
[02:17:28.000 --> 02:17:30.000]  хорошо абстрагирован, что мы можем
[02:17:30.000 --> 02:17:32.000]  читать, даже в тестах написать
[02:17:32.000 --> 02:17:34.000]  просто набор байтиков,
[02:17:34.000 --> 02:17:36.000]  из которых мы хотим читать, и
[02:17:36.000 --> 02:17:38.000]  REST будет...
[02:17:38.000 --> 02:17:40.000]  читать из них.
[02:17:42.000 --> 02:17:44.000]  Сейчас ReadBuff.
[02:17:50.000 --> 02:17:52.000]  Ух, ну, это кажется
[02:17:52.000 --> 02:17:54.000]  буфер просто какой-то.
[02:17:54.000 --> 02:17:56.000]  Ну, я просто какие-то взял
[02:17:56.000 --> 02:17:58.000]  функции, например, с документацией. Я, честно говоря,
[02:17:58.000 --> 02:18:00.000]  не помню.
[02:18:02.000 --> 02:18:04.000]  Ты имеешь в виду вот это вот...
[02:18:04.000 --> 02:18:06.000]  Да, там
[02:18:06.000 --> 02:18:08.000]  lifetime,
[02:18:08.000 --> 02:18:10.000]  кажется, должен зависеть от Read.
[02:18:10.000 --> 02:18:12.000]  Для этого нужно просто
[02:18:12.000 --> 02:18:14.000]  вспомнить, почитать, что делает ReadBuff
[02:18:14.000 --> 02:18:16.000]  в документации. Я его совсем не помню.
[02:18:28.000 --> 02:18:30.000]  Вот, если ReadExide,
[02:18:30.000 --> 02:18:32.000]  то ты либо прочитал, либо не прочитал
[02:18:32.000 --> 02:18:34.000]  что-то из двух. Вот.
[02:18:40.000 --> 02:18:42.000]  Так.
[02:18:42.000 --> 02:18:44.000]  Теперь внёмся...
[02:18:44.000 --> 02:18:46.000]  Ну, пойдём к TradeToWrite.
[02:18:46.000 --> 02:18:48.000]  Write — это, соответственно,
[02:18:48.000 --> 02:18:50.000]  то, что мы умеем читать,
[02:18:50.000 --> 02:18:52.000]  соответственно, мы не можем читать
[02:18:52.000 --> 02:18:54.000]  из всех этих строковых слайсов,
[02:18:54.000 --> 02:18:56.000]  но мы можем читать из всех этих строковых
[02:18:56.000 --> 02:18:58.000]  слайсов, соответственно, то, что мы умеем читать,
[02:18:58.000 --> 02:19:00.000]  соответственно, тоже умеем из
[02:19:00.000 --> 02:19:02.000]  File, TCP и так далее читать.
[02:19:02.000 --> 02:19:04.000]  Здесь есть целых две функции важных.
[02:19:04.000 --> 02:19:06.000]  Это Write, который
[02:19:06.000 --> 02:19:08.000]  записывает из
[02:19:08.000 --> 02:19:10.000]  какого-то буфера.
[02:19:10.000 --> 02:19:12.000]  И Flush.
[02:19:12.000 --> 02:19:14.000]  То есть мы ещё, возможно,
[02:19:14.000 --> 02:19:16.000]  можем написать какие-то
[02:19:16.000 --> 02:19:18.000]  буферизованные
[02:19:18.000 --> 02:19:20.000]  записи.
[02:19:20.000 --> 02:19:22.000]  Flush означает то, что мы
[02:19:22.000 --> 02:19:24.000]  буфер прямо сейчас
[02:19:24.000 --> 02:19:26.000]  делаем пустым.
[02:19:26.000 --> 02:19:28.000]  То есть мы пустошаем.
[02:19:28.000 --> 02:19:30.000]  Вот.
[02:19:30.000 --> 02:19:32.000]  Понятно ли, почему
[02:19:32.000 --> 02:19:34.000]  так Trade устроен?
[02:19:34.000 --> 02:19:36.000]  Так.
[02:19:40.000 --> 02:19:42.000]  WriteAll будет Write по кругу
[02:19:42.000 --> 02:19:44.000]  вызывать, пока он всё не запишет
[02:19:44.000 --> 02:19:46.000]  или пока на ошибку.
[02:19:48.000 --> 02:19:50.000]  Ну, Flush вызывается...
[02:19:50.000 --> 02:19:52.000]  Это зависит от структуры.
[02:19:52.000 --> 02:19:54.000]  Просто мы можем сразу же писать те байты, которые нам дали,
[02:19:54.000 --> 02:19:56.000]  а мы можем в структуре хранить
[02:19:56.000 --> 02:19:58.000]  какой-то буфер.
[02:20:10.000 --> 02:20:12.000]  Ну, Flush внутри
[02:20:12.000 --> 02:20:14.000]  Write в WriteAll не вызывается.
[02:20:14.000 --> 02:20:16.000]  Он существует только для структуры,
[02:20:16.000 --> 02:20:18.000]  которая имплементирует Write.
[02:20:18.000 --> 02:20:20.000]  Для пользователей.
[02:20:20.000 --> 02:20:22.000]  Ты на ОКОСе помнишь, как
[02:20:22.000 --> 02:20:24.000]  ты в TCP писал по кругу?
[02:20:34.000 --> 02:20:36.000]  Так. Нужно вернуть
[02:20:36.000 --> 02:20:38.000]  студентов.
[02:20:46.000 --> 02:20:48.000]  Теперь давайте
[02:20:48.000 --> 02:20:50.000]  BuffRead перейдём.
[02:20:50.000 --> 02:20:52.000]  BuffRead это
[02:20:52.000 --> 02:20:54.000]  буферизованное чтение.
[02:20:54.000 --> 02:20:56.000]  Соответственно, мы можем
[02:20:56.000 --> 02:20:58.000]  либо заполнить буфер
[02:20:58.000 --> 02:21:00.000]  внутренний какой-то.
[02:21:00.000 --> 02:21:02.000]  Во-первых, мы умеем читать точно так же, как мы до этого
[02:21:02.000 --> 02:21:04.000]  читали. Во-вторых, у нас появляется дополнительная
[02:21:04.000 --> 02:21:06.000]  функция для работы с буфером.
[02:21:06.000 --> 02:21:08.000]  Заполнить буфер и
[02:21:10.000 --> 02:21:12.000]  так, я не помню, что конкретно
[02:21:12.000 --> 02:21:14.000]  делать консюм, если честно.
[02:21:14.000 --> 02:21:16.000]  Я помню, что я читал, подзабыл.
[02:21:16.000 --> 02:21:18.000]  Давайте, чтобы не соврать
[02:21:18.000 --> 02:21:20.000]  и не буду вам точно говорить, что
[02:21:20.000 --> 02:21:22.000]  делать консюм, но самое главное
[02:21:22.000 --> 02:21:24.000]  FillBuff.
[02:21:24.000 --> 02:21:26.000]  Он
[02:21:26.000 --> 02:21:28.000]  заполняет наш внутренний буфер
[02:21:28.000 --> 02:21:30.000]  в той структурке,
[02:21:30.000 --> 02:21:32.000]  которая у нас буферизованное чтение
[02:21:32.000 --> 02:21:34.000]  имплементирует.
[02:21:36.000 --> 02:21:38.000]  У нас более того есть
[02:21:38.000 --> 02:21:40.000]  BuffReader.
[02:21:40.000 --> 02:21:42.000]  Она предназначена для того, чтобы
[02:21:42.000 --> 02:21:44.000]  по умолчанию как-то буферизовывать
[02:21:44.000 --> 02:21:46.000]  чтение. Она внутри
[02:21:46.000 --> 02:21:48.000]  себя содержит буфер
[02:21:48.000 --> 02:21:50.000]  какого-то размера. Я боюсь
[02:21:50.000 --> 02:21:52.000]  соврать, возможно, 4-килобайтный.
[02:21:52.000 --> 02:21:54.000]  Возможно, я вам конкретно
[02:21:54.000 --> 02:21:56.000]  вру, так что лучше проверить
[02:21:56.000 --> 02:21:58.000]  это в стандартной библиотеке. Ну, какого-то размера
[02:21:58.000 --> 02:22:00.000]  буфер. Она принимает
[02:22:00.000 --> 02:22:02.000]  в качестве типа T.
[02:22:02.000 --> 02:22:04.000]  Эта структурка является
[02:22:04.000 --> 02:22:06.000]  дженериком.
[02:22:08.000 --> 02:22:10.000]  Какой-то тип, который мы
[02:22:10.000 --> 02:22:12.000]  можем читать. И, соответственно,
[02:22:12.000 --> 02:22:14.000]  когда мы пытаемся что-то прочитать
[02:22:14.000 --> 02:22:16.000]  из него, тогда BuffReader
[02:22:16.000 --> 02:22:18.000]  записывает это все
[02:22:18.000 --> 02:22:20.000]  в свой буфер.
[02:22:20.000 --> 02:22:22.000]  Вот как-то так.
[02:22:22.000 --> 02:22:24.000]  Ну, если вам...
[02:22:24.000 --> 02:22:26.000]  То есть, по сути, достаточно
[02:22:26.000 --> 02:22:28.000]  имплементировать Read. Чтобы имплементировать
[02:22:28.000 --> 02:22:30.000]  BuffRead, вы можете просто обернуть
[02:22:30.000 --> 02:22:32.000]  в BuffRead то, что у вас Read.
[02:22:32.000 --> 02:22:34.000]  Вот так вот.
[02:22:40.000 --> 02:22:42.000]  Так.
[02:22:44.000 --> 02:22:46.000]  BuffRead using BuffWrite.
[02:22:48.000 --> 02:22:50.000]  Насколько я помню, здесь нет...
[02:22:50.000 --> 02:22:52.000]  Вот это вот лишнее.
[02:22:52.000 --> 02:22:54.000]  Это вот строчки.
[02:22:54.000 --> 02:22:56.000]  Забудьте про нее. Не должно быть.
[02:22:58.000 --> 02:23:00.000]  На самом деле, трейта BuffWrite нет, конечно же.
[02:23:02.000 --> 02:23:04.000]  Но вопрос...
[02:23:04.000 --> 02:23:06.000]  Почему там файл Open
[02:23:06.000 --> 02:23:08.000]  или знак вопроса?
[02:23:08.000 --> 02:23:10.000]  Ну, это треки.
[02:23:10.000 --> 02:23:12.000]  Ну, местная навыка.
[02:23:12.000 --> 02:23:14.000]  Open вообще отрезал.
[02:23:14.000 --> 02:23:16.000]  Смотрел на...
[02:23:16.000 --> 02:23:18.000]  Ну, ты либо успешно откроешь файл,
[02:23:18.000 --> 02:23:20.000]  либо, например, его может не быть,
[02:23:20.000 --> 02:23:22.000]  или не быть прав на чтение на него.
[02:23:22.000 --> 02:23:24.000]  Если не будет, то что?
[02:23:24.000 --> 02:23:26.000]  Это вернет какую-то ошибку.
[02:23:26.000 --> 02:23:28.000]  В котором проект?
[02:23:28.000 --> 02:23:30.000]  Их не ошибка.
[02:23:30.000 --> 02:23:32.000]  Ну, в вопросе,
[02:23:32.000 --> 02:23:34.000]  кто это делает, он просто
[02:23:34.000 --> 02:23:36.000]  мачит либо OK файл,
[02:23:36.000 --> 02:23:38.000]  либо error какая-то ошибка
[02:23:38.000 --> 02:23:40.000]  и пропихивает ее дальше.
[02:23:40.000 --> 02:23:42.000]  То есть этот код конкретно
[02:23:42.000 --> 02:23:44.000]  не запаникует?
[02:23:44.000 --> 02:23:46.000]  Нет, он не запаникует,
[02:23:46.000 --> 02:23:48.000]  если у вас Logtxt есть.
[02:23:50.000 --> 02:23:52.000]  А, и не надо проверять как раз
[02:23:52.000 --> 02:23:54.000]  их...
[02:23:54.000 --> 02:23:56.000]  Вопросик, это способ
[02:23:56.000 --> 02:23:58.000]  error handling со второй лекции.
[02:23:58.000 --> 02:24:00.000]  Вот.
[02:24:00.000 --> 02:24:02.000]  Да, я подумал,
[02:24:02.000 --> 02:24:04.000]  что это BuffWrite.
[02:24:04.000 --> 02:24:06.000]  Просто думаю, BuffReader есть.
[02:24:06.000 --> 02:24:08.000]  И по идее, должен называться BuffWriter,
[02:24:08.000 --> 02:24:10.000]  а потом вспомнил, что есть BuffWrite.
[02:24:10.000 --> 02:24:12.000]  Собственно, структурка.
[02:24:12.000 --> 02:24:14.000]  А, не, BuffWriter.
[02:24:14.000 --> 02:24:16.000]  Так как у нас
[02:24:16.000 --> 02:24:18.000]  манипулировать буфером в случае
[02:24:18.000 --> 02:24:20.000]  BuffWrite нет никакого смысла,
[02:24:20.000 --> 02:24:22.000]  поэтому у нас нет трейта BuffWrite.
[02:24:22.000 --> 02:24:24.000]  Просто нет в нем смысла,
[02:24:24.000 --> 02:24:26.000]  и его, соответственно, добавили.
[02:24:26.000 --> 02:24:28.000]  Если у вас бухфилизованное чтение существует,
[02:24:28.000 --> 02:24:30.000]  вы можете и воспользоваться
[02:24:30.000 --> 02:24:32.000]  в коме, например, в домашней издачке.
[02:24:36.000 --> 02:24:38.000]  Вот, есть такие еще прекрасные трейты,
[02:24:38.000 --> 02:24:40.000]  DisplayDebug.
[02:24:40.000 --> 02:24:42.000]  Это, собственно, то, что перегружает
[02:24:42.000 --> 02:24:44.000]  характер того, как мы форматируем строчки
[02:24:44.000 --> 02:24:46.000]  в MacroCFormat
[02:24:46.000 --> 02:24:48.000]  и в Println.
[02:24:48.000 --> 02:24:50.000]  Вот.
[02:24:50.000 --> 02:24:52.000]  Смотрите, у нас есть текст
[02:24:52.000 --> 02:24:54.000]  HelloWorld, вот такой вот.
[02:24:54.000 --> 02:24:56.000]  В случае Display мы выведем вот так вот.
[02:24:56.000 --> 02:24:58.000]  Просто Hello, у нас n есть
[02:24:58.000 --> 02:25:00.000]  World, соответственно.
[02:25:00.000 --> 02:25:02.000]  А если мы имплементируем
[02:25:02.000 --> 02:25:04.000]  Debug, то в таком случае,
[02:25:04.000 --> 02:25:06.000]  если мы выведем Debug,
[02:25:06.000 --> 02:25:08.000]  тогда у нас выведется строчка так, как она была бы в коде.
[02:25:08.000 --> 02:25:10.000]  HelloWorld, так вот в кавычках
[02:25:10.000 --> 02:25:12.000]  с
[02:25:12.000 --> 02:25:14.000]  slash n.
[02:25:14.000 --> 02:25:16.000]  То есть Display
[02:25:16.000 --> 02:25:18.000]  это просто что-то вывести на экран,
[02:25:18.000 --> 02:25:20.000]  а Debug — это Debug-вывод более подробный.
[02:25:20.000 --> 02:25:22.000]  С каким-то, возможно, форматируем.
[02:25:24.000 --> 02:25:26.000]  Вот.
[02:25:26.000 --> 02:25:28.000]  Давайте посмотрим
[02:25:28.000 --> 02:25:30.000]  сначала на Display.
[02:25:32.000 --> 02:25:34.000]  Это
[02:25:34.000 --> 02:25:36.000]  стока форматирования
[02:25:36.000 --> 02:25:38.000]  для пустых
[02:25:38.000 --> 02:25:40.000]  фигуристых скобочек.
[02:25:40.000 --> 02:25:42.000]  Вот как вот здесь у нас есть.
[02:25:44.000 --> 02:25:46.000]  Если вы пишете пустые скобочки,
[02:25:46.000 --> 02:25:48.000]  то у вас вызывается Display.
[02:25:48.000 --> 02:25:50.000]  Собственно, он принимает на вход
[02:25:50.000 --> 02:25:52.000]  какой-то форматор, на который мы сейчас посмотрим.
[02:25:54.000 --> 02:25:56.000]  Что-то с ним делает, и после этого
[02:25:56.000 --> 02:25:58.000]  возвращает либо OK, то есть я все записал,
[02:25:58.000 --> 02:26:00.000]  либо какую-то ошибку.
[02:26:02.000 --> 02:26:04.000]  Для форматора есть еще
[02:26:04.000 --> 02:26:06.000]  подробная документация.
[02:26:06.000 --> 02:26:08.000]  Если захотите,
[02:26:08.000 --> 02:26:10.000]  можете ее почитать.
[02:26:10.000 --> 02:26:12.000]  Мы сейчас будем, кажется...
[02:26:12.000 --> 02:26:14.000]  А, кажется, я подумал, наверное,
[02:26:14.000 --> 02:26:16.000]  что... А, у меня форматор все-таки есть
[02:26:16.000 --> 02:26:18.000]  в лекциях.
[02:26:18.000 --> 02:26:20.000]  Так.
[02:26:20.000 --> 02:26:22.000]  Давайте теперь посмотрим
[02:26:22.000 --> 02:26:24.000]  на Debug Trade.
[02:26:24.000 --> 02:26:26.000]  Это то, что появляется, когда вы пишете
[02:26:26.000 --> 02:26:28.000]  двоеточие вопросиков.
[02:26:28.000 --> 02:26:30.000]  У него есть даже Derive Debug
[02:26:30.000 --> 02:26:32.000]  Macro. То есть Display вам нужно писать
[02:26:32.000 --> 02:26:34.000]  самостоятельно, потому что Vras
[02:26:34.000 --> 02:26:36.000]  не знает, как выводить типы.
[02:26:36.000 --> 02:26:38.000]  Он абсолютно не понимает,
[02:26:38.000 --> 02:26:40.000]  что значит за Display какой-то произвольный тип.
[02:26:40.000 --> 02:26:42.000]  Но Debug он может
[02:26:42.000 --> 02:26:44.000]  задисплеить. Он будет писать
[02:26:44.000 --> 02:26:46.000]  например, в случае структуры,
[02:26:46.000 --> 02:26:48.000]  название поля и какое значение у поля.
[02:26:50.000 --> 02:26:52.000]  Вот.
[02:26:52.000 --> 02:26:54.000]  Это достаточно удобно.
[02:26:54.000 --> 02:26:56.000]  Это у вас лучший друг в случае Debug,
[02:26:56.000 --> 02:26:58.000]  если вам нужно подробно вывести
[02:26:58.000 --> 02:27:00.000]  какую-то структурку на экран.
[02:27:02.000 --> 02:27:04.000]  Так, давайте попробуем,
[02:27:04.000 --> 02:27:06.000]  как эти Trade с дизайном
[02:27:06.000 --> 02:27:08.000]  посмотреть.
[02:27:10.000 --> 02:27:12.000]  Обратите, во-первых, внимание, что мы можем вообще-то
[02:27:12.000 --> 02:27:14.000]  выводить любой объект.
[02:27:14.000 --> 02:27:16.000]  Мы сможем выводить в том числе всякие слайсы
[02:27:16.000 --> 02:27:18.000]  результатов форматирования.
[02:27:18.000 --> 02:27:20.000]  Но при этом у нас
[02:27:20.000 --> 02:27:22.000]  нет никаких дженериков.
[02:27:22.000 --> 02:27:24.000]  Давайте попробуем заранее ответить на вопрос.
[02:27:24.000 --> 02:27:26.000]  Как же так получилось, что дженериков нет,
[02:27:26.000 --> 02:27:28.000]  а выводим любой тип, который врать?
[02:27:28.000 --> 02:27:30.000]  Мы уже знаем ответ на этот вопрос.
[02:27:30.000 --> 02:27:32.000]  Вот.
[02:27:32.000 --> 02:27:34.000]  Когда Formatr создается,
[02:27:34.000 --> 02:27:36.000]  он там принимает на вход
[02:27:36.000 --> 02:27:38.000]  произвольный тип, который врает.
[02:27:40.000 --> 02:27:42.000]  Он не дженерик.
[02:27:42.000 --> 02:27:44.000]  Он дженерик по какому-то lifetime,
[02:27:44.000 --> 02:27:46.000]  но не дженерик по типу, который врает.
[02:27:50.000 --> 02:27:52.000]  Да, да, да, давай, давай.
[02:27:52.000 --> 02:27:54.000]  У нас есть точная ответственность для этого вопроса.
[02:27:56.000 --> 02:27:58.000]  Как вы считаете,
[02:27:58.000 --> 02:28:02.000]  Давай-давай, у нас есть точный ответ на этот вопрос, это лекция.
[02:28:02.000 --> 02:28:08.000]  Да, там динрайт. Там динамическая диспетчеризация.
[02:28:15.000 --> 02:28:21.000]  Значит, давайте подумаем о том, почему дебак так задизайнен так, как он задизайнен.
[02:28:21.000 --> 02:28:25.000]  Во-первых, нам плохо возвращать просто строчку, то есть result-строчка,
[02:28:26.000 --> 02:28:30.000]  потому что мы пишем какую-то, делаем какую-то лишнюю аллокацию.
[02:28:30.000 --> 02:28:32.000]  А что если мы хотим, например, записать файл.
[02:28:32.000 --> 02:28:36.000]  Зачем нам эта лишняя аллокация, если мы можем писать напрямую файл?
[02:28:36.000 --> 02:28:42.000]  А если я хотим какой-то буфер на стеке написать, ну как в Esprint?
[02:28:42.000 --> 02:28:48.000]  Если мы будем возвращать какую-то строку, то в таком случае мы будем промежуточно написать строку,
[02:28:48.000 --> 02:28:52.000]  а потом писать буфер. А что, если мы хотим напрямую написать буфер?
[02:28:55.000 --> 02:29:01.840]  если наш debug рекурсивно вызывается на подобъектах, то есть у нас не просто там какие-то и 32 и 64, а
[02:29:01.840 --> 02:29:07.480]  прямо там какие-то структуры внутри структур, тогда это будет на подобъектах вызываться, и тогда у
[02:29:07.480 --> 02:29:15.440]  нас было бы вообще n allocation под каждый такой вывод, им бы еще строки конкатинировали. Это плохо,
[02:29:15.440 --> 02:29:22.240]  поэтому мы хотим как-то писать напрямую туда, куда нас просят. Собственно у нас поэтому есть
[02:29:22.240 --> 02:29:31.440]  такая структура, называемая форматор. Подробно объяснять, что делают поля внутри, я не буду,
[02:29:31.440 --> 02:29:39.440]  нам это наверное не так интересно. У нас интереснее всего баф. Интереснее всего нам для бафа.
[02:29:39.440 --> 02:29:47.720]  Интереснее всего баф. Как вы можете заметить, у нас тут есть din-write. Как думаете, почему мы тут
[02:29:47.720 --> 02:29:53.760]  din написали? Почему мы не сделали форматор генериком по какому-то т, где t имплементирует write,
[02:29:53.760 --> 02:30:06.560]  и не запихнули его в этом din-t? Да, там неприемлемый кодблок. Там очень много типов имплементирует
[02:30:06.560 --> 02:30:13.120]  дебаг, и соответственно у нас гораздо быстрее работает код, если у нас будет тут din сидеть.
[02:30:13.120 --> 02:30:18.680]  Кстати, когда вам сказал про din-t, t если что это тип, соответственно din-tip написать не получится,
[02:30:18.680 --> 02:30:25.600]  нужно писать din-trate. Такой код не скомпилируется, я просто неправильно вам сказал. Вот.
[02:30:25.600 --> 02:30:40.040]  Да, форматор привязан к какому-то lifetime. Ну, например, форматор как минимум должен жить не меньше,
[02:30:40.040 --> 02:30:46.560]  чем объект, который в write. Потому что если форматор будет жить больше, чем открытый файл,
[02:30:46.560 --> 02:30:52.120]  то у нас получится unsafety опять. Поэтому у нас тут есть lifetime. Про lifetime чуть попозже поговорим.
[02:30:52.120 --> 02:31:04.200]  Еще у нас есть такой trait, называется toString. Он превращает объект в строчку. Соответственно
[02:31:04.200 --> 02:31:10.040]  он принимает объект, возвращаясь в строчку. Он автоматически имплементируется, если объект
[02:31:10.040 --> 02:31:16.760]  имплементирует дисплей. Соответственно toString не нужно имплементировать напрямую. Имплементируете
[02:31:16.760 --> 02:31:23.320]  дисплей, а потом вы бесплатно получите toString. Вопрос, а как же так получилось, что у нас
[02:31:23.320 --> 02:31:26.080]  автоматически что-то имплементируется? Как это сделать в коде?
[02:31:34.200 --> 02:31:39.200]  Не, я имею ввиду это автоматически имплементировано. Автоматически у нас появляется trait.toString.
[02:31:39.200 --> 02:31:46.360]  Если у нас имплементирован debug, как это работает? У нас какой-то автоматический extent получается.
[02:31:46.360 --> 02:32:15.560]  Погоди, ты будешь добавлять тогда имплементацию toString? Смотри, она здесь автоматически добавляется.
[02:32:15.560 --> 02:32:21.160]  То есть так тебе нужно написать импл.toString for type, а здесь он автоматически имплементировать.
[02:32:21.160 --> 02:32:41.800]  Правильный ответ. В общем, для всех те, которые имплементируют дисплей и не обязательно
[02:32:41.800 --> 02:32:52.320]  size, имплементируется toString. Внутри он выглядит примерно вот так. Это прямо из компилятора,
[02:32:52.320 --> 02:32:57.880]  из компилятора стандартной библиотеки скопировано. Можете не вдумываться, как это работает,
[02:32:57.880 --> 02:33:04.440]  если вам непонятно в принципе. Главное понять вот эту строчку. Это то, как автоматически
[02:33:04.440 --> 02:33:17.480]  extend что-то. Тут, кажется, все понятно должно быть. Так, потом есть drf и drf.mute. Вот мы дошли до
[02:33:17.480 --> 02:33:26.040]  самого сладкого. Это лекция. У нас, кстати, осталось 10 минут. И сколько слайдов? 48?
[02:33:26.040 --> 02:33:42.400]  Мне кажется, до интервью мы сегодня не дойдем. Так, давайте продолжим пока что. Пока есть время.
[02:33:42.400 --> 02:33:50.480]  Мы можем даже указывать, какое поведение будет от оператора dereference, то есть у звездочки. Это
[02:33:50.480 --> 02:33:55.280]  используется только для умных указателей. То есть для всяких RC, для бокс имплементировать.
[02:33:55.280 --> 02:34:10.560]  Что еще раз? Для клоун. Ну мы сейчас разберемся. Это уже поведение dereference. Особенно как там
[02:34:10.560 --> 02:34:23.280]  работает. Он специализирует оператор звездочки dereference. Получается, да.
[02:34:23.280 --> 02:34:38.720]  Так, у нас есть trait deref. У него есть какой-то target, к которому мы deref-аемся. Ну естественно,
[02:34:38.720 --> 02:34:45.720]  сама функция deref. Опять же, звездочка это просто синтактический сахар для объекта .deref. Тоже
[02:34:45.720 --> 02:34:51.400]  самое с deref.mute. Он требует реализации deref. Внутри deref.mute. Ну и тут кажется понятно.
[02:34:51.400 --> 02:34:59.000]  Вот. Этот trait никогда не должен заканчиваться ошибкой, потому что вся стандартная библиотека
[02:34:59.000 --> 02:35:04.280]  Rasta, во-первых, на это полагается. Во-вторых, это будет очень очевидно для пользователя,
[02:35:04.280 --> 02:35:11.440]  если он увидит ошибку в deref. То есть он не хочет получать ошибку, когда он просто deref-ает какой-то
[02:35:11.440 --> 02:35:21.200]  тип. Ну в том числе потому, что deref работает не явно, в принципе, в Rasta. И вы получите
[02:35:21.200 --> 02:35:28.640]  прям ошибку совсем в непонятном месте. А вот тот мент, который мне хотелось показать. Самое
[02:35:28.640 --> 02:35:30.640]  время объяснять вам, как работает точечка.
[02:35:30.640 --> 02:35:46.480]  Где-то я находил шутку, там типа наживение 20 метров на стандартной библиотеке. Оператор двигает влево и так ясно.
[02:35:46.480 --> 02:35:57.120]  Так. Значит, давайте так. Если ты имплементируешь deref к какому-то таргету, x это какое-то значение
[02:35:57.120 --> 02:36:05.240]  типа t, то в таком случае звездочка t. Так, мне самому придется сейчас на слайде смотреть, потому что я наизусть не помню, как это работает.
[02:36:05.240 --> 02:36:13.240]  Если ты имплементируешь deref к таргету, x это какое-то значение t.
[02:36:13.240 --> 02:36:16.240]  Это, если что, то как работает просто deref.
[02:36:16.360 --> 02:36:36.360]  Смотрите, deref работает в таргет равный u. То есть мы tap приравниваем к u. В немутабельных контекстах, если вы делаете deref x, то это то, что я говорил, это синтоксический сахар звездочка x.
[02:36:36.360 --> 02:36:43.360]  Он превращается в deref deref x. То есть абсолютно то же самое.
[02:36:43.480 --> 02:36:59.480]  Так, потом. Значение типа ссылки на t приводится к значению типа ссылки на u.
[02:36:59.480 --> 02:37:07.480]  А еще t неявно имплементирует все то, что умеет u. Ну, конечно, немутабельное в случае deref.
[02:37:07.600 --> 02:37:10.600]  Deref – это немутабельный deref у нас.
[02:37:10.600 --> 02:37:18.600]  То есть формально, если у вас есть deref к таргету равному u, то в таком случае вы неявно имплементируете все методы типа u.
[02:37:18.600 --> 02:37:25.600]  Потому что deref работает, ты можешь написать точечку и метод типа u.
[02:37:25.600 --> 02:37:27.600]  И deref все выйдет.
[02:37:27.600 --> 02:37:33.600]  А давай дальше пойдем. Там будут прям правила. Прямо на примерах.
[02:37:33.720 --> 02:37:49.720]  Так, ну deref mute тут написано абсолютно то же самое, только с изменением того, что появилось mute.
[02:37:49.720 --> 02:37:55.720]  То есть все мутабельные методы еще имплементируются для типа t, если мы deref-аемся к u.
[02:37:55.720 --> 02:38:01.720]  И значение типа mute t приводится к mute u.
[02:38:01.840 --> 02:38:03.840]  Вот и через 2 deref.
[02:38:05.840 --> 02:38:09.840]  То есть если у меня есть deref к 1 типу, вот этого типа deref следует.
[02:38:09.840 --> 02:38:11.840]  А мы сейчас опять это увидим.
[02:38:11.840 --> 02:38:13.840]  Вот примеры там с rc и str.
[02:38:13.840 --> 02:38:19.840]  Ну там вот там вот джедочка написанная, а поскольку тот тип тоже deref, то что сработает?
[02:38:19.840 --> 02:38:22.840]  Теперь давайте оператор точечка.
[02:38:22.960 --> 02:38:30.960]  Оператор точечка создает много магии в производстве для того, чтобы сконвертировать типы.
[02:38:30.960 --> 02:38:38.960]  Он делает очень много autoreferencing, dereferencing и приведения типов, пока сами типы не совпадут.
[02:38:45.960 --> 02:38:47.960]  Так, это собственно правило.
[02:38:48.080 --> 02:38:49.080]  Начинаем.
[02:38:49.080 --> 02:38:54.080]  Для начала компилятор проверяет, может ли он напрямую вызвать метод какой-то.
[02:38:54.080 --> 02:39:04.080]  То есть если вы пишете x это типа t, пишете x.fu, допустим, то он в первую очередь пытается найти у самого типа t метод.
[02:39:04.080 --> 02:39:06.080]  Это называется buyValue call.
[02:39:06.080 --> 02:39:09.080]  То есть с самого начала он пытается найти у самого типа.
[02:39:11.080 --> 02:39:13.080]  Если у него не получилось...
[02:39:13.200 --> 02:39:21.200]  Тогда компилятор пытается автоматически zdерефаться.
[02:39:21.200 --> 02:39:26.200]  Он пытается вызвать fu у ссылки на t и у mute ссылки на t.
[02:39:26.200 --> 02:39:29.200]  Это называется autoref call.
[02:39:33.200 --> 02:39:37.200]  Ну и если мы не можем вызвать эту функцию, вот кстати говоря, еще в случае,
[02:39:37.320 --> 02:39:40.320]  если мы неправильные типы имплементируем,
[02:39:40.320 --> 02:39:46.320]  если у нас неправильные типы, либо если функция вообще не имплементирована до self,
[02:39:46.320 --> 02:39:49.320]  то в таком случае он пытается дальше идти.
[02:39:53.320 --> 02:39:55.320]  Автоматику он просто за тебя.
[02:39:55.320 --> 02:39:58.320]  Ты этого не видишь, он за тебя делает, а не он.
[02:39:58.320 --> 02:40:00.320]  Все, автоматика.
[02:40:00.440 --> 02:40:02.440]  Ну да.
[02:40:14.440 --> 02:40:18.440]  Если никто из этого не сработал, то он пытается задеревать t.
[02:40:18.440 --> 02:40:20.440]  То есть если у ссылки на t нет...
[02:40:20.440 --> 02:40:23.440]  С самого начала мы пытаемся у самого значения,
[02:40:23.440 --> 02:40:26.440]  потом если не получилось значение, у ссылки на значение вызвать.
[02:40:26.440 --> 02:40:29.440]  И у mute ссылки на значение в таком порядке.
[02:40:29.560 --> 02:40:32.560]  Если не получилось ничего вызвать или типы не совпали,
[02:40:32.560 --> 02:40:35.560]  то в таком случае он пытается задеревать.
[02:40:35.560 --> 02:40:38.560]  Дерев либо дерев mute, соответственно,
[02:40:38.560 --> 02:40:41.560]  в зависимости от контекста.
[02:40:41.560 --> 02:40:44.560]  Да, иначе fail, конечно, с дерева нет.
[02:40:44.560 --> 02:40:46.560]  Он пытается задеревать.
[02:40:46.560 --> 02:40:49.560]  Это все, у меня, кстати, тут текста t нету,
[02:40:49.560 --> 02:40:54.560]  поэтому здесь дерев и вот это вот не monospace.
[02:40:54.560 --> 02:40:56.560]  Ну ладно.
[02:40:59.560 --> 02:41:03.560]  Собственно, если мы не можем задереференсить t,
[02:41:03.560 --> 02:41:06.560]  то тогда мы пытаемся за unsize t.
[02:41:10.560 --> 02:41:12.560]  Ну смотри, если у тебя есть ссылка на str,
[02:41:12.560 --> 02:41:15.560]  то ты превратишься в str.
[02:41:15.560 --> 02:41:17.560]  Потому что на самом деле индекс имплементирован
[02:41:17.560 --> 02:41:20.560]  не для ссылки на str, а у str.
[02:41:24.560 --> 02:41:27.560]  Так, давайте попробуем посмотреть на такой вот пример.
[02:41:27.680 --> 02:41:30.680]  У нас есть array rc внутри rc-box,
[02:41:30.680 --> 02:41:33.680]  внутри box slice.
[02:41:36.680 --> 02:41:39.680]  А потом я делаю такой first entry array 0.
[02:41:39.680 --> 02:41:42.680]  Это скомпилируется, это будет работать.
[02:41:43.680 --> 02:41:44.680]  Не, ну какой тип?
[02:41:44.680 --> 02:41:45.680]  Тип t.
[02:41:45.680 --> 02:41:46.680]  Получится.
[02:41:46.680 --> 02:41:47.680]  Понятно.
[02:41:47.680 --> 02:41:50.680]  Ну непонятно, но даешь.
[02:41:50.680 --> 02:41:53.680]  Ну хорошо, давай разберем.
[02:41:54.680 --> 02:41:55.680]  Хорошо, для начала.
[02:41:55.800 --> 02:41:58.800]  Array 0 – это просто синтактический сахар
[02:41:58.800 --> 02:42:00.800]  для trade.index.
[02:42:00.800 --> 02:42:02.800]  На самом деле мы, конечно,
[02:42:02.800 --> 02:42:05.800]  вызываем array.index 0.
[02:42:05.800 --> 02:42:06.800]  То есть, как я говорил,
[02:42:06.800 --> 02:42:08.800]  все trade, ну плюсики там,
[02:42:08.800 --> 02:42:10.800]  все такое – это синтактический сахар.
[02:42:10.800 --> 02:42:12.800]  Это вот то, что мы на самом деле ищем.
[02:42:12.800 --> 02:42:15.800]  Мы хотим найти точка index 0 у кого-то.
[02:42:17.800 --> 02:42:19.800]  Для начала компилятор проверяет,
[02:42:19.800 --> 02:42:21.800]  имплементирует ли этот тип index.
[02:42:21.800 --> 02:42:23.800]  Вот так как не имплементирует,
[02:42:23.920 --> 02:42:26.920]  ссылка на rc или mute ссылка на rc
[02:42:26.920 --> 02:42:29.920]  это не имплементирует,
[02:42:29.920 --> 02:42:31.920]  то в таком случае мы пойдем дирефать.
[02:42:31.920 --> 02:42:32.920]  У нас же правило,
[02:42:32.920 --> 02:42:33.920]  сначала мы пытаемся по значению,
[02:42:33.920 --> 02:42:34.920]  потом по ссылке,
[02:42:34.920 --> 02:42:36.920]  потом мы tabbing ссылки.
[02:42:36.920 --> 02:42:37.920]  Ни то, ни другое, ни третье
[02:42:37.920 --> 02:42:38.920]  не имплементируем,
[02:42:38.920 --> 02:42:39.920]  а дирефаем.
[02:42:39.920 --> 02:42:40.920]  Дирефа у rc – это бокс.
[02:42:40.920 --> 02:42:43.920]  То есть rc – дирефается к боксу.
[02:42:43.920 --> 02:42:46.920]  Мы же, когда делаем диреф у rc,
[02:42:46.920 --> 02:42:47.920]  мы получаем, собственно,
[02:42:47.920 --> 02:42:50.920]  объект, который внутри.
[02:42:50.920 --> 02:42:51.920]  Пытаемся снова.
[02:42:51.920 --> 02:42:52.920]  У бокс такого метода нет.
[02:42:53.040 --> 02:42:54.040]  У сылки на бокс метода нет.
[02:42:54.040 --> 02:42:57.040]  У mutable ссылки на бокс метода нет.
[02:42:57.040 --> 02:42:58.040]  Окей.
[02:42:58.040 --> 02:43:01.040]  Задирефаемся дальше, да?
[02:43:01.040 --> 02:43:04.040]  Дирефаемся, получаем тип t3.
[02:43:06.040 --> 02:43:07.040]  Да.
[02:43:07.040 --> 02:43:10.040]  Не, мы не можем задирефать t3,
[02:43:10.040 --> 02:43:11.040]  соответственно,
[02:43:11.040 --> 02:43:14.040]  мы пытаемся за unsize-ить это.
[02:43:14.040 --> 02:43:17.040]  То есть ссылка t3 – это какой-то slice.
[02:43:17.040 --> 02:43:18.040]  И здесь нам нужно за unsize-ить
[02:43:18.040 --> 02:43:21.040]  и получить квадратные скобочки на t.
[02:43:21.040 --> 02:43:22.040]  Обратите внимание,
[02:43:22.160 --> 02:43:23.160]  что вот это вот на самом деле
[02:43:23.160 --> 02:43:25.160]  индекс не имплементирует.
[02:43:25.160 --> 02:43:28.160]  Не имплементирует t.0.3
[02:43:28.160 --> 02:43:30.160]  trade index.
[02:43:30.160 --> 02:43:33.160]  Имплементирует именно slice st.
[02:43:35.160 --> 02:43:37.160]  Превратить unsize тип.
[02:43:37.160 --> 02:43:40.160]  Вот это вот мы превращаем вот это.
[02:43:40.160 --> 02:43:43.160]  То есть мы просто t.0.3
[02:43:43.160 --> 02:43:46.160]  превращаем в slice st.
[02:43:48.160 --> 02:43:49.160]  Просто, опять же,
[02:43:49.160 --> 02:43:50.160]  с точки зрения теории типов
[02:43:50.280 --> 02:43:52.280]  в расти правильно,
[02:43:52.280 --> 02:43:54.280]  если у вас индекс
[02:43:54.280 --> 02:43:57.280]  имплементирован именно у unsize типа.
[02:43:57.280 --> 02:43:59.280]  Все для корректности
[02:43:59.280 --> 02:44:01.280]  такого, правильности
[02:44:01.280 --> 02:44:03.280]  логической, математической.
[02:44:03.280 --> 02:44:04.280]  Вот.
[02:44:04.280 --> 02:44:05.280]  Мы за unsize-или
[02:44:05.280 --> 02:44:06.280]  и получили slice на t.
[02:44:06.280 --> 02:44:07.280]  И, соответственно,
[02:44:07.280 --> 02:44:09.280]  ух, t имплементирует индекс.
[02:44:09.280 --> 02:44:10.280]  Соответственно,
[02:44:10.280 --> 02:44:11.280]  мы нашли эту пункцию,
[02:44:11.280 --> 02:44:12.280]  которую мы хотим вызвать.
[02:44:12.280 --> 02:44:13.280]  И компилятор, соответственно,
[02:44:13.280 --> 02:44:14.280]  пытаясь сделать r0,
[02:44:14.280 --> 02:44:17.280]  он вызовет, конечно же,
[02:44:17.280 --> 02:44:18.280]  ну, slice,
[02:44:18.400 --> 02:44:20.400]  который внутри rc-box
[02:44:20.400 --> 02:44:21.400]  возьмет 0-ой элемент.
[02:44:21.400 --> 02:44:23.400]  А как же правило, там,
[02:44:23.400 --> 02:44:26.400]  явное, очень явного?
[02:44:26.400 --> 02:44:27.400]  Ну,
[02:44:27.400 --> 02:44:29.400]  боюсь, что это как раз тот пример,
[02:44:29.400 --> 02:44:31.400]  когда ты в большинстве случаев
[02:44:31.400 --> 02:44:33.400]  будешь ловить,
[02:44:33.400 --> 02:44:34.400]  наоборот,
[02:44:34.400 --> 02:44:35.400]  положительные эмоции
[02:44:35.400 --> 02:44:36.400]  от этого,
[02:44:36.400 --> 02:44:37.400]  потому что тебе вряд ли
[02:44:37.400 --> 02:44:38.400]  придется вот, вот,
[02:44:38.400 --> 02:44:39.400]  такие вот
[02:44:39.400 --> 02:44:40.400]  замечательные структуры.
[02:44:40.400 --> 02:44:41.400]  Не надо будет
[02:44:41.400 --> 02:44:42.400]  две звездочки фигать.
[02:44:42.400 --> 02:44:43.400]  Да, не нужно будет
[02:44:43.400 --> 02:44:44.400]  десять звездочек
[02:44:44.400 --> 02:44:45.400]  как в плюсах писать типа.
[02:44:45.400 --> 02:44:46.400]  Да блин.
[02:44:46.400 --> 02:44:47.400]  Смотри, как там.
[02:44:47.520 --> 02:44:48.520]  Да.
[02:44:49.520 --> 02:44:50.520]  Диды писали.
[02:44:51.520 --> 02:44:52.520]  А такой вопрос, так,
[02:44:52.520 --> 02:44:53.520]  мы берем,
[02:44:53.520 --> 02:44:54.520]  вот, еще раз,
[02:44:54.520 --> 02:44:56.520]  t.t3 у нас
[02:44:56.520 --> 02:44:58.520]  в сайзе slice?
[02:44:58.520 --> 02:44:59.520]  Да.
[02:44:59.520 --> 02:45:00.520]  Он имеет размер
[02:45:00.520 --> 02:45:01.520]  size of t на t.
[02:45:01.520 --> 02:45:02.520]  Так.
[02:45:02.520 --> 02:45:03.520]  А если у нас
[02:45:03.520 --> 02:45:04.520]  index out of bounds,
[02:45:04.520 --> 02:45:05.520]  что,
[02:45:05.520 --> 02:45:06.520]  кто кидается?
[02:45:06.520 --> 02:45:07.520]  Паника.
[02:45:07.520 --> 02:45:08.520]  Ее кидают,
[02:45:08.520 --> 02:45:09.520]  собственно,
[02:45:09.520 --> 02:45:10.520]  элементации индекса
[02:45:10.520 --> 02:45:11.520]  у unsized slice.
[02:45:11.520 --> 02:45:12.520]  Нет.
[02:45:12.520 --> 02:45:13.520]  Компилятор,
[02:45:14.520 --> 02:45:15.520]  такое вещь
[02:45:15.520 --> 02:45:16.520]  во время компиляции
[02:45:16.520 --> 02:45:17.520]  не проверяет.
[02:45:17.520 --> 02:45:18.520]  Ну, конечно,
[02:45:18.520 --> 02:45:19.520]  не проверяет,
[02:45:19.520 --> 02:45:20.520]  потому что тогда
[02:45:20.520 --> 02:45:21.520]  вопрос,
[02:45:21.520 --> 02:45:22.520]  кто именно из
[02:45:22.520 --> 02:45:23.520]  этой цепочки
[02:45:23.520 --> 02:45:24.520]  первым бросит панику?
[02:45:24.520 --> 02:45:25.520]  Ну, когда
[02:45:25.520 --> 02:45:26.520]  это скомпилируется,
[02:45:26.520 --> 02:45:27.520]  а потом,
[02:45:27.520 --> 02:45:28.520]  когда ты в рантайме
[02:45:28.520 --> 02:45:29.520]  будешь,
[02:45:29.520 --> 02:45:30.520]  у тебя,
[02:45:30.520 --> 02:45:31.520]  собственно,
[02:45:31.520 --> 02:45:32.520]  имплементация индекса
[02:45:32.520 --> 02:45:33.520]  вот у этого slice
[02:45:33.520 --> 02:45:34.520]  выдаст панику.
[02:45:34.520 --> 02:45:35.520]  То есть,
[02:45:35.520 --> 02:45:36.520]  ну,
[02:45:36.520 --> 02:45:37.520]  компилятор,
[02:45:37.520 --> 02:45:38.520]  это все просто,
[02:45:38.520 --> 02:45:39.520]  как я говорю,
[02:45:39.520 --> 02:45:40.520]  превратит,
[02:45:40.520 --> 02:45:41.520]  получается,
[02:45:41.520 --> 02:45:42.520]  в одну,
[02:45:42.520 --> 02:45:43.520]  внутри.
[02:45:43.520 --> 02:45:44.520]  Ну, ладно.
[02:45:44.520 --> 02:45:45.520]  Ну, в плюсах
[02:45:45.520 --> 02:45:46.520]  ты бы сделал
[02:45:46.520 --> 02:45:47.520]  то же самое
[02:45:47.520 --> 02:45:48.520]  только руками.
[02:45:48.520 --> 02:45:49.520]  Вот.
[02:45:49.520 --> 02:45:50.520]  Ну, я просто
[02:45:50.520 --> 02:45:51.520]  показаюсь.
[02:45:51.520 --> 02:45:52.520]  Я сижу,
[02:45:52.520 --> 02:45:53.520]  иногда я пытаюсь
[02:45:53.520 --> 02:45:54.520]  понять,
[02:45:54.520 --> 02:45:55.520]  кто именно кидает.
[02:45:55.520 --> 02:45:56.520]  Просто,
[02:45:56.520 --> 02:45:57.520]  часто,
[02:45:57.520 --> 02:45:58.520]  то есть,
[02:45:58.520 --> 02:45:59.520]  у нас в данном случае
[02:45:59.520 --> 02:46:00.520]  конкретно
[02:46:00.520 --> 02:46:01.520]  этот объект,
[02:46:01.520 --> 02:46:02.520]  типа квадратные
[02:46:02.520 --> 02:46:03.520]  скобки T,
[02:46:03.520 --> 02:46:04.520]  он знает свой размер,
[02:46:04.520 --> 02:46:05.520]  поэтому,
[02:46:05.520 --> 02:46:06.520]  вполне себе,
[02:46:06.520 --> 02:46:07.520]  кинет панику.
[02:46:07.520 --> 02:46:08.520]  Да.
[02:46:08.520 --> 02:46:09.520]  При этом,
[02:46:09.520 --> 02:46:10.520]  на уровне типов
[02:46:10.520 --> 02:46:11.520]  этот размер
[02:46:11.520 --> 02:46:12.520]  то,
[02:46:12.520 --> 02:46:13.520]  что мы
[02:46:13.520 --> 02:46:14.520]  копировали,
[02:46:14.520 --> 02:46:15.520]  то ссылку,
[02:46:15.520 --> 02:46:16.520]  то тип.
[02:46:16.520 --> 02:46:17.520]  То есть,
[02:46:17.520 --> 02:46:18.520]  это у нас
[02:46:18.520 --> 02:46:19.520]  clone,
[02:46:19.520 --> 02:46:20.520]  мы делаем
[02:46:20.520 --> 02:46:21.520]  clone,
[02:46:21.520 --> 02:46:22.520]  это value clone.
[02:46:22.520 --> 02:46:23.520]  Так.
[02:46:23.520 --> 02:46:24.520]  Для начала,
[02:46:24.520 --> 02:46:25.520]  опять же,
[02:46:25.520 --> 02:46:26.520]  так,
[02:46:26.520 --> 02:46:27.520]  это,
[02:46:27.520 --> 02:46:28.520]  надеюсь,
[02:46:28.520 --> 02:46:29.520]  это не,
[02:46:29.520 --> 02:46:30.520]  это повторение,
[02:46:30.520 --> 02:46:31.520]  да?
[02:46:31.520 --> 02:46:32.520]  Черт.
[02:46:32.520 --> 02:46:33.520]  Как же так вышло?
[02:46:33.520 --> 02:46:34.520]  Ладно.
[02:46:34.520 --> 02:46:35.520]  Правильные примеры.
[02:46:35.520 --> 02:46:36.520]  Ладно.
[02:46:36.520 --> 02:46:37.520]  Так, ладно,
[02:46:37.520 --> 02:46:38.520]  давайте подумаем.
[02:46:38.520 --> 02:46:39.520]  Да,
[02:46:39.520 --> 02:46:40.520]  давайте подумаем
[02:46:40.520 --> 02:46:41.520]  и делаем
[02:46:41.520 --> 02:46:42.520]  value clone.
[02:46:42.520 --> 02:46:43.520]  Мы с самого начала
[02:46:43.520 --> 02:46:44.520]  пытаемся
[02:46:44.520 --> 02:46:45.520]  по значению.
[02:46:45.520 --> 02:46:46.520]  По значению,
[02:46:46.520 --> 02:46:47.520]  у нас
[02:46:47.520 --> 02:46:48.520]  вообще
[02:46:48.520 --> 02:46:49.520]  clone не имплементирован.
[02:46:49.520 --> 02:46:50.520]  Так?
[02:46:50.520 --> 02:46:51.520]  Вроде бы не имплементирован
[02:46:51.520 --> 02:46:52.520]  по значению
[02:46:52.520 --> 02:46:53.520]  ссылки на T
[02:46:53.520 --> 02:46:54.520]  clone.
[02:46:54.520 --> 02:46:55.520]  Ну, хорошо.
[02:46:55.520 --> 02:46:56.520]  Вот.
[02:46:56.520 --> 02:46:57.520]  Соответственно,
[02:46:57.520 --> 02:46:58.520]  мы пытаемся это,
[02:46:58.520 --> 02:46:59.520]  у ссылки на
[02:46:59.520 --> 02:47:00.520]  ссылку на T
[02:47:00.520 --> 02:47:01.520]  тоже не имплементирован,
[02:47:01.520 --> 02:47:02.520]  мы табельные
[02:47:02.520 --> 02:47:03.520]  ссылки на
[02:47:03.520 --> 02:47:04.520]  ссылку на
[02:47:04.520 --> 02:47:05.520]  T тоже не имплементирован,
[02:47:05.520 --> 02:47:06.520]  пытаемся
[02:47:06.520 --> 02:47:07.520]  дирефать.
[02:47:07.520 --> 02:47:08.520]  Дирефаем T,
[02:47:08.520 --> 02:47:09.520]  получаем.
[02:47:10.520 --> 02:47:11.520]  Если не имплементирован
[02:47:11.520 --> 02:47:12.520]  clone,
[02:47:12.520 --> 02:47:13.520]  кстати,
[02:47:13.520 --> 02:47:14.520]  сейчас вот
[02:47:14.520 --> 02:47:15.520]  путаюсь,
[02:47:15.520 --> 02:47:16.520]  а почему
[02:47:16.520 --> 02:47:17.520]  там
[02:47:17.520 --> 02:47:18.520]  скопируется?
[02:47:18.520 --> 02:47:19.520]  Ну,
[02:47:19.520 --> 02:47:20.520]  именно
[02:47:20.520 --> 02:47:21.520]  заклонится
[02:47:21.520 --> 02:47:22.520]  ссылка.
[02:47:22.520 --> 02:47:23.520]  Да,
[02:47:23.520 --> 02:47:24.520]  там
[02:47:24.520 --> 02:47:25.520]  заклонится
[02:47:25.520 --> 02:47:26.520]  ссылка,
[02:47:26.520 --> 02:47:27.520]  если
[02:47:27.520 --> 02:47:28.520]  T не
[02:47:28.520 --> 02:47:29.520]  clone.
[02:47:29.520 --> 02:47:30.520]  Cloned будет
[02:47:30.520 --> 02:47:31.520]  иметь
[02:47:31.520 --> 02:47:32.520]  типа
[02:47:32.520 --> 02:47:33.520]  ссылки
[02:47:33.520 --> 02:47:34.520]  на T.
[02:47:34.520 --> 02:47:35.520]  Вот.
[02:47:35.520 --> 02:47:36.520]  Мы же
[02:47:36.520 --> 02:47:37.520]  требуем от
[02:47:37.520 --> 02:47:38.520]  T.
[02:47:38.520 --> 02:47:39.520]  Какой
[02:47:39.520 --> 02:47:40.520]  момент
[02:47:40.520 --> 02:47:41.520]  нам
[02:47:41.520 --> 02:47:42.520]  придет,
[02:47:42.520 --> 02:47:43.520]  когда
[02:47:43.520 --> 02:47:44.520]  она
[02:47:44.520 --> 02:47:45.520]  заклонится
[02:47:45.520 --> 02:47:46.520]  ссылку?
[02:47:46.520 --> 02:47:47.520]  Давайте
[02:47:47.520 --> 02:47:48.520]  тоже
[02:47:48.520 --> 02:47:49.520]  подзабыл
[02:47:49.520 --> 02:47:50.520]  этот момент.
[02:47:50.520 --> 02:47:51.520]  В чате
[02:47:51.520 --> 02:47:52.520]  напишу
[02:47:52.520 --> 02:47:53.520]  сразу.
[02:47:53.520 --> 02:47:54.520]  Ну,
[02:47:54.520 --> 02:47:55.520]  мне
[02:47:55.520 --> 02:47:56.520]  что-то
[02:47:56.520 --> 02:47:57.520]  подсказывает,
[02:47:57.520 --> 02:47:58.520]  просто,
[02:47:58.520 --> 02:47:59.520]  что
[02:47:59.520 --> 02:48:00.520]  по каким-то
[02:48:00.520 --> 02:48:01.520]  причинам,
[02:48:01.520 --> 02:48:02.520]  расту не
[02:48:02.520 --> 02:48:03.520]  нравится
[02:48:03.520 --> 02:48:04.520]  ссылка
[02:48:04.520 --> 02:48:05.520]  на T,
[02:48:05.520 --> 02:48:06.520]  как один
[02:48:06.520 --> 02:48:07.520]  из
[02:48:07.520 --> 02:48:08.520]  других.
[02:48:08.520 --> 02:48:09.520]  Так,
[02:48:09.520 --> 02:48:10.520]  теперь
[02:48:10.520 --> 02:48:11.520]  мы можем
[02:48:11.520 --> 02:48:12.520]  сравнить
[02:48:12.520 --> 02:48:13.520]  с плюсами,
[02:48:13.520 --> 02:48:14.520]  наконец-то.
[02:48:14.520 --> 02:48:15.520]  Наверное,
[02:48:15.520 --> 02:48:16.520]  сравнить
[02:48:16.520 --> 02:48:17.520]  с плюсами
[02:48:17.520 --> 02:48:18.520]  и закончим,
[02:48:18.520 --> 02:48:19.520]  потому что
[02:48:19.520 --> 02:48:20.520]  у нас
[02:48:20.520 --> 02:48:21.520]  формально
[02:48:21.520 --> 02:48:22.520]  лекция
[02:48:22.520 --> 02:48:23.520]  уже все.
[02:48:23.520 --> 02:48:24.520]  Так.
[02:48:24.520 --> 02:48:25.520]  У нас
[02:48:25.520 --> 02:48:26.520]  трейты
[02:48:26.520 --> 02:48:27.520]  хороши
[02:48:27.520 --> 02:48:28.520]  тем,
[02:48:28.520 --> 02:48:29.520]  что они
[02:48:29.520 --> 02:48:30.520]  позволяют
[02:48:30.520 --> 02:48:31.520]  отдельно
[02:48:31.520 --> 02:48:32.520]  держать
[02:48:32.520 --> 02:48:33.520]  имплементацию
[02:48:33.520 --> 02:48:34.520]  от
[02:48:34.520 --> 02:48:35.520]  данных.
[02:48:35.520 --> 02:48:36.520]  В
[02:48:36.520 --> 02:48:37.520]  таком
[02:48:37.520 --> 02:48:38.520]  случае
[02:48:38.520 --> 02:48:39.520]  интерфейса
[02:48:39.520 --> 02:48:40.520]  очень
[02:48:40.520 --> 02:48:41.520]  тяжело
[02:48:41.520 --> 02:48:42.520]  расширять.
[02:48:42.520 --> 02:48:43.520]  То есть,
[02:48:43.520 --> 02:48:44.520]  если
[02:48:44.520 --> 02:48:45.520]  вы
[02:48:45.520 --> 02:48:46.520]  захотите
[02:48:46.520 --> 02:48:47.520]  доимплементировать
[02:48:47.520 --> 02:48:48.520]  какой-то
[02:48:48.520 --> 02:48:49.520]  свой
[02:48:49.520 --> 02:48:50.520]  интерфейс
[02:48:50.520 --> 02:48:51.520]  для
[02:48:51.520 --> 02:48:52.520]  типа,
[02:48:52.520 --> 02:48:53.520]  то в
[02:48:53.520 --> 02:48:54.520]  таком
[02:48:54.520 --> 02:48:55.520]  случае
[02:48:55.520 --> 02:48:56.520]  нужно залезть
[02:48:56.520 --> 02:48:57.520]  в этот
[02:48:57.520 --> 02:48:58.520]  тип.
[02:48:58.520 --> 02:48:59.520]  Это не
[02:48:59.520 --> 02:49:00.520]  удобно.
[02:49:00.520 --> 02:49:01.520]  А в
[02:49:01.520 --> 02:49:02.520]  случае
[02:49:02.520 --> 02:49:03.520]  расту,
[02:49:03.520 --> 02:49:04.520]  вы
[02:49:04.520 --> 02:49:05.520]  можете
[02:49:05.520 --> 02:49:06.520]  использовать
[02:49:06.520 --> 02:49:07.520]  новые
[02:49:07.520 --> 02:49:08.520]  типы,
[02:49:08.520 --> 02:49:09.520]  но сложно их
[02:49:09.520 --> 02:49:10.520]  расширять.
[02:49:10.520 --> 02:49:11.520]  Вот.
[02:49:11.520 --> 02:49:12.520]  Потом,
[02:49:12.520 --> 02:49:13.520]  в
[02:49:13.520 --> 02:49:14.520]  расте
[02:49:14.520 --> 02:49:15.520]  все
[02:49:15.520 --> 02:49:16.520]  трейты
[02:49:16.520 --> 02:49:17.520]  явно
[02:49:17.520 --> 02:49:18.520]  имплементированы.
[02:49:18.520 --> 02:49:19.520]  Пока
[02:49:19.520 --> 02:49:20.520]  плюсовых концептов
[02:49:20.520 --> 02:49:21.520]  позволяет
[02:49:21.520 --> 02:49:22.520]  либо
[02:49:22.520 --> 02:49:23.520]  что-то
[02:49:23.520 --> 02:49:24.520]  только
[02:49:24.520 --> 02:49:25.520]  запретить,
[02:49:25.520 --> 02:49:26.520]  либо разрешить.
[02:49:26.520 --> 02:49:27.520]  А то,
[02:49:27.520 --> 02:49:28.520]  что не
[02:49:28.520 --> 02:49:29.520]  написано,
[02:49:29.520 --> 02:49:30.520]  то
[02:49:30.520 --> 02:49:31.520]  получение
[02:49:31.520 --> 02:49:32.520]  разрешено.
[02:49:32.520 --> 02:49:33.520]  Вот у
[02:49:33.520 --> 02:49:34.520]  меня есть
[02:49:34.520 --> 02:49:35.520]  код
[02:49:35.520 --> 02:49:36.520]  stringify,
[02:49:36.520 --> 02:49:37.520]  какая-то
[02:49:37.520 --> 02:49:38.520]  функция stringify,
[02:49:38.520 --> 02:49:39.520]  которая
[02:49:39.520 --> 02:49:40.520]  возвращает
[02:49:40.520 --> 02:49:41.520]  из
[02:49:41.520 --> 02:49:42.520]  std
[02:49:42.520 --> 02:49:43.520]  string.
[02:49:43.520 --> 02:49:44.520]  Есть
[02:49:44.520 --> 02:49:45.520]  код
[02:49:45.520 --> 02:49:46.520]  cat,
[02:49:46.520 --> 02:49:47.520]  который умеет
[02:49:47.520 --> 02:49:48.520]  в
[02:49:48.520 --> 02:49:49.520]  stringify,
[02:49:49.520 --> 02:49:50.520]  собственно,
[02:49:50.520 --> 02:49:51.520]  и
[02:49:51.520 --> 02:49:52.520]  pet.
[02:49:52.520 --> 02:49:53.520]  Вот.
[02:49:53.520 --> 02:49:54.520]  Потом у нас есть
[02:49:54.520 --> 02:49:55.520]  функция
[02:49:55.520 --> 02:49:56.520]  f,
[02:49:56.520 --> 02:49:57.520]  которая
[02:49:57.520 --> 02:49:58.520]  требует
[02:49:58.520 --> 02:49:59.520]  отти
[02:49:59.520 --> 02:50:00.520]  stringable,
[02:50:00.520 --> 02:50:01.520]  и при
[02:50:01.520 --> 02:50:02.520]  этом я внутри
[02:50:02.520 --> 02:50:03.520]  вызываю
[02:50:03.520 --> 02:50:04.520]  код
[02:50:04.520 --> 02:50:05.520]  stringify.
[02:50:05.520 --> 02:50:06.520]  И
[02:50:06.520 --> 02:50:07.520]  я
[02:50:07.520 --> 02:50:08.520]  не смотрю
[02:50:08.520 --> 02:50:09.520]  ее
[02:50:09.520 --> 02:50:10.520]  с
[02:50:10.520 --> 02:50:11.520]  какого
[02:50:11.520 --> 02:50:12.520]  получится.
[02:50:12.520 --> 02:50:13.520]  Ну,
[02:50:13.520 --> 02:50:14.520]  теперь
[02:50:14.520 --> 02:50:15.520]  представьте,
[02:50:15.520 --> 02:50:16.520]  что у вас все это время
[02:50:16.520 --> 02:50:17.520]  огромная
[02:50:17.520 --> 02:50:18.520]  кодовая
[02:50:18.520 --> 02:50:19.520]  база у вас,
[02:50:19.520 --> 02:50:20.520]  красивые
[02:50:20.520 --> 02:50:21.520]  типы все время
[02:50:21.520 --> 02:50:22.520]  засовывались
[02:50:22.520 --> 02:50:23.520]  в эту
[02:50:23.520 --> 02:50:24.520]  функцию,
[02:50:24.520 --> 02:50:25.520]  что-то
[02:50:25.520 --> 02:50:26.520]  типа такого.
[02:50:26.520 --> 02:50:27.520]  А потом
[02:50:27.520 --> 02:50:28.520]  вы засунули
[02:50:28.520 --> 02:50:29.520]  те,
[02:50:29.520 --> 02:50:30.520]  которые внезапно
[02:50:30.520 --> 02:50:31.520]  pet не
[02:50:31.520 --> 02:50:32.520]  имплементируют.
[02:50:32.520 --> 02:50:33.520]  Какого-то
[02:50:33.520 --> 02:50:34.520]  типа.
[02:50:34.520 --> 02:50:35.520]  Ну,
[02:50:35.520 --> 02:50:36.520]  все равно
[02:50:36.520 --> 02:50:37.520]  было бы
[02:50:37.520 --> 02:50:38.520]  гораздо приятнее,
[02:50:38.520 --> 02:50:39.520]  если бы у вас
[02:50:39.520 --> 02:50:40.520]  был
[02:50:40.520 --> 02:50:41.520]  trait stringable,
[02:50:41.520 --> 02:50:42.520]  и если бы вы
[02:50:42.520 --> 02:50:43.520]  потребовали
[02:50:43.520 --> 02:50:44.520]  stringable в
[02:50:44.520 --> 02:50:45.520]  Rast,
[02:50:45.520 --> 02:50:46.520]  ну,
[02:50:46.520 --> 02:50:47.520]  то
[02:50:47.520 --> 02:50:48.520]  string,
[02:50:48.520 --> 02:50:49.520]  по сути,
[02:50:49.520 --> 02:50:50.520]  то в
[02:50:50.520 --> 02:50:51.520]  таком
[02:50:51.520 --> 02:50:52.520]  случае у вас бы
[02:50:52.520 --> 02:50:53.520]  такой код не
[02:50:53.520 --> 02:50:54.520]  скомпилировался,
[02:50:54.520 --> 02:50:55.520]  потому что Rast
[02:50:55.520 --> 02:50:56.520]  сказал бы,
[02:50:56.520 --> 02:50:57.520]  что он не
[02:50:57.520 --> 02:50:58.520]  нашел
[02:50:58.520 --> 02:50:59.520]  у типа
[02:50:59.520 --> 02:51:00.520]  tpet.
[02:51:00.520 --> 02:51:01.520]  Мы же
[02:51:01.520 --> 02:51:02.520]  в этом
[02:51:02.520 --> 02:51:03.520]  плане,
[02:51:03.520 --> 02:51:04.520]  если вы
[02:51:04.520 --> 02:51:05.520]  попробуете
[02:51:05.520 --> 02:51:06.520]  загуглить,
[02:51:06.520 --> 02:51:07.520]  например,
[02:51:07.520 --> 02:51:08.520]  Rast
[02:51:08.520 --> 02:51:09.520]  trait C++,
[02:51:09.520 --> 02:51:10.520]  ну,
[02:51:10.520 --> 02:51:11.520]  то есть,
[02:51:11.520 --> 02:51:12.520]  как
[02:51:12.520 --> 02:51:13.520]  Rast
[02:51:13.520 --> 02:51:14.520]  trait C++
[02:51:14.520 --> 02:51:15.520]  имплементируют,
[02:51:15.520 --> 02:51:16.520]  там очень
[02:51:16.520 --> 02:51:17.520]  много статей про
[02:51:17.520 --> 02:51:18.520]  то,
[02:51:18.520 --> 02:51:19.520]  как
[02:51:19.520 --> 02:51:20.520]  люди
[02:51:20.520 --> 02:51:21.520]  завидуют
[02:51:21.520 --> 02:51:22.520]  trait в
[02:51:22.520 --> 02:51:23.520]  Rast,
[02:51:23.520 --> 02:51:24.520]  прямо в
[02:51:24.520 --> 02:51:25.520]  смысле слова.
[02:51:25.520 --> 02:51:26.520]  Ну,
[02:51:26.520 --> 02:51:27.520]  то есть,
[02:51:27.520 --> 02:51:28.520]  они
[02:51:28.520 --> 02:51:29.520]  ищут какие-то
[02:51:29.520 --> 02:51:30.520]  способы,
[02:51:30.520 --> 02:51:31.520]  прича,
[02:51:31.520 --> 02:51:32.520]  я думаю,
[02:51:32.520 --> 02:51:33.520]  понравится,
[02:51:33.520 --> 02:51:34.520]  когда
[02:51:34.520 --> 02:51:35.520]  вы будете
[02:51:35.520 --> 02:51:36.520]  работать с Rast,
[02:51:36.520 --> 02:51:37.520]  потому что
[02:51:37.520 --> 02:51:38.520]  она
[02:51:38.520 --> 02:51:39.520]  хорошо
[02:51:39.520 --> 02:51:40.520]  позволяет
[02:51:40.520 --> 02:51:41.520]  абстрагировать
[02:51:41.520 --> 02:51:42.520]  код.
[02:51:42.520 --> 02:51:43.520]  Ну,
[02:51:43.520 --> 02:51:44.520]  и собственно,
[02:51:44.520 --> 02:51:45.520]  концепты
[02:51:45.520 --> 02:51:46.520]  в плюсах
[02:51:46.520 --> 02:51:47.520]  проверяются
[02:51:47.520 --> 02:51:48.520]  только тогда,
[02:51:48.520 --> 02:51:49.520]  когда
[02:51:49.520 --> 02:51:50.520]  инстанциализируются.
[02:51:50.520 --> 02:51:51.520]  Это то,
[02:51:51.520 --> 02:51:52.520]  что приводит
[02:51:52.520 --> 02:51:53.520]  каким-то
[02:51:53.520 --> 02:51:54.520]  запоздалым
[02:51:54.520 --> 02:51:55.520]  ошибкам,
[02:51:55.520 --> 02:51:56.520]  что несколько
[02:51:56.520 --> 02:51:57.520]  неудобно.
[02:51:57.520 --> 02:51:58.520]  Кажется,
[02:51:58.520 --> 02:51:59.520]  мы
[02:51:59.520 --> 02:52:05.080]  Давайте тогда всем пока!
