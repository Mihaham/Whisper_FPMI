[00:00.000 --> 00:11.480]  У нас тема сегодня шестнадцатая и последняя, видимо, это Compiled-time-вычисление.
[00:21.480 --> 00:28.720]  Ну, сегодня будет не совсем еще крышесносное Compiled-time-вычисление, а завтра напоследок я думаю,
[00:28.720 --> 00:37.520]  что мы устроим какой-нибудь развал кабины, и будут очень веселые Compiled-time-вычисления,
[00:37.520 --> 00:44.320]  и последнюю задачу я публикую на них. Но пока начнем с кастовом, наверное,
[00:44.320 --> 00:47.880]  начнем с того, о чем все и так знают. Это Compile-time-вычисление.
[00:47.880 --> 01:05.480]  Его базовое использование. Ну, слово constexpr появилось C++11, как и большинство из того,
[01:05.480 --> 01:14.360]  чем мы занимаемся последние полгода. Что оно означает? Оно означает, что данная функция,
[01:14.360 --> 01:23.280]  а может быть? Оно применимо к функциям и к переменным. Давай сначала поймем,
[01:23.280 --> 01:30.000]  что такое constexpr функция. Ну, вот я напишу constexpr int, ну, не знаю, что-нибудь.
[01:30.000 --> 01:48.960]  Sqr от int x возвращает x умножить на x. Вот. Ну, как вы, наверное, знаете, вообще говоря,
[01:48.960 --> 02:01.280]  я не могу, например, создать какой-нибудь массив из int-ов размера Sqr от 5. Ну, вот. Если бы
[02:01.280 --> 02:07.280]  здесь не было этого слова, до того, как мы начали это обсуждать, вот так я написать не могу,
[02:07.280 --> 02:23.480]  не потому что я не заинфулил ray, сейчас я его заинфулю, а потому что... ой-ой-ой-ой. Блин,
[02:23.480 --> 02:32.200]  я не в той папке находился. Ну ладно, чёрт, сейчас переду. Ну вот. Сейчас не будет ошибка
[02:32.200 --> 02:42.600]  компиляции, потому что нельзя... ну, в параметре шаблона нельзя передавать вызовы функций. Это вы,
[02:42.600 --> 02:49.400]  наверное, и так знаете. Вот. На ней мере должны знать. Ну, все здесь прислушивающие будут знать.
[02:49.400 --> 02:57.520]  Вот. Что вам приходилось делать? Вам приходилось делать какие-то шаблонные мета-учисления, там,
[02:57.520 --> 03:03.280]  рекурсию на шаблонах и так далее, чтобы уходит в статик const-value равное чему-то, и вот тогда его
[03:03.280 --> 03:08.160]  можно. Ну, просто существует такое понятие константа времени компиляции. То есть константы бывают
[03:08.160 --> 03:14.400]  обычные, бывают константы времени компиляции. Вот когда я задаю числовые шаблонные параметры,
[03:14.400 --> 03:18.680]  мне нужна константа времени компиляции, а не просто константа. То есть то, что вычислено
[03:18.680 --> 03:22.840]  на этой компиляции должно быть. Компилятор по умолчанию вызову функций в комплинации не делает.
[03:22.840 --> 03:29.400]  Поэтому так вот и компилируется. Так вот constexpr это слово, которое предписывают компилятору,
[03:29.400 --> 03:39.440]  если от него требуется вычислить эту функцию на этой компиляции. То есть можно эту функцию в compile
[03:39.440 --> 03:49.240]  time вызывать. Вот сейчас поскомпилируется. Вот так стало можно начинать C++11. Вот. Я хочу, значит,
[03:49.240 --> 03:55.880]  обратить внимание на следующий факт. Даже если бы я здесь написал const int. Ну, кстати,
[03:55.880 --> 04:02.280]  может быть, так бы и сработало, там const int m равно десяти, и я бы сказал int, и вот здесь n.
[04:02.280 --> 04:09.880]  Я, кстати, не уверен, сработали это и будет или нет. Нет, работает все-таки. Но я хочу сказать,
[04:09.880 --> 04:22.120]  что вот этот const int n, это хоть и константа, но она не обязана быть константой время компиляции.
[04:22.120 --> 04:29.880]  Ну вот, например, я мог бы поступить к каким-нибудь следующим образом. Я бы сказал int x,
[04:29.880 --> 04:38.380]  ввел бы x с клавиатуры, а потом сказал const int n равно x умножить на x. И давай-ка я заведу массив
[04:38.380 --> 04:46.060]  размера n. Конечно же, это будет CE уже сейчас, очевидно, потому что хоть это и конст, это не
[04:46.060 --> 04:52.220]  compile time константа. Вот это пример иллюстривающей разницы между просто константами и константами
[04:52.220 --> 04:55.900]  времени компиляции. Быть константой времени компиляции — это более строгое условие,
[04:55.900 --> 05:03.660]  чем просто быть константой. Вот сейчас это очевидно не скомпилируется. Вот. Вот это вот называется
[05:03.660 --> 05:09.820]  constant expression. n is not usable in a constant expression. Constant expression означает, что вот выражение,
[05:09.820 --> 05:16.860]  которое в момент компиляции должно быть. Я могу слово constexpr использовать и для переменных тоже.
[05:16.860 --> 05:23.100]  То есть я могу некоторую переменную объявить constexpr. Ну, например, могу вот про это переменную
[05:23.100 --> 05:29.420]  писать constexpr. Что это будет означать? Ну, это опять означать будет ошибку компиляции, только на этот
[05:29.420 --> 05:36.260]  раз уже в этой строке, где constexpr написано. constexpr переменная — это значит такая переменная,
[05:36.260 --> 05:47.780]  которая должна быть, значение которой должно быть вычислено в момент компиляции. То есть она
[05:47.780 --> 05:53.820]  должна в компиляторе, в момент компиляции должно быть вычислено значение и пронициализировано
[05:53.820 --> 05:58.700]  это переменная. Вычисление того, чем она пронициализирована, не должно быть отложено на
[05:58.700 --> 06:09.060]  runtime. Вот constexpr int — это более сильное условие, чем constint. constint означает, что просто константа,
[06:09.060 --> 06:16.820]  но не обязательно то, чем она инциализируется в compile-time вычисляется, а constexpr int означает,
[06:16.820 --> 06:20.700]  что это мало того, что константа, так еще и константа в момент компиляции уже должно быть,
[06:20.700 --> 06:27.140]  в момент которой известно. Вот часто будет СЕ, потому что хуночная х, очевидно, нельзя использовать
[06:27.140 --> 06:35.340]  для инциализации constexpr переменной. Да просто х нельзя использовать для инциализации constexpr
[06:35.340 --> 06:50.220]  переменной. Вот. Но я могу, например, так написать. sqr от пяти. Вот так я могу написать. А если бы
[06:50.220 --> 06:56.220]  здесь я убрал constexpr, то опять бы не смог, потому что, ну, соответственно, вот справа должно быть
[06:56.220 --> 07:12.220]  что-то compile-time-вычислимое. Вот. Ну, все понятно, короче. Вроде как. Да? Вот. Ну, вот мы раньше писали
[07:12.220 --> 07:17.420]  с вами static const, там all-value где-то. Теперь можно писать static constexpr. All-value — это даже будет
[07:17.420 --> 07:26.980]  более диаматично, что ли. Ну хорошо, возникает вопрос. О чем можно вообще в constexpr функциях
[07:26.980 --> 07:35.380]  использовать? Да, первое замечание, которое хочу сделать про constexpr функцию. Вот, допустим,
[07:35.380 --> 07:51.260]  я сказал с dossеин х, потом, наверное, я все-таки ввел х, и вывел stdcout sqr от х. Вот здесь будет какая-нибудь ошибка.
[07:51.260 --> 08:13.020]  Функция constexpr. Все нормально или нет? Да. Значит, правильно, все хорошо, никакой ошибки нет.
[08:13.020 --> 08:22.540]  constexpr функция не означает, что она обязана быть вычислена в момент компиляции. А для этого есть
[08:22.540 --> 08:28.220]  другое слово — const.all, но про него мы попозже поговорим. Вот constexpr функция — это функция, которая,
[08:28.220 --> 08:35.660]  будучи вызвана их constant expression, компилятор должен попытаться вычислить compile-time. Но и это не
[08:35.660 --> 08:41.580]  значит, что ее нельзя вызывать в обычных контекстах. То есть в обычных runtime контекстах ее тоже можно
[08:41.580 --> 08:50.020]  вызывать. А если constexpr функция вызывает какую-то, которая не constexpr, то это ce? Это ce в момент,
[08:50.020 --> 08:56.260]  когда до этого вызова дело дойдет. Сейчас мы эти все примеры разберем.
[08:56.260 --> 09:11.540]  Да. Но давайте что-нибудь более сложное в constexpr функции напишем. Ну давайте,
[09:11.540 --> 09:22.220]  например, это будет у нас какая-нибудь функция constexpr. Не знаю, что. Что-нибудь сделать там.
[09:22.220 --> 09:34.940]  Что у нас бывает? Не знаю, вот. Esprime от n. Вот я сейчас проверю число на простоту. Только
[09:34.940 --> 09:46.700]  вернуть нужно. Bool. Вот. Давайте короче напишем проверку простого числа. Ну там, что мы сделаем там,
[09:46.700 --> 09:51.980]  скажем Bool. Вот первый вопрос. Вообще, могу ли я циклы использовать в constexpr функции? Вообще,
[09:51.980 --> 09:56.140]  что я могу использовать в constexpr функции? Могу ли я написать проверку числа на простоту с помощью
[09:56.140 --> 10:12.140]  constexpr функции вот стандартным образом? Ну то есть, я напишу там int d равно 0 d умножить на d меньше
[10:12.140 --> 10:32.580]  или равно n плюс плюс d. Только не от уля, наверное, а от 2. Да, и если n делится на d, то return false.
[10:32.580 --> 10:52.980]  Если n равно 1, return false, а тут return true. Так, я не наложал проверку числа на простоту. Надеюсь,
[10:52.980 --> 11:01.860]  что нет. Такой позор будет. Ну будем считать, что я не наложал, ладно. Нормально все. Сейчас,
[11:01.860 --> 11:07.700]  ну от двух перебираем делители. Ну да, нормально. Ровно нормально. Вот, это вообще скомпилируется
[11:07.700 --> 11:18.660]  сейчас. Могу ли я такую функцию constexpr сделать? Почему нет? Ну я тут for использую, например. У нас
[11:18.660 --> 11:33.860]  векторит все функции constexpr. Ну это вы просто уже много видели, да. Ну, до c++14 не мог. Вот это все разрешено только c++14.
[11:42.740 --> 11:43.460]  Ну, в общем.
[11:48.660 --> 12:01.340]  Значит, только начиная c++14 в constexpr функциях можно стало использовать control statement. В c++11 изначально
[12:01.340 --> 12:07.020]  constexpr функции были вообще супер ограничены по возможностям. В них можно было использовать лишь
[12:07.020 --> 12:21.260]  один return. Да, ну вот вопрос. Можно ли из constexpr функции вызвать не constexpr функцию? А давайте мы
[12:21.260 --> 12:25.500]  так и сделаем. Вот смотрите, как удачно. Я тут как раз возведение в квадрат нужно. Вот я сейчас вот
[12:25.500 --> 12:33.060]  это здесь и заиспользую. Вот. Ну и давайте я попробую. Ну, во-первых, просто попробую
[12:33.060 --> 12:41.580]  это скомпилировать. А, нет. Я неправильно сказал. ce будет сразу же. Просто сразу же в момент
[12:41.580 --> 12:47.580]  компиляции будет ce. Я не вызывал эту функцию даже. Вот. Если я из constexpr функции пытаюсь вызвать не
[12:47.580 --> 12:53.780]  constexpr, то это ce. Потому что все, что я в constexpr функции делаю, должно само быть constexpr.
[12:53.780 --> 13:00.140]  Вот. Ну, соответственно, sqr должен быть constexpr, тогда все заработает.
[13:00.140 --> 13:12.340]  Окей. Что еще можно делать в constexpr функциях? Ну,
[13:12.340 --> 13:23.340]  давайте вспомним, что мы еще умеем делать. Можно ли это делать в constexpr функциях?
[13:23.340 --> 13:30.140]  Ну, не знаю. Ну, например, могу ли я в constexpr функциях объявить какой-нибудь указатель или ссылку
[13:30.140 --> 13:43.700]  на что-нибудь? Могу ли я, скажем, взять там авто p равно адрес n? Не знаю, зачем это надо,
[13:43.700 --> 13:55.180]  но вот зачем хотелось. Могу. Даже c14, кажется, это должен быть. Вот. Возникает, конечно, вопрос,
[13:55.180 --> 14:06.380]  что же это такое за адрес? Ну вот, компилятор как-то, значит, а, мы ее не вызвали. Может быть,
[14:06.380 --> 14:30.300]  если я вызову, все испортится. Ну, давайте bool is 32767 prime равно is prime от 32767. А! Это
[14:30.300 --> 14:42.840]  должен быть constexpr bool. Нет, все работает. Ну, то есть, компилятор как-то вот в compile
[14:42.840 --> 14:53.740]  time эмулирует самые настоящие выполнения. Можно заводить указатели, ссылки, массивы. Могу ли я
[14:53.740 --> 15:06.620]  вот массив завести? Не знаю, вот, что я хотел написать теперь? Я не буду его писать, не знаю. Вот int a100. Нет, int a10.
[15:06.620 --> 15:25.960]  И вот что-нибудь. A5 равно 3. Так получится у меня. An initialized variable. Мне нужно
[15:25.960 --> 15:38.020]  инициализировать массивы. Ну, давайте инициализируем. Вот, давайте теперь. Все, массивы тоже
[15:38.020 --> 15:45.700]  надо в клацеркульте заводить. Отлично. Что еще вы помните? Что еще бывает в программах c++?
[15:45.700 --> 15:58.060]  C out. Ну, c out, очевидно, нельзя. Потому что, трудно сказать, почему на самом деле. Ну, это что-то странное
[15:58.060 --> 16:04.500]  в этом видео. Ну, это что бы означало, что он в compile time должен подцепиться к потоку вывода и
[16:04.500 --> 16:13.300]  начать писать прям в... В месяц сушку компиляции. Да-да, параллельно с сушкой компиляции. Ну,
[16:13.300 --> 16:22.640]  давайте попробуем. Нет, не могу. Я, честно говоря, даже не пробовал, но нет. Ну, просто оператор
[16:22.640 --> 16:30.740]  влево-влево у Basic Stream, не constexpr, вот и все. А жаль. Я просто сейчас вам расскажу, что еще
[16:30.740 --> 16:38.860]  constexpr стал недавно. Ну, я так понимаю, что new, да? Не только. Это еще не худшее. Не худшее? Да. Ну,
[16:38.860 --> 16:45.780]  окей. Значит, до c++14 constexpr мог содержать только один return и обходить астернарген подкатитил.
[16:45.780 --> 16:53.780]  Начиная с c++14, стало можно использовать и for, ну, любые constful statements и try-patch,
[16:53.780 --> 17:01.780]  чтобы нельзя было. Try-patch нельзя, switch, while, понятно, массивы можно заводить, можно переменные
[17:01.780 --> 17:07.660]  объявлять локальные, можно, значит, другие функции вызывать. Ну, короче, фактически все,
[17:07.660 --> 17:15.180]  что хотите, указатели, ссылки, там, рекурсия. Единственное, чтобы все функции были constexpr. Вот,
[17:15.180 --> 17:25.060]  объекты нельзя создавать, конструкторы вызывать нельзя. Вот, но с другой стороны, смотрите,
[17:25.060 --> 17:34.020]  вот если я, допустим, такое сделаю. Давайте я верну это назад, а то у меня странно уже какая-то
[17:34.020 --> 18:00.700]  чушь написана. Вот вопрос. Вот, допустим, у меня есть какая-то структура и в ней есть поля. Да,
[18:00.700 --> 18:05.460]  вот я сказал, объекты нельзя создавать. Ну, не совсем правда. Вот такие объекты можно, в принципе,
[18:05.460 --> 18:12.660]  создавать в constexpr функциях. Это я все говорю про старые версии плюсов. Дальше с каждой версией
[18:12.660 --> 18:18.900]  возможности того, что можно делать в constexpr функциях, расширяется неукладно. Вот могу ли я создать
[18:18.900 --> 18:34.100]  такое? Ну, казалось бы, да. Почему нет-то? Pereturn s.y. Ну, то есть что, я просто вызываю конструктор
[18:34.100 --> 18:43.180]  по умолчанию, да, и два поля инициализируются по умолчанию. Вот я сейчас, кстати, не уверен,
[18:43.180 --> 18:49.020]  с какими флагами меня это скомпилируется. Ну, давайте, ну, давайте C++17 скомпилировать. Ну,
[18:49.020 --> 18:55.140]  да, скомпилировал с C++17, ну, видимо, и с C++14 тоже скомпилировал. Да, то есть просто создать
[18:55.140 --> 19:01.140]  объект, у которого нет нетривиального конструктора по умолчанию, я могу он стать функцией. Хорошо,
[19:01.140 --> 19:14.820]  что если у меня был бы конструктор? Вот что теперь? Вот теперь это не скомпилируется,
[19:14.820 --> 19:27.420]  скорее всего. Почему? Потому что уже конструктор пользователь, user defined, а он в constexpr не
[19:27.420 --> 19:33.700]  помещен, конструктор это же тоже функция. Вот, поэтому если я хочу такое создавать,
[19:33.700 --> 19:45.660]  то мне нужен constexpr конструктор. Вот теперь скомпилируется. Ну, то есть constexpr конструктор
[19:45.660 --> 19:54.500]  просто, вот сейчас для нас constexpr конструктор это просто способ как функцию сказать, что его
[19:54.500 --> 20:04.220]  можно вызывать в compile time. В частности, создавать объект такого типа в constexpr
[20:04.220 --> 20:19.100]  функции. А вот, хорошо. Как насчет, ну, понятно дальше, что я могу, в принципе, все, вот пока
[20:19.100 --> 20:25.580]  мы не говорим про выделение динамической памяти, понятно, что перегрузка операторов я тоже
[20:25.580 --> 20:30.340]  могу в constexpr. Ну, то есть, если не обращаюсь к каким-то системным ресурсам, то кажется,
[20:30.340 --> 20:36.740]  что я могу сейчас с таким же успехом определить constexpr операторы для этого класса. Вот, могу
[20:36.740 --> 20:41.820]  наследование сделать, то есть я могу сейчас структуру S наследовать от другой, и тот конструктор
[20:41.820 --> 20:47.700]  будет constexpr, и этот конструктор будет constexpr. Ну, то есть, казалось бы, ничего такого. Что еще
[20:47.700 --> 20:53.620]  можно в constexpr функции? Вот, можно ли с исключениями работать в constexpr функции? Вот, можно ли в
[20:53.620 --> 21:02.940]  constexpr функции в compile time бросить исключения? В 20 можно стало. Значит, правило было следующее,
[21:02.940 --> 21:12.620]  вот dot C++, ну, давайте я вот так скажу, тест от X, давай я скажу, если X равно 0,
[21:12.620 --> 21:22.980]  то throw, что-нибудь там, 1. Смотрите, как интересно. Вот, давайте я скажу constexpr int,
[21:22.980 --> 21:38.820]  не знаю, C равно тест от 1. Вот, я зашел в эту функцию, проверил, если X равен 0,
[21:38.820 --> 21:46.140]  то я должен бросить исключения, ну, а так, если нет, то я просто возвращаю тройку. Я вызываю
[21:46.140 --> 21:54.500]  все-таки единицу. Смотрите, как интересно, все работает. То есть, вот эта константа будет,
[21:54.500 --> 22:04.780]  ну, static assert, сейчас я напишу, что C равно 3. Static assert, напоминаю для тех, кто не знает,
[22:04.780 --> 22:10.260]  это compile time проверка, что условия верны, если оно не верно, то ошибка компиляции. Вот,
[22:10.260 --> 22:15.340]  поскольку у меня C это constexpr, вот для constexpr переменных я могу static assert проверять,
[22:15.340 --> 22:21.660]  что они правны чему-то. Вот как раз тот факт, что переменная constexpr дает мне возможность
[22:21.660 --> 22:30.220]  условия на нее проверять static assert. Все скомпилировалось. Ну, то есть, если бы я написал здесь C
[22:30.220 --> 22:37.140]  равно 5, то была бы ошибка компиляции, что C равно 3 и не 5 на самом деле. Static assert failed. Так вот,
[22:37.140 --> 22:50.260]  а что если бы я вызвался от нуля? Там написано if X равен 0, throw 1. Догадаетесь. Say yeah, потому что
[22:50.260 --> 22:59.740]  брошено исключение в compile time. Ну, то есть, если мы в процессе compile time вычислений видим слово
[23:00.060 --> 23:07.780]  throw, само по себе слово throw в концепциях функций не запрещено, но если мы на него
[23:07.780 --> 23:19.740]  натыкаемся в реальности, то say yeah. Вот такое правило. Но это начиная с C++17. До C++17
[23:19.740 --> 23:25.100]  вообще throw, по-моему, нельзя было в концепциях функций писать, давайте проверим. Да, вот смотрите,
[23:25.100 --> 23:36.380]  в C++14 у меня expression throw expression из ноты концепция. То есть, до C++17 вообще throw в концепциях
[23:36.380 --> 23:46.180]  функций было запрещено. Начиная с C++17. У меня работает. Можно. 14+. Да? Интересно. Может,
[23:46.180 --> 23:57.020]  другая версия комплята. У меня и кланк, и JCC работают. Ну, фиг знает. 11 может начало разрешать.
[23:57.020 --> 24:05.940]  Нет, не разрешает. Ну, в общем, не знаю. Но кажется, что, насколько я помню, так было. Вот.
[24:05.940 --> 24:13.980]  C++17, соответственно, если мы натыкаемся на throw, то say yeah, а иначе все нормально. Просто...
[24:13.980 --> 24:24.820]  Подождите, я неправильно сказал. Это у меня ошибка не из-за того, что я throw в принципе написал,
[24:24.820 --> 24:30.380]  ошибка из-за того, что я от нуля вызвался. Может быть, действительно, C++14 тоже можно было throw писать.
[24:30.380 --> 24:39.260]  Ну, не так важно, в какой... Ну да, видимо, это правда. Видимо, 14 тоже можно было. Ну, тогда не буду говорить,
[24:39.260 --> 24:49.020]  что... Так, но... Ну, это не так важно, в какой версии что стало можно. Вот. А я сейчас говорю уже про то,
[24:49.020 --> 24:56.820]  что можно теперь, начиная с C++20. Начиная с C++20, можно try catch писать в концепциях функций. Вот раньше
[24:56.820 --> 25:10.180]  нельзя было. Вот. Я в C++17 еще не мог в концепциях написать try. Ну вот, давайте я так сделаю.
[25:10.180 --> 25:25.660]  Очень странная функция. Смотрите, я, если х равен нулю, то кину 1 и верну, ну, в итоге верну 5.
[25:25.660 --> 25:29.900]  А иначе верну 3. Вот я вызываюсь от единицы. Что сейчас будет?
[25:29.900 --> 25:40.380]  Если я вызываюсь от единицы, то он компилирует прямо с warning, что C++20 нужно. Ну вот, C++17
[25:40.380 --> 25:46.060]  он все равно скомпилировал, но с warning. Ну вот, C++20 он скомпилировал.
[25:46.060 --> 25:58.500]  Вот. И статик осер, что C равно 3. Если от нуля, то...
[25:58.500 --> 26:07.140]  Я разочаровываю.
[26:07.140 --> 26:10.980]  Фроу сделал, но все равно не смог.
[26:10.980 --> 26:19.700]  Эх, жаль. А я думал, он уже умеет. Ну ладно.
[26:20.660 --> 26:24.100]  Try.cache писать научились, а фроу не научились делать.
[26:24.100 --> 26:32.420]  Ну, если бы мы... Вот. В первом случае мы отработали.
[26:32.420 --> 26:37.380]  Когда эти полуравия на единицы, мы попали в этот притерон. А так мы попали в этот притерон.
[26:37.380 --> 26:48.420]  Так, давайте посмотрим на формальный список того, что умеет делать constexpr.
[26:48.420 --> 26:59.860]  Вот здесь перечислено много интересного. Мы сейчас еще не все из этого разобрали.
[26:59.860 --> 27:19.300]  Ну вот, возвращаемый тип должен быть ветеральным. Каждый из этих параметров должен быть ветеральным.
[27:20.260 --> 27:29.140]  Конструктор и деструктор классно не должны иметь виртуальных наследований, так запрещено.
[27:29.140 --> 27:38.340]  Существует... В общем, ладно, я не буду это читать. Нельзя, чтобы это был function.try.blog.c++20.
[27:38.740 --> 27:52.740]  Ну, вот что нельзя в constexpr функциях до 723.
[27:52.740 --> 27:58.980]  Нельзя go to, нельзя метки, соответственно.
[27:58.980 --> 28:02.660]  Нельзя try.blog, нельзя assembler-ную вставку.
[28:03.060 --> 28:07.060]  И нельзя объявление переменной, у которой не производится инициализация.
[28:07.060 --> 28:09.860]  Это до c++20, было с c++20, стало можно.
[28:09.860 --> 28:17.380]  Нельзя определять переменную нелитерального типа, нельзя объявлять переменную статического или thread storage duration.
[28:21.620 --> 28:24.900]  Странно, что throw до сих пор нельзя, если можно при этом...
[28:25.700 --> 28:27.700]  Ам...
[28:31.700 --> 28:33.700]  Зачем нам go to?
[28:35.700 --> 28:45.700]  Да, even though try.blogs and inline.assembly are allowed in constexpr functions, throw in exceptions or execute in assembly is still disallowed in a constexpr expression. Понятно.
[28:45.700 --> 28:47.700]  Что такое literal type?
[28:47.700 --> 28:49.700]  Я не помню.
[28:49.700 --> 28:51.700]  Какой пример не literal type?
[28:51.700 --> 28:53.700]  Ну, вектор.
[28:54.500 --> 28:56.500]  Он не literal, у него же все constexpr.
[28:56.500 --> 28:58.500]  Ам...
[29:02.500 --> 29:04.500]  Нет, я неправильно сказал.
[29:24.500 --> 29:30.500]  В общем, определение literal type подогнано под то, чтобы в constexpr функциях можно было создавать все то, что мы хотим.
[29:30.500 --> 29:33.700]  Он должен обладать всеми следующими свойствами.
[29:33.700 --> 29:41.700]  Имеет тривиальный деструктор до c++20, начиная с c++20, просто constexpr-деструктор.
[29:41.700 --> 29:43.700]  И это, в общем, все, что мы хотим.
[29:43.700 --> 29:45.700]  И это, в общем, все, что мы хотим.
[29:45.700 --> 29:47.700]  И это, в общем, все, что мы хотим.
[29:48.700 --> 29:53.700]  Деструктор до c++20, начиная с c++20, просто constexpr-деструктор.
[29:53.700 --> 29:57.700]  И это один из эгрегатных типов, хотя бы с одним constexpr-конструктором.
[29:57.700 --> 29:59.700]  И либо это замыкание.
[29:59.700 --> 30:01.700]  Замыкание, то есть лямут.
[30:01.700 --> 30:05.700]  Короче, очень много чего literal type-ами уже является.
[30:05.700 --> 30:09.700]  Еще и unions-ы могут быть literal type-ами.
[30:09.700 --> 30:11.700]  для юнионов
[30:12.660 --> 30:17.580]  хотя бы один нестатический член должен быть не волатайл витерал-тайп
[30:18.580 --> 30:22.460]  а для неюнионов все члены должны быть такими, и все базовые классы должны быть такими
[30:23.060 --> 30:25.060]  короче, это очень слабое условие, что витерал-тайп
[30:25.300 --> 30:29.860]  да, все-таки throw нельзя в констанциях функций делать, и вот здесь заметка, что
[30:34.900 --> 30:37.880]  try можно писать, но throw делать нельзя, почему?
[30:38.440 --> 30:42.280]  ну а когда тогда может try в констанциях функций быть полезным?
[30:42.280 --> 30:46.280]  ну например, если эта функция, она вызывается как в run-time, так и в compile-time
[30:47.040 --> 30:54.400]  в compile-time он просто try увидит, ну и пройдет спокойно, но если у нас ровно ткнется, будет ce, а в run-time он уже нормально
[30:55.240 --> 30:58.520]  но исключение кидать в compile-time он все-таки не умеет
[31:00.400 --> 31:02.400]  вот
[31:02.400 --> 31:14.760]  давайте поговорим про constexpr-dynamic-memory-location
[31:14.760 --> 31:16.760]  и про это я даже отдельные пункты веду
[31:21.760 --> 31:25.760]  пункт 16.2 будет называться constexpr-new-delete
[31:26.120 --> 31:30.120]  ну и
[31:34.120 --> 31:36.120]  ну ладно, пройдите пока
[31:36.120 --> 31:42.120]  ну constexpr-vector, vector-end-string
[31:44.120 --> 31:46.120]  начиная с c++20
[31:46.480 --> 31:48.480]  а
[31:53.480 --> 31:57.480]  оператор new стала можно использовать в compile-time
[32:00.480 --> 32:02.480]  зачем это может быть нужно?
[32:04.480 --> 32:06.480]  и как это работает?
[32:08.480 --> 32:10.480]  второй вопрос более интересен
[32:10.840 --> 32:14.840]  на самом деле второй вопрос не супер интересен, потому что
[32:15.840 --> 32:17.840]  это забота компилятора, как обычно
[32:17.840 --> 32:20.840]  но компилятор уже полностью умеет
[32:20.840 --> 32:24.840]  ну, он уже полностью потерян в compile-time, в лизы compile-time-вечтений
[32:24.840 --> 32:27.840]  ну, по сути, весь c++ вогнали почти туда
[32:27.840 --> 32:29.840]  теперь еще new там есть, delete
[32:29.840 --> 32:32.840]  ну как? компилятор просто
[32:32.840 --> 32:35.840]  пока компилирует, делает вызов new, ну что?
[32:35.840 --> 32:37.840]  он запрашивает в операционке, кидает в память
[32:38.200 --> 32:40.200]  ну, пока компилирует, в чем проблема?
[32:41.200 --> 32:44.200]  ну, constexpr-new есть одно приятное очень свойство
[32:44.200 --> 32:46.200]  которое отличает его от
[32:50.200 --> 32:53.200]  не знаю, constexpr-array-sum
[32:53.200 --> 32:55.200]  давайте
[32:55.200 --> 32:57.200]  там, не знаю
[32:59.200 --> 33:02.200]  constexpr-in-array-sum
[33:02.560 --> 33:04.560]  а
[33:05.560 --> 33:08.560]  ну, давайте я скажу, что
[33:10.560 --> 33:12.560]  принимаю n
[33:12.560 --> 33:14.560]  будет очень глупая функция, которая
[33:14.560 --> 33:16.560]  заводит массив
[33:16.560 --> 33:18.560]  заполняет его n числами
[33:18.560 --> 33:20.560]  и возвращает сумму, не знаю
[33:20.560 --> 33:22.560]  в общем
[33:22.560 --> 33:24.560]  ну, давайте я скажу, что у меня будет
[33:24.560 --> 33:26.560]  int звездочка p равно
[33:26.560 --> 33:28.560]  int звездочка a равно
[33:28.560 --> 33:30.560]  new
[33:30.920 --> 33:32.920]  int n
[33:36.920 --> 33:38.920]  ну, дальше я скажу
[33:38.920 --> 33:40.920]  for там, int i равно 0
[33:40.920 --> 33:42.920]  i меньше n, плюс плюс i
[33:42.920 --> 33:44.920]  a it равно
[33:44.920 --> 33:46.920]  i
[33:46.920 --> 33:48.920]  ну, и дальше что-нибудь сделаю там, не знаю
[33:48.920 --> 33:50.920]  for
[33:50.920 --> 33:52.920]  ну, понятно, что я могу, конечно
[33:52.920 --> 33:54.920]  сделать n умножить с 1 пополам
[33:54.920 --> 33:56.920]  и вернуть сумму, но я вот
[33:56.920 --> 33:58.920]  просто для демонстрации
[33:58.920 --> 34:00.920]  возможностей сделаю глупый алгоритм под счет
[34:00.920 --> 34:02.920]  суммы первых n чисел, вот я
[34:02.920 --> 34:04.920]  скажу, что сумма у меня равна 0
[34:04.920 --> 34:06.920]  а теперь я вот это скопирую
[34:06.920 --> 34:08.920]  и скажу, что теперь
[34:08.920 --> 34:10.920]  сумма плюс равно
[34:10.920 --> 34:12.920]  a it
[34:12.920 --> 34:14.920]  очень глупый алгоритм
[34:14.920 --> 34:16.920]  и возвращаю сумму
[34:16.920 --> 34:18.920]  ну, глупый не глупый
[34:18.920 --> 34:20.920]  а можно, в принципе, и
[34:20.920 --> 34:22.920]  что-то более интеллектуальное сделать
[34:22.920 --> 34:24.920]  ну, допустим, у меня действительно был бы какой-то
[34:24.920 --> 34:26.920]  вектор чисел
[34:26.920 --> 34:28.920]  и
[34:28.920 --> 34:30.920]  он бы где-то вот был записан
[34:30.920 --> 34:32.920]  в каких-нибудь статических константах
[34:32.920 --> 34:34.920]  ну, у меня был бы какой-нибудь реально массив статический большой
[34:34.920 --> 34:36.920]  и мне нужно было в CompileTimer
[34:36.920 --> 34:38.920]  посчитать на нем
[34:38.920 --> 34:40.920]  какие-нибудь
[34:40.920 --> 34:42.920]  вещи, ну, или, например, я хочу
[34:42.920 --> 34:44.920]  в CompileTimer сделать 6-й ротосфер
[34:44.920 --> 34:46.920]  вот, вот
[34:46.920 --> 34:48.920]  CompileTimer 6-й ротосфер
[34:48.920 --> 34:50.920]  я хочу там, в CompileTimer
[34:50.920 --> 34:52.920]  построить там таблицу
[34:52.920 --> 34:54.920]  там, среди первых
[34:54.920 --> 34:56.920]  миллионов чисел
[34:56.920 --> 34:58.920]  какой простой, какой нет
[34:58.920 --> 35:00.920]  пожалуйста, я это спокойно делаю в CompileTimer
[35:00.920 --> 35:02.920]  причем
[35:02.920 --> 35:04.920]  это n, я его могу варьировать
[35:04.920 --> 35:06.920]  и оно просто будет параметром
[35:06.920 --> 35:08.920]  функции
[35:08.920 --> 35:10.920]  я просто в CompileTimer
[35:10.920 --> 35:12.920]  построю таблицу эту, среди што
[35:12.920 --> 35:14.920]  ротосфер, и
[35:16.920 --> 35:18.920]  она будет, как статический констант
[35:18.920 --> 35:20.920]  массив, уже в бинарник записана
[35:20.920 --> 35:22.920]  когда программа
[35:22.920 --> 35:24.920]  запустится
[35:26.920 --> 35:28.920]  вот, ну, вот сейчас
[35:28.920 --> 35:30.920]  я попробую это вызвать
[35:32.920 --> 35:34.920]  constexpr int
[35:36.920 --> 35:38.920]  sum равно
[35:38.920 --> 35:40.920]  array sum
[35:40.920 --> 35:42.920]  от 10
[35:44.920 --> 35:46.920]  допустим
[35:46.920 --> 35:48.920]  и так
[35:48.920 --> 35:50.920]  я здесь тест от 0
[35:50.920 --> 35:52.920]  это не будет смогу вызываться
[35:54.920 --> 35:56.920]  ну, давайте скажу, что
[35:56.920 --> 35:58.920]  статик ассерт
[35:58.920 --> 36:00.920]  что сумма у меня
[36:00.920 --> 36:02.920]  45, наверное, должна быть
[36:02.920 --> 36:04.920]  там, когда ввести число
[36:04.920 --> 36:06.920]  сейчас будет CE
[36:12.920 --> 36:14.920]  посмотрите на эту прекрасную
[36:14.920 --> 36:16.920]  ошибку компиляции
[36:16.920 --> 36:18.920]  на первую
[36:18.920 --> 36:20.920]  я сделал new, а delete не сделал
[36:20.920 --> 36:22.920]  в CompileTimer
[36:26.920 --> 36:28.920]  компилятору не понравилось
[36:28.920 --> 36:30.920]  когда я в CompileTimer использую
[36:30.920 --> 36:32.920]  оператор new, компилятор
[36:32.920 --> 36:34.920]  вынужден сам следить
[36:34.920 --> 36:36.920]  за тем
[36:36.920 --> 36:38.920]  освободил ли я все, что выделал
[36:38.920 --> 36:40.920]  или нет
[36:40.920 --> 36:42.920]  добро пожаловать в горку
[36:42.920 --> 36:44.920]  добро пожаловать автоматически
[36:44.920 --> 36:46.920]  можно сказать
[36:46.920 --> 36:48.920]  нельзя сказать
[36:48.920 --> 36:50.920]  сборкой мусора
[36:50.920 --> 36:52.920]  если бы я не освободил
[36:52.920 --> 36:54.920]  то компилятор
[36:54.920 --> 36:56.920]  утечку памяти допустил в CompileTimer
[36:56.920 --> 36:58.920]  так же он не может допустить
[36:58.920 --> 37:00.920]  поэтому компилятор
[37:00.920 --> 37:02.920]  если я что-то в new выделяю
[37:02.920 --> 37:04.920]  в CompileTimer
[37:04.920 --> 37:06.920]  дополнительно сам
[37:06.920 --> 37:08.920]  он на самом деле запрашивает больше
[37:08.920 --> 37:10.920]  он в CompileTimer поддерживает специальные
[37:10.920 --> 37:12.920]  структуры, которые ему нужны
[37:12.920 --> 37:14.920]  сколько я выделил, столько и освободил
[37:14.920 --> 37:16.920]  это же еще веселее
[37:16.920 --> 37:18.920]  допустим я скажу
[37:18.920 --> 37:20.920]  delete
[37:20.920 --> 37:22.920]  a plus 1
[37:22.920 --> 37:24.920]  или go
[37:24.920 --> 37:26.920]  я вот так скажу
[37:26.920 --> 37:28.920]  delete a просто
[37:28.920 --> 37:30.920]  даже это ведь плохо
[37:30.920 --> 37:32.920]  я же должен был сказать delete
[37:32.920 --> 37:34.920]  а
[37:34.920 --> 37:36.920]  non-radiallocational object
[37:36.920 --> 37:38.920]  allocated with react allocation
[37:38.920 --> 37:40.920]  компилятор
[37:40.920 --> 37:42.920]  честно следит
[37:42.920 --> 37:44.920]  что-то, над чем мы столько
[37:44.920 --> 37:46.920]  страдали, что мы должны были
[37:46.920 --> 37:48.920]  в run-time с руками
[37:48.920 --> 37:50.920]  отслеживать через санитайзер, компилятор
[37:50.920 --> 37:52.920]  все теперь в CPU 20 умеет в CompileTimer
[37:52.920 --> 37:54.920]  проверять
[37:54.920 --> 37:56.920]  в частности, например
[37:56.920 --> 37:58.920]  вы можете использовать это для того, чтобы проверить
[37:58.920 --> 38:00.920]  вот у вас там, ну вы не из основного потока
[38:00.920 --> 38:02.920]  даже если вы были из основного потока
[38:02.920 --> 38:04.920]  даже если вы не из основного потока
[38:04.920 --> 38:06.920]  вот пишите вы стринг
[38:06.920 --> 38:08.920]  хотите проверить
[38:08.920 --> 38:10.920]  не забыли все ли вы корректно
[38:10.920 --> 38:12.920]  освобождаете
[38:12.920 --> 38:14.920]  ну просто констанцев понавешали везде
[38:14.920 --> 38:16.920]  соответственно
[38:16.920 --> 38:18.920]  и статик осертов вместо обычных осертов
[38:18.920 --> 38:20.920]  ну тогда компилятор просидит
[38:20.920 --> 38:22.920]  что вы все освободили, что выделили
[38:22.920 --> 38:24.920]  и корректно причем освободили
[38:24.920 --> 38:26.920]  вот
[38:26.920 --> 38:28.920]  но
[38:28.920 --> 38:30.920]  ладно, я вам сейчас еще одну
[38:30.920 --> 38:32.920]  очень забавную фишку покажу связанную
[38:32.920 --> 38:34.920]  с этой
[38:34.920 --> 38:36.920]  давайте я попрошу компилятор
[38:36.920 --> 38:38.920]  посчитать мне сумму
[38:38.920 --> 38:40.920]  времени от
[38:40.920 --> 38:42.920]  не от 10
[38:42.920 --> 38:44.920]  а вот знаете
[38:44.920 --> 38:46.920]  сколько
[38:46.920 --> 38:48.920]  да от миллиарда
[38:50.920 --> 38:52.920]  я не буду уже статик
[38:52.920 --> 38:54.920]  осерт говорить
[38:54.920 --> 38:56.920]  чему равна сумма, я не хочу
[38:56.920 --> 38:58.920]  я просто скажу, что она больше, чем 2 миллиарда
[39:02.920 --> 39:04.920]  ну что сейчас будет?
[39:08.920 --> 39:10.920]  ну сейчас
[39:10.920 --> 39:12.920]  это будет очень долго компилироваться конечно
[39:12.920 --> 39:14.920]  но может быть я
[39:14.920 --> 39:16.920]  от миллиона все таки попрошу, а не от миллиарда
[39:16.920 --> 39:18.920]  мне хватит
[39:18.920 --> 39:20.920]  чтобы продемонстрировать нужный эффект
[39:20.920 --> 39:22.920]  что сейчас будет, отгадайте
[39:22.920 --> 39:24.920]  будет ЦЕ
[39:24.920 --> 39:26.920]  и отгадайте почему
[39:26.920 --> 39:28.920]  потому что переполнение
[39:28.920 --> 39:30.920]  ИНТА
[39:30.920 --> 39:32.920]  у меня loop iteration count exceeds limit of
[39:32.920 --> 39:34.920]  262 тысячи
[39:34.920 --> 39:36.920]  что?
[39:36.920 --> 39:38.920]  это конечно
[39:38.920 --> 39:40.920]  constexpr loop limit
[39:40.920 --> 39:42.920]  ага
[39:42.920 --> 39:44.920]  ну давайте увеличим
[39:44.920 --> 39:46.920]  не проблема
[39:46.920 --> 39:48.920]  я не знал, что они такого параметра
[39:48.920 --> 39:50.920]  удивительно
[39:52.920 --> 39:54.920]  сколько мне надо
[39:54.920 --> 39:56.920]  2 миллиарда
[39:56.920 --> 39:58.920]  ну давайте 10 миллион
[40:02.920 --> 40:04.920]  вот он считает
[40:04.920 --> 40:06.920]  вычисления в compile time
[40:06.920 --> 40:08.920]  не очень быстрые
[40:12.920 --> 40:14.920]  ну все
[40:14.920 --> 40:16.920]  ЦЕ
[40:16.920 --> 40:18.920]  overflowing constant expression
[40:18.920 --> 40:20.920]  причем он очень много раз
[40:20.920 --> 40:22.920]  эту ошибку выдал, видимо
[40:22.920 --> 40:24.920]  он не остановил
[40:24.920 --> 40:26.920]  вычисления, когда ее обнаружил в первый раз
[40:26.920 --> 40:28.920]  и продолжил
[40:28.920 --> 40:30.920]  а в конце он еще написал, что
[40:30.920 --> 40:32.920]  evolution operation count exceeds limit of
[40:32.920 --> 40:34.920]  3352432
[40:36.920 --> 40:38.920]  так стоп, я же 10 миллионов поставил
[40:38.920 --> 40:40.920]  лимит
[40:40.920 --> 40:42.920]  а это лимит на цикл, а тут есть еще
[40:42.920 --> 40:44.920]  лимит на операции
[40:44.920 --> 40:46.920]  и его нужно, минус f constexpr obs limit
[40:46.920 --> 40:48.920]  в общем, у него много лимитов
[40:50.920 --> 40:52.920]  ну это предохранитель
[40:52.920 --> 40:54.920]  ну это уже понятно, ни в каком стандарте не описано
[40:54.920 --> 40:56.920]  а это просто у самого компилятора
[40:56.920 --> 40:58.920]  предохранитель
[40:58.920 --> 41:00.920]  constexpr obs limit
[41:00.920 --> 41:02.920]  это понятно в самом компиляторе
[41:02.920 --> 41:04.920]  что надо предохранить, чтобы вы случайно
[41:04.920 --> 41:06.920]  в compile time не зависли
[41:06.920 --> 41:08.920]  понятнее, чем это надо
[41:08.920 --> 41:10.920]  но можно и его увеличить
[41:10.920 --> 41:12.920]  ну то есть, смотрите, constexpr позволяет вам
[41:16.920 --> 41:18.920]  вылавливать УБ
[41:18.920 --> 41:20.920]  compile time
[41:20.920 --> 41:22.920]  то, что раньше было УБ, теперь ЦЕ
[41:24.920 --> 41:26.920]  то, что раньше было РЕ, теперь ЦЕ
[41:26.920 --> 41:28.920]  давайте я все-таки вектор заведу
[41:30.920 --> 41:32.920]  стд-вектор
[41:40.920 --> 41:42.920]  только это будет В
[41:44.920 --> 41:46.920]  ну, а тысячи буду вызываться
[41:46.920 --> 41:48.920]  чтобы не сильно вручать
[41:48.920 --> 41:50.920]  вот
[41:50.920 --> 41:52.920]  значит
[41:52.920 --> 41:54.920]  вот
[41:54.920 --> 41:56.920]  я
[41:56.920 --> 41:58.920]  этот вектор завел
[41:58.920 --> 42:00.920]  я его посчитал
[42:00.920 --> 42:02.920]  ну, сейчас просто проверим, что работает
[42:02.920 --> 42:04.920]  то там, вроде, символисты жаловались
[42:04.920 --> 42:06.920]  что не компилируются
[42:06.920 --> 42:08.920]  ага
[42:08.920 --> 42:10.920]  я просто не заинтуидаю
[42:10.920 --> 42:12.920]  значит, начиная с имперсус-20
[42:12.920 --> 42:14.920]  конструкторы вектора
[42:14.920 --> 42:16.920]  стали constexpr
[42:16.920 --> 42:18.920]  все
[42:18.920 --> 42:20.920]  ну, возможно, кроме вектора
[42:20.920 --> 42:22.920]  почему? потому что теперь Нью
[42:22.920 --> 42:24.920]  можно в compile time делать, соответственно
[42:24.920 --> 42:26.920]  вы можете в compile time теперь заводить векторы
[42:26.920 --> 42:28.920]  сроки тоже
[42:28.920 --> 42:30.920]  я, кстати, напомню, что
[42:30.920 --> 42:32.920]  в стринг, в строке
[42:32.920 --> 42:34.920]  там есть еще один дополнительный прикол
[42:34.920 --> 42:36.920]  там же есть
[42:36.920 --> 42:38.920]  SOO
[42:38.920 --> 42:40.920]  small object optimization
[42:40.920 --> 42:42.920]  или SSO
[42:42.920 --> 42:44.920]  там union
[42:44.920 --> 42:46.920]  у которого
[42:46.920 --> 42:48.920]  члены переставлять приходится
[42:48.920 --> 42:50.920]  иногда
[42:50.920 --> 42:52.920]  ну, то есть, у вас с юнионом же
[42:52.920 --> 42:54.920]  следующая проблема
[42:54.920 --> 42:56.920]  ну, когда вы выбрали какой-то член в юнио
[42:56.920 --> 42:58.920]  она потом в runtime подменили тип лежащего в юнио
[42:58.920 --> 43:00.920]  на что-то другое
[43:00.920 --> 43:02.920]  вот
[43:02.920 --> 43:04.920]  и это все тоже в compile time теперь можно делать
[43:04.920 --> 43:06.920]  это раньше было нельзя до какой-то версии
[43:06.920 --> 43:08.920]  но я не помню до какой
[43:08.920 --> 43:10.920]  ну вот, начиная с какой-то можно
[43:10.920 --> 43:12.920]  то есть, сейчас, мне кажется
[43:16.920 --> 43:18.920]  ой, материалная статья
[43:18.920 --> 43:20.920]  у меня была
[43:20.920 --> 43:22.920]  статья, в которой перечислялась эта
[43:24.920 --> 43:26.920]  ну, ладно
[43:26.920 --> 43:28.920]  вот
[43:28.920 --> 43:30.920]  ну, в общем, строки и векторы
[43:30.920 --> 43:32.920]  я теперь могу делать в compile time
[43:36.920 --> 43:38.920]  х
[43:38.920 --> 43:40.920]  не могу
[43:40.920 --> 43:42.920]  очень слышно
[43:42.920 --> 43:44.920]  может быть
[43:44.920 --> 43:46.920]  g++ не справляется
[43:48.920 --> 43:50.920]  да, вот семейристы еще тоже жалуются, что
[43:50.920 --> 43:52.920]  вектор в compile time не изменится
[43:52.920 --> 43:54.920]  аа
[43:56.920 --> 43:58.920]  справишься или нет?
[44:00.920 --> 44:02.920]  нет, все равно не получается
[44:02.920 --> 44:04.920]  это очень странно, наверное
[44:04.920 --> 44:06.920]  у меня просто старая версия
[44:08.920 --> 44:10.920]  давайте
[44:10.920 --> 44:12.920]  давайте-ка я попробую
[44:12.920 --> 44:14.920]  давайте-ка я попробую
[44:14.920 --> 44:16.920]  это все
[44:16.920 --> 44:18.920]  я попробую
[44:22.920 --> 44:24.920]  интересно выделяется
[44:28.920 --> 44:30.920]  ладно, сейчас godbolt
[44:34.920 --> 44:36.920]  должен работать
[44:36.920 --> 44:38.920]  давайте
[44:52.920 --> 44:54.920]  я не помню как
[44:54.920 --> 44:56.920]  вот
[45:00.920 --> 45:02.920]  заходить
[45:02.920 --> 45:04.920]  поэтому придется
[45:06.920 --> 45:08.920]  пишет, ошибка, что
[45:08.920 --> 45:10.920]  у среди векторов нет constexpr деструктора
[45:18.920 --> 45:20.920]  сейчас
[45:20.920 --> 45:22.920]  где constexpr
[45:22.920 --> 45:24.920]  был файл
[45:24.920 --> 45:26.920]  давайте
[45:26.920 --> 45:28.920]  вот эту функцию мы
[45:28.920 --> 45:30.920]  скопируем
[45:32.920 --> 45:34.920]  да, просто все скопируем
[45:36.920 --> 45:38.920]  и
[45:38.920 --> 45:40.920]  gcc 12
[45:42.920 --> 45:44.920]  все еще не справляется
[45:44.920 --> 45:46.920]  а силенка 12
[45:46.920 --> 45:48.920]  силенка 14
[45:48.920 --> 45:50.920]  да, силенка 14
[45:56.920 --> 45:58.920]  все
[45:58.920 --> 46:00.920]  нет, все равно не может
[46:00.920 --> 46:02.920]  а не может, вероятно, потому что
[46:06.920 --> 46:08.920]  очень странно
[46:14.920 --> 46:16.920]  а
[46:16.920 --> 46:18.920]  остается
[46:18.920 --> 46:20.920]  17, давайте попробуем 20
[46:24.920 --> 46:26.920]  все равно не может
[46:36.920 --> 46:38.920]  я что-то не понимаю в этой жизни
[46:40.920 --> 46:42.920]  прошел стринг, посмотри
[46:42.920 --> 46:44.920]  вы видите constexpr
[46:48.920 --> 46:50.920]  а так
[46:50.920 --> 46:52.920]  да
[46:52.920 --> 46:54.920]  что?
[46:54.920 --> 46:56.920]  да
[46:56.920 --> 46:58.920]  да
[47:16.920 --> 47:18.920]  да, очень странно
[47:18.920 --> 47:20.920]  непонятно
[47:24.920 --> 47:26.920]  ну
[47:26.920 --> 47:28.920]  значит
[47:28.920 --> 47:30.920]  я был неправ
[47:30.920 --> 47:32.920]  и почему-то они еще не поддерживают
[47:32.920 --> 47:34.920]  объявление векторов
[47:34.920 --> 47:36.920]  в компонент тайне
[47:36.920 --> 47:38.920]  хотя мне казалось, что я
[47:38.920 --> 47:40.920]  прям точно
[47:40.920 --> 47:42.920]  видел такое
[47:42.920 --> 47:44.920]  возможно, это было планируемое
[47:44.920 --> 47:46.920]  возможно, мне
[47:46.920 --> 47:48.920]  побережилось
[47:48.920 --> 47:50.920]  а возможно, это был какой-то код
[47:50.920 --> 47:52.920]  который потенциально должен скорость
[47:52.920 --> 47:54.920]  работать, потому что не работает
[47:58.920 --> 48:00.920]  да
[48:00.920 --> 48:02.920]  ну ладно
[48:02.920 --> 48:04.920]  ну значит
[48:04.920 --> 48:06.920]  почему-то вектор пока нельзя
[48:06.920 --> 48:08.920]  объявлять в компоненте функции
[48:12.920 --> 48:14.920]  написано, что
[48:14.920 --> 48:16.920]  должно быть
[48:16.920 --> 48:18.920]  с 12
[48:18.920 --> 48:20.920]  работать
[48:20.920 --> 48:22.920]  что именно?
[48:22.920 --> 48:24.920]  вектор constexpr
[48:24.920 --> 48:26.920]  ну возможно
[48:26.920 --> 48:28.920]  можно написать constexpr
[48:28.920 --> 48:30.920]  вектор вот так
[48:32.920 --> 48:34.920]  наверное
[48:34.920 --> 48:36.920]  вот что имеется в виду
[48:36.920 --> 48:38.920]  что можно constexpr
[48:38.920 --> 48:40.920]  вектор завести вот таким образом
[48:44.920 --> 48:46.920]  вот так можно
[48:46.920 --> 48:48.920]  в
[48:48.920 --> 48:50.920]  в
[48:58.920 --> 49:00.920]  ничего
[49:00.920 --> 49:02.920]  тоже нельзя, по той же причине
[49:02.920 --> 49:04.920]  ну это уж вообще странно
[49:12.920 --> 49:14.920]  довольно бессмысленно
[49:14.920 --> 49:16.920]  очень странно
[49:16.920 --> 49:18.920]  очень странно
[49:20.920 --> 49:22.920]  ну уж строки-то уж точно
[49:22.920 --> 49:24.920]  должно быть можно
[49:24.920 --> 49:26.920]  я же прям видел, что люди так делают
[49:30.920 --> 49:32.920]  ладно
[49:32.920 --> 49:34.920]  я вас обманул, значит нельзя
[49:34.920 --> 49:36.920]  но я не знаю почему
[49:36.920 --> 49:38.920]  я был уверен, что можно
[49:38.920 --> 49:40.920]  это было странно
[49:40.920 --> 49:42.920]  не знаю почему
[49:42.920 --> 49:44.920]  ладно, разберусь
[49:44.920 --> 49:46.920]  давайте дальше пойдем
[49:46.920 --> 49:48.920]  ну короче constexpr new
[49:48.920 --> 49:50.920]  и delete в любом случае можно
[49:52.920 --> 49:54.920]  по крайней мере это значит
[49:54.920 --> 49:56.920]  что вы можете
[49:56.920 --> 49:58.920]  свой вектор написать
[49:58.920 --> 50:00.920]  который уже будет compile-time поддерживать
[50:00.920 --> 50:02.920]  вы можете
[50:06.920 --> 50:08.920]  наверное объявить виртуальный
[50:08.920 --> 50:10.920]  constexpr
[50:10.920 --> 50:12.920]  деструктор у вектора
[50:12.920 --> 50:14.920]  и тогда он будет
[50:14.920 --> 50:16.920]  работать
[50:16.920 --> 50:18.920]  то есть если вот мы посмотрим на вектор
[50:18.920 --> 50:20.920]  и на его методы
[50:20.920 --> 50:22.920]  то наверное мы увидим, что деструктор
[50:22.920 --> 50:24.920]  в нем не constexpr
[50:26.920 --> 50:28.920]  не деструктор в нем constexpr
[50:28.920 --> 50:30.920]  тогда это вообще
[50:30.920 --> 50:32.920]  очень странно
[50:32.920 --> 50:34.920]  может быть компиляторы просто не поддерживают
[50:34.920 --> 50:36.920]  еще до сих пор, потому что su20 должно быть можно
[50:36.920 --> 50:38.920]  ну написано
[50:38.920 --> 50:40.920]  там же есть статья
[50:40.920 --> 50:42.920]  написано, что должно
[50:42.920 --> 50:44.920]  поддерживать su12
[50:44.920 --> 50:46.920]  ну вот
[50:46.920 --> 50:48.920]  почему-то не поддерживают
[50:48.920 --> 50:50.920]  то ли я какую-то мелочь забыл
[50:50.920 --> 50:52.920]  то ли
[50:52.920 --> 50:54.920]  компиляторы
[50:54.920 --> 50:56.920]  еще не умеют до конца
[50:56.920 --> 50:58.920]  возможно в библиотеке
[50:58.920 --> 51:00.920]  еще constexpr
[51:00.920 --> 51:02.920]  писали в деструктор вектора
[51:02.920 --> 51:04.920]  то есть начиная с su20 и деструктор
[51:04.920 --> 51:06.920]  а следователь на тип становится литеральным
[51:06.920 --> 51:08.920]  согласно тому определению, которое вы читали
[51:08.920 --> 51:10.920]  казалось бы он должен создаваться в компрелтайне в мете
[51:12.920 --> 51:14.920]  в общем
[51:14.920 --> 51:16.920]  я даже если не поддерживаюсь сейчас
[51:16.920 --> 51:18.920]  я все равно верю в то, что это очень скоро начнет поддерживаться
[51:24.920 --> 51:26.920]  следующая вещь, о которой хочу поговорить
[51:28.920 --> 51:30.920]  это самая crazy
[51:30.920 --> 51:32.920]  возможно вещь, которую я
[51:32.920 --> 51:34.920]  слышал про
[51:34.920 --> 51:36.920]  c++
[51:36.920 --> 51:38.920]  ну нет, самая crazy
[51:38.920 --> 51:40.920]  будет завтра
[51:40.920 --> 51:42.920]  это наверное
[51:42.920 --> 51:44.920]  ну это самая смешная вещь
[51:44.920 --> 51:46.920]  которую я за последний год
[51:46.920 --> 51:48.920]  слышал про c++
[51:48.920 --> 51:50.920]  связанная с c++20
[51:50.920 --> 51:52.920]  что у нас еще есть
[51:52.920 --> 51:54.920]  в языке важного
[51:54.920 --> 51:56.920]  из того, что мы изучали
[51:56.920 --> 51:58.920]  ну у нас понятно, из класса
[51:58.920 --> 52:00.920]  конструктор, киргруз и операторов наследования
[52:00.920 --> 52:02.920]  у нас была такая замечательная тема
[52:02.920 --> 52:04.920]  полиморфизм
[52:04.920 --> 52:06.920]  и виртуальные функции
[52:06.920 --> 52:08.920]  а не поддержать ли нам в компрелтайне
[52:08.920 --> 52:10.920]  виртуальные функции
[52:10.920 --> 52:12.920]  подумал комитет
[52:12.920 --> 52:14.920]  а давайте
[52:14.920 --> 52:16.920]  решили они и поддержали
[52:16.920 --> 52:18.920]  начиная с c++20
[52:18.920 --> 52:20.920]  можно виртуальные функции делать констэксп
[52:20.920 --> 52:22.920]  таким образом
[52:22.920 --> 52:24.920]  можно делать в компрелтайне динамик диспетч
[52:24.920 --> 52:26.920]  вот давайте это посмотрим
[52:26.920 --> 52:28.920]  давайте я попробую
[52:28.920 --> 52:30.920]  завести класс base и класс derived
[52:30.920 --> 52:32.920]  давайте это будет пункт 16.3
[52:32.920 --> 52:34.920]  констэкспорт
[52:34.920 --> 52:36.920]  виртуал
[52:36.920 --> 52:38.920]  функционс
[52:38.920 --> 52:40.920]  динамик каст
[52:42.920 --> 52:44.920]  начиная с c++20
[52:48.920 --> 52:50.920]  вот я завожу структуру base
[52:50.920 --> 52:52.920]  да
[52:52.920 --> 52:54.920]  это смешно
[52:56.920 --> 52:58.920]  и тут у меня будет
[52:58.920 --> 53:00.920]  виртуал
[53:00.920 --> 53:02.920]  void f
[53:02.920 --> 53:04.920]  ну не знаю
[53:04.920 --> 53:06.920]  return x
[53:08.920 --> 53:10.920]  констэкспорт
[53:10.920 --> 53:12.920]  base
[53:12.920 --> 53:14.920]  base
[53:20.920 --> 53:22.920]  вот
[53:22.920 --> 53:24.920]  ну и завожу структуру derived
[53:24.920 --> 53:26.920]  которая наследуется от base
[53:34.920 --> 53:36.920]  у нее тоже констэкспорт конструктор
[53:36.920 --> 53:38.920]  напишу на всякий случай чтобы там
[53:38.920 --> 53:40.920]  ни по сомнению не было
[53:40.920 --> 53:42.920]  alright
[53:42.920 --> 53:44.920]  и
[53:44.920 --> 53:46.920]  верну игрок на этот раз
[53:46.920 --> 53:48.920]  ну и давайте
[53:48.920 --> 53:50.920]  констэкспорт
[53:50.920 --> 53:52.920]  int test
[53:52.920 --> 53:54.920]  virtual
[53:54.920 --> 53:56.920]  вот
[53:56.920 --> 53:58.920]  нет чего
[53:58.920 --> 54:00.920]  ну что
[54:00.920 --> 54:02.920]  как там
[54:02.920 --> 54:04.920]  мы любим base
[54:04.920 --> 54:06.920]  звездочка p
[54:06.920 --> 54:08.920]  b равно new
[54:08.920 --> 54:10.920]  derived
[54:18.920 --> 54:20.920]  int
[54:20.920 --> 54:22.920]  ans равно pb
[54:22.920 --> 54:24.920]  стрелочка f
[54:26.920 --> 54:28.920]  delete base
[54:28.920 --> 54:30.920]  delete pb
[54:30.920 --> 54:32.920]  обязательно а то у нас будут проблемы
[54:32.920 --> 54:34.920]  из-за неосвобождения памяти
[54:34.920 --> 54:36.920]  return ans
[54:36.920 --> 54:38.920]  нам похоже нужно виртуальный структур добавить
[54:38.920 --> 54:40.920]  или не то что важно
[54:40.920 --> 54:42.920]  ну давайте
[54:42.920 --> 54:44.920]  добавим
[54:46.920 --> 54:48.920]  не знаю влияет ли это на что-то
[54:48.920 --> 54:50.920]  а
[54:50.920 --> 54:52.920]  мне нужно написать констэкспорт base
[54:52.920 --> 54:54.920]  потому что сейчас у меня не виртуальный структур
[54:54.920 --> 54:56.920]  кстати не знаю может быть
[54:56.920 --> 54:58.920]  давайте сначала без него попробую
[54:58.920 --> 55:00.920]  потому что я не уверен что написал виртуальный структур
[55:00.920 --> 55:02.920]  base возможно все сломается
[55:02.920 --> 55:04.920]  а
[55:04.920 --> 55:06.920]  void function f
[55:06.920 --> 55:08.920]  should not return a value
[55:08.920 --> 55:10.920]  ну действительно
[55:16.920 --> 55:18.920]  and
[55:18.920 --> 55:20.920]  void int
[55:20.920 --> 55:22.920]  ой
[55:22.920 --> 55:24.920]  да я еще что-то написал
[55:24.920 --> 55:26.920]  давайте посмотрим
[55:26.920 --> 55:28.920]  что теперь
[55:28.920 --> 55:30.920]  ну опять та же проблема с вектором
[55:30.920 --> 55:32.920]  но в остальном-то нет проблемы
[55:32.920 --> 55:34.920]  ну как видите компилятор не жалуется
[55:34.920 --> 55:36.920]  то есть единственное что ему не нравится
[55:36.920 --> 55:38.920]  это вектор
[55:38.920 --> 55:40.920]  ну
[55:44.920 --> 55:46.920]  вернем как было
[55:50.920 --> 55:52.920]  блин
[55:52.920 --> 55:54.920]  вот точка v равна
[55:54.920 --> 55:56.920]  ее int под n
[55:56.920 --> 55:58.920]  а тут delete
[55:58.920 --> 56:00.920]  конкретность
[56:00.920 --> 56:02.920]  конточки b
[56:02.920 --> 56:04.920]  так
[56:04.920 --> 56:06.920]  ну тут кстати
[56:06.920 --> 56:08.920]  assertion failed
[56:08.920 --> 56:10.920]  но в целом
[56:10.920 --> 56:12.920]  давайте проверим
[56:12.920 --> 56:14.920]  констэкспорт int
[56:14.920 --> 56:16.920]  мы не написали нашу функцию
[56:16.920 --> 56:18.920]  констэкспорт f
[56:18.920 --> 56:20.920]  да и тем не менее почему-то он скопилировался
[56:20.920 --> 56:22.920]  мы вызвали тест
[56:22.920 --> 56:24.920]  нет
[56:24.920 --> 56:26.920]  констэкспорт int
[56:26.920 --> 56:28.920]  мы его удираем
[56:28.920 --> 56:30.920]  потому что только мы ее мы вызовем
[56:30.920 --> 56:32.920]  что забавно
[56:32.920 --> 56:34.920]  констэкспорт
[56:34.920 --> 56:36.920]  int res
[56:36.920 --> 56:38.920]  равно
[56:38.920 --> 56:40.920]  тест
[56:40.920 --> 56:42.920]  virtual
[56:42.920 --> 56:44.920]  и
[56:44.920 --> 56:46.920]  статик assert
[56:46.920 --> 56:48.920]  что res
[56:48.920 --> 56:50.920]  равен
[56:50.920 --> 56:52.920]  нелю
[56:52.920 --> 56:54.920]  давайте здесь будет 2
[56:54.920 --> 56:56.920]  2
[56:58.920 --> 57:00.920]  2
[57:00.920 --> 57:02.920]  проверим
[57:06.920 --> 57:08.920]  вот
[57:08.920 --> 57:10.920]  non-constext function cannot be used in constant expression
[57:10.920 --> 57:12.920]  ну давайте исправим
[57:12.920 --> 57:14.920]  давайте пометим
[57:14.920 --> 57:16.920]  констэкспорт
[57:16.920 --> 57:18.920]  так
[57:18.920 --> 57:20.920]  мне кажется констэкспор надо писать перед
[57:20.920 --> 57:22.920]  virtual хотя я не уверен
[57:22.920 --> 57:24.920]  вроде не важно
[57:30.920 --> 57:32.920]  удираем
[57:32.920 --> 57:34.920]  я бейс пометил
[57:34.920 --> 57:36.920]  а теперь еще удираем пометим
[57:36.920 --> 57:38.920]  забавно то что бейс можно в данном случае не помечать
[57:38.920 --> 57:40.920]  потому что мы ее не вызовем в итоге
[57:40.920 --> 57:42.920]  это сработает
[57:48.920 --> 57:50.920]  дальше
[57:50.920 --> 57:52.920]  это теперь ошибка компиляции
[57:52.920 --> 57:54.920]  тоже
[57:54.920 --> 57:56.920]  классно
[57:56.920 --> 57:58.920]  ну давайте сделаем виртуальный деструктор
[58:02.920 --> 58:04.920]  ну давайте я сделаю
[58:04.920 --> 58:06.920]  просто виртуальный деструктор
[58:06.920 --> 58:08.920]  и тогда я наверное получу по башке за то что он
[58:08.920 --> 58:10.920]  не констэкспорт
[58:10.920 --> 58:12.920]  с g c 11 не ругается
[58:12.920 --> 58:14.920]  на это
[58:14.920 --> 58:16.920]  non-literal type-destruction
[58:16.920 --> 58:18.920]  не констэкспорт
[58:18.920 --> 58:20.920]  non-literal type derived
[58:20.920 --> 58:22.920]  cannot be used in constant expression
[58:28.920 --> 58:30.920]  он ругался когда не было вообще деструктора
[58:30.920 --> 58:32.920]  because
[58:32.920 --> 58:34.920]  ну короче деструктор я тоже должен делать
[58:34.920 --> 58:36.920]  констэкспорт понятна уже причина
[58:38.920 --> 58:40.920]  констэкспорт virtual
[58:40.920 --> 58:42.920]  тоже мне нравится это сочетание слов
[58:42.920 --> 58:44.920]  деструктор base
[58:44.920 --> 58:46.920]  вот
[58:50.920 --> 58:52.920]  его еще надо определить
[58:52.920 --> 58:54.920]  чего
[58:58.920 --> 59:00.920]  что
[59:02.920 --> 59:04.920]  вот это должно запуститься с кангом теперь
[59:04.920 --> 59:06.920]  какая-то магия
[59:08.920 --> 59:10.920]  g plus-plus не ругается когда вообще нету деструктора
[59:10.920 --> 59:12.920]  виртуального ему пофиг
[59:12.920 --> 59:14.920]  он ругается
[59:14.920 --> 59:16.920]  но вы наверное
[59:16.920 --> 59:18.920]  понимаете что как и с концептами
[59:18.920 --> 59:20.920]  это все вещи очень
[59:20.920 --> 59:22.920]  еще сырые
[59:22.920 --> 59:24.920]  как видите компиляторы очень расходятся
[59:24.920 --> 59:26.920]  во мнениях что должно компилироваться
[59:26.920 --> 59:28.920]  а что нет
[59:28.920 --> 59:30.920]  вот я уверен
[59:30.920 --> 59:32.920]  что и в том и другом компиляторе еще есть
[59:32.920 --> 59:34.920]  достаточно багов
[59:34.920 --> 59:36.920]  то есть мы сейчас наблюдаем
[59:36.920 --> 59:38.920]  не то что должно быть по стандарту
[59:38.920 --> 59:40.920]  а то что компиляторы
[59:40.920 --> 59:42.920]  научились поддерживать к данному моменту
[59:42.920 --> 59:44.920]  c++ 20 пока
[59:44.920 --> 59:46.920]  еще без багов
[59:46.920 --> 59:48.920]  поддержать не удалось
[59:48.920 --> 59:50.920]  но тем не менее
[59:50.920 --> 59:52.920]  мы хоть от
[59:52.920 --> 59:54.920]  какого-то компилятора добились
[59:54.920 --> 59:56.920]  поддержки виртуальных
[59:56.920 --> 59:58.920]  значит функций
[59:58.920 --> 01:00:00.920]  вот ну и
[01:00:00.920 --> 01:00:02.920]  кстати
[01:00:02.920 --> 01:00:04.920]  вопрос еще такой могут ли
[01:00:04.920 --> 01:00:06.920]  констэкспорт
[01:00:06.920 --> 01:00:08.920]  вот если я вот эту функцию
[01:00:08.920 --> 01:00:10.920]  действительно не сделал бы констэкспорт
[01:00:10.920 --> 01:00:12.920]  то
[01:00:12.920 --> 01:00:14.920]  сработало бы это
[01:00:14.920 --> 01:00:16.920]  это бы все равно сработало
[01:00:16.920 --> 01:00:18.920]  под g++
[01:00:18.920 --> 01:00:20.920]  а
[01:00:20.920 --> 01:00:22.920]  это
[01:00:22.920 --> 01:00:24.920]  не работает по той же причине что и раньше
[01:00:24.920 --> 01:00:26.920]  но не
[01:00:26.920 --> 01:00:28.920]  из-за того что я написал
[01:00:28.920 --> 01:00:30.920]  смотрите у меня виртуальная функция f
[01:00:30.920 --> 01:00:32.920]  а override ее констэкспорт
[01:00:32.920 --> 01:00:34.920]  функция то есть
[01:00:34.920 --> 01:00:36.920]  исходная функция была не констэкспорт
[01:00:36.920 --> 01:00:38.920]  а эта функция была констэкспорт
[01:00:38.920 --> 01:00:40.920]  функция
[01:00:40.920 --> 01:00:42.920]  которая override
[01:00:42.920 --> 01:00:44.920]  та которую она override
[01:00:44.920 --> 01:00:46.920]  не констэкспорт и это ничему не мешает
[01:00:46.920 --> 01:00:48.920]  просто в компайл тайме
[01:00:48.920 --> 01:00:50.920]  если дойдет дело до вызова f
[01:00:50.920 --> 01:00:52.920]  и он поймет что нужно выбирать эту f
[01:00:52.920 --> 01:00:54.920]  то будет ce потому что мы вызвали
[01:00:54.920 --> 01:00:56.920]  не констэкспорт версию
[01:00:56.920 --> 01:00:58.920]  а если мы попадем
[01:00:58.920 --> 01:01:00.920]  в нужную версию
[01:01:00.920 --> 01:01:02.920]  если динамический полиморфизм
[01:01:02.920 --> 01:01:04.920]  в компайл тайме поймет что
[01:01:04.920 --> 01:01:06.920]  мы попали в констэкспорт версию
[01:01:06.920 --> 01:01:08.920]  то она вызовется успешно
[01:01:10.920 --> 01:01:12.920]  ну соответственно можно делать
[01:01:12.920 --> 01:01:14.920]  динамик каст в компайл тайме
[01:01:14.920 --> 01:01:16.920]  теперь
[01:01:16.920 --> 01:01:18.920]  констэкспорт функция
[01:01:18.920 --> 01:01:20.920]  ну
[01:01:20.920 --> 01:01:22.920]  ну я наверное не буду
[01:01:22.920 --> 01:01:24.920]  демонстрировать ну в общем
[01:01:24.920 --> 01:01:26.920]  можно вот
[01:01:26.920 --> 01:01:28.920]  вот можно почитать статью тут у меня есть
[01:01:28.920 --> 01:01:30.920]  я тут заготовил несколько
[01:01:34.920 --> 01:01:36.920]  ну вот есть статья
[01:01:36.920 --> 01:01:38.920]  про то как
[01:01:38.920 --> 01:01:40.920]  а
[01:01:40.920 --> 01:01:42.920]  значит что
[01:01:42.920 --> 01:01:44.920]  решили в c4s20
[01:01:44.920 --> 01:01:46.920]  добавить и
[01:01:46.920 --> 01:01:48.920]  здесь есть
[01:01:48.920 --> 01:01:50.920]  даже некоторые практически
[01:01:50.920 --> 01:01:52.920]  пример я его даже
[01:01:52.920 --> 01:01:54.920]  скопипастил
[01:01:54.920 --> 01:01:56.920]  я даже открыл blackbolt
[01:01:56.920 --> 01:01:58.920]  вот здесь есть
[01:01:58.920 --> 01:02:00.920]  очень классный
[01:02:00.920 --> 01:02:02.920]  практически полезный пример
[01:02:02.920 --> 01:02:04.920]  использования констэкспор
[01:02:04.920 --> 01:02:06.920]  версию функций
[01:02:06.920 --> 01:02:08.920]  а именно задача парсинга
[01:02:08.920 --> 01:02:10.920]  выражений
[01:02:10.920 --> 01:02:12.920]  вот в такой форме
[01:02:14.920 --> 01:02:16.920]  значит мы берем констэкспорт
[01:02:16.920 --> 01:02:18.920]  выражение
[01:02:18.920 --> 01:02:20.920]  строку
[01:02:20.920 --> 01:02:22.920]  и статик ассерт
[01:02:22.920 --> 01:02:24.920]  что ее значение это выражение
[01:02:24.920 --> 01:02:26.920]  вот такое
[01:02:26.920 --> 01:02:28.920]  а внутри тут парсер
[01:02:28.920 --> 01:02:30.920]  но парсер он устроен
[01:02:30.920 --> 01:02:32.920]  он использует виртуальные функции в своей реализации
[01:02:32.920 --> 01:02:34.920]  то есть что у нас есть
[01:02:40.920 --> 01:02:42.920]  ну мы типа разбиваем выражение
[01:02:42.920 --> 01:02:44.920]  на ноды
[01:02:44.920 --> 01:02:46.920]  да у нас есть нода
[01:02:46.920 --> 01:02:48.920]  просто int у нас есть
[01:02:48.920 --> 01:02:50.920]  нода сложения
[01:02:50.920 --> 01:02:52.920]  у нас есть нода умножения
[01:02:52.920 --> 01:02:54.920]  и мы значит
[01:02:54.920 --> 01:02:56.920]  вызываем эволуэйт
[01:02:56.920 --> 01:02:58.920]  от ноды
[01:02:58.920 --> 01:03:00.920]  ну в случае умножения
[01:03:00.920 --> 01:03:02.920]  у нас получается что мы оцениваем левое
[01:03:02.920 --> 01:03:04.920]  значение левого и значение правого
[01:03:04.920 --> 01:03:06.920]  и перемножаем в случае сложения
[01:03:06.920 --> 01:03:08.920]  делаем вот так
[01:03:08.920 --> 01:03:10.920]  в случае просто числа
[01:03:10.920 --> 01:03:12.920]  просто возвращаем это число
[01:03:12.920 --> 01:03:14.920]  ну и дальше нам нужно просто научиться
[01:03:14.920 --> 01:03:16.920]  делать парс
[01:03:16.920 --> 01:03:18.920]  мы распарсили либо
[01:03:18.920 --> 01:03:20.920]  число либо терм
[01:03:20.920 --> 01:03:22.920]  либо выражение
[01:03:22.920 --> 01:03:24.920]  выражение
[01:03:24.920 --> 01:03:26.920]  эээ
[01:03:26.920 --> 01:03:28.920]  ну и вот
[01:03:28.920 --> 01:03:30.920]  в итоге это все компилируется
[01:03:30.920 --> 01:03:32.920]  и работает
[01:03:32.920 --> 01:03:34.920]  по константной ссылке
[01:03:34.920 --> 01:03:36.920]  агументы принимаются
[01:03:36.920 --> 01:03:38.920]  по константной
[01:03:38.920 --> 01:03:40.920]  час червь
[01:03:40.920 --> 01:03:42.920]  по
[01:03:42.920 --> 01:03:44.920]  по ссылке на константные указатели
[01:03:44.920 --> 01:03:46.920]  мы принимаем здесь агументы
[01:03:48.920 --> 01:03:50.920]  не такой код станд
[01:03:50.920 --> 01:03:52.920]  но вот
[01:03:52.920 --> 01:03:54.920]  здесь правда
[01:03:54.920 --> 01:03:56.920]  гцц
[01:03:56.920 --> 01:03:58.920]  гцц 12
[01:03:58.920 --> 01:04:00.920]  не справляется
[01:04:00.920 --> 01:04:02.920]  только силенк справляется
[01:04:02.920 --> 01:04:04.920]  ну видимо поддержка
[01:04:04.920 --> 01:04:06.920]  virtual constexr функции
[01:04:06.920 --> 01:04:08.920]  в гцц еще плохо сделано
[01:04:08.920 --> 01:04:10.920]  то есть это есть в
[01:04:10.920 --> 01:04:12.920]  ну вот силенк 13
[01:04:12.920 --> 01:04:14.920]  компилирует спокойно
[01:04:14.920 --> 01:04:16.920]  и вся программа состоит просто
[01:04:16.920 --> 01:04:18.920]  из ничего
[01:04:18.920 --> 01:04:20.920]  программы пустой по сути
[01:04:22.920 --> 01:04:24.920]  но все сделано в compile timing
[01:04:26.920 --> 01:04:28.920]  вот все скомпилировалось
[01:04:28.920 --> 01:04:30.920]  гцц не умеет почему-то ничего
[01:04:30.920 --> 01:04:32.920]  то есть это есть в стандарте
[01:04:32.920 --> 01:04:34.920]  да да да
[01:04:34.920 --> 01:04:36.920]  allowing virtual function
[01:04:36.920 --> 01:04:38.920]  holds in constant expressions
[01:04:38.920 --> 01:04:40.920]  пропузал который собственно
[01:04:40.920 --> 01:04:42.920]  был в стандарт добавлен
[01:04:44.920 --> 01:04:46.920]  окей давайте
[01:04:46.920 --> 01:04:48.920]  расскажу быстренько еще про пару
[01:04:48.920 --> 01:04:50.920]  вещей связанных с compile timing
[01:04:50.920 --> 01:04:52.920]  функциями
[01:04:52.920 --> 01:04:54.920]  и видимо на сегодня мы закончим
[01:04:54.920 --> 01:04:56.920]  ну а завтра я расскажу уж совсем дичь
[01:04:56.920 --> 01:04:58.920]  вот
[01:04:58.920 --> 01:05:00.920]  обязательно приходите
[01:05:04.920 --> 01:05:06.920]  еще пара
[01:05:06.920 --> 01:05:08.920]  вещей
[01:05:08.920 --> 01:05:10.920]  связанных с концепцией
[01:05:10.920 --> 01:05:12.920]  функциями
[01:05:12.920 --> 01:05:14.920]  это
[01:05:14.920 --> 01:05:16.920]  ну во первых
[01:05:16.920 --> 01:05:18.920]  есть такая замечательная функция
[01:05:18.920 --> 01:05:20.920]  из constant evaluator
[01:05:22.920 --> 01:05:24.920]  она позволяет вам проверить
[01:05:24.920 --> 01:05:26.920]  вы сейчас в compile timing находитесь или нет
[01:05:28.920 --> 01:05:30.920]  ну например
[01:05:30.920 --> 01:05:32.920]  вот вы пишете какую-то функцию
[01:05:32.920 --> 01:05:34.920]  возведение в степень
[01:05:36.920 --> 01:05:38.920]  вы хотите по-разному действовать
[01:05:38.920 --> 01:05:40.920]  в зависимости от того
[01:05:40.920 --> 01:05:42.920]  вы сейчас в compile timing вычисляетесь
[01:05:42.920 --> 01:05:44.920]  просто не все вещи могут быть в compile timing
[01:05:44.920 --> 01:05:46.920]  например сделаны
[01:05:46.920 --> 01:05:48.920]  например в runtime вы можете вызвать
[01:05:48.920 --> 01:05:50.920]  какую-то более
[01:05:50.920 --> 01:05:52.920]  умную функцию
[01:05:52.920 --> 01:05:54.920]  которая там делает что-то что в compile timing запрещено
[01:05:54.920 --> 01:05:56.920]  не знаю
[01:05:56.920 --> 01:05:58.920]  или вы можете
[01:05:58.920 --> 01:06:00.920]  в runtime
[01:06:00.920 --> 01:06:02.920]  просто
[01:06:02.920 --> 01:06:04.920]  если вы понимаете что у вас слишком
[01:06:04.920 --> 01:06:06.920]  долгие вычисления вы можете там
[01:06:06.920 --> 01:06:08.920]  на runtime отложить сказать что
[01:06:08.920 --> 01:06:10.920]  если меня вызвали от большого
[01:06:10.920 --> 01:06:12.920]  числа, а я в compile timing
[01:06:12.920 --> 01:06:14.920]  то я не хочу вычислять
[01:06:14.920 --> 01:06:16.920]  это скажу ошибку
[01:06:16.920 --> 01:06:18.920]  а в runtime я вычислюсь
[01:06:18.920 --> 01:06:20.920]  если так получилось
[01:06:20.920 --> 01:06:22.920]  вы проверяете из constant evaluator
[01:06:22.920 --> 01:06:24.920]  эта функция реализована компилятором
[01:06:24.920 --> 01:06:26.920]  на C++ ей не напишешь конечно
[01:06:26.920 --> 01:06:28.920]  это внутренняя функция
[01:06:28.920 --> 01:06:30.920]  раньше она была компилятором
[01:06:30.920 --> 01:06:32.920]  то есть нужно было подчеркнуть
[01:06:32.920 --> 01:06:34.920]  что-то там
[01:06:34.920 --> 01:06:36.920]  в C++ 20 я добавил стандарт
[01:06:36.920 --> 01:06:38.920]  то есть вы можете использовать разные алгоритмы
[01:06:38.920 --> 01:06:40.920]  в зависимости от того
[01:06:40.920 --> 01:06:42.920]  по разному действовать изнутри функции
[01:06:42.920 --> 01:06:44.920]  понимая вы сейчас вызвались из compile timing
[01:06:44.920 --> 01:06:46.920]  или не из compile timing
[01:06:46.920 --> 01:06:48.920]  кстати
[01:06:50.920 --> 01:06:52.920]  обратите внимание
[01:06:52.920 --> 01:06:54.920]  типичная
[01:06:56.920 --> 01:06:58.920]  ошибка
[01:06:58.920 --> 01:07:00.920]  которая бывает при использовании этой функции
[01:07:00.920 --> 01:07:02.920]  это написать if const export
[01:07:04.920 --> 01:07:06.920]  у нас же есть if const export
[01:07:06.920 --> 01:07:08.920]  который проверяет в compile timing
[01:07:08.920 --> 01:07:10.920]  верно или нет
[01:07:10.920 --> 01:07:12.920]  но дело в том
[01:07:12.920 --> 01:07:14.920]  что как раз когда вы хотите if
[01:07:14.920 --> 01:07:16.920]  из const evaluator
[01:07:16.920 --> 01:07:18.920]  вы не должны писать const export
[01:07:18.920 --> 01:07:20.920]  после if
[01:07:20.920 --> 01:07:22.920]  потому что это автоматически сделает условие true
[01:07:22.920 --> 01:07:24.920]  потому что если вы написали их const export
[01:07:24.920 --> 01:07:26.920]  то то что под if в скобочках
[01:07:26.920 --> 01:07:28.920]  оно автоматически const evaluator
[01:07:28.920 --> 01:07:30.920]  и вы получите true
[01:07:30.920 --> 01:07:32.920]  поэтому если вы хотите проверять
[01:07:32.920 --> 01:07:34.920]  const evaluator
[01:07:34.920 --> 01:07:36.920]  вот так написать не надо
[01:07:38.920 --> 01:07:40.920]  и эта функция
[01:07:40.920 --> 01:07:42.920]  в C++ 23
[01:07:44.920 --> 01:07:46.920]  будет устаревшей
[01:07:46.920 --> 01:07:48.920]  скорее всего
[01:07:48.920 --> 01:07:50.920]  потому что ее заменят
[01:07:50.920 --> 01:07:52.920]  другим
[01:07:52.920 --> 01:07:54.920]  другой конструкцией
[01:07:54.920 --> 01:07:56.920]  и в const evaluator
[01:08:04.920 --> 01:08:06.920]  что
[01:08:06.920 --> 01:08:08.920]  ну
[01:08:08.920 --> 01:08:10.920]  точнее нет
[01:08:10.920 --> 01:08:12.920]  if const evaluator будет не устаревшей
[01:08:12.920 --> 01:08:14.920]  потому что она просто будет реализована
[01:08:14.920 --> 01:08:16.920]  через if const evaluator
[01:08:16.920 --> 01:08:18.920]  но вместо if const evaluator можно будет писать if const evaluator
[01:08:18.920 --> 01:08:20.920]  в C++ 23
[01:08:20.920 --> 01:08:22.920]  if const evaluator
[01:08:22.920 --> 01:08:24.920]  уже не нужен круглых скобочек
[01:08:24.920 --> 01:08:26.920]  просто фигурная скобочка
[01:08:26.920 --> 01:08:28.920]  это вот укивалент на проверке того
[01:08:28.920 --> 01:08:30.920]  if compile timing сейчас или нет
[01:08:30.920 --> 01:08:32.920]  const evaluator это новое ключевое слово
[01:08:34.920 --> 01:08:36.920]  вот
[01:08:40.920 --> 01:08:42.920]  ок
[01:08:42.920 --> 01:08:44.920]  ну и
[01:08:44.920 --> 01:08:46.920]  последнее
[01:08:46.920 --> 01:08:48.920]  видимо, что я на сегодня расскажу
[01:08:48.920 --> 01:08:50.920]  но под это я
[01:08:50.920 --> 01:08:52.920]  таки заведу отдельный пункт
[01:08:54.920 --> 01:08:56.920]  это вот как раз
[01:08:56.920 --> 01:08:58.920]  слова const evaluator
[01:08:58.920 --> 01:09:00.920]  const init
[01:09:04.920 --> 01:09:06.920]  давайте я скажу
[01:09:06.920 --> 01:09:08.920]  так
[01:09:08.920 --> 01:09:10.920]  const initialization
[01:09:10.920 --> 01:09:12.920]  const evaluator
[01:09:12.920 --> 01:09:14.920]  const init
[01:09:14.920 --> 01:09:16.920]  а
[01:09:16.920 --> 01:09:18.920]  что
[01:09:20.920 --> 01:09:22.920]  такое
[01:09:22.920 --> 01:09:24.920]  const initialization
[01:09:24.920 --> 01:09:26.920]  ну вот тут я наверное опять обращусь
[01:09:26.920 --> 01:09:28.920]  к статье, но он другой
[01:09:28.920 --> 01:09:30.920]  вот к этой
[01:09:30.920 --> 01:09:32.920]  мы с вами кажется
[01:09:32.920 --> 01:09:34.920]  мы когда-нибудь говорили до сих пор про то
[01:09:34.920 --> 01:09:36.920]  как вообще
[01:09:36.920 --> 01:09:38.920]  инициализируются переменные
[01:09:38.920 --> 01:09:40.920]  в какой момент и кем
[01:09:40.920 --> 01:09:42.920]  но вот
[01:09:42.920 --> 01:09:44.920]  когда у вас есть статические переменные
[01:09:46.920 --> 01:09:48.920]  или когда у вас есть константы
[01:09:48.920 --> 01:09:50.920]  есть
[01:09:50.920 --> 01:09:52.920]  два варианта
[01:09:52.920 --> 01:09:54.920]  они могут быть инициализированы в compile time или run time
[01:09:54.920 --> 01:09:56.920]  то есть константы вот бывают
[01:09:56.920 --> 01:09:58.920]  в compile time вычислимые и те которые уже
[01:09:58.920 --> 01:10:00.920]  после запуска программы вычисляются их значения
[01:10:00.920 --> 01:10:02.920]  вот
[01:10:02.920 --> 01:10:04.920]  соответственно
[01:10:04.920 --> 01:10:06.920]  если у вас
[01:10:06.920 --> 01:10:08.920]  какая-то переменная
[01:10:08.920 --> 01:10:10.920]  объявлена
[01:10:10.920 --> 01:10:12.920]  ну скажем
[01:10:14.920 --> 01:10:16.920]  да даже если она объявлена
[01:10:16.920 --> 01:10:18.920]  const export
[01:10:18.920 --> 01:10:20.920]  сейчас
[01:10:20.920 --> 01:10:22.920]  если она объявлена const export
[01:10:22.920 --> 01:10:24.920]  то наверное это все-таки означает что она должна быть
[01:10:24.920 --> 01:10:26.920]  вычислено
[01:10:26.920 --> 01:10:28.920]  ва
[01:10:28.920 --> 01:10:30.920]  в compile time
[01:10:30.920 --> 01:10:32.920]  если у вас какая-то переменная объявлена
[01:10:32.920 --> 01:10:34.920]  как const
[01:10:34.920 --> 01:10:36.920]  ну вот это тот пример который я говорил в самом начале
[01:10:36.920 --> 01:10:38.920]  то это еще не гарантирует вам
[01:10:38.920 --> 01:10:40.920]  что ее значение будет вычислено
[01:10:40.920 --> 01:10:42.920]  и она будет проинциализирована в compile time
[01:10:42.920 --> 01:10:44.920]  const export вам как раз это гарантирует
[01:10:46.920 --> 01:10:48.920]  вот
[01:10:48.920 --> 01:10:50.920]  но
[01:10:52.920 --> 01:10:54.920]  вы иногда могли бы хотеть
[01:10:54.920 --> 01:10:56.920]  например
[01:10:56.920 --> 01:10:58.920]  чтобы у вас
[01:10:58.920 --> 01:11:00.920]  переменная была гарантирована
[01:11:00.920 --> 01:11:02.920]  вычислено в compile time
[01:11:02.920 --> 01:11:04.920]  но не была константой
[01:11:06.920 --> 01:11:08.920]  вот для такого есть
[01:11:08.920 --> 01:11:10.920]  слово const finite
[01:11:10.920 --> 01:11:12.920]  сейчас
[01:11:12.920 --> 01:11:14.920]  ну то есть вот что мне надо
[01:11:14.920 --> 01:11:16.920]  вот у меня есть compile time
[01:11:16.920 --> 01:11:18.920]  у меня есть переменная
[01:11:18.920 --> 01:11:20.920]  которую я хочу сделать константой
[01:11:22.920 --> 01:11:24.920]  но при этом не гарантирую что значение этой константы
[01:11:24.920 --> 01:11:26.920]  будет положено в бинарник
[01:11:26.920 --> 01:11:28.920]  до запуска программы
[01:11:28.920 --> 01:11:30.920]  тогда я просто пишу const int
[01:11:30.920 --> 01:11:32.920]  если я говорю const export int
[01:11:32.920 --> 01:11:34.920]  я тем самым себя гарантирую что вот эта штука
[01:11:34.920 --> 01:11:36.920]  будет вычислена в compile time и уже
[01:11:36.920 --> 01:11:38.920]  на момент запуска будет известно значение этой штуки
[01:11:38.920 --> 01:11:40.920]  но она при этом будет константой
[01:11:40.920 --> 01:11:42.920]  а что если я хочу сделать
[01:11:42.920 --> 01:11:44.920]  не константу
[01:11:44.920 --> 01:11:46.920]  не константную переменную
[01:11:46.920 --> 01:11:48.920]  но тем не менее гарантировать
[01:11:48.920 --> 01:11:50.920]  что значение будет вычислено
[01:11:50.920 --> 01:11:52.920]  в compile time
[01:11:52.920 --> 01:11:54.920]  ну тогда у меня есть ключевое слово const int
[01:11:54.920 --> 01:11:56.920]  оно появилось
[01:11:56.920 --> 01:11:58.920]  тоже c++20
[01:11:58.920 --> 01:12:00.920]  const int int c
[01:12:00.920 --> 01:12:02.920]  равно
[01:12:02.920 --> 01:12:04.920]  тест от одного
[01:12:06.920 --> 01:12:08.920]  вот сейчас будет
[01:12:08.920 --> 01:12:10.920]  ce скорее всего, потому что
[01:12:10.920 --> 01:12:12.920]  статика cert
[01:12:12.920 --> 01:12:14.920]  уже не работает, потому что это
[01:12:14.920 --> 01:12:16.920]  не compile time константа
[01:12:16.920 --> 01:12:18.920]  я лишь гарантировал что
[01:12:18.920 --> 01:12:20.920]  она инициализируется в compile time
[01:12:22.920 --> 01:12:24.920]  но
[01:12:24.920 --> 01:12:26.920]  менять ее
[01:12:26.920 --> 01:12:28.920]  после этого я могу
[01:12:40.920 --> 01:12:42.920]  вот
[01:12:42.920 --> 01:12:44.920]  соответственно
[01:12:44.920 --> 01:12:46.920]  если бы у меня была какая-нибудь константа
[01:12:46.920 --> 01:12:48.920]  времени конверяции
[01:12:48.920 --> 01:12:50.920]  типа
[01:12:50.920 --> 01:12:52.920]  не примитивного
[01:12:52.920 --> 01:12:54.920]  а какого-нибудь классового
[01:12:54.920 --> 01:12:56.920]  то это бы означало, что чтобы ее
[01:12:56.920 --> 01:12:58.920]  инициализировать в compile time
[01:12:58.920 --> 01:13:00.920]  мне нужно чтобы у него был const export конструктор
[01:13:00.920 --> 01:13:02.920]  и вот эта причина, по которой конструкторы
[01:13:02.920 --> 01:13:04.920]  всех классов стали const export
[01:13:04.920 --> 01:13:06.920]  довольно давно
[01:13:06.920 --> 01:13:08.920]  ну там, если отбросить вот эти истории
[01:13:08.920 --> 01:13:10.920]  с выделением динамической памяти
[01:13:10.920 --> 01:13:12.920]  конструкторы
[01:13:12.920 --> 01:13:14.920]  некоторых классов, которые казалось бы
[01:13:14.920 --> 01:13:16.920]  никакой динамической памяти не выделяют
[01:13:16.920 --> 01:13:18.920]  стали const export
[01:13:18.920 --> 01:13:20.920]  еще до того, как разрешили
[01:13:20.920 --> 01:13:22.920]  много чего делать const export
[01:13:22.920 --> 01:13:24.920]  просто потому что вы иногда бы хотели, чтобы у вас
[01:13:24.920 --> 01:13:26.920]  константы времени
[01:13:26.920 --> 01:13:28.920]  конпиляции можно было создавать вот таких
[01:13:28.920 --> 01:13:30.920]  типов, чтобы они были инициализированы
[01:13:30.920 --> 01:13:32.920]  уже в compile time, статическая инициализация
[01:13:32.920 --> 01:13:34.920]  что бы происходило
[01:13:34.920 --> 01:13:36.920]  ну а вот это вот с const init
[01:13:36.920 --> 01:13:38.920]  примерно
[01:13:38.920 --> 01:13:40.920]  то есть вот это например не сработает
[01:13:40.920 --> 01:13:42.920]  потому что вот это
[01:13:42.920 --> 01:13:44.920]  не const export функция
[01:13:48.920 --> 01:13:50.920]  ну
[01:13:50.920 --> 01:13:52.920]  динамическая инициализация
[01:13:52.920 --> 01:13:54.920]  и
[01:13:54.920 --> 01:13:56.920]  order fiasco это
[01:13:56.920 --> 01:13:58.920]  это уже
[01:13:58.920 --> 01:14:00.920]  другая история
[01:14:00.920 --> 01:14:02.920]  я про это не буду говорить
[01:14:02.920 --> 01:14:04.920]  вот, а
[01:14:04.920 --> 01:14:06.920]  последнее слово, про которое я хотел сказать
[01:14:06.920 --> 01:14:08.920]  это const eval
[01:14:08.920 --> 01:14:10.920]  но я про него уже очень скользь упомянул
[01:14:10.920 --> 01:14:12.920]  там особо говорить нечего
[01:14:12.920 --> 01:14:14.920]  просто скажу, что const eval
[01:14:14.920 --> 01:14:16.920]  то
[01:14:16.920 --> 01:14:18.920]  это
[01:14:18.920 --> 01:14:20.920]  способ гарантировать
[01:14:20.920 --> 01:14:22.920]  что функция обязательно в compile time вычисляется
[01:14:22.920 --> 01:14:24.920]  вот у нас
[01:14:24.920 --> 01:14:26.920]  снова const export
[01:14:26.920 --> 01:14:28.920]  а
[01:14:28.920 --> 01:14:30.920]  как я уже неоднократно
[01:14:30.920 --> 01:14:32.920]  повторял, оно означает, что
[01:14:32.920 --> 01:14:34.920]  функция может быть вызвана в compile time
[01:14:34.920 --> 01:14:36.920]  но это не мешает ее и в run time тоже вызвать
[01:14:38.920 --> 01:14:40.920]  вот если вы хотите, чтобы функцию только в compile time
[01:14:40.920 --> 01:14:42.920]  можно было вызывать, то слово const eval
[01:14:42.920 --> 01:14:44.920]  то есть const eval функция
[01:14:44.920 --> 01:14:46.920]  вам выдаст ошибку в компиляции, если
[01:14:46.920 --> 01:14:48.920]  вы попробуете из run time ее вызвать
[01:14:48.920 --> 01:14:50.920]  а что значит из run time?
[01:14:50.920 --> 01:14:52.920]  ну не в compile time
[01:14:52.920 --> 01:14:54.920]  не в compile time контексте
[01:14:54.920 --> 01:14:56.920]  то есть вот если
[01:14:56.920 --> 01:14:58.920]  вы вызываете в контексте, который const eval
[01:14:58.920 --> 01:15:00.920]  то нормально
[01:15:00.920 --> 01:15:02.920]  а мучать const export int
[01:15:02.920 --> 01:15:04.920]  обязательно равно быть в этой функции?
[01:15:04.920 --> 01:15:06.920]  конечно, потому что именно const export int
[01:15:06.920 --> 01:15:08.920]  что-то
[01:15:08.920 --> 01:15:10.920]  как раз и обязывает, что там compile time
[01:15:10.920 --> 01:15:12.920]  вычисляется
[01:15:12.920 --> 01:15:14.920]  когда ты идентифицируешь const export переменную
[01:15:14.920 --> 01:15:16.920]  это как раз случай, когда
[01:15:16.920 --> 01:15:18.920]  то, что справа
[01:15:18.920 --> 01:15:20.920]  должно быть в compile time вычислено
[01:15:20.920 --> 01:15:22.920]  и ты в compile time контексте находишься из const eval
[01:15:22.920 --> 01:15:24.920]  вот там const export
[01:15:24.920 --> 01:15:26.920]  функция будет
[01:15:26.920 --> 01:15:28.920]  const eval функция подойдет
[01:15:32.920 --> 01:15:34.920]  ну можно
[01:15:34.920 --> 01:15:36.920]  открыть, значит
[01:15:36.920 --> 01:15:38.920]  подемонстрировать
[01:15:38.920 --> 01:15:40.920]  const eval
[01:15:44.920 --> 01:15:46.920]  const eval specify
[01:15:46.920 --> 01:15:48.920]  и это все появилось
[01:15:48.920 --> 01:15:50.920]  тоже начиная с secret 20
