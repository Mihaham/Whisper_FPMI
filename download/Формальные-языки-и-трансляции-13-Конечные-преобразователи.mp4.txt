[00:00.000 --> 00:08.320]  Всем доброго дня, мы уже, я не знаю, раньше у нас лекции начинались в 11.40,
[00:08.320 --> 00:15.920]  теперь у нас начинаются лекции аж в целых 11.55. Да, собственно у нас есть сейчас внезапно час
[00:15.920 --> 00:20.200]  пять минут, чтобы начать новую тему, значит тут было голосование, по которому выяснили,
[00:20.200 --> 00:25.320]  что люди предпочитают новую тему, вот, вместо того, чтобы разбирать линейность для алгоритма.
[00:25.320 --> 00:33.000]  Нет, в нем будем разбираться на следующих лекциях, вот. Решили сменить немного тему,
[00:33.000 --> 00:39.160]  чтобы немножко было попроще и контролем было понимание, что происходит. Значит,
[00:39.160 --> 00:44.400]  наша сегодняшняя тема это, конечно, преобразователи. Значит, смотрите, какая у нас мотивация с вами,
[00:44.400 --> 00:50.480]  мы умеем с вами уже распознавать какие-то слова, да, а вторых, мы можем ли мы их каким-то образом
[00:50.480 --> 00:56.480]  трансформировать, то есть чтобы у нас что-то приходило на вход, ну и допустим мы что-то получали
[00:56.480 --> 01:03.400]  на выход. И для этого давайте сначала вспомним, какая у нас таблица, есть точнее те абстракции,
[01:03.400 --> 01:08.240]  которые мы с вами уже разбирали, которые именно компьютерная абстракция. Вот давайте начнем с
[01:08.240 --> 01:17.320]  автомата. Что у нас с вами представляет собой автомат? Что он на вход принимает? На вход он
[01:17.320 --> 01:22.280]  принимает слово. Есть ли у него какая-то дополнительная структура данных, которые мы пользуемся?
[01:22.280 --> 01:34.880]  Ничего там нету. Да, ну собственно, автомат сам по себе. Что он на выход дает? Да, бит 0 или единичку.
[01:34.880 --> 01:44.040]  Какая была абстракция следующей, которую мы с вами разбирали? Не-не, регулярная это эквалент
[01:44.040 --> 01:49.800]  автомата с точки зрения распознавания. Просто регулярка обычно для нас создана. Да,
[01:49.800 --> 01:57.200]  mp-автомат. Что он на вход принимает? Ага, есть ли у него какая-то дополнительная структура? Да,
[01:57.200 --> 02:04.760]  а на выход что он на... Да нет, ну то есть тоже бит. Как вы думаете, вот следующая абстракция,
[02:04.760 --> 02:11.160]  которую мы с вами будем разбирать, которая является конечным преобразователем, какую структуру будет
[02:11.160 --> 02:22.240]  иметь? Ну тоже автомат. На вход, как вы думаете, что он будет принимать? Слово. На выходе? На выходе
[02:22.240 --> 02:27.440]  она будет принимать слово. А как вы думаете, дополнительная структура у нас будет в ней? Нет.
[02:27.440 --> 02:36.520]  Мы просто пытаемся понять, чего не хватает. То есть смотрите, у нас было на входе слово всегда,
[02:36.520 --> 02:42.360]  и раньше на выходе мы давали ответ только да или нет. Хочется вместо выхода да или нет давать
[02:42.360 --> 02:49.920]  на выход слово, то есть преобразовывать наше входное слово. То есть мы по факту, если раньше занимались
[02:49.920 --> 02:58.640]  просто принадлежностью слова и языка, да это всегда так возникает, то мы можем изучать такой объект
[02:58.640 --> 03:04.920]  как конечный преобразователь kp-тель. Почему тель? Потому что есть такой объект как конечное
[03:04.920 --> 03:12.440]  преобразование e. А конечное преобразование мы с вами будем обозначать как kp. Потому что
[03:12.440 --> 03:24.600]  конечное преобразование каждый раз писать достаточно тяжело. Значит смотрите, вот все вот эти вот разделы,
[03:24.600 --> 03:33.160]  которые у нас были, вот здесь вот мы с вами по факту определяли, так сказать, как это называется,
[03:33.160 --> 03:40.080]  лексический анализ проводили. В качестве AP автоматов, это у нас в контексте свободной
[03:40.080 --> 03:47.640]  грамматики, мы с вами уже определяли синтоксический анализ. А вот конечные преобразователи будут делать
[03:47.640 --> 03:53.760]  кое-какую другую вещь. Какие разделы русского языка вы знаете? Вообще какие разделы лингвистики вы знаете?
[03:53.760 --> 04:09.160]  Диалектология близко, кстати. Арфаэпия, ну если вам нужно по слову написать транскрипцию, то да. Это
[04:09.160 --> 04:22.440]  морфология. Чем занимается морфология? Ну да, мы можем преобразовать части речи из одной
[04:23.320 --> 04:35.840]  из одного подраздела в другое. Например, склонение и спряжение. Столовая, нет чего столовой. Да,
[04:35.840 --> 04:41.000]  это существительное. Но суть в том, что мы можем сказать, у нас есть, допустим, морфологический разбор слова
[04:41.000 --> 04:58.640]  столовая, нет кого столовой. Значит, что у нас произошло при том, что у нас существительное
[04:58.640 --> 05:07.760]  поменялось на родительный падеж? Да, смотрите, у нас с вами последние две буквы ая заменялись
[05:07.760 --> 05:16.640]  на последние две буквы ой. И кажется, что такое можно сделать конструкциями, похожими на конечный
[05:16.640 --> 05:26.800]  автомат. Вот, это вот мельта мотивация, которую мы с вами будем рассматривать. Что бы вы понимали,
[05:26.800 --> 05:32.680]  где это еще работает, есть такой партия, что в питоне, кстати, частенько используется. Называется
[05:32.680 --> 05:45.720]  primorthy2. Потому что вторая версия, во-первых. Вы не поверите, при помощи этого как раз пакеты
[05:45.720 --> 05:52.880]  генерируются условия контрольные? То есть вы пишете, допустим, одно число, дальше вы даете на вход два,
[05:52.880 --> 06:06.080]  оно по ходу два вы генерирует слово числа, два числа. Да, да, да. Да, эта библиотека написана русскими
[06:06.080 --> 06:14.760]  лидиямия для морфологических изменений. Такая удобная достаточно вещь, она правда основана
[06:14.760 --> 06:20.640]  в большей части на словарях и на автоматах, но в целом она помогает вот какие-то простые конструкции
[06:20.640 --> 06:45.720]  морфологически генерировать. Вот так пишется.
[06:50.640 --> 07:05.360]  Morphology также пишется, а slowmorph. Конечно, вы не поверите, когда я поступил в УС, он только
[07:05.360 --> 07:16.000]  как раз только вышел. Это было в тринадцатом году. Да, мы тут как раз коллегами смотрели,
[07:16.000 --> 07:36.360]  что Python 3.7 уже скоро будет. Да, да, да, можно. Ладно, давайте прийдем все-таки к теме, то есть вот
[07:36.360 --> 07:43.240]  эта вот мотивация наша цель понимать, что умеет конструкция, связанная с преобразованием автоматов,
[07:43.240 --> 07:49.400]  вот, который умеет на входе принимать слово, на выходе тоже отдавать какое-то слово. Значит,
[07:49.400 --> 08:06.200]  смотрите, давайте введем первое определение. Конечный преобразователь, он же у нас будет
[08:06.200 --> 08:19.520]  называться теперь дальнейшим каптилем. Это объект вида m, q, sigma, gamma, delta, q0, f. Опять же,
[08:19.520 --> 08:27.480]  подчеркну, что все множества конечные у нас здесь такие, что, значит, q это состояние,
[08:27.480 --> 08:43.960]  sigma это входной алфавит. Как вы думаете, гамма это что такое? Да, гамма это выходной алфавит.
[08:43.960 --> 08:54.240]  Как вы думаете, это под множество, какого множества?
[08:54.240 --> 09:06.440]  Q на sigma со звездой мы переходим, проходим по переходу,
[09:06.440 --> 09:26.120]  считываем с него какое-то слово, на выход пишем слово. Так, q0 где лежит? Q, да, в стартовом состоянии,
[09:26.120 --> 09:47.000]  а f это что у нас с вами такое? И получается, как мы будем с вами писать переходы? Переходы
[09:47.000 --> 09:58.520]  обычно пишутся следующим образом. Как у нас было, у принадлежит sigma со звездой,
[09:58.520 --> 10:05.840]  ну и принадлежит гамма со звездой. И переходы можно писать двумя способами. Какой вам удобнее,
[10:05.840 --> 10:11.160]  что-то можете использовать. Первый способ писать переходы, это вот таким образом,
[10:11.160 --> 10:18.040]  как мы писали переходы по автоматике. Ну иногда, когда хочется прямо показать,
[10:18.040 --> 10:23.400]  что это конечный преобразователь, иногда пишут следующий. На входе пишется слово u,
[10:23.400 --> 10:28.600]  на выход пишется слово v. То есть это просто два эквалентных обозначения.
[10:28.600 --> 10:48.080]  Ну то есть мы записываем тоже по квадрату? Да-да-да. Ну вот регулярно там можно сделать,
[10:48.080 --> 11:02.320]  ну нет, такое мы не делаем. Да-да-да, то есть надо сначала обычнить приставку,
[11:02.320 --> 11:05.840]  возможно перейти в какие-то разные состояния, потом перейти в состояние,
[11:05.840 --> 11:10.640]  в которое мы будем распознавать корень, слово, а потом еще мы будем
[11:10.640 --> 11:14.720]  определенный набор состояний, которые будут распознавать суффикс. То есть мы читаем подряд.
[11:14.720 --> 11:28.400]  Без разницы. Мы уже поняли, что на самом деле только в получать какие-то свободные грамматики
[11:28.400 --> 11:35.080]  важно, чтобы сигма и гамма не пересекались, а здесь уже без разницы. Вот пример конечного
[11:35.080 --> 11:43.280]  преобразователя. Давайте поймем, какие слова он может распознать. А это что, их очень много здесь?
[11:43.280 --> 11:58.600]  Пара, вход, выход. Да, смотрите, любые слова, которые заканчиваются на а, и при этом смотрите,
[11:58.600 --> 12:06.120]  если последняя буква а, то она стирается. То есть это на самом деле, это конечный преобразователь,
[12:06.120 --> 12:11.160]  как ни странно, берет произвольное слово, и если у него последняя буква а, то он ее стирает.
[12:11.160 --> 12:23.800]  То есть это по факту у вас удаление окончания а, можно так сказать. Вот, то есть вот такой конечный
[12:23.800 --> 12:29.800]  преобразователь. Наверное, у вас уже были семинары по конечным преобразователям, были? Нет,
[12:29.800 --> 12:34.600]  у вас еще не было. Вот поэтому Дмитрий меня спрашивал. То есть у всех по-разному, у кого-то уже начались,
[12:34.600 --> 12:43.080]  у кого-то уже нет. У кого-то еще нет. Теперь давайте подумаем, как определить конфигурацию конечного
[12:43.080 --> 13:06.360]  преобразователя. Это пара, ой, тройка, Q, Q, V такие, что Q из Q, Q из сигната Q, V из гамма Q, V из гамма Q, V из гамма Q, V из гамма Q.
[13:06.600 --> 13:11.640]  Давайте подумаем, что хотелось бы сказать о отношении в выводимости.
[13:11.640 --> 13:19.880]  Да, это наименьшее рефлексивное и транспортированное отношение.
[13:19.880 --> 13:38.880]  Такое, смотрите, предположим, что у нас с вами есть переход Q1U переходит Q2V.
[13:38.880 --> 13:48.720]  Тогда давайте подумаем, что нам нужно сделать, чтобы корректно это все определить.
[13:48.720 --> 14:00.640]  Наверное, нам нужно для любого X сигма с звездой, для любого Y из гамма с звездой что-то написать.
[14:00.640 --> 14:02.640]  Что именно?
[14:02.640 --> 14:18.720]  Давайте абстрактный смысл. Значит Q это то, что мы с вами видим, осталось прочесть.
[14:18.720 --> 14:29.760]  А здесь вот это то, что у нас есть, это то, что мы уже записали.
[14:37.760 --> 14:41.760]  Я сейчас это еще раз на флаге покажу.
[14:41.760 --> 14:49.760]  То есть неформально. Находимся в состоянии Q, осталось прочесть слово U, на выход мы уже написали слово V.
[14:49.760 --> 14:54.800]  Тогда давайте поймем, как у нас подставляется конкурент.
[14:58.800 --> 15:08.800]  Да. У X есть слово Y. А здесь что у нас будет тогда? X, Y, V.
[15:11.760 --> 15:17.760]  То есть мы считываем с вами U, пишем V.
[15:17.760 --> 15:24.800]  И вот здесь важный тонкий момент. Раньше мы определяли принадлежные слова языка.
[15:30.800 --> 15:38.800]  Ну это рефлексивность. Транзитивность позволяет нам построить замыкание более чем за один переход.
[15:41.760 --> 15:52.800]  Теперь вопрос. Как вы думаете, такая конструкция может по одному входу делать несколько выходов?
[15:52.800 --> 16:00.800]  Конечно, может. Поэтому важно в данном случае сделать одно важное определение.
[16:00.800 --> 16:04.800]  Это коммерческое преобразование.
[16:11.760 --> 16:18.800]  Значит, это следующая вещь. Это мы будем обозначать 5.
[16:18.800 --> 16:28.800]  Это множество пар УВ таких, что существует завершающая Q.
[16:28.800 --> 16:34.800]  То есть Q0, Qo, мы получаем Qo.
[16:41.800 --> 16:48.800]  Вопрос на понимание гиперсийной математики, февральчитила, основного станка, бинатарики.
[16:48.800 --> 16:50.800]  Что это за объект?
[16:50.800 --> 16:52.800]  Это соответствие.
[16:58.800 --> 17:00.800]  Не отображение, не функция, а именно соответствие.
[17:00.800 --> 17:08.800]  То есть у нас для любого входа может не быть выходов, и для нового входа может быть сколько угодно.
[17:08.840 --> 17:15.840]  И как раз поэтому у нас есть понятие конечного преобразователя, есть понятие конечного преобразования.
[17:19.840 --> 17:27.840]  Конечное преобразование, мы будем говорить, что это соответственно которого существует конечный преобразователь, задающий эти пары слов.
[17:27.880 --> 17:33.880]  Хорошо.
[17:33.880 --> 17:41.880]  Так, значит конечное преобразование состоит из пар УВ, можно построить соответствие из УВ.
[17:41.880 --> 17:45.880]  Значит, мы понимаем с вами, что если у нас
[17:48.880 --> 17:52.880]  для любого У мощность в Qoq
[17:54.880 --> 17:56.880]  мы можем это написать вот так
[17:57.880 --> 18:01.880]  равной единице, то ψ это отображение.
[18:11.880 --> 18:15.880]  Кажется, здесь пока что ничего такого нет.
[18:15.880 --> 18:17.880]  А?
[18:19.880 --> 18:23.880]  Не, ну функция обычно в число отображает.
[18:23.880 --> 18:25.880]  Ну да.
[18:27.880 --> 18:32.840]  Конечное преобразование это соответствие из сигматов с vu в Гам Safety enable,
[18:32.840 --> 18:35.840]  для которого существует конечное преобразование.
[18:35.840 --> 18:38.840]  Мы можем, смотрите, задать конечное преобразование для фиксированного конечного преобразователя
[18:40.840 --> 18:44.840]  или мы можем определить, как некоторые отношения
[18:44.840 --> 18:50.840]  между некоторой соответствием из сигматов с vu к Гамma С certification,
[18:50.840 --> 18:52.840] หน доброго существует конечнее преобразователь,
[18:52.840 --> 18:56.840]  который его задает.
[18:57.840 --> 19:03.840]  Вот, и мы будем говорить следующее. Мы будем говорить ватердно.
[19:03.840 --> 19:06.840]  Во-первых, конечное преобразование для преобразователя.
[19:06.840 --> 19:10.840]  Но если мы это не упоминаем, это означает, что существует конечное преобразование.
[19:10.840 --> 19:16.840]  Хорошо. Давайте посмотрим пример вводимости слова.
[19:16.840 --> 19:24.840]  Собственно, иску 0 мы по a, b, a, e. Куда идем?
[19:25.840 --> 19:31.840]  В q1, a, b, a, e. Дальше что делаем?
[19:31.840 --> 19:35.840]  Съедаем a, мы получаем q1, b, a, a.
[19:35.840 --> 19:43.840]  Потом q1, a, a, b. И дальше что? q2, e, a, b.
[19:43.840 --> 19:51.840]  То есть у нас получается пара a, b, a, b принадлежит этому конечному преобразованию.
[19:51.840 --> 19:55.840]  Конечно, вы преобразоваете μ, который сдается к конечному преобразователю.
[19:55.840 --> 20:02.840]  Хорошо. Сейчас будут некоторые примеры. Они на уровень упражнения тянут.
[20:02.840 --> 20:07.840]  Ну, таких очевидных фактов, что можно задавать конечным преобразованием.
[20:07.840 --> 20:12.840]  Что является конечным преобразованием. Давайте как раз разберем все эти примеры.
[20:12.840 --> 20:15.840]  Первый пример. Identity.
[20:21.840 --> 20:35.840]  Какая идентификация у нас?
[20:35.840 --> 20:38.840]  Пепля.
[20:38.840 --> 20:41.840]  Пепля по всем символам.
[20:41.840 --> 20:44.840]  Да, пепля по всем символам.
[20:44.840 --> 20:47.840]  Символы разлога.
[20:47.840 --> 21:07.840]  Ну да, конечно же.
[21:07.840 --> 21:13.840]  Вот такая она. То есть для любого x мы по входу x генерируем выход x.
[21:13.840 --> 21:16.840]  Вот она картинка.
[21:16.840 --> 21:20.840]  Второй пример.
[21:20.840 --> 21:31.840]  Это, скажите, такие технологии программирования и всяких технических вещей, что написано в операции?
[21:31.840 --> 21:34.840]  Вот это вот.
[21:34.840 --> 21:40.840]  Так?
[21:40.840 --> 21:45.840]  Ну вот, я слышу правильные слова.
[21:45.840 --> 21:55.840]  Перенаправление в девну.
[21:55.840 --> 22:06.840]  Вы можете написать.
[22:06.840 --> 22:09.840]  Мы кома?
[22:09.840 --> 22:11.840]  Ага.
[22:11.840 --> 22:21.840]  В выход ничего не пишется.
[22:21.840 --> 22:31.840]  Стрелочка это оператор вывода.
[22:31.840 --> 22:34.840]  Ну да.
[22:34.840 --> 22:43.840]  В этом деле прав, что нужно добавить апперсан, чтобы stdout и stdir улетало в этот файл.
[22:43.840 --> 22:53.840]  Это файловый дискрептор, который, ну по факту, файловое устройство, которое позволяет вам спрятать весь вывод.
[22:53.840 --> 23:00.840]  Знатоки курса PD уже знакомы с этим оператором.
[23:00.840 --> 23:11.840]  Да.
[23:11.840 --> 23:24.840]  Ну да, а вот это означает, что типа stdout, stdir в stdout направляет.
[23:24.840 --> 23:29.840]  Ладно, короче, тут надо какой-нибудь игре по истории сделать, чтобы найти эту команду.
[23:29.840 --> 23:38.840]  Я образно пишу.
[23:38.840 --> 23:42.840]  Так, вопрос. Как построить конечную преобразователь для этой штуки?
[23:42.840 --> 23:45.840]  А?
[23:45.840 --> 23:54.840]  Не, не, у, вот это регулярный язык, если что.
[23:54.840 --> 24:01.840]  Ну как бы вход у нас должен приниматься только из слов регулярного языка.
[24:01.840 --> 24:06.840]  Да, берем автомат.
[24:06.840 --> 24:14.840]  И на каждом переходе мы пишем вместо слова, на вход слово у, а на выход epsilon пишем.
[24:14.840 --> 24:20.840]  То есть мы как бы считываем все слова из регулярного языка, а на выходе ничего не оставляем.
[24:20.840 --> 24:24.840]  А?
[24:24.840 --> 24:30.840]  В смысле петлю?
[24:30.840 --> 24:39.840]  А что делать, если у нас язык бесконечный? У нас регулярный язык может быть бесконечным.
[24:39.840 --> 24:44.840]  Ну, он может состоять из бесконечного количества слов, я про это говорю.
[24:44.840 --> 24:51.840]  А со звездой допустим?
[24:51.840 --> 25:06.840]  Вот, аналогично можно построить следующую вещь.
[25:06.840 --> 25:09.840]  Да, все просто наоборот. Так, третья.
[25:09.840 --> 25:27.840]  Представьте себе, у нас с вами есть два конечных преобразования, как сконктимировать.
[25:27.840 --> 25:34.840]  Да.
[25:34.840 --> 25:38.840]  Ну, конечно.
[25:38.840 --> 25:45.840]  Тут все свойства автоматов действуют, что существует конечный преобразователь с одним завершающим состоянием.
[25:45.840 --> 25:48.840]  Всем это понятно?
[25:48.840 --> 25:55.840]  Что любой конечный преобразователь может создать конечный преобразователь с ровно одним завершающим состоянием.
[25:55.840 --> 26:01.840]  Да, надо просто втянуть epsilon по входу и по выходу.
[26:01.840 --> 26:09.840]  Поэтому конструкция у нас вот такая.
[26:09.840 --> 26:16.840]  Здесь ничего сложного нет.
[26:16.840 --> 26:18.840]  Так, хорошо.
[26:18.840 --> 26:21.840]  Ну, картинка знакомая.
[26:21.840 --> 26:23.840]  Четвертый.
[26:23.840 --> 26:39.840]  Вещь это приписывание слова произвольного.
[26:39.840 --> 26:42.840]  Как это сделать?
[26:42.840 --> 26:47.840]  Да, сконктимировать id со вторым.
[26:47.840 --> 27:01.840]  На самом деле id сконктимировать вот с таким свойством.
[27:01.840 --> 27:05.840]  Хорошо.
[27:05.840 --> 27:09.840]  Так, я проверю, что Zoom работает.
[27:09.840 --> 27:15.840]  Пятое. Объединение.
[27:15.840 --> 27:19.840]  Как строить объединение?
[27:19.840 --> 27:30.840]  Да, да, да.
[27:30.840 --> 27:35.840]  То есть все вот свойства, которые у нас были для автоматов, они поддерживаются.
[27:35.840 --> 27:38.840]  Ну, объединение, iteration, concatenation.
[27:38.840 --> 27:40.840]  То есть здесь все то же самое.
[27:40.840 --> 27:42.840]  Хорошо, пример шесть.
[27:42.840 --> 27:55.840]  Гомоморфизма.
[27:55.840 --> 27:57.840]  Ну, конечно.
[27:57.840 --> 28:01.840]  От epsilon будет epsilon, да.
[28:01.840 --> 28:05.840]  Это даже кажется можно вывести.
[28:05.840 --> 28:26.840]  Ну, да.
[28:26.840 --> 28:31.840]  Как построить?
[28:31.840 --> 28:43.840]  Ну, на самом деле нам нужно построить конечный преобразователь для каждой буквы.
[28:43.840 --> 28:48.840]  Нет, пока что примеры рассматриваем в преобразовании, которые существуют.
[28:48.840 --> 28:55.840]  То есть вот, допустим, у нас есть отображение из одного языка в другой, да, из одного слова в другой, который является гомоморфитами.
[28:55.840 --> 29:00.840]  Наша цель представить его в виде конечного преобразования.
[29:00.840 --> 29:03.840]  Но вы близко идете, правильно сказали.
[29:03.840 --> 29:18.840]  Наша цель сейчас будет состоять в том, чтобы доказать, что любое конечное преобразование можно представить в виде каких-то простых, обвинения каких-то простых конструкций.
[29:18.840 --> 29:25.840]  То есть если у нас есть гомоморфизм Си из одного языка в другой, то мы его можем задать.
[29:25.840 --> 29:36.840]  Так, только здесь важно, что это буква.
[29:36.840 --> 29:39.840]  Вот так это выглядит. То есть нам достаточно задать...
[29:39.840 --> 29:42.840]  Да, кстати, примеры.
[29:42.840 --> 29:47.840]  Ну, чтобы понять, примеры гомоморфизмов.
[29:47.840 --> 29:55.840]  Значит, это либо каждую букву мы удваиваем с вами, либо кирпичный язык, солнечный язык, я не знаю, было у вас в детстве такое или нет.
[29:55.840 --> 29:58.840]  Ну, вот и потолок.
[29:58.840 --> 30:06.840]  Вот это все можно писать некоторым гомоморфизмом.
[30:06.840 --> 30:07.840]  Вот.
[30:07.840 --> 30:10.840]  Собственно, задается это достаточно простым образом.
[30:10.840 --> 30:14.840]  Так, обратный гомоморфизм давайте обсудим.
[30:14.840 --> 30:18.840]  Тут этого функции нету, но оно должен быть.
[30:27.840 --> 30:30.840]  Я не понял, что мы задавали.
[30:30.840 --> 30:33.840]  В плане, у нас есть какое-то соответствие.
[30:33.840 --> 30:35.840]  Да, которое оказалось, что является гомоморфизмом.
[30:35.840 --> 30:37.840]  Да, наши цели его задать в конечном сетке.
[30:37.840 --> 30:39.840]  В конечном сетке существует конечное преобразование.
[30:39.840 --> 30:42.840]  Да, которое задает этот гомоморфизм.
[30:42.840 --> 30:45.840]  Мы его задали.
[30:45.840 --> 30:48.840]  Сделали астропаховый преобразователь с одним состоянием.
[30:48.840 --> 30:56.840]  Он на фото снимает букву, произвольную букву, и на выход подает ее образ.
[30:56.840 --> 30:58.840]  Вы говорили, что получается конечное преобразование.
[30:58.840 --> 31:02.840]  Да.
[31:02.840 --> 31:04.840]  Ну, потому что чем задается гомоморфизм?
[31:04.840 --> 31:09.840]  Гомоморфизм обычно в группу создается базовыми элементами, полугруппом.
[31:09.840 --> 31:12.840]  Как осуществлять обратный гомоморфизм?
[31:17.840 --> 31:22.840]  То есть наша цель – получать измены впервые.
[31:27.840 --> 31:30.840]  Но по факту надо поменять то, что здесь было местами.
[31:32.840 --> 31:35.840]  Единственное, смотрите, здесь тонкий момент есть.
[31:36.840 --> 31:39.840]  Вот раз скажу, очень важный.
[31:48.840 --> 31:50.840]  Да, здесь вот так вот.
[31:50.840 --> 31:52.840]  Здесь однозначности никто не требует.
[31:57.840 --> 31:59.840]  Хорошо.
[31:59.840 --> 32:01.840]  Вот здесь есть тонкий момент.
[32:01.840 --> 32:05.840]  А как это аккуратненько сделать?
[32:05.840 --> 32:10.840]  На самом деле у нас, думаю, два разных слов.
[32:10.840 --> 32:11.840]  Да.
[32:11.840 --> 32:13.840]  Два перехода по одному и того же слово.
[32:13.840 --> 32:15.840]  Да, но мы детерминированность не требуем.
[32:15.840 --> 32:21.840]  Мы запрещали, мы написали, что у нас 9 при этом, потому что Q на sigma со звездой.
[32:21.840 --> 32:26.840]  Поэтому из каждой вершины может сходить не больше одного.
[32:26.840 --> 32:30.840]  Не, Q на sigma со звездой на Q на sigma со звездой.
[32:42.840 --> 32:46.840]  То есть по одному состоянию мы можем перейти в другое.
[32:48.840 --> 32:54.840]  Так, этот пример с вами должны на семинарах будут разобрать, как два числа складывать.
[32:55.840 --> 33:03.840]  Типа, если у нас числа подаются в бинарной записи, то можно, собственно, использовать состояние автомата как бит переноса.
[33:05.840 --> 33:06.840]  Нормально.
[33:06.840 --> 33:08.840]  Там причем они идут по битово.
[33:08.840 --> 33:13.840]  То есть сначала последние биты X, а потом последние биты Y.
[33:17.840 --> 33:20.840]  Иначе, кстати, можно доказать, что такое сложение работать не будет.
[33:24.840 --> 33:38.840]  Да, то есть у нас есть два числа, которые записаны в двоичной записи, причем биты подаются вот в порядке 0, 0, потом 1, 0, 1, 1 и так далее.
[33:38.840 --> 33:40.840]  То есть вот в таком порядке.
[33:54.840 --> 33:56.840]  Да, да, да, и бит его начали складывать.
[33:57.840 --> 33:59.840]  То есть нам главное уметь хранить бит переноса.
[34:01.840 --> 34:02.840]  Хорошо.
[34:03.840 --> 34:06.840]  Так, и сейчас мы наконец-ки начинаем доказывать какие-то факты.
[34:06.840 --> 34:09.840]  То есть мы рассмотрели с вами примеры, все примеры были понятны?
[34:11.840 --> 34:13.840]  Это вам не лерд оказывать, как говорится.
[34:14.840 --> 34:15.840]  Все достаточно легко.
[34:16.840 --> 34:18.840]  Давайте докажем следующий факт.
[34:18.840 --> 34:21.840]  На самом деле мы его доказывать не будем, как ни странно,
[34:21.840 --> 34:29.840]  потому что это факт, вы сейчас увидите, что большая часть это просто то, что не будет стояться на следующей вещи.
[34:29.840 --> 34:34.840]  Значит, утверждается первое, что для любого конечного преобразователя можно сделать следующее.
[34:44.840 --> 34:46.840]  Можно считать,
[34:47.840 --> 34:49.840]  что
[34:59.840 --> 35:01.840]  почему
[35:09.840 --> 35:11.840]  Ну да, в списку конечных преобразований это совсем сложно.
[35:11.840 --> 35:13.840]  Почему?
[35:17.840 --> 35:19.840]  Значит, первое.
[35:22.840 --> 35:24.840]  Если у нас с вами есть переход,
[35:32.840 --> 35:34.840]  это мы это все уже увидели.
[35:34.840 --> 35:36.840]  Это что, он за один?
[35:42.840 --> 35:44.840]  Нет, с ним пойдет.
[35:44.840 --> 35:47.840]  Такой конечный преобразователь, кстати, он очень интересный,
[35:47.840 --> 35:52.840]  потому что оказывается, в каком очень его можно сделать из контекста свободной грамматики, из контекста зависимости.
[35:52.840 --> 35:57.840]  Ну типа, на вход принять контекст свободного языка, на выход выдать не контекст свободного языка.
[36:04.840 --> 36:08.840]  Да, да, да. Из нас спит на конечности, мы это будем доказывать.
[36:12.840 --> 36:15.840]  Ну да, я думаю, что мы это будем доказывать.
[36:15.840 --> 36:17.840]  А?
[36:18.840 --> 36:21.840]  Да, да, да. Из нас спит на конечности, мы это будем доказывать.
[36:22.840 --> 36:24.840]  Так, ну первый шаг.
[36:24.840 --> 36:25.840]  Это какой?
[36:25.840 --> 36:27.840]  А второй шаг, смотрите, какой.
[36:28.840 --> 36:30.840]  Второй шаг у нас будет в следующем.
[36:31.840 --> 36:33.840]  Убрать epsilon-epsilon перехода.
[36:42.840 --> 36:44.840]  Я думаю, это доказывать не надо.
[36:46.840 --> 36:49.840]  Как они убираются еще раз?
[36:50.840 --> 36:52.840]  Берем epsilon.
[36:53.840 --> 36:54.840]  Да.
[36:55.840 --> 37:01.840]  Берем дерево epsilon, берем существенный переход и делаем вымахание.
[37:02.840 --> 37:04.840]  То есть так же, как удаление epsilon-перехода.
[37:04.840 --> 37:07.840]  Так, это первый факт, который нам нужно было доказать.
[37:08.840 --> 37:10.840]  Теперь давайте подумаем еще одну вещь.
[37:10.840 --> 37:12.840]  Сделаем.
[37:13.840 --> 37:14.840]  Во.
[37:14.840 --> 37:18.840]  Значит, следующие факты, которые позволяют посмотреть,
[37:18.840 --> 37:22.840]  а что же такое конечное преобразование по факту.
[37:22.840 --> 37:24.840]  Значит, это следующее утверждение.
[37:24.840 --> 37:26.840]  Оно будет состоять из трех фактов.
[37:26.840 --> 37:30.840]  И мы будем доказывать, что это конечное преобразование по факту.
[37:31.840 --> 37:33.840]  Значит, это следующее утверждение.
[37:33.840 --> 37:35.840]  Оно будет состоять из трех фактов.
[37:35.840 --> 37:38.840]  Первый факт, область определения конечного преобразования,
[37:38.840 --> 37:40.840]  это регулярный язык.
[37:41.840 --> 37:42.840]  Да.
[37:42.840 --> 37:45.840]  Значит, второе, область значения конечного преобразования,
[37:45.840 --> 37:47.840]  это тоже регулярный язык.
[37:49.840 --> 37:51.840]  Тоже вроде логично.
[37:52.840 --> 37:57.840]  Да, мы просто берем эти, смотрим на выходы, получаем автомат.
[37:57.840 --> 38:04.840]  И третье, это индуцированное конечное преобразование по регулярному языку.
[38:04.840 --> 38:10.840]  То есть, это те регулярные, это по факту такое соответствие,
[38:10.840 --> 38:14.840]  которое принимает только слова из нашего регулярного выражения.
[38:14.840 --> 38:19.840]  И на выходе выдает то, что должен был выдавать от конечного преобразования.
[38:20.840 --> 38:23.840]  На этом можно...
[38:25.840 --> 38:30.840]  Как ни странно, будет пересечение двух конечных преобразователей.
[38:38.840 --> 38:41.840]  Я не знаю, мы хотим это строго доказывать.
[38:49.840 --> 38:52.840]  Да, давайте на третью хотя бы отчасти начнем писать формально,
[38:52.840 --> 38:54.840]  а дальше посмотрим.
[39:15.840 --> 39:17.840]  Теорема.
[39:20.840 --> 39:26.840]  Пусть фи это конечное преобразование.
[39:29.840 --> 39:39.840]  Тогда, первое, область определения фи это регулярный язык.
[39:49.840 --> 39:51.840]  Образ.
[39:53.840 --> 39:55.840]  Это тоже регулярный язык.
[39:59.840 --> 40:01.840]  И третье, это...
[40:01.840 --> 40:28.840]  Если R регулярен, то тоже конечное преобразование.
[40:28.840 --> 40:32.840]  Значит, первые три свойства, мы с вами первые два свойства уже говорили.
[40:37.840 --> 40:43.840]  Это означает, что это конечное преобразование может принимать только слова из родного языка.
[40:58.840 --> 41:01.840]  Это может принимать отход любой слова из родного языка.
[41:03.840 --> 41:09.840]  А потом мы взяли регулярку из двух букв A, которые повторены сколько-то раз.
[41:10.840 --> 41:13.840]  Как у нас это происходит? Мы можем убрать переход по символу A,
[41:13.840 --> 41:15.840]  потому что тогда он станет пустой.
[41:15.840 --> 41:18.840]  А если мы его не уберем, то у нас будет заниматься все.
[41:28.840 --> 41:31.840]  Первое, только входы смотрим.
[41:35.840 --> 41:37.840]  Второе, только выходы.
[41:42.840 --> 41:44.840]  А вот третье, это интересный факт.
[41:44.840 --> 41:48.840]  Значит, смотрите, что такое регулярный язык?
[41:48.840 --> 41:50.840]  Чем его можно задать?
[41:50.840 --> 41:52.840]  Еще?
[41:53.840 --> 41:55.840]  Еще?
[41:56.840 --> 41:58.840]  Так, нет.
[42:09.840 --> 42:11.840]  ДК.
[42:12.840 --> 42:14.840]  Можем задать его ДК.
[42:15.840 --> 42:17.840]  Тут есть некоторые примеры.
[42:17.840 --> 42:27.840]  Мы берем наш преобразователь, который задает ПСИ,
[42:30.840 --> 42:32.840]  и делаем ДКМ.
[42:36.840 --> 42:38.840]  А дальше, смотрите, что мы делаем.
[42:38.840 --> 42:40.840]  Построим декартовое произведение.
[42:40.840 --> 42:50.840]  То есть наша цель сейчас будет пересечь входы регулярного выражения и входы нашего ДК.
[42:53.840 --> 42:55.840]  Смотрите, я сейчас картинку нарисую.
[42:58.840 --> 43:02.840]  Вот это, допустим, наш Т, а вот это наш К.
[43:02.840 --> 43:06.840]  Значит, смотрите, если у нас есть декартовое произведение,
[43:06.840 --> 43:10.840]  есть переход по букве А из состояния КУ1 КУ2,
[43:12.840 --> 43:18.840]  а в нашем конечном преобразователе существует переход из П1.
[43:18.840 --> 43:20.840]  Так, давайте.
[43:21.840 --> 43:26.840]  КУ это у нас в преобразователе, поэтому автоматизируем П1 П2.
[43:26.840 --> 43:28.840]  А здесь есть переход из КУ1 КУ2,
[43:33.840 --> 43:35.840]  который съедает именно эту букву А,
[43:35.840 --> 43:41.840]  то мы делаем переход в нашем конечном преобразователе по вот таким вещам.
[43:44.840 --> 43:46.840]  То, что берет на вход по букве А,
[43:46.840 --> 43:52.840]  то мы делаем переход в нашем конечном преобразователе по вот таким вещам.
[43:52.840 --> 43:56.840]  То, что берет на вход А и на выход по букве А.
[44:04.840 --> 44:06.840]  Ну, почти то же самое, да.
[44:09.840 --> 44:14.840]  А еще смотрите, здесь нужно делать кое-какую аккуратную вещь,
[44:14.840 --> 44:18.840]  что везде вот в этих конструкциях,
[44:19.840 --> 44:27.840]  если у нас с вами был переход из F7PB,
[44:28.840 --> 44:32.840]  то мы делаем вот такие горизонтальные переходы.
[44:38.840 --> 44:40.840]  На всех состояний.
[44:42.840 --> 44:47.840]  То есть мы меняем переход, меняем состояние в нашем конечном преобразователе,
[44:47.840 --> 44:50.840]  но не меняем состояние в нашем автомате.
[44:57.840 --> 45:01.840]  Нам надо контролировать не только то, что мы считаем со входу,
[45:01.840 --> 45:03.840]  но и то, что мы пишем на выход.
[45:04.840 --> 45:08.840]  То есть вот эти состояния мы с вами контролировали пересечением,
[45:08.840 --> 45:10.840]  а вот эти оставляем как есть.
[45:10.840 --> 45:12.840]  Угу, понятно, да?
[45:13.840 --> 45:16.840]  Потому что теперь это формально, если записать,
[45:16.840 --> 45:19.840]  то это выглядит вот таким образом.
[45:19.840 --> 45:21.840]  Состоит из, во-первых...
[45:50.840 --> 45:52.840]  При условии...
[45:57.840 --> 46:00.840]  Здесь переход в нашем конечном преобразователе
[46:01.840 --> 46:03.840]  и есть переход в нашем автомате.
[46:08.840 --> 46:10.840]  Так, объедини...
[46:11.840 --> 46:13.840]  с...
[46:15.840 --> 46:17.840]  Q1P...
[46:20.840 --> 46:22.840]  Получается...
[46:23.840 --> 46:25.840]  Epsilon в...
[46:26.840 --> 46:28.840]  Q2B,
[46:29.840 --> 46:32.840]  если у нас получается следующая вещь,
[46:33.840 --> 46:35.840]  то из Q1Q2...
[46:36.840 --> 46:38.840]  Ой, Q1 в Epsilon есть переход...
[46:40.840 --> 46:42.840]  Q2B.
[46:44.840 --> 46:47.840]  Ну и здесь надо просто оказать чуть-чуть новую лему...
[46:47.840 --> 46:49.840]  следующего образца.
[46:51.840 --> 46:55.840]  Вот такой вот факт нужно уметь доказывать.
[46:56.840 --> 47:02.840]  Значит, получается, что мы можем прочитать в нашем конечном преобразователе
[47:04.840 --> 47:07.840]  построенное наше слово тогда и только тогда...
[47:07.840 --> 47:09.840]  Чуть-чуть...
[47:15.840 --> 47:17.840]  Где мы?
[47:18.840 --> 47:20.840]  Чуть-чуть закотим...
[47:24.840 --> 47:26.840]  выводится...
[47:29.840 --> 47:31.840]  Epsilon в...
[47:32.840 --> 47:34.840]  Тогда и только тогда...
[47:35.840 --> 47:38.840]  Когда мы в каждом из них можем это сделать.
[47:44.840 --> 47:46.840]  Да, да, да...
[47:57.840 --> 48:01.840]  Так, с первого хода как-то, что это неважно...
[48:04.840 --> 48:08.840]  Если бы не стоило тогда добавить переходы не только в петли, а еще в переходы...
[48:12.840 --> 48:14.840]  Короче, в петли это не снимается?
[48:14.840 --> 48:16.840]  Да, нет.
[48:19.840 --> 48:23.840]  Сейчас, вот тут есть один тонкий момент, который мы сейчас будем с вами рассматривать.
[48:23.840 --> 48:26.840]  Возможно, что в нем понадобится, что это ДК.
[48:30.840 --> 48:32.840]  Давайте посмотрим.
[48:33.840 --> 48:37.840]  Смотрите, как вы думаете, в какую сторону сложнее доказывать?
[48:37.840 --> 48:39.840]  Слева направо или справа налево?
[48:41.840 --> 48:43.840]  Слева направо?
[48:47.840 --> 48:49.840]  Да, если подумать...
[48:53.840 --> 48:55.840]  Ну, это да, если меньше подумать.
[48:56.840 --> 48:58.840]  А?
[48:58.840 --> 49:00.840]  Да, слева направо, на самом деле, не сложно.
[49:00.840 --> 49:03.840]  Это индукция по длине вывода в этой грамматике.
[49:03.840 --> 49:05.840]  Вот у нас правило есть.
[49:05.840 --> 49:07.840]  Какой грамматик?
[49:07.840 --> 49:09.840]  В нашем преобразователе.
[49:09.840 --> 49:11.840]  Собственно, берем распичку.
[49:12.840 --> 49:14.840]  То есть у нас там первый переход.
[49:14.840 --> 49:16.840]  Либо вот такой...
[49:16.840 --> 49:18.840]  Да, это значит, что у нас есть выводы в основании.
[49:18.840 --> 49:20.840]  Либо переход такой, тогда мы рассмотрим.
[49:21.840 --> 49:25.840]  Поэтому интересно рассмотреть переход справа налево.
[49:29.840 --> 49:34.840]  И давайте поймем, по какому параметру мы будем делать индукцию.
[49:47.840 --> 49:49.840]  А?
[49:49.840 --> 49:51.840]  Ну да.
[49:54.840 --> 49:56.840]  По сумме длины вывода.
[49:56.840 --> 49:58.840]  Так, это в правую сторону переход.
[49:58.840 --> 50:00.840]  Тут можно просто прочитать.
[50:01.840 --> 50:03.840]  Тут есть несколько вариантов.
[50:03.840 --> 50:05.840]  По сумме длины вывода.
[50:19.840 --> 50:21.840]  База.
[50:25.840 --> 50:27.840]  Значит...
[50:27.840 --> 50:33.840]  У1, у эксион выводит у2, эксион в, в 0 шагов.
[50:35.840 --> 50:37.840]  Что из этого снижается?
[50:44.840 --> 50:47.840]  У эксион, и в в равняется эксион.
[50:47.840 --> 50:49.840]  И в в равняется эксион.
[50:49.840 --> 50:51.840]  Да, снижается.
[50:52.840 --> 50:54.840]  Это логично, да?
[50:54.840 --> 50:56.840]  И второго факта.
[51:01.840 --> 51:03.840]  0 шагов?
[51:05.840 --> 51:07.840]  Ну тогда давайте поймем, что такое...
[51:10.840 --> 51:12.840]  Пара Q1P1?
[51:12.840 --> 51:14.840]  Эксион, эксион.
[51:14.840 --> 51:18.840]  Она как раз выводит пару Q2P2, эксион, эксион.
[51:24.840 --> 51:26.840]  Логично, да?
[51:28.840 --> 51:30.840]  Так, переход.
[51:30.840 --> 51:32.840]  Здесь интересный переход.
[51:36.840 --> 51:38.840]  А, да, кстати.
[51:39.840 --> 51:41.840]  Ну...
[51:41.840 --> 51:45.840]  Да, в общем, тут нужно автомация набуковыми переходами.
[51:47.840 --> 51:52.840]  Ну, пока да, пока автомации набуковыми переходами хватает.
[51:56.840 --> 51:59.840]  Короче, это можно затереть.
[52:00.840 --> 52:03.840]  Так, переход. Значит, смотрите.
[52:03.840 --> 52:08.840]  Давайте рассмотрим последний переход в нашем автоматике.
[52:09.840 --> 52:12.840]  В нашем конечном преобразователе.
[52:29.840 --> 52:31.840]  Так, переход.
[52:32.840 --> 52:35.840]  Здесь более мощная база подойдет.
[52:35.840 --> 52:37.840]  Смотрите.
[52:37.840 --> 52:40.840]  Если здесь эксион у пустое слово,
[52:40.840 --> 52:42.840]  вместо U пустое слово,
[52:42.840 --> 52:45.840]  то здесь неважно, за какое количество переходов.
[52:45.840 --> 52:48.840]  Мы просто явно выводим количество переходов полно нулю.
[52:48.840 --> 52:50.840]  А?
[52:50.840 --> 52:52.840]  Да, здесь одному самому.
[52:52.840 --> 52:54.840]  Хорошо, так, давайте...
[52:55.840 --> 52:57.840]  Мы с вами начнем переход.
[52:58.840 --> 53:02.840]  Значит, рассмотрим последний переход, который у нас был.
[53:13.840 --> 53:15.840]  О, что там?
[53:22.840 --> 53:25.840]  Значит, какие у нас варианты здесь могут быть?
[53:25.840 --> 53:27.840]  Смотрите.
[53:27.840 --> 53:31.840]  Первый вариант, что мы вот здесь вот считываем буквом.
[53:39.840 --> 53:42.840]  Второй вариант, какой здесь может быть?
[53:42.840 --> 53:44.840]  Да.
[53:48.840 --> 53:51.840]  Третий вариант, на самом деле, по идее, должен быть.
[53:51.840 --> 53:54.840]  Ну, давайте рассмотрим первый сначала.
[53:55.840 --> 53:58.840]  Значит, тогда у нас есть переход следующий.
[53:58.840 --> 54:00.840]  Q3, A.
[54:03.840 --> 54:05.840]  Вот Q2.
[54:09.840 --> 54:12.840]  Тогда давайте выводить, что это означает.
[54:14.840 --> 54:17.840]  Это означает, что Q3 равняется A,
[54:18.840 --> 54:20.840]  а в N3 равняется B.
[54:22.840 --> 54:24.840]  Ой, Q3.
[54:26.840 --> 54:29.840]  Вот это слово тогда равняется A.
[54:31.840 --> 54:32.840]  Да?
[54:32.840 --> 54:34.840]  Хорошо.
[54:34.840 --> 54:36.840]  Значит, V3 равняется V.
[54:36.840 --> 54:39.840]  И тогда мы можем сказать, что U
[54:40.840 --> 54:42.840]  это некоторое U'A.
[54:48.840 --> 54:50.840]  И смотрите дальше, что мы делаем.
[54:50.840 --> 54:54.840]  И вот тут тонкий момент, кстати, который говорит следующее.
[54:55.840 --> 55:01.840]  Значит, у нас с вами из P1 по слову U
[55:01.840 --> 55:05.840]  считывается P2ε
[55:06.840 --> 55:10.840]  в нашем автомате с однобуквенными переходами.
[55:12.840 --> 55:13.840]  Да?
[55:13.840 --> 55:16.840]  Значит, смотрите, существует перемычка,
[55:20.840 --> 55:23.840]  что у нас верно вот это соотношение.
[55:23.840 --> 55:26.840]  Так, по-моему, уже вот трогление будет, поэтому
[55:28.840 --> 55:36.840]  P1 U'A мы выводим, смотрите, P4A
[55:37.840 --> 55:40.840]  и за один шаг мы выводим P2ε.
[55:44.840 --> 55:45.840]  Что?
[55:45.840 --> 55:46.840]  Сложный.
[55:46.840 --> 55:47.840]  А?
[55:47.840 --> 55:48.840]  Сложный.
[55:48.840 --> 55:49.840]  Сложный факт.
[55:49.840 --> 55:52.840]  Но здесь, кстати, мы пользуемся, что у нас автоматомодобуквенными переходами.
[55:52.840 --> 55:53.840]  Да.
[55:57.840 --> 55:59.840]  Теперь давайте собирать факты.
[56:04.840 --> 56:05.840]  Собираем наши факты.
[56:05.840 --> 56:07.840]  Смотрите, что у нас получается.
[56:08.840 --> 56:10.840]  У нас получается интересная вещь.
[56:10.840 --> 56:11.840]  Что?
[56:11.840 --> 56:12.840]  Утверждение.
[56:12.840 --> 56:14.840]  Мы можем сказать, что тогда,
[56:14.840 --> 56:17.840]  по предположению индукции, внезапно
[56:18.840 --> 56:27.840]  у нас пара из пары Q1P1U'ε
[56:27.840 --> 56:30.840]  будет выводиться пара Q3P4
[56:37.840 --> 56:38.840]  εv.
[56:39.840 --> 56:40.840]  Откуда это следует?
[56:40.840 --> 56:44.840]  Это следует из того, что вот это U'A у нас с вами,
[56:44.840 --> 56:46.840]  а вот это A,
[56:47.840 --> 56:48.840]  а вот это V.
[56:49.840 --> 56:52.840]  То есть как бы получается, что мы с вами,
[56:52.840 --> 56:54.840]  у нас вот здесь есть переход для
[56:54.840 --> 56:58.840]  из Q1 в Q3, который съедает U' на выход, пишет V,
[56:58.840 --> 57:01.840]  а здесь у нас получается переход, который
[57:01.840 --> 57:05.840]  заменчивает число шагов, из P1 делает P4,
[57:05.840 --> 57:07.840]  считывая это слово U'.
[57:07.840 --> 57:08.840]  Ну да, да, да.
[57:08.840 --> 57:10.840]  Не, мы для любых паровершен это делаем.
[57:12.840 --> 57:16.840]  Ну а тогда смотрите, здесь уже все достаточно просто.
[57:18.840 --> 57:20.840]  Мы пишем U'A,
[57:20.840 --> 57:25.840]  когда мы выводим с вами Q3P4,
[57:26.840 --> 57:27.840]  A, V,
[57:28.840 --> 57:29.840]  В,
[57:30.840 --> 57:31.840]  В,
[57:32.840 --> 57:33.840]  В,
[57:34.840 --> 57:35.840]  В,
[57:35.840 --> 57:36.840]  А, В,
[57:37.840 --> 57:39.840]  и дальше за один шаг,
[57:39.840 --> 57:41.840]  поскольку вот у нас есть вот такой образ.
[57:41.840 --> 57:42.840]  Правильно?
[57:44.840 --> 57:47.840]  Что, значит, если мы с вами,
[57:50.840 --> 57:53.840]  у нас с вами есть переход, который считывает букву A,
[57:54.840 --> 57:56.840]  из Q3 в Q2,
[57:56.840 --> 58:00.840]  а есть переход, который из P4 съедает букву A,
[58:01.840 --> 58:09.840]  то мы получаем с вами пару Q2P2, X, Y.
[58:13.840 --> 58:15.840]  То есть как бы проконтролировали все кроме последней буквы
[58:15.840 --> 58:18.840]  и сделали переход по последней букве со входа.
[58:21.840 --> 58:22.840]  Это первый случай.
[58:26.840 --> 58:27.840]  Второй случай.
[58:28.840 --> 58:31.840]  У нас с вами пишем букву B на выходе.
[58:32.840 --> 58:35.840]  Тогда давайте его рассмотрим.
[58:40.840 --> 58:42.840]  У нас получается,
[58:46.840 --> 58:47.840]  за один шаг,
[58:50.840 --> 58:51.840]  получается есть
[58:51.840 --> 58:54.840]  переход по суну Q3P4.
[58:55.840 --> 58:57.840]  То есть мы пишем букву B.
[58:57.840 --> 58:59.840]  Значит, тогда смотрите,
[58:59.840 --> 59:01.840]  из этого будет следовать,
[59:01.840 --> 59:03.840]  что U3 это пустое слово,
[59:07.840 --> 59:09.840]  а V,
[59:10.840 --> 59:11.840]  так, стоп,
[59:11.840 --> 59:13.840]  а V это какое-то слово V3B.
[59:14.840 --> 59:18.840]  То есть потому что мы вот здесь написали букву B в конец.
[59:18.840 --> 59:20.840]  Меня кто-то еще слушает?
[59:23.840 --> 59:25.840]  Вот, а тогда смотрите, в чем фишка.
[59:25.840 --> 59:27.840]  Значит, дальше мы говорим,
[59:27.840 --> 59:29.840]  смотрите, по предположению индукции,
[59:29.840 --> 59:31.840]  вот здесь тонкий момент,
[59:31.840 --> 59:33.840]  заключается в том, что мы можем написать.
[59:34.840 --> 59:35.840]  Что для пары
[59:38.840 --> 59:39.840]  Q1,
[59:41.840 --> 59:42.840]  P1,
[59:44.840 --> 59:45.840]  Q2,
[59:46.840 --> 59:47.840]  P1,
[59:48.840 --> 59:49.840]  Q3,
[59:50.840 --> 59:54.840]  мы можем вывести пару Q3, P2, E3.
[01:00:01.840 --> 01:00:02.840]  Почему это так?
[01:00:04.840 --> 01:00:08.840]  Собственно, нам нужно считать со входа слово U
[01:00:08.840 --> 01:00:10.840]  и на выход написать слово B3.
[01:00:11.840 --> 01:00:12.840]  В таком случае,
[01:00:12.840 --> 01:00:15.840]  во втором кейсе у нас получается следующее,
[01:00:15.840 --> 01:00:17.840]  что U3 это эпсилон,
[01:00:18.840 --> 01:00:20.840]  поэтому мы со входа считываем U,
[01:00:20.840 --> 01:00:23.840]  а здесь у нас получается со входа эпсилон пишем V3.
[01:00:24.840 --> 01:00:25.840]  Все.
[01:00:25.840 --> 01:00:29.840]  Ну и дополнительно мы с вами понимаем тогда, что здесь,
[01:00:29.840 --> 01:00:33.840]  поскольку у нас с вами уже из U3 нечего считывать,
[01:00:33.840 --> 01:00:35.840]  то мы можем сделать переход за один шаг,
[01:00:36.840 --> 01:00:37.840]  U2,
[01:00:37.840 --> 01:00:38.840]  Q2,
[01:00:41.840 --> 01:00:43.840]  эпсилон, V3B.
[01:00:45.840 --> 01:00:46.840]  Это наш слов Эпс.
[01:00:48.840 --> 01:00:49.840]  Все, доказали.
[01:00:50.840 --> 01:00:53.840]  И как мы правильно подметили, нам не нужен дификат.
[01:00:59.840 --> 01:01:01.840]  Сейчас, погоди, петли.
[01:01:03.840 --> 01:01:04.840]  Петли?
[01:01:07.840 --> 01:01:12.840]  Мы по факту добавили петли поверх состояния нашего автомата.
[01:01:14.840 --> 01:01:16.840]  То есть мы можем мысленно считать,
[01:01:16.840 --> 01:01:19.840]  что у нас вот в этом автомате с одномоквынными переходами
[01:01:20.840 --> 01:01:23.840]  мысленно появляется эпсилон пятер вокруг себя.
[01:01:25.840 --> 01:01:28.840]  Да, я не имею в виду, что если у нас был автомат 1,
[01:01:29.840 --> 01:01:30.840]  а это 2,
[01:01:31.840 --> 01:01:32.840]  у него правило 2,
[01:01:33.840 --> 01:01:34.840]  там был эпсилон V,
[01:01:35.840 --> 01:01:36.840]  у него V2, у него V3,
[01:01:39.840 --> 01:01:42.840]  то в каком мы петли добавили бытового автомата?
[01:01:43.840 --> 01:01:44.840]  В смысле, еще раз?
[01:01:45.840 --> 01:01:46.840]  Если была петля?
[01:01:47.840 --> 01:01:49.840]  Если был переход в первом автомате...
[01:01:50.840 --> 01:01:51.840]  В первом, это V или U3?
[01:01:52.840 --> 01:01:54.840]  Короче, из Q2 в Q3, по U2,
[01:01:57.840 --> 01:01:58.840]  из Q2, Q3,
[01:01:59.840 --> 01:02:01.840]  а, ну да, у нас U3 в Q4,
[01:02:02.840 --> 01:02:04.840]  то мы бытового автомата в Q3 добавили.
[01:02:05.840 --> 01:02:07.840]  Мы сделали парадельный перенос,
[01:02:08.840 --> 01:02:10.840]  из Q3 в Q4 сделали переход,
[01:02:11.840 --> 01:02:13.840]  а вот в этом автомате мы не поменяли свой способ.
[01:02:16.840 --> 01:02:18.840]  А, сейчас, мы добавили...
[01:02:19.840 --> 01:02:20.840]  Чего?
[01:02:21.840 --> 01:02:23.840]  У нас нет обухов, получается?
[01:02:24.840 --> 01:02:25.840]  Чего-чего?
[01:02:25.840 --> 01:02:27.840]  У нас нет обухов в втором автомате.
[01:02:28.840 --> 01:02:29.840]  Ну да,
[01:02:30.840 --> 01:02:31.840]  ну нет, мы не делали, смотрите,
[01:02:32.840 --> 01:02:34.840]  суть в том, что если у нас конечное преобразование
[01:02:35.840 --> 01:02:36.840]  со входа считывается эпсилон,
[01:02:37.840 --> 01:02:40.840]  то в втором автомате мы должны остаться на том же месте.
[01:02:41.840 --> 01:02:42.840]  То есть ничего не делать.
[01:02:43.840 --> 01:02:44.840]  Да.
[01:02:45.840 --> 01:02:46.840]  Ну это именно рептология.
[01:02:47.840 --> 01:02:50.840]  То есть мы во втором автомате добавили эпсилон,
[01:02:51.840 --> 01:02:53.840]  после этого сделали его опять обухов.
[01:02:53.840 --> 01:02:54.840]  Не-не-не, смотрите, вот.
[01:02:55.840 --> 01:02:56.840]  Вот тут написано, как это делается.
[01:02:57.840 --> 01:02:59.840]  То есть мы говорим, что если у нас есть
[01:03:00.840 --> 01:03:01.840]  в нашем автомате старом,
[01:03:02.840 --> 01:03:03.840]  в преобразователе то, что мы считываем
[01:03:04.840 --> 01:03:05.840]  со входа на эпсилон, пишем V на выход.
[01:03:06.840 --> 01:03:07.840]  Да.
[01:03:08.840 --> 01:03:09.840]  Да?
[01:03:10.840 --> 01:03:11.840]  То здесь мы делаем следующее.
[01:03:12.840 --> 01:03:13.840]  Собственно, мы не меняем состояние
[01:03:14.840 --> 01:03:15.840]  в нашем НК,
[01:03:16.840 --> 01:03:18.840]  но меняем состояние в нашем преобразователе.
[01:03:23.840 --> 01:03:24.840]  Вот тогда картинка.
[01:03:32.840 --> 01:03:34.840]  Ну да, по старту ничего не читают.
[01:03:35.840 --> 01:03:36.840]  Сейчас, а можно сказать,
[01:03:37.840 --> 01:03:38.840]  можно сделать так?
[01:03:39.840 --> 01:03:40.840]  Можно для всех?
[01:03:41.840 --> 01:03:42.840]  Нет, нельзя.
[01:03:43.840 --> 01:03:44.840]  Нельзя, наверное.
[01:03:45.840 --> 01:03:46.840]  Ну да.
[01:03:47.840 --> 01:03:48.840]  Я не понимаю, мы просто добавляем
[01:03:49.840 --> 01:03:51.840]  во все вершины абсолютный эпсилон?
[01:03:51.840 --> 01:03:53.840]  Ну да, только во все вершины.
[01:03:54.840 --> 01:03:55.840]  То есть если у нас есть переход
[01:03:56.840 --> 01:03:57.840]  в одной вещи из эпсилона V,
[01:03:58.840 --> 01:03:59.840]  то во все остальные встанут,
[01:04:00.840 --> 01:04:01.840]  мы добавляем такие же.
[01:04:04.840 --> 01:04:06.840]  Так, ну что?
[01:04:09.840 --> 01:04:10.840]  Двигаем дальше.
[01:04:12.840 --> 01:04:14.840]  Ох, тут дальше факты.
[01:04:17.840 --> 01:04:19.840]  Собственно, смотрите, давайте тогда
[01:04:19.840 --> 01:04:21.840]  я сейчас поступлю следующим образом.
[01:04:22.840 --> 01:04:24.840]  Значит, пока что мы вот этот факт
[01:04:25.840 --> 01:04:26.840]  оставим на следующий раз.
[01:04:27.840 --> 01:04:28.840]  Вот, мы к нему поверим.
[01:04:29.840 --> 01:04:30.840]  Значит, это один из самых фундаментальных фактов,
[01:04:31.840 --> 01:04:32.840]  который есть.
[01:04:33.840 --> 01:04:34.840]  То, что конечная преобразовательность
[01:04:35.840 --> 01:04:36.840]  относительно композиции.
[01:04:37.840 --> 01:04:38.840]  То есть если у нас с вами есть два
[01:04:39.840 --> 01:04:40.840]  конечных преобразования, то их композиция
[01:04:41.840 --> 01:04:42.840]  тоже является конечным преобразованием.
[01:04:43.840 --> 01:04:44.840]  Давайте этот факт мы будем доказывать в следующий раз,
[01:04:45.840 --> 01:04:46.840]  потому что здесь очень много
[01:04:47.840 --> 01:04:48.840]  муторных выкладок.
[01:04:49.840 --> 01:04:51.840]  Чтобы вы понимали, как это работает,
[01:04:52.840 --> 01:04:54.840]  знакомый с конструкцией Pipe
[01:04:55.840 --> 01:04:56.840]  перед направлением вывода.
[01:04:57.840 --> 01:04:58.840]  Вот.
[01:04:59.840 --> 01:05:00.840]  Из одного потока в другое.
[01:05:01.840 --> 01:05:03.840]  Вот, попробуйте ее реализовать на автоматах.
[01:05:04.840 --> 01:05:05.840]  То есть вам нужно, грубо говоря,
[01:05:06.840 --> 01:05:08.840]  все, что у вас выходит в стедаут
[01:05:09.840 --> 01:05:10.840]  первого преобразователя,
[01:05:11.840 --> 01:05:12.840]  сразу съедать на входе второго преобразователя.
[01:05:13.840 --> 01:05:14.840]  Вот.
[01:05:15.840 --> 01:05:17.840]  Там опять же будет декартовое произведение преобразователей.
[01:05:18.840 --> 01:05:21.840]  Просто аккуратный разбор трех случаев.
[01:05:23.840 --> 01:05:24.840]  Вот.
[01:05:25.840 --> 01:05:26.840]  Что мы с вами будем делать?
[01:05:27.840 --> 01:05:28.840]  Доказательство ровда похожее на то, что есть.
[01:05:29.840 --> 01:05:31.840]  И давайте мы его просто оставим в следующий раз.
[01:05:32.840 --> 01:05:35.840]  Просто видите, сколько тут перелистываний слайдов.
[01:05:36.840 --> 01:05:39.840]  А вот так строится композиция, допустим.
[01:05:40.840 --> 01:05:42.840]  Двух преобразователей.
[01:05:43.840 --> 01:05:46.840]  Значит, давайте мы сейчас с вами
[01:05:47.840 --> 01:05:48.840]  докажем следующий факт.
[01:05:49.840 --> 01:05:50.840]  Значит, смотрите, есть такое утверждение.
[01:05:51.840 --> 01:05:53.840]  Мы с вами будем использовать такой факт,
[01:05:54.840 --> 01:05:55.840]  как неудлиняющий гомоморфизм.
[01:05:56.840 --> 01:05:58.840]  То есть это гомоморфизм, который не удлиняет длину слова.
[01:06:01.840 --> 01:06:02.840]  Вот.
[01:06:03.840 --> 01:06:04.840]  Значит, вот такой вот интересный факт.
[01:06:05.840 --> 01:06:06.840]  И смотрите.
[01:06:07.840 --> 01:06:09.840]  Собственно, для любого неудлиняющего гомоморфизма
[01:06:10.840 --> 01:06:13.840]  можно сказать, что если у нас есть какая-то буква,
[01:06:14.840 --> 01:06:16.840]  то образ этой буквы не более чем один.
[01:06:18.840 --> 01:06:20.840]  То есть у нас либо образ этой буквы
[01:06:21.840 --> 01:06:22.840]  это другая буква из выходного фавита,
[01:06:23.840 --> 01:06:24.840]  либо образ этой буквы это пустое слово.
[01:06:26.840 --> 01:06:29.840]  И вот теперь еще одна вот такая важная теорема,
[01:06:30.840 --> 01:06:31.840]  которую мы вам доказываем,
[01:06:32.840 --> 01:06:33.840]  доказывать на синем мы сейчас ее быстренько докажем,
[01:06:34.840 --> 01:06:35.840]  называется теорем Нева.
[01:06:37.840 --> 01:06:39.840]  Значит, именно Нева. Почему?
[01:06:40.840 --> 01:06:42.840]  Потому что это французская фамилия.
[01:06:47.840 --> 01:06:48.840]  Вот.
[01:06:49.840 --> 01:06:51.840]  Значит, и она формулирует следующим образом,
[01:06:52.840 --> 01:06:54.840]  что любое конечное преобразование
[01:06:55.840 --> 01:06:59.840]  можно представить в виде композиции трех отдельных вещей.
[01:07:00.840 --> 01:07:03.840]  Значит, первое, это обратный неудлиняющий гомоморфизм.
[01:07:05.840 --> 01:07:07.840]  Второе, это ограничение на регулярный язык.
[01:07:08.840 --> 01:07:12.840]  И третье, это еще один неудлиняющий гомоморфизм.
[01:07:13.840 --> 01:07:14.840]  То есть суть состоит в том,
[01:07:14.840 --> 01:07:15.840]  что вы представляете любое конечное преобразование
[01:07:16.840 --> 01:07:20.840]  в виде трех простых преобразований, композиции.
[01:07:21.840 --> 01:07:25.840]  Каждый из них является само по себе конечным преобразованием.
[01:07:26.840 --> 01:07:27.840]  Если мы верим в теорему,
[01:07:28.840 --> 01:07:29.840]  что конечное преобразование
[01:07:30.840 --> 01:07:31.840]  закрыто относительно композиции,
[01:07:32.840 --> 01:07:33.840]  то получается композиция этих трех преобразований
[01:07:34.840 --> 01:07:36.840]  это конечное преобразование.
[01:07:44.840 --> 01:07:57.460]  давайте напишу таким образом psi можно представить как композиция значит phi в
[01:07:57.460 --> 01:08:08.560]  минус 1 и это это не удлиняющий гаммарфизм
[01:08:14.840 --> 01:08:20.400]  это регулярный язык
[01:08:20.400 --> 01:08:33.840]  вот давайте доказываем эти факты на самом деле доказательства очень красивая
[01:08:33.840 --> 01:08:45.080]  без индукции кстати
[01:08:45.080 --> 01:08:55.840]  нет картинка значит смотрите я не знаю знакомы ли вы с таким понятием как
[01:08:56.280 --> 01:09:01.100]  разложение матрицы собственно это аналог
[01:09:01.100 --> 01:09:06.780]  сингулярного разложения напоминает что такое сингулярRa
[01:09:06.780 --> 01:09:10.760]  разложения эта композиция арт наши то преобразование поворота
[01:09:10.760 --> 01:09:17.760]  жатия или растяжение собственно это ограничение tappedии biliyor другого
[01:09:17.760 --> 01:09:22.560]  приобразование и идиот LISA момент что мы понимаем с вами что PLAYING
[01:09:22.560 --> 01:09:24.560]  Обратное к нему тоже ортогональное.
[01:09:24.560 --> 01:09:26.560]  Но вот здесь приходится усложнять это.
[01:09:26.560 --> 01:09:28.560]  То есть это не удлиняющая обратный гаморфизм.
[01:09:28.560 --> 01:09:30.560]  А идея очень простая.
[01:09:30.560 --> 01:09:34.560]  Давайте рассмотрим конечный преобразователь произвольный.
[01:09:34.560 --> 01:09:36.560]  И мы понимаем с вами,
[01:09:36.560 --> 01:09:38.560]  что у нас существует конечный преобразователь
[01:09:38.560 --> 01:09:40.560]  с однобуквенными переходами.
[01:09:40.560 --> 01:09:42.560]  Логично?
[01:09:42.560 --> 01:09:46.560]  Ну вот тот самый, который мы с вами доказывали.
[01:09:46.560 --> 01:09:50.560]  А теперь давайте мы сделаем следующую вещь.
[01:09:50.560 --> 01:09:52.560]  Мы с вами построим два...
[01:10:02.560 --> 01:10:04.560]  Значит, построим следующую вещь.
[01:10:04.560 --> 01:10:06.560]  Значит...
[01:10:06.560 --> 01:10:08.560]  Смотрите, тут важно.
[01:10:08.560 --> 01:10:10.560]  Видите?
[01:10:10.560 --> 01:10:12.560]  Как вы думаете, здесь опечатка или нет?
[01:10:16.560 --> 01:10:18.560]  Нет, нет.
[01:10:18.560 --> 01:10:20.560]  Что тут дельта написано?
[01:10:20.560 --> 01:10:22.560]  Что промежуточный алфавит это дельта.
[01:10:22.560 --> 01:10:24.560]  Вас ничего не смущает?
[01:10:34.560 --> 01:10:36.560]  Не, однобуквенная это значит сумма переходов один тут.
[01:10:36.560 --> 01:10:38.560]  В этом термине обозначает.
[01:10:44.560 --> 01:10:46.560]  Пока что, пока что да.
[01:10:48.560 --> 01:10:50.560]  А теперь смотрите.
[01:10:50.560 --> 01:10:52.560]  Теперь давайте картинку нарисую.
[01:10:52.560 --> 01:10:54.560]  Значит, смотрите.
[01:10:54.560 --> 01:10:56.560]  Первое.
[01:10:56.560 --> 01:10:58.560]  Пси.
[01:10:58.560 --> 01:11:00.560]  Преобразование Фи.
[01:11:00.560 --> 01:11:02.560]  Оно, значит...
[01:11:02.560 --> 01:11:04.560]  Если у нас с вами есть какой-то переход.
[01:11:08.560 --> 01:11:10.560]  Должны делать следующее.
[01:11:12.560 --> 01:11:16.560]  Оно берет и преобразовывает ее в У.
[01:11:18.560 --> 01:11:20.560]  А это...
[01:11:28.560 --> 01:11:30.560]  Делает В.
[01:11:30.560 --> 01:11:32.560]  А теперь смотрите.
[01:11:32.560 --> 01:11:34.560]  Мы будем строить конечный преобразователь.
[01:11:34.560 --> 01:11:36.560]  У которого алфавит это множество переходов
[01:11:36.560 --> 01:11:38.560]  в нашем исходном конечном преобразователе.
[01:11:40.560 --> 01:11:42.560]  То есть это принадлежит дельта.
[01:11:44.560 --> 01:11:46.560]  И это принадлежит дельта.
[01:11:46.560 --> 01:11:48.560]  Это получается у нас с вами
[01:11:48.560 --> 01:11:50.560]  переход из одной буквы
[01:11:50.560 --> 01:11:52.560]  в не более чем одну букву.
[01:11:54.560 --> 01:11:56.560]  Это взрыв в башке.
[01:11:58.560 --> 01:12:00.560]  Давайте картинку, наверное.
[01:12:00.560 --> 01:12:02.560]  Смотрите.
[01:12:02.560 --> 01:12:04.560]  Пример.
[01:12:04.560 --> 01:12:06.560]  Собственно.
[01:12:06.560 --> 01:12:08.560]  Давайте назначим алфавит ребер,
[01:12:08.560 --> 01:12:10.560]  который у нас имеется.
[01:12:10.560 --> 01:12:12.560]  То есть во всем нашем, конечно,
[01:12:12.560 --> 01:12:14.560]  преобразователь, который у нас имеется,
[01:12:14.560 --> 01:12:16.560]  мы назначим ребра.
[01:12:18.560 --> 01:12:20.560]  Обозначим их вот таким вот образом.
[01:12:22.560 --> 01:12:24.560]  Теперь смотрите, что мы с вами сделаем.
[01:12:26.560 --> 01:12:28.560]  Мы с вами вот это вот регулярное выражение,
[01:12:28.560 --> 01:12:30.560]  которое вот здесь вот есть,
[01:12:30.560 --> 01:12:32.560]  мы скажем, что это множество путей
[01:12:32.560 --> 01:12:34.560]  от нашего стартового состояния
[01:12:34.560 --> 01:12:36.560]  до нашего завершающего состояния.
[01:12:38.560 --> 01:12:40.560]  Мы их можем задать регулярным выражением.
[01:12:40.560 --> 01:12:42.560]  Потому что по факту, что у нас такое,
[01:12:42.560 --> 01:12:44.560]  у нас с вами здесь будет написан
[01:12:44.560 --> 01:12:46.560]  регулярный автомат.
[01:12:46.560 --> 01:12:48.560]  На ребре которого каждого написана
[01:12:48.560 --> 01:12:50.560]  просто буква одного алфавита.
[01:12:52.560 --> 01:12:54.560]  Одна буква этого алфавита дельта.
[01:12:56.560 --> 01:12:58.560]  Да, да, да. Мы это сожмем как регулярное выражение.
[01:12:58.560 --> 01:13:00.560]  Смотрите, у нас здесь что делается.
[01:13:00.560 --> 01:13:02.560]  Мы по факту, вот мы видим с вами
[01:13:02.560 --> 01:13:04.560]  переход.
[01:13:04.560 --> 01:13:06.560]  Значит, какой-нибудь
[01:13:06.560 --> 01:13:08.560]  из эпсилон В.
[01:13:08.560 --> 01:13:10.560]  В нашем, конечно, преобразователе.
[01:13:10.560 --> 01:13:12.560]  Q1, Q2.
[01:13:12.560 --> 01:13:14.560]  Значит, при помощи
[01:13:14.560 --> 01:13:16.560]  неудлиняющего гомоморфизма
[01:13:16.560 --> 01:13:18.560]  обратного
[01:13:18.560 --> 01:13:20.560]  мы это сделаем следующее.
[01:13:20.560 --> 01:13:22.560]  Мы из В
[01:13:22.560 --> 01:13:24.560]  сделаем Q1,
[01:13:26.560 --> 01:13:28.560]  эпсилон В,
[01:13:28.560 --> 01:13:30.560]  Q2.
[01:13:30.560 --> 01:13:32.560]  Перегоним его обратным
[01:13:32.560 --> 01:13:34.560]  гомоморфизму.
[01:13:34.560 --> 01:13:36.560]  Понятно.
[01:13:36.560 --> 01:13:38.560]  То есть,
[01:13:38.560 --> 01:13:40.560]  по факту у нас
[01:13:40.560 --> 01:13:42.560]  фи будет делать вот такую вот.
[01:13:42.560 --> 01:13:44.560]  Фи в минус 1.
[01:13:44.560 --> 01:13:46.560]  А вот этот элемент нашего дельта.
[01:13:46.560 --> 01:13:48.560]  Потом
[01:13:48.560 --> 01:13:50.560]  мы его сократим,
[01:13:50.560 --> 01:13:52.560]  а это
[01:13:52.560 --> 01:13:54.560]  сделает следующее. Она возьмет
[01:13:54.560 --> 01:13:56.560]  вот этот переход, который у нас есть,
[01:14:00.560 --> 01:14:02.560]  и обратно перегонит
[01:14:02.560 --> 01:14:04.560]  выход.
[01:14:08.560 --> 01:14:10.560]  Нам надо вход же перегонять.
[01:14:12.560 --> 01:14:14.560]  То есть у нас вход перегоняется
[01:14:14.560 --> 01:14:16.560]  вот в такую вещь.
[01:14:16.560 --> 01:14:18.560]  Потом при помощи
[01:14:18.560 --> 01:14:20.560]  неудлиняющего гомоморфизма здесь мы перегоняем этот вход.
[01:14:22.560 --> 01:14:24.560]  То есть получается
[01:14:24.560 --> 01:14:26.560]  то, что написано на входе, мы
[01:14:26.560 --> 01:14:28.560]  кодируем ID-шником
[01:14:28.560 --> 01:14:30.560]  нашего перехода.
[01:14:30.560 --> 01:14:32.560]  Потом сокращаем это все
[01:14:32.560 --> 01:14:34.560]  на регулярное выражение, и потом этот ID-шник
[01:14:34.560 --> 01:14:36.560]  обратно переводим
[01:14:36.560 --> 01:14:38.560]  уже в то,
[01:14:38.560 --> 01:14:40.560]  что написано на выходе этого ребра.
[01:14:46.560 --> 01:14:48.560]  Так, давайте вопроса.
[01:14:50.560 --> 01:14:52.560]  Перенумеруем все переходы в нашем автомате.
[01:14:54.560 --> 01:14:56.560]  Говорим, что вот этот переход
[01:14:56.560 --> 01:14:58.560]  это переход номер 5.
[01:14:58.560 --> 01:15:00.560]  Значит, тогда у нас
[01:15:00.560 --> 01:15:02.560]  наш обратный гомоморфизм
[01:15:02.560 --> 01:15:04.560]  будет говорить следующее, что
[01:15:04.560 --> 01:15:06.560]  из эпсилона мы будем
[01:15:06.560 --> 01:15:08.560]  ставить пятерку.
[01:15:10.560 --> 01:15:12.560]  То есть прямой гомоморфизм вот здесь
[01:15:12.560 --> 01:15:14.560]  он будет говорить, вот phi будет писать, что
[01:15:14.560 --> 01:15:16.560]  пятерка
[01:15:16.560 --> 01:15:18.560]  у нас трансформируется в эпсилон.
[01:15:22.560 --> 01:15:24.560]  Пятый переход в нашем автомате.
[01:15:24.560 --> 01:15:26.560]  В нашем конечном преобразователе.
[01:15:28.560 --> 01:15:30.560]  Слова.
[01:15:30.560 --> 01:15:32.560]  Слова. Но смотрите, мы делаем следующее.
[01:15:32.560 --> 01:15:34.560]  Мы говорим, что у нас будет новый язык.
[01:15:34.560 --> 01:15:36.560]  То есть мы переходим.
[01:15:36.560 --> 01:15:38.560]  Нам же здесь не говорят
[01:15:38.560 --> 01:15:40.560]  какие языки.
[01:15:40.560 --> 01:15:42.560]  Ну, типа того.
[01:15:42.560 --> 01:15:44.560]  То есть смотрите,
[01:15:44.560 --> 01:15:46.560]  у нас будет
[01:15:46.560 --> 01:15:48.560]  следующее преобразование. Давайте я напишу
[01:15:48.560 --> 01:15:50.560]  чуть формальнее.
[01:15:54.560 --> 01:15:56.560]  Phi у нас будет
[01:15:56.560 --> 01:15:58.560]  действовать из дельта
[01:15:58.560 --> 01:16:00.560]  в сигма со звездой.
[01:16:00.560 --> 01:16:02.560]  Psi
[01:16:02.560 --> 01:16:04.560]  будет действовать из дельты
[01:16:04.560 --> 01:16:06.560]  в гамма со звездой.
[01:16:10.560 --> 01:16:12.560]  То есть мы
[01:16:12.560 --> 01:16:14.560]  даем этому путь, а он нам дает,
[01:16:14.560 --> 01:16:16.560]  что после этого пути мы
[01:16:16.560 --> 01:16:18.560]  ну да, что
[01:16:18.560 --> 01:16:20.560]  на входе получаем.
[01:16:20.560 --> 01:16:22.560]  Тогда мы берем произвольный вход.
[01:16:22.560 --> 01:16:24.560]  Ну да.
[01:16:24.560 --> 01:16:26.560]  Да, из дельты со звездой.
[01:16:26.560 --> 01:16:28.560]  Правильно.
[01:16:30.560 --> 01:16:32.560]  То есть мы даем ему путь в автомате.
[01:16:34.560 --> 01:16:36.560]  И Phi по пути в автомате выдает
[01:16:36.560 --> 01:16:38.560]  то, что мы прочитали на входе.
[01:16:40.560 --> 01:16:42.560]  А вот это
[01:16:42.560 --> 01:16:44.560]  по входу,
[01:16:44.560 --> 01:16:46.560]  по тому, что мы
[01:16:46.560 --> 01:16:48.560]  какой путь прошли,
[01:16:48.560 --> 01:16:50.560]  мы даем выход.
[01:16:50.560 --> 01:16:52.560]  Да, это есть доказательство.
[01:16:54.560 --> 01:16:56.560]  А смотрите.
[01:16:56.560 --> 01:16:58.560]  Потому что для каждого перехода
[01:16:58.560 --> 01:17:00.560]  мы берем элемент из дельты.
[01:17:00.560 --> 01:17:02.560]  Вот это элемент
[01:17:02.560 --> 01:17:04.560]  из нашего множества
[01:17:04.560 --> 01:17:06.560]  состояний,
[01:17:06.560 --> 01:17:08.560]  то есть длина вот этой штуки
[01:17:08.560 --> 01:17:10.560]  в алфавите
[01:17:10.560 --> 01:17:12.560]  равняется единице?
[01:17:12.560 --> 01:17:14.560]  Да.
[01:17:14.560 --> 01:17:16.560]  То есть длина вот этой штуки
[01:17:16.560 --> 01:17:18.560]  в алфавите
[01:17:18.560 --> 01:17:20.560]  равняется единице?
[01:17:26.560 --> 01:17:28.560]  Одно ребро записано одной буквой, да.
[01:17:32.560 --> 01:17:34.560]  А это уже образ.
[01:17:36.560 --> 01:17:38.560]  Тут либо 0 буква,
[01:17:38.560 --> 01:17:40.560]  либо 1 буква.
[01:17:42.560 --> 01:17:44.560]  То есть получается, да, мы читаем всегда одну букву,
[01:17:44.560 --> 01:17:46.560]  а на выходе всегда пишем либо 0, либо 1 буква.
[01:17:48.560 --> 01:17:50.560]  Вот.
[01:17:54.560 --> 01:17:56.560]  А ограничение на регулярный язык
[01:17:56.560 --> 01:17:58.560]  это как раз множество всех путей
[01:17:58.560 --> 01:18:00.560]  в нашем автомате. Это регулярный автомат.
[01:18:00.560 --> 01:18:02.560]  А по регулярному автомату
[01:18:02.560 --> 01:18:04.560]  мы умеем строить регулярное выражение.
[01:18:08.560 --> 01:18:10.560]  Знаете, как выход
[01:18:10.560 --> 01:18:12.560]  вот за четвертую стенку
[01:18:12.560 --> 01:18:14.560]  в фильмах обычно есть?
[01:18:14.560 --> 01:18:16.560]  Вот оно и произошло.
[01:18:18.560 --> 01:18:20.560]  Так, давайте вопрос.
[01:18:30.560 --> 01:18:32.560]  Да.
[01:18:34.560 --> 01:18:36.560]  Да, да, да.
[01:18:40.560 --> 01:18:42.560]  Допустим,
[01:18:42.560 --> 01:18:44.560]  у нас могло случиться так,
[01:18:44.560 --> 01:18:46.560]  что типа у нас есть слово
[01:18:46.560 --> 01:18:48.560]  а, б,
[01:18:48.560 --> 01:18:50.560]  мы его прочитали
[01:18:50.560 --> 01:18:52.560]  в совходе, получили выход.
[01:18:52.560 --> 01:18:54.560]  И оказывается, что фи в минус 1 от а
[01:18:54.560 --> 01:18:56.560]  это, допустим, вот такой переход.
[01:18:56.560 --> 01:18:58.560]  А фи в минус 1 от б
[01:18:58.560 --> 01:19:00.560]  это другой переход. То есть, грубо говоря,
[01:19:00.560 --> 01:19:02.560]  здесь мы читали слово а,
[01:19:02.560 --> 01:19:04.560]  а здесь мы читали слово б.
[01:19:04.560 --> 01:19:06.560]  Да, и вот эти вот переходы у нас
[01:19:06.560 --> 01:19:08.560]  никаким образом не связаны.
[01:19:12.560 --> 01:19:14.560]  Да, да, да.
[01:19:16.560 --> 01:19:18.560]  Если у нас тут заданное несоответствие,
[01:19:18.560 --> 01:19:20.560]  это отображение.
[01:19:20.560 --> 01:19:22.560]  Ну, да, фи,
[01:19:22.560 --> 01:19:24.560]  гомоморфизм это отображение, если что.
[01:19:24.560 --> 01:19:26.560]  Так.
[01:19:30.560 --> 01:19:32.560]  Да, мы каждый бок смотрим,
[01:19:32.560 --> 01:19:34.560]  какие ребра соответствуют.
[01:19:36.560 --> 01:19:38.560]  Да, путей, да.
[01:19:40.560 --> 01:19:42.560]  А пути мы можем задать регулярным выражением
[01:19:42.560 --> 01:19:44.560]  все.
[01:19:46.560 --> 01:19:48.560]  Каждый путь от стартового выражения,
[01:19:48.560 --> 01:19:50.560]  от стартового станет завершающим, мы можем задать каким-то путем.
[01:19:50.560 --> 01:19:52.560]  Подождите.
[01:19:52.560 --> 01:19:54.560]  Ну, а если у нас есть
[01:19:54.560 --> 01:19:56.560]  текстовый футбол?
[01:19:56.560 --> 01:19:58.560]  Ну, а это звездочка,
[01:19:58.560 --> 01:20:00.560]  это рация к линии в регулярных поражениях.
[01:20:00.560 --> 01:20:02.560]  Мы пишем с вами, смотрите.
[01:20:02.560 --> 01:20:04.560]  Р это регулярный язык
[01:20:04.560 --> 01:20:06.560]  над дельта со звездой.
[01:20:10.560 --> 01:20:12.560]  Над дельтой.
[01:20:12.560 --> 01:20:14.560]  То есть, по Р
[01:20:14.560 --> 01:20:16.560]  нам надо поставить...
[01:20:26.560 --> 01:20:28.560]  Мы строим регулярный автомат.
[01:20:34.560 --> 01:20:36.560]  А если у нас есть регулярный автомат,
[01:20:36.560 --> 01:20:38.560]  то мы можем построить из него
[01:20:38.560 --> 01:20:40.560]  Р регулярного выражения.
[01:20:42.560 --> 01:20:44.560]  Да.
[01:20:48.560 --> 01:20:50.560]  И уже исходя из этого регулярного выражения
[01:20:50.560 --> 01:20:52.560]  мы строим ФИ, да?
[01:20:52.560 --> 01:20:54.560]  А?
[01:20:54.560 --> 01:20:56.560]  Ну да, мы же имеем на входе конкретный автомат.
[01:20:58.560 --> 01:21:00.560]  Вот, допустим.
[01:21:02.560 --> 01:21:04.560]  То есть, по факту,
[01:21:04.560 --> 01:21:06.560]  что делает ФИ?
[01:21:06.560 --> 01:21:08.560]  ФИ минус первое говорит
[01:21:08.560 --> 01:21:10.560]  по входной букве, какие переходы
[01:21:10.560 --> 01:21:12.560]  она могла поратить, а это говорит,
[01:21:12.560 --> 01:21:14.560]  из каких переходов мы можем получить букву В.
[01:21:18.560 --> 01:21:20.560]  Такой коннектор получается.
[01:21:20.560 --> 01:21:22.560]  А ФИ не зависит от вершины?
[01:21:22.560 --> 01:21:24.560]  Нет, не зависит.
[01:21:24.560 --> 01:21:26.560]  От перехода только зависит.
[01:21:30.560 --> 01:21:32.560]  Переход?
[01:21:32.560 --> 01:21:34.560]  Да, переход.
[01:21:40.560 --> 01:21:42.560]  То есть, цель следующая.
[01:21:42.560 --> 01:21:44.560]  Взять, значит, входное слово.
[01:21:46.560 --> 01:21:48.560]  Написать, грубо говоря,
[01:21:48.560 --> 01:21:50.560]  по всем этим буквам,
[01:21:50.560 --> 01:21:52.560]  какие переходы у нас есть.
[01:21:52.560 --> 01:21:54.560]  Потом сказать оба,
[01:21:54.560 --> 01:21:56.560]  какие реально пути подходят.
[01:21:56.560 --> 01:21:58.560]  Это как раз ограничение на наш регулярный автомат
[01:21:58.560 --> 01:22:00.560]  регулярное выражение
[01:22:00.560 --> 01:22:02.560]  из регулярного автомата.
[01:22:04.560 --> 01:22:06.560]  Мы ФИ строили по автомату.
[01:22:06.560 --> 01:22:08.560]  Да, во-первых,
[01:22:08.560 --> 01:22:10.560]  ФИ учитывали ограничение...
[01:22:10.560 --> 01:22:12.560]  Мы построили ФИ,
[01:22:12.560 --> 01:22:14.560]  учитывая уже ограничение нашего автомата.
[01:22:14.560 --> 01:22:16.560]  Да-да-да.
[01:22:16.560 --> 01:22:18.560]  Зачем нам еще раз потом ограничивать?
[01:22:18.560 --> 01:22:20.560]  Нет-нет-нет, чтобы точно все совпало.
[01:22:20.560 --> 01:22:22.560]  А как это может не совпало?
[01:22:22.560 --> 01:22:24.560]  Легко.
[01:22:24.560 --> 01:22:26.560]  Смотрите. Вот даже пример.
[01:22:26.560 --> 01:22:28.560]  Смотрите.
[01:22:30.560 --> 01:22:32.560]  Вот смотрите.
[01:22:32.560 --> 01:22:34.560]  Пример.
[01:22:38.560 --> 01:22:40.560]  Вот это пусть х,
[01:22:40.560 --> 01:22:42.560]  вот это у, вот это z.
[01:22:44.560 --> 01:22:46.560]  Обозначаем.
[01:22:50.560 --> 01:22:52.560]  Что такое фирма МС1?
[01:22:52.560 --> 01:22:54.560]  От АБ.
[01:23:04.560 --> 01:23:06.560]  Сейчас, давай так.
[01:23:06.560 --> 01:23:08.560]  И...
[01:23:10.560 --> 01:23:12.560]  Давайте так.
[01:23:12.560 --> 01:23:14.560]  ФИ от х это...
[01:23:14.560 --> 01:23:16.560]  Это ексимум.
[01:23:16.560 --> 01:23:18.560]  ФИ от х это А, да?
[01:23:18.560 --> 01:23:20.560]  Да, фи от х это А.
[01:23:20.560 --> 01:23:22.560]  ФИ от х это В.
[01:23:22.560 --> 01:23:24.560]  ФИ от z это В.
[01:23:24.560 --> 01:23:26.560]  То есть фиг МС1 от АВ
[01:23:26.560 --> 01:23:28.560]  это утверждение, что это либо
[01:23:28.560 --> 01:23:30.560]  х-секрет, либо х-з.
[01:23:32.560 --> 01:23:34.560]  Но х-з нам не подходят.
[01:23:36.560 --> 01:23:38.560]  Почему? Потому что то регулярное выражение,
[01:23:38.560 --> 01:23:40.560]  которое у нас получится,
[01:23:40.560 --> 01:23:42.560]  это, смотрите, ху
[01:23:42.560 --> 01:23:44.560]  плюс ху-з.
[01:23:46.560 --> 01:23:48.560]  Но можно говорить, чтобы у нас
[01:23:48.560 --> 01:23:50.560]  фи и это у нас давали только
[01:23:50.560 --> 01:23:52.560]  однобухленное? Ну, чтобы не только
[01:23:52.560 --> 01:23:54.560]  однобухленное подавали, чтобы у нас
[01:23:54.560 --> 01:23:56.560]  у вас не кресло было?
[01:23:56.560 --> 01:23:58.560]  Нет. Нет, не можем.
[01:23:58.560 --> 01:24:00.560]  Вот, смотрите, то есть у нас фиг МС1
[01:24:00.560 --> 01:24:02.560]  от АВ это ху и х, да?
[01:24:02.560 --> 01:24:04.560]  Хз нам не подходят.
[01:24:04.560 --> 01:24:06.560]  Потому что регулярное выражение,
[01:24:06.560 --> 01:24:08.560]  которое мы пишем все возможные пути,
[01:24:08.560 --> 01:24:10.560]  это х и х-секрет.
[01:24:12.560 --> 01:24:14.560]  А можете добавить еще Эпсилон А
[01:24:14.560 --> 01:24:16.560]  с первой вершины?
[01:24:16.560 --> 01:24:18.560]  Эпсилона Эпсилона у нас нету.
[01:24:22.560 --> 01:24:24.560]  Тогда у нас фи от А.
[01:24:24.560 --> 01:24:26.560]  Вот это Т будет.
[01:24:28.560 --> 01:24:30.560]  Вот это фи от Т.
[01:24:34.560 --> 01:24:36.560]  Сейчас.
[01:24:38.560 --> 01:24:40.560]  Ну, тогда регулярное выражение у нас
[01:24:40.560 --> 01:24:42.560]  будет Т со звездой.
[01:24:44.560 --> 01:24:46.560]  Вот так вот.
[01:24:50.560 --> 01:24:52.560]  Ну, при этом фи от А,
[01:24:52.560 --> 01:24:54.560]  фи от Т изменяется? Нет, нет, нет.
[01:24:54.560 --> 01:24:56.560]  А фи от Эпсилона тоже?
[01:24:56.560 --> 01:24:58.560]  А? Фи от Т это Эпсилон.
[01:24:58.560 --> 01:25:00.560]  Так, давайте, ладно, напишем
[01:25:00.560 --> 01:25:02.560]  короче, чтобы было понятно.
[01:25:02.560 --> 01:25:04.560]  Фи от Т это Эпсилон.
[01:25:06.560 --> 01:25:08.560]  Значит, смотрите.
[01:25:08.560 --> 01:25:10.560]  Фи от Т это Эпсилон.
[01:25:10.560 --> 01:25:12.560]  Фи от Х это А.
[01:25:26.560 --> 01:25:28.560]  А, вот, все, я понял.
[01:25:28.560 --> 01:25:30.560]  Фи минус 1.
[01:25:30.560 --> 01:25:32.560]  Вот это будет, типа,
[01:25:32.560 --> 01:25:34.560]  Т звездочка А, да?
[01:25:34.560 --> 01:25:36.560]  Ну, да, фи минус 1 от А
[01:25:36.560 --> 01:25:38.560]  это на самом деле даже
[01:25:38.560 --> 01:25:40.560]  больше.
[01:25:44.560 --> 01:25:46.560]  Сейчас, вы просто понимали.
[01:25:46.560 --> 01:25:48.560]  Да.
[01:25:50.560 --> 01:25:52.560]  Да.
[01:25:56.560 --> 01:25:58.560]  Так.
[01:25:58.560 --> 01:26:00.560]  Фи минус 1 от Б.
[01:26:00.560 --> 01:26:02.560]  Нет, это тоже Т звездочка
[01:26:02.560 --> 01:26:04.560]  А.
[01:26:04.560 --> 01:26:06.560]  Почему? У нас нет пути,
[01:26:06.560 --> 01:26:08.560]  который пройдет
[01:26:08.560 --> 01:26:10.560]  по Эпсилону, потом...
[01:26:10.560 --> 01:26:12.560]  Э, нет, смотрите, у нас фи...
[01:26:12.560 --> 01:26:14.560]  Смотрите.
[01:26:14.560 --> 01:26:16.560]  Формально у нас фи
[01:26:16.560 --> 01:26:18.560]  дает, значит, берет на вход
[01:26:18.560 --> 01:26:20.560]  любой переход и строит выход по нему.
[01:26:24.560 --> 01:26:26.560]  Ну, берет переход
[01:26:26.560 --> 01:26:28.560]  и пишет, что на нем на выходе.
[01:26:32.560 --> 01:26:34.560]  Ну, то есть, в нашем случае
[01:26:34.560 --> 01:26:36.560]  фи минус 1 от А это на самом деле
[01:26:36.560 --> 01:26:38.560]  Т вк Т Х.
[01:26:38.560 --> 01:26:40.560]  Т вк Т, да.
[01:26:40.560 --> 01:26:42.560]  Т вк Т.
[01:26:42.560 --> 01:26:44.560]  Да, да, да.
[01:26:48.560 --> 01:26:50.560]  То есть ему, короче,
[01:26:50.560 --> 01:26:52.560]  ему дали просто набор ребер,
[01:26:52.560 --> 01:26:54.560]  Безы, бешенки.
[01:26:54.560 --> 01:26:56.560]  Да.
[01:26:56.560 --> 01:26:58.560]  Да, да, да.
[01:26:58.560 --> 01:27:00.560]  А потом нам нужно как раз применить ограничение
[01:27:00.560 --> 01:27:02.560]  на регулярный язык, на все возможные пути.
[01:27:04.560 --> 01:27:06.560]  Да, это регулярный R.
[01:27:06.560 --> 01:27:08.560]  А потом уже пишем выход.
[01:27:10.560 --> 01:27:12.560]  А?
[01:27:12.560 --> 01:27:14.560]  Да, да.
[01:27:16.560 --> 01:27:18.560]  Да.
[01:27:20.560 --> 01:27:22.560]  Применению этой теории мы хорошие.
[01:27:22.560 --> 01:27:24.560]  Первый факт, который мы с вами думаем,
[01:27:24.560 --> 01:27:26.560]  доказывает, что образ регулярного выражения
[01:27:26.560 --> 01:27:28.560]  при применении конечного преобразования
[01:27:28.560 --> 01:27:30.560]  это регулярный язык.
[01:27:30.560 --> 01:27:32.560]  То есть эта штука позволяет доказывать
[01:27:32.560 --> 01:27:34.560]  замкнутость.
[01:27:36.560 --> 01:27:38.560]  Образ... Смотрите.
[01:27:38.560 --> 01:27:40.560]  То есть если у нас есть
[01:27:40.560 --> 01:27:42.560]  L регулярный,
[01:27:44.560 --> 01:27:46.560]  Пси это конечное преобразование,
[01:27:46.560 --> 01:27:48.560]  то Пси от L тоже будет
[01:27:48.560 --> 01:27:50.560]  регулярным.
[01:27:52.560 --> 01:27:54.560]  Это раз.
[01:27:54.560 --> 01:27:56.560]  Второе.
[01:27:56.560 --> 01:27:58.560]  L КС,
[01:27:58.560 --> 01:28:00.560]  Пси конечное преобразование,
[01:28:00.560 --> 01:28:02.560]  Пси от L тоже будет
[01:28:02.560 --> 01:28:04.560]  КС.
[01:28:08.560 --> 01:28:10.560]  Там еще есть какие-то другие
[01:28:10.560 --> 01:28:12.560]  утверждения, которые чуть более сложные.
[01:28:12.560 --> 01:28:14.560]  Они связаны с тем, как связаны язык
[01:28:14.560 --> 01:28:16.560]  правильно-оскобочных последовательностей
[01:28:16.560 --> 01:28:18.560]  и конечное преобразование.
[01:28:18.560 --> 01:28:20.560]  В этом контексте свободного языка.
[01:28:20.560 --> 01:28:22.560]  В этом контексте свободного языка.
[01:28:22.560 --> 01:28:24.560]  Если грубо говоря,
[01:28:24.560 --> 01:28:26.560]  все то, что
[01:28:26.560 --> 01:28:28.560]  на самом деле мы можем с вами получить
[01:28:28.560 --> 01:28:30.560]  в мире КС языков,
[01:28:30.560 --> 01:28:32.560]  это не что иное, как некоторые вариации
[01:28:32.560 --> 01:28:34.560]  относительно правильно-оскобочных последовательностей.
[01:28:34.560 --> 01:28:36.560]  То есть
[01:28:36.560 --> 01:28:38.560]  ничего более крутого
[01:28:38.560 --> 01:28:40.560]  получить нельзя.
