[00:00.000 --> 00:10.480]  Ну что, мы начинаем нашу лекцию, наконец, в таком карантинном
[00:10.480 --> 00:11.480]  режиме.
[00:11.480 --> 00:14.040]  Надеюсь, что в следующий раз у нас последнее занятие
[00:14.040 --> 00:18.600]  в таком виде будет, ну а пока живем так, как можем.
[00:18.600 --> 00:21.680]  Сегодня, в прошлый раз мы говорили про то, как строить
[00:21.680 --> 00:23.640]  масштабируемые системы, мы до этого долго говорили
[00:23.640 --> 00:25.920]  о строительстве заустойчивой системы, в прошлый раз мы
[00:25.920 --> 00:27.600]  поговорили о строительстве масштабируемой системы,
[00:27.600 --> 00:30.160]  как в них искать узкие места и с помощью каких-то
[00:30.160 --> 00:34.240]  трюков, не знаю, идей, можно их преодолевать, а сегодня
[00:34.240 --> 00:38.040]  мы поговорим про несколько другую задачу, точнее про
[00:38.040 --> 00:41.760]  ту же самую задачу, но немного в другой момент времени.
[00:41.760 --> 00:43.880]  Вот, предположим, мы не то чтобы прямо сейчас пишем
[00:43.880 --> 00:47.480]  распределенную систему, а мы только задумали ее написать,
[00:47.480 --> 00:49.760]  мы примерно понимаем, что она должна делать, разумеется,
[00:49.760 --> 00:52.800]  мы там, не знаю, решили построить кивурию хранилища или
[00:52.800 --> 00:56.800]  файловую систему, или сервис блокировок, или что угодно.
[00:56.800 --> 00:59.600]  Мы, наверное, собрали требования, какого поведения мы от
[00:59.600 --> 01:00.600]  него ожидаем?
[01:00.600 --> 01:02.400]  Ну, например, мы ожидаем, что наша система должна
[01:02.400 --> 01:05.240]  быть ренеризуемой, наша система должна масштабироваться
[01:05.240 --> 01:07.840]  определенным образом, наша система должна переживать
[01:07.840 --> 01:12.920]  отказ вот такого-то числа узлов, такого-то числа датацентров,
[01:12.920 --> 01:16.040]  такого-то числа регионов, потеря такого-то числа регионов.
[01:16.040 --> 01:17.040]  Отлично!
[01:17.040 --> 01:19.680]  А теперь нужно сделать все остальное.
[01:19.680 --> 01:24.520]  То есть, нужно придумать дизайн, нужно как-то его
[01:24.520 --> 01:27.400]  провалидировать, и нужно написать корректную реализацию.
[01:27.400 --> 01:31.480]  Вот сегодня нас будет интересовать не вопрос, не знаю, отказа
[01:31.480 --> 01:34.440]  устойчивости определенных алгоритмов или масштабируемости
[01:34.440 --> 01:37.680]  определенного дизайна, а вот, в принципе, как, имея
[01:37.680 --> 01:40.720]  некоторую задумку, получить корректную систему, корректный
[01:40.720 --> 01:41.720]  код.
[01:41.720 --> 01:45.200]  То есть, реализацию, которая в конечном итоге будет
[01:45.200 --> 01:49.480]  соответствовать заранее поставленным требованиям.
[01:49.480 --> 01:51.120]  Будет очень неприятно, если мы будем писать большую
[01:51.120 --> 01:53.840]  систему, будем писать ее не один год большими силами,
[01:53.840 --> 01:57.200]  то, кажется, что она реализуемость не способна нам обеспечить
[01:57.200 --> 02:00.200]  и по каким-то фундаментальным причинам, которые были...
[02:00.200 --> 02:03.600]  То есть, ошибка была допущена где-то в самом начале дизайна.
[02:03.600 --> 02:06.800]  Так вот, давайте подумаем, как же не получить такую
[02:06.800 --> 02:07.800]  неприятность.
[02:07.800 --> 02:13.440]  То есть, у нас есть некоторая задача большая, сделать
[02:13.440 --> 02:15.560]  файловую систему, сделать кивалию хранилища, сделать
[02:15.560 --> 02:16.560]  базу данных.
[02:16.560 --> 02:21.040]  И вот мы приступаем к дизайну.
[02:21.040 --> 02:22.040]  Как нам...
[02:22.040 --> 02:27.040]  Ну, это как-то очень сложно.
[02:27.040 --> 02:30.600]  Сначала мы вообще просто хотим дизайн как-то придумать.
[02:30.600 --> 02:34.040]  Вот, допустим, мы придумали, выбрали какие-то алгоритмы,
[02:34.040 --> 02:36.480]  выбрали компоненты, декомпозировали нашу систему на какие-то
[02:36.480 --> 02:41.160]  отдельные подсистемы, сформулировали гарантии для них, подумали,
[02:41.160 --> 02:44.600]  через какие протоколы внутри эти гарантии будут достигаться,
[02:44.600 --> 02:46.440]  подумали про взаимосвязь этих компонентов.
[02:46.440 --> 02:50.600]  Ну, и готовы писать.
[02:50.600 --> 02:55.200]  Ну, или не готовы, или, точнее, что значит мы придумали?
[02:55.200 --> 02:56.920]  Вот мало же просто придумать.
[02:56.920 --> 02:59.780]  Ну вот, идеи рождаются в чьей-то голове, но нужно
[02:59.780 --> 03:05.360]  же из головы эти идеи вынести для того, чтобы эти идеи
[03:05.360 --> 03:07.920]  можно было бы обсудить с другими людьми, ну и вообще
[03:07.920 --> 03:09.400]  провалидировать, насколько они разумны.
[03:09.400 --> 03:15.240]  Вот так рождается понятие дизайн документа.
[03:15.240 --> 03:18.800]  У нас есть какая-то сложная задумка, она в нашу голову
[03:18.800 --> 03:22.080]  не помещается, но ее сложно в таком виде презентовать,
[03:22.080 --> 03:23.880]  поэтому мы пишем дизайн док.
[03:23.880 --> 03:25.400]  Ну вот давайте я покажу примеры.
[03:25.400 --> 03:29.400]  Вот дизайн док как rowHDB, надеюсь, мне сейчас видно.
[03:29.400 --> 03:32.400]  А они публичные?
[03:32.400 --> 03:35.760]  Дизайн док и публичные?
[03:35.760 --> 03:38.560]  Ну зависит, если ты пишешь Google Spanner внутри Google, то конечно
[03:38.560 --> 03:42.360]  же они не публичные, но если у тебя open source база данных,
[03:42.360 --> 03:46.520]  то ты хочешь сделать процесс разработки и верификации
[03:46.680 --> 03:49.640]  дизайна прозрачным для людей, ты хочешь, чтобы люди
[03:49.640 --> 03:51.960]  верили, что твоя система работает корректно, поэтому
[03:51.960 --> 03:55.160]  конечно ты публикуешь дизайн документа и весь процесс
[03:55.160 --> 03:56.160]  разработки ведешь открыто.
[03:56.160 --> 04:00.960]  Ну вот дизайн документ как rowHDB и не думаю, что прям
[04:00.960 --> 04:02.440]  по нему шла разработка.
[04:02.440 --> 04:07.320]  А я давно уже должен все показывать и ничего не
[04:07.320 --> 04:09.320]  показываю, к сожалению, да?
[04:09.320 --> 04:11.680]  Ну вот, я долго показывал экран с тектоником, потому
[04:11.680 --> 04:13.800]  что вот пример файловая система, которая большая,
[04:13.800 --> 04:15.480]  сложная, нужно как-то ее задизайнить.
[04:15.560 --> 04:18.520]  Мы в прошлый раз говорили, что вот там есть такие компоненты
[04:18.520 --> 04:22.880]  Metastore, Chunkstore, пленская библиотека, так вот, мы хотим каким-то
[04:22.880 --> 04:25.240]  образом дизайн презентовать, но мы можем, конечно, картинку
[04:25.240 --> 04:28.280]  нарисовать, но одной картинки мало, скорее всего, мы хотим
[04:28.280 --> 04:30.200]  снабдить эту картинку какими-то подробностями.
[04:30.200 --> 04:33.720]  Ну и для этого мы пишем дизайн док, и вот я сейчас
[04:33.720 --> 04:36.000]  показываю вам дизайн док как rowHDB, который был написан
[04:36.000 --> 04:39.280]  когда-то еще давно-давно и с тех пор стала скорее
[04:39.280 --> 04:41.840]  документация архитектурная про систему, есть более
[04:41.840 --> 04:45.160]  полная версия, но вот это то, что было примерно
[04:45.160 --> 04:46.160]  в начале.
[04:46.160 --> 04:49.880]  Ну и мы уже в прошлый раз, по-моему, его смотрели,
[04:49.880 --> 04:54.800]  тут есть слой SQL, слой кивалиохранилища, отдельные узлы, которые
[04:54.800 --> 05:01.320]  хранят реплики диапазонов, и эти реплики реплицируются
[05:01.320 --> 05:02.920]  с помощью протокола консенсора.
[05:02.920 --> 05:08.400]  Ну в общем, мы пишем такой документ и описываем в нем
[05:08.400 --> 05:12.080]  разные компоненты или разные слои архитектуры, вот здесь
[05:12.160 --> 05:15.680]  есть слой непосредственно репликации данных и распределения
[05:15.680 --> 05:19.760]  данных, а есть слой распределенных транзакций, и вот как все
[05:19.760 --> 05:22.480]  транзакции работают, тут подробно достаточно описано.
[05:22.480 --> 05:26.640]  Вот описана модель согласованности, которую мы предоставляем
[05:26.640 --> 05:31.160]  для транзакций, это строгая сериализуемость или в контексте
[05:31.160 --> 05:33.760]  отдельного ключа или нерезуемость, ну про транзакции мы будем
[05:33.760 --> 05:35.720]  говорить в следующий раз, пока это не очень важно,
[05:35.720 --> 05:36.720]  что именно это означает.
[05:36.720 --> 05:40.480]  Главное, что вот такие секции есть, ну и какие-то технические
[05:40.480 --> 05:45.920]  детали, как именно данные представлены в киеварюхранилище,
[05:45.920 --> 05:49.120]  как там хранятся метаданные, как балансируется нагрузка.
[05:49.120 --> 05:53.760]  В общем, все такие детали мы описали для чего, для
[05:53.760 --> 05:57.400]  того чтобы, во-первых, в конце концов, по этому дизайн-доку
[05:57.400 --> 06:02.760]  можно было бы писать код и сверяться с ним, а во-вторых,
[06:02.760 --> 06:03.760]  чтобы провести дизайн-ребью.
[06:03.760 --> 06:09.000]  Вот подобно тому, как вы там, не знаю, пишете какой-то
[06:09.120 --> 06:11.080]  багфикс или какую-то маленькую фичу в какую-то маленькую
[06:11.080 --> 06:14.440]  библиотеку и выкатываете полреквест и его ревьюют
[06:14.440 --> 06:16.800]  более опытные разработчики, скажем, вот точно так же
[06:16.800 --> 06:18.120]  происходит и с дизайн-ребью.
[06:18.120 --> 06:20.720]  Смысл тот же самый, только мы проверяем не какую-то
[06:20.720 --> 06:23.640]  конкретность не пид-кода, а мы пытаемся валидировать
[06:23.640 --> 06:24.640]  дизайн.
[06:24.640 --> 06:27.040]  Вот собирается комитет из опытных разработчиков
[06:27.040 --> 06:30.120]  и они обсуждают, насколько такой дизайн соответствует
[06:30.120 --> 06:32.040]  заявленным требованиям, насколько он эффективен,
[06:32.040 --> 06:34.480]  можно ли сделать иначе, можно ли сделать лучше,
[06:34.480 --> 06:37.680]  где есть слабые места, где есть узкие места при масштабировании.
[06:37.680 --> 06:42.680]  Эта стадия необходима для любой большой системы,
[06:42.680 --> 06:45.200]  потому что, мы уже говорили, системы распределенные
[06:45.200 --> 06:47.680]  устроены довольно сложно и писать их долго.
[06:47.680 --> 06:51.080]  Пишутся они несколько лет, поэтому, и конечно же
[06:51.080 --> 06:53.240]  мы пишем систему для того, чтобы потом от нее кто-то
[06:53.240 --> 06:55.440]  существенно зависит в нашей инфраструктуре.
[06:55.440 --> 06:57.440]  То есть мы пишем огромную файловую систему, чтобы
[06:57.440 --> 06:59.760]  хранить в ней все данные нашей компании.
[06:59.760 --> 07:01.680]  Вот будет неприятно, если мы подадим несколько лет,
[07:01.680 --> 07:04.320]  а потом поймем, что мы провалились на стадии дизайна.
[07:04.320 --> 07:07.960]  Так что стадия дизайн-ребью критически важна.
[07:07.960 --> 07:14.640]  Вот давайте я покажу вам дизайн-дог более актуальный.
[07:14.640 --> 07:19.880]  Это дизайн-дог транзакций и экзектифанс-семантики в Кавке.
[07:19.880 --> 07:21.720]  Кавка у нас будет в другом курсе.
[07:21.720 --> 07:25.920]  Это система, которая реализует персистентную очередь сообщения,
[07:25.920 --> 07:28.680]  то есть позволяет продюсерам и консюмерам обмениваться
[07:28.680 --> 07:29.840]  большими потоками данных.
[07:29.840 --> 07:36.600]  И в какой-то момент в этой системе потребовались
[07:36.600 --> 07:37.600]  транзакции.
[07:37.600 --> 07:41.080]  То есть мы хотим автомарно отправлять сообщения сразу
[07:41.080 --> 07:43.360]  в несколько экологических потоков, не связанных между
[07:43.360 --> 07:44.360]  собой.
[07:44.360 --> 07:49.200]  Ну или, что примерно то же самое, экзектифанс-семантика,
[07:49.200 --> 07:52.600]  но сейчас про это говорить подробно невозможно.
[07:52.600 --> 07:55.960]  Ну, суть в том, что вот был написан дизайн-дог очень
[07:55.960 --> 07:56.960]  большой.
[07:56.960 --> 07:57.960]  Вот тут 67 страниц.
[07:57.960 --> 08:00.600]  Точнее даже не то, чтобы один дизайн-дог, а как бы
[08:00.600 --> 08:06.400]  итерации дизайн-документа, который вот… дизайн-документ
[08:06.400 --> 08:08.640]  развивался с течением времени, ну вот примерно там, не знаю,
[08:08.640 --> 08:09.640]  год или полтора.
[08:09.640 --> 08:10.640]  Вот.
[08:10.640 --> 08:15.800]  И в случае с этой системой дизайн-ребью было публичным.
[08:15.800 --> 08:20.320]  Ну, то есть люди со всего интернета могли прийти,
[08:20.320 --> 08:22.840]  читать этот глугодог и там комментировать, и остались
[08:22.840 --> 08:24.800]  какие-то, не знаю, замечания, идеи.
[08:24.800 --> 08:29.080]  Вот этот процесс длился достаточно длительное время,
[08:29.080 --> 08:32.080]  и потом в конце концов дизайн зафиксировали и пошли
[08:32.080 --> 08:33.080]  его писать.
[08:33.080 --> 08:36.800]  Вообще, процесс должен быть хорошо знакомым вам,
[08:36.800 --> 08:39.600]  в смысле вот дизайн-ребью, потому что, скажем, любой
[08:39.600 --> 08:41.920]  язык программирования развивается по тем же самым
[08:41.920 --> 08:42.920]  законам.
[08:42.920 --> 08:48.720]  Вот, не знаю, вы Google хотите добавить в Go-дженерики,
[08:48.720 --> 08:50.840]  и вы пишете дизайн-документ.
[08:50.840 --> 08:53.800]  И вот с дженериками в Го, кажется, была точно такая же
[08:53.800 --> 08:54.800]  ситуация.
[08:54.800 --> 08:57.480]  Дизайн-документ написали, а потом его публично обсуждали.
[08:57.480 --> 09:07.320]  Ну, или в языке Rust в позапрошлом году добавляли AsyncAwait.
[09:07.320 --> 09:10.520]  Ну, что-то похожее на коротина C++.
[09:10.520 --> 09:18.520]  И там тоже были разные стадии дизайн-документы и публичное
[09:18.520 --> 09:19.520]  обсуждение.
[09:19.520 --> 09:20.520]  Ну, вот для этого...
[09:20.520 --> 09:23.520]  Почему это Swift?
[09:24.240 --> 09:28.000]  Неправильные ссылки.
[09:28.000 --> 09:29.000]  Непорядок.
[09:29.000 --> 09:30.000]  Вот.
[09:30.000 --> 09:35.920]  Для таких обсуждений у Rust есть просто свои собственные
[09:35.920 --> 09:39.920]  форумы, где можно обсуждать те или иные пропозалы.
[09:39.920 --> 09:46.040]  Ну, совершенно стандартная история, знакомая вам для
[09:46.040 --> 09:47.800]  языков программирования, вот то же самое происходит
[09:47.800 --> 09:48.800]  в распределённых системах.
[09:49.080 --> 09:54.600]  Ну, в разработке любых крупных проектов.
[09:54.600 --> 09:57.000]  Распределённых систем особенно, потому что...
[09:57.000 --> 09:59.800]  Ну, в чём сложность распределённых систем?
[09:59.800 --> 10:04.400]  В том, что они пишутся долго, и в том, что в них много
[10:04.400 --> 10:06.720]  недетерминизма, много конкарнсия.
[10:06.720 --> 10:09.600]  И вот такие вещи одному человеку в голове уж тем
[10:09.600 --> 10:12.160]  более сложно очень превалидировать.
[10:12.160 --> 10:14.240]  Нужно, чтобы на его дизайн посмотрели другие люди.
[10:14.680 --> 10:19.680]  Ну вот, такая задача.
[10:19.680 --> 10:21.480]  Проводим мы дизайн-ревью.
[10:21.480 --> 10:24.920]  Там показываем вот такие документы, обсуждаем такие
[10:24.920 --> 10:28.640]  документы, смотрим на вот такие вот картинки и принимаем
[10:28.640 --> 10:29.640]  решение.
[10:29.640 --> 10:30.640]  Всё, идём писать систему.
[10:30.640 --> 10:36.920]  Вот в таком подходе есть некоторая уязвимость.
[10:36.920 --> 10:41.440]  Понятно ли она?
[10:41.640 --> 10:47.000]  Ну, наверное, мы не можем предугадать сразу какие-то
[10:47.000 --> 10:50.640]  небольшие детали реализации, которые вообще могут в принципе
[10:50.640 --> 10:52.640]  как-то повлиять на...
[10:52.640 --> 10:56.240]  Ну, смотри, какие-то небольшие детали реализации могут
[10:56.240 --> 10:59.320]  повлиять, но скорее, я бы сказал, что не могут.
[10:59.320 --> 11:02.840]  Они могут повлиять, в смысле, какого масштаба детали
[11:02.840 --> 11:03.840]  ты...
[11:03.840 --> 11:05.440]  Про какого масштаба детали ты говоришь?
[11:05.440 --> 11:08.640]  Вот скажем, мы долго обсуждаем, что если мы вот положили
[11:08.640 --> 11:10.960]  в основу системы консенсус, то мы сможем добиться
[11:10.960 --> 11:11.960]  реализуемости.
[11:11.960 --> 11:13.640]  А если мы хотим добиться реализуемости, то нам в
[11:13.640 --> 11:15.360]  обратную сторону необходимо иметь консенсус.
[11:15.360 --> 11:17.640]  И вот если мы задумали, что у нас система что-то там
[11:17.640 --> 11:21.480]  упорядочивает, но при этом внутри консенсус не использует,
[11:21.480 --> 11:24.400]  ну, например, мы решили написать GFS, вот так это
[11:24.400 --> 11:28.040]  написано в статье, то, конечно же, мы ни на что рассчитывать
[11:28.040 --> 11:29.040]  не можем.
[11:29.040 --> 11:31.440]  Но я бы не сказал, что вот такую деталь трудно не заметить.
[11:31.440 --> 11:36.640]  Как бы очень трудно понять, что GFS, очень не трудно понять,
[11:36.640 --> 11:40.840]  что GFS необходима для бродкаст на уровне перезапись,
[11:40.840 --> 11:42.160]  на уровне перезапись отдельных чанков.
[11:42.160 --> 11:48.240]  То есть, скорее, наш курс как раз про это, про то, что
[11:48.240 --> 11:50.400]  какие-то важные свойства распределенных систем,
[11:50.400 --> 11:52.560]  они зависят от каких-то больших задач, которые сложно
[11:52.560 --> 11:53.560]  просмотреть.
[11:53.560 --> 12:01.600]  Ну, конечно, можно сказать, что мы обсуждаем здесь
[12:01.600 --> 12:04.240]  не такой, как бы не то чтобы прямо высокоуровневый
[12:04.240 --> 12:06.760]  дизайн, мы можем обсуждать реализацию какого-то отдельного
[12:06.760 --> 12:09.480]  компонента, и там такие проблемы уже могут быть.
[12:09.480 --> 12:12.840]  Но на уровне дизайн-ревью нас, наверное, не интересует,
[12:12.840 --> 12:19.080]  ну, не знаю, используем ли мы где-то в коде там, не
[12:19.080 --> 12:22.360]  знаю, вектор или дек, что будет лучше работать у нас.
[12:22.360 --> 12:23.800]  Конечно, нам такие частности не важны.
[12:23.800 --> 12:30.880]  Проблема, о которой я хочу сказать такая, вот картинки
[12:30.880 --> 12:35.040]  и такой дизайн-документ, такой вот текст на английском
[12:35.040 --> 12:38.800]  языке, он хорош, пока люди его понимают одинаково.
[12:38.800 --> 12:43.640]  Но такое происходит не всегда.
[12:43.640 --> 12:48.400]  Вот я вам показывал на лекции про Singular Greek Access, статью
[12:48.400 --> 12:51.280]  по Access Made Simple, и там вот, и показывал вопрос на Stackoverflow,
[12:51.280 --> 12:53.880]  где какой-то человек обнаружил, что там есть какая-то неоднозначность,
[12:53.880 --> 12:57.280]  какая это неоднозначность, и интерпретировав какое-то
[12:57.280 --> 13:00.440]  предложение на английском языке неправильно, можно
[13:00.440 --> 13:01.440]  получить некорректный алгоритм.
[13:01.440 --> 13:04.960]  Ну, наверное, если вы понимаете, что происходит, вы интерпретируете
[13:04.960 --> 13:08.320]  его правильно, и обо всем вы сами догадаетесь, но
[13:08.320 --> 13:11.840]  мы бы хотели такие неоднозначности устранить.
[13:11.840 --> 13:17.480]  Вот естественный язык нам в этом не помогает, потому
[13:17.480 --> 13:23.320]  что естественный язык по устроению неоднозначно,
[13:23.320 --> 13:25.200]  мы не можем эту неоднозначность из него исключить.
[13:25.200 --> 13:31.360]  Ну, можно поступить альтернативным способом, если мы хотим
[13:31.360 --> 13:34.520]  объяснить людям дизайн так, чтобы они ни в чем не
[13:34.520 --> 13:36.000]  сомневались, мы можем написать код.
[13:37.000 --> 13:39.360]  Ну, в конце концов, вы говорите, например, соседу,
[13:39.360 --> 13:41.960]  как работает merge sort, делим массив пополам, сортируем
[13:41.960 --> 13:43.800]  левую часть, сортируем правую, потом сливаем.
[13:43.800 --> 13:46.920]  Ну, вроде бы все понятно, но если вы увидите код,
[13:46.920 --> 13:48.920]  вам будет гораздо проще разобраться, что именно
[13:48.920 --> 13:50.960]  происходит, и как именно все работает, как именно
[13:50.960 --> 13:51.960]  сливается.
[13:51.960 --> 13:55.080]  Или мы говорим в коэксорте, делим массив каким-то
[13:55.080 --> 13:58.440]  ведущим элементом на две части, тут же великая множество
[13:58.440 --> 14:03.000]  вариаций, как это можно сделать, ну и большое количество
[14:03.000 --> 14:04.760]  возможностей ошибиться в этой процедуре.
[14:04.760 --> 14:10.160]  Так что, как говорил Linux, покажите мне код, вот гораздо
[14:10.160 --> 14:12.840]  приятнее посмотреть на код, но в распределенной системе
[14:12.840 --> 14:15.640]  мы не можем сразу написать код, конечно же, это займет
[14:15.640 --> 14:18.440]  несколько лет, но не знаю, мы могли бы написать для
[14:18.440 --> 14:22.080]  каких-то ключевых компонентов, ну какую-то маленькую, референсную,
[14:22.080 --> 14:23.560]  упрощенную, неэффективную реализацию.
[14:23.560 --> 14:28.640]  Ну, такой proof of concept, что вот в принципе такое можно
[14:28.640 --> 14:29.640]  было бы сделать.
[14:30.560 --> 14:37.160]  Ну, это, конечно, немалые усилия, и мы получаем
[14:37.160 --> 14:38.160]  проблемы другого рода.
[14:38.160 --> 14:41.280]  Вот текст на английском языке, на любом естественном
[14:41.280 --> 14:46.080]  языке неоднозначен, код программы очень однозначен,
[14:46.080 --> 14:49.280]  но в нем появляется очень много деталей, которые нерелевантны
[14:49.280 --> 14:50.280]  дизайну.
[14:50.280 --> 14:52.600]  Ну, вот если мы пишем какой-нибудь, если мы используем какой-то
[14:52.600 --> 14:54.400]  контейнер в коде, то вот мы смотрим на этот код и
[14:54.400 --> 14:56.920]  думаем, а этот контейнер здесь важен или он просто
[14:56.920 --> 14:59.320]  выбран спонтанно, потому что нужно было что-то написать.
[15:00.200 --> 15:01.200]  Вот.
[15:01.200 --> 15:03.520]  Ну, не знаю, нам нужно думать про локации памяти, нам
[15:03.520 --> 15:08.880]  нужно думать про… ну, в общем, появляются какие-то
[15:08.880 --> 15:11.640]  инженерные детали, как именно вы на языке эту реализацию
[15:11.640 --> 15:15.400]  напишете, ну, потому что язык заставляет вас использовать
[15:15.400 --> 15:17.880]  довольно низкий уровень абстракции относительно
[15:17.880 --> 15:26.320]  вашего дизайна, и вы делаете больше, чем нужно.
[15:26.320 --> 15:31.320]  Так что и язык программирования, и дизайн Doki несовершенны.
[15:31.320 --> 15:36.240]  Ну, как, вернее, если вас смущает, что в вашей референсной
[15:36.240 --> 15:39.560]  реализации упрощенной будет много каких-то инженерных
[15:39.560 --> 15:42.360]  подробностей, неважных для вашей системы, например,
[15:42.360 --> 15:44.520]  вы выбрали там, не знаю, карутины вместо файберов
[15:44.520 --> 15:48.960]  или колбеки вместо файберов или акторы, что-нибудь такое.
[15:48.960 --> 15:51.840]  Это же для дизайна, скорее всего, неважно, ну, может
[15:51.840 --> 15:55.320]  быть, тоже важно, но, допустим, на данном уровне абстракции
[15:55.320 --> 15:57.760]  не важно, а вам нужно какой-то код написать.
[15:57.760 --> 15:58.760]  Поэтому, ну, что вы можете делать?
[15:58.760 --> 16:01.160]  Вы можете написать комментарии к этому коду, что, ну, вот,
[16:01.160 --> 16:04.960]  не обращайте на это внимания, вот, главное, что, вот, в
[16:04.960 --> 16:10.320]  общем, понятно, что комментарии полезны в коде, но, как бы,
[16:10.320 --> 16:12.640]  на стадии дизайна, где все очень подвижно и все часто
[16:12.640 --> 16:15.640]  меняется, комментарии запросто могут с кодом разойтись.
[16:15.640 --> 16:17.200]  Ну, и комментарии вообще, в принципе, так себе в форме
[16:17.200 --> 16:18.200]  документации.
[16:18.200 --> 16:23.440]  Далеко не идеально для задач дизайна.
[16:23.440 --> 16:29.800]  Ну, вот, у нас есть дизайн-док на языке, не знаю, человеческом
[16:29.800 --> 16:33.120]  каком-то, и есть программа на языке программирования.
[16:33.120 --> 16:37.760]  И вот и то, и другое в качестве описания дизайна не совсем
[16:37.760 --> 16:38.760]  нам подходит.
[16:38.760 --> 16:45.320]  Нужно что-то более строгое, чем естественный язык,
[16:45.320 --> 16:49.240]  и все же не такое подробное, не такое детальное, как код
[16:49.240 --> 16:50.240]  на языке программирования.
[16:50.240 --> 16:54.200]  Ну, как вы, не знаю, изучаете алгоритмы?
[16:54.200 --> 16:57.480]  Наверное, вам показывают какой-то псевдокод, на доске
[16:57.480 --> 16:58.480]  его пишут, например.
[16:58.480 --> 17:01.880]  Вряд ли вы в алгоритм изучаете прямо сразу на C++, по реализации
[17:01.880 --> 17:02.880]  на C++.
[17:02.880 --> 17:03.880]  Вот.
[17:03.880 --> 17:08.920]  Ну, псевдокод тоже инструмент далекий от идеала, потому
[17:08.920 --> 17:14.080]  что вы, наверное, заметили в своей жизни уже, что сколько
[17:14.080 --> 17:17.520]  книг по алгоритмам, столько вариантов псевдокода существует.
[17:17.680 --> 17:19.000]  Каждый автор изобретает свой.
[17:19.000 --> 17:25.720]  И получается, что вам заодно нужно будет объяснить вместе
[17:25.720 --> 17:27.600]  с своим дизайном этот псевдокод, как он устроен.
[17:27.600 --> 17:31.720]  Псевдокод неформален, вот в чем беда.
[17:31.720 --> 17:39.520]  Хочется в этом месте иметь какой-то большую степень
[17:39.520 --> 17:41.200]  формализма, большую степень строгости.
[17:41.200 --> 17:46.520]  Ну вот, вы представьте, вы строите дом и приходите
[17:46.520 --> 17:49.800]  к строителям и говорите, мне нужна крыша, мне нужна
[17:49.800 --> 17:52.000]  два этажа, мне нужна веранда рядом.
[17:52.000 --> 17:55.720]  Это примерно дизайн-документ, какие компоненты в системе
[17:55.720 --> 17:56.720]  есть.
[17:56.720 --> 17:59.840]  Наверное, вы что-то про них напишете, но по такому
[17:59.840 --> 18:02.120]  дизайн-документу сложно написать код, сложно построить
[18:02.120 --> 18:03.120]  дом.
[18:03.120 --> 18:06.980]  Вот Лэмпард говорит об этом же, что дом невозможно
[18:06.980 --> 18:09.760]  построить без чертежей, вот так же для распределенной
[18:09.760 --> 18:12.960]  системы любого большого проекта вам тоже нужен такой
[18:12.960 --> 18:13.960]  своеобразный чертеж.
[18:14.400 --> 18:18.400]  И этот чертеж – это формальная спецификация.
[18:18.400 --> 18:21.880]  То есть это некоторый формальный вариант псевдокода, формальная
[18:21.880 --> 18:25.000]  система, где у вас есть строгий синтаксис и строгая
[18:25.000 --> 18:26.000]  семантика.
[18:26.000 --> 18:28.800]  И вот если вы придумаете себе такую систему для
[18:28.800 --> 18:33.600]  спецификации вашего дизайна, то ее невозможно будет
[18:33.600 --> 18:36.700]  понять неоднозначно, просто потому что мы говорим про
[18:36.700 --> 18:39.840]  какие-то математические объекты математическим
[18:39.840 --> 18:40.840]  языком.
[18:40.840 --> 18:49.560]  То есть такая спецификация могла бы служить нам в
[18:49.560 --> 18:51.640]  идеальной документации системы.
[18:51.640 --> 18:54.360]  Но давайте я покажу вам, у меня сегодня очень много
[18:54.360 --> 18:57.000]  ссылок открыто, я боюсь у них всех потеряться.
[18:57.000 --> 19:01.160]  Вот мы смотрели с вами алгоритм RAFT не так давно, я вам показывал
[19:01.160 --> 19:05.200]  вот страница с его спецификацией, вот написано, что какие
[19:05.200 --> 19:08.760]  бывают узлы в RAFT, какие сообщения по сети летают
[19:08.760 --> 19:12.680]  и как каждый узел на эти сообщения реагирует.
[19:12.680 --> 19:18.040]  Может быть, эту реализацию можно понять неоднозначно.
[19:18.040 --> 19:24.960]  На этот случай у RAFT есть референсная реализация
[19:24.960 --> 19:33.960]  на C++.
[19:33.960 --> 19:36.000]  Вот иллюстрация тезиса про то, что код может быть
[19:36.000 --> 19:37.000]  слишком подробным.
[19:37.000 --> 19:41.160]  Вот мы говорим handle append-endress, смотрим на обработчик сообщения
[19:41.160 --> 19:45.640]  append-endress и тут какие-то детали про protobuf и какие-то
[19:45.640 --> 19:46.640]  блокировки.
[19:46.640 --> 19:49.880]  Вот в спецификации RAFT ничего нет про блокировки,
[19:49.880 --> 19:53.640]  это детали реализации постороннего протокола репликации,
[19:53.640 --> 19:56.440]  а в реализации они есть, потому что в реализации
[19:56.440 --> 20:01.560]  нужно решать, как выразить конкарнси на уровне языка
[20:01.560 --> 20:02.560]  программирования.
[20:02.560 --> 20:08.000]  Так что вот эта страница, возможно, не слишком формальна.
[20:08.000 --> 20:11.840]  Этот код, возможно, чересчур детализирован деталями
[20:11.840 --> 20:14.360]  конкарнси в языке C++.
[20:14.360 --> 20:19.120]  И ровно поэтому авторы алгоритма RAFT написали вместе
[20:19.120 --> 20:22.040]  и с тем, и с другим еще и спецификацию на языке
[20:22.040 --> 20:25.000]  TLA+, про которую мы сегодня будем говорить.
[20:25.000 --> 20:27.520]  Вот эта спецификация, она, конечно, больше, чем страница
[20:27.520 --> 20:30.000]  кода, тут вот 500 строчек, но с другой стороны, она
[20:30.000 --> 20:35.040]  гораздо меньше, чем реализация на C++, и в отличие от страницы
[20:35.040 --> 20:39.520]  с спецификацией в статье, эта спецификация абсолютно
[20:39.520 --> 20:40.520]  строгая.
[20:40.520 --> 20:48.480]  Сейчас, я вроде бы транслирую экран.
[20:48.480 --> 20:54.640]  То, что вы показываете, это и есть спецификация?
[20:54.640 --> 20:55.640]  Да.
[20:55.640 --> 20:58.760]  Но это же не похоже, смотри, это похоже на псевдокод.
[20:58.760 --> 21:02.760]  Какие-то очень странные символы.
[21:02.760 --> 21:05.200]  Очень странные символы, но мы разберемся, что они
[21:05.200 --> 21:06.200]  значат.
[21:06.200 --> 21:07.200]  Во-первых, они не странные, это вообще конъюнкция.
[21:07.200 --> 21:10.720]  Ты, наверное, такое в своей жизни уже видел.
[21:10.720 --> 21:19.600]  Это что-то такое декларативное очень, и что приятно, вот
[21:19.600 --> 21:23.960]  эта спецификация, ее сложная, если ты знаешь язык TLA+, если
[21:23.960 --> 21:27.960]  ты знаешь, что такое логика, то ты можешь прочесть спецификацию
[21:28.160 --> 21:29.160]  так же, как и я.
[21:29.160 --> 21:30.720]  Ты не сможешь ее прочесть иначе.
[21:30.720 --> 21:38.040]  Вот сегодня мы поговорим, как можно писать такие
[21:38.040 --> 21:39.400]  спецификации, и вообще, как придумать такой вот
[21:39.400 --> 21:41.400]  язык для спецификаций.
[21:41.400 --> 21:46.280]  Мы будем говорить не о формальной спецификации
[21:46.280 --> 21:49.640]  вообще, а о спецификации на конкретном языке, который
[21:49.640 --> 21:50.640]  придумал Лесли Лэмпард.
[21:50.640 --> 21:53.520]  Это язык TLA+.
[21:53.520 --> 21:57.080]  Почему именно он?
[21:57.200 --> 22:00.280]  Потому что это самый востребованный индустрией инструмент.
[22:00.280 --> 22:05.320]  Вот давайте я покажу вам статью, которую написали
[22:05.320 --> 22:15.520]  в Amazon, в дареком уже 2014 году, про то, что это статья,
[22:15.520 --> 22:20.720]  которую писали инженеры облака Amazon, и, конечно, они
[22:20.720 --> 22:24.360]  пишут нагруженные конкурентные распределенные системы.
[22:24.360 --> 22:27.040]  И вот они говорят, мы используем дизайн-ревью, мы используем
[22:27.040 --> 22:29.600]  код-ревью, мы используем статический анализ кода,
[22:29.600 --> 22:32.920]  мы используем стресс-тесты, мы используем fault injection.
[22:32.920 --> 22:38.520]  Но все равно этого не хватает по разным причинам.
[22:38.520 --> 22:42.920]  Мы пишем сложные конкурентные и отказоустойчивые системы.
[22:42.920 --> 22:48.040]  И, конечно же, люди, которые валидируют дизайн тех
[22:48.040 --> 22:50.480]  или иных компонентов, там протоколы репликации,
[22:50.480 --> 22:53.680]  они не могут в голове перебрать все возможные исполнения.
[22:53.680 --> 22:56.280]  Вот, а fault injection, он тоже не обеспечивает полное
[22:56.280 --> 23:00.560]  покрытие всех возможных сценариев.
[23:00.560 --> 23:06.640]  Поэтому мы хотим решить две задачи, на самом деле,
[23:06.640 --> 23:07.640]  на месте инженеров Amazon.
[23:07.640 --> 23:11.600]  Во-первых, мы хотим иметь язык для спецификации для
[23:11.600 --> 23:14.360]  того, чтобы просто документировать наш дизайн максимально
[23:14.360 --> 23:15.360]  строго.
[23:15.360 --> 23:21.960]  Вот, об этом они писали и в своей недавней статье,
[23:21.960 --> 23:26.800]  уже 20-го, кажется, года, миллионы маленьких баз данных
[23:26.800 --> 23:27.800]  про...
[23:27.800 --> 23:30.520]  В общем, неважно даже сейчас, что это за система, которую
[23:30.520 --> 23:31.520]  они здесь пишут.
[23:31.520 --> 23:40.480]  Важно, что они используют CLI plus по двум причинам.
[23:40.480 --> 23:46.920]  Во-первых, спецификация на CLI plus – это просто хорошая
[23:46.920 --> 23:51.280]  форма документации распределенных протоколов, а во-вторых,
[23:51.400 --> 23:53.760]  если вы смогли описать свой дизайн на некотором
[23:53.760 --> 24:00.480]  формальном языке, то, ну, его, если это язык формальный,
[24:00.480 --> 24:03.160]  то его может читать уже не только человек, а еще и
[24:03.160 --> 24:04.160]  компьютер.
[24:04.160 --> 24:07.600]  И для такой спецификации можно написать model checker,
[24:07.600 --> 24:11.760]  то есть программу, которая по этой спецификации, в
[24:11.760 --> 24:16.040]  которой описана система и описаны ее свойства, может
[24:16.040 --> 24:18.680]  механически проверить, что система удовлетворяет
[24:18.680 --> 24:19.680]  этим свойствам.
[24:20.080 --> 24:23.880]  Но это не совсем доказательство, скорее, это полный перебор,
[24:23.880 --> 24:26.240]  то есть мы можем перебрать все возможные достижимые
[24:26.240 --> 24:28.560]  состояния системы и проверить, что свойства исполняются
[24:28.560 --> 24:31.280]  во всех состояниях или на всех возможных траекториях
[24:31.280 --> 24:32.280]  поведениях.
[24:32.280 --> 24:36.680]  Вот, но, тем не менее, это второй важный бонус, который
[24:36.680 --> 24:40.560]  мы, используя формальную спецификацию, получаем.
[24:40.560 --> 24:43.400]  Мы можем использовать model checker, и для CLI plus, конечно
[24:43.400 --> 24:47.840]  же, model checker есть, он называется TLC.
[24:47.840 --> 24:54.880]  Никто не знает, что значит TLC, расшифровка этого сокращения
[24:54.880 --> 24:55.880]  утрачена.
[24:55.880 --> 25:01.960]  Но, тем не менее, вот этот model checker, что он позволил
[25:01.960 --> 25:06.160]  сделать в Амазоне еще в 2013-14 году.
[25:06.160 --> 25:11.160]  Вот пример систем, который инженеры специфицировали
[25:11.160 --> 25:17.600]  и валидировали, верифицировали с помощью model checker для
[25:17.600 --> 25:19.560]  CLI plus.
[25:19.560 --> 25:21.880]  Самые разные компоненты, самые разные системы, от
[25:21.880 --> 25:26.920]  каких-то логов и структур данных до протоколов, репликаций
[25:26.920 --> 25:28.200]  и каких-то сетевых патоколов.
[25:28.200 --> 25:32.080]  И вот, пожалуйста, размер спецификации, который был
[25:32.080 --> 25:35.680]  получен, ну и везде он несоизмерим, конечно, с объемом кода,
[25:35.680 --> 25:37.520]  который нужно было в том или ином компоненте написать.
[25:37.520 --> 25:43.280]  И при этом эти спецификации и model checker помогли найти
[25:43.280 --> 25:47.560]  какие-то баги, ну или убедиться, наоборот, что их нет, и мы
[25:47.560 --> 25:50.440]  дальше можем использовать эту страшную логовую структуру
[25:50.440 --> 25:51.440]  данных.
[25:51.440 --> 26:01.440]  Вот, наша задача сегодня разобраться с этими инструментами,
[26:01.440 --> 26:03.560]  поговорить про то, что уже придумал Лесли Лэмбард
[26:03.560 --> 26:07.080]  и как можно с помощью такого инструмента описывать
[26:07.080 --> 26:10.280]  и протоколы репликации, и какие-то, и более крупный
[26:10.280 --> 26:11.280]  дизайн.
[26:11.280 --> 26:18.560]  Вообще, Лесли Лэмбард придумал это все давным-давно, и
[26:18.560 --> 26:23.520]  его не интересовала задача верификации, ему нужен был
[26:23.520 --> 26:27.200]  способ просто строго излагать свои алгоритмы, и он придумывал
[26:27.200 --> 26:28.200]  язык для себя.
[26:28.200 --> 26:32.320]  Ну и уже позже для него написали model checker и стали
[26:32.320 --> 26:36.400]  использовать в индустрии для верификации какого-то
[26:36.400 --> 26:37.400]  промышленного дизайна.
[26:37.400 --> 26:46.120]  Ну и, конечно, да, Amazon это не единственный пример компании,
[26:46.120 --> 26:51.080]  которая использует формальные методы при разработке своих
[26:51.080 --> 26:52.080]  систем.
[26:52.080 --> 26:57.360]  Сейчас, после этой статьи, спецификации стали более-менее
[26:57.360 --> 27:04.680]  общим местом, и, скажем, если мы посмотрим на какую-то
[27:04.680 --> 27:10.440]  современную базу данных, TitaniumDB, то у них есть репозитории,
[27:10.440 --> 27:15.720]  где они формально описали, ну, там RAFT и какие-то его
[27:15.720 --> 27:18.360]  вариации, и протокол распределенных транзакций.
[27:18.360 --> 27:24.880]  Вот можем пойти в этот репозиторий и посмотреть на какую-то
[27:24.880 --> 27:29.280]  спецификацию размера, ну, такого среднего размера,
[27:29.280 --> 27:30.280]  400 строчек.
[27:31.280 --> 27:34.280]  Вот, как РОЧДБ, который я упоминал в самом начале,
[27:34.280 --> 27:36.280]  для него тоже есть спецификация.
[27:36.280 --> 27:41.280]  Ну вот, можно открыть, сейчас найду, их пост про транзакции,
[27:41.280 --> 27:43.280]  про дизайн транзакции в их инженерном блоге.
[27:48.280 --> 27:54.280]  И там они ссылаются на свою реализацию, свою спецификацию
[27:54.280 --> 27:55.280]  этого протокола.
[28:00.280 --> 28:18.280]  Вот это такой приятный довес к этому дизайн-документу
[28:18.280 --> 28:20.280]  и вот к секции про транзакции.
[28:20.280 --> 28:25.280]  Конечно, никто вас не заставляет спецификацию расшифровывать
[28:25.280 --> 28:27.280]  с нуля, не понимая, что у них происходит.
[28:27.280 --> 28:29.280]  Скорее вы читаете спецификацию, после того вы прочтете
[28:29.280 --> 28:33.280]  документ на естественном языке и уже более-менее будете
[28:33.280 --> 28:38.280]  понимать, из каких компонентов, деталей состоит система
[28:38.280 --> 28:40.280]  или алгоритм какой-то.
[28:40.280 --> 28:43.280]  Но для того, чтобы добиться строгого формального
[28:43.280 --> 28:46.280]  понимания, вам все-таки нужно читать его спецификацию
[28:46.280 --> 28:48.280]  на языке тела и плюс.
[28:48.280 --> 28:51.280]  Итак, давайте теперь говорить про то, как этот язык устроен,
[28:51.280 --> 28:54.280]  как устроена спецификация, что это вообще такое.
[28:54.280 --> 28:56.280]  И мы перемещаемся на доску.
[28:58.280 --> 29:02.280]  Итак, мы хотим каким-то образом специфицировать нашу
[29:02.280 --> 29:03.280]  систему строго.
[29:03.280 --> 29:05.280]  Что вообще это значит?
[29:05.280 --> 29:09.280]  Ну, я бы сказал, что мы хотим написать для нее такой
[29:09.280 --> 29:11.280]  строгий стресс-тест.
[29:11.280 --> 29:14.280]  Вот у нас есть некоторый алгоритм, например, алгоритм
[29:14.280 --> 29:16.280]  консенсус, там есть узлы, которые договариваются
[29:16.280 --> 29:17.280]  в общем значении.
[29:17.280 --> 29:21.280]  Так вот, мы не будем описывать сам алгоритм в вакууме,
[29:21.280 --> 29:26.280]  мы строго опишем тест, в котором есть, скажем, три
[29:26.280 --> 29:29.280]  узла, и они обмениваются сообщениями и с помощью
[29:29.280 --> 29:32.280]  протокола Paxos договариваются об общем выборе.
[29:32.280 --> 29:37.280]  То есть у нас есть некоторый такой мир, некоторая система
[29:41.280 --> 29:44.280]  и набор свойств.
[29:51.280 --> 29:53.280]  Вот эта спецификация.
[29:53.280 --> 29:56.280]  Давайте теперь думать, как эта спецификация должна
[29:56.280 --> 29:57.280]  быть устроена.
[29:57.280 --> 30:01.280]  То есть как мы опишем строго, на каком формальном языке
[30:01.280 --> 30:05.280]  мы опишем систему нашу и на каком формальном языке
[30:05.280 --> 30:08.280]  мы опишем свойства этой системы.
[30:11.280 --> 30:15.280]  Вспомним лекции про невозможность консенсус и про теорему
[30:15.280 --> 30:16.280]  FLP.
[30:16.280 --> 30:19.280]  Там мы говорили про произвольный алгоритм консенсуса
[30:19.280 --> 30:22.280]  и показывали, что у него обязательно есть лайфлог.
[30:22.280 --> 30:25.280]  Для того, чтобы говорить про произвольный алгоритм,
[30:25.280 --> 30:30.280]  мы этот алгоритм заменили в уме на граф конфигурации.
[30:37.280 --> 30:40.280]  Мы сказали, что у нас есть направленный граф,
[30:40.280 --> 30:44.280]  где каждая вершина конфигурация это
[30:47.280 --> 30:51.280]  снимок текущего состояния всего исполнения.
[30:51.280 --> 30:54.280]  Это состояние сети, то есть те сообщения, которые были
[30:54.280 --> 30:57.280]  отправлены узлами, но еще не получены адресатами
[30:57.280 --> 31:01.280]  и находятся в проводах, плюс состояние каждого узла.
[31:01.280 --> 31:04.280]  Вплоть до того, что мы фиксируем их регистры,
[31:04.280 --> 31:07.280]  состояние памяти, состояние жесткого диска,
[31:07.280 --> 31:09.280]  всю эту информацию.
[31:09.280 --> 31:12.280]  Все это вместе составляет конфигурацию.
[31:12.280 --> 31:16.280]  Между конфигурациями были атомарные переходы.
[31:16.280 --> 31:20.280]  Если в этой конфигурации в сети
[31:21.280 --> 31:25.280]  было сообщение М, адресованное узлу П,
[31:29.280 --> 31:32.280]  то мы могли это сообщение доставить
[31:34.280 --> 31:37.280]  и получить новое состояние мира, где изменилось
[31:37.280 --> 31:40.280]  состояние узла, которое сообщение получил,
[31:40.280 --> 31:43.280]  и, возможно, изменилось состояние сети, потому что
[31:43.280 --> 31:46.280]  начало сеть новое сообщение.
[31:46.280 --> 31:50.280]  Все возможные исполнения мы представили в виде графа.
[31:50.280 --> 31:54.280]  Каждая траектория в этом графе – это какое-то конкретное исполнение.
[31:54.280 --> 31:57.280]  И это конкретное исполнение в те времена ФЛП
[31:57.280 --> 32:00.280]  выбирала отверсия, который стремился алгоритм
[32:00.280 --> 32:02.280]  загнать в лайфлог.
[32:04.280 --> 32:10.280]  В спецификации сама система описывается примерно таким же образом.
[32:11.280 --> 32:14.280]  Как именно это представить в языке,
[32:14.280 --> 32:17.280]  в смысле как мы именно описываем этот граф,
[32:17.280 --> 32:20.280]  мы отложим этот вопрос на будущее.
[32:20.280 --> 32:23.280]  А пока поговорим про свойства.
[32:23.280 --> 32:26.280]  Я напомню, что нас не интересуют все возможные свойства,
[32:26.280 --> 32:28.280]  которые только можно вообразить.
[32:28.280 --> 32:32.280]  Свойства относительно алгоритма, вернее, этого графа,
[32:32.280 --> 32:35.280]  который по этому алгоритму порождается
[32:35.280 --> 32:38.280]  для какой-то фиксированного числа узлов,
[32:38.280 --> 32:41.280]  который в консенсусе участвует.
[32:41.280 --> 32:44.280]  Свойства нас интересуют как правило двух типов.
[32:44.280 --> 32:49.280]  Свойства safety и свойства liveness.
[32:52.280 --> 32:55.280]  Первый класс свойств о том, что не происходит ничего плохого,
[32:55.280 --> 32:59.280]  и liveness свойств о том, что eventually происходит что-то хорошее.
[32:59.280 --> 33:03.280]  Эти свойства – это утверждение про нашу…
[33:03.280 --> 33:06.280]  На всякий случай я поясню еще раз.
[33:06.280 --> 33:10.280]  То есть эта система не имеется в виду, что распределенная система база данных,
[33:10.280 --> 33:15.280]  а имеется в виду такой мир, в котором есть участники,
[33:15.280 --> 33:19.280]  которые реализуют некий протокол.
[33:19.280 --> 33:22.280]  Это может быть буквально распределенная система с клиентами,
[33:22.280 --> 33:26.280]  или это могут быть узлы, которые решают задачу консенсуса.
[33:26.280 --> 33:30.280]  И вот эту систему, этот мир я изображаю в виде графа конфигурации
[33:30.280 --> 33:35.280]  с какими-то атомарными переходами, видимо, по доставке сообщений.
[33:35.280 --> 33:39.280]  А дальше мы про эту систему строим какие-то утверждения.
[33:39.280 --> 33:42.280]  Мы говорим, что с ней не происходит никогда ничего плохого,
[33:42.280 --> 33:46.280]  или что с ней происходит нечто хорошее рано или поздно.
[33:46.280 --> 33:51.280]  Вот эти утверждения вроде бы в общем про систему,
[33:51.280 --> 33:55.280]  но можно сказать чуть локальнее.
[33:55.280 --> 33:59.280]  Вот safety свойства – это, например, что…
[33:59.280 --> 34:03.280]  Представим себе, что у нас система – это мьютекс по разделению памяти
[34:03.280 --> 34:06.280]  и несколько потоков.
[34:06.280 --> 34:10.280]  И мы хотим убедиться, что мьютекс гарантирует взаимные исключения.
[34:10.280 --> 34:14.280]  Например, safety свойства – это взаимные исключения.
[34:14.280 --> 34:19.280]  Вот взаимные исключения в терминах этого графа – это утверждение про что?
[34:22.280 --> 34:26.280]  Ну, про весь граф разом или про…
[34:29.280 --> 34:33.280]  Про какую структуру в этом графе?
[34:36.280 --> 34:41.280]  Вот если мы говорим про мьютекс и потоки, то каждая конфигурация фиксирует
[34:41.280 --> 34:46.280]  некоторую точку у исполнения, то есть инструкцион-поинтер каждого потока
[34:46.280 --> 34:51.280]  и состояние разделяемой памяти, в том числе там какие-то ячейки внутри этого мьютекса.
[34:52.280 --> 34:56.280]  Вот утверждение взаимного исключения.
[34:56.280 --> 35:00.280]  Свойства взаимного исключения.
[35:02.280 --> 35:06.280]  Во-первых, это свойство safety, мы, наверное, понимаем все.
[35:06.280 --> 35:10.280]  Это утверждение, что ни в какой момент времени не бывает такого,
[35:10.280 --> 35:14.280]  что два потока одновременно находятся в критической секции.
[35:15.280 --> 35:19.280]  Это утверждение про весь граф или про что?
[35:19.280 --> 35:23.280]  Итак, вопрос мой понятен был.
[35:24.280 --> 35:28.280]  У нас есть система, например, это потоки, которые пытаются взять блокировку,
[35:28.280 --> 35:33.280]  и мы рисуем граф всех возможных состояний в таком исполнении,
[35:33.280 --> 35:36.280]  где у нас есть четыре потока и один мьютекс.
[35:36.280 --> 35:41.280]  Мы говорим, что для такой системы мы формулируем свойства взаимного исключения.
[35:41.280 --> 35:48.280]  То есть не может быть такого, что два потока находятся одновременно в критической секции.
[35:49.280 --> 35:52.280]  Вот это свойство взаимного исключения.
[35:52.280 --> 35:57.280]  Это утверждение про весь граф в целом, про отдельные его пути, про что.
[35:59.280 --> 36:05.280]  Это утверждение про каждую конфигурацию, про каждый узел этого графа.
[36:07.280 --> 36:13.280]  А если мы говорим про свойства свободы от взаимной блокировки,
[36:13.280 --> 36:18.280]  то есть если у нас мьютекс свободен и его пытаются захватить несколько потоков,
[36:18.280 --> 36:21.280]  то одному из них это удастся.
[36:27.280 --> 36:29.280]  Deadlock freedom.
[36:31.280 --> 36:34.280]  Это ваивное свойство про то, что eventually что-то произойдет.
[36:35.280 --> 36:37.280]  Вот это утверждение про что?
[36:37.280 --> 36:41.280]  Ну, явно уже не про отдельную вершину, не про отдельную конфигурацию.
[36:49.280 --> 36:54.280]  Может, про то, что из каждой вершины есть переход какой-то следующий?
[36:54.280 --> 36:56.280]  Не понятно, как это связано.
[36:58.280 --> 37:03.280]  Переход есть, ты ходишь по бесконечному пути, и в нем ничего хорошего не происходит.
[37:03.280 --> 37:06.280]  Где же этот deadlock freedom? Это deadlock.
[37:10.280 --> 37:14.280]  Возможно отсутствие циклов, но...
[37:15.280 --> 37:18.280]  Что значит отсутствие циклов?
[37:18.280 --> 37:20.280]  Непонятно, что значит отсутствие циклов.
[37:20.280 --> 37:25.280]  Если у тебя есть мьютекс и четыре потока,
[37:31.280 --> 37:36.280]  мьютекс на одной ячейке памяти с флажками 0,1 и 2, если вы помните, можно было такое написать,
[37:36.280 --> 37:39.280]  то в этом графе просто конечное число вершин.
[37:39.280 --> 37:42.280]  Исполнения могут бесконечно долгими быть, если мы напишем
[37:42.280 --> 37:47.280]  несколько потоков, которые будут в цикле wild true захватывать мьютекс и отпускать его.
[37:47.280 --> 37:53.280]  Но цикла там, конечно, будут, потому что состояние мьютекса в состоянии системы повторяется.
[37:55.280 --> 37:57.280]  Вы не понимаете мой вопрос.
[37:57.280 --> 38:01.280]  Свойство взаимного исключения — это утверждение про каждую вершину графа.
[38:01.280 --> 38:09.280]  А свойство прогресса для мьютекса — это утверждение про весь граф разом,
[38:09.280 --> 38:11.280]  утверждение про отдельную вершину и про что.
[38:14.280 --> 38:18.280]  Нет, это утверждение про каждую траекторию в этом графе, про каждый путь.
[38:20.280 --> 38:23.280]  Для каждого пути в этом графе должно выполняться следующее,
[38:23.280 --> 38:31.280]  что в какой-то момент какой-то поток в этом пути, в этой траектории мьютекс захватывает.
[38:33.280 --> 38:38.280]  В том-то и дело, что safety свойства — это утверждение про каждую вершину графа.
[38:38.280 --> 38:41.280]  Live in свойства — это утверждение про каждый путь в графе.
[38:42.280 --> 38:44.280]  И вот только такие свойства нас интересуют.
[38:45.280 --> 38:53.280]  Мы, скажем, не говорим про алгоритм консенсуса, что в графе конфигурации существует путь,
[38:53.280 --> 38:55.280]  в котором кто-то что-то выбирает.
[38:55.280 --> 39:00.280]  Вот такого рода свойства нам бесполезны, что существует путь.
[39:00.280 --> 39:04.280]  Нам интересно говорить про каждую вершину, про каждую точку в исполнении
[39:04.280 --> 39:06.280]  и про каждый путь в этом графе.
[39:08.280 --> 39:12.280]  У нас в графе могут быть циклы?
[39:12.280 --> 39:13.280]  Что?
[39:13.280 --> 39:15.280]  У нас в графе могут быть циклы?
[39:15.280 --> 39:18.280]  Конечно, могут быть циклы. Я же только что привел пример с мьютексами и потоками,
[39:18.280 --> 39:20.280]  где циклы точно будут.
[39:20.280 --> 39:24.280]  Просто потому, что число состояния системы ограничено сверху.
[39:24.280 --> 39:27.280]  У тебя ячейка мьютекса принимает значение 0,1 и 0,2,
[39:27.280 --> 39:32.280]  и instruction pointer потоков тоже чем-то ограничен каким-то набором значений,
[39:32.280 --> 39:34.280]  потому что программа просто конечной длины.
[39:34.280 --> 39:36.280]  Никаких там счетчиков у тебя нет.
[39:36.280 --> 39:38.280]  Вот и все.
[39:38.280 --> 39:40.280]  Нет, циклы здесь не важны.
[39:40.280 --> 39:42.280]  Циклы – это тоже некоторая траектория.
[39:42.280 --> 39:44.280]  Траектория может быть бесконечная.
[39:44.280 --> 39:46.280]  Это абсолютно легально.
[39:50.280 --> 39:51.280]  Вот.
[39:51.280 --> 39:55.280]  Когда мы говорим про TLA, то мы думаем про граф конфигурации и про свойства,
[39:55.280 --> 40:00.280]  и теперь нужно каким-то образом эти свойства записать строго.
[40:00.280 --> 40:04.280]  Нужно как-то граф записать в виде формальной системы с помощью формального языка
[40:04.280 --> 40:06.280]  и свойства записать.
[40:06.280 --> 40:12.280]  Вот давайте начнем со свойств, потому что это будет нам попроще сделать.
[40:12.280 --> 40:17.280]  В теле плюс конфигурации называются состояниями.
[40:20.280 --> 40:24.280]  Каждое состояние описывается набором переменных.
[40:24.280 --> 40:28.280]  Каждое состояние описывается набором переменных.
[40:28.280 --> 40:32.280]  Просто мы говорим, что есть некоторый набор переменных,
[40:32.280 --> 40:36.280]  и каждое назначение значений для этого набора переменных
[40:36.280 --> 40:40.280]  описывает некоторое состояние системы.
[40:42.280 --> 40:48.280]  У нас есть переменный, и мы назначаем им значение.
[40:48.280 --> 40:56.280]  И вот для каждого состояния мы должны иметь возможность что-то про него утверждать.
[40:56.280 --> 41:01.280]  Нам пока не важно, что именно это за переменные, какой у них смысл.
[41:01.280 --> 41:06.280]  Мы сейчас говорим про то, как построить сам язык для таких утверждений.
[41:06.280 --> 41:10.280]  Ну а как мы обычно формулируем утверждения строго?
[41:10.280 --> 41:13.280]  Какой у нас для этого инструмент есть?
[41:19.280 --> 41:22.280]  Еще раз, мы сейчас говорим про язык.
[41:22.280 --> 41:25.280]  Как мы формулируем строго утверждения?
[41:25.280 --> 41:29.280]  Не знаю, в математике как мы строго формулируем утверждения?
[41:29.280 --> 41:32.280]  Еще раз возьмем, мы используем логику.
[41:32.280 --> 41:35.280]  Возможно, формально логично.
[41:35.280 --> 41:37.280]  Да, ну вот мы к этому и идем.
[41:37.280 --> 41:41.280]  У нас свойство это некоторые утверждения, некоторые логики.
[41:41.280 --> 41:44.280]  Нужно только подходящую логику выбрать.
[41:44.280 --> 41:48.280]  Явно логика высказывания достаточно бедна для наших целей.
[41:48.280 --> 41:51.280]  Мы там ничего содержательно сказать не можем.
[41:51.280 --> 41:56.280]  Но есть более богатые, более выразительные системы.
[41:59.280 --> 42:03.280]  Ну вот представьте перед вами задача, скажем, формализовать математику.
[42:05.280 --> 42:09.280]  Вам надоело говорить это очевидно, и вы хотите что-то строго записать.
[42:09.280 --> 42:11.280]  Что вы для этого делаете?
[42:15.280 --> 42:18.280]  Вы используете...
[42:19.280 --> 42:21.280]  Мы сейчас не говорим про какую-то...
[42:21.280 --> 42:23.280]  Про логику вообще из каких деталей она состоит.
[42:23.280 --> 42:25.280]  Мы говорим про...
[42:30.280 --> 42:32.280]  Про какой-то конкретный язык.
[42:32.280 --> 42:36.280]  Вот я предлагаю вспомнить вам логику первого порядка.
[42:38.280 --> 42:42.280]  Знакомое явление?
[42:42.280 --> 42:44.280]  В ней вы можете...
[42:47.280 --> 42:49.280]  Что у вас там есть?
[42:52.280 --> 42:55.280]  У любой логики есть синтаксис и семантика.
[42:57.280 --> 42:59.280]  Вы можете строить, во-первых, формулы.
[42:59.280 --> 43:02.280]  Конечно, у вас есть обычные логические связки.
[43:03.280 --> 43:05.280]  Но что у вас еще появляется?
[43:05.280 --> 43:11.280]  У вас появляются некоторые функциональные символы и предикатные символы.
[43:12.280 --> 43:20.280]  И вы можете писать еще и квантор существования, и всеобщности.
[43:25.280 --> 43:34.280]  Правда, не по предикатам, но по элементам некоторого домена, который вы заранее зафиксировали.
[43:35.280 --> 43:37.280]  И вы дальше умеете эти формулы интерпретировать,
[43:37.280 --> 43:47.280]  потому что вы понимаете, каким математическим объектом соответствуют ваши переменные и функции, как они себя ведут.
[43:53.280 --> 43:55.280]  Вы же это все знаете, правда?
[43:57.280 --> 43:58.280]  Вот.
[43:58.280 --> 43:59.280]  Да.
[43:59.280 --> 44:01.280]  Отлично. Тогда можно...
[44:08.280 --> 44:10.280]  Можно привести пример.
[44:12.280 --> 44:18.280]  Какого-то утверждения, который можно в логике первого порядка сформулировать про состояние системы.
[44:19.280 --> 44:22.280]  Вот давайте посмотрим на свойства взаимного исключения.
[44:26.280 --> 44:28.280]  Вот видно вам на экране?
[44:31.280 --> 44:32.280]  Да.
[44:38.280 --> 44:40.280]  Что тут говорится? Что для любых...
[44:40.280 --> 44:46.280]  Ну, тут некоторая такая математическая аскиграфика, но в принципе можно догадаться, что происходит.
[44:46.280 --> 44:55.280]  Тут написано, для любых процессов P1 и P2 из некоторого множества, если P1 не равен P2, вот эта вот решетка означает не равен,
[44:55.280 --> 45:01.280]  то из этого следует, что неверно, что программ-каунтер P1 находится в критической секции,
[45:01.280 --> 45:05.280]  и одновременно с этим программ-каунтер P2 тоже находится в критической секции.
[45:07.280 --> 45:10.280]  Ну вот, пожалуйста, утверждения в логике первого порядка.
[45:12.280 --> 45:15.280]  Вот сам язык позволяет нам такие утверждения формулировать.
[45:15.280 --> 45:19.280]  Это утверждения про какое-то состояние мира. У нас есть переменные.
[45:19.280 --> 45:25.280]  Видимо, есть переменная программ-каунтер, которая описывает точку... точку исполнения,
[45:25.280 --> 45:29.280]  в которой находится каждый из поток, в каждый из процессов, как они здесь называются.
[45:30.280 --> 45:36.280]  И вот мы строим некоторые утверждения про эти переменные. Утверждения выглядят вот таким вот образом.
[45:38.280 --> 45:45.280]  То есть вот такой вот логике нам достаточно, чтобы сформулировать свойства взаимного исключения.
[45:47.280 --> 45:52.280]  Но нам этого недостаточно, чтобы сформулировать свойства лавенеса, свойства прогресса.
[45:53.280 --> 45:59.280]  Потому что логика первого порядка позволяет нам что-то говорить про конкретное состояние системы.
[45:59.280 --> 46:01.280]  Давайте вернемся на доску.
[46:01.280 --> 46:05.280]  Вот мы можем сказать что-то про конкретный кружочек здесь.
[46:06.280 --> 46:09.280]  Но мы же хотим говорить не просто про отдельные моменты исполнения,
[46:09.280 --> 46:11.280]  мы хотим говорить про всю траекторию.
[46:12.280 --> 46:18.280]  Про то, что прямо сейчас, может быть, Ньютексом не владеет никто, но в будущем кто-то завладеет.
[46:19.280 --> 46:23.280]  И вот в наших утверждениях появляется измерение времени.
[46:24.280 --> 46:26.280]  Вот здесь одной логики первого порядка недостаточно,
[46:26.280 --> 46:30.280]  потому что нам нужно это как-то измерение, темпоральное, вводить.
[46:31.280 --> 46:35.280]  Для таких задач существуют другие логики, называются модальными логиками.
[46:36.280 --> 46:40.280]  И конкретно здесь нас будет интересовать темпоральная логика.
[46:40.280 --> 46:44.280]  Смотрите, в логике первого порядка мы интерпретировали формулы
[46:46.280 --> 46:49.280]  на, можно сказать, состояниях нашего мира.
[46:49.280 --> 46:52.280]  Мы брали значения переменных, подставляли их по некоторым правилам,
[46:52.280 --> 46:57.280]  и вычесывали, узнавали формулы выполнения и в Bloomberg'е以前
[46:58.280 --> 47:02.280]  Ward Trainת дivers김ắнила anni во tellement тысячи к來了та,
[47:02.280 --> 47:06.360]  можно сказать, что в состояниях нашего мира. Мы брали значения переменных,
[47:06.360 --> 47:10.640]  подставляли их по некоторым правилам и вычисляли, узнавали, формула выполняется
[47:10.640 --> 47:15.640]  или не выполняется в этом состоянии. В темпоральной логике мы формулируем
[47:15.640 --> 47:22.440]  утверждение и интерпретируем формулы не относительно отдельных состояний, а целых
[47:22.440 --> 47:31.720]  траектории в этом графе. То есть для нас мы оперируем такими объектами.
[47:31.720 --> 47:43.200]  Траектория — это начальное состояние, следующее состояние, следующее состояние и так далее.
[47:43.200 --> 47:48.840]  И формулу, которую мы будем строить, мы будем интерпретировать на таких
[47:49.080 --> 47:55.720]  траекториях. Я бы называть их трейсами, можно называть их, лэмпорт называет их
[47:55.720 --> 48:03.880]  поведениями. Как мы строим темпоральные формулы? Во-первых, мы можем что-то
[48:03.880 --> 48:12.000]  строить утверждение, как и раньше, относительно переменных. Но к этим
[48:12.000 --> 48:16.400]  правилам, к существующему синтаксису, у нас добавляются новые
[48:16.400 --> 48:27.680]  темпоральные операторы. Темпоральных операторов главных три. Вот если phi — это
[48:27.680 --> 48:33.880]  некоторая формула, скажем, утверждения про состояние, то можно написать box phi,
[48:33.880 --> 48:52.680]  это означает всегда. Diamond phi означает eventually. И кружочек phi — это означает next.
[48:55.600 --> 49:03.360]  Как это всё нужно понимать? Вот давайте начнём с некоторой базы. Пусть phi — это
[49:03.360 --> 49:09.440]  утверждение про отдельное состояние. Скажем, phi — это утверждение, что в данном
[49:09.440 --> 49:15.200]  состоянии мы можем вот эту формулу проинтерпретировать на конкретном
[49:15.200 --> 49:18.960]  состоянии, проверить, верно ли, что в этом состоянии потоки не нарушают
[49:18.960 --> 49:23.880]  взаимное исключение. Вот когда мы говорим box phi, то есть добавляем такой вот
[49:23.880 --> 49:29.520]  квадратный темпоральный оператор, то мы говорим, что phi выполняется в каждой
[49:29.520 --> 49:39.800]  точке, в каждой конфигурации из траектории. Это инвариант. То есть если у нас есть
[49:39.800 --> 49:52.960]  цепочка из состояний, то в каждом состоянии выполнена phi. Что означает
[49:52.960 --> 50:04.880]  eventually? Странный вопрос, наверное. Понятно, что означает. Эта формула
[50:04.880 --> 50:11.240]  интерпретируется так. Прямо сейчас phi может быть не выполнена, но где-то в
[50:11.240 --> 50:17.400]  будущем, на каком-то шаге, в какой-то конфигурации цкатой phi всё-таки
[50:17.400 --> 50:20.280]  не должно выполнится.
[50:25.400 --> 50:28.400]  С next ещё проще.
[50:28.400 --> 50:48.840]  Сейчас про это поговорим. Ну, мы вообще-то... Давай прямо сейчас про это поговорим.
[50:48.840 --> 51:07.880]  Вот что такое не always phi? Не всегда phi. Значит, что где-то не phi. Что? Значит, что есть где-то...
[51:07.880 --> 51:17.640]  Это то же самое, что и eventually не phi. Ну вот, так что можно заметить, что
[51:17.640 --> 51:25.440]  отрицание, оно, темпоральный оператор, поворачивает. Можно подумать, что такое не
[51:25.440 --> 51:34.520]  кружок phi. Кружок тоже поворачивается, но не меняется пред. Хорошо.
[51:34.520 --> 51:41.240]  Ну, это такой простой случай, когда phi это формула утверждения про некоторое
[51:41.240 --> 51:48.080]  конкретное состояние. Формула про состояние. А что, если phi это самостоятельная
[51:48.080 --> 51:56.120]  темпоральная формула? То есть в phi тоже могут входить темпоральные операторы. Вот
[51:56.120 --> 52:05.320]  мы скажем так, более строго теперь. У нас будет такая база. Мы скажем, что вот пусть у
[52:05.320 --> 52:12.160]  нас phi это утверждение про состояние. Мы скажем, что траектория sigma выполняет
[52:12.160 --> 52:18.920]  формулу phi про состояние, утверждение про состояние, если
[52:21.880 --> 52:28.920]  стартовая конфигурация этой траектории выполняет формулу phi. Ну, пока такой
[52:28.920 --> 52:35.120]  бессмысленное определение. Все-таки у нас темпоральная логика, там утверждение
[52:35.120 --> 52:39.720]  про траектории, поэтому мы интерпретируем формулу всегда на траектории.
[52:39.720 --> 52:44.920]  Но вот если формула про конкретное состояние, про одно состояние, у нее нет
[52:44.920 --> 52:48.760]  темпоральных операторов, то она интерпретируется так. Мы просто берем
[52:48.760 --> 52:53.840]  начальную конфигурацию в траектории и интерпретируем формулу на ней. Вот, а
[52:53.840 --> 53:03.120]  теперь, если мы видим формулу box phi, то траектория sigma выполняет формулу box phi
[53:03.600 --> 53:06.600]  тогда, когда что?
[53:10.640 --> 53:15.560]  Не для любого цитов, потому что phi у нас сейчас уже любая, в том числе,
[53:15.560 --> 53:18.560]  темпоральная формула.
[53:20.680 --> 53:23.680]  Для любого k
[53:27.480 --> 53:31.880]  вот ведем такое вспомогательное определение суффикс.
[53:33.680 --> 53:36.680]  Траектории.
[53:45.240 --> 53:51.600]  Мы скажем, что траектория sigma выполняет формулу always phi, когда любой суффикс
[53:51.600 --> 53:57.640]  этой траектории выполняет формулу phi. Вот это все матчется с такой картинкой.
[53:57.640 --> 54:02.320]  Если у нас phi это утверждение про конкретное состояние, а не про
[54:02.320 --> 54:08.720]  траекторию, то вот эта запись, что суффикс исполняет phi, это более-менее
[54:08.720 --> 54:14.280]  означает, что цикатый выполняет phi. Ну, то есть, что просто phi выполнено в каждой
[54:14.280 --> 54:23.280]  конфигурации. Вот, а что такое формально теперь, что значит, что sigma выполняет
[54:23.280 --> 54:26.280]  diamond phi?
[54:27.200 --> 54:33.200]  Это называть еще box, я говорю, так, кажется, не записал, а eventually diamond, потому что
[54:33.200 --> 54:36.200]  символы такие.
[54:42.200 --> 54:45.200]  Ну, скажите мне, что здесь написано?
[54:46.120 --> 54:53.120]  Ну, существует некоторый суффикс траектории,
[54:55.120 --> 54:58.120]  который выполняет phi. Вот.
[55:01.120 --> 55:05.120]  Ну, нам нужно, мы говорим про формальная система, нам нужно немного формализма, вот,
[55:05.120 --> 55:11.120]  а теперь про интуицию. Вот, я сейчас напишу две формулы, и мы пытаемся понять,
[55:11.120 --> 55:16.120]  что они значат. Первая формула. Давайте от чего-то избавимся.
[55:23.120 --> 55:26.120]  Какой-то вопрос?
[55:32.120 --> 55:38.120]  Цикаты – это конфигурация, то есть конфигурация графа. В смысле, это узлы графа,
[55:38.120 --> 55:48.120]  а в смысле общей задачи – это снимок состояния всей системы, то есть в случае
[55:48.120 --> 55:53.120]  потоков – это состояние разделения памяти и стэк каждого потока и его регистры,
[55:53.120 --> 55:57.120]  или в случае распределенной системы, узлов, которые решают консенсус – это
[55:57.120 --> 56:02.120]  состояние сети плюс состояние каждого узла.
[56:09.120 --> 56:11.120]  Да.
[56:17.120 --> 56:22.120]  Так потому что в темпоральной логике мы, смотри, это просто по построению,
[56:22.120 --> 56:27.120]  в темпоральной логике мы оперируем не конфигурациями, а траекториями.
[56:27.120 --> 56:31.120]  И мы интерпретируем любую формулу в темпоральной логике не на конфигурации,
[56:31.120 --> 56:38.120]  а на траектории. Поэтому мы всегда говорим про траектории, но у нас есть
[56:38.120 --> 56:43.120]  некоторая база. У нас есть такие выраженные формулы темпоральные,
[56:43.120 --> 56:50.120]  где темпоральных операторов вообще нет. Вот мы интерпретируем их таким образом,
[56:50.120 --> 56:55.120]  сводим их к интерпретации на первом состоянии, на первой конфигурации.
[56:55.120 --> 56:59.120]  А так вообще мы говорим про суффиксы.
[56:59.120 --> 57:06.120]  Собственно, я же поэтому сначала написал так, где φ была не темпоральной формулой
[57:06.120 --> 57:10.120]  в утверждении про состояние, а потом написал более общее определение.
[57:15.120 --> 57:20.120]  У нас смысл базы по темпоральности формулы.
[57:20.120 --> 57:26.120]  Вот если формула φ не темпоральная, там нет темпоральных операторов,
[57:26.120 --> 57:33.120]  то мы интерпретируем ее на траектории так. Мы берем первую конфигурацию
[57:33.120 --> 57:37.120]  в этой траектории и интерпретируем φ на ней. Это вот некоторый искусственный шаг,
[57:37.120 --> 57:44.120]  но просто чтобы дальше от него идти. А здесь уже все довольно разумно.
[57:44.120 --> 57:49.120]  Мы говорим, что σ выполняет eventual φ, то есть некоторая траектория выполняет
[57:49.120 --> 57:54.120]  eventual φ, если на некотором суффиксе исполняется просто φ.
[57:54.120 --> 57:57.120]  И если φ оказывается в формуле, где темпоральных операторов нет,
[57:57.120 --> 58:01.120]  то это означает, что σ выполняет eventual φ, когда существует
[58:01.120 --> 58:04.120]  некоторая конфигурация ЦК, которая выполняет φ.
[58:04.120 --> 58:07.120]  Вот просто склеиваем это и это.
[58:07.120 --> 58:13.120]  Получилось ответить на твой вопрос?
[58:13.120 --> 58:18.120]  Относительно.
[58:18.120 --> 58:22.120]  Спрашивай, потому что ответ да или нет, получилось или не получилось.
[58:22.120 --> 58:29.120]  То есть это вполне эквивалентно тому, что у нас для какой-то конфигурации
[58:29.120 --> 58:32.120]  это выполнено, потому что у нас футбаза и дальше суффикс.
[58:37.120 --> 58:55.120]  Смотри, вот я пишу такое свойство, always всегда взаимное исключение.
[58:55.120 --> 58:58.120]  Вот взаимное исключение я уже показывал, это формула,
[58:58.120 --> 59:03.120]  которую можно было проинтерпретировать на состоянии системы,
[59:03.120 --> 59:06.120]  на программ-каунтрах, потоках и узнать, выполняется взаимное исключение или нет.
[59:06.120 --> 59:10.120]  Я пишу always. Это означает вот просто по этому определению,
[59:10.120 --> 59:18.120]  что для любого суффикса вот эта формула уже должна на суффиксе выполняться.
[59:18.120 --> 59:23.120]  Эта формула не темпоральная, там не было темпоральных операторов.
[59:23.120 --> 59:31.120]  Поэтому я беру просто суффикс любой и проверяю, что любой суффикс
[59:31.120 --> 59:36.120]  должен выполнять вот эту формулу взаимного исключения.
[59:36.120 --> 59:42.120]  А это в свою очередь означает для не темпоральной формулы,
[59:42.120 --> 59:49.120]  что ЦКТ должно выполнять формулу взаимного исключения.
[59:50.120 --> 59:54.120]  И всё это для любого ЦКТ, для любого ОК.
[01:00:02.120 --> 01:00:04.120]  На всякий случай ничего сложного не происходит.
[01:00:04.120 --> 01:00:08.120]  Если мы чего-то не понимаем, то значит мы запутались в определениях просто.
[01:00:10.120 --> 01:00:14.120]  Мы всего лишь перенесли утверждение какого-то мгновенного состояния мира
[01:00:14.120 --> 01:00:17.120]  на цепочки состоянии. Вот и всё.
[01:00:18.120 --> 01:00:22.120]  Ладно, давайте, чтобы понять, что убедиться, что мы действительно понимаем,
[01:00:22.120 --> 01:00:25.120]  я задам вопрос, который я планировал.
[01:00:32.120 --> 01:00:38.120]  Две уже не очень тривиальные формулы. Что означают они?
[01:00:39.120 --> 01:00:45.120]  Box diamond fee, always eventually fee и eventually always fee.
[01:00:47.120 --> 01:00:53.120]  Первое это просто always?
[01:00:53.120 --> 01:00:57.120]  Первое это не просто always, конечно.
[01:00:57.120 --> 01:00:59.120]  Потому что, ну вот, начнём вы раскрывать.
[01:00:59.120 --> 01:01:03.120]  Always eventually fee. Это означает, что для любого суффикса
[01:01:03.120 --> 01:01:06.120]  выполняется eventually fee.
[01:01:10.120 --> 01:01:13.120]  Но это не означает, что...
[01:01:13.120 --> 01:01:20.120]  Первое значит то, что у нас fee будет выполняться сколько угодно много раз?
[01:01:20.120 --> 01:01:25.120]  Вот, это значит, что fee выполняется бесконечно много раз на траектории.
[01:01:25.120 --> 01:01:33.120]  Вот какой бы суффикс мы ни взяли, всё равно в будущем fee будет выполнена.
[01:01:33.120 --> 01:01:38.120]  Но при этом fee не обязана выполняться, не знаю, всегда,
[01:01:38.120 --> 01:01:41.120]  потому что она может выполняться, не знаю, на каждую вторую конфигурацию
[01:01:41.120 --> 01:01:48.120]  всё равно формула будет выполнена на такой траектории.
[01:01:48.120 --> 01:01:54.120]  Что это означает для нас, для людей, которые занимаются concurrency?
[01:01:54.120 --> 01:01:58.120]  Неважно, в распределённых системах или в многопоточных.
[01:01:58.120 --> 01:02:00.120]  Это означает свойство fairness.
[01:02:00.120 --> 01:02:02.120]  То есть вы пишете планировщик операционной системы,
[01:02:02.120 --> 01:02:06.120]  и вы обязаны запускать поток бесконечно много раз, пока он готов исполняться.
[01:02:06.120 --> 01:02:09.120]  Вы не можете его задерживать на бесконечное время.
[01:02:11.120 --> 01:02:18.120]  Это fairness. А вот это свойство что означает?
[01:02:18.120 --> 01:02:22.120]  Начиная с какого-то момента, когда будет выполняться.
[01:02:22.120 --> 01:02:25.120]  Вот это уже разговор про распределённые системы.
[01:02:25.120 --> 01:02:28.120]  Есть такое понятие eventual consistency.
[01:02:28.120 --> 01:02:31.120]  Оно про то, что реплики вообще-то могут расходиться,
[01:02:31.120 --> 01:02:35.120]  но если их оставить в покое, то они друг с другом договорятся
[01:02:35.120 --> 01:02:38.120]  и придут к одному и тому же состоянию.
[01:02:38.120 --> 01:02:41.120]  Навсегда.
[01:02:41.120 --> 01:02:47.120]  Мы умеем теперь строить формулы темпоральной логики.
[01:02:47.120 --> 01:02:49.120]  Это хорошо.
[01:02:49.120 --> 01:02:53.120]  А теперь нам нужно саму систему описать.
[01:02:53.120 --> 01:03:00.120]  Граф, который порождает траектории, на которых мы интерпретируем свойства.
[01:03:00.120 --> 01:03:04.120]  Напомню, что спецификация – это система плюс свойства.
[01:03:04.120 --> 01:03:06.120]  Свойства мы описывать умеем.
[01:03:06.120 --> 01:03:09.120]  Мы умеем строить сложные утверждения относительно…
[01:03:09.120 --> 01:03:12.120]  Во-первых, мы берём граф системы
[01:03:12.120 --> 01:03:16.120]  и говорим, что каждое состояние в этом графе описывается наборами переменных.
[01:03:16.120 --> 01:03:20.120]  И дальше мы, во-первых, строим язык,
[01:03:20.120 --> 01:03:24.120]  в котором можно формулировать сложные утверждения строго
[01:03:24.120 --> 01:03:27.120]  относительно состояния, то есть относительно набора переменных.
[01:03:27.120 --> 01:03:29.120]  Это логика первого порядка.
[01:03:29.120 --> 01:03:32.120]  А дальше мы этот язык расширяем темпоральными операторами
[01:03:32.120 --> 01:03:35.120]  для того, чтобы строить утверждения относительно путей.
[01:03:35.120 --> 01:03:42.120]  Да, вот то, что мы построили, называется LTL – линейная темпоральная логика.
[01:03:42.120 --> 01:03:45.120]  Это не единственная темпоральная логика, есть другие.
[01:03:45.120 --> 01:03:48.120]  Но вот Лэмпорту нравится она.
[01:03:48.120 --> 01:03:51.120]  И ещё Лэмпорту не нравится оператор NEXT.
[01:03:51.120 --> 01:03:58.120]  Вот в TLA+, Temporal Logic of Actions, там тоже слово «темпоральное»,
[01:03:58.120 --> 01:04:03.120]  есть Box и Diamond, два темпоральных оператора, но нет кружочка NEXT.
[01:04:03.120 --> 01:04:06.120]  Почему его нет?
[01:04:11.120 --> 01:04:15.120]  В темпоральной логике вообще-то он есть, а у Лэмпорта его нет.
[01:04:15.120 --> 01:04:18.120]  Лэмпорт его выбрасывает, он говорит, что не нужно писать свойства,
[01:04:18.120 --> 01:04:21.120]  в которых есть кружочки.
[01:04:21.120 --> 01:04:26.120]  Но это же просто свойства на префексе первом, на суффексе первом.
[01:04:29.120 --> 01:04:32.120]  Мы же не определили, что это такое в общем случае.
[01:04:32.120 --> 01:04:34.120]  Давай определим.
[01:04:34.120 --> 01:04:43.120]  Сигма выполняет кружочек Фи тогда, когда Сигма плюс один выполняет Фи.
[01:04:43.120 --> 01:04:46.120]  Вот ничего неожиданного.
[01:04:51.120 --> 01:05:01.120]  Мы же не различаем NEXT и Eventually.
[01:05:01.120 --> 01:05:02.120]  Что?
[01:05:02.120 --> 01:05:05.120]  Мы не умеем различать NEXT и Eventually, по-моему.
[01:05:05.120 --> 01:05:09.120]  Смотрите, зачем мы вообще пишем спецификации для того, чтобы проверять, скажем,
[01:05:09.120 --> 01:05:14.120]  safety. Мы описали спецификацию ПАКСОСа, и у нас есть Model Shaker,
[01:05:14.120 --> 01:05:18.120]  который может по этой спецификации сгенерировать этот граф
[01:05:18.120 --> 01:05:21.120]  и проверить, что свойства выполняются.
[01:05:21.120 --> 01:05:26.120]  Safety свойства ПАКСОСа — это свойства, которые мы доказывали в асинхронной системе.
[01:05:26.120 --> 01:05:29.120]  Мы вообще работаем в мире, где нет никакой синхронности,
[01:05:29.120 --> 01:05:34.120]  поэтому непонятно, что значит NEXT в нашем графе.
[01:05:34.120 --> 01:05:39.120]  Мы не можем требовать, чтобы следующим шагом было доставлено какое-то сообщение
[01:05:39.120 --> 01:05:41.120]  или случилось какое-то событие.
[01:05:41.120 --> 01:05:46.120]  Мы нигде не можем в своих ожиданиях от мира
[01:05:46.120 --> 01:05:50.120]  оперировать, а следующим ходом произойдет вот это.
[01:05:50.120 --> 01:05:54.120]  У нас есть либо concurrency, и нас могут переключить на другой поток,
[01:05:54.120 --> 01:05:59.120]  либо у нас есть асинхронность сети, и следующее может быть доставлено любое сообщение.
[01:05:59.120 --> 01:06:04.120]  Поэтому Lamport говорит, что в условиях асинхронности нам оператор NEXT не нужен,
[01:06:04.120 --> 01:06:08.120]  потому что мы не рассчитываем на время.
[01:06:08.120 --> 01:06:13.120]  Логика темпоральная, но асинхронность мы не рассчитываем нигде.
[01:06:13.120 --> 01:06:18.120]  Кроме того, вы можете просто спецификацию детализировать в любой момент.
[01:06:18.120 --> 01:06:23.120]  То есть вы там написали какую-то подсистему, а потом добавили в нее состояние
[01:06:23.120 --> 01:06:28.120]  просто потому, что больше деталей его спецификации теперь.
[01:06:28.120 --> 01:06:33.120]  И раньше то, что занимало один шаг, занимает теперь 10 шагов.
[01:06:33.120 --> 01:06:36.120]  То есть вы можете спеку детализировать спецификацию вашей системы,
[01:06:36.120 --> 01:06:41.120]  и тогда у вас свойства, которые использовали бы оператор NEXT, поломались бы.
[01:06:41.120 --> 01:06:44.120]  Вот Lamport против этого.
[01:06:54.120 --> 01:06:58.120]  Так ты же формулируешь здесь какие-то ожидания свои.
[01:06:58.120 --> 01:07:01.120]  Вот у тебя не должно быть ожиданий, что вот о следующем что-то случится,
[01:07:01.120 --> 01:07:04.120]  следующим шагом что-то случится.
[01:07:04.120 --> 01:07:08.120]  Хорошо, тогда мы движемся к...
[01:07:12.120 --> 01:07:15.120]  Мы исчерпали время, конечно, все.
[01:07:15.120 --> 01:07:19.120]  Нужно перейти к примерам, но вот последняя теоретическая часть
[01:07:19.120 --> 01:07:24.120]  про то, как описать сам граф, саму систему.
[01:07:24.120 --> 01:07:27.120]  Есть идеи?
[01:07:27.120 --> 01:07:32.120]  Вот у нас есть язык логики для того, чтобы описывать свои legitimacy
[01:07:32.120 --> 01:07:53.480]  Есть идеи. Вот у нас есть язык логики для того, чтобы
[01:07:53.480 --> 01:07:59.400]  описывать свойства. Но будет плохо, если нам придется
[01:07:59.400 --> 01:08:01.480]  сейчас изобрести новый язык для того, чтобы описывать
[01:08:01.480 --> 01:08:14.960]  графы конфигурации. Лэмпард переиспользует то, что вот
[01:08:14.960 --> 01:08:19.080]  написано в правой части, говорит, что описание системы
[01:08:19.080 --> 01:08:36.680]  это тоже свойство такого вида. Он говорит, что описание
[01:08:36.680 --> 01:08:42.480]  графа – это некоторое свойство, которое выделяет все допустимые
[01:08:42.480 --> 01:08:46.440]  цепочки в этом графе. Это цепочки, в которых в начальной
[01:08:46.440 --> 01:08:51.280]  конфигурации выполняется предикат init, свойство init,
[01:08:51.280 --> 01:08:55.040]  и для каждой пары соседней конфигурации выполняется
[01:08:55.040 --> 01:09:00.400]  предикат next. Next – это предикат на парах состояний, на прошлом
[01:09:00.400 --> 01:09:06.560]  и будущем. И вот если для любой пары соседних конфигураций
[01:09:06.560 --> 01:09:10.640]  в траектории выполняется next, и для первой конфигурации
[01:09:10.640 --> 01:09:16.160]  выполняется init, то это означает, что траектория валидна.
[01:09:16.160 --> 01:09:18.480]  Так что граф конфигурации описывается вот такой
[01:09:18.480 --> 01:09:22.480]  темпоральной формулой, а свойства системы описываются
[01:09:22.480 --> 01:09:24.720]  вот какими-то такими темпоральными формулами.
[01:09:24.720 --> 01:09:33.240]  Еще раз, init что задает? Смотри, это темпоральная формула.
[01:09:33.240 --> 01:09:38.640]  Это как фи и пси, грубо говоря. Эта формула, поскольку
[01:09:38.640 --> 01:09:41.200]  без темпоральных операторов, она интерпретируется на
[01:09:41.200 --> 01:09:44.880]  начальной конфигурации, а next – это такой предикат,
[01:09:45.200 --> 01:09:47.640]  это уже расширение линейной темпоральной логики, это
[01:09:47.640 --> 01:09:52.400]  предикат на паре соседних конфигураций, и он должен
[01:09:52.400 --> 01:09:57.280]  выполняться для каждой пары. И если эта формула справедлива
[01:09:57.280 --> 01:10:00.480]  на траектории, то эта траектория принадлежит этому графу,
[01:10:00.480 --> 01:10:05.720]  и вот так мы графы описываем. То есть next – это какая-то
[01:10:05.720 --> 01:10:08.520]  формула, которая описывает переходы между вершинами?
[01:10:08.520 --> 01:10:11.680]  Да, она говорит, что next выполняется на соседних
[01:10:11.680 --> 01:10:15.080]  состояниях. Это означает, что в графе существует
[01:10:15.080 --> 01:10:20.280]  переход из состояния s в состояние штрих. Ну, например,
[01:10:20.280 --> 01:10:23.200]  здесь было сообщение какое-то в сети, а здесь какой-то
[01:10:23.200 --> 01:10:27.280]  узел его получил. И вот предикат это проверяет, и значит,
[01:10:27.280 --> 01:10:29.120]  если предикат выполнется, значит, такой переход возможен.
[01:10:29.120 --> 01:10:35.840]  Вот то, что получилось, и называется все вместе
[01:10:35.840 --> 01:10:40.680]  TLA+, Temporal Logic of Actions. Вот этот предикат next называется
[01:10:40.680 --> 01:10:47.680]  action. И Лэмпард замечает, что вся эта конструкция,
[01:10:47.680 --> 01:10:50.680]  точнее такой способ описать граф – это такой дискретный
[01:10:50.680 --> 01:10:54.040]  аналог дифференциальных уравнений. Мы, по сути, описываем
[01:10:54.040 --> 01:11:00.120]  всевозможные изменения в состоянии системы. Что
[01:11:00.120 --> 01:11:09.120]  такое плюс, я, честно говоря, не помню, уже не знаю. Ну
[01:11:09.120 --> 01:11:13.480]  вот так Лэмпард предлагает нам специфицировать весь
[01:11:13.480 --> 01:11:16.720]  наш код. А дальше мы должны посмотреть на какие-то
[01:11:16.720 --> 01:11:19.600]  спецификации и понять, что же все это значит, в конце
[01:11:19.600 --> 01:11:23.000]  концов. Потому что пока, наверное, ничего не понятно.
[01:11:23.000 --> 01:11:28.000]  Давайте сделаем это после перерыва. Через 10 минут.
[01:11:28.000 --> 01:11:39.000]  Ну что, продолжаем. Мы не в силах уже заниматься
[01:11:39.000 --> 01:11:42.320]  совсем абстрактным. Нужно посмотреть на примеры.
[01:11:42.320 --> 01:11:46.120]  Вот я надеюсь, что вы сейчас видите первую спецификацию
[01:11:46.120 --> 01:11:49.200]  на TLA, которую я хочу вам показать. Это спецификация
[01:11:49.200 --> 01:11:55.400]  алгоритма Ивклида. Вообще-то задумка TLA в том, чтобы специфицировать
[01:11:55.400 --> 01:11:59.320]  конкурентные системы, распределенные системы или многоплоточные
[01:11:59.320 --> 01:12:04.760]  системы. Вот алгоритм Ивклида полностью не соответствует
[01:12:04.760 --> 01:12:07.680]  этим церям, но это самый простой пример, самый маленький
[01:12:07.680 --> 01:12:10.960]  хлоу ворлд, который только можно придумать. Вот смотрите,
[01:12:10.960 --> 01:12:15.520]  здесь есть переменные X и Y. И изначально они равны
[01:12:15.520 --> 01:12:19.800]  значениям N и M. Вот каким образом M и N. Вот как мы это
[01:12:19.800 --> 01:12:23.840]  описали с помощью предиката ИНИТ. Вот, пожалуйста, утверждение
[01:12:23.840 --> 01:12:29.920]  про состояние мира. Про две переменные. X равен M, Y равен
[01:12:29.920 --> 01:12:35.480]  N. Формула логики первого порядка. И вот предикат
[01:12:35.480 --> 01:12:41.480]  NEXT, который выделяет допустимые переходы. Вот в этом предикате
[01:12:41.480 --> 01:12:45.080]  есть штрихованные и нештрихованные переменные. Штрихованные
[01:12:45.080 --> 01:12:47.080]  переменные — это переменные, отвечающие следующему
[01:12:47.080 --> 01:12:51.160]  состоянию, не штрихованные к текущему состоянию. И если
[01:12:51.160 --> 01:12:54.560]  этот предикат, этот action, как называется в тело, выполняется,
[01:12:54.560 --> 01:12:59.080]  то значит, переход допустим. Какие возможны переходы?
[01:12:59.080 --> 01:13:04.520]  Либо если X меньше Y, то допустим переход, где X не меняется,
[01:13:04.520 --> 01:13:09.480]  а из Y вычитается X. Или наоборот. Если Y в старом состоянии
[01:13:09.480 --> 01:13:13.680]  был меньше X, то допускается переход, где новый X равен
[01:13:13.680 --> 01:13:22.680]  старому, из которого вычли Y. И вот описание системы.
[01:13:22.680 --> 01:13:28.960]  Вот описание графа конфигурации. В начальной конфигурации
[01:13:28.960 --> 01:13:33.640]  должен быть выполнен предикат ИНИТ и для каждого перехода
[01:13:33.640 --> 01:13:36.800]  должен быть выполнен next. Но вот это крайне неинтересный
[01:13:36.800 --> 01:13:41.040]  граф. Почему? Потому что это просто такой бамбук, цепочка
[01:13:41.040 --> 01:13:44.440]  узлов. Никаких витринений нет, никакого недетерминизма
[01:13:44.440 --> 01:13:48.520]  нет, ничего интересного. Но тем не менее, мы по крайней
[01:13:48.520 --> 01:13:54.840]  мере видим, как устроен язык. Вот мы видим, что в нем отступы
[01:13:54.840 --> 01:13:57.120]  влияют. То есть вместо того, чтобы писать скобочки,
[01:13:57.120 --> 01:14:01.520]  мы пишем отступы. Вот вместо and и or мы пишем вот такой
[01:14:01.520 --> 01:14:06.080]  связки графики с юнкцией конъюнкцией. Но в принципе
[01:14:06.080 --> 01:14:08.760]  можно расшировать, что примерно происходит. Это чем-то
[01:14:08.760 --> 01:14:15.240]  отдаленно напоминает всех. Ну и это сравнение, оно
[01:14:15.240 --> 01:14:19.040]  здесь не просто так, потому что... Давайте я вам покажу
[01:14:19.040 --> 01:14:36.280]  какой-нибудь пример сейчас. Да, видите, это не какой-то
[01:14:36.280 --> 01:14:40.000]  супер моргинальный инструмент. Вот GitHub умеет подсвечивать
[01:14:40.000 --> 01:15:03.880]  тела и плюс. Секунду, терпение. Это не про... Ну, смотрите,
[01:15:03.880 --> 01:15:07.560]  LaTeX писал лэмпорт, тела и плюс придумал лэмпорт, еще бы
[01:15:07.560 --> 01:15:10.840]  это спецификация, не умели транслироваться бы в тех.
[01:15:10.840 --> 01:15:13.680]  Вот, пожалуйста, статья про там... Я рассказывал вам
[01:15:13.680 --> 01:15:16.160]  на лекции про паксос-мейдлайв, про гибкие кворумы, про то,
[01:15:16.160 --> 01:15:19.880]  что кворумы на фазу препэра на accept могут быть разные,
[01:15:19.880 --> 01:15:23.080]  и можно брать где-то больше, где-то меньше для разных
[01:15:23.080 --> 01:15:25.640]  целей. Ну и вот спецификация этого алгоритма, спецификация
[01:15:25.640 --> 01:15:30.000]  алгоритма паксоса, и она скомпилирована в читаемый
[01:15:30.000 --> 01:15:33.160]  PDF. Тут уже у вас конъюнкции и дизюнкции совершенно
[01:15:33.160 --> 01:15:40.760]  обычные. Что еще про эту спецификацию можно сказать?
[01:15:40.760 --> 01:15:46.320]  Что удивляет в ней даже не это, а то, что чекер тела
[01:15:46.320 --> 01:15:50.680]  и плюс может интерпретировать вот такие вот штуки. Какое
[01:15:50.680 --> 01:15:53.560]  мы здесь свойства проверяем? Мы проверяем safety-свойства,
[01:15:53.560 --> 01:15:57.440]  predicate, который говорит, что если x равен y, то x равен
[01:15:57.440 --> 01:16:02.160]  наибольшему общему делителю nm. Вот, а наибольший общий
[01:16:02.160 --> 01:16:04.240]  делитель, про него, конечно, модел чекера ничего не
[01:16:04.240 --> 01:16:07.720]  знает, поэтому мы его определяем. Мы вводим отношение делимости,
[01:16:07.720 --> 01:16:12.760]  мы определяем множество делителей, мы учим, пишем
[01:16:12.760 --> 01:16:16.280]  функцию, которая находит максимум, и определяем наибольший
[01:16:16.280 --> 01:16:19.360]  общий делитель как максимум из пересечения множества
[01:16:19.360 --> 01:16:24.280]  делителей по yq. Так что вот здесь описание системы
[01:16:24.280 --> 01:16:29.360]  перед вами, вот набор переменных и формула, которая выделяет
[01:16:29.360 --> 01:16:33.720]  допустимые траектории. И вот инвариант, то есть утверждение
[01:16:33.720 --> 01:16:41.560]  про конкретное состояние. Вот, ну это такой скучный
[01:16:41.560 --> 01:16:44.720]  пример, но зато его можно запустить, в смысле, можно
[01:16:44.720 --> 01:16:48.960]  запустить модел чекер, задав какие-то значения nm, ну
[01:16:48.960 --> 01:16:51.880]  и получить, что мы нашли три разных состояния, видимо,
[01:16:51.880 --> 01:16:56.080]  три шага. Алгоритм вклюда сделал, дошел до 6 и остановился.
[01:16:56.080 --> 01:16:59.120]  Ну это неинтересный пример, потому что граф тут довольно
[01:16:59.120 --> 01:17:05.440]  выраженный просто. Вот, посмотрим, например, сложнее. Вот,
[01:17:05.440 --> 01:17:08.240]  этот пример понятен только старикам, типа у меня, потому
[01:17:08.240 --> 01:17:11.440]  что они смотрели в детстве боевик Крепкий орешек 3.
[01:17:11.440 --> 01:17:15.600]  В этом фильме был Брюс Вирес, и ему звонил террорист
[01:17:15.600 --> 01:17:17.800]  и говорил, что если он сейчас не решит довольно странный
[01:17:17.800 --> 01:17:21.680]  пазл, то Црис взорвет бомбу, кажется, дело было так. Пазл
[01:17:21.680 --> 01:17:28.440]  был такой. Был фонтан и две канистры размером 3.5 галлонов,
[01:17:28.440 --> 01:17:34.680]  и нужно было набрать большую канистру 4. Вот. Ну такой пазл,
[01:17:34.680 --> 01:17:41.400]  его нужно найти решение. Понятно, что граф конфигурации
[01:17:41.400 --> 01:17:45.800]  для этого пазла, можно, вот посмотрим, как этот граф
[01:17:45.800 --> 01:17:51.400]  строится с помощью тела и плюс. Мы вводим две переменные,
[01:17:51.400 --> 01:17:53.920]  сколько сейчас воды в большой канистре, сколько в маленькой,
[01:17:53.920 --> 01:17:59.640]  и значения описывают вот состояние, которое мы достигли.
[01:17:59.640 --> 01:18:07.880]  У нас есть начальное состояние, где канистры пустые. Мы можем
[01:18:07.880 --> 01:18:11.720]  совершать некоторые действия. Мы можем заполнить маленькую
[01:18:11.720 --> 01:18:17.520]  канистру водой. Этот экшен называется Fill Small Jug, и он выглядит
[01:18:17.680 --> 01:18:22.240]  так. В штрихованные переменные с маленькой канистрой наполняется
[01:18:22.240 --> 01:18:27.720]  тройкой, а большая остается без изменений. Мы можем заполнить
[01:18:27.720 --> 01:18:31.360]  большую канистру, штрихованные переменные положить здесь
[01:18:31.360 --> 01:18:33.640]  5, а в штрихованные переменные на маленькой канистре сохранить
[01:18:33.640 --> 01:18:37.600]  просто значение. И мы можем опустошить маленькую, опустошить
[01:18:37.600 --> 01:18:49.040]  точно так же, и мы можем переливать из... у нас какой-то вопрос в чате. Штрихи, да, это
[01:18:49.040 --> 01:18:55.300]  специальный синтаксис, который позволяет нам писать экшены, а именно вот предикат
[01:18:55.300 --> 01:19:00.880]  next на парах соседних состояний. У нас переменных объявлено здесь две, big и small,
[01:19:00.880 --> 01:19:05.840]  а в экшенах мы можем писать переменные big и big-штрих. Вот штрих — это значит следующее
[01:19:05.840 --> 01:19:12.040]  состояние. Вот и правила переливания. Вот предикат на паре состояний, который допускает
[01:19:12.040 --> 01:19:17.600]  переливания. В большой канистре становится минимум из большой плюс маленькой и емкости
[01:19:17.600 --> 01:19:24.000]  большой канистры, в маленькой, соответственно, маленькая уменьшается на дельту, на которую
[01:19:24.000 --> 01:19:32.240]  изменилась большая. Вот на всякий случай тут не нужно думать про порядок вычислений,
[01:19:32.240 --> 01:19:38.080]  потому что порядка вычислений здесь нет. Это вообще неимперативный код, это логическая
[01:19:38.080 --> 01:19:46.360]  формула. Вот она берет четыре значения и проверяет, что для них выполнены какие-то соотношения. Да,
[01:19:46.360 --> 01:19:51.960]  разумеется, Model Checker, который будет интерпретировать эту спецификацию, он будет смотреть на это как на
[01:19:51.960 --> 01:19:57.080]  какие-то присваивания, но вообще мы пишем логическую формулу. У нас здесь равно — это равно, это не
[01:19:57.080 --> 01:20:08.920]  присваивание. Окей, мы определили маленькие экшены, отдельные экшены для таких элементарных
[01:20:08.920 --> 01:20:16.920]  операций, а теперь можем описать весь граф. Вот для этого мы next определяем как дизьюнкцию всех этих
[01:20:16.920 --> 01:20:23.380]  отдельных шагов. При каждом переходе мы можем либо опустошить маленькую канистру, либо опустошить
[01:20:23.380 --> 01:20:27.820]  большую канистру, либо наполнить маленькую, либо наполнить большую, либо перелить из одной в
[01:20:27.820 --> 01:20:37.820]  другую. Вот и за счет этой вариативности у нас граф становится уже менее тривиальным, из каждой
[01:20:37.820 --> 01:20:51.660]  конфигурации у него есть, видимо, 6 дуг. А теперь вопрос. Вот мы описали таким вот образом граф
[01:20:51.660 --> 01:21:00.240]  конфигурации для нашего пазла. А теперь мы хотим каким-то образом с помощью model checker,
[01:21:00.240 --> 01:21:04.640]  который умеет варидировать safety-level-свойства, то есть свойства, описанные в виде темпоральных
[01:21:04.640 --> 01:21:13.480]  формул, мы хотим узнать, есть ли решение у пазла. Вот узнать, существует ли решение, то есть существует
[01:21:13.480 --> 01:21:21.320]  ли в графе какая-то конфигурация, для которой выполняется, что b равно 4. Вот вроде бы
[01:21:21.320 --> 01:21:29.660]  темпоральная логика этого делать не позволяет. Мы строим утверждение относительно каждого пути
[01:21:29.660 --> 01:21:37.260]  или каждого состояния. А тут у нас вопрос, существует ли состояние, в котором выполнено
[01:21:37.260 --> 01:21:43.060]  некоторые условия. Вот поможет ли нам здесь model checker, который умеет проверять свойства
[01:21:43.060 --> 01:21:58.020]  на выполнимость. Eventually, b равно 4 означает, что, что бы ты ни делал, ты в будущем обязательно
[01:21:58.020 --> 01:22:03.700]  достигнешь четырех. А ты заполняешь маленькую канистру, потом выливаешь ее, заполняешь,
[01:22:03.700 --> 01:22:08.340]  выливаешь, заполняешь, выливаешь, делаешь так бесконечно. Это некоторая траектория в графе,
[01:22:08.460 --> 01:22:12.540]  а свойства, они же должны выполняться для любой траектории. В этом смысл.
[01:22:12.540 --> 01:22:18.420]  Когда мы говорим save to aliveness, свойства спустя прогресс, она означает, что на каждой
[01:22:18.420 --> 01:22:23.620]  траектории в графе у тебя происходит нечто хорошее. Вот на такой траектории ничего хорошего не
[01:22:23.620 --> 01:22:41.220]  произойдет и не должно. Мы говорим следующее, мы пишем инвариант, что big не равно 4. А теперь мы
[01:22:41.220 --> 01:22:46.500]  запускаем model checker и проверяем, что этот вариант выполняется. То есть верно ли, что в каждом
[01:22:46.500 --> 01:23:02.540]  состоянии у нас содержимое большой канистры не равно 4. Вот запускаем model checker. Он находит
[01:23:02.540 --> 01:23:13.620]  84 состояния, 16 разных, чтобы это пока не значило. И инвариант нарушается. Тем самым мы узнаем,
[01:23:13.620 --> 01:23:18.100]  что в графе все-таки существует. То есть этот вариант несправедлив, и в графе, значит,
[01:23:18.100 --> 01:23:24.500]  существует состояние, где содержимое большой канистры все-таки равно 4. Ну а поскольку model
[01:23:24.500 --> 01:23:34.140]  checker TLA+, перебирает граф не абы как, а поиском в ширину, то это означает, что он находит не просто
[01:23:34.140 --> 01:23:40.140]  траекторию, на которой вариант нарушается, а он находит кратчайшую траекторию, на которую этот
[01:23:40.140 --> 01:23:47.140]  вариант нарушается. И вот мы можем здесь, в этом окошке, траекторию прочесть. Мы начинаем с двух
[01:23:47.140 --> 01:23:52.820]  нулей, потом тут даже написано, как называется, action, который мы взяли. Мы заполняем большую
[01:23:52.820 --> 01:23:58.300]  канистру, получаем там 5, потом мы переливаем из большой канистры в маленькую, получаем в большую
[01:23:58.300 --> 01:24:05.540]  2, в маленькой 3, потом мы опустошаем маленькую канистру, там становится 0, потом мы переливаем
[01:24:05.540 --> 01:24:14.340]  из маленькой в большую, там становится 2, потом мы заполняем большую, там становится 5, и потом
[01:24:14.340 --> 01:24:19.620]  мы переливаем из большой в маленькую, пока не заполнится маленькая, и таким образом в большой
[01:24:19.620 --> 01:24:26.780]  остается 4. Вот утверждается, что решение короче не существует просто потому, что model checker обходит
[01:24:26.780 --> 01:24:40.700]  граф поиском ширину. Эта спецификация все еще не имеет никакого отношения к конкарнции прямого
[01:24:40.700 --> 01:24:45.180]  и к определенным системам, но по крайней мере ирустрирует, как можно описать какой-то
[01:24:45.180 --> 01:24:54.460]  не совсем тривиальный граф уже. Ну что ж, а теперь мы морально готовы к тому, чтобы посмотреть на
[01:24:54.460 --> 01:25:04.540]  спецификацию алгоритма Paxos. Вот она местами выглядит довольно страшно, ну вот например, посмотрите на этот
[01:25:04.540 --> 01:25:17.620]  экшен. Ну это дело техники. Итак, смотрим на спецификацию, точнее даже так, смотрим на
[01:25:17.620 --> 01:25:25.420]  спецификацию и понимаем, что, даже по предыдущим примерам, что тело и плюс это очень низкоуровневый
[01:25:25.420 --> 01:25:33.740]  язык. Там есть переменные, там есть множество, там есть отображение, там есть списки, но там нет узлов,
[01:25:33.740 --> 01:25:39.780]  там нет сети, там нет никаких высокоуровневых абстракций, про которые мы думаем, когда говорим
[01:25:39.780 --> 01:25:46.700]  про определенные системы. Это сделано намеренно, потому что такой уровень абстракции нас бы
[01:25:46.700 --> 01:25:53.860]  в себе фиксировал, а Lampard хочет, чтобы мы могли специфицировать систему в самом разном масштабе
[01:25:53.860 --> 01:26:00.060]  с любым уровнем детализации, и через множество, и через списки, через отображение по замыслу Lampard
[01:26:00.060 --> 01:26:05.100]  можно выразить всё. В том числе можно выразить алгоритм Paxos, узлы, которые общаются по сети.
[01:26:05.100 --> 01:26:12.380]  Давайте подумаем, как это можно сделать. Тут, по-моему, ответ уже перед вами, можно было бы его
[01:26:12.380 --> 01:26:25.300]  просто прочесть. Как нам моделировать узлы и сеть алгоритма Paxos? У нас есть узлы, аксепторы, и у каждого
[01:26:25.300 --> 01:26:30.540]  аксептора есть состояние. Каждый аксептор помнит максимальный ballot number, который он получал,
[01:26:30.540 --> 01:26:38.260]  и каждый аксептор помнит отданный голос. Вот эти три переменные — это, на самом деле, три отображения.
[01:26:38.260 --> 01:26:45.780]  Отображение из множества аксепторов. Максимальный ballot number — это отображение из аксепторов
[01:26:45.780 --> 01:26:54.100]  в максимальные ballot numbers. Эти две переменные — это отображение для каждого аксептора из
[01:26:54.100 --> 01:27:01.300]  отображения в значение или в ballot number, за который он проголосовал,
[01:27:01.300 --> 01:27:08.860]  proposal number, за который этот аксептор проголосовал. Вот три такие переменные описывают состояние
[01:27:08.860 --> 01:27:15.700]  всех аксепторов. Ещё одна переменная описывает просто сеть. Вот мы не пытаемся моделировать
[01:27:15.700 --> 01:27:23.260]  здесь провода какие-то, там, коммутаторы, стойки, децентрия. Сеть — это просто множество отправленных
[01:27:23.340 --> 01:27:31.020]  сообщений. И у нас есть специальный action next, специальный action send,
[01:27:31.020 --> 01:27:40.300]  который позволяет отправить в сеть сообщения. Этот action говорит, что штрихованный messages
[01:27:40.300 --> 01:27:47.940]  должен быть равен messages на предыдущем шаге в объединении с таким синглотоном из множества
[01:27:47.940 --> 01:27:58.460]  из сообщения. Вот так моделируется сеть. Как моделируется исполнение? Как обычно,
[01:27:58.460 --> 01:28:09.140]  смотрим на предикат next. В этом предикате есть два конъюнкта. Что может в аксете происходить?
[01:28:09.140 --> 01:28:14.740]  Может происходить отправка сообщения prepare на первой фазе, может происходить отправка в
[01:28:14.740 --> 01:28:22.380]  обратную сторону промеса, accept и accepted. Четыре возможных события. И вот здесь есть две ветки.
[01:28:22.380 --> 01:28:29.420]  Первая ветка — это действие пропаузера. Какой-то пропаузер начинает первую фазу паксуса,
[01:28:29.420 --> 01:28:34.740]  посылает prepare. Вот здесь нотация лэмпрад из оригинальной статьи «Паксус имеет симпл»,
[01:28:34.740 --> 01:28:47.420]  1a — это prepare, 1b — это promise, 2a — это accept, 2b — это ответ acceptа, то, что он проголосовал за
[01:28:47.420 --> 01:28:57.740]  значение, за пропаузу. И вот смотрите, что мы пишем. Или существует ballot number из множества всех
[01:28:57.740 --> 01:29:07.100]  ballot number такой, что или было отправлено сообщение prepare, или существует некоторое значение такое,
[01:29:07.100 --> 01:29:17.460]  что был отправлен accept из пары b в. То есть лэмпрад здесь даже не моделирует пропаузеров.
[01:29:17.460 --> 01:29:27.260]  Просто в системе появляются prepare и появляются accept. Вот как будто бы из воздуха возникают.
[01:29:27.260 --> 01:29:38.700]  Вот из воздуха возник prepare с ballot number b. Что такое action phase 1a? Как он устроен? Он устроен
[01:29:38.700 --> 01:29:49.780]  очень просто. Он говорит, что в штрихованной сети появляется такое сообщение типа 1a с ballot
[01:29:49.780 --> 01:30:02.180]  number b, а все остальные переменные остаются неизменными. Вот это как будто бы какой-то пропаузер
[01:30:02.180 --> 01:30:08.420]  отправил какому-то accept сообщение. Вернее, он отправил его даже не какому-то конкретному accept,
[01:30:08.420 --> 01:30:14.980]  потому что здесь получателя вообще нет. Это просто prepare с некоторым ballot number.
[01:30:14.980 --> 01:30:24.740]  Кто же его получает? Ну, вообще-то его может получить любой acceptor. При переходе из
[01:30:24.740 --> 01:30:30.380]  предшествующего состояния в следующее, мы можем выбрать одного из acceptors, из множества acceptors,
[01:30:30.380 --> 01:30:37.820]  которые мы задаем в model checker, и для него может случиться переход phase 1b. А phase 1b устроен
[01:30:37.820 --> 01:30:50.460]  таким образом. В сети есть сообщение m. Такое, что его тип 1a, то есть это prepare, ballot number в
[01:30:50.460 --> 01:30:57.540]  нем больше, чем максимальный ballot number, который видел данный acceptor. Это не массивы, это отображение.
[01:30:57.540 --> 01:31:09.900]  Вот, ballot number штрих для этого acceptor меняется на значение из сообщения, и в сети появляется
[01:31:09.900 --> 01:31:23.660]  сообщение типа 1b, то есть promise от acceptor a с ballot number, который нам отправили. И переменная
[01:31:23.860 --> 01:31:30.700]  поля m-ball и m-wall – это proposal, за который данный acceptor к этому времени проголосовал.
[01:31:30.700 --> 01:31:40.060]  То есть вот такой вот переход. Вот здесь видите, сообщение отправляется кому-то одному. Здесь
[01:31:40.060 --> 01:31:46.020]  сообщение отправляется сразу всем. И будучи отправленным, оно из сети никогда не исчезает.
[01:31:46.020 --> 01:31:53.020]  Поэтому это такая широковещательная рассылка. Вы сделали broadcast сразу всем, и каждый acceptor
[01:31:53.020 --> 01:32:06.980]  любой acceptor a может это сообщение получить. Что? Подожди, но это реакция отдельного acceptor. Тут
[01:32:06.980 --> 01:32:12.700]  никаких кормов и не должно быть. Acceptor получил сообщение prepare, посмотрел на свои переменные и
[01:32:12.700 --> 01:32:27.460]  ответил. Повтори, пожалуйста, вопрос. Очень тихо было слышно. Это такой очень странный уродливый
[01:32:27.460 --> 01:32:33.540]  синтаксис. Lamport тоже кажется уродливым, но всем он кажется уродливым. Это означает, что переменное
[01:32:33.540 --> 01:32:40.900]  отображение штрихованное равно исходному за исключением одной точки a, где оно меняется на
[01:32:40.900 --> 01:33:00.220]  такое значение. Ну вот, это такая вот большая конъюнкция. Какие условия должны сложиться,
[01:33:00.220 --> 01:33:07.420]  чтобы нам acceptor отправил promise? В сети должен быть prepare, его ballot number этого acceptor должен
[01:33:07.420 --> 01:33:16.100]  быть меньше, чем ballot number в сообщении. Ну и тогда в обратную сторону появится promise.
[01:33:16.100 --> 01:33:23.740]  То есть опять же, тут нет никакой последовательности шагов. Это вот как бы разум случается и все,
[01:33:23.740 --> 01:33:31.900]  это такой атомарный переход. Каждый action это атомарный переход. Ну вот, мы посмотрели
[01:33:31.900 --> 01:33:40.780]  фейс 1a, фейс 1b, а теперь фейс 2a. То есть возможен переход для некоторого b и для некоторого v.
[01:33:40.780 --> 01:33:53.620]  Этот переход означает, что для данного ballot number и данного значения v в сеть, видимо,
[01:33:53.620 --> 01:34:04.700]  был отправлен accept. А почему он был отправлен? Ну вообще-то это сложно уже. Тут можно такие детали
[01:34:04.700 --> 01:34:12.700]  прочесть. Вот фейс 2a. Этот action говорит, что в штрихованном мире есть accept, а в нештрихованном
[01:34:12.700 --> 01:34:21.660]  его еще не было. Ну вот, в нештрихованном мире в сети не существовало сообщения 2a с ballot
[01:34:21.660 --> 01:34:32.940]  number b. В штрихованной сети оно появилось и, видимо, должно быть какое-то условие,
[01:34:32.940 --> 01:34:41.620]  которое к этому привело. Видимо, собрался quorum. То есть существует элемент q множество quorumов.
[01:34:41.620 --> 01:34:51.460]  Такой, что... Тут хорошо знакомые любители функционального программирования конструкции
[01:34:51.460 --> 01:34:58.660]  LED. Если вы пишете на c++ всю жизнь, то, наверное, вам это трудно читать. Ну в общем, мы здесь
[01:34:58.660 --> 01:35:05.580]  определяем множество всех ballot numbers, которые мы получили от accept'ров. То есть вот мы перебираем
[01:35:05.580 --> 01:35:14.700]  все сообщения, множество messages такие, что это сообщение promise, оно входит в этот quorum
[01:35:14.700 --> 01:35:28.500]  выделенный и ballot number там b. Вот, и из них собираем... Сейчас, я сам запутался.
[01:35:36.580 --> 01:35:47.900]  Это множество всех сообщений, которые мы получили в рамках этого quorum, а это все сообщения с непустыми
[01:35:47.900 --> 01:35:58.340]  голосами. Ну дальше мы определили два таких объекта, и через них мы уже строим некоторую формулу.
[01:35:58.340 --> 01:36:06.500]  То есть мы выделили некоторую сложную подформулу, дали ей имя, связали ее с именем. Вот, и теперь мы
[01:36:06.500 --> 01:36:13.140]  можем эту подформулу использовать в качестве имени для того, чтобы сказать, что какой-то
[01:36:13.140 --> 01:36:23.140]  пропозер предлагает значение v с ballot number b, потому что, ну, либо все ответы были пустыми, а b было,
[01:36:23.140 --> 01:36:32.660]  а v, видимо, было его выбором, его собственным значением. Либо же существует такое сообщение в quorum'е
[01:36:32.660 --> 01:36:44.860]  promise, такое, что значение в этом сообщении это v, и при этом в этом сообщении ballot number больше,
[01:36:44.860 --> 01:36:54.420]  чем все другие, не меньше, чем ballot number всех других сообщений с quorum. Ну вот, вроде прочитали.
[01:36:54.420 --> 01:37:03.820]  Вот это целиком декларативное описание, тут никаких вычислений, никакого порядка нет. Мы просто
[01:37:03.820 --> 01:37:10.340]  пишем большую формулу. Вообще, вся эта спецификация — это одна большая формула next, по сути-то. Вот если мы
[01:37:10.340 --> 01:37:15.860]  начнем ее подставлять, то получится такая гигантская, непонятная, но она и так не очень-то понятная, но
[01:37:15.860 --> 01:37:23.300]  получится абсолютно гигантская формула, и вот эта формула описывает все возможные исполнения алгоритма
[01:37:23.300 --> 01:37:32.540]  сингуют degree of access. Примерно понятная идея, как эта спецификация описана?
[01:37:32.540 --> 01:37:56.260]  Что? Так вот же, мы только что прочли. Смотри, вот этот... Вот мы задаем просто множество quorum'ов,
[01:37:56.260 --> 01:38:03.580]  когда мы запускаем... Смотри, model checker, вот здесь у нас есть переменные и есть некоторые константы. Вот
[01:38:03.580 --> 01:38:08.540]  value — это множество всех значений, acceptor — это множество acceptor'ов, quorum1, quorum2 — это quorumы
[01:38:08.540 --> 01:38:16.180]  для первой и для второй фазы. И когда мы запускаем model checker, мы задаем, что у нас три acceptor,
[01:38:16.180 --> 01:38:23.940]  что у нас два значения, что у нас, раз три acceptor, то вот такая система quorum'ов, любые
[01:38:24.060 --> 01:38:31.020]  всевозможные двойки. Вот, а ballot number'ов у нас вообще четыре. Вот два возможных значения,
[01:38:31.020 --> 01:38:43.340]  четыре acceptor'а, три acceptor'а, четыре ballot number'а. Тут как таковых пропаузеров нет. Вот этих циклов
[01:38:43.340 --> 01:38:52.100]  с литрами нет. У вас просто из воздуха появляются сначала prepare, а потом появляются accept. И
[01:38:52.740 --> 01:38:58.620]  acceptor должны на них реагировать. Чего мы от такого графа хотим? Мы хотим выполнения safety
[01:38:58.620 --> 01:39:05.660]  свойства. А safety свойства записывается вот буквально так, как мы формулировали теорему.
[01:39:05.660 --> 01:39:17.300]  Для любого значения v или для любого ballot number'a v. Если был выбран пропаузл bv, что значит
[01:39:17.300 --> 01:39:27.660]  выбран? Что существует quorum второй фазы такой, что любой acceptor из этого quorum'а отправил в сеть
[01:39:27.660 --> 01:39:36.500]  сообщение 2b с этим значением и этим ballot number'ом. Вот просто определение понятия выбора в консенсусе
[01:39:36.500 --> 01:39:45.500]  в алгоритме Paxos. Это вот formula agreed. Вот если мы умеем читать, мы понимаем, что такое значение
[01:39:45.740 --> 01:39:51.500]  выбрано. Мы уже не можем... Вот здесь максимально строгое изложение. Еще раз помните, говорил вам,
[01:39:51.500 --> 01:39:56.540]  что значение выбрано не означает, что оно лежит на большинстве... Даже пропаузл лежит на большинстве
[01:39:56.540 --> 01:40:03.100]  acceptor'ов. А то, что большинство acceptor'ов ответили. Вот здесь ровно это и записано. Нашелся quorum
[01:40:03.100 --> 01:40:12.260]  такое, что каждый acceptor из этого quorum'а отправил в сеть сообщение 2b. А safety свойства описывается так.
[01:40:12.260 --> 01:40:21.620]  Для любого v из множества значений и b из множества ballot number'ов, если пропаузл был выбран,
[01:40:21.620 --> 01:40:34.460]  то для любого другого значения v2 или любого другого v2 больше v из того, что в сети появилось
[01:40:34.460 --> 01:40:43.700]  сообщение accept b2 v2, следует, что v равно v2. То есть для любого пропаузла с большим ballot number'ом
[01:40:43.700 --> 01:40:51.300]  значение в accept должно совпадать. Опять же, это ровно формировка теории. Вот мы теперь это можем
[01:40:51.300 --> 01:41:01.780]  записать при желании скомпилировать в PDF и проверить. И вот запустив на таком наборе с такими
[01:41:01.780 --> 01:41:08.460]  параметрами muddle-checker мы узнаем, что у нас в мультипаксосе получилось то ли 6 миллионов
[01:41:08.460 --> 01:41:17.900]  состояний, то ли 700 тысяч состояний в зависимости от того, как считать. Почему 700 тысяч меньше, чем 6
[01:41:17.900 --> 01:41:21.180]  миллионов? Ну, в смысле, почему два разных счетчика состояний? Потому что некоторые
[01:41:21.180 --> 01:41:31.540]  состояний различать не стоит. Скажем, вы отправили сообщение... Дело не в том, что у вас два
[01:41:31.540 --> 01:41:36.740]  состояний, ромбиком вы пришли к одному и тому же состоянию, потому что у вас два события
[01:41:36.740 --> 01:41:43.620]  коммутировали. А дело в том, что некоторые состояний будут симметричны в том смысле, что из одного
[01:41:43.620 --> 01:41:51.260]  можно получить другое, просто перенумерував аксепторы или перенумерував значения. Вот понятно,
[01:41:51.260 --> 01:41:56.340]  что различать такие случаи не стоит, и muddle-checker их не различает, и ровно поэтому, когда мы задаем
[01:41:56.340 --> 01:42:03.660]  ему параметры, мы говорим, что вот 1а2а3 это просто некоторые идентификаторы аксепторов, и можно их
[01:42:03.660 --> 01:42:09.580]  перенумеровывать. Они ничем друг от друга не отличаются, они все одинаковы. Со значениями то
[01:42:09.580 --> 01:42:22.740]  же самое. Вот это позволяет перебор сокращать. Вот так вот можно задать Paxos. Не то чтобы это
[01:42:22.740 --> 01:42:31.940]  очень-очень удобно читалось, потому что тут бы много таких... Не поворачивайся сказать слово
[01:42:31.940 --> 01:42:42.140]  инженерных оптимизаций. У нас новый вопрос в чате. Найдет ли TLC LifeLog? TLC найдет LifeLog,
[01:42:42.140 --> 01:42:53.780]  и я чуть позже про него покажу. Чуть позже я его покажу в другом контексте. Ну, LifeLog это
[01:42:53.780 --> 01:43:01.060]  что-то паральное свойство, значит его можно проверять. Я хотел про оптимизации поговорить.
[01:43:01.060 --> 01:43:05.580]  Смотрите, тут много оптимизаций. Когда мы отправляем сообщение в сеть, мы отправляем его сразу всем.
[01:43:05.580 --> 01:43:11.860]  Когда мы отправляем сообщение в сеть, мы его после этого никогда из сети не извлекаем. То есть когда
[01:43:11.860 --> 01:43:22.260]  мы получаем сообщение, мы пишем, что существует m, множество messages такое и так далее. Что? Ну да,
[01:43:22.260 --> 01:43:28.100]  мы таким образом упрощаем жизнь Model Checker. Вот вопрос, а как такая спека учитывает сбои узлов?
[01:43:28.100 --> 01:43:36.420]  Учитывает она как-то их или нет? Рестарта точно не учитывает здесь, а вот
[01:43:36.420 --> 01:43:49.540]  сбой, исполнение в котором узел умер, это исполнение в котором узел просто не двигается,
[01:43:49.540 --> 01:43:54.020]  но не совершает ходов. А поскольку Model Checker перебирает все возможные траектории, в том числе
[01:43:54.020 --> 01:43:59.300]  в сети, в котором какой-то узел не ходит, то это в общем-то равносильно. То есть тут не нужно каким-то
[01:43:59.300 --> 01:44:05.740]  образом моделировать partition или моделировать сбои узлов. Вот partition это просто некоторые
[01:44:05.740 --> 01:44:11.460]  исполнения, где долгое время какие-то сообщения не долетают до каких-то узлов. Model Checker переберет
[01:44:11.460 --> 01:44:16.700]  все возможные исполнения, в том числе и такие. Поэтому необходимости как-то явно описывать такие
[01:44:16.700 --> 01:44:30.620]  partition в спецификации нет. А зачем мы зафиксировали Bell от одного до четырех? Ну а как мы будем? Ну а
[01:44:30.620 --> 01:44:35.620]  иначе Model Checker что перебирать? Чтобы ограничить число состояния в нашем графе, чтобы оно было
[01:44:35.620 --> 01:44:43.180]  конечным, чтобы Model Checker завершался. Ну кажется другая модель получилась. В чем здесь хитрость?
[01:44:43.180 --> 01:44:49.020]  Непонятно. Здесь нету хитрости. Мы просто хотим дождаться, чтобы проверка завершится. Мы можем
[01:44:49.020 --> 01:44:58.660]  написать 100, но тогда понимаешь, что любой параметр, все эти параметры вместе комбинаторно
[01:44:58.660 --> 01:45:06.780]  перемножаются и получается экспоненциальное число состояния в нашем мире. Даже для таких маленьких
[01:45:06.780 --> 01:45:20.340]  параметров мы получили 6, где было? 6 миллионов состояний. У нас всего лишь 3 acceptora, 4 было
[01:45:20.340 --> 01:45:29.180]  от number, 2 значения. Вот, разумеется, мы не можем брать большие числа. Если мы хотим какие-то
[01:45:29.180 --> 01:45:35.900]  свойства проверить eventually, то может при больших числах что-то испортиться или нет? Я думаю,
[01:45:35.900 --> 01:45:42.020]  что не может. Если ты сдавал курс весной, то ты знаешь, что количество потоков или количество
[01:45:42.020 --> 01:45:50.780]  узлов мало на что влияет. Влияет конкурентность. Вот это ломает алгоритмы, но конкурентность Model
[01:45:50.780 --> 01:45:54.700]  Checker как раз перебирает полностью. То есть он перебирает все возможные состояния, которые
[01:45:54.700 --> 01:46:02.620]  достижимы в исполнении алгоритма. Но бы ценой того, что он перебирает какие-то конечные графы
[01:46:02.620 --> 01:46:07.380]  для небольших значений параметров, для небольших значений свободных переменных.
[01:46:07.380 --> 01:46:14.140]  Но мы, поскольку мы верим, что баги конкурентно не так устроены, а мы, кажется, верим, но потому
[01:46:14.140 --> 01:46:20.700]  что контрпремеров просто не существует. Мы верим, что даже с такими параметрами, если мы не найдем
[01:46:20.700 --> 01:46:26.900]  ошибок, то мы будем склонны считать, что алгоритм корректен. Разумеется, ты можешь эти значения
[01:46:26.900 --> 01:46:32.900]  увеличивать, брать больше acceptors, больше bullet numbers. Но как алгоритм пакса зависит от большого
[01:46:32.900 --> 01:46:37.180]  количества bullet numbers. Что может случиться с bullet number 7 и не может случиться с тремя?
[01:46:37.180 --> 01:46:49.380]  Тут проблема не в значениях, а в конкуренции. В каком порядке долетают сообщения? Вот мы верим,
[01:46:49.380 --> 01:46:57.980]  что для небольшого количества acceptors, небольшого количества bullet numbers будет достаточно для того,
[01:46:57.980 --> 01:47:09.780]  чтобы быть уверенными, что алгоритм корректен. Что еще у нас в этой спейке привлекает? Ну не
[01:47:09.780 --> 01:47:23.060]  привлекает, а скорее вызывает вопросы. Возможно, нам не нравится, что она написана как будто ее
[01:47:23.060 --> 01:47:33.260]  фусцировали намеренно. Мы сейчас посмотрим другую спеку, и там все будет лучше. Это скорее отношение
[01:47:33.860 --> 01:47:39.620]  представьте себе, как люди пишут из академии и как пишут инженеры. Пишут по-разному. Вот так же и
[01:47:39.620 --> 01:47:46.460]  лэмпард. Он пишет логическую формулу, но даже логическую формулу можно написать в продакшн качества.
[01:47:46.460 --> 01:47:55.580]  Вот это логическая формула математика, а сейчас я найду логическую формулу инженера. Вот логическая
[01:47:55.580 --> 01:48:06.020]  формула инженера. Тут комментарии больше, чем формул, и все обозначения, которые вводятся,
[01:48:06.020 --> 01:48:12.420]  они еще длинные и читаемые. Вот спека получается, конечно, больше, какие-то тысячи строк. Это
[01:48:12.420 --> 01:48:20.700]  протокол изоляции транзакций, который у нас будет через неделю или через две. Так вот, эта спека
[01:48:20.700 --> 01:48:29.580]  написана инженером облака Amazon, и она оставляет совершенно другое впечатление. Можете догадаться.
[01:48:29.580 --> 01:48:37.700]  Так что это здесь не свойство TLA, это свойство лэмпарда. А вот свойство TLA, оно вот здесь вот. Видите,
[01:48:37.700 --> 01:48:50.420]  здесь есть такой специальный предикат TypeOC. Дело в том, что TLA динамически типизирован,
[01:48:51.180 --> 01:48:58.220]  язык, у которого нет статических типов. Почему? Потому что если у вас язык с статическими типами,
[01:48:58.220 --> 01:49:04.340]  то он вас в векторном смысле ограничивает. Вот представьте, как бы вы на C++ написали бы множество
[01:49:04.340 --> 01:49:09.700]  сообщений, где сообщение будет разных типов. Вы бы смогли это написать с помощью каких-нибудь
[01:49:09.700 --> 01:49:15.180]  вариантов, но вы бы, безусловно, страдали в своем коде. А лэмпард просто множество
[01:49:15.180 --> 01:49:25.260]  messenger кладет совершенно гитрогенные объекты в этом сэнде и совершенно не беспокоится. Ну,
[01:49:25.260 --> 01:49:31.780]  при написании не беспокоится. Когда он спеку написал, он хочет убедиться, что она типизируется
[01:49:31.780 --> 01:49:37.500]  нормально. И он это проверяет в рантайме. Каким образом он просто в каждом... Он запускает проверку
[01:49:37.500 --> 01:49:42.180]  инварианта TypeOC. Вот если вы написали большую спеку, то начнете здесь с проверки инварианта
[01:49:42.180 --> 01:49:49.020]  Safety, SafeValue здесь называется, а с проверки инварианта TypeOC, что вот эта формула выполняется в
[01:49:49.020 --> 01:49:55.340]  каждом отдельном состоянии, которое был у чехер посетит. Если выполняется, то, наверное, ваша спека
[01:49:55.340 --> 01:50:13.020]  делает что-то разумное. Вы ей можете верить. Что еще можно было бы про эту спеку сказать? Не знаю.
[01:50:13.020 --> 01:50:20.260]  Если у вас вопросы остаются, то задавайте. Если нет, то я дальше пойду. Я хотел про RAFT
[01:50:20.260 --> 01:50:30.180]  поговорить. Вот здесь уже спецификация большая, и мне кажется, что она написана достаточно читаема,
[01:50:30.180 --> 01:50:39.820]  в отличие от Paxos, и по ней ориентироваться при некоторой сноровке даже проще, чем по вот этому
[01:50:39.820 --> 01:50:47.980]  описанию из статьи. Вот смотрите, с чего мы начинаем чтение спецификации. Скорее всего,
[01:50:48.300 --> 01:50:53.980]  множество переменных может быть, но скорее всего с оператора Next, с actionNext. Что вообще в системе
[01:50:53.980 --> 01:51:01.820]  происходит? И вот здесь actionNext иллюстрирует нам все возможные события, все возможные переходы,
[01:51:01.820 --> 01:51:08.740]  которые в RAFT рассматриваются. Рестарт узла, тайм-аут реакшн таймера, где мы считаем, что лидер,
[01:51:08.740 --> 01:51:15.060]  видимо, уже мертв, где мы посылаем request vote с просьбой проголосовать за нас, мы становимся лидером,
[01:51:15.060 --> 01:51:21.260]  мы получаем запрос от клиента, мы двигаем commit-индекс вперед, мы получаем команду
[01:51:21.260 --> 01:51:29.980]  репликации от немы. Тут существует EG, то есть ИТ-сервер отправил житому сообщение request
[01:51:29.980 --> 01:51:37.580]  vote с просьбой проголосовать за себя в каком-то терме. В общем, это все, что может с миром
[01:51:37.580 --> 01:51:42.980]  происходить, с миром RAFT. Ну и почему такая спека может быть полезна? Вот смотрим, например,
[01:51:42.980 --> 01:51:52.860]  на actionRestart. Какая нам от него польза? Нам как разработчика. Вот в RSM, который мы пишем,
[01:51:52.860 --> 01:51:57.500]  есть состояние персистентное, есть волатильное. То есть мы должны что-то хранить в памяти,
[01:51:57.500 --> 01:52:04.300]  что-то мы можем хранить в памяти, а что-то мы обязаны хранить на диске. И вот по этому action
[01:52:04.300 --> 01:52:09.300]  можно понять, какое состояние волатильное, какое персистентное. Вот в RAFT здесь написано,
[01:52:09.300 --> 01:52:16.300]  какое-какое. Но вот эту же информацию можно получить из спеки, читая этот action. Вот current
[01:52:16.300 --> 01:52:23.380]  терм не меняется при рестарте. VotedFor, отданный голос не меняется при рестарте. Log не меняется
[01:52:23.380 --> 01:52:29.220]  при рестарте. Это означает, что это персистентное состояние. Смотрим статью, и вот действительно
[01:52:29.220 --> 01:52:38.900]  эти три переменные должны храниться надежно на диске. Вот, а при этом текущий стейт узла может
[01:52:38.900 --> 01:52:47.980]  потеряться. Какие-то собранные при голосовании голоса могут потеряться. Знание про то, как мы
[01:52:47.980 --> 01:52:55.580]  матчимся с другой репликой по логу тоже может потеряться. Все это не страшно. Или, например,
[01:52:55.580 --> 01:53:07.860]  мы пытаемся понять, что делает реплика, когда у нее истекает reaction timer. Вот, можно здесь
[01:53:07.860 --> 01:53:17.180]  это пытаться найти, ну вот, например. Какие-то действия описаны. Вот спецификации их можно найти в
[01:53:17.180 --> 01:53:25.780]  action timeout. Вот сервер И, у него истек timeout, и он считает, что лидер текущего терма отказал.
[01:53:25.780 --> 01:53:39.540]  Тогда он становится кандидатом, он увеличивает терм на единицу, он сбрасывает голос. То есть
[01:53:39.540 --> 01:53:48.460]  он пока ни за кого не проголосовал. Ну и дальше он может отправить request vote, потому что он
[01:53:48.460 --> 01:54:00.940]  кандидат, и жид и ему еще не ответил. Вот тогда в сеть можно положить вот такое сообщение. И здесь
[01:54:00.940 --> 01:54:07.740]  мы видим, что мы именно посылаем при голосовании. Мы посылаем свой терм, мы посылаем терм последней
[01:54:07.740 --> 01:54:26.380]  записи влоги, мы посылаем длину лога. Ну вот, в общем, такие сообщения. Вот это более сложный
[01:54:26.380 --> 01:54:31.300]  экшен, где реплика реагирует на доставленные сообщения. Ну, кстати, это уже сил нет, да и
[01:54:31.300 --> 01:54:38.740]  время у нас лучше на другое потратить. В общем, спеку RAF-то можно использовать просто как
[01:54:38.740 --> 01:54:48.100]  документацию алгоритма. Более подробную, чем вот это словесное писание, и гораздо менее подробную,
[01:54:48.100 --> 01:54:54.580]  менее детализированную, чем код на C++, который у нас где-то был здесь. Тут, конечно, можно...
[01:54:54.580 --> 01:55:02.500]  Вот все эти спецификации, они же именно про дизайн и про корректность алгоритма. Или их,
[01:55:02.500 --> 01:55:08.540]  в теории, можно как-то соединить с реализацией, проверить, что мы этот алгоритм реализовали правильно.
[01:55:08.540 --> 01:55:13.420]  Я как раз к этому хотел перейти, потому что мы можем с помощью формальных методов,
[01:55:13.420 --> 01:55:22.060]  с помощью спецификации на тело E+, написать понятную формальную документацию и потом
[01:55:22.060 --> 01:55:29.340]  проверифицировать с помощью Model Checker. Но мы верифицируем дизайн, а в конечном итоге мы бы
[01:55:29.340 --> 01:55:37.460]  хотели верифицировать реализацию. Мы хотели бы быть уверены не только в дизайне, но и в коде,
[01:55:37.460 --> 01:55:44.660]  который мы написали тоже. Я сейчас к этому перейду, буквально пара слов про RAF-то. Вот эта спека,
[01:55:44.660 --> 01:55:51.780]  ее уже сложно проверить, так как можно проверить спеку Paxos. Почему? Потому что хотя бы из-за
[01:55:51.780 --> 01:55:59.260]  этого экшена вот здесь прирастает current term. Поэтому если мы начнем такую спеку прогонять
[01:55:59.260 --> 01:56:05.060]  через Model Checker, то в ней будет бесконечно много состояний, потому что термы будут расти. И будет
[01:56:05.060 --> 01:56:15.180]  цепочка, где просто каждая реплика тайм-аутится на каждом шаге. Значит ли это, что эта
[01:56:15.180 --> 01:56:23.540]  спецификация годится только для документации, не годится для проверки. Но мы можем запустить ее
[01:56:23.540 --> 01:56:30.660]  в Model Checker и ограничить глубину или просто ждать. И чем больше мы прождем, тем больше мы будем
[01:56:30.660 --> 01:56:36.940]  уверены, что алгоритм корректи. Просто потому что он так вот волнами исследует граф конфигурации.
[01:56:36.940 --> 01:56:45.460]  Вот, это уже такая более инженерная документация, в смысле написана более
[01:56:45.460 --> 01:56:56.140]  человечная, в отличие вот от вот этого фарша символов. Ну и да, я говорил вам, что можно делать
[01:56:56.140 --> 01:57:01.860]  это совсем хорошо, если у вас много свободного времени и вы знаете хороший код промышленного
[01:57:01.860 --> 01:57:08.140]  качества. Можете писать промышленного качества логические формулы еще. Но это все логические
[01:57:08.140 --> 01:57:16.460]  формулы и замечательно все, что... Да, договорю, раз уж начал. Тут критерии качества промышленные,
[01:57:16.460 --> 01:57:23.900]  они применимы к логическим формулам и в других смыслах. Вот вы пишете, во-первых,
[01:57:23.900 --> 01:57:28.340]  комментарии в коде, во-вторых, вы тесты кода пишете еще. То есть вы проверяете, что ваша
[01:57:28.340 --> 01:57:33.460]  спецификация, в смысле ваш код вообще работает, что он делает что-то разумное.
[01:57:33.460 --> 01:57:44.620]  Вот к спецификации тоже можно писать unit-тесты. Вот тут есть какие-то дикие... Сейчас мы найти это.
[01:57:44.620 --> 01:57:48.380]  Может быть, в этой спецификации нет.
[01:57:48.380 --> 01:58:03.380]  Черт возьми, нет только хорошего примера. Но можно для самой спецификации писать маленькие
[01:58:03.380 --> 01:58:09.100]  unit-тесты, то есть некоторые сложные предикаты, и потом с помощью Model Checker вылидировать,
[01:58:09.100 --> 01:58:13.940]  что они действительно выполняются, то есть проверяешь, что строили линеризуемое. Вот такой
[01:58:13.940 --> 01:58:17.780]  предикат можно написать, он будет устроен суперсложно, но все равно можно убедиться,
[01:58:17.780 --> 01:58:22.420]  что он корректен, просто запустив его на некоторых конкретных историях. В общем,
[01:58:22.420 --> 01:58:26.060]  все практики, которые применяются, многие практики, которые применяются в промышленном
[01:58:26.060 --> 01:58:29.260]  программировании, их можно перенести на программирование логических формов.
[01:58:29.260 --> 01:58:35.140]  Но, наконец, мы все еще не уверены, что наша реализация будет корректна. Даже если мы придумали
[01:58:35.140 --> 01:58:43.820]  дизайн, даже если мы его строго изложили в виде спецификации, даже если мы верифицировали
[01:58:43.820 --> 01:58:48.940]  спецификацию с помощью Model Checker, все равно остается шанс, что мы напортачили в реализации.
[01:58:48.940 --> 01:58:56.700]  Вот нам же хочется в итоге получить работающий код, который поверх работающего дизайна,
[01:58:56.700 --> 01:59:00.740]  вот работающий дизайн у нас есть, а в коде мы ошиблись. Почему мы в коде ошиблись? Где мы вообще могли
[01:59:00.740 --> 01:59:15.380]  ошибиться? Ну, просто невнимательно. Ну, скорее всего, дополнительная сложность, которую ты
[01:59:15.380 --> 01:59:21.340]  получаешь, программируя распределенные системы, это конкурентность. Вот в спейке Паксоса у тебя
[01:59:21.340 --> 01:59:30.100]  все однопоточное. В смысле, странное заявление. В спейке Паксоса у тебя цепочки, где изотоварных
[01:59:30.100 --> 01:59:37.220]  шагов. В рафте у тебя здесь тоже переходы атомарные. Вот кто-то отправил... у кого-то
[01:59:37.220 --> 01:59:42.340]  истек тайм-аут, кто-то отправил реквест в аут. А в коде у тебя все конкурентно. И вот в коде у тебя
[01:59:42.340 --> 01:59:46.140]  появляются какие-то блокировки, какие-то локи-анлоки. Здесь это довольно сложно устроено,
[01:59:46.140 --> 01:59:59.140]  но мы это еще в будущем увидим. И можно ошибиться в конкарнсе. Во-первых, как можно провалидировать,
[01:59:59.140 --> 02:00:08.060]  что вы конкарнсе пишете правильно. Ваши примитивы и синхронизации, которые вы используете,
[02:00:08.060 --> 02:00:15.300]  тоже корректны. В этом написали какие-то страшные мьютексы или экзекутеры страшные,
[02:00:15.300 --> 02:00:19.540]  какие-то лог-фри очереди, что-то подобное. Вот для этого, оказывается, тоже можно использовать
[02:00:19.540 --> 02:00:24.980]  CLA+. Это все еще не про код, но про другой аспект реализации. Не про дизайн верхней уровней,
[02:00:24.980 --> 02:00:36.780]  а про примитивы конкурентности, которые мы используем. Конкарнсе тоже можно специфицировать
[02:00:36.780 --> 02:00:46.660]  и верифицировать с помощью CLA+. Но если, скажем, конкарнсе в распределенной системе можно выразить
[02:00:46.660 --> 02:00:55.940]  с помощью дизъюнкции и с помощью кванторосуществования, это тот инструмент, с помощью которого вы
[02:00:55.940 --> 02:01:00.660]  конкуренции, с помощью которого вы конкуренции описываете в распределенной системе в CLA+,
[02:01:00.660 --> 02:01:11.020]  то вот такой низкоуровневый способ для конкурентности на уровне потоков вам уже не подходит. С потоками
[02:01:11.020 --> 02:01:15.540]  все-таки у вас есть планировщик, как единственный источник интерминизма и конкарнсе, и у вас есть
[02:01:15.540 --> 02:01:21.100]  какие-то атомарные шаги в потоках, и потоки перемешиваются друг с другом. Вот на CLA+,
[02:01:21.100 --> 02:01:27.060]  какого-то адекватного способа выразить это нет, вы сойдете с ума, если будете описывать отдельные
[02:01:27.060 --> 02:01:32.940]  маленькие шаги, отдельные инструкции, таким образом. Но для решения этой проблемы существует
[02:01:32.940 --> 02:01:40.940]  промежуточный язык, который называется плюскаль, потому что плюскаль, как паскаль, только, в общем,
[02:01:40.940 --> 02:01:48.980]  немного по-другому. И в нем уже есть понятие потоков, есть понятие процедур функций,
[02:01:48.980 --> 02:01:58.180]  есть понятие макросов для атомарных операций, и вот есть метки. И можно описать какой-то... Вот это,
[02:01:58.180 --> 02:02:07.120]  кстати, ваша домашка про LifeLog, первая домашка из весеннего курса. Здесь написан алгоритм
[02:02:07.120 --> 02:02:14.160]  взаимоисключения, в котором есть LifeLog, и для него написаны свойства safety и свойства liveness.
[02:02:14.160 --> 02:02:23.200]  И этот код написан уже в таком императивном стиле. Вот мы сначала выполняем фидж-эт, если мы
[02:02:23.200 --> 02:02:27.360]  получили что-то больше 0, то мы уменьшаем его, а потом пробуем заново, снова делаем фидж-эт,
[02:02:27.360 --> 02:02:34.660]  если получить больше 0, пробуем заново. Если помните, у нас такая игрушечная задачка была. Вот такой
[02:02:34.660 --> 02:02:41.020]  код можно верифицировать с помощью того же самого ModelChecker, если предварительно транслировать его
[02:02:41.020 --> 02:02:51.940]  в TLA+. И это можно сделать механически. Каким образом? Тут долго рассказывать, я общий принцип поясню.
[02:02:51.940 --> 02:02:59.580]  Вот у нас здесь есть метки, это такие атомарные шаги. Между этими атомарными шагами, то есть вы
[02:02:59.580 --> 02:03:05.940]  можете сделать один шаг, потом переключиться на другой поток, на другой процесс. Вы можете взять
[02:03:05.940 --> 02:03:14.340]  этот высокоуровневый код и транслировать его в низкоуровневый логический Assembler. Он не
[02:03:14.340 --> 02:03:20.220]  предназначен для чтения, так же как Assembler, не предназначен для чтения людьми, но его уже может
[02:03:20.220 --> 02:03:28.140]  валидировать ModelChecker TLA. Трансляция устроена довольно забавно. Я бы сказал, что это буквально
[02:03:28.140 --> 02:03:35.140]  компирация в Assembler, потому что... Вот представим, что у вас есть... Ну, во-первых, как устроен
[02:03:35.140 --> 02:03:45.060]  атомарный шаг? Вы пишите l1 fetch add. Для каждой метки генерируется служебный action. Он говорит,
[02:03:45.060 --> 02:03:52.460]  что programCounter сейчас равен l1, programCounter, штрихованный после этого action, равен l2.
[02:03:52.460 --> 02:04:04.540]  Вот. А переменная count, она на единицу увеличилась. То есть мы можем вот такие вот простые атомарные
[02:04:04.540 --> 02:04:14.220]  шаги... Да, и значение pref оказалось в старое значение count. Вот мы в теле плюс выразили
[02:04:14.220 --> 02:04:21.900]  операцию fetch add, которую написал сам пользователь, впрочем. Вот. Что происходит, когда мы зовем
[02:04:21.900 --> 02:04:35.820]  какую-то функцию? Ну или давайте себе вот... Сейчас другой пример. Call Tricky Unlock, где мы делаем
[02:04:35.820 --> 02:04:47.060]  fetch add. В Unlock для него тоже будет служебный action, и в нем мы проверяем, что programCounter был
[02:04:47.060 --> 02:04:57.620]  равен Unlock, programCounter, штрихованный, становится равен чему? Первой метке процедуры, которую мы вызвали,
[02:04:57.620 --> 02:05:11.460]  o1. Но при этом мы должны для будущего возврата из этой функции в стэк вызовов положить,
[02:05:11.460 --> 02:05:17.660]  а куда мы, собственно, должны вернуться. Мы обновляем наш стэк вызовов, добавляем в него
[02:05:17.660 --> 02:05:23.340]  новый стэковый frame, где мы говорим, что возвращаемся в процедуру Tricky Unlock в метку lock,
[02:05:23.340 --> 02:05:33.540]  когда мы отсюда выйдем из процедуры Tricky Unlock вот по этому return. А теперь смотрим на o2.
[02:05:33.540 --> 02:05:42.620]  Здесь мы находимся в метке o2, и мы должны перейти в метку, которую мы извлекаем из головы стэка,
[02:05:42.620 --> 02:05:49.660]  а потом мы попаем сам стэк. Ну не потом, в смысле вот как бы все вместе. Короче, вот у нас тут
[02:05:49.660 --> 02:05:53.620]  служебные переменные programCounter, это просто instruction pointer, у нас здесь callstack моделируется.
[02:05:53.620 --> 02:05:59.700]  Ну короче, мы вот буквально компилируем вот этот псевдокод в логический assembler с такими же
[02:05:59.700 --> 02:06:05.100]  собственными структурами данных, которые у вас в процессоре выполняются. А дальше мы можем
[02:06:05.100 --> 02:06:11.580]  запустить проверку safety свойства и liveness свойств. И safety свойства, она у нас выполняется,
[02:06:11.580 --> 02:06:16.900]  liveness свойства нарушаются, разумеется, потому что есть lifelog. И тут его невозможно, конечно,
[02:06:16.900 --> 02:06:23.580]  читать, но tli plus его находят, его можно декодировать отсюда. Я думаю, что вы как бы сами найдете его
[02:06:23.580 --> 02:06:31.500]  быстрее, сами его искали быстрее. Разве что можно показать, как именно свойства формулируются,
[02:06:31.500 --> 02:06:40.740]  свойства liveness. Вот logany и logall. Что из них что? Давайте читать, потому что я сам не помню.
[02:06:40.740 --> 02:06:48.700]  Logany. Существует процесс такой, что если programCounter этого процесса не равен критической секции,
[02:06:48.700 --> 02:06:57.460]  то загадочные символы programCounter равны критической секции. logall для любого p из множества процессов,
[02:06:57.460 --> 02:07:06.140]  если programCounter p не равен, то магические символы programCounter равны. Вот смотрите,
[02:07:06.140 --> 02:07:09.900]  у нас есть две гарантии прогресса, сильные и слабые. Сильные про то, что каждый поток,
[02:07:09.900 --> 02:07:13.940]  получится критическую секцию, слабые, что какой это поток?
[02:07:21.780 --> 02:07:30.620]  Ну, точнее так, слабая гарантия прогресса, она про то, что mutex бесконечно часто захватывают.
[02:07:30.620 --> 02:07:40.140]  mutex бесконечно часто... если у вас число потоков конечное, то утверждение, что mutex бесконечно
[02:07:40.140 --> 02:07:45.660]  часто захватывают, эквивалентно тому, что какой-то поток бесконечно часто захватывает mutex. Вот,
[02:07:45.660 --> 02:07:55.180]  и ровно это формулируется в свойствах logany. Вот tilde-стрелочка означает следующее. Давайте
[02:07:55.180 --> 02:08:02.180]  попробую здесь написать. Лучше, конечно, на доске. tilde-стрелочка — это когда у вас
[02:08:02.180 --> 02:08:13.900]  phi tilde-стрелочка psi. Это означает, кажется, это сокращение для такого.
[02:08:13.900 --> 02:08:34.660]  Всегда верно, что если phi, то event чьё ли psi. То есть существует процесс такой, что если прямо
[02:08:34.660 --> 02:08:41.860]  сейчас он не в критической секции, то в будущем он обязательно будет в критической секции. Но это
[02:08:41.860 --> 02:08:52.340]  справедливо для любого суффикса. Вот, это свойство можно запустить, проверить, и Model Checker найдёт
[02:08:52.340 --> 02:09:06.460]  страшное, плохо читаемое исполнение. Где-то оно... я его свернул. Что делать? Вот, смотрите, тут есть
[02:09:06.460 --> 02:09:11.100]  некоторая фундаментальная беда такого подхода. С одной стороны, всё довольно астроумно, то есть
[02:09:11.100 --> 02:09:26.380]  мы пишем такой псевдокод, потом мы нажимаем кнопочку в IDE «транслировать его». Но сейчас я не
[02:09:26.380 --> 02:09:32.940]  транслирую, потому что я ошибку написал. Здесь, синтоксическую. Если мы её сотрём и нажмём на
[02:09:32.940 --> 02:09:44.060]  кнопку, то компилятор этой IDE сгенирует код, такой логический, и его провалидирует относительно
[02:09:44.060 --> 02:09:50.660]  свойств, и найдёт ошибку. Но беда в том, что Model Checker работает уже не с этим понятным кодом,
[02:09:50.660 --> 02:09:59.420]  где есть функция, где есть атомарные шаги, а вот с этим вот, с этим фаршем Assembler. И bit.race,
[02:09:59.900 --> 02:10:05.140]  который сейчас тоже в виде такого вот фарша. Нужно её декодировать, то есть в этом состоянии
[02:10:05.140 --> 02:10:11.860]  program counter 1 равен L2, program counter 2 равен log, и нужно идти сюда и смотреть, где же потоки находились.
[02:10:11.860 --> 02:10:23.020]  Не очень удобно. Кроме того, есть другая проблема. А что, если мы неверно ошиблись с метками? Вдруг мы
[02:10:23.020 --> 02:10:30.060]  подметку поместили сразу две операции над разными ячейками памяти. Вот таких операций
[02:10:30.060 --> 02:10:39.700]  атомарных в процессоре нет, а у нас они есть. И мы получили исполнение, более узкий набор
[02:10:39.700 --> 02:10:47.140]  исполнений, и мы не все случаи перебрали. Но это непреодолимые препятствия, и преодолеются они
[02:10:47.140 --> 02:10:56.260]  совершенно другим образом. Весной я вам рассказывал про планировщик Go, как он устроен,
[02:10:56.260 --> 02:11:02.700]  и, может быть, говорил, что другие языки этот дизайн переиспользуют, в том числе планировщик
[02:11:02.700 --> 02:11:09.820]  для фреймворка Tokyo в Rust. И вот есть статья, как они писали свой быстрый планировщик. Тут,
[02:11:09.820 --> 02:11:14.980]  в общем-то, пересказ идей планировщика Go. Ничего интересного до момента, когда появляется Loom.
[02:11:14.980 --> 02:11:23.100]  Вот они написали код, и теперь его нужно проверить. Вот для того, чтобы проверить написанный код,
[02:11:23.100 --> 02:11:33.180]  где есть всякие лог-фри и вейт-фри очереди, разработчики написали собственный фреймворк,
[02:11:33.180 --> 02:11:40.340]  где они заставляют писать код на своих собственных атомиках и мютоксах на Rust. Но
[02:11:40.500 --> 02:11:47.500]  за этими атомиками и мютоксами прячется Model Checker. И Model Checker перебирает уже не...
[02:11:47.500 --> 02:11:54.180]  Model Checker работает не с каким-то псевдокодом, не с какими-то спецификациями,
[02:11:54.180 --> 02:11:58.380]  он работает уже непосредственно с кодом на Rust, ну или с кодом на C++, это уже неважно.
[02:11:58.380 --> 02:12:11.220]  Вот он перебирает исполнение этого кода. И в какой-то степени мы вот на вопрос отвечаем,
[02:12:11.220 --> 02:12:17.020]  как убедиться, что в коде ошибок нет. Ну можно через Model Checker прогонять сам код. Ну разумеется,
[02:12:17.020 --> 02:12:20.700]  не всякий код, потому что код обычно сложно устроен, и через Model Checker можно прогнать
[02:12:20.700 --> 02:12:24.900]  только какие-то небольшие сниппеты. Ну то есть можно протестировать там маленький, ну,
[02:12:24.900 --> 02:12:34.260]  трэдпул. Можно протестировать какой-нибудь там спинлок или очередь. Но нельзя протестировать
[02:12:34.260 --> 02:12:42.500]  настоящую реализацию RAF, которая работает поверх там каких-то трэдов, файберов, фьюч, потому что
[02:12:42.500 --> 02:12:48.900]  состояния там будет уже безумно много. Их много было даже в спецификации, а в коде настоящем их
[02:12:48.900 --> 02:12:59.020]  будет еще больше, потому что у нас просто больше подробностей. Что делать в этом случае? Вот у нас
[02:12:59.020 --> 02:13:09.220]  есть RAF, то он написан на C++. Вот у нас даже есть уже RAF, и он написан на C++. Где он был? Вот он.
[02:13:09.220 --> 02:13:15.340]  И мы хотим убедиться, что он корректный. Ну правда, вот мы собираемся по этому коду изучать RAF,
[02:13:15.340 --> 02:13:26.140]  а вдруг ему баги есть. Будет неприятно. Как так? Ну вот у нас уже написан код, понимаешь, что это
[02:13:26.140 --> 02:13:34.700]  сложно взять и... Во-первых, нужно будет переписать весь код, что довольно сложно. Ну и где-то он с этим
[02:13:34.700 --> 02:13:40.100]  фреймворком не сойдется, допустим. Ну да, ответ очевидный. Мы не можем в таком масштабе использовать
[02:13:40.100 --> 02:13:47.460]  уже перебор. Мы не можем делать model checker. Нам нужно использовать fault injection. Было бы здорово,
[02:13:47.460 --> 02:13:53.860]  если бы мы fault injection держали в уме, когда мы писали этот код. Но есть уже какие-то системы,
[02:13:53.860 --> 02:13:59.540]  которые написаны без учета fault injection, а тестировать их нужно. Убедиться, что... Ну да,
[02:13:59.540 --> 02:14:05.140]  мы верим, что эти системы построены на корректном дизайне, но в системах просто бывают баги,
[02:14:05.140 --> 02:14:11.020]  связанные с конкурентостью, связанные, там не знаю, с чем-то. Автор не выспался. Нужно убедиться,
[02:14:11.020 --> 02:14:16.460]  что в самой реализации багов нет. Fault injection внутри системы мы строить уже не можем, потому что
[02:14:16.460 --> 02:14:27.340]  вот код написан, это очень сложно было бы сделать. Ну вот для таких задач существует решение. Его
[02:14:27.340 --> 02:14:31.580]  придумал замечательный человек, которого зовут Кал Кингсбери. Вот, я не знаю, у меня где-то...
[02:14:31.580 --> 02:14:41.620]  Есть ли где-то его доклад? Ну давайте посмотрим. Минутку буквально. Он очень забавный.
[02:14:41.620 --> 02:14:52.780]  Секунду.
[02:15:11.620 --> 02:15:41.620]  Ну вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот, вот,
[02:15:41.620 --> 02:15:55.220]  Но у нас не DevFire.
[02:15:55.220 --> 02:16:00.980]  Ю Kwang-Chi, не делайте眾드�fer, manage.6i for the fire.
[02:16:00.980 --> 02:16:06.180]  menosenedORY, ищите результаты accomplishment.
[02:16:06.180 --> 02:16:14.180]  называется Jepson. Вот репозиторий на GitHub. Этот фреймворк фолтинжекшена, где фолтинжекшен,
[02:16:14.180 --> 02:16:22.700]  кстати, он тестировал у Kevin, потрясающе, где он запускает в виртуальных машинах узлы системы и,
[02:16:22.700 --> 02:16:28.260]  там, не знаю, через IP tables ломает между ними маршрутизацию, двигает системные часы в
[02:16:28.260 --> 02:16:34.440]  контейнерах, не знаю, перезагружает что-то, ломает что-то. То есть он буквально ломает физический
[02:16:34.440 --> 02:16:39.640]  мир на уровне операционной системы, в которой узлы выполняются. То есть нам не нужно менять код
[02:16:39.640 --> 02:16:47.080]  нашей системы, мы можем снаружи все это так вот ломать. И он занимается этим более-менее
[02:16:47.080 --> 02:16:52.680]  профессионально. Ему заказывают исследование корректности разработчиков этой системы,
[02:16:52.680 --> 02:16:57.760]  он исследовал, кажется, буквально все, что есть. Монгодиби тут много раз упоминается,
[02:16:57.760 --> 02:17:02.200]  вот он продолжает, ее продолжают писать, он продолжает ее ломать, ищут там какие-то баги.
[02:17:02.200 --> 02:17:09.160]  Вот. Что он искал в последний раз? Кажется, какие-то баги с транзакциями связаны. Ну,
[02:17:09.160 --> 02:17:15.840]  вот, рисовал какие-то безумно странные картинки про причинность. Вот это можно делать, не залезая
[02:17:15.840 --> 02:17:22.480]  внутрь системы, просто зная, что, там, не знаю, она реализует атомарное key-value с операции CAS,
[02:17:22.480 --> 02:17:30.040]  или она реализует key-value с транзакциями. Вот мы пишем стресс-тест, где мы проверяем некоторые
[02:17:30.040 --> 02:17:35.200]  варианты, что, не знаю, мы делаем n-анкрементов и получаем значение n, в итоге, в ящике памяти. И
[02:17:35.200 --> 02:17:41.840]  запускаем этот стресс-тест вместе с тем, нагружая систему какими-то проблемами в виде рестартов
[02:17:41.840 --> 02:17:48.440]  узлов, двигаем часы и, там, не знаю, ломаем сеть между узлами, строим какие-то партишины. Вот таким
[02:17:48.440 --> 02:17:56.160]  образом можно тестировать код, который написан без учета, без учета возможной верификации
[02:17:56.160 --> 02:18:05.360]  возможного fault injection внутри. Но если вы чуть аккуратнее, то вы можете писать код и учитывать это,
[02:18:05.360 --> 02:18:13.920]  то есть просто закладывать на стадии дизайн. Вот вы, у вас есть дизайн-ребью, вы к нему написали
[02:18:13.920 --> 02:18:30.120]  спецификацию системы. Вы, давайте откроем, сейчас я найду картинку, статью про это. Вот, это статья,
[02:18:30.120 --> 02:18:36.680]  напомню, «Амазона», про «Эксвежую систему», это статья 20-го или 21-го даже года, помню, 20-го все-же.
[02:18:36.680 --> 02:18:44.520]  Вот, они пишут, что они используют формальные методы для того, чтобы провалидировать дизайн. Ну,
[02:18:44.520 --> 02:18:50.640]  во-первых, они используют их для того, чтобы задокументировать свой дизайн, а во-вторых,
[02:18:50.640 --> 02:18:57.440]  чтобы проверить какие-то safety liveness свойства с помощью model checker TLC. Но вместе с этим они
[02:18:57.440 --> 02:19:03.280]  весь свой код пишут в фрейворке, который абстрагирует все детали физического мира.
[02:19:03.280 --> 02:19:11.360]  Вот, и дальше умеют запускать этот код в режиме симуляции детерминированной для того, чтобы
[02:19:11.360 --> 02:19:17.400]  убедиться, что сам код не нарушает свойства уже. И это тот же самый fault injection, что и в Jepsen,
[02:19:17.400 --> 02:19:23.120]  то есть вы могли бы снаружи также ломать сеть или также ломать часы. Но когда вы это все
[02:19:23.120 --> 02:19:30.040]  промоделировали внутри, то, во-первых, такие тесты работают, ну, не знаю, на какое количество
[02:19:30.360 --> 02:19:36.320]  порядков быстрее. Видимо, какая-то колоссальная разница там должна быть в миллион раз быстрее. А
[02:19:36.320 --> 02:19:45.680]  кроме того, вы можете просто более сложные сценарии проворачивать. То есть вы можете написать поломку
[02:19:45.680 --> 02:19:52.360]  вашего кода в симуляторе совершенно, ну, не знаю, любые партишины в сети в симуляторе сделать
[02:19:52.360 --> 02:19:57.640]  гораздо легче, чем в реальном мире. Любой дрейф часов, короче говоря, все, что вы можете представить
[02:19:57.640 --> 02:20:02.640]  себе, все сбои, которые вы можете вообразить, и гораздо проще моделировать кодом в симуляторе,
[02:20:02.640 --> 02:20:10.400]  чем пытаться делать их снаружи. И проще, и быстрее, и можно сделать это гораздо разнообразнее. Вот эта
[02:20:10.400 --> 02:20:17.760]  идея, мне кажется, это не они придумали, потому что такой подход используют в Apple в системе,
[02:20:17.760 --> 02:20:25.720]  которая называется FoundationDB. Вот опять, не важно, что это за система, важно, что в 2013 году про нее
[02:20:25.720 --> 02:20:30.720]  был замечательный доклад, про то, что это, кажется, первые люди, которые в мире, которые решили
[02:20:30.720 --> 02:20:36.920]  сделать так, решили абстрагировать весь недотерминизм, который в системе есть, весь внешний мир,
[02:20:36.920 --> 02:20:46.440]  сеть, часы, диск, время, и написать весь код поверх симулятора. Это позволяет, во-первых,
[02:20:46.440 --> 02:20:56.200]  делать fault injection, гораздо внедрять сбои вообще в любые места вашей программы, и, во-вторых,
[02:20:56.200 --> 02:21:00.240]  добавляет, что важно, дотерминизм, воспроизводимость. Вы можете, если у вас проблемы,
[02:21:00.240 --> 02:21:05.440]  воспроизвести исполнение и добавить отладки. Короче, вы понимаете, что это значит. И вот точно
[02:21:05.440 --> 02:21:12.720]  так же они начали с того, что написали собственную библиотеку Concurrency, потому что она им нужна была
[02:21:12.720 --> 02:21:18.760]  для дотерминизма, для того, чтобы они контролировали, что там нигде нет хэшмэпов, нигде нет потоков,
[02:21:18.760 --> 02:21:25.280]  которые не дотерминированно планируются. Ну и фреймворк у них, у них тоже открытый код,
[02:21:25.280 --> 02:21:34.160]  можно посмотреть на их фреймворк, он называется Flow. Там у них такие акторы с фьючами, но акторы,
[02:21:34.160 --> 02:21:39.440]  они здесь, это такое расширение компилиатора, но я бы сказал, что сейчас это более-менее
[02:21:39.440 --> 02:21:45.920]  эквивалентно к рутинам. В смысле цель у них точно такие же, то есть скомпилировать код в
[02:21:45.920 --> 02:21:52.840]  какую-то стейт-машину. Вот они это сделали, они получили дотерминизм на уровне Concurrency и дальше
[02:21:52.840 --> 02:22:00.640]  они пишут весь свой промышленный код с помощью этого фреймворка и с помощью симулятора. Ну и
[02:22:00.640 --> 02:22:05.360]  также у них симуляция задается одним числом и на выход дают одно число и другое число. Если там,
[02:22:05.360 --> 02:22:10.880]  не знаю, сиды одинаковые, а дайджесты получились разные, то, видимо, там, не знаю, код дотерминирован,
[02:22:10.880 --> 02:22:18.240]  доверять ему нельзя. Вот и так можно написать большую промышленную систему. Вот оно.
[02:22:18.240 --> 02:22:28.360]  Конечно, этот подход тоже несовершенен, потому что вы, кажется, понимаете, чем симуляция
[02:22:28.360 --> 02:22:35.380]  отличается от реального исполнения тем, что, например, в симуляции в шаге потока, в шаге файбера не
[02:22:35.380 --> 02:22:40.520]  идет время. Вот у них такая же проблема, у них есть доклад, где они описывают все эти трудности. У них
[02:22:40.520 --> 02:22:45.120]  тоже время не идет, потому что непонятно, как можно было бы двигать часы, когда файбер исполняется,
[02:22:45.120 --> 02:22:51.600]  если мы хотим делать дотерминированно все. Но в целом никто вас не заставляет использовать один
[02:22:51.600 --> 02:23:03.000]  подход. Разумно использовать все. То есть вы по возможности закладываете, вы проектируете вашу
[02:23:03.000 --> 02:23:08.520]  систему, пишете дизайн документ в виде спецификации на TLA, вы используете Model Checker для того,
[02:23:08.520 --> 02:23:15.880]  чтобы провалидировать какие-то аспекты, вы используете эту спецификацию как форму документации для
[02:23:15.880 --> 02:23:24.400]  вашего дизайна, а дальше вы пишете код. Ну я не сказал разумеется, с чего нужно начинать. С того,
[02:23:24.400 --> 02:23:31.320]  чтобы выбрать правильный язык и уже к нему добавлять все эти инструменты fault injection и внешний
[02:23:31.320 --> 02:23:38.320]  и внутренний. И с языком тут тоже очень интересно, в смысле это отдельная сторона вопроса и отдельный
[02:23:38.320 --> 02:23:44.480]  современный тренд. Как, куда современные языки двигаются. Вот разумеется, вы пишете систему,
[02:23:44.480 --> 02:23:49.880]  не на питоне, не потому что питон медленный, а потому что питон динамически типизированный.
[02:23:49.880 --> 02:23:54.080]  Если вы когда-нибудь писали, видели проект на питоне большой, видели тесты, то вы знаете,
[02:23:54.080 --> 02:23:59.440]  что в этих тестах проверяется, что верно ли, что мы там отправили функцию в строчку и получили
[02:23:59.440 --> 02:24:07.120]  назад тоже строчку. То есть мы просто проверяем типы, которые в языке типа C++ были бы зафиксированы
[02:24:07.120 --> 02:24:14.000]  на уровне сигнатуры функции и проверил компилятор при компиляции. То есть нам необходимо статическая
[02:24:14.000 --> 02:24:25.160]  система типов, но вот вариативность здесь огромная на самом деле. И о чем я сейчас сформулирую,
[02:24:25.160 --> 02:24:32.000]  достаточно емко, о чем я хочу сказать. Типы в языках программирования, они не про то, что там,
[02:24:32.000 --> 02:24:37.360]  не знаю, нельзя умножать строчку на число, но в некоторых языках можно, не будем сейчас о них,
[02:24:37.360 --> 02:24:42.480]  строчку на строчку умножать не стоит, наверное, всегда, ни при каких обстоятельствах. Так вот,
[02:24:42.480 --> 02:24:46.640]  система типов не про это, не про то, чтобы запретить такие безумные ошибки. Вообще,
[02:24:46.640 --> 02:24:56.400]  есть такая мета интуиция очень сложная, про то, что описание типов в языке в некотором смысле
[02:24:56.400 --> 02:25:05.120]  эквивалентно формулировке теориям, а тело функции — это ее доказательство. Вот если эту идею развить,
[02:25:05.120 --> 02:25:10.560]  она очень содержательна, то можно понять, что система типов, она про какие-то статические
[02:25:10.560 --> 02:25:16.040]  свойства программы. Вот если у вас есть программа на C++ и вы запускаете ее, наверное, вы уверены,
[02:25:16.040 --> 02:25:21.240]  что вы там две строчки не перемножаете внутри. Но может быть, у вас есть там висящие указатели.
[02:25:21.240 --> 02:25:27.160]  Ну, что вы делаете для этого? Вы для этого заводите адрес-санитайзер, и он проверяет,
[02:25:27.160 --> 02:25:32.960]  что у вас память не течет в конкретном исполнении. Но это проверка в рантайме, точно так же,
[02:25:32.960 --> 02:25:37.080]  как Питон проверяет, что вы не умножаете две строчки в рантайме. Просто проверка другого рода.
[02:25:38.080 --> 02:25:43.720]  Эту задачу можно решить по-другому же. То есть можно взять язык со сборкой мусора и решить
[02:25:43.720 --> 02:25:49.360]  проблемы на уровне рантайма. То есть вам ГО не позволяет получить висящую ссылку,
[02:25:49.360 --> 02:25:55.680]  потому что в ГО вообще нет понятия сториджа, там стэка или куча, где расположить объект,
[02:25:55.680 --> 02:26:01.000]  решается сам компилятор. Ну а дальше рантайм обеспечивает, что пока ссылки на объект есть,
[02:26:01.000 --> 02:26:06.480]  этот объект освобожден не будет. Ну или, скажем, рантайм ГО вам обеспечивает,
[02:26:06.480 --> 02:26:15.680]  что вы более-менее не можете переполнить стэк, потому что он растет у грутина. Но это вот такие
[02:26:15.680 --> 02:26:21.040]  гарантии на уровне рантайма, которые обеспечиваются, а можно достигать гарантии на уровне системы типов.
[02:26:21.040 --> 02:26:25.600]  То есть можно просто построить язык, в котором в системе типов будет заложено, что вы не можете
[02:26:25.600 --> 02:26:33.040]  получить висящую ссылку. Вот, например, вот Rust, он эту проблему решает. Каким образом сейчас...
[02:26:33.040 --> 02:26:44.400]  Это была заготовлена ссылка. Вот пример кода на C++ и на Rust. Здесь мы берем вектор,
[02:26:44.400 --> 02:26:51.560]  кладем вектор в два значения, берем указатель на первый элемент, потом делаем pushback,
[02:26:51.560 --> 02:26:56.440]  потом разыминовываем указатель. Ну и получаем в общем случае use of the free,
[02:26:56.440 --> 02:27:04.040]  потому что этот pushback мог привести к перелокации буфера, и в итоге наш поинтер инвалидировался.
[02:27:04.040 --> 02:27:12.280]  Вот эта программа, в которой есть use of the free, вы можете его обнаружить, запустив ее под
[02:27:12.280 --> 02:27:17.480]  адрес санитайзера, а можете не обнаружить use of the free, потому что в исполнении он не случится,
[02:27:17.480 --> 02:27:23.720]  а где-нибудь продакшн не случится. Вот, а можно эту же проблему решить на уровне системы типов,
[02:27:23.720 --> 02:27:30.120]  то есть просто запретить программы, в которых такая утечка в принципе возможна. Делать это
[02:27:30.120 --> 02:27:36.360]  косвенно в Rust, но в общем довольно просто. Нужно сделать single writer multiple readers, то есть
[02:27:36.360 --> 02:27:44.920]  либо вам разрешается иметь только одну мутабельную ссылку на данные. Вот у вас здесь есть мутабельный
[02:27:44.920 --> 02:27:51.560]  вектор и мутабельная ссылка на его элемент, и вы дальше мутируете вектор через одну ссылку,
[02:27:51.560 --> 02:27:58.480]  а потом читаете элемент через другую ссылку. И вот вы свойства потеряли, но корректность
[02:27:58.480 --> 02:28:02.880]  потеряли. Что делает этот раз? Он говорит, что не может быть в программе одновременно с мутабельной
[02:28:02.880 --> 02:28:09.280]  ссылкой другая мутабельная, или вообще любой рейхеринг, через который можно читать. Если
[02:28:09.280 --> 02:28:17.760]  есть мутабельная ссылка, то значит других ссылок нет. Вот такой простой вариант, его можно проверять
[02:28:17.760 --> 02:28:26.440]  на уровне системы типов, на уровне комператора, и таким образом отслеживать не то что ошибку в
[02:28:26.440 --> 02:28:32.080]  каком-то конкретном исполнении, а апроксимировать ошибки, которые возникают хотя бы в одном исполнении.
[02:28:32.080 --> 02:28:35.920]  Собственно, система типов про это, про то, чтобы апроксимировать все возможные исполнения
[02:28:35.920 --> 02:28:41.480]  программы. Если хотя бы в каком-то исполнении что-то может пойти не так, то значит, неважно,
[02:28:41.480 --> 02:28:48.720]  реализуется оно или не реализуется. Система типов языка может это запретить. Это, в общем,
[02:28:48.720 --> 02:28:55.520]  иллюстрация какой-то системы типов. Можно строить разные системы типов. Например, есть язык Java,
[02:28:55.520 --> 02:29:03.880]  и там все это референсы. Есть value-типы, но, в общем, одни референсы вокруг. И вы понимаете,
[02:29:03.880 --> 02:29:07.560]  что существует в Java такая проблема, которая называется ошибка на миллиард долларов. Кажется,
[02:29:07.560 --> 02:29:14.640]  про то, что за каждым референсом может лежать null. И вообще-то, когда вы вызываете через референс
[02:29:14.640 --> 02:29:18.520]  менять какой-то объект, тут нужно узнать, убедиться сначала, что этот референс не пустой,
[02:29:18.520 --> 02:29:24.920]  что он на что-то указывает. То есть, как с и плюс-плюс, вы получаете pointer и не знаете,
[02:29:24.920 --> 02:29:36.520]  а вдруг он на null-пойнтер ссылается сейчас. Поэтому в языке Kotlin есть понятие null-safety
[02:29:36.520 --> 02:29:43.240]  или null-ability, его еще называют, про то, что вы не можете, если вы не уверены, если в ссылке может
[02:29:43.240 --> 02:29:49.560]  быть null или не null, если null может быть в ссылке, то вы не можете обратиться через нее к объекту,
[02:29:49.560 --> 02:30:00.400]  пока вы не убедитесь, что там не null. Тут где-то был простой пример. Ну вот, у вас есть ссылка,
[02:30:00.400 --> 02:30:09.160]  и вы можете обратиться к полю длина, только если вы проверили на не null сначала. Это вроде бы
[02:30:09.160 --> 02:30:17.000]  простые соображения, но тут дело в том, что сам компилиатор, сама система типов заставляет вас
[02:30:17.000 --> 02:30:23.360]  это делать. Вы не можете не проверить, иначе ваша программа не скомпилируется. Вот идею можно
[02:30:23.360 --> 02:30:36.480]  расширять. Есть null-safety в Kotlin, есть lifetime и разделяемое-неразделяемое владение в Rust.
[02:30:36.480 --> 02:30:43.320]  Есть другая проблема. Скажем, вы пишете сокеты, и если вы знаете API-сокетов, то вы знаете,
[02:30:43.320 --> 02:30:50.560]  что чтобы получить работающий сокет, нужно сначала его построить, сказать на нем bind,
[02:30:50.560 --> 02:30:56.960]  сказать listen, сказать accept. Вот такой пайплайн пройти из четырех операций. А что делать,
[02:30:56.960 --> 02:31:03.400]  если вы в программе написали listen, но не написали перед этим bind? Еще один класс ошибок,
[02:31:03.400 --> 02:31:12.600]  которые вы можете совершить. Система типов может вам помочь и с такими ошибками. Это
[02:31:12.600 --> 02:31:17.840]  называют state-safety. То есть вы можете как-то на уровне системы типов закодировать, что методы
[02:31:17.840 --> 02:31:22.280]  объекта можно вызывать только в каком-то порядке. И если вы вызываете их не в таком, то компилиатор
[02:31:22.280 --> 02:31:28.480]  тоже может сослаться на это как на ошибку. То есть можно было бы сказать, что можно же просто таких
[02:31:28.480 --> 02:31:34.600]  ошибок не делать. Можно, конечно, всегда делать все правильно, не получать инвалидированные
[02:31:34.600 --> 02:31:40.560]  итераторы, вызывать методы в правильном порядке, не обращаться по null-pointer никогда. Конечно,
[02:31:40.560 --> 02:31:45.680]  можно с помощью дисциплины человеческой, но какие-то проблемы можно переложить на компилиатор.
[02:31:45.680 --> 02:31:53.400]  И вообще тут возможности совершенно фантастические могут быть. Есть понятие зависимых типов,
[02:31:53.400 --> 02:32:01.200]  когда вы можете добиться следующего. Вы можете иметь не просто тип матрицы, скажем, или вектор,
[02:32:01.200 --> 02:32:09.240]  а вы можете иметь тип матрицы размером n на m. И вы можете написать функцию, которая умножает
[02:32:09.240 --> 02:32:15.440]  только матрицы, у которых размеры согласованы. При этом не то, чтобы эта матрица как бы на стадии
[02:32:15.440 --> 02:32:20.760]  компилиации написана, что она размера 3 на 5. Нет. Вы читаете там из файла какое-то значение,
[02:32:20.760 --> 02:32:24.680]  при этом вы можете создать дальше матрицу, и при этом они все равно перемножаются правильно.
[02:32:24.680 --> 02:32:36.040]  Или вы не можете обратиться к нулевому элементу пустого вектора. Вот такие ошибки тоже можно было
[02:32:36.040 --> 02:32:40.240]  в runtime отслеживать, а можно построить настолько сложную систему типов, которые и их будет находить.
[02:32:40.240 --> 02:32:51.400]  Вот скажем, есть вариация Husker, которая это позволяет делать, в которой вы не можете
[02:32:51.400 --> 02:33:00.280]  выбрать функцию head на списке от пустого списка. Список должен быть не пустым, иначе это будет
[02:33:00.280 --> 02:33:06.040]  ошибка компилиации. Это не то же самое, что constexpr и C++, на всякий случай.
[02:33:06.040 --> 02:33:21.280]  constexpr он про то, что он известен на этапе компилиации. Длина списка может быть неизвестна на
[02:33:21.280 --> 02:33:30.280]  этапе компилиации, а проверка все равно работает. В этом и суть. А проверка в runtime работает? Нет,
[02:33:30.280 --> 02:33:37.760]  еще раз. Проверка работает на стадии компилиации, разумеется. Так мы же не знаем размер. Так задача
[02:33:37.760 --> 02:33:46.120]  сложная. Это самое сложное, что в языках программирования бывают зависимые типы.
[02:33:46.120 --> 02:34:01.540]  Это тема другого курса. Написать компилятор, который поддерживает зависимые типы, это очень сложная
[02:34:01.540 --> 02:34:06.320]  задача, потому что задача проверки в такой системе типов вычислительна крайне сложная.
[02:34:06.320 --> 02:34:13.680]  Тут очень много трейдовов, очень много сложностей. Конечно, звучит очень невероятно,
[02:34:13.680 --> 02:34:20.520]  но задача-то непростая. C++ этого не будет никогда, потому что по миллиону разных причин.
[02:34:20.520 --> 02:34:34.200]  Это делают не просто так в функциональных языках, в первую очередь. Можете еще раз повторить объяснение,
[02:34:34.200 --> 02:34:39.840]  почему constexpr не подходит? Потому что ты читаешь список из файла или по сети и получаешь.
[02:34:39.840 --> 02:34:55.200]  Почему тут constexpr? constexpr — это то, что есть в программе на стадии компиляции. Я взял в
[02:34:55.200 --> 02:34:59.680]  программе вектор, сделал в него один pushback, сделал второй pushback и сделал третий pushback,
[02:34:59.680 --> 02:35:07.840]  а потом я сравниваю. Я взял два вектора, в одном сделал три pushback, в другой четыре pushback,
[02:35:07.840 --> 02:35:14.320]  а потом пытаюсь скалярно их перемножить. Вот такая программа, она вот ясно делает… что?
[02:35:14.320 --> 02:35:21.600]  — В языках, о которых вы говорите, с такими типами, тип известен на этапе компиляции или нет?
[02:35:21.600 --> 02:35:30.160]  — Ну в смысле? Ты пишешь, не знаю, грубо говоря, список, но просто не ограничивай у себя constexpr,
[02:35:30.160 --> 02:35:35.720]  и все. Ты сделал три pushback, ты сделал четыре pushback, ты пытаешься скалярно перемножить,
[02:35:35.720 --> 02:35:39.400]  и, конечно, функция, которая скалярно перемножает два вектора, выдаст тебя компиляции, потому что,
[02:35:39.400 --> 02:35:44.800]  ну просто по тексту программы можно было бы понять, что нет, это работать не будет.
[02:35:44.800 --> 02:35:51.360]  При этом на этапе компиляции сами вектора неизвестно еще.
[02:35:51.360 --> 02:35:54.960]  — Какие-то статические анализаторы кода, которые могут…
[02:35:54.960 --> 02:36:00.200]  — Ну какие статические анализаторы? Понимаешь, что компилятор — это есть статический анализатор
[02:36:00.200 --> 02:36:04.400]  кода, он этим и занимается. Просто задача очень сложная.
[02:36:04.400 --> 02:36:10.280]  — Ну то есть, условно говоря, он проверяет то, что там где-то был if, то что n равно равно m,
[02:36:10.280 --> 02:36:16.600]  и только после этого разрешает вызов. То есть он в каком-то смысле проверяет, что там где-то
[02:36:16.600 --> 02:36:21.400]  был как вкотлени, типа if n равно равно m, только потом разрешит этот вызов функции перемножения.
[02:36:21.400 --> 02:36:28.320]  — Да, но для этого нужно и мог это понять, что вот какое n и какое m, всегда ли оно сходится или может
[02:36:28.320 --> 02:36:35.680]  не сходится. Но это очень сложная задача. Поэтому ее решать-то в промышленных языках вроде бы и не
[02:36:35.680 --> 02:36:41.080]  пытаются. Вот есть для хаскера какая-то вариация, там что-то сделали. Но это прям супер-супер сложная.
[02:36:41.080 --> 02:36:49.400]  Вот мы, наверное, на такое рассчитывать не можем, но вот мы можем использовать… Ну вот no safety и то
[02:36:49.400 --> 02:36:57.520]  как бы делали сколько лет. Это сложная задача, потому что она требует как бы и синтезис определенным
[02:36:57.520 --> 02:37:04.600]  образом задизайнить, чтобы он под это все подходил. Тут есть нюансы, про которые можно поговорить,
[02:37:04.600 --> 02:37:14.400]  но это как бы еще раз, это отдельный курс. Сейчас мы просто… Я просто обозначаю, что корректность,
[02:37:14.400 --> 02:37:20.520]  она обеспечивается, конечно, не только проверками в runtime, не только как бы формальной спецификации
[02:37:20.520 --> 02:37:26.160]  на стадии дизайна и не только там fault injection при исполнении, но еще просто выбором языка и
[02:37:26.160 --> 02:37:38.640]  развитием языков программирования. Все это тоже помогает. То есть задача решается с самых разных сторон.
[02:37:38.640 --> 02:37:45.160]  Вообще говоря, система типов в языках программирования — это супер-сложная область,
[02:37:45.160 --> 02:37:50.840]  супер-большая. Ее развивает много лет уже, и там как бы замысел-то один в системе типов — как
[02:37:50.840 --> 02:37:56.160]  делать больше статистических проверок, не исполняя программы? Как проверять более-более сложные
[02:37:56.160 --> 02:38:01.680]  свойства программ? Вот то, что ты не можешь перемножать строчки — это довольно простое
[02:38:01.680 --> 02:38:07.600]  свойство. А вот то, что ты там не получаешь всяких ссылок, или что ты не можешь получить data race,
[02:38:07.600 --> 02:38:15.720]  или то, что ты не можешь обратиться к полю через null-ссылку, или про то, что ты не можешь вызвать
[02:38:15.720 --> 02:38:22.560]  bind после listen — это уже менее тривиальные свойства, и для них нужны специальные системы типов,
[02:38:22.560 --> 02:38:37.520]  и вот это огромная научная область. Итого, мы пишем спецификацию, мы выбираем подходящий язык,
[02:38:37.520 --> 02:38:44.540]  мы на нем пишем программу, где какие-то отдельные маленькие юниты мы можем, не знаю, тестировать,
[02:38:44.540 --> 02:38:51.480]  верифицировать помощью model-чейкера, типа лог-фри очереди, но на уровне кода мы используем
[02:38:51.480 --> 02:38:57.080]  fault injection, возможно, если мы можем использовать fault injection, который мы внедряем в свой проект
[02:38:57.080 --> 02:39:04.760]  сразу, и мы используем fault injection снаружи в виде фреймворка Jepsen, который позволяет нам статически
[02:39:04.760 --> 02:39:14.960]  убедиться, не модифицируя код, что система ведет себя снаружи в соответствии с поставленными,
[02:39:14.960 --> 02:39:20.600]  с гарантиями, которые сформулировали в самом начале. Наконец, вот последнее, что я скажу,
[02:39:20.600 --> 02:39:29.640]  и на этом закончу, потому что устал. Можно идти еще дальше и использовать,
[02:39:29.640 --> 02:39:38.240]  но то, что таким словом называется, то есть вы берете свою систему большую, вы там потестировали
[02:39:38.240 --> 02:39:44.760]  ее Jepsen, день-два, погоняли какие-то маленькие тесты, а дальше вы разворачиваете у себя, не знаю,
[02:39:44.760 --> 02:39:50.960]  тестовый кластер и просто запускаете на ней демона специального, который ходит, периодически там,
[02:39:50.960 --> 02:39:55.720]  не знаю, перезагружает машины, что-то портит, и вот это происходит так в фоне. Не так, чтобы система
[02:39:55.720 --> 02:40:02.840]  стала полностью недоступна, но вот просто увеличивает число разнообразных событий,
[02:40:02.840 --> 02:40:09.080]  которые с ней происходят, и вот в таком режиме кластер живет, с ним работают люди, и вот вы уже
[02:40:09.080 --> 02:40:15.680]  через людей пытаетесь понять, есть ли какие-то баги, репортит они вам их или нет, потому что
[02:40:15.680 --> 02:40:22.640]  любые тесты, синтетические или спецификации, вы проверяете то, что вы сами ожидаете от системы,
[02:40:22.800 --> 02:40:28.760]  и скорее всего, просто так устроено человеческое мышление, что он проверяет то, что он знает,
[02:40:28.760 --> 02:40:32.880]  что работает, а то, что он не знает, что у него работает, он обычно не проверяет, вот поэтому
[02:40:32.880 --> 02:40:38.480]  дальше приходят люди, они тестируют вашу систему своими настоящими задачами и узнают, что в ней
[02:40:38.480 --> 02:40:46.800]  все-таки баги есть. Ну и пройдя через все вот эти круги ада, мы в конце концов можем быть уверены,
[02:40:46.800 --> 02:40:56.800]  что наша система, наверное, работает, написано корректно. Все, у меня на сегодня все.
