[00:00.000 --> 00:09.000]  Итак, первая тема, о которой мы говорим, — это персистентность.
[00:09.000 --> 00:15.000]  И когда мы говорим о персистентных структурах данных, мы говорим о таких структурах, которые помнят все свои старые версии.
[00:15.000 --> 00:21.000]  Как-то в сжатом виде хранят не только свое текущее состояние, но и все возможные свои предыдущие версии.
[00:21.000 --> 00:34.000]  Самый такой для нас близкий пример — это система контроллер-версии, что-то в стиле гитхаба или гитлаба, где у вас там, на семинарах, где вы работаете.
[00:34.000 --> 00:39.000]  Это система, которая хранит все версии вашего кода.
[00:39.000 --> 00:42.000]  Вот вы написали какой-то код, запушили его, а вот он там хранится.
[00:42.000 --> 00:47.000]  Потом внесли какие-то правки, и вам доступна как конечная версия, так и предыдущая.
[00:47.000 --> 00:52.000]  Вы знаете, в чем они отличаются. Вы можете к любой версии быстро получить доступ.
[00:52.000 --> 00:59.000]  И когда мы говорим про персистентные структуры, мы тоже хотим ровно этого, что пришел пользователь, что-то поделал, поделал.
[00:59.000 --> 01:02.000]  Потом такой сказал, — ой, не хочу, откатывай все к такой-то версии.
[01:02.000 --> 01:07.000]  Или просто, а вот что было там год назад, что было в базе данных наших год назад?
[01:07.000 --> 01:13.000]  Просто какие-то такие запросы к каким-то более ранним версиям нашей структуры.
[01:13.000 --> 01:19.000]  И вот самое простое, что можно сделать, одно из самых простых, это персистентный массив.
[01:26.000 --> 01:31.000]  Ну, в такой простой версии нам нужно уметь обрабатывать, по сути, два типа запросов.
[01:31.000 --> 01:35.000]  Значит, в какой-то момент времени нам приходит запрос изменения,
[01:35.000 --> 01:39.000]  и мне нужно в какой-то позиции запрос обновить число и положить его равным числу вал.
[01:39.000 --> 01:42.000]  А пери присвоит какое-то значение.
[01:42.000 --> 01:48.000]  И второй запрос — это, например, а скажите, пожалуйста, что было в такой-то ячейке массива на такой-то версии?
[01:48.000 --> 01:58.000]  То есть вывести или там найти апостая в этой версии, в этой версии.
[01:58.000 --> 02:05.000]  Ну или там в такой-то момент времени у вас приходят запросы, вы у каждого запроса знаете, в какой момент времени он приходит,
[02:05.000 --> 02:11.000]  и когда поступают запросы второго типа, вам говорят, а вот типа тот запрос, который я тебе вчера прислал, скажи, пожалуйста,
[02:11.000 --> 02:17.000]  у него в той ячейке. Ну и понятное дело, что вот идет поз, они могут варьироваться от запроса к запросу.
[02:17.000 --> 02:21.000]  От запроса к запросу.
[02:21.000 --> 02:24.000]  Вот здесь решение может быть следующее, очень простое.
[02:24.000 --> 02:28.000]  Давайте мы просто для каждой позиции запомним всю историю ее изменений.
[02:28.000 --> 02:32.000]  Для каждого индекса, для каждого аитова запомним, какое число там было в начале,
[02:32.000 --> 02:36.000]  потом как оно поменялось и в какой момент времени оно изменилось.
[02:36.000 --> 02:45.000]  То есть там аито было сначала х, потом оно в какой-то момент времени т1 стало у, потом в момент времени т2 стало z, ну и так далее.
[02:45.000 --> 02:50.000]  То есть мы знаем просто целиком историю и ее храним в некотором векторе, в динамическом массиве,
[02:50.000 --> 02:56.000]  который нам позволяет добавлять информацию в конец. То есть мы вот так делаем pushback в наш вектор,
[02:56.000 --> 03:00.000]  добавляем новые сведения о том, что в такой-то момент времени наш элемент так-то изменился.
[03:00.000 --> 03:06.920] baum с loved one linem eh
[03:06.920 --> 03:10.920]  тогда если мне приходит запрос, извлечение какого-то
[03:10.920 --> 03:13.780]  элемента, ну точнее нахождения кого-то элемента в в какой-то
[03:13.780 --> 03:17.160]  момент времени наш не�опросто понять она вот мне
[03:17.160 --> 03:20.520]  нужна посмотреть на апост tsp давайте посмотрю на апостно и на всю
[03:20.520 --> 03:24.100]  историю unhappy что там было какое-то число сначала так то поменялась
[03:24.100 --> 03:27.460] 문 одни ст occasion и так то другой так далее и так далее и тогда все что не
[03:27.460 --> 03:32.920]  нужно сделать это понять, чему равно число в тетый
[03:32.920 --> 03:33.920]  момент.
[03:33.920 --> 03:36.560]  Значит, мне нужно из вот этих вот пар, если я храню
[03:36.560 --> 03:44.760]  пары t1, y, t2, z, там t3 какой-то еще, не знаю, буквы кончились,
[03:44.760 --> 03:49.800]  а, b, тогда мне нужно просто найти первый момент времени,
[03:49.800 --> 03:52.420]  точнее не так, мне нужно видимо найти последний
[03:52.420 --> 04:02.900]  момент времени, меньше или равный t, чтобы найти,
[04:02.900 --> 04:13.180]  чтобы найти апостоля в момент t, в этом списке нужно найти
[04:13.180 --> 04:15.620]  как бы последние изменения, которые произошло к моменту
[04:15.620 --> 04:18.140]  времени t, то есть вот там какой-то префикс изменений
[04:18.140 --> 04:21.740]  произошел, да, и вот то последнее изменение, которое произошло
[04:21.740 --> 04:24.420]  до момента t, нам нужно как бы его и вывести, да, то
[04:24.420 --> 04:26.420]  последнее изменение, которое произошло до момента времени
[04:26.420 --> 04:27.420]  t, это есть наш ответ.
[04:27.420 --> 04:42.900]  Так вот, в этом списке надо найти последние изменения
[04:42.900 --> 04:47.020]  в момент меньше либо равный t.
[04:47.020 --> 04:50.740]  Ну а это уже простая задача на конюнвен поиск, если
[04:50.740 --> 04:54.460]  у меня есть отсоцированный массив времен изменений,
[04:54.460 --> 04:57.420]  что там тогда-то поменялось на то, тогда-то на то, то
[04:57.420 --> 04:59.460]  дальше просто бин поиском нужно найти вот эту вот последнюю
[04:59.460 --> 05:02.380]  позицию, где число, где момент времени больше,
[05:02.380 --> 05:04.660]  чем t, потому что сначала идут меньше и равные t, потом
[05:04.660 --> 05:07.860]  идут больше t, у нас есть такая монотонность, возрастание
[05:07.860 --> 05:10.460]  времени изменений, значит можно просто запустить
[05:10.460 --> 05:13.740]  бин поиск и найти там, собственно, последнюю операцию, которая
[05:13.740 --> 05:15.740]  повлияла на это апостол.
[05:15.740 --> 05:18.980]  Тогда получается, что у меня запрос вот этого второго
[05:18.980 --> 05:22.900]  типа, мы на него отвечаем за логарифм, ну логарифм
[05:22.900 --> 05:29.420]  q, где q это общее число запросов, потому что в худшем случае
[05:29.420 --> 05:32.380]  все запросы приходят к одному этому же элементу, и тогда
[05:32.380 --> 05:34.260]  мне нужно хранить массив длины q и в нем делать бин
[05:34.260 --> 05:35.260]  поиск.
[05:35.260 --> 05:36.260]  За лог q работает.
[05:36.260 --> 05:37.260]  Вот.
[05:37.260 --> 05:40.900]  А запрос изменения работает за амортизированную единицу,
[05:40.900 --> 05:43.900]  потому что это просто pushback-вектор.
[05:43.900 --> 05:45.860]  Амортизированная единица, потому что это просто pushback-вектор.
[05:45.860 --> 05:49.300]  И в этом случае можно в it-вектор сообщить, добавить
[05:49.300 --> 05:53.060]  новое значение, t запятая вал, что в t этот момент времени
[05:53.060 --> 05:54.060]  число поменялось на вал.
[05:54.060 --> 05:58.340]  Вот такая очень простая структура, мы просто помним
[05:58.340 --> 05:59.980]  историю каждого элемента.
[05:59.980 --> 06:04.260]  Так, есть ли вопросы сейчас по персидентному массиву?
[06:04.260 --> 06:05.260]  Сейчас.
[06:05.260 --> 06:10.940]  А мы же, наверное, в каждой паре мы должны хранить не
[06:11.940 --> 06:17.340]  только t1 и изменения, но еще и то значение, которое
[06:17.340 --> 06:19.940]  было до этого изменения.
[06:19.940 --> 06:20.940]  Да.
[06:20.940 --> 06:21.940]  А зачем?
[06:21.940 --> 06:30.220]  Ну, а как, иначе вы поймете, что было момент t, ну, то
[06:30.220 --> 06:35.420]  есть, а или а, окей, ой, все, все, я понял.
[06:35.420 --> 06:37.500]  Ну, если вопрос возникнет, я все равно на него отвечу,
[06:37.500 --> 06:39.500]  давайте я нарисую вот такую вот временную ось.
[06:39.500 --> 06:42.780]  Значит, смотрите, это увеличение времени, значит, в нулевом
[06:42.780 --> 06:45.740]  момент времени там был какой-то x, потом в какой-то
[06:45.740 --> 06:49.100]  другой момент времени появился y, в третий момент времени
[06:49.100 --> 06:51.100]  появился z, и так далее, и так далее.
[06:51.100 --> 06:53.780]  Ну, а дальше, если мне приходит запрос, скажите, пожалуйста,
[06:53.780 --> 06:57.060]  какой час облау в момент времени t, то я просто нахожу,
[06:57.060 --> 07:00.260]  как бы, куда это t попадает, между какими двумя запросами,
[07:00.260 --> 07:02.780]  ну, скажем, вот куда-то сюда он попал, t, скажем, вот
[07:02.780 --> 07:07.220]  здесь, и тогда ответ – это y, это последнее изменение,
[07:07.260 --> 07:09.620]  которое произошло в момент времени меньше равных t.
[07:09.620 --> 07:11.620]  То есть я смотрю на все, что находится левее чем-то
[07:11.620 --> 07:15.220]  t, нахожу последнее изменение, и это будет наш ответ.
[07:15.220 --> 07:17.220]  Потому что, ну, позднее, чем это изменение, ничего
[07:17.220 --> 07:22.100]  не происходило, значит, это есть наш ответ.
[07:22.100 --> 07:25.340]  Да, возможно, у нас происходит запросы к элементам, нам
[07:25.340 --> 07:29.060]  же нужно весь массив копировать при каждом запросе и изменять
[07:29.060 --> 07:31.260]  один элемент в нем, ну, чтобы поддерживать такую структуру
[07:31.260 --> 07:34.980]  данных, или это как-то по-другому реализовано?
[07:34.980 --> 07:39.460]  Нет-нет, смотрите, у меня на каждый запрос я добавляю
[07:39.460 --> 07:42.460]  только одну, ну, в общем, под единицей памяти у меня
[07:42.460 --> 07:46.780]  нужно лишний, потому что, смотрите, я ничего не перекопирую,
[07:46.780 --> 07:49.700]  я для каждого элемента, для каждой позиции i хранил
[07:49.700 --> 07:50.700]  всю его историю.
[07:50.700 --> 07:52.780]  То есть я знаю примерно следующее, что в момент
[07:52.780 --> 07:55.060]  времени 0 оно было каким-то значением там x.
[07:55.060 --> 07:58.460]  Потом, если у меня приходит новый запрос, где i t меняется,
[07:58.460 --> 08:01.740]  то я это добавляю в вектор, соответствующий i t ему элемент,
[08:01.900 --> 08:07.660]  то есть я вектор там, не знаю, в kt и t, я добавляю информацию
[08:07.660 --> 08:10.900]  о том, что в новый момент времени t1, оно поменялось
[08:10.900 --> 08:11.900]  на y.
[08:11.900 --> 08:15.180]  То есть, на самом деле, каждый запрос изменения, он не требует
[08:15.180 --> 08:17.820]  никаких копирований, он просто требует добавления,
[08:17.820 --> 08:20.380]  ну, одного pushback, то есть одного добавления в конец
[08:20.380 --> 08:24.980]  в i t векторе, тем самым я как бы знаю целиком вот
[08:24.980 --> 08:25.980]  этого одного элемента.
[08:25.980 --> 08:26.980]  Да, я ничего не копирую.
[08:26.980 --> 08:30.900]  Извините, то есть у нас векторы столько же, сколько
[08:30.900 --> 08:34.020]  элементов, сколько элементов, да, для каждого элемента
[08:34.020 --> 08:40.340]  свой массив, свой вектор, свой вектор, да, хорошо.
[08:40.340 --> 08:46.740]  Так, это мы обсудили, теперь, ну, наверное, я на семинар
[08:46.740 --> 08:49.820]  оставлю какие-нибудь упражнения типа персистентный стэк
[08:49.820 --> 08:53.380]  или персистентная очередь, но с очередь там вроде сложно,
[08:53.380 --> 08:56.940]  наверное, персистентный стэк, вот, а сейчас мы обсудим
[08:56.940 --> 08:57.940]  персистентный дерево отрезков.
[08:58.940 --> 09:02.620]  Персистентное дерево отрезков.
[09:02.620 --> 09:09.340]  Идеология абсолютно такая же, да, мы хотим делать какие-то
[09:09.340 --> 09:12.900]  запросы в нашем деле, скажем, изменять элемент в точке
[09:12.900 --> 09:15.860]  и находить сумму на отрезке, но еще мы иногда хотим как
[09:15.860 --> 09:19.620]  бы откатываться во времени, или, ну, можно сказать так,
[09:19.620 --> 09:24.500]  можно сказать просто запрос, что текущая версия должна
[09:24.500 --> 09:27.340]  быть равна там, та, которая была когда-то в этот момент
[09:27.340 --> 09:30.220]  времени, то есть, ну, реально, вот, текущую версию откатить
[09:30.220 --> 09:33.460]  до какой-то более старой, либо просто поступают запросы,
[09:33.460 --> 09:36.660]  что нам нужно вот в такой-то версии найти сумму на отрезке.
[09:36.660 --> 09:38.580]  Вот давайте вторая версия, она более общая, давайте
[09:38.580 --> 09:42.380]  ее, значит, и зафиксируем.
[09:42.380 --> 09:46.100]  И так, и того, есть два типа запросов, первый это по
[09:46.100 --> 09:51.340]  позиции и значению, мне нужно сделать обновление
[09:51.340 --> 09:54.220]  этого элемента, да, и забыть то, что там было раньше и
[09:54.220 --> 09:59.900]  поменять на значение вал, и второй тип запроса следующий,
[09:59.900 --> 10:02.860]  если мы рассмотрим эту версию нашего деревоотресков,
[10:02.860 --> 10:05.780]  то есть версию деревоотресков, которая была после первых
[10:05.780 --> 10:07.860]  Т изменений, допустим, то есть, вот у меня есть изменение
[10:07.860 --> 10:14.700]  значений, и я храню, я спрашиваю в момент не когда все они
[10:14.700 --> 10:17.260]  уже обработаны, а в момент, когда только первые Т обработаны,
[10:17.260 --> 10:21.580]  значит, первые Т обработаны, мне нужна сумма на отрезке,
[10:21.580 --> 10:28.300]  чтобы найти, нужна сумма AL плюс AL плюс 1 плюс так далее
[10:28.300 --> 10:37.100]  плюс AR в этот момент времени.
[10:37.100 --> 10:40.140]  Давайте пример, чтобы точно было понятно того, что мы
[10:40.140 --> 10:45.780]  хотим от этого дерева, пусть для начала был такой массив,
[10:45.780 --> 10:56.500]  не знаю, там 7, 8, 3, а 0, 1, 2, первый запрос такой, поменяйте
[10:56.500 --> 11:08.140]  пожалуйста 1 на 2, а 1 заменить на 2, хорошо, заменили, как
[11:08.140 --> 11:10.460]  будто бы запомнили, что вот есть у меня исходная версия
[11:10.460 --> 11:13.980]  7.8.3, теперь текущая версия 7.2.3, на самом деле мы не будем
[11:13.980 --> 11:15.740]  целиком копировать массив, вы как спрашивали, мы не
[11:15.740 --> 11:18.300]  будем так делать, но как будто бы, да, текущая версия
[11:18.300 --> 11:21.220]  у меня 7.2.3, представляем виртуально, что мы его скопировали
[11:21.220 --> 11:24.500]  и один элемент заменили, приходит следующий запрос,
[11:24.500 --> 11:27.260]  а вот если мы забудем про это текущее изменение,
[11:27.260 --> 11:30.060]  испортим в себя, что было в момент времени 0, то есть
[11:30.060 --> 11:32.860]  до всех запросов, и там найти сумму элементов, не знаю,
[11:32.860 --> 11:39.260]  с 0 по 2, значит, T равно 0, L равно 0, R равно 2, тогда
[11:39.260 --> 11:43.260]  мне нужна сумма на отрезке от 0 до 2 элемента до всех
[11:43.260 --> 11:48.260]  изменений, значит, мне нужно просто найти 7.8.3, то есть
[11:48.260 --> 11:52.900]  18, дальше приходит третий запрос, хорошо, это мы, значит,
[11:52.900 --> 11:56.020]  узнали, что было до всех изменений, а если все-таки
[11:56.020 --> 11:58.540]  вернуть то изменение, то есть если первое изменение
[11:58.540 --> 12:02.060]  сделать и считать, что этот запрос все-таки у меня нужно
[12:02.060 --> 12:05.660]  обработать, сначала A1 поменять на 2, ну теперь, например,
[12:05.660 --> 12:09.380]  тот же самый запрос, L равно 0, R равно 2, тогда здесь уже
[12:09.380 --> 12:12.380]  мы должны написать 7 плюс 2 плюс 3, потому что из-за
[12:12.380 --> 12:17.100]  вот этой единицы мы вынуждены сначала A1 поменять на 2,
[12:17.100 --> 12:20.300]  только потом найти всю сумму, это уже будет 12, то
[12:20.300 --> 12:23.260]  есть в зависимости от этого T мы как бы ограничиваем
[12:23.260 --> 12:26.300]  себя некоторым префиксом, то есть некоторым начальным
[12:26.300 --> 12:30.780]  отрезком запросов изменения, несколько первых запросов
[12:30.780 --> 12:33.220]  изменений мы сохранили, их обработаем, и в этот
[12:33.220 --> 12:36.020]  момент времени как бы откатываемся в истории, в этот момент
[12:36.020 --> 12:37.980]  времени, когда дерево было таким, когда массив был
[12:38.980 --> 12:44.980]  таким, мы выводим сумму на отрезки. Вот такая задача.
[12:44.980 --> 12:49.420]  Решается следующим образом. Давайте мы будем писать
[12:49.420 --> 12:53.300]  как будто бы обычное дерево отрезков с суммой в поддереве,
[12:53.300 --> 12:57.580]  только когда мы обрабатываем запрос обновления в какой-то
[12:57.580 --> 13:00.540]  точке, давайте нарисую как это работает, когда мне
[13:00.540 --> 13:03.260]  приходит запрос обновления в какой-то там позиции
[13:03.260 --> 13:06.620]  поз, я спускаюсь от корня, то есть от лишинки номер
[13:06.620 --> 13:10.740]  1 по какому-то пути, и вот во все эти элементы сумму
[13:10.740 --> 13:12.940]  увеличу на дельта, во всех элементах сумму увеличу
[13:12.940 --> 13:16.460]  на дельта. Это мы обсуждали в прошлый раз, если значение
[13:16.460 --> 13:20.860]  опосты выросло на дельта, то тогда, соответственно,
[13:20.860 --> 13:24.180]  во всем пути, который контролирует эту вершинку, то есть на
[13:24.180 --> 13:26.620]  всем пути от корня до этой вершинки поз, мне нужно
[13:26.620 --> 13:29.540]  прибавить ту же самую дельту, потому что сумма выросла
[13:29.540 --> 13:33.140]  на этом пути только и на нем ровно на дельту.
[13:33.140 --> 13:37.100]  Так вот, давайте мы вместо изменений на этом пути в
[13:37.100 --> 13:39.500]  исходном дереве отрезков, мы все эти вершинки как
[13:39.500 --> 13:42.100]  бы продублируем, вот давайте мы вместо них, вместо вот
[13:42.100 --> 13:44.900]  этих четырех вершин, создадим четыре новые вершины с той
[13:44.900 --> 13:48.940]  же самой структурой, и в них напишем вот эти новые
[13:48.940 --> 13:52.220]  значения, то есть скажем, если здесь был х, то здесь
[13:52.220 --> 13:56.860]  мы напишем х плюс дельта, если здесь был у, то здесь
[13:56.940 --> 14:03.860]  мы напишем х плюс дельта, ну там zb, здесь тогда z плюс
[14:03.860 --> 14:10.060]  дельта, b плюс дельта, то есть мы не заменяем вот тот
[14:10.060 --> 14:13.300]  путь, а как бы его копируем и меняем там значения, как
[14:13.300 --> 14:16.020]  нам нужно, то есть мы старый путь не затираем, мы помним,
[14:16.020 --> 14:19.460]  какая там информация хранится, копируем эти все вершинки,
[14:19.460 --> 14:21.580]  и вот в них уже меняем, вот этих скопированных что-то
[14:21.580 --> 14:24.980]  меняем, вот, то есть это как бы наша текущая версия
[14:24.980 --> 14:27.540]  вот этого пути, что вот это как бы правильно, текущая
[14:27.540 --> 14:31.900]  версия, а это как бы старая версия, что было до этого
[14:31.900 --> 14:38.100]  изменения, но, когда смотрите, давайте мы вот эти вершинки,
[14:38.100 --> 14:46.220]  которые синие, мы их оставим и сделаем так, давайте я,
[14:46.220 --> 14:50.940]  нет, не так, у меня у корня был левый сын какой-то,
[14:50.940 --> 14:54.620]  левый сын, и он не поменялся, поэтому давайте левая ссылка
[14:54.680 --> 14:58.460]  как вот это вот нового корня, будет вести туда-же, то
[14:58.460 --> 15:00.720]  есть мы понимаем, что вот это вот новый корень, в
[15:00.720 --> 15:03.740]  нем хранится текущая новая информация и левый сын
[15:03.740 --> 15:05.660]  в новом под� deputy он как бы не поменялся, у меня
[15:05.660 --> 15:08.020]  изменения какие-то прошли только в правом сыне, тогда
[15:08.020 --> 15:11.200]  давайте ссылку на левого сына мы как бы. не поменяем,
[15:11.200 --> 15:13.100]  мы ее оставим такой же, она будет вести туда же,
[15:13.100 --> 15:15.380]  куда вела раньше, вот эта вот ссылка в левого сына
[15:15.380 --> 15:18.100]  будет вести туда же, значит ну правый сын, соответственно,
[15:18.100 --> 15:21.620]  у меня обновился, правый сын это вот эта новая вершинка,
[15:21.620 --> 15:24.540]  что дальше, дальше у меня, у этой вершинки, мы знаем
[15:24.540 --> 15:30.260]  левого сына. Это вот эта новая вершина, ту же синяя. Но что с правым сыном? Правого сына здесь нет.
[15:30.260 --> 15:35.640]  Но понятно, что правый сын у этой вершинки равен правому сыну у этой вершинки. Потому что когда я могу
[15:35.640 --> 15:41.020]  здесь нарисую правого сына, то понятен, что во всем этом подделе ничего не поменялось. Поэтому можно
[15:41.020 --> 15:49.460]  эту ссылку сохранить. Что правым сыном ją выступает теперь старый правый сын membership minus Littlestanden,
[15:49.460 --> 15:55.860]  было написано y. то есть по сути я оставляю ссылки на всех детей, на лево-право сына, меняю
[15:55.860 --> 16:01.580]  только вот этот путь, вдоль которого произошли изменения. давайте еще какое-нибудь другое дерево
[16:01.580 --> 16:11.180]  нарисую. вот у меня было дерево, давайте на трех элементах нарисуем. дерево отрезков на трех
[16:11.180 --> 16:17.740]  элементах выглядит так. и допустим изменения произошли вдоль вот этого пути. соответственно
[16:17.740 --> 16:25.300]  вот этот путь будет новой версией того пути, на котором произошли изменения. это левый сын остается,
[16:25.300 --> 16:31.060]  он показывает новую вершину. правым сыном нового корня будет выступать старый правый сын старого
[16:31.060 --> 16:38.180]  корня. то есть вот этот старый корень это новый корень. а правый сыновья у них одинаковый,
[16:38.180 --> 16:43.220]  потому что все правое под дерево корня у нас не поменялось. у нас поменялось что-то только в
[16:43.300 --> 16:50.100]  Здесь вот в левом под дереве. поэтому мы меняем только левого сына. левый сын у меня новая вершинка.
[16:50.100 --> 16:54.700]  а правый сын мне не поменялся, поэтому я могу вот эту ссылку просто перенаправить. то, что было
[16:54.700 --> 17:02.260]  раньше правым сыном, то и остается. вот это правая ссылка корня. дальше у этой вершинки, наоборот,
[17:02.260 --> 17:08.540]  поменялся правый сын, поэтому здесь появляется новая стрелка в новую вершину, а левый не поменялся,
[17:08.540 --> 17:15.700]  потому что у этой вершинки, которая является предшественником новой вершинки, у нее в левом
[17:15.700 --> 17:20.900]  под деревень ничего не произошло, поэтому здесь левую ссылку, точнее ссылку на левого сына,
[17:20.900 --> 17:26.740]  мы оставляем такой же, как было раньше. Вот такая идея. То есть мы просто перекопировали путь,
[17:26.740 --> 17:30.260]  а ссылки на неизменившиеся вершинки мы их оставили такими же, как были.
[17:30.260 --> 17:36.500]  Так, ну здесь несколько технических деталей, что, во-первых, мы отказываемся от сплошной
[17:36.500 --> 17:42.340]  нумерации вершин, точнее от нумерации, что там у вершинки В обязательно деть это 2В и 2В плюс 1.
[17:42.340 --> 17:55.460]  Отказываемся от удобной нумерации. Ну потому что, если там раньше это было верно, да, и вот у
[17:55.460 --> 18:00.860]  вершинки В были вершинки 2В и 2В плюс 1, то теперь я создаю новую вершину с каким-то номером еще
[18:00.860 --> 18:06.940]  больше, чем 2В плюс 1, да, новый номер какой-то завожу, то у нее правый сын, как бы, имеет тот же
[18:06.940 --> 18:12.620]  самый номер 2В плюс 1, да, поэтому здесь с номерами уже все будет совсем по-другому, и мы вместо этого
[18:12.620 --> 18:17.020]  будем просто в каждой вершине хранить, ну а вот, а кто является моим левым сыном, кто является
[18:17.020 --> 18:21.140]  моим правым сыном? То есть я не буду хранить, ну, то есть у меня не будет верно, что с лева 2В,
[18:21.140 --> 18:25.660]  с права 2В плюс 1, да, у меня просто будет стрелка на левого сына и ссылка стрелка на правого.
[18:25.660 --> 18:32.780]  Ну, это номер левого сына и номер правого сына. Вот, ну, давайте напишем такой небольшой код,
[18:32.780 --> 18:39.580]  значит, можно завести структуру вершины, структ ноде, это что будет у меня храниться в вершине дерева
[18:39.580 --> 18:47.540]  отрезков. Ну, во-первых, там нужна сумма, сумма в подделье, пусть будет long-long сам, и мне нужны
[18:47.540 --> 18:54.380]  вот эти две ссылки на левый и на правый сына, int, давайте назову их left и int right.
[18:54.380 --> 19:07.820]  Ну да, пусть будет так. Вот есть такая структура вершинки, которая имеет как бы ссылку на левый
[19:07.820 --> 19:12.020]  и на правый, на левый и на правый сына, но это будет не ссылки, а как бы номер левого сына и номер
[19:12.020 --> 19:19.460]  правого сына. Вот тогда, какие у меня поступают запросы? Что мне нужно делать? Мне нужно уметь
[19:19.460 --> 19:24.180]  заводить новую вершину, которая является копией одной из старых вершин. Вот скажем, у меня был
[19:24.180 --> 19:30.940]  какой-то старый корень, мне нужно завести новый синий корень и по умолчанию скопировать вот эти
[19:30.940 --> 19:37.740]  вот ссылки, которые были у детей старого корня, подвесить эти же ссылки вот сюда. Если у меня был
[19:37.740 --> 19:45.020]  какой-то старый корень, не знаю, там вершинка с номером v, то мы создаем новую вершинку, скажем,
[19:45.020 --> 19:55.620]  с номером w и говорим, что twt.left равно tv.left. То есть я как бы перекопирую информацию о левом
[19:55.620 --> 20:01.420]  сыне из старого корня в новый корень. Завел новый корень w с новым номером w и сказал,
[20:01.420 --> 20:07.820]  что его левый сын равен левому сыну вот этого старого корня вершинки v. Тоже самое с правым
[20:07.820 --> 20:21.260]  сыном twt.right равно tv.right. Это мы скопировали ссылки на детей. Дальше нужно исправить сумму,
[20:21.260 --> 20:26.220]  если сблокать сумма s, то здесь станет сумма плюс дельта. А потом нужно спуститься вот в одного из
[20:26.220 --> 20:31.060]  этих детей и с ним сделать то же самое. Если человек меняется, если вершинка меняется,
[20:31.060 --> 20:36.020]  то мне нужно ее как бы скопировать, завести новую вершинку, перекопировать ссылки на детей и обновить
[20:36.020 --> 20:41.900]  сумму. На самом деле все очень просто. Мне нужно скопировать, мне нужно научиться перекопировать
[20:41.900 --> 20:47.420]  одну вершинку в другое место, сохранить ссылки на детей и просто в новой вершинке изменить
[20:47.420 --> 20:53.860]  значение суммы, изменить сумму, увеличить ее на дельту. А ссылки на детей у меня сохранятся.
[20:53.860 --> 20:59.900]  Потом я понимаю, в какого из детей мне нужно спуститься. Туда спускаюсь и там изменяю то же
[20:59.900 --> 21:04.820]  самое, ее перекопирую, сохраняю ссылки на детей и там изменяю значение. И так далее спускаюсь до
[21:04.820 --> 21:11.420]  листика. В итоге как раз будет сделано то, что хочется. У меня будет отдельно храниться старое
[21:11.420 --> 21:17.300]  дерево. Если я буду поддерживать указатель на старый корень, то у меня будет оно целиком доступно,
[21:17.300 --> 21:23.100]  потому что все эти ссылочки не поменялись. Там все равно хранится вся информация про предыдущую
[21:23.100 --> 21:29.740]  версию. Единственное, что добавится, это появится как бы новую такую путь. Новый путь, который где-то
[21:29.740 --> 21:37.380]  ссылается на, ну вот частично ссылается на старое дерево. Тут какие-то есть такие стрелочки. Ну и
[21:37.380 --> 21:41.900]  хорошо получается, что как раз у меня есть как раз отличие на нового дерева от старого, что
[21:41.900 --> 21:45.700]  отличается на таком маленьком пути, а все остальное как раз ссылается на старое дерево.
[21:45.700 --> 21:54.100]  Может пресс? Да. То есть у нас все дерево хранится в массиве нодов? Да, можно так, ну в векторе скорее,
[21:54.100 --> 21:59.500]  чтобы уметь добавлять конец. Да, хорошо. А можем ли мы отбросаться от этого и хранить только вот
[21:59.500 --> 22:05.380]  основные вершины, то есть вот корни в векторе? Зачем им всех детей тоже хранить вектор? Да,
[22:05.380 --> 22:12.260]  ну это хороший вопрос. Это так можно сделать, но тогда вам нужно сделать, ну в смысле они же все
[22:13.100 --> 22:19.860]  же в какой-то памяти должны храниться. Да, это можно сделать, но тогда видимо, вам нужны указатели,
[22:19.860 --> 22:26.380]  чтобы не хранить явно, то есть не хранить их в массиве, можно просто их где-то заводить, хранить их
[22:26.380 --> 22:30.140]  по указателям, и потом, если вам нужно очистить память, то вам нужно будет от всех корней пройтись
[22:30.140 --> 22:34.940]  и запустить delete от всех таких достиженных вершин. То есть можно сделать так, что в массиве
[22:34.940 --> 22:40.600]  Т хранятся не вообще все вершины, а только корни, только, ну вот все версии корней. Да, и потом,
[22:40.600 --> 22:45.200]  чтобы очистить память, вам нужно будет пройтись вниз и сделать дилет, так тоже можно сделать.
[22:45.200 --> 22:53.120]  Ну и когда мы такую штуку сделали, потом отвечать на запрос второго типа, то есть второй тип это
[22:53.120 --> 22:58.040]  когда в момент времени t нужно найти сумму на отрезке, мне нужно просто вот во всем этом
[22:58.040 --> 23:02.720]  огромном наборе деревьев отрезков, то есть по сути у меня есть как бы первый корень,
[23:02.720 --> 23:07.920]  какой дерево отрезка было с самого начала, второй корень, то есть как дерево поменялось после первого
[23:07.920 --> 23:13.360]  запроса, третий и так далее и так далее, вот есть опять цепочка корней, как у меня, ну изменяется вот
[23:13.360 --> 23:19.400]  этот вот верхний вершина моего дерева, тогда нам нужно просто найти там тетую версию, если это равно
[23:19.400 --> 23:27.520]  трем, то мне нужно посмотреть, видимо сюда, да, 0, 1, 2, 3, нужно посмотреть в эту версию дерева отрезков,
[23:27.520 --> 23:36.080]  и в ней просто обычным образом найти сумму, в этом дереве ищем сумму на отрезке, но так
[23:36.080 --> 23:49.200]  он уже умеем делать, просто сумма на отрезке в дереве, в дереве отрезков, и здесь всё, да, вопрос,
[23:49.200 --> 23:55.160]  а что у нас в итоге момент времени t хранится? а так у меня кстати конфликтовозначение, что у меня t
[23:55.160 --> 24:00.240]  это с одной стороны массив вершин, с другой стороны момент времени, давайте скрутаем,
[24:00.240 --> 24:13.280]  ещё раз, что хранится? у меня хранится, ну я пишу так, я пишу, что у меня есть один большой вектор t,
[24:13.280 --> 24:18.760]  в котором хранятся вообще все когда-либо использовавшиеся вершины, ну раз мне всё равно
[24:18.760 --> 24:22.840]  нужно иметь доступ к любой версии, то значит где-то у меня должны храниться все эти вершины,
[24:22.840 --> 24:28.800]  пусть они все в каком-то порядке лежат в векторе t, в этом векторе t, также мне нужно ещё какой-то
[24:28.940 --> 24:36.840]  список корней, roots это список всех корней всех деревьев отрезков, на счет вот у меня есть эта вершинка,
[24:36.840 --> 24:42.640]  она лежит в roots, эта вершинка, эта вершинка, эта, и так далее, короче, все корни, все версии корней,
[24:42.640 --> 24:47.320]  потому что корень всё равно всегда меняется после каждого запроса, поэтому как раз версия
[24:47.320 --> 24:50.880]  у меня будет ровно столько, сколько запроса изменений, соответственно и корней будет столько,
[24:50.880 --> 24:55.880]  сколько запроса изменений, храню, то есть таким образом я на самом деле всего два массива,
[24:55.880 --> 25:02.960]  массив t и массив roots. а дальше, когда приходит запрос о том, чтобы в какой-то момент времени time
[25:02.960 --> 25:11.460]  узнать какая была версия деревоотресков, я просто обращаюсь к элементу roots.time, и это как раз у меня
[25:11.460 --> 25:20.120]  указатель или номер вершины в массиве t, который соответствует корню дерева в момент времени time.
[25:20.120 --> 25:26.960]  и вот эти roots, вот эти корни как раз складывают таким образом в массив roots, что roots от time это
[25:26.960 --> 25:35.960]  версия корня в момент времени time, то есть после запроса с номером time. так, ответил ли я на вопрос?
[25:35.960 --> 25:46.200]  ясно. хорошо. нам в самом вот векторе с элементами не нужно хранить обратных указателей на новые
[25:46.200 --> 25:51.920]  деревья, потому что если нам придут запросы к двум разным веткам, то мы не сможем правильно
[25:51.920 --> 25:58.120]  дать ответ на вопрос, какая сумма будет на подотреске. что значит к двум разным веткам, я не очень понял.
[25:58.120 --> 26:04.880]  ну, допустим, у нас левый и правый элемент будут изменены, а нас попросят найти сумму, ну, допустим,
[26:04.880 --> 26:15.000]  на всем подотреске. ну, короче, главное, чтобы ответ не лежал в вертушине, тогда мы не сможем указать
[26:15.000 --> 26:21.600]  ответ, потому что мы имеем только одну ветку. смотрите, значит, утверждение следующее, что если вы
[26:21.600 --> 26:28.520]  рассмотрите вот этот вот roots от time, то все дерево, достижимое по стрелкам из этого, из этой вершинки с
[26:28.520 --> 26:34.280]  номером roots от time, это корректное дерево отрезков в момент времени time, то есть после запроса с
[26:34.280 --> 26:40.120]  номером time. доказывается простой индукции. если у меня time равно нулю, дерево еще не менялось,
[26:40.120 --> 26:43.800]  не происходило ни одного запроса, то я в самом начале построил корректное дерево отрезков,
[26:43.800 --> 26:49.000]  там в каждой вершине хранится правильная сумма. дальше, приходит первый запрос изменения. что
[26:49.000 --> 26:55.160]  меняется? меняется некоторый будь, вот этот синенький будь меняется, те вершины, которые не
[26:55.160 --> 26:59.680]  меняются, я на них пересылаюсь, вот эти вот черные стрелки длинные, я на них пересылаюсь,
[26:59.680 --> 27:05.840]  таким образом меняется только сумма на вот этом вот синем буди, только в этих вершинах меняется
[27:05.840 --> 27:11.720]  сумма. вспоминаем утверждение, что если я встану вот сюда, вершинку с номером roots от единицы,
[27:11.720 --> 27:17.560]  это корень корректного дерева отрезков в момент времени после первого запроса. действительно,
[27:17.560 --> 27:22.440]  вот есть корень, в нем лежит правильная сумма, потому что, по сути, я в нем как раз увеличил на
[27:22.440 --> 27:27.360]  то самое дельта, который мне пришла. запрос изменения, вот здесь было плюс дельта, я это учел.
[27:27.360 --> 27:33.840]  дальше, слева у меня левый сын, по сути, это все старое левое под деревом, оно не поменялось,
[27:33.840 --> 27:38.120]  я в него ссылаюсь, то есть там ничего не поменялось. значит, как раз это есть корректное
[27:38.120 --> 27:41.820]  дерево, что в момент времени mình, ноль, то и в момент времени один. оно не поменялось,
[27:41.820 --> 27:47.200]  я могу туда сослаться. идем вправо. здесь что поменялось?
[27:47.200 --> 27:51.120]  поменялось по сравнению это с старой версией только то, что сумма увеличилась на дельту.
[27:51.120 --> 27:55.320]  ну, мы это учли, когда создали новую вершинку, у меня там сумма увеличилась на дельту,
[27:55.320 --> 28:00.840]  поэтому здесь тоже все верно. получается, что у меня у корня и левый сын правильный и правый сын
[28:00.840 --> 28:04.780]  правильный. но для всех остальных у меня, либо поменялась вершина и там увеличилась сумма
[28:04.780 --> 28:09.460]  сумму на нужное значение, либо по дереву не изменилось, вот как здесь. и я на него
[28:09.460 --> 28:12.740]  просто пересосвался. ну и раз там все было раньше корректно, ничего не поменялось,
[28:12.740 --> 28:18.660]  ну и теперь корректно. давайте запишем утверждение. дерево,
[28:18.660 --> 28:37.060]  достижимое по стрелкам из roots of time. это правильное дерево отрезков,
[28:37.060 --> 28:45.180]  то есть в каждой вершине написано сумма из под дерева. правильное дерево отрезков
[28:45.180 --> 28:57.540]  после запроса номер time. вроде я на пальцах объяснил почему-то так, потому что корень
[28:57.540 --> 29:02.500]  я правильно написал, левый сын у него правильный, правый сын у него правильный, дальше пошли в ту
[29:02.500 --> 29:06.340]  ветку, которая поменялась, и там точно так же все рассуждения проходят, что в одной вершинке
[29:06.340 --> 29:13.180]  я изменил сумму на дельта. да, согласен. да, правый сын не поменялся, и там все скопировали просто.
[29:13.180 --> 29:20.860]  сейчас, а у нас, мы же никогда не поднимаемся, да, наверное, по каким-то, то есть нам нужно такое узнать,
[29:20.860 --> 29:27.380]  ссылку, ну, как добраться до детей, но за родителя детей не надо добираться. да, нам ссылка в родителя
[29:27.380 --> 29:40.900]  нам не нужна, верно. хорошо. как мы обновляем? обновляем, в смысле, вот эту плюс дельту делаем?
[29:40.900 --> 29:51.300]  ну, смотрите, значит, это вот то, что я выше писал, значит, вот то, что я здесь рисовал, смотрите,
[29:51.300 --> 29:54.620]  если у меня есть какой-то корень, если у меня есть старая версия вершинки, вот это вот Т от В,
[29:54.620 --> 29:59.060]  у меня было правильное в этой вершинке, у нее был правильный левый сын, правильный правый сын,
[29:59.060 --> 30:04.780]  и мне нужно было поменять значение С здесь на значение С плюс дельта, тогда изменение такое,
[30:04.780 --> 30:11.060]  я завожу новую вершинку В, ну, там в вектор Т, pushback, новую вершинку, сумма в ней это С плюс дельта,
[30:11.060 --> 30:16.460]  потому что сумма на дельта должна увеличиться, а ссылки я просто перекопировал, то есть левый сын
[30:16.460 --> 30:21.140]  ссылается сюда, туда же, куда и раньше, и правый сын ссылается сюда, тоже туда же, куда раньше.
[30:21.140 --> 30:25.180]  Получается, я вот одну вершинку так скопировал, как бы сохранил ссылки и поменял значение,
[30:25.180 --> 30:30.540]  а дальше, чтобы поменять в поддереве, я, ну, как бы по сути спускаюсь рекурсивно, что если
[30:30.540 --> 30:37.180]  мне нужно поменять что-то в этом поддереве, то я встаю в эту старую вершинку, встаю, сначала ее
[30:37.180 --> 30:41.500]  копирую точно так же, как, ну, в общем, процедура копирования вершинки вот в какую-то новую,
[30:41.500 --> 30:47.460]  создаю новую вершину, если здесь была какая-то сумма, не знаю, у, то я здесь пишу у плюс дельта,
[30:47.460 --> 30:55.500]  и вот эти вот ссылки перекопирую просто из старой вершинки, то есть обновление это просто
[30:55.500 --> 31:02.420]  вот копирование вершины с перенаправлением стрелочек и рекурсивный спуск до правильного листика.
[31:02.420 --> 31:09.420]  А массив roots мы как заполняем? Когда мы копируем корень, мы врут с pushback-ом новый корень.
[31:09.420 --> 31:23.020]  Когда мы копируем, ну, на моменте времени t равное i, мы же копируем t-ity корень. Ну,
[31:23.020 --> 31:28.540]  как бы мы из предыдущего корня, не из основного, который был на 1 раньше.
[31:28.540 --> 31:36.660]  Да, мы всегда смотрим на предыдущую версию и оттуда перекопируем, да.
[31:36.660 --> 31:43.540]  Ну, у нас задача такая, что у нас есть как бы сплошной поток изменений, и каждое изменение
[31:43.540 --> 31:46.660]  это изменение по сравнению с предыдущим запросом, что вот всю предыдущую историю мы
[31:46.660 --> 31:52.100]  сохранили, а еще нужно сделать новый запрос, изменение. А запросы второго типа, это вот во
[31:52.100 --> 31:56.020]  всей этой истории изменений, длинной и большой, мы делаем какие-то случайные хаотические тыки,
[31:56.020 --> 32:01.460]  а вот там, не знаю, 5 лет назад что было, а 10 лет назад, а там, не знаю, а вот 5 секунд назад что
[32:01.460 --> 32:06.820]  было, да, то есть есть сплошная история изменений подряд, каждый запрос изменяет массив по сравнению
[32:06.820 --> 32:12.380]  с предыдущим, с предыдущим состоянием, а потом тыки в произвольные места, это вот как раз просмотр
[32:12.380 --> 32:23.860]  какой-то версии, какой-то более старой версии. Так, окей, вроде плюс-минус, еще раз палец
[32:23.860 --> 32:31.860]  вопроса. Давайте тогда заметим про время работы всего этого дела. Во-первых, время, время работы,
[32:31.860 --> 32:43.620]  как всегда, логарифм на запрос, логан на запрос, значит, логан на запрос, ну потому что, то есть,
[32:43.620 --> 32:48.340]  какой у меня запрос, у меня есть запрос изменения, запрос изменения, у меня работает так, я по сути просто беру
[32:48.340 --> 32:53.100]  какой-то путь в старом дереве, в предыдущем дерево, перекопирую его, точно так же, да, то есть,
[32:53.100 --> 32:57.580]  создаю вершины к столику, сколько было в нем, ну и там перенаправляю вот эти стрелочки, вот эти все
[32:57.580 --> 33:02.400]  стрелочки перенаправляю. Это работает за длину пути, то есть, за логарифм, потому что, ну, глубина
[33:02.400 --> 33:09.220]  дерева у меня по режиму логарифм. Это запрос изменения, запрос нахождения суммы, это нужно просто в
[33:09.220 --> 33:13.740]  такой-то версии, да, в конкретной версии дерево отрезков, найти сумму на отрезке, сумму на отрезке мы
[33:13.740 --> 33:20.340]  знаем, как искать за логарифм, как обычно. Вот, но единственное, что здесь такое неприятное по сравнению
[33:20.340 --> 33:30.420]  с обычными деревьями отрезков, это затраты памяти, затраты памяти. А именно, у нас каждый запрос изменения,
[33:30.420 --> 33:37.380]  он связан с логарифмическим количеством новых ячеек. На каждое изменение, каждый запрос изменения,
[33:37.380 --> 33:53.100]  изменения, это создание логен новых вершин, логен новых вершин. Ну и нам все эти вершинки надо
[33:53.100 --> 33:59.780]  хранить, да, либо в явном виде, вот как я пишу, в массиве t, ну, в векторе t я их все сохраняю, либо мы можем
[33:59.780 --> 34:04.060]  явно на них ссылки не хранить и просто писать все по указателям и хранить только ссылки на корней,
[34:04.060 --> 34:10.180]  вот. Но все равно они где-то же в памяти лежат, это все равно учитывается в количестве затрачивания
[34:10.180 --> 34:16.380]  памяти, поэтому это нужно, этим нельзя пренебречь, у нас на каждом шаге заводится логен новых вершин.
[34:16.380 --> 34:22.780]  Поэтому память здесь построена с обычным деревом отрезков, у меня память растет от запроса к запросу,
[34:22.780 --> 34:30.740]  и тем самым, если у меня было всего q запросов, q запросов, то память у меня тогда задействуется,
[34:30.740 --> 34:41.420]  ну я напишу так, n плюс q log n, n это от исходного, ну, от исходной версии дерева отрезков,
[34:41.420 --> 34:47.420]  от самого начального дерева отрезков, и q log n по логарифму на каждый запрос.
[34:47.420 --> 34:55.460]  То есть, по сути, все здорово, мы отвечаем за такой же логарифм на каждый запрос,
[34:55.460 --> 35:00.020]  только немножко растет память, память растет логарифмично от каждого запроса.
[35:00.020 --> 35:02.780]  Такое важное замечание.
[35:02.780 --> 35:12.980]  У вас спрашивали, как обновлять дерево, и вы говорили, что сверху вниз, а что если не
[35:12.980 --> 35:18.620]  получится обновить сверху вниз. Ну, например, задача у нас на семинаре была, к массиву поступают
[35:18.620 --> 35:25.220]  запросы изменения элемента, и после каждого запроса нужно сообщить под отрезок всего массива
[35:25.220 --> 35:31.060]  с максимальной суммой. Вот, это не получится изменить сверху вниз, это нужно снизу вверх
[35:31.060 --> 35:41.300]  изменить. Получится, да, получится сверху вниз. Ну, на самом деле, снизу всегда более слабо,
[35:41.300 --> 35:47.740]  чем сверху. Давайте кратко отсудим. Значит, раз вы это решали, то вы, наверное, хранили в каждой
[35:47.740 --> 35:54.100]  вершине отрезок с максимальной суммой в поддереве, сумму на всем отрезке, а также максимальный
[35:54.100 --> 36:01.980]  суффикс и префикс, правда? Ну, тогда, смотрите, если мне нужно обновить в каком-то элементе
[36:01.980 --> 36:13.940]  значение, а это нужно поменять. Значит, я иду сверху вниз, запускаюсь рекурсивно вдоль этого
[36:13.940 --> 36:18.580]  пути, и, допустим, вот здесь, когда я дошел до этого листика, понятно, что там нужно написать,
[36:18.580 --> 36:22.740]  то есть у меня контролируется только одна вершина, а там все эти вершины понятно пересчитываются.
[36:22.740 --> 36:27.540]  Дальше мы эту рекурсию как бы разворачиваем и идем снизу вверх. То есть, когда я там сначала
[36:27.540 --> 36:31.300]  спустился в сына, посчитал, что в сыне нашлось правильное значение, и теперь я склеиваюсь,
[36:31.300 --> 36:35.100]  ну, то есть пересчитываю значение в текущей вершине, зная значение в новом сыне. То есть,
[36:35.100 --> 36:39.180]  скажем, вот здесь у меня есть вершинка В, я запустился от там правого сына в В плюс один,
[36:39.180 --> 36:44.300]  и в нем хранится новое правильное значение, мне нужно пересчитать значение В. Ну, как это делать?
[36:44.300 --> 36:49.740]  Собственно, мы храним эти четыре значения для того, чтобы это можно было склеивать. Если я знаю
[36:49.780 --> 36:55.240]  максимальную подсуму здесь, максимальную подсуму здесь, то нужно здесь взять из них максимум,
[36:55.240 --> 37:00.300]  потом максимальный префикс это либо максимальный префикс отсюда, либо, сумма здесь плюс максимальный
[37:00.300 --> 37:03.700]  префикс отсюда, ну и так далее. По сути мы склеиваем ответ на vibrations pounds с левой
[37:03.700 --> 37:07.460]  и с правой, и получаем ответ с вершинки В. Ну, то есть вы сначала спустились сниз,
[37:07.460 --> 37:12.500]  по нас издавав новые вершины по капусты... Да, и с родновными значениями. Потом поднимаетесь
[37:12.500 --> 37:17.820]  здесь вверх, пересчитываешь все? Да, я понял. В каком-то смысле да, то есть я иду по сути снизу,
[37:17.820 --> 37:21.960]  то есть я проталкивал информацию снизу вверх, но перед этим я все равно прошел снизу вверх,
[37:21.960 --> 37:26.340]  извините, сверху вниз, все перекопировал, ну и уже по этому новому пути иду снизу вверх.
[37:26.340 --> 37:42.260]  хорошо, так это обсудили, персентное мы обсудили, вот, и зачем это может быть,
[37:42.260 --> 37:45.820]  например, нужно. давайте вспомним задачу, которая была в прошлый раз, про количество
[37:45.820 --> 37:53.020]  чисел на отрезке, количество чисел на отрезке, которые больше или равны чем x,
[37:53.020 --> 38:01.620]  напоминаю кратко, есть какой-то статический массив неизменяемый, статический массив,
[38:01.620 --> 38:10.260]  а 0, 1, так далее, n-1, и поступают запросы одного типа, это три числа rx, мне нужно на отрезке с
[38:10.260 --> 38:16.540]  a или rt найти количество чисел, которые больше или равны чем x, то есть количество чисел,
[38:16.540 --> 38:21.020]  которые лежат на отрезке, и при этом сами хотя бы больше или равны чем x. вот мы решили в
[38:21.020 --> 38:25.860]  прошлый раз с помощью fractional cascading, да, это вот когда там, ну, не буду, не буду обсудать,
[38:25.860 --> 38:31.740]  еще раз, с помощью merge sort 3 мы это сделали, теперь мы это сделаем с помощью персентного
[38:31.740 --> 38:37.700]  деревоотреска, то же самое, только альтернативный подход. значит, давайте сделаем следующее,
[38:37.700 --> 38:42.860]  давайте мы отсортируем весь наш массив, там, любым алгоритмом сортировки, хоть merge sort, хоть
[38:42.860 --> 38:48.900]  quick sort, хоть что хотите, а именно, давайте мы заведем массив sort от вот таких вот пар,
[38:48.900 --> 38:56.100]  а 0 запятая 0, а 1 запятая 1, и так далее, а n-1, n-1, то есть мы не только посортируем,
[38:56.100 --> 39:00.980]  но также запомним, как бы, откуда каждый элемент пришел, заведем такой массив пар,
[39:00.980 --> 39:06.980]  отсортируем их, ну, как обычно, как обычно, сортируются пары, сначала сравниваются
[39:06.980 --> 39:11.380]  по первому элементу, потом по второму, так вот, после сортировки, когда я вызываю алгоритм,
[39:11.380 --> 39:16.780]  там, любой алгоритм сортировки нашего массива, sort, у меня как раз будут расположены числа
[39:16.780 --> 39:21.380]  в порядке возрастания, и при этом я про каждое число знаю, где оно лежало изначально, не знаю,
[39:21.380 --> 39:27.380]  там, сначала будет минимальное число с позиции этого минимума, потом, какой-то второй максимум,
[39:27.380 --> 39:34.020]  да, second минимум, его позиция, ну, и так далее, то есть, по сути, у меня есть сортировка массива,
[39:34.020 --> 39:40.620]  а также, откуда пришел каждый элемент, тогда давайте сделаем следующее, давайте мы сначала убьем все
[39:40.620 --> 39:49.500]  элементы, будем считать, что все элементы мертвы, все элементы мертвы, ну, и заведем дерево отрезков,
[39:49.500 --> 40:03.860]  которое считает количество живых элементов в поддереве, которое хранит количество живых
[40:03.860 --> 40:12.100]  элементов, значит, сначала все мертвые, и у меня в каждой вершинке ноль живых, затем мы будем
[40:12.100 --> 40:16.980]  оживлять эти числа, эти элементы в порядке возрастания, то есть, мы сначала оживим минимум,
[40:17.500 --> 40:23.420]  нет, давайте, наоборот, в порядке убывания, извините, оживляем, в порядке убывания, да, и сначала мы оживим
[40:23.420 --> 40:32.820]  максимум, потом предпосреднее, увеличенное число, потом предопред, последнее, и так далее,
[40:32.820 --> 40:42.500]  оживляем элементы, элементы в порядке убывания, порядке убывания, и получается, что у меня к дереву отрезков
[40:42.500 --> 40:46.420]  отрезков вступает запрос оживить какой-то элемент, но соответственно, когда элемент оживает,
[40:46.420 --> 40:51.340]  мне нужно на всем пути от него до корня, или что-же самое, от корня до него, прибавить единичку,
[40:51.340 --> 40:56.340]  там у меня ожило по элементу в каждом из этих вот, ну в каждый из вершинок один элемент ожило,
[40:56.340 --> 41:01.860]  мне нужно прибавить один, то есть по сути оживление это плюс один на пути в дереве,
[41:01.860 --> 41:09.580]  на пути в дереве, и мы это дерево будем хранить персистентно, персистентное дерево отрезков,
[41:09.580 --> 41:13.740]  то есть мы будем хранить все его версии, мы будем хранить версию, когда все мертвые,
[41:13.740 --> 41:17.980]  потом когда один живой, потом когда два живых, три живых, и так далее, и так далее,
[41:17.980 --> 41:25.500]  все эти версии мы будем хранить. а дальше что? а дальше, когда мне приходит запрос в стиле,
[41:25.500 --> 41:32.820]  сколько есть чисел на отрезке lr, которые больше равны, чем x, я посмотрю на дерево отрезков в
[41:32.820 --> 41:37.140]  момент времени, когда живыми были только элементы, больше равные, чем x. у меня же все равно,
[41:37.220 --> 41:43.240]  у меня есть версия дерево отрезков, когда живые все, ну там сколько-то максимальных элементов,
[41:43.240 --> 41:47.860]  есть версия, когда жив только максимальный, есть версия, когда живые два максимальных,
[41:47.860 --> 41:52.260]  и так далее, и так далее, то есть по сути для каждого x. у меня есть версия дерева отрезков,
[41:52.260 --> 41:57.340]  в котором живы все элементы больше равні, чем x, и больше никто не жив, но если в этом дереве
[41:57.340 --> 42:01.280]  отмечено как раз только те самые элементы, которые мне нужны, да, те живые элементы,
[42:01.280 --> 42:05.500]  которые больше равны, чем x, мне нужно просто найти кори full живых на отрезке в каком-то дереве,
[42:05.500 --> 42:10.380]  ровно это мы и будем делать. мы просто обращаемся к нужному дерево отрезков,
[42:10.380 --> 42:15.340]  когда живые элементы это те самые, которые мы больше равные, чем x, и потом
[42:15.340 --> 42:27.140]  просто находим количество живых на отрезке. можно вопрос? да. как мы определяем версию,
[42:27.140 --> 42:33.820]  в которой были... бинпоиском. а, бинпоиском. все, понятно. так, давай сейчас мы все это напишем.
[42:33.820 --> 42:48.380]  итак, давайте... обжимем просто номер махива. еще раз? а, у нас же числа нечестные. ну скорее
[42:48.380 --> 42:55.340]  любые целые. ну да, ну может быть вещественные. не только те, которые лежат в дереве. да-да,
[42:55.340 --> 43:05.840]  могут быть не обязательно из массива. итак, давайте напишу следующее. для любого и от одного
[43:06.200 --> 43:21.120]  у нас есть версия DO, у нас есть версия дерево отрезков, в котором живы только элементы,
[43:21.120 --> 43:39.520]  больше либо равные этой порядковой статистике. этой порядковой статистике. я напоминаю,
[43:39.520 --> 43:44.320]  что эта порядковая статистика это как раз число, которое находится на этом месте после сортировки.
[43:44.320 --> 43:50.160]  и вот здесь, когда я массив сортир посортировал, у меня как раз там, да, на первом месте хранится
[43:50.160 --> 43:53.940]  Pure numbers в минимум. то есть первая порядковая статистика на втором, второе минимум, то есть вторая
[43:53.940 --> 44:00.960]  статистика, и так далее. и вот когда я иду в порядке убывания, в ite-м дереве есть все числа,
[44:00.960 --> 44:06.340]  которые больше равны, чем ite, после сортировки. то есть больше чем ite порядковая статистика.
[44:07.080 --> 44:11.440]  и для каждого ite, то есть для каждой порядковой статистики, у меня есть для каждого числа,
[44:11.440 --> 44:16.000]  по сути. у меня есть версия DO, которая хранит все числа больше, равно чем оно, да и живые,
[44:16.000 --> 44:27.760]  только они. тогда значит ответ на запрос такой, ответ на запрос lrx. мне нужно найти такое и, найти
[44:27.760 --> 44:35.040]  минимальное и, что и та порядка статистического массивя, и та порядка статистического массивя
[44:35.040 --> 44:44.920]  больше равна, чем x. потому что мне нужно сейчас рассматривать, ну считать живыми, только те
[44:44.920 --> 44:50.520]  элементы, которые больше равны, чем x. давайте тогда вот найдем в нашем массиве sortit, в ассортированном
[44:50.520 --> 44:56.080]  массиве нашем sortit, мы найдем первое число больше равна, чем x. и тогда как раз живыми
[44:56.080 --> 45:00.480]  нужно считать только те, кто стоят правее. вот эти вот живые. раз мне нужны все больше равны,
[45:00.480 --> 45:06.640]  чем x. и это какое-то там какое-то итое число. значит мне нужна просто ита версия деревоотресков
[45:06.640 --> 45:13.960]  посмотреть в ней, вот просто посмотреть, что было в ита версии. и количество живых там на отрезке lr,
[45:13.960 --> 45:19.040]  это в точности интересующие меня значения. в точности количество чисел на отрезке lr,
[45:19.040 --> 45:38.320]  которые больше равны, чем x. в конце нужно найти количество живых на отрезке lr в итом деревоотресков.
[45:39.320 --> 45:50.720]  вот такое симпатичное решение. мы все посортировали, потом прошлись порядки возрастания и храним
[45:50.720 --> 45:58.120]  персидентное деревоотресков, храним персидентное деревоотресков, которое знает все свои версии,
[45:58.120 --> 46:03.400]  и для каждого числа знает, есть версия, где живые как раз все числа больше равны, чем это число.
[46:04.200 --> 46:08.880]  потом просто по x мы находим вот этот и минпоискам, что живыеanno сflowed table,
[46:08.880 --> 46:13.760]  что все числа больше равны x находим этой версии деревоотресков, and then we just need
[46:13.760 --> 46:18.600]  найти число живых элементов, потому что живые и больше равны x% в том дереве, в той версии,
[46:18.600 --> 46:25.920]  же одно и тоже. живые и больше равны x �о, в этой версии деревоотресков. ну все количество живых
[46:25.920 --> 46:39.240]  а мы в каждой вершине в качестве значения мы храним что то есть количество живых клеток на
[46:39.240 --> 46:45.640]  отрезке который эта вершина контролирует верно да да все верно количество живых а запросы меня
[46:45.640 --> 46:50.000]  это просто ну какой-то элемент из мертвого сделать живым и тогда нам нужно на пути сделать
[46:50.000 --> 46:56.280]  плюс один просто пути откорнят эту вершинкой сделать плюс один вот давайте тоже померяем
[46:56.280 --> 47:03.320]  асимптотики всякие время n log n потому что что у меня значит у меня есть сортировка за n log n
[47:03.320 --> 47:09.680]  сначала потом я иду в порядке убывания по всем элементам и для каждого числа я за логарифом
[47:09.680 --> 47:14.240]  делаю обновление как всегда в дереве отрезков у меня как бы когда я перешу к персистентной
[47:14.240 --> 47:19.760]  версии у меня логариф на запрос сохраняется то есть n log n на предпочет ну и потом там давайте
[47:19.760 --> 47:27.480]  ку логен на запрос плюс ку логен чтобы обработать все запросы потому что если у меня всего ку
[47:27.480 --> 47:33.440]  запросов на ку запросов то каждый запрос я обрабатываю за логарифом потому что нужно сначала
[47:33.440 --> 47:39.520]  сделать запустить один поиск чтобы найти вот этот самый и да больше ну что это порядка стрифика
[47:39.520 --> 47:44.480]  больше нашим икс нужно найти правильную версию до а дальше в этой дереве в этом дереве отрезков
[47:44.480 --> 47:50.480]  еще найти сумму на отрезке этом еще логариф поэтому время такое ну а память здесь будет
[47:50.480 --> 47:59.720]  просто логен потому что мне нужно хранить n версии персистентного дерева отрезков да и выше
[47:59.720 --> 48:05.960]  мы писали что каждая версия это плюс логариф памяти раз всего n версии то соответственно мне
[48:05.960 --> 48:22.760]  нужно n логен памяти иметь вот такая престь хорошо это было персент на дерево отрезков
[48:22.760 --> 48:27.880]  теперь давайте еще одну модификацию рассмотрим это динамическое дерево отрезков динамическое
[48:27.880 --> 48:41.520]  дерево отрезков вдохновиться можно следующей следующим примером есть у вас вещественная
[48:41.520 --> 48:49.800]  прямая с координатами там от нуля до 10 18 изначально в каждом в каждой точке как бы записан 0
[48:49.800 --> 48:55.240]  в каждом числе ну в каждой позиции написано число 0 в каждой толчочной позиции написано число 0
[48:55.240 --> 49:02.840]  и поступают запросы как всегда как мы любим двух типов значит в какой-то точке x поменять
[49:02.840 --> 49:12.160]  число написать туда вал а икста присвоить вал и второе это запрос суммы нужно найти сумму с
[49:12.160 --> 49:19.800]  аэль по аэр то есть это практически обычное дерево отрезков только у меня массив на котором все
[49:19.800 --> 49:26.280]  строится да вот этот массив он имеет не какой-то адекватную длину n а длину 10 18 я даже не буду
[49:26.280 --> 49:30.760]  это означать и н кай потому что ну это обычно что-то вот ну адекватно да что можно работать
[49:30.760 --> 49:39.480]  за вот он или вот он уген здесь конечно не за 10 18 и не за 10 не за илоген не заработать поэтому
[49:39.480 --> 49:45.760]  нужно что-то лучше то есть по сути это как обычное дерево отрезков по крайней мере задача такая же
[49:45.760 --> 49:51.960]  только у меня очень большой исходный массив массив имеет длину как бы 10 18 и он даже ну явно
[49:51.960 --> 49:57.080]  мы его нигде не будем хранить конечно вот он вот изначально ну ли в каких-то точках изменения и
[49:57.080 --> 50:04.880]  потом сумма на отрезках вот идея такая давайте мы как будто бы построим дерево отрезков на
[50:04.880 --> 50:11.560]  всем этом огромном массиве длины 10 18 прям целиком да построим такое большое дерево отрезков но
[50:11.560 --> 50:18.480]  будем хранить в нем только вершины в которых хоть что-то происходило потому что понятно что
[50:18.480 --> 50:24.200]  изначально у меня во всех решениях хранятся нули дай и каждая сумма в любом подделе это 0 поэтому
[50:24.200 --> 50:28.280]  по сути нам даже ничего хранить не нужно там заведем корень и приличия таковым что корень
[50:28.280 --> 50:36.040]  соответствует отрезку 0 до 10 17 и в нем сумма равно 0 потом если придет запрос изменения в
[50:36.040 --> 50:42.040]  точке то что происходит по сути давайте пересуе чтобы у меня не было наложение насчет есть у меня
[50:42.040 --> 50:49.040]  огромный массив который явно нигде не хранится есть корень 0 10 18 сумма равна
[50:51.040 --> 50:56.920]  потом приходит изменение в какой-то точке их нужно написать что вал что меняется меняется
[50:56.920 --> 51:02.320]  что-то в очень небольшом числе вершин нам уже понимаем только что наблюдали персоветом
[51:02.920 --> 51:10.240]  что меняется у меня только ну вот этот путь мне нужно там как-то правильно дойти до вершинки
[51:10.240 --> 51:14.800]  и кстам какой-то длинный будет путь ну короче как-то мы сюда пришли тогда давайте вот эти вершинки
[51:14.800 --> 51:19.640]  их как бы пока что явно еще нету у меня просто нету ссылок ни налево ни налево ни направо сына
[51:19.640 --> 51:24.600]  у корня их вообще еще не существует давайте заведем то есть понятно что раньше был 0 поэтому
[51:24.600 --> 51:28.840]  в принципе то что мы ее не хранили это не страшно мы так знаем что вам сумма равна 0 поэтому
[51:28.840 --> 51:33.040]  можно было бы не хранить но если у меня теперь поступает к ней запросы мне нужно туда спуститься
[51:33.040 --> 51:38.640]  но что делать заведем ее создадим вот этого права сына скажем что там отрезок ну какой-то
[51:38.640 --> 51:47.880]  видимо 10 18 пополам 10 18 сумма все еще ну вот и так далее короче спустимся до вот этого икса и
[51:47.880 --> 51:54.640]  все эти вершинки по пути создадим ну их там раньше не было там был ну вот их сначала создать а потом
[51:54.640 --> 51:59.400]  уже если у меня есть этот путь то мне нужно просто вдоль этого пути пройтись и в них
[51:59.400 --> 52:03.920]  вовсе прибавить вал на что это все нужно сюда поставить и соответственно сумма на всем этом
[52:03.920 --> 52:10.680]  пути увеличивается в точности на вал потом если приходит какой-то другой запрос там в какой-то
[52:10.680 --> 52:17.000]  другой точке игрек нужно что-то что-то поменять я опять как будто бы спускаюсь в эту вершинку
[52:17.000 --> 52:22.040]  игрек как я спускался бы в обычном дереве отрезков только каждая вершина которая пока не существует
[52:22.040 --> 52:26.840]  который я пока не создал мы ну я ее создаю там мне нужно спуститься в левого сына ну что
[52:26.840 --> 52:34.880]  поделать спускаюсь и создаю его здесь будет там координаты от нуля до 10 18 пополам сумма тоже
[52:34.880 --> 52:41.480]  ну давайте здесь плюс один чтобы не перескалось вот сумму ровную все вершинки тоже на пути
[52:41.480 --> 52:47.520]  создаем которые там еще не были и потом обратно поднимаемся и делаем плюс там какой-то вал новая
[52:47.720 --> 52:54.440]  не вал на всем этом пути вот и так будем работать просто если нужно пойти вершины вот прям по зарез
[52:54.440 --> 53:00.040]  нужно и там что-то поменять то и причем ее еще нету то создаем пишем что там сумма равна нулю раз
[53:00.040 --> 53:06.560]  мы там еще не были там еще ничего не приходил сумма точно 0 создаем и туда заходим а если вершинки
[53:06.560 --> 53:11.960]  нету то значит ну и собственно там сумма нули то и нам туда не надо не надо идти то ее просто не
[53:11.960 --> 53:16.560]  храним то есть такое динамическое зерево отрезков оно очень ленивое оно хранит только что-то
[53:16.560 --> 53:22.160]  полезно оно не хранит все вот эти подделия где сумма точно 0 нам это не нужно там точно ли и
[53:22.160 --> 53:30.960]  если нам потребуется мы всегда эти вершинки сможем завести вот ну давайте напишем какой-нибудь такой
[53:30.960 --> 53:41.240]  микрокод что я хочу иметь давайте я ну тоже у меня будет вершинка структ нот которые хранится
[53:41.240 --> 53:54.600]  сумма давайте я для удобства напишу здесь же tltr вопрос какой-то
[53:54.600 --> 54:06.080]  нету она значит в вершинке я вот поддерживаю координаты отрезка который который она контролирует
[54:06.080 --> 54:13.680]  значит дальше что мне нужно мне еще нужна ссылка налево право сына и левт и трайт
[54:13.680 --> 54:26.040]  я строит вот дальше значит как у меня работать скажем процедура дай да ну и давайте еще
[54:26.040 --> 54:31.080]  конструкторе промолчанию то есть дефолтными значения вот этого левта и райта мы поставим
[54:31.080 --> 54:36.560]  чисто минус один как знак того что у меня нету изначально ни левый ни правого сына и там как
[54:36.560 --> 54:40.720]  бы нулевая сумма там ничего не происходил это скучные вершины мы их как бы даже не
[54:40.720 --> 54:48.080]  создаем говорим что минус один так вот как работает апдейт как работает апдейт скажем
[54:48.080 --> 54:54.680]  в вершинке в когда мне нужно в позиции какой-то пост так плохо давайте ниже
[54:54.680 --> 55:12.240]  сейчас сур апдейт находится в какой-то вершинке в понимает что в какой-то позиции пост мне нужно
[55:12.240 --> 55:17.920]  ну давайте я буду хранить не вал а сразу дельта пусть там я знаю что мне нужно увеличить вдоль
[55:17.920 --> 55:27.160]  пути все надо и простой случай что если да и да и у меня будет вот здесь вектор этих решений
[55:27.160 --> 55:34.440]  вектор нот также как раньше мне будет вектор всех всех у меня будет в одном месте хранится
[55:34.440 --> 55:44.560]  информация во всех решениях в каком-то перемешанном порядке да да да да правильно все пишете по факту
[55:45.000 --> 55:50.160]  умеет все то же самое что и обычно что и обычно но без лишних затрат на память при этом да все так
[55:50.160 --> 56:01.840]  да при этом как на большей массиве тоже работать и так если ты в это точка tail равно ты в этой
[56:01.840 --> 56:06.480]  точке tr то есть если я спросился в листик или выгонить срадно правой тогда мне нужно просто
[56:06.480 --> 56:14.480]  обновить сумму тв это точка сам плюс равно дельта и ретерк если я спросил соблисты делать ничего
[56:14.480 --> 56:20.640]  не нужно мне нужно просто обновить сумму на этом закончится дальше наступает интересное понятно
[56:20.640 --> 56:25.880]  что мне нужно во первых в этой вершинке обновить сумму на то есть что раз по деревья поменялся
[56:25.880 --> 56:29.960]  какое-то шло на дельта то и сумма здесь изменилась на дельта поэтому здесь давайте вот этот трешку
[56:29.960 --> 56:34.280]  просто вынесу до этого и факт я в самом начале в любом случае понимаю что сумму надо увеличить
[56:34.280 --> 56:41.800]  сумму увеличил если в листе то сразу делаем ретерн иначе нужно пойти в детей и возможно
[56:41.800 --> 56:48.400]  какие-то здесь не существует если не существует давайте создадим я напишу это следующим образом
[56:48.400 --> 56:56.840]  лонг лонг тм это как всегда наша любимая полусумма координат до полусумма границы
[56:56.840 --> 57:04.200]  тв тл и тв т тр пополам больше больше один теперь нужно сделать следующий если мне
[57:04.200 --> 57:10.960]  нужно пойти в левого сына и при этом его не существует то пожалуйста создай его напиши там
[57:10.960 --> 57:21.600]  сумму ноль и запустись рекурсивно от левого сына значит если т в это точка т л равно минус
[57:21.600 --> 57:29.880]  единицы и при этом поз меньше в равно чем тм так меньше и равно чем тм да то есть мне нужно пойти
[57:29.880 --> 57:34.000]  в левого сына и при этом его еще как бы я не создал тогда вот нужно его прямо сейчас срочно
[57:34.000 --> 57:42.960]  создавать ну создадим давайте мы добавим в вектор т новую вершинку с какими параметрами ну давайте
[57:42.960 --> 57:50.640]  я напишу так вольно я хочу чтобы у нее сумма была нулевая тл у нее такой же как у вершинки в
[57:50.640 --> 57:57.240]  датель равно тв это точка т л а т равно т м потому что левого сына мы знаем что у него граница
[57:57.240 --> 58:05.000]  этот т л заветает и вот мы создали такую вершинку в нее сослались и с текущей вершины т в этой
[58:05.000 --> 58:15.760]  точке левт равно т точка с ась минус 1 потому что как бы я добавил новую вершинку на нее
[58:15.760 --> 58:20.440]  сослался и с текущей то есть это мой текущий новый левый сын тем самым не нужно как бы ты
[58:20.440 --> 58:25.360]  в это точка левт обновить вот я обновляю ну и в конце нужно запуститься рекурсивно а даже даже
[58:25.360 --> 58:31.240]  не так я вот это сделать а то есть я сейчас создал левого сына и теперь если мне нужно пойти в
[58:31.240 --> 58:46.360]  лево сына то я запускаюсь в него рекурсивно update т в этой точка левт пост дельта вот иначе
[58:46.360 --> 58:51.000]  если мне нужно работать с правым сыном то тоже аналогичный кусок кода обработки правого сына
[58:51.000 --> 58:56.480]  если правого сына нету мне туда нужно пойти то есть если пост больше чем тм то мне нужно
[58:56.480 --> 59:03.120]  право сына завести создать новую вершинку положить туда правильное значение сумм т л тр сослаться
[59:03.120 --> 59:07.560]  из в в качестве правого сына на эту новую добавленную вершинку и запуститься из нее
[59:07.560 --> 59:13.520]  рекурсивно вот и я разнес вот это вот условия да что я вот это вот не вписал сюда потому что
[59:13.520 --> 59:18.960]  а что делать если левый сын был то есть если левый сын был то его не нужно пересоздавать я
[59:18.960 --> 59:24.080]  просто в него спускаюсь рекурсивно а если его не было то я сначала создал и потом потом в него
[59:24.080 --> 59:32.360]  перешел это создание левого сына создание а это это спуск в это самое дело сын все его сначала
[59:32.360 --> 59:42.280]  создал если его не было а потом если туда нужно то я туда и спускаюсь вот ну такой вот будет код
[59:42.280 --> 59:48.400]  для апдейта соответственно гет я я уже писать не буду но смысл такой что если вам нужно найти
[59:48.400 --> 59:52.800]  сумму на каком-то отрезке и скажем вы пытаетесь пойти в под дерево где написан минус один то есть
[59:52.940 --> 59:57.880]  вы показать и пойти вершину которая несоздана но значит туда идти вообще бессмысленно сумма там
[59:57.880 --> 01:00:02.840]  все равно ноль если решение создана значит туда вообще никаких запросов еще не приходила значит
[01:00:02.840 --> 01:00:07.540]  сумма в том под дереве 0 млн дайте это же бессмысленно сумма все равно будет мореisode мы в
[01:00:07.540 --> 01:00:13.220] enschaftа не идем если ускорити только в те вершины которые существуют которые немецоним и так вот
[01:00:13.220 --> 01:00:17.520]  я все обойду если я пытаюсь пойти в не существующие рияна не accelerator а все остальные который
[01:00:17.520 --> 01:00:21.520]  который я обойду, а тут нужно сложить сумму и получит сумму на отрезке.
[01:00:21.520 --> 01:00:27.520]  А мы правого сына игнорируем?
[01:00:27.520 --> 01:00:32.520]  Нет, это я просто не дописал, вот то, что я здесь написал,
[01:00:32.520 --> 01:00:37.520]  многоточие по скотчу tm, это в смысле нужно написать аналогичный код для правого сына,
[01:00:37.520 --> 01:00:41.520]  то есть если правого сына нет, то мы его создаем, и если нужно пойти в правого сына,
[01:00:41.520 --> 01:00:46.520]  то мы в него спускаемся рекурсивно, я просто не буду писать, потому что код аналогичный.
[01:00:46.520 --> 01:00:50.520]  Мы его не игнорируем, отдельно пишем, просто я здесь этого не отобразил.
[01:00:54.520 --> 01:00:57.520]  Так, а мы не поднимаемся потом вверх, чтобы обновить вал, не поднимаемся,
[01:00:57.520 --> 01:01:04.520]  потому что мы в самом начале, я вот эту строчку написал прямо вот первой при заходе в апдейт.
[01:01:04.520 --> 01:01:10.520]  Я зашел в апдейт, сразу же, я понимаю, что поменялось, у меня все увеличилось на дельту,
[01:01:10.520 --> 01:01:13.520]  поэтому давайте вот прям сразу в этой вершинке увеличу все на дельту,
[01:01:13.520 --> 01:01:18.520]  и потом просто рекурсивно спущусь в сына, мне не нужно будет передавать информацию снизу вверх,
[01:01:18.520 --> 01:01:24.520]  я уже знаю, ты в этой точке сам, мне его не нужно пересчитывать.
[01:01:28.520 --> 01:01:30.520]  Так, отлично.
[01:01:32.520 --> 01:01:36.520]  Так, еще вопрос. Вывне должно быть tv-tlf равно минус один вместо tl?
[01:01:36.520 --> 01:01:40.520]  Ой, ой-ой-ой, это я видимо отписался.
[01:01:40.520 --> 01:01:47.520]  Да, спасибо большое, это я виноват, конечно, здесь конечно левт, да, левт.
[01:01:48.520 --> 01:01:58.520]  Спасибо, tl это граница, которую я контролирую, то есть вершинка v контролирует отрезок с tv-tlf по tv-tlf,
[01:01:58.520 --> 01:02:04.520]  а tv-tlf это ссылка, точнее номер левого сына, ссылка на левого сына.
[01:02:04.520 --> 01:02:09.520]  И если вот это вот tlf равно минус 1, если нет левого сына, тогда нужно его создавать.
[01:02:09.520 --> 01:02:11.520]  Да, спасибо, не справили.
[01:02:14.520 --> 01:02:20.520]  Вот, отлично. То есть это мы и научились как бы решать задачу, когда массив мой большой.
[01:02:22.520 --> 01:02:25.520]  Что-то вот со временем, время...
[01:02:27.520 --> 01:02:30.520]  Ну, что здесь можно сказать?
[01:02:30.520 --> 01:02:33.520]  Ну, понятно, что каждый запрос обрабатывается опять-таки за логарифм,
[01:02:33.520 --> 01:02:36.520]  только логарифм будет вот 10 и 18.
[01:02:36.520 --> 01:02:39.520]  Давайте я напишу log c на запрос,
[01:02:41.520 --> 01:02:44.520]  где c равно 10 и 18.
[01:02:44.520 --> 01:02:47.520]  То есть если длина вот этого вот как бы неявного массива это 10 и 18,
[01:02:47.520 --> 01:02:51.520]  то, как всегда, работает все за логарифм, потому что там это обычный спуск по дереву,
[01:02:51.520 --> 01:02:56.520]  либо сумма отрезки, либо апдейт точки, это все работает как в обычном массиве.
[01:02:56.520 --> 01:03:00.520]  А все вот эти операции на создание, ну, в Одиссеи, то есть создание вершинок, которых раньше не было,
[01:03:00.520 --> 01:03:04.520]  они не заменяются всегда от единицы, поэтому все равно главное слагаемое,
[01:03:04.520 --> 01:03:07.520]  это вот глубина нашего дерева будет log c.
[01:03:07.520 --> 01:03:12.520]  Ну, с памятью здесь все то же самое, что в персистентном,
[01:03:12.520 --> 01:03:17.520]  потому что в худшем случае на каждом запросе мне придется создать log c новых вершин.
[01:03:17.520 --> 01:03:21.520]  Поэтому в худшем случае опять-таки плюс log c на запрос.
[01:03:23.520 --> 01:03:27.520]  Потому что может быть такое, что я иду по такому странному пути, где я еще ни разу не был,
[01:03:27.520 --> 01:03:31.520]  поэтому и каждую вершинку мне нужно создать, значит в худшем случае будет log c.
[01:03:31.520 --> 01:03:35.520]  Получается, работает за константы, да, все верно.
[01:03:35.520 --> 01:03:41.520]  Ну, это так, шутка, конечно, потому что, ну, это, это, конечно, большая константа, ее лучше учитывать,
[01:03:41.520 --> 01:03:44.520]  но так тоже можно сказать.
[01:03:44.520 --> 01:03:49.520]  Так, хорошо, хорошо.
[01:03:49.520 --> 01:03:58.520]  Давайте тогда в последнее время, которое у нас остается, мы обсудим разницу подходов онлайн и офлайн.
[01:03:59.520 --> 01:04:03.520]  Онлайн против офлайн.
[01:04:06.520 --> 01:04:08.520]  Здесь имеется в виду следующее.
[01:04:08.520 --> 01:04:12.520]  Всюду, кажется, до этого момента мы говорили про ответственность запроса онлайн.
[01:04:12.520 --> 01:04:18.520]  То есть следующий запрос приходит только после того, как мы обработали предыдущий.
[01:04:18.520 --> 01:04:20.520]  Давайте я это запишу.
[01:04:20.520 --> 01:04:34.520]  Онлайн – это когда следующий запрос приходит только после ответа на предыдущий.
[01:04:40.520 --> 01:04:44.520]  Ну и, собственно, всюду выше мы делали ровно так.
[01:04:44.520 --> 01:04:49.520]  Сначала пришел запрос, я сначала на него отвечу, потом перейду к следующему.
[01:04:49.520 --> 01:04:54.520]  Это вот такой подход, когда мы сразу отвечаем на то, что нас просят.
[01:04:54.520 --> 01:04:57.520]  Есть другой подход, есть подход оффлайн.
[01:04:57.520 --> 01:05:04.520]  Это подход, когда вам все запросы известны заранее, то есть, я не знаю, вы всемогущий предсказатель,
[01:05:04.520 --> 01:05:07.520]  который знаете, какие запросы у вас будут просить пользователя,
[01:05:07.520 --> 01:05:11.520]  либо у вас такая структура, что, не знаю, пришел заказчик и сказал,
[01:05:11.520 --> 01:05:16.520]  вот, типа, у меня будет такая машина, к ней будут такие запросы, пожалуйста, быстро их обработайте.
[01:05:16.520 --> 01:05:20.520]  То есть я вот знаю все, что будет, точно, мне нужно просто это быстро обработать.
[01:05:20.520 --> 01:05:24.520]  То есть оффлайн – это подход, когда все запросы известны заранее.
[01:05:24.520 --> 01:05:32.520]  Все запросы известны заранее.
[01:05:32.520 --> 01:05:39.520]  И вам не нужно отвечать на текущий запрос перед переходом к следующему.
[01:05:39.520 --> 01:05:44.520]  Вы сначала их все можете прочитать как-нибудь интересным образом переупорядочить, как вам удобно.
[01:05:44.520 --> 01:05:47.520]  Потом отвечать в каком-то произвольном порядке, как вам удобно.
[01:05:47.520 --> 01:05:51.520]  Опять, да, вы можете сначала ответить на первый запрос, потом на 20-й, потом на 3-й и так далее.
[01:05:51.520 --> 01:05:53.520]  Вот как вам хотите, так можете отвечать.
[01:05:53.520 --> 01:06:00.520]  Но главное, чтобы только не конкретовали, чтобы там, ну да, то есть не было, чтобы изменений там между 1-м и 20-м,
[01:06:00.520 --> 01:06:02.520]  если вы сразу так телепортируетесь.
[01:06:02.520 --> 01:06:08.520]  В общем, как-то эти запросы вы можете так и порядочить, что вам будет удобнее на них отвечать.
[01:06:08.520 --> 01:06:16.520]  И в оффлайне, конечно, вы чуть более способны.
[01:06:16.520 --> 01:06:22.520]  У вас есть больше возможностей, вы больше знаете про задачу, и довольно часто у вас задача сильно упрощается.
[01:06:22.520 --> 01:06:30.520]  Давайте рассмотрим несколько примеров того, почему переход в оффлайн, он чаще, ну, то есть иногда дает вам какие-то новые возможности,
[01:06:30.520 --> 01:06:35.520]  дает возможность решать задачу быстрее или проще на использовании более простой структуры.
[01:06:36.520 --> 01:06:45.520]  И такое довольно часто наблюдается, но мы все-таки по умолчанию, то есть если в задачах не прописано прям словами,
[01:06:45.520 --> 01:06:48.520]  то скорее всего имеется в виду, что нужно решать онлайн.
[01:06:48.520 --> 01:06:51.520]  То есть на каждый запрос отвечаем вот прям сразу же, как только он пришел.
[01:06:51.520 --> 01:06:54.520]  Ничего не известно заранее, нужно отвечать сразу, как только он пришел.
[01:06:54.520 --> 01:07:02.520]  Но иногда, когда это не так, когда все известно заранее и об этом прямо сказано, тогда можно все это делать.
[01:07:02.520 --> 01:07:11.520]  Итак, первая, первая иллюстрация вот этого оффлайна против онлайна, это сжатие координат, сжатие координат.
[01:07:13.520 --> 01:07:19.520]  Значит, вспоминаем задачу, которая у нас была в динамическом дереве отрезков, динамическое дерево отрезков.
[01:07:19.520 --> 01:07:29.520]  И пусть нам все запросы известны заранее, пусть все запросы известны заранее.
[01:07:29.520 --> 01:07:34.520]  То есть мы знаем, что там сначала придет запрос изменения в такой-то точке, потом придет запрос суммы на отрезке.
[01:07:34.520 --> 01:07:39.520]  Потом такое изменение, такое изменение, такая сумма и так далее, и так далее. Мы знаем все запросы.
[01:07:39.520 --> 01:07:46.520]  Тогда идея следующая. Нам не нужно динамическое дерево отрезков, нам хватит обычного дерева отрезков.
[01:07:46.520 --> 01:07:50.520]  Потому что, ну вот смотрите, если все запросы известны, тогда как бы что это значит?
[01:07:50.520 --> 01:07:55.520]  Это значит, что я знаю какие координаты в принципе вообще важны в этой задаче.
[01:07:55.520 --> 01:08:00.220]  в принципе, вообще важны в этой задаче. То есть в каких координатах что-то будет происходить.
[01:08:00.220 --> 01:08:12.800]  Я знаю все x, в которых что-то происходит, я знаю там все l и все r. Я знаю в каких точках что-то будет
[01:08:12.800 --> 01:08:18.640]  происходить. Давайте тогда я возьму этот вектор всех координат, сложу их в один большой вектор,
[01:08:19.240 --> 01:08:36.400]  и посортирую. Еще есть такая удобная функция c++, это unique. После того, как мы все посортировали,
[01:08:36.400 --> 01:08:52.160]  если написать такую строчку sorted.precise.unique.sorted.begin.sorted.end.
[01:08:52.160 --> 01:09:08.560]  минус sorted.begin, то у вас из массива удалятся дубликаты. То есть мы понимаем, что какие-то
[01:09:08.560 --> 01:09:14.160]  там x могут быть равны каким-то другим, x равны быть каким-то l. Здесь могут быть равные числа,
[01:09:14.160 --> 01:09:20.560]  чтобы от них избавиться мы вот так вот проявляем, запустим функцию unique, которая все равные числа
[01:09:20.560 --> 01:09:26.840]  вам. По сути для нас просто их удалит, удалит все повторы. Вот такая строчка удалит все повторы из
[01:09:26.840 --> 01:09:34.240]  массива. А дальше смотрите, у вас есть список всех интересных позиций. Тогда давайте мы построим
[01:09:34.240 --> 01:09:39.280]  дерево отрезков вот на этих вот позициях. То есть я знаю что-то, не знаю, ну пусть sorted,
[01:09:39.280 --> 01:09:49.840]  после этого всего sorted. Это какой-нибудь там массив 3, 4, 10, 15, 17, 22. Тогда давайте просто
[01:09:49.840 --> 01:09:56.840]  построим дерево отрезков на вот этом вот массиве из шести элементов в данном случае и будем с ним
[01:09:56.840 --> 01:10:00.280]  работать как с обычным деревом отрезков. Не как с динамическим, а как с обычным деревом отрезков.
[01:10:00.280 --> 01:10:06.600]  И тогда у меня будет, ну во-первых, прелесть, что это обычное DO, а не динамическое. То есть обычно мы уже
[01:10:06.600 --> 01:10:13.640]  умеем писать. То есть динамическое конечно не сильно сложнее, но обычное DO, ну как минимум быстрее,
[01:10:13.640 --> 01:10:23.480]  потому что там меньше число под логарифмом. Там было 10, 18, здесь откуп по сути, от числа запроса.
[01:10:23.480 --> 01:10:34.400]  Сейчас отвечу на вопрос чатча. Мы построили дерево отрезков на этом запросе, и мы можем отвечать
[01:10:34.400 --> 01:10:39.280]  как бы на вот этом массиве, можем отвечать на все запросы. Потому что когда приходит запрос
[01:10:39.280 --> 01:10:44.600]  обновить число в позиции 10, мы находим где-то число 10 находится в нашем массиве сорта бин поиском,
[01:10:44.600 --> 01:10:52.040]  и говорим, что вот здесь в DO надо сделать плюс дельта. Когда приходит запрос суммы,
[01:10:52.040 --> 01:10:57.960]  там на отрезке 4.17, я понимаю, что вот 4, вот 17, опять двумя бин поисками нахожу эти два
[01:10:57.960 --> 01:11:02.720]  числа в мою массиве, понимаю на каком отрезке нужно найти сумму, и там нахожу сумму в обычном
[01:11:02.720 --> 01:11:07.720]  дереве отрезков. И как раз прелесть в том, что я выкинул те числа, к которым заведомо не будет
[01:11:07.720 --> 01:11:15.200]  запрос. И в итоге мне достаточно обычного дерева отрезков. Достаточно обычного дерева отрезков.
[01:11:15.200 --> 01:11:20.960]  Без всякого динамического, без этих указателей, большого, не явного большого массива данных,
[01:11:20.960 --> 01:11:28.200]  мне достаточно будет DO на массиве сорта. Вот такое преимущество по сравнению с подходом онлайн.
[01:11:28.200 --> 01:11:33.560]  Если все в оффлайне, если я знаю все запросы заранее, то можно это сделать все быстрее.
[01:11:33.560 --> 01:11:41.160]  Так, вопрос про еник. Как он работает? Удаляет повторяющиеся элементы только из ассортированного
[01:11:41.160 --> 01:11:47.440]  или можно с произвольным? Чтобы он делал то, что нужно, нужно сначала ассортировать. Потому что
[01:11:47.440 --> 01:11:53.920]  еник, он проходится, и если видит несколько подряд равных, то, грубо говоря, удаляет вот как бы
[01:11:53.920 --> 01:11:58.960]  блок равных, оставляя из него только одно. Если у вас, например, будет там, не знаю, 3 единицы,
[01:11:58.960 --> 01:12:04.360]  2-ка, 3 единицы, тогда он удалит вот эти 2 единицы, вот эти 2 единицы, но не поймет, что вот эти 2 единицы
[01:12:04.360 --> 01:12:09.360]  одинаковые. И оставит вам и то, и то. А мы хотим как раз, чтобы каждое число встречалось ровно один
[01:12:09.360 --> 01:12:16.080]  раз из тех, которые есть. Поэтому нам нужно его сначала ссортировать, сгруппировать блоки равных,
[01:12:16.080 --> 01:12:22.960]  и потом удалять. Еник работает за ОАТН, потому что это просто проход по массиву. Ну то есть,
[01:12:22.960 --> 01:12:27.440]  раз у меня все ассортировано, у меня сначала идет блок единиц, потом двое, потом тройка,
[01:12:27.440 --> 01:12:32.160]  и так далее. Он просто идет по блокам, видит единицу, ее сохраняет, остальные удаляет. Ну там не то,
[01:12:32.160 --> 01:12:39.920]  что удаляет, а перемещает их как бы в конец массива. Вот. Короче, за ОАТН. Просто нам нужно из каждого
[01:12:39.920 --> 01:12:48.560]  блока оставить по одному числу, это работает, понятно, за любым. Вот, вторая иллюстрация. Это, давайте
[01:12:48.560 --> 01:12:57.120]  мы обсудим кратко дерево поиска. Дерево поиска онлайн. Мы скоро к нему перейдем, видимо, через
[01:12:57.120 --> 01:13:04.400]  лекцию, не на следующую, а через одну. Дерево поиска оффлайн. Дерево поиска, мы еще будем подробно
[01:13:04.400 --> 01:13:09.160]  про это говорить, но дерево поиска это такая структура, которая умеет отвечать на запросы,
[01:13:09.160 --> 01:13:20.200]  скажем, трех типов. Она как-то поддерживает множество S. Со следующими операциями insertX,
[01:13:20.200 --> 01:13:46.720]  то есть добавить XS. EraseX. Удалить XSS. И третье findX. FindX. Сообщить, есть ли XS. Вопрос в чате
[01:13:46.720 --> 01:13:54.960]  set или multi-set, неважно. Давайте считаем, что set без повторяющихся элементов. Без повторяющихся.
[01:13:54.960 --> 01:14:04.480]  Давай считаем, что запросы такие, что не бывает двух подряд insert одного и того же числа. Вот,
[01:14:04.480 --> 01:14:09.760]  то есть мы почти что умеем это делать с помощью кучи на самом деле, потому что куча умеет делать
[01:14:09.760 --> 01:14:15.920]  insert и умеет делать erase. Вот это наша хитрая реализация про хранить кучу удаленных элементов.
[01:14:15.920 --> 01:14:21.320]  Но, к сожалению, она не умеет делать find, потому что find в куче, чтобы найти какой-то элемент в куче,
[01:14:21.320 --> 01:14:29.960]  нужно ее всю пройти. Никак по-другому это сделать нельзя. Эффективно. Мы чуть позже будем изучать
[01:14:29.960 --> 01:14:33.920]  разные подходы к тому, как это можно сделать. Там куча-куча всяких разных реализаций есть,
[01:14:33.920 --> 01:14:39.520]  как вот у кучи есть двоичная, биномиальная, фибоначчо и много-много других. Также у дерева
[01:14:39.520 --> 01:14:44.520]  поиска есть, наверняка знакомый многим из вас, дерево декартовое дерево, которое все это умеет
[01:14:44.520 --> 01:14:50.240]  делать. Ну и плюс также мы посмотрим на кучу всяких других. АВЛ дерево, red-black дерево,
[01:14:50.240 --> 01:14:56.560]  красно-красно-черное, которое лежит в основе того, что как раз set в C++. Ну и там еще какие-нибудь
[01:14:56.560 --> 01:15:01.960]  другие. Посмотрим тоже интересно. Так вот, теперь представьте, что вам все эти запросы
[01:15:01.960 --> 01:15:09.000]  известны заранее. Вам известно заранее, что придет такой-то запрос insertX, потом findY,
[01:15:09.000 --> 01:15:16.200]  потом erase что-то, insert еще что-то и так далее. Вы все знаете. Как всегда в оффлайне все запросы
[01:15:16.200 --> 01:15:25.800]  известны заранее. Тогда нам не нужно никакого декартового дерева, нам не нужно никакого дерева
[01:15:25.800 --> 01:15:30.880]  поиска, потому что если мне все известно, то давайте сделаем практически то же самое,
[01:15:30.880 --> 01:15:37.000]  что было выше. Давайте мы зафиксируем себе, про какие в принципе элементы приходят запросы,
[01:15:37.000 --> 01:15:43.760]  insert, erase и find. Сохраним какой-то вектор, посортируем, проявляем и будем хранить,
[01:15:43.760 --> 01:15:51.800]  извините, массив просто, булевских флагов есть это число или нет. Запрос известны заранее. Мы
[01:15:51.800 --> 01:16:03.800]  считаем все интересные назначения, все интересующие назначения, посортируем,
[01:16:03.800 --> 01:16:14.200]  проюникаем, то есть удалим дубликаты, потому что если приходит insertX, потом findX,
[01:16:14.200 --> 01:16:18.640]  то X будет два раза, мы хотим, чтобы каждое число было по одному разу. И теперь у меня в массиве
[01:16:18.640 --> 01:16:23.680]  sorted будет информация о тех числах, которые в принципе когда-либо приходят, ну придут в запрос.
[01:16:23.680 --> 01:16:32.800]  Пусть это там, не знаю, опять 3, 4, 8, 15, 20. Тогда давайте мы будем хранить 5 булевских значений,
[01:16:32.800 --> 01:16:41.400]  true, false, 0, 1, true, false, true, false, true, false. И если приходит insert, не знаю, insert 15,
[01:16:41.400 --> 01:16:46.840]  то мне нужно это 15 найти в этом массиве, bin поиском, нахожу 15 и говорю, что здесь единица,
[01:16:46.840 --> 01:16:56.960]  то есть я это число добавляю в моё множество. Приходит erase 8, нашёл эту 8 bin поиском, сказал,
[01:16:56.960 --> 01:17:02.440]  что мы её удаляем, теперь она не хранится в массиве. Приходит find, я опять нахожу bin поиском,
[01:17:02.440 --> 01:17:08.520]  и просто то число, которое, ну там true или false, если true, то значит число есть, если false,
[01:17:08.520 --> 01:17:13.880]  то значит числа нет. Ещё раз find, это просто bin поиск, и просмотр, true или false, если true,
[01:17:13.880 --> 01:17:21.880]  то число есть, если false, то числа нет. Получается, что какая-то симптотика, ну тут сортировка,
[01:17:21.880 --> 01:17:31.040]  если всего к у запросов, то всё это обрабатывается за кулак ку, потому что сортировка ку чисел в
[01:17:31.040 --> 01:17:37.800]  худшем случае, а потом на каждый запрос мне нужно один bin поиск и одно изменение булевского
[01:17:37.800 --> 01:17:44.880]  значения, true or false, или просто просмотр его. Получается обработка всего за кулак ку, повторюсь,
[01:17:44.880 --> 01:17:52.560]  если все запросы известны заранее, и по сути нам не нужно никакого декартового дерева, если всё
[01:17:52.560 --> 01:17:58.440]  известно заранее, но, к сожалению, это далеко не всегда так, и поэтому приходится всё-таки
[01:17:58.440 --> 01:18:04.640]  отвечать в онлайне, то есть не знать, какие числа будут дальше, и при этом всё равно примерно за
[01:18:04.640 --> 01:18:09.800]  столько отвечать на все запросы, всё равно примерно в среднем залог ку на запрос хочется отвечать.
[01:18:09.800 --> 01:18:23.320]  вот и третье, давайте мы закончим тем же, что в прошлый раз, и тем с чего начали, это количество
[01:18:23.320 --> 01:18:38.120]  чисел на отрезке больше равных чем x, опять есть неизменный массив статический, приходится
[01:18:38.120 --> 01:18:43.680]  просто с тремя параметрами lrx, мне нужно отрезкой lr сообщить количество чисел,
[01:18:43.680 --> 01:18:57.040]  которые больше равных чем x, давайте считать все запросы известны заранее, тогда давайте мы их
[01:18:57.040 --> 01:19:09.000]  все отсортируем в порядке убывания x, отсортируем запросы, в порядке убывания x,
[01:19:14.560 --> 01:19:22.280]  а дальше воспользуемся той же самой идеей, которая была в персистентном дереве отрезков, только
[01:19:22.280 --> 01:19:26.800]  теперь мне уже не нужна будет персистентность, потому что, если я иду по запросам в порядке
[01:19:26.800 --> 01:19:31.760]  убывания x, что это значит? это означает, что как бы изначально все элементы мёртвые, а дальше они
[01:19:31.760 --> 01:19:37.080]  постепенно оживают, и мне нужна только текущая версия дерева, то есть вот, не знаю, там какой-нибудь
[01:19:37.080 --> 01:19:42.840]  x пришёл, я оживил все элементы, которые больше равны чем x, и ответил на запрос, это просто число
[01:19:42.880 --> 01:19:48.040]  живых на отрезке, потом у меня x уменьшился, пришёл запрос с меньшим x, значит мне нужно несколько
[01:19:48.040 --> 01:19:53.480]  элементов оживить, и потом опять сумма на отрезке, то есть число живых на отрезке, то есть это как
[01:19:53.480 --> 01:20:01.480]  будто бы персистентный дерево отрезков, только мне не нужно иметь доступ к любому дереву, у меня
[01:20:01.480 --> 01:20:05.640]  вот этот вот запрос к дереву, он будет как бы сдвигаться в порядке убывания x, а мне не нужно
[01:20:05.640 --> 01:20:12.880]  тыкать в разные-разные места, у меня будут просто, ну вот эти запросы к разным деревьям,
[01:20:12.880 --> 01:20:18.000]  они будут такие последовательные в порядке убывания x, а то есть в порядке процессинга,
[01:20:18.000 --> 01:20:25.760]  обработки всех чисел в порядке убывания. давайте напишем, что храним одно дерево отрезков,
[01:20:25.760 --> 01:20:34.400]  не персистентное, обычное, одно обычное до, в каждой вершине храним число живых под деревом,
[01:20:34.400 --> 01:20:48.800]  число живых под деревом, тогда если я скажем ответил на запрос там, не знаю, l,
[01:20:49.800 --> 01:20:59.840]  l' x', на его мы допустим ответили, приходится следующий запрос l2' r2' x2' , где x2' меньше
[01:20:59.840 --> 01:21:06.360]  чем x', я же их посортил, теперь у меня как бы приходит запрос с меньшим x, ну тогда мне
[01:21:06.360 --> 01:21:14.320]  нужно просто пройтись по всем числам от x' до x2', то есть все числа, которые оживают в отрезке
[01:21:14.320 --> 01:21:19.960]  между этими запросами, в промежутке между этими запросами, все их оживить и теперь делать запрос
[01:21:19.960 --> 01:21:34.240]  на новом отрезке l2' r2' оживляем числа, принадлежащая отрезку от x2' до x' невключительно,
[01:21:34.240 --> 01:21:40.120]  все их оживляем, то есть у меня еще отдельно ассортированы все элементы исходного массива,
[01:21:40.120 --> 01:21:44.440]  так же как было у меня в персидентном подходе, я сначала ссорчиваюсь массив исходный, иду в
[01:21:44.440 --> 01:21:51.240]  порядке убывания и то есть по сути я иду в как бы параллельно в порядке убывания по моему
[01:21:51.240 --> 01:21:58.120]  массиву ссортит исходному, по моему массиву статической, которая в порядке убывания значений,
[01:21:58.120 --> 01:22:03.320]  а также иду параллельно по запросам, в порядке убывания x' запроса, если у меня скажем вот здесь
[01:22:03.320 --> 01:22:08.200]  нашелся какой-то одинаковый x, тогда у меня живые, выменьшаются все вот эти вот элементы,
[01:22:08.200 --> 01:22:13.680]  соответственно тогда мне просто нужно сумма顆ить живых отрезок, потом приходится следующий запрос x,
[01:22:13.680 --> 01:22:21.840]  х' x2', тогда мне нужно продвинуть вот этот указатель вниз, оживить несколько элементов и потом сделать
[01:22:21.840 --> 01:22:26.900]  запрос на отрезки, и каждый раз когда у меня вот этот x все уменьшается, усиливается, мне нужно оживить
[01:22:26.900 --> 01:22:34.160]  несколько элементов и сделать запрос на отрезки, и именно из-за того что у меня x вот эти вот линейно
[01:22:34.160 --> 01:22:39.000]  убывают подряд, всё меньше и меньше и меньше. Это значит, что мне не нужно персистентное ДО,
[01:22:39.000 --> 01:22:46.080]  мне нужна его последняя версия, нужна последняя версия, в которой всё оживают и оживают новые
[01:22:46.080 --> 01:22:58.800]  элементы, мне нужна всегда только одна версия без всей истории. Нужна только одна версия ДО.
[01:22:58.800 --> 01:23:08.680]  Ну вот тоже такое упрощение подхода, который был выше, про персистентное дерево отрезка. То есть,
[01:23:08.680 --> 01:23:12.560]  по сути, мы отказались от персистентности, заодно, кстати, сэкономили память, потому что
[01:23:12.560 --> 01:23:16.720]  персистентное ДО требовало от нас N log N памяти, потому что у нас N обновлений,
[01:23:16.720 --> 01:23:23.200]  и каждое обновление алгоритм занимало. Заодно память уменьшили, заодно уменьшили память.
[01:23:23.200 --> 01:23:29.360]  А время стало точно не хуже. Кула куразов, чтобы её, чтобы все запросы поспортировать.
[01:23:29.360 --> 01:23:38.360]  Ну короче, всё это точно не хуже, чем онлайн подход с персистентным ДО, потому что здесь всё,
[01:23:38.360 --> 01:23:42.880]  ну короче, просто более простая структура. ДО явно более простая, чем персистентный ДО.
[01:23:42.880 --> 01:23:49.080]  Так, ну всё, спасибо. Если нет вопросов, то тогда до свидания, до следующего раза.
[01:23:49.080 --> 01:23:59.040]  Маленький вопрос. Значит, вот мы, когда у нас приходит очередной запрос, мы оживляем элементы
[01:23:59.040 --> 01:24:08.400]  от, ну, допустим, x' до x'2. А как это, собственно, в дереве это происходит? Ну, то есть, вот...
[01:24:08.400 --> 01:24:14.000]  Ну, смотрите, вот сюда, сюда смотрите. Есть у меня, я изначально посортировал массив sortit.
[01:24:14.000 --> 01:24:19.040]  Исходный массив отсортировал, он теперь хранится в sortit. Там все элементы в порядке убывания.
[01:24:19.040 --> 01:24:27.160]  Соответственно, если у меня, если мне нужно оживить все числа от x' до x'2, я понимаю, где они.
[01:24:27.160 --> 01:24:31.240]  Это вот такой отрезок, мне нужно просто вот, я понимаю, какие числа нужно оживить. Ну,
[01:24:31.240 --> 01:24:42.800]  а оживление числа, это просто там, ну, плюс один в ДОшке. Я понял, но если мы все эти числа оживляем,
[01:24:42.800 --> 01:24:52.920]  то у нас получается время работы вот этого запроса, оно будет там x'-x2' умножить там на налог.
[01:24:52.920 --> 01:24:59.040]  Ну, да, количество чисел вот здесь умножить на алгорифм, да. Но еще раз, смотрите, если мне все
[01:24:59.040 --> 01:25:05.720]  запросы известны заранее, то есть, я все равно их сначала все считаю, считываю и на все отвечаю,
[01:25:05.720 --> 01:25:10.880]  да, то есть, якобы, трачу время на то, чтобы ответить на все. И вот эту всю сумму я считаю
[01:25:10.880 --> 01:25:14.320]  временем работы, то есть, каждый конкретный запрос добра в этот задолб, потому что мне нужно
[01:25:14.320 --> 01:25:19.480]  сначала считать все остальные. И, ну, как бы, я отвечаю на все, то есть, я считаю сумму только
[01:25:19.480 --> 01:25:25.720]  на все запросы сразу. Вот поэтому, сколько трачу времени на каждый конкретный, это даже, даже
[01:25:25.720 --> 01:25:30.960]  некорректно спрашивает, потому что, ну, мы сначала нужно все остальные прочитать. Так,
[01:25:30.960 --> 01:25:36.720]  еще вопросы в чате. То есть, мы сохраняем ответ на каждый запрос, запросы, запросы. Да, ну, конечно,
[01:25:36.720 --> 01:25:42.000]  то есть, ну, здесь нужно, там, чуть формальнее, если писать, то мне нужно для каждой тройки lrx,
[01:25:42.000 --> 01:25:47.360]  еще запоминать, какой-то номер запроса был, да, то есть, мне нужно сортировать четверки lrx,
[01:25:47.360 --> 01:25:52.400]  запятая i, да, там, номер запроса. И дальше я их все посортил, и когда смог ответить на какой-то
[01:25:52.400 --> 01:25:59.040]  i-й запрос, мне нужно запомнить, ага, на i-й запрос такой-то ответ. Куда-то это себе записываю в массив,
[01:25:59.040 --> 01:26:03.320]  да, и потом, когда я на все запросы ответил, после этого мне нужно вывести этот массив. То есть,
[01:26:03.320 --> 01:26:10.160]  я сначала записал все ответы, потом в должном проекте вывел. Так, может быть, в оффлайн-подходе
[01:26:10.160 --> 01:26:24.720]  другая симпатика отличная от онлайна. Ну, конечно, может. Пример сходу не назову, но вот,
[01:26:24.720 --> 01:26:29.160]  вот что может быть. Точно может быть что-то в стиле, если у вас онлайн-лог-квадратный запрос,
[01:26:29.160 --> 01:26:36.160]  то оффлайн, возможно, можно за логарифм. Вот. Пример, к сожалению, да, сейчас сходу не назову,
[01:26:36.160 --> 01:26:48.760]  но, типа, уменьшение степени логарифма вполне бывает. Ну, все тогда спасибо за внимание,
[01:26:48.760 --> 01:26:53.680]  до свидания. Запись я скину и надеюсь, что это тоже на youtube залетит.
