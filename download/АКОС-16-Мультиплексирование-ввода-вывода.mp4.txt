[00:00.000 --> 00:14.280]  так тема сегодняшней лекции это продолжение с сукитами но в данном случае не только с сукитами
[00:14.280 --> 00:23.880]  еще и с вводом-выводом давайте вспомним что такое сокет и просьба выключить микрофон если вы не
[00:23.880 --> 00:32.880]  говорите что такое сукит это по сути некоторые файлы дескриптор файлы дескриптор это целое число
[00:32.880 --> 00:41.520]  которое однозначно идентифицирует некоторые объекты ввода-вывода и с ним можно вытворять все что может
[00:41.520 --> 00:49.980]  делаться обычными файлами дескриптора как мы получаем такие файлы дескрипторы и так можно
[00:49.980 --> 00:53.860]  обработать ситуацию когда у нас получаются такие дескрипторы
[00:53.880 --> 01:02.560]  вот рассмотрим обычный сервер который делает что-то очень полезное серверы бывают разные
[01:02.560 --> 01:13.400]  например веб-сервер или это может быть ssh-сервер телнедсервер куча разных полезных применений что
[01:13.400 --> 01:19.880]  должен делать сервер он должен создать сокет затем этот сокет связать с каким-то именем что
[01:19.880 --> 01:23.720]  такое имя сокета это либо пара
[01:23.880 --> 01:32.700]  двух чисел ip-адрес плюс номер порта либо просто какое-то локальное имя файловой системы если это
[01:32.700 --> 01:40.240]  unix-сокет затем если мы сокет планируем не подключать к кому-то а сами принимать подключение
[01:40.240 --> 01:45.820]  то нужно переключить режим прослушивания создать очередь на входящие подключения после чего брать
[01:45.820 --> 01:53.720]  по одному соединению и уже дальше использовать стимулированный read-write для того чтобы общаться
[01:53.880 --> 02:00.640]  это все хорошо когда у вас клиент один что если клиентов много здесь возникает проблема что у нас
[02:00.640 --> 02:08.100]  есть какие-то блокирующие операции в нашей программе а именно сетевый вызов и read-write как они себя ведут
[02:08.100 --> 02:15.900]  они пытаются что-то прочитать пока данные есть а сетевый вызов и read-write пытаются записывать пока есть место в буфере
[02:15.900 --> 02:23.240]  когда вы взаимодействуете ровно с одним клиентом то все хорошо и замечательно
[02:23.880 --> 02:30.360]  если клиентов несколько какая проблема возникает вы начали работать с одним клиентом все остальные
[02:30.360 --> 02:37.700]  клиенты что нужно делать наверное мы должны подождать что не очень хорошо какой же это сервер если он
[02:37.700 --> 02:46.060]  работает только один на один хотя должен работать со мной какие тут варианты решения этой проблемы но самое простое
[02:46.060 --> 02:53.500]  очевидно из того что вы уже знаете уже умеете это сделать форк после того как примите очередное подключение
[02:53.880 --> 03:02.520]  почему форк будет работать потому что при создании копии процесса у нас некоторые атрибуты процесса
[03:02.520 --> 03:11.740]  не следуют в начальном процессе в том числе открытые файловые дескрипты если вы принимаете подключение после этого
[03:11.740 --> 03:19.980]  делаете форк то родительский процесс может смело принимать следующие подключения от новых клиентов
[03:19.980 --> 03:23.660]  а дочерний процесс уже взаимодействует непосредственно с новым клиентом
[03:23.880 --> 03:32.020]  с тем клиентом ради которого он будет создан на самом деле это очень распространенная практика многие серверы так и работают
[03:32.020 --> 03:41.720]  это достаточно надежный механизм потому что если дальше в процессе работы с каким-то отдельным клиентом
[03:41.720 --> 03:48.500]  у вас возникнет какие-то проблемы которые могут привести всяким нехорошим последствиям вот до сегментешен флот
[03:48.500 --> 03:51.920]  то других клиентов вы просто не заметите
[03:51.920 --> 03:53.420]  вы
[03:53.880 --> 03:58.180]  В каждом процессе общайтесь с отдельным клиентом, между
[03:58.180 --> 04:04.760]  собой процессы никак явным образом не связаны, и клиенты
[04:04.760 --> 04:07.760]  не мешают друг другу, есть полное изоляция.
[04:07.760 --> 04:11.980]  Но здесь, если все-таки логика подразумевает, что
[04:11.980 --> 04:16.120]  вы должны как-то организовать взаимодействие ваших клиентов,
[04:16.120 --> 04:18.760]  то простым способом это не сделать, тут приходится
[04:18.760 --> 04:21.840]  уже придумывать всякие обходные пути и межпроцессное
[04:21.840 --> 04:22.840]  взаимодействие.
[04:22.840 --> 04:29.260]  Так, в принципе, как избавиться от проблемы межпроцессного
[04:29.260 --> 04:31.560]  взаимодействия, которые возникают при работе с
[04:31.560 --> 04:33.560]  несколькими клиентами.
[04:33.560 --> 04:37.020]  Кроме процессов есть еще такое понятие как бесконечные
[04:37.020 --> 04:38.020]  процессы.
[04:38.020 --> 04:40.660]  Их еще называют треды, их еще называют нити.
[04:40.660 --> 04:44.940]  Так, у вас еще идет параллельно курс теории, практики англопоточной
[04:44.940 --> 04:45.940]  синхронизации.
[04:45.940 --> 04:50.780]  В этом уже успели изучить такое понятие, как потом
[04:50.780 --> 04:51.780]  знать что-то.
[04:51.780 --> 04:52.780]  То есть, в рамках одного процесса, если вы понимаете,
[04:52.780 --> 04:55.840]  что вы можете создавать несколько потоков, и в принципе
[04:55.840 --> 04:59.500]  все клиенты, вы все клиенты можете обрабатывать в отдельных
[04:59.500 --> 05:00.500]  потоках.
[05:00.500 --> 05:05.500]  Здесь решаются проблемы межпроцессного взаимодействия,
[05:05.500 --> 05:06.500]  которые не нужны.
[05:06.500 --> 05:09.880]  Так, добавился много других проблем, многопоточная
[05:09.880 --> 05:10.880]  синхронизация.
[05:10.880 --> 05:16.040]  Но это иногда решать проще и комфортнее, по части
[05:16.040 --> 05:17.040]  оплаты в частности.
[05:17.040 --> 05:22.200]  Но опять же здесь не решается основная проблема с большим
[05:22.200 --> 05:25.960]  количеством подключений, то, что у вас на каждое подключение
[05:25.960 --> 05:29.920]  должна быть одна задача, то есть когда звучит поток,
[05:29.920 --> 05:31.920]  и чем же это плохо?
[05:31.920 --> 05:33.920]  Плохо это тем, что это тяжело.
[05:33.920 --> 05:38.120]  Что процесс, что поток, они достаточно тяжелые сущности.
[05:38.120 --> 05:43.920]  Ну, кстати, по поводу того, как это все реализовано,
[05:43.920 --> 05:48.920]  вот такая схема классического, как сейчас на данном слайде,
[05:48.920 --> 05:51.120]  это обычный веб-сервер под названием патч.
[05:51.120 --> 05:52.120]  Схема его работает.
[05:52.120 --> 05:57.840]  То есть чем плохи процессы и потоки, в общем-то, тоже.
[05:57.840 --> 06:03.040]  То, что при создании процесса или потока вам требуется
[06:03.040 --> 06:06.020]  создать новую сущность планировщика заданий, это
[06:06.020 --> 06:09.800]  подразумевает как создание новой сущности планировщика
[06:09.800 --> 06:14.100]  заданий, так и выделение памяти, поскольку как минимум
[06:14.100 --> 06:18.800]  у каждого потока, тем более у процесса, есть выделенная
[06:18.800 --> 06:20.880]  область памяти, которая называется степ.
[06:20.880 --> 06:21.880]  Вот.
[06:22.120 --> 06:25.840]  По умолчанию в большинстве линук-систем размер стека
[06:25.840 --> 06:26.840]  – это 8 мегабайт.
[06:26.840 --> 06:31.400]  Можно, конечно, сделать поменьше, для процессов
[06:31.400 --> 06:35.000]  настраиваться через Ulimit, для потоков это тоже можно
[06:35.000 --> 06:40.160]  настроить и сделать это сильно меньше, но, тем не
[06:40.160 --> 06:44.640]  менее, если у вас количество клиентов – это десятки,
[06:44.640 --> 06:49.120]  то такой подход, он вполне себе приемлем, если у вас
[06:49.120 --> 06:50.120]  количество клиентов уже исчисляется тысячами, то,
[06:50.120 --> 06:51.120]  например, у вас будет много клиентов, то, конечно,
[06:51.120 --> 06:56.680]  есть из них тысячи, то это становится очень дорого.
[06:56.680 --> 07:03.220]  Ну и как можно эту проблему решить?
[07:03.220 --> 07:09.580]  Вот, я как-то уже упоминал, что файлодескрипторы могут
[07:09.580 --> 07:10.580]  быть неблокирующими.
[07:10.580 --> 07:12.820]  Ведь основная проблема в чем?
[07:12.820 --> 07:18.280]  У нас есть две стадии, которые тормозят взаимодействие
[07:18.280 --> 07:20.240]  с другими клиентами.
[07:20.240 --> 07:41.460]  В первых системах вызова read и write, во-вторых, есть у нас еще система вызов accept. Read и write у нас блокируются, если нет данных от клиента, то есть вы работаете с медленным клиентом, например. А accept у вас будет блокировать всю цифровую выполнение в том случае, если у вас не поступает наук подключения.
[07:41.460 --> 07:52.500]  Вот если все это сделать не блокирующим, то, казалось бы, мы можем эту проблему решить. И как эта проблема может быть решена?
[07:52.920 --> 08:11.180]  Есть такой замечательный заговорочный файл из некоторых нечитабельных букв, потому что в том названии только согласный, не одногласный, FCNTL. Название очень страшное, эрудимент еще в 70-е годы, когда экономили каждый символ.
[08:11.460 --> 08:27.120]  Файл control, это просто такое сокращение. И там есть одноименный степный вызов. На самом деле, этот заговорочный файл вы видели достаточно часто, когда открывали файлы. Собственно, степный вызов open, он там же и объявлен.
[08:28.700 --> 08:41.400]  Вообще, работа с файловыми дескрипторами, это не только открытие файла, его закрытие, но и изменение каких-то параметров. В частности, что вы можете сделать с файловыми дескрипторами? Вы можете создать его клуб.
[08:41.460 --> 09:10.660]  С помощью системы вызова DAT или DAT2. Вы можете установить блокировку на файл с помощью системы вызова FLOG. И хотя есть отдельный системный вызов, который это делает, просто по соображениям совместимости, многое из этого можно реализовать как библиотечное высказывание функций поверх всего лишь одного системного вызова файл control, который просто берет некоторый творческий аргумент файловый дескриптор, какую-то команду, что нужно сделать.
[09:11.460 --> 09:28.300]  В частности, файл control нам может быть полезен для того, чтобы узнать флаги открытия файла и, возможно, установить какие-то новые.
[09:28.300 --> 09:36.600]  Но какие вы помните флаги? Флаг только для чтения, флаг только для записи.
[09:36.600 --> 09:41.400]  Опять же, в Unix API есть одна особенность, что комбинация флагов.
[09:41.460 --> 09:46.460]  Чтение и запись вовсе не дают флаг чтения плюс запись, и это есть отдельный флаг.
[09:46.460 --> 09:52.460]  Зато можно делать комбинацию флагов, например, что запись в конец, либо создание файла.
[09:52.460 --> 10:01.460]  И если вы внимательно посмотрите огромный список флагов, которые есть, например, в системе вызовы open, там есть флаг, который называется null.
[10:01.460 --> 10:05.460]  Который нам сейчас будет интересен.
[10:05.460 --> 10:07.460]  Что этот флаг означает?
[10:07.460 --> 10:11.460]  Означает, что вы можете какой-то файл-дескриптор сделать у меня.
[10:11.460 --> 10:22.460]  Не блокирующий, то есть при отсутствии данных у вас все равно будет возможно выполнение операции чтения, которое не будет останавливать процесс.
[10:22.460 --> 10:34.460]  Но если вы файл не открываете, а уже имеете какой-то готовый файл-дескриптор, откуда этот файл-дескриптор может нам прилететь?
[10:34.460 --> 10:41.460]  Например, вы выполняете систему вызов accept и уже получаете готовый созданный файл-дескриптор.
[10:41.460 --> 10:52.460]  В данном случае нам может быть полезен систему вызов file-control, которая может модифицировать существующие флаги открытия файлового дискриптора.
[10:52.460 --> 11:01.460]  И какие проблемы можно решать установкой флага null?
[11:01.460 --> 11:09.460]  Во-первых, мы можем решать проблему с блокирующим выводом.
[11:09.460 --> 11:10.460]  То есть так у нас работает файл-дескриптор.
[11:11.460 --> 11:14.460]  Он работает системой вызов write и любая запись файла.
[11:14.460 --> 11:29.460]  Если вы пишете куда-то в локальный файл либо файл устройства, то ядро Linux старается использовать всю возможную доступную физическую память, которая никем не занята, под бухгализацию вывода.
[11:29.460 --> 11:34.460]  Тут, кстати, бывают иногда очень неожиданные побочные эффекты с ним связаны.
[11:34.460 --> 11:40.460]  Если вы себе ставили Linux на реальное железо,
[11:40.460 --> 11:41.460]  а на ядро Linux вы ставили Linux на реальное железо,
[11:41.460 --> 11:43.460]  не виртуальную машину,
[11:43.460 --> 11:48.460]  то наверняка вам нужно было сделать какую-то загрузочную флешку.
[11:48.460 --> 11:52.460]  Вы скачиваете образ вашего дискриптива,
[11:52.460 --> 11:58.460]  пишете команду dd, скопируете из одного файла файл устройства.
[11:58.460 --> 12:02.460]  У вас все достаточно быстро может быть скопировано.
[12:02.460 --> 12:08.460]  Но при этом флешка продолжает мигать, и вытаскивать ее из компьютера не нужно.
[12:08.460 --> 12:10.460]  Команда dd завершила свою работу.
[12:10.460 --> 12:15.460]  Сказала, что все, мы все скопировали, но на самом деле запись не произведена.
[12:15.460 --> 12:17.460]  Из-за чего такой эффект возникает?
[12:17.460 --> 12:23.460]  Такой эффект возникает из-за того, что запись произведена в локальный буфер.
[12:23.460 --> 12:27.460]  То есть программа dd, которая копирует содержимое файла,
[12:27.460 --> 12:33.460]  она честно завершила свою работу, честно выполнив системный вызов read и write.
[12:33.460 --> 12:37.460]  Дальше уже задача ядра операционной системы.
[12:37.460 --> 12:39.460]  Сбросить файл.
[12:39.460 --> 12:44.460]  Сбросить буфер, и после этого только считается, что запись завершена.
[12:44.460 --> 12:51.460]  Вот с файлами обычно проблема, что у вас закончился буфер для записи,
[12:51.460 --> 12:56.460]  она не возникает, и маловероятно, что вы навопнетесь на эту проблему
[12:56.460 --> 12:59.460]  используя системный вызов write.
[12:59.460 --> 13:02.460]  Но кроме файлов у нас еще бывают другие объекты.
[13:02.460 --> 13:04.460]  Во-первых, это пайпы.
[13:04.460 --> 13:07.460]  В Linux есть размер...
[13:09.460 --> 13:13.460]  Пайпа 64 килобайта.
[13:13.460 --> 13:17.460]  То есть если вас никто из пайпа не читает,
[13:17.460 --> 13:19.460]  а вы туда продолжаете писать,
[13:19.460 --> 13:22.460]  то в какой-то момент наталкиваемся на ситуацию,
[13:22.460 --> 13:27.460]  что запись невозможна, пока кто-нибудь из пайпа не прочитает.
[13:27.460 --> 13:32.460]  Та же самая проблема у нас связана с сокетами TCP.
[13:32.460 --> 13:36.460]  Но здесь достаточно гибкий размер буфера.
[13:36.460 --> 13:38.460]  Вот есть некоторый файлик,
[13:38.460 --> 13:41.460]  который вы можете прочитать с подобычного пользователя,
[13:41.460 --> 13:43.460]  который содержит три числа.
[13:43.460 --> 13:45.460]  Это размеры в байках.
[13:45.460 --> 13:48.460]  Минимально возможный размер TCP буфера,
[13:48.460 --> 13:51.460]  размер по умолчанию, который у вас сейчас используется,
[13:51.460 --> 13:54.460]  и максимальный размер, который вы можете настроить.
[13:54.460 --> 13:59.460]  Опять же вы можете значение дефолтное поменять до некоторого большего,
[13:59.460 --> 14:02.460]  но для этого вам уже потребуется проворота.
[14:02.460 --> 14:06.460]  Чаще проблема с блокировками,
[14:06.460 --> 14:11.460]  с блокировками она возникает не на записи, а на чтении.
[14:11.460 --> 14:16.460]  С файлами, опять же, маловероятно, что вы на эту проблему наткнетесь,
[14:16.460 --> 14:19.460]  но только если у вас не очень много листов.
[14:19.460 --> 14:23.460]  Системный мизофрит нам может что-то вернуть,
[14:23.460 --> 14:27.460]  в том случае, если он может прочитать хотя бы один байт
[14:27.460 --> 14:29.460]  из пайпа либо сокета.
[14:29.460 --> 14:31.460]  Но если у вас нет даже одного байта,
[14:31.460 --> 14:33.460]  байта в пайпе либо в сокете,
[14:33.460 --> 14:35.460]  то, опять же, чтение у вас блокируется,
[14:36.460 --> 14:38.460]  и процесс...
[14:38.460 --> 14:40.460]  Что происходит с процессом,
[14:40.460 --> 14:43.460]  когда он не может сделать чтение или запись?
[14:43.460 --> 14:46.460]  Кто помнит?
[14:46.460 --> 14:49.460]  В режим ожидания?
[14:49.460 --> 14:53.460]  Да. Процесс переходит в состояние, которое называется слип,
[14:53.460 --> 14:58.460]  то есть он не потребляет процессорное время,
[14:58.460 --> 15:00.460]  он не расходует ресурсы,
[15:00.460 --> 15:03.460]  его просто переводят в спящий режим до тех пор,
[15:03.460 --> 15:05.460]  пока процесс не сможет...
[15:06.460 --> 15:08.460]  какие-то данные прочитать.
[15:08.460 --> 15:13.460]  Так вот, если мы ставим вот наш замечательный флагман блок
[15:13.460 --> 15:15.460]  либо при открытии файла,
[15:15.460 --> 15:18.460]  либо после создания файлового дескриптора,
[15:18.460 --> 15:22.460]  то любые неуспешные попытки,
[15:22.460 --> 15:25.460]  неуспешные – это значит, что данных нет при чтении
[15:25.460 --> 15:28.460]  либо закончилось место в буфере при записи,
[15:28.460 --> 15:30.460]  не приведут к ситуации,
[15:30.460 --> 15:35.460]  когда процесс перейдет в состояние слип.
[15:35.460 --> 15:37.460]  Ну, еще бывает состояние диск слип,
[15:37.460 --> 15:40.460]  это именно файловый вот-вот.
[15:40.460 --> 15:47.460]  Кстати, кто помнит, чем отличается слип от диск слип?
[15:47.460 --> 15:49.460]  Напоминаю, что и слип вы можете сразу
[15:49.460 --> 15:51.460]  процесс перевести в состояние зоны,
[15:51.460 --> 15:52.460]  то есть в завершение.
[15:52.460 --> 15:54.460]  То есть диск слип сначала в состояние раннего,
[15:54.460 --> 15:55.460]  чтобы сбросить эфир,
[15:55.460 --> 15:58.460]  только после этого в слип.
[15:58.460 --> 16:01.460]  Так вот, если у нас есть флаг,
[16:01.460 --> 16:04.460]  который позволяет не блокироваться,
[16:04.460 --> 16:07.460]  то есть процесс у нас не будет переходить в состояние сна,
[16:07.460 --> 16:11.460]  если у нас нет никаких данных, например, при чтении,
[16:11.460 --> 16:15.460]  то стенозафрит вернет ошибку,
[16:15.460 --> 16:17.460]  которая на самом деле ошибкой не является.
[16:17.460 --> 16:20.460]  Ошибка – это значит значение минус один,
[16:20.460 --> 16:24.460]  и в переменную ярло будет прописан код ошибки.
[16:24.460 --> 16:28.460]  И есть отдельно выделенный код ошибки,
[16:28.460 --> 16:31.460]  который на самом деле ошибкой не является.
[16:31.460 --> 16:33.460]  На самом деле таких кодов два,
[16:34.460 --> 16:39.460]  если посмотреть, например,
[16:39.460 --> 16:51.460]  на системный вызов read.
[16:51.460 --> 16:53.460]  Так, системный вызов read.
[16:53.460 --> 16:57.460]  Вот eegl – это ошибка,
[16:57.460 --> 17:00.460]  значит, что файл у нас помечен как файл
[17:00.460 --> 17:03.460]  только для неблокирующего ввода-вывода,
[17:03.460 --> 17:05.460]  но данных нет.
[17:05.460 --> 17:08.460]  И есть еще одна ситуация,
[17:08.460 --> 17:13.460]  когда никакой ошибки нет,
[17:13.460 --> 17:16.460]  это просто к нам прилетел некоторый сигнал.
[17:16.460 --> 17:21.460]  eenter означает, что у нас пришел сигнал,
[17:21.460 --> 17:25.460]  и через segaction вы прописали поведение System5.
[17:25.460 --> 17:27.460]  Помните, что бывают разные поведения?
[17:27.460 --> 17:29.460]  PSD-стайл, System5-стайл.
[17:29.460 --> 17:32.460]  Так вот, в PSD-стиле по умолчанию
[17:32.460 --> 17:35.460]  подразумевается, что системные вызовы
[17:35.460 --> 17:37.460]  должны сами возобновлять свою работу
[17:37.460 --> 17:39.460]  после того, как им были прерваны сигналы.
[17:39.460 --> 17:41.460]  В System5 как раз нет.
[17:41.460 --> 17:43.460]  И в segaction есть flag sa-restart.
[17:43.460 --> 17:45.460]  Вот если вы его не указали,
[17:45.460 --> 17:48.460]  и во время какой-то длительной операции,
[17:48.460 --> 17:50.460]  например, ожидания ввода,
[17:50.460 --> 17:52.460]  вам прилетает сигнал,
[17:52.460 --> 17:56.460]  то системный вызов возвращает значение минус один
[17:56.460 --> 17:59.460]  и в ЯРНО прописывает как раз вот этот код,
[17:59.460 --> 18:01.460]  что он был прерван,
[18:01.460 --> 18:03.460]  с помощью сигнала.
[18:08.460 --> 18:12.460]  Так вот, здесь системные вызовы read-write
[18:12.460 --> 18:14.460]  могут вам честно возвращать минус один,
[18:14.460 --> 18:17.460]  вы можете не ждать, пока медленный клиент
[18:17.460 --> 18:20.460]  вам что-то напишет,
[18:20.460 --> 18:22.460]  а переходить сразу в взаимодействие
[18:22.460 --> 18:24.460]  с каким-то другим клиентом.
[18:24.460 --> 18:27.460]  Впоследствии вернуться еще раз к тому же клиенту,
[18:27.460 --> 18:28.460]  который нам ничего не ответил,
[18:28.460 --> 18:30.460]  который не подготовил данные,
[18:30.460 --> 18:33.460]  для того, чтобы попробовать еще раз
[18:33.460 --> 18:34.460]  у него что-то запросить,
[18:34.460 --> 18:36.460]  может быть, через какое-то время
[18:36.460 --> 18:38.460]  его данные и появятся.
[18:38.460 --> 18:41.460]  В случае для системного вызова accept
[18:41.460 --> 18:43.460]  тут примерно такая же аналогия,
[18:43.460 --> 18:45.460]  только здесь accept,
[18:45.460 --> 18:47.460]  если он является неблокирующим,
[18:47.460 --> 18:49.460]  то вернет значение минус один
[18:49.460 --> 18:52.460]  в том случае, когда у нас нет новых подключений,
[18:52.460 --> 18:55.460]  и эту ситуацию мы опять же можем обрабатывать так,
[18:55.460 --> 18:57.460]  чтобы заниматься кем-то в другом клиенте.
[18:57.460 --> 18:59.460]  То есть на самом деле взаимодействие
[18:59.460 --> 19:01.460]  с большим количеством клиентов
[19:01.460 --> 19:05.460]  мы можем организовать всего лишь в один поток.
[19:05.460 --> 19:07.460]  На самом деле в реальной жизни
[19:07.460 --> 19:09.460]  используется многопоточность,
[19:09.460 --> 19:14.460]  просто для того, чтобы распроверить задачу
[19:14.460 --> 19:20.460]  по обработке клиентов на несколько ядер процесса.
[19:20.460 --> 19:25.460]  Так, если мы просто будем пытаться
[19:25.460 --> 19:28.460]  выполнять неблокирующие операции,
[19:29.460 --> 19:33.460]  получая ошибку переходить к обработке других клиентов
[19:33.460 --> 19:37.460]  и затем возвращаться обратно к тем клиентам,
[19:37.460 --> 19:39.460]  с которыми у нас ничего не получилось,
[19:39.460 --> 19:43.460]  фактически мы превращаем нашу программу
[19:43.460 --> 19:45.460]  в бесконечный цикл while true,
[19:45.460 --> 19:48.460]  и чем это поможет?
[19:48.460 --> 19:51.460]  Плохо это тем, что если у вас даже нет
[19:51.460 --> 19:53.460]  никакой нагрузки реальной,
[19:53.460 --> 19:55.460]  то есть, например, никто к вам не подключился,
[19:55.460 --> 19:57.460]  клиентов много,
[19:57.460 --> 19:59.460]  или один клиент очень медленный,
[19:59.460 --> 20:01.460]  или несколько клиентов,
[20:01.460 --> 20:04.460]  и они достаточно медленные и не требуют внимания.
[20:04.460 --> 20:06.460]  Неважно, какая у вас нагрузка,
[20:06.460 --> 20:08.460]  за счет этого самого цикла while true,
[20:08.460 --> 20:10.460]  который фактически превращается
[20:10.460 --> 20:14.460]  в конструкцию безусловного джампа,
[20:14.460 --> 20:17.460]  у вас как минимум одно или другое процессор
[20:17.460 --> 20:20.460]  будет всегда болтаться впустую,
[20:20.460 --> 20:23.460]  что не очень хорошо.
[20:23.460 --> 20:25.460]  Как с этой проблемой можно бороться?
[20:25.460 --> 20:29.460]  Можно ставить какие-то периодически принудительные
[20:29.460 --> 20:32.460]  паузы на определенное количество миллисекунд,
[20:32.460 --> 20:36.460]  но это очень корявое, постыдное решение.
[20:36.460 --> 20:38.460]  Все понимают, что так делать нельзя.
[20:38.460 --> 20:40.460]  Чем это плохо?
[20:40.460 --> 20:44.460]  Тем, что тут требуется знать некоторую константу,
[20:44.460 --> 20:46.460]  а насколько именно вам нужно заснуть,
[20:46.460 --> 20:49.460]  для того, чтобы сильно не нагружать процессор.
[20:49.460 --> 20:52.460]  И эту константу вы в реальной жизни
[20:52.460 --> 20:54.460]  не сможете оценить никогда,
[20:54.460 --> 20:57.460]  потому что все зависит от того, какая у вас нагрузка.
[20:57.460 --> 20:58.460]  Окей, вы можете подобрать нам константу,
[20:58.460 --> 21:01.460]  если к вам никто не подключился,
[21:01.460 --> 21:02.460]  никто не готов,
[21:02.460 --> 21:05.460]  то раз в 100 миллисекунд
[21:05.460 --> 21:07.460]  делать паузу на 100 миллисекунд,
[21:07.460 --> 21:09.460]  после этого проверять заново.
[21:09.460 --> 21:11.460]  Но это хорошо будет работать,
[21:11.460 --> 21:13.460]  когда клиентов у вас немного.
[21:13.460 --> 21:16.460]  Да, все, казалось бы, хорошо работает,
[21:16.460 --> 21:18.460]  но как только клиентов становится много,
[21:18.460 --> 21:20.460]  то 100 миллисекунд может быть
[21:20.460 --> 21:23.460]  весьма существенной задержкой.
[21:23.460 --> 21:27.460]  Но у нас есть еще и до.
[21:27.460 --> 21:30.460]  И вообще говоря, ядро знает,
[21:30.460 --> 21:32.460]  кто к нам подключился по сети.
[21:32.460 --> 21:35.460]  Ядро знает, что мы прочитали
[21:35.460 --> 21:37.460]  какой-то кусок из файлов
[21:37.460 --> 21:40.460]  и можем это передать,
[21:40.460 --> 21:42.460]  пользоваться тем процессом,
[21:42.460 --> 21:45.460]  который занимается этими файловыми дескрипторами.
[21:45.460 --> 21:48.460]  Почему бы нам просто не использовать ядро
[21:48.460 --> 21:53.460]  и все его знания о файловых дескрипторах?
[21:53.460 --> 21:56.460]  Для этого существует механизм.
[21:56.460 --> 21:59.460]  Это нотификация со стороны ядра
[21:59.460 --> 22:02.460]  о каких-то событиях,
[22:02.460 --> 22:04.460]  связанных с файловыми дескрипторами.
[22:04.460 --> 22:06.460]  А как это работает?
[22:06.460 --> 22:09.460]  Пользовский процесс просто заявляет ядру о том,
[22:09.460 --> 22:12.460]  что он хочет знать обо всех событиях,
[22:12.460 --> 22:15.460]  которые возникают с каким-то файловым дескриптором.
[22:15.460 --> 22:19.460]  Дальше он может вызвать специальный стимул вызов,
[22:19.460 --> 22:23.460]  который ждет, пока не возникнет одно из событий,
[22:23.460 --> 22:25.460]  которое было предписано ядру.
[22:25.460 --> 22:30.460]  В этот момент, конечно, процесс находится в режиме сна,
[22:30.460 --> 22:33.460]  но ядро обязано распутить процесс,
[22:33.460 --> 22:36.460]  если возникнет хотя бы одно из событий,
[22:36.460 --> 22:38.460]  которым процесс интересовался.
[22:38.460 --> 22:41.460]  Казалось бы, очень простая концепция,
[22:41.460 --> 22:45.460]  но она достаточно давно была реализована.
[22:45.460 --> 22:48.460]  Что это могут быть за события?
[22:48.460 --> 22:50.460]  Если вы хотите что-то читать,
[22:50.460 --> 22:53.460]  то событием является поступление новых данных
[22:53.460 --> 22:55.460]  в файл либо сайт.
[22:55.460 --> 22:57.460]  Либо для системы вызова Accept
[22:57.460 --> 23:00.460]  там может быть новое входящее подключение.
[23:00.460 --> 23:04.460]  Также событиями значимыми являются
[23:04.460 --> 23:06.460]  признак end of file,
[23:06.460 --> 23:08.460]  то есть когда кто-то закрыл
[23:08.460 --> 23:10.460]  противоположную сторону канала,
[23:10.460 --> 23:12.460]  либо SOP.
[23:12.460 --> 23:16.460]  Но также могут быть всякие дополнительные события,
[23:16.460 --> 23:18.460]  например, полученный сигнал,
[23:18.460 --> 23:20.460]  который мешает нам что-то дальше прочитать,
[23:20.460 --> 23:22.460]  либо тайм-аут,
[23:22.460 --> 23:24.460]  если вы хотите периодически все-таки
[23:24.460 --> 23:27.460]  приостанавливать цикл ожидания.
[23:27.460 --> 23:29.460]  Все это является событием.
[23:29.460 --> 23:32.460]  И на самом деле все это было сделано
[23:32.460 --> 23:36.460]  давным-давно, еще в 80-е или 90-е годы.
[23:36.460 --> 23:40.460]  Да, но кто помнит историю Unix систем,
[23:40.460 --> 23:42.460]  как раз в 80-е годы
[23:42.460 --> 23:45.460]  появилось два разных развития.
[23:45.460 --> 23:48.460]  Это BSD Unix и Unix System 4.
[23:48.460 --> 23:51.460]  Поэтому весь API, который появился
[23:51.460 --> 23:53.460]  уже в 80-е годы,
[23:54.460 --> 23:57.460]  он может различаться в разных системах.
[23:57.460 --> 24:01.460]  Современные системы Linux и FreeBSD,
[24:01.460 --> 24:03.460]  ну и macOS как FreeBSD,
[24:03.460 --> 24:07.460]  они поддерживают разные варианты API
[24:07.460 --> 24:11.460]  из соображений совместимости.
[24:11.460 --> 24:15.460]  И в этих системах существовало
[24:15.460 --> 24:17.460]  два системного пользователя,
[24:17.460 --> 24:20.460]  которые работали примерно одинаковым образом,
[24:20.460 --> 24:22.460]  но просто с разными сигнатурами,
[24:22.460 --> 24:24.460]  с разными структурами.
[24:24.460 --> 24:26.460]  Один из них назывался Select,
[24:26.460 --> 24:28.460]  другой назывался Poll.
[24:28.460 --> 24:30.460]  В чем смысл этих системных вызовов?
[24:30.460 --> 24:32.460]  Вы сканываете им
[24:32.460 --> 24:34.460]  некоторый массив
[24:34.460 --> 24:37.460]  из файлов-дескрипторов,
[24:37.460 --> 24:40.460]  которые вам интересны.
[24:40.460 --> 24:42.460]  Дальше вызываете системный вызов
[24:42.460 --> 24:43.460]  Select и Warp Poll,
[24:43.460 --> 24:46.460]  и они переходят в режим ожидания
[24:46.460 --> 24:49.460]  до тех пор, пока не возникнет события,
[24:49.460 --> 24:51.460]  связанные с одним из файлов-дескрипторов,
[24:51.460 --> 24:53.460]  которые вы искали.
[24:53.460 --> 24:56.460]  После этого вам нужно пробежаться по массиву
[24:56.460 --> 24:59.460]  и посмотреть,
[24:59.460 --> 25:02.460]  файл-дескриптор готов либо не готов
[25:02.460 --> 25:04.460]  к операциям ввода-выбора.
[25:04.460 --> 25:07.460]  Очень простой, казалось бы, механизм,
[25:07.460 --> 25:11.460]  достаточно эффективный в некоторых случаях.
[25:11.460 --> 25:14.460]  Более того, он стал настолько универсальным,
[25:14.460 --> 25:16.460]  что его даже Windows портирует.
[25:16.460 --> 25:19.460]  Но чем все-таки такой подход плох,
[25:19.460 --> 25:21.460]  и почему сейчас новый код
[25:21.460 --> 25:23.460]  не пишется с использованием
[25:23.460 --> 25:26.460]  системных вызовов Select и Warp Poll?
[25:26.460 --> 25:28.460]  Проблема заключается в том,
[25:28.460 --> 25:32.460]  что когда у вас 10 000 подключений,
[25:32.460 --> 25:35.460]  то все хорошо, все замечательно,
[25:35.460 --> 25:38.460]  но на каждый вызов Select и Warp Poll
[25:38.460 --> 25:42.460]  и после завершения работы каждого Select и Warp Poll
[25:42.460 --> 25:45.460]  вам приходится заново пробегаться по массиву
[25:45.460 --> 25:49.460]  из огромного количества файлов-дескрипторов
[25:49.460 --> 25:53.460]  и проверять с каждым из них готовность,
[25:53.460 --> 25:57.460]  что он действительно готов к работе.
[25:57.460 --> 26:00.460]  То есть Select и Warp Poll –
[26:00.460 --> 26:03.460]  это всего лишь частичное решение той проблемы,
[26:03.460 --> 26:05.460]  которая, может, когда-то хорошо решалась
[26:05.460 --> 26:08.460]  в 80-90-е годы, но не в современное время.
[26:08.460 --> 26:10.460]  Потому что что такое 100 000
[26:10.460 --> 26:12.460]  одновременных подключений?
[26:12.460 --> 26:14.460]  Это совсем ни о чем.
[26:14.460 --> 26:16.460]  Нормальная нагрузка на какой-нибудь
[26:16.460 --> 26:18.460]  среднестатистический сайт.
[26:19.460 --> 26:21.460]  Тут какой-то момент,
[26:21.460 --> 26:24.460]  начало нулевых или конец 90-х,
[26:24.460 --> 26:27.460]  была такая система FreeBSD,
[26:27.460 --> 26:29.460]  она сейчас существует.
[26:29.460 --> 26:33.460]  Там немножко по-другому реализовали механизм
[26:33.460 --> 26:36.460]  под названием Select.
[26:36.460 --> 26:39.460]  То есть главная проблема – это обход массива.
[26:39.460 --> 26:41.460]  А еще есть такая структура,
[26:41.460 --> 26:43.460]  которая называется очередь.
[26:43.460 --> 26:45.460]  Чем хороша очередь?
[26:45.460 --> 26:47.460]  Вы можете в конец очереди в хвост
[26:47.460 --> 26:49.460]  записывать какие-то новые события,
[26:49.460 --> 26:53.460]  а из головы очереди сначала вытаскивать
[26:53.460 --> 26:56.460]  какие-то самые ранние события,
[26:56.460 --> 27:01.460]  их обрабатывать, ну и хорошая такая структура.
[27:01.460 --> 27:07.460]  Так вот, в системе FreeBSD реализовали
[27:07.460 --> 27:10.460]  такую обработку событий через очередь,
[27:10.460 --> 27:12.460]  которая называется очередь ядра –
[27:12.460 --> 27:14.460]  Kernel-Q.
[27:14.460 --> 27:17.460]  Как происходит взаимодействие с этой очередью?
[27:17.460 --> 27:19.460]  Вы регистрируете точно так же,
[27:19.460 --> 27:21.460]  как для SelectClickAll,
[27:21.460 --> 27:23.460]  какие-то файлы и дескрипторы,
[27:23.460 --> 27:25.460]  которые вы хотите мониторить.
[27:25.460 --> 27:29.460]  Дальше, если происходят какие-то события,
[27:29.460 --> 27:33.460]  то ядро добавляет в очередь
[27:33.460 --> 27:36.460]  эти файлы и дескрипторы,
[27:36.460 --> 27:38.460]  и пользовательский процесс
[27:38.460 --> 27:41.460]  периодически может вытаскивать что-то
[27:41.460 --> 27:44.460]  из головы этой очереди, из ядра.
[27:44.460 --> 27:47.460]  При этом в ядре эти события помечаются,
[27:47.460 --> 27:49.460]  как прочитанные они исчезают,
[27:49.460 --> 27:51.460]  ну и дальше с ними что-то делать.
[27:51.460 --> 27:54.460]  Поэтому здесь, если у вас огромное количество
[27:54.460 --> 27:56.460]  файлов и дескрипторов, с которыми вы хотите
[27:56.460 --> 27:59.460]  взаимодействовать, и, например,
[27:59.460 --> 28:02.460]  только одна десятая часть из них реально готова,
[28:02.460 --> 28:04.460]  вы честно получите от ядра
[28:04.460 --> 28:07.460]  только одну десятую часть файлов и дескрипторов,
[28:07.460 --> 28:10.460]  с которыми вы действительно готовы работать
[28:10.460 --> 28:14.460]  и не тратить время на проверку всего остального.
[28:14.460 --> 28:17.460]  Вот на базе этого механизма,
[28:17.460 --> 28:20.460]  как это все делается с программной точки зрения,
[28:20.460 --> 28:26.460]  очередь ядра это некоторый файл и дескриптор,
[28:26.460 --> 28:29.460]  то есть похожий на файл и дескриптор объект,
[28:29.460 --> 28:31.460]  идентифицируется целым числом,
[28:31.460 --> 28:34.460]  их может быть несколько.
[28:34.460 --> 28:37.460]  Если вас интересуют какие-то файлы и дескрипторы,
[28:37.460 --> 28:39.460]  например, полученные от клиентов,
[28:39.460 --> 28:41.460]  вы заполняете некоторую структуру,
[28:41.460 --> 28:44.460]  где указываете, что для этого файла и дескриптора
[28:44.460 --> 28:47.460]  вас интересуют события готовности к чтению,
[28:47.460 --> 28:53.460]  добавляете прослушку на этот файл и дескриптор,
[28:53.460 --> 28:56.460]  запихиваете это в параметры очереди.
[28:56.460 --> 28:58.460]  После того, как вы все настроили,
[28:58.460 --> 29:00.460]  вы задаваете еще раз системный вызов
[29:00.460 --> 29:02.460]  немножко с другими параметрами,
[29:02.460 --> 29:06.460]  куда передаете массив из структур
[29:06.460 --> 29:08.460]  максимально возможное количество,
[29:08.460 --> 29:10.460]  по аналогии с read,
[29:10.460 --> 29:12.460]  которое можно прочитать количество,
[29:12.460 --> 29:16.460]  но и для этого самого клиента он блокирует
[29:16.460 --> 29:18.460]  выполнение до тех пор,
[29:18.460 --> 29:22.460]  пока не возникнет хоть какое-нибудь событие.
[29:22.460 --> 29:25.460]  Если у нас хотя бы один файл и дескриптор готов,
[29:25.460 --> 29:28.460]  то он вернет некоторое целое число,
[29:28.460 --> 29:31.460]  это количество элементов очереди,
[29:31.460 --> 29:32.460]  которые он записал.
[29:32.460 --> 29:34.460]  Вот такой простой механизм.
[29:34.460 --> 29:36.460]  Дальше можно просто пробежаться по этой очереди
[29:36.460 --> 29:38.460]  и обработать файл и дескриптор.
[29:38.460 --> 29:42.460]  Ну и примерно в то же время
[29:42.460 --> 29:45.460]  как раз появился веб-сервер.
[29:46.460 --> 29:51.460]  Созданный одним из сисабминов компании Wrangler,
[29:51.460 --> 29:54.460]  который называется Nginx.
[29:54.460 --> 29:57.460]  Буквы страшные, тут всего лишь одногласные,
[29:57.460 --> 29:59.460]  читается Nginx.
[29:59.460 --> 30:02.460]  В чем особенность этого веб-сервера?
[30:02.460 --> 30:06.460]  Он основан как раз на механизме очереди ветра,
[30:06.460 --> 30:09.460]  поэтому он спокойно,
[30:09.460 --> 30:11.460]  даже на слабых машинах,
[30:11.460 --> 30:13.460]  выдерживает небольшую нагрузку.
[30:13.460 --> 30:15.460]  Если лет 10 назад считалось,
[30:15.460 --> 30:19.460]  что надо держать 10 тысяч одновременных подключений,
[30:19.460 --> 30:22.460]  то для современных систем 100 тысяч одновременных подключений
[30:22.460 --> 30:24.460]  это вполне нормальная практика.
[30:24.460 --> 30:28.460]  Но, правда, здесь надо настраивать количество файлов и дескрипторов
[30:28.460 --> 30:30.460]  одновременно открытых, чтобы было доступно и так далее.
[30:30.460 --> 30:35.460]  Конечно, не любая доступная для двух систем по дефолту может.
[30:35.460 --> 30:39.460]  И за счет чего это достигается?
[30:39.460 --> 30:44.460]  Ну, во-первых, у вас есть несколько ядер процессора,
[30:44.460 --> 30:46.460]  то есть вы можете задействовать несколько потоков,
[30:46.460 --> 30:48.460]  какое-то фиксированное количество,
[30:48.460 --> 30:51.460]  делать потоков больше, чем у вас реально есть ядер.
[30:51.460 --> 30:54.460]  Это не очень осмысленно.
[30:54.460 --> 30:58.460]  Ну и дальше мы просто поднимаем какие-то подключения,
[30:58.460 --> 31:00.460]  обрабатываем, выдаем данные.
[31:00.460 --> 31:02.460]  Данные, опять же, можно создать из памяти,
[31:02.460 --> 31:04.460]  не обязательно брать из диска.
[31:04.460 --> 31:07.460]  Что плохого во всей этой концепции?
[31:07.460 --> 31:12.460]  Плохо то, что здесь нет никакой изоляции между разными клеммами.
[31:12.460 --> 31:14.460]  Поэтому сервер Nginx,
[31:14.460 --> 31:18.460]  в первую очередь используется как прокси-сервер,
[31:18.460 --> 31:22.460]  который выдерживает большую нагрузку на входе,
[31:22.460 --> 31:25.460]  дальше, возможно, выполняет балансировку нагрузки,
[31:25.460 --> 31:29.460]  раскидывает это все по другим уже бэкэндам,
[31:29.460 --> 31:31.460]  которые реально генерят контент,
[31:31.460 --> 31:33.460]  ну или потоком дает стать.
[31:33.460 --> 31:39.460]  То есть есть два основных веб-сервера для системы Linux.
[31:39.460 --> 31:42.460]  Один называется Apache, другой называется Nginx.
[31:42.460 --> 31:46.460]  Apache предназначен как внешне такое универсальное,
[31:46.460 --> 31:48.460]  можно делать все, что угодно.
[31:48.460 --> 31:55.460]  Запускать CGI-скрипты, делать очень простое взаимодействие с какими-нибудь бэкэндами.
[31:55.460 --> 32:03.460]  Nginx на плане менее функциональный, но зато он более ориентирован на большое количество подключений.
[32:03.460 --> 32:06.460]  Так, и это все начало нулевых.
[32:06.460 --> 32:10.460]  Я вам рассказывал про некоторые серверы, которые есть в системе Linux.
[32:10.460 --> 32:13.460]  Про это я говорил, что есть какой-то механизм,
[32:13.460 --> 32:15.460]  который реализован в системе FreeBSD,
[32:15.460 --> 32:18.460]  про который, наверное, не все из вас слышали.
[32:18.460 --> 32:24.460]  Никого это не смущает?
[32:24.460 --> 32:26.460]  Ну ладно, на самом деле в Linux то же самое.
[32:26.460 --> 32:28.460]  Только называется по-другому.
[32:28.460 --> 32:32.460]  И сделан тоже немножко не так.
[32:32.460 --> 32:36.460]  В Linux примерно в то же время,
[32:36.460 --> 32:39.460]  то есть в год 2004-2005,
[32:39.460 --> 32:42.460]  в год 2006,
[32:42.460 --> 32:44.460]  появился похожий механизм,
[32:44.460 --> 32:50.460]  который фактически переписали с FreeBSD,
[32:50.460 --> 32:52.460]  но немножко по-другому.
[32:52.460 --> 32:55.460]  Назвали поля, по-другому назвали структуры.
[32:55.460 --> 32:57.460]  Есть все то же самое,
[32:57.460 --> 33:00.460]  называется Calipy.
[33:00.460 --> 33:02.460]  Дизайн тот же самый.
[33:02.460 --> 33:05.460]  Поэтому обсуждать что-то тут не очень,
[33:05.460 --> 33:08.460]  но тут мы получаем некоторую проблему.
[33:08.460 --> 33:09.460]  Представьте себе,
[33:09.460 --> 33:11.460]  что вы хотите написать какой-то софт,
[33:11.460 --> 33:14.460]  который должен работать везде,
[33:14.460 --> 33:18.460]  неважно, это было сервер, FreeBSD, Mac, Linux.
[33:18.460 --> 33:21.460]  Ну на Mac'е сервера это, конечно, уже экзотика.
[33:21.460 --> 33:24.460]  FreeBSD, OpenBSD еще встречаются.
[33:24.460 --> 33:29.460]  Особенно в каких-нибудь небольших системах.
[33:29.460 --> 33:31.460]  И тут можно влиять тенденцию,
[33:31.460 --> 33:34.460]  что с каждым годом эти системы
[33:34.460 --> 33:37.460]  начинают расходиться друг от друга все дальше и дальше.
[33:37.460 --> 33:41.460]  И, казалось бы, очень похожие концепции.
[33:41.460 --> 33:46.460]  Реализуется все примерно одинаковым образом,
[33:46.460 --> 33:50.460]  но приходится писать разный код для разных систем.
[33:50.460 --> 33:53.460]  Как с этим можно бороться?
[33:53.460 --> 33:57.460]  Либо писать какие-то куски под их дефами,
[33:57.460 --> 34:00.460]  то есть проверять, что этот код нужно компилировать только под Linux,
[34:00.460 --> 34:02.460]  а этот компилируют только в FreeBSD.
[34:02.460 --> 34:05.460]  Либо воспользоваться некоторыми готовыми библиотеками,
[34:05.460 --> 34:07.460]  которые за вас тоже сделаны.
[34:07.460 --> 34:11.460]  В частности, для механизмов очередь, ядра и пол
[34:11.460 --> 34:14.460]  есть библиотека Revalent,
[34:14.460 --> 34:17.460]  которую потом в какой-то момент перенесли в LibEv.
[34:17.460 --> 34:20.460]  И, если говорить про плюсы,
[34:20.460 --> 34:24.460]  есть такой большой фреймворк, который называется Boost,
[34:24.460 --> 34:27.460]  который очень не любят во многих компаниях.
[34:27.460 --> 34:29.460]  И вот один из модулей этого Boost'а
[34:29.460 --> 34:31.460]  как раз предназначен, опять же,
[34:31.460 --> 34:34.460]  для такого синхронного взаимодействия.
[34:34.460 --> 34:37.460]  И на разных системах,
[34:37.460 --> 34:42.460]  используют разные механизмы,
[34:42.460 --> 34:44.460]  которые, по сути, делают одно и то же.
[34:44.460 --> 34:46.460]  В том числе, кстати, работает и под Windows,
[34:46.460 --> 34:50.460]  где тоже есть некоторый аналог очереди, ядра.
[34:50.460 --> 34:55.460]  Так, что еще есть в крови очередей?
[34:55.460 --> 34:57.460]  Если вы...
[34:57.460 --> 35:00.460]  Так, ну Python, по идее, у вас всех будет.
[35:00.460 --> 35:05.460]  В Python, не помню, то ли с 3.6, то ли с 3.7 версии,
[35:05.460 --> 35:10.460]  появились включены слова под названием асинхровые.
[35:10.460 --> 35:12.460]  Встречали когда-нибудь такое?
[35:12.460 --> 35:14.460]  Ну, что-то в синхронности такое, да.
[35:14.460 --> 35:16.460]  На самом деле, это не только в Python,
[35:16.460 --> 35:19.460]  есть еще и другие, извините, части JavaScript, Dart,
[35:19.460 --> 35:21.460]  в которых есть такое понятие,
[35:21.460 --> 35:23.460]  как асинхронно ориентированная программировка.
[35:23.460 --> 35:25.460]  В чем оно заключается?
[35:25.460 --> 35:29.460]  Если у вас есть какая-то потенциально долгая операция,
[35:29.460 --> 35:32.460]  например, ввод-вывод,
[35:32.460 --> 35:34.460]  который неизвестно когда завершится,
[35:34.460 --> 35:37.460]  либо сетевое взаимодействие,
[35:37.460 --> 35:43.460]  то функция, которая выполняет эти операции,
[35:43.460 --> 35:47.460]  она возвращает не результат своей работы,
[35:47.460 --> 35:51.460]  а некоторый объект, который называется future, или будущее.
[35:51.460 --> 35:54.460]  В C++, кстати, тоже есть класс с таким названием,
[35:54.460 --> 35:56.460]  делает примерно то же самое.
[35:56.460 --> 35:59.460]  Дальше, около объекта класса future,
[35:59.460 --> 36:03.460]  есть метод, правило называется ZEN,
[36:03.460 --> 36:05.460]  либо еще как-нибудь,
[36:05.460 --> 36:08.460]  которым можно скормить некоторую функцию,
[36:08.460 --> 36:11.460]  обработчик, которая будет выполнена в тот момент,
[36:11.460 --> 36:14.460]  когда данные реально будут готовы.
[36:14.460 --> 36:16.460]  И эта функция выполняется.
[36:16.460 --> 36:20.460]  Либо можно сделать привидительное ожидание
[36:20.460 --> 36:24.460]  готовности объекта.
[36:24.460 --> 36:26.460]  В некоторых языках программирования
[36:26.460 --> 36:28.460]  существует конструкция под названием EVA,
[36:28.460 --> 36:32.460]  ну, либо на плюсах привидительно вызвать ожидание future.
[36:33.460 --> 36:35.460]  Когда объект будет готов, future.v,
[36:35.460 --> 36:37.460]  как он называется.
[36:37.460 --> 36:40.460]  И вот такой подход называется асинхронным,
[36:40.460 --> 36:42.460]  когда вы откладываете какие-то вычисления
[36:42.460 --> 36:45.460]  до тех пор, пока они не станут вам нужными.
[36:45.460 --> 36:47.460]  На самом деле, примерно то же самое
[36:47.460 --> 36:52.460]  еще у нас реализовано в ядре и по лиду.
[36:52.460 --> 36:57.460]  Одинаково реализовано в BSD-системах и в Linux.
[36:57.460 --> 37:01.460]  Называется API асинхронного ввода-вывода.
[37:01.460 --> 37:04.460]  Примеры системных вызовов,
[37:04.460 --> 37:06.460]  по которым можно что-то почитать
[37:06.460 --> 37:10.460]  или посмотреть примеры, приведены на слайде.
[37:10.460 --> 37:13.460]  Казалось бы, вот она, панацея,
[37:13.460 --> 37:18.460]  красивое решение, как работать асинхронно с файлами.
[37:18.460 --> 37:22.460]  Но до недавнего времени поддержка асинхронного ввода-вывода
[37:22.460 --> 37:25.460]  в Linux была достаточно отвратительной.
[37:25.460 --> 37:29.460]  За это ее сильно критиковал Linux.org в свое время.
[37:29.460 --> 37:31.460]  Отвратительная вкладка,
[37:31.460 --> 37:33.460]  а не производительность.
[37:33.460 --> 37:37.460]  Поэтому особо популярным этот API не стал.
[37:37.460 --> 37:41.460]  Хотя у них ядро 5.1
[37:41.460 --> 37:43.460]  сделал хорошее улучшение.
[37:43.460 --> 37:45.460]  Может, стало что-то и получше.
[37:45.460 --> 37:47.460]  Так.
[37:47.460 --> 37:50.460]  Ну и все это работает,
[37:50.460 --> 37:53.460]  если вы хотите, BPUL работает с файловыми дескрипторами.
[37:53.460 --> 37:58.460]  И на самом деле вы можете делать некоторую иерархию.
[37:58.460 --> 38:00.460]  Что она возвращает?
[38:00.460 --> 38:09.460]  Например, системный вызов epl.create.
[38:17.460 --> 38:23.460]  Он возвращает некоторые instance-объекты epl в очереди ядра.
[38:23.460 --> 38:29.460]  И при этом само возвращаемое значение типа int является файловым дескриптором.
[38:30.460 --> 38:33.460]  Что можно сделать с файловым дескриптором?
[38:33.460 --> 38:36.460]  Вы можете запихать его в другой epl.
[38:36.460 --> 38:39.460]  В смысле на это?
[38:39.460 --> 38:43.460]  На самом деле это очень удобная фича,
[38:43.460 --> 38:47.460]  потому что вы можете делать некоторую иерархию древовидную
[38:47.460 --> 38:49.460]  в ваших файловых дескрипторах.
[38:49.460 --> 38:51.460]  Объединять файловые дескрипторы в группы,
[38:51.460 --> 38:55.460]  и тем самым дожидаться готовности уже к определенной группе.
[38:55.460 --> 38:59.460]  Вот кроме epl.create бывают еще другие специальные файлы,
[38:59.460 --> 39:04.460]  которые используются только в Linux,
[39:04.460 --> 39:07.460]  потому что в других системах они не реализованы.
[39:07.460 --> 39:09.460]  С одним из них вы уже сталкивались.
[39:09.460 --> 39:11.460]  Вызывается Signal-ID.
[39:11.460 --> 39:13.460]  Помните такую штуку?
[39:13.460 --> 39:16.460]  Signal-ID это специальный файлодескриптор,
[39:16.460 --> 39:23.460]  из которого можно прочитать объекты по названиям информации о пришедшем сигнале.
[39:23.460 --> 39:28.460]  Ну и кроме Signal-ID еще бывают файлодескрипторы, связанные с таймером.
[39:28.460 --> 39:33.460]  То есть как сделать самый простой таймер на системе пользователя Linux.
[39:33.460 --> 39:35.460]  Создать файлодескриптор,
[39:35.460 --> 39:41.460]  в который периодически попадают некоторые объекты таймера и периодически их ищут.
[39:41.460 --> 39:43.460]  Обычным блокирующим водовыводом.
[39:43.460 --> 39:45.460]  Не блокирующего тут не особо есть.
[39:45.460 --> 39:48.460]  Ну и еще есть event.evd,
[39:48.460 --> 39:51.460]  предназначенный для общения между собой разных потоков,
[39:51.460 --> 39:54.460]  куда можно передавать данные,
[39:54.460 --> 39:57.460]  ну примерно как в Go-Channels.
[39:58.460 --> 40:00.460]  В какую-то одну сторону.
[40:00.460 --> 40:04.460]  Не будет гарантироваться на передаче данных,
[40:04.460 --> 40:09.460]  потому что не будет возникать никаких проблем с мегаточной синхронизацией.
[40:09.460 --> 40:11.460]  Так, ну и...
[40:11.460 --> 40:15.460]  Что это за картинка от Rudali?
[40:15.460 --> 40:19.460]  Такое очень позитивное что-то.
[40:19.460 --> 40:23.460]  На самом деле это высокая нагрузка.
[40:23.460 --> 40:25.460]  Ладно, на этом все.
[40:25.460 --> 40:27.460]  Есть у вас вопросы?
[40:28.460 --> 40:35.460]  Можно задавать голосом Zoom, если кто-то подключился дистанционно.
[40:35.460 --> 40:39.460]  О задании.
[40:39.460 --> 40:41.460]  Нам надо...
[40:41.460 --> 40:43.460]  Мы делаем домашнее задание.
[40:43.460 --> 40:46.460]  Надо думать о том, что во время ожидания ответа
[40:46.460 --> 40:48.460]  прилетит сигнал какой-то.
[40:48.460 --> 40:50.460]  Но в данном случае...
[40:50.460 --> 40:52.460]  Смотрите, если вы обрабатываете сигналы,
[40:52.460 --> 40:55.460]  вы можете при регистрации обработчика сигнала
[40:55.460 --> 40:57.460]  поставить флаг из ареста.
[40:57.460 --> 40:59.460]  И не задумываться об этом.
[40:59.460 --> 41:01.460]  А если арест ставят, это значит продолжились?
[41:01.460 --> 41:03.460]  Это означает, что да,
[41:03.460 --> 41:06.460]  тот системный вызов блокирующий, который был остановлен сигналом,
[41:06.460 --> 41:09.460]  он будет перезапущен.
[41:09.460 --> 41:11.460]  И потому что у меня осталось место в этом значке.
[41:11.460 --> 41:13.460]  А если не делаю обработчик?
[41:13.460 --> 41:15.460]  А, то он не перелет всегда?
[41:15.460 --> 41:17.460]  Нет, если вы не делаете обработчик сигнала,
[41:17.460 --> 41:19.460]  то будет действие по умолчанию,
[41:19.460 --> 41:21.460]  и как правило это совершенно бессмысленно.
[41:21.460 --> 41:25.460]  Потому что для большинства сигналов действие это прибить процесс.
[41:27.460 --> 41:37.460]  Еще вопросы?
[41:37.460 --> 41:39.460]  Ну ладно, если нет вопросов,
[41:39.460 --> 41:41.460]  тогда беспокойно.
