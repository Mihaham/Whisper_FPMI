[00:00.000 --> 00:06.920]  Так, ладно, мы начинаем тогда.
[00:06.920 --> 00:22.040]  Ладно, надеюсь, вы все видите и не уснете при этом.
[00:22.040 --> 00:25.120]  Тема сегодняшнего занятия это продолжение уже не
[00:25.120 --> 00:29.000]  только межпроцессного взаимодействия, но и еще и сетевой взаимодействия.
[00:29.000 --> 00:31.000]  То есть сокеты.
[00:31.000 --> 00:38.840]  Давайте вспомним, какие вообще вы помните способы межпроцессного взаимодействия.
[00:38.840 --> 00:42.840]  Тупой наивный способ это обычные файлы.
[00:42.840 --> 00:45.200]  Не буду о них устанавливаться.
[00:45.200 --> 00:51.800]  Можно делать какие-то разделяемые области памяти с помощью механизма МАП.
[00:51.800 --> 00:56.120]  Можно использовать каналы как именованные, так и неименованные.
[00:56.120 --> 01:01.040]  Но у всех этих способов, связанных с каналами, есть существенный недостаток.
[01:01.040 --> 01:02.600]  Что у Пайпа, что у Фифо.
[01:02.600 --> 01:06.840]  Что это за недостаток такой? Очень существенный.
[01:06.840 --> 01:11.880]  Но буфер-то ладно, мы заполнили, прочитали, освободили.
[01:11.880 --> 01:16.040]  Это нормальная история. Самое-то главное ограничение у каналов.
[01:16.040 --> 01:22.600]  Да, мы нормально можем организовать взаимодействие только двух процессов, но не больше.
[01:23.480 --> 01:31.480]  Если вам нужно организовать какой-то процесс, который может работать с большим количеством подключений, то здесь каналы не подойдут.
[01:31.480 --> 01:37.960]  То есть на самом деле вы можете запустить несколько дочерних процессов, используя один и тот же Фифо или один и тот же Пайп.
[01:37.960 --> 01:43.240]  Но это сильно вам не поможет, потому что данные у вас будут просто перемешиваться.
[01:43.240 --> 01:49.480]  И вы не знаете никогда, от кого именно какую часть данных вы получили.
[01:49.720 --> 01:57.720]  И для взаимодействия нескольких процессов между собой, когда их больше двух, каналы уже не подходят.
[01:57.720 --> 02:04.040]  И для этого используется еще один способ межпроцессного взаимодействия, который называется сокеты.
[02:04.040 --> 02:06.840]  Что такое сокет?
[02:06.840 --> 02:13.640]  Это файл-дискрептор, который в отличие от каналов предназначен одновременно и для чтения, и для записи.
[02:13.640 --> 02:19.320]  То есть он открыт сразу в обе стороны и предназначен для двустороннего взаимодействия.
[02:20.280 --> 02:29.400]  При этом при взаимодействии нескольких процессов нужно выбрать один главный процесс, который мы дальше будем называть сервером.
[02:29.400 --> 02:34.040]  Слово сервер, наверное, знакомо. Это что-то, к чему можно подключиться.
[02:34.040 --> 02:39.800]  Все остальные процессы, которых может быть от нуля и больше, будут называться клиентами.
[02:39.800 --> 02:45.880]  Сервер что должен сделать для организации межпроцессного взаимодействия?
[02:46.120 --> 02:51.240]  Он должен объявить некоторое имя, по которому его смогут найти.
[02:51.240 --> 02:53.720]  Имена бывают самые разные.
[02:53.720 --> 03:02.680]  Если проводить аналогию с какими-нибудь именованными каналами FIFO, то есть еще один специальный тип файла под названием UnixSocket.
[03:02.680 --> 03:12.680]  UnixSocket это некоторый файл, который можно не совсем открыть, который можно подключиться, используя механизм сокетов.
[03:13.560 --> 03:22.280]  Если вы знаете имя этого файла, если у вас есть права доступа к этому файлу, то есть поскольку файл там можно поставить разные права доступа,
[03:22.280 --> 03:28.840]  у файла может быть владелец, группа владельцев и так далее, вы можете организовать межпроцессные взаимодействия.
[03:28.840 --> 03:34.120]  Еще один способ адресации — это использовать пару чисел.
[03:34.200 --> 03:38.040]  Числа могут быть либо 128-битными, либо 32-битными.
[03:38.040 --> 03:43.720]  Одно число — это адрес, и второе число 16-битное — номер порта.
[03:43.720 --> 03:55.720]  Вот адрес компьютера плюс номер порта однозначно определяют какой-то процесс, но уже в данном случае не только на локальном машине, но на каком-то произвольном компьютере.
[03:55.720 --> 04:00.520]  То есть механизм сокетов очень легко масштабируется с локальной историей на сетевую.
[04:01.160 --> 04:07.240]  И есть еще третий тип адресации, который присутствует во всех UNIX-подобных системах.
[04:07.240 --> 04:11.000]  На самом деле их чуть больше, но они уже являются платформа-зависимыми.
[04:11.000 --> 04:25.480]  Это низкоуровненный способ взаимодействия, где адресом является уникальный дезификатор вашей сетевой платы, куда вы можете, имея права рута, писать что-то напрямую.
[04:26.200 --> 04:31.400]  Создается socket, как ни странно, систем вызовом, который тоже называется socket.
[04:31.400 --> 04:39.400]  Что делает socket? Он просто создает файловый дискриптор, которым пока вы ничего не можете делать.
[04:39.400 --> 04:48.120]  То есть он занимает место в пространстве файловых дискрипторов точно так же, как при открытии файлов и при создании файловых дискрипторов.
[04:48.120 --> 04:53.000]  Вы можете получить ошибку при создании, что вы исчерпали лимит на количество файловых дискрипторов.
[04:53.000 --> 04:57.000]  И что необходимо указать при создании сокета?
[04:57.000 --> 05:03.000]  Во-первых, нужно указать, какой тип адресации вы в дальнейшем будете использовать.
[05:03.000 --> 05:07.000]  То есть address family, либо UNIX файлы, либо интернет.
[05:07.000 --> 05:09.000]  Причем интернет бывает двух видов.
[05:09.000 --> 05:14.000]  Адресация IPv4 классическая, которую вас учили везде, в том числе, наверное, и в школе.
[05:14.000 --> 05:19.000]  И адресация IPv6, где адреса имеют размер 16 байт.
[05:20.000 --> 05:24.000]  И сокеты у нас могут использоваться в двух разных режимах.
[05:24.000 --> 05:30.000]  Один режим – это потоковая передача данных в две стороны.
[05:30.000 --> 05:36.000]  То есть сокет – это файловый дискрептор, доступный и для чтения, и для записи.
[05:36.000 --> 05:40.000]  Гарантируется последовательность данных, которые вы записываете и читаете,
[05:40.000 --> 05:42.000]  и гарантируется целостность этих данных.
[05:42.000 --> 05:46.000]  То есть если у вас данные закончились, вы об этом обязательно узнаете.
[05:46.000 --> 05:49.000]  Если возникнет ошибка, тоже об этом узнаете.
[05:49.000 --> 05:51.000]  Это параметр потоковый.
[05:51.000 --> 05:55.000]  И второй тип, который мы разберем уже не сегодня, а позже,
[05:55.000 --> 06:03.000]  это передача коротких сообщений, предназначенной для того, чтобы уменьшить нагрузку на сеть.
[06:03.000 --> 06:07.000]  Но этот способ не гарантирует абсолютно ничего.
[06:07.000 --> 06:12.000]  То есть вам нужно указать пространство адресов, тип взаимодействия.
[06:12.000 --> 06:17.000]  Есть еще третий параметр, который, когда вы начинаете что-то писать на сокетах,
[06:17.000 --> 06:20.000]  может вас немного смущать. Это номер протокола.
[06:20.000 --> 06:25.000]  Чуть позже мы сегодня на лекции затронем, что такое номер протокола.
[06:25.000 --> 06:30.000]  На самом деле с практической точки зрения просто указывайте значение 0,
[06:30.000 --> 06:34.000]  и в большинстве случаев вам это будет абсолютно не нужно.
[06:34.000 --> 06:42.000]  0 – это автоматический выбор ядром по паре пространства адресов и тип взаимодействия.
[06:42.000 --> 06:46.000]  Когда вы создали какой-то сокет, вы израсходовали файловый дескриптор.
[06:46.000 --> 06:50.000]  Дальше этот файловый дескриптор вы можете куда-нибудь передать, например,
[06:50.000 --> 06:54.000]  дочерний процесс создать, и, соответственно, дочерний процесс унаследует ваш сокет.
[06:54.000 --> 06:58.000]  Можете сдать его копию, можете закрывать с помощью клоуз,
[06:58.000 --> 07:08.000]  для того чтобы этот сокет освободить и ценный ресурс количество файловых дескрипторов немножко возобновить.
[07:08.000 --> 07:14.000]  Но читать и писать в сокет вы еще не можете, потому что сокет у вас пока еще не настроен,
[07:14.000 --> 07:21.000]  вы его только создали. И настройка сокета бывает в двух разных видов.
[07:21.000 --> 07:33.000]  Это либо настройка сокета для серверного взаимодействия, либо настройка для клиентского взаимодействия.
[07:33.000 --> 07:44.000]  Что требуется для того, чтобы сокет настроить? В зависимости от того, кем вы являетесь.
[07:44.000 --> 07:49.000]  Если вы являетесь клиентом, то ваш сокет нужно просто подключить к какому-то адресу.
[07:49.000 --> 07:54.000]  Подключить это значит, если у вас локальная машина, вам нужно знать имя файла,
[07:54.000 --> 08:01.000]  вам нужно открыть этот файл, и если у вас есть права на доступ к файлу сокета,
[08:01.000 --> 08:04.000]  все хорошо, все замечательно, соединение установлено.
[08:04.000 --> 08:10.000]  Если вы подключаетесь к какому-то удаленному компьютеру, либо к себе самому,
[08:10.000 --> 08:13.000]  но уже используя сетевой протокол имя хоста localhost,
[08:14.000 --> 08:18.000]  то нужно, чтобы у вас была настроена рабочая сеть
[08:18.000 --> 08:23.000]  и существовал маршрут до того компьютера, к которому вы хотите подключиться.
[08:23.000 --> 08:30.000]  Клиенту достаточно сделать просто коннект. Результат работы этой операции нужно всегда проверять,
[08:30.000 --> 08:34.000]  потому что здесь может происходить все, что угодно.
[08:34.000 --> 08:41.000]  Даже в таком высокотехнологичном месте как FizTech, как вы могли заметить, иногда с интернетом тоже бывают проблемы.
[08:42.000 --> 08:47.000]  Ну и если вы являетесь сервером, то тут немножко сложнее.
[08:47.000 --> 08:50.000]  Необходимо выполнить для взаимодействия.
[08:50.000 --> 08:53.000]  Клиент после того, как сделал коннект, все, может сокет читать и писать,
[08:53.000 --> 08:55.000]  используя обычные стенвызовы, риты и врать.
[08:55.000 --> 08:59.000]  А серверу для этого требуется несколько больше действий.
[08:59.000 --> 09:08.000]  Во-первых, вам нужно анонсировать какое-то имя, по которому ваш сервис будет доступен.
[09:08.000 --> 09:12.000]  После этого вам нужно переключить сокет в режим прослушивания.
[09:12.000 --> 09:19.000]  И после этого вы принимаете по одному соединение от разных клиентов.
[09:19.000 --> 09:25.000]  И уже с каждым клиентом работаете по отдельности, используя отдельный файловый дескриптор.
[09:25.000 --> 09:30.000]  Как связать сокет с каким-то именем?
[09:30.000 --> 09:34.000]  Есть два системных вызова. Один называется коннект, другой байнд.
[09:34.000 --> 09:38.000]  Разница между ними в том, что коннект предназначен для клиентов.
[09:38.000 --> 09:44.000]  То есть он устанавливает соединение, и вы уже можете после этого взаимодействовать с сокетом.
[09:44.000 --> 09:51.000]  Байнд просто связывает сокет с каким-то именем, чтобы к нему кто-то мог подключиться.
[09:51.000 --> 09:56.000]  Параметры у них одинаковые. Это тот файловый дескриптор, который вы создали раньше.
[09:56.000 --> 10:04.000]  И плюс имя, которое вы хотите связать с вашим сокетом.
[10:04.000 --> 10:13.000]  Причем если вы используете высокоуровневый API сокета на питоне, то это ровно один параметр.
[10:13.000 --> 10:17.000]  В 29-й группе вчера на семинаре это показывал.
[10:17.000 --> 10:24.000]  В случае си тут немножко сложнее, потому что сокеты у вас бывают совершенно разных типов.
[10:24.000 --> 10:32.000]  Есть некоторая абстрактная структура SOCADR, которая фактически только содержит заголовок.
[10:32.000 --> 10:36.000]  Всех остальных структур, которые наследуются этой структурой.
[10:36.000 --> 10:40.000]  Но си это же не объектно-ориентированный язык программирования.
[10:40.000 --> 10:49.000]  Здесь имитация псевдоуп реализуется за счет того, что есть структуры, которые реализуют конкретную функциональность определенных адресов,
[10:49.000 --> 10:57.000]  которые самым первым полем содержат некоторую константу, которая определяет, чем именно эта структура является.
[10:57.000 --> 11:01.000]  Эти структуры имеют все разный размер.
[11:01.000 --> 11:14.000]  Например, для IP-адреса IPv4 нам нужно 32-битное число для самого IP-адреса и 16-битное число для номера порта.
[11:14.000 --> 11:19.000]  А, например, для локального униксойки-то нам нужно уже хранить имя файла.
[11:19.000 --> 11:22.000]  Тут есть одно отличие от обычных имен файлов.
[11:22.000 --> 11:27.000]  Это ограничение на длину 108 байт, а не 4096.
[11:27.000 --> 11:30.000]  Но все равно 108 это заведомо больше, чем 6 байт.
[11:30.000 --> 11:32.000]  Плюс еще есть дополнительная информация.
[11:32.000 --> 11:40.000]  То есть у всех структур есть разный размер, который должен быть системным вызовом, скопирован из пользовского пространства в память ядра.
[11:40.000 --> 11:44.000]  Поэтому на языке C есть еще третий параметр обязательный.
[11:44.000 --> 11:49.000]  Это размер той структуры, которую вы передаете.
[11:49.000 --> 11:58.000]  Конкретные поля в разных структурах смотрятся в седьмом разделе мана по соответствующему пространству имен.
[11:58.000 --> 12:07.000]  Имена, перечисленные на слайд, это уникс, IP это обычный интернет, IPv6 это адресация IPv6 более новая.
[12:07.000 --> 12:19.000]  После того, как вы связали связывание стенлозом байнд, точно так же, как коннект, всегда нужно проверять на успешность.
[12:19.000 --> 12:27.000]  Почему у вас может возникнуть какая-то ошибка на стадии связывания какого-то адреса с сокетом?
[12:27.000 --> 12:31.000]  Можете предположение сделать?
[12:31.000 --> 12:34.000]  Очень распространенные ошибки, которые не всегда проверяют.
[12:34.000 --> 12:41.000]  Когда проверяют, получается все очень плохо.
[12:41.000 --> 12:46.000]  У вас банально адрес может быть занят.
[12:46.000 --> 12:52.000]  То есть, если у вас, например, есть один компьютер с каким-то IP адресом,
[12:52.000 --> 12:59.000]  и вы запустили, например, веб-сервер Nginx, который работает на 80 порту,
[12:59.000 --> 13:06.000]  потом вы запускаете веб-сервер Apache, который настроен тоже на 80 порт по умолчанию, что у вас произойдет.
[13:06.000 --> 13:12.000]  Тот, кто запущен раньше, тот будет слушать 80 порта и работать как веб-сервер.
[13:12.000 --> 13:18.000]  Тот, кто запущен позже, не сможет сделать байнд, и ничего хорошего из этого не выйдет.
[13:18.000 --> 13:24.000]  Более того, когда вы будете решать задачи, писать какие-то серверы,
[13:24.000 --> 13:32.000]  то понятно, что если вы нормально пишете, а не катаете, вы отлаживаетесь,
[13:32.000 --> 13:35.000]  у вас иногда что-нибудь случается, программа крэшится,
[13:35.000 --> 13:39.000]  либо вы ее принудительно останавливаете кнопочкой остановить, послать сигнанс и кил.
[13:39.000 --> 13:41.000]  Что при этом происходит?
[13:41.000 --> 13:47.000]  Происходит не освобождение адреса в ведре, то есть при завершении работы процесса
[13:47.000 --> 13:51.000]  у вас еще остается некоторый фантом вашего сокета.
[13:51.000 --> 13:59.000]  В Linux он примерно через минуту исчезает, но тем не менее при повторной попытке выполнить байнд
[13:59.000 --> 14:04.000]  у вас ничего хорошего не выйдет, потому что имя уже занято, нужно либо подождать,
[14:04.000 --> 14:08.000]  либо использовать некоторую магию, которая у вас в рейтинге прописана.
[14:08.000 --> 14:14.000]  Итак, вы связали сокет с каким-то именем, дальше вы переключаете сокет в режим прослушивания,
[14:14.000 --> 14:20.000]  и здесь есть еще некоторый целочисленный параметр, который больше по историческим причинам
[14:20.000 --> 14:24.000]  является параметром, на самом деле он достаточно жестко,
[14:24.000 --> 14:30.000]  точнее верхняя граница этого параметра жестко лимитирована в ядре операционной системы.
[14:30.000 --> 14:38.000]  В Linux 128 максимальное количество подключений, которые могут ждать обработки сервера.
[14:38.000 --> 14:43.000]  Что значит ждать? Это означает, что вы запустили сервер, еще не успели ничего сделать,
[14:43.000 --> 14:48.000]  к вам уже ломятся какие-то клиенты. Сколько может быть таких клиентов?
[14:48.000 --> 14:55.000]  В Linux их может быть не больше, чем 128, и что будет происходить с теми, кто подключился слишком поздно?
[14:55.000 --> 15:04.000]  Эти клиенты сразу от ядра операционной системы получают отказ, что соединения нельзя установить.
[15:04.000 --> 15:13.000]  Если вы лимит на backlog не превысили, тогда подключившиеся клиенты успешно смогут подключиться,
[15:13.000 --> 15:21.000]  Connect им вернет нормальный файловый дискриптор, для них вернет значение 0 успешное подключение,
[15:21.000 --> 15:30.000]  но пока сервер не начнет что-то писать или что-то читать, для клиента ничего полезного происходить не будет,
[15:30.000 --> 15:35.000]  он будет просто на стенах закрытой в райд ждать, процесс будет в состоянии sleep.
[15:35.000 --> 15:42.000]  Вы создали socket, связали его с каким-то именем, переключили в режим прослушивания.
[15:42.000 --> 15:49.000]  Если на этом этапе у вас все произошло успешно, то следующая часть,
[15:49.000 --> 16:02.000]  которую вы должны сделать на сервере, это принимать по одному с помощью системного вызова accept,
[16:02.000 --> 16:11.000]  accept возвращает уже серверу отдельный файловый дискриптор, с которым можно дальше взаимодействовать,
[16:11.000 --> 16:19.000]  естественно у вас должен быть неизрасходованный лимит на максимальное количество файловых дискрипторов,
[16:19.000 --> 16:26.000]  кстати по этой причине дефолтное значение количество файловых дискрипторов иногда приходится менять,
[16:26.000 --> 16:32.000]  потому что значение 1024, которое по умолчанию в большинстве дистрибутилов,
[16:32.000 --> 16:41.000]  бывает совершенно неприемлемым для серверных применений, когда у вас большое количество одновременных подключений.
[16:41.000 --> 16:48.000]  Если все успешно, вы на сервере либо приняли соединение, либо клиентом успешно подключились,
[16:48.000 --> 16:57.000]  то как с сокетом можно взаимодействовать, либо простым способом, который в большинстве случаев более чем достаточен,
[16:57.000 --> 17:03.000]  используя обычные системные вызовы read&write, поскольку это обычный файловый дискриптор, можно читать, можно писать,
[17:03.000 --> 17:10.000]  либо используя специальные системные вызовы, которые работают с файлом дискриптор, но специального типа, только с сокетами.
[17:11.000 --> 17:17.000]  Это send и rec, в которые позволяет еще дополнительно указывать разные параметры.
[17:17.000 --> 17:32.000]  Например, при чтении вы можете дождаться, когда все данные будут прочитаны, а потом только после этого rec вам возвращает количество байт,
[17:32.000 --> 17:39.000]  а rec может в этом время прочитать один кусок, потом еще один кусок, то есть объединить количество данных.
[17:39.000 --> 17:46.000]  Но более принципиально, где используется send и rec, это либо при взаимодействии по UDP, то есть не потоковой передачи данных,
[17:46.000 --> 17:56.000]  либо при взаимодействии, когда вам требуется передавать какие-то специальные пакеты, например, отдельные участки данных с повышенным приоритетом.
[17:56.000 --> 18:10.000]  На сокете действуют те же самые ограничения, что и для каналов, то есть нельзя писать в сокет, у которого с противоположной стороны никто не читает.
[18:10.000 --> 18:19.000]  Если вы попытаетесь что-то записать в сокет, который уже закрыт, то то же самое, как при записи в каналах, вы получаете сигнал sickpipe,
[18:19.000 --> 18:23.000]  если вы его не обрабатываете, то получаете ошибку brokenpipe.
[18:23.000 --> 18:29.000]  В систему из-за send вы можете явным образом указать флаг, что не нужно получать sickpipe,
[18:29.000 --> 18:38.000]  если вы используете систему из-за fright, как эту ситуацию можно обойти, чтобы не падать, если вдруг противоположная сторона закрыла соединение.
[18:42.000 --> 18:44.000]  Предложите способ обойти эту проблему.
[18:44.000 --> 18:53.000]  Да, можно просто установить хендлер на сигнал sickpipe, который ничего не будет делать.
[18:53.000 --> 19:02.000]  Так, ну и сети. Что это такое? То есть с локальными сокетами тут все достаточно просто.
[19:02.000 --> 19:09.000]  Я вам все рассказал, используйте специальные файлы типа сокет, и будет вам счастье.
[19:09.000 --> 19:18.000]  Так, теперь немножко про сети. Мы живем в современном мире, поэтому забываем про всякие разные способы адресации,
[19:18.000 --> 19:24.000]  которые у вас перечислены, например, в мане на сокет.
[19:24.000 --> 19:37.000]  То есть если вы посмотрите список всех доступных пространств адресов, в втором разделе сокет, какие есть константы,
[19:37.000 --> 19:43.000]  то их очень много, на одну страницу мана они не помещаются.
[19:43.000 --> 19:50.000]  И на самом деле большая часть того, что здесь перечислено, это уже какой-то очень старый мусор,
[19:50.000 --> 19:56.000]  который просто тащится из соображений гарантии совместимости.
[19:56.000 --> 20:02.000]  Ну не все мусор, тут конечно есть отдельные типы, которые просто редко используем,
[20:02.000 --> 20:06.000]  но тем не менее много из этого вы в реальной жизни никогда не встретите.
[20:06.000 --> 20:12.000]  Современные сети это стэк протоколов TCPIP,
[20:12.000 --> 20:21.000]  и есть еще классическая модель сетевой иерархии, которая называется Open System Interconnection Model.
[20:21.000 --> 20:25.000]  На каких-нибудь собеседованиях, если вам придется что-то рассказывать про сети,
[20:25.000 --> 20:32.000]  единственное место, где вам нужно знать, что такое УСИ, какие там есть уровни.
[20:32.000 --> 20:38.000]  Давайте пройдемся снизу вверх. Какие у нас бывают уровни организации сети?
[20:38.000 --> 20:44.000]  На самом нижнем уровне у нас есть уровень сетевого интерфейса с точки зрения стэка TCPIP,
[20:44.000 --> 20:50.000]  который в свою очередь делится на два подуровня, физический уровень и Data Link.
[20:50.000 --> 20:57.000]  Например, интерфейс Ethernet. Что такое сетевой разъем на ноутбуке, знаете?
[20:57.000 --> 20:59.000]  Или вы уже привыкли к Wi-Fi?
[20:59.000 --> 21:03.000]  Ну в общем, бывают сетевые разъемы у десктопов и на некоторых ноутбуках,
[21:03.000 --> 21:07.000]  и во всяких переходниках с Type-C, куда можно воткнуть проводок.
[21:07.000 --> 21:14.000]  Это стандарт Ethernet. На самом деле кроме Ethernet раньше существовали еще другие типы сетей,
[21:14.000 --> 21:16.000]  например, как сиальный кабель.
[21:16.000 --> 21:19.000]  И в этом стандарте есть два подстандарта.
[21:19.000 --> 21:22.000]  То есть Ethernet это некоторое обобщенное название.
[21:22.000 --> 21:29.000]  Один стандарт описывает физический уровень, то есть как у нас данные передаются в виде сигналов по проводам.
[21:29.000 --> 21:36.000]  И второй стандарт это как данные у нас должны быть организованы, на логическом уровне.
[21:36.000 --> 21:44.000]  При этом в каких ситуациях у вас могут эти данные отличаться, могут эти стандарты быть разными?
[21:44.000 --> 21:50.000]  Например, когда вы подключаете через USB кабель компьютеру смартфон,
[21:50.000 --> 21:54.000]  если у вас Android смартфон, что обычно вы видите?
[21:54.000 --> 21:57.000]  Вы видите, что вы подключили какую-то новую сетевую плату,
[21:57.000 --> 22:01.000]  которую используете как обычную сетевую плату,
[22:01.000 --> 22:07.000]  используя логический интерфейс Ethernet, но при этом на физическом уровне вы используете обычный USB кабель.
[22:07.000 --> 22:13.000]  И данные здесь передаются по USB, но при этом закодируем предварительно в формате Ethernet frame.
[22:13.000 --> 22:21.000]  И противоположная ситуация, когда вы используете обычный Ethernet провод,
[22:21.000 --> 22:25.000]  но на логическом уровне там что-то может быть другое.
[22:25.000 --> 22:30.000]  Это когда вы установите VPN подключения, у вас создается виртуальная сетевая плата,
[22:30.000 --> 22:36.000]  которая использует тоже Ethernet пакет, но уже поверх немного другого уровня.
[22:36.000 --> 22:40.000]  По Ethernet можно передавать данные тоже произвольного типа,
[22:40.000 --> 22:46.000]  не обязательно Ethernet пакеты, это иногда используется при работе с микроконтроллерами.
[22:46.000 --> 22:54.000]  Чуть выше уже идет сетевой уровень, который в оси называется сетевым уровнем TCP, IP стеки называется уровнем интернет.
[22:54.000 --> 22:59.000]  Он определяет способ адресации ваших пакетов.
[22:59.000 --> 23:03.000]  В нюнаслайде два раза IPv4 потаблировано, это имеет в виду IPv6.
[23:03.000 --> 23:09.000]  На этом уровне определяется, как можно данные доставить до кого-то другого,
[23:09.000 --> 23:15.000]  то есть фактически это адрес, по которому как-то дальше можно узнать маршрут.
[23:15.000 --> 23:21.000]  Из современных протоколов выжили только IPv4 и IPv6, остальное это старинные legacy,
[23:21.000 --> 23:28.000]  навряд ли вы когда-нибудь видите новое нетвер или старинные Apple компьютеры, которые есть только в Яндекс.Музее.
[23:28.000 --> 23:34.000]  Следующий уровень – это уровень транспорта, который определяет, а что именно мы передаем.
[23:34.000 --> 23:42.000]  Либо мы передаем потоковые данные, то есть открываете сокет для двустороннего взаимодействия с помощью Read&Write,
[23:42.000 --> 23:46.000]  либо вы передаете короткие сообщения.
[23:46.000 --> 23:54.000]  А дальше уже начинается все, что вы читаете из Read&Write, это уровень процессов, достаточно обобщенный.
[23:54.000 --> 23:58.000]  Ну и в классической модели AC там есть еще разделение на несколько подуровней,
[23:58.000 --> 24:03.000]  на самом деле границы между ними очень весьма условные.
[24:03.000 --> 24:09.000]  Так, ну и что у нас происходит при попытке как-то взаимодействовать.
[24:09.000 --> 24:13.000]  Шрифт мелковатый, конечно, потом в презентации посмотрите.
[24:13.000 --> 24:20.000]  Итак, вот представьте себе, что вы открываете какой-то веб-браузер, набираете www.example.com,
[24:21.000 --> 24:27.000]  не забывая при этом писать http, потому что по умолчанию все браузеры используют протокол https,
[24:27.000 --> 24:31.000]  который передает данные в разношифрованном виде.
[24:31.000 --> 24:34.000]  Смотреть на это, конечно, немного сложнее, хотя это безопаснее.
[24:34.000 --> 24:36.000]  Итак, что у нас происходит.
[24:36.000 --> 24:43.000]  Наша система открывает какой-то рандомный порт с достаточно большим номером,
[24:43.000 --> 24:51.000]  и с этим портом связывает какие-то полезные данные, например, заголовок HP запроса.
[24:51.000 --> 24:53.000]  Что происходит дальше.
[24:53.000 --> 25:00.000]  С этим потоком данных, дальше этот поток данных заворачивается в некоторый TCP-сегмент.
[25:00.000 --> 25:09.000]  И здесь уже обязательным параметром TCP-сегмента является номер порта как отправителя,
[25:09.000 --> 25:13.000]  это большое значение, и плюс номер порта получателя.
[25:13.000 --> 25:19.000]  Если вы обращаетесь к веб-серверу, то стандартным номером является номер 80.
[25:19.000 --> 25:23.000]  И здесь еще возникает то самое число.
[25:23.000 --> 25:25.000]  Нет, пока еще не возникает.
[25:25.000 --> 25:31.000]  Так, эта штука называется TCP-сегмент, который содержит кусочек данных, связанных с номером порта.
[25:31.000 --> 25:35.000]  Дальше этот TCP-сегмент заворачивается в IP-пакет,
[25:35.000 --> 25:40.000]  в который добавляется IP-адрес, куда нужно этот пакет отправить,
[25:40.000 --> 25:46.000]  и он содержит еще IP-адрес отправителя, чтобы противоположная сторона знала, куда отправлять ответ.
[25:46.000 --> 25:53.000]  И в этот момент еще добавляется число для TCP-6.
[25:53.000 --> 26:00.000]  Это тот самый номер протокола, который является третьим параметром при создании сокета.
[26:00.000 --> 26:04.000]  Тот, который ядро может само выбрать, если указать значение 0.
[26:04.000 --> 26:12.000]  Дальше IP-пакет заворачивается, если вы используете Wi-Fi либо проводной интернет, уже в Ethernet-кадр.
[26:12.000 --> 26:15.000]  Адресация по Ethernet немножко другая.
[26:15.000 --> 26:20.000]  Она предназначена для того, чтобы адресовать любое устройство в пределах какой-то локальной сети,
[26:20.000 --> 26:24.000]  то есть до первого маршрутизатора или до первого Wi-Fi-руутера.
[26:24.000 --> 26:28.000]  Это 6-байтное значение называется MAC-адрес.
[26:28.000 --> 26:33.000]  И вот мы получаем огромное количество заголовок, в дополнение к нашим большим данным.
[26:33.000 --> 26:37.000]  И этот фрейм дальше как-то идет до маршрутизатора.
[26:37.000 --> 26:40.000]  И с маршрутизатора дальше извлекается IP-пакет.
[26:40.000 --> 26:46.000]  Какими-то окольными путями все-таки дело доходит до нашего сервера, куда мы отправили.
[26:46.000 --> 26:50.000]  Причем доходит он, возможно, в искаженном виде.
[26:50.000 --> 26:55.000]  То есть у нас может поменяться номер порта отправителя, IP-адрес отправителя,
[26:55.000 --> 27:00.000]  но, естественно, меняется MAC-адрес отправителя с одним исключением, если вы не находитесь в одной локальной сети.
[27:00.000 --> 27:06.000]  Дальше сервер обрабатывает эти заголовки.
[27:06.000 --> 27:15.000]  Если получен соответствие по IP-адресу, то сервер обрабатывает.
[27:15.000 --> 27:21.000]  Дальше пакет, если не соответствующий по IP-адресу, значит он должен куда-то переадресовать этот пакет,
[27:21.000 --> 27:25.000]  либо отклонить в зависимости от того, как таблица маршрутизации настроена.
[27:25.000 --> 27:27.000]  Дальше извлекается TCP-сегмент.
[27:27.000 --> 27:32.000]  В серверу порта, который прописан в TCP-сегменте, выбирается уже конкретный процесс,
[27:32.000 --> 27:36.000]  который открыл на прослушивание порт с нужным номером.
[27:36.000 --> 27:42.000]  Дальше что происходит в обратную сторону.
[27:42.000 --> 27:52.000]  Зная адрес отправителя, номер порта отправителя, можно сформировать какой-то ответ и отправить обратно.
[27:52.000 --> 27:57.000]  Давайте пройдемся снизу вверх, начиная с логического, а не физического уровней.
[27:57.000 --> 28:03.000]  Что мы можем передавать? Интереснее это смотреть на реальной практике.
[28:03.000 --> 28:08.000]  Для этого есть замечательный тул, который называется Wireshark.
[28:08.000 --> 28:12.000]  Это кросс-платформенная опенсорсная утилита.
[28:12.000 --> 28:18.000]  Есть не только в Linux, может даже и в Windows есть, не проверял.
[28:18.000 --> 28:23.000]  Под Mac оно точно есть, под Linux тем более.
[28:23.000 --> 28:31.000]  Вот мы запускаем некоторые тулы. Сначала нам нужно выбрать, с каким сетевым интерфейсом будем работать.
[28:31.000 --> 28:38.000]  В данном случае физиологическая сеть подвела, поэтому я подключусь через мобильный интернет.
[28:38.000 --> 28:44.000]  Давайте double-кликнем. Что у нас происходит? Происходит какая-то активность.
[28:44.000 --> 28:49.000]  На самом деле в реальной жизни тут очень большая активность, запутаться легко и просто.
[28:49.000 --> 28:52.000]  Вверху есть строчка, где можно написать какой-то фильтр.
[28:52.000 --> 29:02.000]  Например, будем фильтровать все, что связано с IP-адресом.
[29:02.000 --> 29:08.000]  Я должен продемонстрировать какое-то взаимодействие по протоколу HTTP.
[29:08.000 --> 29:13.000]  Именно по HTTP, без использования SSL. Не так много сайтов живых осталось.
[29:13.000 --> 29:21.000]  Пример такого сайта это www.example.com.
[29:21.000 --> 29:27.000]  Он умеет работать по протоколу HTTP, без буквы S.
[29:27.000 --> 29:36.000]  И выдают какую-то страничку о том, что это специальный дом, чтобы иллюстрировать, как работать с интернетом на низком уровне.
[29:36.000 --> 29:45.000]  Итак, вот у нас есть некоторый example.com. Чтобы настроить фильтр, я выясняю его IP-адрес.
[29:45.000 --> 29:53.000]  Есть разные способы, как выяснить IP-адреса. К сожалению, проектор немножко подрезает, поэтому я подниму.
[29:53.000 --> 30:03.000]  www.example.com. Команда ns-lookup ищет у основного DNS-сервера IP-адрес, связанный с этим именем.
[30:03.000 --> 30:12.000]  Есть еще более продвинутая команда, которая называется dig, где можно более тонко тюнить, например, с какого сервера получать.
[30:12.000 --> 30:22.000]  Итак, вот мы видим, что есть некоторые IP-адресы нашего example.com, и эту штуку мы можем добавить в наш фильтр.
[30:22.000 --> 30:26.000]  Так, что-то я тут уже получал. Ну ладно.
[30:26.000 --> 30:31.000]  Так, вот запрос мы уже обработали, он сохранился в истории, который Wireshark отловил.
[30:31.000 --> 30:38.000]  Итак, что у нас происходит при отправке запроса и получении ответа вот в таком виде?
[30:38.000 --> 30:51.000]  Происходит очень большой обмен данными по протоколу TCP, который содержит в конце полезную нагрузку в виде текста HTTP.
[30:51.000 --> 30:57.000]  Вот мы нашли протокол HTTP, и вот этот текст мы можем наблюдать.
[30:57.000 --> 31:02.000]  Так, но что нас следует до данных, которые мы отправляем в GET-запросе?
[31:02.000 --> 31:15.000]  Во-первых, у нас есть некоторые заголовок. Вот когда я кликаю по разным частям того, что Wireshark отображает на каком-то пакете, это разные уровни сети интернет.
[31:15.000 --> 31:24.000]  Frame — это что-то низкоуровневое, поэтому здесь неинтересно это смотреть, оно может по-разному работать даже в разных операционных системах.
[31:24.000 --> 31:29.000]  А вот начиная с уровня Ethernet-логических, все более-менее стандартно.
[31:29.000 --> 31:34.000]  Итак, что у нас есть в заголовке Ethernet? Есть всего лишь три поля.
[31:34.000 --> 31:44.000]  Когда я кликаю на какой-то заголовок, внизу подсвечивается что-то. Это как раз та часть, которая занята заголовками.
[31:44.000 --> 31:59.000]  Так, что у нас есть в заголовке Ethernet? Есть два числа, длина каждого числа 6 байт, это как раз MAC-адрес отправителя и получателя.
[31:59.000 --> 32:09.000]  И некоторый тип данных, 2-байтное значение, которое указывает, а что именно внутри этого IP-пакета закодировано.
[32:09.000 --> 32:21.000]  Поскольку мы можем передавать данные не только по протоколу IP, но и, например, по протоколу IPv6, еще есть всякие разные протоколы, какие типы пакетов мы можем отправлять внутри Ethernet-кадра.
[32:21.000 --> 32:25.000]  Нужно знать их тип, чтобы принимающая сторона могла разобраться, что дальше с этим делать.
[32:25.000 --> 32:42.000]  Так, дальше внутри следующий заголовок, уже там, где у нас идет полезная нагрузка. Размер полезной нагрузки является настраиваемым при установке соединения,
[32:42.000 --> 32:54.000]  установке подключения к интернету. Обычно это параметр 1492 либо 1500. Это максимальный размер одного Ethernet-кадра.
[32:54.000 --> 33:03.000]  Если у вас что-то не помещается в полезную нагрузку, данные делятся на несколько Ethernet-кадров, они отправляются последовательно.
[33:03.000 --> 33:22.000]  Здесь какие могут быть ограничения. Например, если вы используете VPN-подключение, то понятно, что у вас будет каждый раз при каждой новом уровне вложенности очередного VPN-подключения размер полезной нагрузки у вас будет уменьшаться.
[33:22.000 --> 33:34.000]  Дальше у нас в этой полезной нагрузке запихивается AP-пакет, который тоже имеет какой-то заголовок. Естественно, этот заголовок идет сразу после заголовка Ethernet.
[33:34.000 --> 33:47.000]  Тут куча всяких параметров, на самом деле не все из них нам интересны. В альшарках тоже отображает. Они идут сразу, что у нас есть полезного, интересного в этих заголовках.
[33:47.000 --> 34:01.000]  Хидр и длина заголовков неинтересно. Суммарный размер в байтах. Заголовка вроде нет.
[34:01.000 --> 34:08.000]  Полный размер AP-пакета 131 байт. Похоже на правду. Что еще полезного?
[34:08.000 --> 34:19.000]  Параметр TimeToLeave. Это количество итераций, которые может пройти пакет через разные маршрутизаторы, прежде чем исчезнуть.
[34:19.000 --> 34:31.000]  Для чего это нужно? Например, если у вас плохо сконфигурированная сеть, есть какие-то петли для того, чтобы пакеты не нагружали сеть, ходя бесконечно, есть некоторые ограничения.
[34:31.000 --> 34:43.000]  С этим TimeToLeave есть еще один побочный эффект, связанный с тем, что некоторые нехорошие мобильные операторы любят брать дополнительную денежку, когда вы начинаете раздавать интернет с телефона.
[34:43.000 --> 34:55.000]  Как они это определяют? Телефон является очередным маршрутизатором. При прохождении трафика через него ТТЛ уменьшается на единичку.
[34:55.000 --> 35:02.000]  По этому признаку можно понять, что вы действительно раздаете интернет, а не пользуетесь телефоном.
[35:02.000 --> 35:12.000]  На компьютере, с которым вы подключаетесь, увеличивает параметр до 65, и будет вам счастье.
[35:12.000 --> 35:20.000]  Тут есть некоторые косвенные признаки, чтобы узнать, что вы раздаете интернет.
[35:20.000 --> 35:28.000]  Если вы пользуетесь как бы телефоном, но при этом телефон внезапно начинает лезть в Windows Update, это уже подозрительно,
[35:28.000 --> 35:36.000]  и уже по косвенным признакам операторы все-таки могут определить, что вы интернет все-таки раздаете, и с вас может просить денежку.
[35:36.000 --> 35:43.000]  Номер протокола. Для TCP это значение 6, для EDP это значение 17.
[35:43.000 --> 35:50.000]  Других поверх IP есть протоколы, но достаточно редко используемые.
[35:50.000 --> 35:58.000]  Для чего нужен номер протокола? Для того, чтобы при распаковке пакета знать, как дальше обрабатывать следующие заголовки.
[35:58.000 --> 36:02.000]  Тот самый пресловутый третий параметр.
[36:02.000 --> 36:09.000]  Контрольные суммы, понятно, не интересно. Да, и два целых числа, без знаковых, 32-битных.
[36:09.000 --> 36:14.000]  Это source address, Windows 192, 168, чего-то там.
[36:14.000 --> 36:23.000]  И destination address, это тот самый IP-адрес, который соответствует серверу example.com.
[36:23.000 --> 36:31.000]  В чем тут есть особенность? В IP у нас не содержится номер порта, это уже TCP-сегмент.
[36:31.000 --> 36:38.000]  Но что для IP-адреса, что для номера порта, действует соглашение о том, что это числа.
[36:38.000 --> 36:45.000]  И как можно закодировать числа, если их длина больше 1 байта?
[36:45.000 --> 36:49.000]  Big Indian, Little Indian, помните такое?
[36:49.000 --> 36:55.000]  Так вот, у большинства компьютеров родной порядок byte – это Little Indian.
[36:55.000 --> 37:00.000]  То есть, когда у вас сначала идут младшие разряды, а потом старшие.
[37:00.000 --> 37:06.000]  В сети не так. Есть такое понятие, как сетевой порядок byte, он же Big Indian,
[37:06.000 --> 37:12.000]  когда сначала идут старшие разряды, а потом младшие.
[37:12.000 --> 37:18.000]  Так вот, если вы внимательно посмотрите на бинарный dump, посчитаете на калькуляторе, какое тут должно быть значение,
[37:18.000 --> 37:25.000]  то увидите, что данные перейдутся всегда в Big Indian, и это нужно учитывать в том числе,
[37:25.000 --> 37:32.000]  если вы хотите инициализировать какие-то структуры, связанные с адресами либо номерами портов.
[37:32.000 --> 37:39.000]  В принципе, это все, что есть интересного в IPv4, остальное не особо интересно.
[37:39.000 --> 37:47.000]  А дальше, поверх, внутри IP-пакетов, в качестве полезной нагрузки мы можем отправлять пакеты одного из двух видов.
[37:47.000 --> 37:50.000]  Самый простой из них – это UDP.
[37:50.000 --> 37:58.000]  Я сделал простой запрос к HTTP, огромное количество данных всяких пошло, всяких разных страшных.
[37:58.000 --> 38:08.000]  Есть еще более простой способ – это использовать UDP-пакеты, у которых в заголовке есть только две полезные информации.
[38:08.000 --> 38:16.000]  Это 16-битный номер порта получателя, куда нужно отправить, 16-битный номер порта отправителя,
[38:16.000 --> 38:22.000]  длина сообщения в байтах и контрольная сумма для проверки целостности.
[38:22.000 --> 38:30.000]  Короткий заголовок, очень простой, и как мы можем отправить UDP-сообщение и проследить.
[38:30.000 --> 38:36.000]  Один способ – это выяснить IP-адрес по имени, это команда nslookup.
[38:36.000 --> 38:42.000]  Есть еще команда dig, где можно указать то же самое.
[38:43.000 --> 38:47.000]  И он выдаст немножко в другом формате, но тот же самый ответ.
[38:47.000 --> 38:53.000]  Еще есть одна особенность dig, что вы можете указать, кому именно из DNS-серверов,
[38:53.000 --> 38:56.000]  в которых может быть много, передать данный запрос.
[38:56.000 --> 39:02.000]  4.8 либо 8.8.4.4 – это гугловские DNS-серверы.
[39:02.000 --> 39:08.000]  Так, чтобы было что-то нестандартное, я отправляю на сейвер 8.8.4.4 запрос,
[39:08.000 --> 39:13.000]  получаю правильный ответ, ну давайте исследуем, что у нас при этом произошло.
[39:13.000 --> 39:18.000]  8.8.8.4.4.
[39:18.000 --> 39:24.000]  Так, соединение, тут взаимодействие намного короче, чем PotiCP.
[39:24.000 --> 39:28.000]  Только один запрос и один ответ.
[39:28.000 --> 39:34.000]  Запрос с нашего IP-шника на 8.8.4.4 и ответ в обратную сторону.
[39:34.000 --> 39:38.000]  Так, ну давайте посмотрим, что у нас тут могло быть.
[39:38.000 --> 39:42.000]  С IP с головками примерно все то же самое, он одинаковый для TCP-UDP.
[39:42.000 --> 39:50.000]  Дальше идет заголовок UDP, это какой-то большой номер 63 372
[39:50.000 --> 39:59.000]  для открытого порта отправителя и номер 53, стандарт для DNS, адрес порт получателя.
[39:59.000 --> 40:04.000]  Длина 64 байта.
[40:04.000 --> 40:08.000]  Так, контрольная сумма, ну и все, заголовок на этом закончился.
[40:08.000 --> 40:13.000]  Дальше уже идет полезная нагрузка, которая была отправлена в качестве запроса,
[40:13.000 --> 40:17.000]  ну и ответа на DNS-сервер.
[40:17.000 --> 40:20.000]  Так, вот с TCP тут все сложнее.
[40:20.000 --> 40:26.000]  Ну точно так же у нас есть номер порта отправителя сегмента,
[40:26.000 --> 40:34.000]  номер порта получателя. TCP, в отличие от UDP, это протокол для потоковой передачи данных.
[40:34.000 --> 40:37.000]  То есть у нас здесь еще важными являются такие параметры,
[40:37.000 --> 40:41.000]  как порядковый номер какого-то TCP-сегмента в общем потоке,
[40:41.000 --> 40:45.000]  для того чтобы гарантировать целостность данных в правильном порядке.
[40:45.000 --> 40:47.000]  Как эта целостность гарантируется?
[40:47.000 --> 40:54.000]  Вы отправляете какой-то сегмент, в ответ сервер вам отправляет какой-то ответ
[40:54.000 --> 41:00.000]  в виде TCP-сегмента, который при этом содержит еще одно число в заголовке,
[41:00.000 --> 41:06.000]  это номер подтверждаемого пакета, что сервер его действительно получил.
[41:06.000 --> 41:14.000]  Это все обрабатывается на уровне ядра, то есть не нужно при использовании ReadWrite прописывать это вручную.
[41:14.000 --> 41:18.000]  Дальше ядро проверяет, что действительно все сегменты были отправлены,
[41:18.000 --> 41:21.000]  если какие-то были не отправлены, повторяет отправку,
[41:21.000 --> 41:26.000]  либо сообщает о том, что ошибка, что за плохо с интернетом.
[41:26.000 --> 41:32.000]  Так, есть еще всякие разные неинтересные параметры TCP,
[41:32.000 --> 41:38.000]  но кроме этого есть еще некоторый набор флагов в количестве 9 штук,
[41:38.000 --> 41:41.000]  то есть не занимает 1 байт плюс 1 бит,
[41:41.000 --> 41:45.000]  и среди них выделяются три очень полезных бита.
[41:45.000 --> 41:49.000]  Один бит, который называется acknowledgement, означает,
[41:49.000 --> 41:55.000]  что данный пакет содержит значимое число, это номер подтверждаемого пакета.
[41:55.000 --> 42:01.000]  Кстати, номера пакетов имеют сквозную нумерацию с момента загрузки системы.
[42:01.000 --> 42:05.000]  То есть если вы запускаете несколько процессов,
[42:05.000 --> 42:11.000]  то при каждом новом сетевом соединении
[42:11.000 --> 42:16.000]  начинается эта нумерация не с нуля, а с достаточно большого числа.
[42:16.000 --> 42:21.000]  Но если вы смотрите в Wireshark, то Wireshark автоматически сам это все пересчитывает.
[42:21.000 --> 42:30.000]  Так, вот ACK означает, что является значимым число номер подтверждаемого пакета,
[42:30.000 --> 42:35.000]  и есть два флага для установки соединения, SIN и FIN.
[42:35.000 --> 42:38.000]  SIN означает, что вы устанавливаете соединение,
[42:38.000 --> 42:41.000]  а FIN, что вы хотите соединение закрыть.
[42:41.000 --> 42:46.000]  И есть еще флаг RST, означает, что соединение было сброшено,
[42:46.000 --> 42:49.000]  в некоторых случаях оно тоже является признаком того,
[42:49.000 --> 42:53.000]  что в это соединение закрываете, хотя это не самый корректный способ.
[42:56.000 --> 42:59.000]  Как выглядит взаимодействие по TCP?
[42:59.000 --> 43:04.000]  Изначально кто-то инициирует соединение,
[43:04.000 --> 43:07.000]  отправляя при этом флаг SIN.
[43:07.000 --> 43:12.000]  В ответ вы получаете TCP-сегмент с флагами SIN и Acknowledgement.
[43:12.000 --> 43:15.000]  После этого уже начинается передача данных,
[43:15.000 --> 43:18.000]  то есть отправка чего-то с флагом Acknowledgement,
[43:18.000 --> 43:21.000]  чтобы мы действительно получили флаг подтверждения.
[43:21.000 --> 43:24.000]  И до тех пор, пока вы не отправите флаг FIN,
[43:24.000 --> 43:27.000]  ну и в ответ вы тоже получите флаг,
[43:27.000 --> 43:30.000]  сегмент с флагами Acknowledgement и FIN,
[43:30.000 --> 43:35.000]  что действительно ваше закрытие соединения принято сервером,
[43:35.000 --> 43:38.000]  либо, наоборот, клиентом, если вы в другую сторону взаимодействуете.
[43:38.000 --> 43:43.000]  И тем самым соединение при этом завершается.
[43:46.000 --> 43:49.000]  И вот как правильно закрывать TCP-соединение,
[43:49.000 --> 43:52.000]  то есть все-таки отправлять сегменты с флагом FIN.
[43:52.000 --> 43:57.000]  Когда вы просто закрываете файл в дискриттер с помощью close,
[43:57.000 --> 43:59.000]  что у вас происходит?
[43:59.000 --> 44:02.000]  У вас просто освобождается очень ценный ресурс
[44:02.000 --> 44:05.000]  количество файловых дискриттеров.
[44:05.000 --> 44:07.000]  И все.
[44:07.000 --> 44:09.000]  То есть этот файл дискриттер становится недоступен,
[44:09.000 --> 44:12.000]  но при этом системный вызов close не предназначен
[44:12.000 --> 44:14.000]  для того, чтобы закрывать сетевые соединения.
[44:14.000 --> 44:16.000]  Закрыть-то, конечно, можно.
[44:16.000 --> 44:18.000]  Да, вы освободите у себя файловый дискриттер.
[44:18.000 --> 44:21.000]  Но что будет происходить с противоположной стороной?
[44:21.000 --> 44:23.000]  Противоположная сторона об этом не узнает,
[44:23.000 --> 44:25.000]  что вы закрыли соединение,
[44:25.000 --> 44:28.000]  и будет пытаться вам что-то записать,
[44:28.000 --> 44:31.000]  либо будет пытаться что-то от вас прочитать.
[44:31.000 --> 44:33.000]  В какой-то момент, конечно, получит ошибку
[44:33.000 --> 44:35.000]  либо broken pipe при попытке записать,
[44:35.000 --> 44:38.000]  либо incarnation refused при попытке прочитать,
[44:38.000 --> 44:40.000]  но это произойдет не сразу.
[44:40.000 --> 44:43.000]  И это будет именно ошибочная ситуация.
[44:43.000 --> 44:46.000]  Да, при этом вам как клиенту на это, наверное, все равно,
[44:46.000 --> 44:48.000]  но вы ведете себя невежливо.
[44:48.000 --> 44:50.000]  Как правильно делать?
[44:50.000 --> 44:53.000]  Перед закрытием обязательно делать shutdown.
[44:53.000 --> 44:56.000]  Некоторые системы, например, Linux,
[44:56.000 --> 45:00.000]  при close посылают как раз пакет RST,
[45:00.000 --> 45:05.000]  который может быть обработан именно как ошибочная ситуация
[45:05.000 --> 45:08.000]  для того, чтобы противоположная сторона
[45:08.000 --> 45:11.000]  не находилась у вас в состоянии ожидания.
[45:13.000 --> 45:18.000]  Ну и по поводу номеров портов, которые являются 16-битными,
[45:18.000 --> 45:23.000]  как и адреса, они закодированы в BigEndian,
[45:23.000 --> 45:26.000]  даже если их номера не очень большие.
[45:26.000 --> 45:34.000]  Номера до 1000 обычно связаны с какими-то стандартными службами,
[45:34.000 --> 45:36.000]  то есть есть какие-то стандарты,
[45:36.000 --> 45:39.000]  которые описывают на каком порту, что должно быть.
[45:39.000 --> 45:42.000]  Но при этом никто не мешает вам сделать, например,
[45:42.000 --> 45:46.000]  какой-нибудь эхо-сервер, который будет работать на 22-м или 80-м порту,
[45:46.000 --> 45:49.000]  или перенастроить SSA, чтобы он работал не на 22-м порту,
[45:49.000 --> 45:52.000]  а на чем-то рандомном, например,
[45:52.000 --> 45:56.000]  чтобы усложнить поиск потенциальным злоумышленником.
[45:57.000 --> 46:00.000]  То есть есть некоторые стандартные порты.
[46:00.000 --> 46:03.000]  И когда-то давно считали, что у вас есть 1024 стандартных порта,
[46:03.000 --> 46:06.000]  открывать их может только пользователь root.
[46:06.000 --> 46:10.000]  Все остальные порты с номерами больше, чем 1024,
[46:10.000 --> 46:15.000]  начиная с 1024, они могут быть использованы
[46:15.000 --> 46:19.000]  с бедром произвольным образом в качестве исходящих клиентских номеров.
[46:19.000 --> 46:21.000]  Куда потом прислать ответ?
[46:21.000 --> 46:24.000]  В современных системах это немножко не так,
[46:24.000 --> 46:28.000]  потому что появилась куча разных сценариев использования
[46:28.000 --> 46:31.000]  помимо стандартных сервисов.
[46:31.000 --> 46:36.000]  Классический пример — это фласск или robin rails.
[46:36.000 --> 46:39.000]  Используют порт 8080.
[46:39.000 --> 46:44.000]  И понятно, что использовать порты с такими номерами в качестве исходящих
[46:44.000 --> 46:46.000]  как-то не очень правильно.
[46:46.000 --> 46:49.000]  Поэтому в современных системах в случае с Linux
[46:49.000 --> 46:53.000]  ядро начинает назначать рандомные порты
[46:53.000 --> 46:59.000]  начиная с кода номера 32768 в Windows, Mac 49152.
[46:59.000 --> 47:01.000]  То есть достаточно большие номера.
[47:01.000 --> 47:06.000]  И вот в этих диапазонах как раз не нужно делать никакие сетевые службы.
[47:06.000 --> 47:13.000]  И кроме того, порты с номером до 1024 открывать может только root,
[47:13.000 --> 47:17.000]  либо есть такое понятие как Linux Capabilities,
[47:17.000 --> 47:19.000]  которые позволяют...
[47:19.000 --> 47:21.000]  Capabilities, помните такую штуку?
[47:21.000 --> 47:23.000]  Команды setcap, getcap и так далее.
[47:23.000 --> 47:27.000]  Всякие флаги там — pay, inherited и так далее.
[47:27.000 --> 47:30.000]  Так вот, есть отдельный флаг Capabilities,
[47:30.000 --> 47:33.000]  который позволяет непривлекированному пользователю
[47:33.000 --> 47:37.000]  все-таки открывать порты с небольшим номером,
[47:37.000 --> 47:40.000]  если это вдруг нужно.
[47:40.000 --> 47:43.000]  Но иногда это бывает полезно.
[47:43.000 --> 47:46.000]  Хотя зачем?
[47:46.000 --> 47:49.000]  Можно настроить EngineX Server в качестве Proxy.
[47:49.000 --> 47:51.000]  Ну ладно.
[47:51.000 --> 47:56.000]  Теперь немножко по поводу исходящих номеров портов,
[47:56.000 --> 48:00.000]  которые рандомно присваивают из этого большие числа.
[48:00.000 --> 48:07.000]  На самом деле сервер может неправильно узнать в вашей пиадрис,
[48:07.000 --> 48:09.000]  когда вы подключаетесь,
[48:09.000 --> 48:11.000]  номер вашего порта,
[48:11.000 --> 48:13.000]  потому что где-то по дороге
[48:13.000 --> 48:16.000]  эти сведения в заголовках могут поменяться.
[48:16.000 --> 48:18.000]  Из-за чего они могут поменяться?
[48:18.000 --> 48:20.000]  Давайте рассмотрим классическую ситуацию,
[48:20.000 --> 48:24.000]  что вы сидите через единую Wi-Fi с вашим соседом,
[48:24.000 --> 48:28.000]  и вы одновременно подключаетесь к Яндексу
[48:28.000 --> 48:31.000]  или еще к какому-нибудь веб-сайту.
[48:31.000 --> 48:33.000]  Что есть у какого-то веб-сайта?
[48:33.000 --> 48:37.000]  Есть порт номер 80, есть какой-то IP-адрес,
[48:37.000 --> 48:40.000]  и вы одновременно с соседом подключаетесь.
[48:40.000 --> 48:42.000]  И так случайно совпало,
[48:42.000 --> 48:46.000]  что у вас на ноутбуках система одновременно присвоила
[48:46.000 --> 48:49.000]  один и тот же номер исходящего порта.
[48:49.000 --> 48:53.000]  А как сервер узнает, а кому именно отправить ответ?
[48:53.000 --> 48:56.000]  Какой ответ кому предназначен?
[48:56.000 --> 48:58.000]  Ответ никак.
[48:58.000 --> 49:03.000]  Поэтому в чем заключается задача маршрутизатора?
[49:03.000 --> 49:06.000]  Маршрутизатор, он же роутер,
[49:06.000 --> 49:10.000]  это таблица маршрутизации, которая содержит записи вида
[49:10.000 --> 49:13.000]  от кого, кому, что было отправлено,
[49:13.000 --> 49:17.000]  чтобы потом сметчить уже правильную сторону ответа.
[49:17.000 --> 49:22.000]  И мы получаем запросы с двух разных IP-шников
[49:22.000 --> 49:25.000]  внутри нашей какой-то локальной сети,
[49:25.000 --> 49:30.000]  который на выходе во внешнюю сеть превращается в один IP-адрес,
[49:30.000 --> 49:32.000]  который присвоен вам провайдером,
[49:32.000 --> 49:35.000]  сервер будет отправлять ответ уже на этот IP-адрес,
[49:35.000 --> 49:37.000]  который вам провайдером присвоен,
[49:37.000 --> 49:39.000]  либо он будет отправлять провайдеру,
[49:39.000 --> 49:41.000]  если у вас динамический IP-адрес,
[49:41.000 --> 49:43.000]  а провайдер дальше уже разберется,
[49:43.000 --> 49:45.000]  кому отправлять и так далее.
[49:45.000 --> 49:48.000]  И роутер меняет номер порта.
[49:48.000 --> 49:50.000]  Соответственно, получая ответ от сервера,
[49:50.000 --> 49:52.000]  роутер разбирается,
[49:52.000 --> 49:55.000]  а кому именно из внутренних клиентов уже предназначается
[49:55.000 --> 49:58.000]  этот ответ и отправляет его обратно.
[49:58.000 --> 50:00.000]  Поэтому что будет,
[50:00.000 --> 50:03.000]  если вы возьмете обычный домашний роутер
[50:03.000 --> 50:09.000]  и попробуете организовать огромную сеть на 100 человек.
[50:09.000 --> 50:13.000]  И среди этих 100 человек еще найдутся человек 5,
[50:13.000 --> 50:16.000]  которые начнут качать торренты или смотреть видосики.
[50:17.000 --> 50:19.000]  Вообще тела можно не убедить.
[50:19.000 --> 50:21.000]  Вот однопоточнение у меня поползло.
[50:21.000 --> 50:23.000]  Можно заметить, что внутри одного,
[50:23.000 --> 50:25.000]  ну разных частей истек,
[50:25.000 --> 50:27.000]  и нельзя попрощать другого процесса.
[50:27.000 --> 50:29.000]  Это на что-то вылетает.
[50:29.000 --> 50:31.000]  Ну короче, будет плохо.
[50:31.000 --> 50:33.000]  Опять же, ключевой момент здесь.
[50:33.000 --> 50:35.000]  Если вы используете обычный бытовой роутер,
[50:35.000 --> 50:44.000]  на самом деле тут будет уже некоторая перенапряженность нашего эфира.
[50:44.000 --> 50:48.000]  Но даже если вы в роутер воткнете несколько...
[50:48.000 --> 50:52.000]  у роутеров еще кроме Wi-Fi бывает выход на обычный Ethernet.
[50:52.000 --> 50:54.000]  Можно сделать что-то древовидное,
[50:54.000 --> 50:56.000]  использовать дешевые свитчи.
[50:56.000 --> 51:00.000]  Так вот, в какой-то момент у вас роутер перегреется
[51:00.000 --> 51:02.000]  и начнет очень медленно работать.
[51:02.000 --> 51:04.000]  Просто по той причине,
[51:04.000 --> 51:07.000]  что у него будет перегружена таблица маршрутизации.
[51:07.000 --> 51:12.000]  Объем оперативной памяти у роутеров обычно не очень большой.
[51:12.000 --> 51:15.000]  И вы просто воткнетесь в это ограничение.
[51:15.000 --> 51:20.000]  Поэтому если вы хотите организовывать полномашнабную какую-то сеть
[51:20.000 --> 51:22.000]  на большое количество людей,
[51:22.000 --> 51:26.000]  то здесь уже надо обзавестись какими-нибудь нормальными промышленными роутерами,
[51:26.000 --> 51:28.000]  которые рассчитаны на большую нагрузку.
[51:28.000 --> 51:30.000]  Принципиальное отличие в том,
[51:30.000 --> 51:35.000]  что нормальный промышленный роутер умеет работать с большими таблицами маршрутизации.
[51:35.000 --> 51:37.000]  Либо взять просто старый десктоп ненужный,
[51:37.000 --> 51:39.000]  и поставить несколько сетевых плат,
[51:39.000 --> 51:41.000]  и пусть он будет роутером.
[51:42.000 --> 51:46.000]  Что еще надо знать про порты?
[51:46.000 --> 51:50.000]  Лишний открытый порт – это дырка безопасности.
[51:50.000 --> 51:55.000]  И во многих Linux-дистрибутивах, и не только в Linux,
[51:55.000 --> 51:59.000]  есть такая штука, которая в Windows называется страшным словом BrandMower.
[51:59.000 --> 52:01.000]  Что это такое означает?
[52:01.000 --> 52:04.000]  Какую-то лингвистическую экспертизу надо проводить.
[52:07.000 --> 52:10.000]  Нарисована в виде стены в иконках.
[52:10.000 --> 52:12.000]  А что слово BrandMower?
[52:17.000 --> 52:21.000]  Другой термин – это Firewall, так называется огненная стена.
[52:21.000 --> 52:23.000]  Что это за штука такая?
[52:23.000 --> 52:29.000]  Это штука, которая препятствует либо исходящим соединениям
[52:29.000 --> 52:32.000]  на запрещенные какие-то ресурсы,
[52:32.000 --> 52:37.000]  либо блокирует попытки входящих подключений через сеть,
[52:37.000 --> 52:39.000]  на определенные интерфейсы.
[52:39.000 --> 52:44.000]  Причем Firewall можно достаточно гибко настраивать.
[52:44.000 --> 52:46.000]  Если у вас есть несколько сетевых плат,
[52:46.000 --> 52:52.000]  то указывать, какие сетевые платы у вас привязаны к доверенным интерфейсам
[52:52.000 --> 52:55.000]  или демилитаризованной зоне, то есть без ограничений.
[52:55.000 --> 52:58.000]  Например, внутренняя сеть между разными сервами.
[52:58.000 --> 53:01.000]  Какие-то интерфейсы могут смотреть наружу,
[53:01.000 --> 53:04.000]  там нужны максимально жесткие правила и так далее.
[53:04.000 --> 53:10.000]  Что является одной записью с точки зрения Firewall?
[53:10.000 --> 53:18.000]  Это некоторый IP-адрес, номер порта и от кого разрешено принимать запросы,
[53:18.000 --> 53:22.000]  от кого запрещено и в каких случаях нужно, например, делать перенаправление.
[53:22.000 --> 53:25.000]  Стандартная таблица маршрутизации в Linux
[53:25.000 --> 53:32.000]  она унифицирована для роли роутера и так и для Firewall.
[53:32.000 --> 53:34.000]  И если у вас несколько сетевых плат,
[53:34.000 --> 53:38.000]  то опять же вам нужно открывать на прослушивание либо конкретный адрес,
[53:38.000 --> 53:43.000]  либо есть специальное значение IP-адреса 4.0 для IPv4,
[53:43.000 --> 53:46.000]  либо 16.0 для IPv6.
[53:46.000 --> 53:48.000]  Это специальный адрес, который означает,
[53:48.000 --> 53:52.000]  что нужно связаться со всеми сетевыми платами, которые у вас есть.
[53:52.000 --> 54:00.000]  Так, узнать, какие порты у вас открыты вы можете с помощью команды nmap.
[54:00.000 --> 54:04.000]  Она обычно не входит в базовую поставку в многих дистрибутеев.
[54:04.000 --> 54:09.000]  Нужно ставить дополнительно apt-get, циппер и так далее.
[54:09.000 --> 54:12.000]  В репозиториях обычно есть, но не стоит по умолчанию.
[54:12.000 --> 54:17.000]  И вот можете проверить свой ноутбук, а что у вас лишнего пана открыто.
[54:17.000 --> 54:21.000]  Firewall как раз валяет это все прикрыть.
[54:21.000 --> 54:23.000]  Так, как работает Firewall?
[54:23.000 --> 54:25.000]  В Linux есть команда, называется epitables,
[54:25.000 --> 54:30.000]  которая добавляет какие-то правила таблицы маршрутизации.
[54:30.000 --> 54:31.000]  Правила могут быть видом.
[54:31.000 --> 54:36.000]  Либо разрешить подключение, либо запретить.
[54:36.000 --> 54:39.000]  Например, вы знаете, что по какому-то IP-адресу находится злоумышленник,
[54:39.000 --> 54:42.000]  либо в какой-то подсети с определенной маской.
[54:42.000 --> 54:45.000]  Ну и вы блокируете явно эти вещи,
[54:45.000 --> 54:51.000]  чтобы все эти пакеты до вас просто не доходили и никому не мешали.
[54:51.000 --> 54:53.000]  Причем сервисы, которые у вас запущены,
[54:53.000 --> 54:56.000]  они даже ничего не узнают, что кто-то пытался подключиться.
[54:56.000 --> 54:58.000]  Firewall работает на более низком уровне.
[54:58.000 --> 55:01.000]  Либо перенаправить определенные подключения,
[55:01.000 --> 55:04.000]  но, например, вы так можете настроить правила,
[55:04.000 --> 55:07.000]  что если вы выходите в сетку такую-то,
[55:07.000 --> 55:12.000]  или пытаясь подключиться, например, к какому-то серверу с известным IP,
[55:12.000 --> 55:16.000]  то это подключение, например, нужно явным образом принудительно перенаправлять
[55:16.000 --> 55:20.000]  через VPN-тунель, чтобы обойти какие-то блокировки или еще что-то.
[55:20.000 --> 55:25.000]  Так вот, таблицы амортизатора достаточно огромными становятся.
[55:25.000 --> 55:29.000]  И напрямую работать с командой iptables
[55:29.000 --> 55:34.000]  для того, чтобы настраивать правила Firewall, это достаточно утомительное занятие.
[55:34.000 --> 55:39.000]  Поэтому в разных дистрибутилах есть высокоуровневые инструменты уже поверх iptables.
[55:39.000 --> 55:45.000]  То есть iptables используют, в частности, в Ubuntu это команда UFW,
[55:45.000 --> 55:49.000]  которая можно поставить в том числе под Debian, Ubuntu Firewall,
[55:49.000 --> 55:52.000]  в Fedora есть Firewall CMD, это команда,
[55:52.000 --> 55:59.000]  которая позволяет тоже легко и просто назначать какие-то правила вашего Firewall.
[55:59.000 --> 56:04.000]  Да, есть одно важное замечание по поводу Linux-дистрибутилов.
[56:04.000 --> 56:08.000]  Во многих из них почему-то по дефолту Firewall отключен.
[56:08.000 --> 56:13.000]  То есть первое, что нужно сделать, поставить Firewall и обязательно его включить,
[56:13.000 --> 56:15.000]  а уже после этого настраивать.
[56:15.000 --> 56:20.000]  Если вы настраиваете сервер, то еще не забыть включить сразу по умолчанию 22-й порт.
[56:20.000 --> 56:25.000]  Так, вообще, что нужно делать, когда вы, например, хотите сделать свой сервер,
[56:25.000 --> 56:33.000]  неважно, это или на какой-то площадке, где хостинг VDS, VPS,
[56:33.000 --> 56:37.000]  либо вы дома поднимаете, покупаете статический IP-адрес.
[56:37.000 --> 56:40.000]  Сначала первым делом при настройке.
[56:40.000 --> 56:42.000]  Да, учитесь на чужих ошибках.
[56:42.000 --> 56:45.000]  Первым делом включайте Firewall.
[56:45.000 --> 56:48.000]  Система без Firewall – это решито.
[56:48.000 --> 56:51.000]  Причем неважно, есть ли у вас злоумышленники или нет.
[56:51.000 --> 56:54.000]  Даже если у вас врагов нет, все равно, есть толпа китайцев,
[56:54.000 --> 56:58.000]  есть куча всяких ботов, которые тупо ломятся на ваш сервер,
[56:58.000 --> 57:06.000]  начинают брутфорсить все подряд, пытаться ломиться, искать какие-то дырки в приложениях.
[57:07.000 --> 57:12.000]  Даже если у вас ничего полезного, ценного на сервере нет, кроме SSH,
[57:12.000 --> 57:16.000]  но все равно это лишнестевая нагрузка. Зачем она вам нужна?
[57:16.000 --> 57:22.000]  По поводу SSH. Отключите парольный вход.
[57:22.000 --> 57:28.000]  Пароли – это пережиток XX века, который сильно помогает хакерам.
[57:28.000 --> 57:34.000]  Даже если не поможет хакерам, все равно хакеры будут пытаться долбиться, подбирая.
[57:34.000 --> 57:37.000]  Посмотрите, какие логии SSH, если у вас парольный вход разрешен.
[57:37.000 --> 57:39.000]  Что у вас будет происходить?
[57:39.000 --> 57:44.000]  Всякие китайские IP-адреса, которые подбирают разные распространенные имена,
[57:44.000 --> 57:50.000]  распространенные пароли. Опять же, лишняя нагрузка на сеть. Зачем она вам нужна?
[57:50.000 --> 57:57.000]  Как ни странно, по всему, вот почему хак уже только по SSH разрешает включаться в последнее время?
[57:57.000 --> 58:02.000]  Распространенная проблема. Тем более, в последнее время есть производитель роутеров MikroTik,
[58:02.000 --> 58:09.000]  которые допустили серьезный баг распространяющий ботнет, не препятствующий точнее распространению ботнета.
[58:09.000 --> 58:16.000]  И вот эти роутеры MikroTik становятся сами взломными ботнетами.
[58:16.000 --> 58:21.000]  В общем, это легко отключается. Один раз настроите ключик и все.
[58:21.000 --> 58:26.000]  Кроме того, есть такая замечательная тулза, называется Fail-to-Ban,
[58:26.000 --> 58:30.000]  которая анализирует логи разных серверов не только SSH,
[58:30.000 --> 58:36.000]  но применимость, в первую очередь, к SSH, потому что туда часть все долгается.
[58:36.000 --> 58:40.000]  И если обнаруживается попытка несколько раз неправильно зайти,
[58:40.000 --> 58:46.000]  то происходит добавление с помощью IP-tables в таблицу маршрутизации.
[58:46.000 --> 58:52.000]  И тот IP-адрес, с которого много раз пытаются до вас достучаться,
[58:52.000 --> 58:58.000]  например, подбирать имена пользователей и пароли, он добавляется в черный список на уровне Firewall,
[58:58.000 --> 59:04.000]  и больше вас не будет беспокоить. Тем самым вы можете предотвратить DDoS-атаку, хотя бы на SSH.
[59:04.000 --> 59:10.000]  На остальные сервисы там не очень тосмысленно, потому что по HTTP это сложно.
[59:10.000 --> 59:14.000]  Так, ну и закрывайте Firewall-ом все, что вы не хотите показывать наружу.
[59:14.000 --> 59:19.000]  Понятно, что 22-й порт никуда не деться, подключаться как надо, надо иметь.
[59:19.000 --> 59:24.000]  80-й порт, если у вас веб-сервер есть, тогда придется открыть.
[59:24.000 --> 59:29.000]  Всякие внутренние потроха, типа фласка и прочее, естественно, должны быть закрыты.
[59:29.000 --> 59:37.000]  База данных тоже. Уж тем более удаленный рабочий стол, который RDP либо Windows Remote Desktop,
[59:37.000 --> 59:44.000]  это решено еще то. Но все-таки, если вам нужно этим пользоваться на локальном компьютере,
[59:44.000 --> 59:48.000]  и у вас-то что-то прикрыто Firewall-ом, что тут можно поделать?
[59:48.000 --> 59:54.000]  Опять же, есть команда SSH, это наш все. У SSH есть замечательная штука,
[59:54.000 --> 59:59.000]  как туннелирование каких-то отдельных портов. То есть помимо терминала
[59:59.000 --> 01:00:06.000]  предоставляется функциональность проброса отдельных портов уже по защищенному каналу.
[01:00:06.000 --> 01:00:09.000]  На слайде нарисованы опции командной строки, которые нужно дописать.
[01:00:09.000 --> 01:00:14.000]  Например, если вы хотите, чтобы локально работать... У вас же база данных начались, да?
[01:00:14.000 --> 01:00:19.000]  Подгресс QL или что у вас? Да, на подгрессе.
[01:00:19.000 --> 01:00:24.000]  Так вот, подгресс у вас может быть либо локально поднят, да, DataGrip вы, наверное, вам показывали.
[01:00:27.000 --> 01:00:29.000]  Почему нельзя?
[01:00:30.000 --> 01:00:34.000]  Вот DataGrip, да, вы можете подключиться уже с ознанной, либо на локальном компьютере, либо на удаленном.
[01:00:34.000 --> 01:00:41.000]  С локальным компом все более-менее понятно, все просто, что если у вас база данных находится где-то на удаленном сервере.
[01:00:41.000 --> 01:00:47.000]  Варианта два. Либо открывать на удаленном сервере порт 5.4.3.2 подгресс QL,
[01:00:47.000 --> 01:00:55.000]  и тем самым дать кучу возможностей хакерам, либо просто прокинуть этот порт.
[01:00:55.000 --> 01:00:59.000]  Кстати, в DataGrip это настраивается в параметрах подключения по SSH.
[01:00:59.000 --> 01:01:03.000]  То есть можно накликать, не обязательно ручками запускать отдельный SSH7.
[01:01:03.000 --> 01:01:11.000]  И тем самым пробрасывать трафик уже через вашу SSH-сессию.
[01:01:11.000 --> 01:01:19.000]  Так, ладно, на этом у меня все. Картинка это визуализация огненной стены от бута Рую Дали.
