[00:00.000 --> 00:16.440]  Всем добрый день! В прошлый раз мы остановились на том, что обсудили теорему о поиске точек
[00:16.440 --> 00:24.680]  сочинения в неориентированных графах. Напомню, что мы доказали. Мы доказали следующий результат,
[00:25.520 --> 00:33.960]  что если нам дан мы не ориентированный граф, то что можно сказать.
[00:33.960 --> 00:40.460]  Вот если дан мы не ориентированный граф и мы запустили DFS на таком графе,
[00:40.460 --> 00:45.300]  со старта вершины R, то вершина R будет являться точкой сочинения тогда и
[00:45.300 --> 00:48.760]  только тогда. То есть, вершина, которая является корнем будет точкой сочинения тогда и только
[00:48.760 --> 00:57.960]  тогда, когда у нее в дереве обхода в глубину более одного сына. Вот, это первое. А второе,
[00:57.960 --> 01:08.520]  второе, второе, у нас было следующее. Что если вершина U не совпадает со стартовой точкой DFS,
[01:08.520 --> 01:13.400]  то есть не является корнем дерева обхода, то она точка сочинения тогда и только тогда,
[01:13.400 --> 01:26.680]  когда у нее есть сын, из которого нельзя попасть в предку вершины U. Следующая вещь. Вот у
[01:26.680 --> 01:37.840]  вас есть вершина U, у нее есть сын V, тут какие-то предки. И вот если отсюда нельзя попасть в
[01:37.840 --> 01:47.960]  предков, то вершина U является точкой сочинения. Что еще мы сделали? Мы рассмотрели две
[01:47.960 --> 01:52.680]  характеристики графа, первая это, точнее, характеристики вершины. Это time in, то есть время
[01:52.680 --> 01:58.240]  обнаружения, собственно так, как мы обсуждали на лекции по DFS, и вереновую характеристику time up,
[01:58.240 --> 02:03.600]  то есть та высота, на которую можно подняться, двигать только по ребрам дерева и одному обратному
[02:03.600 --> 02:08.120]  ребру. Ну двигаться можно только по направлению, которое задано естественным обходом графа. В том
[02:08.120 --> 02:13.200]  смысле, что если вы располагаете вершины сверху вниз, то есть предки расположены выше, а потомки
[02:13.200 --> 02:18.880]  ниже, то ребра дерева вы направляете сверху вниз, а обратные ребра снизу вверх. Так вот, если вам
[02:18.880 --> 02:22.720]  разрешено двигаться только по ребрам дерева и по одному обратному ребру, то вот time up это то,
[02:22.720 --> 02:28.840]  та высота, на которую можно подняться, используя только одно обратное ребро. Ну и мы сказали,
[02:28.840 --> 02:35.880]  что условие 2 теоремы, оно на самом деле в точности совпадает с вот таким условием,
[02:35.880 --> 02:45.040]  что существует C&V, у которого time up больше либравен, чем time in A2. Ну и в конце мы коротко
[02:45.040 --> 02:50.120]  обсудили, как вот эту самую характеристику time up можно считать. Ну time up это, собственно,
[02:50.120 --> 02:56.200]  минимум из time in для текущей вершины, минимум из всех time in для вершин, в которые идут обратные
[02:56.200 --> 03:04.600]  ребра, и time up для всех вершин, в которые ведут ребра дерева. Ну и соответственно,
[03:04.600 --> 03:09.800]  что мы понимаем? Мы понимаем следующее, что time in можно высчитывать прямо в процессе обхода
[03:09.800 --> 03:18.280]  в глубину, time up тоже можно высчитывать прямо при обходе в глубину. Давайте коротко опишем,
[03:18.280 --> 03:33.720]  у нас есть цикл. DFS visit, вот граф G, родитель P и вершины V. Ну опустим там все части,
[03:33.720 --> 03:42.120]  связанные с цветами, с посещением. Давайте просто рассмотрим основной цикл. For VU in.
[03:42.120 --> 04:02.320]  Среди соседей вершины V. Смотрим, значит, если VU это обратное ребро, вот как определить обратное
[04:02.320 --> 04:08.080]  ребро или нет, мы разбирали. Понятно, что если у нас ребро ведет в серую вершину, то мы встретили
[04:08.080 --> 04:14.080]  обратное ребро. Вот, значит, если это обратное ребро, то что мы делаем? Вот смотрим на эту
[04:14.080 --> 04:19.600]  формулу. Если мы видим, что у нас есть ребро, который ведет, точнее, есть обратное ребро,
[04:19.600 --> 04:25.920]  которое ведет в какую-то вершину back, то мы можем time up обновить до time in not back. Точнее,
[04:25.920 --> 04:48.640]  написать следующее. Time up от V равно minimum из time up от V и time in not U. Ну а далее,
[04:48.640 --> 05:00.040]  если VU это ребро дерева, то что мы делаем? Если мы видим нового сына, то есть видим
[05:00.040 --> 05:13.920]  белую вершину, точнее, видим ребро дерева, то мы увеличиваем число детей для вершины V. Это первое.
[05:13.920 --> 05:25.960]  Второе. Мы можем репурсивно запустить DFS visit от вершины U. Ну и дальше, в этот момент, после того,
[05:25.960 --> 05:32.560]  как у нас закончился вызов DFS visit для вершины U, что мы знаем? Ну для нее был корректно посчитана
[05:32.560 --> 05:40.080]  характеристика time up. Time up от U. То есть мы прошли в эту вершину, DFS там как-то завершился,
[05:40.080 --> 05:45.720]  соответственно, time up для вершины U уже был посчитан. Ну и все, в этот момент мы уже можем выполнить
[05:45.720 --> 06:09.320]  проверку. Если вершина V не является корнем, и time up от U больше либо равен, чем time in not V,
[06:09.320 --> 06:30.760]  то просто пишем, что V это точка сочленения. Ну и в конце проверяем, если вершина V все-таки была
[06:30.760 --> 06:36.360]  корнем. Ну в конце, в смысле, после того, как весь цикл завершился, проверяем, если вершина V была
[06:36.360 --> 06:53.280]  корнем и число ее детей больше, чем один, то V это точка сочленения, articulation point. Ну,
[06:53.280 --> 06:57.760]  идейно понятно, да? То есть вот, то есть мы буквально воспользовались двумя формулами. То есть вот этой
[06:57.760 --> 07:05.280]  формулой. Здесь U и V у нас поменены местами, не важно, да? Вот, то есть мы воспользовались вот этой
[07:05.280 --> 07:11.520]  формулой внутри этого U и V. То есть если это условие выполняется, то значит V это точка сочленения.
[07:11.520 --> 07:18.320]  Ну и плюс в процессе нашего обхода в глубину мы подсчитывали еще и time up. То есть time up обновили
[07:18.320 --> 07:35.360]  здесь. А, и time up на самом деле нужно было обновить здесь. Давайте, тут мы забыли. V это та вершина,
[07:35.360 --> 07:39.080]  из которой мы вызываем, а U это та вершина, которую мы сейчас будем обрабатывать. Да,
[07:39.080 --> 07:46.120]  вот тут еще надо, конечно, писать обновление time up. Вот, если мы встретили ребро дерева,
[07:46.120 --> 08:06.160]  то time up от V это минимум из time up от V и time up от U. Теперь все нормально. То есть time up
[08:06.160 --> 08:10.760]  обновляем здесь, когда видим обратное ребро, и time up обновляем здесь, да, когда видим ребро
[08:10.760 --> 08:19.080]  дерева. Все, ну а дальше пользуемся критерием. То есть либо этим, либо если это корень,
[08:19.080 --> 08:32.280]  то спрашиваем про числа детей уже в самом конце. Articulation point, точка сочленения.
[08:32.280 --> 09:00.640]  Ну вот. Так, на этом с точками сочленения все. Теперь перейдем к реберному аналогу.
[09:00.640 --> 09:19.040]  Точек сочленения – это мосты. Ну что такое мосты? То есть мосты – это то же самое,
[09:19.040 --> 09:33.640]  что точка сочленения, но только для ребер. То есть мост – это ребро в неориентированном графе,
[09:33.640 --> 09:56.360]  такое что, давайте так не такое что, а удаление которого приводит к увеличению компонент связности.
[09:56.360 --> 10:10.000]  Например, вот такой граф. Вот это ребро – это мост. Понятно, что если мы удалим это ребро, то у нас
[10:10.000 --> 10:14.480]  граф развалится на две компоненты. При этом вот это, вот это и вот это ребро не являются мостами.
[10:14.480 --> 10:22.480]  Удаление любого из этих трех ребер не приводит к развалу графа. Отдельно стоящее ребро тоже
[10:22.480 --> 10:32.080]  является мостом и так далее. Ну и хорошая новость состоит в том, что для мостов критерии абсолютно такое же.
[10:32.080 --> 10:50.480]  В общем, поиск мостов аналогичен поиску точек сочленения за исключением двух вещей.
[10:50.480 --> 11:12.160]  Значит, первый. Нет особого случая корня. Ну понятно, мост по себе не может являться корнем,
[11:12.160 --> 11:19.040]  поэтому про корень тут в принципе можно не говорить, то есть отдельно рассматривать
[11:19.040 --> 11:35.200]  случай корня не нужно. Ну и второй момент. Нестрогое неравенство нужно заменить на строгое.
[11:35.200 --> 11:50.920]  То есть вот здесь. Вот это неравенство просто заменяем не строгое на строгое. И все начинает
[11:50.920 --> 12:17.320]  работать. Ну то есть УВ мост, У предок, В сын. Если таймин от У строго меньше,
[12:17.320 --> 12:28.920]  чем таймап от В. Доказательство проводить не буду, потому что оно абсолютно аналогично
[12:28.920 --> 12:33.480]  предыдущему. Единственное отличие, почему здесь возникает строгое неравенство. Ну смотрите,
[12:33.480 --> 12:41.760]  вот идейно. Вот у меня была вершина У, у нее был сын В. Вот раньше, смотрите, раньше, когда у меня,
[12:41.760 --> 12:50.880]  да, и тут какое-то дерево растет. Вот раньше, когда у меня были ребра, которые вели В, меня это устраивало.
[12:50.880 --> 12:58.960]  То есть если из под дерева В, то есть точнее из вершины В, я не мог добраться в предков,
[12:58.960 --> 13:03.560]  но при этом мог добраться на вершину У, вот на эту высоту. Меня это устраивало. Почему? Потому что
[13:03.560 --> 13:07.280]  если я удалю вершину У, то у меня вместе с ней удалятся все вот эти ребра. Соответственно,
[13:07.280 --> 13:12.000]  компонента отвалится. Поэтому у меня был неравенство не строгое. Мне можно было подниматься в У,
[13:12.000 --> 13:18.880]  нельзя было в предков. А в случае мостов не работает. Я хочу проверить, является ли УВ мостом.
[13:18.880 --> 13:24.200]  Но вот если помимо этого ребра у меня есть еще какие-то ребра, которые ведут в У, вот это ребро
[13:24.200 --> 13:29.040]  перестает быть мостом. Потому что я его удалю, и при этом вот эта вершина остается связанной
[13:29.040 --> 13:35.920]  со всем остальным под графом. Поэтому я заменяю неравенство на строгое. То есть вот такие вот
[13:35.920 --> 13:40.920]  ребра мне запрещены. То есть если у меня все ребра ведут из этой компоненты в эту же компоненту,
[13:40.920 --> 13:49.040]  то все плохо. Потому что существует только одно ребро УВ, которое связывает граф повыше с под
[13:49.040 --> 14:06.720]  деревом В. Тут все абсолютно то же самое, только вот эта штука не нужна, потому что проверяется
[14:06.720 --> 14:30.000]  случай корня. Ну и вот тут. Тут У. Тут мы, к сожалению, поменяли. Давайте тут поменяем. Тут будет У. Тут У, тут В.
[14:36.720 --> 14:55.040]  Ну и так далее. Вот.
[14:55.040 --> 15:21.800]  Ну теперь У. Еще раз вопрос можно? Нет, это все же стоит под ИФОМ.
[15:21.800 --> 15:38.480]  Нет, таймап мы обновляем после DFS-визит. Ну то есть идея какая? Мы запустили DFS-визит от вершины В.
[15:38.480 --> 15:44.680]  Ну теперь уже от вершины В. Вот. И таймап для В уже посчитан. Соответственно вот тут мы спокойно
[15:44.680 --> 16:00.200]  можем его использовать. Вот. Так, ну с мостами то же самое, только теперь вместо У из точки сочинения
[16:00.200 --> 16:13.000]  мы пишем. Ребро ВУ является мостом. Вот и все. Вот этот случай убираем. И вот тут проверку на корень
[16:13.000 --> 16:19.480]  тоже убираем. В остальном все то же самое. Да, ну и знак меняем с нестрогого на строгое.
[16:19.480 --> 16:36.000]  Ну и последнее, что хотелось бы сказать про мосты, это доказать одну интересную теорему,
[16:36.000 --> 17:02.960]  а именно теорему Робинса. Звучит она следующим образом. Связанный граф G сильно ориентируем,
[17:02.960 --> 17:28.000]  тогда и только тогда, связанном графе G нет мостов. Что значит граф сильно ориентируем? Ну смотрите,
[17:28.000 --> 17:35.440]  вот у меня есть неориентированный граф. Граф буду называть сильно ориентированным, если я могу ввести
[17:35.440 --> 17:41.400]  ориентацию на ребрах так, что у меня сохранится свойство сильной связности. Да, ну то есть если
[17:41.400 --> 17:45.880]  у меня дан неориентированный граф, и он связан, что это означает? Это означает, что из любой вершины
[17:45.880 --> 17:50.600]  я могу добраться до любой другой. Вот. А сильная ориентированность говорит следующее, что ну давайте
[17:50.600 --> 17:56.120]  я просто нарисую как-нибудь стрелочки на ребрах. И вот если у меня получится нарисовать стрелочки так,
[17:56.120 --> 17:59.720]  что у меня сохранится свойство сильной связности, то есть из любой вершины я по-прежнему смогу
[17:59.720 --> 18:06.240]  добраться до любой другой, то я буду говорить, что у меня граф сильно ориентируем. Окей? Да, что если
[18:06.240 --> 18:11.280]  можно так сделать, то граф сильно ориентируем. Так вот оказывается, что так можно сделать в том и
[18:11.280 --> 18:17.000]  только в том случае, если у меня в графе нет мостов. Если хотя бы один мост есть, то все. Беда.
[18:17.000 --> 18:38.360]  Давайте докажем. Ну, в одну сторону. Значит пусть у меня граф сильно ориентирован,
[18:38.360 --> 18:44.160]  при этом есть мост. В изначальном графе был мост. Ну, давайте его рассмотрим. Значит, как выглядит
[18:44.160 --> 18:53.480]  любой мост? Значит, есть ребро, которое связывает какие-то две компоненты связности. Так, ну по
[18:53.480 --> 18:57.440]  условию, точнее вот по предположению, у меня граф сильно ориентирован. То есть я могу вести ориентацию
[18:57.440 --> 19:02.640]  на ребрах. Соответственно, на этом мосте я тоже как-то веду ориентацию. То есть, ну допустим, без ограничения
[19:02.640 --> 19:19.000]  общности. Без ограничений общности будем считать, что сильная ориентация заносится так, что у меня
[19:19.000 --> 19:31.320]  ребро идет от вершины У к вершине В. Так, и что тогда получается? Да. Но из этого следует, что из В нельзя
[19:31.320 --> 19:42.720]  попасть в У. Пришли противоречию. То есть, грубо говоря, мост это как раз те ребра, которые ориентировать
[19:42.720 --> 19:51.960]  нельзя. Если вы их ориентируете, то все, обратный путь вам будет закрыт. Так, ну и обратно. Обратно
[19:51.960 --> 19:57.400]  докажем конструктивно. То есть прямо предъявим сейчас ориентацию графа, если в графе нет мостов.
[19:57.400 --> 20:13.880]  Смотрите, давайте просто возьмем и запустим DFS на этом графе. И будем ориентировать ребра следующим
[20:13.880 --> 20:33.640]  образом. Да, и ориентируем ребра по направлениям ребер дерева. То есть, от предков потомкам.
[20:33.640 --> 20:59.440]  И направлением ребер обратных ребр. Ровно то, что мы делали раньше. Раньше мы делали вот здесь.
[20:59.440 --> 21:04.920]  Помните, мы запускали обход DFS и говорили, что ребра дерева будут ориентированы так, что ребра
[21:04.920 --> 21:09.360]  дерева ведут от предков потомкам. Если у меня есть обратное ребро, то ориентируем его по направлению
[21:09.360 --> 21:13.760]  потомка к предку. Ну, собственно, как раз по направлению обхода. По направлению обнаружения этих самых
[21:13.760 --> 21:26.560]  ребер. То есть, естественная ориентация довольно. Вот. Ну и, собственно, утверждается, что вот эта
[21:26.560 --> 21:37.520]  ориентация, как раз таки, будет сильной ориентацией графа. Почему? Потому что следующая вещь. Чтобы
[21:37.520 --> 22:06.480]  показать сильную связность, достаточно доказать, что корень дерева DFS достижим из
[22:06.480 --> 22:21.920]  любой вершины. Почему это так? Ну, смотрите, я как-то ориентировал граф и хочу доказать, что он сильно
[22:21.920 --> 22:27.200]  связан. Так вот, я утверждаю, что он будет сильно связан тогда и только тогда, когда корень достижим
[22:27.200 --> 22:32.280]  из любой вершины. Ну, почему это так? Потому что, если я из любой вершины могу добраться до корня,
[22:32.280 --> 22:36.960]  то это значит, что из любой вершины я могу добраться до корня, а от корня могу добраться до любой другой
[22:36.960 --> 22:47.720]  вершины. Потому что это дерево. Ну вот, здесь есть мосты, но давайте представим себе, что вы из любой
[22:47.720 --> 22:52.920]  вершины можете добраться до корня. Ну, что это тогда означает? Вот, допустим, вам хочется построить путь
[22:52.920 --> 22:58.360]  из тройки в ноль. Как это сделать? Ну, вы сначала идете в корень, а потом из корни спускаетесь,
[22:58.360 --> 23:07.920]  куда вам надо. Понятно? Точно? Всем понятно? Поэтому самая главная проблема — это из любой вершины
[23:07.920 --> 23:12.800]  добраться до корня. Если вы поднялись в корень, то все, до любой другой вершины вы спокойно дойдете.
[23:12.800 --> 23:19.720]  Потому что ребра так. Потому что ребра идут от предков к потомкам, а корень — это предок вообще всех
[23:19.720 --> 23:48.560]  вершин. Так, ну а почему это так? Вот, отлично, да. Это так, потому что в графе нет мостов. А из этого что
[23:48.560 --> 24:17.560]  следует? Что для любой пары УВ, где У — это предок, В — это сын, time up от В больше либо равен,
[24:17.560 --> 24:43.040]  чем time in от У. То есть вот у вас есть ребро УВ. Почему строго? Нет, все нормально. Нет? Сейчас,
[24:43.040 --> 24:53.920]  или наоборот должно быть? Не, наоборот же должно быть. Вот так. То есть из вершины В я могу подняться в У или выше.
[24:53.920 --> 25:10.400]  Ну, то есть вот. Из вершины В я могу подняться в У или выше. Ну, это отрицание вот этого условия.
[25:10.400 --> 25:23.720]  То есть там time in больше либо равно, чем time up от В. Вот. То есть что это значит? Вот в какой бы
[25:23.720 --> 25:31.940]  вы в вершине не находились, вы всегда по обратным ребрам сможете попасть хотя бы сюда. А если
[25:31.940 --> 25:37.520]  смогли попасть сюда, то что это значит? Мы применяем ту же самую операцию. Раз вы оказались здесь, то
[25:37.560 --> 25:45.080]  отсюда вы можете подняться куда-нибудь повыше. Ну и так далее. Понятно? То есть из любой вершины вы
[25:45.080 --> 25:50.120]  можете подняться чуть выше. Ну а бесконечно выше-выше вы подниматься не можете. Рано или поздно вы
[25:50.120 --> 26:10.240]  пойдете в корень? Ну, все. То есть двигаясь по ребрам дерева можно... ребрам дерева и обратным
[26:10.240 --> 26:29.200]  ребрам и обратным можно попасть в предка. Ну а из этого следует можно добраться до корня.
[26:29.200 --> 26:47.600]  Ну все. Давайте еще раз проговорю, что мы сделали, как мы доказали. Нам нужно доказать, что если у нас
[26:47.600 --> 26:52.800]  в графе нет мостов, то мы можем из любой вершины добраться... видя некоторую ориентацию на графе,
[26:52.800 --> 26:58.440]  мы можем добраться из любой вершины до любой другой. Я предлагаю ориентировать граф согласно
[26:59.000 --> 26:59.960]  ребрам дерева и обратным ребрам. Соответственно, у меня
[27:01.660 --> 27:07.980]  сохранится свойство сильной связности в том или только в том случае, если из любой вершины
[27:07.980 --> 27:12.560]  я могу добраться до корня. Из любой вершины я добираюсь до корня. А потом из корня я добираюсь
[27:12.560 --> 27:18.080]  до любой другой вершины. Почему это верно? Почему из любой вершины я могу добраться до
[27:18.080 --> 27:25.040]  корня? Ну, ровно потому, что у меня нет мостов в графе. Нет просто мостов. А если у меня в графе
[27:25.040 --> 27:29.600]  нет мостов, то это значит, что для любой пары предок-сын выполнено вот это неравенство.
[27:29.600 --> 27:36.860]  А что говорит это неравенство? Это неравенство говорит, что из сына я могу подняться своего
[27:36.860 --> 27:43.160]  предка или даже еще выше. Но если из любой вершины я могу подняться в предка или еще выше, то двигаясь
[27:43.160 --> 27:55.760]  вот так вот по предкам, я могу добраться до корня. Ну все, окей? Все, разбрались? Ну вот,
[27:55.760 --> 28:12.600]  такой интересный факт. Так, давайте перейдем. Так, на этом надо сделать такую паузу и сказать,
[28:13.080 --> 28:19.160]  что мы закончили просмотров материал второго модуля. Первый модуль был посвящен деревьям,
[28:19.160 --> 28:26.040]  второй обходом на графах. Сейчас мы перейдем к третьему модуле, который будет посвящен,
[28:26.040 --> 28:31.080]  ну так условно назовем, полезной информации на ребрах. То есть раньше мы на ребрах ничего такого
[28:31.080 --> 28:35.480]  не писали, а сейчас у нас на ребрах будет какая-то информация, какие-то числа и так далее. И будем
[28:35.480 --> 28:46.520]  пытаться как-то обрабатывать все это. Но, видимо, после перерыва. Так, я привел в порядок тот алгоритм,
[28:46.520 --> 28:53.360]  который мы писали. Теперь кажется, что все консистентно и с теоремой, которую мы доказывали,
[28:53.360 --> 28:59.480]  и с другими обозначениями. В общем, полный псевдокод выглядит так. Давайте еще раз. Изначально
[28:59.480 --> 29:05.840]  таймин и таймап, они равны для вершины У. Мы просто там присваиваем не текущий, а увеличиваем счетчик
[29:05.840 --> 29:10.600]  и присваиваем это значение. Дальше проверяем, является ли наша вершина корнем. То есть она корень,
[29:10.600 --> 29:15.720]  если у нее не было предка. Так, можно потише, пожалуйста. То есть она корень, если у нее не было
[29:15.720 --> 29:20.480]  предка. Ну и число детей в данный момент у нее ноль. Дальше, собственно, в цикле проходимся по всем
[29:20.480 --> 29:26.400]  соседям. Вот если встретили обратное ребро, то мы обновляем таймап. Ну, мин равно таймин от В. Ну,
[29:26.400 --> 29:31.080]  мин равно, в смысле, равно минимум из текущего значения вот этого значения. Вот. Если это ребро
[29:31.080 --> 29:37.400]  дерева, то увеличиваем число детей, запускаем default visit, обновляем таймап. И с помощью критерия
[29:37.400 --> 29:44.600]  теоремы проверяем, является ли вершина У точка сочинения. Вот. При этом этот критерий, да,
[29:44.600 --> 29:49.280]  вот это вот условие, оно годится только, если вершина У не является корнем. Вот. Соответственно,
[29:49.280 --> 29:53.000]  как только этот цикл заканчивается, мы проверяем второй критерий. Если вершина У изначально была
[29:53.000 --> 29:57.560]  корнем, да, вот из root, и у нее больше одного ребенка мы обнаружили в процессе обхода в глубину,
[29:57.560 --> 30:09.840]  то значит У тоже корень, ой, тоже точка сочинения из АП. Окей. Вот. Так. А тема,
[30:09.840 --> 30:32.480]  которую мы переходим, называется потоки. Потоки в графах. Это вообще о чем? Вот. Представьте себе,
[30:32.480 --> 30:57.360]  что у вас есть какая-то сеть труб. То есть вам дан некоторый ориентированный граф,
[30:57.360 --> 31:08.920]  вот задан некоторый ориентированный граф, и задано две выделенные вершины. Source,
[31:08.920 --> 31:16.360]  то есть источник, и sync, stock. Исток, исток. Значит, что вам известно? Известно, что источник
[31:16.360 --> 31:23.240]  продуцирует, ну что может течь по трубам? Ну, в общем, что-то он продуцирует, в общем,
[31:23.240 --> 31:28.280]  какую-то жидкость, ну или какое-то количество единиц товара. Вот. При этом там потенциально
[31:28.280 --> 31:33.720]  бесконечно много. И есть, собственно, stock или target, который может этот товар в себя принять,
[31:33.720 --> 31:38.800]  тоже сколь угодно большое количество. Но при этом есть ограничение. И ограничение заключается в том,
[31:38.800 --> 31:44.120]  что пропускная способность труб или дорог, она ограничена. Ну скажем, здесь вы можете максимум
[31:44.120 --> 31:53.480]  пустить пять единиц, здесь три единицы, здесь две, здесь четыре, здесь три, два, шесть, один,
[31:53.480 --> 32:03.880]  три, десять. То есть по каждому ребру можешь протекать ограниченное что? Одно ребро осталось,
[32:03.880 --> 32:14.560]  вот это пусть тоже три будет. Вот. То есть пропускная способность каждой трубы ограничена.
[32:14.560 --> 32:20.720]  Ну и соответственно задача в чем заключается? Ну задача заключается в том, чтобы каким-то образом,
[32:20.720 --> 32:26.080]  ну то есть решить задачу логистики, каким-то образом направить товары по дорогам или жидкость
[32:26.080 --> 32:32.200]  по трубам так, чтобы протекало максимальное количество того, что вы там пускаете из источника в
[32:32.200 --> 32:41.960]  синг, т.е. в таргет. Ну то есть давайте формально попробуем описать. Формально что у нас есть?
[32:41.960 --> 32:58.600]  Формально у нас есть граф, который будем называть транспортной сетью. Вот такая что у нее на парах
[32:58.640 --> 33:07.080]  вершин задана некоторая весовая функция, точнее capacity. В смысле пропускная способность. То есть capacity
[33:07.080 --> 33:22.200]  это функция на парах вершин в, ну не варь, давайте от нуля до плюс бесконечности. Вот. То есть сув
[33:22.200 --> 33:47.400]  максимальное число единиц товара из ув. При этом если ув принадлежит е, тогда это только тогда,
[33:47.400 --> 33:55.640]  когда сув больше нуля. Вот. То есть между какими-то парами, парами этих, не знаю, городов, узлов,
[33:55.640 --> 34:00.000]  у нас ничего протекать не может. Например, между вот этим, вот этой парой ничего протекать не
[34:00.000 --> 34:05.160]  может. Условно можно считать, что между ними пропускная способность равна нулю. Вот. А между
[34:05.160 --> 34:08.720]  этими вершинами ребро есть. Соответственно на нем задана некоторая положительная пропускная способность.
[34:08.720 --> 34:24.560]  Вот. Ну и сдача заключается в чем? Значит, пусть f из тоже пар v в r поток,
[34:24.560 --> 34:39.160]  такое что для любой пары uv, uv меньше и равен чем cuv. Ну, давайте скажем заодно, что больше и
[34:39.160 --> 34:46.880]  равен чем 0. Вот. То есть нам необходимо пустить какой-то единиц товара f по каждому ребру так,
[34:46.880 --> 34:52.560]  чтобы вот эти все условия удовлетворялись. Ну, давайте здесь какой-нибудь попробуем пустить.
[34:52.560 --> 35:01.920]  Допустим, здесь пустим. Сколько можно тут пустить? Давайте пустим 4. Здесь пустим 2. Тогда здесь
[35:01.920 --> 35:10.920]  пройдет тоже 2. Соответственно отсюда можем пустить. Давайте пустим 3 отсюда и 1 отсюда. Да? То есть видно,
[35:10.920 --> 35:26.440]  что все пока. Где? Сюда? Почему? Все нормально? Да, входит 6. Да, давайте тут 4, тут 2. Вот. Нормально?
[35:26.440 --> 35:35.640]  Дальше. Нет. Да, если мы сюда пустили 4, давайте отсюда пойдет 2. А отсюда пойдет оставшееся 2.
[35:35.640 --> 35:46.040]  Значит, здесь пошло 2. Соответственно давайте 1 пустим сюда, 1 пустим сюда. Да, и тогда сюда
[35:46.040 --> 35:54.920]  дополнительно еще 1. 3. Ну, тогда отсюда пойдет 2, отсюда пойдет 1. Ну, кажется, все нормально, да? Вот.
[35:54.920 --> 35:58.560]  То есть по этому ребру пустили 4 единицы, хотя пропускная способность 5. Здесь пустили 2 единицы,
[35:58.560 --> 36:06.160]  хотя пропускная способность 3. Так, здесь две единицы. Так, тут 6, 6. Так, тут 5, 5. Ну, кажется,
[36:06.160 --> 36:14.000]  все остальное нормально. То есть черным я обозначил поток, красным пропускные способности. Так,
[36:14.000 --> 36:21.640]  ну и какой суммарный поток у меня течет из источника из стока в сток? 6. Вот эту штуку
[36:21.640 --> 36:37.280]  будем назвать величной потока. Можно пустить больше? Да, ну как минимум можно увеличить на 1.
[36:37.280 --> 36:45.920]  Да? Ну, как минимум. Ну вот, если отсюда пущу 5 единиц, здесь тогда я могу увеличить на 1, здесь
[36:45.920 --> 36:49.540]  тоже могу увеличить на 1, здесь могу увеличить на 1. Соответственно, поток, который был найден, не
[36:49.540 --> 36:55.000]  не максимально. Соответственно, мы сейчас займемся вопросом, а как искать
[36:55.000 --> 36:58.780]  максимальный поток вот в таких сетях. Да, нужно еще, наверное, написать дополнительные
[36:58.780 --> 37:03.100]  условия. Вот как вы правильно отметили, у меня ни в одном вот во внутренних вершинах
[37:03.100 --> 37:06.740]  вот эта вот самая жидкость или этот самый товар накапливаться не может. То есть
[37:06.740 --> 37:12.100]  складов вот в этих вершинах у меня нет. То есть вот сколько в вершину пришло единиц,
[37:12.100 --> 37:17.220]  столько же из нее должно выйти. За исключением стартовые и конечные вершины, естественно.
[37:17.220 --> 37:22.460]  То есть во внутренних вершинах у меня ничего не накапливается. Ну такое первое
[37:22.460 --> 37:29.820]  правило Киргофа. То есть сумма для любой вершины v не равный s и t. У меня сумма
[37:29.820 --> 37:42.380]  исходящего потока vpx должна совпадать с суммой входящего потока.
[37:46.980 --> 37:55.740]  Ну давайте попробуем решить как-нибудь эту задачу.
[37:56.700 --> 38:03.780]  Значит задача решается следующим образом. Ну точнее план такой. Давайте сразу построить
[38:03.780 --> 38:08.580]  поток сложно. То есть довольно сложно сразу там взять и найти максимальный поток. Как
[38:08.580 --> 38:14.580] -то назначить веса в ребрах и так далее. Давайте будем строить потихонечку. То есть по ручейку.
[38:14.580 --> 38:21.060]  То есть пустим какой-нибудь ручеек из источника в сток. Зафиксируем. Потом во
[38:21.060 --> 38:29.140]  старшейся графе тоже пустим какой-нибудь ручеек. Ну и так далее. Например. Пусть у меня тут s, тут t.
[38:29.140 --> 38:43.660]  Пусть у меня там какой-то вот такой граф. Пропускные способности следующие. Везде по единице.
[38:43.660 --> 38:56.420]  Что я собираюсь делать? Давайте я просто попробую найти какой-нибудь путь из s в t. Ну
[38:56.420 --> 39:08.460]  например вот такой. Допустим который идет вот по верхней дуге. То есть сколько я тут могу пустить
[39:08.460 --> 39:13.700]  единицы вдоль этого пути? Ну по единице. То есть тут могу пустить единицу, тут могу пустить единицу и тут
[39:13.700 --> 39:20.940]  могу пустить единицу. Отлично. То есть пустил и соответственно насытил какие-то ребра. Это был первый
[39:20.940 --> 39:25.380]  шаг. На следующем шаге снова. Давайте попробуем найти какой-нибудь путь из s в t, который проходит
[39:25.380 --> 39:30.660]  по еще не насыщенным ребрам. То есть по ребрам, которые я еще могу что-то пустить. Ну что, давайте
[39:30.660 --> 39:41.260]  пустим по нижней дуге. 1, 1, 1. Ну и казалось бы все. Я таким образом, то есть постепенно увеличивая
[39:41.260 --> 39:48.340]  мой поток, я найду максимальный. То есть план такой пока. То есть пускать там маленькие ручейки,
[39:48.340 --> 39:52.740]  до тех пор, пока я могу насытить мою сеть. Как только я не смогу найти путь из s в t,
[39:52.740 --> 39:55.860]  но в данном случае я не могу найти путь из s в t, потому что у меня вот эти все ребра, они
[39:55.860 --> 40:03.140]  сблокированы. Все, как только я не могу найти путь, я на этом останавливаюсь. Все ли понимают,
[40:03.140 --> 40:09.660]  что этот путь ведет в никуда? Пока. Смотрите, да, то есть это я так хорошо просто подобрал пути,
[40:09.660 --> 40:15.220]  что они меня так хорошо себя ведут. Но на самом деле может возникнуть немного другая ситуация.
[40:25.860 --> 40:34.020]  Что если я взял... Ну снова, тут пропускные способности везде по единице. То есть тут единица,
[40:34.020 --> 40:44.540]  тут единица. Единица, единица. Что если я мой первый поток пустил как-то не очень? Ну скажем,
[40:44.540 --> 40:49.340]  нашел путь вот такой. Здесь пустил единицу, здесь пустил единицу, здесь пустил единицу. То есть пошел
[40:49.340 --> 40:55.700]  вот так, пустил единицу здесь, пустил единицу здесь. Вот. То есть это ручеек, да, я его пустил,
[40:55.700 --> 41:04.620]  нашел путь из s в t, все нормально. Так, что я делаю на втором шаге? Плачу, да, ну то есть все. То есть я
[41:04.620 --> 41:09.340]  прохожу сюда, а отсюда уже пути никуда не могу, то есть никакой путь другой найти не могу. Это
[41:09.340 --> 41:13.100]  ребро заблокировано, поэтому я могу пройти, но уже из этой вершины я никуда пройти не могу,
[41:13.100 --> 41:20.260]  потому что это ребро заблокировано. Все, беда. То есть если я ищу жадным способом мой поток,
[41:20.260 --> 41:28.620]  вот в такой постановке, то все плохо. В чем здесь проблема? На самом деле проблема не в методе,
[41:28.620 --> 41:31.500]  метод нормальный. То есть с помощью такого метода мы сейчас построим оптимальные алгоритмы.
[41:31.500 --> 41:36.500]  Проблема заключается в том, что если мы в какой-то момент построили неправильный ручеек,
[41:36.500 --> 41:43.540]  неправильный поток, то у нас нет возможности его исправить. То есть нам бы хотелось сделать
[41:43.540 --> 41:48.300]  следующую вещь, что если мы видим, что вот это вот ребро мы выбрали как-то неоптимально, нам бы
[41:48.300 --> 41:52.060]  хотелось в процессе добавления новых ручейков его как-то исправлять. Ну в частном, например,
[41:52.060 --> 41:55.740]  сказать, что пустили ручеек здесь, пустили ручеек здесь в обратном направлении, то есть
[41:55.740 --> 42:00.260]  компенсировали вот этот поток, а потом пустили ручеек сюда. Тогда мы пришли ровно к вот этой
[42:00.260 --> 42:06.820]  картине. То есть если мы другой путь пустили вот так, то мы бы сказали, что путь идет сюда,
[42:06.820 --> 42:12.860]  потом путь идет сюда, который компенсирует старый поток здесь, и путь идет сюда. И тогда вдоль
[42:12.860 --> 42:18.180]  каждого ребра мы бы построили нормальный поток. Понятно, да? То есть хотелось бы как-то в процессе
[42:18.180 --> 42:27.460]  исправлять наши неправильные пути, которые мы нашли до этого. Так вот, чтобы этого достичь,
[42:27.460 --> 42:31.860]  мне придется немного поменять определение, которое я вел до этого, ну точнее, как поменять,
[42:31.860 --> 42:37.060]  наконец-то ввести эти определения, потому что это все была болтовня. Сейчас давайте попробуем как-то
[42:37.060 --> 42:44.700]  исправить это все. На самом деле, тут есть еще одна проблема. Мне очень не нравится, что у меня
[42:44.700 --> 42:52.260]  определение потока, точнее, определение величины потока, оно какое-то, точнее, вот это вот условие,
[42:52.260 --> 42:59.340]  что у меня ни в каком узле не накапливается никакая жижа, оно у меня, грубо говоря, не симметрично.
[42:59.340 --> 43:03.660]  То есть я должен отдельно рассматривать, отдельно рассматривать ребра, которые исходят из вершины,
[43:03.660 --> 43:08.060]  и отдельно рассматривать ребра, которые входят в вершину. Давайте попробуем это исправить с
[43:08.060 --> 43:14.340]  помощью симметризации потока. Давайте наконец введем определение. Каким определением потока
[43:14.340 --> 43:23.460]  буду пользоваться я? Значит, определение будет следующее. f поток в транспортной сети g,
[43:23.460 --> 43:40.980]  если f это функция топорок вершин в r, такая что она удовлетворяет следующим условиям. Первое условие
[43:40.980 --> 43:57.900]  антисимметричность f от uv равно минус f в у для любой пары в у. То есть сколько единиц у меня потока
[43:57.900 --> 44:06.100]  течет в направлении от u к v, то есть что можно сказать, что если у меня из uv течет поток равный
[44:06.100 --> 44:11.980]  единице, то я могу сказать, что из vv у меня течет поток равный минус единицы. Грубо говоря, как ток,
[44:11.980 --> 44:20.500]  положительные частицы текут в одну сторону, отрицательные в другую. Второе. Естественно,
[44:20.500 --> 44:29.140]  я хочу, чтобы мне удовлетворялось вот это соотношение. То есть я не хочу, чтобы у меня
[44:29.140 --> 44:39.060]  поток тек больше, чем у меня реально вмещает ребро. Что? Нет, вот так. Мне так устраивает.
[44:39.060 --> 44:57.140]  Так, ну и третье. Для любой вершины v неравный s и t, сумма fvx по всем x принижающим v равно 0. Вот.
[44:57.140 --> 45:08.340]  Теперь у меня формула вот эта стала симметричной. Почему? Вот смотрите, раньше у меня что было? Раньше
[45:08.340 --> 45:20.380]  у меня была вершина, у нее входило, скажем, один-два и выходило два-один. Да, вот раньше что отвечало
[45:20.380 --> 45:25.740]  условию, что у меня ни в одной вершине поток не накапливается. Ну, я отдельно считал исходящие
[45:25.740 --> 45:31.820]  ребра и отдельно считал входящие ребра. А теперь что у меня происходит? У меня помимо входящих
[45:31.820 --> 45:39.700]  ребер теперь есть симметричное ему ребро, которое течет в обратную сторону. Ну вот, антисимметричность.
[45:39.700 --> 45:45.100]  То есть это значит, что в обратном направлении течет минус одна единица потока и здесь минус две единицы
[45:45.100 --> 45:49.740]  потока. Ну и теперь, если я просуммирую по всем исходящим ребрам, то у меня как раз таки будет
[45:49.740 --> 45:59.700]  сохраняться баланс. То есть 2 плюс 1 равно минус 1, минус 2. Понятно? То есть теперь я входящие
[45:59.700 --> 46:16.500]  ребра учитываю как исходящие. Все нормально. Вот, ну еще одно определение величиной исходящего
[46:16.500 --> 46:34.700]  потока. Назовем модуль f+, который равен сумме всех потоков, которые исходят из вершины s.
[46:34.700 --> 46:45.620]  Все, что производит поток вершины s, это величина исходящего потока. Соответственно,
[46:45.620 --> 47:06.380]  величиной входящего потока назовем f с минусом, который будет равен сумме по всем потокам,
[47:06.380 --> 47:22.060]  которые входят в t. Так, так, так, так, так. Что еще раз? Нет, нет, конечно. Вы что?
[47:22.060 --> 47:29.860]  Нет, какой модуль? Вы что? Ну зачем модуль? Что вы придумываете? Ладно, давайте вот тут.
[47:29.860 --> 47:35.780]  Давайте с определением разберемся. Хорошо. Давайте вот тут. Что нам нужно? Значит, помимо прямых
[47:35.780 --> 47:49.700]  ребер мы теперь заводим и обратные ребра. Вот так, вот так, вот так. Какие у них пропускные
[47:49.700 --> 47:56.380]  способности? А, пока не понятно. У них на самом деле нет. У них пропускные способности равно нулю.
[47:56.380 --> 48:05.380]  Потому что вам разрешено опускать поток только в направлении от s к вот этой вершине. То есть
[48:05.380 --> 48:18.460]  от s к направлении от s положительного потока течь не может. Смотрите, мне разрешено
[48:18.460 --> 48:25.060]  опускать поток от этой вершины? Вот этой вершины. В обратном направлении. Мне опускать положительный
[48:25.060 --> 48:35.540]  поток запрещено. Вот. И соответственно, так как я поток симметризовал, у меня в обратном направлении
[48:35.540 --> 48:42.020]  тут течет минус один, тут течет минус один, тут течет минус один, ну и так далее. Везде, где ноль,
[48:42.020 --> 48:51.060]  у меня течет поток минус один. Минус один меньше равен, чем ноль. Поэтому все ок. То есть если у меня
[48:51.400 --> 48:58.380]  ребро идет в правильном направлении, то там у меня пропускная способность равна единице.ュ Но
[48:58.380 --> 49:05.260]  при этом есть еще куча остальных ребер, у которых пропускная способность равна нулю. Да, то есть
[49:05.260 --> 49:08.140]  ребра graph считается только те, у которых пропускная способность равна единице. При этом между всеми
[49:08.140 --> 49:14.580]  остальными парами вершин тоже есть пропускная способность, но при этом она равна нулю. Ну и при этом,
[49:14.580 --> 49:18.120]  как я сказал, у меня поток антисимметричен. То есть если у меня в этом направлении поток течет равный
[49:18.120 --> 49:22.120]  то в обратном направлении счет поток равный минус единице.
[49:22.120 --> 49:25.120]  Но при этом в обратном направлении, так как поток равен минус единице,
[49:25.120 --> 49:28.120]  а пропускная способность ноль, то второе условие тоже выполняется.
[49:28.120 --> 49:32.120]  Минус один меньше, равно нуля. Все нормально.
[49:41.120 --> 49:44.120]  Ну или вот это еще можно переписать как
[49:44.120 --> 49:54.120]  минус сумма по всем y, клянусь за чем v, в силу антисимметричности, свойства 1.
[50:00.120 --> 50:03.120]  Ну и утверждение стоит в том, что на самом деле не важно,
[50:03.120 --> 50:08.120]  какой поток, какую величину потока вы считаете, они будут равны.
[50:10.120 --> 50:12.120]  Более-менее очевидно, давайте докажем.
[50:12.120 --> 50:21.120]  Давайте просто возьмем сумму по всем x при назначении v, сумму по всем y при назначении v, f от x и y.
[50:30.120 --> 50:34.120]  Так, только на самом деле это надо убрать.
[50:36.120 --> 50:39.120]  Вот это верно сейчас для любой вершины.
[50:43.120 --> 50:44.120]  Или нет?
[50:51.120 --> 50:56.120]  Нет, это для любой вершины не равный s и t, конечно.
[50:57.120 --> 51:01.120]  Значит, рассмотрим такую сумму. Что мы про нее можем сказать?
[51:06.120 --> 51:10.120]  Во-первых, давайте выделим отдельно часть, которая относится к s.
[51:12.120 --> 51:22.120]  Здесь будет сумма по y при нежащем v, f от sy.
[51:26.120 --> 51:29.120]  И отдельно выделим часть, которая относится к t.
[51:32.120 --> 51:39.120]  Сумма по всем y при нежащем v, f от ty.
[51:40.120 --> 51:42.120]  Но и останется на что?
[51:43.120 --> 51:52.120]  Сумма по всем x неравным s и t, сумма по всем y при нежащем v, f от x и y.
[51:58.120 --> 52:00.120]  Что можно сказать про эту сумму?
[52:00.120 --> 52:02.120]  Что можно сказать про эту сумму?
[52:03.120 --> 52:04.120]  Почему?
[52:06.120 --> 52:11.120]  Да, по пункту 3 вот эта сумма, мы ее можем слопнуть в ноль.
[52:13.120 --> 52:17.120]  Точнее, вот эта штука равна нулю.
[52:18.120 --> 52:22.120]  Ну потому что для любого x неравного s и t вот эта сумма ноль.
[52:22.120 --> 52:29.120]  Соответственно, эта штука будет равна модуле f плюс,
[52:38.120 --> 52:40.120]  минус модуль f минус.
[52:40.120 --> 52:51.120]  Минус модуль f минус.
[53:11.120 --> 53:14.120]  Чем у нас там только x неравного s?
[53:15.120 --> 53:16.120]  Где?
[53:17.120 --> 53:18.120]  Ну, последняя сумма.
[53:19.120 --> 53:20.120]  Так, вот эта?
[53:21.120 --> 53:23.120]  Разве нам еще вот эту штуку x не равен t?
[53:24.120 --> 53:26.120]  Ну вот, не равен s, не равен t.
[53:27.120 --> 53:31.120]  То есть я извлек часть, которая относится к s, и часть, которая относится к t.
[53:40.120 --> 53:41.120]  Так, а что у нас стоит здесь, смотрите?
[53:42.120 --> 53:43.120]  Что у нас стоит здесь?
[53:44.120 --> 53:46.120]  Почему вот эта сумма на самом деле равна нулю?
[53:47.120 --> 53:48.120]  А да?
[53:49.120 --> 53:53.120]  Смотрите, эта сумма по всевозможным парам x и y.
[53:54.120 --> 53:58.120]  Но при этом для любого uv у меня есть f и t.
[53:59.120 --> 54:01.120]  А у меня есть f и t.
[54:02.120 --> 54:04.120]  А у меня есть f и t.
[54:05.120 --> 54:07.120]  А у меня есть f и t.
[54:08.120 --> 54:10.120]  А у меня есть f и t.
[54:11.120 --> 54:13.120]  А у меня есть f и t.
[54:13.120 --> 54:18.120]  Но при этом для любого uv у меня есть f от vu, который с обратным знаком.
[54:19.120 --> 54:23.120]  Ну короче, у меня вся эта сумма по всем парам раскладывается на пары x, y, y, x.
[54:24.120 --> 54:27.120]  Vu и uv, которые взаимно уничтожают друг друга.
[54:28.120 --> 54:31.120]  То есть на самом деле вся эта сумма изначально была равна нулю.
[54:32.120 --> 54:34.120]  В силу антисимметричности 1.
[54:35.120 --> 54:36.120]  Согласны?
[54:37.120 --> 54:39.120]  То есть в этой сумме расположены всевозможные пары.
[54:39.120 --> 54:43.120]  А всевозможные пары раскладываются на сумму f от x, y.
[54:47.120 --> 54:52.120]  У меня в этой сумме есть пары f от x, y плюс f от y, x.
[54:53.120 --> 54:57.120]  Но так как f от y, x равен минус f от x, y, это равно нулю.
[54:59.120 --> 55:01.120]  Поэтому и вся сумма целиком равна нулю.
[55:02.120 --> 55:05.120]  Ну и что я в итоге получил? Что у меня исходящий поток минус входящий поток равен нулю.
[55:06.120 --> 55:08.120]  Ну, следовательно, они равны.
[55:09.120 --> 55:14.120]  Понятно?
[55:15.120 --> 55:18.120]  Это просто как бы некоторое утверждение о корректности,
[55:19.120 --> 55:24.120]  что неважно, как вы считаете, что величина потока, которая исходит из тока, равна величине потока, который входит в поток.
[55:25.120 --> 55:28.120]  То есть неважно, как вы определяете величину потока.
[55:29.120 --> 55:31.120]  Это два эквалентных определения.
[55:32.120 --> 55:34.120]  Вот. Окей.
[55:39.120 --> 55:41.120]  Давайте теперь вернемся к нашему примеру.
[55:42.120 --> 55:47.120]  Давайте как-нибудь его покрупнее нарисуем, чтобы прям все было видно, все было понятно.
[55:52.120 --> 55:56.120]  И попробуем понять, чем симметризация потока нам помогла.
[56:09.120 --> 56:11.120]  Так, нарисуем пропускные способности.
[56:14.120 --> 56:34.120]  Здесь 1, здесь 0, здесь 1, здесь 0, здесь 1, 0, 1, 0, 1, 0, 1, 0, 1, 0.
[56:40.120 --> 56:46.120]  Так, ну и допустим, мы пустили плохой поток, который шел и прошел по диагонали.
[56:47.120 --> 56:48.120]  Что у нас получилось?
[56:49.120 --> 56:54.120]  Что здесь величина потока равна 1, здесь 1, здесь 1.
[56:57.120 --> 56:58.120]  И что еще?
[56:59.120 --> 57:01.120]  Ну и в обратном направлении у меня протекли минус 1.
[57:02.120 --> 57:09.120]  Тут минус 1, минус 1, минус 1, минус 1, минус 1.
[57:10.120 --> 57:11.120]  Ну, нулевые потоки я не буду писать.
[57:12.120 --> 57:14.120]  Во всех остальных местах у меня поток 0.
[57:15.120 --> 57:17.120]  Понятно, что все три условия для потока выполняются.
[57:18.120 --> 57:19.120]  Да, вот вон те.
[57:20.120 --> 57:22.120]  Так, ну тут понятно, S.
[57:24.120 --> 57:27.120]  Теперь давайте попробуем нод.
[57:28.120 --> 57:29.120]  Собственно, план снова прежний.
[57:29.120 --> 57:32.120]  Пускаем маленькие потоки до тех пор, пока мы можем найти путь.
[57:33.120 --> 57:35.120]  Как только пути не будет положительного, мы прекращаем работу.
[57:36.120 --> 57:39.120]  Так, давайте попробуем в таком графе теперь пустить какой-нибудь положительный путь.
[57:40.120 --> 57:41.120]  Ну, смотрите.
[57:42.120 --> 57:45.120]  Значит тут, каким есть исходящее ребро? Есть исходящее ребро вот это.
[57:46.120 --> 57:47.120]  Но по нему я ничего пустить не могу.
[57:48.120 --> 57:50.120]  Если я пущу какой-то положительный поток вдоль него, то у меня будет тут больше единицы,
[57:51.120 --> 57:53.120]  ну соответственно больше пропускной способности этого ребра.
[57:54.120 --> 57:55.120]  Все плохо.
[57:56.120 --> 57:57.120]  Давайте я попробую здесь пустить поток равный единице.
[57:57.120 --> 58:01.120]  Пускай здесь поток равный единице, здесь минус единица.
[58:02.120 --> 58:04.120]  Дальше. В этом, в эту вершину я снова попасть не могу.
[58:05.120 --> 58:06.120]  Один-один.
[58:07.120 --> 58:08.120]  А смотрите теперь вот здесь. Какая история?
[58:09.120 --> 58:11.120]  У меня есть ребро, которое ведет из этой вершины в эту вершину.
[58:12.120 --> 58:15.120]  В изначальном графе вот этого ребра не было.
[58:16.120 --> 58:17.120]  То есть изначально у него была пропускная способность ноль.
[58:18.120 --> 58:21.120]  Но теперь смотрите, если я вдоль этого ребра теперь пущу поток равный единице,
[58:22.120 --> 58:23.120]  у меня все будет нормально.
[58:24.120 --> 58:25.120]  Минус один плюс один ноль.
[58:25.120 --> 58:28.660]  1 – ноль. Ноль меньше равна нуля и так далее.
[58:28.660 --> 58:32.060]  То есть, симметризовав поток, я получил возможность
[58:32.060 --> 58:35.060]  исправлять плохие потоки. Понятно?
[58:35.060 --> 58:36.860]  То есть, по этому ребру я теперь могу пустить поток
[58:36.860 --> 58:41.500]  равный единице. Понятно? Вот.
[58:41.500 --> 58:44.300]  Давайте тут напишу плюс один.
[58:44.300 --> 58:46.600]  Плюс один минус один – ноль. Все нормально.
[58:46.600 --> 58:48.740]  Так, а здесь, соответственно, если я сюда добавил поток
[58:48.740 --> 58:51.700]  равный единице, то отсюда я должен его вычесть.
