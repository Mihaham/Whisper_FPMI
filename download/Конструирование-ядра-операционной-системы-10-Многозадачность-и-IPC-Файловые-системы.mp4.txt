[00:00.000 --> 00:12.040]  Ну, у вас, почти у всех, я уже заработал user space, поэтому
[00:12.040 --> 00:18.480]  мы продолжаем нашу тематику многозадачности и сегодня
[00:18.480 --> 00:20.600]  у нас три небольшие темы.
[00:20.600 --> 00:29.160]  В частности, мы помним, что из третьей лекции, что
[00:29.160 --> 00:32.680]  ядро обычно запускает какой-то начальный поток, начальный
[00:32.680 --> 00:36.560]  процесс, соответственно, это процесс init, например,
[00:36.560 --> 00:42.400]  в линуксе, launch.de, например, в маке, ну и так далее.
[00:42.400 --> 00:45.840]  Но это что касается первого запускаемого процесса,
[00:45.840 --> 00:50.500]  у которого пит единичка, спецнур ядра, пит нолик,
[00:50.500 --> 00:54.780]  но все остальные процессы должны быть как-то порождены
[00:54.780 --> 00:58.680]  уже в рамках работы этого процесса init, поэтому мы
[00:58.680 --> 01:02.480]  поговорим о том, как, собственно, порождаются новые процессы
[01:02.480 --> 01:06.280]  в операционных системах и немножко поговорим про
[01:06.280 --> 01:09.880]  такой механизм под названием fork.exe.
[01:09.880 --> 01:16.720]  Затем мы поговорим о том, как процессы могут общаться
[01:16.720 --> 01:19.760]  друг с другом, ну потому что системные вызовы у
[01:19.760 --> 01:22.760]  вас уже работают, то есть процессы могут общаться
[01:22.760 --> 01:26.480]  с ядром, но довольно часто мы хотим, чтобы процессы
[01:26.480 --> 01:30.480]  могли общаться и между собой, поэтому речь пойдет
[01:30.480 --> 01:35.880]  об IPC, ну или Interprocess Communication, как он может быть организован,
[01:35.880 --> 01:39.360]  и мы приведем какие-то простые примеры, которые
[01:39.360 --> 01:40.360]  будут понятны.
[01:40.360 --> 01:48.480]  Соответственно, также после этого мы доберемся до
[01:48.480 --> 01:51.200]  тех вещей, которые можно организовать поверх IPC,
[01:51.200 --> 01:54.560]  и поговорим немножко о файловых системах, потому
[01:54.640 --> 01:56.960]  что там буквально в следующей лабораторной работе у
[01:56.960 --> 01:58.960]  вас будет, соответственно, реализована файловая
[01:58.960 --> 02:04.560]  система в Neuterspace'е, поверх того IPC, который вы реализуете.
[02:04.560 --> 02:06.560]  Это будет все, что будет в файловом системе, или будет
[02:06.560 --> 02:08.560]  то, что будет в IPC?
[02:08.560 --> 02:10.560]  Все.
[02:10.560 --> 02:13.560]  То есть, ну, по операционным системам у вас, по идее,
[02:13.560 --> 02:15.560]  курс обязанных систем должен быть.
[02:15.560 --> 02:25.560]  Ну, так, что касается создания процессов?
[02:25.560 --> 02:31.560]  Ну, я думаю, что про механизм fork.exec особо объяснять
[02:31.560 --> 02:36.560]  там ничего не нужно, но все знают, как работает fork.exec.
[02:36.560 --> 02:40.560]  Ну, на всякий случай как бы напомню какие-то там
[02:40.560 --> 02:44.560]  вещи, то есть у вас есть некоторые там родители,
[02:45.560 --> 02:48.560]  соответственно, этот родитель имеет там два системных
[02:48.560 --> 02:52.560]  вызова, ну, соответственно, точнее, гидрой имеет два
[02:52.560 --> 02:53.560]  системных вызова.
[02:53.560 --> 02:56.560]  Родитель вызывает системный вызов fork, ну, понятно,
[02:56.560 --> 02:59.560]  что он вызывает некоторую там функцию из стандартной
[02:59.560 --> 03:02.560]  библиотеки, а эта стандартная библиотека уже там, через
[03:02.560 --> 03:06.560]  сколько-то там подфункций, вызывает уже системный
[03:06.560 --> 03:10.560]  вызов, задача которого сходит в том, чтобы породить
[03:10.560 --> 03:14.560]  новый процесс, то есть процесс ребенка, который
[03:14.560 --> 03:20.560]  будет отображать тот же самый контекст, что и процесс
[03:20.560 --> 03:21.560]  родителя.
[03:21.560 --> 03:26.560]  При этом, когда вы в родители вызовите fork, он вам вернет,
[03:26.560 --> 03:29.560]  соответственно, PID того процесса, который вы породили,
[03:29.560 --> 03:32.560]  то есть PID ребенка, а в ребенке он, соответственно,
[03:32.560 --> 03:33.560]  вернет нолик.
[03:33.560 --> 03:36.560]  Так вы можете отличить в своей программе, собственно,
[03:36.560 --> 03:41.560]  кто вы после вызова fork, ребенок или родитель.
[03:41.560 --> 03:48.560]  После того, как вы вызвали, соответственно, fork и оказались
[03:48.560 --> 03:52.560]  в ребенке, вы можете заменить свое тело с помощью системного
[03:52.560 --> 03:55.560]  вызова exec, в который вы передаете, соответственно,
[03:55.560 --> 03:59.560]  путь к некоторому другому исполняемому файлу, и ваш,
[03:59.560 --> 04:03.560]  соответственно, процесс заменяется на тот исполняемый
[04:03.560 --> 04:08.560]  файл, который вы передали в аргумент exec.
[04:08.560 --> 04:14.560]  Вы можете подождать в родителе завершения работы ребенка
[04:14.560 --> 04:18.560]  с помощью системного вызова wait или wait PID, то есть когда
[04:18.560 --> 04:22.560]  у вас много детей, то вы можете ждать какого-то конкретного.
[04:22.560 --> 04:25.560]  Так же вы ребенка можете завершить или послать ему
[04:25.560 --> 04:31.560]  сигнал с помощью системного вызова kill и в дальнейшем
[04:31.560 --> 04:39.560]  управлять. Понятно, что exec при такой схеме вызывать
[04:39.560 --> 04:45.560]  в целом не обязательно, то есть вы можете fork-нуть
[04:45.560 --> 04:49.560]  родительский процесс и продолжить исполняться с тем
[04:49.560 --> 04:52.560]  же состоянием, что и ваш родительский процесс.
[04:52.560 --> 04:55.560]  Например, так могут работать некоторые песочники в
[04:55.560 --> 04:57.560]  разном программном обеспечении.
[04:57.560 --> 05:04.560]  Но, тем не менее, наиболее частый механизм реализации
[05:04.560 --> 05:11.560]  схемы fork-exec, когда сразу после вызова fork возникает
[05:11.560 --> 05:20.560]  вызов exec. Вопрос. Вот представьте, что у вас есть ядерный
[05:20.560 --> 05:29.560]  вызов fork и вам предлагают написать exec в user space
[05:29.560 --> 05:33.560]  самостоятельно. Как вы думаете, можно ли это сделать
[05:33.560 --> 05:37.560]  и что для этого может понадобиться?
[05:41.560 --> 05:45.560]  У вас есть системный вызов fork и вам предлагается
[05:45.560 --> 05:49.560]  сделать вызов exec целиком реализовать user space
[05:49.560 --> 05:51.560]  без поддержки идра.
[05:55.560 --> 06:02.560]  Например, вам дадут вызов mmap или вызов mprotect.
[06:02.560 --> 06:07.560]  То есть mprotect меняет permission, mmap мапит данные.
[06:07.560 --> 06:15.560]  У нас есть истаграмма, мап мапит все фигменты.
[06:15.560 --> 06:20.560]  Единственное, что нам нужно хранить тот код, который
[06:20.560 --> 06:23.560]  это делает где-то в памяти. То есть, может быть,
[06:23.560 --> 06:26.560]  попросить уйдра нового региона себе с правами сначала
[06:26.560 --> 06:29.560]  на запись, потом поменять на выполнение. Перемешать
[06:29.560 --> 06:32.560]  туда, даже в какой-то мантудово все это делать.
[06:33.560 --> 06:40.560]  Переместить себя на лету, наверное, не очень получится.
[06:40.560 --> 06:45.560]  Потому что там relocate придется обновлять, а у вас их нет.
[06:47.560 --> 06:51.560]  Или переместить новый код.
[06:51.560 --> 06:54.560]  Заланцировать новый кусок кода, сначала writable,
[06:54.560 --> 06:57.560]  записать туда какую-нибудь функцию.
[06:57.560 --> 07:00.560]  Но это если он position-independent.
[07:00.560 --> 07:02.560]  Который это будет делать.
[07:02.560 --> 07:06.560]  Ведь код своей программы более часть времени работает
[07:06.560 --> 07:08.560]  по нормальному по своему интересу.
[07:08.560 --> 07:11.560]  Вы имеете в виду, что взять некоторый трамплин,
[07:11.560 --> 07:14.560]  разместить его в новом адресном пространстве,
[07:14.560 --> 07:17.560]  и после этого этот трамплин будет копировать уже адресное пространство
[07:17.560 --> 07:20.560]  целевого процесса. Ну да, можно, это действительно один
[07:20.560 --> 07:23.560]  из сценариев. Второй сценарий просто задействовать islr.
[07:23.560 --> 07:29.560]  То есть с помощью islr разместить новый процесс так, чтобы он просто не пересекался.
[07:29.560 --> 07:33.560]  Ну если при этом новый процесс не position-independent?
[07:33.560 --> 07:35.560]  Да, если новый процесс не position-independent, то да,
[07:35.560 --> 07:37.560]  нужна схема с трамплинами.
[07:37.560 --> 07:41.560]  Ну действительно, да, суть именно такая.
[07:41.560 --> 07:45.560]  Поэтому, в принципе, exec вполне реализуется в user space,
[07:45.560 --> 07:48.560]  но никто так не делает, потому что с органи удобно долго.
[07:48.560 --> 07:49.560]  Можно вопрос все-таки?
[07:49.560 --> 07:50.560]  Да.
[07:50.560 --> 07:54.560]  Понятно, что сам по себе орг, в принципе, зачастую полезно использовать по идее,
[07:54.560 --> 07:57.560]  но все-таки, если орг экземпляр, это такая частая инфляция,
[07:57.560 --> 08:03.560]  почему в Linux это разбито на фрае, нет общего?
[08:03.560 --> 08:06.560]  Как раз следующую фразу, которую я хотел сказать,
[08:06.560 --> 08:10.560]  вот да, это замечательно, но так сейчас никто не делает.
[08:10.560 --> 08:28.560]  Ну, формально на самом деле, формально child вот здесь, child вот здесь,
[08:28.560 --> 08:34.560]  это клон parent, соответственно, формально определяет, что запускать parent.
[08:34.560 --> 09:00.560]  Но это примерно та же схема программирования, что у вас есть, например, setJump,
[09:00.560 --> 09:01.560]  longJump.
[09:01.560 --> 09:08.560]  То есть, знаете же, вызовы в C там, setJump, longJump, они тоже возвращают разные
[09:08.560 --> 09:11.560]  соответственно коды в зависимости от того, что произошло там.
[09:11.560 --> 09:14.560]  Вы вернулись в эту точку или, соответственно, там вот сейчас
[09:14.560 --> 09:16.560]  сохранили состояние.
[09:16.560 --> 09:23.560]  И так, да, с памятью.
[09:23.560 --> 09:25.560]  Правильно.
[09:25.560 --> 09:28.560]  Соответственно, почему так никто не делает?
[09:28.560 --> 09:30.560]  Вот сразу.
[09:30.560 --> 09:33.560]  То есть первое, грубо говоря, после того, как вы поняли, что да,
[09:33.560 --> 09:37.560]  это с одной стороны действительно очень удобно, делает там безумную гибкость
[09:37.560 --> 09:40.560]  в вашей операционной системе, но это дорого.
[09:40.560 --> 09:45.560]  Поэтому первое, что, собственно, предложили, это использовать механизм copyonwrite.
[09:45.560 --> 09:52.560]  То есть, механизм copyonwrite, встраиваясь в fork.exe,
[09:52.560 --> 09:57.560]  работает по следующему принципу, что вот у вас есть адресное пространство
[09:57.560 --> 10:00.560]  там родителя.
[10:00.560 --> 10:07.560]  То есть там какое-то адресное пространство там родителя.
[10:07.560 --> 10:16.560]  И мы порождаем адресное пространство ребенка.
[10:16.560 --> 10:22.560]  При этом, соответственно, все права на запись, вот в момент вот этого порождения,
[10:22.560 --> 10:27.560]  они отбираются и, соответственно, у родителя, и у ребенка.
[10:27.560 --> 10:31.560]  То есть любое, соответственно, обращение на запись в память,
[10:31.560 --> 10:36.560]  грубо говоря, ребенка или родителя, произойдет к пейчфолту.
[10:36.560 --> 10:41.560]  То есть write это пейчфолт.
[10:41.560 --> 10:45.560]  И в момент возникновения пейчфолта произойдет ленивое копирование.
[10:45.560 --> 10:49.560]  То есть продублируется, соответственно, эта страничка.
[10:49.560 --> 10:55.560]  И, к примеру, ребенка будет своя память, а у родителя своя.
[10:55.560 --> 10:59.560]  Таким образом, в условиях, если ребенок мало изменяет память,
[10:59.560 --> 11:06.560]  а это действительно так, то есть у нас часто очень используется сразу exec после вызова forks,
[11:06.560 --> 11:11.560]  то такая схема достаточно неплохо позволяет ускорить, соответственно, процесс,
[11:11.560 --> 11:16.560]  что у вас нет копирования, и позволяет уменьшить потребление оперативной памяти.
[11:16.560 --> 11:35.560]  У родителя тоже отбираются права на запись.
[11:35.560 --> 11:39.560]  Если на старой странице родителя, соответственно, окончится мусор,
[11:39.560 --> 11:41.560]  окончится ничьи.
[11:41.560 --> 11:43.560]  Почему ничьи имеют?
[11:43.560 --> 11:46.560]  Если и родители копируют при записях, и ребенок копирует при записях.
[11:46.560 --> 11:48.560]  Ну, у вас есть refcount.
[11:48.560 --> 11:50.560]  Ну, да, можно сделать там...
[11:50.560 --> 11:54.560]  Ну, нет, то есть они что-нибудь соберутся, чтобы на этой странице дальше уже ничьи.
[11:54.560 --> 11:56.560]  Нет, нормальная реализация.
[11:56.560 --> 12:02.560]  Если refcount, грубо говоря, copyonwrite страницы равен единичке,
[12:02.560 --> 12:06.560]  то, соответственно, что-то копируют, просто изменили права на запись на эту страничку, и все.
[12:06.560 --> 12:10.560]  Ну, как бы там, подсчет ссылок он всю жизнь работал.
[12:10.560 --> 12:20.560]  Да, но, соответственно, родителю в момент, если ребенок заместил себя,
[12:20.560 --> 12:26.560]  возвращаются его законные права, потому что refcount этих страниц стал, соответственно, единичкой,
[12:26.560 --> 12:29.560]  потому что ребенок в этих страницах уже не владеет.
[12:29.560 --> 12:38.560]  Но как мы, соответственно, видим, это с одной стороны действительно нам ускоряет процесс,
[12:38.560 --> 12:41.560]  потому что нет вот этого безумного копирования всего адресного пространства,
[12:41.560 --> 12:53.560]  но все еще есть накладные расходы, связанные с ссылками, есть накладные расходы, связанные с обработкой исключений.
[12:53.560 --> 13:01.560]  Поэтому сейчас один из основных механизмов – это использование AVForg.
[13:01.560 --> 13:18.560]  Там должно быть два прота. Есть prot shared, есть prot copyonwrite, что касается именно самого джосса.
[13:18.560 --> 13:26.560]  Shared – это общая страничка в памяти, в которую имеет право обращаться в два разных процесса.
[13:26.560 --> 13:29.560]  Это, соответственно, для обеспечения межпроцессных коммуникаций.
[13:29.560 --> 13:37.560]  А prot copyonwrite – это, соответственно, как раз copyonwrite в момент, когда происходят записи в стране.
[13:37.560 --> 13:43.560]  Возможно, лэзи. Ну, код refactorits, там все уже вспомнить.
[13:43.560 --> 14:00.560]  Минус weight в смысле, как это, изменили этот rv битик, поставили туда 0.
[14:00.560 --> 14:10.560]  Ну да, present, но, соответственно, не writable. Вспомним пейчфолтовский 14-й вектор на x86.
[14:10.560 --> 14:15.560]  То есть нулевой битик у вас present. Первый битик – это запись.
[14:15.560 --> 14:23.560]  Второй битик, по-моему, user. Еще один битик exec.
[14:23.560 --> 14:28.560]  Возможно, порядок перекутал битов, но у вас, соответственно, есть такая штука, как error code.
[14:28.560 --> 14:35.560]  И в error code у вас устанавливаются четыре основных битика.
[14:35.560 --> 14:40.560]  Презент или непрезент. Была запись или не была запись, то есть чтение.
[14:40.560 --> 14:44.560]  Соответственно, страницы обращались из пользователя или из ядра.
[14:44.560 --> 14:48.560]  Ну, соответственно, здесь единичка, если user. И было ли instruction fetch.
[14:48.560 --> 14:52.560]  Ну, я написал здесь е, но, по-моему, оно там вот так вот af написано.
[14:52.560 --> 14:57.560]  Было ли исполнение страницы или это была операция чтения или записи.
[14:57.560 --> 15:02.560]  И, соответственно, в коде пейчфолта у вас будет установлена такая вот маска.
[15:02.560 --> 15:07.560]  И в дополнение к регистру CR2 я очень часто рекомендую смотреть,
[15:07.560 --> 15:12.560]  какой у вас error code в пейчфолте, потому что он нам позволяет понять,
[15:12.560 --> 15:19.560]  а что вообще произошло с операционной системой.
[15:19.560 --> 15:22.560]  Что?
[15:22.560 --> 15:26.560]  General protection – это, например, если вы вызвали какую-то инструкцию,
[15:26.560 --> 15:30.560]  которую вы не имели права вызывать с текущим уровнем привилегий.
[15:30.560 --> 15:37.560]  То есть, ну, немножко разные, грубо говоря, ректора и исключения.
[15:37.560 --> 15:41.560]  Они схожи, но вот разные действия приводят к разному.
[15:41.560 --> 15:46.560]  В принципе, есть процессоры, где используется одно и то же исключение
[15:46.560 --> 15:51.560]  и в том, и в другом случае. Поэтому читайте даташит на свой процессор,
[15:51.560 --> 15:56.560]  к которому вы работаете. Там будут приняты свои соглашения.
[15:56.560 --> 16:06.560]  Соответственно, сейчас Copy&Write – это прекрасно, но есть более хорошее решение.
[16:06.560 --> 16:11.560]  Есть, например, механизм VFork. Слышали когда-нибудь про VFork?
[16:11.560 --> 16:16.560]  Отлично. Ну, если вы откроете стандарт POSIX, то сможете это найти.
[16:16.560 --> 16:26.560]  И VFork отличается от FORK тем, что в момент, когда вы делаете, соответственно,
[16:26.560 --> 16:31.560]  вызов VFork, формально поведение программы ровно такое же.
[16:31.560 --> 16:38.560]  То есть, вам возвращают PIT вашего ребенка, в ребенке типа возвращается, соответственно,
[16:38.560 --> 16:47.560]  в ребенке возвращается нолик, но по факту у вас не происходит никакого клонирования адресного пространства.
[16:47.560 --> 16:52.560]  То есть, у вас просто есть полный доступ в адресное пространство родителей,
[16:52.560 --> 16:59.560]  единственные стэки отличаются. И все, что вы можете сделать после вызова VFork,
[16:59.560 --> 17:07.560]  это выполнить exec. Таким образом, не нужно реализовывать там ни механизм Copy&Write,
[17:07.560 --> 17:15.560]  в общем-то, формально даже не нужно клонировать адресное пространство и порождать его в момент вызова VFork.
[17:15.560 --> 17:20.560]  То есть, у вас на самом деле даже ребенок может быть порожден чуть позднее.
[17:20.560 --> 17:26.560]  Соответственно, именно за счет VFork...
[17:30.560 --> 17:36.560]  Нет, VFork работает точно так же, как FORK. Единственное отличие VFork от FORK заключается в том,
[17:36.560 --> 17:42.560]  что любое обращение к глобальным переменным на запись является неопределенным поведением.
[17:42.560 --> 17:47.560]  Да. По-моему, возможно, даже там есть ограничение на чтение.
[17:50.560 --> 17:55.560]  Дальше должен быть сразу exec.
[17:55.560 --> 17:58.560]  А строка?
[17:58.560 --> 18:03.560]  На стэк, например, положите. Или, соответственно, по-моему,
[18:03.560 --> 18:07.560]  на том все-таки можно на чтение к динамической памяти обращаться.
[18:07.560 --> 18:15.560]  Можно перечитать. Перечитайте стандарт POSIX. Я сейчас не хочу вас просто обмануть,
[18:15.560 --> 18:20.560]  а комплектную формулировку не воспроизведу.
[18:20.560 --> 18:26.560]  Кстати, я на слайдах как раз не может быть изменено ребенком.
[18:26.560 --> 18:30.560]  Скорее, с учтением все-таки доступно.
[18:30.560 --> 18:35.560]  Соответственно, после VFork должен следовать сразу exec,
[18:35.560 --> 18:40.560]  и тем самым мы можем не копировать адресное пространство водителя.
[18:40.560 --> 18:45.560]  Замечательно. Но это не все.
[18:45.560 --> 18:50.560]  Поэтому сейчас есть еще более хороший механизм, называется POSIX Spawn.
[18:50.560 --> 18:53.560]  POSIX Spawn это примерно как в Индии.
[18:53.560 --> 18:57.560]  Просто передали в качестве аргумента исполняемый файл, который надо создать,
[18:57.560 --> 19:02.560]  и вам просто вернули PID того процесса, который создался,
[19:02.560 --> 19:05.560]  и он сразу начинает пополняться.
[19:05.560 --> 19:13.560]  Это самое простое и интуитивное решение, но к нему пришли не сразу,
[19:13.560 --> 19:23.560]  потому что не было очевидно, что fork.exec как пара будет использоваться очень часто.
[19:23.560 --> 19:28.560]  На тот момент, когда fork.exec проектировались, а это были еще до юниксовские времена,
[19:28.560 --> 19:32.560]  Соответственно, оперативной памяти было не так много,
[19:32.560 --> 19:41.560]  и не было понимания, что сразу после fork кто-то будет exec делать.
[19:41.560 --> 19:45.560]  То есть вполне нормально было, что после fork выполнялся и другой процесс,
[19:45.560 --> 19:51.560]  потому что это можно было использовать для генерации новых трендов.
[19:51.560 --> 19:53.560]  Что?
[19:53.560 --> 19:55.560]  POSIX Spawn?
[19:55.560 --> 19:57.560]  Нет, это системный вызов.
[19:57.560 --> 20:02.560]  На современных, соответственно, в маке, например, есть POSIX Spawn.
[20:02.560 --> 20:06.560]  Должен быть.
[20:06.560 --> 20:10.560]  Но, возможно, в линуксе реализован через fork.exec.
[20:10.560 --> 20:13.560]  Но не хочу это же врать, потому что...
[20:13.560 --> 20:16.560]  Может быть.
[20:16.560 --> 20:18.560]  На маке системно.
[20:18.560 --> 20:23.560]  Но формально standard POSIX не заставляет вас делать и то, и другое системным вызовом.
[20:23.560 --> 20:27.560]  Достаточно просто реализовать то поведение, которое описано в стандарте.
[20:27.560 --> 20:30.560]  И если это будет просто какая-то функция в системной библиотеке,
[20:30.560 --> 20:36.560]  которая будет вести себя ровно так же, то вы выполнили это требование.
[20:36.560 --> 20:38.560]  Хорошо.
[20:38.560 --> 20:46.560]  Вот из этой картинки видно, что в отличие от последних двух,
[20:46.560 --> 20:51.560]  у первого механизма copy-on-write еще дополнительно экономится память.
[20:51.560 --> 21:01.560]  Да, она экономится исключительно на момент порождения пользовательского процесса клона родителя.
[21:01.560 --> 21:09.560]  Но в целом экономия оперативной памяти – это достаточно серьезная боль,
[21:09.560 --> 21:12.560]  которая есть при разработке библиотек.
[21:12.560 --> 21:19.560]  Поэтому я, пользуясь этим случаем, все-таки напомню, что у вас в операционной системе
[21:19.560 --> 21:25.560]  при порождении и при планировании процессов все-таки есть много механизмов
[21:25.560 --> 21:30.560]  по оптимизации доступа к оперативной памяти, которые регулярно используются.
[21:30.560 --> 21:33.560]  Про sloping мы, соответственно, помним.
[21:33.560 --> 21:39.560]  Есть алгоритмы планирования третьего уровня,
[21:39.560 --> 21:55.560]  которые дампят память на диск, когда реже используемый процесс не обращается к своей памяти,
[21:55.560 --> 21:57.560]  а физическая память у вас закончилась.
[21:57.560 --> 22:01.560]  Следственно, удаление копирования, подсчет ссылок.
[22:01.560 --> 22:10.560]  Если мы действительно используем какие-то общие ресурсы, то регулярно используются техники риф-каунтинга,
[22:10.560 --> 22:17.560]  которые, если объекты не изменяются, они могут вполне честно использовать общую память.
[22:17.560 --> 22:22.560]  Например, сейчас это очень часто используется, например, в файловых системах.
[22:22.560 --> 22:27.560]  Все современные файловые системы используют механизм copy-on-write.
[22:27.560 --> 22:35.560]  То есть, когда сектор у вас дублируется только в тот момент, когда реально происходит запись,
[22:35.560 --> 22:42.560]  из-за чего копирование файлов стало очень быстрым, но запись может стать в отдельных случаях более медленной.
[22:42.560 --> 22:45.560]  Есть сжатие страниц.
[22:45.560 --> 22:55.560]  Кстати, есть индивидуальное задание в джосе реализовать поддержку сжатия страниц, так же, как и sloping.
[22:55.560 --> 23:03.560]  Соответственно, те страницы, которые используются реже, они могут сжиматься с определенным успехом.
[23:03.560 --> 23:15.560]  Причем, если, например, известно, что страница там однородная, например, содержит только нули или только там эвки,
[23:15.560 --> 23:18.560]  то, соответственно, можно просто использовать механизм удаления.
[23:18.560 --> 23:20.560]  Копирование необязательно использует сжатие.
[23:20.560 --> 23:28.560]  Например, в джосе есть такая оптимизация, то есть нулевые страницы, они копируются лениво только в тот момент, когда в них что-то записывается.
[23:28.560 --> 23:36.560]  Точно так же с страницами, полностью забитыми единичными битами, например, shadow-память.
[23:36.560 --> 23:40.560]  Про адрес Annotizer же помним. Есть, соответственно, теневая память.
[23:40.560 --> 23:45.560]  В теневой памяти, если она poison, то там записаны все единички, все бит.
[23:45.560 --> 23:52.560]  Точно так же можно, например, дарить копирование для такой памяти и тем самым сделать дополнительную оптимизацию.
[23:52.560 --> 23:56.560]  Здесь, соответственно, кэши библиотек.
[23:56.560 --> 24:07.560]  Ну, мы помним, что традиционными способами кэширования там все-таки являются два направления.
[24:07.560 --> 24:15.560]  То есть это library, caching.
[24:15.560 --> 24:21.560]  То есть когда кэшируется там некоторый набор системных библиотек.
[24:21.560 --> 24:25.560]  И, соответственно, какие-нибудь системные вызовы.
[24:31.560 --> 24:37.560]  Например, когда у вас отображаются какие-либо функции, например,
[24:37.560 --> 24:43.560]  функции получения времени прямо в user space, например, через общую память с ядром.
[24:43.560 --> 24:49.560]  Или какая-то информация о вашей платформе, например,
[24:49.560 --> 24:55.560]  количество ядер, модель процессора и так далее, чтобы вам не нужно было за этим лезть.
[24:55.560 --> 25:02.560]  Например, в маковском ядре это называется com.page.
[25:02.560 --> 25:07.560]  В линуксовом раньше оно называлось com.vdso.
[25:07.560 --> 25:11.560]  Сейчас как-то по-другому переименовали, но суть та же.
[25:11.560 --> 25:17.560]  При этом мы, соответственно, помним, что вот эти вот вещи могут
[25:17.560 --> 25:22.560]  приводить к негативным последствиям безопасности.
[25:22.560 --> 25:24.560]  Помним, каким и почему.
[25:30.560 --> 25:32.560]  Не только.
[25:34.560 --> 25:36.560]  Можно риторически делать.
[25:37.560 --> 25:40.560]  Нет, это проблема адресного пространства,
[25:40.560 --> 25:45.560]  которое есть чисто в Винде, потому что там библиотеки по именам ищутся не по полным путям.
[25:45.560 --> 26:09.560]  В том направлении говорите, хотя немножко не точно, но я на всякий случай напомню.
[26:09.560 --> 26:17.560]  Когда мы делаем cache-библиотек общий для нескольких разных процессов,
[26:17.560 --> 26:20.560]  то чтобы он, соответственно, мог быть общим,
[26:20.560 --> 26:27.560]  потому что не весь код position-independent без релокаций,
[26:27.560 --> 26:30.560]  чаще всего у вас там будут какие-то релокации,
[26:30.560 --> 26:34.560]  то код придется размещать по одному и тому же адресу.
[26:34.560 --> 26:38.560]  Ну простой пример, если у вас здесь, например, указатель,
[26:38.560 --> 26:41.560]  который содержит указатель, например, на другую переменную,
[26:41.560 --> 26:49.560]  то просто так отобразить в одном процессе эти данные по одному адресу,
[26:49.560 --> 26:53.560]  а в другом процессе по другому адресу не получится, потому что указатель будет неверный.
[26:53.560 --> 26:57.560]  То есть его нужно пропатчить, то есть исправить ему смещение.
[26:57.560 --> 27:01.560]  А если его пропатчить, то не получится сэкономить оперативную память.
[27:01.560 --> 27:11.560]  Поэтому, действительно, кэш-библиотек должен располагаться по одному и тому же адресу в процессе.
[27:11.560 --> 27:16.560]  Ну с некоторыми оговорками, но в целом такая реальность.
[27:16.560 --> 27:21.560]  И, например, в свое время, опять же, в макии,
[27:21.560 --> 27:27.560]  когда с этой проблемой столкнулись, решили, ну окей,
[27:27.560 --> 27:34.560]  мы возьмем и будем располагать кэш-библиотек по разному адресу каждую перезагрузку.
[27:34.560 --> 27:41.560]  Отлично, то есть в каждой перезагрузке, соответственно, разные адреса.
[27:41.560 --> 27:47.560]  И они, в принципе, эту проблему решили и до того момента как появилось что?
[27:47.560 --> 27:51.560]  Как думаете?
[27:51.560 --> 27:57.560]  Что?
[27:57.560 --> 28:05.560]  Вот что у вас практически у всех есть либо на столе, либо в кармане?
[28:05.560 --> 28:09.560]  Мобильник, правильно.
[28:09.560 --> 28:15.560]  Очень все просто. Смотрите, когда вы переружаете свой мобильник, насколько часто?
[28:16.560 --> 28:20.560]  Раз в месяц.
[28:20.560 --> 28:29.560]  Соответственно, если я буду активно проверять в течение месяца какой-то адрес,
[28:29.560 --> 28:36.560]  ну вот, грубо говоря, в течение месяца 30 раз у меня какое-то приложение упадет,
[28:36.560 --> 28:41.560]  вполне есть шанс, что вы за эти 30 несчастных падений,
[28:41.560 --> 28:45.560]  во-первых, половину этих падений не распознаете, подумаете, что операционка убила
[28:45.560 --> 28:48.560]  просто из-за того, что там памяти не хватает, например.
[28:48.560 --> 28:52.560]  А даже если и заметите, то вполне возможно, что вы это приложение не удалите.
[28:52.560 --> 28:57.560]  А я, соответственно, на какой-нибудь 30 раз таки угадаю с адресом
[28:57.560 --> 29:02.560]  и после этого, соответственно, смогу выполнить код на вашем устройстве.
[29:02.560 --> 29:07.560]  Дестопные операционные системы перегружают достаточно чаще,
[29:07.560 --> 29:13.560]  поэтому проблемы с тем, что, грубо говоря, устройства не перезагружают,
[29:13.560 --> 29:18.560]  она есть, в принципе, и на десктопах, но не столь серьезно.
[29:18.560 --> 29:21.560]  Догадываетесь, как можно обойти?
[29:21.560 --> 29:26.560]  Обойти, потому что они не выгружают перед того, что перезагружают.
[29:26.560 --> 29:32.560]  Обойти проблему, что система становится небезопасной при использовании шаред-кэша.
[29:32.560 --> 29:35.560]  Ну, уменьшает кэши.
[29:35.560 --> 29:40.560]  Дорого, очень дорого. Оперативной памяти не хватит.
[29:40.560 --> 29:42.560]  Перезагружать насильно?
[29:42.560 --> 29:47.560]  Перезагружать насильно, да. На самом деле, уже вчера предлагали насильно
[29:47.560 --> 29:53.560]  перезагружать в 3 часа ночи, как винда устанавливает обновления,
[29:53.560 --> 29:57.560]  после этого пользователь достает свой мобильный телефон,
[29:57.560 --> 30:01.560]  у него там вкладочка была в браузере, которая закрылась,
[30:01.560 --> 30:06.560]  у него там был какой-то любимый фильм, он тоже закрылся с потерей
[30:06.560 --> 30:11.560]  там таймкодов, где он смотрел, и юзабилити от этого...
[30:11.560 --> 30:14.560]  Да было бы дело в перезагрузке.
[30:14.560 --> 30:19.560]  Ну как неявная перезагрузка? Вам придется...
[30:19.560 --> 30:24.560]  Можно просто перезагрузить кэши библиотет, не все есть тема.
[30:24.560 --> 30:28.560]  Да, но у вас процессы не смогут работать, вы не сможете...
[30:28.560 --> 30:33.560]  Как грабочек электро в Java? Поставить систему на паузу, сделать что-то другое,
[30:33.560 --> 30:36.560]  сделать грязное дело, разобновить процессы.
[30:36.560 --> 30:43.560]  В Android, конечно, можно попытаться, но я вас уверяю, что даже в Android
[30:43.560 --> 30:47.560]  огромное количество приложений, которые используют NDK, то есть
[30:47.560 --> 30:53.560]  нативные, грубо говоря, куски кода, и даже для них все очень плачевно.
[30:53.560 --> 30:58.560]  Даже для тех, которые NDK не используют, все очень плачевно там.
[30:58.560 --> 31:01.560]  Сейчас у них увеличены указатели, что ли?
[31:01.560 --> 31:08.560]  Ну в Java runtime куча указателей, и все их пропатчить я практически невозможно.
[31:08.560 --> 31:13.560]  А можно сделать те страницы, на которых раньше был этот кэш,
[31:13.560 --> 31:19.560]  специальными, ну, ловушечными, чтобы page vault, когда ловят по ним обращение,
[31:19.560 --> 31:22.560]  он некоторое время менял указатели на правильные...
[31:22.560 --> 31:24.560]  А какой указатель?
[31:24.560 --> 31:27.560]  Ну не основание, page vault сейчас ловили под гунды instruction pointer
[31:27.560 --> 31:30.560]  с таким-то этим, он лазит в тот код, и там батчит что-то.
[31:30.560 --> 31:37.560]  Оно будет, во-первых, безумно тормозить, а во-вторых, пользователь выкинет телефон.
[31:37.560 --> 31:40.560]  Потому что у него все-таки рандомно до что-то падает.
[31:40.560 --> 31:43.560]  Нет, решение есть гораздо более простое.
[31:43.560 --> 31:49.560]  Соответственно, поиск ISLR-смещения, то есть поиск смещения кэша-библиотек,
[31:49.560 --> 31:52.560]  это фактически какая-то стохастическая атака.
[31:52.560 --> 31:54.560]  То есть вы либо угадаете, либо нет.
[31:54.560 --> 31:58.560]  То есть вы пробуете один раз, второй раз, третий раз, четвертый, пятый, шестой,
[31:58.560 --> 32:00.560]  седьмой, восьмой, девятый, десятый.
[32:00.560 --> 32:03.560]  О, на какой-нибудь пятидесятый попали.
[32:03.560 --> 32:08.560]  Может даже быстрее, если у вас достаточно значный эксплуат.
[32:08.560 --> 32:16.560]  Поэтому во всех случаях, когда вы будете обращаться к этому адресу,
[32:16.560 --> 32:18.560]  у вас система будет падать.
[32:18.560 --> 32:21.560]  Не система, а, соответственно, ваш процесс будет крашиться,
[32:21.560 --> 32:24.560]  потому что вы обратились по неволидному указателю.
[32:24.560 --> 32:29.560]  Как вы, наверное, догадались уже сами, что это не очень нормально,
[32:29.560 --> 32:34.560]  что процесс за короткий промежуток времени регулярно падает.
[32:34.560 --> 32:41.560]  Ну окей, соответственно, сделаем не один кэш-библиотек, а, например, два или три.
[32:41.560 --> 32:45.560]  Соответственно, в нормальной ситуации используется один кэш-библиотек.
[32:45.560 --> 32:49.560]  Если какой-то процесс начинает аномально падать, причем,
[32:49.560 --> 32:55.560]  например, более пяти раз он упал, ну окей, взяли ему, перемапили кэш.
[32:55.560 --> 32:58.560]  Да, этот конкретно один процесс будет тормозить,
[32:58.560 --> 33:02.560]  потому что у него будет в момент его запуска создаваться кэш-библиотек.
[33:02.560 --> 33:06.560]  Да, при этом увеличится, грубо говоря, в полтора раза потребление памяти.
[33:06.560 --> 33:09.560]  Но конкретно этот процесс пострадает.
[33:09.560 --> 33:13.560]  А как под знать, что это конкретно этот процесс?
[33:13.560 --> 33:14.560]  Покрашим.
[33:14.560 --> 33:19.560]  Не, ну в смысле процесс палта, чтобы он перезапустился, перезапустится,
[33:19.560 --> 33:22.560]  может уже перезапуститься, может...
[33:22.560 --> 33:24.560]  Ну если просто тот же типус моего палта,
[33:24.560 --> 33:27.560]  то можно автоматически переменовывать.
[33:27.560 --> 33:29.560]  То есть вы можете делать загрузки.
[33:29.560 --> 33:33.560]  Нет, ну смотрите, как вы будете переменовывать приложения в Sandbox,
[33:33.560 --> 33:36.560]  там iOS-устройство, например,
[33:36.560 --> 33:42.560]  там у вас приложения устанавливаются по случайно сгенерированному пути
[33:42.560 --> 33:43.560]  системой.
[33:43.560 --> 33:47.560]  И соответственно они в этом своем контейнере ничего не могут поменять,
[33:47.560 --> 33:51.560]  потому что их там изначально цифровой подписью всех зажали
[33:51.560 --> 33:55.560]  и не дают запускать произвольно исполняемые файлы никакие вообще.
[33:55.560 --> 33:59.560]  И возможностей проверить, ну типа без падения проверить
[33:59.560 --> 34:01.560]  можно обязательно...
[34:01.560 --> 34:03.560]  Нет.
[34:03.560 --> 34:06.560]  Они не могут соответственно без отладчика
[34:06.560 --> 34:09.560]  устанавливать хендлеры...
[34:09.560 --> 34:12.560]  В Mac есть механизм там типа
[34:12.560 --> 34:15.560]  официальных там IPC, которые позволяют вам делать
[34:15.560 --> 34:18.560]  локальный отладчик внутри своего процесса.
[34:18.560 --> 34:23.560]  И как раз соответственно недавно эту дыру закрыли,
[34:23.560 --> 34:28.560]  в том числе из-за того, чтобы защитить вот этот механизм клонирования
[34:28.560 --> 34:30.560]  соответственно адресного пространства.
[34:30.560 --> 34:33.560]  Но как результат, соответственно пользователи сейчас в интернете воют,
[34:33.560 --> 34:38.560]  что вот, вот, все плохо, Apple у них украл джеты.
[34:38.560 --> 34:42.560]  А на самом деле Apple закрывал дыру в безопасности.
[34:42.560 --> 34:47.560]  То есть про дескопные системы есть?
[34:47.560 --> 34:51.560]  Ну дескопные системы перезагружают чаще.
[34:51.560 --> 34:55.560]  То есть соответственно как бы там вектор атак немножко другой.
[34:55.560 --> 34:57.560]  Что?
[34:57.560 --> 35:00.560]  JIT, Injustice Time компиляция.
[35:00.560 --> 35:03.560]  Ну он как бы всегда был там очень условно доступен,
[35:03.560 --> 35:07.560]  но там были варианты типа там через хитрый entitlement его получить.
[35:07.560 --> 35:11.560]  И они как бы у легальных пользователей там до сих пор есть.
[35:11.560 --> 35:15.560]  А соответственно там вот пользователи там каких-нибудь там, не знаю там,
[35:15.560 --> 35:18.560]  эмуляторов, например, они очень страдали,
[35:18.560 --> 35:21.560]  потому что они там всякими хитрыми способами пытались сделать вид,
[35:21.560 --> 35:24.560]  что они запускают локальный отладчик
[35:24.560 --> 35:28.560]  и использовали там механизм типа установки брейкпоинтов
[35:28.560 --> 35:31.560]  для того, чтобы делать себе джиты.
[35:31.560 --> 35:34.560]  Ну как это, полагались на недокументированное поведение системы,
[35:34.560 --> 35:37.560]  в ходе момента она перестала работать.
[35:37.560 --> 35:40.560]  В браузере?
[35:40.560 --> 35:43.560]  В браузере? Ну в браузере JIT есть, да.
[35:43.560 --> 35:46.560]  Что?
[35:46.560 --> 35:49.560]  Ну, например, какой-нибудь эмулятор, консоли.
[35:49.560 --> 35:54.560]  То есть очень часто на мобильных телефонах там запускают какие-нибудь там эмуляторы там старых приставок.
[35:54.560 --> 35:59.560]  То есть, да, эмулятор существовал в эмуляторе.
[35:59.560 --> 36:04.560]  Да, например, сейчас даже существует, у меня даже на Эпаде стоит.
[36:04.560 --> 36:11.560]  А можно еще раз, ну, во-первых,
[36:11.560 --> 36:14.560]  в библиотеке, вот когда библиотеки начинаются,
[36:14.560 --> 36:17.560]  он начинается по адресам кэшивать.
[36:17.560 --> 36:21.560]  А Митя когда вызывает, вызывает эти код, ну да, он, конечно, да, выполняется.
[36:21.560 --> 36:24.560]  А что, в чем вопрос?
[36:24.560 --> 36:29.560]  Ну, при этом, если пользователь, ну, если программа кэшитает свою библиотеку, то она только подобрается кэш?
[36:29.560 --> 36:33.560]  Нет, конечно, только системные. Понятно, что те библиотеки, которые представляют
[36:33.560 --> 36:37.560]  использователям, они, соответственно, там по случайным адресам располагаются в момент запуска.
[36:37.560 --> 36:39.560]  В этом как бы...
[36:39.560 --> 36:44.560]  Сейчас, ну, вызов пункции библиотечной, например, он же должен быть как-то дойти до библиотечного кода.
[36:44.560 --> 36:47.560]  В чем проблема дать возможность, ну, в чем проблема библиотечного кода?
[36:47.560 --> 36:56.560]  Не от того защищаетесь, то есть тот человек, который пытается вас атаковать,
[36:56.560 --> 37:00.560]  он не имеет полноценного контроля над, соответственно, вашим кодом.
[37:00.560 --> 37:04.560]  То есть он получает там управление в виде там returner и end of programming.
[37:04.560 --> 37:07.560]  Он не знает, где находятся какие функции и так далее.
[37:07.560 --> 37:12.560]  То есть защищается не от тех, у кого там полноценная программа, которая может себя исполнять.
[37:12.560 --> 37:14.560]  Вы договорились в сэндбоксе?
[37:14.560 --> 37:15.560]  Ну, в сэндбоксе.
[37:15.560 --> 37:19.560]  Я думал, что в сэндбоксе в плане, что может быть все приложение, в сэндбоксе весь процесс,
[37:19.560 --> 37:22.560]  автору процесса доверия нет и все такое.
[37:22.560 --> 37:26.560]  Ну, автору процесса доверия нет и все такое, но как бы от авторов в данном случае.
[37:26.560 --> 37:29.560]  Вот конкретно этот mitigation, он не от автора приложения.
[37:29.560 --> 37:31.560]  Нет, просто газетина не вполне понятна.
[37:31.560 --> 37:36.560]  Понятно негодование пользователей по поводу того, что это закрыли, потому что закрыли,
[37:37.560 --> 37:42.560]  а вектор атаки для требующей уже наличия уязвимости в другом месте.
[37:42.560 --> 37:44.560]  Ну, так это всегда так.
[37:44.560 --> 37:53.560]  Нельзя защититься от конкретных уязвимостей, которые еще не публиковали и о них не сообщили.
[37:53.560 --> 37:58.560]  Но можно закрывать классы атак, а посредством добавления mitigation.
[37:58.560 --> 38:03.560]  Ну, в смысле не прям закрывать на 100%, но, грубо говоря, усложнять их эксплуатацию.
[38:03.560 --> 38:09.560]  Ну, именно, что это кого-то решают реальные печи, которые они используют,
[38:09.560 --> 38:12.560]  ради такого вероятностного усиления защиты.
[38:12.560 --> 38:14.560]  Да, и на самом деле оно все так.
[38:14.560 --> 38:17.560]  Усиление многих пользователей, это может быть не такое.
[38:17.560 --> 38:20.560]  Они могут быть негде.
[38:20.560 --> 38:25.560]  Ну, некоторые пользователи, да, но чаще всего в таких ситуациях
[38:25.560 --> 38:28.560]  недовольных пользователей меньше доли и процентов.
[38:29.560 --> 38:34.560]  То есть, как бы, ну, сколько есть пользователей, у которых есть developer ID,
[38:34.560 --> 38:40.560]  которые, соответственно, там запускают какие-то там собственно собранные программы.
[38:43.560 --> 38:45.560]  Ну, это всегда третий вопрос.
[38:49.560 --> 38:54.560]  Поэтому главная задача не добавлять что-то новое и небезопасное.
[38:54.560 --> 39:00.560]  Для этого, как раз, собственно, и есть в командах архитекторы
[39:00.560 --> 39:02.560]  по информационной безопасности.
[39:02.560 --> 39:06.560]  Они там в первую очередь должны оценить, собственно, то, что фича,
[39:06.560 --> 39:09.560]  которая реализуется там в каком-то конкретном целевом продукте,
[39:09.560 --> 39:14.560]  она не нарушает безопасность, собственно, всех этих целевой платформ.
[39:14.560 --> 39:19.560]  То есть, ну, вот как раз вы только что назвали одну из служебных обязанностей
[39:19.560 --> 39:23.560]  собственно, безопасников в команде разработки.
[39:23.560 --> 39:27.560]  Кстати, вот то, что приложение пользовательские, наверное,
[39:27.560 --> 39:29.560]  на иконе могут вызвать, вот, куда-то их...
[39:29.560 --> 39:30.560]  Да.
[39:30.560 --> 39:33.560]  Вот в нем будет JIT или не будет?
[39:33.560 --> 39:34.560]  Будет.
[39:34.560 --> 39:35.560]  А как?
[39:35.560 --> 39:40.560]  Ну, специальные там entitlements или там специальные сервисы для этого есть.
[39:40.560 --> 39:43.560]  Ну, это же как бы какие-то там устроения для приложений или он...
[39:43.560 --> 39:47.560]  Нет, он как в шаре-то там кэша находится, там феймворк.
[39:47.560 --> 39:48.560]  А, и он как бы...
[39:48.560 --> 39:52.560]  Нет, ну, JIT никому не запрещают использовать.
[39:52.560 --> 39:55.560]  Если вы там, грубо говоря, сказали, что вам нужен, грубо говоря, вот кит,
[39:55.560 --> 39:58.560]  то, соответственно, у вас внутри вот кита будет JIT.
[39:58.560 --> 40:01.560]  Ну, при этом, если я там использую JIT, то, соответственно,
[40:01.560 --> 40:03.560]  у вас внутри есть entitlement?
[40:03.560 --> 40:05.560]  Нет, да, если у вас есть entitlement.
[40:05.560 --> 40:07.560]  Там есть специальные entitlements на JIT.
[40:07.560 --> 40:08.560]  Что?
[40:08.560 --> 40:09.560]  До сих пор?
[40:09.560 --> 40:10.560]  Да, до сих пор, до сих пор.
[40:10.560 --> 40:12.560]  И да, это как перемышление?
[40:12.560 --> 40:13.560]  Что?
[40:13.560 --> 40:14.560]  И да, это как перемышление?
[40:14.560 --> 40:15.560]  Типа того, да.
[40:15.560 --> 40:16.560]  Вот.
[40:16.560 --> 40:19.560]  Другое дело, то, что просто у вас может ревью не пройти приложение,
[40:19.560 --> 40:22.560]  грубо говоря, вы используете JIT не по назначению.
[40:22.560 --> 40:24.560]  Типа нельзя его использовать, кроме как...
[40:24.560 --> 40:27.560]  Но вот там браузер, например, можно.
[40:27.560 --> 40:29.560]  Вот.
[40:29.560 --> 40:32.560]  То есть тут как бы все достаточно.
[40:32.560 --> 40:33.560]  Не очень хорошо сделано.
[40:33.560 --> 40:35.560]  Не очень надежно, точнее.
[40:39.560 --> 40:40.560]  Так.
[40:40.560 --> 40:44.560]  Ну, соответственно, мы немножко отвлеклись, но
[40:44.560 --> 40:45.560]  в целом
[40:45.560 --> 40:47.560]  поняли, как
[40:47.560 --> 40:49.560]  нуждаются, соответственно, современные процессы.
[40:49.560 --> 40:51.560]  И в дальнейшем как бы наша задачка
[40:51.560 --> 40:54.560]  понять, как вообще эти процессы
[40:54.560 --> 40:56.560]  могут общаться.
[40:56.560 --> 40:59.560]  Ну, соответственно, там
[40:59.560 --> 41:01.560]  простой пример,
[41:01.560 --> 41:03.560]  как реализовать там
[41:03.560 --> 41:05.560]  коммуникации между двумя процессами.
[41:05.560 --> 41:08.560]  Ну, представьте, что там у вас есть
[41:08.560 --> 41:10.560]  процесс, грубо говоря, там
[41:10.560 --> 41:12.560]  P1
[41:12.560 --> 41:14.560]  и процесс P2.
[41:14.560 --> 41:16.560]  И они хотят
[41:16.560 --> 41:19.560]  передать друг другу какое-нибудь сообщение.
[41:19.560 --> 41:21.560]  Ну, например, там строчку
[41:21.560 --> 41:24.560]  размером 256 бай.
[41:24.560 --> 41:26.560]  Мы знаем, что
[41:26.560 --> 41:28.560]  там над нами
[41:28.560 --> 41:30.560]  есть
[41:30.560 --> 41:32.560]  некоторый kernel.
[41:35.560 --> 41:38.560]  То есть ядро, находящееся на нулевом
[41:38.560 --> 41:40.560]  уровне привилегий.
[41:40.560 --> 41:43.560]  И мы с ним можем, соответственно,
[41:43.560 --> 41:45.560]  общаться в помощи системных выборов.
[41:45.560 --> 41:48.560]  Ответственно, простейший
[41:48.560 --> 41:50.560]  пример, там
[41:50.560 --> 41:52.560]  реализация APC
[41:52.560 --> 41:54.560]  может выглядеть как.
[41:54.560 --> 41:56.560]  То есть добавляем некоторый системный вызов
[41:56.560 --> 41:58.560]  в ядро.
[41:58.560 --> 42:00.560]  Ну, например, тут
[42:00.560 --> 42:02.560]  send,
[42:02.560 --> 42:04.560]  тут receive.
[42:04.560 --> 42:07.560]  В разных операционных системах
[42:07.560 --> 42:09.560]  по-разному, не так важно.
[42:09.560 --> 42:11.560]  И, соответственно,
[42:11.560 --> 42:13.560]  передаем сюда
[42:13.560 --> 42:15.560]  какие-то данные.
[42:15.560 --> 42:17.560]  А вот здесь эти данные получаем.
[42:17.560 --> 42:19.560]  Ну, как это может выглядеть?
[42:19.560 --> 42:21.560]  Соответственно, здесь будет
[42:21.560 --> 42:23.560]  некоторое копирование
[42:25.560 --> 42:27.560]  в
[42:27.560 --> 42:29.560]  ядерную память.
[42:29.560 --> 42:31.560]  И, соответственно, здесь
[42:31.560 --> 42:33.560]  копирование
[42:34.560 --> 42:36.560]  еще одно
[42:36.560 --> 42:38.560]  в
[42:38.560 --> 42:40.560]  целевой процесс.
[42:40.560 --> 42:42.560]  А если P2 вызов принять эти данные?
[42:42.560 --> 42:44.560]  Ну, он вызов
[42:44.560 --> 42:46.560]  receive.
[42:46.560 --> 42:48.560]  Если он не вызывает вызов receive,
[42:48.560 --> 42:50.560]  то, соответственно, хорошая реализация
[42:50.560 --> 42:52.560]  будет делать тайм-аут.
[42:52.560 --> 42:54.560]  На пасуху.
[42:54.560 --> 42:56.560]  То есть вы можете сказать, что
[42:56.560 --> 42:58.560]  P2 не готов, и, соответственно,
[42:58.560 --> 43:00.560]  если он не готов в течение какого-то тайм-аута,
[43:00.560 --> 43:02.560]  то просто вернуть управление
[43:02.560 --> 43:04.560]  отправки
[43:04.560 --> 43:06.560]  с некоторым сообщением.
[43:06.560 --> 43:08.560]  А какой имитет делает этот тайм-аут?
[43:08.560 --> 43:10.560]  Ну, то есть от задачи.
[43:14.560 --> 43:16.560]  Ну, зависит от задачи.
[43:16.560 --> 43:18.560]  В плане доставки
[43:18.560 --> 43:20.560]  вызывающего процесса.
[43:20.560 --> 43:22.560]  Ну да.
[43:36.560 --> 43:38.560]  Обычно это вообще синхронно делается,
[43:38.560 --> 43:40.560]  поэтому как бы отправили,
[43:40.560 --> 43:42.560]  и, соответственно, дальше смотрите, ждете или нет.
[43:42.560 --> 43:44.560]  То есть это как бы там вот
[43:44.560 --> 43:46.560]  крутейшая демонстрация, она типа блокирующая.
[43:46.560 --> 43:48.560]  На деле, соответственно, отправили,
[43:48.560 --> 43:50.560]  и дальше потом ждете, получили или не получили.
[43:52.560 --> 43:54.560]  Ну, в случае, например,
[43:54.560 --> 43:56.560]  там real-time операционных систем, у вас есть расписание,
[43:56.560 --> 43:58.560]  соответственно, вы знаете, что он будет готов принять.
[43:58.560 --> 44:00.560]  В случае там
[44:00.560 --> 44:02.560]  операционных систем общего назначения,
[44:02.560 --> 44:04.560]  ну, там
[44:04.560 --> 44:06.560]  с долей вероятности обслуживающий сервер,
[44:06.560 --> 44:08.560]  соответственно, у него будет время
[44:08.560 --> 44:10.560]  служить в ваш процесс. Например, там
[44:10.560 --> 44:12.560]  простой пример IPC,
[44:12.560 --> 44:14.560]  ну, у вас какой-нибудь графический сервер.
[44:14.560 --> 44:16.560]  То есть у вас графика, например, работает
[44:16.560 --> 44:18.560]  на линуксе или на маке, соответственно,
[44:18.560 --> 44:20.560]  у вас есть меркоплята шейдеров какой-нибудь
[44:20.560 --> 44:22.560]  внешний.
[44:22.560 --> 44:24.560]  Соответственно, вы ему отправляете IPC запросы,
[44:24.560 --> 44:26.560]  чтобы он там собрал вам шейдеры.
[44:26.560 --> 44:28.560]  Например.
[44:28.560 --> 44:30.560]  И, в принципе, ну,
[44:30.560 --> 44:32.560]  гарантируется, что
[44:32.560 --> 44:34.560]  он будет достаточно быстрым, потому что у вас
[44:34.560 --> 44:36.560]  интерфейс не очень тормозит.
[44:36.560 --> 44:38.560]  А при этом многие ковы Uber,
[44:38.560 --> 44:40.560]  там Uber в ABC не бывает?
[44:40.560 --> 44:42.560]  Почему? Бывают.
[44:42.560 --> 44:44.560]  То есть вот здесь, в ядре, например,
[44:44.560 --> 44:46.560]  может быть память.
[44:46.560 --> 44:48.560]  Нет, то есть можно быть спокойной реализацией
[44:48.560 --> 44:50.560]  без стейм-аунта, что просто отправил,
[44:50.560 --> 44:52.560]  и дальше все, и игнорируешь это, а она лежит в буфере
[44:52.560 --> 44:54.560]  до сих пор, пока не закончится очередь.
[44:54.560 --> 44:56.560]  Ну, то есть, например,
[44:56.560 --> 44:58.560]  вот то, что вы сейчас описываете,
[44:58.560 --> 45:00.560]  например, это так работает,
[45:00.560 --> 45:02.560]  с чем,
[45:02.560 --> 45:04.560]  как говорится, работает, с тем могу назвать,
[45:04.560 --> 45:06.560]  например, так работает портуярник 153
[45:06.560 --> 45:08.560]  в авианике.
[45:08.560 --> 45:10.560]  И в очереди гарантируется
[45:10.560 --> 45:12.560]  некоторый буфер
[45:12.560 --> 45:14.560]  определенной длины, который, соответственно,
[45:14.560 --> 45:16.560]  записывается в конфигурации,
[45:16.560 --> 45:18.560]  соответственно, под него резервируется память
[45:18.560 --> 45:20.560]  и любой
[45:20.560 --> 45:22.560]  участвующий в
[45:22.560 --> 45:24.560]  передаче, соответственно,
[45:24.560 --> 45:26.560]  клиент, ну, то есть, грубо говоря,
[45:26.560 --> 45:28.560]  может в этот буфер положить сколько-то данных
[45:28.560 --> 45:30.560]  до того момента, когда этот буфер не заполнится.
[45:30.560 --> 45:32.560]  Соответственно, если буфер заполнился,
[45:32.560 --> 45:34.560]  то ему скажут, что, извини, места нет.
[45:34.560 --> 45:36.560]  А, соответственно, как только
[45:36.560 --> 45:38.560]  для этого буфера что-то прочтут,
[45:38.560 --> 45:40.560]  то можно будет класть еще.
[45:40.560 --> 45:42.560]  Ну, простой пример, то есть, как бы такой тоже есть.
[45:44.560 --> 45:46.560]  Это такой
[45:46.560 --> 45:48.560]  самый простейший пример
[45:48.560 --> 45:50.560]  IPC и
[45:50.560 --> 45:52.560]  ну да, то есть, действительно
[45:52.560 --> 45:54.560]  в каких-то там
[45:54.560 --> 45:56.560]  операционных системах, даже, по-моему, в Android
[45:56.560 --> 45:58.560]  какое-то время так делали.
[45:58.560 --> 46:00.560]  Именно так и было, но в целом
[46:00.560 --> 46:02.560]  в принципе сейчас
[46:02.560 --> 46:04.560]  так опять же никто не делает,
[46:04.560 --> 46:06.560]  потому что, ну, вот здесь как раз есть хороший
[46:06.560 --> 46:08.560]  тезис, что
[46:08.560 --> 46:10.560]  IPC должны быть быстрыми.
[46:10.560 --> 46:12.560]  Ну, понятно, что скорость там
[46:12.560 --> 46:14.560]  IPC, она там в целом
[46:14.560 --> 46:16.560]  может быть описана
[46:16.560 --> 46:18.560]  ну, давайте, тремя тезисами.
[46:20.560 --> 46:22.560]  Соответственно, первый тезис
[46:22.560 --> 46:24.560]  это минимальное
[46:24.560 --> 46:26.560]  количество копирования.
[46:28.560 --> 46:30.560]  То есть, вот мы видим, что здесь копируются данные
[46:30.560 --> 46:32.560]  в ядро, после этого копируется обратно
[46:32.560 --> 46:34.560]  user space.
[46:34.560 --> 46:36.560]  Это дорого.
[46:36.560 --> 46:38.560]  Зачем делать две копии?
[46:38.560 --> 46:40.560]  Чаще всего еще вот тут будет копирование,
[46:40.560 --> 46:42.560]  потому что тут еще упаковка будет какая-нибудь.
[46:44.560 --> 46:46.560]  Соответственно,
[46:46.560 --> 46:48.560]  второй тезис
[46:48.560 --> 46:50.560]  это
[46:50.560 --> 46:52.560]  минимальное
[46:54.560 --> 46:56.560]  переключение, собственно,
[46:56.560 --> 46:58.560]  контекстов.
[46:58.560 --> 47:00.560]  То есть, ну, вот в данном
[47:00.560 --> 47:02.560]  случае
[47:02.560 --> 47:04.560]  представьте, что у вас
[47:04.560 --> 47:06.560]  ядро тупое,
[47:06.560 --> 47:08.560]  и оно может там, грубо говоря,
[47:08.560 --> 47:10.560]  находиться либо в адресном пространстве
[47:10.560 --> 47:12.560]  процесса P1,
[47:12.560 --> 47:14.560]  либо в адресном пространстве
[47:14.560 --> 47:16.560]  процесса P2.
[47:18.560 --> 47:20.560]  Если вот ядро действительно настолько тупое,
[47:20.560 --> 47:22.560]  то вы не можете
[47:22.560 --> 47:24.560]  просто взять, например,
[47:24.560 --> 47:26.560]  и сразу скопировать данные
[47:26.560 --> 47:28.560]  в P2. Вам придется в еды иметь промежуточный
[47:28.560 --> 47:30.560]  буфер.
[47:44.560 --> 47:46.560]  Вы представляете, какие-то накладные расходы будут?
[47:46.560 --> 47:48.560]  Нет, ну, просто представьте,
[47:48.560 --> 47:50.560]  для того чтобы передавать группу гребайт вам
[47:50.560 --> 47:52.560]  нужно делать contact switch.
[47:58.560 --> 48:00.560]  К этому мы сейчас
[48:00.560 --> 48:02.560]  подбираемся.
[48:02.560 --> 48:04.560]  То есть, примерно так
[48:04.560 --> 48:06.560]  действительно делают
[48:06.560 --> 48:08.560]  современные перезвоночные системы.
[48:08.560 --> 48:10.560]  И, соответственно,
[48:10.560 --> 48:12.560]  там третий момент
[48:12.560 --> 48:14.560]  это
[48:14.560 --> 48:16.560]  быстрые сисковые.
[48:16.560 --> 48:18.560]  Ну, то есть, помним предыдущую лекцию, действительно, там
[48:18.560 --> 48:20.560]  существуют во многих процессорах аппаратные
[48:20.560 --> 48:22.560]  возможности по ускорению системных вызовов,
[48:22.560 --> 48:24.560]  и если они есть, то их неплохо
[48:24.560 --> 48:26.560]  применять, потому что они, соответственно,
[48:26.560 --> 48:28.560]  ускоряют сам процесс
[48:28.560 --> 48:30.560]  перехода туда-сюда.
[48:32.560 --> 48:34.560]  Сюда же я, соответственно,
[48:34.560 --> 48:36.560]  еще не добавил. То есть, кроме переключений
[48:36.560 --> 48:38.560]  контекста, вам еще,
[48:38.560 --> 48:40.560]  соответственно, нужен
[48:40.560 --> 48:42.560]  ну, желательно, скажем так,
[48:42.560 --> 48:44.560]  быстрое
[48:44.560 --> 48:46.560]  перемапливание, соответственно, изменение
[48:46.560 --> 48:48.560]  отображения, если,
[48:48.560 --> 48:50.560]  соответственно, оно используется
[48:50.560 --> 48:52.560]  при реализации системных вызовов.
[48:52.560 --> 48:54.560]  Ну, это уже одна из этапов.
[48:54.560 --> 48:56.560]  Как,
[48:56.560 --> 48:58.560]  собственно,
[48:58.560 --> 49:00.560]  делают это в реальности?
[49:00.560 --> 49:02.560]  Ну, там, например, одна из оптимизаций,
[49:02.560 --> 49:04.560]  которая, ну,
[49:04.560 --> 49:06.560]  вы уже начали про нее догадываться,
[49:08.560 --> 49:10.560]  связана с тем,
[49:10.560 --> 49:12.560]  чтобы
[49:12.560 --> 49:14.560]  второму процессу просто
[49:20.560 --> 49:22.560]  отдать ту память, которую вы, собственно,
[49:22.560 --> 49:24.560]  хотите ему отправить.
[49:24.560 --> 49:26.560]  То есть, представьте, что у вас вот есть некоторая страничка
[49:26.560 --> 49:28.560]  с данными,
[49:28.560 --> 49:30.560]  там,
[49:30.560 --> 49:32.560]  буквера messageM,
[49:34.560 --> 49:36.560]  и
[49:36.560 --> 49:38.560]  вы хотите ее передать
[49:38.560 --> 49:40.560]  P2.
[49:40.560 --> 49:42.560]  Мы помним, что в случае, там, ну,
[49:42.560 --> 49:44.560]  например, с страничными ММУ,
[49:44.560 --> 49:46.560]  такими, как используется в x86
[49:46.560 --> 49:48.560]  или в арме, у нас достаточно
[49:48.560 --> 49:50.560]  просто переделать
[49:50.560 --> 49:52.560]  отображение виртуальной памяти.
[49:52.560 --> 49:54.560]  Соответственно, мы можем
[49:54.560 --> 49:56.560]  просто, например, взять
[49:56.560 --> 49:58.560]  вот эту самую страничку
[49:58.560 --> 50:00.560]  с данными, которые хотим отправить,
[50:00.560 --> 50:02.560]  и отобразить ее
[50:02.560 --> 50:04.560]  в адресное пространство
[50:04.560 --> 50:06.560]  P2. Ну, понятно, что вот это ядро
[50:06.560 --> 50:08.560]  делает.
[50:14.560 --> 50:16.560]  Правильно.
[50:16.560 --> 50:18.560]  Далеко не всегда.
[50:18.560 --> 50:20.560]  И именно поэтому, например, в Android
[50:20.560 --> 50:22.560]  очень страдают с IPC,
[50:22.560 --> 50:24.560]  потому что они не могут сделать оптимизации
[50:24.560 --> 50:26.560]  вот такого рода.
[50:26.560 --> 50:28.560]  То есть, там все равно возникает копирование.
[50:28.560 --> 50:30.560]  Но
[50:30.560 --> 50:32.560]  в целом есть
[50:32.560 --> 50:34.560]  как бы некоторые особенности
[50:34.560 --> 50:36.560]  в том плане, что когда
[50:36.560 --> 50:38.560]  вы передаете вот какие-то данные,
[50:38.560 --> 50:40.560]  то это вот сейчас я сказал,
[50:40.560 --> 50:42.560]  что мы хотим передать строчку, там, 256 байт.
[50:42.560 --> 50:44.560]  На деле,
[50:44.560 --> 50:46.560]  когда вы хотите передать какие-то
[50:46.560 --> 50:48.560]  данные, это может быть какой-то более сложный объект.
[50:48.560 --> 50:50.560]  Потому что вашим
[50:50.560 --> 50:52.560]  программам,
[50:52.560 --> 50:54.560]  вашим, соответственно, приложениям
[50:54.560 --> 50:56.560]  чаще всего хочется
[50:56.560 --> 50:58.560]  передавать не голые байты, это мы привыкли
[50:58.560 --> 51:00.560]  писать на C, то есть мы
[51:00.560 --> 51:02.560]  как системные программисты мыслим, грубо говоря,
[51:02.560 --> 51:04.560]  в байках. А
[51:04.560 --> 51:06.560]  условно там
[51:06.560 --> 51:08.560]  какой-нибудь прикладной программист будет,
[51:08.560 --> 51:10.560]  ну вот я хочу передать текстуру.
[51:10.560 --> 51:12.560]  Или там я нарисовал какой-нибудь
[51:12.560 --> 51:14.560]  виджет, я его
[51:14.560 --> 51:16.560]  хочу туда передать. То есть это какие-то
[51:16.560 --> 51:18.560]  сложные, соответственно, объекты.
[51:18.560 --> 51:20.560]  И поэтому
[51:20.560 --> 51:22.560]  вот в момент, грубо говоря,
[51:22.560 --> 51:24.560]  вызова там вот этого IPC
[51:24.560 --> 51:26.560]  у вас еще будет там некоторая
[51:30.560 --> 51:32.560]  сериализация,
[51:32.560 --> 51:34.560]  то есть или упаковка, собственно,
[51:34.560 --> 51:36.560]  того объекта, который вы хотите передать,
[51:36.560 --> 51:38.560]  чтобы его можно было передать вот
[51:38.560 --> 51:40.560]  через механизм. И, соответственно, вот
[51:40.560 --> 51:42.560]  эта упаковка уже как раз она может быть
[51:42.560 --> 51:44.560]  механизирована так, чтобы размещать
[51:44.560 --> 51:46.560]  объект
[51:46.560 --> 51:48.560]  в какой-то выровненной памяти
[51:48.560 --> 51:50.560]  и тем самым, соответственно, сделать его удобным
[51:50.560 --> 51:52.560]  для передачи.
[51:52.560 --> 51:54.560]  Здесь есть
[51:54.560 --> 51:56.560]  некоторый нюанс, например,
[51:56.560 --> 51:58.560]  связанный
[51:58.560 --> 52:00.560]  с тем, что вот мы сейчас
[52:00.560 --> 52:02.560]  сделали отображение вот этого
[52:02.560 --> 52:04.560]  объекта сюда.
[52:04.560 --> 52:06.560]  И
[52:06.560 --> 52:08.560]  если у вас процессор там
[52:08.560 --> 52:10.560]  многоядерный, например,
[52:10.560 --> 52:12.560]  или просто пройдет достаточное количество времени
[52:12.560 --> 52:14.560]  и мы снова переключимся на P1,
[52:14.560 --> 52:16.560]  то, например, P1
[52:16.560 --> 52:18.560]  будет продолжать иметь доступ к этому объекту
[52:18.560 --> 52:20.560]  и может, например, его изменить.
[52:20.560 --> 52:22.560]  А P2 будет его в этот момент
[52:22.560 --> 52:24.560]  читать.
[52:24.560 --> 52:26.560]  Да, но тут как бы, в принципе, два пути.
[52:26.560 --> 52:28.560]  Ну, там один путь — это, соответственно,
[52:28.560 --> 52:30.560]  например, копию онрайна делать.
[52:30.560 --> 52:32.560]  То есть он возьмет, просто продублируется.
[52:32.560 --> 52:34.560]  Соответственно, второй путь — это можно
[52:34.560 --> 52:36.560]  просто взять и отобрать.
[52:36.560 --> 52:38.560]  Ну, то есть
[52:38.560 --> 52:40.560]  передать вот это владение
[52:40.560 --> 52:42.560]  этой страничкой, собственно, к тому
[52:42.560 --> 52:44.560]  процессу, который P2.
[52:44.560 --> 52:46.560]  Ну, например.
[52:46.560 --> 52:48.560]  Ну, с другой стороны, вы упаковали
[52:48.560 --> 52:50.560]  и зачем вам эта страница?
[52:50.560 --> 52:52.560]  Как обычно, да.
[52:52.560 --> 52:54.560]  Ну, там же в OpenGL
[52:54.560 --> 52:56.560]  это обретовывается постоянно, там,
[52:56.560 --> 52:58.560]  16 секунд, наверное,
[52:58.560 --> 53:00.560]  то передавали бутерброд.
[53:00.560 --> 53:02.560]  В OpenGL
[53:02.560 --> 53:04.560]  все еще зависит
[53:04.560 --> 53:06.560]  от того, какая у вас архитектура
[53:06.560 --> 53:08.560]  GPU. У вас же там
[53:08.560 --> 53:10.560]  может быть
[53:10.560 --> 53:12.560]  передача в видеопамять
[53:12.560 --> 53:14.560]  GPU,
[53:14.560 --> 53:16.560]  а может быть Unified Memory.
[53:16.560 --> 53:18.560]  И GPU может просто там
[53:18.560 --> 53:20.560]  получить прямой доступ.
[53:20.560 --> 53:22.560]  А еще у вас там DMA есть.
[53:22.560 --> 53:24.560]  Ну,
[53:24.560 --> 53:26.560]  как это, драйвера
[53:26.560 --> 53:28.560]  GPUшек достаточно
[53:28.560 --> 53:30.560]  сложные, достаточно
[53:30.560 --> 53:32.560]  закрытые.
[53:32.560 --> 53:34.560]  Я вам, наверное, я не являюсь
[53:34.560 --> 53:36.560]  перспектом по драйверам GPU
[53:36.560 --> 53:38.560]  и, наверное,
[53:38.560 --> 53:40.560]  хорошо ответить на ваш вопрос не смогу.
[53:40.560 --> 53:42.560]  Вот это будет, наверное,
[53:42.560 --> 53:44.560]  такое наиболее честное.
[53:44.560 --> 53:46.560]  Но
[53:46.560 --> 53:48.560]  в принципе в GPUшках
[53:48.560 --> 53:50.560]  просто разные модели памяти используют
[53:50.560 --> 53:52.560]  и там оптимизации
[53:52.560 --> 53:54.560]  могут быть достаточно
[53:54.560 --> 53:56.560]  там дичайшие
[53:56.560 --> 53:58.560]  в зависимости от того,
[53:58.560 --> 54:00.560]  какой там API используется.
[54:00.560 --> 54:02.560]  Вот.
[54:02.560 --> 54:04.560]  Вот.
[54:04.560 --> 54:06.560]  Так.
[54:06.560 --> 54:08.560]  Мы, кажется, немножко откатились.
[54:08.560 --> 54:10.560]  Вот.
[54:10.560 --> 54:12.560]  Соответственно в JOS
[54:12.560 --> 54:14.560]  используется там очень простенький
[54:14.560 --> 54:16.560]  механизм IPC.
[54:16.560 --> 54:18.560]  То есть, который
[54:18.560 --> 54:20.560]  работает ну вот
[54:20.560 --> 54:22.560]  по принципу обеспечения
[54:22.560 --> 54:24.560]  общей памяти. То есть
[54:24.560 --> 54:26.560]  в случае с JOS
[54:26.560 --> 54:28.560]  у нас нет тайм-аута.
[54:28.560 --> 54:30.560]  Соответственно и нету многопроцессности.
[54:30.560 --> 54:32.560]  Поэтому решается проблема то, что
[54:32.560 --> 54:34.560]  тот, кто отправил, может сообщение
[54:34.560 --> 54:36.560]  изменить до того, как, собственно, его прочитает
[54:36.560 --> 54:38.560]  процесс, который
[54:38.560 --> 54:40.560]  его, собственно, принят.
[54:40.560 --> 54:42.560]  Но
[54:42.560 --> 54:44.560]  в целом там механизм довольно простой.
[54:44.560 --> 54:46.560]  Выделяется
[54:46.560 --> 54:48.560]  некоторая страница общей памяти.
[54:50.560 --> 54:52.560]  В эту страницу копируются какие-то данные.
[54:52.560 --> 54:54.560]  И в дальнейшем
[54:54.560 --> 54:56.560]  между процессами происходит обмен.
[54:56.560 --> 54:58.560]  Ну, такой компромиссный и простой
[54:58.560 --> 55:00.560]  вариант организации IPC,
[55:00.560 --> 55:02.560]  который в целом там близок
[55:02.560 --> 55:04.560]  к тому, что можно встретить
[55:04.560 --> 55:06.560]  в других системах, ну если
[55:06.560 --> 55:08.560]  в очень упрощенном виде.
[55:08.560 --> 55:10.560]  Соответственно там недостатки, которые очевидно там
[55:10.560 --> 55:12.560]  решены в
[55:12.560 --> 55:14.560]  взрослых системах, это там нет
[55:14.560 --> 55:16.560]  тайм-аутов и, соответственно, там
[55:16.560 --> 55:18.560]  размер ограничен одной страницей.
[55:18.560 --> 55:20.560]  Но в рамках индивидуальных заданий
[55:20.560 --> 55:22.560]  это случается.
[55:22.560 --> 55:24.560]  Вот.
[55:24.560 --> 55:26.560]  Что касается
[55:26.560 --> 55:28.560]  IPC,
[55:28.560 --> 55:30.560]  то это вот там
[55:30.560 --> 55:32.560]  такой механизм, который я описывал,
[55:32.560 --> 55:34.560]  это лишь там один из способов IPC.
[55:34.560 --> 55:36.560]  То есть, ну, вот один из там способов, который
[55:36.560 --> 55:38.560]  организуется через там оперативную память.
[55:38.560 --> 55:40.560]  То есть, на рамках там
[55:40.560 --> 55:42.560]  стандартов там того же
[55:42.560 --> 55:44.560]  POSIX у вас там есть, например,
[55:44.560 --> 55:46.560]  там ITC через файловую
[55:46.560 --> 55:48.560]  систему, там всякие именованные
[55:48.560 --> 55:50.560]  каналы, неименованные каналы, там
[55:50.560 --> 55:52.560]  сетевой стэк, там те же
[55:52.560 --> 55:54.560]  колокиты, вот, там
[55:54.560 --> 55:56.560]  очереди сообщений, сигналы,
[55:56.560 --> 55:58.560]  то есть, в общем-то, выше
[55:58.560 --> 56:00.560]  крыши. То есть, вы используете те
[56:00.560 --> 56:02.560]  механизмы IPC,
[56:02.560 --> 56:04.560]  которые вам, собственно,
[56:04.560 --> 56:06.560]  удобнее для конкретной
[56:06.560 --> 56:08.560]  задачи.
[56:08.560 --> 56:10.560]  В принципе,
[56:10.560 --> 56:12.560]  как это главное, наверное,
[56:14.560 --> 56:16.560]  там вот, что можно
[56:16.560 --> 56:18.560]  провести как бы черту над всеми этими
[56:18.560 --> 56:20.560]  способами IPC,
[56:20.560 --> 56:22.560]  это
[56:22.560 --> 56:24.560]  в том, что они как бы
[56:24.560 --> 56:26.560]  должны быть
[56:26.560 --> 56:28.560]  как бы, ну, либо legit,
[56:28.560 --> 56:30.560]  либо там, наверное,
[56:30.560 --> 56:32.560]  вот так вот, типа
[56:32.560 --> 56:34.560]  authenticated, в смысле
[56:34.560 --> 56:36.560]  авторизованные. Потому что
[56:36.560 --> 56:38.560]  если
[56:38.560 --> 56:40.560]  у вас два процесса
[56:40.560 --> 56:42.560]  могут общаться друг
[56:42.560 --> 56:44.560]  с другом, то, соответственно, там
[56:44.560 --> 56:46.560]  целевая платформа или целевая операционная
[56:46.560 --> 56:48.560]  система должна об этом, по крайней мере,
[56:48.560 --> 56:50.560]  знать и, соответственно, выдать на это
[56:50.560 --> 56:52.560]  разрешение. Ну, там, как
[56:52.560 --> 56:54.560]  пример,
[56:54.560 --> 56:56.560]  можно, например, организовывать IPC
[56:56.560 --> 56:58.560]  спекулятивной атаки,
[56:58.560 --> 57:00.560]  ну, или через микроархитектурные баги.
[57:00.560 --> 57:02.560]  И вот
[57:02.560 --> 57:04.560]  такие виды IPC, они
[57:04.560 --> 57:06.560]  чаще всего
[57:06.560 --> 57:08.560]  не являются способами IPC по назначению.
[57:08.560 --> 57:10.560]  Простой пример,
[57:10.560 --> 57:12.560]  недавно
[57:12.560 --> 57:14.560]  вышел же M1,
[57:14.560 --> 57:16.560]  в М1 обнаружили один
[57:16.560 --> 57:18.560]  из регистров, который там не чистится
[57:18.560 --> 57:20.560]  при переключении контекстов.
[57:20.560 --> 57:22.560]  В результате два произвольных процесса
[57:22.560 --> 57:24.560]  могут класть в этот регистр, он
[57:24.560 --> 57:26.560]  записываемый прямо из юзерспейса,
[57:26.560 --> 57:28.560]  могут записывать какие-то данные
[57:28.560 --> 57:30.560]  и, соответственно, другой процесс
[57:30.560 --> 57:32.560]  может эти данные считывать.
[57:32.560 --> 57:34.560]  Вполне себе неплохо работает.
[57:36.560 --> 57:38.560]  Да, это
[57:38.560 --> 57:40.560]  про регистр, грубо говоря, просто забыли.
[57:40.560 --> 57:42.560]  То есть, ну, так случается.
[57:44.560 --> 57:46.560]  Можете
[57:46.560 --> 57:48.560]  загуглить там
[57:48.560 --> 57:50.560]  CVS.
[57:50.560 --> 57:52.560]  Я конкретно имени не назову,
[57:52.560 --> 57:54.560]  но там, по-моему, какая-то статистика просто
[57:54.560 --> 57:56.560]  накапливалась процессором.
[57:56.560 --> 57:58.560]  Да,
[57:58.560 --> 58:00.560]  то есть там вполне себе можно было
[58:00.560 --> 58:02.560]  использовать какие-то циклические коды, которые
[58:02.560 --> 58:04.560]  вам гарантированно позволяли
[58:04.560 --> 58:06.560]  убедиться, что данные, которые
[58:06.560 --> 58:08.560]  вы туда записали, они не повредились.
[58:08.560 --> 58:10.560]  И достаточно такой быстренький канал
[58:10.560 --> 58:12.560]  обмена данных.
[58:12.560 --> 58:14.560]  Насколько я помню, сейчас уже все починили.
[58:14.560 --> 58:16.560]  То есть, ну, просто надо было
[58:16.560 --> 58:18.560]  убрать доступ
[58:18.560 --> 58:20.560]  от операционной системы.
[58:20.560 --> 58:22.560]  И сейчас
[58:22.560 --> 58:24.560]  уже, в принципе, все хорошо. Но, как пример,
[58:24.560 --> 58:26.560]  то есть, если у вас
[58:26.560 --> 58:28.560]  есть какие-то баги
[58:28.560 --> 58:30.560]  либо в ядре, либо
[58:30.560 --> 58:32.560]  в
[58:32.560 --> 58:34.560]  собственно, в вашей
[58:34.560 --> 58:36.560]  микроакферитуре, в оборудовании,
[58:36.560 --> 58:38.560]  все эти вещи могут быть использованы в ротифаз.
[58:38.560 --> 58:40.560]  И, соответственно, если будут общаться
[58:40.560 --> 58:42.560]  процессы, которые там
[58:42.560 --> 58:44.560]  не должны друг другом общаться, то станет
[58:44.560 --> 58:46.560]  неплохо. Ну, представьте
[58:46.560 --> 58:48.560]  такой пример. Есть
[58:48.560 --> 58:50.560]  какое-нибудь там приложение
[58:50.560 --> 58:52.560]  вредоносное, которое запускается в песочнице.
[58:52.560 --> 58:54.560]  Соответственно,
[58:54.560 --> 58:56.560]  с счет того, что оно запускается в песочнице,
[58:56.560 --> 58:58.560]  соответственно, у него нет возможности
[58:58.560 --> 59:00.560]  навредить вашему целевому
[59:00.560 --> 59:02.560]  устройству. То есть, например, оно своровало
[59:02.560 --> 59:04.560]  какие-то секреты, но оно их не может никуда передать.
[59:04.560 --> 59:06.560]  А есть, например, другое приложение, например,
[59:06.560 --> 59:08.560]  браузер, который может общаться там
[59:08.560 --> 59:10.560]  с интернетом. И
[59:10.560 --> 59:12.560]  в браузере, например, есть специальный
[59:12.560 --> 59:14.560]  бэкдор, который там
[59:14.560 --> 59:16.560]  готов по каким-то скрытым каналам
[59:16.560 --> 59:18.560]  принимать сообщения
[59:18.560 --> 59:20.560]  и их передавать в
[59:20.560 --> 59:22.560]  сеть по нужному адресу.
[59:22.560 --> 59:24.560]  При этом сам браузер не занимается
[59:24.560 --> 59:26.560]  никаким воровством, потому что у него
[59:26.560 --> 59:28.560]  на это прав.
[59:28.560 --> 59:30.560]  Поэтому такие атаки вполне себе используются,
[59:30.560 --> 59:32.560]  и вас, как разработчик
[59:32.560 --> 59:34.560]  операционной системы, нужно грамотно
[59:34.560 --> 59:36.560]  достаточно там
[59:36.560 --> 59:38.560]  любиться в том, что грамотно организована архитектура.
[59:44.560 --> 59:46.560]  Да, по-моему, это мы исправили уже.
[59:46.560 --> 59:48.560]  Там она и должна чистить.
[59:52.560 --> 59:54.560]  Я не уверен, что там...
[59:54.560 --> 59:56.560]  Нет, там вполне
[59:56.560 --> 59:58.560]  возможно, что данные под
[59:58.560 --> 01:00:00.560]  что-то просто используются, но, по-моему,
[01:00:00.560 --> 01:00:02.560]  мы уже исправили.
[01:00:02.560 --> 01:00:04.560]  Можно будет подробнее почитать.
[01:00:06.560 --> 01:00:08.560]  То есть бывают ситуации,
[01:00:08.560 --> 01:00:10.560]  когда действительно там
[01:00:10.560 --> 01:00:12.560]  записать какие-то данные нельзя
[01:00:12.560 --> 01:00:14.560]  без
[01:00:14.560 --> 01:00:16.560]  повреждения каких-то там
[01:00:16.560 --> 01:00:18.560]  внутренних структур, но это не в данной
[01:00:18.560 --> 01:00:20.560]  ситуации. Там, скорее всего,
[01:00:20.560 --> 01:00:22.560]  были не очень приятные
[01:00:22.560 --> 01:00:24.560]  последствия для производительности.
[01:00:26.560 --> 01:00:28.560]  И, как бы, видимо,
[01:00:28.560 --> 01:00:30.560]  авторы посчитали, что на эти
[01:00:30.560 --> 01:00:32.560]  жертвы производительности никто не пойдет.
[01:00:32.560 --> 01:00:34.560]  А там, по-моему, просто нормально
[01:00:34.560 --> 01:00:36.560]  все и никаких проблем в производительности не было.
[01:00:40.560 --> 01:00:42.560]  Соответственно, что касается
[01:00:42.560 --> 01:00:44.560]  IPC, то
[01:00:44.560 --> 01:00:46.560]  в нашем случае мы будем использовать
[01:00:46.560 --> 01:00:48.560]  IPC для
[01:00:48.560 --> 01:00:50.560]  организации доступа к
[01:00:50.560 --> 01:00:52.560]  файловой системе.
[01:00:52.560 --> 01:00:54.560]  Ну, по идее, как
[01:00:54.560 --> 01:00:56.560]  выглядит классическая файловая
[01:00:56.560 --> 01:00:58.560]  система, вы там плюс-минус
[01:00:58.560 --> 01:01:00.560]  должны знать. Я, как понимаю,
[01:01:00.560 --> 01:01:02.560]  не вполне знаете, поэтому
[01:01:02.560 --> 01:01:04.560]  мы, наверное, немножко здесь остановимся.
[01:01:06.560 --> 01:01:08.560]  Ну, соответственно, здесь
[01:01:10.560 --> 01:01:12.560]  есть классическая
[01:01:12.560 --> 01:01:14.560]  схемка, когда
[01:01:16.560 --> 01:01:18.560]  у вас здесь может быть какой-то
[01:01:18.560 --> 01:01:20.560]  физический носитель, например,
[01:01:20.560 --> 01:01:22.560]  MVME диск какой-нибудь,
[01:01:22.560 --> 01:01:24.560]  SATA диск,
[01:01:24.560 --> 01:01:26.560]  флешка,
[01:01:26.560 --> 01:01:28.560]  неважно. То есть фактически некоторые устройства,
[01:01:28.560 --> 01:01:30.560]  которые являются
[01:01:30.560 --> 01:01:32.560]  накопителем данных, может быть даже
[01:01:32.560 --> 01:01:34.560]  оперативной памяти.
[01:01:34.560 --> 01:01:36.560]  Соответственно, далее
[01:01:36.560 --> 01:01:38.560]  от этого устройства
[01:01:38.560 --> 01:01:40.560]  до пользователя,
[01:01:40.560 --> 01:01:42.560]  который является потребителем
[01:01:42.560 --> 01:01:44.560]  файловой системы, то есть является
[01:01:44.560 --> 01:01:46.560]  человеком, который
[01:01:46.560 --> 01:01:48.560]  будет с ней взаимодействовать,
[01:01:48.560 --> 01:01:50.560]  есть чаще всего
[01:01:50.560 --> 01:01:52.560]  цепочка, как минимум, из трех
[01:01:52.560 --> 01:01:54.560]  оплов, то есть из трех драйверов,
[01:01:54.560 --> 01:01:56.560]  которые
[01:01:56.560 --> 01:01:58.560]  от каждой отвечают за свою
[01:01:58.560 --> 01:02:00.560]  знаменность. Ну, вот как пример,
[01:02:02.560 --> 01:02:04.560]  первое, что она встречается,
[01:02:04.560 --> 01:02:06.560]  это некоторый блокчный драйвер.
[01:02:06.560 --> 01:02:08.560]  Представляете, как работает блокчный драйвер?
[01:02:08.560 --> 01:02:10.560]  Наверное, он как-то оставляет доступ к носителю
[01:02:10.560 --> 01:02:12.560]  в каком-то ладжу уровня. Правильно.
[01:02:12.560 --> 01:02:14.560]  Соответственно, действительно,
[01:02:14.560 --> 01:02:16.560]  у блокчного драйвера
[01:02:16.560 --> 01:02:18.560]  задача предоставить
[01:02:18.560 --> 01:02:20.560]  интерфейс, вида
[01:02:20.560 --> 01:02:22.560]  чтения, соответственно,
[01:02:22.560 --> 01:02:24.560]  запись к
[01:02:24.560 --> 01:02:26.560]  нашему носителю.
[01:02:26.560 --> 01:02:28.560]  Соответственно,
[01:02:28.560 --> 01:02:30.560]  блокчный драйвер
[01:02:30.560 --> 01:02:32.560]  на той и собственной блокчинке работает блоками,
[01:02:32.560 --> 01:02:34.560]  потому что каждый отдельно
[01:02:34.560 --> 01:02:36.560]  взятый носитель, он может
[01:02:36.560 --> 01:02:38.560]  не иметь
[01:02:38.560 --> 01:02:40.560]  возможности писать, например,
[01:02:40.560 --> 01:02:42.560]  по одному байту.
[01:02:42.560 --> 01:02:44.560]  То есть стандартные, грубо говоря, особенностью
[01:02:44.560 --> 01:02:46.560]  каждого носителя это
[01:02:46.560 --> 01:02:48.560]  сектор размером.
[01:02:48.560 --> 01:02:50.560]  Ну, это
[01:02:50.560 --> 01:02:52.560]  типичные значения, которые
[01:02:52.560 --> 01:02:54.560]  можно встретить.
[01:02:54.560 --> 01:02:58.560]  То есть 512-4996 бай.
[01:03:00.560 --> 01:03:02.560]  И именно примерно с такой гранулярностью
[01:03:02.560 --> 01:03:04.560]  вы можете выполнять
[01:03:04.560 --> 01:03:06.560]  атомарные операции с вашим
[01:03:06.560 --> 01:03:08.560]  физическим носителем.
[01:03:08.560 --> 01:03:10.560]  Ну, хорошо если атомарными,
[01:03:10.560 --> 01:03:12.560]  потому что
[01:03:12.560 --> 01:03:14.560]  здесь, например, может быть какой-нибудь кэш,
[01:03:14.560 --> 01:03:16.560]  и этот кэш окажется
[01:03:16.560 --> 01:03:18.560]  энергозависимым.
[01:03:18.560 --> 01:03:20.560]  Выключили питание и выяснили, что
[01:03:20.560 --> 01:03:22.560]  те данные, которые вы записали, они
[01:03:22.560 --> 01:03:24.560]  остались в кэше.
[01:03:24.560 --> 01:03:26.560]  Отключение питания, соответственно,
[01:03:26.560 --> 01:03:28.560]  от кэша, собственно,
[01:03:28.560 --> 01:03:30.560]  эти данные потерял, и у вас оказалась
[01:03:30.560 --> 01:03:32.560]  файловая система в каком-то неконсистентном
[01:03:32.560 --> 01:03:34.560]  состоянии.
[01:03:34.560 --> 01:03:36.560]  Ну, это там сильно... Что?
[01:03:36.560 --> 01:03:38.560]  Ну, для ускорения.
[01:03:38.560 --> 01:03:40.560]  Да.
[01:03:40.560 --> 01:03:42.560]  На самом деле, все достаточно
[01:03:42.560 --> 01:03:44.560]  не так плохо.
[01:03:44.560 --> 01:03:46.560]  Хотя, как бы, на 100%
[01:03:46.560 --> 01:03:48.560]  быть уверенным,
[01:03:48.560 --> 01:03:50.560]  что у вас такой проблемы нет, можно только отриверсить
[01:03:50.560 --> 01:03:52.560]  прошивку своего SSD, например.
[01:03:52.560 --> 01:03:54.560]  А это довольно долго.
[01:04:12.560 --> 01:04:14.560]  Ну, я здесь могу
[01:04:14.560 --> 01:04:16.560]  сказать, что просто
[01:04:16.560 --> 01:04:18.560]  некоторые проблемы
[01:04:18.560 --> 01:04:20.560]  можно решать на разных уровнях.
[01:04:20.560 --> 01:04:22.560]  То есть, мы как это... Помним про
[01:04:22.560 --> 01:04:24.560]  закон сохранения боли.
[01:04:24.560 --> 01:04:26.560]  Вот, соответственно, боль можно передвинуть
[01:04:26.560 --> 01:04:28.560]  из одного места в другое место.
[01:04:28.560 --> 01:04:30.560]  Например, там, не знаю, ups поставить.
[01:04:30.560 --> 01:04:32.560]  Как в свое
[01:04:32.560 --> 01:04:34.560]  время
[01:04:34.560 --> 01:04:36.560]  был у нас студент, его, собственно,
[01:04:36.560 --> 01:04:38.560]  на защите спрашивали,
[01:04:38.560 --> 01:04:40.560]  а вот если у компьютера
[01:04:40.560 --> 01:04:42.560]  отключится питание, то что надо делать?
[01:04:42.560 --> 01:04:44.560]  Подумал, подумал,
[01:04:44.560 --> 01:04:46.560]  ups надо поставить.
[01:04:46.560 --> 01:04:48.560]  А если
[01:04:48.560 --> 01:04:50.560]  отключится питание,
[01:04:50.560 --> 01:04:52.560]  его там долго не будет.
[01:04:52.560 --> 01:04:54.560]  Побольше ups надо будет поставить.
[01:04:54.560 --> 01:04:56.560]  А если
[01:04:56.560 --> 01:04:58.560]  прям совсем долго не будет,
[01:04:58.560 --> 01:05:00.560]  ну, еще больше ups
[01:05:00.560 --> 01:05:02.560]  нужно будет поставить с дизельными
[01:05:02.560 --> 01:05:04.560]  генераторами.
[01:05:04.560 --> 01:05:06.560]  А там
[01:05:06.560 --> 01:05:08.560]  штуки-реакты, короче, маломощные,
[01:05:08.560 --> 01:05:10.560]  которые поддерживаются
[01:05:10.560 --> 01:05:12.560]  абсолютно долгое время,
[01:05:12.560 --> 01:05:14.560]  можно такое поставить. Можно такое
[01:05:14.560 --> 01:05:16.560]  производство ракетом
[01:05:16.560 --> 01:05:18.560]  как раз.
[01:05:18.560 --> 01:05:20.560]  Здесь, скорее, просто
[01:05:20.560 --> 01:05:22.560]  суть в том, что
[01:05:22.560 --> 01:05:24.560]  не нужно ограничивать
[01:05:24.560 --> 01:05:26.560]  свою фантазию
[01:05:26.560 --> 01:05:28.560]  в рамках применения
[01:05:28.560 --> 01:05:30.560]  единого, некоторого архитектурного
[01:05:30.560 --> 01:05:32.560]  паттерна при решении какой-то конкретный
[01:05:32.560 --> 01:05:34.560]  проблем.
[01:05:34.560 --> 01:05:36.560]  Соответственно, на том мы как бы здесь
[01:05:36.560 --> 01:05:38.560]  и сидим, что
[01:05:40.560 --> 01:05:42.560]  даже одну и ту же проблему
[01:05:42.560 --> 01:05:44.560]  можно решать разными способами
[01:05:44.560 --> 01:05:46.560]  и при этом достигать там разной эффективности.
[01:05:46.560 --> 01:05:48.560]  Соответственно,
[01:05:48.560 --> 01:05:50.560]  блокчный драйвер вам предоставляет
[01:05:50.560 --> 01:05:52.560]  чаще всего там по-секторное,
[01:05:52.560 --> 01:05:54.560]  атомарное. Если там
[01:05:54.560 --> 01:05:56.560]  брать там современные системы,
[01:05:56.560 --> 01:05:58.560]  то там побайтовое, не атомарное
[01:05:58.560 --> 01:06:00.560]  обращение к
[01:06:00.560 --> 01:06:02.560]  вашему физическому носителю.
[01:06:02.560 --> 01:06:04.560]  И
[01:06:04.560 --> 01:06:06.560]  на самом деле, вот здесь
[01:06:06.560 --> 01:06:08.560]  нарисован один блокчный драйвер,
[01:06:08.560 --> 01:06:10.560]  но нередко
[01:06:10.560 --> 01:06:12.560]  у вас их больше.
[01:06:12.560 --> 01:06:14.560]  Догадываетесь, почему?
[01:06:14.560 --> 01:06:16.560]  Нет, нет, нет.
[01:06:16.560 --> 01:06:18.560]  В смысле один в рамках одной цепочки.
[01:06:18.560 --> 01:06:20.560]  То есть понятно, что вот это описан
[01:06:20.560 --> 01:06:22.560]  какой-то некоторый инстанс.
[01:06:22.560 --> 01:06:24.560]  То есть грубо говоря, там
[01:06:24.560 --> 01:06:26.560]  один физический носитель,
[01:06:26.560 --> 01:06:28.560]  такая цепочка, то есть понятно, что
[01:06:28.560 --> 01:06:30.560]  в блокчных драйверах для разных
[01:06:30.560 --> 01:06:32.560]  носителей может быть больше.
[01:06:32.560 --> 01:06:34.560]  Нет, это просто
[01:06:34.560 --> 01:06:36.560]  примеры популярных размеров
[01:06:36.560 --> 01:06:38.560]  секторов на диске.
[01:06:38.560 --> 01:06:40.560]  Не нужно брать, что
[01:06:40.560 --> 01:06:42.560]  блокчный драйвер может
[01:06:42.560 --> 01:06:44.560]  работать вот только с такими размерами
[01:06:44.560 --> 01:06:46.560]  и не с какими больше.
[01:06:46.560 --> 01:06:48.560]  То есть тут на самом деле
[01:06:48.560 --> 01:06:50.560]  просто вот некоторый пример чисел.
[01:06:52.560 --> 01:06:54.560]  Вот это уже ближе.
[01:06:54.560 --> 01:06:56.560]  Для чего?
[01:06:56.560 --> 01:06:58.560]  Потому что
[01:06:58.560 --> 01:07:00.560]  блокчный драйвер
[01:07:00.560 --> 01:07:02.560]  вот это уже ближе.
[01:07:02.560 --> 01:07:04.560]  Для чего это может использоваться?
[01:07:04.560 --> 01:07:06.560]  Нет, быстрее не будет у вас стерилизации.
[01:07:08.560 --> 01:07:10.560]  Разные разделы.
[01:07:10.560 --> 01:07:12.560]  Соответственно у вас диск может
[01:07:12.560 --> 01:07:14.560]  избиваться на разделы там, ну или на
[01:07:14.560 --> 01:07:16.560]  контейнеры, и соответственно в зависимости
[01:07:16.560 --> 01:07:18.560]  от того, как именно
[01:07:18.560 --> 01:07:20.560]  устроена геометрия вашего носителя,
[01:07:20.560 --> 01:07:22.560]  соответственно может быть там
[01:07:22.560 --> 01:07:24.560]  еще несколько, грубо говоря,
[01:07:24.560 --> 01:07:26.560]  блокчных драйверов.
[01:07:26.560 --> 01:07:28.560]  Соответственно каждый
[01:07:28.560 --> 01:07:30.560]  свой раздел
[01:07:30.560 --> 01:07:32.560]  жёсткого диска,
[01:07:32.560 --> 01:07:34.560]  твердотельного накопителя, неважно,
[01:07:34.560 --> 01:07:36.560]  который фактически занимается
[01:07:36.560 --> 01:07:38.560]  тем, что транслирует
[01:07:38.560 --> 01:07:40.560]  координаты, транслирует геометрию,
[01:07:40.560 --> 01:07:42.560]  то есть
[01:07:42.560 --> 01:07:44.560]  добавляет необходимое
[01:07:44.560 --> 01:07:46.560]  смещение к
[01:07:46.560 --> 01:07:48.560]  этим запросам и обращается
[01:07:48.560 --> 01:07:50.560]  к родительскому драйверу.
[01:07:50.560 --> 01:07:52.560]  Это сильно упрощает
[01:07:52.560 --> 01:07:54.560]  написание некоторого кода
[01:07:54.560 --> 01:07:56.560]  для того же драйвера файловой системы,
[01:07:56.560 --> 01:07:58.560]  потому что вам не нужно
[01:07:58.560 --> 01:08:00.560]  постоянно держать в уме, что вот мой раздел
[01:08:00.560 --> 01:08:02.560]  от SIG до SIG достаточно считать,
[01:08:02.560 --> 01:08:04.560]  что у вас там
[01:08:04.560 --> 01:08:06.560]  мои данные от нулевого там, грубо говоря,
[01:08:06.560 --> 01:08:08.560]  сектора до такого-то, просто этот нулевой сектор
[01:08:08.560 --> 01:08:10.560]  он на самом деле вертолетний.
[01:08:10.560 --> 01:08:12.560]  Вот.
[01:08:12.560 --> 01:08:14.560]  Это что касается блокчного драйвера.
[01:08:14.560 --> 01:08:16.560]  После блокчного драйвера чаще всего
[01:08:16.560 --> 01:08:18.560]  то есть у вас идет
[01:08:18.560 --> 01:08:20.560]  сам непосредственно драйвер файловой системы,
[01:08:20.560 --> 01:08:22.560]  и драйвер файловой системы там
[01:08:22.560 --> 01:08:24.560]  реализуется поверх
[01:08:24.560 --> 01:08:26.560]  классических там, грубо говоря,
[01:08:28.560 --> 01:08:30.560]  интерфейсов блокчного драйвера
[01:08:30.560 --> 01:08:32.560]  и представляют уже там такие
[01:08:32.560 --> 01:08:34.560]  соответственно там
[01:08:34.560 --> 01:08:36.560]  сервисы соответственно, как там
[01:08:36.560 --> 01:08:38.560]  типа open
[01:08:38.560 --> 01:08:40.560]  ну в смысле
[01:08:40.560 --> 01:08:42.560]  там для директории
[01:08:42.560 --> 01:08:44.560]  соответственно там
[01:08:44.560 --> 01:08:46.560]  read,
[01:08:46.560 --> 01:08:48.560]  write, ну в смысле в рамках там
[01:08:48.560 --> 01:08:50.560]  некоторого файла, там соответственно
[01:08:50.560 --> 01:08:52.560]  может быть там какой-нибудь лист,
[01:08:52.560 --> 01:08:54.560]  то есть грубо говоря
[01:08:54.560 --> 01:08:56.560]  прочитать содержимое директории
[01:08:56.560 --> 01:08:58.560]  и так далее.
[01:08:58.560 --> 01:09:00.560]  Соответственно
[01:09:00.560 --> 01:09:02.560]  этот интерфейс
[01:09:02.560 --> 01:09:04.560]  он определяется
[01:09:04.560 --> 01:09:06.560]  некоторым
[01:09:06.560 --> 01:09:08.560]  компонентом, который называется
[01:09:08.560 --> 01:09:10.560]  виртуальная файловая система, или иначе
[01:09:10.560 --> 01:09:12.560]  VFS. Слышали
[01:09:12.560 --> 01:09:14.560]  про VFS, я думаю.
[01:09:14.560 --> 01:09:16.560]  Ну то есть
[01:09:16.560 --> 01:09:18.560]  в операционной системе присутствует
[01:09:18.560 --> 01:09:20.560]  такой компент, как
[01:09:20.560 --> 01:09:22.560]  виртуальная файловая система,
[01:09:22.560 --> 01:09:24.560]  к которой подключаются
[01:09:24.560 --> 01:09:26.560]  соответственно различные драйверы
[01:09:26.560 --> 01:09:28.560]  файловых систем.
[01:09:28.560 --> 01:09:30.560]  Ну например там может быть драйвер
[01:09:30.560 --> 01:09:32.560]  какой-нибудь там X4, там NTFS
[01:09:32.560 --> 01:09:34.560]  и так далее. И каждый соответственно
[01:09:34.560 --> 01:09:36.560]  драйвер, он может реализовывать
[01:09:36.560 --> 01:09:38.560]  там некоторый понятный
[01:09:38.560 --> 01:09:40.560]  набор системных вызовов и
[01:09:40.560 --> 01:09:42.560]  дерг, ну не системных вызовов,
[01:09:42.560 --> 01:09:44.560]  оговорился, соответственно, ну
[01:09:44.560 --> 01:09:46.560]  понятный набор интерфейсов,
[01:09:46.560 --> 01:09:48.560]  который
[01:09:48.560 --> 01:09:50.560]  может использовать виртуальная файловая система
[01:09:50.560 --> 01:09:52.560]  для того, чтобы
[01:09:52.560 --> 01:09:54.560]  соответственно
[01:09:54.560 --> 01:09:56.560]  самостоятельно уже обеспечить
[01:09:56.560 --> 01:09:58.560]  там некоторый доступ к файловой системе
[01:09:58.560 --> 01:10:00.560]  для пользователя
[01:10:00.560 --> 01:10:02.560]  через там отдельно взятые
[01:10:02.560 --> 01:10:04.560]  стенные вызовы.
[01:10:04.560 --> 01:10:06.560]  Для чего это нужно? Ну это нужно
[01:10:06.560 --> 01:10:08.560]  в первую очередь для юнификации,
[01:10:08.560 --> 01:10:10.560]  то есть ну например мы все знаем,
[01:10:10.560 --> 01:10:12.560]  что там в Unix
[01:10:12.560 --> 01:10:14.560]  файловая система там, она выглядит
[01:10:14.560 --> 01:10:16.560]  как некоторое там дерево
[01:10:16.560 --> 01:10:18.560]  фактически. То есть есть некоторый корень
[01:10:18.560 --> 01:10:20.560]  там, а здесь там может быть
[01:10:20.560 --> 01:10:22.560]  там, грубо говоря,
[01:10:22.560 --> 01:10:24.560]  разные директории,
[01:10:24.560 --> 01:10:26.560]  при этом соответственно эти директории могут быть
[01:10:26.560 --> 01:10:28.560]  реально
[01:10:28.560 --> 01:10:30.560]  подмонтированными другими разделами
[01:10:30.560 --> 01:10:32.560]  собственно другими файловыми системами.
[01:10:32.560 --> 01:10:34.560]  То есть
[01:10:34.560 --> 01:10:36.560]  иерархичное представление.
[01:10:36.560 --> 01:10:38.560]  Для VFS это в целом
[01:10:38.560 --> 01:10:40.560]  не важно, потому что VFS может
[01:10:40.560 --> 01:10:42.560]  по-разному маппить вас
[01:10:42.560 --> 01:10:44.560]  к драйверам
[01:10:44.560 --> 01:10:46.560]  файловой системы.
[01:10:46.560 --> 01:10:48.560]  Но в целом это такой наглядный пример,
[01:10:48.560 --> 01:10:50.560]  от чего
[01:10:50.560 --> 01:10:52.560]  нужен VFS.
[01:10:52.560 --> 01:10:54.560]  Кроме этого соответственно здесь могут быть
[01:10:54.560 --> 01:10:56.560]  различные кэшей,
[01:10:56.560 --> 01:10:58.560]  соответственно там всяких
[01:10:58.560 --> 01:11:00.560]  high-node и прочих
[01:11:00.560 --> 01:11:02.560]  вещей, которые
[01:11:02.560 --> 01:11:04.560]  вам позволяют там
[01:11:04.560 --> 01:11:06.560]  ускорить поиск, ускорить соответственно
[01:11:06.560 --> 01:11:08.560]  чтение. Любая там
[01:11:08.560 --> 01:11:10.560]  файловая система, она
[01:11:10.560 --> 01:11:12.560]  характеризуется фактически
[01:11:12.560 --> 01:11:14.560]  некоторыми там лимитами,
[01:11:14.560 --> 01:11:16.560]  то есть там лимит вложенности, например,
[01:11:16.560 --> 01:11:18.560]  лимит длины пути.
[01:11:18.560 --> 01:11:20.560]  И соответственно
[01:11:20.560 --> 01:11:22.560]  вот тут
[01:11:22.560 --> 01:11:24.560]  и тут
[01:11:24.560 --> 01:11:26.560]  эти лимиты должны
[01:11:26.560 --> 01:11:28.560]  быть согласованы,
[01:11:28.560 --> 01:11:30.560]  потому что
[01:11:30.560 --> 01:11:32.560]  есть лимиты, которые устанавливает
[01:11:32.560 --> 01:11:34.560]  там операционная система, есть
[01:11:34.560 --> 01:11:36.560]  лимиты, которые там
[01:11:36.560 --> 01:11:38.560]  дополнительно возникают
[01:11:38.560 --> 01:11:40.560]  при доступе
[01:11:40.560 --> 01:11:42.560]  к файловой системе, соответственно нужно
[01:11:42.560 --> 01:11:44.560]  эффективно взять наименьшие из них.
[01:11:46.560 --> 01:11:48.560]  Что вот в этой
[01:11:48.560 --> 01:11:50.560]  классической схеме
[01:11:50.560 --> 01:11:52.560]  скажем так не очень хорошо?
[01:11:52.560 --> 01:11:54.560]  Есть мысли?
[01:12:02.560 --> 01:12:04.560]  Вот эта вот красненькая
[01:12:04.560 --> 01:12:06.560]  это то, что
[01:12:06.560 --> 01:12:08.560]  чаще всего вот это все находится в ядре.
[01:12:10.560 --> 01:12:12.560]  И как раз вот это
[01:12:12.560 --> 01:12:14.560]  на самом деле это не очень хорошо.
[01:12:14.560 --> 01:12:16.560]  Не очень хорошо, потому
[01:12:16.560 --> 01:12:18.560]  что мы крайне
[01:12:18.560 --> 01:12:20.560]  увеличиваем соответственно
[01:12:20.560 --> 01:12:22.560]  поверхность атаки,
[01:12:22.560 --> 01:12:24.560]  то есть крайне увеличиваем
[01:12:24.560 --> 01:12:26.560]  объем кода в ядерном пространстве
[01:12:26.560 --> 01:12:28.560]  и за счет этого увеличиваем соответственно
[01:12:28.560 --> 01:12:30.560]  поверхность атаки на
[01:12:30.560 --> 01:12:32.560]  операционную систему. Фактически
[01:12:32.560 --> 01:12:34.560]  каждый, грубо говоря, там добавленный
[01:12:34.560 --> 01:12:36.560]  драйвер файловой системы, он там
[01:12:36.560 --> 01:12:38.560]  снижает нашу безопасность
[01:12:38.560 --> 01:12:40.560]  и это скажем так
[01:12:40.560 --> 01:12:42.560]  не очень хорошо.
[01:12:46.560 --> 01:12:48.560]  Да. Соответственно
[01:12:48.560 --> 01:12:50.560]  если у вас микроядерная архитектура
[01:12:50.560 --> 01:12:52.560]  операционной системы, то
[01:12:52.560 --> 01:12:54.560]  действительно
[01:12:54.560 --> 01:12:56.560]  вот эти вот вещи
[01:12:56.560 --> 01:12:58.560]  они там по максимуму
[01:12:58.560 --> 01:13:00.560]  выносятся в user space.
[01:13:00.560 --> 01:13:02.560]  Но на самом деле даже если у вас
[01:13:02.560 --> 01:13:04.560]  монолитная архитектура операционной
[01:13:04.560 --> 01:13:06.560]  системы, то
[01:13:06.560 --> 01:13:08.560]  далеко не все вот это вот
[01:13:08.560 --> 01:13:10.560]  может находиться в user space.
[01:13:10.560 --> 01:13:12.560]  Можете привести какие-нибудь такие примеры?
[01:13:22.560 --> 01:13:24.560]  Физический носитель
[01:13:24.560 --> 01:13:26.560]  это в смысле черненькое, потому что
[01:13:26.560 --> 01:13:28.560]  это оборудование.
[01:13:28.560 --> 01:13:30.560]  Да, вот здесь
[01:13:30.560 --> 01:13:32.560]  на самом деле еще может быть
[01:13:32.560 --> 01:13:34.560]  несколько драйверов, типа драйвер
[01:13:34.560 --> 01:13:36.560]  шины там.
[01:13:42.560 --> 01:13:44.560]  Это RAM.
[01:13:44.560 --> 01:13:46.560]  То есть в нашем
[01:13:46.560 --> 01:13:48.560]  случае это все еще
[01:13:48.560 --> 01:13:50.560]  физическое устройство,
[01:13:50.560 --> 01:13:52.560]  не находящееся в ядре, потому что это
[01:13:52.560 --> 01:13:54.560]  оперативная память.
[01:13:56.560 --> 01:13:58.560]  Но это не означает то, что
[01:13:58.560 --> 01:14:00.560]  грубо говоря
[01:14:00.560 --> 01:14:02.560]  код ядра действительно находится в оперативной
[01:14:02.560 --> 01:14:04.560]  памяти, но оперативная память не является кодом ядра.
[01:14:10.560 --> 01:14:12.560]  Ну по крайней мере у нас сейчас
[01:14:12.560 --> 01:14:14.560]  не курс какой-нибудь по ПЛИСу, поэтому
[01:14:18.560 --> 01:14:20.560]  Так вот, в случае
[01:14:24.560 --> 01:14:26.560]  с системами общего назначения, догадывайтесь
[01:14:26.560 --> 01:14:28.560]  в каком случае это
[01:14:28.560 --> 01:14:30.560]  может быть не так?
[01:14:32.560 --> 01:14:34.560]  Да-да-да-да, ладно, хорошо.
[01:14:34.560 --> 01:14:36.560]  Тогда вопрос
[01:14:38.560 --> 01:14:40.560]  Вы этим пользуетесь?
[01:14:40.560 --> 01:14:42.560]  Как вы думаете?
[01:14:44.560 --> 01:14:46.560]  Ну раз вы спрашиваете, наверное давно
[01:14:46.560 --> 01:14:48.560]  не знал об этом.
[01:14:48.560 --> 01:14:50.560]  Так, хорошо.
[01:14:52.560 --> 01:14:54.560]  Ну вот это уже возможно, да.
[01:14:54.560 --> 01:14:56.560]  То есть, например, там самый простой пример
[01:14:56.560 --> 01:14:58.560]  это какой-нибудь там драйвер NTFS
[01:14:58.560 --> 01:15:00.560]  в линуксе, пока его
[01:15:00.560 --> 01:15:02.560]  замергили в каком-то виде ядро.
[01:15:02.560 --> 01:15:04.560]  То есть был такой пакет,
[01:15:04.560 --> 01:15:06.560]  назывался NTFS 3G.
[01:15:06.560 --> 01:15:08.560]  Вот NTFS 3G действительно работал
[01:15:08.560 --> 01:15:10.560]  через фьюз. Там всякие были вещи
[01:15:10.560 --> 01:15:12.560]  типа SSHFS, то есть когда
[01:15:12.560 --> 01:15:14.560]  можно подмонтировать удаленную файловую
[01:15:14.560 --> 01:15:16.560]  систему прямо через SSH протокол.
[01:15:16.560 --> 01:15:18.560]  Ну вот, соответственно, тоже использует
[01:15:18.560 --> 01:15:20.560]  фьюз. Идея
[01:15:20.560 --> 01:15:22.560]  File System in User Space
[01:15:22.560 --> 01:15:24.560]  заключается в следующем, что
[01:15:26.560 --> 01:15:28.560]  мы оставляем вот это
[01:15:28.560 --> 01:15:30.560]  вот это в ядре,
[01:15:30.560 --> 01:15:32.560]  но при этом
[01:15:32.560 --> 01:15:34.560]  пишем маленький-маленький
[01:15:34.560 --> 01:15:36.560]  драйвер.
[01:15:36.560 --> 01:15:38.560]  Соответственно,
[01:15:38.560 --> 01:15:40.560]  в данном случае это драйвер
[01:15:40.560 --> 01:15:42.560]  Fuse, который
[01:15:44.560 --> 01:15:46.560]  собственно и
[01:15:46.560 --> 01:15:48.560]  обеспечивает там некоторый набор системных
[01:15:48.560 --> 01:15:50.560]  вызовов для другого
[01:15:50.560 --> 01:15:52.560]  процесса,
[01:15:52.560 --> 01:15:54.560]  соответственно, уже для непосредственного
[01:15:54.560 --> 01:15:56.560]  драйвера файловой системы.
[01:15:56.560 --> 01:15:58.560]  Фактически
[01:15:58.560 --> 01:16:00.560]  вот этому драйверу файловой системы
[01:16:00.560 --> 01:16:02.560]  предоставляется доступ
[01:16:02.560 --> 01:16:04.560]  к блочному драйверу, то есть он может
[01:16:04.560 --> 01:16:06.560]  читать, соответственно, писать
[01:16:06.560 --> 01:16:08.560]  на раздел, который, собственно,
[01:16:08.560 --> 01:16:10.560]  предоставляет доступ.
[01:16:10.560 --> 01:16:12.560]  И ему, соответственно, предлагается
[01:16:12.560 --> 01:16:14.560]  реализовать, собственно, вызовы
[01:16:14.560 --> 01:16:16.560]  чтения, поиска,
[01:16:16.560 --> 01:16:18.560]  записи, создание файлов
[01:16:18.560 --> 01:16:20.560]  для виртуальной файловой
[01:16:20.560 --> 01:16:22.560]  системы. В случае
[01:16:22.560 --> 01:16:24.560]  этого драйвер Fuse является некоторым подобием
[01:16:24.560 --> 01:16:26.560]  Proxy, который, соответственно,
[01:16:26.560 --> 01:16:28.560]  пробрасывает набор
[01:16:28.560 --> 01:16:30.560]  интерфейсов
[01:16:30.560 --> 01:16:32.560]  виртуальной файловой системы и блочного
[01:16:32.560 --> 01:16:34.560]  драйвера, как
[01:16:34.560 --> 01:16:36.560]  некоторый набор системных вызовов для
[01:16:36.560 --> 01:16:38.560]  драйвера файловой системы.
[01:16:38.560 --> 01:16:40.560]  В данном случае это хорошо,
[01:16:40.560 --> 01:16:42.560]  потому что
[01:16:42.560 --> 01:16:44.560]  программисту становится сильно
[01:16:44.560 --> 01:16:46.560]  легче писать
[01:16:46.560 --> 01:16:48.560]  драйвера файловых систем,
[01:16:48.560 --> 01:16:50.560]  так как
[01:16:50.560 --> 01:16:52.560]  они могут использовать там
[01:16:52.560 --> 01:16:54.560]  обычные языки программирования,
[01:16:54.560 --> 01:16:56.560]  полноценные системные библиотеки.
[01:16:56.560 --> 01:16:58.560]  Им не надо опасаться
[01:16:58.560 --> 01:17:00.560]  того, что они обрушат
[01:17:00.560 --> 01:17:02.560]  всю систему тем,
[01:17:02.560 --> 01:17:04.560]  что где-то ошибутся,
[01:17:04.560 --> 01:17:06.560]  соответственно,
[01:17:06.560 --> 01:17:08.560]  и приведут,
[01:17:08.560 --> 01:17:10.560]  например, к падению ядра.
[01:17:10.560 --> 01:17:12.560]  То есть
[01:17:12.560 --> 01:17:14.560]  механизм действительно
[01:17:14.560 --> 01:17:16.560]  довольно хороший для безопасности,
[01:17:16.560 --> 01:17:18.560]  потому что, еще и более того, драйвер
[01:17:18.560 --> 01:17:20.560]  Fuse гораздо меньше, чем любой драйвер
[01:17:20.560 --> 01:17:22.560]  файловой системы.
[01:17:22.560 --> 01:17:24.560]  Ну, не прям чтобы любой, но практически любой.
[01:17:24.560 --> 01:17:26.560]  Что?
[01:17:26.560 --> 01:17:28.560]  Ну, системные вызовы.
[01:17:38.560 --> 01:17:40.560]  Откройте LipFuse
[01:17:40.560 --> 01:17:42.560]  и увидите интерфейс.
[01:17:42.560 --> 01:17:44.560]  Вам проще всего будет.
[01:17:50.560 --> 01:17:52.560]  Ну, смотрите,
[01:17:52.560 --> 01:17:54.560]  вам
[01:17:54.560 --> 01:17:56.560]  нужны права,
[01:17:56.560 --> 01:17:58.560]  то есть вот этот вот процесс должен быть
[01:17:58.560 --> 01:18:00.560]  запущен под рутом,
[01:18:00.560 --> 01:18:02.560]  чтобы, соответственно,
[01:18:02.560 --> 01:18:04.560]  иметь доступ и как бы пользователей
[01:18:04.560 --> 01:18:06.560]  это аутентифицировать, соответственно,
[01:18:06.560 --> 01:18:08.560]  могут быть дополнительные политики, которые
[01:18:08.560 --> 01:18:10.560]  разрешают или запрещают,
[01:18:10.560 --> 01:18:12.560]  соответственно,
[01:18:12.560 --> 01:18:14.560]  отдельно взятому процессу
[01:18:14.560 --> 01:18:16.560]  реализовывать, соответственно,
[01:18:16.560 --> 01:18:18.560]  файловую систему в рамках какого-то
[01:18:18.560 --> 01:18:20.560]  устройства.
[01:18:20.560 --> 01:18:22.560]  Поэтому насчет
[01:18:22.560 --> 01:18:24.560]  вируса Пети, ну, честно говоря,
[01:18:24.560 --> 01:18:26.560]  если вы можете
[01:18:26.560 --> 01:18:28.560]  скомпрометировать вот этот процесс,
[01:18:28.560 --> 01:18:30.560]  ну, то есть завладеть им каким-то образом,
[01:18:30.560 --> 01:18:32.560]  то действительно вы сможете
[01:18:34.560 --> 01:18:36.560]  соответственно скомпрометировать ту
[01:18:36.560 --> 01:18:38.560]  файловую систему, которую этот процесс
[01:18:38.560 --> 01:18:40.560]  соответственно управляет.
[01:18:40.560 --> 01:18:42.560]  Хорошо или это
[01:18:42.560 --> 01:18:44.560]  или плохо? Вопрос, потому что
[01:18:44.560 --> 01:18:46.560]  вы сможете скомпрометировать файловую систему,
[01:18:46.560 --> 01:18:48.560]  вы сможете скомпрометировать ядро.
[01:18:50.560 --> 01:18:52.560]  Поэтому вот
[01:18:52.560 --> 01:18:54.560]  здесь как-то там
[01:18:54.560 --> 01:18:56.560]  палочка о двух концах, потому что даже если вы
[01:18:56.560 --> 01:18:58.560]  получите какие-то привилегии, у вас эти привилегии
[01:18:58.560 --> 01:19:00.560]  будут ниже, чем соответственно
[01:19:00.560 --> 01:19:02.560]  привилегии ядра.
[01:19:02.560 --> 01:19:04.560]  Ну, понятно, что здесь
[01:19:04.560 --> 01:19:06.560]  есть определенная боль там
[01:19:06.560 --> 01:19:08.560]  связанная с корневой
[01:19:08.560 --> 01:19:10.560]  файловой системой, ее из ядра
[01:19:10.560 --> 01:19:12.560]  гораздо тяжелее вытащить,
[01:19:12.560 --> 01:19:14.560]  потому что проблема курицы и яйца,
[01:19:14.560 --> 01:19:16.560]  вам нужно как-то запустить начальный
[01:19:16.560 --> 01:19:18.560]  процесс, а у вас
[01:19:18.560 --> 01:19:20.560]  файловая система оказывается в юзерспейсе,
[01:19:20.560 --> 01:19:22.560]  поэтому соответственно
[01:19:22.560 --> 01:19:24.560]  в случае, по крайней мере,
[01:19:24.560 --> 01:19:26.560]  с UNIX системами
[01:19:26.560 --> 01:19:28.560]  Fuse используется только для дополнительных
[01:19:28.560 --> 01:19:30.560]  файловых систем. В случае
[01:19:30.560 --> 01:19:32.560]  с
[01:19:32.560 --> 01:19:34.560]  микроядерными архитектурами,
[01:19:34.560 --> 01:19:36.560]  где
[01:19:36.560 --> 01:19:38.560]  где
[01:19:42.560 --> 01:19:44.560]  картинка выглядит примерно так,
[01:19:44.560 --> 01:19:46.560]  то есть
[01:19:46.560 --> 01:19:48.560]  в
[01:19:48.560 --> 01:19:50.560]  некоторый пользовательский процесс
[01:19:50.560 --> 01:19:52.560]  маппится, грубо говоря, регистры
[01:19:52.560 --> 01:19:54.560]  физического носителя,
[01:19:54.560 --> 01:19:56.560]  и он соответственно предоставляет некоторую интерфейс
[01:19:56.560 --> 01:19:58.560]  блокчиного драйвера,
[01:19:58.560 --> 01:20:00.560]  драйвер-файловая система и так далее.
[01:20:00.560 --> 01:20:02.560]  У вас есть
[01:20:02.560 --> 01:20:04.560]  некоторая маленькая файловая система,
[01:20:04.560 --> 01:20:06.560]  которая доступна из ядра,
[01:20:06.560 --> 01:20:08.560]  чаще всего там Redonly, а
[01:20:08.560 --> 01:20:10.560]  полноценная файловая система
[01:20:10.560 --> 01:20:12.560]  уже доступна
[01:20:12.560 --> 01:20:14.560]  в рамках какого-то запущенного процесса.
[01:20:16.560 --> 01:20:18.560]  Не обязательно
[01:20:18.560 --> 01:20:20.560]  разных. То есть
[01:20:20.560 --> 01:20:22.560]  если у вас, грубо говоря, есть конструкция,
[01:20:22.560 --> 01:20:24.560]  это вовсе не означает, что
[01:20:24.560 --> 01:20:26.560]  это все должны быть разные процессы.
[01:20:26.560 --> 01:20:28.560]  Да, могут быть
[01:20:28.560 --> 01:20:30.560]  разных процессов для облегчения
[01:20:30.560 --> 01:20:32.560]  изоляции. Могут не быть.
[01:20:32.560 --> 01:20:34.560]  В зависимости от того
[01:20:34.560 --> 01:20:36.560]  какой-то рэдов между соответственно
[01:20:36.560 --> 01:20:38.560]  предварительностью и соответственно безопасностью.
[01:20:38.560 --> 01:20:40.560]  А как они будут общаться друг с другом через файловую
[01:20:40.560 --> 01:20:42.560]  систему?
[01:20:42.560 --> 01:20:44.560]  Ну, через IPC, например.
[01:20:44.560 --> 01:20:46.560]  IPC мы вот только что разобрали.
[01:20:50.560 --> 01:20:52.560]  Ну, было бы смешно.
[01:20:56.560 --> 01:20:58.560]  Итак, ну, в целом
[01:20:58.560 --> 01:21:00.560]  здесь как бы действительно все
[01:21:00.560 --> 01:21:02.560]  достаточно просто.
[01:21:02.560 --> 01:21:04.560]  Поэтому в Джосе
[01:21:04.560 --> 01:21:06.560]  вот у вас
[01:21:06.560 --> 01:21:08.560]  в десятой лабораторной работе будет
[01:21:08.560 --> 01:21:10.560]  именно такая картинка.
[01:21:10.560 --> 01:21:12.560]  И вам, соответственно, нужно будет реализовать простейшую
[01:21:12.560 --> 01:21:14.560]  файловую систему, где вы как раз познакомитесь
[01:21:14.560 --> 01:21:16.560]  с интерфейсом файловой системы.
[01:21:20.560 --> 01:21:22.560]  Микро. Да.
[01:21:22.560 --> 01:21:24.560]  Получается, что процесс файловой системы
[01:21:24.560 --> 01:21:26.560]  просто сразу
[01:21:26.560 --> 01:21:28.560]  виснет в прожигании
[01:21:28.560 --> 01:21:30.560]  сообщения
[01:21:34.560 --> 01:21:36.560]  Ну, на самом деле не совсем так.
[01:21:36.560 --> 01:21:38.560]  Потому что, ну, смотрите,
[01:21:38.560 --> 01:21:40.560]  вот если обрабатывать цикли
[01:21:40.560 --> 01:21:42.560]  он будет однопоточным.
[01:21:42.560 --> 01:21:44.560]  А там клиентов может быть несколько.
[01:21:44.560 --> 01:21:46.560]  Другое одно дело там, грубо говоря.
[01:21:46.560 --> 01:21:48.560]  Если
[01:21:48.560 --> 01:21:50.560]  у вас обращение к носителю
[01:21:50.560 --> 01:21:52.560]  надо реализовывать.
[01:21:52.560 --> 01:21:54.560]  То есть как раз вот эта вот
[01:21:54.560 --> 01:21:56.560]  часть. То есть любой
[01:21:56.560 --> 01:21:58.560]  в другом
[01:21:58.560 --> 01:22:00.560]  драйвер файловой системы
[01:22:00.560 --> 01:22:02.560]  или на уровне VFS
[01:22:02.560 --> 01:22:04.560]  или на уровне драйвера файловой системы
[01:22:04.560 --> 01:22:06.560]  должен обеспечивать сериализацию.
[01:22:06.560 --> 01:22:08.560]  Ну то есть некоторую по сути очередь
[01:22:08.560 --> 01:22:10.560]  чтений, записей.
[01:22:10.560 --> 01:22:12.560]  Причем
[01:22:12.560 --> 01:22:14.560]  сериализацию и на уровне операций
[01:22:14.560 --> 01:22:16.560]  и на уровне
[01:22:16.560 --> 01:22:18.560]  микроопераций.
[01:22:18.560 --> 01:22:20.560]  Грубо говоря, у вас микрооперация это там запись чтения сектора
[01:22:20.560 --> 01:22:22.560]  которое там артное.
[01:22:22.560 --> 01:22:24.560]  А соответственно операция это то в рамках
[01:22:24.560 --> 01:22:32.560]  то есть, некоторая последовательность микроопераций, в рамках которых, грубо говоря, у вас происходит изменение файловой системы, например, создание файла,
[01:22:32.560 --> 01:22:43.560]  соответственно, изменение. Например, ну вот, грубо говоря, когда вы там создаете файл, то вы там можете сначала записать файл,
[01:22:43.560 --> 01:22:53.560]  а после этого добавить его в, соответственно, дерево для того, чтобы у вас файловая система на всех стадиях микрооперации оставалась консистентной.
[01:22:53.560 --> 01:22:58.560]  Ну то есть, если у вас резко отключат питание, чтобы, соответственно, файловая система осталась консистентной.
[01:22:58.560 --> 01:23:08.560]  И, соответственно, возвращаясь к этому вопросу, то даже с учетом того, что вам нужно обеспечивать сериализацию,
[01:23:08.560 --> 01:23:16.560]  у вас все равно есть некоторые накладные расходы на обеспечение процесса доступа к файлам, у вас есть кэш, например.
[01:23:16.560 --> 01:23:23.560]  Во многих случаях вам не нужно обращаться к диску для того, чтобы ответить, например, какие файлы лежат в директории,
[01:23:23.560 --> 01:23:31.560]  для того, чтобы прочитать какой-то файл, у вас может быть кэш файлов. Например, в джосе у вас будет простейший кэш,
[01:23:31.560 --> 01:23:41.560]  где прочитанные файлы будут кэшироваться в оперативной памяти, соответственно, к ним не придется обращаться повторно.
[01:23:41.560 --> 01:23:43.560]  Вот.
[01:23:55.560 --> 01:24:04.560]  Ну, из двух функций это в максимально простом виде. То есть, как бы в джосе, ну как бы простой пример, да,
[01:24:04.560 --> 01:24:10.560]  когда там действительно однопоточный файловый сервер, там ничего сверхумного действительно нет.
[01:24:10.560 --> 01:24:17.560]  Но в нормальных, соответственно, операционных системах у вас там есть набор воркеров, которые там могут разным образом
[01:24:17.560 --> 01:24:23.560]  алоцироваться. Если, например, Hard real-time, то они могут резервироваться еще на статике. То есть, например,
[01:24:23.560 --> 01:24:29.560]  на статике определяется, сколько процессов могут иметь доступ к файловой системе, соответственно,
[01:24:29.560 --> 01:24:36.560]  под них выделяются ресурсы, соответственно, выделяется процессорное время, выделяется, соответственно, память
[01:24:36.560 --> 01:24:40.560]  и обеспечивается там возможность обращения.
[01:24:44.560 --> 01:24:49.560]  Я вам говорю, что у вас может быть кэширование, у вас могут быть накладные расходы. И, соответственно,
[01:24:49.560 --> 01:24:56.560]  если обращение к жесткому диску действительно надо стереализовать, хотя и там, на самом деле, есть очереди,
[01:24:56.560 --> 01:25:01.560]  и там современные контроллеры, они позволяют там читать, например, из разных мест параллельно.
[01:25:04.560 --> 01:25:08.560]  В NVMe спецификацию почитайте, вам будет интересно.
[01:25:09.560 --> 01:25:15.560]  Соответственно, но даже если бы этого не было, то, например, в кэше, то есть многие операции к файлам системы
[01:25:15.560 --> 01:25:21.560]  вам не обязательно лезть к диску, у вас может быть просто обращение по кэшу.
[01:25:21.560 --> 01:25:26.560]  И в этом случае, как бы, там, воркеры они неплохо ускоряют средний доступ.
[01:25:27.560 --> 01:25:32.560]  Худший не ускоряют. Ну, точнее как, ускоряют, но в отдельных ситуациях, опять же.
[01:25:34.560 --> 01:25:40.560]  Не, ну, зависит от. То есть тут как бы нельзя дать такой однозначно хороший ответ.
[01:25:41.560 --> 01:25:48.560]  Вот. Плюс, соответственно, там, любая файловая система там должна ограничивать, соответственно, там,
[01:25:48.560 --> 01:25:55.560]  количество, там, одновременно открытых файлов, потому что, ну, это ресурсы, там, либо на уровне VFS-а,
[01:25:55.560 --> 01:26:02.560]  либо на уровне и VFS-а, и там, драйвера, там, количество одновременных операций, которые могут выполнять
[01:26:03.560 --> 01:26:09.560]  процессы к файловым системам. Размер транзакций. То есть мы, например, там, привыкли, что
[01:26:10.560 --> 01:26:15.560]  в рамках, там, позикса, можем, например, записать произвольное количество байт, там, файлов.
[01:26:15.560 --> 01:26:22.560]  Ну, при условии, что диска хватит. Соответственно, если там какой-нибудь hard real time, то у вас на уровне, там, API
[01:26:23.560 --> 01:26:28.560]  будет сказано, что, например, там нельзя одновременно, там, в рамках одной операции, писать вот больше, там,
[01:26:28.560 --> 01:26:34.560]  столько-то байт. Потому что, там, гарантируется, там, временно и худшего ответа файловой системы.
[01:26:35.560 --> 01:26:39.560]  Что, например, файловая система ответит, там, ну, вот за столько, например, микросекунд или, там, миллисекунд.
[01:26:39.560 --> 01:26:49.560]  И как это можно достичь? Ну, вот, соответственно, посредством добавления, там, тех или иных ограничений.
[01:26:50.560 --> 01:26:58.560]  Ну, на этом, в принципе, у меня все. Всем спасибо.
