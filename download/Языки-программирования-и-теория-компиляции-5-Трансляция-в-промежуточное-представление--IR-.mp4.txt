[00:00.000 --> 00:05.920]  Всем доброго дня, мы с вами наконец-таки собрались
[00:05.920 --> 00:06.920]  после перерыва.
[00:06.920 --> 00:09.800]  Да, видимо, перерыв нам очень сильно подкосил.
[00:09.800 --> 00:14.240]  От нас всего тут очень немного людей, но я надеюсь,
[00:14.240 --> 00:16.240]  это к семинару хотя бы подправится.
[00:16.240 --> 00:20.480]  В прошлый раз мы с вами начали рассматривать такое
[00:20.480 --> 00:26.200]  понятие как таблица символов, и мы с вами научились строить
[00:26.200 --> 00:30.480]  вот такие вот интересные объекты как таблица скопов
[00:30.480 --> 00:31.480]  наших перемен.
[00:31.480 --> 00:34.680]  То есть мы с вами сказали, что неплохо было бы для
[00:34.680 --> 00:39.800]  каждого объекта в нашей симматической таблице научиться
[00:39.800 --> 00:41.440]  определять его тип.
[00:41.440 --> 00:44.720]  То есть у нас с вами не то что тип, а его симматическую
[00:44.720 --> 00:45.720]  структуру.
[00:45.720 --> 00:47.800]  То есть когда мы с вами встречаем допустим идентификатор
[00:47.800 --> 00:52.760]  под названием scopeExample, хотелось бы сказать, что этот scopeExample
[00:52.760 --> 00:54.680]  это будет именно название нашего класса.
[00:55.080 --> 00:58.640]  То есть у нас есть несколько скопов и дополнительно
[00:58.640 --> 01:00.520]  у нас должна быть таблица символов.
[01:00.520 --> 01:04.720]  Я посмотрел некоторые реализации, и в этих реализациях оказалось
[01:04.720 --> 01:11.160]  следующее, что в некоторых из них как раз скоп функции
[01:11.160 --> 01:13.960]  и таблица символов находится в одной концепции.
[01:13.960 --> 01:17.560]  Но опять же мы можем сделать не только так, а мы можем
[01:17.560 --> 01:18.560]  еще сделать иначе.
[01:18.560 --> 01:22.400]  Иначе в том плане, что грубо говоря, хранить таблицу
[01:22.400 --> 01:26.680]  символов отдельно, а хранить дерево скопов отдельно.
[01:26.680 --> 01:29.480]  Значит сразу скажу, что у глобального скопа, если
[01:29.480 --> 01:31.960]  мы рассматриваем чисто объектно-ориентированный
[01:31.960 --> 01:37.440]  язык, коем является у нас джава, у нас в глобальном
[01:37.440 --> 01:39.240]  скопе могут быть только названия классов.
[01:39.240 --> 01:43.840]  Если мы говорим про другие языки, то у нас там могут
[01:43.840 --> 01:46.040]  быть переменные, у нас там могут быть функции, у нас
[01:46.040 --> 01:47.040]  могут быть классы.
[01:47.040 --> 01:51.000]  Значит внутри класса, у нас внутри скопа что находится.
[01:51.000 --> 02:00.760]  У нас там могут быть либо поля, либо метода, а внутри
[02:00.760 --> 02:04.560]  скопа определенного метода у нас уже, если мы не рассматриваем
[02:04.560 --> 02:08.100]  лябдо функции, пока что давайте их выкинем, потому
[02:08.100 --> 02:11.640]  что это интересный момент, у нас с вами будут как раз
[02:11.640 --> 02:14.200]  переменные, которые мы с вами определяем, возможно
[02:14.200 --> 02:16.880]  вызовы каких-то других функций, но в общем мы определяем
[02:16.880 --> 02:18.480]  зачастую именно переменные.
[02:18.480 --> 02:23.080]  И внутри текущего скопа может быть еще один скоп,
[02:23.080 --> 02:25.880]  в котором мы с вами определяем объекты.
[02:25.880 --> 02:29.720]  И как раз вот эти скопы иногда называют блоками.
[02:29.720 --> 02:33.120]  И вот смотрите, у нас с вами есть вот такой вот пример,
[02:33.120 --> 02:36.400]  и что мы можем с этим примером сделать?
[02:36.400 --> 02:39.120]  То есть наша цель как раз объявить те переменные,
[02:39.120 --> 02:42.160]  которые у нас умеются, плюс дополнительно сверху как
[02:42.160 --> 02:46.280]  ни странно нам нужно будет определить, а каким образом
[02:46.280 --> 02:47.920]  к этим переменным обращаться.
[02:47.920 --> 02:53.680]  И для этого нам полезно понимать следующую вещь.
[02:53.680 --> 02:56.880]  Нам полезно понимать, как эти переменные будут
[02:56.880 --> 02:57.880]  объявляться.
[02:57.880 --> 03:00.880]  Для этого давайте попробуем переписать ту функцию,
[03:00.880 --> 03:06.240]  которую у нас есть в C-стайле.
[03:06.240 --> 03:08.560]  Почему это важно переписать функцию в C-стайле?
[03:08.560 --> 03:11.760]  Потому что мы тогда сразу для переменных будем понимать,
[03:11.760 --> 03:14.960]  какой сдвиг от начала стека у них есть относительно
[03:14.960 --> 03:15.960]  праймпоинтера.
[03:15.960 --> 03:20.680]  Итак, как этот код будет переписываться?
[03:20.680 --> 03:25.880]  C-89 года.
[03:25.880 --> 03:33.840]  Итак, как он будет выглядеть?
[03:33.840 --> 03:34.840]  Да.
[03:34.840 --> 03:41.840]  Не-не-не, я говорю чисто про переменные, конечно
[03:41.840 --> 03:42.840]  же.
[03:42.840 --> 03:44.680]  Значит смотрите, у нас наши функции сначала будут
[03:44.680 --> 03:51.920]  объявлены int a, дальше int x, после этого у нас будет
[03:51.920 --> 04:07.240]  if b больше нуля, а равно пяти, return b плюс a, или else, я те
[04:07.240 --> 04:08.240]  в докод пишу.
[04:08.240 --> 04:21.240]  Ну, вот, значит, что это нам позволяет сделать?
[04:21.240 --> 04:24.160]  Нам это позволяет сразу объявить следующую вещь.
[04:24.160 --> 04:30.760]  Да, у нас есть int b, и здесь мы говорим сразу, что вот
[04:30.760 --> 04:33.280]  эта переменная у нас по факту нулевая переменная
[04:33.280 --> 04:35.800]  в нашей функции, то есть она нам передается на стек,
[04:35.800 --> 04:38.560]  и если мы возьмем с вами праймпоинтер, то первый
[04:38.560 --> 04:43.120]  элемент во праймпоинтер это будет переменная b, дальше
[04:43.120 --> 04:45.640]  следующая переменная, которая у нас будет, это будет переменная
[04:45.640 --> 04:49.960]  a, и после этого нам нужно будет объявить переменную
[04:49.960 --> 04:50.960]  x.
[04:50.960 --> 04:55.000]  То есть когда мы с вами будем идти в коде, нам надо
[04:55.000 --> 04:58.400]  будет явно отслеживать, когда эта переменная была
[04:58.400 --> 04:59.400]  объявлена.
[04:59.400 --> 05:02.200]  Мы в прошлый раз с вами как раз посмотрели сущность
[05:02.200 --> 05:05.960]  связанных со структурой объектов, и тут нужно сказать
[05:05.960 --> 05:07.920]  следующее, что если мы с вами будем реализовывать
[05:07.920 --> 05:11.560]  классическую таблицу символов, и будем смотреть именно на
[05:11.560 --> 05:14.400]  скопы переменных, то у нас может возникнуть неприятная
[05:14.400 --> 05:15.400]  ситуация.
[05:15.400 --> 05:19.880]  Я сейчас попытаюсь найти пример как раз, почему нельзя
[05:19.880 --> 05:23.400]  сразу объявлять таблицу скопов и по ней идти.
[05:23.400 --> 05:27.480]  Значит, как раз нам Николай очень сильно в этом помог.
[05:27.480 --> 05:31.640]  Давайте посмотрим на вот такой код.
[05:31.640 --> 06:01.160]  Значит, while i равно равно нулю, так int i, так, вот такой код
[06:02.160 --> 06:04.800]  Значит, давайте фигурные скопки.
[06:04.800 --> 06:15.960]  Что у нас этот код выводит?
[06:15.960 --> 06:19.880]  int i равно нулю, while i равно равно нулю, print i, int i равно единице
[06:19.880 --> 06:41.600]  print i.
[06:41.600 --> 06:42.600]  Да, он выведет бесконечный цикл.
[06:42.600 --> 06:45.080]  Но смотрите, если мы с вами попытаемся сразу построить
[06:45.080 --> 06:48.760]  таблицу символов и таблицу скопов, то у нас произойдет
[06:48.760 --> 06:49.760]  следующий эффект.
[06:49.760 --> 06:52.560]  У нас появится переменная i, а дальше в скопе номер
[06:52.560 --> 06:58.120]  ноль у нас появится переменная i, тоже еще одна переменная
[06:58.120 --> 06:59.120]  i.
[06:59.120 --> 07:00.120]  То есть у нас появляется глобальный модификатор.
[07:00.120 --> 07:02.880]  И в чем возникают проблемы?
[07:02.880 --> 07:05.960]  Значит, когда вы будете объявлять вот таблицу скопов, вы
[07:05.960 --> 07:10.000]  говорите окей, у нас уже с вами есть переменная, которая
[07:10.000 --> 07:13.320]  называется i, то есть мы сразу построили с вами таблицу
[07:13.320 --> 07:17.160]  символов на определенном проходе сканера визитера.
[07:17.160 --> 07:22.040]  Значит, у нас с вами есть переменная i, и дальше говорим
[07:22.040 --> 07:26.000]  окей, у нас эта переменная i есть, когда мы заходим
[07:26.000 --> 07:31.360]  вот сюда, смотрим на ее содержимое.
[07:31.360 --> 07:33.640]  Собственно главное, чтобы мы не зашли во внутренние
[07:33.640 --> 07:35.360]  скопы в этот момент времени.
[07:35.360 --> 07:39.840]  Если мы обращаемся к этой переменной, то все хорошо.
[07:39.840 --> 07:42.160]  Если мы не обращаемся к этой переменной, а пытаемся
[07:42.160 --> 07:45.600]  обратиться именно к этой переменной, то возникают
[07:45.600 --> 07:46.600]  проблемы.
[07:46.600 --> 07:50.960]  Потому что у нас эта переменная уже i становится равной единице,
[07:50.960 --> 07:52.960]  по идее мы ее уже с вами стираем.
[07:52.960 --> 08:01.920]  О, смотрите, вот такой пример, i равно 0, а вот здесь мы вставляем
[08:01.920 --> 08:02.920]  i равно 5.
[08:02.920 --> 08:11.760]  Да, ну а на интерац, даже если мы здесь поставим i
[08:11.840 --> 08:15.160]  равная 0, то какая проблема у нас возникнет?
[08:15.160 --> 08:21.280]  Мы уже зашли с вами внутренний скоп, мы пытаемся посмотреть
[08:21.280 --> 08:26.840]  на значение переменной i, она по идее должна быть
[08:26.840 --> 08:30.440]  объявлена в этом скопе, а значение у нее будет равно
[08:30.440 --> 08:31.440]  единице.
[08:31.440 --> 08:35.320]  То есть мы будем обновлять значение переменной, которое
[08:35.320 --> 08:41.040]  находится не здесь, как это логически должно происходить,
[08:41.040 --> 08:42.040]  а здесь.
[08:42.040 --> 08:47.040]  Вот мы будем обновлять значение переменной, которую мы еще
[08:47.040 --> 08:48.040]  не объявили.
[08:48.040 --> 08:52.800]  И поэтому с этим нужно будет аккуратно обходить.
[08:52.800 --> 08:56.120]  То есть когда мы в прошлый раз посмотрели пример, когда
[08:56.120 --> 08:59.240]  мы на стеке объявляем переменные и их кладем, все нормально.
[08:59.240 --> 09:02.240]  Если мы с вами будем визуально хранить таблицу скопов,
[09:02.240 --> 09:05.640]  то все это в виде деревя, то придется еще хранить
[09:05.640 --> 09:08.480]  идентификатор того, когда эта переменная была добавлена.
[09:08.480 --> 09:13.760]  Нам нужно будет заводить timestamp, которое по входному
[09:13.760 --> 09:17.920]  значению, грубо говоря, по индексу будет определять,
[09:17.920 --> 09:19.760]  существует эта переменная еще или нет.
[09:19.760 --> 09:24.120]  Потому что у нас возникнет вот такой вот сайд-эффект,
[09:24.120 --> 09:25.920]  который не хотелось бы рассматривать.
[09:25.920 --> 09:34.280]  Как угодно, можно хоть уникстайны сделать.
[09:34.280 --> 09:45.240]  Ну конечно же, какой-то индекс, в котором мы заводим
[09:45.240 --> 09:46.240]  наши элементы.
[09:46.240 --> 09:54.640]  Это что касается построения таблицы символов.
[09:54.640 --> 09:57.840]  Когда мы с вами уже имеем таблицы символов, нам нужно
[09:57.840 --> 10:00.080]  будет сделать еще несколько визитеров.
[10:00.080 --> 10:04.400]  Дальше у нас можно еще прогнать одну стадию
[10:04.400 --> 10:08.000]  валидации визитеров, которая будет проверять, вообще
[10:08.000 --> 10:10.480]  мы можем вызывать наши объекты или не можем вызывать
[10:10.480 --> 10:11.480]  наши объекты.
[10:11.480 --> 10:16.400]  Вот в чем проблема, давайте обсудим еще одного кода.
[10:16.400 --> 10:18.160]  У нас тряпок немного осталось.
[10:18.160 --> 10:38.640]  Это, к слову, о том, как нужно будет обходить визитером
[10:38.640 --> 10:39.640]  эти все штуки.
[10:39.640 --> 11:07.800]  А код такой, образно говоря, вот такое поведение.
[11:07.800 --> 11:11.160]  То есть у нас получается класс foo, дальше у нас создается
[11:11.160 --> 11:18.280]  объект типа bar, а потом внутри мы вызываем внутри
[11:18.280 --> 11:21.120]  объекта bar объект типа foo.
[11:21.120 --> 11:26.480]  Смотрите, если мы пойдем сразу объявлять таблицу
[11:26.480 --> 11:29.120]  символов, то в чем проблема получается?
[11:29.120 --> 11:33.200]  Мы заходим вот сюда, мы видим с вами, что у нас выполняется
[11:33.200 --> 11:37.040]  конструктор класса bar, а класса bar еще нет, потому
[11:37.280 --> 11:38.800]  что мы не дошли до этого места в программер.
[11:38.800 --> 11:43.200]  Что мы с вами получаем?
[11:43.200 --> 11:55.920]  Не, это не обязательно в конструкторе, я говорю.
[11:55.920 --> 12:00.720]  Да, то есть смотрите, нам нужно будет, вот тут очень
[12:00.720 --> 12:03.240]  важно сделать следующее, что когда мы будем вызывать
[12:03.240 --> 12:06.280]  визитер для обхода всего этого, нам нужно будет либо
[12:06.280 --> 12:09.120]  сделать два визитера, которые сначала просто построят
[12:09.120 --> 12:11.840]  объекты, которые у нас нет, а дальше провалидируют
[12:11.840 --> 12:12.840]  их вызовы.
[12:12.840 --> 12:16.160]  То есть что здесь можно вызывать bar и методы bar, здесь
[12:16.160 --> 12:19.040]  можно вызывать foo и методы foo.
[12:19.040 --> 12:21.640]  Либо первый обход, который мы делаем с вами, когда мы
[12:21.640 --> 12:26.560]  делаем визитера, мы находимся с вами в глобальном сколпе,
[12:26.560 --> 12:30.040]  нам нужно будет проверить, сразу записать таблицу
[12:30.040 --> 12:32.920]  классов, что у нас будут конкретные классы для того,
[12:32.920 --> 12:34.720]  чтобы у нас хотя бы код в первом приближении
[12:34.720 --> 12:35.720]  работы.
[12:35.720 --> 12:36.720]  Вот.
[12:36.720 --> 12:42.080]  Вот это понятно, что иногда визитерах нужно корректно
[12:42.080 --> 12:44.920]  задавать порядок, что нельзя просто внутренне обходить
[12:44.920 --> 12:48.200]  это все дело рекурсивным выпуском, иногда нужно заходить
[12:48.200 --> 12:49.200]  именно внутрь.
[12:49.200 --> 12:53.440]  Хорошо, а теперь давайте обсудим, какие нам визитеры
[12:53.440 --> 12:56.800]  нужны, прежде чем мы с вами перейдем в промежуточные
[12:56.800 --> 12:57.800]  представления.
[12:57.800 --> 13:02.000]  Нам нужно, во-первых, научиться строить таблицу символов,
[13:02.000 --> 13:04.120]  во-вторых, нам нужно будет валидировать эту таблицу
[13:04.120 --> 13:07.160]  символов, в-третьих, нам нужно будет проверить
[13:07.160 --> 13:14.840]  типы, вывести систему типов, потому что будет интересно,
[13:14.840 --> 13:23.280]  если вы напишите код вот такой, int b равно var, вызываете
[13:23.280 --> 13:30.920]  конструктор класса и присваиваете его к int.
[13:31.920 --> 13:37.240]  Ну, можно, да, если мы хотим это сделать, нам нужно сделать
[13:37.240 --> 13:40.680]  конвертацию типов, то есть по факту нам нужно будет
[13:40.680 --> 13:46.120]  посмотреть, оператор равно для int, то есть там придется
[13:46.120 --> 13:49.520]  делать некоторое преобразование, мы это будем опускать, пока
[13:49.520 --> 13:53.720]  что это сложная для нас вещь, но и дополнительно,
[13:53.720 --> 13:57.960]  конечно же, если мы говорим про такой код, то не нужно
[13:57.960 --> 14:02.320]  забывайте про наследование, то есть для наследования
[14:02.320 --> 14:06.120]  нам нужно будет еще одна, по факту, тот же самый аналог
[14:06.120 --> 14:09.000]  таблице символов, только уже для наследования, то
[14:09.000 --> 14:11.160]  есть нам нужно будет простраивать иерархию наследования
[14:11.160 --> 14:12.160]  типов.
[14:12.160 --> 14:17.280]  Это что касается визитеров, и последний визитер, который
[14:17.280 --> 14:20.920]  нам понадобится, это визитер, который будет входить внутри
[14:20.920 --> 14:24.600]  каждой функции и определять сдвиг относительно начала,
[14:24.600 --> 14:29.600]  нужно будет для каждой переменной понять, какой сдвиг ее относительно фреймпоинтера,
[14:29.600 --> 14:38.600]  чтобы мы к ней могли обращаться уже в машинном коде. Вот, и когда мы это все сделаем, мы с вами
[14:38.600 --> 14:46.060]  можем уже как раз переходить к, так сказать, ER представлению. Я нажимаю на escape, оно не
[14:46.060 --> 14:52.700]  escape-ится. Вот, поэтому мы с вами начинаем новую тему, как раз, которую мы, я думаю,
[14:52.700 --> 14:55.900]  сегодня на семинарах будем смотреть, это трансляция в промежуточных представлениях.
[14:55.900 --> 15:02.580]  Сразу скажу, что на семинарах мы с вами будем смотреть представление именно в LVM ER,
[15:02.580 --> 15:08.700]  он более высокоуровневый, чем текущий ER, который мы будем рассматривать на лекции. Вот, я как раз
[15:08.700 --> 15:12.060]  говорю, что у нас будет более низкоуровневое представление, просто по той причине, что
[15:12.060 --> 15:18.540]  нам нужно будет считать обсеты относительно фреймпоинтеров. Давайте определим некоторые
[15:18.540 --> 15:22.300]  особенности. Где мы сейчас находимся, мы наконец-таки заползли до вот этой части,
[15:22.300 --> 15:29.460]  когда мы выходим из фронтэнда и начинаем работать как раз с вами в промежуточные
[15:29.460 --> 15:35.820]  представлениях, говорить с вами про промежуточные представления. Так, что у нас с вами есть к этому
[15:35.820 --> 15:41.780]  моменту? Значит, у нас с вами есть таблицы символов, у нас с вами есть проверка типов,
[15:41.780 --> 15:48.620]  и у нас с вами есть примитивные фреймы. Что это означает? Это означает, что у нас для любой
[15:48.620 --> 15:53.780]  функции, которую мы вызываем, мы знаем какие аргументы, каким образом эти аргументы кладутся на
[15:53.780 --> 15:59.380]  стэк, то есть какие у них сдвиги относительно стартовых элементов, и наша цель будет как раз
[15:59.380 --> 16:04.900]  преобразовать каждый фрейм в правильный код, который мы с вами можем проинтерпретировать.
[16:04.900 --> 16:14.660]  И как раз нам помогут сейчас некоторые вещи создать как раз для составления промежуточного
[16:14.660 --> 16:18.500]  представления. То есть цель будет построить дерево промежуточного представления, а во-вторых,
[16:18.500 --> 16:23.780]  это понять как работает механизм создания фреймов. Да, то есть сейчас нам прямо фреймы не
[16:23.780 --> 16:28.300]  нужны, потому что у нас высокоуровневая вещь. Когда мы будем уже спускаться в более
[16:28.300 --> 16:34.860]  низкоуровневую вещь, мы про это поговорим. Итак, значит, давайте еще раз вспомним картинку,
[16:34.860 --> 16:39.020]  зачем нам нужно промежуточное представление. У нас с вами есть front-end, мы можем написать
[16:39.020 --> 16:44.940]  произвольный front-end на разных языках программирования, и нам нужно проводить стадии оптимизации. И как
[16:44.940 --> 16:49.500]  раз стадии оптимизации проводится поверх промежуточного представления нашего кода,
[16:49.500 --> 16:55.460]  а после этого мы с вами идем и все компилируем в определенный тип бэк-энда. То есть это у нас
[16:55.460 --> 17:00.380]  может быть либо бэк-энд по какую-то архитектуру, либо у нас может быть какой-нибудь там,
[17:00.380 --> 17:09.940]  образно говоря, какой-то экзотический бэк-энд для real-time operating system, например. Значит,
[17:09.940 --> 17:15.140]  напомню еще раз, как выглядит код VR. Это вот все напоминания в первой лекции. Значит, в чем его
[17:15.140 --> 17:34.340]  отличие? Давайте поймем. Справа, конечно. У нас здесь появляются индексы T1, T2, T3, T4.
[17:34.340 --> 17:57.260]  У нас с вами по факту есть здесь виртуальный регистр. Мы можем прочитать значение из
[17:57.260 --> 18:01.100]  виртуального регистра, записать значение в определенный виртуальный регистр. То есть справа
[18:01.100 --> 18:06.980]  в этоиты это виртуальный регистр. И здесь как раз у нас статик single assignment form. То есть у нас
[18:06.980 --> 18:15.860]  каждый раз, когда мы что-то делаем, мы строим новый виртуальный регистр. Кроме команды store,
[18:15.860 --> 18:26.540]  которая записывает именно значение по регистру по определенному указателю. И здесь мы как раз видим,
[18:26.540 --> 18:33.020]  что если мы вызываем какой-то функционал, то зачастую мы вызываем его поверх указателя на
[18:33.020 --> 18:42.220]  наш объект. Поэтому нам нужно с вами как раз научиться приводить, возможно, не к такому типу,
[18:42.220 --> 18:52.260]  но хотя бы к похожему типу. И как раз видите, здесь у нас есть i32. Здесь мы не запариваемся по
[18:52.260 --> 18:58.180]  поводу того, какие у нас ассеблерные инструкции зафигинируются. А нам бы хотелось сделать что-то
[18:58.180 --> 19:03.340]  более низкоуровневое. То есть у нас t1 должен быть аллотирован, это указатель относительно
[19:03.340 --> 19:08.700]  фреймпоинтера. То есть получается t1 это фреймпоинтер, t2 это фреймпоинтер плюс 4,
[19:08.700 --> 19:16.460]  плюс 4 байта, t3 это фреймпоинтер плюс 8, t4 это фреймпоинтер плюс 12. То есть у нас переменные
[19:16.460 --> 19:22.700]  будут располагаться с вами на стеке. Так, ну хорошо, давайте тогда посмотрим, собственно,
[19:22.700 --> 19:30.060]  какие есть необходимые свойства у LVM Skyar. Как раз первое свойство LVM Skyar заключается в том,
[19:30.060 --> 19:34.780]  что мы будем с вами использовать статик Single Assignment. Один виртуальный регистр может быть
[19:34.780 --> 19:40.580]  присвоен единожды. Мы можем изменить значение нашего виртуального регистра только при помощи
[19:40.580 --> 19:47.260]  операции Store. Дальше, значит, у нас есть фии инструкции. Это важное свойство, по которому поговорим
[19:47.260 --> 19:54.260]  чуть позже. Третье, у нас есть толчистые типы, причем они могут быть произвольными. То есть дальше
[19:54.260 --> 19:59.260]  нам на уровне бэкэнда нужно будет решать, каким образом эти натуральные числа преобразовывают. То
[19:59.260 --> 20:06.580]  есть в принципе, когда вы пишете LVM Skyar, вам может быть сказано, ну сделайте переменную i17.
[20:06.580 --> 20:11.580]  Да, ну, наверное, мы с вами понимаем, что это скорее всего будут там два int и бул какой-нибудь.
[20:11.580 --> 20:28.820]  Какой два int? Один short получает один байт, один бул. Да, в VR такое можно написать LVM Skyar,
[20:28.820 --> 20:33.060]  но, правда, таким вот никто не пользуется. Но для була используют i1.
[20:33.060 --> 20:40.380]  Да, его надо кастовать потом к i8 для разных операций.
[20:40.380 --> 20:52.980]  Вот, дальше у нас используются только указатели. То есть у нас с вами аллок i64 или i64 звездочка,
[20:52.980 --> 20:59.300]  и есть поддержка структур данных, и есть поддержка векторов. Она является рекурсивной.
[20:59.300 --> 21:08.060]  Так, давайте рассмотрим пример фи инструкции. Значит, здесь есть определенный код. Вот,
[21:08.060 --> 21:14.340]  смотрите, интересный код заключается в чем. У нас с вами есть функция m, которая принимает
[21:14.340 --> 21:21.380]  на вход два мула, и второй Bool l. Он заключается в том, что это y, и смотрите внимание на оперант.
[21:21.380 --> 21:27.860]  Здесь оперант две палки. Если был бы оперант одна палка, код был бы намного проще.
[21:27.860 --> 21:34.540]  В чем особенность оператора две палки, двойной лопайп?
[21:34.540 --> 21:44.980]  Да, это означает, что у нас переменная r будет вычитываться только тогда, когда переменная y равна нулю.
[21:57.860 --> 22:21.140]  Если есть параллельное ядро, то можно. Это так делают, кстати. Более того, так на видеокарте
[22:21.140 --> 22:26.660]  работает. Ну, потому что ему вперед просчитать что-то, для того чтобы потом подставить значение и
[22:26.660 --> 22:47.700]  подставить все по маске. Ну, всегда зависит от всяких таких вещей. Вот, и как раз здесь есть у нас
[22:47.700 --> 22:55.380]  пример этого кода в иаре. Значит, дальше, например, здесь мангл-инструкция, то есть define void,
[22:55.380 --> 23:03.940]  и дальше z1 mbb. Что это означает? Это означает, что у нас дальше идет функция. В ней один элемент,
[23:03.940 --> 23:10.980]  эта функция имеет название длины 1, название у нее m. Дальше у нас два аргумента, значит,
[23:10.980 --> 23:21.540]  bb. Это по факту определение двух булов. Дальше у нас и1, мы видим с вами y. Дальше, значит,
[23:21.540 --> 23:27.700]  мы что делаем? Мы с вами по факту сохраняем эти переменные во внутрь нашей функции, вот эти
[23:27.700 --> 23:43.460]  вот две строки. Давайте увеличу этот код. Значит, дальше мы алоцируем переменную l, aloka. Дальше
[23:43.460 --> 23:54.180]  мы конвертируем нашу i1 в i8 и храним это все в переменную. Store i from bool x. Дальше мы создаем
[23:54.180 --> 24:01.620]  еще одну переменную from bool zx i1 y to i8. Это, если что, lvm код. Дальше храним значение наше,
[24:01.620 --> 24:07.940]  при этом указан выравниваем. Дальше мы зачитаем значение этого всего дела. Почему-то обратно мы
[24:07.940 --> 24:19.300]  это все конвертируем в bool, опять снова в i1. Да-да-да, не, по идее, тут можно было бы сразу...
[24:19.300 --> 24:33.940]  Нет, у нас просто уже есть i1. Зачем, спрашивается... Да, протент можешь генерить любую вещь, согласен.
[24:33.940 --> 24:48.940]  Да-да-да, согласен. Да, и вот смотрите, к чему мы приходим. У нас здесь переменная to bool есть и
[24:48.940 --> 24:56.220]  дальше у нас есть br. Значит, br это либо jump, либо condition jump в зависимости от числа переменных.
[24:56.220 --> 25:06.020]  Вот, и мы говорим to bool. Значит, смотрите, если to bool у нас true, то есть получается to bool это у
[25:06.020 --> 25:14.820]  нас кто и 0, это y. Если y у нас true, то мы прыгаем с вами в end сразу, иначе мы прыгаем в правую часть.
[25:14.820 --> 25:19.780]  Давайте посмотрим, что будет, если мы не прыгаем в правую часть, тогда нам нужно загрузить значение
[25:20.460 --> 25:34.660]  и получить значение. Да, это особенность иара. Да, он не умеет проходить сквозь метки. Зачем это сделано?
[25:34.660 --> 25:39.980]  Это сделано для того, что вот эта вот штука, вот которая от метки до бранчика называется basic
[25:39.980 --> 25:44.580]  block'ом. Главная особенность basic block состоит в том, что их можно ставить в любом порядке.
[25:44.580 --> 26:11.700]  Зачем это нужно? Объясняю, у вас дальше, значит, можно эти блоки будет объединить в трейсы,
[26:11.700 --> 26:18.140]  вот, и дальше задать линейный порядок. То есть, допустим, нам окажется, что большая часть инструкции,
[26:18.140 --> 26:22.580]  которая у нас есть с оптимизатором-компилятором, понимает, что ему надо зайти в правую часть,
[26:22.580 --> 26:30.060]  в большей части случаев, чем не зайти в правую часть. Да, да, да, и поэтому мы как раз их соединим
[26:30.060 --> 26:38.860]  в одну инструкцию. Вот, значит, дальше у нас есть прыжок и label, и вот тут начинается веселая
[26:38.860 --> 26:45.940]  часть. У нас появляется fee-инструкция, которая говорит следующее, что если мы прыгнули из вот
[26:45.940 --> 26:50.660]  такой метки, то поставь такое значение, а если мы прыгнули из другой метки, то поставь другое
[26:50.660 --> 26:56.940]  значение. То есть мы говорим, что если мы прыгнули с вами из изначальной метки, то означает выражение
[26:56.940 --> 27:03.780]  у нас true, действительно. Когда мы прыгнули в end, тогда когда у нас тубул равняется единице,
[27:03.780 --> 27:11.700]  то есть когда наше значение равняется единице, значит у нас здесь уже результат true. Вот, а если мы
[27:11.700 --> 27:20.180]  говорим про другую метку, вот здесь, то мы прыгнули отсюда, соответственно, нам нужно посмотреть какое
[27:20.180 --> 27:30.220]  значение было в этой метке, которую мы, кстати, определили только внутри правой части. Да, это виртуальный
[27:30.220 --> 27:32.740]  регистр.
[28:00.220 --> 28:20.220]  Технически нет, но в большей части да, а дальше список условий.
[28:20.220 --> 28:37.820]  Лорр РХС, да. Дальше кастуем и возвращаем в Void. Кстати, а зачем мы? Ну, сразу можно понять,
[28:37.820 --> 28:42.020]  что компилятор, что это все было скомпилировано с опцией минусу ноль.
[28:42.020 --> 29:01.260]  Ну вот, то есть он, как бы, генерировал сложный код. Ну да, в общем, вот такой вот код, собственно,
[29:01.260 --> 29:07.220]  практиковать мы его будем на семинарах, на лекциях мы немного пойдем по другой части. Так, значит,
[29:07.220 --> 29:14.300]  значит, смотрите, нам нужно будет сейчас, как ни странно, взять дерево, абстрактное
[29:14.300 --> 29:20.580]  синтаксическое дерево с его структурой и переложить его в другое синтаксическое дерево. Но
[29:20.580 --> 29:28.460]  синтаксическое дерево здесь уже будет не выглядеть не как список, да, ну, его можно представить в виде
[29:28.460 --> 29:45.740]  дерева, при желании. Списка деревьев. Ну да, часто формали не образуют, но, в принципе,
[29:45.740 --> 29:48.580]  мы их можем тоже анализировать, как в виде дерева.
[30:15.740 --> 30:43.940]  Не, у нас может...
[30:43.940 --> 31:04.380]  В ветке. Не, в исходном...
[31:13.940 --> 31:22.700]  Не, ну бренч, они все-таки, ну да, они будут завязаны под другие переменные, да. То есть нам
[31:22.700 --> 31:27.460]  нужно будет правильно эмитить наш выход, получать результат.
[31:27.460 --> 31:36.900]  Ну да, тут уже реализаций много, да, я все-таки бы угадал, как это сделать, как это сделать.
[31:36.900 --> 31:58.500]  Ну да, тут уже реализации много, да, я все-таки буду говорить про более такую
[31:58.500 --> 32:05.740]  теоретическую основу. Значит, смотрите, и сразу скажу, что в ER дереве, значит, мы можем сказать,
[32:05.740 --> 32:11.740]  что у нас есть аля в ER дереве, в кавычках, значит, у нас будут некоторые типы. Первое,
[32:11.740 --> 32:17.020]  это экспрешена, это те, что мы будем считать. Значит, дальше у нас будут стейтменты,
[32:17.020 --> 32:25.900]  это, собственно, операторы присваивания, там вызовы самих экспрешен, которые не влияют на
[32:25.900 --> 32:34.180]  результат, там принт инструкции, кстати. Кстати, сразу скажу следующий момент, что принт инструкции,
[32:34.180 --> 32:49.060]  это на самом деле не совсем стейтмент, это больше экспрешен. Да, ну вот, не, мы пока будем считать
[32:49.060 --> 32:54.100]  все-таки отдельные стейтменты. Значит, дальше нам нужен будет экспрешен лист, зачем нам нужно
[32:54.100 --> 32:59.140]  будет в какой-то момент времени экспрешен лист, в какой-то смысле, именно список экспрешен хранить.
[32:59.140 --> 33:20.460]  Мы должны, да, оно хранит стейтмент лист. Да, когда мы вызываем функцию, у нас может быть
[33:20.460 --> 33:25.060]  несколько аргументов, как раз в данном случае нам нужен будет экспрешен лист. Стейтфлис
[33:25.060 --> 33:30.620]  basic утверждений и, значит, тут еще можно добавить, как раз коллеги добавили, что мы можем говорить
[33:30.620 --> 33:35.980]  про такой панист как basicplog, который будет состоять из стейтных листов. И при этом в начале у него
[33:35.980 --> 33:42.820]  будет инструкция видометки и в конце будет инструкция videojump. Это, кстати, тоже будет стейтментом.
[33:42.820 --> 33:52.620]  Значит, смотрите, здесь вот такой вот список выражений предлагается экспрешен, давайте обозначим
[33:52.620 --> 33:57.860]  их. Значит, тут надо тоже быть в какой-то степени аккуратным, потому что все зависит от дерева и яра.
[33:57.860 --> 34:05.220]  Значит, мы с вами можем объявить, да, тут именно синтаксис такой, мы можем с вами объявить константу,
[34:05.220 --> 34:14.460]  это по факту аналог нашего number expression. Дальше у нас может быть метка, это как раз через
[34:14.460 --> 34:22.620]  которую мы будем с вами прыгать. После этого у нас может быть временная переменная tempT, после этого
[34:22.620 --> 34:28.620]  у нас может быть с вами бинарная операция. Вообще, знаете, сразу скажу, что вы можете взять любой
[34:28.620 --> 34:38.060]  собственный ER написать, главное его сигнатуру определить. А дальше здесь, в том яре, в котором
[34:38.060 --> 34:44.900]  я основываюсь, есть такая вещь, оператор mem, memory. Значит, она позволяет вам по любому экспрешену
[34:44.900 --> 34:49.500]  получить значение виртуального регистра, то есть, если в левой части вы его используете,
[34:49.500 --> 34:55.900]  то вы получаете указатель на lvalue, который вы можете записать значение. В правой части это
[34:55.900 --> 35:24.580]  Rvalue. Не надо. Ну да. Да, да, так тоже можно. Согласен, в принципе ER это и сделает. Да,
[35:24.980 --> 35:34.420]  да, смотрите, у нас получается, что оператор mem по факту это либо оператор load в определенной
[35:34.420 --> 35:40.660]  части. Мы загружаем наш указатель, дальше по нему пишем значение. Дальше у нас должен быть call
[35:40.660 --> 35:47.260]  expression, это вызов функции s с аргументами list. И на самом деле здесь еще есть такая одна абстрация
[35:47.260 --> 35:56.860]  в текущем дереве. Это в яре. Это некоторый аналог, который позволяет нам вычислить некоторые,
[35:56.860 --> 36:03.580]  так сказать, утверждения s, после чего вернуть значение, результат выражения e. То есть,
[36:03.580 --> 36:10.900]  это некоторый side-effect, который нам может понадобиться. Вот это оператор e sec, expression
[36:10.900 --> 36:17.620]  sequential. Вот. Тут можно подумать, где это нужно. На самом деле это обычно нужно, когда нужно,
[36:17.620 --> 36:23.260]  допустим, взять какую-нибудь переменную, скастовать ее к определенному типу, потом получить результат.
[36:23.260 --> 36:37.580]  Это переглядный. Да, это выглядит как оператор запятая. Вот. Когда он все-таки нужен. Так,
[36:37.660 --> 36:43.860]  список выражений, значит, список утверждений. Здесь как раз есть тоже некоторые абстракции,
[36:43.860 --> 36:54.220]  которые есть. Первый оператор это у нас как раз присваивание значений в метку. Второй оператор
[36:54.220 --> 37:01.900]  это оператор store. То есть, как бы мы получаем указатель на метку e1, вычисляем значение e2 и
[37:01.900 --> 37:07.580]  после этого перемещаем значение в указатель. То есть, это оператор store. Вот. Вот этот оператор
[37:07.580 --> 37:17.780]  это оператор, как он называется, давайте промотаем. Вот это оператор, то есть, вот это у нас оператор
[37:17.780 --> 37:31.220]  load. Вот этот оператор store. Это псевдояр, так сказать.
[37:47.780 --> 38:14.060]  Ну, это да. Ну, в какой-то степени да. В целом можно сделать так. Значит, дальше смотрите. Здесь,
[38:14.060 --> 38:21.820]  конечно же, сразу почему скажу так, потому что когда это, кстати, из книги этой, создание
[38:21.820 --> 38:27.500]  миниджава компилятора. Вот там они предлагают такой язык ER. Понятно, что в современных реалиях
[38:27.500 --> 38:33.940]  мы понимаем, что его можно сильно упростить. Да, то есть, грубо говоря, если у нас есть conditional
[38:33.940 --> 38:38.780]  jump, то conditional jump мы делаем на определенные условия, а не на некоторые операторы. Но все
[38:38.780 --> 38:43.180]  равно тоже интересно посмотреть не только один пример ER, но и другой пример ER для того,
[38:43.180 --> 38:47.300]  чтобы понять, как они соотносятся между собой. Значит, дальше у нас есть expression,
[38:47.300 --> 38:52.220]  которая вычисляет в выражении E и игнорирует результат. То есть, expression будет на вход
[38:52.220 --> 38:59.100]  принимать expression. Дальше у нас есть оператор jump, который делает прыжок в метку L. Это по факту,
[38:59.100 --> 39:04.980]  если мы говорим в классическом и aria L вемовском, то это оператор burr без никаких операторов,
[39:04.980 --> 39:13.540]  без никаких аргументов. Следующая функция это conditional jump. И вот смотрите, поскольку вот в этом
[39:13.540 --> 39:18.820]  aria не предусмотрено тип boolean, то нам приходится выкручиваться вот так. То есть, что у нас есть
[39:18.820 --> 39:24.580]  оператор, который принимает два выражения, и дальше мы вычисляем значение E1, вычисляем значение E2,
[39:24.580 --> 39:32.180]  сравниваем их по операции. Если результат true, прыгаем в ветку T, иначе прыгаем в ветку F. В aria
[39:32.180 --> 39:38.020]  мы бы сделали следующее. Мы бы вызвали какой-нибудь бинарный оператор в сравнение, загрузили бы это в
[39:38.020 --> 39:44.940]  boolean метку, сделали бы прыжок в результат. Дальше у нас есть оператор sec. Кстати, про то,
[39:44.940 --> 39:52.500]  почему это может быть деревом. Просто мы можем sequential объединить в список. И последнее стоит
[39:52.500 --> 40:00.420]  вот это создание метки. Опять же, напомню, что это такой псевдоэфемерный яр, и это такая
[40:00.420 --> 40:08.220]  дань история. Потому что LVM в то время еще, по-моему... Кстати, давайте узнаем, в каком году LVM появился,
[40:08.220 --> 40:13.980]  первый релиз. Давайте посмотрим.
[40:13.980 --> 40:34.180]  2003. А вот эта книжка написана в 2001 году, то есть она появилась еще до того, как появился LVM.
[40:34.180 --> 40:41.460]  Поэтому удивительно, что есть какой-то другой яр. И, кстати, к слову, к ответвлению, знаете,
[40:41.460 --> 40:48.140]  в некоторых компаниях, которые появились еще в бородатых 90-х годах, есть даже свои собственные
[40:48.140 --> 40:49.500]  стандарты языка C++.
[40:49.500 --> 40:56.580]  Чего?
[40:56.580 --> 41:10.780]  Да. Ну, своя надстройка над компилятором и свои библиотеки поверх компилятора.
[41:10.780 --> 41:19.580]  Вот. К примеру, есть такая компания, я не знаю, как она сейчас называется, по-моему,
[41:19.580 --> 41:29.420]  она сейчас в России называется А4. Это бывшая компания Abbey. Вот, так там в Abbey как раз свой
[41:29.420 --> 41:36.260]  собственный стандарт. Насколько я знаю, в Одинэйсе тоже в свое время был свой собственный
[41:36.260 --> 41:44.380]  стандарт, но потом они его прокачали и они отстают на одну версию от стандарта, от классического
[41:44.380 --> 42:07.220]  сейчас.
[42:08.060 --> 42:10.460]  И, кстати, в Куде тоже свой собственный стандарт.
[42:10.460 --> 42:27.100]  Смотрите, тут еще один важный момент. Хочу сказать, что, грубо говоря, в каких-то
[42:27.100 --> 42:31.940]  стандартах могут быть разные языки промежуточных представлений. То есть, как бы, у GCC свой
[42:31.940 --> 42:37.380]  есть ЯР, у вот этого языка свой собственный ЯР, у LV тоже свой собственный ЯР.
[43:01.940 --> 43:08.500]  Так, ладно, давайте посмотрим как раз пример этого Яра. Значит, какие типы
[43:08.500 --> 43:13.700]  экспрешенов у нас могут быть? У нас могут быть типы экспрешенов, это экспрешены, это могут быть
[43:13.700 --> 43:18.940]  стейтменты, это выражения, в которых результат игнорируется. И третье, это условные выражения,
[43:18.940 --> 43:23.700]  здесь явно выделяются условные выражения, которые необходимы для прыжков по меткам,
[43:23.700 --> 43:30.380]  то есть, чтобы мы делали conditional jump. Вот. И, значит, если действовать по классической
[43:30.380 --> 43:35.220]  реализации, то необходимо было бы сделать обёрт конвертера между классами. То есть,
[43:35.220 --> 43:42.700]  каким образом, собственно, сделать экспрешены, которые там, грубо говоря, объект, который нам
[43:42.700 --> 43:46.580]  берет что-то конвертирует в экспрешен, что-то конвертирует в стейтмент и что-то конвертирует
[43:46.580 --> 43:52.140]  в conditional, то есть, которые при этом добавляют ветки true и false. Сразу скажу, что этот код не
[43:52.140 --> 43:55.660]  скомпилируется, потому что true и false вряд ли вы сможете передать в прогументу функции,
[43:55.660 --> 44:10.260]  если только никакой другой язык. Вот. Значит, смотрите, как это делается. Вот. И смотрите,
[44:10.260 --> 44:16.060]  вот у нас есть вот такой вот код. Значит, если у нас а меньше b и c меньше d, то мы прыгаем в true
[44:16.060 --> 44:23.180]  блок. Иначе мы прыгаем в false блок. Ну, собственно, здесь это можно конвертировать так. Нам нужна будет
[44:23.180 --> 44:30.300]  дополнительная метка z, которая делает следующее. У нас создается несколько наборов секвенсов. Мы
[44:30.300 --> 44:38.500]  сравниваем, значит, с a и b, прыгаем в метку z, если значение true. Если нет, то мы прыгаем в значение
[44:38.500 --> 44:46.500]  в метку false. Дальше у нас получается, если у нас есть sequence, то он, собственно, появляется новая
[44:46.500 --> 44:53.500]  метка z, и дальше делаем еще один jump. То есть вот так вот, вот эта вот штука превращается в conditional.
[44:53.500 --> 44:58.820]  То есть она нам сгенерирует несколько блоков подряд. То есть вот это выражение, оно будет прыгать,
[44:58.820 --> 45:07.340]  значит, либо в блок, который связан с true. Давайте я как раз тут чем удобен zoom рассказываю. Да,
[45:07.340 --> 45:22.740]  то есть смотрите. Так, смотрите, вот у нас получается, объявляется метка. Значит, первое
[45:22.740 --> 45:29.420]  секвеншал это у нас conditional jump. Он будет говорить, что мы прыгаем с вами, если условие выполнено,
[45:29.420 --> 45:35.940]  то мы прыгаем в ветку z и ветку f. Дальше мы делаем следующее. Говорим, окей, значит, если у вас
[45:35.940 --> 45:43.620]  метка z, мы ее объявляем здесь, и говорим следующее, окей, а здесь мы ставим еще один c jump,
[45:43.620 --> 45:56.780]  lt cd, c меньше d, получается ветка true и ветка false. И при этом где-то вдалеке будет у нас ветка true,
[45:56.780 --> 46:06.580]  собственно, ветка true и ветка с false, которые метки эти тоже будут объявлены, но это где-то
[46:06.580 --> 46:13.260]  будет потом. То есть вот таким вот образом мы с вами можем конвертировать эту штуку в conditional
[46:13.260 --> 46:19.180]  jump. Опять же, если нам нужно будет вычислить значение выражений, которое здесь есть, нам
[46:19.180 --> 46:28.060]  нужен будет аналог fee инструкций по тому примеру, который у нас рассматривали в прошлом. Так,
[46:28.060 --> 46:35.620]  поедем на этот пример. То есть если мы получается сразу прыгаем false, то мы сразу прыгаем false,
[46:35.620 --> 46:43.180]  иначе мы прыгаем в эти метки. Хорошо, так, мы убираем эту запись, clear road drawings и поехали
[46:43.180 --> 46:53.740]  дальше. Так, значит, для выражений, для стейтментов здесь сделается следующее. Значит, c jump,
[46:53.740 --> 47:03.140]  а, так, это стоп, у нас что было, значит, для выражений, так, а, это для стейтментов было,
[47:03.140 --> 47:10.740]  вот, для стейтментов, допустим, для expression, если мы сделаем, да, то expression верни себя,
[47:10.740 --> 47:16.740]  и дальше смотрите, что мы можем сделать дополнительно, если у нас это, допустим,
[47:16.740 --> 47:23.220]  не был какой-нибудь conditional, да, а именно мы получаем expression на вход конвертации в
[47:23.220 --> 47:29.620]  conditional, то мы должны сгенерировать дополнительную инструкцию, что у нас выражение не равно нулю. То есть
[47:29.620 --> 47:33.900]  то значение в expression, которое у нас было, оно не равняется нулю, если оно не равняется нулю,
[47:33.900 --> 47:39.660]  то мы прыгаем в true, иначе прыгаем в ветку fall. Так, для стейтментов, давайте подумаем,
[47:39.660 --> 47:44.340]  значит, каким образом происходит конвертация? Можем ли мы стейтменты сконвертировать в expression?
[47:44.340 --> 47:57.220]  Нет. Ну да, да, да, не раз. Statement, statement. Да, это жрецное преобразование, а в conditional?
[47:57.220 --> 48:09.980]  Это условное выражение, которое типа принимают в conditional jump, по факту. Statement. Навряд ли,
[48:09.980 --> 48:13.860]  наверное, да. Ну да, именно так, то есть...
[48:27.220 --> 48:40.260]  Да. Да, то да. Нет, нет, я скажу следующая вещь. Пока это такое псевдоярм. Если мы говорим
[48:40.260 --> 48:44.260]  про этот ярм, у него будет еще одна из стадий, называется линия реализации.
[48:44.260 --> 49:00.820]  Ну да, нет, поэтому для этого типа иаров его нужно еще причёсывать, чтобы он стал
[49:00.820 --> 49:10.820]  линейным. На самом деле, я честно скажу, судя по опыту, я могу сказать, просто люди
[49:10.820 --> 49:18.500]  булл не хотели придумывать. Булл придумывать. Да, второй тип перемены, и из-за этого возникают
[49:18.500 --> 49:25.980]  все проблемы. Ну да, поэтому если у нас булл, то понятно, что большое количество экспрешенов
[49:25.980 --> 49:31.540]  можно просто там conditional нам нафиг не нужен. Вот, смотрим условное выражение, сразу типа
[49:31.540 --> 49:37.060]  делаем две метки. Так, значит, это мы обсуждили, значит, для условных выражений. Значит, если мы
[49:37.060 --> 49:44.820]  говорим про условные выражения, то нужно учитывать разные блоки. И поэтому здесь, если так по-хорошему
[49:44.820 --> 49:50.620]  говорить, если поддерживать все эти операторы, то нужно будет конвертацию этих операторов в
[49:50.620 --> 49:59.220]  conditional делать. То есть, допустим, нам нужно, с вами будет конвертировать это все в экспреши. Условные
[49:59.220 --> 50:06.100]  выражения, если мы не хотим булы, тогда нам нужно будет вот этот conditional превратить следующую
[50:06.100 --> 50:17.420]  вещь. То есть, что нам нужно будет с вами, значит, объявить две метки r1. То есть, смотрите,
[50:17.420 --> 50:26.140]  что происходит. Мы указываем, что r равняется единице, а дальше делаем две ветки f. Если мы делаем
[50:26.140 --> 50:33.820]  jump в ветку f, то у нас r равняется нулю. То есть, давайте я тоже опять нарисую здесь, что здесь
[50:33.820 --> 50:40.220]  происходит. То есть, смотрите, здесь мы объявляем r, присваиваем метку единички. Да, тут ассоции не
[50:40.220 --> 50:47.460]  пахнет. Значит, дальше мы с вами делаем следующее. Вот это вот оператор nf, это он создает нам две
[50:47.460 --> 50:58.300]  ветки. А дальше мы говорим следующее. Значит, делаем ветку 0, здесь у нас будет ветка f, ветка 0.
[50:58.300 --> 51:07.860]  Вот, и с, и в ветку t. Вот, и дополнительно мы получается разворачиваем conditional. То есть,
[51:07.860 --> 51:15.260]  получается у нас следующая вещь. Когда мы хотим условное выражение какое-то сконвертировать,
[51:15.260 --> 51:23.300]  то мы должны получить значение результата r, которое будет пройдено через вот этот такт. То есть,
[51:23.300 --> 51:30.060]  когда мы будем его конвертировать, у нас появятся две метки tef, через которые мы их как раз и
[51:30.060 --> 51:40.980]  их сможем связать. То есть, у нас получается сайд-эффект вычисления наших выражений. Вот,
[51:40.980 --> 51:48.180]  так такая сложная инструкция, которая скорее всего не очень приятно выполнять. Вот, и соответственно
[51:48.180 --> 51:53.500]  здесь можно обсуждать, что можно сделать для других веток, для and or negate. Собственно,
[51:53.500 --> 52:00.820]  если and, то мы создаем промежуточную ветку для первых true, во-вторых false. Значит, для or мы
[52:00.820 --> 52:06.700]  выполняем оператор or, как в питоне он делается, или двойная палка. Мы делаем все то же самое,
[52:06.700 --> 52:13.100]  аналогичное оператору and, и в операции negate мы меняем ветки местами. Ну, то есть, если у нас
[52:13.100 --> 52:21.100]  было, грубо говоря, одно больше, чем второе, в выполнении jump ветки true и false, то мы их
[52:21.100 --> 52:30.700]  меняем местами, получаем jump ветку false true. Кажется, все логично. Так, вот, так, это что касается
[52:30.700 --> 52:36.900]  jump. Теперь давайте наконец-то придем к сути, как это все дело конвертировать. Первая операция
[52:36.900 --> 52:44.460]  это чтение переменной. Вот она будет выглядеть вот таким образом. То есть, мы для нашей переменной
[52:44.460 --> 52:49.900]  знаем сдвиг относительно frame pointer, поэтому если мы хотим взять значение какой-то переменной,
[52:49.900 --> 52:55.220]  получить, загрузить значение какой-то переменной, то нам нужно сделать следующее. Нам нужно будет
[52:55.220 --> 53:03.900]  сделать бинарную операцию frame pointer плюс ее сдвиг и взять ее в память. Это у нас оператор
[53:03.900 --> 53:11.700]  workloads так будет выглядеть. Ну или вообще оператор store. Значит, теперь вопрос, как хранить массивы?
[53:21.700 --> 53:24.700]  Тут есть несколько подходов. Давайте обсудим.
[53:24.700 --> 53:47.180]  Гениально. Где у нас массив хранится будет?
[53:47.180 --> 54:05.340]  Так, два варианта. На стейке куча и еще один. Да, можно засунуть их туда.
[54:05.340 --> 54:22.580]  Ну, в общем, смотрите. На самом деле три варианта перечисли. Если брать Pascal like
[54:22.580 --> 54:27.540]  вариант, то массивы это отдельные переменные, которые можно забивать в память. Если мы
[54:27.540 --> 54:34.500]  C like массива возьмем, то это массивы указателей по факту, которые занимают некоторую последовательность
[54:34.500 --> 54:44.660]  символов на стейке. Да, я и говорю, что это отдельный тип именно.
[54:44.660 --> 55:11.580]  Пхп like тогда уж. Тогда уж пхп like. Мы можем с вами создавать массивы в куче. Причем мы будем
[55:11.580 --> 55:17.260]  умулировать call внешней функции с набором параметров. Назовите, пожалуйста, функцию,
[55:17.260 --> 55:23.060]  которую нам нужно будет вызвать для того, чтобы алоцировать участок памяти на куче.
[55:23.060 --> 55:30.140]  Malog, да. Просто мы когда будем это все делать, то есть когда конвертация VR происходит,
[55:30.140 --> 55:39.900]  нам нужно создать массив, просто убирать ее и пишете call Malog. Да, и получаете указатель на...
[55:39.900 --> 55:44.820]  Конечно, можно.
[55:44.820 --> 55:58.580]  Да-да-да. Ну, если посмотреть просто любой исполняемый файл, который у нас генировал,
[55:58.580 --> 56:03.860]  в гел-файл у него есть утилита лдд. Просто посмотреть какие динамические либилитетики
[56:03.860 --> 56:08.580]  там подключаются. И там по подавляющей большинства просто липси подключил.
[56:08.580 --> 56:38.100]  Ну да, единственное, где это вы можете увидеть, что у вас что-то не использует липси, это надо зайти
[56:38.100 --> 56:58.100]  взять docker образ busybox и в нем что-нибудь попробовать запустить. Ну да, часть механизма липси.
[56:58.100 --> 57:09.540]  Так, ладно, давайте тогда перейдем к структурам. Значит, все подобные в языке поля структуры могут
[57:09.540 --> 57:13.860]  иметь произвольное количество параметров, поэтому VR и LVM на самом деле существует понятие
[57:13.860 --> 57:17.980]  выравнивания, то есть позволяет указывать для каждого перемена, как они выравниваются.
[57:17.980 --> 57:25.460]  Вот, и, собственно, если мы говорим про наш механизм MEM, то мы можем дополнительно передать
[57:25.460 --> 57:29.100]  параметр, типа какое именно выравнивание мы хотим использовать для наших переменных.
[57:29.100 --> 57:35.900]  Дальше, веселая вещь. Собственно, как обратиться к элементам массива, на самом деле очень просто.
[57:35.900 --> 57:41.260]  Взять указатель на начало массива, это оператор load, сделать сдвиг на него на определенное
[57:41.260 --> 57:47.740]  количество слов, если мы работаем с вами в byte offset, либо сделать сдвиг на определенное
[57:47.740 --> 57:56.100]  количество элементов. В VR и LVM, господи, как это называется, по-моему, GetElementInboundsPtr,
[57:56.100 --> 58:02.780]  или как-то так, там специальная функция есть, GetElementPtr. В VR, я думаю, мы посмотрим это на
[58:02.780 --> 58:14.900]  семинарах. Кстати, это касается элементов массива. Вопрос, все знают Питон? Типа, ну, на самом деле...
[58:14.900 --> 58:34.380]  Нет, нет, нет. Смотрите. На самом деле, если мы посмотрим на все функции того, как выглядит
[58:34.380 --> 58:40.620]  функция VR и LVM, то мы внезапно обнаружим, что они выглядят все как в Питоне, потому что у них
[58:40.620 --> 58:43.500]  как раз первым аргументом будет передаваться указательность здесь.
[59:10.620 --> 59:20.500]  Ну, это мы совсем уже в низку уровню спускаемся. Мы все-таки пока на ИАРе находимся. Вот. Значит,
[59:20.500 --> 59:25.420]  на самом деле обращение к полям класса ничем не отличается от обращения к элементам массива,
[59:25.420 --> 59:37.780]  просто нужно понимать, какой элемент относительно зысо находится для этого поля. Да. Да. Вот. Поэтому
[59:37.780 --> 59:44.380]  арифметика. Ну, мне кажется, здесь все просто. Для арифметики бинарная операция. Вот. Значит,
[59:44.380 --> 59:50.460]  если нужно делать условные выражения, то мы можем сделать следующее. Тобственно, мы объединяем их в
[59:50.460 --> 59:56.340]  необходимом порядке. То есть, two conditional, true, false. Дальше, то, у которого условие у нас идет
[59:56.340 --> 01:00:02.540]  then statement, то мы их находим после метки true. После этого мы здесь делаем jump метку after. После
[01:00:02.540 --> 01:00:08.620]  этого мы пишем label false, указываем метку соусом. После этого делаем метку jump в after. И после этого
[01:00:08.620 --> 01:00:17.660]  получаем after. Ну, дальше строковые типы. У нас создается именованная метка. Можем создать. Вот.
[01:00:17.660 --> 01:00:23.740]  И все операции можем производить в runtime аналогично массивам, умеющимся. Вот. Тем более,
[01:00:23.740 --> 01:00:30.300]  кстати, в питонии строка это, там, итерация по строке, это то же самое, что итерация по массиву
[01:00:30.300 --> 01:00:37.780]  из чаров. Вот. Собственно, массивы и структуры мы можем тоже вызывать. Нам нужно будет делать
[01:00:37.780 --> 01:00:49.580]  lock, malloc. А, кстати, важный момент. Нужно, когда вы выделяете массив, вы создаете массив размером
[01:00:49.580 --> 01:00:51.420]  на один больше, чем количество элементов.
[01:00:51.420 --> 01:01:07.340]  Да, согласен. Здесь просто про input все говорится.
[01:01:07.340 --> 01:01:11.980]  Да.
[01:01:37.340 --> 01:02:00.860]  Ну, да.
[01:02:00.860 --> 01:02:22.180]  Так. Хорошо. Да. А вот это, допустим, то, как можно хранить значение. То есть, это
[01:02:22.180 --> 01:02:28.300]  инициализация структуры. То есть, мы сделаем malloc, а дальше записываем значение элемента
[01:02:28.300 --> 01:02:35.140]  наших массивов. То есть, я один, первый я записываю со двигом, второй со двигом на одно слово и так
[01:02:35.140 --> 01:02:40.580]  далее. И после этого мы получаем нашу структуру. То есть, мы получаем наш указатель. То есть,
[01:02:40.580 --> 01:02:48.220]  это прямо то, как можно прям массив сразу с унициализацией получить. То есть, вы пишете int
[01:02:48.220 --> 01:02:56.420]  x, квадратные скобки равно, там, вот это вот. И сразу то, что вы в него записываете. Так,
[01:02:56.420 --> 01:03:04.060]  что касается создания массива структуры. Циклы, кстати, переписываются вот так. То есть,
[01:03:04.060 --> 01:03:10.580]  с while у нас получается, если не выполнена condition, то мы идем в done. Выполняем body,
[01:03:10.580 --> 01:03:29.900]  go to в jump начальную метку. For обычно переписывается в while. Да, вот. Значит, если мы с вами хотим
[01:03:29.900 --> 01:03:38.140]  callingConversions для функций и для методов класса, то мы вызываем call от имени нашей функции. Для
[01:03:38.140 --> 01:03:46.340]  методов мы вызываем call от полного классификатора нашей метки класса и передаем аргументы.
[01:03:46.340 --> 01:03:52.580]  Первым аргументом передаем указатель на this. Это callingConversions для меток. Так,
[01:03:52.580 --> 01:04:00.420]  объявление переменных, кстати, здесь можно опустить. Либо мы явно их, если мы говорим
[01:04:00.420 --> 01:04:09.620]  про RLVM, то мы делаем aloka. Вот. Так, это, так, я думаю, что на этом мы остановимся,
[01:04:09.620 --> 01:04:17.280]  потому что здесь как раз уже идет callingConversions, который вот нам для практики сейчас не нужен. И на
[01:04:17.280 --> 01:04:23.660]  семинаре мы тогда посмотрим примеры конвертации в RLVM. Вот. Там просто дальше последняя часть слайда
[01:04:23.660 --> 01:04:33.020]  про RLVM. Если, допустим, надо будет, мы просто вспомним, как это делается еще раз. Так. Наверное,
[01:04:33.020 --> 01:04:38.300]  на сегодня из основных моментов все. Значит, что мы с вами сделали? Давайте просуммируем. Мы с вами,
[01:04:38.300 --> 01:04:43.220]  собственно, разобрали некоторые подводные камни с примерами с таблицей символов. Поняли,
[01:04:43.220 --> 01:04:48.860]  что нам нужно для того, чтобы начать готовиться к IR, и в дальнейшем мы как раз разобрали, каким
[01:04:48.860 --> 01:04:54.180]  образом можно все делать, конвертировать в IR. Значит, в следующий раз мы с вами посмотрим,
[01:04:54.180 --> 01:04:59.500]  как эти некоторые инструкции можно оптимизировать. То есть посмотрим, как любой IR можно, в принципе,
[01:04:59.500 --> 01:05:04.940]  приводить к линейному виду. Ну и дополнительно начнем говорить про оптимизацию. То есть делаем
[01:05:04.940 --> 01:05:06.260]  классификацию оптимизации.
