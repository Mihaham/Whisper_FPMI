[00:00.000 --> 00:12.000]  Ну, в принципе, тут можно... Вот мы много чего изучили про mp-полноту.
[00:12.000 --> 00:16.000]  В принципе, можно дальше в разных направлениях двигаться.
[00:16.000 --> 00:26.000]  Ну, давайте я буду рассказывать про другие классы задач.
[00:26.000 --> 00:34.000]  Да, в общем, мы поговорим про полинамиальную иерархию.
[00:38.000 --> 00:44.000]  Вот. Значит, это некоторое такое обобщение np.
[00:45.000 --> 00:49.000]  Можно прямо сюда это написать.
[00:56.000 --> 01:04.000]  Обобщение np.
[01:11.000 --> 01:18.000]  Вот. Ну и давайте начнем от такого вопроса.
[01:18.000 --> 01:28.000]  Значит, рассмотрим какую-нибудь точную задачу оптимизации.
[01:31.000 --> 01:37.000]  Например, чему равно хроматическое число графа?
[01:37.000 --> 01:45.000]  Ну, соответственно, можно рассмотреть прям такую задачу.
[01:45.000 --> 01:49.000]  Назовем ее хром-намбер.
[01:49.000 --> 02:05.000]  Которая есть набор пар из графа и числа таких, что хроматическое число графа g в точности равно k.
[02:05.000 --> 02:09.000]  И тогда получается следующее.
[02:09.000 --> 02:23.000]  Если мы напишем здесь меньше либо равно, то это будет классическая np. полная задача.
[02:25.000 --> 02:31.000]  Она будет np. полной, даже если там k ровно 3.
[02:31.000 --> 02:35.000]  Ну, в общем, все равно.
[02:35.000 --> 02:39.000]  И за это она будет np. трудной.
[02:39.000 --> 02:55.000]  Да, в np она будет, потому что достаточно предъявить раскраску в не более чем k цветов.
[03:01.000 --> 03:11.000]  Вот. Соответственно, если мы здесь напишем теперь больше либо равно, то это на самом деле будет coin.p полная задача.
[03:11.000 --> 03:19.000]  Ну, потому что тут наоборот.
[03:19.000 --> 03:33.000]  Для опровержения достаточно предъявить раскраску в меньше чем k цветов.
[03:33.000 --> 03:41.000]  А как мы определим coin.p полнота?
[03:41.000 --> 03:45.000]  Да, конечно, coin.p полнота точно так же, как np. полнота.
[03:45.000 --> 03:47.000]  И вообще, на самом деле это общее понятие.
[03:47.000 --> 03:57.000]  Если у вас есть какой-то класс и какое-то понятие сводимости, то возникает понятие полноты относительно этой сводимости.
[03:57.000 --> 04:03.000]  Ну да, эти я тут припишу.
[04:03.000 --> 04:31.000]  Значит, coin.p полнота это принадлежность к coin.p, плюс полиномиальная сводимость любой задачи из coin.p к данной.
[04:31.000 --> 04:37.000]  И в принципе, значит, это у нас будет еще очень много раз встречаться в курсе.
[04:37.000 --> 04:44.000]  Там будет, например, вот, ну, собственно, с полиномиальной иерархией будут некоторые классы, в них будет полнота.
[04:44.000 --> 04:52.000]  Вот. Будет там B-space полнота, будет там NL полнота для логографической сводимости.
[04:52.000 --> 04:56.000]  В общем, это одно из ключевых понятий.
[04:56.000 --> 05:06.000]  Да, значит, есть понятие сводимости, очень важно, и есть понятие полноты, тоже очень важно.
[05:16.000 --> 05:18.000]  Вот.
[05:26.000 --> 05:31.000]  Хорошо. Значит, теперь, что дальше?
[05:31.000 --> 05:36.000]  Да, значит, смотрите, если меньше, то это NL полное, если больше, то coin полное.
[05:36.000 --> 05:49.000]  Вот. А если прямо равно, то, вероятно, не принадлежит ни к NL, ни к coin.p.
[05:49.000 --> 05:55.000]  По крайней мере, неясно, как бы это можно было доказать или опровергнуть.
[05:55.000 --> 06:00.000]  Да, то есть, как доказать, что в точности k? Ну, вот, непонятно. Можно, конечно, уменьшить либо равно k.
[06:00.000 --> 06:07.000]  Как опровергнуть, что равно k? Ну, можно, конечно, опровергнуть, предъявив раскраску, меньшее число цветов.
[06:07.000 --> 06:11.000]  Вот. Но опровергнуть, предъявив большее число цветов, не получится.
[06:11.000 --> 06:17.000]  Да, значит, поэтому тоже непонятно, что делать.
[06:17.000 --> 06:42.000]  Вот. Соответственно, можно только сказать, что это пересечение языка из NP и языка из coin.p.
[06:42.000 --> 06:56.000]  Либо, что то же самое, либо, эквивалентно, разность двух языков из NP.
[06:56.000 --> 07:07.000]  Значит, поскольку coin.p это множество дополнений к языкам из NP, то, соответственно, пересечение NP и coin.p это то же самое, что пересечение с дополнением.
[07:07.000 --> 07:12.000]  Но пересечение с дополнением – это и есть разность.
[07:12.000 --> 07:21.000]  Так. Хорошо. Соответственно, класс таких языков называется DP.
[07:21.000 --> 07:44.000]  Значит, от слов Difference polynomial. Вот. То есть, получается, что DP – это множество… Ну, давайте через разность напишу.
[07:44.000 --> 08:04.000]  Множество разностей двух языков, а значит, таких, что a из NP, a b из coin.p.
[08:04.000 --> 08:09.000]  Вот.
[08:09.000 --> 08:18.000]  Ой, да, если разность, то a b из NP, правильно.
[08:18.000 --> 08:40.000]  Вот. Хорошо. Соответственно, здесь действительно более-менее все задачи точной оптимизации лежат в DP.
[08:40.000 --> 08:50.000]  Ну, что значит все? Те, для которых можно проверить запоминальное время, что значение на данном входе равно тому-то.
[08:50.000 --> 08:53.000]  Да, но таких задач у нас было довольно много.
[08:53.000 --> 09:00.000]  Да, например, кроме хроматического числа были там задачи о клике или о члене независимости.
[09:00.000 --> 09:06.000]  Да, в принципе, там задачи в рюкзаке можно так воспринимать, да, задачи Комико и Жора.
[09:06.000 --> 09:21.000]  Вот, значит, куча вариантов, которые все вот такие вот.
[09:21.000 --> 09:28.000]  Ну, и там целочисленно-линийное программирование, оно прям формулируется как задача оптимизации.
[09:28.000 --> 09:36.000]  Так, хорошо. А теперь давайте посмотрим на вот эти вот языки.
[09:36.000 --> 09:55.000]  Значит, теперь посмотрим на эти языки с точки зрения записи, ну, логическими формулами первого порядка.
[09:55.000 --> 10:14.000]  Значит, смотрите, у нас, если А лежало в NP, то у нас получалось так, что х лежит в А тогда и только тогда, когда существует у в от x и у.
[10:14.000 --> 10:25.000]  Да, значит, и это с обычными оговорками, да, что у там полинамерной длины, в полинамерной отчислимой.
[10:25.000 --> 10:31.000]  Вот, ну и да, мы все, собственно.
[10:31.000 --> 10:52.000]  Вот, значит, дальше в NP получалось так, да, значит, что х лежит в Б, х лежит в Б тогда и только тогда, когда получалось для любого у в от x и у.
[10:52.000 --> 11:01.000]  Что это и из-за чего так получается? Ну, из того, что можно взять, да, Б это, например, дополнение К,
[11:01.000 --> 11:09.000]  когда можно взять отрицание вот здесь, вот, что х лежит в дополнение К, то есть как раз в Б, а здесь вот отрицание существования.
[11:09.000 --> 11:16.000]  А отрицание существования это будет для любого отрицания, и получится вот это w, это отрицание w.
[11:16.000 --> 11:23.000]  Вот, ну а ясно, что если w вычислимо за полинамерное время, то и отрицание w тоже вычислимо за полинамерное время.
[11:23.000 --> 11:42.000]  Так, значит, теперь что получается с точки зрения DP, да, пусть у нас теперь С лежит в DP, да, и С у нас, так, ну теперь давайте я наоборот напишу через пересечение,
[11:42.000 --> 11:50.000]  чтобы совпадало вот с этим. Значит, С это пересечение А и B, где А в NP, B в coinP.
[11:55.000 --> 12:06.000]  Вот, тогда получается следующее. А, давайте я еще здесь изменю у на z, да, чтобы были разные буквы.
[12:06.000 --> 12:31.000]  Значит, получается, что х лежит в С, тогда и только тогда, когда одновременно существует у такой, что v от x, y, и для любого z w от x, z.
[12:31.000 --> 12:46.000]  Вот, получается вот такая вот штука. А дальше это можно привести к предваренной нормальной форме, да, помните, мы такое изучали, что можно все кванторы вынести вперед.
[12:46.000 --> 13:05.000]  И получится, что с одной стороны будет существует у для любого z, что здесь v от x, y, и w от x, z.
[13:05.000 --> 13:22.000]  А с другой стороны можно и в другом порядке, да, можно писать для любого z, существует у, ну а здесь то же самое, v от x, y, и w от x, z.
[13:22.000 --> 13:36.000]  Да, значит, помните, мы это обсуждали на логике, что просто так менять порядок кванторов нельзя, только в одну сторону можно, но если формула вот так вот расщепляется на две, тогда можно и в обе стороны менять.
[13:36.000 --> 13:50.000]  Вот, то есть какой вывод, да, значит вывод такой, что здесь один квантор существования, здесь один квантор всеобщенности, а здесь у меня получается чередование.
[13:50.000 --> 14:09.000]  Вот, и это соответственно уже задает полинамиальную иерархию, да, то есть вообще теперь можно определять, что такое полинамиальная иерархия.
[14:09.000 --> 14:34.000]  Так, у нее есть много уровней, уровень 0, это просто P, уровень 0 это P, уровень 1 это NP и CoNP.
[14:34.000 --> 14:46.000]  Дальше есть уровень 2, ну вот DP будет на уровне 2, но не только.
[14:46.000 --> 15:15.000]  Да, значит будет, ой, нет, не так, значит будет sigma2 полинамиальная, значит это вот что, это множество таких а, что верно следующее, x лежит в a, тогда и только тогда, когда существует y.
[15:15.000 --> 15:23.000]  Для любого z, а здесь какой-то v от x, y, z.
[15:23.000 --> 15:48.000]  Вот, ну и соответственно P2 полинамиальная, значит тут соответственно будет наоборот, для любого y существует z.
[15:48.000 --> 16:09.000]  Вот, ну и так далее, на самом деле, если вы помните, что такое архиметическая иерархия, то это очень похожая вещь, только вот, ну в общем определение почти точно такое же, только добавлено условия полинамиальности.
[16:09.000 --> 16:23.000]  Да, значит соответственно получается, что вот все эти y и z должны быть полинамиальны длины от x, и v должно работать в полинамиальное время от x.
[16:23.000 --> 16:46.000]  Вот, значит, ну а соответственно, дальше так можно продолжать, уровень k, уровень k это будет sigma kt полинамиальная,
[16:46.000 --> 17:08.000]  значит это соответственно множество таких а, что x лежит в a, тогда и только тогда, когда существует y1, для любого y2 существует y3, и так далее.
[17:08.000 --> 17:29.000]  Вот, ну и соответственно тут на самом деле в зависимости вот, дайте я вот так напишу, значит в зависимости от четности, значит если нечетное, то будет, существует, если четное, то для любого.
[17:29.000 --> 17:54.000]  Существует для любого ykt, и дальше будет v, вот x, y1, и так далее ykt.
[17:54.000 --> 18:07.000]  Вот, значит ну и соответственно pi, точно так же pi kt полинамиальная, здесь первый квантор наоборот.
[18:07.000 --> 18:35.000]  Вот, выставим все точно так же, вот, значит ну в принципе и так далее, значит и так далее, еще будет просто ph, это объединение всех уровней.
[18:35.000 --> 19:03.000]  ph от слова полиномиал хаэроши, значит это будет, так, пукат нуля до бесконечности, объединение пукат нуля до бесконечности, соответственно sigma kt полинамиальных,
[19:03.000 --> 19:25.000]  ну и это в принципе то же самое, что объединение всех пукатах, это сейчас обсудим, почему это то же самое, вот, так хорошо, значит теперь хочется обсудить, как все эти классы друг с другом соотносятся,
[19:25.000 --> 19:46.000]  да, значит видно на самом деле, что вот уровень 0 и уровень 1 согласован со всем, что дальше, да, потому что np это на самом деле sigma первое, потому что тут существование coin p это p первое, потому что только всеобщность, а p это на самом деле sigma нулевое и p нулевое,
[19:46.000 --> 20:09.000]  да, здесь ни одного квантора нет, поэтому не важно какой он, да, значит вообще тут как и в случае с арифметической иерархией, то sigma это или p зависит от первого квантора, значит если первый квантор существования, то это sigma, если первый квантор всеобщенности, то это p, вот, ну а запомнить это можно так, что да, где sigma, а где p, ну смотрите, всеобщенность это что-то типа кайфовая,
[20:16.000 --> 20:40.000]  а конъюнкция, а конъюнкция это что-то типа умножения, вот, а умножение это p, да, p это произведение, вот, ну а дизюнкция, нас, что-то типа дизюнкция, а дизюнкция это конечно не совсем сложение, но все-таки ближе к сложению, чем к умножению, но в общем с этим можно поспорить, но в общем это по исключению получается,
[20:40.000 --> 21:10.000]  да, что соответственно, сочетание типа дизюнкции, дизюнкции типа сложения, вот, а сложение это сумма обозначается sigma, да, вот так можно запомнить где p, а где sigma, вот, но уж точно, уж точно дизюнкция это сложение, если считать, что ложь это ноль, а истина это любое положительное число, да, значит тогда уж точно конъюнкция это умножение, а дизюнкция это сложение прямо самое настоящее,
[21:10.000 --> 21:39.000]  вот, ну и кстати, это на самом деле не так, это не просто метафора, это прям будет использоваться на какой-то момент, правда, видимо, в следующем курсе, да, хорошо, значит, ну, соответственно, можно, почему это иерархия, да, значит, вообще иерархии очень важны,
[21:39.000 --> 21:55.000]  да, значит, для теории сложности, да, что важны не только отдельные классы, но и целые иерархии, да, а иерархии означают, что они как-то друг другу-другу вложены, и, соответственно, что тут так происходит, да, значит, вот есть нулевой уровень,
[21:55.000 --> 22:25.000]  и это, да, значит, нулевой уровень, это не зависит от того, sigma или pi, и это, соответственно, это p, вот, значит, дальше есть n, p и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q
[22:25.000 --> 22:33.320]  y и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q, и q,
[22:33.320 --> 22:38.600]  и q, и q, и q, и q, и q, и q.ía это состояниеnik 1 dimension insurance
[22:38.600 --> 22:40.260]  написал по вал listened to a
[22:40.260 --> 22:54.820] iji
[22:54.820 --> 23:08.820]  Сигма третья полинамиальная, пи третья полинамиальная, дальше и так далее, да и значит здесь где-то вот еще pH.
[23:08.820 --> 23:16.820]  Вот, а дальше эта структура вложенности будет вот такой вот.
[23:16.820 --> 23:26.820]  Это вложено вот так вот, п вложено в NP и также п вложено в CoNP, это мы хорошо знаем.
[23:26.820 --> 23:41.820]  Вот, а дальше здесь будет вложение вот так вот, как бы и параллельное, и крест-накрест тоже.
[23:41.820 --> 23:46.820]  Сигма 1 вложено в сигма 2, пи 1 вложено в пи 2.
[23:46.820 --> 23:51.820]  И также сигма 1 вложено в пи 2 и пи 1 вложено в сигма 2.
[23:51.820 --> 23:53.820]  Почему это так?
[23:53.820 --> 24:00.820]  Ну, потому что можно просто добавить второй квантор, можно как бы добавить фиктивную переменную, второй квантор,
[24:00.820 --> 24:04.820]  и причем его можно добавить как в ту, так и в другую сторону.
[24:04.820 --> 24:12.820]  Да, то есть, например, если у нас было NP, да, у нас было NP, вот такое вот существование y,
[24:12.820 --> 24:19.820]  то теперь можно считать, что у нас вот это самое v зависит не только от x и y, но еще от z.
[24:19.820 --> 24:28.820]  Но при этом на самом деле от z оно не зависит, да, то есть там одни и те же значения для всех z.
[24:28.820 --> 24:34.820]  Но тогда, соответственно, если от z зависимости нет, вот тогда можно любой квантор тут поставить,
[24:34.820 --> 24:40.820]  например, все общности, и это ни на что не повлияет.
[24:40.820 --> 24:47.820]  Так, ну а можно наоборот, можно представить, что вот тот старый y, это теперь у нас z, вот здесь вот,
[24:47.820 --> 24:50.820]  а мы добавили новый y, от которого ничего не зависит.
[24:50.820 --> 24:53.820]  И тогда к нему можно квантор в начало поставить,
[24:53.820 --> 24:58.820]  да, от этого sigma1 будет вложено в pi2, да, здесь sigma2.
[24:58.820 --> 25:01.820]  Ну и, в общем, это все аналогично.
[25:01.820 --> 25:08.820]  И дальше вот эта же самая картина, она так и будет дальше продолжаться.
[25:08.820 --> 25:24.820]  Вот, соответственно, так это будет все вложено, ну, значит, пока не будет вложено все в pH.
[25:24.820 --> 25:33.820]  И как раз вот эти вложения, они показывают, почему, вот это вот верно, да,
[25:33.820 --> 25:39.820]  значит, почему в обзине всех сигмакатах, это то же самое, что в обзине всех picat.
[25:39.820 --> 25:45.820]  Потому что каждый сигмакат вложен в piqa1, и поэтому, соответственно,
[25:45.820 --> 25:50.820]  в обзине всех сигмакат вложен в пк1, а это то же самое, что в обзине всех picat.
[25:50.820 --> 25:58.820]  Ну и наоборот, piqa вложен в sigma, ka1, поэтому правая часть вложена в левую.
[25:58.820 --> 26:01.340]  Вот, значит, вот поэтому это и иерархия.
[26:05.060 --> 26:10.240]  Так, ну что, значит, здесь давайте чуть-чуть остановимся, может, кините вопросы есть.
[26:11.380 --> 26:13.380]  Да, вот именно по определениям.
[26:21.140 --> 26:23.140]  Дальше я хочу несколько примеров привести.
[26:24.140 --> 26:26.140]  Несколько примеров.
[26:26.860 --> 26:32.540]  Задач, которые сложнее, чем вот эти первые примеры, да, значит, сложнее, чем просто задача оптимизации.
[26:33.620 --> 26:36.660]  Вот, но при этом лежат где-то вот на каких-то уровнях.
[26:40.660 --> 26:42.660]  ПАШ-Полиномиалхоэрши.
[26:47.900 --> 26:49.900]  Так, ну давайте.
[26:53.140 --> 26:57.140]  Как это пишется, собственно, Полиномиалхоэрши.
[27:07.660 --> 27:09.660]  Вот.
[27:13.780 --> 27:15.780]  Так, ну ладно, значит, давайте.
[27:16.580 --> 27:18.580]  Вот, вообще, на самом деле
[27:18.860 --> 27:21.380]  искусственно можно построить примеры, в общем-то, на любом уровне,
[27:21.780 --> 27:24.140]  но, естественно, это не так легко сделать.
[27:25.340 --> 27:30.340]  Поэтому естественные примеры обычно на втором уровне, иногда на третьем. Вот.
[27:31.540 --> 27:35.140]  Более высоко это скорее уже специальные примеры нужно струировать.
[27:38.660 --> 27:40.660]  Вот, значит,
[27:41.660 --> 27:43.660]  значит, примеры,
[27:44.980 --> 27:46.980]  примеры задач
[27:46.980 --> 27:48.980]  на втором и третьем
[27:49.980 --> 27:51.980]  уровнях
[27:52.980 --> 27:54.980]  Полиномиалхоэрши.
[28:00.940 --> 28:02.940]  Так.
[28:03.100 --> 28:05.100]  Ну, значит,
[28:05.100 --> 28:07.100]  например, есть задача
[28:07.100 --> 28:09.100]  минимальный
[28:09.100 --> 28:11.100]  DNF,
[28:11.100 --> 28:13.100]  да, ну, в виде,
[28:13.100 --> 28:15.100]  или вообще минимальная формуля.
[28:16.660 --> 28:18.660]  Так, первый пример,
[28:18.660 --> 28:20.660]  значит,
[28:20.660 --> 28:22.660]  задача на втором и третьем уровнях
[28:22.660 --> 28:24.660]  на первом уровнях
[28:24.660 --> 28:26.660]  на третьем уровне
[28:26.660 --> 28:28.660]  на третьем уровне
[28:28.660 --> 28:30.660]  на третьем уровне
[28:30.660 --> 28:48.140]  например, задача о минимизации dnf, она вот так вот формируется,
[28:48.140 --> 28:56.540]  minimal equivalent dnf, считается множество пар из формулы
[28:56.540 --> 29:03.740]  и какого-то числа, что для формулы
[29:03.740 --> 29:07.740]  для формулы
[29:10.820 --> 29:13.820]  phi
[29:14.620 --> 29:17.620]  существует
[29:17.620 --> 29:19.620]  а
[29:24.860 --> 29:32.660]  для формулы phi существует dnf длины k
[29:34.620 --> 29:38.260]  такая, что
[29:39.140 --> 29:44.420]  ну а просто эквивалент
[29:50.420 --> 29:54.900]  но в принципе, потому что это именно dnf, это в принципе не очень важно
[29:54.900 --> 30:03.060]  может быть какая-нибудь другая формула или просто произвольная формула
[30:03.060 --> 30:07.540]  вот, ну в общем тут нужно написать так
[30:08.460 --> 30:20.900]  существует psi такая, что для любого, а такая, что во-первых, psi dnf
[30:21.220 --> 30:24.380]  psi dnf
[30:24.780 --> 30:28.380]  соответственно длина psi
[30:29.380 --> 30:38.700]  не больше k и на экваленте phi, а что это значит, это для любого x
[30:38.700 --> 30:41.700]  для любого набора значений
[30:41.700 --> 30:46.700]  длина прям больше k или ровно?
[30:46.700 --> 30:50.700]  а, ну да, давайте не больше k
[30:51.380 --> 30:59.660]  да, это для любого x
[30:59.660 --> 31:07.900]  значит это соответственно на любом x значение psi такое же, как у phi
[31:10.700 --> 31:15.700]  вот, ну соответственно вот это вот для любого можно вынести
[31:15.700 --> 31:26.700]  ну а то есть можно эквивалентно написать вот так вот
[31:26.700 --> 31:33.700]  здесь, соответственно, для любого x вот эту брать
[31:33.700 --> 31:41.700]  вот, и тогда соответственно то, что в скобках будет полиномиально
[31:41.700 --> 31:44.700]  да, полиномиально проверяемо
[31:45.700 --> 31:52.700]  вот, и поэтому это получается sigma2
[31:52.700 --> 31:59.700]  формула из sigma2 полиномиальная
[31:59.700 --> 32:06.700]  вот, насчет ровно k можно еще заметить следующее, да, значит замечание
[32:06.700 --> 32:11.700]  значит если потребовать
[32:11.700 --> 32:15.700]  ну, точнее, если спрашивать
[32:15.700 --> 32:31.700]  о кратчайшей, значит, о том имеет ли кратчайшее эквивалентное dnf длину k
[32:31.700 --> 32:38.700]  то получится задача оптимизации
[32:38.700 --> 32:46.700]  но она уже будет не из dp, а наоборот на этаж выше
[32:46.700 --> 32:56.700]  будет sigma3 полиномиальная пересечь с pi3 полиномиальная
[32:56.700 --> 33:02.700]  да, потому что опять же тут как бы нужно рассмотреть разность
[33:02.700 --> 33:09.700]  разности вот такого языка для k и такого же для k-1
[33:09.700 --> 33:12.700]  вот, ну а соответственно
[33:15.700 --> 33:18.700]  аналогично, кстати, это можно будет чуть-чуть попозже обсудить
[33:18.700 --> 33:25.700]  как в принципе теоретико-множительные операции влияют на уровень в иерархии
[33:25.700 --> 33:30.700]  да, хорошо, значит, ну вот это вот первый пример
[33:31.700 --> 33:32.700]  а можно вопрос?
[33:32.700 --> 33:33.700]  да
[33:33.700 --> 33:39.700]  мы вот тут пишем какие-то условия для psi и x
[33:39.700 --> 33:44.700]  правда же вы не могли написать в скобках
[33:44.700 --> 33:48.700]  что у psi на любом наборе так же как phi
[33:48.700 --> 33:54.700]  то есть не используя x, потому что тогда бы это потребовало не полиномиальной проверки
[33:54.700 --> 33:56.700]  ну конечно, да, конечно
[33:56.700 --> 34:01.700]  мы могли бы не писать этот квантор, но тогда бы потеряли полиномиальность
[34:08.700 --> 34:12.700]  вот, то есть тут в принципе когда стоит задача о классификации
[34:12.700 --> 34:16.700]  то надо понимать, да, вот этот ваш квантор, он действительно нужен
[34:16.700 --> 34:19.700]  и нам просто так удобно записать, а на самом деле можно без него
[34:19.700 --> 34:24.700]  то есть, например, если какой-то полиномиальный перебор, то там может возникать квантор
[34:24.700 --> 34:29.700]  но поскольку перегорка полиномиальной, то можно его перебрать
[34:29.700 --> 34:34.700]  но здесь экспоненциальный перебор получается, да, потому что экспоненциально много разных наборов
[34:38.700 --> 34:39.700]  так
[34:48.700 --> 34:49.700]  хорошо
[34:54.700 --> 34:58.700]  значит теперь можно
[34:58.700 --> 35:01.700]  значит другой пример
[35:01.700 --> 35:04.700]  значит другой пример, задача
[35:04.700 --> 35:08.700]  по ram.save-ости
[35:12.700 --> 35:14.700]  оооо
[35:14.700 --> 35:16.700]  ооо
[35:16.700 --> 35:18.700]  ооо
[35:18.700 --> 35:20.700]  ооо
[35:20.700 --> 35:22.700]  ооо
[35:22.700 --> 35:24.700]  ооо
[35:24.700 --> 35:26.700]  ооо
[35:26.700 --> 35:28.700]  ооо
[35:28.700 --> 35:30.700]  ооо
[35:30.700 --> 35:32.700]  ну, не знаю, там
[35:32.700 --> 35:34.700]  об
[35:34.700 --> 35:36.700]  об
[35:36.700 --> 35:41.700]  я так напишу, об обобщенной ram.save-ости графа
[35:41.700 --> 35:44.700]  значит, что имеется ввиду
[35:44.700 --> 35:49.700]  значит, вообще вы, наверное, изучали, да, Андрей Михайлович рассказывал про тюрем ram.save
[35:49.700 --> 35:51.700]  про числа ram.save
[35:51.700 --> 35:53.700]  да, и обычно там
[35:53.700 --> 35:56.700]  тюрем такая, да, что
[35:56.700 --> 35:58.700]  ну, для любых двух чисел
[35:58.700 --> 36:00.700]  найдется
[36:00.700 --> 36:03.700]  ну, для любых двух чисел
[36:03.700 --> 36:05.700]  и достаточно
[36:05.700 --> 36:07.700]  большого числа
[36:07.700 --> 36:09.700]  вершин
[36:09.700 --> 36:12.700]  да, и любого графа найдется либо там s
[36:12.700 --> 36:16.700]  вершин по парносоединенных ребрами, либо t вершин по парносоединенных ребрами
[36:16.700 --> 36:20.700]  да, вот это классическое тюрем ram.save
[36:20.700 --> 36:22.700]  как бы это тюрем в полном графе
[36:22.700 --> 36:24.700]  да, а может быть тюрема
[36:24.700 --> 36:29.700]  ну, или не тюрема, а там задача у ram.save-ости частичного графа
[36:29.700 --> 36:33.700]  да, то есть, например, у нас есть не полный граф, а какой-то граф
[36:33.700 --> 36:38.700]  и он, и вот его только ребра раскрашены в два цвета
[36:38.700 --> 36:42.700]  и тогда, соответственно, нужно
[36:42.700 --> 36:44.700]  да, значит, вопрос
[36:44.700 --> 36:48.700]  есть ли там полный граф на s вершинах одного цвета
[36:48.700 --> 36:52.700]  или есть полный граф на t вершины другого цвета
[36:57.700 --> 36:59.700]  а может быть еще больше обобщения
[36:59.700 --> 37:02.700]  когда мы ищем не полный под граф
[37:02.700 --> 37:05.700]  а вообще какой-нибудь
[37:06.700 --> 37:09.700]  и вот это тут и спрашивается
[37:09.700 --> 37:11.700]  да, значит, соответственно, тут
[37:12.700 --> 37:14.700]  значит, задан граф
[37:16.700 --> 37:20.700]  в общем, заданы три графа
[37:22.700 --> 37:25.700]  f, g и h
[37:29.700 --> 37:31.700]  и, соответственно, вопрос
[37:31.700 --> 37:33.700]  да, значит, вопрос
[37:34.700 --> 37:40.700]  верно ли, что для любой раскраски
[37:41.700 --> 37:48.700]  ребер графа f в два цвета
[37:49.700 --> 37:56.700]  найдется либо под граф первого цвета
[37:58.700 --> 38:00.700]  изоморфный g
[38:02.700 --> 38:08.700]  либо под граф второго цвета
[38:11.700 --> 38:16.700]  изоморфный h
[38:20.700 --> 38:22.700]  вот
[38:32.700 --> 38:35.700]  вот, значит, вот такая у нас задача
[38:35.700 --> 38:38.700]  вот, это можно сформулировать
[38:38.700 --> 38:40.700]  да, то есть это можно сформулировать
[38:40.700 --> 38:42.700]  как некоторый язык рэмси
[38:44.700 --> 38:46.700]  тут, соответственно, есть тройки
[38:46.700 --> 38:50.700]  значит, тройки f, g, h
[38:51.700 --> 38:53.700]  значит, такие, что
[38:53.700 --> 38:57.700]  существует некоторая функция раскраски
[38:57.700 --> 39:00.700]  из ребер графа f
[39:00.700 --> 39:04.700]  так, а, кстати, тоже sigma, что ли, получится
[39:04.700 --> 39:08.700]  а, не, для любой, да, значит, для любой
[39:09.700 --> 39:11.700]  вот, правильно все
[39:11.700 --> 39:16.700]  для любой раскраски ребер графа f
[39:16.700 --> 39:20.700]  в два цвета, значит, в 1, 2
[39:21.700 --> 39:25.700]  существует такой под граф
[39:25.700 --> 39:27.700]  ну, я не пишу как подношество, да, значит, под граф
[39:28.700 --> 39:30.700]  под граф f
[39:31.700 --> 39:33.700]  вот, такой, что либо
[39:37.700 --> 39:39.700]  значит, либо k
[39:43.700 --> 39:45.700]  изоморфин g
[39:47.700 --> 39:49.700]  либо
[39:49.700 --> 39:51.700]  изоморфин g
[39:52.700 --> 39:54.700]  изоморфин g
[39:55.700 --> 39:59.700]  и раскраска
[40:00.700 --> 40:02.700]  на нем
[40:03.700 --> 40:06.700]  тождественно равна единице
[40:13.700 --> 40:16.700]  так, дать, я тут логическую операцию напишу
[40:16.700 --> 40:18.700]  и
[40:19.700 --> 40:23.700]  или, соответственно, k
[40:24.700 --> 40:26.700]  изоморфин h
[40:28.700 --> 40:32.700]  и раскраска на нем
[40:36.700 --> 40:38.700]  тождественно, на двойке
[40:39.700 --> 40:42.700]  вот, ну, вообще, я надеюсь, что обозначение понятное
[40:42.700 --> 40:45.700]  да, значит, но главное получается, что это
[40:46.700 --> 40:50.700]  значит, язык из p2 получается
[40:50.700 --> 40:52.700]  язык из
[40:53.700 --> 40:55.700]  p2 полюмянь
[40:56.700 --> 40:59.700]  вопрос, да, значит, можно ли вот для этого графа
[40:59.700 --> 41:02.700]  проверить вот такое обобщенное рамсаевское свойство
[41:07.700 --> 41:10.700]  значит, что для любой раскраски найдется такой
[41:10.700 --> 41:12.700]  или такой
[41:16.700 --> 41:18.700]  ну, и как бы вот это обобщение
[41:19.700 --> 41:21.700]  значит, вот это обобщение
[41:24.700 --> 41:26.700]  нам позволяет избежать
[41:27.700 --> 41:30.700]  разного рода оговорок
[41:30.700 --> 41:32.700]  значит, типа того, что если
[41:34.700 --> 41:37.700]  ну, мы же там, например, знаем, как числа рамсаева растут
[41:37.700 --> 41:39.700]  да, они растут экспоненциально
[41:39.700 --> 41:43.700]  вот, поэтому если мы просто рамсаевость будем проверять там для такого-то числа
[41:45.700 --> 41:48.700]  да, там для полного графа, особенно если он прям явно написан
[41:48.700 --> 41:50.700]  то это будет какая-то не очень сложная задача
[41:52.700 --> 41:54.700]  ну, то есть как не сложная
[41:56.700 --> 41:59.700]  нет, в смысле, она будет сложная, но она будет из CoINP
[41:59.700 --> 42:02.700]  да, потому что раскрасок будет очень много
[42:02.700 --> 42:04.700]  но если раскраска есть
[42:05.700 --> 42:08.700]  то за счет вот этих вот симпатических оценок
[42:08.700 --> 42:10.700]  можно получать, что
[42:10.700 --> 42:12.700]  может только маленький может проверять
[42:12.700 --> 42:15.700]  вот, а вот здесь это уже заведомо им именно P2 получается
[42:21.700 --> 42:23.700]  так
[42:28.700 --> 42:30.700]  хорошо
[42:30.700 --> 42:32.700]  значит, теперь
[42:34.700 --> 42:36.700]  может, какие-нибудь вопросы есть?
[42:36.700 --> 42:38.700]  по предыдущему
[42:38.700 --> 42:42.700]  а, сейчас здесь, заметьте, что здесь уже вроде нет никакого параметра оптимизации
[42:42.700 --> 42:44.700]  поэтому ничего такого не получится
[42:47.700 --> 42:49.700]  так, третий вопрос
[42:49.700 --> 42:52.700]  еще вопрос про граф и раскраски
[42:52.700 --> 42:55.700]  задача о кликовой раскраске
[42:59.700 --> 43:02.700]  тоже интересная постановка
[43:03.700 --> 43:05.700]  да, вполне интересная постановка
[43:05.700 --> 43:09.700]  ну, я думаю, что тут, в принципе, можно что-нибудь поизучать, если кому интересно
[43:10.700 --> 43:12.700]  значит, это задача кликовой раскраски
[43:12.700 --> 43:14.700]  что вообще мы называем кликовой раскраской?
[43:15.700 --> 43:18.700]  значит, кликовой раскраской
[43:19.700 --> 43:25.700]  называется такая раскраска вершин графа
[43:27.700 --> 43:29.700]  значит, что
[43:30.700 --> 43:33.700]  любая раскраска
[43:33.700 --> 43:37.700]  любая максимальная
[43:38.700 --> 43:40.700]  в смысле, не увеличиваемая
[43:41.700 --> 43:43.700]  то есть, не увеличиваемая
[43:44.700 --> 43:46.700]  клика
[43:47.700 --> 43:49.700]  ну, не покрашена в один тот же цвет
[43:50.700 --> 43:52.700]  да, значит, содержит вершины
[43:55.700 --> 43:57.700]  хотя бы двух цветов
[44:04.700 --> 44:06.700]  вот
[44:10.700 --> 44:12.700]  ну и тогда, например
[44:15.700 --> 44:17.700]  да, значит, ясно, что
[44:17.700 --> 44:19.700]  обычная правильная раскраска
[44:20.700 --> 44:22.700]  обычная правильная раскраска
[44:24.700 --> 44:26.700]  является кликовой
[44:26.700 --> 44:28.700]  кликовой
[44:32.700 --> 44:34.700]  да, значит, но
[44:37.700 --> 44:39.700]  не наоборот
[44:40.700 --> 44:43.700]  не в случае, когда граф не пустой
[44:46.700 --> 44:49.700]  не, ну не только для сущности, когда граф не пустой
[44:50.700 --> 44:53.700]  в общем случае, наоборот, не ясно
[44:54.700 --> 44:56.700]  не в том плане, что
[44:57.700 --> 44:59.700]  это ампликация, которая верна, а верна есть
[44:59.700 --> 45:01.700]  если у нас в графе есть ребра
[45:05.700 --> 45:07.700]  а, в смысле, я понял
[45:07.700 --> 45:09.700]  что вы произолерные
[45:10.700 --> 45:13.700]  да, что вообще, если у нас есть изолерные вершины, то там
[45:16.700 --> 45:18.700]  ну, в общем-то, философский вопрос
[45:18.700 --> 45:20.700]  считать изолерную вершину кликой
[45:20.700 --> 45:22.700]  вообще, видимо, все-таки надо считать
[45:24.700 --> 45:26.700]  ну, дайте этот допись как исключение
[45:27.700 --> 45:29.700]  значит, исключение
[45:31.700 --> 45:33.700]  изолированной вершины
[45:34.700 --> 45:36.700]  тогда все-таки это будет верно
[45:37.700 --> 45:40.700]  да, значит, что изолерную вершину можно в любой цвет красить
[45:42.700 --> 45:45.700]  вот, в общем, давайте я покажу пример
[45:46.700 --> 45:48.700]  да, значит, пример
[45:48.700 --> 45:50.700]  пример, да
[45:50.700 --> 45:52.700]  граф
[45:52.700 --> 45:54.700]  это граф такой, такое колесо
[45:55.700 --> 45:57.700]  да, есть
[45:58.700 --> 46:00.700]  пятиугольное колесо, в общем
[46:01.700 --> 46:03.700]  значит, есть центральная
[46:04.700 --> 46:06.700]  вершина
[46:06.700 --> 46:08.700]  и есть пять по циклу
[46:08.700 --> 46:10.700]  вот, ну и, соответственно, нужно соединить
[46:11.700 --> 46:13.700]  вот так вот
[46:18.700 --> 46:20.700]  вот, значит, тогда понятно, что здесь
[46:22.700 --> 46:24.700]  в обычном смысле
[46:24.700 --> 46:26.700]  в два цвета его нельзя раскрасить
[46:26.700 --> 46:28.700]  да, потому что вот эти три, треугольник и пятиугольник
[46:30.700 --> 46:32.700]  вот
[46:32.700 --> 46:34.700]  но, тем не менее, можно его раскрасить
[46:36.700 --> 46:38.700]  в два цвета кликова
[46:38.700 --> 46:40.700]  да, значит, это именно нужно
[46:40.700 --> 46:42.700]  например, центр покрасить синий
[46:44.700 --> 46:46.700]  да, например, центр покрасить синий
[46:48.700 --> 46:50.700]  а дальше иметь
[46:52.700 --> 46:54.700]  два подряд
[46:56.700 --> 46:58.700]  так, и дальше, соответственно, чередовать
[47:00.700 --> 47:02.700]  здесь, смотрите, никакое ребро не является
[47:02.700 --> 47:04.700]  максимальной кликой
[47:04.700 --> 47:06.700]  да, потому что любое ребро можно
[47:06.700 --> 47:08.700]  строить до треугольника
[47:08.700 --> 47:10.700]  с другой стороны
[47:10.700 --> 47:12.700]  КАТ-4 тут нет вообще
[47:12.700 --> 47:14.700]  поэтому все максимальные клики
[47:14.700 --> 47:16.700]  это треугольники
[47:16.700 --> 47:18.700]  вот, ну и прям видно, да, что здесь есть
[47:18.700 --> 47:20.700]  пять треугольников
[47:20.700 --> 47:22.700]  и в каждом из них хотя бы два цвета
[47:22.700 --> 47:24.700]  вот, соответственно, это вот мы
[47:24.700 --> 47:26.700]  покрасили в два цвета
[47:26.700 --> 47:28.700]  соблюдением правил
[47:28.700 --> 47:30.700]  кликовой раскраски
[47:30.700 --> 47:32.700]  но соблюдением правил обычной раскраски
[47:32.700 --> 47:34.700]  мы так не смогли сделать
[47:36.700 --> 47:38.700]  так, хорошо
[47:42.700 --> 47:44.700]  ну, соответственно, может быть, задача
[47:44.700 --> 47:46.700]  да, обычная задача
[47:46.700 --> 47:48.700]  у кликовой раскраски
[47:50.700 --> 47:52.700]  да, значит, получается так
[47:52.700 --> 47:54.700]  значит
[47:54.700 --> 47:56.700]  да
[47:56.700 --> 47:58.700]  у нас КА-2 является кликой
[48:00.700 --> 48:02.700]  а, что тут
[48:02.700 --> 48:04.700]  я не дочитал
[48:04.700 --> 48:06.700]  извините
[48:06.700 --> 48:08.700]  а, ладно
[48:08.700 --> 48:10.700]  так
[48:10.700 --> 48:12.700]  в общем, задача такая
[48:12.700 --> 48:14.700]  да, это множество
[48:14.700 --> 48:16.700]  пары из графа и числа
[48:18.700 --> 48:20.700]  такое, что
[48:20.700 --> 48:22.700]  соответственно
[48:24.700 --> 48:26.700]  существует
[48:28.700 --> 48:30.700]  кликовая раскраска
[48:32.700 --> 48:34.700]  вершин же
[48:34.700 --> 48:36.700]  вершин же
[48:38.700 --> 48:40.700]  в К цветов
[48:48.700 --> 48:50.700]  вот, и это у нас будет
[48:50.700 --> 48:52.700]  записываться так, да
[48:52.700 --> 48:54.700]  значит, существует
[48:54.700 --> 48:56.700]  такая
[48:56.700 --> 48:58.700]  соответственно, функция
[48:58.700 --> 49:00.700]  знаешь, которая
[49:00.700 --> 49:02.700]  вершины АДЖ
[49:02.700 --> 49:04.700]  отображает
[49:04.700 --> 49:06.700]  множество 1 и так далее
[49:06.700 --> 49:08.700]  К
[49:08.700 --> 49:10.700]  такая, что для любой
[49:10.700 --> 49:12.700]  клики
[49:12.700 --> 49:14.700]  любого С
[49:14.700 --> 49:16.700]  может В
[49:16.700 --> 49:18.700]  если С
[49:18.700 --> 49:20.700]  это не увеличиваемая клика
[49:22.700 --> 49:24.700]  то тогда
[49:26.700 --> 49:28.700]  в С
[49:28.700 --> 49:30.700]  есть разные цвета
[49:32.700 --> 49:34.700]  вот
[49:34.700 --> 49:36.700]  и
[49:36.700 --> 49:38.700]  проблема в том, что
[49:38.700 --> 49:40.700]  вот этот вот хуантер
[49:40.700 --> 49:42.700]  нельзя изничтожить
[49:42.700 --> 49:44.700]  потому что реально
[49:44.700 --> 49:46.700]  неувеличиваемых клик может быть очень много
[49:46.700 --> 49:48.700]  да, это упражнение
[49:48.700 --> 49:50.700]  придумать граф, в котором неувеличиваемых клик
[49:50.700 --> 49:52.700]  будет
[49:52.700 --> 49:54.700]  ну,
[49:54.700 --> 49:56.700]  сверхполиндарное число
[49:56.700 --> 49:58.700]  какая-нибудь экспонента
[49:58.700 --> 50:00.700]  поэтому
[50:00.700 --> 50:02.700]  просто перебрать это всё нельзя
[50:02.700 --> 50:04.700]  значит, если ребра можно все перебрать
[50:04.700 --> 50:06.700]  то все неувеличиваемые клики
[50:06.700 --> 50:08.700]  нельзя все перебрать
[50:08.700 --> 50:10.700]  за пальмельное время
[50:12.700 --> 50:14.700]  вот, а отсюда получается
[50:14.700 --> 50:16.700]  снова
[50:16.700 --> 50:18.700]  Сигма 2
[50:20.700 --> 50:22.700]  вот, значит, ну дальше
[50:22.700 --> 50:24.700]  есть ещё
[50:24.700 --> 50:26.700]  другая задача
[50:26.700 --> 50:28.700]  может быть
[50:28.700 --> 50:30.700]  задача о
[50:30.700 --> 50:32.700]  наследственной
[50:32.700 --> 50:34.700]  кликовой раскраске
[50:36.700 --> 50:38.700]  ну это не раскраска наследственная
[50:38.700 --> 50:40.700]  давайте я напишу
[50:40.700 --> 50:42.700]  раскрашиваемости
[50:44.700 --> 50:46.700]  так, это
[50:48.700 --> 50:50.700]  хредитари
[50:52.700 --> 50:54.700]  клик колоринг
[50:54.700 --> 50:56.700]  тут
[50:56.700 --> 50:58.700]  соответственно
[50:58.700 --> 51:00.700]  можно писать так
[51:00.700 --> 51:02.700]  что это пара из
[51:02.700 --> 51:04.700]  g и k
[51:04.700 --> 51:06.700]  таких, что любой
[51:06.700 --> 51:08.700]  под граф
[51:08.700 --> 51:10.700]  g
[51:10.700 --> 51:12.700]  кликово
[51:12.700 --> 51:14.700]  раскрашивается
[51:14.700 --> 51:16.700]  к цветов
[51:18.700 --> 51:20.700]  в частности, вот этот граф, который здесь
[51:20.700 --> 51:22.700]  нарисован
[51:22.700 --> 51:24.700]  он не является
[51:24.700 --> 51:26.700]  наследственно раскрашиваемого в два цвета
[51:26.700 --> 51:28.700]  потому что если центральную точку убрать
[51:28.700 --> 51:30.700]  то останется цикл из пяти вершин
[51:30.700 --> 51:32.700]  и тогда
[51:32.700 --> 51:34.700]  максимальные клики это будут просто
[51:34.700 --> 51:36.700]  ребра
[51:36.700 --> 51:38.700]  и тогда, конечно, цикл из пяти вершин
[51:38.700 --> 51:40.700]  нельзя покрасить в два цвета
[51:40.700 --> 51:42.700]  может только в три
[51:42.700 --> 51:44.700]  вот, поэтому
[51:44.700 --> 51:46.700]  весь граф раскрашивается в кликовом смысле
[51:46.700 --> 51:48.700]  в два цвета
[51:48.700 --> 51:50.700]  а под граф не раскрашивается
[51:50.700 --> 51:52.700]  а тут мы, соответственно, спрашиваем
[51:52.700 --> 51:54.700]  что не только сам граф, но и любой под граф
[51:54.700 --> 51:56.700]  раскрашивается
[51:58.700 --> 52:00.700]  вот
[52:00.700 --> 52:02.700]  соответственно, ясно
[52:14.700 --> 52:16.700]  значит, ясно, что это может быть более сложная задача
[52:16.700 --> 52:18.700]  но и реально получается так
[52:18.700 --> 52:20.700]  то есть тут получается, что для любого
[52:22.700 --> 52:24.700]  h под граф
[52:26.700 --> 52:28.700]  существует
[52:28.700 --> 52:30.700]  то же самое, что там
[52:30.700 --> 52:32.700]  значит
[52:32.700 --> 52:34.700]  c из вершин
[52:34.700 --> 52:36.700]  граф h
[52:36.700 --> 52:38.700]  в один
[52:38.700 --> 52:40.700]  и так далее
[52:40.700 --> 52:42.700]  да, я хотел еще сказать, что это отличие от обычной раскрашиваемости
[52:42.700 --> 52:44.700]  что если у нас
[52:44.700 --> 52:46.700]  граф в обычном смысле раскрашился в к цветов
[52:46.700 --> 52:48.700]  то и любой под граф тоже в конце цветов
[52:48.700 --> 52:50.700]  раскрасятся
[52:50.700 --> 52:52.700]  а здесь получается, что граф раскрасился
[52:52.700 --> 52:54.700]  кликово, а под граф не красится
[52:54.700 --> 52:56.700]  соответственно, это дальше
[53:00.700 --> 53:02.700]  для любого s
[53:04.700 --> 53:06.700]  под множество v от h
[53:06.700 --> 53:08.700]  а здесь получается
[53:08.700 --> 53:10.700]  то же самое, что было
[53:10.700 --> 53:12.700]  вот
[53:14.700 --> 53:16.700]  соответственно, это получается
[53:16.700 --> 53:18.700]  p
[53:18.700 --> 53:20.700]  3
[53:20.700 --> 53:22.700]  пальномиальная
[53:24.700 --> 53:26.700]  а если мы прям еще
[53:26.700 --> 53:28.700]  ищем
[53:28.700 --> 53:30.700]  где может четвертый уровень
[53:30.700 --> 53:32.700]  возникнуть
[53:32.700 --> 53:34.700]  значит, если искать
[53:34.700 --> 53:36.700]  точное значение
[53:36.700 --> 53:38.700]  наследственного
[53:38.700 --> 53:40.700]  кликового
[53:42.700 --> 53:44.700]  хроматического числа
[53:44.700 --> 53:46.700]  потом понятно, что
[53:46.700 --> 53:48.700]  это имеется в виду
[53:48.700 --> 53:50.700]  да, то есть
[53:50.700 --> 53:52.700]  минимальное число цветов
[53:52.700 --> 53:54.700]  в которые любой под граф можно кликово раскрасить
[53:56.700 --> 53:58.700]  вот, то получится
[54:00.700 --> 54:02.700]  задача из
[54:04.700 --> 54:06.700]  p4
[54:06.700 --> 54:08.700]  пальномиальная в пересечение
[54:08.700 --> 54:10.700]  σ4
[54:10.700 --> 54:12.700]  пальномиальная
[54:18.700 --> 54:20.700]  то есть до четвертого уровня
[54:20.700 --> 54:22.700]  иногда все-таки как-то достреливает
[54:22.700 --> 54:24.700]  такие содержательные задача
[54:26.700 --> 54:28.700]  вот, ну и еще последний пример хочу привести
[54:30.700 --> 54:32.700]  значит, последний пример
[54:32.700 --> 54:34.700]  это
[54:34.700 --> 54:36.700]  тоже, я думаю, вам знакомый сюжет
[54:36.700 --> 54:38.700]  задача
[54:38.700 --> 54:40.700]  о размерности
[54:40.700 --> 54:42.700]  вапника-червоненкеса
[54:48.700 --> 54:50.700]  изучали ведь такое
[54:50.700 --> 54:52.700]  на вашем новом обучении, да?
[54:52.700 --> 54:54.700]  или что там где-нибудь
[54:54.700 --> 54:56.700]  на дискране
[54:56.700 --> 54:58.700]  на дискране изучали, отлично
[55:00.700 --> 55:02.700]  так
[55:02.700 --> 55:04.700]  хорошо, ну соответственно задача
[55:08.700 --> 55:10.700]  ну, как бы задача ее посчитать
[55:10.700 --> 55:12.700]  есть
[55:12.700 --> 55:14.700]  какой-то набор
[55:14.700 --> 55:16.700]  множеств
[55:16.700 --> 55:18.700]  значит
[55:18.700 --> 55:20.700]  s1 и так далее
[55:20.700 --> 55:22.700]  там sn
[55:26.700 --> 55:28.700]  и нужно
[55:28.700 --> 55:30.700]  там
[55:30.700 --> 55:32.700]  размерность вапника-червоненкеса
[55:32.700 --> 55:34.700]  да, от этого самого
[55:34.700 --> 55:36.700]  s
[55:44.700 --> 55:46.700]  больше либо ровно чем k
[55:48.700 --> 55:50.700]  ну или ровно k, но ровно k это будет опять же оптимизация
[55:52.700 --> 55:54.700]  да, больше либо ровно k это
[55:54.700 --> 55:56.700]  какая-то задача
[55:58.700 --> 56:00.700]  такая обычная
[56:04.700 --> 56:06.700]  вот, значит, ну тут стоит вопрос
[56:06.700 --> 56:08.700]  значит, давайте вспомним, что это такое
[56:12.700 --> 56:14.700]  напоминание
[56:16.700 --> 56:18.700]  что вот эта самая размерность
[56:22.700 --> 56:24.700]  это максимальное число элементов
[56:24.700 --> 56:26.700]  в x
[56:28.700 --> 56:30.700]  да, о таком, что
[56:30.700 --> 56:32.700]  среди
[56:34.700 --> 56:36.700]  пересечений s и t, x
[56:38.700 --> 56:40.700]  и x есть все подножства
[56:40.700 --> 56:42.700]  x
[56:46.700 --> 56:48.700]  вот, значит, на самом деле
[56:48.700 --> 56:50.700]  сложная такая задача
[56:50.700 --> 56:52.700]  существенно зависит от того, как именно
[56:52.700 --> 56:54.700]  записана
[56:54.700 --> 56:56.700]  вот эта система
[56:56.700 --> 56:58.700]  значит, если она
[56:58.700 --> 57:00.700]  в явном виде записана, то
[57:00.700 --> 57:02.700]  это будет более простая задача
[57:06.700 --> 57:08.700]  значит, тут предполагаем
[57:10.700 --> 57:12.700]  что система
[57:12.700 --> 57:14.700]  s
[57:14.700 --> 57:16.700]  записана
[57:16.700 --> 57:18.700]  в сжатом виде
[57:18.700 --> 57:20.700]  значит
[57:20.700 --> 57:22.700]  например
[57:22.700 --> 57:24.700]  есть
[57:24.700 --> 57:26.700]  какая-то логическая схема
[57:28.700 --> 57:30.700]  phi
[57:30.700 --> 57:32.700]  значит, которая
[57:32.700 --> 57:34.700]  по индексу
[57:36.700 --> 57:38.700]  по индексу
[57:40.700 --> 57:42.700]  и
[57:42.700 --> 57:44.700]  элементу
[57:44.700 --> 57:46.700]  x сообщает
[57:46.700 --> 57:48.700]  лежит ли
[57:48.700 --> 57:50.700]  x в s и t
[57:54.700 --> 57:56.700]  вот, ну, про логические схемы
[57:56.700 --> 57:58.700]  мы еще поговорим подробнее
[57:58.700 --> 58:00.700]  ну, в общем, это что-то типа логических формул
[58:00.700 --> 58:02.700]  но там можно
[58:02.700 --> 58:04.700]  переиспользовать платформулы, например
[58:06.700 --> 58:08.700]  да, в общем, мы про это поговорим подробнее
[58:08.700 --> 58:10.700]  если вы там не знаете
[58:10.700 --> 58:12.700]  то можно просто представить, что есть какое-то
[58:12.700 --> 58:14.700]  короткое описание
[58:14.700 --> 58:16.700]  такое, что
[58:16.700 --> 58:18.700]  в общем, у i есть
[58:18.700 --> 58:20.700]  некоторая длина
[58:22.700 --> 58:24.700]  и это будет логарифм n
[58:24.700 --> 58:26.700]  да, то есть тогда можно
[58:26.700 --> 58:28.700]  считать
[58:28.700 --> 58:30.700]  тут я n большое сделаю
[58:30.700 --> 58:32.700]  да, есть такое соглашение
[58:32.700 --> 58:34.700]  что n маленькое – это логарифм от n большого
[58:36.700 --> 58:38.700]  вот, соответственно
[58:40.700 --> 58:42.700]  может быть так
[58:44.700 --> 58:46.700]  что
[58:46.700 --> 58:48.700]  n
[58:48.700 --> 58:50.700]  будет
[58:50.700 --> 58:52.700]  экспонента от n малого
[58:52.700 --> 58:54.700]  да, а
[58:54.700 --> 58:56.700]  размер phi
[58:56.700 --> 58:58.700]  это
[58:58.700 --> 59:00.700]  полинов от n малого
[59:02.700 --> 59:04.700]  вот, ну, то есть
[59:04.700 --> 59:06.700]  то есть
[59:06.700 --> 59:08.700]  экспоненциальное
[59:08.700 --> 59:10.700]  семейство множеств
[59:10.700 --> 59:12.700]  задано полиновиальным
[59:14.700 --> 59:16.700]  описанием
[59:18.700 --> 59:20.700]  вот, ну и тогда
[59:20.700 --> 59:22.700]  будет такая формула
[59:22.700 --> 59:24.700]  тогда формула
[59:24.700 --> 59:26.700]  будет такой
[59:32.700 --> 59:34.700]  существует
[59:34.700 --> 59:36.700]  x большое
[59:36.700 --> 59:38.700]  что для любого
[59:38.700 --> 59:40.700]  t
[59:42.700 --> 59:44.700]  под множество
[59:44.700 --> 59:46.700]  x большое
[59:46.700 --> 59:48.700]  существует
[59:48.700 --> 59:50.700]  и
[59:50.700 --> 59:52.700]  ну, такой, что
[59:52.700 --> 59:54.700]  соответственно
[59:54.700 --> 59:56.700]  s и t
[59:56.700 --> 59:58.700]  в пересечении с x
[59:58.700 --> 01:00:00.700]  равняется t
[01:00:04.700 --> 01:00:06.700]  вот, ну, то есть это
[01:00:06.700 --> 01:00:08.700]  то есть форма будет
[01:00:08.700 --> 01:00:10.700]  sigma 3
[01:00:10.700 --> 01:00:12.700]  sigma 3 полинумеральная
[01:00:12.700 --> 01:00:14.700]  вот, и действительно тут
[01:00:14.700 --> 01:00:16.700]  ничего сократить нельзя
[01:00:16.700 --> 01:00:18.700]  потому что если вот это множество
[01:00:18.700 --> 01:00:20.700]  экспоненциально большое
[01:00:20.700 --> 01:00:22.700]  то тогда и вот это вот
[01:00:22.700 --> 01:00:24.700]  и нельзя
[01:00:24.700 --> 01:00:26.700]  перебором найти
[01:00:26.700 --> 01:00:28.700]  и тогда и под множество x может быть
[01:00:28.700 --> 01:00:30.700]  экспоненциально много
[01:00:30.700 --> 01:00:32.700]  ну, и самих x тем более экспоненциально много
[01:00:32.700 --> 01:00:34.700]  поэтому ни один из этих кванторов
[01:00:34.700 --> 01:00:36.700]  поэтому ни один из этих кванторов сократить нельзя
[01:00:38.700 --> 01:00:40.700]  если нет вот такого вот сжатого описания
[01:00:40.700 --> 01:00:42.700]  да, то есть
[01:00:42.700 --> 01:00:44.700]  вот это n большое там
[01:00:44.700 --> 01:00:46.700]  само полинумеральное, тогда, например
[01:00:46.700 --> 01:00:48.700]  ну, все под множество здесь можно перебирать
[01:00:48.700 --> 01:00:50.700]  и это будет не больше, чем np
[01:00:52.700 --> 01:00:54.700]  то есть sigma 3 получилось именно вот для такой
[01:00:54.700 --> 01:00:56.700]  сжатой записи
[01:00:56.700 --> 01:00:58.700]  вот, ну а как обычно
[01:00:58.700 --> 01:01:00.700]  точно задача оптимизации будет
[01:01:00.700 --> 01:01:02.700]  p4 и sigma 4
[01:01:02.700 --> 01:01:04.700]  да, то есть всегда задача оптимизации
[01:01:04.700 --> 01:01:06.700]  на этаж выше, чем
[01:01:06.700 --> 01:01:08.700]  вопрос для конкретного
[01:01:08.700 --> 01:01:10.700]  числа
[01:01:12.700 --> 01:01:14.700]  наверное стоит добавить, что мощность
[01:01:14.700 --> 01:01:16.700]  x больше или равна k
[01:01:16.700 --> 01:01:18.700]  а, надо, конечно, да
[01:01:20.700 --> 01:01:22.700]  ну ладно, да, в общем, давайте сюда
[01:01:22.700 --> 01:01:24.700]  давай прямо внутрь
[01:01:24.700 --> 01:01:26.700]  а
[01:01:28.700 --> 01:01:30.700]  да, можно было
[01:01:30.700 --> 01:01:32.700]  добавить сюда, но
[01:01:32.700 --> 01:01:34.700]  в общем, мы знаем, что это можно вынести
[01:01:34.700 --> 01:01:36.700]  наружу этих кванторов
[01:01:44.700 --> 01:01:46.700]  вот
[01:01:54.700 --> 01:01:56.700]  так, хорошо
[01:02:00.700 --> 01:02:02.700]  так, значит, вот такие вот примеры
[01:02:06.700 --> 01:02:08.700]  ну, теперь
[01:02:10.700 --> 01:02:12.700]  возникает вопрос
[01:02:12.700 --> 01:02:14.700]  насколько это все
[01:02:24.700 --> 01:02:26.700]  так
[01:02:26.700 --> 01:02:28.700]  что возникает вопрос
[01:02:28.700 --> 01:02:30.700]  вот какой, да, значит, тут у нас вот здесь
[01:02:30.700 --> 01:02:32.700]  иерархия
[01:02:32.700 --> 01:02:34.700]  а насколько она все-таки вот на самом деле
[01:02:34.700 --> 01:02:36.700]  такая иерархия
[01:02:36.700 --> 01:02:38.700]  да, не может ли быть так, что
[01:02:38.700 --> 01:02:40.700]  это мы тут что-то придумали, оно все
[01:02:40.700 --> 01:02:42.700]  на самом деле одинаковое, да, или что-нибудь еще
[01:02:42.700 --> 01:02:44.700]  да, в принципе, это каждый из этих задач
[01:02:46.700 --> 01:02:48.700]  но пока никто
[01:02:48.700 --> 01:02:50.700]  не придумал
[01:02:50.700 --> 01:02:52.700]  что-то чего-то более простого
[01:02:52.700 --> 01:02:54.700]  вот, но может это просто
[01:02:54.700 --> 01:02:56.700]  мы не смогли придумать, да
[01:02:56.700 --> 01:02:58.700]  на самом деле можно
[01:03:00.700 --> 01:03:02.700]  вот, но оказывается, что все-таки есть
[01:03:02.700 --> 01:03:04.700]  некоторые основания полагать
[01:03:04.700 --> 01:03:06.700]  что
[01:03:06.700 --> 01:03:08.700]  они все разные
[01:03:10.700 --> 01:03:12.700]  давайте начнем с такой теоремы
[01:03:12.700 --> 01:03:14.700]  значит, теоремы
[01:03:14.700 --> 01:03:16.700]  на самом деле, если P равно NP
[01:03:16.700 --> 01:03:18.700]  то P равно PH
[01:03:18.700 --> 01:03:20.700]  это называется
[01:03:20.700 --> 01:03:22.700]  это называется коллапсирование
[01:03:24.700 --> 01:03:26.700]  полинамиальной
[01:03:26.700 --> 01:03:28.700]  иерархии
[01:03:32.700 --> 01:03:34.700]  вот, но как
[01:03:34.700 --> 01:03:36.700]  будем доказывать
[01:03:36.700 --> 01:03:38.700]  ну, смотрите там, первое
[01:03:38.700 --> 01:03:40.700]  первое, если P равно NP
[01:03:42.700 --> 01:03:44.700]  то тогда P равно
[01:03:44.700 --> 01:03:46.700]  ICO NP
[01:03:50.700 --> 01:03:52.700]  ну, действительно
[01:03:52.700 --> 01:03:54.700]  значит, если
[01:03:54.700 --> 01:03:56.700]  B лежит
[01:03:56.700 --> 01:03:58.700]  в CoNP
[01:03:58.700 --> 01:04:00.700]  то из этого следует, что
[01:04:02.700 --> 01:04:04.700]  B с чертой
[01:04:04.700 --> 01:04:06.700]  лежит в NP
[01:04:10.700 --> 01:04:12.700]  из этого следует, что
[01:04:12.700 --> 01:04:14.700]  B с чертой лежит в P
[01:04:14.700 --> 01:04:16.700]  если мы предположим, что P равно NP
[01:04:16.700 --> 01:04:18.700]  так, сейчас давайте это
[01:04:18.700 --> 01:04:20.700]  отделю, значит, доказательства
[01:04:22.700 --> 01:04:24.700]  вот, ну а из этого следует,
[01:04:24.700 --> 01:04:26.700]  что и B лежит в P
[01:04:30.700 --> 01:04:32.700]  потому что P за кто-то тинет
[01:04:32.700 --> 01:04:34.700]  дополнение
[01:04:36.700 --> 01:04:38.700]  так, ну хорошо
[01:04:38.700 --> 01:04:40.700]  теперь давайте
[01:04:42.700 --> 01:04:44.700]  так, напишем
[01:04:44.700 --> 01:04:46.700]  что если P равно CoNP
[01:04:48.700 --> 01:04:50.700]  то тогда, например
[01:04:50.700 --> 01:04:52.700]  sigma 2
[01:04:52.700 --> 01:04:54.700]  полинамиальная
[01:04:54.700 --> 01:04:56.700]  sigma 2
[01:04:56.700 --> 01:04:58.700]  полинамиальная
[01:04:58.700 --> 01:05:00.700]  софе просто с NP
[01:05:02.700 --> 01:05:04.700]  так, ну тут, смотрите
[01:05:04.700 --> 01:05:06.700]  значит у нас
[01:05:06.700 --> 01:05:08.700]  там A
[01:05:08.700 --> 01:05:10.700]  лежит, например
[01:05:10.700 --> 01:05:12.700]  sigma 2
[01:05:12.700 --> 01:05:14.700]  лежит, например, sigma 2
[01:05:14.700 --> 01:05:16.700]  полинамиальная
[01:05:20.700 --> 01:05:22.700]  вот, соответственно
[01:05:22.700 --> 01:05:24.700]  у нас случается, что
[01:05:24.700 --> 01:05:26.700]  X лежит в A
[01:05:26.700 --> 01:05:28.700]  тогда и только тогда
[01:05:28.700 --> 01:05:30.700]  когда существует Y
[01:05:30.700 --> 01:05:32.700]  для любого Z
[01:05:32.700 --> 01:05:34.700]  V от
[01:05:34.700 --> 01:05:36.700]  X, Y, Z
[01:05:36.700 --> 01:05:38.700]  вот
[01:05:40.700 --> 01:05:42.700]  но теперь можно рассмотреть
[01:05:42.700 --> 01:05:44.700]  такое множество
[01:05:44.700 --> 01:05:46.700]  множество пар
[01:05:46.700 --> 01:05:48.700]  X, Y
[01:05:48.700 --> 01:05:50.700]  таких, что
[01:05:50.700 --> 01:05:52.700]  для любого Z
[01:05:54.700 --> 01:05:56.700]  V от X, Y, Z
[01:05:56.700 --> 01:05:58.700]  равно 1
[01:05:58.700 --> 01:06:00.700]  что Z лежит в CoNP
[01:06:00.700 --> 01:06:02.700]  значит
[01:06:02.700 --> 01:06:04.700]  этого следует, что
[01:06:04.700 --> 01:06:06.700]  лежит в P
[01:06:14.700 --> 01:06:16.700]  вот
[01:06:20.700 --> 01:06:22.700]  ну а тогда получается, что
[01:06:22.700 --> 01:06:24.700]  X лежит в A
[01:06:24.700 --> 01:06:26.700]  равносильно
[01:06:26.700 --> 01:06:28.700]  равносильно
[01:06:32.700 --> 01:06:34.700]  в существовании Y
[01:06:34.700 --> 01:06:36.700]  ну а дальше
[01:06:36.700 --> 01:06:38.700]  как получается вот это вот
[01:06:40.700 --> 01:06:42.700]  где вот эта штука уже
[01:06:42.700 --> 01:06:44.700]  лежит в P
[01:06:46.700 --> 01:06:48.700]  значит тут
[01:06:48.700 --> 01:06:50.700]  условия
[01:06:50.700 --> 01:06:52.700]  в скобках
[01:06:52.700 --> 01:06:54.700]  лежит в P
[01:06:56.700 --> 01:06:58.700]  так что все вместе
[01:07:00.700 --> 01:07:02.700]  лежит в NP
[01:07:04.700 --> 01:07:06.700]  ну а соответственно
[01:07:08.700 --> 01:07:10.700]  дальше получается по транзитивности
[01:07:12.700 --> 01:07:14.700]  по силогизму
[01:07:14.700 --> 01:07:16.700]  если P равно NP
[01:07:18.700 --> 01:07:20.700]  то тогда получается, что
[01:07:22.700 --> 01:07:24.700]  sigma 2 полинамиальная
[01:07:24.700 --> 01:07:26.700]  равно P
[01:07:28.700 --> 01:07:30.700]  ну и так далее, значит далее аналогично
[01:07:32.700 --> 01:07:34.700]  да, то есть если P равно NP
[01:07:34.700 --> 01:07:36.700]  то последний квантор мы можем вот так
[01:07:36.700 --> 01:07:38.700]  схлопывать
[01:07:38.700 --> 01:07:40.700]  и спускаться на этаж ниже
[01:07:40.700 --> 01:07:42.700]  а дальше еще один схлопывать, еще один и так далее
[01:07:46.700 --> 01:07:48.700]  вот
[01:07:50.700 --> 01:07:52.700]  но это вот такой
[01:07:52.700 --> 01:07:54.700]  такой
[01:07:54.700 --> 01:07:56.700]  жесткий пример
[01:07:56.700 --> 01:07:58.700]  коллапсирования
[01:07:58.700 --> 01:08:00.700]  ну а дальше конечно
[01:08:00.700 --> 01:08:02.700]  после того, как мы доказали, что все уровни
[01:08:02.700 --> 01:08:04.700]  совпадают с P
[01:08:04.700 --> 01:08:06.700]  то pH тоже совпадает с P
[01:08:06.700 --> 01:08:08.700]  то есть тут
[01:08:08.700 --> 01:08:10.700]  значит в итоге
[01:08:10.700 --> 01:08:12.700]  раз все уровни
[01:08:12.700 --> 01:08:14.700]  равны P
[01:08:16.700 --> 01:08:18.700]  то и pH равно P
[01:08:18.700 --> 01:08:20.700]  как объединение
[01:08:22.700 --> 01:08:24.700]  так
[01:08:24.700 --> 01:08:26.700]  ну и дальше есть общая теорема
[01:08:28.700 --> 01:08:30.700]  общая теорема о коллапсировании
[01:08:34.700 --> 01:08:36.700]  значит
[01:08:36.700 --> 01:08:38.700]  следующее три условия
[01:08:38.700 --> 01:08:40.700]  эквивалентные
[01:08:44.700 --> 01:08:46.700]  так, первое
[01:08:48.700 --> 01:08:50.700]  первое, что две сигмы подряд совпали
[01:08:52.700 --> 01:08:54.700]  sigma kt
[01:08:54.700 --> 01:08:56.700]  polynomial
[01:08:56.700 --> 01:08:58.700]  да, значит равняется
[01:08:58.700 --> 01:09:00.700]  sigma k
[01:09:00.700 --> 01:09:02.700]  плюс первому
[01:09:02.700 --> 01:09:04.700]  polynomial
[01:09:04.700 --> 01:09:06.700]  второе, что
[01:09:06.700 --> 01:09:08.700]  на том же уровне sigma
[01:09:08.700 --> 01:09:10.700]  и P совпали
[01:09:10.700 --> 01:09:12.700]  значит sigma kt
[01:09:12.700 --> 01:09:14.700]  равняется Pk
[01:09:14.700 --> 01:09:16.700]  и третье, что
[01:09:16.700 --> 01:09:18.700]  весь pH
[01:09:18.700 --> 01:09:20.700]  равняется
[01:09:20.700 --> 01:09:22.700]  sigma kt
[01:09:38.700 --> 01:09:40.700]  ну вот получается, что
[01:09:40.700 --> 01:09:42.700]  такие условия
[01:09:42.700 --> 01:09:44.700]  эквивалентные
[01:09:44.700 --> 01:09:46.700]  так, ну у нас еще есть время
[01:09:46.700 --> 01:09:48.700]  доказательства
[01:09:48.700 --> 01:09:50.700]  так
[01:09:52.700 --> 01:09:54.700]  ну это конечно
[01:09:54.700 --> 01:09:56.700]  да
[01:09:58.700 --> 01:10:00.700]  так, ну вообще значит
[01:10:00.700 --> 01:10:02.700]  на самом деле ясно, вот из третьего, первого
[01:10:02.700 --> 01:10:04.700]  и второго
[01:10:04.700 --> 01:10:06.700]  следует
[01:10:06.700 --> 01:10:08.700]  автоматически
[01:10:08.700 --> 01:10:10.700]  да, потому что смотрите
[01:10:10.700 --> 01:10:12.700]  то
[01:10:14.700 --> 01:10:16.700]  то есть вообще
[01:10:16.700 --> 01:10:18.700]  на самом деле
[01:10:18.700 --> 01:10:20.700]  тут, да, я вот немножко
[01:10:20.700 --> 01:10:22.700]  не поговорил про
[01:10:22.700 --> 01:10:24.700]  все эти множественные свойства
[01:10:24.700 --> 01:10:26.700]  но по крайней мере
[01:10:26.700 --> 01:10:28.700]  мне конечно должно быть ясно следующее
[01:10:28.700 --> 01:10:30.700]  что A лежит
[01:10:32.700 --> 01:10:34.700]  в sigma kt
[01:10:34.700 --> 01:10:36.700]  тогда и только тогда
[01:10:36.700 --> 01:10:38.700]  когда A с чертой
[01:10:38.700 --> 01:10:40.700]  лежит
[01:10:40.700 --> 01:10:42.700]  в Pk
[01:10:42.700 --> 01:10:44.700]  вот
[01:10:44.700 --> 01:10:46.700]  ну потому что если
[01:10:46.700 --> 01:10:48.700]  вот там добавим отрицание
[01:10:48.700 --> 01:10:50.700]  принесенному через всю цепочку
[01:10:50.700 --> 01:10:52.700]  то все кванторы поменяются
[01:10:52.700 --> 01:10:54.700]  вот, поэтому
[01:10:54.700 --> 01:10:56.700]  соответственно
[01:10:56.700 --> 01:10:58.700]  вот здесь вот во втором достаточно
[01:10:58.700 --> 01:11:00.700]  в одну сторону доказывать вложение
[01:11:00.700 --> 01:11:02.700]  вот
[01:11:02.700 --> 01:11:04.700]  ну а тогда соответственно
[01:11:04.700 --> 01:11:06.700]  например Pk вложено в sigma kt
[01:11:06.700 --> 01:11:08.700]  плюс первое
[01:11:08.700 --> 01:11:10.700]  sigma kt плюс первое в силу вот этого
[01:11:12.700 --> 01:11:14.700]  вот
[01:11:14.700 --> 01:11:16.700]  не так уж просто
[01:11:16.700 --> 01:11:18.700]  не так уж просто
[01:11:18.700 --> 01:11:20.700]  значит вот наверное
[01:11:20.700 --> 01:11:22.700]  из третьего в первое прям очевидно
[01:11:22.700 --> 01:11:24.700]  значит из третьего в первое
[01:11:24.700 --> 01:11:26.700]  очевидно
[01:11:26.700 --> 01:11:28.700]  что слева направо мы уже доказывали
[01:11:28.700 --> 01:11:30.700]  а справа налево
[01:11:30.700 --> 01:11:32.700]  sigma kt плюс первое пленомиальное
[01:11:32.700 --> 01:11:34.700]  вложено
[01:11:34.700 --> 01:11:36.700]  в pH
[01:11:36.700 --> 01:11:38.700]  вложено в
[01:11:38.700 --> 01:11:40.700]  sigma kt
[01:11:40.700 --> 01:11:42.700]  пленомиальное
[01:11:42.700 --> 01:11:44.700]  вот, значит
[01:11:44.700 --> 01:11:46.700]  из третьего в второе
[01:11:48.700 --> 01:11:50.700]  из третьего в второе
[01:11:50.700 --> 01:11:52.700]  тут чуть-чуть сложнее
[01:11:52.700 --> 01:11:54.700]  получается что
[01:11:54.700 --> 01:11:56.700]  Pkt
[01:11:56.700 --> 01:11:58.700]  пленомиальное
[01:11:58.700 --> 01:12:00.700]  вложено
[01:12:00.700 --> 01:12:02.700]  в sigma
[01:12:02.700 --> 01:12:04.700]  kt плюс первое
[01:12:04.700 --> 01:12:06.700]  пленомиальное
[01:12:06.700 --> 01:12:08.700]  это вложено
[01:12:08.700 --> 01:12:10.700]  в pH
[01:12:10.700 --> 01:12:12.700]  и это вложено
[01:12:12.700 --> 01:12:14.700]  в sigma kt
[01:12:14.700 --> 01:12:16.700]  пленомиальное
[01:12:20.700 --> 01:12:22.700]  вот отсюда
[01:12:22.700 --> 01:12:24.700]  ну а дальше за счет
[01:12:24.700 --> 01:12:26.700]  за счет
[01:12:26.700 --> 01:12:28.700]  перехода
[01:12:28.700 --> 01:12:30.700]  к дополнениям
[01:12:32.700 --> 01:12:34.700]  наоборот тоже верно
[01:12:34.700 --> 01:12:36.700]  значит sigma kt
[01:12:36.700 --> 01:12:38.700]  kt пленомиальное
[01:12:40.700 --> 01:12:42.700]  kt пленомиальное
[01:12:44.700 --> 01:12:46.700]  вот, поэтому интересно
[01:12:46.700 --> 01:12:48.700]  в обратную сторону
[01:12:48.700 --> 01:12:50.700]  значит например
[01:12:50.700 --> 01:12:52.700]  из первого третья
[01:12:54.700 --> 01:12:56.700]  значит из первого третья
[01:13:00.700 --> 01:13:02.700]  но это в принципе аналогично
[01:13:02.700 --> 01:13:04.700]  к тому что вот здесь было
[01:13:06.700 --> 01:13:08.700]  а
[01:13:26.700 --> 01:13:28.700]  на самом деле тут
[01:13:28.700 --> 01:13:30.700]  на самом деле тут удобнее делать вот так вот
[01:13:32.700 --> 01:13:34.700]  значит удобнее делать
[01:13:34.700 --> 01:13:36.700]  что первое равносильно второму
[01:13:38.700 --> 01:13:40.700]  а потом уже переходить
[01:13:40.700 --> 01:13:42.700]  из того и другого к третьему
[01:13:46.700 --> 01:13:48.700]  так
[01:13:52.700 --> 01:13:54.700]  ну а в самом деле из
[01:13:56.700 --> 01:13:58.700]  первой и второй
[01:13:58.700 --> 01:14:00.700]  на самом деле аналогично получается
[01:14:00.700 --> 01:14:02.700]  аналогично предыдущему
[01:14:02.700 --> 01:14:04.700]  да
[01:14:04.700 --> 01:14:06.700]  просто аналогично
[01:14:06.700 --> 01:14:08.700]  предыдущему
[01:14:10.700 --> 01:14:12.700]  значит без
[01:14:12.700 --> 01:14:14.700]  pH
[01:14:14.700 --> 01:14:16.700]  по дороге
[01:14:16.700 --> 01:14:18.700]  да, то есть вот это вот первое всегда верно
[01:14:18.700 --> 01:14:20.700]  значит kt всегда вложено в sigma kt
[01:14:20.700 --> 01:14:22.700]  и если они равны, то это ложные
[01:14:22.700 --> 01:14:24.700]  sigma kt
[01:14:24.700 --> 01:14:26.700]  поэтому
[01:14:26.700 --> 01:14:28.700]  интересно в второго, в первое
[01:14:28.700 --> 01:14:30.700]  так
[01:14:30.700 --> 01:14:32.700]  не в второго, в первое
[01:14:40.700 --> 01:14:42.700]  это как раз
[01:14:42.700 --> 01:14:44.700]  похоже на то что здесь
[01:14:52.700 --> 01:14:54.700]  ну значит смотрите у нас
[01:14:54.700 --> 01:14:56.700]  пусть a будет лежать
[01:14:56.700 --> 01:14:58.700]  в sigma k
[01:14:58.700 --> 01:15:00.700]  плюс первым
[01:15:00.700 --> 01:15:02.700]  в альномерном
[01:15:02.700 --> 01:15:04.700]  вот тогда у нас получается что
[01:15:04.700 --> 01:15:06.700]  x лежит в a
[01:15:06.700 --> 01:15:08.700]  тогда и только тогда когда существует
[01:15:10.700 --> 01:15:12.700]  тогда и только тогда когда
[01:15:12.700 --> 01:15:14.700]  существует
[01:15:16.700 --> 01:15:18.700]  давайте я первую выделю
[01:15:18.700 --> 01:15:20.700]  существует
[01:15:20.700 --> 01:15:22.700]  существует y
[01:15:22.700 --> 01:15:24.700]  для любого z1
[01:15:24.700 --> 01:15:26.700]  существует
[01:15:26.700 --> 01:15:28.700]  z2
[01:15:28.700 --> 01:15:30.700]  и так далее
[01:15:30.700 --> 01:15:32.700]  да и в конце там для любого
[01:15:32.700 --> 01:15:34.700]  или существует, для любого
[01:15:34.700 --> 01:15:36.700]  zkt
[01:15:40.700 --> 01:15:42.700]  а дальше какой-то
[01:15:44.700 --> 01:15:46.700]  v
[01:15:46.700 --> 01:15:48.700]  вот x, y
[01:15:48.700 --> 01:15:50.700]  z1
[01:15:50.700 --> 01:15:52.700]  и так далее zkt
[01:15:54.700 --> 01:15:56.700]  ну тогда соответственно
[01:15:56.700 --> 01:15:58.700]  но что таких пар
[01:15:58.700 --> 01:16:00.700]  x, y
[01:16:00.700 --> 01:16:02.700]  что значит верно
[01:16:02.700 --> 01:16:04.700]  то же самое начиная
[01:16:04.700 --> 01:16:06.700]  с второго
[01:16:08.700 --> 01:16:10.700]  да значит вот это вот будет лежать
[01:16:12.700 --> 01:16:14.700]  в pic atom
[01:16:24.700 --> 01:16:26.700]  ну а значит
[01:16:28.700 --> 01:16:30.700]  лежит его
[01:16:30.700 --> 01:16:32.700]  в sigma
[01:16:32.700 --> 01:16:34.700]  к атом
[01:16:42.700 --> 01:16:44.700]  ну потому что мы предположили
[01:16:44.700 --> 01:16:46.700]  что они равны
[01:16:48.700 --> 01:16:50.700]  то есть получается что
[01:16:50.700 --> 01:16:52.700]  вот это вот верно
[01:16:54.700 --> 01:16:56.700]  да значит это будет
[01:16:56.700 --> 01:16:58.700]  равносильно
[01:16:58.700 --> 01:17:00.700]  тому что тут какие-то другие
[01:17:00.700 --> 01:17:02.700]  существует
[01:17:02.700 --> 01:17:04.700]  какой-то t1
[01:17:04.700 --> 01:17:06.700]  для любого
[01:17:06.700 --> 01:17:08.700]  t2
[01:17:08.700 --> 01:17:10.700]  и так далее
[01:17:10.700 --> 01:17:12.700]  существует
[01:17:12.700 --> 01:17:14.700]  tkt
[01:17:14.700 --> 01:17:16.700]  здесь какой-то w от x, y
[01:17:16.700 --> 01:17:18.700]  t1
[01:17:18.700 --> 01:17:20.700]  и так далее
[01:17:20.700 --> 01:17:22.700]  tkt
[01:17:24.700 --> 01:17:26.700]  так
[01:17:28.700 --> 01:17:30.700]  ну тогда получается что в итоге
[01:17:30.700 --> 01:17:32.700]  в итоге x лежит va
[01:17:32.700 --> 01:17:34.700]  тогда и только тогда
[01:17:36.700 --> 01:17:38.700]  когда здесь
[01:17:38.700 --> 01:17:40.700]  существует y
[01:17:40.700 --> 01:17:42.700]  потом все то же самое
[01:17:46.700 --> 01:17:48.700]  ну то есть можно писать так
[01:17:48.700 --> 01:17:50.700]  существует
[01:17:50.700 --> 01:17:52.700]  пара из y
[01:17:52.700 --> 01:17:54.700]  tk и t1
[01:17:56.700 --> 01:17:58.700]  дальше вот это вот
[01:18:00.700 --> 01:18:02.700]  и это уже будет sigma k выражение
[01:18:08.700 --> 01:18:10.700]  sigma kt
[01:18:10.700 --> 01:18:12.700]  полимерное выражение
[01:18:14.700 --> 01:18:16.700]  то есть получается что
[01:18:18.700 --> 01:18:20.700]  значит в итоге
[01:18:22.700 --> 01:18:24.700]  у нас лежит
[01:18:24.700 --> 01:18:26.700]  sigma kt
[01:18:30.700 --> 01:18:32.700]  то есть доказали
[01:18:34.700 --> 01:18:36.700]  ну и осталось
[01:18:36.700 --> 01:18:38.700]  например из первого третья
[01:18:46.700 --> 01:18:48.700]  нет вот из первого третьего еще не доказали
[01:18:48.700 --> 01:18:50.700]  у нас первое второе
[01:18:50.700 --> 01:18:52.700]  и они оба из третьего
[01:18:52.700 --> 01:18:54.700]  так что еще нужно
[01:18:54.700 --> 01:18:56.700]  из первого третьего
[01:19:00.700 --> 01:19:02.700]  ну из первого третьего смотрите
[01:19:08.700 --> 01:19:10.700]  если
[01:19:14.700 --> 01:19:16.700]  в общем у нас довольно легко
[01:19:16.700 --> 01:19:18.700]  если вот эти равны
[01:19:20.700 --> 01:19:22.700]  так если эти равны
[01:19:24.700 --> 01:19:26.700]  то
[01:19:26.700 --> 01:19:28.700]  верный наоборот
[01:19:28.700 --> 01:19:30.700]  то есть и
[01:19:30.700 --> 01:19:32.700]  kt полимерное тоже равно
[01:19:32.700 --> 01:19:34.700]  это как раз то что вы спрашивали
[01:19:34.700 --> 01:19:36.700]  kt плюс 1
[01:19:42.700 --> 01:19:44.700]  вот а раз
[01:19:44.700 --> 01:19:46.700]  мы уже доказали
[01:19:46.700 --> 01:19:48.700]  что отсюда следует
[01:19:48.700 --> 01:19:50.700]  что sigma kt
[01:19:50.700 --> 01:19:52.700]  равняется pi kt
[01:19:54.700 --> 01:19:56.700]  то и
[01:19:56.700 --> 01:19:58.700]  sigma k
[01:19:58.700 --> 01:20:00.700]  плюс 1
[01:20:02.700 --> 01:20:04.700]  равняется pi
[01:20:06.700 --> 01:20:08.700]  k плюс 1
[01:20:10.700 --> 01:20:12.700]  вот отсюда
[01:20:12.700 --> 01:20:14.700]  получаем
[01:20:14.700 --> 01:20:16.700]  что sigma
[01:20:16.700 --> 01:20:18.700]  k плюс 1
[01:20:18.700 --> 01:20:20.700]  будет равно
[01:20:20.700 --> 01:20:22.700]  sigma k
[01:20:22.700 --> 01:20:24.700]  плюс 2
[01:20:26.700 --> 01:20:28.700]  то есть получили что
[01:20:28.700 --> 01:20:30.700]  sigma kt
[01:20:32.700 --> 01:20:34.700]  равняется
[01:20:34.700 --> 01:20:36.700]  sigma k
[01:20:36.700 --> 01:20:38.700]  плюс 2
[01:20:38.700 --> 01:20:40.700]  ну и далее
[01:20:40.700 --> 01:20:42.700]  ну и далее по индукции
[01:20:44.700 --> 01:20:46.700]  далее по индукции
[01:20:46.700 --> 01:20:48.700]  все будет получаться
[01:20:56.700 --> 01:20:58.700]  что еще раз
[01:20:58.700 --> 01:21:00.700]  откуда у нас равенство
[01:21:00.700 --> 01:21:02.700]  kp и pkp
[01:21:02.700 --> 01:21:04.700]  вот это вот такое что
[01:21:04.700 --> 01:21:06.700]  только что доказали что из первого
[01:21:06.700 --> 01:21:08.700]  второго следует
[01:21:08.700 --> 01:21:10.700]  точно
[01:21:10.700 --> 01:21:12.700]  из первого второго следует
[01:21:14.700 --> 01:21:16.700]  то есть тут как бы
[01:21:16.700 --> 01:21:18.700]  мы вот оба этих использовали
[01:21:18.700 --> 01:21:20.700]  вот здесь получилось что
[01:21:20.700 --> 01:21:22.700]  из первого второго отсюда
[01:21:22.700 --> 01:21:24.700]  получилось второе на шаг выше
[01:21:24.700 --> 01:21:26.700]  а отсюда получилось первое
[01:21:26.700 --> 01:21:28.700]  на шаг выше
[01:21:28.700 --> 01:21:30.700]  ну и дальше вот эти равны
[01:21:30.700 --> 01:21:32.700]  вот эти равны
[01:21:32.700 --> 01:21:34.700]  по индукции
[01:21:34.700 --> 01:21:36.700]  понятно что теперь у нас
[01:21:36.700 --> 01:21:38.700]  все более высокие sigma равны kt
[01:21:38.700 --> 01:21:40.700]  значит объединение всех тоже равно kt
[01:21:44.700 --> 01:21:46.700]  вот ну собственно все
[01:21:46.700 --> 01:21:48.700]  значит на этом давайте
[01:21:48.700 --> 01:21:50.700]  видимо закончим
[01:21:52.700 --> 01:21:54.700]  может кинча вопроса есть
[01:22:06.700 --> 01:22:08.700]  но сейчас обычно предполагают
[01:22:08.700 --> 01:22:10.700]  что
[01:22:10.700 --> 01:22:12.700]  иерархия нигде не склопывается
[01:22:12.700 --> 01:22:14.700]  не коллапсируется
[01:22:14.700 --> 01:22:16.700]  да предполагают что несмотря на то что
[01:22:16.700 --> 01:22:18.700]  интересные задачи только на первых двух нижних уровнях
[01:22:18.700 --> 01:22:20.700]  что нигде не склопывается
[01:22:20.700 --> 01:22:22.700]  но на самом деле на каждом уровне есть
[01:22:22.700 --> 01:22:24.700]  полные задачи
[01:22:24.700 --> 01:22:26.700]  которые
[01:22:26.700 --> 01:22:28.700]  они получаются не очень интересные но они есть
[01:22:28.700 --> 01:22:30.700]  в частности все
[01:22:30.700 --> 01:22:32.700]  все предыдущие будут полные
[01:22:32.700 --> 01:22:34.700]  на втором и на третьем уровня
[01:22:34.700 --> 01:22:45.060]  вот ну либо другом они тоже есть вот и да да такая что это все разное вот то есть все как
[01:22:45.060 --> 01:22:49.940]  а следующий уровень выше предыдущего но соответственно пашу выше любого конкретного
[01:22:59.940 --> 01:23:01.900]  так ну ладно тогда на этом все
