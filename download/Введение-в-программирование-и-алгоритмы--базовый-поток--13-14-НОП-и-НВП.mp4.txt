[00:00.000 --> 00:11.960]  У нас осталось с вами две темы, которые и будут финальными, по сути, в курсе алгоритмов,
[00:11.960 --> 00:16.080]  посвященные все также динамике. То есть динамика это у нас, если глобально смотреть,
[00:16.080 --> 00:21.960]  последняя тема была. Да, действительно, у нас сейчас последняя лекция, поэтому давайте уж все
[00:21.960 --> 00:26.840]  включите камеры. Если кто-нибудь мне ответит и попадет со мной на экзамен, я хотя бы вспомню
[00:26.840 --> 00:32.720]  этого человека и скажу, да, это ты мне ответил на этот вопрос правильно, хорошо так и быть,
[00:32.720 --> 00:43.640]  мы как-нибудь сдадим это вместе. Поэтому думайте об этом, зачем нужно было включать камеры все это
[00:43.640 --> 00:54.680]  время. Смотрите, у нас осталось два вида задач. Наибольшая общая подпоследовательность,
[00:54.680 --> 01:01.040]  либо наединейшая, в зависимости от того, как это переводят, и наибольшая возрастающая
[01:01.040 --> 01:14.800]  подпоследовательность. По-английски, НОП это ЛКС, Latest Common Subsequence. Вначале мы
[01:14.800 --> 01:20.680]  поработаем с ней, потом уже с наибольшей возрастающей подпоследовательностью. Все эти
[01:20.680 --> 01:28.280]  задачи решаются именно конкретно самым оптимальным решением. Будет здесь та самая динамическое
[01:28.280 --> 01:33.240]  программирование, которое есть. Для того, чтобы с этим всем работать, давайте ведем простейшие
[01:33.240 --> 01:42.280]  понятия. Начнем мы с наибольшей общей подпоследовательности. Предположим, что у нас с вами есть какие-то две
[01:42.280 --> 01:48.920]  последовательности. У нас есть последовательность x равная, я буду записывать, как там x1 маленькая и
[01:48.920 --> 02:13.720]  так далее. И у нас есть последовательность y равная y1 и так далее. Что это означает в общем
[02:13.720 --> 02:18.600]  видео? Представьте, что у меня есть последовательности, если не из цитров, а просто из букв, там, например,
[02:18.600 --> 02:31.960]  a-a-c-t-a и так далее. А здесь у меня есть a-c-t-g-a и так далее. Вот у меня есть две какие-то последовательности.
[02:31.960 --> 02:42.600]  И мне среди них нужно найти наибольшую общую подпоследовательность z. z равная z1 и так далее.
[02:42.600 --> 02:54.120]  Что такое наибольшая общая подпоследовательность? Наибольшая общая подпоследовательность это те
[02:54.120 --> 03:04.120]  самые элементы, которые мы можем выбрать в x и в y, они являются одинаковыми и друг друг за дружкой.
[03:04.120 --> 03:09.240]  То есть, к примеру, здесь мы можем сказать, что наибольшая общая подпоследовательность, в общем
[03:09.240 --> 03:16.920]  видео, если смотреть, то это вот a-a, потом у нас есть c, который идет, и последний т, т, и а, а. То есть,
[03:16.920 --> 03:23.320]  наибольшая общая подпоследовательность у них это a-c-t-a, не обязательно идущая подряд. То есть,
[03:23.320 --> 03:29.360]  мы выбираем какие-то конкретно буквы и говорим, что они присутствуют и там, и там в такой-то
[03:29.360 --> 03:35.400]  последовательности, если мы там выкинем какие-то из них. Это метод достаточно полезный в той же
[03:35.640 --> 03:46.280]  информатике, например. Это одно из применений, к примеру. И там такое возможно. Вот. И все это
[03:46.280 --> 03:53.440]  решается с помощью динамического программирования. Как вам было сказано на прошлой лекции и на поза
[03:53.440 --> 04:00.160]  прошлой лекции, главное, что нужно показать, что у нас есть какие-то оптимальные задачи. Вообще
[04:00.320 --> 04:07.600]  всегда во всех задачах с динамическим программированием. Именно поэтому нам необходимо с вами
[04:07.600 --> 04:14.240]  доказать, будет некоторую теорему о наибольшей общей подпоследовательности. Но перед этим давайте
[04:14.240 --> 04:31.960]  кое-что введем. Мы скажем, что и ты, префикс, префикс, например, икса, равный x и t, мы будем
[04:31.960 --> 04:42.000]  обозначать. Это просто последовательность равная x1 и так далее x2. С префиксами вы будете не раз
[04:42.000 --> 04:48.000]  встречаться, но просто префиксы это некоторая последовательность с самого начала и до какого-то
[04:48.000 --> 04:54.720]  момента. Вот это мы будем называть итым префиксом. И обозначать просто так. Префиксы и элементы
[04:54.720 --> 05:04.320]  обязательно друг за другом идут. Да, все верно. То есть если мы возьмем, к примеру, вот для этого
[05:04.320 --> 05:13.680]  примера x3, то это у нас будет aac. Ну вот что такое третий префикс. Мы так это назовем просто для
[05:13.680 --> 05:21.400]  себя, чтобы нам было удобно с этим работать. Теперь давайте введем следующую теорему. Теорема,
[05:21.400 --> 05:43.240]  она прям так называют. Теорема об оптимальности, оптимальность, структура. Наибольшей общей
[05:43.240 --> 05:52.480]  под последовательностью. Вот что эта теорема нам говорит. Она состоит из следующего. Ну для начала
[05:52.480 --> 06:02.200]  мы делаем предположение. Пусть у нас там, пусть у нас есть последовательность. А там скобку надо
[06:02.200 --> 06:09.280]  закрыть, видимо, да? А скобку, видимо, надо закрыть. Да, это правда. Пусть у нас есть последовательности
[06:09.280 --> 06:26.080]  x равны x1 и так далее, xm и y равны y1 и так далее, yn. То есть эти последовательности могут быть
[06:26.080 --> 06:45.840]  разные по размеру. И пусть z равны, к примеру, z1 и так далее, zk. Вот это наибольшая общая
[06:45.840 --> 07:00.280]  под последовательность x и y. Тогда, тогда мы можем сказать следующее. Первое. Просто из
[07:00.280 --> 07:04.800]  чего все будет строиться? Как раз именно из оптимальности. Нам нужно понимать вот оптимально
[07:04.800 --> 07:10.080]  ли что мы будем вообще строить. И вот здесь мы это и докажем. Это достаточно простая теорема,
[07:10.080 --> 07:26.400]  не очень сложная. Первое. Если x, ну, к примеру, xm и yn. Точно, не так, не и. А xm равно yn.
[07:26.400 --> 07:46.520]  Вот, то zk равняется, xm равняется yn и zk-1. То есть префикс z без последнего элемента это
[07:46.520 --> 08:00.360]  наибольшая общая под последовательность последовательности xk-1. Чтобы различать,
[08:00.360 --> 08:06.080]  мы же здесь имеем ввиду, что z большая, правильно? Да, да, здесь z большая. Давайте
[08:06.080 --> 08:13.600]  я напишу. zk-1 это префикс вот здесь. Давайте вот так напишем. Так лучше. xm-1 здесь тоже x
[08:13.600 --> 08:34.200]  большое и yn-1. Это первое утверждение. Второе утверждение. Если xm не равно ym,
[08:34.200 --> 09:00.480]  то из zk не равно xm вытекает, вытекает что? z является
[09:04.200 --> 09:13.000]  наибольшей общей под последовательностью. А чего, как вы думаете? Давайте я кого-нибудь
[09:13.000 --> 09:21.520]  спрошу. Давайте. Айда, скажи, пожалуйста, вот чего является z наибольшей общей под последовательностью?
[09:21.520 --> 09:38.920]  Наверное, y, y, z является… Не может быть просто y. Наибольшей
[09:39.080 --> 09:43.680]  предпоследовательности из двух складывается. Давайте кого-нибудь еще спрошу. Вот Леонид.
[09:43.680 --> 10:04.120]  Возможно, минус два. Минус два что? М-2 и Н-2? Нет. Н-1 и Н-1. Н-1 и Н-1 так нет.
[10:04.120 --> 10:17.000]  Префикса xm-1 и как? Префикса xm-1 и y. Действительно. Смотрите, нам важно обратить внимание именно на
[10:17.000 --> 10:23.960]  вот эту штуку. Мы говорим, что если это вот так, то все логично. И третье утверждение,
[10:23.960 --> 10:33.520]  которое у меня есть, что если у меня xm… Извините, а вот во втором утверждении вы написали,
[10:33.520 --> 10:43.000]  если xm не равно yn, здесь префиксы или элементы? Здесь маленькие. Смотрите,
[10:43.000 --> 10:51.600]  вот здесь, когда я пишу nop чего-то, здесь большие. Это последовательности. А это маленькие. То есть
[10:51.600 --> 11:00.400]  префиксы мы не сравниваем. Мы сравним только элементы. Понятно? Вот. Да, спасибо. Здесь у нас
[11:00.400 --> 11:29.520]  если xm не равно yn, то из zk не равно yn вытекает… что? z является… является nop… ой-ой… nop.
[11:29.520 --> 11:46.160]  А nop чего? Скажи мне, пожалуйста, Ирина. Наверное, x и ym-1.
[11:46.160 --> 12:02.840]  x и ym-1. Понятно ли утверждения, которые здесь написаны, в принципе? Надеюсь, что понятно.
[12:02.840 --> 12:13.600]  В первом утверждении после zk равно же, да? Да, вот это равно. И вот это равно.
[12:13.600 --> 12:20.320]  Можно другой вопрос? Можно. У нас обратные утверждения, они же не верны.
[12:20.320 --> 12:26.120]  В обратном утверждении не факт, что верны. Ну а как-то можно вывести обратное утверждение,
[12:26.120 --> 12:32.880]  которое точно верно? А зачем? Я хочу и в мелких подзадачи строить большое, а не из большой мелки.
[12:32.880 --> 12:39.280]  Можно еще спросить? А вот от того, что zk, например, во втором или в третьем условии не равно xm,
[12:39.280 --> 12:48.400]  но это ведь не означает, что оно равно ym? Не означает. То есть из неравенства утекает, да?
[12:48.400 --> 12:55.440]  Да. Ну то есть у меня последовательность может быть… ну вот, смотрите, давайте вернемся к этой
[12:55.440 --> 12:59.520]  последовательности, которая у меня здесь была. Вот у меня последние два числа здесь равны.
[12:59.520 --> 13:05.800]  А представьте, если бы у меня здесь было вот не а в конце, а b. Ну вот b я захотел сюда поставить.
[13:05.800 --> 13:12.760]  Тогда бы у меня их общая последовательность была бы a c t. Вот для y оно равно последнему у z?
[13:12.760 --> 13:18.920]  Ой, тут t, извините. Тогда в этом случае здесь бы написал t еще. Оно бы равно было.
[13:20.920 --> 13:30.000]  Ну потому что общая их подпоследовательность – это там a c t. Здесь, если что бы, в всякий случай справлю.
[13:30.000 --> 13:42.640]  Ну t последняя равно y последней, но не равно x. Да. Ну вот. То есть ничего мы можем конкретно здесь не
[13:42.640 --> 13:49.080]  сказать. Да, я понял. Поэтому рассматриваем два таких вот отдельных случая отдельно друг от друга.
[13:49.080 --> 13:57.240]  Вот. Таким образом мы можем из этого будем сделать некоторый вывод об оптимальности. Но
[13:57.240 --> 14:01.720]  для начала давайте докажем вообще эту теорему. Давайте рассмотрим первое утверждение. Первое
[14:01.720 --> 14:07.960]  утверждение нам говорит о том, что если у нас в конце элементы равны и они равны z,
[14:07.960 --> 14:17.880]  к этому то z k-1 это наибольшая общая подпоследовательность от x m-1 и y m-1. Давайте с вами
[14:17.880 --> 14:34.720]  будем доказывать. И первое, что нам нужно, давайте так. Если бы у нас выполнялось соотношение z,
[14:34.720 --> 14:41.200]  к примеру, k-1 не равнялось x m. Ну то есть не выполнялось вот это тройное равенство,
[14:41.440 --> 14:56.920]  которое у нас было. То к последовательности z, то, давайте я буду запись, то к z можно было бы,
[14:56.920 --> 15:15.080]  было бы добавить, добавить, а x n, x m равна x y n. Ну то есть мы можем добавить этот
[15:15.080 --> 15:22.480]  последний элемент, который у нас есть в конце. А если y меньше, а если n меньше чем m, то есть
[15:22.680 --> 15:27.600]  у нас идут две одинаковые последовательности, одна из которых заканчивается на один, а другая
[15:27.600 --> 15:34.600]  на один-один. Еще раз, m и n. M это окончание x, а n это окончание y. Смотрите у нас есть
[15:34.600 --> 15:41.440]  последовательность x m, которая состоит из допустим 10 единиц, и последовательность y n,
[15:41.440 --> 15:47.600]  которая состоит из 9 единиц. Еще раз, у нас есть отдельное число m. Сколько у нас чисел в x,
[15:47.600 --> 15:53.360]  сколько у нас последовательность в x, сколько у нас элементов в x, а есть n, сколько у нас
[15:53.360 --> 16:04.440]  элементов в y, это разные числа могут быть. Ну да, у нас не вытекает из того, что мы не можем
[16:04.440 --> 16:09.200]  доказать, что мы можем прибавить z-катой, просто потому что у нас m может быть больше, ты ну...
[16:10.200 --> 16:19.120]  Я говорю следующее, у меня z-катой не равен xm. Я пока не понял утверждение, которое вы хотите
[16:19.120 --> 16:27.960]  сказать мне. Давайте z-катой не равно xm, z-катой маленький, это маленькие буковки здесь. А здесь z
[16:27.960 --> 16:33.920]  большой, я не знаю, как вам их отделить. Давайте z большой буду писать без штучки, просто вот так.
[16:33.920 --> 16:41.360]  Это будет двойка. Это мы сейчас рассматриваем первый случай? Да, это первый случай. А почему z-катой не равно xm?
[16:41.360 --> 16:48.400]  Что еще раз? Почему тогда z-катой не равно xm? Мы предполагаем, пусть это не так. Мы противно
[16:48.400 --> 16:57.320]  видим. Пусть z-катой не равно xm. Но мы знаем, что xm равно ym, у нас это есть,
[16:57.320 --> 17:03.680]  к примеру. И тогда мы можем взять... Что ж такое? У меня опять начинает подлогивать.
[17:03.680 --> 17:14.600]  Тогда я мог бы к своей последовательности z добавить элемент xm равно ym. То есть последний
[17:14.600 --> 17:22.480]  элемент в последовательности x и y, правильно? Мог бы добавить z. Но тогда бы у меня не было
[17:22.480 --> 17:39.800]  такого, что z... Но тогда z не наибольшая общая подпоследовательность x и y. Понятно,
[17:39.800 --> 17:48.760]  почему я сделал такой выбор? Потому что если мы не добавили последние элементы, которые равные,
[17:48.760 --> 17:53.640]  они точно могут войти в наибольшее общее подпоследование. Они в конце, мы никак не нарушим
[17:53.640 --> 17:59.520]  порядок, мы ничего с этим не сделаем. Но тогда, если в z они не входили, тогда она не может
[17:59.520 --> 18:03.160]  являться наибольшей общей подпоследовательностью. Потому что мы можем безболезненно добавить эти
[18:03.160 --> 18:07.680]  элементы и сказать, вот она наибольшая общая подпоследовательность. Это первый момент,
[18:07.680 --> 18:15.920]  который нужно понимать. Понятно? Или нет? Но это вроде бы логично так все получилось.
[18:15.920 --> 18:40.080]  Окей. Это правда. Таким образом, z кt равно xm равно ym. То есть мы это первое утверждение,
[18:41.080 --> 18:46.920]  вот эту первую штуку доказать. Теперь нам необходимо сделать следующее.
[18:46.920 --> 19:07.520]  Префикс. Мы говорим, что префикс z к-1. Это общее какая-то подпоследовательность,
[19:07.520 --> 19:36.600]  просто пока общее. А подпоследовательность x и xm-1 и yn-1.
[19:36.600 --> 19:52.680]  Нужно показать, что эта общая подпоследовательность является наибольшей, то есть исходя из того,
[19:52.680 --> 19:59.920]  что у нас наибольшая, там наибольшая тоже. Окей, тогда давайте с вами говорить следующее.
[20:06.600 --> 20:30.720]  Давайте предположим, что существует общая подпоследовательность
[20:30.720 --> 20:59.800]  xm-1 и yn-1. Предположим, что существует какая-то другая. И ее длина больше
[20:59.800 --> 21:12.600]  к-1. Извините, вы пишете префикс z к-1 наибольшую общую подпоследовательность именно или?
[21:12.600 --> 21:22.280]  Префикс. Общее просто. Смотрите, мы с вами доказали, что если у нас есть последние
[21:22.280 --> 21:29.160]  элементы равные, то тогда z является наибольшей общей подпоследовательностью. Этот элемент
[21:29.160 --> 21:36.080]  входит в них. Понятно? Да, но выбирайте последний элемент и говорите, что без последнего это наибольшее.
[21:36.080 --> 21:44.080]  Сейчас мы должны сказать, что если у нас была наибольшая общая подпоследовательность,
[21:44.080 --> 21:49.680]  мы хотим выбрать последний элемент и сказать, что если мы даже уберем этот последний элемент,
[21:49.680 --> 21:58.880]  это будет наибольшей общей подпоследовательностью для префиксов xm-1 и префикс ym-1. То есть
[21:58.880 --> 22:05.160]  без последних элементов у нас z без последнего элемента будет являться наибольшей общей
[22:05.160 --> 22:11.280]  подпоследовательностью равно. Из меньшей задачи мы говорим, что если у нас есть большая задача,
[22:11.280 --> 22:18.160]  то она опирается на маленькую, на меньшую, которая действительно входит в нее же. Иначе мы не можем
[22:18.160 --> 22:26.000]  перекрывающую задачу сделать внутри. Понятно? Да, спасибо. Если мы предполагаем, что существует
[22:26.000 --> 22:33.880]  общая подпоследовательность в последовательности xm-1 и yn-1 и ее длина будет больше чем k-1,
[22:33.880 --> 22:53.640]  то тогда в этом случае что мы можем сказать? То добавив в нее xm равное y
[22:53.640 --> 23:03.760]  и мы получим получим общую
[23:03.760 --> 23:10.040]  подпоследовательность
[23:10.040 --> 23:19.040]  x и y больше
[23:19.040 --> 23:48.680]  чем k. А это противоречит тому, что z — наибольшая общая подпоследовательность x и y.
[23:49.320 --> 23:55.280]  Почему это противоречит? Потому что у меня в z находится всего k-элементов. Если там всего
[23:55.280 --> 24:03.720]  k-элементов и она наибольшая общая подпоследовательность, то там не существует
[24:03.720 --> 24:10.720]  общей последовательности, в которой больше чем k. Иначе тогда z не являлась наибольшей. Именно
[24:10.720 --> 24:16.680]  в этом вся проблема. То есть мы просто два раза отталкиваемся от противного. И таким образом мы
[24:16.680 --> 24:22.880]  с вами получаем, что у нас с вами есть, если у нас есть с вами последние два равных элемента,
[24:22.880 --> 24:32.480]  и они равны z внутри, то они равны z внутри, и z от k-1 является наибольшей общей подпоследовательностью
[24:32.480 --> 24:41.480]  от xm-1 и ym-1. То есть мы можем откатиться назад, убрав последние элементы, и они входят все равно
[24:41.480 --> 24:46.120]  в нашу наибольшую общую подпоследовательность. То есть мелкие задачи действительно являются
[24:46.120 --> 24:54.720]  большой подзадачей. Элементом большой. Понятно? Это первый момент, который мы с вами доказали.
[24:54.720 --> 24:58.920]  Это очень круто, потому что так мы доказали оптимальность с точки зрения того, что большая
[24:58.920 --> 25:08.040]  подзадача включает в себя маленький. Чудеса. Теперь давайте перейдем к
[25:08.040 --> 25:19.840]  второму пункту. Второй пункт звучал следующим образом, что если xm не равно ym, то из zk не
[25:19.840 --> 25:27.680]  равно xm, вытекая, что z является наибольшей общей подпоследовательностью xm-1 и y. Ну это все
[25:27.680 --> 25:33.480]  достаточно тоже тривиально и просто, доказывается также примерно противно. То есть смотрите,
[25:33.480 --> 25:55.320]  если давайте zk не равно xm, то z общая, ну точнее даже не противно. Общая подпоследовательность,
[25:55.320 --> 26:16.160]  общая подпоследовательность, последовательности xm-1 и просто y. Ну понятно почему. Если в последнем
[26:16.160 --> 26:23.240]  zk не лежит xm, то zk равно какому-то из предыдущих элементов. А если оно равно какому-то из предыдущих
[26:23.240 --> 26:30.800]  элементов, то как бы ok. Так-то мы и быть, значит он там где-то раньше был. Это наибольшая общая
[26:30.800 --> 26:35.560]  подпоследовательность. Поэтому мы говорим о том, что z является общей подпоследовательностью.
[26:35.560 --> 26:49.520]  И здесь опять мы говорим, что если бы, если бы существовала общая, общая подпоследовательность,
[26:49.520 --> 27:05.880]  подпоследовательность w, последовательности, последовательности xm-1 и y. Длина,
[27:05.880 --> 27:34.640]  которая превышала бы k, то w являлась общей подпоследовательностью.
[27:35.880 --> 27:51.160]  Общей подпоследовательностью последовательности x. По факту m, ну то есть все x и y. Ну то есть если
[27:51.160 --> 27:58.080]  бы мы добавили элемент неравный ничему, неравный там почему-то последнему, то если мы добавим туда
[27:58.080 --> 28:03.400]  элемент, общая подпоследовательность так и останется такой же. Правда? Правда. То есть она может
[28:03.400 --> 28:11.720]  максимум увеличиться. Уменьшиться никак не может. Вот. А это означает, что это противоречит,
[28:11.720 --> 28:22.680]  что противоречит, что противоречит, что противоречит, что противоречит, что противоречит z наибольшая
[28:22.680 --> 28:29.440]  общая подпоследовательность. То есть смотрите, как это работает, еще раз. Если мы предполагаем,
[28:29.440 --> 28:37.240]  что у нас есть последовательность w, которая является общей подпоследовательностью, вот xm-1 и y,
[28:37.240 --> 28:44.360]  и у нее размер больше, чем k, то есть больше, чем у z, то давайте в x мы добавим еще один элемент,
[28:44.360 --> 28:50.440]  xm. Если мы добавим туда еще один элемент, общая подпоследовательность так и останется общей
[28:50.440 --> 28:56.040]  подпоследовательностью даже с добавленным элементом. Но если у нее размер был больше,
[28:56.040 --> 29:02.360]  чем k, тогда z не могла являться наибольшей общей подпоследовательностью, потому что есть еще
[29:02.360 --> 29:08.960]  последовательности, у которых больше размеров, что противоречит по самому условию теории. Вот.
[29:08.960 --> 29:13.960]  То есть здесь простые такие рассуждения, которые нас приводят к необходимости,
[29:13.960 --> 29:17.800]  к тому, что у нас все хорошо. Ну, третий случай аналогичен второму.
[29:17.800 --> 29:31.480]  Таким образом, мы с вами доказали вот такую вот теорему об оптимальности. Что нам дает такая
[29:31.480 --> 29:40.320]  теорема об оптимальности? Мы из этой теоремы видим следующее, что у нас наидлиннейшая общая
[29:40.320 --> 29:48.520]  подпоследовательность, двухпоследовательность, содержит в себе наибольшую общую подпоследовательность
[29:48.520 --> 29:54.160]  их префиксов. То есть исходя из того, что у нас есть наибольшая общая подпоследовательность,
[29:54.160 --> 30:00.160]  мы можем найти наибольшую общую подпоследовательность префиксов. Вот. То есть задача
[30:00.160 --> 30:09.920]  НОП сама по себе обладает оптимальной такой структурой внутри. То есть мы взяли и разбили
[30:09.920 --> 30:14.880]  большую задачу на мелкие. То есть внутри большой задачи сохранять вот эти вот мелкие подзадачки.
[30:14.880 --> 30:21.360]  Именно благодаря этому мы можем с вами говорить, что да, мы можем решать эту задачу с помощью
[30:21.360 --> 30:30.640]  динамики, потому что нам необходимо как раз таки сама вот это вот, нам необходимо сама вот это
[30:30.640 --> 30:44.200]  вот оптимальность. Это пока понятно все? Нет вопросов? Ни у кого? Отлично. А тогда давайте с
[30:44.200 --> 30:50.760]  вами рассуждать и попробуем рекуррентно задать, а чему же равно наибольшая общая подпоследовательность.
[30:50.760 --> 30:57.520]  Мы сейчас будем искать ее просто вообще в принципе, как ее можно найти, длину именно. Мы
[30:57.520 --> 31:01.880]  захотим длину пока наибольшей общей подпоследовательности. Если мы с вами хотим
[31:01.880 --> 31:06.960]  длину наибольшей общей подпоследовательности, то мы можем задать это с помощью рекуррента. Мы с
[31:06.960 --> 31:12.440]  вами с помощью теории, мы уже увидели, что если у нас равные элементы, то они входят в нашу
[31:12.440 --> 31:20.120]  последовательность. Если у нас элементы разные, то они не входят. И причем не входят типа от
[31:20.120 --> 31:24.640]  префиксов, то есть у нас Z является наибольшей общей подпоследовательностью. Кто-нибудь может
[31:24.640 --> 31:31.320]  на основе этого вывести рекуррентное соотношение? Давайте вот я кого-нибудь спрошу. И вот Владислав
[31:31.320 --> 31:40.840]  Чшанский. Есть ли идеи, как вот из этой теории мы можем сделать рекурренту?
[31:40.840 --> 32:00.400]  Пока нет. Хорошо, давайте я кого-нибудь еще спрошу. Вот, например, давайте вот Олега
[32:00.480 --> 32:09.040]  Чурина я спрошу. Олег, есть ли идеи, как это можно сделать? На основе вот этой теории мы об оптимальности.
[32:18.400 --> 32:20.600]  Я не слышу. Микрофон выключи.
[32:20.600 --> 32:30.040]  Допустим, у нас есть НЛП для каких-то двух подпоследовательностей. Одну из них увеличим на единицу.
[32:30.040 --> 32:43.760]  И будем рассматривать различные случаи. Или нет, лучше обе последовательности увеличить на единицу.
[32:43.760 --> 32:58.760]  Такое не всегда возможно. Мы можем просто сделать таблетку Nm для всех префиксов x и y. И для каждой
[32:58.760 --> 33:06.000]  клеточки смотреть, равны последние элементы этих префиксов? Если равны, мы уменьшаем обе
[33:06.000 --> 33:12.840]  координаты клеточки на 1, берем оттуда число и ставим в нашу клетку это число вечно на 1.
[33:12.840 --> 33:27.320]  В этом случае мы рассматриваем два варианта. Сравним клетку, в которой мы уменьшили префикс x и берем оттуда
[33:27.320 --> 33:36.200]  число и смотрим на клетку с уменьшенным префиксом y. Естественно, берем максимум из двух чисел.
[33:36.200 --> 33:48.200]  Да, отлично. Давайте с вами, с помощью того, что у нас есть, мы построим для какого-то примера.
[33:48.200 --> 34:03.080]  Пусть у меня x равно, с числами работать легче, поэтому давайте с числами сделаем. Сделаем табличку
[34:03.080 --> 34:23.960]  на числа. Пусть у меня x равно 1, 1, 8, 5, 3, к примеру, и y равно 0, 1, 5, 9, 7. Вот, к примеру, такие две последние.
[34:23.960 --> 34:29.560]  Я думаю, вы видите здесь, что как бы наибольшая общая подпоследность является 1 и 5. Ну как бы, это их наибольшая
[34:29.560 --> 34:36.680]  общая подпоследность. Так мы можем здесь действовать. Давайте сделаем табличку. У нас здесь по 5 действий.
[34:36.680 --> 34:42.200]  Она может быть не обязательно квадратная, но в нашем случае у нас сейчас будет квадратная табличка.
[34:42.200 --> 34:57.640]  Давайте с вами сделаем некоторую такую вот таблицу. У нас здесь будет
[34:57.640 --> 35:09.720]  она не получилась сильно квадратной, конечно, но что поделать. Смотрите, первую строку и первый столбец
[35:09.720 --> 35:17.400]  мы оставляем пустыми. То есть, представим, что у нас пустая строка. Вот. То есть, здесь как бы пусто.
[35:17.400 --> 35:25.800]  Если у нас пустая строка, то наибольшая общая подпоследность какую длину имеет? 0, правда? Вот.
[35:25.800 --> 35:30.520]  Это мы сейчас скоро и заполним. Это будет как раз-таки то самое начало для рекурсивной штуки.
[35:30.520 --> 35:41.640]  Давайте здесь поставим 1, 1, 8, там, 5 и 3. Ну, чуть-чуть кривенько, конечно, у меня вышло здесь, но ладно.
[35:41.640 --> 35:57.880]  А здесь 0, 1, 5, 9 и 7. Вот. И сейчас ее расчерчем. Так, так, так, так. Ну и давайте, чтобы здесь вот было
[35:57.880 --> 36:11.160]  примерно вот так. То есть, вот этот вот кусок просто забейте. Сейчас я сотру. Давайте я перечерчу, чтобы
[36:11.160 --> 36:29.720]  у вас было все хорошо. Вот. Здесь у меня там 7. И мы доделываем эту таблицу до ума. Вот. И давайте
[36:29.720 --> 36:35.720]  заполнять эту таблицу. Когда у нас пустые подстроки, любая из подстрок пустая, у нас как бы ничего нет.
[36:35.720 --> 36:46.680]  Вот. А дальше, а дальше, исходя из нашей теории об оптимальности, мы говорим, что если у нас есть
[36:46.680 --> 36:56.440]  общая подстрока, то в этом случае мы как бы можем сказать, что если у нас элементы не равны на конце
[36:56.440 --> 37:01.160]  наших подстрок, то есть, к примеру, что мы предполагаем, какая подзадача? Подзадача следующая.
[37:01.160 --> 37:09.080]  Представим вот в этой клеточке. Вот в этой клеточке. У нас есть строчка 1,1 и 0,1. И вот в зависимости от этого
[37:09.080 --> 37:15.000]  мы можем сделать какие-то решения на основе предыдущих. Вот. Но если у нас 0 и 1, то в этом
[37:15.000 --> 37:20.920]  случае у нас с вами наибольшая общая подстрока равна нулю. Я думаю, вы все это понимаете. Если
[37:20.920 --> 37:26.040]  у меня открыто только 0, то есть представим, что у меня открыто только 0, тогда в этом случае здесь
[37:26.040 --> 37:33.400]  настолько все нулевое. Почему? Потому что нигде из элементов у нас нет нулевого. А вот если у нас
[37:33.400 --> 37:41.000]  есть элементы 1 и 1, то в этом случае, согласно нашей теореме сказанным, если у нас есть равные
[37:41.000 --> 37:53.680]  элементы, то префикс zk-1 является наибольшей общей подпоследовательностью от префиксов xm-1 и
[37:53.800 --> 38:02.480]  yn-1. То есть в случае равенства мы говорим, что мы просто добавляем один элемент в нашу общую
[38:02.480 --> 38:10.000]  подпоследовательность. То есть исходя из того, что здесь было 0, мы здесь ставим единицу. Потому
[38:10.000 --> 38:16.200]  что мы взяли и добавили один элемент в нашу общую подпоследовательность. 1 и 1. Здесь же у нас
[38:16.200 --> 38:22.440]  дальше тоже равные элементы. 1 и 1. Когда у нас равные элементы, давайте идти согласно нашей теореме.
[38:22.440 --> 38:26.520]  Согласно нашей теореме, у нас наибольшая общая подпоследовательность, все также вот отсюда
[38:26.520 --> 38:34.640]  будет идти. Будет единичка. Когда у нас элементы неравны, то есть когда у нас неравные элементы,
[38:34.640 --> 38:42.080]  там xm, к примеру, и так далее, мы уже не опираемся на первый пункт. А значит, тогда мы можем взять либо
[38:42.080 --> 38:51.400]  так, что мы уберем последовательность из ык, последний элемент, либо из ыкса. То есть мы можем
[38:51.400 --> 38:56.200]  взять либо оттуда, либо оттуда подпоследовательность. Так давайте возьмем максимальную. Мы же ищем
[38:56.200 --> 39:01.000]  максимальную общую подпоследовательность, ну и большую. Поэтому давайте возьмем максимум. В случае,
[39:01.000 --> 39:07.120]  когда у нас элементы будут неравны, то мы ищем максимум из этих двух. И ничего не прибавляем,
[39:07.120 --> 39:14.680]  потому что мы не можем добавить элементов. Поэтому в этом случае здесь тоже будет единичка. Дальше 1 и
[39:14.680 --> 39:24.040]  5 они тоже неравны, и 1 и 3 тоже неравны. Давайте мне вот Грабунов и Вак продиктуют, как будет
[39:24.040 --> 39:32.360]  выглядеть следующая строка, и исходя из чего. Можете еще раз объяснить способ? Смотрите,
[39:32.360 --> 39:38.560]  когда у нас элементы равны, то есть смотрите, мы можем сказать, что вот эта единица, сейчас,
[39:38.560 --> 39:45.520]  давайте зеленую возьму, вот эта единица, она равна вот этой единице, вот этой единице, правда? Да.
[39:45.520 --> 39:52.600]  Тогда согласно нашей теории, которую мы только что доказали, если у нас xm равно yn, то zkt равно
[39:52.600 --> 40:02.880]  xm равно yn, а z от k-1 является наибольшей общей подпоследовательностью xm-1 и yn-1. То есть мы
[40:02.880 --> 40:12.160]  можем взять наше решение, которое было раньше, на основе xn-1 и xm-1. То есть мы берем просто и
[40:12.160 --> 40:19.800]  убираем кусочек. То есть в этом случае мы говорим о том, что если мы убираем единичку и единичку,
[40:19.800 --> 40:27.560]  которые у нас стоят вот в этих столбцах, вот в этих столбцах, галочки я поставил такие, то мы
[40:27.560 --> 40:32.400]  можем рассмотреть наибольшую общую подпоследовательность, вот здесь, которую мы уже почитали, она равна нулю, и
[40:32.400 --> 40:46.760]  добавить к ней элемент 1. Отлично. Теперь же, когда у нас элементы не равны, когда у нас xm не равно y, то из
[40:46.760 --> 40:58.960]  zk не равно xm вытекает, что z является nop xm-1 и y. И если они не равны, то у нас zk не равно xy-1.
[40:58.960 --> 41:04.160]  Оно является наибольшей общей подпоследовательностью для вот этих вот префиксов. То есть в случае
[41:04.160 --> 41:09.120]  неравенства наших элементов мы можем взять наибольшую общую подпоследовательность, либо
[41:09.120 --> 41:18.440]  выкинув один элемент из y, либо выкинув один из элементов из x. Понятно? А если мы выкидываем один
[41:18.440 --> 41:23.520]  элемент оттуда или оттуда, то в этом случае мы просто рассматриваем эти элементы отдельно.
[41:23.520 --> 41:34.000]  То есть если у нас элементы не равны, то мы можем рассмотреть результат, который был вот здесь,
[41:34.000 --> 41:42.000]  либо вот здесь. Ну вот 1 и 8 неравны, к примеру. И взять из них максимальный. Мы же наибольшей
[41:42.000 --> 41:48.640]  общей подпоследовательностью. Да, понятно. Понятно, теперь стало отлично. Тогда продиктуй
[41:48.640 --> 41:55.560]  мне следующую строку. Ну нолик вы уже записали, значит там будет единичка, потом будет опять
[41:55.560 --> 42:04.200]  единичка. Опять единичка. Еще единичка. Еще единичка. Так, ну сейчас они равны,
[42:04.200 --> 42:11.120]  ну значит двойка. Потому что мы идем из такой диагональной клетки, делаем плюс один, поэтому
[42:11.120 --> 42:17.720]  здесь два. А тут? Двойка. Двойка. Давайте следующую строчку мне продиктует София,
[42:17.720 --> 42:29.560]  например. София Павловна. 9, 0, 1, 1, 1, 2, 2. Да, то есть у нас здесь нет элементов равных. И для
[42:29.560 --> 42:39.800]  семерки давайте вот мне тоже кто-нибудь продиктует по-быстрому. Давайте вот Александр Погутин.
[42:39.800 --> 42:49.240]  Так, значит для семерки у нас будет 0, 1, 1, 1, 1, 1, 2, 2. 2, 2. И смотрите,
[42:49.240 --> 42:59.360]  наша наибольшая длина будет как раз-таки лежать вот здесь, вот в конце. Понятно? То есть у нас
[42:59.360 --> 43:04.400]  получилась вот такая вот таблица. А по факту рекуррента будет выглядеть следующим образом.
[43:04.400 --> 43:14.280]  Если мы назовем эту табличку DP, ну динамическое программирование там DP, либо там LKS еще ставят
[43:14.280 --> 43:20.040]  здесь. Ну здесь все зависит от того, как вы хотите сами писать. Вот, то в этом случае нам
[43:20.040 --> 43:25.880]  достаточно с вами написать просто рекурренту, как мы заполняем вообще все в принципе. А заполнять
[43:25.880 --> 43:34.960]  все очень просто. Пишется, что DP получается IT, JIT. Так как мы делаем таблицу на 1 больше,
[43:34.960 --> 43:38.840]  мы специально говорим, что у нас есть пустые строки, грубо говоря, чтобы мы просто могли
[43:38.840 --> 43:50.520]  нормальная динамика идти. То 0 у нас будет в случае I равно 0 или J равно 0. Вот. После этого
[43:50.520 --> 43:58.560]  мы говорим о том, что если у нас элементы равные, то у нас это будет DP и минус 1,
[43:58.560 --> 44:14.640]  J минус 1, если у нас X и T равно Y JT. Плюс единицы еще. Ой да, плюс единичка, спасибо большое. Извините.
[44:14.640 --> 44:26.360]  Плюс единицы. Вот. И максимуму, если они не равны, то есть максимум из DP и минус 1,
[44:26.360 --> 44:48.000]  J. Взбитая DP, получается у нас I, J минус 1. В случае, если у нас X и T, не равно Y JT. Это понятно?
[44:48.000 --> 44:59.280]  Теперь стало всё понятно. Сверху, когда у нас максимум идёт с левой части, а не сверху,
[44:59.280 --> 45:04.920]  просто вроде бы все это же. Ну, с левой части, вот у нас тут пример. Если сверху, то можно
[45:04.920 --> 45:18.240]  другой. Сверху? Ну, давайте здесь придумаем. К примеру, у нас будет так, что у нас сверху было
[45:18.240 --> 45:33.480]  вот здесь. Вот, сейчас покажу. Давайте возьму чёрный. Вот здесь было сверху. Видно? Вот это вот,
[45:33.480 --> 45:41.080]  когда было 0 и единичка, мы брали сверху. Когда у нас вот здесь двойка была, мы тоже брали сверху.
[45:41.080 --> 45:52.200]  Видно? Ну, то есть оно происходит в зависимости от ситуации. Вот. И всё это благодаря этой теоремы
[45:52.200 --> 46:00.280]  об оптимальности. Вопросы в общем… Пожалуйста, скажите, что такое вот LCS и DP, как расшифровывается?
[46:00.280 --> 46:06.320]  Это по факту табличка. LCS – это largest common subsections, то есть это наибольшая общая
[46:06.320 --> 46:11.520]  подпоследовательность. DP – это просто чаще всего в динамике. Все массивы обозначаются DP.
[46:11.520 --> 46:18.080]  Поясняю, что это динамическая программировка. Такой предпочёт. Вот. Поэтому здесь, как вы хотите.
[46:18.080 --> 46:28.760]  Ясно? Вот. Как восстанавливается ответ в данной задаче? Ответ восстанавливается здесь достаточно
[46:28.760 --> 46:35.840]  просто. В данной задаче нам необходимо просто смотреть. Если у нас элементы не равны, то нужно
[46:35.840 --> 46:43.520]  понять, с какой ячейки мы пришли. То есть если у меня вот 7 и 3 не равны, то я мог прийти сверху или слева.
[46:43.520 --> 46:48.880]  Но нам без разницы, откуда. Мы могли и оттуда, и оттуда прийти. Поэтому нам нужно просто восстановить
[46:48.880 --> 46:57.160]  путь. Давайте пойдём сверху, к примеру. Давайте вот я сейчас возьму какой-нибудь вот такой вот
[46:57.160 --> 47:03.680]  жёлтый. Мы будем восстанавливать путь. Опять двойка 9 и 3 не равны мог прийти откуда угодно. А вот
[47:03.680 --> 47:10.240]  здесь двойка я точно пришёл слева. Потому что я максимум выбирал, а 5 и 3 не равны. А вот здесь,
[47:10.240 --> 47:18.960]  вот в этой ячейке у меня 5 и 5 равны. А если они равны, то я приходил явно по диагональке. Тогда
[47:18.960 --> 47:30.960]  в мою последовательность Z я запишу 5. Конец. Я записываю сюда 5 и иду вот в эту ячейку. Здесь
[47:30.960 --> 47:37.200]  у меня 1 и 8. Они не равны. Значит, я пришёл либо сверху, либо слева. В зависимости от того,
[47:37.200 --> 47:42.840]  где максимум, туда и иду. Вот сюда, к примеру, иду. Максимум единичка, потому что слева. А здесь у
[47:42.840 --> 47:49.160]  меня 1 и 1 равны. Поэтому в свою последовательность Z я запишу ещё единичку. И всё, что мне в конце,
[47:49.160 --> 47:53.840]  а потом я пришёл, так как они у меня были равны, я пришёл вот отсюда. Здесь у меня 0,
[47:53.840 --> 47:59.280]  ну можно уже остановиться. Либо можно дойти вот до сюда, к примеру, до самого начала. Обычно
[47:59.840 --> 48:05.720]  до самого начала. То есть в Z у меня 5 и 1. Так как я считал с конца до начала, то у меня должно
[48:05.720 --> 48:12.720]  получиться, мне необходимо это повернуть. Поэтому общая подпоследовательность это 1 и 5. Понятно,
[48:12.720 --> 48:21.440]  как это работает? У меня вопрос. В ситуации, вот у нас есть квадратик 1, 1, 1, 2. Вот маленький,
[48:21.440 --> 48:26.800]  где мы переход делали, пятёрку когда записывали. Возможно, есть ситуация, когда у нас будет
[48:26.800 --> 48:36.440]  квадратик 0, 1, 1, 1. Тогда ведь не совсем понятно, куда идти. Почему? Мы сравнивали элементы х и у.
[48:36.440 --> 48:49.840]  Если они равны по буквенам, то есть х и ты равно у житому, то мы пришли точно по диагональке.
[48:49.840 --> 49:01.440]  То есть ситуация, когда будет 0, 1, 1, 1. Возможно. Но в этой ситуации мы всё равно пришли по
[49:01.440 --> 49:11.920]  диагональке. Возможно ли? Странно было бы. Можно ли находить так, что, например, когда у нас
[49:11.920 --> 49:22.360]  была вот самая последняя двойка. Два слева, два сверху. Поэтому вы сказали, что мы пришли точно не
[49:22.360 --> 49:26.920]  из диагонали и идём либо вверх, либо вниз. А мы можем ли сделать вывод из-за того, что вот эта
[49:26.920 --> 49:31.960]  вот, которая по диагонали, она такая же? Ну тоже двойка. Поэтому мы точно не из диагонали. Ну типа
[49:31.960 --> 49:39.200]  сравнивать 3 и 3 клетки и от этого исходить. Можно от этого, но у вас есть х и ты, х и ты. Давайте
[49:39.440 --> 49:44.400]  просто по динамике по тому, как мы заполняли таблицу. То есть можно по ней сравнивать сразу же и всё
[49:44.400 --> 49:53.600]  понятно будет. Потому что по диагонали может быть элементом на единичку меньше. Я сейчас в
[49:53.600 --> 50:08.560]  принципе в голове, наверное, придумаю. Нет, такого быть не может. Но сама суть в чём смысл? Как бы
[50:08.560 --> 50:14.160]  доказать одну тяремку, мы смогли всё решить. Построение будет работать вот именно таким вот
[50:14.160 --> 50:20.800]  образом. Я думаю, что вы сможете написать этот код этой задачи самостоятельно, правда? Без того,
[50:20.800 --> 50:25.680]  что вам нужен там псевдокод. Заполнить табличку вы сможете. Если нужно восстановить, восстановить вы
[50:25.680 --> 50:35.600]  тоже сможете. Просто идя задом наперёд и потом развернув этот массивчик. Ясно? Если нам надо
[50:35.600 --> 50:44.280]  посчитать, почему не за две линии это сделать? В смысле за две линии? Ну фактически мы эту таблицу
[50:44.280 --> 50:53.760]  строим, как фиксируем какой-то элемент и потом проходимся по x. Потом приходим на следующий
[50:53.760 --> 50:59.200]  элемент. У нас посчитано, какое максимальное количество уже, максимальная последовательность у нас
[50:59.200 --> 51:06.880]  есть с этим элементом предыдущим. Но зачем, если мы встречаем следующий элемент, в последовательстве
[51:06.880 --> 51:15.880]  у, просто увеличиваем предыдущее значение на единицу. Почему? Потому что мы встретили этот
[51:15.880 --> 51:23.360]  элемент в последовательности x. В зависимости от того, в каком месте ты его встретил. Пойми,
[51:23.360 --> 51:32.320]  что если я добавлю в x еще здесь конец 0, то этот 0 как бы мне не сыграет роли большой. Ну и в
[51:32.320 --> 51:37.280]  действительности, я думаю, вы понимаете, что этот алгоритм работает за у от н квадрата.
[51:37.280 --> 51:51.960]  Вот. Я думаю, это понятно. Таким образом, вот решение задачи nop. Есть вопрос еще к этому всему?
[51:51.960 --> 52:01.640]  Видимо, нет. Хорошо. Теперь перейдем к задаче nvp. Как вы думаете,
[52:01.680 --> 52:08.040]  что такое nvp? Наибольшая возрастающая последовательность. Наибольшая возрастающая
[52:08.040 --> 52:19.240]  подпоследовательность. Задача. Нвп. Ну по-английски это largest increase subsequent.
[52:19.240 --> 52:28.520]  Вот. В чем заключается задача наибольшей возрастающей подпоследовательности?
[52:28.520 --> 52:37.040]  Смотрите. Наибольшая возрастающая подпоследовательность строится по одной
[52:37.040 --> 52:42.360]  последовательности. То есть представьте следующее. У меня есть массив чиселок.
[52:42.360 --> 52:57.320]  Ну там какой-нибудь. Давайте сейчас напишем. 1-5-8-7-3-4. Что такое наибольшая возрастающая
[52:57.320 --> 53:01.420]  подпоследовательность? Наибольшая возрастающая подпоследовательность. Такая подпоследовательность,
[53:01.420 --> 53:07.220]  что в ней будут возрастать все элементы и идти строго друг за другом согласно тому,
[53:07.220 --> 53:12.920]  как было в последовательности. В данном случае, если мы будем рассматривать эту
[53:12.920 --> 53:23.940]  подпоследовательность, что будет наибольшей возрастающей? Как вы думаете? 1-3-4. Еще есть
[53:23.940 --> 53:38.660]  варианты минус 5 3 4 к примеру еще наверное больше нет наверное больше то есть элементы не
[53:38.660 --> 53:44.980]  должны подряд идти обязательно не должны эта задача связанная с тем чтобы выбрать просто
[53:44.980 --> 53:51.940]  элементы которые идут возрастающие ну не угодно еще раз каким образом устроили построил последователь
[53:51.940 --> 53:58.820]  под последовательности мы выбираем любой из элементов вот к примеру единицу и все что идет
[53:58.820 --> 54:04.980]  после него можно построить здесь 1 8 под последовательность к примеру то есть мы
[54:04.980 --> 54:11.740]  выбираем любые элементы но суть в следующем что это давайте тогда формально напишу чтобы
[54:11.740 --> 54:22.660]  вы знали вы могли на это ответить спокойно а не больше возрастающая под последовательность строки
[54:22.660 --> 54:45.380]  строки икс длины n это последовательность это последовательность икс и минус 1 так далее икс
[54:45.380 --> 54:52.300]  давайте здесь не тогда ли а просто меньше сразу кажем икс и минус один меньше икс и минус два
[54:52.300 --> 55:11.340]  икс и 2 меньше и так далее меньше чем икс от иката какой-то символы символ икс причем
[55:11.340 --> 55:29.460]  причем и 1 меньше и 2 меньше и так далее меньше и и и один ну там меньше либо равен 0 если мы
[55:29.460 --> 55:40.820]  с нуля считаем 0 меньше либо равен там и житое меньше либо меньше чем если с нуля ну как стоять
[55:40.820 --> 55:50.540]  что еще раз а нет не обязательно да понял я подумал что длины если н тогда индекс максимальный
[55:51.540 --> 56:06.260]  но потому что нет причем смотрите причем к тире а наибольшей из возможных наибольшие из возможных
[56:06.260 --> 56:16.700]  я думаю это вам понятно ну теперь стало понятно совсем уже окончательно что это если мы ввели
[56:16.720 --> 56:22.340]  формальное определение наибольшего возрастающая под последов revelation мы просто выбираем какие-то
[56:22.340 --> 56:27.980]  элементы идущие друг за д coating и не обязательно друг за другом но в правильный последовательности
[56:27.980 --> 56:34.660]  как наши последовательности вот и они возрастают вот это возрастающая под последовательность
[56:34.660 --> 56:42.780]  вопросuros а обязательно они должны строго возрастать или задачи может как-то различаться
[56:42.780 --> 56:48.620]  Ну, если вы хотите вести не строго возрастающую подпосредственность, так тоже можно, в принципе.
[56:48.620 --> 56:51.900]  Вы сейчас увидите, как мы будем это строить, тогда возможно.
[56:51.900 --> 56:59.020]  Но вообще, именно возрастающая подпосредственность, она не зря называется наибольшая возрастающая, увеличивающаяся.
[56:59.020 --> 57:00.700]  То есть она строго возрастающая?
[57:00.700 --> 57:01.340]  Да.
[57:01.340 --> 57:02.540]  Ну, все, хорошо, спасибо.
[57:02.540 --> 57:04.860]  Вот, если как-то вы захотите модифицировать, пожалуйста.
[57:05.740 --> 57:13.500]  Смотрите, здесь никакой дикой корректности нам не необходимо.
[57:13.500 --> 57:17.340]  То есть мы понимаем, что если у нас была подпоследовательность какая-то,
[57:17.340 --> 57:20.380]  и мы добавим туда элемент больше, чем все предыдущие,
[57:20.380 --> 57:23.580]  то мы получим еще одну возрастающую подпосредственность.
[57:23.580 --> 57:27.580]  И таким образом мы можем с вами там перебирать различные варианты.
[57:27.580 --> 57:32.540]  Как строится наибольшая возрастающая подпосредственность?
[57:33.500 --> 57:59.740]  Давайте построим массив D такой, что D и T – это длина
[57:59.740 --> 58:26.620]  наибольшей возрастающей подпоследовательности оканчивающейся в элементе,
[58:26.620 --> 58:39.740]  с индексом и массив.
[58:39.740 --> 58:45.100]  Вот, ну как мы будем строить этот массив? Что это означает?
[58:45.100 --> 58:51.100]  Массив D и T. Вот давайте с вами опять вернемся к той же последовательности,
[58:51.100 --> 59:05.180]  которая у меня была 1-5-8, давайте сюда перепишу, 1-5-8, что там еще? 7-3-4, 7-3-4.
[59:05.180 --> 59:14.780]  Вот этот массив х, я хочу построить массив D. Смотрите, какая наибольшая возрастающая
[59:14.780 --> 59:18.460]  подпоследовательность оканчивается на единичку, если нам известна только лишь она?
[59:21.980 --> 59:33.900]  1. У нее размер 1, то есть сам этот элемент. У минус 5, то есть мы будем открывать элементы поочередно,
[59:33.900 --> 59:43.060]  грубо говоря. Если мы открываем минус 5, то, Кирилл Сергеевич, скажите, какая последовательность
[59:43.060 --> 59:55.980]  с длиной максимальной? 1. А вот если мы откроем восьмерку, что еще раз? Если мы открываем восьмерку,
[59:55.980 --> 01:00:07.740]  то что там будет, Владислав? Или кто там сказал 2? 2 будет. Это либо 1-8, либо минус 5-8, любая споседа.
[01:00:07.740 --> 01:00:19.180]  Если мы открываем еще семерку, то здесь какой ответ будет? Тоже 2. На трех это будет тоже 2. А вот на
[01:00:19.180 --> 01:00:31.420]  четырех это уже будет 3. Смотрите, а где будет лежать ответ, где у нас лежит максимальная
[01:00:31.420 --> 01:00:41.100]  подпоследовательность? В наибольшем элементе. Наибольшем элементе? А, ну или нет, нет, нет.
[01:00:41.100 --> 01:00:51.860]  Так. Ну, в последнем элементе. Нет, нет, нет, непонятно где. Надо отсортировать. Надо просто
[01:00:51.860 --> 01:00:58.380]  найти максимум длины, но при желании, если очень не хочется это делать, хочется сделать так,
[01:00:58.380 --> 01:01:07.100]  чтобы это вошло в остальную программу, которую мы уже сделали. Мы можем добавить лишний элемент
[01:01:07.100 --> 01:01:11.660]  в последовательность, которая больше всех остальных, если мы, например, знаем ограничение,
[01:01:11.660 --> 01:01:21.980]  чтобы иметь в конце. Нам просто надо тут посмотреть, где наибольшая длина в нашей последовательности
[01:01:21.980 --> 01:01:29.540]  получилось. Ну, то есть, грубо говоря, да, действительно, по факту нам нужно найти максимум.
[01:01:29.540 --> 01:01:34.620]  Если бы я в эту последовательность добавил здесь, к примеру, 0, то у меня в конце был бы ответ,
[01:01:34.620 --> 01:01:43.900]  но я думаю, вы все понимаете, что 2. Ну, минус 5 и 0. И он не лежит в конце. И вот это та задача,
[01:01:43.900 --> 01:01:48.580]  где необходимо найти ответ именно просто как максимум по всей этой последовательности.
[01:01:48.580 --> 01:01:53.700]  А сколько это будет работы поиска максимума? Можно, конечно, соптимизировать так, что мы
[01:01:53.700 --> 01:02:00.540]  будем искать одновременно с этим всем все остальное. Но суть в том, что мы все равно будем искать это,
[01:02:00.540 --> 01:02:07.700]  как массив заполняется. Ну, мы сначала заполнен там D от нуля, потом D от единички и так далее.
[01:02:07.700 --> 01:02:16.820]  То есть, у нас как будет проверяться? Мы будем работать следующим образом. Рассмотрим какой-то
[01:02:16.900 --> 01:02:25.700]  из элементов. Например, давайте вот эту тройку. Мы не знаем еще какое число там поставить. Ну,
[01:02:25.700 --> 01:02:32.460]  как мы будем искать? А давайте посмотрим все предыдущие наши элементы, все предыдущие,
[01:02:32.460 --> 01:02:41.820]  и увидим там, где элемент у нас меньше чем 3, мы можем в конец добавить тройку. Правильно? Ну,
[01:02:41.820 --> 01:02:51.180]  поставим. И тогда давайте поставим туда и сделаем плюс один от этого всего и получим
[01:02:51.180 --> 01:02:58.340]  наши результаты. То есть, мы будем сравнивать 3 со всеми элементами до и увеличивать на единицу
[01:02:58.340 --> 01:03:05.020]  относительно того, что у нас есть. Однако, если элемент оказался там меньше. Однако,
[01:03:05.020 --> 01:03:11.060]  нам нужно все равно найти там максимум. Поэтому здесь надо там написать будет немножко по другому.
[01:03:11.060 --> 01:03:18.380]  Вот. Давайте здесь все же напишем псевдокод к этому всему, как это правильно считается,
[01:03:18.380 --> 01:03:26.140]  но здесь все достаточно, наверное, просто. А можно вопрос наперед? А тут разве не
[01:03:26.140 --> 01:03:33.180]  будет сложности от n квадрат? Будет. Первоначально мы сейчас рассматриваем построение за n квадрат.
[01:03:33.180 --> 01:03:39.980]  Хорошо. Если мы сегодня не успеем построение за n логен, с вами рассмотрят это на семинаре.
[01:03:39.980 --> 01:03:50.420]  Ясно? Да, хорошо. Мы к этому как раз и придем сейчас. Вот. Пусть у меня там массив есть,
[01:03:50.420 --> 01:04:05.180]  не знаю, какой-нибудь а. Давайте сделаю снова странички. Массив а, размер n. Я хочу найти длину
[01:04:05.180 --> 01:04:11.700]  максимальную, которая у меня в принципе есть в этом массиве. Тогда мне достаточно сделать
[01:04:11.700 --> 01:04:19.900]  следующее. Написать здесь. Ну, у меня есть еще массив d. D, который там тоже в начале есть,
[01:04:19.900 --> 01:04:31.340]  и у него тоже размеры. Я просто делаю следующее for и равное нулю то там n-1. Я говорю, что d и t
[01:04:31.340 --> 01:04:45.300]  равно 1. После этого я говорю for, g равное нулю, получается до и-1 элемента. То есть рассматриваю
[01:04:45.300 --> 01:04:58.220]  абсолютно все предыдущие элементы. И в случае, если у меня а gt меньше, чем а и t, то есть если у
[01:04:58.220 --> 01:05:13.300]  меня вот это вот есть то, что я могу а и t добавить в конец, и d от g плюс 1, то есть тот элемент,
[01:05:13.300 --> 01:05:17.580]  который меньше, если я добавлю туда элемент еще один, у него будет на один больше в этой
[01:05:17.580 --> 01:05:22.460]  последовательности. То есть dg плюс 1 последовательность будет такая, будет больше,
[01:05:22.460 --> 01:05:30.860]  чем то, что у меня сейчас находится в моем элементе и, то в этом случае, то в этом случае я говорю
[01:05:30.860 --> 01:05:45.740]  следующее, что у меня d и t равно dg t плюс 1. Я здесь так писал, давайте без скобочек.
[01:05:45.740 --> 01:06:01.020]  Я же писал без скобочек. Вот. И тогда максимальная длина равна максимуму из d.
[01:06:01.020 --> 01:06:05.180]  А вот еще раз, что в каких массивах у нас хранится?
[01:06:05.180 --> 01:06:14.900]  Массив a является первым массивом. Ну то есть массив заданных чиселок. Массив d – это тот
[01:06:15.220 --> 01:06:21.820]  массив d, в котором мы будем хранить то, что нам необходимо. Ну то есть вот это вот длину нашей
[01:06:21.820 --> 01:06:31.420]  последовательности, возрастающей наибольшую. Понятно? Вот. Как восстанавливается ответ? То есть
[01:06:31.420 --> 01:06:36.060]  восстановление ответа тоже будет на вас, потому что его вам необходимо будет восстанавливать. А
[01:06:36.060 --> 01:06:41.140]  как можно восстанавливать ответ? А очень просто в этой задаче можно восстановить ответ. А давайте
[01:06:41.140 --> 01:06:48.980]  сделаем следующее. Пусть у нас есть, помимо массива d, есть еще массив предыдущих. Где у нас
[01:06:48.980 --> 01:06:58.260]  будет приходить индекс, откуда мы пришли? Просто вот откуда мы приходили. И если у нас здесь стоит
[01:06:58.260 --> 01:07:03.100]  единичка, то мы ниоткуда не пришли. Это само число является этой подпоследовательностью. Правильно?
[01:07:03.100 --> 01:07:09.220]  Правильно. Для восьмерки мы пришли к восьмерке от единички, судя по тому алгоритму, который я
[01:07:09.220 --> 01:07:15.460]  написал, потому что мы начинаем с нуля. Если мы начинали с конца в начало, то было бы там единичка.
[01:07:15.460 --> 01:07:20.780]  То есть здесь ноль. Индекс откуда мы пришли. В семерку мы также пришли с нуля. В тройку мы
[01:07:20.780 --> 01:07:26.980]  пришли с нуля. А вот в четверку мы пришли с раз, два, три, четыре, пять. И с четвертого элемента.
[01:07:26.980 --> 01:07:35.500]  В нолик мы пришли также с единички. И вот как мы будем ходить? Мы выводим само число, когда мы
[01:07:35.500 --> 01:07:44.740]  нашли максимальную длину. Мы выводим само число. Мы с единицами пришли в ноль.
[01:07:44.740 --> 01:07:56.820]  Да, с минус 5, извините. Все правильно. Отлично, здесь будет один. Вот, мы находим максимальное число.
[01:07:56.820 --> 01:08:04.380]  Максимальное число. А это три. Вот она максимальная подпоследовательность. Тогда мы записываем с вами
[01:08:04.380 --> 01:08:12.300]  4. И идем к предыдущему. Предыдущий находится на четвертом индексе. Но четвертый индекс не
[01:08:12.300 --> 01:08:19.420]  сложно обратиться. За 1 мы можем. Это 3. А дальше у него предыдущий индекс это ноль. Таким образом,
[01:08:19.420 --> 01:08:23.820]  возрастающий подпоследовательность равна 0, 3, 4. То есть опять наоборот. То есть мы опять идем с
[01:08:23.820 --> 01:08:31.500]  конца в начало. Понятно, как восстанавливается ответ? Ой, 0, 3, 4. 1, 3, 4. Извините. Нолевой индекс
[01:08:31.500 --> 01:08:46.300]  от единичка. Ясно? Вопросы к этому построению есть? А можете еще раз вернуть в реализацию?
[01:08:46.300 --> 01:08:55.420]  Конечно, могу. Реализация вот такая. Не очень сложная. Ну и как вы понимаете,
[01:08:55.420 --> 01:09:04.940]  этот алгоритм работает за о от n квадрата. Потому что мы на каждом элементе просмотрим все
[01:09:04.940 --> 01:09:11.900]  предыдущие. То есть первый там просмотрит 0 элементов, второй 1, третий там 2 и так далее.
[01:09:11.900 --> 01:09:16.980]  Это будет арифметическая прогрессия. Будет там n на n плюс 1 пополам. О от n квадрата. Ясно?
[01:09:16.980 --> 01:09:30.620]  Окей. И давайте я сейчас кратко расскажу, потому что там вопросов должно быть гораздо больше. Но
[01:09:30.620 --> 01:09:38.220]  постараюсь объяснить все, что есть. Существует решение за n логы. То есть быстрее. Вот у вас
[01:09:38.220 --> 01:09:56.380]  есть задача. Просто НВП и быстрое построение НВП. Быстрое построение это n логы. Построение за
[01:09:56.380 --> 01:10:16.180]  о от n лог. Давайте мы изменим наш массив d. Пусть у меня в d и там, сейчас так, пусть. Пусть
[01:10:16.180 --> 01:10:30.100]  d и t. Ну там от 0 до n. Давайте на всякий случай напишу и равное 0 и так далее n. Это число,
[01:10:30.100 --> 01:10:42.260]  на которое. Только я минус 1 наверное. Нет. Сейчас вы поймете, что такое d, поймете почему так.
[01:10:42.260 --> 01:10:58.820]  Это число, на которое оканчивается. Окончивается. Окончивается возрастающая последовательность,
[01:10:58.820 --> 01:11:03.820]  не наибольшая, просто возрастающая последовательность длины.
[01:11:12.860 --> 01:11:33.740]  Понятно? Изначально мы сделаем d и t. Д0 равно минус бесконечности, а d1 равно, так далее,
[01:11:33.820 --> 01:11:50.220]  равно dn t равно бесконечности. Смотрите, два важных свойства этой динамики. Два
[01:11:50.220 --> 01:12:04.860]  свойства. Первая. Я думаю вы понимаете, что d и минус первая. А, если несколько значений,
[01:12:04.860 --> 01:12:09.220]  смотрите, вот у нас было такое, что у нас есть возрастающая подпоследовательность, может,
[01:12:09.220 --> 01:12:13.460]  а, ну здесь было несколько возрастающих подпоследовательств, но заканчивается они
[01:12:13.460 --> 01:12:20.660]  на четверку. А представим, что у меня было бы здесь несколько вариантов. Было бы 4 и 3. Если у
[01:12:20.660 --> 01:12:35.780]  нас несколько вариантов, то мы в d и t ставим наименьше. Это важно. Если несколько возрастающих
[01:12:35.780 --> 01:12:56.020]  последовательств длины, то выбираем наименьший конец. Это важное еще одно
[01:12:56.020 --> 01:13:03.940]  свойство. Точнее, важные условия динамики. Первое свойство, это то, что d и минус первое меньше
[01:13:03.940 --> 01:13:18.460]  либо равно d i t. Почему так? Ну, это все достаточно просто, потому что у нас на i минус первой позиции
[01:13:18.460 --> 01:13:22.500]  там у нас стоит какое-то число, к примеру, на которое оканчивается возрастающая последовательность.
[01:13:22.500 --> 01:13:29.140]  Если у нас есть большая возрастающая последовательность, то именно с первым числе,
[01:13:29.140 --> 01:13:37.500]  ну представьте следующее. У меня есть последовательность 1, 3, 5. Она длины 3 и заканчивается
[01:13:37.500 --> 01:13:46.380]  на пятерку. А у меня есть там последствия 1,8. Но в d и t я буду хранить наименьшее число. И как
[01:13:46.380 --> 01:13:58.020]  минимум есть вот эта тройка, которая меньше и стоит на i минус первом месте. Поэтому d и минус первое
[01:13:58.020 --> 01:14:03.900]  меньше либо равно d i t. Потому что если мы рассмотрим последовательность длины 3, то в ней
[01:14:03.900 --> 01:14:11.540]  последовательность длины 2 и там вот это последнее число меньше, чем последнее число из последовательности
[01:14:11.540 --> 01:14:17.460]  длины 3. То есть благодаря вот этому мы можем балансировать. Может быть есть число еще меньше,
[01:14:17.460 --> 01:14:24.060]  но учитывая, что мы все время обновляем туда и кладем наименьшее число в конце, которое стоит,
[01:14:24.060 --> 01:14:31.460]  то у нас все хорошо. То есть как минимум вот этого число 3 есть. Это первый момент. Второй
[01:14:31.460 --> 01:14:55.340]  момент, который необходим здесь. Это то, что каждый элемент i и t обновляет максимум
[01:14:55.340 --> 01:15:18.260]  1,1 d i t. То есть при обработке каждого i и t мы обновим максимум один из элементов d i t. Почему так?
[01:15:18.260 --> 01:15:27.900]  Потому что в случае, когда если бы он обновлял два элемента, то у нас бы последовательность,
[01:15:27.900 --> 01:15:36.460]  ну предположим он обновлял там второй и четвертый. Но если бы он обновлял четвертый, то у нас до этого
[01:15:36.460 --> 01:15:42.540]  была бы последовательность возрастающая, которая бы хранилась из этих четырех элементов элементики.
[01:15:42.660 --> 01:15:54.740]  И там второй был бы меньше, чем сам этот аидый. Понятно, что я имею в виду или нет?
[01:15:59.740 --> 01:16:02.300]  Задумайтесь над этими свойствами. Ясны ли они вам?
[01:16:02.300 --> 01:16:13.300]  Люди просто отключаются и понимают. Можете, пожалуйста, еще раз пояснить второе?
[01:16:13.300 --> 01:16:20.140]  Второе. Каждый элемент i и t обновляет только один d i t. Представьте следующее. Вот у меня была
[01:16:20.140 --> 01:16:30.820]  последовательность там 1,3,5. И вот я добавил 4. Смотрите, у меня появились новые последовательности.
[01:16:30.820 --> 01:16:47.220]  1,4, 3,4, 1,3,4. Ну и все вроде. Вот я добавил 4. То есть как бы добавили несколько последовательностей
[01:16:47.220 --> 01:16:55.420]  возрастающих, ну еще сам 4. Все остальные были раньше. Но так как я четверку вот здесь ставлю
[01:16:55.420 --> 01:17:02.820]  в конец, то существует возрастающая подпоследовательность из как минимум двух
[01:17:02.820 --> 01:17:08.700]  элементов. То есть было 3. Ну то есть до этого была возрастающая подпоследовательность 1,3,5
[01:17:08.700 --> 01:17:17.260]  из трех элементов. Теперь я добавил 4. У меня появился 1,3,4. 4 не может обновить последовательности
[01:17:17.260 --> 01:17:22.620]  длины 2. Почему? Потому что если есть последовательность длины 3, то в ней хранится
[01:17:22.620 --> 01:17:31.860]  элемент меньше, гораздо меньше, ну не гораздо, просто меньше, чем это четверка. В этой последовательности
[01:17:31.860 --> 01:17:37.420]  длины 2. А так как у нас в деитом хранится наименьшее число, на которое оканчивается
[01:17:37.420 --> 01:17:42.900]  возрастающая подпоследовательность, то четверка никуда больше встать не могла. А на максимум могла
[01:17:42.900 --> 01:17:52.700]  поменять одно число такое. Так стало понятным? Да, спасибо. Ага, отлично. Меньше либо равно уже. Что еще
[01:17:52.700 --> 01:18:02.580]  раз? Ну в последовательности из двух элементов хранится меньше либо равно. Просто сказали меньше,
[01:18:02.580 --> 01:18:14.460]  строго. Ну если мы рассматриваем возрастающую подпоследовательность, то меньше. А теперь смотрите,
[01:18:14.460 --> 01:18:26.220]  если у меня di-1 меньше либо равно деитово, какой здесь массив? Отсортированный. А если аито
[01:18:26.220 --> 01:18:35.700]  обновляет максимум один элемент, то что в этом случае? В этом случае мы можем делать бен поиск,
[01:18:35.700 --> 01:18:43.060]  правильно, за счет этого и делается логерезмическая сложность. Каким образом мы просто находим место,
[01:18:43.060 --> 01:18:50.460]  куда нам вставить этот элемент аито в нашей последовательности? Давайте на примере это сделаем,
[01:18:50.460 --> 01:18:56.500]  а реализацию тогда уже оставим на семинар. Давайте сделаем какой-нибудь пример. Пример
[01:18:56.500 --> 01:19:03.500]  следующий. Я сейчас не знаю какие числа из головы возьму. Вот давайте мне кто-нибудь их
[01:19:03.500 --> 01:19:09.980]  продиктует, чтобы не сказали, что все куплено, все понятно. Дарья решать некогда, давай. Придумай
[01:19:09.980 --> 01:19:15.100]  мне просто пять любых чисел, чтобы там были какие-нибудь возрастающие подпоследовательности внутри.
[01:19:15.100 --> 01:19:26.300]  Минус 7. Минус 7. Ноль. Ноль. Четыре. Четыре. Пять. Один. Пять. Один. Ну хорошо, получим так.
[01:19:26.300 --> 01:19:33.500]  Давайте с вами поэлементно добавлять в наши деиты элементики. На любом шаге у нас будет,
[01:19:33.500 --> 01:19:39.740]  давайте вот так отделю, на любом шаге у нас будет минус бесконечность и пять бесконечностей. Раз,
[01:19:39.740 --> 01:19:52.140]  два, три, четыре, пять. Вот здесь вот у нас будет нулевой индекс. Первый, второй, третий,
[01:19:52.140 --> 01:19:58.260]  четвертый, пятый. Зачем нужна минус бесконечность? Чтобы нулевой индекс что-то могли ставить. Просто
[01:19:58.260 --> 01:20:05.900]  на самом деле. Ну то есть бинпоиск работал бы корректно. Вот. Дальше у нас появляется первый
[01:20:05.900 --> 01:20:12.580]  шаг, когда мы добавляем минус 7. Минус 7 должно заменить что-то. И мы ставим ее на первое место.
[01:20:12.580 --> 01:20:17.580]  То есть минус 7 самая минимальная последовательность. Там длины какой-то. Поэтому у нас будет
[01:20:17.580 --> 01:20:24.300]  минус бесконечность, минус 7, бесконечность, бесконечность, бесконечность, бесконечность.
[01:20:24.300 --> 01:20:34.060]  Дальше у нас появляется второй шаг. На втором шаге у нас добавляется ноль. Ноль не является
[01:20:34.060 --> 01:20:38.980]  меньше минус 7. Поэтому первое мы не обозначим. Давайте я добавлю сюда вот не четыре, а минус пять.
[01:20:38.980 --> 01:20:44.580]  Чтобы мы как-то что-то добавили. Вот давайте не минус пять, а минус восемь. Чтобы у нас было
[01:20:44.580 --> 01:20:50.580]  обновление, вы увидели как точно это работает. То случайно может перепутать. Вот. Дальше у нас
[01:20:50.580 --> 01:20:57.580]  будет минус бесконечность, минус 7. И есть последовательность длины 2. Это ноль. И ноль как раз
[01:20:57.580 --> 01:21:11.020]  таки, если мы бинарным поиском найдем, его место будет вот здесь. Вот здесь у него будет место.
[01:21:11.020 --> 01:21:18.500]  Поэтому давайте я буду красным рисовать то место, куда мы добавляем. У нас будет минус 7, здесь
[01:21:18.500 --> 01:21:24.540]  появился ноль. Все остальное осталось без изменений. Бесконечность, бесконечность, бесконечность.
[01:21:24.540 --> 01:21:31.100]  Теперь третий шаг. На третьем шаге мы добавляем с вами четверку. Четверка может быть там,
[01:21:31.100 --> 01:21:37.620]  встать на третье место. Почему? Мы просто бин поиском ставим. У нас будет вот здесь вот четыре,
[01:21:37.620 --> 01:21:45.220]  а здесь элементы не изменятся. То есть у нас будет минус бесконечность, минус 7, ноль, бесконечность,
[01:21:45.220 --> 01:21:51.100]  бесконечность. Теперь рассмотрим четвертый шаг, когда мы добавляем минус восемь. Вот когда мы
[01:21:51.100 --> 01:21:58.580]  добавляем минус восемь, мы ищем бин поиском его место. А где находится его место? Вот давайте
[01:21:58.580 --> 01:22:09.620]  я кого-нибудь спрошу, спрошу, спрошу. Вот Вячеслава Панкова, например. Минус восемь.
[01:22:09.620 --> 01:22:22.820]  Смотрите, минус восемь будет вот здесь. Здесь будет минус бесконечность, здесь ноль,
[01:22:22.820 --> 01:22:31.660]  здесь четыре, бесконечность и бесконечность. И теперь у нас есть единичка. Пятый шаг. У нас
[01:22:31.660 --> 01:22:39.180]  будет минус бесконечность. Куда встанет единичка? Давайте я спрошу еще кого-нибудь. Вот давайте
[01:22:39.180 --> 01:22:47.340]  я Елизавету спрошу. Там, где четверка стояла? Там, где стояла единичка, там, где четверка,
[01:22:47.340 --> 01:22:59.380]  неправда. Бин поиск, как работает? А, ну да, все правильно. А все правильно, бин поиск не так
[01:22:59.380 --> 01:23:04.180]  и работает. То есть он первое число, которое больше у него, заменяет. Поэтому у нас будет с вами
[01:23:04.180 --> 01:23:13.580]  минус восемь, ноль, потом здесь будет один, а здесь будет бесконечность, бесконечность.
[01:23:13.580 --> 01:23:21.380]  Таким образом, мы с вами построили. Что является наибольшей длиной, возрастающей под последовательностью?
[01:23:21.380 --> 01:23:26.980]  Является то первое число, где у нас в конце не стоит бесконечность. Мы разве правильно воткнули
[01:23:26.980 --> 01:23:37.860]  минус восемь? Да. Она же стоит после нуля. Ну, факт. Так, и что? У нас же будет ноль,
[01:23:37.860 --> 01:23:45.460]  минус восемь, один, это не возрастающая последовательность. Ноль, минус восемь, один. Так, а что не так с минус восемь?
[01:23:45.460 --> 01:23:52.500]  Ну, мы когда вставляем ее на место минус семь, мы еще должны проверять, что оно не меньше. Не меньше
[01:23:52.620 --> 01:24:03.340]  чего? Ну того, что там было стояло. Ну, минус семь больше, чем минус восемь. Так, сейчас же,
[01:24:03.340 --> 01:24:06.900]  у нас должна получиться возрастающая последовательность. Ноль, минус восемь, один. Это не
[01:24:06.900 --> 01:24:12.380]  возрастающая последовательность. Еще раз, здесь в этой таблице хранится непоследовательность.
[01:24:13.380 --> 01:24:25.340]  Какой пример сделал? Хранится лишь только то, на что оканчивается возрастающая последовательность
[01:24:25.340 --> 01:24:32.860]  длины и, и там в конце стоит наименьшее число. Поэтому на третьем месте в конце стоит единичкой.
[01:24:32.860 --> 01:24:40.300]  И наибольшая возрастающая последовательность имеет длину три. В конце у него стоит единица. А вот
[01:24:40.340 --> 01:24:44.740]  откуда мы пришли в эту единицу? Вам необходимо самостоятельно разбираться,
[01:24:44.740 --> 01:24:51.220]  к примеру. Вот на этом вот мы с вами закончим. Это вы узнаете на семинарах. То есть смотрите,
[01:24:51.220 --> 01:24:58.060]  главное, что вы можете понять из этой таблицы то, что у вас наибольшая длина возрастающей
[01:24:58.060 --> 01:25:10.260]  последовательности равна трем. Если она равна трем, то все хорошо. Ясно? Вот.
[01:25:10.260 --> 01:25:18.300]  А если у нас нестрого возрастающая, у нас же все то же самое? Не строго возрастающая,
[01:25:18.300 --> 01:25:24.700]  здесь уже необходимо подумать. Сейчас я так быстро не могу почему-то ответить на это. Вообще не
[01:25:24.700 --> 01:25:34.740]  должно сильно что-то менять. Ну хотя сейчас. Тогда немножко нужно переделать бинпоиск. Чуть-чуть. То
[01:25:34.740 --> 01:25:41.620]  есть нужно заменять всегда число первое больше. Потому что у вас может получить там 1,1. Если бы
[01:25:41.620 --> 01:25:45.940]  у вас были одинаковые элементы, то этот бинпоиск, который здесь должен быть, он бы заменял число,
[01:25:45.940 --> 01:25:50.980]  которое необходимо. Которое такое же. То есть единицу на единицу, к примеру. То есть там
[01:25:50.980 --> 01:25:55.940]  зависимости от равенства меняется. Ну то есть зависимости от равенства, что вы захотите делать.
[01:25:55.940 --> 01:26:01.580]  Но это вам не нужно особо пока что. Мы рассматриваем именно возрастающую последовательность. Есть ли
[01:26:01.580 --> 01:26:09.700]  вопросы к этому всему? Если нет, то смотрите. Благодаря бинпоиску и месту куда вставить,
[01:26:09.700 --> 01:26:17.700]  этот алгоритм работает за о от n лог n. Почему за n лог n? Потому что мы для каждого числа ищем
[01:26:17.700 --> 01:26:25.060]  его место бинпоиска. У нас там ровно n плюс один элемент. Вот мы берем бинпоиск,
[01:26:25.060 --> 01:26:31.260]  это работает за логарифом. Ищем его первое место, туда вставляем и так далее. Вот нужно
[01:26:31.260 --> 01:26:37.380]  это вам будет реализовать позже. Если у вас нет вопросов, то вы можете быть свободны. Если у
[01:26:37.380 --> 01:26:44.780]  вас вопросы есть, то вы можете их задать всем остальным. До свидания.
