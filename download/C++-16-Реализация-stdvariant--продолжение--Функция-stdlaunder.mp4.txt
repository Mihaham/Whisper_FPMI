[00:00.000 --> 00:11.600]  Вот, собственно, класс-вариант, в нем мы поняли, что храним variateq.union, еще индекс,
[00:11.600 --> 00:17.360]  который говорит о том, как азельтратика сейчас активная, и мы написали, ну, там,
[00:17.360 --> 00:23.320]  с оговорочками разных тонкостей, написали функции GET, консультёр на тихом поняли,
[00:23.320 --> 00:28.240]  что легко и неинтересно, не будем писать, вот, и мы начали разговаривать о том, как
[00:28.240 --> 00:35.840]  реализовать конструкторы. А, да, мы тут написали метафункцию getNetsByType, и, возможно, нам понадобится
[00:35.840 --> 00:41.160]  getType, боимится еще, сейчас подумаем. Вот, и мы начали разговаривать о том, как писать конструкторы.
[00:41.160 --> 00:47.880]  Вот, написание конструкторов варианта — это самая веселая, пожалуй, штука есть. Возможно, только ради
[00:47.880 --> 00:55.600]  этого стоило об этом поговорить. Ну, вообще, можно было бы честно в variate, ну, то есть,
[00:55.600 --> 01:03.720]  сделать ему конструктор от шаблонного типа T и произвольного, то есть, от U, template type U,
[01:03.720 --> 01:11.120]  конструктора 22%, и просто перебирать в этом union, ну, то есть, делать вот этот вот шаблонный цикл,
[01:11.120 --> 01:18.640]  так скажем, пока мы не дойдем, пока мы не увидим, что тип head совпадает с типом, который у нас сейчас,
[01:18.640 --> 01:24.080]  и сконструировать, когда дойдем до нужного. Но это, во-первых, поработало за линейное время в runtime,
[01:24.080 --> 01:31.440]  а во-вторых, это бы не позволяло выбрать лучшую версию, как при перегрузке это происходит, если у нас там
[01:31.440 --> 01:42.400]  int double и string, а нам дали float, то мы должны сконструировать double. Вот, поэтому вот предлагать
[01:42.400 --> 01:50.800]  следующее решение. До этого догадаться самому, я не знаю, кто до этого догадался, кажется, Андрей
[01:50.800 --> 01:58.000]  Александрович, по-моему, писал какую-то статью там о том, как, в общем, какие-то ребята очень такие мощные
[01:58.000 --> 02:05.400]  из комитета, там, очень такие старички, изобрели вот такой способ, значит, мы наследуемся от переменного
[02:05.400 --> 02:12.440]  количества предков, который называется вариант alternative, приватный на следовательстве, вот как это выглядит,
[02:12.440 --> 02:23.560]  вариант alternative с типом te и еще все остальные варианты. Ну, вы вроде все поняли, да, что это, повторяю, все понимают,
[02:23.560 --> 02:30.440]  все понимают, что написано здесь. Тут многоточие, и после этого еще. Единственный вопрос, мы когда, мы как бы проходили
[02:30.440 --> 02:38.040]  отдельно приватное и публичное наследование, отдельно множественное наследование, правила ставятся где, вы понимаете?
[02:38.040 --> 02:43.640]  От всех, если я хочу просто от двух челеков наследоваться приватно, что я должен сделать?
[02:43.640 --> 02:51.800]  Это отличный вопрос, честно говоря, я не знаю, как они сделали parser этого, то есть наследование от переменного количества шаблонных
[02:51.800 --> 03:00.280]  аргументов там появилось в C++, даже не в 11, по-моему разрешили, по-моему, наследование от переменного количества типов
[03:00.280 --> 03:06.200]  появилось позже, чем просто переменного количества шаблонных аргументов, но я не уверен, типа parser дублируется
[03:06.200 --> 03:11.160]  Вы слышали слово «правила» перед каждым вариантом вернутьев, я не знаю, но в данном случае это неважно, потому что у нас
[03:11.160 --> 03:14.440]  все равно класс, а у класса все вот наследование по волчанию приватное.
[03:14.440 --> 03:16.440]  О, да!
[03:16.440 --> 03:19.960]  Нет, ну я думаю, что дублик, да, то есть мы написали правильное.
[03:19.960 --> 03:23.240]  У нас наследуемся от структуры, но наследуется класс.
[03:23.240 --> 03:25.240]  Да-да-да, наслед... ну...
[03:26.760 --> 03:28.760]  Кто наследует, тот определяет.
[03:28.760 --> 03:32.760]  Да, это же он, ну как сын...
[03:32.760 --> 03:34.200]  Не знает ничего про тебя.
[03:34.200 --> 03:39.320]  Нет-нет-нет, сын, что такое приватное наследование? Что сын не показывает нам, от кого он наследовался.
[03:39.320 --> 03:40.520]  А сам он знает об этом?
[03:40.520 --> 03:42.520]  Конечно, сам он знает.
[03:42.520 --> 03:47.800]  Ну, приватное наследование — это сын запрещает внешним человеку видеть, от кого он наследовался.
[03:47.800 --> 03:57.320]  Ну, поэтому private — оно относится к классу, то есть вот это вот private — это область ответственности самого варианта.
[03:57.320 --> 04:01.320]  Каким образом был правильный наслед? Я не понял.
[04:01.400 --> 04:03.400]  Приватно запрещает нам вообще обращаться к базовому классу.
[04:03.400 --> 04:09.400]  В смысле обращаться... private запрещает внешнему человеку использовать этот факт, что ты наследник.
[04:09.400 --> 04:11.400]  Окей, а внутри типа...
[04:11.400 --> 04:15.400]  Конечно, нет, иначе какой смысл наследования вообще?
[04:15.400 --> 04:20.200]  Private — это еще раз напоминаю, что это private наследование.
[04:20.200 --> 04:26.200]  Это такое наследование, что никто, кроме вас самих, не может использовать этот факт, что вы наследник того.
[04:26.200 --> 04:28.200]  Ладно.
[04:28.280 --> 04:32.280]  Но вы, конечно, можете, потому что иначе в чем смысл?
[04:32.280 --> 04:36.280]  Это как приватные поля. У вас есть приватные поля и приватный предок.
[04:36.280 --> 04:38.280]  Но предок — это же ваша часть, по сути.
[04:38.280 --> 04:42.280]  Это же как бы то, что в вас внутри есть.
[04:42.280 --> 04:50.280]  Так вот, вариант Артернацев говорит, что он...
[04:50.280 --> 04:54.280]  Вообще-то у него есть дирайв, потому что вариант Артернацев знает, что он на фене всегда.
[04:54.360 --> 04:58.360]  И он умеет конструироваться вот этого t, от которого он создался.
[04:58.360 --> 05:04.360]  И что он делает? Он просто говорит такой хоп, я туда положу вот это value.
[05:04.360 --> 05:08.360]  С шамлонным параметром t.
[05:08.360 --> 05:10.360]  Вот.
[05:10.360 --> 05:14.360]  А как я его положу? Ну тут нужна функция put.
[05:14.360 --> 05:16.360]  Пишите, напишем функцию put тоже.
[05:16.360 --> 05:22.360]  Да, ну собственно, а что? У нас дальше в варианте написано using, вот это вот все, вариант Артернацев многоточит.
[05:22.440 --> 05:24.440]  Вот все, вариант Артернацев многоточит.
[05:24.440 --> 05:26.440]  Здесь есть такой же вопрос.
[05:26.440 --> 05:28.440]  Можно ли вообще писать using, что нас запитает, что бы?
[05:28.440 --> 05:34.440]  Нельзя, но можно писать...
[05:34.440 --> 05:36.440]  Так.
[05:36.440 --> 05:38.440]  Сейчас, у меня тут вот что-то не то.
[05:38.440 --> 05:40.440]  Опа, опа, опа.
[05:40.440 --> 05:42.440]  Извините, пожалуйста.
[05:42.440 --> 05:44.440]  Позадрешал, да, понимаю, понимаю.
[05:44.440 --> 05:46.440]  Так, давайте...
[05:46.520 --> 05:48.520]  Позадрешали, да.
[05:48.520 --> 05:50.520]  Да.
[05:50.520 --> 05:52.520]  Матам или олимпиадной неравенства.
[05:52.520 --> 05:54.520]  А, значит...
[05:54.520 --> 05:56.520]  А, это вы типа пишете учебник, да?
[05:56.520 --> 05:58.520]  Сколько я знаю?
[06:00.520 --> 06:02.520]  Не совсем, но не важно.
[06:02.520 --> 06:04.520]  Ну пока не написали ни одной новой строчки по, да?
[06:04.520 --> 06:06.520]  Да, я хочу открыть...
[06:06.520 --> 06:08.520]  Я говорю, уже ты из вас.
[06:08.520 --> 06:10.520]  И ничего страшного.
[06:10.520 --> 06:12.520]  Да, да.
[06:12.520 --> 06:14.520]  Ладно, в варианте.
[06:14.600 --> 06:16.600]  Ну, у тебя, да, у нас нет.
[06:16.600 --> 06:18.600]  Все, вы продолжите сидеть, я уйду.
[06:18.600 --> 06:20.600]  Давайте я...
[06:20.600 --> 06:22.600]  Я сейчас попробую variable.
[06:22.600 --> 06:24.600]  Variable arguments.
[06:24.600 --> 06:26.600]  Ой, Господи.
[06:26.600 --> 06:28.600]  На что он так же октябрь обговорил всю пару.
[06:28.600 --> 06:30.600]  О, Господи.
[06:30.600 --> 06:32.600]  Параметр back.
[06:32.600 --> 06:34.600]  Значит...
[06:36.600 --> 06:38.600]  Ну давайте посмотрим.
[06:38.600 --> 06:40.600]  Вот здесь должно быть написано
[06:40.600 --> 06:42.600]  про шаблонные using в том числе.
[06:42.680 --> 06:44.680]  Вот контексты, в которых
[06:44.680 --> 06:46.680]  можно использовать распаковку
[06:46.680 --> 06:48.680]  пакета.
[06:48.680 --> 06:50.680]  Вот, там, base, edify.
[06:50.680 --> 06:52.680]  Вот.
[06:52.680 --> 06:54.680]  Во-первых, можно делать...
[06:56.680 --> 06:58.680]  То, что мы искали, оно внизу.
[06:58.680 --> 07:00.680]  Не на столько, не на столько.
[07:00.680 --> 07:02.680]  There is a declaration.
[07:02.680 --> 07:04.680]  Вот это стимулятор 17 появился.
[07:06.680 --> 07:08.680]  А, SDBR...
[07:08.680 --> 07:10.680]  Мы, кстати, обсужали, почему
[07:10.760 --> 07:12.760]  SDBR, кстати, раньше...
[07:12.760 --> 07:14.760]  Да, кстати.
[07:14.760 --> 07:16.760]  Возможно, поэтому.
[07:20.760 --> 07:22.760]  Нет, почему? Они могли добавить что-то в язык.
[07:22.760 --> 07:24.760]  Раньше это был какой-нибудь
[07:24.760 --> 07:26.760]  compile-reinfinity, а теперь
[07:26.760 --> 07:28.760]  это стал часть языка, и они спокойно добавляют сюда
[07:28.760 --> 07:30.760]  к биотеку. Да, в общем,
[07:30.760 --> 07:32.760]  использование переменного количества
[07:32.760 --> 07:34.760]  шаблонных аргументов
[07:34.760 --> 07:36.760]  в появлении юзинга
[07:36.760 --> 07:38.760]  появилось и в 17.
[07:38.840 --> 07:40.840]  Вообще, этот юзинг-конструктор появился только с 11,
[07:40.840 --> 07:42.840]  а с переменным количеством
[07:42.840 --> 07:44.840]  появился с 17.
[07:44.840 --> 07:46.840]  Вот, а base-specifiers
[07:46.840 --> 07:48.840]  появилось уже по 11.
[07:48.840 --> 07:50.840]  Прикол.
[07:50.840 --> 07:52.840]  Ну ладно.
[07:54.840 --> 07:56.840]  Почему вначале добавляют фичи, а потом думают,
[07:56.840 --> 07:58.840]  где их менять?
[07:58.840 --> 08:00.840]  Нет, почему? Вполне возможно, что они добавляют фичи
[08:00.840 --> 08:02.840]  как раз... Вот, например, рэп играет,
[08:02.840 --> 08:04.840]  они добавили как раз потому, что здесь это надо.
[08:04.840 --> 08:06.840]  Ну, они могли продумать,
[08:06.920 --> 08:08.920]  но...
[08:08.920 --> 08:10.920]  Нет, скорее они добавили...
[08:10.920 --> 08:12.920]  Нет, они именно понимают,
[08:12.920 --> 08:14.920]  что неплохо было бы иметь такую конструкцию,
[08:14.920 --> 08:16.920]  для чего они добавляют, я думаю. Короче,
[08:16.920 --> 08:18.920]  ну все, в принципе, все работает.
[08:18.920 --> 08:20.920]  Осталось только путь написать.
[08:20.920 --> 08:22.920]  Конструкторы работают.
[08:22.920 --> 08:24.920]  Как путь написать?
[08:24.920 --> 08:26.920]  В смысле, конструктор работает, а мы ничего уже не забывали.
[08:26.920 --> 08:28.920]  Все, что нужно,
[08:28.920 --> 08:30.920]  у нас уже написано.
[08:31.000 --> 08:33.000]  А можно варианты?
[08:35.000 --> 08:37.000]  Все, что есть варианты,
[08:37.000 --> 08:39.000]  конструктора T,
[08:39.000 --> 08:41.000]  ну и вот это.
[08:41.000 --> 08:43.000]  Значит,
[08:43.000 --> 08:45.000]  давайте путь напишем.
[08:45.000 --> 08:47.000]  Что надо здесь написать?
[08:47.000 --> 08:49.000]  Войт?
[08:49.000 --> 08:51.000]  Там был T, да,
[08:51.000 --> 08:53.000]  type name T.
[08:53.000 --> 08:55.000]  А что?
[08:55.000 --> 08:57.000]  Войт, наверное, тут.
[08:57.000 --> 08:59.000]  Что?
[08:59.080 --> 09:01.080]  5%?
[09:01.080 --> 09:03.080]  Value?
[09:03.080 --> 09:05.080]  Еще там 4 варианта?
[09:05.080 --> 09:07.080]  Ну, это понятно.
[09:07.080 --> 09:09.080]  Что здесь?
[09:09.080 --> 09:11.080]  Положи, чему 4 варианта?
[09:11.080 --> 09:13.080]  Да, мне нужно...
[09:13.080 --> 09:15.080]  Нужно знать,
[09:15.080 --> 09:17.080]  куда конструктор.
[09:17.080 --> 09:19.080]  Просто можно там...
[09:19.080 --> 09:21.080]  Да, так что надо сделать?
[09:21.080 --> 09:23.080]  В каком контексте она используется?
[09:23.080 --> 09:25.080]  Только в конструкторе?
[09:25.080 --> 09:27.080]  Ну пока, да, но пока только для этого пишем.
[09:27.160 --> 09:29.160]  Удалять пока ничего не надо?
[09:29.160 --> 09:31.160]  Потом удалять мы будем,
[09:31.160 --> 09:33.160]  но это потом.
[09:33.160 --> 09:35.160]  Да, сейчас мы еще дистрибку напишем.
[09:35.160 --> 09:37.160]  Если конструктор, а что?
[09:37.160 --> 09:39.160]  А неважно, какая разница?
[09:39.160 --> 09:41.160]  Как это неважно?
[09:41.160 --> 09:43.160]  Theta hat?
[09:43.160 --> 09:45.160]  Нет, нам надо...
[09:45.160 --> 09:47.160]  Нам надо...
[09:47.160 --> 09:49.160]  Вот, кстати,
[09:49.160 --> 09:51.160]  нам надо как-то еще...
[09:51.160 --> 09:53.160]  Вот здесь я не совсем правильно сказал,
[09:53.160 --> 09:55.160]  у нас еще индекс нужно положить правильный.
[09:55.240 --> 09:57.240]  Нам же нужно индекс запомнить.
[09:59.240 --> 10:01.240]  Зачем?
[10:01.240 --> 10:03.240]  Потому что у него индекс...
[10:03.240 --> 10:05.240]  Вариант должен записан быть...
[10:05.240 --> 10:07.240]  Какой индекс сейчас активный?
[10:07.240 --> 10:09.240]  Да, но где это индекс?
[10:09.240 --> 10:11.240]  Он сейчас запишет, нет?
[10:11.240 --> 10:13.240]  Кто запишет? Я сказал...
[10:13.240 --> 10:15.240]  А, в пут мы запишем.
[10:15.240 --> 10:17.240]  А куда запишем мы это?
[10:17.240 --> 10:19.240]  В пут внутри Юния имеет.
[10:19.240 --> 10:21.240]  В пут внутри Юния?
[10:21.240 --> 10:23.240]  О, Господи!
[10:23.320 --> 10:25.320]  Да.
[10:25.320 --> 10:27.320]  Ну, значит, надо бы в конструкторе добавить строчку.
[10:27.320 --> 10:29.320]  Да.
[10:35.320 --> 10:37.320]  Это все правильно, кстати?
[10:37.320 --> 10:39.320]  Типа, наши нижние.
[10:43.320 --> 10:45.320]  Да, да, да, это все...
[10:45.320 --> 10:47.320]  Ну, сам Variant Union, он в...
[10:47.320 --> 10:49.320]  Вообще, вовне варианта.
[10:49.320 --> 10:51.320]  Мы сделали.
[10:51.400 --> 10:53.400]  Мы сделали.
[10:55.400 --> 10:57.400]  То есть, я могу чисто Variant Union?
[10:57.400 --> 10:59.400]  А-а-а...
[11:01.400 --> 11:03.400]  Возможно, правильнее было бы сделать структуру,
[11:03.400 --> 11:05.400]  которая содержит в себе
[11:05.400 --> 11:07.400]  Union, вот этот, и индекс.
[11:09.400 --> 11:11.400]  И в этом...
[11:11.400 --> 11:13.400]  Эта пут определять уже в этой структуре.
[11:13.400 --> 11:15.400]  И тут...
[11:15.400 --> 11:17.400]  Индекс, соответственно,
[11:17.400 --> 11:19.400]  расставить.
[11:19.480 --> 11:21.480]  Мне вообще так кажется.
[11:25.480 --> 11:27.480]  Вот, ну то есть нам в любом случае надо индекс поставить,
[11:27.480 --> 11:31.480]  но для этого надо, чтобы Variant Alternative знал какой-нибудь индекс еще.
[11:31.480 --> 11:33.480]  Вот, а как нам это сделать?
[11:33.480 --> 11:35.480]  Ну,
[11:35.480 --> 11:37.480]  нам на самом деле вот как можно это сделать.
[11:37.480 --> 11:39.480]  Вот здесь Variant Alternative
[11:39.480 --> 11:41.480]  я просто напишу
[11:41.480 --> 11:43.480]  и я не буду поле ему заводить,
[11:43.480 --> 11:45.480]  я ему скажу static course
[11:45.480 --> 11:47.480]  sizeT
[11:47.560 --> 11:49.560]  И индекс, он же...
[11:49.560 --> 11:51.560]  Ну, этот индекс, он же...
[11:51.560 --> 11:53.560]  Определен заранее.
[11:53.560 --> 11:55.560]  Определен заранее в compile-time
[11:55.560 --> 11:57.560]  мне не нужно в объекте Variant Alternative его хранить.
[11:57.560 --> 11:59.560]  Просто для каждого экземпляра,
[11:59.560 --> 12:01.560]  для каждого инстанцированного Variant Alternative
[12:01.560 --> 12:03.560]  индекс будет известен.
[12:03.560 --> 12:05.560]  А что это будет такое?
[12:05.560 --> 12:07.560]  Ну, это и будет getIndexByType
[12:07.560 --> 12:09.560]  тот самый.
[12:09.560 --> 12:11.560]  Какой?
[12:11.560 --> 12:13.560]  Вот t-Types
[12:13.560 --> 12:15.560]  2.2.vl
[12:15.640 --> 12:17.640]  getIndexByType.vl
[12:17.640 --> 12:19.640]  Ну да, вот уже есть getIndexByType.vl
[12:19.640 --> 12:21.640]  То есть, на самом деле
[12:21.640 --> 12:23.640]  нам даже здесь не надо
[12:23.640 --> 12:25.640]  ничего мудрить, а просто
[12:25.640 --> 12:27.640]  я вот здесь запишу
[12:27.640 --> 12:29.640]  Ааа...
[12:29.640 --> 12:31.640]  Мы еще, кстати, не решили в предыдущий раз
[12:31.640 --> 12:33.640]  проблему, потому что у нас сверху объявлен Variant
[12:33.640 --> 12:35.640]  но у Variant есть Storage
[12:35.640 --> 12:37.640]  и поэтому мы будем при этом провести.
[12:37.640 --> 12:39.640]  Давайте я скажу this.ptr
[12:39.640 --> 12:41.640]  это вот это вот static course derived
[12:41.640 --> 12:43.640]  this
[12:45.560 --> 12:47.560]  и
[12:47.560 --> 12:49.560]  this.ptr
[12:49.560 --> 12:51.560]  сначала я скажу storage
[12:51.560 --> 12:53.560]  положим туда эту штуку
[12:53.560 --> 12:55.560]  а дальше
[12:55.560 --> 12:57.560]  я скажу
[12:57.560 --> 12:59.560]  this.ptr
[12:59.560 --> 13:01.560]  да, this.ptr
[13:01.560 --> 13:03.560]  а дальше я скажу
[13:03.560 --> 13:05.560]  this.ptr
[13:05.560 --> 13:07.560]  индекс
[13:07.560 --> 13:09.560]  равно
[13:09.560 --> 13:11.560]  индекс
[13:11.560 --> 13:13.560]  вот
[13:13.560 --> 13:15.560]  я могу
[13:15.560 --> 13:17.560]  ну давайте скажу index большой буквы
[13:17.560 --> 13:19.560]  чтобы было красиво
[13:19.560 --> 13:21.560]  вот
[13:21.560 --> 13:23.560]  да
[13:23.560 --> 13:25.560]  и вот
[13:25.560 --> 13:27.560]  но это
[13:27.560 --> 13:29.560]  константа же
[13:29.560 --> 13:31.560]  статичная константа
[13:31.560 --> 13:33.560]  ка вначале
[13:33.560 --> 13:35.560]  ну да
[13:35.560 --> 13:37.560]  ка значит констант
[13:37.560 --> 13:39.560]  с индексом
[13:39.560 --> 13:41.560]  ка и на кей
[13:41.560 --> 13:43.560]  да
[13:43.560 --> 13:45.560]  константа
[13:45.560 --> 13:47.560]  кей
[13:47.560 --> 13:49.560]  а вот
[13:49.560 --> 13:51.560]  на самом деле
[13:51.560 --> 13:53.560]  это все-таки не очень не нравится, потому что
[13:53.560 --> 13:55.560]  мы же
[13:55.560 --> 13:57.560]  я уже не понимаю
[13:59.560 --> 14:01.560]  я еще не понимаю
[14:01.560 --> 14:03.560]  у нас же типа
[14:03.560 --> 14:05.560]  а у нас там все types
[14:05.560 --> 14:07.560]  ну короче
[14:07.560 --> 14:09.560]  их все не нравится
[14:09.560 --> 14:11.560]  мы же конструировали Ιд mı
[14:11.560 --> 14:13.560]  а потом должны быть
[14:13.560 --> 14:15.560]  когда мы конструировали quiz
[14:15.560 --> 14:17.560]  он принципизирует
[14:17.560 --> 14:19.560]  эти поля
[14:19.560 --> 14:25.560]  что назвать
[14:25.560 --> 14:27.560]  что значит
[14:27.560 --> 14:32.360]  что значит
[14:32.360 --> 14:34.360]  короче
[14:34.520 --> 14:36.520]  то есть на самом деле
[14:36.520 --> 14:41.800]  Выполняем. Скорее всего, он сначала принесет все по умолчанию,
[14:41.800 --> 14:48.360]  поэтому пойдет в тело конструктора. Да, наверное так, потому что иначе было бы
[14:48.360 --> 14:51.720]  странно, иначе как мы из...
[14:53.720 --> 14:59.240]  Чего я буду... Он же всегда у нас тоже собирается, скорее тогда, а потом уже потом приходит.
[14:59.240 --> 15:03.240]  Так мы из твоего конструктора, конструктор нас.
[15:03.960 --> 15:10.760]  Да, короче, что-то я вот задумался, не знаю, возможно это...
[15:10.760 --> 15:18.760]  Секундочку. Возможно, он будет в другом порядке делать, и тогда такая реализация не очень хорошая.
[15:18.760 --> 15:20.760]  И проблема не в индексе.
[15:20.760 --> 15:26.760]  Мы делаем у человека, который еще не создан.
[15:26.760 --> 15:30.760]  Это да, не очень хорошо.
[15:31.280 --> 15:33.280]  Ну, эту проблему потом решим. Что?
[15:33.280 --> 15:36.280]  Решили проблему, что у нас вариант отремонта не знает сториджа.
[15:36.280 --> 15:38.280]  В смысле, не знает сториджа?
[15:40.280 --> 15:44.280]  В смысле, объявляешь вариант сверху, потом пишешь везде вместо функции про это.
[15:44.280 --> 15:46.280]  А, ну может даже скомпилируется.
[15:46.280 --> 15:49.280]  Давайте попробуем это скомпилировать. Не хотел я, правда, их начинать делать.
[15:49.280 --> 15:53.280]  А оно вроде скомпилируется. Я каждый раз скомпилировал.
[15:54.280 --> 15:58.280]  Кстати, не так уж много и ошибок. 161, что у меня 161.
[15:58.800 --> 16:00.800]  Кто нерв где-то?
[16:00.800 --> 16:02.800]  Кость.
[16:02.800 --> 16:04.800]  Что?
[16:04.800 --> 16:06.800]  Это закоэминичный мейн, понятное дело.
[16:06.800 --> 16:10.800]  У меня скобочный баланс засоблюден, видимо, где-то.
[16:10.800 --> 16:12.800]  Закрываешь столки в мейне.
[16:12.800 --> 16:14.800]  Есть.
[16:14.800 --> 16:16.800]  Вот она.
[16:16.800 --> 16:18.800]  Так, это грустно.
[16:18.800 --> 16:20.800]  Так, может CLM?
[16:20.800 --> 16:22.800]  Нет, получше скажешь.
[16:22.800 --> 16:24.800]  А то скобочный баланс засоблюден.
[16:25.320 --> 16:27.320]  Ааа...
[16:27.320 --> 16:29.320]  Трэшка чхэшка?
[16:29.320 --> 16:31.320]  Да, во-первых, я забыл многоточие здесь.
[16:35.320 --> 16:37.320]  Вот здесь.
[16:37.320 --> 16:41.320]  Так, что дальше?
[16:41.320 --> 16:45.320]  Declaration of tapes, types, shadows, template, parameters.
[16:45.320 --> 16:47.320]  Отличное отмечание.
[16:49.320 --> 16:51.320]  А, я...
[16:51.320 --> 16:53.320]  Все это оттуда же идет.
[16:53.840 --> 16:55.840]  Сейчас, declaration of tapes.
[16:58.840 --> 17:00.840]  Почему так?
[17:00.840 --> 17:02.840]  Это не здесь.
[17:02.840 --> 17:04.840]  А, в 78-й строке.
[17:04.840 --> 17:06.840]  А, вот оно что.
[17:06.840 --> 17:08.840]  Ну да, здесь нужно другое.
[17:08.840 --> 17:12.840]  Да, вот так.
[17:12.840 --> 17:14.840]  Да, вот здесь.
[17:14.840 --> 17:16.840]  Конфликт имен.
[17:16.840 --> 17:18.840]  51 expected expression.
[17:18.840 --> 17:20.840]  Это где у меня expected expression?
[17:20.840 --> 17:22.840]  А, понятно.
[17:23.360 --> 17:25.360]  Давайте все-таки допишем.
[17:25.360 --> 17:27.360]  Так, если что...
[17:29.360 --> 17:31.360]  Не, ну в принципе, можно было бы просто сказать,
[17:31.360 --> 17:33.360]  что я беру адрес.
[17:33.360 --> 17:35.360]  Тут можно даже, наверное, visitconstexport
[17:35.360 --> 17:37.360]  просто сказать, что...
[17:37.360 --> 17:39.360]  Ну, это же union. Какая разница?
[17:39.360 --> 17:41.360]  Я просто...
[17:43.360 --> 17:45.360]  Что мы в head вообще хотели?
[17:45.360 --> 17:47.360]  Ну, если T это head,
[17:47.360 --> 17:49.360]  то на месте heads конструировать head.
[17:49.360 --> 17:51.360]  А иначе пойти и сделать put
[17:51.880 --> 17:53.880]  в тот union, который второй.
[17:55.880 --> 17:57.880]  Давайте подумаем,
[17:57.880 --> 17:59.880]  могу ли я написать просто вот
[17:59.880 --> 18:01.880]  сейчас без всякого их констатиста
[18:01.880 --> 18:03.880]  просто сказать new от
[18:03.880 --> 18:05.880]  от вот этого
[18:07.880 --> 18:09.880]  T от value.
[18:11.880 --> 18:13.880]  Ну, конечно, так бы не сказать,
[18:13.880 --> 18:15.880]  потому что 3D-предкаст придется делать какой-то.
[18:16.400 --> 18:18.400]  А...
[18:20.400 --> 18:22.400]  Наверное, это даже будет работать.
[18:22.400 --> 18:24.400]  Почему?
[18:24.400 --> 18:26.400]  Ну, в смысле, если я
[18:26.400 --> 18:28.400]  интерпреткастом сейчас здесь забывал.
[18:28.400 --> 18:30.400]  Почему работает не тот тип?
[18:30.400 --> 18:32.400]  И что?
[18:32.400 --> 18:34.400]  Так, я просто беру адрес, я интерпреткащу
[18:34.400 --> 18:36.400]  его, указать именно то, что мне надо, и все.
[18:36.400 --> 18:38.400]  Корейцы, у них адреса, так все равно же.
[18:38.400 --> 18:40.400]  Ага, у всех одинаковые адреса.
[18:40.400 --> 18:42.400]  А может такой вопрос? Да.
[18:42.400 --> 18:44.400]  У нас, у нас, вроде, в union есть конструктор по умолчанию?
[18:44.920 --> 18:46.920]  У кого?
[18:46.920 --> 18:48.920]  Нет, у него нет.
[18:48.920 --> 18:50.920]  А почему он не создается?
[18:50.920 --> 18:52.920]  Кто по умолчанию создается?
[18:52.920 --> 18:54.920]  Он не создается.
[18:54.920 --> 18:56.920]  Он пока...
[18:56.920 --> 18:58.920]  Ну, он не создастся, нет.
[18:58.920 --> 19:00.920]  Ну, если тип уникальвиальный, он не создастся.
[19:00.920 --> 19:02.920]  И его нужно написать будет.
[19:02.920 --> 19:04.920]  И слова default там тоже нету, да?
[19:06.920 --> 19:08.920]  Ну, в данном случае default
[19:08.920 --> 19:10.920]  ничего не сможет сделать, скорее всего,
[19:10.920 --> 19:12.920]  потому что он не поймет, что именно надо сконструировать.
[19:13.440 --> 19:15.440]  Кажется, у нас default уникал.
[19:15.440 --> 19:17.440]  Вот.
[19:17.440 --> 19:19.440]  В общем.
[19:19.440 --> 19:21.440]  Просто именно в этом ошибке, когда я пытаюсь
[19:21.440 --> 19:23.440]  сказать. Так, давайте
[19:23.440 --> 19:25.440]  я все-таки, не нравится мне так делать,
[19:25.440 --> 19:27.440]  давайте я все-таки честно напишу.
[19:27.440 --> 19:29.440]  If constexpr std is same where
[19:31.440 --> 19:33.440]  от t,
[19:33.440 --> 19:35.440]  запятая head,
[19:35.440 --> 19:37.440]  я создам new
[19:39.440 --> 19:41.440]  по адресу head
[19:41.960 --> 19:43.960]  t в value
[19:43.960 --> 19:45.960]  а иначе
[19:45.960 --> 19:47.960]  я сделаю put
[19:48.960 --> 19:50.960]  с шаблонным параметром t
[19:50.960 --> 19:52.960]  от
[19:52.960 --> 19:54.960]  ну, иначе
[19:54.960 --> 19:56.960]  я в tail просто сделаю put
[19:56.960 --> 19:58.960]  с шаблонным параметром t, там же самое value.
[20:00.960 --> 20:02.960]  Вот так, по крайней мере,
[20:02.960 --> 20:04.960]  не будет убе формально, когда я буду обращаться
[20:04.960 --> 20:06.960]  к полям unit. Ну, то есть, я
[20:06.960 --> 20:08.960]  хотя бы правильно члены проинциализировал,
[20:08.960 --> 20:10.960]  то есть, я new вызвал по, ну, по адресу
[20:10.960 --> 20:12.960]  нужной штуки, а не по адресу
[20:12.960 --> 20:14.960]  не той штуки.
[20:14.960 --> 20:16.960]  То есть, я как бы,
[20:16.960 --> 20:18.960]  по крайней мере, формально правильно
[20:18.960 --> 20:20.960]  нужно писать tail.templateput
[20:20.960 --> 20:22.960]  Да, это правда.
[20:22.960 --> 20:24.960]  Сейчас бы мне Силенка об этом сказал.
[20:26.960 --> 20:28.960]  Да.
[20:32.960 --> 20:34.960]  Чего?
[20:34.960 --> 20:36.960]  А мы put вызываем
[20:36.960 --> 20:38.960]  с конкретным типом всегда.
[20:38.960 --> 20:40.960]  Вот именно здесь мы решаем эту проблему.
[20:40.960 --> 20:42.960]  Выберется версия
[20:42.960 --> 20:44.960]  перегрузки, наиболее подходящая,
[20:44.960 --> 20:46.960]  а это tail уже будет конкретно в одним из тех
[20:46.960 --> 20:48.960]  tail, иначе мы
[20:48.960 --> 20:50.960]  в варианте turnative tail всегда в одной из тех
[20:50.960 --> 20:52.960]  types.
[20:52.960 --> 20:54.960]  Так, ну давайте попробуем теперь это
[20:54.960 --> 20:56.960]  скомпилировать.
[20:58.960 --> 21:00.960]  А...
[21:02.960 --> 21:04.960]  Хорошо.
[21:04.960 --> 21:06.960]  Ну, давай.
[21:06.960 --> 21:08.960]  А концепт по умолчанию у него есть, я надеюсь?
[21:08.960 --> 21:10.960]  Кажется, тоже нет.
[21:10.960 --> 21:12.960]  Интересно.
[21:16.960 --> 21:18.960]  Missing template keyword так,
[21:18.960 --> 21:20.960]  строчка 100,
[21:20.960 --> 21:22.960]  вот здесь template
[21:22.960 --> 21:24.960]  нужна,
[21:24.960 --> 21:26.960]  давайте
[21:26.960 --> 21:28.960]  дальше.
[21:28.960 --> 21:30.960]  Не скомпилируйтесь, потому что...
[21:30.960 --> 21:32.960]  У меня когда
[21:32.960 --> 21:34.960]  где?
[21:34.960 --> 21:36.960]  Где-где?
[21:36.960 --> 21:38.960]  О,
[21:38.960 --> 21:40.960]  index-1 надо, конечно.
[21:40.960 --> 21:42.960]  Да-да-да.
[21:42.960 --> 21:44.960]  Мы не за что здесь не скомпилируем, потому что там
[21:44.960 --> 21:46.960]  нужен конструктор и деструктор в варианте q, не рано.
[21:46.960 --> 21:48.960]  Сейчас, подождите, тут я хочу пока понять,
[21:48.960 --> 21:50.960]  что компилятору не нравится.
[21:50.960 --> 21:52.960]  NoNumberNamed вариант alternative,
[21:52.960 --> 21:54.960]  InMight вариант alternative.
[21:54.960 --> 21:56.960]  А...
[21:56.960 --> 21:58.960]  В чем проблема?
[22:02.960 --> 22:04.960]  Привет.
[22:08.960 --> 22:10.960]  Я смог это стимулировать.
[22:14.960 --> 22:16.960]  Ой, молодец.
[22:16.960 --> 22:18.960]  Так, давайте поймем, что
[22:18.960 --> 22:20.960]  не так.
[22:22.960 --> 22:24.960]  Alternative.
[22:24.960 --> 22:26.960]  А, я просто опечатался, господи.
[22:26.960 --> 22:28.960]  Да, вот это неприятно.
[22:28.960 --> 22:30.960]  Alternative.
[22:30.960 --> 22:32.960]  Я тоже собирался себе
[22:32.960 --> 22:34.960]  стимулировать быстрее.
[22:34.960 --> 22:36.960]  Может, правильнее?
[22:36.960 --> 22:38.960]  Мне кажется, это будет регулярно.
[22:40.960 --> 22:42.960]  Мне кажется, это нам сразу поцелует.
[22:42.960 --> 22:44.960]  Ну, да,
[22:44.960 --> 22:46.960]  я
[22:46.960 --> 22:48.960]  согласен. Наверное, я это сделаю
[22:48.960 --> 22:50.960]  в следующем ученом году.
[22:50.960 --> 22:52.960]  Нет, ладно,
[22:52.960 --> 22:54.960]  наверное, я поставлю. Да, я поставлю.
[22:54.960 --> 22:56.960]  В следующем ученом году уже нельзя быть.
[22:56.960 --> 22:58.960]  Ну, может быть, валить
[22:58.960 --> 23:00.960]  и раскладывать все эти старошилки,
[23:00.960 --> 23:02.960]  как всегда.
[23:02.960 --> 23:04.960]  И раскладываю.
[23:06.960 --> 23:08.960]  И я еще
[23:08.960 --> 23:10.960]  новое придумаю в программу,
[23:10.960 --> 23:12.960]  и надо просто старошилки раскладывать снова.
[23:16.960 --> 23:18.960]  Это...
[23:20.960 --> 23:22.960]  Почему?
[23:22.960 --> 23:24.960]  Потому что
[23:24.960 --> 23:26.960]  because BasePlus
[23:26.960 --> 23:28.960]  default-конструктор.
[23:28.960 --> 23:30.960]  Нам нужен почему-то default-конструктор
[23:30.960 --> 23:32.960]  variant-alternative. Когда мы его напишем,
[23:32.960 --> 23:34.960]  будет проблема, что нет
[23:34.960 --> 23:36.960]  default-конструктора у ValidQNN.
[23:36.960 --> 23:38.960]  Когда мы это исправим, напишем, что нет
[23:38.960 --> 23:40.960]  default-деструктора у ValidQNN.
[23:40.960 --> 23:42.960]  Только когда мы его тоже допишем, даже пускай
[23:42.960 --> 23:44.960]  пустым, вот тогда он скопилируется.
[23:44.960 --> 23:46.960]  Давайте допишем.
[23:52.960 --> 23:54.960]  Мы тут ничего не делаем.
[23:54.960 --> 23:56.960]  Тут мы тоже ничего не делаем.
[23:58.960 --> 24:00.960]  Variadic
[24:00.960 --> 24:02.960]  Junion
[24:02.960 --> 24:04.960]  Мы ничего не делаем.
[24:04.960 --> 24:06.960]  И здесь мы ничего не делаем.
[24:06.960 --> 24:08.960]  Почему он не может им default-ом написать?
[24:08.960 --> 24:10.960]  Потому что нет понятия default-а.
[24:10.960 --> 24:12.960]  Потому что он не понимает, что такое
[24:12.960 --> 24:14.960]  default, это значит, что он должен
[24:14.960 --> 24:16.960]  проницилизировать, какой тип из имеющихся.
[24:18.960 --> 24:20.960]  Так,
[24:20.960 --> 24:22.960]  а теперь у нас нету get
[24:22.960 --> 24:24.960]  int.
[24:24.960 --> 24:26.960]  Ну отлично, можно сказать
[24:26.960 --> 24:28.960]  my get, вместо std-get.
[24:36.960 --> 24:38.960]  Что теперь?
[24:38.960 --> 24:40.960]  Index as a private member
[24:40.960 --> 24:42.960]  это стражка 101.
[24:42.960 --> 24:44.960]  Мы в фраге добавили, кажется.
[24:44.960 --> 24:46.960]  Да, у меня get не друг.
[24:46.960 --> 24:48.960]  Давайте сделаем.
[24:48.960 --> 24:50.960]  Да, я сделал
[24:50.960 --> 24:52.960]  get от
[25:06.960 --> 25:08.960]  Это на все натуры не совпадает.
[25:10.960 --> 25:12.960]  Так,
[25:12.960 --> 25:14.960]  нужно авто
[25:16.960 --> 25:18.960]  43
[25:22.960 --> 25:24.960]  43
[25:26.960 --> 25:28.960]  Я ничего не возвращаю.
[25:28.960 --> 25:30.960]  Точнее, я возвращаю ссылку на бой.
[25:32.960 --> 25:34.960]  Во всяком случае, я возвращаю ссылку на бой.
[25:34.960 --> 25:36.960]  Когда у нас, мы же переписали
[25:36.960 --> 25:38.960]  get для пустого, и так надо что-то выкинуть.
[25:40.960 --> 25:42.960]  Вагон байд, вагон байд get.
[25:42.960 --> 25:44.960]  Да, император.
[25:46.960 --> 25:48.960]  Возвращайте буль.
[25:48.960 --> 25:50.960]  В самом деле, буль.
[25:50.960 --> 25:52.960]  Блин, я не знаю.
[25:54.960 --> 25:56.960]  Поверьте.
[26:02.960 --> 26:04.960]  Так,
[26:04.960 --> 26:06.960]  что будет это делать?
[26:08.960 --> 26:10.960]  А, не типа просто возвращать, я не знаю,
[26:10.960 --> 26:12.960]  какой-нибудь empty struct.
[26:12.960 --> 26:14.960]  Здесь гранвение, шумы,
[26:14.960 --> 26:16.960]  что-то зацепили.
[26:16.960 --> 26:18.960]  Не было такого.
[26:20.960 --> 26:22.960]  Когда такого не было,
[26:22.960 --> 26:24.960]  и вот опять.
[26:24.960 --> 26:26.960]  Ну, короче, здесь я просто
[26:26.960 --> 26:28.960]  верну empty struct.
[26:28.960 --> 26:30.960]  А, черт,
[26:30.960 --> 26:32.960]  это будет...
[26:36.960 --> 26:38.960]  Ну, что, что?
[26:38.960 --> 26:40.960]  Это будет
[26:40.960 --> 26:42.960]  бита ссылка.
[26:42.960 --> 26:44.960]  Да,
[26:44.960 --> 26:46.960]  это будет вообще бита ссылка.
[26:46.960 --> 26:48.960]  Давайте куда-то не бежим.
[26:50.960 --> 26:52.960]  Какой-то такой...
[26:54.960 --> 26:56.960]  Извините, я заделывал дырю как могу.
[26:58.960 --> 27:00.960]  Так же, мы, когда с моим годом
[27:00.960 --> 27:02.960]  в последствии создавели там
[27:02.960 --> 27:04.960]  такой же прикол, чистый из комментариев.
[27:04.960 --> 27:06.960]  I'm so sorry.
[27:06.960 --> 27:08.960]  Интересные ошибки.
[27:12.960 --> 27:14.960]  Классно.
[27:14.960 --> 27:16.960]  Так, а почему
[27:16.960 --> 27:18.960]  не верну инфы?
[27:24.960 --> 27:26.960]  Так, на самом деле я хочу...
[27:26.960 --> 27:28.960]  Возможно, я вводка поступлю сейчас,
[27:28.960 --> 27:30.960]  я не буду все это исправлять на ходу,
[27:30.960 --> 27:32.960]  я просто открою вам вариант, который у меня
[27:32.960 --> 27:34.960]  написан был заранее, который кипелируется.
[27:34.960 --> 27:36.960]  Там все то же самое, примерно.
[27:36.960 --> 27:38.960]  Просто заранее исправим наши ошибки на компиляции.
[27:38.960 --> 27:40.960]  Давайте я так поступил,
[27:40.960 --> 27:42.960]  иначе мы будем еще 20 минут исправлять CE,
[27:42.960 --> 27:44.960]  мне это не нравится.
[27:46.960 --> 27:48.960]  Короче, мы разобрались с тем,
[27:48.960 --> 27:50.960]  как конструкторы работают.
[27:50.960 --> 27:52.960]  Кажется. Кажется понятно, да,
[27:52.960 --> 27:54.960]  что конструкторы делают.
[27:54.960 --> 27:56.960]  Давайте напишем деструкторы,
[27:56.960 --> 27:58.960]  на этом, в принципе, разговор про вариант пока закончим.
[27:58.960 --> 28:00.960]  Что должен делать деструктор?
[28:00.960 --> 28:02.960]  Ну, сейчас мы напишем деструктор,
[28:02.960 --> 28:04.960]  но я не буду исправить ошибки компиляции,
[28:04.960 --> 28:06.960]  я просто открою заранее написанный код,
[28:06.960 --> 28:08.960]  который кипелируется.
[28:08.960 --> 28:10.960]  Там то же самое все.
[28:12.960 --> 28:14.960]  Нам надо в варианте...
[28:16.960 --> 28:18.960]  Вот что должен делать деструктор в варианте?
[28:18.960 --> 28:20.960]  Давайте деструктор в варианте.
[28:20.960 --> 28:22.960]  Отчищать активный...
[28:22.960 --> 28:24.960]  Как мы это сделаем? У вас есть индекс?
[28:24.960 --> 28:26.960]  Ухраните его все.
[28:26.960 --> 28:28.960]  Сохраним тайп-лист, так сказать.
[28:28.960 --> 28:30.960]  Ну, то есть, что я должен сейчас делать?
[28:30.960 --> 28:32.960]  Что написать в деструкторе?
[28:34.960 --> 28:36.960]  У вас есть в варианте...
[28:36.960 --> 28:38.960]  У вас есть метод обращения, да?
[28:38.960 --> 28:40.960]  Ну, кажется, да, есть.
[28:40.960 --> 28:42.960]  Нам на пост деструкта вызовут в варианте, кажется.
[28:42.960 --> 28:44.960]  А, кстати, мы должны писать этот
[28:44.960 --> 28:46.960]  using в варианте деструктов
[28:46.960 --> 28:48.960]  в паблике или неважно?
[28:48.960 --> 28:50.960]  Ну...
[28:50.960 --> 28:52.960]  Уличные конструкторы должны быть...
[28:52.960 --> 28:54.960]  Если напишешь в приватном,
[28:54.960 --> 28:56.960]  если напишешь в приватном,
[28:56.960 --> 28:58.960]  то они просто останутся приватными.
[28:58.960 --> 29:00.960]  У меня прям работают.
[29:00.960 --> 29:02.960]  Чего? У тебя не MSWC-компилятор, случайно?
[29:02.960 --> 29:04.960]  Что?
[29:04.960 --> 29:06.960]  У меня TANK++ и EG++
[29:06.960 --> 29:08.960]  я упробовал, у меня компилировался.
[29:08.960 --> 29:10.960]  Сейчас, ты хочешь сказать, что ты using
[29:10.960 --> 29:12.960]  конструктор написал в private-секции варианта
[29:12.960 --> 29:14.960]  и это из Main вызывается?
[29:14.960 --> 29:16.960]  Да.
[29:16.960 --> 29:18.960]  Это какая-то ерунда.
[29:18.960 --> 29:20.960]  Ты его вызвал?
[29:20.960 --> 29:22.960]  Да, я вызвал.
[29:22.960 --> 29:24.960]  Возможно, он просто сгенерируется
[29:24.960 --> 29:26.960]  Возможно, он просто сгенерирует
[29:26.960 --> 29:28.960]  дефолтный конструктор
[29:28.960 --> 29:30.960]  и как-то придумал,
[29:30.960 --> 29:32.960]  как сконструировать родителей
[29:32.960 --> 29:34.960]  самому умолчанию.
[29:34.960 --> 29:36.960]  У всех типов дефолтный конструктор,
[29:36.960 --> 29:38.960]  он такой типо, а, нормально.
[29:38.960 --> 29:40.960]  Возможно, он всех родителей сконструировал
[29:40.960 --> 29:42.960]  по умолчанию и...
[29:42.960 --> 29:44.960]  Возможно, у тебя поэтому нужен конструктор
[29:44.960 --> 29:46.960]  по умолчанию для варианта альтернатив?
[29:46.960 --> 29:48.960]  Так тут тоже надо было, он тоже показался.
[29:48.960 --> 29:50.960]  Так вот, деструкты варианта.
[29:50.960 --> 29:52.960]  Чего он должен делать?
[29:52.960 --> 29:54.960]  Удалить активный тип.
[29:54.960 --> 29:56.960]  И всё.
[29:56.960 --> 29:58.960]  Ну, это не всё, что нельзя сделать.
[30:00.960 --> 30:02.960]  Обратиться в юниор
[30:02.960 --> 30:04.960]  вызовет деструктур явно.
[30:04.960 --> 30:06.960]  Деструктур чего? Юниор?
[30:06.960 --> 30:08.960]  Какого типа?
[30:08.960 --> 30:10.960]  Ты умеешь обращаться
[30:10.960 --> 30:12.960]  к сторожу? Ты же умеешь кучать гет?
[30:12.960 --> 30:14.960]  Нет.
[30:14.960 --> 30:16.960]  Гет только с шаблонным параметром
[30:16.960 --> 30:18.960]  ты умеешь вызывать или с шаблонным параметром
[30:18.960 --> 30:20.960]  индекс? А у тебя не шаблонный параметр,
[30:20.960 --> 30:22.960]  а роттайм примерно.
[30:22.960 --> 30:24.960]  Индекс.
[30:24.960 --> 30:26.960]  Ну, нам нужна какая-нибудь функция
[30:26.960 --> 30:28.960]  дестроид и пилот.
[30:28.960 --> 30:30.960]  Нам нужна что-то виртуальная, потому что мы никогда
[30:30.960 --> 30:32.960]  не... Нет, нет, нет.
[30:32.960 --> 30:34.960]  Функция дестрои...
[30:34.960 --> 30:36.960]  Функция дестрои...
[30:36.960 --> 30:38.960]  Вот этот вариант мне больше нравится.
[30:38.960 --> 30:40.960]  Нам нужно просто в юниор добавить ещё функцию
[30:40.960 --> 30:42.960]  дестрои.
[30:42.960 --> 30:44.960]  Вот.
[30:44.960 --> 30:46.960]  Но сейчас.
[30:46.960 --> 30:48.960]  А что дестрои-то?
[30:48.960 --> 30:50.960]  Что? По индексу?
[30:50.960 --> 30:52.960]  Да.
[30:52.960 --> 30:54.960]  Дестрои?
[30:54.960 --> 30:56.960]  Я почти придумал.
[30:56.960 --> 30:58.960]  Короче, дестрои от
[30:58.960 --> 31:00.960]  индекса. Просто индекса.
[31:00.960 --> 31:02.960]  Так.
[31:02.960 --> 31:04.960]  Нет, от.
[31:04.960 --> 31:06.960]  А от числа?
[31:06.960 --> 31:08.960]  Да. Если ноль,
[31:08.960 --> 31:10.960]  то удалим х.
[31:10.960 --> 31:12.960]  В чём проблема?
[31:12.960 --> 31:14.960]  А дальше будем
[31:14.960 --> 31:16.960]  параметрально проходить?
[31:16.960 --> 31:18.960]  Вы считаете?
[31:18.960 --> 31:20.960]  Нет. Мы не миллионеры.
[31:20.960 --> 31:22.960]  Если про это.
[31:22.960 --> 31:24.960]  Я всё-таки хочу, чтобы это было шаблонной
[31:24.960 --> 31:26.960]  штукой.
[31:26.960 --> 31:28.960]  А как?
[31:28.960 --> 31:30.960]  Пусть это будет так-найм-индекс.
[31:30.960 --> 31:32.960]  Или так-найм-тэ, на самом деле.
[31:32.960 --> 31:34.960]  Так-найм-тэ, ладно.
[31:34.960 --> 31:36.960]  Так-найм-тэ. Ну, то же самое,
[31:36.960 --> 31:38.960]  просто дестрои без параметров
[31:38.960 --> 31:40.960]  и в конст-экспорт.
[31:42.960 --> 31:44.960]  А теперь, наверное, у нас сейчас понадобится функция, чтобы
[31:44.960 --> 31:46.960]  если STD
[31:46.960 --> 31:48.960]  isSame
[31:48.960 --> 31:50.960]  в
[31:50.960 --> 31:52.960]  опять т, запятая head.
[31:52.960 --> 31:54.960]  Ну, может, сейчас и для
[31:54.960 --> 31:56.960]  индекса сделаем.
[31:56.960 --> 31:58.960]  То мы говорим head.
[31:58.960 --> 32:00.960]  вызвать
[32:00.960 --> 32:02.960]  destructor head.
[32:02.960 --> 32:04.960]  Ну, а иначе делаем
[32:04.960 --> 32:06.960]  дестрои
[32:06.960 --> 32:08.960]  с шаблонным параметром
[32:08.960 --> 32:10.960]  t от
[32:10.960 --> 32:12.960]  tail.
[32:12.960 --> 32:14.960]  tail.
[32:14.960 --> 32:16.960]  tail.template-destroy
[32:16.960 --> 32:18.960]  tail.template-destroy
[32:18.960 --> 32:20.960]  tail.template-destroy
[32:20.960 --> 32:22.960]  tail.template-destroy-t
[32:22.960 --> 32:24.960]  tail.template-destroy-t
[32:24.960 --> 32:26.960]  tail.template-destroy-t
[32:26.960 --> 32:28.960]  На самом деле, мне
[32:28.960 --> 32:30.960]  не очень нравится такая реализация.
[32:30.960 --> 32:32.960]  Сейчас я её ещё упрощу.
[32:32.960 --> 32:34.960]  Вот что
[32:34.960 --> 32:36.960]  на самом деле.
[32:36.960 --> 32:38.960]  По сути, сейчас я могу сказать
[32:38.960 --> 32:40.960]  с каким шаблонным параметром
[32:40.960 --> 32:42.960]  вызвать дестрои.
[32:42.960 --> 32:44.960]  Понятно.
[32:44.960 --> 32:46.960]  Да, пока что.
[32:46.960 --> 32:48.960]  Это в варантайме представляется они.
[32:48.960 --> 32:50.960]  Да.
[32:50.960 --> 32:52.960]  Тейфлист пишемся.
[32:52.960 --> 32:54.960]  Тейфлист вектор пишется.
[32:56.960 --> 32:58.960]  Лёгкий
[32:58.960 --> 33:00.960]  виртуальный акул.
[33:00.960 --> 33:02.960]  Я виртуальный акул.
[33:02.960 --> 33:04.960]  А я виртуальный класс.
[33:06.960 --> 33:08.960]  Смотрите, я
[33:08.960 --> 33:10.960]  просто сделаю деструктор вариант
[33:10.960 --> 33:12.960]  альтернатив.
[33:14.960 --> 33:16.960]  Ну или я сделаю даже не деструктор
[33:16.960 --> 33:18.960]  альтернатив, в самом варианты
[33:18.960 --> 33:20.960]  альтернативе сделаю функцию destory.
[33:20.960 --> 33:22.960]  Я сейчас
[33:22.960 --> 33:24.960]  буду так смотреть, правда ли
[33:24.960 --> 33:26.960]  индекс мой, я опять сейчас
[33:26.960 --> 33:28.960]  статик кастом сделаю
[33:28.960 --> 33:30.960]  к наспитникам, правда ли мой
[33:30.960 --> 33:32.960]  индекс там, который записан,
[33:32.960 --> 33:34.960]  это тот индекс, который мой сейчас.
[33:34.960 --> 33:36.960]  И если да, то я просто вызову
[33:36.960 --> 33:41.700]  с шаблонным параметром, как надо, без всякой фаз здесь уже.
[33:41.700 --> 33:44.160]  То есть это будет за линию происходить?
[33:44.160 --> 33:50.840]  Это, конечно, будет за линию происходить, потому что это надо делать, ну, потому что это врантаймерный упсус.
[33:50.840 --> 33:53.400]  То есть всегда улизывается destroy всех предков?
[33:53.400 --> 33:57.160]  Да, просто он будет тривиальным во всех случаях, кроме одного.
[33:57.160 --> 34:01.600]  Да, но в каком-то смысле он будет не тривиальным, но это врантаймерная операция.
[34:01.600 --> 34:02.880]  А у тебя вариантов нет?
[34:02.880 --> 34:03.720]  Да.
[34:03.720 --> 34:06.360]  У тебя вариантов нет? У меня вариантов, сколько угодно.
[34:08.360 --> 34:10.920]  Если у тебя мало идея, прошу исправнение, как говорится.
[34:10.920 --> 34:12.920]  Так, можно мы вернемся в destroy?
[34:14.920 --> 34:16.320]  Можно мы вернемся в destroy?
[34:16.320 --> 34:18.920]  Сейчас, destroy я просто уничтожаю голову.
[34:20.120 --> 34:25.920]  А, не просто уничтожаю голову, я уничтожаю голову при условии, что она какая надо.
[34:26.720 --> 34:27.920]  А else не пишу.
[34:28.520 --> 34:29.720]  А, просто else нет.
[34:29.720 --> 34:30.920]  Да, вот так давайте.
[34:30.920 --> 34:32.320]  Jostam загонит голову.
[34:32.320 --> 34:33.120]  Почему?
[34:33.720 --> 34:35.520]  А здесь я напишу так, я скажу...
[34:35.520 --> 34:40.120]  Секунды, я присоединяюсь, они без пояснения резко вернутся и вернутся обратно.
[34:40.120 --> 34:41.320]  Почему можно так сделать?
[34:41.320 --> 34:45.520]  Потому что я хочу написать, он мне не дает.
[34:45.520 --> 34:49.320]  Сейчас, я вариант alternative делаю функцию destroy.
[34:51.320 --> 34:54.120]  Которая делает следующее.
[34:54.120 --> 34:55.320]  Если...
[34:55.920 --> 34:59.120]  Ну, во-первых, опять весь PTR она делает.
[35:00.920 --> 35:02.920]  Это static cast derived.
[35:03.920 --> 35:05.120]  Звездочки.
[35:05.120 --> 35:06.320]  Почему destroy?
[35:06.920 --> 35:07.920]  Почему не destructor?
[35:07.920 --> 35:10.120]  Потому что мы можем destroy не только...
[35:11.320 --> 35:14.720]  Дестрой нужен чаще, когда мы направляем в свое место.
[35:15.320 --> 35:15.720]  Да.
[35:15.720 --> 35:17.720]  Хорошо, ладно, мы destructor вызывали destructor.
[35:17.720 --> 35:20.320]  Если Vist PTR...
[35:21.320 --> 35:22.720]  Уже не cost export.
[35:23.320 --> 35:24.320]  Vist PTR.
[35:26.120 --> 35:29.520]  Стрелочка index равно равно наш index,
[35:30.120 --> 35:32.320]  то просто я вызываю destroy,
[35:34.720 --> 35:36.320]  ну, Vist PTR.
[35:37.520 --> 35:38.920]  Стрелочка storage.
[35:39.720 --> 35:40.720]  Точка destroy.
[35:40.720 --> 35:42.320]  Точка tempo destroy.
[35:44.320 --> 35:45.320]  Ты хорош.
[35:45.320 --> 35:47.120]  Шаблоны поравентом T.
[35:49.120 --> 35:49.920]  И все.
[35:51.320 --> 35:55.320]  То есть, этот destroy, он просто во всех случаях тривиально сработает.
[35:55.320 --> 35:56.320]  Ну, как тривиально?
[35:56.320 --> 36:00.320]  Он сделает, конечно, один проход по указателю,
[36:00.320 --> 36:04.520]  но в остальном он ни к чему не приведет,
[36:04.520 --> 36:07.720]  потому что destroy вызовется в реальность только один раз
[36:07.720 --> 36:09.120]  и уничтожит правильную голову.
[36:09.120 --> 36:10.520]  А как вызовет destroy все?
[36:10.920 --> 36:11.320]  Да.
[36:11.320 --> 36:12.320]  Вот.
[36:12.920 --> 36:14.320]  А вот тут...
[36:14.320 --> 36:17.320]  А можно еще вернемся туда, потому что я ничего...
[36:17.520 --> 36:18.920]  Хорошо, давай вернемся.
[36:18.920 --> 36:20.120]  Почти все понятно.
[36:20.520 --> 36:21.320]  Почти все понятно.
[36:21.320 --> 36:23.320]  Ну вот, просто я вот так написал.
[36:24.520 --> 36:26.520]  Это тот destroy, а новый destroy где?
[36:26.520 --> 36:27.320]  А новый destroy вот где?
[36:27.320 --> 36:28.320]  Я просто destroy понял, все хорошо.
[36:29.320 --> 36:33.320]  Новый destroy просто проверяет, как называется, storage точку,
[36:33.320 --> 36:35.320]  потому что storage это есть именно еще.
[36:37.320 --> 36:41.720]  Так, теперь, как вызвать здесь, в деструкторе,
[36:41.720 --> 36:43.720]  destroy для всех наследников сразу?
[36:43.720 --> 36:46.320]  А, ну, кажется, уже понятно, что что-то надо сделать.
[36:46.320 --> 36:49.320]  Нам нужно вызвать как бы функцию destroy в вариант alternative.
[36:50.120 --> 36:50.920]  Ну, как бы, да?
[36:51.720 --> 36:52.320]  Так.
[36:52.320 --> 36:55.320]  Ну, мы пишем вариант alternative, type, запятаем type три точки,
[36:55.320 --> 36:58.520]  ну, двоеточь-двоеточеча, destroy, и потом в конце еще три точки.
[36:58.520 --> 36:59.520]  Что-то такое.
[36:59.520 --> 37:01.520]  Ну, как с юдингом.
[37:02.520 --> 37:05.520]  А есть ли, я думаю, что пакетный вызов функции?
[37:05.520 --> 37:07.520]  Конечно, ну, за Китай это просто...
[37:07.520 --> 37:08.520]  Есть?
[37:08.520 --> 37:09.520]  Нет.
[37:09.520 --> 37:10.520]  Так прям нет.
[37:10.520 --> 37:12.520]  Но есть.
[37:12.520 --> 37:16.520]  И вот сейчас как раз мы изучим еще одну.
[37:16.520 --> 37:17.520]  Killer feature.
[37:17.520 --> 37:19.520]  Killer feature 17?
[37:19.520 --> 37:20.520]  Да.
[37:20.720 --> 37:22.720]  Значит, сейчас мы впервые...
[37:22.720 --> 37:23.720]  Cyclepotipum.
[37:23.720 --> 37:24.720]  Cyclepotipum.
[37:24.720 --> 37:25.720]  Fold expression сейчас будет.
[37:25.720 --> 37:26.720]  Если кто знает.
[37:26.720 --> 37:27.720]  Cool.
[37:27.720 --> 37:28.720]  Сейчас мы впервые...
[37:28.720 --> 37:30.720]  Там в первом смеси, когда я рассказывал про пакеты типов,
[37:30.720 --> 37:33.720]  кто-то заикался, что вот есть еще fold expression.
[37:33.720 --> 37:34.720]  Внутри скобочек что-то.
[37:34.720 --> 37:35.720]  Да.
[37:35.720 --> 37:36.720]  Возможно, это был ты, кстати.
[37:36.720 --> 37:37.720]  Нет, это был такой человек.
[37:37.720 --> 37:38.720]  Ладно, хорошо.
[37:38.720 --> 37:41.720]  Сейчас мы впервые в нашем курсе используем новую синтаксическую
[37:41.720 --> 37:43.720]  конструкцию, которая называется fold expression.
[37:45.720 --> 37:46.720]  А...
[37:46.720 --> 37:48.720]  Вот мы сейчас отлучировали сюда.
[37:48.920 --> 37:49.920]  Смотрите.
[37:49.920 --> 37:50.920]  Да-да-да.
[37:50.920 --> 37:55.920]  В C++17 появилась такая синтаксическая конструкция.
[37:55.920 --> 37:57.920]  Это новая синтаксическая конструкция.
[37:57.920 --> 38:00.920]  Мы такого раньше еще не делали никогда.
[38:00.920 --> 38:07.920]  Она позволяет вам применить, вычислить одно и то же выражение
[38:07.920 --> 38:11.920]  параметризованное пакетом типов.
[38:11.920 --> 38:15.920]  Ну, например, у вас есть вот шаблонный парак, вот
[38:16.120 --> 38:19.120]  у вас есть, допустим, шаблонные аргументы.
[38:19.120 --> 38:21.120]  Давайте что-нибудь простое.
[38:21.120 --> 38:22.120]  Вот, например, так.
[38:22.120 --> 38:26.120]  Вот у меня есть шаблонные аргументы, которые допускают
[38:26.120 --> 38:28.120]  оператор двойной имперсант над собой.
[38:28.120 --> 38:30.120]  Я тогда могу написать такую функцию.
[38:30.120 --> 38:32.120]  Вот у меня переменное количество шаблонных аргументов
[38:32.120 --> 38:36.120]  принято, а я возвращаю вот такое выражение.
[38:36.120 --> 38:40.120]  Многоточие двойной имперсант и этот пакет.
[38:40.120 --> 38:45.120]  И это в compile time развернется в двойной имперсант по всей
[38:45.320 --> 38:47.320]  элементам пакета.
[38:47.320 --> 38:50.320]  О, типа я видел там, кстати, есть булевые функции,
[38:50.320 --> 38:54.320]  вот это N, записок принимаются, ну, за себя.
[38:54.320 --> 38:57.320]  То есть это вообще что-то сделано, да?
[38:57.320 --> 38:58.320]  Возможно.
[38:58.320 --> 38:59.320]  Возможно есть, да.
[38:59.320 --> 39:00.320]  Вероятно.
[39:00.320 --> 39:01.320]  Вероятно.
[39:01.320 --> 39:03.320]  Ну, я не очень понял, про какие ты говоришь.
[39:03.320 --> 39:07.320]  Секундочку, почему, но написано как функция,
[39:07.320 --> 39:10.320]  оно же примерно константное.
[39:10.320 --> 39:12.320]  Ну, функция константная.
[39:12.320 --> 39:13.320]  Сейчас.
[39:13.520 --> 39:15.520]  О, нет, все отлично, я понял, хорошо.
[39:15.520 --> 39:16.520]  Пожалуйста.
[39:16.520 --> 39:19.520]  Так, посмотрите, пожалуйста, на эту синтаксическую
[39:19.520 --> 39:20.520]  конструкцию.
[39:20.520 --> 39:23.520]  Вот тут формальное определение, как это работает.
[39:23.520 --> 39:27.520]  Значит, у вас есть выражение, которое должно быть пакетом.
[39:27.520 --> 39:31.520]  Ну, оно может содержать, оно может быть не тремяльным
[39:31.520 --> 39:33.520]  выражением, то есть не просто имя, не тремярное,
[39:33.520 --> 39:35.520]  но в нем должен фигурировать имя пакета.
[39:35.520 --> 39:37.520]  Бинарная операция, многоточие, скобка закрылась.
[39:37.520 --> 39:39.520]  Все это обязательно должно быть в скобках, что важно.
[39:39.520 --> 39:41.520]  И без скобок это не будет компилироваться.
[39:41.720 --> 39:43.720]  Это должно быть в скобках, потому что синтаксис иначе
[39:43.720 --> 39:45.720]  просто компилятами может распарсить.
[39:45.720 --> 39:46.720]  Ну, не повезло.
[39:46.720 --> 39:48.720]  Всегда это должно быть именно в скобках.
[39:48.720 --> 39:49.720]  Важный вопрос.
[39:49.720 --> 39:50.720]  Да.
[39:50.720 --> 39:52.720]  Уже было секунды назад.
[39:52.720 --> 39:53.720]  Да.
[39:53.720 --> 39:57.720]  Зачем мы в Destroy проверяем, что head и test совпадают?
[39:57.720 --> 40:00.720]  Мы же всегда вызываем, только если head и test совпадают.
[40:00.720 --> 40:01.720]  Нет.
[40:01.720 --> 40:02.720]  В Destroy...
[40:02.720 --> 40:04.720]  Чтобы мы это проверили на этапе рых, раньше еще.
[40:04.720 --> 40:05.720]  Ты про Destroy в Union.
[40:05.720 --> 40:06.720]  В Destroy в Union.
[40:06.720 --> 40:08.720]  Так у тебя в Union всегда head фиксированный,
[40:08.920 --> 40:10.920]  а тебе нужно будет делать любой.
[40:11.920 --> 40:13.920]  Union и head первый.
[40:13.920 --> 40:14.920]  И что?
[40:14.920 --> 40:16.920]  А тебе нужно делать любой.
[40:16.920 --> 40:17.920]  И что?
[40:17.920 --> 40:18.920]  Я же не ударил остальные.
[40:18.920 --> 40:19.920]  В смысле?
[40:19.920 --> 40:20.920]  Тебе нужно ударить нужные.
[40:20.920 --> 40:23.920]  Ты хочешь сказать, ты готов вызвать destructor head,
[40:23.920 --> 40:25.920]  хотя там не head лежало?
[40:25.920 --> 40:26.920]  Нет, нет, нет.
[40:26.920 --> 40:27.920]  В смысле?
[40:27.920 --> 40:28.920]  Я его просто не буду вызывать.
[40:28.920 --> 40:30.920]  Я же Destroy вызываю в одном из случаев.
[40:30.920 --> 40:32.920]  Ты говоришь про то, что это все равно...
[40:32.920 --> 40:34.920]  Мы два разных знаем, одно и то же.
[40:35.120 --> 40:37.120]  Ну, поскольку это их констэкспорт,
[40:37.120 --> 40:39.120]  то это ничего не портит,
[40:39.120 --> 40:42.120]  а если вдруг я вызову Destroy из какого-то другого контекста,
[40:42.120 --> 40:44.120]  то ничего не будет.
[40:44.120 --> 40:46.120]  Если я вызову Destroy с неправильным типом,
[40:46.120 --> 40:47.120]  то ничего не произойдет.
[40:47.120 --> 40:49.120]  Ну, там их констэкспорты.
[40:51.120 --> 40:53.120]  Зачем я вызвал Destroy?
[40:53.120 --> 40:55.120]  Если вы вызвали Destroy,
[40:55.120 --> 40:57.120]  значит вы уже точно ошиблись в смысле.
[40:57.120 --> 40:59.120]  И лучше вам скажут, что...
[40:59.120 --> 41:01.120]  Лучше сделать какую-то штуку, которая скажет,
[41:01.120 --> 41:02.120]  что вы ошиблись,
[41:02.120 --> 41:04.120]  чем штука, которая такая...
[41:04.320 --> 41:06.320]  И ничего не сделает.
[41:06.320 --> 41:08.320]  Ну, возможно.
[41:08.320 --> 41:10.320]  Эй, короче, это личная проверка.
[41:10.320 --> 41:12.320]  Она Compile Time,
[41:12.320 --> 41:14.320]  Compile Planet Exp, не жалко.
[41:14.320 --> 41:16.320]  Возможно...
[41:16.320 --> 41:18.320]  В одном контексте вызвать Destroy,
[41:18.320 --> 41:20.320]  это бы нам пригодилось.
[41:20.320 --> 41:22.320]  Так, давайте придемся к Fold Expression.
[41:22.320 --> 41:24.320]  Fold Expression.
[41:24.320 --> 41:26.320]  Посмотрите на определение.
[41:30.320 --> 41:32.320]  Все понятно.
[41:32.520 --> 41:34.520]  Есть
[41:34.520 --> 41:36.520]  вот такие два варианта.
[41:36.520 --> 41:38.520]  Fold Expression,
[41:38.520 --> 41:40.520]  когда я хочу сделать
[41:40.520 --> 41:42.520]  не просто
[41:42.520 --> 41:44.520]  бинарным оператором связать
[41:44.520 --> 41:46.520]  все элементы пакета,
[41:46.520 --> 41:48.520]  а еще с каким-то аргументом
[41:48.520 --> 41:50.520]  с левой или с правой.
[41:50.520 --> 41:52.520]  Например, вот здесь.
[41:52.520 --> 41:54.520]  Например, я хочу вот это добавить,
[41:54.520 --> 41:56.520]  просуммировать весь пакет
[41:56.520 --> 41:58.520]  и еще в конце добавить к этому вот это.
[41:59.520 --> 42:01.520]  Секунду можно нагниться.
[42:01.520 --> 42:03.520]  Там сказано, вот так неправильно,
[42:03.520 --> 42:05.520]  а вот так правильно. Я не увидел отличия.
[42:05.520 --> 42:07.520]  Тут говорится про то, что
[42:07.520 --> 42:09.520]  сколько нужно вот это выражение записывать,
[42:09.520 --> 42:11.520]  которое я тут в конце написал.
[42:11.520 --> 42:13.520]  Вот.
[42:15.520 --> 42:17.520]  Ну, давайте вот еще
[42:17.520 --> 42:19.520]  парочку примеров.
[42:19.520 --> 42:21.520]  Например, можно вот так
[42:21.520 --> 42:23.520]  вывести все элементы пакета.
[42:23.520 --> 42:25.520]  Как раз такая
[42:25.520 --> 42:27.520]  конструкция
[42:27.520 --> 42:29.520]  позволяет вывести все в СИАУ,
[42:29.520 --> 42:31.520]  потому что она разворачивается в СТД СИАУ
[42:31.520 --> 42:33.520]  влево-влево. Первый аргумент пакета,
[42:33.520 --> 42:35.520]  все это в скобочках влево-влево,
[42:35.520 --> 42:37.520]  второй аргумент пакета и так далее.
[42:37.520 --> 42:39.520]  Через пробел это может быть?
[42:41.520 --> 42:43.520]  Через пробел вывести?
[42:47.520 --> 42:49.520]  Ну, СТД СИАУ
[42:49.520 --> 42:51.520]  сейчас, давайте подумаем.
[42:51.520 --> 42:53.520]  Можно?
[42:57.520 --> 42:59.520]  Ну, если я сделаю СТС СИАУ
[43:01.520 --> 43:03.520]  Давайте, типа,
[43:03.520 --> 43:05.520]  как сюда пишем пробел,
[43:05.520 --> 43:07.520]  штуку обернем в скобки,
[43:07.520 --> 43:09.520]  а она скобки раньше распасет,
[43:09.520 --> 43:11.520]  да?
[43:11.520 --> 43:13.520]  Да, через пробел,
[43:13.520 --> 43:15.520]  не знаю, как.
[43:15.520 --> 43:17.520]  Ну, можно заказать
[43:17.520 --> 43:19.520]  такой потоп и потом, типа,
[43:19.520 --> 43:21.520]  слушай,
[43:21.520 --> 43:23.520]  не, примерно,
[43:23.520 --> 43:25.520]  типа, создать копирующий потоп, который
[43:25.520 --> 43:27.520]  каждый раз можно полностью вывести куда-то,
[43:27.520 --> 43:29.520]  он сам-то не сдаляется.
[43:29.520 --> 43:31.520]  Ну да, понятно, что можно там создать какой-то
[43:31.520 --> 43:33.520]  какой-то обер, куда лезть, наверное,
[43:33.520 --> 43:35.520]  через обер.
[43:35.520 --> 43:37.520]  Почему ты так пишешь?
[43:37.520 --> 43:39.520]  Потому что у меня нет идеи.
[43:39.520 --> 43:41.520]  Ну, я не знаю, можно или нет,
[43:41.520 --> 43:43.520]  но я не могу сказать.
[43:43.520 --> 43:45.520]  Данилу Максимов не умеет решать задачи, сдача не решается.
[43:45.520 --> 43:47.520]  Ну, давай, у тебя есть идеи?
[43:47.520 --> 43:49.520]  Да, обращаемся к тебе.
[43:49.520 --> 43:51.520]  Мы можем просто взять
[43:51.520 --> 43:53.520]  аргумент в скобочки? Все сломается или нет?
[43:53.520 --> 43:55.520]  Мы можем, почему нет?
[43:55.520 --> 43:57.520]  Хорошо, ну можно после аргумента
[43:57.520 --> 43:59.520]  в скобочках в этих написать
[43:59.520 --> 44:01.520]  влево-влево пробеги?
[44:01.520 --> 44:03.520]  Да!
[44:03.520 --> 44:05.520]  Первым распорзаться оно,
[44:05.520 --> 44:07.520]  получится, что у тебя карта будет влево-влево
[44:07.520 --> 44:09.520]  при объеме операторов пробела.
[44:09.520 --> 44:11.520]  А почему я не могу взять
[44:11.520 --> 44:13.520]  вот это в скобочки
[44:13.520 --> 44:15.520]  написать?
[44:15.520 --> 44:17.520]  Сейчас.
[44:19.520 --> 44:21.520]  Если все возьму в скобочки,
[44:21.520 --> 44:23.520]  то ничего не будет.
[44:23.520 --> 44:25.520]  Проблема в том, что он в любом случае
[44:25.520 --> 44:27.520]  пишет все аргументы подряд,
[44:27.520 --> 44:29.520]  и только операторы между ними.
[44:29.520 --> 44:31.520]  Я могу оставить пустоту
[44:31.520 --> 44:33.520]  слева твоей точки сейчас?
[44:35.520 --> 44:37.520]  Пустоту слева, то есть написать
[44:37.520 --> 44:39.520]  бизнес-дресси-аут?
[44:39.520 --> 44:41.520]  Ну, тогда он попробует.
[44:41.520 --> 44:43.520]  В смысле, пустой экспрешен?
[44:43.520 --> 44:45.520]  Точка за пятой?
[44:45.520 --> 44:47.520]  Ну, нет, просто пустой, вообще пустой,
[44:47.520 --> 44:49.520]  ничего не делается.
[44:49.520 --> 44:51.520]  Ну, ладно.
[44:51.520 --> 44:53.520]  Короче, я так понял,
[44:53.520 --> 44:55.520]  просто убрать...
[44:55.520 --> 44:57.520]  Многоточие, влево-влево, аркс
[44:57.520 --> 44:59.520]  и все это в скобочки.
[44:59.520 --> 45:01.520]  Без эс-дресси-аут, короче.
[45:01.520 --> 45:03.520]  Многоточие, влево-влево, аркс
[45:03.520 --> 45:05.520]  и все это в скобочки.
[45:05.520 --> 45:07.520]  Вот в плане эс-дресси-аут
[45:07.520 --> 45:09.520]  обратите к галочке.
[45:09.520 --> 45:11.520]  Все, что слева, три точки.
[45:11.520 --> 45:13.520]  Скобка открывается,
[45:13.520 --> 45:15.520]  многоточие,
[45:15.520 --> 45:17.520]  влево-влево, аркс,
[45:17.520 --> 45:26.520]  Так, выбирать все, что находится с левой отрицательной, до левой из полки.
[45:26.520 --> 45:28.520]  И куда оно выведется?
[45:28.520 --> 45:30.520]  Ну, сейчас никуда, но, типа, если так можно, то...
[45:30.520 --> 45:33.520]  Ну, это будет работать как... Ну, я же спросил, понятно?
[45:33.520 --> 45:38.520]  Это будет работать вот так. Оно свяжет просто все аргументы вот этим оператором.
[45:38.520 --> 45:46.520]  И, типа, идея в том, что я хочу распаксить одно выражение в кучу вот таких же сигналов.
[45:46.520 --> 45:48.520]  А, он не поймет?
[45:48.520 --> 45:52.520]  Он свяжет этим оператором все твои аргументы, что за день.
[45:52.520 --> 45:54.520]  Какой аргумент?
[45:54.520 --> 45:56.520]  Что можно?
[45:58.520 --> 46:00.520]  Я не понял ничего.
[46:00.520 --> 46:02.520]  Какая операция может быть над Void?
[46:02.520 --> 46:04.520]  Просто мы же не хотим, чтобы все срочно это возвращало.
[46:04.520 --> 46:10.520]  Так, короче, мы очень долго сидим на этом. Ну, в общем, понятно синтез этой конструкции.
[46:10.520 --> 46:12.520]  Синтез плюс 17.
[46:12.520 --> 46:18.520]  Вот, кстати, обратите внимание, что в зависимости от того, с какой стороны вы напишете многоточие, зависит ассоциативность.
[46:18.520 --> 46:22.520]  Она... Ну, он либо право ассоциативный, либо лево ассоциативный сделает какую-то штуку.
[46:22.520 --> 46:26.520]  То есть, как... Чем нижние два отличаются?
[46:26.520 --> 46:31.520]  Ну, он... Ну, как бы ты можешь его вот так... Ну, вот написано, чем они отличаются.
[46:31.520 --> 46:33.520]  Все.
[46:33.520 --> 46:37.520]  Так вот, теперь я вспоминаю, что у меня есть оператор запятая.
[46:37.520 --> 46:39.520]  Точно, да.
[46:39.520 --> 46:42.520]  И говорю следующий вариант альтернатив.
[46:44.520 --> 46:49.520]  От types, запятая types, многоточие.
[46:49.520 --> 46:52.520]  B.B.destroy.
[46:55.520 --> 46:57.520]  Запятая, многоточие.
[46:57.520 --> 46:59.520]  И все это в скобочках.
[46:59.520 --> 47:01.520]  И все это в скобочках.
[47:01.520 --> 47:03.520]  И все это в скобочках.
[47:05.520 --> 47:07.520]  А что это у нас там...
[47:07.520 --> 47:09.520]  Это, знаете, по всем наследникам пробежавшись, вызвал дестрои.
[47:09.520 --> 47:17.520]  Не доказавай, ну как, но что если, например, у нас... Как вы понимаете, какой пакет мы разбиваем?
[47:17.520 --> 47:19.520]  Ну...
[47:19.520 --> 47:21.520]  Читчички, может быть, их больше одного же, вроде?
[47:21.520 --> 47:26.520]  Ну нет, если у тебя... Ну, как? В первую очередь, вот этот пакет, понятно?
[47:26.520 --> 47:28.520]  Нет, ну это понятно, а я именно самому фокусируюсь.
[47:28.520 --> 47:30.520]  Если их больше одного, то C и E будут, я думаю.
[47:30.520 --> 47:34.520]  Вот, на самом деле я вам сейчас веселую историю расскажу.
[47:34.520 --> 47:37.520]  Вот и если это скомпилировать, ну сейчас я попробую это скомпилировать.
[47:37.520 --> 47:39.520]  Ладно, давайте я уже не буду пробовать.
[47:39.520 --> 47:41.520]  Это компилировать, я...
[47:41.520 --> 47:42.520]  У меня это компилируйте.
[47:42.520 --> 47:44.520]  Я в принципе написал все, что хотел.
[47:44.520 --> 47:46.520]  Сейчас я просто открою.
[47:46.520 --> 47:48.320]  Так, все.
[47:48.320 --> 47:51.520]  Про реализацию контурка, пакетов, вариантов, я рассказал все, что хотел.
[47:52.520 --> 47:55.520]  Если кто-то что-то хочет спросить сейчас, то самое время.
[47:55.520 --> 47:57.520]  Потому что мы еще будем дальше к следующему вопросу.
[47:57.520 --> 48:04.280]  — Да. Почему, почему нет возможности, не добавили возможности, instead of «запитой» здесь написается точка «запитой»?
[48:04.280 --> 48:07.600]  — Потому что «запитая» — это оператор, а точка «зап monastery» — не оператор.
[48:07.600 --> 48:12.720]  — Ну и формально, если бы мы распарсили как множество… типа...
[48:12.720 --> 48:14.280]  — Почему не поменяли син元тикцизм языка? — Почему maminax?
[48:14.280 --> 48:17.440]  Зачем вообще требование, чтобы запитая была оператором?
[48:17.440 --> 48:21.320]  Зачем вообще требование, чтобы промежуточная штука была оператором?
[48:21.320 --> 48:25.160]  — Потому что иначе тебе пришлось бы поменять син 20111 на уровне совсем глобальном,
[48:25.160 --> 48:30.160]  что у тебя бывают не только expression и declarations, а еще и expression в скобочках.
[48:30.160 --> 48:33.160]  Клуб.
[48:33.160 --> 48:36.160]  Ну потому что то, что заканчивается точкой за битой, это инструкция.
[48:36.160 --> 48:37.160]  Она может быть чем-то...
[48:37.160 --> 48:39.160]  Она может быть в скобочках, хорошо.
[48:39.160 --> 48:40.160]  Да, у тебя может быть...
[48:40.160 --> 48:43.160]  Мол, она работает, я придумал это увидеть.
[48:43.160 --> 48:47.160]  Что? Ты придумал с пробелами это сделать?
[48:47.160 --> 48:49.160]  Какая херня.
[48:49.160 --> 48:51.160]  Это забавно, это что-то прикол.
[48:51.160 --> 48:53.160]  По-моему, страшно ты это придумал.
[48:53.160 --> 48:55.160]  Ну типа...
[48:57.160 --> 48:59.160]  Это прикол.
[48:59.160 --> 49:01.160]  Интересный код.
[49:01.160 --> 49:02.160]  Что там?
[49:02.160 --> 49:04.160]  Да, я знаю.
[49:04.160 --> 49:06.160]  А что-то доп-функция или какая-то?
[49:06.160 --> 49:09.160]  Нет, сейчас я напишу.
[49:09.160 --> 49:10.160]  Ой.
[49:10.160 --> 49:11.160]  Интересно.
[49:11.160 --> 49:12.160]  Да блин.
[49:12.160 --> 49:13.160]  Bim.
[49:13.160 --> 49:15.160]  Как себя?
[49:15.160 --> 49:16.160]  Витар.
[49:16.160 --> 49:18.160]  STDC out.
[49:19.160 --> 49:20.160]  Робел.
[49:20.160 --> 49:22.160]  ARX.
[49:22.160 --> 49:25.160]  Все это в скобочках.
[49:25.160 --> 49:26.160]  А, забитае.
[49:26.160 --> 49:29.160]  Нет, забитае, то есть три точки без этого.
[49:29.160 --> 49:30.160]  А, забитае.
[49:30.160 --> 49:32.160]  А, точно, через забитуе все, да.
[49:32.160 --> 49:34.160]  Это жесть.
[49:34.160 --> 49:37.160]  Я считаю, это вообще жесть.
[49:37.160 --> 49:38.160]  Ух, ну понятно.
[49:38.160 --> 49:39.160]  Ух.
[49:39.160 --> 49:41.160]  Аппарата забитае, да.
[49:41.160 --> 49:44.160]  И даже может присвоиться очень куда-то впихнуть, не просто чак какой-нибудь.
[49:44.160 --> 49:45.160]  Ооо.
[49:45.160 --> 49:47.160]  Не, ну это конечно очень мощно.
[49:47.160 --> 49:48.160]  Да, круто, круто.
[49:48.160 --> 49:49.160]  Это прям очень мощно.
[49:49.160 --> 49:51.160]  Нет, у тебя первым пробел выведется.
[49:51.160 --> 49:53.160]  Может, у меня есть старый.
[49:53.160 --> 49:55.160]  Тогда последним пробел выведется.
[49:55.160 --> 49:57.160]  Ну, можно вводить стрим-стрим.
[49:57.160 --> 49:59.160]  Пусть за один пробел вводить все.
[49:59.160 --> 50:00.160]  Я победил.
[50:00.160 --> 50:02.160]  Так, все.
[50:02.160 --> 50:04.160]  Теперь я...
[50:04.160 --> 50:06.160]  А, или вначале ARX, а потом ARX.
[50:06.160 --> 50:09.160]  Я это закрою.
[50:09.160 --> 50:11.160]  Открою вот другой файл.
[50:11.160 --> 50:12.160]  Конечно.
[50:12.160 --> 50:14.160]  Ааа.
[50:14.160 --> 50:16.160]  Ладно, давайте я перейду в обратную папку.
[50:16.160 --> 50:19.160]  Которую я выводил раньше.
[50:19.160 --> 50:22.160]  Я выводил на мой MyVariant2.
[50:22.160 --> 50:24.160]  Себе отзывал.
[50:24.160 --> 50:28.160]  Так, ну, короче, на самом деле тут у меня...
[50:28.160 --> 50:30.160]  Съемка идет?
[50:30.160 --> 50:32.160]  Что, съемка идет?
[50:32.160 --> 50:33.160]  Но тут не...
[50:33.160 --> 50:36.160]  Если ты к тому, что вы просто это все скобипастите и напишите, то...
[50:36.160 --> 50:37.160]  Так он уже...
[50:37.160 --> 50:38.160]  Так.
[50:38.160 --> 50:39.160]  Вы думаете здесь...
[50:39.160 --> 50:43.160]  Здесь написан просто вариант, который я написал, но он далеко не полный.
[50:43.160 --> 50:47.160]  В смысле, здесь написано не сильно больше, чем я написал до этого.
[50:47.160 --> 50:48.160]  А нам надо больше?
[50:48.160 --> 50:49.160]  Конечно.
[50:49.160 --> 50:50.160]  Углай.
[50:50.160 --> 50:51.160]  Ну, вот...
[50:51.160 --> 50:52.160]  Хочу щипсить.
[50:52.160 --> 50:53.160]  Это будет смешно.
[50:53.160 --> 50:54.160]  Отрати ровно.
[50:54.160 --> 50:55.160]  Что за ломбер?
[50:55.160 --> 50:56.160]  Вот.
[50:56.160 --> 50:57.160]  Вот, значит...
[50:57.160 --> 50:58.160]  Вот здесь ты лондер нужен.
[50:58.160 --> 50:59.160]  Вот.
[50:59.160 --> 51:00.160]  Сейчас мы...
[51:00.160 --> 51:01.160]  Пуча.
[51:01.160 --> 51:02.160]  Сейчас мы про это и поговорим.
[51:02.160 --> 51:03.160]  Но сначала я из него стру.
[51:03.160 --> 51:04.160]  Так, значит...
[51:04.160 --> 51:05.160]  Так, сейчас...
[51:05.160 --> 51:06.160]  Вот.
[51:06.160 --> 51:11.160]  Ну, давайте еще раз посмотрим, что мы добились.
[51:11.160 --> 51:15.160]  У меня есть getIndexByType, getTypeByIndex.
[51:15.160 --> 51:18.160]  Не помню, зачем оно было надо, но вот оно написано.
[51:18.160 --> 51:20.160]  Значит, вариант Alternative.
[51:20.160 --> 51:22.160]  То же самое, что и у нас было Derived.
[51:22.160 --> 51:23.160]  Index.
[51:23.160 --> 51:24.160]  Конструктор по умолчанию.
[51:24.160 --> 51:25.160]  Вариант Alternative.
[51:25.160 --> 51:28.160]  Тут у меня был где-то важный вывод какой-то.
[51:28.160 --> 51:29.160]  Конструктор Outtie.
[51:29.160 --> 51:31.160]  Конструктор Outtie 2.0.
[51:31.160 --> 51:32.160]  Destroy.
[51:35.160 --> 51:36.160]  Почему-то Destroy...
[51:36.160 --> 51:37.160]  Ничего не делает.
[51:37.160 --> 51:38.160]  Ничего не делает, да.
[51:38.160 --> 51:39.160]  Что же Destroy?
[51:39.160 --> 51:40.160]  Не дописано Destroy.
[51:40.160 --> 51:41.160]  Ну, то компилируется.
[51:41.160 --> 51:42.160]  Не дописано Destroy.
[51:42.160 --> 51:43.160]  Ну, то компилируется, да.
[51:43.160 --> 51:46.160]  Ну, variatic union.
[51:51.160 --> 51:52.160]  В общем...
[51:52.160 --> 51:54.160]  А сколько Busqy будет работать в дальнейшем?
[51:54.160 --> 51:56.160]  В общем, все, по сути, ничего нового.
[51:56.160 --> 51:58.160]  Вот этот вариант Alternative с Destroy.
[51:58.160 --> 51:59.160]  Все, все.
[51:59.160 --> 52:00.160]  Ну, короче, вот.
[52:00.160 --> 52:01.160]  Все, что мы написали, по сути, здесь.
[52:01.160 --> 52:03.160]  Просто оно написано так, что компилируется.
[52:03.160 --> 52:05.160]  Давайте это скомпилируем.
[52:05.160 --> 52:07.160]  Проверим, что компилируется.
[52:08.160 --> 52:11.160]  C++ experience.
[52:11.160 --> 52:12.160]  Да.
[52:12.160 --> 52:13.160]  My...
[52:13.160 --> 52:14.160]  Значит...
[52:14.160 --> 52:16.160]  My варианту 2.
[52:16.160 --> 52:18.160]  Не спрашивайте, почему 2.
[52:18.160 --> 52:20.160]  Первый провалился, понимаю.
[52:20.160 --> 52:21.160]  Вот.
[52:23.160 --> 52:26.160]  Нет, просто первый был как раз тот, в котором все реализовано.
[52:26.160 --> 52:27.160]  А вам не надо до него показывать.
[52:27.160 --> 52:28.160]  Значит...
[52:31.160 --> 52:32.160]  Так.
[52:34.160 --> 52:36.160]  Смотрите, это компилируется.
[52:37.160 --> 52:41.160]  Потому что G++ на самом деле не смог распарсить эту конструкцию.
[52:42.160 --> 52:44.160]  А Clang сможет?
[52:44.160 --> 52:46.160]  А Clang сможет.
[52:46.160 --> 52:48.160]  Знаешь, как пилируют Clang?
[52:49.160 --> 52:50.160]  Сейчас, секунду.
[52:50.160 --> 52:52.160]  А локально нам Clang установлен?
[52:52.160 --> 52:56.160]  Нет, в контесте G++, но G++ 11 уже может.
[52:56.160 --> 52:57.160]  То есть...
[52:57.160 --> 52:59.160]  А изначально G++ какой был?
[52:59.160 --> 53:00.160]  10.
[53:00.160 --> 53:01.160]  Все, слава богу.
[53:01.160 --> 53:03.160]  Вот, начиная с 11, G++ умеет распарсить.
[53:03.160 --> 53:05.160]  А 10 не умел.
[53:05.160 --> 53:07.160]  И здесь...
[53:08.160 --> 53:09.160]  Сейчас.
[53:09.160 --> 53:11.160]  О, господи.
[53:13.160 --> 53:15.160]  Так, где-то...
[53:15.160 --> 53:17.160]  Возможно, я закрыл это.
[53:17.160 --> 53:19.160]  Ну, в общем...
[53:20.160 --> 53:21.160]  Так, нет.
[53:21.160 --> 53:23.160]  Ну ладно, не буду искать.
[53:26.160 --> 53:32.160]  В общем, там был баг в G++ 10, про который был в багзилле G++.
[53:32.160 --> 53:33.160]  Баг репорт.
[53:33.160 --> 53:38.160]  В общем, там написано, что G++ умеет парсить такие конструкции.
[53:38.160 --> 53:41.160]  И вот, начиная с 11 версии, умеет.
[53:41.160 --> 53:45.160]  Это к тому, если вы будете компилировать G++ в версии ниже 11,
[53:45.160 --> 53:47.160]  то у вас может это не работать.
[53:47.160 --> 53:48.160]  Но это не ваша ошибка.
[53:48.160 --> 53:50.160]  Это ошибка, как компилятор.
[53:51.160 --> 53:53.160]  То есть, мы впервые столкнулись с реальной ошибкой компилятора.
[53:53.160 --> 53:54.160]  Да не впервые.
[53:54.160 --> 53:56.160]  Мы, по-моему, раньше сталкивались.
[53:56.160 --> 53:57.160]  Какой?
[53:58.160 --> 53:59.160]  В этом году?
[53:59.160 --> 54:00.160]  Ну, нет.
[54:00.160 --> 54:01.160]  В прошлом году точно сталкивались.
[54:01.160 --> 54:02.160]  Ладно.
[54:02.160 --> 54:04.160]  Может, в этом вы и не застали еще.
[54:05.160 --> 54:06.160]  Так, окей.
[54:07.160 --> 54:10.160]  Переходим к следующему пункту нашей замечательной программы.
[54:10.160 --> 54:13.160]  У нас осталось 12 минут, но мы успеем, я думаю.
[54:14.160 --> 54:16.160]  А пункт называется эстаделлонда.
[54:19.160 --> 54:21.160]  Я даже напишу...
[54:21.160 --> 54:22.160]  Что там?
[54:22.160 --> 54:23.160]  Аптейд?
[54:23.160 --> 54:24.160]  Да.
[54:24.160 --> 54:26.160]  Вот, короче, не знаю.
[54:26.160 --> 54:28.160]  Я торжественно сделаю заголовок.
[54:28.160 --> 54:29.160]  Каптер 47.
[54:29.160 --> 54:31.160]  Вот здесь вот написано.
[54:31.160 --> 54:32.160]  Эстаделлонда.
[54:32.160 --> 54:33.160]  Вон был стягивать доску.
[54:33.160 --> 54:34.160]  Да не.
[54:34.160 --> 54:37.160]  Я вот здесь вот напишу, и мне места хватит.
[54:37.160 --> 54:38.160]  Короче, смотрите.
[54:38.160 --> 54:40.160]  Вот такая пункция.
[54:40.160 --> 54:48.160]  Пока это спойлер, сейчас я попробую вот это скомпилировать и запустить.
[54:48.160 --> 54:54.160]  Вот смотрите, у меня есть вариант от int-double-std-string, который создает пятерки.
[54:55.160 --> 54:56.160]  Молодец.
[54:56.160 --> 55:04.560]  И вывожу, что, ну, это должен получиться int, понятное дело, и смотрю, что в нём лежит по int.
[55:04.560 --> 55:09.040]  И хочу быть уверен, что там пятёрка действительно лежит.
[55:09.040 --> 55:15.600]  Ну, на самом деле, я мог и не выводить, я просто напишу assert, но вот сейчас мы выведем, что там лежит.
[55:15.600 --> 55:23.600]  Значит, я компилирую, я плюс плюс одиннадцатым, запускаю, и там лежит пять, как ни странно.
[55:23.680 --> 55:25.200]  И даже assert не упал.
[55:25.200 --> 55:27.200]  И даже assert не упал, да.
[55:27.200 --> 55:29.680]  Ну, давайте я попробую скомпилировать это силендом.
[55:29.680 --> 55:30.960]  No.
[55:30.960 --> 55:32.960]  И там лежит пять, как ни странно.
[55:36.320 --> 55:38.320]  А давайте я попробую.
[55:42.640 --> 55:44.640]  Мы очень лозь.
[55:44.640 --> 55:46.640]  Опа.
[55:46.640 --> 55:48.640]  Что он сделал?
[55:48.640 --> 55:54.640]  Мы должны в руки играть все оптимизации по ручкам, и посмотреть, где там сломалась какая оптимизация.
[55:54.640 --> 55:58.640]  Значит, у кого есть идеи, что здесь пошло не так.
[55:58.640 --> 56:02.640]  Здесь нет никого обма, то есть всё то, что мы реализовали, тут написано.
[56:02.640 --> 56:08.640]  Давайте проследим внимательно, как работает конструктор.
[56:08.640 --> 56:10.640]  Что такое конструктор V от 5?
[56:10.640 --> 56:16.640]  У нас в варианте есть у наследованные конструкторы.
[56:16.640 --> 56:18.640]  Вариант alternative.
[56:18.640 --> 56:20.640]  Больше нет конструкторов.
[56:20.640 --> 56:22.640]  Смотрим конструктор варианта alternative.
[56:22.640 --> 56:26.640]  Вариант alternative умеет конструироваться от...
[56:26.640 --> 56:30.640]  Ну, вот здесь есть те ауты, которые, в общем-то, я не просто так написал,
[56:30.640 --> 56:32.640]  потому что, собственно, мы по ним поедем.
[56:32.640 --> 56:36.640]  Ну, вот здесь есть те ауты, которые, в общем-то, я не просто так написал,
[56:36.640 --> 56:40.640]  потому что, собственно, мы по ним и можем дебажить, что происходит.
[56:40.640 --> 56:42.640]  Они все сэндл в конце.
[56:42.640 --> 56:48.640]  Сейчас мы с ними запустим.
[56:48.640 --> 56:50.640]  Вот, смотрите, значит, мы...
[56:54.640 --> 56:56.640]  Что произошло?
[56:56.640 --> 56:58.640]  Так, минуточку.
[56:58.640 --> 57:02.640]  Бойзик стринг. Так обычно.
[57:02.640 --> 57:04.640]  Да.
[57:06.640 --> 57:08.640]  Обычная строка.
[57:10.640 --> 57:12.640]  Да, смотрите, что здесь происходит.
[57:12.640 --> 57:16.640]  Он выводит нам порядок, в котором он посещает конструкторы.
[57:16.640 --> 57:22.640]  Сначала он оказывается в варианте alternative в конструкторе,
[57:22.640 --> 57:26.640]  и typeid это int.
[57:26.640 --> 57:30.640]  Ну, я вывожу, какой тип у него.
[57:30.640 --> 57:36.640]  И value 5. То есть он сначала проницилизировал
[57:40.640 --> 57:42.640]  поле 100 с пятеркой.
[57:44.640 --> 57:48.640]  И только затем он зашел в дефолтный конструктор для дабла,
[57:48.640 --> 57:52.640]  и только затем он зашел в дефолтный конструктор для строки.
[57:52.640 --> 57:55.640]  А можно дефолтный конструктор?
[57:55.640 --> 57:59.640]  Кстати, заметьте, пятерка появилась.
[57:59.640 --> 58:05.640]  Вместо... ну, я не убрал ладуа, но все стало работать из-за сиаутов.
[58:05.640 --> 58:09.640]  Ну, потому что сиауты, они зачастую...
[58:09.640 --> 58:13.640]  Из-за сиаутов исчезают оптимизации некоторые.
[58:13.640 --> 58:15.640]  То есть он сказал...
[58:15.640 --> 58:19.640]  Оттого, что я закомпетирую сиауты, он станет работать по-другому.
[58:19.640 --> 58:21.640]  Не удивляйтесь. Что, что, что?
[58:21.640 --> 58:23.640]  Мы с твоей механикой, мы не можем вас не держать,
[58:23.640 --> 58:25.640]  потому что мы мы не жарим.
[58:25.640 --> 58:26.640]  Все так.
[58:26.640 --> 58:28.640]  Что он нас с этим делает?
[58:28.640 --> 58:32.640]  Ну, собственно, ошибка там, где нужно Slender будет поставить.
[58:32.640 --> 58:33.640]  Вау!
[58:33.640 --> 58:35.640]  Ты знаешь наперед, да.
[58:35.640 --> 58:37.640]  Нет, он видел, как мы стирали Slender.
[58:37.640 --> 58:39.640]  Нет, он неделю назад подходил и спрашивал.
[58:39.640 --> 58:43.640]  Так, ну, смотрите, на самом деле все-таки происходит неприятность.
[58:43.640 --> 58:45.640]  А именно сначала...
[58:45.640 --> 58:48.640]  Почему мы входим в дефолтный конструктор?
[58:48.640 --> 58:50.640]  Так мне же надо наследников проницилизировать.
[58:50.640 --> 58:51.640]  Наследников, а родителей?
[58:51.640 --> 58:52.640]  Родителей.
[58:52.640 --> 58:55.640]  Да, можно посмотреть, какой у нас дефолтный конструктор у родителей, пожалуйста.
[58:55.640 --> 58:56.640]  Пустой.
[58:56.640 --> 58:58.640]  Вот и конструктор у родителей ничего не делает.
[58:58.640 --> 58:59.640]  У него уже полей нет.
[58:59.640 --> 59:00.640]  Нет, нет, нет.
[59:00.640 --> 59:01.640]  Он всегда вызывает всегда.
[59:01.640 --> 59:02.640]  Ну, всегда.
[59:02.640 --> 59:03.640]  Да, хорошо.
[59:03.640 --> 59:06.640]  Ну, то есть вызывается конструктор вот этого вот...
[59:06.640 --> 59:09.640]  А мы получаем этот наш вопрос.
[59:09.640 --> 59:13.640]  Ну, в смысле, нет, еще не сконструирован storage в момент, когда мы заходим в конструктор,
[59:13.640 --> 59:14.640]  потому что он вызывается.
[59:14.640 --> 59:15.640]  Ну да.
[59:15.640 --> 59:18.640]  Он не сконструирован, ну и ладно.
[59:18.640 --> 59:19.640]  Нет.
[59:19.640 --> 59:24.640]  В смысле, мы вызываем его, мы к нему обращаемся, к несинферимому объекту.
[59:24.640 --> 59:25.640]  Вообще УБ должен быть.
[59:25.640 --> 59:26.640]  И УБ происходит.
[59:26.640 --> 59:27.640]  Все логично.
[59:27.640 --> 59:28.640]  Нет.
[59:28.640 --> 59:29.640]  Что?
[59:29.640 --> 59:31.640]  Где мы к storage обращаемся?
[59:31.640 --> 59:32.640]  В конструкторе...
[59:32.640 --> 59:34.640]  Смотри, у нас есть наследник.
[59:34.640 --> 59:36.640]  Чтобы смулировать наследник, мы сначала конструируем родителя,
[59:36.640 --> 59:39.640]  а родители берут поля наследника и инициализируют их.
[59:39.640 --> 59:40.640]  Что-то с ними делают.
[59:40.640 --> 59:41.640]  Да.
[59:41.640 --> 59:43.640]  Ну, типа все, УБ сворачивает.
[59:43.640 --> 59:46.640]  На самом деле вроде это нормально, потому что мы не поли...
[59:46.640 --> 59:48.640]  А мне важно, чем сейчас конструктор вообще?
[59:48.640 --> 59:52.640]  Потому что функция put, она что-то делает адекватное.
[59:52.640 --> 01:00:00.640]  У нас в storage сейчас не лежит ни один объект в сырой памяти.
[01:00:00.640 --> 01:00:01.640]  Ага.
[01:00:01.640 --> 01:00:04.640]  И мы вот в этот момент просто к сырой памяти storage...
[01:00:04.640 --> 01:00:06.640]  Время жизни storage еще не начало.
[01:00:06.640 --> 01:00:10.640]  Мы к обращаемся к сырой памяти storage и кладем туда int.
[01:00:10.640 --> 01:00:11.640]  Да.
[01:00:11.640 --> 01:00:16.640]  А потом все это отрабатывает.
[01:00:16.640 --> 01:00:21.640]  А потом только инициализируются поля, видимо, варианта.
[01:00:21.640 --> 01:00:24.640]  Видимо в том, что конструктор ничего не делает по умолчанию,
[01:00:24.640 --> 01:00:26.640]  поэтому ничего не меняется.
[01:00:26.640 --> 01:00:28.640]  Конструктор по умолчанию storage...
[01:00:28.640 --> 01:00:29.640]  Чего?
[01:00:29.640 --> 01:00:31.640]  Конструктор storage ничего не делает.
[01:00:31.640 --> 01:00:32.640]  Конструктор storage ничего не делает.
[01:00:32.640 --> 01:00:34.640]  Память не обнуляется, ничего не происходит.
[01:00:35.640 --> 01:00:41.640]  Так вот, компилятор просто видит, что в конце вызван дефолтный конструктор,
[01:00:41.640 --> 01:00:46.640]  и такой раз дефолтный конструктор вызван, значит, там можно обнулить.
[01:00:46.640 --> 01:00:48.640]  Значит, можно до этого ничего не делать с этой памятью,
[01:00:48.640 --> 01:00:50.640]  что бы там ни происходило.
[01:00:50.640 --> 01:00:51.640]  Ну...
[01:00:51.640 --> 01:00:52.640]  Ну...
[01:00:52.640 --> 01:00:53.640]  Сомнительно.
[01:00:53.640 --> 01:00:55.640]  Это О2, все нормально.
[01:00:57.640 --> 01:00:59.640]  Ну...
[01:00:59.640 --> 01:01:01.640]  Я не понимаю, почему это не УБМ.
[01:01:01.640 --> 01:01:03.640]  Так это УБМ, конечно.
[01:01:03.640 --> 01:01:05.640]  Почему оно так себя ведет?
[01:01:05.640 --> 01:01:07.640]  Конечно, это УБМ.
[01:01:07.640 --> 01:01:09.640]  Это УБМ, правильно.
[01:01:09.640 --> 01:01:12.640]  Главное понять настоящую причину, почему это УБМ.
[01:01:18.640 --> 01:01:19.640]  Вот.
[01:01:19.640 --> 01:01:21.640]  Так, а что у меня в storage написано?
[01:01:21.640 --> 01:01:23.640]  Да, в ряде гивнем.
[01:01:25.640 --> 01:01:27.640]  Собственно, здесь у меня куд.
[01:01:33.640 --> 01:01:35.640]  Ммм...
[01:01:39.640 --> 01:01:41.640]  Вот то, что создано, здесь мы вызовем...
[01:01:41.640 --> 01:01:43.640]  Это уже...
[01:01:43.640 --> 01:01:45.640]  Это не проблема, с одной памятью.
[01:01:45.640 --> 01:01:47.640]  Да, с одной памятью, это не проблема.
[01:01:47.640 --> 01:01:50.640]  Но то, что мы обращаемся к объекту до начала времени его жизни,
[01:01:50.640 --> 01:01:53.640]  и у него потом вызовется конструктор еще.
[01:02:00.640 --> 01:02:01.640]  Да...
[01:02:02.640 --> 01:02:05.640]  Сейчас меня начало это смущать, потому что...
[01:02:09.640 --> 01:02:11.640]  Потому что...
[01:02:11.640 --> 01:02:14.640]  Если это действительно так работает, то...
[01:02:15.640 --> 01:02:17.640]  Ваше понимание сломалось.
[01:02:17.640 --> 01:02:19.640]  Мое понимание, да, сломалось.
[01:02:19.640 --> 01:02:23.640]  Потому что я-то думал, что он все-таки называется Pochette после того, как мы...
[01:02:23.640 --> 01:02:26.640]  Что он инцелизирует storage...
[01:02:26.640 --> 01:02:29.640]  Короче, надо посмотреть в Assembler на подвидении.
[01:02:29.640 --> 01:02:31.640]  Я думал, что он инцелизирует...
[01:02:31.640 --> 01:02:34.640]  Вот, короче, что вот этот мерок называется после того...
[01:02:34.640 --> 01:02:37.640]  Можно просто проверить, в какой раз он инцелизирует.
[01:02:38.640 --> 01:02:39.640]  Да.
[01:02:39.640 --> 01:02:42.640]  Ну, скорее всего, он просто ничего не делает с ним.
[01:02:42.640 --> 01:02:46.640]  Ну, то есть, когда вызывается дефолтный конструктор storage...
[01:02:47.640 --> 01:02:51.640]  Когда вызывается дефолтный конструктор storage, ничего не происходит.
[01:02:51.640 --> 01:02:53.640]  Просто ничего не происходит.
[01:02:54.640 --> 01:02:58.640]  Вот. У него формально начинается время жизни, но ничего туда не плывется.
[01:02:58.640 --> 01:03:00.640]  При этом вот этот чел...
[01:03:01.640 --> 01:03:04.640]  Он ничего не делает, потому что он такой...
[01:03:04.640 --> 01:03:07.640]  Ну, все равно потом дефолтный конструктор storage вызывается.
[01:03:08.640 --> 01:03:10.640]  И, видимо, поэтому я тоже ничего не делаю.
[01:03:10.640 --> 01:03:12.640]  Он реально может пригодаться.
[01:03:13.640 --> 01:03:15.640]  Ну, по инструкции в порядке.
[01:03:15.640 --> 01:03:17.640]  По инструкции в порядке.
[01:03:19.640 --> 01:03:21.640]  Сейчас, когда у нас создается объект...
[01:03:22.640 --> 01:03:24.640]  Ну, он не причина, чтобы объявляться, да?
[01:03:24.640 --> 01:03:26.640]  У него уже сразу будет минопатия, да?
[01:03:26.640 --> 01:03:27.640]  Ну, это происходит все равно.
[01:03:27.640 --> 01:03:28.640]  Ну, да.
[01:03:28.640 --> 01:03:29.640]  То есть, она прямо...
[01:03:29.640 --> 01:03:30.640]  Конечно.
[01:03:30.640 --> 01:03:31.640]  Окей.
[01:03:31.640 --> 01:03:34.640]  Тогда дальше мы переходим к товарищу, который наш предыдущий конструктор, да?
[01:03:34.640 --> 01:03:39.640]  Пробегаемся, и потом мы с ним поставим обязательно уже пример.
[01:03:40.640 --> 01:03:43.640]  А дальше он пытается...
[01:03:44.640 --> 01:03:47.640]  Ну, сконструировать storage, ну, типа...
[01:03:48.640 --> 01:03:51.640]  Вступать, которую мы затронули, и при этом мы ее...
[01:03:51.640 --> 01:03:54.640]  Это ты говоришь, чтобы он делал без оптимизации.
[01:03:54.640 --> 01:03:56.640]  То есть, он буквально исполнял строшку за строчкой.
[01:03:56.640 --> 01:03:57.640]  Поэтому так и сработало.
[01:03:57.640 --> 01:03:59.640]  Типа, все нормально сработало.
[01:03:59.640 --> 01:04:01.640]  Нет, он, наоборот, должен был нормально сработать.
[01:04:01.640 --> 01:04:02.640]  Нет.
[01:04:02.640 --> 01:04:05.640]  Потому что он сейчас с оптимизацией, он не обязан делать то, что ему написал детство.
[01:04:05.640 --> 01:04:07.640]  Он может стимизировать это.
[01:04:07.640 --> 01:04:11.640]  Если ты попытаешься изменить память...
[01:04:12.640 --> 01:04:13.640]  Которая?
[01:04:13.640 --> 01:04:16.640]  Которая у тебя уже был выполнен констракт и не была выполнена...
[01:04:16.640 --> 01:04:19.640]  Там не был констракт, там было allocate.
[01:04:19.640 --> 01:04:20.640]  Понимаешь?
[01:04:20.640 --> 01:04:22.640]  Ты эту память алоцировал, но не инструировал еще.
[01:04:22.640 --> 01:04:23.640]  В этом ты прикол.
[01:04:23.640 --> 01:04:24.640]  А где мы конструируем память?
[01:04:24.640 --> 01:04:26.640]  После родителей.
[01:04:26.640 --> 01:04:29.640]  Сначала родители, потом сын.
[01:04:32.640 --> 01:04:34.640]  Конструируем непосредственно объект, который...
[01:04:35.640 --> 01:04:36.640]  Еще раз.
[01:04:36.640 --> 01:04:39.640]  И как происходит конструирование, если ты наследник кого-то?
[01:04:39.640 --> 01:04:41.640]  Выделяется память под всех вас.
[01:04:41.640 --> 01:04:42.640]  Да, да, да.
[01:04:42.640 --> 01:04:45.640]  Вызывается конструктор всех твоих родителей в каком-то порядке.
[01:04:45.640 --> 01:04:47.640]  Вызывается конструктор тебя.
[01:04:48.640 --> 01:04:49.640]  Вот смотри.
[01:04:49.640 --> 01:04:53.640]  Вырезается память, которая относится именно к тебе, не к твоим родителям.
[01:04:53.640 --> 01:04:55.640]  Нашего конструктора мы уже узнали, конструктор родителя.
[01:04:57.640 --> 01:04:59.640]  Формаева наш конструктор есть, представляете, using.
[01:04:59.640 --> 01:05:00.640]  Устой.
[01:05:00.640 --> 01:05:01.640]  Что это значит?
[01:05:01.640 --> 01:05:02.640]  Что мы как бы...
[01:05:05.640 --> 01:05:07.640]  Еще в какой-то момент вызывается конструктор наших полей.
[01:05:07.640 --> 01:05:08.640]  Вот это очень интересно.
[01:05:08.640 --> 01:05:12.640]  Они вызываются после конструктора наших родителей.
[01:05:14.640 --> 01:05:15.640]  Вот проблема вот эта.
[01:05:15.640 --> 01:05:18.640]  Потому что у тебя конструктор, твоя волда...
[01:05:18.640 --> 01:05:20.640]  Что такое using конструктор?
[01:05:20.640 --> 01:05:26.640]  Конструктор storage, это то, что вызывается, его он вызывает, а там в ту же паре он вызывается
[01:05:26.640 --> 01:05:30.640]  Его уже используют на объекты, скорее всего, он нравится
[01:05:30.640 --> 01:05:32.640]  Ну, нет, он не совсем
[01:05:32.640 --> 01:05:34.640]  Да, все так
[01:05:34.640 --> 01:05:37.640]  Сначала вызывается конструкторы всех родителей
[01:05:37.640 --> 01:05:38.640]  Это логично
[01:05:38.640 --> 01:05:41.640]  Потом только конструктор variadic и union
[01:05:42.640 --> 01:05:44.640]  Ммм
[01:05:46.640 --> 01:05:50.640]  И конструктор variadic и union ничего не делает
[01:05:50.640 --> 01:05:56.640]  Но из-за того, что он ничего не делает, имплядер может позволить себе отменить все, что сделано до этого
[01:05:56.640 --> 01:05:58.640]  На этой памяти
[01:05:58.640 --> 01:06:00.640]  Да, это правда
[01:06:00.640 --> 01:06:03.640]  И я не понимаю, как мы вообще можем сделать так, чтобы это не было упадет
[01:06:03.640 --> 01:06:07.640]  Мы можем сделать так, чтобы это работало, например, с аутом
[01:06:07.640 --> 01:06:13.640]  Ну, надо просто как-то заставить его явно сразу кинцелизировать storage
[01:06:13.640 --> 01:06:15.640]  За мнением делающих
[01:06:18.640 --> 01:06:21.640]  А, ну, кстати, возможно, да, он может, типа, зачищать storage
[01:06:21.640 --> 01:06:24.640]  Мы в разе не можем менять порядок инсталлирования, в смысле
[01:06:24.640 --> 01:06:26.640]  Мы умеем отметить активизацию, как сказал
[01:06:28.640 --> 01:06:32.640]  Это все равно UBS, в смысле, формально, даже если это работает, это...
[01:06:32.640 --> 01:06:34.640]  Ну
[01:06:34.640 --> 01:06:36.640]  Добро пожаловать
[01:06:36.640 --> 01:06:38.640]  Да, ну, короче
[01:06:38.640 --> 01:06:41.640]  То, что я хотел сказать, вот в чем заключается
[01:06:41.640 --> 01:06:43.640]  Есть такая волшебная функция?
[01:06:43.640 --> 01:06:45.640]  Да
[01:06:45.640 --> 01:06:47.640]  Нет
[01:06:52.640 --> 01:06:55.640]  Я сейчас закомментирую все, если да, си аут
[01:06:58.640 --> 01:07:00.640]  Что здесь написано?
[01:07:02.640 --> 01:07:04.640]  Закомментирую, если да, си аут
[01:07:04.640 --> 01:07:10.640]  А, только, кажется, не весь, потому что си ауты две строчки кое-где
[01:07:10.640 --> 01:07:13.640]  И вот эта часть не закомментируется
[01:07:13.640 --> 01:07:15.640]  Я хотел сложить этот винт, да
[01:07:15.640 --> 01:07:20.640]  Вот, да, сейчас мы увидим, что все падает снова
[01:07:20.640 --> 01:07:23.640]  А под силенгом, кстати, не падает
[01:07:23.640 --> 01:07:25.640]  Силенг просто без активизации
[01:07:25.640 --> 01:07:26.640]  Чего?
[01:07:26.640 --> 01:07:29.640]  Да даже O3 все равно, он просто не оптимизирует
[01:07:29.640 --> 01:07:31.640]  Он предваряется
[01:07:31.640 --> 01:07:34.640]  Вот, есть такая функция
[01:07:34.640 --> 01:07:37.640]  Ну, короче, просто сейчас расскажу
[01:07:37.640 --> 01:07:39.640]  Какая-то проблема решается, как это работает
[01:07:39.640 --> 01:07:41.640]  И придется до следующего раза обложить
[01:07:41.640 --> 01:07:43.640]  Есть такая замечательная функция
[01:07:43.640 --> 01:07:46.640]  This is delonder, вот она тут должна быть использована
[01:07:49.640 --> 01:07:53.640]  Что она говорит компилятору?
[01:07:53.640 --> 01:08:00.640]  По сути, эта функция говорит компилятору, что вот это обращение нельзя оптимизировать
[01:08:00.640 --> 01:08:02.640]  Где?
[01:08:02.640 --> 01:08:11.640]  Значит, почему компилятор иногда решает пропустить вот эту часть?
[01:08:11.640 --> 01:08:13.640]  Почему он решает ее пропустить?
[01:08:13.640 --> 01:08:18.640]  Потому что он из некоторых соображений решает, что
[01:08:18.640 --> 01:08:29.640]  Ну, у нас под этим указателем лежит значение, которое и так заведомо известно какое
[01:08:29.640 --> 01:08:36.640]  Я не буду тратить время на его перезапись, потому что оно
[01:08:36.640 --> 01:08:44.640]  Из некоторых соображений, связанных с УБ, связанных с нарушением вами контракта
[01:08:44.640 --> 01:08:48.640]  Что вы не кладете подряд два раза одно и то же на один и тот же адрес
[01:08:48.640 --> 01:08:52.640]  Компилятор решает, что второй раз пласть он не будет
[01:08:52.640 --> 01:08:54.640]  Ну, по сути, здесь именно это происходит
[01:08:54.640 --> 01:08:56.640]  Только компилятор первый раз решает, что он ничего пласть не будет
[01:08:56.640 --> 01:08:58.640]  Да и второй тоже
[01:08:58.640 --> 01:09:01.640]  Второй раз он ничего не кладет, потому что вы ничего не инициализируете
[01:09:01.640 --> 01:09:03.640]  Первый раз он не кладет, потому что вы все равно положите
[01:09:03.640 --> 01:09:05.640]  Второй раз, какая ему разница?
[01:09:05.640 --> 01:09:07.640]  Ну, это УБ
[01:09:07.640 --> 01:09:10.640]  Вот, std-londer это функция, которая
[01:09:10.640 --> 01:09:13.640]  Очень трудно объяснить, что делает на самом деле
[01:09:13.640 --> 01:09:15.640]  Можем посмотреть, если хоббель отличен
[01:09:15.640 --> 01:09:19.640]  Нет, она и принцип, она built-in londer и там assembler
[01:09:19.640 --> 01:09:25.640]  Там даже не assembler, там intermediate representation
[01:09:25.640 --> 01:09:28.640]  Ее нельзя написать самостоятельно
[01:09:28.640 --> 01:09:30.640]  Она чисто
[01:09:30.640 --> 01:09:38.640]  Она на ходе внутренней имплементации компилятора
[01:09:38.640 --> 01:09:40.640]  Она не на плюсах реализована
[01:09:40.640 --> 01:09:50.640]  Она, короче говоря, предотвращает оптимизацию компилятора, которая разрешает не делать это обращение
[01:09:50.640 --> 01:09:54.640]  По сути, она говорит, забудь, что ты раньше знал об этом сказателе
[01:09:54.640 --> 01:09:56.640]  И сделай все равно то, что я тебя прошу
[01:09:56.640 --> 01:09:58.640]  Не оптимизируй это обращение
[01:09:58.640 --> 01:10:00.640]  Yes, do what I say
[01:10:00.640 --> 01:10:02.640]  Я тебя очень прошу
[01:10:02.640 --> 01:10:04.640]  Что-то вроде забудь, что вообще лежал раньше
[01:10:04.640 --> 01:10:07.640]  Поэтому адресу памяти и читай, что это
[01:10:07.640 --> 01:10:09.640]  Да, почему londer?
[01:10:09.640 --> 01:10:11.640]  Ну, londer значит постирать
[01:10:11.640 --> 01:10:13.640]  Бельмё постирать, еще деньги отмывать
[01:10:13.640 --> 01:10:15.640]  Money это значит отмывание денег
[01:10:15.640 --> 01:10:17.640]  Снимаком, комитет
[01:10:17.640 --> 01:10:19.640]  Ааа
[01:10:19.640 --> 01:10:22.640]  Значит, londer это функция, которая говорит
[01:10:22.640 --> 01:10:24.640]  Не забудь, что ты знал раньше об этом указателе
[01:10:24.640 --> 01:10:26.640]  Возможно, у тебя есть какие-то о нем предположения
[01:10:26.640 --> 01:10:28.640]  Так вот, не делай их
[01:10:28.640 --> 01:10:33.640]  Тем самым предотвращает оптимизацию, что можно не перезаписывать
[01:10:33.640 --> 01:10:35.640]  И это актуально в случае варианта
[01:10:35.640 --> 01:10:37.640]  Например, когда вы кладете
[01:10:37.640 --> 01:10:39.640]  Когда у вас что-то лежало по этому адресу памяти
[01:10:39.640 --> 01:10:41.640]  А потом вы туда кладете что-то другое
[01:10:41.640 --> 01:10:43.640]  Компилятор в этот момент, он может
[01:10:43.640 --> 01:10:45.640]  Если вы там
[01:10:47.640 --> 01:10:49.640]  Даже если вы вызвали деструктор
[01:10:49.640 --> 01:10:51.640]  Компилятор такой может
[01:10:51.640 --> 01:10:53.640]  Вообще, при некоторых условиях
[01:10:53.640 --> 01:10:55.640]  Компилятор может предполагать
[01:10:55.640 --> 01:10:57.640]  Что там лежит то же самое
[01:10:57.640 --> 01:10:59.640]  Что и раньше и не будет заново считывать указатель
[01:10:59.640 --> 01:11:01.640]  Ну, например, если у вас был тип
[01:11:01.640 --> 01:11:03.640]  В котором константное поле
[01:11:03.640 --> 01:11:05.640]  А потом бы в плейсмент нею туда
[01:11:05.640 --> 01:11:07.640]  Положили другое константное поле
[01:11:07.640 --> 01:11:09.640]  Но компилятор может предположить, что
[01:11:09.640 --> 01:11:11.640]  Константа не изменилась, поскольку она была константой
[01:11:11.640 --> 01:11:13.640]  А второй раз класть на ту же память
[01:11:13.640 --> 01:11:15.640]  Вы, по идее, не должны
[01:11:15.640 --> 01:11:17.640]  Если вы не сделали это
[01:11:17.640 --> 01:11:19.640]  Совсем правильно, что компилятор не заметил
[01:11:19.640 --> 01:11:21.640]  Что время жизни объекта закончился
[01:11:21.640 --> 01:11:23.640]  Потом снова началось время жизни другого объекта
[01:11:23.640 --> 01:11:25.640]  Компилятор может иметь предположение
[01:11:25.640 --> 01:11:27.640]  Относительно указать, что там что-то лежит уже
[01:11:27.640 --> 01:11:29.640]  Вот Sdlonder предотвращает это предположение
[01:11:29.640 --> 01:11:31.640]  И заставляет компилятор
[01:11:31.640 --> 01:11:33.640]  Не использовать, тихо положу туда, все равно
[01:11:33.640 --> 01:11:35.640]  Короче, с Sdlonder это будет
[01:11:35.640 --> 01:11:37.640]  Работать правильно
[01:11:37.640 --> 01:11:39.640]  Только 5 почему-то не вывелось
[01:11:39.640 --> 01:11:41.640]  Потому что я весь Сяутик
[01:11:41.640 --> 01:11:43.640]  А, потому что я весь Сяутик
[01:11:43.640 --> 01:11:45.640]  Да, но ассерт не упал
[01:11:45.640 --> 01:11:47.640]  Вот, короче, мораль
[01:11:47.640 --> 01:11:49.640]  Для отечественного кода Sdlonder
[01:11:49.640 --> 01:11:51.640]  Когда будет реализовывать вариант
[01:11:51.640 --> 01:11:53.640]  Когда вы обращаетесь к
[01:11:53.640 --> 01:11:55.640]  Именно в путе, да
[01:11:55.640 --> 01:11:57.640]  Ну вот когда вы делаете пут
[01:11:57.640 --> 01:11:59.640]  Может быть нужно это использовать
[01:11:59.640 --> 01:12:01.640]  Потому что иначе
[01:12:01.640 --> 01:12:03.640]  При оптимизации он проигнорирует
[01:12:03.640 --> 01:12:05.640]  Для отечественного кода
[01:12:05.640 --> 01:12:07.640]  Sdlonder
[01:12:07.640 --> 01:12:09.640]  Есть что-то такое
[01:12:09.640 --> 01:12:11.640]  Для отечественного кода используется ли Sdlonder
[01:12:11.640 --> 01:12:13.640]  Нет, но там чуть другая реализация
[01:12:13.640 --> 01:12:15.640]  Вот, я не понимаю, почему это
[01:12:15.640 --> 01:12:17.640]  Явно сочетается УБ
[01:12:19.640 --> 01:12:21.640]  Границы разумеют
[01:12:21.640 --> 01:12:23.640]  Просто
[01:12:23.640 --> 01:12:25.640]  Все, давайте
[01:12:25.640 --> 01:12:27.640]  До следующего раза
[01:12:27.640 --> 01:12:29.640]  Я хотя бы быстренько
[01:12:29.640 --> 01:12:31.640]  Поперек, что делает Sdlonder
[01:12:31.640 --> 01:12:33.640]  Компания, типа
[01:12:33.640 --> 01:12:35.640]  Она же какой-то
[01:12:35.640 --> 01:12:37.640]  Ассендертом инжинирует
[01:12:37.640 --> 01:12:39.640]  Ну или меняет ассендерации
[01:12:39.640 --> 01:12:41.640]  Она как раз
[01:12:41.640 --> 01:12:43.640]  Ну вот, вот у меня есть
[01:12:43.640 --> 01:12:45.640]  Собственно вот
[01:12:45.640 --> 01:12:47.640]  Вот как выглядит этот код
[01:12:47.640 --> 01:12:49.640]  В ассемблере без
[01:12:49.640 --> 01:12:51.640]  Без Sdlonder
[01:12:51.640 --> 01:12:53.640]  А вот как с Sdlonder
[01:12:53.640 --> 01:12:55.640]  Ну
[01:12:55.640 --> 01:12:57.640]  Сама с Sdlonder ничего понятного
[01:12:57.640 --> 01:12:59.640]  Генерирует, она наоборот
[01:12:59.640 --> 01:13:01.640]  Запрещает компилятору оптимизировать некоторые
[01:13:01.640 --> 01:13:03.640]  Ассембльные инструкции
[01:13:03.640 --> 01:13:05.640]  То есть с Sdlonder, я в том, что я добавлю Sdlonder
[01:13:05.640 --> 01:13:07.640]  Ассемблера станет больше
[01:13:07.640 --> 01:13:09.640]  Потому что действие компилятора
[01:13:09.640 --> 01:13:11.640]  Буду нужно сделать больше
[01:13:11.640 --> 01:13:13.640]  Ассемблерная инструкция во что-то транслируется
[01:13:13.640 --> 01:13:15.640]  Раньше она ни во что не транслировалась
[01:13:15.640 --> 01:13:17.640]  Сейчас
[01:13:17.640 --> 01:13:19.640]  Где это у нас
[01:13:19.640 --> 01:13:21.640]  Вот она
[01:13:21.640 --> 01:13:23.640]  Ну по сути вот
[01:13:23.640 --> 01:13:25.640]  Кладет 5 туда
[01:13:25.640 --> 01:13:27.640]  Если я закомментирую
[01:13:27.640 --> 01:13:29.640]  То она вообще ни в какой ассемблер не транслируется
[01:13:29.640 --> 01:13:31.640]  Эта инструкция
[01:13:31.640 --> 01:13:33.640]  То есть от того, что добавил Sdlonder
[01:13:33.640 --> 01:13:35.640]  Появились новые ассемблерные инструкции
[01:13:35.640 --> 01:13:37.640]  Просто компилятор не оптимизировал эту часть
