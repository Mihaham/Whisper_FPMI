[00:00.000 --> 00:12.920]  Так, ладно, всем привет. Поздравляю с началом семестра и с тем, что я наконец-то могу видеть
[00:12.920 --> 00:21.320]  вас вживьем, а не только показывать себя в пустой аудитории. В прошлый раз мы начали
[00:21.320 --> 00:29.440]  большую тему про межпроцессное взаимодействие, и собственно это будет половина семестра. В прошлый
[00:29.440 --> 00:34.400]  раз мы рассмотрели один из простых способов взаимодействия между процессами по названиям
[00:34.400 --> 00:43.480]  каналы. Сегодня будет еще один из способов, который называется сигнал. Итак, давайте я напомню о том,
[00:43.480 --> 00:50.400]  что такое процессы в очередной раз. Процесс это такая штуковина, которая выполняется изолированно
[00:50.400 --> 00:58.680]  и выполняет какую-то программу, у которой обычно есть начало и есть конец. То есть у нас программа
[00:58.680 --> 01:03.720]  в какой-то момент времени может завершиться, хотя совершенно не обязательно. Например,
[01:03.720 --> 01:11.320]  завершается функция main, которая обычно возвращает int, либо заканчивается немножко раньше, чем
[01:11.320 --> 01:19.720]  закончится функция main, если вы вызовете функцию exit, либо системный вызов exit, который вызывается
[01:19.720 --> 01:27.080]  из функции exit. И тем самым ваш процесс завершится и вернет какой-то целочисленный код возврата
[01:27.080 --> 01:36.600]  размером 1 байт. Затем родительский процесс может вызвать weight pit либо weight для того,
[01:36.600 --> 01:42.280]  чтобы получить 32-битное число, большое число, которое содержит причину завершения процесса,
[01:42.280 --> 01:49.920]  и в том числе извлечь этот байт с кодом возврата. Но на самом деле процессы могут завершаться не
[01:49.920 --> 01:58.440]  только добровольно, но и по каким-то другим причинам. Например, процесс может получить
[01:58.440 --> 02:06.840]  так называемый сигнал в одной из нескольких причин. Самый простой способ послать процессу сигнал
[02:06.840 --> 02:14.160]  это набрать в терминале команду kill либо kill all. Команда kill требует явного указания процесса ID,
[02:14.160 --> 02:22.920]  kill all в качестве аргумента принимает название исполняемого файла и прибивает все экземпляры этого
[02:22.920 --> 02:28.400]  исполняемого файла. И тем самым вы просто завершаете работу процесса, не дождавшись,
[02:28.400 --> 02:36.920]  пока он честно дойдет до функции exit, либо до конца функции my. Если вы программу запускаете из
[02:36.920 --> 02:44.680]  терминала, вы можете нажать CTRL-C, вы можете просто закрыть вкладку терминала, либо банально ваша
[02:44.680 --> 02:51.400]  программа может получить какую-то ошибку, segmentation fault, еще что-нибудь. Да, ну еще можно просто выключить
[02:51.400 --> 02:58.480]  компьютер. И в какой момент времени у нас приходят все эти события? Ну, очевидно, в те моменты времени,
[02:58.480 --> 03:03.320]  про которые процесс совершенно ничего не знает, это просто какой-то рандом с точки зрения выполнения
[03:03.320 --> 03:09.600]  программы. Но по-хорошему процесс должен иметь возможность как-то эти ситуации обрабатывать.
[03:09.600 --> 03:16.480]  Например, если у вас есть какие-то критичные данные, которые нельзя потерять, то, естественно,
[03:16.480 --> 03:22.080]  при получении сигнала нужно сначала эти данные сохранить, а потом завершить свою работу. В чем
[03:22.080 --> 03:27.520]  еще особенность завершения работы процесса с помощью сигнала? В этом случае у нас становится
[03:27.520 --> 03:34.720]  неопределенным код возврата, и когда вы с помощью weight либо weight pit читаете это состояние, то эту
[03:34.720 --> 03:40.000]  ситуацию нужно обрабатывать отдельно, то есть проверять, что программа действительно завершилась
[03:40.000 --> 03:45.640]  кодом возврата, тогда вы код возврата можете извлечь. Либо другая ситуация, если программа
[03:45.640 --> 03:50.640]  завершилась с помощью сигнала, и в этом случае вы можете узнать, а по какой именно причине, то есть
[03:50.640 --> 03:59.480]  из-за какого сигнала ваш процесс был завершен? Из-за чего могут возникать сигналы? Сигналы
[03:59.480 --> 04:07.640]  могут посылаться процессу либо другим процессом, либо ядром, ну и процессы сами себе тоже могут
[04:07.640 --> 04:16.000]  посылать сигнал. Какие ошибки могут быть? Самая частая ошибка, которую вы, наверное, встречали,
[04:16.000 --> 04:24.160]  это нарушение сегментации. Обычно возникает, если вы пытаетесь обратиться к какому-то области памяти,
[04:24.160 --> 04:30.560]  которая не отображается на виртуальное адресное пространство, либо вы пытаетесь сделать что-то с
[04:30.560 --> 04:35.280]  памятью, не имея на это достаточных прав. Например, какой-то участок у вас отображается как память
[04:35.280 --> 04:43.400]  только для чтения, а вы пытаетесь что-то туда записать. Либо на современных системах вы
[04:43.400 --> 04:52.520]  пытаетесь выполнить код из участка памяти, для которого не предоставлен флаг исполняемый. Кроме того,
[04:52.520 --> 05:01.000]  в прошлый раз мы еще рассмотрели каналы, и у каналов есть одна особенность, что когда вы хотите
[05:01.000 --> 05:08.200]  что-то прочитать из каналов, с которым не связана никакая записывающая сторона, то системный
[05:08.200 --> 05:13.720]  изофрит просто блокируется, можете наступить на дедлог. А если вы пытаетесь записать что-то в
[05:13.720 --> 05:18.440]  канал, который никто не читает, тогда вы получаете ошибку. Broken pipe это тоже сигнал,
[05:18.440 --> 05:24.640]  который вам посылает ядро операционной системы. Ну и разные исключения процессора тоже могут
[05:24.640 --> 05:31.360]  всплывать в виде сигналов. Например, неверная инструкция, когда такой сигнал возникает. Например,
[05:31.360 --> 05:36.520]  когда вы пытаетесь на каком-нибудь старом процессоре выполнять код, который не поддерживается.
[05:36.840 --> 05:42.160]  Берем например интеловский процессор десятилетней давности, пытаемся на нем выполнить что-то в
[05:42.160 --> 05:51.880]  x2, все приплыли. Ну и другие исключения процессора, например, деление на 0. Процесс тоже сам себе может
[05:51.880 --> 06:00.320]  посылать сигналы. Обычно это редкая история, и нужно для того, чтобы сломать наш процесс
[06:00.320 --> 06:06.640]  принудительно. Вставить, например, какую-нибудь конструкцию Assert, либо abort, функция есть такая.
[06:06.640 --> 06:15.520]  Для чего это бывает нужно? Проверка каких-то условий. И если у вас код обычно скомпилирован в дебаг
[06:15.520 --> 06:20.200]  режиме, а не в релиз, то лучше уж пусть процесс грохнется, чтобы можно было исследовать его
[06:20.200 --> 06:31.600]  состояние, чем он будет выполнять что-то неправильное. Может быть какой-то другой
[06:31.600 --> 06:37.520]  процесс, который посылает вам сигнал, и если другой процесс может отправлять вам сигнал,
[06:37.520 --> 06:43.960]  то, наверное, этот способ можно в том числе использовать как способ межпроцессного взаимодействия.
[06:43.960 --> 06:51.760]  Что такое сигнал? Сигнал это какое-то асинхронное событие. Асинхронное это значит,
[06:51.760 --> 06:57.160]  что оно прилетает в любой произвольный момент времени. И что можно делать при получении сигнала?
[06:57.160 --> 07:03.200]  Есть стандартные реакции на разные сигналы. Например, сигнал можно просто проигнорировать.
[07:03.200 --> 07:10.320]  Пример такой ситуации, это когда вы запускаете какой-то дочерний процесс, затем этот дочерний
[07:10.320 --> 07:15.600]  процесс завершает свою работу, и при этом ядро посылает вам сигнал о том, что ваш дочерний
[07:15.600 --> 07:23.800]  процесс завершился. Понятно, что лишний раз завершать свою работу, грохаться на каждый
[07:23.800 --> 07:28.080]  завершенный дочерний процесс, это очень странно. Поэтому действия по умолчанию для таких ситуаций,
[07:28.080 --> 07:34.200]  это просто игнорировать такие сигналы. Хотя эту ситуацию можно в том числе обработать. Большинство
[07:34.200 --> 07:41.720]  сигналов стандартных приводят к немедленному завершению работы процесса. Классический пример
[07:41.720 --> 07:50.280]  это команда kill, которая по умолчанию отправляет сигнал SIGTERM. Этот сигнал, конечно, может быть
[07:50.280 --> 07:54.880]  перехвачен, но тем не менее действие по умолчанию это завершить свою работу. И есть сигналы,
[07:54.880 --> 08:00.200]  которые просто меняют состояние процесса. Состояние процесса бывает выполняется,
[08:00.200 --> 08:08.040]  приостановлен, поставлен на паузу и так далее. И это бывает удобно, например, если вы запускаете
[08:08.040 --> 08:13.840]  какой-то процесс из-под отладчика, и в этом случае нажатие кнопочек выполнить следующую строку,
[08:13.840 --> 08:20.560]  продолжить выполнение и так далее, они как раз управляются с помощью сигналов. То есть есть некоторые
[08:20.560 --> 08:28.880]  действия по умолчанию, и вы можете запрограммировать какие-то произвольные действия на большинство
[08:28.880 --> 08:38.000]  сигналов, но не на все. Итак, есть некоторые стандартные сигналы. Некоторые из них отправляются
[08:38.000 --> 08:48.800]  ядром. Это, например, SIGHUB, SIGIL, но вообще можно любой абсолютно сигнал отправить с помощью команды
[08:48.800 --> 09:01.040]  KILL. К чему приводят разные сигналы и из-за чего они возникают? Самый распространенный сигнал,
[09:01.040 --> 09:06.480]  который вы можете посылать, это нажатие клавиш Ctrl-C. Посылает сигнал с номером 2,
[09:06.480 --> 09:12.800]  он же SIGINT, который по умолчанию приводит к завершению процесса. Код возврата,
[09:12.800 --> 09:19.120]  при этом, естественно, не определен. Кроме того, процесс может завершаться по другим причинам.
[09:19.120 --> 09:25.960]  Например, если вы закрываете вкладку терминала, то у вас пропадают стандартные потоки ввода и
[09:25.960 --> 09:33.640]  вывода SD-IN и SD-OUT, и процесс при этом получает сигнал SIGHUB. Это совершенно другой сигнал,
[09:33.640 --> 09:40.280]  другая причина завершения работы. Если у вас возникает неверная инструкция либо деление на ноль,
[09:40.280 --> 09:48.640]  то тоже ядро отправляет сигнал, который, в отличие от простого завершения, может еще
[09:48.640 --> 09:57.800]  при этом приводить к созданию дампа памяти, ну или процесс может сам себя прибить. Давайте
[09:57.800 --> 10:05.160]  посмотрим, как можно поубивать процесс разными способами. Для этого нам нужен процесс,
[10:05.160 --> 10:14.440]  который, например, ничего не делает. Вот простая программа, которая не делает ничего и при этом
[10:14.440 --> 10:20.520]  старается не мешать другим процессам. Еще один возможный вариант описания такой программы
[10:20.520 --> 10:26.480]  SHED-YIELD поменять на какой-нибудь SLEEP. В этом случае вы будете меньше расходовать аккумулятор ноутбука,
[10:26.480 --> 10:33.960]  но при этом SHED-YIELD точно так же, как и SLEEP, не мешает выполнению других процессов. Запустим
[10:33.960 --> 10:40.440]  нашу программу, ну и теперь предложите способы ее прибить, учитывая, что она сама никогда не
[10:40.440 --> 10:49.520]  завершает свою работу. Как это можно сделать? Самые разные, да. Ну, очевидно, CTRL-C. Нажали,
[10:49.520 --> 10:55.640]  что сделать в нашей программе. Она получилась сигнал SIGINT, мы ее прибили. Так, ладно, следующий
[10:55.640 --> 11:11.720]  способ. Да, банально закрыть вкладку. Все, программа завершилась. Так, еще способы. Я могу, да,
[11:11.720 --> 11:22.520]  открыть другую вкладку, набрать команду ps, найти наш процесс и, зная его процесс ID,
[11:22.520 --> 11:35.560]  набрать команду kill и наш процесс был завершен. То же самое я могу назвать набрать команду kill all,
[11:35.560 --> 11:42.360]  если мне лень искать наш процесс. На самом деле это опасный способ. Вдруг у вас есть еще какой-нибудь
[11:42.360 --> 11:54.040]  процесс с таким же исполняемым файлом, будут прибиты все. Так, ну и еще один способ, это нажать
[11:54.040 --> 12:02.640]  сочетание клавиш CTRL-SLASH, слэш вот такой. В этом случае программа тоже завершит свою работу,
[12:02.640 --> 12:11.880]  но в отличие от CTRL-C, она еще получает сообщение к виду, и что-то у нас тут делается, пока не делается,
[12:11.880 --> 12:21.360]  но сейчас будем добиваться, чтобы оно сделалось. А именно, чем отличается принципиально сигнал
[12:21.360 --> 12:29.720]  CGBRT, который завершает свою работу процесса с некоторым core dump от обычного завершения,
[12:29.720 --> 12:39.120]  например, по CTRL-C. Есть такое понятие, как core dump. Это просто образ памяти, один в один,
[12:39.120 --> 12:43.920]  что у нас хранится в памяти процесса, который может быть сохранен на диск для того,
[12:43.920 --> 12:50.280]  чтобы дальше можно было это исследовать обычным отладщиком ГДБ. Естественно, для этого у вашей
[12:50.280 --> 13:00.600]  программы должна быть отладочная информация, иначе этот core dump будет совершенно
[13:00.600 --> 13:07.080]  бессмысленным. И что обычно происходит с core dump? В большинстве линукс-дистрибутивов эти core
[13:07.080 --> 13:16.520]  dump просто либо игнорируются, либо могут быть переданы разработчику, то есть возникает окошко
[13:16.520 --> 13:22.280]  о том, что программа завершила свою работу некорректно, сообщите разработчику о том,
[13:22.280 --> 13:27.400]  что пошло не так. И что у вас происходит в этот момент? В этот момент просто отправляется core dump.
[13:27.400 --> 13:32.240]  Хотя, на самом деле, не всегда core dump могут быть полезны, некоторые из них могут требовать
[13:32.240 --> 13:38.400]  отдельной отладочной информации, но разработчики уже с этим самим разберутся. И как понять,
[13:38.400 --> 13:45.960]  что у вас происходит с core dump? Нужно посмотреть переменную kernel-core-pattern. Это специальная
[13:45.960 --> 13:52.960]  системная переменная, настройка ядра, которая проверяется либо стенлозом sysctl, либо командой
[13:52.960 --> 14:09.960]  sysctl. Sysctl с опцией "-a", отображает все переменные нашего ядра, ну и можно поставить либо найти
[14:09.960 --> 14:20.920]  вот такую переменную kernel-core-pattern, которая определяет шаблон. Да, тут много всяких еще
[14:20.920 --> 14:30.800]  других названий, которые недоступны, но вот kernel-core-pattern — это некоторый шаблон имени файла,
[14:30.800 --> 14:36.720]  который может содержать, в том числе, например, process ID, полный путь программы и так далее через
[14:36.720 --> 14:43.080]  процентики. То есть это некоторый шаблон, который определяет имя файла для создания core dump.
[14:43.080 --> 14:48.240]  Если этот шаблон начинается с вертикальной черты в некоторых дистрибутивах, например,
[14:48.240 --> 14:55.080]  Fedora или OpenSUSE, это именно так и сделано, то core dump просто направляется некоторому сервису,
[14:55.080 --> 15:00.600]  который обрабатывает эти core dump, и в зависимости от того, что это за dump, уже выполняет какие-то
[15:00.600 --> 15:05.400]  дополнительные действия. Либо игнорирует, либо предлагает отправить разработчику. Итак,
[15:05.400 --> 15:13.520]  должен по идее создаться файл под названием core, если я нажму ctrl-slash, либо запущу какой-то
[15:13.520 --> 15:24.560]  процесс, который делает, например, вот такую штуку. Если программа где-то вызывает функцию abort,
[15:24.560 --> 15:32.480]  которая сама в себе, саму процессу посылает сигнал cgbrt, то у нас дополнительно создается core dump.
[15:32.480 --> 15:39.360]  Давайте я запущу, например, скомпилирую эту программу с отладочной информацией, то есть
[15:39.760 --> 15:54.640]  с опцией "-g". Теперь, что ожидается, когда я запущу эту программу? Естественно, она грохнется,
[15:54.640 --> 16:07.400]  и ожидается, что будет создан файл под названием core, но файл почему-то не создался. Это связано с
[16:07.400 --> 16:16.360]  тем, что есть еще ограничение на максимально возможный размер core файла. В некоторых дистрибутивов
[16:16.360 --> 16:24.120]  по умолчанию он равен нулю, но это ограничение не является жестким, и можно указать какой-нибудь
[16:24.120 --> 16:30.680]  не нулевой размер в блоках. Блок — это одна страница памяти. Все, вот я поменял этот лимит.
[16:30.760 --> 16:40.760]  Теперь я могу еще раз запустить какую-то программу. Все, у нас процесс грохнулся по сигналу cgbrt. При этом
[16:40.760 --> 16:47.720]  у нас создался dump-хедра, вот появился файл под названием core. Что теперь с этим файлом я могу
[16:47.720 --> 16:57.120]  сделать? Теперь я могу набрать команду gdb, дальше название исполняемого файла, и еще я могу добавить
[16:57.480 --> 17:04.480]  в качестве аргумента имя core файла, который у меня раньше получился. Причем это можно сделать
[17:04.480 --> 17:09.040]  не обязательно на том же самом компьютере, это можно сделать на другом компьютере, главное перекинуть core
[17:09.040 --> 17:19.440]  файл. Теперь можно посмотреть на backtrace вызова, и вот мы видим, что наша программа грохнулась,
[17:19.440 --> 17:27.000]  потому что где-то из стандартной сибиблиотеки мы вызвали какую-то функцию gi-race, чего-то там из
[17:27.000 --> 17:35.400]  функции ji-abort, которая в свою очередь была вызвана из функции main в пятой строчке до abort.c. И таким
[17:35.400 --> 17:42.920]  образом можно уже после того, как программа грохнулась, разбираться в причинах, а что же у нас пошло не так.
[17:43.920 --> 17:56.760]  Так, что у нас еще есть с сигналами? На самом деле это не темно-коричневый цвет, это красный цвет. Есть
[17:56.760 --> 18:04.480]  некоторые сигналы, которые являются очень жесткими, сейчас мы про это отдельно поговорим,
[18:04.480 --> 18:11.200]  так давайте придемся по всем остальным сигналам. Некоторые сигналы, которые могут генерироваться
[18:11.200 --> 18:18.440]  ядром, это нарушение сегментации, broken pipe, ну и кроме того есть стандартный сигнал,
[18:18.440 --> 18:23.380]  который посылается по умолчанию командой kill. На самом деле команде kill можно передавать все эти
[18:23.380 --> 18:31.400]  имена и посылать не только сектерам по умолчанию, но и все остальное. Есть еще ситуация, когда процесс
[18:31.400 --> 18:40.080]  приходит в режим паузы до тех пор, пока вы не продолжите выполнение процесса. Из-за чего это
[18:40.080 --> 18:47.520]  может происходить? Наверное, встречались иногда с такой ситуацией, что, особенно когда только
[18:47.520 --> 18:53.960]  переходите на UNIX-систему после Windows, что вместо, например, CTRL-D для завершения потока ввода вы
[18:53.960 --> 19:04.160]  нажимаете CTRL-Z. Или иногда случайно промахиваетесь, нажимаете CTRL-Z, когда пытаетесь там сделать какую-нибудь
[19:04.160 --> 19:09.760]  отмену undo в консольном приложении, забывая, что это у вас консоль, и получать вот такую картину,
[19:09.760 --> 19:19.360]  что процесс какой-то suspended. Что делать дальше? Как теперь вернуть все обратно? И что вообще у нас
[19:19.360 --> 19:36.480]  произошло? Произошло следующее. Вот наш процесс ГДБ, который находится в состоянии T. Что буква T
[19:36.480 --> 19:43.280]  означает в плане состояния? Значит, процесс остановлен с помощью сигнала six-stop. То есть нажать
[19:43.280 --> 19:49.480]  и клавиш CTRL-Z, посылает текущему процессу сигнал six-stop, процесс просто останавливается,
[19:49.480 --> 19:55.600]  переходит в режим паузы. Как вернуть все как было? Есть такая замечательная команда foreground,
[19:55.600 --> 20:04.160]  то есть не нужно паниковать, перезапускать заново. Команда foreground, которая посылает нашему процессу
[20:04.160 --> 20:10.560]  сигнал six-continue. Все, теперь процесс выполняется дальше. Экран, правда, не перерасовался по понятным
[20:10.560 --> 20:18.360]  причинам, но тем не менее процесс живой, процесс работает. И просто команда foreground посылает сигнал
[20:18.360 --> 20:28.560]  six-continue, который меняет состояние. Два сигнала sig-child, sig-argand, они по умолчанию у нас
[20:28.560 --> 20:35.640]  игнорируются, то есть не волняются никаких действий, если вы их не переопределите. И что значит
[20:35.640 --> 20:42.080]  переопределить какие-то действия для процесса? Это значит, что вы можете навешать на большинство
[20:42.080 --> 20:49.560]  сигналов какие-то произвольные кастомные обработчики, функции, которые будут выполняться вместо действий
[20:49.560 --> 20:55.320]  по умолчанию, но это невозможно сделать для сигнала six-stop, то есть нажатие клавиш CTRL-Z,
[20:55.320 --> 21:04.160]  ну никак. Только если перехватывать клавиатуру и блокировать сочетание клавиш CTRL-Z. Есть еще
[21:04.160 --> 21:15.480]  жесткий сигнал six-kill, вот его тоже никак нельзя перехватить. Ну и что значит перехват обработки
[21:15.480 --> 21:24.040]  сигналов? Есть два способа, как перехватить обработчик сигнала. Один старый, другой по новее.
[21:24.040 --> 21:30.800]  Старый он выглядит немножко попроще, это системный вызов сигнал, где в качестве первого аргумента
[21:31.240 --> 21:36.400]  вы передаете номер сигнала. Совершенно не обязательно помнить номера сигналов,
[21:36.400 --> 21:42.880]  но за исключением сигнала с номером 9. Сигнал с номером 9 это kill, это надо запомнить. Все остальные
[21:42.880 --> 21:49.920]  номера, в принципе, они представлены разными константами из того же файла signal h. То есть
[21:49.920 --> 21:57.200]  первый аргумент это номер сигнала, а второй аргумент это указатель на функцию с очень
[21:57.200 --> 22:05.040]  простой сигнатурой, которая будет выполняться вместо дефолтного обработчика. И тут уже возникают
[22:05.040 --> 22:13.320]  первые подставы, связанные с портируемостью такого кода, хотя бы по той причине, что вроде как
[22:13.320 --> 22:21.200]  похожие сигнатуры у системного вызова сигнала, но используются немножко разные названия объявления
[22:21.200 --> 22:26.440]  из оголочных файлов. В линукс называется сиг-хэндлер подчеркивания t, а во FreeBSD и macOS
[22:26.440 --> 22:34.200]  называется сиг подчеркивания t. Но вроде как с этим жить можно, не сильно нам это пока мешает. И как
[22:34.200 --> 22:45.880]  можно взять и перехватить обработчик для нажатии ctrl-c. Делается достаточно просто.
[22:45.880 --> 22:58.480]  Итак, если я вызываю вот этот вот системный вызов сигнал, в качестве первого аргумента
[22:58.480 --> 23:05.440]  указываю целочисленную константу, связанную с номером сигнала. Второй аргумент это указатель
[23:05.440 --> 23:11.080]  на функцию, которая будет выполняться, то каждый раз вместо того, чтобы выполнять действия по
[23:11.080 --> 23:19.560]  умолчанию, у вас будет выполняться какая-то функция. Давайте мы эту программу запустим. Здесь я
[23:19.560 --> 23:28.120]  зарегистрировал обработку на два сигнала, то есть у меня нет никакой реакции на ctrl-c. Я нажимаю
[23:28.120 --> 23:34.280]  ctrl-c, вместо того, чтобы завершить свою работу, мы получаем, что пойман сигнал с номером 2. И
[23:34.280 --> 23:53.640]  то же самое, если я пишу kill all, как там процесс назывался, handle, sig. Трудно. Если я пишу kill,
[23:53.640 --> 24:05.080]  процесс такой-то, он тоже не прибивается, потому что сиг терм, мы тоже перехват. Как этот процесс
[24:05.080 --> 24:13.960]  можно прибить? Предложите хотя бы два способа. ctrl-d не спасет, потому что я ничего не читаю.
[24:13.960 --> 24:27.080]  Закрыть терминал. Ладно. Во-первых, я могу написать kill-9 либо kill-kill. Сигнал sig kill
[24:27.080 --> 24:34.080]  перехватить невозможно в принципе, и поэтому с помощью этого сигнала можно прибить абсолютно
[24:34.080 --> 24:43.800]  любой процесс. Второй способ, если не получается, но опять же, внимательно смотрим на код. Я
[24:43.800 --> 24:49.920]  перехватываю sig int, sig term, а, например, sig quit, ctrl-slash я не перехватываю, поэтому могу использовать
[24:49.920 --> 25:01.920]  сигнал для того, чтобы завершить его работу. Так, почему такой способ плохой с использованием
[25:01.920 --> 25:07.680]  системного вызова сигнала? На счет партируемости есть тут две разные проблемы. Во-первых,
[25:07.680 --> 25:12.600]  в заключенных файлах там какая-то ничь написана в разных операционных системах. Во-вторых,
[25:12.600 --> 25:21.800]  сигналы по-разному работают на разных операционных системах. Точнее, есть два огромных класса
[25:21.800 --> 25:32.880]  операционных систем. Это классическая AT&T System 5 Unix, от которой потом, не то что отпочковались,
[25:32.880 --> 25:39.840]  скорее ее лицензировали и доработали под себя компании Sun Microsystems и IBM. Это операционные
[25:39.840 --> 25:46.680]  системы Solaris и IBM AX. Сейчас уже компании Sun Microsystems не существует, вместо нее есть Oracle,
[25:46.680 --> 25:53.400]  Solaris называется теперь Open Solaris, и просто Solaris тоже жив. В общем, на самом деле таких
[25:53.400 --> 26:00.760]  систем было когда-то много, они уже все повымерли, вот, кроме двух. И была альтернативная ветка
[26:00.760 --> 26:08.640]  развития Unix-систем в 80-е годы, которая называлась BSD Unix. Следуя заветам BSD Unix,
[26:08.640 --> 26:15.320]  сигналы реализовали в системах всех BSD подобных, то есть Free BSD, Open BSD, Net BSD, в Linux и в macOS.
[26:15.320 --> 26:23.840]  В чем разница? Вот когда вы компилируете код с указанием явно какого-то стандарта,
[26:23.840 --> 26:34.400]  если вы указываете стандарт C++17, C11, C99 и так далее, то компилятор строго следует именно
[26:34.400 --> 26:41.920]  стандарту языка и стандарт еще некоторым старым Unix-овым стандартом. А если вы пишете еще
[26:41.920 --> 26:50.880]  слово GNU вместо C11, либо GNU++ вместо C++17, например, то у вас дополнительно доопределяются
[26:50.880 --> 27:01.400]  некоторые macros, это BSD Source, GNU Source. В последних версиях в Gleap C macros BSD Source стал
[27:01.400 --> 27:06.400]  не приклеить и вместо него другое название, но суть это не меняет. То есть у вас немножко
[27:06.400 --> 27:12.320]  меняется поведение. Что происходит, когда вы пишете GNU вместо языка программирования?
[27:12.320 --> 27:19.320]  Во-первых, у вас становятся доступны некоторые нестандартные расширения языка программирования.
[27:19.320 --> 27:29.360]  Кто помнит такие нестандартные расширения полезные? Нет, boost совершенно ни при чем. Это
[27:29.360 --> 27:34.520]  отдельная библиотека. Нестандартные расширения имеются в виду, например, встроенные функции для
[27:34.520 --> 27:42.120]  проверки целочисленного переполнения. В прошлом семестре вы это использовали. Ну и плюсы считаются
[27:42.120 --> 27:51.440]  определенными вот эти macros. И на что это влияет? Давайте мы перекомпилируем нашу программку,
[27:51.440 --> 27:58.400]  очень простую, которая просто регистрирует два обработчика с разными опциями компиляции.
[27:58.400 --> 28:10.560]  Итак, скомпилируем. Бинарник в стиле System V, строго следуя стандарту,
[28:12.560 --> 28:22.840]  не дописывая никаких новых макроопределений. И скомпилируем тоже самое, но с гнушными расширениями.
[28:22.840 --> 28:32.880]  Так, сначала посмотрим... Ой, блин, я же перезаписал, да, спасибо. Так,
[28:32.880 --> 28:41.160]  вместо System V пусть будет BSD Style. Давайте посмотрим на стандартный BSD Style,
[28:41.160 --> 28:52.400]  но то поведение, которое мы сейчас и ожидаем. Ничего сверхъестественного. А теперь запустим
[28:52.400 --> 29:01.640]  System Fire Style, нажимаем CTRL-C. Все честно, да, получили сигнал, не завершились. Нажимаем CTRL-C
[29:01.640 --> 29:11.280]  еще раз. Бабах! Просто из-за того, что я указал другой флаг компиляции. Так, из-за чего это
[29:11.280 --> 29:21.000]  происходит? Потому что обработка сигналов по-разному происходила уже в 80-е годы в разных UNIX-системах.
[29:21.000 --> 29:29.120]  В System Fire у нас после обработки нестандартного хендлера происходил сброс на хендлер по
[29:29.120 --> 29:35.200]  умолчанию. Поэтому первый раз у нас появилось сообщение, что получен сигнал с таким-то номером,
[29:35.200 --> 29:43.440]  при повторном нажатии CTRL-C, поскольку у нас все сбросилось на дефолтное поведение, произошел
[29:43.440 --> 29:50.080]  дефолтный обработчик сигнала, то есть процесс завершил свою работу. Еще сигналы System Fire
[29:50.080 --> 29:56.240]  могут вызываться рекурсивно. То есть в тот момент, когда у вас выполняется какой-то обработчик сигнала
[29:56.240 --> 30:02.880]  и приходит еще один сигнал, то у вас рекурсивно начинает выполняться, не завершив вполне предыдущего.
[30:02.880 --> 30:09.760]  В общем, достаточно опасная штука, поскольку вашему процессу могут посылать огромное количество
[30:09.760 --> 30:17.480]  сигналов, чтобы его забомбить. В BSD-системах, ну и тем, которые следуют этому соглашению, в том
[30:17.480 --> 30:27.800]  числе Linux, по умолчанию подразумевается, что если у вас уже обработчик сигнала, то он гарантированно
[30:27.800 --> 30:35.320]  завершится, а потом, может быть, если пришел сигнал, то будет выполнен повторно. Ну и есть еще очень
[30:35.320 --> 30:42.120]  важное с точки зрения удобства использования отличия, если ваш процесс выполняет какие-то
[30:42.120 --> 30:49.920]  блокирующие системные вызовы, например, read, write, то эти системные вызовы у вас завершатся,
[30:49.920 --> 30:57.720]  вернут минус один и код ошибки пропишут E-inter, то есть у вас стемный вызов был прерван каким-то
[30:57.720 --> 31:04.680]  сигналом. В случае с BSD-стайлом все эти системные вызовы автоматически перезапускаются и нет
[31:04.680 --> 31:10.840]  необходимости проверять на код ошибки E-inter и выполнять какие-то повторные действия, что достаточно
[31:10.840 --> 31:21.640]  удобно. Есть два разных способа обработки сигналов и более современный способ, который позволяет
[31:21.640 --> 31:28.240]  все это детально указывать, а не надеяться на какое-то поведение определенной операционной системы,
[31:28.240 --> 31:34.280]  заключается в том, что вы не используете системный вызов сигнал, который на самом деле в современных
[31:34.280 --> 31:40.320]  реализациях вовсе не является системным вызовом. Используйте системный вызов под названием
[31:40.320 --> 31:47.440]  segaction. Чем этот способ плох? Тем, что приходится писать больше букв. То есть кроме номера сигнала вам
[31:47.440 --> 31:54.560]  нужно еще указать структуру segaction, в которой вы пропишете детально поведение обработки вашего
[31:54.560 --> 32:07.720]  обработчика сигнал. Как это выглядит на практике? На практике это выглядит тем, что у вас объявляется
[32:07.720 --> 32:17.120]  некоторая структура segaction, в которой вы прописываете указатель на хендлер, прописываете какие-то
[32:17.120 --> 32:25.400]  дополнительные флаги SAFLAGS, которые указывают точное поведение вашего процесса.
[32:25.400 --> 32:39.520]  Давайте более подробно посмотрим на некоторые флаги. Если указать флаг SAResetHand. Да, флаги
[32:39.520 --> 32:46.480]  это обычные значения, которые через операцию по разрядово или можно объединять. Вот если указать
[32:46.480 --> 32:55.800]  дополнительно флаг ResetHand, то будет поведение в стиле System5. После обработки вашей функции поведение
[32:55.800 --> 33:06.320]  будет сброшено на поведение по умолчанию. Если указать флаг NODEFER, то опять же вы получите
[33:06.320 --> 33:14.480]  поведение System5 системы, и при получении сигнала в тот момент, пока вы выполняете уже какой-то
[33:14.480 --> 33:20.360]  обработчик, он вас будет рекурсирно вызываться. По умолчанию этого не происходит в стиле BSD.
[33:20.360 --> 33:28.360]  И важный еще флаг, но правда этот флаг надо явным образом всегда указывать. Если вы не укажете его,
[33:28.360 --> 33:34.880]  то будет поведение в стиле System5, системные вызовы у вас не будут перезапускаться. Если вы
[33:34.880 --> 33:39.320]  этот флаг укажете, то системные вызовы будут перезапускаться вместо того, чтобы возвращать
[33:39.320 --> 33:46.320]  код ошибки. Работать это будет примерно то же самое, но зато такой код является более портируемым,
[33:46.320 --> 33:58.920]  и плюс вы можете вызывать не просто какие-то простые обработчики, которые могут работать только с
[33:58.920 --> 34:03.400]  номером сигнала, но и получать некоторую дополнительную информацию используя обработчик
[34:03.400 --> 34:10.160]  с тремя аргументами, а не с одним. Давайте мы чуть более подробно рассмотрим эту программу.
[34:10.160 --> 34:20.720]  Итак, у нас есть два разных варианта обработчика сигнала. Точно такой же, как в прошлый раз,
[34:20.720 --> 34:28.840]  функция, которая просто выводит номер сигнала и ничего не делает. Такой обработчик с одним
[34:28.840 --> 34:36.240]  аргументом у нас связан с сигналом segue, то есть нажатием клавиш Ctrl-C. Второй обработчик уже
[34:36.240 --> 34:42.240]  функция с тремя аргументами. Первый аргумент точно также принимает номер сигнала. Второй
[34:42.240 --> 34:48.200]  аргумент содержит уже информацию о сигнале, в том числе информацию о том, а кто этот сигнал
[34:48.200 --> 34:53.120]  нам прислал. Третий аргумент, контекст, обычно редко используется. Там можно передавать что-то
[34:53.120 --> 34:59.000]  произвольное. Так, и для того, чтобы зарегистрировать функцию с тремя аргументами вместо одного,
[34:59.000 --> 35:04.160]  ну понятно, что обработчик сигнала должен понимать, какую из функций нам нужно использовать.
[35:04.160 --> 35:09.680]  Для этого используется во флагах дополнительный флаг sasiginfo, чтобы указать, что нужно использовать
[35:09.680 --> 35:17.480]  другую функцию. Так, навешиваем это на сигнал сектер. Ну и что мы теперь можем наблюдать
[35:17.840 --> 35:30.880]  при получении сигналов. Если я нажимаю Ctrl-C, ну получаем просто сигнал с номером 2. Если я теперь
[35:30.880 --> 35:46.240]  найду наш процесс и отправлю сигнал сектерм вместо секинт, то вызываются функции с тремя аргументами,
[35:46.240 --> 35:51.600]  которые в том числе позволяют выяснить, а кто же нам этот сигнал отправил. То есть,
[35:51.600 --> 35:59.720]  процесс ID 37039, давайте проверим, правильнее это или нет. Специально окружение, перемена окружения
[35:59.720 --> 36:07.440]  в баш 2 доллара указывает на номер текущего процесса. Ну и вот процесс баш нам отправил
[36:07.440 --> 36:18.520]  некоторый сигнал, который мы поймали. Кстати, 37039, так и здесь тоже 37039. Это означает,
[36:18.520 --> 36:31.360]  что, что можно сказать про команду kill. Это означает, что использовался встроенный вариант
[36:31.360 --> 36:47.000]  команды kill, а в оси не внешняя программа. Если я наберу полным путем 3, 2, 7, то процесс уже другой.
[36:47.000 --> 37:01.080]  Почему это произошло понятно или нужно пояснить? Так, тишина. Так, в чем разница между командой
[37:01.080 --> 37:10.760]  kill и вызовом программы usr bin kill? В некоторых оболочках, например, bash, zsh, некоторые из
[37:10.760 --> 37:17.400]  стандартных команд реализованы как встроенные функции, а вовсе не запуск внешних программ. Просто
[37:17.400 --> 37:22.280]  по соображению производительности. Поэтому, когда я пишу команду kill, то используется внутренняя
[37:22.280 --> 37:34.240]  встроенная функция оболочки. Здесь у меня по-моему zsh. Врать не буду. Да, это zsh. Используется встроенная
[37:34.240 --> 37:40.080]  функция, поэтому процесс id отправителя сигнала, он совпадает с процесс id этой оболочки. Когда я
[37:40.080 --> 37:44.600]  запускаю внешнюю программу kill, то создается новый процесс, который выполняет эту программу,
[37:44.600 --> 37:50.560]  и соответственно процесс, получивший сигнал, он будет иметь уже другой процесс id.
[37:50.560 --> 38:04.000]  Так, поскольку cgaction требует написания большого количества букв, что мало того, что затратнее по
[38:04.000 --> 38:10.040]  времени, так еще и делает код менее читабельным. Иногда все-таки хочется использовать более простой
[38:10.040 --> 38:17.360]  вариант. Это функцию сигнал, которая в реализациях Linux и в macOS является именно функцией,
[38:17.360 --> 38:24.480]  а не системным вызовом. Есть два единственных случая, когда это можно делать безопасно и когда
[38:24.480 --> 38:31.560]  это делать осмысленно. Вот есть два константных специальных значения. Это значение 1 и значение 0,
[38:31.560 --> 38:40.840]  которое можно указывать вместо функции обработчика. Это константа, что сигналы нужно игнорировать,
[38:40.840 --> 38:48.000]  и константа, что нужно сбросить на дефолтное поведение. И в данном случае, если вы сбрасываете
[38:48.000 --> 38:53.500]  поведение на дефолтное, то понятно, что никакой обработчик вам не нужен, никакие параметры вам
[38:53.500 --> 38:58.840]  не нужны. Если сигналы игнорируете, то то же самое. Вам совершенно не важно, как сигналы
[38:58.840 --> 39:04.800]  обрабатываются. Вы их просто игнорируете. Вчера, кстати, у меня был семинар в 29-й группе. Там был
[39:04.800 --> 39:13.680]  вопрос, действительно ли осмысленно делать это для SIGIGN. Я это проверил. Действительно
[39:13.680 --> 39:20.840]  осмысленно, потому что игнорирование сигнала подразумевает, что не будет вызван обработчик,
[39:20.840 --> 39:28.120]  который сбрасывает на дефолтный обработчик. И поведение в этом случае вполне осмысленное.
[39:28.120 --> 39:39.160]  Как же эта функция реализована? В фидерфайле проверяется наличие флага default source,
[39:39.160 --> 39:46.000]  bsd source, либо gnusource. Если они проставлены, то подставляется вызов cgaction с одними
[39:46.000 --> 39:51.960]  параметрами. Если нет, то вызов с другими параметрами. Имитируется поведение либо
[39:51.960 --> 40:00.560]  системфай в стиле, либо bsd в стиле. Что может делать наш обработчик сигнала и что нужно при
[40:00.560 --> 40:06.120]  этом учитывать? Самое главное, о чем нельзя забывать. Сигнал может прилетать в совершенно
[40:06.120 --> 40:14.240]  рандомный момент времени. И программа может выполнять что-то очень важное, что-то очень критичное.
[40:14.240 --> 40:22.960]  Что в этот момент происходит? Вам приходит сигнал, переходит управление к обработчику сигнала. А что
[40:22.960 --> 40:28.360]  у вас будет происходить с основной программой? У вас есть уже какой-то стэк с данными. На самом
[40:28.360 --> 40:34.160]  деле у вас будет в том же самом стэке все и выполняться. На самом деле можно указать
[40:34.160 --> 40:40.320]  какой-нибудь альтернативный стэк для обработчиков сигналов. Обычно это используется при реализации
[40:41.320 --> 40:48.120]  высокоуровневых языков программирования типа Python либо Java. Ну и при этом для современных
[40:48.120 --> 40:58.520]  процессоров есть еще гарантия по соглашениям вызовов, что есть гарантировано 128 байт на стэке,
[40:58.520 --> 41:03.520]  которые заведомо никак не будут затронуты обработчиком сигналов. То есть обработчик сигналов
[41:03.520 --> 41:12.240]  у нас всегда начинается от текущего стэка, но на 128 байт ниже. И еще одним очень важным
[41:12.240 --> 41:18.480]  ограничением, поскольку у нас обработчик сигналов выполняется в том же самом потоке,
[41:18.480 --> 41:23.840]  что и основная программа, на самом деле для многопоточной программы в рандомном потоке,
[41:23.840 --> 41:31.160]  но здесь нужно обязательно использовать только ограниченный набор функций, который называется
[41:31.160 --> 41:40.680]  AsyncSignalSafe. Как это переводится на русский язык? Я даже не знаю. Итак, что такое безопасность
[41:40.680 --> 41:47.880]  точки асинхронного использования сигналов? Седьмой раздел MAN. Signal Safety. Перед тем,
[41:47.880 --> 41:52.240]  как отправлять свои задачи, перед тем, как идти на защиту, перед тем, как идти на контрольную,
[41:52.240 --> 42:00.520]  читать обязательно. Итак, у нас в функции все делятся на несколько больших классов. Во-первых,
[42:00.520 --> 42:05.720]  это функции, про которые ничего сказать не можно, потому что они являются просто функциями и никак
[42:05.720 --> 42:13.960]  не влияют на внешнее окружение. Пример такой функции, например, AscentPrint, StrLen, то есть функции,
[42:13.960 --> 42:20.920]  которые принимают аргументы и возвращают что-нибудь, при этом ничего никак не затрагивает. Такие
[42:20.920 --> 42:26.920]  функции можно смело использовать в обработчиках сигнала, потому что ни на что не влияют. И есть
[42:26.920 --> 42:34.720]  функции, которые влияют на глобальное поведение. Например, если вы как-то модифицируете стандартный
[42:34.720 --> 42:44.520]  поток вывода, какие-нибудь функции Print, Puts, Putschar, и так далее. И здесь бывают всякие разные
[42:44.520 --> 42:51.800]  подставы из-за того, что эти функции теоретически могут быть вызваны из разных потоков, ну или в
[42:51.800 --> 42:59.360]  разные моменты времени, из разных участков кода. Есть функции, для которых не гарантируется
[42:59.360 --> 43:05.920]  безопасность. Это, например, класс функций, который заканчивается на подчеркивание Unlocked,
[43:05.920 --> 43:12.800]  которые напрямую взаимодействуют с буфером, работают очень быстро, в отличие от аналогов
[43:12.800 --> 43:19.640]  без подчеркивания Unlocked. Но при этом нет никаких гарантий, что у вас будет с результатом, если вы,
[43:19.640 --> 43:25.080]  например, запускаете это в разных потоках. Есть функции, которые являются безопасными с точки
[43:25.080 --> 43:30.480]  зрения многопоточности, то есть могут быть одновременно параллельно выполняться, и гарантируется,
[43:30.480 --> 43:37.800]  что будет одинаковый результат. Большинство стандартных функций C для операции водовывода,
[43:37.800 --> 43:45.880]  они как раз являются MTSafe. Все эти флаги MTSafe, ISafe обычно прописаны в манах для каждых из
[43:45.880 --> 43:54.440]  функций. Но при этом класс функций MTSafe не является тем же классом, что AsyncSignalFave.
[43:54.440 --> 44:01.600]  Рассмотрим банальный пример. Вы пытаетесь записать что-то в стандартный поток вывода из основной
[44:01.600 --> 44:07.920]  программы. В этот момент вы получаете сигнал, который тоже пытается что-то записать на стандартный
[44:07.920 --> 44:14.880]  поток вывода. Но при этом вы уже вызвали, например, функцию PutChar. Функция PutChar захватила барьер
[44:14.880 --> 44:25.040]  для того, чтобы предотвратить повреждение данных из другого потока, и поэтому в обработке сигнала
[44:25.040 --> 44:30.360]  вы тоже останавливаетесь на этом барьере и ждете, пока его кто-то освободит. Что у нас будет происходить,
[44:30.360 --> 44:37.720]  поскольку учитывая, что у нас основной код не будет выполняться дальше, пока не завершится
[44:37.720 --> 44:45.000]  обработчик сигнала. Будет deadlock. Поэтому использование большинства функций, которые модифицируют
[44:45.000 --> 44:50.640]  глобальное состояние из-за обработчиков сигнала запрещено по этой причине. Но зато вы можете смело
[44:50.640 --> 44:56.000]  использовать системные вызовы, например, системы UsofWrite, которые ничего вам блокировать не будут.
[44:56.000 --> 45:07.160]  Ну и какие общие паттерны к написанию обработчиков сигнала? Во-первых, если вы можете писать
[45:07.160 --> 45:16.120]  код с использованием только очень ограниченного количества функций, то понятно, что здесь вам
[45:16.120 --> 45:22.640]  проще поставить какой-то флаг, зафиксировать сам факт того, что сигнал пришел, и дальше уже этот факт
[45:22.640 --> 45:31.360]  где-нибудь спокойно обработать. И в теории ваши сигналы могут выполняться очень долго, но так
[45:31.360 --> 45:38.160]  делать нехорошо, потому что вы блокируете вполне основной программы, и в основной программе у вас
[45:38.160 --> 45:45.400]  могут быть какие-то критические по времени секции. Например, к вам выявляетесь сервером,
[45:45.400 --> 45:51.200]  к вам подключился клиент, и вы получаете сигнал, уведомление о том, что нужно что-то сделать,
[45:51.200 --> 45:57.080]  занимаетесь долго обработкой сигнала. Что будет с клиентом? Клиент не дождется ответа,
[45:57.080 --> 46:02.040]  по тайм-ауту завершится, так делать нехорошо. Поэтому обычно хорошей практикой является,
[46:02.040 --> 46:10.080]  что вы максимально быстро обрабатываете сигнал, а содержательную часть по обработке,
[46:10.080 --> 46:16.240]  то есть вы просто фиксируете факт, что сигнал пришел, а содержательную часть выполняете только уже из
[46:16.240 --> 46:23.840]  основного кода, когда вам это становится удобно. Что значит проставить какой-то флаг? Это значит,
[46:23.840 --> 46:31.760]  что у вас есть какая-то переменная либо в глобальной области видимости, либо где-нибудь в аргументах,
[46:31.760 --> 46:37.840]  в контексте, и какого типа это может быть переменная, чтобы можно было ее безопасно,
[46:37.840 --> 46:42.400]  гарантированно использовать, поскольку у вас код может выполняться в произвольный момент времени,
[46:42.400 --> 46:48.480]  когда вы уже начали обращаться к значению. На самом деле, таких типов данных не очень много,
[46:48.480 --> 46:56.040]  и в стандарте Posix предусмотрено название sigatomic-t. Это тип данных, для которого гарантируется,
[46:56.040 --> 47:02.160]  что его значение будет всегда консистентным в любой момент времени. То есть не может быть
[47:02.160 --> 47:06.960]  ситуации, что вы начали модифицировать значение переменной в основном коде, прилетел сигнал и
[47:06.960 --> 47:13.800]  что-то там повредил. Для большинства современных систем это просто обычный type-def на int, но для
[47:13.800 --> 47:19.640]  каких-нибудь экзотических встраиваемых применений это может быть тип данных более мелкого размера.
[47:19.640 --> 47:26.400]  И второй момент, про который не нужно забывать при реализации обработчиков сигнала, то,
[47:26.400 --> 47:33.600]  что компилятор может посчитать в некоторых ситуациях, что ваш код является бессмысленным,
[47:33.600 --> 47:40.440]  потому что присылаете значение переменной, нигде не используете. Как с этим бороться? Есть
[47:40.440 --> 47:47.160]  ключевое слово volatile на имя переменной, которое запрещает компилятору делать какие-то предположения
[47:47.160 --> 47:52.920]  о том, что эта переменная не нужна, даже если он не видит всей картины в целом. Таким образом,
[47:52.920 --> 48:00.600]  как может выглядеть правильная обработка сигналов? Правильная обработка сигналов может выглядеть
[48:00.600 --> 48:10.520]  следующим образом. У вас есть обработчик, который единственное, что делает, это запоминает факт
[48:10.520 --> 48:17.400]  прихода сигнала. Уже в основной программе вы можете проверять факт наличия этого сигнала и,
[48:17.400 --> 48:24.200]  в зависимости от того, какой сигнал вы получили либо не получили, выполнять какую-то логику в тот
[48:24.200 --> 48:33.960]  момент, когда вам это действительно удобно. Где на практике используется обработка сигналов?
[48:33.960 --> 48:42.500]  Есть стандартные сигналы SIGTERM, но иногда еще обрабатывает сигнал SIGINT. Что можно на них
[48:42.500 --> 48:51.040]  навешать? Если вы обрабатываете сигнал SIGTERM, то вы должны сохранить текущие данные, чтобы их не
[48:51.040 --> 48:55.480]  потерять. Если у вас есть общение с каким-то клиентом, то сказать клиенту до свидания,
[48:55.480 --> 49:02.880]  вежливо попрощаться, перестать принимать остальных клиентов. Многие серверные применения
[49:02.880 --> 49:09.080]  еще ведут лог-файлы для того, чтобы как-то протоколировать ход своей нормальной либо
[49:09.080 --> 49:14.560]  ненормальной работы. Естественно, нужно сделать запись в лог и уже только после этого корректно
[49:14.560 --> 49:21.880]  завершить работу с помощью обычного системного вызова EXIT. Есть еще сигнал SIGHUB, который
[49:21.880 --> 49:28.000]  означает... Исторически он предназначался в собственном названии SIGHUB, откуда взялось
[49:28.000 --> 49:34.680]  исторически. Это был разрыв с терминалом, когда компьютеры были большой мейнфреймами, которые
[49:34.680 --> 49:41.520]  цеплялись с отдельными терминалами. Сейчас это не очень осмысленно, но бывает полезно в той ситуации,
[49:42.000 --> 49:49.480]  когда вам нужно как-то просигналить процессу, у которого нет пользовательского интерфейса,
[49:49.480 --> 49:55.120]  он работает фоном. Сейчас фактически формальное такое негласное соглашение, что этот сигнал
[49:55.120 --> 50:01.600]  используется как указание перечитать свои настройки из конфиг-файлов. SIGCHILD приходит,
[50:01.600 --> 50:10.000]  если вы запускаете какие-то дочерние процессы, что будет, если вы очень долго работаете и при
[50:10.000 --> 50:18.680]  этом не вызываете weight pit. У вас накапливаются процессы зомби. Если вы запускаете процессы,
[50:18.680 --> 50:25.720]  нужно периодически чистить завершенные, и по приходу сигнала SIGCHILD вы можете синхронным
[50:25.720 --> 50:34.880]  образом просто читать код возврата для того, чтобы эти зомби истреблять. Если вы хотите писать
[50:34.880 --> 50:40.680]  надежный код, который будет работать 24 на 7, то по-хорошему надо еще обрабатывать все остальные
[50:40.680 --> 50:45.720]  ошибочные ситуации. Как минимум их надо протоколировать куда-нибудь в log file, что эти
[50:45.720 --> 50:51.920]  ошибки возникли при каких-то обстоятельствах. Иногда можно, конечно, попробовать восстановить
[50:51.920 --> 50:59.880]  состояние процесса, ну или хотя бы аккуратно себя перезапустить. Что у нас происходит на низком
[50:59.880 --> 51:06.080]  уровне при доставке сигналов и какие с этим связаны ограничения. Есть такое понятие как
[51:06.080 --> 51:11.720]  маска сигналов, ожидающих доставки. То есть у нас есть некоторый набор стандартных сигналов,
[51:11.720 --> 51:18.280]  их не так много, и можно представить все это множество в виде обычного целого числа,
[51:18.280 --> 51:27.280]  где отдельные биты отвечают за отдельный сигнал. И когда какой-то процесс отправляет нам
[51:27.280 --> 51:35.080]  некоторый сигнал, он просто проставляет единичку в эту маску сигналов, ожидающих доставки. Что будет,
[51:35.080 --> 51:42.640]  если у нас одновременно два каких-то процесса успели отправить сигнал другому процессу,
[51:42.640 --> 51:48.680]  а этот процесс не успел их обработать. Честно, была проставлена единичка, сколько раз будет
[51:48.680 --> 51:55.860]  обработчик сигнала обработан? Ровно один раз. Поэтому сигналы не очень хорошо подходят для такого
[51:55.860 --> 52:00.660]  межпроцессного взаимодействия через системный вызов kill, они предназначены для уведомлений.
[52:00.660 --> 52:10.140]  Такой атрибут как маска сигналов, ожидающих доставки, он является атрибутом процесса,
[52:10.140 --> 52:16.660]  который при этом не наследуется при создании нового дочернего процесса через системный
[52:16.660 --> 52:23.500]  вызов fork. Что логично, если бы этот атрибут наследовался, тогда отправив сигнал к какому-то
[52:23.500 --> 52:29.180]  процессу, то почему этот сигнал мог бы прийти в новосознанную дочерню, что не очень логично.
[52:29.180 --> 52:36.180]  Так, ну и как у нас происходит обработка сигналов и почему у нас вся обработка происходит в том же
[52:36.180 --> 52:44.020]  самом контексте, что и основная программа. Допустим, вы хотите отправить кому-то сигнал,
[52:44.020 --> 52:49.340]  вы просто выполняете системный вызов kill. Да, есть команда kill, есть системный вызов,
[52:49.340 --> 52:55.060]  который тоже называется kill. Он просто, как и команда kill, посылает сигнал определенному процессу.
[52:55.060 --> 53:02.100]  Kill не блокируется до выполнения сигналов, вы просто поставили флаг и продолжаете выполнять
[53:02.100 --> 53:07.660]  дальше. Что происходит с процессом, которому вы этот kill отправили? Этот процесс тоже ничего про
[53:07.660 --> 53:12.260]  kill не знает. Он честно продолжает выполнение, пока не израсходит свой квант времени,
[53:12.260 --> 53:17.340]  который отведен вам планировщикам заданий. Потом уже в следующий раз при выборе этого
[53:17.340 --> 53:21.940]  процесса планировщикам заданий сначала проверяется маска сигналов, ожидающих доставки.
[53:21.940 --> 53:27.580]  Если есть какие-то сигналы, то сначала выполняются обработчики сигналов, а после этого процесс
[53:27.580 --> 53:35.260]  переходит в самое обычное выполнение, с того места, где он был прерыв. И есть еще одна маска,
[53:35.260 --> 53:42.540]  которая называется просто signals mask. Да, насчет терминологии. Очень часто встречается англоязычная
[53:42.540 --> 53:47.620]  терминология signal mask. Signal mask это то, что я сейчас вам расскажу, а предыдущая штука,
[53:47.620 --> 53:55.140]  это называется pending mask. Можно навешивать некоторые фильтры для того, чтобы запрещать
[53:55.140 --> 54:02.580]  определенные сигналы. И вот эта штука называется как раз маска сигналов, просто некоторая дополнительная
[54:02.580 --> 54:09.660]  маска из 0 единичек, которая либо разрешает обработку сигналов, либо запрещает. Что будет
[54:09.660 --> 54:16.020]  происходить, если сигнал у вас запрещен на уровне маски сигналов, но он все-таки пришел. У вас
[54:16.020 --> 54:25.660]  просто остается храниться единичка либо 0, которая просто не пропускается через эту маску. И в какой
[54:25.660 --> 54:32.020]  момент вы этот сигнал сможете обработать? Только в тот момент, когда вы поменяете маску сигналов,
[54:32.020 --> 54:37.740]  перестанете фильтровать этот сигнал, и в этот случай все отложенные сигналы до вас дойдут.
[54:37.740 --> 54:46.100]  Вот маска сигналов обычная, вместо, в отличие от маски pending сигнала, с которой маска сигналов
[54:46.100 --> 54:50.940]  ожидающей доставки, она как раз наследуется дочерними процессами, если вы вызываете форк.
[54:50.940 --> 54:59.140]  Естественно, тут есть два ограничения. Сигнал isekill и isekstop вы не можете никак обработать,
[54:59.140 --> 55:04.380]  и то же самое вы никак не можете наложить маску сигналов на эти два обязательных
[55:04.380 --> 55:15.420]  неблокируемых сигнала. Для чего эта маска может быть использована? Например, если вы хотите явным
[55:15.420 --> 55:22.580]  образом ждать какие-то определенные сигналы, либо вы выполняете какую-то критическую секцию
[55:22.580 --> 55:28.300]  вашей программы и хотите напрочь забыть про обработку сигналов на какое-то время,
[55:28.300 --> 55:32.580]  тогда вы можете устанавливать маску сигналов либо для всего процесса целиком,
[55:32.580 --> 55:39.540]  либо только для текущего потока. Я, конечно, много раз сейчас употребляю слово поток,
[55:39.540 --> 55:44.660]  многопоточность, мы пока это еще не проходили, но, я думаю, интуитивно вы понимаете, что это такое.
[55:44.660 --> 55:49.100]  То есть у вас в рамках одного процесса может быть несколько задач, которые выполняются параллельно.
[55:49.100 --> 55:55.540]  На самом деле, системный вызов, который предназначен был исходно для установки
[55:55.540 --> 56:03.620]  маски сигналов для текущего процесса, делает это только для текущего потока. Но в Linux есть
[56:03.620 --> 56:10.500]  еще отдельная функция, которая предназначена только для текущего потока. Она еще аккуратно
[56:10.500 --> 56:14.300]  обрабатывает ситуацию с двумя специальными сигналами. Про спецсигнал я чуть позже скажу.
[56:14.300 --> 56:25.260]  И есть еще очень интересный системный вызов, про который в документации написано, что он
[56:25.260 --> 56:33.180]  временно меняет маску сигналов на какую-то новую, ждет сигнал, а потом возвращает все обратно. Такое
[56:33.180 --> 56:38.580]  очень сложное описание на самом деле означает просто, что вы передаете какое-то множество сигналов,
[56:38.580 --> 56:44.940]  которые вам интересны, и процесс приостанавливается до тех пор, пока вы не получите один из сигналов
[56:44.940 --> 56:55.980]  этого множества. Не более того, не надо пугаться того, что написано в мане. Ну и дубль слайда,
[56:55.980 --> 57:11.780]  на самом деле маска она размер 64 бита, сигналов не так много. Как можно дождаться, приходит какой-то
[57:11.780 --> 57:17.700]  сигнал. Ну вот этот сексаспинг как раз и можете использовать, скормить ему множество сигналов,
[57:17.700 --> 57:24.740]  которые вам интересны, и процесс приостанавливается до тех пор, пока вам не
[57:24.740 --> 57:30.580]  придет один из сигналов из этого множества. Либо системный вызов пауза, который ждет,
[57:30.580 --> 57:35.660]  пока не придет какой-нибудь, неважно какой, любой сигнал, который вы можете обработать.
[57:35.660 --> 57:40.780]  Но естественно при этом у вас должны быть навешаны обработчики сигналов, иначе у вас
[57:40.780 --> 57:47.460]  процесс просто завершится, и код после паузы не будет иметь никакого смысла. То есть сигналы
[57:47.460 --> 57:53.780]  можно использовать в качестве некоторого способа синхронного водовывода, если вы их явным
[57:53.780 --> 58:00.980]  образом дождаетесь. И для этих целей в линукс даже сделали специальную конструкцию сигнала fd,
[58:00.980 --> 58:10.660]  это штуковина, которая позволяет читать объекты под названием пришедший сигнал. Что это означает?
[58:10.660 --> 58:15.980]  Это означает, что вы создаете какой-то файловый дискриптор, связываете файл дискриптора с
[58:15.980 --> 58:20.660]  определенным множеством сигналов, которые вам интересно, и дальше используете обычный
[58:20.660 --> 58:27.140]  системный вызов read, читая из этого файла дискриптора, и получаете на каждое чтение
[58:27.140 --> 58:32.780]  информацию о вновь пришедшем сигнале, либо ожидания, пока не придет какой-нибудь сигнал из
[58:32.780 --> 58:40.060]  этого списка. Использовать такую штуку достаточно опасно, потому что эта штука не портируема,
[58:40.060 --> 58:51.940]  существует только в линукс. Про FreeBSD, про macOS можно забыть. Можно ли все-таки сигналы
[58:51.940 --> 58:58.020]  использовать как способ межпроцессного взаимодействия? Есть некоторые стандартные
[58:58.020 --> 59:02.940]  сигналы, которые называются стандарты POSIX. Это те самые, про которые я вам рассказывал,
[59:02.940 --> 59:08.740]  связанные с определенными событиями. Там есть два сигнала, на которые не навешано никаких два
[59:08.740 --> 59:15.900]  специальных, нет никаких двух специальных значений, это сигнал CGU-SR1, CGU-SR2, некоторый резерв,
[59:15.900 --> 59:20.660]  но тем не менее вы можете только использовать номер сигнала в качестве полезной информации,
[59:20.660 --> 59:27.380]  не более того. И плюс, как я уже сказал, у сигналов есть одна серьезная подстава, связанная с тем,
[59:27.380 --> 59:33.420]  что если два процесса одновременно вам отправят один и тот же сигнал, то с высокой степью
[59:33.500 --> 59:38.300]  вероятности, хотя нет, не очень высокой, потому что такая ситуация, конечно, не очень вероятна,
[59:38.300 --> 59:45.340]  но тем не менее возможна ситуация, когда вы получите только один сигнал, а не все те,
[59:45.340 --> 59:52.020]  которые вам были отправлены. Поэтому способ очень ненадежный, и есть некоторое расширение стандарта
[59:52.020 --> 01:00:02.580]  POSIX, под названием POSIX Real Time Extensions, который дополняет систему еще дополнительными сигналами с
[01:00:02.580 --> 01:00:11.540]  важным свойством. Во-первых, эти сигналы не теряются, если несколько процессов одновременно
[01:00:11.540 --> 01:00:18.100]  вам их отправляют, а складываются в очередь, которые обрабатываются последовательно ровно в том порядке,
[01:00:18.100 --> 01:00:24.980]  как эти сигналы были отправлены. Это сигналы с номерами, которые начинаются от 32 и заканчиваются
[01:00:24.980 --> 01:00:34.780]  на номере 63. Всего 64 сигнала в современных UNIX-системах. Но при этом нужно их отправлять специальным
[01:00:34.780 --> 01:00:42.500]  образом. То есть есть система вызов Kill, которая отправляет сигнал обычным образом. То есть тут
[01:00:42.500 --> 01:00:47.540]  действует то же самое ограничение, что он просто проставляет бит в маску сигналов, ожидающих доставки.
[01:00:47.540 --> 01:00:56.060]  Если два процесса одновременно делают Kill, то вы сможете зафиксировать только один факт.
[01:00:56.060 --> 01:01:05.220]  И есть еще функция SecQ, это именно функция не системный вызов, которая, точнее во FreeBSD,
[01:01:05.220 --> 01:01:10.780]  это системный вызов в Linux, это функция, которая позволяет как раз отправить сигнал,
[01:01:10.780 --> 01:01:15.580]  но не произвольный сигнал, а только сигнал с номером не менее чем 32, произвольному
[01:01:15.580 --> 01:01:21.220]  процессу таким образом, чтобы он положился в очередь. И при этом вы можете еще дополнительно
[01:01:21.220 --> 01:01:27.140]  отправить полезную информацию, а не только номер сигнала, произвольное число по размеру,
[01:01:27.140 --> 01:01:35.900]  не превышающее размер указателей. Чем этот способ плох? Он все-таки не совсем стандартный,
[01:01:35.900 --> 01:01:45.900]  например в macOS он не реализован. Как можно использовать сигналы в рамках нашей огромной
[01:01:45.900 --> 01:01:52.940]  большой задачи межпроцессное взаимодействие? У сигналов есть куча ограничений, поэтому фактически
[01:01:52.940 --> 01:01:58.420]  единственный способ как их можно использовать корректным образом, это только для уведомления
[01:01:58.420 --> 01:02:07.540]  процесса о чем-нибудь. То есть полезную информацию передавать вы не можете, вы максимум можете
[01:02:07.540 --> 01:02:11.780]  передать номер сигнала. Ну хорошо, у вас есть сигналы реального времени на некоторых системах,
[01:02:11.780 --> 01:02:19.180]  но опять же вы не будете передавать последовательно огромное количество чисел по одному числу за один
[01:02:19.180 --> 01:02:25.020]  раз, потому что это очень дорого. Но если у вас, например, используются сигналы совместно с каким-нибудь
[01:02:25.020 --> 01:02:31.340]  другим механизмом, например ма, разделяемая память, то вот эта комбинация становится уже удобной,
[01:02:31.340 --> 01:02:37.900]  потому что вы можете большие куски данных хранить где-то в общей памяти, доступной сразу
[01:02:37.900 --> 01:02:44.860]  межпроцессом. Возникает естественная проблема синхронизации, нужно как-то уведомлять процессы о том,
[01:02:44.860 --> 01:02:50.300]  что данные готовы. Вот для этих целей сигналы вполне себе можно использовать. На этом у меня все,
[01:02:50.300 --> 01:02:55.660]  да, сервер Рудали сегодня упал, поэтому по старинке тут всего лишь котик,
[01:02:55.660 --> 01:02:58.460]  который означает, что лекция закончилась. Есть ли у вас вопросы?
[01:02:58.460 --> 01:03:07.260]  А если, например, сигналы, которые в очередь складываются, если пошла обработка такого сигнала
[01:03:07.260 --> 01:03:12.620]  и другой пришел, то он сложится в очередь? Да, если это именно сигнал realtime,
[01:03:12.620 --> 01:03:18.540]  который оправлен не через skill, а через secq, тогда да, он просто сложится в очередь и потом будет
[01:03:18.540 --> 01:03:23.660]  обработан. То есть их доставка гарантируется? Их доставка гарантируется. Обычных нет. Более того,
[01:03:23.660 --> 01:03:27.900]  даже сигналы реальных времени не гарантируется доставкой, если вы используете обычный системный
[01:03:27.900 --> 01:03:43.620]  вызов skill. То есть тут надо использовать другую функцию. В macOS просто не используется сигналы
[01:03:43.620 --> 01:03:47.140]  реального времени, там используются другие способы межпроцессного взаимодействия.
[01:03:47.140 --> 01:03:54.820]  Но обычные сигналы есть в любой UNIX-системе. Да, в Windows сигналов нет. Это именно UNIX-штуки.
[01:03:54.820 --> 01:04:08.220]  Еще вопросы? Ну ладно, если вопросов нет, тогда лекция закончилась и вы свободны.
