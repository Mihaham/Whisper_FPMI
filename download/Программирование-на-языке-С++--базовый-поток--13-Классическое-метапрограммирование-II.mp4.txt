[00:00.000 --> 00:09.200]  Добрый день, давайте начнем. В прошлый раз мы с вами начали говорить про классическое
[00:09.200 --> 00:13.640]  метапрограммирование. Поговорили про такие сущности, как определители типов,
[00:13.640 --> 00:16.800]  которые позволяют для произвольного шаблонного параметра определить,
[00:16.800 --> 00:20.280]  содержится ли его констант или нет, содержит ли этот тип ссылку или нет,
[00:20.280 --> 00:24.440]  является ли он указателем, ну и так далее. В общем, обсудили общую схему того,
[00:24.440 --> 00:28.080]  как можно писать определители типов. И также поговорили про то, как писать
[00:28.080 --> 00:33.320]  модификаторы типов, то есть как, соответственно, изменять шаблонный параметр, который мне
[00:33.320 --> 00:36.200]  передали на вход, то есть как избавляться от константности, если она вдруг там внутри
[00:36.200 --> 00:41.800]  зашита, как избавляться от ссылочности, указатель, и так далее. Тоже обсудили такую общую схему.
[00:41.800 --> 00:46.280]  Также поговорили про if-const-export, который позволяет, зависимо от каких-то условий,
[00:46.280 --> 00:49.240]  которые проверяем на этапе компиляции, компилировать какую-то ветку кода или нет.
[00:49.240 --> 00:55.480]  Ну и в конце мы с вами остановились на том, что написали на самом деле свою собственную
[00:55.480 --> 01:02.880]  реализацию функции stdmove. Напомню, в чем там в чем-то стоит суть. Функция stdmove делает так,
[01:02.880 --> 01:07.800]  что передаваемый ей на вход объект должен восприниматься как R-value. То есть я хочу, чтобы
[01:07.800 --> 01:14.160]  в результате вызвать stdmove, у меня был бы прежний объект, но при этом он, с точки зрения компилятора,
[01:14.160 --> 01:19.760]  воспринимался бы как R-value. Это можно сделать, если выполнить так называемое
[01:19.760 --> 01:24.560]  преобразование L-value to R-value. Грубо говоря, если вам податься на вход R-value, то мы оставляем
[01:24.560 --> 01:30.480]  его без мнений. Если на вход подается какой-нибудь L-value, то мне нужно
[01:30.480 --> 01:35.480]  преобразовать его в ссылку на R-value. На самом деле, давайте ссылаться на этот объект,
[01:35.480 --> 01:43.160]  как будто бы это был R-value. Как мы этого достигли? Тут три ключевых момента. Первый момент,
[01:43.240 --> 01:49.560]  что мы принимаем. Так как функция stdmove может принимать в себя все что угодно, то есть произвольную
[01:49.560 --> 01:55.600]  категорию значения, будь то L-value, будь то R-value, поэтому мы принимаем объект по универсальной ссылке.
[01:55.600 --> 02:00.280]  Дальше, что мы понимаем? Мы понимаем, что функция stdmove должна вернуть в любом случае, чтобы ей не
[02:00.280 --> 02:06.280]  передали, она должна вернуть ссылку на R-value. То есть она должна вернуть объект, как если бы он был R-value.
[02:06.280 --> 02:10.720]  Соответственно, что мы для этого делаем? Понятное дело, что универсальная ссылка устроена таким
[02:10.720 --> 02:17.240]  образом, что она может в теории сохранить в тип T какую-то ссылку. Например, тип T может
[02:17.240 --> 02:25.200]  быть выведен как int амперсан, может быть выведен как int или там может быть выведен как const int амперсан.
[02:25.200 --> 02:32.680]  То есть в зависимости от того, содержит ли у меня тип T ссылку или нет, понятное дело, что
[02:32.680 --> 02:36.160]  возвращаемое значение будет от этого меняться. То есть я не могу тут просто написать возвращаемое
[02:36.160 --> 02:40.160]  значение, например, t двойного амперсана. Почему? Потому что мы знаем по правилам сворачивания
[02:40.160 --> 02:47.080]  ссылок, что если у меня вдруг внутри t зашита амперсант, тогда амперсант плюс два амперсан,
[02:47.080 --> 02:52.640]  в итоге один амперсант, тогда у меня будет возвращать обычную L-value ссылку, а не R-value ссылку.
[02:52.640 --> 02:59.280]  Так вот, чтобы эту проблему победить, я воспользовался модификатором типа RemoveReference. Что я сказал? Если
[02:59.280 --> 03:05.120]  там вот внутри типа T зашита какая-то ссылка, то ее нужно убрать. То есть, грубо говоря, после
[03:05.120 --> 03:09.600]  выполнения вот этого модификатора типа у меня тут вместо этого, вместо вот этого псевдонима,
[03:09.600 --> 03:15.400]  подставляется тип, на котором не будет висеть никакой ссылки. То есть это будет просто-напросто тип,
[03:15.400 --> 03:20.160]  возможно, с каким-то const-квалификатором. Ну и дальше уже вот на этот голый тип,
[03:20.160 --> 03:24.400]  на котором не навешано никаких ссылок, я навешиваю двойной амперсант. Ну если
[03:24.400 --> 03:31.000]  навешание двойного амперсанда на тип без ссылок, да, дает мне краски R-value ссылку.
[03:31.000 --> 03:38.120]  Вот ровно то, чего я хотел. В return делаю по сути то же самое. Точнее делаю ровно то,
[03:38.120 --> 03:43.640]  что от меня требуется. Я беру X и применяю к нему статикаст вот к нужному типу. Это
[03:43.640 --> 03:52.440]  RemoveReference T двойной амперсант. Окей, вспомнили? Хорошо, давайте потихоньку поднимать планку и
[03:52.440 --> 04:05.920]  поговорим про... теперь поговорим про функцию SDForward. Стэмплот класс T. Значит, есть функция
[04:05.920 --> 04:21.400]  forward, которая что-то принимает, что-то возвращает, ну как-то работает. Вот, ну это сначала вспомним,
[04:21.400 --> 04:27.440]  что вообще делает SDForward. Вот, какой вообще типичный кейс использования SDForward? Ну,
[04:27.440 --> 04:31.240]  на самом деле, чуть ли не единственный кейс правильного использования forward. Значит, есть
[04:31.240 --> 04:42.600]  у меня есть какая-то функция, да, пусть есть функция F, тоже шаблонная. Стэмплот класс T. Вот,
[04:42.600 --> 04:50.520]  функция F принимает T по универсальной ссылке. Вот, мы принимаем T по универсальной ссылке,
[04:50.520 --> 04:54.880]  дальше вдруг и дальше в какой-то момент. Я хочу этот X передать какую-то другую функцию, да, то есть,
[04:54.880 --> 04:59.120]  ну что означает forward? Forward буквально означает передать вперед, да, то есть, ну,
[04:59.120 --> 05:01.960]  пробросить дальше. Вот, собственно, forward как раз таки используется тогда, когда мне
[05:01.960 --> 05:05.840]  нужно аргумент функции, пробросить куда-то дальше, причем не изменяя его самого, да, то есть,
[05:05.840 --> 05:10.440]  если мне вдруг передали lvalue, я хочу передать дальше как lvalue. Ну, как lvalue, как ссылку на исходный
[05:10.440 --> 05:14.760]  объект. Если мы передали как rvalue, я хочу, чтобы он не дальше, он пошел как rvalue. Вот, то есть,
[05:14.760 --> 05:18.720]  самые типичные кисли использования это такой. Значит, я пишу F, вызываю какую-то другую функцию,
[05:18.720 --> 05:28.680]  допустим G, и передаю туда с помощью SD forward, причем обязательно передаю вывезенный тип T, да,
[05:28.680 --> 05:36.800]  и дальше передаю туда X. Вот типичный пример использования SD forward. То есть, SD forward что
[05:36.800 --> 05:42.400]  делает? Смотрите, тут прикол в том, что X, X это переменная. Как, я надеюсь, мы с вами помним,
[05:42.400 --> 05:49.240]  переменная это всегда lvalue, да. То есть, смотрите, если я тут просто напишу G от X, то аргумент X,
[05:49.240 --> 05:53.440]  функцию G будет всегда передаваться как lvalue, да. Ну, а что если функция G умеет принимать только
[05:53.440 --> 05:58.040]  rvalue, да, и на самом деле изначально функцию F я передавал rvalue, вот. То я бы хотел, чтобы на самом
[05:58.040 --> 06:02.360]  деле, вот, если я передал функцию F в X как rvalue, я хотел, чтобы он и дальше, а функцию G тоже
[06:02.360 --> 06:07.520]  передавался как rvalue. Знаете, вот такая вот получается, такая вот бешевная передача, да, то есть,
[06:07.520 --> 06:13.000]  то, что я передал в F, то же самое должно передаться в G. Вот как раз таки, как раз таки этого и
[06:13.000 --> 06:19.960]  добивается SD forward. То есть, грубо говоря, SD forward делает следующее. Если я X изначально, если я в X
[06:19.960 --> 06:24.160]  изначально передал lvalue, да, то и, соответственно, функцию G он должен передавать как lvalue, да, то
[06:24.160 --> 06:29.080]  есть, не изменен, то есть, тип не без изменений. Если же я в качестве, если же я в аргумент X передал
[06:29.080 --> 06:34.520]  rvalue, да, то и в G он тоже должен передавать rvalue. То есть, forward, то есть, forward превращается в
[06:34.520 --> 06:39.400]  в этом смысле в move, да, то есть, если изначально X был lvalue, то forward просто-напросто возвращает
[06:39.400 --> 06:45.760]  исходный X. Если же X изначально был rvalue, то я должен передавать, то SD forward ведет себя как SD
[06:45.760 --> 06:50.040]  move, да, то есть, мы говорили, что forward – такой условный, условный move. Ну и, наконец, как forward
[06:50.040 --> 06:55.240]  понимает, как forward понимает, что было изначально lvalue или rvalue, ну, как раз таки, вот по выведенному
[06:55.240 --> 06:58.880]  типу T, да, то есть, мы с вами помним, как работает универсальная ссылка. Если я в универсальную ссылку
[06:58.880 --> 07:05.120]  передавал rvalue, то тип выводится без имперсанда, да, допустим, int. Вот, если же я в аргумент X
[07:05.120 --> 07:09.920]  передал lvalue, да, то тогда у меня универсальная ссылка, точнее, шаблоны параметра T выводится как
[07:09.920 --> 07:14.080]  ссылочный тип, да, тогда у меня выводится int ссылка. Вот, ну и в зависимости от того, что мне передали
[07:14.080 --> 07:18.640]  int или int ссылка, ну, точнее, что forward передали, да, сюда int или int ссылка, он, соответственно,
[07:18.640 --> 07:27.880]  либо делает SD move, либо не делает SD move. Окей? Хорошо. Ну, давайте в связи с этим подумаем, в связи с этим
[07:27.880 --> 07:32.840]  подумаем, что нам нужно написать. Давай, ну, самое простое, наверное, начать с того, а что должен
[07:32.840 --> 07:39.360]  возвращать SD forward? Вот, смотрите, я в SD forward явно, вот, обратите внимание, еще один момент, в SD forward
[07:39.360 --> 07:44.120]  я всегда тип передаю явно, то есть, я всегда указываю шаблонный параметр, с который я вызываю forward,
[07:44.120 --> 07:48.520]  да, иначе у forward нет никакого шанса понять, а что же изначально объект X был, да, потому что X тут
[07:48.520 --> 07:53.040]  в данном контексте всегда будет lvalue, поэтому, чтобы с forward понять, что делать, мы, соответственно,
[07:53.040 --> 08:00.720]  всегда передаем шаблонный параметр t. Так вот, смотрите, смотрите, чего хочется, если вдруг t это lvalue
[08:00.720 --> 08:05.040]  ссылка, да, если вот тот тип t, точнее, вот этот тип t, который сюда передал, если это lvalue ссылка, то я хочу
[08:05.040 --> 08:09.960]  возвращать, то я хочу возвращать, собственно, lvalue ссылку, если t это rvalue ссылка, я хочу, чтобы
[08:09.960 --> 08:13.640]  тут была rvalue ссылка, точнее, если t это просто обычный тип, то я хочу, чтобы тут возникала
[08:13.640 --> 08:18.120]  lvalue ссылка. Что я тут могу написать такого, что ведет себя именно так, как я хочу?
[08:18.120 --> 08:30.960]  Ну, смотрите, я хочу применить какое-то преобразование к f, к t, давайте, вот, смотрите, давайте так, вот, я
[08:30.960 --> 08:40.240]  условно напишу, как-то, давайте так, f с крышкой, да, я хочу применить такое преобразование к t, ну, или давайте,
[08:41.200 --> 08:45.440]  я хочу такое преобразование, которое из вот такой t делает inte двойного амперсанта,
[08:45.440 --> 08:50.880]  которое из int двойного амперсанта делает int двойного амперсанта,
[08:50.880 --> 09:02.600]  и которое из int один амперсант делает inte один амперсант. Что это за преобразование?
[09:02.600 --> 09:06.600]  что
[09:07.100 --> 09:09.720]  да согласны ли вы что если я просто вот
[09:09.720 --> 09:11.040]  этому типу применю два персанда
[09:11.040 --> 09:13.040]  допустим и два персандаgrund
[09:13.040 --> 09:15.700] apho
[09:16.900 --> 09:19.720]  да или если же моего баточатого
[09:19.720 --> 09:21.500] cinmot물 получу один апперсант по
[09:21.500 --> 09:24.780]  правилу сворачивания ссылок chat
[09:24.780 --> 09:26.440]  на самом деле возвращать значений все
[09:26.440 --> 09:27.760]  просто мне нужно просто вернуть это
[09:27.760 --> 09:30.000]  двойной персант
[09:30.000 --> 09:31.940]  потому что если это содержится какая-то
[09:31.940 --> 09:37.820]  какая-то ссылка, то ссылка станет той же самой. А если в t не было ссылок, то это будет t-двойная ссылка.
[09:37.820 --> 09:46.260]  То есть ровно то, чего я хочу. Так, окей. Так, ну и, соответственно, ретёрн.
[09:46.260 --> 09:54.620]  Ретёрн более-менее тоже понятен. Делаем статик cast к t-двойной
[09:54.620 --> 10:04.500]  персант от x. Статик cast к t-двойной персант x. Хорошо. А вот теперь давайте
[10:04.500 --> 10:11.020]  разбираться с принимаемым значением. Кто принимает sd forward?
[10:11.020 --> 10:26.940]  Ну, смотрите, на самом деле тут, чтобы понять, что принимает sd forward, нужно, в общем, нужно
[10:26.940 --> 10:32.460]  понять, в каких контекстах используется sd forward. Смотрите, опять же, sd forward используется всегда
[10:32.460 --> 10:38.100]  в контекстах, когда у меня есть какая-то переменная, когда у меня есть какой-то аргумент,
[10:38.540 --> 10:44.060]  который был принят ранее по универсальной ссылке. И дальше я этот аргумент передаю в sd forward.
[10:44.060 --> 10:49.020]  То есть, на самом деле, что всегда передаётся в sd forward? Да, смотрите, обратите внимание, что в
[10:49.020 --> 10:56.100]  sd forward всегда передаётся l value. Потому что forward всегда используется в паре в связке с
[10:56.100 --> 10:59.700]  универсальной ссылкой. Вот, если он всегда используется в связке с универсальной ссылкой,
[10:59.700 --> 11:03.860]  то, соответственно, ему на вход всегда передают l value, то есть всегда передаёт аргумент
[11:03.860 --> 11:09.460]  какой-то функции. Понятно? Вот. Поэтому for всегда принимает lvalue.
[11:09.460 --> 11:13.460]  Всегда принимает lvalue. Поэтому, вообще говоря, можно было бы, наверное, написать
[11:13.460 --> 11:23.420]  тут что-то наподобие такого. Типа t&x. Вот. Можно было бы написать
[11:23.420 --> 11:27.520]  что-то наподобие такого, и в целом, более-менее, это бы работало. Вот. Но на самом деле,
[11:27.520 --> 11:31.500]  в стандартной библиотеке это реализовано, эта штука реализована немного иначе.
[11:31.540 --> 11:35.180]  Ну, по следующей причине, смотрите. Опять же. Мы с вами
[11:35.180 --> 11:38.820]  говорили о том, что forward работает только так и не как иначе. До sout HIV,
[11:38.820 --> 11:43.100]  и я forward обязательно должен передавать шаблонный параметр. Вот. Вот это вот
[11:43.100 --> 11:45.800]  шаблонный параметр в треугольных стелках t, и я всегда должен передавать явно.
[11:45.800 --> 11:49.320]  Вопрос, что произойдет, если я вот в такую реализацию не буду передавать
[11:49.320 --> 11:52.340]  явно шаблонный параметр? Ну, смотрите, если я в такую реализацию явно не буду
[11:52.340 --> 11:56.420]  передавать шаблонный параметр, то у меня в качестве typo-t, в качестве typo-t
[11:56.420 --> 12:00.060]  всегда будет уводиться какой тип.
[12:00.060 --> 12:04.740]  Ну, всегда будет вводиться тип без имперсанда, да?
[12:04.740 --> 12:08.720]  Представьте себе, что, например, тип XA — это int.
[12:08.720 --> 12:12.620]  Инт-ссылка или просто тип XA — это int.
[12:12.620 --> 12:16.140]  Если тип XA — это int, то, соответственно, если я буду
[12:16.140 --> 12:18.040]  передавать сюда, то в качестве TpT мне всегда будет вводиться
[12:18.040 --> 12:19.040]  просто int.
[12:19.040 --> 12:22.180]  Потому что X — это будет просто ссылка на int.
[12:22.180 --> 12:23.180]  Понятно?
[12:23.180 --> 12:27.880]  А если в качестве TpT всегда будет вводиться просто
[12:27.880 --> 12:31.720]  то, соответственно, тут я всегда... то forward будет работать, по сути, всегда как sdmove.
[12:31.720 --> 12:38.440]  Поэтому, чтобы запретить вот такие вот вызовы, чтобы запретить пользователю вызывать forward
[12:38.440 --> 12:42.840]  без указания, без явного указания шаблонного параметра, можно написать вот так.
[12:42.840 --> 12:54.840]  Точнее, стоит писать вот так. Давайте я тут напишу std
[12:54.840 --> 13:15.160]  removeReference от t, ссылка x. Вот. Вот. Почему это гарантирует, что я std forward всегда могу вызывать только так и не как иначе?
[13:15.160 --> 13:21.080]  Потому что если я вдруг тут не напишу, если я вдруг тут не укажу явно шаблонный параметр,
[13:21.320 --> 13:28.600]  тогда у компилятора возникнет следующая задача. Ему нужно будет тут в качестве типа t, ему нужно будет тут что-то подставить в качестве типа t,
[13:28.600 --> 13:35.400]  чтобы будет подходить по тот вызов. Вот. Но, естественно, эта задача для компилятора не решаемая.
[13:35.400 --> 13:40.440]  Почему? Потому что, смотрите, в теории, потому что, смотрите, removeReference, потому что ему нужно понять,
[13:40.440 --> 13:45.320]  во-первых, для каких типов t... Допустим, представьте, что я туда в качестве x передаю int.
[13:45.320 --> 13:50.360]  Вот, представьте, я передаю int. Тогда компилятору нужно понять следующее. Ему нужно решить вот такую задачу.
[13:50.360 --> 14:08.760]  removeReference t равно int. То есть ему нужно понять, для каких типов t вот эта штука будет давать int.
[14:08.760 --> 14:17.360]  На самом деле, эта задача не то чтобы разрешимая. Почему? Потому что ему надо заглянуть в шаблонный класс removeReference,
[14:17.360 --> 14:22.320]  подставлять туда различные типы. То есть ему нужно вообще подставить туда всевозможные типы,
[14:22.320 --> 14:28.280]  чтобы понять, для какого типа t вот эта штука дает int. Понятно? То есть ему нужно явно
[14:28.280 --> 14:32.400]  проинстанцировать все классы, чтобы понять, а в каком же случае, на самом деле, у него действительно
[14:32.400 --> 14:38.400]  будет храниться ваполи type типа int. Это, во-первых. А, во-вторых, на самом деле, у компилятора может
[14:38.400 --> 14:44.000]  быть, на этапе вызова stfors, у него может не быть полной информации, а вообще всевозможных
[14:44.000 --> 14:48.000]  специализациях этого класса. Потому что с класса это может быть как-то специализирован. То есть я
[14:48.000 --> 14:54.120]  могу указать, что, например, для вектора stmoveReference тоже дает int. Таких ситуаций, естественно, компилятор
[14:54.120 --> 14:58.280]  тоже обработать не сможет. Ну или просто представь себе, что у меня stmoveReference, там, допустим,
[14:58.280 --> 15:03.640]  для нескольких типов, допустим, не знаю, для int, для вектора int, не знаю, для дека int, выдаёт нам
[15:03.640 --> 15:11.000]  на выход int. Тогда тут задача тоже неоднозначно решается. В таком случае компилятор не делает
[15:11.000 --> 15:16.760]  никакого вывода типов. В этом случае, если я дописал stfors без написания аргументов, компилятор
[15:16.760 --> 15:22.000]  просто нам пожалуется, он скажет, что я не знаю, какой тип мне выведете. В этом контексте тип t не
[15:22.000 --> 15:29.000]  выводим. Окей? Потому что вот эта задача, она сложная. Ему нужно просто посмотреть на этот шаблонный
[15:29.000 --> 15:34.000]  класс, подставить всевозможные типы и понять, при каких типах t у него там будет int. Естественно,
[15:34.000 --> 15:38.360]  компилятор такими вещами заниматься не будет. Ему нужно всегда четко понимать, а вот какой
[15:38.360 --> 15:52.920]  конкретно шаблонный класс нужно инстанцировать. Окей? Есть ли вопрос? Хорошо. Давайте тогда двигаться
[15:52.920 --> 16:01.160]  дальше. И следующие ключевые слова на очереди это decal type и decal val. Давайте поговорим про них.
[16:01.160 --> 16:08.480]  Смотрите, decal type это очень интересное слово ключевое, которое означает следующее. Decal type может
[16:08.480 --> 16:15.040]  применяться либо к переменным, ну, идентификаторам, либо к переменным, либо к выражениям. И в зависимости
[16:15.040 --> 16:18.880]  от этого decal type ведет себя чуть-чуть по-разному. Давайте рассмотрим сначала самый простой случай,
[16:18.880 --> 16:26.480]  когда decal type применяется к имени переменной. Вот. Как это работает? Смотрите, если я напишу decal type,
[16:26.480 --> 16:31.280]  если я напишу decal type от какой-то переменной, то на месте вот этого вызова, на месте вызова
[16:31.280 --> 16:37.440]  decal type подставится тип, с которым объявлена данная переменная. То есть смотрите, представьте
[16:37.440 --> 16:43.320]  себе, что у меня есть переменная int x, у меня есть const slot y, у меня есть const int % rx. Вот. Я могу,
[16:43.320 --> 16:47.760]  смотрите, допустим, я в какой-то момент хочу объявить переменную a, которая имеет ровно такой
[16:47.760 --> 16:52.440]  же тип, что и x. Вот. Ну, по какой-то причине я хочу, чтобы у меня была переменная a, которая имеет
[16:52.440 --> 16:57.400]  ровно, ровно, прям тоже самый тип, что и x. Вот. Что я могу сделать? Я могу написать decal type x a
[16:57.400 --> 17:02.080]  равно нулю. Что пройдет в этом случае? Компилятор во время компиляции программы, он посмотрит на
[17:02.080 --> 17:07.160]  это decal type от x, посмотрит, какой тип имеет переменная x, вот, прям вот, а с каким типом объявлена
[17:07.160 --> 17:11.880]  переменная x. Вот. И вместо этого decal type от x подставит конкретный тип int. Вот. То есть в данном
[17:11.880 --> 17:16.720]  случае вот эта точка, она полностью эквалентной int a равно нулю. То же самое с decal type y, b равно 1.
[17:16.720 --> 17:46.720]  Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот. Вот
[17:46.720 --> 17:48.900]  Вот. Ну при этом я знаю, при этом я знаю, что..
[17:48.900 --> 17:52.940]  Этот вектор содержит структуры, у которых есть поле x
[17:52.940 --> 17:55.360]  Ну представьте в 분들은, что мне есть вектор, у которого есть есть... Ну, представьте в
[17:55.360 --> 17:57.300]  Что у меня есть вектор
[17:57.300 --> 18:00.980]  Вектор хранит элементы, точнее структуры у которых есть поле x
[18:00.980 --> 18:04.720]  Ну при этом тип самого поля x я не знаю
[18:04.720 --> 18:06.900]  И все что я хочу сделать, это взять исходный вектор
[18:06.900 --> 18:09.640]  И сделать из него вектор элементов
[18:09.640 --> 18:13.400]  Ну, где из каждого элемента вектора я достал поле x
[18:13.400 --> 18:15.840]  Ну грубо говоря сделать следующее
[18:16.720 --> 18:26.800]  для каждого элемента из V, вот, просто-напросто сделал
[18:26.800 --> 18:36.280]  lm.x и запихнул его pushback в какой-то другой массив.
[18:36.280 --> 18:41.080]  То есть, просто-напросто создал копию массива V,
[18:41.080 --> 18:43.040]  но при этом скопировал не сами элементы, а скопировал
[18:43.040 --> 18:44.040]  только поля X.
[18:44.040 --> 18:46.200]  Смотрите, какая тут может быть проблема.
[18:46.200 --> 18:51.240]  Я написал эту функцию шаблонной, и проблема тут заключается
[18:51.240 --> 18:52.240]  вот в чем.
[18:52.240 --> 18:55.920]  Если у меня вектор содержит произвольную структуру,
[18:55.920 --> 18:58.760]  в которой есть поле X, я не знаю, какого типа эти
[18:58.760 --> 18:59.760]  поля X.
[18:59.760 --> 19:03.760]  Все, что я знаю, это вектор содержит объекты, структуры,
[19:03.760 --> 19:04.760]  у которых есть поле X.
[19:04.760 --> 19:07.160]  Какого типа эти поля структуры, я не знаю.
[19:07.160 --> 19:11.720]  Но, смотрите, мне же нужно как-то будет в этой строчке
[19:11.720 --> 19:13.080]  объявить результирующий вектор.
[19:13.080 --> 19:15.400]  То есть, мне нужно сказать, что вектор будет содержать
[19:15.400 --> 19:20.040]  элементы того же типа, что и поле X у элементов вектора
[19:20.040 --> 19:21.040]  V.
[19:21.040 --> 19:23.320]  В этом случае я могу как раз-таки воспользоваться
[19:23.320 --> 19:24.320]  трюком с decal type.
[19:24.320 --> 19:27.560]  Я могу написать, если вектор содержит те же самые типы,
[19:27.560 --> 19:33.720]  что и тип у какого-то элемента вектора, у поля произвольного
[19:33.720 --> 19:34.720]  элемента вектора.
[19:34.720 --> 19:38.720]  Тут конкретно я беру нулевой элемент вектора, говорю,
[19:38.720 --> 19:41.000]  обратиться к полю X и взять его тип.
[19:41.000 --> 19:43.000]  Окей?
[19:43.000 --> 19:50.400]  Смотрите, тут важно понимать то, что decal type ровно как
[19:50.400 --> 19:56.280]  и sizeof, ровно как и операция noexcept, decal type не вычисляет
[19:56.280 --> 19:58.080]  то, что находится у него внутри круглых скобок.
[19:58.080 --> 20:05.640]  В теории у меня вектор может быть пустым, но даже если
[20:05.640 --> 20:08.280]  вектор пустой, то вот эта строчка не приведет
[20:08.280 --> 20:09.280]  никакой ошибки.
[20:09.280 --> 20:10.280]  Почему?
[20:10.280 --> 20:12.080]  Потому что на самом деле эта штука не вычисляется,
[20:12.160 --> 20:13.160]  она же анализирует с компилятором.
[20:13.160 --> 20:15.640]  То есть компилятор просто-напросто чисто формально смотрит,
[20:15.640 --> 20:16.640]  ага, есть вектор.
[20:16.640 --> 20:17.640]  Окей.
[20:17.640 --> 20:18.640]  К вектору можно применить квадратные скобки?
[20:18.640 --> 20:19.640]  Да.
[20:19.640 --> 20:20.640]  К вектору можно применить квадратные скобки.
[20:20.640 --> 20:21.640]  Окей.
[20:21.640 --> 20:22.640]  А эти квадратные скобки что возвращают?
[20:22.640 --> 20:26.280]  Ну, квадратные скобки у вектора возвращают const, там, const
[20:26.280 --> 20:27.280]  s ссылка.
[20:27.280 --> 20:28.280]  Да.
[20:28.280 --> 20:31.040]  То есть он видит, что квадратные скобки возвращают const
[20:31.040 --> 20:32.040]  100%.
[20:32.040 --> 20:33.040]  Окей.
[20:33.040 --> 20:38.400]  А если я к вот этому объекту применю точка X, то какого
[20:38.400 --> 20:39.800]  типа будет эта переменная X?
[20:39.800 --> 20:41.480]  Ну, соответственно, там, допустим, переменная X будет
[20:41.480 --> 20:42.480]  иметь тип int.
[20:42.480 --> 20:43.480]  Вот.
[20:43.480 --> 20:45.160]  И поэтому вместо вот этого decal type компилятор подставляет
[20:45.160 --> 20:46.160]  int.
[20:46.160 --> 20:47.160]  Окей.
[20:47.160 --> 20:49.760]  То есть компилятор просто-напросто анализирует это выражение.
[20:49.760 --> 20:50.760]  Вот.
[20:50.760 --> 20:53.120]  Он просто-напросто думает, ага, а что является возвращаемым
[20:53.120 --> 20:55.160]  типом вот этого выражения?
[20:55.160 --> 20:56.160]  Вот.
[20:56.160 --> 20:59.560]  И, точнее, не возвращаем тип, а что является, точнее,
[20:59.560 --> 21:01.560]  с каким типом объявлена вот эта переменная X, которая
[21:01.560 --> 21:03.040]  относится к элементу v0.
[21:03.040 --> 21:04.040]  Вот.
[21:04.040 --> 21:07.760]  Ну и, соответственно, просто-напросто тут создается вектор из вектора
[21:07.760 --> 21:12.120]  элементов, которые совпадают по типу с полем X элементов
[21:12.120 --> 21:13.120]  вектора v.
[21:13.120 --> 21:14.120]  Вот.
[21:14.120 --> 21:16.080]  Ну и дальше я просто-напросто делаю pushback value.x для каждого
[21:16.080 --> 21:17.080]  элемента вектора v.
[21:17.080 --> 21:18.080]  Окей.
[21:18.080 --> 21:19.080]  Нормально?
[21:19.080 --> 21:20.080]  Да.
[21:20.080 --> 21:21.080]  Да.
[21:21.080 --> 21:22.080]  Да.
[21:22.080 --> 21:37.680]  То есть можно при написать const decal type at X, звездочка
[21:37.680 --> 21:43.480]  p равно, не знаю, address x, как-то так.
[21:43.480 --> 21:44.480]  Да.
[21:44.480 --> 21:47.720]  Ну decal type at X это, ну просто, можно считать, что это обычный
[21:47.720 --> 21:50.360]  тип, на который можно вешать константности, ссылки,
[21:50.360 --> 21:53.680]  звездочки и так далее, и так далее.
[21:53.680 --> 21:54.680]  Вот.
[21:54.680 --> 21:55.680]  Так.
[21:55.680 --> 21:56.680]  Еще вопросы.
[21:56.680 --> 21:57.680]  Окей.
[21:57.680 --> 21:58.680]  Теперь.
[21:58.680 --> 22:02.960]  Вот это то, что касается применения decal type к переменам.
[22:02.960 --> 22:03.960]  Значит, еще раз.
[22:03.960 --> 22:04.960]  Да.
[22:04.960 --> 22:05.960]  Если я применяю decal type к какой-то переменной или к
[22:06.280 --> 22:09.400]  на самом деле идентификатору, то он просто-напросто возвращает
[22:09.400 --> 22:12.280]  тип этой перемены или тип этого идентификатора.
[22:12.280 --> 22:13.280]  Вот.
[22:13.280 --> 22:17.120]  Decal type ведет себя чуть иначе, если я применяю decal type к выражению.
[22:17.120 --> 22:18.120]  Да.
[22:18.120 --> 22:19.120]  Ну что значит выражение?
[22:19.120 --> 22:24.520]  Ну выражение значит, что некоторая вычисляемая последовательность
[22:24.520 --> 22:25.520]  операции оперантов.
[22:25.520 --> 22:26.520]  Вот.
[22:26.520 --> 22:33.240]  Ну то есть условно, если я напишу decal type at X, он не вернет
[22:33.240 --> 22:35.840]  тип, с которым объявлен X.
[22:35.840 --> 22:43.280]  Если я напишу decal type от X плюс X, то decal type будет
[22:43.280 --> 22:44.280]  вести себя иначе.
[22:44.280 --> 22:45.280]  Как?
[22:45.280 --> 22:47.080]  Ну вот, собственно, все показано на слайде.
[22:47.080 --> 22:53.680]  Смотрите, decal type анализирует выражение и смотрит на возвращаемый
[22:53.680 --> 22:54.680]  тип.
[22:54.680 --> 22:55.680]  И вот тут смотрите, важно.
[22:55.680 --> 22:58.280]  Если возвращаемый тип, если возвращаемый тип выражения
[22:58.280 --> 23:00.960]  — это просто, ну, если возвращаемый тип выражения — это просто
[23:00.960 --> 23:04.000]  какой-то тип, ну, например, ну, не знаю там, сложение
[23:04.000 --> 23:05.000]  двух интов — это int.
[23:05.680 --> 23:07.820]  То в этом случае decal type в качестве типа подставляет
[23:07.820 --> 23:09.220]  ну просто, просто сам тип.
[23:09.220 --> 23:10.060]  То есть просто int.
[23:10.060 --> 23:11.060]  Вот.
[23:11.060 --> 23:14.080]  И если же выражение возвращает ссылку, вот это вот важный
[23:14.080 --> 23:17.440]  момент, если выражение возвращает ссылку, lvalue-сылку, то
[23:17.440 --> 23:20.380]  и тип выводится как lvalue-сылку.
[23:20.380 --> 23:21.640]  Ok.
[23:21.640 --> 23:22.640]  Вот.
[23:22.640 --> 23:26.480]  Если же выражение возвращает, возвращейт, lvalue-сылку, если
[23:26.480 --> 23:28.600]  выражение возвращает lvalue-сылку, ну или возвращает
[23:28.600 --> 23:32.160]  так называемое X-value, вот, то decal type, то decal type
[23:32.160 --> 23:33.800]  подставляет тип с двойным амперсандом.
[23:33.800 --> 23:37.600]  Ну, вы можете сказать, ну, как бы, ну, а что изменилось?
[23:37.600 --> 23:38.600]  А изменилось следующее.
[23:38.600 --> 23:48.200]  Смотрите, если я пишу декл-тайп от x, ну, допустим, представьте
[23:48.200 --> 23:53.120]  себе, что x объявлено так, x равно 0, то вместо декл-тайп
[23:53.120 --> 23:55.080]  будет подставлен просто нам просто int, да, почему?
[23:55.080 --> 23:57.560]  Потому что x объявлен стипом int.
[23:57.560 --> 24:04.960]  Далее, если я напишу декл-тайп от плюс-плюс x, то смотрите,
[24:04.960 --> 24:05.960]  что происходит.
[24:05.960 --> 24:09.000]  Вроде как плюс-плюс x и x это одно и то же, да, ну,
[24:09.000 --> 24:10.840]  мы уже говорили о том, что плюс-плюс x возвращает
[24:10.840 --> 24:14.720]  самый исходный x, да, вот, но с точки зрения декл-тайп
[24:14.720 --> 24:15.720]  это разные вещи.
[24:15.720 --> 24:16.720]  Почему?
[24:16.720 --> 24:18.480]  Потому что это декл-тайп, примененный к переменной,
[24:18.480 --> 24:21.480]  а это декл-тайп, примененный к выражению, а что возвращает
[24:21.480 --> 24:22.480]  это выражение?
[24:22.480 --> 24:25.880]  Это выражение возвращает ссылку на int, да, вот, поэтому
[24:25.880 --> 24:27.920]  декл-тайп тоже выведет тип как int ссылка.
[24:27.920 --> 24:31.320]  И еще один момент, возможно, странный.
[24:31.320 --> 24:35.400]  Есть на слайде, да, есть, вот он предпоследний.
[24:35.400 --> 24:47.000]  Если я применю декл-тайп к скобках x, что это такое?
[24:47.000 --> 24:49.280]  Это, смотрите, вот этот декл-тайп, он применяется к переменной,
[24:49.280 --> 24:54.280]  а вот этот декл-тайп применяется к выражению, к выражению,
[24:54.280 --> 24:56.200]  который состоит из круглых скобок, и в которых написан
[24:56.200 --> 24:57.200]  внутри x.
[24:57.200 --> 24:58.200]  Понятно?
[24:58.200 --> 25:02.960]  То есть вот это, вот это, то есть в коде C++, понятно
[25:02.960 --> 25:07.280]  дело, что это валидная строчка на C++, потому что это выражение,
[25:07.280 --> 25:10.200]  то есть я могу написать x, могу написать круглые скобки
[25:10.200 --> 25:12.840]  x, то есть круглые скобки C+, они используются для указания
[25:12.840 --> 25:14.880]  приоритет операции, да, то есть тут как раз таки
[25:14.880 --> 25:16.480]  я говорю, что вот в этом выражении, которое состоит
[25:16.480 --> 25:20.120]  из x, в первую очередь нужно вычислить x, вот, но опять
[25:20.120 --> 25:22.600]  же, с точки зрения декл-тайп, это уже выражение, это не
[25:22.600 --> 25:25.800]  переменная, это выражение, и поэтому он его воспринимает
[25:25.800 --> 25:31.040]  как int&&, ну почему, потому что это выражение вычисляется
[25:31.040 --> 25:34.440]  в x, да, ну а x это lvalue, как любая другая переменная,
[25:34.440 --> 25:35.440]  окей?
[25:35.440 --> 25:40.560]  Вот, ну давайте, ну давайте поупражняемся, вот, например,
[25:40.560 --> 25:44.280]  я написал декл-тайп вот x+, что у меня выйдется в качестве,
[25:44.280 --> 25:52.080]  что у меня выйдется в качестве типа, что возвращает x+, да,
[25:52.160 --> 25:54.880]  x+, то есть x возвращает просто int, да, не ссылочный, не lvalue
[25:54.880 --> 25:57.520]  ссылок, не lvalue, а просто int, да, просто какое-то временное
[25:57.520 --> 25:58.520]  значение.
[25:58.520 --> 26:00.540]  Поэтому в первой строчке в качестве типа выведется
[26:00.540 --> 26:01.740]  сам, выведется просто int.
[26:01.740 --> 26:07.120]  Дальше, декл-тайп от plus plus x, int&&, да, это обсуждали,
[26:07.120 --> 26:09.900]  вот, plus plus x это выражение, которое возвращает lvalue ссылку
[26:09.900 --> 26:13.040]  на исходный объект, вот, поэтому в качестве, ну поэтому
[26:13.040 --> 26:15.360]  вместо декл-тайп тут подставится просто int&&.
[26:15.360 --> 26:19.200]  Дальше, декл-тайп от x+, да, просто int, потому что x+,
[26:19.200 --> 26:23.700]  Возвращает просто временное значение, просто int, который хранит старое значение x.
[26:23.700 --> 26:27.200]  Да, поэтому тут просто вы видите int. Даша, декл-тайп с круглоскопкой x.
[26:27.200 --> 26:32.700]  Да, это обсудили. Круглоскопки x уже воспринимаются как выражение, не как переменная.
[26:32.700 --> 26:34.700]  Вот, поэтому тут вернется int амперсанат.
[26:34.700 --> 26:36.700]  Ну окей, декл-тайп, вот sdmove от x.
[26:36.700 --> 26:41.700]  int двойной амперсанат. Да, почему? Потому что sdmove, как мы с вами обсуждали, вот.
[26:41.700 --> 26:44.700]  Он возвращает тип с навершением его двойной ссылкой.
[26:44.700 --> 26:48.700]  Поэтому декл-тайп, ну просто посмотри, что возвращает sdmove, и ну скажешь что.
[26:48.700 --> 26:50.700]  Ну окей, там возвращается int двойная ссылка.
[26:52.200 --> 26:53.200]  Окей?
[26:53.700 --> 26:54.700]  Нормально?
[26:56.200 --> 26:57.200]  Хорошо.
[26:58.200 --> 26:59.200]  Так.
[26:59.700 --> 27:04.200]  Ну и наконец еще одна форма декл-тайп. Это декл-тайп от авто.
[27:04.200 --> 27:07.200]  Давайте сначала посмотрим на верхний пример.
[27:07.200 --> 27:10.700]  Ну мы с вами как-то обсуждали, ну как-то, значит, когда мы с вами говорили про шаблоны,
[27:10.700 --> 27:13.700]  мы с вами говорили про то, как выводится шаблонный параметр.
[27:13.700 --> 27:18.200]  И дальше мы с вами сказали, что если я объявляю переменный с помощью plate-холдера авто,
[27:18.200 --> 27:21.200]  то тип авто выводится так же, как шаблонный параметр.
[27:21.200 --> 27:23.200]  Ну, допомним, как выводится тип авто.
[27:23.200 --> 27:24.200]  Тип авто выводится так.
[27:24.200 --> 27:28.200]  Если справа стоит какой-то ссылочный тип, то ссылки отбрасываются, и просто получается тип.
[27:28.200 --> 27:31.200]  Там константности, ссылки и т.д. отбрасываются, и т.д.
[27:32.200 --> 27:36.200]  Если же, если же я хочу, чтобы там не отбрасывались ссылки,
[27:36.200 --> 27:38.700]  я хочу, чтобы не отбрасывались там константности и т.д.,
[27:38.700 --> 27:43.900]  если я хочу, чтобы тип моей переменной с точностью был бы скопирован с выражения
[27:43.900 --> 27:48.380]  я или с переменной, которая стоит справа, я могу воспользоваться деколтайп от авто.
[27:48.380 --> 27:53.620]  Что это означает? Деколтайп от авто означает следующее, что y объявлен так, как если бы вместо
[27:53.620 --> 28:00.020]  вот этого авто было в точности прописано выражение, которое стоит здесь. То есть вот этот деколтайп от
[28:00.020 --> 28:06.820]  авто y равно x означает деколтайп от x, y равно x. Деколтайп от x возвращает volatile int. Почему?
[28:06.820 --> 28:11.940]  Потому что x объявлен как volatile int. Поэтому y будет иметь тип volatile int. Дальше деколтайп
[28:11.940 --> 28:17.580]  авто z равно plus plus y означает применение деколтайп к plus plus y и ровно такой тип и будет
[28:17.580 --> 28:22.900]  иметь z. Но так как деколтайп от plus plus y это ссылочный тип, то есть volatile int ссылка, то
[28:22.900 --> 28:27.500]  соответственно z будет иметь ровно такой же тип. Ну и наконец деколтайп авто t равно круглоскопки x.
[28:27.500 --> 28:32.580]  Это вот там обсуждали. То есть я применяю деколтайп круглоскопкой x и ровно таким типом
[28:32.580 --> 28:37.580]  объявляю переменную t. То есть деколтайп авто говорит следующее. Нужно вывести тип,
[28:37.580 --> 28:51.820]  но не по правилам авто, а по правилам деколтайп. Нормально? Ну и собственно почему это все? На самом
[28:51.820 --> 28:55.540]  деле вот то, что мы с вами писали до этого. Смотрите, вот тут мы когда реализовали forward,
[28:55.540 --> 29:00.660]  когда реализовали move, нам тут приходилось дублировать тип, который мы писали
[29:00.660 --> 29:06.340]  возвращаемые значения. Так вот, эти примеры могли сильно упростить, если просто написали вместо этих
[29:06.340 --> 29:17.060]  типов деколтайп от авто. И здесь тоже вместо возвращаемого типа можно было просто написать
[29:17.060 --> 29:25.460]  деколтайп авто. Как работает деколтайп от авто? Точнее так, давайте, мы кажется об этом,
[29:25.460 --> 29:31.380]  мы явно об этом не говорили, но давайте сейчас проговорим. Я для возвращаемого значения функции
[29:31.380 --> 29:36.260]  могу использовать тоже авто. Что это будет означать? Это будет означать, посмотри на return,
[29:36.260 --> 29:41.460]  посмотри на возвращаемое значение return и выведи тип, ну как бы ты выводил шаблонный параметр.
[29:41.460 --> 29:46.180]  Ну опять же, напомню, что если ввожу по правилам авто, то это означает, что я отбрасываю ссылки,
[29:46.180 --> 29:49.860]  отбрасываю константности и так далее и так далее. Смотрите, ну тут же мне не нужно отбрасывать
[29:49.860 --> 29:53.860]  ссылки. То есть я тут на самом деле не хочу, чтобы ссылка отбрасывалась. Я хочу, чтобы вернулся именно
[29:53.860 --> 29:57.900]  на этот тип, который тут есть. Именно поэтому я говорю, что я хочу вывести возвращаемое значение
[29:57.900 --> 30:07.340]  не по правилам авто, а по правилам деколтайп. Вот деколтайп, вот авто и так далее. И тогда вот сюда
[30:07.340 --> 30:12.100]  подставится тип, который будет равен, который будет эквивалентен применению деколтайп к вот этому
[30:12.100 --> 30:17.780]  всему. Ну а соответственно значение, точнее типом вот этого выражения, является remove reference
[30:17.780 --> 30:21.180]  t в двойной амперсант, поэтому тут тоже будет remove reference t в двойной амперсант.
[30:21.180 --> 30:28.620]  То есть возвращаемое значение авто говорит о том, что ну просто выведи тип, отбрось ссылки,
[30:28.620 --> 30:32.700]  отбрось константности, вот эти все правила и подставь туда нужное
[30:32.700 --> 30:36.860]  возвращаемое значение. А деколтайп, это авто говорит, что нет, применить деколтайп к возвращаемому
[30:36.860 --> 30:45.020]  значению return и подставь туда вот это вот значение. Не значение, а тип. Еще один пример применения
[30:45.020 --> 30:50.940]  деколтайп. Представьте себе, что у вас есть два массива, два массива разных типов, два массива,
[30:50.940 --> 30:56.420]  которые содержат элементы разных типов. Есть тип T и есть тип U. В чем может быть проблема?
[30:56.420 --> 31:00.860]  Ну понятно дело, что если у меня, допустим, один массив содержит N3, второй массив содержит
[31:00.860 --> 31:06.580]  таблы. А да, в чем задача, собственно. Мне подают вновь код два массива, я хочу получить из них
[31:06.580 --> 31:10.780]  третий массив, который является просто элементной суммой этих двух массивов. Ну грубо говоря,
[31:10.780 --> 31:17.580]  я сохранил два вектора, в геометрическом смысле два вектора, но при этом один вектор
[31:17.580 --> 31:22.660]  хранит N3, другой вектор хранит таблы. Я хочу просто и напросто их чисто математически,
[31:22.660 --> 31:29.820]  геометрически сложить друг с другом. Смотрите, в чем проблема. Проблема состоит в том, что непонятно,
[31:29.820 --> 31:34.180]  чему будет равен тип результирующего вектора. Ой, простите, да, результирующего вектора или
[31:34.180 --> 31:38.260]  результирующего массива. Ну потому что в зависимости того, какие типы мне передали,
[31:38.260 --> 31:41.940]  допустим, если мне передали вектор, который состоит из N2 и другой вектор, который состоит из N2,
[31:41.940 --> 31:46.740]  то окей, все понятно. Результирующий вектор будет хранить N3. Если мне передали вектор из N2 и
[31:46.740 --> 31:52.420]  второй вектор из N2, то окей, будет вектор из N2. Ну и так далее. Я хочу, чтобы программа сама
[31:52.420 --> 31:59.260]  определяла, а какие элементы будет хранить результирующий вектор. Так вот, ровно это,
[31:59.260 --> 32:06.100]  как раз таки, можно сделать с помощью декл-тайп. Вот у меня есть SRA типов T, у меня есть SRA типов U,
[32:06.100 --> 32:10.220]  то есть потенциально разных типов. Ну и понятное дело, что я хочу создать массив результатов.
[32:10.220 --> 32:14.860]  Вот, чтобы создать массив результатов, мне нужно в качестве первого параметра передать тип хранимых
[32:14.860 --> 32:19.180]  элементов. И вот, собственно, тип хранимых элементов я могу записать вот таким образом. Я могу сказать,
[32:19.180 --> 32:25.380]  а давай-ка посмотрим, что произойдет, если я сложу два типа, ну если я сложу два объекта типа T и типа U.
[32:25.380 --> 32:31.860]  Вот, то есть я просто напишу LHS 0 плюс LHS 0, то есть сумму двух элементов, применяю к этому декл-тайп,
[32:31.860 --> 32:38.540]  и, как раз таки, получаю тип суммы двух элементов. Вот. Ну, тут я еще дополнительно себя защищаю
[32:38.540 --> 32:43.180]  с помощью применения модификатора removeCVREF от T. Ну, removeCVREF означает, что нужно убрать и
[32:43.180 --> 32:48.020]  константные, и константы, и волатайлы, и референсы, и так далее. Ну, по понятным причинам, потому что,
[32:48.020 --> 32:55.300]  если вдруг у меня операция сложения для каких-то типов перегружена, и эта перегрузка возвращает,
[32:55.300 --> 33:00.620]  допустим, конст стринг, то, естественно, я не хочу, чтобы у меня в массиве были констринги. Вот,
[33:00.620 --> 33:05.260]  поэтому я говорю, что посчитай, какой тип будет урезетирующей суммы, и вот с этого типа сними
[33:05.260 --> 33:10.020]  константности, ссылки, и так далее, и просто вставь тот тип, который, ну, просто вставь голый тип,
[33:10.020 --> 33:14.940]  без ссылок, константности, и так далее. Вот. То есть, таким образом, я создал массив элементов,
[33:14.940 --> 33:20.380]  я создал массив элементов такого типа, который получится при сложении двух типов, там, двух
[33:20.380 --> 33:28.100]  элементов типа T и типа U, вот. Ну, и даже спокойно заполняю этот массив суммами LHS и LHS. Окей? Да.
[33:28.100 --> 33:37.860]  Нет, почему? Нет, погодите, у вас может быть просто такая вот ситуация, что у вас есть,
[33:37.860 --> 33:41.340]  не знаю, у вас есть интовый вектор, допустим, не знаю, или, допустим, флотовый вектор, есть
[33:41.340 --> 33:45.860]  дабловый вектор. Вот. Вам нужно получить их сумму. Вот. Вы просто пишете обобщенный алгоритм,
[33:45.860 --> 33:49.020]  который работает в этом случае. То есть, если есть два типа, которые можно сложить друг с другом,
[33:49.020 --> 33:52.300]  ну, или, на самом деле, не то, что пукот стайл, ну, смотрите, у вас может быть вполне себе такое,
[33:52.300 --> 33:58.260]  что, а, ну, представьте, у вас есть массив, допустим, указателей и есть массив интов. Указателем
[33:58.260 --> 34:02.700]  же можно прибавлять числа и числа? Вот. Ну, и, соответственно, вот в этой ситуации тоже все сработает.
[34:02.700 --> 34:10.020]  То есть, вы каждому указателю прибавите, прибавится соответствующий сдвиг. Все нормально. Вот. То есть,
[34:10.020 --> 34:15.100]  это просто универсальная функция, которая позволяет сложить вектора, ну, или массивы разных, массивы
[34:15.100 --> 34:19.700]  разных типов. Вот. Ну, и ведет себя более-менее предсказуемым образом, да. То есть, у него в качестве
[34:19.700 --> 34:23.980]  результатов будет ровно тот же самый тип, который получается при сложении типа T, ну, при сложении
[34:23.980 --> 34:34.700]  объектов типа T и типа U. Вот. А тут, тут есть, тут есть небольшая проблема. Ну, точнее, на самом деле,
[34:34.700 --> 34:43.860]  большая проблема. Которая заключается вот в чем. Смотрите. Ну, значит, да, тут еще пример,
[34:43.860 --> 34:48.140]  тут еще пример того, как можно воспользоваться noexcept. То есть, я еще хочу, допустим, дополнительно
[34:48.140 --> 34:56.220]  завести спецификатор noexcept в зависимости того, является ли сложение двух, является сложение
[34:56.220 --> 35:04.620]  элементов типа T и типа U noexcept или нет. Но это ладно. Тут есть следующая более, в общем, такая
[35:04.620 --> 35:10.260]  идеологическая проблема. Вот, смотрите. Представьте себе, что у меня есть какой-то тип T и у меня есть
[35:10.260 --> 35:16.460]  какой-то тип U. И представьте себе, что в какой-то момент, ну, в программе моей, я хочу завести тип,
[35:16.460 --> 35:22.540]  ну, точнее, я хочу создать переменную X, ну, хочу завести переменную X, ну, допустим, равную нулю,
[35:22.540 --> 35:33.380]  которая бы имела ровно тот же самый тип, что дает сложение объектов типа T и типа U. Ну, короче,
[35:33.380 --> 35:39.500]  я хочу, чтобы тип X, чтобы тип MxA был тип, который получается при сложении объектов типа T и типа U.
[35:39.500 --> 35:47.500]  Ну, допустим, вот у меня есть переменная TA, у меня есть переменная TB, вот. И я хочу, грубо говоря,
[35:47.500 --> 36:06.260]  сделать вот декл-тайп вот A плюс B. В чем проблема? Проблема заключается в том, что вот если я хочу
[36:06.260 --> 36:11.900]  получить тип какого-то выражения, тип какого-то выражения, который применяется, ну, типа какого-то
[36:11.900 --> 36:16.540]  выражения, мне необходимо для этого либо создать переменные этого типа, либо написать какое-то
[36:16.540 --> 36:21.500]  выражение, которое бы давало нужный мне тип. Вот, например, как здесь. Чтобы, например, получить тип
[36:21.500 --> 36:27.180]  сложения двух, чтобы получить тип сложения T и U, да, мне необходимо было получить LHS от нуля и RHS
[36:27.180 --> 36:31.980]  от нуля. Но все тут потенциальная проблема. А потенциальная проблема тут заключается в том,
[36:31.980 --> 36:36.060]  что представь себе, что я в какой-то момент написал, ну, представь себе, что мне, на самом деле,
[36:36.060 --> 36:39.940]  в сумму передали на вход массив нулей. Ну, точнее, не нулей, простите, а массив нулевого размера.
[36:39.940 --> 36:46.140]  Да, SDRA нулевого размера, SD и второй SDRA нулевого размера. Значит, по стандарту SDRA нулевого
[36:46.140 --> 36:49.340]  размера, они должны поддерживаться. Ну, причем они поддерживаются так, что, ну, точнее, там, на самом
[36:49.340 --> 36:54.980]  деле, я уже не помню никак, в общем, там в теории, по-моему, может быть такое, что у массива нулевого
[36:54.980 --> 37:00.220]  размера нельзя позвать квадратные скобки. Вот. И тогда тут возникает проблема. Да, если у массива
[37:00.220 --> 37:03.460]  нулевого размера нельзя позвать квадратные скобки, тогда, соответственно, это просто не скомпилируется.
[37:03.460 --> 37:09.140]  Вот. Ну, хотя, вроде как, хотя, наверное, при сложении двух массивов нулевого размера хотелось бы
[37:09.140 --> 37:12.580]  получить просто массив нулевого размера, да, хотелось бы, чтобы это скомпилировалось. Вот.
[37:12.580 --> 37:17.700]  Это первая проблема. А вот вторая проблема, которую я как раз тут описывал, заключается в следующем. Вот.
[37:17.700 --> 37:23.660]  Мне нужно получить, мне нужно получить переменную, в которой будет храниться результат сложения двух
[37:23.700 --> 37:30.220]  переменных x и y. И при этом я хочу написать какой-то тип. Хочу написать, хочу написать какой-то тип. Вот.
[37:30.220 --> 37:35.380]  Но в чем тут проблема? Смотрите, чтобы написать, чтобы создать переменную z, которая имеет тот же
[37:35.380 --> 37:40.740]  самый тип, что и сложение x плюс y, мне пришлось для этого создать перемены x и y. Ну, а хотя, на самом
[37:40.740 --> 37:46.340]  деле, возможно, мне сами перемены x и y не нужны. Понятно? Вот. То есть, я хочу создать переменную z,
[37:46.340 --> 37:51.500]  которая имеет тот же самый тип, что и сложение двух объектов типа t. Вот. Но, соответственно, мне для этого,
[37:51.500 --> 37:55.340]  чтобы написать декл-тайп соответствующий, мне пришлось создать переменную x и переменную y.
[37:55.340 --> 38:01.140]  Хотя, они, возможно, мне совсем-совсем не нужны. Тут можно сказать следующее. Смотрите. Ну, а давайте
[38:01.140 --> 38:05.540]  я поступлю так. Вот. Например, вот в этой задаче. Давайте я не буду создавать переменные a и b,
[38:05.540 --> 38:21.380]  а напишу вот так. Напишу декл-тайп от t плюс u. Ну, что тут происходит? Я говорю, давайте создадим
[38:21.460 --> 38:25.660]  t по умолчанию, создадим u по умолчанию и сложим два этих объекта по умолчанию. Пrites посмотрим,
[38:25.660 --> 38:32.060]  что за типа получится. И ровно этот тип сохраним... и ровно этот тип сохраним в перемену x. Вот. Но,
[38:32.060 --> 38:36.260]  в чем проблема? Проблема в том, что мне никто и гарантирует, мне вообще никто не гарантирует,
[38:36.260 --> 38:42.440]  то, что тип t и тип u имеет конструктор по умолчанию, согласны? Вот. А что если, например, тип t и тип
[38:42.440 --> 38:46.980]  u конструктор по умолчанию не имеют? Ну, тогда получается... если такое выражение, я написать
[38:46.980 --> 38:52.140]  имею право но все-таки наверное ну все-таки наверное хотелось бы да хотелось бы
[38:52.140 --> 38:55.860]  уметь анализировать анализировать выражение при этом не создавая никаких
[38:55.860 --> 39:03.100]  конкретных объектов проблема понятно окей как будем решать вот проблема и
[39:03.100 --> 39:08.360]  проблема решается с помощью специальной функции decal val давайте про нее поговорим
[39:08.360 --> 39:14.740]  значит decal val это конечно функция mem смотрите вот все что известно про
[39:14.740 --> 39:19.100]  функцию decal val вот представь себе что у вас есть специальная функция давайте я
[39:19.100 --> 39:33.300]  ее напишу я допустим написал std decal val int пугу и скобки
[39:33.620 --> 39:39.860]  короче все что я знаю про эту функцию это то что она возвращает int все больше я
[39:40.420 --> 39:52.940]  больше я про нее ничего не знаю или я могу сказать decal val от флот амперсант
[39:52.940 --> 39:57.980]  опять же все что я знаю про эту функцию то что она возвращает тип флот амперсант
[39:57.980 --> 40:03.260]  про то как она устроена про то там что она внутри себя делает я ничего не знаю все что я знаю то
[40:03.260 --> 40:08.860]  что вот она возвращает именно то что мне нужно вот для произвольного типа t для произвольного типа
[40:09.260 --> 40:15.720]  D kernel reversed ровно то что нужно окей вот теперь смотрите допустим допустим меня есть такая вот
[40:15.720 --> 40:20.300]  замечательная допустим есть такая замечательные функции декала которая вот чтобы я в нее и передал
[40:20.300 --> 40:26.620]  она сможет это вернуть выглядит как решается проблема эта проблема решается очень просто есть у
[40:26.620 --> 40:32.580]  меня есть такая замечательная функция которая может вернуть то что угодно я пишу по первост logic
[40:32.580 --> 40:51.580]  Декалкайп, потом могу написать декалвал от t плюс декалвал от u, x, ну и допустим ровно нулю.
[40:51.580 --> 41:00.580]  Что это будет означать? Это будет означать следующее, что тип x будет совпадать с типом вот этого выражения.
[41:00.580 --> 41:07.580]  А что это за выражение? Тут из этой функции возвращается объект типа t, из этой функции возвращается объект типа u.
[41:07.580 --> 41:14.580]  Дальше они складываются, и результативающий тип является типом x.
[41:14.580 --> 41:19.580]  При этом обратите внимание, что я тут вообще не предполагаю ничего.
[41:19.580 --> 41:22.580]  То есть я не предполагаю, что у t есть конструктор, что у u есть конструктор.
[41:22.580 --> 41:25.580]  То есть я вообще не знаю, как устроены типа t и типа u.
[41:25.580 --> 41:27.580]  Более того, я не знаю, как устроена функция декалвал.
[41:27.580 --> 41:32.580]  Все, что я знаю, то, что декалвал возвращает ровно то, что нужно, именно тот тип, который есть, тип t.
[41:36.580 --> 41:43.580]  Декалвал мы можем использовать всегда в тех контекстах, когда мы хотим как будто бы создать какой-то объект,
[41:43.580 --> 41:50.580]  чтобы проверить его возвращаемый тип или свойства возвращаемого типа.
[41:50.580 --> 41:54.580]  Но при этом мы не можем опираться на то, что, допустим, у типа есть какой-то конструктор,
[41:54.580 --> 41:55.580]  или, допустим, мы не хотим создавать объектов.
[41:55.580 --> 41:58.580]  Вот если мы не хотим создавать объектов типа конкретного,
[41:58.580 --> 42:00.580]  мы можем просто воспользоваться декалвалом.
[42:03.580 --> 42:05.580]  Тут может возникнуть естественный вопрос.
[42:05.580 --> 42:07.580]  А как на самом деле устроена декалвал?
[42:07.580 --> 42:09.580]  Декалвал — это какая-то стандартная функция,
[42:09.580 --> 42:11.580]  которую я придаю в стандартной библиотеке.
[42:11.580 --> 42:16.580]  И как так получается, что декалвал может вернуть вообще все что угодно?
[42:18.580 --> 42:19.580]  Ответ такой.
[42:19.580 --> 42:23.580]  Как реализовать функцию, которая может вернуть все что угодно?
[42:23.580 --> 42:24.580]  Ответ — никак.
[42:28.580 --> 42:31.580]  Все плюс-плюс, есть прекрасная возможность не писать определение функции,
[42:31.580 --> 42:33.580]  если на самом деле определение функции не требуется.
[42:34.580 --> 42:37.580]  Так вот, декалвал устроен следующим образом.
[42:46.580 --> 42:47.580]  Template class T.
[42:47.580 --> 42:49.580]  Ну и давайте я напишу свою версию декалвал.
[42:50.580 --> 43:00.580]  Декалвал не принимает никаких аргументов и возвращает все.
[43:03.580 --> 43:07.580]  Вот это по сути все, что нужно от функции декалвал.
[43:09.580 --> 43:11.580]  Все тут важно понимать.
[43:11.580 --> 43:14.580]  Важно понимать то, что функция декалвал
[43:14.580 --> 43:18.580]  на самом деле никогда не будет вызываться в реальных выражениях.
[43:18.580 --> 43:20.580]  То есть в выражениях, которые будут реально вычисляться.
[43:21.580 --> 43:23.580]  Декалвал — это специальная функция,
[43:23.580 --> 43:31.580]  которая должна быть использована только в так называемых не вычисляемых контекстах.
[43:31.580 --> 43:34.580]  То есть в контекстах, когда вычисление самой функции не требуется.
[43:34.580 --> 43:36.580]  Ну какие это контексты? Мы с вами уже про них знаем.
[43:36.580 --> 43:38.580]  Например, sizeof.
[43:38.580 --> 43:40.580]  Это контекст, например, noexcept.
[43:40.580 --> 43:42.580]  То есть если я просто хочу проверить какие-то свойства,
[43:42.580 --> 43:44.580]  то есть просто-напросто операции, которые проверяют свойства,
[43:44.580 --> 43:45.580]  они вычисляют выражение.
[43:45.580 --> 43:46.580]  Или, например, decaltype.
[43:46.580 --> 43:48.580]  Декалtype тоже не вычисляет выражение,
[43:48.580 --> 43:50.580]  он просто-напросто его анализирует.
[43:50.580 --> 43:53.580]  А если компилятору нужно просто-напросто проанализировать выражение,
[43:53.580 --> 43:55.580]  то естественно и определение функции ему не нужно.
[43:55.580 --> 43:57.580]  То есть компилятор просто-напросто смотрит на объявление функции,
[43:57.580 --> 43:59.580]  ага, в функции декалвал,
[43:59.580 --> 44:00.580]  она возвращает тип T2n.
[44:00.580 --> 44:01.580]  Ну все замечательно.
[44:01.580 --> 44:03.580]  Значит она возвращает то, что нужно,
[44:03.580 --> 44:04.580]  или она возвращает T2n.
[44:04.580 --> 44:09.580]  Я могу это использовать для проверки нужных мне свойств.
[44:09.580 --> 44:11.580]  Окей? Да.
[44:12.580 --> 44:16.580]  Ну да, нет, не то что это я.
[44:16.580 --> 44:18.580]  Там скорее всего ошибка линков.
[44:18.580 --> 44:20.580]  Если вы просто-напросто в коде напишите,
[44:20.580 --> 44:22.580]  вызовут функции декалвал,
[44:22.580 --> 44:24.580]  в каком-то вычисляемом контексте,
[44:24.580 --> 44:27.580]  то получите ошибку компиляции, ошибку линковки.
[44:27.580 --> 44:30.580]  Потому что вы вызовете функцию, у которой нет определения.
[44:33.580 --> 44:35.580]  То есть опять, функция декалвал,
[44:35.580 --> 44:37.580]  это по сути та же самая функция,
[44:37.580 --> 44:39.580]  это еще одна из такой череды функций,
[44:39.580 --> 44:41.580]  которые обманывают компилятор.
[44:41.580 --> 44:43.580]  То есть функция декалвал говорит,
[44:43.580 --> 44:45.580]  да, окей, я там это возвращаю, именно это.
[44:45.580 --> 44:47.580]  Вот, как бы, можешь не переживать.
[44:47.580 --> 44:49.580]  Окей?
[44:53.580 --> 44:55.580]  Такой немного тонкий вопрос.
[44:55.580 --> 44:57.580]  Как вы думаете, зачем тут возвращать именно T2n%?
[44:57.580 --> 44:59.580]  Ну то есть почему бы тут не написать,
[44:59.580 --> 45:01.580]  просто-напросто...
[45:01.580 --> 45:03.580]  Т.
[45:03.580 --> 45:05.580]  Да.
[45:05.580 --> 45:07.580]  Какая перегрузка?
[45:07.580 --> 45:09.580]  Не, ну смотрите, как бы,
[45:09.580 --> 45:11.580]  если я напишу,
[45:11.580 --> 45:13.580]  если я напишу,
[45:13.580 --> 45:15.580]  допустим, декалвал от
[45:15.580 --> 45:17.580]  int%
[45:19.580 --> 45:21.580]  то тут в качестве возвращаемого значения будет
[45:21.580 --> 45:23.580]  стоять int%.
[45:23.580 --> 45:25.580]  Вот. Ну то есть тот тип, который я передам сюда,
[45:25.580 --> 45:27.580]  он в точности,
[45:27.580 --> 45:29.580]  он будет стоять
[45:29.580 --> 45:31.580]  в точности,
[45:31.580 --> 45:33.580]  он будет стоять в точности,
[45:33.580 --> 45:35.580]  он будет стоять в точности,
[45:35.580 --> 45:37.580]  а я передам сюда,
[45:37.580 --> 45:39.580]  он в точности скопируется вот сюда в возвращаемое значение.
[45:41.580 --> 45:43.580]  Я то есть если sandwichу декалвал от
[45:43.580 --> 45:45.580]  tmp%, то у меня here будет
[45:45.580 --> 45:47.580]  в возвращаемом значении int&%
[45:47.580 --> 45:49.580]  если я напишу int%
[45:49.580 --> 45:50.580]  то у меня будет2tnt%,
[45:50.580 --> 45:52.580]  если напишу int'
[45:52.580 --> 45:54.580]  то в возвращаемом значении будет un.
[45:54.580 --> 45:56.580]  То есть вам кажется, что я ровно это и хочу.
[45:56.580 --> 45:58.580]  Чтоб функция декалвал возвращала ровно То, что я прошу.
[46:02.580 --> 46:04.580]  Ну вот почему на самом деле
[46:04.580 --> 46:09.580]  в библиотеке, почему на самом деле лучше возвращать именно этот двойной амперсант.
[46:12.580 --> 46:19.580]  На самом деле тут проблемы в следующем. Если я возвращаю t,
[46:19.580 --> 46:22.580]  то тут, возможно, следующая проблема. Представь себе, что я вызываю декалвал
[46:22.580 --> 46:27.580]  для типа t, у которого нет ни конструктора копирования, ни конструктора перемещения.
[46:27.580 --> 46:33.580]  Тогда у компинатора возникнут вопросики. Погоди, вот ты вызываешь функцию декалвал
[46:33.580 --> 46:38.580]  для типа, у которого нет ни конструктора копирования, ни конструктора перемещения.
[46:38.580 --> 46:43.580]  У компилятора возникает вопрос. Погоди, а как тогда этот объект t вернется сюда?
[46:44.580 --> 46:50.580]  Логичный вопрос. Вот у меня есть функция декалвал, которая возвращает какой-то объект,
[46:50.580 --> 46:53.580]  который нельзя ни скопировать, ни переместить. То есть, грубо говоря, компилятор понимает,
[46:53.580 --> 46:56.580]  ага, этот объект, видимо, как-то создается внутри функции декалвал,
[46:56.580 --> 46:59.580]  ну или как-то он его получает и дальше возвращает наружу.
[46:59.580 --> 47:05.020]  И соответственно, компилятор вот тут должен подставить какой-то код,
[47:05.020 --> 47:09.020]  скопировать из функции вот сюда, или переместить из функции вот сюда.
[47:09.020 --> 47:12.020] upport.otago.ru Но если компилятор видит, что у типа нет ни конструктора копирования,
[47:12.020 --> 47:14.020]  ни конструктора перемещения, то он задаст вопрос.
[47:14.020 --> 47:17.020]  Хорошо, а как я это должен сделать? И вот тут возникнет ошибка компиляции.
[47:17.020 --> 47:19.020]  Потому что компилятор скажет, погоди, тип не копируемый, тип неперемещаемый,
[47:19.020 --> 47:26.020]  поэтому из функции, из этой функции, вот сюда я не смогу поместить объект. Понятно?
[47:26.020 --> 47:31.120]  exploit()
[47:31.120 --> 47:35.140]  Так, смотри еще раз. Чего анализ?
[47:35.140 --> 47:36.560]  Попустим, компилятор анализирует вот такое выражение.
[47:36.560 --> 47:43.040]  Давайте проанализируем компилятор. Что понимает компилятор?
[47:43.040 --> 47:47.240]  Чтоб понимает что тут вызывается функция f, дальше вызывается функция g
[47:47.240 --> 47:50.040]  дальше кот 거의 готова bater deeds
[47:50.040 --> 47:55.480]  и только потом крь Mountaintest
[47:55.480 --> 47:59.840]  то есть он же не дурак, он понимает, что из функций объект должен как-то вернуться вот в это место.
[48:01.840 --> 48:06.200]  Естественно, компилятор задаётся вопросом, типа, а вообще, возможно ли из функции вернуть этот объект или нет.
[48:06.200 --> 48:09.360]  То есть вообще объект нужно скопировать сюда или объект нужно переместить сюда или нет.
[48:13.800 --> 48:15.800]  Поэтому, чтобы у компилятора не возникало таких вопросов,
[48:18.160 --> 48:20.160]  я пишу это и двойной персант.
[48:20.360 --> 48:23.080]  Почему компилятор в этом случае не будет никаких вопросов?
[48:23.320 --> 48:30.960]  Потому что если функция декалвал как-то смогла создать эту ссылку, то значит объект точно есть, объект точно существует.
[48:30.960 --> 48:34.280]  И плюс, на самом деле, ссылки не требуют копирования.
[48:35.320 --> 48:40.360]  Потому что ссылка означает вернуть именно ту самую область парстанции, которая связана вот с этим объектом.
[48:45.560 --> 48:49.960]  Ну и на самом деле тут двойная ссылка даёт мне следующее преимущество.
[48:49.960 --> 48:56.520]  Если я в декалвал передал int&, то int& плюс двойной персант даст мне просто амперсант.
[48:56.520 --> 48:58.520]  Да, ровно то, чего я хотел.
[48:58.520 --> 49:01.720]  Вот, если я передам int& и двойной персант, то тут тоже выйдет тип int& и двойной персант.
[49:01.720 --> 49:03.720]  Если я передам int, то тут выйдет int& и двойной персант.
[49:03.720 --> 49:08.520]  Ну, по сути, то же самое, то есть неважно, там я передал это или это, да всё равно декалвал вернёт rvalue.
[49:12.200 --> 49:14.200]  Понятно?
[49:14.280 --> 49:16.200] itional process tie
[49:19.240 --> 49:25.080]  Ну нет, можно получить просто т, но для этого вы просто, наоб Zug А сейчас, можно ли получить просто Т?
[49:25.320 --> 49:32.120]  Ну вот. Смотрите, опять же, если вам нужно получить просто Т, то кажется, что это –
[49:33.320 --> 49:35.960]  Ну кажется, это нельзя сделать в универсальном контексте
[49:37.800 --> 49:41.480]  Погодите. Нет, это короче кажется что нельзяFred в универсальном контексте.
[49:41.480 --> 49:47.480]  Потому что по тем причинам, которые я описал ранее, объект может быть не копируем, объект может быть не...
[49:47.480 --> 49:53.480]  Короче, если вы просто пишете t, это вы утверждаете, что в какой-то момент должно произойти создание этого объекта.
[49:55.480 --> 50:00.480]  То есть если вы написали decalval, то есть decalval, а просто t, ну просто, допустим, от int или какого-то типа,
[50:00.480 --> 50:04.480]  это означает, что в любом случае должен быть создан объект.
[50:04.480 --> 50:08.480]  Ссылка же говорит, ссылка не говорит о том, что объект должен быть создан.
[50:08.480 --> 50:14.480]  Потому что ссылка может связываться с объектом, который уже был создан где-то ранее в глобальной памяти или где-то еще.
[50:14.480 --> 50:18.480]  А если вы пишете просто tip, то это означает, что объект обязательно должен быть создан.
[50:18.480 --> 50:24.480]  И дальше у комплиатора могут возникать вопросы типа, а как он создан, а как я его скопирую, а как я его перемещу и так далее.
[50:24.480 --> 50:29.480]  А тогда вы можете, ну тогда, скорее всего, вы можете сделать так.
[50:29.480 --> 50:34.480]  Тогда вы можете просто написать t, вот decalval.
[50:38.480 --> 50:46.480]  Ну тогда decalval вернет вам какую-то ссылку, и вы говорите, что давайте эту ссылку, я с помощью этой ссылки там либо скопирую, либо перемещу в t.
[50:46.480 --> 50:49.480]  Можно мы через это скопируем.
[50:50.480 --> 50:54.480]  Ну это опять же, если вы прям уверены, что tip.t либо копируем, либо перемещаем.
[50:57.480 --> 50:59.480]  Так, еще вопросы.
[50:59.480 --> 51:00.480]  Да.
[51:00.480 --> 51:02.480]  Ну что значит ссылочные сложения?
[51:05.480 --> 51:11.480]  Ну в плане того, что у нас в плане перегрузки очень �iny же отм valeurется,
[51:11.480 --> 51:16.480]  и поэтому у нас либо есть сложениеpendol, либо есть сложениеdevirtual resilience,
[51:16.480 --> 51:17.480]  или esqlo attitudes?
[51:17.480 --> 51:18.480]  В俺 smiles, yes.
[51:19.480 --> 51:20.480]  Б punching.
[51:23.480 --> 51:26.480]  Я даю тебе defending object и airborne object.
[51:26.480 --> 51:27.480]  SDK.
[51:27.480 --> 51:31.480]  Либо есть сложение для кодов, либо есть сложение для двух ссылок.
[51:35.480 --> 51:40.480]  Нет, вы можете написать сложение для lvalue и сложение для rvalue.
[51:40.480 --> 51:43.480]  То есть по типу перегрузки ссылки.
[51:43.480 --> 51:47.480]  Более-менее, смотрите, вот эта ситуация, вот этот декалвал,
[51:47.480 --> 51:49.480]  покрывается все возможные варианты.
[51:49.480 --> 51:55.480]  Потому что декалвал может вернуть либо lvalue, либо rvalue.
[51:55.480 --> 51:59.480]  Если у него передали lvalue, то он вернет как раз к rvalue ссылку.
[51:59.480 --> 52:02.480]  Если у него передали lvalue, то он вернет lvalue ссылку.
[52:07.480 --> 52:10.480]  Даже если там есть какая-то функция или какой-то метод,
[52:10.480 --> 52:16.480]  который зависит от категории значения, то, опять же, у вас все случаи покрываются.
[52:16.480 --> 52:19.480]  То есть есть lvalue ссылки, есть rvalue ссылки.
[52:19.480 --> 52:23.480]  И в целом декалвал все случаи более-менее покрывает.
[52:25.480 --> 52:27.480]  Еще вопросы?
[52:36.480 --> 52:41.480]  Я уже показал, как можно исправить вот этот пример и предыдущий пример.
[52:41.480 --> 52:48.480]  Просто вместо lcs от 0 и rcs от 0 записать декалвал от t и декалвал от u.
[52:48.480 --> 52:52.480]  То есть я говорю, что неважно как, откуда-то у меня есть объект типа t,
[52:52.480 --> 52:54.480]  откуда-то у меня есть объект типа u, и просто их нужно сложить.
[52:54.480 --> 52:57.480]  Просто нужно понять, а что произойдет в результате их сложения.
[52:57.480 --> 52:59.480]  То есть это делается с помощью декалвала,
[52:59.480 --> 53:01.480]  тогда мне не нужно создавать никаких дополнительных переменных,
[53:01.480 --> 53:03.480]  не выдумывать никаких выражений.
[53:03.480 --> 53:06.480]  Все в итоге сработает и так.
[53:06.480 --> 53:09.480]  Это более-менее тоже обсудили.
[53:13.480 --> 53:15.480]  Есть ли вопросы?
[53:17.480 --> 53:21.480]  Давайте перейдем к следующей теме большой.
[53:22.480 --> 53:30.480]  Это еще одна ключевая аббревиатура c++, которая называется SFINAE.
[53:33.480 --> 53:35.480]  Что такое SFINAE?
[53:35.480 --> 53:40.480]  SFINAE расшифровывает как substitution failure is not an error.
[53:40.480 --> 53:43.480]  То есть ошибка в установке не является ошибкой.
[53:43.480 --> 53:47.480]  Это на самом деле одно из правил c++, которые мы с вами не обсуждаем до этого.
[53:47.480 --> 53:50.480]  На самом деле в нем и необходимости особо не было.
[53:50.480 --> 53:53.480]  Давайте обсудим его сейчас.
[53:53.480 --> 53:55.480]  Что означает эта фраза?
[53:55.480 --> 53:57.480]  Неудачная обстановка? Нет, это не ошибка.
[53:57.480 --> 53:59.480]  Эта фраза говорит следующее.
[53:59.480 --> 54:03.480]  Если вдруг в результате подстановки шаблонных параметров
[54:03.480 --> 54:06.480]  у вас возникла какая-то несуразица, какая-то билиберда,
[54:06.480 --> 54:12.480]  то компилятор просто этот шаблон не рассматривает в качестве возможной перегрузки.
[54:12.480 --> 54:15.480]  Давайте перейдем к примеру.
[54:15.480 --> 54:20.480]  Да, вот смотрите.
[54:20.480 --> 54:24.480]  Представьте, что у меня есть две шаблонные функции f.
[54:24.480 --> 54:26.480]  Первая шаблонная функция f принимает int,
[54:26.480 --> 54:28.480]  вторая шаблонная функция f принимает long.
[54:28.480 --> 54:31.480]  Но при этом первая функция f возвращает temp%,
[54:31.480 --> 54:34.480]  а вторая функция f возвращает тип t.
[54:34.480 --> 54:36.480]  Смотрите, что происходит.
[54:36.480 --> 54:40.480]  Представьте, что я вызываю f дальше в треугольный скоплочар от нуля.
[54:40.480 --> 54:42.480]  Смотрите, как это работает.
[54:42.480 --> 54:46.480]  Если я в качестве типа t в первую и вторую функцию подставлю char,
[54:46.480 --> 54:49.480]  то первая функция будет возвращать char ampersand,
[54:49.480 --> 54:51.480]  а вторая будет возвращать void.
[54:51.480 --> 54:53.480]  Пока все нормально.
[54:53.480 --> 54:55.480]  Если я подставлю f в треугольный скоплочар,
[54:55.480 --> 54:58.480]  у меня будет существовать первая версия функции f,
[54:58.480 --> 55:00.480]  в которой в качестве шаблонных параметров подставил char,
[55:00.480 --> 55:02.480]  и вторая версия шаблонной функции f, в которой я подставил char.
[55:02.480 --> 55:04.480]  То есть они существуют одновременно.
[55:04.480 --> 55:06.480]  И даже когда я функцию f вызываю от нуля,
[55:06.480 --> 55:08.480]  у меня происходит выбор перегрузки.
[55:08.480 --> 55:11.480]  То есть выбор функции между int и long.
[55:11.480 --> 55:17.400]  соответственно, так как 0 имеет тип int, то, соответственно, будет выбрана первая функция, окей?
[55:18.000 --> 55:23.120]  А теперь смотрите, что происходит дальше. Дальше я вызываю функцию f и передаю ее в качестве шаблонного параметра void.
[55:23.840 --> 55:26.520]  В чем тут проблема? Проблема тут заключается в том, что
[55:27.560 --> 55:31.000]  ссылки на void не существуют. То есть, ну, нельзя создать тип ссылки на void.
[55:32.240 --> 55:39.040]  Поэтому, если я подставлю вот это вот f от void в первый шаблон, то у меня в компилятор возникнет ошибочная конструкция вида
[55:39.520 --> 55:41.520]  ссылка на void.
[55:43.200 --> 55:47.960]  Что мы можем предположить, что в этом случае произойдет? Ну, смотрите, компилятор мог бы поступить так.
[55:48.320 --> 55:50.320]  Компилятор мог бы сразу запаниковать, сказать, погоди,
[55:50.800 --> 55:55.240]  тут ты подставил функцию f void, и в качестве pt подставил void, у тебя возник void.impercent.
[55:55.240 --> 55:57.500]  Соответственно, он мог закричать об ошибке, сказать, что все плохо,
[55:58.000 --> 56:00.000]  значит, такой функции f существовать не может.
[56:00.480 --> 56:08.280]  Но правило SFINAE говорит следующее, что если вдруг я подставил какой-то шаблонный параметр, и у меня возникло какой-то несуществующий тип,
[56:08.280 --> 56:13.720]  или просто возникла какая-то ошибочная конструкция, то компилятор просто игнорирует эту шаблонную функцию.
[56:14.080 --> 56:22.240]  Он говорит, окей, вот эта шаблонная функция не подходит, потому что в результате подстановки в нее возникает какая-то некорректная запись.
[56:22.360 --> 56:26.040]  Поэтому эту шаблонную функцию он просто игнорирует и рассматривает другие.
[56:26.880 --> 56:32.280]  И вот именно в этом случае, когда я передаю f от void, у меня первая функция игнорируется, потому что в ней возникает ошибочный тип, и
[56:32.480 --> 56:37.320]  таким образом, в результате вызова f от void, у меня существует только один кандидат на перегрузку, это f от long, и
[56:37.440 --> 56:41.800]  поэтому, несмотря на то, что я туда передал ноль, у меня вызовется все равно f от long, потому что первые функции как бы,
[56:41.800 --> 56:44.800]  ну, которые существуют с параметром void, ее как бы не существует.
[56:45.520 --> 56:47.520]  Окей?
[56:49.320 --> 56:54.120]  Нормально? Вот. То есть, если в результате подстановки шаблона к параметрам возникает
[56:54.400 --> 57:00.800]  ошибочная конструкция, то это не приводит к ошибке сразу. Просто написать компилятор, этот шаблон игнорирует до поры до времени.
[57:03.280 --> 57:05.280]  Вот. Значит, еще один пример.
[57:08.720 --> 57:10.720]  Давайте напишем структуру,
[57:11.200 --> 57:15.160]  в общем случае, которая будет проверять, можно ли на тип навесить ссылку или нет.
[57:15.960 --> 57:17.800]  Смотрите, как все устроено.
[57:17.800 --> 57:22.520]  Все устроено так. Я напишу структуру из referenceable, то есть, можно ли навесить на тип ссылку или нет.
[57:22.520 --> 57:34.520]  А, я вспомнил, нет, тут, короче, написано ерунда, в общем, нет, так не работает. Прошу прощения. Давайте дальше сразу. Другие примеры.
[57:35.520 --> 57:37.160]  Смотрите.
[57:37.160 --> 57:42.160]  Смотрите. Вот еще пример. У меня есть функция, у меня есть шаблонная функция a,
[57:43.160 --> 57:47.080]  шаблонная функция a, у которой в качестве второго шаблонного параметра выступает тип,
[57:47.760 --> 57:50.680]  тип массива размера n%2.
[57:51.520 --> 57:53.520]  Вот. И есть, соответственно,
[57:55.680 --> 58:00.080]  шаблонная функция a, которая содержит всего лишь один шаблонный параметр n. Смотрите, что тут происходит.
[58:00.960 --> 58:08.040]  Допустим, точнее, допустим, вот я тут вызываю функцию a шаблоном параметром a, шаблоном параметром 5. Что тут происходит?
[58:08.040 --> 58:10.040]  Тут вместо n-ки подставляется 5, и
[58:10.480 --> 58:16.320]  тут вместо n-ки тоже подставляется 5, в итоге получается в качестве второго шаблона параметра выводится массив витов размер 1.
[58:16.560 --> 58:23.480]  Вот. То есть в итоге первая шаблонная функция – это шаблонная функция с параметрами 5 и массив Nordic, размер 1.
[58:23.520 --> 58:28.460]  Вот. И вторая шаблонная функция, то есть я подставляю этот параметр и во вторую шаблонную функцию, так они обе,
[58:28.600 --> 58:33.880]  так не обе шаблонные функции а, я подставляю сюда 5, получается просто шаблонная функция a с параметром 5.
[58:33.880 --> 58:37.160]  То есть у меня одновременно в программе существует и первая шаблонная функция, и вторая шаблонная функция,
[58:37.160 --> 58:39.860]  при этом первая шаблонная функция имеет 2 параметра,
[58:40.040 --> 58:43.880]  вторая шаблонная функция имеет 1 параметр. Вот. И дальше в эту шаблонную функцию я передаю значение 0.
[58:43.880 --> 58:48.920]  ну и дальше все происходит ровно как ровно по правилам перегрузки да то есть у меня существуют
[58:48.920 --> 58:53.280]  две версии функции одна принимает int и другая принимает long ну соответственно если я передаю
[58:53.280 --> 58:58.600]  int то естественно выигрывает функция которая принимает int но если я вызову a в трикольных скобках
[58:58.600 --> 59:03.160]  2 от нуля тут будет другая ситуация тут как раз таки будет вот эта самая свиная контекст смотрите
[59:03.160 --> 59:08.960]  что происходит тут происходит следующее я подставляю в качестве n шаблонный параметр 2 вот
[59:09.140 --> 59:15.560]  предоставляете два и дальше здесь пишется следующее int от n процент 2 получается
[59:15.560 --> 59:21.160]  массив int размера 0 но но по стандарту c++ массива размера 0 запрещено просто
[59:21.160 --> 59:27.000]  просто запрещены то есть невозможно создать сишный массив размер точнее так скорее всего
[59:27.000 --> 59:32.240] .: компилятор какой-то разрешают это сделать но строго по стандарту массив размеры 0 запрещены
[59:32.240 --> 59:36.280]  вот поэтому с точки зрения компилятора с точки зрения компилятора вот этот тип существовать
[59:36.280 --> 59:42.120]  то есть массив int-ов размера 0 существовать не может, и поэтому этот шаблон вообще в принципе не
[59:42.120 --> 59:47.680]  будет учитываться в перегрузке при вот этом вызове. А во втором случае я вместо n-ки подставлю
[59:47.680 --> 59:51.960]  двойку, в итоге у меня будет шаблонная функция a с параметром 2, ну и так у меня больше никаких
[59:51.960 --> 59:56.120]  других кандидатов нет, то тут вызовется функция a, которая принимает лонг, то есть вторая версия
[59:56.120 --> 01:00:03.320]  функции. Еще один пример. Представьте себе, что у меня есть снова две шаблонные функции b, одна
[01:00:03.320 --> 01:00:09.720]  принимает int, другая принимает лонг, но при этом первая возвращает t, а вторая возвращает просто t.
[01:00:09.720 --> 01:00:17.360]  Что происходит? Я вызываю функцию b с шаблоном параметром вектор int-ов и передаю ей 0. Значит
[01:00:17.360 --> 01:00:21.280]  тут вместо шаблона параметра t выводится вектор int-ов, тут вместо шаблона параметра t тоже выводится
[01:00:21.280 --> 01:00:29.240]  вектор int-ов, ну и у вектора int-ов, естественно, есть внутренний тип value type. Соответственно,
[01:00:30.000 --> 01:00:35.400]  одновременно две функции, две версии функций b. Когда я передаю туда значение 0, и естественно
[01:00:35.400 --> 01:00:39.160]  перегрузку выигрывает первая функция, потому что 0 — это int, а не лонг, ну соответственно
[01:00:39.160 --> 01:00:44.520]  по точному соответствующему выигрывает именно первая функция. А во втором случае смотрите,
[01:00:44.520 --> 01:00:48.840]  когда я в качестве шаблона параметра t передаю int, то вторая функция инстанцируется нормально,
[01:00:48.840 --> 01:00:52.720]  потому что в качестве типа type просто installs int. А тут в качестве типа type原 first NFM подставляется int
[01:00:52.720 --> 01:00:57.640]  и дальше пишется intHIN value type, но естественно у н neat onionsrovу в Bendake measure нет, поэтому снова Hess
[01:00:57.640 --> 01:01:01.680]  Возникла ошибочная конструкция, и эту версию функции компилятор просто игнорирует.
[01:01:02.440 --> 01:01:07.040]  Поэтому тут при вызове функции bint от нуля будет приниматься в внимание только вторая функция,
[01:01:07.040 --> 01:01:09.040]  но, собственно, ровно она и будет вызываться.
[01:01:13.520 --> 01:01:15.880]  Да, ну и, соответственно, что здесь?
[01:01:16.440 --> 01:01:19.240]  Здесь происходит ровно то же самое.
[01:01:19.240 --> 01:01:23.840]  Если я передаю два консчер звездочки, то тут выводится консчер звездочка,
[01:01:23.840 --> 01:01:27.200]  тут выводится консчер звездочка, но дальше я пишу дегалта под х плюс у.
[01:01:27.640 --> 01:01:32.120]  Но так как два указателя сложить нельзя – QUADrieben, чисто diesized ourselves –
[01:01:32.120 --> 01:01:34.320]  тут возникает ошибочная конструкция.
[01:01:34.960 --> 01:01:40.200]  И, снова, по правилам свминое, так как в результате обстановки шалонового параметра
[01:01:40.200 --> 01:01:41.420]  в overc obviously Ste helper的话 возникла ошибочная конструкция,
[01:01:41.420 --> 01:01:43.440]  первая функция просто нам stronger אךot в Warszаве будет учитываться.
[01:01:43.440 --> 01:01:45.140]  Поэтому будет учитываться только вторая функция,
[01:01:45.140 --> 01:01:46.880]  вместо typo t подставим кончер ё.
[01:01:46.880 --> 01:01:48.680]  Тут вместо typo u подставим кончер ё.
[01:01:48.680 --> 01:01:50.720]  Все, будет вызвана вторая функция.
[01:01:50.720 --> 01:01:53.240]  А если я вызову t от 1 до 2, то все будет ок animals.
[01:01:53.240 --> 01:01:55.380]  Почему? Потому что跟你 typo t и выолнится int.
[01:01:55.380 --> 01:02:00.820]  Сложить 2 int я могу, в результате получится int, то есть получится функция C, которая принимает 2 int и возвращает int.
[01:02:00.820 --> 01:02:06.620]  Вроде как вторая функция тоже подходит, но по правилу наименьше количества подстановок будет выбрана именно первая функция.
[01:02:06.620 --> 01:02:07.620]  Понятно?
[01:02:07.620 --> 01:02:19.020]  То есть этот правил с FinAE говорит о том, что какие из шаблонных функций компилятор будет рассматривать в качестве потенциальных кандидатов на выбор перегрузки.
[01:02:19.020 --> 01:02:31.020]  Что важно понимать, вот как я уже сказал, FinAE это правило, которое относится только к подстановке шаблонов параметров.
[01:02:31.020 --> 01:02:42.020]  И причем это самое главное, FinAE относится только к подстановке шаблонов параметров. При инстанцировании шаблонов FinAE не работает.
[01:02:42.020 --> 01:02:54.020]  То есть если компилятор уже выбрал какую-то перегрузку, я надеюсь, мы с вами помним о том, что компилятор сначала выбирает перегрузку, сначала выбирает, какой шаблон используется, и потом его инстанцирует.
[01:02:54.020 --> 01:03:02.020]  Так вот, если в процессе инстанцирования возникла ошибка, то это уже не FinAE, это уже прям ошибка, это прям ошибка компиляции.
[01:03:02.020 --> 01:03:11.020]  Ну, давайте посмотрим какой-нибудь простой пример, а, ну вот, те же самые примеры, но только я вынес ошибки непосредственно внутри функций.
[01:03:11.020 --> 01:03:17.020]  Смотрите, что тут происходит. У меня есть шаблонная функция A, которая принимает int, есть шаблонная функция A, которая принимает long.
[01:03:17.020 --> 01:03:22.020]  Оба они параметризованы одним и тем же шаблонным параметром. Я вызываю A0, 0.
[01:03:22.020 --> 01:03:29.020]  Смотрите, то есть тут можно подумать следующее, ну смотрите, вот в этой функции происходит создание массива размера 0.
[01:03:29.020 --> 01:03:33.020]  Ну а так, как массивы размера 0 запрещены, то соответственно должна быть выбрана вот эта функция.
[01:03:33.020 --> 01:03:38.020]  Ну вот нифига, потому что, напомню, FinAE работает только при подстановке шаблонных параметров.
[01:03:38.020 --> 01:03:42.020]  А что такое подстановка? Подстановка – это именно анализ сигнатуры функции.
[01:03:42.020 --> 01:03:47.020]  То есть, смотрите, когда я подставляю A0, тут вместо n подставляется 0 и все окей.
[01:03:47.020 --> 01:03:52.020]  Ну, функция нормально, то есть я вместо n подставил 0, функция A возвращает void, принимает int. Все прекрасно.
[01:03:52.020 --> 01:04:00.020]  Дальше, сюда подставляю 0, значит шаблонная функция в качестве шаблона параметра принимает 0, возвращает void и принимает в качестве типа long.
[01:04:01.020 --> 01:04:09.020]  Дальше, я среди этих функций выбираю ту, которую сможет принять 0, но 0 может принимать первая функция, потому что там точная соответствия.
[01:04:09.020 --> 01:04:14.020]  И только после того, как я выбрал эту функцию, то компилятор уже определился, компилятор выбрал первую функцию.
[01:04:14.020 --> 01:04:20.020]  Вот, компилятор выбрал первую функцию и начинает ее инстансировать, начинает генерировать из нее код,
[01:04:20.020 --> 01:04:23.020]  но в процессе генерации кода у него возникла ошибка, все, это ошибка компиляции.
[01:04:23.020 --> 01:04:30.020]  Даша, говорите, ой, что-то у меня там не получилось ее инстанцировать, давай-ка я выберу другую функцию. Нет, все, комплинатор сначала выбрал функцию и потом ее инстанцирует.
[01:04:30.020 --> 01:04:35.020]  Если в процессе инстанцирования произошла проблема, то все, это уже ваши проблемы. Да.
[01:04:35.020 --> 01:04:40.020]  Если у нас сейчас инстанцирование где-нибудь происходит в другом файле, в общем?
[01:04:40.020 --> 01:04:43.020]  Ну, то же самое.
[01:04:43.020 --> 01:04:50.020]  Комплинатор, смотрите, когда вы вызываете функцию, там, не важно, шаблоны и шаблоны, ему же сначала нужно понять, что это за функция, какую версию выбрать.
[01:04:50.020 --> 01:04:55.020]  И по ссылке шаблонов параметров, она как раз отвечает моменту выбора перегрузки.
[01:04:55.020 --> 01:05:01.020]  То есть, FNAIR работает в момент, когда комплинатор пытается понять, а какую функцию ему вызвать.
[01:05:01.020 --> 01:05:07.020]  Ну, естественно, тело функции вообще никак не может повлиять на то, какая функция будет выбрана.
[01:05:07.020 --> 01:05:11.020]  Ну и все остальные примеры ровно те же самые.
[01:05:11.020 --> 01:05:18.020]  Напомню, что в втором примере у меня VLUType встречался в возвращаемом значении, тут я VLUType вынес внутрь функции B.
[01:05:18.020 --> 01:05:24.020]  И, естественно, вот этот внутренний VLUType никак не будет влиять на SFINAE, потому что реализация функции на SFINAE никак не влияет.
[01:05:24.020 --> 01:05:28.020]  На SFINAE влияют только принимаемые параметры и возвращаемые значения.
[01:05:28.020 --> 01:05:34.020]  Ну и, собственно, для чего нужно SFINAE?
[01:05:34.020 --> 01:05:40.020]  На самом деле правило SFINAE нужно было как раз какие-то для того, чтобы было приятно программировать,
[01:05:40.020 --> 01:05:46.020]  чтобы комплинатор не выдавал ошибки, если у вас есть несколько шаблонов кандидатов,
[01:05:46.020 --> 01:05:50.020]  и вдруг в каком-то шаблон кандидата возникла проблема, чтобы вам было приятнее.
[01:05:50.020 --> 01:05:56.020]  Грубо говоря, комплинатор просто не обращал на это внимания и вызвал ровно ту функцию, которую вызвать можно.
[01:05:56.020 --> 01:06:06.020]  В общем, внезапно в какой-то момент разработчики на C++ выяснили, что с помощью SFINAE можно метапрограммировать.
[01:06:06.020 --> 01:06:12.020]  С помощью SFINAE, с помощью правил SFINAE, можно писать различные другие крутые штуки,
[01:06:12.020 --> 01:06:18.020]  которые нельзя сделать с помощью тех вещей, которые мы делали до этого, кроме определительных типов, модификаторов.
[01:06:18.020 --> 01:06:23.020]  С помощью SFINAE можно делать много всяких других классных вещей, например, в частности, узнавать,
[01:06:23.020 --> 01:06:29.020]  а есть ли у этого типа метод F, есть ли у этого типа перемещающее присваивание и так далее.
[01:06:29.020 --> 01:06:33.020]  Об этом, видимо, уже поговорим в следующий раз.
[01:06:33.020 --> 01:06:35.020]  На сегодня все.
