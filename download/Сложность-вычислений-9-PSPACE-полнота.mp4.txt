[00:00.000 --> 00:10.540]  значит
[00:13.660 --> 00:18.840]  канал вот дальше
[00:30.000 --> 00:48.000]  Доказательство, то же самое, что и Endless Pace, поговорим вообще про разные власти, связанные с памятью.
[00:48.000 --> 01:00.000]  Ну и вот есть истина для телевизорных инструментов анализа.
[01:00.000 --> 01:05.000]  Слушайте задачу, это изучение того и ваше, а не полного, в одном классе.
[01:05.000 --> 01:13.000]  Ну и в некотором смысле любая задача в одном классе была в любой суть этого класса.
[01:13.000 --> 01:18.000]  То есть можно ее терпенно сформулировать в любой другую задачу в этом классе.
[01:18.000 --> 01:24.000]  Вот мы и много говорим про F-полную задачу, а точно говорим про PSP-полную задачу.
[01:24.000 --> 01:26.000]  Ну определение точно такое же.
[01:26.000 --> 01:42.000]  Значит, там B является PSP-полной, если B сама лежит в PSP,
[01:42.000 --> 01:56.000]  и для любого A из PSP верно, что A сводится к B, причем сводимость та же самая.
[01:56.000 --> 02:06.000]  Да, значит, иногда может показаться, что раз у нас тут память, то и сводимость должна быть полинамеральной по памяти.
[02:06.000 --> 02:12.000]  Но это не интересно, было бы, потому что полинамерально по памяти там все друг другу сводится.
[02:12.000 --> 02:18.000]  Точно так же, как внутри P, все друг другу сводится полинамерально по времени.
[02:18.000 --> 02:29.000]  На этом вообще нас тут интересует вопрос, равны ли P и PSP?
[02:29.000 --> 02:39.000]  Даже этот вопрос открыт, не только равны ли P и NP, не только равны ли P и полинамеральная иерархия, но и даже равно ли P и PSP?
[02:39.000 --> 02:42.000]  Это тоже открытый вопрос.
[02:42.000 --> 02:49.000]  Ну и соответственно, чтобы его изучать, можно изучать полные задачи в большем классе,
[02:49.000 --> 02:53.000]  но они как бы будут полны относительно сводимости из меньшего класса.
[02:53.000 --> 02:58.000]  То есть в данном случае относительно полинамеральной сводимости, обычной по карпу.
[02:58.000 --> 03:01.000]  Так, хорошо.
[03:01.000 --> 03:07.000]  Ну а дальше может быть такой генерический PSP-исполненный язык.
[03:07.000 --> 03:22.000]  Генерический PSP-исполненный язык.
[03:22.000 --> 03:35.000]  Ну можно его называть Space TM SAT.
[03:35.000 --> 03:40.000]  Ну и он очень похож на генерический NP полный язык.
[03:40.000 --> 03:45.000]  То есть тут мы более-менее спрашиваем.
[03:45.000 --> 03:52.000]  Спрашиваем именно про тройку, уже нет никакого Y, потому что в определении PSP-ис нет никакого Y.
[03:52.000 --> 04:01.000]  Значит, а тут тройка из M входа X.
[04:01.000 --> 04:05.000]  Значит, и S лунарной записи.
[04:05.000 --> 04:12.000]  Ну, тут, в общем, неважно, можно как я сейчас напишу, можно просто там S записывать.
[04:12.000 --> 04:24.000]  Значит, тройка из M, X и S единиц.
[04:24.000 --> 04:28.000]  А, да нет, даже можно, прям так и нужно.
[04:28.000 --> 04:32.000]  Значит, что M от X.
[04:32.000 --> 04:35.000]  M от X равно единице.
[04:35.000 --> 04:44.000]  И использует не больше, чем S ячеек памяти.
[04:44.000 --> 04:54.000]  Да, тут нужно именно в лунарной записи, чтобы сам этот язык лежал в PSP-ис.
[04:54.000 --> 04:56.000]  Ну, почему он лежит в PSP-ис?
[04:56.000 --> 05:00.000]  Ну, потому что нужно учиться вот это вот проверять.
[05:00.000 --> 05:06.000]  А как мы это будем проверять?
[05:06.000 --> 05:13.000]  Ну, более-менее запускаем универсальную машину тюринга M от X.
[05:13.000 --> 05:16.000]  И выделяем ей место S.
[05:16.000 --> 05:22.000]  Если она вышла за пределы отведенного места, то тогда мы говорим нет.
[05:22.000 --> 05:27.000]  Если она остановилась и выдала единицу, тогда мы говорим нет.
[05:27.000 --> 05:32.000]  Если она остановилась и выдала ноль...
[05:32.000 --> 05:36.000]  Ой, подождите, если единицу говорим да, не выходя за пределы.
[05:36.000 --> 05:38.000]  Значит, если ноль, то говорим нет.
[05:38.000 --> 05:42.000]  Но еще может быть ситуация, когда она зациклится.
[05:42.000 --> 05:48.000]  Да, то есть тут...
[05:48.000 --> 05:53.000]  Да, я сейчас запишу, значит, почему он принадлежит PSP-ис.
[05:53.000 --> 06:07.000]  Значит, ну, получается, что запускаем M от X на памяти S.
[06:07.000 --> 06:27.000]  Теперь получается, если вышла за пределы S, то, соответственно, вернем ноль.
[06:27.000 --> 06:35.000]  Если остановилась, то тогда вернем ее ответ.
[06:35.000 --> 06:39.000]  Если остановилась и выдала единицу, тогда нужно единицу.
[06:39.000 --> 06:49.000]  Если остановилась и выдала ноль, вернем ее ответ.
[06:49.000 --> 06:54.000]  Но еще есть третий вариант, что она зациклилась.
[06:54.000 --> 07:01.000]  Тогда, конечно, тоже нужно выдавать...
[07:01.000 --> 07:05.000]  Конечно, если она зациклилась, то тоже нужно возвращать ноль.
[07:05.000 --> 07:10.000]  Но возникает вопрос, а как проверять зацикливание?
[07:10.000 --> 07:17.000]  Потому что мы не можем, например, записывать все возможные конфигурации, которые были.
[07:17.000 --> 07:23.000]  Что значит зациклилась? Значит, повторилась конфигурация.
[07:23.000 --> 07:29.000]  Но мы не можем, например, записывать все возможные конфигурации, их хранить и каждую новую сравнивать с теми, которые уже были.
[07:29.000 --> 07:37.000]  Для этого нужно будет слишком много шагов, слишком много, точнее, памяти, чтобы их все хранить.
[07:37.000 --> 07:42.000]  Вместо этого мы будем их не хранить, а только считать, то есть будем считать шаги.
[07:42.000 --> 08:00.000]  И тогда дело в том, что на фиксированной зоне может быть только ограниченное число, причем экспоненты ограниченное, число конфигураций.
[08:00.000 --> 08:07.000]  Потому что на съезд ячеев в каждой из них может быть любой из символов алфавита, это экспоненциальное количество,
[08:07.000 --> 08:17.000]  ну и умножить на еще немножко, умножить на состояние, это константа на число положений возможных указателей, это еще какой-то логарифм.
[08:17.000 --> 08:22.000]  Да, в общем, самое главное, что есть экспоненциальное число слов, которые можно написать.
[08:23.000 --> 08:34.000]  Вот, значит, есть экспоненциальное число слов.
[08:34.000 --> 08:52.000]  Ну, значит, есть экспоненциальное число слов, как следствие, есть экспоненциальное число конфигураций.
[08:52.000 --> 08:57.000]  И получается, что можно максимум экспоненциальное число шагов сделать, прежде чем остановиться.
[08:57.000 --> 09:03.000]  Иначе, по принципу Дерехле, там какая-то конфигурация повторится, и дальше будет происходить движение по кругу.
[09:03.000 --> 09:15.000]  Поэтому достаточно просто считать шаги и контролировать, что их число не превысит экспоненту, а для этого нужно еще порядка S ячеек.
[09:16.000 --> 09:40.000]  Соответственно, контролируем зацикливание, просто считая шаги машины и проверяя,
[09:40.000 --> 09:59.000]  что их не больше, не больше, чем конфигурации.
[09:59.000 --> 10:13.000]  Вот, ну и для этого нужно еще порядка S памяти.
[10:13.000 --> 10:26.000]  Это потребует то большое от S памяти, ну и таким образом общая память будет линейна, ну и, как следствие, пальномиальна.
[10:26.000 --> 10:35.000]  Так, хорошо, это первая часть, ну а вторая часть, почему PSPACE трудная, это более-менее очевидно.
[10:35.000 --> 11:00.000]  Значит, PSPACE трудная, получается, что если A лежит в PSPACE, и распознается машиной M на памяти какой-то S,
[11:00.000 --> 11:21.000]  ну, S от N я, давайте, напишу, где н длина х, тогда получается, что сводимость будет просто, что х превращается в тройку
[11:21.000 --> 11:34.000]  из M, х и единица, повторенная S от длины х, а раз.
[11:34.000 --> 11:41.000]  Ну и тогда как раз х лежит в A, тогда это только тогда, когда M от х равно единице,
[11:41.000 --> 11:53.000]  когда M от х работает на такой памяти, а это ровно то же, что вот про эту тройку написано в определении, соответственно, SPACE TEM SAT.
[11:53.000 --> 12:00.000]  Поэтому любой A сводится к нашему генерическому.
[12:00.000 --> 12:04.000]  Так, ну чего, понятно?
[12:04.000 --> 12:14.000]  Ну это как обычно, значит, если вообще в классе какой-то полный язык есть, то тогда в том числе такой будет полным.
[12:14.000 --> 12:26.000]  И соответственно, как раз вот трудность более-менее всегда одинаково делается, а вот принадлежит тому же классу не всегда верна вообще.
[12:26.000 --> 12:38.000]  Именно с этим связаны примеры, когда полных языков вообще нет.
[12:38.000 --> 12:50.000]  Так, ну дальше вот это вот формально верно, но как с этим работать, совершенно непонятно.
[12:50.000 --> 13:11.000]  И можно переформулировать, значит, можно переформулировать в задачу достижимости графа, достижимости вершин в графе.
[13:11.000 --> 13:26.000]  Мы в прошлый раз говорили про конфигурационный граф, про пути в нем, про то, что можно решать на какой-то совсем маленькой памяти.
[13:26.000 --> 13:32.000]  Вот, и это соответственно можно обобщить.
[13:32.000 --> 13:38.000]  Задачу поставить так.
[13:38.000 --> 13:50.000]  Так, ну тут, например, есть какое-то описание.
[13:50.000 --> 14:02.000]  Ну давайте это как-то phi обозначим, описание, значит, s и t.
[14:02.000 --> 14:29.000]  В графе g-phi есть, в or-графе можно писать, значит, в ориентированном графе g-phi есть путь из s в t.
[14:29.000 --> 14:44.000]  Что имеется в виду? Что имеется в виду, что размер этого графа 2 в степени n вершин.
[14:44.000 --> 15:02.000]  То есть в графе g-phi есть 2 в степени n вершин.
[15:02.000 --> 15:11.000]  В графе g-phi есть 2 в степени n вершин, а ребра задаются как раз вот описанием phi.
[15:11.000 --> 15:27.000]  g-phi это строка длины полинома от n.
[15:27.000 --> 15:55.000]  Ну дальше, значит, по phi и паре из двух вершин у и в, значит, можно проверить за полиномиальное время.
[15:55.000 --> 16:09.000]  Верно ли, верно ли, что пара у и в лежит в е.
[16:09.000 --> 16:21.000]  То есть phi это какое-то такое очень сжатое, значит, саксинкс это сжатое, то есть очень плотно заархивированная информация про граф.
[16:21.000 --> 16:39.000]  У совместного графа есть какое-то короткое описание, но при этом оно, хотя и короткое, может быть таким довольно неочевидным.
[16:39.000 --> 16:49.000]  Ну, грубо говоря, очевидно, когда я говорю, что там вершину и и g соединяю с и плюс 1 g, и и g плюс 1 и что-нибудь еще.
[16:49.000 --> 17:02.000]  Да, это тоже будет очень короткое описание, но в таком графе там не будет особой проблемы понять, есть путь или нет.
[17:02.000 --> 17:16.000]  В общем случае, phi какое-то такое неочевидное описание, так что не сразу можно понять что-то про этот граф, но при этом короткое.
[17:16.000 --> 17:36.000]  Вот. Ну и тогда получается, что, соответственно, такая штука лежит в PSPACE, оно лично тому, как мы в прошлый раз с Терем Саевича доказывали.
[17:36.000 --> 17:50.000]  Значит, тут лежит PSPACE. Опять же получается рекурсивный алгоритм, рекурсивный алгоритм.
[17:50.000 --> 18:17.000]  Да, то есть тут можно писать там reach от x, y, от x, y и k. Значит, это есть ли путь, есть ли путь из x в y длины не больше, чем 2 в степени k.
[18:17.000 --> 18:38.000]  Соответственно, если k равно 0, это означает, что x равно y, или есть ребро, или x, y лежит в е.
[18:38.000 --> 18:48.000]  Значит, и соответственно вот это вот, ну первое можно просто непосредственно проверить, а второе можно проверить исходя из phi.
[18:48.000 --> 19:12.000]  То есть вот это вот проверяется исходя из phi. Вот. Ну а дальше, соответственно, рекурсия reach от x, y, k плюс 1.
[19:12.000 --> 19:40.000]  Это будет disjunction по всем z, значит того, что reach от x, z, k и reach от z, y, k.
[19:40.000 --> 19:52.000]  Вот. Ну и соответственно, глубина рекурсии будет как логарифм длины максимального пути.
[19:52.000 --> 19:59.000]  Логарифм максимальной длины пути. Максимальная длина пути не больше, чем число вершин в графе, то есть не больше, чем 2 в степени n.
[19:59.000 --> 20:06.000]  То есть будет n этапов рекурсии, на каждом этапе добавляется перебор вот этого z.
[20:06.000 --> 20:10.000]  А z это еще n, потому что z это индекс вершин в графе.
[20:10.000 --> 20:18.000]  Ну и всего порядка n в квадрате памяти нужно будет, чтобы этот рекурсивный алгоритм весь провернуть.
[20:18.000 --> 20:27.000]  Вот. Поэтому какие бы ни были детали того, как именно phi задает граф, если это можно вычислить за полиномиальное время,
[20:27.000 --> 20:37.000]  то, соответственно, в принципе даже можно здесь потребовать, чтобы на полиномиальной памяти только это определялось.
[20:37.000 --> 20:42.000]  Да, все равно это полиномиальная память, она еще добавится к этому всему.
[20:42.000 --> 20:45.000]  И будет в итоге тоже полиномиальная память.
[20:45.000 --> 20:53.000]  Но как правило, это какие-то описания простые, типа phi там описывает машину тюринга или какую-нибудь схему логическую,
[20:53.000 --> 21:02.000]  или еще что-нибудь такое. Вот. Про схему мы еще поговорим через пару лекций.
[21:02.000 --> 21:12.000]  Так, хорошо. Значит, это вот он так лежит в PSPACE, потому что можно рекурсивный алгоритм сделать.
[21:12.000 --> 21:16.000]  Ну, а PSPACE-трудность...
[21:16.000 --> 21:32.000]  Значит, PSPACE-трудность происходит из того, что можно считать, что граф конфигурационный,
[21:32.000 --> 21:52.000]  g-phi это конфигурационный граф машины m на входе x.
[21:52.000 --> 22:14.000]  Ну, а со само phi это просто сама машина m вместе со входом x.
[22:22.000 --> 22:44.000]  Вот. Ну и понятно, что если у нас есть x, то мы его как бы подставляем вот в это описание.
[22:44.000 --> 22:52.000]  Ну и получается, что тут как бы в phi еще нужно добавить описание алгоритма.
[22:52.000 --> 22:59.000]  Ну, можно считать, что phi это такой самораспаковывающийся архив для графа.
[22:59.000 --> 23:05.000]  У нас, соответственно, в phi есть и программа, которая нужна, чтобы любой...
[23:05.000 --> 23:11.000]  И он как бы такой локально самораспаковывающийся, то есть можно по тексту архива,
[23:11.000 --> 23:18.000]  не обязательно прям весь файл генерировать, можно как конкретный кусок файла.
[23:18.000 --> 23:22.000]  То есть это как бы такой самораспаковывающийся архив с параметром.
[23:22.000 --> 23:30.000]  То есть в него можно попросить, что написано там в файле с такого-то байта по такой-то байту.
[23:30.000 --> 23:36.000]  И он вернет только вот эту часть архива, не генерируя все вместе.
[23:36.000 --> 23:44.000]  Как бы такой локально самораспаковывающийся архив. Вот что такое это phi.
[23:44.000 --> 23:50.000]  Получается, что вообще результат очень длинный, но можно любой кусочек,
[23:50.000 --> 23:56.000]  может любой кусочек сгенерировать по вот этой программе и запросить, что это за кусочек.
[23:57.000 --> 24:01.000]  Вот.
[24:01.000 --> 24:07.000]  Ну вот, соответственно, phi это вот инструкция, что делать с описанием машины и входа,
[24:07.000 --> 24:15.000]  что нужно... там же еще ув на вход подается, ув это две конфигурации.
[24:15.000 --> 24:19.000]  И инструкция заключается в том, что нужно по этим двум конфигурациям
[24:19.000 --> 24:27.000]  и команда машины M, и входу X понять, есть ли переход из первой конфигурации во вторую.
[24:27.000 --> 24:30.000]  Вот это вот то, что нам нужно понимать.
[24:30.000 --> 24:37.000]  Ну и понятно, что это довольно стандартными методами делается.
[24:40.000 --> 24:43.000]  Так, ну ничего, понятно.
[24:43.000 --> 24:47.000]  Так, хорошо.
[24:55.000 --> 24:57.000]  Хорошо, значит, вот это...
[24:57.000 --> 25:01.000]  Но тем не менее, это такая еще довольно общая задача.
[25:01.000 --> 25:05.000]  И можно сказать, что вот здесь мы просто формально записали,
[25:05.000 --> 25:09.000]  значит, здесь мы формально записали, как бы, что мы вообще делаем в PSPACE.
[25:09.000 --> 25:15.000]  Соответственно, здесь мы это чуть-чуть отошли от записи чисто через машины,
[25:15.000 --> 25:17.000]  но все равно, что нам нужно...
[25:17.000 --> 25:19.000]  А, нам же еще что нужно?
[25:19.000 --> 25:20.000]  Нам еще S и T нужно.
[25:20.000 --> 25:22.000]  Вот это я забыл.
[25:22.000 --> 25:26.000]  Да, но это понятно, если это начальная конфигурация,
[25:26.000 --> 25:30.000]  значит, S это начальная конфигурация,
[25:30.000 --> 25:34.000]  а T это принимающая конфигурация.
[25:40.000 --> 25:44.000]  Ну и чтобы это была только одна принимающая конфигурация,
[25:44.000 --> 25:48.000]  можно добавить какую-то виртуальную принимающую конфигурацию
[25:48.000 --> 25:52.000]  и ребро из каждой обычной принимающей, где просто T не принимающая,
[25:52.000 --> 25:56.000]  вот в эту виртуальную.
[25:56.000 --> 26:00.000]  Да, и соответственно, получается вопрос,
[26:00.000 --> 26:04.000]  можно добраться из начальной позиции в принимающую,
[26:04.000 --> 26:08.000]  действуя каждый раз в соответствии с программой.
[26:08.000 --> 26:12.000]  Но это и есть вопрос о том, вернет ли программа единицу.
[26:12.000 --> 26:16.000]  То же самое, что у нас там было.
[26:16.000 --> 26:20.000]  Ну вот, значит, все-таки это еще недалеко отошло.
[26:20.000 --> 26:23.000]  И дальше, как мы уже говорили,
[26:23.000 --> 26:27.000]  в НП полных задачах была выделенная задача у выполнимости,
[26:27.000 --> 26:31.000]  значит, ко НП полных была выделена задача у тавтологичности,
[26:31.000 --> 26:35.000]  на уровнях полиновальной иерархии были тоже выделенные задачи
[26:35.000 --> 26:39.000]  с чередованием кванторов.
[26:39.000 --> 26:43.000]  Вот здесь тоже есть аналогичная задача,
[26:43.000 --> 26:47.000]  называется TQBF.
[26:47.000 --> 26:51.000]  TQBF, расшифрованная,
[26:51.000 --> 26:57.000]  TQBF расшифровывается как totally quantified Boolean formula,
[26:57.000 --> 27:03.000]  то есть Boolean formula, в которой поставлены кванторы по всем переменам.
[27:03.000 --> 27:07.000]  Соответственно, язык формулируется как множество таких phi,
[27:07.000 --> 27:11.000]  что там существует x1 для любого x2,
[27:11.000 --> 27:15.000]  существует x3 и так далее.
[27:15.000 --> 27:19.000]  И здесь, соответственно, phi от x1, x2, x3,
[27:19.000 --> 27:23.000]  и так далее.
[27:37.000 --> 27:41.000]  Здесь, в отличие от полиновальной иерархии,
[27:41.000 --> 27:45.000]  где нам явно нужно было указывать, что x это не отдельные переменные,
[27:45.000 --> 27:48.000]  какие-то целые блоки переменных,
[27:48.000 --> 27:52.000]  здесь, в принципе, может быть так, что x и y отдельные переменные,
[27:52.000 --> 27:56.000]  потому что здесь не ограничено количество кванторов.
[27:56.000 --> 28:00.000]  Если у нас подряд одни и те же кванторы стоят, мы их можем искусно разбавить
[28:00.000 --> 28:04.000]  другими кванторами, так чтобы они чередовались строго по одной переменной.
[28:04.000 --> 28:08.000]  Ну ладно, здесь тогда сделаем перерыв.
[28:12.000 --> 28:16.000]  Значит, вот эта задача, TQBF.
[28:16.000 --> 28:20.000]  Значит, ну во-первых,
[28:20.000 --> 28:24.000]  как обычно,
[28:24.000 --> 28:28.000]  доказывая, что она PSPACE полная, нужно вначале
[28:28.000 --> 28:32.000]  доказать, что она лежит в PSPACE.
[28:32.000 --> 28:36.000]  Ну и это, в общем, делается точно так же
[28:36.000 --> 28:40.000]  рекурсивно.
[28:46.000 --> 28:50.000]  Значит, то есть рекурсия получается, что
[28:50.000 --> 28:54.000]  x1 равно 0.
[28:58.000 --> 29:02.000]  Потом считаем то, что
[29:02.000 --> 29:06.000]  начинается со второго квантора.
[29:10.000 --> 29:14.000]  Ну и, соответственно, потом x1 равно 1.
[29:14.000 --> 29:18.000]  Ну и берем disjunction.
[29:18.000 --> 29:22.000]  А тут, соответственно, получаем, что x2 равно 0.
[29:22.000 --> 29:26.000]  И, соответственно, считаем, что существует x3 там
[29:26.000 --> 29:30.000]  для любого x4 и так далее.
[29:30.000 --> 29:34.000]  То, что осталось x2 равно 1.
[29:34.000 --> 29:38.000]  И беремся, соответственно, конъюнкцию.
[29:38.000 --> 29:42.000]  Ну и так далее. Значит, соответственно, так вот идем, идем, идем, идем.
[29:42.000 --> 29:46.000]  И как раз глубина получается такая же, как тут число переменных.
[29:46.000 --> 29:50.000]  Ну а переменных в формуле не больше, чем ее длина.
[29:50.000 --> 29:54.000]  То есть вот получается как раз
[29:54.000 --> 29:58.000]  полиномиальная глубина рекурсии.
[29:58.000 --> 30:02.000]  Ну а тут на каждом уровне мы просто один бит храним,
[30:02.000 --> 30:06.000]  поэтому всего полиномиальное число битов для рекурсии.
[30:06.000 --> 30:10.000]  Ну и в самом конце нужно будет просто вычислить функцию phi
[30:10.000 --> 30:14.000]  и вычислить х. Ну и это тоже
[30:14.000 --> 30:18.000]  какая-то несложная операция.
[30:18.000 --> 30:22.000]  Просто по таблицистинности просто делать.
[30:22.000 --> 30:26.000]  Тоже будет порядка полиномиальной памяти.
[30:26.000 --> 30:30.000]  Ну ничего, понятно.
[30:30.000 --> 30:34.000]  Вообще это типичная ситуация, что язык лежит в PSPACE,
[30:34.000 --> 30:38.000]  если он вычисляется каким-то рекурсивным образом.
[30:38.000 --> 30:42.000]  Ну и дальше
[30:42.000 --> 30:46.000]  PSPACE полнота.
[30:52.000 --> 30:56.000]  Ну PSPACE трудность получается.
[31:00.000 --> 31:04.000]  PSPACE трудность получается
[31:04.000 --> 31:08.000]  аналогично, в общем, по похожим образом
[31:08.000 --> 31:12.000]  на то, что у нас было
[31:16.000 --> 31:20.000]  сейчас, по похожим образом на то, что у нас было в Теремисевиче в прошлый раз.
[31:20.000 --> 31:24.000]  Вот, но еще там
[31:24.000 --> 31:28.000]  один компонент нужен.
[31:28.000 --> 31:32.000]  Во-первых, тут общая идея, что там все свойства можем выражать
[31:32.000 --> 31:36.000]  вот я буду пользоваться теми же обозначениями
[31:36.000 --> 31:40.000]  с достижимостью. То есть там reach
[31:40.000 --> 31:44.000]  reach от x и y1
[31:44.000 --> 31:48.000]  значит reach от x и y1
[31:48.000 --> 31:52.000]  можно записать
[31:56.000 --> 32:00.000]  записать формулой
[32:00.000 --> 32:04.000]  ну, от какого-то константного
[32:04.000 --> 32:08.000]  от константного числа переменных.
[32:12.000 --> 32:16.000]  То есть у нас вот там
[32:16.000 --> 32:20.000]  конфигурация описывает с каким-то числом переменных
[32:20.000 --> 32:24.000]  а, сейчас, не, подожди, не от константного все-таки.
[32:24.000 --> 32:28.000]  Нет, это я глупости написал. Нет, не от константного, но от пальномиального.
[32:28.000 --> 32:32.000]  Да, или даже от линейного.
[32:42.000 --> 32:46.000]  От пальномиального, но важно, что тут как бы уже никаких кванторов не будет.
[32:46.000 --> 32:50.000]  Просто значение x-ов фиксировано, значение y-ов фиксировано и просто
[32:50.000 --> 32:54.000]  какая-то вот между ними связь.
[32:54.000 --> 32:58.000]  Вот, хорошо. Значит, дальше
[32:58.000 --> 33:02.000]  в принципе получается
[33:02.000 --> 33:06.000]  да, вот это вот disjunction можно заменить на квантуру существования
[33:06.000 --> 33:10.000]  да, это стандартная операция
[33:10.000 --> 33:14.000]  reach
[33:14.000 --> 33:18.000]  от x и y и k плюс 1
[33:18.000 --> 33:22.000]  да, значит, можно написать так, это тогда будет равносильно
[33:22.000 --> 33:26.000]  к тому, что существует z
[33:26.000 --> 33:30.000]  такое, что reach
[33:30.000 --> 33:34.000]  от x и z, k
[33:34.000 --> 33:38.000]  и reach
[33:38.000 --> 33:42.000]  от z, y, k
[33:46.000 --> 33:50.000]  Вот, так тоже можно писать, но если это
[33:50.000 --> 33:54.000]  не инструкция по вычислению, если это прямо формула
[33:54.000 --> 33:58.000]  то при такой записи возникает проблема, что
[33:58.000 --> 34:02.000]  у нас как бы вот эта вот формула два раза повторяется
[34:02.000 --> 34:06.000]  и соответственно длина возрастает вдвое и еще плюс немножко
[34:06.000 --> 34:10.000]  Да, значит, соответственно тут получается проблема
[34:10.000 --> 34:14.000]  что длина
[34:14.000 --> 34:18.000]  возрастает вдвое
[34:20.000 --> 34:24.000]  А, знаете, что вот здесь было важно, что, конечно, формула
[34:24.000 --> 34:28.000]  от полинарных числа переменных, но еще и сама формула полинарной длины
[34:28.000 --> 34:32.000]  И вот здесь уже нужна специфика того, что это именно изменение
[34:32.000 --> 34:36.000]  в машине тюринга небольшое
[34:36.000 --> 34:40.000]  Да, значит, тут важно, что сама формула
[34:40.000 --> 34:44.000]  тоже полинарной длины
[34:44.000 --> 34:48.000]  Да, и тоже, конечно, не любая функция выражается формулой полинарной длины
[34:48.000 --> 34:52.000]  от n-переменных, но в данном случае выражается
[34:52.000 --> 34:56.000]  потому что это как раз
[34:56.000 --> 35:00.000]  достижимость в графе, значит, одно ребро в графе
[35:00.000 --> 35:04.000]  и это, более того, не просто ребро в графе, а это шаг машины тюринга
[35:04.000 --> 35:08.000]  Шаг машины тюринга заключается в том, что
[35:08.000 --> 35:12.000]  почти везде ничего не меняется, и это очень
[35:12.000 --> 35:16.000]  простая формула, что вот этот бит не изменяется, этот бит не изменяется
[35:16.000 --> 35:20.000]  и так далее
[35:20.000 --> 35:24.000]  И только там, где стоит указатель, там что-то меняется
[35:24.000 --> 35:28.000]  и вот там-то как раз можно прямую просто таблицу ясности записать
[35:28.000 --> 35:32.000]  В небольшой окрестности меняется по задней таблице
[35:32.000 --> 35:36.000]  а все остальное не меняется
[35:36.000 --> 35:40.000]  Но, конечно, какой именно окрест меняется тоже не фиксировано
[35:40.000 --> 35:44.000]  но это тоже по полинарничеству вариантов
[35:44.000 --> 35:48.000]  В зависимости от того, где стоит указатель
[35:48.000 --> 35:52.000]  Если тут указатель, то тут меняется остальное на месте, если тут, то тут
[35:52.000 --> 35:56.000]  И там тоже полинарничество вариантов, и в каждом полинарничество равенств
[35:56.000 --> 36:00.000]  и еще небольшое для константа
[36:00.000 --> 36:04.000]  переменных уже просто произвольная функция
[36:04.000 --> 36:08.000]  Но все вместе это будет по полинарной длине формулы
[36:08.000 --> 36:12.000]  Так
[36:12.000 --> 36:16.000]  Так, ну хорошо, что же делать?
[36:24.000 --> 36:28.000]  Что же делать вот здесь вот?
[36:32.000 --> 36:36.000]  Ну, там некоторый трюк, который, может быть
[36:36.000 --> 36:40.000]  некоторые из вас помнят из курса логики
[36:42.000 --> 36:46.000]  А именно, когда мы там проходили
[36:46.000 --> 36:50.000]  очень короткие формулы, которые выражают какое-нибудь свойство
[36:50.000 --> 36:54.000]  там такой же трюк использовался
[37:06.000 --> 37:10.000]  Так, и трюк выглядит следующим образом
[37:12.000 --> 37:16.000]  Так, значит, я продолжаю равносильность
[37:24.000 --> 37:28.000]  Существует Z для любого U, для любого V
[37:28.000 --> 37:32.000]  Значит, если
[37:32.000 --> 37:36.000]  х равно U и
[37:36.000 --> 37:40.000]  наоборот, ну, то есть, неважно, да, но логичнее
[37:40.000 --> 37:44.000]  наоборот, U равно х и V равно Z
[37:48.000 --> 37:52.000]  или U равно Z и V равно
[37:52.000 --> 37:56.000]  Y, то тогда
[37:56.000 --> 38:00.000]  reach от U, V, K
[38:02.000 --> 38:06.000]  Вот, вот такая вот формула
[38:06.000 --> 38:10.000]  То есть, для любой пары, если эта пара, это вот эта пара
[38:10.000 --> 38:14.000]  или эта пара, это вот эта пара, то тогда
[38:14.000 --> 38:18.000]  соответственно от первого элемента пары
[38:18.000 --> 38:22.000]  до второго можно добраться за K
[38:22.000 --> 38:26.000]  шагов
[38:26.000 --> 38:30.000]  Вот, и вот тут уже мы получаем преимущество
[38:30.000 --> 38:34.000]  в том, что мы только один раз recursive формулу записываем
[38:34.000 --> 38:38.000]  Да, и вместо того, чтобы увеличивать в двое длину как происходило здесь
[38:38.000 --> 38:42.000]  мы ее увеличиваем на константу значит, на вот это вот
[38:42.000 --> 38:46.000]  значит, на вот эту вот константу формула увеличивается
[38:46.000 --> 38:50.000]  Но тогда если мы этот полинимационное число раз сделаем...
[38:50.000 --> 38:54.000]  если мы этот полинимационное число раз удвоили, то у нас получится эксп Reynolds длина
[38:54.000 --> 38:58.000]  А если мы вылечили полинимационное число раз на константу, то получится полинимиальная длина
[38:58.000 --> 39:12.000]  Ну вот. Ну и еще, соответственно, чтобы получилось так, как здесь написано, нужно еще привести к предваренно нормальной форме.
[39:12.000 --> 39:19.000]  То есть, если вот этому уже заменена форма с кванторами, то кванторы отсюда надо вынести сюда.
[39:20.000 --> 39:37.000]  Вот. Соответственно, вынесу все кванторы в начало.
[39:38.000 --> 39:55.000]  Значит, получим постановку, постановку TQBF.
[39:55.000 --> 40:13.000]  Вот. Поэтому это сводится, да, свели вопрос удостижимости, значит, к вопросу, соответственно, вот этой формуле с кванторами.
[40:13.000 --> 40:25.000]  Так, хорошо. Как еще можно посмотреть на вот такую цепочку с переменой кванторов? Да, может быть, поэтому вам расскажут какие-нибудь вопросы есть.
[40:25.000 --> 40:44.000]  Конечно. Ну, можем, можем, да. То есть, тут получается вот эти кванторы, да, это не по отдельным переменам, а по группам переменам, которые описывают вершину в графе.
[40:44.000 --> 40:49.000]  Ну, соответственно, можем перебирать, да, значит, на главную форму написать.
[40:49.000 --> 41:01.000]  А если мы требуем, чтобы были отдельные переменные, то мы еще добавляем фиктивные кванторы по фиктивным переменным, которые вставляются между настоящими кванторами по отдельным переменным этих описаний.
[41:03.000 --> 41:13.000]  Вот. Хорошо. Значит, на самом деле вот такие вот чередования существуют, для любого существуют и так далее, у нас уже были в полинаминальной иерархии.
[41:14.000 --> 41:24.000]  Вот. Соответственно, как и там, значит, можно интерпретировать вот эти вот цепочки со сменами кванторов через игры.
[41:24.000 --> 41:46.000]  Можно интерпретировать цепочки кванторов, цепочки кванторов как игры.
[41:46.000 --> 42:08.000]  То есть тут, соответственно, получается, что игрок 1, игрок 1 выбирает x1, потом 2 выбирает x2, потом снова 1 выбирает x3, значит, 2 выбирает x4, и так далее.
[42:08.000 --> 42:17.000]  А в итоге фи говорит, кто выиграл. Фи сообщает, кто выиграл.
[42:23.000 --> 42:32.000]  Ну, может, тут игрока 2 лучше было назвать игроком 0, тогда фи прям говорит конкретно, кто выиграл, а так фи говорит только четность того, кто выиграл.
[42:33.000 --> 42:41.000]  Ну и тогда вот такая вот формула с кванторами означает, что у первого игрока есть выигрышная стратегия.
[42:41.000 --> 43:01.000]  Значит, тогда и только тогда, когда у игрока 1 есть выигрышная стратегия.
[43:11.000 --> 43:25.000]  То есть у него есть такой хороший первый ход, что как бы потом не сходил второй, он сможет сходить снова так хорошо, что как бы не сходил потом второй, и так далее, в результате все-таки выиграет первый.
[43:25.000 --> 43:40.000]  То есть можно сказать так, в итоге такой вот цепочке переходов, можно сказать, что любую задачу SPACE-SPACE можно интерпретировать как вопрос о том, у какой из сторон есть выигрышная стратегия.
[43:40.000 --> 43:48.000]  Вот в такой игре, в какой-то игре, которая длится, тем не менее, полиномиальное число ходов.
[43:48.000 --> 43:54.000]  Значит, вот это здесь важно, значит, что игра длится полиномиальное число ходов.
[43:54.000 --> 43:59.000]  Потому что могут быть, в принципе, игры, которые дольше длятся.
[43:59.000 --> 44:09.000]  Значит, сразу уникает вопрос про какие-нибудь игры, которые, ну, на самом деле, не длится полиномиальное число ходов.
[44:09.000 --> 44:19.860]  И соответственно, чтобы вообще ставить вопрос о сложности игры, нужно сначала эту игру обобщить на
[44:19.860 --> 44:29.860]  Доску произвольного размера. Но, скажем, шашки очень легко обобщаются на Доску двойного размера.
[44:30.860 --> 44:38.860]  Ну, там нужно сказать, насколько горизонтальный, там, ставить шашки и так далее.
[44:38.860 --> 44:54.460]  Ну, вообще, можно это сделать, вот hu Rachel,
[44:54.460 --> 44:59.860]  насколько горизонтальей там ставить шашки, и так далее, но вообще можно это
[44:59.860 --> 45:06.540]  сделать. ГО еще проще обобщается, но для ГО там нужно, наоборот,
[45:06.540 --> 45:13.220]  нужен квадрат с нечетной стороной, а в остальном там ставится камня, но там в ГО
[45:13.220 --> 45:20.140]  есть тонкие правила со снятием камней, если кто не знает, в ГО
[45:20.140 --> 45:26.020]  нужно ставить камни разного цвета и так окружать какие-то территории.
[45:26.020 --> 45:28.860]  И еще там есть хитрые правила, что в некоторых ситуациях там какие-то камни
[45:28.860 --> 45:34.340]  снимаются, которые уже поставлены, и, соответственно, тогда, вот если бы ничего не
[45:34.340 --> 45:40.420]  снималось, тогда ясно было бы, что ходов не больше, чем клеток, а если они снимаются,
[45:40.420 --> 45:56.700]  то там нужно аккуратно смотреть, будут они длиться сверхполиномерно-долго, или,
[45:56.700 --> 46:01.380]  все-таки, полиномиально. Шахматы мне еще сложнее, потому что шахматы мне неочевидно,
[46:01.380 --> 46:10.180]  какой набор фигуры должен быть на доске N на N. И кроме того, там есть еще всякие
[46:10.180 --> 46:21.300]  специальные правила. Не, в принципе, и шашками тоже возникает некоторый вопрос,
[46:21.300 --> 46:30.260]  сколько это будет длиться реально, может, на самом деле, долго длиться.
[46:30.260 --> 46:36.580]  Например, в шахматах можно поставить какое-нибудь условие, типа там правил 50 ходов.
[46:36.740 --> 46:41.860]  Есть в обычных шахматах правило 50 ходов, что если на протяжении 50 ходов ни одна
[46:41.860 --> 46:48.740]  фигура не съедена, то игра заканчивается ничьей. Ну и тогда, соответственно, на
[46:48.740 --> 46:54.540]  доске N на N должно быть какое-то число, порядка N или порядка N в квадрате, что если
[46:54.540 --> 47:03.980]  такое число не было взять и фигур, то тогда игра заканчивается ничью. Вот с таким
[47:03.980 --> 47:08.860]  правилом очевидно будет полимерное число ходов, потому что всего фигур
[47:08.860 --> 47:13.820]  полимерное число должно быть, либо порядка N, либо порядка N в квадрате.
[47:13.820 --> 47:19.820]  Ну шахматы скорее порядка N, там должен быть ряд испешек и какие-то фигуры.
[47:19.820 --> 47:26.060]  Соответственно, фигур порядка N, и, соответственно, если больше чем N в квадрате
[47:26.060 --> 47:31.740]  ходов не может быть без взятий, то всего ходов будет не больше, чем N в кубе.
[47:31.740 --> 47:37.820]  Тогда это подпадет вот сюда вот. А есть, например, такого правила не делать, а делать только
[47:37.820 --> 47:44.860]  правила, там еще есть такой правил о троекратном повторении позиции. А это, значит,
[47:44.860 --> 47:50.620]  ситуация, троекратное повторение позиции означает, что если три раза одна и та же
[47:50.620 --> 47:57.580]  позиция на доске появилась, то тогда тоже ничья. Но вот это правило уже не дает
[47:57.580 --> 48:03.100]  ограничений на полимеральное число ходов, потому что позиция-то разное как экспоненциальное число,
[48:03.100 --> 48:10.940]  и даже если каждый из них повторяется три раза, то все равно общее число ходов может быть экспоненциальным.
[48:10.940 --> 48:21.820]  Ну вот, соответственно, если как-то игра обобщена и получилось, что она точно идет в полимерное время,
[48:21.900 --> 48:32.380]  то тогда она точно будет в PSPACE, и, соответственно, можно будет ставить вопрос о том, будет ли она полна в этом классе.
[48:32.380 --> 48:43.980]  Ну и вот я хочу рассказать про одну конкретную игру, которая будет полна, и это называется игра в города.
[48:43.980 --> 48:53.420]  Игра в города, вы, наверное, знаете, как, в принципе, играют в города.
[48:53.420 --> 49:04.540]  Значит, там нужно называть города или там какие-нибудь другие слова так, чтобы каждый следующий город начинался на ту букву, на которую заканчивается предыдущий.
[49:04.540 --> 49:19.420]  Повторяться нельзя, и, соответственно, кто не может ничего придумать, тот проигрывает.
[49:19.420 --> 49:29.020]  Ну обычно это воспринимается как такая игра на эрудицию, там кто больше городов знает, но в принципе тут может быть и такое математическое измерение,
[49:29.900 --> 49:43.900]  потому что есть такие буквы, на которые городов заканчивается много, а начинается мало, и, соответственно, вот можно пытаться все время придумывать города, которые на эти буквы заканчиваются с целью, чтобы у противника исчерпались слова.
[49:43.900 --> 49:49.900]  Но с другой стороны, противник тоже может так делать, и тогда получается вопрос, у кого быстрее исчерпаются слова.
[49:50.780 --> 50:06.220]  Да, и если кто-то из игроков больше знает, то, соответственно, этот игрок выиграет, но если две программы, у которых один и тот же список возможных городов, то это же такая комбинаторная игра получается.
[50:06.540 --> 50:18.540]  Да, что вот, нужно как-то вынудить, но суметь самому назвать последнее последающее слово так, чтобы у противника вариантов не было.
[50:22.540 --> 50:32.540]  Ну а мы рассмотрим чуть-чуть более общий вариант. Это называется обобщенная игра в города.
[50:36.540 --> 50:46.540]  Значит, тут вместо того, что как-то буквы отвечают за то, что можно после чего называть, здесь будем считать, что есть просто некоторые графы.
[50:46.860 --> 50:52.860]  Значит, G-ориентированный граф с выделенной начальной вершиной.
[51:00.860 --> 51:04.860]  И, соответственно, в эту вершину ставится фишка.
[51:10.860 --> 51:12.860]  Вершину ставится фишка.
[51:16.540 --> 51:42.860]  Ну и, соответственно, получается, что два игрока по очереди двигают ее вдоль ребер.
[51:46.860 --> 51:54.860]  Так что, соответственно, нельзя повторять вершина.
[51:54.860 --> 51:58.860]  Значит, так что нельзя ее заводить туда, где она уже была.
[52:00.860 --> 52:02.860]  Значит, так что вершины не повторяются.
[52:02.860 --> 52:15.180]  Значит, кто не может сделать ход, проигрывает.
[52:15.180 --> 52:33.500]  Значит, игрок, который не может сделать ход, проигрывает.
[52:33.500 --> 52:46.500]  Ну вот, вопрос, значит, кто выигрывает при правильной игре, да, у кого есть выигрышная стратегия.
[52:46.500 --> 52:53.500]  Значит, почему это именно обобщенный граф города? Ну, потому что, значит, на городах там тоже есть какой-то граф,
[52:53.500 --> 53:02.500]  когда мы соединяем город X с городом Y, если город X заканчивается на ту же букву, на которой начинается Y.
[53:02.500 --> 53:09.500]  Но тогда, значит, в таком случае непроизвольный граф получится.
[53:09.500 --> 53:15.500]  Посмотрите, если после этого можно назвать вот этот, после этого вот этот и после этого вот этот,
[53:15.500 --> 53:18.500]  тогда вот этот тоже можно назвать.
[53:18.500 --> 53:23.500]  Да, потому что это означает, что здесь и здесь последняя буква такая же, как здесь и здесь первая.
[53:23.500 --> 53:30.500]  Вот, это совершенно непроизвольное свойство графа.
[53:30.500 --> 53:36.500]  Вот, значит, поэтому вот для графа с таким свойством я на самом деле не знаю там,
[53:36.500 --> 53:41.500]  что получается, будет ли это. По-прежнему PSP полная задача.
[53:41.500 --> 53:51.500]  А вот для призвольных графа сейчас расскажу, как строится, как строится свадимость.
[54:01.500 --> 54:11.500]  Да, но прежде чем строить свадимость, нужно еще поговорить про вид формулы.
[54:12.500 --> 54:34.500]  Да, вот у нас в NP был вопрос не просто про выполнимость формулы, а про выполнимость 3KNF.
[54:34.500 --> 54:43.500]  Но, например, про тавтологичность 3KNF вопрос бессмысленный ставить.
[54:43.500 --> 54:49.500]  Да, потому что 3KNF будет тавтологией, только если там в каждой скобке есть какая-то переменная и ее отрицание.
[54:49.500 --> 54:56.500]  Да, а так обычно, если там написано P или Q или R и что-то еще, то есть мы возьмем там PQR равный нулю,
[54:56.500 --> 55:01.500]  то что бы там еще ни было, это уже будет не истина.
[55:01.500 --> 55:08.500]  Я считаю, что про тавтологичность 3KNF бессмысленный вопрос ставить, он тривиальный, а никакой не KNP полный.
[55:08.500 --> 55:15.500]  А на уровне полинамеральной иерархии, на самом деле, важен какой там последний квантор.
[55:15.500 --> 55:20.500]  Да, зато для тавтологичности можно вопрос про 3DNF ставить.
[55:20.500 --> 55:25.500]  Да, для 3DNF она наоборот будет KNP полной.
[55:25.500 --> 55:33.500]  Ну вот, а вообще в полинамеральной иерархии там есть цепочка кванторов,
[55:33.500 --> 55:37.500]  и важно какой квантор последний, не первый из цепочки.
[55:37.500 --> 55:43.500]  То есть если последний квантор это существование, тогда можно считать, что phi в 3KNF.
[55:43.500 --> 55:47.500]  Если последний квантор всеобщенности, тогда нет, нельзя считать.
[55:47.500 --> 55:50.500]  Ну а здесь у нас кванторов сколько угодно,
[55:50.500 --> 55:54.500]  так что мы вполне можем считать, что у нас последний квантор существования.
[55:54.500 --> 55:57.500]  А здесь phi еще привести к виду 3KNF.
[55:57.500 --> 56:01.500]  Ну, будут у нас там какие-то еще лишние кванторы.
[56:01.500 --> 56:04.500]  Потому что процедура самая обычная.
[56:04.500 --> 56:08.500]  Мы говорим, что формула равна единице.
[56:08.500 --> 56:12.500]  Если там существуют такие значения под формул,
[56:12.500 --> 56:17.500]  что во-первых, значения под формул согласованы со всеми значениями переменных,
[56:17.500 --> 56:22.500]  и во-вторых, вся формула будет равна единице.
[56:22.500 --> 56:27.500]  Соответственно, это вот можно сделать.
[56:27.500 --> 56:31.500]  Поэтому можно считать, что у нас phi в 3KNF.
[56:31.500 --> 56:34.500]  Но вроде это на семинарах должно было обсуждаться,
[56:34.500 --> 56:38.500]  по крайней мере на моей группе обсуждалось, и в листочке было.
[56:38.500 --> 56:44.500]  Если так, если не было и со слуху непонятно, то подумайте,
[56:44.500 --> 56:49.500]  почему мы вообще пишем про 3KNF, почему можем заменять,
[56:49.500 --> 56:53.500]  и почему это сработает для tQBF тоже.
[56:53.500 --> 57:02.500]  Будем считать, что у нас phi в 3KNF.
[57:02.500 --> 57:09.500]  Фи в 3KNF, а иксы это отдельные переменные.
[57:09.500 --> 57:16.500]  Иксы это отдельные переменные.
[57:16.500 --> 57:20.500]  И тогда получается вот такая вот картина.
[57:20.500 --> 57:27.500]  Вот есть исходная точка.
[57:27.500 --> 57:31.500]  Стрелка из ниоткуда, это начальная вершина.
[57:31.500 --> 57:41.500]  И дальше возникает вот такая вот развилка на такой ромбик.
[57:41.500 --> 57:48.500]  Но соответственно, тут как бы выбираем x1 у нас будет 0 или единицей.
[57:48.500 --> 57:51.500]  А дальше происходит как бы передача хода.
[57:51.500 --> 57:54.500]  То есть тут вот первый игрок, в зависимости от того,
[57:54.500 --> 57:58.500]  куда он подвинет фишку, сюда или сюда, он выбирает либо 0, либо единицу.
[57:58.500 --> 58:02.500]  Потом у второго игрока нет выбора, он возвращает вот сюда вот.
[58:02.500 --> 58:04.500]  И потом первый сдвигает вот сюда.
[58:04.500 --> 58:06.500]  Вот здесь уже второй выбирает.
[58:06.500 --> 58:11.500]  Второй игрок выбирает x2.
[58:11.500 --> 58:19.500]  Соответственно, он тоже выбирает либо 0, либо единицу.
[58:19.500 --> 58:23.500]  И потом это все куда-то возвращается.
[58:23.500 --> 58:26.500]  И снова придется ход.
[58:26.500 --> 58:31.500]  Теперь, соответственно, первый игрок выбирает x3.
[58:31.500 --> 58:39.500]  Тут тоже либо 0, либо единица.
[58:39.500 --> 58:43.500]  Соответственно, возвращается, придается ход и так далее.
[58:43.500 --> 58:46.500]  Итак, получается такая гирлянда.
[58:46.500 --> 58:50.500]  Гирлянда из ромбиков для всех переменных.
[58:50.500 --> 59:00.500]  Так что, проходя по ней, мы выбираем значение всех переменных.
[59:00.500 --> 59:16.500]  Так, и дальше мы приходим в конец.
[59:16.500 --> 59:20.500]  В общем, мы делаем так, чтобы была такая выделенная вершина.
[59:20.500 --> 59:27.500]  Значит, в ней ходит игрок 2.
[59:27.500 --> 59:29.500]  У нас наша формула phi.
[59:29.500 --> 59:38.500]  Но это будет knf, то есть конъюнция отдельных скобок.
[59:38.500 --> 59:42.500]  Значит, конъюнция отдельных скобок.
[59:42.500 --> 59:53.500]  И соответственно, здесь вот второй выбирает c1, c2, c3 и так далее.
[59:53.500 --> 59:55.500]  Так, а c1, например, будет...
[59:55.500 --> 59:57.500]  Так, x1, x2, x3 там написано.
[59:57.500 --> 01:00:03.500]  Значит, например, x1 или не x2, или x3.
[01:00:03.500 --> 01:00:09.500]  Так, и мы будем считать, что вот эта левая вершина 0 означает,
[01:00:09.500 --> 01:00:14.500]  что перемена равна 0, единичка означает, что она равна единице.
[01:00:14.500 --> 01:00:17.500]  И тогда стрелку мы пишем наоборот.
[01:00:17.500 --> 01:00:25.500]  То есть c1 у нас x1, а мы соответственно в 0 отправляем стрелку.
[01:00:25.500 --> 01:00:31.500]  x2 у нас с отрицанием, там мы в единицу отправляем стрелку.
[01:00:31.500 --> 01:00:39.500]  Соответственно, x3 само по себе, поэтому мы тоже в 0 отправляем стрелку.
[01:00:39.500 --> 01:00:42.500]  Ну и так же со всеми другими.
[01:00:52.500 --> 01:00:57.500]  Вот, все, вот и дает, что вот такая конструкция графа.
[01:00:57.500 --> 01:01:05.500]  Так, и теперь почему выигрышная стратегия в такой игре соответствует
[01:01:05.500 --> 01:01:09.500]  правильному выбору значений переменных формуля.
[01:01:09.500 --> 01:01:17.500]  Значит, ну смотрите, пусть там вот для формулы, пусть у игрока 1 была выигрышная стратегия.
[01:01:17.500 --> 01:01:23.500]  Тогда у него есть, значит, тогда у него есть хороший выбор значений x1.
[01:01:23.500 --> 01:01:25.500]  Значит, например, x1 равно 0.
[01:01:25.500 --> 01:01:33.500]  Ну тогда он, например, сходил вот так вот.
[01:01:33.500 --> 01:01:38.500]  Соответственно, потом второй вернулся сюда.
[01:01:38.500 --> 01:01:41.500]  Значит, первый пошел вот сюда.
[01:01:41.500 --> 01:01:43.500]  Теперь второй ходит.
[01:01:43.500 --> 01:01:47.500]  Ну а второй, например, тоже в 0 пошел.
[01:01:47.500 --> 01:01:52.500]  Значит, тогда после этого первый возвращается, второй передает ход.
[01:01:52.500 --> 01:01:54.500]  Теперь снова первый ходит.
[01:01:54.500 --> 01:01:57.500]  Ну а тут он, например, единицу пошел.
[01:02:01.500 --> 01:02:02.500]  Ну и так далее.
[01:02:02.500 --> 01:02:05.500]  Значит, так все идет.
[01:02:05.500 --> 01:02:10.500]  Потом, смотрите, вот здесь второй выбирает.
[01:02:10.500 --> 01:02:13.500]  А, ну понятно, что здесь вот этот ход второго
[01:02:13.500 --> 01:02:19.500]  первый интерпретирует как выбор значений x2 равно 0 вот в той игре на формуле.
[01:02:19.500 --> 01:02:25.500]  И после этого там есть хороший ход x3, и он его же повторяет вот здесь вот.
[01:02:25.500 --> 01:02:27.500]  Ну и так далее.
[01:02:27.500 --> 01:02:31.500]  Потом игрок 2 выбирает одну из этих скобок.
[01:02:31.500 --> 01:02:35.500]  Ну у нас в итоге все эти скобки должны быть истинными.
[01:02:35.500 --> 01:02:39.500]  Соответственно, вот, например, выбрал c1.
[01:02:39.500 --> 01:02:43.500]  Ну у нас здесь x1 равно 0.
[01:02:43.500 --> 01:02:46.500]  Значит, x1 равно 0.
[01:02:46.500 --> 01:02:51.500]  А x2 равно тоже 0.
[01:02:51.500 --> 01:02:57.500]  Ну и тогда получается, что второй сходил вот сюда, а первый может сходить вот сюда.
[01:02:57.500 --> 01:03:00.500]  А после этого у второго уже нет варианта,
[01:03:00.500 --> 01:03:04.500]  потому что вот это уже было пройдено как бы на основном пути.
[01:03:04.500 --> 01:03:07.500]  И поэтому первый выиграл.
[01:03:07.500 --> 01:03:11.500]  То есть получается, что если вот та скобка истина,
[01:03:11.500 --> 01:03:15.500]  то из вот этих трех вершин, куда идет стрелка, раз, два и три.
[01:03:15.500 --> 01:03:20.500]  Хотя бы одна не будет посещена, пока мы шли вот по этой гирляндии.
[01:03:20.500 --> 01:03:26.500]  И поэтому первый сможет сходить в нее, а после этого второму уже некуда ходить.
[01:03:26.500 --> 01:03:28.500]  Поэтому первый выиграл.
[01:03:28.500 --> 01:03:31.500]  Первый выиграл, если все вот эти скобки оказались истинными,
[01:03:31.500 --> 01:03:34.500]  тогда первый выиграл вот в этой игре.
[01:03:40.500 --> 01:03:44.500]  Потому что, смотрите, тут идея такая, что вот эта стрелка,
[01:03:44.500 --> 01:03:51.500]  как раз в то значение, которое делает, но которое не делает истинную скобку.
[01:03:51.500 --> 01:03:57.500]  Соответственно, если мы вот здесь прошли, там здесь прошли, вот здесь прошли,
[01:03:57.500 --> 01:04:02.500]  то получится, что у нас х1 равно 0, х2 равно 1, х3 равно 0.
[01:04:02.500 --> 01:04:04.500]  А тогда вот эта скобка была бы ложной.
[01:04:04.500 --> 01:04:09.500]  Раз она истинна, значит одна из этих не посещена.
[01:04:09.500 --> 01:04:14.500]  Ну а в другую сторону, наоборот, что если у второго есть выигрышная стратегия,
[01:04:14.500 --> 01:04:17.500]  то уже он ее здесь будет повторять.
[01:04:17.500 --> 01:04:21.500]  То есть интерпретировать первый ход первого как выбор значения х1,
[01:04:21.500 --> 01:04:24.500]  на него отвечать выигрышным значениям х2,
[01:04:24.500 --> 01:04:28.500]  потом интерпретировать следующий как значение х3 и так далее.
[01:04:28.500 --> 01:04:32.500]  И в результате получится, что конъюнция ложная.
[01:04:32.500 --> 01:04:38.500]  И тогда вот здесь у второй может выбрать скобку, которая ложна.
[01:04:38.500 --> 01:04:41.500]  Ну а ложная, она это означает, что, соответственно, у нее
[01:04:41.500 --> 01:04:45.500]  не как здесь написано, наоборот скажем, вот эта посещена,
[01:04:45.500 --> 01:04:47.500]  вот эта посещена и вот эта посещена,
[01:04:47.500 --> 01:04:50.500]  и тогда уже, наоборот, у первых здесь будет не будет входов.
[01:04:50.500 --> 01:04:53.500]  И тогда первый проиграет.
[01:04:53.500 --> 01:04:56.500]  То есть получается, что выигрышная стратегия первого в той игре
[01:04:56.500 --> 01:04:59.500]  перекладывается на выигрышную стратегию в этой игре,
[01:04:59.500 --> 01:05:03.500]  а выигрышная стратегия второго в той игре тоже перекладывается на выигрышную в этой игре.
[01:05:03.500 --> 01:05:13.500]  Вот. Но поэтому, соответственно, какой здесь ответ, такой и там ответ, поэтому получилась сводимость.
[01:05:13.500 --> 01:05:19.500]  Ну и, конечно, нужна замечание, что это сводимость пальномиальная.
[01:05:19.500 --> 01:05:26.500]  Ну, конечно, тут граф будет пальномиального размера, порядка числа переменных плюс числа скобок.
[01:05:27.500 --> 01:05:31.500]  Вот, строится вот так вот, понятным образом.
[01:05:31.500 --> 01:05:43.500]  Ну а сама игра будет в PSPACE, просто потому что любая игра с пальномиальным ограничением начало ходов будет вот в PSPACE.
[01:05:43.500 --> 01:05:51.500]  Так.
[01:05:51.500 --> 01:05:58.500]  Да, в общем, это более-менее всё. Сейчас будет звонок через полминуты.
