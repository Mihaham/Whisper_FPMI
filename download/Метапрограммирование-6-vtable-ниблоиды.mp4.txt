[00:00.000 --> 00:17.520]  в прошлых сериях мы сделали аналог std function да шар на вот сюда и сюда шар оба шара
[00:17.520 --> 00:34.760]  стд function сделали мы его более оптимально чем на виртуальных вызовах да с помощью таких
[00:34.760 --> 00:41.760]  типа виртуальных таблиц которые мы записывали указатели на функции, функции генерили через
[00:41.760 --> 00:48.200]  шаблон где мы это делали ну вот тут например шаблонная лямбда в зависимости от того что
[00:48.200 --> 00:56.240]  прислали ну шаблонная не лямбда сам конструктор на зависимости от того что туда положили лямбда
[00:56.240 --> 01:02.560]  в итоге становится разной и собственно с помощью этого мы в рантайме диспатчили наши вызовы
[01:02.560 --> 01:12.080]  к разным функциям, к разным конструкторам, к разным деструкторам и т.д. и т.п. вот и в конце
[01:12.080 --> 01:20.760]  позвучала мысль что дай-ка мы объединим все вот эти вот call, deconstructor, constructor, еще copy
[01:20.760 --> 01:29.600]  constructor да объединим их все в одну таблицу для пущего удобства сейчас мы эту идею будем
[01:29.600 --> 01:38.660]  развивать ну и кажется я сказал что в итоге получается что-то очень сильно похоже на сами
[01:38.660 --> 01:46.280]  виртуальные функции, виртуальные вызовы фактически на шаблонах переизобрели ООП с нуля сейчас мы
[01:46.280 --> 01:52.480]  будем продолжать переизобретать ООП с нуля на шаблонах да но перед этим небольшое замечание
[01:52.480 --> 01:59.680]  комментарии исправления про которое забыл сказать да вот декл-тайп от авто я обещал что расскажу что это
[01:59.680 --> 02:08.720]  и так его написал и так и не рассказал ну если вдруг кто не знает на всякий случай расскажу
[02:08.720 --> 02:17.320]  с какого-то там стандарта мы можем писать вот так и в конце указывать тип
[02:17.320 --> 02:30.240]  я не знаю с 11 но более того вот когда мы так пишем мы можем вот в этом вот типе в конце
[02:30.240 --> 02:36.400]  трейлинг так называется формально говоря мы в нем можем использовать аргументы которые нам
[02:36.400 --> 02:42.640]  прислали функцию ну если это просто какая-то функция это не особо полезно вот если функция
[02:42.640 --> 02:52.000]  шаблонная то когда мы вот здесь писали тип мы не могли как-то использовать а например да
[02:52.000 --> 03:00.600]  писать декл-тайп от а или там а стрелка где-то какой-нибудь вот вот это не работало там а не
[03:00.600 --> 03:05.440]  было видно и собственно вот этот трейлинг ритор мы добавили ровно для этого чтобы мы могли
[03:05.440 --> 03:11.600]  вот так вот писать ну
[03:16.480 --> 03:20.360]  ну нет декл-вал здесь не особо подходит потому что нам нужно очень аккуратно
[03:20.360 --> 03:32.480]  обрабатывать кейсы когда а это l-value ссылка или r-value ссылка и формально говоря ну там надо
[03:32.480 --> 03:37.640]  очень аккуратно это сделать там легко ошибиться вот в таком виде оно выглядит легко просто и
[03:37.640 --> 03:48.560]  понятно более того если говорить о свиная то вот эта часть внутри декл-тайпа или вообще весь
[03:48.560 --> 03:56.560]  возвращаемый тип оно тоже учитывается в стена и что какую какую магическую магию это нам
[03:56.560 --> 04:02.000]  позволяет сделать взять и буквально скопировать возвращаемый тип возвращаемое
[04:02.000 --> 04:12.520]  выражение функции пахнуть его сюда теперь функция да сейчас секунду теперь функция возвращает ровно
[04:12.520 --> 04:18.240]  то же самое что возвращал вот этот где то есть если где-то возвращает ссылку она возвращает
[04:18.240 --> 04:28.280]  ссылку р-value ссылку р-value ссылку вот и вроде если значение то просто значение и это очень
[04:28.280 --> 04:34.480]  здорово это нам по сути позволяет делать perfect forwarding и для аргументов и для возвращаемых
[04:34.480 --> 04:43.560]  значений то есть вот это вот прошлойка и не кэст она вообще никак не влияет на ни на что ни на какие
[04:43.560 --> 04:49.280]  категории значения ни на какие ссылки полностью сохраняет информацию о том l-value или r-value
[04:49.280 --> 05:01.080]  хотим ли мы мовнутили скопировать вот но это неудобно да очень неудобно поэтому решили ну блин
[05:01.080 --> 05:08.680]  а что делать да если функции функции много строчек то все их сюда впихивать это очень
[05:08.680 --> 05:20.120]  костыльно и неудобно поэтому мы можем делать вот так и все оно автоматом вместо этого авто
[05:20.120 --> 05:27.600]  подставит вот это выражение заметьте что вот это все не то же самое что написать вот этот
[05:27.600 --> 05:38.040]  сейчас надо вспомнить конечно но в каких-то случаях вот этот авто он немножко не так
[05:38.040 --> 05:55.960]  работает как мы хотим если get возвращает l-value ссылку в общем это хороший вопрос как оно
[05:55.960 --> 06:09.600]  конкретно работает вообще да наверное все-таки она не будет да она не будет как ссылка в общем
[06:09.600 --> 06:15.840]  это бесполезно пытаться запоминать проще каждый раз загуглить и посмотреть такие тонкости очень
[06:15.840 --> 06:21.320]  редко нужны но при этом могут больно отстрелить ногу и если вы знаете что вам вот прям нужно
[06:21.320 --> 06:27.640]  типа полностью все сохранить как бы l-value и r-value категории и на входе и на выходе то вы
[06:27.640 --> 06:33.080]  используете деколта и под авто ну и писать вам можно не только сзади но и спереди теперь вот
[06:33.080 --> 06:38.720]  но это немножко меняет семантик работы всего этого по сравнению с тем что вот тут было что
[06:38.720 --> 06:49.040]  меняется манглинг нет это не интересно в чем разница между вот этим вот этим достаточно
[06:49.040 --> 07:04.840]  важная да вот здесь свиная работы то есть если вот это выражение оно как бы некорректно да я
[07:04.840 --> 07:15.680]  не знаю а нету такого шаблонного метода гет да то вот в таком случае у нас просто и не каст
[07:15.680 --> 07:22.320]  вылетит из списка кандидатов функции которые могли бы вызвать сюда вот при огорел от резолюшен
[07:22.320 --> 07:28.480]  мы обсуждали что строится сет потенциальных функций которые нам подходят и свиная просто
[07:28.480 --> 07:35.360]  говорит о том что если в сигнатуре функции что-то подставилось и произошла ошибка то мы не
[07:35.360 --> 07:41.960]  выкидываем компиляции а исключаем из множества подходящих функций вот соответственно где-то
[07:41.960 --> 07:47.800]  в другом месте может быть другая перегрузка и не каста определенно который уже умеет
[07:47.800 --> 08:06.840]  справляться как бы со случаем где где вот это вот не работа например стд а давайте даже демонстрируем
[08:06.840 --> 08:17.840]  это а мы уже все стерли про и не каст ладно давайте вот здесь стреляем по-быстрому представим
[08:17.840 --> 08:31.880]  что мы нам прислали шаблоном какой-то тешку про который мы точно знаем что она какая-то
[08:31.880 --> 08:39.280]  имплементация они до стд либо не стд либо наши они а может быть и не наши не может быть
[08:39.280 --> 08:47.880]  они из густа или вообще из другой библиотеки как нам написать от универсально чтобы они каст
[08:47.880 --> 08:54.920]  который мы предполагаем есть у нас и во стд и в пусте работал во всех случаях если мы напишем
[08:54.920 --> 09:09.080]  просто они каст да то кажется это нас спасет в этом случае да ладно плохой пример давайте
[09:09.080 --> 09:14.320]  отложим этот вопрос мы потом да с они кастом мне не дастся демонстрировать
[09:14.320 --> 09:26.160]  окей значит потом но до просфена и поняли так с финай есть вот так с финай нет но это не
[09:26.160 --> 09:34.680]  единственное что мы еще хотим соблюдать при вот таком вот перфект форвардинге да давайте
[09:34.680 --> 09:46.080]  подумаем вот где-то если он но accept и не каст он же все равно будет не но accept и это неприятно
[09:46.080 --> 09:52.680]  не всю как бы информацию прокинули про функцию или про вызов очень хотелось бы чтобы если
[09:52.680 --> 10:01.760]  нет но accept и не каст но accept если он не но accept то и не каст не но accept мы так можем мы пишем
[10:01.760 --> 10:13.080]  но accept от буля вот так можно делать теперь по моему 17 и можно писать true или false соответственно
[10:13.080 --> 10:19.960]  это будет определять рули но accept или false этот truly false может вам приходить из шаблонных
[10:19.960 --> 10:27.360]  параметров например может быть какая-то глобальная применная config что-нибудь такое но
[10:27.360 --> 10:32.520]  самое интересное то что можно написать еще раз но accept а в скобках какое-то выражение
[10:32.520 --> 10:45.480]  после requires requires это не должно уже вызывать сильного шока вот эта вещь с 11 вообще здорово нет
[10:45.480 --> 10:54.440]  но accept specify рэда а то что буль скобках можно писать да здорово вот вот эта штука
[10:54.440 --> 11:05.000]  выдаст вам true если выражение скобках но accept иначе false и этот буль который говорит получится ли
[11:05.000 --> 11:10.760]  вот это вот как но accept вычислить вы прокидываете собственно мой акцент для не каста и теперь
[11:10.760 --> 11:20.880]  кое не каста мой к сепаря такой же как и у гета ну или у других частей этого выражения то есть
[11:20.880 --> 11:27.120]  если все выражение но accept нигде там никогда не может выскочить исключение то вот это но тогда
[11:27.120 --> 11:32.840]  и не каст макса и вот это вот совсем перфект перфект супер перфект форварде где вообще все
[11:32.840 --> 11:43.240]  сохраняется и все здорово вот вот с комментарием к прошлому на этом всем давайте переходить к
[11:43.240 --> 11:57.720]  будущему мы хотим вот эту вот идею с виртуальной таблицей развить обобщить и сделать супер классно
[11:57.720 --> 12:05.480]  ну с какой цели на самом деле цели очень много первая наша цель будет симулировать
[12:05.480 --> 12:17.320]  пусть у нас есть класс base даже айбез на интерфейс есть вот такая виртуальная функция есть вот
[12:17.320 --> 12:43.240]  такая виртуальная мы делаем драйв и там перекружаем обе функции ну и делаем другой
[12:43.240 --> 12:57.240]  класс draft такие изготовки айбез айбез паблик я не знаю зачем классы
[12:57.240 --> 13:16.120]  не папсулировать пришли полиморфировать другой так ok соответственно что происходит
[13:16.120 --> 13:24.840]  реальные вещи сейчас буду говорить ничего сложного мы делаем указатель на айбез который
[13:24.840 --> 13:49.360]  равен и такую же фигню для 2 для хорошести давайте и вот эту базу мы можем запустить
[13:49.960 --> 14:02.720]  можем запустить бейс 2 полиморфизм тип у них один синтаксис один вызов нас приводит в разные
[14:02.720 --> 14:12.000]  точки кода один сюда другой сюда здорово давайте тоже самое делать руками что получается когда
[14:12.000 --> 14:22.720]  мы объявляем айбез ну на самом деле в памяти айбез немножко больше чем нам кажется давайте
[14:22.720 --> 14:33.360]  как-то это обозначим ну тут никаких данных не хранится давайте им положим туда чтобы он был
[14:33.360 --> 14:38.800]  если бейс был просто структуркой без виртуального вот этого всего то и в памяти
[14:38.800 --> 14:48.480]  он выглядел как просто один им но так как мы объявили виртуальные функции у экземпляров
[14:48.480 --> 15:03.280]  айбез теперь будет лежать до вот этого им а указатель на виртуальную таблицу и умолчанию
[15:03.280 --> 15:11.000]  если мы просто сделаем ну мио и бейс ну нам даже не позволит мне быть сделать да экземпляров
[15:11.000 --> 15:16.800]  чисто абстрактных классов то есть кто-таки у которых хотя бы один метод чисто виртуальный мы
[15:16.800 --> 15:24.480]  делать не можем окей что происходит когда мы экземпляра айдрайв ну как мы знаем если
[15:24.480 --> 15:33.160]  мы наследуем что-то то наш родителей становится под объектом нас то есть как бы память состоит
[15:33.160 --> 15:38.480]  теперь из двух частей давайте наверное даже горизонтально записывать чтобы было нагляднее
[15:38.480 --> 15:47.520]  такими палочками разделять блоки соответственно теперь у нас все это состоит из двух блоков один
[15:47.520 --> 15:59.080]  блок этой бейс а дальше идет как бы данные айдрайв и внутри этого и бейс у нас все еще
[15:59.080 --> 16:14.840]  есть тейпл звездочка и все еще есть если мы какие-то данные добавим сюда то они просто дальше
[16:14.840 --> 16:24.920]  будут складываться соответственно что происходит когда конструируется экземпляр дарайф 1 ну у нас
[16:24.920 --> 16:43.800]  выделено такая вот память и как бы конструирование идет от под объектов к общему объекту да то бишь
[16:43.800 --> 16:50.400]  сначала нужно самый вложенный объект то бишь родителя сконструировать ну так как формально
[16:50.400 --> 16:55.800]  говоря конструктор вызывать нельзя это такое не очень понятное слово сконструировать но вот здесь
[16:55.800 --> 17:06.240]  могут быть всякие инициализации да которые нужно сделать ну больше того конструктор это все-таки
[17:06.240 --> 17:13.760]  могут быть у айбэйс и их все равно нужно запустить и при запуске конструктора драйв у нас
[17:13.760 --> 17:20.200]  сначала запустится конструктор айбэйс который витей был звездочка положит ну вот это там данные
[17:20.200 --> 17:25.760]  как-то инициализирует конструктор полностью отработает дальше мы придем конструктор драйф
[17:25.760 --> 17:32.080]  один и вот перед тем как запускать само тело конструктора которые мы написали драйв один
[17:32.080 --> 17:38.440]  подменит указатель на виртуальную таблицу на наш указатель на виртуальную таблицу где вот
[17:38.440 --> 17:45.560]  уже записан указатель на вот эти наши функции затем инициализирует наши поля и уже запустит
[17:45.560 --> 17:53.200]  наш конструктор если бы драйв дать один был еще один ребенок то он бы дальше в свою очередь
[17:53.200 --> 18:01.680]  подменил опять вот и был звездочка на какого-то своего на какие-то свои какой-то свой вот это
[18:01.680 --> 18:10.720]  соответственно когда мы кастим указатель с не ударает один на айбэйс ну фактически с ним
[18:10.720 --> 18:16.120]  ничего не происходит он все еще указывает на тоже начало памяти и там все еще вот есть этот вот
[18:16.720 --> 18:23.600]  но как бы по типу айбэйза мы знаем что в этом вот это и был вот это и на самом деле лежат
[18:23.600 --> 18:33.280]  два указателя на функции войб от аргументов и их можно вызвать что собственно вот здесь и происходит
[18:33.280 --> 18:40.520]  и когда мы создаем два разных драйв да драйв 1 драйв 2 вот эти указатели нова тейбл у них
[18:40.520 --> 18:46.520]  получается разные после каста к айбэйзу и ровно за счет этого получается полиморфизм
[18:46.520 --> 18:56.200]  окей это такое напоминание если сейчас что-то было непонятно давайте это говорить это вот
[18:56.200 --> 19:03.400]  просто механика что как бы есть указатель на виртуальную таблицу он подменяется как бы
[19:03.400 --> 19:10.960]  наследниками на свои вот в случае когда у нас только один родитель все просто понятно и хорошо
[19:10.960 --> 19:21.640]  ну отдельные проблемы может быть то что у нас вот здесь могут добавляться новые виртуальные
[19:21.640 --> 19:30.980]  и как бы нужно расширять таблицу вызовов но про это чуть попозже мне кажется мы это осили
[19:30.980 --> 19:40.420]  не факт возможно этим не стоит заниматься так как мы будем изобретать наш велосипед
[19:40.420 --> 19:50.940]  ну конечно нам понадобится структурка и конечно же она будет шаблонно вот какие шаблонные
[19:50.940 --> 20:00.860]  аргументы там будут мы пока не понимать как компилятор вообще понимает в каком
[20:00.860 --> 20:06.540]  порядке хранить функции виртуальной стаблице да ну наверное просто в порядке объявлений
[20:06.540 --> 20:15.020]  сначала фу потом бам но как бы когда мы убирать делаем нам нужно по названию функции или там
[20:15.020 --> 20:21.980]  сигнатуре понять в какой из слотов вот этих виртуальных функций идет оверрайт
[20:21.980 --> 20:31.580]  там да скорее всего лежит какая-то каштаблица что-то вроде того так у нас тут мэта прога мы не
[20:31.580 --> 20:37.980]  будем каштаблицу сам по ил тайме делать мы сделаем проще мы будем пытаться по некоторому ключу
[20:37.980 --> 20:49.020]  индексировать а элементы витамин то бишь что это все значит давайте заведем еще одну структуру
[20:49.020 --> 21:05.940]  витамин 3 и она тоже будет шаблонная и шаблоне у нас будет две вещи первая это статик стринг из
[21:05.940 --> 21:17.020]  первого задания помните его он полез я решил на 64 сделать потому что 256 как-то жирновато
[21:17.020 --> 21:27.180]  соответственно это будет что-то вроде имени функции вот меня сейчас как-то что-то останавливает меня
[21:27.180 --> 21:34.620]  просто взять и заходить здесь статик стринг поэтому заготовочку на будущее давайте сразу
[21:34.620 --> 21:46.500]  сделаем здесь некоторые даже лучше нет не лучше давайте сделаем некоторые класс ключа и
[21:46.500 --> 21:58.140]  будем принимать экземпляры этого класса ключа а также нам понадобится нам понадобится сигнатура
[21:58.140 --> 22:06.620]  чтобы знать но как вызывать эту функцию с какими аргументами ну это сигнатура соответственно
[22:06.620 --> 22:13.420]  изначально у нас будет просто f и дальше нам понадобится наши любимые специализации как
[22:13.420 --> 22:29.820]  обычно соответственно мы уточняем что у нас сигнатура была рет от аргстрой точь так все хорошо
[22:29.820 --> 22:36.420]  все хорошо и хранить мы здесь будем соответственно указатель на функцию
[22:36.420 --> 22:46.820]  сделаем юзин для удобства
[22:46.820 --> 22:51.540]  указатель
[22:52.060 --> 22:55.960]  discipl
[23:00.340 --> 23:01.600]  соответственно
[23:03.840 --> 23:04.180]  the
[23:06.180 --> 23:17.540] ics table table table table как мы сможем запихнуть произвольное количество
[23:17.540 --> 23:24.380]  витейбл entry, наш витейбл. вот такое уже где-то видели.
[23:27.740 --> 23:39.780]  когда мы, я не знаю, писали factory, там были какие-то креатуры, в которых нужно было
[23:39.780 --> 23:57.460]  штуку запихнуть в класс, нет? что-что? ну да, именно так, через наследок. здесь будет
[23:57.460 --> 24:07.900]  некоторый баг, пока не определились какой, но в итоге мы эти в витейбл entry сюда с чем-то
[24:07.900 --> 24:16.820]  подставим и развернем такой баг. что там должно быть? кажется, у нас ключ должен быть один для всех,
[24:16.820 --> 24:39.220]  а вот баг конкретных значений типа ключа и сигнатур, это уже чуть проблематично.
[24:39.220 --> 24:47.780]  сейчас я пытаюсь сделать заготовку, чтобы потом не пришлось ничего переписывать,
[24:47.780 --> 24:49.220]  я не знаю, насколько она будет сейчас.
[25:03.220 --> 25:07.020]  давайте сделаем всю эту специализацию опять.
[25:07.020 --> 25:37.020]  ааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааа
[25:37.020 --> 25:42.020]  да, нужно подкасты лягать совершенно традиционные вещи
[26:07.020 --> 26:13.020]  вот так мы сделаем
[26:13.020 --> 26:27.020]  вот, все хорошо
[26:27.020 --> 26:31.020]  нет, это пока никакие не полиции
[26:31.020 --> 26:33.020]  хотя, если присмотреться, возможно
[26:33.020 --> 26:35.020]  нет, мы пытаемся изобрести вотейбл
[26:35.020 --> 26:39.020]  вотейбл должен состоять из entry
[26:39.020 --> 26:41.020]  каждый entry содержит одну функцию
[26:41.020 --> 26:49.020]  и мы определились, что мы хотим по какому-то ключу получать доступ к этим bitable entry
[26:49.020 --> 26:53.020]  соответственно, да, вот так
[26:53.020 --> 26:57.020]  приходится везде протягивать этот ключ
[26:57.020 --> 27:03.020]  и в итоге в сам bitable мы будем впихивать
[27:03.020 --> 27:09.020]  pack, par, key, value, ну и какой-то тип key
[27:18.020 --> 27:20.020]  ну пока ничего особенного
[27:20.020 --> 27:24.020]  теперь нам надо научиться доставать по ключу
[27:24.020 --> 27:26.020]  из bitable
[27:26.020 --> 27:30.020]  соответствующей функции
[27:43.020 --> 27:45.020]  как мы хотим это сделать?
[27:49.020 --> 27:53.020]  у меня есть сильное ощущение, что я такие вещи уже рассказывал
[27:53.020 --> 27:55.020]  но я запамятал
[27:55.020 --> 28:01.020]  мы же учились из вот такой конструкции, когда у нас куча наследников
[28:01.020 --> 28:08.020]  вытаскивать из какого-то конкретного по ключу данного
[28:13.020 --> 28:15.020]  когда в factory делали?
[28:15.020 --> 28:17.020]  abstract factory
[28:25.020 --> 28:35.020]  да, мы делали в каждом классе какую-то функцию
[28:50.020 --> 28:54.020]  да, это момент параметра pack через вот в этот момент
[28:54.020 --> 28:57.020]  но нам же тоже самое надо сделать
[28:57.020 --> 29:01.020]  если мы собрались делать гет по ключу
[29:01.020 --> 29:03.020]  одна только проблема
[29:03.020 --> 29:08.020]  мы не очень понимаем, какая сигнатура будет в итоге
[29:08.020 --> 29:12.020]  и с этим пока непонятно, что делать
[29:12.020 --> 29:16.020]  ну как с factory и double element
[29:18.020 --> 29:20.020]  давайте
[29:20.020 --> 29:23.020]  да, double element
[29:27.020 --> 29:31.020]  у нас примерно такая же ситуация
[29:31.020 --> 29:35.020]  давайте ровно так сделаем
[29:37.020 --> 29:40.020]  template key key
[29:42.020 --> 29:45.020]  пока будет auto get
[29:48.020 --> 29:50.020]  что нам нужно сделать?
[29:50.020 --> 29:56.020]  прикастить себя к тому из наследников, у которых есть key
[30:02.020 --> 30:04.020]  что-то типа того
[30:06.020 --> 30:09.020]  давай ты мне поможешь написать эту фолпер функцию
[30:09.020 --> 30:13.020]  я код colab сейчас не включал, что мы хотим?
[30:28.020 --> 30:34.020]  нам наверное нужен template auto value tag
[30:34.020 --> 30:37.020]  чтобы по нему диспатчить
[30:39.020 --> 30:43.020]  соответственно вот table entry
[30:43.020 --> 30:45.020]  мы будем возвращать
[30:47.020 --> 30:50.020]  диспатч назовем
[30:50.020 --> 30:52.020]  какие аргументы будут?
[30:56.020 --> 31:00.020]  нет, мы хотим тихую диспатчить
[31:04.020 --> 31:08.020]  мы хотим вот такие функции в каждой table entry объявить
[31:08.020 --> 31:12.020]  в итоге вот здесь мы сделаем using
[31:25.020 --> 31:28.020]  и вот здесь диспатч будем использовать
[31:28.020 --> 31:30.020]  и мы хотим чтобы...
[31:30.020 --> 31:33.020]  ну теперь все эти диспатчи они overloaded
[31:33.020 --> 31:35.020]  они все видимо в одной области
[31:35.020 --> 31:37.020]  это все перегрузки одной и той же функции
[31:37.020 --> 31:40.020]  мы хотим чтобы с помощью overload resolution
[31:40.020 --> 31:43.020]  мы каким-то образом выбрали диспатч
[31:43.020 --> 31:45.020]  тот который нужен для этого ключа
[31:45.020 --> 31:47.020]  но вот так не получится
[31:48.020 --> 31:50.020]  почему так не получится?
[31:58.020 --> 32:02.020]  ну да, у всех key одинаковый тип
[32:02.020 --> 32:04.020]  да
[32:05.020 --> 32:07.020]  поэтому я сказал что нам нужен value tag
[32:07.020 --> 32:10.020]  мы хотим принять value tag
[32:10.020 --> 32:14.020]  причем такой, где принимается ровно наш key
[32:15.020 --> 32:17.020]  все
[32:17.020 --> 32:20.020]  в теле мы вернем его, если мне кажется
[32:22.020 --> 32:25.020]  я даже сказал бы, что это cast называется
[32:32.020 --> 32:33.020]  что не так?
[32:33.020 --> 32:35.020]  скажи мне
[32:36.020 --> 32:38.020]  ну без карт возможно еще
[32:38.020 --> 32:39.020]  ладно, неважно
[32:39.020 --> 32:43.020]  вот теперь здесь мы делаем авто звездочка entry
[32:45.020 --> 32:46.020]  cast
[32:46.020 --> 32:48.020]  не забудьте здесь поменять
[32:50.020 --> 32:53.020]  причем, если я не ошибаюсь, все-таки index cast
[32:53.020 --> 32:55.020]  а нет, не index, мы их заusing-ли
[32:55.020 --> 32:57.020]  в прошлый раз это выяснили
[32:57.020 --> 32:59.020]  value tag
[33:04.020 --> 33:05.020]  создать
[33:05.020 --> 33:06.020]  ура
[33:06.020 --> 33:08.020]  диспатчеризировались
[33:08.020 --> 33:10.020]  через overload resolution
[33:10.020 --> 33:12.020]  к нужной entry
[33:12.020 --> 33:14.020]  теперь мы можем
[33:14.020 --> 33:17.020]  в принципе сразу можем, даже не сохраняя
[33:17.020 --> 33:19.020]  вернуть
[33:22.020 --> 33:23.020]  value
[33:23.020 --> 33:25.020]  ура
[33:27.020 --> 33:29.020]  мы научились делать ket
[33:33.020 --> 33:35.020]  что нам еще нужно?
[33:35.020 --> 33:37.020]  нам нужно создавать это table
[33:37.020 --> 33:39.020]  мы хотим, чтобы
[33:39.020 --> 33:41.020]  если мы сделали такой класс ibase
[33:41.020 --> 33:45.020]  то для него была бы создана одна статическая
[33:45.020 --> 33:47.020]  как одна для этого класса
[33:47.020 --> 33:49.020]  одинаковая для всех экземпляров
[33:49.020 --> 33:51.020]  виртуальная таблица
[33:51.020 --> 33:53.020]  где просто написано нули
[33:53.020 --> 33:55.020]  или какие-то функции, которые там
[33:55.020 --> 33:57.020]  кидают или что-то такое
[33:57.020 --> 33:59.020]  также для draft1
[33:59.020 --> 34:01.020]  для класса draft1
[34:01.020 --> 34:02.020]  тоже генерируем
[34:02.020 --> 34:04.020]  один единственный объект
[34:04.020 --> 34:06.020]  его виртуальная таблица
[34:06.020 --> 34:09.020]  которые используются всеми его экземплярами
[34:09.020 --> 34:11.020]  то же самое draft2
[34:11.020 --> 34:13.020]  мы перед тем, как
[34:13.020 --> 34:15.020]  возиться, как это все сделать
[34:17.020 --> 34:19.020]  перед тем, как возиться, как это сделать статическим
[34:19.020 --> 34:21.020]  давайте
[34:21.020 --> 34:23.020]  создавать мелочи
[34:25.020 --> 34:27.020]  нужен конструктор
[34:27.020 --> 34:29.020]  либо
[34:29.020 --> 34:31.020]  либо метод create
[34:31.020 --> 34:33.020]  и
[34:33.020 --> 34:35.020]  в ходе хорошей библиотеки
[34:35.020 --> 34:37.020]  я увидел, что они делают
[34:37.020 --> 34:39.020]  публичном жарлонный метод create
[34:39.020 --> 34:41.020]  поэтому мы тоже так сделаем
[34:41.020 --> 34:43.020]  и возможно в процессе
[34:43.020 --> 34:45.020]  поймем, зачем они так делают
[34:49.020 --> 34:51.020]  а если не секрет, а какой библиотеки
[34:51.020 --> 34:53.020]  идёт речь?
[34:53.020 --> 34:55.020]  liveunifex
[34:55.020 --> 34:57.020]  мы тоже сейчас доживём
[34:57.020 --> 34:59.020]  надеюсь, это семинар
[34:59.020 --> 35:01.020]  очень интересно узнать
[35:01.020 --> 35:03.020]  надо как-то ускориться
[35:03.020 --> 35:05.020]  конструктор vtable
[35:05.020 --> 35:07.020]  будет принимать список
[35:07.020 --> 35:09.020]  fnt value
[35:17.020 --> 35:19.020]  он должен принимать
[35:19.020 --> 35:21.020]  в каком-то виде набор ключей
[35:21.020 --> 35:23.020]  и набор значений, которые
[35:25.020 --> 35:27.020]  уже не классы
[35:27.020 --> 35:29.020]  этих значений, а уже конкретные функции
[35:37.020 --> 35:39.020]  мы хотим
[35:39.020 --> 35:41.020]  выводить
[35:41.020 --> 35:43.020]  на самом деле
[35:47.020 --> 35:49.020]  давайте через метод create выводить
[35:51.020 --> 35:53.020]  vtable
[35:53.020 --> 35:55.020]  create
[35:57.020 --> 35:59.020]  create будет принимать
[35:59.020 --> 36:01.020]  да, именно так
[36:01.020 --> 36:03.020]  static
[36:03.020 --> 36:05.020]  он будет принимать
[36:05.020 --> 36:07.020]  пак из функций
[36:07.020 --> 36:09.020]  вернее указателей
[36:09.020 --> 36:11.020]  на функцию
[36:13.020 --> 36:15.020]  их мы пока
[36:15.020 --> 36:17.020]  распаковывать не будем
[36:17.020 --> 36:19.020]  здесь вот в retargs
[36:19.020 --> 36:21.020]  это просто будут какие-то
[36:21.020 --> 36:23.020]  типы
[36:47.020 --> 36:49.020]  что конечно ключи
[36:51.020 --> 36:53.020]  давайте их тоже выводить
[37:17.020 --> 37:21.020]  да, сейчас
[37:21.020 --> 37:23.020]  давайте
[37:23.020 --> 37:25.020]  подглянем
[37:25.020 --> 37:27.020]  потому что
[37:27.020 --> 37:29.020]  происходит очень высокоуровневая магия
[37:29.020 --> 37:31.020]  очень легко
[37:31.020 --> 37:33.020]  да, не тот goodbolt
[37:33.020 --> 37:35.020]  или тот
[37:35.020 --> 37:37.020]  не тот goodbolt
[37:37.020 --> 37:39.020]  не тот goodbolt
[37:47.020 --> 37:49.020]  нас ждет
[37:51.020 --> 37:53.020]  да, происходит очень классная магия
[37:53.020 --> 37:55.020]  надеюсь к концу мы
[37:55.020 --> 37:57.020]  начнем принимать
[38:07.020 --> 38:09.020]  да
[38:09.020 --> 38:11.020]  тут предлагают
[38:11.020 --> 38:13.020]  указывать
[38:13.020 --> 38:15.020]  функции ключи
[38:15.020 --> 38:17.020]  ну да
[38:17.020 --> 38:19.020]  это менее удобно
[38:19.020 --> 38:21.020]  чем
[38:21.020 --> 38:23.020]  нам придется поменять немножко подход
[38:23.020 --> 38:25.020]  нам придется
[38:25.020 --> 38:27.020]  сделать все-таки
[38:27.020 --> 38:29.020]  конструктор
[38:29.020 --> 38:31.020]  шаблонный
[38:31.020 --> 38:33.020]  принимающий
[38:33.020 --> 38:35.020]  пары
[38:35.020 --> 38:37.020]  пары
[38:37.020 --> 38:39.020]  из указателей на функцию
[38:39.020 --> 38:41.020]  и value
[38:41.020 --> 38:43.020]  тега
[38:43.020 --> 38:45.020]  да
[38:45.020 --> 38:47.020]  ключи
[38:47.020 --> 38:49.020]  да
[39:03.020 --> 39:05.020]  keys2 key
[39:11.020 --> 39:13.020]  что значит ключи
[39:13.020 --> 39:15.020]  второй пак ключей
[39:15.020 --> 39:17.020]  зачем
[39:17.020 --> 39:19.020]  второй пак ключей
[39:19.020 --> 39:21.020]  второй пак ключей
[39:21.020 --> 39:23.020]  нам нужно написать
[39:23.020 --> 39:25.020]  deduction guide
[39:25.020 --> 39:27.020]  цель какая
[39:27.020 --> 39:29.020]  я не знаю
[39:29.020 --> 39:31.020]  напишем вот так
[39:31.020 --> 39:33.020]  static auto
[39:33.020 --> 39:35.020]  auto
[39:35.020 --> 39:37.020]  myq
[39:37.020 --> 39:39.020]  be table
[39:39.020 --> 39:41.020]  от
[39:41.020 --> 39:43.020]  здесь будет пак пар
[39:43.020 --> 39:45.020]  да
[39:51.020 --> 39:53.020]  не знаю указатель
[39:53.020 --> 39:55.020]  на какой-нибудь
[39:55.020 --> 39:57.020]  какие есть глобальные функции
[39:57.020 --> 39:59.020]  у нас на xp и std
[39:59.020 --> 40:01.020]  которые можно для тестов использовать
[40:01.020 --> 40:03.020]  видимо никаких
[40:03.020 --> 40:05.020]  давайте сделаем static void
[40:05.020 --> 40:07.020]  void foo
[40:07.020 --> 40:09.020]  void bar
[40:09.020 --> 40:11.020]  очень здорово классно
[40:13.020 --> 40:15.020]  bar
[40:15.020 --> 40:17.020]  value tag
[40:19.020 --> 40:21.020]  bar
[40:21.020 --> 40:23.020]  sister
[40:25.020 --> 40:27.020]  жух
[40:31.020 --> 40:33.020]  а это просто клан
[40:33.020 --> 40:35.020]  как бесится
[40:35.020 --> 40:37.020]  на самом деле код компельса работает
[40:37.020 --> 40:39.020]  да
[40:39.020 --> 40:41.020]  это был bar, а вот это foo
[40:43.020 --> 40:45.020]  мы пока не умеем
[40:45.020 --> 40:47.020]  делать
[40:47.020 --> 40:49.020]  вот эту операцию автоматом
[40:49.020 --> 40:51.020]  так можно
[40:51.020 --> 40:53.020]  сложно и очень осторожно
[40:53.020 --> 40:55.020]  поэтому пока что мы
[40:55.020 --> 40:57.020]  к сожалению
[40:57.020 --> 40:59.020]  давайте для отсутствия костылей
[40:59.020 --> 41:01.020]  сделаем макро
[41:07.020 --> 41:09.020]  чисто чтобы было удобно
[41:09.020 --> 41:11.020]  честное слово
[41:15.020 --> 41:17.020]  кто помнит как
[41:17.020 --> 41:19.020]  решетка f
[41:25.020 --> 41:27.020]  так кажется
[41:27.020 --> 41:29.020]  и вот так
[41:37.020 --> 41:39.020]  ура
[41:39.020 --> 41:41.020]  это нас избавит
[41:41.020 --> 41:43.020]  от проблем
[41:43.020 --> 41:45.020]  это можно сделать без макросов
[41:45.020 --> 41:47.020]  мы просто пока не умеем
[41:47.020 --> 41:49.020]  научимся через пару семинаров
[41:53.020 --> 41:55.020]  а нет умеем
[42:03.020 --> 42:05.020]  кажется скорее не умеем
[42:05.020 --> 42:07.020]  даже не научимся в таком конкретном кейсе
[42:07.020 --> 42:09.020]  беда
[42:09.020 --> 42:11.020]  ладно, оставим так
[42:11.020 --> 42:13.020]  то есть что произошло
[42:13.020 --> 42:15.020]  мы просто взяли и создали
[42:15.020 --> 42:17.020]  vetable
[42:17.020 --> 42:19.020]  и вся эта муть
[42:19.020 --> 42:21.020]  с ключами value
[42:21.020 --> 42:23.020]  и вот этим страшным паком
[42:23.020 --> 42:25.020]  и специализациями, она автоматом выявилась
[42:25.020 --> 42:27.020]  мы теперь просто указываем список
[42:27.020 --> 42:29.020]  функций, которые мы туда кладем
[42:29.020 --> 42:31.020]  это неплохо
[42:35.020 --> 42:37.020]  вопрос
[42:37.020 --> 42:39.020]  что ли это что нам нужно
[42:47.020 --> 42:49.020]  что?
[42:49.020 --> 42:51.020]  тип вывелся
[42:53.020 --> 42:55.020]  вот этот
[42:55.020 --> 42:57.020]  пак пар
[42:57.020 --> 42:59.020]  из values
[42:59.020 --> 43:01.020]  должны вывестись
[43:01.020 --> 43:03.020]  из fs
[43:03.020 --> 43:05.020]  да, пока не вывелось
[43:05.020 --> 43:07.020]  мы дедакшн гайд не написали
[43:07.020 --> 43:09.020]  мы дедакшн гайд сейчас напишем
[43:09.020 --> 43:11.020]  и все будет хорошо
[43:11.020 --> 43:13.020]  ключи, соответственно
[43:13.020 --> 43:15.020]  из вот этого
[43:15.020 --> 43:17.020]  этой части пака вывелись
[43:27.020 --> 43:29.020]  и values
[43:29.020 --> 43:31.020]  и keys
[43:31.020 --> 43:33.020]  как ты поймешь
[43:33.020 --> 43:35.020]  где я раскраничивается
[43:35.020 --> 43:37.020]  мне кажется это не будет работать
[43:37.020 --> 43:39.020]  давай не будем экспонентировать
[43:39.020 --> 43:41.020]  просто как есть все сделано
[43:41.020 --> 43:43.020]  так, теперь мне кто-то должен
[43:43.020 --> 43:45.020]  будет помочь вспомнить как работает
[43:45.020 --> 43:47.020]  дедакшн гайд
[43:49.020 --> 43:51.020]  вернее какой у них синтаксис
[43:51.020 --> 43:53.020]  это самое нас интересующее
[43:53.020 --> 43:55.020]  кажется мы можем сделать вот так
[43:55.020 --> 43:57.020]  и сказать
[43:57.020 --> 43:59.020]  что если конструктор вызвали
[43:59.020 --> 44:01.020]  от
[44:07.020 --> 44:09.020]  вот так
[44:09.020 --> 44:11.020]  то
[44:11.020 --> 44:13.020]  выводится вот тейбл
[44:13.020 --> 44:15.020]  от
[44:21.020 --> 44:23.020]  нам нужно вывести вот эту
[44:23.020 --> 44:25.020]  пару
[44:35.020 --> 44:37.020]  вот примерно такая жесть
[44:37.020 --> 44:39.020]  keys2
[44:39.020 --> 44:41.020]  искренне надеюсь что это
[44:41.020 --> 44:43.020]  будет работать
[44:43.020 --> 44:45.020]  давайте проверим
[44:45.020 --> 44:47.020]  вот так
[44:51.020 --> 44:53.020]  запятая
[45:01.020 --> 45:03.020]  такая запятая
[45:03.020 --> 45:05.020]  нас не занимается
[45:15.020 --> 45:44.700]  мне кажется нам нужно сделать это так
[45:44.700 --> 45:47.900]  интересно сработает ли это
[45:47.900 --> 46:01.820]  кажется да теперь она работает но только у нас дедакшен 5 не подходит почему не подходит где
[46:01.820 --> 46:15.340]  мы ошиблись да это конечно проблема
[46:15.340 --> 46:33.780]  это проблема проблема в чем мы здесь использовали как бы да кажется если мы сделаем вот так
[46:45.340 --> 46:52.140]  все будет круто нет ничего не будет
[46:53.140 --> 47:04.640]  ну что сделай здесь key 0
[47:04.640 --> 47:24.600]  так мне кажется надо прекратить вот на это тратить время что-то более
[47:24.600 --> 47:30.480]  продуктивное давайте скажем что мы просто будем явно указывать все эти штуки не будем
[47:30.480 --> 47:41.120]  себе пудрить мозги, соответственно в конструктор мы просто принимаем values, конкретные экземпляры,
[47:41.120 --> 47:51.440]  соответственно наши функции, которые мы собираемся вызывать и наших предков нужно
[47:51.440 --> 48:02.720]  инициализировать агрегатно вот valse, то есть в каждого редкого table entry мы кладем
[48:02.720 --> 48:21.640]  соответствующие вот это да конечно это агрегат ну explicit и всякую такую фигню, а что может быть
[48:21.640 --> 48:31.080]  единственная проблема вот эти values мы не сказали от указателей на функции или ссылки на функции это
[48:31.080 --> 48:38.480]  внезапно разные вещи в языке но одно в другое легко превращается так что кажется здесь должно
[48:38.480 --> 48:53.000]  быть нормально то бишь существует вот такой тип, ровно его мы пишем просто до функции, но переменные
[48:53.000 --> 48:58.240]  такого типа нельзя создавать, переменные можно только вот такого типа создавать указательно
[48:58.240 --> 49:08.400]  да и мы хотим вот здесь соответственно указывать все-таки так же как в std function красиво,
[49:08.400 --> 49:19.680]  вот здесь чтобы хранилось все-таки со звездочкой вот и соответственно значение вот эти вот наверное
[49:19.680 --> 49:25.920]  мы тоже хотим принимать указатели поэтому вот как уже правильно замечают есть такая вещь как
[49:25.920 --> 49:33.680]  std dkt которая куча всего разного непонятного делает но помимо прочего оно превращает вот такую
[49:33.680 --> 49:44.960]  штуку вот такую то есть добавляет звездочку вот теперь кажется точно все хорошо давайте
[49:44.960 --> 49:52.240]  мы будем с этим бендрижом все-таки сейчас париться времени маловато давайте создадим
[49:52.240 --> 50:14.000]  лучше какой-нибудь тип, ки у нас будет static string 64, давайте даже лучше сделаем сразу это назовем
[50:14.000 --> 50:20.160]  power table
[50:20.160 --> 50:31.440]  это будет ключ значения, мы их сюда закидываем, чтобы просто не писать каждый раз static string,
[50:31.440 --> 50:36.720]  когда мы будем баловаться с ним, а теперь
[51:07.440 --> 51:14.080]  да это просто план бейсица, все отлично
[51:14.080 --> 51:24.640]  сможем ли мы теперь сделать cool table
[51:24.640 --> 51:28.080]  я слишком много сетета, да
[51:36.720 --> 51:58.160]  ну да это клан
[51:58.160 --> 52:01.680]  ура
[52:01.680 --> 52:08.000]  обернули все в очень обобщенный код, пока непонятно что добились эти
[52:08.000 --> 52:18.320]  о чем мы на самом деле добились, а все, теперь такой полиморфизм как в примере
[52:18.960 --> 52:22.960]  нет давайте на всякий случай чуть-чуть-чуть потестим
[52:36.960 --> 52:38.960]  и попытаемся его вызвать
[52:39.600 --> 52:43.600]  да то есть читать это нужно как бы
[52:51.600 --> 52:53.600]  получили указательную функцию
[52:53.600 --> 52:59.600]  теперь вызовем
[53:09.600 --> 53:13.600]  ура vtable работает
[53:15.600 --> 53:17.600]  начнем копипастить вот этот код
[53:19.600 --> 53:25.600]  наделаем его через наш cool table, а не standard
[53:27.600 --> 53:29.600]  что это значит
[53:33.600 --> 53:37.600]  во-первых все предстоит быть виртуальным
[53:39.600 --> 53:51.600]  сейчас до максимума удобства мы наверное не будем стараться эту штуку довести
[53:51.600 --> 53:59.600]  по конфликту имен добавим слово cool
[54:00.240 --> 54:02.240]  все
[54:12.240 --> 54:16.240]  здесь в самом начале нам хочется vtable звездочка
[54:20.240 --> 54:26.240]  который на самом деле указывает на какой-то статический vtable
[54:26.880 --> 54:32.880]  ровно как тот, который мы объявили
[54:32.880 --> 54:34.880]  давайте его стянем
[54:46.880 --> 54:50.880]  и наверное его объявим online, чтобы все было хорошо
[54:51.520 --> 54:55.520]  наверное его унициализируем
[54:55.520 --> 54:59.520]  да, но не хочет чтобы он у нас без унициализации жук
[54:59.520 --> 55:01.520]  давайте сделаем
[55:01.520 --> 55:07.520]  ну как, нельзя, конструктора-то нет без аргументов
[55:07.520 --> 55:09.520]  значит надо его добавить
[55:10.160 --> 55:14.160]  жук
[55:28.160 --> 55:32.160]  вот непонятно, это просто клан весятся или что-то не так
[55:32.160 --> 55:36.160]  а, равно 0 надо убрать
[55:36.800 --> 55:42.800]  ну да, мы теперь не можем делать функции без объявления
[55:42.800 --> 55:46.800]  ну типа, немножко недавно сработает
[55:46.800 --> 55:48.800]  мы вообще можем эти функции убрать
[55:48.800 --> 55:50.800]  потому что вместо этих объявлений virtual равно 0
[55:50.800 --> 55:52.800]  у нас теперь вот этот vtable
[55:56.800 --> 55:58.800]  который равен
[55:58.800 --> 56:00.800]  тут еще
[56:00.800 --> 56:02.800]  я так плохо называю
[56:02.800 --> 56:04.800]  потому что все равно сейчас
[56:05.440 --> 56:07.440]  поменяю
[56:19.440 --> 56:21.440]  но это дико неудобно
[56:21.440 --> 56:23.440]  каждый раз такую штуку городить
[56:23.440 --> 56:29.440]  более того, если вдруг у нас 2 одинаковых набора
[56:29.440 --> 56:31.440]  вот этих вот всех аргументов
[56:35.440 --> 56:39.440]  сейчас
[56:39.440 --> 56:41.440]  не складывается
[56:41.440 --> 56:43.440]  не складывается
[56:43.440 --> 56:45.440]  не складывается
[56:51.440 --> 56:53.440]  и да
[56:53.440 --> 56:55.440]  давайте пока так продолжим
[56:55.440 --> 56:57.440]  да
[56:57.440 --> 56:59.440]  у него свой vtable
[56:59.440 --> 57:01.440]  в котором
[57:02.080 --> 57:06.080]  давайте даже объявить
[57:12.080 --> 57:14.080]  так
[57:24.080 --> 57:26.080]  так, сделаем
[57:26.720 --> 57:28.720]  ок
[57:28.720 --> 57:30.720]  теперь аналогичная конструкция
[57:30.720 --> 57:32.720]  должна приехать
[57:32.720 --> 57:34.720]  в каждую следующую функцию
[57:34.720 --> 57:36.720]  только теперь
[57:36.720 --> 57:38.720]  да, только здесь
[57:38.720 --> 57:40.720]  теперь нужно вписать наши функции
[57:40.720 --> 57:42.720]  но вот беда
[57:42.720 --> 57:44.720]  мы там сказали, что функции void
[57:44.720 --> 57:46.720]  у нас на самом деле
[57:46.720 --> 57:48.720]  не совсем функция void
[57:48.720 --> 57:50.720]  это методы, которые что-то принимают
[57:50.720 --> 57:52.720]  соответственно, нам такие методы
[57:52.720 --> 57:54.720]  не нужны
[57:55.360 --> 57:57.360]  соответственно, нам таки нужно сказать
[57:57.360 --> 57:59.360]  что здесь мы принимаем
[58:09.360 --> 58:11.360]  и если мы теперь хотим overriding
[58:15.360 --> 58:17.360]  попробуем добиться того
[58:17.360 --> 58:19.360]  чтобы оно ровно с такими явлениями
[58:19.360 --> 58:21.360]  работало
[58:22.000 --> 58:24.000]  для этого нам нужно как-то
[58:24.000 --> 58:26.000]  превратить вот эти функции
[58:26.000 --> 58:28.000]  которые принимают
[58:28.000 --> 58:30.000]  icool base звездочек и запихивают
[58:30.000 --> 58:32.000]  их и вызывают у них
[58:32.000 --> 58:34.000]  ну мы вновь
[58:34.000 --> 58:36.000]  будем
[58:36.000 --> 58:38.000]  делать прикольные мены
[58:42.000 --> 58:44.000]  здесь мы будем делать
[58:44.000 --> 58:46.000]  статик cast
[58:46.000 --> 58:48.000]  нам
[58:48.000 --> 58:50.000]  мы это
[58:50.000 --> 58:52.000]  имеем право делать
[58:52.000 --> 58:54.000]  так как эта функция находится
[58:54.000 --> 58:56.000]  в виртуальной таблице нашей
[58:56.000 --> 58:58.000]  следовательно
[58:58.000 --> 59:00.000]  если из этой виртуальной таблицы
[59:00.000 --> 59:02.000]  что-то вызвалось, значит
[59:02.000 --> 59:04.000]  настоящий динамический тип
[59:04.000 --> 59:06.000]  статик cast мы имеем право делать
[59:14.000 --> 59:16.000]  еще раз, ты не понял, почему
[59:16.000 --> 59:18.000]  можно статик cast
[59:20.000 --> 59:22.000]  конечно
[59:22.000 --> 59:24.000]  да, конечно
[59:30.000 --> 59:32.000]  да
[59:34.000 --> 59:36.000]  так лучше
[59:44.000 --> 59:46.000]  кажется ему совсем
[59:46.000 --> 59:48.000]  плосо, надо
[59:48.000 --> 59:50.000]  отправлять
[59:50.000 --> 59:52.000]  окей
[59:52.000 --> 59:54.000]  это же еще не все
[59:54.000 --> 59:56.000]  мы вот так делаем
[59:56.000 --> 59:58.000]  на самом деле у нас там пары принимались
[59:58.000 --> 01:00:00.000]  теперь нам нужно
[01:00:00.000 --> 01:00:02.000]  через запятую
[01:00:02.000 --> 01:00:04.000]  имя вроде
[01:00:04.000 --> 01:00:06.000]  так же мы делали
[01:00:06.000 --> 01:00:08.000]  да
[01:00:08.000 --> 01:00:10.000]  нет, мы не так делали
[01:00:10.000 --> 01:00:12.000]  нет, мы просто в том же порядке, в котором их объявили
[01:00:12.000 --> 01:00:14.000]  да, мы
[01:00:14.000 --> 01:00:16.000]  отбросили эту идею
[01:00:16.000 --> 01:00:18.000]  потому что ничего чуть-чуть не получилось
[01:00:18.000 --> 01:00:20.000]  и проще так
[01:00:20.000 --> 01:00:22.000]  похоже на правду
[01:00:22.000 --> 01:00:24.000]  мне кажется похоже
[01:00:26.000 --> 01:00:28.000]  если есть вопросы
[01:00:28.000 --> 01:00:30.000]  давайте это обсудим
[01:00:30.000 --> 01:00:32.000]  мне хочется чтобы мы сейчас
[01:00:32.000 --> 01:00:34.000]  поняли какую магию мы
[01:00:34.000 --> 01:00:36.000]  руками сделали
[01:00:36.000 --> 01:00:38.000]  оп-полиморфизм без оп
[01:00:42.000 --> 01:00:44.000]  вот так
[01:00:44.000 --> 01:00:46.000]  ну и все в принципе
[01:00:46.000 --> 01:00:48.000]  конечно все это можно вернуть в макросы
[01:00:48.000 --> 01:00:50.000]  какие-нибудь классные
[01:00:50.000 --> 01:00:52.000]  да
[01:00:52.000 --> 01:00:54.000]  еще не все
[01:00:54.000 --> 01:00:56.000]  мы вот здесь вот так сделали, но это конечно же не то
[01:00:56.000 --> 01:00:58.000]  что нам нужно
[01:00:58.000 --> 01:01:00.000]  да, мы хотим родительский table
[01:01:00.000 --> 01:01:02.000]  подменять на наш конструктор
[01:01:02.000 --> 01:01:04.000]  ровно это мы и сделаем
[01:01:06.000 --> 01:01:08.000]  как бы в конструкторе
[01:01:08.000 --> 01:01:10.000]  говорим
[01:01:14.000 --> 01:01:16.000]  как мы его назвали
[01:01:26.000 --> 01:01:28.000]  мне почему-то кажется, что в деструктуре
[01:01:28.000 --> 01:01:30.000]  мы тоже кое-что должны сделать
[01:01:30.000 --> 01:01:32.000]  вопрос что
[01:01:34.000 --> 01:01:36.000]  что будет, если мы
[01:01:36.000 --> 01:01:38.000]  уничтожаем
[01:01:38.000 --> 01:01:40.000]  объект типа cool-drive1
[01:01:40.000 --> 01:01:42.000]  у него
[01:01:42.000 --> 01:01:44.000]  в конструкторе table
[01:01:44.000 --> 01:01:46.000]  положилась вот эта штука
[01:01:46.000 --> 01:01:48.000]  а потом кто-то из предков например
[01:01:48.000 --> 01:01:50.000]  iql-base в деструктуре решил
[01:01:50.000 --> 01:01:52.000]  виртуальную штуку вызвать
[01:01:54.000 --> 01:01:56.000]  как бы вызваться все будет нормально
[01:01:56.000 --> 01:01:58.000]  вызваться вот эта вот функция
[01:01:58.000 --> 01:02:00.000]  которая прикастит
[01:02:00.000 --> 01:02:02.000]  да прикастит base-cool-drive1
[01:02:02.000 --> 01:02:04.000]  который уже как бы уничтожен
[01:02:04.000 --> 01:02:06.000]  во внешнюю оболочку
[01:02:06.000 --> 01:02:08.000]  над-объект уже как бы начали
[01:02:08.000 --> 01:02:10.000]  удалять
[01:02:10.000 --> 01:02:12.000]  и беда
[01:02:12.000 --> 01:02:14.000]  cool-drive1 уже удален
[01:02:14.000 --> 01:02:16.000]  а base еще нет
[01:02:16.000 --> 01:02:18.000]  нам прислали base у которого
[01:02:18.000 --> 01:02:20.000]  как бы нет cool-drive1 части
[01:02:20.000 --> 01:02:22.000]  мы его кстати кастнули и взрыв
[01:02:26.000 --> 01:02:28.000]  да, нам нужно делать
[01:02:28.000 --> 01:02:30.000]  table
[01:02:36.000 --> 01:02:38.000]  конечно мне хотелось чтобы все было гораздо красивее
[01:02:38.000 --> 01:02:40.000]  автоматизировать не стримлайн
[01:02:40.000 --> 01:02:42.000]  но
[01:02:42.000 --> 01:02:44.000]  судьба такова что
[01:02:44.000 --> 01:02:46.000]  придется
[01:02:48.000 --> 01:02:50.000]  ура
[01:02:50.000 --> 01:02:52.000]  билдес
[01:02:56.000 --> 01:02:58.000]  drive2 drive2
[01:02:58.000 --> 01:03:00.000]  fullbar
[01:03:00.000 --> 01:03:02.000]  отлично
[01:03:02.000 --> 01:03:04.000]  вопрос а как вызвать
[01:03:04.000 --> 01:03:06.000]  давайте iql-base
[01:03:06.000 --> 01:03:08.000]  перемешаем
[01:03:10.000 --> 01:03:12.000]  ну тут как бы опять хочется
[01:03:12.000 --> 01:03:14.000]  какой-нибудь rtp использовать чтобы на самом деле
[01:03:14.000 --> 01:03:16.000]  подмешивать вот этот вот getable
[01:03:16.000 --> 01:03:18.000]  и вот эту штуку тоже подмешивать
[01:03:18.000 --> 01:03:20.000]  но это слишком для крутых ребят
[01:03:20.000 --> 01:03:22.000]  мы сделаем пока тупо
[01:03:22.000 --> 01:03:24.000]  мы просто сделаем
[01:03:26.000 --> 01:03:28.000]  ничего не будем делать
[01:03:28.000 --> 01:03:30.000]  зачем мне ее писать
[01:03:32.000 --> 01:03:34.000]  да, поехали
[01:03:34.000 --> 01:03:36.000]  iql-base
[01:03:36.000 --> 01:03:38.000]  равно
[01:03:38.000 --> 01:03:40.000]  ui-drive
[01:03:40.000 --> 01:03:42.000]  cool-drive1
[01:03:42.000 --> 01:03:44.000]  2
[01:03:44.000 --> 01:03:46.000]  base1
[01:03:46.000 --> 01:03:48.000]  base2
[01:03:48.000 --> 01:03:50.000]  каких тебе по мне
[01:03:58.000 --> 01:04:00.000]  нет там буквы не
[01:04:00.000 --> 01:04:02.000]  ура
[01:04:06.000 --> 01:04:08.000]  ура
[01:04:08.000 --> 01:04:10.000]  base1
[01:04:10.000 --> 01:04:12.000]  double
[01:04:16.000 --> 01:04:18.000]  get
[01:04:18.000 --> 01:04:20.000]  шаблон
[01:04:22.000 --> 01:04:24.000]  да
[01:04:24.000 --> 01:04:26.000]  get по ключу
[01:04:30.000 --> 01:04:32.000]  и вызываем это
[01:04:32.000 --> 01:04:34.000]  конечно не очень удобно
[01:04:36.000 --> 01:04:38.000]  да
[01:04:38.000 --> 01:04:40.000]  вот какую обертку мы можем написать iql-base для удобства
[01:04:40.000 --> 01:04:42.000]  мы можем делать диспетчеризацию
[01:04:42.000 --> 01:04:44.000]  через
[01:04:44.000 --> 01:04:46.000]  value-tag
[01:05:00.000 --> 01:05:02.000]  сейчас
[01:05:02.000 --> 01:05:04.000]  как мы это хотим
[01:05:10.000 --> 01:05:12.000]  мы хотим чтобы это
[01:05:12.000 --> 01:05:14.000]  был template
[01:05:14.000 --> 01:05:16.000]  или нет
[01:05:16.000 --> 01:05:18.000]  да, это будет template
[01:05:20.000 --> 01:05:22.000]  static stream
[01:05:22.000 --> 01:05:24.000]  4s
[01:05:24.000 --> 01:05:26.000]  который лежит вот здесь
[01:05:26.000 --> 01:05:28.000]  и
[01:05:30.000 --> 01:05:32.000]  некоторые аргументы для вызову
[01:05:34.000 --> 01:05:36.000]  возвращать он будет
[01:05:36.000 --> 01:05:38.000]  угадайте что
[01:05:38.000 --> 01:05:40.000]  table
[01:05:40.000 --> 01:05:42.000]  table
[01:05:48.000 --> 01:05:50.000]  table get
[01:05:50.000 --> 01:05:52.000]  s
[01:05:54.000 --> 01:05:56.000]  args
[01:05:56.000 --> 01:05:58.000]  args
[01:05:58.000 --> 01:06:00.000]  args
[01:06:00.000 --> 01:06:02.000]  forward
[01:06:02.000 --> 01:06:04.000]  args
[01:06:04.000 --> 01:06:06.000]  forward
[01:06:06.000 --> 01:06:08.000]  args
[01:06:08.000 --> 01:06:10.000]  forward
[01:06:10.000 --> 01:06:12.000]  forward
[01:06:12.000 --> 01:06:14.000]  forward
[01:06:14.000 --> 01:06:16.000]  get
[01:06:16.000 --> 01:06:18.000]  get
[01:06:18.000 --> 01:06:20.000]  get
[01:06:20.000 --> 01:06:22.000]  get
[01:06:22.000 --> 01:06:24.000]  этот get нам еще и указательно
[01:06:24.000 --> 01:06:26.000]  возвращает
[01:06:26.000 --> 01:06:28.000]  так
[01:06:28.000 --> 01:06:30.000]  это уже будет работать
[01:06:30.000 --> 01:06:32.000]  проверим
[01:06:32.000 --> 01:06:34.000]  base 1
[01:06:34.000 --> 01:06:36.000]  virtual call
[01:06:38.000 --> 01:06:40.000]  foo
[01:06:42.000 --> 01:06:44.000]  да
[01:06:44.000 --> 01:06:46.000]  и мы никаких аргументов не передаем
[01:06:46.000 --> 01:06:48.000]  теперь base 2 позовем
[01:06:48.000 --> 01:06:50.000]  foo
[01:06:52.000 --> 01:06:54.000]  эксперименты
[01:06:56.000 --> 01:06:58.000]  и
[01:06:58.000 --> 01:07:00.000]  get
[01:07:02.000 --> 01:07:04.000]  да, действительно
[01:07:06.000 --> 01:07:08.000]  попытка номер 2
[01:07:08.000 --> 01:07:10.000]  нет
[01:07:18.000 --> 01:07:20.000]  а, нам нельзя забывать про this
[01:07:20.000 --> 01:07:22.000]  this
[01:07:24.000 --> 01:07:26.000]  вот что мы забыли
[01:07:36.000 --> 01:07:38.000]  да, оно работает
[01:07:40.000 --> 01:07:42.000]  виртуальная таблица вызовов руками
[01:07:42.000 --> 01:07:44.000]  на костылях
[01:07:44.000 --> 01:07:46.000]  какие ограничения
[01:07:46.000 --> 01:07:48.000]  и что вы можете сделать если вам вдруг очень
[01:07:48.000 --> 01:07:50.000]  хочется поиграться с этим
[01:07:52.000 --> 01:07:54.000]  первая проблема
[01:07:54.000 --> 01:07:56.000]  расширение этой виртуальной таблицы
[01:07:58.000 --> 01:08:00.000]  если мы в CoolDirect
[01:08:00.000 --> 01:08:02.000]  хотим добавить
[01:08:02.000 --> 01:08:04.000]  еще один виртуальный
[01:08:04.000 --> 01:08:06.000]  метод
[01:08:06.000 --> 01:08:08.000]  его нужно добавить в таблицу
[01:08:08.000 --> 01:08:10.000]  да, идти в таблицу уже меняется
[01:08:10.000 --> 01:08:12.000]  но вообще говоря
[01:08:12.000 --> 01:08:14.000]  мы можем
[01:08:14.000 --> 01:08:16.000]  заменив
[01:08:16.000 --> 01:08:18.000]  вот эту вещь
[01:08:18.000 --> 01:08:20.000]  на
[01:08:22.000 --> 01:08:24.000]  как бы наследование от vtable
[01:08:24.000 --> 01:08:26.000]  с откусанным
[01:08:26.000 --> 01:08:28.000]  последним аргументом
[01:08:30.000 --> 01:08:32.000]  да, мы как бы генерируем
[01:08:32.000 --> 01:08:34.000]  иерархию в каком-то смысле
[01:08:34.000 --> 01:08:36.000]  откусываем из начала по одному
[01:08:36.000 --> 01:08:38.000]  одной функции
[01:08:38.000 --> 01:08:40.000]  одной паре ключа значения
[01:08:40.000 --> 01:08:42.000]  и это нам позволит
[01:08:42.000 --> 01:08:44.000]  кастить vtable
[01:08:44.000 --> 01:08:46.000]  который содержит
[01:08:46.000 --> 01:08:48.000]  на одну функцию больше
[01:08:48.000 --> 01:08:50.000]  помимо всех таких же
[01:08:50.000 --> 01:08:52.000]  к тем кто
[01:08:52.000 --> 01:08:54.000]  как бы к родительским vtable
[01:08:56.000 --> 01:08:58.000]  т.б. vtable который содержит
[01:08:58.000 --> 01:09:00.000]  примерно вот такие функции
[01:09:00.000 --> 01:09:02.000]  void от int
[01:09:02.000 --> 01:09:04.000]  и void от la
[01:09:06.000 --> 01:09:08.000]  его должно быть можно
[01:09:08.000 --> 01:09:10.000]  прикастить к vtable который содержит
[01:09:10.000 --> 01:09:12.000]  void от int
[01:09:12.000 --> 01:09:14.000]  но это сигнатура
[01:09:14.000 --> 01:09:16.000]  ключи считаем что
[01:09:16.000 --> 01:09:18.000]  одинаковые
[01:09:18.000 --> 01:09:20.000]  да, давайте даже напишем
[01:09:20.000 --> 01:09:22.000]  вот если у нас есть foo
[01:09:22.000 --> 01:09:24.000]  в одном vtable
[01:09:24.000 --> 01:09:26.000]  в другом vtable foo и bar
[01:09:26.000 --> 01:09:28.000]  в третьем foo, bar
[01:09:28.000 --> 01:09:30.000]  и bus
[01:09:32.000 --> 01:09:34.000]  вот этот vtable
[01:09:34.000 --> 01:09:36.000]  должно быть возможно
[01:09:36.000 --> 01:09:38.000]  скастить к вот этому
[01:09:38.000 --> 01:09:40.000]  в таблицу
[01:09:40.000 --> 01:09:42.000]  да, статически
[01:09:42.000 --> 01:09:44.000]  то есть просто вот этот
[01:09:44.000 --> 01:09:46.000]  должен наследовать вот этот
[01:09:46.000 --> 01:09:48.000]  должен наследовать вот этот
[01:09:48.000 --> 01:09:50.000]  это вам позволит
[01:09:52.000 --> 01:09:54.000]  в детях хранить статическую
[01:09:54.000 --> 01:09:56.000]  переменную
[01:09:56.000 --> 01:09:58.000]  с вот таким
[01:09:58.000 --> 01:10:00.000]  vtable
[01:10:02.000 --> 01:10:04.000]  а в родителях с вот таким
[01:10:04.000 --> 01:10:06.000]  vtable, ну не статическую
[01:10:06.000 --> 01:10:08.000]  переменную, а вот
[01:10:08.000 --> 01:10:13.080]  ну не статическую переменную, да и указатель, нет статическую переменную
[01:10:13.080 --> 01:10:20.720]  я уверен, что сейчас ничего не понятно, но давайте назовем эти типы как-то, что вот как бы
[01:10:20.720 --> 01:10:27.640]  table такого формата, table3 это table2
[01:10:27.640 --> 01:10:34.280]  в родителе может храниться указатель на table2
[01:10:34.280 --> 01:10:44.440]  равно три точки, а ребенок может создать table вот такой, основной функции больше
[01:10:44.440 --> 01:10:53.640]  после чего прикастить к вот этому и положить в родителя вот этот указатель на table
[01:10:53.640 --> 01:11:00.960]  если вот эта штука как бы реально наследует вот эту, а этот наследует вот эту и при каждом
[01:11:00.960 --> 01:11:04.560]  наследовании у нас на одну большую функцию становится, то мы так можем
[01:11:04.560 --> 01:11:12.400]  и это собственно и позволяет нам в ребенке добавить еще одну новую виртуальную функцию,
[01:11:12.400 --> 01:11:20.440]  которую его уже дети смогут перегружать, вот это первое, что здесь нужно пофиксить
[01:11:20.440 --> 01:11:33.320]  нет, он один, да вот такой table2 звездочка один, но туда можно как бы положить любого
[01:11:33.320 --> 01:11:40.880]  наследника, указатель на любого наследника и потом статик кастами приводить обратно к нужному
[01:11:40.880 --> 01:11:51.840]  да, на самый верхний один указатель, да, иначе будет что-то очень странное происходить
[01:11:51.840 --> 01:11:59.600]  я хочу сделать на эту задачу, но мне скорее всего не будет времени, поэтому не сделаю
[01:11:59.600 --> 01:12:13.280]  да, мне кажется третьей задачей можно в таком стиле что-то написать, еще тут еще не так, да,
[01:12:13.280 --> 01:12:21.840]  множественное наследование, мы пока его вообще никак не умеем контролировать, что произойдет,
[01:12:21.840 --> 01:12:28.960]  если у нас несколько наследников, у них разные таблицы, нужно как бы уметь верайдить и туда и туда
[01:12:28.960 --> 01:12:40.160]  а наши таблицы это должна быть как бы комбинацией их таблиц, не сильно думайте об этом, это нужно
[01:12:40.160 --> 01:12:53.640]  долго писать и вникать, ну что-то такое, причем эта идея, она немного артагональна идее вот этой вот,
[01:12:53.640 --> 01:13:03.360]  потому что вот такие две штуки сконконтонировать мы как бы не особо можем, и мне кажется это супер
[01:13:03.360 --> 01:13:07.520]  такое хардкорное упражнение сделать эту штуку с поддержкой множественного наследования,
[01:13:07.520 --> 01:13:12.120]  а потом подъезжает виртуальное наследование и вообще просто пиши пропало, давайте,
[01:13:12.120 --> 01:13:21.160]  вот, но идея вот этих вот виртуальных таблиц, которые можно в шаблонах просто явно прописать
[01:13:21.160 --> 01:13:25.240]  и как бы использовать, она не ограничивается ОП-шкой
[01:13:27.680 --> 01:13:34.840]  остановились мы на том, что накостреляли VTABLE, сказали, что можно сделать его конечно и лучше,
[01:13:34.840 --> 01:13:42.400]  гораздо лучше, но очень сложно, и мы сейчас немножко в другую сторону пойдем, чтобы более
[01:13:42.400 --> 01:13:56.560]  интересное применение этого VTABLE увидеть, давайте как-то вот эти прикольные классы, все
[01:13:56.560 --> 01:14:11.600]  namespace.op бахнем, и туда же вот это все бахнет
[01:14:26.560 --> 01:14:47.800]  так, все, да, значит поехали, то о чем я с Anycustom пытался донести мысль, если мы пишем люто-шаблонный код,
[01:14:47.800 --> 01:14:55.160]  и нам присылают какой-то какие-то те каким-то образом почему-то,
[01:14:55.160 --> 01:15:20.200]  например, что-то такое, и нам понадобилось сделать swap,
[01:15:25.160 --> 01:15:41.360]  что будет происходить, ну, во-первых, обычно мы std swap пишем, ну, как правило, человек сел сядь на
[01:15:41.360 --> 01:15:49.760]  плясах, он ставит функцию std swap, а почему это не очень хорошо, потому что std swap он как реализован,
[01:15:49.760 --> 01:16:05.760]  он делает три move, ну да, но вот по дефолту swap делает три move, а что если тип лежит в какой-то другой библиотеке,
[01:16:05.760 --> 01:16:14.480]  эти move не заинлайнятся, и они там ну плюс-минус дорогие, три вызова функции из какой-то другой
[01:16:14.480 --> 01:16:24.120]  библиотеке, которая еще там что-то делает, очень часто есть способ сделать swap дешевле, это возможно
[01:16:24.120 --> 01:16:31.360]  микро оптимизм, но тем не менее стандарт позволяет кастомизировать swap, то есть если у вас в каком-нибудь
[01:16:31.360 --> 01:16:49.640]  namespace есть какая-то структурка, вы можете прямо в этом namespace сделать swap для этой структурки,
[01:16:49.640 --> 01:17:06.120]  и вообще говоря хотелось бы, чтобы этот swap можно было использовать в обобщенных алгоритмах,
[01:17:06.120 --> 01:17:19.320]  и это работает, если вы используете какой-нибудь стандартный алгоритм для структурки s, ну или там
[01:17:19.320 --> 01:17:32.080]  я не знаю, какой-нибудь sort, используйте для вектора s, вероятно sort внутри использует где-нибудь swap,
[01:17:32.080 --> 01:17:39.880]  ну как бы это зависит от имплементации, конечно же какой у них там sort, но вероятно, предположим это пузырик,
[01:17:39.880 --> 01:17:46.080]  и вот этот swap из стандартной библиотеки, если он там конечно есть, он обязательно найдет вот эту
[01:17:46.080 --> 01:18:01.840]  функцию swap, каким образом? алгоритм стандартной библиотеки, если он использует swap, да он найдет,
[01:18:01.840 --> 01:18:11.160]  почему? argument-dependent lookup это называется, я не помню, обсуждали ли мы это с вами, скорее всего нет,
[01:18:11.160 --> 01:18:26.480]  но если мы пишем вот такой вот вызов, то есть unqualified без уточнения namespace, то вот эту функцию
[01:18:26.480 --> 01:18:32.400]  swap будут искать не только в глобальном namespace, а еще и во всех namespace связанных с типом
[01:18:32.400 --> 01:18:47.800]  аргументов, то есть связанных с типом ten, если мы сейчас запустим эту функцию foo от sss,
[01:18:47.800 --> 01:19:08.560]  сделаем из этого вектора, то все будет работать,
[01:19:08.560 --> 01:19:27.280]  давайте даже в качестве обязательства выведем, отлично,
[01:19:38.560 --> 01:19:57.560]  ты про то, что swap должен быть концептами какими-то связанными,
[01:19:57.560 --> 01:20:14.760]  ну да, мы конечно вот нехорошо сделали, конечно по стандарту, если вы вот такую штуку сделали и
[01:20:14.760 --> 01:20:24.440]  определили в связанном с namespace операцию swap для s, то вы уже подписывайтесь выполнять семантику
[01:20:24.440 --> 01:20:39.840]  swap в этой функции или у вас ub, то это ub, это одна из проблем, в которой я иду, среди таких
[01:20:39.840 --> 01:20:48.560]  функций swap, считайте глобально зарезервированные имя, begin, есть такая функция std begin от контейнера,
[01:20:48.560 --> 01:20:55.840]  стд end от контейнера, все эти функции это такие глобально зарезервированные имена, также называемые
[01:20:55.840 --> 01:21:03.320]  точками кастомизации, такие функции, которые нужны примерно для всего подряд на свете и
[01:21:03.320 --> 01:21:09.320]  хочется уметь их кастомизировать, помимо вот дефолтного какого-то определения, для конкретных
[01:21:09.320 --> 01:21:18.200]  типов, например, стд begin кастомизирован, чтобы если от него передали сишный массив,
[01:21:18.200 --> 01:21:30.040]  он все равно не ломался, как и стд end, это тоже такой поинт, что если у вас, давайте даже так
[01:21:30.040 --> 01:21:41.640]  сделаем для пущего эффекта, если у вас какой-то неизвестный контейнер в шаблонном коде, делать
[01:21:41.640 --> 01:21:50.680]  вот так нельзя, это не корректный шаблонный код, потому что в качестве контейнера могут
[01:21:50.680 --> 01:22:01.800]  передать сишный массив, вообще говоря, а правильно делать стд begin от век, и вот он уже умеет
[01:22:01.800 --> 01:22:10.880]  обрабатывать, он умеет обрабатывать сишные массивы, еще какие-то коронаптехи есть на самом деле,
[01:22:10.880 --> 01:22:25.680]  систроки, мне кажется, и подобные штуки, в общем не будем, коронаптехи бывают, так вот,
[01:22:25.680 --> 01:22:41.240]  на чем остановился, ну окей, мы написали, круто, кастомизируется, и не работает, давайте
[01:22:41.240 --> 01:22:50.360]  скомпилим, чтобы более адекватное сообщение об ошибке, да swap not defined, потому что мы сюда
[01:22:50.360 --> 01:22:58.600]  пихнули int, и как мы как бы, у нас нет такой функции swap, у нас даже нет namespace связанного
[01:22:58.600 --> 01:23:08.480]  с int, в котором бы моглась найти функцию swap, ну мы напишем не std swap, мы напишем using std swap
[01:23:08.480 --> 01:23:21.440]  и после этого swap, и здесь тоже самое, using std begin, а потом просто begin, таким образом в список
[01:23:21.440 --> 01:23:29.600]  функции, которые будут рассмотрены, добавляются, во-первых, std swap, который мы заюзингали, поэтому
[01:23:29.600 --> 01:23:34.800]  к нему можно без qualifiers обращаться, во-вторых, любой слог, который лежит в связанном namespace
[01:23:34.800 --> 01:23:41.560]  с типами аргументов, то есть вот этот слог, и вот это уже корректно написанный шаблонный код,
[01:23:41.560 --> 01:23:52.240]  который уважает точки кастомизации стандарта, ну постепенно, да, это первый шаг программы,
[01:23:52.240 --> 01:24:01.560]  вот, но нам же нифига не удобно вот так делать, ну come on, кто помнит в шаблонном коде, что каждый
[01:24:01.560 --> 01:24:07.920]  раз, когда ты там вызвал какую-то из вот этого списка функций стандарта, нужно обязательно сделать это
[01:24:07.920 --> 01:24:18.400]  вот таким образом, но это больно, поэтому в каком-то там, то ли 14, то ли 11 году мистер Эрик Нибблер придумал
[01:24:18.400 --> 01:24:35.240]  чит хак вообще убойный, чит хак заключается в следующем, правда, чит хак должен находиться в том
[01:24:35.240 --> 01:24:40.920]  месте, где мы первый раз объявляем вот эту точку кастомизации swap, то есть в том месте, где std swap объявлен,
[01:24:40.920 --> 01:24:48.560]  так как мы силами менять стд либо не обладаем, мы будем свою точку кастомизации объявлять,
[01:24:48.560 --> 01:25:03.720]  mybegin, например, давайте сбихнем это, как бы лучше все это сделать, давайте вот здесь, да,
[01:25:03.720 --> 01:25:12.840]  сделаем какую-то функцию, не так, трюк начинает с того, что мы теперь используем не функции,
[01:25:12.840 --> 01:25:17.800]  а мы используем как бы функторы, но лучше говорить функциональные объекты,
[01:25:17.800 --> 01:25:29.840]  да, я обожаю спорить на эту тему, то бишь, что я имею в виду, мы делаем inline, статик не статик,
[01:25:29.840 --> 01:25:46.560]  пока не важно, он стэкспор, стракт, mycpo назовем, и что может делать наша цеплошка,
[01:25:46.560 --> 01:25:53.120]  давайте она будет принт делать, это будет наш принт, и назовем принт cpo,
[01:25:53.120 --> 01:26:03.480]  окей, вас не смущает этот лютый синтаксис? вас он должен смущать всех,
[01:26:03.480 --> 01:26:14.600]  то есть что мы здесь сделали, да, мы как бы прямо внутри объявления переменной объявили структурку,
[01:26:14.600 --> 01:26:36.000]  типа которой она будет, без понятия о чем речь, ну ладно,
[01:26:36.000 --> 01:26:46.960]  окей, ну да, это такая типа древняя техника, так носи писать очень любили,
[01:26:46.960 --> 01:26:55.220]  ну и сейчас так носи пишут, но в писах редко встречается, вот здесь как раз, вот, и мы хотим в
[01:26:55.220 --> 01:27:05.320]  итоге вот эту точку кастомизации запускать принт, и это сразу нам на самом деле несколько проблем
[01:27:05.320 --> 01:27:12.680]  решит, ну понятно, ладно, пока не решит, окей, соответственно, если мы собрались запускать эту
[01:27:12.680 --> 01:27:26.680]  штуку, у нее должен быть оператор круглой скобки, давайте он будет принимать что угодно, конечно же,
[01:27:26.680 --> 01:27:45.040]  возвращать ничего и делать какой-то дефолт адекватный, будем писать unknown,
[01:27:45.040 --> 01:27:59.080]  дефолтной имплементации, так, так, так, все хорошо, теперь если мы вот так вот сделаем, туда запихнем нашу
[01:27:59.080 --> 01:28:16.840]  давайте даже эту эсочку в другой namespace запихнем, что, что, да, сейчас я,
[01:28:16.840 --> 01:28:24.840]  возникли ли у меня проблемы, если они в одном namespace, мне кажется, может, это будет, это
[01:28:24.840 --> 01:28:34.800]  my space, namespace, my, нет, ладно, должно быть, я помню, что это работает, значит у нас заработает, все,
[01:28:34.800 --> 01:28:54.000]  да, конечно же, нам нужно эту штуку пометить const и не const, а static, просто const,
[01:28:54.000 --> 01:29:05.680]  окей, окей, окей, здорово, пока ничего не добились хорошего,
[01:29:05.680 --> 01:29:21.000]  давайте лучше все в кинепринт, не могу я решиться, лучше мы сделаем свою точку
[01:29:21.000 --> 01:29:32.800]  кастомизации для свопа, и будет он принимать уже теперь не 1, а 2,
[01:29:32.800 --> 01:29:57.840]  да, а будет делать он следующее, ровно тот самый бюфазный лукап, вот этот вот кастильный,
[01:29:57.840 --> 01:30:04.680]  ну, типа, вот этот странный способ делать шаблонный код, конечно же, здесь немножко не хватает
[01:30:04.680 --> 01:30:14.600]  форварда, но меня недавно научили, что форвард можно вот так делать, потому что в слове форвард много букв,
[01:30:14.600 --> 01:30:28.400]  а времени бесконечно, надо сокращать код, код, да, ну, кстати, каст тоже долго писать, понимаешь,
[01:30:28.400 --> 01:30:38.000]  это очень много бюф, для кода на семинаре отлично, вот в чем трюк, трюк заключается в следующем,
[01:30:38.000 --> 01:30:41.960]  что, мне кажется, мы даже это можем просто слабо назвать,
[01:30:41.960 --> 01:30:58.600]  а да, у нас есть вот этот фигетин еще, сейчас, давайте сделаем так,
[01:30:58.600 --> 01:31:17.640]  нет, так и задуман, давайте для индикации того, что происходит увидим кирк, и теперь попробуем просто
[01:31:17.640 --> 01:31:33.480]  где-нибудь взять, а собственно, что нам пытаться, вот у нас здесь есть, вот это уберем, внимание, что получится,
[01:31:33.480 --> 01:31:58.120]  да, почему три раза, вызвали один раз, интересно, трюк очень сложный просто, но что должно было произойти?
[01:31:58.120 --> 01:32:17.720]  а потому что, нормально, трюк удался, все нормально,
[01:32:17.720 --> 01:32:40.320]  в чем заключается трюк, да, в чем заключается трюк, когда мы объявили переменную, а это перемен,
[01:32:40.320 --> 01:32:51.120]  в глобальном namespace, мы на самом деле зашедовали, а даже для пущего эффекта, мы это пишем namespace.std,
[01:32:51.120 --> 01:33:19.840]  в общем, идея в чем, вот такой вызов через объект, глобальный, его оператор круглые скобки,
[01:33:19.840 --> 01:33:27.200]  он на самом деле отключает ADATE, если мы сейчас положим вот эту вот штуку в какой-то,
[01:33:27.200 --> 01:33:40.600]  ладно, давайте не будем про это, тут очень сложно последовательно все рассказать, беда.
[01:33:40.600 --> 01:34:00.480]  она будет приоритетней, чем любая функция слов, вот в этом прикол, да, то есть, да, вот-вот-вот-вот-вот,
[01:34:00.480 --> 01:34:07.000]  все, я сформулировал мысли, нет, я думаю, мне стало полегче, нет, не стало, вот здесь, раньше,
[01:34:07.000 --> 01:34:14.800]  пока не добавили вот эту фигню, у нас вызывался слоп, который лежал внутри, став s, слоп, который
[01:34:14.800 --> 01:34:23.080]  лежал вот здесь, так, теперь, когда мы добавили вот такую штуку, почему-то вызывается не вот этот
[01:34:23.080 --> 01:34:35.440]  слоп, который функцией найденной ADL, а оператор круглые скобки у объекта, почему так, потому что
[01:34:35.440 --> 01:34:45.520]  вот этот слоп, он в приоритете над всеми остальными как бы функциями, которые также называются,
[01:34:45.520 --> 01:34:55.120]  могут быть найдены там ADL или еще как-то, вызов, вернее так, определение имени как название глобальной
[01:34:55.120 --> 01:35:02.120]  применной в приоритете над определением имени как вызовов функции или как функции, и вот на этом
[01:35:02.120 --> 01:35:09.640]  основан этот лютый трюк, мы специально всегда вот такие вызовы слоп теперь пропускаем через вот
[01:35:09.640 --> 01:35:16.040]  такую конструкцию, и там уже обрабатываем вариант, что у нас может быть из-за стд-слоп, а может быть
[01:35:16.040 --> 01:35:35.640]  найден ADL слоп, вот, и этот, да, что ты имеешь ввиду, давай теперь в namespace,
[01:35:35.640 --> 01:35:59.080]  mylib, да, что значит как бы не обращались, что ты имеешь ввиду,
[01:36:05.640 --> 01:36:15.560]  а, в плане, что если, да, в плане, что такая же функция foo или там bar, она может лежать в том же namespace и
[01:36:15.560 --> 01:36:22.480]  просто как бы вот так делать, и ей уже не нужно указывать qualified имя, ну, в общем, это немножко
[01:36:22.480 --> 01:36:30.000]  упорядочивает вот этот вот весь ад с метапрошным вызовом каких-либо точек кастомизации, потому что по
[01:36:30.000 --> 01:36:37.280]  дефолту нужно вот так писать, везде всегда помнить, а если все вернуть такой вот трюк, то не нужно
[01:36:37.280 --> 01:36:44.520]  об этом думать, просто пишите, хоть mylib2.swap, хоть и просто swap, если уже внутри этой библиотеки,
[01:36:44.520 --> 01:36:58.640]  и все работает, и называется этот трюк, и вот этот объект nebloid, вот, где же нам нужны nebloids,
[01:36:58.640 --> 01:37:07.440]  ну, как оказалось, не совсем nebloids там нужны, а даже более прокачанная вещь,
[01:37:07.440 --> 01:37:15.800]  где же они, а может header видим, что не так,
[01:37:15.800 --> 01:37:20.760]  ой, они еще по переименованию,
[01:37:20.760 --> 01:37:34.240]  не, да, раньше было написано nebloid, красивое же слово, а, теперь customization.object,
[01:37:34.240 --> 01:37:47.560]  да, это, я думаю, достаточно очевидно, nebler, nebloid, история заключается в следующем, один
[01:37:47.560 --> 01:37:53.440]  из редакторов cppreferent спрашивает, как мне назвать вот эти выпендрежные супер дупер объекты от Эрика,
[01:37:53.440 --> 01:38:02.200]  ответ Эрика, могу ли я со всей скромностью посоветовать имя nebloids, следующее сообщение,
[01:38:02.200 --> 01:38:09.000]  это скрин, где везде проставлено слово nebloid, но с тех пор они его поменяли, беда, ну вот,
[01:38:09.000 --> 01:38:26.160]  да, begin и end и прочие вещи в рэпжах, они такие nebloids, окей, ну, видимо, где-то поменяли, где-то нет,
[01:38:26.160 --> 01:38:42.120]  вот, то есть как бы inline constexpr unspecified begin равно unspecified, то есть это переменная
[01:38:42.120 --> 01:38:52.120]  непонятного типа в непонятном namespace, да, ну и на самом деле выглядит оно вот примерно так,
[01:38:52.120 --> 01:39:15.040]  как мы здесь написали, давайте посмотрим из любопытства, inline constexpr cast access begin,
[01:39:15.040 --> 01:39:27.760]  begin, ровно оно, только тут куча всяких выпендрежей, да, там require сами их связывают, в общем,
[01:39:27.760 --> 01:39:34.880]  все круто, и вот, собственно, да, вот наш самый оператор круглые скобки constexpr, к тому же
[01:39:34.880 --> 01:39:41.080]  возвращающий авто, но accept, как мы видели еще в самом начале, он там в зависимости от того,
[01:39:41.080 --> 01:39:51.960]  accept ли что-то другое, и вот он костыль для массивов сишных, если вот этот tp, который сюда передали,
[01:39:51.960 --> 01:40:07.160]  это array, то мы убираем все extents с array, в общем, делаем невероятные вещи, которые, видимо,
[01:40:07.160 --> 01:40:14.760]  нужны, чтобы это действительно всегда работало, независимо от каких-то странных кейсов, да,
[01:40:14.760 --> 01:40:27.000]  интересно, вот, ну ладно, ну давайте не будем пытаться понять, да, ну типа как бы сишный массив и
[01:40:27.000 --> 01:40:31.560]  указатель на его начало, формально говоря, по стандарту, чуть-чуть разные вещи, хотя и на деле
[01:40:31.560 --> 01:40:41.240]  тоже, поэтому нужна вся эта чехарда, кажется, вот, дальше проверяют, если у него есть как бы метод
[01:40:41.240 --> 01:40:51.600]  begin, то вызывают у него метод begin, иначе делают вот этот вот, вот тот самый, который мы здесь сразу
[01:40:51.600 --> 01:40:57.360]  делаем, то есть через стандартную функцию, но так как у них и так это все в namespace и cstd определено,
[01:40:57.360 --> 01:41:06.560]  и вот этой строчки нет, то есть у них вот это вот, ну оно само находится как бы в текущем namespace,
[01:41:06.560 --> 01:41:17.000]  вот, тут есть еще несколько некоторых тонкостей, о которых проще всего, конечно же,
[01:41:17.000 --> 01:41:35.360]  узнать от самого Эрика, а не пытаться придумать, где, нет, значит я пудрил, в общем есть вот такая статья,
[01:41:35.360 --> 01:41:44.240]  где все это подробно и очень понятно расписывается, статья еще 14 года, и тут есть небольшое замечание,
[01:41:44.240 --> 01:41:58.280]  что вообще говоря, ну объект с одним оператором скобки или такой тип, его можно генерить автоматом
[01:41:58.280 --> 01:42:05.240]  на самом деле, да, через лямбда, на что Эрик привел ряд причин, почему так нельзя, а у нас,
[01:42:05.240 --> 01:42:15.520]  мне кажется, так можно, потому что мы в будущем, наверное, мы сейчас не будем на это тратить время,
[01:42:15.520 --> 01:42:28.400]  да, лямбды не бывают куда-то с экспортом, теперь бывают, ОДР тоже не проблема, потому что у нас
[01:42:28.400 --> 01:42:36.400]  ключевое слово inline, которого раньше не было, да, для перемен, constraint, generic, лямбда, раньше было нельзя,
[01:42:36.400 --> 01:42:42.920]  теперь можно, automatic return type deduction, ну там со свиная могут возникнуть проблемы, да,
[01:42:42.920 --> 01:42:52.600]  что если мы пишем какой-то более капертизированный алгоритм, чем слов, например, begin, мы должны,
[01:42:52.600 --> 01:43:04.320]  как они вот здесь вот это делают на самом деле, да, с помощью requires проверить, что мы вообще,
[01:43:04.320 --> 01:43:11.800]  типа, такой тип нам подходит, у него есть вообще это begin или он контейнер, ну вот здесь немного так,
[01:43:11.800 --> 01:43:20.520]  типа, странно, так а maybe board range это, а, вот, концепт, вот, как минимум вот это, да, концепт,
[01:43:20.520 --> 01:43:29.080]  который требует, чтобы вот этот аргумент был range, тип его, а зачем это надо, вдруг две разных
[01:43:29.080 --> 01:43:39.840]  библиотеки объявляют вот такой customization point object, да, cpo, если еще называется, ну под
[01:43:39.840 --> 01:43:47.880]  названием size, один имеет в виду размер вектора или там структуру данных, другой имеет в виду
[01:43:47.880 --> 01:43:55.320]  площадь геометрической фигуры, ну, типа, размер же блин, вот, чтобы эти все вещи не конфликтовали,
[01:43:55.320 --> 01:44:04.880]  можно концептами вот здесь затребовать, чтобы работало только для такого и тогда, в случае,
[01:44:04.880 --> 01:44:19.440]  если мы имеем два size, один от shape другого от контейнера, пихнув, ну, сделав вызов size от shape,
[01:44:19.440 --> 01:44:28.480]  оно само поймет, что вот это не подходит второе и вызовет первое, окей, это все здорово, это все классно,
[01:44:28.480 --> 01:44:37.880]  но одну из главных причин и главных болей мы не решили, мы все еще глобально резервируем ключевое слово swap,
[01:44:37.880 --> 01:44:51.120]  эта проблема понятна, если при каждой точке кастомизации, которых в стандарте внезапно,
[01:44:51.120 --> 01:45:04.720]  ой-ой-ой-ой, как много, это еще не все, тут еще алгоритмов есть, в общем, их становится реально много,
[01:45:04.720 --> 01:45:11.440]  если с каждой новой точкой кастомизации мы новое слово глобально резервируем и никому нигде в коде
[01:45:11.440 --> 01:45:16.760]  не разрешаем его использовать для других вещей, то очень быстро слова в английском кончатся и нам
[01:45:16.760 --> 01:45:31.560]  будет больно, эту проблему надо как-то решить, и ее решение тут просто бомбезное, как бы к нему подвести,
[01:45:35.960 --> 01:45:43.120]  но мы его в принципе уже знаем, мы только что вот там где-то сверху,
[01:45:43.120 --> 01:46:00.400]  где же оно было, а вот здесь оно было, вот этот каст мы его диспетчеризировали через оверлоуды,
[01:46:00.400 --> 01:46:10.000]  то есть какой-то ключ внутри такого вот value тега использовали, чтобы выбрать какой из кастов
[01:46:10.000 --> 01:46:21.760]  мы хотим вызвать в зависимости от ключа, окей, давайте заведем, это будет теперь не myLib, а std,
[01:46:21.760 --> 01:46:26.960]  который с большой буквы, как бы std, заведем здесь две вещи,
[01:46:26.960 --> 01:46:50.160]  давайте class и заведем здесь, наверное мы сразу вот эту,
[01:46:50.160 --> 01:47:01.560]  заведем здесь функцию, вернее customization point, под названием tag-invoke,
[01:47:01.560 --> 01:47:10.920]  он будет уже немного сложнее,
[01:47:10.920 --> 01:47:24.240]  он будет принимать некоторые cpo и аргументы,
[01:47:24.240 --> 01:47:44.440]  и собственно он будет пытаться все еще точно так же как было раньше,
[01:47:44.440 --> 01:47:57.280]  он будет пытаться с помощью ADL найти функцию tag-invoke, куда прокинет cpo, куда прокинет аргументы,
[01:47:57.280 --> 01:48:15.800]  в чем pond, это некоторая инфраструктура, которая нам теперь позволит плодить эти точки
[01:48:15.800 --> 01:48:22.120]  кастомизации, где мы хотим, как мы хотим, и они не будут у нас конфликтовать,
[01:48:22.120 --> 01:48:37.400]  давайте в namespace объявим точку кастомизации,
[01:48:37.400 --> 01:49:00.200]  допустим это какой-то наш особый begin, бегову назовем, потому что не хочу бороться с конфликтом,
[01:49:01.080 --> 01:49:07.320]  все еще делаем примерно то же самое, почти такое же не было делаем,
[01:49:07.320 --> 01:49:11.040]  оператор какой-то скобки шаблонный,
[01:49:11.040 --> 01:49:30.280]  но вот здесь делаем несколько иное, мы делаем tag-invoke под бег,
[01:49:30.280 --> 01:49:46.240]  ну да, наверное нам так-то и не нужен, делаем вот такую штуку,
[01:49:46.240 --> 01:50:14.000]  наверное так, в чем идея?
[01:50:14.000 --> 01:50:23.640]  мы будем выбирать некоторую функцию tag-invoke, у нее будет много перегрузок в разных namespaces,
[01:50:23.640 --> 01:50:33.560]  где угодно лежащих, основываясь на вот этом первом аргументе, то бишь если мы захотели
[01:50:33.560 --> 01:50:47.640]  сделать какую-то свою структуру данности, здесь должно быть много кода, но его здесь нет,
[01:50:47.640 --> 01:50:56.280]  это будет vectorintof, и мы решили эту точку кастомизации бег кастомизировать для него,
[01:50:56.280 --> 01:51:04.560]  например он приватно следует, или приватно его где-то хранит, и поэтому мы не можем
[01:51:04.560 --> 01:51:10.600]  просто так точку begin вызвать или std begin, кастомизировать мы будем так,
[01:51:10.600 --> 01:51:21.640]  да, здесь конечно не будет, а декл-тайп от авто, возвращать нужно этот результат,
[01:51:21.640 --> 01:51:37.680]  friend tag-invoke, или там myVectorBeg,
[01:51:37.680 --> 01:52:00.360]  наверное это должно работать, но конечно так сложно,
[01:52:00.360 --> 01:52:10.280]  почему tag-invoke сам себя вызывает, ну точно так же как у нас раньше swap сам себя вызывал,
[01:52:10.280 --> 01:52:17.400]  это он вызывает не сам себя, он вызывает функцию, а вот эта штука это какая-то переменная,
[01:52:19.400 --> 01:52:24.680]  и соответственно вот эта штука, вот это имя не увидит, потому что оно еще не объявлен,
[01:52:24.680 --> 01:52:37.280]  и найдет варианты только с std и возможностями функций, ну вообще конечно да, и вот здесь,
[01:52:37.280 --> 01:52:59.680]  ну вот да, там был какой-то костыль кажется, что вот нужно что-то аккуратно сделать,
[01:52:59.680 --> 01:53:05.320]  чтобы вот в каких-то супер крайних случаях не нашелся, вот сам же этот tag-invoke рекурсивно,
[01:53:05.320 --> 01:53:16.320]  ну окей, последуем стандарту, inline namespace, это такой namespace,
[01:53:16.320 --> 01:53:22.520]  который как бы namespace не является, а просто добавляет все свои результаты в внешний namespace,
[01:53:22.520 --> 01:53:29.760]  но каким-то хитрым образом, вот тут уже черт много сломят, говорят это помогает,
[01:53:29.760 --> 01:53:39.680]  собственно зачем оно на cpp референсов не используется, ну имя у namespace как мы знаем,
[01:53:39.680 --> 01:53:47.040]  можно не указывать, так вот, а вот здесь уже вся эта фига мне не нужна, здесь у нас все хорошо,
[01:53:47.040 --> 01:54:01.920]  можно даже вот так сделать и в чем-то оправляем, это статическая функция, которая выкидывается в внешний
[01:54:01.920 --> 01:54:13.200]  namespace, но вот эта friend функция, которая как бы и добавилась в namespace, ее нельзя явно вызвать,
[01:54:13.200 --> 01:54:23.480]  единственный способ ее вызвать это addl, а addl у нас может быть по всем аргументам, соответственно
[01:54:23.480 --> 01:54:32.360]  там вот myvector, второй аргумент и позволит нам, наверное не constant, и позволит нам найти вот эту
[01:54:32.360 --> 01:54:42.320]  friend функцию при вызове tag-invoke, то есть вот в этом месте, когда мы попытаемся сделать tag-invoke
[01:54:42.320 --> 01:54:51.320]  с первым аргументом begin, вторым аргументом myvector, оно с помощью addl все-таки найдет и вызовет
[01:54:51.320 --> 01:55:01.200]  ее, так давайте это уберем, и проверим работает ли теория, мне кажется все-таки
[01:55:01.200 --> 01:55:25.360]  самым интересным времени не останется, и да, окей, ладно, попробуем, mylib, бег, там с маленьким, бег от myvector, бег,
[01:55:25.360 --> 01:55:35.120]  давай что-то положить бы хорошо, ну ладно,
[01:55:35.120 --> 01:55:55.600]  да, constant теряли вот здесь, вот это работает,
[01:55:55.600 --> 01:56:03.520]  все даже нормально, а type-it это
[01:56:03.520 --> 01:56:14.440]  ну чем мне нравится, давайте проверим,
[01:56:14.440 --> 01:56:36.520]  да, то есть действительно нам вернулся итератор на вот этот вектор, который там лежал внутри,
[01:56:36.520 --> 01:56:47.600]  окей, почему это все очень здорово, теперь у нас зарезервировано ровно одно глобальное имя в namespace std под
[01:56:47.600 --> 01:56:56.320]  названием tag-invoke, все больше зарезервированных глобальных имен нет, второе, так как лукап идет по
[01:56:56.320 --> 01:57:08.120]  конкретным типам других точек кастомизации, мы никогда не сможем перепутать что мы вызываем,
[01:57:08.120 --> 01:57:16.200]  вот если у нас так окажется, что вот ситуация с двумя сайзами, один из которых для фигур,
[01:57:16.200 --> 01:57:22.280]  другой для контейнеров, это что значит, это значит что у нас две вот таких точки кастомизации с
[01:57:22.280 --> 01:57:28.960]  одинаковым названием две глобальных переменност в одном файле видны в одном месте, это будет
[01:57:28.960 --> 01:57:38.240]  ambiguous name, нам сразу просто выдадут ошибку и скажут, извините, и попросят уточнить, а из какого
[01:57:38.240 --> 01:57:46.480]  namespace мы хотим вызвать функцию, мы уточним, а из namespace геометрических фигур, и все будет
[01:57:46.480 --> 01:57:57.520]  работать после этого, я не знаю, вот этот begin, если мы явно указали, что мы используем mylib-bg,
[01:57:57.520 --> 01:58:05.000]  то уже нет выбора, кроме как прийти вот сюда, а tag-invoke будет среди оверлоудов выбираться при
[01:58:05.000 --> 01:58:14.320]  помощи вот этого вот уникального, так сказать, ключа, типа структурки, который мы вот здесь
[01:58:14.320 --> 01:58:19.840]  inline объявили, и ни с какой другой точкой кастомизации, с другой библиотеки или откуда-то не было бы,
[01:58:19.840 --> 01:58:33.920]  это не спутать, и кажется на этом все, в итоге мы найдем какую-то из перегрузок функции tag-invoke,
[01:58:33.920 --> 01:58:48.640]  которые обычно пихнуты как френды в какие-то конкретные, какие-то конкретные типа, но не
[01:58:48.640 --> 01:59:03.280]  обязательно, их можно и в глобальном namespace делать еще много где, так, еще про кастомизацию,
[01:59:03.280 --> 01:59:10.760]  для вот таких точек кастомизации, которые сделаны через tag-invoke, конечно же, тоже можно делать
[01:59:10.760 --> 01:59:17.000]  default, ну и мы примерно представляем, посмотрев уже вот сюда, как они там будут делаться,
[01:59:17.000 --> 01:59:31.960]  ладно, я потерял этот код, можно проверить, что у tag-invoke есть regim, тогда мы можем сразу вернуть
[01:59:31.960 --> 01:59:43.160]  tag-in, иначе мы можем сесть и вызвать вот этот вот левок, и тогда наша конструкция сразу начнет
[01:59:43.160 --> 02:00:13.040]  работать, вот теперь давайте все-таки вернемся к источнику всей этой
[02:00:13.040 --> 02:00:31.080]  магии, замечательному пропузелу, он написан очень простым языком и очень наглядно показывает
[02:00:31.080 --> 02:00:37.840]  все эти проблемы, так что рекомендую ознакомиться, потому что это все попадет в стандартском,
[02:00:37.840 --> 02:00:46.680]  вот, ну и соответственно, если мы совсем все по-хорошему пишем и как большие дяди действуют,
[02:00:46.680 --> 02:00:55.120]  то объявляя новую какую-то точку кастомизации foo, нам нужно, во-первых, предусмотреть noexcept,
[02:00:55.120 --> 02:01:10.400]  во-вторых, предусмотреть SFINA, чтобы если случайно название, вернее, здесь это кажется не особо
[02:01:10.400 --> 02:01:20.640]  нужно, да, вроде как есть какие-то corner cases, где важно именно вот так делать, tag-invoke, как вы
[02:01:20.640 --> 02:01:29.840]  понимаете, это тот же самый tag-invoke, что у нас, а SFINA нужно, ну зачем, да, вот здесь просто this
[02:01:29.840 --> 02:01:36.600]  перекидывают, я не знаю, почему я так же не сделал, я зачем-то заново создал экземпляр того же типа
[02:01:36.800 --> 02:01:48.120]  можно просто сделать this, и тут супер подробно написано, почему это вылечивает примерно все
[02:01:48.120 --> 02:02:03.000]  проблемы, вот про адаптеры еще важно сказать, но их пример какой-то супер неприятный, давайте
[02:02:03.000 --> 02:02:22.440]  представим, что мы делаем какой-то адаптер, который внутри себя хранит т-шку, как мы в классических
[02:02:22.440 --> 02:02:30.440]  плюсах или в классическом op прокидывали все вызовы, которые умел делать т, к нему обратно,
[02:02:30.440 --> 02:02:37.680]  ну если просто по плюсовому, то можно в оператор стрелочкой или там оператор звездочкой вернуть
[02:02:37.680 --> 02:02:43.520]  вот эту т-шку и прокинуть ему вызовы, как вы в домашней собственно должны сделать, если мы
[02:02:43.520 --> 02:02:51.200]  делаем op-style, то нам тут нужно как бы да вот сделать вот так вот, самоследовать т, надеяться,
[02:02:51.200 --> 02:02:58.160]  что у него методы виртуальные, и тогда если мы храним указательный адаптер, его вызовы автоматом
[02:02:58.160 --> 02:03:05.600]  прокинуться к т, а вот если мы адаптер хотим сделать с помощью вот этих тег инвоков, то
[02:03:05.600 --> 02:03:15.960]  внезапно получается конфетка, вот этот friend тег инвок мы можем кастомизировать по самой цп ошки,
[02:03:15.960 --> 02:03:22.840]  да помним, что тег инвок, первый аргумент, это некоторый класс цпо, который просто говорит,
[02:03:22.840 --> 02:03:29.160]  как бы кто пытает, вернее какую функцию мы пытаемся вызвать, какую точку кастомизации,
[02:03:29.160 --> 02:03:37.920]  мы можем сказать, что если любую точку кастомизации попытались вызвать с адаптером т,
[02:03:37.920 --> 02:03:56.640]  да, но не сейчас, мы можем сказать, а пойди-ка и сделай все еще тег инвок с той же цп ошкой,
[02:03:56.640 --> 02:04:10.800]  но теперь не для адаптера, а для его флешки, то есть мы прокинули все вызовы точек кастомизации
[02:04:10.800 --> 02:04:25.320]  к адаптеру на вызовы к его элементу, это может быть, например, share ptr или unique ptr и это нам
[02:04:25.320 --> 02:04:35.040]  позволит любые попытки unique shared ptr использовать в точке кастомизации какой-либо, прокинуть запрос
[02:04:35.040 --> 02:04:46.200]  к тому, что лежит под указателем, мне кажется, это немножко ого-го, как круто, но то есть реально
[02:04:46.200 --> 02:04:53.520]  очень сильно освобождает головной боли при работе с такими адаптерами, с паттерным адаптером,
[02:04:53.520 --> 02:05:00.720]  ОП потребовала бы динамической диспетчеризации, здесь, заметьте, вся диспетчеризация статическая,
[02:05:00.720 --> 02:05:13.520]  да, ну также можно подобные трюки делать не только для, как бы объявляя френдов,
[02:05:13.520 --> 02:05:22.240]  можно их и глобально объявлять, но глобальные минуты говорят засорять хорошо. Так, какие еще
[02:05:22.240 --> 02:05:34.640]  есть классные пункты? Да, мы можем концептами описать список, вернее, мы можем описать класс,
[02:05:34.640 --> 02:05:43.000]  который умеет вызываться в следующих точках кастомизации, то есть вообще, если задуматься
[02:05:43.000 --> 02:05:58.960]  точки кастомизации, это алгоритм, а типа это какие-то данные. Можем сделать концепт,
[02:05:58.960 --> 02:06:22.240]  как бы его назвать адекватно, не знаю, вот так. Вообще говоря, для тех, кто немножко шарит
[02:06:22.240 --> 02:06:31.440]  другие языки, это можно назвать trait, потому что это максимально похоже на trait в Rust. Я знаю,
[02:06:31.440 --> 02:06:35.560]  что они там бывают динамические и статические, вот динамические — это то, на что у нас не хватит
[02:06:35.560 --> 02:06:43.480]  времени, а это статические, да, и мы просто требуем, чтобы, если нам дали такую тешку,
[02:06:43.480 --> 02:06:53.080]  да, по аналогии с тем, что этих ребят мы могли любую из этих цеплошек запустить. Надеюсь,
[02:06:53.080 --> 02:07:01.720]  у меня сейчас сработает с разверткой. Ну ладно, скорее всего не сработает, придется чуть похитрее.
[02:07:13.480 --> 02:07:17.640]  Вот, теперь мы в каких-то шаблонных функциях можем просто описывать, что...
[02:07:17.640 --> 02:07:44.520]  Мы можем сделать концепт range, который там затребует, чтобы у T были std ranges begin, std ranges end,
[02:07:44.520 --> 02:07:59.520]  ну и все в принципе, но только нам нужны... Да, не совсем так, это конечно не классы, это объекты.
[02:07:59.520 --> 02:08:12.320]  Вот, и вот это максимально похоже на type классы в Haskell или traits в Rust,
[02:08:12.320 --> 02:08:22.320]  где вы просто указываете, какие... Ну, когда вы создаете какой-то trait или type класс, вы говорите,
[02:08:22.320 --> 02:08:29.440]  какие функции должны у него поддерживаться, потом совершенно отдельно вы прям обязаны сказать для
[02:08:29.440 --> 02:08:38.960]  каждой из этих функций, что я как бы вписываюсь в этот trait. Ну, есть некая разница, но мне кажется,
[02:08:38.960 --> 02:08:46.680]  эту мысль можно добить. Окей, давайте наверное на сегодня завершим тогда,
[02:08:46.680 --> 02:08:52.320]  или какие-нибудь вопросы можно по обсуждать, проблемы с домашними и прочее.
