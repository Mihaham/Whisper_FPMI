[00:00.000 --> 00:08.760]  короче сегодня продолжаем немножко про числа говорить цель в конце лекции
[00:08.760 --> 00:14.440]  разобрать алгоритм факторизации довольно быстрый который ну факторизация это
[00:14.440 --> 00:19.320]  разложение на множители значит ну наверное многие из вас сумеют раскладывать за корень из n
[00:19.320 --> 00:27.800]  просто перебираю все числа от одного до корня и типа деля на них пока делится ну не обязательно ну
[00:27.800 --> 00:31.640]  типа если число это квадрат простого то вы быстрее чем за корень не сделаете я думаю ну и
[00:31.640 --> 00:37.560]  если только не извлечу теперь ну неважно не там типа корень не именно что это сам он
[00:37.560 --> 00:44.160]  он хорош точная оценка короче вот ну сначала еще какие-то просто задачки вокруг по рассматриваем
[00:44.160 --> 00:48.400]  в частности попроверяем число на простоту просто перед тем как раскладывать число на множителя мы
[00:48.400 --> 00:57.640]  сначала научимся проверять что оно простое вот и перед этим еще такая задача это извлечение корня
[00:58.000 --> 01:15.480]  значит ну начнам данные два числа а и п причем п простое надо решить вот такое уравнение вот то
[01:15.480 --> 01:25.600]  есть решить по факту извлечь квадратный корень из а да но смотрите если п как бы какие у нас
[01:25.600 --> 01:31.360]  будут просты у нас все просты либо четная двойка либо нечетная с п равно два как нибудь разберемся
[01:31.360 --> 01:36.600]  наверное за ифаем что если по равно два то как нибудь там корни по извлекаем вот теперь давайте
[01:36.600 --> 01:44.360]  отсюда до конца лекции считать что п нечетно просто вот а и тут есть два случая один простой
[01:44.360 --> 01:57.400]  сложный значит случай первый это когда п это тройка по моделю 4 значит тогда утверждаю что
[01:57.400 --> 02:09.720]  x равная плюс-минус а в степени п плюс один на четыре ну помодлю п конечно это единственный два корня
[02:09.800 --> 02:16.560]  уравнение у этого уравнения вот но понятно там если мы живем в zp то наверное у уравнений
[02:16.560 --> 02:21.680]  второй степени не больше чем два корня вот это дежда что оба они вот тут написано значит почему
[02:21.680 --> 02:26.400]  но давайте возведем это в квадрат если мы вот это вот воздумать в квадрат то у нас получится
[02:26.400 --> 02:35.960]  а в степени п плюс один пополам правильно плюс-минус уйдет здесь будет а все п плюс один пополам так хорошо
[02:35.960 --> 02:48.440]  ну и видимо надо еще сказать что есть такой простой факт давайте утверждение без доказательства что
[02:48.440 --> 03:01.880]  если а это элемент zp звездочки то есть любой нелевой вычет то тогда а является квадратичным
[03:01.880 --> 03:14.960]  вычетом то есть является квадратом какого-то числа давайте а напишем равно b в квадрате для
[03:14.960 --> 03:33.840]  некоторого b если только если помните условия да да это правда
[03:33.840 --> 03:41.280]  значит это условия на квадратичный вычет и аналогичные условия на квадрате не вычет
[03:41.280 --> 03:51.680]  так не вычет но это наоборот квадратичный не вычет это число из которого не извлекается корень
[03:51.680 --> 03:55.840]  то есть число не равно никакому квадрату это верно в случае если а в степени по минус
[03:55.840 --> 04:11.440]  пополам это минус 1 так для кого новая информация да хорошо ну простой факт он на самом деле на
[04:11.440 --> 04:15.240]  теориям и фирма в ком-то смысле основывается потому что а в степени по минус один всегда
[04:15.240 --> 04:21.160]  единица по моделю п вот а если это квадратичный вычет то есть оно уже квадрат то получается что
[04:21.280 --> 04:25.000]  если вы это вот это вот б в квадрате воздействует еще в эту степень до края будет б в степени по
[04:25.000 --> 04:31.640]  минус 1 значит единица вот но если не вычет то можно доказать что будет минус 1 так пардон здесь
[04:31.640 --> 04:38.760]  здесь двой конечно вот ну хорошо а значит тогда на самом деле первый первым шагом конечно здесь
[04:38.760 --> 04:43.400]  хотелось бы провести что а это квадратичный вычет потому что мы хотим из него извлечь корень
[04:43.400 --> 04:47.320]  но понятно если это не вычет то решений нет на то есть первое что мы делаем это проверяют что
[04:47.320 --> 04:57.460]  А это квадратичный вычет. Проверяем, что А квадратичный вычет. То есть мы запускаем
[04:57.460 --> 05:02.180]  просто такую проверку, возводим А в степень по месорин пополам. Благо мы потенцировать умеем
[05:02.180 --> 05:06.780]  быстро, мы умеем быстро возведет степень по модулю П. Но если такая степень 1, то значит это
[05:06.780 --> 05:11.920]  квадратичный вычет, иначе не вычет. Вот, значит если А это квадратичный не вычет, то решений нет,
[05:11.920 --> 05:17.200]  и делать нечего. Вот, а иначе я утверждаю, что, значит, давайте вернемся сюда, что если возьму
[05:17.200 --> 05:24.320]  такой х, возводую в квадрат, получится а в степени p плюс один пополам, это можно так расписать, это
[05:24.320 --> 05:30.840]  а в степени p минус один пополам плюс один, но мы знаем, что вот эта единичка, потому что а это
[05:30.840 --> 05:43.160]  квадратичный вычет, но, значит, это просто а по моделю p. Согласны? Ну вот. Так, мне не хватает света, мне кажется.
[05:43.160 --> 06:01.200]  Это простой случай, если p отстройка по моделю 4, то вот мы оба корня умеем опять-таки получать,
[06:01.200 --> 06:06.400]  возводя в степень. Ну здесь мы пользуемся тем, что это целое число, p плюс 1 на 4 целое число,
[06:06.400 --> 06:10.680]  значит, мы можем так сделать. Ну и вот оба корня мы извлекли. Значит, теперь второй случай,
[06:10.680 --> 06:23.960]  когда p единичка по моделю 4. Так, хорошо, ну давайте мы запишем p в таком виде. Значит,
[06:23.960 --> 06:34.760]  p можно представить как 1 плюс m на 2 в степени s, где m нечетно. Ну понятно, раз p нечетная,
[06:34.840 --> 06:38.200]  то после вычитания единички и после многократного деления на двойку можно
[06:38.200 --> 06:42.640]  добиться того, что мы, в общем, высекли все двойки, которые там были, осталось какое-то нечетное m.
[06:42.640 --> 06:59.040]  Хорошо. Давайте я тогда скажу следующее. Давайте рассмотрим у нулевое равное а в степени m,
[06:59.040 --> 07:07.840]  в нулевое равное а в степени m плюс 1 пополам. Ну, поскольку им нечетно,
[07:07.840 --> 07:16.440]  то это будет тоже целое число, можно возводить в такую степень. Тогда будет ясно, что в 0 в квадрате
[07:16.440 --> 07:23.840]  это а на у 0. Ну, естественно, по модулю p, потому что в 0 в квадрате это просто а в степени m плюс
[07:23.840 --> 07:32.600]  1, здесь будет 1 а, здесь будет а в степени m еще. Это тривиальное равенство. Вот, но если бы нам
[07:32.600 --> 07:39.080]  так повезло, смотрите, представьте, что нам так повезло, и у 0 эта единичка по модулю p. Ну вот
[07:39.080 --> 07:44.120]  представьте, так случилось, что у 0 равная вот этой штуке эта единичка по модулю p. То есть ее можно
[07:44.120 --> 07:48.760]  тогда закрыть, и мы извлекли корни за то, что нам нужно. Мы знаем, что плюс-минус в 0 это корни.
[07:48.760 --> 07:55.680]  Согласны? Вот. И это на самом деле ровно то, что происходит в первом случае. Вот если p это
[07:55.680 --> 08:01.120]  единичка, perdон, тройка по модулю 4, то, ну по факту мы вот делаем ровно вот это вот, потому что там
[08:01.120 --> 08:07.800]  m будет как раз p плюс 1 на 4, точнее, p плюс 1 пополам, и потом мы еще делим его пополам, короче, будет
[08:07.800 --> 08:17.200]  вот ровно оно. Ну, значит, вот на этом шаге, в случае 1, нам бы уже на самом деле повезло. В этом
[08:17.200 --> 08:22.480]  случае нам не обязательно повезет, у может быть совсем не единицей, но мы хотим добиться того,
[08:22.480 --> 08:28.840]  чтобы она стала единичкой. Так вот давайте мы будем строить последовательность таких пар у, в, что они
[08:28.840 --> 08:35.760]  будут последовательно удовлетворять вот такому вот соотношению, что v² равно a на ui по модулю p.
[08:35.760 --> 08:45.240]  Вот. Ну и будем дождаться момента, когда уишка станет равна единице по модулю p. Окей. Значит, как
[08:45.240 --> 08:54.080]  мы это будем делать? Давайте мы посмотрим на порядок элемента u0. Значит, напомню, что порядком
[08:54.080 --> 08:58.760]  элемента называется его минимальная положительная степень, в которой он равен единице. Ну, если есть
[08:58.760 --> 09:04.040]  какое-то число x, мы записываем все его степени подряд по модулю p и дожидаемся, когда впервые
[09:04.040 --> 09:10.760]  он становится единицей по модулю p, тогда это будет порядком. Какая-то порядок элемента x по модулю p.
[09:10.760 --> 09:19.640]  Ну, это же, наверное, многим знакомо. Что такое порядок? Хорошо. Ну вот давайте посмотрим на порядок
[09:19.640 --> 09:30.920]  элемента u0. Чему он может быть равен? Смотрите, мы знаем, что u0 это а в степени m, и мы знаем,
[09:30.920 --> 09:37.680]  что p вот в таком виде представима. Поэтому в частности можно заметить, что u0 в степени 2 в
[09:38.160 --> 09:48.920]  степени s это единица. Ну потому что u0 это а в степени m, давайте распишем, это а в степени m в степени
[09:48.920 --> 09:57.960]  2 в степени s, то есть это а в степени m на 2 в степени s. То есть а в степене p минус 1. Ну, значит,
[09:57.960 --> 10:05.840]  тогда порядок u0 обязательно делит 2 в степени s. Мы знаем, что если в какой-то степени мы получили
[10:05.840 --> 10:08.240]  единицу, то порядок обязательно делит эту самую степень.
[10:08.240 --> 10:11.480]  Ну, значит, мы точно можем сказать, что порядок – это
[10:11.480 --> 10:19.360]  какой-то делитель 2 в степени s, причем… Так, мне это сейчас
[10:19.360 --> 10:23.480]  одну секунду… Важно ли мне это будет? Будьте здоровы.
[10:23.480 --> 10:31.800]  А, ну да, более того, можно сказать, что порядок этой
[10:31.800 --> 10:35.800]  штуки даже делит 2 в степени s-1, потому что если
[10:35.800 --> 10:39.640]  бы я здесь написал s-1, здесь – s-1, здесь – s-1, тогда
[10:39.640 --> 10:42.200]  получится p-1 пополам. И даже это тоже единица по моделю
[10:42.200 --> 10:46.040]  p. Да, можно немножко уточнить оценку, сказать, что у нас
[10:46.040 --> 10:50.160]  здесь порядок не 2 в степени s, а 2 в степени s-1, потому
[10:50.160 --> 10:52.000]  что a – квадратичный вытяж, значит, его достаточно
[10:52.000 --> 10:54.400]  в такую степень возвести, чтобы получить единицу.
[10:54.400 --> 10:57.800]  Ну, в любом случае, так или иначе, мы понимаем, что
[10:57.800 --> 11:00.160]  порядок у нуля делит какую-то степень двойки, значит,
[11:00.160 --> 11:03.800]  сам этот порядок является степенью двойки. Давайте
[11:03.800 --> 11:09.920]  напишем 2 в степени r0, да, где r0 какое-то число меньше
[11:09.920 --> 11:27.920]  чем s. Хорошо. Теперь давайте вот будем делать эти переходы.
[11:27.920 --> 11:31.760]  Вот пары u0, v0. Мы будем строить все новые и новые пары ui,
[11:31.760 --> 11:37.400]  и будем стараться уменьшать порядок u, потому что мы сказали,
[11:37.400 --> 11:39.640]  что если в какой-то момент u – это единица, то есть у нее
[11:39.640 --> 11:44.480]  порядок 1, то мы победили. Мы нашли корни из a, это будет
[11:44.480 --> 11:48.040]  просто v, плюс-минус v. Так вот давайте сейчас сделаем
[11:48.040 --> 11:51.360]  такие итерации, будем строить новые пары u, v, чтобы уменьшать
[11:51.360 --> 11:54.360]  порядок u, но при этом сохранять вот это вот равенство, что
[11:54.360 --> 12:00.200]  у этого выитая квадрата, это а на уитая. Окей, давайте
[12:00.200 --> 12:04.280]  этого будем добиваться. Для начала мне нужно будет
[12:04.280 --> 12:10.640]  найти произвольный квадратичный невычат. Давайте скажем,
[12:10.640 --> 12:17.320]  что пусть b – это произвольный квадратичный невычат в
[12:17.320 --> 12:28.920]  zp. Мы знаем по этому утверждению более-менее, что кроме нуля
[12:28.920 --> 12:31.080]  квадратичных вычетов и квадратичные вычеты их
[12:31.080 --> 12:36.680]  поровну. Их ровно по p-1 пополам штук. У меня есть 0, у меня
[12:36.680 --> 12:40.600]  есть p-1 пополам квадратичный вычет и p-1 пополам невычат.
[12:40.600 --> 12:43.920]  Поэтому их там примерно поровну, и грубо говоря,
[12:43.920 --> 12:45.920]  если мы возьмем случайное число, то с вероятностью
[12:45.920 --> 12:48.960]  около 1 в 2 мы попадем как раз таки в невычат. Ну и
[12:48.960 --> 12:51.160]  чтобы его найти алгоритмически, давайте просто сгенерируем
[12:51.160 --> 12:56.960]  много чисел, точнее генерировать число b много раз, пока не
[12:56.960 --> 12:59.080]  станет выполняться вот это вот, пока его вот такая-то
[12:59.080 --> 13:02.120]  степень не будет минус 1. Поскольку их около половины,
[13:02.120 --> 13:07.440]  то мы довольно быстро его сгенерим. Среднее число
[13:07.440 --> 13:09.920]  шагов, которые надо сделать, это будет 2, потому что около
[13:09.920 --> 13:13.080]  половины невычаты, значит мы с вероятностью 1 в 2 каждый
[13:13.080 --> 13:15.040]  раз попадаем куда надо, а от ожиданий будет очень
[13:15.040 --> 13:18.960]  хороший, очень маленький. Вот, значит раз это невычат,
[13:18.960 --> 13:23.840]  то мы знаем, что b в степени p-1 пополам это минус 1. Что
[13:23.840 --> 13:30.160]  такое p-1 пополам? Это m на 2 в s минус 1. Значит b в степени
[13:30.160 --> 13:36.200]  m на 2 в степени s минус 1 это минус 1 по модулю p. С
[13:36.200 --> 13:39.400]  одной стороны, с другой стороны, b в степени m на 2 в степени
[13:39.400 --> 13:44.760]  s это уже единица по модулю p. Помалтерим фирма, потому
[13:44.760 --> 13:52.760]  что это p-1 в точность. Хорошо. Давайте обозначим, я скажу,
[13:52.760 --> 14:00.440]  что c это b в степени m. Так, давайте сюда перенесу.
[14:00.440 --> 14:04.840]  Значит, я говорю, что c это b в степени m. Тогда для
[14:04.840 --> 14:07.920]  него выполняются те же самые соотношения. Тогда c в степени
[14:07.920 --> 14:14.360]  2 в степени s минус 1 это еще минус 1, а c в степени 2 в степени
[14:14.360 --> 14:25.520]  s это уже единица по модулю p. Хорошо. Ну, теперь начинается
[14:25.520 --> 14:35.720]  следующая магия. Давайте я скажу, что… Сейчас подумаем.
[14:35.720 --> 14:44.320]  Значит, смотрите, пусть у меня была пара ui-vi, такая,
[14:44.320 --> 14:46.720]  что она удовлетворяла всем вот этим соотношениям.
[14:46.720 --> 14:51.360]  Значит, во-первых, vt квадрат это a на ui-t. Во-вторых, порядок
[14:51.360 --> 14:57.200]  элемента ui это 2 в степени какой-то ri. 2 в степени ri.
[14:57.200 --> 15:01.880]  Ну, что тогда можно написать? Можно написать, что ui-t в
[15:01.880 --> 15:09.960]  степени 2 в степени r минус 1 это минус единица. Да,
[15:09.960 --> 15:15.080]  но потому что вот такая-то степень u это 1, значит, если
[15:15.080 --> 15:34.720]  у в этой степени единица, то у в степени это пополам
[15:34.720 --> 15:36.480]  как раз минус единица, потому что из единицы есть только
[15:36.480 --> 15:40.080]  два корня плюс минус 1. Ну, соответственно, если порядок
[15:40.080 --> 15:44.840]  не вот это, значит, эта штука как раз минус 1. Теперь давайте
[15:44.840 --> 15:52.960]  умножим вот это вот на это вот. Что тогда получится?
[15:52.960 --> 16:00.000]  Получится ui-t в степени 2 в степени ri минус 1 умножить
[16:00.000 --> 16:04.040]  на c в степени 2 в степени s минус 1 равно единицы по
[16:04.040 --> 16:26.400]  модлю p. А теперь я хочу сгруппировать и вынести
[16:26.400 --> 16:36.440]  в скобках, ну, видимо, просто u на c. Нет, плохо, так будет
[16:36.440 --> 16:40.520]  плохо. Сейчас, секунду. Наоборот, наоборот, наоборот,
[16:40.520 --> 16:47.400]  виноват. Значит, ui-t на c в степени 2 в степени s минус
[16:47.400 --> 16:53.760]  r и t. Вот так. Вот. И это все будет оставаться в степени
[16:53.760 --> 16:57.480]  2 в степени r и t минус 1. Это будет единица по модлю
[16:57.480 --> 17:07.000]  p. Вот. Короче, я вот здесь вот сгруппировал. Короче,
[17:07.000 --> 17:09.320]  я вот эту вот степень 2 в степени r минус 1 выношу
[17:09.320 --> 17:13.040]  в качестве степени за скобку. В скобках остается u и c
[17:13.040 --> 17:15.840]  в степени разной степени 2 в s минус 1 минус 2 в степени,
[17:15.840 --> 17:18.480]  ну, точнее, поделить на 2 в степени r минус 1. Остается
[17:18.480 --> 17:26.720]  такая степень. Нет, s, s, нет, нет, нет. s это часть
[17:26.720 --> 17:37.800]  определения p. Да, оно фиксировано. Так, ну, это просто отсюда
[17:37.800 --> 17:44.400]  получилось вынесение в скобку. Ну и все, теперь давайте
[17:44.400 --> 17:47.920]  я скажу, что u и плюс первая, это вот то, что у меня стоит
[17:47.920 --> 18:05.000]  внутри скобки. А v и плюс первая? Сейчас, сейчас,
[18:05.000 --> 18:11.240]  сейчас, все будет, не переживайте. Значит, это k на c в степени
[18:11.240 --> 18:31.880]  2 s минус r минус 1, правильно? И, и, и. Вот, смотрите еще
[18:31.880 --> 18:34.240]  раз, значит, я, я все это сделал, чтобы теперь перейти
[18:34.240 --> 18:36.600]  к такой паре u и плюс 1 v и плюс 1. То есть у меня была
[18:36.600 --> 18:40.040]  старая пара u и v и, для которой что-то там выполнялось.
[18:40.040 --> 18:45.240]  Вот, давайте я для нее проверю, что выполняются те наши
[18:45.240 --> 18:48.680]  два условия, которые я хочу. Значит, во-первых, v и t в
[18:48.680 --> 18:51.160]  квадрате должно быть a на u и плюс первая, но давайте
[18:51.160 --> 18:54.520]  посчитаем, что такое v и плюс первая в квадрате.
[18:54.520 --> 18:58.520]  Это v и t в квадрате умножить на c в степени удвоенной
[18:58.520 --> 19:01.160]  вот этого, то есть просто c в степени 2 в степени s
[19:01.160 --> 19:07.680]  минус r и. Но v и t в квадрате, мы знаем, что это a на u и t
[19:07.680 --> 19:14.680]  в квадрате. Так. Да, действительно, спасибо, спасибо. Да, ну,
[19:29.320 --> 19:36.320]  а это как раз u и плюс первая, правильно? Да. По определению
[19:37.320 --> 19:41.680]  просто, вот оно u и плюс первая. Вот. Значит, первое соотношение
[19:41.680 --> 19:47.280]  выполнено. Второе. Ну, смотрите еще раз, у меня на пары
[19:47.280 --> 19:50.200]  мои есть два соотношения всего, то есть я поддерживаю
[19:50.200 --> 19:56.720]  такие пары u и v, что, во-первых, квадрат v это a на u, во-вторых,
[19:56.720 --> 20:03.720]  порядок ушки это степень двойки, 2 в степене r.
[20:06.440 --> 20:12.400]  Но они будут у меня убывать, на самом деле. Так вот,
[20:12.400 --> 20:14.040]  смотрите еще раз, давайте просто формально, у меня
[20:14.040 --> 20:16.800]  была такая пара с таким свойством, я перехожу к
[20:16.800 --> 20:19.960]  такой паре, проверю для нее аналогичные свойства.
[20:19.960 --> 20:23.160]  Во-первых, я хочу, чтобы квадрат v был a на u, давайте
[20:23.160 --> 20:26.560]  считаем квадрат вот этой v, вот этой v. Получается v
[20:26.560 --> 20:31.560]  и квадрат на c в удвоенной вот этой вот степени, v и
[20:31.560 --> 20:33.720]  t в квадрате, мы знаем, что по предположению это a на
[20:33.720 --> 20:36.880]  u и оставляем эту c, и получается у нас как раз множество
[20:36.880 --> 20:40.720]  u и плюс 1, поэтому мы получили аналогичное соотношение,
[20:40.720 --> 20:47.720]  что u и плюс 1 в квадрате это a на u и плюс 1. Не торопитесь,
[20:48.920 --> 20:52.360]  вот это понятно? Хорошо, теперь давайте посмотрим на
[20:52.360 --> 20:57.720]  порядок ушки, когда мы вот так вот сделали. Ну смотрите,
[20:57.720 --> 21:00.600]  если раньше u был порядок 2 в степени r и, то теперь
[21:00.600 --> 21:03.360]  я утверждаю, что у нее порядок меньше либо равен, чем 2
[21:03.360 --> 21:06.880]  в степени r и минус 1, ну потому что вот мы взяли u и плюс
[21:06.880 --> 21:10.000]  1, вот оно под скобками стоит, и мы знаем, что его вот такая
[21:10.000 --> 21:13.160]  степень уже единица, значит порядок обязательно еще
[21:13.160 --> 21:18.480]  ну как бы не больше, значит порядок u и плюс 1 делит вот
[21:18.480 --> 21:25.480]  эту вот штуку, потому что его такая степень это единица,
[21:25.480 --> 21:29.520]  значит порядок может быть еще только меньше. Все,
[21:29.520 --> 21:34.640]  мы сделали переход, значит у нас по-прежнему выполняется
[21:34.640 --> 21:38.200]  вот это соотношение, что v квадрат это ау, и мы уменьшили
[21:38.200 --> 21:45.200]  показатель степени в порядке u. Да, да, да, ну s точнее. Вот
[21:50.680 --> 21:57.680]  отсюда. Вот это u и плюс 1, вот то, что под скобками,
[21:59.640 --> 22:03.960]  это u и плюс 1, мы знаем, что его вот такая степень это
[22:03.960 --> 22:05.400]  единица, значит порядок может только делить эту
[22:05.400 --> 22:12.200]  степень. Вот, ну все, значит мы сделали переход, и давайте
[22:12.200 --> 22:16.520]  делать эти переходы, пока u не станет равна единице.
[22:16.520 --> 22:19.560]  Наша мечта, давайте вспомним в самом начале, наша мечта
[22:19.560 --> 22:22.400]  это, что u единица, тогда мы знаем, что v это корень
[22:22.400 --> 22:26.200]  низа, плюс-минус v это корень низа. Вот, но тогда если
[22:26.200 --> 22:28.600]  мы так будем делать и каждый раз будем уменьшать показатель
[22:28.600 --> 22:31.680]  у u, то мы рано или поздно дойдем до единички и победим.
[22:31.680 --> 22:38.680]  Да. Смотрите, если мы знаем, что x в какой-то степени,
[22:40.120 --> 22:43.640]  значит x хоть в какой-то степени, давайте скажем n это единица,
[22:43.640 --> 22:50.640]  то тогда порядок обязательно делит, делит n. Нет, обязательно
[22:50.640 --> 22:57.640]  делит. Еще раз? Ну вообще нет, типа я считаю это предреквизитом,
[23:03.360 --> 23:08.360]  как это доказать? Ну нет, не у всех теорий групп, видимо.
[23:08.360 --> 23:15.360]  Да, да, хорошо. Ну окей, давайте попробуем, давайте
[23:16.360 --> 23:19.760]  вот этот попробуем наказать быстренько. Мне предлагают
[23:19.760 --> 23:23.680]  поделить, если n не делится на порядок, давайте поделим
[23:23.680 --> 23:26.760]  с остатком. Хорошо, значит тогда будет n это порядок
[23:26.760 --> 23:32.760]  x на какой-то q, плюс какой-то r. Значит, и мы знаем, что x
[23:32.760 --> 23:37.480]  в этой степени 1, и x в этой степени 1. Ну тогда x в этой
[23:37.480 --> 23:43.900]  степени 1? Значит, обязательно x в этой степени 1. Противоречие
[23:43.900 --> 23:49.420]  с тем, что это порядок, да. Вот. Поэтому действительно
[23:49.420 --> 23:51.980]  если в какой-то степени единица, то порядок обязательно
[23:51.980 --> 23:54.900]  делит эту степень. То есть у нас на самом деле структура
[23:54.900 --> 23:58.140]  вот этих вот n-ок, структура степеней, в которых x единица,
[23:58.140 --> 23:59.900]  она очень простая, это все делители, порядка и все,
[23:59.900 --> 24:04.980]  и больше ничего нет. Ну вот. Вот вроде все, значит
[24:04.980 --> 24:07.220]  мы тогда научились делать переход, мы делаем эти переходы,
[24:07.220 --> 24:09.940]  пока ушко не станет равной единице по моделю p, и в тот
[24:09.940 --> 24:17.540]  момент, когда она единица, мы нашли корни за. Ау. Ну
[24:17.540 --> 24:20.020]  вот если представьте, что у вас это 1. Представьте,
[24:20.020 --> 24:25.300]  что это 1. Тогда у вас написано, что v квадрат это a, а вы знаете
[24:25.300 --> 24:39.500]  v. Значит v это корень. Я думаю, вы это так понимали. Ну
[24:40.500 --> 24:51.420]  у вас есть вопрос? Ну все тогда. Нет, все мы решили
[24:51.420 --> 24:58.700]  задачу. Да. Хороший вопрос. Как мы его находим? Ну можно
[24:58.700 --> 25:00.980]  просто возводить во всей степени u в квадрате, u в
[25:00.980 --> 25:02.860]  четвертой, u в восьмой и так далее, дождаться первого
[25:02.860 --> 25:04.940]  момента, когда будет единица. Тогда мы найдем r, r плюс
[25:04.940 --> 25:07.700]  первое. Да. Это правильный вопрос, но это легко сделать
[25:07.700 --> 25:10.300]  просто как бинарную степень возводим, дожидаемся когда
[25:10.300 --> 25:14.740]  впервые 1, а это будет как раз r плюс первое. Ну что
[25:14.740 --> 25:19.740]  со симптотикой? Мне кажется, что лог p в квадрате, потому
[25:19.740 --> 25:23.580]  что вот тут внутри у меня всякие возведения в степень,
[25:23.580 --> 25:27.340]  которые за логарифом работают, за лог p. И плюс у меня примерно
[25:27.340 --> 25:30.420]  лог итераций, потому что на каждом шаге у меня убывает
[25:30.420 --> 25:33.660]  r. Вот да, если раньше было r и t, то теперь не больше,
[25:33.660 --> 25:37.180]  чем r минус 1. Значит на каждом шаге убывает r, их тоже максимум
[25:37.180 --> 25:39.060]  логариф, ну, наверное, примерно около лог квадрата
[25:39.060 --> 25:53.060]  работают. Вот. Ну да, ну типа если не вычет нашелся,
[25:53.060 --> 26:02.060]  то дальше лог квадрат. Вот. Понятно? Ну ладно. Хорошо.
[26:02.060 --> 26:11.140]  Ну это, видимо, если как-то хитро вот здесь вот степень
[26:11.140 --> 26:14.340]  возводить и не возводить два раза то, что уже было,
[26:14.340 --> 26:19.140]  то, наверное, можно побыстрее. Ну, короче, в любом случае
[26:19.140 --> 26:26.420]  неплохо. Так. Хорошо, давайте пойдем дальше. Дальше давайте
[26:26.420 --> 26:29.860]  посмотрим задачу проверки на простоту. Что-то дано
[26:29.860 --> 26:43.380]  число n. Проверить его на простоту. Вот. Ну n какое-нибудь
[26:43.380 --> 26:47.980]  большое, типа там 10, 18 или может быть даже еще побольше.
[26:47.980 --> 26:56.100]  Надо проверить его на простоту. Хорошо. Значит давайте, значит
[26:56.100 --> 27:01.660]  тут в основе опять лежит терем, терем фирма. Мы знаем,
[27:01.660 --> 27:11.060]  что если n простое, то тогда для любого a от 1 до n-1, нас
[27:11.060 --> 27:17.900]  в степени n-1 это единица по моделю n. Вот это для простых
[27:17.900 --> 27:22.260]  n. Для составных это, типа, соответственно, тогда будет
[27:22.260 --> 27:31.820]  неверно. Вот. Ну вот да. Нет, там как раз для них это
[27:31.820 --> 27:36.140]  тоже будет неверно, но неважно. Значит, хотелось бы вот на
[27:36.140 --> 27:39.220]  основании такого факта основать какой-то алгоритм
[27:39.220 --> 27:42.460]  проверки на простоту. Можно было бы просто генерировать,
[27:42.460 --> 27:45.060]  скажем, случайные а из этого отрезка, возводить их в
[27:45.060 --> 27:48.580]  такую степень, проверить, что они единицы. Вот. Ну и,
[27:48.580 --> 27:50.580]  соответственно, то, что мы получим, это называется
[27:50.580 --> 27:55.860]  простой тест фирма. Тест фирма на простоту. Он работает
[27:55.860 --> 27:59.580]  так. Мы генерируем много случайных а. Ну там, не знаю,
[27:59.580 --> 28:03.740]  давайте k каких-нибудь шагов возьмем. k маленько от одного
[28:03.740 --> 28:15.940]  до k большого. Генерируем случайное а из вот этого диапазона.
[28:15.940 --> 28:20.100]  Говорим, что если а в степени n-1 не равно единице по моделю
[28:20.100 --> 28:24.420]  n, тогда n, очевидно, непростое, ну потому что как бы для
[28:24.420 --> 28:26.860]  него вот это не выполняется, значит, не выполняется вот
[28:26.860 --> 28:33.100]  это. Значит, сразу говорим, что n непростое. Стритерн,
[28:33.100 --> 28:38.980]  там не знаю, n составное. Вот. Ну если мы в течение
[28:38.980 --> 28:40.740]  большого числа итерации такого числа не нашли,
[28:40.740 --> 28:45.940]  то объявляем его простым. Стритерн. Ну давайте я так
[28:45.940 --> 28:58.420]  напишу, скорее всего, n простое. Вот. Ну тогда понятно,
[28:58.420 --> 29:01.700]  что если алгоритм в какое-то время вернул, что число
[29:01.700 --> 29:04.900]  составное, то он точно составное, потому что для него не выполняется
[29:04.900 --> 29:08.340]  термин фирма. Значит, он точно не простое, точно составное.
[29:08.340 --> 29:11.820]  Вот. Ну а иначе, как бы, ну вот, типа оно надеется,
[29:11.820 --> 29:22.580]  что n простое. Вот. На самом деле, к сожалению, он работает
[29:22.580 --> 29:27.980]  не всегда. Ну вот, есть там числа, какие-то числа,
[29:27.980 --> 29:32.580]  для которых, ну, которые почти вот этому закон удовлетворяют,
[29:32.580 --> 29:36.020]  что там почти для всех чисел его n-1-ой степени это единица
[29:36.020 --> 29:39.300]  по моделю n. Типа, такие числа есть, значит, это, в общем,
[29:39.300 --> 29:41.700]  недосадженодежный тест. Можно, например, убедиться,
[29:41.700 --> 29:47.020]  что если дать в качестве n 561, это наименьшее простое,
[29:47.020 --> 29:49.500]  которое проходит такой тест. Извините, наименьшее
[29:49.500 --> 29:52.820]  составное, которое с хорошей вероятностью этот тест не
[29:52.820 --> 29:55.900]  проходит, то есть на нем ошибается. Вот. Тогда если
[29:55.900 --> 29:59.780]  возьмете любое а, взаимно простое с n, то его n-1-ой степени
[29:59.780 --> 30:03.380]  будет единица. Ну вот, короче, типа, бывают числа, которые,
[30:03.380 --> 30:05.660]  бывают составные числа, которые этот тест проходит,
[30:05.660 --> 30:08.540]  и они будут считаться как бы простыми, хотя на самом
[30:08.540 --> 30:10.820]  деле это не такие составные. Вот, но это, например, на
[30:10.820 --> 30:15.860]  три делится, поэтому точно не простое. Вот. Поэтому
[30:15.860 --> 30:20.980]  это не очень такой, не очень адекватный алгоритм. Ну,
[30:20.980 --> 30:25.460]  к сожалению, их до 10-18 около миллиона, поэтому не получится.
[30:25.460 --> 30:30.700]  Ну, кстати, да. Но то, как вы их построите, не очень
[30:30.700 --> 30:35.420]  понятно. Предпосчитаю. Ну, хорошо, удачи вам. Вот.
[30:35.900 --> 30:38.180]  Давайте поделаем что-то более интеллектуальное.
[30:38.180 --> 30:41.620]  Смотрите. Давайте сделаем что-то более интеллектуальное,
[30:41.620 --> 30:45.940]  похожее на то, что было в прошлой задаче. А именно,
[30:45.940 --> 30:49.500]  ну давайте опять загенерим какое-нибудь случайное а.
[30:49.500 --> 30:52.260]  Понятно, что если для него а в n-1-ой не единица, то а
[30:52.260 --> 30:55.940]  уже точно составное. Пусть единица. Ну, а, значит,
[30:55.940 --> 31:00.940]  пусть для какого-то а, а в степени n-1, это единица
[31:00.940 --> 31:10.820]  по модулю n. Хорошо. Давайте опять скажем, что n это 1
[31:10.820 --> 31:14.820]  плюс m на 2 в степени s для каких-то m и s, где опять-таки
[31:14.820 --> 31:23.540]  m нечётно. Вот. Ну, если n само по себе чётное, то,
[31:23.540 --> 31:25.380]  ну, наверное, проверить чётное число на простоту не очень
[31:25.380 --> 31:28.180]  сложно. Вот здесь я могу в начало ещё добавить в
[31:28.180 --> 31:31.900]  проверку, что если n-чётное, то там, если двойка выводи
[31:31.900 --> 31:36.220]  простой, иначе составное. Что если n, давайте так,
[31:36.220 --> 31:42.980]  n-чётное отдельно. Дальше считаю, что он нечётный.
[31:42.980 --> 31:47.740]  Значит, вот такое. Мы знаем, что а в степени n-1-ой единицы
[31:47.740 --> 31:53.420]  по модулю n. Давайте тогда повозводим опять а во все
[31:53.420 --> 31:56.700]  степени кратной m. То есть давайте посмотрим на а в
[31:56.700 --> 32:03.340]  степени m, а в степени 2m, а в степени 4m, ну и так далее
[32:03.340 --> 32:05.460]  вплоть до, собственно, вот этого вот. А в степени
[32:05.460 --> 32:10.780]  m на 2 в степени. Это есть а минус 1. Давайте весь отряд
[32:10.780 --> 32:15.420]  посмотрим. Мы знаем, что последнее число здесь – это
[32:15.420 --> 32:24.380]  единица. Давайте пойдём тогда по этому ряду справа
[32:24.380 --> 32:29.020]  налево найдём первую не единицу. Это какие-то вычёты
[32:29.020 --> 32:32.300]  по модулю n. Давайте посмотрим на последний из них, который
[32:32.300 --> 32:40.700]  не равен единице по модулю n. Нет, мы просто линейным
[32:40.700 --> 32:43.260]  проходом. Тут s маленькая, поэтому можно не делать
[32:43.260 --> 32:47.100]  бинпоиск. Давайте найдём самое последнее, которое
[32:47.100 --> 32:50.940]  не сравнимо с единицей по модулю n. Тогда, если это
[32:50.940 --> 32:56.940]  не минус единица, то n точно составная. Давайте напишем.
[32:56.940 --> 33:05.340]  Пусть а в степени m на 2 в степени какой-нибудь t. Нет,
[33:05.340 --> 33:12.820]  t не хочу. r. Это не единица по модулю n. А в следующей
[33:12.820 --> 33:16.220]  степени, то есть а в степени m на 2 в r плюс 1, уже единица
[33:16.220 --> 33:24.860]  по модулю n. Так вот, если вот эта вот штука даже не
[33:24.860 --> 33:34.080]  минус единица, то n составная. Если я нашёл самую правую
[33:34.080 --> 33:36.020]  степень, которая не равна единице, и при этом она ещё
[33:36.020 --> 33:38.780]  и не минус единица, то n составная. Почему?
[33:38.780 --> 33:42.820]  Потому что для простых это должно быть не единица.
[33:42.820 --> 33:46.940]  Иными словами, мы нашли такое число, квадрат которого
[33:46.940 --> 33:56.660]  единица, но при этом само число не плюс 1 и не минус
[33:56.660 --> 34:04.780]  1. Такого в простых полях не бывает. Мы нашли решение
[34:04.780 --> 34:11.100]  вот такого уравнения, где x не плюс-минус 1. Я тогда
[34:11.100 --> 34:19.460]  думал, что это обязательно n составное. Идея самая
[34:19.460 --> 34:23.260]  простая, что если бы n было простым, то в ZP у нас многочлен
[34:23.260 --> 34:26.220]  второй степени имеет максимум 2 корня. А это как раз плюс-минус
[34:26.220 --> 34:29.020]  1. А мы сказали, что есть ещё какой-то третий противоречие.
[34:29.020 --> 34:31.660]  Либо, если вы не верите в эту теорему, можно было
[34:31.660 --> 34:36.020]  бы сказать, что смотрите, что значит, что x квадрат
[34:36.020 --> 34:41.460]  единица по моделю n. Значит, что x минус 1 на x плюс 1 делится
[34:41.460 --> 34:47.300]  на n. Вот отсюда оно следует. Причём, более того, давайте
[34:47.300 --> 35:02.580]  вот это вот сотрём всё. Да, ну если как раз x не плюс-минус
[35:02.580 --> 35:04.340]  1, тогда это означает. Потому что, смотрите, вот эти вот
[35:04.340 --> 35:08.740]  числа x плюс 1 и x минус 1, это какие-то элементы от
[35:08.740 --> 35:14.980]  1 до n минус 1. Вот эти два числа – это числа от 1 до n минус
[35:14.980 --> 35:25.220]  1. Да, потому что… Так, ну… Ну, x 0, тогда здесь будет
[35:25.220 --> 35:28.780]  n минус 1 и 1. Ну, имеется в виду, что если я их сначала
[35:28.780 --> 35:32.340]  возьму по моделю n, как элементы от 0 до n минус 1, тогда это
[35:32.340 --> 35:35.300]  будут… Короче, ни один из них не 0. Вот, ни один
[35:35.300 --> 35:38.900]  из них не 0 по моделю n. Значит, как остатки по моделю n – это
[35:38.900 --> 35:43.180]  числа от 1 до n минус 1. Но тогда n не может быть простым,
[35:43.180 --> 35:45.500]  потому что простое число не может быть представлено
[35:45.500 --> 35:49.980]  в виде разделения двух меньших чисел. А здесь ровно это
[35:49.980 --> 35:59.100]  написано. Так, ладно. Ну, мы что-то поняли. Значит,
[35:59.100 --> 36:02.060]  мы поняли, что если в какой-то момент вот так вот при проходе
[36:02.060 --> 36:05.940]  справа-налево мы нашли последнюю не единицу, если она еще
[36:05.940 --> 36:11.780]  не минус 1, то n точно составная. Вот. И этого нам хватит для
[36:11.780 --> 36:14.500]  алгоритма. Значит, алгоритм тогда будет следующим. Значит,
[36:14.500 --> 36:23.980]  алгоритм – это называется тест Миллера Рабина. Значит,
[36:23.980 --> 36:26.940]  на вход подается число m. Значит, опять в начале если
[36:27.540 --> 36:37.140]  как-то отдельно это разбираем, то разбираем отдельно. Иначе
[36:37.140 --> 36:43.260]  делаем следующее. Много раз, к большой раз, генерируем
[36:43.260 --> 36:57.460]  случайное a. От 1 до n-1. Значит, во-первых, если… Ну, считаем…
[36:57.460 --> 36:59.900]  А давайте не буду это говорить. Давайте просто посчитаем
[36:59.900 --> 37:03.100]  все вот эти вот степени. Давайте еще в самом начале
[37:03.100 --> 37:14.900]  скажем, что n – это 1 плюс m на 2 в степени s. Посчитаем… Ну,
[37:14.900 --> 37:23.260]  давайте как-нибудь это назову. v i t – это a в степени m на
[37:23.260 --> 37:30.700]  2 в степени i. Для всех i от 0 до s. То есть посчитаю все
[37:30.700 --> 37:46.580]  вот эти вот числа. Если v s t не единица, то n составное
[37:46.580 --> 37:52.100]  – это тест Ферма. Иначе давайте найдем самое правое
[37:52.100 --> 37:56.360]  неравное единица. Да, как вот здесь. Ну, если такого
[37:56.360 --> 37:59.180]  нет, если все эти единицы, то нам это число ничего
[37:59.180 --> 38:01.820]  не дает, и мы его просто скипаем. Если все они единицы,
[38:01.820 --> 38:06.740]  то тоже скипаем. Если… Ну, а все они единицы только
[38:06.740 --> 38:09.380]  если первые из них единицы. Потому что остальные получаются
[38:09.380 --> 38:12.820]  просто воздействиями в квадрат. Если v 0 равно единице,
[38:12.820 --> 38:17.500]  то continue. Это просто значит, что они все равны единице
[38:17.500 --> 38:20.140]  и мы никакой информации не получили. Иначе пусть
[38:20.140 --> 38:33.100]  r. Пусть r минимальное такое, что v r t, наоборот, максимальное
[38:33.100 --> 38:39.940]  такое, что v r t не единица. И если это самое v r t не минус
[38:39.940 --> 38:48.940]  1, то опять n составное. Ну, я просто повторил то, что
[38:48.940 --> 38:52.060]  я на самом деле здесь объяснял. И в конце, если мы за все
[38:52.060 --> 38:55.500]  эти k и t рации ничего не нашли, если мы не выявили, что n составное,
[38:55.500 --> 38:58.900]  то давайте скажем, что n скорее всего простое. Значит,
[38:58.900 --> 39:08.660]  иначе n скорее всего простое. Не знаю, нужно запятая
[39:08.660 --> 39:19.420]  или нет. Вроде нужно. Да нет, мы не пользуемся этим.
[39:19.420 --> 39:22.260]  Мы просто степень двойки делим, пока делится и все.
[39:22.260 --> 39:26.900]  Нам m не надо раскладывать. Только двойки выделить.
[39:26.900 --> 39:38.020]  Так, поняли алгоритм? Значит, смотрите, давайте я договорюсь
[39:38.020 --> 39:42.660]  сам собой и буду называть вот такие вот числа свидетелями.
[39:42.660 --> 39:51.420]  Ну, точнее, значит, если я сгенерировал такое a, что
[39:51.420 --> 39:55.820]  для него верно вот это или вот это, то я a называю свидетелем.
[39:55.820 --> 40:00.340]  Ну, свидетель непростоты. Я говорю, что a свидетель непростоты,
[40:00.340 --> 40:03.700]  если оно однозначно свидетельствует о том, что n составное. И
[40:03.700 --> 40:07.300]  моя цель как бы, мне бы хотелось, чтобы при генерации вот
[40:07.300 --> 40:11.220]  этого числа a я бы попадал в свидетеля. Давайте докажем,
[40:11.220 --> 40:18.140]  что свидетелей достаточно много. Значит, утверждение
[40:18.140 --> 40:20.940]  такое, что с вероятностью хотя бы одна вторая при составном
[40:20.940 --> 40:28.940]  n мы пойдем в свидетеля. Значит, при n составном, при составном
[40:28.940 --> 40:46.260]  n случайное a является свидетелем непростоты с вероятностью
[40:46.260 --> 40:53.500]  хотя бы одна вторая. Вот. Ну, если это мы докажем,
[40:53.500 --> 40:55.740]  что получается с вероятностью одна вторая хотя бы мы всегда
[40:55.820 --> 40:59.540]  попадаем в свидетеля, значит, тогда свидетель либо вот
[40:59.540 --> 41:01.340]  здесь вот скажет что n составное, либо вот здесь вот скажет
[41:01.340 --> 41:04.740]  что n составное. Если мы сделаем, скажем, сто раз, то вероятность
[41:04.740 --> 41:06.980]  хотя бы один раз попасть в свидетеля, это будет уже
[41:06.980 --> 41:09.740]  ну там один минус два в минус сотый. Ну, короче, вероятность
[41:09.740 --> 41:11.780]  ошибиться будет очень маленькой. Специально маленькой, пока
[41:11.780 --> 41:38.900]  большом. Хорошо. Давайте попробуем доказать это. Я это буду
[41:38.900 --> 41:42.420]  доказывать так. Я докажу, что свидетелей больше равно
[41:42.420 --> 41:47.300]  чем несвидетелей, предъявив инъекцию из несвидетелей
[41:47.300 --> 41:52.220]  в свидетеля. Значит, ну понятно, несвидетель это те, для
[41:52.220 --> 41:55.860]  которых это неверно все. То есть, если вы сгенерили
[41:55.860 --> 41:59.260]  a в качестве несвидетеля, то ни одна проверка не сработает
[41:59.260 --> 42:03.280]  и он посчитает, что n пока что простое. Так вот, я построю
[42:03.280 --> 42:12.160]  инъекцию из несвидетелей в свидетелей. Это будет инъективное
[42:12.160 --> 42:15.560]  отображение. Ну и значит, этих должно быть хотя бы
[42:15.560 --> 42:19.840]  столько, сколько этих, значит, их хотя бы половина. Да?
[42:19.840 --> 42:29.120]  Вот. Ну, давайте попробуем это сделать. Хорошо, давайте
[42:29.120 --> 42:32.680]  посмотрим на несвидетеля. Что такое несвидетель? Несвидетели
[42:32.680 --> 42:36.000]  бывают двух типов. Это либо когда во всей этой последовательности
[42:36.000 --> 42:41.360]  все единицы, да, это вот случай, когда r даже не нашлось
[42:41.360 --> 42:44.080]  такого, что vrt не равно единице. Значит, первый тип свидетеля
[42:44.080 --> 42:46.240]  – это когда все вот эти единицы. Тогда мы что сказать не
[42:46.240 --> 42:49.400]  можем, мы его просто скипаем. Значит, да, давайте напишем,
[42:49.400 --> 42:52.960]  что первый тип несвидетелей. Первый тип – это когда
[42:52.960 --> 42:57.600]  все степени, все v вплоть до, какого там, s-того, они
[42:57.600 --> 43:01.800]  все единицы. Значит, могут быть такие. Второй тип свидетелей
[43:01.800 --> 43:06.560]  поинтереснее. Это когда не все единицы, но последние
[43:06.560 --> 43:10.240]  не единицы – это минус единицы. То есть там сначала идут
[43:10.240 --> 43:14.600]  какие-то числа, потом какой-то vrt равно минус единицы, а
[43:14.600 --> 43:26.560]  начиная с vr плюс 1 уже все единицы. Да? Других не бывает.
[43:26.560 --> 43:28.680]  При составном случайной… Нет, все правильно. Ресвидетель
[43:28.840 --> 43:32.600]  хотя бы на второй, да, все правильно. Хорошо, значит,
[43:32.600 --> 43:34.400]  более того, смотрите, я утверждаю, что свидетелей второго
[43:34.400 --> 43:40.960]  типа существуют. Например, это минус единицы. Точнее,
[43:40.960 --> 43:51.960]  это не свидетель второго типа. Ну почему? Потому что
[43:52.720 --> 43:58.880]  m у меня нечетная, v0 – это a в степени m. Значит, это будет
[43:58.880 --> 44:00.880]  минус единица, потому что я минус единицы возвожу
[44:00.880 --> 44:05.720]  в нечетную степень. Значит, v1, как v0 в квадрате, уже будет
[44:05.720 --> 44:11.480]  единицей. Значит, неверно, что они все единицы, но
[44:11.480 --> 44:14.000]  начиная с какого-то момента они минус 1, а потом и единица.
[44:14.000 --> 44:17.880]  Ну, значит, в самом начале v0 будет минус 1, а потом все
[44:17.880 --> 44:20.200]  остальные будут единицами. Значит, по крайней мере один
[44:20.200 --> 44:22.440]  такой чувак есть, по крайней мере один несвидетель второго
[44:22.440 --> 44:29.440]  типа точно существует. Хорошо, тогда я имею право рассмотреть
[44:29.880 --> 44:35.760]  среди всех несвидетелей второго типа того, у которого r максимально
[44:35.760 --> 44:42.760]  возможно. Значит, среди всех несвидетелей второго типа
[44:43.520 --> 44:50.520]  рассмотрим такое h. Давайте я так напишу, что h в степени
[45:05.680 --> 45:12.680]  m на 2 в степени j равно минус 1 по моделю n. Значит,
[45:12.960 --> 45:19.960]  j максимально возможное. Здесь m на 2 в степени j написано.
[45:20.960 --> 45:24.520]  То есть я рассматриваю такое число, что у него в этой
[45:24.520 --> 45:27.720]  последовательности v1, который я здесь построил, v0, v1 и так
[45:27.720 --> 45:31.000]  далее, минус 1 находится на самом правом месте, имеет
[45:31.000 --> 45:33.240]  максимально возможный индекс. Среди всех возможных
[45:33.240 --> 45:36.360]  чисел такого типа я отодвигаю как можно правее эту минус
[45:36.360 --> 45:39.200]  1. Беру максимальный aj, для которого существует
[45:39.200 --> 45:44.440]  какой-то такой aj. Ну и поскольку они существуют, я имею право
[45:44.440 --> 45:51.440]  выбрать из них максимальное. Да, хорошо. И вот я с ним
[45:54.640 --> 46:00.840]  сейчас буду работать. Давайте рассмотрим n. Я сейчас живу
[46:00.840 --> 46:05.840]  в парадигме, что n составное. При составном n. Значит,
[46:05.840 --> 46:08.560]  как может выглядеть составное n? Ну, давайте рассмотрим
[46:08.560 --> 46:11.200]  первый простой случай, когда n это степень простого,
[46:11.200 --> 46:18.200]  причем степень хотя бы вторая. Случай первый. Пусть n это
[46:19.480 --> 46:26.480]  какой-то кувьетой, где e хотя бы двойка, а q простое. Так,
[46:32.400 --> 46:35.360]  сейчас, мне получается aj здесь будет даже не нужно,
[46:36.360 --> 46:40.800]  насколько я понимаю. Да, ну ладно, не страшно. Зато
[46:40.800 --> 46:45.240]  мы поймем, в какую сторону тут можно будет думать. Так
[46:45.240 --> 46:49.680]  вот, смотрите, давайте возьмем в качестве, пусть n это степень
[46:49.680 --> 46:56.680]  кушки какая-то. Тогда, давайте посмотрим на такое число.
[46:56.680 --> 47:03.680]  Значит, я отражаю, что это свидетель. Почему свидетель?
[47:19.960 --> 47:22.800]  Давайте возведем это все сначала в n степень. Давайте
[47:22.800 --> 47:25.920]  возведем t в степени n. А, сейчас, или даже в степень
[47:25.920 --> 47:28.920]  q мне хватит. Сейчас, одну секунду. В степень q я просто
[47:28.920 --> 47:35.920]  возвожу. Да, да, да. Ну, могу a написать. Ну, то же самое,
[47:40.520 --> 47:42.560]  да. Ну, это в смысле вот, я просто его по-другому
[47:42.560 --> 47:44.560]  назвал, чтобы оно было вот именно таким специфическим.
[47:44.560 --> 47:46.320]  А это у меня было случайно, aj это вот такое, которое
[47:46.320 --> 47:50.360]  я здесь выбрал. Да. Итак, значит, почему свидетель? Давайте
[47:50.520 --> 47:54.720]  возведем в n степень, посмотрим, что получится. Это будет
[47:54.720 --> 48:01.720]  1 плюс q в степени e-1 в степени n. Дальше давайте по биному
[48:04.640 --> 48:11.640]  Ньютона я это раскрою. Начнем вот единица. Плюс n на q в степени
[48:12.160 --> 48:17.320]  e-1. Это e, да, везде. Ну, можно, не важно какая-то
[48:17.320 --> 48:24.320]  буква. У меня e. Плюс и так далее. Значит, там все будут
[48:25.720 --> 48:30.720]  множители, которые делятся на квадрат вот этого. Значит,
[48:30.720 --> 48:33.680]  делятся на n. Все вот эти остальные будут делиться
[48:33.680 --> 48:38.800]  на n. Потому что они делятся на квадрат q в степени e-1,
[48:38.800 --> 48:41.400]  поскольку e хотя бы двойка, то квадрат будет хотя бы
[48:41.400 --> 48:45.360]  q в степени e. Все вот эти вот штучки будут делиться
[48:45.420 --> 48:48.740]  на n. Ну, и это тоже делится на n. На самом деле мы получили,
[48:48.740 --> 48:55.740]  что t в n на этой единице по моделю n. Ну, вот. Значит,
[48:57.480 --> 49:01.520]  тогда t в n минус первой уже не может быть единицей
[49:01.520 --> 49:07.200]  по моделю n. Потому что если бы это было единицей по
[49:07.200 --> 49:09.980]  моделю в n и это было бы единицей по моделю в n, то обязательно
[49:09.980 --> 49:13.080]  t должно было быть единицей по моделю n. А t как мы видим
[49:13.080 --> 49:19.680]  ну не единица, а вот это вот по модулю n.
[49:19.680 --> 49:21.760]  Ну смотрите, мы знаем, что t в n – это единица по модулю
[49:21.760 --> 49:22.760]  n.
[49:22.760 --> 49:26.400]  Тогда, если бы это тоже было единицей по модулю n,
[49:26.400 --> 49:30.760]  то t обязательно было бы единицей по модулю n, а t – это не единицей
[49:30.760 --> 49:32.400]  по модулю n.
[49:32.400 --> 49:36.040]  Ну вот, значит t – свидетель, потому что для него просто
[49:36.040 --> 49:37.040]  тест Свермасс работал.
[49:37.040 --> 49:38.040]  Да?
[49:38.040 --> 49:40.800]  n – первая степень числа не единица по модулю n.
[49:40.800 --> 49:43.480]  Значит t – свидетель, очевидно.
[49:43.480 --> 49:44.480]  Хорошо.
[49:44.480 --> 49:49.120]  Так, значит, хотя бы одного свидетеля мы нашли, супер.
[49:49.120 --> 49:50.840]  Теперь давайте вот ту самую инъекцию приявим.
[49:50.840 --> 50:01.520]  Инъекция очень простая, она просто берет и любого
[50:01.520 --> 50:02.840]  несвидетеля домножает на t.
[50:02.840 --> 50:09.440]  Значит, вот если d был какой-то несвидетель, то мы в качестве
[50:09.440 --> 50:13.480]  инъекции рассматриваем просто d умножить на t по
[50:13.480 --> 50:14.480]  модулю n.
[50:14.480 --> 50:20.920]  Нужно доказать две вещи, во-первых, что для любого
[50:20.920 --> 50:25.760]  несвидетеля это свидетель, а во-вторых, что это инъекция.
[50:25.760 --> 50:27.920]  Ну давайте первое докажем, почему dt – это свидетель.
[50:27.920 --> 50:36.040]  Ну смотрите, если d был несвидетелем, в частности, он проходил
[50:36.040 --> 50:40.080]  тест фирма, то есть для него d в степени n-1 было единицей
[50:40.080 --> 50:43.000]  по модулю n, но раз-то не свидетель.
[50:43.000 --> 50:47.960]  А t в степени n-1 не единица, значит их произведение в
[50:47.960 --> 50:48.960]  n-1 тоже не единица.
[50:48.960 --> 51:00.840]  Значит, мы знаем вот это, значит dt – это не единица
[51:01.840 --> 51:04.840]  по модулю n.
[51:04.840 --> 51:05.840]  Значит, это свидетель.
[51:05.840 --> 51:06.840]  Да?
[51:06.840 --> 51:14.360]  Хорошо, теперь почему это инъекция?
[51:14.360 --> 51:17.360]  Почему f-инъекция?
[51:17.360 --> 51:24.840]  Ну пусть не так, пусть какие-то две d-шки он склеивает, пусть
[51:24.840 --> 51:32.840]  d-1 на t внезапно склеилось с d-2 на t по модулю n, пусть
[51:32.840 --> 51:33.840]  они склеились.
[51:33.840 --> 51:44.080]  Хорошо, так, тогда давайте напишем следующую цепочку
[51:44.080 --> 51:45.080]  сравнений.
[51:45.080 --> 51:50.840]  Значит, d-1, давайте я умножу d-1 на t в степени n.
[51:50.840 --> 51:53.880]  Я знаю, что t в степени n – это единица, поэтому я могу
[51:53.880 --> 51:57.880]  написать, что d-1 – это d-1 на t в степени n.
[51:57.880 --> 52:00.880]  Потому что это – это 1 по модулю n.
[52:00.880 --> 52:05.880]  Дальше, я вычленяю одну t-шку из вот этого вот произведения,
[52:05.880 --> 52:09.880]  у меня остается d-1 на t в степени n-1.
[52:09.880 --> 52:19.880]  Вот это вот равно d-2 на t в степени n-1, но вот эта единица,
[52:19.880 --> 52:22.880]  поэтому остается d-2.
[52:22.880 --> 52:26.880]  Значит, если для каких-то d-1, d-2 вот это верно, то d-1
[52:26.880 --> 52:27.880]  равно d-2.
[52:27.880 --> 52:35.880]  То есть, еще раз, я предположил противно, что f не инъекция,
[52:35.880 --> 52:38.880]  f склеивает какие-то две дешки, то есть для двух разных
[52:38.880 --> 52:42.880]  дешек d-1, d-2 их образы совпали, то есть d-1 на t равно d-2
[52:42.880 --> 52:43.880]  на t по модулю n.
[52:43.880 --> 52:46.880]  Ну и дальше каким-то арифметическими трюками доказал тогда,
[52:46.880 --> 53:14.880]  что в этом случае мы победили, мы доказали то, что хотели,
[53:14.880 --> 53:17.880]  что свидетелей хотя бы столько, сколько не свидетели.
[53:17.880 --> 53:19.880]  Значит, вероятностью больше, чем одна вторая, хотя бы
[53:19.880 --> 53:21.880]  одна вторая, мы поведем как раз вне свидетеля.
[53:21.880 --> 53:24.880]  Это только в первом случае.
[53:24.880 --> 53:25.880]  Теперь второй случай.
[53:25.880 --> 53:26.880]  Да.
[53:26.880 --> 53:31.880]  А неважно, неважно.
[53:31.880 --> 53:35.880]  Это работает для любого несвидетеля, хоть первого, хоть второго.
[53:35.880 --> 53:37.880]  Тут я нигде это не использую.
[53:37.880 --> 53:42.880]  Так, ну второй случай, когда n это не степень простого,
[53:42.880 --> 53:45.880]  тогда я утверждаю, что n можно разложить в произведение
[53:45.880 --> 53:49.880]  двух взаимно простых чисел.
[53:49.880 --> 53:53.880]  q и r взаимно простые, то есть их наибольший общий делитель
[53:53.880 --> 53:55.880]  единицы.
[53:55.880 --> 53:58.880]  Ну понятно, если n составной, а при этом не степень простого,
[53:58.880 --> 54:02.880]  то при разложении на степени простых можно, скажем, в
[54:02.880 --> 54:04.880]  качестве q взять все степени одного простого, в качестве
[54:04.880 --> 54:05.880]  r все, что осталось.
[54:05.880 --> 54:08.880]  Тогда они будут взаимно простые.
[54:08.880 --> 54:09.880]  Вот.
[54:09.880 --> 54:14.880]  Хорошо, тогда вот нам сейчас придется вот с этим h повозиться.
[54:14.880 --> 54:18.880]  Вспоминаем, что у меня было какой-то h.
[54:18.880 --> 54:26.880]  Тогда, значит, я утверждаю, что существует такое t, что
[54:26.880 --> 54:32.880]  t сравнимо с h по модулю q и при этом сравнимо с единицей
[54:32.880 --> 54:33.880]  по модулю r.
[54:33.880 --> 54:43.880]  Скажите, пожалуйста, почему.
[54:43.880 --> 54:48.880]  Да, китайской теряемостатках у меня просто взаимно простые
[54:48.880 --> 54:50.880]  модули q и r.
[54:50.880 --> 54:52.880]  Я такие системы умею спокойно решать.
[54:52.880 --> 54:53.880]  Это просто КТО.
[54:53.880 --> 55:00.880]  Это просто китайская теряемостатка.
[55:00.880 --> 55:01.880]  Вот.
[55:01.880 --> 55:03.880]  Теперь давайте докажем, что t свидетель.
[55:03.880 --> 55:06.880]  Если t является решением такой системы, то t обязательно
[55:06.880 --> 55:07.880]  свидетель.
[55:07.880 --> 55:17.880]  Покажем, что t свидетель.
[55:17.880 --> 55:20.880]  Так.
[55:20.880 --> 55:26.880]  Ну, давайте рассмотрим его вот эту вот степень m на
[55:26.880 --> 55:27.880]  2 вжитой.
[55:27.880 --> 55:35.880]  Давайте рассмотрим его степень m на 2 вжитой.
[55:35.880 --> 55:39.880]  Ну, понятно тогда, если я просто вот это вот сравнение
[55:39.880 --> 55:42.880]  возведу в степень m на 2 вжитой, у меня здесь останется
[55:42.880 --> 55:49.880]  h в степени m на 2 вжитой и это будет минус 1 по модулю q.
[55:49.880 --> 55:52.880]  Ну, потому что h в этой степени был минус 1 по модулю
[55:52.880 --> 55:53.880]  m.
[55:53.880 --> 55:57.880]  Значит, по любому делящему ему оно тоже будет минус
[55:57.880 --> 55:58.880]  1 по модулю.
[55:58.880 --> 56:01.880]  Значит, с одной стороны, с другой стороны, t в этой
[56:01.880 --> 56:08.880]  же степени это единица по модулю r.
[56:08.880 --> 56:15.880]  Ну, потому что я просто это возвожу в любую степень,
[56:15.880 --> 56:16.880]  остается справа единица.
[56:16.880 --> 56:17.880]  Так.
[56:17.880 --> 56:21.880]  Ну, и тогда я утверждаю, что t свидетель обязательно.
[56:21.880 --> 56:28.880]  Почему?
[56:28.880 --> 56:34.880]  Потому что, если я наконец рассмотрю эту степень t по
[56:34.880 --> 56:41.880]  модулю n, то это одновременно не плюс-минус единица.
[56:41.880 --> 56:44.880]  Потому что, если бы она была единицей, то здесь было
[56:44.880 --> 56:45.880]  бы 1, 1.
[56:45.880 --> 56:48.880]  Если бы эта степень t была бы единицей по модулю n,
[56:48.880 --> 56:50.880]  то определение и на q, и на r у меня бы тоже оставались
[56:50.880 --> 56:51.880]  остатки 1.
[56:51.880 --> 56:53.880]  Но мы знаем, что здесь минус 1, 1.
[56:53.880 --> 56:54.880]  То же самое.
[56:54.880 --> 56:56.880]  Эта штука не может быть минус единицей, потому что
[56:56.880 --> 56:59.880]  иначе бы здесь было минус 1, минус 1.
[56:59.880 --> 57:01.880]  Значит, эта штука не может быть плюс-минус единицы
[57:01.880 --> 57:02.880]  по модулю n.
[57:02.880 --> 57:03.880]  С одной стороны.
[57:03.880 --> 57:06.880]  С другой стороны, если я наращу степень ж на единицу
[57:06.880 --> 57:09.880]  хотя бы, то у меня будет здесь и здесь единица, потому
[57:09.880 --> 57:11.880]  что все возвертывается просто в квадрат.
[57:11.880 --> 57:17.880]  Значит, вот это не минус 1, однако t в степени m на 2 в
[57:17.880 --> 57:22.880]  степени g плюс 1 уже единица по модулю n.
[57:22.880 --> 57:24.880]  Значит, t-свидетель.
[57:24.880 --> 57:28.880]  Потому что мы нашли какую-то его степень, равную единице,
[57:28.880 --> 57:32.880]  такую, что предыдущая степень не единица и не минус единица.
[57:32.880 --> 57:34.880]  Значит, t-свидетель там, в одной из строчек это было
[57:34.880 --> 57:35.880]  проверено.
[57:35.880 --> 57:36.880]  Ок?
[57:36.880 --> 57:45.880]  Да, и теперь то же самое.
[57:45.880 --> 57:54.880]  Вот, значит, мы нашли свидетеля.
[57:54.880 --> 57:57.880]  Теперь давайте докажем, что точно такое же отображение
[57:57.880 --> 58:01.880]  из не свидетелей, получается, путем домножения на тот
[58:01.880 --> 58:04.880]  самый t, это будет опять такие инъекции, которые мы искали.
[58:04.880 --> 58:10.880]  Значит, опять давайте для любого не свидетеля положим
[58:10.880 --> 58:13.880]  f от d, это d на t по модулю n.
[58:14.880 --> 58:16.880]  И опять давайте докажем те же самые две вещи, что
[58:16.880 --> 58:19.880]  мы получаем обязательно свидетеля и что это инъекция.
[58:19.880 --> 58:21.880]  Тогда мы победим.
[58:21.880 --> 58:24.880]  Ну, короче, сделаем то же самое во втором случае.
[58:24.880 --> 58:27.880]  Значит, первое, почему dt-свидетель?
[58:34.880 --> 58:37.880]  Почему dt-свидетель?
[58:37.880 --> 58:39.880]  Сейчас скажу.
[58:43.880 --> 58:46.880]  Причем d был не свидетель, да?
[58:46.880 --> 58:49.880]  То там минус 1, 1.
[58:49.880 --> 58:51.880]  Да.
[58:55.880 --> 58:58.880]  Ну, смотрите, раз d не свидетель, то получается, когда мы
[58:58.880 --> 59:00.880]  считаем его степенью, вот это вот d в m-той, 2 в m-той,
[59:00.880 --> 59:04.880]  4 в m-той, 8 в m-той и так далее, то у нас либо не все единицы,
[59:04.880 --> 59:06.880]  либо с какого-то шага, ну, в каком-то моменте минус
[59:06.880 --> 59:08.880]  1, а потом все единицы.
[59:08.880 --> 59:12.880]  Причем этот шаг, он не правее, чем g.
[59:12.880 --> 59:15.880]  Мы специально взяли g, такое, что...
[59:15.880 --> 59:18.880]  Ну, короче, максимально возможное g взяли.
[59:18.880 --> 59:22.880]  Это значит, что, смотрите, раз d не свидетель,
[59:22.880 --> 59:25.880]  то получается, что...
[59:25.880 --> 59:29.880]  Ну, давайте я так в общем виде напишу, что какая-то его там степень
[59:29.880 --> 59:32.880]  d на m в степени 2 в i-той.
[59:32.880 --> 59:36.880]  Вот здесь вот минус 1, а все, начиная с и плюс 1,
[59:36.880 --> 59:39.880]  уже единицы.
[59:39.880 --> 59:43.880]  Ну, вот, в общем виде не свидетель такой.
[59:43.880 --> 59:46.880]  И при этом и не больше, чем g.
[59:46.880 --> 59:48.880]  Это мы знаем, потому что g мы специально выбрали максимальным.
[59:48.880 --> 59:52.880]  Среди всех не свидетелей мы выбрали g такое, что...
[59:52.880 --> 59:55.880]  Ну, короче, при нем это максимальная степень, при которой получается
[59:55.880 --> 59:57.880]  минус 1 вот здесь.
[59:57.880 --> 59:59.880]  Значит, и не больше, чем g, ну и тогда если я все перемножу,
[59:59.880 --> 01:00:02.880]  то у меня как раз получится то, что надо, потому что, смотрите,
[01:00:02.880 --> 01:00:08.880]  значит, это значит, что d в степени m в степени 2 в степени g
[01:00:08.880 --> 01:00:11.880]  это плюс-минус 1.
[01:00:14.880 --> 01:00:17.880]  Да, потому что если это минус 1, то все, что правее,
[01:00:17.880 --> 01:00:19.880]  ну как бы все, что начинается с этой позиции правее,
[01:00:19.880 --> 01:00:21.880]  либо единицы, либо минус 1.
[01:00:21.880 --> 01:00:25.880]  Поэтому d в такой степени это плюс-минус 1.
[01:00:25.880 --> 01:00:31.880]  Ну, и тогда dt в степени m на 2 в степени g.
[01:00:31.880 --> 01:00:35.880]  Это мы знаем, что значит d-шка это минус 1 или плюс 1.
[01:00:35.880 --> 01:00:37.880]  А t это не плюс 1 и не минус 1.
[01:00:37.880 --> 01:00:39.880]  Значит, тогда это тоже не плюс-минус 1.
[01:00:49.880 --> 01:00:52.880]  Нет, иногда может быть минус 1, если и равно g.
[01:00:52.880 --> 01:00:55.880]  Да, если равенство, то здесь будет минус 1.
[01:00:56.880 --> 01:00:58.880]  Вот, значит...
[01:01:06.880 --> 01:01:10.880]  Да, да, да, да.
[01:01:10.880 --> 01:01:12.880]  Ну, значит, их произведение в этой степени не плюс-минус 1.
[01:01:12.880 --> 01:01:15.880]  Если здесь плюс-минус 1, если вот это в степени будет плюс-минус 1,
[01:01:15.880 --> 01:01:17.880]  а это не плюс-минус 1, то когда перенажать,
[01:01:17.880 --> 01:01:19.880]  не может получиться плюс-минус 1.
[01:01:20.880 --> 01:01:21.880]  Вот.
[01:01:21.880 --> 01:01:23.880]  Значит, эта штука реально не свидетель.
[01:01:23.880 --> 01:01:25.880]  Ну, мы показали, что в такой степени это не плюс-минус 1.
[01:01:25.880 --> 01:01:31.880]  А если я степень еще наращу и напишу 2g плюс 1,
[01:01:31.880 --> 01:01:35.880]  тогда мы знаем, что и эта единица, и эта единица, значит, g будет 1.
[01:01:38.880 --> 01:01:41.880]  Значит, dt свидетель.
[01:01:41.880 --> 01:01:46.880]  Потому что его ds с едной степени одна единица, а предыдущая не единица и не минус единица.
[01:01:46.880 --> 01:01:47.880]  Ну, вот.
[01:01:47.880 --> 01:01:50.880]  А почему эта инъекция докажется аналогична?
[01:01:50.880 --> 01:01:52.880]  Ну, а почему инъекция?
[01:01:53.880 --> 01:01:55.880]  Почему инъекция?
[01:01:58.880 --> 01:02:03.880]  Значит, ну пусть d1t сравнимо с d2t.
[01:02:09.880 --> 01:02:11.880]  Не на t в минус 1, только на что-то другое надо.
[01:02:12.880 --> 01:02:16.880]  Не на t в минус 1, только на что-то другое надо, видимо.
[01:02:17.880 --> 01:02:20.880]  Видимо, на вот это вот надо домножить.
[01:02:25.880 --> 01:02:28.880]  То есть мне надо домножить на что-то, чтобы потом свернулась в единицу.
[01:02:31.880 --> 01:02:32.880]  Ну да, да, да.
[01:02:33.880 --> 01:02:47.880]  Значит, ну давайте домножим на t в степени m на 2 в степени g плюс 1, минус 1.
[01:02:49.880 --> 01:02:54.880]  Тогда у меня как раз слева и справа будет t в степени m на 2 в степени g плюс 1.
[01:02:54.880 --> 01:03:00.880]  M на 2 в степени g плюс 1.
[01:03:00.880 --> 01:03:04.880]  А это мы знаем что единица, потому что вот это тут написано.
[01:03:06.880 --> 01:03:08.880]  Значит, за 1 равно d2, противоречие.
[01:03:18.880 --> 01:03:19.880]  Да, да, да.
[01:03:19.880 --> 01:03:21.880]  Ну я просто показал, какие они бывают.
[01:03:21.880 --> 01:03:23.880]  Сказал, что есть хотя бы один второго типа.
[01:03:23.880 --> 01:03:26.880]  И там выбираю максимум. Внутри второго типа выбираю максимум, да.
[01:03:32.880 --> 01:03:34.880]  Нет, смотрите, инъекция у нас одинакова.
[01:03:34.880 --> 01:03:38.880]  Я просто, во-первых, у меня различные t, по-разному t выбираются.
[01:03:38.880 --> 01:03:41.880]  Ну то есть мне надо доказать, что есть какой-то свидетель, грубо говоря.
[01:03:41.880 --> 01:03:44.880]  В разных случаях по-разному я доказываю, во-первых.
[01:03:44.880 --> 01:03:46.880]  Во-вторых, вот здесь по-разному доказательства проходят.
[01:03:51.880 --> 01:03:52.880]  Ну да.
[01:03:54.880 --> 01:03:56.880]  Не, не, не, еще раз.
[01:03:56.880 --> 01:03:59.880]  Я два раза доказываю в разных случаях.
[01:03:59.880 --> 01:04:02.880]  В первом случае я доказывал, когда n это степень простого.
[01:04:02.880 --> 01:04:05.880]  Там немножко другое рассуждение, потому что я там по-другому выбираю t.
[01:04:05.880 --> 01:04:08.880]  Да, там такое же отображение, там та же инъекция.
[01:04:08.880 --> 01:04:11.880]  Но там другое t, и там я по-другому доказываю.
[01:04:11.880 --> 01:04:14.880]  А здесь другой случай. Я уже так доказать не могу.
[01:04:14.880 --> 01:04:18.880]  У меня n это произведение двух взаимнопростых чисел.
[01:04:18.880 --> 01:04:20.880]  И надо по-другому рассуждать.
[01:04:21.880 --> 01:04:24.880]  Просто два случая, они по-разному разбираются.
[01:04:24.880 --> 01:04:26.880]  Их одинаково не получается.
[01:04:26.880 --> 01:04:28.880]  Ну вот.
[01:04:28.880 --> 01:04:31.880]  Все, значит, мы доказали, что свидетелей хотя бы половина.
[01:04:31.880 --> 01:04:33.880]  Значит, с хорошей вероятностью, если мы много раз запустимся,
[01:04:33.880 --> 01:04:36.880]  то с хорошей вероятностью мы хотя бы один раз по путем свидетеля.
[01:04:37.880 --> 01:04:39.880]  Такие дела.
[01:04:41.880 --> 01:04:43.880]  Ну, хорошо, хорошо.
[01:04:43.880 --> 01:04:46.880]  Тогда с проверкой на просту разобрались.
[01:04:47.880 --> 01:04:50.880]  Так, остается 15 минут. Правильно, понял?
[01:04:52.880 --> 01:04:55.880]  Интересно. Ну ладно, посмотрим.
[01:04:55.880 --> 01:04:57.880]  Может, у тебя на уровне идеи просто.
[01:04:57.880 --> 01:05:00.880]  А? Нет, наоборот.
[01:05:00.880 --> 01:05:04.880]  Значит, теперь давайте перейдем к последней задаче.
[01:05:04.880 --> 01:05:07.880]  Значит, факторизации.
[01:05:09.880 --> 01:05:12.880]  Представьте, что вам дано число n.
[01:05:12.880 --> 01:05:15.880]  Вы, например, прогнали его через тест Миллера Рабина,
[01:05:15.880 --> 01:05:17.880]  поняли, что оно составное.
[01:05:17.880 --> 01:05:20.880]  И вам надо разложить его на множители.
[01:05:23.880 --> 01:05:26.880]  Разложить на множители.
[01:05:33.880 --> 01:05:36.880]  Вот. Ну, давайте я это явным образом пропишу,
[01:05:36.880 --> 01:05:39.880]  что если у вас такая задача, вам просто дается n,
[01:05:39.880 --> 01:05:41.880]  и вам надо его факторизовать, то есть разложить на множители,
[01:05:41.880 --> 01:05:43.880]  всегда сначала разумно провести тест на простоту.
[01:05:43.880 --> 01:05:46.880]  Потому что если оно простое, то можно ничего больше не делать.
[01:05:46.880 --> 01:05:49.880]  Конечно, оно само по себе является своими разложениями на простые.
[01:05:49.880 --> 01:05:56.880]  Перед этим запустили тест на простоту.
[01:06:00.880 --> 01:06:03.880]  Теперь мы считаем, что n составное,
[01:06:03.880 --> 01:06:06.880]  по крайней мере с вероятностью экспоненциально маленькое,
[01:06:06.880 --> 01:06:08.880]  оно может быть простым.
[01:06:08.880 --> 01:06:10.880]  Но вот мы считаем, что оно наоборот.
[01:06:10.880 --> 01:06:12.880]  Короче, мы считаем, что мы правильно посчитали простоту.
[01:06:12.880 --> 01:06:14.880]  Мы считаем, что оно составное.
[01:06:14.880 --> 01:06:17.880]  Вот давайте теперь составное число раскладывать.
[01:06:19.880 --> 01:06:22.880]  Так. Что будем делать?
[01:06:24.880 --> 01:06:27.880]  Мы будем жить в Zn.
[01:06:28.880 --> 01:06:31.880]  То есть будем рассматривать все числа, как остатки по моделю n.
[01:06:32.880 --> 01:06:38.880]  И, смотрите, вот здесь нам хочется вести какую-то функцию,
[01:06:38.880 --> 01:06:43.880]  которая довольно случайно перемешивала бы элементы Zn.
[01:06:44.880 --> 01:06:47.880]  Вот в качестве такой функции обычно берут x² плюс 1.
[01:06:51.880 --> 01:06:57.880]  Вот если я живу в Zn, и просто по x считаю x² плюс 1,
[01:06:58.880 --> 01:07:03.880]  то вот это, скажем так, эмпирически очень похоже на просто случайное перемешивание.
[01:07:03.880 --> 01:07:05.880]  Но это не объект.
[01:07:09.880 --> 01:07:11.880]  Ну, во-первых, и бог с ним.
[01:07:12.880 --> 01:07:14.880]  Да, во-вторых, почему?
[01:07:15.880 --> 01:07:17.880]  А, x минус x склеится, да.
[01:07:17.880 --> 01:07:20.880]  Ну, окей, там, скорее всего, на самом деле, типа...
[01:07:22.880 --> 01:07:24.880]  Короче, нормально, пофигу.
[01:07:25.880 --> 01:07:27.880]  Ну, значит, не перемешивает.
[01:07:27.880 --> 01:07:31.880]  Хорошо, перемешивает плохое слово, близко к плохому случайно, скажем так.
[01:07:32.880 --> 01:07:37.880]  Иными словами, на самом деле, по значению вот этой штуки x найти сложно.
[01:07:39.880 --> 01:07:41.880]  Это прям точно.
[01:07:41.880 --> 01:07:43.880]  То есть, если вам дали какое-то большое число n,
[01:07:43.880 --> 01:07:46.880]  если вы знаете вот этого число, ну, грубо говоря,
[01:07:46.880 --> 01:07:49.880]  ну, иными словами, вы знаете просто x², то вот x найти сложно.
[01:07:49.880 --> 01:07:53.880]  Короче, извлечь корень по произвольному модулю – это сложная задача.
[01:07:54.880 --> 01:07:55.880]  Вот.
[01:07:55.880 --> 01:08:01.880]  И это там где-то в криптографии используется, что вот такая вот функция является односторонней.
[01:08:01.880 --> 01:08:03.880]  Ну, по крайней мере, предположительно.
[01:08:03.880 --> 01:08:05.880]  Что по x² найти x сложно.
[01:08:05.880 --> 01:08:08.880]  Но давайте жить в таком предположении, давайте считать, что это, ну, окей,
[01:08:08.880 --> 01:08:12.880]  там, если не случайно перемешивать, то как-то там, похоже на случайно, в каком-то смысле.
[01:08:12.880 --> 01:08:18.880]  Тут алгоритм будет именно такой, эвристический, про него ничего не доказано,
[01:08:18.880 --> 01:08:20.880]  но как-то вот он на практике хорошо работает.
[01:08:24.880 --> 01:08:25.880]  Вот.
[01:08:25.880 --> 01:08:27.880]  Хорошо, значит, что будет происходить?
[01:08:27.880 --> 01:08:29.880]  Значит, мы сделаем следующее.
[01:08:29.880 --> 01:08:30.880]  Значит, идея такая.
[01:08:30.880 --> 01:08:32.880]  Давайте выберем случайно какой-то x0.
[01:08:32.880 --> 01:08:34.880]  x0 – случайный элемент из Zt.
[01:08:38.880 --> 01:08:43.880]  Ну, и давайте строить последовательность, получающуюся просто применением f от предыдущему x.
[01:08:45.880 --> 01:08:47.880]  Просто многократно навешиваем f.
[01:08:49.880 --> 01:08:50.880]  Вот.
[01:08:50.880 --> 01:08:52.880]  Значит, вот это всё.
[01:08:52.880 --> 01:08:53.880]  Мы навешиваем f.
[01:08:55.880 --> 01:08:56.880]  Вот.
[01:08:56.880 --> 01:09:03.880]  Значит, если бы мы жили в мире, где f, значение f реально случайное,
[01:09:03.880 --> 01:09:07.880]  то скажите, пожалуйста, через сколько шагов мы бы зациклились?
[01:09:08.880 --> 01:09:11.880]  Когда у нас в этой последовательности начинается повторение?
[01:09:13.880 --> 01:09:15.880]  Можно гораздо лучше сказать.
[01:09:16.880 --> 01:09:20.880]  Вот если f случайное, вот представьте себе, что f не такая конкретно детерминированная,
[01:09:20.880 --> 01:09:24.880]  а вот у вас было это случайное число, вы к нему применили случайную функцию,
[01:09:24.880 --> 01:09:26.880]  то есть по факту взяли ещё одно случайное число,
[01:09:26.880 --> 01:09:28.880]  потом ещё раз случайное число, ещё раз случайное число и так далее.
[01:09:28.880 --> 01:09:31.880]  Вот когда вы впервые зациклитесь, когда у вас впервые будет повтор?
[01:09:33.880 --> 01:09:34.880]  Ещё меньше.
[01:09:38.880 --> 01:09:40.880]  Да, примерно в корне, потому что есть парадокс день рождения,
[01:09:40.880 --> 01:09:43.880]  что если вы сгенерируете n случайных…
[01:09:43.880 --> 01:09:47.880]  примерно корень из n случайных величин из отрезка от 1 до n,
[01:09:47.880 --> 01:09:49.880]  то с реальностью близко к единице у вас будет повтор.
[01:09:50.880 --> 01:09:51.880]  Да.
[01:09:52.880 --> 01:09:54.880]  Значит, парадокс день рождения
[01:10:01.880 --> 01:10:05.880]  говорит вам, что если бы f была по-настоящему случайной,
[01:10:05.880 --> 01:10:08.880]  то в среднем через корень из n шагов у вас было бы зацикливание.
[01:10:08.880 --> 01:10:12.880]  Через примерно корень из n шагов
[01:10:15.880 --> 01:10:17.880]  последовательность зациклится.
[01:10:20.880 --> 01:10:22.880]  Значит, зацикливание можно изобразить так.
[01:10:23.880 --> 01:10:26.880]  Вот у вас было какое-то x0, вы посчитали от него x1,
[01:10:26.880 --> 01:10:28.880]  то есть применили функцию f, от него x2,
[01:10:29.880 --> 01:10:32.880]  давайте картинку перерисую, x0, x1,
[01:10:32.880 --> 01:10:34.880]  x2, ну и так далее, короче, считали, считали,
[01:10:34.880 --> 01:10:37.880]  и когда-то вернулись туда, где уже были.
[01:10:37.880 --> 01:10:40.880]  Не обязательно в x0, ну короче, вот зациклились в какой-то момент,
[01:10:40.880 --> 01:10:42.880]  попали туда, где уже были.
[01:10:42.880 --> 01:10:44.880]  У нас получается такая фигурка,
[01:10:44.880 --> 01:10:47.880]  которая похожа на греческую букву «рор»,
[01:10:47.880 --> 01:10:50.880]  и поэтому алгоритм, который здесь мы будем использовать,
[01:10:50.880 --> 01:10:52.880]  называется «рор алгоритм Поларда».
[01:10:52.880 --> 01:10:54.880]  Ну, типа того, да, по образованию бабочки, да,
[01:10:54.880 --> 01:10:57.880]  очень похож на букву «рор», с кубочками нет, но неважно.
[01:11:02.880 --> 01:11:04.880]  Сейчас все будет, не торопитесь.
[01:11:04.880 --> 01:11:07.880]  Значит, вот мы понимаем, что если бы f была реально случайной,
[01:11:07.880 --> 01:11:10.880]  то у нас будет фигурка, которая похожа на букву «рор»,
[01:11:10.880 --> 01:11:13.880]  и поэтому алгоритм, который здесь мы будем использовать,
[01:11:13.880 --> 01:11:15.880]  называется «рор алгоритм Поларда».
[01:11:16.880 --> 01:11:18.880]  Сейчас все будет, не торопитесь.
[01:11:18.880 --> 01:11:21.880]  Значит, вот мы понимаем, что если бы f была реально случайной,
[01:11:21.880 --> 01:11:24.880]  то мы бы примерно через корень zhen шагов зациклились.
[01:11:24.880 --> 01:11:27.880]  Вот, ну и более того, как бы как-то так на практике получается,
[01:11:27.880 --> 01:11:30.880]  что даже если f не случайная, вот такая конкретная,
[01:11:30.880 --> 01:11:33.880]  то через корень zhen тоже на все будет получаться.
[01:11:33.880 --> 01:11:36.880]  Если что, мы всегда можем сгенерить случайное новое x0
[01:11:36.880 --> 01:11:38.880]  и заново пойти, если надо, да,
[01:11:38.880 --> 01:11:41.880]  и тогда, там, рано или поздно, скорее всего, это сработает,
[01:11:41.880 --> 01:11:43.880]  и мы зациклимся.
[01:11:46.880 --> 01:11:48.880]  Вот. Хорошо.
[01:11:48.880 --> 01:11:51.880]  Значит, более того, смотрите, если это составное,
[01:11:51.880 --> 01:11:55.880]  то, ну, давайте я напишу, что n это какой-нибудь pq.
[01:11:56.880 --> 01:11:59.880]  Давайте я из n выделю его минимальный простой делитель.
[01:12:02.880 --> 01:12:04.880]  Минимальный простой делитель.
[01:12:07.880 --> 01:12:09.880]  Вот.
[01:12:10.880 --> 01:12:12.880]  Ну, давайте p на...
[01:12:12.880 --> 01:12:14.880]  Продон, да.
[01:12:14.880 --> 01:12:16.880]  А пофиг, p на q, пофиг.
[01:12:16.880 --> 01:12:18.880]  Вот.
[01:12:19.880 --> 01:12:21.880]  Значит, я выделю минимальный простой делитель zhen.
[01:12:21.880 --> 01:12:24.880]  Тогда, если я рассматривал бы эту последовательность
[01:12:24.880 --> 01:12:26.880]  не как последовательность zten,
[01:12:26.880 --> 01:12:28.880]  а как последовательность zp,
[01:12:28.880 --> 01:12:30.880]  она бы еще быстрее зациклилась,
[01:12:30.880 --> 01:12:32.880]  потому что здесь был корень zhen,
[01:12:32.880 --> 01:12:34.880]  а здесь будет корень sp.
[01:12:34.880 --> 01:12:36.880]  То есть, если я все это теперь погружу в zp
[01:12:36.880 --> 01:12:38.880]  и рассматривал бы все это zp,
[01:12:38.880 --> 01:12:40.880]  тогда бы она у меня еще быстрее зациклилась,
[01:12:40.880 --> 01:12:42.880]  ну, примерно за корень sp действий.
[01:12:42.880 --> 01:12:44.880]  Значит, здесь тогда длина вот этого цикла
[01:12:44.880 --> 01:12:46.880]  была бы примерно корень sp.
[01:12:50.880 --> 01:12:52.880]  Вот.
[01:12:52.880 --> 01:12:54.880]  Ну а p это что такое? p это не больше, чем корень zhen.
[01:12:56.880 --> 01:12:58.880]  Да, минимальный простой делитель составного числа
[01:12:58.880 --> 01:13:00.880]  не больше, чем корень из него.
[01:13:00.880 --> 01:13:02.880]  Значит, у нас длина вот этого цикла
[01:13:02.880 --> 01:13:04.880]  на время, когда мы впервые зациклимся,
[01:13:04.880 --> 01:13:06.880]  будет примерно корень четвертой степени zhen.
[01:13:06.880 --> 01:13:08.880]  Вот.
[01:13:08.880 --> 01:13:10.880]  И такая симптомика у нас у алгоритма и будет.
[01:13:12.880 --> 01:13:14.880]  Ну, еще раз,
[01:13:14.880 --> 01:13:16.880]  если бы мы рассматривали вот эту вот рожку
[01:13:16.880 --> 01:13:18.880]  не в zn, а в zp,
[01:13:18.880 --> 01:13:20.880]  она бы зациклилась еще раньше,
[01:13:20.880 --> 01:13:22.880]  она бы зациклилась через столько действий,
[01:13:22.880 --> 01:13:24.880]  через вот корень sp.
[01:13:24.880 --> 01:13:26.880]  Поскольку p это наименьший простой делитель,
[01:13:26.880 --> 01:13:28.880]  значит, он не больше, чем корень,
[01:13:28.880 --> 01:13:30.880]  значит, это корень четвертой степени.
[01:13:32.880 --> 01:13:34.880]  Вот. Но при этом p мы
[01:13:34.880 --> 01:13:36.880]  саму по себе не знаем, к сожалению.
[01:13:42.880 --> 01:13:44.880]  Наша цель — его найти.
[01:13:48.880 --> 01:13:50.880]  Сейчас, погодите, сейчас будет.
[01:13:50.880 --> 01:13:52.880]  Значит, смотрите.
[01:13:52.880 --> 01:13:54.880]  Что я хочу?
[01:13:54.880 --> 01:13:56.880]  Вот давайте
[01:13:58.880 --> 01:14:00.880]  скажем, что по модулю p,
[01:14:00.880 --> 01:14:02.880]  то есть в zp, у нас происходит зацикливание.
[01:14:02.880 --> 01:14:04.880]  Что это значит?
[01:14:04.880 --> 01:14:06.880]  Значит, что какие-то два числа, два элемента последовательности,
[01:14:06.880 --> 01:14:08.880]  скажем, x it
[01:14:08.880 --> 01:14:10.880]  и x jt,
[01:14:10.880 --> 01:14:12.880]  они попали в одну и ту же точку в zp,
[01:14:12.880 --> 01:14:14.880]  то есть они сравнимы по модулю p.
[01:14:16.880 --> 01:14:18.880]  Это как раз значит зацикливание.
[01:14:20.880 --> 01:14:22.880]  Вот. Более того,
[01:14:22.880 --> 01:14:24.880]  можно надеяться,
[01:14:24.880 --> 01:14:26.880]  что они не сравнимы
[01:14:26.880 --> 01:14:28.880]  по модулю n.
[01:14:32.880 --> 01:14:34.880]  Ну, потому что p
[01:14:34.880 --> 01:14:36.880]  все-таки число довольно маленькое,
[01:14:36.880 --> 01:14:38.880]  корневое по n.
[01:14:40.880 --> 01:14:42.880]  Если они совпали по модулю p,
[01:14:42.880 --> 01:14:44.880]  это еще не значит, что они совпали по модулю n.
[01:14:44.880 --> 01:14:46.880]  Здесь
[01:14:46.880 --> 01:14:48.880]  тут все довольно такое эмпирическое,
[01:14:48.880 --> 01:14:50.880]  тут мало что доказывается.
[01:14:50.880 --> 01:14:52.880]  То есть вот просто представьте себе, что мы
[01:14:52.880 --> 01:14:54.880]  вот в нашей последовательности x,
[01:14:54.880 --> 01:14:56.880]  мы считали, считали, считали, в какой-то момент
[01:14:56.880 --> 01:14:58.880]  представьте, что мы зациклились по p, но не зациклились по n.
[01:14:58.880 --> 01:15:00.880]  Вот пусть у меня есть такая пара x it и x jt.
[01:15:02.880 --> 01:15:04.880]  Тогда я утверждаю, что отсюда можно легко извлечь
[01:15:04.880 --> 01:15:06.880]  хотя бы какой-то делитель n,
[01:15:06.880 --> 01:15:08.880]  не тривиальный.
[01:15:10.880 --> 01:15:12.880]  Можете ли вы
[01:15:12.880 --> 01:15:14.880]  что-нибудь придумать?
[01:15:14.880 --> 01:15:16.880]  Вот представьте, есть два числа сравнимы по модулю p,
[01:15:16.880 --> 01:15:18.880]  где p это делитель n,
[01:15:18.880 --> 01:15:20.880]  но не сравнимы по модулю n.
[01:15:20.880 --> 01:15:22.880]  Можно ли как-нибудь из них извлечь,
[01:15:22.880 --> 01:15:24.880]  с их помощью найти какой-нибудь делитель n?
[01:15:26.880 --> 01:15:28.880]  Ну да, давайте напишем разность.
[01:15:28.880 --> 01:15:30.880]  Давайте пусть скажем, не знаю,
[01:15:30.880 --> 01:15:32.880]  а это x it и – jt.
[01:15:32.880 --> 01:15:34.880]  То есть мы знаем, что это делится на p,
[01:15:36.880 --> 01:15:38.880]  разность делится на p, но
[01:15:38.880 --> 01:15:40.880]  не делится на n, то есть иными словами
[01:15:40.880 --> 01:15:42.880]  а это какое-то число от 1 до n-1.
[01:15:42.880 --> 01:15:44.880]  Можно считать.
[01:15:44.880 --> 01:15:46.880]  При этом а делится на p.
[01:15:46.880 --> 01:15:48.880]  Как бы тогда это p извлечь?
[01:15:52.880 --> 01:15:54.880]  Сложить чего?
[01:15:56.880 --> 01:15:58.880]  Мы тогда получим n.
[01:16:00.880 --> 01:16:02.880]  А, нет.
[01:16:02.880 --> 01:16:04.880]  Ну непонятно сколько,
[01:16:04.880 --> 01:16:06.880]  не понятно сколько раз складывать.
[01:16:08.880 --> 01:16:10.880]  Да, значит
[01:16:10.880 --> 01:16:12.880]  вот есть число кратное p, лежащее в таком диапазоне,
[01:16:12.880 --> 01:16:14.880]  как найти p, грубо говоря.
[01:16:20.880 --> 01:16:22.880]  Давайте просто найдем наибольший
[01:16:22.880 --> 01:16:24.880]  общий делитель a и n.
[01:16:26.880 --> 01:16:28.880]  Это будет не тривиальный делитель n.
[01:16:28.880 --> 01:16:30.880]  Да, потому что
[01:16:30.880 --> 01:16:32.880]  у нас есть какое-то число кратное p,
[01:16:32.880 --> 01:16:34.880]  и n тоже делится на p,
[01:16:34.880 --> 01:16:36.880]  поэтому, по крайней мере, это gcd будет
[01:16:36.880 --> 01:16:38.880]  на p делиться. Но, поскольку
[01:16:38.880 --> 01:16:40.880]  а – это маленькое число, а это разность каких-то двух
[01:16:40.880 --> 01:16:42.880]  остатков, значит эта штука будет
[01:16:42.880 --> 01:16:44.880]  меньше, чем n. То есть эта штука хотя бы p, но
[01:16:44.880 --> 01:16:46.880]  меньше n, значит это не тривиальный делитель.
[01:16:46.880 --> 01:16:48.880]  Не тривиальный делитель.
[01:16:50.880 --> 01:16:52.880]  Причем gcd мы умеем реализовывать
[01:16:52.880 --> 01:16:54.880]  быстро, открытыми в кляда.
[01:16:54.880 --> 01:16:56.880]  Да?
[01:16:56.880 --> 01:16:58.880]  Ну, типа того, да.
[01:17:00.880 --> 01:17:02.880]  Не обязательно.
[01:17:02.880 --> 01:17:04.880]  Не обязательно. Ну, типа если
[01:17:04.880 --> 01:17:06.880]  n – это p на q на r,
[01:17:06.880 --> 01:17:08.880]  то, может быть, там, может быть, ну, короче,
[01:17:08.880 --> 01:17:10.880]  не важно. Это какой-то делитель. Не обязательно.
[01:17:10.880 --> 01:17:12.880]  Ну вот, значит, наша цель
[01:17:12.880 --> 01:17:14.880]  теперь дождаться
[01:17:14.880 --> 01:17:16.880]  такого момента, что вот эта вот
[01:17:16.880 --> 01:17:18.880]  перестановка зазыкливалась в zp, но еще не зазыкливалась
[01:17:18.880 --> 01:17:20.880]  в zn.
[01:17:20.880 --> 01:17:22.880]  Значит, как я это буду делать? Смотрите.
[01:17:22.880 --> 01:17:24.880]  Да, и причем как бы я
[01:17:24.880 --> 01:17:26.880]  не знаю длину цикла, я не знаю p, то есть я
[01:17:26.880 --> 01:17:28.880]  не знаю длину вот этого цикла в zp, я не знаю p,
[01:17:28.880 --> 01:17:30.880]  вообще ничего не знаю. Мне просто хотелось бы
[01:17:30.880 --> 01:17:32.880]  найти такие два элемента
[01:17:32.880 --> 01:17:34.880]  последовательности, чтобы
[01:17:34.880 --> 01:17:36.880]  их разность
[01:17:38.880 --> 01:17:40.880]  дала бы мне какой-то нейтральный делитель
[01:17:40.880 --> 01:17:42.880]  n с помощью gcd.
[01:17:46.880 --> 01:17:48.880]  Ну, тем не менее, я знаю, что как-то они так зазыкливаются.
[01:17:48.880 --> 01:17:50.880]  Давайте вот что сделаем.
[01:17:50.880 --> 01:17:52.880]  Давайте поставим...
[01:17:52.880 --> 01:17:54.880]  Значит, это на самом деле похоже
[01:17:54.880 --> 01:17:56.880]  на задачу о нахождении цикла
[01:17:56.880 --> 01:17:58.880]  в односвязанном списке.
[01:17:58.880 --> 01:18:00.880]  В каком-то смысле у нас вот эти вот переходы
[01:18:00.880 --> 01:18:02.880]  это односвязанный список. Каждая вишина говорит
[01:18:02.880 --> 01:18:04.880]  какая следующая. Каждый вычет говорит
[01:18:04.880 --> 01:18:06.880]  какой следующий. Так вот,
[01:18:06.880 --> 01:18:08.880]  моя цель... А?
[01:18:08.880 --> 01:18:10.880]  Нет. Моя цель...
[01:18:10.880 --> 01:18:12.880]  Слишком много памяти будет.
[01:18:12.880 --> 01:18:14.880]  Значит, моя цель найти вот эту точку.
[01:18:16.880 --> 01:18:18.880]  Ну, точнее не так. Моя цель
[01:18:18.880 --> 01:18:20.880]  на самом деле найти такие
[01:18:20.880 --> 01:18:22.880]  просто два индекса x и xg, разные
[01:18:22.880 --> 01:18:24.880]  два индекса, что они попали в одну и ту же точку
[01:18:24.880 --> 01:18:26.880]  в zp.
[01:18:26.880 --> 01:18:28.880]  Давайте я сделаю следующее. Давайте я поставлю
[01:18:28.880 --> 01:18:30.880]  сюда черепашку,
[01:18:32.880 --> 01:18:34.880]  а сюда зайчика.
[01:18:36.880 --> 01:18:38.880]  И на каждом шаге
[01:18:38.880 --> 01:18:40.880]  черепашка будет идти на один шаг вперед, а зайчик
[01:18:40.880 --> 01:18:42.880]  на два шага вперед.
[01:18:48.880 --> 01:18:50.880]  Ну, и так буду делать.
[01:18:52.880 --> 01:18:54.880]  Зайчик на один шаг...
[01:18:54.880 --> 01:18:56.880]  Сейчас.
[01:18:56.880 --> 01:18:58.880]  Ну, не важно, на самом деле.
[01:18:58.880 --> 01:19:00.880]  Давайте их в одно место поставлю для улупства.
[01:19:02.880 --> 01:19:04.880]  Давайте в одно. Наверное, так лучше.
[01:19:04.880 --> 01:19:06.880]  Просто зайчик
[01:19:06.880 --> 01:19:08.880]  на два шага каждый раз будет прыгать.
[01:19:08.880 --> 01:19:10.880]  И первое из совпадений не считаем до
[01:19:10.880 --> 01:19:12.880]  совпадения.
[01:19:12.880 --> 01:19:14.880]  Блин.
[01:19:14.880 --> 01:19:16.880]  Значит, тогда я утверждаю,
[01:19:16.880 --> 01:19:18.880]  что в какой-то момент,
[01:19:18.880 --> 01:19:20.880]  короче, пока черепашка дойдет
[01:19:20.880 --> 01:19:22.880]  вот до сюда, зайчик уже будет где-то вот здесь.
[01:19:22.880 --> 01:19:24.880]  И потом зайчик будет догонять
[01:19:24.880 --> 01:19:26.880]  черепашку. И поскольку черепашка движется
[01:19:26.880 --> 01:19:28.880]  со скоростью один, рано или поздно
[01:19:28.880 --> 01:19:30.880]  они встретятся в одну и ту же точку.
[01:19:30.880 --> 01:19:32.880]  Вот здесь будет черепашка, а зайчик пройдет еще на один цикл
[01:19:32.880 --> 01:19:34.880]  больше и окажется в той же позиции.
[01:19:34.880 --> 01:19:36.880]  Получится, что мы найдем
[01:19:36.880 --> 01:19:38.880]  два элемента последовательности, как раз
[01:19:38.880 --> 01:19:40.880]  x и xg, которые
[01:19:40.880 --> 01:19:42.880]  попали в одну и ту же точку в zp.
[01:19:42.880 --> 01:19:44.880]  То есть, ну, как раз
[01:19:44.880 --> 01:19:46.880]  у нас будет верно вот это вот.
[01:19:46.880 --> 01:19:48.880]  Но мы с хорошей вероятностью надеемся,
[01:19:48.880 --> 01:19:50.880]  что они различны по модулю n.
[01:19:50.880 --> 01:19:52.880]  Вот.
[01:19:52.880 --> 01:19:54.880]  Получается алгоритм такой. Мы просто
[01:19:54.880 --> 01:19:56.880]  поставили сюда два
[01:19:56.880 --> 01:19:58.880]  итератора, которые двигаются с разными скоростями.
[01:19:58.880 --> 01:20:00.880]  Один движется на один шаг
[01:20:00.880 --> 01:20:02.880]  за такт, другой на два шага
[01:20:02.880 --> 01:20:04.880]  за такт. И каждый раз у нас
[01:20:04.880 --> 01:20:06.880]  есть, получается, две перемены. Давайте скажем, что там
[01:20:06.880 --> 01:20:08.880]  черепашка это t, зайчик
[01:20:08.880 --> 01:20:10.880]  это h. Каждый раз t двигается на
[01:20:10.880 --> 01:20:12.880]  1, h движется на 2.
[01:20:12.880 --> 01:20:14.880]  И каждый момент времени мы просто смотрим
[01:20:14.880 --> 01:20:16.880]  на t-h, считаем
[01:20:16.880 --> 01:20:18.880]  gcd с n
[01:20:18.880 --> 01:20:20.880]  и дожидаемся, когда это будет не
[01:20:20.880 --> 01:20:22.880]  единица. Короче, когда
[01:20:22.880 --> 01:20:24.880]  найдем какой-то делитер. Вот.
[01:20:24.880 --> 01:20:26.880]  Итак, рано или поздно, когда
[01:20:26.880 --> 01:20:28.880]  и черепашка, и зайчик, во-первых, дойдут до цикла,
[01:20:28.880 --> 01:20:30.880]  потом зайчик догонит черепашку,
[01:20:30.880 --> 01:20:32.880]  поскольку он в два раза быстрее ходит.
[01:20:32.880 --> 01:20:34.880]  И здесь рано или поздно как раз будут
[01:20:34.880 --> 01:20:36.880]  такие два числа. То есть, t и h будут
[01:20:36.880 --> 01:20:38.880]  одинаковы по модулю p,
[01:20:38.880 --> 01:20:40.880]  но разные по модулю n, и это даст какой-то
[01:20:40.880 --> 01:20:42.880]  н. Все.
[01:20:42.880 --> 01:20:44.880]  Значит,
[01:20:44.880 --> 01:20:46.880]  ожидается, что это все
[01:20:46.880 --> 01:20:48.880]  будет работать примерно за вот столько вот
[01:20:48.880 --> 01:20:50.880]  тактов.
[01:20:50.880 --> 01:20:52.880]  Ну, потому что мы знаем, что длина этого цикла
[01:20:52.880 --> 01:20:54.880]  максимум корень четвертой степени,
[01:20:54.880 --> 01:20:56.880]  то есть вообще длина всего этого графика
[01:20:56.880 --> 01:20:58.880]  корень четвертой степени z, значит
[01:20:58.880 --> 01:21:00.880]  впервые они зациклются там примерно через столько
[01:21:00.880 --> 01:21:02.880]  итераций, и мы найдем
[01:21:02.880 --> 01:21:04.880]  здесь интервьюальный делитель.
[01:21:04.880 --> 01:21:06.880]  Еще раз?
[01:21:06.880 --> 01:21:08.880]  Откуда p взяли?
[01:21:08.880 --> 01:21:10.880]  Ну, мы не взяли, мы знаем, что она есть.
[01:21:10.880 --> 01:21:12.880]  То есть, еще раз, мы на самом деле
[01:21:12.880 --> 01:21:14.880]  p, вот когда у меня
[01:21:14.880 --> 01:21:16.880]  черепашка и зайчик ходит, они не знают p.
[01:21:16.880 --> 01:21:18.880]  Они просто ходят с разными скоростями.
[01:21:18.880 --> 01:21:20.880]  1 и 2. И каждый раз
[01:21:20.880 --> 01:21:22.880]  там, когда они ставят в каких-то
[01:21:22.880 --> 01:21:24.880]  двух точках, скажем, здесь t, здесь h,
[01:21:24.880 --> 01:21:26.880]  я просто беру их разность и считаю
[01:21:26.880 --> 01:21:28.880]  gcd с n.
[01:21:28.880 --> 01:21:30.880]  Да,
[01:21:30.880 --> 01:21:32.880]  хождение в ztn у меня. У меня все
[01:21:32.880 --> 01:21:34.880]  в ztn, просто
[01:21:34.880 --> 01:21:36.880]  я каждый раз беру gcd разности с n.
[01:21:36.880 --> 01:21:38.880]  И поскольку
[01:21:38.880 --> 01:21:40.880]  если бы я рассматривал в ztp, я бы скоро
[01:21:40.880 --> 01:21:42.880]  зациклился, я бы зациклился через столько действий.
[01:21:42.880 --> 01:21:44.880]  Значит, мне достаточно сделать примерно столько
[01:21:44.880 --> 01:21:46.880]  действий, чтобы найти
[01:21:46.880 --> 01:21:48.880]  в качестве вот этой вот разности
[01:21:48.880 --> 01:21:50.880]  какой-то делитель интервьюальный.
[01:21:50.880 --> 01:21:52.880]  То есть, мы сначала сделали действие, а потом gcd?
[01:21:52.880 --> 01:21:54.880]  Да, у нас перешли зайчик
[01:21:54.880 --> 01:21:56.880]  и черепашка взяли gcd, перешли gcd, перешли
[01:21:56.880 --> 01:21:58.880]  и так на каждом шаге берем gcd.
[01:21:58.880 --> 01:22:00.880]  Да, здесь ничего не доказано,
[01:22:00.880 --> 01:22:02.880]  это ирвистический алгоритм, который хорошо
[01:22:02.880 --> 01:22:04.880]  работает на практике, но
[01:22:04.880 --> 01:22:06.880]  про него не доказано ничего, да.
[01:22:06.880 --> 01:22:08.880]  Это правда.
[01:22:08.880 --> 01:22:10.880]  Мы всегда можем сгенерировать новое случайно
[01:22:10.880 --> 01:22:12.880]  x0 и запустить
[01:22:12.880 --> 01:22:14.880]  заново эту процедуру.
[01:22:14.880 --> 01:22:16.880]  Все, спасибо за внимание.
