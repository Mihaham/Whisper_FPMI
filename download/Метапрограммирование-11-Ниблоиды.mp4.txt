[00:00.000 --> 00:11.640]  Вот такая лекция будет сегодня про не особо связанные вещи, но вот первая из них нам нужна
[00:11.640 --> 00:17.600]  к лекции, которая будет через два раза, а вторая из них это просто традиционная тема,
[00:17.600 --> 00:23.520]  которая там современно Александреску тащится, она прикольная и даже на практике немного полезная,
[00:23.520 --> 00:31.720]  только не в том виде, в котором, конечно, ее Александреску показывал. А вы же Тюпл писали,
[00:31.720 --> 00:39.040]  да? Тогда будет много дежавю сегодня, ну вот во второй части, ну или развитие идеи Тюпла.
[00:39.040 --> 00:45.760]  Отлично, если люди, которые не писали, будем развлекаться, но сначала нам надо поговорить про
[00:45.760 --> 00:57.200]  Неблоиды. Вот Неблоиды это про убийство АДЛ, ну непонятно пока, о чем речь, вот у нас был АДЛ,
[00:57.200 --> 01:05.560]  не-не-не-не, не надо гадать, затравочка, чтобы привлечь внимание. АДЛ, у нас был АДЛ, что такое АДЛ?
[01:05.560 --> 01:25.440]  Каких? Что ищем в каких namespace? Ну расшифруйте это кто-нибудь. Да, типа того.
[01:25.440 --> 01:36.240]  Да, не только, если ничего не получилось, но в принципе, что когда функцию вызываете,
[01:36.240 --> 01:42.120]  причем вызываете неквалифицированно, то есть просто фу, без двух двоеточий,
[01:42.120 --> 01:54.160]  без указания namespace, он квалифает лукап. Вы идете, помимо обычного лукапа, еще и во все namespace,
[01:54.160 --> 02:05.200]  которые хоть как-то относятся к типу аргументов. Ну как бы да, но это интуитивно понятно. Тот namespace,
[02:05.200 --> 02:11.520]  в котором лежит этот тип, все namespace, которые в типах аргументов шаблону помянут, и родительских
[02:11.520 --> 02:20.240]  типах, ну вообще все, короче. Андрей, как умное слово, ассоциированный, вот, ассоциированный
[02:20.240 --> 02:27.800]  namespace это называется. Мы там что-то посмотрели, ну сейчас еще посмотрим. Вот, и ну техника, зачем это
[02:27.800 --> 02:34.080]  в принципе как бы нужно изначально, ну окей, изначально это нужно было, чтобы hello world работал,
[02:34.080 --> 02:40.600]  да, это помним. Вы пишете cout, стрелка, стрелка, hello world, откуда находится оператор стрелка,
[02:40.600 --> 02:46.280]  стрелка, стрелка в namespace std из EDL. Потом внезапно обнаружили, что с помощью этого можно
[02:46.280 --> 02:53.840]  кастомизировать всякие функции типа swap, да. Вот идея какая, мы берем и перестаем звать просто
[02:53.840 --> 03:04.200]  std swap, мы делаем using там, std, да, давайте по порядку. Если вот так делаем, то у нас вот тут как бы
[03:04.200 --> 03:09.400]  кастомный какой-то swap есть для нашего типа статический, и он типа более эффективный, чем два
[03:09.400 --> 03:16.080]  move, ну как-то там сделали. Вот так вот вызывая, мы просто дефолтную реализацию дернем, вместо
[03:16.080 --> 03:21.560]  кастомной неприятно, хорошо бы уметь кастомную именно вызывать, поэтому предлагается такая схема.
[03:21.560 --> 03:27.800]  Вместо того, чтобы это статический метод был, да, он будет random, причем не friend declaration,
[03:27.800 --> 03:34.920]  а friend definition. Это вот делает, определяет новую функцию в как бы родительском namespace для
[03:34.920 --> 03:41.720]  этой структуры, но находится эта функция только через ADL, и когда вы делаете вот так, у вас либо
[03:41.720 --> 03:48.320]  через ADL найдется такая штука и вызовется, либо стандартный swap будет использован, если ADL ничего
[03:48.320 --> 03:55.200]  не нашел. Вот такая технология была. Вспомнили, вспомнили. Если что-то непонятно, пропустили,
[03:55.200 --> 04:00.000]  прослушали, переспросите, что дальше все будет бессмысленно, если вы не поняли вот эту технику.
[04:00.000 --> 04:12.760]  Там такой порядок при выборе перегрузки, такой порядок. Там надо, конечно, стандарт открыть и
[04:12.760 --> 04:18.200]  прочитать. Я наизусть это, даже если в какой-то момент запоминаю, потом быстро забываю, но вот как
[04:18.200 --> 04:24.800]  факт, когда вы пишете такую конструкцию, у вас приоритет берет то, что находит ADL. ADL никогда
[04:24.800 --> 04:30.080]  ничего не находится, делается, а там с хитрыми приоритетами. Мы можем, наверное, так и сказать, что мы
[04:30.080 --> 04:36.920]  делаем юзиную декларацию для cd swap, мы, грубо говоря, его помещаем в namespace, в котором мы
[04:36.920 --> 04:44.240]  написали эту юзиную декларацию, а class это более вложенный scope, поэтому он идет первым по порядку.
[04:44.240 --> 04:52.720]  То есть, когда мы пишем friend, мы смотрим на friend функцию, как на member функцию, при его капе,
[04:52.720 --> 05:02.800]  и поэтому... Ну это... Не-не-не, вот это не member функция. Да, ну, мне кажется, это бесполезно пытаться
[05:02.800 --> 05:08.040]  вот какую-то такую интуицию набросать. Нет, она буквально там в стандарте написана, что friend
[05:08.040 --> 05:15.920]  declare functions. А, ну, если ты прям помнишь, что так написано, то окей, да, что там у нас member функции
[05:15.920 --> 05:22.080]  какой-то приоритет берут. Ну, в общем и целом, вот это тупо надо запомнить, что вот так работает.
[05:22.640 --> 05:26.220]  Когда вы делаете так, вызовется кастомизация.
[05:34.220 --> 05:37.920]  Область видимости структура в отдельный namespace. Нет, как бы...
[05:37.920 --> 05:42.420]  Область видимости это четкое понятие в языке. Любой namespace это область видимости,
[05:42.420 --> 05:46.420]  и любая структура область видимости.
[05:46.420 --> 05:50.560]  Да, структура, она так и так область видимости.
[05:50.560 --> 05:53.800]  ты в структуре можешь статическую функцию, как на прошлом слайде, определить,
[05:54.800 --> 05:58.800]  ее можно позвать, ну как, только foo2.swap, да?
[06:00.060 --> 06:02.300]  То есть вот структура, она так и так.
[06:03.800 --> 06:10.560]  А тут формально, когда мы говорим friend и пишем определение функции прямо в классе,
[06:10.560 --> 06:16.060]  не объявление, если бы там фигурных скобок не было, это было бы объявление,
[06:16.060 --> 06:19.300]  и тогда мы говорим, где-то там есть какая-то другая функция swap,
[06:19.540 --> 06:21.540]  которую мы говорим, что она нам friend.
[06:21.540 --> 06:24.040]  Ну, ее там пойдет искать компилятор, где она есть.
[06:24.040 --> 06:26.040]  Если не найдется, то будет ошибка.
[06:26.040 --> 06:28.540]  А здесь мы говорим, мы создаем новую функцию.
[06:28.540 --> 06:30.540]  В какой области видимости?
[06:30.540 --> 06:35.540]  Ну, на самом деле в родительской области видимости по отношению к этой структуре,
[06:35.540 --> 06:39.540]  но по факту, если вы попытаетесь вызвать полностью квалифицированный вот этот swap,
[06:39.540 --> 06:40.540]  ничего не выйдет.
[06:40.540 --> 06:42.540]  Прям в стандарте так захардкожено.
[06:42.540 --> 06:45.040]  Его можно вызвать только через ADL.
[06:45.040 --> 06:48.040]  То есть вот такая конструкция, она специально сделана для ADL,
[06:48.040 --> 06:49.540]  и без нее смысла не имеет.
[06:51.540 --> 06:53.540]  То есть вот, механически так происходит,
[06:53.540 --> 06:57.040]  и вот тут, когда так пишем, ADL берет приоритет.
[06:57.040 --> 07:03.040]  А если бы я написал не SDSwap, а, не знаю, какой-нибудь namespace,
[07:03.040 --> 07:07.040]  был бы уже вот peterswap, это сработало бы?
[07:07.040 --> 07:09.040]  Про что я речь?
[07:09.040 --> 07:11.040]  Недостатки этого подхода,
[07:11.040 --> 07:13.540]  оно вообще никак не работает с namespaces.
[07:14.040 --> 07:19.040]  То есть мы не можем сделать какую-нибудь другую функцию
[07:19.040 --> 07:23.040]  с названием swap, которая что-нибудь другое делает.
[07:23.040 --> 07:26.040]  Ну, вдруг в нашей предметной области слово swap,
[07:26.040 --> 07:28.040]  оно имеет какое-то специфичное значение,
[07:28.040 --> 07:32.040]  и мы хотим использовать это слово с этим значением.
[07:32.040 --> 07:33.040]  Не можем.
[07:33.040 --> 07:37.040]  Для чего swap, он как бы вот этот вот кастомизируемый вызов,
[07:37.040 --> 07:39.040]  он зарезервирован глобально.
[07:39.540 --> 07:43.540]  То есть нигде вы никогда уже не можете swap использовать
[07:43.540 --> 07:45.540]  для своих каких-то целей как функцию,
[07:45.540 --> 07:48.540]  иначе будете ловить всякие конфликты и проблемы.
[07:48.540 --> 07:51.540]  Это плохо, потому что мы на уровне библиотеки
[07:51.540 --> 07:54.540]  вносим как будто бы новые ключевые слова.
[07:54.540 --> 07:56.540]  То есть берем и резервируем ключевые слова,
[07:56.540 --> 07:58.540]  не меняя язык, это странно.
[08:00.540 --> 08:02.540]  Колдунские заклинания.
[08:02.540 --> 08:05.540]  Вот это вот, признайтесь, хоть раз вы писали,
[08:05.540 --> 08:07.540]  или до этого курса видели?
[08:08.040 --> 08:11.040]  Да, мне Мещерин говорил, что не надо их писать.
[08:11.040 --> 08:13.040]  То есть ты так написал, а Мещерин сказал не надо?
[08:13.040 --> 08:14.040]  Да.
[08:14.040 --> 08:17.040]  Ну, я пишу на первый курс, уже слишком...
[08:17.040 --> 08:19.040]  Нет, нет, нет, почему ты так писал?
[08:19.040 --> 08:21.040]  Почему ты так оставался?
[08:21.040 --> 08:23.040]  Ну, я думаю...
[08:23.040 --> 08:24.040]  Слишком темное заклинание.
[08:24.040 --> 08:25.040]  Да, да.
[08:25.040 --> 08:27.040]  Ну, Мещерин прав.
[08:27.040 --> 08:29.040]  Это слишком темное заклинание,
[08:29.040 --> 08:31.040]  и авторам стандарта это тоже было очевидно,
[08:31.040 --> 08:33.040]  что вот так никто код не пишет.
[08:33.040 --> 08:35.040]  Пойдите, найдите хоть где-то в проде вот эти вот заклинания.
[08:35.040 --> 08:37.040]  Да нету их, никто так не делает.
[08:37.540 --> 08:39.540]  Скажите, вы специсты, да?
[08:41.540 --> 08:43.540]  Вроде как не уверен.
[08:43.540 --> 08:44.540]  Не уверен.
[08:44.540 --> 08:45.540]  Попробуй.
[08:45.540 --> 08:47.540]  Ну, вот, собственно, причин для своба стандарта есть
[08:47.540 --> 08:49.540]  кастынь, что его можно специализировать.
[08:49.540 --> 08:51.540]  Был.
[08:51.540 --> 08:53.540]  Ну, давай не будем про это, пожалуйста, Андрей.
[08:53.540 --> 08:55.540]  Ну, потому что именно из-за этого этот кастынь был,
[08:55.540 --> 08:57.540]  потому что интернет пишет как надо.
[08:57.540 --> 08:58.540]  Ну, да.
[08:58.540 --> 09:00.540]  Окей, историческая справка.
[09:00.540 --> 09:02.540]  Вот так вот слишком сложно, поэтому в какой-то момент
[09:02.540 --> 09:04.540]  в C++ можно было писать
[09:04.540 --> 09:06.540]  свою явную специализацию
[09:06.540 --> 09:08.540]  шаблона swap namespace-std.
[09:08.540 --> 09:10.540]  Вы такое делали уже,
[09:10.540 --> 09:12.540]  правда ведь, специализировали
[09:12.540 --> 09:14.540]  шаблоны из namespace-std в своем коде.
[09:14.540 --> 09:16.540]  Какие?
[09:16.540 --> 09:18.540]  Hash.
[09:18.540 --> 09:20.540]  Всем известно, хотите в unordered map
[09:20.540 --> 09:22.540]  положить, специализируйте hash.
[09:22.540 --> 09:24.540]  Ну, со swap, оказывается, так тоже можно было,
[09:24.540 --> 09:26.540]  но, по-моему, уже запретили.
[09:26.540 --> 09:28.540]  Не уверен.
[09:28.540 --> 09:30.540]  По крайней мере, пользоваться этим уже точно
[09:30.540 --> 09:32.540]  не надо, сейчас мы дойдем до конца
[09:32.540 --> 09:34.540]  сегодня и поймем почему.
[09:34.540 --> 09:36.540]  Да,
[09:36.540 --> 09:38.540]  еще есть такой моментик
[09:38.540 --> 09:40.540]  случайная ADL.
[09:40.540 --> 09:42.540]  Вот я тут так рекламирую вам ADL, что круто,
[09:42.540 --> 09:44.540]  кастомизация, ну, там есть какие-то недостатки,
[09:44.540 --> 09:46.540]  но можно же этим пожертвовать, чтобы
[09:46.540 --> 09:48.540]  у нас там
[09:48.540 --> 09:50.540]  зирокост кастомизации
[09:50.540 --> 09:52.540]  без всяких трейтов, без всего
[09:52.540 --> 09:54.540]  магически работать.
[09:54.540 --> 09:56.540]  Ну, вот сейчас будет мотивирующий пример
[09:56.540 --> 09:58.540]  про то, о чем я говорю.
[09:58.540 --> 10:00.540]  Что такое случайная ADL?
[10:00.540 --> 10:02.540]  Знакома ли вам эта функция?
[10:02.540 --> 10:04.540]  Этот шаблон функции?
[10:04.540 --> 10:06.540]  О копе, да,
[10:06.540 --> 10:08.540]  это итальянская версия функции
[10:08.540 --> 10:10.540]  копе или
[10:10.540 --> 10:12.540]  французская? Не уверен.
[10:12.540 --> 10:14.540]  Итальянская, итальянская.
[10:14.540 --> 10:16.540]  Что она делает?
[10:16.540 --> 10:18.540]  Помним?
[10:18.540 --> 10:20.540]  Кто-нибудь?
[10:20.540 --> 10:22.540]  Копируем.
[10:22.540 --> 10:24.540]  Что, куда?
[10:24.540 --> 10:26.540]  Так, все от first
[10:26.540 --> 10:28.540]  to last, где first to last, это вот
[10:28.540 --> 10:30.540]  в какой-то контейнер,
[10:30.540 --> 10:32.540]  а да, оно берет
[10:32.540 --> 10:34.540]  и шагает от first to last,
[10:34.540 --> 10:36.540]  и копирует это все дело
[10:36.540 --> 10:38.540]  в result, где в result
[10:38.540 --> 10:40.540]  уже заранее должна быть память под это выделена,
[10:40.540 --> 10:42.540]  то есть оно просто как бы
[10:42.540 --> 10:44.540]  result разаменовывает, присваивает, двигает вперед,
[10:44.540 --> 10:46.540]  разаменовывает, присваивает, двигает вперед.
[10:46.540 --> 10:48.540]  Что оно возвращает?
[10:48.540 --> 10:50.540]  Да, result после всех
[10:50.540 --> 10:52.540]  присваиваний.
[10:52.540 --> 10:54.540]  Что вам может не нравиться
[10:54.540 --> 10:56.540]  в этой функции?
[10:56.540 --> 10:58.540]  Почему он тебе не нравится?
[10:58.540 --> 11:00.540]  Зачем он возвращает?
[11:00.540 --> 11:02.540]  Посылки нормальные.
[11:02.540 --> 11:04.540]  Почему?
[11:06.540 --> 11:08.540]  Это странно.
[11:08.540 --> 11:10.540]  Кажется, ты получаешь при передаче
[11:10.540 --> 11:12.540]  посылки, мы получаем interaction
[11:12.540 --> 11:14.540]  и на уровне EBI это могут быть проблемы,
[11:14.540 --> 11:16.540]  что ты уже не оптимизируешь.
[11:16.540 --> 11:18.540]  Ну, вообще, про EBI, неоптимальности
[11:18.540 --> 11:20.540]  и итераторы, это совсем отдельный
[11:20.540 --> 11:22.540]  разговор, там все плохо.
[11:22.540 --> 11:24.540]  Вам кажется, что все нормально, вы
[11:24.540 --> 11:26.540]  привыкли передавать итераторы по значению, на самом деле
[11:26.540 --> 11:28.540]  все очень плохо. Ну ладно, это отдельный разговор.
[11:28.540 --> 11:30.540]  Нет, это не проблема,
[11:30.540 --> 11:32.540]  это наоборот очень круто, потому что вы
[11:32.540 --> 11:34.540]  взяли какой-то там вот этот
[11:34.540 --> 11:36.540]  итератор на начало, куда
[11:36.540 --> 11:38.540]  вы копируете, передали вы сюда
[11:38.540 --> 11:40.540]  копий, вам вернули
[11:40.540 --> 11:42.540]  наконец. Вот вы их вычли,
[11:42.540 --> 11:44.540]  изначальный result, который вы передали, и то,
[11:44.540 --> 11:46.540]  что вам вернули, вычли, получили сколько
[11:46.540 --> 11:48.540]  перекопировано было.
[11:48.540 --> 11:50.540]  Тип итератора.
[11:50.540 --> 11:52.540]  Аутпут итератора.
[11:52.540 --> 11:54.540]  Ну да,
[11:54.540 --> 11:56.540]  это аутпут итератора, это инпут,
[11:56.540 --> 11:58.540]  я решил опустить все эти концепты.
[11:58.540 --> 12:00.540]  Почему?
[12:00.540 --> 12:02.540]  Ну, например, я хочу какой-нибудь...
[12:02.540 --> 12:04.540]  Ну, короче,
[12:04.540 --> 12:06.540]  у меня нет понимания,
[12:06.540 --> 12:08.540]  когда файл заканчивается,
[12:08.540 --> 12:10.540]  когда я не смог почитать, а когда заканчивается.
[12:10.540 --> 12:12.540]  Прекрасно.
[12:12.540 --> 12:14.540]  Ну, ты явно знал.
[12:14.540 --> 12:16.540]  Нет, я просто про рендж
[12:16.540 --> 12:18.540]  рассказывал пару лет назад.
[12:18.540 --> 12:20.540]  Это ровно то, что мы хотим.
[12:20.540 --> 12:22.540]  Но только у меня пример более
[12:22.540 --> 12:24.540]  простой, чем файлы.
[12:24.540 --> 12:26.540]  Сестроки.
[12:26.540 --> 12:28.540]  Вот у сестрок есть только указатель на
[12:28.540 --> 12:30.540]  начало. Указатель на конец
[12:30.540 --> 12:32.540]  получить, это линия, это
[12:32.540 --> 12:34.540]  типа долго.
[12:34.540 --> 12:36.540]  Зато, зато у нас есть
[12:36.540 --> 12:38.540]  четкий критерий, понимание, когда мы
[12:38.540 --> 12:40.540]  дошли до конца. Вот этому алгоритму
[12:40.540 --> 12:42.540]  зачем ему вообще
[12:42.540 --> 12:44.540]  итератор на конец?
[12:44.540 --> 12:46.540]  Только сравнивать
[12:46.540 --> 12:48.540]  с текущим ферстом.
[12:48.540 --> 12:50.540]  Единственное, зачем он нужен, это понять, когда мы
[12:50.540 --> 12:52.540]  дошли до конца. В сестроке мы
[12:52.540 --> 12:54.540]  по-другому понимаем, как мы дошли до конца.
[12:54.540 --> 12:56.540]  Поэтому идея. Давайте
[12:56.540 --> 12:58.540]  усовершенствуем стандартную библиотеку.
[12:58.540 --> 13:00.540]  Добавим сюда
[13:00.540 --> 13:02.540]  другого типа last, так, чтобы можно было
[13:02.540 --> 13:04.540]  какое-то волшебное значение
[13:04.540 --> 13:06.540]  подпихнуть, которое можно сравнивать с
[13:06.540 --> 13:08.540]  консчар звездочка.
[13:08.540 --> 13:10.540]  И при сравнении
[13:10.540 --> 13:12.540]  нам бы просто говорили, дошли ли мы до
[13:12.540 --> 13:14.540]  нулевого символа в конце сестроки
[13:14.540 --> 13:16.540]  или нет. Понятная идея.
[13:16.540 --> 13:18.540]  Это вот прям реальная штука из
[13:18.540 --> 13:20.540]  ranges. Такое теперь есть.
[13:20.540 --> 13:22.540]  Да,
[13:22.540 --> 13:24.540]  но тут еще есть проблема. Вы не успели
[13:24.540 --> 13:26.540]  прочитать или успели?
[13:26.540 --> 13:28.540]  Не успели. Хорошо.
[13:28.540 --> 13:30.540]  Да, тут еще есть недослаточек.
[13:30.540 --> 13:32.540]  Ну, про размер сестроки.
[13:32.540 --> 13:34.540]  Очевидно кому-нибудь,
[13:34.540 --> 13:36.540]  что это значит?
[13:36.540 --> 13:38.540]  Что?
[13:38.540 --> 13:40.540]  Размер в смысле байтов
[13:40.540 --> 13:42.540]  или в смысле сестрочных символов?
[13:42.540 --> 13:44.540]  Про кодировки не думаем.
[13:44.540 --> 13:46.540]  Char это char, это символ,
[13:46.540 --> 13:48.540]  это...
[13:50.540 --> 13:52.540]  Ну, неважно.
[13:52.540 --> 13:54.540]  Просто хотели получить размер.
[13:54.540 --> 13:56.540]  Вот когда такая ситуация, у нас разные
[13:56.540 --> 13:58.540]  какие-то значения сюда переданы,
[13:58.540 --> 14:00.540]  вот эта штука с последней, кстати, буквы s,
[14:00.540 --> 14:02.540]  это sentinel.
[14:02.540 --> 14:04.540]  Вы когда какие-нибудь деревья писали
[14:04.540 --> 14:06.540]  или связанные списки, да?
[14:06.540 --> 14:08.540]  А чем еще я не рассказывал про сентинел?
[14:08.540 --> 14:10.540]  Ну,
[14:10.540 --> 14:12.540]  да,
[14:12.540 --> 14:14.540]  ну просто когда связанный список у вас есть,
[14:14.540 --> 14:16.540]  очень часто пустой список
[14:16.540 --> 14:18.540]  представляют не отсутствием нод,
[14:18.540 --> 14:20.540]  а
[14:20.540 --> 14:22.540]  сентинелом, фейковой нодой.
[14:22.540 --> 14:24.540]  И вот это фейковая нода,
[14:24.540 --> 14:26.540]  к ней уже настоящие цепляются,
[14:26.540 --> 14:28.540]  и она всегда пропускается при террировании.
[14:28.540 --> 14:30.540]  Вот просто деталь имплементации.
[14:30.540 --> 14:32.540]  Вот это вот как бы сентинел,
[14:32.540 --> 14:34.540]  что-то фейковое,
[14:34.540 --> 14:36.540]  что охраняет границы,
[14:36.540 --> 14:38.540]  как сентинел вообще-то, по-моему,
[14:38.540 --> 14:40.540]  как раз типа пограничника слова.
[14:40.540 --> 14:42.540]  Интуитивно я понимаю,
[14:42.540 --> 14:44.540]  что оно значит на английском переводе,
[14:44.540 --> 14:46.540]  не помню. Ну ладно.
[14:46.540 --> 14:48.540]  Значит,
[14:48.540 --> 14:50.540]  у вас есть сентинел, запустили алгоритм,
[14:50.540 --> 14:52.540]  внутри под капотом вы прошли
[14:52.540 --> 14:54.540]  отсюда до конца.
[14:54.540 --> 14:56.540]  Ну и куда-то
[14:56.540 --> 14:58.540]  перекопировали. Причем вот это вот output
[14:58.540 --> 15:00.540]  итератор, он же на самом деле мог быть
[15:00.540 --> 15:02.540]  не какая-то другая строка, а вообще
[15:02.540 --> 15:04.540]  output итератор на консоль.
[15:04.540 --> 15:06.540]  Просто там,
[15:06.540 --> 15:08.540]  знаете же, этот OStream
[15:08.540 --> 15:10.540]  итератор, который
[15:10.540 --> 15:12.540]  просто берет и пишет все, что в него записали
[15:12.540 --> 15:14.540]  на консоль.
[15:14.540 --> 15:16.540]  Бэкинсертер какой-нибудь, ну с бэкинсертером
[15:16.540 --> 15:18.540]  получится, а вот с OStream итератором
[15:18.540 --> 15:20.540]  не получится.
[15:20.540 --> 15:22.540]  Констчр звездочка, сентинел,
[15:22.540 --> 15:24.540]  OStream итератор. Внутри этого алгоритма
[15:24.540 --> 15:26.540]  была посчитана на самом деле длина
[15:26.540 --> 15:28.540]  строки, правда? Вы же дошли
[15:28.540 --> 15:30.540]  от начала до конца.
[15:30.540 --> 15:32.540]  На выход вам вернули какой-то другой OStream итератор
[15:32.540 --> 15:34.540]  и вычитать их друг из друга нельзя,
[15:34.540 --> 15:36.540]  дистанцию находить нельзя,
[15:36.540 --> 15:38.540]  то, что вы сюда передали, оно уже неволидное.
[15:38.540 --> 15:40.540]  То есть вы как бы потеряли вот эту информацию,
[15:40.540 --> 15:42.540]  которую могли бы вообще бесплатно получить.
[15:42.540 --> 15:44.540]  Ну если вам кажется, что это
[15:44.540 --> 15:46.540]  я какие-то бритни рассказываю, то
[15:46.540 --> 15:48.540]  если вам нужно выжать
[15:48.540 --> 15:50.540]  миллисекунды, нанесекунды
[15:50.540 --> 15:52.540]  из вашего алгоритма, то это делается вот так.
[15:52.540 --> 15:54.540]  Минимизировать количество раз, которые вы проходитесь
[15:54.540 --> 15:56.540]  по строке.
[15:56.540 --> 15:58.540]  Надо поменять тип.
[15:58.540 --> 16:00.540]  Да, просто взять
[16:00.540 --> 16:02.540]  и вернуть
[16:04.540 --> 16:06.540]  вот этот вот first после
[16:06.540 --> 16:08.540]  всех инкрементов.
[16:22.540 --> 16:24.540]  Нет, короче,
[16:24.540 --> 16:26.540]  вот такая сигнатура хорошая.
[16:26.540 --> 16:28.540]  Почему? Потому что она всю информацию,
[16:28.540 --> 16:30.540]  которую внутри себя вычислила по ходу дела,
[16:30.540 --> 16:32.540]  вернула.
[16:42.540 --> 16:44.540]  Ну слушай, да, ты прав.
[16:44.540 --> 16:46.540]  Я не знаю, что комитет
[16:46.540 --> 16:48.540]  на этот счет может сказать.
[16:50.540 --> 16:52.540]  Ну да, там скорее всего
[16:52.540 --> 16:54.540]  в библиотеке RNG есть какой-нибудь раппер.
[16:54.540 --> 16:56.540]  Мне правда так и не довелось
[16:56.540 --> 16:58.540]  библиотеку RNG погонять
[16:58.540 --> 17:00.540]  прямо плотно, потому что все
[17:00.540 --> 17:02.540]  все проекты, где я работаю, там они
[17:02.540 --> 17:04.540]  либо не нужны, либо их не получится
[17:04.540 --> 17:06.540]  затащить пока.
[17:08.540 --> 17:10.540]  Ну вот чего не такое.
[17:10.540 --> 17:12.540]  Короче, можно выкрутиться, но да.
[17:12.540 --> 17:14.540]  Вот так решили. Это короче из стандарта.
[17:14.540 --> 17:16.540]  Еще раз хочу уточить.
[17:16.540 --> 17:18.540]  Мы передали Sentinel
[17:18.540 --> 17:20.540]  несколько интеракторов на конец строки.
[17:20.540 --> 17:22.540]  И Sentinel на самом деле
[17:22.540 --> 17:24.540]  будет штука, которая
[17:24.540 --> 17:26.540]  при сравнении с собой будет чекать
[17:26.540 --> 17:28.540]  на то, что... Не с собой.
[17:28.540 --> 17:30.540]  У которой есть оператор сравнения,
[17:30.540 --> 17:32.540]  когда сравниваем конц, чар, звездочку и Sentinel,
[17:32.540 --> 17:34.540]  происходит return
[17:34.540 --> 17:36.540]  звездочка, первый аргумент.
[17:36.540 --> 17:38.540]  равно равно там нуль
[17:38.540 --> 17:40.540]  ноль, да? То есть
[17:40.540 --> 17:42.540]  просто оператор сравнения
[17:42.540 --> 17:44.540]  для вот конц, чар, звездочки и
[17:44.540 --> 17:46.540]  Sentinel выдаст вам
[17:46.540 --> 17:48.540]  лежит ли под
[17:48.540 --> 17:50.540]  оператором нулевой чар или не лежит.
[17:50.540 --> 17:52.540]  То есть у нас Sentinel
[17:52.540 --> 17:54.540]  получился пустым. Sentinel это
[17:54.540 --> 17:56.540]  пустая структура, да, в ней вообще ничего нет.
[17:56.540 --> 17:58.540]  Мы этого набивались?
[17:58.540 --> 18:00.540]  Sentinel здесь просто нужен, чтобы
[18:00.540 --> 18:02.540]  вообще с всеи строками можно было работать.
[18:02.540 --> 18:04.540]  Не находя заранее их длину.
[18:06.540 --> 18:08.540]  Хочется за один проход,
[18:08.540 --> 18:10.540]  чтобы все работало.
[18:10.540 --> 18:12.540]  Минимизировать количество проходов по длинной строке
[18:12.540 --> 18:14.540]  в памяти, потому что доступ в память это
[18:14.540 --> 18:16.540]  дорого. Про это уже вроде
[18:16.540 --> 18:18.540]  обгнил что-то.
[18:18.540 --> 18:20.540]  Так, ну вот, такую функцию добавили в стандарт
[18:20.540 --> 18:22.540]  вместе с двадцатыми плюсами.
[18:24.540 --> 18:26.540]  Сейчас.
[18:26.540 --> 18:28.540]  Да, ну вот такую на самом деле.
[18:28.540 --> 18:30.540]  Ну немножко
[18:30.540 --> 18:32.540]  посложнее стало, да?
[18:34.540 --> 18:36.540]  Ну что здесь написано?
[18:36.540 --> 18:38.540]  Во-первых, вместо пары мы
[18:38.540 --> 18:40.540]  используем какие-то дурацкие структурки
[18:40.540 --> 18:42.540]  с именами, чтобы было понятнее.
[18:42.540 --> 18:44.540]  Там какой-то in-out result есть,
[18:44.540 --> 18:46.540]  copy result,
[18:46.540 --> 18:48.540]  тыры-пыры, copy result,
[18:48.540 --> 18:50.540]  та же самая копия.
[18:50.540 --> 18:52.540]  Ну и концепты навесили.
[18:52.540 --> 18:54.540]  Что?
[18:54.540 --> 18:56.540]  Input Adapter, Sentinel-4.
[18:56.540 --> 18:58.540]  Такой концепт тоже есть. Давайте пока
[18:58.540 --> 19:00.540]  не думать, что там написано. Ну вы догадаться
[19:00.540 --> 19:02.540]  наверное можете, если так прикинуть.
[19:02.540 --> 19:04.540]  И Weakly Incrementable-O.
[19:08.540 --> 19:10.540]  Который вот где-то в Require.se скрыт.
[19:10.540 --> 19:12.540]  Я решил это опустить, это нам не так важно.
[19:14.540 --> 19:16.540]  Теперь надо следить за руками.
[19:16.540 --> 19:18.540]  Мы написали
[19:18.540 --> 19:20.540]  вот такой код.
[19:20.540 --> 19:22.540]  Почему написали using namespace
[19:22.540 --> 19:24.540]  std ranges? Ну потому что тут было
[19:24.540 --> 19:26.540]  очень много кода. Большой алгоритм,
[19:26.540 --> 19:28.540]  где там как-то данные гоняются,
[19:28.540 --> 19:30.540]  перекладываются, что-то вот алгоритмическое
[19:30.540 --> 19:32.540]  происходит. Ну надоело
[19:32.540 --> 19:34.540]  нам писать std ranges копии.
[19:34.540 --> 19:36.540]  Да, я не сказал, вернее
[19:36.540 --> 19:38.540]  я показал, это в namespace и ranges
[19:38.540 --> 19:40.540]  живет, вот этот новый копий. То есть
[19:40.540 --> 19:42.540]  std copy старый остался, как мы
[19:42.540 --> 19:44.540]  начально смотрели. Теперь std ranges
[19:44.540 --> 19:46.540]  копии.
[19:46.540 --> 19:48.540]  Много кода, где-то
[19:48.540 --> 19:50.540]  зовем копии. И вот вопрос.
[19:50.540 --> 19:52.540]  Что в такой ситуации вызвется?
[19:52.540 --> 19:54.540]  В каком
[19:54.540 --> 19:56.540]  namespace? В своем
[19:56.540 --> 19:58.540]  кастомном namespace Keck.
[20:00.540 --> 20:02.540]  А может быть Sentinel
[20:02.540 --> 20:04.540]  с итератором?
[20:04.540 --> 20:06.540]  Да, конечно. Любой
[20:06.540 --> 20:08.540]  тип итератора сам
[20:08.540 --> 20:10.540]  для себя является Sentinel, кроме
[20:10.540 --> 20:12.540]  каких-то там кейсов,
[20:12.540 --> 20:14.540]  когда input итератора, по-моему.
[20:14.540 --> 20:16.540]  А есть юзмут для std или нет?
[20:16.540 --> 20:18.540]  Вот здесь нет.
[20:18.540 --> 20:20.540]  Вот ровно так.
[20:20.540 --> 20:22.540]  Ну как бы хочется
[20:22.540 --> 20:24.540]  сказать, что ты прав, но на самом деле
[20:24.540 --> 20:26.540]  нет. Давай дальше смотреть.
[20:26.540 --> 20:28.540]  Sentinel.
[20:28.540 --> 20:30.540]  Я надеялся, что у меня этот
[20:30.540 --> 20:32.540]  слайд раньше был, но он только здесь.
[20:32.540 --> 20:34.540]  Вот const char звездочка и какой-то
[20:34.540 --> 20:36.540]  magic Sentinel, для которого там оператор
[20:36.540 --> 20:38.540]  сравнение определен с const char звездочка.
[20:38.540 --> 20:40.540]  Вот так зовем. Что
[20:40.540 --> 20:42.540]  тут вызовется?
[20:44.540 --> 20:46.540]  Теперь точно можно сказать.
[20:46.540 --> 20:48.540]  Варианта два,
[20:48.540 --> 20:50.540]  либо std copy, либо std
[20:50.540 --> 20:52.540]  ranges copy.
[20:52.540 --> 20:54.540]  Может ли вызваться std copy?
[20:54.540 --> 20:56.540]  Почему?
[21:02.540 --> 21:04.540]  Это неважно.
[21:04.540 --> 21:06.540]  Мы же знаем, что есть всякие хитрые-хитрые
[21:06.540 --> 21:08.540]  как-то притащить,
[21:08.540 --> 21:10.540]  отоели всякие, еще что-то там.
[21:10.540 --> 21:12.540]  Тут явно не может быть вызвана std
[21:12.540 --> 21:14.540]  копия.
[21:14.540 --> 21:16.540]  Да, разные типы.
[21:16.540 --> 21:18.540]  First и last не одного типа, а тут разных.
[21:18.540 --> 21:20.540]  Ну конечно, std копия вызвать быть не может.
[21:20.540 --> 21:22.540]  Никак.
[21:22.540 --> 21:24.540]  Тут прям std ranges
[21:24.540 --> 21:26.540]  copy строго.
[21:26.540 --> 21:28.540]  Что здесь вызовется?
[21:32.540 --> 21:34.540]  Почему?
[21:36.540 --> 21:38.540]  Ну,
[21:38.540 --> 21:40.540]  как бы тебе сказать.
[21:40.540 --> 21:42.540]  Продолжай мысль.
[21:42.540 --> 21:44.540]  Андрей молчит, потому что
[21:44.540 --> 21:46.540]  он на все эти вопросы может ответить.
[21:46.540 --> 21:48.540]  Аркадий, рассказывай.
[21:48.540 --> 21:50.540]  Сейчас.
[21:50.540 --> 21:52.540]  У нас, наверное, должен сработать
[21:52.540 --> 21:54.540]  ADL. У нас здесь
[21:54.540 --> 21:56.540]  не квалифицирован...
[21:56.540 --> 21:58.540]  не квалифицирован name.
[21:58.540 --> 22:00.540]  Поэтому
[22:00.540 --> 22:02.540]  мы
[22:02.540 --> 22:04.540]  идем, у нас
[22:04.540 --> 22:06.540]  ассоциированный класс
[22:06.540 --> 22:08.540]  будет
[22:08.540 --> 22:10.540]  set int
[22:10.540 --> 22:12.540]  специализированный
[22:12.540 --> 22:14.540]  set лежит
[22:14.540 --> 22:16.540]  в std, поэтому у нас
[22:18.540 --> 22:20.540]  будет ассоциированность
[22:20.540 --> 22:22.540]  в множество, это
[22:22.540 --> 22:24.540]  сначала внутри set,
[22:24.540 --> 22:26.540]  затем в std,
[22:26.540 --> 22:28.540]  потом
[22:28.540 --> 22:30.540]  уже в global
[22:30.540 --> 22:32.540]  namespace вытащенное
[22:32.540 --> 22:34.540]  определение.
[22:34.540 --> 22:36.540]  Как бы
[22:36.540 --> 22:38.540]  в целом, ты правильно мыслишь,
[22:38.540 --> 22:40.540]  но просто
[22:40.540 --> 22:42.540]  можно менее детально сказать, что
[22:42.540 --> 22:44.540]  ADL действительно найдет
[22:44.540 --> 22:46.540]  std копия, потому что
[22:46.540 --> 22:48.540]  аргумент в namespace std лежит,
[22:48.540 --> 22:50.540]  ассоциированный namespace, очевидно.
[22:50.540 --> 22:52.540]  Найдем std копии, включим в множество
[22:52.540 --> 22:54.540]  перегрузок, среди которого нужно
[22:54.540 --> 22:56.540]  найти лучшее.
[22:56.540 --> 22:58.540]  Мы найдем
[22:58.540 --> 23:00.540]  ranges, потому что они как будто
[23:00.540 --> 23:02.540]  в global namespace.
[23:02.540 --> 23:04.540]  Нет, у нас же тут using namespace
[23:04.540 --> 23:06.540]  просто, оно найдется.
[23:06.540 --> 23:08.540]  И ranges копии тоже будет включен.
[23:08.540 --> 23:10.540]  А, ну и там best
[23:10.540 --> 23:12.540]  что будет лучше мэтчиться, нужно посмотреть.
[23:12.540 --> 23:14.540]  Да.
[23:14.540 --> 23:16.540]  Я не помню уже
[23:16.540 --> 23:18.540]  стд копии имеет
[23:18.540 --> 23:20.540]  одинаковые, вот ключевое.
[23:20.540 --> 23:22.540]  Поэтому там
[23:22.540 --> 23:24.540]  bestmatch?
[23:24.540 --> 23:26.540]  Нет, он может быть specialized.
[23:26.540 --> 23:28.540]  С другой стороны
[23:28.540 --> 23:30.540]  range копии, он more constrained
[23:30.540 --> 23:32.540]  по всем аргументам?
[23:32.540 --> 23:34.540]  Ну, ответ
[23:34.540 --> 23:36.540]  на этот вопрос взят из бумаг, которые
[23:36.540 --> 23:38.540]  там
[23:38.540 --> 23:40.540]  есть constraint у ranges копии,
[23:40.540 --> 23:42.540]  а у std копии нет.
[23:42.540 --> 23:44.540]  А суть констраинта
[23:44.540 --> 23:46.540]  это как бы
[23:46.540 --> 23:48.540]  излез констраинт, чем донитие констраинта?
[23:48.540 --> 23:50.540]  Да, ребят, тут есть небольшая деталь,
[23:50.540 --> 23:52.540]  что с одной стороны
[23:52.540 --> 23:54.540]  у std копии одинаковые
[23:54.540 --> 23:56.540]  типы, у первых двух аргументов,
[23:56.540 --> 23:58.540]  к которым он лучше подходит.
[23:58.540 --> 24:00.540]  А у ranges копии разные.
[24:00.540 --> 24:02.540]  С другой стороны у ranges копии есть еще
[24:02.540 --> 24:04.540]  констраинты, концепты какие-то навешаны.
[24:04.540 --> 24:06.540]  И оно как бы тоже кажется, что как-то влияет,
[24:06.540 --> 24:08.540]  но бумаги
[24:08.540 --> 24:10.540]  по std ranges в момент,
[24:10.540 --> 24:12.540]  когда их разрабатывали, вот я их откопал,
[24:12.540 --> 24:14.540]  открыл, прочитал, утверждается, что все-таки std копии
[24:14.540 --> 24:16.540]  будет вызван здесь в такой ситуации.
[24:16.540 --> 24:18.540]  А почему не кидать от видео стол?
[24:18.540 --> 24:20.540]  Так плюсы работают.
[24:20.540 --> 24:22.540]  Когда можно разрешить хоть как-то
[24:22.540 --> 24:24.540]  да.
[24:24.540 --> 24:26.540]  Такие правила.
[24:26.540 --> 24:28.540]  Надо выкуривать стандарт.
[24:28.540 --> 24:30.540]  Сейчас, по-моему, там просто
[24:30.540 --> 24:32.540]  дело в том, что
[24:32.540 --> 24:34.540]  вот этот огромный
[24:34.540 --> 24:36.540]  относительный порядок
[24:36.540 --> 24:38.540]  в overload resolution сначала проверяет
[24:38.540 --> 24:40.540]  специализацию, только потом
[24:40.540 --> 24:42.540]  мороконстраинт. То есть он на констраинты смотрит.
[24:42.540 --> 24:44.540]  После того...
[24:44.540 --> 24:46.540]  То есть, естественно, он убедился, что
[24:46.540 --> 24:48.540]  типа all above включая
[24:48.540 --> 24:50.540]  вот, опять
[24:50.540 --> 24:52.540]  вот, нашли 5-6.
[24:52.540 --> 24:54.540]  А, ну вот.
[24:54.540 --> 24:56.540]  Значит, строго написано в стандарте,
[24:56.540 --> 24:58.540]  что сначала мы смотрим, что
[24:58.540 --> 25:00.540]  аргументы, типы аргументов
[25:00.540 --> 25:02.540]  более как бы подходят.
[25:02.540 --> 25:04.540]  Вот это more specialize, что std ranges
[25:04.540 --> 25:06.540]  одинаковые, и у нас тут одинаковые,
[25:06.540 --> 25:08.540]  а у ranges копии разные.
[25:08.540 --> 25:10.540]  Это берет приоритет над всем,
[25:10.540 --> 25:12.540]  на констраинты не смотрим. Во,
[25:12.540 --> 25:14.540]  вызвали std копия.
[25:14.540 --> 25:16.540]  Да? Ну, уже как-то неловко становится,
[25:16.540 --> 25:18.540]  да? Вот так пишем
[25:18.540 --> 25:20.540]  ranges копии, вот так пишем копии.
[25:20.540 --> 25:22.540]  Не надо просто никогда
[25:22.540 --> 25:24.540]  писательство не квалифицировать.
[25:24.540 --> 25:26.540]  Ну,
[25:26.540 --> 25:28.540]  понимаешь,
[25:28.540 --> 25:30.540]  как бы
[25:30.540 --> 25:32.540]  тебе сейчас понятно, что никогда
[25:32.540 --> 25:34.540]  он квалификает вызовы, вообще не нужно писать. И там
[25:34.540 --> 25:36.540]  мне понятно, и многим тут понятно, возможно.
[25:36.540 --> 25:38.540]  Не уверен. Ну, на работе, по крайней мере,
[25:38.540 --> 25:40.540]  всегда все полностью квалифицирую.
[25:40.540 --> 25:42.540]  А, ну вот.
[25:42.540 --> 25:44.540]  У людей был как бы опыт
[25:44.540 --> 25:46.540]  печальный. Ну, не стажер случайно
[25:46.540 --> 25:48.540]  написал? Нет. Сеньор?
[25:48.540 --> 25:50.540]  Или просто чувак?
[25:50.540 --> 25:52.540]  Не, ну просто компилятор обновили,
[25:52.540 --> 25:54.540]  он в вождь не кидал.
[25:54.540 --> 25:56.540]  Ой.
[25:56.540 --> 25:58.540]  Ой.
[25:58.540 --> 26:00.540]  Ой. Ну, вот такое
[26:00.540 --> 26:02.540]  значит бывает.
[26:02.540 --> 26:04.540]  Вот бывает такое,
[26:04.540 --> 26:06.540]  бывает, что вы разработчики
[26:06.540 --> 26:08.540]  какой-нибудь стандартной
[26:08.540 --> 26:10.540]  библиотеки или буста, и вам
[26:10.540 --> 26:12.540]  там, у вас там
[26:12.540 --> 26:14.540]  тоже много всего, и там такие
[26:14.540 --> 26:16.540]  проблемы тоже бывают.
[26:16.540 --> 26:18.540]  Ты хочешь, наверное, перегружать
[26:18.540 --> 26:20.540]  оператор битого воздвига?
[26:20.540 --> 26:22.540]  Не, давайте
[26:22.540 --> 26:24.540]  так, серьезно.
[26:24.540 --> 26:26.540]  А бывает...
[26:26.540 --> 26:28.540]  Это сейчас не шутка была.
[26:28.540 --> 26:30.540]  Так, и что с этой перегрузкой?
[26:30.540 --> 26:32.540]  Ну, тут да, тут вот это вот все.
[26:32.540 --> 26:34.540]  Ну, не будет же никто писать, типа
[26:34.540 --> 26:36.540]  namespace 2.2.оператор
[26:36.540 --> 26:38.540]  битшифта 2?
[26:38.540 --> 26:40.540]  Ну, да. Ну, ты обычно через EDL находишь
[26:40.540 --> 26:42.540]  свой оператор битшифта, если не находишь
[26:42.540 --> 26:44.540]  что-то. Левого аргумента есть.
[26:44.540 --> 26:46.540]  И вот правого аргумента есть.
[26:46.540 --> 26:48.540]  Да, тогда уже вот что-то такое придется,
[26:48.540 --> 26:50.540]  и могут быть проблемы.
[26:50.540 --> 26:52.540]  В общем, самый частый кейс, когда проблемы будут,
[26:52.540 --> 26:54.540]  это когда вы в школе ECM пишете.
[26:54.540 --> 26:56.540]  Вот, вы такую фигню
[26:56.540 --> 26:58.540]  бахнули, и
[26:58.540 --> 27:00.540]  у вас все сломалось, и
[27:00.540 --> 27:02.540]  сидишь на Олимпиаде и думаешь, что произошло?
[27:02.540 --> 27:04.540]  Вы не забывайте, что C++
[27:04.540 --> 27:06.540]  это язык, которому еще
[27:06.540 --> 27:08.540]  кого-то обучать надо, да?
[27:08.540 --> 27:10.540]  Ребят, потише, пожалуйста.
[27:10.540 --> 27:12.540]  Вот как бы очень здорово,
[27:12.540 --> 27:14.540]  когда там много лет опыт на плюсах есть,
[27:14.540 --> 27:16.540]  и ты уже advanced темы понимаешь,
[27:16.540 --> 27:18.540]  но вот эта вот вся шняга должна работать,
[27:18.540 --> 27:20.540]  даже когда школьник Олимпиадки решает в 8 классе.
[27:20.540 --> 27:22.540]  Понимаете?
[27:22.540 --> 27:24.540]  И вот если вот такой
[27:24.540 --> 27:26.540]  using namespace это абсолютно, типа,
[27:26.540 --> 27:28.540]  всегда встречается, то
[27:28.540 --> 27:30.540]  вот это может привести к такому бубуху,
[27:30.540 --> 27:32.540]  что беда.
[27:32.540 --> 27:34.540]  Вот, соответственно, это так жить невозможно.
[27:34.540 --> 27:36.540]  А бывает еще хуже.
[27:36.540 --> 27:38.540]  Вот это вот самое убойное.
[27:38.540 --> 27:40.540]  Что вызовется?
[27:42.540 --> 27:44.540]  Предыдущий
[27:44.540 --> 27:46.540]  был set,
[27:46.540 --> 27:48.540]  а теперь
[27:48.540 --> 27:50.540]  вектор. Что поменялось?
[27:50.540 --> 27:52.540]  Неужели у вектора
[27:52.540 --> 27:54.540]  есть какой-нибудь там фрэнк?
[27:54.540 --> 27:56.540]  Не-не-не.
[27:56.540 --> 27:58.540]  А что такое
[27:58.540 --> 28:00.540]  итератор?
[28:00.540 --> 28:02.540]  Да, а что такое итератор у вектора?
[28:02.540 --> 28:04.540]  Ну вот, смотря кого вы спросите.
[28:04.540 --> 28:06.540]  Если вы спросите там всякие стандартные
[28:06.540 --> 28:08.540]  библиотеки, типа, EASTL,
[28:08.540 --> 28:10.540]  или, типа,
[28:10.540 --> 28:12.540]  кого-нибудь там, типа,
[28:12.540 --> 28:14.540]  кто-то еще
[28:14.540 --> 28:16.540]  так делал, когда...
[28:16.540 --> 28:18.540]  Ну, когда
[28:18.540 --> 28:20.540]  какой-нибудь O3
[28:20.540 --> 28:22.540]  и выключены все проверки выхода за границы,
[28:22.540 --> 28:24.540]  и вам нужно супер оптимайжена,
[28:24.540 --> 28:26.540]  вот этот тип
[28:26.540 --> 28:28.540]  это будет просто ин звездочка.
[28:28.540 --> 28:30.540]  А если нет,
[28:30.540 --> 28:32.540]  то вот у вас другой кейс,
[28:32.540 --> 28:34.540]  то есть, там, MSWC библиотек
[28:34.540 --> 28:36.540]  или проверка у итераторов
[28:36.540 --> 28:38.540]  на выход за границу включен, то, конечно,
[28:38.540 --> 28:40.540]  это будет ин звездочка.
[28:40.540 --> 28:42.540]  Как вы проверку на выход за границу будете делать с ин звездочкой?
[28:42.540 --> 28:44.540]  Никак.
[28:44.540 --> 28:46.540]  И это будет уже что-то в namespace STD.
[28:46.540 --> 28:48.540]  Соответственно,
[28:48.540 --> 28:50.540]  если вам повезло, это лежит на namespace STD
[28:50.540 --> 28:52.540]  и ADL найдет
[28:52.540 --> 28:54.540]  STD копия,
[28:54.540 --> 28:56.540]  а если это ин звездочка,
[28:56.540 --> 28:58.540]  то нету никакого ADL,
[28:58.540 --> 29:00.540]  и вы найдете ranges копии,
[29:00.540 --> 29:02.540]  потому что вот.
[29:02.540 --> 29:04.540]  Implementation defined.
[29:04.540 --> 29:06.540]  Нормально? Вообще класс.
[29:06.540 --> 29:08.540]  Когда сразу получается
[29:08.540 --> 29:10.540]  забавный момент,
[29:10.540 --> 29:12.540]  если в одном кодике сначала vector.int,
[29:12.540 --> 29:14.540]  потом vector.bool,
[29:14.540 --> 29:16.540]  то какую бы мы имплементацию не зафиксировали,
[29:16.540 --> 29:18.540]  и вызывать разные перегрузки.
[29:18.540 --> 29:20.540]  Да, если вы пишете шаблонный код,
[29:20.540 --> 29:22.540]  где vector от чего-то произвольного,
[29:22.540 --> 29:24.540]  то с vector.bool вы так
[29:24.540 --> 29:26.540]  накушаетесь вообще.
[29:26.540 --> 29:28.540]  А еще раз, я не понимаю, почему
[29:28.540 --> 29:30.540]  ваше STD-вектор
[29:30.540 --> 29:32.540]  и тератор это
[29:32.540 --> 29:34.540]  ин звездочка? Да, смотри,
[29:34.540 --> 29:36.540]  стандарт не запрещает что так, что так делать.
[29:36.540 --> 29:38.540]  Вот стандартная библиотека,
[29:38.540 --> 29:40.540]  которая подходит под
[29:40.540 --> 29:42.540]  стандарт,
[29:42.540 --> 29:44.540]  она имеет право написать
[29:44.540 --> 29:46.540]  итератор для вектора как полноценный класс
[29:46.540 --> 29:48.540]  со всякими операторами,
[29:48.540 --> 29:50.540]  присвоения и прочим-прочим.
[29:50.540 --> 29:52.540]  Так и имеет право сделать
[29:52.540 --> 29:54.540]  итератор у вектора просто указателем.
[29:54.540 --> 29:56.540]  Вы, span, решали,
[29:56.540 --> 29:58.540]  что делать итератором? Указатель.
[29:58.540 --> 30:00.540]  К чему была подводка?
[30:00.540 --> 30:02.540]  То есть это в принципе стандартом разрешено,
[30:02.540 --> 30:04.540]  и у span, и у вектора может быть
[30:04.540 --> 30:06.540]  и вообще у любого contiguous range,
[30:06.540 --> 30:08.540]  итератор его может быть просто т звездочка.
[30:10.540 --> 30:12.540]  Ну и вот в таком случае,
[30:12.540 --> 30:14.540]  как бы вы на венде компилируете
[30:14.540 --> 30:16.540]  у вас одно поведение, на линуксе другое.
[30:16.540 --> 30:18.540]  И что?
[30:18.540 --> 30:20.540]  И как жить?
[30:22.540 --> 30:24.540]  Ну, типы разные.
[30:24.540 --> 30:26.540]  А мы только что поняли, что если
[30:26.540 --> 30:28.540]  first и last лежат на эмспейсе STD,
[30:28.540 --> 30:30.540]  то будет вызвана STD-копия,
[30:30.540 --> 30:32.540]  а если нет, то STD-Ranges-копия.
[30:34.540 --> 30:36.540]  Разные функции с разной сигнатурой
[30:36.540 --> 30:38.540]  и разным возвращаемым типом.
[30:38.540 --> 30:40.540]  У нас тогда получается, можно еще отметить,
[30:40.540 --> 30:42.540]  что алиасы,
[30:42.540 --> 30:44.540]  они учитываются
[30:44.540 --> 30:46.540]  как типы, которые они алиасят,
[30:46.540 --> 30:48.540]  а не как они сами.
[30:48.540 --> 30:50.540]  Да, там какой-то такой еще прикол есть.
[30:50.540 --> 30:52.540]  Нет, ну это буквально
[30:52.540 --> 30:54.540]  вот тут как раз и скрывается.
[30:54.540 --> 30:56.540]  Если бы алиас
[30:56.540 --> 30:58.540]  считался отдельной сущностью,
[30:58.540 --> 31:00.540]  а не заменялся
[31:00.540 --> 31:02.540]  на тип конкретный,
[31:02.540 --> 31:04.540]  то тогда всегда вызывался бы STD-копия.
[31:04.540 --> 31:06.540]  Как же ты в корень зришь?
[31:06.540 --> 31:08.540]  Я даже не задумывался об этом.
[31:08.540 --> 31:10.540]  Ну, интересно вообще.
[31:10.540 --> 31:12.540]  Алиасы можно шаблонизировать
[31:12.540 --> 31:14.540]  отдельно от того, кого они алиасы.
[31:14.540 --> 31:16.540]  Да, интересно, что будет, если шаблонные
[31:16.540 --> 31:18.540]  алиасы. Вообще
[31:18.540 --> 31:20.540]  хороший вопрос. А как взаимодействуют
[31:20.540 --> 31:22.540]  ЭДЛ и алиасы? Ответа на него у меня
[31:22.540 --> 31:24.540]  сейчас нет.
[31:24.540 --> 31:26.540]  Потому что такого я не пробовал делать.
[31:26.540 --> 31:28.540]  Сейчас, насколько я
[31:28.540 --> 31:30.540]  помню приколы 23-х плюсов,
[31:30.540 --> 31:32.540]  там уже отдельно что-то фиксили
[31:32.540 --> 31:34.540]  по этому поводу. Не на мой больший уровень,
[31:34.540 --> 31:36.540]  но уровня, кстати, длиннее был.
[31:36.540 --> 31:38.540]  Все-таки алиас сначала вскрывается
[31:38.540 --> 31:40.540]  и потом стараться
[31:40.540 --> 31:42.540]  сценировать их уже по ним.
[31:42.540 --> 31:44.540]  И нестинность этих прикол
[31:44.540 --> 31:46.540]  учитывается уже в концерте.
[31:46.540 --> 31:48.540]  То есть то, где
[31:48.540 --> 31:50.540]  определен вот этот алиас-этератор, оно не
[31:50.540 --> 31:52.540]  играет роли, правда? Не играет.
[31:52.540 --> 31:54.540]  Да, ну все.
[31:54.540 --> 31:56.540]  То есть все здесь правильно. Действительно
[31:56.540 --> 31:58.540]  на ровном месте вы получаете
[31:58.540 --> 32:00.540]  не кроссплатформенность.
[32:00.540 --> 32:02.540]  Прекрасно.
[32:02.540 --> 32:04.540]  Нам это надо фиксить.
[32:04.540 --> 32:06.540]  Согласны?
[32:06.540 --> 32:08.540]  Почему нет?
[32:08.540 --> 32:10.540]  Мы дадим школьникам
[32:10.540 --> 32:12.540]  код писать.
[32:14.540 --> 32:16.540]  Кто придет
[32:16.540 --> 32:18.540]  нам на смену, чтобы кодить
[32:18.540 --> 32:20.540]  на C++?
[32:20.540 --> 32:22.540]  Вы уже на должном уровне знаете,
[32:22.540 --> 32:24.540]  чтобы задуматься о таких вопросах, правда?
[32:24.540 --> 32:26.540]  Да.
[32:26.540 --> 32:28.540]  Здесь мы, получается, игнорируем
[32:28.540 --> 32:30.540]  возвращаемое значение, если не будем игнорировать
[32:30.540 --> 32:32.540]  и явно напишем 5.
[32:32.540 --> 32:34.540]  Ну,
[32:34.540 --> 32:36.540]  не будет компилироваться,
[32:36.540 --> 32:38.540]  но...
[32:38.540 --> 32:40.540]  Ну что? Не факт!
[32:40.540 --> 32:42.540]  А что?
[32:42.540 --> 32:44.540]  А это есть
[32:44.540 --> 32:46.540]  такое вроде?
[32:46.540 --> 32:48.540]  Ну, еще
[32:48.540 --> 32:50.540]  внимание, прикол.
[32:50.540 --> 32:52.540]  Это может скомпилироваться как, если вам здесь
[32:52.540 --> 32:54.540]  вернули вот эту вот пару,
[32:54.540 --> 32:56.540]  так и если
[32:56.540 --> 32:58.540]  у вас итераторы, какой-то странной
[32:58.540 --> 33:00.540]  структуры, это...
[33:00.540 --> 33:02.540]  Какой-то структуры данных странные. Это просто
[33:02.540 --> 33:04.540]  структурки из двух элементов.
[33:04.540 --> 33:06.540]  Ну, бывает такое, что...
[33:06.540 --> 33:08.540]  Структуры из двух элементов стараются получиться,
[33:08.540 --> 33:10.540]  но можно реализовывать эту подготовку?
[33:10.540 --> 33:12.540]  Нет. Чтобы структуры, чтобы структуры-биндинги
[33:12.540 --> 33:14.540]  работали для структур, ничего делать не надо.
[33:14.540 --> 33:16.540]  Они автоматом работают.
[33:16.540 --> 33:18.540]  Более того, для структуры из трех или четырех
[33:18.540 --> 33:20.540]  или пяти элементов это тоже сработает.
[33:20.540 --> 33:22.540]  То есть, если у вас внезапно итератор,
[33:22.540 --> 33:24.540]  а эта структура, а не класс
[33:24.540 --> 33:26.540]  инкапсулированный, ну, вдруг какая-то
[33:26.540 --> 33:28.540]  библиотека вам прилетела, гадостная,
[33:28.540 --> 33:30.540]  и в ней вот так вот заведено,
[33:30.540 --> 33:32.540]  то у вас здесь все скомпилируется в этой строчке,
[33:32.540 --> 33:34.540]  только ИИО это будет вообще
[33:34.540 --> 33:36.540]  непонятно что. Какие-то кишки
[33:36.540 --> 33:38.540]  одного итератора, аутпут, который
[33:38.540 --> 33:40.540]  вернул вам СТД-копия.
[33:40.540 --> 33:42.540]  И дальше вы пойдете с ними что-то делать и словите
[33:42.540 --> 33:44.540]  такую ошибку о компиляции,
[33:44.540 --> 33:46.540]  что мама не горюй.
[33:46.540 --> 33:48.540]  Это все теория, конечно. Не уверен, что
[33:48.540 --> 33:50.540]  кому-то на практике приходилось с таким сталкиваться.
[33:50.540 --> 33:52.540]  Я сталкивался с тем, что я добавил
[33:52.540 --> 33:54.540]  Define Glipstakes и ExitDebug
[33:54.540 --> 33:56.540]  педалью.
[33:56.540 --> 33:58.540]  Компилировал, и оно не компилировалось,
[33:58.540 --> 34:00.540]  потому что там, типа...
[34:00.540 --> 34:02.540]  А, то есть, вот как раз поменялся...
[34:02.540 --> 34:04.540]  ...на какой-то другой итератор, да, и
[34:04.540 --> 34:06.540]  что-то не то запомнилось. Да, вот
[34:06.540 --> 34:08.540]  это правильное
[34:08.540 --> 34:10.540]  замечание, я так вскользь сказал, что
[34:10.540 --> 34:12.540]  вот есть обычно у стандартных библиотек
[34:12.540 --> 34:14.540]  режимы дебага итераторов, да.
[34:14.540 --> 34:16.540]  Как ты сказал этот?
[34:16.540 --> 34:18.540]  Вот, Glipstakes
[34:18.540 --> 34:20.540]  debugpedantic. Вот оно, кажется, включает,
[34:20.540 --> 34:22.540]  что там итераторы становятся другими и очень
[34:22.540 --> 34:24.540]  много всяких ассертов и дебага делают.
[34:24.540 --> 34:26.540]  У
[34:26.540 --> 34:28.540]  Microsoft такая же штука есть. Да, в принципе, у
[34:28.540 --> 34:30.540]  всех оно должно быть, кто у себя вообще хоть
[34:30.540 --> 34:32.540]  как-то уважает, потому что без дебага итераторов
[34:32.540 --> 34:34.540]  многие вещи отловить невозможно.
[34:34.540 --> 34:36.540]  А то, что этот дебаг итераторов начинает
[34:36.540 --> 34:38.540]  менять поведение нашего кода, это просто
[34:38.540 --> 34:40.540]  пху!
[34:40.540 --> 34:42.540]  Да,
[34:42.540 --> 34:44.540]  потому что там
[34:44.540 --> 34:46.540]  другая реализация,
[34:46.540 --> 34:48.540]  которая с дебагом.
[34:48.540 --> 34:50.540]  Без дебага, с дебагом, они там
[34:50.540 --> 34:52.540]  разных лежат, и все ломается.
[34:52.540 --> 34:54.540]  Окей. Как чинить будем?
[34:54.540 --> 34:56.540]  Давайте придумывать.
[34:56.540 --> 34:58.540]  Это
[34:58.540 --> 35:00.540]  здорово!
[35:00.540 --> 35:02.540]  Вот ключевая аудитория
[35:02.540 --> 35:04.540]  этого фикса, это вот
[35:04.540 --> 35:06.540]  люди, которые
[35:06.540 --> 35:09.660]  этого фикса. Это вот люди, которые только начали изучать
[35:09.660 --> 35:11.300]  плюсы и которым плюсы нужны.
[35:11.300 --> 35:13.740]  RNG равно std ranges.
[35:13.740 --> 35:16.660]  Можно так, но ты все равно не приучишь школьников
[35:16.660 --> 35:20.260]  писать так, все равно будет вот это. Вот нужно, чтобы
[35:20.260 --> 35:22.980]  вот ты так написал, так написал, и это нормально работало.
[35:22.980 --> 35:23.980]  Фикс не здесь.
[35:23.980 --> 35:26.180]  Можно зафиксировать naming-cap и писать...
[35:26.180 --> 35:30.100]  Нет, нет. Смотри, вот этот код зафиксирован просто
[35:30.100 --> 35:31.940]  цементно. Его менять нельзя.
[35:31.940 --> 35:35.180]  Раз не компилирует этот код.
[35:35.180 --> 35:39.820]  Но правильно в том, что на плюсах написано.
[35:39.820 --> 35:42.740]  На плюсах он должен начать работать нормально. Придумайте
[35:42.740 --> 35:45.420]  фикс. Ну не очевидно, понимаю.
[35:45.420 --> 35:46.900]  Выключить.
[35:46.900 --> 35:52.460]  Выключить EDL, ну, были предложения, но невозможно, потому что
[35:52.460 --> 35:54.100]  тогда у тебя Hello World не будет работать.
[35:54.100 --> 35:59.220]  А так, ну, у нас тоже Hello World, из импорта стд, стд принт.
[35:59.220 --> 36:00.220]  Ну как бы, да.
[36:00.220 --> 36:04.660]  Это повод для того, чтобы написать проползл в стандарт,
[36:04.660 --> 36:08.660]  давайте выпилим EDL, но этого не будет. Как жить?
[36:08.660 --> 36:15.660]  А жить вот так. Что вас здесь может заинтересовать?
[36:15.660 --> 36:20.660]  Функция внутри функции.
[36:20.660 --> 36:26.940]  Почему? Ну что вы... Функции внутри функции, это когда
[36:26.940 --> 36:29.860]  вы прямо внутри функции пишете декларацию, другое
[36:30.340 --> 36:32.340]  Мы только что договорились, что этот код зафиксирован
[36:32.340 --> 36:35.340]  цементом. Вот здесь декларацию какую-то написать нельзя.
[36:35.340 --> 36:44.340]  Не очевидно, да? Давайте еще подсказку.
[36:44.340 --> 36:48.340]  Вот когда вот такое выражение видите, что это может быть?
[36:48.340 --> 36:52.340]  Вот это вот копия, это может быть конструктор, это может
[36:52.340 --> 36:55.340]  быть, ну, вызов функции, как мы и раньше думали, а еще...
[36:55.340 --> 36:57.340]  Какого?
[36:57.820 --> 37:01.820]  Какой метод? Какого класса?
[37:01.820 --> 37:03.820]  Нет, а если мы внутри класса находимся, то это может
[37:03.820 --> 37:05.820]  быть метод текущего класса.
[37:05.820 --> 37:08.820]  Окей, еще.
[37:08.820 --> 37:11.820]  Сейчас вот, что?
[37:11.820 --> 37:15.820]  Да, это может быть вызов оператора круглые скобки
[37:15.820 --> 37:18.820]  на объекте копия.
[37:18.820 --> 37:21.820]  А объявление не функции, то есть объекта с названием
[37:21.820 --> 37:26.820]  копия, выключает EDL.
[37:27.300 --> 37:30.300]  Вот оно.
[37:30.300 --> 37:33.300]  То есть что мы делаем? Мы делаем копию FN структуру.
[37:33.300 --> 37:35.300]  У нее делаем оператора круглые скобки.
[37:35.300 --> 37:40.300]  Теперь вот здесь находится код нашего копия алгоритма.
[37:40.300 --> 37:43.300]  Вот сигнатура точно такая же, как у копия была у этого
[37:43.300 --> 37:44.300]  оператора круглые скобки.
[37:44.300 --> 37:45.300]  Да?
[37:45.300 --> 37:47.300]  Помните?
[37:47.300 --> 37:48.300]  Окей.
[37:48.300 --> 37:52.300]  И делаем inline constexpr копии FN копии фигурной скобки.
[37:52.300 --> 37:55.300]  Глобальный constexpr объект.
[37:55.780 --> 37:56.780]  Вот этого типа.
[37:56.780 --> 37:57.780]  Данных в нем нет.
[37:57.780 --> 38:00.780]  Есть только оператор круглые скобки.
[38:01.780 --> 38:04.780]  ADL не включится, потому что мы в namespace STD range
[38:04.780 --> 38:07.780]  сразу найдем копия и все.
[38:08.780 --> 38:10.780]  Ни ADL ничего не будет.
[38:10.780 --> 38:13.780]  Мы нашли не функцию, поэтому...
[38:14.780 --> 38:15.780]  Вот такой прикол.
[38:15.780 --> 38:18.780]  И вот этот вот объект называется nebloid.
[38:19.780 --> 38:22.780]  То есть мораль nebloid, это вот такая конструкция,
[38:23.260 --> 38:25.260]  которая подавляет ADL.
[38:28.260 --> 38:29.260]  Ничего не понятно.
[38:29.260 --> 38:30.260]  Что?
[38:33.260 --> 38:37.260]  Ну сейчас мы в какой-то момент откроем кланговскую STD
[38:37.260 --> 38:39.260]  либу и увидим там вот примерно такое.
[38:46.260 --> 38:47.260]  Нет, смотри, если ты...
[38:47.260 --> 38:48.260]  Ребят, потише, пожалуйста.
[38:48.260 --> 38:51.620]  Если ты пишешь свою стандартную библиотеку и ты в ней хочешь
[38:51.620 --> 38:52.620]  иметь функцию копия.
[38:52.620 --> 38:55.620]  И причем у тебя была старая функция копия.
[38:55.620 --> 38:57.620]  Вот мы же только кейс рассматривали, только что, да?
[38:57.620 --> 38:58.620]  Жуткий.
[38:58.620 --> 39:01.620]  Вот если ты попал в такую ситуацию, как авторы стандартной
[39:01.620 --> 39:04.620]  библиотеки, где есть старая копия, новая копия,
[39:04.620 --> 39:06.620]  ну а такое в жизни может быть, когда у тебя очень
[39:06.620 --> 39:09.620]  большой проект, там есть всякая legacy,
[39:09.620 --> 39:12.620]  и там некоторые штуки одинаково называются, но делают немножко
[39:12.620 --> 39:13.620]  разное.
[39:13.620 --> 39:16.620]  Вот в такой ситуации тебе стоит сделать вот так
[39:16.620 --> 39:20.620]  и подавить ADL, чтобы никогда не было случайного вызова
[39:20.620 --> 39:22.620]  не того, что ты ожидаешь.
[39:23.620 --> 39:24.620]  Вот.
[39:24.620 --> 39:27.620]  Но в принципе, вот от тебя вот это вот писать в жизни
[39:27.620 --> 39:29.620]  потребуется примерно никогда, если только ты не станешь
[39:29.620 --> 39:31.620]  разработчиком стандартной библиотеки,
[39:31.620 --> 39:33.620]  либо Boosta, либо QT.
[39:33.620 --> 39:34.620]  Ну какие еще варианты?
[39:34.620 --> 39:35.620]  В принципе все.
[39:35.620 --> 39:38.620]  Ну Upsell тоже считается стандартная библиотека.
[39:39.620 --> 39:41.620]  То есть вот этим ребятам, которые пишут огромные,
[39:41.620 --> 39:43.620]  жуткие, шаблонизированные библиотеки, вот это вот
[39:43.620 --> 39:45.620]  очень нужно и полезно.
[39:45.620 --> 39:48.620]  Чтобы там дружить с предыдущими версиями и спокойно
[39:48.620 --> 39:50.620]  мигрировать, а также не конфликтовать с другими
[39:50.620 --> 39:51.620]  библиотеками.
[39:52.620 --> 39:54.620]  Ну если у вас несколько библиотек, и в них разные
[39:54.620 --> 39:56.620]  копии, в разных namespace тоже проблемы.
[39:59.620 --> 40:00.620]  Можно еще объяснить?
[40:00.620 --> 40:01.620]  Да.
[40:01.620 --> 40:02.620]  У нас есть копия френд структуры.
[40:02.620 --> 40:03.620]  Да.
[40:03.620 --> 40:05.620]  Не перебружен оператор круглый с кодом.
[40:05.620 --> 40:06.620]  Да.
[40:06.620 --> 40:07.620]  Не обязательно...
[40:09.620 --> 40:11.620]  Он именно просто объявлен?
[40:11.620 --> 40:13.620]  Ну там код написан.
[40:13.620 --> 40:14.620]  Я просто его здесь опустил.
[40:15.620 --> 40:17.620]  Там прям реализация написана, да.
[40:18.620 --> 40:21.620]  А дальше мы делаем онлайн констексов копии fn-копии.
[40:21.620 --> 40:22.620]  Это что мы сделаем?
[40:22.620 --> 40:23.620]  Переменная.
[40:23.620 --> 40:25.620]  Это переменная типа копии fn.
[40:25.620 --> 40:27.620]  С названием копия.
[40:27.620 --> 40:29.620]  Глобальная переменная.
[40:29.620 --> 40:31.620]  А почему она констэкспор?
[40:31.620 --> 40:34.620]  Ну потому что зачем нам в ронтайме с ней что-то делать?
[40:34.620 --> 40:35.620]  Она один раз.
[40:35.620 --> 40:37.620]  Она нам нужна только чтобы у нее оператор круглый
[40:37.620 --> 40:38.620]  с копии был.
[40:38.620 --> 40:39.620]  Навешиваем констэкспор.
[40:39.620 --> 40:41.620]  Почему она онлайн?
[40:41.620 --> 40:43.620]  А проверка на вшивость.
[40:43.620 --> 40:45.620]  Зачем она онлайн?
[40:45.620 --> 40:46.620]  Чтобы не ругался линкер.
[40:46.620 --> 40:47.620]  Чтобы не ругался линкер.
[40:47.620 --> 40:48.620]  Верно.
[40:48.620 --> 40:49.620]  Потому что это все в хедере написано.
[40:49.620 --> 40:50.620]  Это все шаблоны.
[40:50.620 --> 40:53.620]  В хедере все переменные должны быть помечены онлайн.
[40:53.620 --> 40:56.620]  Ну там вроде констэкспор по дефолту онлайн.
[40:56.620 --> 41:00.620]  Я тоже думал, что констэкспор по дефолту онлайн.
[41:00.620 --> 41:02.620]  На счет переменных это неправда.
[41:02.620 --> 41:04.620]  Нет, не по дефолту онлайн.
[41:04.620 --> 41:08.620]  Просто когда ты пишешь в классе статик онлайн...
[41:08.620 --> 41:14.620]  Если ты не пишешь онлайн, тебе ругается, что нарушен definition rules и прочее.
[41:14.620 --> 41:17.620]  Констэкспорт это статик конст.
[41:17.620 --> 41:20.620]  Мембр и для него компилятор автоматически оптимизирует.
[41:20.620 --> 41:22.620]  Что такое двайк для переменных?
[41:22.620 --> 41:24.620]  То же самое, что и для функций.
[41:24.620 --> 41:26.620]  Когда ты в хедере реализовал функцию,
[41:26.620 --> 41:29.620]  и ты этот хедр в два разных cpp-шника включил,
[41:29.620 --> 41:32.620]  у тебя будет multiple definitions, конфликт.
[41:32.620 --> 41:34.620]  Нарушение one definition rule.
[41:34.620 --> 41:38.620]  Потому что код функции просто из хедра подтянут в один cpp-шник, в другой.
[41:38.620 --> 41:40.620]  Там скомпилировали функцию здесь.
[41:40.620 --> 41:43.620]  Итог у тебя в двух объектных файлах одинаковая функция с одинаковым всем.
[41:43.620 --> 41:45.620]  Нарушение odr.
[41:45.620 --> 41:47.620]  Чтобы этого не было, мы помечаем функцию inline.
[41:47.620 --> 41:49.620]  Что это значит?
[41:49.620 --> 41:52.620]  Компилятор, забей на то, что там два definition,
[41:52.620 --> 41:54.620]  я обещаю, что они одинаковые.
[41:54.620 --> 41:56.620]  То же самое для переменных.
[41:56.620 --> 41:58.620]  У тебя каждая глобальная переменная,
[41:58.620 --> 42:02.620]  это будет некоторое выделенное количество байтиков в объектном файле.
[42:02.620 --> 42:04.620]  Зарезервированных глобальных байтиков.
[42:04.620 --> 42:09.620]  Которые потом попадут в какую-нибудь pro-дату в xz-шнике или еще куда-нибудь.
[42:09.620 --> 42:11.620]  Ну и вот вопрос.
[42:11.620 --> 42:14.620]  Вот у тебя в одном объектном файле есть переменная,
[42:14.620 --> 42:17.620]  и в другом объектном файле переменная абсолютно одинаковая.
[42:17.620 --> 42:20.620]  Вот ты имел в виду, что это одна и та же переменная,
[42:20.620 --> 42:23.620]  и у них общая память должна быть в итоговом xz-шнике.
[42:23.620 --> 42:26.620]  Или это две разных, и у них разная память должна быть.
[42:26.620 --> 42:29.620]  Вот чтобы было две разных, нужно написать static.
[42:29.620 --> 42:32.620]  Чтобы была одна и та же память, нужно написать inline.
[42:32.620 --> 42:35.620]  Если ничего не написать, будет как бы нарушение odr.
[42:37.620 --> 42:40.620]  Быстрый рекап первых двух лекций.
[42:40.620 --> 42:43.620]  А как вы там проявляете constexpr?
[42:44.620 --> 42:47.620]  Ну чтобы ты не мог написать какую-нибудь фигню,
[42:47.620 --> 42:49.620]  типа copy равно там,
[42:49.620 --> 42:52.620]  copy fn фигурной скобки, ну присвоить.
[42:54.620 --> 42:59.620]  Сейчас ни в каком случае у нас не будет конфликта с каким-то,
[42:59.620 --> 43:01.620]  то есть с std-шным копией,
[43:01.620 --> 43:05.620]  и у нас при этом он не будет судать на аргументы и...
[43:05.620 --> 43:06.620]  Да.
[43:06.620 --> 43:09.620]  Мы полностью подавили адель, ничего не будет.
[43:10.620 --> 43:13.620]  Как бы теперь, когда мы...
[43:13.620 --> 43:15.620]  А, да, еще есть вот такой вариант.
[43:15.620 --> 43:17.620]  Потом будет вроде пример.
[43:17.620 --> 43:18.620]  Да.
[43:18.620 --> 43:23.620]  Ну если вам нужен объект, у которого оператор круглые скобки определен.
[43:23.620 --> 43:25.620]  Как такой объект получить?
[43:25.620 --> 43:27.620]  Лямбда.
[43:27.620 --> 43:29.620]  А вот то же самое.
[43:29.620 --> 43:31.620]  Просто тут синтаксис уже такой,
[43:31.620 --> 43:34.620]  типа интересный что-то, квадратные скобки, потом треугольные,
[43:34.620 --> 43:36.620]  потом requires, еще и еще.
[43:36.620 --> 43:37.620]  Да.
[43:37.620 --> 43:39.620]  То есть тут авто пришлось написать.
[43:39.620 --> 43:42.620]  Ну это там, может, некоторые проблемы возникнуть, но...
[43:42.620 --> 43:45.620]  А лямбда разве можно явно чтобы на параметрах указать?
[43:45.620 --> 43:46.620]  Да.
[43:46.620 --> 43:47.620]  С двадцатых плюсов можно.
[43:47.620 --> 43:49.620]  Если вы не знали, знакомьтесь.
[43:49.620 --> 43:52.620]  С двадцатых плюсов в лямбдах есть еще и треугольные скобки.
[43:52.620 --> 43:54.620]  Не-не-не, я вам указываю, при вызове.
[43:54.620 --> 43:55.620]  При вызове нельзя.
[43:55.620 --> 43:56.620]  И это нормально.
[43:56.620 --> 43:57.620]  И это нормально.
[43:57.620 --> 43:58.620]  И всем без разницы.
[43:58.620 --> 44:00.620]  Нет, нормально, но если я...
[44:02.620 --> 44:06.620]  А, ну я же все равно не могу, скобки тоже.
[44:10.620 --> 44:13.620]  Так, что-то мы...
[44:13.620 --> 44:15.620]  Сколько же времени-то?
[44:15.620 --> 44:16.620]  А, мы час.
[44:16.620 --> 44:20.620]  У нас еще полчаса, чтобы добить часть пронеблойды.
[44:20.620 --> 44:21.620]  Идем нормально.
[44:21.620 --> 44:24.620]  Даже раньше, надеюсь, успеем закончить.
[44:24.620 --> 44:25.620]  Окей.
[44:25.620 --> 44:27.620]  Можно так, можно так.
[44:27.620 --> 44:29.620]  Я дальше буду всегда лямбду писать.
[44:29.620 --> 44:32.620]  Неблойд — это функтор, который включает объекты.
[44:32.620 --> 44:33.620]  Да, это глобальный объект.
[44:33.620 --> 44:37.620]  Ну сейчас там будет мораль в каком-то месте прям четко выписанная,
[44:37.620 --> 44:41.620]  но в целом неблойд — это глобальный объект, который выключает ADL.
[44:41.620 --> 44:43.620]  Который можно вызвать.
[44:43.620 --> 44:45.620]  Глобальный колобл-объект, выключающий ADL.
[44:45.620 --> 44:46.620]  Да.
[44:46.620 --> 44:48.620]  У нас же получается...
[44:48.620 --> 44:51.620]  Мы написали копию с круглыми скобками.
[44:51.620 --> 44:54.620]  И он пойдет искать, что это за копия такая.
[44:54.620 --> 44:57.620]  Он найдет наш неблойд.
[44:57.620 --> 44:59.620]  А если это он может найти при этом?
[44:59.620 --> 45:00.620]  Чего?
[45:02.620 --> 45:05.620]  Если честно, я не помню деталей процедуры.
[45:05.620 --> 45:08.620]  Я решил вас не перегружать этим.
[45:08.620 --> 45:11.620]  В целом тут очень много деталей опущено.
[45:11.620 --> 45:14.620]  Потому что всякие там еще noexcept нужно написать на копии.
[45:14.620 --> 45:17.620]  Куча концептов всяких навесить.
[45:17.620 --> 45:19.620]  Еще там всякие inline namespaces.
[45:19.620 --> 45:20.620]  Ну в общем...
[45:20.620 --> 45:23.620]  Кстати, вот эта копия Fn очень похожа на лямбду.
[45:23.620 --> 45:26.620]  Это просто классик с единственным убиратором круглые скобки.
[45:26.620 --> 45:27.620]  Ну да, да.
[45:27.620 --> 45:29.620]  Поэтому и можно лямбду изменить с одной оговоркой,
[45:29.620 --> 45:31.620]  которая будет потом, а может и не будет.
[45:31.620 --> 45:35.620]  Просто мы назвали точно так, как называется функция.
[45:35.620 --> 45:37.620]  Да, и насколько я помню,
[45:37.620 --> 45:41.620]  всегда, если у вас есть выбор между функцией и объектом,
[45:41.620 --> 45:43.620]  выбирается объект.
[45:43.620 --> 45:45.620]  Просто всегда, по-моему, так.
[45:45.620 --> 45:48.620]  Поправьте мне, если кто-то знает точнее.
[45:48.620 --> 45:52.620]  Андрей, всегда ли при конфликте имени между функцией и объектом
[45:52.620 --> 45:54.620]  выбирается объект?
[45:54.620 --> 45:55.620]  Сейчас.
[45:55.620 --> 45:57.620]  Просто там так вроде говоришь, что ADL...
[45:57.620 --> 45:59.620]  Вот ты сказал, что ADL отключается,
[45:59.620 --> 46:02.620]  если при рукаве будет найдено хотя бы что-то из этого...
[46:02.620 --> 46:05.620]  Да, но в целом, если без ADL смотреть,
[46:05.620 --> 46:08.620]  когда у нас...
[46:08.620 --> 46:10.620]  А, без ADL так не пол...
[46:10.620 --> 46:11.620]  Ну вот у нас там...
[46:11.620 --> 46:14.620]  Мы идем по родительским namespace в поисках имени.
[46:14.620 --> 46:17.620]  Если мы найдем хотя бы одного из запретного списка,
[46:17.620 --> 46:18.620]  то ADL...
[46:18.620 --> 46:19.620]  А, окей.
[46:19.620 --> 46:21.620]  Короче, такой ситуации вообще не может же возникнуть,
[46:21.620 --> 46:23.620]  если мы про ADL не говорим.
[46:23.620 --> 46:26.620]  Что у тебя и функция в кандидатах, и объект.
[46:26.620 --> 46:28.620]  Вот, типа если мы говорим про ADL,
[46:28.620 --> 46:30.620]  значит мы объекты уже не нашли,
[46:30.620 --> 46:32.620]  потому что ADL начинается в том, как объекта нет.
[46:32.620 --> 46:35.620]  Да, но, короче, в одном namespace нельзя определить
[46:35.620 --> 46:37.620]  и функцию объекта с одинаковым именем.
[46:37.620 --> 46:39.620]  Правда? Правда.
[46:39.620 --> 46:41.620]  Когда мы в разных родительских namespace'ах
[46:41.620 --> 46:44.620]  объявляли одинаковые имена функции объектов,
[46:44.620 --> 46:46.620]  то мы просто до первого имени дойдем,
[46:46.620 --> 46:49.620]  неважно, функция ты или объект, ты его выберем.
[46:49.620 --> 46:51.620]  То есть тут просто такой ситуации без ADL,
[46:51.620 --> 46:54.620]  чтобы был выбор объектов или функций,
[46:54.620 --> 46:56.620]  его, кажется, не бывает.
[46:56.620 --> 46:58.620]  Поэтому все нормально.
[46:58.620 --> 47:00.620]  Вот, ну вот мы добились чего хотели.
[47:00.620 --> 47:03.620]  У нас и так вызовется оператор круглой скобки, и так.
[47:03.620 --> 47:05.620]  И хоть тушкой, хоть чучелом,
[47:05.620 --> 47:07.620]  всегда будет то, что надо вызываться.
[47:07.620 --> 47:09.620]  Оператор круглой скобки у нашего копии fn,
[47:09.620 --> 47:12.620]  где нормальная реализация нашего нового классного копии
[47:12.620 --> 47:14.620]  с дополнительным функционалом.
[47:15.620 --> 47:17.620]  Окей.
[47:17.620 --> 47:20.620]  Кажется, мы узнали, что такое случайный ADL,
[47:20.620 --> 47:22.620]  что он таки бывает в жизни иногда,
[47:22.620 --> 47:24.620]  и как его подавлять и чинить.
[47:25.620 --> 47:27.620]  По существованию ADL мы имели в виду,
[47:27.620 --> 47:30.620]  что под оператором можно кастоваться как структура.
[47:30.620 --> 47:34.620]  Очень сложно предсказать, что найдет ADL.
[47:34.620 --> 47:36.620]  То есть первый раз с ним встречаешься,
[47:36.620 --> 47:38.620]  кажется, что он всегда найдет то, что нужно.
[47:38.620 --> 47:41.620]  По факту ADL может найти какую-то лютую фигню,
[47:41.620 --> 47:43.620]  причем в разных ситуациях разную,
[47:43.620 --> 47:45.620]  и вот все как-то вот...
[47:45.620 --> 47:48.620]  В общем, незащищенный ADL это опасно.
[47:50.620 --> 47:55.620]  Есть еще две проблемы,
[47:55.620 --> 47:59.620]  которые были с swap'ом.
[47:59.620 --> 48:01.620]  Вот я сейчас про копии тут рассказывал,
[48:01.620 --> 48:04.620]  и вот там был случайный ADL.
[48:04.620 --> 48:07.620]  Копии – это не кастомизируемая штука.
[48:07.620 --> 48:10.620]  Вот копии, как и другие там всякие transform
[48:10.620 --> 48:12.620]  и прочие алгоритмы в ranges,
[48:12.620 --> 48:15.620]  их нельзя кастомизировать, потому что а вам зачем?
[48:15.620 --> 48:17.620]  Пусть вендоры библиотек кастомизируют,
[48:17.620 --> 48:19.620]  основываясь на концептах.
[48:19.620 --> 48:21.620]  То есть копии для contiguous контейнеров,
[48:21.620 --> 48:23.620]  вам понятно, что можно быстрее написать,
[48:23.620 --> 48:25.620]  чем понятно.
[48:25.620 --> 48:27.620]  Вот, нам говорят нельзя,
[48:27.620 --> 48:29.620]  а вендорам говорят можно.
[48:29.620 --> 48:31.620]  Ну вот есть swap.
[48:31.620 --> 48:33.620]  Это кастомизируемая штука,
[48:33.620 --> 48:37.620]  и мы научились как бы чинить случайный ADL,
[48:37.620 --> 48:40.620]  который со swap'ом тоже может быть, в принципе.
[48:40.620 --> 48:43.620]  Но еще надо избавиться от кладунских заклинаний.
[48:45.620 --> 48:47.620]  Поехали.
[48:47.620 --> 48:49.620]  Swap будет выглядеть как-то так.
[48:49.620 --> 48:51.620]  Тут какой-то код.
[48:51.620 --> 48:53.620]  Ну мы что хотим?
[48:53.620 --> 48:57.620]  Вот чтобы, наверное, вот это кладунское заклинание с ADL'ем,
[48:57.620 --> 49:00.620]  using std swap и swap unqualified,
[49:00.620 --> 49:02.620]  просто его сюда вписать.
[49:02.620 --> 49:04.620]  Как вам идея?
[49:04.620 --> 49:06.620]  Давайте так и сделаем.
[49:06.620 --> 49:09.620]  Да, внимание, все в namespace ranges происходит.
[49:09.620 --> 49:11.620]  То есть это не старый swap чинят,
[49:11.620 --> 49:13.620]  старый swap останется сломанным,
[49:13.620 --> 49:15.620]  а добавляют новый swap.
[49:17.620 --> 49:18.620]  Вот.
[49:18.620 --> 49:20.620]  Что это за концепт?
[49:20.620 --> 49:23.620]  Ну в нем написана ровно вот эта строчка.
[49:24.620 --> 49:26.620]  Вот swap fst с nd.
[49:26.620 --> 49:29.620]  То есть это просто концепт, который проверяет,
[49:29.620 --> 49:31.620]  что unqualified lookup
[49:31.620 --> 49:33.620]  находит какой-то swap
[49:33.620 --> 49:35.620]  для наших аргументов типа t.
[49:35.620 --> 49:37.620]  Вот все.
[49:37.620 --> 49:39.620]  Ну то есть как бы по сути здесь написано,
[49:39.620 --> 49:41.620]  если вот этот код компилируется,
[49:41.620 --> 49:43.620]  вот этот код используй.
[49:43.620 --> 49:45.620]  Иначе используй std swap.
[49:45.620 --> 49:46.620]  Все.
[49:48.620 --> 49:51.620]  То есть теперь колоннуство с using std swap.
[49:51.620 --> 49:52.620]  Не нужно.
[49:52.620 --> 49:55.620]  Делаешь std ranges swap и все работает.
[49:58.620 --> 50:00.620]  Не понятно, как бы воспользоваться.
[50:00.620 --> 50:02.620]  Да, оно просто затолкано под ковер,
[50:02.620 --> 50:04.620]  но под ковром все еще гниль,
[50:04.620 --> 50:06.620]  и какие-то вот кишки тут лютые.
[50:06.620 --> 50:08.620]  Понятно, зачем ranges.
[50:08.620 --> 50:09.620]  Что?
[50:09.620 --> 50:12.620]  Если я использую swap, не понятно, зачем ranges.
[50:12.620 --> 50:14.620]  Если я два in task swap.
[50:14.620 --> 50:16.620]  Ну если ты два in task swap,
[50:16.620 --> 50:18.620]  то тебе, да, ничего не нужно.
[50:18.620 --> 50:20.620]  Вся эта колдунская магия нужна,
[50:20.620 --> 50:22.620]  когда мы пишем обобщенный код.
[50:22.620 --> 50:24.620]  Когда вы пишете, например,
[50:24.620 --> 50:26.620]  свой другой алгоритм для ranges.
[50:26.620 --> 50:28.620]  Вот новый алгоритм какой-то решили
[50:28.620 --> 50:30.620]  разработать на основе ranges.
[50:30.620 --> 50:32.620]  И вам там посвопать что-то понадобилось.
[50:32.620 --> 50:34.620]  Будьте добры, используйте ranges swap,
[50:34.620 --> 50:36.620]  чтобы все кастомизации работали
[50:36.620 --> 50:38.620]  и все у вас было хорошо.
[50:38.620 --> 50:39.620]  Да.
[50:39.620 --> 50:43.620]  То, что реально будет еще такое написано
[50:43.620 --> 50:45.620]  в стандартной библиотеке,
[50:45.620 --> 50:47.620]  это стандартно гарантируется?
[50:47.620 --> 50:48.620]  Да.
[50:48.620 --> 50:50.620]  Странными словами, но гарантируется.
[50:50.620 --> 50:52.620]  Ну мы сейчас посмотрим, я надеюсь,
[50:52.620 --> 50:54.620]  на код стандартной библиотеки.
[50:54.620 --> 50:56.620]  Потому что открыть,
[50:56.620 --> 50:58.620]  CTRL-кликнуть по STD ranges swap,
[50:58.620 --> 50:59.620]  вы все можете.
[50:59.620 --> 51:01.620]  То, что вы там увидите, понять
[51:01.620 --> 51:03.620]  с первого раза невозможно.
[51:03.620 --> 51:05.620]  Нужно идти читать сопровождающие бумаги,
[51:05.620 --> 51:07.620]  где написано, почему так,
[51:07.620 --> 51:09.620]  как я этитирую более-менее.
[51:09.620 --> 51:11.620]  Надеюсь, после этой лекции вы сможете CTRL-кликнуть
[51:11.620 --> 51:13.620]  по функциям из ranges и понимать,
[51:13.620 --> 51:15.620]  что происходит там в целом.
[51:15.620 --> 51:17.620]  Окей.
[51:17.620 --> 51:19.620]  Ну то есть это в принципе все,
[51:19.620 --> 51:21.620]  на самом-то деле.
[51:21.620 --> 51:23.620]  Есть один нюанс и одна историческая справка,
[51:23.620 --> 51:25.620]  которая нам необходима.
[51:25.620 --> 51:27.620]  Если вы сами так напишете,
[51:27.620 --> 51:29.620]  как я сейчас тут упрощенным бахнул,
[51:29.620 --> 51:31.620]  будут проблемы.
[51:31.620 --> 51:33.620]  Нужно еще чуть-чуть подкрутить.
[51:33.620 --> 51:35.620]  Вот это чуть-чуть, оно такое нудно и скучно,
[51:35.620 --> 51:37.620]  но мне кажется...
[51:37.620 --> 51:39.620]  Куда? Куда battery low?
[51:43.620 --> 51:45.620]  Так, это опасно, если...
[51:49.620 --> 51:51.620]  Я, кажется, только что оглушил
[51:51.620 --> 51:53.620]  всех, кто слушал на ютубе.
[51:53.620 --> 51:55.620]  Это допустимые потери.
[51:57.620 --> 51:59.620]  Ну да, что они нам?
[52:05.620 --> 52:07.620]  Ладно, давайте добьем до конца.
[52:07.620 --> 52:09.620]  Тут чуть-чуть осталось про неблоида
[52:09.620 --> 52:11.620]  и прочее.
[52:11.620 --> 52:13.620]  И тогда уже буду пытаться зарядку сделать,
[52:13.620 --> 52:15.620]  чтобы работало.
[52:15.620 --> 52:17.620]  Должно хватить пока.
[52:17.620 --> 52:19.620]  Итак, есть, как говорится,
[52:19.620 --> 52:21.620]  один нюанс.
[52:21.620 --> 52:23.620]  Чуть более полная версия
[52:23.620 --> 52:25.620]  вот этой вот штуки.
[52:25.620 --> 52:27.620]  А, вот эта штука называется
[52:27.620 --> 52:29.620]  точка кастомизации, кстати.
[52:29.620 --> 52:31.620]  Та самая, которая там уже упоминала
[52:31.620 --> 52:33.620]  несколько раз.
[52:33.620 --> 52:35.620]  Вот неблоид он только подавлял ADL,
[52:35.620 --> 52:37.620]  а точка кастомизации
[52:37.620 --> 52:39.620]  она еще и
[52:39.620 --> 52:41.620]  в своих корыстных целях под капотом
[52:41.620 --> 52:43.620]  использует ADL, чтобы пользователь мог
[52:43.620 --> 52:45.620]  кастомизировать.
[52:45.620 --> 52:47.620]  Ну, почему точка кастомизации обязана быть
[52:47.620 --> 52:49.620]  неблоидом? Кажется, вам должно быть
[52:49.620 --> 52:51.620]  очевидно.
[52:51.620 --> 52:53.620]  Надо сначала побороть ADL, чтобы потом
[52:53.620 --> 52:55.620]  его использовать в своих целях, и без этого
[52:55.620 --> 52:57.620]  не работает, в общем.
[52:57.620 --> 52:59.620]  Там очень одновременно все придумали,
[52:59.620 --> 53:01.620]  поэтому нету какой-то строгой линии подводки,
[53:01.620 --> 53:03.620]  как они иначе.
[53:03.620 --> 53:05.620]  Тут есть проблема.
[53:05.620 --> 53:07.620]  Не очевидная.
[53:07.620 --> 53:09.620]  Если вы внимательно следили
[53:09.620 --> 53:11.620]  за слайдами, вы ее можете сразу увидеть.
[53:11.620 --> 53:13.620]  Но это невозможно, в принципе.
[53:13.620 --> 53:15.620]  Тут я добавил
[53:15.620 --> 53:17.620]  std ranges, раньше просто namespace ranges
[53:17.620 --> 53:19.620]  писал, теперь std ranges.
[53:19.620 --> 53:21.620]  Вписал явно, что тут есть
[53:21.620 --> 53:23.620]  requires ADL find swap.
[53:23.620 --> 53:25.620]  Ну, или,
[53:25.620 --> 53:27.620]  внимание, или,
[53:27.620 --> 53:29.620]  работает просто std swap.
[53:29.620 --> 53:31.620]  Ну, что это значит, что там
[53:31.620 --> 53:33.620]  move assignable и
[53:33.620 --> 53:35.620]  move в констракте был?
[53:37.620 --> 53:39.620]  Никак, там нету
[53:39.620 --> 53:41.620]  семантических требований.
[53:41.620 --> 53:43.620]  Это не стандартный концепт,
[53:43.620 --> 53:45.620]  его стандарт не требует,
[53:45.620 --> 53:47.620]  стандарт другим языком это описывает.
[53:51.620 --> 53:53.620]  Тихо, тихо.
[53:53.620 --> 53:55.620]  Концепт swap был, понятно,
[53:55.620 --> 53:57.620]  что есть, дойдем до него, не рассказывай,
[53:57.620 --> 53:59.620]  что с ним.
[53:59.620 --> 54:01.620]  Тихо.
[54:01.620 --> 54:03.620]  Нет, никаких там семантических требований нет.
[54:03.620 --> 54:05.620]  Вот в этом ADL find swap просто написано,
[54:05.620 --> 54:07.620]  requires вот такой код,
[54:07.620 --> 54:09.620]  все, ничего сложного,
[54:09.620 --> 54:11.620]  я там даже на какой-то слайд вставил его.
[54:11.620 --> 54:13.620]  Где бага?
[54:13.620 --> 54:15.620]  Вот в этом коде.
[54:15.620 --> 54:17.620]  Вот в этом коде.
[54:17.620 --> 54:19.620]  Где она?
[54:19.620 --> 54:21.620]  Какие-то тут рассуждения умные,
[54:21.620 --> 54:23.620]  а вот самое очевидное,
[54:23.620 --> 54:25.620]  тут не пофикшено.
[54:25.620 --> 54:27.620]  Совсем очевидно.
[54:27.620 --> 54:29.620]  Рекурсии...
[54:29.620 --> 54:31.620]  Какой-нибудь ADL find swap
[54:31.620 --> 54:33.620]  он находит вот этот swap, который он ставит справа.
[54:37.620 --> 54:39.620]  Кажется,
[54:39.620 --> 54:41.620]  кажется, не должно быть.
[54:41.620 --> 54:43.620]  Вообще,
[54:43.620 --> 54:45.620]  по этим соображениям, кстати,
[54:45.620 --> 54:47.620]  вот так в стандартной библиотеке не написано.
[54:47.620 --> 54:49.620]  Написана отдельно структура,
[54:49.620 --> 54:51.620]  отдельно под структурой
[54:51.620 --> 54:53.620]  объект. Я здесь
[54:53.620 --> 54:55.620]  для краткости так написал. Давайте представим,
[54:55.620 --> 54:57.620]  что вот этот swap точно не найдется.
[54:57.620 --> 54:59.620]  А может какой-то другой
[54:59.620 --> 55:01.620]  найти?
[55:01.620 --> 55:03.620]  Где?
[55:03.620 --> 55:05.620]  Где найдется
[55:05.620 --> 55:07.620]  STD swap?
[55:07.620 --> 55:09.620]  Последняя строча?
[55:09.620 --> 55:11.620]  Последняя? Ну вот явно его написали.
[55:11.620 --> 55:13.620]  Может не
[55:13.620 --> 55:15.620]  найти?
[55:15.620 --> 55:17.620]  Стд swap полностью.
[55:17.620 --> 55:19.620]  Может
[55:19.620 --> 55:21.620]  найти в первом? Да.
[55:21.620 --> 55:23.620]  Возможно, это была просто
[55:23.620 --> 55:25.620]  тык в пальцем небом, но
[55:25.620 --> 55:27.620]  почему?
[55:27.620 --> 55:29.620]  Почему просто он квалифает...
[55:29.620 --> 55:31.620]  Да, мы вложены в STD.
[55:31.620 --> 55:33.620]  Поэтому вот эта штука, в принципе, всегда найдет
[55:33.620 --> 55:35.620]  кандидата
[55:35.620 --> 55:37.620]  STD swap.
[55:37.620 --> 55:39.620]  Окей.
[55:39.620 --> 55:41.620]  То есть что это значит?
[55:41.620 --> 55:43.620]  Внутри
[55:43.620 --> 55:45.620]  концепта ADL find swap
[55:45.620 --> 55:47.620]  у нас всегда...
[55:47.620 --> 55:49.620]  Внутри концепта
[55:49.620 --> 55:51.620]  ADL find swap мы всегда
[55:51.620 --> 55:53.620]  на самом деле найдем, вот в
[55:53.620 --> 55:55.620]  таком же коде, найдем
[55:55.620 --> 55:57.620]  STD swap. А STD swap
[55:57.620 --> 55:59.620]  до
[55:59.620 --> 56:01.620]  какой-то версии плюсов не был
[56:01.620 --> 56:03.620]  constrained. Что мне дальше...
[56:03.620 --> 56:05.620]  Так, ладно.
[56:05.620 --> 56:07.620]  Чуть-чуть не в том порядке.
[56:07.620 --> 56:09.620]  Он до сих пор не constrained, только
[56:09.620 --> 56:11.620]  там только mandate, по-моему, к нему написано.
[56:11.620 --> 56:13.620]  Ой.
[56:13.620 --> 56:15.620]  По-моему...
[56:15.620 --> 56:17.620]  Давайте еще одну.
[56:17.620 --> 56:19.620]  Проблема может вот так STD swap
[56:19.620 --> 56:21.620]  найти. Как ее пофиксить?
[56:21.620 --> 56:23.620]  Просто
[56:23.620 --> 56:25.620]  это странно, да? Пока вот без мотивации
[56:25.620 --> 56:27.620]  странно, что у нас ADL find swap
[56:27.620 --> 56:29.620]  и вот здесь может найти не ADL
[56:29.620 --> 56:31.620]  swap, а STD swap. Как это тупо пофиксить?
[56:33.620 --> 56:35.620]  Вот максимально тупо.
[56:35.620 --> 56:37.620]  Создать отдельные
[56:37.620 --> 56:39.620]  сферы, которые не можем... Да.
[56:39.620 --> 56:41.620]  Да.
[56:41.620 --> 56:43.620]  Вот, вот. Все правильно ответ.
[56:43.620 --> 56:45.620]  Берем и делаем, и это все фиксит.
[56:45.620 --> 56:47.620]  Еще одна проблема,
[56:47.620 --> 56:49.620]  которая уже совсем не очевидная.
[56:49.620 --> 56:51.620]  Ну, может, ладно.
[56:51.620 --> 56:53.620]  Сейчас много раз про это все проговаривала, оно все
[56:53.620 --> 56:55.620]  однообразное достаточно.
[56:55.620 --> 56:57.620]  Опять подсказка. В этом месте проблема.
[56:57.620 --> 56:59.620]  Что еще может здесь
[56:59.620 --> 57:01.620]  найти? Вот если мы все это в другой name space
[57:01.620 --> 57:03.620]  передвинули, совсем отдельный,
[57:03.620 --> 57:05.620]  и там
[57:05.620 --> 57:07.620]  в родительском swap нет, может
[57:07.620 --> 57:09.620]  что-то...
[57:09.620 --> 57:11.620]  Что?
[57:11.620 --> 57:13.620]  Нет, видно.
[57:13.620 --> 57:15.620]  Тут квалифует, полностью квалифует.
[57:15.620 --> 57:17.620]  Да, квалифует.
[57:17.620 --> 57:19.620]  Сейчас, а как мы побороли предыдущую проблему?
[57:19.620 --> 57:21.620]  Да, там не видно STD swap. Это совсем другой name space,
[57:21.620 --> 57:23.620]  не вложенный в STD. Два нижних подчеркивания
[57:23.620 --> 57:25.620]  STD. Может, что-то еще может быть
[57:25.620 --> 57:27.620]  написано в этом отдельном name space,
[57:27.620 --> 57:29.620]  в котором вы видели? Или там вот буквально
[57:29.620 --> 57:31.620]  открыт name space, в нем написано...
[57:31.620 --> 57:33.620]  Да, давай вот так.
[57:33.620 --> 57:35.620]  Просто буквально открыт, и больше ничего.
[57:35.620 --> 57:37.620]  Если face space
[57:37.620 --> 57:39.620]  SD, у нас
[57:39.620 --> 57:41.620]  в STD лежат.
[57:41.620 --> 57:43.620]  Вот.
[57:43.620 --> 57:45.620]  ADL может найти STD swap
[57:45.620 --> 57:47.620]  внезапно.
[57:47.620 --> 57:49.620]  Да, вот здесь. Мы ожидаем,
[57:49.620 --> 57:51.620]  что у нас STD swap только тут вызовется.
[57:51.620 --> 57:53.620]  А он на самом деле и в первой ветке может вызваться,
[57:53.620 --> 57:55.620]  и главное вот в этом концепте
[57:55.620 --> 57:57.620]  для любого класса
[57:57.620 --> 57:59.620]  из STD, мы найдем
[57:59.620 --> 58:01.620]  STD swap. По ADL.
[58:01.620 --> 58:03.620]  Чего мы и хотели, в принципе.
[58:03.620 --> 58:05.620]  Почему это плохо?
[58:05.620 --> 58:07.620]  Вот, понятный слайд.
[58:07.620 --> 58:09.620]  Docity++17 было вот так.
[58:11.620 --> 58:13.620]  Просто понятный обычный swap.
[58:13.620 --> 58:15.620]  После
[58:15.620 --> 58:17.620]  C++17 стало так.
[58:17.620 --> 58:19.620]  Но requires добавился,
[58:19.620 --> 58:21.620]  видите, да? То есть теперь, если у вас
[58:21.620 --> 58:23.620]  мува какого-то не хватает,
[58:23.620 --> 58:25.620]  попытка вызвать
[58:25.620 --> 58:27.620]  такой swap, она там выдаст вам
[58:27.620 --> 58:29.620]  ошибку. Причем свиная
[58:29.620 --> 58:31.620]  как бы ошибку, да?
[58:31.620 --> 58:33.620]  А вот такая как бы вызовет ошибку,
[58:33.620 --> 58:35.620]  выведет ошибку только когда вы уже
[58:35.620 --> 58:37.620]  в тело функции пойдете, и в теле функции
[58:37.620 --> 58:39.620]  обнаружите, что, ой, все сломано.
[58:39.620 --> 58:41.620]  Внутри
[58:41.620 --> 58:43.620]  этого концепта у нас
[58:43.620 --> 58:45.620]  написан вот такой код.
[58:45.620 --> 58:47.620]  Если он нашел STD swap
[58:47.620 --> 58:49.620]  до 17-х плюсов,
[58:49.620 --> 58:51.620]  он unconstrained.
[58:51.620 --> 58:53.620]  Вот этого
[58:53.620 --> 58:55.620]  requires нету.
[58:55.620 --> 58:57.620]  А это значит что?
[58:57.620 --> 58:59.620]  Что концепт всегда скажет true.
[58:59.620 --> 59:01.620]  Потому что просто вызов
[59:01.620 --> 59:03.620]  скомпилируется, да.
[59:03.620 --> 59:05.620]  Это правда.
[59:05.620 --> 59:07.620]  Это правда.
[59:07.620 --> 59:09.620]  Ну, RNG изначально планировали
[59:09.620 --> 59:11.620]  и раньше 20-х плюсов добавить,
[59:11.620 --> 59:13.620]  и, в принципе, первоначальные
[59:13.620 --> 59:15.620]  пропозалы базировались на
[59:15.620 --> 59:17.620]  C++14,
[59:17.620 --> 59:19.620]  где вот этого не было.
[59:19.620 --> 59:21.620]  Ну, то есть
[59:21.620 --> 59:23.620]  в C++17 добавили словами требования,
[59:23.620 --> 59:25.620]  с C++20 оно там как бы как requires
[59:25.620 --> 59:27.620]  появилось нормально, вроде как.
[59:27.620 --> 59:29.620]  То есть,
[59:29.620 --> 59:31.620]  то есть,
[59:31.620 --> 59:33.620]  вот этот вот
[59:33.620 --> 59:35.620]  requires весь, он бы говорил true
[59:35.620 --> 59:37.620]  на любые вещи из STD.
[59:37.620 --> 59:39.620]  Вам не кажется это странным?
[59:39.620 --> 59:41.620]  Ну, вы поняли,
[59:41.620 --> 59:43.620]  почему это происходит, да?
[59:43.620 --> 59:45.620]  По ADL нашли, либо в родительском
[59:45.620 --> 59:47.620]  namespace нашли. Ну, родительские по фикселя,
[59:47.620 --> 59:49.620]  а по ADL все равно найдем.
[59:49.620 --> 59:51.620]  Найдем, будет true.
[59:51.620 --> 59:53.620]  И мы пойдем компилировать
[59:53.620 --> 59:55.620]  код. Сюда пойдем, куда-нибудь внутрь,
[59:55.620 --> 59:57.620]  провалимся в какую-нибудь
[59:57.620 --> 59:59.620]  имплементацию, и там
[59:59.620 --> 01:00:01.620]  вылетит ошибка. Нельзя
[01:00:01.620 --> 01:00:03.620]  присвоить авто
[01:00:03.620 --> 01:00:05.620]  два нижних подчеркивания,
[01:00:05.620 --> 01:00:07.620]  tmp02.
[01:00:07.620 --> 01:00:09.620]  Ну, вот это вот.
[01:00:09.620 --> 01:00:11.620]  Ну, очередная ошибка сразу в конец
[01:00:11.620 --> 01:00:13.620]  будет проблемой.
[01:00:13.620 --> 01:00:15.620]  Ну, это как бы то, что концепты
[01:00:15.620 --> 01:00:17.620]  призваны были полечить, правда ведь?
[01:00:17.620 --> 01:00:19.620]  Да, что у вас ошибки
[01:00:19.620 --> 01:00:21.620]  не читаемые, где-то там в кишках стандартной
[01:00:21.620 --> 01:00:23.620]  библиотеки, сквозь 10 вызовов функций,
[01:00:23.620 --> 01:00:25.620]  unable to move assign,
[01:00:25.620 --> 01:00:27.620]  что-то там, что-то там.
[01:00:27.620 --> 01:00:29.620]  Здесь все равно же будет такая ошибка,
[01:00:29.620 --> 01:00:31.620]  но вот у нас, ну, допустим,
[01:00:31.620 --> 01:00:33.620]  зачем-то для stdm-butex
[01:00:33.620 --> 01:00:35.620]  одно вызвание, да?
[01:00:35.620 --> 01:00:37.620]  Да.
[01:00:37.620 --> 01:00:39.620]  А, сейчас, стоп.
[01:00:39.620 --> 01:00:41.620]  Тебе напишут.
[01:00:41.620 --> 01:00:43.620]  Да, тебе напишут,
[01:00:43.620 --> 01:00:45.620]  во-первых, ADL я не нашел,
[01:00:45.620 --> 01:00:47.620]  во-вторых, move
[01:00:47.620 --> 01:00:49.620]  move, да.
[01:00:49.620 --> 01:00:51.620]  Да.
[01:00:51.620 --> 01:00:53.620]  Ну, более того,
[01:00:53.620 --> 01:00:55.620]  тут нужно еще сказать про вот это.
[01:00:55.620 --> 01:00:57.620]  Потому что концепт
[01:00:57.620 --> 01:00:59.620]  стопобалон вот ровно так
[01:00:59.620 --> 01:01:01.620]  определен.
[01:01:01.620 --> 01:01:03.620]  В libc++.
[01:01:03.620 --> 01:01:05.620]  То есть, это концепт
[01:01:05.620 --> 01:01:07.620]  для всех вещей из std
[01:01:07.620 --> 01:01:09.620]  либо будет true.
[01:01:09.620 --> 01:01:11.620]  Это сломанный концепт.
[01:01:11.620 --> 01:01:13.620]  Ага.
[01:01:13.620 --> 01:01:15.620]  То есть, вот такая маленькая проблемка,
[01:01:15.620 --> 01:01:17.620]  она такие последствия имеет жуткие.
[01:01:17.620 --> 01:01:19.620]  Ну, в общем-то ужасно.
[01:01:21.620 --> 01:01:23.620]  Сплошные проблемы.
[01:01:23.620 --> 01:01:25.620]  Поэтому есть всякие пропузлы там,
[01:01:25.620 --> 01:01:27.620]  поменять, заменить,
[01:01:27.620 --> 01:01:29.620]  но это бред.
[01:01:29.620 --> 01:01:31.620]  Такого не должно быть явно.
[01:01:31.620 --> 01:01:33.620]  Я не фикс.
[01:01:33.620 --> 01:01:35.620]  Самому додуматься до этого фикса невозможно.
[01:01:35.620 --> 01:01:37.620]  Решительно.
[01:01:37.620 --> 01:01:39.620]  Я думаю, что многие из вас не знали,
[01:01:39.620 --> 01:01:41.620]  что такой конструкции в языке можно пользоваться.
[01:01:41.620 --> 01:01:43.620]  Вот я точно не знал, пока на всю эту тему не наткнулся.
[01:01:43.620 --> 01:01:45.620]  Видите,
[01:01:45.620 --> 01:01:47.620]  что мы делаем?
[01:01:47.620 --> 01:01:49.620]  Мы объявляем
[01:01:49.620 --> 01:01:51.620]  какую-то функцию swap
[01:01:51.620 --> 01:01:53.620]  с сигнатурой
[01:01:53.620 --> 01:01:55.620]  один в один какой std swap.
[01:01:57.620 --> 01:01:59.620]  И говорим, что
[01:01:59.620 --> 01:02:01.620]  определение
[01:02:01.620 --> 01:02:03.620]  для этого объявления удалено.
[01:02:05.620 --> 01:02:07.620]  Да, мы будем его находить
[01:02:07.620 --> 01:02:09.620]  и в этот момент получать ошибку.
[01:02:11.620 --> 01:02:13.620]  Тут подробно расписано.
[01:02:13.620 --> 01:02:15.620]  Во-первых, в родительском
[01:02:15.620 --> 01:02:17.620]  namespace мы не найдем
[01:02:17.620 --> 01:02:19.620]  std swap, потому что вот эта функция
[01:02:19.620 --> 01:02:21.620]  его зашедует.
[01:02:21.620 --> 01:02:23.620]  Мы идем вверх по namespace вложенным,
[01:02:23.620 --> 01:02:25.620]  пока не найдем первое имя, которое в О.
[01:02:25.620 --> 01:02:27.620]  Вот оно первое имя.
[01:02:27.620 --> 01:02:29.620]  Все. Родительский std swap
[01:02:29.620 --> 01:02:31.620]  выше не найдется.
[01:02:31.620 --> 01:02:33.620]  Есть namespace,
[01:02:33.620 --> 01:02:35.620]  в котором мы сейчас, это ranges.
[01:02:35.620 --> 01:02:37.620]  Есть родительский namespace std.
[01:02:39.620 --> 01:02:41.620]  Еще раз.
[01:02:41.620 --> 01:02:43.620]  Unqualify lookup.
[01:02:45.620 --> 01:02:47.620]  Это объявление
[01:02:47.620 --> 01:02:49.620]  функции.
[01:02:49.620 --> 01:02:51.620]  А это определение.
[01:02:51.620 --> 01:02:53.620]  Вот это определение
[01:02:53.620 --> 01:02:55.620]  до равно.
[01:02:55.620 --> 01:02:57.620]  Это определение функции.
[01:02:57.620 --> 01:02:59.620]  А равно delete
[01:02:59.620 --> 01:03:01.620]  это ее определение.
[01:03:01.620 --> 01:03:03.620]  Да.
[01:03:03.620 --> 01:03:05.620]  Это определение ничем.
[01:03:05.620 --> 01:03:07.620]  Оказывается C++
[01:03:07.620 --> 01:03:09.620]  любую функцию...
[01:03:09.620 --> 01:03:11.620]  Да, определение тем,
[01:03:11.620 --> 01:03:13.620]  что у меня нет тела, меня нельзя вызвать.
[01:03:19.620 --> 01:03:21.620]  Вообще можно
[01:03:21.620 --> 01:03:23.620]  delete definition в cpp-шнике.
[01:03:23.620 --> 01:03:25.620]  Ладно.
[01:03:25.620 --> 01:03:27.620]  Первый пункт мы поняли.
[01:03:27.620 --> 01:03:29.620]  Зашедовали имя
[01:03:29.620 --> 01:03:31.620]  из верхнего namespace, теперь оно не найдется.
[01:03:31.620 --> 01:03:33.620]  Второй пункт про ADL.
[01:03:33.620 --> 01:03:35.620]  При нахождении через ADL
[01:03:35.620 --> 01:03:37.620]  внезапно возникнет ambiguous call.
[01:03:37.620 --> 01:03:39.620]  И там
[01:03:39.620 --> 01:03:41.620]  все будет нормально.
[01:03:43.620 --> 01:03:45.620]  Цитата из бумаги, которая
[01:03:45.620 --> 01:03:47.620]  это предложила.
[01:03:47.620 --> 01:03:49.620]  Я тоже.
[01:03:51.620 --> 01:03:53.620]  Нет, мы не будем разбираться.
[01:03:53.620 --> 01:03:55.620]  Это констатируется как факт.
[01:03:55.620 --> 01:03:57.620]  Вот эта вот шняга, она запрещает
[01:03:57.620 --> 01:03:59.620]  ADL вызывать std swap
[01:03:59.620 --> 01:04:01.620]  с вот такой вот
[01:04:01.620 --> 01:04:03.620]  сигнатурой.
[01:04:07.620 --> 01:04:09.620]  Да, который без requires.
[01:04:09.620 --> 01:04:11.620]  Ну, современный
[01:04:11.620 --> 01:04:13.620]  swap, в нем уже requires есть.
[01:04:13.620 --> 01:04:15.620]  Поэтому оно никак здесь не играет.
[01:04:15.620 --> 01:04:17.620]  Сейчас, то есть, swap с requires
[01:04:17.620 --> 01:04:19.620]  мы не аделить.
[01:04:19.620 --> 01:04:21.620]  Мы его можем вызвать.
[01:04:21.620 --> 01:04:23.620]  Да, его ADL может
[01:04:23.620 --> 01:04:25.620]  найти.
[01:04:25.620 --> 01:04:27.620]  Короче, вот этот костыль изначально нужен был
[01:04:27.620 --> 01:04:29.620]  в момент, когда грезили ranges
[01:04:29.620 --> 01:04:31.620]  протолкнуть и концепты в 17-е плюсы.
[01:04:31.620 --> 01:04:33.620]  Были пока 14-е плюсы.
[01:04:33.620 --> 01:04:35.620]  То есть std swap не было констрейнтов,
[01:04:35.620 --> 01:04:37.620]  были проблемы. Придумали все эти
[01:04:37.620 --> 01:04:39.620]  решения. Но в современном мире
[01:04:39.620 --> 01:04:41.620]  единственная польза от вот этой штуки,
[01:04:41.620 --> 01:04:43.620]  она есть до сих пор в стандартных библиотеках
[01:04:43.620 --> 01:04:45.620]  и даже стандартам требуется, чтобы
[01:04:45.620 --> 01:04:47.620]  точка
[01:04:47.620 --> 01:04:49.620]  кастомизации,
[01:04:49.620 --> 01:04:51.620]  swap,
[01:04:51.620 --> 01:04:53.620]  она делает
[01:04:53.620 --> 01:04:55.620]  argument-dependent lookup для unqualified,
[01:04:55.620 --> 01:04:57.620]  имени swap в контексте, в котором
[01:04:57.620 --> 01:04:59.620]  определено вот такая вот штука и удалена.
[01:04:59.620 --> 01:05:01.620]  Там не argument-dependent говорит, там говорит
[01:05:01.620 --> 01:05:03.620]  просто unqualified в контексте,
[01:05:03.620 --> 01:05:05.620]  в котором есть вот эта вот штука.
[01:05:05.620 --> 01:05:07.620]  Поэтому это еще работает, но это уже не сказано.
[01:05:07.620 --> 01:05:09.620]  Так что если работает, вы догадаетесь сами.
[01:05:09.620 --> 01:05:11.620]  Да, ну вот
[01:05:11.620 --> 01:05:13.620]  в общем современном, вот тут я много текста
[01:05:13.620 --> 01:05:15.620]  написал с объяснением истории, а в современном
[01:05:15.620 --> 01:05:17.620]  стандартной библиотеке
[01:05:17.620 --> 01:05:19.620]  все нужно с одной целью
[01:05:19.620 --> 01:05:21.620]  зашедовать std swap.
[01:05:21.620 --> 01:05:23.620]  По-моему
[01:05:23.620 --> 01:05:25.620]  это зашедует любой.
[01:05:25.620 --> 01:05:27.620]  Вот это зашедует
[01:05:27.620 --> 01:05:29.620]  любой std swap,
[01:05:29.620 --> 01:05:31.620]  но
[01:05:31.620 --> 01:05:33.620]  не подавит
[01:05:33.620 --> 01:05:35.620]  ADL для свопа
[01:05:35.620 --> 01:05:37.620]  с другой сигнатурой, по-моему, вот так.
[01:05:37.620 --> 01:05:39.620]  То есть сейчас если мы напишем
[01:05:39.620 --> 01:05:41.620]  space std ranges,
[01:05:41.620 --> 01:05:43.620]  он вызовет
[01:05:43.620 --> 01:05:45.620]  anyway
[01:05:45.620 --> 01:05:47.620]  вызовет
[01:05:47.620 --> 01:05:49.620]  swap не std-шнум
[01:05:49.620 --> 01:05:51.620]  или как это работает?
[01:05:51.620 --> 01:05:53.620]  Я не понимаю сейчас.
[01:05:53.620 --> 01:05:55.620]  Смотри, вот это нужно
[01:05:55.620 --> 01:05:57.620]  в этом концепте только,
[01:05:57.620 --> 01:05:59.620]  в том месте, где мы ADL find swap,
[01:05:59.620 --> 01:06:01.620]  пишем requires, вот такой своп.
[01:06:01.620 --> 01:06:03.620]  Вот эта вот штука влияет
[01:06:03.620 --> 01:06:05.620]  только на это.
[01:06:05.620 --> 01:06:07.620]  А мы делитим
[01:06:07.620 --> 01:06:09.620]  не swap с requires,
[01:06:09.620 --> 01:06:11.620]  потому что мы находим сейчас
[01:06:11.620 --> 01:06:13.620]  на namespace std ranges
[01:06:13.620 --> 01:06:15.620]  и это не делитит какую-то другую
[01:06:15.620 --> 01:06:17.620]  функцию, это создает
[01:06:17.620 --> 01:06:19.620]  новую функцию, которая удалена.
[01:06:19.620 --> 01:06:21.620]  Да,
[01:06:21.620 --> 01:06:23.620]  это новое объявление
[01:06:23.620 --> 01:06:25.620]  новой функции в namespace
[01:06:25.620 --> 01:06:27.620]  std ranges.
[01:06:27.620 --> 01:06:29.620]  Нет.
[01:06:29.620 --> 01:06:31.620]  Нет.
[01:06:31.620 --> 01:06:33.620]  Нет.
[01:06:33.620 --> 01:06:35.620]  Нет.
[01:06:35.620 --> 01:06:37.620]  Я не понимаю.
[01:06:37.620 --> 01:06:39.620]  И не нужно, мне кажется.
[01:06:39.620 --> 01:06:41.620]  Перевернули.
[01:06:41.620 --> 01:06:43.620]  Попытаться.
[01:06:43.620 --> 01:06:45.620]  Мы объявили
[01:06:45.620 --> 01:06:47.620]  вот такую функцию
[01:06:47.620 --> 01:06:49.620]  с еще интервендацией delete
[01:06:49.620 --> 01:06:51.620]  в своем namespace.
[01:06:51.620 --> 01:06:53.620]  Да, в namespace std ranges.
[01:06:53.620 --> 01:06:55.620]  Мы это сделали для того, чтобы
[01:06:55.620 --> 01:06:57.620]  зашедуить.
[01:06:57.620 --> 01:06:59.620]  ADL пойдет, найдет
[01:06:59.620 --> 01:07:01.620]  этот своп delete и не пойдет дальше.
[01:07:01.620 --> 01:07:03.620]  А
[01:07:03.620 --> 01:07:05.620]  конечная цель всего
[01:07:05.620 --> 01:07:07.620]  этого
[01:07:07.620 --> 01:07:09.620]  вот этот ADL find
[01:07:09.620 --> 01:07:11.620]  своп, он отрабатывает,
[01:07:11.620 --> 01:07:13.620]  когда найдет своп где?
[01:07:13.620 --> 01:07:15.620]  Он вернет true, когда просто
[01:07:15.620 --> 01:07:17.620]  он квалифает lookup,
[01:07:17.620 --> 01:07:19.620]  в текущем контексте найдет своп.
[01:07:19.620 --> 01:07:21.620]  Так он же его найдет
[01:07:21.620 --> 01:07:23.620]  потом.
[01:07:23.620 --> 01:07:25.620]  Этот он найдет, если ничего лучше нету.
[01:07:25.620 --> 01:07:27.620]  Там вот такая логика.
[01:07:27.620 --> 01:07:29.620]  Что?
[01:07:29.620 --> 01:07:31.620]  Что?
[01:07:31.620 --> 01:07:33.620]  Что?
[01:07:33.620 --> 01:07:35.620]  Да.
[01:07:35.620 --> 01:07:37.620]  И поэтому
[01:07:37.620 --> 01:07:39.620]  ADL, по-моему,
[01:07:39.620 --> 01:07:41.620]  отключится,
[01:07:41.620 --> 01:07:43.620]  потому что он отключается,
[01:07:43.620 --> 01:07:45.620]  когда ambiguous call.
[01:07:45.620 --> 01:07:47.620]  Там какая-то жесть, если честно.
[01:07:47.620 --> 01:07:49.620]  В общем и целом
[01:07:49.620 --> 01:07:51.620]  вы очень вряд ли
[01:07:51.620 --> 01:07:53.620]  когда-то с такой ситуацией
[01:07:53.620 --> 01:07:55.620]  столкнетесь.
[01:07:55.620 --> 01:07:57.620]  Все это изначально было задумано
[01:07:57.620 --> 01:07:59.620]  с одной лишь целью.
[01:07:59.620 --> 01:08:01.620]  Полечить вот эту проблему, что у нас своп
[01:08:01.620 --> 01:08:03.620]  без констрейнтов, где у меня слайд.
[01:08:03.620 --> 01:08:05.620]  Вот эту проблему полечить.
[01:08:05.620 --> 01:08:07.620]  В современных стандартных библиотеках
[01:08:07.620 --> 01:08:09.620]  это осталось с одной единственной целью
[01:08:09.620 --> 01:08:11.620]  shadow it. Вам не нужно думать
[01:08:11.620 --> 01:08:13.620]  про вот эту проблему legacy, где у вас есть
[01:08:13.620 --> 01:08:15.620]  старая функция в плохом
[01:08:15.620 --> 01:08:17.620]  namespace,
[01:08:17.620 --> 01:08:19.620]  которая unconстрейнт,
[01:08:19.620 --> 01:08:21.620]  а есть новая функция в хорошем
[01:08:21.620 --> 01:08:23.620]  namespace, у которой там и констрейнты,
[01:08:23.620 --> 01:08:25.620]  и кастомизация, и вам нужно
[01:08:25.620 --> 01:08:27.620]  как-то организовать вот это вот, чтобы
[01:08:27.620 --> 01:08:29.620]  одно-другое... Это невозможно.
[01:08:29.620 --> 01:08:31.620]  Вы в своей практике на такое не натолкнетесь.
[01:08:31.620 --> 01:08:33.620]  Но, если вы ctrl-кликните
[01:08:33.620 --> 01:08:35.620]  по какому-нибудь std-swap,
[01:08:35.620 --> 01:08:37.620]  std-range swap, то вы вот это увидите.
[01:08:37.620 --> 01:08:39.620]  Вот чтобы вас
[01:08:39.620 --> 01:08:41.620]  это не шокировало, я рассказал
[01:08:41.620 --> 01:08:43.620]  примерно откуда это взялось и зачем это нужно.
[01:08:43.620 --> 01:08:45.620]  Теперь мы сможем
[01:08:45.620 --> 01:08:47.620]  вызвать своп
[01:08:47.620 --> 01:08:49.620]  с такой сигнатуры,
[01:08:49.620 --> 01:08:51.620]  в принципе, если на всю
[01:08:51.620 --> 01:08:53.620]  namespace std-range swap.
[01:08:53.620 --> 01:08:55.620]  Да, лукавство
[01:08:55.620 --> 01:08:57.620]  здесь есть. На самом деле
[01:08:57.620 --> 01:08:59.620]  вот эта пара вот этих штук, она заталкнута
[01:08:59.620 --> 01:09:01.620]  еще в более вложенный namespace, чтобы никуда
[01:09:01.620 --> 01:09:03.620]  наружу не торчать.
[01:09:03.620 --> 01:09:05.620]  Давайте скажем, что мы...
[01:09:05.620 --> 01:09:07.620]  Давайте подведем итоги и вот
[01:09:07.620 --> 01:09:09.620]  пойдем посмотрим имплементацию в libc++,
[01:09:09.620 --> 01:09:11.620]  чтобы вот прям четко было.
[01:09:11.620 --> 01:09:13.620]  Так, думаю, будет лучше, чем по этим
[01:09:13.620 --> 01:09:15.620]  слайдам. Тут упрощений очень много.
[01:09:15.620 --> 01:09:17.620]  Итак,
[01:09:17.620 --> 01:09:19.620]  колонутские заклинания мы пофиксили.
[01:09:19.620 --> 01:09:21.620]  Возникли некоторые проблемы.
[01:09:21.620 --> 01:09:23.620]  Не у нас, правда, а у авторов стандартной библиотеки.
[01:09:23.620 --> 01:09:25.620]  Они их там как-то закостыляли и со стандартом
[01:09:25.620 --> 01:09:27.620]  покопировались, все здорово.
[01:09:27.620 --> 01:09:29.620]  Единственная оставшаяся проблема, это то, что
[01:09:29.620 --> 01:09:31.620]  до сих пор мы имена глобально резервируем,
[01:09:31.620 --> 01:09:33.620]  потому что ходим через ADL.
[01:09:33.620 --> 01:09:35.620]  Вот это он квалифает
[01:09:35.620 --> 01:09:37.620]  имя swap в ADL, мы зарезервировали.
[01:09:37.620 --> 01:09:39.620]  В одной из следующих серий
[01:09:39.620 --> 01:09:41.620]  мы попробуем научиться пофиксить ей эту проблему.
[01:09:41.620 --> 01:09:43.620]  Сейчас, то есть мы
[01:09:43.620 --> 01:09:45.620]  можем сделать
[01:09:45.620 --> 01:09:47.620]  условно говоря глобальный объект
[01:09:47.620 --> 01:09:49.620]  как с копия.
[01:09:49.620 --> 01:09:51.620]  Так есть глобальный объект swap.
[01:09:51.620 --> 01:09:53.620]  С этого
[01:09:53.620 --> 01:09:55.620]  началось все.
[01:09:55.620 --> 01:09:57.620]  Точка кастомизации
[01:09:57.620 --> 01:09:59.620]  это всегда не bloat теперь.
[01:09:59.620 --> 01:10:01.620]  Вот если на cpp-референс
[01:10:01.620 --> 01:10:03.620]  увидите написано cpo или
[01:10:03.620 --> 01:10:05.620]  customization point object, это
[01:10:05.620 --> 01:10:07.620]  не bloat.
[01:10:07.620 --> 01:10:09.620]  Swap в range
[01:10:09.620 --> 01:10:11.620]  это переменная.
[01:10:11.620 --> 01:10:13.620]  Это переменная.
[01:10:13.620 --> 01:10:15.620]  Так.
[01:10:15.620 --> 01:10:17.620]  Когда-нибудь мы это возможно
[01:10:17.620 --> 01:10:19.620]  попробуем и учиться фиксить, но не в этот раз.
[01:10:19.620 --> 01:10:21.620]  Давайте подведем
[01:10:21.620 --> 01:10:23.620]  итоги маленькие.
[01:10:23.620 --> 01:10:25.620]  Почему не bloat? Потому что
[01:10:25.620 --> 01:10:27.620]  вот этого парня зовут Эрик Нибблер.
[01:10:27.620 --> 01:10:29.620]  Душераздирающий взгляд.
[01:10:29.620 --> 01:10:31.620]  Почему его
[01:10:31.620 --> 01:10:33.620]  флажки
[01:10:33.620 --> 01:10:35.620]  с титрами поставлены
[01:10:35.620 --> 01:10:37.620]  справа?
[01:10:37.620 --> 01:10:39.620]  Это мода, понимаешь?
[01:10:39.620 --> 01:10:41.620]  Есть такие вещи,
[01:10:41.620 --> 01:10:43.620]  которые люди делают, абсолютно не задумываясь
[01:10:43.620 --> 01:10:45.620]  какой под ними смысл,
[01:10:45.620 --> 01:10:47.620]  просто потому что так принято у всех вокруг.
[01:10:47.620 --> 01:10:49.620]  Давайте не будем осуждать людей за следование
[01:10:49.620 --> 01:10:51.620]  о толпе, потому что все мы тоже так
[01:10:51.620 --> 01:10:53.620]  делаем каждый день.
[01:10:53.620 --> 01:10:55.620]  Честно говоря.
[01:10:55.620 --> 01:10:57.620]  Неважно.
[01:10:57.620 --> 01:10:59.620]  Итак.
[01:10:59.620 --> 01:11:01.620]  Итак, не bloat.
[01:11:01.620 --> 01:11:03.620]  Это
[01:11:03.620 --> 01:11:05.620]  callable constexpr constructable object.
[01:11:05.620 --> 01:11:07.620]  То есть объект
[01:11:07.620 --> 01:11:09.620]  constexpr constructable
[01:11:09.620 --> 01:11:11.620]  чтобы там все работало нормально,
[01:11:11.620 --> 01:11:13.620]  которое можно вызвать.
[01:11:13.620 --> 01:11:15.620]  И по сути это подавлялка ADL.
[01:11:17.620 --> 01:11:19.620]  Customization point object.
[01:11:19.620 --> 01:11:21.620]  Cpo.
[01:11:21.620 --> 01:11:23.620]  Это тоже самое callable constexpr constructable,
[01:11:23.620 --> 01:11:25.620]  customizable
[01:11:25.620 --> 01:11:27.620]  и concept constrained object.
[01:11:27.620 --> 01:11:29.620]  Это цитаты.
[01:11:29.620 --> 01:11:31.620]  Блин, я ссылку не вставил на то, откуда
[01:11:31.620 --> 01:11:33.620]  это цитаты. Ну ладно.
[01:11:33.620 --> 01:11:35.620]  Возможно.
[01:11:35.620 --> 01:11:37.620]  Да, это вот
[01:11:37.620 --> 01:11:39.620]  CCCCCC.
[01:11:39.620 --> 01:11:41.620]  То есть отличие
[01:11:41.620 --> 01:11:43.620]  неблоида Cpo в том,
[01:11:43.620 --> 01:11:45.620]  что
[01:11:45.620 --> 01:11:47.620]  Cpo можно кастомизировать
[01:11:47.620 --> 01:11:49.620]  и еще ожидается, что вы все-таки какие-то
[01:11:49.620 --> 01:11:51.620]  концепты туда нависите.
[01:11:51.620 --> 01:11:53.620]  Потому что иначе там смысла никакого не будет.
[01:11:53.620 --> 01:11:55.620]  В
[01:11:55.620 --> 01:11:57.620]  ranges библиотеке
[01:11:57.620 --> 01:11:59.620]  все алгоритмы это неблоиды.
[01:11:59.620 --> 01:12:01.620]  Там их много.
[01:12:01.620 --> 01:12:03.620]  Референс можете посмотреть.
[01:12:03.620 --> 01:12:05.620]  Либо дождитесь там после следующего раза.
[01:12:05.620 --> 01:12:07.620]  SwapBeginEnd. Стандартные
[01:12:07.620 --> 01:12:09.620]  Cpo. По-моему, еще какие-то
[01:12:09.620 --> 01:12:11.620]  цепости стандартные. Я не помню.
[01:12:11.620 --> 01:12:13.620]  А в
[01:12:13.620 --> 01:12:15.620]  предложении STD execution,
[01:12:15.620 --> 01:12:17.620]  где у нас наконец-то
[01:12:17.620 --> 01:12:19.620]  concurrency появится в плюсах,
[01:12:19.620 --> 01:12:21.620]  этих Cpo вот такая вот гора.
[01:12:21.620 --> 01:12:23.620]  Скоро.
[01:12:23.620 --> 01:12:25.620]  Надо только подождать.
[01:12:25.620 --> 01:12:27.620]  Ну и вот.
[01:12:27.620 --> 01:12:29.620]  Надеюсь, по каким-то осадочным знаниям
[01:12:29.620 --> 01:12:31.620]  вам станет проще жить в мире
[01:12:31.620 --> 01:12:33.620]  Modern C++.
[01:12:33.620 --> 01:12:35.620]  Дальше нас ждет вот это.
[01:12:35.620 --> 01:12:37.620]  Давайте лучше посмотрим
[01:12:37.620 --> 01:12:39.620]  стандартную имплементацию.
[01:12:39.620 --> 01:12:41.620]  Буквально 5 минуточек
[01:12:41.620 --> 01:12:43.620]  перед тем, как пойти на перерыв.
[01:12:43.620 --> 01:12:45.620]  Да, камеру надо чуть-чуть как-то это.
[01:12:45.620 --> 01:12:47.620]  Туда-сюда.
[01:12:47.620 --> 01:12:49.620]  Тыры-пыры.
[01:12:51.620 --> 01:12:53.620]  Мне кланк больше по душе.
[01:13:01.620 --> 01:13:03.620]  Внимание! STD
[01:13:03.620 --> 01:13:05.620]  range swap в
[01:13:05.620 --> 01:13:07.620]  libc++ 12, кажется.
[01:13:07.620 --> 01:13:09.620]  Это
[01:13:09.620 --> 01:13:11.620]  libc++?
[01:13:11.620 --> 01:13:13.620]  Это не libc++.
[01:13:13.620 --> 01:13:15.620]  Это libstd c++.
[01:13:15.620 --> 01:13:17.620]  Ну ладно, а мне и без разницы.
[01:13:17.620 --> 01:13:19.620]  Ну.
[01:13:19.620 --> 01:13:21.620]  Я просто это
[01:13:21.620 --> 01:13:23.620]  разбирал, да. Как же я
[01:13:23.620 --> 01:13:25.620]  напоролся. Ну давайте смотреть.
[01:13:25.620 --> 01:13:27.620]  Тут насколько хорошо вам видно?
[01:13:27.620 --> 01:13:29.620]  Мне кажется, так получше, да?
[01:13:29.620 --> 01:13:31.620]  Ну все, это сразу видно.
[01:13:31.620 --> 01:13:33.620]  Так.
[01:13:33.620 --> 01:13:35.620]  Что?
[01:13:35.620 --> 01:13:37.620]  Где удивление?
[01:13:37.620 --> 01:13:39.620]  Это персанты такие.
[01:13:39.620 --> 01:13:41.620]  Вот это? Да.
[01:13:41.620 --> 01:13:43.620]  Тебе еще кажется,
[01:13:43.620 --> 01:13:45.620]  в тапе этого размера не нравится,
[01:13:45.620 --> 01:13:47.620]  что у тебя...
[01:13:47.620 --> 01:13:49.620]  В libc++ они мешают
[01:13:49.620 --> 01:13:51.620]  в тапе проделы,
[01:13:51.620 --> 01:13:53.620]  и в тапе у них это 8 проделов.
[01:13:53.620 --> 01:13:55.620]  Если у них больше 8...
[01:13:55.620 --> 01:13:57.620]  Тут, я думаю, читать невозможно
[01:13:57.620 --> 01:13:59.620]  код. Ну...
[01:13:59.620 --> 01:14:01.620]  Сейчас, подождите.
[01:14:01.620 --> 01:14:03.620]  Меня одна вещь смущает.
[01:14:09.620 --> 01:14:11.620]  У тебя, по-моему,
[01:14:11.620 --> 01:14:13.620]  с них справа есть
[01:14:13.620 --> 01:14:15.620]  таблиц код.
[01:14:15.620 --> 01:14:17.620]  Кто-нибудь помнит, как называется опция
[01:14:17.620 --> 01:14:19.620]  VS-код, которая вот здесь сверху показывает
[01:14:19.620 --> 01:14:21.620]  заголовочки того,
[01:14:21.620 --> 01:14:23.620]  где я нахожусь?
[01:14:23.620 --> 01:14:25.620]  Мне это сейчас очень нужно будет.
[01:14:25.620 --> 01:14:27.620]  Вот тут где-то это было...
[01:14:31.620 --> 01:14:33.620]  Нет.
[01:14:33.620 --> 01:14:35.620]  Просто сейчас мы запутаемся,
[01:14:35.620 --> 01:14:37.620]  в каком мы нам эспейсе без этого.
[01:14:37.620 --> 01:14:39.620]  Я что-то удивлен, что у меня...
[01:14:39.620 --> 01:14:41.620]  Вот я хочу не вот это вот,
[01:14:41.620 --> 01:14:43.620]  тут тяжело,
[01:14:43.620 --> 01:14:45.620]  а чтобы он на строчках показывал.
[01:14:45.620 --> 01:14:47.620]  Сейчас.
[01:14:47.620 --> 01:14:49.620]  Никто такую фичу не видел, да?
[01:14:49.620 --> 01:14:51.620]  Не помнит?
[01:14:51.620 --> 01:14:53.620]  Очень-очень плохо.
[01:14:59.620 --> 01:15:01.620]  Это, по-моему, стандартная была фича,
[01:15:01.620 --> 01:15:03.620]  и я просто не помню, как она
[01:15:03.620 --> 01:15:05.620]  на строчках показывала.
[01:15:05.620 --> 01:15:07.620]  А вот, вот.
[01:15:07.620 --> 01:15:09.620]  Вот, вот.
[01:15:09.620 --> 01:15:11.620]  Вот, вот.
[01:15:11.620 --> 01:15:13.620]  Вот, вот.
[01:15:13.620 --> 01:15:15.620]  Вот, вот.
[01:15:15.620 --> 01:15:17.620]  Стандартная была фича,
[01:15:17.620 --> 01:15:19.620]  и я просто не помню, как она...
[01:15:19.620 --> 01:15:21.620]  Ладно, будем так.
[01:15:21.620 --> 01:15:23.620]  Будем страдать. Итак,
[01:15:23.620 --> 01:15:25.620]  где находится вот этот вот объект,
[01:15:25.620 --> 01:15:27.620]  к которому мы прилетели,
[01:15:27.620 --> 01:15:29.620]  буквально control-клику
[01:15:29.620 --> 01:15:31.620]  на std ranges swap?
[01:15:31.620 --> 01:15:33.620]  std ranges cast.
[01:15:33.620 --> 01:15:35.620]  Внимание.
[01:15:35.620 --> 01:15:37.620]  Cast — это inline namespace.
[01:15:41.620 --> 01:15:43.620]  Да, вы видели когда-нибудь
[01:15:43.620 --> 01:15:45.620]  что-то?
[01:15:45.620 --> 01:15:47.620]  Ну, вот я их тоже вижу
[01:15:47.620 --> 01:15:49.620]  каждый год, как впервые.
[01:15:49.620 --> 01:15:51.620]  Они не особо важны,
[01:15:51.620 --> 01:15:53.620]  и тут вроде ничего не влияют,
[01:15:53.620 --> 01:15:55.620]  поэтому давайте
[01:15:55.620 --> 01:15:57.620]  откроем на cpp-референс про них.
[01:15:59.620 --> 01:16:01.620]  Inline namespace.
[01:16:01.620 --> 01:16:03.620]  Суть их в том, что просто как будто их нету.
[01:16:03.620 --> 01:16:05.620]  То есть все, что в них, подмешивается наверх.
[01:16:05.620 --> 01:16:07.620]  А что только за их?
[01:16:07.620 --> 01:16:09.620]  Просто эти оформления кожи?
[01:16:13.620 --> 01:16:15.620]  As if they are members
[01:16:15.620 --> 01:16:17.620]  of the enclosing namespace
[01:16:17.620 --> 01:16:19.620]  in many situations.
[01:16:19.620 --> 01:16:21.620]  Но они во всех.
[01:16:21.620 --> 01:16:23.620]  То есть в каких-то ситуациях они считаются,
[01:16:23.620 --> 01:16:25.620]  что лежат в родительском namespace,
[01:16:25.620 --> 01:16:27.620]  и в некоторых — не считаются.
[01:16:27.620 --> 01:16:29.620]  Ну, это от нас независимо.
[01:16:29.620 --> 01:16:31.620]  Ну, вот тут написано.
[01:16:31.620 --> 01:16:33.620]  Это как inline для функции рекомендации?
[01:16:33.620 --> 01:16:35.620]  Еще раз.
[01:16:35.620 --> 01:16:37.620]  Нет, тут
[01:16:37.620 --> 01:16:39.620]  в некоторых
[01:16:39.620 --> 01:16:41.620]  кейсах в языке прямо прописано,
[01:16:41.620 --> 01:16:43.620]  в каких ситуациях, если мы
[01:16:43.620 --> 01:16:45.620]  пытаемся найти имя, мы его найдем,
[01:16:45.620 --> 01:16:47.620]  даже если оно объявлено не в namespace
[01:16:47.620 --> 01:16:49.620]  ranges, а в namespace вложенном.
[01:16:49.620 --> 01:16:51.620]  Ну, вот тут это abusing.
[01:16:51.620 --> 01:16:53.620]  Зачем это вот такие лютые детали,
[01:16:53.620 --> 01:16:55.620]  что просто беда?
[01:16:55.620 --> 01:16:57.620]  Хотите заморочиться и прочитать это?
[01:16:57.620 --> 01:16:59.620]  Я вот не очень.
[01:16:59.620 --> 01:17:01.620]  Нет?
[01:17:01.620 --> 01:17:03.620]  Ну, давайте тогда
[01:17:03.620 --> 01:17:05.620]  и не будем.
[01:17:05.620 --> 01:17:07.620]  В целом считаем, что этого как будто нет.
[01:17:07.620 --> 01:17:09.620]  Почему?
[01:17:09.620 --> 01:17:11.620]  Ну, потому что
[01:17:11.620 --> 01:17:13.620]  неинтересно, скучно,
[01:17:13.620 --> 01:17:15.620]  и я забыл, что там конкретно происходит.
[01:17:15.620 --> 01:17:17.620]  Не особо важно понимать механики
[01:17:17.620 --> 01:17:19.620]  самих inline namespace?
[01:17:19.620 --> 01:17:21.620]  Просто
[01:17:21.620 --> 01:17:23.620]  вот эта вот штука, она как будто
[01:17:23.620 --> 01:17:25.620]  на namespace выше.
[01:17:25.620 --> 01:17:27.620]  Вообще inline namespace используют для
[01:17:27.620 --> 01:17:29.620]  версионирования обычно.
[01:17:29.620 --> 01:17:31.620]  То есть в библиотеке ranges
[01:17:31.620 --> 01:17:33.620]  было inline namespace
[01:17:33.620 --> 01:17:35.620]  v1.
[01:17:35.620 --> 01:17:37.620]  Когда что-то
[01:17:37.620 --> 01:17:39.620]  меняют и обратную совместимость,
[01:17:39.620 --> 01:17:41.620]  там ломают, меняют там на v2,
[01:17:41.620 --> 01:17:43.620]  и те, кому нужно старое, они
[01:17:43.620 --> 01:17:45.620]  явно дописывают v1, v2.
[01:17:45.620 --> 01:17:47.620]  Вот.
[01:17:47.620 --> 01:17:49.620]  Итак.
[01:17:49.620 --> 01:17:51.620]  Из какого-то другого
[01:17:51.620 --> 01:17:53.620]  namespace cast swap, который, кстати, рядом
[01:17:53.620 --> 01:17:55.620]  используется, тип
[01:17:55.620 --> 01:17:57.620]  swap для этого.
[01:17:57.620 --> 01:17:59.620]  Где же, где же, где же
[01:17:59.620 --> 01:18:01.620]  тип swap? Давайте control-кликнем.
[01:18:01.620 --> 01:18:03.620]  Вот он.
[01:18:03.620 --> 01:18:05.620]  Ну, это, конечно, невозможно смотреть, да?
[01:18:23.620 --> 01:18:25.620]  Гады они, конечно.
[01:18:25.620 --> 01:18:27.620]  Это ж просто невозможно читать.
[01:18:27.620 --> 01:18:29.620]  Так.
[01:18:29.620 --> 01:18:31.620]  OK.
[01:18:33.620 --> 01:18:35.620]  Swap.
[01:18:35.620 --> 01:18:37.620]  Что внутри есть?
[01:18:41.620 --> 01:18:43.620]  Это что-то неважное.
[01:18:43.620 --> 01:18:45.620]  Есть главный оператор
[01:18:45.620 --> 01:18:47.620]  круглой скобки, который
[01:18:47.620 --> 01:18:49.620]  void принимает
[01:18:49.620 --> 01:18:51.620]  два аргумента. Деталь, которую я
[01:18:51.620 --> 01:18:53.620]  опустил, аргументы разные.
[01:18:55.620 --> 01:18:57.620]  Ну, и по универсальным ссылкам.
[01:18:57.620 --> 01:18:59.620]  Там, да, это тоже, по-моему, я забил
[01:18:59.620 --> 01:19:01.620]  на это.
[01:19:01.620 --> 01:19:03.620]  А вот тут концепты
[01:19:03.620 --> 01:19:05.620]  про то, что
[01:19:05.620 --> 01:19:07.620]  я говорил. ADL-swap
[01:19:07.620 --> 01:19:09.620]  или
[01:19:09.620 --> 01:19:11.620]  будет работать STD-swap.
[01:19:15.620 --> 01:19:17.620]  Как
[01:19:17.620 --> 01:19:19.620]  оно называется?
[01:19:21.620 --> 01:19:23.620]  О.
[01:19:25.620 --> 01:19:27.620]  Сейчас.
[01:19:29.620 --> 01:19:31.620]  Там online-show,
[01:19:31.620 --> 01:19:33.620]  non-spaces.
[01:19:33.620 --> 01:19:35.620]  Там много шоу.
[01:19:35.620 --> 01:19:37.620]  Не взяли, что поиски
[01:19:37.620 --> 01:19:39.620]  написать outline, а дел show non-spaces.
[01:19:39.620 --> 01:19:41.620]  А это, скорее
[01:19:41.620 --> 01:19:43.620]  всего...
[01:19:43.620 --> 01:19:45.620]  Так. Ну, тогда
[01:19:45.620 --> 01:19:47.620]  надо искать оба слова, я outline,
[01:19:47.620 --> 01:19:49.620]  non-spaces.
[01:19:49.620 --> 01:19:51.620]  В общем-то, это происходит.
[01:19:51.620 --> 01:19:53.620]  Одно же или другое?
[01:19:53.620 --> 01:19:55.620]  Видимо, он сдался от того, насколько
[01:19:55.620 --> 01:19:57.620]  большой файл.
[01:20:03.620 --> 01:20:05.620]  Это explorer, да?
[01:20:07.620 --> 01:20:09.620]  Features, explorer.
[01:20:13.620 --> 01:20:15.620]  Кажется, это не то.
[01:20:19.620 --> 01:20:21.620]  Ладно, неважно.
[01:20:23.620 --> 01:20:25.620]  Здесь он работает.
[01:20:25.620 --> 01:20:27.620]  Ну, тоже не работает. Значит, не outline.
[01:20:27.620 --> 01:20:29.620]  Значит, как-то по-другому.
[01:20:29.620 --> 01:20:31.620]  Знакомый код, правда?
[01:20:31.620 --> 01:20:33.620]  Вот это вот ровно то, что мы смотрели.
[01:20:33.620 --> 01:20:35.620]  ADL-swappable
[01:20:35.620 --> 01:20:37.620]  или работает STD-swap.
[01:20:37.620 --> 01:20:39.620]  И в constexpr ADL-swap нашел,
[01:20:39.620 --> 01:20:41.620]  делается, вы не поверите,
[01:20:41.620 --> 01:20:43.620]  swap с помощью ADL-а.
[01:20:43.620 --> 01:20:45.620]  Кто знает, что это такое?
[01:20:45.620 --> 01:20:47.620]  Зачем здесь какой-то статик cast?
[01:20:47.620 --> 01:20:49.620]  Да.
[01:20:49.620 --> 01:20:51.620]  Это имплементация STD-форварда.
[01:20:51.620 --> 01:20:53.620]  Написанная здесь ручками, потому что
[01:20:53.620 --> 01:20:55.620]  ну, а почему нет?
[01:20:55.620 --> 01:20:57.620]  Настоящие программисты на C++
[01:20:57.620 --> 01:20:59.620]  не используют.
[01:20:59.620 --> 01:21:01.620]  Все переписывают с нуля.
[01:21:01.620 --> 01:21:03.620]  Про noexcept
[01:21:03.620 --> 01:21:05.620]  тоже. Noexcept надо
[01:21:05.620 --> 01:21:07.620]  писать.
[01:21:07.620 --> 01:21:09.620]  И вот эта вспомогательная функция там
[01:21:09.620 --> 01:21:11.620]  просто определяет, нормально ли все будет
[01:21:11.620 --> 01:21:13.620]  с noexcept-ами работать.
[01:21:15.620 --> 01:21:17.620]  Ну, давайте концепт ADL-swap посмотрим.
[01:21:17.620 --> 01:21:19.620]  А?
[01:21:21.620 --> 01:21:23.620]  Это реализация STD-swap.
[01:21:23.620 --> 01:21:25.620]  Руками написанная.
[01:21:27.620 --> 01:21:29.620]  Не знаю, может они решили не include
[01:21:29.620 --> 01:21:31.620]  header-util в header-concept.
[01:21:31.620 --> 01:21:33.620]  Скорее всего, это так.
[01:21:39.620 --> 01:21:41.620]  Тут еще какая-то мелкая
[01:21:41.620 --> 01:21:43.620]  гадость есть?
[01:21:43.620 --> 01:21:45.620]  Кто-нибудь понимает, что это такое?
[01:21:45.620 --> 01:21:47.620]  Это STD-swap, у него же есть две стд-swap
[01:21:47.620 --> 01:21:49.620]  для C-шных массивов отдельно.
[01:21:49.620 --> 01:21:51.620]  Да, есть отдельный STD-swap для
[01:21:51.620 --> 01:21:53.620]  C-шных массивов. Это еще один
[01:21:53.620 --> 01:21:55.620]  оператор круглые скобки же у нас, да?
[01:21:55.620 --> 01:21:57.620]  Да, это еще один оператор круглые скобки для C-шных массивов.
[01:21:57.620 --> 01:21:59.620]  А где вот эта вот строчка-то
[01:21:59.620 --> 01:22:01.620]  проделит?
[01:22:01.620 --> 01:22:03.620]  Сейчас будет. Она же относится
[01:22:03.620 --> 01:22:05.620]  к концепту ADL-swap.
[01:22:05.620 --> 01:22:07.620]  Поэтому, когда мы пройдем по концепту ADL-swap,
[01:22:07.620 --> 01:22:09.620]  мы ее увидим.
[01:22:09.620 --> 01:22:11.620]  И все это
[01:22:11.620 --> 01:22:13.620]  в name-спейсе cast-swap, чтобы ничего наружу не
[01:22:13.620 --> 01:22:15.620]  торчало, да?
[01:22:15.620 --> 01:22:17.620]  Который не inline.
[01:22:17.620 --> 01:22:19.620]  И вот здесь мы
[01:22:19.620 --> 01:22:21.620]  подавили как бы нахождение STD-swap,
[01:22:21.620 --> 01:22:23.620]  если вдруг он там за inclusion,
[01:22:23.620 --> 01:22:25.620]  подавили еще что-то.
[01:22:27.620 --> 01:22:29.620]  Да, могли и написать.
[01:22:29.620 --> 01:22:31.620]  Они, смотри, они не
[01:22:31.620 --> 01:22:33.620]  хотят в header-concepts, это все в
[01:22:33.620 --> 01:22:35.620]  header-concepts, include-ить header-util,
[01:22:35.620 --> 01:22:37.620]  в котором объявлен STD-swap.
[01:22:37.620 --> 01:22:39.620]  Да? Зато
[01:22:39.620 --> 01:22:41.620]  ты в своем коде можешь сначала за include-ить
[01:22:41.620 --> 01:22:43.620]  header-util, потом header-concepts.
[01:22:43.620 --> 01:22:45.620]  И как бы тут все будет находиться.
[01:22:45.620 --> 01:22:47.620]  А если в обратном порядке?
[01:22:47.620 --> 01:22:49.620]  Тоже не важно.
[01:22:51.620 --> 01:22:53.620]  Окей, концепт более-менее
[01:22:53.620 --> 01:22:55.620]  понятный, но тут правда просит
[01:22:55.620 --> 01:22:57.620]  какую-то странную штуку, что это типа
[01:22:57.620 --> 01:22:59.620]  класс или инам, да? То есть там
[01:22:59.620 --> 01:23:01.620]  видимо
[01:23:01.620 --> 01:23:03.620]  отсекают массивы,
[01:23:03.620 --> 01:23:05.620]  указатели на функции,
[01:23:05.620 --> 01:23:07.620]  еще не понятно.
[01:23:07.620 --> 01:23:09.620]  Но главное вот,
[01:23:09.620 --> 01:23:11.620]  это такой визуальный шум, который надо
[01:23:11.620 --> 01:23:13.620]  привыкнуть игнорировать, когда вы читаете код
[01:23:13.620 --> 01:23:15.620]  стандартных библиотек. Вот это здесь суть.
[01:23:15.620 --> 01:23:17.620]  Вот ровно как я показываю.
[01:23:23.620 --> 01:23:25.620]  Визуальный шум вот.
[01:23:25.620 --> 01:23:27.620]  А важная информация вот, не путайте.
[01:23:27.620 --> 01:23:29.620]  И вот, собственно, наш
[01:23:29.620 --> 01:23:31.620]  дилит прекрасный, который удаляет стандартный
[01:23:31.620 --> 01:23:33.620]  swap с вот такой сигнатурой.
[01:23:35.620 --> 01:23:37.620]  Что Unqualified Lookup
[01:23:37.620 --> 01:23:39.620]  найдет через STD
[01:23:39.620 --> 01:23:41.620]  какой-то swap?
[01:23:41.620 --> 01:23:43.620]  Не STD,
[01:23:43.620 --> 01:23:45.620]  потому что здесь вот это есть.
[01:23:45.620 --> 01:23:47.620]  Ну, то есть если мы...
[01:23:51.620 --> 01:23:53.620]  Да, если из STD какие-то
[01:23:53.620 --> 01:23:55.620]  вектора, еще что-нибудь,
[01:23:55.620 --> 01:23:57.620]  то STD здесь по идее должен найти STD
[01:23:57.620 --> 01:23:59.620]  вектор.
[01:24:03.620 --> 01:24:05.620]  Да, потому что STD
[01:24:05.620 --> 01:24:07.620]  swap, сейчас будет смешно, если он
[01:24:07.620 --> 01:24:09.620]  констраин здесь.
[01:24:09.620 --> 01:24:11.620]  О, смотрите, сколько он...
[01:24:11.620 --> 01:24:13.620]  Вэни, Вэрей,
[01:24:13.620 --> 01:24:15.620]  тут он определен. Где
[01:24:15.620 --> 01:24:17.620]  что-нибудь нормальное?
[01:24:19.620 --> 01:24:21.620]  Почему он определен во всех хедерах,
[01:24:21.620 --> 01:24:23.620]  кроме утил, где он должен быть на самом деле?
[01:24:23.620 --> 01:24:25.620]  Погоди, а он, скорее всего,
[01:24:25.620 --> 01:24:27.620]  в BitSmoove.
[01:24:27.620 --> 01:24:29.620]  Определение своего STD слов — это BitSmoove,
[01:24:29.620 --> 01:24:31.620]  который в утиле находится.
[01:24:31.620 --> 01:24:33.620]  А, ну вот он.
[01:24:33.620 --> 01:24:35.620]  Так.
[01:24:37.620 --> 01:24:39.620]  О, видите, как тут
[01:24:39.620 --> 01:24:41.620]  красиво.
[01:24:41.620 --> 01:24:43.620]  Что-то типа...
[01:24:43.620 --> 01:24:45.620]  Если у вас слишком длинные часы,
[01:24:45.620 --> 01:24:47.620]  то концерты... Ну, как-то
[01:24:47.620 --> 01:24:49.620]  типа...
[01:24:49.620 --> 01:24:51.620]  И в C++ меньше
[01:24:51.620 --> 01:24:53.620]  11,
[01:24:53.620 --> 01:24:55.620]  то какая-то
[01:24:55.620 --> 01:24:57.620]  костылина внутри.
[01:24:57.620 --> 01:24:59.620]  Если C++...
[01:24:59.620 --> 01:25:01.620]  Сейчас, да.
[01:25:01.620 --> 01:25:03.620]  О, о, о!
[01:25:03.620 --> 01:25:05.620]  Если C++ больше,
[01:25:05.620 --> 01:25:07.620]  то...
[01:25:07.620 --> 01:25:09.620]  Да, по SFI вместо
[01:25:09.620 --> 01:25:11.620]  Requires.
[01:25:11.620 --> 01:25:13.620]  Ну, читать тяжело,
[01:25:13.620 --> 01:25:15.620]  но, короче, здесь есть вот это вот отсечение
[01:25:15.620 --> 01:25:17.620]  прекрасное.
[01:25:17.620 --> 01:25:19.620]  А, да, а еще свои трейдеры, вместо стандартных.
[01:25:19.620 --> 01:25:21.620]  Ну, в общем,
[01:25:21.620 --> 01:25:23.620]  все прекрасно.
[01:25:23.620 --> 01:25:25.620]  Если Adel найдет
[01:25:25.620 --> 01:25:27.620]  STD move, но при этом
[01:25:27.620 --> 01:25:29.620]  класс не move-assignable
[01:25:29.620 --> 01:25:31.620]  и move-constructable,
[01:25:31.620 --> 01:25:33.620]  то
[01:25:33.620 --> 01:25:35.620]  нам нормально концепт скажет
[01:25:35.620 --> 01:25:37.620]  false. Не будет ложно-положительных
[01:25:37.620 --> 01:25:39.620]  срабатываний концепта.
[01:25:39.620 --> 01:25:41.620]  Вот это главное. Итак,
[01:25:41.620 --> 01:25:43.620]  в целом, все от этой имплементации,
[01:25:43.620 --> 01:25:45.620]  вот cast-swap, здесь вот это смешной
[01:25:45.620 --> 01:25:47.620]  PoisonPill так называемый, я не сказал
[01:25:47.620 --> 01:25:49.620]  это слово, кажется, вот это называется
[01:25:49.620 --> 01:25:51.620]  PoisonPill. Концепт
[01:25:51.620 --> 01:25:53.620]  находит ли Adel что-то, для которого
[01:25:53.620 --> 01:25:55.620]  этот PoisonPill сделан.
[01:25:55.620 --> 01:25:57.620]  Структурка, у которой, ну, какой-то костыль,
[01:25:57.620 --> 01:25:59.620]  чтобы noexcept проверять, не так важно.
[01:25:59.620 --> 01:26:01.620]  Оператор круглой
[01:26:01.620 --> 01:26:03.620]  скобки нормальный, ровно как я показал,
[01:26:03.620 --> 01:26:05.620]  за исключением визуального шума
[01:26:05.620 --> 01:26:07.620]  со всякой мелочью.
[01:26:07.620 --> 01:26:09.620]  И вот этот вот для
[01:26:09.620 --> 01:26:11.620]  массивов неважно.
[01:26:11.620 --> 01:26:13.620]  Дальше inline namespace cast,
[01:26:13.620 --> 01:26:15.620]  в котором мы просто
[01:26:15.620 --> 01:26:17.620]  делаем этот самый объект, и у нас
[01:26:17.620 --> 01:26:19.620]  все работает.
[01:26:19.620 --> 01:26:21.620]  А в родительском namespace ranges
[01:26:21.620 --> 01:26:23.620]  мы берем и делаем концепт
[01:26:23.620 --> 01:26:25.620]  swapable, как просто rangeswap
[01:26:25.620 --> 01:26:27.620]  компилируется.
[01:26:27.620 --> 01:26:29.620]  Во! То есть компилируется,
[01:26:29.620 --> 01:26:31.620]  здесь значит, что концепты удовлетворены
[01:26:31.620 --> 01:26:33.620]  на операторе круглой скобки,
[01:26:33.620 --> 01:26:35.620]  который мы починили через PoisonPill.
[01:26:35.620 --> 01:26:37.620]  Все!
[01:26:37.620 --> 01:26:39.620]  Вот теперь все.
[01:26:41.620 --> 01:26:43.620]  Домашнее задание — полазить по объявлениям
[01:26:43.620 --> 01:26:45.620]  ваших любимых алгоритмов из ranges,
[01:26:45.620 --> 01:26:47.620]  если у вас такого есть, и посмотреть,
[01:26:47.620 --> 01:26:49.620]  что там написано. Наверное,
[01:26:49.620 --> 01:26:51.620]  даже лучше не в lib std c++,
[01:26:51.620 --> 01:26:53.620]  а lib c++.
[01:26:55.620 --> 01:26:57.620]  Прекрасный.
[01:26:57.620 --> 01:26:59.620]  Очень много нижних подчеркан...
[01:26:59.620 --> 01:27:01.620]  Где угодно можно. Можно даже
[01:27:01.620 --> 01:27:03.620]  MSWC STL, он тоже не такой плохой.
[01:27:03.620 --> 01:27:05.620]  На этой прекрасной ноте мы уходим
[01:27:05.620 --> 01:27:07.620]  на перерыв, перед тем, как отправиться
[01:27:07.620 --> 01:27:09.620]  в путешествие опять в пучиную историю.
