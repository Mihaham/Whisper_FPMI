[00:00.000 --> 00:12.280]  Так, у нас последнее, что было, это templates overloading.
[00:12.280 --> 00:16.040]  Мы разговаривали про то, как при наличии нескольких
[00:16.040 --> 00:18.320]  версий шаблонных функций компилятор выбирает версию.
[00:18.320 --> 00:26.760]  Я, кстати, сегодня собираюсь скинуть программу.
[00:26.760 --> 00:33.600]  Сегодня, во-первых, появится четвертая задача, возможно, последняя в этом семестре.
[00:33.600 --> 00:38.120]  А во-вторых, я вам скину программу за этот семестр,
[00:38.120 --> 00:42.880]  чтобы вы начинали повторять, что ли, систематизировать.
[00:42.880 --> 00:44.360]  Это все человек сказал.
[00:44.360 --> 01:06.800]  Вот я в прошлый раз вроде что-то говорил такое, но не очень, возможно, отчетливо.
[01:06.800 --> 01:15.960]  Вот я напоминаю, что если у вас есть f, который принимает t-амперсант,
[01:15.960 --> 01:19.520]  f, который принимает код с t-амперсант, то тут перегрузка корректно работает.
[01:19.520 --> 01:23.680]  А вот если бы вы одно принимали по значению, а другое по ссылке,
[01:23.680 --> 01:28.600]  то такая перегрузка уже не сработает и будет неоднозначность.
[01:28.600 --> 01:35.800]  Ну, в принципе, как и с обычными типами это происходит.
[01:35.800 --> 01:39.880]  Вот так, тут у меня что-то лишнее написано, извините.
[01:41.880 --> 01:46.400]  И есть еще такой интересный эффект.
[01:46.400 --> 01:53.560]  Иногда бывает, что вы в классе, ну вот у вас есть какой-нибудь класс,
[01:53.560 --> 02:06.000]  и вы в нем решаете объявить s, ну вы в нем решаете объявить шаблонный конструктор,
[02:06.000 --> 02:18.080]  ну вот скажем, от вот такого. Ну зачем-то вот решаете объявить такое.
[02:18.080 --> 02:23.840]  Тогда у вас поглотится конструктор копирования. Что значит поглотиться?
[02:23.840 --> 02:30.320]  Но если вы напишете s от const s-амперсант, а потом будете создавать свое s от другого s,
[02:30.320 --> 02:37.240]  то вы будете попадать сюда, потому что по правилу точное соответствие лучше приведения типа,
[02:37.240 --> 02:42.000]  лучше попасть в конструктор, соответствующий точно по сигнатуре, чем навесить константность.
[02:42.000 --> 02:49.920]  Вот это такой неприятный эффект, который надо иметь в виду, когда вы своему классу
[02:49.920 --> 02:54.720]  определяете шаблонные конструкторы. А вы наверняка будете своему классу
[02:54.720 --> 03:01.320]  определять шаблонные конструкторы. И там придется что-то придумывать,
[03:01.320 --> 03:06.640]  чтобы конструктор копирования при этом оставался на плаву.
[03:06.640 --> 03:20.040]  Да, если я теперь создаю s от другого s, то я попаду не в конструктор
[03:20.040 --> 03:26.080]  копирования, как хотелось бы, а сюда. Потому что это предпочтительнее,
[03:26.080 --> 03:34.000]  ну потому что тут const не надо делать. Вот, ну вариант либо определять отдельно
[03:34.000 --> 03:39.280]  конструктор вот такой, который кстати тоже формально считается конструктором копирования,
[03:39.280 --> 03:47.560]  и его кстати тоже компилятор умеет генерировать. Ну можно написать, что типа, ну там, этот конструктор
[03:47.560 --> 03:55.840]  можно определить просто как s от, ну идут const cast навесить какой-нибудь, ну вряд ли такое вам
[03:55.840 --> 04:03.200]  пригодится. Скорее, ну короче увидите, когда такая ситуация случится, тогда и поговорим.
[04:03.200 --> 04:10.960]  Что делаете? Если это const, то конечно этот, потому что частное предпочтительнее общего.
[04:10.960 --> 04:19.280]  А зачем может понадобиться вызов конструктора по ссылке? Ну в смысле, вы написали это ссылка.
[04:19.280 --> 04:26.800]  Чего вызов конструктора, а что там должно по-твоему быть? Константная ссылка?
[04:26.800 --> 04:44.600]  Ну такой-то конкретно случай у вас вряд ли будет, а вот с двумя амперсандами очень даже будет,
[04:44.600 --> 04:52.760]  когда будет универсальная ссылка, так называемая. Всё, проехали. Просто имейте в виду,
[04:52.760 --> 05:02.200]  что такая проблема есть. Давайте дальше. Следующая штука это специализация шаблонов.
[05:02.200 --> 05:13.920]  Не буду писать полностью слово. Так вот, я вам рассказал про перегрузку шаблонных функций,
[05:13.920 --> 05:34.320]  но есть ещё специализация шаблонов. Сейчас мы поговорим о том, что такое специализация шаблонов.
[05:34.320 --> 05:46.600]  Ну проще рассказать, что такое специализация шаблонов классов. Вот у вас есть какой-нибудь класс.
[05:46.600 --> 06:01.280]  Ну давайте опять-таки, я буду писать структура S. Абстракт S. Ну и в нём что-то есть, я не знаю.
[06:01.280 --> 06:14.160]  Ну что угодно типа. А давайте я сразу буду на примере вектора. Вот в векторе есть значит
[06:14.160 --> 06:28.600]  T звёздочка массив, да, как мы уже выясняли там. Size T, size, size T, capacity. А казалось бы,
[06:28.600 --> 06:37.040]  что может пойти не так. Можно для некоторых конкретных типов этот класс переопределить
[06:37.040 --> 06:44.560]  иначе. Вот что такое специализация. Да, вот вы знаете, я неспроста привёл вектор,
[06:44.560 --> 06:49.960]  потому что такой классический пример. Вы можете захотеть, чтобы ваш класс для вот
[06:49.960 --> 06:58.840]  некоторого конкретного типа был определён не так, как для общего случая. Да, и, например,
[06:58.840 --> 07:06.400]  вектор bool является таким классом, который специализирует обычный вектор. А в чём его
[07:06.400 --> 07:13.880]  реализация отличается от стандартного вектора? Ну там не вектор, ну там не bool звёздочка, там
[07:13.880 --> 07:21.680]  char звёздочка скорее. А когда вы в него по индексу записываете, там происходит записывание определённого
[07:21.680 --> 07:29.360]  битика в нужный char. Но я сейчас не буду писать, как устроен вектор bool, хотя у нас в планах это
[07:29.360 --> 07:36.640]  достаточно подробно разобрать. Сейчас мы не будем с вами прям писать реализацию, но меня сейчас
[07:36.640 --> 07:42.000]  больше волнует, как это синтактически пишется, как именно с точки зрения специализации. Как это
[07:42.000 --> 07:47.280]  пишется? Пишется следующим образом. Я пишу опять шаблонный префикс template, указывающий на то,
[07:47.280 --> 07:59.720]  что это всё ещё шаблон, а дальше у меня уже ноль шаблонных параметров, зато вот здесь есть
[07:59.720 --> 08:10.600]  один явно указанный шаблонный параметр, и тут что-то там, какие-то поля. Вот, вот,
[08:10.720 --> 08:19.200]  внимание на синтакте специализации, он может быть неинтуитивный. Вот здесь вот я перечисляю те
[08:19.200 --> 08:23.880]  шаблонные параметры, которые мне реально остались нужны. Их совершенно необязательно должно быть
[08:23.880 --> 08:31.320]  ноль. В общем-то их даже необязательно должно быть меньше, чем было здесь, а их даже может
[08:31.320 --> 08:37.720]  быть больше, чем было здесь. Смысл специализации в том, что она после слов template и какие-то там
[08:37.720 --> 08:45.640]  угловые скобочки, уточняет вектор от чего. Вот, когда я определяю обычный шаблонный класс,
[08:45.640 --> 08:52.240]  я пишу template blah blah blah в вектах, ну, название класса, и дальше у меня вот эти вот шаблонные
[08:52.240 --> 08:58.360]  переменные, метапеременные внутри тела класса. Когда я определяю специализацию, я пишу template
[08:58.360 --> 09:04.080]  какой-то снова шаблонный префикс, смотря сколько мне нужно шаблонных аргументов оставить. И здесь
[09:04.080 --> 09:15.760]  определяю, значит, в угловых скобочках, прямо после названия, для чего я конкретизирую. Вот,
[09:15.760 --> 09:26.960]  специализация обязательно должна быть объявлена после общей версии. Если я напишу так до нее,
[09:26.960 --> 09:31.400]  то это будет CE, компилятор скажет, что я пытаюсь специализировать класс, который еще не объявлен.
[09:31.400 --> 09:42.440]  Вот, если я... вот так ты хочешь написать или что?
[09:42.440 --> 10:07.480]  Ну, да, есть более умный способ. Значит, скоро мы с вами научимся навешивать условия на типы,
[10:07.480 --> 10:13.400]  и вам не придется такое писать. То есть, на самом деле, мы просто научимся скоро делать
[10:13.400 --> 10:17.840]  compile-time-проверки, чем является тип. Ну, например, если тип это будет или имп,
[10:17.840 --> 10:25.240]  сделай одно иначе другое. Ну, такое тоже можно. Вот, но пока мы не умеем, да, поэтому так.
[10:25.240 --> 10:40.160]  Вот, специализация должна быть объявлена после общей версии. Вот, когда есть специализация,
[10:40.160 --> 10:45.800]  то только вот такой конкретный тип попадает сюда. Если даже тип не явно приводится,
[10:45.800 --> 10:54.280]  то это не повод идти в специализацию, только вот для данного конкретного TE. И еще раз напоминаю,
[10:54.280 --> 10:59.240]  что эти два типа, вектор от какого-то TE и вектор от Bool, это не связанные друг с другом типы
[10:59.240 --> 11:03.320]  с точки зрения компилятора. Один к другому никак не преобразуется, это просто нагенерированный
[11:03.320 --> 11:09.760]  код. Компилятор просто подставляет то, что называется делать инстанцирование, когда мы
[11:09.760 --> 11:16.880]  подставляем какие-то TE, но это не означает, что эти типы для него как-то какие-то что-то общие имеют
[11:16.880 --> 11:24.120]  с точки зрения компилятора. Вот, то, что я показал, называется полная специализация. Вот это вот полная
[11:24.120 --> 11:33.760]  специализация. А бывает еще частичная специализация. Частично это когда вы не все параметры
[11:33.760 --> 11:44.080]  специализируете, или когда вы специализируете лишь, скажем так, вид параметра, а не его конкретное
[11:44.080 --> 11:48.160]  значение. Сейчас продемонстрирую. Вот представьте, что у меня есть структура, вот теперь уже будет
[11:48.160 --> 12:02.840]  абстрактно. Представьте, что у меня есть структура вот такая. TypeNameT и TypeNameU. Стракт S. И тут есть два
[12:02.840 --> 12:10.320]  поля вот таким. Вот, но это такая шаблонная структура с двумя параметрами, шаблонными параметрами.
[12:11.280 --> 12:25.640]  Вот, но я могу, допустим, эту структуру специализировать для ситуации, когда у меня типы одинаковые.
[12:25.640 --> 12:37.280]  Допустим, в такой ситуации я хочу сделать всего одно поле. Вот, пожалуйста, тоже себе вполне
[12:37.360 --> 12:48.320]  специализация корректная. Обратите внимание на синтаксис. У структуры все еще два шаблонных
[12:48.320 --> 12:52.440]  параметра. Я не могу путем специализации уменьшить ей число шаблонных параметров,
[12:52.440 --> 12:59.560]  но я могу навесить некоторые ограничения на то, какие они путем специализации. Сейчас я написал,
[12:59.560 --> 13:09.720]  что если так сложилось, что в этой структуре передали два одинаковых параметра, то иди вот в эту
[13:09.720 --> 13:16.280]  частную версию. Вот это называется частичная специализация. Частичная она, потому что я
[13:16.280 --> 13:24.440]  не уточнил конкретно, то есть у меня под эту специализацию подходит много вообще
[13:24.440 --> 13:35.720]  ситуаций. Вот, ее частичность лишь в том, что я навесил условия, что параметры равны,
[13:35.720 --> 13:50.600]  но не сказал, чему они конкретно равны. Конечно, никак это они не связаны друг с другом. Я могу
[13:50.600 --> 14:03.680]  объявить, в принципе, ничем не мешает шаблонный конструктор от другого S. Понятно, что если я
[14:03.680 --> 14:09.240]  захочу, я могу сделать их все конструируемыми друг из друга. Я могу, например, сделать их все
[14:09.240 --> 14:17.840]  друзьями друг друга. А можно как-то общие методы делать? Кому? Так, они... Если у них должны быть
[14:17.840 --> 14:25.640]  какие-то методы прям совершенно одинаковые, то их не подойдет. Ну, унаследоваться можно от общего предка,
[14:25.640 --> 14:40.720]  например. А можно одну унаследоваться, другую нет? Да, по-моему, можно, да. Ну, есть-то разная
[14:40.720 --> 14:49.880]  сершонтипа, может быть одна наследница и чего-то, а другая не является наследником. Вот, кажется, да.
[14:49.880 --> 15:03.200]  Что еще можно? Можно их все сделать друзьями, да, например, все такие шаблонные структуры. То есть
[15:03.200 --> 15:16.880]  написать шаблонное объявление друга, то есть сказать template typeName a, typeName b, friend struct S. Я
[15:16.880 --> 15:24.880]  вот только правда не уверен, что здесь нужно писать a, typeName b в угловых скобочках. Ну, в общем,
[15:24.880 --> 15:36.680]  неважно. Ну, короче, можно все их сделать друзьями друг с другом. Такой шаблонный друг. Мой шаблонный
[15:36.680 --> 15:47.800]  дружок. Так, хорошо. Да. Вот частичная специализация бывает еще вот какая. Например, я могу сделать так.
[15:47.800 --> 15:59.920]  Давайте я это скопирую и сказать следующее. Представим, что у меня, например, ну так вот выглядит
[15:59.920 --> 16:10.200]  дело. Это другой вид частичной специализации. Я навесил условия на тип тем самым. Шаблонных
[16:10.200 --> 16:15.680]  параметров по-прежнему две, но теперь, допустим, вот если второй из них является ссылкой, то я попаду
[16:15.680 --> 16:22.960]  в эту версию. Но я тоже самое могу сделать там, если этот параметр является указателем, я попаду в
[16:22.960 --> 16:28.960]  эту версию. Или если он является константным, например, я попаду в эту версию. То есть я просто
[16:29.000 --> 16:38.560]  один из параметров сделал каким-то уточнил, скажем так. И теперь, если я попадаю в
[16:38.560 --> 16:47.960]  частный случай, что у меня, например, если я s от int запятая double-impercent создам, то попаду сюда.
[16:47.960 --> 16:56.480]  Вот, если я, допустим, сейчас создам специализацию, ой, создам попытающий экземпляр s, например,
[16:56.640 --> 17:02.440]  int&int%, то скорее всего будет ce, потому что из двух специализаций он не сможет выбрать какая лучше,
[17:02.440 --> 17:10.040]  какая более частная. Ну, непонятно какая. И это чем-то хороша, и это чем-то хороша. Вот,
[17:10.040 --> 17:16.880]  здесь, скорее всего, он не сможет выбрать, скажет, неоднозначность. Как с ним бороться? Делать
[17:16.880 --> 17:23.400]  нормальные специализации. Так же, как при перегрузке функции, вы с ним боретесь. Либо не создавать
[17:23.400 --> 17:32.960]  таких объектов, либо делать так, чтобы было понятно, как из специализации выбирать. Вот,
[17:32.960 --> 17:47.320]  значит, это специализация классов. Теперь поговорим про специализацию шаблонных функций. Она
[17:47.320 --> 17:55.920]  тоже бывает. Но с шаблонными функциями есть загвоздка. Дело в том, что у функций же бывает
[17:55.920 --> 18:05.600]  еще и перегрузка, помимо специализации. Вот, смотрите, сейчас мне понадобится main,
[18:05.600 --> 18:22.960]  наверное. Ну, давайте я возьму, сделаю шаблонную функцию. Ну, неважно, не буду тип указывать. Если
[18:22.960 --> 18:28.120]  кто еще не знает, чтобы компилятор не жаловался на не используя переменную, нужно просто не
[18:28.120 --> 18:32.880]  указывать имя переменной, то я в очередной раз хочу обратить ваше внимание на это, а то,
[18:32.880 --> 18:40.680]  когда люди такие вопросы ближе к концу семестра, в чате создают мне даже неловко. Так вот,
[18:40.680 --> 18:54.120]  ну, обычная функция. А теперь смотрите. Не так. Давайте будет функция с двумя аргументами.
[18:54.600 --> 19:10.640]  Ну и тут два типа я принимаю. У типов нету параметров, потому что некоторые, я уверен,
[19:10.640 --> 19:20.400]  что до сих пор не все знают, что можно так. Да, да, да, но понимаешь, в чате много раз писали,
[19:20.400 --> 19:32.400]  много чего до этого. Тем не менее люди спрашивают. Вот, ну, смотрите, вот я сделал такую штуку. Вот у
[19:32.400 --> 19:37.680]  меня есть функция двух шаблонных параметров, которые уют один, и этот от одного, который выводит два.
[19:37.680 --> 19:46.080]  Ну, аргументов в обоих случаях два, а шаблонных параметров то один, то два. Ну, ни у кого не
[19:46.080 --> 19:56.880]  вызывает, я думаю, все понимают, что выведется в каждом из этих двух случаев. Ну, что выведется в
[19:56.880 --> 20:05.640]  каждом из случаев? Сначала один, потом два, потому что второе более частное. Вот, но то, что я сейчас
[20:05.640 --> 20:19.760]  написал, это не специализация функции. Это очень странный... так, что? О-хо-хо-хо. Темплэйт, а не тайпнэйм.
[20:19.760 --> 20:33.960]  Вот, но это, это не специализация сейчас, это перегрузка. А в чем разница между перегрузкой
[20:33.960 --> 20:41.720]  и специализацией? А вот сложно сказать. Ну, короче, это не специализация, точно говорю. А сейчас покажу
[20:41.720 --> 21:05.600]  специализацию. Специализация будет вот. F от int int. Вот это специализация. Поскольку для функций
[21:05.600 --> 21:15.960]  существует перегрузка, комитет по стандартизации решил проблему терминологическую таким образом. Вот,
[21:15.960 --> 21:23.040]  если у вас есть несколько версий функций с одним и тем же именем, но разными наборами параметров или
[21:23.040 --> 21:29.600]  разными наборами шаблонных параметров, то это все называется перегрузкой. А специализация считается
[21:29.600 --> 21:37.120]  только ситуацией, когда у вас с пустого префикса темплэйта начинаются объявления функций. А все остальное
[21:37.120 --> 21:41.760]  считается перегрузкой функций. Казалось бы, какая разница, как это называть, а вот сейчас выяснится,
[21:41.760 --> 21:46.680]  что есть разница, но сначала давайте поймем, что выведется в этих случаях. Ну, очевидно, выведется
[21:46.680 --> 21:59.240]  сначала один, потом три. А разве что-то изменится, если мы уберем темплэйт пустой? Сейчас. В данном случае как-будто нет.
[21:59.240 --> 22:11.320]  Сейчас увидим. Короче, сейчас понятно будет один, потом три. Вот. Давайте закомментируем. Теперь это
[22:11.320 --> 22:17.600]  перегрузка. Ну, теперь ее нельзя вызывать шаблонными аргументами, например. То есть, я не могу,
[22:18.200 --> 22:31.200]  вот если я напишу вот так, то я получу два. Вот. А если бы здесь был темплэйт, то при таком вызове
[22:31.200 --> 22:41.040]  я все равно получил три. Вот смотрите, вот сейчас я все равно получу три при втором вызове. Потому что
[22:41.040 --> 22:48.440]  теперь считается, что это вот это f, это под случай как-бы вот этого случая, когда я от него
[22:48.440 --> 22:59.920]  шаблонного аргумента вызываю. Вот. Но есть один замечательный пример интересный.
[22:59.920 --> 23:23.520]  Где? Да, ну. Вот если так я написал, ну так все равно будет три. А если бы тут не стоял шаблонный
[23:23.520 --> 23:43.840]  префикс, то так было бы два. А теперь фокус. Я беру и вот эту вот штуку переношу сюда. Да блин,
[23:43.840 --> 23:53.280]  никак не научусь вставлять в ВИМИ нормально. Смотрите, теперь у меня что есть. Ну да, shift-Pan,
[23:53.400 --> 24:04.320]  тот же вопрос. Что сейчас выведется?
[24:09.720 --> 24:12.440]  Перестававки, что должно поменяться?
[24:23.280 --> 24:36.160]  Вот сейчас внезапно выведется два, а не три во втором случае.
[24:36.160 --> 24:56.800]  Потому что так решил комитет по стандартизации.
[24:56.800 --> 25:15.280]  Значит, почему? Почему он так решил? Ну, а специализация, она должна прицепиться
[25:15.280 --> 25:24.280]  к какой-то версии функции. Специализация это как-бы такая прицепка к какой-то основной из версий.
[25:24.280 --> 25:30.640]  Вот у нас сейчас здесь две перегрузки, и у одной из них есть специализация. Просто специализация
[25:30.640 --> 25:38.440]  прицепляется ближайше сверху. Вот сейчас по факту у меня две версии F, но одна из них специализирована.
[25:38.440 --> 25:53.560]  Ну, потому что это с точки зрения перегрузки версии две. Это просто прицепка к первой версии.
[25:53.560 --> 26:03.880]  Сначала решается, кто победил в перегрузке, а потом, если у этой версии перегрузки была
[26:03.880 --> 26:10.680]  специализация, то мы посмотрим, не подходит ли она. В данном случае в перегрузке выигрывает
[26:10.680 --> 26:18.880]  вторая версия, вот эта. А у нее нет специализации, поэтому сюда мы не попадаем. Вот это важный
[26:18.880 --> 26:24.360]  пример, который стоит запомнить, демонстрирующий разницу между специализацией перегрузкой для
[26:24.360 --> 26:37.520]  шаблонных функций. Просто поменял местами и изменилось поведение от этого. Почему, почему что?
[26:37.520 --> 26:45.000]  Ну, я же только что рассказал, потому что сначала решается какая версия перегрузки побеждает,
[26:45.000 --> 26:53.320]  а потом уже нет ли у этой версии перегрузки специализации подходящей. Специализация
[26:53.320 --> 27:02.680]  прицепляется к ближайшей сверху версии перегрузки. Нет, третья. Вот это, это перегрузка.
[27:02.680 --> 27:21.080]  Ну да. Но пригодится, ну нужно ли вам будет так писать, я не знаю, но теории можно, почему нет?
[27:21.080 --> 27:29.280]  Сначала перегрузка, потом специализация. Почему же на этом этапе не выберется средняя функция,
[27:30.160 --> 27:41.080]  потому что она не является перегрузкой. Нет, она является специализацией другой просто версии.
[27:41.080 --> 27:49.160]  Еще раз, у вас есть две версии, вот FATU и FATT. Эта штука прицепилась к той, которая сверху была,
[27:49.160 --> 27:54.080]  вот они две версии перегрузки, а это какой-то из них прицепилась как подверсия, скажем так.
[27:54.080 --> 28:00.520]  А чтобы вызвать там среднюю функцию, нужно, что нужно сделать вообще?
[28:00.520 --> 28:21.400]  Ну сейчас, наверное, если я сделаю вот так, то я получу третью.
[28:21.400 --> 28:30.920]  Ну потому что у нее два шаблонных параметра, а у этой всего один шаблонный параметр.
[28:30.920 --> 28:40.800]  И вот таким вызовом я всегда получу версию, причем более того, даже если я вот так сделаю,
[28:40.800 --> 28:46.920]  кажется я все равно получу третью, правда я вот тут уже не уверен. А нет, тут я получу, тут я
[28:46.920 --> 28:53.400]  получу первую, да, потому что он ставит соответствие соответствующих. Да, ну вот так получу третью.
[28:53.400 --> 29:05.280]  Сейчас специализация она работает примерно как наследование, то есть у нас есть какой-то
[29:05.280 --> 29:16.640]  дерево с главной функцией. Ну что значит? Я не знаю, что значит как наследование,
[29:16.640 --> 29:23.040]  но вот она так работает, как я рассказывал. Ближайший сверху, я же три раза сказал уже.
[29:23.040 --> 29:39.920]  Так, все, идем дальше. Вот, ладно, это были такие технические подробности. Сейчас будет очень
[29:39.920 --> 29:53.320]  важный пункт, который вам прямо пригодится в ближайшее самое время. Сейчас мы разберем,
[29:53.320 --> 30:00.360]  что еще может быть параметрами шаблона кроме, собственно, типов.
[30:00.360 --> 30:17.200]  Не знаю, а изучение вообще любого языка, например, там русского или английского, это что?
[30:17.200 --> 30:31.200]  11 глаголов исключений, например. Это как так вышло? Так решил комитет по грамматизации.
[30:31.200 --> 30:42.800]  Когда новый стандарт выпустили? Ну вот, да, вот выпустили новый стандарт,
[30:42.800 --> 30:46.640]  стало можно кофе в среднем роде говорить. Вот примерно так и живем.
[30:46.640 --> 31:03.440]  Ну да, да, я и говорю, вот кофе среднего рода теперь можно.
[31:03.440 --> 31:26.840]  Так, очень важный пункт. Очень важный пункт не типовые параметры шаблонов. Не типовые не в том
[31:26.840 --> 31:30.840]  смысле, что они какие-то необычные, а в смысле, что не являющиеся типами.
[31:30.840 --> 31:40.120]  Что еще может быть параметрами шаблонов кроме типов? Вот сейчас, если никто из вас до этого,
[31:40.120 --> 31:46.760]  ну никто, если кто-то из вас вот с шаблонами до этого не работал, у него может немножечко
[31:46.760 --> 31:53.600]  сломаться мозг, потому что в первый раз, ну, в общем, большой риск немножечко запутаться,
[31:53.600 --> 32:02.800]  но постарайтесь. Числа могут быть параметрами шаблонов, просто числа, а не типы. Я могу
[32:02.800 --> 32:17.400]  написать template int n, а дальше void f, вот чего-нибудь, int x, например. Ну и там, не знаю, вывести x
[32:17.400 --> 32:24.120]  плюс n. Вот, пожалуйста, я вам написал функцию, у которой шаблонным параметром является число,
[32:24.120 --> 32:32.520]  и обычным параметром является число. Ну и как такой функции пользоваться? Ну, могу, например,
[32:32.520 --> 32:41.280]  вызвать f с шаблонным параметром 2 от 1, выведется 3. Это много, чем отличается. Что за хрень-то?
[33:11.280 --> 33:18.400]  Я понял. Да что ж такое? Зачем я? Господи, потому что я, все, я понял, потому что я вместо g
[33:18.400 --> 33:29.800]  плюс-плюс пишу vim. Все понятно. Ну вот, вот 3 вывелось. Значит, вот, добро пожаловать,
[33:29.800 --> 33:37.640]  функция с шаблонным параметром int и с обычным параметром int. И вот я вызываюсь от этих.
[33:41.280 --> 33:48.200]  Да, между словом template и открывающей угловой скобкой пробел ставится, а вот между названием
[33:48.200 --> 33:56.720]  функции открывающей круглой не ставится. Вот так вот живите с этим. У меня появился второй вопрос.
[33:56.720 --> 34:24.080]  Да, кстати, смотрите, code style, значит, ну просто привыкните и пишите так, все нормальные люди так
[34:24.080 --> 34:30.160]  пишут, и вы так делаете. Когда вы объявляете шаблон, вот здесь пробел ставится, а когда используете,
[34:30.160 --> 34:37.120]  не ставится. Вот здесь не ставится пробел, а тут ставится. Понятно? Да, все ясненько вам, понятненько.
[34:37.120 --> 34:48.880]  Так, что, есть вопросы вот про этот пример? Тут вроде все понятно. Ого-го-го, ну сейчас,
[34:48.880 --> 34:56.240]  нет, зачем это как раз, вот это как раз очень нужно. Когда мы писали просто template от какого-то
[34:56.240 --> 35:03.520]  type name n, то как нам завести, допустим, вот у нас в template было написано type name t, как нам в этом
[35:03.520 --> 35:12.080]  же template завести переменную типа t? Как так и завести t и x точкой запятой? Нет, вот у тебя в template
[35:12.080 --> 35:20.080]  допустим было type name t. Что значит в template завести? Как в template передать переменную типа t? А, нужно было бы написать,
[35:20.080 --> 35:27.320]  допустим, у тебя было написано type name t, а не ты бы через запятую передал t, а какой-нибудь t, n. Ты хочешь
[35:27.320 --> 35:32.920]  прямо в угловые скобки t что ли вставить? Да, да. Да, можно и так, например, так можно написать.
[35:32.920 --> 35:38.880]  Допустим, у меня есть type name t, после этого t уже в принципе рабочее, я могу вот так написать.
[35:38.880 --> 35:47.360]  Ну, только мне надо здесь другое, ну так могу написать. А можно маленький вопрос задать? Можно, да. А код что ли по
[35:47.360 --> 35:54.200]  ходу компиляторам этого мусора собирается? Что значит по ходу компилятора? У нас очень много разных видов функций,
[35:54.200 --> 36:01.360]  как это устроено на уровне реализации? У нас же очень много разных видов функций, это скипами там еще понятно,
[36:01.360 --> 36:08.440]  типа плюс-минус их счетное количество, а вот значение перегенда может быть очень новым. Так, вот смотрите,
[36:08.560 --> 36:21.040]  это устроено также как и с типами. И вот здесь как раз я сейчас должен сказать важную вещь,
[36:21.040 --> 36:29.160]  главное ограничение, которое проистекает из такого. Вот это вот n должна быть константой,
[36:29.160 --> 36:37.680]  причем не просто константой, а compile time константой. Да, да, да, ну я пока еще не объяснял,
[36:37.680 --> 36:44.360]  что это такое, но да, вот то, что является параметрами шаблона, должно быть константой,
[36:44.360 --> 36:53.880]  но не просто константой, а compile time вычислимой константой. Что, например, ну, например,
[36:53.880 --> 37:02.720]  я очевидно не могу сделать так. Он дает написать просто constant без constant. Сейчас, сейчас,
[37:02.720 --> 37:14.640]  сейчас обсудим. Вот так я не могу сделать, очевидно. Вот, вот все посмотрите, пожалуйста,
[37:14.640 --> 37:24.800]  на этот пример и поймите, почему так невозможно просто сделать даже теоретически. Да, вот если
[37:24.800 --> 37:32.040]  вы пока не понимаете, если вам кажется, что казалось бы, что такого плохого я написал,
[37:32.040 --> 37:43.680]  вот пере, переосмыслите свои взгляды. Вот вам должно стать, вам должно стать очевидно и
[37:43.680 --> 37:49.840]  понятно, что вот это полный бред и компилятор такое скомпилировать не в состоянии. Он же знает,
[37:49.840 --> 38:00.120]  что переменная a тип знает и что он не знает, чему она равна на момент компиляции. Нет,
[38:00.120 --> 38:05.320]  он должен ее передать шаблонным параметрам. Это не то же самое, что передать обычным параметрам.
[38:05.320 --> 38:17.040]  Значит, шаблонные параметры это штука, которая подставляется в compile time и генерируется. Вот
[38:17.040 --> 38:29.160]  если у меня будет, вот понимаете ли вы следующее, что например f, вот такая f, вот такая f,
[38:29.160 --> 38:38.640]  вот такая f, ну и так далее. Это все разные f, у них разные адреса, например. То есть я могу,
[38:38.640 --> 38:43.160]  ну вот кто-то понимает, вот я остальных спрашиваю. Я могу спросить, какой адрес,
[38:43.160 --> 38:48.080]  ну сейчас конечно мне не выведется, потому что адреса функций так себе вводится на консоль.
[38:48.080 --> 38:54.680]  Но вот это все три разных функции с тремя разными адресами. В памяти прям это как три разных
[38:54.680 --> 39:00.760]  функции лежит, отдельных, не связанных друг с другом. То есть компилятор в compile time
[39:00.760 --> 39:05.240]  подставляет вместо шаблонных параметров конкретные числа, конкретные значения. Точно
[39:05.240 --> 39:11.120]  так же, как он подставляет типы, так он здесь подставляет конкретные числа. И это и компилятор
[39:11.120 --> 39:17.800]  генерирует код. Значит шаблоны это история про кодогенерацию. Компилятор фактически подставляя
[39:17.800 --> 39:24.080]  разные значения в compile time генерирует много разных f уже без угловых скобочек. И вот их
[39:24.080 --> 39:31.280]  компилирует уже нормально. Шаблонная кодогенерация это такой подэтап, предшествующий нормальной
[39:31.280 --> 39:38.680]  компиляции фактически. То есть теперь у нас появился еще такой новый этап. Подэтап компиляции
[39:38.680 --> 39:44.400]  это шаблонная подстановка. Сначала развертывание при процессор, потом шаблонные подстановки,
[39:44.400 --> 39:55.720]  потом только нормальная компиляция. Так вот, ну инклуды всякие. Когда инклуды разворачиваются при
[39:55.720 --> 40:01.240]  процессор я говорю. Это разворачивание при процессорах. Потом делается шаблонные подстановки,
[40:01.240 --> 40:10.640]  вот уже когда компилятор начинает работать. Вот, тем не менее, если я напишу вот так, то так все-таки
[40:10.640 --> 40:21.280]  можно. Но только надо проинциализировать эту a. Ну то есть если компилятор в состоянии в compile
[40:21.280 --> 40:27.840]  time понять чему равно значение константы и подставить, то он сумеет сгенерировать. Но
[40:27.840 --> 40:33.040]  какой пример константы, от которой нельзя сделать? Ну вот такой же, давайте я заведу.
[40:33.040 --> 40:41.600]  Арксинуса нуля? Нет, арксинуса нуля получится, почему нет? А у меня не получилось, когда я объявлял D.
[40:41.600 --> 40:55.440]  Ну там, давай ладно, я сейчас не буду этот пример разбирать, это долго, мы отвлечемся. Ну там
[40:55.440 --> 41:01.600]  констэкспорт должен быть в самой функции, поэтому оно должно работать вроде как. Он будет
[41:01.600 --> 41:11.800]  кастовать здесь W. Вот смотрите, сейчас. А да, sin. Вот, теперь я беру и говорю вот так и вот так
[41:11.800 --> 41:19.240]  уже конечно не выйдет у меня ничего. То есть вот это константа, но это не compile time константа.
[41:19.240 --> 41:33.600]  Вот. Is not usable in a constant expression. Вот для таких выражений существует понятие constant
[41:33.600 --> 41:39.640]  expression. Constant expression это выражение, которое вычисляется в момент компиляции и значение его
[41:39.640 --> 41:46.000]  известно на этапе компиляции. Вот сейчас B это не constant expression. Вот до этого A это было constant
[41:46.000 --> 41:50.400]  expression, потому что в compile time компилятор уже знает чему оно равно и знает что не поменяется,
[41:50.400 --> 41:58.480]  значит может подставить шаблон. А здесь он не знает и поэтому не может подставить шаблон. Зачем нужны
[41:58.480 --> 42:09.080]  шаблоны с числовыми аргументами? А они очень даже нужны. Например для чего? Чтобы что? Например
[42:09.680 --> 42:24.440]  или например матрице. Матрица M на N. Это же какой-то тип. Ну у вас допустим матрица из int размера
[42:24.440 --> 42:32.440]  10 на 10. Это же другой тип нежели матрица из int размера 5 на 10. Не так ли? Ну и вот. Вот вам
[42:32.440 --> 42:39.400]  пожалуйста тип параметризованный числом. Давайте я продемонстрирую вам такой еще один класс
[42:39.400 --> 42:45.600]  из стандартной билетеки. Да. А если мы заранее не знаем размер матрицы? Значит все провал,
[42:45.600 --> 42:55.780]  ничего не получится. Если нам размер матрицы дается в входный данный? Тут мне надо повторить
[42:55.780 --> 43:00.840]  мантру, которую я говорил в самом самом начале. C++ это статически типизированный язык,
[43:00.840 --> 43:08.600]  к счастью или к сожалению. Все типы должны быть известны на этапе компиляции. Если мы не знаем
[43:08.600 --> 43:15.640]  размер матрицы, то видимо надо все-таки его делать параметром не шаблона, а поля. Ну да,
[43:15.640 --> 43:23.040]  тогда его придется делать каким-то runtime параметром, а не compile-time параметром. А можно
[43:23.040 --> 43:28.020]  отнаследовать этот мусор, который был озвучен? Какой мусор? Подожди, подожди, я никого мусора
[43:28.020 --> 43:36.360]  сейчас не озвучил. Ты зря так. Матрицы это фиксированный размер? Да. Манити размер не фиксированный,
[43:36.360 --> 43:45.400]  как правило. Да. А кого из них ты мусором-то назвал? Я что-то не пойму. Нет, это не очень приятно.
[43:45.400 --> 43:58.800]  Ну ты можешь и что тебе это даст? Нет, отнаследовать ты можешь, а что тебе это даст-то? Ты в матрицах,
[43:58.800 --> 44:04.440]  которые без шаблонных параметров реализуют какие-то общие методы типа, а как они будут выглядеть?
[44:04.440 --> 44:13.960]  У тебя же все методы, они используют размер свои в себе. Как нормально работать с переходами,
[44:13.960 --> 44:18.920]  а не шаблонов и шаблонов? То есть если у нас есть тип не шаблонный, с которым мы как-то в общем
[44:18.920 --> 44:23.560]  виде работаем, и при этом мы хотим иметь такой же тип, но не шаблонный, чтобы с ним работать
[44:23.560 --> 44:30.040]  немножко по-другому. Я не понимаю, это какой-то очень абстрактный вопрос, очень-очень общий.
[44:30.040 --> 44:35.360]  Конкретный пример, если у нас есть матрицы, мы хотим иметь два вида матриц. Матрица конкретно
[44:35.360 --> 44:42.400]  размера 3 на 3, для них иметь отдельные методы. И матрица размера n на n, для которого у нас будет...
[44:42.800 --> 44:47.680]  Сделаем матрицы размера 3 на 3 специализацией матриц размера n на n. У тебя для матрицы 3 на 3
[44:47.680 --> 44:51.280]  будут свои отдельные методы, не похожие ни на кого другого.
[44:51.280 --> 44:53.640]  Нет, n на n у нас не зафиксированы.
[44:53.640 --> 44:58.440]  А если мы хотим параллельно с этим параметром, вот такие вот n и m, передавать пользователю, чтобы они...
[44:58.440 --> 45:04.920]  Если ты хочешь, чтобы n и m были runtime-параметрами, то шаблоны тебе никак не помогут.
[45:04.920 --> 45:08.600]  Все, шаблоны — это чисто compile-time-штуковина.
[45:10.600 --> 45:14.600]  Это просто два разных подхода к реализации.
[45:17.600 --> 45:23.600]  Давай я тебе сейчас покажу другой пример, который, собственно, и собирался показать, прежде чем...
[45:24.280 --> 45:31.280]  Глубоко компилятор запускает почувствения вот этих вот...
[45:31.280 --> 45:36.280]  Это мы обсудим через... Это мы в следующем пункте обсудим.
[45:36.280 --> 45:40.280]  То есть, если писать constar, но p, b и r, то все равно...
[45:40.280 --> 45:44.280]  А, ты про это... Не знаю, если честно.
[45:44.280 --> 45:46.280]  Насколько так глубоко можно осуществить?
[45:46.960 --> 45:50.960]  А... Я тебе...
[45:50.960 --> 45:56.960]  Есть одно специальное волшебное слово, которое заставляет компилятор досчитать на этапе компиляции.
[45:56.960 --> 45:58.960]  Оно называется constexpr.
[45:58.960 --> 46:00.960]  Но я не хочу сейчас про него рассказывать.
[46:00.960 --> 46:06.960]  Я хочу про него рассказать, когда мы уже более базовые вещи разберем.
[46:07.960 --> 46:09.960]  Вот, смотрите.
[46:09.960 --> 46:12.960]  Есть в стандартной библиотеке такой замечательный класс.
[46:12.960 --> 46:14.960]  Называется array.
[46:15.640 --> 46:17.640]  Знали о таком?
[46:21.640 --> 46:23.640]  А почему он подсветился сюда? Мы будем его разбирать.
[46:23.640 --> 46:25.640]  А вот мы его уже и разбираем.
[46:27.640 --> 46:29.640]  Все разобрали.
[46:29.640 --> 46:31.640]  Все разобрали. Он вот так и выглядит.
[46:35.640 --> 46:37.640]  Ну, в нем есть методы разные.
[46:39.640 --> 46:41.640]  В нем есть методы. Сейчас я вам только...
[46:41.640 --> 46:43.640]  Ну, давайте я вам браузер открою.
[46:44.320 --> 46:46.320]  Пошел.
[46:46.320 --> 46:48.320]  А у нас запись идет, да?
[46:48.320 --> 46:52.320]  Я просто в какой-то момент научился под запись не открывать свой браузер,
[46:52.320 --> 46:56.320]  а то там всякие ненужные вещи возникают.
[47:00.320 --> 47:03.320]  Потом все знают, что...
[47:03.320 --> 47:05.320]  Потом все знают, что браузеры имеют.
[47:05.320 --> 47:08.320]  Да, какие страницы я в свободное время открываю.
[47:08.320 --> 47:10.320]  Вот, значит...
[47:10.320 --> 47:12.320]  Ну вот, std array.
[47:13.000 --> 47:15.000]  Неужели справочник будет тоже?
[47:21.000 --> 47:23.000]  Вот. Что это за штука?
[47:23.000 --> 47:25.000]  Ну, это... Это что за покемон?
[47:27.000 --> 47:29.000]  Это просто массив фиксированного размера.
[47:32.000 --> 47:34.000]  Большой вопрос, а на хрена?
[47:36.000 --> 47:38.000]  На хрена.
[47:38.000 --> 47:40.000]  А это очень удобно.
[47:40.000 --> 47:42.000]  Потому что...
[47:42.680 --> 47:45.680]  В ООП парадигме реализовывают массив фиксированного размера.
[47:45.680 --> 47:46.680]  Почему это удобно?
[47:46.680 --> 47:48.680]  Ну, обычные массивы, сишные,
[47:48.680 --> 47:52.680]  они обладают разными странными неприятными свойствами.
[47:52.680 --> 47:55.680]  Например, они кастуются к указателям неявно.
[47:55.680 --> 47:58.680]  Или их нельзя друг к другу присваивать, скажем.
[47:58.680 --> 48:01.680]  Вы помните, что массивы нельзя друг к другу присваивать, например?
[48:01.680 --> 48:02.680]  Да.
[48:02.680 --> 48:04.680]  Вот. Или нельзя там делать...
[48:04.680 --> 48:06.680]  Что там еще с ними нельзя делать?
[48:06.680 --> 48:09.680]  Можно деструктур прописать ему или тогда памятник.
[48:10.360 --> 48:12.360]  Нет, деструктур у него и так...
[48:12.360 --> 48:14.360]  В смысле, кому?
[48:14.360 --> 48:16.360]  Не, не, не.
[48:16.360 --> 48:18.360]  Вот.
[48:18.360 --> 48:20.360]  А этот STDRA, им пользоваться очень удобно.
[48:20.360 --> 48:22.360]  Ты просто берешь и...
[48:22.360 --> 48:25.360]  Ну, то есть, у него есть все методы, как у обычного контейнера.
[48:25.360 --> 48:27.360]  То есть, можно квадратными скобочками, front, back,
[48:27.360 --> 48:32.360]  итераторы, размер, значит, empty.
[48:32.360 --> 48:34.360]  Вот.
[48:34.360 --> 48:36.360]  Ну, вот просто пример.
[48:36.360 --> 48:38.360]  Пример использования, да?
[48:39.040 --> 48:41.040]  Чего? Сайз? Что?
[48:41.040 --> 48:43.040]  Да, да, да.
[48:43.040 --> 48:45.040]  Вот.
[48:45.040 --> 48:47.040]  Код чего?
[48:47.040 --> 48:49.040]  Мой?
[48:49.040 --> 48:51.040]  Ой, ну вот все.
[48:51.040 --> 48:54.040]  Открыл браузер, и вы увидели много чего лишнего.
[48:58.040 --> 49:00.040]  Ну вот.
[49:00.040 --> 49:02.040]  Вот, собственно, все, что этот массив хранит.
[49:02.040 --> 49:04.040]  Он не динамический.
[49:04.040 --> 49:07.040]  Он просто хранит на стеке.
[49:07.720 --> 49:09.720]  В полях.
[49:09.720 --> 49:11.720]  То есть, массив из N элементов.
[49:11.720 --> 49:13.720]  Ну, собственно, его можно создать от N элементов.
[49:13.720 --> 49:15.720]  Ну, можете посмотреть, что вы можете создать.
[49:15.720 --> 49:17.720]  Здесь N это константа времени компиляции.
[49:17.720 --> 49:19.720]  То есть, это одномерный такой массив.
[49:19.720 --> 49:21.720]  По сути, это одномерный вектор.
[49:21.720 --> 49:23.720]  Но константного размера.
[49:23.720 --> 49:27.720]  И пользоваться таким массивом, конечно же, гораздо эффективнее,
[49:27.720 --> 49:31.720]  чем вектором, если вам не нужно
[49:31.720 --> 49:33.720]  размер менять в runtime.
[49:33.720 --> 49:35.720]  И удобно.
[49:36.400 --> 49:38.400]  Потому что этот массив ведет себя, как обычно, переменно.
[49:38.400 --> 49:40.400]  Присваивать можно его друг к другу.
[49:40.400 --> 49:42.400]  Ну и так далее.
[49:42.400 --> 49:44.400]  Разумеется, в прочем, если вы заведете такой массив
[49:44.400 --> 49:46.400]  слишком большого размера, например,
[49:46.400 --> 49:50.400]  не знаю, 100 миллионов,
[49:50.400 --> 49:53.400]  то вы получите секфолд, потому что стекворфлоу.
[49:53.400 --> 49:55.400]  Но, да.
[49:55.400 --> 49:57.400]  Вот, как бы,
[49:57.400 --> 49:59.400]  как он понимает,
[49:59.400 --> 50:01.400]  какое количество массивов нужно выделить?
[50:01.400 --> 50:03.400]  Понятно, что мы фиксируем размерный,
[50:03.400 --> 50:05.400]  мы можем как-нибудь форики, в зависимости от runtime
[50:06.080 --> 50:08.080]  сделать несколько таких массивов.
[50:08.080 --> 50:10.080]  Не очень понятно, как он на этапе компиляции выделит под них файлы.
[50:10.080 --> 50:12.080]  Как он понимает, сколько интов надо выделить тебе?
[50:12.080 --> 50:14.080]  Так же, как и столько массивов.
[50:14.080 --> 50:16.080]  Ну, обычная переменная.
[50:16.080 --> 50:18.080]  Это же на стеке.
[50:18.080 --> 50:20.080]  То есть, он по очереди будет на стеке.
[50:20.080 --> 50:22.080]  Это же переменная на стеке.
[50:22.080 --> 50:24.080]  Как он понимает.
[50:24.080 --> 50:26.080]  То есть, мы не можем считать переменную и создать array?
[50:28.080 --> 50:31.080]  Размера n, где n в виде нос клавиатуры нет, не можем.
[50:31.080 --> 50:33.080]  В этом и смысл array.
[50:33.080 --> 50:35.080]  Размер известен на этапе компиляции.
[50:35.760 --> 50:37.760]  Вот.
[50:37.760 --> 50:39.760]  Ну, а соответственно,
[50:39.760 --> 50:41.760]  логичная штука,
[50:41.760 --> 50:43.760]  которая вам предстоит,
[50:43.760 --> 50:45.760]  логичная следующая идея.
[50:45.760 --> 50:47.760]  Это двумерный массив размера...
[50:55.760 --> 50:57.760]  Вот.
[50:59.760 --> 51:01.760]  Такой замечательный класс.
[51:01.760 --> 51:03.760]  Давайте я бы...
[51:04.440 --> 51:06.440]  Давайте я бы сказал...
[51:10.440 --> 51:12.440]  Я бы причем даже написал вот так.
[51:16.440 --> 51:18.440]  И здесь написал...
[51:21.440 --> 51:23.440]  Вот что.
[51:23.440 --> 51:25.440]  Вы уже,
[51:25.440 --> 51:27.440]  наверное же,
[51:27.440 --> 51:29.440]  дошли до матриц над произвольным полем,
[51:29.440 --> 51:31.440]  или нет?
[51:31.440 --> 51:33.440]  Ну вот, видите, как хорошо?
[51:34.120 --> 51:36.120]  Ну...
[51:36.120 --> 51:38.120]  Ну как-то не очень хорошо
[51:38.120 --> 51:40.120]  типы одной буквы называть,
[51:40.120 --> 51:42.120]  если это не числа.
[51:42.120 --> 51:44.120]  Так что, подожди, m и n это не типы.
[51:44.120 --> 51:46.120]  m и n это константы.
[51:46.120 --> 51:48.120]  t и u без d и k.
[51:48.120 --> 51:50.120]  Ну t это, как бы,
[51:50.120 --> 51:52.120]  такое...
[51:52.120 --> 51:54.120]  Соглашение.
[51:54.120 --> 51:56.120]  t и u соглашение, а f это...
[51:56.120 --> 51:58.120]  Ну да, да, да.
[51:58.120 --> 52:00.120]  Нет, ну,
[52:00.120 --> 52:02.120]  здесь скорее дело вот в чем.
[52:02.800 --> 52:04.800]  Просто это вам, это уже прям,
[52:04.800 --> 52:06.800]  класс, который не постоянно реализовывается.
[52:06.800 --> 52:08.800]  Это все были учебные примеры, а это уже такой настоящий,
[52:08.800 --> 52:10.800]  жизненный пример. Вот, ну и все.
[52:10.800 --> 52:12.800]  И здесь вы храните фактически
[52:12.800 --> 52:14.800]  массив размера m на n,
[52:14.800 --> 52:16.800]  или вектор размера m на n.
[52:16.800 --> 52:18.800]  Ну как хотите.
[52:18.800 --> 52:20.800]  Можете массив c размера m на n хранить.
[52:20.800 --> 52:22.800]  Вот.
[52:28.800 --> 52:30.800]  У вас будет вот так.
[52:31.480 --> 52:33.480]  Надо сделать.
[52:33.480 --> 52:35.480]  Вот, то есть, смотрите,
[52:35.480 --> 52:37.480]  матрицы, они же могут быть над разным.
[52:37.480 --> 52:39.480]  Они могут быть над
[52:39.480 --> 52:41.480]  рациональными числами,
[52:41.480 --> 52:43.480]  а могут быть над...
[52:47.480 --> 52:49.480]  Над веществными уж тогда.
[52:49.480 --> 52:51.480]  Но...
[52:51.480 --> 52:53.480]  Еще, я вас прошу
[52:53.480 --> 52:55.480]  реализовать вот такой класс.
[52:56.160 --> 52:58.160]  А...
[52:58.160 --> 53:00.160]  Да.
[53:02.160 --> 53:04.160]  Ну, смотрите,
[53:04.160 --> 53:06.160]  у вас бывают вычеты
[53:06.160 --> 53:08.160]  по моделю m.
[53:08.160 --> 53:10.160]  Да.
[53:10.160 --> 53:12.160]  И над ними тоже можно делать
[53:12.160 --> 53:14.160]  матрицы.
[53:14.160 --> 53:16.160]  Соответственно,
[53:16.160 --> 53:18.160]  матрицы у меня будут
[53:18.160 --> 53:20.160]  как над...
[53:20.160 --> 53:22.160]  Ну, они будут над разными
[53:22.160 --> 53:24.160]  штуками пытаться строиться.
[53:24.840 --> 53:26.840]  Бывают матрицы над рациональными числами.
[53:26.840 --> 53:28.840]  Соответственно, там...
[53:28.840 --> 53:30.840]  Операции там, обращения,
[53:30.840 --> 53:32.840]  всего, определители и так далее
[53:32.840 --> 53:34.840]  будут нормально вычтяться.
[53:34.840 --> 53:36.840]  Шаблонный f of t?
[53:36.840 --> 53:38.840]  Шаблонный f of t? Нет.
[53:38.840 --> 53:40.840]  Кажется, не придется.
[53:40.840 --> 53:42.840]  А чего ты там так боишься?
[53:42.840 --> 53:44.840]  Пиши шаблонный f of t.
[53:44.840 --> 53:46.840]  А зачем f of t?
[53:46.840 --> 53:48.840]  А вот хотелось бы
[53:48.840 --> 53:50.840]  как-то
[53:50.840 --> 53:52.840]  compile time запрещать
[53:53.520 --> 53:55.520]  ситуацию, когда
[53:55.520 --> 53:57.520]  фил не является моим лидером.
[53:57.520 --> 53:59.520]  Да!
[53:59.520 --> 54:01.520]  Ты прям...
[54:01.520 --> 54:03.520]  Я рад, что мои желания
[54:03.520 --> 54:05.520]  совпадают с вашими. Это тоже
[54:05.520 --> 54:07.520]  надо будет делать.
[54:07.520 --> 54:09.520]  Значит, в compile time
[54:09.520 --> 54:11.520]  ну, это
[54:11.520 --> 54:13.520]  небольшое забегание вперед,
[54:13.520 --> 54:15.520]  но сейчас мы это сделаем, да.
[54:15.520 --> 54:17.520]  Мы сейчас научимся в compile time проверять
[54:17.520 --> 54:19.520]  на простоту.
[54:19.520 --> 54:21.520]  А как это проверить?
[54:22.200 --> 54:24.200]  А как это проверять в compile time?
[54:24.200 --> 54:26.200]  Что ты имеешь в виду?
[54:26.200 --> 54:28.200]  Что значит проверять в compile time, что оно является полем?
[54:28.200 --> 54:30.200]  Как ты в compile time будешь проверять,
[54:30.200 --> 54:32.200]  например, что сложение ассоциативно?
[54:32.200 --> 54:34.200]  Я не очень понимаю.
[54:34.200 --> 54:36.200]  Сложение ассоциативно?
[54:36.200 --> 54:38.200]  Чего?
[54:38.200 --> 54:40.200]  Сложение...
[54:40.200 --> 54:42.200]  Ты веришь?
[54:42.200 --> 54:44.200]  Ну, вот в то,
[54:44.200 --> 54:46.200]  что выполним отделение,
[54:46.200 --> 54:48.200]  верить никак нельзя.
[54:48.200 --> 54:50.200]  То есть, что именно
[54:50.880 --> 54:52.880]  ты хочешь, формально,
[54:52.880 --> 54:54.880]  с точки зрения плюсов, что означает твои условия,
[54:54.880 --> 54:56.880]  что оно является полем?
[54:56.880 --> 54:58.880]  Что в нем поддерживаются определенные операции.
[54:58.880 --> 55:00.880]  Без уточнения
[55:00.880 --> 55:02.880]  свойств этих операций.
[55:02.880 --> 55:04.880]  Такое можно делать.
[55:04.880 --> 55:06.880]  Для этого служат
[55:06.880 --> 55:08.880]  сфинае, так называемые, а еще
[55:08.880 --> 55:10.880]  концепты, но это будет конец второго
[55:10.880 --> 55:12.880]  семестра. Мы...
[55:12.880 --> 55:14.880]  В общем, это можно, но это
[55:14.880 --> 55:16.880]  очень весело, классно
[55:16.880 --> 55:18.880]  и будем мы это делать весной.
[55:19.560 --> 55:21.560]  Сейчас пока мы будем этого делать,
[55:21.560 --> 55:23.560]  потому что это вам и так хватит.
[55:23.560 --> 55:25.560]  Да, что за вопрос?
[55:25.560 --> 55:27.560]  Нельзя в качестве шаблонного поля
[55:27.560 --> 55:29.560]  для поля...
[55:29.560 --> 55:31.560]  Шаблонного поля для поля?
[55:31.560 --> 55:33.560]  Передать поле.
[55:33.560 --> 55:35.560]  Передавать таблицу сложения и
[55:35.560 --> 55:37.560]  умножения. Что значит, передавать таблицу?
[55:37.560 --> 55:39.560]  Это как?
[55:39.560 --> 55:41.560]  Но мы же можем
[55:41.560 --> 55:43.560]  передавать миру.
[55:43.560 --> 55:45.560]  Давайте передавать массив.
[55:45.560 --> 55:47.560]  Нет, я не понимаю.
[55:48.240 --> 55:50.240]  Как ты таблицу на генерешену
[55:50.240 --> 55:52.240]  сделаешь?
[55:52.240 --> 55:54.240]  Генерешен уходит от 4 элемента.
[55:54.240 --> 55:56.240]  Ты делаешь...
[55:56.240 --> 55:58.240]  Я не очень
[55:58.240 --> 56:00.240]  понимаю, что вы хотите сделать.
[56:00.240 --> 56:02.240]  Давайте я расскажу, что
[56:02.240 --> 56:04.240]  можно делать и что вам нужно будет
[56:04.240 --> 56:06.240]  сделать. Тихо. Давайте я расскажу,
[56:06.240 --> 56:08.240]  что можно делать, что нужно будет сделать,
[56:08.240 --> 56:10.240]  а фантазии на тему, а что еще
[56:10.240 --> 56:12.240]  теоретически можно было бы сделать.
[56:12.240 --> 56:14.240]  Мы потом, как-нибудь, не в учебное время
[56:14.240 --> 56:16.240]  в чате пообсуждаем, потому что иначе
[56:16.240 --> 56:18.240]  передавать не успеем ничего.
[56:18.240 --> 56:20.240]  Короче, вот.
[56:20.240 --> 56:22.240]  Класс вычетов по моделю N
[56:22.240 --> 56:24.240]  и класс
[56:24.240 --> 56:26.240]  матриц
[56:26.240 --> 56:28.240]  размера M на N над произвольным
[56:28.240 --> 56:30.240]  полем.
[56:30.240 --> 56:32.240]  Вот.
[56:32.240 --> 56:34.240]  Кстати,
[56:34.240 --> 56:36.240]  как будет, например,
[56:36.240 --> 56:38.240]  выглядеть оператор умножения
[56:38.240 --> 56:40.240]  двух матриц? Это может быть кому-то
[56:40.240 --> 56:42.240]  не очевидно, давайте напишем.
[56:42.240 --> 56:44.240]  Но он будет не членом.
[56:44.240 --> 56:46.240]  Вот как будет выглядеть
[56:46.240 --> 56:48.240]  давай, вот кто понимает,
[56:48.240 --> 56:50.240]  как объявить умножение матриц?
[56:50.240 --> 56:52.240]  С такими вот.
[56:52.240 --> 56:54.240]  Ну, блин,
[56:54.240 --> 56:56.240]  темплей, это очевидно.
[56:56.240 --> 56:58.240]  А дальше что?
[56:58.240 --> 57:00.240]  Сайс T, M,
[57:00.240 --> 57:02.240]  сайс T,
[57:04.240 --> 57:06.240]  N,
[57:06.240 --> 57:08.240]  сайс T, K.
[57:08.240 --> 57:10.240]  Ну,
[57:10.240 --> 57:12.240]  и type name.
[57:12.240 --> 57:14.240]  Ну, давайте
[57:14.240 --> 57:16.240]  все-таки field.
[57:18.240 --> 57:20.240]  А то, что
[57:20.240 --> 57:22.240]  Irrational прописал это по дефолту?
[57:22.240 --> 57:24.240]  Да, это шаблонный параметр по умолчанию,
[57:24.240 --> 57:26.240]  я про это рассказывал в прошлый раз.
[57:26.240 --> 57:28.240]  А здесь почему не прописал параметр?
[57:28.240 --> 57:30.240]  Ну, потому что
[57:30.240 --> 57:32.240]  это же
[57:32.240 --> 57:34.240]  оператор, я же от двух матриц его вызываю,
[57:34.240 --> 57:36.240]  когда я буду вызывать его от двух матриц,
[57:36.240 --> 57:38.240]  уже по матрицам понятно, какой field.
[57:38.240 --> 57:40.240]  Вот.
[57:40.240 --> 57:42.240]  Что будет возвращать?
[57:42.240 --> 57:44.240]  Matrix.
[57:44.240 --> 57:46.240]  Размера M на K.
[57:46.240 --> 57:48.240]  Field.
[57:48.240 --> 57:50.240]  И вот здесь, кстати,
[57:50.240 --> 57:52.240]  я могу не писать, кажется.
[57:52.240 --> 57:54.240]  А, нет, должен писать, потому что оно
[57:54.240 --> 57:56.240]  должно быть таким же, как там.
[57:56.240 --> 57:58.240]  Оператор умножить
[57:58.240 --> 58:00.240]  от
[58:00.240 --> 58:02.240]  const matrix
[58:02.240 --> 58:04.240]  обожаю.
[58:04.240 --> 58:06.240]  M запятая
[58:06.240 --> 58:08.240]  M
[58:10.240 --> 58:12.240]  Подожите, я так не хотел.
[58:12.240 --> 58:14.240]  Я не знаю почему.
[58:14.240 --> 58:16.240]  M запятая
[58:16.240 --> 58:18.240]  field
[58:18.240 --> 58:20.240]  ampersand
[58:24.240 --> 58:26.240]  const
[58:26.240 --> 58:28.240]  matrix
[58:28.240 --> 58:30.240]  N, K
[58:30.240 --> 58:32.240]  field
[58:32.240 --> 58:34.240]  ampersand.
[58:34.240 --> 58:36.240]  Если я...
[58:36.240 --> 58:38.240]  Ну да, имена я потом.
[58:38.240 --> 58:40.240]  Соответственно, если я
[58:40.240 --> 58:42.240]  начну таким образом пытаться перемножить
[58:42.240 --> 58:44.240]  матрицы несоответствующих размеров, я получу
[58:44.240 --> 58:46.240]  CE.
[58:46.240 --> 58:48.240]  Или если я буду пытаться перемножить
[58:48.240 --> 58:50.240]  матрицы
[58:50.240 --> 58:52.240]  над разными
[58:52.240 --> 58:54.240]  полями, я тоже получу CE.
[58:56.240 --> 58:58.240]  Вот.
[58:58.240 --> 59:00.240]  Могу.
[59:00.240 --> 59:02.240]  Ну, секрет.
[59:02.240 --> 59:04.240]  Но я могу.
[59:04.240 --> 59:06.240]  И вас тоже научу скоро.
[59:14.240 --> 59:16.240]  На самом деле
[59:16.240 --> 59:18.240]  есть
[59:18.240 --> 59:20.240]  лайфхак, плюсовый,
[59:20.240 --> 59:22.240]  как делать проверку.
[59:22.240 --> 59:24.240]  На самом деле я уже делал проверку
[59:24.240 --> 59:26.240]  на CE, если вы внимательно
[59:26.240 --> 59:28.240]  смотрели.
[59:28.240 --> 59:30.240]  Когда, например, я проверял, что
[59:30.240 --> 59:32.240]  константной строки ничего нельзя
[59:32.240 --> 59:34.240]  присваивать, как я это проверял.
[59:34.240 --> 59:36.240]  Есть такая метафлукция.
[59:36.240 --> 59:38.240]  std is assignable. Я беру квадратные скобочки
[59:38.240 --> 59:40.240]  от вашей строки и проверяю, что ей
[59:40.240 --> 59:42.240]  допустимо присвоить char.
[59:42.240 --> 59:44.240]  Она возвращает true, если можно,
[59:44.240 --> 59:46.240]  и false иначе.
[59:46.240 --> 59:48.240]  Но это другое дело. То есть можно просто
[59:48.240 --> 59:50.240]  проверить, определённый ли метод в классе.
[59:50.240 --> 59:52.240]  Вот.
[59:52.240 --> 59:54.240]  В общем, короче, существуют способы
[59:54.240 --> 59:56.240]  это написать, и это мы с вами тоже
[59:56.240 --> 59:58.240]  разберём, как делать.
[59:58.240 --> 01:00:00.240]  Но есть более простой способ
[01:00:00.240 --> 01:00:02.240]  для тех, кто плюсов не знает.
[01:00:02.240 --> 01:00:04.240]  Я же могу просто написать
[01:00:04.240 --> 01:00:06.240]  G++
[01:00:18.240 --> 01:00:20.240]  Но я могу написать G++ ваш код
[01:00:22.240 --> 01:00:24.240]  или G++
[01:00:24.240 --> 01:00:26.240]  G++ маленький тестик
[01:00:26.240 --> 01:00:28.240]  или G++
[01:00:28.240 --> 01:00:30.240]  следующий маленький тестик и так далее.
[01:00:30.240 --> 01:00:32.240]  И в самом только конце
[01:00:32.240 --> 01:00:34.240]  G++ уже нормальный код.
[01:00:34.240 --> 01:00:36.240]  Ну, вы же
[01:00:36.240 --> 01:00:38.240]  знаете, как работают
[01:00:38.240 --> 01:00:40.240]  аргументы командной строки, двойная персант,
[01:00:40.240 --> 01:00:42.240]  двойная вертикальная черта.
[01:00:42.240 --> 01:00:44.240]  Вот компилятор при неуспешной компиляции
[01:00:44.240 --> 01:00:46.240]  возвращает код ошибки 1.
[01:00:46.240 --> 01:00:48.240]  Соответственно, будет продолжаться
[01:00:48.240 --> 01:00:50.240]  выполнение этого конвейера G++
[01:00:50.240 --> 01:00:52.240]  или G++, только если
[01:00:52.240 --> 01:00:54.240]  неуспешной была предыдущая компиляция.
[01:00:54.240 --> 01:00:56.240]  Вот и всё.
[01:00:56.240 --> 01:00:58.240]  И у вас просто не дойдёт компиляции до нужного файла
[01:00:58.240 --> 01:01:00.240]  и вы получите странный вердикт,
[01:01:00.240 --> 01:01:02.240]  что ничего не удалось завершить.
[01:01:02.240 --> 01:01:04.240]  Так что да, я смогу в контесте
[01:01:04.240 --> 01:01:06.240]  проверить, что у вас не компилируется
[01:01:06.240 --> 01:01:08.240]  то, что не должно компилироваться.
[01:01:08.240 --> 01:01:10.240]  Вот, поэтому да.
[01:01:10.240 --> 01:01:12.240]  Можно просто будет
[01:01:12.240 --> 01:01:14.240]  сделать так, как Яндекс.Контест обычно
[01:01:14.240 --> 01:01:16.240]  делает СЕ и без лода.
[01:01:16.240 --> 01:01:18.240]  Это он так редко делает.
[01:01:18.240 --> 01:01:20.240]  Не, после этих выходных я вообще
[01:01:20.240 --> 01:01:22.240]  не пастор Яндекс.Контеста стал, мне кажется.
[01:01:22.240 --> 01:01:24.240]  Что угодно могу проверить Яндекс.Контеста.
[01:01:30.240 --> 01:01:32.240]  Так, господа,
[01:01:32.240 --> 01:01:34.240]  продолжаем. Нам ещё надо
[01:01:34.240 --> 01:01:36.240]  успеть
[01:01:36.240 --> 01:01:38.240]  много чего.
[01:01:38.240 --> 01:01:40.240]  Да, смотрите,
[01:01:40.240 --> 01:01:42.240]  ну, вот
[01:01:42.240 --> 01:01:44.240]  какие типы могут быть параметры мешаблона?
[01:01:44.240 --> 01:01:46.240]  Ну числа могут быть, могут быть
[01:01:46.240 --> 01:01:48.240]  чары, могут быть, ну вообще любые
[01:01:48.240 --> 01:01:50.240]  числочисленные типы.
[01:01:50.240 --> 01:01:52.240]  Вот.
[01:01:52.240 --> 01:01:54.240]  А может ли дабл быть параметром
[01:01:54.240 --> 01:01:56.240]  шаблона?
[01:02:00.240 --> 01:02:02.240]  Могут ли камень не платить налоги?
[01:02:02.240 --> 01:02:04.240]  Может ли дабл быть параметром шаблона?
[01:02:04.240 --> 01:02:06.240]  А
[01:02:06.240 --> 01:02:08.240]  стринг
[01:02:08.240 --> 01:02:10.240]  раз и не может? У нас вообще
[01:02:10.240 --> 01:02:12.240]  был пример
[01:02:12.240 --> 01:02:14.240]  а стринг не может.
[01:02:14.240 --> 01:02:16.240]  Ну давайте
[01:02:16.240 --> 01:02:18.240]  попробуем.
[01:02:18.240 --> 01:02:20.240]  Но кажется нет.
[01:02:20.240 --> 01:02:22.240]  Кажется, потому что
[01:02:22.240 --> 01:02:24.240]  я не уверен, что они там добавили все
[01:02:24.240 --> 01:02:26.240]  плюс-плюс 20, может и это тоже добавили.
[01:02:26.240 --> 01:02:28.240]  Но нет, всё-таки не может.
[01:02:28.240 --> 01:02:30.240]  Потому что
[01:02:30.240 --> 01:02:32.240]  так решил. Ну короче не может.
[01:02:32.240 --> 01:02:34.240]  Ну потому что
[01:02:34.240 --> 01:02:36.240]  это довольно-таки
[01:02:36.240 --> 01:02:38.240]  бессмысленно. Ну да, типа как
[01:02:38.240 --> 01:02:40.240]  в compile-time дабл хранить?
[01:02:40.240 --> 01:02:42.240]  Это можно было бы делать, но
[01:02:42.240 --> 01:02:44.240]  Дабл, наверное, понятно.
[01:02:48.240 --> 01:02:50.240]  Да, ну то есть даже
[01:02:50.240 --> 01:02:52.240]  с плюс-плюс 20 нельзя дабл
[01:02:52.240 --> 01:02:54.240]  делать параметром шаблона.
[01:02:54.240 --> 01:02:56.240]  Вот может ли стринг быть параметром шаблона?
[01:02:56.240 --> 01:02:58.240]  А как вы это себе представляете?
[01:02:58.240 --> 01:03:00.240]  Там же динамическая память должна выделяться.
[01:03:02.240 --> 01:03:04.240]  А там, что не должна выделиться
[01:03:04.240 --> 01:03:06.240]  динамическая память выделяться?
[01:03:06.240 --> 01:03:08.240]  А там, что не
[01:03:08.240 --> 01:03:10.240]  должна?
[01:03:10.240 --> 01:03:12.240]  Нет, он сейчас звёздочки...
[01:03:12.240 --> 01:03:14.240]  Если передавать строку элитерал,
[01:03:14.240 --> 01:03:16.240]  он ничего не выделяется в динамической памяти.
[01:03:16.240 --> 01:03:18.240]  Ну на самом деле
[01:03:24.240 --> 01:03:26.240]  сейчас правда, конечно
[01:03:26.240 --> 01:03:28.240]  будет немного странно,
[01:03:28.240 --> 01:03:30.240]  но давайте я вот так сделаю.
[01:03:32.240 --> 01:03:34.240]  А...
[01:03:34.240 --> 01:03:36.240]  Ладно.
[01:03:36.240 --> 01:03:38.240]  Значит...
[01:03:40.240 --> 01:03:42.240]  Как видите...
[01:03:46.240 --> 01:03:48.240]  Да, because it's not structural.
[01:03:48.240 --> 01:03:50.240]  Короче, нет, не может.
[01:03:50.240 --> 01:03:52.240]  Но на самом деле
[01:03:52.240 --> 01:03:54.240]  с плюс-плюс 20
[01:03:54.240 --> 01:03:56.240]  ослабили ограничение на то, что может быть параметром шаблона,
[01:03:56.240 --> 01:03:58.240]  и там теперь параметрами
[01:03:58.240 --> 01:04:00.240]  шаблона могут быть классовые типы.
[01:04:00.240 --> 01:04:02.240]  Вот до с плюс-плюс 20 параметрами шаблона
[01:04:02.240 --> 01:04:04.240]  могли быть только целочистые типы,
[01:04:04.240 --> 01:04:06.240]  ну да и всё, в общем-то.
[01:04:06.240 --> 01:04:08.240]  А начиная с плюс-плюс 20 параметрами
[01:04:08.240 --> 01:04:10.240]  шаблонов могут быть
[01:04:10.240 --> 01:04:12.240]  объекты некоторых классов, но
[01:04:12.240 --> 01:04:14.240]  не любых.
[01:04:14.240 --> 01:04:16.240]  Ну...
[01:04:16.240 --> 01:04:18.240]  Честно говоря, я не помню какие там формальные
[01:04:18.240 --> 01:04:20.240]  требования. Вот стринг не подходит,
[01:04:20.240 --> 01:04:22.240]  но если я заведу какую-нибудь простую структурку,
[01:04:22.240 --> 01:04:24.240]  в которой будет несколько...
[01:04:24.240 --> 01:04:26.240]  Не знаю, не помню.
[01:04:26.240 --> 01:04:28.240]  Не пользовался этим.
[01:04:28.240 --> 01:04:30.240]  Шаблон массив передавать, что ли?
[01:04:30.240 --> 01:04:32.240]  Ээээ...
[01:04:32.240 --> 01:04:34.240]  Чё?
[01:04:34.240 --> 01:04:36.240]  А рей передавать?
[01:04:36.240 --> 01:04:38.240]  СТД рей параметром
[01:04:38.240 --> 01:04:40.240]  шаблона быть, кажется, не мог.
[01:04:40.240 --> 01:04:42.240]  Да, не мог, нет, не мог.
[01:04:42.240 --> 01:04:44.240]  А вот сейчас мог.
[01:04:44.240 --> 01:04:46.240]  Ну это, ты довольно странный,
[01:04:46.240 --> 01:04:48.240]  ну вот, например, такое, кажется, можно, да.
[01:04:52.240 --> 01:04:54.240]  Но только рей
[01:04:54.240 --> 01:04:56.240]  непонятно что, сейчас я его заинклужу.
[01:04:56.240 --> 01:04:58.240]  Можно сейчас написать
[01:04:58.240 --> 01:05:00.240]  типа...
[01:05:00.240 --> 01:05:02.240]  Ну всё.
[01:05:02.240 --> 01:05:04.240]  Вот, например, СТД рей,
[01:05:04.240 --> 01:05:06.240]  это вполне себе нормальный
[01:05:06.240 --> 01:05:08.240]  параметр для шаблона,
[01:05:08.240 --> 01:05:10.240]  потому что он, ну, просто на стеке
[01:05:10.240 --> 01:05:12.240]  хранит 10 тинтов. Пожалуйста,
[01:05:12.240 --> 01:05:14.240]  можно параметром шаблона делать
[01:05:14.240 --> 01:05:16.240]  рей, то есть, например, я могу теперь
[01:05:16.240 --> 01:05:18.240]  написать так.
[01:05:18.240 --> 01:05:20.240]  f от
[01:05:20.240 --> 01:05:22.240]  1, 2, 3, 4, 5
[01:05:22.240 --> 01:05:24.240]  в фигурных скобочках.
[01:05:24.240 --> 01:05:26.240]  А остальные
[01:05:26.240 --> 01:05:28.240]  нулями проницилизируются.
[01:05:28.240 --> 01:05:30.240]  О, как вам такое?
[01:05:30.240 --> 01:05:32.240]  Сейчас, а указатель
[01:05:32.240 --> 01:05:34.240]  я тоже...
[01:05:34.240 --> 01:05:36.240]  Ну нет, он не может
[01:05:36.240 --> 01:05:38.240]  из initializer листа рей сделать
[01:05:38.240 --> 01:05:40.240]  в compile-time.
[01:05:40.240 --> 01:05:42.240]  Ну, короче, можно сделать...
[01:05:42.240 --> 01:05:44.240]  Нужно ещё написать слово
[01:05:44.240 --> 01:05:46.240]  constexpr, чтобы рей compile-time
[01:05:46.240 --> 01:05:48.240]  создался, и дальше получится.
[01:05:48.240 --> 01:05:50.240]  Короче, я не хочу, я сейчас
[01:05:50.240 --> 01:05:52.240]  не буду это про это дальше говорить,
[01:05:52.240 --> 01:05:54.240]  не знаю, попробую.
[01:05:54.240 --> 01:05:56.240]  Я не буду пробовать сейчас.
[01:05:56.240 --> 01:05:58.240]  Указатель, думаю,
[01:05:58.240 --> 01:06:00.240]  можно.
[01:06:00.240 --> 01:06:02.240]  Указатель, думаю, можно.
[01:06:02.240 --> 01:06:04.240]  Но
[01:06:04.240 --> 01:06:06.240]  я не хочу сейчас.
[01:06:06.240 --> 01:06:08.240]  Я не хочу.
[01:06:08.240 --> 01:06:10.240]  Короче, сейчас пока
[01:06:10.240 --> 01:06:12.240]  от вас требуется только уметь
[01:06:12.240 --> 01:06:14.240]  пользоваться шаблонами с параметрами,
[01:06:14.240 --> 01:06:16.240]  являющимися типами,
[01:06:16.240 --> 01:06:18.240]  с параметрами, являющимися целыми числами
[01:06:18.240 --> 01:06:20.240]  и булями. Вот, все эти
[01:06:20.240 --> 01:06:22.240]  приколы примочки C++20
[01:06:22.240 --> 01:06:24.240]  мы обсудим, когда
[01:06:24.240 --> 01:06:26.240]  там, короче, веслой.
[01:06:26.240 --> 01:06:28.240]  Сейчас пока хватит и без этого
[01:06:28.240 --> 01:06:30.240]  вам с чем возиться.
[01:06:30.240 --> 01:06:32.240]  Но это всё ещё
[01:06:32.240 --> 01:06:34.240]  не все виды шаблонных параметров,
[01:06:34.240 --> 01:06:36.240]  которые бывают. Бывают
[01:06:36.240 --> 01:06:38.240]  шаблонные параметры, являющиеся
[01:06:38.240 --> 01:06:40.240]  типами, бывают шаблонные параметры,
[01:06:40.240 --> 01:06:42.240]  являющиеся числами
[01:06:42.240 --> 01:06:44.240]  ну или переменными,
[01:06:44.240 --> 01:06:46.240]  а бывают шаблонные параметры, являющиеся
[01:06:46.240 --> 01:06:48.240]  шаблонами.
[01:06:48.240 --> 01:06:50.240]  Темплэйт, темплэйт параметры,
[01:06:50.240 --> 01:06:52.240]  так называемые.
[01:06:52.240 --> 01:06:54.240]  Сейчас я вам покажу
[01:06:54.240 --> 01:06:56.240]  шаблонный параметр,
[01:06:56.240 --> 01:06:58.240]  являющийся шаблоном.
[01:06:58.240 --> 01:07:00.240]  Только я для этого хочу, чтобы у меня
[01:07:00.240 --> 01:07:02.240]  код начал компилироваться.
[01:07:02.240 --> 01:07:04.240]  Давайте я удалю просто вот эту часть.
[01:07:04.240 --> 01:07:06.240]  Смотрите.
[01:07:06.240 --> 01:07:08.240]  Вот знаете, есть такой
[01:07:08.240 --> 01:07:10.240]  класс,
[01:07:10.240 --> 01:07:12.240]  стандартная библиотекя
[01:07:12.240 --> 01:07:14.240]  stack.
[01:07:14.240 --> 01:07:16.240]  Темплэйт typeName
[01:07:16.240 --> 01:07:18.240]  class
[01:07:18.240 --> 01:07:20.240]  stack.
[01:07:20.240 --> 01:07:22.240]  Стд stack.
[01:07:22.240 --> 01:07:24.240]  Вот класс stack, короче,
[01:07:24.240 --> 01:07:26.240]  есть в стандартной библиотеке.
[01:07:26.240 --> 01:07:28.240]  Всё ещё в 6.4.
[01:07:28.240 --> 01:07:30.240]  Всё ещё в 6.4, да.
[01:07:30.240 --> 01:07:32.240]  К сожалению.
[01:07:32.240 --> 01:07:34.240]  Ну,
[01:07:34.240 --> 01:07:36.240]  всё ещё в 6.4, да.
[01:07:36.240 --> 01:07:38.240]  Всё ещё в 6.4, да.
[01:07:38.240 --> 01:07:40.240]  Всё ещё в 6.4, да.
[01:07:40.240 --> 01:07:42.240]  К сожалению.
[01:07:42.240 --> 01:07:44.240]  Ну,
[01:07:44.240 --> 01:07:46.240]  ладно, нормально, если...
[01:07:46.240 --> 01:07:48.240]  А с кочуром будет пар или сибирь?
[01:07:48.240 --> 01:07:50.240]  Не, вечером снова буду я
[01:07:50.240 --> 01:07:52.240]  и снова будут плюсы, да.
[01:07:52.240 --> 01:07:54.240]  Мы не... Мы...
[01:07:54.240 --> 01:07:56.240]  Надо много по плюсам ещё успеть. Пройти в этом
[01:07:56.240 --> 01:07:58.240]  семестре, что там медленные.
[01:07:58.240 --> 01:08:00.240]  Вот.
[01:08:02.240 --> 01:08:04.240]  Так вот.
[01:08:04.240 --> 01:08:06.240]  Stack. Знаете, что такое stack?
[01:08:06.240 --> 01:08:08.240]  Кажется,
[01:08:08.240 --> 01:08:10.240]  этот вопрос я уже задавал где-то в начале
[01:08:10.240 --> 01:08:12.240]  тестера.
[01:08:16.240 --> 01:08:18.240]  Что внутри stack?
[01:08:18.240 --> 01:08:20.240]  Как устроен класс stack?
[01:08:24.240 --> 01:08:26.240]  Там на самом деле
[01:08:26.240 --> 01:08:28.240]  есть...
[01:08:28.240 --> 01:08:30.240]  Stack это на самом деле обёртка над другим
[01:08:30.240 --> 01:08:32.240]  контейнером всего лишь.
[01:08:32.240 --> 01:08:34.240]  Stack это не самостоятельный контейнер
[01:08:34.240 --> 01:08:36.240]  в стандартной библиотеке.
[01:08:36.240 --> 01:08:38.240]  Он состоит из...
[01:08:38.240 --> 01:08:40.240]  Ну, на самом деле у него есть второй
[01:08:40.240 --> 01:08:42.240]  шаблонный параметр.
[01:08:46.240 --> 01:08:48.240]  Который по умолчанию равен
[01:08:48.240 --> 01:08:50.240]  stddec от t.
[01:08:50.240 --> 01:08:52.240]  Вот. Но его можно сделать
[01:08:52.240 --> 01:08:54.240]  stdvector от t.
[01:08:54.240 --> 01:08:56.240]  Ну, короче, вот.
[01:08:56.240 --> 01:08:58.240]  Я просто делаю stack на основе
[01:08:58.240 --> 01:09:00.240]  шаблонного контейнера.
[01:09:00.240 --> 01:09:02.240]  На основе контейнера.
[01:09:02.240 --> 01:09:04.240]  Я вторым параметром передаю
[01:09:04.240 --> 01:09:06.240]  underline-container,
[01:09:06.240 --> 01:09:08.240]  подложка.
[01:09:08.240 --> 01:09:10.240]  Stack на основе вектора, например,
[01:09:10.240 --> 01:09:12.240]  могу сделать.
[01:09:12.240 --> 01:09:14.240]  Вот. Но!
[01:09:14.240 --> 01:09:16.240]  Я мог бы сделать и по-другому.
[01:09:16.240 --> 01:09:18.240]  Я мог бы написать
[01:09:18.240 --> 01:09:20.240]  следующее.
[01:09:22.240 --> 01:09:24.240]  Что параметром шаблона
[01:09:24.240 --> 01:09:26.240]  является шаблон. Но ведь по сути у меня
[01:09:30.240 --> 01:09:32.240]  вектор это шаблон, который является параметром
[01:09:32.240 --> 01:09:34.240]  другого шаблона. Правильно?
[01:09:34.240 --> 01:09:36.240]  Я stack делаю на основе вектора.
[01:09:36.240 --> 01:09:38.240]  Тогда...
[01:09:46.240 --> 01:09:48.240]  Я могу написать вот так.
[01:09:54.240 --> 01:09:56.240]  Я сделал параметром шаблона
[01:09:56.240 --> 01:09:58.240]  шаблон.
[01:09:58.240 --> 01:10:00.240]  Я написал
[01:10:00.240 --> 01:10:02.240]  темплей... А, да. Кстати, я вам
[01:10:02.240 --> 01:10:04.240]  показать, что если мне не нужны
[01:10:04.240 --> 01:10:06.240]  шаблонные параметры,
[01:10:06.240 --> 01:10:08.240]  то я их могу тоже имена им не давать.
[01:10:08.240 --> 01:10:10.240]  Этот векс, кажется, не говорил.
[01:10:10.240 --> 01:10:12.240]  Это только может потребоваться.
[01:10:14.240 --> 01:10:16.240]  Очень скоро потребуется.
[01:10:16.240 --> 01:10:18.240]  Увидеть.
[01:10:18.240 --> 01:10:20.240]  Точно тогда же, когда есть
[01:10:20.240 --> 01:10:22.240]  функция. Вот. Я могу
[01:10:22.240 --> 01:10:24.240]  не давать шаблонному параметру название,
[01:10:24.240 --> 01:10:26.240]  если не собираюсь его использовать.
[01:10:26.240 --> 01:10:28.240]  Ну, например, когда я
[01:10:28.240 --> 01:10:30.240]  специализацию шаблона делаю, я могу не использовать
[01:10:30.240 --> 01:10:32.240]  некоторые из параметров.
[01:10:32.240 --> 01:10:34.240]  Вот. Так вот здесь я сделал
[01:10:34.240 --> 01:10:36.240]  именно это. Я написал темплей.
[01:10:36.240 --> 01:10:38.240]  Дальше снова угловые скобочки, и я перечисляю,
[01:10:38.240 --> 01:10:40.240]  что является шаблонными параметрами
[01:10:40.240 --> 01:10:42.240]  шаблона. Уже этого.
[01:10:42.240 --> 01:10:44.240]  А потом говорю class container.
[01:10:44.240 --> 01:10:46.240]  Вот здесь
[01:10:46.240 --> 01:10:48.240]  тонкий момент.
[01:10:48.240 --> 01:10:50.240]  До C++17
[01:10:50.240 --> 01:10:52.240]  вот здесь обязательно нужно было писать class,
[01:10:52.240 --> 01:10:54.240]  а type name уже не подходило.
[01:10:54.240 --> 01:10:56.240]  Но начиная с C++17,
[01:10:56.240 --> 01:10:58.240]  здесь тоже можно писать type name.
[01:10:58.240 --> 01:11:00.240]  Ни в чем, кроме того,
[01:11:00.240 --> 01:11:02.240]  что вот иногда нужно писать
[01:11:02.240 --> 01:11:04.240]  ни в чем.
[01:11:04.240 --> 01:11:06.240]  Сейчас уже ни в чем. Начиная с C++17 вообще ни в чем.
[01:11:06.240 --> 01:11:08.240]  Но вот
[01:11:08.240 --> 01:11:10.240]  здесь
[01:11:12.240 --> 01:11:14.240]  или здесь
[01:11:14.240 --> 01:11:16.240]  надо было писать class, а не тут.
[01:11:16.240 --> 01:11:18.240]  Ну, короче, неважно. Сейчас можно везде
[01:11:18.240 --> 01:11:20.240]  писать type name.
[01:11:20.240 --> 01:11:22.240]  Вот.
[01:11:22.240 --> 01:11:24.240]  Ну,
[01:11:24.240 --> 01:11:26.240]  я по старой привычке буду писать здесь
[01:11:26.240 --> 01:11:28.240]  слово class, имея в виду, что это
[01:11:28.240 --> 01:11:30.240]  все-таки не какой-то тип,
[01:11:30.240 --> 01:11:32.240]  а прям настоящий класс целый, с шаблонными
[01:11:32.240 --> 01:11:34.240]  акубентами даже.
[01:11:36.240 --> 01:11:38.240]  Да, давай удалим, чтобы, так сказать,
[01:11:38.240 --> 01:11:40.240]  не...
[01:11:52.240 --> 01:11:54.240]  Ну да, я вот удалил здесь название n,
[01:11:54.240 --> 01:11:56.240]  поэтому, видите,
[01:11:56.240 --> 01:11:58.240]  он не понимает, что такое n.size.
[01:12:00.240 --> 01:12:02.240]  Так вот.
[01:12:04.240 --> 01:12:06.240]  Я сделал
[01:12:06.240 --> 01:12:08.240]  контейнер шаблонным параметром шаблона stack.
[01:12:08.240 --> 01:12:10.240]  Теперь контейнер внутри stack
[01:12:10.240 --> 01:12:12.240]  это шаблон от одного аргумента.
[01:12:12.240 --> 01:12:14.240]  И я могу, например, говорить
[01:12:14.240 --> 01:12:16.240]  контейнер от int
[01:12:16.240 --> 01:12:18.240]  c.
[01:12:20.240 --> 01:12:22.240]  То есть контейнер теперь это не полноценный тип,
[01:12:22.240 --> 01:12:24.240]  а шаблон, которому нужно подставить еще один
[01:12:24.240 --> 01:12:26.240]  аргумент, чтобы он стал полноценным типом.
[01:12:28.240 --> 01:12:30.240]  Нормально?
[01:12:30.240 --> 01:12:32.240]  Вполне.
[01:12:32.240 --> 01:12:34.240]  Вот.
[01:12:34.240 --> 01:12:36.240]  Смогу... Давайте
[01:12:36.240 --> 01:12:38.240]  я попробую такой stack
[01:12:38.240 --> 01:12:40.240]  создать от std-вектора, например.
[01:12:44.240 --> 01:12:46.240]  Получится?
[01:12:46.240 --> 01:12:48.240]  Стоп.
[01:12:50.240 --> 01:12:52.240]  Чего?
[01:12:54.240 --> 01:12:56.240]  Ой-ой-ой, виноват, виноват, конечно, да.
[01:12:56.240 --> 01:12:58.240]  Вот именно здесь я не должен писать шаблонные аргументы.
[01:13:00.240 --> 01:13:02.240]  Потому что я передаю
[01:13:02.240 --> 01:13:04.240]  в качестве шаблонного параметра шаблон,
[01:13:04.240 --> 01:13:06.240]  а не тип. Вектор int это
[01:13:06.240 --> 01:13:08.240]  законченный тип, а вектор просто
[01:13:08.240 --> 01:13:10.240]  без уточнения это шаблон,
[01:13:10.240 --> 01:13:12.240]  а не законченный тип.
[01:13:12.240 --> 01:13:14.240]  Ты можешь передать еще в отдельный параметр t?
[01:13:14.240 --> 01:13:16.240]  Сейчас.
[01:13:16.240 --> 01:13:18.240]  Да, я могу сказать
[01:13:18.240 --> 01:13:20.240]  template typeNameT
[01:13:20.240 --> 01:13:22.240]  Чтоб у тебя скомпилировалось?
[01:13:22.240 --> 01:13:24.240]  Пока я еще не компилировал.
[01:13:24.240 --> 01:13:26.240]  Но сейчас-то не скомпилируется, если что.
[01:13:26.240 --> 01:13:28.240]  Можно
[01:13:28.240 --> 01:13:30.240]  вот так сделать.
[01:13:30.240 --> 01:13:32.240]  Тогда я могу написать вот так.
[01:13:32.240 --> 01:13:34.240]  int.std-вектор.
[01:13:34.240 --> 01:13:36.240]  А у него есть шаблон просто typeNameT, написать template typeNameT
[01:13:36.240 --> 01:13:38.240]  классный пример?
[01:13:38.240 --> 01:13:40.240]  Эээ...
[01:13:40.240 --> 01:13:42.240]  Могли, но
[01:13:42.240 --> 01:13:44.240]  t это откуда
[01:13:44.240 --> 01:13:46.240]  бы взялось?
[01:13:46.240 --> 01:13:48.240]  Ну, ровно в этом прошибу.
[01:13:48.240 --> 01:13:50.240]  Передали бы.
[01:13:50.240 --> 01:13:52.240]  А,
[01:13:52.240 --> 01:13:54.240]  ты пишешь это вот так?
[01:13:54.240 --> 01:13:56.240]  Ммм...
[01:13:56.240 --> 01:13:58.240]  Кстати...
[01:13:58.240 --> 01:14:00.240]  Да, а здесь
[01:14:00.240 --> 01:14:02.240]  что, тогда тебе придется здесь писать
[01:14:02.240 --> 01:14:04.240]  контейнер от t, по-моему...
[01:14:04.240 --> 01:14:06.240]  По-моему, так...
[01:14:06.240 --> 01:14:08.240]  Нет, стоп.
[01:14:08.240 --> 01:14:10.240]  Может, кстати, так и сработает.
[01:14:10.240 --> 01:14:12.240]  Ну, сейчас это не сработает по той причине, что у вектора
[01:14:12.240 --> 01:14:14.240]  на самом деле не один, а два шаблонных параметров.
[01:14:16.240 --> 01:14:18.240]  Вот здесь мне нужно
[01:14:18.240 --> 01:14:20.240]  еще один typeName.
[01:14:20.240 --> 01:14:22.240]  Мало кто знает, но у вектора есть
[01:14:22.240 --> 01:14:24.240]  второй шаблонный параметр, который по умолчанию,
[01:14:24.240 --> 01:14:26.240]  который все обычно забывают.
[01:14:26.240 --> 01:14:28.240]  Он называется allocator, да.
[01:14:28.240 --> 01:14:30.240]  Поэтому вот теперь это сработает.
[01:14:30.240 --> 01:14:32.240]  Кхм-кхм...
[01:14:32.240 --> 01:14:34.240]  Ааа...
[01:14:34.240 --> 01:14:36.240]  Теперь это...
[01:14:36.240 --> 01:14:38.240]  А, это не сработало, потому что
[01:14:38.240 --> 01:14:40.240]  стэк же не знает, что у контейнера
[01:14:40.240 --> 01:14:42.240]  второй аргумент по умолчанию,
[01:14:42.240 --> 01:14:44.240]  поэтому мне теперь нужно второй аргумент
[01:14:44.240 --> 01:14:46.240]  передать по умолчанию.
[01:14:46.240 --> 01:14:48.240]  Ну...
[01:14:48.240 --> 01:14:50.240]  Ааа...
[01:14:50.240 --> 01:14:52.240]  Там
[01:14:52.240 --> 01:14:54.240]  он вот так по умолчанию выглядит.
[01:14:54.240 --> 01:14:56.240]  std allocator at int.
[01:14:56.240 --> 01:14:58.240]  Сейчас.
[01:14:58.240 --> 01:15:00.240]  Теперь...
[01:15:00.240 --> 01:15:02.240]  Теперь-теперь-теперь...
[01:15:02.240 --> 01:15:04.240]  В стэке, там же наверху,
[01:15:04.240 --> 01:15:06.240]  я в стэк передал
[01:15:06.240 --> 01:15:08.240]  два шаблона
[01:15:08.240 --> 01:15:10.240]  аргумента, а их всего один.
[01:15:10.240 --> 01:15:12.240]  Все, теперь компилируется.
[01:15:14.240 --> 01:15:16.240]  Давайте попробуем
[01:15:16.240 --> 01:15:18.240]  сказать то, что вы
[01:15:18.240 --> 01:15:20.240]  написали, не получится ли у меня
[01:15:20.240 --> 01:15:22.240]  вот так.
[01:15:22.240 --> 01:15:24.240]  Честно говоря,
[01:15:24.240 --> 01:15:26.240]  да, я даже не знаю, но мне кажется, что
[01:15:26.240 --> 01:15:28.240]  нет, да, не получится.
[01:15:28.240 --> 01:15:30.240]  Ну правильно, да,
[01:15:30.240 --> 01:15:32.240]  потому что, что такое T?
[01:15:32.240 --> 01:15:34.240]  Откуда взялось, непонятно.
[01:15:36.240 --> 01:15:38.240]  Илья, а если ты в принципе не будешь
[01:15:38.240 --> 01:15:40.240]  создавать такого стэка, то у тебя компилируется?
[01:15:42.240 --> 01:15:44.240]  Да, потому что
[01:15:44.240 --> 01:15:46.240]  ну, я могу дать имена этим шаблонным
[01:15:46.240 --> 01:15:48.240]  параметрам, просто я их нигде
[01:15:48.240 --> 01:15:50.240]  не использую.
[01:15:50.240 --> 01:15:52.240]  Нет, смотри, я могу теоретически
[01:15:52.240 --> 01:15:54.240]  как-то использовать. Допустим, у меня потом
[01:15:54.240 --> 01:15:56.240]  еще был бы шаблонный параметр какой-то, который
[01:15:56.240 --> 01:15:58.240]  в себе использовал там
[01:15:58.240 --> 01:16:00.240]  допустим typeName
[01:16:00.240 --> 01:16:02.240]  равно std-вектора T.
[01:16:04.240 --> 01:16:06.240]  Вот здесь это T, оно понятно откуда.
[01:16:08.240 --> 01:16:10.240]  Потому что
[01:16:10.240 --> 01:16:12.240]  потому что
[01:16:12.240 --> 01:16:14.240]  вот здесь понятно откуда
[01:16:14.240 --> 01:16:16.240]  ему взять T. Вот этот контейнер, T
[01:16:16.240 --> 01:16:18.240]  это его первый шаблонный аргумент.
[01:16:18.240 --> 01:16:20.240]  Тогда вот здесь второй typeName, это будет
[01:16:20.240 --> 01:16:22.240]  std-вектора T.
[01:16:24.240 --> 01:16:26.240]  А, нет, не работает.
[01:16:26.240 --> 01:16:28.240]  Ну значит...
[01:16:28.240 --> 01:16:30.240]  Это шаблон в шаблоне,
[01:16:30.240 --> 01:16:32.240]  то есть вы говорили
[01:16:32.240 --> 01:16:34.240]  компиляция, то есть вот здесь
[01:16:34.240 --> 01:16:36.240]  вы можете в контейнере
[01:16:36.240 --> 01:16:38.240]  написать стэк, а вне контейнера
[01:16:38.240 --> 01:16:40.240]  уже стэк, определен даже внутри
[01:16:40.240 --> 01:16:42.240]  внутри стэк.
[01:16:42.240 --> 01:16:44.240]  Да, согласен, так нельзя, так
[01:16:44.240 --> 01:16:46.240]  неправильно, да, согласен.
[01:16:46.240 --> 01:16:48.240]  Я, что такое контейнер?
[01:16:48.240 --> 01:16:50.240]  Ну, я могу здесь написать равно
[01:16:50.240 --> 01:16:52.240]  и по умолчанию написать чему равно.
[01:16:52.240 --> 01:16:54.240]  Наверное. Чего, что такое контейнер?
[01:16:54.240 --> 01:16:56.240]  В смысле...
[01:16:56.240 --> 01:16:58.240]  В данном примере
[01:16:58.240 --> 01:17:00.240]  или вообще?
[01:17:00.240 --> 01:17:02.240]  Вообще.
[01:17:02.240 --> 01:17:04.240]  Это долго рассказывать,
[01:17:04.240 --> 01:17:06.240]  это целый, у нас целая глава будет
[01:17:06.240 --> 01:17:08.240]  про это.
[01:17:08.240 --> 01:17:10.240]  Видимо какой-то абстракт
[01:17:10.240 --> 01:17:12.240]  да, что?
[01:17:12.240 --> 01:17:14.240]  Можно еще раз мотивацию так
[01:17:14.240 --> 01:17:16.240]  писать?
[01:17:16.240 --> 01:17:18.240]  Чтобы параметром шаблона был шаблон,
[01:17:18.240 --> 01:17:20.240]  чтобы я мог вот, ну как, вот,
[01:17:20.240 --> 01:17:22.240]  я в стэк отдал просто
[01:17:22.240 --> 01:17:24.240]  не вектор от конкретных типов,
[01:17:24.240 --> 01:17:26.240]  а вектор...
[01:17:26.240 --> 01:17:28.240]  Вектор как таковой, а внутри
[01:17:28.240 --> 01:17:30.240]  этого уже могу конкретизировать
[01:17:30.240 --> 01:17:32.240]  вектор.
[01:17:36.240 --> 01:17:38.240]  Все, пока что.
[01:17:38.240 --> 01:17:40.240]  На пункт
[01:17:40.240 --> 01:17:42.240]  6.4.
[01:17:42.240 --> 01:17:44.240]  Вот, ну, а сейчас будет
[01:17:44.240 --> 01:17:46.240]  моя любимая, и на этом мы закончим
[01:17:46.240 --> 01:17:48.240]  первую пару.
[01:17:48.240 --> 01:17:50.240]  Следующий
[01:17:50.240 --> 01:17:52.240]  пункт, который я хочу успеть разобрать,
[01:17:52.240 --> 01:17:54.240]  это...
[01:18:02.240 --> 01:18:04.240]  вот такой замечательный
[01:18:06.240 --> 01:18:08.240]  пункт.
[01:18:08.240 --> 01:18:10.240]  Сейчас мы с вами позанимаемся
[01:18:12.240 --> 01:18:14.240]  простейшими
[01:18:16.240 --> 01:18:18.240]  вычислениями на этапе компиляции.
[01:18:22.240 --> 01:18:24.240]  Что?
[01:18:26.240 --> 01:18:28.240]  А, да, все нормально.
[01:18:28.240 --> 01:18:30.240]  Так.
[01:18:32.240 --> 01:18:34.240]  Давайте...
[01:18:34.240 --> 01:18:36.240]  6.5. Извиняюсь.
[01:18:38.240 --> 01:18:40.240]  У меня просто в другом году была
[01:18:40.240 --> 01:18:42.240]  номерация немножечко измененная.
[01:18:42.240 --> 01:18:44.240]  В прошлом году
[01:18:44.240 --> 01:18:46.240]  виртуальные функции были после шаблона.
[01:18:46.240 --> 01:18:48.240]  Может быть, циклы какие-то...
[01:18:50.240 --> 01:18:52.240]  Значит...
[01:18:52.240 --> 01:18:54.240]  Отвечаю на вопрос
[01:18:54.240 --> 01:18:56.240]  и сразу говорю
[01:18:56.240 --> 01:18:58.240]  то, что
[01:18:58.240 --> 01:19:00.240]  может кого-то шокировать.
[01:19:00.240 --> 01:19:02.240]  Язык шаблонов полон
[01:19:02.240 --> 01:19:04.240]  по тьюрингу?
[01:19:04.240 --> 01:19:06.240]  Ну, то есть,
[01:19:06.240 --> 01:19:08.240]  шаблоны
[01:19:08.240 --> 01:19:10.240]  этот язык в языке полноценный.
[01:19:10.240 --> 01:19:12.240]  На шаблонах можно
[01:19:12.240 --> 01:19:14.240]  вычислить все.
[01:19:14.240 --> 01:19:16.240]  Что значит вычислить на шаблонах, вы сейчас увидите.
[01:19:16.240 --> 01:19:18.240]  Сейчас я вам покажу
[01:19:18.240 --> 01:19:20.240]  классический пример, как
[01:19:20.240 --> 01:19:22.240]  в Compile Time с помощью шаблонов
[01:19:22.240 --> 01:19:24.240]  вычислить n-ное число фибоначчи.
[01:19:24.240 --> 01:19:26.240]  А на олимпиадах есть ограничения
[01:19:26.240 --> 01:19:28.240]  на премьеру? Да, это самый популярный
[01:19:28.240 --> 01:19:30.240]  вопрос, который задает продвинутый поток
[01:19:30.240 --> 01:19:32.240]  после того, как я это говорю.
[01:19:34.240 --> 01:19:36.240]  Год от года вопрос не меняется.
[01:19:36.240 --> 01:19:38.240]  А как это использовать на олимпиадах?
[01:19:38.240 --> 01:19:40.240]  Ну, можете попробовать
[01:19:40.240 --> 01:19:42.240]  использовать на олимпиадах, да.
[01:19:42.240 --> 01:19:44.240]  В предвычислении, да,
[01:19:44.240 --> 01:19:46.240]  в Яндекс.Монтесте есть ограничения на время компиляции.
[01:19:46.240 --> 01:19:48.240]  Более того,
[01:19:48.240 --> 01:19:50.240]  во втором семестре у нас будет задача,
[01:19:50.240 --> 01:19:52.240]  где самое сложное будет влезть в Compile Time
[01:19:52.240 --> 01:19:54.240]  тл, а не в
[01:19:54.240 --> 01:19:56.240]  Rantart. Но у нас
[01:19:56.240 --> 01:19:58.240]  и в этом семестре будет такая задача.
[01:19:58.240 --> 01:20:00.240]  В общем-то, это и будут матрицы.
[01:20:00.240 --> 01:20:02.240]  Вам нужно будет проверять
[01:20:02.240 --> 01:20:04.240]  число на простоту в Compile Time.
[01:20:04.240 --> 01:20:06.240]  Ну, то есть, у вас есть
[01:20:06.240 --> 01:20:08.240]  матрица.
[01:20:08.240 --> 01:20:10.240]  У вас есть кольцо
[01:20:10.240 --> 01:20:12.240]  по модулю N?
[01:20:12.240 --> 01:20:14.240]  Иногда оно является полем, иногда нет.
[01:20:14.240 --> 01:20:16.240]  Если N простое, то является.
[01:20:16.240 --> 01:20:18.240]  Соответственно, если оно простое,
[01:20:18.240 --> 01:20:20.240]  то деление должно быть определено.
[01:20:20.240 --> 01:20:22.240]  А если нет, то не должно быть.
[01:20:22.240 --> 01:20:24.240]  И это должна ошибкой компиляции быть, а не ошибкой Rantime.
[01:20:26.240 --> 01:20:28.240]  Если я пытаюсь
[01:20:28.240 --> 01:20:30.240]  поделить,
[01:20:30.240 --> 01:20:32.240]  если я пытаюсь выяснить оператор деления
[01:20:32.240 --> 01:20:34.240]  в кольце, вычитав
[01:20:34.240 --> 01:20:36.240]  по модулю 10,
[01:20:36.240 --> 01:20:38.240]  то я должен получать CE.
[01:20:38.240 --> 01:20:40.240]  11 не должен.
[01:20:40.240 --> 01:20:42.240]  Соответственно, задача
[01:20:42.240 --> 01:20:44.240]  реализовать класс
[01:20:44.240 --> 01:20:46.240]  вычитав по модулю N так,
[01:20:46.240 --> 01:20:48.240]  чтобы тогда и только тогда, когда N
[01:20:48.240 --> 01:20:50.240]  простое, в нем был определен оператор деления.
[01:20:50.240 --> 01:20:52.240]  Ну, то есть, вызов оператора деления
[01:20:52.240 --> 01:20:54.240]  не давал CE.
[01:20:54.240 --> 01:20:56.240]  Да.
[01:20:56.240 --> 01:20:58.240]  Для некоторых
[01:20:58.240 --> 01:21:00.240]  да, но в общем случае нет.
[01:21:00.240 --> 01:21:02.240]  Поэтому мы говорим CE, если я
[01:21:02.240 --> 01:21:04.240]  пытаюсь поделить.
[01:21:04.240 --> 01:21:06.240]  Значит, я хочу, чтобы
[01:21:06.240 --> 01:21:08.240]  когда модуль не простое число, деления не было.
[01:21:08.240 --> 01:21:10.240]  Ну и
[01:21:10.240 --> 01:21:12.240]  даже так,
[01:21:12.240 --> 01:21:14.240]  я хочу, чтобы просто,
[01:21:14.240 --> 01:21:16.240]  например, матрицу нельзя было обратить,
[01:21:16.240 --> 01:21:18.240]  если то, что переданим,
[01:21:18.240 --> 01:21:20.240]  не является полем, в том смысле,
[01:21:20.240 --> 01:21:22.240]  что в нем нету,
[01:21:22.240 --> 01:21:24.240]  скажем...
[01:21:24.240 --> 01:21:26.240]  Ну вот,
[01:21:26.240 --> 01:21:28.240]  у меня есть, допустим, матрица
[01:21:28.240 --> 01:21:30.240]  над кольцом вычитав
[01:21:30.240 --> 01:21:32.240]  по модулю 10.
[01:21:32.240 --> 01:21:34.240]  Такую матрицу создать я могу.
[01:21:34.240 --> 01:21:36.240]  И я могу перемножать такие матрицы.
[01:21:36.240 --> 01:21:38.240]  Но я хочу, например,
[01:21:38.240 --> 01:21:40.240]  что в момент, когда я пытаюсь инвертировать матрицу
[01:21:40.240 --> 01:21:42.240]  над полем вычитав по модулю,
[01:21:42.240 --> 01:21:44.240]  извиняюсь, над кольцом вычитав по модулю 10,
[01:21:44.240 --> 01:21:46.240]  я бы получал CE,
[01:21:46.240 --> 01:21:48.240]  а не RE со словами деления на ноль.
[01:21:50.240 --> 01:21:52.240]  И вот именно так, и нужно
[01:21:52.240 --> 01:21:54.240]  вот именно это реализовать и будет
[01:21:54.240 --> 01:21:56.240]  вашей основной целью
[01:21:56.240 --> 01:21:58.240]  в последней задаче, видимо, последней этого семестра.
[01:21:58.240 --> 01:22:00.240]  Видимо, пятую учитку не успеть.
[01:22:00.240 --> 01:22:02.240]  Давайте для начала я покажу,
[01:22:02.240 --> 01:22:04.240]  как вычислить числа фибоначчи на этапе компиляции.
[01:22:04.240 --> 01:22:06.240]  Это стандартный пример,
[01:22:06.240 --> 01:22:08.240]  с которого все начинают. Смотрите.
[01:22:08.240 --> 01:22:10.240]  Я пишу
[01:22:10.240 --> 01:22:12.240]  template int n,
[01:22:12.240 --> 01:22:14.240]  ну size tn на самом деле, но ладно.
[01:22:14.240 --> 01:22:16.240]  struct
[01:22:16.240 --> 01:22:18.240]  fibonacci
[01:22:22.240 --> 01:22:24.240]  an
[01:22:28.240 --> 01:22:30.240]  Да, это будет структура.
[01:22:32.240 --> 01:22:34.240]  Это будет
[01:22:34.240 --> 01:22:36.240]  метапрограммирование такое.
[01:22:36.240 --> 01:22:38.240]  У меня здесь
[01:22:38.240 --> 01:22:40.240]  функции,
[01:22:40.240 --> 01:22:42.240]  такие метафункции, это на самом деле структуры.
[01:22:44.240 --> 01:22:46.240]  А значение этих метафункций
[01:22:46.240 --> 01:22:48.240]  это
[01:22:48.240 --> 01:22:50.240]  константы, которые
[01:22:50.240 --> 01:22:52.240]  в структурах лежат.
[01:22:52.240 --> 01:22:54.240]  Вот у меня в структуре фибоначчи
[01:22:54.240 --> 01:22:56.240]  будет статическая константа
[01:22:56.240 --> 01:22:58.240]  value
[01:22:58.240 --> 01:23:00.240]  равная
[01:23:02.240 --> 01:23:04.240]  fibonacci
[01:23:04.240 --> 01:23:06.240]  n-1 value
[01:23:08.240 --> 01:23:10.240]  плюс
[01:23:10.240 --> 01:23:12.240]  fibonacci
[01:23:12.240 --> 01:23:14.240]  n-2 value
[01:23:18.240 --> 01:23:20.240]  У меня бесконечная рекурсия.
[01:23:20.240 --> 01:23:22.240]  Что же делать?
[01:23:22.240 --> 01:23:24.240]  Как же избавиться от рекурсии?
[01:23:24.240 --> 01:23:26.240]  Ну надо специализировать.
[01:23:26.240 --> 01:23:28.240]  Сейчас, подождите, давайте я напишу
[01:23:28.240 --> 01:23:30.240]  fibonacci от 1
[01:23:30.240 --> 01:23:32.240]  и тут я пишу
[01:23:32.240 --> 01:23:34.240]  static constant
[01:23:34.240 --> 01:23:36.240]  int value
[01:23:36.240 --> 01:23:38.240]  равно 1.
[01:23:40.240 --> 01:23:42.240]  Ну а еще
[01:23:42.240 --> 01:23:44.240]  от 0.
[01:23:44.240 --> 01:23:46.240]  static constant value
[01:23:46.240 --> 01:23:48.240]  равно 0 будет.
[01:23:50.240 --> 01:23:52.240]  Ну, 0-ое число
[01:23:52.240 --> 01:23:54.240]  fibonacci это поможет.
[01:23:54.240 --> 01:23:56.240]  Ну, 0-ое число fibonacci это
[01:23:56.240 --> 01:23:58.240]  по-моему все-таки 0.
[01:24:00.240 --> 01:24:02.240]  Это зависит от того, как ты хочешь
[01:24:02.240 --> 01:24:04.240]  я предпочитаю число fibonacci
[01:24:04.240 --> 01:24:06.240]  определять так, что в формуле бене было n,
[01:24:06.240 --> 01:24:08.240]  а не n-1.
[01:24:08.240 --> 01:24:10.240]  Вот если ты
[01:24:10.240 --> 01:24:12.240]  0-евым числом fibonacci назовешь 0,
[01:24:12.240 --> 01:24:14.240]  то кажется у тебя формула бене сработает
[01:24:14.240 --> 01:24:16.240]  с постановкой
[01:24:16.240 --> 01:24:18.240]  phi в степени n надо будет возводить как раз.
[01:24:20.240 --> 01:24:22.240]  Вот поэтому я, лично я предпочитаю
[01:24:22.240 --> 01:24:24.240]  любым числом fibonacci считать 0,
[01:24:24.240 --> 01:24:26.240]  но я не против, если у вас другое определение
[01:24:26.240 --> 01:24:28.240]  числа fibonacci, теоретически у меня
[01:24:28.240 --> 01:24:30.240]  как бы не протестую.
[01:24:34.240 --> 01:24:36.240]  Потому что что?
[01:24:36.240 --> 01:24:38.240]  Я не прослышал.
[01:24:44.240 --> 01:24:46.240]  Так, смотрите какие
[01:24:46.240 --> 01:24:48.240]  чудеса-то.
[01:24:48.240 --> 01:24:50.240]  Теперь, если я беру и говорю
[01:24:52.240 --> 01:24:54.240]  как что такое?
[01:24:54.240 --> 01:24:56.240]  Это обращение к статическому полю класса.
[01:25:00.240 --> 01:25:02.240]  Я обращаюсь не к нему, я обращаюсь
[01:25:02.240 --> 01:25:04.240]  к полю другого класса.
[01:25:04.240 --> 01:25:06.240]  Который уже от n-1.
[01:25:06.240 --> 01:25:08.240]  Это другой совершенно класс.
[01:25:14.240 --> 01:25:16.240]  Ну давайте выведем 10 число fibonacci.
[01:25:22.240 --> 01:25:24.240]  О, пошли глубокие вопросы.
[01:25:26.240 --> 01:25:28.240]  У нас же есть ограничение на время
[01:25:28.240 --> 01:25:30.240]  исполнения, а есть ограничение на количество
[01:25:30.240 --> 01:25:32.240]  сгенерированного кодакода.
[01:25:34.240 --> 01:25:36.240]  Ну так и работает.
[01:25:36.240 --> 01:25:38.240]  Там есть EML и ETL
[01:25:38.240 --> 01:25:40.240]  в compile-time.
[01:25:40.240 --> 01:25:42.240]  Ну, в настройках контеста,
[01:25:42.240 --> 01:25:44.240]  если вот здесь посмотреть,
[01:25:44.240 --> 01:25:46.240]  вот я
[01:25:48.240 --> 01:25:50.240]  классно.
[01:25:52.240 --> 01:25:54.240]  Ну вот, тут есть
[01:25:54.240 --> 01:25:56.240]  в настройках вполне себе
[01:25:58.240 --> 01:26:00.240]  Господи, ладно,
[01:26:00.240 --> 01:26:02.240]  хорошо, я предпочитаю вот это.
[01:26:10.240 --> 01:26:12.240]  Блин, в настройках задачи
[01:26:12.240 --> 01:26:14.240]  делается.
[01:26:14.240 --> 01:26:16.240]  Ну короче, есть в настройках
[01:26:16.240 --> 01:26:18.240]  вполне себе
[01:26:22.240 --> 01:26:24.240]  Ну давайте, вот я покажу вам на примере
[01:26:24.240 --> 01:26:26.240]  biginteger.
[01:26:28.240 --> 01:26:30.240]  То есть ограничение EML и ETL
[01:26:30.240 --> 01:26:32.240]  существует как у run-time, так и у compile-time.
[01:26:38.240 --> 01:26:40.240]  Не-не-не,
[01:26:40.240 --> 01:26:42.240]  это плохой путь, нет.
[01:26:42.240 --> 01:26:44.240]  Так, ну вот, давайте
[01:26:44.240 --> 01:26:46.240]  10 число fibonacci вычислим.
[01:26:46.240 --> 01:26:48.240]  Вот, пожалуйста, 55.
[01:26:48.240 --> 01:26:50.240]  Чего?
[01:26:52.240 --> 01:26:54.240]  Да, я знаю.
[01:26:54.240 --> 01:26:56.240]  Смотрите,
[01:26:56.240 --> 01:26:58.240]  вот что будет,
[01:26:58.240 --> 01:27:00.240]  если я
[01:27:00.240 --> 01:27:02.240]  сделаю бесконечную шаблонную
[01:27:02.240 --> 01:27:04.240]  рекурсию?
[01:27:04.240 --> 01:27:06.240]  Ну, логично, что будет CE.
[01:27:08.240 --> 01:27:10.240]  Сейчас будет очень забавная
[01:27:10.240 --> 01:27:12.240]  шипрокомпиляция.
[01:27:12.240 --> 01:27:14.240]  Fatal error.
[01:27:14.240 --> 01:27:16.240]  Template instantiation depth exceeded
[01:27:16.240 --> 01:27:18.240]  maximum of 900.
[01:27:20.240 --> 01:27:22.240]  Значит,
[01:27:22.240 --> 01:27:24.240]  по умолчанию у компилятора
[01:27:24.240 --> 01:27:26.240]  есть лимит,
[01:27:26.240 --> 01:27:28.240]  сколько уровней шаблонной рекурсии
[01:27:28.240 --> 01:27:30.240]  он готов
[01:27:30.240 --> 01:27:32.240]  инстанцировать.
[01:27:32.240 --> 01:27:34.240]  И здесь такая подскаточка.
[01:27:34.240 --> 01:27:36.240]  Используйте вот такой параметр, чтобы увеличить этот лимит.
[01:27:36.240 --> 01:27:38.240]  Минус Ftemplate depth
[01:27:38.240 --> 01:27:40.240]  равно.
[01:27:40.240 --> 01:27:42.240]  Вот, когда вы будете проверять
[01:27:42.240 --> 01:27:44.240]  числа на простоту в Compile Timer
[01:27:44.240 --> 01:27:46.240]  с помощью шаблонной рекурсии, вам предстоит
[01:27:46.240 --> 01:27:48.240]  увеличить этот лимит.
[01:27:48.240 --> 01:27:50.240]  Нет, здесь же написано
[01:27:50.240 --> 01:27:52.240]  минус Ftemplate depth, это такой параметр
[01:27:52.240 --> 01:27:54.240]  компиляции.
[01:27:54.240 --> 01:27:56.240]  В системе у меня будет
[01:27:56.240 --> 01:27:58.240]  стоять минус Ftemplate depth сколько надо.
[01:27:58.240 --> 01:28:00.240]  А если он не стоит, то сколько надо?
[01:28:00.240 --> 01:28:02.240]  А если мы считаем, что надо больше?
[01:28:02.240 --> 01:28:04.240]  Я не знаю,
[01:28:04.240 --> 01:28:06.240]  можно ли это делать через Pragma,
[01:28:06.240 --> 01:28:08.240]  но вот я знаю, что можно делать таким шаблонным параметром.
[01:28:08.240 --> 01:28:10.240]  У Selengo, кстати,
[01:28:10.240 --> 01:28:12.240]  лимит повыше.
[01:28:14.240 --> 01:28:16.240]  У Selengo лимит
[01:28:16.240 --> 01:28:18.240]  1024.
[01:28:20.240 --> 01:28:22.240]  А ты попытался вывести какой-то большой
[01:28:22.240 --> 01:28:24.240]  число? Я попытался
[01:28:24.240 --> 01:28:26.240]  просто, я бесконечную рекурсию
[01:28:26.240 --> 01:28:28.240]  сделал.
[01:28:28.240 --> 01:28:30.240]  Вот, ну хорошо.
[01:28:30.240 --> 01:28:32.240]  А он на циклы проверяет?
[01:28:34.240 --> 01:28:36.240]  Если он
[01:28:36.240 --> 01:28:38.240]  зациклится, то все, рекурсия
[01:28:38.240 --> 01:28:40.240]  закончилась же.
[01:28:40.240 --> 01:28:42.240]  Ему больше не надо инстанцировать.
[01:28:42.240 --> 01:28:44.240]  Дальше вопрос в том,
[01:28:44.240 --> 01:28:46.240]  зацикленные у тебя сами
[01:28:46.240 --> 01:28:48.240]  определения, то уже будет runtime рекурсия, кажется.
[01:28:48.240 --> 01:28:50.240]  О нет, не runtime, виноват.
[01:28:50.240 --> 01:28:52.240]  Ну короче, его именно инстанцирований
[01:28:52.240 --> 01:28:54.240]  много слишком.
[01:28:56.240 --> 01:28:58.240]  Если он как-то вот руками
[01:28:58.240 --> 01:29:00.240]  на этапе компиляции
[01:29:02.240 --> 01:29:04.240]  Если у меня нулевое число фибоначи
[01:29:04.240 --> 01:29:06.240]  бы использовалось снова 10 число фибоначи,
[01:29:06.240 --> 01:29:08.240]  то мы зациклились бы
[01:29:08.240 --> 01:29:10.240]  в цикл, но это был не
[01:29:10.240 --> 01:29:12.240]  бесконечная шаблонная рекурсия,
[01:29:12.240 --> 01:29:14.240]  это была бы бесконечная компиляция просто.
[01:29:14.240 --> 01:29:16.240]  Вот не знаю,
[01:29:16.240 --> 01:29:18.240]  если, кстати, будет
[01:29:18.240 --> 01:29:20.240]  я не знаю, наверное,
[01:29:20.240 --> 01:29:22.240]  это было бы CE, наверное,
[01:29:22.240 --> 01:29:24.240]  возможно, блин, я даже не знаю,
[01:29:24.240 --> 01:29:26.240]  честно говоря, надо попробовать, не знаю.
[01:29:26.240 --> 01:29:28.240]  Потому что за линию вычисляется все это?
[01:29:28.240 --> 01:29:30.240]  Вот, за какое время вычисляется
[01:29:30.240 --> 01:29:32.240]  n-ое число фибоначи здесь.
[01:29:32.240 --> 01:29:34.240]  Залинейное, потому что каждая
[01:29:34.240 --> 01:29:36.240]  структура
[01:29:36.240 --> 01:29:38.240]  инстанцируется один раз, просто так,
[01:29:38.240 --> 01:29:40.240]  как он ее сгенерировал один раз, ему больше не надо.
[01:29:40.240 --> 01:29:42.240]  Вот это не то, как
[01:29:42.240 --> 01:29:44.240]  вызовы функций работают, если вы делаете
[01:29:44.240 --> 01:29:46.240]  просто тупую рекурсию с вычислением
[01:29:46.240 --> 01:29:48.240]  чисел фибоначи, то у вас получается экспоненциальная
[01:29:48.240 --> 01:29:50.240]  сложность, правильно? Потому что вы
[01:29:50.240 --> 01:29:52.240]  каждый раз вызывая f от n, вычисляете
[01:29:52.240 --> 01:29:54.240]  заново f от n минус 1 и все предыдущие.
[01:29:54.240 --> 01:29:56.240]  Здесь не так, здесь если вы
[01:29:56.240 --> 01:29:58.240]  проинстанцировали фибоначи от n,
[01:29:58.240 --> 01:30:00.240]  то вы больше не инстанцируете
[01:30:00.240 --> 01:30:02.240]  его заново, когда к нему обращаетесь, там уже
[01:30:02.240 --> 01:30:04.240]  готовая константа лежит.
[01:30:04.240 --> 01:30:06.240]  Вот, понимаете ли вы,
[01:30:06.240 --> 01:30:08.240]  почему здесь статик
[01:30:08.240 --> 01:30:10.240]  и почему конст?
[01:30:10.240 --> 01:30:12.240]  Статик, потому что я не
[01:30:12.240 --> 01:30:14.240]  создаю ни одного объекта типа фибоначи,
[01:30:14.240 --> 01:30:16.240]  я просто использую эту структуру,
[01:30:16.240 --> 01:30:18.240]  как...
[01:30:18.240 --> 01:30:20.240]  Ну, мне
[01:30:20.240 --> 01:30:22.240]  только статическое поле в ней интересует.
[01:30:22.240 --> 01:30:24.240]  И почему конст? Потому что если
[01:30:24.240 --> 01:30:26.240]  было не конст, то в compile-time-е он бы отказался
[01:30:26.240 --> 01:30:28.240]  вычислять это.
[01:30:28.240 --> 01:30:30.240]  Вот.
[01:30:36.240 --> 01:30:38.240]  Ну...
[01:30:42.240 --> 01:30:44.240]  Чего если?
[01:30:48.240 --> 01:30:50.240]  Так это же то же самое.
[01:30:52.240 --> 01:30:54.240]  Нет, он
[01:30:54.240 --> 01:30:56.240]  не будет создавать
[01:30:56.240 --> 01:30:58.240]  десятки заново.
[01:30:58.240 --> 01:31:00.240]  Блин, а почему
[01:31:00.240 --> 01:31:02.240]  он вообще так эгилирует,
[01:31:02.240 --> 01:31:04.240]  когда подобный код в систему я вызывал?
[01:31:04.240 --> 01:31:06.240]  Ну, давайте я проведу эксперименты
[01:31:06.240 --> 01:31:08.240]  здесь и здесь, попребовать от него
[01:31:08.240 --> 01:31:10.240]  фибоначи десятая.
[01:31:10.240 --> 01:31:12.240]  Что произойдет? Вероятно
[01:31:12.240 --> 01:31:14.240]  он упадет с той же ошибкой, потому что он
[01:31:14.240 --> 01:31:16.240]  просто зациклится в инстанцированиях.
[01:31:16.240 --> 01:31:18.240]  Ну, хотя с другой стороны, он же вроде не инстанцирует.
[01:31:18.240 --> 01:31:20.240]  Нет, то же самое
[01:31:20.240 --> 01:31:22.240]  произошло, то же самое.
[01:31:22.240 --> 01:31:24.240]  То же самое.
[01:31:24.240 --> 01:31:26.240]  Ладно.
[01:31:32.240 --> 01:31:34.240]  Ну, потому что чтобы ему посчитать,
[01:31:34.240 --> 01:31:36.240]  чему равно
[01:31:36.240 --> 01:31:38.240]  фибоначи первая, ему пришлось опять зайти в
[01:31:38.240 --> 01:31:40.240]  фибоначи десятая.
[01:31:40.240 --> 01:31:42.240]  Он так и не понял, чему равно
[01:31:42.240 --> 01:31:44.240]  фибоначи... А, вот почему.
[01:31:44.240 --> 01:31:46.240]  Потому что фибоначи десятая же он не сумел понять,
[01:31:46.240 --> 01:31:48.240]  чему равно.
[01:31:48.240 --> 01:31:50.240]  Для этого ему пришлось зайти и так далее, и так далее,
[01:31:50.240 --> 01:31:52.240]  фибоначи первая, а там снова фибоначи десятая.
[01:31:52.240 --> 01:31:54.240]  Он так и зациклился, потому что у него теперь...
[01:31:54.240 --> 01:31:56.240]  Ну да. То есть он так и не инстанцировал
[01:31:56.240 --> 01:31:58.240]  фибоначи никакой в конечном итоге.
[01:31:58.240 --> 01:32:00.240]  А можно
[01:32:00.240 --> 01:32:02.240]  но
[01:32:02.240 --> 01:32:04.240]  для этого потребуется
[01:32:04.240 --> 01:32:06.240]  слово constexpr,
[01:32:06.240 --> 01:32:08.240]  а вам будет запрещено им пользоваться, вам нужно
[01:32:08.240 --> 01:32:10.240]  пока на шаблонах.
[01:32:10.240 --> 01:32:12.240]  Что?
[01:32:12.240 --> 01:32:14.240]  В этой задачи нельзя
[01:32:14.240 --> 01:32:16.240]  использовать constexpr, в этой задачи вам
[01:32:16.240 --> 01:32:18.240]  нужно на шаблонах все написать.
[01:32:18.240 --> 01:32:20.240]  constexpr мы
[01:32:20.240 --> 01:32:22.240]  будем потом пользоваться.
[01:32:22.240 --> 01:32:24.240]  В втором семестре. Вот, последняя
[01:32:24.240 --> 01:32:26.240]  штука. Помните, я вам
[01:32:26.240 --> 01:32:28.240]  говорил, что бывают шаблонные
[01:32:28.240 --> 01:32:30.240]  переменные?
[01:32:34.240 --> 01:32:36.240]  Ну вот теперь вы понимаете, зачем они могут быть
[01:32:36.240 --> 01:32:38.240]  нужны.
[01:32:44.240 --> 01:32:46.240]  Шаблонная
[01:32:46.240 --> 01:32:48.240]  переменная,
[01:32:48.240 --> 01:32:50.240]  добро пожаловать.
[01:32:52.240 --> 01:32:54.240]  То есть мне теперь не надо писать
[01:32:54.240 --> 01:32:56.240]  value
[01:32:56.240 --> 01:32:58.240]  вот это вот все, мне просто
[01:32:58.240 --> 01:33:00.240]  можно писать фиб десятая.
[01:33:00.240 --> 01:33:02.240]  И это переменная, шаблонная
[01:33:02.240 --> 01:33:04.240]  переменная, параметризованная
[01:33:04.240 --> 01:33:06.240]  числом,
[01:33:06.240 --> 01:33:08.240]  которая равна вот этому вот.
[01:33:08.240 --> 01:33:10.240]  Луки, а это ты там сорок не писать?
[01:33:10.240 --> 01:33:12.240]  Никак.
[01:33:12.240 --> 01:33:14.240]  Дайте им полночь.
[01:33:16.240 --> 01:33:18.240]  А вы не писать?
[01:33:18.240 --> 01:33:20.240]  Вопросики?
[01:33:20.240 --> 01:33:22.240]  Вопрос,
[01:33:22.240 --> 01:33:24.240]  а, но если так написать, он только
[01:33:24.240 --> 01:33:26.240]  десятого сгибает? Да, конечно.
[01:33:26.240 --> 01:33:28.240]  Зачем мы генерировать остальные?
[01:33:28.240 --> 01:33:30.240]  А если там будет допустим cn и
[01:33:30.240 --> 01:33:32.240]  cfn? Ага.
[01:33:32.240 --> 01:33:34.240]  ce
[01:33:34.240 --> 01:33:36.240]  n это не константное выражение.
[01:33:36.240 --> 01:33:38.240]  Не может параметром
[01:33:38.240 --> 01:33:40.240]  шаблона быть runtime переменная.
[01:33:40.240 --> 01:33:42.240]  Только compile time
[01:33:42.240 --> 01:33:44.240]  константа может быть параметром шаблона.
[01:33:44.240 --> 01:33:46.240]  Если ты еще потом попробуешь вывести
[01:33:46.240 --> 01:33:48.240]  двадцатая
[01:33:48.240 --> 01:33:50.240]  у него
[01:33:50.240 --> 01:33:52.240]  первые десять уже сгенерированы, мне придется
[01:33:52.240 --> 01:33:54.240]  заново.
[01:33:54.240 --> 01:33:56.240]  Вот смотрите, давайте я попытаюсь
[01:33:56.240 --> 01:33:58.240]  вывести, не знаю.
[01:34:04.240 --> 01:34:06.240]  Стотысячное число
[01:34:06.240 --> 01:34:08.240]  фибоначи.
[01:34:08.240 --> 01:34:10.240]  Вот я,
[01:34:12.240 --> 01:34:14.240]  вот у меня сейчас
[01:34:14.240 --> 01:34:16.240]  a.out занимает шестнадцать килобайт.
[01:34:16.240 --> 01:34:18.240]  Давайте я попытаюсь
[01:34:18.240 --> 01:34:20.240]  сгенерировать, не знаю,
[01:34:20.240 --> 01:34:22.240]  двухсоттысячное число фибоначи.
[01:34:22.240 --> 01:34:24.240]  А произойдет
[01:34:24.240 --> 01:34:26.240]  ub, потому что
[01:34:26.240 --> 01:34:28.240]  переполнение, ну как, произойдет
[01:34:28.240 --> 01:34:30.240]  в runtime ub. Но меня
[01:34:30.240 --> 01:34:32.240]  это не волнует. То есть пусть там будет какая-то
[01:34:32.240 --> 01:34:34.240]  непонятная константа.
[01:34:34.240 --> 01:34:36.240]  Да, я хочу
[01:34:36.240 --> 01:34:38.240]  сделать
[01:34:38.240 --> 01:34:40.240]  минус f template depth равно дофига.
[01:34:46.240 --> 01:34:48.240]  Не-не-не.
[01:34:50.240 --> 01:34:52.240]  Вот.
[01:34:52.240 --> 01:34:54.240]  Двухсоттысячное число фибоначи.
[01:34:54.240 --> 01:34:56.240]  Но там будет бред какой-то.
[01:34:56.240 --> 01:34:58.240]  Кстати, возможно будет
[01:35:00.240 --> 01:35:02.240]  Смотрите, warning.
[01:35:06.240 --> 01:35:08.240]  Не early exhaust.
[01:35:10.240 --> 01:35:12.240]  Как приятно.
[01:35:14.240 --> 01:35:16.240]  Да, тут произошла
[01:35:16.240 --> 01:35:18.240]  неувязочка.
[01:35:18.240 --> 01:35:20.240]  Он мне выдал ce
[01:35:20.240 --> 01:35:22.240]  из-за того, что у него переполнение int
[01:35:22.240 --> 01:35:24.240]  случилось, кажется.
[01:35:24.240 --> 01:35:26.240]  Сделаем unsigned depth, вроде как
[01:35:26.240 --> 01:35:28.240]  переполнение unsigned depth.
[01:35:28.240 --> 01:35:30.240]  Да, давайте
[01:35:30.240 --> 01:35:32.240]  static const
[01:35:32.240 --> 01:35:34.240]  unsigned
[01:35:34.240 --> 01:35:36.240]  Господи.
[01:35:40.240 --> 01:35:42.240]  Да, давайте
[01:35:42.240 --> 01:35:44.240]  Господи.
[01:35:46.240 --> 01:35:48.240]  Я уже
[01:35:48.240 --> 01:35:50.240]  объяснял, что оно считается за atn,
[01:35:50.240 --> 01:35:52.240]  потому что одинажды инстанцировав шаблон,
[01:35:52.240 --> 01:35:54.240]  он потом не должен инстанцировать
[01:35:54.240 --> 01:35:56.240]  его снова.
[01:35:56.240 --> 01:35:58.240]  Все, теперь у меня
[01:35:58.240 --> 01:36:00.240]  все int без знаков, и давайте попробуем
[01:36:00.240 --> 01:36:02.240]  еще раз.
[01:36:02.240 --> 01:36:04.240]  Теперь переполнение не должно быть.
[01:36:04.240 --> 01:36:06.240]  Main, master, turn, int.
[01:36:06.240 --> 01:36:08.240]  Не удалось, конечно.
[01:36:12.240 --> 01:36:14.240]  Хорошо, давайте просто int
[01:36:14.240 --> 01:36:16.240]  сделаем.
[01:36:16.240 --> 01:36:18.240]  Еще раз
[01:36:18.240 --> 01:36:20.240]  пробуем.
[01:36:26.240 --> 01:36:28.240]  Но ничего, потерпим.
[01:36:32.240 --> 01:36:34.240]  И подождем, да.
[01:36:34.240 --> 01:36:36.240]  Все, скомпилировался.
[01:36:36.240 --> 01:36:38.240]  Теперь, смотрите.
[01:36:38.240 --> 01:36:40.240]  Да, я minus f template depth.
[01:36:40.240 --> 01:36:42.240]  А, нет, тоже 16440.
[01:36:42.240 --> 01:36:44.240]  Ну,
[01:36:44.240 --> 01:36:46.240]  значит, он не вписал
[01:36:46.240 --> 01:36:48.240]  в бинарник все эти значения.
[01:36:48.240 --> 01:36:50.240]  То есть к чему был этот эксперимент?
[01:36:50.240 --> 01:36:52.240]  Эксперимент был к тому, что
[01:36:52.240 --> 01:36:54.240]  он же сгенерировал
[01:36:54.240 --> 01:36:56.240]  по ходу компиляции 200 тысяч
[01:36:56.240 --> 01:36:58.240]  экземпляров Fibonacci.
[01:36:58.240 --> 01:37:00.240]  И в каждой из них
[01:37:00.240 --> 01:37:02.240]  статическая константа value есть.
[01:37:02.240 --> 01:37:04.240]  То есть это супер долго.
[01:37:04.240 --> 01:37:06.240]  И ему, то есть в compile time
[01:37:06.240 --> 01:37:08.240]  он вот это все проделал.
[01:37:08.240 --> 01:37:10.240]  И по идее
[01:37:10.240 --> 01:37:12.240]  все эти вот экземпляры
[01:37:12.240 --> 01:37:14.240]  этих структур Fibonacci, то есть все вот эти
[01:37:14.240 --> 01:37:16.240]  вот классы, определение классов, все
[01:37:16.240 --> 01:37:18.240]  он создал. Он их сгенерировал.
[01:37:18.240 --> 01:37:20.240]  У него 200 тысяч разных классов
[01:37:20.240 --> 01:37:22.240]  он скомпилировал, пока компилировал эту программу.
[01:37:22.240 --> 01:37:24.240]  Вот. Но он их
[01:37:24.240 --> 01:37:26.240]  не вписал в бинарник, потому что
[01:37:26.240 --> 01:37:28.240]  ему только один из них потребовался, он
[01:37:28.240 --> 01:37:30.240]  константу вывел.
[01:37:30.240 --> 01:37:32.240]  Вот. Но вообще-то
[01:37:32.240 --> 01:37:34.240]  если вы генерируете
[01:37:34.240 --> 01:37:36.240]  если вы, короче, генерируете шаблонный
[01:37:36.240 --> 01:37:38.240]  код, имейте в виду, что компилятор
[01:37:38.240 --> 01:37:40.240]  реально создает вот такое количество
[01:37:40.240 --> 01:37:42.240]  классов, которые вы тут запросили,
[01:37:42.240 --> 01:37:44.240]  когда шаблонные рекурсии ему организовали.
[01:37:44.240 --> 01:37:46.240]  А почему у тебя переполнение
[01:37:46.240 --> 01:37:48.240]  не произошло?
[01:37:48.240 --> 01:37:50.240]  А переполнение чего должно было произойти?
[01:37:50.240 --> 01:37:52.240]  Не знаю, stack, допустим.
[01:37:52.240 --> 01:37:54.240]  Зачем? Откуда?
[01:37:54.240 --> 01:37:56.240]  Он сказал stack nearly exhausted,
[01:37:56.240 --> 01:37:58.240]  но не переполнился, видишь?
[01:37:58.240 --> 01:38:00.240]  А, это warning он
[01:38:00.240 --> 01:38:02.240]  выкопал. Это warning, да.
[01:38:02.240 --> 01:38:04.240]  Ну, я не знаю.
[01:38:04.240 --> 01:38:06.240]  Вот, кстати, G++ как бы
[01:38:06.240 --> 01:38:08.240]  с этим справился можно проверить.
[01:38:08.240 --> 01:38:10.240]  А, G++ падает.
[01:38:10.240 --> 01:38:12.240]  А это что?
[01:38:16.240 --> 01:38:18.240]  А, во-во-во, да-да-да.
[01:38:18.240 --> 01:38:20.240]  Вот G++ не справляется. О-о-о!
[01:38:20.240 --> 01:38:22.240]  Да-да-да.
[01:38:22.240 --> 01:38:24.240]  Да.
[01:38:24.240 --> 01:38:26.240]  Да, смотрите, смотрите,
[01:38:26.240 --> 01:38:28.240]  смотрите, что произошло.
[01:38:28.240 --> 01:38:30.240]  Сейчас G++ упал
[01:38:30.240 --> 01:38:32.240]  из-за того, что
[01:38:32.240 --> 01:38:34.240]  произошел segfault в compile-time.
[01:38:34.240 --> 01:38:36.240]  Потому что
[01:38:36.240 --> 01:38:38.240]  пока он инстанцировал,
[01:38:38.240 --> 01:38:40.240]  пока он инстанцировал эти 200...
[01:38:40.240 --> 01:38:42.240]  Ну, C-Lang справился. C-Lang, видимо,
[01:38:42.240 --> 01:38:44.240]  более оптимально это делает.
[01:38:44.240 --> 01:38:46.240]  А G++ не справился инстанцировать
[01:38:46.240 --> 01:38:48.240]  200 тысяч шаблонов.
[01:38:48.240 --> 01:38:50.240]  И упал с segfault в compile-time.
[01:38:50.240 --> 01:38:52.240]  Internal compiler error.
[01:38:52.240 --> 01:38:54.240]  Причем, смотрите,
[01:38:54.240 --> 01:38:56.240]  в чем не сказали.
[01:38:56.240 --> 01:38:58.240]  А, вот...
[01:38:58.240 --> 01:39:00.240]  Да что же такое это? Нет, не посылать ничего.
[01:39:02.240 --> 01:39:04.240]  Segmentation false signal
[01:39:04.240 --> 01:39:06.240]  terminated program CC1+.
[01:39:06.240 --> 01:39:08.240]  Вот, помните, я вам говорил, ну или Федя вам рассказывал,
[01:39:08.240 --> 01:39:10.240]  что компиляция состоит
[01:39:10.240 --> 01:39:12.240]  из нескольких частей,
[01:39:12.240 --> 01:39:14.240]  и первая из этих частей там подстановка.
[01:39:14.240 --> 01:39:16.240]  Вот CC1+, это что такое?
[01:39:16.240 --> 01:39:18.240]  Это вот та самая программа,
[01:39:18.240 --> 01:39:20.240]  которая непосредственно компиляция занимается,
[01:39:20.240 --> 01:39:22.240]  то есть у вас G++ — это же конвейер.
[01:39:22.240 --> 01:39:24.240]  Там сначала идет распаковка инклудов,
[01:39:24.240 --> 01:39:26.240]  потом идет непосредственно компиляция,
[01:39:26.240 --> 01:39:28.240]  потом идет линковка.
[01:39:28.240 --> 01:39:30.240]  То есть у вас на самом деле две программы
[01:39:30.240 --> 01:39:32.240]  сначала...
[01:39:32.240 --> 01:39:34.240]  Ну, подстановка инклудов,
[01:39:34.240 --> 01:39:36.240]  потом CC1+, вот эта та самая
[01:39:36.240 --> 01:39:38.240]  программа, которая непосредственно
[01:39:38.240 --> 01:39:40.240]  компиляцию выполняет, кода,
[01:39:40.240 --> 01:39:42.240]  то есть языковую компиляцию.
[01:39:42.240 --> 01:39:44.240]  А потом вызывается LD-линковщик.
[01:39:44.240 --> 01:39:46.240]  И вот у нас segfault
[01:39:46.240 --> 01:39:49.280]  программу cc1+, здесь написано
[01:39:49.280 --> 01:39:51.200]  Segmentation Folded Signal Terminated Program
[01:39:51.200 --> 01:39:53.880]  cc1+, то есть операционная система убила
[01:39:53.880 --> 01:39:55.960]  вот тот самый cc1+, который
[01:39:55.960 --> 01:39:58.040]  компиляция занимался,
[01:39:58.040 --> 01:40:00.800]  пока он компилировал. И g++
[01:40:00.800 --> 01:40:02.680]  сказал, что произошла internal compiler error.
[01:40:02.680 --> 01:40:11.400]  И мы с вами сейчас научимся проверять
[01:40:11.400 --> 01:40:14.600]  число на простоту в Compile Timer.
[01:40:16.720 --> 01:40:19.400]  Но я сделаю это за ОАТН,
[01:40:19.400 --> 01:40:22.400]  а вам надо будет за ОАТ нормального.
[01:40:22.400 --> 01:40:24.400]  Ну чего-то.
[01:40:24.400 --> 01:40:27.400]  Ну...
[01:40:30.820 --> 01:40:33.360]  Если вы сделаете закон
[01:40:33.360 --> 01:40:36.360]  в четвертой степени, можно будет, не знаю,
[01:40:36.360 --> 01:40:39.360]  до балл дать.
[01:40:43.360 --> 01:40:45.880]  Ну, в смысле, до балла-то, типа,
[01:40:45.880 --> 01:40:48.680]  не по 10 бальней шкале, конечно, и даже не по...
[01:40:52.200 --> 01:40:58.600]  Корень четвертой степени на шаблонах, проверка на простоту, на шаблонах, не в обычных проверках.
[01:40:58.600 --> 01:41:02.120]  Корень четвертой степени это долго, можно же там выскокать, залог квадрата.
[01:41:02.120 --> 01:41:04.120]  Ой, какой лог квадрат?
[01:41:04.120 --> 01:41:05.120]  Залог квадрат.
[01:41:05.120 --> 01:41:07.960]  Нет, залог квадрат вряд ли.
[01:41:07.960 --> 01:41:15.560]  Лучшее, что я знаю, если детерминированно, это, это, кстати, вам Райгородский на конце первого курса расскажет.
[01:41:16.520 --> 01:41:19.560]  Если мы хотим не разложить, а только проверить на частоту, там же есть...
[01:41:19.560 --> 01:41:20.560]  На простоту.
[01:41:20.560 --> 01:41:22.560]  Продлинг-ризайн, наверное.
[01:41:22.560 --> 01:41:24.560]  Что там есть?
[01:41:24.560 --> 01:41:31.560]  Если ты про алгоритм Миллера Рабина, то он работает за куб, и то это при том, что ты фурье пишешь.
[01:41:31.560 --> 01:41:34.560]  Там в кубе логу log n получается.
[01:41:34.560 --> 01:41:38.560]  То есть четвертой степень, короче, там примерно.
[01:41:38.560 --> 01:41:42.560]  И еще и при этом у него вероятность ошибки есть.
[01:41:42.560 --> 01:41:44.560]  Ну, короче, все плохо там.
[01:41:44.560 --> 01:41:47.560]  Так, что-то мы какую-то вот фигню сегодня обсуждаем.
[01:41:47.560 --> 01:41:49.560]  Давайте плюсы лучше пообсуждаем.
[01:41:49.560 --> 01:41:54.560]  Давайте, давайте пообсуждаем.
[01:41:54.560 --> 01:41:57.560]  А у нас опять запись идет или нет на этот раз, я не знаю.
[01:41:57.560 --> 01:42:00.560]  Давайте подумаем, как вот проверить, что...
[01:42:00.560 --> 01:42:02.560]  Прости, а за сколько нам нужно сделать?
[01:42:02.560 --> 01:42:04.560]  Да за корень квадратный.
[01:42:06.560 --> 01:42:10.560]  Эх, нет, хотите, я вас за корень четвертой степени сделаю.
[01:42:10.560 --> 01:42:14.560]  И не сделаем, будете РО-полоку на шаблонах писать, но не надо.
[01:42:14.560 --> 01:42:16.560]  А не в этом цель.
[01:42:16.560 --> 01:42:22.560]  Так, вообще, на самом деле, может быть, я вам и не буду показывать, а вы сами напишите просто.
[01:42:22.560 --> 01:42:24.560]  Можно показать просто?
[01:42:24.560 --> 01:42:27.560]  Давайте я идейно покажу, что надо сделать, да?
[01:42:27.560 --> 01:42:29.560]  На шаблонах, да.
[01:42:29.560 --> 01:42:30.560]  На шаблонах.
[01:42:30.560 --> 01:42:33.560]  Ну, смотрите, template, type name...
[01:42:33.560 --> 01:42:35.560]  Ой, какой type name?
[01:42:35.560 --> 01:42:37.560]  int n
[01:42:41.560 --> 01:42:49.560]  Я недавно научился, после того, как Вим поискал какую-то строку, чтобы сделать ее неподсвеченной, надо набрать команду NOH.
[01:42:49.560 --> 01:42:51.560]  Вы знали о таком?
[01:42:51.560 --> 01:42:52.560]  Да.
[01:42:52.560 --> 01:42:58.560]  О чем Mustang Overflow за этот ответ набрал 1970 очков.
[01:42:58.560 --> 01:43:04.560]  И, таким образом, 19700 рейтинга, а весь его рейтинг это 27000.
[01:43:04.560 --> 01:43:11.560]  То есть, просто за один этот факт ты стал звездой Static Overflow, понимаете?
[01:43:11.560 --> 01:43:18.560]  А вы говорите, если бы Static Overflow исчезло, можно было бы заново на таком рейтинг набирать, а не как сейчас.
[01:43:18.560 --> 01:43:24.560]  Так вот, структура isPrime будет у меня.
[01:43:24.560 --> 01:43:30.560]  В ней будет static const bool value равно...
[01:43:30.560 --> 01:43:35.560]  А вот теперь давайте подумаем, что надо здесь написать.
[01:43:42.560 --> 01:43:47.560]  Наверное, мне нужен, знаете, такой helper.
[01:43:47.560 --> 01:43:51.560]  Но я буду сейчас перебирать делители.
[01:43:51.560 --> 01:43:55.560]  На самом деле, блин, неинтересно, я сейчас за вас свою задачу решу почти.
[01:43:55.560 --> 01:44:00.560]  Ну давайте, да, я напишу template int int int d.
[01:44:00.560 --> 01:44:05.560]  struct isPrime helper.
[01:44:05.560 --> 01:44:07.560]  И тут будет примерно такое.
[01:44:07.560 --> 01:44:09.560]  Значит, что здесь будет?
[01:44:09.560 --> 01:44:12.560]  Ну, он будет...
[01:44:12.560 --> 01:44:18.560]  Когда я дошел до...
[01:44:18.560 --> 01:44:24.560]  Ну, что-то не хочу я дописывать, потому что сейчас все сразу станет вам всем очевидно.
[01:44:24.560 --> 01:44:27.560]  Давайте я все-таки не буду дописывать, а то слишком легко.
[01:44:27.560 --> 01:44:30.560]  Да, я примерно так, может быть, сейчас и оставлю, не буду дописывать.
[01:44:30.560 --> 01:44:32.560]  Ну, смотрите.
[01:44:32.560 --> 01:44:34.560]  В чем идея? Я имитирую цикл.
[01:44:34.560 --> 01:44:36.560]  То есть этот isPrime helper, он рекурсивный.
[01:44:36.560 --> 01:44:42.560]  И он, грубо говоря, проверяет делимость стен на D.
[01:44:42.560 --> 01:44:45.560]  Да, да, именно.
[01:44:45.560 --> 01:44:49.560]  Программирование на шаблонах это функциональное программирование, если вы знаете, что это такое.
[01:44:49.560 --> 01:44:56.560]  По сути, программирование на шаблонах это и есть функциональный язык внутри языка C++, да.
[01:44:56.560 --> 01:44:58.560]  А...
[01:44:58.560 --> 01:45:00.560]  Так вот.
[01:45:00.560 --> 01:45:01.560]  Я что должен сделать?
[01:45:01.560 --> 01:45:03.560]  Ну, я начну перебирать делители.
[01:45:03.560 --> 01:45:04.560]  То есть я буду говорить.
[01:45:04.560 --> 01:45:13.560]  Это равно isPrime helper от n запятая n, допустим, 2.2.value.
[01:45:13.560 --> 01:45:17.560]  И этот isPrime helper, он будет...
[01:45:17.560 --> 01:45:23.560]  Рекурсию делать такую, он будет спрашивать isPrime helper...
[01:45:23.560 --> 01:45:28.560]  Ну, если n делится на D, то ответ сразу false.
[01:45:28.560 --> 01:45:34.560]  А если нет, то рекурсивно вы isPrime helper от n запятая d-1 уходим.
[01:45:34.560 --> 01:45:36.560]  Понимаете?
[01:45:36.560 --> 01:45:37.560]  Ну и все.
[01:45:37.560 --> 01:45:41.560]  Ну, там нужно будет обработать хвост, то есть там, когда D равно единице, допустим.
[01:45:41.560 --> 01:45:43.560]  Ну, он делится всегда.
[01:45:43.560 --> 01:45:48.560]  Ну, надо обработать, ну и надо сделать, чтобы не все мы числа проверяли, а только числа до корня.
[01:45:48.560 --> 01:45:49.560]  Вот.
[01:45:49.560 --> 01:45:51.560]  Функцию с qrt вызывать нельзя.
[01:45:54.560 --> 01:45:55.560]  Как?
[01:45:55.560 --> 01:45:57.560]  Ну, так можно, вот нельзя.
[01:45:58.560 --> 01:45:59.560]  Зато можно в квадрат возвести.
[01:45:59.560 --> 01:46:01.560]  Да, в квадрат можно возводить.
[01:46:01.560 --> 01:46:04.560]  Можно все ребята в квадрат вызвести, как мы знаем.
[01:46:05.560 --> 01:46:06.560]  В compile time?
[01:46:06.560 --> 01:46:07.560]  Нет.
[01:46:07.560 --> 01:46:08.560]  Нет.
[01:46:08.560 --> 01:46:12.560]  Сейчас, у тебя же isPrime helper нет еще никакого value?
[01:46:12.560 --> 01:46:15.560]  Ну, я не написал специально, чтобы вам сложнее было.
[01:46:16.560 --> 01:46:18.560]  А же, может повторить, пожалуйста, еще раз?
[01:46:18.560 --> 01:46:19.560]  Ну, еще раз.
[01:46:19.560 --> 01:46:20.560]  Это рекурсивная штука.
[01:46:20.560 --> 01:46:21.560]  Там же запись.
[01:46:21.560 --> 01:46:23.560]  Все, вот можно же на записи пересмотреть потом.
[01:46:23.560 --> 01:46:26.560]  И я уже, я уже рассказал решение по суде, что надо написать.
[01:46:26.560 --> 01:46:33.560]  Надо просто сделать рекурсивный, ну, цикл надо делать такой, как бы, с помощью рекурсии имитировать цикл.
[01:46:33.560 --> 01:46:39.560]  Если это делится над D, то ответ сразу false, а если нет, то переходим из isPrime helper от n и d-1.
[01:46:39.560 --> 01:46:40.560]  Ого.
[01:46:40.560 --> 01:46:41.560]  Ну, это завод от n.
[01:46:41.560 --> 01:46:48.560]  А если надо завод корни из n, ну, надо, блин, просто делители от одного до корни из n перебирать там и все.
[01:46:48.560 --> 01:46:49.560]  Ну, вот и все.
[01:46:49.560 --> 01:46:54.560]  Таким образом, у нас будет isPrime в compile time проверять число на простоту.
[01:46:54.560 --> 01:46:55.560]  А там можно тернарный?
[01:46:55.560 --> 01:46:57.560]  Тернарный оператор можно.
[01:46:58.560 --> 01:47:01.560]  А там разве не только тернарный можно оператором?
[01:47:01.560 --> 01:47:02.560]  Значит, только тернарный.
[01:47:02.560 --> 01:47:03.560]  Нет, ну как?
[01:47:03.560 --> 01:47:04.560]  А как?
[01:47:05.560 --> 01:47:07.560]  Мы же value что-то присваиваем.
[01:47:07.560 --> 01:47:12.560]  Нет, ну можно разные операторы использовать, не знаю, оператор плюс можно использовать.
[01:47:12.560 --> 01:47:14.560]  Конечно же, только тернарный оператор.
[01:47:14.560 --> 01:47:17.560]  Ну, для if-ов.
[01:47:18.560 --> 01:47:19.560]  Да ну вы не получится, да?
[01:47:19.560 --> 01:47:22.560]  If-ов нету. У вас есть только шаблоны.
[01:47:25.560 --> 01:47:26.560]  Все.
[01:47:26.560 --> 01:47:30.560]  Так, это был пункт 6.5.
[01:47:30.560 --> 01:47:37.560]  А мы можем там завести переменную, как-то что-то с ней сделать, а потом сказать, что наша статическая константа равна этой переменной?
[01:47:37.560 --> 01:47:38.560]  Нет.
[01:47:38.560 --> 01:47:40.560]  Что такое переменная?
[01:47:40.560 --> 01:47:43.560]  Нет, вы только константы можете заводить.
[01:47:43.560 --> 01:47:45.560]  Ой, какая боль.
[01:47:45.560 --> 01:47:47.560]  Ну, в смысле, стандарт — это эмоциональная штука.
[01:47:47.560 --> 01:47:49.560]  Почему не констант?
[01:47:49.560 --> 01:47:50.560]  Что мешает?
[01:47:50.560 --> 01:47:52.560]  Какие завещенцы в этом пишут?
[01:47:52.560 --> 01:47:58.560]  Потому что нельзя в compile time заводить переменную, не лезть с константами времени компиляции.
[01:47:58.560 --> 01:48:01.560]  Не просто константы, а константы времени компиляции только завершены.
[01:48:03.560 --> 01:48:05.560]  Компилятор не будет.
[01:48:07.560 --> 01:48:12.560]  Создавать в compile time переменную не конст.
[01:48:14.560 --> 01:48:15.560]  Все.
[01:48:16.560 --> 01:48:17.560]  Правила такие.
[01:48:17.560 --> 01:48:20.560]  Как решил комитет постанализации, что еще могу сказать?
[01:48:20.560 --> 01:48:23.560]  Ну в смысле, а как-то сделать не так?
[01:48:23.560 --> 01:48:25.560]  Это же невозможно не так.
[01:48:26.560 --> 01:48:35.560]  Ну, теоретически можно было бы заставить компилятор в compile time выполнять произвольный код просто с обычными переменными.
[01:48:35.560 --> 01:48:39.560]  И в общем-то так оно и сделано уже в C++, даже 11.
[01:48:39.560 --> 01:48:44.560]  Просто нужно правильные волшебные слова употребить.
[01:48:44.560 --> 01:48:48.560]  Есть волшебное слово, которое говорит, пожалуйста, все-таки заведи не константы в compile time.
[01:48:48.560 --> 01:48:49.560]  Но вам нельзя.
[01:48:49.560 --> 01:48:51.560]  Вы будете пока только...
[01:48:51.560 --> 01:48:52.560]  Мы еще не научим.
[01:48:52.560 --> 01:48:53.560]  Да, вы будете страдать, да.
[01:48:53.560 --> 01:48:57.560]  А во втором семестре мы научимся страдать более естественно.
[01:49:00.560 --> 01:49:03.560]  Пункт 6.6 называется...
[01:49:06.560 --> 01:49:07.560]  Вот так.
[01:49:09.560 --> 01:49:10.560]  Dependent names.
[01:49:12.560 --> 01:49:13.560]  Зависимые имена.
[01:49:14.560 --> 01:49:20.560]  Это такой технический пункт, который вам...
[01:49:21.560 --> 01:49:26.560]  В общем-то, в этом пункте я не расскажу никаких новых возможностей,
[01:49:26.560 --> 01:49:32.560]  а лишь опишу вам некоторые проблемы, о которых вы, скорее всего, не задумывались до сих пор,
[01:49:32.560 --> 01:49:37.560]  и некоторые технические костыли, как комитет по стратизации придумал их решить.
[01:49:37.560 --> 01:49:38.560]  А зачем я их опишу?
[01:49:38.560 --> 01:49:43.560]  Да потому что мы с ними уже скоро начнем сталкиваться вот прямо в ближайшее время,
[01:49:43.560 --> 01:49:47.560]  и вы будете спрашивать, почему костыли им... почему такой костыль.
[01:49:47.560 --> 01:49:48.560]  Ну вот сейчас узнаете.
[01:49:49.560 --> 01:49:57.560]  Вот когда мы добавили в язык шаблоны, у нас появилась следующая интересная история.
[01:49:57.560 --> 01:49:59.560]  Вот давайте я заведу такую структуру,
[01:50:03.560 --> 01:50:07.560]  а в ней заведу шаблонную структуру.
[01:50:14.560 --> 01:50:15.560]  Или даже не так.
[01:50:18.560 --> 01:50:20.560]  Да не, все нормально, да.
[01:50:22.560 --> 01:50:28.560]  Сейчас я вспомню этот пример, я его каждый раз забываю, каждый раз заново придумываю.
[01:50:29.560 --> 01:50:31.560]  Значит, тут у меня есть такая шаблонная структура,
[01:50:36.560 --> 01:50:39.560]  и в ней пусть у меня будет, скажем,
[01:50:39.560 --> 01:50:41.560]  функция F,
[01:50:49.560 --> 01:50:50.560]  которая...
[01:50:58.560 --> 01:51:00.560]  Сейчас, дайте мне минутку подумать.
[01:51:09.560 --> 01:51:10.560]  А, ну да.
[01:51:11.560 --> 01:51:13.560]  Значит, и здесь у меня будет написано using...
[01:51:23.560 --> 01:51:25.560]  Да, вот как будет сейчас.
[01:51:25.560 --> 01:51:26.560]  Сейчас вам скажу.
[01:51:26.560 --> 01:51:27.560]  Смотрите.
[01:51:27.560 --> 01:51:29.560]  У меня есть шаблонная структура,
[01:51:29.560 --> 01:51:31.560]  и в ней написано using...
[01:51:31.560 --> 01:51:32.560]  О.
[01:51:32.560 --> 01:51:34.560]  Класс.
[01:51:34.560 --> 01:51:36.560]  Теперь я напишу специализацию.
[01:51:38.560 --> 01:51:40.560]  От типа, ну я не знаю, от какого.
[01:51:40.560 --> 01:51:41.560]  От какого хочу.
[01:51:45.560 --> 01:51:47.560]  Там, скажем.
[01:51:51.560 --> 01:51:52.560]  От какого хочу.
[01:51:52.560 --> 01:51:54.560]  От какого хочу.
[01:51:54.560 --> 01:51:56.560]  От какого хочу.
[01:51:56.560 --> 01:51:58.560]  От какого хочу.
[01:51:58.560 --> 01:52:00.560]  От какого хочу.
[01:52:01.560 --> 01:52:02.560]  Да хоть int.
[01:52:02.560 --> 01:52:05.560]  Ну давайте char, чтобы не казалось, что
[01:52:06.560 --> 01:52:08.560]  это как-то связанные типы.
[01:52:08.560 --> 01:52:14.560]  И здесь напишу static const int a равно нулю.
[01:52:20.560 --> 01:52:22.560]  Как вам, нравится?
[01:52:23.560 --> 01:52:25.560]  Вам вы уже предчувствуете, чем пахнет?
[01:52:25.560 --> 01:52:27.560]  Ну смотрите, я завел шаблонную структуру,
[01:52:27.560 --> 01:52:29.560]  и в ней вот
[01:52:32.560 --> 01:52:34.560]  сделал
[01:52:35.560 --> 01:52:36.560]  тип
[01:52:37.560 --> 01:52:39.560]  a, который равен int внутренней.
[01:52:39.560 --> 01:52:41.560]  А потом завел специализацию этой структурой,
[01:52:41.560 --> 01:52:43.560]  и в этой специализации...
[01:52:43.560 --> 01:52:45.560]  Ну слушайте, давайте даже я не так сделаю,
[01:52:45.560 --> 01:52:47.560]  я вот лучше так сделаю, скажем.
[01:52:47.560 --> 01:52:49.560]  Это неконкурсивная...
[01:52:51.560 --> 01:52:53.560]  Ну, я не знаю, что это такое.
[01:52:54.560 --> 01:52:56.560]  Вот так вот сделаю.
[01:52:56.560 --> 01:52:58.560]  То есть смотрите, если у меня структура
[01:52:58.560 --> 01:53:00.560]  от произвольного t, то в ней using a равно int.
[01:53:00.560 --> 01:53:02.560]  А если структура от t является указательным,
[01:53:02.560 --> 01:53:04.560]  то в ней static const int a равно нулю.
[01:53:05.560 --> 01:53:07.560]  А теперь
[01:53:07.560 --> 01:53:09.560]  я объявляю некоторую функцию f,
[01:53:09.560 --> 01:53:11.560]  ну разумеется шаблонную,
[01:53:13.560 --> 01:53:15.560]  которая
[01:53:16.560 --> 01:53:18.560]  в своем коде делает следующее.
[01:53:18.560 --> 01:53:20.560]  s с шаблонным параметром t
[01:53:20.560 --> 01:53:22.560]  2.2.a
[01:53:22.560 --> 01:53:24.560]  звездочка x
[01:53:28.560 --> 01:53:30.560]  а x это int.
[01:53:30.560 --> 01:53:32.560]  Ну x это...
[01:53:32.560 --> 01:53:34.560]  Ну пока непонятно, что такое x.
[01:53:35.560 --> 01:53:37.560]  Вот вы компилятор.
[01:53:37.560 --> 01:53:39.560]  Что здесь написано?
[01:53:41.560 --> 01:53:43.560]  Ну пока по сути ничего не описано,
[01:53:43.560 --> 01:53:45.560]  потому что у нас не задано ни один контекст для f.
[01:53:46.560 --> 01:53:48.560]  Нет, вы компилятор,
[01:53:48.560 --> 01:53:50.560]  и вам нужно этот код скомпилировать.
[01:53:50.560 --> 01:53:52.560]  Вот я говорю g++,
[01:53:52.560 --> 01:53:54.560]  я говорю t++,
[01:53:54.560 --> 01:53:56.560]  значит компилируй.
[01:53:56.560 --> 01:53:58.560]  Как ты будешь это компилировать?
[01:53:58.560 --> 01:54:00.560]  Вот здесь вот,
[01:54:00.560 --> 01:54:02.560]  что ты скажешь на этой строчке?
[01:54:02.560 --> 01:54:04.560]  Хорошо,
[01:54:04.560 --> 01:54:06.560]  если я здесь напишу вот так,
[01:54:06.560 --> 01:54:08.560]  ты что-нибудь скажешь мне?
[01:54:08.560 --> 01:54:10.560]  Что ты скажешь?
[01:54:10.560 --> 01:54:12.560]  Непонятно, что такое set?
[01:54:12.560 --> 01:54:14.560]  Правильно? Нет.
[01:54:14.560 --> 01:54:16.560]  У тебя будет семантическая ошибка,
[01:54:16.560 --> 01:54:18.560]  у тебя будет объявленный идентификатор set.
[01:54:18.560 --> 01:54:20.560]  Какая ошибка будет здесь?
[01:54:20.560 --> 01:54:22.560]  Ты как компилятор,
[01:54:22.560 --> 01:54:24.560]  как ты должен эту строчку понять?
[01:54:24.560 --> 01:54:26.560]  А точная ошибка будет?
[01:54:26.560 --> 01:54:28.560]  Это тоже вопрос.
[01:54:28.560 --> 01:54:30.560]  Будет ли ошибка и какая?
[01:54:30.560 --> 01:54:32.560]  Одну для первой версии, а вторую для специализации?
[01:54:32.560 --> 01:54:34.560]  Ты компилируешь,
[01:54:34.560 --> 01:54:36.560]  пока сим, вот тебе нужно
[01:54:36.560 --> 01:54:38.560]  прочитать этот код,
[01:54:38.560 --> 01:54:40.560]  я еще не вызвал f ни с каким t,
[01:54:40.560 --> 01:54:42.560]  я ничего не подставил никуда,
[01:54:42.560 --> 01:54:44.560]  я не попросил сгенерировать тебя f,
[01:54:44.560 --> 01:54:46.560]  вот какая здесь,
[01:54:46.560 --> 01:54:48.560]  это что, как это расправить?
[01:54:48.560 --> 01:54:50.560]  Непонятно, куда пойдет
[01:54:50.560 --> 01:54:52.560]  t,
[01:54:52.560 --> 01:54:54.560]  но в зависимости от того,
[01:54:54.560 --> 01:54:56.560]  от кого выберется первая перегрузка,
[01:54:56.560 --> 01:54:58.560]  не повторяй.
[01:54:58.560 --> 01:55:00.560]  Так, вы не понимаете моего вопроса.
[01:55:00.560 --> 01:55:02.560]  Вот я написал
[01:55:02.560 --> 01:55:04.560]  g++, вот этот код,
[01:55:04.560 --> 01:55:06.560]  .cpp,
[01:55:06.560 --> 01:55:08.560]  как компилятор должен прочитать эту строчку?
[01:55:08.560 --> 01:55:10.560]  Можно поругаться на то,
[01:55:10.560 --> 01:55:12.560]  что у нас a может не являться
[01:55:12.560 --> 01:55:14.560]  x,
[01:55:14.560 --> 01:55:16.560]  но
[01:55:16.560 --> 01:55:18.560]  можно и не ругаться,
[01:55:18.560 --> 01:55:20.560]  потому что
[01:55:20.560 --> 01:55:22.560]  код может быть корректным,
[01:55:22.560 --> 01:55:24.560]  в зависимости от того,
[01:55:24.560 --> 01:55:26.560]  от какой мы тейпы были.
[01:55:26.560 --> 01:55:28.560]  На самом деле, то, что вы сказали, так и будет сейчас.
[01:55:28.560 --> 01:55:30.560]  Dependent names.
[01:55:32.560 --> 01:55:34.560]  А, нет, вру,
[01:55:34.560 --> 01:55:36.560]  он поругался не на это, сейчас,
[01:55:36.560 --> 01:55:38.560]  сейчас, сейчас.
[01:55:38.560 --> 01:55:40.560]  x,
[01:55:40.560 --> 01:55:42.560]  вы забудете здесь x,
[01:55:42.560 --> 01:55:44.560]  это стока с объявлением
[01:55:44.560 --> 01:55:46.560]  a.
[01:55:46.560 --> 01:55:48.560]  Нет, он поругался,
[01:55:48.560 --> 01:55:50.560]  в общем-то, правильно он поругался,
[01:55:50.560 --> 01:55:52.560]  это я просто неправильно понял, что он так.
[01:55:52.560 --> 01:55:54.560]  Он мне сказал, что x не объявлен.
[01:55:54.560 --> 01:55:56.560]  Он воспринял a как переменную,
[01:55:56.560 --> 01:55:58.560]  а не как название типа.
[01:55:58.560 --> 01:56:00.560]  А что дальше происходит?
[01:56:00.560 --> 01:56:02.560]  Ничего, не происходит.
[01:56:02.560 --> 01:56:04.560]  Ну как, что ли?
[01:56:04.560 --> 01:56:06.560]  Значит, компилятору
[01:56:06.560 --> 01:56:08.560]  надо как-то партии,
[01:56:08.560 --> 01:56:10.560]  как-то читать, синтоксически же надо ему
[01:56:10.560 --> 01:56:12.560]  как-то читать ваш код,
[01:56:12.560 --> 01:56:14.560]  когда вы пишете шаблоны.
[01:56:14.560 --> 01:56:16.560]  Даже если вы не
[01:56:16.560 --> 01:56:18.560]  подставили ничего в шаблон,
[01:56:18.560 --> 01:56:20.560]  компилятор должен как-то это прочитать.
[01:56:20.560 --> 01:56:22.560]  Ему нужно понять,
[01:56:22.560 --> 01:56:24.560]  это expression или declaration.
[01:56:24.560 --> 01:56:26.560]  Вы понимаете, что здесь проблема в том,
[01:56:26.560 --> 01:56:28.560]  это что вообще?
[01:56:28.560 --> 01:56:30.560]  Это понимать как объявление указателя типа
[01:56:30.560 --> 01:56:32.560]  такого и название его x
[01:56:32.560 --> 01:56:34.560]  или как умножение величины
[01:56:34.560 --> 01:56:36.560]  a на x.
[01:56:36.560 --> 01:56:38.560]  Компилятор вообще не знает,
[01:56:38.560 --> 01:56:40.560]  что такое a.
[01:56:40.560 --> 01:56:42.560]  Оно может быть разным в зависимости от разных t,
[01:56:42.560 --> 01:56:44.560]  и компилятор даже не будет пытаться выяснять,
[01:56:44.560 --> 01:56:46.560]  при разных t действительно у него
[01:56:46.560 --> 01:56:48.560]  разная семантика или нет.
[01:56:48.560 --> 01:56:50.560]  Компилятору нужно в отрыве от всех t
[01:56:50.560 --> 01:56:52.560]  как-то прочитать эту строчку,
[01:56:52.560 --> 01:56:54.560]  как он это будет делать.
[01:56:54.560 --> 01:56:56.560]  Так вот, правило следующее.
[01:56:56.560 --> 01:56:58.560]  Если у компилятора есть два варианта,
[01:56:58.560 --> 01:57:00.560]  как прочитать строчку,
[01:57:00.560 --> 01:57:02.560]  как тип или value,
[01:57:02.560 --> 01:57:04.560]  он будет читать как value.
[01:57:06.560 --> 01:57:08.560]  Правило такое,
[01:57:08.560 --> 01:57:10.560]  если у вас внутри шаблонного класса
[01:57:10.560 --> 01:57:12.560]  объявлено нечто,
[01:57:12.560 --> 01:57:14.560]  и вы
[01:57:14.560 --> 01:57:16.560]  в шаблонном коде
[01:57:16.560 --> 01:57:18.560]  обращаетесь к нему
[01:57:18.560 --> 01:57:20.560]  через двойной двойточие,
[01:57:20.560 --> 01:57:22.560]  то компилятор будет
[01:57:22.560 --> 01:57:24.560]  по умолчанию считать,
[01:57:24.560 --> 01:57:26.560]  что это не название типа,
[01:57:26.560 --> 01:57:28.560]  а это величина некоторая,
[01:57:28.560 --> 01:57:30.560]  статическая переменная.
[01:57:30.560 --> 01:57:32.560]  Просто правило такое,
[01:57:32.560 --> 01:57:34.560]  потому что компилятору нужно
[01:57:34.560 --> 01:57:36.560]  прочитать этот код
[01:57:36.560 --> 01:57:38.560]  еще до всех подстановок типов.
[01:57:38.560 --> 01:57:40.560]  Ему нужно синтоксический парсинг
[01:57:40.560 --> 01:57:42.560]  произвести до того,
[01:57:42.560 --> 01:57:44.560]  как он начнет подставлять t
[01:57:44.560 --> 01:57:46.560]  и что-то осмысленное делать.
[01:57:46.560 --> 01:57:48.560]  Да.
[01:57:48.560 --> 01:57:50.560]  Если бы у нас не было структуры,
[01:57:50.560 --> 01:57:52.560]  где i, то это статик...
[01:57:52.560 --> 01:57:54.560]  Неважно.
[01:57:54.560 --> 01:57:56.560]  Компилятор читает это как value.
[01:57:56.560 --> 01:57:58.560]  Компилятор читает это...
[01:57:58.560 --> 01:58:00.560]  Ему нужно провести синтоксический анализ этого.
[01:58:00.560 --> 01:58:02.560]  И во время синтоксического
[01:58:02.560 --> 01:58:04.560]  анализа компилятор совершенно
[01:58:04.560 --> 01:58:06.560]  не в состоянии пойти,
[01:58:06.560 --> 01:58:08.560]  полезть выше по коду,
[01:58:08.560 --> 01:58:10.560]  посмотреть, оправда ли во всех возможных
[01:58:10.560 --> 01:58:12.560]  специализациях этой структуры,
[01:58:12.560 --> 01:58:14.560]  а означает оно и то же,
[01:58:14.560 --> 01:58:16.560]  и это везде типа незначение. Нет.
[01:58:16.560 --> 01:58:18.560]  Компилятор во время синтоксического анализа
[01:58:18.560 --> 01:58:20.560]  не будет такое делать. При синтоксическом анализе
[01:58:20.560 --> 01:58:22.560]  компилятор парсит это как value,
[01:58:22.560 --> 01:58:24.560]  а не как тип.
[01:58:24.560 --> 01:58:26.560]  Да, даже если оно...
[01:58:26.560 --> 01:58:28.560]  Потому что компилятор не будет
[01:58:28.560 --> 01:58:30.560]  во время синтоксического анализа
[01:58:30.560 --> 01:58:32.560]  верить, что получается.
[01:58:32.560 --> 01:58:34.560]  Это задача совершенно другого уровня.
[01:58:34.560 --> 01:58:36.560]  Компилятор должен делать...
[01:58:36.560 --> 01:58:38.560]  Должен для начала сделать просто
[01:58:38.560 --> 01:58:40.560]  синтоксический анализ.
[01:58:40.560 --> 01:58:42.560]  А если мы напишем вместо a, например,
[01:58:42.560 --> 01:58:44.560]  set?
[01:58:44.560 --> 01:58:46.560]  Поэтому...
[01:58:46.560 --> 01:58:48.560]  Ну, давайте я закомментирую
[01:58:48.560 --> 01:58:50.560]  и покажу вам.
[01:58:50.560 --> 01:58:52.560]  Ошибка всё равно та же.
[01:58:52.560 --> 01:58:54.560]  Если вместо a set напишем,
[01:58:54.560 --> 01:58:56.560]  как он поймёт, что это уже настоящий set?
[01:58:56.560 --> 01:58:58.560]  Что... Какой set?
[01:58:58.560 --> 01:59:00.560]  Вот такой?
[01:59:00.560 --> 01:59:02.560]  Чего?
[01:59:02.560 --> 01:59:04.560]  В st вообще нет
[01:59:04.560 --> 01:59:06.560]  ничего с названием set.
[01:59:10.560 --> 01:59:12.560]  Нет, подожди.
[01:59:12.560 --> 01:59:14.560]  Set он как бы глобальный.
[01:59:14.560 --> 01:59:16.560]  Какой может быть set внутри s-a-t?
[01:59:16.560 --> 01:59:18.560]  Да, я имею ввиду, если он не внутри s-a-t,
[01:59:18.560 --> 01:59:20.560]  а просто set, как он поймёт,
[01:59:20.560 --> 01:59:22.560]  что это не труп, не элемент?
[01:59:24.560 --> 01:59:26.560]  Ты в отрыве от s-a-t
[01:59:26.560 --> 01:59:28.560]  вот ты спрашиваешь.
[01:59:28.560 --> 01:59:30.560]  То есть если я пишу std set,
[01:59:30.560 --> 01:59:32.560]  и что-то там? Или что?
[01:59:32.560 --> 01:59:34.560]  Нет, я имею ввиду, в какой момент он перестаёт
[01:59:34.560 --> 01:59:36.560]  считать, что это value.
[01:59:36.560 --> 01:59:38.560]  Что мне надо написать? Какой у тебя вопрос?
[01:59:38.560 --> 01:59:40.560]  Я не понимаю пока.
[01:59:40.560 --> 01:59:42.560]  Какой пример ты хочешь разобрать?
[01:59:42.560 --> 01:59:44.560]  Вот вы говорите, что a может быть
[01:59:44.560 --> 01:59:46.560]  везде типом, и всё равно он это
[01:59:46.560 --> 01:59:48.560]  проинтервизирует как value.
[01:59:48.560 --> 01:59:50.560]  Он... a это некоторая
[01:59:50.560 --> 01:59:52.560]  переменная внутри шаблонного класса.
[01:59:52.560 --> 01:59:54.560]  Где t ещё не подставленный
[01:59:54.560 --> 01:59:56.560]  тип?
[01:59:56.560 --> 01:59:58.560]  Вот если я здесь напишу std vector,
[01:59:58.560 --> 02:00:00.560]  помните, у нас в самом начале,
[02:00:00.560 --> 02:00:02.560]  когда мы с вами шаблоны делали,
[02:00:02.560 --> 02:00:04.560]  у нас была следующая проблема.
[02:00:06.560 --> 02:00:08.560]  Ну вот что-то такое я написал.
[02:00:08.560 --> 02:00:10.560]  И была именно эта проблема.
[02:00:14.560 --> 02:00:16.560]  Когда t не подставлена,
[02:00:16.560 --> 02:00:18.560]  а я внутрь шаблонного класса прохожу
[02:00:18.560 --> 02:00:20.560]  параметризуя его параметром t,
[02:00:20.560 --> 02:00:22.560]  компилятор уже не может понять,
[02:00:22.560 --> 02:00:24.560]  что итератор это вообще говоря тип или value.
[02:00:24.560 --> 02:00:26.560]  И поэтому, если я так пишу,
[02:00:26.560 --> 02:00:28.560]  компилятор считает, что итератор
[02:00:28.560 --> 02:00:30.560]  это некоторая переменная,
[02:00:30.560 --> 02:00:32.560]  а не тип.
[02:00:32.560 --> 02:00:34.560]  Если я нахожусь внутри шаблонного...
[02:00:34.560 --> 02:00:36.560]  если я нахожусь в шаблонном коде,
[02:00:36.560 --> 02:00:38.560]  параметризованном t, и внутри этого шаблонного кода
[02:00:38.560 --> 02:00:40.560]  у класса, параметризованного t,
[02:00:40.560 --> 02:00:42.560]  вызываю какое-то внутреннее имя,
[02:00:42.560 --> 02:00:44.560]  через двойное двоеточие,
[02:00:44.560 --> 02:00:46.560]  компилятор теряется, ему надо понять,
[02:00:46.560 --> 02:00:48.560]  это тип или value?
[02:00:48.560 --> 02:00:50.560]  И он решает, что это value, если я явно
[02:00:50.560 --> 02:00:52.560]  не скажу обратно. Понятно?
[02:00:52.560 --> 02:00:54.560]  А нужно писать слово type name.
[02:00:54.560 --> 02:00:56.560]  Вот здесь вот нужно
[02:00:56.560 --> 02:00:58.560]  писать type name.
[02:00:58.560 --> 02:01:00.560]  Я скажу, пожалуйста,
[02:01:00.560 --> 02:01:02.560]  а без этого type name, даже если вот...
[02:01:02.560 --> 02:01:04.560]  Еще раз спроси,
[02:01:04.560 --> 02:01:06.560]  даже если там не было специализации,
[02:01:06.560 --> 02:01:08.560]  в которой это value, да, третий раз
[02:01:08.560 --> 02:01:10.560]  повторяю, да, все равно будет CE,
[02:01:10.560 --> 02:01:12.560]  я это уже показал. У меня просто компелит
[02:01:12.560 --> 02:01:14.560]  если закомменитить.
[02:01:14.560 --> 02:01:16.560]  Какая у тебя версия?
[02:01:16.560 --> 02:01:18.560]  Я себе 17-ю выставил.
[02:01:18.560 --> 02:01:20.560]  Чего?
[02:01:20.560 --> 02:01:22.560]  Compilator какая версия,
[02:01:22.560 --> 02:01:24.560]  а не языка?
[02:01:24.560 --> 02:01:26.560]  It's a language++.
[02:01:26.560 --> 02:01:28.560]  Версия, это хороший вопрос.
[02:01:30.560 --> 02:01:32.560]  Забавно, что можно написать
[02:01:32.560 --> 02:01:34.560]  в этой же функции одно state name
[02:01:34.560 --> 02:01:36.560]  корректно, одну без...
[02:01:36.560 --> 02:01:38.560]  Вот, короче,
[02:01:38.560 --> 02:01:40.560]  вот, ну давайте
[02:01:40.560 --> 02:01:42.560]  я еще раз продемонстрирую, вот все равно
[02:01:42.560 --> 02:01:44.560]  ошибка.
[02:01:44.560 --> 02:01:46.560]  Если я сделаю C lang++,
[02:01:46.560 --> 02:01:48.560]  все равно ошибка.
[02:01:48.560 --> 02:01:50.560]  Та же самая причем.
[02:01:50.560 --> 02:01:52.560]  Необъявленный идентификатор.
[02:01:54.560 --> 02:01:56.560]  В том же самом,
[02:01:56.560 --> 02:01:58.560]  когда я пишу STD VectorT итератор,
[02:01:58.560 --> 02:02:00.560]  это абсолютно один в один та же ситуация.
[02:02:00.560 --> 02:02:02.560]  Один в один.
[02:02:02.560 --> 02:02:04.560]  VectorT итератор, что такое итератор,
[02:02:04.560 --> 02:02:06.560]  пока не известно, что такое T, непонятно,
[02:02:06.560 --> 02:02:08.560]  это тип или значение?
[02:02:12.560 --> 02:02:14.560]  Ну, все, для тех, кто знает,
[02:02:14.560 --> 02:02:16.560]  для тех было понятно.
[02:02:16.560 --> 02:02:18.560]  Для тех, кто не знает, потом столкнетесь.
[02:02:18.560 --> 02:02:20.560]  Вот, но это еще...
[02:02:20.560 --> 02:02:22.560]  Ладно, это еще цветочки.
[02:02:22.560 --> 02:02:24.560]  Есть
[02:02:24.560 --> 02:02:26.560]  пример более
[02:02:26.560 --> 02:02:28.560]  интересный.
[02:02:28.560 --> 02:02:30.560]  Да, собственно, почему этот параграм называется
[02:02:30.560 --> 02:02:32.560]  dependent names? Вот такие имена...
[02:02:32.560 --> 02:02:34.560]  Вот это вот называется dependent name.
[02:02:34.560 --> 02:02:36.560]  Вот это вот A называется зависимым
[02:02:36.560 --> 02:02:38.560]  именем, dependent name.
[02:02:38.560 --> 02:02:40.560]  Когда мы находимся в шаблонном коде
[02:02:40.560 --> 02:02:42.560]  и внутрь шаблонного класса проходим.
[02:02:42.560 --> 02:02:44.560]  Вот, но это еще...
[02:02:44.560 --> 02:02:46.560]  Ладно, это еще цветочки.
[02:02:46.560 --> 02:02:48.560]  А представьте, что у меня есть следующая
[02:02:48.560 --> 02:02:50.560]  штука.
[02:02:54.560 --> 02:02:56.560]  У меня еще тут есть
[02:02:56.560 --> 02:02:58.560]  template type int n
[02:02:58.560 --> 02:03:00.560]  using R,
[02:03:00.560 --> 02:03:02.560]  значит, и тут написано using R,
[02:03:02.560 --> 02:03:04.560]  но я не знаю, что.
[02:03:08.560 --> 02:03:10.560]  Ну,
[02:03:10.560 --> 02:03:12.560]  std array
[02:03:12.560 --> 02:03:14.560]  от
[02:03:14.560 --> 02:03:16.560]  int zeta n.
[02:03:20.560 --> 02:03:22.560]  Вот.
[02:03:22.560 --> 02:03:24.560]  И теперь я говорю.
[02:03:30.560 --> 02:03:32.560]  Вот так.
[02:03:40.560 --> 02:03:42.560]  Теперь смотрите, какая ситуация.
[02:03:42.560 --> 02:03:44.560]  Это может быть
[02:03:44.560 --> 02:03:46.560]  шаблоном?
[02:03:46.560 --> 02:03:48.560]  То есть, если
[02:03:48.560 --> 02:03:50.560]  я пришел в эту версию,
[02:03:50.560 --> 02:03:52.560]  то это я сейчас сделал не что иное,
[02:03:52.560 --> 02:03:54.560]  как объявил массив int в размере 5
[02:03:54.560 --> 02:03:56.560]  и назвал его x.
[02:03:56.560 --> 02:03:58.560]  Правильно?
[02:03:58.560 --> 02:04:00.560]  А если это
[02:04:00.560 --> 02:04:02.560]  другая версия,
[02:04:02.560 --> 02:04:04.560]  то я сейчас
[02:04:04.560 --> 02:04:06.560]  сделал следующее.
[02:04:06.560 --> 02:04:08.560]  Взял int,
[02:04:08.560 --> 02:04:10.560]  сравнил его с пятеркой,
[02:04:10.560 --> 02:04:12.560]  получился bool, неявно конвертировал bool в int,
[02:04:12.560 --> 02:04:14.560]  сравнил его с x.
[02:04:16.560 --> 02:04:18.560]  Вопрос.
[02:04:18.560 --> 02:04:20.560]  Как компилятор должен допарсить?
[02:04:20.560 --> 02:04:22.560]  Конечно же, вторым способом.
[02:04:22.560 --> 02:04:24.560]  Очевидно.
[02:04:24.560 --> 02:04:26.560]  Очевидно, я имел в виду именно это.
[02:04:26.560 --> 02:04:28.560]  Вот.
[02:04:32.560 --> 02:04:34.560]  Будет опять то же самое.
[02:04:34.560 --> 02:04:36.560]  Компилятор решает, что это
[02:04:36.560 --> 02:04:38.560]  сейчас int,
[02:04:38.560 --> 02:04:40.560]  что это некоторое value,
[02:04:40.560 --> 02:04:42.560]  которое я пытаюсь сравнить с пятеркой,
[02:04:42.560 --> 02:04:44.560]  а потом результат сравнить с x.
[02:04:44.560 --> 02:04:46.560]  Но у него Anticlade Artifier x.
[02:04:50.560 --> 02:04:52.560]  Давайте.
[02:04:58.560 --> 02:05:00.560]  Вот если я сейчас добавлю
[02:05:00.560 --> 02:05:02.560]  глобальный x, то ce исчезнет.
[02:05:06.560 --> 02:05:08.560]  Вот int, допустим.
[02:05:08.560 --> 02:05:10.560]  Ну, чтобы не отказать себя.
[02:05:10.560 --> 02:05:12.560]  Ну, все будет хорошо.
[02:05:12.560 --> 02:05:14.560]  Давайте.
[02:05:14.560 --> 02:05:16.560]  А, подожди, f от int.
[02:05:16.560 --> 02:05:18.560]  В смысле, чтобы я попал в первую версию?
[02:05:18.560 --> 02:05:20.560]  Да.
[02:05:20.560 --> 02:05:22.560]  Будет ce.
[02:05:22.560 --> 02:05:24.560]  А, нет.
[02:05:24.560 --> 02:05:26.560]  Сейчас я соображу, что будет.
[02:05:28.560 --> 02:05:30.560]  Подождите, я хочу сначала
[02:05:30.560 --> 02:05:32.560]  разобрать то, к чему мы пришли.
[02:05:32.560 --> 02:05:34.560]  Я сделал глобальный x.
[02:05:34.560 --> 02:05:36.560]  И как компилятор это прочитал?
[02:05:36.560 --> 02:05:38.560]  Почему он не выдал мне никакой ошибки?
[02:05:38.560 --> 02:05:40.560]  Что я с чем пытаюсь сравнить?
[02:05:40.560 --> 02:05:42.560]  Что за бред я делаю?
[02:05:42.560 --> 02:05:44.560]  Какой ноль?
[02:05:44.560 --> 02:05:46.560]  Он не знает, что такое a.
[02:05:46.560 --> 02:05:48.560]  А есть внутри...
[02:05:48.560 --> 02:05:50.560]  А есть внутри темплейта.
[02:05:50.560 --> 02:05:52.560]  И что?
[02:05:52.560 --> 02:05:54.560]  Он не заходит внутрь темплейта.
[02:05:54.560 --> 02:05:56.560]  В смысле, он синтактически это распарсил?
[02:05:56.560 --> 02:05:58.560]  Все нашлось?
[02:05:58.560 --> 02:06:00.560]  Да.
[02:06:00.560 --> 02:06:02.560]  Все правильно.
[02:06:02.560 --> 02:06:04.560]  Нужно понимать, что компиляция
[02:06:04.560 --> 02:06:06.560]  шаблонного кода, она
[02:06:06.560 --> 02:06:08.560]  состоит из двух стадий.
[02:06:08.560 --> 02:06:10.560]  И синтаксический анализ не требует
[02:06:10.560 --> 02:06:12.560]  подстановки t никаких.
[02:06:12.560 --> 02:06:14.560]  Вот эта ошибка о том,
[02:06:14.560 --> 02:06:16.560]  что x не объявлен в идентификаторе,
[02:06:16.560 --> 02:06:18.560]  это ошибка
[02:06:18.560 --> 02:06:20.560]  на уровне синтаксического анализа произошедшего.
[02:06:20.560 --> 02:06:22.560]  Потому что он распарсил эту штуку
[02:06:22.560 --> 02:06:24.560]  как выражение,
[02:06:24.560 --> 02:06:26.560]  и в нем встретил x,
[02:06:26.560 --> 02:06:28.560]  который непонятно откуда взят.
[02:06:28.560 --> 02:06:30.560]  Но, если я
[02:06:30.560 --> 02:06:32.560]  сделаю, что x это для него
[02:06:32.560 --> 02:06:34.560]  понятное имя,
[02:06:34.560 --> 02:06:36.560]  то он успешно пройдет эту стадию.
[02:06:36.560 --> 02:06:38.560]  T он никакой не подставляет.
[02:06:38.560 --> 02:06:40.560]  Он просто понял, что это корректный expression.
[02:06:40.560 --> 02:06:42.560]  Он смог распарсить это как корректный expression.
[02:06:42.560 --> 02:06:44.560]  Но поскольку подстановки типов еще не случилось,
[02:06:44.560 --> 02:06:46.560]  он не выдал ошибку компиляции.
[02:06:46.560 --> 02:06:48.560]  Ошибка компиляции о том,
[02:06:48.560 --> 02:06:50.560]  что не поддерживается такая операция, имеет смысл в том,
[02:06:50.560 --> 02:06:52.560]  когда подставили T и поняли, что реально получилось.
[02:06:52.560 --> 02:06:54.560]  Вот.
[02:06:54.560 --> 02:06:56.560]  Теперь давайте вызовем f
[02:06:56.560 --> 02:06:58.560]  шаблонным параметром int.
[02:06:58.560 --> 02:07:00.560]  И посмотрим, что будет.
[02:07:00.560 --> 02:07:02.560]  Вот сейчас я заставил его
[02:07:02.560 --> 02:07:04.560]  проинстанцировать.
[02:07:04.560 --> 02:07:06.560]  Значит...
[02:07:06.560 --> 02:07:08.560]  ...
[02:07:08.560 --> 02:07:10.560]  ...
[02:07:10.560 --> 02:07:12.560]  ...
[02:07:12.560 --> 02:07:14.560]  ...
[02:07:14.560 --> 02:07:16.560]  ...
[02:07:16.560 --> 02:07:18.560]  ...
[02:07:18.560 --> 02:07:20.560]  ...
[02:07:20.560 --> 02:07:22.560]  ...
[02:07:22.560 --> 02:07:24.560]  ...
[02:07:24.560 --> 02:07:26.560]  ...
[02:07:26.560 --> 02:07:28.560]  ...
[02:07:28.560 --> 02:07:30.560]  ...
[02:07:30.560 --> 02:07:32.560]  ...
[02:07:32.560 --> 02:07:34.560]  ...
[02:07:34.560 --> 02:07:36.560]  ...
[02:07:36.560 --> 02:07:38.560]  ...
[02:07:38.560 --> 02:07:40.560]  ...
[02:07:42.560 --> 02:07:44.560]  ...
[02:07:44.560 --> 02:07:46.560]  ...
[02:07:46.560 --> 02:07:48.560]  ...
[02:07:48.560 --> 02:07:50.560]  ...
[02:07:50.560 --> 02:07:52.560]  ...
[02:07:52.560 --> 02:07:54.560]  ...
[02:07:54.560 --> 02:07:59.540]  то есть по идее попал сюда то есть я заставил его я заставил его теперь
[02:07:59.540 --> 02:08:04.140]  считать что а это вот эта штука и он не смог все равно а давайте селенг а это
[02:08:04.140 --> 02:08:11.300]  селенг и есть давайте г плюс плюс вот ну здесь g plus plus получше справился
[02:08:11.300 --> 02:08:16.260]  обычно селенг лучше справляется с выдачей нормальных ошибок но на этот раз
[02:08:16.260 --> 02:08:20.900]  селенг g plus plus лучше справился дело в том что синтоксический анализ уже
[02:08:20.900 --> 02:08:27.260]  проведен он считает что эта штука это обозначать value а когда я инстанцировал
[02:08:27.260 --> 02:08:33.100]  и он вдруг внезапно понял что это было не value он такой ой но от этого не
[02:08:33.100 --> 02:08:37.820]  исправит синтоксический анализ свой то есть он когда анализировал эту функцию
[02:08:37.820 --> 02:08:43.820]  до подстановки типов он понял что это expression а сейчас я подставил ему такое
[02:08:43.820 --> 02:08:48.600]  t что это оказался не expression а он скомпилировал уже но он уже построил
[02:08:48.600 --> 02:08:52.160]  там все синтоксическое дерево все там под настроил конструкции свои и он
[02:08:52.160 --> 02:08:57.240]  решил что там был expression в этом месте вот поэтому несмотря на то что я даже
[02:08:57.240 --> 02:09:02.840]  заставил его теперь подставить сюда такой тип что породил он ему не value он
[02:09:02.840 --> 02:09:07.240]  все равно сломался потому что оказалось это не value а он думал что это value вот
[02:09:07.240 --> 02:09:15.240]  но если я вызовусь от звездочки то все будет нормально вот так вот как мне
[02:09:15.240 --> 02:09:25.000]  победить это а ты звездочки да он он все корректно скомпилирует потому что он
[02:09:25.000 --> 02:09:31.700]  понял что 0 меньше 5 больше нуля просто у него получилось и все вот ну вот давайте
[02:09:31.700 --> 02:09:34.760]  напишу здесь type name
[02:09:39.440 --> 02:09:44.560]  вот теперь он справляется да потому что он понимает что это тин так и
[02:09:44.560 --> 02:09:52.640]  силен кажется справится а нет не справляется почему-то вот же плюс плюс
[02:09:52.640 --> 02:09:55.840]  и силенка идут себя по-разному
[02:10:00.600 --> 02:10:06.480]  а почему это вот на самом деле тут есть тонкость потому что вот ну тут как-то
[02:10:06.480 --> 02:10:09.960]  вот разные компиляторы немного по-разному это читают но идея в
[02:10:09.960 --> 02:10:15.640]  следующем что слово type name может быть недостаточно если я написал даже type
[02:10:15.640 --> 02:10:21.560]  name он все равно ну то есть когда я написал type name он партий это как тип а
[02:10:21.560 --> 02:10:26.080]  надо партий как шаблон то есть теперь он считает что вот это название некоторого
[02:10:26.080 --> 02:10:29.960]  типа но на самом деле это не название типа это название шаблона и следующий
[02:10:29.960 --> 02:10:36.400]  знак меньше ему нужно спастить как головую скобочку открывающую вот несмотря на то
[02:10:36.400 --> 02:10:41.360]  что написал type name он все равно не понимает что-то на самом деле template они
[02:10:41.360 --> 02:10:45.040]  просто type name он партий до сюда дальше голову скобочку партий все еще как знак
[02:10:45.040 --> 02:10:51.960]  меньше и це я вот поэтому чтобы совсем победить ошибку окончательно нужно
[02:10:51.960 --> 02:10:59.680]  здесь еще написать слово template значит слово template используется не только для
[02:10:59.680 --> 02:11:01.920]  того чтобы объявлять шаблоны и шаблонные параметры
[02:11:02.560 --> 02:11:08.320]  оно используется еще в конструкциях неоднозначности когда в выражениях зависимых от t у вас
[02:11:08.320 --> 02:11:13.760]  некоторая штука может читаться как well я может как шаблон вот сейчас должно все
[02:11:13.760 --> 02:11:20.760]  скомпилироваться любым компилятором вот а если я вообще не буду этого делать и не
[02:11:20.760 --> 02:11:29.080]  объявлю x давайте посмотрим что вот сейчас будет вот я сейчас допустим уберу слово template здесь
[02:11:29.080 --> 02:11:37.360]  поймет ли он возможно даже сейчас поймет до g plus plus справляется селенк все равно не
[02:11:37.360 --> 02:11:45.720]  справляется вот ну возможно кстати селенк и ну со стд си плюс плюс 20 может быть у меня
[02:11:45.720 --> 02:11:53.280]  просто да он даже предложил просто да да нет селенк сказал что здесь не хватает слова template
[02:11:53.280 --> 02:12:01.600]  а g plus plus просто скомпилировал и так понял без слова template вот по моему по стандарту нужно
[02:12:01.600 --> 02:12:12.520]  ставить template кто ну же плюс плюс компилирует вот кто из них прав я не помню значит кто из
[02:12:12.520 --> 02:12:22.200]  них прав я не помню если честно если он предлагает короче я не помню кто из них прав но вот лучше
[02:12:22.200 --> 02:12:27.680]  писать template тогда надежно будут все компилировать понятен пример и его решение да
[02:12:37.680 --> 02:12:46.680]  чего type name что что это означает вот о том что это означает я последние 20 минут и
[02:12:46.680 --> 02:12:51.080]  рассказывал зачем здесь слово type name вот именно об этом этот пункт зачем здесь нужно type name
[02:12:51.080 --> 02:12:59.960]  чтобы он парсил это как тип а не как value ну я привел пример ну слушай ну блин ну что мне
[02:12:59.960 --> 02:13:04.680]  все занято но я не знаю но я привел как раз пример что была неоднозначность это можно
[02:13:04.680 --> 02:13:11.160]  прочитать как expression а можно как declaration по умолчанию он парсит как expression как expression
[02:13:11.160 --> 02:13:16.480]  потому что он должен какое-то решение принять по умолчанию вот так он принимает по умолчанию
[02:13:16.480 --> 02:13:21.440]  решение чтобы заставить его принять по умолчанию считать что-то тип он начинал написать type name
[02:13:21.440 --> 02:13:32.080]  перед этим нужно для того чтобы компилятор считал это типом а не значением при парсинге при
[02:13:32.080 --> 02:13:46.160]  синтоксическом анализе своем да да сами создали проблемы сами их решили нет почему так
[02:13:46.320 --> 02:13:51.840]  вы постоянно будете так делать когда у вас будет и тараторы в контейнерах вы будете с этой ситуации
[02:13:51.840 --> 02:13:57.000]  ну ситуации template вы будете ну вы тоже не столкнетесь много раз но когда вы будете
[02:13:57.000 --> 02:14:02.560]  сталкиваться с вектор т и в нем что-то нужно из него достать у вас будет постоянно такая
[02:14:02.560 --> 02:14:09.200]  проблема ну короче проблема это частая и приходится с ней возиться неприятно вот
[02:14:09.200 --> 02:14:16.880]  последнее что я скажу в этом пункте да что
[02:14:16.880 --> 02:14:33.200]  в смысле два варианта void f с одинаковый шаблонным набором параметров с одинаковой
[02:14:33.200 --> 02:14:48.200]  сигнатурой где вот здесь очевидно нельзя перегрузить функцию с одинаковыми сигнатурами
[02:14:48.200 --> 02:14:58.520]  типа вот это redefinition of f вот и все а тайт-нэм с рейтингом ce потому что после угловой
[02:14:58.520 --> 02:15:09.840]  скобочки ожидается нет ну можно вот так сделать ну короче все понятно чего
[02:15:09.840 --> 02:15:22.080]  давайте подойдешь после пары потому что я боюсь что мы задержим всех и опять не успеем сейчас
[02:15:22.080 --> 02:15:37.400]  что хитро я не понял что ты сказал ну да ладно так еще одна вещь про которую надо сказать в
[02:15:37.400 --> 02:15:49.880]  этом пункте представьте что у меня следующая ситуация так смотрите вот
[02:15:49.880 --> 02:16:08.200]  давайте рассмотрим следующий пример
[02:16:08.200 --> 02:16:28.280]  ну например вот так так господа посмотрите пожалуйста следующий пример вот такой пример
[02:16:28.280 --> 02:16:37.680]  казалось бы что может пойти не так есть шаблонный класс base от него унаследовался derived заметьте
[02:16:37.680 --> 02:16:41.200]  кстати что здесь я вынужден повторять type name т шаблонный префикс потому что я использую
[02:16:41.200 --> 02:16:46.720]  его внаследовании и здесь я в методе derived инкриментирую x давайте попробуем
[02:16:46.720 --> 02:16:52.480]  подскомпилировать внезапно оказывается что x не объявленный идентификатор
[02:16:52.480 --> 02:17:14.280]  что посмотрите на этот код что могло бы пойти не так казалось бы плюс плюс x ce x не объявленный
[02:17:14.280 --> 02:17:24.120]  идентификатор нет здесь плюс плюс x не объявленный идентификатор меня только в одном месте кода плюс плюс x
[02:17:24.120 --> 02:17:44.320]  написано и же плюс плюс солидарен и минус остодесии плюс плюс 20 не помогает что же делать у кого есть
[02:17:44.320 --> 02:17:57.120]  идеи почему так это опять dependent name пункт называется dependent name мне очень нравится этот человек вот
[02:17:57.120 --> 02:18:01.760]  слушай вот у нас в прошлом году был тоже такой человек который все время очень громко кричал когда
[02:18:01.760 --> 02:18:07.920]  подобные вещи рассказываю озмущался вот ты пожалуйста не пропускай пары потому что мне нужно чтобы на
[02:18:07.920 --> 02:18:15.280]  парах был хоть один человек реакцию из зала выдаёт вот и хорошо да во втором особенно не
[02:18:15.280 --> 02:18:23.080]  пропускай чтобы как бы я ощущал вот фидбэк от того что я рассказываю да да да вот примерно так
[02:18:23.080 --> 02:18:40.080]  дело в том что поля бейс вообще говоря зависит от т и компилятор когда мы находимся в наследнике
[02:18:40.080 --> 02:18:52.000]  смотря какое т их сможет либо быть либо не быть ну как я могу сказать темплей я могу специализировать
[02:18:52.000 --> 02:19:01.600]  структуру без для им ты в ней не написать никакого поле x вы чего да я такой вот и тут не будет
[02:19:01.600 --> 02:19:09.000]  никакого x и вот и вопрос то есть получается что когда я из наследника обращаюсь к полю x его
[02:19:09.000 --> 02:19:21.320]  наличие зависит от того какой был т оно может быть а может его и не быть вот поэтому поэтому но
[02:19:21.320 --> 02:19:27.080]  тут я уже не знаю тут мои полномочия все как говорится я просто скажу как это работает а вот
[02:19:27.080 --> 02:19:34.720]  объяснить глубинные причины почему комитет так решил я значит по умолчанию компилятор если вы
[02:19:34.720 --> 02:19:40.360]  наследуетеся шаблонного родителя компилятор не лезет не пытается лезть в поля шаблонного
[02:19:40.360 --> 02:19:47.560]  родителя он считает что ну когда он парсит ваш код наследника он смотрит только на ваши поля и
[02:19:47.560 --> 02:19:51.160]  на ваших обычных родителей на поля шаблонных родителей не смотрит потому что понимать что они
[02:19:51.160 --> 02:19:58.320]  могут быть и могут не быть и он просто не берется выяснять а во всех ли возможных
[02:19:58.320 --> 02:20:04.480]  подстановках ты есть это поле а если его нет где-то то что мне делать вот он просто считает что
[02:20:04.480 --> 02:20:10.280]  их нет а если вы хотите к ним обратиться вам нужно явно квалифицировать откуда вы берете из насли из
[02:20:10.280 --> 02:20:21.400]  родителей то есть вам надо писать base от t2.2.x только не так конечно да плюс плюс base от t2.2.x вот так
[02:20:21.400 --> 02:20:27.680]  ну если будет перегрузка с entom конечно же будет ce потому что он подставил ent и увидел что нет
[02:20:27.680 --> 02:20:36.560]  поля x он не подставляет t когда компилирует он не смотрит вы понимаете он компилирует шаблонный
[02:20:36.560 --> 02:20:43.200]  код и он не идет в родителей просто видя что они шаблонные он не пытается посмотреть какие у них
[02:20:43.200 --> 02:20:53.600]  есть поля он не пытается он не пытается на первой стадии компиляции шаблонного код
[02:20:53.600 --> 02:21:00.160]  среди двух стадий первая стадия это просто проверка синтаксиса и базовых но на второй
[02:21:00.160 --> 02:21:04.960]  стадии когда т конкретизируется конечно же когда т конкретизируется компилятор подставляет
[02:21:04.960 --> 02:21:10.360]  конкретный т и смотрит что получилось и тут выдает уже ошибки следующего уровня но на первой
[02:21:10.360 --> 02:21:14.800]  стадии он не пытается подставлять никакие т потому что в зависимости от поставки разных
[02:21:14.800 --> 02:21:19.360]  тем может получиться разное поэтому он просто говорит я не знаю что такое x я не ходил туда и не
[02:21:19.360 --> 02:21:26.000]  смотрел что там скажи мне что x оттуда если ты хочешь его явно взять оттуда вот такая проблема
[02:21:26.000 --> 02:21:33.280]  при взятии полей из шаблонного родителя если вы наследуетесь от шаблонного родителя то когда
[02:21:33.300 --> 02:21:38.400]  обращайтесь к полям нужно явно квалифицировать откуда поля он же и до этого не подставлял
[02:21:38.400 --> 02:21:46.040]  inequality при этом до этого не отставлял вот сейчас он не подставляет �пки это когда у нас
[02:21:46.040 --> 02:21:55.960]  когда что мы не указывали откуда именно нужно брать x тоже не подставляй ну теперь он верит
[02:21:55.960 --> 02:22:01.280]  нам там есть x понимает neck議 ᶗ tatas это он не верил до этого он просто не знал что
[02:22:01.280 --> 02:22:07.540]  что такое икс откуда его брать он не ходил в родители он не смотрел что у них он он не занимается вот этим вот
[02:22:07.540 --> 02:22:12.240]  на стадии статистическую анализа схожу ка и посмотрю на тех родителей подставлю ка от и увижу какие там
[02:22:12.240 --> 02:22:17.440]  возможные имена переменах получиться он занимается этим если не темплей то скажет если не темплей то да но
[02:22:17.440 --> 02:22:23.200]  если темплей он отказывается это делать потому что потому что это другая стадия компиляции если там
[02:22:23.200 --> 02:22:32.880]  нет шаблонов то это он проворачивает ну короче не знаю друг другая другой другой модель компилятор
[02:22:32.880 --> 02:22:40.000]  за это ответственно изначально шаблонный кто или кто шаблонный стадия компиляции сначала
[02:22:40.000 --> 02:22:45.520]  паре сначала проверяется синтакса с точки зрения корректности просто вот до подстановки шаблонный
[02:22:45.520 --> 02:22:51.440]  проверять делаются базовые проверки синтакса после уже подставляются типы что я правильно
[02:22:52.000 --> 02:23:05.880]  он верит что там есть поле x просто мы явно об этом сказали да да да еще еще можно писать
[02:23:05.880 --> 02:23:15.800]  вис стрелочка x да еще вот так можно писать так тоже работает он тоже понимает что это из
[02:23:15.800 --> 02:23:31.080]  родителя значит но если я так пишу то он понимает что это поле значит да он просто
[02:23:31.080 --> 02:23:34.120]  справляется с парсингом после этого а до этого не справляется
[02:23:34.120 --> 02:23:51.760]  да да да все а теперь он же всегда мог в принципе базовый не специфицированный
[02:23:51.760 --> 02:23:58.440]  я отказываюсь комментировать я рассказываю как есть вот все
[02:23:58.480 --> 02:24:12.640]  все мы идем дальше дорогие господа у нас сейчас с вами такой достаточно важный момент вот то что
[02:24:12.640 --> 02:24:19.600]  я сейчас расскажу оно вам пригодится в жизни да вот но на самом деле предыдущий пункт был подготовкой
[02:24:19.600 --> 02:24:25.240]  к этому пункту сейчас мы с вами впервые столкнемся с таким замечательным и совершенно великолепным
[02:24:25.240 --> 02:24:29.480]  на мой взгляд явлением стандарта библиотеки это прям вот одна из моих любимых частей языка
[02:24:29.480 --> 02:24:35.720]  c++ один из любимых закололков я надеюсь вы тоже получите удовольствие называется type traits это
[02:24:35.720 --> 02:24:40.360]  такие метафункции ну по сути мы сейчас будем простенькой метапрограммирование на типах делать
[02:24:40.360 --> 02:24:47.840]  такие метафункции до что значит слово мета значит что такое метапрограммирование мета это запрещенная
[02:24:48.720 --> 02:24:59.840]  значит метапрограммирование это такой подход к программированию когда я уже говорил сегодня
[02:24:59.840 --> 02:25:10.480]  утром у нас теперь функции это структуры а в роли объектов выступают типы сейчас вы увидите вот
[02:25:10.480 --> 02:25:16.840]  смотрите давайте напишем простую функцию метафункцию которая проверяет является ли данный тип
[02:25:16.840 --> 02:25:25.320]  указательным или ссылкой давайте я напишу простую метафункцию которая проверяет является ли тип
[02:25:25.320 --> 02:25:39.360]  указательным traits это значит характеристики а я пишу template typeNameT struct isPointer и вот теперь
[02:25:39.360 --> 02:25:44.360]  помните у нас у нас в код стайле было написано типа нужно писать с маленькой буквы с большой
[02:25:44.360 --> 02:25:52.760]  буквы все это правило отменяется если мы говорим о метафункциях если на самом деле тип метафункция то
[02:25:52.760 --> 02:26:04.520]  есть его роль ответит на какой-то вопрос про другой тип значит можно с маленькой ну да static
[02:26:04.520 --> 02:26:12.280]  const bool value равно false пишу я а теперь я делаю следующее
[02:26:12.280 --> 02:26:21.720]  заметьте что из pointer подсвечивается зеленым потому что есть такая cd-шная функция а вот
[02:26:21.720 --> 02:26:37.200]  здесь я пишу static const bool value равно true таким образом теперь если у меня есть некоторая шаблонная
[02:26:37.200 --> 02:26:55.760]  функция я могу использовать это следующим образом если isPointer по t value то сделать что-то одно а иначе
[02:26:55.760 --> 02:27:11.120]  что-то другое нету никого сфинает это пока не пугайте людей раньше не слушайте его он сумасшедший
[02:27:11.120 --> 02:27:29.360]  он слишком да так он слишком долго ботл плюсы поэтому да понятно что здесь написано понятно как
[02:27:29.360 --> 02:27:35.600]  этим пользоваться вот но пользоваться этим неудобно поэтому я еще напишу вот такой хелпер
[02:27:35.600 --> 02:27:49.720]  const bool isPointer в равно isPointer от t2.2.value но что бы мне не приходилось писать вот это вот
[02:27:49.720 --> 02:27:56.640]  я вместо того чтобы писать isPointer t value буду просто писать isPointer v от t
[02:27:56.640 --> 02:28:07.400]  да молодцы вы вы вы узнали вы распознали до из assignable из assignable это метафункция
[02:28:07.400 --> 02:28:12.960]  которая проверяет можно ли присвоить типу объекту типа a объект типа b но ее мы с вами сейчас не
[02:28:12.960 --> 02:28:16.880]  реализуем это сложно пока мы реализуем только простые вот пожалуйста вам проверка на то
[02:28:16.880 --> 02:28:29.520]  является ли тип указателя вот на самом деле здесь я еще вот что скажу я все-таки здесь
[02:28:29.520 --> 02:28:36.600]  используя вот это запрещенное слово которое вообще-то запрещено которое вам нельзя будет
[02:28:36.600 --> 02:28:40.960]  использовать в задаче про матрицы но я вам про него все-таки скажу но потому что просто грех не
[02:28:40.960 --> 02:28:48.700]  сказать в такой ситуации про него просто иначе ну я не знаю ну просто да ну это иначе выглядит
[02:28:48.700 --> 02:28:59.720]  ужасно значит есть такое слово constexpr которое можно после ифа писать вот есть такая конструкция
[02:29:00.720 --> 02:29:12.280]  пока не думайте о том что значит слово constexpr само по себе у него особенное значение если оно
[02:29:12.280 --> 02:29:20.840]  пишется после ифа и в constexpr это значит это сделает compile time проверку в compile time проверить
[02:29:20.840 --> 02:29:28.960]  истинно ли это и если истинно то ну то есть просто не компилирую вторую часть если вот это
[02:29:28.960 --> 02:29:42.360]  неверно вот например если это pointer то тогда я не знаю что-нибудь напиши там tx равно null ptr
[02:29:42.360 --> 02:29:54.240]  вот а иначе ничего не делай вот и что произойдет если допустим я сейчас вызову эту f от какого
[02:29:54.240 --> 02:30:03.680]  нибудь типа который не является pointer то есть я написал f от ну я не знаю 100d string вот если
[02:30:03.680 --> 02:30:11.360]  здесь не было написано constexpr была бы ошибка компиляции потому что потому что ну эта строчка
[02:30:11.360 --> 02:30:20.000]  же ну потому что здесь подставляется t и я пытаюсь сказать string x равно null ptr no conversion from std null ptr t to std string
[02:30:20.000 --> 02:30:28.080]  но constexpr означает не компилирует этот кусок кода если условие не выполнено просто игнори его на
[02:30:28.080 --> 02:30:33.440]  этапе компиляции просто игнорирует эту часть это очень полезная штука поэтому про нее лучше
[02:30:33.440 --> 02:30:37.640]  рассказать можно раньше чтобы у вас не было в коде таких некрасивых конструкций когда вы там
[02:30:37.640 --> 02:30:42.880]  ну короче вот такие вещи как проверка является какой-то тип каким-то свойством обладает она в
[02:30:42.880 --> 02:30:51.080]  compile time делается и соответственно проверить что этот тип не является указателем можно написать
[02:30:51.080 --> 02:30:56.440]  constexpr и это просто не приведет к тому что код не сгенерируется под это если тип был не таким
[02:30:56.440 --> 02:31:02.200]  но если это условие некомпайл тайм проверяемая то есть здесь написано некомпайл тайм константа то
[02:31:02.200 --> 02:31:14.240]  будет ce со словами не могу посчитать это на этапе компиляции понятно чего я подумаю я подумаю
[02:31:14.240 --> 02:31:30.280]  возможно вы фах можно будет чего специализация чего-чего тихо что где вторая из вот это это
[02:31:30.280 --> 02:31:36.640]  специализация частичная это же структура не функция у структур не бывает перегрузки у них
[02:31:36.640 --> 02:31:42.160]  бывает только специализация специализация в эту функции это мета функция но с точки зрения языка
[02:31:42.640 --> 02:31:54.880]  это класс класса нельзя перегружать можно только специализировать так я не буду отвечать на этот
[02:31:54.880 --> 02:31:59.800]  вопрос потому что ты заставляешь меня рассказать вам что такое констэкспорт целиком это я буду
[02:31:59.800 --> 02:32:06.920]  рассказывать весной если хочешь после пары подойдет но вам нельзя им будет пользоваться так
[02:32:06.920 --> 02:32:16.200]  вот если я сейчас это так скомпилирую basic type traits то нет я не получил ce почему-то а потому
[02:32:16.200 --> 02:32:20.600]  что ce потому что стрейн конструируется от чара от костчар звезды а налptr конвертируется в
[02:32:20.600 --> 02:32:28.800]  костчар звезду наверное поэтому ну я не знаю можно там от чего не короче не важно ну блин
[02:32:28.800 --> 02:32:33.560]  нет наверное все-таки надо показать ну давайте какой-нибудь тип который от налptr ну точно
[02:32:33.560 --> 02:32:43.600]  нельзя дабл наверное нельзя давайте проверим ну все вот нельзя из налptr сделать дабл но если
[02:32:43.600 --> 02:32:57.720]  я напишу здесь констэкспорт то можно будет все так понятен ли пример с из pointer из pointer
[02:32:58.280 --> 02:33:05.320]  вот на самом деле из pointer это штука из стд то есть это это такая стандартная метафункция стд из
[02:33:05.320 --> 02:33:24.520]  pointer кроме стд из pointer есть еще много чего в стандартной библиотеке а найти бы их только
[02:33:24.640 --> 02:33:27.960]  кто первый найдет слово traits тот молодец
[02:33:27.960 --> 02:33:38.160]  нет конечно
[02:33:38.160 --> 02:34:06.960]  вот смотрите смотрите пожалуйста вот вот у меня очень много файли type trait стандартных
[02:34:06.960 --> 02:34:14.840]  метафункций из integral из floating point из array из enum из union из class из function
[02:34:14.840 --> 02:34:21.240]  из pointer из lvl reference из lvl из member object pointer то есть вот например как проверить является ли тип
[02:34:21.240 --> 02:34:28.560]  массивом да очень просто вот просто написали специализацию но тут правда нужно объяснить что
[02:34:28.560 --> 02:34:35.280]  такое стд false type стд true type ну стд false type это просто тип в котором написано static
[02:34:35.880 --> 02:34:55.200]  равно false и все чтобы короче писать все метафункции вот смотрите пожалуйста вот
[02:34:55.200 --> 02:35:01.240]  пожалуйста метафункция из array если надо проверить является ли тип массива но тут
[02:35:01.640 --> 02:35:05.720]  является ли тип константным вот пожалуйста метафункция проверяющая является ли тип
[02:35:05.720 --> 02:35:13.240]  константным очень просто упражнение на тройку реализовать такую метафункцию на зачете
[02:35:13.240 --> 02:35:32.720]  ну да ну да да да да да вот можно слушайте ну давайте потише я так кричу громко а вы
[02:35:32.720 --> 02:35:41.520]  еще болтаете вслух вы очень громко очень тяжело вас перекрикивать вот ну тут есть
[02:35:41.520 --> 02:35:47.720]  много разных значит метафункций и большинство из них мы сейчас вами не в сцене реализовать
[02:35:47.720 --> 02:35:52.400]  потому что они требуют довольно жесткого метапрограммирования который мы позанимаемся
[02:35:52.400 --> 02:36:02.480]  весной но пока вот из pointer из reference из array вот еще одна очень полезная функция которая вам
[02:36:02.480 --> 02:36:09.920]  наверняка понравится это функция из same метафункция конечно значит смотрите метафункция из same
[02:36:09.920 --> 02:36:21.680]  из same type tmt type name u проверяет являются ли два типа одинаковыми значит вот я беру
[02:36:21.680 --> 02:36:30.240]  здесь пишу false а теперь специализирую для одного типа и здесь пишу true
[02:36:30.240 --> 02:36:43.440]  это есть стандарт на библиотеке я же только что показывала стд я показывал
[02:36:43.440 --> 02:36:57.520]  вот соответственно я например могу если меня ну если и и еще для всех для них есть вот такие
[02:36:57.520 --> 02:37:09.640]  вот алиасы и сэм в это шаблонные а темплейт значит type name t
[02:37:09.640 --> 02:37:30.560]  стракт ой какой стракт const bool value равно ой что пишу из сэм в равно из сэм от t тут нужно
[02:37:30.560 --> 02:37:38.680]  два типа да type name u и сэм t u 2.2. value чтобы вам не приходилось писать вот эти вот явные обращения
[02:37:39.080 --> 02:37:47.880]  к структурам это шаблонная переменная вот ну для справки все эти штуки вот все эти
[02:37:47.880 --> 02:37:55.360]  тайп трейд и они начиная с и плюс плюс 11 а вот эта штука только начиная с и плюс плюс 17 есть
[02:37:55.360 --> 02:38:00.440]  если вдруг что если вы где-то будете где нет с и плюс плюс 17 вот этих алиасов там еще не
[02:38:00.440 --> 02:38:11.520]  добавили конечно шаблонные переменные появились и плюс плюс 14 но история такая с 11 появились
[02:38:11.520 --> 02:38:17.760]  вот эти тайп трейд и все плюс 14 добавили шаблонные переменные а все плюс 17 в библиотеку
[02:38:17.760 --> 02:38:22.160]  добавили реализации шаблонных переменных для этих штук и в конст экспорт тоже только начиная с
[02:38:22.160 --> 02:38:30.000]  и плюс плюс 17 да поэтому если у вас нет и плюс плюс 17 то вам придется имитировать и в конст экспорт
[02:38:30.000 --> 02:38:34.360]  довольно хитрым способом значит не буду рассказывать каким это мы все по втором семестре обсудим
[02:38:34.360 --> 02:38:43.320]  да уже много чего 23 плюсы уже утверждены фактически уже известно что мне
[02:38:43.320 --> 02:38:53.120]  нет пока нет как будто вас это спасет стринг тоже в стандартной библиотеке есть знаете ли но
[02:38:53.120 --> 02:39:01.520]  вам все равно и вы реализовываете это же говорили что когда-то планировали бигендеджер конечно
[02:39:01.520 --> 02:39:07.360]  засовывать в стандап то по моему где-то в 21 году было им фарш то нет отказались от этой идеи
[02:39:07.360 --> 02:39:21.440]  еще одна еще одна очень еще быстро две метафункции а потом я должен вам успеть рассказать про
[02:39:21.440 --> 02:39:29.000]  вариативные шаблоны смотрите вот эти функции которые сейчас которые сейчас показывал они
[02:39:29.000 --> 02:39:39.760]  берут типы из них возвращают значение а можно рассмотреть такую штуку а стракт
[02:39:39.760 --> 02:39:55.120]  римов референс например ну или римов поинтер что это такое это такая структура в которой
[02:39:55.120 --> 02:40:06.400]  написано юзинг тайп равно ты очень полезно вот но все конечно становится интересней когда я
[02:40:06.400 --> 02:40:18.280]  добавлю специализацию он ли как это работает то есть вот у меня я вот пишу код какой-то
[02:40:18.280 --> 02:40:25.720]  шаблонный и у меня есть некоторые тип те и мне нужно получить как бы снять с него амперсант
[02:40:25.720 --> 02:40:32.360]  если он на нем был мне нужно получить тип который был которым был те если с него амперсант снять
[02:40:32.360 --> 02:40:39.200]  ну я использую метафункцию римов референс я пишу стд римов референс от ты двоеточие
[02:40:39.200 --> 02:40:57.280]  двоеточие тайп вот давайте я так и попробую сделать вот допустим я здесь но я эту функцию
[02:40:57.280 --> 02:41:07.120]  сейчас вызову от им там персант здесь напишу римов референс от ты двоеточие двоеточие тайп икс и
[02:41:07.120 --> 02:41:25.040]  вызовусь я от ссылки на дабл в каком смысле не идти вот вот именно поэтому я и думаете для
[02:41:25.040 --> 02:41:30.320]  чего это сейчас он показал вот ты это понял а все это поняли именно вот вы спрашивали где мы с
[02:41:30.320 --> 02:41:37.880]  этим столкнемся а вот именно для этого и нужен был предыдущий рассказ длинный про то что за еще
[02:41:37.880 --> 02:41:44.160]  раз вот у меня смета функция которая снимает амперсант стипа римов референс называется ну
[02:41:44.160 --> 02:41:50.720]  такая же есть функция римов конст римов поинтер есть функция это поинтер и вот я хочу вот у меня
[02:41:50.720 --> 02:41:56.640]  шаблонный код и я хочу взять тип т который меня передан шаблонным параметром и снять с него
[02:41:56.640 --> 02:42:03.120]  амперсант и получить получить получить некоторые тип ну и вот я вызвал f от дабл амперсант и хочу
[02:42:03.120 --> 02:42:07.720]  здесь в этой функции ну то есть это должно превратиться во что я просто объявляю дабл то есть
[02:42:07.720 --> 02:42:16.400]  вот так вот это должно теперь выглядеть да но сейчас будет ce и вы же понимаете почему
[02:42:16.400 --> 02:42:27.080]  потому что потому что он распарсит type как значение они как тип поэтому здесь надо писать
[02:42:27.080 --> 02:42:38.360]  type name и теперь да теперь все будет хорошо а в чем прикол вот такой прикол нет никого
[02:42:38.360 --> 02:42:48.600]  приклада римов референс ох как ты заблуждаешься но я пока я пока не буду спойлер зачем это
[02:42:48.600 --> 02:43:01.360]  что а ссылка может быть только одна да римов поинтер это будет снятие одного одной
[02:43:01.360 --> 02:43:12.560]  звездочки да ты можешь написать римов поинтер и кстати да это звучит как отличная задача для
[02:43:12.560 --> 02:43:17.960]  зачета написать функцию метафункции ему вау поинтер она вызывает римов поинтер рекурсивно до тех
[02:43:17.960 --> 02:43:23.480]  пор пока результат вызова не станет равен тому что было до вызова да можно написать римов по
[02:43:23.480 --> 02:43:33.120]  олл поинтерс вот да есть еще такая функция метафункция римов экстент сейчас покажу
[02:43:33.120 --> 02:43:40.520]  ну вот есть римов конст римов волатайл римов поинтер и от поинтер римов экстент вот
[02:43:40.520 --> 02:43:46.920]  например есть функция что она делает она снимает одни квадратные скобочки но у вас может быть
[02:43:46.920 --> 02:43:55.880]  многомерный массив вы снимете с него одно измерение ну вот но у вас был тип т квадратной
[02:43:55.880 --> 02:44:00.120]  скобочки квадратной скобочки вы сняли вторые квадратные скобочки стал просто т квадратной
[02:44:00.120 --> 02:44:09.400]  скобочки да просто ну чё вы задаёте какие-то вопросы странно а зачем нужно я не знаю
[02:44:09.400 --> 02:44:29.400]  теория марда шакурадо зачем да ну что нет неоднозначно type это непонятно что тип или значение
[02:44:29.400 --> 02:44:35.800]  поэтому он парщит его по умолчанию как значение нигде не используется для компилятора ну
[02:44:35.800 --> 02:44:41.600]  господи в четвертый раз повторяю неважно если там это специалист или нет он парщится как значение
[02:44:41.600 --> 02:44:47.480]  всегда в четвертый в пятый раз повторяю да всегда парщится как значение если написать
[02:44:47.840 --> 02:44:58.160]  это об этом был разговор в течение получаса до этого да всегда парщится как значение поэтому
[02:44:58.160 --> 02:45:07.400]  нужно писать type name вот и поэтому крайне полезно использовать алиас смотрите юзинг
[02:45:07.400 --> 02:45:18.200]  сейчас я делаю шаблонный юзинг шаблонный алиас помните что шаблонными могут быть и юзинги
[02:45:18.200 --> 02:45:33.280]  еще так вот я пишу юзинг рему в референс т равно type name рему в референс а т двоеточие
[02:45:33.280 --> 02:45:42.560]  двоеточие type ну и все вот и теперь когда мне нужно это использовать в нормальном коде я уже
[02:45:42.560 --> 02:45:50.720]  не пишу type name и не пишу двоеточие двоеточие type а просто пишу рему референс т вот эти штуки
[02:45:50.720 --> 02:46:05.440]  появились начиная си плюс плюс 14 но это для справки вот начиная си плюс плюс 20 сейчас я
[02:46:05.440 --> 02:46:14.200]  вас совсем угроху конечно вот здесь type name все-таки можно не писать но просто когда я делаю
[02:46:14.200 --> 02:46:19.520]  юзинг тип равно другой тип но очевидно что type name не надо и так понятно уже тут точно
[02:46:19.520 --> 02:46:31.720]  вот начиная си плюс плюс 20 разрешили не писать type name в этом месте но если я попрошу меньше
[02:46:31.720 --> 02:46:48.640]  версии языка то будет цена ну не все но стремимся к этому вот ну короче да потому что я убрал type
[02:46:48.640 --> 02:46:59.920]  name у него что-то сломался нет это же не шаблон это просто тип это не не шаблон просто тип так
[02:47:00.000 --> 02:47:05.240]  еще одна очень полезная метафункция и после этого я вам должен все-таки успеть рассказать про
[02:47:05.240 --> 02:47:13.400]  ой господи прошу вариативные шаблоны так еще одна божественная совершенно метафункция без которой
[02:47:13.400 --> 02:47:17.160]  я не могу вас оставить в этом семестре это замечательная метафункция стд conditional
[02:47:17.160 --> 02:47:32.880]  тернарный оператор тернарный мета оператор смотрите template type name ну не так template
[02:47:32.880 --> 02:47:47.000]  bool b type name t type name f struct conditional
[02:47:47.000 --> 02:48:16.320]  вот using type равно ну f дальше template type name t type name f struct conditional
[02:48:16.320 --> 02:48:30.640]  true за 5 т за 5 f using type равно t понятно как это работает ну и разумеется template
[02:48:30.640 --> 02:48:48.480]  bool b type name t type name f извиняюсь using conditional t равно ну если мы все плюс плюс 20 то уже
[02:48:48.480 --> 02:48:56.720]  type name можно не писать conditional от b запятая t запятая f двоеточие две точки type
[02:48:56.720 --> 02:49:15.360]  соответственно я могу например сказать вот мне передали t я могу спросить conditional t из
[02:49:15.360 --> 02:49:29.200]  const v от t запятая не знаю int запятая double x равно нулю вот пожалуйста если
[02:49:29.200 --> 02:49:36.240]  тип т был константным то я интервью а если не константно то дабл объявлю тернарный мета
[02:49:36.240 --> 02:49:51.920]  оператор ну я бы не рассказывал это если бы вам это не пригодилось ближайший ну это вам
[02:49:51.920 --> 02:49:55.960]  пригодится уже в задаче который будет следующий после матрицы и видимо она будет первые же
[02:49:55.960 --> 02:50:10.000]  в самом начале второго семестра это вам пригодится вот если вам кажется что я
[02:50:10.000 --> 02:50:15.480]  сейчас рассказываю бесполезную хрень и вообще кто этим пользуется вы очень заблуждаетесь этим
[02:50:15.480 --> 02:50:21.560]  как раз пользуется очень активно в промышленном коде вот да все польза куда не выйдет на улицу
[02:50:21.560 --> 02:50:27.920]  спроси вот ту женщина вся пользуется каждый бесполезную хрень я буду рассказывать в конце
[02:50:27.920 --> 02:50:32.520]  второго семестра а сегодня а сейчас им рассказываю очень полезную хрень я можем
[02:50:32.520 --> 02:50:43.440]  страйк conditional от false t f сделать можем ну и присловить using type равно f ну здесь надо ну здесь
[02:50:43.440 --> 02:50:49.760]  тогда надо будет равно t написать а здесь равно f да можем ну на ну типа в общей версии я что-то
[02:50:49.760 --> 02:50:56.160]  должен написать а в частности написать что-то другое еще про метру создать пол ну можем можем
[02:50:56.160 --> 02:51:08.000]  а зачем так же короче да видимо двадцатый силенг все-таки не любит так чтобы убирали так
[02:51:08.000 --> 02:51:15.680]  ну силенг да силенг вообще с двадцатыми плюсами интересная история силенг медленнее всех
[02:51:15.680 --> 02:51:21.720]  поддерживать научился по моему то есть быстрее всех как ни парадоксально научился поддерживать их
[02:51:21.720 --> 02:51:29.400]  мсв цепом на втором месте г плюс плюс а на третьем месте сил вот силенг дольше всех короче то есть
[02:51:29.400 --> 02:51:34.320]  силенга еще много фичей не реализована в том числе ну как мы могли убедиться даже библиотеки силенга
[02:51:34.320 --> 02:51:40.720]  еще некоторые штуки не реализованы сейчас прости а если мы мы вот там напишем и для у нас написан
[02:51:40.720 --> 02:51:44.720]  для true и мы напишем для холста получается общая версия у нас вообще никогда не получается да
[02:51:44.720 --> 02:51:56.560]  может нет не могу мне надо еще один пункт вам рассказать потому что мы очень ну хорошо нас
[02:51:56.560 --> 02:52:13.240]  смотри а что было в конце нет ну запись же идет зачем это уже я не знаю давайте я вам расскажу
[02:52:13.240 --> 02:52:18.960]  последнюю очень важную вещь которая вам вероятно пригодится в ближайшее время и отпущу вас с миром
[02:52:18.960 --> 02:52:23.160]  вареник темплэйс
[02:52:23.160 --> 02:52:46.040]  ну геомия да смотрите ну у нас были функции с аргументами по умолчанию у нас были функции у которых
[02:52:46.040 --> 02:52:55.720]  что там еще у значит аргументов не указаны имена но в общем и у нас были функции с произвольным
[02:52:55.720 --> 02:53:01.920]  количеством аргументов вот после этого у нас появились шаблоны шаблоны значит у нас появились
[02:53:01.920 --> 02:53:08.440]  тоже у которых есть аргументы по умолчанию у которых можно там не указывать имена значит
[02:53:09.400 --> 02:53:14.400]  но вот c плюс плюс 11 это все начало вот этот пункт он c плюс плюс 11
[02:53:14.400 --> 02:53:23.120]  появились люди подумали а что давайте сделаем и шаблоны с переменным количеством аргументов
[02:53:23.120 --> 02:53:30.400]  значит шаблоны с переменным количеством аргументов я могу написать темплэйт с
[02:53:30.760 --> 02:53:48.800]  многоточие ну тс скажем много типов стракт с ну и тут что-то написать вот ну пока не очень
[02:53:48.800 --> 02:53:53.680]  понятно для чем для чего это надо структура с переменом количеством шаблонов аргументов это
[02:53:53.680 --> 02:53:58.240]  такая не очень легкая для понимания вещей давайте я покажу на примере функции вот представьте что
[02:53:58.240 --> 02:54:04.120]  у меня есть функция классический пример это функция принт вот знаете можно придумать такую
[02:54:04.120 --> 02:54:18.160]  функцию принт допустим вот также чипл да устроен где-то конечно да ну в смысле также да он с
[02:54:18.160 --> 02:54:26.320]  переменным количеством шаблонных аргументов да да да а тс это что это тип какой то тс это вот
[02:54:26.320 --> 02:54:37.800]  трудно сказать что такое тс это пакет это некоторая новая сущность значит тс это пакет типов
[02:54:37.800 --> 02:54:51.080]  ну я затрудняюсь дать вам какую-то интуицию того что такое пакет типов я предпочитаю
[02:54:51.080 --> 02:54:59.560]  воспринимать пакет типов исключительно по как знаете утиная типизация ну типа вот по списку того
[02:54:59.560 --> 02:55:07.840]  что с ним можно делать вот пакет типов это некоторая необычная сущность которая существует
[02:55:07.840 --> 02:55:13.160]  только на этапе компиляции не является сама по себе никаким типом вот ну что с ней можно
[02:55:13.160 --> 02:55:20.920]  делать ее можно распаковывать как ее можно распаковывать можно распаковывать когда вы
[02:55:20.920 --> 02:55:32.440]  перечисляете аргументы вот например так я распаковал пакет ну вот такая конструкция означает что
[02:55:32.440 --> 02:55:40.280]  теперь у меня аркс это пакет аргумент можно распаковывать пакет типов получать им самым пакет
[02:55:40.280 --> 02:55:57.920]  аргументов да ну тут все корректно я просто объявил шаблонную функцию с первым количеством
[02:55:57.920 --> 02:56:05.480]  аргументов ничего не передал ни от чего не вызвать я распаковал пакет но то есть я объявил
[02:56:05.480 --> 02:56:12.560]  функцию с переменным количеством шаблонных аргументов которая принимает значит вот как с
[02:56:12.560 --> 02:56:20.960]  этим работать это прекрасный вопрос а ну вот в таком виде довольно трудно давайте я напишу
[02:56:20.960 --> 02:56:28.600]  функцию которая дело следующий она выводит все аргументы в консоль все аут через по одному вот
[02:56:28.600 --> 02:56:34.880]  ну это классический пример значит как не не не не не аркс это не контейнер чтобы по нему так
[02:56:34.880 --> 02:56:43.440]  ходить у него же нет атераторов мы проверим ли мы проверили а вот есть идеи как вообще вот
[02:56:43.440 --> 02:56:53.040]  воспользоваться чем-то из этого пакета что нет нет аркс это пакет аргументов аркс сам по себе
[02:56:53.040 --> 02:56:59.800]  аркс сам по себе это никакой не это не переменная никакого типа это как бы такое имя за которым
[02:56:59.800 --> 02:57:08.960]  скрывается много переменных пакет можно пакет переменных можно распаковывать в свою очередь
[02:57:08.960 --> 02:57:14.880]  тоже получать таким образом несколько переменных через запятую я могу например сказать вот здесь
[02:57:14.880 --> 02:57:21.080]  ф от аркс многоточие и это будет означать как если написал f от а 1 запитая 2 запитая ну и короче вот
[02:57:21.080 --> 02:57:26.480]  я могу применить многоточие к пакету аргументов это будет означать что я вот все эти аргументы
[02:57:26.480 --> 02:57:37.160]  через запятую как будто перечислять нет ты не может это будет означать while и через запятую
[02:57:37.160 --> 02:57:48.120]  аргументы но это не оператор запитая это это перечисление можно напрямую нельзя чего можно
[02:57:48.120 --> 02:57:57.200]  присвоить массив нет можно получить количество впрочем можно типа убрать первый аргумент допустим и
[02:57:57.200 --> 02:58:04.040]  так пока не а вот это а вот это ты молодец так и надо да значит чтобы чтобы нам из этого пакета
[02:58:04.040 --> 02:58:16.480]  хоть что-то достать применяется следующий трюк мы делаем первый аргумент нормальным а после
[02:58:16.480 --> 02:58:25.920]  этого делаем хвост из переменного количества аргументов и мы принимаем в функцию первым
[02:58:25.920 --> 02:58:40.640]  аргументом голову а дальше хвост с переменным количеством аргументов соответственно да если
[02:58:40.640 --> 02:58:44.280]  теперь я вызову принтер пустого количества аргументов то это будет сие потому что нет
[02:58:44.280 --> 02:58:52.600]  соответствующей версии соответственно теперь я делаю вот так а после этого вызываю принт от
[02:58:52.600 --> 02:59:08.120]  хвоста распакованного да то есть я могу написать принт один запятая 2 запятая обц запятая 3.0 вот и
[02:59:08.120 --> 02:59:16.800]  это почти скомпилируется проблема только в том что не будет версии для принта без аргументов мы
[02:59:17.560 --> 02:59:25.160]  но мы ее не специализируем а перегрузим потому что специализация функции шаблонных это другое
[02:59:25.160 --> 02:59:32.400]  она нужна перегрузка да мы даже не будем она даже шаблонной не должна быть мы просто вот так
[02:59:32.400 --> 02:59:50.280]  сделаем все все нет не все а правильно потому что я объявил ее позже после того как она мне
[02:59:50.280 --> 03:00:09.760]  понадобится вот все работает что в какой момент вообще выводит что-то в ран тайме он выводит
[03:00:09.760 --> 03:00:18.400]  акапеллирует компайлпайны пакеты представляет он выводит голову потом ты ему передаешь
[03:00:18.400 --> 03:00:27.760]  снова все пакеты и у него меняется голова и меняется строго говоря он ничего не выводит он
[03:00:27.760 --> 03:00:33.840]  только код генерирует а когда ты им пустой я сейчас сгенерировал 5 версий функций принт
[03:00:33.840 --> 03:00:43.200]  вот этот код приводит в генерации пяти версий функций принт от нуля от 4 аргументов потом от
[03:00:43.200 --> 03:00:49.680]  трех от двух от одного ну и вот в итоге у меня от нуля от нуля сам написал от нуля сам написал
[03:00:49.680 --> 03:00:57.680]  да вот ну и каждый из этих функций делается ся вот первого аргумента своего и вызывает
[03:00:57.680 --> 03:01:05.640]  предыдущую функцию но в ран тайме они уже вызываются одна за другой все ну разумеется сюда
[03:01:05.640 --> 03:01:10.800]  можно принимать например по константной ссылке или просто по ссылке вот здесь вот я тоже могу
[03:01:10.800 --> 03:01:20.440]  навешивать украшать или на тип вот так мы будем писать но применять да это значит ко всем типам
[03:01:20.440 --> 03:01:30.280]  применить вот такую штуку да то есть у меня будут все аргументы по константной ссылке
[03:01:30.280 --> 03:01:32.920]  таким образом ну все давайте на сегодня закончим
