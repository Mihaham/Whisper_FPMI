[00:00.000 --> 00:10.840]  Да, ну начнём мы с того, что, наверное, добьём тему двоичных
[00:10.840 --> 00:11.840]  деревьев поиска.
[00:11.840 --> 00:15.480]  Ну добьём в каком плане, потому что остались, конечно,
[00:15.480 --> 00:17.840]  одни очень популярные деревья, которые мы с вами так не
[00:17.840 --> 00:18.840]  обсудили.
[00:18.840 --> 00:20.840]  Как вы думаете, что за деревья?
[00:20.840 --> 00:21.840]  Конечно, да.
[00:21.840 --> 00:25.520]  Вот, ну не то чтобы мы будем сильно много времени на
[00:25.520 --> 00:27.560]  них тратить, потому что, думаю, там вам, наверное,
[00:27.560 --> 00:29.520]  не надо рассказывать, что такое эти карты и деревья,
[00:29.520 --> 00:31.960]  как делать всякие разворотно-подотрески и так далее.
[00:31.960 --> 00:34.960]  Или надо?
[00:34.960 --> 00:38.480]  Нет, ну, думаю, вам не надо.
[00:38.480 --> 00:42.120]  Тем более, мы уже выяснили, что идей на в общем-то необходимости
[00:42.120 --> 00:44.280]  в них никакой нет, потому что овель дерева умеет всё
[00:44.280 --> 00:45.840]  то же самое, только за честный логориф.
[00:45.840 --> 00:50.760]  Вот, но кратенько всё-таки вынуждены чуть-чуть напомнить.
[00:50.760 --> 00:51.760]  Действительно.
[00:51.760 --> 00:52.760]  Ну зачем вообще нужны дикартовые деревья?
[00:52.760 --> 00:55.280]  Ну дикарты деревья нужны как минимум для того, чтобы
[00:55.280 --> 00:57.000]  код вписался чуть-чуть попроще.
[00:57.000 --> 01:01.080]  Вот, ну потому что мы видели, что там, скажем, овель и красно-чёрная
[01:01.080 --> 01:03.200]  там, вот это всё, там писать все эти, прописывать все
[01:03.200 --> 01:05.160]  эти повороты, это немножко больно.
[01:05.160 --> 01:09.040]  А вот тут появляется такая вероятность той структуры
[01:09.040 --> 01:12.440]  данных, которая говорит там о том, как балансировать.
[01:12.440 --> 01:13.440]  Да очень просто.
[01:13.440 --> 01:16.280]  Давайте-ка скажем, что у нас есть ключи, по которым
[01:16.280 --> 01:18.560]  у нас есть двоичное дерево поиска.
[01:18.560 --> 01:21.240]  А теперь мы говорим, а давайте в каждой вершине мы сгенерируем
[01:21.240 --> 01:23.560]  ещё какое-нибудь рандомное число.
[01:23.560 --> 01:29.680]  И будем говорить, что, вот, что по, вот это число мы
[01:29.680 --> 01:33.080]  назовём приоритет, и по этим приоритетам у нас там
[01:33.080 --> 01:36.080]  дерево должно образовывать кучу на минимум.
[01:36.080 --> 01:37.080]  Вот.
[01:37.080 --> 01:38.080]  Соответственно.
[01:38.080 --> 01:42.000]  И тогда, вот, и после этого тогда у нас появляются
[01:42.000 --> 01:44.040]  действительно какие-то достаточно простые сплиты
[01:44.040 --> 01:45.040]  и мержи.
[01:45.040 --> 01:50.480]  Вот, которые там, которые действительно, скажем, мерж
[01:50.480 --> 01:53.960]  базируются на том, что если нам нужно слить два дерева,
[01:53.960 --> 01:58.160]  а напоминаю, что пока, пока, подчёркиваю, мы сливаем
[01:58.160 --> 02:02.000]  два дерева, в котором там, здесь находятся ключи
[02:02.000 --> 02:05.240]  меньше либо равные х, а здесь находятся ключи больше
[02:05.240 --> 02:06.240]  чем х.
[02:06.240 --> 02:09.440]  И тогда слияние происходит действительно простым
[02:09.440 --> 02:11.040]  естественным образом.
[02:11.040 --> 02:14.360]  Рассмотрим два корня и выберем у кого приоритет меньше,
[02:14.360 --> 02:15.360]  тот и есть корень.
[02:15.360 --> 02:18.960]  Если у нас слева, если у нас тут приоритет оказался
[02:18.960 --> 02:26.160]  меньше, то тут мы, соответственно, берем лево, берем право и,
[02:26.160 --> 02:28.880]  то есть тут уже рекурсивно объединяем и просто подвешиваем.
[02:28.880 --> 02:32.760]  То есть инвариант соблюдается, собственно, нас устраивает.
[02:32.760 --> 02:35.560]  То есть дальше балансировка у нас гарантируется за
[02:35.560 --> 02:39.800]  счет того, что мы верим в это, верим в то, что вероятность
[02:39.800 --> 02:42.360]  того, что здесь там высота дерева будет какая-то
[02:42.360 --> 02:44.400]  нелагеритмическая крайне мала.
[02:44.400 --> 02:45.400]  Вот.
[02:45.920 --> 02:49.480]  Осталось только это доказать, но мы этого сейчас делать
[02:49.480 --> 02:50.480]  не будем.
[02:50.480 --> 02:51.480]  Вот.
[02:51.480 --> 02:56.000]  Да, но тут, в общем-то, да, действительно, ну, это
[02:56.000 --> 02:57.000]  нечего тут особо рассказывать.
[02:57.000 --> 02:59.680]  Действительно такое, ну, по крайней мере, рассказывать
[02:59.680 --> 03:02.000]  можно, конечно, бесконечно долго, но вероятность того,
[03:02.000 --> 03:06.600]  что вы ничего из этого не знаете, мы не будем.
[03:06.600 --> 03:12.320]  Поэтому надо, конечно, называть это сейчас не обсуждать
[03:12.320 --> 03:14.880]  подробно дикартовые деревья, а рассказать что-нибудь
[03:14.880 --> 03:19.000]  более, действительно, что-нибудь такое более интересное.
[03:19.000 --> 03:21.200]  Например, дерево отрезков.
[03:21.200 --> 03:28.920]  Вот, вы не знаете, да, называется, может показаться, да, казалось
[03:28.920 --> 03:29.920]  бы, да.
[03:29.920 --> 03:33.840]  Ну, казалось бы, что там, казалось бы, что там может
[03:33.840 --> 03:34.840]  быть проще.
[03:34.840 --> 03:40.400]  Но вот, тем не менее, оказывается, что кое-что там есть, ну,
[03:40.400 --> 03:43.200]  мы даже пойдем сейчас не в дерево отрезков, а все-таки
[03:43.280 --> 03:47.440]  копнем даже немножко в большую базу, потому что везде на
[03:47.440 --> 03:48.920]  самом деле какие-то мелочи есть.
[03:48.920 --> 03:51.760]  Но, правда, есть вот маленькие оговорчики.
[03:51.760 --> 03:56.080]  Да, то есть, конечно, то есть обычно в таких лекциях
[03:56.080 --> 03:59.160]  говорят, что вот там есть задача R S Q, есть задача R M Q.
[03:59.160 --> 04:03.080]  Да, вот давайте вспомним, что такое задача R S Q.
[04:03.080 --> 04:08.680]  Да, это означает, что у вас есть массив, там, ну, там,
[04:08.680 --> 04:11.520]  например, элементы от одного до N, допустим, или от нуля
[04:11.520 --> 04:13.160]  до N минус один, как договоримся.
[04:13.160 --> 04:20.720]  И нам очень хочется решать такую задачу, то есть, в идеале
[04:20.720 --> 04:24.160]  нам хочется решать задачу найти сумму на подотреске
[04:24.160 --> 04:27.280]  с L по R и изменять элемент.
[04:27.280 --> 04:34.400]  Ну, например, пока в простой версии изменять один элемент
[04:34.400 --> 04:35.400]  там в одной позиции.
[04:35.400 --> 04:39.760]  Вот такова у нас задача R S Q.
[04:40.360 --> 04:44.600]  Но есть, конечно, классическая задача R M Q, где то же самое,
[04:44.600 --> 04:47.880]  только на ототреске нужно искать какое-нибудь минивум.
[04:47.880 --> 04:57.080]  Вот, так, тоже с каким-нибудь прессами, тут по умолчанию
[04:57.080 --> 04:58.080]  в точке.
[04:58.080 --> 05:03.280]  Вот, но мы это, ну, вот, то есть мы эти задачи попробуем
[05:03.280 --> 05:04.280]  обобщить.
[05:04.640 --> 05:14.960]  Мы будем решать задачу R Q, где операция Y это какая-то
[05:14.960 --> 05:16.160]  абстрактная операция.
[05:16.160 --> 05:22.160]  Вот, но, но как повезет в зависимости от чего.
[05:22.160 --> 05:29.920]  Вот, потому что, ну, здесь можно рассматривать обычно
[05:29.920 --> 05:30.920]  два случая.
[05:31.800 --> 05:38.800]  Первый случай, когда операция Y, то есть Y оказывается ассоциативна.
[05:46.600 --> 05:50.120]  Ну, вот давайте так скажем, коммутативна и обратима.
[05:50.120 --> 05:51.600]  Вот так скажем.
[05:55.600 --> 05:59.720]  Вот, но на самом деле обратимость уже сама по себе подразумевает,
[05:59.840 --> 06:03.160]  ну, нулевой, точнее, единичный элемент есть.
[06:03.160 --> 06:04.160]  Куда же деваться.
[06:04.160 --> 06:05.160]  Вот.
[06:05.160 --> 06:08.160]  Ну, если у нас операция Y устроена действительно вот
[06:08.160 --> 06:13.760]  таким вот образом, то тогда в некоторых случаях у нас
[06:13.760 --> 06:15.560]  решение становится халявное.
[06:15.560 --> 06:19.000]  Какие случаи, какие случаи я имею в виду?
[06:19.000 --> 06:21.960]  Ну, первое, что хочется рассмотреть – это конечно
[06:21.960 --> 06:25.200]  задачу статик R Q.
[06:25.200 --> 06:28.000]  Что означает статик?
[06:28.000 --> 06:32.960]  это означает что массив не меняется вообще в принципе уже мы себе тут
[06:32.960 --> 06:37.840]  облегчили жизнь таким образом что что в этот массив не вставляются никакие
[06:37.840 --> 06:45.080]  элементы не удаляются некие элементы вот значит как-то она вот а тут
[06:45.080 --> 06:48.320]  предлагается что давайте совсем облегчим себе жизнь то есть условно
[06:48.320 --> 06:55.280]  говоря от нас требуется только один запрос быть на подотрезке от эль-дайер
[06:55.840 --> 07:02.400]  ну что делать если у нас операция обладает аж до такими свойствами да ну
[07:02.400 --> 07:10.280]  конечно за этот метод называется префиксный быть логично да то есть если
[07:10.280 --> 07:15.080]  вот массив называется а то мы можем назвать то мы можем объявить что
[07:15.080 --> 07:24.520]  допустим па там и ты присвоить себе там просто а первая быть а второе быть и так
[07:24.520 --> 07:30.640]  далее быть а это вот но ассоциативность позволяет нам как минимум не писать
[07:30.640 --> 07:36.440]  скобочки но как во всем позволяет насчитать такие префиксные уйти за
[07:36.440 --> 07:44.560]  линию что что ну пока не пользуемся но да по большому счету да коммутативность
[07:44.560 --> 07:50.480]  там в общем-то тут не особо нужда нам надо на самом деле хватает обратимости
[07:50.480 --> 07:57.400]  хватает обратимости сказать что уйти от эля это на самом деле равно чему там
[07:57.400 --> 08:15.040]  па значит отель минус 1 в минус первой быть вот как да да вот конкретно здесь
[08:15.040 --> 08:24.480]  вот в таком написании не пользуюсь так но на чем с того что вот нет давайте
[08:24.480 --> 08:29.320]  парализируй смотрите смотрите раз зашла и что вот это такое я утверждаю что это
[08:29.320 --> 08:38.400]  равно а л-1 в минус первой быть а л-2 в минус первой быть и так далее быть так
[08:38.400 --> 08:43.360]  у нас там один индоксация до быть а первое в минус первый дальше мы пишем
[08:43.720 --> 08:52.080]  вот по эра начинаем писать значит а первая быть а второе быть и так далее быть ар
[08:52.080 --> 09:00.440]  но вот да и начинаем видеть что тут вот у нас шлёп шлёп ну вот соответственно потом тут у
[09:00.440 --> 09:05.840]  нас появляется там шлёп шлёп ну и так далее в общем тут все шлёп шлёп шлёп шлёп и получается
[09:05.840 --> 09:12.160]  ровно то что нам надо поэтому коммутативность тут оказывается даже особо и не нужна то есть в
[09:12.160 --> 09:17.360]  общем-то обратимость и нам вот так хватает поэтому можно тут ее даже вот так закрепить
[09:17.360 --> 09:23.280]  да это такой вот самый простой вариант называется да то есть обычно чаще всего
[09:23.280 --> 09:28.560]  кашь применяется когда это просто обычная сумма там каких-нибудь чисел мы там любых
[09:28.560 --> 09:34.000]  обычно целых чисел там рациональных действительно каких углов комплексных даже можно в принципе
[09:34.000 --> 09:51.640]  пожалуйста дойдем дойдем как бы сейчас все дойдем все поговорим тем более что там как бы есть
[09:51.640 --> 09:59.040]  просто интересные мелочи ответвления вот потому что действительно следующий шаг говорит а что
[09:59.040 --> 10:09.760]  делать вот у нас случай номер два если уить оказалось необратимо вот так вот повысим себе
[10:09.760 --> 10:21.800]  планочку быть оказалось просто ассоциативно может быть даже нет никакой гарантии на коммутативность
[10:21.800 --> 10:27.640]  но самое главное нет гарантии на обратимость ну какие какой пример идти мы можем вот с вами
[10:28.040 --> 10:34.360]  уже взрослые люди с вами можно разговаривать да да да да ну самый простой пример это
[10:34.360 --> 10:41.880]  произведение по непростому модулю там по модулю там вот нет но оно коммутативно хорошо но можно
[10:41.880 --> 10:57.160]  привести примеры каких-нибудь чего чего-то это не коммутативно что ли а ну в этом смысле
[10:57.480 --> 11:04.400]  а это да но это операции не ассоции не ассоциативно я боюсь не но не сдано я бы тут у нас сразу
[11:04.400 --> 11:10.640]  честно скажем что есть у нас операция не ассоциативно то наши все подходы тут конечно все да потому
[11:10.640 --> 11:16.160]  что у нас все подходы базируется на том что мы там какие-то подотрески уже заранее предпочитали
[11:16.160 --> 11:24.600]  и все остальные комбинируем из них тут в общем-то без этого как-то и не очень вот
[11:24.600 --> 11:32.800]  вот нету на самом деле нет нет вы читание тоже так себе коммутативно да вот ассоциативно
[11:32.800 --> 11:40.400]  вот а вот если брать хотя бы произведение матриц 2 на 2 не гарантированно вы не гарантированно
[11:41.400 --> 11:46.880]  вот вам и пожалуйста да вот поэтому я и говорил да вот вы взрослые люди с вами можно разговаривать
[11:46.880 --> 11:52.480]  на таком языке вот а то обычно там придет что в 8 вот обычно это рассказывает где-нибудь там
[11:52.480 --> 11:58.240]  всем там в восьмом классе в девятом да и там уже называется матрицами лучше не пугать никого вот
[11:58.240 --> 12:05.520]  но не важно но вот но мы теперь но ты так у нас операция ассоциативно что можно сделать ну пока
[12:05.520 --> 12:12.360]  вы находитесь в восьмом девятом классе вам все-таки дают все-таки какое-то облегчение облегчение
[12:12.360 --> 12:27.640]  говорят но там но облегчение может сказать что у нас это минимум например но что но вот что вот
[12:27.640 --> 12:34.800]  если это минимум стита каких-то чисел как тогда решать задачу но выясняется что можно завести
[12:34.800 --> 12:43.880]  конечно знаменитый спар стейбл что означает спар стейбл ну спар стейбл по сути означает что
[12:43.880 --> 12:51.680]  мы находим минимум на всех подотресках длины степень двойки то есть мы там заводим там так
[12:51.680 --> 13:06.400]  и пишем ст и т л т присвоить там допустим в данном случае минимум на минимум значит от а и
[13:06.400 --> 13:13.600]  пум-пум и плюс два степень или минус один вот я вот подотрески массива буду так писать вот
[13:13.600 --> 13:22.640]  ну думаю достаточно очевидно что это то есть размер этой таблицы какой до н лог насчитать
[13:22.640 --> 13:28.040]  ее тоже можно легко за н лог потому что любой подотрезок длины два степеней легко там минимум
[13:28.040 --> 13:32.240]  на нем легко насчитывается как минимум из двух отрезков длины два степень или минус один думаю
[13:32.240 --> 13:40.600]  очевидно да но а после этого говорится следующее заметим что любой подотрезок длины там просто
[13:40.600 --> 13:45.880]  абсолютно любой подотрезок от любого l до любого r так ну давайте тут вот лен давайте все-таки
[13:45.880 --> 13:52.280]  хранить чтобы лена и не путать оказывается он покрывается двумя отрезками длины два в одинаковой
[13:52.280 --> 14:00.040]  степени вот чему это нас приводит то есть оказывается давайте просто возьмем минимум на этом
[14:00.040 --> 14:06.520]  отрезке возьмем минимум на этом отрезке и поздравляю но ты собственно минимум из них это минимум на
[14:06.520 --> 14:15.600]  всем отрезке ура логично да так вот первое сказать вопрос начинает у нас если уйти минимум а теперь
[14:15.600 --> 14:20.080]  искать вопрос какими конкретно свойствами минимуму мы воспользовались чтобы написать
[14:20.080 --> 14:29.480]  такую крутую структуру да то есть действительно начитут если в скобчиках написать то во первых
[14:29.480 --> 14:32.680]  мы замечаем что уйти у нас коммутативно
[14:32.680 --> 15:01.680]  ну хотя вот ну хотя да коммутативность тут действительно в яхте в смысле важна но тут
[15:01.680 --> 15:07.080]  конечно ключевым является даже немножко другое свойство да то есть знаменитая и
[15:07.080 --> 15:17.640]  демпутентность не самое популярное слово но тем не менее вот что это означает это означает что
[15:17.640 --> 15:42.400]  уйти от xx равно x в смысле отрете чего-чего-чего и что тогда я сказал надо просто отрезки находить
[15:42.400 --> 15:48.940]  минимум в конце будем нажать на 2 но вот обычно то есть первая идея конечно что-то идем по
[15:48.940 --> 15:53.440]  тетость для того чтобы то есть как бы если мы в минимум подсунули два одинаковых элемента то
[15:53.440 --> 15:59.480]  ответ от этого не поменялся но конечно важна коммутативность чтобы те два элемента могли
[15:59.480 --> 16:04.120]  схлопнуться да потому что если я просто запишу там вот это это на это на это на это на это на это
[16:04.120 --> 16:07.320]  на это на это на это на это на это на это на это на это на это на это на это на это на это на это на это
[16:07.320 --> 16:11.280]  то рядом одинаковых элементов нет никто не схлопнулся да поэтому коммутативность нам здесь
[16:11.280 --> 16:18.720]  все-таки нужна да вот то есть это обычно но обычно вот так классический пример минимум
[16:18.720 --> 16:36.840]  в общем практически не для чего обычно спортсы и не пишут да да да да да да да да да да да да
[16:36.840 --> 16:41.520]  действительно действительно а теперь заметим сюда коммутативность нам на самом деле не нужна
[16:41.520 --> 16:47.920]  потому что мы можем сказать что этот отрезок это вот этот отрезок на вот этот отрезок а вот
[16:47.920 --> 16:53.560]  этот отрезок это вот этот отрезок на вот этот отрезок и получается средний все равно схлопнется
[16:53.560 --> 17:02.520]  утверждение на самом деле до коммутативность нам не нужна почему она не нужна потому что вот
[17:02.520 --> 17:07.560]  рассмотрим вот эти два отрезка заметьте что они пересекаются да давайте представим себе что вот
[17:07.560 --> 17:13.640]  вот скажем что тогда в силу ассоциативности оказывается что вот этот отрезок это вот этот
[17:13.640 --> 17:19.200]  отрезок умножить на вот этот отрезок а вот этот отрезок заметьте мы это вот этот отрезок на
[17:19.200 --> 17:24.520]  вот этот отрезок тогда кажется если мы перемножим вот этот отрезок на этот отрезок на этот отрезок
[17:24.520 --> 17:28.080]  на этот отрезок то эти два отрезка по диппатентности схлопнутся
[17:28.080 --> 17:42.400]  а мы из отдела следующем но на языке минимума мы эти все элементы заменили на минимум между ними
[17:42.400 --> 17:51.720]  вот вот то есть как бы тут тут один элемент и тут один элемент поэтому как потом мы берем
[17:51.720 --> 17:56.920]  минимум типа между ними оказывается что это что так как это одинаковый элемент а то мы их и пишем
[17:56.920 --> 18:02.400]  так что действительно да оказывается да от коммута там коммутативность действительно
[18:02.400 --> 18:12.600]  побеждается в общем-то нам достаточно и диппатентности вот что делать если диппатентности нет вот подсунуть
[18:12.600 --> 18:22.000]  нам произведение матриц 2 на 2 но вот но тут выясняется действительно что у спортстейбла есть на
[18:22.000 --> 18:30.280]  самом деле маленькая красивая модификация называется диз джойн спортстейбл так а ну как кто сталкивался
[18:30.280 --> 18:41.840]  с такой штукой популярно окей вот но про но тем не менее уже половина не всем но давайте разбираться
[18:41.840 --> 18:53.880]  да как же нам что же нам сделать если уить у нас не но вот если действительно у нас оказывается
[18:53.880 --> 19:01.960]  быть остается только и диппатентный то есть давайте пишем 2 б только ассоциативность
[19:01.960 --> 19:17.360]  тогда оказывается то есть можно изобрести действительно диз джойн спортстейбл вот
[19:17.360 --> 19:29.600]  вот ну тут идея такая чтобы все то есть хочется все-таки да построить какой-то спортстейбл но так
[19:29.600 --> 19:34.040]  чтобы то есть каждый отрезок появлялся в виде объединения двух каких-то отрезков но так чтобы
[19:34.040 --> 19:43.720]  они уже не накладывались друг на друга но как же это сделать но идея возникает такая но то есть
[19:43.720 --> 19:49.040]  идея возникает такой неожиданный разделяй властвуй потому что вот рассмотрим массив если мы
[19:49.040 --> 19:55.440]  рассмотрим массив то этого массива есть вот да вот давайте даже сейчас для просто скажем так
[19:55.440 --> 20:02.360]  на будущее что у нас все-таки все от нуля до n-1 и тогда идея такая давайте можно разделить
[20:02.360 --> 20:12.440]  массив примерно напополам и сказать что отрезки бы под отрезки бывают трех типов каких да они
[20:12.440 --> 20:19.680]  говорят те кто слева те кто справа и те кто пересекаются как бы проходит через вот эту
[20:19.680 --> 20:28.720]  границу тогда идея такая значит мы сейчас на ваших глазах за линейное время научимся
[20:28.720 --> 20:38.480]  считать ответ для всех под отрезков которые пересекают эту границу вот звучит пафосно может
[20:38.480 --> 20:44.680]  даже магически пока вы чуть-чуть не включили мозг как только включили мозг вы обнаружили
[20:44.680 --> 20:50.880]  что ничего сложного в этом нет потому что что нужно чтобы за линию научиться насчитывать все
[20:50.880 --> 20:55.680]  под ответы для всех под отрезков которые пересекают эту границу но очевидно надо
[20:55.680 --> 21:01.280]  насчитать ответы на всех префиксах правого массива и на всех суффиксах левого массива
[21:01.280 --> 21:09.440]  это делается в общем-то не сильно сложно понимаете да вот ну а что мы но а что делать вот для этих
[21:09.440 --> 21:16.520]  отрезков но для этих отрезков мы будем работать рекурсивно то есть по сути мы получается построим
[21:16.520 --> 21:21.320]  значит возьмем такой значит вот эту вот границу насчитаем на не ответ тут и вот тут почему нас
[21:21.320 --> 21:27.000]  вот на этом уровне будет прямо действительно ровно n элементов то есть все кто правее границы для
[21:27.000 --> 21:34.640]  них будет насчитаны префиксные идти а для всех кто слева будет написано суффиксные выйти вот
[21:34.640 --> 21:43.040]  та переча но вот ну и идем рекурсивно теперь у нас тут получается две половинки массива в
[21:43.040 --> 21:51.000]  каждой из них тоже есть теперь своя середина и мы на ней тоже насчитаем эти так и эти так вот
[21:51.040 --> 21:59.480]  вот ну и так далее вот
[21:59.480 --> 22:13.080]  что вопрос вопрос какие-то или что да да ну здесь уже где неправильно что неправильно да вот сейчас
[22:13.080 --> 22:24.400]  правильно вот так вот вот так вот вот так вот ну и так далее в общем так вот
[22:24.400 --> 22:34.560]  вот ну дальше рисовать не буду думаю хотя ладно нет давайте вот все-таки дорисуем
[22:34.560 --> 22:44.720]  предположим что у нас 16 элементов вот ну и тогда там в каждом вот это в каждом этом префиксе
[22:44.720 --> 22:54.440]  суффиксе тут будет уже где-то по одному элементу все закончится вот и вот казалось бы действительно
[22:54.440 --> 23:02.360]  то есть теперь идея очень простая то есть для любого подотрезка теперь можно найти такой отрез
[23:02.360 --> 23:07.880]  то есть то есть для любого теперь вот отрезка или который бы тут не был на массиве можно найти в
[23:07.880 --> 23:13.960]  этом спортстейбле подотрезок такой что во первых вот наши исходный отрезок лежит внутри там
[23:13.960 --> 23:21.400]  какого-то подотрезка таблицы и при этом пересекает его середину логично да как его найти но если он
[23:21.400 --> 23:25.920]  пересекает глобально середину массива то это вот самый первый отрезок и есть в противном случае
[23:25.920 --> 23:31.920]  он находится либо слева либо справа вот допустим там оказался справа тогда мы идем сюда если он
[23:31.920 --> 23:36.360]  пересекает вот эту границу то вот он и лежит в противном случае мы идем тоже влево и вправо и
[23:36.360 --> 23:49.200]  так его находим вот смотрите тут такой момент пока такой алгоритм работает залог это да но
[23:49.200 --> 23:55.080]  опять не но ты да но ладно есть до мелко оговорка что есть отрезок для меня 1 но правда отрезок
[23:55.080 --> 24:01.440]  для меня 1 можно считать что пересекает границу из себя любимого да но такой поддав ну понятно
[24:01.440 --> 24:07.200]  да что да если у нас отрезок длины 1 то скорее всего мы и там умеем его искать и так тем более
[24:07.200 --> 24:11.520]  что мы же говорим о статике то есть это означает что если вас запросили отрезок длины 1 вы просто
[24:11.520 --> 24:19.080]  достаете нужные элементы его выдают вот но здесь смотрите то есть отличие от называть от как мы
[24:19.080 --> 24:23.440]  скажем будущим дерево отрезков но собственно это уже про очень похоже на дерево отрезков хотя
[24:23.440 --> 24:28.380]  больше похоже на полный протокол какого-нибудь там какой-нибудь там сортировки слиянием да когда
[24:28.380 --> 24:36.060]  вы там в каждой вершине храните там там линии там не от единицы информации олинию точно здесь
[24:36.060 --> 24:41.460]  уже преимущество заключается в том что да то есть залогари вам придется искать конечно может
[24:41.460 --> 24:48.820]  быть саму вершину но зато операцию идь вам придется сделать от единиц уж как только вы найдете что
[24:48.820 --> 24:54.660]  там у вас отрезок вот какой-то вот такой то выберете суффикс или там суффикс здесь делаете
[24:54.740 --> 25:02.220]  с префиксом здесь и получаете ответ на задачу то есть получается уже от единицы идти и от
[25:02.220 --> 25:11.460]  логарифма вот таких спусков это уже неплохо вот да да да это следа да это следующий это следующий
[25:11.460 --> 25:17.460]  шаг но пока почеку что как бы то что я сказал это уже может быть неплохо да то есть мы сейчас конечно
[25:17.460 --> 25:23.220]  от этого логарифма тоже избавимся но на самом деле эти бывают на самом деле очень жирные там
[25:23.400 --> 25:27.120]  особенно если выяснить что эти такого и там запрос какой-нибудь вы там в какой-нибудь базе
[25:27.120 --> 25:31.460]  данных про интернету то на самом деле может оказаться что-то там вам в общем-то на этот
[25:31.460 --> 25:37.140] �убе рифму уже и наплевать потому что он там но потому что он там будет занимать
[25:37.140 --> 25:43.920]  мизерную часть от этого запроса по интернету вот а с точки зрения конечно там более абстрактно
[25:43.920 --> 25:48.060]  и там какой-то абстрактной математике конечно это все равно остается ловили там логарифм есть
[25:48.060 --> 25:53.060]  логарифом. И теперь есть какая-то вопрос, а можно ли действительно этот подотрезок
[25:53.060 --> 26:04.700]  действительно найти как-то, как-то действительно за вот единицы. Оказывается, можно. И технология,
[26:04.700 --> 26:09.620]  оказывается, вот, оказывается такой. То есть, во-первых, нам придется предположить,
[26:09.620 --> 26:17.580]  что наш размер нашего массива это степень двойки. Вот ровно степень двойки.
[26:17.580 --> 26:23.740]  Вот, ну понятно, что ничего страшного в общем-то там не асимпатически не дает,
[26:23.740 --> 26:28.740]  потому что, ну там, если n не степень двойки, ну там добьем массив какой-нибудь бякой лишней
[26:28.740 --> 26:36.940]  и не будем париться. Вот. Ну тогда, значит, давайте теперь нод. Тогда, смотри, тогда мы
[26:36.940 --> 26:42.900]  можем заметить, нод, ну что мы здесь можем заметить? Тогда мы можем заметить, что вот эта
[26:42.900 --> 26:52.900]  граница, это у нас два в степени k-1. Да? Здесь граница два в степени k-2 и три на два в степени
[26:52.900 --> 27:02.100]  k-2. Вот дальше тут у нас граница получается два в степени k-3, тут получается три на два в степени
[27:02.100 --> 27:10.260]  k-3, значит тут получается там пять на два в степени k-3, тут получается семь на два в степени k-3.
[27:10.260 --> 27:30.220]  Чего? Что тебя смущает? Нет, это не отрезок, это позиция в массиве глобально. Вот. Так,
[27:30.380 --> 27:36.580]  то есть на самом деле тут, то есть что тут можно заметить, да? То есть можно заметить следующее,
[27:36.580 --> 27:45.420]  что это вообще за числа? Вот. Ну, чего? То есть заметим, что если мы рассматриваем натуральные
[27:45.420 --> 27:51.460]  числа меньше, чем два в степени k-1, то мы видим, что вот это число это единственное число, которое
[27:51.460 --> 28:00.100]  делится на два в степени k-1. Эти два числа, что это за числа? Это такие числа, которые делятся
[28:00.700 --> 28:09.220]  на два в степени k-2, но не делятся на два в степени k-1. Вот. То есть вот эти числа – это
[28:09.220 --> 28:14.140]  числа, которые делятся на два в степени k-3, но не делятся на там большей степени двойки.
[28:14.140 --> 28:21.020]  То есть, по идее, про каждое число можно сказать, на каком уровне оно окажется разделителем,
[28:21.020 --> 28:24.740]  то есть что? То есть чтобы определить этот уровень, надо просто определить,
[28:24.740 --> 28:35.300]  на какую максимальную степень двойки это число делится понятно да вот приятно вот то есть это
[28:35.300 --> 28:42.900]  вот с одной стороны но с другой стороны теперь в нашей теке когда нам дается число lr нам нужно
[28:42.900 --> 28:53.660]  что когда нам нужно такое вот число l not lr вот допустим мы ищем что нот ну что мы ищем но
[28:54.340 --> 29:04.980]  но допустим и вот под нот ну да то есть допустим мы вот ищем подотрезок и лер то есть вот тогда
[29:04.980 --> 29:12.060]  что нам нужно нам на этом подотрезке нужно найти вот получается вот какой-то разделитель то есть
[29:12.060 --> 29:19.740]  по сути задача будет такая надо найти какое-то число x такое что l меньше либо равно x меньше
[29:19.740 --> 29:35.420]  либо равно x делится на 2 в степени лен лен максимально возможно понятно да и тогда и тогда
[29:35.420 --> 29:44.420]  если мы найдем хотя бы но вот но да но то есть ну в принципе да то есть наша цель найти такой
[29:44.420 --> 29:54.300]  лен вот но заметим что если мы уж какой-нибудь лен такой найдем то в общем-то но то в общем-то
[29:54.300 --> 30:00.500]  все остальное мы уже по лену восстановим правда то есть как бы если мы знаем лен то x восстановить
[30:00.500 --> 30:08.340]  тоже достаточно просто да то есть понятно что при известном лене получится что x равно по сути
[30:08.340 --> 30:20.500]  r минус там r процент там 2 степени лен логично да вот ну потому что это ближайшее к эру
[30:20.500 --> 30:25.260]  метам меньшее число ну или точнее не больше которое делится на 2 степени лен и оно как бы либо
[30:25.260 --> 30:36.580]  подходит нам либо нет понимаете да вот но теперь вот внимание вопрос да как же такое такой x вот как
[30:36.580 --> 30:44.980]  же такое найти но вот ну давайте дать да действительно давайте разбираться да потому
[30:44.980 --> 30:56.540]  что раз степень двойки значит наверно какие-то биты надо надо писать да но спорить породить
[30:56.540 --> 31:02.580]  сейчас вот давайте разбираться постепенно все сюда и так рассмотрим числа или рассмотрим их
[31:02.580 --> 31:11.880]  битовое представление но заметим следующее что некогда мы идем слева направо lr но про
[31:11.880 --> 31:19.040]  lr мы знаем что l меньше либо равно r и мы знаем что они совпадают совпадают там с какого-то
[31:19.040 --> 31:25.220]  момента начинаются единички там потом опять нолики но пока мы знаем что x в общем-то обязан
[31:25.220 --> 31:32.420]  будет совпадать с ними правда тот получится 1 1 и то тот бабах но если l равно это это
[31:32.420 --> 31:41.780]  случай нам особо не интересен да вот но если l меньше чем вот бабах произошла первая ситуация
[31:41.780 --> 31:56.580]  когда в эле находится нулевой бит а в эле единичной вот и что-то теперь происходит вот такое вот то
[31:56.580 --> 32:02.540]  есть тут какой-то вот то есть там какой-то безобразие тут какое-то безобразие но впрочем
[32:02.540 --> 32:08.620]  на самом деле тут теперь два варианта вот то есть принципе есть два варианта первый вариант
[32:08.620 --> 32:16.380]  либо ну если так формально рассуждать либо кажется что то есть вполне может на самом деле
[32:16.380 --> 32:22.260]  оказаться вот кстати тут давайте я даже для простых даже еще тут напишу вот допустим тут 1 1
[32:22.260 --> 32:33.780]  а тут 0 0 0 0 ну во первых действительно может оказаться так что у эля здесь все числа нулевые
[32:33.780 --> 32:41.980]  ну может такое быть правда тогда я думаю становится достаточно очевидно что лен что
[32:41.980 --> 32:47.580]  такой максимальный лен это вот это количество нулей то есть тогда вот тогда получается вот
[32:47.580 --> 32:55.020]  само по себе число l в общем-то нам и подходит понимаете да вот ну кстати да надеюсь да я
[32:55.020 --> 32:59.660]  думаю достаточно очевидно что для каждого числа от 1 до n вот это вот предпочитать эту
[32:59.660 --> 33:09.580]  максимальную степень двойки можно за линию правда вот но вот но замечаем да что если тут вот после
[33:09.580 --> 33:15.740]  этого но после этого момента действительно у нас тут нолики там только нолики то и льдам и
[33:15.740 --> 33:23.060]  подходит вот но в противном же случае что можно сказать если тут хоть где-нибудь хоть какая-нибудь
[33:23.060 --> 33:36.500]  единица донашлась но тогда ответ очевиден тогда икса канут тогда икс оказывается нужен 1 1 0 1 0 0 1 и
[33:36.500 --> 33:46.500]  0 0 0 0 то есть надо вот после этой единицы запихнуть нули вот ну потому что действительно заметим
[33:46.500 --> 33:54.540]  что между л и р очевидно то есть очевидно уж теперь то есть больше чем вот столько нулей в
[33:54.540 --> 34:03.260]  начале там в конце идти не будет видно да но чтобы шло больше тут уже 0 и чтоб тут пошло дальше вот
[34:03.260 --> 34:07.620]  а ровно столько будет идти ровно в этом числе но в общем-то кстати можно заметить что и только в нём
[34:07.620 --> 34:15.020]  остается только понять как же это найти но очень просто потому что вообще во-первых то есть надо
[34:15.020 --> 34:25.280]  понять а как этот бит вообще найти где они вот первые начинают различаться ну вот то есть
[34:25.280 --> 34:30.900]  до самом деле заметим что это действительно что вот это вот это действительно старший бы но то
[34:30.900 --> 34:43.660]  есть это вот действительно старший бит старший бит в такой штуке как альк сор э вот то есть
[34:43.660 --> 34:48.660]  Если мы возьмем LXORR, то все вот эти биты обнулятся, а этот будет единичным.
[34:50.160 --> 34:54.160]  Ну, то есть там, конечно, для того, чтобы его найти, видимо, придется тоже делать какие-то предподсчеты.
[34:54.160 --> 34:59.660]  То есть там для всех чисел от 0 до 2 в степеника придется предподсчитать, кто у него старший бит.
[35:00.660 --> 35:03.160]  Но это тоже за там, за линию делается не проблема.
[35:03.160 --> 35:07.160]  А можно даже и за N log N, в общем-то, потому что у нас все равно таблица за N log N.
[35:08.160 --> 35:08.660]  Вот.
[35:09.160 --> 35:13.160]  То есть отдельная песня, есть там какие-то специальные битовые операции, которые позволяют делать.
[35:13.160 --> 35:15.160]  Но если честно, я слета таких не помню.
[35:17.160 --> 35:18.160]  Чего?
[35:22.160 --> 35:24.160]  32 минус...
[35:24.160 --> 35:28.160]  А, беда. Ну, осталось только выяснить, за сколько этот built-in CLZ еще работает.
[35:29.160 --> 35:31.160]  Да, ойли.
[35:31.160 --> 35:32.160]  Точно?
[35:33.160 --> 35:38.160]  А то всякое там бывает, а то полностью pop count работает все-таки за реальное количество единичных бит.
[35:38.160 --> 35:40.160]  Хоть там константа, конечно, сильно меньше.
[35:40.160 --> 35:42.160]  Ну окей, неважно.
[35:44.160 --> 35:50.160]  Последнее рассуждение было не рассуждение, а тем, как это технически вычислять этот старший бит.
[35:56.160 --> 35:57.160]  Да.
[35:58.160 --> 35:59.160]  А иначе оказывает...
[35:59.160 --> 36:01.160]  А иначе мы говорим так, нот.
[36:02.160 --> 36:04.160]  Но а иначе оказывается, что...
[36:04.160 --> 36:06.160]  Ну, что такое вот этот вот максимальный лен?
[36:06.160 --> 36:10.160]  Это максимальное количество нулей, которые могут тут подряд в конце идти, правда?
[36:11.160 --> 36:16.160]  Так вот, я утверждаю, что это максимальное количество будет вот ровно вот в таком числе.
[36:16.160 --> 36:20.160]  То есть, когда мы вот в этом... Здесь вот префикс сохраняется, ну тут без вариантов, да?
[36:20.160 --> 36:23.160]  Тут мы ставим единичку, а после этого пишем все нули.
[36:24.160 --> 36:26.160]  Да, а про что вы там написали LXORR?
[36:27.160 --> 36:29.160]  Это... Ну, как вычис...
[36:29.160 --> 36:33.160]  Ну, тут вопрос. Даны LR, а как вычислить вот этот вот самый старший бит, в котором они различаются?
[36:34.160 --> 36:38.160]  То есть, надо просто взять LXORR и там любыми средствами, с помощью битовых операций,
[36:38.160 --> 36:41.160]  или с помощью их чего-то найти там старший бит.
[36:43.160 --> 36:46.160]  Вот. То есть там предподсчет какой-то сделан.
[36:47.160 --> 36:48.160]  Вот.
[36:49.160 --> 36:52.160]  Так что тут действительно по-разному можно делать.
[36:52.160 --> 36:58.160]  То есть обычно на практике, конечно, вот этот случай с L, который тут на эти нули делится,
[36:58.160 --> 37:00.160]  на самом деле даже тоже не рассматривают.
[37:01.160 --> 37:05.160]  Потому что, хотя в принципе, можно было не заморачиваться.
[37:05.160 --> 37:09.160]  Потому что в принципе можно было, можно в любом случае, даже если тут везде нолики,
[37:09.160 --> 37:14.160]  можно все равно вот там, допустим, вот это число, вот этот X рассмотреть,
[37:14.160 --> 37:19.160]  рассмотреть соответствующий уровень лен, и в нем соответствующие префиксные суммы найти суфиксные.
[37:21.160 --> 37:24.160]  Разница будет только в том, что просто там...
[37:24.160 --> 37:28.160]  Так, если у нас L прям вот тут такое с ноликами, это означает, что в соответствующем подотрезке
[37:28.160 --> 37:31.160]  вам на префиксе просто придется взять весь подотрезок.
[37:32.160 --> 37:34.160]  Ну, в общем-то, ничего страшного в этом нет.
[37:37.160 --> 37:38.160]  Вот.
[37:38.160 --> 37:39.160]  Но тем не менее.
[37:40.160 --> 37:41.160]  Вот.
[37:41.160 --> 37:45.160]  Так что вот такая вот штука оказывается, что если у нас есть только ассоциативность,
[37:45.160 --> 37:50.160]  то, в общем-то, аналог спортсов даже не сильно сложнее, но такие существуют.
[37:52.160 --> 37:54.160]  Так, есть ли тут какие-то вопросы?
[37:57.160 --> 37:59.160]  Да, нет, наверное, есть кто живой.
[38:02.160 --> 38:03.160]  Вот.
[38:03.160 --> 38:04.160]  Хорошо.
[38:04.160 --> 38:05.160]  Да.
[38:06.160 --> 38:07.160]  Ну, вот.
[38:07.160 --> 38:09.160]  Ну, нет, на самом деле вопросы там...
[38:09.160 --> 38:10.160]  Нет, вопрос есть.
[38:11.160 --> 38:16.160]  То есть, в идее, как бы, наука начинает спрашивать, да, но вы делаете предпочтение за НЛОГМ?
[38:17.160 --> 38:20.160]  А нельзя случайно сделать за Алинию?
[38:23.160 --> 38:25.160]  Кстати, отдельная песня, так слету даже...
[38:26.160 --> 38:29.160]  Нет, я так слету даже не отвечу, если честно.
[38:30.160 --> 38:33.160]  Хотя тут нам вообще надо задуматься, если так вообще-то уже...
[38:33.160 --> 38:35.160]  А нельзя ли в общем случае доказать, что нельзя?
[38:39.160 --> 38:40.160]  Кринут.
[38:41.160 --> 38:45.160]  Может выяснится, что если вам там подсовывают камешки, и на камешках есть каритмическая операция,
[38:45.160 --> 38:48.160]  по которой мы только знаем, что она ассоциативна,
[38:49.160 --> 38:54.160]  то выяснится, что на самом деле быстрее, чем за НЛОГМ нельзя в принципе, потому что бла-бла-бла.
[38:56.160 --> 38:57.160]  Вот.
[38:57.160 --> 38:58.160]  Может даже и нот.
[39:00.160 --> 39:03.160]  Ну, в принципе, тут на самом деле, даже если вы хотя бы для минимума ищете,
[39:03.160 --> 39:07.160]  там уже не самый тривиальный вопрос, можно ли вообще сделать предпочтение за Линию,
[39:07.160 --> 39:10.160]  так чтобы за УАД единицы отвечать потом на запрос.
[39:13.160 --> 39:17.160]  Нет, методология, конечно, есть, и мы в свое время будем ее изучать.
[39:18.160 --> 39:19.160]  Ну, как в свое время?
[39:19.160 --> 39:22.160]  Есть подозрения, что либо сегодня, либо в следующий раз, на самом деле.
[39:23.160 --> 39:24.160]  Ну, вот, ну, просто я...
[39:25.160 --> 39:27.160]  Ну, максимум через две недели.
[39:28.160 --> 39:29.160]  Вот.
[39:29.160 --> 39:31.160]  Да, соответственно, это была нот.
[39:33.160 --> 39:35.160]  Ну, пока мы на этом остановимся.
[39:36.160 --> 39:37.160]  Вот.
[39:37.160 --> 39:39.160]  Но это у нас были статические случаи.
[39:39.160 --> 39:41.160]  Это были статические случаи.
[39:42.160 --> 39:45.160]  Да, то есть когда у нас операция только ассоциативна, но у нас...
[39:48.160 --> 39:51.160]  Только ассоциативная, и массив при этом не меняется.
[39:53.160 --> 39:56.160]  А что делать, если массив меняется?
[39:58.160 --> 40:01.160]  Что в таком случае делать?
[40:05.160 --> 40:06.160]  Ну, в принципе, да.
[40:06.160 --> 40:07.160]  На самом деле...
[40:11.160 --> 40:12.160]  Да, вот действительно.
[40:12.160 --> 40:13.160]  Да-да-да.
[40:13.160 --> 40:14.160]  Вот давайте так и посмотрим.
[40:14.160 --> 40:16.160]  Какая первая идея возникает?
[40:16.160 --> 40:21.160]  Вот теперь представим себе, что у нас есть действительно уже более классическая задача.
[40:22.160 --> 40:25.160]  В которой надо делать ыть на отрезке.
[40:25.160 --> 40:29.160]  И, соответственно, изменять один элемент.
[40:33.160 --> 40:35.160]  То есть что-то переприсваивать.
[40:36.160 --> 40:39.160]  Ну, самое тупое, что можно сделать, это, конечно...
[40:40.160 --> 40:42.160]  Ну, там есть такие два крайних случая.
[40:42.160 --> 40:44.160]  На самом деле, каждый из которых может вам неожиданно помочь.
[40:45.160 --> 40:47.160]  Крайний случай номер раз.
[40:50.160 --> 40:51.160]  Ну, вот, допустим, да.
[40:51.160 --> 40:56.160]  А вот, опять же, давайте пока скажем, что ыть ассоциативно и все.
[40:59.160 --> 41:00.160]  Вот ассоциативно.
[41:04.160 --> 41:09.160]  Тогда, конечно, первая идея, которая возникает, вот самое тупое, что можно написать, и это иногда помогает.
[41:10.160 --> 41:11.160]  А давайте просто не заморачиваться.
[41:11.160 --> 41:15.160]  То есть делаем вот эту штуку в тупую и вот эту штуку прям в тупую, прям фориком.
[41:17.160 --> 41:18.160]  И иногда это помогает.
[41:19.160 --> 41:21.160]  Потому что, то есть, тут надо внимательно смотреть.
[41:22.160 --> 41:23.160]  Потому что, давайте, вот вам дана задача.
[41:23.160 --> 41:26.160]  Там, допустим, находить ыть на отрезке и изменять элемент.
[41:28.160 --> 41:30.160]  Как бы вы можете там забабахать.
[41:31.160 --> 41:32.160]  Кто-то может там забабахать.
[41:32.160 --> 41:34.160]  Так, ой, мы же на прошлом лекции изучили овл.
[41:34.160 --> 41:35.160]  Давайте писать овл.
[41:37.160 --> 41:38.160]  Ой, мы же изучили красно-черное дерево.
[41:38.160 --> 41:39.160]  Ну, круче.
[41:39.160 --> 41:40.160]  Давайте писать красно-черное дерево.
[41:41.160 --> 41:46.160]  Ну, пока вы его пишете, придут какие-нибудь маленькие восьмиклассники, которые не изучали красно-черное дерево.
[41:47.160 --> 41:48.160]  И вообще ничего не изучали.
[41:49.160 --> 41:50.160]  Поэтому, что как они будут решать задачу?
[41:51.160 --> 41:54.160]  Они внимательно прочитают задачу, посмотрят на ограничения.
[41:55.160 --> 41:56.160]  О влечениях написано.
[41:56.160 --> 42:00.160]  Гарантируется, что вот эта операция происходит не более чем пять раз.
[42:03.160 --> 42:04.160]  Что они тогда скажут?
[42:05.160 --> 42:06.160]  А давайте делаем префиксный ыть.
[42:08.160 --> 42:11.160]  Ну вот, скажут восьмиклассники, потому что префиксные суммы уж как-то, наверное, не изучали.
[42:12.160 --> 42:14.160]  Или додумаются сами.
[42:16.160 --> 42:17.160]  Чего?
[42:17.160 --> 42:18.160]  А если ыть не обратима?
[42:19.160 --> 42:20.160]  Если ыть не обратима.
[42:22.160 --> 42:23.160]  Ну вот.
[42:24.160 --> 42:25.160]  Ну ладно.
[42:25.160 --> 42:26.160]  Так, проблема.
[42:26.160 --> 42:27.160]  Хорошо.
[42:27.160 --> 42:28.160]  Ну они набирают...
[42:28.160 --> 42:32.160]  Ладно, они набирают 55 баллов, потому что там в первых трех группах гарантируется, что операция обратима.
[42:37.160 --> 42:38.160]  Вот.
[42:38.160 --> 42:39.160]  Ну ладно, да.
[42:39.160 --> 42:40.160]  Хорошо, да.
[42:43.160 --> 42:44.160]  Ну ладно, согласен.
[42:44.160 --> 42:45.160]  Согласен, да.
[42:45.160 --> 42:46.160]  Налоги тут не совсем уместны.
[42:46.160 --> 42:48.160]  Да, не совсем точно получилось, но не суть.
[42:48.160 --> 42:54.160]  Ну суть действительно в том, что если оказывается, что у вас массив меняется не сильно много раз,
[42:57.160 --> 43:00.160]  то оказывается выгодно насчитывать частичные суммы.
[43:00.160 --> 43:03.160]  Если там префиксный сумм или какой-нибудь spark stable.
[43:03.160 --> 43:08.160]  А если, допустим, а если массив элемент изменился, значит мы тогда ее просто пересчитываем в тупую.
[43:08.160 --> 43:13.160]  И это оказывается оптимальнее, чем любое там дерево отрезков, которое вы тут можете написать.
[43:14.160 --> 43:15.160]  Вот.
[43:16.160 --> 43:22.160]  Но бывает, конечно, другой крайний случай, когда у вас, наоборот, массив меняется часто, а вот этих ИТ мало.
[43:23.160 --> 43:24.160]  Ну тогда наоборот.
[43:24.160 --> 43:27.160]  Тогда выгодно вообще ничего не делать, просто делать все в тупую.
[43:27.160 --> 43:31.160]  Тогда ИТ вычитать чисто за линию, это тоже оптимально, оказывается.
[43:32.160 --> 43:33.160]  Вот.
[43:34.160 --> 43:40.160]  Но, конечно же, бывает, чаще все-таки встречаются задачи, когда и то, и то встречается достаточно часто.
[43:41.160 --> 43:43.160]  Там примерно одинаково часто.
[43:43.160 --> 43:45.160]  То есть, что же тогда делать?
[43:45.160 --> 43:47.160]  Какая первая идея может возникнуть?
[43:48.160 --> 43:50.160]  Ну первая идея, действительно, может возникнуть.
[43:50.160 --> 43:51.160]  Действительно.
[43:53.160 --> 43:56.160]  Ну да, наверное, надо как-то все...
[43:56.160 --> 44:00.160]  Хочется хранить какие-то префиксные суммы или суффиксные суммы.
[44:00.160 --> 44:03.160]  Но делить как-то подотрески надо.
[44:05.160 --> 44:06.160]  Ну да.
[44:07.160 --> 44:10.160]  Вот такой совсем spark stable, конечно, похоронить не удастся.
[44:10.160 --> 44:17.160]  Потому что если один элемент поменялся, то вам придется тут целый логариф массивов поменять и в каждом массиве менять за линию.
[44:18.160 --> 44:19.160]  Вот. Это не очень хорошо.
[44:19.160 --> 44:27.160]  Ну это, конечно, 8 точки не n log n, но как бы 8.n на запрос, это как бы могли быть честные там префиксные суммы насчитать или даже...
[44:28.160 --> 44:29.160]  Соответственно.
[44:29.160 --> 44:30.160]  Вот. Это нас не очень устраивает.
[44:32.160 --> 44:33.160]  Да, нас устраивает следующее.
[44:34.160 --> 44:37.160]  А давайте-ка поделим подотрезок.
[44:37.160 --> 44:38.160]  Подотрезок.
[44:39.160 --> 44:41.160]  Вот тут возникает какая-то такая неожиданная идея.
[44:41.160 --> 44:44.160]  А давайте поделим отрезок на подотрезки длины.
[44:46.160 --> 44:47.160]  Да. Действительно.
[44:48.160 --> 44:50.160]  А давайте потом подумаем, какой пока бубен.
[44:54.160 --> 44:55.160]  Вот.
[44:56.160 --> 44:57.160]  То есть такая вот классика жанга.
[44:58.160 --> 44:59.160]  Бубен.
[45:01.160 --> 45:04.160]  Да, как-то зафиксируем константу, которую потом подгоним позже.
[45:05.160 --> 45:06.160]  Такой стандартный метод.
[45:07.160 --> 45:08.160]  И будем говорить.
[45:09.160 --> 45:12.160]  Так. А давайте на каждом из этих подотрезков насчитаем...
[45:14.160 --> 45:19.160]  Ну, например, насчитаем там префиксные и суффиксные.
[45:22.160 --> 45:23.160]  Вот.
[45:24.160 --> 45:25.160]  Тогда как мы будем искать сумму?
[45:26.160 --> 45:27.160]  Ну, сумму будем искать так.
[45:28.160 --> 45:32.160]  Ну, во-первых, если подотрезок целиком попал внутрь одного блока, то, соответственно, мы его будем...
[45:32.160 --> 45:33.160]  Ладно, так и быть искать в тупую.
[45:36.160 --> 45:38.160]  А в противном случае мы что будем делать?
[45:41.160 --> 45:42.160]  Да, тогда мы...
[45:43.160 --> 45:49.160]  Ну, вот тогда у нас отрезок делится на, значит, соответственно, целые блоки, куда попали.
[45:49.160 --> 45:51.160]  Вот этот вот суффикс и вот этот вот префикс.
[45:52.160 --> 45:56.160]  Ну, на суффиксе и на префиксе мы умеем отвечать на запрос за вот единицы.
[45:56.160 --> 45:58.160]  Ну, в данном варианте.
[45:58.160 --> 45:59.160]  В данном варианте, да.
[46:00.160 --> 46:04.160]  Вот. В каждом блоке мы тоже умеем за вот единицы, то есть, получается, ответ находится.
[46:06.160 --> 46:07.160]  Ну, вот.
[46:07.160 --> 46:08.160]  Ну, не за о, а от ить.
[46:09.160 --> 46:10.160]  Ну, ить у нас за вот единицы работает.
[46:11.160 --> 46:16.160]  Поэтому получается, что ить от лр у вас может работать за сколько?
[46:16.160 --> 46:17.160]  Может работать за бубен.
[46:19.160 --> 46:20.160]  Вот в этом случае.
[46:20.160 --> 46:23.160]  А может работать за n поделить на бубен.
[46:23.160 --> 46:24.160]  Ну, скажем так.
[46:24.160 --> 46:25.160]  Давайте так.
[46:25.160 --> 46:26.160]  Ладно, будем говорить аккуратно.
[46:26.160 --> 46:30.160]  То есть, когда я здесь пишу, мы будем говорить бубен или n делить на бубен итий.
[46:31.160 --> 46:32.160]  Вот так.
[46:32.160 --> 46:33.160]  Да, итий могут быть жирные.
[46:33.160 --> 46:34.160]  Да.
[46:35.160 --> 46:36.160]  А.
[46:36.160 --> 46:40.160]  Потому что у нас блока, в которые мы тут прибираем вот в случае большого запроса,
[46:40.160 --> 46:41.160]  не более чем n поделить.
[46:43.160 --> 46:44.160]  Да.
[46:44.160 --> 46:48.160]  Но мы ж тут заявили, что мы в каждом блоке пересчитываем итий на префиксах итина.
[46:48.160 --> 46:50.160]  Так что мы тут еще и обнаглели.
[47:15.160 --> 47:17.160]  Пока мы не получили n поделить на бубен и бубен.
[47:17.160 --> 47:23.160]  бубен плюс бубен, но у нас есть проблема, что ассайен при вот такой интерпретации
[47:23.160 --> 47:30.040]  будет работать за сколько? Да, за бубен. То есть, на самом деле, суть, в общем, особо не
[47:30.040 --> 47:35.200]  поменялась. То есть, каждая операция может работать как за эндилит на бубен, так и
[47:35.200 --> 47:43.400]  бубен. Вот. Так что, в результате тогда, что тогда? Есть альтернативная версия.
[47:43.400 --> 47:47.120]  Альтернативная версия называется, давайте в каждом блоке, то есть, никакие
[47:47.120 --> 47:53.760]  префиксы и суффиксы не храним. А все, что мы делаем, это для каждой штуки
[47:53.760 --> 48:00.360]  пересчитываем сумму. То есть, пересчитываем только сумму на всем бубне. Но правда,
[48:00.360 --> 48:05.920]  замечаем, что у ассайна от этого бубен никуда не денется. Потому что, если поменялся
[48:05.920 --> 48:11.240]  элемент, придется вот перебегать. Даже наоборот, если бы префиксы и суффиксы хранили, то наоборот,
[48:11.240 --> 48:17.080]  у нас там был шанс пересчитать хотя бы сумму за побыстрее. Правда, префиксы и суффиксы
[48:17.080 --> 48:25.360]  все равно придется досчитывать. Да, если бы хранили сумму на отрезке, то, конечно,
[48:25.360 --> 48:30.520]  мы могли бы за 1 пересчитывать. Это да. Но в общем случае все равно получается,
[48:30.520 --> 48:38.200]  что на запрос мы тратим то ли бубен, то ли n делить на бубен, то ли сумму. То есть,
[48:38.200 --> 48:47.400]  ассимптотика пока получается все равно q на максимум из бубен и n делить на бубен.
[48:47.400 --> 48:55.480]  Остается только подогнать какой-нибудь хороший бубен для того, чтобы эта ассимптотика была как
[48:55.480 --> 49:04.240]  можно лучше. Да-да-да. Почему 300? 324 тогда уже. Впрочем, там от констанции зависит на самом деле.
[49:04.240 --> 49:10.240]  Да, с точки зрения абстрактной математики, конечно, мы говорим, что, то есть, заметь,
[49:10.240 --> 49:16.520]  чтобы максимизировать нот, чтобы минимизировать максимум, то есть, что нужно, одна функция у
[49:16.520 --> 49:21.760]  нас возрастает под бубен, другая функция убывает, и тогда надо найти просто место,
[49:21.760 --> 49:35.920]  где они начинают пересекаться. Почему оффлайн? Нет, мы не знаем. В данном случае мы говорим,
[49:35.920 --> 49:44.720]  что мы не знаем сколько кого. Да, если бы точно знали, то тогда у нас получалось бы что-то типа
[49:44.720 --> 49:58.000]  q1 на бубен, там плюс q2, там n делить на бубен. И тогда оптимальный бубен, тогда у нас оказывается,
[49:58.000 --> 50:04.600]  ну то есть, все равно надо их приравнять, и получается, что оптимальный бубен равно что-то типа там
[50:04.600 --> 50:12.200]  корень из n умножить на корень из q2 делить на q1. Ну то есть, если, ну понятно, если q равны,
[50:12.200 --> 50:17.720]  то оптимальный бубен корень из n, если там кого-то больше, то, соответственно, тогда у нас,
[50:17.720 --> 50:24.560]  тогда происходит какой-то какая-то балансировка в нужную сторону. То есть, скажем, если, то есть,
[50:24.560 --> 50:30.600]  если q1 больше, значит мы бубен сделаем поменьше, если q2 больше, значит мы бубен тоже сделаем побольше,
[50:30.600 --> 50:39.320]  чтобы тут знаменатель был, чтобы тут вот эта droid была поменьше. Вот, то есть, да, ну в реально,
[50:39.320 --> 50:44.280]  да, в реальности на практике тут еще и не только q1, q2, еще и константы могут вывести там конкретно,
[50:44.280 --> 50:49.040]  то есть конкретные константы, с которыми вы делаете вот эту операцию, эту операцию, да, поэтому там,
[50:49.040 --> 50:57.840]  ну вот, нет, подгонка. Нет, там подгонка где-то 300, где-то 400, то есть, там начинается, то есть,
[50:57.840 --> 51:01.760]  как бы два места в олимпиаде программировали, где происходит там, на самом деле, магическая
[51:01.760 --> 51:08.400]  подгонка. Это, собственно, в корневухе и в геометрии. Нет, ну мало ли еще, ну вот, ну соответственно,
[51:08.400 --> 51:14.760]  да, то есть, знаете, тут у нас это, то есть, на самом деле, владеющие этой магии, то есть,
[51:14.760 --> 51:18.440]  на самом деле, хорошо владеющие этой магии, особенно в последних минутах контеста, может чемпионом
[51:18.440 --> 51:23.520]  мира стать, на самом деле. То есть, мы уже помним, то есть, у нас это одна, одна команда фистеха уже
[51:23.520 --> 51:29.400]  так, называется там, лишилась чемпионства, потому что буквально там, называется, рядом с ней там сидела
[51:29.400 --> 51:37.400]  команда, которая за три минуты до конца там угадала епсилон. Вот, нет, история реальная. Вот,
[51:37.400 --> 51:48.680]  соответственно, да, был приятный, да, был веселый прецедент. Вот, в принципе, да, уже неплохо. То
[51:48.680 --> 51:54.120]  есть, по большому счету, то есть, первая идея у нас какая возникла? То есть, уже, в принципе,
[51:54.120 --> 52:02.360]  получается, что мы оба запроса можем делать за колень. То есть, в принципе, так уже неплохо. Вот,
[52:02.360 --> 52:08.000]  ну, какие тут еще могут возникнуть варианты? Ну, на самом деле, следующий вариант возникает такой.
[52:08.000 --> 52:17.240]  Так, а давайте делать это разбедение двухуровневым. То есть, идея на самом деле такая.
[52:17.240 --> 52:34.920]  Чего? Ну, вот, чего эскортили? Ну, вот. Ну, нет. Ну, скажи так, с таким названием не знаю.
[52:34.920 --> 52:50.520]  Ну, возможно. Ну, вот. Ладно, сделаем то, что делалось явно, что идея была явно раньше. То есть,
[52:50.520 --> 52:57.760]  давайте делаем, то есть, давайте так, поделим на, так сказать, тут какой-нибудь бубен B1. Вот,
[52:57.760 --> 53:04.400]  но при этом блоки по B1 у нас, может быть, будет где-то поменьше, но зато блоки мы еще сгруппируем
[53:04.400 --> 53:12.160]  в блоке какой-нибудь там, допустим, какой-нибудь B2, который равен B1 умножить на что-то. Вот, то есть,
[53:12.160 --> 53:20.400]  какой-нибудь такой. Ну, ладно, или лучше легче сказать, что B2 просто делится на B1. Чего? Что,
[53:20.400 --> 53:28.680]  чего нет? Ну, мы же бубны выбираем. Нет, ну, понятно, мы сейчас не оговариваем, конечно,
[53:28.680 --> 53:32.480]  что мы там делаем с хвостом, но понятно, что с хвостом, в общем, ничего страшного не происходит.
[53:32.480 --> 53:41.120]  Вот. Ну, тогда, ВТК, действительно, какая у нас идея? Ну, вот, тогда, то есть, идея такая. То есть,
[53:41.120 --> 53:46.880]  давайте вот храним такое, давайте в каждом блоке тоже, то есть, там, в каждом маленьком блоке храним
[53:46.880 --> 53:56.080]  все суффиксы при, там, суммы на всех префиксах и на всех суффиксах. Вот. Но, ну, вот, вот, на более
[53:56.080 --> 54:01.640]  высоком уровне делаем хитрее. Мы тоже храним там все префиксы, все суффиксы, но с оговорочкой.
[54:01.640 --> 54:10.400]  Потому что мы здесь считаем, что у нас всего вот это, то есть, на этом уровне мы храним только B1
[54:10.400 --> 54:17.640]  элементов. То есть, идея такая, то есть, я беру ИТ на каждом из этих подотресков, записываю куда-то
[54:17.640 --> 54:33.520]  сюда и его в явном виде храню. Ну, вот. Ну, да, B2 поделить на B1 элементов. Ну, то есть, идея, ну,
[54:33.520 --> 54:40.440]  идея такая, то есть, вот у нас есть какие-то вот N поделить на B1 отрезков. На каждом из них мы
[54:40.440 --> 54:51.120]  насчитали ИТ, записали эти, значит, эти ИТ на подотресках в массив отдельный. И на этом массив тоже,
[54:51.120 --> 55:07.400]  в свою очередь, поделили на, там, блоки по B2 поделить на B1, условно. Ну, вот. Ну, типа-то, ну,
[55:07.400 --> 55:12.480]  можно так сказать, да. А можно сказать, что мы поделили на блоки по B2 и внутри каждого из них
[55:12.480 --> 55:19.920]  забабахали, так сказать, корневуху в кавычках по B1. Можно, ну, по-разному можно это претировать,
[55:19.920 --> 55:28.000]  но суть такая. Вот. И тогда теперь смотрите, тогда у нас это будет работать. Если мы хотим
[55:28.000 --> 55:33.400]  поменять элемент, то есть, вот этот ассайн, то это будет работать, то есть, там, какой-то
[55:33.400 --> 55:38.200]  элемент поменять, то это будет работать за сколько? За пересчет вот этих сумм внутри этого блока,
[55:38.200 --> 55:48.320]  это будет B1. Ну, вот. И за пересчет элементов здесь. Это будет B2 поделить на B1. Это у нас ассайн.
[55:48.320 --> 55:56.800]  За сколько будет работать ИТ от ЭЛЕР? Ну, ИТ от ЭЛЕР в такой интерпретации будет работать
[55:56.800 --> 56:05.520]  за сколько? Вот. Ну, во-первых, мы замечаем, что у нас в ответ входит какое-то количество блоков
[56:05.520 --> 56:13.280]  на вот этом уровне. А этих блоков у нас, ну, вот. А этих блоков у нас не более чем N поделить на B2.
[56:13.280 --> 56:23.040]  Плюс что еще можно сделать? Ну, плюс еще надо найти ответы на суффиксах и префиксах. Ну,
[56:23.080 --> 56:29.200]  суффиксы и префиксы, это значит, мы отправляемся вот в какой-то набор вот этих блоков. То есть,
[56:29.200 --> 56:35.880]  сколько-то блоков тут и еще там какой-то суффикс. Вот. То есть, это уже, тут их уже получается,
[56:35.880 --> 56:45.280]  там, блоков получается B2 делить на B1. Чего? Ну да. Нет. Ну, почему? Если мы суффиксы и префиксы
[56:45.280 --> 56:51.960]  на блоках насчитываем, то единица. Вот. Но где-то там, правда, возникнет все равно B1,
[56:51.960 --> 56:57.960]  потому что все равно может выясниться, что у нас ответ попал внутрь. Вот такой суммы. Да. Более
[56:57.960 --> 57:04.440]  того, есть еще промежуточный вариант, когда нам придется, называется тут, за B2 работать. То есть,
[57:04.440 --> 57:16.440]  там B2 плюс B2 делить на B1. Там что-то такое. Вот. То есть, разные вот такие варианты. Вот. Ну,
[57:16.440 --> 57:20.880]  и опуская там все анализы, действительно уже очевидно, что на самом деле оптимально здесь
[57:20.880 --> 57:27.200]  взять, то есть сказать, что B1 и B2 равно тоже корень из N, но на этот раз кубический.
[57:27.200 --> 57:41.760]  Ну, давайте. Ну, хорошо, хорошо. Ну, господи, да, хорошо. B1 и B2 поделить на B1 должно быть корень
[57:41.760 --> 57:52.240]  кубический. Вот так. Вот. Ну, вот. Ну, кстати, да, если бы это была, то есть,
[57:52.240 --> 57:57.160]  здесь была структура данных для суммы, то есть, для обратимой операции и коммутативной еще сверху,
[57:57.160 --> 58:02.520]  это важно. То, что бы у нас произошло, то тогда мы вообще, тогда, конечно, изменение одного элемента
[58:02.520 --> 58:26.400]  мы вообще за единицу делали, кстати. Ну, да, не обязательно. Согласен. Да. Хорошо. Вот. То есть,
[58:26.640 --> 58:33.400]  вот. То есть, в принципе, да, то есть получается, в принципе, что можно сказать, что для любой
[58:33.400 --> 58:41.880]  константы C можно достичь все-таки корень с этой степени из N на операцию. Хотя, если C не считать
[58:41.880 --> 58:46.840]  константы, то мы, конечно, обнаружим, что там больше похоже на C умножить на корень с этой степени
[58:46.840 --> 58:53.960]  из N. Вот. Но если С считает константы, то, в принципе, можно сказать так. То есть, получается,
[58:53.960 --> 59:00.560]  для людей, знаете, это уже теорема, с которой, да, мы уже, нет, это не вот единица. Нет,
[59:00.560 --> 59:04.720]  а если, то есть, можно сказать так, для любого епсилон больше нуля найдется алгоритм,
[59:04.720 --> 59:19.680]  который тратит на каждый из этих запросов от N в степени 1 плюс епсилон. Да. Чего? Ну,
[59:20.160 --> 59:25.640]  я имею в виду, на каждый, на каждый из запросов он тратит повод столько времени. Ну, суммарно,
[59:25.640 --> 59:40.160]  да, он тратит Q на вот это, да. Чего? А, даже Q. Да, да, да. Вот. Хорошо. Да. Нет. Тут важно для
[59:40.160 --> 59:45.920]  любого епсилон больше нуля. Но, к сожалению, тут у нас восьминтотики непрерывность так не
[59:45.920 --> 59:54.840]  работает. Но вот, ну, жизнь так устроена, что, то есть, оказывается, то есть отсюда не следует,
[59:54.840 --> 01:00:01.920]  что существует алгоритм, который работает за линию. Вот типичный пример сортировка. Потому что
[01:00:01.920 --> 01:00:06.440]  утверждение, для любого епсилон больше нуля существует алгоритм сортировки за N в степени
[01:00:06.440 --> 01:00:21.320]  епсилон. Ну вот. Ой-ой-ой-ой-ой-ой, как всё грустно-то. Ну хорошо. Да, ладно.
[01:00:21.320 --> 01:00:37.120]  ну вот и хорошо да да но хорошо ладно да для сортировки не совсем так для сортировки
[01:00:37.120 --> 01:00:43.160]  теория обозвучала так да то же самое но для n степени 1 плюс айпсел то есть для любого
[01:00:43.160 --> 01:00:47.520]  айпсел больше нуля то есть найдется алгоритм который сортирует за такое симптом это при
[01:00:47.520 --> 01:00:52.760]  любой межсорт нам подойдет но к сожалению из этого не следует что у нас существует алгоритм
[01:00:52.760 --> 01:01:02.960]  который сортирует за нинью да к сожалению вот тут вот то есть более того да вот мы еще по идее мы
[01:01:02.960 --> 01:01:07.440]  впервые должны были с этим столкнуться как с фурятиной на самом деле потому что фурятине там
[01:01:07.440 --> 01:01:12.320]  это можно без всякой фурятины доказать сериям о том что можно переножать длинные числа вот за
[01:01:12.320 --> 01:01:18.520]  столько ну вот но это мы но это это отдельная песня это мы там собственно видимо все видимо
[01:01:18.520 --> 01:01:24.640]  будем в следующем семестре активно разбираться как это делать вот но соответственно здесь вот то
[01:01:24.640 --> 01:01:31.040]  же то есть принципе можно для любого то есть n в любой положительной степени но как бы до
[01:01:31.040 --> 01:01:37.520]  единицы скорее всего это не дойдет но тем более что на самом деле тем более что заметим что мы
[01:01:37.520 --> 01:01:42.000]  в общем-то чтобы делать произвольную константу c нужно уметь сделать произвольное количество
[01:01:42.000 --> 01:01:47.600]  уровней правда но с другой стороны есть подозрение что для фиксированного n есть на
[01:01:47.600 --> 01:01:53.560]  самом деле какая-то граница сколько уровней мы можем сделать ну потому что заметил что уровни
[01:01:53.560 --> 01:01:59.400]  наверное вряд ли целесообразно делать если у вас там внутри блока меньше чем хотя бы два элемента
[01:01:59.400 --> 01:02:04.880]  правда и вот действительно тогда вытекает действительно идея что вот у вас есть какие-то
[01:02:04.880 --> 01:02:16.520]  элементы и тогда давайте вот допустим делить делим их на блоке по два элемента то есть вот
[01:02:16.520 --> 01:02:23.760]  то есть принципе и для каждом блоке храним скажем сумму этих двух элементов но больше
[01:02:23.760 --> 01:02:29.560]  ничего хранить не надо особо вот после этого тогда оказывается что вот то есть эти блоки мы
[01:02:29.560 --> 01:02:35.880]  тоже там делим на блоке то есть тут уже каждый блок отвечает уже за по четыре элемента тут уже
[01:02:35.880 --> 01:02:48.120]  по 8 и 16 то есть в принципе вот и получается классическое дерево отрезков чего работает
[01:02:48.120 --> 01:02:57.960]  да но нет нету непрерывность не сработала потому что как вы все сами хорошо знаем
[01:02:57.960 --> 01:03:08.360]  операции в дереве отрезков работают все-таки не за единицу а за логом да но что приятно да
[01:03:08.360 --> 01:03:14.960]  то есть это алгоритм конечно до бьет все эти степени да то есть нету такого что там существует
[01:03:14.960 --> 01:03:18.680]  какой-то теоретический то есть для любого наш алгоритм который можем написать существует
[01:03:18.680 --> 01:03:23.000]  теоретический алгоритм который работает быстрее но правда на практике он особо
[01:03:23.000 --> 01:03:28.400]  неприменимы за огромные константы но в нашем случае нет у нас есть вот дерево отрезков и
[01:03:28.400 --> 01:03:33.000]  мы радуемся то есть видим до что дерево отрезков это просто такая корневуха на максималках
[01:03:33.000 --> 01:03:48.760]  зачем а зачем нам нужен нулевой элемент как бы дерево отрезков говорит так что оно как бы
[01:03:49.320 --> 01:03:55.080]  что существует что у каждой вершины есть подотрезок за который она отвечает и на котором
[01:03:55.080 --> 01:04:01.720]  она хранит но ей это для пересчета ты не надо потому что ей ну в идеале если мы например если
[01:04:01.720 --> 01:04:06.720]  у нас массив как всегда степень двойки то тогда как мы пересчитываем ответ мы его пересчитываем
[01:04:06.720 --> 01:04:18.600]  за то есть просто за единицу через детей вот нет туда да ну свея да отдельный еще вопрос
[01:04:18.600 --> 01:04:26.240]  сверху или снизу но то да да но тут надо добежать да потому что тут так ну-ка на всякий случай
[01:04:26.240 --> 01:04:34.720]  соцопроса а кто умеет делать операции в дереве отрезков снизу точно а нет ну почти все ладно
[01:04:34.720 --> 01:04:41.400]  но все спасибо не но тот вот грустный момент да потому что тут это пошли тут это модные
[01:04:41.400 --> 01:04:46.320]  тенденции педагогики виды да зачем рассказывать снизу все равно никому не надо на будущее
[01:04:46.320 --> 01:04:49.360]  вообще сверху сразу надо потому что мы отложены операции
[01:04:49.360 --> 01:05:12.720]  что пересчитывать нет но нет в чем проблема вот давайте напишем и снизу для вот такого
[01:05:12.720 --> 01:05:23.760]  дерева нет нет на самом деле нет я утверждаю что нужна только ассоциативность значит
[01:05:23.760 --> 01:05:27.880]  значит требовать будем так во первых давайте поговорим о том как хранить адекватно дерево
[01:05:27.880 --> 01:05:33.480]  отрезка давайте вот на всякий случай да то есть во первых скажем что у нас массив степень
[01:05:33.480 --> 01:05:42.320]  двойки да и боем массив у нас будет с нуля то есть тут n-1 и n равно степень двойки просто
[01:05:42.320 --> 01:05:50.360]  почему нам это удобно но вот на само дерево отрезков мы будем хранить так то есть то есть
[01:05:50.360 --> 01:05:57.920]  ячейки мы здесь будем хранить начиная с единицы зачем но тогда просто действительно оказывается
[01:05:57.920 --> 01:06:03.080]  что вот имеет место та же приятность что и в двоичной куче то есть именно что для каждой
[01:06:03.080 --> 01:06:08.840]  вершины легко найти детей как просто два на нее и два на нее плюс один и родителя как просто
[01:06:08.840 --> 01:06:17.760]  поделить на два вот то есть тут оказывается очень удобно 14 15 и тут вот 16 17 и так далее да то есть
[01:06:17.760 --> 01:06:25.080]  при какой предподсчете вот это вот то есть n у нас это на два степени к вот и соответственно
[01:06:25.080 --> 01:06:30.280]  но мы соответственно вот у нас тут такая каждая ячейка отвечает в каждой ячейке хранится
[01:06:30.400 --> 01:06:39.400]  соответствующих элементов вот ну и тогда оказывается что как найти действительно
[01:06:39.400 --> 01:06:51.560]  скажем как тогда найти значит пишем значит код тогда может прозвучать так так скажем
[01:06:51.560 --> 01:07:04.440]  таки но это не ключ конечно ладно ну ладно давайте t-element хорошо значит t-element
[01:07:04.440 --> 01:07:10.080]  как будет уйти по-английски
[01:07:10.080 --> 01:07:30.480]  нет это уйду не а года а еще идти написать то получится не надо не надо
[01:07:30.480 --> 01:07:41.240]  нет ну ладно быть ну ладно быть так это быть так ладно давайте быть он сегмент
[01:07:41.240 --> 01:07:51.520]  ну уйти что нет у нас операция уйти не операция и все-таки да
[01:07:51.520 --> 01:08:08.520]  так значит как вообще это все будет работать работать это будет примерно так да вот давайте
[01:08:08.520 --> 01:08:13.920]  как как мы тут будем искать сумму сумму будем искать примерно следующим образом вот допустим
[01:08:13.920 --> 01:08:20.960]  нам нужно найти вот такую штук тогда мы замечаем следующее что внутри этого подотрезка все
[01:08:21.100 --> 01:08:26.060]  элементы можно разбить на дваamation на паре причем паре сумма которых уже представлена в
[01:08:26.060 --> 01:08:34.240]  дереве отрезков кроме может быть левого элемента и может быть правой но как определить как как
[01:08:34.240 --> 01:08:41.480]  определить вот у этого левого элемента его напарник внутри отрезка или вне да то есть
[01:08:41.480 --> 01:08:47.620]  едим а прав abrirти 너무 как отличить мой правый сын или левый то есть если мы antibiotics
[01:08:47.620 --> 01:08:52.740]  оказывается правый сын это такой сын который не делится на два а левый сын тот который делится
[01:08:52.740 --> 01:08:58.820]  на два очень удобно мы здесь на вот то есть получается здесь правого сына там то есть правого
[01:08:58.820 --> 01:09:03.460]  сына быстренько обчитываем значит левого сына тут если он есть тоже обчитываем после этого
[01:09:03.460 --> 01:09:08.500]  переходим на следующий уровень где делаем буквально то же самое логично там то есть тоже
[01:09:08.500 --> 01:09:15.900]  право сына общита но тут право сына обчитали левого сына тут нету но поэтому идем сюда так ну
[01:09:15.900 --> 01:09:18.960]  здесь вот этого правого сына обчитываем левого сына обчитываем и выясняется дальше大家 и monk
[01:09:18.960 --> 01:09:29.760]  что пустил поздравляю мы бы поздравляю и доехали вот но как их правильно насчитывать то есть
[01:09:29.760 --> 01:09:35.180]  насчитывать получится так что надо соответственно просто то есть вот это вот этих товарищей значит
[01:09:35.180 --> 01:09:40.300]  то есть на этих товарищей искать какую-то сумму там какой-то и слева и тут искать какой-то буквально
[01:09:40.300 --> 01:09:50.580]  справа значит мы поэтому значит пишем значит значит инициализируем ну начнем
[01:09:50.580 --> 01:10:00.580]  с того что l у нас к l прибавим n и к r прибавим n да и дальше пишем t элемент
[01:10:00.580 --> 01:10:14.460]  значит преф равно вот так скажем empty segment даже знаете вот скорее всего это
[01:10:14.460 --> 01:10:23.420]  будет даже звучать как там t элемент двоеточие двоеточие empty segment
[01:10:23.420 --> 01:10:31.580]  ну смотрите да то есть по-хорошему да я мог бы написать нейтральный элемент но
[01:10:31.580 --> 01:10:37.580]  как мы с вами договорились нейтрального элемента может и не быть вот но мы специально заведемся
[01:10:37.580 --> 01:10:42.500]  что у нас есть такой специальный элемент который сигнализирует о том что мы храним там
[01:10:42.500 --> 01:10:48.420]  идь там пустого префикса то есть какой-то пустого подотреска и тогда когда мы его будем
[01:10:48.420 --> 01:10:54.540]  домножать на что угодно получится это самое что угодно ну то есть условно говоря мы искусств
[01:10:54.540 --> 01:10:59.780]  то есть как бы если у этой операции идти у этого множества нет единицы мы ее искусственно вводим
[01:10:59.780 --> 01:11:05.900]  то есть мы не требуем никакой обратимости но просто мы вот эту единицу искусственно вводим вот
[01:11:05.900 --> 01:11:17.740]  вот но ты элемент сув соответственно тоже пишем равно t элемент двоеточие двоеточие тоже empty
[01:11:17.740 --> 01:11:34.380]  segment вот можно но так все-таки но так все-таки правильнее а то как-то ощущение что суф это
[01:11:34.380 --> 01:11:40.540]  такой но то есть как-то ощущение что преф как-то первичнее суфа хотя на самом деле они одинаковые
[01:11:40.540 --> 01:11:45.620]  поэтому логичнее все-таки так написать вот но в общем на вкус и цвет как говорится фломастеры
[01:11:46.020 --> 01:11:56.420]  вот и так значит пишем while l меньше либо равно r дальше говорим мы начну и дальше
[01:11:56.420 --> 01:12:04.860]  код там работает так значит если оказалось что l не делится на два то тогда что мы делаем
[01:12:04.860 --> 01:12:20.780]  вот тогда но сначала мы говорим что преф равно преф быть значит там три значит от
[01:12:20.780 --> 01:12:26.940]  l и после этого мы говорим плюс плюс и но я мог бы конечно тут l плюс плюс написать но я не буду
[01:12:26.940 --> 01:12:38.900]  делать чтобы понять не было вот независимо пишем что если оказалось что если не r and 1 то тогда
[01:12:38.900 --> 01:12:53.020]  мы пишем суф равно и вот здесь очень важно 3 от r быть суф минус минус r но дальше пишем
[01:12:53.020 --> 01:13:14.980]  l делим на два r делим на два чем ну кого ну он по разному на самом деле на вкус и цвет на вкус
[01:13:15.340 --> 01:13:24.380]  но вот ну и ретурн получается надо все что в конце надо писать это преф быть
[01:13:24.380 --> 01:13:31.860]  то есть вот так на самом деле штуку можно писать если у вас операция абстрактная то есть надо
[01:13:31.860 --> 01:13:36.380]  обратить внимание что важно здесь вот паря если у вас операция некоммутативная то вот порядок
[01:13:36.380 --> 01:13:54.060]  здесь важно не перепутать видно да но вот но в тите в качестве упражнения стоит доказать что да
[01:13:54.060 --> 01:13:58.660]  то есть действительно это то есть вот всякие границы там с граничными случаем каких там проблем
[01:13:58.660 --> 01:14:03.660]  не возникнет то есть остановится этот вайл тогда когда нужен но в принципе да то есть если не
[01:14:03.820 --> 01:14:10.140]  вот это вот полезно знать на самом деле ну как минимум потому что это дается понимание того
[01:14:10.140 --> 01:14:15.140]  как встроено дерево отрезков это раса вторых все-таки при прочих равных не рекурсивный
[01:14:15.140 --> 01:14:22.980]  код будет все-таки работать быстрее чем рекурсивный вот но да и в общем-то пишет да и пишется мне
[01:14:22.980 --> 01:14:28.460]  кажется да и как-то вот этот код по моему как-то пишется даже попроще чем рекурсивного по час
[01:14:28.460 --> 01:14:35.900]  что что вы имеете в виду вот тут л-л плюс плюс написать или шо
[01:14:35.900 --> 01:14:47.260]  не оправдываться хорошо если мы будем писать на полу интервала хочу по моему код будет
[01:14:47.260 --> 01:15:06.060]  буквально такой же только вот тут четкости будут немного другие да и да вот это и вот это
[01:15:06.060 --> 01:15:14.540]  убивается еще да ну хорошо
[01:15:36.060 --> 01:15:53.020]  но я честно скажу по моему по моему это не по моему это не называется проще по моему уже
[01:15:53.020 --> 01:16:03.740]  нету быстрее и проще это разная вещь то есть да потому что да потому что кстати проще бывает
[01:16:03.740 --> 01:16:08.380]  разное можно там можно попытаться загнать этот код сделать так чтобы написать поменьше символов
[01:16:08.380 --> 01:16:12.380]  это да можно загнать действительно что есть идеи на проще как правило скажем можно вообще как
[01:16:12.380 --> 01:16:35.420]  в него уху написать нет нет ну да ну да ну да да да да в том знаете вот там это надо
[01:16:35.980 --> 01:16:47.220]  вы даете контест надо его разобрать вы открываете авторское решение там вот это ну да ну вот ну не
[01:16:47.220 --> 01:16:53.740]  важно нет ну ладно так что тут уже конечно действительно до вкуса цвета там но сейчас не
[01:16:53.740 --> 01:16:58.140]  об этом так то сейчас вот действительно есть вот на самом деле есть разные варианты потому что
[01:16:58.140 --> 01:17:04.340]  сегодня нам еще предстоит еще выяснить что помимо этого можно вообще дерево фенвик написать и это
[01:17:04.340 --> 01:17:21.540]  уже но вот ну почему но смотря что спуск по федрику нет ну как сказать по большому
[01:17:21.540 --> 01:17:29.780]  счет я не знаю первое то есть возможно я не знаю что имеется в виду конкретно сейчас пошел но спуск
[01:17:29.780 --> 01:17:35.460]  но тут дай что да потому что да потому что заметил что встречный федрик это такое дерево
[01:17:35.460 --> 01:17:50.380]  отрезка в котором элементы по-другому записаны по обычному ну как-то ну нету почему нет нету
[01:17:50.380 --> 01:17:55.940]  почему нет нет не общета в принципе да нет а в принципе можно то что выясняется что по тем
[01:17:55.940 --> 01:17:59.980]  элементам которым вы идете там просто они в нужной половине дерево отрезков представлены
[01:17:59.980 --> 01:18:18.300]  ладно да хорошо обсудим этот момент вот так что я надеюсь так сколько сейчас время это так
[01:18:18.300 --> 01:18:27.180]  ладно так ну хорошо так но вот сейчас но есть правда нет при но есть правда еще маленькая
[01:18:27.180 --> 01:18:32.540]  оговорчика хорошо мы написали как искать сумму на отрезке по хорошему чтобы добить дерево
[01:18:32.540 --> 01:18:38.740]  отрезков мы должны конечно еще понять как изменять элемент но здесь понятно тут уже код ищется
[01:18:38.740 --> 01:18:45.740]  достать тут уже пишется достаточно тривиально да как он пишется то есть void вот этот вот ассайн
[01:18:45.820 --> 01:19:00.580]  от int pos int x t элемент точнее x как его написать значит там получается pos
[01:19:00.580 --> 01:19:09.900]  плюс равно n да пишем 3 посовая тупо равно x но дальше так ладно для тех кто не любит
[01:19:09.900 --> 01:19:22.940]  while давайте так и пишем for постом делить равно 2 pos значит pos делить равно 2 пишем тогда значит
[01:19:22.940 --> 01:19:42.780]  3 но вот 3 от pos умножить на 2 3 от pos умножить на 2 плюс 1 ой а я уже все написал
[01:19:42.780 --> 01:19:53.340]  но понятно да тут я думаю нет особых вопросов что я сделал да я просто прошелся снизу просто
[01:19:53.340 --> 01:19:58.060]  то есть когда изменил элемент я пробежался по всем его предкам в каждом предке просто тупо
[01:19:58.060 --> 01:20:06.140]  пересчитал видите да то есть вот пересчитал и то есть вот таким вот например образом то есть
[01:20:06.140 --> 01:20:13.740]  можно вот написать вот такого объема в принципе код вот но оказывается если операция не только
[01:20:13.740 --> 01:20:20.020]  ассоциативно ну и коммутативно и обратимо то можно написать кода оказывается и поменьше и
[01:20:20.020 --> 01:20:28.380]  сделать более того заметим что смотрите сколько памяти требует дерево отрезков да но требует
[01:20:28.380 --> 01:20:40.740]  памяти она требует памяти до двое но на самом деле да да то есть то есть вплоть до четырех да то
[01:20:40.740 --> 01:20:45.140]  есть там на часто на практике да берите ваши 100 тысячи домножайте на четыре ну или там находите
[01:20:45.140 --> 01:20:55.980]  степень двойки там ближайшую и следующую за ней да вот но для но просто но как сказать у нас
[01:20:55.980 --> 01:21:03.380]  пока весь вот этот код работал в предположении что над степенью нет вот это вот вот эти вот
[01:21:03.380 --> 01:21:23.940]  штуки тут просто скажи так операции сверху нет ну как сказать а нет ну как сказать особенно
[01:21:23.940 --> 01:21:27.980]  если операции сверху то им там можно как-то реализовать но правда если операции сверху
[01:21:27.980 --> 01:21:45.380]  можно вообще резать динамическое дерево отрезков снизу ну нет ну сложно сказать нет то в любом
[01:21:45.380 --> 01:21:51.580]  случае на самом деле скажем что можно конечно в этом смысле думать но на самом деле ну в принципе
[01:21:51.580 --> 01:21:56.620]  можно заметить что существует на самом деле дерево федрика который потребует в общем случае
[01:21:56.620 --> 01:22:04.140]  ровно двоян операции ровно двое а в случае коммунативной операции и обратимый на самом
[01:22:04.140 --> 01:22:10.620]  деле потребует просто то есть по памяти потребуется даже не двоян а просто хотя как мы потом выясним
[01:22:10.620 --> 01:22:15.740]  на самом деле идеи в общем-то отсюда недалеко ушли то есть по камере не сильно ближе чем кажется
[01:22:15.740 --> 01:22:21.740]  но и кода получится меньше и памяти получится меньше но как это произойдет мы обсудим после
[01:22:21.740 --> 01:22:30.300]  перерыва таким же образом можно решать но каким же образом можно решать нашу мистическую задачу
[01:22:30.300 --> 01:22:39.780]  какой-нибудь эритку за адекват за чуть более адекватную память чем это умножить в худшем
[01:22:39.780 --> 01:22:53.180]  случае на 4 но как разобрали я лично я не разобрал но да но да
[01:22:53.180 --> 01:23:19.460]  но там-то сложен вот но справляем так охотно верю но с другой стороны кажется как бы феновик
[01:23:19.460 --> 01:23:22.900]  в любом случае надо обсудить потому что крутая это вы же как минимум крутая вещь
[01:23:22.900 --> 01:23:31.380]  а нет как дать знаете есть какое-то видео в котором там рассказывайте мистику потом говорят об том
[01:23:31.380 --> 01:23:38.340]  говорит как это устроено никто не знает а я знаю и конечно с удовольствием расскажу и дальше там
[01:23:38.340 --> 01:23:42.740]  рассказывается каким образом там что-то брожение присутствует какой-то мухой который какой-то
[01:23:43.740 --> 01:23:55.300]  добра но доображение да то есть просто все очень любят устроена это пить пива да никто не но как
[01:23:55.300 --> 01:24:01.260]  она как оно варится никто не знает а я знаю и конечно с удовольствием расскажу там на самом деле
[01:24:01.260 --> 01:24:07.780]  да на хмель там что-то налетают бухи значит они садятся помещают там какие-то свои вещества эти
[01:24:07.780 --> 01:24:15.220]  вещества там реагируют но вот то есть начинается но-то но-то скажи так суть рассказа примерно вот
[01:24:15.220 --> 01:24:26.180]  такая детали могу путать но вот там какой-то градус абсурдизма примерно такой вот да хотя
[01:24:26.180 --> 01:24:31.860]  да вот как устроен феновик действительно нету феновик в общем-то действительно устроен достаточно
[01:24:31.860 --> 01:24:43.060]  мистично потому что действительно потому что если мы хотим потому что допустим что у нас
[01:24:43.060 --> 01:24:52.500]  операция идь допустим ассоциативно коммутативно обратимо ну в общем-то коммутативно даже ставим
[01:24:52.500 --> 01:25:04.260]  скобочках они не ставим не ставим вот и допустим мы хотим действительно делать операцию rsq там
[01:25:04.260 --> 01:25:17.580]  видео значит найти найти идь допустим на отрезке и так сказать add pos x но раз она коммутативно то есть
[01:25:17.580 --> 01:25:26.180]  ну по сути мы хотим чтобы а по самому там скажем было плюс равно то есть идь вот идь
[01:25:26.180 --> 01:25:34.700]  равно x вот так да у нас так оператор идь равно хотя знаете это как-то но вот хотя если честно
[01:25:34.700 --> 01:25:39.580]  действительно как там часто вот не хватает все-таки вот это да когда у нас вот операции мин равно нету
[01:25:40.580 --> 01:25:53.980]  нет мы-то пишем апд это да нет нет ввести новый оператор мы не можем да ну нет ну как
[01:25:53.980 --> 01:26:01.580]  плохо знаешь это надо как бы нет ну как сказать нет ну нет не совсем так на define и могут нам
[01:26:01.580 --> 01:26:11.380]  помочь в принципе но развлечение но развлечение будет нет ну что-то наверное не могут там со
[01:26:11.380 --> 01:26:26.740]  ну хотя ладно ну понятно понятно да да хоть да переда как это как и хватает это да да да
[01:26:26.740 --> 01:26:34.740]  нет обычно да нет обычно приходится писать оп там апд и так далее ладно так вот значит
[01:26:34.740 --> 01:26:43.500]  идея такая вот допустим я опоссовая и допустим массив а у меня тоже идет от нуля до n-1 вот
[01:26:43.500 --> 01:26:51.660]  но на самом деле что нужно чтобы писать дерево фенвика но оказывается да для этого нужно просто
[01:26:51.660 --> 01:27:04.220]  завести массив тф на 1 м и написать буквально следующие заклинания мы изначально мы считаем
[01:27:04.220 --> 01:27:10.140]  что оба массива нули там просто нулевые и дальше как у нас будет как у нас будет
[01:27:10.140 --> 01:27:19.700]  выглядеть функции ну функция это да будет выглядеть примерно так там то есть void допустим это да там
[01:27:19.700 --> 01:27:35.900]  int pos t-element x так ну поехали как это как тогда это будет выглядеть for плюс плюс pos pos меньше
[01:27:35.900 --> 01:27:52.140]  либо равно n pos равно там pos или pos минус 1 плюс 1 может я наврал в моей интерпретации
[01:27:52.140 --> 01:28:04.660]  минус потому что в моей интерпретации vt и tf у меня от 1 до n но там потому что или и потом
[01:28:04.660 --> 01:28:29.940]  еще плюс один ко всему этому надо там это минус 1 вот то есть tf от pos быть равно x вот все так дальше
[01:28:29.940 --> 01:28:39.980]  если я хочу найти какой-то элемент t-element то есть хочу найти и так сказать быть он сегмент
[01:28:39.980 --> 01:29:00.340]  от int l int r то что я говорю но вот то я говорил ретурн быть преф но я так
[01:29:00.340 --> 01:29:12.300]  напишу давайте так l минус 1 в минус первой быть преф от вот так видимо я тут должен
[01:29:12.300 --> 01:29:19.540]  взять какую-то функцию инф конечно но думаю и так понятно о чем речь вот и конечно его величество
[01:29:19.540 --> 01:29:44.180]  быть преф значит быть преф от int r но то мы говорим да там t-element там ans равно как всегда t-element
[01:29:49.540 --> 01:30:08.780]  на mt-сегмент вот ну и тут мы пишем понятно for плюс плюс r r больше нуля r and равно r минус
[01:30:08.780 --> 01:30:18.940]  1 там ans равно соответственно ну давайте чтоб тут было понятнее tf от r быть ans
[01:30:18.940 --> 01:30:32.460]  да в чем заключается магия магия заключается в том что это все буквально
[01:30:32.460 --> 01:30:42.580]  практически буквально вот собственно весь код я написал то есть памяти требуется то есть
[01:30:42.580 --> 01:30:49.140]  помимо самого массива а требуется буквально n на этот раз но остается только действительно
[01:30:49.140 --> 01:31:00.260]  выяснить это но вот а почему это все вообще работает чего нужна ой нужна вот вот вот чтобы
[01:31:00.260 --> 01:31:05.700]  такой вот это наглый делать ой как нужна потому что если вы прибавляете элемент где-то в середине
[01:31:05.700 --> 01:31:13.420]  подотрезочка то нужна поэтому да на этот раз коммутативность это прям святое вот но нам
[01:31:13.420 --> 01:31:19.140]  конечно а при цену остается только выяснить а почему это вообще работает так а кто кстати вообще
[01:31:19.140 --> 01:31:23.740]  но я догадываю что дерево фенвика наверно вы собственно хоть раз в жизни написали наверно
[01:31:23.740 --> 01:31:30.900]  да хотя давайте кто хотя бы раз в жизни писал дерево фенвика ну логично да вот
[01:31:30.900 --> 01:31:40.060]  да ну к ну копипастил переписал дан в случае одно и то же так хорошо а кто понимает почему
[01:31:40.060 --> 01:32:08.940]  это вообще работает да да ладно даже интересная версия но вот
[01:32:08.940 --> 01:32:20.540]  но тем не менее почему-то известно как дерево фенвика все равно до binary индексе 3
[01:32:20.540 --> 01:32:30.860]  называется ну а автор статьи что оказывается можно еще делать вот так да отдельная песня почему
[01:32:30.860 --> 01:32:36.100]  это называется дерево но у него там какие-то картинки есть что действительно что он это как-то как
[01:32:36.860 --> 01:32:44.260]  я так слета не могу сказать почему вот но давайте разбираться почему же собственно это все работает
[01:32:44.260 --> 01:32:54.860]  но идея на самом деле такая вот то есть на самом деле вот эта штука то есть давайте так сейчас
[01:32:54.860 --> 01:33:03.020]  мы введем две функции красную и синю вот вот эта функция будет красная то есть вот на самом деле
[01:33:03.020 --> 01:33:14.260]  вот это вот будет называться у нас f от поз или красную зеленую лучше точно давайте зеленую вот
[01:33:14.260 --> 01:33:23.780]  это вот будет называться нет ой черт это цвета у я молодец я цвета перепутал ну ладно да не будет
[01:33:23.780 --> 01:33:32.020]  не будет мне немножко непривычно но на самом деле не принципиально а это будет f от так вот цель
[01:33:32.020 --> 01:33:36.860]  на самом деле была но вот ну то есть идея такая хочется но то есть на самом деле если бы я сейчас
[01:33:36.860 --> 01:33:47.260]  кода не писал просто идея была бы такая я хочу ввести массив тф и ну вот и сказать что тф что
[01:33:47.260 --> 01:34:00.900]  на самом деле тф и т это уить на полу интервале от f от и до и вот тут я полу интервалы ввиду
[01:34:00.900 --> 01:34:11.420]  неожиданно но обратите внимание что если мы верим что тф и это вот такая вот штука то
[01:34:11.420 --> 01:34:16.700]  тогда отсюда автоматически следует что этот код по крайней мере работает ну я не знаю за
[01:34:16.700 --> 01:34:26.220]  какой симпатику но работает логично да вот вот но соответственно но но единственная только
[01:34:26.220 --> 01:34:32.100]  проблема что как бы полу интервала надо подбирать не просто так каким образом их надо подбирать их
[01:34:32.100 --> 01:34:37.540]  надо подбирать таким образом что если придет время измени вот что нужно если мы там захотели
[01:34:37.540 --> 01:34:43.180]  к постовому элементу прибавить x нужно найти в тф все полу интервалов содержащие пост и ко
[01:34:43.180 --> 01:34:51.180]  всем им прибавить x правда остается только понять как же их найти так вот тут ну видимо методом
[01:34:51.180 --> 01:34:58.860]  там методом каких-то вот проп и ошибок или глядя на дерево отрезков какой-нибудь придумалось
[01:34:58.860 --> 01:35:11.940]  неожиданное определение то есть определение звучит так то есть f от и это число и у которого
[01:35:11.940 --> 01:35:20.740]  обнулен младший единичный бит
[01:35:20.740 --> 01:35:34.180]  вот что это сочетание означает то есть означает что есть у нас было какое-то число и то есть
[01:35:34.180 --> 01:35:45.820]  там был там 00 это 1100 там рандом рандом 1100 там 1100 вот то тогда f от и говорит
[01:35:45.820 --> 01:35:51.740]  такое следующее что оно все абсолютно такое же такое же такое же копипаста копипаста копипаста
[01:35:51.740 --> 01:35:58.420]  только в общем единственное только что вот где вот последний единичка находится у нас находится 0
[01:35:58.420 --> 01:36:14.380]  вот то есть вот такая неожиданная идея ну легко показать что то есть легко показать что на самом
[01:36:14.380 --> 01:36:24.300]  деле то есть дальше уже вытекает такое утверждение да то есть утверждение f от и равно и и минус 1
[01:36:24.300 --> 01:36:33.500]  вот понятно и действительно не сложно будет что потому что и минус один это что такое это вот
[01:36:33.500 --> 01:36:38.500]  этот единичный бит мы обнуляем а вот эти объединичиваем наоборот а когда делаем
[01:36:38.500 --> 01:36:46.580]  энд то получается что и тут 0 и там 0 остается вот то есть можно это вот воспринимать вот таким
[01:36:46.580 --> 01:36:54.100]  вот нехитрым способом но теперь вытекает вопрос а как же найти теперь все полу интервалы в которых
[01:36:54.100 --> 01:37:04.540]  чисто какое-нибудь число поз лежит ну значит тут технология такая то есть на то есть то есть
[01:37:04.540 --> 01:37:13.220]  то есть значит дано число поз надо найти все такие и что f от и меньше либо равно поз строго
[01:37:13.220 --> 01:37:22.540]  меньше и логично да ну поехали как же это сделать тогда вот допустим у меня число поз оно какое а
[01:37:22.540 --> 01:37:37.860]  оно у меня какие-то 0 0 0 1 1 1 1 1 там 0 0 1 0 1 1 1 1 0 0 0 1 1 1 1 0 0 0 так теперь давайте
[01:37:37.860 --> 01:37:46.540]  думать как устроено число и число и это какое-то число которое больше поза это означает что до
[01:37:46.540 --> 01:37:53.460]  какого-то момента они совпадают а то в какой-то момент бабах и неожиданно тут все-таки образовалась
[01:37:53.460 --> 01:38:02.580]  единица и начиная с этого вот тут образовалась единица а дальше идет что угодно понимаем да
[01:38:02.580 --> 01:38:15.340]  но теперь начинаем думать но как устроена f от и так ну f от и очевидно до этого момента
[01:38:15.340 --> 01:38:28.540]  точно ничего не поменяется 0 0 1 1 1 1 0 0 1 0 1 1 1 0 0 так а вот теперь интрига теперь у нас
[01:38:28.540 --> 01:38:37.580]  два случая если после этой единички в и есть еще какие-то единички да то тогда мы вынуждены
[01:38:37.580 --> 01:38:44.100]  заключить что и здесь будет написано единица правда но тогда оказывается что f от и тоже
[01:38:44.100 --> 01:38:54.260]  строго больше поза понимаете да это невозможно следовательно тут написан 0 и отсюда тогда
[01:38:54.260 --> 01:39:02.900]  возникает ощущение что тогда после вот этой единицки железобетонно находится только 0 мы тут
[01:39:02.900 --> 01:39:16.580]  в общем-то тоже ну просто тут как бы ну потому что и f от и отличаются в одном бите можно вот
[01:39:16.580 --> 01:39:23.500]  рассуждать еще по-другому тут единичка и тут стало строго больше но так как здесь f от и меньше
[01:39:23.500 --> 01:39:28.820]  либо равно поза до этого момента было совпадение то тогда и здесь мы вынуждены писать 0 следовательно
[01:39:28.820 --> 01:39:32.780]  вот он этот бит в котором различия но это может быть только в том случае если дальше
[01:39:32.780 --> 01:39:39.820]  идут только 0 это младший день так то есть в переводе говоря мы то есть получается должны
[01:39:39.820 --> 01:39:47.660]  перебрать все такие и которые вот на самом деле которые как бы как поз только какой-то
[01:39:47.660 --> 01:39:56.140]  ноль экзаменен на единичку а дальше все обнулено вот видите да но давайте попробуем взять число
[01:39:56.140 --> 01:40:03.780]  поз и тупо перебрать и просто тупо посмотреть как такие числа выглядят но давайте я поз поменьше
[01:40:03.780 --> 01:40:18.660]  себе возьму на этот раз поз там 0 0 0 там допустим 1 1 1 1 1 0 0 1 1 1 там 0 0 0 0 там 1 1 0 0 0 значит поехали
[01:40:18.660 --> 01:40:26.100]  значит но соответственно где же этот нолик менять на единичку очевидно чем как бы более старше
[01:40:26.100 --> 01:40:34.500]  нолик мы заменим на единичку чем больше получится число правда вот но поехали но самое младше это
[01:40:34.500 --> 01:40:39.060]  конечно когда мы самый первый нолик заменим на единичку то есть это вот мы вот тут возьмем
[01:40:39.060 --> 01:40:51.020]  единичку а тут соответственно 0 0 0 1 1 1 1 0 0 1 1 1 1 0 0 0 1 1 0 дальше если мы возьмете второй
[01:40:51.020 --> 01:41:03.740]  нолик получится тут 0 1 0 ну и дальше тоже копипаста 0 0 0 1 1 1 1 0 0 1 1 1 0 0 0 так потом
[01:41:03.740 --> 01:41:13.140]  берем вот этот то есть следующие значит вот тут единичка 0 0 0 там копипаста бла бла бла вот так
[01:41:13.140 --> 01:41:18.460]  1 1 1 1 так вот дальше интересно давите после этого нолика следующим идет вот этот поэтому
[01:41:18.460 --> 01:41:30.660]  тут получается 1 0 0 ну и дальше тут копипаст опять но потом идет вот тут 1 0 0 0 0 потом тут вот
[01:41:30.660 --> 01:41:36.740]  тут вот так вот один вот так сделаем потом один потом один тогда но заметить можно следующее то
[01:41:36.740 --> 01:41:41.940]  есть первое что тут в этой картинке нужно заметить так это то что каждое следующее число на самом
[01:41:41.940 --> 01:41:49.940]  деле зависит только от предыдущего каким образом да очень просто устроено оно так мы берем последний
[01:41:49.940 --> 01:41:57.860]  блок единичек вот последний единичек последний блок единичек перед ним ставим единицу а сам блок
[01:41:57.860 --> 01:42:08.180]  зонуляем понимаете да вот ну и легко на самом деле вывести то есть получается то есть что на
[01:42:08.180 --> 01:42:13.220]  самом деле здесь получается вот первое число это конечно же пос плюс один а дальше у нас
[01:42:13.220 --> 01:42:25.320]  идут числа же от пос плюс один же от же от пос плюс один там же от же от же от пос плюс один и
[01:42:25.320 --> 01:42:35.540]  тогда ли где функция же вот получается так и определена то есть я так ненот то есть можно
[01:42:35.540 --> 01:42:45.140]  так и прописывать и действительно прямо писать что g и там значит оба нот обнуляет
[01:42:45.140 --> 01:43:01.980]  то есть так на вот так находит скажем так младший блок из единичек из единичек
[01:43:01.980 --> 01:43:16.020]  ставит один перед ним вот а сам блок обнуляет
[01:43:16.020 --> 01:43:32.380]  вот ну и легко коня нот то есть это вот это я говорю определение функции же ну и конечно же
[01:43:32.380 --> 01:43:41.020]  утверждение автоматически возникает что ж ты равно на самом деле и или и минус 1 то есть что
[01:43:41.020 --> 01:43:46.540]  теперь делает или минус один берет последние нолики но перед младшей единичкой и их
[01:43:46.540 --> 01:43:52.460]  объединить вы понимаете да а потом то есть тут получается 1 1 1 а потом чтобы это обнулить и
[01:43:52.460 --> 01:44:01.300]  тут единичку поставить надо просто один прибавить вот поэтому здесь надо и или и минус 1 и все это
[01:44:01.900 --> 01:44:15.700]  вот ну в принципе на самом деле вот мы уже и практически разобрались действительно то есть
[01:44:15.700 --> 01:44:30.220]  почему этот код вообще работает вот вот это ну значит но так а потому что смотрим значит
[01:44:30.260 --> 01:44:40.780]  после меня какое-нибудь число и равно там бла бла бла там 0 0 0 1 1 0 0 0 там 0 1 1 1 1 1 1 и 0 0 0 тогда
[01:44:40.780 --> 01:44:50.020]  замечаем что и минус 1 это что такое это абсолютно то же самое только последний единичка обнулена
[01:44:50.020 --> 01:44:59.780]  а перед ней а после нее все нолики объединить когда я делаю и или и минус 1 то получается
[01:44:59.780 --> 01:45:09.780]  значит вот до этого момента копипаста прям честная 1 1 1 1 да 0 0 0 0 0 1 1 вот а здесь везде
[01:45:09.780 --> 01:45:18.180]  написано единиц но вот но теперь получается если я к этому прибавлю один то получается как раз
[01:45:18.180 --> 01:45:24.860]  вот что как бы весь этот блок получается вот обнуляется тут ставится единичка тут ставится
[01:45:24.860 --> 01:45:38.740]  везде нолики ну и все 1 1 0 0 0 и все вот и все доказательства вот то есть принципе да то
[01:45:38.740 --> 01:45:44.340]  есть на самом деле тут часто бывает идея что такие сами формулы даже на памяти обычно не помню то
[01:45:44.340 --> 01:45:48.340]  есть я помню примерно я помню что они значит а тогда если вы уже помните то обычно вы уже
[01:45:48.340 --> 01:46:00.140]  достаточно быстро там конкретные там md or и вы уже можете вывести вот так что можно но в принципе
[01:46:00.140 --> 01:46:06.260]  вот смотрите так но тем более как бы достаточно очевидно что каждый из этих фориков очевидно
[01:46:06.260 --> 01:46:11.900]  работает за логарифом правда ну точнее даже не за логарифом а вот там преб вот этот будет
[01:46:11.900 --> 01:46:18.660]  работать за количество единичных бит в числе 1 ну вот ну пост конечно тут работает за что-то
[01:46:18.660 --> 01:46:24.340]  менее там за что-то менее тривиальное он будет работать за там за сколько он там будет работать
[01:46:24.340 --> 01:46:35.700]  но так ну так количество нулей да да кроме да если отсечь лидирующие только там теми которые в
[01:46:35.700 --> 01:46:43.420]  которых укладывается да да еще не учитывать вот эти нули в конце но вот но суть одна это как
[01:46:43.420 --> 01:46:50.300]  бы логарифом но при этом логарифом такой с очень быстрой константой по факту чего
[01:46:50.300 --> 01:47:00.900]  но потому что как бы если вы пост там ну скажем так если бы если у вас пост плюс один окажется
[01:47:00.900 --> 01:47:08.260]  в два раза больше то работать оно будет примерно столько потому что нет просто нули в конце никогда
[01:47:08.260 --> 01:47:16.100]  не обрезается то есть у вас все потому что код работает за сколько то есть фактически за то есть
[01:47:16.100 --> 01:47:21.220]  как бы смотрите то есть вы там берем последний блок берем вот этот нолик да вот по сайте вот
[01:47:21.220 --> 01:47:25.540]  начало по сути начинает с этого момента сколько тут ноликов встретится пока он не превосходит
[01:47:25.860 --> 01:47:36.980]  за столько он и будет работать поэтому вот эти нолики не принципиально вот то есть там условно
[01:47:36.980 --> 01:47:44.940]  но так же получается вот такая красота то есть если так вот код фантастически минималистичен
[01:47:44.940 --> 01:47:50.540]  единственное только что тут написано какая-то магия но то магию можно либо выучить либо что
[01:47:50.540 --> 01:47:59.540]  еще лучше запомнить откуда наберется вот но впрочем на самом деле эту магию можно применять и
[01:47:59.540 --> 01:48:07.620]  дальше потому что так мы написали код заявив что значит у нас операция коммутативно и обратимо
[01:48:07.620 --> 01:48:22.580]  вот понятно да вот но на самом деле можно что что
[01:48:22.580 --> 01:48:32.700]  нет коммутативности мы пользовались вот здесь то есть еще раз подчеркиваем здесь это коммутативность
[01:48:32.700 --> 01:48:38.420]  принципиально почему потому что мы пользуемся мы здесь говорим так что допустим у нас там есть
[01:48:38.420 --> 01:48:48.100]  какой-нибудь полу интервал от я знаю там 64 до там до 115 вот в нем по полкам 79 элемент которому
[01:48:48.100 --> 01:48:54.860]  надо прибавить 5 тогда мы пользуемся тем что тогда если мы прибавили к 79 элементу 5 то вот
[01:48:54.860 --> 01:49:01.220]  эта сумма 64 по 115 тоже увеличится на 5 причем абсолютно неважно то есть можно и там в самом
[01:49:01.220 --> 01:49:08.540]  конце это 5 добавить то есть ровно в этом месте мы пользуемся коммутативностью то есть как только
[01:49:08.540 --> 01:49:14.780]  операция перестанет быть коммутативной вот уже эта функция начинает соответственно ее полномочия
[01:49:14.780 --> 01:49:27.380]  ну короче все вот поэтому приходит но поэтому и так то есть если прямо точь хочет то есть поэтому
[01:49:27.380 --> 01:49:32.780]  если мы убираем коммутативности обратимость то по идее вот весь этот код хоть он конечно и
[01:49:32.780 --> 01:49:35.540]  фантастически хорош приходится его убирать
[01:49:35.540 --> 01:50:04.340]  вот да значит тут у нас место тысячи но определение f и g я никуда девать не буду
[01:50:05.340 --> 01:50:19.940]  вот значит тут вот так а ну давайте вот это я все тоже все это доказательство я уберу
[01:50:19.940 --> 01:50:38.980]  и вот вместо этого вот f и g я оставлю f и g я оставлю вот но оказывается что если я очень
[01:50:38.980 --> 01:50:45.380]  хочу чтобы у меня операция была ассоциативно а писать я хочу все равно что-то подобное то
[01:50:45.380 --> 01:50:51.300]  оказывается я неожиданно введу себе просто скажу что мне просто нужно вместо одного массива ввести
[01:50:51.300 --> 01:51:00.140]  два то есть я сохраню себе массив тф от одного до n где у меня нот инвариант у меня будет
[01:51:00.140 --> 01:51:16.100]  абсолютно тот же то есть вот f а еще я введу tg коммутативность и обратимость мы теперь что
[01:51:16.100 --> 01:51:19.620]  говорим что пусть у нас операция только ассоциативно как бы есть подозрение что
[01:51:19.620 --> 01:51:25.060]  если у нас операция не ассоциативно то вообще честно говоря непонятно а что с ней можно делать
[01:51:25.060 --> 01:51:34.060]  ну да да вот да в тупую слева направо а можно ли с ней делать что-то в тупую это надо тоже
[01:51:34.060 --> 01:51:44.580]  еще какие-то свойства знать понимаете какое мо я мо что это что делает мо мо значит говорить
[01:51:44.580 --> 01:51:49.500]  что вот у вас есть подотрезок и вы умеете там допустим сдвинуть указатель туда-сюда и что-то
[01:51:49.500 --> 01:52:05.700]  дополнить да но обычно это уже операция требует от вас ассоциативности это каким образом это
[01:52:05.700 --> 01:52:26.540]  типа предпочитывать прям явно медиатрески что ли а ну откатываем и мой но может быть ну ладно там
[01:52:26.540 --> 01:52:33.500]  можно отдельно покопать вот там всякое такое можно делать но но в нашем случае значит будем
[01:52:33.500 --> 01:52:42.220]  делать так мы введем тф то есть введем тф с тем же определением и введем еще тж тж и т на
[01:52:42.220 --> 01:52:57.020]  этот раз будет равно быть на полу интервале от а до и бум бум же от и вот такую штуку я введу
[01:52:57.020 --> 01:53:10.700]  вот ну там отдельные но вот но то что у нас как всегда в ассистент два момента во-первых
[01:53:10.700 --> 01:53:16.700]  если у нас изменится вот или элемент вот например хотя бы вот таким образом хотя это неважно как то
[01:53:16.700 --> 01:53:24.660]  во-первых как теперь обновлять тф и тж а во-вторых и чем нам это поможет в нашей великой миссии поиска
[01:53:24.980 --> 01:53:44.100]  ну не суммой а ну идти но на самом деле вот как же нам это поможет но на самом деле магия тут
[01:53:44.100 --> 01:53:52.900]  будет очень простая то есть то есть начнем с того как искать сумму там давайте как всегда пишем
[01:53:52.900 --> 01:54:13.940]  быть он сегмент там и ты интер вот значит моя 5 t элемент начит преф равно там ты элемент
[01:54:13.940 --> 01:54:19.180]  пум пум пум пум empty segment
[01:54:19.180 --> 01:54:33.540]  но вот t элемент сув тоже равно t элемент
[01:54:33.540 --> 01:54:37.900]  значит empty segment
[01:54:37.900 --> 01:54:56.500]  значит смотрите и будет у меня работать так for так хотя я так скажу ладно для красоты и
[01:54:56.500 --> 01:55:05.420]  лучшего там может быть адекватного понимания что происходит значит суффикс я буду называть
[01:55:05.420 --> 01:55:21.820]  зелененьким а префикс красненьким ну да начнем да начнем зелененького
[01:55:31.460 --> 01:55:32.820]  я буду писать f от
[01:55:32.820 --> 01:55:59.700]  а по но вот то есть что я делаю то есть когда мне приходит какой-то подотрезок
[01:55:59.780 --> 01:56:10.380]  вот мне вот допустим подотрезок или то я делаю так то есть я тут нахожу какие-то полы там то есть
[01:56:10.380 --> 01:56:18.420]  я нахожу тут условно полу интервалы по f вот некие там полу интервалы и для них беру ответ но
[01:56:18.420 --> 01:56:22.740]  в какой-то момент обнаруживается что мне очередной полу интервал заходит за пределы
[01:56:22.860 --> 01:56:30.260]  видно да то есть мне остался вот этот префикс как я его насчитываю предельно тупо
[01:56:30.260 --> 01:56:58.100]  вот то есть просто идея такая я начинаю с этого или просто беру и беру вот этими
[01:56:58.100 --> 01:57:08.660]  иду полу интервалчиками пока не дойду до вот этого места стыка все то есть получается
[01:57:08.660 --> 01:57:15.660]  на префиксе насчитано и получается мне остается только написать там префикс по идти с суффиксом
[01:57:15.660 --> 01:57:30.940]  вот то есть вот такой не сильно сложный код
[01:57:30.940 --> 01:57:55.380]  но возникает вопрос какой нет почему-то нет почему тф и тж мы в явном виде определили
[01:57:55.380 --> 01:58:07.140]  нет функция ф и ж абсолютно те же что были раньше вот да то есть конечно конечно это
[01:58:07.140 --> 01:58:12.500]  функция работает в одном жестком предположении что когда мы тут пошли отель попа вот же то есть
[01:58:12.500 --> 01:58:17.540]  и же отыжатый то утверждает что мы обязательно в какой-то момент уткнемся именно в то место
[01:58:17.540 --> 01:58:24.980]  где мы остановились в эрке ну точнее так если эрка остановилась в эрке то в общем-то все
[01:58:24.980 --> 01:58:32.060]  очевидно правда вот если она остановилась потом то есть где-то раньше тот утверждает
[01:58:32.060 --> 01:58:52.580]  что когда мы скачем из эльпожи то мы уткнемся ровно в нее чего с ипожи
[01:58:52.580 --> 01:59:09.100]  чего не обратная но вот но вот нам почему-то так захотелось определение такое вот ну как
[01:59:09.100 --> 01:59:22.620]  вы чего с обратной функции сложно потому что по f отывы и однозначно не восстановить нет есть нет
[01:59:22.620 --> 01:59:28.020]  чего если оно сойдется и у вас массивы корректно определены ровно вот так то тогда сумма очевидна
[01:59:28.020 --> 01:59:35.380]  почему потому что как бы нет это очевидно вопрос как бы почему оно схлопнется вот
[01:59:49.380 --> 01:59:55.320]  да может и может и сразу перепрыгнуть пожалуйста но тогда утверждает что если вот мы увеличим
[01:59:55.320 --> 02:00:00.200]  р на 1 ну потому что подотрезок превратили в полу интервал если после этого выяснилось что там f от
[02:00:00.200 --> 02:00:09.040]  r меньше чем a то значит в последовательности lg от lg от g это ли встретится это число и да то есть
[02:00:09.040 --> 02:00:20.960]  вот такое вот такое я утверждаю почему я это утверждаю а потому что я утверждаю что никакие
[02:00:20.960 --> 02:00:30.480]  два из этих отрезков не пересекаются ну полу интервалов а вот этих вот смотрите вот у нас
[02:00:30.480 --> 02:00:38.260]  тут 2 и минус один отрезок какой-то да так вот я утверждаю что любые два из этих отрезков либо
[02:00:38.260 --> 02:00:45.140]  не пересекаются то есть просто вообще нет общих элементов либо один из них вложен в другой
[02:00:50.960 --> 02:00:58.560]  почему я это утверждаю можно рассмотреть это двумя способами но во первых заметим
[02:00:58.560 --> 02:01:06.040]  ночью потому что на самом деле это мягко говоря не совсем произвольного вида отрезки потому что
[02:01:06.040 --> 02:01:11.800]  на самом деле я утверждаю что это отрезки каждый из этих отрезков что зеленый что красный устроен
[02:01:11.800 --> 02:01:22.200]  так вы берете какое-то число битовое точнее берете какой-то префикс битового числа вот и
[02:01:22.200 --> 02:01:30.520]  начиная с какого-то момента говорите что вот вот эти биты можно заполнять как угодно так вот
[02:01:30.520 --> 02:01:38.360]  я утверждаю что все полу интервалы выглядит именно так ну что я имею в виду вот действительно
[02:01:38.360 --> 02:01:44.760]  давайте допустим вот про атеф разберемся да то есть есть у меня и равно допустим там 0 0 0 1 1 1 0 там
[02:01:44.760 --> 02:01:59.880]  0 0 0 там 1 1 1 1 1 0 0 да тогда кто лежит в полу интервале f от и до и кто там лежит там лежат
[02:01:59.880 --> 02:02:12.280]  все числа у которых префикс 0 0 0 1 1 1 0 0 0 1 1 1 1 и тут 0 а вот тут что угодно вот прям в
[02:02:12.280 --> 02:02:23.000]  точности эти числа правда вот а теперь как устроенные а теперь давайте как устроен полу
[02:02:23.000 --> 02:02:37.960]  интервал а ци да же но здесь на самом деле тоже самое только граница вот здесь но то есть я так
[02:02:37.960 --> 02:02:49.880]  вот ну да то есть здесь на самом деле мы видим что здесь числа 1 1 1 0 0 0 0 1 1 1 1 1 только на этот
[02:02:49.880 --> 02:02:56.200]  раз тут один а тут вопросики ну потому что следующие за этим блоком это как раз вот число
[02:02:56.200 --> 02:03:03.160]  один и тут 0 0 0 это есть же правда то есть видите то есть для каждого числа и получается есть вот
[02:03:03.160 --> 02:03:09.080]  полу интервал где то есть как бы допустим есть число и который делится на 8 но не делится на 16
[02:03:09.080 --> 02:03:16.640]  наном случае да то можно заметить что полу интервал то у нее слева полу интервал который
[02:03:16.640 --> 02:03:24.080]  который длины 8 да и справа то есть полу интервал который начинается и который тоже длины 8 то
[02:03:24.080 --> 02:03:33.920]  есть такая симметрия получается да вот понимаете да вот да нет наверное вот кстати отдельная
[02:03:33.920 --> 02:03:40.520]  песня так как делать спуск подъем дерева фенрика если вы не понимаете как дерево фенрика устроен да
[02:03:40.960 --> 02:03:49.340]  придется понимать вот но тогда но думаю достаточно очевидно да что любые два подобного
[02:03:49.340 --> 02:03:55.760]  рода отрезка они либо не пересекаются либо вложены правда то есть чтобы потому что чтобы
[02:03:55.760 --> 02:04:00.760]  отрезки пересекались нужно чтобы там как бы один из префиксов был префиксом другого префикса
[02:04:00.760 --> 02:04:08.240]  правда вот и тогда это вложенность вот в принципе да уже из этого следует что вот это вот штука он
[02:04:08.240 --> 02:04:15.600]  сегмент уже работает но остается только один маленький вопрос а как собственно а если вот
[02:04:15.600 --> 02:04:24.920]  у нас элемент изменился то как tf и tg обновлять но на самом деле да вот эти редкие случаи когда
[02:04:24.920 --> 02:04:30.280]  я тут мог вам показать презентацию но не буду этого делать потому что презентация бы на
[02:04:30.280 --> 02:04:35.920]  самом деле из этого вывела как ну потому что презентация было бы написано так что ну заметим
[02:04:35.920 --> 02:04:45.360]  да что эту задачу что теперь вот там найти пересчитать все эти суммы можно за нет хотя нет
[02:04:45.360 --> 02:04:52.480]  начать нужно с другого надо начать с того что ну во первых надо научиться как-то в tg искать
[02:04:52.480 --> 02:05:01.800]  все или имеют там все полу интервалы которые этот пост задействует как это сделать вот ну
[02:05:02.480 --> 02:05:08.160]  но на самом деле там можно так по секрету скажу да можно показать что для того чтобы вот
[02:05:08.160 --> 02:05:12.360]  понятия вот в tf чтобы найти все полу интервала надо было начиная с пост плюс один скакать
[02:05:12.360 --> 02:05:18.760]  жешками да ну в tg на самом деле тоже надо начинать способ на самом деле просто скакать
[02:05:19.360 --> 02:05:26.760]  то есть можно показать что это работает да но надо и так и там и тут скакать и тут скакать да
[02:05:26.760 --> 02:05:37.640]  вот нету я скажу так тупая то значит опять тупая идея номер раз если вы нашли все
[02:05:37.640 --> 02:05:42.800]  полу интервалы на которые тут надо все менять и мы еще и видим что этих полу интервалов там
[02:05:42.800 --> 02:05:53.360]  от логарифма то тогда эту операцию можно выполнить за лог квадрат но потому что каждый полу интервалы
[02:05:53.360 --> 02:05:59.280]  просто можем в тупую пересчитать то есть если мы там поменяли элементы значит считаем от считаем
[02:05:59.280 --> 02:06:03.600]  то что справа вот с помощью этой функции считаем то что слева с помощью этой функции понимаете
[02:06:03.600 --> 02:06:17.200]  да и получается лог квадрат все уже магия пошла начать и первая идея вот задача найти все полу
[02:06:17.200 --> 02:06:23.640]  интервалы в тф и в теже которые содержат заданное число поз в тф уже научились таки искать да но
[02:06:23.640 --> 02:06:30.080]  вот значит поверим теперь в магию поверим в то что в теже не ищутся как что числа нужны и равный
[02:06:30.080 --> 02:06:36.760]  поз f от поса f от поса так далее ну давайте так в качестве упражнения там просто буквально так
[02:06:36.760 --> 02:06:43.640]  же рассуждать я просто не хочу время на это тратить а так просто вот но вот то есть просто
[02:06:43.640 --> 02:06:49.120]  поверьте что вот так и так получается что мы нашли логарифм отрезков здесь логарифм отрезков
[02:06:49.120 --> 02:06:56.040]  здесь которые нужно поправить да тогда идея такая а давайте каждый из этих отрезков поправим
[02:06:56.680 --> 02:07:03.320]  ну потому что жил был какой-нибудь вот этот вот подотрезок несчастный там допустим и же от
[02:07:03.320 --> 02:07:10.640]  и в котором он случайно выпал поз который поменялся но тогда идея такая давайте вот у него есть в
[02:07:10.640 --> 02:07:16.200]  этом полу интервале есть то что слева от поса есть то что справа так вот давайте в ту пулю вычислим
[02:07:16.200 --> 02:07:21.680]  сумму здесь и здесь она будет вычисляться с помощью полу интервалов который пост не задели поэтому
[02:07:21.680 --> 02:07:28.520]  как бы там все корректно и тогда получается мы научились делать это за лог квадрат но
[02:07:28.520 --> 02:07:42.160]  ты это же поменяли но это вот понятно да нет пост нет туда пост не попадает как раз потому
[02:07:42.160 --> 02:07:51.080]  что мы в явном виде находим все такие и у которых вот в этот отрезок пост попадает
[02:07:51.080 --> 02:08:01.480]  мы это делаем что и равно пост f от пост f от f от пост и так далее да мы пока оставили
[02:08:01.480 --> 02:08:05.600]  без доказательства тот факт что это так но вот просто предлагается в качестве упражнений убедиться
[02:08:05.600 --> 02:08:14.720]  что это так вот вот и тогда предлагается просто то есть все такие подотрезки мы в явном виде
[02:08:14.720 --> 02:08:19.800]  нашли и тогда на каждом подотрезке предлагается за логарифм сумму обновить вот таким образом то
[02:08:19.800 --> 02:08:25.840]  есть вычислить то что слева от поса вычислить то что справа от поса и перемножить но через
[02:08:25.840 --> 02:08:36.200]  вот этот вот новый x вот понятно да ну потому что мы знаем что мы не более чем за логарифм
[02:08:36.200 --> 02:08:45.200]  отн операции вот в этой последствии наткнемся на 0 вот то есть получается в теже мы все поменяли
[02:08:45.200 --> 02:08:50.840]  за логарифм в тф мы делаем тоже самое потому что в тф мы перебираем там и равно там пост плюс
[02:08:50.840 --> 02:08:57.920]  один там же от пост плюс один же от пост плюс один и так далее там их тоже логарифм понятно да так
[02:08:57.920 --> 02:09:04.800]  вот этот момент сейчас понятен да но вот а дальше вы хорошо а можно ли этот лог квадрат заменить
[02:09:04.800 --> 02:09:12.760]  на лог то есть можно не то что у нас чтобы то есть как-то все-таки все эти отрезки все-таки
[02:09:12.760 --> 02:09:22.560]  за суммар на лог пересчитывать и не за каждый залог по отдельности но идея на самом деле предельно
[02:09:22.560 --> 02:09:28.200]  тупая конечно можно потому что дело в том что заметим следующий шут рассмотрим вот эти красные
[02:09:28.200 --> 02:09:35.240]  отрезки которые мы обновляем да тогда дело в том что каждый следующий является над интервалом
[02:09:35.240 --> 02:09:40.480]  предыдущего правда они же нас помните либо не пересекаются либо один вложен в другой правда
[02:09:40.480 --> 02:09:49.280]  они все пересекаются по посту значит вложены но тогда идея такая я утверждаю что если полу один
[02:09:49.280 --> 02:09:57.240]  полу интервал вложен в другой то тогда можно то тогда на самом деле вот от этой границы можно
[02:09:57.240 --> 02:10:04.960]  вот если это граница l то тут можно вот идти то есть последуясь вот это вот f отель f от f отель
[02:10:04.960 --> 02:10:11.200]  и тогда мы рано или поздно обязательно наткнемся на вот эту границу почему потому что если мы ее
[02:10:11.200 --> 02:10:16.800]  проскочим то тогда это будет означать что вот эти полу интервалы пересеклись пересеклись но не
[02:10:16.800 --> 02:10:27.040]  вложились а такого не бывает понимаете да так что-то уже мертвые какие-то после где где я
[02:10:27.040 --> 02:10:34.200]  начал черную магию рассказывать или да или просто это называется да наступил снег приближается
[02:10:34.200 --> 02:10:40.680]  но я бы все мертвые там и так далее я просто если я бы может я может мне надо чуть поподробнее
[02:10:40.680 --> 02:10:48.720]  рассказывать я там это слишком преувеличивает то что вы все знаете там нет смотрите а я пока еще не
[02:10:48.720 --> 02:10:54.560]  договорил я пока только сказал идею что вот у меня есть вот этот отрезок есть следующий да тогда
[02:10:54.560 --> 02:10:59.240]  утверждаю что если я вот из левой границы вот этого отрезка поскочу по f ком то я наткнусь на
[02:10:59.240 --> 02:11:06.920]  вот эту границу почему потому что если я проскочу мимо то будут пересекающиеся отрезок но более
[02:11:06.920 --> 02:11:13.120]  того заметим что я и здесь могу на самом деле вот скакать вот если это у меня то я могу здесь
[02:11:13.120 --> 02:11:22.280]  скакать тоже буду скакать пожежком на самом деле жет там же джетер и так далее и тогда я нот
[02:11:22.280 --> 02:11:28.160]  и тогда и тогда на пусть тоже провода по той же причине наткнуть на эту границу то есть получается
[02:11:28.160 --> 02:11:33.320]  чтобы найти сумму следующего отрезка, я должен взять сумму предыдущего отрезка и тут подомножать
[02:11:33.320 --> 02:11:38.240]  ее слева на какие-то скачки и справа на какие-то скачки. Но у меня суммарно здесь скачков будет
[02:11:38.240 --> 02:11:44.160]  логорифом и здесь суммарно скачков логорифом. Поэтому в сумме поймем, по волочи, что логориф.
[02:11:44.160 --> 02:11:49.960]  Потому что тогда будут, вот допустим, мы вот здесь неожиданно взяли и перепрыгнули,
[02:11:49.960 --> 02:11:54.680]  тогда вот этот полуинтервал и этот полуинтервал пересекаются, но не вложены.
[02:11:54.680 --> 02:12:05.840]  А как мы уже убедились ранее, такого не бывает. Ну, предположили, что мы начали
[02:12:05.840 --> 02:12:10.440]  где-то внутри полуинтервала, скакнули на g, а g оказалась вне полуинтервала.
[02:12:10.440 --> 02:12:21.120]  Но это и есть как раз пересечение, но не вложенность. Ну, по сути, да. То есть
[02:12:21.120 --> 02:12:47.080]  пересчитывать так, что вот таким единым образом. Вот. Можно. Но я так скажу. Ну вот,
[02:12:47.080 --> 02:12:50.880]  на самом деле, нет, я вам так скажу. Нет, я мог бы вам сейчас открыть презентацию,
[02:12:50.880 --> 02:12:57.280]  показать, какой там код получается. Ну, приличный такой. Ну, по объему уж точно не меньше
[02:12:57.280 --> 02:13:05.880]  деревоотреск, а то и больше дальше. Вот. Но на самом деле, но вот, но это надо мне сейчас
[02:13:05.880 --> 02:13:12.880]  экран доставать там и так далее. А во-вторых, на самом деле, если вглядеться в это дерево
[02:13:12.880 --> 02:13:18.880]  более внимательно, то можно писать сильно более простой код. То есть давайте на эти интервалы
[02:13:18.880 --> 02:13:25.560]  вглядимся еще более внимательно. Что такое более внимательно? А давайте их тупо нарисуем. Смотрите.
[02:13:25.560 --> 02:13:32.560]  Потому что на самом деле, да, видите, мы тут не случайно заметили, что видите, и то есть как бы
[02:13:32.560 --> 02:13:39.160]  длинные полуинтервалов от f от i до i и от i до g от i, они почему-то вообще одинаковые, да? И равны
[02:13:39.160 --> 02:13:45.640]  они максимальной степени двойки, на которую делится и правда. А давайте сейчас я вот так вот
[02:13:45.640 --> 02:14:01.320]  сейчас я предположу, что n равно 16 и тупо их нарисую. Да даже не перевернута. Нет, я буду рисовать
[02:14:01.320 --> 02:14:08.800]  так, что даже не перевернута. Смотрите. Вот я тут не случайно ввел зеленые красные цвета. Смотрите.
[02:14:08.800 --> 02:14:16.920]  То есть давайте начнем с полуинтервала в длины... Все полуинтервалы у нас степень двойки, но давайте
[02:14:16.920 --> 02:14:21.240]  начнем с полуинтервала в длины один. Что это за полуинтервалы? Это, конечно, полуинтервалы,
[02:14:21.240 --> 02:14:29.320]  когда берутся из и нечетных, правда. И получается примерно так, смотрите. То есть получается 0,1
[02:14:29.320 --> 02:14:36.000]  значит там, но я потом красненьким нарисую. Значит 2,3, ну, зелененькие интервалы. Это, конечно, те,
[02:14:36.000 --> 02:14:40.120]  которые у меня из ТГ взялись, красеньким я буду рисовать то, что взялось из ТГ.
[02:14:40.120 --> 02:15:01.120]  4, 5, 6, 7, значит 8, 9, 10, 11, 12, 13, 14, 15. Вот, то есть длины 1 из f берутся вот
[02:15:01.120 --> 02:15:17.320]  такие, а кто берется из жешек? Из жешек на самом деле берутся 1, 2, 3, 4, 5, 6, 7, 8, 9,
[02:15:17.320 --> 02:15:37.880]  10, 11, 12, 13, 14, 15, 16. Вот, это были полуинтервалы длины 1. Да, то есть я их просто так
[02:15:37.880 --> 02:15:42.640]  нарисовал, но потому что мне это интересно графически их так нарисовать. Как выглядят
[02:15:42.640 --> 02:15:48.960]  полуинтервалы длины 2? Они берутся из тех и, что которые делятся на 2, но не делятся на 4,
[02:15:48.960 --> 02:16:07.240]  правда? И получается следующее, то есть 0, 2, ой, так тут мимо, 2, 3, 3, 0, 2, 4, 6, 8, 10,
[02:16:07.240 --> 02:16:27.560]  у нас еще 12, 14. Так, ну и красненькие соответственно 2, 4, 6, 8, 10, 12 и вот тут еще 4, 16.
[02:16:27.560 --> 02:16:38.080]  Вот, значит, тут получается 0, 4, дальше для отрезков длины 4 они получаются 0,
[02:16:38.080 --> 02:16:51.480]  4, 8, 12 и получается 4, 8, 12, 16. Вот, ну здесь сверху окажется уже просто 8, 16,
[02:16:51.480 --> 02:17:03.680]  ну вот и зелененький, конечно, 0, 8 и, конечно же, здесь 0, 16. Так, ну оказывается, если n
[02:17:03.680 --> 02:17:08.440]  степень двойки, то оказывается у нас тут в этих двух массивах хранится просто дерево отрезка в
[02:17:08.440 --> 02:17:17.800]  явном виде. Вот видно, да? Ну вот, то есть более того, кстати, есть еще и альтернативное
[02:17:17.800 --> 02:17:23.160]  определение функции f и g, кстати, которые тоже иногда полезно знать, потому что вот я вот написал
[02:17:23.160 --> 02:17:31.080]  такой код, но часто его пишут через какую-то тильду. Да, кто пишет дерево отрезков через тильду? Твой,
[02:17:31.080 --> 02:17:42.760]  дерево Фенрика. Да, ну вот, да, не все. Просто идея такая, просто можно на самом деле ввести такое
[02:17:42.760 --> 02:17:51.880]  определение. Можно ввести функцию h, где сказать, что h от i — это такое максимальное, значит,
[02:17:51.880 --> 02:17:59.760]  2 в степени лен, такое, что i делится на 2 в степени лен. То есть максимальная степень двойки,
[02:17:59.760 --> 02:18:11.000]  на которой i делится. Тогда автоматически возникает утверждение, что на самом деле f от i — это всего
[02:18:11.240 --> 02:18:25.800]  и минус h от i. Вот, а g от i — это равно и плюс h от i. Вот, кстати, да, полуинтервальная логика,
[02:18:25.800 --> 02:18:30.680]  кстати, имеет преимущество именно такое, что в этом случае тогда имеется иду симметрия.
[02:18:30.680 --> 02:18:39.680]  Ну, несложно в этом убедиться, я думаю, по определению, правда? То есть можно про f и g,
[02:18:40.160 --> 02:18:45.920]  ввести те определения, а можно сразу сказать вот эти, просто из деревоотресков. По факту,
[02:18:45.920 --> 02:18:51.400]  на самом деле, да, то есть там дерево Фенрика говорит нам, что если операция коммутативная
[02:18:51.400 --> 02:18:55.800]  ассоциативно, то нам на самом деле от деревоотресков нужны только вот эти зеленые половинки.
[02:18:55.800 --> 02:19:04.240]  Вот, или вот, если у вас там была бы задача, например, вот классическая задача, вот тут
[02:19:04.240 --> 02:19:09.680]  произносится словосочетание «магическая спуск по дереву Фенрика», то давайте вспомним,
[02:19:09.680 --> 02:19:13.800]  да, вот классику деревоотресков, потому что где-то примерно второй или третий
[02:19:13.800 --> 02:19:20.080]  задачей на деревоотресков обычно рассматривается какая задача? Да, каты, да, каты, там, каты нолик,
[02:19:20.080 --> 02:19:25.000]  или лучше, каты единичка нам удобнее будет. То есть представьте себе, то есть у нас есть
[02:19:25.000 --> 02:19:30.640]  массивчик из нулей единиц. Нам нужно уметь, во-первых, там заменять там нолик на единичку,
[02:19:30.640 --> 02:19:38.920]  единичку на нолик, а также дано число k, найдите k-ту единичку. Как мы эту задачу решаем? Ну,
[02:19:38.920 --> 02:19:45.000]  во-первых, мы сначала идем вот в этот элемент и говорим, так, если там меньше, написано «меньше
[02:19:45.000 --> 02:19:50.200]  чем k», значит, говорим ответ там просто –1, там low solution, в общем, ругаемся там так, как нам
[02:19:50.200 --> 02:19:58.680]  описано в условии. Но если тут k хотя бы единиц есть, но мы думаем, а эти k единиц есть в левой
[02:19:58.680 --> 02:20:04.400]  половинке, как мы это выясняем? Мы выясняем просто идем вот сюда. Если у нас k единичек есть,
[02:20:04.400 --> 02:20:09.000]  то есть если тут число больше либо равно k, значит, остаемся в этой половине. Если их меньше k,
[02:20:09.000 --> 02:20:15.360]  то мы это число из k вычитаем и в этой половине ищем вот эту, это вот k минус вот эта вот единичку.
[02:20:15.360 --> 02:20:27.200]  Понятно, да? Так, воспомнили немножко, да? Или не воспомнили? Вот. Ну вот. Но просто тут фишка,
[02:20:27.320 --> 02:20:33.520]  здесь тоже проверяем, как бы укладывается нужная единичка здесь, если да, то идем куда-то сюда,
[02:20:33.520 --> 02:20:41.120]  если нет, то там вычитаем, идем сюда. Но замечаем, что для этого нам оказывается нужны только вот эти
[02:20:41.120 --> 02:20:56.720]  зеленые полуинтервалы. Вот так получается. Потому что, ну скажем, да, то есть утверждение мы будем
[02:20:56.720 --> 02:21:01.720]  попадать только в зеленые полуинтервалы. Доказательства. Вот пусть мы живем в очередном
[02:21:01.720 --> 02:21:06.000]  зеленом полуинтервале. Теперь, чтобы перейти на нижний уровень, мы должны отправиться в
[02:21:06.000 --> 02:21:17.600]  левую половинку и спросить. Ладно, то есть мы знаем, что ответ находится в каком-то
[02:21:17.600 --> 02:21:23.840]  полуинтервале. Ну, что зеленом, что красном. Но даже если красном. Потому что проблема в том,
[02:21:23.840 --> 02:21:28.880]  что мы теперь должны понять, теперь ответ находится в его левой половинке или в его правой половинке.
[02:21:28.880 --> 02:21:34.040]  Значит, мы отправляемся в левую половинку, то есть заведомо в зеленый полуинтервал и выясняем,
[02:21:34.040 --> 02:21:39.600]  туда надо идти или не туда. Но заметим, что вот это число нам знать даже не обязательно. Нам
[02:21:39.600 --> 02:21:44.680]  достаточно знать только зеленые. То есть отсюда следует, что этот спуск можно реально делать,
[02:21:44.680 --> 02:21:51.640]  только чисто в дереве, чисто в дереве фенгера, просто обращаясь к правильным ТФ. Я вам даже,
[02:21:51.640 --> 02:21:59.440]  даже можно сказать каким. У вас в каждый момент времени у вас полуинтервал LR есть, да? То есть там
[02:21:59.520 --> 02:22:04.200]  полуинтервал LR и на самом деле в каждом момент времени вам нужно брать просто L плюс R пополам и
[02:22:04.200 --> 02:22:13.120]  смотреть в ТФ от этого L плюс R пополам. Вот, понятно, да? Вот, единственная только оговорка,
[02:22:13.120 --> 02:22:18.680]  что N у вас должно быть все-таки степенью двойки. Но это не сильно большая проблема, потому что,
[02:22:18.680 --> 02:22:24.120]  очевидно, если там катаэлемент у вас, то есть если вы там, то есть вам заведомо изначально
[02:22:24.120 --> 02:22:29.160]  придется узнать, если у вас там катаэединичка, а если она есть, то в общем-то N вы там забабахиваете
[02:22:29.160 --> 02:22:35.800]  на степень двойки, но вам гарантируется, что там, скорее всего, там может быть, ну либо в какие-то
[02:22:35.800 --> 02:22:41.880]  неправильные, ну неверно, что вы в какие-то там неправильные ТФ не войдете, да? Потому что может
[02:22:41.880 --> 02:22:45.960]  так случиться, что там у вас будет какой-нибудь полуинтервал со степенью двойки из середины,
[02:22:45.960 --> 02:22:52.080]  ну а тебе вам придется все-таки там, серединка тоже уйдет за N. Но вы просто будете говорить,
[02:22:52.080 --> 02:22:57.000]  что если серединка уходит у вас за пределы N, то вы просто заведомо говорите, что там нужная вам
[02:22:57.000 --> 02:23:05.400]  катаэединичка заведомо есть. Вот такая идея. Так же получается, действительно, то есть это имел
[02:23:05.400 --> 02:23:10.280]  в виду под спуском по дереву Фенвика, да? Ну вот. Но правда тут, конечно, просто надо понимать,
[02:23:10.280 --> 02:23:14.800]  что дерево Фенвика это, то есть, то есть на самом деле такое дерево отрезков, которое просто чуть
[02:23:14.800 --> 02:23:20.000]  по-другому написали. То есть может быть его даже, может его придумали так, это глядя на это и
[02:23:20.000 --> 02:23:23.800]  заметив, что вот в половине случаев вам нужны только вот эти подотрески, их можно отдельно
[02:23:23.800 --> 02:23:29.160]  хранить. Потому что заметно, потому что еще можно заметить, что в каждой позиции заканчивается не
[02:23:29.160 --> 02:23:42.400]  более чем один зеленый отрез. Вот. Это была H. Это была FG. Ну вот. Так, это нот. Так что нот. Это
[02:23:42.400 --> 02:23:49.560]  было у нас такое дерево. Вот. Но правда, если у нас операция некоммутативно, то есть некоммутативно
[02:23:49.560 --> 02:23:54.440]  обратимо, то, конечно, вот эти TF, TG-шки надо обменивать. Надо менять. Но как их менять?
[02:23:54.440 --> 02:24:00.040]  Ну, очевидно, на самом деле, что вот просто вот такая структура вам просто очень красиво
[02:24:00.040 --> 02:24:04.360]  показывает, что конкретно надо менять. То есть надо просто поменять конкретный отрезок, а дальше
[02:24:04.360 --> 02:24:09.720]  прогуляться по родителям. Единственное только проблема, что раньше мы эти их хранили там как-то
[02:24:09.720 --> 02:24:17.440]  в явном виде, что мы знали, что у вершины номер В родители-то В пополам. Вот. Ну и здесь, конечно,
[02:24:17.440 --> 02:24:26.360]  у нас все немножко нот. То есть немножко как-то по-другому. Вот. Ну, для нот. Но,
[02:24:26.360 --> 02:24:32.440]  тем не менее, суть, на самом деле, можно написать абсолютно такую же. Каким образом можно это сделать?
[02:24:32.440 --> 02:24:44.280]  Вот. То есть можно это сделать так. Вот. Ну, то есть вот давайте. Вот вы говорили про код. Вот сейчас
[02:24:44.280 --> 02:24:51.920]  мы этот код и напишем. Ну, на самом деле, как можно видеть, код будет практически идентичен дереву отрезков.
[02:24:51.920 --> 02:25:01.800]  Вот.
[02:25:14.940 --> 02:25:30.440]  Вот. Значит, то есть. Значит, итак. Давайте только напишем это не как add, а собственно assign. Значит,
[02:25:30.440 --> 02:25:48.880]  пишем. Значит int, как всегда pos. И это element x. Вот. Значит, ну, можно здесь теперь сделать так.
[02:25:48.880 --> 02:25:59.320]  Введем int l равно pos, а r равно pos plus 1. То есть я буду поддерживать инвариант, что я сейчас
[02:25:59.320 --> 02:26:09.480]  нахожусь в полуинтервале lr, и у меня сейчас уже для него все предпочитано. Вот. Понятно, да? Вот.
[02:26:09.480 --> 02:26:15.400]  Значит, ну, начнем с того, что я, давайте, на самом нижнем уровне попытаюсь пересчитать. Но как мне
[02:26:15.400 --> 02:26:20.520]  пересчитать? Для этого мне нужно понять, вот, под полуинтервал lr, он зеленый или красный? Как меня
[02:26:20.520 --> 02:26:31.680]  отличить, кстати, зеленый полуинтервал от красного? Наоборот, заканчивается на нечетный. Да, ну,
[02:26:31.680 --> 02:26:38.520]  пока, да, пока полуинтервалы, да, заметим так, пока полуинтервалы, полуинтервал у нас длины 1,
[02:26:38.520 --> 02:26:45.160]  то надо просто проверить, кто у него нечетный, начало или конец. Поэтому пишем, поэтому можно,
[02:26:45.160 --> 02:26:58.280]  сейчас я тут напишу экзотическую вещь, то есть, значит, пишем r and 1, вопросик, значит, tf от r,
[02:26:58.280 --> 02:27:18.320]  твое точье tg от l равно x. Да, мало кто знает, но тардарный оператор можно и слева от знака
[02:27:18.320 --> 02:27:29.080]  присваивать. Вот, нет, ну, почему? Нет, ну, а нет, читать так надо куда-то присвоить x, куда? Ну,
[02:27:29.080 --> 02:27:39.280]  если нечетная, то вот сюда, иначе вот сюда, логично. Нет, я понимаю, да, что, скажем так, это как бы кажется
[02:27:39.280 --> 02:27:45.440]  нечитаемым, потому что это как бы не самая привычная вам конструкция. Вот, но так, в общем-то,
[02:27:45.440 --> 02:28:01.000]  ничего супер нечитаемого такого нет. Так, ну, поехали. А дальше, что мы теперь говорим? Ну,
[02:28:01.000 --> 02:28:08.120]  дальше мы говорим while, там, видимо, r-l меньше n. Так, ну, во-первых, теперь мы говорим так,
[02:28:08.120 --> 02:28:19.360]  надо теперь l-r сдвинуть, правда? Вот, ну, как сдвинуть? Ну, как теперь? Вот нам дан рандомный
[02:28:19.360 --> 02:28:29.800]  подотрезок l-r, как понять, как быть это l-r он зеленый или красный? Ох, поделить, то есть на
[02:28:30.800 --> 02:28:52.560]  времени тратить, да? Ну, что, оба, оба делятся. Ну, на самом деле, да, заметим, теперь вспомним,
[02:28:52.560 --> 02:29:02.160]  что зеленый полуинтервал это всегда полуинтервал вида там f от r, правда? А красный полуинтервал
[02:29:02.160 --> 02:29:07.880]  это полуинтервал вида l g от l. Но мы же легко можем проверить для полуинтервала l-r, если мы
[02:29:07.880 --> 02:29:14.160]  точно знаем, что он хороший, какому из этих видов он принадлежит, правда? Поэтому можно так
[02:29:14.160 --> 02:29:23.040]  сказать, начнем с зелененького случая. Если оказалось, что l равно f от r, то в этом зелененьком
[02:29:23.040 --> 02:29:30.480]  случае что мы тогда делаем? Ну вот, но тогда оказывается, что надо r сдвинуть на g, правда?
[02:29:30.480 --> 02:29:52.920]  Ну, соответственно сдвигаем. Ну, можно написать так, int значит nr, новый r равно g от r, да? Вот,
[02:29:52.920 --> 02:29:59.560]  ну и теперь надо, ну вот, ну теперь мы знаем, как вычислить сумму. Значит, сумму вычислить
[02:29:59.560 --> 02:30:11.600]  можно, как теперь получается tf от r и tg от r, правда? Но записывать теперь надо в полуинтервал вот
[02:30:11.600 --> 02:30:19.920]  этот вот l nr. Как его записать? Ну, я сейчас напишу не самый оптимальный там, конечно, код, но написать
[02:30:19.920 --> 02:30:37.840]  его можно так. То есть можно его написать l равно равно f от nr, если да, то tf от nr, если нет, то tg от l.
[02:30:49.920 --> 02:31:07.240]  Ну мы и про... Где писать? Вот здесь? Вот это? Так мы так и делали. А, ну да, в принципе, да. Ну,
[02:31:07.240 --> 02:31:15.120]  просто в данном случае мы еще и точно знаем. Вот, значит, тут получается вот так, ну а в противном
[02:31:15.120 --> 02:31:24.960]  случае получается какой-то симметричный код. Сразу пишем тут int. Там nl равно f от l, естественно.
[02:31:24.960 --> 02:31:43.600]  Вот, и там получается pum pum. Ну да, допустим, nl равно равно f от r, тогда tf от r до точки tg от nl.
[02:31:43.600 --> 02:32:01.040]  Равно tf от l и tg от l. Вот. Вот. Ну и, конечно, не забыть l равно nl.
[02:32:01.040 --> 02:32:21.240]  Чего? Ну tf слева, tg слева. Нет, тут как раз все нормально. У нас tf зеленое, tg красное.
[02:32:21.240 --> 02:32:39.640]  Так что вот такой, в общем-то, код получается. Ну ладно, вот такой. А, еще вот такой. Ну, на самом деле,
[02:32:39.640 --> 02:32:45.280]  да, деревоотреска, в общем-то, не сильно ушли. То есть по коду, в общем-то, получилось примерно
[02:32:45.280 --> 02:32:54.080]  то же самое. Только код получился даже чуть более магически. Нет, ну в принципе, да, то есть,
[02:32:54.080 --> 02:32:59.360]  ну вот. Нет, то единственное только что, как бы, тут надо внимательно посмотреть, как бы,
[02:32:59.360 --> 02:33:09.520]  насколько код, насколько такой код работает. Нет, кстати, нет, давайте внимательно. Сейчас,
[02:33:09.520 --> 02:33:13.360]  давайте, подождите, давайте подумаем. Нет, как бы, этот код гарантированно работает если
[02:33:13.360 --> 02:33:17.680]  n степень двойки. А теперь давайте подумаем, а насколько он адекватно работает, если n это не
[02:33:17.680 --> 02:33:25.600]  степень двойки. Но не совсем так работает. Потому что давайте, давайте предположим сейчас,
[02:33:25.600 --> 02:33:32.880]  давайте предположим, что n равно 11. И там полуинтервал у вас какой-нибудь там, вы меняете
[02:33:32.880 --> 02:33:39.120]  какой-нибудь там восьмой или восьмой элемент. Тогда вы поменяете 8,9, вы поменяете 8,10,
[02:33:39.120 --> 02:33:46.000]  потом попытаетесь поменять 8,12, но у вас этого полуинтервала нет. Ну вот такой вайл у нас не
[02:33:46.000 --> 02:33:56.000]  брейкается. Вот. Но на самом деле, да, можно тут, то есть допилить его можно так. То есть,
[02:33:56.000 --> 02:34:01.360]  ну на самом деле, да, как только у вас r вот в этом месте выйдет за пределы n, на самом деле вы можете
[02:34:01.360 --> 02:34:07.560]  сказать, что значит остальные полуинтервалы вас не интересуют, мы их не храним. Поэтому в принципе
[02:34:07.600 --> 02:34:19.960]  можно обнаглеть и сказать так, смотрите. Вайл труп. Нет. И тут обнаглеть заявить, что если оказалось,
[02:34:19.960 --> 02:34:34.200]  что n больше n, то вот тут бряк. Вот. Вот. Ну как бы знаете, да, любимый оператор этого, одного
[02:34:34.440 --> 02:34:40.280]  долговязого мышонка, да, знаете. Нет. Ну у него был такой мелкий такой друг,
[02:34:40.280 --> 02:34:52.080]  который пытался захватить мир. Да. Ну вот. Извали их Pinky Brain, если что. Вот. Так вот он, да. Так вот
[02:34:52.080 --> 02:34:57.000]  это долговязый там, толковязый видимо постоянно, когда ему там говорили что-то умное, он еще любил
[02:34:57.000 --> 02:35:04.960]  использовать этот оператор. Соответственно. Ну не важно. Ладно. Ладно, если вы не знаете,
[02:35:04.960 --> 02:35:12.000]  не заморачивайтесь. Не важно. Вот. Так что вот. Так что вот в принципе можно так написать и в
[02:35:12.000 --> 02:35:17.040]  принципе вот у вас и получается примерно дерево, на самом деле такое дерево отрезков, в котором вы
[02:35:17.040 --> 02:35:30.480]  храните 2n-1 элемент, а не, а не. Нет. А FL у вас как бы, а потому что при FL вот этот полуинтервал,
[02:35:30.480 --> 02:35:36.080]  скажем так, по большому счету, что такое дерево отрезок, то есть мы тут пытаемся хранить на n. То
[02:35:36.080 --> 02:35:40.280]  есть это когда мы n как бы мысленно дополнили до степени двойки, но полуинтервалы, которые требуют
[02:35:40.280 --> 02:35:45.920]  хранить не чего-то там n или больших элементов, мы просто не храним. Потому что они нам типа не
[02:35:45.920 --> 02:35:51.680]  нужны. Вот. Но очевидно, что вот. То есть здесь мы исследуем ровно те полуинтервалы, которые как бы
[02:35:51.680 --> 02:35:58.040]  нам нужны, и поэтому если у них там все индексы не больше n, значит они существуют. Поэтому здесь как
[02:35:58.040 --> 02:36:00.400]  бы FL никуда не выходит, FL не выходит за пределы нуля.
[02:36:00.400 --> 02:36:21.240]  Почему как бы, как бы сформулируем так. Это может быть написано не самым оптимальным образом,
[02:36:21.240 --> 02:36:27.520]  хотя нет. Но с другой стороны, как бы, смотрите, рекалки абсолютно такие же. Вот. С двиги, но на
[02:36:27.520 --> 02:36:32.440]  самом деле, ну почти такие же. То есть там как бы было, ну там было немножко так, то есть там
[02:36:32.440 --> 02:36:40.200]  был, правда был, нет, ну да. Но там было, да, там было, конечно, там, конечно, сильно проще находили
[02:36:40.200 --> 02:36:45.960]  родители, там одно деление на два, а тут как бы какие-то вот такие битвы, операции. Ну да. Так
[02:36:45.960 --> 02:36:52.560]  что да, пожалуй, тут может работать, конечно, чуть дольше. Вот. Ну и за эту память чуть-чуть
[02:36:52.560 --> 02:37:01.160]  экономии. Почему? Почти в два раза, между прочим. Если у вас реально n равно 2 в степени
[02:37:01.160 --> 02:37:20.360]  плюс 57, то вы сэкономили почти в два раза. Ну да, но это, видимо, придется по-другому писать,
[02:37:20.360 --> 02:37:33.160]  возможно. Чтобы не менять то же самое, у вас так не получится, потому что, как бы, допустим,
[02:37:33.160 --> 02:37:38.720]  у вас n это 2 в степени плюс 57. Тогда если вы напишете так же, но обрежете до n, то, извиняюсь,
[02:37:38.720 --> 02:37:43.760]  у вас там все верхние уровни будут как будто под большую степень двойки писали, а на нижнем
[02:37:43.760 --> 02:37:59.600]  уровне останется всего 57. А листья на разных уровнях. Ну это, в принципе, ладно. Ну хорошо,
[02:37:59.600 --> 02:38:07.360]  да, это еще можно. Допустим, да. Нет, листья надо, да. Листья, листья надо.
[02:38:07.360 --> 02:38:31.920]  Нет, ну как нет, просто в дереве отрезка говорится так, что, допустим, у нас n не 16,
[02:38:31.920 --> 02:38:51.000]  а там, допустим, 17. Нет, 17 как-то нет, не вместится. Нет, ну я не знаю, я бы сказал,
[02:38:51.000 --> 02:38:59.680]  что давайте 11. Так, ну давайте смотреть. Значит, как предлагается хранить тогда на 11?
[02:38:59.680 --> 02:39:16.600]  Ну да, нет, да, ну просто, видимо, на 11 просто, ну то есть, видимо, как-то на 11 предлагается
[02:39:16.600 --> 02:39:25.120]  идея такая. То есть, давайте выкинем все вот эти элементы, да, да. Понятно, ну вот. То есть,
[02:39:25.120 --> 02:39:32.320]  выкинем вот эти элементы и вот эти элементы. А так будем хранить вот нот. А вот эти 11
[02:39:32.320 --> 02:39:38.160]  элементов будем хранить вот примерно вот в таком массивчике. Так, так я вас понял примерно.
[02:39:56.120 --> 02:40:02.400]  А, ну нет, ну может это, а ну что прям в явном виде так хранить? Там же решила простой реализация
[02:40:02.400 --> 02:40:16.280]  неко. Нет, ну правда, нет, там просто имейте в виду, что вместо вот этого элемента на 10-12,
[02:40:16.280 --> 02:40:21.920]  то есть как бы они просто будут отвечать не за элемент 8-10, а они будут отличать за как бы
[02:40:21.920 --> 02:40:30.640]  полуинтервал 8-9, 9-10 и 10-11. Вот, а дальше тут вот объединение нот, а вот эти вот верхние
[02:40:30.640 --> 02:40:36.000]  там все объединения, да, вот этот элемент мы тоже не храним в итоге, да. Ну хотя...
[02:40:36.000 --> 02:40:47.240]  Так, сейчас подряд запишем, что? То есть, да, но тогда, видимо, придется записать,
[02:40:47.240 --> 02:41:01.200]  что запишем? Сначала вот эти элементы, потом эти или что? Ну да.
[02:41:17.240 --> 02:41:27.640]  Нет, просто тогда у нас под отрезок будет не очень удобно его распиливать, придется.
[02:41:27.640 --> 02:41:38.880]  Нет, ну то есть придется учитывать, где суффикс и где префикс.
[02:41:38.880 --> 02:41:59.440]  Ну это да, ну не знаю. Нет, вот это и магия, что получение, что там какие-то ИФы надо вставлять.
[02:41:59.440 --> 02:42:07.720]  Нет, ну хотя нет, тут вопрос, какие операции? Если операции сверху снизу, то как бы еще одно дело.
[02:42:07.720 --> 02:42:17.120]  Нет, ну там не совсем так, там, ну вопе, нет, там, во-первых, как бы ПЛР еще МИДы надо искать.
[02:42:17.120 --> 02:42:24.000]  Нет, абсолютно так же нет, тогда тут будет 0.1, там какой-нибудь отрезок будет 0.10, у него МИД
[02:42:24.000 --> 02:42:31.320]  будет там что-то делить напополам и непонятно. Так что, видимо, у нас с вами разные делаются так же.
[02:42:31.320 --> 02:42:42.200]  Так что я не знаю, что такое такое. Похоже, код видимо у меня какой-то другой, что снизу, что сверху.
[02:42:42.200 --> 02:42:47.560]  Ладно, неважно. Так, сколько сейчас времени?
[02:42:47.560 --> 02:43:15.760]  Ну понятно, понятно, так сколько времени?
[02:43:15.760 --> 02:43:25.640]  Ну понятно, окей, хорошо. Ну ладно, значит тогда, понятно, что там МИДы.
[02:43:25.640 --> 02:43:34.000]  Ну снизу, нет, ну как сказать, прикольно, скажешь так, прикольно, что так тоже можно, да.
[02:43:34.000 --> 02:43:42.680]  Не, ну почему? Ну знаете, фенвик тоже будет выглядеть как отхог какой-то, знаете.
[02:43:42.680 --> 02:43:52.720]  Не, ну как сказать, ну я не знаю, что тут придумалось раньше, но...
[02:43:52.720 --> 02:44:04.160]  Ну, типа оно возникает вследствие логичных каких-то вещей, здесь мы немножечко, вот функции будут такие, и типа...
[02:44:04.160 --> 02:44:12.000]  Нет, дерево-тешка снизу, как бы стандартная реализация, тоже понятно.
[02:44:12.000 --> 02:44:38.160]  Не, ну я боюсь, там просто, боюсь это реально работает по принципу, да, там, то есть давайте дерево-отресков храним не два в степени там элементов минус один, а только вот там...
[02:44:38.160 --> 02:44:51.760]  Ну, не обязательно даже, ну не обязательно даже китаец, но просто кто-то случайно заметил, что так работает, да.
[02:44:51.760 --> 02:45:01.280]  Да, нет, у Спарсты, конечно, более логично в том плане, что если мы хотим быстрее искать какой-нибудь минимум на отрезке, то понятно, что нам на каких-то отрезках минимум придется предподсчитать.
[02:45:01.280 --> 02:45:15.040]  Да, ну вот, поэтому там скорее всего до степени двойки видео в какой-то момент додумаетесь, потому что там получается асимптотика НЛОГН, как бы получается единица, все нормально, да, тут, ну дизджойнт из этого там допиливается, ну допиливается, короче.
[02:45:15.040 --> 02:45:19.200]  Дизджойнт это хорошее, как выглядит ЭЛБИТ, мы разделяем власту, мы типа накажем.
[02:45:19.200 --> 02:45:20.320]  Да, да, да, да, да.
[02:45:20.320 --> 02:45:21.360]  Ну да.
[02:45:21.360 --> 02:45:23.360]  Просто ее запихали всю груда.
[02:45:23.360 --> 02:45:26.320]  Ну да, нет, ну да, одна и та же, да, совершенно верно, да.
[02:45:26.320 --> 02:45:28.320]  Массив, там можно все время массив.
[02:45:28.400 --> 02:45:36.400]  Нет, ну везде тут можно заметить, что, ну ладно, ладно, давайте так, совсем прокапывать не будем, потому что на самом деле про Фенвика есть еще что рассказать, как-то не странно.
[02:45:36.400 --> 02:45:38.400]  Да, это еще, это еще.
[02:45:38.400 --> 02:45:40.400]  А, прибавление на отрезки типа?
[02:45:40.400 --> 02:45:56.400]  Ну, ну как сказать, у меня классика такая, Фенвик с прибавлением на отрезки, значит это, конечно, Фенвик Фенвиков, да, будет еще свинод, может быть даже КД-деревом у нас сейчас возникнет даже.
[02:45:56.480 --> 02:46:00.480]  Ну и конечно его величество казарский, Фенвик.
[02:46:04.480 --> 02:46:14.480]  А в том прикол, что задача, которая, ну, значит легенда, значит легенда такая, давным-давно в 2012 году, по-моему, плюс-минус, плюс-минус один, мы давали контест Петрозаводск.
[02:46:14.480 --> 02:46:16.480]  Значит, контест оказался неожиданно гробовой.
[02:46:16.480 --> 02:46:20.480]  Ну, чтобы вы понимали, в контесте было 9 задач, чемпион решил 4.
[02:46:20.480 --> 02:46:24.480]  Ну как чемпион, там две команды решили 4 задачи, а остальные 3 и менее.
[02:46:24.560 --> 02:46:30.560]  Более того, одна команда стала из двух действующих чемпионов мира, другая команда там через два года стала чемпионом мира.
[02:46:30.560 --> 02:46:44.560]  Ну, мы сильно удивились, на самом деле, потому что мы еще объясняем, что это был контест в первый день, то есть, знаете, когда с утра, в 8 утра вы вышли из поезда, в 2 часа вы уже контест пишете.
[02:46:44.640 --> 02:46:50.640]  Ну вот, потому что сейчас там современные команды, там более современные, вроде там и по 6 закрывали, и по 8 там уже нормально.
[02:46:50.640 --> 02:46:54.640]  Может, конечно, задачи уже бояными стали, но тем не менее.
[02:46:54.640 --> 02:46:58.640]  Ну вот, и там была одна веселая задача, там структура данных.
[02:46:58.640 --> 02:47:02.640]  Мы призывали, что это такая относительно сложная структура, что-то там на дикартовые деревья.
[02:47:02.640 --> 02:47:04.640]  Ну, по камере в авторском, что-то там дикартовые деревья писались.
[02:47:04.640 --> 02:47:10.640]  Но решила ее только одна команда, Казахстанско-Британского технического университета.
[02:47:10.720 --> 02:47:20.720]  Нет, университета в Алмате такой реально существует.
[02:47:20.720 --> 02:47:26.720]  И более того, мы открыли решение, ничего, кроме мапчиков и фенвичков, там не было.
[02:47:26.720 --> 02:47:30.720]  Вот, вот что с задачей.
[02:47:30.720 --> 02:47:34.720]  Ну, я могу сразу условия рассказать, и вы можете пока подумать.
[02:47:34.720 --> 02:47:36.720]  Но более того, пока скажу просто на уровне легенды.
[02:47:36.800 --> 02:47:42.800]  Потом прошло несколько лет, где-то в 2015 году я, собственно, съездил в этот вуз, провел там сборы.
[02:47:42.800 --> 02:47:44.800]  Казахстанско-Британский?
[02:47:44.800 --> 02:47:46.800]  Да. Нет, ну, в смысле, нормально там эти команды.
[02:47:46.800 --> 02:47:54.800]  Кстати, более того, я там уже в 2019 году, в принципе, то есть потом ездил на финал и встретил там, собственно, знакомые лица.
[02:47:54.800 --> 02:47:56.800]  Вот.
[02:47:56.800 --> 02:48:00.800]  Так что, ну вот, встретил, и там одной из занятий у меня было по дикартовому дереву.
[02:48:00.800 --> 02:48:04.800]  Но я там дал 9 задач на дикартовые деревья, на разборе они мне подробно объяснили,
[02:48:04.880 --> 02:48:06.880]  что мне реально нужны дикартовые деревья.
[02:48:06.880 --> 02:48:10.880]  А все остальные прекрасно решаются там, ну, не сложнее, чем деревьями отрезков.
[02:48:10.880 --> 02:48:12.880]  Там у них лог квадратный, да, симпатикой?
[02:48:12.880 --> 02:48:14.880]  Нет, причем с нормальными асимптотиками, да.
[02:48:14.880 --> 02:48:18.880]  Не, просто у дикартовых деревьев, нет, у дикартовых деревьев есть недостаток.
[02:48:18.880 --> 02:48:22.880]  В терминах дикартовых деревьев очень удобно мыслить.
[02:48:22.880 --> 02:48:24.880]  Потому что, да, то есть можно забить на дерево отрезков,
[02:48:24.880 --> 02:48:28.880]  что дикартовое дерево как бы, оно умеет делать то же самое, что дерево отрезков.
[02:48:28.880 --> 02:48:30.880]  За тот же логарифм. Правда, более жирный.
[02:48:30.880 --> 02:48:32.880]  Но тут выясняется, что конкретно нет.
[02:48:32.960 --> 02:48:34.960]  Ну, вот, что там есть конкретика,
[02:48:34.960 --> 02:48:36.960]  что можно чаще всего дикарточку не писать.
[02:48:36.960 --> 02:48:38.960]  Вот. А в данном случае, ну, вот.
[02:48:38.960 --> 02:48:40.960]  В данном случае пришлось.
[02:48:40.960 --> 02:48:42.960]  А задача такая, значит, смотрите, вот, видимо мы ее,
[02:48:42.960 --> 02:48:44.960]  значит, видимо после перерыва разберем,
[02:48:44.960 --> 02:48:46.960]  пока можете подумать. Задача такая.
[02:48:48.960 --> 02:48:50.960]  Значит, там Саша,
[02:48:50.960 --> 02:48:52.960]  да, на этот раз Саша, да, редкий случай,
[02:48:52.960 --> 02:48:54.960]  вот, но на этот раз Саша,
[02:48:54.960 --> 02:48:56.960]  вот, соответственно, собирает вещи.
[02:48:56.960 --> 02:48:58.960]  Вещи у него лежат,
[02:48:58.960 --> 02:49:00.960]  ну, вещи он собирает в энчима,
[02:49:01.040 --> 02:49:03.040]  ну, вещи он собирает в энчимаданов,
[02:49:03.040 --> 02:49:05.040]  ну, эн до 100 тысяч, естественно,
[02:49:05.040 --> 02:49:07.040]  как всегда.
[02:49:07.040 --> 02:49:09.040]  Значит, есть 100 тысяч чемоданов.
[02:49:09.040 --> 02:49:11.040]  Каждый чемодан, ну, такой,
[02:49:11.040 --> 02:49:13.040]  в каждом чемодане лежат такой
[02:49:13.040 --> 02:49:15.040]  столбик вещей.
[02:49:17.040 --> 02:49:19.040]  Так вот, запросы у него такие, ну, вот,
[02:49:19.040 --> 02:49:21.040]  причем более того, вещи тоже бывают
[02:49:21.040 --> 02:49:23.040]  одного из двухсот тысяч типов.
[02:49:25.040 --> 02:49:27.040]  Ну, там красные, зеленые, там, короче,
[02:49:27.040 --> 02:49:29.040]  200 тысяч цветов.
[02:49:29.120 --> 02:49:31.120]  Так вот.
[02:49:31.120 --> 02:49:33.120]  Значит, запросы там такие.
[02:49:33.120 --> 02:49:35.120]  Ну, да, сейчас какие там
[02:49:35.120 --> 02:49:37.120]  запросы сделать?
[02:49:37.120 --> 02:49:39.120]  Ну, по-моему, там запросы были примерно такие.
[02:49:39.120 --> 02:49:41.120]  Во-первых, первый запрос. Скажите, пожалуйста,
[02:49:41.120 --> 02:49:43.120]  сколько запросов, сколько вещей
[02:49:43.120 --> 02:49:45.120]  такого-то типа лежит сейчас в чемодане
[02:49:45.120 --> 02:49:47.120]  таком-то?
[02:49:47.120 --> 02:49:49.120]  Это первое.
[02:49:49.120 --> 02:49:51.120]  И второе.
[02:49:51.120 --> 02:49:53.120]  А, ну, вот.
[02:49:53.120 --> 02:49:55.120]  Нет.
[02:49:55.120 --> 02:49:57.120]  Нет, второй тип запроса,
[02:49:57.200 --> 02:49:59.200]  перекладывание. Ну, вам изначально сказано,
[02:49:59.200 --> 02:50:01.200]  какие вещи в каких чемоданах лежат, естественно,
[02:50:01.200 --> 02:50:03.200]  да? Так вот. А потом второй
[02:50:03.200 --> 02:50:05.200]  запрос. Значит,
[02:50:05.200 --> 02:50:07.200]  возьмите чемодан номер
[02:50:07.200 --> 02:50:09.200]  X,
[02:50:09.200 --> 02:50:11.200]  возьмите в нем
[02:50:11.200 --> 02:50:13.200]  там верхний игрок
[02:50:13.200 --> 02:50:15.200]  вещей,
[02:50:15.200 --> 02:50:17.200]  возьмите среди них все вещи
[02:50:17.200 --> 02:50:19.200]  типа С,
[02:50:19.200 --> 02:50:21.200]  и переложите их в чемодан
[02:50:21.200 --> 02:50:23.200]  типа номер X3
[02:50:23.200 --> 02:50:25.200]  наверх. Положите наверх, да.
[02:50:27.200 --> 02:50:29.200]  Да, вот такая вот вещь.
[02:50:31.200 --> 02:50:33.200]  Да, вот такая веселая.
[02:50:33.200 --> 02:50:35.200]  Да, там ограничение типа все по 100 тысяч.
[02:50:37.200 --> 02:50:39.200]  Ну, адекватный какой-то, две секунды, по-моему.
[02:50:41.200 --> 02:50:43.200]  Ну, насколько я помню, там, по-моему,
[02:50:43.200 --> 02:50:45.200]  вроде ни у кого проблем, кто
[02:50:45.200 --> 02:50:47.200]  сдавал, вы там, проблемы были не с ТЛ.
[02:50:47.200 --> 02:50:49.200]  То есть у этой команды никаких
[02:50:49.200 --> 02:50:51.200]  проблем с ТЛ не было. Но правда,
[02:50:51.200 --> 02:50:53.200]  там и все сдавалось, как выяснилось.
[02:50:53.200 --> 02:50:55.200]  А почему
[02:50:55.280 --> 02:50:57.280]  из этого ВУЗа придумал такие решения?
[02:50:57.280 --> 02:50:59.280]  Не знаю, вот я не знаю,
[02:50:59.280 --> 02:51:01.280]  поэтому вот у меня ощущение, что
[02:51:01.280 --> 02:51:03.280]  в Казахстане есть суровые казахские
[02:51:03.280 --> 02:51:05.280]  технологии, как избегать декартячих.
[02:51:07.280 --> 02:51:09.280]  Нет, нет, как сказать,
[02:51:09.280 --> 02:51:11.280]  придумали. Это какая-то сложная структура,
[02:51:11.280 --> 02:51:13.280]  которую надо, то есть она сложно,
[02:51:13.280 --> 02:51:15.280]  ее как-то надо писать и так далее, а на самом
[02:51:15.280 --> 02:51:17.280]  деле ее писать не надо.
[02:51:17.280 --> 02:51:19.280]  То есть да, как бы напрашиваюсь,
[02:51:19.280 --> 02:51:21.280]  ну да, в принципе, тут отдельная песня,
[02:51:21.280 --> 02:51:23.280]  как тут декартячих вообще придумать
[02:51:23.360 --> 02:51:25.360]  то есть какой конкретный декартяч писать
[02:51:25.360 --> 02:51:27.360]  и шоу от него надо.
[02:51:27.360 --> 02:51:29.360]  Но окажется, вот утверждается,
[02:51:29.360 --> 02:51:31.360]  что вот казахи умеют это делать то же самое
[02:51:31.360 --> 02:51:33.360]  в терминах Мапов и Федвиков.
[02:51:33.360 --> 02:51:35.360]  Вот, но как они это делают,
[02:51:35.360 --> 02:51:37.360]  мы узнаем после перерыва.
[02:51:37.360 --> 02:51:39.360]  Так, но давайте разбираться,
[02:51:39.360 --> 02:51:41.360]  как это называется, да, кто-то, возможно, даже успел
[02:51:41.360 --> 02:51:43.360]  подумать над задачей,
[02:51:43.360 --> 02:51:45.360]  но поэтому, как говорят в одном блоге, да,
[02:51:45.360 --> 02:51:47.360]  ну а теперь, когда каждый из вас составил
[02:51:47.360 --> 02:51:49.360]  свое мнение об этой задаче, мы разберем
[02:51:49.360 --> 02:51:51.360]  авторское решение.
[02:51:51.440 --> 02:51:53.440]  Вот.
[02:51:53.440 --> 02:51:55.440]  Ну ладно, не то чтобы авторское,
[02:51:55.440 --> 02:51:57.440]  не знаю, может быть авторское было не совсем
[02:51:57.440 --> 02:51:59.440]  такое, но с другой стороны, какие тут идеи вообще
[02:51:59.440 --> 02:52:01.440]  возникают?
[02:52:01.440 --> 02:52:03.440]  Можешь хранить какую-то пару, типа значение, количество.
[02:52:03.440 --> 02:52:05.440]  Ну вот, так, но да,
[02:52:05.440 --> 02:52:07.440]  но первая идея, конечно, заключается в том,
[02:52:07.440 --> 02:52:09.440]  что вещи одинакового
[02:52:09.440 --> 02:52:11.440]  типа имеет смысл хранить
[02:52:11.440 --> 02:52:13.440]  в блоках.
[02:52:13.440 --> 02:52:15.440]  Да, то есть на самом деле,
[02:52:15.440 --> 02:52:17.440]  то есть первая идея, давайте в каждой
[02:52:17.440 --> 02:52:19.440]  ящик храним в виде, ну я не знаю,
[02:52:19.520 --> 02:52:21.520]  дикартового дерева, какого-нибудь,
[02:52:21.520 --> 02:52:23.520]  то есть какого-нибудь вот
[02:52:23.520 --> 02:52:25.520]  там,
[02:52:25.520 --> 02:52:27.520]  дикартового дерева,
[02:52:27.520 --> 02:52:29.520]  в котором храним последовательность блоков.
[02:52:29.520 --> 02:52:31.520]  В каждом блоке пишем, там, какой
[02:52:31.520 --> 02:52:33.520]  тип, и там, какой тип вещей,
[02:52:33.520 --> 02:52:35.520]  и сколько этих вещей.
[02:52:35.520 --> 02:52:37.520]  Вот.
[02:52:37.520 --> 02:52:39.520]  Ну вот.
[02:52:39.520 --> 02:52:41.520]  Это во-первых.
[02:52:41.520 --> 02:52:43.520]  С начала в начало, ну из начала в конец.
[02:52:43.520 --> 02:52:45.520]  Ну я бы сказал, что,
[02:52:45.520 --> 02:52:47.520]  ну да, я бы сказал, что ящик
[02:52:47.600 --> 02:52:49.600]  будет скорее вот такой какой-то, да,
[02:52:49.600 --> 02:52:51.600]  но это не так принципиально.
[02:52:51.600 --> 02:52:53.600]  Ну что нам бы еще было
[02:52:53.600 --> 02:52:55.600]  было бы желательно? Ну как минимум было бы желательно
[02:52:55.600 --> 02:52:57.600]  ну, во-первых,
[02:52:57.600 --> 02:52:59.600]  как бы уметь пробегаться по вещам
[02:52:59.600 --> 02:53:01.600]  одного типа.
[02:53:01.600 --> 02:53:03.600]  Как это можно сделать?
[02:53:03.600 --> 02:53:05.600]  Ну, например, то есть там для
[02:53:05.600 --> 02:53:07.600]  каждой вершины хранить ссылку на
[02:53:07.600 --> 02:53:09.600]  предыдущую вершину такого же
[02:53:09.600 --> 02:53:11.600]  типа.
[02:53:11.600 --> 02:53:13.600]  Вот.
[02:53:13.680 --> 02:53:15.680]  Мы же блоки уже храним.
[02:53:15.680 --> 02:53:17.680]  Да, ну на предыдущий блок
[02:53:17.680 --> 02:53:19.680]  такого же типа. То есть на предыдущий.
[02:53:19.680 --> 02:53:21.680]  Ну, в смысле, да, но просто мы же
[02:53:21.680 --> 02:53:23.680]  блоки храним из подряд идущих вещей одного
[02:53:23.680 --> 02:53:25.680]  типа. Ну вот.
[02:53:25.680 --> 02:53:27.680]  Поэтому вот. Но теперь вот идея, что
[02:53:27.680 --> 02:53:29.680]  и... То есть при этом показать, на самом деле,
[02:53:29.680 --> 02:53:31.680]  ну, типа, просто на два назад. Почему на два?
[02:53:31.680 --> 02:53:33.680]  Потому что предыдущий блок ну кого типа?
[02:53:33.680 --> 02:53:35.680]  Нет. А у предыдущих много типов.
[02:53:35.680 --> 02:53:37.680]  Да, типа типов у нас 100 000,
[02:53:37.680 --> 02:53:39.680]  к сожалению. А то и 200 000, так что увы.
[02:53:39.680 --> 02:53:41.680]  Вот. То есть тут храним, как бы тут
[02:53:41.760 --> 02:53:43.760]  все адекватненько в этом плане. Ну вот.
[02:53:43.760 --> 02:53:45.760]  Ну а указатель... Ну вот. Ну единственное только,
[02:53:45.760 --> 02:53:47.760]  что для каждого ящика придется хранить указатель
[02:53:47.760 --> 02:53:49.760]  на, видимо, последний
[02:53:49.760 --> 02:53:51.760]  блок такого типа.
[02:53:51.760 --> 02:53:53.760]  Но это... Чего?
[02:53:53.760 --> 02:53:55.760]  Так.
[02:53:55.760 --> 02:53:57.760]  Ну давайте подумаем. Может показаться, что много.
[02:53:57.760 --> 02:53:59.760]  Но на самом деле суммарно это не много.
[02:53:59.760 --> 02:54:01.760]  Потому что на самом деле
[02:54:01.760 --> 02:54:03.760]  заметим, что вещей-то у нас всего тоже там,
[02:54:03.760 --> 02:54:05.760]  сколько там? 100-200 000, да?
[02:54:05.760 --> 02:54:07.760]  Ну вот. Поэтому суммарный размер
[02:54:07.760 --> 02:54:09.760]  всех мапов там будет на самом деле тоже
[02:54:09.840 --> 02:54:11.840]  не более чем 200 000.
[02:54:11.840 --> 02:54:13.840]  Да, то есть анод.
[02:54:13.840 --> 02:54:15.840]  То есть в каком-нибудь мапе,
[02:54:15.840 --> 02:54:17.840]  то есть в каком-нибудь вот действительно мапе храним
[02:54:17.840 --> 02:54:19.840]  указатель, что где у нас вот такая вещь,
[02:54:19.840 --> 02:54:21.840]  где у нас там вот такая вещь, может быть там,
[02:54:21.840 --> 02:54:23.840]  ну и так далее.
[02:54:23.840 --> 02:54:25.840]  Вот.
[02:54:25.840 --> 02:54:27.840]  Ну вот.
[02:54:27.840 --> 02:54:29.840]  Ну вот. И какие тут идеи
[02:54:29.840 --> 02:54:31.840]  возникают. Ну вот.
[02:54:31.840 --> 02:54:33.840]  То есть идея... Ну вот.
[02:54:33.840 --> 02:54:35.840]  Ну вот. Ну а также с помощью
[02:54:35.840 --> 02:54:37.840]  этого же мапчика на самом деле еще мы поддерживаем
[02:54:37.920 --> 02:54:39.920]  информацию о том, сколько вещей такого типа
[02:54:39.920 --> 02:54:41.920]  у нас в этом ящике хранится.
[02:54:41.920 --> 02:54:43.920]  Вот.
[02:54:43.920 --> 02:54:45.920]  Ну потому что давайте вот предположим,
[02:54:45.920 --> 02:54:47.920]  что нам, ну то есть предположим,
[02:54:47.920 --> 02:54:49.920]  что нам сделали запрос
[02:54:49.920 --> 02:54:51.920]  перетащить там какие-то вещи.
[02:54:51.920 --> 02:54:53.920]  Ну во-первых, когда вы кладете эти вещи,
[02:54:53.920 --> 02:54:55.920]  вы их кладете как новый единый блок, правда?
[02:54:55.920 --> 02:54:57.920]  Ну вы за логарифом значит просто
[02:54:57.920 --> 02:54:59.920]  пушбекаете, значит, эту вещь.
[02:54:59.920 --> 02:55:01.920]  То есть эти вещи находите там предыдущий
[02:55:01.920 --> 02:55:03.920]  указатель, собственно, в мапчик
[02:55:03.920 --> 02:55:05.920]  перевешиваете.
[02:55:06.000 --> 02:55:08.000]  Да, то есть там...
[02:55:08.000 --> 02:55:10.000]  Да, то есть наоборот, значит, мапчик вот
[02:55:10.000 --> 02:55:12.000]  теперь там перевешиваете и заодно там
[02:55:12.000 --> 02:55:14.000]  к соответствующему количеству вещей
[02:55:14.000 --> 02:55:16.000]  прибавляете вот это, да?
[02:55:16.000 --> 02:55:18.000]  Вот. Ну что вы еще молили? Ну вот.
[02:55:18.000 --> 02:55:20.000]  Но теперь остается только самое интересное. Это вы как
[02:55:20.000 --> 02:55:22.000]  положить вы поняли, а как достать?
[02:55:22.000 --> 02:55:24.000]  Ну достать предельно тупо.
[02:55:24.000 --> 02:55:26.000]  То есть на самом деле там взять
[02:55:26.000 --> 02:55:28.000]  соответствующий ящик, там
[02:55:28.000 --> 02:55:30.000]  допустим, ну вот
[02:55:30.000 --> 02:55:32.000]  посплитить, ну
[02:55:32.000 --> 02:55:34.000]  отсплитить, собственно, там нужное
[02:55:34.080 --> 02:55:36.080]  последнее количество вещей.
[02:55:38.080 --> 02:55:40.080]  Причем заметим, что при этом вот эти вот ссылочки
[02:55:40.080 --> 02:55:42.080]  на предыдущий блок вообще трогать не надо,
[02:55:42.080 --> 02:55:44.080]  потому что при сплетах и мержах относительный
[02:55:44.080 --> 02:55:46.080]  порядок не меняется.
[02:55:48.080 --> 02:55:50.080]  Ну вот. Ну и все,
[02:55:50.080 --> 02:55:52.080]  что вам тогда остается, это только
[02:55:52.080 --> 02:55:54.080]  пробежаться по вот этому односвязанному
[02:55:54.080 --> 02:55:56.080]  списку нужных вам блоков
[02:55:56.080 --> 02:55:58.080]  и соответственно их всех просто повыдирать.
[02:55:58.080 --> 02:56:00.080]  Остановиться надо только на
[02:56:00.080 --> 02:56:02.080]  как бы том блоке, которое
[02:56:02.160 --> 02:56:04.160]  уже в отсплитченной части не лежит.
[02:56:06.160 --> 02:56:08.160]  То есть вот в принципе, ну вот, то есть
[02:56:08.160 --> 02:56:10.160]  за сколько это будет работать? То есть это будет конечно работать
[02:56:10.160 --> 02:56:12.160]  за логарифом на сколько блоков
[02:56:12.160 --> 02:56:14.160]  вы достанете. Да,
[02:56:14.160 --> 02:56:16.160]  но суммарно это кулоген, почему?
[02:56:16.160 --> 02:56:18.160]  Потому что амортизировано, потому что
[02:56:18.160 --> 02:56:20.160]  вы достали там допустим к блоков,
[02:56:20.160 --> 02:56:22.160]  но при этом схлопнули их
[02:56:22.160 --> 02:56:24.160]  в один. Да, ну
[02:56:24.160 --> 02:56:26.160]  и ладно, есть еще одна мелкая оговорка,
[02:56:26.160 --> 02:56:28.160]  может быть еще так, что вам какой-то блок
[02:56:28.160 --> 02:56:30.160]  придется распилить на два, кстати.
[02:56:30.240 --> 02:56:32.240]  Да, то есть это тоже такая техническая
[02:56:32.240 --> 02:56:34.240]  гадость, которую придется учесть.
[02:56:34.240 --> 02:56:36.240]  Вот, но тем не менее,
[02:56:36.240 --> 02:56:38.240]  вот амортизировано, получился решение за кулоген
[02:56:38.240 --> 02:56:40.240]  с дикартячкой, вот примерно такую гадость
[02:56:40.240 --> 02:56:42.240]  вот. Ну вот, но как-то почему-то
[02:56:42.240 --> 02:56:44.240]  да, в Петрозаводске такую гадость что-то никто
[02:56:44.240 --> 02:56:46.240]  не написал.
[02:56:46.240 --> 02:56:48.240]  А вместо этого выяснилось, что оказывается
[02:56:48.240 --> 02:56:50.240]  в этой гадости дикартового дерева писать
[02:56:50.240 --> 02:56:52.240]  вообще не надо.
[02:56:52.240 --> 02:56:54.240]  В смысле не надо, в смысле можно написать.
[02:56:54.240 --> 02:56:56.240]  Чего?
[02:56:56.240 --> 02:56:58.240]  В смысле не надо, в смысле можно не писать.
[02:56:58.320 --> 02:57:00.320]  Ну вот,
[02:57:00.320 --> 02:57:02.320]  потому что оказывается,
[02:57:02.320 --> 02:57:04.320]  что вместо
[02:57:04.320 --> 02:57:06.320]  этого идея оказывается такая,
[02:57:06.320 --> 02:57:08.320]  а давайте-ка вот эти вот блоки
[02:57:08.320 --> 02:57:10.320]  вместо дикартового дерева будем хранить
[02:57:10.320 --> 02:57:12.320]  фенвички.
[02:57:14.320 --> 02:57:16.320]  То есть заведем просто честный вектор,
[02:57:16.320 --> 02:57:18.320]  будем в нем хранить сколько там, то есть
[02:57:18.320 --> 02:57:20.320]  будем хранить тип вещей, сколько их,
[02:57:20.320 --> 02:57:22.320]  а на вот там сколько их заведем
[02:57:22.320 --> 02:57:24.320]  фенвичка.
[02:57:24.320 --> 02:57:26.320]  Ну начнем с того, кстати, что фенвичек
[02:57:26.400 --> 02:57:28.400]  обладает,
[02:57:28.400 --> 02:57:30.400]  то есть обладает
[02:57:30.400 --> 02:57:32.400]  поддерживать такую мистическую
[02:57:32.400 --> 02:57:34.400]  технологию как pushback
[02:57:36.400 --> 02:57:38.400]  за логарифом.
[02:57:38.400 --> 02:57:40.400]  Ну то есть понятно, что если вы тут
[02:57:40.400 --> 02:57:42.400]  впрекете один элемент, он конечно повлияет на несколько сумм,
[02:57:42.400 --> 02:57:44.400]  но он повлияет только на логарифом сумму,
[02:57:44.400 --> 02:57:46.400]  вы собственно стандартным образом высчитываете.
[02:57:46.400 --> 02:57:48.400]  А можно в принципе заранее, там запросы
[02:57:48.400 --> 02:57:50.400]  никто не анализировал, слава богу, поэтому
[02:57:50.400 --> 02:57:52.400]  в принципе вы можете заранее подсчитать
[02:57:52.400 --> 02:57:54.400]  сколько теоретических блоков у вас там
[02:57:54.400 --> 02:57:56.400]  в этом ящике потребуется.
[02:57:56.400 --> 02:57:58.400]  Ну понятно,
[02:57:58.400 --> 02:58:00.400]  суммарных будет там, понятно,
[02:58:00.400 --> 02:58:02.400]  сколько было изначально,
[02:58:02.400 --> 02:58:04.400]  сколько было изначально, плюс
[02:58:04.400 --> 02:58:06.400]  ку еще.
[02:58:06.400 --> 02:58:08.400]  И тогда идея такая,
[02:58:08.400 --> 02:58:10.400]  то есть давайте делаем абсолютно
[02:58:10.400 --> 02:58:12.400]  то же самое, но только храним
[02:58:12.400 --> 02:58:14.400]  вот это все в фенвичке.
[02:58:14.400 --> 02:58:16.400]  И дальше тогда идея вот такая,
[02:58:16.400 --> 02:58:18.400]  что мы конечно
[02:58:18.400 --> 02:58:20.400]  в фенвичке еще проще можем
[02:58:20.400 --> 02:58:22.400]  пробежаться по вот этому списку.
[02:58:24.400 --> 02:58:26.400]  Да, один на чемодан.
[02:58:26.400 --> 02:58:28.400]  Но теперь идея такая, то есть когда вы прогуливаетесь
[02:58:28.400 --> 02:58:30.400]  вот только по списку, да, ну вы сначала
[02:58:30.400 --> 02:58:32.400]  вы находите, до как, там
[02:58:32.400 --> 02:58:34.400]  где вот эти вот первые там самые верхние
[02:58:34.400 --> 02:58:36.400]  ка элементов лежат. Как вы делаете?
[02:58:36.400 --> 02:58:38.400]  Можно даже, ну можно сделать тупо бинпоиском
[02:58:38.400 --> 02:58:40.400]  на самом деле.
[02:58:40.400 --> 02:58:42.400]  Я думаю залог квадрат там зайдет.
[02:58:42.400 --> 02:58:44.400]  Но как мы уже сегодня убедились, можно аккуратненьким
[02:58:44.400 --> 02:58:46.400]  спуском тоже делать в принципе.
[02:58:46.400 --> 02:58:48.400]  Вот.
[02:58:48.400 --> 02:58:50.400]  Но так или иначе вы нашли, где эти вот
[02:58:50.400 --> 02:58:52.400]  верхние ка значит
[02:58:52.400 --> 02:58:54.400]  заканчиваются, да?
[02:58:54.400 --> 02:58:56.400]  Вот. И тогда идея такая, значит
[02:58:56.400 --> 02:58:58.400]  тогда все, что вам нужно, эти вот эти блоки выпилить.
[02:58:58.400 --> 02:59:00.400]  Как эти блоки выпилить?
[02:59:00.400 --> 02:59:02.400]  Да очень просто, написать, что там
[02:59:02.400 --> 02:59:04.400]  ноль.
[02:59:04.400 --> 02:59:06.400]  Вот.
[02:59:06.400 --> 02:59:08.400]  Ну написать, во-первых, что там ноль, и во-вторых
[02:59:08.400 --> 02:59:10.400]  конечно записать, что там
[02:59:10.400 --> 02:59:12.400]  в этот вот исходный мапчик, что
[02:59:12.400 --> 02:59:14.400]  последний блок такого типа теперь вон там.
[02:59:14.400 --> 02:59:16.400]  Но если какой-то блок надо распилить
[02:59:16.400 --> 02:59:18.400]  на два, то понимаете, да, по факту это произойдет
[02:59:18.400 --> 02:59:20.400]  только если у нас тут там
[02:59:20.400 --> 02:59:22.400]  179 вещей, а из них надо забрать
[02:59:22.400 --> 02:59:24.400]  всего лишь 57, да?
[02:59:24.400 --> 02:59:26.400]  Поэтому в этом смысле вы просто в этом блоке
[02:59:26.400 --> 02:59:28.400]  пишете 122 и не паритесь.
[02:59:28.400 --> 02:59:30.400]  Вот.
[02:59:30.400 --> 02:59:32.400]  Ну вот собственно и все. То есть получается,
[02:59:32.400 --> 02:59:34.400]  то есть идея оказалась в том, что просто храним все
[02:59:34.400 --> 02:59:36.400]  в фенвирчике, просто идея в том, что мы разрешаем
[02:59:36.400 --> 02:59:38.400]  в себе какие-то дыры.
[02:59:38.400 --> 02:59:40.400]  И с этого сильно не
[02:59:40.400 --> 02:59:42.400]  страдаем.
[02:59:42.400 --> 02:59:44.400]  А мы для каждого цвета храним
[02:59:44.400 --> 02:59:46.400]  фенвир? Нет.
[02:59:46.400 --> 02:59:48.400]  Нет, почему? Для каждого чемодана храним фенвир.
[02:59:48.400 --> 02:59:50.400]  В шагах мы удаляем блоки нужного цвета.
[02:59:50.400 --> 02:59:52.400]  Ну а дальше
[02:59:52.400 --> 02:59:54.400]  все так же. То есть для каждого блока
[02:59:54.400 --> 02:59:56.400]  соответствующего цвета мы храним
[02:59:56.400 --> 02:59:58.400]  предыдущий. Вот.
[02:59:58.400 --> 03:00:00.400]  Предыдущий заодно еще храним там сколько таких
[03:00:00.400 --> 03:00:02.400]  вещей, чтоб на запрос потом второй отвечать.
[03:00:02.400 --> 03:00:04.400]  Ну вот и так далее.
[03:00:04.400 --> 03:00:06.400]  Так что мы уже делаем общий спуск.
[03:00:06.400 --> 03:00:08.400]  Мы можем также просто двигаться, пока
[03:00:08.400 --> 03:00:10.400]  не найдем. И это будет опять
[03:00:10.400 --> 03:00:12.400]  примортизированное, чтобы... Ааа.
[03:00:12.400 --> 03:00:14.400]  Здесь крас не будет, потому что у тебя 0 возможно.
[03:00:14.400 --> 03:00:16.400]  А я буду двигаться такой по 0.
[03:00:16.400 --> 03:00:18.400]  Да. То есть заметьте, вот этот
[03:00:18.400 --> 03:00:20.400]  досвязный список мы поддерживаем так, что 0 мы там
[03:00:20.400 --> 03:00:22.400]  не храним. Да.
[03:00:22.400 --> 03:00:24.400]  А тогда, в принципе, да, заметим,
[03:00:24.400 --> 03:00:26.400]  что действительно амортизация тут гарантирует
[03:00:26.400 --> 03:00:28.400]  так, что когда вы пришли в блок, вы можете
[03:00:28.400 --> 03:00:30.400]  просто выяснить, сколько перед ним элементов за
[03:00:30.400 --> 03:00:32.400]  один фенвир.
[03:00:32.400 --> 03:00:34.400]  Потому что все равно, что вы будете его там либо обнулять,
[03:00:34.400 --> 03:00:36.400]  либо в этом месте остановитесь.
[03:00:36.400 --> 03:00:38.400]  А когда раз обнуляете за логарифом, почему
[03:00:38.400 --> 03:00:40.400]  вам не потратить логарифом на то, чтобы
[03:00:40.400 --> 03:00:42.400]  тут еще и сумму найти?
[03:00:42.400 --> 03:00:44.400]  Да. Так что вот
[03:00:44.400 --> 03:00:46.400]  оказывается, да, тут оказывается, еще никаких
[03:00:46.400 --> 03:00:48.400]  спусков по дереву нет.
[03:00:48.400 --> 03:00:50.400]  Вот. То есть вот получается,
[03:00:50.400 --> 03:00:52.400]  что никаких декартовых деревьев здесь
[03:00:52.400 --> 03:00:54.400]  не надо.
[03:00:56.400 --> 03:00:58.400]  Ну вот. Ну вот, чаще всего
[03:00:58.400 --> 03:01:00.400]  да. Не, ну чаще всего на самом деле да.
[03:01:00.400 --> 03:01:02.400]  То есть обычно оно не нужно,
[03:01:02.400 --> 03:01:04.400]  но тут вот выясняем. Но тут это просто вот потрясающий
[03:01:04.400 --> 03:01:06.400]  пример, действительно, технологии, как без декартики
[03:01:06.400 --> 03:01:08.400]  можно прекрасно обойтись.
[03:01:08.400 --> 03:01:10.400]  Ну вот. Ну вот просто там.
[03:01:10.400 --> 03:01:12.400]  Ну как бы напоминаю, да, что как бы...
[03:01:12.400 --> 03:01:14.400]  Идея может выглядеть простенько, но
[03:01:14.400 --> 03:01:16.400]  в тот момент там только одна команда
[03:01:16.400 --> 03:01:18.400]  решила задачу, напоминаю.
[03:01:18.400 --> 03:01:20.400]  Вот.
[03:01:20.400 --> 03:01:22.400]  Ну и там в авторском решении тоже были декартики.
[03:01:22.400 --> 03:01:24.400]  То есть мы так
[03:01:24.400 --> 03:01:26.400]  были так сильно удивлены.
[03:01:26.400 --> 03:01:28.400]  Ну вот.
[03:01:28.400 --> 03:01:30.400]  Ну вот, оказывается, так можно.
[03:01:30.400 --> 03:01:32.400]  Ну, собственно, это нормально, да.
[03:01:32.400 --> 03:01:34.400]  Да, ведь контест в Петразаводске
[03:01:34.400 --> 03:01:36.400]  будет только к тому, что вам на разборе расскажут, как
[03:01:36.400 --> 03:01:38.400]  на самом деле задача решалась.
[03:01:38.400 --> 03:01:40.400]  Или, корректно говоря,
[03:01:40.400 --> 03:01:42.400]  была бы решаться.
[03:01:42.400 --> 03:01:44.400]  Вот.
[03:01:44.400 --> 03:01:46.400]  Ну, вот бывает.
[03:01:46.400 --> 03:01:48.400]  Вот.
[03:01:48.400 --> 03:01:50.400]  То есть ну вот. Ну такое бывает, собственно, за этим
[03:01:50.400 --> 03:01:52.400]  в общем-то сборе в Петразаводске и делается.
[03:01:52.400 --> 03:01:54.400]  Вот.
[03:01:54.400 --> 03:01:56.400]  Значит, это был казахский Федор.
[03:01:58.400 --> 03:02:00.400]  Чего?
[03:02:00.400 --> 03:02:02.400]  Что его придумали казахи.
[03:02:04.400 --> 03:02:06.400]  Чего?
[03:02:06.400 --> 03:02:08.400]  Ну да, ну скажем так,
[03:02:08.400 --> 03:02:10.400]  я, то есть, ну, не, ну, то есть подобная технология,
[03:02:10.400 --> 03:02:12.400]  что вот можно оказывается там какие-то вот
[03:02:12.400 --> 03:02:14.400]  какие-то, то есть какие-то вещи
[03:02:14.400 --> 03:02:16.400]  без декартики реально вот иногда хранить
[03:02:16.400 --> 03:02:18.400]  фенвиками и удалять вот методом
[03:02:18.400 --> 03:02:20.400]  записи нуля, и этого хватает.
[03:02:20.400 --> 03:02:22.400]  Вот.
[03:02:22.400 --> 03:02:24.400]  Ну, то есть я не знаю, просто меня это надо. То есть меня эта идея настолько
[03:02:24.400 --> 03:02:26.400]  впечатлила, что я ее с тех пор всем рассказываю.
[03:02:26.400 --> 03:02:28.400]  Вот. Но идея действительно
[03:02:28.400 --> 03:02:30.400]  крутая. Вот. Я ее
[03:02:30.400 --> 03:02:32.400]  называю казахский фенвик. То есть нельзя сказать,
[03:02:32.400 --> 03:02:34.400]  что она там супер, там официально, конечно,
[03:02:34.400 --> 03:02:36.400]  название, но тем не менее.
[03:02:36.400 --> 03:02:38.400]  Так, ну, что у нас еще есть?
[03:02:40.400 --> 03:02:42.400]  Вот.
[03:02:44.400 --> 03:02:46.400]  Нет, у меня нету.
[03:02:50.400 --> 03:02:52.400]  Нет, нет.
[03:02:54.400 --> 03:02:56.400]  Да, да, там
[03:02:56.400 --> 03:02:58.400]  суммарно, да, по памяти там
[03:02:58.400 --> 03:03:00.400]  Н.
[03:03:02.400 --> 03:03:04.400]  Ну, да.
[03:03:04.400 --> 03:03:06.400]  Но более жирная, да.
[03:03:08.400 --> 03:03:10.400]  Так, что да.
[03:03:10.400 --> 03:03:12.400]  Так, ну, что, идем дальше тогда.
[03:03:12.400 --> 03:03:14.400]  Так, ладно, сейчас нас
[03:03:14.400 --> 03:03:16.400]  неожиданно поприветствует фенвик фенвиков.
[03:03:18.400 --> 03:03:20.400]  Сейчас у нас будет задача, которую
[03:03:20.400 --> 03:03:22.400]  за всю нашу сознательную жизнь мы
[03:03:22.400 --> 03:03:24.400]  так или иначе решим двумя способами,
[03:03:24.400 --> 03:03:26.400]  возможно, даже сегодня.
[03:03:28.400 --> 03:03:30.400]  Нет.
[03:03:30.400 --> 03:03:32.400]  Двумерное немножко другое.
[03:03:32.400 --> 03:03:34.400]  Нет, как бы не путать двумерный фенвик и фенвик
[03:03:34.400 --> 03:03:36.400]  фенвиков. Это разные вещи.
[03:03:38.400 --> 03:03:40.400]  Не надо падать со стула.
[03:03:40.400 --> 03:03:42.400]  Это не самое страшное, да, не волнуйтесь.
[03:03:42.400 --> 03:03:44.400]  Значит, идея у нас будет такая.
[03:03:46.400 --> 03:03:48.400]  Значит, идея такая.
[03:03:50.400 --> 03:03:52.400]  Хотя как бы идея будет похожа на
[03:03:52.400 --> 03:03:54.400]  двумерную риску, но немного другая.
[03:03:54.400 --> 03:03:56.400]  Значит, дано N.
[03:03:58.400 --> 03:04:00.400]  Ну, там N, как всегда, там приблизительно 10 в 5.
[03:04:02.400 --> 03:04:04.400]  Вот.
[03:04:04.400 --> 03:04:06.400]  Нет, какие звезды?
[03:04:06.400 --> 03:04:08.400]  Звезды – это трехмерный фенвик, просто
[03:04:08.400 --> 03:04:10.400]  напишите и не парьтесь. А тут задача такая.
[03:04:10.400 --> 03:04:12.400]  Даны какие-то N. Множество точек
[03:04:12.400 --> 03:04:14.400]  не меняется.
[03:04:16.400 --> 03:04:18.400]  Смотрите, ребята, множество точек не меняется.
[03:04:18.400 --> 03:04:20.400]  На каждой
[03:04:20.400 --> 03:04:22.400]  точке написаны какие-то числа.
[03:04:22.400 --> 03:04:24.400]  И вот они, кстати, вполне себе меняются.
[03:04:26.400 --> 03:04:28.400]  Ну, по большому счету, запросы такие.
[03:04:28.400 --> 03:04:30.400]  То есть у вас бывают запросы
[03:04:30.400 --> 03:04:32.400]  added.
[03:04:32.400 --> 03:04:34.400]  Значит, там posX, там posD.
[03:04:34.400 --> 03:04:36.400]  То есть это означает, возьми точку
[03:04:36.400 --> 03:04:38.400]  номер pos и прибавь
[03:04:38.400 --> 03:04:40.400]  к ее числу D.
[03:04:42.400 --> 03:04:44.400]  И второй тип запроса
[03:04:44.400 --> 03:04:46.400]  сумма.
[03:04:48.400 --> 03:04:50.400]  То есть просто дан какой-то вот
[03:04:50.400 --> 03:04:52.400]  под прямоугольник, в сторону которого
[03:04:52.400 --> 03:04:54.400]  параллельно осям координат, и нам говорят,
[03:04:54.400 --> 03:04:56.400]  пожалуйста, найдите сумму
[03:04:56.400 --> 03:04:58.400]  чисел на всех точках,
[03:04:58.400 --> 03:05:00.400]  которые в этот прямоугольник попали.
[03:05:18.400 --> 03:05:20.400]  Ну да.
[03:05:20.400 --> 03:05:22.400]  Практически жирно.
[03:05:22.400 --> 03:05:24.400]  Самое тупое, что можно делать,
[03:05:24.400 --> 03:05:26.400]  особенно если выяснить, что координаты
[03:05:26.400 --> 03:05:28.400]  от 0 до 10 в 9.
[03:05:28.400 --> 03:05:30.400]  Да.
[03:05:30.400 --> 03:05:32.400]  Ну да, самое тупое, что можно делать.
[03:05:32.400 --> 03:05:34.400]  Давайте там xy до
[03:05:34.400 --> 03:05:36.400]  хотя бы от 0 до 10 в 9.
[03:05:36.400 --> 03:05:38.400]  Ну действительно, давайте заведем
[03:05:38.400 --> 03:05:40.400]  неявного фенлика на 10 в 9.
[03:05:40.400 --> 03:05:42.400]  Да.
[03:05:42.400 --> 03:05:44.400]  Ну сейчас погодите.
[03:05:44.400 --> 03:05:46.400]  Самое тупое, что можно сделать. Давайте заведем неявного фенлика
[03:05:46.400 --> 03:05:48.400]  на 10 в 9.
[03:05:48.400 --> 03:05:50.400]  Ну хранить там ячейки будем в анортерет
[03:05:50.400 --> 03:05:52.400]  мапе и там лишнее не создавать.
[03:05:52.400 --> 03:05:54.400]  Тогда все запросы
[03:05:54.400 --> 03:05:56.400]  у нас будут за лог 10 в 9,
[03:05:56.400 --> 03:05:58.400]  на лог 10 в 9 кайф.
[03:05:58.400 --> 03:06:00.400]  Казалось бы.
[03:06:00.400 --> 03:06:02.400]  Да.
[03:06:02.400 --> 03:06:04.400]  Но
[03:06:04.400 --> 03:06:06.400]  скажем так, да, оказывается,
[03:06:06.400 --> 03:06:08.400]  да, то есть как
[03:06:08.400 --> 03:06:10.400]  часто бывает, в том числе и в корнячках,
[03:06:10.400 --> 03:06:12.400]  как говорится, да, то есть асимпатически
[03:06:12.400 --> 03:06:14.400]  формально вроде нормально, но реально не заходит.
[03:06:14.400 --> 03:06:16.400]  Ну извините, у авторов решение в три раза быстрее работает.
[03:06:16.400 --> 03:06:18.400]  Мы ничего не можем сделать.
[03:06:18.400 --> 03:06:20.400]  Всякое бывает.
[03:06:20.400 --> 03:06:22.400]  В контесте на физтехе
[03:06:22.400 --> 03:06:24.400]  в другом контесте вообще была задача,
[03:06:24.400 --> 03:06:26.400]  в которой у нас
[03:06:26.400 --> 03:06:28.400]  было два решения за асимпатическую
[03:06:28.400 --> 03:06:30.400]  логен, но одно работало в 10 раз дольше
[03:06:30.400 --> 03:06:32.400]  другого.
[03:06:34.400 --> 03:06:36.400]  Нет, там запросов не было.
[03:06:36.400 --> 03:06:38.400]  А вот это
[03:06:38.400 --> 03:06:40.400]  ну
[03:06:40.400 --> 03:06:42.400]  ну вообще оффлайн.
[03:06:42.400 --> 03:06:44.400]  Да, ну вот
[03:06:44.400 --> 03:06:46.400]  действительно, да, потому что как можно сделать
[03:06:46.400 --> 03:06:48.400]  побыстрее? Да, во-первых, начнем с того, что можно
[03:06:48.400 --> 03:06:50.400]  пожать координаты. Действительно.
[03:06:50.400 --> 03:06:52.400]  Да.
[03:06:52.400 --> 03:06:54.400]  Так, правда, отдельное,
[03:06:54.400 --> 03:06:56.400]  кстати, отдельный вопрос.
[03:06:56.400 --> 03:06:58.400]  Кстати, как пожать координаты?
[03:07:00.400 --> 03:07:02.400]  Рисайз юник.
[03:07:02.400 --> 03:07:04.400]  Так, надеюсь, все пишут рисайз юник?
[03:07:04.400 --> 03:07:06.400]  А то там кто-то мапы какие-то
[03:07:06.400 --> 03:07:08.400]  там пишет или там что?
[03:07:08.400 --> 03:07:10.400]  Давайте я на всякий случай
[03:07:10.400 --> 03:07:12.400]  напишу, потому что это чтобы
[03:07:12.400 --> 03:07:14.400]  чтобы было, потому что я понимаю,
[03:07:14.400 --> 03:07:16.400]  что многие, скорее всего, правильный код знают.
[03:07:16.400 --> 03:07:18.400]  Допустим, у нас ситуация такая,
[03:07:18.400 --> 03:07:20.400]  допустим, у меня есть
[03:07:22.400 --> 03:07:24.400]  там вектор point
[03:07:24.400 --> 03:07:26.400]  там PS какой-нибудь от n, в который
[03:07:26.400 --> 03:07:28.400]  записали точки, я хочу сжать
[03:07:28.400 --> 03:07:30.400]  иксы. Так вот.
[03:07:30.400 --> 03:07:32.400]  Значит, как сжимать иксы?
[03:07:32.400 --> 03:07:34.400]  Что значит сжать координаты?
[03:07:34.400 --> 03:07:36.400]  Я хочу, по идее, взять
[03:07:36.400 --> 03:07:38.400]  все эти иксы и заменить каждый
[03:07:38.400 --> 03:07:40.400]  икс на его порядковый номер с сортированным
[03:07:40.400 --> 03:07:42.400]  R7 иксов, правда?
[03:07:42.400 --> 03:07:44.400]  Поэтому делаю я это
[03:07:44.400 --> 03:07:46.400]  так.
[03:07:46.400 --> 03:07:48.400]  Смотрите, вектор
[03:07:48.400 --> 03:07:50.400]  там int, ну допустим int
[03:07:50.400 --> 03:07:52.400]  x
[03:07:52.400 --> 03:07:54.400]  да, значит пишем
[03:07:54.400 --> 03:07:56.400]  point
[03:07:56.400 --> 03:07:58.400]  там point PS
[03:07:58.400 --> 03:08:00.400]  значит
[03:08:00.400 --> 03:08:02.400]  xs.pushback
[03:08:04.400 --> 03:08:06.400]  от p.x, да, но если хочется
[03:08:06.400 --> 03:08:08.400]  сразу пооптимизировать, тут еще можно
[03:08:08.400 --> 03:08:10.400]  амперсентик написать.
[03:08:10.400 --> 03:08:12.400]  Ну это не
[03:08:12.400 --> 03:08:14.400]  хорошо.
[03:08:14.400 --> 03:08:16.400]  Ну не важно, ладно.
[03:08:16.400 --> 03:08:18.400]  Главная идея такая,
[03:08:18.400 --> 03:08:20.400]  дальше пишем, значит
[03:08:20.400 --> 03:08:22.400]  сортируем иксы.
[03:08:24.400 --> 03:08:26.400]  Значит, да,
[03:08:26.400 --> 03:08:28.400]  сортируем иксы.
[03:08:28.400 --> 03:08:30.400]  Значит, дальше
[03:08:30.400 --> 03:08:32.400]  делаем самую магическую строчку
[03:08:32.400 --> 03:08:34.400]  в этом месте.
[03:08:34.400 --> 03:08:36.400]  Но я люблю так писать,
[03:08:36.400 --> 03:08:38.400]  xs.resize
[03:08:38.400 --> 03:08:40.400]  значит
[03:08:40.400 --> 03:08:42.400]  resize
[03:08:42.400 --> 03:08:44.400]  от unic
[03:08:44.400 --> 03:08:46.400]  от
[03:08:46.400 --> 03:08:48.400]  xs.begin
[03:08:48.400 --> 03:08:50.400]  xs.end
[03:08:52.400 --> 03:08:54.400]  минус
[03:08:54.400 --> 03:08:56.400]  xs.begin
[03:08:58.400 --> 03:09:00.400]  Вот.
[03:09:00.400 --> 03:09:02.400]  Ну и в конце
[03:09:02.400 --> 03:09:04.400]  for
[03:09:04.400 --> 03:09:06.400]  point
[03:09:06.400 --> 03:09:08.400]  амперсант
[03:09:08.400 --> 03:09:10.400]  PS
[03:09:10.400 --> 03:09:12.400]  p.x
[03:09:12.400 --> 03:09:14.400]  равно lower bound.
[03:09:18.400 --> 03:09:20.400]  Не надо.
[03:09:20.400 --> 03:09:22.400]  Но lower bound
[03:09:22.400 --> 03:09:24.400]  как-то на массиве будет быстрее работать, чем какой-то
[03:09:24.400 --> 03:09:26.400]  мап, очевидно.
[03:09:36.400 --> 03:09:38.400]  Вот.
[03:09:42.400 --> 03:09:44.400]  Вот.
[03:09:44.400 --> 03:09:46.400]  То есть вот такие вот образы
[03:09:46.400 --> 03:09:48.400]  без всяких созданий мапов это можно
[03:09:48.400 --> 03:09:50.400]  написать.
[03:09:54.400 --> 03:09:56.400]  Так.
[03:09:56.400 --> 03:09:58.400]  Вот.
[03:09:58.400 --> 03:10:00.400]  Так, ладно, надо кому-то рассказать, что
[03:10:00.400 --> 03:10:02.400]  делает алгоритмы sort, lower bound и
[03:10:02.400 --> 03:10:04.400]  unic.
[03:10:04.400 --> 03:10:06.400]  Нет, sort абсолютно
[03:10:06.400 --> 03:10:08.400]  обычный.
[03:10:08.400 --> 03:10:10.400]  Преимущество тут заключается
[03:10:10.400 --> 03:10:12.400]  в том, что sort, unic и lower bound это
[03:10:12.400 --> 03:10:14.400]  стандартные алгоритмы STL.
[03:10:14.400 --> 03:10:16.400]  Ну sort, ну понятно,
[03:10:16.400 --> 03:10:18.400]  что делает.
[03:10:18.400 --> 03:10:20.400]  А unic делает следующее.
[03:10:20.400 --> 03:10:22.400]  Unic, он пробегается
[03:10:22.400 --> 03:10:24.400]  по массиву и
[03:10:24.400 --> 03:10:26.400]  избавляется от идущих подряд
[03:10:26.400 --> 03:10:28.400]  одинаковых элементов.
[03:10:28.400 --> 03:10:30.400]  То есть, ну пример такой.
[03:10:30.400 --> 03:10:32.400]  Значит, смотрите, что делает
[03:10:32.400 --> 03:10:34.400]  уник. Предположим, что унику передали
[03:10:34.400 --> 03:10:36.400]  с помощью двух итераторов.
[03:10:36.400 --> 03:10:38.400]  Значит, массив, в котором
[03:10:38.400 --> 03:10:40.400]  написано 5, 5, 4,
[03:10:40.400 --> 03:10:42.400]  4, 4, 8, 8,
[03:10:42.400 --> 03:10:44.400]  8, 8, 2, 5,
[03:10:44.400 --> 03:10:46.400]  5, 4, 4, 3,
[03:10:46.400 --> 03:10:48.400]  2, 2, 2,
[03:10:48.400 --> 03:10:50.400]  2, 1, 1, 3,
[03:10:50.400 --> 03:10:52.400]  3, 3,
[03:10:52.400 --> 03:10:54.400]  3,
[03:10:54.400 --> 03:10:56.400]  5.
[03:10:56.400 --> 03:10:58.400]  Да.
[03:10:58.400 --> 03:11:00.400]  Ну, тут
[03:11:00.400 --> 03:11:02.400]  да, конечно.
[03:11:02.400 --> 03:11:04.400]  Эпично, да.
[03:11:04.400 --> 03:11:06.400]  Так вот, предположим, что вам
[03:11:06.400 --> 03:11:08.400]  унику передали на вход
[03:11:08.400 --> 03:11:10.400]  вот это. То есть, передали вот типа
[03:11:10.400 --> 03:11:12.400]  begin вот сюда,
[03:11:12.400 --> 03:11:14.400]  end вот сюда. Заметим, что
[03:11:14.400 --> 03:11:16.400]  алгоритм, которому передали
[03:11:16.400 --> 03:11:18.400]  два итератора, он как бы сам
[03:11:18.400 --> 03:11:20.400]  вектор пресайзить не может, естественно.
[03:11:20.400 --> 03:11:22.400]  Более того, это не обязан быть вектор,
[03:11:22.400 --> 03:11:24.400]  вы могли туда и указатели на массив подсунуть.
[03:11:24.400 --> 03:11:26.400]  Вот.
[03:11:28.400 --> 03:11:30.400]  Я рассказываю, как работает
[03:11:30.400 --> 03:11:32.400]  оператор функции уник.
[03:11:32.400 --> 03:11:34.400]  Она работает, да.
[03:11:34.400 --> 03:11:36.400]  Она не завязана на том, что там
[03:11:36.400 --> 03:11:38.400]  элементы отсортированы.
[03:11:38.400 --> 03:11:40.400]  Она просто идет слева
[03:11:40.400 --> 03:11:42.400]  направо и как бы в тот же самый
[03:11:42.400 --> 03:11:44.400]  массив записывает.
[03:11:44.400 --> 03:11:46.400]  То есть, она вот просто берет
[03:11:46.400 --> 03:11:48.400]  вот слева направо идет и тупо
[03:11:48.400 --> 03:11:50.400]  записывает все элементы, но при этом
[03:11:50.400 --> 03:11:52.400]  игнорируя,
[03:11:52.400 --> 03:11:54.400]  но при этом игнорирую дубликаты.
[03:11:54.400 --> 03:11:56.400]  То есть вот дальше вот, например, идет пятёрка,
[03:11:56.400 --> 03:11:58.400]  значит, мы её не записываем. Вот дальше
[03:11:58.400 --> 03:12:00.400]  идёт четвёрка, мы её записываем.
[03:12:00.400 --> 03:12:02.400]  Дальше. То есть вот так вот. Идём,
[03:12:02.400 --> 03:12:04.400]  идем, не записываем,
[03:12:04.400 --> 03:12:06.400]  идём, не записываем.
[03:12:06.400 --> 03:12:08.400]  Значит, идём, ой,
[03:12:08.400 --> 03:12:10.400]  нерав championships, мы пишем восьмёрку.
[03:12:10.400 --> 03:12:12.400]  Значит, идем не записываем,
[03:12:12.400 --> 03:12:14.400]  идём не записываем, идём не записываем.
[03:12:14.400 --> 03:12:16.400]  Значит, двойку записываем,
[03:12:16.400 --> 03:12:18.400]  пятёрку записываем.
[03:12:18.400 --> 03:12:20.400]  Это не записываем.
[03:12:20.400 --> 03:12:28.800]  наоборот это это это мы не зачеркиваем сейчас вот скажу почему значит 5 значит 4 вот так вот
[03:12:28.800 --> 03:12:37.140]  значит это мы да что ж такое зачем я ее зачеркиваю все время нет это мы типа не пишем вот так это
[03:12:37.140 --> 03:12:44.040]  записываем ну короче говоря вы уж дорадуетесь да давали сюда что там что будет 2 1 3 5 короче
[03:12:44.040 --> 03:12:55.120]  вот но юник кое-что вернет вот эти элементы смотрите вот почему это зачеркиваю потому что
[03:12:55.120 --> 03:12:59.760]  идея в том что как бы понятно он новую память юник не создает естественно он просто вот
[03:12:59.760 --> 03:13:07.920]  перезаписывает в начало массива вот эти элементы и более того возвращает итератор вот сюда то есть
[03:13:08.880 --> 03:13:15.160]  то есть типа что я закончил здесь так вот вот эти элементы он не трогает то есть они останутся в
[03:13:15.160 --> 03:13:21.840]  первозданном виде вот то есть вот что по официальному вообще определению делает
[03:13:21.840 --> 03:13:30.720]  собственно алгоритм юник нет почему делает предельно в тупую бежит
[03:13:30.720 --> 03:13:42.320]  да совершенно нет почему нет у него задача сжать идущий подряд дубликаты все это все что он
[03:13:42.320 --> 03:13:46.960]  делает то есть никто не сказал что он удаляет дубликаты все вообще он удаляет подряд идущие
[03:13:46.960 --> 03:13:56.840]  да он делает это салей нет нет вот начиная с этого момента элементы останутся теми же
[03:13:56.840 --> 03:14:01.560]  какими были раньше я их поэтому не зачеркивать то есть там вот то есть массив будет до этого
[03:14:01.560 --> 03:14:07.040]  момента вот такой а вот начиная с этого момента прям вот что было раньше да можете считать по
[03:14:07.040 --> 03:14:14.040]  сути это мусор вот еще вот этот итератор вернется поэтому для того чтобы этот мусор убить я тут
[03:14:14.040 --> 03:14:23.080]  пишу resize от вот этого то что вернул юник минус беги то есть это столько элементов осталось можно
[03:14:23.080 --> 03:14:28.720]  да ну скажем так просто я честно я пишу я пишу так не так привычнее кто-то пишет
[03:14:28.720 --> 03:14:36.360]  res от юника да так тоже можно ну там есть там видимо от юника и эндон а да так-то так тоже
[03:14:36.360 --> 03:14:42.520]  можно это на ваше усмотрение вот но для меня как бы суть одна в результате этих двух операций
[03:14:42.520 --> 03:14:50.760]  это что я сделал я взял массив xs а цартировал там все элементы удалил дубликаты теперь после
[03:14:50.760 --> 03:14:55.840]  этого мне каждый x нужно заменить на его номер в отсортированном массиве как найти номер
[03:14:55.840 --> 03:15:00.960]  отсортированном массиве правильно бен поиском но бен поиск у нас устояли реализуются помчу
[03:15:00.960 --> 03:15:08.480]  алгоритма подчеркиваю алгоритма лавербаунд да не вот эти не путать дальше есть там у сетов есть
[03:15:08.480 --> 03:15:14.720]  метод лавербаунд но если вы напишите лавербаунд от там икса там от с точка бегины там сет точка
[03:15:15.720 --> 03:15:28.280]  то работать он будет не залогарив да вы очень сильно удивитесь почему они ну нет при этом подлянка
[03:15:28.280 --> 03:15:35.520]  такая он попытается к этому бегину прибавлять какие-то какие-то штуки к сожалению по к
[03:15:35.520 --> 03:15:41.560]  сожалению но там есть проблема с этого митератором можно прибавлять там 5 7 10 другой вопрос что по
[03:15:41.560 --> 03:15:47.560]  факту они будут работать через 10 раз плюс плюс ну вот и вас поэтому ждет небольшой сюрприз
[03:15:47.560 --> 03:15:55.360]  вот поэтому как бы аккуратнее поэтому не пишите поэтому пишите метод лавербаунд нет там есть
[03:15:55.360 --> 03:15:59.880]  подлянка что действительно больше есть там метод одно там вы скажете что надо плюс плюс не работает
[03:15:59.880 --> 03:16:05.800]  но там есть функция advance которая получает на вход икса и какой-то число и прибавляет к нему это
[03:16:05.800 --> 03:16:12.520]  число но там по умолчанию там реализация шаблонная по умолчанию там реально по умолчанию там
[03:16:12.520 --> 03:16:18.200]  реализация сделает там нужное число раз плюс плюс или минус минус вот но для некоторых итераций
[03:16:18.200 --> 03:16:24.280]  там advance перегружен в соответствии с тем там соответствии с адекватностью ну понятно там
[03:16:24.280 --> 03:16:30.840]  для скажем для вектор или там для массива естественно там плюс равно работает и так вот есть такой
[03:16:30.840 --> 03:16:37.040]  спецэффект вот так поэтому пишем значит тут лавербаунд да вот странно что никого тут не
[03:16:37.040 --> 03:16:44.240]  смутило что тут надо помимо беги на энд и еще кое-что передать а именно собственно п точка икс да
[03:16:44.240 --> 03:16:52.520]  а вот энд всех смутил но да да да компилятор конечно вот да да вот да компилятор тут конечно
[03:16:52.520 --> 03:16:58.440]  вы запишите вы что-то ему не передали да как это я не знаю как работает ваш лавербаунд но
[03:16:58.440 --> 03:17:08.960]  но мой лавербаунд получает три аргумента они два а вы а ну да так что но то хорошо ладно значит
[03:17:08.960 --> 03:17:12.880]  значит такое лирическое отступление сделали значит на всякий случай вот умелись как пишется
[03:17:12.880 --> 03:17:18.360]  вот сжатия координат так что не знаю я бы не советовал там использовать мапочки вот а то
[03:17:18.360 --> 03:17:24.400]  заводить мапчик что-то совать их куда-то там бла бла бла это ну вот то есть не знаю хотя
[03:17:24.400 --> 03:17:28.600]  опять же формально конечно надо просто там сесть и потестировать там вот еще быстрее
[03:17:28.600 --> 03:17:33.120]  работает понятно что относительно в масштабах основного решения скорее всего это будет там
[03:17:33.120 --> 03:17:44.720]  там разница будет пренебрежимым а у вас скорее всего да окей все ладно все значит все говорим
[03:17:44.720 --> 03:17:52.800]  ладно как говорится некогда да да так и скажем значит практики утверждают что да да возможно
[03:17:52.800 --> 03:18:02.680]  правда будут другие практики а у меня наоборот с мапом зашло вот это нет но я тоже ну да ну вообще
[03:18:02.680 --> 03:18:11.800]  да ну хорошо ладно значит вот так поговорили немножко о коде вернемся к делу вот хорошо ладно
[03:18:11.800 --> 03:18:16.240]  начиная с этого момента мы в общем-то без особого ограничения обществе можем считать что все
[03:18:16.240 --> 03:18:25.000]  координаты тоже для 10 в пятый чем это нам да чем это нам помогает да теперь да теперь все будет
[03:18:25.000 --> 03:18:31.760]  работать залог квадрат не 10 в 9 10 в пятый но все-таки 30 квадрате 20 квадрате что круче да а в нашем
[03:18:31.760 --> 03:18:42.000]  случае ты еще и 18 в квадрате ну вот да ну как бы полтора раза вообще получилось тогда а когда
[03:18:42.000 --> 03:18:49.160]  еще и квадрат это уже даже в два точка двадцать пять раз а то и в два с половиной чем может быть
[03:18:49.160 --> 03:18:56.600]  кайфец но правда есть подозрение что памяти да единственная проблема что там будет не не только
[03:18:56.600 --> 03:19:02.920]  по времени лог квадрат а скорее всего еще и по памяти лог квадрат а это не очень хорошо потому
[03:19:02.920 --> 03:19:08.200]  что она вот то есть лог квадрат памяти то есть 10 в пятый налог квадрат 10 восьмой памяти это
[03:19:08.200 --> 03:19:16.080]  может быть и memory limit да автори задачи делать круглый звук извините у меня решение 64 мегабайта
[03:19:16.080 --> 03:19:24.120]  укладывается как бы то что вы так будете писать но я не задал такого извините вот то есть ну как
[03:19:24.120 --> 03:19:30.120]  тогда нет ну как извините он скажет нет извините да нет знаете у меня решение укладывается называется
[03:19:30.120 --> 03:19:36.560]  как говорится оно простое так что как бы если вы как-то не так думаете это ваши проблемы вот как
[03:19:36.560 --> 03:19:42.560]  тут предлагают думать думать думать некоторые авторы но на самом деле да то есть один из вариантов
[03:19:42.560 --> 03:19:50.600]  такой сейчас мы с вами сделаем фенвика фенвиков то есть потому что до что мы обычно халим фенвика
[03:19:50.600 --> 03:19:59.880]  сумму на подотрезке а теперь где такая давайте сделаем фенвика по иксу то есть вот то есть
[03:20:00.200 --> 03:20:23.120]  давайте вот этот вот эту вот это и за бабахиям фенвика то есть ну ну как храним какие-то вот
[03:20:23.120 --> 03:20:27.280]  Вот эти вот все наши любимые зеленые полуинтервалы, вот эти все, да?
[03:20:29.280 --> 03:20:30.000]  Да, вот будем.
[03:20:30.920 --> 03:20:35.000]  Ну да, но в этих полуинтервалах мы храним не сумму.
[03:20:35.920 --> 03:20:38.880]  Мы храним множество точек.
[03:20:40.440 --> 03:20:46.280]  То есть мы себе заявляем, что tf от x0, ну где у нас x0,
[03:20:46.600 --> 03:20:51.000]  как всегда, от 1 до 10 в пятый плюс 1, как всегда,
[03:20:52.000 --> 03:20:56.840]  это множество таких точек, которые нам изначально заданы,
[03:20:58.640 --> 03:21:06.200]  таких, что p точка х лежит в полуинтервале от f от x0 до x0.
[03:21:09.280 --> 03:21:12.280]  Вот воспользуемся тем, что сами по себе точки,
[03:21:12.600 --> 03:21:14.440]  как физические объекты, не меняются.
[03:21:16.840 --> 03:21:19.640]  Так, ну давайте заведем такой вектор векторов просто, да?
[03:21:20.600 --> 03:21:22.240]  Спрашивается, вот внимание, вопрос.
[03:21:23.200 --> 03:21:25.960]  Каков суммарный размер этого вектора векторов будет?
[03:21:27.480 --> 03:21:28.840]  Ну а n лог, да, 10, ну да.
[03:21:30.800 --> 03:21:33.680]  А, ну, кстати, да, кстати, жатия, конечно, можно уж тут честно написать,
[03:21:33.680 --> 03:21:35.640]  что даже не 10 в пятый, а реально n.
[03:21:37.960 --> 03:21:40.400]  Даже минус, ну будем честны, даже минус 1, в общем-то.
[03:21:43.320 --> 03:21:47.440]  Вот, тогда замечаем, что каждая точка попадет не более,
[03:21:47.440 --> 03:21:50.920]  чем в, соответственно, n отрезочков.
[03:21:53.120 --> 03:21:55.360]  То есть не более, чем логарифом n отрезочков,
[03:21:55.560 --> 03:21:58.040]  в общем, даже не от логарифма, а буквально логарифом.
[03:21:59.680 --> 03:22:00.560]  Как мы помним, да?
[03:22:01.160 --> 03:22:04.680]  Поэтому получается, что суммарно получается этих отрезочков,
[03:22:05.080 --> 03:22:07.240]  то есть суммарная длина всех массивов n лог n.
[03:22:07.240 --> 03:22:09.280]  То есть какие-то массивы большие, какие-то маленькие,
[03:22:09.280 --> 03:22:10.560]  но суммарная длина n лог n.
[03:22:11.360 --> 03:22:11.920]  Удобно, да?
[03:22:13.520 --> 03:22:13.880]  Вот.
[03:22:15.640 --> 03:22:16.080]  Вот.
[03:22:18.440 --> 03:22:20.600]  Но теперь просто идея, просто какая будет?
[03:22:22.720 --> 03:22:24.960]  То есть, но идея у нас будет просто такая,
[03:22:25.600 --> 03:22:28.080]  что когда нам придет какой-нибудь запрос по прямоугольнике,
[03:22:28.080 --> 03:22:30.840]  ну, во-первых, заметим, что мы с помощью классической там
[03:22:31.080 --> 03:22:33.520]  формулы включения и исключения можем свести задачу
[03:22:33.520 --> 03:22:38.800]  к поиску ответов на прямоугольниках с углом в точке 0,0, правда?
[03:22:39.680 --> 03:22:42.360]  Ну, помним, вот это, там минус вот это, минус вот это,
[03:22:42.360 --> 03:22:43.960]  плюс вот это, ну классика, да?
[03:22:44.920 --> 03:22:48.000]  Ну, то есть такие двумерные префиксные суммы, да?
[03:22:49.360 --> 03:22:49.680]  Вот.
[03:22:50.520 --> 03:22:51.720]  Но тогда идея теперь такая.
[03:22:51.720 --> 03:22:53.360]  Заметим, что вот этот вот подотрезок,
[03:22:53.920 --> 03:23:00.080]  мы теперь, мы умеем разбить на логарифм фенвиковых полуинтервалов, да?
[03:23:01.680 --> 03:23:04.200]  Ну, теперь идея такая, в каждом из этих полуинтервалов, да,
[03:23:04.680 --> 03:23:07.320]  лежат какие-то, то есть по x лежат какие-то точки.
[03:23:07.720 --> 03:23:12.560]  Надо взять, в каждом полуинтервале надо взять сумму каких-то точек,
[03:23:12.720 --> 03:23:14.120]  но не всех, а каких?
[03:23:14.960 --> 03:23:19.160]  А только тех, у которых y лежат в заданном подотрезке, правда?
[03:23:20.160 --> 03:23:23.160]  Но при этом заметим, что внутри каждого множества
[03:23:23.360 --> 03:23:27.400]  нас интересуют только точки, то есть хорошие для нас точки,
[03:23:27.400 --> 03:23:30.840]  которые попадают в задний диапазон по y и плохие все остальные.
[03:23:32.200 --> 03:23:33.880]  Поэтому идея оказывается следующей.
[03:23:34.200 --> 03:23:39.400]  А давайте внутри каждого этого tf эти точки отсортируем по y.
[03:23:39.920 --> 03:23:42.440]  И более того, не просто точки отсортируем по y,
[03:23:42.440 --> 03:23:45.520]  а на получившемся массиве размера, то сколько там точек получилось,
[03:23:45.520 --> 03:23:47.960]  забабахаем еще одного Федрика.
[03:23:50.840 --> 03:23:53.920]  Ну вот, тогда, то есть единственная только разница будет,
[03:23:53.920 --> 03:23:57.600]  что какие там бывают y, и это вам придется, то есть там,
[03:23:57.600 --> 03:24:01.000]  в каждом фенвике, перед запуском фенвика, еще и бинпоиском искать.
[03:24:05.160 --> 03:24:06.160]  Чего?
[03:24:10.320 --> 03:24:12.640]  Ну, то есть у вас там есть все точки отсортированные по y.
[03:24:12.640 --> 03:24:15.320]  То есть вы находитесь в каком диапазоне находится интересующая вас точка
[03:24:15.320 --> 03:24:19.000]  и ищите сумму на этом отрезке с помощью уже внутреннего фенвика.
[03:24:25.840 --> 03:24:26.840]  Ну, по сути, да.
[03:24:28.040 --> 03:24:29.280]  Ну, то есть в переводе говорят, да.
[03:24:29.760 --> 03:24:34.480]  То есть скажешь так, внутри каждого ttf вы храните отсортированный массив
[03:24:34.480 --> 03:24:37.680]  по y и фенвик на этих чиселках на нем.
[03:24:39.920 --> 03:24:43.840]  Нет, нам нужна не количество точек, а сумма чиселок.
[03:24:44.720 --> 03:24:46.840]  Да, если было количество точек, то да.
[03:24:47.520 --> 03:24:48.920]  Но нам нужна сумма чиселок.
[03:24:48.920 --> 03:24:51.160]  И более того, чиселки иногда еще и меняются.
[03:24:52.920 --> 03:24:54.840]  Нет, игроки не меняются, меняются чиселки.
[03:24:55.440 --> 03:24:59.240]  Но чтобы поменять чиселку понятно, надо полезть во все tf-ки
[03:24:59.240 --> 03:25:02.520]  и внутри каждой tf-ки сделать изменение в точке в дереве фенвика.
[03:25:03.480 --> 03:25:06.400]  То есть вот такая, то есть заметим, что такое решение тоже работает
[03:25:06.400 --> 03:25:07.960]  за лог квадрат n.
[03:25:10.160 --> 03:25:13.760]  Ну, памяти она требует n-лог n и, конечно, по Константе значительно проще.
[03:25:14.440 --> 03:25:17.080]  На самом деле, у этого решения Константа уже порядка восьми,
[03:25:17.080 --> 03:25:20.400]  на самом деле, семьдесяти вообще, потому что мы делаем четыре разбиения.
[03:25:20.880 --> 03:25:24.040]  В разбиении мы заходим в лог фенвиков.
[03:25:24.280 --> 03:25:27.480]  Вон, в фенвиков мы делаем бабин поиска.
[03:25:28.600 --> 03:25:30.080]  Да, но при этом...
[03:25:30.960 --> 03:25:35.120]  Но это компенсируется тем, что во многих этапах, в половине из этих фенвиков
[03:25:35.120 --> 03:25:36.120]  очень мало точек.
[03:25:36.640 --> 03:25:42.880]  Поэтому вы и тут будете далеко не всегда скакать за логорифом,
[03:25:42.880 --> 03:25:46.200]  и внутри каждого фенвика будете не за реально логорифом n-скакать.
[03:25:50.520 --> 03:25:51.520]  Да, если еще это...
[03:25:52.200 --> 03:25:54.400]  Можно, но нет, можно, кстати, да.
[03:25:55.560 --> 03:25:58.720]  Ну да, ну да, так что, в принципе, это в принципе рекомендует
[03:25:58.720 --> 03:26:00.720]  даже просто уже Сергей Капелевич.
[03:26:06.200 --> 03:26:08.360]  Внутри деревоотресков деревоотрески.
[03:26:12.800 --> 03:26:15.800]  Да, ну единственная проблема, что мы тут этого не делаем.
[03:26:15.800 --> 03:26:16.800]  Да, но...
[03:26:18.440 --> 03:26:19.440]  Ну хорошо, да.
[03:26:20.240 --> 03:26:23.240]  Нет, это правда, да, можно было, конечно, тут это, действительно,
[03:26:23.240 --> 03:26:26.840]  отсортировать все точки по игроку и делать полный протокол, действительно, да,
[03:26:26.840 --> 03:26:28.160]  и было бы примерно то же самое.
[03:26:29.280 --> 03:26:32.360]  Но как бы по фенвику, наверное, памяти все-таки будет жраться чуть меньше.
[03:26:33.360 --> 03:26:34.880]  Можно делать просто фенвик.
[03:26:35.880 --> 03:26:39.600]  Можно, а можно сделать просто фенвик, фенвик, да.
[03:26:40.280 --> 03:26:43.000]  Но в принципе, начиная с этого момента, мы тут обсуждаем технологии,
[03:26:43.000 --> 03:26:45.680]  которые, в общем-то, в которых, конечно, фенвик прекрасно заменяется
[03:26:45.680 --> 03:26:48.000]  на деревоотресков с операциями снизу, на самом деле.
[03:26:48.640 --> 03:26:51.400]  Но разница будет только в том, что деревоотресков будет жрать
[03:26:51.400 --> 03:26:52.400]  в два раза больше памяти.
[03:26:53.680 --> 03:26:55.680]  Или, ну или, да.
[03:26:57.200 --> 03:26:59.560]  Ну или да, но тогда, ну вот.
[03:26:59.560 --> 03:27:03.200]  Ну вот, но это уже, ну, смотри.
[03:27:04.480 --> 03:27:05.800]  Так, сколько у нас времени?
[03:27:13.480 --> 03:27:14.200]  Так, значит, смотрите.
[03:27:15.120 --> 03:27:15.920]  Так, ну это ладно.
[03:27:16.520 --> 03:27:21.480]  Значит, так что такая вот, ну вот, то есть такое вот решение из
[03:27:21.480 --> 03:27:24.360]  залог квадрат, такой вот фенвик, фенвик, такая вот полезная технология.
[03:27:25.360 --> 03:27:30.360]  Ну вот, но есть и другая технология, которая работает, когда обвалится это.
[03:27:32.360 --> 03:27:39.360]  А это обвалится, если, например, вы захотите, ну скажем, присваивать на прямоугольнике.
[03:27:42.360 --> 03:27:47.360]  Да, мало кто знает, но в деревеотресках иногда требует присваивать не один
[03:27:47.360 --> 03:27:49.360]  элемент, а прям несколько подряд идущих скопов.
[03:27:50.360 --> 03:27:54.360]  Ну я думаю, не надо сейчас вам рассказывать технологию отложенных операций, естественно, да?
[03:27:55.360 --> 03:27:56.360]  Вот, ну как-то да.
[03:27:57.360 --> 03:28:00.360]  То есть скорее всего, я думаю, еще на уровне тестирования в продвинутый поток проверялась,
[03:28:00.360 --> 03:28:03.360]  что вы как бы этой технологией так или иначе владеете, да.
[03:28:05.360 --> 03:28:11.360]  Ну вот, ну скажем так, я все-таки поверю, что технологию отложенных операций вам на презентации показывать не надо.
[03:28:12.360 --> 03:28:13.360]  Хотя, Кириль, да.
[03:28:17.360 --> 03:28:18.360]  Да.
[03:28:20.360 --> 03:28:22.360]  Если хотим за n лог квадрат.
[03:28:23.360 --> 03:28:29.360]  А вот смотрите, а вот, нет, ну на самом деле сейчас посмотрим, но на самом деле тут технология
[03:28:29.360 --> 03:28:31.360]  оказывается весьма неожиданной.
[03:28:32.360 --> 03:28:34.360]  Но на самом деле она очень похожа на деревоотреска.
[03:28:34.360 --> 03:28:36.360]  Что говорит деревоотреска? У нас есть массив.
[03:28:37.360 --> 03:28:41.360]  Так, ну во-первых, давайте у нас будет ячейка, которая отвечает за весь массив, храним в нем сумму
[03:28:41.360 --> 03:28:44.360]  и какие-нибудь отложенные операции на весь массив, да.
[03:28:44.360 --> 03:28:48.360]  А потом дальше массив делим на две половинки, в каждом из них типа делаем то же самое рекурсивно.
[03:28:49.360 --> 03:28:50.360]  Правда?
[03:28:51.360 --> 03:28:52.360]  Вот.
[03:28:53.360 --> 03:28:56.360]  И теперь, а теперь предлагается другая версия.
[03:28:58.360 --> 03:29:00.360]  Значит, да, то есть теперь задача, да.
[03:29:00.360 --> 03:29:04.360]  То есть делаем тоже задачу, то есть надо искать сумму на прямоугольники и скажем присваивание на прямоугольники.
[03:29:04.360 --> 03:29:07.360]  Ну или там, я не знаю, прибавление еще на прямоугольники может там.
[03:29:07.360 --> 03:29:09.360]  Все что угодно.
[03:29:10.360 --> 03:29:11.360]  И тут смотрите.
[03:29:12.360 --> 03:29:15.360]  И так, значит, тут возникает такая неожиданная идея.
[03:29:15.360 --> 03:29:18.360]  Значит, тоже мы сейчас построим веселое дерево.
[03:29:19.360 --> 03:29:20.360]  Вот.
[03:29:23.360 --> 03:29:25.360]  Значит, смотрите, идея такая.
[03:29:26.360 --> 03:29:30.360]  Значит, тоже массив мы делили пополам, ну или примерно пополам.
[03:29:30.360 --> 03:29:34.360]  Так вот, здесь мы точки тоже поделим по х примерно пополам.
[03:29:34.360 --> 03:29:37.360]  Но пополам не по х, не в смысле х пополам возьмем.
[03:29:37.360 --> 03:29:40.360]  А чтобы у нас слева и справа точечек было примерно по н пополам.
[03:29:41.360 --> 03:29:42.360]  Ну плюс-минус один.
[03:29:43.360 --> 03:29:44.360]  Вот.
[03:29:44.360 --> 03:29:45.360]  И отправим нот.
[03:29:45.360 --> 03:29:47.360]  И скажем, что у нас есть вот такие ноты.
[03:29:47.360 --> 03:29:48.360]  Вот такие ноты.
[03:29:49.360 --> 03:29:51.360]  Ну вот и скажем, что это вот это был корень.
[03:29:51.360 --> 03:29:52.360]  Это будут дети корня.
[03:29:53.360 --> 03:29:55.360]  В каждом из детей корня.
[03:29:56.360 --> 03:29:59.360]  Да, прям звучит как какой-то пафосный голливудский сериал.
[03:29:59.360 --> 03:30:01.360]  Дети, корня, там, я не знаю.
[03:30:02.360 --> 03:30:03.360]  Вот.
[03:30:03.360 --> 03:30:07.360]  Хотя это просто будет какой-то, да, дети, корня, корень, криминальный авторитет.
[03:30:09.360 --> 03:30:10.360]  Да, корень.
[03:30:10.360 --> 03:30:12.360]  Да, он же там Вася Корнев.
[03:30:12.360 --> 03:30:15.360]  Там родился с 1979 года рождения, да.
[03:30:16.360 --> 03:30:17.360]  Да, какой-то.
[03:30:17.360 --> 03:30:18.360]  Не, ну неважно.
[03:30:19.360 --> 03:30:20.360]  Ладно, так вот.
[03:30:20.360 --> 03:30:24.360]  Значит, в каждой у детей корня мы тоже делим точки пополам.
[03:30:24.360 --> 03:30:26.360]  Но на это прям по игроку.
[03:30:31.360 --> 03:30:32.360]  Во.
[03:30:35.360 --> 03:30:36.360]  Чего?
[03:30:36.360 --> 03:30:38.360]  Тут четыре точки, тут четыре точки.
[03:30:39.360 --> 03:30:40.360]  По количеству точек.
[03:30:40.360 --> 03:30:44.360]  Да, это важно, что тут, конечно, конкретные границы могли пойти по-разному.
[03:30:46.360 --> 03:30:48.360]  Так, что тут мы делаем?
[03:30:48.360 --> 03:30:53.360]  Так, ну тут в каждой, в каждом внуке, естественно, мы тоже делим точки, но уже по иксу.
[03:30:53.360 --> 03:30:55.360]  То есть мы каждый раз меняем координату.
[03:30:56.360 --> 03:30:57.360]  Во.
[03:30:57.360 --> 03:30:58.360]  Вот так вот.
[03:30:59.360 --> 03:31:02.360]  Ну и так вот идем до тех пор, пока в какой-то вершине не останется.
[03:31:02.360 --> 03:31:06.360]  То есть там, если в вершине осталась одна точка, то, в общем-то, рекульсия на этом заканчивается.
[03:31:07.360 --> 03:31:09.360]  Вот, примерно вот так это будет.
[03:31:12.360 --> 03:31:13.360]  Вот так.
[03:31:14.360 --> 03:31:15.360]  Этым построение делаем.
[03:31:15.360 --> 03:31:17.360]  Да, это мы так построили.
[03:31:18.360 --> 03:31:24.360]  Ну, построение такое можно, естественно, сделать в зерлогране, потому что конкретную медиану там по иксу и по игроку можно найти за линию.
[03:31:25.360 --> 03:31:30.360]  Ну или там более простая технология, конечно, отсортировать сначала там.
[03:31:30.360 --> 03:31:39.360]  То есть, допустим, отсортировать, ну хотя, да, можно отсортировать точки по иксу и там в каждой подмассив дополнительно еще и по игроку отсортировать.
[03:31:40.360 --> 03:31:41.360]  Хотя, ну вот.
[03:31:41.360 --> 03:31:42.360]  Ну и там как-то адекватно пилить.
[03:31:42.360 --> 03:31:43.360]  Ну, неважно.
[03:31:43.360 --> 03:31:45.360]  В общем, так или иначе, собственно, делается.
[03:31:47.360 --> 03:31:48.360]  А теперь идея такая.
[03:31:49.360 --> 03:31:52.360]  А теперь, ну вот, а теперь, предположим, приходит к вам запрос.
[03:31:52.360 --> 03:31:56.360]  Вот давайте вспомним, как у нас работают технологии отложенных операций в деревеотресках.
[03:31:57.360 --> 03:32:00.360]  То есть обычно одна из стандартных технологий звучит так.
[03:32:01.360 --> 03:32:08.360]  Вот, допустим, мы себе, мы тут себе захотели, вот давайте я тут деревоотресков нарисую.
[03:32:10.360 --> 03:32:18.360]  Вот на каком-нибудь вот подобного рода подотрески я тут неожиданно захотел что-то сделать.
[03:32:20.360 --> 03:32:21.360]  Вот там присвоить.
[03:32:21.360 --> 03:32:23.360]  Что я тогда буду делать?
[03:32:23.360 --> 03:32:29.360]  Я пойду в эту вершину и скажу, так, эта вершина пересекается с моим запросом, но целиком в него не вложена.
[03:32:29.360 --> 03:32:31.360]  Поэтому я пойду сюда-сюда.
[03:32:32.360 --> 03:32:37.360]  Так, эта вершина пересекается с моим запросом, но не вложена в него, поэтому пойду сюда-сюда.
[03:32:37.360 --> 03:32:39.360]  Так, эта пересекается, еще пойду сюда-сюда.
[03:32:39.360 --> 03:32:45.360]  Эта вершина не пересекается с моим запросом, поэтому, собственно, я из нее не пойду.
[03:32:46.360 --> 03:32:51.360]  А вот эта вершина в него целиком вложена, поэтому я, вот эта вложена, эта вложена,
[03:32:51.360 --> 03:32:55.360]  поэтому я здесь храню какую-то отложенную операцию, которая будет нам говорить, что мы сюда,
[03:32:55.360 --> 03:33:01.360]  на всем этом подотреске присваиваем наш новый элемент, но дети до поры до времени этого не знают.
[03:33:03.360 --> 03:33:04.360]  Ну вот, помните, да?
[03:33:05.360 --> 03:33:09.360]  Вот, потом, значит, вернулись, значит, здесь, соответственно, тоже там сходили куда-то сюда-сюда,
[03:33:09.360 --> 03:33:13.360]  но здесь мы сразу присвоили, а здесь мы сразу выбросились.
[03:33:18.360 --> 03:33:23.360]  Ну а дальше потом говорилось, что если мы хотим, то есть если нам после этого пришла информация о том,
[03:33:23.360 --> 03:33:29.360]  что давайте теперь еще вот на каком-нибудь вот этом подотреске присвоим еще что-нибудь, то что мы делаем?
[03:33:30.360 --> 03:33:34.360]  Мы просто пишем, что вот здесь присваиваем и здесь присваиваем, по сути, да?
[03:33:35.360 --> 03:33:41.360]  То есть тогда оказывается, что эти элементы, ой, я двоечка, я троечка, на самом деле вы галочка,
[03:33:41.360 --> 03:33:47.360]  но я вам пока об этом не скажу, а потом дедушка сверху, да, да, да, да.
[03:33:49.360 --> 03:33:54.360]  Вот, ну потому что если, например, потребуется узнать, кто вот этот элемент, то как произойдет?
[03:33:54.360 --> 03:33:59.360]  Мы пойдем, так, мне нужно узнать, кто вот этот элемент, хорошо, спрашиваем, так, надо узнать, кто этот элемент,
[03:33:59.360 --> 03:34:05.360]  сейчас одну минуточку, так, дорогие дети, у меня тут для вас важные сведения, вы нолики,
[03:34:05.360 --> 03:34:12.360]  так в смысле, вы же сказали галочки, а ты что, детям передал? Нет, вот слава богу, и не надо, это галочки,
[03:34:12.360 --> 03:34:18.360]  ну вот, это нолик, отлично, ну все, передали, пошли, так, кто у тебя ребенок?
[03:34:18.360 --> 03:34:23.360]  Так, сейчас мне им нужно передать важную информацию, передаем, проходим, поздравляю, я нолик.
[03:34:25.360 --> 03:34:30.360]  Вот, ну вот так выглядит классическая технология отложенных операций, да, я думаю там ничего нового там,
[03:34:30.360 --> 03:34:38.360]  там ничего фантастически нового я сейчас для вас не рассказал, вот, вот тут я ничего нового,
[03:34:38.360 --> 03:34:45.360]  ну вот, так вот, идея такая, а давайте-ка то же самое сделаем вот в этом вот,
[03:34:46.360 --> 03:34:54.360]  то есть, предположим, что нам тут неожиданно пришел запрос, найдите какую-нибудь сумму на вот таком прямоугольнике,
[03:34:58.360 --> 03:35:08.360]  так, смотрите, тогда говорим, так, значит, мы, значит, наш запрос как бы пересекается, видимо, с корнем,
[03:35:08.360 --> 03:35:16.360]  но как бы не, но наш корень в него не вложен, поэтому мы идем влево, идем вправо, да, так, смотрим,
[03:35:16.360 --> 03:35:22.360]  вот этот вот как бы левая вершина отвечает за прямоугольник вот такой, ну ладно, там на самом деле можно
[03:35:22.360 --> 03:35:30.360]  конкретные лавербаунды, оперебаунды поставить, естественно, да, так, пересечение есть, но вложенности нет,
[03:35:30.360 --> 03:35:36.360]  поэтому тоже, значит, идем там куда-то влево-вправо, вот, то есть, вот эти все ячеечки тоже обрабатываются,
[03:35:36.360 --> 03:35:42.360]  вот это ячейко тут сразу как бы мы ее берем целиком потому что она в нас целиком, а, хотя нет,
[03:35:42.360 --> 03:35:48.360]  сначала делим вот так, потом делим сюда, но это мы обрабатываем целиком потому что оно целиком вложено,
[03:35:48.360 --> 03:35:54.360]  нам, так, тут точка тоже целиком вложена, поэтому входим, хотя на самом деле вот здесь нам бы
[03:35:54.360 --> 03:35:59.360]  наверное узе могли сказать, что тут на самом деле прямоугольник уже вот такой, он не пересекается с нашем,
[03:35:59.360 --> 03:36:06.560]  с нашим, поэтому мы можем уже на уровне вот этой ячейки выброситься. Ну и так далее. То есть заметим,
[03:36:06.560 --> 03:36:11.920]  что с помощью такой технологии в принципе можно делать и сумму искать и какие-нибудь отложенные
[03:36:11.920 --> 03:36:23.240]  присваивания тоже пожалуйста. А какие проблемы? Нет, а что с пушами, а что такое? У каждой вершины
[03:36:23.240 --> 03:36:27.600]  там два ребенка, значит мы им передаем. То есть с точки зрения суммы как бы никаких проблем,
[03:36:27.600 --> 03:36:33.080]  потому что сумма, то есть если вы на всем прямоугольнике что-то присвоили, значит сумма
[03:36:33.080 --> 03:36:42.000]  будет это сколько точек в прямоугольнике умножить на что вы присвоили. Да, вот возникает основной
[03:36:42.000 --> 03:36:46.920]  вопрос. То есть как бы технология, то есть понятно, что это будет работать в плане находить
[03:36:46.920 --> 03:36:55.080]  правильный ответ. Но теперь самый интересный вопрос, а за какую асимптотику это будет работать?
[03:36:55.080 --> 03:37:11.560]  Так, 4 лог квадрат. Умножить на лог, я надеюсь, хотя бы. Ух ты, корень из лог умножить на лог.
[03:37:11.560 --> 03:37:21.720]  Так, да, сколько вариантов-то, да? Так, ну вот да, ну на самом деле,
[03:37:21.720 --> 03:37:27.840]  действительно, что гадать, давайте попробуем записать. Но сейчас у нас, но сразу предупреждаю,
[03:37:27.840 --> 03:37:36.400]  по крайней мере, в той технологии, которая есть у меня тэшек будет долго. Тэшек. Значит поехали.
[03:37:36.400 --> 03:37:44.840]  Значит работать будем так. Значит внимание. Но на самом деле, давайте будем говорить так. В
[03:37:44.840 --> 03:37:49.920]  каждый момент времени будем считать, что зеленый прямоугольник, он на самом деле внутри синего
[03:37:49.920 --> 03:37:55.160]  прямоугольника ячеечки. Ну потому что в каждый момент времени можно от зеленого
[03:37:55.160 --> 03:38:00.440]  прямоугольника оставлять только его пересечение с синем, правда? Но теперь возникает, но самое,
[03:38:01.160 --> 03:38:07.240]  начнем вот с чего. То есть будем т с индексом вот таким вот.
[03:38:07.240 --> 03:38:19.800]  От n. Значит предположим, что нам, мы хотим вычислить ответ, где у нас n точек, ну вот,
[03:38:19.800 --> 03:38:24.560]  и зелененький прямоугольник как-то внутри этого синего расположен, мы вообще не знаем как.
[03:38:24.560 --> 03:38:31.920]  Тогда какие у нас два варианта бывают? У нас на самом деле может быть два варианта,
[03:38:31.920 --> 03:38:38.600]  потому что вот этот вот, потому что мы тут по х распиливаем, да? И тут два варианта. Этот распил,
[03:38:38.600 --> 03:38:47.880]  распилил зеленый прямоугольник или не распилил? Если он его не распилил, то это получается от
[03:38:47.880 --> 03:39:03.120]  единицы плюс т с абсолютно тем же индексом, но от n пополам. А если распилил, то смотри,
[03:39:03.120 --> 03:39:09.360]  а если распил произошел, то что тогда происходит? Ну тогда заметим следующее, что мы точно знаем,
[03:39:09.360 --> 03:39:16.000]  что наш зеленый запрос прижатка к вертикальной границе, правда? Но теперь заметим, что дальше
[03:39:16.120 --> 03:39:20.960]  мы будем как бы уже делить не по иксу, а по игроку, да? Поэтому логично запрос так мысленно,
[03:39:20.960 --> 03:39:27.240]  ну во-первых, повернуть на 90 градусов, а во-вторых, еще заметить, что как бы прижат,
[03:39:27.240 --> 03:39:31.200]  и тогда он будет прижат снизу, но прижат снизу и прижат сверху, это для нас одно и тоже будет
[03:39:31.200 --> 03:39:38.960]  более-менее, да? Но это означает, что гарантируется, что запрос будет выглядеть примерно вот так.
[03:39:38.960 --> 03:40:02.840]  Вот так. Вот. Ну тоже плюс 100 единиц. Вот. Ну и так у нас появилась новая рекуррента. Ну ничего
[03:40:03.720 --> 03:40:12.280]  страшного. Как боится, глаза боятся, руки делают. Говорим в этом месте мы. Начали говорим,
[03:40:12.280 --> 03:40:19.960]  что t от этого n равно чему? Ну два варианта тут. Распил по иксу, он как бы этот зубчик заденет
[03:40:19.960 --> 03:40:29.440]  или не заденет? Какие у нас варианты? Если он не заденет, то получится 2t от n пополам. Нет,
[03:40:29.440 --> 03:40:37.240]  вру. Да, если не заденет, то наоборот. Один там плюс от единицы, но тут тогда будет зубчик уже,
[03:40:37.240 --> 03:40:49.240]  правда, и для нас это будет принципиально уже вот такого вида. Чего? Нет, потому что здесь как бы
[03:40:49.240 --> 03:40:56.240]  да там будет произойдет, что распил не распилил зеленый отрезок, поэтому получится, что там в
[03:40:56.240 --> 03:41:06.160]  нижней два. Да-да-да, два нужна, поэтому я тут ее так приписал, да. А для удобства, потому что мы
[03:41:06.160 --> 03:41:11.560]  сейчас предполагаем, что мы сначала будем делить по иксу, потом в детях по игроку, во внуках по иксу
[03:41:11.560 --> 03:41:17.360]  и так далее. Но когда мы переходим на уровень ниже, логично повернутый 90 градусов, что там тоже
[03:41:17.360 --> 03:41:26.520]  типа сначала по иксу, потом по игроку и так далее. Вот такая какая-то идея. Вот, ну значит зубчик у нас
[03:41:26.520 --> 03:41:33.160]  либо оказался просто такой же, но горизонтальный, либо он поделился, но тогда у нас оказывается такой
[03:41:33.160 --> 03:41:41.920]  более продвинутый случай. Это называется прижатый к углу, в чем, кстати, абсолютно неважно какому из
[03:41:41.920 --> 03:41:57.520]  четырех. Так, ну что, идем дальше. Так, значит поехали. Так, ну в порядке БФС у нас появился горизонтальный зубчик,
[03:41:57.520 --> 03:42:06.040]  но тем, что, как бы, ну, Вертика, просто этот мы, потому что мы и тот, и тот будем по иксу распиливать.
[03:42:06.040 --> 03:42:11.080]  Поэтому, когда вы тут распиливаете по иксу, у вас тут может образоваться два вот таких зубчика,
[03:42:11.080 --> 03:42:16.560]  а там образуются не вот такие, то есть не такие уголки, а образуются там может быть один зубчик и
[03:42:16.560 --> 03:42:24.080]  один там еще. Такая веселая вещь. Поэтому, значит пишем, значит смотрите, вот тот важный момент. Тут
[03:42:24.080 --> 03:42:31.240]  нам либо повезет, либо не повезет. То есть нам повезет, если я распил, не задел зубчик, да? Тогда
[03:42:31.240 --> 03:42:44.800]  получится T от, значит, этой же штуки от N пополам плюс O от единиц. Ну да. Вот. Точно, да, на этот раз
[03:42:44.800 --> 03:42:49.640]  повернутый, то есть мы вот свели задачу к уже известной рекурренте. Но может так получиться,
[03:42:49.640 --> 03:42:55.920]  что распил произойдет. Но что тогда произойдет? Тогда, на самом деле, тут будет T от N пополам,
[03:42:55.920 --> 03:43:05.080]  плюс T от N пополам, плюс O от единиц. Где, смотрите, тут T, значит тут будет прям тот же самый зубчик,
[03:43:05.080 --> 03:43:14.440]  а тут будет уже вот наша полосочка. Так, ну вообще сразу можно, наверное, заметить, что вот этот
[03:43:14.440 --> 03:43:19.520]  вот случай можно выкинуть, потому что он маржагируется вот этим случаем, правда? Вот.
[03:43:19.520 --> 03:43:23.680]  Вот так.
[03:43:23.680 --> 03:43:43.000]  Ну нормально, Павел. Идем дальше. Так, кто у нас там в порядке? БФС идет следующий. Так,
[03:43:43.000 --> 03:43:56.200]  уголочек. Поехали. Уголочек от N равно. Так, ну уголочек. Поехали. Уголочек. Так,
[03:43:56.200 --> 03:44:02.840]  ну на самом деле аналогично. Тут есть какой-то вот этот вот как бы как бы либо распил произойдет,
[03:44:02.840 --> 03:44:07.000]  либо распил не произойдет. Но уголочек так и так останется. Поэтому я как бы один случай тут
[03:44:07.000 --> 03:44:12.320]  даже писать не буду. А просто, то есть так поменьше, что он типа есть, то на самом деле он нас не
[03:44:12.320 --> 03:44:23.920]  интересует. Получится опять T от N пополам, плюс T от N пополам, плюс O от единиц. Где уголочек
[03:44:23.920 --> 03:44:35.560]  будет? Ну где опять тут будет уголочек? А тут будет, соответственно, да, вот такой вот. Не,
[03:44:35.560 --> 03:44:43.760]  ну что ее и префикс это уже хорошо. Так, хорошо, давайте, кто там у нас следующий? Так, этого
[03:44:43.760 --> 03:44:51.280]  нарисовали уголочек. Ну да, в порядке БФС дальше идет вот это вот. Да, небо в клетку, друзья,
[03:44:51.280 --> 03:45:01.120]  в полосочку. Так, ну сейчас, как пойдет, погодите. Тут как бы, на этот раз тут как повезет. Может
[03:45:01.120 --> 03:45:05.800]  быть распил как бы и состоится, а может не состоится. И на этот раз это два содержательных
[03:45:05.800 --> 03:45:15.760]  случая. Потому что если распил не состоится, то получится горизонтальная полосочка. Вот, то есть
[03:45:15.760 --> 03:45:23.320]  либо произойдет горизонтальная полосочка, либо распил произойдет. Но тогда получится, по сути,
[03:45:23.320 --> 03:45:44.320]  2t от, не, префикса повернутого, такого префикса снизу. Так, значит идем дальше. Так, значит хорошо.
[03:45:44.320 --> 03:45:50.520]  Так, вертикальный зубчик так распилили. Что там у нас дальше появилось? А дальше у нас появился
[03:45:50.520 --> 03:46:03.920]  префикс. Так, вроде я пока ничего не забываю. Префикс. Ну, префикс от n равен. Ну понятно,
[03:46:03.920 --> 03:46:11.000]  что тут есть как бы случайно повезло. Если распил не произошел, то понятно. Если распил произошел,
[03:46:11.000 --> 03:46:18.040]  то тоже понятно. Потому что, смотрите, если распила не произошло, то получается повернутый
[03:46:18.040 --> 03:46:24.200]  префикс. А если распил произошел, то опять получится повернутый префикс и тоже ячейка,
[03:46:24.200 --> 03:46:29.400]  обработанная за O от единицы. Только на этот раз не в том, что она не пересеклась, а наоборот,
[03:46:29.400 --> 03:46:37.160]  что она прям хорошо пересеклась. Поэтому здесь оказывается очень удобно. Здесь оказывается,
[03:46:37.160 --> 03:46:46.840]  что это просто равно t от n пополам плюс O от единицы. И здесь это вот такой горизонтальный
[03:46:46.840 --> 03:47:00.640]  префикс. Вот. Так, кто там у нас дальше? Так, вот этого мы взяли. Так, это мы нарисовали. Так,
[03:47:00.640 --> 03:47:10.600]  теперь у нас. Так, теперь у нас вот эта штука. Ну, вот это, в смысле, вот это, да. Но здесь все
[03:47:10.600 --> 03:47:15.640]  просто. Тут любой распил приведет к тому, что тут будет 2t от вертикальной полосы, правда?
[03:47:15.640 --> 03:47:31.960]  N пополам и плюс O от единицы. Вот. Так, что еще? Нет, сейчас, нет, вертикальный префикс мы уже
[03:47:31.960 --> 03:47:40.120]  сделали. Вот этот надо сделать. Да. Так, ну сейчас, эту вертикальную полосу мы уже сделали. Так,
[03:47:40.120 --> 03:47:46.560]  теперь вот эта горизонтальная полоса теперь осталась. Вот это, но это не полоса, в смысле,
[03:47:46.560 --> 03:48:04.600]  да, вот эта штука. Так, от n она равна 2, ну, по сути, два префикса, да. Так. Так, ну что ж,
[03:48:04.600 --> 03:48:34.440]  так вроде система, так вроде все. Да, правда, что меньше. Так, вы вроде написали замкнутую
[03:48:34.440 --> 03:48:43.080]  систему тэшек, да? Нет, ну, я не знаю, вроде нет ли какой-то тэшки, которую мы тут, которую мы
[03:48:43.080 --> 03:48:50.600]  не расписали. То есть, как бы замкнутая система. Так, ну поехали, хорошо. Ну, значит, как получить,
[03:48:50.600 --> 03:48:58.640]  значит, ну, значит, как получить результат? Ну, на самом деле, заметим следующее. Давайте заметим,
[03:48:58.640 --> 03:49:07.280]  что вот если я вот тут вот эту штуку раскрою, вот, то у меня неожиданно, вот, то в принципе у меня
[03:49:07.280 --> 03:49:16.040]  автоматически получится, что это равно 2t от n делить на 4 плюс от единицы, да, где t, ну, в
[03:49:16.040 --> 03:49:24.800]  соответствии с вот этим, это 2t на префиксе. Так, и вот смотрите, какая прикольная рекуррента
[03:49:24.800 --> 03:49:33.360]  получилась t на префиксе от n равно 2t на префиксе от n делить на 4 плюс от единицы. Внимание, вопрос,
[03:49:33.360 --> 03:49:50.600]  чему равно t на префиксе? Да, логарифом. По какому основанию и от чего? Давайте вспоминаем мастер
[03:49:51.000 --> 03:49:57.080]  терему. Да, логарифом двойки по основанию 4.
[03:49:57.080 --> 03:50:15.680]  Да, поэтому да, но логарифом двойки по основанию 4 это 1 вторая, поэтому мы получаем, что это равно
[03:50:15.680 --> 03:50:27.680]  просто n в степени 1 вторая, ну, более именуемое среди мирного населения корень из n. Так,
[03:50:27.680 --> 03:50:32.560]  то раз это корень из n, то мы автоматически, конечно, выводим, что это тоже корень из n,
[03:50:32.560 --> 03:50:54.560]  да. Так, ну, что у нас там дальше? Так, дальше мы замечаем, что вот t, так. Чего? Где коэффициент
[03:50:54.560 --> 03:51:06.040]  2? Вот здесь? Ну, потому что когда, а откуда 2? Ну да, но только на какие две части? Если мы
[03:51:06.040 --> 03:51:10.840]  эту зеленую префикс на две части разделили, то одна из этих частей она покрыла прям весь
[03:51:10.840 --> 03:51:19.320]  прямоугольник. Вот, и так получается, значит, тут корень. Теперь давайте вот про эту штуку скажем.
[03:51:19.320 --> 03:51:24.480]  Значит, эта штука у нас равна либо ко вот отсюда прям сразу видим, что два корня, ну, то есть
[03:51:24.480 --> 03:51:32.400]  просто корень, да, либо эта штука равна горизонтальной полосе, которая там, которая на самом деле равна
[03:51:32.400 --> 03:51:46.320]  вертикальной полосе. Да, либо она вот равна двум вертикальным полосам. Да, то есть, ну, тут может
[03:51:46.320 --> 03:51:58.800]  быть, да, либо два корня сразу, либо вот тут вот n делить на 4 плюс 100 единиц. Вот, значит,
[03:51:58.800 --> 03:52:08.080]  соответственно, ну, то есть получается, да, тогда получается так, да, тогда легко по индукции
[03:52:08.080 --> 03:52:14.200]  доказать, что это тоже, что это так или иначе корень. Ну, потому что, смотрите, то есть, по сути,
[03:52:14.400 --> 03:52:20.160]  по сути, у нас так, мы несколько раз берем это n делим на 4, потом в корпент останавливаемся,
[03:52:20.160 --> 03:52:25.400]  берем корень, а потом возвращаемся. Причем, когда возвращаемся, говорю, что каждый раз,
[03:52:25.400 --> 03:52:34.640]  когда делили до 4, домножаем на 2. Получается буквально корень, правда? Вот. То есть получается,
[03:52:34.640 --> 03:52:42.040]  что это равно автоматический корень, но и это равно автоматический корень. Вот. Так, ну, что дальше?
[03:52:42.040 --> 03:52:50.920]  Так, что такое уголочек? Уголочек по этой логике получается это корень и z, плюс я же,
[03:52:50.920 --> 03:52:56.320]  плюс он же на n пополам. То есть, получится корень и z, плюс корень и z пополам, плюс корень и z на 4,
[03:52:56.320 --> 03:53:00.480]  плюс корень и z на 8 и так далее, да? Ну, очевидно, это геометрическая прогрессия,
[03:53:00.480 --> 03:53:05.360]  которая тоже схлопнется в корень. Там с какой-то более жирной константой.
[03:53:05.360 --> 03:53:14.960]  Там два плюс два корня из двух. Там какая-то константа, потому что там геометрическая
[03:53:14.960 --> 03:53:24.000]  прогрессия не штаром два, а шаром корень из двух. Вот. Вот. Ну, да. То есть, да, два плюс корень из
[03:53:24.000 --> 03:53:31.040]  двух. Там как-то это, но все равно корень из двух. Значит, тут корень из двух. Так. Так, ну, поехали.
[03:53:31.360 --> 03:53:42.880]  Кому мы тут уже, так сказать, привязали к корню? Так. Тут корень, тут корень. А, ну, то есть,
[03:53:42.880 --> 03:53:49.800]  что мы видим? А, ну, заметим, что вот от этой штуки мы можем избавиться, потому что мы эту вот
[03:53:49.800 --> 03:53:56.640]  мажорирующуюся штуку можем подставить сразу сюда. То есть, это равно от корня из n, прям единицу мы
[03:53:56.640 --> 03:54:05.400]  тоже туда вписываем. Плюс получается там t от себя любимого. Плюс t от там n делит на 4.
[03:54:05.400 --> 03:54:12.080]  Не, ну, просто от этих вот. Ну, я просто вместо вот этого подставляю сразу вот это равенство.
[03:54:12.080 --> 03:54:20.600]  И еще и замечаешь, что тут сразу кой. Поэтому тут получает, то есть, да, то есть t тоже от
[03:54:20.600 --> 03:54:27.320]  себя любимого рекурсивного. Вот с этим вот индексом. И отсюда автоматически получается,
[03:54:27.320 --> 03:54:33.240]  что опять корень из n, но на этот раз уже геометрическая прогрессия с еще лучшим шаром,
[03:54:33.240 --> 03:54:42.480]  который тоже корень из n. Вот. Так. Ну, и отсюда тогда что мы видим? А теперь мы видим, что мы тут
[03:54:42.480 --> 03:54:50.440]  несколько раз делим пополам и в какой-то момент плюнем и заявляем, что дальше корень. Получается,
[03:54:50.440 --> 03:54:58.760]  корень плюс какие-то единички, которых не больше, чем логарифам. Ну, мораль очень простая. Мы
[03:54:58.760 --> 03:55:13.120]  изобрели корневуху. Да. Значит, да. Эта структура данных называется kd дерева. Точнее, конкретно это
[03:55:13.120 --> 03:55:28.400]  называется 2d дерево. Потому что kd дерево то же самое в камерном пространстве. Нет. Смотря какая
[03:55:28.400 --> 03:55:34.680]  цель. Если у тебя задача вывести, скажем, все точки, которые попали в прямоугольник, то это
[03:55:34.680 --> 03:55:43.080]  будет работать за о от корня из n плюс, там, скорее всего, плюс, собственно, все точки. Вот так скажем.
[03:55:43.080 --> 03:55:54.840]  Нет. За о от n тут еще вопрос, какие запросы ищешь. Потому что часто к 2d дереву пытаются применить,
[03:55:54.840 --> 03:55:59.360]  потому что 2d дерева пытаются, то есть это какие запросы. Мы тут сейчас пользуемся тем,
[03:55:59.360 --> 03:56:04.440]  что у нас точки фиксированы, и мы делили прям вот так вот жестко. Потому что на самом деле
[03:56:04.560 --> 03:56:10.520]  на практике это дерево любят использовать еще, когда точки еще добавляются и исчезают.
[03:56:10.520 --> 03:56:18.680]  То есть там точки добавляются и исчезают. Если они как-то добавляются рандомно, то и тут и
[03:56:18.680 --> 03:56:24.120]  работает. Дерево будет более-менее адекватно. Или часто, например, или еще там бывает такой
[03:56:24.120 --> 03:56:31.320]  запрос. Найдите, пожалуйста, а сколько у меня находится точек, которые лежат не в заднем
[03:56:31.320 --> 03:56:42.920]  прямоугольнике, а в заданной окружности? Ну вот, или еще. И в окружности тоже там надежда,
[03:56:42.920 --> 03:56:49.080]  что давайте делать тоже абсолютно тем же методом, как и в любом дереве отрезков. То есть если мы
[03:56:49.080 --> 03:56:54.240]  попали в прямоугольник, который в окружности даже не пересекается, то мы выбрасываемся. В
[03:56:54.240 --> 03:56:59.000]  адекватно каких-то рандомно распределенных точек нормально, но контртест подсунуть можно.
[03:56:59.000 --> 03:57:10.280]  Мы пока решаем задачу вида, что все запросы делаются на прямоугольниках со сторонами
[03:57:10.280 --> 03:57:19.280]  параллельными, а всем координат. Здесь мы просто говорим, что это сумма и прибавления или
[03:57:19.280 --> 03:57:26.920]  присваивание, потому что когда мы говорим про что-то двумерное, на самом деле уже сложно что-то
[03:57:26.920 --> 03:57:53.080]  говорить. Почему? Будет. Дать правду другая технология, мы ее тоже обсудим. Нет, по-разному,
[03:57:53.080 --> 03:58:00.000]  но это если прибавление, потому что вот эта технология кушает и присваивание. То есть это
[03:58:00.000 --> 03:58:06.360]  да. Правда, она работает за корень. 2D дерево работает за корень, но в принципе еще есть
[03:58:06.360 --> 03:58:12.360]  просто сведения из науки, что есть вот камерное дерево, оно отличается тем, что мы делим на х,
[03:58:12.360 --> 03:58:17.720]  потом на y, потом на z, потом на x, потом на y, потом на z, очень по кругу бежим. Так вот,
[03:58:17.720 --> 03:58:32.120]  там асимптотика оказывается n в степени 1 минус 1 делить на d. Ну, в смысле на k, да? Вот.
[03:58:32.120 --> 03:58:42.360]  Ну да, при k равно 1,2 получился наш корень. Вот. Так что вот такая вот красота получается,
[03:58:42.360 --> 03:58:49.680]  маленькая, приятная. Вот. То есть до этого я скорее всего, до доказательства этого скорее
[03:58:49.680 --> 03:58:57.760]  всего мы не доживем, потому что нам уже двумерного случая вон так хватило, но там нет, но там,
[03:58:57.760 --> 03:59:02.440]  честно скажем, там надо отдельно думать на тему того, то есть нельзя ли эти конкуренты в общем
[03:59:02.440 --> 03:59:07.280]  случае как-то все-таки схлопнуть по случаям или как-то вот более общим образом рассматривать,
[03:59:07.280 --> 03:59:10.520]  ну или может быть там у каких-то авторов есть более продвинутые доказательства.
[03:59:10.520 --> 03:59:23.040]  Чего? Нет, пишутся они как в дереве отрезков. Ты приходишь в вершину, значит,
[03:59:23.040 --> 03:59:34.760]  смотришь, у него такой прямоугольник. Да, только, ну разве что, да. Но это обычно не проблема, да.
[03:59:34.760 --> 03:59:42.320]  Нет, там еще в каждой вершине надо хранить, почему конкретно вы попилили или в каждой вершине в
[03:59:42.320 --> 03:59:47.800]  явном виде хранить свой прямоугольник. Ну не знаю, по-моему, но по-моему наоборот,
[03:59:47.800 --> 03:59:54.360]  что неприятного, практически подвешенное дерево отрезков классическое. Ну скажем так,
[03:59:54.360 --> 04:00:02.880]  будет вот задача, как я писал, правда вы можете написать там Федрика Федриков. Вот это,
[04:00:02.880 --> 04:00:09.600]  нет, прибавление по прямоугольнике, наверное, будет немножко другая задача, но в принципе
[04:00:09.600 --> 04:00:21.600]  интересно, да. Ну посмотрим, но в принципе вот. Так, сколько у нас времени-то? Так, 39.40,
[04:00:22.040 --> 04:00:35.720]  так 39.40, это нам типа там 5 минут осталось. Нет, экономистов нет, экономистов выгонять не надо,
[04:00:35.720 --> 04:00:48.920]  да, они как бы да. Нет, на самом деле официальное окончание занятия у нас в 13.45, потом по идее 10
[04:00:48.920 --> 04:00:57.560]  минут перемены и в 13.55 начинается другое занятие. Ну вот, в этом смысле да, но я не знаю,
[04:00:57.560 --> 04:01:01.080]  просто смотрите. Дальше план такой, по идее как бы к этому обязательно надо рассказать,
[04:01:01.080 --> 04:01:08.840]  как с помощью дерева Федриков делать прибавление на отрезки. Вот, но правда фишка еще в том,
[04:01:08.840 --> 04:01:24.240]  что, а потом рассказ как это делать в двумерном случае. Нет, все в этом мире можно. Ну ладно,
[04:01:24.240 --> 04:01:35.000]  нет, то я не знаю, ладно, давайте. Нет, разобраться можно, но лучше да, особенно в двумерном,
[04:01:35.480 --> 04:01:39.880]  я бы, честно говоря, это просто за, там типа давайте вот так-так-так и все понятно, я бы не делал,
[04:01:39.880 --> 04:01:44.280]  потому что нет, по идее как бы да, нет, ну как сказать, потому что дерево отрезков на этом по-любому не
[04:01:44.280 --> 04:01:52.280]  заканчивается, как минимум сливаемое ДО никто не отменял. Значит утверждение, да, мало кто знает,
[04:01:52.280 --> 04:02:00.400]  ОДО можно сплитить и мерзить. Ну и пост тоже, ну как бы вещь важную упомянуть стоит, конечно.
[04:02:00.920 --> 04:02:04.680]  Не, ну как сказать, да, это класс, так конечно говорить, так на кэфе был пост,
[04:02:04.680 --> 04:02:09.600]  поэтому мы это не обсуждаем, да, об этом спрашиваем на экзамене, да, но тогда вы знаете,
[04:02:09.600 --> 04:02:13.520]  если вы там почитать статьи, статьи Адаманта там на этом кодфорсе, знаете там сколько всего,
[04:02:13.520 --> 04:02:23.920]  что знать придется. Так что поаккуратнее, но сливаемое ДО по-любому идет, потому что знаете,
[04:02:23.920 --> 04:02:29.880]  потому что оказался, потому что когда возникают уже просто задачи вида дан массив и выполните
[04:02:29.880 --> 04:02:40.360]  на нем 100 тысяч запросов вида, возьмите подотрезок и отсортируйте его. Нет, ну вот оказывается,
[04:02:40.360 --> 04:02:45.840]  то есть оказывается, что это можно сделать, то есть оказывается, что это можно сделать правильными
[04:02:45.840 --> 04:02:52.840]  там деревьями отрезков, причем на запрос за логарифм. Нет, амортизировано будет за логарифм,
[04:02:52.840 --> 04:02:59.320]  декартовыми можно, но там как бы скажем так, как бы там тоже авторитетные источники, то ли квадрат,
[04:02:59.320 --> 04:03:06.320]  то ли куб там получится, если декартизация писать. Ну вот, а везде амортизация. В декартахе
[04:03:06.320 --> 04:03:17.000]  тоже амортизация, если что? Нет. А, ну в смысле? Ну я боюсь там и то, и то будет. Да, потому что
[04:03:17.000 --> 04:03:22.320]  когда вас там придет информация, там давайте, то есть речь будет идти о том, чтобы сливать два
[04:03:22.320 --> 04:03:29.680]  дерева, у которых не верно, что ключи одного меньше, чем ключи второго, но теоретически можно,
[04:03:29.680 --> 04:03:35.240]  и там даже какая-то симптотика, то ли лог квадрат, то ли лог куб даже возникает, но скорее всего нет,
[04:03:35.240 --> 04:03:40.840]  потому что есть дерево отрезков, которое делает это загарантированный лог. И вот, кстати, это
[04:03:40.840 --> 04:03:46.760]  второй случай, когда дерево отрезков все-таки обыгрывает декартовый дерево. Нет, ну не всегда,
[04:03:46.840 --> 04:03:54.320]  так оно обыгрывает, что я умею тоже самое из-за тот же лог, а тут выясняется, что дерево отрезков
[04:03:54.320 --> 04:03:55.760]  делает это асимпатически лучше.
