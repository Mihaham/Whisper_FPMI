[00:00.000 --> 00:10.000]  Всем добрый день. Как меня видно, слышно? Видно ли экран?
[00:10.000 --> 00:14.000]  Да, я видно.
[00:14.000 --> 00:24.000]  Супер. Давайте тогда начинать. Я рад всех приветствовать на втором семестре нашего курса по C++.
[00:24.000 --> 00:32.000]  В этом семестре мы будем продолжать заниматься C++. У нас откроется, я надеюсь, больше возможностей,
[00:32.000 --> 00:44.000]  больше тем интересных, которые мы будем обучать, и больше таких проектов, которые можно будет реализовать с помощью языка программирования C++.
[00:44.000 --> 00:53.000]  Надеюсь, покончать это семестр мы практически в полной мере познакомимся со всеми возможностями современного языка C++.
[00:53.000 --> 01:02.000]  В целом, как будет построен наш курс? Что мы будем изучать в этом семестре? Давайте коротко прибежимся по организационным моментам.
[01:02.000 --> 01:10.000]  Я расскажу про устройство курса, про его структуру и про то, как будет устроена жизнь в этом семестре.
[01:10.000 --> 01:19.000]  В целом, на самом деле, принципиальных отличий от первого семестра не будет. Мы продолжаем изучать C++, у нас будут лекционные занятия,
[01:20.000 --> 01:33.000]  ну и также остаются домашние задания, в которых будут три штуки. По этим самым домашним заданиям вам будет выставлена оценка за семестр.
[01:33.000 --> 01:44.000]  Также в конце этого семестра вас ждет экзамен по курсу C++. Это будет годовой экзамен, на нем вы продемонстрируете то, что изучили в течение года,
[01:44.000 --> 01:51.000]  то есть в течение первого семестра и второго семестра. Вот такая дополнительная опция появляется в этом семестре.
[01:51.000 --> 02:05.000]  При этом деление на практику и экзамен остается, то есть то, что вы нарешиваете на практике, оно в итоге пойдет и в оценку за итог,
[02:05.000 --> 02:21.000]  примерно в соотношении 3 к 7, то есть примерно 30% вашей оценки будет зависеть от нарешенных домашних заданий, ну и 70% оценки это то, что вы отвечаете на устном экзамене летом этого года.
[02:21.000 --> 02:39.000]  Про структуру курса в смысле тем, что мы будем с вами изучать. В целом у нас, наверное, на курсе будет 4 основных блок, они в целом не соотносятся один к одному с домашними работами,
[02:39.000 --> 02:49.000]  то есть в целом нельзя сказать, что одна тема большая это домашка, но в целом логический курс будет повествовать о 4 принципиальных вещах.
[02:49.000 --> 03:03.000]  Первая вещь это то, что вы видите на экране, Resource Acquisition Identification, важнейшая идиома языка C++, которая позволяет писать, во многих случаях позволяет писать одновременно как безопасный, так и эффективный код.
[03:03.000 --> 03:10.000]  Мы с вами в прошлом семестре много раз говорили о том, что C++ это про некоторый баланс между эффективностью языка и безопасностью.
[03:10.000 --> 03:19.000]  Вот эта штука, рай, позволяет в некоторых случаях, в поддельных случаях, позволяет писать более, скажем, безопасный код и на самом деле зачастую более удобный код.
[03:19.000 --> 03:22.000]  В каком смысле поговорим как раз таки сегодня.
[03:22.000 --> 03:31.000]  Вторая тема это наследование. Поговорим о том про еще одну концепцию объектно-ориентированного программирования, которую не затронули в прошлом семестре.
[03:31.000 --> 03:45.000]  Во всех подробностях поговорим о том, зачем оно нужно, в каких задачах возникает, как помогает решать более удобным способом различного рода проблемы, возникающие перед разработчиками и так далее.
[03:45.000 --> 03:50.000]  Третья тема, естественно, это стандартная билетека языка C++.
[03:50.000 --> 03:53.000]  Скорее даже в большей части это стандартная билетека контейнеров.
[03:53.000 --> 04:03.000]  Познакомимся, наконец, с тем, как не писать свои собственные велосипеды, как в полной мере использовать возможности стандартной билетеки C++ и использовать их контейнеры.
[04:03.000 --> 04:09.000]  Какие контейнеры использовать, в каких ситуациях, и наиболее эффективные приемы их использования также разберем.
[04:09.000 --> 04:18.000]  Ну и последняя тема. Условно ее называем C++. Условно эта категория тем будет называться C++20+.
[04:18.000 --> 04:31.000]  На ней мы познакомимся с новыми фичами стандартов C++20, C++23 и так далее.
[04:31.000 --> 04:40.000]  Поговорим про новые концепции, которые возникли, и как это влияет на то, что мы с вами изучали до этого.
[04:40.000 --> 04:45.000]  В целом, в структуре все будет строено примерно так.
[04:45.000 --> 04:55.000]  Опять же, тут не будет сильного деления. Сначала мы изучаем это, потом темы могут каким-то образом пересекаться довольно логичным образом.
[04:55.000 --> 05:00.000]  В целом, с этим мы на занятиях познакомимся. Я это буду отдельно проговаривать.
[05:00.000 --> 05:05.000]  Есть ли какие-то вопросы? Давайте начнем.
[05:05.000 --> 05:11.000]  Как я проанонсировал, наша первая тема состоит из четырех букв. Это рай.
[05:11.000 --> 05:15.000]  Давайте потихоньку знакомиться с тем, что это такое.
[05:15.000 --> 05:20.000]  Давайте вспомним то, что мы занимались в прошлом семестре.
[05:20.000 --> 05:25.000]  В конце прошлого семестра мы активно обучили класс под названием stack.
[05:25.000 --> 05:30.000]  Мы познакомились с такой структурой данных как односвязанный список.
[05:30.000 --> 05:33.000]  На основе односвязанного списка построили тип данных stack.
[05:33.000 --> 05:39.000]  Добавляли в него всякие методы, конструкторы и так далее.
[05:39.000 --> 05:42.000]  Давайте еще раз на него взглянем.
[05:42.000 --> 05:45.000]  Так или иначе, мы довели его к такому туману.
[05:45.000 --> 05:51.000]  Давайте еще раз на него взглянем и подумаем, чего нам в нем не хватает.
[05:51.000 --> 05:55.000]  В чем проблема нашего класса stack?
[05:55.000 --> 06:00.000]  Тех классов, большинства классов, которые мы писали до этого.
[06:00.000 --> 06:03.000]  Удаление приходилось прописывать.
[06:03.000 --> 06:14.000]  Одной из основных проблем является то, что нам необходимо вручную выполнить такое действие, как очистка stack.
[06:14.000 --> 06:18.000]  У нас есть некоторый stack, мы его создаем.
[06:18.000 --> 06:20.000]  Дальше каким-то образом с ним работаем.
[06:20.000 --> 06:23.000]  В него доволяем элементы с помощью push, удаляем элементы с помощью pop.
[06:23.000 --> 06:25.000]  Получаем верхний элемент с помощью стоп и так далее.
[06:25.000 --> 06:31.000]  Но самое главное, о чем нам необходимо помнить, это то, что в конце работы со stack мы должны вызвать clear.
[06:31.000 --> 06:35.000]  Если мы не вызовем clear, мы не вызвали clear.
[06:35.000 --> 06:41.000]  Мы получили утечку памяти, получили кучу связанных с этим проблем.
[06:41.000 --> 06:44.000]  Как бы мы ни создавали stack, нам необходимо помнить,
[06:44.000 --> 06:48.000]  что на всякий созданный stack должен быть вызван свой метод clear.
[06:48.000 --> 06:53.000]  Ну или хотя бы мы должны быть уверены в том, что по завершении работы со stack он оказался push.
[06:53.000 --> 06:56.000]  Будут на слайде представлены еще более страшные ситуации.
[06:56.000 --> 07:00.000]  Если у нас есть отдельный stack, хотя бы массив stack, то все нормально.
[07:00.000 --> 07:03.000]  Нормально в том смысле, что понятно, как очистить stack.
[07:03.000 --> 07:10.000]  Мы вызываем clear, либо просто в цикле для массива вызываем clear для каждого элемента stack.
[07:10.000 --> 07:13.000]  Но при этом, скажем, если вдруг у меня есть stack stack,
[07:13.000 --> 07:16.000]  вот такая конструкция в целом имеет место быть,
[07:16.000 --> 07:21.000]  то есть stack в качестве каждого элемента которого выступает какой-то другой stack,
[07:21.000 --> 07:25.000]  то тогда нам необходимо уже придумать, точнее написать какой-то нетривиальный цикл,
[07:25.000 --> 07:29.000]  какой-то нетривиальный алгоритм, который всю эту страшную структуру будет как-то очищать.
[07:29.000 --> 07:32.000]  Ну а теперь давайте представим себе следующую ситуацию.
[07:32.000 --> 07:35.000]  Тут мы говорим только конкретно про stack.
[07:35.000 --> 07:37.000]  Вот мы написали свой собственный класс stack,
[07:37.000 --> 07:40.000]  а теперь представь себе, что вот вы написали свой собственный класс stack,
[07:40.000 --> 07:43.000]  а при этом вы пользуетесь какой-то сторонней библиотекой,
[07:43.000 --> 07:45.000]  которая реализовывает класс очереди,
[07:45.000 --> 07:49.000]  ну или просто какой-нибудь класс, который тоже работает с динамической памятью.
[07:49.000 --> 07:54.000]  Вы создаете stack из этих классов, эти классы в свою очередь используют какие-то другие классы и так далее.
[07:54.000 --> 07:57.000]  Потом мы получаем такую огромную иерархическую структуру,
[07:57.000 --> 08:01.000]  в которой нам необходимо помнить, что нам сначала нужно уничтожить самые вложенные объекты,
[08:01.000 --> 08:04.000]  потом подняться на уровень выше и уничтожить эти объекты,
[08:04.000 --> 08:06.000]  а потом, соответственно, уничтожить наш stack.
[08:06.000 --> 08:11.000]  При этом методы, которые очищают эти структуры данных, эти типы данных,
[08:11.000 --> 08:13.000]  они могут быть абсолютно разные.
[08:13.000 --> 08:15.000]  Например, для моего stack это метод clear,
[08:15.000 --> 08:18.000]  для другого объекта это метод delete,
[08:18.000 --> 08:21.000]  для третьего это метод finalize и так далее.
[08:21.000 --> 08:24.000]  То есть необходимо помнить о том, для какого класса,
[08:24.000 --> 08:27.000]  какой метод нужно вызвать, чтобы завершить над ним работу.
[08:27.000 --> 08:30.000]  И вообще говоря, это не то, как мы привыкли с вами программировать,
[08:30.000 --> 08:35.000]  скажем так, до примерно десятой лекции прошлого семестра.
[08:35.000 --> 08:39.000]  Все-таки мы с вами привыкли жить парадигме, что если мы работаем,
[08:39.000 --> 08:41.000]  создаем какую-то переменную,
[08:41.000 --> 08:43.000]  то мы можем создать переменную типа int,
[08:43.000 --> 08:45.000]  написать int x, дальше x'у что-то присвоить,
[08:45.000 --> 08:48.000]  x может поучаствовать в каких-то арифтических операциях,
[08:48.000 --> 08:51.000]  и потом, как только нам x перестает быть нужным,
[08:51.000 --> 08:53.000]  мы можем спокойно забыть про x и дальше им не пользоваться.
[08:53.000 --> 08:57.000]  Мы уверены в том, что x нормально очистится самостоятельно.
[08:57.000 --> 08:59.000]  То есть x просто как переменная уничтожится,
[08:59.000 --> 09:02.000]  и мы об этом вообще не задумываемся над тем,
[09:02.000 --> 09:04.000]  как int должен быть очищен,
[09:04.000 --> 09:08.000]  как он должен быть переиспользован в дальнейшем.
[09:08.000 --> 09:10.000]  Со стеком такой ситуации не получается.
[09:10.000 --> 09:12.000]  То есть со стеком получается так, что мы создаем стек сами,
[09:12.000 --> 09:14.000]  и нам необходимо еще дополнительно помнить о том,
[09:14.000 --> 09:16.000]  как этот стек удалить, как его очистить.
[09:16.000 --> 09:20.000]  Возникает проблема с удобным написанием кода
[09:20.000 --> 09:21.000]  и проблема с безопасностью.
[09:21.000 --> 09:24.000]  То есть если мы не очищаем динамическую память,
[09:24.000 --> 09:26.000]  не очищаем стек, то код перестает быть безопасным,
[09:26.000 --> 09:30.000]  в нем потенциально появляются течки памяти и много чего плохого.
[09:30.000 --> 09:34.000]  Вторая проблема, которая до этого не была озвучена.
[09:34.000 --> 09:37.000]  Давайте подумаем над тем еще раз.
[09:37.000 --> 09:40.000]  Еще одна проблема, над которой мы не задумывались в прошлом смеси.
[09:40.000 --> 09:42.000]  А что если мы попытаемся скопировать стек?
[09:42.000 --> 09:47.000]  Мы создали стек, и даже создали adder копию исходного стека.
[09:47.000 --> 09:50.000]  И даже сказали adder.push2.
[09:50.000 --> 09:52.000]  Что при этом произойдет?
[09:52.000 --> 09:54.000]  А при этом произойдет следующее.
[09:54.000 --> 09:56.000]  При этом в стеке adder окажется элемент 2,
[09:56.000 --> 09:58.000]  и в исходном стеке тоже окажется элемент 2.
[09:58.000 --> 10:00.000]  Вопрос, как так получится?
[10:00.000 --> 10:05.000]  Давайте вернемся к определению стека и посмотрим на него.
[10:05.000 --> 10:07.000]  Вот как устроен класс стека.
[10:07.000 --> 10:09.000]  Класс стека содержит всего лишь одно поле, это hand,
[10:09.000 --> 10:11.000]  то есть это указатель на вершину стека.
[10:11.000 --> 10:13.000]  Теперь давайте посмотрим сюда.
[10:13.000 --> 10:15.000]  Давайте вспомним, что происходит при копировании структуры.
[10:15.000 --> 10:18.000]  Что происходит, когда мы копируем одну структуру в другую структуру,
[10:18.000 --> 10:20.000]  или когда мы копируем один класс в другой класс.
[10:20.000 --> 10:23.000]  На самом деле создается просто полная побитовая копия.
[10:23.000 --> 10:26.000]  То есть если мы один стек скопировали stack adder,
[10:26.000 --> 10:29.000]  то stack adder содержит ровно тот же самый указатель, что и stack.
[10:29.000 --> 10:31.000]  А что это за указатель?
[10:31.000 --> 10:34.000]  Это указатель, который указывает на вершину стека под названием stack.
[10:34.000 --> 10:37.000]  То есть получается так, что и adder и stack,
[10:37.000 --> 10:41.000]  по сути они владеют одними и теми же данными.
[10:41.000 --> 10:43.000]  И поэтому если я adder скажу push,
[10:43.000 --> 10:45.000]  он добавит некоторые новые элементы.
[10:45.000 --> 10:51.000]  Но при этом этот же элемент появится и в стеке stack.
[10:51.000 --> 10:55.000]  Или если stack вдруг начнет удалять данные,
[10:55.000 --> 10:59.000]  то эти же данные уничтожатся и в стеке adder.
[10:59.000 --> 11:01.000]  Беда.
[11:01.000 --> 11:04.000]  Мы все-таки действуем в соображении разумности.
[11:04.000 --> 11:06.000]  Мы с вами все-таки привыкли к тому,
[11:06.000 --> 11:08.000]  что если мы одну переменную копируем в другую переменную,
[11:08.000 --> 11:10.000]  например, создаем int y равно x,
[11:10.000 --> 11:13.000]  мы все-таки подразумеваем, что y имеет начальное значение такое же, как и x,
[11:13.000 --> 11:17.000]  но при этом эти две переменные являются независимыми.
[11:17.000 --> 11:20.000]  То есть x и y не влияют никак друг на друга.
[11:20.000 --> 11:23.000]  То есть если я увеличиваю x, то y при этом никак не увеличивается.
[11:23.000 --> 11:24.000]  И наоборот.
[11:24.000 --> 11:28.000]  Если я уменьшаю y, то x никак не уменьшится, никак не изменится.
[11:30.000 --> 11:31.000]  Проблема.
[11:31.000 --> 11:34.000]  То есть нарушается как называемая семантика копирования,
[11:34.000 --> 11:36.000]  которую мы привыкли в языке C++.
[11:36.000 --> 11:39.000]  И плюс еще одна дополнительная проблема состоит в следующем.
[11:39.000 --> 11:42.000]  Ну, допустим, мы смирились с тем,
[11:42.000 --> 11:44.000]  что семантика копирования сломана,
[11:44.000 --> 11:46.000]  просто так копировать классы нельзя.
[11:46.000 --> 11:49.000]  То есть у меня теперь stack указывает на одни и те же данные.
[11:49.000 --> 11:50.000]  Хорошо, допустим.
[11:50.000 --> 11:52.000]  Допустим, мы с этим смирились.
[11:52.000 --> 11:53.000]  Думаю, вот на чем.
[11:53.000 --> 11:58.000]  Что произойдет, если я вызову для стека clear?
[11:58.000 --> 12:01.000]  Если я вызову clear для стека, то, соответственно, он очистится,
[12:01.000 --> 12:03.000]  и у него все данные пропадут.
[12:03.000 --> 12:05.000]  А что произойдет, если я вызову clear для adder?
[12:05.000 --> 12:08.000]  Ну, смотрите, для adder тоже он попытается вызвать clear,
[12:08.000 --> 12:11.000]  но при этом у adder хранится старый указатель на ноду,
[12:11.000 --> 12:13.000]  которая уже была удалена,
[12:13.000 --> 12:16.000]  и поэтому adder попытается снова удалить все же самые данные.
[12:16.000 --> 12:18.000]  И возникает проблема двойного удаления.
[12:18.000 --> 12:21.000]  То есть на самом деле, если у нас есть две копии объекта,
[12:21.000 --> 12:23.000]  которые указывают на одни и те же данные,
[12:23.000 --> 12:26.000]  то на самом деле удалять данные и очищать данные должен только один.
[12:26.000 --> 12:28.000]  То есть только либо stack, либо adder.
[12:28.000 --> 12:30.000]  Вопрос, кто из них должен что-то удалять?
[12:30.000 --> 12:32.000]  То есть если у меня есть несколько объектов,
[12:32.000 --> 12:34.000]  которые указывают на одни и те же данные,
[12:34.000 --> 12:36.000]  то удалить должен кто-то один.
[12:36.000 --> 12:37.000]  Вопрос, кто?
[12:37.000 --> 12:40.000]  Во-вторых, как гарантировать, что удалены будут данные только один раз?
[12:40.000 --> 12:42.000]  Снова получаем целый вор в проблем.
[12:42.000 --> 12:48.000]  Ну и давайте познакомимся, скажем так, с решением части проблем
[12:48.000 --> 12:52.000]  с новой конструкцией языка C++, которая называется destructor.
[12:52.000 --> 12:58.000]  Вообще говоря, если чисто на таком обывательском уровне
[12:58.000 --> 13:01.000]  попытаться сравнить языки C и C++,
[13:01.000 --> 13:04.000]  задать вопрос, а чем принципиальный язык C отличается от C++?
[13:04.000 --> 13:07.000]  Что делает язык C++ именно языком C++?
[13:07.000 --> 13:10.000]  Многие скажут, что это объект ориентирования программирования,
[13:10.000 --> 13:11.000]  но в целом будут правы.
[13:11.000 --> 13:15.000]  На самом деле, наверное, ключевым отличием этих двух языков
[13:15.000 --> 13:17.000]  является наличие destructor.
[13:17.000 --> 13:20.000]  Наличие destructor из соответствующих методов,
[13:20.000 --> 13:23.000]  про которые мы сегодня поговорим.
[13:23.000 --> 13:25.000]  Вот что такое destructor.
[13:25.000 --> 13:28.000]  Destructor – это еще один особый метод класса.
[13:28.000 --> 13:32.000]  Еще один в том смысле, что помимо тех,
[13:32.000 --> 13:34.000]  которые мы с вами обсуждали в первом семестре.
[13:34.000 --> 13:36.000]  В первом семестре обсуждали конструкторы,
[13:36.000 --> 13:38.000]  обсуждали перегрузку операции.
[13:38.000 --> 13:40.000]  Destructor – это еще один особый метод класса.
[13:40.000 --> 13:43.000]  При этом этот метод класса вызывается автоматически
[13:43.000 --> 13:45.000]  при завершении времени жизни объекта.
[13:45.000 --> 13:47.000]  То есть как только время жизни объекта завершается,
[13:47.000 --> 13:49.000]  вызывается destructor.
[13:49.000 --> 13:51.000]  Напомним, конструктор вызывается при создании объекта.
[13:51.000 --> 13:53.000]  Destructor – это антипод конструктора,
[13:53.000 --> 13:57.000]  который удаляет объект, который был ранее создан.
[13:57.000 --> 14:00.000]  Как создать, как определить destructor?
[14:00.000 --> 14:01.000]  Очень просто.
[14:01.000 --> 14:04.000]  Имя destructor совпадает с именем самого класса
[14:04.000 --> 14:06.000]  за единственным исключением,
[14:06.000 --> 14:09.000]  что в начале него пишется знак tilde.
[14:09.000 --> 14:12.000]  То есть tilde имя класса – это название метода,
[14:12.000 --> 14:14.000]  который называется destructor.
[14:14.000 --> 14:16.000]  Особенностью destructor является то,
[14:16.000 --> 14:18.000]  что, во-первых, он не имеет возвращаемого значения
[14:18.000 --> 14:19.000]  ровно как конструктор.
[14:19.000 --> 14:22.000]  Потому что у destructor единственное значение –
[14:22.000 --> 14:24.000]  это удалить исходный объект.
[14:24.000 --> 14:26.000]  То есть у него нет никакого возвращаемого значения,
[14:26.000 --> 14:28.000]  ну и по смыслу его быть не может.
[14:28.000 --> 14:34.000]  И плюс destructor не принимает никогда никаких аргументов.
[14:34.000 --> 14:37.000]  То есть destructor в вашем классе может быть только один.
[14:37.000 --> 14:42.000]  В отличие от конструкторов destructor может быть только один.
[14:42.000 --> 14:44.000]  В конструкторах может быть много разных,
[14:44.000 --> 14:47.000]  в зависимости от того, какую перегрузку вы написали,
[14:47.000 --> 14:49.000]  какие перегрузки вы выбрали.
[14:49.000 --> 14:55.000]  Так как по определению destructor – это особый метод класса,
[14:55.000 --> 14:57.000]  который вызывается при завершении времени жизни объекта,
[14:57.000 --> 15:00.000]  мы туда, в этот самый destructor, можем помесить произволену логику,
[15:00.000 --> 15:05.000]  которую необходимо выполнять при уничтожении этого самого объекта.
[15:05.000 --> 15:07.000]  В частности, если у нас есть класс stack,
[15:07.000 --> 15:09.000]  то мы просто напросто туда можем поместить метод clear.
[15:09.000 --> 15:11.000]  И теперь, в этот момент, мы можем быть уверены
[15:11.000 --> 15:13.000]  в вся awakened раз, когда stack уничтожается,
[15:13.000 --> 15:15.000]  допустим, переменная выходит из своей области действия.
[15:15.000 --> 15:18.000]  Ну или уничтожается с помощью delete указатель,
[15:18.000 --> 15:22.000]  который указывает на динамический stack.
[15:22.000 --> 15:24.000]  Мы можем быть строго уверены,
[15:24.000 --> 15:27.000]  что именно в этот момент обязательно вызывается clear.
[15:27.000 --> 15:29.000]  То есть как только переменная становится нам ненужна,
[15:29.000 --> 15:33.000]  как только переменная выходит из своей области действия一定要 вызывается метод clear.
[15:33.000 --> 15:41.000]  И теперь этого не нужно делать вручную, если нам этого не нужно делать по логике программы.
[15:41.000 --> 15:46.000]  Вот пример. У меня есть стэк, я его создаю, дальше делаю push единица,
[15:46.000 --> 15:49.000]  и дальше могу про него забыть, никаких утечек памяти не будет,
[15:49.000 --> 15:54.000]  потому что вовремя вызовется деструктор и очистит память.
[15:54.000 --> 15:58.000]  Вот такой замечательный метод.
[15:58.000 --> 16:05.000]  Теперь давайте разберем такой вопрос.
[16:05.000 --> 16:12.000]  Мы с вами до этого никак не обсуждали понятие деструктора,
[16:12.000 --> 16:15.000]  но при этом активно писали классы, структуры и с ними.
[16:15.000 --> 16:17.000]  Возникает естественный вопрос.
[16:17.000 --> 16:19.000]  А как тогда у нас вызывался деструктор?
[16:19.000 --> 16:23.000]  Если мы говорим о том, что деструктор всегда вызывается при завершении времени жизни объекта,
[16:23.000 --> 16:25.000]  при этом до этого мы никак не писали деструктора,
[16:25.000 --> 16:29.000]  как же тогда уничтожались у нас объекты до этого?
[16:29.000 --> 16:31.000]  Ну и ответ собственно состоит в следующем.
[16:31.000 --> 16:34.000]  Деструктор — это особый метод класса.
[16:34.000 --> 16:37.000]  В том смысле, что если вы не пишете свои собственные реализации деструктора,
[16:37.000 --> 16:39.000]  то компилятор сделает это за вас автоматически.
[16:39.000 --> 16:41.000]  Например, по аналогии с конструктором по умолчанию.
[16:41.000 --> 16:45.000]  Напомню, если вы в классе не пишете для вас неодного конструктора,
[16:45.000 --> 16:47.000]  то компилятор за вас создаст конструктор по умолчанию.
[16:47.000 --> 16:49.000]  С диструктором та же история.
[16:49.000 --> 16:54.000]  Если вы в классе не писали деструктора, то компилятор за вас создаст диструктор.
[16:54.000 --> 16:57.000]  Следующий вопрос. Ну окей. Допустим, комбинатор создал за меня деструкты.
[16:57.000 --> 16:58.000]  Что он делает?
[16:58.000 --> 17:01.000]  Ну и тут есть опять несколько вариантов ответа.
[17:01.000 --> 17:04.000]  Первый и самый простой ответ – это ничего не делает.
[17:04.000 --> 17:06.000]  В некотором смысле он является правильным.
[17:06.000 --> 17:10.000]  В том смысле, что если у вас все поля класса являются примитивными типами,
[17:10.000 --> 17:14.000]  то есть примитивные типы в том смысле, что при уничтожении с ними ничего делать не нужно.
[17:14.000 --> 17:19.000]  Например, это int, double, char указатель, char звездочка и так далее.
[17:19.000 --> 17:23.000]  То есть это примитивные типы, для которых при уничтожении и так ничего не происходит.
[17:23.000 --> 17:26.000]  Вот в этом случае деструктор ничего не сделает.
[17:26.000 --> 17:30.000]  А более правильный ответ будет звучать следующим образом.
[17:30.000 --> 17:35.000]  Если поле является примитивным типом, если поле – это поле примитивного типа,
[17:35.000 --> 17:37.000]  то с этим полем ничего не произойдет.
[17:37.000 --> 17:39.000]  То есть деструктор его просто проигнорирует.
[17:39.000 --> 17:43.000]  Но если в качестве поля вашего класса выступает какой-то другой класс,
[17:43.000 --> 17:47.000]  точнее объект другого класса, то для этого поля тоже будет вызвать деструктор.
[17:47.000 --> 17:50.000]  И это на самом деле замечательная новость. Почему?
[17:50.000 --> 17:53.000]  Я в образовании деструктора сказал, что это особый метод класса,
[17:53.000 --> 17:56.000]  который вызывается всегда при завершении времени жизни объекта.
[17:56.000 --> 17:58.000]  А теперь представьте следующую картину.
[17:58.000 --> 18:01.000]  Вот так. У меня тут есть пример.
[18:01.000 --> 18:04.000]  Давайте посмотрим на структуру B.
[18:04.000 --> 18:09.000]  У меня есть структура B, и у структуры B в качестве одного из полей выступает поле A,
[18:09.000 --> 18:13.000]  который является в свою очередь структурой A.
[18:13.000 --> 18:15.000]  И она как-то не тривиально устроена.
[18:15.000 --> 18:18.000]  Смотрите, если уничтожается структура B,
[18:18.000 --> 18:22.000]  то чтобы корректно уничтожить структуру B, нужно уничтожить поля A и X.
[18:22.000 --> 18:26.000]  И компилятор естественно это понимает, и естественно он будет уничтожать и поле X, и поле A.
[18:26.000 --> 18:30.000]  Но при этом для интого поля X, чтобы его уничтожить, с ним ничего не нужно делать,
[18:30.000 --> 18:34.000]  он и так как бы сгинет в небытие вашей оперативной памяти.
[18:34.000 --> 18:36.000]  А вот со структурой A все гораздо сложнее.
[18:36.000 --> 18:40.000]  То есть тут в структуре A написан деструктор, который очищает динамически выделенный память.
[18:40.000 --> 18:43.000]  И поэтому при уничтожении объекта B будет сгенерирован деструктор,
[18:43.000 --> 18:47.000]  который вызовет деструктор для A, а деструктор для A в свою очередь очистит динамическую память,
[18:47.000 --> 18:49.000]  которая находится внутри.
[18:49.000 --> 18:52.000]  То есть важно понимать, что деструктор – это такая замечательная вещь,
[18:52.000 --> 18:55.000]  которая будет вызвана в любом случае.
[18:55.000 --> 19:03.000]  Практически во всех логичных контекстах, где логично было бы вызвать деструктор, он будет вызван.
[19:03.000 --> 19:11.000]  Ну и соответственно вы на самом деле можете явно попросить компилятор создать деструктор за вас.
[19:11.000 --> 19:15.000]  То есть если вы хотите в коде явно указать, что вы не пишете свой собственный деструктор,
[19:15.000 --> 19:20.000]  вы полагаетесь на компилятор, вы можете записать конструкцию равно default.
[19:20.000 --> 19:25.000]  Ну как, например, в случае класса non-destructible.
[19:25.000 --> 19:31.000]  Тут, кстати, в случае класса non-destructible это очень интересный пример.
[19:31.000 --> 19:36.000]  В смысле, что если бы я написал просто пустой класс, то я просто написал пустой класс non-destructible.
[19:36.000 --> 19:40.000]  В этом случае компилятор создал бы заменять деструктор, который просто ничего не делает.
[19:40.000 --> 19:44.000]  И при этом деструктор он бы создал в публичной области.
[19:44.000 --> 19:54.000]  Но тут я намеренно поместил объявление и определение деструктора non-destructible в приватную область.
[19:54.000 --> 19:58.000]  То есть я в приватную область написал деструктор non-destructible равно default.
[19:58.000 --> 20:04.000]  Это означает, что я сказал компилятору создай за меня деструктор по умолчанию в приватной области.
[20:04.000 --> 20:07.000]  Что означает приватный деструктор?
[20:07.000 --> 20:13.000]  С точки зрения обывательского кода приватный деструктор в целом не имеет никакого смысла.
[20:13.000 --> 20:18.000]  Потому что если вы создали приватный деструктор, то удалить объекты вашего класса не получится.
[20:18.000 --> 20:21.000]  Точнее, удалить объекты вашего класса извне вашего класса не получится.
[20:21.000 --> 20:25.000]  И, соответственно, как вы понимаете, использовать объекты вашего класса вне вашего класса не получится.
[20:25.000 --> 20:30.000]  Поэтому это довольно странная конструкция, которая встречается крайне-крайне редко.
[20:30.000 --> 20:32.000]  Кроме того, это приводит к еще одной проблеме.
[20:32.000 --> 20:36.000]  Если вдруг у вашего класса нет деструктора или приватный деструктор,
[20:36.000 --> 20:40.000]  то если вы используете этот класс в каком-то другом классе, как класс C,
[20:40.000 --> 20:42.000]  то у него в качестве поля выступает non-destructible.
[20:42.000 --> 20:45.000]  В этом случае у класса C тоже тогда не будет деструктора.
[20:45.000 --> 20:48.000]  Почему? Потому что компилятор увидит класс C.
[20:48.000 --> 20:51.000]  Он поймет, что вы для класса C не написали свой деструктор.
[20:51.000 --> 20:55.000]  И он попытается для класса C создать свой деструктор, предоставить его вам.
[20:55.000 --> 20:58.000]  В этот момент у компилятора возникнет проблема. Почему?
[20:58.000 --> 21:02.000]  Потому что деструктор класса C должен вызывать деструктор класса non-destructible.
[21:02.000 --> 21:05.000]  Но деструктор класса non-destructible будет недоступен.
[21:05.000 --> 21:09.000]  И поэтому компилятор откажется за вас генерировать деструктор для класса C.
[21:09.000 --> 21:16.000]  Если собирать все коротко, собирать мораль, то если вы не пишете свой деструктор,
[21:16.000 --> 21:18.000]  то компилятор попытается его создать за вас.
[21:18.000 --> 21:21.000]  И он создаст его практически во всех ситуациях.
[21:21.000 --> 21:24.000]  Как правило, это означает, что у одного из полей нет деструктора,
[21:24.000 --> 21:27.000]  или этот деструктор является недоступен.
[21:33.000 --> 21:37.000]  Да, про это я и проговорил. Если деструктор недоступен,
[21:37.000 --> 21:40.000]  то эти объекты на стеке создавать нельзя.
[21:40.000 --> 21:43.000]  И если деструктор недоступен, то это не может быть диструктором.
[21:43.000 --> 21:46.000]  Если диструктор недоступен, то это не может быть диструктором.
[21:46.000 --> 21:50.000]  А если диструктор недоступен, то эти объекты на стеке создавать нельзя.
[21:50.000 --> 21:53.000]  Это довольно странная конструкция.
[21:53.000 --> 21:56.000]  Но тем не менее, если вы хотите запретить создавать ваши объекты на стеке,
[21:56.000 --> 22:01.000]  то можете воспользоваться приватным деструктором.
[22:01.000 --> 22:05.000]  Так, тут на сцене опечатка не конструктор, а деструктор.
[22:07.000 --> 22:12.000]  Следующий вопрос. Давайте поговорим о следующем.
[22:12.000 --> 22:18.000]  В прошлом семестре мы с вами написали несколько классов.
[22:18.000 --> 22:22.000]  Понятное дело, что стэк был одним из них.
[22:22.000 --> 22:26.000]  Тут может возникнуть вполне себе естественный вопрос.
[22:26.000 --> 22:29.000]  Мы с вами познакомились с понятием деструктора.
[22:29.000 --> 22:36.000]  Вопрос. Нужно ли, в этом случае, верно ли, что по нашему стилю
[22:36.000 --> 22:41.000]  или по каким-то общепринятым соглашениям нужно обязательно для класса писать деструктор?
[22:41.000 --> 22:45.000]  И вообще, если мы пишем деструктор, что в деструкторе обычно делается?
[22:45.000 --> 22:47.000]  Так вот, идея такая.
[22:47.000 --> 22:52.000]  Смотрите, деструктор стоит писать только тогда, когда вам это необходимо.
[22:52.000 --> 22:53.000]  А когда вам это необходимо?
[22:53.000 --> 22:58.000]  Необходимо это делать тогда, когда при удалении объекта нужна какая-то нетривиальная логика.
[22:58.000 --> 23:01.000]  Давайте сравним. Сравним с чем, например.
[23:01.000 --> 23:05.000]  В прошлом семестре разбирали еще такой тип данных, как комплексное число.
[23:05.000 --> 23:08.000]  Мы с вами писали свой класс комплексного числа.
[23:08.000 --> 23:11.000]  Имеет ли смысл для комплексного числа писать свой деструктор?
[23:11.000 --> 23:13.000]  Кажется, что нет. Почему?
[23:13.000 --> 23:16.000]  Потому что если мы написали свой класс комплексного числа,
[23:16.000 --> 23:20.000]  то у него в качестве полей выступает просто действительно имнимая часть.
[23:20.000 --> 23:23.000]  Эти обе части являются примитивными типами.
[23:23.000 --> 23:25.000]  Например, типом double.
[23:25.000 --> 23:29.000]  Если у вашего класса все поля это примитивный тип, например, double, int и так далее,
[23:29.000 --> 23:37.000]  и вам в принципе устраивает история, что эти поля будут просто уничтожены стандартным образом,
[23:37.000 --> 23:40.000]  то в целом деструктор писать не обязательно.
[23:40.000 --> 23:46.000]  Но если по завершении работы с объектом вам необходимо, чтобы компилятор сделал какую-то нетривиальную логику,
[23:46.000 --> 23:48.000]  например, очистил память.
[23:48.000 --> 23:50.000]  Очистка памяти – это нетривиальное действие.
[23:50.000 --> 23:53.000]  То есть если у вас в классе есть указатель на динамически выделенную память,
[23:53.000 --> 23:56.000]  то компилятор не догадается очистить ее.
[23:56.000 --> 24:00.000]  В этом смысле компилятор тупой, как он был тупой, так он и остался.
[24:00.000 --> 24:04.000]  Никто за вас дилит вызывать, вызывать не будет.
[24:04.000 --> 24:07.000]  Поэтому это действие, которое стоит прописывать в деструкторе.
[24:07.000 --> 24:10.000]  Но то же самое касается вообще любых ресурсов, не только памяти.
[24:10.000 --> 24:13.000]  Закрытие файлов, освобождение mutex.
[24:13.000 --> 24:19.000]  Или если вдруг по завершении времени жизни объекта вам нужно записать в какой-нибудь отдельный логирующий файл,
[24:19.000 --> 24:25.000]  что объект уничтожился с 15 часов, 12 минут, 13 секунд по московскому времени.
[24:25.000 --> 24:27.000]  Что делать с этой информацией – непонятно.
[24:27.000 --> 24:30.000]  Но допустим, вам нужно просто записывать такого рода информацию.
[24:30.000 --> 24:35.000]  Это, естественно, тоже должно быть прописано в деструкторе.
[24:35.000 --> 24:38.000]  Да, я вижу вопрос в чате, я сейчас отвечу.
[24:38.000 --> 24:41.000]  И еще одна вещь, которую важно помнить.
[24:41.000 --> 24:46.000]  Опять, я еще раз повторю, что если у вас в качестве поля класс выступает какой-то другой класс,
[24:46.000 --> 24:48.000]  то для него не нужно явно вызывать деструктор.
[24:48.000 --> 24:52.000]  Все деструкторы, которые могут быть вызваны автоматически, вызовутся автоматически.
[24:52.000 --> 24:59.000]  Вот нетривиальные действия, типа дилит по динамической памяти, этого сделано не будет, поэтому это прописывать нужно.
[24:59.000 --> 25:02.000]  Так, как компилятор понимает, когда запускать деструктор?
[25:02.000 --> 25:05.000]  После последнего использования переменной класса нет.
[25:05.000 --> 25:09.000]  У нас история в целом.
[25:09.000 --> 25:14.000]  Деструктор никак не влияет на понимание компилятора вашего кода.
[25:14.000 --> 25:18.000]  То есть, смотрите, у нас мы с вами в прошлом семестре обсуждали область действия переменных.
[25:18.000 --> 25:25.000]  Мы с вами говорили, что, например, область действия стековых переменных ограничена блоком из фигурных скобок, к которому он находится.
[25:25.000 --> 25:29.000]  Соответственно, как только вы покидаете соответствующий блок, вызывается деструктор.
[25:29.000 --> 25:36.000]  То есть, как только вы написали int x и дальше выходите из фигурной скобки закрывающейся, то в этот момент вызывается деструктор.
[25:36.000 --> 25:40.000]  Если мы говорим про глобальные перемены, до какого момента живут глобальные перемены?
[25:40.000 --> 25:44.000]  Глобальные перемены живут до конца программ.
[25:44.000 --> 25:47.000]  Поэтому деструктор для глобальных перемен вызывается в конце программы.
[25:47.000 --> 25:54.000]  То есть, как только программа завершается, у вас вызываются деструкторы для всех глобальных перемен.
[25:54.000 --> 25:58.000]  Или если мы говорим О динамической памяти.
[25:58.000 --> 26:00.100]  В кой момент уничтожаются объекты в динамической памяти?
[26:00.100 --> 26:04.000]  Объекты в динамической памяти уничтожаются, когда я по ним вызываю delete.
[26:04.000 --> 26:09.000]  То есть, когда я пишу delete p, то в этот момент объект, на который указывает p, уничтожается.
[26:09.000 --> 26:13.000]  В этот момент краски вызваны для стук деструктора.
[26:13.000 --> 26:17.000]  В целом, тут история такая же, как и в прошлом сем then.
[26:17.000 --> 26:21.000]  Есть глобальные объекты, есть объекты, которые живут на стеке, есть объекты, которые живут в динамической памяти.
[26:21.000 --> 26:26.000]  Вот как только они уничтожают даты глобальной переменной в конце программы, стеклой в конце соответствующего блока,
[26:26.000 --> 26:30.000]  а динамически, когда вызываете дилейт. Вот во все эти три момента и вызываются деструкторы.
[26:30.000 --> 26:37.000]  То есть, естественно, компилятор не будет анализировать, когда вы последний раз использовали переменную и так далее.
[26:37.000 --> 26:44.000]  Ладно, давайте так, еще раз сделаю такую оговорку, что понятно дело, что компиляторы могут оптимизировать ваш код как угодно.
[26:44.000 --> 26:46.000]  То есть, они в принципе могут теоретически так сделать.
[26:47.000 --> 26:52.000]  Вот вы переменную использовали только в начале функции, а в конце функции вы больше ни разу ее не использовали.
[26:52.000 --> 26:56.000]  Наверное, компилятор тут может как-то прооптимизировать и сказать, что давай я сразу вызову деструктор.
[26:56.000 --> 27:01.000]  Но опять же, это поведение не регламентировано стандартными языками C++, поэтому на это полагаться вообще не стоит.
[27:05.000 --> 27:09.000]  Надеюсь, ответил на вопрос. Если нет, то мейкните.
[27:12.000 --> 27:15.000]  Так, хорошо, идем дальше.
[27:16.000 --> 27:20.000]  Ну, собственно, вот пример, что делали деструкторы.
[27:20.000 --> 27:22.000]  А, ну, давайте тут хороший пример.
[27:22.000 --> 27:28.000]  Вот смотрите, у меня есть стэк, и логично, что при завершении работы со стэком я вызываю clear.
[27:28.000 --> 27:34.000]  То есть, clear просто очищаю, удаляю все элементы, на которые он указывает.
[27:34.000 --> 27:38.000]  И вот тут есть еще одно действие. Например, height равно nullptr.
[27:38.000 --> 27:42.000]  Вот тут для чего нужен этот слайд?
[27:42.000 --> 27:50.000]  Очень часто такое возникает в студенческом коде, что в деструкторе люди удаляют память,
[27:50.000 --> 27:53.000]  то есть делают delete динамической памяти или делают clear,
[27:53.000 --> 27:56.000]  а потом в конце делают head равно nullptr и size равно null.
[27:56.000 --> 27:58.000]  То есть тут стэк еще может написать size равно null.
[27:58.000 --> 28:04.000]  Ну и в принципе это в некотором смысле раздуманно, если мы очистили стэк, то он же стал пустым,
[28:04.000 --> 28:08.000]  поэтому у него голова это nullptr и размер равен null. Вроде как логично.
[28:08.000 --> 28:12.000]  Но вопрос тут в следующем. Зачем это делать? Зачем делать эти лишние действия?
[28:12.000 --> 28:17.000]  Ведь мы знаем, гарантированно, что по завершении деструктора объекта больше не будет существовать.
[28:17.000 --> 28:21.000]  То есть вопрос, для кого вы стараетесь? Для кого вы зануляете размер? Для кого вы зануляете head?
[28:21.000 --> 28:25.000]  Ну ответ не для кого. То есть после того, как вы это сделаете, объект сразу же уничтожится,
[28:25.000 --> 28:28.000]  и комплятор про это сразу же забудет.
[28:28.000 --> 28:32.000]  Поэтому никаких лишних действий, в том смысле, что занулять какие-то переменные,
[28:32.000 --> 28:35.000]  делать так, чтобы все осталось красиво, не нужно.
[28:35.000 --> 28:40.000]  Просто сделали очистку, и на этом завершили. После этого объект существовать не будет,
[28:40.000 --> 28:46.000]  никто ваших некрасивых значений переменных никогда не увидит.
[28:46.000 --> 28:54.000]  И еще одна распространенная ошибка, это ниже код структура A, у нее в качестве поля стэк S,
[28:54.000 --> 28:58.000]  и вызывается деструктор, и пишут определение деструктора A следующим образом.
[28:58.000 --> 29:02.000]  Логично же, чтобы уничтожить объект A, нужно уничтожить поле S.
[29:02.000 --> 29:05.000]  Чтобы уничтожить поле S, нужно вызвать деструктор.
[29:05.000 --> 29:10.000]  Вот этого делать ни в коем случае не стоит. Вообще говоря, нельзя. Почему?
[29:10.000 --> 29:13.000]  Потому что деструктор стэка, как мы с вами говорили, и так будет вызван.
[29:13.000 --> 29:16.000]  То есть деструкторы всех полей будут вызываться автоматически.
[29:16.000 --> 29:21.000]  Это не является нетривиальным действием, это является действием, которое шито в логику компилятора.
[29:21.000 --> 29:24.000]  Поэтому что тут произойдет? Тут произойдет следующее.
[29:24.000 --> 29:30.000]  Вы вызываете деструктор для стэка, потом вы выходите из деструктора A,
[29:30.000 --> 29:32.000]  и в этот момент компилятор снова вызовет деструктор для стэка.
[29:32.000 --> 29:34.000]  То есть у вас для стэка будет вызван деструктор дважды,
[29:34.000 --> 29:37.000]  и в лучшем случае вы просто-напросто сделаете лишнюю работу,
[29:37.000 --> 29:42.000]  а в худшем случае вы получите рантайм-эррор из-за того, что вы очистили два раза одну и ту же память.
[29:42.000 --> 29:44.000]  То есть double-free.
[29:44.000 --> 29:48.000]  Явно вызывать деструктор, вообще говоря, не стоит практически никогда.
[29:48.000 --> 29:51.000]  Есть отдельные, совсем отдельные ситуации, когда это возможно,
[29:51.000 --> 29:55.000]  но про них мы поговорим отдельно на одном из будущих занятий.
[29:56.000 --> 30:00.000]  Пока мораль такая, что если в деструкторе вызывается другой деструктор,
[30:00.000 --> 30:02.000]  то скорее всего вы не правы.
[30:02.000 --> 30:05.000]  Ну, по крайней мере, в рамках того, что мы с вами сейчас обсуждаем.
[30:07.000 --> 30:09.000]  Хорошо.
[30:11.000 --> 30:13.000]  Давайте пойдем дальше.
[30:13.000 --> 30:18.000]  Собственно, разговор про деструктора в целом у меня завершен.
[30:18.000 --> 30:21.000]  Есть ли какие-то вопросы?
[30:26.000 --> 30:32.000]  Стоит ли еще что-нибудь проговорить или точнить?
[30:41.000 --> 30:42.000]  Хорошо.
[30:42.000 --> 30:44.000]  Давайте тогда двигаться дальше.
[30:44.000 --> 30:48.000]  Ну, в общем, смотрите, кажется, уже довольно-таки понятно,
[30:48.000 --> 30:51.000]  что деструкторы очень сильно упрощают нам жизнь.
[30:51.000 --> 30:54.000]  Ну, например, мы написали деструктор для стека,
[30:54.000 --> 30:57.000]  и можем теперь не задумываться над тем, чтобы вызывать нам у него Clear,
[30:57.000 --> 30:59.000]  чтобы очищать его память.
[30:59.000 --> 31:02.000]  И вообще, если мы пишем произвольную программу, точнее произвольный класс,
[31:02.000 --> 31:04.000]  в котором как-то работаем с динамической памятью,
[31:04.000 --> 31:10.000]  то кажется, что просто в деструкторе помещаем учесть очищение,
[31:10.000 --> 31:15.000]  и можем спокойно забыть про этот самый дурацкий delete,
[31:15.000 --> 31:18.000]  с которым учились там весь первый семестр.
[31:18.000 --> 31:20.000]  То есть написать свой класс для динамического массива,
[31:20.000 --> 31:23.000]  написать свой класс для просто динамического указателя,
[31:23.000 --> 31:26.000]  и просто для всех написать деструкторы,
[31:26.000 --> 31:30.000]  и жить без этих надоельных delete.
[31:30.000 --> 31:32.000]  В целом, под мыслью верной,
[31:32.000 --> 31:35.000]  но на самом деле оказывается, что просто деструктора,
[31:35.000 --> 31:37.000]  к сожалению, недостаточно.
[31:37.000 --> 31:40.000]  Ну, опять же, нам вначале говорили, что у нас есть много проблем,
[31:40.000 --> 31:44.000]  и, к сожалению, деструктор не решает всех проблем.
[31:44.000 --> 31:49.000]  Поэтому давайте поговорим о еще нескольких концепциях,
[31:49.000 --> 31:55.000]  которые идут всегда в связке с деструктором
[31:55.000 --> 31:59.000]  и позволяют писать более чистый и безопасный код.
[31:59.000 --> 32:02.000]  Давайте вспомним, опять же, прошлый семестр
[32:02.000 --> 32:04.000]  и поговорим вот о чем.
[32:04.000 --> 32:06.000]  Мы с вами обсуждали тему конструкторы,
[32:06.000 --> 32:12.000]  и в теме конструктора мы с вами поговорили про следующие категории.
[32:12.000 --> 32:14.000]  Мы поговорили про параметрические конструкторы.
[32:14.000 --> 32:16.000]  Напомним, параметрическим конструктором мы назвали конструктор,
[32:16.000 --> 32:18.000]  который принимает более одного аргумента.
[32:18.000 --> 32:20.000]  У нас был конструктор преобразования.
[32:20.000 --> 32:22.000]  Конструктор преобразования мы назвали конструктор,
[32:22.000 --> 32:24.000]  который принимает ровно один аргумент.
[32:24.000 --> 32:26.000]  Точнее, может принимать ровно один аргумент.
[32:26.000 --> 32:28.000]  Конструктором по умолчанию мы назвали конструктор,
[32:28.000 --> 32:30.000]  который может принимать ноль аргументов,
[32:30.000 --> 32:32.000]  который может быть вызван без аргументов.
[32:32.000 --> 32:34.000]  Еще, если вы помните, на той лекции я упомянул,
[32:34.000 --> 32:36.000]  что существуют еще такие конструкторы,
[32:36.000 --> 32:38.000]  как конструктор копирования и конструктор помещения.
[32:38.000 --> 32:40.000]  И когда-нибудь мы про них поговорим.
[32:40.000 --> 32:42.000]  И şimdi когда-нибудь, как минимум для конструктора копирования,
[32:42.000 --> 32:44.000]  наступило сейчас.
[32:44.000 --> 32:50.000]  Давайте поговорим, что это за зверь и для чего оно нам необходимо.
[32:50.000 --> 32:52.000]  Итак, конструктор копирования.
[32:54.000 --> 32:56.000]  Что такое конструктор копирования?
[32:56.000 --> 32:58.000]  Это конструктор, который создает
[32:58.000 --> 33:02.000]  объект с помощью другого объекта того же типа,
[33:02.000 --> 33:04.000]  путем его копирования.
[33:04.000 --> 33:06.000]  То есть на самом деле конструктор копирования
[33:06.000 --> 33:09.560]  А конструктор преобразования особого вида
[33:09.560 --> 33:12.460]  Если вы помните, что конструктор преобразования просто принимает один аргумент
[33:12.460 --> 33:14.780]  Точнее, он может принимать только один аргумент
[33:14.780 --> 33:17.200]  Так вот, конструктор копирования это конструктор, который принимает один аргумент
[33:17.200 --> 33:23.920]  И при этом этот тип этого аргумента совпадает с типом моего класса, который я в данный момент определяю
[33:23.920 --> 33:29.060]  К сожалению, если писать конструктор копирования, так как написано в определении
[33:29.060 --> 33:34.140]  То есть просто сказать reflecting để написать. Так как напишем просто пред Internal Stacker
[33:34.140 --> 33:36.140]  просто примем аргумент stack
[33:38.140 --> 33:40.140]  и напишем какую-то реализацию этого самого конструктора.
[33:40.140 --> 33:42.140]  Вот, к сожалению, тут будет большая проблема.
[33:42.140 --> 33:44.140]  Давайте поговорим, в чем она будет заключаться.
[33:44.140 --> 33:46.140]  Я тут создаю stack a
[33:46.140 --> 33:48.140]  просто помощью конструкторов по умолчанию.
[33:48.140 --> 33:50.140]  Дальше создаю stack b
[33:50.140 --> 33:52.140]  с помощью вроде как конструктора копирования.
[33:52.140 --> 33:54.140]  И вот я утверждаю, что на самом деле
[33:54.140 --> 33:56.140]  в этой строчке у меня существует бесконечные реклусии.
[33:56.140 --> 33:58.140]  Как она получается?
[33:58.140 --> 34:00.140]  Давайте обсуждать.
[34:00.140 --> 34:02.140]  Смотрите, что тут происходит.
[34:02.140 --> 34:04.140]  Я хочу создать b
[34:04.140 --> 34:06.140]  на основе стека a.
[34:06.140 --> 34:08.140]  Так как я создаю stack
[34:08.140 --> 34:10.140]  на основе стека,
[34:10.140 --> 34:12.140]  у меня, естественно, будет вызываться конструктор копирования.
[34:12.140 --> 34:14.140]  Хорошо, комбинатор понимает. Нужно вызвать конструктор копирования.
[34:14.140 --> 34:16.140]  Конструктор копирования
[34:16.140 --> 34:18.140]  это специальная функция,
[34:18.140 --> 34:20.140]  вот такого вида.
[34:20.140 --> 34:22.140]  Эта функция принимает stack по значению.
[34:22.140 --> 34:24.140]  А если что происходит,
[34:24.140 --> 34:26.140]  когда мы вызываем функцию
[34:26.140 --> 34:28.140]  и передаем в нее аргумент по значению?
[34:28.140 --> 34:30.140]  А в этот момент происходит копирование
[34:30.140 --> 34:32.140]  кнопы0001,
[34:32.140 --> 34:34.140]  которую я вызвал с forgot.
[34:34.140 --> 34:50.140]  üzerения adding 58,
[34:50.140 --> 34:52.140] gréheavy�T playsNar.
[34:52.140 --> 34:54.140]  То есть в этой функции
[34:54.140 --> 34:56.140]  собира WomenR4
[34:56.140 --> 34:58.140]  謝謝!
[34:58.140 --> 35:01.740]  то мне снова нужно передать a в аргумент этого конструктора копирования.
[35:01.740 --> 35:04.700]  В итоге получается, что я бесконечно количество раз
[35:04.700 --> 35:07.380]  буду взять конструктор копирования и по итогу он никак не будет вызов coupage.
[35:07.380 --> 35:09.840]  Почему? Потому что я хочу скопировать a вб
[35:09.840 --> 35:12.300]  для этого мне нужно скопировать a в other. При копировании a в other
[35:12.300 --> 35:14.840]  снова вызовется конструктор копирования, чтобы вызовет
[35:14.840 --> 35:18.280]  этот конструктор копирования, снова надо скопировать.
[35:18.280 --> 35:20.120]  Беда.
[35:20.120 --> 35:22.760]  К сожалению, копино supremе такое конструктор на при panels не примет.
[35:22.760 --> 35:25.520]  Точнее, если вы просто напишете конструктор копирования,
[35:25.520 --> 35:29.020]  то он его схавывает, скомпилирует программу,
[35:29.020 --> 35:31.920]  но если вы вдруг попытаетесь его вызвать,
[35:31.920 --> 35:34.540]  то в этом случае возникнет проблема.
[35:35.900 --> 35:38.300]  Как от этой проблемы обойтись?
[35:38.300 --> 35:39.900]  Ну, обойти ее очень просто.
[35:39.900 --> 35:41.220]  В чем была проблема?
[35:41.220 --> 35:43.260]  Чтобы вызвать конструктор копирования,
[35:43.260 --> 35:45.080]  нужно вызвать конструктор копирования.
[35:45.080 --> 35:46.900]  А как вызвать конструктор копирования,
[35:46.900 --> 35:47.800]  не копируя объект?
[35:47.840 --> 35:48.840]  Это очень просто.
[35:48.840 --> 35:51.720]  Давайте в качестве конструктора копирования
[35:51.720 --> 35:53.700]  будем передавать объект не по значению,
[35:53.700 --> 35:54.560]  а по ссылке.
[35:54.560 --> 35:59.220]  Ну, это стандартный трюк, который мы использовали еще в прошлом семестре.
[35:59.480 --> 36:06.820]  Чтобы не копировать аргументы функцию, мы можем просто передавать по swollen7.
[36:06.820 --> 36:08.980]  Ну действительно, если мы передадим объект по constant ссылке —
[36:08.980 --> 36:10.300]  ну опять-таки, почему по ссылке?
[36:10.300 --> 36:12.000]  Потому что мы не хотим копировать объект.
[36:12.000 --> 36:13.160]  Почему по constant ссылке?
[36:13.160 --> 36:14.440]  Ну, потому что мы не хотим...
[36:14.440 --> 36:16.620]  во-первых, мы хотим возможность передавать туда constant.
[36:16.620 --> 36:20.100]  Во-вторых, мы не хотим случайно изменить объект внутри этого конструктора.
[36:20.100 --> 36:22.500]  Плюс мы хотим возможность передавать туда временные Значения,
[36:22.500 --> 36:26.080]  Я напомню, что константные ссылки могут связываться со временными значениями.
[36:26.080 --> 36:28.080]  В общем, константные ссылки всем хороши.
[36:28.080 --> 36:31.080]  И поэтому именно константные ссылки используются в конструкторах копирования.
[36:31.080 --> 36:35.080]  Начиная с этого момента, я спокойно могу написать конструктор копирования
[36:35.080 --> 36:44.080]  и спокойно могу создавать объекты стека на основе других объектов стека.
[36:44.660 --> 36:53.660]  Конструктор копирования – это конструктор, который принимает объект того же типа по константной ссылке.
[36:55.660 --> 36:56.660]  Хорошо.
[36:56.660 --> 36:58.660]  Что нужно делать в конструкторе копирования?
[36:58.660 --> 37:01.660]  Зачем нам писать свой собственный конструктор копирования,
[37:01.660 --> 37:07.660]  если мы говорили о том, что существует стандартное копирование в C++?
[37:07.660 --> 37:12.660]  На самом деле, в C++ копирование и так работает, но просто как побитое копирование полей.
[37:12.740 --> 37:15.740]  В этом самом побитом копировании поле и кроется главная проблема.
[37:15.740 --> 37:19.740]  Если мы возвращаемся в начало, если мы просто возьмем стек
[37:19.740 --> 37:23.740]  и скопируем его указатель на вершину стека в другой стек,
[37:23.740 --> 37:26.740]  то у нас по сути получится два стека, которые указывают на одни и те же данные.
[37:26.740 --> 37:29.740]  А это проблема, то есть нарушается привычная нам семантика копирования.
[37:29.740 --> 37:32.740]  То есть мы все-таки привыкли к тому, что если мы создаем копию,
[37:32.740 --> 37:35.740]  то эта копия является независимой от исходного объекта.
[37:35.740 --> 37:38.740]  Именно поэтому мы хотим написать свой собственный конструктор копирования,
[37:38.820 --> 37:40.820]  которое будет следовать именно этой Chemistry,
[37:40.820 --> 37:42.820]  который будет следовать именно этой семантике.
[37:42.820 --> 37:46.220]  Ну и пример подобного конструктора копирования так и указан
[37:46.220 --> 37:49.220]  на этом слайде.
[37:49.220 --> 37:50.220]  То есть, что я делаю?
[37:50.220 --> 37:53.220]  Я говорю, что если стек, который я хочу скопировать, пустой,
[37:53.220 --> 37:56.220]  то это значит, что у меня вершина нового стека,
[37:56.220 --> 37:57.220]  тоже должно быть пустой.
[37:57.220 --> 38:00.220]  То есть, тоже должен быть пустойrillевой указатель.
[38:00.220 --> 38:03.220]  Если же другой стек не пуст, то, соответственно,
[38:03.220 --> 38:04.220]  я создаю новую вершину.
[38:04.220 --> 38:05.220]  То есть новую вершину этого стека.
[38:05.220 --> 38:08.220]  В этом цикле просто беру E,
[38:08.220 --> 38:14.580]  копирую все поля по элементам. То есть если у меня в первом стеке были элементы 1, 2, 3,
[38:14.580 --> 38:21.660]  то и в втором стеке тоже будут элементы 1, 2, 3, но просто-напросто, которые хранятся в отдельном
[38:21.660 --> 38:26.780]  связанном списке. То есть после вызова этого конструктора копирования будет две независимые
[38:26.780 --> 38:32.140]  копии стека, которые будут жить отдельно друг от друга. Кажется, таким образом восстановлена
[38:32.140 --> 38:41.900]  привычная нам симатика копирования. Ну и, как я уже сказал, если вы не пишете своего
[38:41.900 --> 38:48.100]  собственного копирования, то компилятор создаст его за вас. Но при этом вот
[38:48.100 --> 38:51.940]  этот самый компиляторный конструктор копирования устроен очень тупо. Он просто-напросто побитого
[38:51.940 --> 38:58.820]  копирует все поля. Ну опять же, это полуправда, потому что на самом деле конструктор копирования
[38:58.820 --> 39:04.660]  побитого копирует лишь примитивные поля. То есть если это поле типа int, указатель на int,
[39:04.660 --> 39:09.700]  указатель на указатель на char, то тогда он его скопирует побитого. То есть все примитивные тип
[39:09.700 --> 39:15.460]  он копирует побитого. А если поле вашего класса выступает какой-то другой класс, то для этого
[39:15.460 --> 39:19.780]  класса будет вызов конструктор копирования. В этом и заключается еще одно преимущество конструктора
[39:19.780 --> 39:23.860]  копирования. То есть всякий раз, когда для вашего класса логично вызвать конструктор копирования,
[39:23.860 --> 39:28.340]  будет вызываться именно конструктор копирования. Ну, собственно, вот пример. У меня есть какой-то
[39:28.340 --> 39:35.060]  класс A, и допустим, в нем есть конструктор копирования. Я пишу класс B, и допустим, в нем я не
[39:35.060 --> 39:38.620]  написал своего собственного конструктора копирования. Но все равно в этом случае я могу быть уверен в том,
[39:38.620 --> 39:44.180]  что класс B скопируется правильно. Почему? Потому что поле X скопируется побитого. Просто числовое
[39:44.180 --> 39:48.740]  значение скопируется в другое значение. А класс A скопируется с помощью своего конструктора копирования.
[39:48.740 --> 39:55.460]  То есть при копировании классов всегда будет вызываться конструктор копирования. Это главная мысль,
[39:55.460 --> 40:01.860]  которую стоит запомнить. То есть копирование классов заключается в копировании всех полей.
[40:01.860 --> 40:07.540]  При этом, если полем класса является другой класс, то для него тоже будет вызван конструктор копирования.
[40:07.540 --> 40:15.100]  Хорошо. Если есть вопросы, то пишите, задавайте.
[40:15.100 --> 40:33.580]  Как обычно, я на предыдущем слайде сказал, что компилятор создает для нас свой собственный
[40:33.580 --> 40:37.100]  конструктор копирования. Но при этом, естественно, существует ситуация, при которой компилятор
[40:37.100 --> 40:46.140]  просто окажется это делать. Самая понятная ситуация в том случае, если конструктор копирования
[40:46.140 --> 40:51.060]  другого класса был недоступен. Например, у меня есть структура A, давайте я просто помещу конструктор
[40:51.060 --> 40:55.900]  копирования A в приватную секцию. То есть я просто всем запрещу использовать конструктор копирования.
[40:55.900 --> 41:01.580]  То есть я скажу, он есть, но другим использовать конструктор копирования нельзя. Тогда, если я создам
[41:01.580 --> 41:07.580]  структуру B и у нее в качестве поля будет выступать объект типа A, то тогда копировать структуру B
[41:07.580 --> 41:12.740]  будет нельзя. Почему? Потому что при копировании структуру B компилятор попытается вызвать
[41:12.740 --> 41:20.620]  конструктор копирования для A, а конструктор копирования для A недоступен. Поэтому возникнет
[41:20.620 --> 41:25.460]  проблем. Возникнет ошибка в компиляции примерно такого рода, user deleted function и так далее.
[41:25.460 --> 41:30.540]  Почему deleted function? Потому что компилятор попытается создать за вас конструктор копирования, но пометить
[41:30.540 --> 41:34.460]  его как удаленный, потому что скажут, ну вот я попытался, но ничего не смог сделать, поэтому фиг в омане
[41:34.460 --> 41:42.780]  конструктор копирования. Опять же, конструктор копирования, как и деструктор, как и конструктор
[41:42.780 --> 41:47.740]  помолчания генерируется только в том случае. Если компилятор это может сделать, если компилятор
[41:47.740 --> 41:58.380]  не понимает это сделать, то он не знает, что это такое. Вот, хорошо. Конструкция равно default. Как и для
[41:58.660 --> 42:05.820]  конструктора помолчания, деструктора, для конструктора копирования, применимо конструкция равно default.
[42:05.820 --> 42:13.200]  Конструкция равно default, она в точности следует тем правилам, которые написаны вот тут.
[42:13.200 --> 42:17.500]  то есть конструкция равно default просто говорит том, что меня желт облом писать свою себе
[42:17.500 --> 42:22.700]  конструкцию копирования и компилятору напиши конструкцию копирования за меня. То есть по сути таким
[42:22.700 --> 42:26.920]  образом вы просто Rainfish и
[42:26.920 --> 42:34.840]  отдали на откуп к компилятору. Ну да, и собственно, как тут на этом стадии написано, вообще эта
[42:34.840 --> 42:38.060]  конструкция равно деполт для конструктор-копирования не является обязательной, то есть если вы написали
[42:38.060 --> 42:42.600]  свой собственный конструктор-копирование, то компилятор создаст его за вас ровно такое же.
[42:42.600 --> 42:55.200]  Ну и вопрос тут заключается в следующем. Тут еще на стадии поставлен вопрос, в каких ситуациях стоит писать
[42:55.200 --> 42:59.280]  свой собственный конструктор-копирование, в каких случаях стоит доверить компилятору, но ответ
[42:59.280 --> 43:09.280]  тут довольно прост. Опять же, если вам для класса нужно нетривиальное копирование, в том смысле,
[43:09.280 --> 43:14.960]  что копирование этого класса нарушает обычную, привычную нам симактику копирования. Например,
[43:14.960 --> 43:19.040]  если в вашем классе есть указательные динамические данные, то есть согласить было бы странно при
[43:19.040 --> 43:23.520]  копировании иметь два указателя на одни и те же динамические данные. Поэтому в этом случае мы
