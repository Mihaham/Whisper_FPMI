[00:00.000 --> 00:14.320]  Окей, седьмая лекция, на прошлой лекции мы с вами закончили о том, что мы ввели с вами что такое сеть,
[00:14.320 --> 00:21.000]  что такое поток, что такое величина потока и порисовали картинки. Вот, это в принципе наше
[00:21.000 --> 00:27.560]  великое достижение, однако теперь будем пытаться учиться искать максимальный поток, а для этого
[00:27.560 --> 00:42.400]  понадобится новый инструмент. Остаточная сеть для сети N, напомню, что это у нас такой интересный
[00:42.400 --> 00:52.480]  кортеж VECST, где C это какая-то неотрясательная, можно сказать, положительная функция на множестве
[00:52.480 --> 00:59.080]  ребер. Вообще мы проявили на декартом квадрате, поэтому лучше на декартом квадрате V. S и T это элементы,
[00:59.080 --> 01:13.920]  S и T мы считали различными. И все. И потока, так, для сети и потока F. Это у нас будет внезапно сеть,
[01:13.920 --> 01:31.080]  будем означать N с индексом F, определяется оно вот так вот. GF, VEF, CF, ST. То есть смотрите,
[01:31.080 --> 01:39.240]  у нас меняются ребра, у нас меняются вестимости. S и T остаются, вершинки остаются. Теперь мы будем
[01:39.240 --> 01:48.240]  определять компоненты, которые поменялись. CF это, собственно, самое интересное. Для любых У,
[01:48.240 --> 02:00.040]  для любых УВ из В. CF от УВ. УВ. Определяется следующим образом. Здесь будет несколько веток
[02:00.040 --> 02:13.760]  определения. Первый вариант это С от УВ, минус F от УВ, если УВ лежит в Е. То есть если у нас было
[02:13.760 --> 02:17.640]  ребро и мы пустили по нему какой-то поток F, то остаточная профессиональная способность вот так
[02:17.640 --> 02:34.240]  вот. Дальше. Сейчас будет самое интеллектуальное. F от УВ, если ВУ лежит в Е. То есть смотрите,
[02:34.240 --> 02:40.360]  здесь у нас если УВ лежит в Е, то мы берем само ребро. А если у нас лежит обратное ребро,
[02:40.360 --> 02:56.520]  то мы берем поток. Я нарисую потом. Ну или иначе. Соответственно, EF. Это множество УВ из В квадрат,
[02:56.520 --> 03:11.560]  таких, что CF от УВ больше нуля. Как это понимать? Давайте на примере. Так, будет С.
[03:11.560 --> 03:28.760]  Не так. Давайте нарисуем такую сеть. Классическую. Да, и расставим в местимости какие-нибудь.
[03:28.760 --> 03:45.480]  Давайте вот так вот расставим их. Вот. Например, мы пустили поток. Это наша исходная сеть. Давайте
[03:45.480 --> 03:54.080]  пустим поток. Такое, что здесь будет, не знаю, один из трех. Здесь один из одного, здесь один
[03:54.080 --> 04:05.040]  из одного, здесь один из двух. Да. Тогда как будет выглядеть остаточная сеть? Снова рисуем
[04:05.040 --> 04:17.400]  наши четыре вершинки. Это S, это T. Так, это AB давайте будем обозначать. Давайте читать,
[04:17.400 --> 04:28.760]  чему равно CF от AB. Нет, от SA давайте сначала посчитаем. CF от SA чему равно? Смотрим. Ребро
[04:28.760 --> 04:35.960]  SA у нас было изначально в E, поэтому используем эту ветку. Получается 3-1, то есть 2. Остаточная
[04:35.960 --> 04:46.320]  вместимость. Аналогично возникает обратное ребро. Вместимости 1. Абсолютно аналогично
[04:46.320 --> 04:55.400]  здесь ребро вместимости 1, ребро вместимости 1. Давайте с SB посмотрим. Так, из SB ребро было,
[04:55.400 --> 05:02.120]  значит используем эту верхнюю ветку. При этом у нас capacity 1, поток 1, значит пропускная способность
[05:02.120 --> 05:07.280]  0. А здесь мы определяем EF как то, у чего больше нуля пропускная способность. Поэтому здесь
[05:07.280 --> 05:17.360]  ребра из SB не будет. Однако будет вот такое вот ребро. Так, аналогично здесь появятся обе стороны
[05:17.360 --> 05:27.800]  ребра. Обе стороны. Это вот так вот. Так, из AFB мы не пускали поток, поэтому как было, так и будет.
[05:27.800 --> 05:39.960]  Вроде бы похоже на правду. Такая вот остаточная сеть. Собственно поэтому мы запрещали антипараллельные
[05:39.960 --> 05:48.160]  ребра, потому что у нас возникает обратное ребро в остаточной сети. Потому что мы пустили сюда,
[05:48.160 --> 05:58.960]  у нас было ребро из SB. Смотрим. Ребро из SB есть в E, значит есть ребро из B в S по этой ветке. То есть
[05:58.960 --> 06:06.320]  вы для каждого ребра рисуете два изначально. То есть здесь как бы формально здесь существует
[06:06.320 --> 06:12.320]  ребро пропускной способности 0, но оно пропускной способности 0, поэтому мы его игнорируем. Вот и все.
[06:12.320 --> 06:17.880]  Аналогично здесь у вас тоже появляется ребро пропускной способности 0. То есть вы каждое
[06:17.880 --> 06:27.320]  ребро делаете двунаправленным и ставите соответствующие емкости. Собственно да,
[06:27.320 --> 06:32.400]  если бы у нас в изначальной сети мы разрешали себе антипараллельные ребра, которые вот такие вот,
[06:32.400 --> 06:41.880]  то у вас бы в остаточной сети еще было бы вот так вот. Круто да? И разбираться кто где вообще неприятно.
[06:41.880 --> 06:49.200]  Поэтому мы избавили себя от такой чести тем, что избавились от антипараллельных ребер путем
[06:49.200 --> 06:54.080]  введения искусственной вершины. Это мы с вами судили на прошлой лекции как это делать.
[06:54.080 --> 07:03.400]  Здесь у вас может закраться смутное сомнение, что остаточная сеть, казалось бы, это то сколько
[07:03.400 --> 07:09.680]  потока еще можно протолкнуть. Вроде бы логично, да? Вот это вот действительно сколько потока еще
[07:09.680 --> 07:16.440]  можно протолкнуть, но это тоже естественная ветка. А вот это что такое? Вот это то,
[07:16.440 --> 07:23.080]  что вы позволяете себе отменить единицу потока. Как это понимать? Давайте нарисуем еще один пример
[07:23.080 --> 07:32.960]  по этой же сети. Давайте ее оставим, только нарисуем еще один пример, когда нам это будет нужно.
[07:32.960 --> 07:43.560]  И везде поставим врусные способности 1. И, допустим, я взял поток вот такой вот.
[07:43.560 --> 08:01.040]  Прикольно, да? Давайте нарисуем остаточную сеть. Здесь будет сюда 1, здесь будет сюда 1,
[08:01.040 --> 08:14.480]  так, здесь будет сюда 1, здесь будет сюда 1, а здесь будет в обратную сторону 1.
[08:14.480 --> 08:28.400]  Ну и что можно было бы заметить, да? Что, по сути, у меня этот поток не максимальный,
[08:28.400 --> 08:34.480]  мне выгоднее пускать не здесь единичку, не вот так вот брать поток, а вот так вот взять,
[08:34.480 --> 08:41.880]  получится 2 единицы потока. Ну и мы потом докажем, что это будет связано с остаточной сетью,
[08:41.880 --> 08:49.320]  что если у нас есть путь из ТФС в остаточной сети, то поток не максимален и наоборот. Но
[08:49.320 --> 08:56.880]  пока что это какие-то тайные знания, и это может быть максимум на уровне интуиции. Вот. А так,
[08:56.880 --> 09:23.840]  еще определение. Дополняющим потоком, потоком f'nf, давайте для nf, дополняющим же для чего-то,
[09:23.840 --> 09:37.200]  назовем поток f'nf, то есть это вы смогли пустить еще единичку потока, ну или больше, чем единичку
[09:37.200 --> 09:44.320]  потока. Как, например, вот здесь вот можно пустить в остаточной сети еще раз-два, и допустим,
[09:44.320 --> 10:00.280]  ой, наоборот, тут путь из f так, конечно, должен быть. Вот, ну это потом поймем почему. Ну смотрите,
[10:00.280 --> 10:07.120]  у вас был поток f, вы по нему построили остаточную сеть, вы бахнули еще поток f' туда и вы дополнили,
[10:07.120 --> 10:13.360]  как бы, поток. Мы пустили его именно в остаточной сети, то есть вы как бы пустили в этой сети еще
[10:13.360 --> 10:21.600]  поток, допустим, раз-два, такой вот, или вот здесь вот, то ли вот этой вот траекторией. То есть давайте
[10:21.600 --> 10:27.240]  посмотрим, что происходит, если я опускаю здесь дополнящий поток вот такой вот. Я же могу его
[10:27.240 --> 10:35.680]  пустить, да? Вроде все подходит по определению. Тогда что я получу? То есть это будет, если это
[10:35.680 --> 10:50.200]  было n, это будет nf, то это будет nf плюс f'. Так, снова две вершинки и еще одна т. Так,
[10:50.200 --> 10:58.600]  смотрим, кто кого. Получается, здесь у меня единичка, потому что в обратную сторону пускаю,
[10:58.600 --> 11:09.960]  здесь снова единичка, здесь единичка, здесь единичка, и здесь вот сюда будет единичка. Вот,
[11:09.960 --> 11:15.960]  и вот здесь вот уже из этого f' я не могу дойти. Вот, это будет критериям того, что поток максимальный,
[11:15.960 --> 11:25.320]  если что. На этом где-то минут через 50, наверное, до этого дойдем. Вот, а пока что, вот мы называем
[11:25.320 --> 11:30.240]  это определением потоков. Ну, этот поток понятно. Давайте еще сделаем определение одно.
[11:30.240 --> 11:53.800]  Сложение потоков f и f' определяется. Для любых u, v из v f плюс f' от u,
[11:53.800 --> 12:07.600]  у. Сейчас будет самое страшное. Так, f от u, v плюс f' от u, v минус f' от vu. Вот так вот.
[12:07.600 --> 12:18.400]  То есть, вот это естественная часть, вот это неестественная надбавка, ну, точнее наоборот,
[12:18.400 --> 12:24.400]  отбавка. Почему она возникает? Потому что у вас возникает и прямое ребро, и обратное
[12:24.400 --> 12:33.760]  ребро в остаточной сети. Поэтому приходится с этим считаться. Ну, теперь нужно доказать естественное
[12:33.760 --> 12:59.040]  утверждение. Пусть f' это дополняющий поток vnf. Тогда f плюс f' это поток vn. То есть,
[12:59.040 --> 13:05.120]  мы-то с вами, конечно, классно определили поточечное сложение потоков, но теперь надо доказать,
[13:05.120 --> 13:12.360]  что наше поточечное сложение это поток. Незапно это не очевидно. Кому очевидно, поднимите руку и
[13:12.360 --> 13:18.360]  выйдите, докажите. Это первая часть утверждения, а вторая часть утверждения, что модуль f плюс f',
[13:18.360 --> 13:31.840]  вот так, что величина потока с дополняющим, это сумма величин потоков. Давайте доказывать первую
[13:31.840 --> 13:39.760]  часть, что это вообще поток, что вывлечает из него величину. Так, что у нас было в потоке? Поток
[13:39.760 --> 13:47.480]  это функция, которая, я напишу красненько, мы определяли вот так вот, поток, это первое
[13:47.480 --> 13:52.680]  свойство, потому что у нас ограниченность. А второй свойство, то, что там было, сколько втекло,
[13:52.680 --> 14:06.400]  столько и вытекло, закон сохранения потока. f плюс f', вообще, поток. Давайте доказывать первую часть f
[14:06.400 --> 14:25.360]  плюс f', будем доказывать сначала неотрицательность. Ну окей, для любых УВ из В, f плюс f' от УВ,
[14:25.360 --> 14:38.560]  по определению пишем f от УВ плюс f' от УВ минус f' от ВУ. Так, теперь, что мы с вами говорим?
[14:38.560 --> 14:53.680]  Давайте скажем, что это больше либо равно, чем это мы не тронем, это мы не тронем, а это оставим,
[14:53.680 --> 15:05.560]  вот таким вот образом заменим. Ну поток всегда меньше вместимости. Вместимость, когда вы строите f',
[15:05.560 --> 15:13.560]  это cf, поток всегда меньше вместимости по определению, поэтому я имею право так заменить. У вас поток не
[15:13.560 --> 15:21.000]  больше, чем capacity, ну или емкость, соответственно, минус поток больше либо равно, чем минус емкость. Так,
[15:21.000 --> 15:27.400]  ну что еще хочется теперь сделать? Да, мы, естественно, смотрим, что УВ, давайте из Е,
[15:27.400 --> 15:34.640]  конечно же, их напишем. Почему? Потому что мы смотрим поток изначальной сети в Н, да? Значит,
[15:34.640 --> 15:39.120]  нам выгодно, адекватно рассматривать только для тех ребер, которые были в сети изначальной.
[15:39.120 --> 15:53.960]  Вот, окей. Хорошо, а если у нас сети изначальный, то тогда что можно заметить? Что остаточная
[15:53.960 --> 16:04.080]  пропускная способность ВУ, она у нас по сути, потому что смотрите, что у нас происходит,
[16:04.080 --> 16:12.960]  если у нас УВ было в сети, то cf от ВУ определяется как f от УВ просто-напросто. Согласны? Ну,
[16:12.960 --> 16:22.880]  просто по второй ветке определения. Поэтому я здесь могу написать вот так вот просто, что это f от УВ
[16:22.880 --> 16:37.760]  плюс f' от УВ минус f от УВ. Просто по второй ветке определения я раскрываю cf от ВУ. Так,
[16:37.760 --> 16:48.240]  ну это равно этому, то есть это равно f' от УВ, ну что по свойству потока не отрицательно. Так,
[16:48.240 --> 16:52.560]  окей, доказали не отрицательность. Давайте во вторую сторону доказывать. То есть вот эту
[16:52.560 --> 17:17.320]  штуку. Пункт Б. Так, ну давайте. Снова пишем для ребра из ДЕ f плюс f' от УВ. Что? В смысле
[17:17.320 --> 17:24.800]  нет. Мы оцениваем f плюс f' все время. Нам нужно показать, что это больше уровня нуля, чем мы будем
[17:24.800 --> 17:32.840]  показывать, что это меньше уровня capacity в любом случае. Так, это у нас кто такой? Это f от УВ. Здесь
[17:32.840 --> 17:49.240]  вроде будет проще. УВ минус f' от ВУ. Так, ну давайте сделаем вот как. А, ну здесь предлагают сделать вот
[17:49.240 --> 18:01.120]  так вот. Забить на третье слагаемое просто. Но в силу того, что у вас поток не отрицательный,
[18:01.120 --> 18:07.880]  в вычитании его такое уменьшает выражение. Ставим только два первых слагаемых. Так,
[18:07.880 --> 18:18.680]  теперь давайте поймем, что такое f' от УВ. f' от УВ будто бы хочется сказать, что это вот так
[18:18.840 --> 18:31.560]  хочется написать по определению. Согласна, да? Ну потому что поток в остаточной сети не может
[18:31.560 --> 18:41.240]  быть больше, чем capacity в остаточной сети. Просто по определению потока f'. Ну теперь просто-напросто
[18:41.240 --> 18:51.320]  заметим, что УВ лежит в Е, поэтому мы пользуемся этой веткой. Вот она. То есть cf от УВ равно c от УВ
[18:51.320 --> 19:04.640]  минус f от УВ. Откуда cf от УВ плюс f от УВ? Это c от УВ. Ну доказали. Доказали, что f' плюс f' это
[19:04.640 --> 19:13.160]  пункция, которая лежит вот в таком вот промежутке. Остается доказать, что это сохранение потока.
[19:13.160 --> 19:24.160]  Как у нас говорилось свойство сохранения потока? Что для любой вершинки В из В без С и Т,
[19:24.160 --> 19:36.640]  что мы хотели с вами? Мы с вами хотели, чтобы сумма по У из Вf от УВ равна была сумме по У из Вf от Ву.
[19:36.640 --> 19:43.760]  То есть это то, сколько втекает в В, это то, сколько вытекает из В. Мы хотели, чтобы это было равно.
[19:43.760 --> 19:58.240]  Ну давайте мы это же и запишем. Давайте любой У будем суммировать, чтобы у вас потом в конспектах не возникало
[19:58.240 --> 20:17.680]  проблем с тем, что буквы разные. Выписываем просто определение. Так, по В из В f плюс f' от УВ. Вот вы
[20:17.680 --> 20:23.360]  хотим понять, что эта сумма будет такой же. Ну давайте этим займемся, что мы для этого сделаем.
[20:23.360 --> 20:43.120]  Для этого запишем определение для начала просто. По В из В f от УВ плюс f' от УВ минус f' от ВУ.
[20:43.120 --> 21:05.120]  Ну окей. Что тогда можно сделать? Заметим следующее, что для f верно сохранение потока.
[21:05.120 --> 21:15.360]  Согласны, да? Ну потому что f по определению. Тогда я могу просто здесь переставить ВУ местами.
[21:15.360 --> 21:25.000]  Ну аналогично для f' верно сохранение потока.
[21:25.000 --> 21:33.120]  Поэтому здесь для f и f' верно сохранение потока. То есть я могу здесь переставить,
[21:33.120 --> 21:40.160]  здесь переставить и здесь переставить буквы. То есть здесь как раз-таки все очень просто.
[21:40.160 --> 22:02.080]  Ну тогда я могу заключить, что это просто по определению сложения потоков f плюс f' от ВУ.
[22:02.080 --> 22:10.880]  То, что требовалось доказать. Мы доказали, что f плюс f' это поток. Вау, это было интеллектуально.
[22:10.880 --> 22:30.080]  Да, по В. Это сколько в f текло, это сколько из В вытекло. Так, второй пункт. Хотим,
[22:30.080 --> 22:41.760]  что модуль f плюс f' это модуль f плюс модуль f'. Причем, напомню, что модуль f это сумма по всем.
[22:41.760 --> 22:56.120]  Так, сейчас давайте скажем это так. Вроде похоже на правду, что можно это так определить.
[22:56.120 --> 23:04.440]  А, ну нет, конечно же нельзя, потому что у нас сейчас минус суммы обитекающих.
[23:04.440 --> 23:14.040]  Во, теперь правда. То есть это сколько из f вытекает, это сколько из f втекает. Вот это
[23:14.040 --> 23:25.880]  наше определение было. Ну давайте напишем определение модул f плюс f'. Это просто
[23:25.880 --> 23:45.560]  сумма по всем В из В f плюс f' т.е. до В. Минус сумма по всем В из В f плюс f' из В в С.
[23:45.560 --> 23:54.040]  Ну будто бы хочется взять да расписать все это в 6 сумм. Никогда не возникало такого желания.
[23:54.520 --> 24:07.560]  Балдеж. Ну сейчас с этим будем заниматься. Так. А, ну да, окей. Давайте еще обозначу вот такую
[24:07.560 --> 24:31.200]  вот штуку. Что В1 это у нас будет множество таких В, что СВ лежит в Е. В1 это 1. Аналогично В2
[24:31.200 --> 24:42.560]  определю где-нибудь здесь. Ну чтобы мне было удобнее писать суммирование. То есть это ребра
[24:42.560 --> 24:52.800]  входящие в С. То есть ребра исходящие из С это исходящие из С. Наоборот, это исходящие,
[24:53.560 --> 25:03.040]  все уплыли окончательно. То есть по сути я здесь могу написать вот так вот. Потому что это по сути
[25:03.040 --> 25:11.560]  те, кто из С входит, это те, кто в С входит. Вот. Ну окей, теперь просто-напросто это все запишем.
[25:11.560 --> 25:28.680]  Так, это что такое? Сумма по В из В1 ф от С до В по В из В1 ф штрих от С до В минус сумма по В из
[25:28.680 --> 25:51.640]  В1 ф штрих от С. Минус. Так, выписываем дальше. Минус по В из В2 ф от ВС. Минус по В из В2
[25:51.640 --> 26:04.880]  ф штрих от С до В. Получается плюс сумма по В из В2 ф штрих от В до С. Да. Сейчас,
[26:04.880 --> 26:13.360]  так, минутку. Здесь ВС, здесь ВС, а здесь СВ. Во, вот так вот. Почему? Потому что у меня здесь
[26:13.360 --> 26:19.480]  изначально ВС, здесь не меняю, здесь не меняю, здесь должен поменять. Во, все, теперь сложилось.
[26:19.480 --> 26:27.720]  Это я группирую с этим, это с этим группирую, это с этим группирую, это с этим группирую. Так,
[26:27.720 --> 26:42.560]  что это такое? Напишу сразу, что это сумма по В из В1 ф от С до В минус сумма по В из В2 ф от ВС.
[26:42.560 --> 26:51.480]  Проницательный зритель сразу поймет, что это такое, что это модуль F. Так, поехали дальше.
[26:51.480 --> 27:11.480]  Плюс сумма по В из В1 с В2 ф штрих от С до В минус сумма по В из В1 с В2 ф штрих от В до С. Так,
[27:11.480 --> 27:19.560]  ну давайте. Кто не согласен с тем, что это модуль F? Здесь я могу В1 расширить до В,
[27:19.560 --> 27:24.920]  суммирование просто до В. Почему? Потому что все остальные такие потоки это 0. Поэтому здесь я
[27:24.920 --> 27:33.840]  могу убрать индекс 1. Аналогично, здесь я могу убрать индекс 2. Поэтому это просто F. Все,
[27:33.840 --> 27:40.160]  что в скобках, это модуль F. Так, и здесь что я могу сказать? Что, по сути, то, что я здесь написал,
[27:40.160 --> 27:44.960]  это, конечно, классно, но здесь В1 с В2, я также могу на В заменить просто-напросто, потому что для
[27:44.960 --> 27:55.560]  всех остальных поток 0 будет. Поэтому здесь я могу написать плюс сумма по В из В ф штрих от С до В
[27:55.560 --> 28:07.520]  минус сумма по В из В ф штрих из В в С. Но это по определению просто величина ф штрих. Конец.
[28:07.520 --> 28:21.240]  Второе по сложности утверждение доказали. Скоро будет первое. Пределение в сети N равный
[28:21.240 --> 28:48.920]  JVE CST. Разрезом ST называется A. Ну, пара ST такая, что S, D, V, ST это V. Ну, и то, что мы с вами в
[28:49.400 --> 28:53.360]  как раз делали, что у нас пересечение пустое, а их объединение полностью это множество вершин.
[28:53.360 --> 29:03.960]  И второе это то, что и ST лежит в одной доле, ST лежит в другой. Мы здесь их вот так вот разделять
[29:03.960 --> 29:17.760]  будем. Дальше определение. Пропускная способность разреза определяется крайне интеллектуально.
[29:17.760 --> 29:30.480]  Так, С от УВ. То есть рассматривается серебра из ST и берется их суммарная емкость. Еще одно
[29:30.480 --> 29:37.840]  определение. Поток через разрез. Он уже определяется чуть-чуть интеллектуальнее.
[29:37.840 --> 30:01.120]  Казалось бы, хотелось бы на этом закончить, но нет. Ужасно. Нам нужно доказать несколько
[30:01.120 --> 30:05.760]  утверждений. Мы хотим доказать, что вообще поток через любой разрез одинаковый,
[30:05.760 --> 30:13.120]  если фиксировать поток, то раз. Два, мы хотим доказать, что поток через любой разрез не
[30:13.120 --> 30:18.800]  превосходит вместимости любого разреза. Три, мы хотим доказать, что они соприкасаются ровно в
[30:18.800 --> 30:23.520]  одной точке, когда мы находим максимальный поток. И четыре, доказать их вероятность всех этих
[30:23.520 --> 30:29.160]  утверждений. Собственно, когда мы это все докажем, мы докажем теорема Форта Флкерсона.
[30:29.160 --> 30:52.760]  Теорема FF. Пусть ST это произвольный разрез. N и фиксирован F. Поток. Тогда
[30:52.760 --> 31:06.080]  что поток через разрез, это просто лично потока. Мы здесь берем на произвольный разрез,
[31:06.080 --> 31:12.400]  то есть, в хорошем, здесь надо вешать квантор для любого разреза. F это какой-то фиксированный поток.
[31:12.400 --> 31:24.160]  Ну сейчас, по-моему, самая дичь. Да, самая дичь. Все дальше просто будет доказывать.
[31:24.160 --> 31:42.920]  Так, по определению, модуле F это сумма по VSV, F от SV, минус сумма по VSV, F от VS. Да. Окей. Так,
[31:42.920 --> 31:49.800]  ну что можно сказать? Я хочу сейчас немножко навалить кринжа и добавить сюда слагаемое
[31:49.800 --> 31:57.480]  одно нулевое. Будет он выглядеть ужасно, но вы не пугайтесь. Переписываем все то же самое.
[31:57.480 --> 32:13.120]  По U из S без S. Уже страшно, да? А теперь пишем нулевое слагаемое.
[32:13.120 --> 32:32.560]  Почему это нулевое слагаемое? Потому что это сколько из U в F текло, это сколько из V в U вытекло.
[32:32.560 --> 32:45.640]  По сохранению потока равно нулю. Поэтому суммируйте кучу раз нулевые слагаемые,
[32:45.640 --> 32:53.120]  поэтому это 0. Поэтому сумма не меняется. Ну что теперь можно сказать? Я предлагаю раскрыть все это
[32:53.120 --> 33:04.600]  дело, потому что было две суммы, станет сейчас четыре. Некоторые из них двойные. F от S до V,
[33:04.600 --> 33:32.240]  F из V в S, сумма по U из S без S, F от V, минус сумма по U из S без S, сумма по V из V, F от V в U.
[33:32.240 --> 33:41.200]  Так, ну что можно сказать? То есть на самом-то деле, смотрите, я могу здесь переставить порядок
[33:41.200 --> 33:54.720]  суммирования, согласны? Да, извините, еще сумму надо написать. Здесь сумма по V из V, F от U V,
[33:54.720 --> 34:01.800]  да, вы правы. Смотрите, что я сейчас буду делать. Я переставлю порядок суммирования здесь. Давайте,
[34:01.880 --> 34:08.040]  будто бы, напишу, что это сначала сумма по V из V, а здесь сумма по U. И заметьте, что здесь у меня
[34:08.040 --> 34:17.120]  сумма по V из V дофиксированной S. То есть, по сути, у меня здесь перебираются все V из V, а когда
[34:17.120 --> 34:23.640]  сгруппирую эту и эту часть, у меня будут перебираться все U из S большого. Согласны?
[34:23.640 --> 34:34.540]  Аналогично здесь. Поэтому что я делаю? Это просто сумма по V из V, сумма, вот это с этой
[34:34.540 --> 34:56.380]  группирую, по U из S, F от U V, да, минус, аналогично, сумма по V из V, сумма по U из S, F от V U, да.
[34:56.380 --> 35:08.220]  Теперь самое ужасное. Что такое суммирование по V большому? Это суммирование по S и суммирование
[35:08.220 --> 35:14.740]  по T, потому что S и T не пересекаются. Поэтому сейчас я распишу каждую из этих сумм как две. Здесь
[35:14.740 --> 35:21.980]  я возьму отдельно S, отдельно T, и здесь я возьму отдельно S, отдельно T. Так, получится сумма по V из S,
[35:21.980 --> 35:39.980]  по U из S, по V из S, F от U V, плюс сумма по U из T, сумма по V из S, F от U V, да. Получаем дальше
[35:39.980 --> 36:00.300]  6 минус, сумма по U из S, сумма по V из T, ой, V из S, у нас всегда U из S, да, было? У нас U всегда U из S, да?
[36:00.300 --> 36:11.420]  У всегда U из S, а V мы расписываем по обеим. Понимаете, U из S всегда, это будет S T. Вот так вот.
[36:11.420 --> 36:29.500]  F от V U, минус сумма по U из S, сумма по V из T, F от V U. Вроде бы на правду похоже. Так,
[36:29.500 --> 36:50.860]  давайте заметим вот что с вами. Сгруппируем 1 с 3, 2 с 4. Минус сумма по U из S, сумма по V из S,
[36:50.860 --> 36:56.580]  F от V U. Провинциательный читатель должен сразу сказать, чему равна эта разность.
[36:56.580 --> 37:22.380]  Давайте, чему равна эта разность. Ну да, потому что по сути вы здесь перебираете ровно одно и то же.
[37:22.380 --> 37:27.180]  Вы можете понять здесь порядки суммирования здесь буквами местами. То есть вы каждую пару V U
[37:27.180 --> 37:34.180]  рассматриваете ровно один раз здесь, и точно такую же пару V U рассматриваете здесь один раз.
[37:34.180 --> 37:44.220]  Ну это примерно как вы будете считать сумму от 1 до N или сумму от N до 1. Суммы получатся одинаковыми,
[37:44.220 --> 38:04.460]  в конце концов. Поэтому это 0. Это кто такой? А это F от ST. Ну все, доказали. Следствие
[38:04.460 --> 38:18.780]  для произвольного F, для произвольного ST, F заведомо меньше либо равно, чем модуль F.
[38:18.780 --> 38:34.740]  F от ST. Я надеюсь, это очевидно. Если нет, то могу расписать. А, давайте распишем.
[38:34.740 --> 38:44.660]  Ровно F от ST. У нас же F от ST фиксирован, F фиксирован. Значит, я могу расписать,
[38:44.660 --> 38:53.780]  просто поток через этот разрез. Дальше по определению по U из S сумма по V из ST, F от U в,
[38:53.780 --> 39:05.460]  минус сумма по U из S сумма по V из ST, F от V U. Смотрим, это по определению поток, значит,
[39:05.460 --> 39:11.620]  он не отрицательный. Вычитая что-то отрицательное, вычитая что-то положительное, мы выражение уменьшаем.
[39:11.620 --> 39:25.540]  Поэтому это не превосходит. Просто, ой так, ну поток не превосходит всегда вместимости.
[39:25.540 --> 39:42.860]  С от U в, что равно С от ST. Ну все, то, что мы хотели. То есть, смотрите, что у нас с вами получается,
[39:42.860 --> 39:51.020]  картина очень интересная. Вот наша действительно числа какая-то. Здесь какое-то разделяющее
[39:51.020 --> 39:59.820]  значение. Есть вот какой-то F1, есть какой-то модуль F2, есть там модуль F3. То есть, величины потоков
[39:59.820 --> 40:10.660]  лежат всегда слева. Здесь будут лежать какие-то там C от S1T1. То есть, какие разрезы вы бы не выбирали,
[40:10.660 --> 40:16.180]  какой поток вы бы не выбирали, у вас всегда есть меньше либо равно равенство. Поэтому у вас одни строго
[40:16.180 --> 40:24.180]  справа, другие строго слева. Возникает вопрос, есть ли вот эта вот точка, так сказать, наш вот этот
[40:24.180 --> 40:35.660]  F со звездой. Вот, оказывается, есть. Есть theorem for the folkerson, огласящая, что если вы нашли поток F в сети
[40:35.660 --> 40:42.980]  какой-то и он максимален, тогда найдется разрез на емкости равной величине потока. То есть, это
[40:42.980 --> 40:49.540]  будет максимальный поток или минимальный разрез. Или третье утверждение, что в остаточной сети не
[40:49.540 --> 41:11.580]  найдется пути из SFT. Так, ну поехали. theorem for the folkerson. Пусть F это поток в сети N.
[41:11.580 --> 41:25.900]  Тогда следующее утверждение эквивалентное. И давайте выпишем эти утверждения.
[41:25.900 --> 41:52.220]  Первое, это F максимален, то есть, модуль F максимально. Второе, это NF нет пути из SFT.
[41:52.220 --> 42:06.340]  Третье, из SFT именно. Если я сказал SFT, то я оговорился, извините. Существует
[42:06.340 --> 42:24.220]  ST разрез такое, что ZST модуль F. Все теорема. Если мы доказываем, то плюс-минус понятно,
[42:24.220 --> 42:29.860]  как дальше жить, как искать потоки. Поток будет искать очень просто. Вы будете пускать единичку
[42:29.860 --> 42:35.940]  потока, строить остаточную сеть, дальше смотреть, правда ли, что там уже нет пути из SFT,
[42:35.940 --> 42:43.380]  если еще есть, то и делать так до бесконечности, пока поток не останется. Это алгоритм for the
[42:43.380 --> 42:51.260]  folkerson. Покажем теорему. Так, поехали. Ну, я предложу доказать из 1 в 2 сначала. Самое
[42:51.260 --> 42:59.860]  простое. Что F максимален, значит нет пути из SFT. Ну, предполагаю противное. Ну, или просто
[42:59.860 --> 43:19.260]  докажем в обратную сторону. Если NF есть путь P из SFT, это следует, что вдоль P можно пустить
[43:19.260 --> 43:38.060]  дополняющий F'. Такое, что модуль F' больше нуля, очевидно. Но тогда F не максимальный. Дорога.
[43:38.060 --> 43:46.200]  Что? Путь P из SFT. То есть, если вы нашли какой-то путь, вы вдоль него пускаете единичку потока,
[43:46.200 --> 43:54.880]  вы смогли ее все-таки заткнуть, потому что у вас это путь из SFT. Значит, у вас есть F' с величиной
[43:54.880 --> 44:02.080]  строго больше нуля. Значит, у вас есть поток F' с величиной равной модуле F' с модуле F'. То есть,
[44:02.080 --> 44:07.560]  что строго больше модуле F'. Значит, F не максимальный. Противоречие, грубо говоря.
[44:07.560 --> 44:14.320]  Доказали и задим в два. Так, теперь, что простенького, что простенького. Давайте
[44:14.320 --> 44:22.440]  с 3 в 1 тоже простенько доказывать. Так, нам известно, что модуль F для любого F,
[44:22.440 --> 44:37.520]  для любого ST, модуль F меньше либо равно, чем TST. Но если существует такой TST,
[44:37.520 --> 44:49.800]  что модуль F равен TST, то следует, что F максимальный. Но это очевидно, почему на самом деле.
[44:49.800 --> 44:58.320]  Допустим, что F не максимальный. Значит, существует еще больший поток F, строго больше него. Давайте
[44:58.320 --> 45:11.680]  предположим, что пусть существует F0, такое, что модуль F0 больше, чем модуль F'. Из этого следует,
[45:11.680 --> 45:23.280]  что модуль F0 больше, чем TST. Но у нас же есть вот это вот. Противоречие. Поэтому этого быть не
[45:23.280 --> 45:31.120]  может. Хорошо, доказали из 3 в 1 и задим в два. Остается доказать из 2 в 3, получается, чтобы
[45:31.120 --> 45:39.000]  зациклить. Давайте доказывать. Доказать здесь будет очень простым, на самом деле. Продолжение
[45:39.000 --> 45:52.320]  получилось настолько безыдейным, что доказывается по страничке. Так, из 2 в 1 доказываем. В NF нет
[45:52.320 --> 46:10.200]  пути из S в T. Сейчас доказываем из 2 в 3. Да, из 2 в 3 надо доказывать. В NF нет пути из S в T. Тогда
[46:10.200 --> 46:13.920]  я сейчас просто построю такой разрез, для которого будет верно, что это равно величине потока.
[46:13.920 --> 46:31.840]  Определим, что S равно V таких, что V достижимо из S в NF, T равно V без S. Согласны ли вы с тем,
[46:31.840 --> 46:38.400]  что хотя бы T маленькая лежит в T большой? Просто потому, что у вас T недостижимо из S,
[46:38.400 --> 46:48.280]  поэтому она лежит в T. Ещё нужно, конечно, проверить, что это разрез по определению,
[46:48.280 --> 46:54.640]  что у вас действительно нет общей вершинки у них и что они суммарно, понятно, что суммарно они
[46:54.640 --> 46:59.400]  образуют V. Нужно проверить, что среди них, что в них лежат все вершины, это очевидно,
[46:59.400 --> 47:07.440]  и что нет вершины, лежащие в и в S, и в T. Это вроде тоже очевидно плюс-минус.
[47:07.440 --> 47:30.720]  Давайте тогда считать F в T просто-напросто. По определению F от V минус сумма по VST,
[47:30.720 --> 47:55.040]  F от VU. Теперь поймём, что такое ребро через разрез. Давайте поймём вот что. Я хочу сказать,
[47:55.040 --> 48:08.360]  что F от UV равно C от UV. Понимаете, почему это так? Изначально сети у меня UV из E,
[48:08.360 --> 48:24.680]  тогда в остаточной сети, что я хочу, это N. У меня очевидно и появляется ребро обратное из UV,
[48:24.680 --> 48:30.040]  но смотрите, так как вы лежит в T большом, из этого следует, что у меня нет обратного
[48:30.040 --> 48:37.600]  ребра, вот такого вот. Согласны? Значит, у меня капаситет этого ребра ноль. А чтобы
[48:37.600 --> 48:43.280]  капаситет обратного ребра было ноль, у меня должно быть, что F от UV равно C от UV из UV. Я же не
[48:43.280 --> 48:48.720]  хочу, чтобы у меня здесь из S все достижимо. А V недостижимо из S, значит у меня нет такого
[48:48.720 --> 48:53.920]  ребра. А чтобы у меня не было такого ребра, нужно, чтобы ребро UV было полностью насыщенным.
[48:53.920 --> 49:03.640]  Иначе у меня возникает обратное ребро, вот такое вот, и всё, и плохо. То есть у меня как бы остается,
[49:03.640 --> 49:07.920]  грубо говоря, у меня остается ещё какая-то ёмкость здесь, то есть я могу ещё протопнуть поток.
[49:07.920 --> 49:22.280]  Такого быть не должно. То есть я с вами доказал следующее, что это C от UV. Чтобы доказать,
[49:22.280 --> 49:30.800]  что это C от ST, мне нужно доказать, что это ноль. Ну абсолютно по тем же соображениям. Если у меня
[49:30.800 --> 49:45.400]  есть ребро VU в сети, то я хочу, чтобы поток через ноль был ноль. А если у меня есть F от VU, значит у меня есть
[49:46.400 --> 50:01.440]  ребро UV в сети. Ладно, сейчас давайте распишем это полностью. Если VU лежит в Е, из этого следует,
[50:01.440 --> 50:10.040]  что F от VU равно нулю. Вот я хочу это показать. Если VU есть в сети, то F от VU равно нулю. То есть что
[50:10.040 --> 50:16.600]  в обратную сторону никто не течёт через разрез. Давайте предположим иначе. Иначе,
[50:16.600 --> 50:37.280]  так, CF от UV равное F от VU больше нуля. Почему это так? Потому что у нас VU в сети, значит
[50:37.280 --> 50:44.800]  остаточная capacity ребра UV это F от VU просто-напросто по определению. Потому что если у нас VU в сети,
[50:44.800 --> 50:55.800]  то F от UV это CF от UV. Так, а если это больше нуля, из этого следует, что в NF есть ребро
[50:55.800 --> 51:12.800]  UV. Но если есть ребро UV, ну всё, это плохо. Значит у нас V достижимо из S. В достижимо
[51:12.800 --> 51:23.760]  из S маленькой. Противоречие, у нас этого не было. Это не достижимо, потому что VST лежит. Поэтому
[51:23.760 --> 51:39.960]  это ноль. То есть я построил только что разрез, для которого верно, что он равен модуле F просто-напросто.
[51:39.960 --> 51:46.040]  А ну, да, здесь надо написать, что модуль F равно F от ST. Это мы уже с вами доказали,
[51:46.040 --> 51:54.280]  что любого разреза для любого потока модули F это F от ST. Ух, ну всё. Это было сложно, я считаю.
[51:54.280 --> 52:02.680]  Но тиремма Форда Фолкерсона доказана. А из этого следует алгоритм Форда Фолкерсона непосредственно.
[52:02.680 --> 52:08.000]  В смысле, чем хороша тиремма Форда Фолкерсона? Тем, что мы впервые получили хоть какой-то механизм,
[52:08.000 --> 52:17.520]  хоть какой-то, позволяющий нам искать поток. Потому что мы нашли какой-то адекватный критерий
[52:17.520 --> 52:23.200]  максимальности потока. Потому что, если он дать какой-то поток и сеть, вообще не очевидно,
[52:23.200 --> 52:29.360]  как проверить, что он максимален. Вот внезапно тиремма Форда Фолкерсона позволила нам как
[52:29.360 --> 52:35.640]  раз-таки эту проблему решить тем, что мы можем построить остаточную сеть, поискать в ней путь,
[52:35.640 --> 52:42.320]  и если мы его нашли, то поток не максимален. Собственно, алгоритм Форда Фолкерсона, окей,
[52:42.320 --> 53:11.000]  шаг первый. Найди путь из С в Т с помощью DFS. Если такого нет, то F максимален. А, ну изначально
[53:11.000 --> 53:29.880]  инициализация F тождественно равна нулю на всех ребрах. Иначе пункт второй. Протолкни F штрих вдоль
[53:29.880 --> 53:53.880]  пути. Шаг третий. F равно F плюс F штрих. Перестрой NF. То есть, вы нашли дополняющий поток,
[53:53.880 --> 53:58.680]  перестроили вдоль ребер, через которые тек у вас поток, остаточные стоимости,
[53:58.680 --> 54:05.160]  вместимости пересчитали. То есть, у вас изначально остаточная сеть равна искомой сети, исходной сети,
[54:05.160 --> 54:12.080]  а поток тождественно равный нулю везде. Затем вы нашли путь из С в Т, протолкнули вдоль него
[54:12.080 --> 54:21.720]  поток какой-то величины, вдоль F штрих. Дальше вдоль этих ребер поменяли остаточные вместимости.
[54:21.720 --> 54:42.920]  Это и есть перестрой остаточную сеть. Все, алгоритм окончен. Повтори 1-4. Классный алгоритм. То есть,
[54:42.920 --> 54:47.880]  все сложное было это в теории, чтобы это все доказать. На практике, по сути, вы будете писать,
[54:47.880 --> 54:56.760]  while есть путь, протолкни через путь, измени остаточную емкость на пути и поток через ребро. Все.
[54:56.760 --> 55:05.000]  Там 50 строк-кода примерно, если писать, как вы пишете. На ревью будет порядка 400 строк-кода,
[55:05.000 --> 55:10.760]  сразу предупреждаю. Потому что вам придется писать граф, придется писать строитель сети,
[55:10.760 --> 55:18.040]  придется писать шаблонные BFS и DFS для всего этого. Ну, вы уже должны были привыкнуть. Так,
[55:18.040 --> 55:25.200]  окей. Давайте оценим сложность времен у этого всего дела. Ну, казалось бы, давайте считать,
[55:25.200 --> 55:40.040]  что F действует из В квадрата в Z+. Ну, тогда сложность алгоритма
[55:40.040 --> 56:02.240]  от E на F. Почему? Потому что у вас ровно F раз, ну, максимум F раз запустится ваш поиск пути,
[56:02.240 --> 56:08.160]  да? Потому что, если только F раз протолкнули по единичке поток, у вас не получится уже ничего
[56:08.160 --> 56:21.080]  сделать. Здесь надо не так чуть-чуть написать. У вас суммарно будет модуль F DFS. Чем плох
[56:21.080 --> 56:35.960]  форт Фалкерсон? Чем он плох тем, что если у вас F действует в R, ну, в R+, почему F? Давайте CF,
[56:35.960 --> 56:44.000]  CF. Тогда все OK. Если CF у вас вещественные, то можно построить сеть, где алгоритм форта
[56:44.000 --> 56:51.920]  Фалкерсона будет сходиться бесконечно долго. Он будет постоянно перестраивать вдоль там, то есть
[56:51.920 --> 56:56.960]  у него там будет геометрической прогрессии убывать ребра, которые он там перестраивает, потоки через
[56:56.960 --> 57:03.000]  них. Поэтому он будет очень долго сходиться. Более того, есть контрпример, когда он сходится,
[57:03.000 --> 57:08.960]  во-первых, бесконечно долго, во-вторых, сходится вообще к неверному ответу. Поэтому это не самый
[57:08.960 --> 57:24.160]  лучший алгоритм, однако он неплох. Вот так. Алгоритм Эдманца Карпа. Эдманца Карпа.
[57:24.160 --> 57:54.000]  А про что этот алгоритм? Шаг 1. Возьмите алгоритм форта Фалкерсона. Шаг 2. Конец.
[57:54.160 --> 58:04.240]  То есть вам нужно искать не с помощью ДФС пути, а с помощью ДФС. Тогда есть несколько классных
[58:04.240 --> 58:08.880]  свойств. Во-первых, мы избавляемся от этих контрпримеров с вещественными числами. Он всегда
[58:08.880 --> 58:20.680]  сходится и всегда нормально работает. Это первое. Второе. Сложность. Вот такая вот будет.
[58:20.680 --> 58:33.520]  Без доказательств. Еще 40 минут доказывать эту теорему и не выдержу. Вот. Там выводится,
[58:33.520 --> 58:40.240]  что у вас порядка ВЕ итерации будет в этом алгоритме. И все хорошо, и все у них было прекрасно.
[58:40.240 --> 58:55.400]  Примерно так. Я позволю себе это опустить все-таки. Так. Определение. Пара УВ из В квадрат,
[58:55.400 --> 59:16.840]  реберно, К связано. Если при удалении любых ж меньше К ребер,
[59:16.840 --> 59:45.280]  все еще есть путь из УВ. То есть когда у нас были мосты, мы с вами искали мосты в графе и находили
[59:45.280 --> 59:49.760]  компоненты реберной двухсвязанности. Когда удалили мосты, компонент связанности превышает
[59:49.760 --> 59:54.720]  компонент реберной двухсвязанности. Здесь немножко не так, здесь все чуть сложнее.
[59:54.720 --> 01:00:04.080]  А именно здесь так сходу, с насколько для всего графа не получится ответить его о связанности.
[01:00:04.080 --> 01:00:09.840]  Однако для пары вершин в принципе сможем. Давайте подумаем, что делать.
[01:00:09.840 --> 01:00:25.480]  Ну да, вот казалось бы, что значит удалить ребра? Нам нужно разрез искать. Причем мы хотим удалить
[01:00:25.480 --> 01:00:32.240]  минимальное число ребер, поэтому соответственно нам нужно минимальный разрез искать. Значит нужно
[01:00:32.240 --> 01:00:52.640]  построить сеть У и СТОК, ВСТОК. Ребра, заменим ребра на двунаправленные например, то есть в одну
[01:00:52.640 --> 01:01:01.200]  и в другую сторону. Ребра заменим на двунаправленные. Ребра, точнее на пару
[01:01:01.200 --> 01:01:20.200]  направленных. Пару односторонних заменим на пару односторонних. С тождественно равно единичке.
[01:01:20.200 --> 01:01:29.720]  Компасити будет равно единичке тождественно. Вот такая вот идея. Как мы с вами говорили,
[01:01:29.720 --> 01:01:34.200]  мы в сети не допускаем антипараллельных ребер, а мы тут внезапно вообще строим каждый
[01:01:34.200 --> 01:01:39.480]  ребро, делаем его антипараллельным. Поэтому у вас должна быть по идее в коде прекрасная функция,
[01:01:39.480 --> 01:01:45.560]  которая берет граф и избавляется от антипараллельных ребер. Вот так, что дальше нужно сделать.
[01:01:45.560 --> 01:01:57.760]  Ну все, сеть ввели, давайте изобразим ее как-нибудь. Так, первый раз это у нас получится что? Что я
[01:01:57.760 --> 01:02:19.080]  превращу все двунаправленные ребра. Ужасно. Получилось буквотето. Так, теперь давайте рисовать.
[01:02:19.080 --> 01:02:31.040]  Давайте это у, это а, это б. Так, вершина у, мы для нее делаем фиктивную вершинку. Это а,
[01:02:31.040 --> 01:02:39.000]  и для нее вот сюда вот шлеп и последний шлеп. Во. Ну чуть-чуть увеличили сеть, ну слегка раздули
[01:02:39.000 --> 01:02:48.640]  бывает. Число вершин стало число вершин плюс число ребер. Число ребер увеличилось вдвое. Нет,
[01:02:48.640 --> 01:02:57.800]  втрою. Короче, линейное увеличение, поэтому 8 точек вообще не роляет. Ну теперь нужно искать в
[01:02:57.800 --> 01:03:06.540]  этой сети максимальный поток. Точнее, нужно искать в этой сети минимальный разрез. Нужно найти
[01:03:06.540 --> 01:03:16.900]  минимальный разрез. Потому что минимальный разрез как-то
[01:03:16.900 --> 01:03:22.900]  раз-таки делает нам из U недостижимой V. Ну или наоборот, из V недостижимой U.
[01:03:22.900 --> 01:03:28.180]  Нужно найти минимальный разрез. Но казалось бы, нам нужно найти, точнее, мы умеем искать
[01:03:28.180 --> 01:03:31.860]  минимальный разрез, а нам нужно найти минимальное число ребер. Но всего того, что у нас
[01:03:31.860 --> 01:03:36.620]  капасти тождественной равно единичке, это то же самое, что найти минимальное число ребер.
[01:03:36.620 --> 01:03:51.700]  Равносильно исходной задачи. Давайте я сразу напишу, что в сети V' это будет исходное число
[01:03:51.700 --> 01:04:03.900]  вершин, плюс для каждого ребра добавится новое. E' соответственно это будет 3E. Вот это наши новые
[01:04:03.900 --> 01:04:12.820]  параметры. Минимальное капасити. Просто по определению минимального разреза,
[01:04:12.820 --> 01:04:19.180]  минимальный разрез, то тот, кого капасити минимальный. Если это не сказал, то извините,
[01:04:19.180 --> 01:04:26.860]  вроде как я говорил. Это наши новые параметры. Теперь, если мы найдем в этой сети минимальный
[01:04:26.860 --> 01:04:35.300]  разрез, значит, найдем нужное число ребер для удаления. Ну все, победа будет наша.
[01:04:35.300 --> 01:04:53.100]  Тогда ищем минимальный разрез. И все. Так, теперь нужно оценить время работы. Эдман скарп
[01:04:53.100 --> 01:05:13.700]  V'. Давайте фортфалкерсон. Давайте я не буду здесь E. В плюс E я буду E писать. Просто,
[01:05:14.140 --> 01:05:27.100]  что мне уже лень. Теперь поймем, чему равно F максимально. Ну да, в лучшем случае придется
[01:05:27.100 --> 01:05:32.940]  удалить ровно E ребер. Все вообще. Но это когда у вас конструкция вот такая вот.
[01:05:32.940 --> 01:05:47.500]  Придется все ребра удалить. Вообще можно сказать так, что если у вас K, то вам нужно
[01:05:47.500 --> 01:05:58.220]  найти, по сути, модуль F равный K. Проверить, что F хотя бы K. Если F больше K, короче,
[01:05:58.220 --> 01:06:02.260]  модуль F в итоге будет равен просто K, который будет в ответе вам фигурировать. Вот так вот.
[01:06:02.260 --> 01:06:18.140]  Поэтому F не превосходит K, а если у вас есть, ну и на K есть оценка E. Ну что круче. Ну вот,
[01:06:18.140 --> 01:06:24.420]  он уже нечем, поэтому скарп. Вот, ну больше примеров на семинаре будет.
