[00:00.000 --> 00:14.440]  Всем добрый день, давайте начнем. Сегодня последний раз, когда мы встречаемся для разговора о C++,
[00:14.440 --> 00:20.760]  дальше будут только алгоритмы, но тем осталось, мягко скажем, немало, поэтому давайте постараемся
[00:20.760 --> 00:28.320]  успеть разобрать все то, что было запланировано. Мы в прошлый раз остановились на том, что начали
[00:28.320 --> 00:35.080]  обсуждать итераторы, и кое-что, отсюда мы уже даже успели обсудить. Кажется, остановились
[00:35.080 --> 00:40.640]  здесь. Вкратце напомним, что у нас есть итератор, и итератор представляет собой
[00:40.640 --> 00:47.680]  некоторый общ ada интерфейс указателя. Мы с контейнерами можем работать через так
[00:47.680 --> 00:52.360]  называемые итераторы, и итераторы представляют интерфейс, который похож на интерфейс указателя,
[00:52.360 --> 00:55.360]  то есть их можно инкрементировать, некоторые можно декрементировать,
[00:55.360 --> 00:58.360]  можно разуменовывать, получать значения и так далее.
[00:58.360 --> 01:03.360]  В частности, итератор – это единственный способ получения элементов связанного списка.
[01:03.360 --> 01:06.360]  Понятное дело, что мы не имеем доступа к внутренней реализации списка,
[01:06.360 --> 01:12.360]  то есть мы не можем взять ноду, сказать ей next, next, next или prev, проходиться в право-лево.
[01:12.360 --> 01:18.360]  Мы можем взять итератор внутрь списка и с помощью него бегать туда-обратно.
[01:18.360 --> 01:23.360]  Ну и собственно все алгоритмы стандартной биб pureтеche
[01:23.360 --> 01:26.360]  так или иначе работают с итераторами, то есть с абстракцией итератора.
[01:26.360 --> 01:29.360]  Алгоритмы стандартной биб pureteche, они не подразумевают того,
[01:29.360 --> 01:32.360]  что вы туда будете передавать контейнер, они подразумевают,
[01:32.360 --> 01:35.360]  что вы туда будете передавать итератор, ну скажем, в данном примере,
[01:35.360 --> 01:37.360]  если вы хотите отсортировать иектор, то вы передаете итератор
[01:37.360 --> 01:40.360]  на началоبة, и speculate, и итератор наконец, vend,
[01:40.360 --> 01:43.360]  вот и соответственно этот диапазон будет сортироваться.
[01:43.360 --> 01:46.360]  Более того, итераторы помогают нам с тем, что таким образом
[01:46.360 --> 01:51.080]  ну и скажем его часть. Мы можем взять какую-то середину вектора, передать
[01:51.080 --> 01:54.840]  итератор на какой-то центральный элемент, передать итератор на другой элемент
[01:54.840 --> 01:59.680]  и отсортировать небольшой диапазон внутри целого контейнера.
[01:59.680 --> 02:07.120]  И как правило, итераторы реализуются непосредственно для каждого контейнера,
[02:07.120 --> 02:11.360]  потому что каждый итератор должен понимать, как устроен внутри контейнера.
[02:11.360 --> 02:15.720]  Условно итератор вектора понимает, что он бегает по непрерывному участку памяти.
[02:15.920 --> 02:20.680]  Итератор в списку понимает, что он указывает на конкретный узел, и в своей операции плюс-плюс
[02:20.680 --> 02:25.880]  он должен перейти к следующему узлу, а не увеличиться на ячейку памяти.
[02:25.880 --> 02:29.360]  Поэтому каждый контейнер реализует свой итератор, и этот тип можно получить
[02:29.360 --> 02:33.520]  с помощью разрешения области видимости, например, стадивектор Invo и точку.
