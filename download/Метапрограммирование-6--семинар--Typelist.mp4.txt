[00:00.000 --> 00:14.000]  Всем привет, мы начинаем. Начинаем мы наконец-то семинар, который я давно хотел, и все, что-то мы затягивали.
[00:14.000 --> 00:24.000]  Мы будем, значит, кодить, и будет это происходить через волшебную магию Live Share в S-коде.
[00:25.000 --> 00:30.000]  Ну да, все будем вместе редачить одни и те же файлы.
[00:30.000 --> 00:40.000]  Так, Invitational Link Copy to Clickboard. Значит, появилась ссылка на Live Share.
[00:40.000 --> 00:45.000]  Просьба по ней пройти и убедиться, что у вас что-нибудь работает.
[00:45.000 --> 00:50.000]  О, дискуссию можно начинать. Космические технологии.
[00:55.000 --> 01:02.000]  Так, ну дождемся пока, хоть один человек появится, и мы убедимся, что все работает.
[01:06.000 --> 01:14.000]  Запись идет. ФПС поставил мало, цепу не грузится, ноут не греется. Вроде это успех.
[01:16.000 --> 01:19.000]  Так, ну что, хоть у кого-нибудь получилось?
[01:20.000 --> 01:26.000]  Ну, может в браузере, может нет. Я с той стороны не видел, как оно работает.
[01:32.000 --> 01:38.000]  Да, и какие-то имена вбивайте, потому что гест анонимус меня как-то смущает.
[01:41.000 --> 01:43.000]  Там же можно имя вбить, правда?
[01:47.000 --> 01:48.000]  Нет?
[01:50.000 --> 01:54.000]  Есть позволение, что нужно залогинить самый Microsoft Account.
[01:54.000 --> 01:56.000]  У вас нет Microsoft Account?
[01:59.000 --> 02:01.000]  Вы не пользуетесь WinDoy?
[02:11.000 --> 02:14.000]  Мне просто нужно человек пять хотя бы, чтобы работали.
[02:14.000 --> 02:20.000]  Ну да, вот там оно некоторое время тупить может.
[02:20.000 --> 02:26.000]  Давайте тогда на такой вопрос смешно ответим, и вообще вводное, чем мы тут собрались заниматься сейчас.
[02:26.000 --> 02:31.000]  Надеюсь, вы меня слушаете, хотя бы в полухо, смотря в экраны.
[02:31.000 --> 02:37.000]  Мы хотим работать со списками типов. Что такое список?
[02:37.000 --> 02:41.000]  Ну, чисто на математическом языке. Последовательность, конечная.
[02:41.000 --> 02:47.000]  Ну, противопоставляется множеству. Последовательность, она вот фиксированная.
[02:47.000 --> 02:50.000]  И в каком смысле мы хотим список типов?
[02:50.000 --> 02:56.000]  Мы хотим какой-то другой тип, который внутри себя кодирует список других типов.
[02:56.000 --> 02:58.000]  Зачем?
[03:00.000 --> 03:02.000]  Есть идеи, зачем это может быть нужно?
[03:02.000 --> 03:04.000]  Ну, как в Расте?
[03:04.000 --> 03:10.000]  Ну, я, к сожалению, вот в Расте не знаю, что там, как обстоят дела со списками типов.
[03:10.000 --> 03:13.000]  Кажется, никак. Последний раз, когда я проверял.
[03:13.000 --> 03:22.000]  Был пропозал добавить тюплы, и там такие сразу, о, давайте тюплы еще и с типами будут работать, и ну, чего-то нет.
[03:24.000 --> 03:27.000]  Что, никак не будут списки типов использоваться?
[03:27.000 --> 03:28.000]  Как задать?
[03:28.000 --> 03:31.000]  А, никак. Есть способы.
[03:31.000 --> 03:39.000]  Ну, хорошо. Вот C++11. Какое жуткое изменение в шаблонах было, от которого все офигели?
[03:39.000 --> 03:42.000]  А? Нет, с феней было всегда.
[03:44.000 --> 03:45.000]  В рядике?
[03:45.000 --> 03:49.000]  В рядике, да. В рядике это в каком-то смысле список типов, да?
[03:49.000 --> 03:55.000]  Можем передать шаблон не один тип, а сколько угодно. 0, 1, 2.
[03:55.000 --> 03:57.000]  А чем они неудобны?
[03:57.000 --> 04:02.000]  Ну, посередине как-то обращаться к какому-нибудь катому не очень удобно.
[04:02.000 --> 04:05.000]  Ну, это решаемая проблема.
[04:05.000 --> 04:07.000]  Ну, в принципе все более-менее.
[04:07.000 --> 04:15.000]  Ну, все решаемое. Ладно. Нет, короче, проблема главная, на которую я сетую, это то, что нельзя несколько в рядиков передать один шаблон.
[04:15.000 --> 04:16.000]  Да?
[04:17.000 --> 04:21.000]  Помните, я говорил, что мы собрались обобщать абстракт факторе?
[04:22.000 --> 04:24.000]  Давайте даже картинку откроем.
[04:24.000 --> 04:26.000]  Такая-то не та...
[04:30.000 --> 04:34.000]  Произойдет ли что-то плохое, если я сейчас открою мой Google Drive?
[04:34.000 --> 04:36.000]  Кажется, там не было ничего такого.
[04:38.000 --> 04:45.000]  Да, тут только учеба. Прекрасно. Никакой дискредитирующей информации.
[04:46.000 --> 04:48.000]  Лекция какая мне нужна?
[04:49.000 --> 04:51.000]  Кто помнит, какая это была лекция?
[04:51.000 --> 04:52.000]  Первая, наверное.
[04:52.000 --> 04:54.000]  Да.
[05:00.000 --> 05:02.000]  Ты-ты-ты-ты-ты-ты.
[05:03.000 --> 05:07.000]  Где же она? Она одна из первых была. Вот. Вот-вот-вот.
[05:07.000 --> 05:11.000]  Вот абстракт факторе. Я в какой-то момент сказал, что мы собрались ее обобщать.
[05:11.000 --> 05:15.000]  Потому что тут, мол, ну код, полный boilerplate.
[05:15.000 --> 05:21.000]  Вся эта иерархия нужна просто потому, что нужна, а интеллектуального кода ни в одной функции нету.
[05:21.000 --> 05:28.000]  Там просто во всех вот этих вот create product A, create product B написано return new concrete product A.
[05:29.000 --> 05:35.000]  Вот это вот код мы не хотим руками писать, эти функции мы не хотим руками писать, эти классы мы не хотим руками писать.
[05:35.000 --> 05:37.000]  Ничего не хотим руками писать.
[05:37.000 --> 05:41.000]  Хотим сгенерировать всю вот эту вот штуку, просто указав...
[05:42.000 --> 05:44.000]  Ну, взяв какой-то шаблон и что-то в него подставив.
[05:44.000 --> 05:46.000]  А что мы будем в шаблон подставлять?
[05:46.000 --> 05:53.000]  Вот какие здесь вещи определяют вот всю эту иерархию?
[05:53.000 --> 05:56.000]  Интерфейс фабрики.
[05:56.000 --> 06:00.000]  Интерфейс фабрики? Ну а интерфейс фабрики чем определяется?
[06:03.000 --> 06:05.000]  Ну тут просто create product A, create product B.
[06:07.000 --> 06:13.000]  Это значит, что весь интерфейс, все, что в нем содержится, это вот просто список типов на самом деле.
[06:13.000 --> 06:14.000]  Что крейтим?
[06:15.000 --> 06:19.000]  Список типов, product A, product B. Это интерфейсы, кстати, да?
[06:19.000 --> 06:23.000]  Вот один список типов нам надо задать, чтобы всю вот эту штуку сгенерировать.
[06:24.000 --> 06:27.000]  А дальше есть конкретные фабрики.
[06:28.000 --> 06:30.000]  Ну, догадайтесь, чем они задаются.
[06:32.000 --> 06:36.000]  Вот конкретная фабрика 1, конкретная фабрика 2. Чем первая задается?
[06:37.000 --> 06:38.000]  Тоже списком типов.
[06:39.000 --> 06:43.000]  Конкрет product A, concrete product B. Ну, с единичкой.
[06:43.000 --> 06:45.000]  Второй список типов получили.
[06:47.000 --> 06:49.000]  И для второй concrete factory тоже список.
[06:51.000 --> 07:01.000]  То есть если это не голосом проговаривать, а в коде написать, то у нас abstract factory задается...
[07:09.000 --> 07:10.000]  Что?
[07:24.000 --> 07:26.000]  Давайте осептим всех.
[07:28.000 --> 07:34.000]  Вот видите, кто-то из вас у меня автоматом заосептился, видимо, потому что я уже раньше осептил.
[07:38.000 --> 07:40.000]  Я тоже почему-то пустил.
[07:44.000 --> 07:52.000]  Сейчас ты говоришь, что несколько вариантов как раз нельзя в тупле упаковать и внутри уже расплывать.
[07:53.000 --> 07:55.000]  Ты в правильную сторону мыслишь, но пока...
[07:56.000 --> 08:00.000]  Да, ты в абсолютно правильную сторону мыслишь, но пока идейно.
[08:00.000 --> 08:02.000]  Для тех, кто может...
[08:04.000 --> 08:06.000]  Как-то не понял из моих рассуждений.
[08:07.000 --> 08:09.000]  Вот есть один список типов.
[08:09.000 --> 08:13.000]  Product A, product B, product C. Это интерфейсы, которые мы хотим в нашей факторе.
[08:16.000 --> 08:19.000]  Любая конкретная фабрика задается...
[08:22.000 --> 08:27.000]  Product A1, product B1, product C1.
[08:27.000 --> 08:29.000]  Это другой список типов.
[08:30.000 --> 08:33.000]  Но как бы от этого списка типов мы все равно не избавляемся.
[08:33.000 --> 08:40.000]  Чтобы конкретную фабрику соорудить, нам нужно и список интерфейсов знать, и список продуктов, которые удовлетворяют этому интерфейсу.
[08:40.000 --> 08:42.000]  Два списка типов.
[08:42.000 --> 08:51.000]  Соответственно, если мы хотим вот эти вот конкретные фабрики, вот эти вот классы Concrete Factory 1, Concrete Factory 2 каким-то образом генерировать с помощью шаблонов,
[08:51.000 --> 08:58.000]  то нам нужно сначала научиться несколько разных как-то ворядек паков передавать в один класс.
[08:58.000 --> 09:02.000]  Ну, я думаю, вы должны понимать, что...
[09:04.000 --> 09:06.000]  Что я пишу?
[09:11.000 --> 09:18.000]  Вот так вот мы делать не умеем, потому что непонятно, где разделитель поставить.
[09:18.000 --> 09:25.000]  Я думаю, ничего не стоило в языке C++ ввести вот такую замечательную фишку, которая есть в некоторых других языках,
[09:25.000 --> 09:30.000]  где умеют точкой с запятой разделять такие паки, но у нас такого нет.
[09:35.000 --> 09:40.000]  Если честно, я не помню, где так можно разделять сейчас.
[09:40.000 --> 09:44.000]  Короче, вот тут есть такой язык, да, скрипт, опять пропаганда пошла.
[09:44.000 --> 09:52.000]  Вот там можно параметры функций разделять с запятыми и точками за запято, и там у этого вполне логичный смысл есть.
[09:52.000 --> 09:59.000]  Мол, через запятую ты несколько аргументов с одним и тем же типом перечисляешь, а с точкой с запятой новый тип.
[09:59.000 --> 10:01.000]  Ну, это мелочи.
[10:01.000 --> 10:07.000]  Так, вот это надо убрать, вот это надо убрать.
[10:07.000 --> 10:09.000]  Тут кто-то что-то пишет.
[10:09.000 --> 10:12.000]  Ну, давайте вот на это все забьем.
[10:12.000 --> 10:17.000]  Мы пришли к выводу, надо сделать какой-то тип, который содержит в себе несколько других типов.
[10:17.000 --> 10:19.000]  Как это сделать?
[10:20.000 --> 10:30.000]  Ну да, предлагается использовать STD tuple, но без значений, как тип, в котором просто указаны типы.
[10:30.000 --> 10:34.000]  Но я предлагаю даже так не делать, а сделал для этого свой тип.
[10:38.000 --> 10:42.000]  Давайте даже type tuple его назовем.
[10:42.000 --> 10:45.000]  И все, вот наш тип.
[10:46.000 --> 10:50.000]  Это такой tuple из типов.
[10:50.000 --> 10:52.000]  Как его предполагается использовать?
[10:52.000 --> 11:00.000]  Предполагается в какой-то другой шаблон, например, concrete factory maker какой-то.
[11:00.000 --> 11:04.000]  Передать первый type tuple.
[11:04.000 --> 11:08.000]  Может тут же тогда назначим factory factory?
[11:08.000 --> 11:10.000]  Нет.
[11:11.000 --> 11:16.000]  Не, не, не, надо полагать сущности.
[11:22.000 --> 11:24.000]  Вот так.
[11:26.000 --> 11:30.000]  Ну, factory это речь идет о конкретном шаблоне, вот этом вот.
[11:30.000 --> 11:37.000]  Maker creator это всегда такой тип, когда не хочешь заморачиваться, этот шаблон или нет.
[11:37.000 --> 11:43.000]  Хорошо, можно просто concrete factory назвать и все.
[11:43.000 --> 11:45.000]  Можно generator.
[11:48.000 --> 11:50.000]  Идея понятна.
[11:50.000 --> 11:57.000]  Мы просто вот такими двумя tuplami можем передать два разных списка в один и тот же тип.
[11:57.000 --> 11:59.000]  А зачем это?
[11:59.000 --> 12:02.000]  Кто-то откопировал, может быть это был я.
[12:02.000 --> 12:04.000]  А как с этим работать потом?
[12:04.000 --> 12:06.000]  Может быть не очень понятно.
[12:06.000 --> 12:15.000]  Потому что мы написали tt2.
[12:15.000 --> 12:17.000]  Какую-то такую штуку.
[12:20.000 --> 12:22.000]  Подожди, скорированием.
[12:22.000 --> 12:26.000]  Вот мы такой шаблон написали, передали туда два списка типов.
[12:26.000 --> 12:28.000]  А как из них достать?
[12:28.000 --> 12:32.000]  Собственно, эти самые списки изначальные как-то использовать?
[12:32.000 --> 12:37.000]  Можно по индексу получать.
[12:37.000 --> 12:42.000]  А можно как-то очень тупо, если мы просто хотим получить вот такой же pack.
[12:42.000 --> 12:45.000]  Прям параметр pack или заребай?
[12:45.000 --> 12:47.000]  Прям параметр pack получить.
[12:49.000 --> 12:51.000]  Кто меня там так активно...
[12:55.000 --> 12:58.000]  Можно сделать последний, кого-то всех.
[12:58.000 --> 13:03.000]  Нет, видимо вопрос непонятный я задаю.
[13:03.000 --> 13:09.000]  Вот здесь хочется, идейно, сделать tt1 и распаковать и что-то с ними сделать.
[13:09.000 --> 13:13.000]  Вот мы сейчас так не можем, потому что это какой-то класс непонятный.
[13:13.000 --> 13:16.000]  Ну, можно...
[13:16.000 --> 13:18.000]  Сейчас это класс у нас, да?
[13:18.000 --> 13:22.000]  Но тогда это же по сути не будет rebind.
[13:22.000 --> 13:24.000]  Что такое rebind?
[13:24.000 --> 13:28.000]  Ну, нам нужно вытащить шаблон, наверное, и можно написать.
[13:28.000 --> 13:31.000]  Мы здесь буквально выпусто оставим и закроем этот класс.
[13:31.000 --> 13:37.000]  А затем написать конкретно специализацию от тюкла с какими-то паками.
[13:37.000 --> 13:39.000]  Специализацию? Какую?
[13:39.000 --> 13:42.000]  Ну, напиши специализацию, в которой будут паки.
[13:47.000 --> 13:49.000]  Закончился класс.
[13:49.000 --> 13:51.000]  Теперь мы пишем replay.
[13:54.000 --> 14:00.000]  Никто не понимает, о чем речь, что происходит, или все понимают, и всем очевидно.
[14:00.000 --> 14:04.000]  Я прослушал просто начало довода, поэтому не смотрю.
[14:04.000 --> 14:06.000]  Так, ну, начало было какое?
[14:06.000 --> 14:10.000]  Мы хотим генерировать Concrete Factory вот такие.
[14:10.000 --> 14:13.000]  Чтобы их задать, нам нужно, во-первых, список интерфейсов,
[14:13.000 --> 14:17.000]  во-вторых, список конкретных продуктов, которым мы будем дергать new.
[14:17.000 --> 14:19.000]  Здесь написано, new дергаем.
[14:19.000 --> 14:21.000]  Нужно два списка.
[14:21.000 --> 14:24.000]  Два вариадика в одном шаблоне быть не может.
[14:24.000 --> 14:28.000]  Поэтому мы сказали, заведем вот такой вспомогательный класс TypeTuple,
[14:28.000 --> 14:32.000]  который ничего не делает, и будем через него передавать два разных списка.
[14:36.000 --> 14:39.000]  Мы сначала список запаковали в тип TypeTuple.
[14:41.000 --> 14:47.000]  А, вот, а то мы речь, что да, в шаблон мы не можем два вариадика передать.
[14:47.000 --> 14:49.000]  Но...
[14:51.000 --> 14:53.000]  Что ты забыл?
[15:03.000 --> 15:06.000]  Сейчас, мне кажется, его просто бесит, что я вот тут некорректный код написал.
[15:06.000 --> 15:08.000]  Вот, теперь его ничего не бесит.
[15:08.000 --> 15:10.000]  Видите, это компилируется.
[15:10.000 --> 15:16.000]  Вот в том, что будет сегодня, и том, что будет в домашней грядущей,
[15:16.000 --> 15:20.000]  корректность кода, она вот проверяется на этапе компиляции полностью.
[15:21.000 --> 15:24.000]  То есть сегодня мы вообще не будем собирать коды, запускать его,
[15:24.000 --> 15:28.000]  мы будем чисто по красным подчеркиваниям понимать, что у нас где неправильно.
[15:30.000 --> 15:32.000]  А как оно скомпилировалось?
[15:45.000 --> 15:48.000]  Видите, вот так не работает.
[15:48.000 --> 15:51.000]  Говорят, template parameter pack must be less template parameter.
[15:51.000 --> 15:54.000]  То есть один и в конце.
[15:54.000 --> 15:56.000]  Нельзя.
[15:56.000 --> 15:58.000]  А вот так почему-то можно.
[15:58.000 --> 16:02.000]  Но это к вопросу, а что такое вообще явная специализация?
[16:02.000 --> 16:05.000]  Мы, по сути, делаем pattern matching.
[16:05.000 --> 16:09.000]  Мы говорим, если вот этот шаблон, шаблон тут один, да?
[16:09.000 --> 16:12.000]  Вот это все разные просто специализации одного шаблона.
[16:12.000 --> 16:17.000]  Если этот шаблон инстанцировали с типами,
[16:17.000 --> 16:20.000]  с какими-то специализациями type tuple,
[16:20.000 --> 16:25.000]  а конкретно со специализациями, у которых написан вот такой pack внутри,
[16:25.000 --> 16:28.000]  то вот использую вот такое вот тело класса
[16:28.000 --> 16:31.000]  для нашей специализации Concrete Factor Regenerator.
[16:31.000 --> 16:35.000]  И в итоге в рамках вот этого кода мы уже спокойно можем
[16:35.000 --> 16:38.000]  паки test1 или test2 распаковывать.
[16:38.000 --> 16:40.000]  Прикол, да?
[16:40.000 --> 16:43.000]  Нет, действие компилятора, он видит.
[16:43.000 --> 16:45.000]  Вот такую штуку видит.
[16:45.000 --> 16:48.000]  Давайте ее сюда подвинем.
[16:49.000 --> 16:51.000]  Сюда подвинем.
[16:51.000 --> 16:53.000]  Прекрати прыгать.
[16:55.000 --> 16:58.000]  И сюда, наверное, надо написать int float,
[16:58.000 --> 17:03.000]  а сюда bool char, чтобы у нас компилировалось.
[17:05.000 --> 17:06.000]  Ура.
[17:06.000 --> 17:08.000]  Действие компилятора.
[17:08.000 --> 17:12.000]  Он видит, что шаблон Concrete Factor Regenerator инстанцирует
[17:12.000 --> 17:15.000]  с вот такими двумя шаблонными аргументами
[17:15.000 --> 17:20.000]  и смотрит, какую явную специализацию надо использовать.
[17:20.000 --> 17:24.000]  Ну, вот это, формально говоря, тоже явная специализация,
[17:24.000 --> 17:26.000]  но она не единственная.
[17:26.000 --> 17:28.000]  Он посмотрит еще на эту.
[17:28.000 --> 17:32.000]  Ну, выбирается здесь и как с перегрузкой функции самая конкретная.
[17:32.000 --> 17:36.000]  Ну, выбирается здесь и как с перегрузкой функции самая конкретная.
[17:36.000 --> 17:38.000]  А, я кого-то following.
[17:38.000 --> 17:40.000]  Как мне stop following?
[17:40.000 --> 17:42.000]  Нет.
[17:46.000 --> 17:48.000]  Так, unfollow.
[17:49.000 --> 17:53.000]  Ну, из вот этих двух специализаций выберется самая конкретная.
[17:53.000 --> 17:57.000]  Вот это просто говорит, я принимаю любые вообще классы, мне все равно.
[17:57.000 --> 18:00.000]  А вот это говорит, я принимаю только классы,
[18:00.000 --> 18:06.000]  типы, являющиеся инстанциацией шаблона TypeTuple.
[18:06.000 --> 18:08.000]  Специализации, точнее сказать.
[18:08.000 --> 18:11.000]  Ну, мы передали специализации TypeTuple, да.
[18:11.000 --> 18:14.000]  Значит, выберется эта специализация.
[18:14.000 --> 18:17.000]  Ну, и при этом сказано, что когда вот такие типы передали,
[18:17.000 --> 18:20.000]  пусть то, что внутри этого типа TypeTuple было,
[18:20.000 --> 18:22.000]  у нас теперь хранится в таком паке,
[18:22.000 --> 18:25.000]  а то, что в этом было, хранится в таком паке.
[18:25.000 --> 18:30.000]  Вот этот int float пара попадет, ой, в этот пак тэс-1,
[18:30.000 --> 18:33.000]  а boll char попадет в пак тэс-2.
[18:33.000 --> 18:36.000]  Но мы не можем явно вызвать вот эту штуку,
[18:36.000 --> 18:39.000]  вот конкретную, нижнюю,
[18:39.000 --> 18:41.000]  чтобы он не выводился в самок,
[18:41.000 --> 18:44.000]  а явно типа, что он не знает, где же двигатель, да?
[18:44.000 --> 18:47.000]  А ты, в принципе, не можешь явные специализации сказать,
[18:47.000 --> 18:49.000]  используй вот эту.
[18:49.000 --> 18:53.000]  Ну, ты же можешь в векторе там пакать int, чтобы открыть пак.
[18:53.000 --> 18:56.000]  Ну, смотри, у тебя есть вектор bool, да?
[18:56.000 --> 18:58.000]  Можешь ли ты сказать компилятору,
[18:58.000 --> 19:01.000]  я хочу не вектор bool, которая специализация,
[19:01.000 --> 19:04.000]  а хочу обычный вектор.
[19:04.000 --> 19:07.000]  Ну, ты же знаешь, да, что вектор bool-ов, он там биты пакует.
[19:07.000 --> 19:09.000]  Можешь ли ты компилятора попросить,
[19:09.000 --> 19:12.000]  используй не вот эту явную специализацию для bool-а,
[19:12.000 --> 19:16.000]  где биты пакуют, а используй главную специализацию?
[19:16.000 --> 19:18.000]  Вообще не можешь.
[19:18.000 --> 19:21.000]  В C++ всегда автоматом определяется,
[19:21.000 --> 19:25.000]  какую из явных специализаций шаблона использовать
[19:25.000 --> 19:28.000]  при подстановке шаблонных аргументов.
[19:28.000 --> 19:32.000]  А может быть, у меня есть вот, я сделаю штуку,
[19:32.000 --> 19:35.000]  какой ошибку он мне интересный дает?
[19:35.000 --> 19:37.000]  Ошибку, вот там он красную подчеркивает,
[19:37.000 --> 19:39.000]  меня просто не подчеркивает.
[19:39.000 --> 19:42.000]  А у вас, когда вы смотрите, нету ошибок, да?
[19:42.000 --> 19:44.000]  Ну, я не вижу всех.
[19:44.000 --> 19:46.000]  Странно.
[19:46.000 --> 19:49.000]  Ну, у всех по-разному.
[19:49.000 --> 19:57.000]  Ну, что за ошибка?
[19:57.000 --> 19:59.000]  Слишком много шаблонных аргументов.
[19:59.000 --> 20:00.000]  Почему?
[20:00.000 --> 20:02.000]  Идем смотрим в этот шаблон.
[20:02.000 --> 20:04.000]  Сколько шаблонных аргументов он принимает?
[20:04.000 --> 20:06.000]  Два.
[20:06.000 --> 20:07.000]  Все.
[20:07.000 --> 20:09.000]  А ты четыре передал.
[20:14.000 --> 20:16.000]  А да.
[20:16.000 --> 20:18.000]  Type tuple, да, это шаблон,
[20:18.000 --> 20:20.000]  который принимает сколько угодно
[20:20.000 --> 20:22.000]  шаблонных параметров.
[20:22.000 --> 20:25.000]  То есть, здесь можно передать хоть десять.
[20:25.000 --> 20:29.000]  Void, void, void.
[20:29.000 --> 20:32.000]  Сейчас, как еще раз мы передаем
[20:32.000 --> 20:34.000]  два type tuple?
[20:34.000 --> 20:36.000]  Просто два класса принимаем, любых.
[20:36.000 --> 20:40.000]  А потом мы говорим, что если эти классы
[20:40.000 --> 20:44.000]  были конкретно type tuple с вот такими паками внутри,
[20:44.000 --> 20:48.000]  то кто-то что-то навставлял,
[20:48.000 --> 20:51.000]  то использовать вот этот вот код,
[20:51.000 --> 20:52.000]  который здесь написан.
[20:52.000 --> 20:54.000]  Вот это тело класса.
[20:54.000 --> 20:56.000]  Просто вот мачинг, которые там двое,
[20:56.000 --> 21:00.000]  наши, которые два, извините, точные,
[21:00.000 --> 21:01.000]  какие-то всевозможные туманы,
[21:01.000 --> 21:03.000]  как он так матчит?
[21:03.000 --> 21:05.000]  Сейчас.
[21:05.000 --> 21:09.000]  Как происходит мачинг?
[21:09.000 --> 21:11.000]  Что-то я сломал, да?
[21:11.000 --> 21:13.000]  Или кто сломал?
[21:13.000 --> 21:15.000]  Тест 1, тест, а, тест 2.
[21:15.000 --> 21:18.000]  Что можно сюда писать?
[21:18.000 --> 21:20.000]  На самом деле это произвольный
[21:20.000 --> 21:22.000]  паттерн мачинг, грубо говоря.
[21:22.000 --> 21:24.000]  Вот я только что поменял чуть-чуть код,
[21:24.000 --> 21:25.000]  и он начал ругаться.
[21:25.000 --> 21:27.000]  На что он ругается?
[21:27.000 --> 21:29.000]  Contains a template parameter
[21:29.000 --> 21:31.000]  that cannot be deduced.
[21:31.000 --> 21:33.000]  То есть, посмотри внимательно
[21:33.000 --> 21:35.000]  на этот код, все посмотрите.
[21:35.000 --> 21:37.000]  Может ли компилятор как-то понять
[21:37.000 --> 21:40.000]  из вот этого вот такого паттерна,
[21:40.000 --> 21:44.000]  что должно содержаться в паке тест 2?
[21:44.000 --> 21:46.000]  Не может никак, он здесь не упомянут.
[21:46.000 --> 21:48.000]  Поэтому это ошибка.
[21:48.000 --> 21:50.000]  А вот если он однозначно может,
[21:50.000 --> 21:52.000]  сопоставив то, что мы конкретно
[21:52.000 --> 21:54.000]  в шаблон подставили,
[21:54.000 --> 21:56.000]  с вот таким паттерном понять,
[21:56.000 --> 21:58.000]  что каждая из вот здесь написанного
[21:58.000 --> 22:00.000]  должно чем являться,
[22:00.000 --> 22:02.000]  то как бы все нормально.
[22:04.000 --> 22:06.000]  Гайды, да, гайды не про это.
[22:06.000 --> 22:08.000]  Гайды про...
[22:08.000 --> 22:10.000]  Гайды про конструкторы.
[22:10.000 --> 22:12.000]  По шаблонным аргументам конструктора
[22:12.000 --> 22:14.000]  понять шаблонные аргументы класса.
[22:14.000 --> 22:16.000]  А здесь мы вообще конструкторы
[22:16.000 --> 22:18.000]  звать не будем, пока что.
[22:18.000 --> 22:20.000]  Все в compile-time.
[22:20.000 --> 22:22.000]  А вот мы можем второй гайде
[22:22.000 --> 22:24.000]  вытащить как первый?
[22:24.000 --> 22:26.000]  Вместо tie2.ts2 просто тс2.x?
[22:28.000 --> 22:30.000]  Использовать один как...
[22:32.000 --> 22:34.000]  Да, так мы действительно можем.
[22:34.000 --> 22:36.000]  Внезапно.
[22:36.000 --> 22:38.000]  Только теперь вот так надо
[22:38.000 --> 22:40.000]  такой паттерн использовать.
[22:40.000 --> 22:42.000]  Заметили, что произошло?
[22:46.000 --> 22:48.000]  Да, да, да.
[22:48.000 --> 22:50.000]  Вот здесь теперь надо убрать type2.pl
[22:50.000 --> 22:52.000]  и просто через запятую перечислять их.
[22:56.000 --> 22:58.000]  То есть вот этот механизм
[22:58.000 --> 23:00.000]  частичных специализаций явных
[23:00.000 --> 23:02.000]  вы, наверное,
[23:02.000 --> 23:04.000]  в задачах не его использовали,
[23:04.000 --> 23:06.000]  а полные специализации, да?
[23:06.000 --> 23:08.000]  То есть у вас вот здесь ничего не было,
[23:08.000 --> 23:10.000]  а здесь вы просто конкретное значение указывали.
[23:10.000 --> 23:12.000]  Забавно второй раз type2.pl убирать.
[23:12.000 --> 23:14.000]  Мы можем уже type2.pl это доставить,
[23:14.000 --> 23:16.000]  он просто как один,
[23:16.000 --> 23:18.000]  подставится здесь.
[23:18.000 --> 23:20.000]  Да, он подставится как одно значение
[23:20.000 --> 23:22.000]  в этом паке параметров.
[23:22.000 --> 23:24.000]  Тут начинается тема с
[23:24.000 --> 23:26.000]  дактайпингом, кстати.
[23:26.000 --> 23:28.000]  Так писать я считаю плохо,
[23:28.000 --> 23:30.000]  потому что пользователю не очевидно,
[23:30.000 --> 23:32.000]  что первый, оказывается, type2.pl должен быть,
[23:32.000 --> 23:34.000]  а второй не type2.pl.
[23:34.000 --> 23:36.000]  То есть пользователь спокойно может вот так написать,
[23:36.000 --> 23:38.000]  это будет работать неправильно.
[23:38.000 --> 23:40.000]  Да?
[23:40.000 --> 23:42.000]  А почему если не писать type2.pl,
[23:42.000 --> 23:44.000]  вы могли передать ему час?
[23:44.000 --> 23:46.000]  А мы поменяли сверху,
[23:46.000 --> 23:48.000]  как шаблон выглядит.
[23:48.000 --> 23:50.000]  Мы сказали, что второй аргумент
[23:50.000 --> 23:52.000]  теперь не какой-то type2.pl должен быть,
[23:52.000 --> 23:54.000]  а просто
[23:56.000 --> 23:58.000]  просто варядик какой-то,
[23:58.000 --> 24:00.000]  пак каких-то типов.
[24:02.000 --> 24:04.000]  То есть смешивать паки
[24:04.000 --> 24:06.000]  и type2.pl я не советую, запутаетесь.
[24:08.000 --> 24:10.000]  Либо передаете все через
[24:10.000 --> 24:12.000]  тюплы, а внутри уже распаковываете,
[24:12.000 --> 24:14.000]  как с этим работаете.
[24:14.000 --> 24:16.000]  Либо все через один варядик.
[24:16.000 --> 24:18.000]  Ну, вот это такая идея,
[24:18.000 --> 24:20.000]  зачем все это может быть нужно и зачем
[24:20.000 --> 24:22.000]  используются. Как сгенерировать этот
[24:22.000 --> 24:24.000]  класс с ConcreteFactory мы пока не знаем,
[24:24.000 --> 24:26.000]  конечно же.
[24:26.000 --> 24:28.000]  Но сама, вот как сама
[24:28.000 --> 24:30.000]  цель научиться работать со
[24:30.000 --> 24:32.000]  списками типов, я думаю,
[24:32.000 --> 24:34.000]  я достаточно обосновал,
[24:34.000 --> 24:36.000]  что сейчас мы будем учиться делать
[24:36.000 --> 24:38.000]  всякие классные операции
[24:38.000 --> 24:40.000]  со списками типов.
[24:40.000 --> 24:42.000]  Но не с такими.
[24:42.000 --> 24:44.000]  Потому что вот я говорю списки типов,
[24:44.000 --> 24:46.000]  а список типов это type list, а здесь почему-то
[24:46.000 --> 24:48.000]  назвал type2.pl.
[24:50.000 --> 24:52.000]  Чего?
[24:52.000 --> 24:54.000]  Почему без методов?
[24:56.000 --> 24:58.000]  Да нет.
[24:58.000 --> 25:00.000]  Не поэтому.
[25:00.000 --> 25:02.000]  Вообще методов никаких мы не будем
[25:02.000 --> 25:04.000]  использовать. Шаблонное вот это вот
[25:04.000 --> 25:06.000]  программирование на уровне типов, оно
[25:06.000 --> 25:08.000]  всегда выглядит как функциональное
[25:08.000 --> 25:10.000]  программирование. У вас есть данные типы,
[25:10.000 --> 25:12.000]  все. Никакого ООП
[25:12.000 --> 25:14.000]  на уровне шаблонов
[25:14.000 --> 25:16.000]  на самом деле нет.
[25:18.000 --> 25:20.000]  Давайте к спискам типов.
[25:20.000 --> 25:22.000]  Придумайте мне, пожалуйста,
[25:22.000 --> 25:24.000]  еще один список,
[25:24.000 --> 25:26.000]  еще один способ
[25:26.000 --> 25:28.000]  задать список типов.
[25:28.000 --> 25:30.000]  Голова и остаток.
[25:30.000 --> 25:32.000]  Вот. Голова и остаток.
[25:32.000 --> 25:34.000]  Кто-нибудь еще понял,
[25:34.000 --> 25:36.000]  что Аркадий сказал?
[25:36.000 --> 25:38.000]  Давайте кто-нибудь попробует вот здесь написать
[25:38.000 --> 25:40.000]  что-нибудь.
[25:42.000 --> 25:44.000]  Слушай, а ты изначально
[25:44.000 --> 25:46.000]  не заклюлся? Нет.
[25:46.000 --> 25:48.000]  Все работает.
[25:48.000 --> 25:50.000]  Но падает, да?
[25:50.000 --> 25:52.000]  Нет, просто что-то вернулось.
[25:52.000 --> 25:54.000]  Странно.
[25:56.000 --> 25:58.000]  Что-то такое.
[25:58.000 --> 26:00.000]  Там ты его...
[26:00.000 --> 26:02.000]  Нет,
[26:02.000 --> 26:04.000]  нет, не с
[26:04.000 --> 26:06.000]  строиточиями.
[26:06.000 --> 26:08.000]  Все правильно было написано
[26:08.000 --> 26:10.000]  сейчас.
[26:10.000 --> 26:12.000]  Вспомните Матлог.
[26:12.000 --> 26:14.000]  Как вы из множеств делали
[26:14.000 --> 26:16.000]  списки на Матлоге?
[26:16.000 --> 26:18.000]  Ну,
[26:18.000 --> 26:20.000]  примерно.
[26:20.000 --> 26:22.000]  Ну ладно,
[26:22.000 --> 26:24.000]  это могло от Лектора отличаться.
[26:24.000 --> 26:26.000]  Идея в следующем.
[26:26.000 --> 26:28.000]  И давайте вот это вот название
[26:28.000 --> 26:30.000]  я поменяю. Я поменяю его на такое смешное
[26:30.000 --> 26:32.000]  слово cons, потому что в функциональном
[26:32.000 --> 26:34.000]  программировании это так принято называть.
[26:38.000 --> 26:40.000]  Потому что одно вообще-то.
[26:40.000 --> 26:42.000]  А, ты на fsharp'е пишешь?
[26:42.000 --> 26:44.000]  Нет, я на скале пишу.
[26:44.000 --> 26:46.000]  Нет, одно должно быть.
[26:46.000 --> 26:48.000]  Ну, cons будет.
[26:48.000 --> 26:50.000]  Какая идея? Мы будем задавать список типов
[26:50.000 --> 26:52.000]  вот так.
[26:52.000 --> 26:54.000]  Да,
[26:54.000 --> 26:56.000]  это главная проблема этого слова.
[26:56.000 --> 26:58.000]  Надо отучить свою память
[26:58.000 --> 27:00.000]  пальцами букву T вставлять.
[27:04.000 --> 27:06.000]  Ну, как-то так мы будем это делать.
[27:08.000 --> 27:10.000]  Но тут начинается какая-то неприятность.
[27:12.000 --> 27:14.000]  Сможем порезаться
[27:16.000 --> 27:18.000]  будем резаться.
[27:22.000 --> 27:24.000]  Ну,
[27:24.000 --> 27:26.000]  смотри,
[27:26.000 --> 27:28.000]  фундаментально, если ты используешь
[27:28.000 --> 27:30.000]  врядики, то тебе не нужны
[27:30.000 --> 27:32.000]  никакие вот такие приколы.
[27:32.000 --> 27:34.000]  Врядики уже сами по себе
[27:34.000 --> 27:36.000]  полноценные списки типов, и с ними можно
[27:36.000 --> 27:38.000]  работать как угодно, можно голову отщеплять,
[27:38.000 --> 27:40.000]  можно там еще что-то делать классное.
[27:40.000 --> 27:42.000]  Это отдельная тема.
[27:42.000 --> 27:44.000]  И она достаточно простая, на самом деле.
[27:44.000 --> 27:46.000]  Я предлагаю вам
[27:46.000 --> 27:48.000]  самим потренироваться, если вы хотите
[27:48.000 --> 27:50.000]  с тем, что я буду type теплами называть,
[27:50.000 --> 27:52.000]  работать. Ну, то есть в дамашке тоже немножко
[27:52.000 --> 27:54.000]  будет про type теплы, но совсем чуть-чуть.
[27:54.000 --> 27:56.000]  Но вот с этими type теплами можно, очевидно,
[27:56.000 --> 27:58.000]  операции всякие делать.
[27:58.000 --> 28:00.000]  Можно отрезать голову от вот этого вот
[28:00.000 --> 28:02.000]  type тепла, где голова это первый элемент,
[28:02.000 --> 28:04.000]  вот этот инт,
[28:04.000 --> 28:06.000]  а все остальное, остаток
[28:06.000 --> 28:08.000]  это хвост. То есть можно сделать операцию
[28:08.000 --> 28:10.000]  отрезания головы.
[28:10.000 --> 28:12.000]  Можно сделать операцию получения по индексу
[28:12.000 --> 28:14.000]  типа в этом списке.
[28:14.000 --> 28:16.000]  Очень сильно зависит
[28:16.000 --> 28:18.000]  от того, как вы это сделаете.
[28:18.000 --> 28:20.000]  Перформанс в компайлтайме
[28:20.000 --> 28:22.000]  это отдельная тема.
[28:30.000 --> 28:32.000]  Можно,
[28:32.000 --> 28:34.000]  но это делается
[28:34.000 --> 28:36.000]  built-in magic функциями,
[28:36.000 --> 28:38.000]  которые, впрочем,
[28:38.000 --> 28:40.000]  не могут быть
[28:40.000 --> 28:42.000]  в компайле.
[28:42.000 --> 28:44.000]  Но которые, впрочем,
[28:44.000 --> 28:46.000]  ну, короче, есть
[28:46.000 --> 28:48.000]  tuple get такая фигня в стандартной
[28:48.000 --> 28:50.000]  библиотеке, типа std get
[28:50.000 --> 28:52.000]  там ноль от тепла.
[28:52.000 --> 28:54.000]  Вот она внутри
[28:54.000 --> 28:56.000]  конечно же никакими шаблонами
[28:56.000 --> 28:58.000]  не реализована, она реализована просто
[28:58.000 --> 29:00.000]  через встроенную в компилятор волшебную функцию,
[29:00.000 --> 29:02.000]  которая волшебством достает
[29:02.000 --> 29:04.000]  нужный элемент. Но если вы сделаете
[29:04.000 --> 29:06.000]  вот так и реализуете
[29:06.000 --> 29:08.000]  протокол тепла для вашего type тепла,
[29:08.000 --> 29:10.000]  то там все будет работать за вот единицы
[29:10.000 --> 29:12.000]  и можно вот так делать.
[29:12.000 --> 29:14.000]  Но мне интересно не это.
[29:14.000 --> 29:16.000]  Мне интересно...
[29:28.000 --> 29:30.000]  Окей, ладно, тогда надо использовать
[29:30.000 --> 29:32.000]  не свой шаблон type tuple, а std.
[29:32.000 --> 29:34.000]  tuple и вот там уже интринзики работают.
[29:34.000 --> 29:36.000]  Все.
[29:36.000 --> 29:38.000]  Ну, короче, можно сделать это быстро,
[29:38.000 --> 29:40.000]  но медленно.
[29:40.000 --> 29:42.000]  Можно так. Способ, конечно,
[29:42.000 --> 29:44.000]  миллион.
[29:44.000 --> 29:46.000]  Попробовать все мы
[29:46.000 --> 29:48.000]  тупо не успеем, не на семинарах,
[29:48.000 --> 29:50.000]  не в домашках.
[29:52.000 --> 29:54.000]  Вот.
[29:54.000 --> 29:56.000]  Вот, к этому
[29:56.000 --> 29:58.000]  и вопрос, что
[29:58.000 --> 30:00.000]  первым делом, когда вот этот
[30:00.000 --> 30:02.000]  конс видят, ну, в чем идея
[30:02.000 --> 30:04.000]  его? Мы храним в первом
[30:04.000 --> 30:06.000]  шаблонном аргументе голову,
[30:06.000 --> 30:08.000]  то есть первый элемент списка,
[30:08.000 --> 30:10.000]  а во втором шаблонном аргументе
[30:10.000 --> 30:12.000]  храним остальной список.
[30:12.000 --> 30:14.000]  Но остальной список это другой конс.
[30:14.000 --> 30:16.000]  Ой.
[30:16.000 --> 30:18.000]  Ну, очень быстро
[30:18.000 --> 30:20.000]  замечаешь, что если только так
[30:20.000 --> 30:22.000]  действовать, то вот здесь какая-то фигня
[30:22.000 --> 30:24.000]  оказывается. Понятно ли вам,
[30:24.000 --> 30:26.000]  что вот так будет дико неудобно со всем этим работать?
[30:26.000 --> 30:28.000]  Что
[30:28.000 --> 30:30.000]  последний элемент как бы может быть
[30:30.000 --> 30:32.000]  ну, второй шаблонный аргумент
[30:32.000 --> 30:34.000]  у конса может быть другим консом, а может
[30:34.000 --> 30:36.000]  быть конкретным типом.
[30:36.000 --> 30:38.000]  И уже не понятно,
[30:38.000 --> 30:40.000]  как это отличать от, скажем,
[30:40.000 --> 30:42.000]  от списка списков.
[30:42.000 --> 30:44.000]  То есть двумерный массив
[30:44.000 --> 30:46.000]  типов мы тоже, наверное, хотим уметь делать.
[30:46.000 --> 30:48.000]  Начинается куча проблем. От этого
[30:48.000 --> 30:50.000]  берется здесь элемент нил.
[30:50.000 --> 30:52.000]  Соответственно,
[30:52.000 --> 30:54.000]  если все это подытожить,
[30:54.000 --> 30:56.000]  что мы говорим? Что мы вводим
[30:56.000 --> 30:58.000]  такой, грубо говоря, концепт
[31:00.000 --> 31:02.000]  список типов.
[31:04.000 --> 31:06.000]  Список типов
[31:06.000 --> 31:08.000]  это либо
[31:12.000 --> 31:14.000]  нил
[31:14.000 --> 31:16.000]  это значит пустой список.
[31:16.000 --> 31:18.000]  Либо
[31:26.000 --> 31:28.000]  либо
[31:28.000 --> 31:30.000]  это какая-то инстанциация
[31:30.000 --> 31:32.000]  конса.
[31:32.000 --> 31:34.000]  Теперь вопрос.
[31:34.000 --> 31:36.000]  Я здесь хочу написать что?
[31:36.000 --> 31:38.000]  Что, мол,
[31:38.000 --> 31:40.000]  тт
[31:40.000 --> 31:42.000]  давайте так.
[31:44.000 --> 31:46.000]  Опять говорю неправильное слово.
[31:46.000 --> 31:48.000]  Какая-то специализация
[31:48.000 --> 31:50.000]  конс.
[31:54.000 --> 31:56.000]  Вот, да. Умейте ли вы
[31:56.000 --> 31:58.000]  определять,
[31:58.000 --> 32:00.000]  является ли структура специализации
[32:00.000 --> 32:02.000]  какого-то
[32:02.000 --> 32:04.000]  шаблона
[32:04.000 --> 32:06.000]  в принципе как угодно?
[32:06.000 --> 32:08.000]  Как-то да.
[32:08.000 --> 32:10.000]  Мы это написали уже, по сути.
[32:10.000 --> 32:12.000]  Вот через это
[32:12.000 --> 32:14.000]  как раз можно.
[32:14.000 --> 32:16.000]  Тут можно просто в паблике написать using type
[32:16.000 --> 32:18.000]  иначе using value true.
[32:18.000 --> 32:20.000]  Можно еще вот так.
[32:20.000 --> 32:22.000]  False type.
[32:22.000 --> 32:24.000]  Вот здесь там
[32:24.000 --> 32:26.000]  true type.
[32:26.000 --> 32:28.000]  И примерно мы поняли,
[32:28.000 --> 32:30.000]  как проверять, является ли там что-то.
[32:30.000 --> 32:32.000]  Конечно,
[32:32.000 --> 32:34.000]  оно должно быть, да.
[32:34.000 --> 32:36.000]  Идея понятна.
[32:36.000 --> 32:38.000]  Надеюсь, вы такое просто уже писали,
[32:38.000 --> 32:40.000]  когда-то игрались с этим.
[32:40.000 --> 32:42.000]  А сейчас я вам покажу более
[32:42.000 --> 32:44.000]  смешной юморной способ,
[32:44.000 --> 32:46.000]  до которого допереть
[32:46.000 --> 32:48.000]  самому, наверное, достаточно сложно.
[32:48.000 --> 32:50.000]  То есть я его не сам, конечно же, придумал,
[32:50.000 --> 32:52.000]  а высмотрел.
[32:52.000 --> 32:54.000]  Сейчас
[32:54.000 --> 32:56.000]  бы воспроизвести
[32:56.000 --> 32:58.000]  и ничего не перепутать.
[32:58.000 --> 33:00.000]  Requires у нас будет
[33:00.000 --> 33:02.000]  такой.
[33:04.000 --> 33:06.000]  Да.
[33:10.000 --> 33:12.000]  Вот так.
[33:12.000 --> 33:14.000]  Вот так.
[33:14.000 --> 33:16.000]  Вот так.
[33:16.000 --> 33:18.000]  Вот так.
[33:24.000 --> 33:26.000]  И вот так.
[33:26.000 --> 33:28.000]  Как вам?
[33:28.000 --> 33:30.000]  Понимаете, что
[33:30.000 --> 33:32.000]  написано?
[33:32.000 --> 33:34.000]  В смысле, все, красно мне...
[33:34.000 --> 33:36.000]  Ну,
[33:36.000 --> 33:38.000]  это шаблонная лямбда,
[33:38.000 --> 33:40.000]  и она снимает
[33:40.000 --> 33:42.000]  на одну.
[33:42.000 --> 33:44.000]  Ну, она
[33:44.000 --> 33:46.000]  паттерн.
[33:46.000 --> 33:48.000]  У нее паттерн в аргументе
[33:48.000 --> 33:50.000]  консов A и B.
[33:50.000 --> 33:52.000]  Поэтому
[33:52.000 --> 33:54.000]  она либо дидюсит A
[33:54.000 --> 33:56.000]  и B, если
[33:56.000 --> 33:58.000]  ТТ это конс,
[33:58.000 --> 34:00.000]  либо дается
[34:00.000 --> 34:02.000]  E, что
[34:02.000 --> 34:04.000]  ТТ не конс.
[34:04.000 --> 34:06.000]  Поняли объяснение?
[34:06.000 --> 34:08.000]  Так, а может, B
[34:08.000 --> 34:10.000]  тоже тайп-лист, нет?
[34:10.000 --> 34:12.000]  Нет, B может быть
[34:12.000 --> 34:14.000]  либо тайп-лист, либо нил.
[34:14.000 --> 34:16.000]  Нет, нет.
[34:16.000 --> 34:18.000]  B может быть либо конс, либо нил.
[34:18.000 --> 34:20.000]  Но это абсолютная правда,
[34:20.000 --> 34:22.000]  что B должно быть тайп-листом.
[34:22.000 --> 34:24.000]  Но так мы не умеем
[34:24.000 --> 34:26.000]  языке C++.
[34:26.000 --> 34:28.000]  Ну, то есть, можно
[34:28.000 --> 34:30.000]  из хичлицы написать
[34:30.000 --> 34:32.000]  штуку, которая при проверке этого концепта
[34:32.000 --> 34:34.000]  будет рекурсивно спускаться
[34:34.000 --> 34:36.000]  по всем консам и проверять, что они
[34:36.000 --> 34:38.000]  везде корректные.
[34:42.000 --> 34:44.000]  Да, да.
[34:44.000 --> 34:46.000]  Нет, что? Стоп.
[34:46.000 --> 34:48.000]  B должно быть
[34:48.000 --> 34:50.000]  либо конс, либо нил.
[34:50.000 --> 34:52.000]  То есть, можно написать
[34:52.000 --> 34:54.000]  хитрую процедуру
[34:54.000 --> 34:56.000]  в Compel Time, которая будет спускаться по этим
[34:56.000 --> 34:58.000]  типам. Метапрограммирование
[34:58.000 --> 35:00.000]  там все волшебство
[35:00.000 --> 35:02.000]  сделает и проверит, что везде конс
[35:02.000 --> 35:04.000]  и нилы.
[35:06.000 --> 35:08.000]  Наверное, у этого есть причина,
[35:08.000 --> 35:10.000]  почему так не делается.
[35:10.000 --> 35:12.000]  Просто причина, наверное,
[35:12.000 --> 35:14.000]  в том, что
[35:14.000 --> 35:16.000]  а что
[35:16.000 --> 35:18.000]  есть список бесконечных?
[35:20.000 --> 35:22.000]  Ну, это раз.
[35:22.000 --> 35:24.000]  А два,
[35:24.000 --> 35:26.000]  что если рекурсию у вас
[35:26.000 --> 35:28.000]  в общем случае не завершится.
[35:28.000 --> 35:30.000]  То есть, не хочется
[35:30.000 --> 35:32.000]  иметь при проверке концептов
[35:32.000 --> 35:34.000]  произвольную рекурсию.
[35:34.000 --> 35:36.000]  Наверное, поэтому...
[35:38.000 --> 35:40.000]  Окраничение на рекурсию есть.
[35:40.000 --> 35:42.000]  В общем, мораль.
[35:42.000 --> 35:44.000]  Можно здесь из хищрица все это
[35:44.000 --> 35:46.000]  вынести в отдельный шаблон класса,
[35:46.000 --> 35:48.000]  и там рекурсивно идти
[35:48.000 --> 35:50.000]  и проверять, что все нормально.
[35:50.000 --> 35:52.000]  Я предлагаю так не делать.
[35:52.000 --> 35:54.000]  Просто остановиться на этом. Мы проверили
[35:54.000 --> 35:56.000]  верхний уровень, он конс, нил,
[35:56.000 --> 35:58.000]  а дальше мы просто
[35:58.000 --> 36:00.000]  на самом деле будем работать с вот этими списками,
[36:00.000 --> 36:02.000]  в какой-то момент до какого-то
[36:02.000 --> 36:04.000]  места их развернем и все равно
[36:04.000 --> 36:06.000]  проверим, что там все нормально.
[36:08.000 --> 36:10.000]  Да?
[36:10.000 --> 36:12.000]  Зачем вы конс подумали? Я забыл.
[36:12.000 --> 36:14.000]  Конс? Ну, на самом деле
[36:14.000 --> 36:16.000]  не зачем. Это все развлекуха.
[36:16.000 --> 36:18.000]  То есть, в современном C++
[36:18.000 --> 36:20.000]  просто берите, используйте
[36:20.000 --> 36:22.000]  врядики, у вас все будет хорошо.
[36:22.000 --> 36:24.000]  Но когда-то их не было, до 11-х плюсов.
[36:24.000 --> 36:26.000]  И до них тоже как-то
[36:26.000 --> 36:28.000]  хотелось со списками типов работать.
[36:28.000 --> 36:30.000]  А как ты описываешь,
[36:30.000 --> 36:32.000]  что да?
[36:32.000 --> 36:34.000]  Просто проверять концепты никто
[36:34.000 --> 36:36.000]  не просит. Не проверяю
[36:36.000 --> 36:38.000]  все. Концепты нам
[36:38.000 --> 36:40.000]  нужны только для удобства.
[36:44.000 --> 36:46.000]  Да, то, что здесь что-то проходит,
[36:46.000 --> 36:48.000]  это, конечно, грустно, но
[36:48.000 --> 36:50.000]  давайте не будем перегружать компилятор
[36:50.000 --> 36:52.000]  с лишними проверками,
[36:52.000 --> 36:54.000]  потому что если мы на каждой инстанциации шаблон
[36:54.000 --> 36:56.000]  работающего со списком типов будем
[36:56.000 --> 36:58.000]  проходить весь список типов и проверять, что он весь
[36:58.000 --> 37:00.000]  корректный, будет немножко
[37:00.000 --> 37:02.000]  больно.
[37:02.000 --> 37:04.000]  Да, зачем все это нужно?
[37:04.000 --> 37:06.000]  Это все придумал Александр Эску в книжке своей,
[37:06.000 --> 37:08.000]  которую я там не один раз уже о ней упоминал.
[37:08.000 --> 37:10.000]  И придумал ровно для
[37:10.000 --> 37:12.000]  вот этого вот
[37:12.000 --> 37:14.000]  всего. Он хотел генерировать
[37:14.000 --> 37:16.000]  вот такие вот сложные шаблоны.
[37:16.000 --> 37:18.000]  Для этого нужны были списки типов.
[37:18.000 --> 37:20.000]  Врядиков
[37:20.000 --> 37:22.000]  не было. Он
[37:22.000 --> 37:24.000]  хорошо учил матлог в УЗе
[37:24.000 --> 37:26.000]  и просто реализовал
[37:26.000 --> 37:28.000]  такой матложный список или
[37:28.000 --> 37:30.000]  функпрожный список.
[37:30.000 --> 37:32.000]  Ну, подозреваю, что это не
[37:32.000 --> 37:34.000]  функциональные программисты придумали, а все-таки
[37:34.000 --> 37:36.000]  логики в какой-то момент.
[37:36.000 --> 37:38.000]  Во времена тюринга, например.
[37:38.000 --> 37:40.000]  Вот просто вот так делать.
[37:40.000 --> 37:42.000]  Да, во всяких
[37:42.000 --> 37:44.000]  языках вроде Хаскеля ровно так
[37:44.000 --> 37:46.000]  и задается всегда любые списки.
[37:48.000 --> 37:50.000]  Некоторое преимущество у такого подхода
[37:50.000 --> 37:52.000]  есть.
[37:52.000 --> 37:54.000]  Но вы его увидите в домашке.
[37:54.000 --> 37:56.000]  Кто уже себе все проспылирил,
[37:56.000 --> 37:58.000]  тот сам себе злобный Буратино.
[37:58.000 --> 38:00.000]  Еще про Хаскель пару слов скажу.
[38:00.000 --> 38:02.000]  Перед тем, как мы
[38:02.000 --> 38:04.000]  перейдем к тому, чтобы писать разные
[38:04.000 --> 38:06.000]  операции работы над вот такими списками типов.
[38:10.000 --> 38:12.000]  Тяжело
[38:12.000 --> 38:14.000]  форматировать код.
[38:14.000 --> 38:16.000]  Или что-то хотел сказать?
[38:16.000 --> 38:18.000]  Нет, я хотел сказать, что
[38:18.000 --> 38:20.000]  тяжело код удалять.
[38:20.000 --> 38:22.000]  Что значит удалять?
[38:24.000 --> 38:26.000]  Последний элемент? Откусить?
[38:26.000 --> 38:28.000]  Ну да, тяжело.
[38:28.000 --> 38:30.000]  Что поделать?
[38:30.000 --> 38:32.000]  Поэтому я говорю, что вот это лист такой.
[38:32.000 --> 38:34.000]  Он как бы форвард-лист на самом деле,
[38:34.000 --> 38:36.000]  но сейчас больше такая терминология
[38:36.000 --> 38:38.000]  функпрожная идет.
[38:38.000 --> 38:40.000]  Там это листами просто называют.
[38:44.000 --> 38:46.000]  Поэтому вот это тюпл.
[38:46.000 --> 38:48.000]  Потому что в тюпле на самом деле рандом аксесс есть, если очень постараться.
[38:48.000 --> 38:50.000]  Завод единицы по индексу
[38:50.000 --> 38:52.000]  вообще никак здесь не получится.
[38:52.000 --> 38:54.000]  Да, завод единицы по индексу
[38:54.000 --> 38:56.000]  вообще никак здесь не получится.
[38:56.000 --> 38:58.000]  Я не верю, что в тюпле есть
[38:58.000 --> 39:00.000]  аксесс, если не иметь
[39:00.000 --> 39:02.000]  в игре имплементацию следовательного.
[39:02.000 --> 39:04.000]  Ну если не иметь, то наверное нет.
[39:04.000 --> 39:06.000]  Почти, наверное. Не уверен.
[39:06.000 --> 39:08.000]  Наверное, все-таки какие-то хитрые способы есть.
[39:08.000 --> 39:10.000]  Я не помню.
[39:10.000 --> 39:12.000]  Но каждый год придумываю
[39:12.000 --> 39:14.000]  новые хитрые способы извращаться в языке
[39:14.000 --> 39:16.000]  C++. Я не удивлюсь, если что-то
[39:16.000 --> 39:18.000]  вы уже придумали.
[39:18.000 --> 39:20.000]  Или я просто не нашел.
[39:20.000 --> 39:22.000]  Но если кто-то найдет, обязательно нам расскажите.
[39:22.000 --> 39:24.000]  А мы про именно листы будем.
[39:24.000 --> 39:26.000]  Так вот, что я хотел сказать. Про форматирование.
[39:26.000 --> 39:28.000]  Сейчас у вас будут трехэтажные шаблоны.
[39:28.000 --> 39:30.000]  Вот такие.
[39:30.000 --> 39:32.000]  Уже был комментарий, что
[39:32.000 --> 39:34.000]  как от треугольной скобки не обколоться.
[39:34.000 --> 39:36.000]  Очень просто.
[39:36.000 --> 39:38.000]  Новый код стайл.
[39:38.000 --> 39:40.000]  Для вас новый. Почему у нас 4 пробела?
[39:40.000 --> 39:42.000]  Что это такое?
[39:42.000 --> 39:44.000]  Должно быть 2.
[39:46.000 --> 39:48.000]  А клан формат?
[39:48.000 --> 39:50.000]  Нет.
[39:50.000 --> 39:52.000]  Я не буду запускать клан формат сегодня.
[39:52.000 --> 39:54.000]  Сейчас увидишь, почему.
[39:54.000 --> 39:56.000]  А где кнопочка...
[39:58.000 --> 40:00.000]  Еще надо.
[40:00.000 --> 40:02.000]  Еще, да?
[40:04.000 --> 40:06.000]  О, вот теперь видно.
[40:06.000 --> 40:08.000]  4.
[40:08.000 --> 40:10.000]  Детект.
[40:12.000 --> 40:14.000]  Вернули обратно.
[40:14.000 --> 40:16.000]  Вот так кажется было, да?
[40:16.000 --> 40:18.000]  Нормально видно?
[40:18.000 --> 40:20.000]  Код стайл.
[40:20.000 --> 40:22.000]  Новый для вас. Очень смешной.
[40:22.000 --> 40:24.000]  Кому-то сейчас понравится, кто-то будет плеваться.
[40:28.000 --> 40:30.000]  Теперь это лесенка, да?
[40:36.000 --> 40:38.000]  В смысле?
[40:38.000 --> 40:40.000]  Это невероятно удобно, если вы занимаетесь
[40:40.000 --> 40:42.000]  функциональным программированием.
[40:44.000 --> 40:46.000]  Любые списки чего угодно
[40:46.000 --> 40:48.000]  работают так.
[40:48.000 --> 40:50.000]  Какое-то название или
[40:50.000 --> 40:52.000]  префикс на первой строчке.
[40:52.000 --> 40:54.000]  На следующей строчке открывающая скобка.
[40:54.000 --> 40:56.000]  И после нее через пробел
[40:56.000 --> 40:58.000]  элемент списка.
[40:58.000 --> 41:00.000]  Потом запятая через пробел элемент списка.
[41:00.000 --> 41:02.000]  Ну и так далее.
[41:02.000 --> 41:04.000]  Да.
[41:04.000 --> 41:06.000]  Это принципиально, что она переносится.
[41:06.000 --> 41:08.000]  Потому что, да, оно у тебя так выровнено
[41:08.000 --> 41:10.000]  будет.
[41:10.000 --> 41:12.000]  Эта колонка,
[41:12.000 --> 41:14.000]  вся пунктуация.
[41:14.000 --> 41:16.000]  Более того, это мега удобно
[41:16.000 --> 41:18.000]  в плане копирования.
[41:18.000 --> 41:20.000]  Если там просто какой-нибудь
[41:26.000 --> 41:28.000]  вот такую какую-нибудь фигню сделать.
[41:32.000 --> 41:34.000]  Вот так делать, да?
[41:34.000 --> 41:36.000]  Вы предлагаете?
[41:36.000 --> 41:38.000]  Ну я решил,
[41:38.000 --> 41:40.000]  что мне два була на самом деле
[41:40.000 --> 41:42.000]  в этом списке нужно в конце.
[41:42.000 --> 41:44.000]  Откопировал, у меня не компилируется.
[41:44.000 --> 41:46.000]  Нужно вернуться обратно,
[41:46.000 --> 41:48.000]  поставить запятую.
[41:48.000 --> 41:50.000]  Нет, неудобно.
[41:50.000 --> 41:52.000]  Я делаю вот так.
[41:52.000 --> 41:54.000]  Теперь могу спокойно копировать
[41:54.000 --> 41:56.000]  хоть последний элемент.
[41:56.000 --> 41:58.000]  Ладно, любой кроме первого.
[42:00.000 --> 42:02.000]  Кто строчки переносит?
[42:02.000 --> 42:04.000]  Или это я сам тройной клип?
[42:04.000 --> 42:06.000]  Наверное, это я сам.
[42:06.000 --> 42:08.000]  Ну, короче, такой стиль есть.
[42:08.000 --> 42:10.000]  Он в Haskellе широко используется.
[42:10.000 --> 42:12.000]  Сегодня я его буду тоже использовать.
[42:12.000 --> 42:14.000]  Мне кажется, это удобнее,
[42:14.000 --> 42:16.000]  когда мы пишем функциональный код.
[42:16.000 --> 42:18.000]  Так, на этом
[42:18.000 --> 42:20.000]  такая вводная часть
[42:20.000 --> 42:22.000]  закончена.
[42:22.000 --> 42:24.000]  Давайте удалим
[42:24.000 --> 42:26.000]  все, что происходит.
[42:26.000 --> 42:28.000]  Все лишнее.
[42:28.000 --> 42:30.000]  А лишнее здесь...
[42:30.000 --> 42:32.000]  Все.
[42:32.000 --> 42:34.000]  О, тут кто-то
[42:34.000 --> 42:36.000]  играется с какими-то матчами.
[42:36.000 --> 42:38.000]  Кто-то писал
[42:38.000 --> 42:40.000]  и прокомментируйте.
[42:40.000 --> 42:42.000]  Что ты хотел сказать этим?
[42:42.000 --> 42:44.000]  Я не хотел ничего сказать.
[42:44.000 --> 42:46.000]  Ну ладно.
[42:46.000 --> 42:48.000]  Я удалю это?
[42:48.000 --> 42:50.000]  Окей, вот это удалим.
[42:52.000 --> 42:54.000]  Вот это, наверное, все оставим.
[42:54.000 --> 42:56.000]  Это, наверное,
[42:56.000 --> 42:58.000]  в репозиторий попадет,
[42:58.000 --> 43:00.000]  а может, не попадет.
[43:00.000 --> 43:02.000]  Я не решил, хочу ли это все заливать.
[43:02.000 --> 43:04.000]  Окей, мы идем в соседний файл.
[43:08.000 --> 43:10.000]  Здесь есть какая-то кнопочка,
[43:10.000 --> 43:12.000]  чтобы у вас всех пресумонить.
[43:16.000 --> 43:18.000]  Нету, да?
[43:20.000 --> 43:22.000]  У меня должна быть кнопочка,
[43:22.000 --> 43:24.000]  чтобы всех пресумонить в конкретное место.
[43:30.000 --> 43:32.000]  Ну ладно, не получилось.
[43:40.000 --> 43:42.000]  О, я вас всех
[43:42.000 --> 43:44.000]  сфокусировал на мне. Прекрасно.
[43:44.000 --> 43:46.000]  Можете отфокусироваться.
[43:46.000 --> 43:48.000]  Главное, чтобы вы попали в нужный файл.
[43:50.000 --> 43:52.000]  Смешной файл.
[43:52.000 --> 43:54.000]  Здесь есть куча заглушек
[43:54.000 --> 43:56.000]  разных и смешных операций.
[43:56.000 --> 43:58.000]  Давайте по ним пробежимся.
[43:58.000 --> 44:00.000]  И везде, где вы видите туду,
[44:00.000 --> 44:02.000]  нужно что-то вписать.
[44:02.000 --> 44:04.000]  Поэтому, если вас эта операция
[44:04.000 --> 44:06.000]  заинтересовала, вы стирайте туду
[44:06.000 --> 44:08.000]  и начинайте пыхтеть.
[44:12.000 --> 44:14.000]  Не гадлистите, пожалуйста.
[44:14.000 --> 44:16.000]  Мы здесь собрались что-то хорошее накодить.
[44:16.000 --> 44:18.000]  Ну, первая операция.
[44:20.000 --> 44:22.000]  Делаем список типов из параметра pack.
[44:24.000 --> 44:26.000]  Она нам нужна, чтобы поудобнее списки типов
[44:26.000 --> 44:28.000]  создавать, потому что вот так
[44:28.000 --> 44:30.000]  ручками писать cons, cons, cons, nil
[44:30.000 --> 44:32.000]  мы не хотим.
[44:32.000 --> 44:34.000]  Но поиграться с ними хотим.
[44:34.000 --> 44:36.000]  Поэтому нужно уметь паки конвертировать
[44:36.000 --> 44:38.000]  в cons, cons, cons, cons
[44:38.000 --> 44:40.000]  и nil в конце.
[44:42.000 --> 44:44.000]  Предупреждение заранее. Не засоряйте
[44:44.000 --> 44:46.000]  глобальный namespace, пожалуйста.
[44:46.000 --> 44:48.000]  Если вы вспомогательные какие-то шаблоны будете делать,
[44:48.000 --> 44:50.000]  namespace detail
[44:50.000 --> 44:52.000]  и в него все.
[44:52.000 --> 44:54.000]  Append. Ну, понятно, что Append делает.
[44:54.000 --> 44:56.000]  Дописывает в конец новый тип.
[44:58.000 --> 45:00.000]  И тут, конечно же, тесты уже
[45:00.000 --> 45:02.000]  накиданы с какого-то
[45:02.000 --> 45:04.000]  прошлого года. Если вам их не хватает, вы можете
[45:04.000 --> 45:06.000]  еще их накидать.
[45:06.000 --> 45:08.000]  Ну и то, о чем я говорил.
[45:08.000 --> 45:10.000]  Решили вы
[45:10.000 --> 45:12.000]  под задачу, как только вот эта вот
[45:12.000 --> 45:14.000]  красная строчка пропала.
[45:16.000 --> 45:18.000]  Так, Append, Append.
[45:18.000 --> 45:20.000]  Конкатонация.
[45:20.000 --> 45:22.000]  Ну, тоже понятно,
[45:22.000 --> 45:24.000]  что такое, да?
[45:24.000 --> 45:26.000]  Ничего магического.
[45:26.000 --> 45:28.000]  Headtail. Взять первые элементы,
[45:28.000 --> 45:30.000]  взять все кроме первого.
[45:32.000 --> 45:34.000]  Найти длину.
[45:36.000 --> 45:38.000]  Почему плюс? А, наверное,
[45:38.000 --> 45:40.000]  в прошлом году ставили плюс и там, где занято.
[45:40.000 --> 45:42.000]  Пока не занято.
[45:44.000 --> 45:46.000]  Думаю, тоже вопросов нет.
[45:46.000 --> 45:48.000]  Reverse. Ну и разреверсить.
[45:48.000 --> 45:50.000]  Вот map более интересная.
[45:50.000 --> 45:52.000]  Вот вы знаете про операцию Map.
[45:52.000 --> 45:54.000]  Да.
[45:54.000 --> 45:56.000]  MapReduce.
[45:56.000 --> 45:58.000]  Такое модное.
[45:58.000 --> 46:00.000]  Это все из FuncProgi пошло.
[46:00.000 --> 46:02.000]  И MapReduce.
[46:02.000 --> 46:04.000]  И, заметите, что мы используем в качестве функции.
[46:06.000 --> 46:08.000]  Другой шаблон.
[46:08.000 --> 46:10.000]  Это метафункция.
[46:10.000 --> 46:12.000]  Она на вход принимает какой-то класс.
[46:14.000 --> 46:16.000]  А, ну я не понял,
[46:16.000 --> 46:18.000]  что ты там писал. На выход дают
[46:18.000 --> 46:20.000]  другой класс. Нужно пройтись
[46:20.000 --> 46:22.000]  по всему списку типов и каждый тип
[46:22.000 --> 46:24.000]  в нем заменить на f
[46:24.000 --> 46:26.000]  от этого типа.
[46:30.000 --> 46:32.000]  Ну и тут есть тест
[46:32.000 --> 46:34.000]  с функцией, метафункцией AddStar.
[46:34.000 --> 46:36.000]  Что, мол,
[46:36.000 --> 46:38.000]  int void bool добавить звездочку
[46:38.000 --> 46:40.000]  должна быть int звездочку, void звездочку, bool звездочка.
[46:44.000 --> 46:46.000]  Сколько там еще?
[46:48.000 --> 46:50.000]  Interspers. Вот это кажется одной из самых сложных.
[46:50.000 --> 46:52.000]  Если кто-то прям хочет вот запотеть,
[46:52.000 --> 46:54.000]  возьмите эту штуку.
[46:56.000 --> 46:58.000]  Что она делала?
[46:58.000 --> 47:00.000]  А, между каждыми элементами
[47:00.000 --> 47:02.000]  вставляет новый.
[47:02.000 --> 47:04.000]  Ну по тестам можно понять, на самом деле, что происходит.
[47:04.000 --> 47:06.000]  boolpack int void bool
[47:06.000 --> 47:08.000]  решили интерсперс на char.
[47:08.000 --> 47:10.000]  Получилось int char,
[47:10.000 --> 47:12.000]  void char, bool char.
[47:12.000 --> 47:14.000]  Нет, в конце char нет.
[47:14.000 --> 47:16.000]  Ну короче, как в питоне
[47:16.000 --> 47:18.000]  Interspers, знаете?
[47:18.000 --> 47:20.000]  Там можно список
[47:20.000 --> 47:22.000]  строк сделать ему что-то типа
[47:22.000 --> 47:24.000]  Interspers и потом join.
[47:24.000 --> 47:26.000]  И вот вы делаете список строк
[47:26.000 --> 47:28.000]  Interspers запятая
[47:28.000 --> 47:30.000]  и потом join. И у вас получается
[47:30.000 --> 47:32.000]  список с запятыми строка.
[47:34.000 --> 47:36.000]  Ну вот такая логика тут.
[47:36.000 --> 47:38.000]  Какие у нас ограничения для реализации?
[47:38.000 --> 47:40.000]  Важно ли
[47:40.000 --> 47:42.000]  type-to-plu, type-to-plu?
[47:42.000 --> 47:44.000]  Я хочу, чтобы вы
[47:44.000 --> 47:46.000]  не уходили к type-to-plu.
[47:56.000 --> 47:58.000]  Ну то есть как бы реализация
[47:58.000 --> 48:00.000]  должна быть в духе вот этих списков типов.
[48:00.000 --> 48:02.000]  Везде надо ходить рекурсивно.
[48:02.000 --> 48:04.000]  Первые элементы.
[48:04.000 --> 48:06.000]  Ну не сильно сложно, но так.
[48:06.000 --> 48:08.000]  Надо поднапрячься.
[48:08.000 --> 48:10.000]  И последний n тоже так.
[48:10.000 --> 48:12.000]  Итак.
[48:12.000 --> 48:14.000]  Сейчас все, кто подключен,
[48:14.000 --> 48:16.000]  дружно решается, какую функцию он
[48:16.000 --> 48:18.000]  хочет реализовывать, и садится.
[48:18.000 --> 48:20.000]  Ты отжал
[48:20.000 --> 48:22.000]  pack-to-list. Прекрасно.
[48:24.000 --> 48:26.000]  А еще я отжал
[48:26.000 --> 48:28.000]  на mscreen tl. Пожалуйста,
[48:28.000 --> 48:30.000]  прошу, не пишите больше
[48:30.000 --> 48:32.000]  афиги.
[48:32.000 --> 48:34.000]  Да нет,
[48:34.000 --> 48:36.000]  на mspace detail как раз мусора надо
[48:36.000 --> 48:38.000]  накидывать.
[48:38.000 --> 48:40.000]  Ну конфликты может быть.
[48:44.000 --> 48:46.000]  Так.
[48:46.000 --> 48:48.000]  Что ж вы так смотрите печально?
[48:48.000 --> 48:50.000]  Вам надо решиться на мужественный
[48:50.000 --> 48:52.000]  подвиг. Вызваться.
[48:52.000 --> 48:54.000]  Что? Да, вы пишите, не я пишу.
[48:54.000 --> 48:56.000]  А нужно писать, кто
[48:56.000 --> 48:58.000]  забрал или нет?
[48:58.000 --> 49:00.000]  Месяка хватит.
[49:00.000 --> 49:02.000]  Да без разницы.
[49:02.000 --> 49:04.000]  Я думаю тоже без разницы.
[49:04.000 --> 49:06.000]  Да.
[49:08.000 --> 49:10.000]  Оценок за это конечно же никаких
[49:10.000 --> 49:12.000]  не будет, но это возможность потренироваться
[49:12.000 --> 49:14.000]  под неймнадзором перед домашкой.
[49:14.000 --> 49:16.000]  Домашка, как вы можете догадаться,
[49:16.000 --> 49:18.000]  будет ровно про это. Реализовать кучу
[49:18.000 --> 49:20.000]  разных операций.
[49:20.000 --> 49:22.000]  Но с таким спайси
[49:22.000 --> 49:24.000]  нил, нил и конс
[49:24.000 --> 49:26.000]  прибиты,
[49:26.000 --> 49:28.000]  зафиксированы ли названия?
[49:28.000 --> 49:30.000]  Сейчас да.
[49:30.000 --> 49:32.000]  Конс и нил они зафиксированы и прибиты.
[49:34.000 --> 49:36.000]  Мы в итоге с консами
[49:36.000 --> 49:38.000]  работаем в стане традиции получается.
[49:38.000 --> 49:40.000]  То же самое может быть
[49:40.000 --> 49:42.000]  писать и на этим вариадике.
[49:42.000 --> 49:44.000]  Да, но есть
[49:44.000 --> 49:46.000]  некоторое преимущество. Я говорю в домашке
[49:46.000 --> 49:48.000]  вы увидите, что классного можно натворить,
[49:48.000 --> 49:50.000]  если пользоваться не вариадиками.
[49:52.000 --> 49:54.000]  Если кто-то писал на хаскеле,
[49:54.000 --> 49:56.000]  то он может догадаться, чем
[49:56.000 --> 49:58.000]  хаскеловский лист отличается
[49:58.000 --> 50:00.000]  фундаментально, например,
[50:00.000 --> 50:02.000]  векторов в плюсах.
[50:02.000 --> 50:04.000]  А что, бесконечная?
[50:04.000 --> 50:06.000]  Да. Ленивость?
[50:06.000 --> 50:08.000]  Да.
[50:08.000 --> 50:10.000]  Больше ничего не говорю, сами подумайте об этом,
[50:10.000 --> 50:12.000]  в домашке разберетесь до конца.
[50:14.000 --> 50:16.000]  Вообще суть всего этого
[50:16.000 --> 50:18.000]  в том, чтобы прочувствовать, как
[50:18.000 --> 50:20.000]  писать разные метафункции
[50:20.000 --> 50:22.000]  хитрые операции
[50:22.000 --> 50:24.000]  в шаблонах над типами.
[50:26.000 --> 50:28.000]  Потому что тут очень много
[50:28.000 --> 50:30.000]  всего придется вам заиспользовать.
[50:30.000 --> 50:32.000]  Частичные специализации,
[50:32.000 --> 50:34.000]  всякие полные,
[50:34.000 --> 50:36.000]  вся цирковая штука.
[50:40.000 --> 50:42.000]  Почему append никто не взял?
[50:42.000 --> 50:44.000]  Append один из самых простых.
[50:44.000 --> 50:46.000]  Кто хочет append?
[50:46.000 --> 50:48.000]  Класс-лист. Что за класс-лист?
[50:50.000 --> 50:52.000]  Есть концепты type-лист,
[50:52.000 --> 50:54.000]  которые мы можем здесь дописать
[50:54.000 --> 50:56.000]  где-то вместо этого,
[50:56.000 --> 50:58.000]  а можем не дописывать.
[50:58.000 --> 51:00.000]  Так.
[51:18.000 --> 51:20.000]  Все написано.
[51:22.000 --> 51:24.000]  Нужно доброволец найти длину,
[51:24.000 --> 51:26.000]  это простенько.
[51:26.000 --> 51:28.000]  Доброволец найти длину,
[51:28.000 --> 51:30.000]  не ты, Аркадий.
[51:30.000 --> 51:32.000]  Ну, совсем просто.
[51:32.000 --> 51:34.000]  Возьмите.
[51:42.000 --> 51:44.000]  Так tail
[51:44.000 --> 51:46.000]  тоже тебе слишком просто
[51:46.000 --> 51:48.000]  будет. Ты tail не берешь.
[51:48.000 --> 51:50.000]  Нет, я не знаю пока,
[51:50.000 --> 51:52.000]  как написать tail.
[51:52.000 --> 51:54.000]  Ну ладно, давай тогда.
[51:54.000 --> 51:56.000]  Tail, кажется, никто не взял.
[51:56.000 --> 51:58.000]  А зачем мы вообще писали
[51:58.000 --> 52:00.000]  всех этих класс?
[52:00.000 --> 52:02.000]  Вот эти вот густое тело.
[52:02.000 --> 52:04.000]  А, можно без тела.
[52:04.000 --> 52:06.000]  На самом деле.
[52:06.000 --> 52:08.000]  Да.
[52:08.000 --> 52:10.000]  Ну, то есть давайте сейчас у конца
[52:10.000 --> 52:12.000]  и Нилы уберем тело,
[52:12.000 --> 52:14.000]  если вас оно смущает,
[52:14.000 --> 52:16.000]  и это будет тогда incomplete type.
[52:16.000 --> 52:18.000]  Ну, так и задумано.
[52:18.000 --> 52:20.000]  Мы их не хотим
[52:20.000 --> 52:22.000]  создавать экземпляры этого класса.
[52:22.000 --> 52:24.000]  Это чисто служебный класс.
[52:24.000 --> 52:26.000]  Сейчас здесь где-то есть типа last.
[52:26.000 --> 52:28.000]  Я прочитал tail
[52:28.000 --> 52:30.000]  и подумал, что это last,
[52:30.000 --> 52:32.000]  а не tail.
[52:32.000 --> 52:34.000]  Last?
[52:34.000 --> 52:36.000]  Наверное, last end.
[52:40.000 --> 52:42.000]  Сейчас, а как в Haskell last называется?
[52:42.000 --> 52:44.000]  Да там last end в конце есть,
[52:44.000 --> 52:46.000]  я его возьму.
[52:46.000 --> 52:48.000]  А, ну можно так.
[52:50.000 --> 52:52.000]  А если у Вадика желание
[52:52.000 --> 52:54.000]  наоборот сделать, чтобы у нас
[52:54.000 --> 52:56.000]  из концев лист получился?
[52:56.000 --> 52:58.000]  Хороший желание или плохой?
[52:58.000 --> 53:00.000]  Сейчас, из листа в тюпл?
[53:00.000 --> 53:02.000]  Нет, из концев,
[53:02.000 --> 53:04.000]  из последовательства концев в тюпл.
[53:04.000 --> 53:06.000]  Вот вложенные концы
[53:06.000 --> 53:08.000]  мы называем листом.
[53:08.000 --> 53:10.000]  В ряде с тюплами одно и то же.
[53:10.000 --> 53:12.000]  Если хочешь, напиши
[53:12.000 --> 53:14.000]  конверсию из
[53:16.000 --> 53:18.000]  из листа в тюпл, но
[53:20.000 --> 53:22.000]  короче, это будет медленно,
[53:22.000 --> 53:24.000]  если ты будешь реализовывать вот эти вот алгоритмы,
[53:24.000 --> 53:26.000]  сначала переходя к
[53:26.000 --> 53:28.000]  паку, а потом обратно.
[53:28.000 --> 53:30.000]  Сейчас, а если
[53:30.000 --> 53:32.000]  писать last end,
[53:32.000 --> 53:34.000]  насколько это
[53:34.000 --> 53:36.000]  не правильно?
[53:36.000 --> 53:38.000]  Сначала считать size.
[53:38.000 --> 53:40.000]  Что значит
[53:40.000 --> 53:42.000]  сначала считать size?
[53:42.000 --> 53:44.000]  Сначала какой размер листа,
[53:44.000 --> 53:46.000]  а потом уже из этого
[53:46.000 --> 53:48.000]  исходим.
[53:48.000 --> 53:50.000]  Давай подумаем.
[53:50.000 --> 53:52.000]  Кажется, в форвард листе
[53:52.000 --> 53:54.000]  нельзя играть.
[53:54.000 --> 53:56.000]  Потому что в форвард листе, пока мы не пройдем
[53:56.000 --> 53:58.000]  до конца, не знаем, где мы закончим.
[53:58.000 --> 54:00.000]  Ну да, тут аналогии с обычным кодом
[54:00.000 --> 54:02.000]  они работают прекрасно.
[54:02.000 --> 54:04.000]  Мы можем пройти
[54:04.000 --> 54:06.000]  в форвард листе до конца
[54:06.000 --> 54:08.000]  в перекурсии, например,
[54:08.000 --> 54:10.000]  а потом, спускаясь вверх, накапливать
[54:10.000 --> 54:12.000]  элементы. Можем?
[54:12.000 --> 54:14.000]  Можем. Здесь тоже что-то такое
[54:14.000 --> 54:16.000]  возможно получится.
[54:16.000 --> 54:18.000]  То есть не два прохода,
[54:18.000 --> 54:20.000]  а спуститься и подняться.
[54:20.000 --> 54:22.000]  В итоге каждый свой
[54:22.000 --> 54:24.000]  namespace detail делает или
[54:26.000 --> 54:28.000]  да, сделайте
[54:28.000 --> 54:30.000]  свой namespace detail
[54:30.000 --> 54:32.000]  какой угодно.
[54:32.000 --> 54:34.000]  Короче, главное, глобальный namespace
[54:34.000 --> 54:36.000]  не засоряйте и избегайте конфликтов имен.
[54:38.000 --> 54:40.000]  Есть ли еще кто-то?
[54:40.000 --> 54:42.000]  Typelist у вас
[54:42.000 --> 54:44.000]  уже зафиксировано.
[54:44.000 --> 54:46.000]  Typelist это концепт, да.
[54:46.000 --> 54:48.000]  Он зафиксирован.
[54:48.000 --> 54:50.000]  Если ты насполирил
[54:50.000 --> 54:52.000]  себя как в домашке, он зафиксирован.
[54:52.000 --> 54:54.000]  Тут по-другому, да, так и задумано.
[54:54.000 --> 54:56.000]  Окей, это хорошо.
[54:56.000 --> 54:58.000]  В домашке концепт typelist другой.
[55:04.000 --> 55:06.000]  Кто сидит, скучает?
[55:06.000 --> 55:08.000]  Возьмите еще что-нибудь.
[55:16.000 --> 55:18.000]  Лучше бы сейчас Typelist заняться.
[55:20.000 --> 55:22.000]  А я ничего говорить не буду. У нас
[55:22.000 --> 55:24.000]  семинар.
[55:34.000 --> 55:36.000]  У меня тоже
[55:36.000 --> 55:38.000]  useI
[55:38.000 --> 55:40.000]  в будущем он появится.
[55:42.000 --> 55:44.000]  Просто получается не протестировать
[55:44.000 --> 55:46.000]  то, что он будет написать.
[55:46.000 --> 55:48.000]  Тут и так не особо протестируешь за количество ошибок
[55:48.000 --> 55:50.000]  компиляции, но как только
[55:50.000 --> 55:52.000]  начнет какое-то
[55:52.000 --> 55:54.000]  количество реализованных корректно функций
[55:54.000 --> 55:56.000]  накапливаться, все будет круто.
[56:04.000 --> 56:06.000]  Так.
[56:28.000 --> 56:30.000]  Так, это Pactlist
[56:30.000 --> 56:32.000]  ты сделал, Аркадий?
[56:32.000 --> 56:59.640]  сделал давай тест напишем поехал разметка да ребята пакту лист у нас
[56:59.640 --> 57:04.640]  рабочий утверждается что так что можете его использовать и не сами выписывать
[57:04.640 --> 57:11.960]  ну в смысле для тестов для тестов его использовать да реализация
[57:11.960 --> 57:18.720]  должно быть без него чтобы оно быстро работало тесты можно с ним
[57:41.960 --> 58:08.240]  ну вы работайте я пойду за водичкой
[58:12.960 --> 58:18.720]  ее именно и приветствую мы сейчас просто ходим рекурсивно по этим спискам и
[58:18.720 --> 58:21.960]  пытаемся что-то найти
[58:48.720 --> 58:50.720]  а вот это я не назвал
[58:50.720 --> 58:52.720]  а
[58:52.720 --> 58:54.720]  а
[58:54.720 --> 58:56.720]  а
[58:56.720 --> 58:58.720]  а
[58:58.720 --> 59:00.720]  а
[59:00.720 --> 59:02.720]  а
[59:02.720 --> 59:04.720]  а
[59:04.720 --> 59:06.720]  а
[59:06.720 --> 59:08.720]  а
[59:08.720 --> 59:10.720]  а
[59:10.720 --> 59:12.720]  а
[59:12.720 --> 59:14.720]  а
[59:14.720 --> 59:16.720]  а
[59:16.720 --> 59:18.720]  а
[59:18.720 --> 59:20.720]  а
[59:20.720 --> 59:22.720]  а
[59:22.720 --> 59:24.720]  а
[59:24.720 --> 59:26.720]  а
[59:26.720 --> 59:28.720]  а
[59:28.720 --> 59:30.720]  а
[59:30.720 --> 59:32.720]  а
[59:32.720 --> 59:34.720]  а
[59:34.720 --> 59:36.720]  а
[59:36.720 --> 59:39.440]  а
[59:39.440 --> 59:44.440]  Сейчас, давайте по одному.
[59:44.440 --> 59:48.440]  Короче, я ловлю странное ошибку.
[59:48.440 --> 59:52.440]  Планетарь, эваливация, локальность, констакт.
[59:56.440 --> 01:00:02.440]  Планетарь, эваливация, локальность, констакт.
[01:00:18.440 --> 01:00:22.440]  Планетарь, эваливация, локальность, констакт.
[01:00:22.440 --> 01:00:26.440]  Возможно, ты наткнулся на independent base name lookup.
[01:00:26.440 --> 01:00:27.440]  Нет?
[01:00:27.440 --> 01:00:30.440]  Помнишь? Рассказывал об этом.
[01:00:30.440 --> 01:00:34.440]  Что если у тебя дергаешь что-то из родительского класса...
[01:00:34.440 --> 01:00:36.440]  Это все в одном классе.
[01:00:36.440 --> 01:00:37.440]  Это все в одном?
[01:00:37.440 --> 01:00:39.440]  Да, у меня нет последований.
[01:00:39.440 --> 01:00:42.440]  Я просто в родительский хуй нес. Ну ладно.
[01:00:42.440 --> 01:00:46.440]  И, то есть...
[01:00:46.440 --> 01:00:48.440]  Divide, Extend.
[01:00:48.440 --> 01:00:51.440]  Ну это просто обокруглять в делении.
[01:00:51.440 --> 01:00:55.440]  Когда такие ошибки, надо начинать модифицировать.
[01:00:55.440 --> 01:00:59.440]  Вот это выражение вынести в отдельную constexpr переменную.
[01:00:59.440 --> 01:01:05.440]  Прям в этом блоке делаешь constexpr фуров, но это выражение уже подставляешь.
[01:01:05.440 --> 01:01:11.440]  И вот как-то так декомпозируй на кусочки и смотри, работает или не работает.
[01:01:11.440 --> 01:01:14.440]  Да.
[01:01:14.440 --> 01:01:16.440]  Concatenate.
[01:01:16.440 --> 01:01:19.440]  Давайте посмотрим Concatenate.
[01:01:19.440 --> 01:01:21.440]  После...
[01:01:28.440 --> 01:01:30.440]  Так.
[01:01:42.440 --> 01:01:44.440]  Ну, идейно. Что вы сделали?
[01:01:44.440 --> 01:01:46.440]  Ну, дошли до конца списка.
[01:01:46.440 --> 01:01:48.440]  Ну, вот.
[01:01:48.440 --> 01:01:50.440]  Так надо.
[01:02:06.440 --> 01:02:08.440]  Да, вот тут...
[01:02:08.440 --> 01:02:13.440]  Некто Никита пытается сделать частичные специализации.
[01:02:13.440 --> 01:02:17.440]  Using так не работает. Это вы.
[01:02:17.440 --> 01:02:19.440]  Никита, ты.
[01:02:19.440 --> 01:02:21.440]  Вы вдвоем, Никита.
[01:02:21.440 --> 01:02:23.440]  Понял.
[01:02:23.440 --> 01:02:28.440]  А вот так не работает. Нельзя сделать forward declaration для using, к сожалению.
[01:02:28.440 --> 01:02:33.440]  Поэтому я и сказал про namespace, потому что вам какие-то структурки вспомогательные могут понадобиться.
[01:02:33.440 --> 01:02:37.440]  Так, а какая ошибка у тебя была? В каком месте?
[01:02:39.440 --> 01:02:41.440]  На какую строчку мне посмотреть?
[01:02:41.440 --> 01:02:43.440]  134.
[01:02:45.440 --> 01:02:49.440]  А вот почему нельзя forward эти music делать?
[01:02:49.440 --> 01:02:51.440]  А, так вот. Вот так.
[01:02:51.440 --> 01:02:54.440]  Ну, это мега тупо. Меня тоже это бесит.
[01:02:54.440 --> 01:02:58.440]  Местами это мне ломает жизнь очень сильно, но вот так вот.
[01:02:58.440 --> 01:03:01.440]  И причем достаточно легко придумать замену.
[01:03:01.440 --> 01:03:05.440]  Ну, какой-нибудь type name foo, если бы работало, было бы здорово.
[01:03:05.440 --> 01:03:07.440]  Как forward declaration.
[01:03:07.440 --> 01:03:10.440]  Но не работает. Я думаю, за проблем Abbey.
[01:03:12.440 --> 01:03:14.440]  Так.
[01:03:29.440 --> 01:03:31.440]  Ну, ctrl c сделай, перезагрузись.
[01:03:31.440 --> 01:03:33.440]  А first and detail.
[01:03:35.440 --> 01:03:37.440]  Это оно?
[01:03:37.440 --> 01:03:39.440]  Нет.
[01:03:45.440 --> 01:03:49.440]  Сейчас. Length. Что в length пошло не так?
[01:04:07.440 --> 01:04:09.440]  Нормально.
[01:04:34.440 --> 01:04:36.440]  Хитрее будете делать.
[01:04:36.440 --> 01:04:38.440]  Хитрее.
[01:04:42.440 --> 01:04:44.440]  Списки типов.
[01:04:46.440 --> 01:04:48.440]  Знаешь операцию group by?
[01:04:52.440 --> 01:04:54.440]  Ну, вот это бонус на уровень этого dz.
[01:05:06.440 --> 01:05:08.440]  Сейчас забавишься.
[01:05:24.440 --> 01:05:27.440]  Ну, obs скрашился. Наверное, оно и к лучшему.
[01:05:30.440 --> 01:05:32.440]  На камере.
[01:05:32.440 --> 01:05:35.440]  Ну, на камере тут достаточно хорошо все видно должно быть, по идее.
[01:05:36.440 --> 01:05:38.440]  Вот.
[01:05:41.440 --> 01:05:44.440]  Ну, я просто не знаю, как с этим воевать.
[01:05:44.440 --> 01:05:47.440]  Оно умирает, крашится, у меня ноут перегревается.
[01:05:47.440 --> 01:05:49.440]  Возможно, пора новый ноут покупать.
[01:05:54.440 --> 01:05:56.440]  Так, ну, length там вообще правильно выглядел.
[01:05:56.440 --> 01:06:00.440]  То, что он не работал, это, возможно, баг чего-то выше.
[01:06:01.440 --> 01:06:03.440]  Что?
[01:06:03.440 --> 01:06:05.440]  TL?
[01:06:07.440 --> 01:06:09.440]  Окей, оно все работает.
[01:06:33.440 --> 01:06:35.440]  Вот.
[01:06:35.440 --> 01:06:37.440]  Вот.
[01:07:02.440 --> 01:07:04.440]  Здравствуй.
[01:07:05.440 --> 01:07:07.440]  Здравствуй.
[01:07:19.440 --> 01:07:22.440]  Аркадий, ты решил просто все написать за всех, да?
[01:07:23.440 --> 01:07:27.440]  Нет, просто какой-то человек у меня украл у нас TL.
[01:07:29.440 --> 01:07:34.440]  И я хочу написать, записать, чтобы вот этого деймспейса и таблистировать.
[01:07:34.440 --> 01:07:36.440]  Окей.
[01:07:37.440 --> 01:07:39.440]  Ну, такое могло произойти.
[01:07:47.440 --> 01:07:50.440]  Так, кто-то у нас неправильно использует слово typelist.
[01:07:50.440 --> 01:07:52.440]  Typelist это концепт.
[01:07:54.440 --> 01:07:56.440]  Cons.
[01:07:57.440 --> 01:08:00.440]  Cons, пара, элемент, хвост, это cons.
[01:08:01.440 --> 01:08:03.440]  Или что вы хотите?
[01:08:05.440 --> 01:08:07.440]  Type tuple.
[01:08:14.440 --> 01:08:17.440]  Такие же первокуры шумные, боже мой.
[01:08:35.440 --> 01:08:39.440]  Реверс делаете, да?
[01:08:52.440 --> 01:08:54.440]  Кто?
[01:08:57.440 --> 01:08:59.440]  N? Что?
[01:09:05.440 --> 01:09:07.440]  Вау.
[01:09:08.440 --> 01:09:10.440]  Но это умно, да.
[01:09:11.440 --> 01:09:13.440]  Но это медленно.
[01:09:34.440 --> 01:09:36.440]  Так, Никита Петя.
[01:09:36.440 --> 01:09:39.440]  Мне кажется, вы что-то тут творите такое очень хитрое.
[01:09:40.440 --> 01:09:42.440]  Зачем?
[01:09:45.440 --> 01:09:47.440]  Не надо так.
[01:09:49.440 --> 01:09:54.440]  Perf в compile-time измеряется в количестве инстанциаций.
[01:09:55.440 --> 01:10:00.440]  Всегда, когда мы пишем что-то вот такое, наша задача это минимизировать количество инстанциаций шаблонов.
[01:10:00.440 --> 01:10:03.440]  То, что вы делаете, это будет очень больно.
[01:10:05.440 --> 01:10:09.440]  Ну, то есть чем проще и меньше действий вы делаете, как правило, тем быстрее оно работает.
[01:10:10.440 --> 01:10:14.440]  OK, но логично, хотя бы unpack на фису правильный, но типа это должно работать?
[01:10:15.440 --> 01:10:17.440]  Unpack. То есть вы перегоняете...
[01:10:18.440 --> 01:10:20.440]  А зато type tuple и sponsor?
[01:10:23.440 --> 01:10:25.440]  Ну, нет.
[01:10:25.440 --> 01:10:27.440]  Вот это фигня какая-то.
[01:10:28.440 --> 01:10:33.440]  Почему сделали type tuple из какого-то left и шаблон unpack вашего?
[01:10:44.440 --> 01:10:50.440]  Ну, короче, у вас таким образом не получится сделать превращение type-листа в type tuple,
[01:10:50.440 --> 01:11:02.440]  чтобы превратить type-лист в type tuple, вам нужно в шаблонных аргументах вашего хелпера, вот здесь, накопить пак итоговый,
[01:11:03.440 --> 01:11:06.440]  а потом разом весь его запихнуть в type tuple.
[01:11:09.440 --> 01:11:11.440]  Если вы поняли, это OK.
[01:11:12.440 --> 01:11:14.440]  Но это не имеет отношения к реализации апенда.
[01:11:15.440 --> 01:11:19.440]  В апенде нужно просто дойти до конца и заменить...
[01:11:20.440 --> 01:11:21.440]  Заменить.
[01:11:22.440 --> 01:11:27.440]  Ну, как конкатенейт люди уже справились, можно точно так же как там, по сути.
[01:11:44.440 --> 01:11:46.440]  Ну, добивайте.
[01:11:51.440 --> 01:11:57.440]  Пока апенд превратится в конкатенейт, tl, cons...
[01:12:08.440 --> 01:12:10.440]  Блин, конкатенейт он ниже.
[01:12:14.440 --> 01:12:16.440]  Ладно.
[01:12:44.440 --> 01:12:46.440]  Сейчас с левой тип, с правой конца.
[01:13:01.440 --> 01:13:05.440]  Сейчас разом в конце левой тип, правой...
[01:13:06.440 --> 01:13:08.440]  Да, слева тип, справа другой список.
[01:13:14.440 --> 01:13:19.440]  Ну, вот, да, вот эта конвертация в ту сторону, это то, что немножко расширяет сознание в плане использования шаблонов,
[01:13:20.440 --> 01:13:24.440]  накапливания результата в шаблонных аргументов какого-то хелпера.
[01:13:25.440 --> 01:13:27.440]  Такой трюк необычный немного.
[01:13:32.440 --> 01:13:33.440]  А что мы делаем?
[01:13:33.440 --> 01:13:36.440]  К тебе смельчак, который возьмет эндерспёрс?
[01:13:38.440 --> 01:13:39.440]  Ты берёшь его, да?
[01:13:40.440 --> 01:13:41.440]  А я пилю.
[01:13:42.440 --> 01:13:43.440]  Я пилю.
[01:13:44.440 --> 01:13:45.440]  А ты пилю.
[01:13:46.440 --> 01:13:47.440]  А я пилю.
[01:13:48.440 --> 01:13:49.440]  И ты пилю.
[01:13:50.440 --> 01:13:51.440]  А я пилю.
[01:13:52.440 --> 01:13:53.440]  А я пилю.
[01:13:54.440 --> 01:13:55.440]  А я пилю.
[01:13:56.440 --> 01:13:57.440]  А я пилю.
[01:13:58.440 --> 01:13:59.440]  А я пилю.
[01:14:00.440 --> 01:14:01.440]  А я пилю.
[01:14:01.440 --> 01:14:03.440]  Ты берёшь его, да?
[01:14:04.440 --> 01:14:05.440]  Ага, всё.
[01:14:07.440 --> 01:14:10.440]  А вот плюсик вижу, всё, я не заметил.
[01:14:32.440 --> 01:14:35.440]  Реализация, я всё-таки считаю, что...
[01:14:38.440 --> 01:14:41.440]  Ну что ты делаешь? Ты идёшь...
[01:14:47.440 --> 01:14:49.440]  Сколько выкинуть надо, да?
[01:14:50.440 --> 01:14:52.440]  Ну это нормально, в принципе.
[01:14:53.440 --> 01:14:56.440]  По-моему, я также в итоге написал. Это самое простое, что можно написать.
[01:14:56.440 --> 01:14:59.440]  Насчёт оптимального, надо, конечно, подумать.
[01:15:00.440 --> 01:15:02.440]  С головы такая просто это не выдумать.
[01:15:02.440 --> 01:15:05.440]  Ну как можно, типа, имитировать?
[01:15:06.440 --> 01:15:07.440]  Именно...
[01:15:08.440 --> 01:15:11.440]  Вот как бы, типа, граф идём, открытие, закрытие, вершина.
[01:15:12.440 --> 01:15:14.440]  Вот как бы, закрытие, имитирование.
[01:15:15.440 --> 01:15:16.440]  Вышли из скоб.
[01:15:25.440 --> 01:15:27.440]  В шаблонных аргументах что-то надо делать.
[01:15:27.440 --> 01:15:31.440]  Смотри, мне хочется, в идеале как сделать?
[01:15:32.440 --> 01:15:36.440]  Сделать репушку, чтобы мы выходим до конца, а затем выходим один раз.
[01:15:37.440 --> 01:15:39.440]  Это кажется последствием уже.
[01:15:40.440 --> 01:15:44.440]  Нет, выходить мы всё равно все... ну и входим-выходим одинаковое количество раз.
[01:15:45.440 --> 01:15:47.440]  Прошли до конца, потом выходим.
[01:15:48.440 --> 01:15:52.440]  И вот пока мы проходим внутрь, мы должны каким-то образом понять,
[01:15:53.440 --> 01:15:57.440]  а на каждом из этих шагов должны ли мы наружу возвращать
[01:16:00.440 --> 01:16:03.440]  результат просто, как он есть, или прицепить ещё свой элемент.
[01:16:04.440 --> 01:16:08.440]  То есть каждая нода рекурсии делает решение.
[01:16:09.440 --> 01:16:13.440]  То, что ей дали следующего шага, вернуть как есть или прицепить свой результат.
[01:16:14.440 --> 01:16:19.440]  Вот это решение научиться принимать нужно, пока мы спускались вниз, мне кажется.
[01:16:19.440 --> 01:16:23.440]  Сейчас я попробую. У меня есть какая-то голове мысли возникла.
[01:16:24.440 --> 01:16:26.440]  Сейчас может получится делать.
[01:16:49.440 --> 01:16:53.440]  Track 1
[01:16:57.440 --> 01:16:59.440]  Я не знаю, что тут делать.
[01:17:11.440 --> 01:17:13.440]  Хочется сказать, что нет.
[01:17:13.440 --> 01:17:22.360]  что нет, но тут как всегда есть маленькое но, но наизусть
[01:17:22.360 --> 01:17:24.440]  я не помню в чём там деталь и проблема.
[01:17:24.440 --> 01:17:32.560]  А нет, вот куда посмотреть какая строчка.
[01:17:32.560 --> 01:17:40.560]  Так, и что тебе пишут?
[01:18:02.560 --> 01:18:28.840]  Так вроде она работает, просто там это кто-то нашалил сверху, сломал.
[01:18:28.840 --> 01:18:42.760]  Ну я вот сейчас смотрю, тут ничего вроде нету.
[01:18:42.760 --> 01:18:53.680]  160.
[01:18:58.840 --> 01:19:18.240]  Аппенд никто не стал писать.
[01:19:18.240 --> 01:19:27.240]  Ну это мы пробуем так, если мы выбрали любой список, один список на капель для другой размерации.
[01:19:27.240 --> 01:19:55.240]  У вас ничего не работает, да, там смептонг.
[01:19:55.240 --> 01:20:18.240]  Ну тут люди пишут что-то, поэтому это всё.
[01:20:18.240 --> 01:20:43.240]  Пробовали выйти и зайти обратно?
[01:20:43.240 --> 01:20:49.240]  Какой у тебя ник?
[01:20:49.240 --> 01:21:11.240]  Нет, может просто призрак остался.
[01:21:11.240 --> 01:21:16.240]  Да, но только пишет анонимус, на самом деле ники можно ставить.
[01:21:16.240 --> 01:21:39.240]  Да, это для меня новости.
[01:21:39.240 --> 01:22:04.240]  Кто type name не дописал?
[01:22:04.240 --> 01:22:29.240]  Кто мап писал, он готов или не готов?
[01:22:29.240 --> 01:22:37.240]  Тут кажется какие-то форут-декларации нужно накладывать, что-то вот такое, чтобы оно не жаловалось на жизнь.
[01:22:37.240 --> 01:22:41.240]  Ну вообще мап должен быть проще, мне кажется.
[01:22:41.240 --> 01:22:57.240]  Вот то, что три разных шаблона, уже это так не должно быть, там одного должно хватить.
[01:22:57.240 --> 01:23:13.240]  А, вижу. Ну всё равно, по-моему одним шаблоном можно обойтись. То есть проще должно быть немножко всё.
[01:23:13.240 --> 01:23:38.240]  Одним шаблоном со специализацией в смысле, да.
[01:23:38.240 --> 01:24:03.240]  Что-то по всему файлу пропадают запятые точки с запятыми. Что происходит? Кто ворует?
[01:24:03.240 --> 01:24:22.240]  Аркадий, почему ты забросил last temple fast?
[01:24:22.240 --> 01:24:28.240]  Я не забросил, это интернет упал, я его пришёл.
[01:24:28.240 --> 01:24:32.240]  Не видишь, но он растёт.
[01:24:32.240 --> 01:24:36.240]  Видишь имплементацию, она есть.
[01:24:36.240 --> 01:25:04.240]  Нет, я написал какую-то логику уже, но я верю, что она работает. У меня осталась специализация для крывых звучей.
[01:25:04.240 --> 01:25:06.240]  Кто пишет маму?
[01:25:06.240 --> 01:25:24.240]  Кажется люди за вами, вот там.
[01:25:24.240 --> 01:25:46.240]  Так, в 373 мы пытаемся первой N.
[01:25:46.240 --> 01:26:04.240]  А, ты наткнулся на случай, когда ты сделал специализацию, когда нулевой размер, число н, число ноль, и отдельную специализацию, где нил.
[01:26:04.240 --> 01:26:13.240]  Сейчас, нет. 379 и 391, говоришь, ambiguous.
[01:26:13.240 --> 01:26:27.240]  Да, тут тоже может быть ambiguous, когда у тебя и ноль, и конс одновременно.
[01:26:27.240 --> 01:26:35.240]  Кстати, это тоже такая мораль небольшая, что такое возникает, а надо писать третью тогда.
[01:26:35.240 --> 01:26:55.240]  У меня она возникала с пустым обычно, когда вот не конс, а нил.
[01:26:55.240 --> 01:27:01.240]  Так, что вы в этом тейке сделали такого, товарищи?
[01:27:01.240 --> 01:27:05.240]  Ты один делал или вы там вместе?
[01:27:05.240 --> 01:27:15.240]  Да, что ты там натворил?
[01:27:15.240 --> 01:27:22.240]  Ага, развернуты.
[01:27:22.240 --> 01:27:25.240]  И тебе потом обратно разворачивать нужно.
[01:27:25.240 --> 01:27:32.240]  Кажется мне, что можно без этого разворота.
[01:27:32.240 --> 01:27:35.240]  Ну вот сразу ты идешь внутрь, вниз.
[01:27:35.240 --> 01:27:44.240]  Берешь и говоришь, что я это конс от текущего элемента и рекурсивный вызов от хвоста.
[01:27:44.240 --> 01:27:47.240]  Понял?
[01:27:47.240 --> 01:27:53.240]  На каждой трассе рекурсии ты говоришь, что твой тип это вот конс от текущего типа и рекурсивного вызова.
[01:27:53.240 --> 01:27:57.240]  А дальше рекурсивный вызов в какой-то момент решит, а дальше идти не надо.
[01:27:57.240 --> 01:27:59.240]  Все, мы набрали сколько надо.
[01:27:59.240 --> 01:28:01.240]  И вернет нил.
[01:28:01.240 --> 01:28:03.240]  Не придется реверс делать.
[01:28:23.240 --> 01:28:25.240]  Что вы видите?
[01:28:25.240 --> 01:28:27.240]  Что вы видите?
[01:28:27.240 --> 01:28:28.240]  А вот и другое.
[01:28:28.240 --> 01:28:34.240]  Теперь положите.
[01:28:34.240 --> 01:28:36.240]  Кто-то у нас где-то халпы.
[01:28:36.240 --> 01:28:40.240]  У нас халпы где-то там.
[01:28:40.240 --> 01:28:44.240]  Вот у нас халпы.
[01:28:44.240 --> 01:29:11.240]  Я не особо понимаю.
[01:29:11.240 --> 01:29:23.240]  Стоит ли сейчас пытаться впихнуть кусочек теории?
[01:29:23.240 --> 01:29:29.240]  Ну давай ты мне покажешь, а я перепишу.
[01:29:29.240 --> 01:29:37.240]  О да, сейчас тебе путешествие будет.
[01:29:37.240 --> 01:29:42.240]  Вот отсюда начинается.
[01:29:42.240 --> 01:29:45.240]  Только один счетчик, да?
[01:29:45.240 --> 01:29:47.240]  Да.
[01:29:47.240 --> 01:29:52.240]  Тин счетчик.
[01:29:52.240 --> 01:29:58.240]  Хэк тэйл, тэк тэк.
[01:29:58.240 --> 01:30:02.240]  У, мама, кондиционал тэ.
[01:30:02.240 --> 01:30:06.240]  Ну это конечно так.
[01:30:32.240 --> 01:30:57.240]  Ну в принципе это примерно то, что я хотел, да.
[01:30:57.240 --> 01:31:12.240]  Ну тут сейчас будет да.
[01:31:12.240 --> 01:31:24.240]  Тут просто с насыщением.
[01:31:24.240 --> 01:31:30.240]  Иначе видимо...
[01:31:30.240 --> 01:31:36.240]  Что ты такое делаешь вообще тогда?
[01:31:36.240 --> 01:31:42.240]  А, эта штука плюс... да, да, да, факт.
[01:31:42.240 --> 01:31:46.240]  Какое-то программирование.
[01:31:46.240 --> 01:31:51.240]  Сейчас надо искать, да?
[01:31:51.240 --> 01:31:54.240]  Все, да?
[01:31:54.240 --> 01:31:56.240]  Больше специализации нет?
[01:31:56.240 --> 01:31:57.240]  Вот еще.
[01:31:57.240 --> 01:31:58.240]  О, нет.
[01:31:58.240 --> 01:32:07.240]  Конец.
[01:32:07.240 --> 01:32:09.240]  На самом деле не конец, да?
[01:32:09.240 --> 01:32:13.240]  Потому что еще если тебя ноль передали.
[01:32:13.240 --> 01:32:18.240]  Если ноль передали, то...
[01:32:18.240 --> 01:32:21.240]  Если ноль передали, то...
[01:32:21.240 --> 01:32:23.240]  Нет, она отработает, если ноль передали.
[01:32:23.240 --> 01:32:26.240]  Можно оптимайз, конечно, сделать.
[01:32:26.240 --> 01:32:28.240]  Но если так помыслить.
[01:32:28.240 --> 01:32:31.240]  Ну сейчас давай мы напишем ниловскую специализацию.
[01:32:31.240 --> 01:32:32.240]  Тут еще size 0.
[01:32:32.240 --> 01:32:33.240]  А, она дойдет.
[01:32:33.240 --> 01:32:35.240]  И это last end, да?
[01:32:35.240 --> 01:32:37.240]  Вот сюда size еще можно написать.
[01:32:37.240 --> 01:32:44.240]  Size 0.
[01:32:44.240 --> 01:32:46.240]  Это last end был, правда?
[01:32:46.240 --> 01:32:48.240]  Last end.
[01:32:48.240 --> 01:32:51.240]  Last end, да, для last ends n.
[01:32:51.240 --> 01:32:53.240]  Окей, да, да.
[01:32:53.240 --> 01:32:56.240]  Можно только оптимизировать, но это так фигня.
[01:32:56.240 --> 01:32:59.240]  Окей, смотри...
[01:32:59.240 --> 01:33:00.240]  Прикол.
[01:33:00.240 --> 01:33:04.240]  Conditional te можно заменить.
[01:33:04.240 --> 01:33:10.240]  Заменить на следующий прикол.
[01:33:10.240 --> 01:33:13.240]  А, специализацию на bool сделать?
[01:33:13.240 --> 01:33:17.240]  Сейчас, но...
[01:33:17.240 --> 01:33:18.240]  Интересно, интересно.
[01:33:18.240 --> 01:33:20.240]  Вот такой какой-то прикол.
[01:33:20.240 --> 01:33:22.240]  Сейчас, нет.
[01:33:22.240 --> 01:33:27.240]  Но тут, конечно, достаточно сложно это будет с тем, как ты написал.
[01:33:27.240 --> 01:33:29.240]  Отсюда выдрать tail only head.
[01:33:29.240 --> 01:33:32.240]  Я не знаю, мне не хочется об этом думать.
[01:33:32.240 --> 01:33:33.240]  Я бы оставил...
[01:33:33.240 --> 01:33:35.240]  Можно да, можно так.
[01:33:35.240 --> 01:33:37.240]  Но тут можно поиграться.
[01:33:37.240 --> 01:33:41.240]  И вот через этот люк тоже может красивее выйти.
[01:33:41.240 --> 01:33:43.240]  В целом, кажется, она работает.
[01:33:43.240 --> 01:33:44.240]  Сейчас.
[01:33:44.240 --> 01:33:45.240]  Если заменить.
[01:33:45.240 --> 01:33:47.240]  Давай тогда вот здесь нужно в last end.
[01:33:47.240 --> 01:33:49.240]  Ну тут умеет просто на fast.
[01:33:49.240 --> 01:33:51.240]  Там тест нежуестка.
[01:33:58.240 --> 01:34:01.240]  Что это подчеркнуто?
[01:34:01.240 --> 01:34:05.240]  No name type name.
[01:34:05.240 --> 01:34:07.240]  А, стоп, там еще не все.
[01:34:07.240 --> 01:34:09.240]  Тут странное что-то.
[01:34:09.240 --> 01:34:11.240]  Тут надо вставить.
[01:34:11.240 --> 01:34:13.240]  Сюда write.
[01:34:13.240 --> 01:34:15.240]  Почему-то нет.
[01:34:15.240 --> 01:34:17.240]  Почему ты сюда write и не ввешай?
[01:34:19.240 --> 01:34:21.240]  Не-не-не.
[01:34:21.240 --> 01:34:23.240]  Смотри, meagones.
[01:34:23.240 --> 01:34:25.240]  Type.
[01:34:25.240 --> 01:34:27.240]  Type.
[01:34:34.240 --> 01:34:36.240]  3.
[01:34:42.240 --> 01:34:45.240]  Мне кажется, она идет в дефолтную имплементацию.
[01:34:49.240 --> 01:34:51.240]  conditional.t
[01:34:51.240 --> 01:34:53.240]  Ты понял, что произошло, да?
[01:34:53.240 --> 01:34:55.240]  А, скобки потерялись.
[01:35:05.240 --> 01:35:07.240]  Работает, ура.
[01:35:09.240 --> 01:35:11.240]  Ну все, получилось.
[01:35:11.240 --> 01:35:15.240]  Жаль, конечно, что wi-fi карта не позволила.
[01:35:17.240 --> 01:35:19.240]  Так, у кого еще что-то не сработало или не срослось?
[01:35:19.240 --> 01:35:23.240]  Рома, мы случайно развивали монст в обратном направлении.
[01:35:23.240 --> 01:35:25.240]  Можешь ампак-тошку смотреть?
[01:35:25.240 --> 01:35:27.240]  Кого посмотреть?
[01:35:27.240 --> 01:35:29.240]  Ампак-тошку, вверху самом.
[01:35:29.240 --> 01:35:31.240]  Это Никита.
[01:35:31.240 --> 01:35:33.240]  Мы как-то сделали правильно,
[01:35:33.240 --> 01:35:37.240]  только у нас ампак он еще реверсит при этом.
[01:35:37.240 --> 01:35:39.240]  Неприятная особенность, да?
[01:35:39.240 --> 01:35:41.240]  Мы ее осознали давно.
[01:35:41.240 --> 01:35:43.240]  А зачем вы вот так вот делаете?
[01:35:43.240 --> 01:35:45.240]  Странно.
[01:35:45.240 --> 01:35:47.240]  В чем странность?
[01:35:47.240 --> 01:35:49.240]  Принимайте.
[01:35:53.240 --> 01:35:57.240]  Зачем отдельно выделять обработку последнего элемента,
[01:35:57.240 --> 01:35:59.240]  когда база рекурсии может с нулем работать?
[01:35:59.240 --> 01:36:01.240]  Может.
[01:36:01.240 --> 01:36:03.240]  Так, а сама рекурсия как выглядит?
[01:36:07.240 --> 01:36:09.240]  ConsLeftRight распаковываем
[01:36:11.240 --> 01:36:13.240]  и запускаем ампак от...
[01:36:13.240 --> 01:36:15.240]  А что такое helper?
[01:36:17.240 --> 01:36:19.240]  Просто закопить.
[01:36:23.240 --> 01:36:25.240]  Не понимаю.
[01:36:25.240 --> 01:36:29.240]  Ну и кажется, кстати, кассет проходит.
[01:36:29.240 --> 01:36:31.240]  Ну, проходит и проходит.
[01:36:31.240 --> 01:36:33.240]  Взять кассет с перевернутым.
[01:36:35.240 --> 01:36:37.240]  Зачем...
[01:36:37.240 --> 01:36:39.240]  Просто смотрите, вы говорите,
[01:36:39.240 --> 01:36:41.240]  что сигнатура у этого шаблона, она какая?
[01:36:41.240 --> 01:36:43.240]  Cons и...
[01:36:43.240 --> 01:36:45.240]  О, все окей.
[01:36:45.240 --> 01:36:47.240]  А...
[01:36:47.240 --> 01:36:49.240]  С таким helper можно было
[01:36:49.240 --> 01:36:51.240]  в качестве него type tuple
[01:36:51.240 --> 01:36:53.240]  просто использовать.
[01:36:53.240 --> 01:36:55.240]  Но я имел в виду что?
[01:36:55.240 --> 01:36:57.240]  Прям вот так сделать.
[01:36:57.240 --> 01:36:59.240]  Прям вот здесь pack передавать.
[01:36:59.240 --> 01:37:01.240]  А вот left-right это не очень хорошо называть.
[01:37:01.240 --> 01:37:03.240]  Head-tail фиксированная терминология,
[01:37:03.240 --> 01:37:05.240]  которая там
[01:37:05.240 --> 01:37:07.240]  во всей литературе примерно используется.
[01:37:07.240 --> 01:37:09.240]  Tail.
[01:37:09.240 --> 01:37:11.240]  А здесь просто передаем head
[01:37:11.240 --> 01:37:13.240]  и тот же самый и.
[01:37:19.240 --> 01:37:21.240]  Я бы это вот так назвал.
[01:37:21.240 --> 01:37:23.240]  То есть мы аккумулируем какие-то типы.
[01:37:27.240 --> 01:37:29.240]  В случае, когда ампак
[01:37:29.240 --> 01:37:31.240]  такой вот такой,
[01:37:31.240 --> 01:37:33.240]  то есть мы аккумулируем
[01:37:33.240 --> 01:37:35.240]  какие-то типы.
[01:37:35.240 --> 01:37:37.240]  В случае, когда ампак такой вот такой,
[01:37:37.240 --> 01:37:39.240]  мы аккумулируем
[01:37:43.240 --> 01:37:45.240]  nil, int...
[01:37:45.240 --> 01:37:47.240]  Да, все нормально, нет.
[01:37:47.240 --> 01:37:49.240]  Все нормально.
[01:37:49.240 --> 01:37:51.240]  Мы аккумулируем типы в обычный pack.
[01:37:51.240 --> 01:37:53.240]  Только они нааккумулировались,
[01:37:53.240 --> 01:37:55.240]  возвращаем type tuple.
[01:37:55.240 --> 01:37:57.240]  Проще? Проще.
[01:37:57.240 --> 01:37:59.240]  Да, вот это все
[01:37:59.240 --> 01:38:01.240]  я удаляю, оно уже не нужно.
[01:38:01.240 --> 01:38:03.240]  Какой-то legacy.
[01:38:03.240 --> 01:38:05.240]  И это кажется тоже.
[01:38:05.240 --> 01:38:07.240]  Окей.
[01:38:11.240 --> 01:38:13.240]  Я не могу прочитать,
[01:38:13.240 --> 01:38:15.240]  что у вас здесь написано.
[01:38:19.240 --> 01:38:21.240]  Ну окей,
[01:38:21.240 --> 01:38:23.240]  но я прям рекомендую
[01:38:23.240 --> 01:38:25.240]  попробовать дать ему шанс.
[01:38:27.240 --> 01:38:29.240]  Трехэтажные шаблоны
[01:38:29.240 --> 01:38:31.240]  требуют особого какого-то
[01:38:31.240 --> 01:38:33.240]  подхода к жизни.
[01:38:33.240 --> 01:38:35.240]  Так, и
[01:38:35.240 --> 01:38:37.240]  int
[01:38:37.240 --> 01:38:39.240]  double float.
[01:38:39.240 --> 01:38:41.240]  Чтобы развернуть,
[01:38:41.240 --> 01:38:43.240]  просто местами
[01:38:43.240 --> 01:38:45.240]  дописываем
[01:38:45.240 --> 01:38:47.240]  в конец
[01:38:47.240 --> 01:38:49.240]  будет
[01:38:49.240 --> 01:38:51.240]  float double int.
[01:38:55.240 --> 01:38:57.240]  Почему это сработало?
[01:39:01.240 --> 01:39:03.240]  Так,
[01:39:03.240 --> 01:39:05.240]  мап заброшен
[01:39:05.240 --> 01:39:07.240]  или у вас какой-то прогресс есть?
[01:39:07.240 --> 01:39:09.240]  Возможно, вы на кого-то
[01:39:09.240 --> 01:39:11.240]  в полу нажали и вас из-за этого
[01:39:11.240 --> 01:39:13.240]  дергало.
[01:39:13.240 --> 01:39:15.240]  Просто дергало.
[01:39:15.240 --> 01:39:17.240]  Давайте мы просто
[01:39:17.240 --> 01:39:19.240]  уже к концу...
[01:39:19.240 --> 01:39:21.240]  Вы не обидитесь, если я просто расскажу,
[01:39:21.240 --> 01:39:23.240]  как мап написать?
[01:39:23.240 --> 01:39:25.240]  Мы можем сейчас свою организацию
[01:39:25.240 --> 01:39:27.240]  попробовать снимать?
[01:39:27.240 --> 01:39:29.240]  Да.
[01:39:29.240 --> 01:39:31.240]  Ну если она большая,
[01:39:31.240 --> 01:39:33.240]  то это точно что-то не так.
[01:39:33.240 --> 01:39:35.240]  Что там...
[01:39:35.240 --> 01:39:37.240]  Мап?
[01:39:37.240 --> 01:39:39.240]  Мап это две специализации, все.
[01:39:43.240 --> 01:39:45.240]  Применяет
[01:39:45.240 --> 01:39:47.240]  метафункцию каждому элементу списка.
[01:39:47.240 --> 01:39:49.240]  К нилу он не применяется.
[01:39:49.240 --> 01:39:51.240]  Ну к нилу будет
[01:39:51.240 --> 01:39:53.240]  тоже нил.
[01:39:53.240 --> 01:39:55.240]  Ну да.
[01:39:55.240 --> 01:39:57.240]  Но к пустому множеству
[01:39:57.240 --> 01:39:59.240]  применить функцию, это
[01:39:59.240 --> 01:40:01.240]  будет все еще пустое множество
[01:40:01.240 --> 01:40:03.240]  по элементное применение функции.
[01:40:03.240 --> 01:40:05.240]  А по элементным?
[01:40:05.240 --> 01:40:07.240]  Да.
[01:40:07.240 --> 01:40:09.240]  Ну,
[01:40:09.240 --> 01:40:11.240]  я думаю,
[01:40:11.240 --> 01:40:13.240]  что это все еще
[01:40:13.240 --> 01:40:15.240]  будет пустое множество
[01:40:15.240 --> 01:40:17.240]  по элементам.
[01:40:17.240 --> 01:40:19.240]  Надеюсь.
[01:40:19.240 --> 01:40:21.240]  Мы не работаем.
[01:40:21.240 --> 01:40:23.240]  Сейчас.
[01:40:23.240 --> 01:40:25.240]  Как закомпетить?
[01:40:25.240 --> 01:40:27.240]  Так, это вы вставили, да?
[01:40:27.240 --> 01:40:29.240]  Имплементация.
[01:40:33.240 --> 01:40:35.240]  Так, ну,
[01:40:35.240 --> 01:40:37.240]  что вы пытаетесь делать?
[01:40:37.240 --> 01:40:39.240]  Пытаемся сделать...
[01:40:39.240 --> 01:40:41.240]  получается
[01:40:41.240 --> 01:40:43.240]  бабло от
[01:40:43.240 --> 01:40:45.240]  функции.
[01:40:51.240 --> 01:40:53.240]  Как бы да.
[01:40:53.240 --> 01:40:55.240]  У вас два случая есть.
[01:40:55.240 --> 01:40:57.240]  Либо список дали пустой, либо не пустой.
[01:40:57.240 --> 01:40:59.240]  То, что у вас три
[01:40:59.240 --> 01:41:01.240]  специализации, это странно.
[01:41:01.240 --> 01:41:03.240]  Я говорю, что так не надо.
[01:41:03.240 --> 01:41:05.240]  Ой, куда делось? Что произошло?
[01:41:07.240 --> 01:41:09.240]  Нет, у вас
[01:41:09.240 --> 01:41:11.240]  Мап импл есть главная специализация.
[01:41:11.240 --> 01:41:13.240]  Вот частичная специализация номер 1,
[01:41:13.240 --> 01:41:15.240]  частичная специализация номер 2.
[01:41:15.240 --> 01:41:17.240]  Я говорю, что главную
[01:41:17.240 --> 01:41:19.240]  просто надо убрать. Ой.
[01:41:19.240 --> 01:41:21.240]  А вот так, просто
[01:41:21.240 --> 01:41:23.240]  без всего оставить.
[01:41:29.240 --> 01:41:31.240]  Вот тут typeName надо приписывать, да?
[01:41:31.240 --> 01:41:33.240]  Плюсы странный язык.
[01:41:33.240 --> 01:41:35.240]  Когда вы пишете шаблон два двуи точия
[01:41:35.240 --> 01:41:37.240]  названия чего-то,
[01:41:37.240 --> 01:41:39.240]  он думает, что это переменная или функция,
[01:41:39.240 --> 01:41:41.240]  а то, что вы подразумеваете type,
[01:41:41.240 --> 01:41:43.240]  вот надо явно было прописать.
[01:41:43.240 --> 01:41:45.240]  Ошибка к импиляции только в этом месте
[01:41:45.240 --> 01:41:47.240]  тут была.
[01:41:49.240 --> 01:41:51.240]  Так, ну и два случая.
[01:41:51.240 --> 01:41:53.240]  Либо в tail
[01:41:53.240 --> 01:41:55.240]  есть cons от head и tail.
[01:41:55.240 --> 01:41:57.240]  Тогда мы применяем
[01:41:57.240 --> 01:41:59.240]  f к head, кладем в cons,
[01:41:59.240 --> 01:42:01.240]  а tail запускаемся рекурсивно.
[01:42:01.240 --> 01:42:03.240]  Либо у нас был нил.
[01:42:03.240 --> 01:42:05.240]  Тогда и результат нил.
[01:42:05.240 --> 01:42:07.240]  Должно
[01:42:07.240 --> 01:42:09.240]  работать.
[01:42:09.240 --> 01:42:11.240]  Почему не работает?
[01:42:15.240 --> 01:42:17.240]  Потому что вы...
[01:42:17.240 --> 01:42:19.240]  Короче, это очень смешно.
[01:42:19.240 --> 01:42:21.240]  Что не хватает в этой строчке?
[01:42:25.240 --> 01:42:27.240]  Type.
[01:42:29.240 --> 01:42:31.240]  Все, теперь все работает.
[01:42:33.240 --> 01:42:35.240]  То есть вы на самом деле справились, но вот это
[01:42:35.240 --> 01:42:37.240]  легко забыть, type name и
[01:42:37.240 --> 01:42:39.240]  type дописать и да.
[01:42:39.240 --> 01:42:41.240]  Бывало у меня такое, что
[01:42:41.240 --> 01:42:43.240]  я часто дебажил это и только потом
[01:42:43.240 --> 01:42:45.240]  понял, что я дурак.
[01:42:47.240 --> 01:42:49.240]  Так, ну что, кажется у нас вообще
[01:42:49.240 --> 01:42:51.240]  все получилось сделать в целом.
[01:42:51.240 --> 01:42:53.240]  Хоть как-то.
[01:43:05.240 --> 01:43:07.240]  Так, ну что?
[01:43:19.240 --> 01:43:21.240]  Давайте
[01:43:21.240 --> 01:43:23.240]  поднимите руки, если вы все еще
[01:43:23.240 --> 01:43:25.240]  редачите что-то по спискам типов.
[01:43:25.240 --> 01:43:27.240]  Вот два человека точно
[01:43:27.240 --> 01:43:29.240]  готовы еще
[01:43:29.240 --> 01:43:31.240]  копаться с онпаком.
[01:43:31.240 --> 01:43:33.240]  Все остальные, кажется, уже нет.
[01:43:33.240 --> 01:43:35.240]  Что-то написали, если
[01:43:35.240 --> 01:43:37.240]  хотели, если не хотели, то
[01:43:37.240 --> 01:43:39.240]  ну очень жаль.
[01:43:39.240 --> 01:43:41.240]  Да.
[01:43:45.240 --> 01:43:47.240]  Length of tail.
[01:43:51.240 --> 01:43:53.240]  Type of specialized
[01:43:53.240 --> 01:43:55.240]  non-type template argument
[01:43:55.240 --> 01:43:57.240]  depends on the template
[01:43:57.240 --> 01:43:59.240]  параметр.
[01:43:59.240 --> 01:44:01.240]  О,
[01:44:01.240 --> 01:44:03.240]  потому что он так не умеет.
[01:44:05.240 --> 01:44:07.240]  Он не может как бы
[01:44:07.240 --> 01:44:09.240]  распарсить вот этот вот
[01:44:09.240 --> 01:44:11.240]  процесс вычисления этого значения.
[01:44:17.240 --> 01:44:19.240]  Вообще, конечно, мог бы он это понимать,
[01:44:19.240 --> 01:44:21.240]  но кажется, так просто не умеет.
[01:44:25.240 --> 01:44:27.240]  Нет, он вам
[01:44:27.240 --> 01:44:29.240]  говорит что, что
[01:44:29.240 --> 01:44:31.240]  он будет пытаться
[01:44:31.240 --> 01:44:33.240]  ну вообще, что такое синтаксе значит?
[01:44:33.240 --> 01:44:35.240]  Это в выведе, что первая
[01:44:35.240 --> 01:44:37.240]  штука была tail, а второй
[01:44:37.240 --> 01:44:39.240]  аргумент был равен длине
[01:44:39.240 --> 01:44:41.240]  этого tail, но он
[01:44:41.240 --> 01:44:43.240]  начинает пытаться этот tail выводить
[01:44:43.240 --> 01:44:45.240]  оттуда тоже и как-то это сопоставлять,
[01:44:45.240 --> 01:44:47.240]  и, кажется, сломается в этот момент.
[01:44:51.240 --> 01:44:53.240]  Ну, то есть так нельзя, короче.
[01:44:57.240 --> 01:44:59.240]  Да.
[01:44:59.240 --> 01:45:01.240]  Специализироваться по номеру,
[01:45:01.240 --> 01:45:03.240]  который длина списка,
[01:45:03.240 --> 01:45:05.240]  это плохо.
[01:45:05.240 --> 01:45:07.240]  Ребят, давайте общую мысль
[01:45:07.240 --> 01:45:09.240]  скажу по поводу perf.
[01:45:09.240 --> 01:45:11.240]  Вы же любите perf, вы на плюсах
[01:45:11.240 --> 01:45:13.240]  пишете. Вот perf в compile
[01:45:13.240 --> 01:45:15.240]  time он тоже важен.
[01:45:15.240 --> 01:45:17.240]  В чем измеряется в compile time
[01:45:17.240 --> 01:45:19.240]  perf? Ну вот в
[01:45:19.240 --> 01:45:21.240]  run time в тактах процессора,
[01:45:21.240 --> 01:45:23.240]  а в compile time, когда мы вот таким
[01:45:23.240 --> 01:45:25.240]  занимаемся, на самом деле в
[01:45:25.240 --> 01:45:27.240]  инстанциациях.
[01:45:27.240 --> 01:45:29.240]  И вот все, что вы реализовали,
[01:45:29.240 --> 01:45:31.240]  чем меньше инстанциация оно делает,
[01:45:31.240 --> 01:45:33.240]  шаблонов разных, тем лучше.
[01:45:33.240 --> 01:45:35.240]  Если вы там на каждой
[01:45:37.240 --> 01:45:39.240]  если вы в своей рекурсии
[01:45:39.240 --> 01:45:41.240]  на каждом уровне запускаете
[01:45:41.240 --> 01:45:43.240]  шаблон length, то что будет?
[01:45:43.240 --> 01:45:45.240]  Будет от
[01:45:45.240 --> 01:45:47.240]  n квадрат инстанциаций.
[01:45:51.240 --> 01:45:53.240]  Так tail у тебя разный на каждой
[01:45:53.240 --> 01:45:55.240]  суффикс.
[01:45:55.240 --> 01:45:57.240]  Но чтобы понять, какую специализацию
[01:45:57.240 --> 01:45:59.240]  выбрать, надо и размер посчитать, правда?
[01:46:07.240 --> 01:46:09.240]  Чтобы посчитать
[01:46:09.240 --> 01:46:11.240]  размер этого списка, сколько нужно
[01:46:11.240 --> 01:46:13.240]  операций? Линия.
[01:46:13.240 --> 01:46:15.240]  Для следующего элемента сколько? Линия.
[01:46:17.240 --> 01:46:19.240]  Хорошо, пойдем с конца.
[01:46:19.240 --> 01:46:21.240]  Спасет ли ваше каширование?
[01:46:21.240 --> 01:46:23.240]  Не знаю.
[01:46:23.240 --> 01:46:25.240]  Давайте не думать, что есть каширование,
[01:46:25.240 --> 01:46:27.240]  а просто пытаться писать
[01:46:27.240 --> 01:46:29.240]  код с как можно меньше инстанциацией.
[01:46:31.240 --> 01:46:33.240]  Кажется,
[01:46:33.240 --> 01:46:35.240]  это просто такое, да, ладно,
[01:46:35.240 --> 01:46:37.240]  ваша правда, здесь не будет квадрата,
[01:46:37.240 --> 01:46:39.240]  здесь будет непонятно что,
[01:46:39.240 --> 01:46:41.240]  возможно и линия.
[01:46:43.240 --> 01:46:45.240]  Может и нет.
[01:46:45.240 --> 01:46:47.240]  Ладно,
[01:46:47.240 --> 01:46:49.240]  это все не важно, общая мысль понятна,
[01:46:49.240 --> 01:46:51.240]  меньше инстанциаций лучше,
[01:46:51.240 --> 01:46:53.240]  не надо делать там квадрат инстанциаций,
[01:46:53.240 --> 01:46:55.240]  лучше линию, лучше еще
[01:46:55.240 --> 01:46:57.240]  меньше, но меньше не получается
[01:46:57.240 --> 01:46:59.240]  обычно.
[01:47:05.240 --> 01:47:07.240]  Смотри, тут
[01:47:07.240 --> 01:47:09.240]  про читаемости речи уже
[01:47:09.240 --> 01:47:11.240]  не идет.
[01:47:11.240 --> 01:47:13.240]  Никто сюда смотреть не должен.
[01:47:15.240 --> 01:47:17.240]  Да, write only
[01:47:17.240 --> 01:47:19.240]  code.
[01:47:21.240 --> 01:47:23.240]  В моей
[01:47:23.240 --> 01:47:25.240]  компании, я думаю, есть
[01:47:25.240 --> 01:47:27.240]  максимум пара-тройка человек,
[01:47:27.240 --> 01:47:29.240]  которые в таком готовы
[01:47:29.240 --> 01:47:31.240]  разбираться, заниматься и смотреть,
[01:47:31.240 --> 01:47:33.240]  что это такое.
[01:47:33.240 --> 01:47:35.240]  Мне кажется, где угодно
[01:47:35.240 --> 01:47:37.240]  будет максимум 1-2-3 человека,
[01:47:37.240 --> 01:47:39.240]  которые таким заниматься любят.
[01:47:39.240 --> 01:47:41.240]  Это не правильный вопрос,
[01:47:41.240 --> 01:47:43.240]  но какие техники
[01:47:43.240 --> 01:47:45.240]  компайл-тайм-учления
[01:47:45.240 --> 01:47:47.240]  где можно выделить
[01:47:47.240 --> 01:47:49.240]  компайл-тайм-учлений?
[01:47:51.240 --> 01:47:53.240]  Ну компайл-тайм-учлений
[01:47:53.240 --> 01:47:55.240]  на самом деле много где есть,
[01:47:55.240 --> 01:47:57.240]  как бы...
[01:47:57.240 --> 01:47:59.240]  Ну,
[01:47:59.240 --> 01:48:01.240]  что?
[01:48:03.240 --> 01:48:05.240]  Не знаю,
[01:48:05.240 --> 01:48:07.240]  не знаю.
[01:48:07.240 --> 01:48:09.240]  Перезагрузилась, все заработало.
[01:48:09.240 --> 01:48:11.240]  В репетитории есть куча
[01:48:11.240 --> 01:48:13.240]  ссылок, и в частности
[01:48:13.240 --> 01:48:15.240]  они здесь, чтобы показать вам,
[01:48:15.240 --> 01:48:17.240]  где это вообще может быть нужно.
[01:48:19.240 --> 01:48:21.240]  Сейчас, где
[01:48:21.240 --> 01:48:23.240]  ссылка?
[01:48:25.240 --> 01:48:27.240]  Например, вот, LibUnifex,
[01:48:27.240 --> 01:48:29.240]  замечательная библиотека, которая
[01:48:29.240 --> 01:48:31.240]  в итоге была принята
[01:48:31.240 --> 01:48:33.240]  в это,
[01:48:33.240 --> 01:48:35.240]  ну в стандарт почти, скоро
[01:48:35.240 --> 01:48:37.240]  будет принята.
[01:48:37.240 --> 01:48:39.240]  Type-лист,
[01:48:39.240 --> 01:48:41.240]  ой, Type-листы.
[01:48:41.240 --> 01:48:43.240]  И пошло-поехало.
[01:48:43.240 --> 01:48:45.240]  Ну, то есть,
[01:48:45.240 --> 01:48:47.240]  просто в какой-то момент, делая сложные
[01:48:47.240 --> 01:48:49.240]  библиотеки, внезапно оказывается,
[01:48:49.240 --> 01:48:51.240]  что вот это вот нужно где-то, и начинается
[01:48:51.240 --> 01:48:53.240]  цирк совсем вот этим вот.
[01:48:53.240 --> 01:48:55.240]  Ну, тут не так много
[01:48:55.240 --> 01:48:57.240]  операций, конечно, всегда стараются
[01:48:57.240 --> 01:48:59.240]  минимизировать вот такой беспредел,
[01:48:59.240 --> 01:49:01.240]  но оно бывает.
[01:49:05.240 --> 01:49:07.240]  Стрим?
[01:49:07.240 --> 01:49:09.240]  Ну,
[01:49:11.240 --> 01:49:13.240]  это какой-то стрим
[01:49:13.240 --> 01:49:15.240]  каких-то объектов, мы не знаем каких,
[01:49:15.240 --> 01:49:17.240]  но можем что-то делать. Не знаю.
[01:49:17.240 --> 01:49:19.240]  Ну, там просто все очень
[01:49:19.240 --> 01:49:21.240]  шаблонное, а чтобы убрать шаблоны,
[01:49:21.240 --> 01:49:23.240]  нужен TypeRager, который у нас будет в один
[01:49:23.240 --> 01:49:25.240]  из следующих разов, поэтому пока
[01:49:25.240 --> 01:49:27.240]  отложим.
[01:49:27.240 --> 01:49:29.240]  Помимо Unifex,
[01:49:29.240 --> 01:49:31.240]  кажется, в Function 2 что-то тоже было
[01:49:31.240 --> 01:49:33.240]  близкое на списке типов,
[01:49:33.240 --> 01:49:35.240]  только оно так не называется.
[01:49:37.240 --> 01:49:39.240]  Ну, в целом, вот просто какую-то библиотеку
[01:49:39.240 --> 01:49:41.240]  открыл, и здесь все обмазано каким-то
[01:49:41.240 --> 01:49:43.240]  лютыми шаблонами, и
[01:49:43.240 --> 01:49:45.240]  кажется, была
[01:49:45.240 --> 01:49:47.240]  метапрога, прям метапрога,
[01:49:47.240 --> 01:49:49.240]  что вычисление в Compile Time.
[01:49:53.240 --> 01:49:55.240]  Ну,
[01:49:55.240 --> 01:49:57.240]  ну,
[01:49:57.240 --> 01:49:59.240]  ну,
[01:49:59.240 --> 01:50:01.240]  ну,
[01:50:01.240 --> 01:50:03.240]  Кажется,
[01:50:05.240 --> 01:50:07.240]  вот это, примерно,
[01:50:07.240 --> 01:50:09.240]  оно. Какие-то Function
[01:50:09.240 --> 01:50:11.240]  Trades пошли.
[01:50:11.240 --> 01:50:13.240]  View,
[01:50:13.240 --> 01:50:17.240]  Invoker. Ну,
[01:50:17.240 --> 01:50:19.240]  вот похоже, что это оно.
[01:50:21.240 --> 01:50:23.240]  Так, в общем, любые сложные
[01:50:23.240 --> 01:50:25.240]  библиотеки большие, где есть шаблоны,
[01:50:25.240 --> 01:50:27.240]  если порыться, там ты найдешь
[01:50:27.240 --> 01:50:29.240]  вычисление в Compile Time в том или ином
[01:50:29.240 --> 01:50:35.960]  видео. Тут есть некоторое количество ссылок.
[01:50:40.800 --> 01:50:46.160]  Кстати, не хватает ссылок. Надо в презентации на сегодня есть ссылка. Так,
[01:50:46.160 --> 01:50:49.720]  давайте считать, что мы все закончили на сегодня с написанием кода. Как вам? И
[01:50:49.720 --> 01:50:58.400]  чуть послушаем сказочек. Голова болит от кода? Давайте откроем окна и
[01:50:58.400 --> 01:51:04.960]  проветрим. Голова перестанет болеть. Я отвечаю, что отдыхательный. А перерыв сделать надо.
[01:51:04.960 --> 01:51:14.080]  Перерыв сделать надо. Давайте в 20 минут продолжим кусок, который успеем, я расскажу.
