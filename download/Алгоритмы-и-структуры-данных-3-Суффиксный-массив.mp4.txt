[00:00.000 --> 00:03.820]  Leave the room
[00:30.000 --> 00:44.000]  мы сегодня говорим про суеткостный массив, поднимите, пожалуйста, лапки тел,
[00:44.000 --> 00:48.000]  у кого была населена суеткостная массив, чтобы я понимал, что сейчас происходит.
[00:48.000 --> 00:59.000]  так, ну что ж, давайте смотреть пусть у нас есть строчка.
[00:59.000 --> 01:06.000]  наша задача отсортировать все суффиксы этой строки.
[01:06.000 --> 01:10.000]  пустой суффикс, наверное, мы не будем рассматривать.
[01:10.000 --> 01:13.000]  все такие суффиксы, все вот такие строчки, рассмотрим.
[01:13.000 --> 01:18.000]  и мне нужно их отсортировать в лексикратическом порядке.
[01:18.000 --> 01:22.000]  ну понятно, поскольку все эти строчки разные длины, значит они все попарно различны,
[01:22.000 --> 01:27.000]  значит на них однозначно поделен порядок строгого возрастания.
[01:27.000 --> 01:30.000]  вот такое, значит, определение.
[01:30.000 --> 01:54.000]  суффиксным массивом вот этой строки, строки с, называется перестановка
[01:54.000 --> 02:04.000]  п0, п1, и так далее, по n-1, такая, что суффиксы, начинающие с позиции п0,
[02:04.000 --> 02:11.000]  меньше суффиксы, начинающие с позиции п1, и так далее, меньше суффиксы, начинающие с позиции pn-1.
[02:11.000 --> 02:20.000]  ну давайте я напишу вот так вот сначала.
[02:20.000 --> 02:27.000]  если я использую диапресс с верхним индексом g, это, собственно, суффикс начинающий с g-той позиции.
[02:33.000 --> 02:36.000]  простое определение, просто строгая суффикс.
[02:51.000 --> 02:56.000]  вот, наша мечта найти такую перестановку.
[02:56.000 --> 02:59.000]  да, такие все у нас мечты, конечно.
[02:59.000 --> 03:04.000]  давайте сразу же определим еще все, что нам надо, давайте еще определим массив lcp.
[03:04.000 --> 03:08.000]  ну не столько определения, сколько обозначения, ну определение.
[03:08.000 --> 03:14.000]  значит вместе с вот этой перестановкой я хочу насчитать массив lcp.
[03:14.000 --> 03:18.000]  я вот так и буду называть lcp, ну во-первых, почему называется lcp?
[03:18.000 --> 03:25.000]  потому что london без common prefix на lcp.
[03:25.000 --> 03:30.000]  двух строк, но это буквально длина их наибольшего общего префикса.
[03:31.000 --> 03:41.000]  двух строк, но это длина их наибольшего общего префикса.
[03:46.000 --> 03:52.000]  если есть с кем две строчки вот такая и вот такая, то как посчитать их lcp?
[03:52.000 --> 03:58.000]  ну давайте просто вот встанем указательным сначала строк, будем идти направо, пока не найдем первое различие.
[03:58.000 --> 04:06.000]  Вот эти два символа равны, то есть первые символы равны идем дальше, следующие символы равны, следующие, и так далее, и так далее, вплоть до какого-то первого различия.
[04:06.000 --> 04:12.000]  Вот если я вижу, что здесь символы отличаются, значит LCP вот он, а вот он LCP.
[04:12.000 --> 04:13.000]  Не включается.
[04:13.000 --> 04:18.000]  Да, ну конечно, если они различны, то они в LCP не входят.
[04:18.000 --> 04:25.000]  Вот, ну и давайте посчитаем LCP вот на этом массиве строк.
[04:25.000 --> 04:43.000]  Чтобы значение LCP IT, это собственно длина лонг-строман-плефикса, да, то есть длина наибольшего общего префикса, для строк, внимание, SPI и SPI плюс один.
[04:44.000 --> 04:52.000]  То есть вот в том порядке, в котором они располагаются в суфиксном массиве, в этом порядке между парами соседей я считаю LCP.
[04:52.000 --> 04:55.000]  То есть вот давайте я сюда вернусь, да, на картинку.
[04:55.000 --> 05:04.000]  Вот есть у меня сортировка всех суфиксов, я посчитаю LCP вот этой пары, LCP вот этой пары, и так далее LCP вот этой пары, то есть между всеми соседями.
[05:05.000 --> 05:15.000]  Да, не между всеми парами вообще, или не между парами, скажем, ну там, S0 и S1, а именно вот в этом порядке SP0 и SPI, SP1 и SP2 и так далее.
[05:15.000 --> 05:19.000]  Именно в этом порядке, как они располагаются, между всеми соседями я нахожу LCP.
[05:21.000 --> 05:23.000]  Вот, значит зачем это может быть нужно?
[05:24.000 --> 05:26.000]  Ну, смотрите, простое утверждение.
[05:28.000 --> 05:29.000]  Простое утверждение.
[05:29.000 --> 05:42.000]  Пусть P какое-нибудь LTE равно I, P регистерта равно G, в чем L меньше, чем R.
[05:42.000 --> 06:07.000]  И если у нас LTE не умещено, тогда утверждается, наибольший общий префикс суфиксов, начинающихся в I и в G позиции, есть минимальный среди LCP кадр по всем K от L до R-1.
[06:12.000 --> 06:14.000]  Такое формальное утверждение, картинка.
[06:15.000 --> 06:20.000]  Давайте я сейчас суфиксный массив представлю как, опять-таки картинку, как набор строк.
[06:21.000 --> 06:29.000]  Вот у меня сначала там идет SP0, потом какой-то SP1, SP2 и так далее вплоть до конца.
[06:30.000 --> 06:34.000]  Оно не обязательно самое длинное, в общем, какое-то, да, очередная строка SP-1.
[06:34.000 --> 06:41.000]  Я хочу найти наибольший общий префикс двух каких-то суфиксов ITE и GTE.
[06:42.000 --> 06:47.000]  Ну, давайте скажем, это будет ITE, это будет SITE, где-то там будет SGTE.
[06:48.000 --> 06:53.000]  Я сначала нахожу, где они у меня в перестановке, где они у меня в суфиксном массиве.
[06:54.000 --> 07:02.000]  То есть я нахожу такое L, что SPL это SITE, то есть вот этот суфикс SPL это как раз SITE.
[07:02.000 --> 07:04.000]  То же самое SPL это SGTE.
[07:05.000 --> 07:07.000]  А я нахожу, где они у меня находятся в моем суфмассе.
[07:08.000 --> 07:13.000]  А дальше, чтобы найти их LCP, у меня же нет LCP этих двух суфиксов, у меня есть LCP только между соседними.
[07:14.000 --> 07:16.000]  У меня есть LCP вот этих двух, вот этих двух, вот этих двух и так далее.
[07:17.000 --> 07:19.000]  Так вот я утверждаю, что чтобы найти LCP вот этих двух товарищей,
[07:20.000 --> 07:23.000]  мне нужно найти минимальное среди вот этих LCP, которые у меня на этом отрезке лежат.
[07:24.000 --> 07:27.000]  То есть я рассматриваю все LCP на этом отрезке, беру с них минимальное ответ.
[07:29.000 --> 07:30.000]  Вот.
[07:31.000 --> 07:33.000]  Ну, доказательств здесь очень простое.
[07:34.000 --> 07:38.000]  Так что давайте раньше доказывать как два неравенства.
[07:39.000 --> 07:45.000]  В одну сторону очевидно, понятно, что LCP SITE и SGTE точно больше либо равно, чем этот минимум.
[07:51.000 --> 07:58.000]  Ну, по картинке понятно, потому что давайте я этот как-нибудь минимум отначу за X.
[07:58.000 --> 08:00.000]  Что значит, что минимум равен X?
[08:01.000 --> 08:07.000]  Это значит, что вот на этом промежутке все соседние строки имеют хотя бы первые X одинаковых символов.
[08:08.000 --> 08:10.000]  То есть везде LCP соседей хотя бы X.
[08:11.000 --> 08:16.000]  Значит, если я рассматриваю первый X символу вот в этой строке, то во второй они будут точно такими же X символами.
[08:17.000 --> 08:18.000]  Потому что у них LCP хотя бы X.
[08:19.000 --> 08:20.000]  То же самое между второй строкой и прийти.
[08:21.000 --> 08:24.000]  Здесь LCP хотя бы X, потому что X за минимум.
[08:25.000 --> 08:27.000]  Значит, первые X такие же, как вот здесь везде.
[08:28.000 --> 08:31.000]  Ну и так далее, вплоть до конца, первые X символы в последней строке такие же, как в первой.
[08:32.000 --> 08:35.000]  Поэтому LCP SITE и SGTE будет по крайней мере X.
[08:36.000 --> 08:37.000]  X это минимальность или эффект СТ.
[08:38.000 --> 08:39.000]  Вот.
[08:41.000 --> 08:45.000]  Ну теперь давайте обратно покажем, что не может быть больше.
[08:48.000 --> 08:54.000]  Покажем, что LCP SITE и SGTE не может быть больше, чем X.
[08:54.000 --> 08:55.000]  Вот.
[08:56.000 --> 08:57.000]  От противного.
[09:00.000 --> 09:01.000]  Пусть больше.
[09:04.000 --> 09:05.000]  Пусть это LCP.
[09:07.000 --> 09:08.000]  Хотя бы X плюс один.
[09:10.000 --> 09:16.000]  То есть на этой картинке вот эта строка и эта строка имеют хотя бы X плюс один общий символ.
[09:16.000 --> 09:21.000]  Но при этом где-то на промежутке между ними есть две сосредние строчки, у которых LCP равен только X.
[09:22.000 --> 09:23.000]  Но не X плюс один и не больше.
[09:24.000 --> 09:25.000]  Вот.
[09:26.000 --> 09:27.000]  Ну тогда давайте рассмотримся с тем, что это суффиксный массив.
[09:28.000 --> 09:33.000]  Я утверждаю, что если у меня есть две какие-то строчки, которые начинаются на одинаковые X плюс один символов,
[09:34.000 --> 09:37.000]  то все между ними тоже обязаны начинаться на те же самые X плюс один символов.
[09:38.000 --> 09:40.000]  Почему? Ну давайте я перерисую картинку.
[09:41.000 --> 09:43.000]  Вот есть у меня X плюс один символ.
[09:43.000 --> 09:44.000]  Я перерисую картинку.
[09:45.000 --> 09:47.000]  Вот есть у меня и ты суффикс.
[09:48.000 --> 09:49.000]  Есть и ты суффикс.
[09:50.000 --> 09:54.000]  Вот есть строка между ними какая-то, ну в диапазоне между ними в суффмассе.
[09:55.000 --> 09:59.000]  Вот я утверждаю, что если эти две строки имеют какой-то общий трефис до X плюс один,
[10:00.000 --> 10:01.000]  то он же будет наследоваться и здесь.
[10:02.000 --> 10:03.000]  Ну почему?
[10:04.000 --> 10:07.000]  Пусть первые X плюс один символов здесь отличаются от первых X плюс один символов здесь.
[10:08.000 --> 10:10.000]  То есть когда что-то не совпадает, потом идет что-то другое.
[10:10.000 --> 10:12.000]  Но давайте рассмотрим это первое несовпадение.
[10:13.000 --> 10:17.000]  Так, здесь символ одинаковый, здесь C, здесь C.
[10:18.000 --> 10:19.000]  Пусть здесь какой-нибудь другой символ.
[10:20.000 --> 10:24.000]  Ну если этот символ был бы, например, меньше, чем C, то есть, например, если здесь A, B,
[10:25.000 --> 10:26.000]  то понятное дело у меня некорректный суффикс на массив,
[10:27.000 --> 10:29.000]  потому что тогда этот суффикс явно меньше, чем вот этот.
[10:30.000 --> 10:32.000]  Значит, это должно быть выше, значит, чем этот.
[10:33.000 --> 10:35.000]  Ну а мы с вами знаем, что суффмасса парагнала однозначно.
[10:36.000 --> 10:39.000]  Я сказал, что у меня все строки попарно различны, поэтому перестановка единственна.
[10:40.000 --> 10:42.000]  Значит, этот не может быть здесь, он обязан быть здесь.
[10:43.000 --> 10:44.000]  Потому что здесь больше.
[10:45.000 --> 10:46.000]  Вот, он должен быть выше.
[10:47.000 --> 10:51.000]  Но аналогично симметричной ситуации, если здесь символ больше, чем C, скажем, D,
[10:52.000 --> 10:54.000]  то он должен быть обязательно ниже, чем сжитая.
[10:55.000 --> 10:58.000]  Ну потому что при сравнении у меня есть какой-то общий префикс,
[10:59.000 --> 11:03.000]  а первое отличие в первом отличающем индексе, здесь символ больше, чем здесь.
[11:04.000 --> 11:05.000]  Поэтому строка обязательно должна быть ниже.
[11:06.000 --> 11:11.000]  Противорячься, значит, символ на этой позиции обязан совпадать с C,
[11:12.000 --> 11:16.000]  то есть если у этих двух строк есть общий префикс, то он же наследуется во все строки между ними.
[11:17.000 --> 11:19.000]  Ну поэтому такого быть не может.
[11:20.000 --> 11:21.000]  Согласны?
[11:22.000 --> 11:24.000]  А индексы I и J они снизу должны быть?
[11:25.000 --> 11:27.000]  То есть это возвращайные?
[11:28.000 --> 11:29.000]  Да, да.
[11:30.000 --> 11:32.000]  Но еще раз, верхний индекс, это не после перестановки,
[11:32.000 --> 11:35.000]  верхний индекс, значит, суффикс начинается с этой позиции.
[11:38.000 --> 11:39.000]  А, все я понял.
[11:40.000 --> 11:42.000]  То есть я нашел, где они находятся в моем суфмассе,
[11:43.000 --> 11:45.000]  то есть вот в каком-то месте у меня находится икле суфикс, в каком-то месте житых суфикс.
[11:46.000 --> 11:47.000]  Я беру минимум на треске между ними.
[11:48.000 --> 11:51.000]  Но чтобы взять минимум на треске между ними, мне нужно знать, что это за индекс в суфмассе.
[11:52.000 --> 11:54.000]  Поэтому мне нужна вот эта перестановка P.
[11:55.000 --> 11:56.000]  Вот, вроде показали.
[11:57.000 --> 11:58.000]  Вроде показали.
[11:59.000 --> 12:03.000]  Получается, вывод какой из этого?
[12:04.000 --> 12:06.000]  Что если нам надо, мы можем посчитать LCP любых двух суффиксов,
[12:07.000 --> 12:10.000]  например, за единицу, если мы заранее на массив LCP построим спаррстейбл.
[12:12.000 --> 12:14.000]  А если считать, что наша строка меняться не будет,
[12:15.000 --> 12:17.000]  если строка меняться не будет,
[12:18.000 --> 12:20.000]  то мы можем посчитать массив LCP,
[12:21.000 --> 12:23.000]  мы можем построить на нем спаррстейбл, на минимум,
[12:24.000 --> 12:27.000]  и дальше для подсчета LCP двух суффиксов просто искать минимум на адрес.
[12:28.000 --> 12:29.000]  А спаррстейбл делать за единицу.
[12:30.000 --> 12:31.000]  Давайте напишем, что вывод.
[12:32.000 --> 12:34.000]  А с помощью спаррстейбл
[12:43.000 --> 12:49.000]  можем находить LCP двух суффиксов, LCP вольных,
[12:50.000 --> 12:53.000]  LCP WG2, за единицу на допрос.
[12:59.000 --> 13:02.000]  Ну, это все предположено, что мы все построим, смотри.
[13:02.000 --> 13:30.000]  Зачем нам может понадобиться находить наибольший общий префикс двух суффиксов?
[13:31.000 --> 13:34.000]  Ну, например, чтобы решать задачу о проверке равности двух подстрок.
[13:35.000 --> 13:36.000]  Задача.
[13:37.000 --> 13:39.000]  Есть большая строка S,
[13:40.000 --> 13:45.000]  к ней поступают запросы, задаваемые индексами L1, L1, L2, L2.
[13:46.000 --> 13:48.000]  Нам надо проверить, равны ли эти строки,
[13:49.000 --> 13:51.000]  ну, в общем, равны ли эти подстроки просто как строки.
[13:52.000 --> 13:54.000]  Проверка подстрока равности.
[14:01.000 --> 14:02.000]  Вот.
[14:03.000 --> 14:04.000]  Раньше мы имели это только хэшами делать,
[14:05.000 --> 14:08.000]  да, мы там считали все хэши всех префиксов,
[14:09.000 --> 14:11.000]  и потом хэши подстроки мы можем вычислить за единицу,
[14:12.000 --> 14:14.000]  ну, если как бы сравнить хэши подстрок,
[14:15.000 --> 14:17.000]  если хэши равны, то мы видим, что они равны, если не равны, то не равны.
[14:18.000 --> 14:22.000]  А теперь мы можем детерминированно с помощью суффмасса это делать без ошибок.
[14:23.000 --> 14:27.000]  Ну, очень просто, потому что если есть как бы две подстроки, давайте найдем LCP вот таких двух суффиксов,
[14:27.000 --> 14:30.000]  да, ну и проверим, что все вот этот символы не совпадают.
[14:34.000 --> 14:36.000]  Вот, значит, как это сделать чуть точнее.
[14:37.000 --> 14:43.000]  Ну, во-первых, если у них различные длины, давайте осторожно скажем, что они не равны,
[14:46.000 --> 14:49.000]  return null какой-нибудь, чтобы подстройки не равны.
[14:58.000 --> 15:03.000]  Иначе они имеют одинаковую длину, давайте найдем LCP соответствующих двух суффиксов,
[15:04.000 --> 15:07.000]  да, вот суффиксы начинаются с L1 и суффиксы начинаются с L2.
[15:08.000 --> 15:13.000]  И если их LCP хотя бы длина этой строки, да, которая одинаковая, то значит они равны.
[15:16.000 --> 15:20.000]  Давайте так напишу, я мастер тренажных операторов.
[15:21.000 --> 15:29.000]  Return LCP SL1 SL2 больше или равно, чем длина строки?
[15:30.000 --> 15:32.000]  Вопрос yes, а значит no.
[15:37.000 --> 15:38.000]  Круто.
[15:39.000 --> 15:40.000]  Да, спасибо.
[15:41.000 --> 15:42.000]  Согласны?
[15:43.000 --> 15:44.000]  Не читаем?
[15:45.000 --> 15:46.000]  Ну, ничего, справитесь.
[15:47.000 --> 15:48.000]  Я вас вижу.
[15:48.000 --> 15:49.000]  Я вас вижу.
[15:50.000 --> 15:51.000]  Если я смеюсь, то вы точно сможете.
[15:52.000 --> 15:53.000]  Вот, ну вроде все.
[15:54.000 --> 15:58.000]  Вот, значит у нас есть хотя бы какая-то мотивация, зачем нам надо искать UFMAS,
[15:59.000 --> 16:00.000]  соответственно не у массива LCP.
[16:01.000 --> 16:04.000]  Ну, давайте теперь перейдем, собственно, к алгоритму, который находит суффиксные массивы.
[16:04.000 --> 16:14.000]  У нас же где начинается строка L1, он не обязательно попадает с позиции L2.
[16:15.000 --> 16:24.000]  Да, ну смотрите, когда я пишу S с верхним каким-то индексом, это просто суффикс начинается с позиции L1.
[16:25.000 --> 16:26.000]  Это суффикс начинается с позиции L2.
[16:27.000 --> 16:30.000]  Вот если я умею считать такой LCP, если мы больше равно, то мы знаем ответ.
[16:30.000 --> 16:31.000]  Но как мы считаем такой LCP?
[16:32.000 --> 16:34.000]  Чтобы посчитать LCP двух суффиксов, я на самом деле делаю вот это.
[16:35.000 --> 16:36.000]  Я сначала нахожу, где они лежат в суффмассе.
[16:37.000 --> 16:38.000]  Вот как здесь, да, я сделал.
[16:39.000 --> 16:40.000]  Вот у меня есть вот это и этажи.
[16:41.000 --> 16:42.000]  Считайте это и этажи.
[16:43.000 --> 16:44.000]  Я сначала нахожу, где они лежат в суффмассе.
[16:45.000 --> 16:47.000]  Как-то, но это несложно сделать упражнение.
[16:48.000 --> 16:49.000]  Я нахожу, где они лежат в суффмассе.
[16:50.000 --> 16:51.000]  И дальше на этом отрезке нахожу минимум.
[16:52.000 --> 16:53.000]  Вот.
[16:54.000 --> 16:56.000]  Ну, то есть как бы я считаю, что у меня уже есть процедура, вот я ее здесь описал,
[16:56.000 --> 16:59.000]  у меня уже есть процедура, находящая LCP двух произвольных суффиксов.
[17:00.000 --> 17:02.000]  Если у меня суффиксы заданы просто своими началами,
[17:03.000 --> 17:04.000]  в каких индексах они начинаются,
[17:05.000 --> 17:07.000]  то вот тут я описывал, что мне нужно сначала найти,
[17:08.000 --> 17:09.000]  где они лежат в суффмассе, взять минимум на отрезке.
[17:10.000 --> 17:12.000]  Есть такая процедура, я ее здесь просто использую.
[17:26.000 --> 17:27.000]  Так, хорошо.
[17:41.000 --> 17:42.000]  Ну, что будем делать?
[17:43.000 --> 17:44.000]  Первое действие такое.
[17:45.000 --> 17:48.000]  Давайте припишем к нашей строке символ, который меньше всех символов алфавита.
[17:49.000 --> 17:51.000]  Ну, якобы у нас сегодняшний день.
[17:52.000 --> 17:53.000]  Рисую решетку.
[17:53.000 --> 17:57.000]  Предполагаю, что у меня строка содержит только, скажем, маленькие латинские буквы,
[17:58.000 --> 18:01.000]  тогда приписывание решетки это как раз символ, который меньше всех символов строки.
[18:02.000 --> 18:03.000]  Вот.
[18:04.000 --> 18:06.000]  Давайте теперь считать, я забываю, что у меня была исходная строка S,
[18:07.000 --> 18:08.000]  вот теперь это S.
[18:09.000 --> 18:10.000]  Я считаю, что строка S заканчивается символом решетки,
[18:11.000 --> 18:12.000]  который меньше всех остальных символов.
[18:14.000 --> 18:16.000]  И давайте сразу скажем, что мы нашу строку зациклим.
[18:24.000 --> 18:25.000]  Вот.
[18:26.000 --> 18:30.000]  То есть, если меня, скажем, попросят посчитать, ну, точнее вывести,
[18:31.000 --> 18:34.000]  под строку, начинающую здесь имеющую какую-то супербольшую длину,
[18:35.000 --> 18:36.000]  то под строка устроено так.
[18:37.000 --> 18:38.000]  Я сначала печатаю вот эти символы, потом, если надо,
[18:39.000 --> 18:41.000]  телепортируюсь в начало и продолжаю печатать в начало.
[18:42.000 --> 18:45.000]  То есть, я ее зациклю, да, и символ, следующий, за последним, это нулевой.
[18:48.000 --> 18:49.000]  Вот.
[18:53.000 --> 18:54.000]  План такой.
[18:55.000 --> 18:58.000]  И дальше мы еще будем сейчас работать не только с суффиксами,
[18:59.000 --> 19:00.000]  а будем работать со всеми подстроками.
[19:01.000 --> 19:02.000]  Ну, соответственно, с циклическими подстроками.
[19:03.000 --> 19:06.000]  Будем работать с циклическими подстроками вот этой новой строки S.
[19:11.000 --> 19:16.000]  С циклическими подстроками строки S.
[19:17.000 --> 19:20.000]  Тут циклические в том плане, что строка есть зациклена,
[19:20.000 --> 19:22.000]  и вот это вот, да, вот то, что я здесь нарисовал, вот такая вот строка.
[19:23.000 --> 19:24.000]  Вот такая.
[19:25.000 --> 19:26.000]  Это подстрока считается.
[19:27.000 --> 19:28.000]  Хоть она и не подстрока исходной строки, может быть,
[19:29.000 --> 19:30.000]  но вот именно, что зацикленность.
[19:31.000 --> 19:32.000]  Если все зациклит, то это подстрока.
[19:33.000 --> 19:34.000]  Вот.
[19:35.000 --> 19:36.000]  Значит, почему это нам ничего сильно не ломает?
[19:37.000 --> 19:39.000]  Ну, смотрите, потому что, если, например, у меня получится посортировать
[19:40.000 --> 19:44.000]  все циклические сдвиги, скажем, такой строки,
[19:45.000 --> 19:48.000]  то я однозначно могу восстановить суффиксный массив.
[19:49.000 --> 19:50.000]  Давайте примерку нарисуем.
[19:51.000 --> 19:52.000]  Вот есть, скажем, строка ABATSABA.
[19:55.000 --> 19:58.000]  Как для нее выглядит?
[19:59.000 --> 20:02.000]  Давайте нарисуем сортировку всех циклических ее сдвигов.
[20:03.000 --> 20:05.000]  Ну, раз решетка самый маленький символ,
[20:06.000 --> 20:08.000]  то, понятное дело, начинается все будет с нее,
[20:09.000 --> 20:10.000]  а минимальная строка, минимальная циклическая сдвигательность строки
[20:11.000 --> 20:12.000]  начинается с решетки.
[20:13.000 --> 20:14.000]  Значит, решетка ABATSABA.
[20:15.000 --> 20:16.000]  Так.
[20:17.000 --> 20:19.000]  Знаешь, какая строка будет следующей?
[20:20.000 --> 20:21.000]  Ну, видимо, вот эта, потому что А-решетка,
[20:22.000 --> 20:23.000]  это самая выгодная,
[20:24.000 --> 20:26.000]  А-решетка ABATSABA.
[20:27.000 --> 20:29.000]  Дальше, видимо, ABATSABA-решетка.
[20:37.000 --> 20:39.000]  ABATSABA-решетка.
[20:44.000 --> 20:49.000]  BA-решетка ABATSABA.
[20:50.000 --> 20:53.000]  ABATSABA-решетка ABATSABA.
[20:54.000 --> 20:55.000]  Да, спасибо, забыл.
[20:56.000 --> 20:57.000]  Тогда не пометь.
[20:58.000 --> 20:59.000]  Ладно, тогда не буду все писать.
[21:00.000 --> 21:01.000]  ABATSABA-решетка.
[21:02.000 --> 21:03.000]  ABATSABA-решетка.
[21:04.000 --> 21:05.000]  Правильно, да?
[21:06.000 --> 21:07.000]  Ну и дальше что-то.
[21:08.000 --> 21:09.000]  Вот.
[21:10.000 --> 21:11.000]  Тогда, смотрите, понятно, что если я обрублю все эти строки
[21:12.000 --> 21:13.000]  на символе перед решеткой,
[21:14.000 --> 21:15.000]  здесь будет A, здесь будет AB,
[21:16.000 --> 21:17.000]  здесь будет ABATSABA,
[21:18.000 --> 21:19.000]  здесь ABATSABA, тут ABATSABA.
[21:20.000 --> 21:21.000]  То есть обрубаю на символах до решетки,
[21:22.000 --> 21:23.000]  я утверждаю, что это будет как раз
[21:24.000 --> 21:25.000]  сестровка суффиксов.
[21:26.000 --> 21:27.000]  Это чей?
[21:28.000 --> 21:29.000]  Ну понятно, потому что у меня конец строки
[21:30.000 --> 21:31.000]  теперь ассоциируется с решеткой.
[21:32.000 --> 21:33.000]  А мне именно что нужно,
[21:34.000 --> 21:35.000]  что конец строки ведет себя как символ
[21:36.000 --> 21:37.000]  меньше всех остальных, потому что
[21:38.000 --> 21:39.000]  если есть, скажем, две строки,
[21:40.000 --> 21:41.000]  такие, что одна является префиксом другой,
[21:42.000 --> 21:43.000]  и здесь продолжение.
[21:44.000 --> 21:45.000]  То это меньше это эликсиграфически,
[21:46.000 --> 21:47.000]  потому что одна префикс другой.
[21:48.000 --> 21:49.000]  Но если бы я написал, например,
[21:50.000 --> 21:51.000]  до решетки в конец обеих строк,
[21:52.000 --> 21:53.000]  то они сравнивали бы так же.
[21:54.000 --> 21:55.000]  Ну потому что конец строки
[21:56.000 --> 21:57.000]  сравнивается с символом.
[21:58.000 --> 21:59.000]  Поэтому дописывание решетки
[22:00.000 --> 22:01.000]  и сортировка циклических сдвигов
[22:02.000 --> 22:03.000]  по факту мне автоматически дает
[22:04.000 --> 22:05.000]  сортировку суффиксов.
[22:06.000 --> 22:07.000]  Потому что решетка ведет себя как конец строки.
[22:08.000 --> 22:09.000]  Это понятно?
[22:10.000 --> 22:11.000]  Все.
[22:12.000 --> 22:13.000]  Значит мы теперь будем сортировать
[22:14.000 --> 22:15.000]  по строке, потом даем
[22:16.000 --> 22:17.000]  до циклических сдвигов.
[22:44.000 --> 22:45.000]  Значит что мы будем делать?
[22:46.000 --> 22:48.000]  Давайте мы будем сортировать
[22:49.000 --> 22:51.000]  подстроки, я уже сказал, что мы будем
[22:52.000 --> 22:53.000]  работать с подстроками, а не суффиксами.
[22:54.000 --> 22:55.000]  Давайте будем сортировать подстроки
[22:56.000 --> 22:57.000]  длины сначала один, потом два,
[22:58.000 --> 22:59.000]  потом четыре, восемь и так далее.
[23:00.000 --> 23:01.000]  То есть семян в гройке пойдем.
[23:02.000 --> 23:08.000]  Будем сортировать подстроки
[23:09.000 --> 23:13.000]  длины 2 в катах.
[23:14.000 --> 23:19.700]  и на каждом шаге, при каждом ка, мы будем хранить сортировку, ну, точнее, вот именно
[23:19.700 --> 23:24.860]  перестановку всех подстрок такой длины, в каком порядке надо переставить все подстроки
[23:24.860 --> 23:28.000]  такой длины, чтобы они шли в порядке возрастания.
[23:28.000 --> 23:31.000]  Что мы там делали с зацикливанием?
[23:31.000 --> 23:36.000]  Я сказал, что у меня все зациклено, у меня строки зациклены теперь.
[23:36.000 --> 23:39.000]  И когда я здесь говорю подстрока, я имею ввиду зацикленные подстрока.
[23:39.000 --> 23:43.000]  То есть вот то, что я здесь рисовал, это тоже будет подстрока.
[23:43.000 --> 23:47.000]  И когда я говорю подстроки длины 2 в ката, их сколько? Их ровно m.
[23:47.000 --> 23:50.000]  Потому что можно в любой позиции начаться, прочитать 2 в ката силов,
[23:50.000 --> 23:53.000]  возможно, вернувшись в начало.
[23:53.000 --> 23:57.000]  Поэтому на каждом шаге у меня подстрок всегда ровно m.
[23:57.000 --> 24:01.000]  Так вот, как я буду сортировать?
[24:01.000 --> 24:06.000]  Я буду хранить, получается, перестановку, в каком порядке нужно все вот эти подстроки проставить.
[24:06.000 --> 24:12.000]  А также я буду хранить их разбиение в разы хевалентности.
[24:12.000 --> 24:21.000]  Также храним разбиение на классы хевалентности.
[24:29.000 --> 24:32.000]  Классы просто говорят, равны подстройке или нет.
[24:32.000 --> 24:37.000]  А если не равны, то... ну то есть класс хевалентности это будет просто номер какое-то, какое-то число.
[24:37.000 --> 24:40.000]  То есть я сейчас хочу пронумеровать все подстройки вот такой длины.
[24:40.000 --> 24:43.000]  Я сейчас хочу пронумеровать все подстройки длинной 2 в ката.
[24:43.000 --> 24:47.000]  Так что одинаковым подстрочкам соответствуют одинаковые номера.
[24:47.000 --> 24:50.000]  А если подстрочки разные, то у них и номера разные.
[24:50.000 --> 24:53.000]  И при этом их соотношение такое же, как на эти строки.
[24:53.000 --> 24:56.000]  То есть если одна строка меньше другой, она под строка меньше другой.
[24:56.000 --> 24:59.000]  То и номер первое меньше номера второе.
[24:59.000 --> 25:01.000]  Буду хранить такую еще, как бы номерацию...
[25:01.000 --> 25:06.000]  То есть я каждой подстроке поставлю соответственно номер класса.
[25:06.000 --> 25:13.000]  И классы соотносятся так же, как строки, если строка меньше, то класс меньше, если строки равны, то класс равен.
[25:13.000 --> 25:14.000]  Меньше лексиграфический?
[25:14.000 --> 25:16.000]  Да, конечно, строки всегда сравниваются лексиграфически.
[25:16.000 --> 25:17.000]  А, ладно, какой вопрос.
[25:17.000 --> 25:20.000]  По-другому ты по-другому не умеешь.
[25:20.000 --> 25:23.000]  Вот, такой план.
[25:23.000 --> 25:26.000]  Давайте обозначение, как мы будем делать.
[25:26.000 --> 25:31.000]  Смотрите, я уже сказал, что под строк длины 2 в каторе всегда ровно n, в частности, за счет того, что я зацикливал,
[25:31.000 --> 25:34.000]  у меня всегда ровно n под строк.
[25:34.000 --> 25:39.000]  Давайте, у меня будет так же, как всегда, значит, p0, p1 и так далее.
[25:39.000 --> 26:03.000]  Это начальный индекс строки под строки длины 2 в каторе,
[26:03.000 --> 26:20.000]  которая стоит на этом месте в порядке сортировки.
[26:20.000 --> 26:26.000]  То есть у меня каждая подстрока длины 2 в каторе будет ассоциирована с индексом своего начала.
[26:26.000 --> 26:30.000]  Вот, есть вся строка, есть какая-то подстрока.
[26:30.000 --> 26:37.000]  Она связана с индексом, с каким-то индексом, где она начинается, какая-то позиция начала.
[26:37.000 --> 26:44.000]  И pi – это такой индекс g, что вот эта строка будет it в порядке сортировки всех подстрок длины 2 в каторе.
[26:44.000 --> 26:52.000]  То есть pi – это номер начального индекса строки на этом месте, на этом месте в порядке сортировки.
[26:52.000 --> 27:06.000]  Вот, а ci – это будет класс эквивалентности, давайте лучше номер класса эквивалентности.
[27:06.000 --> 27:21.000]  Опять-таки под строки длины 2 в каторе начинаешься в позиции i.
[27:21.000 --> 27:23.000]  В индексе i.
[27:31.000 --> 27:35.000]  Так, надо примерно рисовать.
[27:35.000 --> 27:38.000]  Попробуем сделать.
[27:38.000 --> 27:50.000]  A, B, C, AB, BC решетки.
[27:50.000 --> 27:56.000]  Давайте такое сделаем и давайте рассматривать подстроки длины 2.
[27:56.000 --> 28:00.000]  Что я хочу? Я хочу рассмотреть все подстроки длины 2.
[28:00.000 --> 28:08.000]  Вот это, вот это, вот это, вот это, и еще вот это. Решетка A, такая зацикленная, она тоже есть.
[28:08.000 --> 28:12.000]  Почему t и t не равна i?
[28:12.000 --> 28:17.000]  Потому что, смотрите, pi – это, нам надо быть на i-том месте в порядке сортировки.
[28:17.000 --> 28:19.000]  Например, давайте возьмем i равно 0.
[28:19.000 --> 28:26.000]  P0 – это та строка, та фотострока, которая будет самой маленькой в порядке сортировки.
[28:26.000 --> 28:31.000]  А у нас, ну вот, у меня есть большая строка, я рассматриваю все ее, вот такие обложки, двум, два в кадре.
[28:31.000 --> 28:35.000]  Вопрос, кто из них самая маленькая? Это Бог его знает, ну какая-то.
[28:35.000 --> 28:38.000]  А именно, п0-ая.
[28:38.000 --> 28:46.000]  Вот. То есть, p it-ая, это какая строка будет it-ой после снастировки?
[28:46.000 --> 28:49.000]  Вот какая будет p0-ой? Точнее, что такое p0?
[28:49.000 --> 28:53.000]  Это самая маленькая из-под строк. Я не знаю, где она, но вот в каком клиндексе p0 она начинается.
[28:53.000 --> 28:58.000]  Вот я ровно в этой хане. То есть, по факту p it то же самое, что суфмасс, только для постройки на два вкаток.
[28:58.000 --> 29:03.000]  Это кто будет на it-ом месте после снастировки? Ровно то же самое.
[29:03.000 --> 29:05.000]  А мы пока обозначили, но не посчитали, да?
[29:05.000 --> 29:10.000]  Да, да, конечно. Я пока обозначил, понимаю, что это несколько, как это по-русски, громовское определение.
[29:10.000 --> 29:14.000]  Вот я сейчас хочу на примере нарисовать, что здесь будет.
[29:14.000 --> 29:17.000]  Вот, давайте до этой строчки.
[29:17.000 --> 29:21.000]  Так, давайте что такое p0, скажите, пожалуйста.
[29:22.000 --> 29:23.000]  Решетка A.
[29:23.000 --> 29:25.000]  Решетка A, да.
[29:25.000 --> 29:29.000]  Мне нужно ее занумировать все сначала.
[29:29.000 --> 29:32.000]  Вот, и тогда это будет 7, правильно?
[29:32.000 --> 29:37.000]  Потому что эта вот решетка A, это самая маленькая из постройок для n2, она начинается к 7-му символе.
[29:37.000 --> 29:40.000]  Вот я его здесь храню, p0 равно 7.
[29:40.000 --> 29:43.000]  И идем дальше. Что такое p1?
[29:43.000 --> 29:46.000]  Ну дальше, вы видите, у меня есть две одинаковые по строчке AB.
[29:46.000 --> 29:50.000]  Они равны, они как бы следующие по минимальности.
[29:50.000 --> 29:53.000]  Ну я могу их в любом порядке записывать здесь.
[29:53.000 --> 29:55.000]  Могу написать 0, могу написать 3.
[29:55.000 --> 29:58.000]  Давайте здесь 0, здесь 3.
[29:58.000 --> 30:04.000]  Потому что вот эти вот две подстроки AB, AB, они идут в следующем порядке стротировки.
[30:04.000 --> 30:07.000]  Значит, ну скажем, на первом месте идет 0, а потом 3.
[30:07.000 --> 30:09.000]  Понятно?
[30:09.000 --> 30:12.000]  Так, что будет p4?
[30:12.000 --> 30:14.000]  AB мы обработали.
[30:14.000 --> 30:15.000]  AB.
[30:15.000 --> 30:16.000]  Еще раз?
[30:16.000 --> 30:17.000]  AB.
[30:17.000 --> 30:19.000]  AB, да, согласен.
[30:19.000 --> 30:22.000]  AB будет, то есть, 4, да?
[30:22.000 --> 30:24.000]  П3, наверное.
[30:24.000 --> 30:26.000]  Ой, да, виноват, виноват.
[30:26.000 --> 30:28.000]  П3 будет как раз 4, правильно?
[30:30.000 --> 30:31.000]  Вот.
[30:31.000 --> 30:35.000]  AB мы обработали, остались BC.
[30:35.000 --> 30:40.000]  Два раза, смотрите, BC встречается два раза, поэтому 1 и пятерка сейчас будут, да, в каком-то порядке.
[30:40.000 --> 30:42.000]  Ну, например, в таком.
[30:42.000 --> 30:48.000]  Разве не нужно p1 и p2 поменять местами, потому что в итоге стротировки может быть, кажется, p2 выше.
[30:48.000 --> 30:50.000]  Ну, в плане, короче.
[30:50.000 --> 30:56.000]  Нет, p1 и p2, еще раз, я рассматривал подстройки для n2.
[30:56.000 --> 30:59.000]  Вот сейчас они одинаковы абсолютно, я не могу их никак перестать.
[30:59.000 --> 31:02.000]  Ну, типа, я их могу, ну, здесь порядок неопределен, на самом деле.
[31:02.000 --> 31:04.000]  Ну, вот, допустим.
[31:04.000 --> 31:08.000]  Просто по этому определению они могут быть в таком или другом порядке.
[31:08.000 --> 31:10.000]  И это неважно, на самом деле.
[31:10.000 --> 31:12.000]  Так, что дальше?
[31:12.000 --> 31:14.000]  П5 я нашел, значит, я обработал BC.
[31:14.000 --> 31:16.000]  Осталось CA и C-решетка, правильно?
[31:16.000 --> 31:21.000]  Сначала, видимо, C-решетка, то есть строка начинается с шестого символа.
[31:21.000 --> 31:25.000]  Потом идет CA, эта строка начинается со второго символа.
[31:25.000 --> 31:27.000]  Не обманываю?
[31:27.000 --> 31:28.000]  Ну вроде.
[31:28.000 --> 31:31.000]  Хорошо, теперь давайте C-шки посчитаем.
[31:31.000 --> 31:34.000]  Давайте посчитаем C-шки.
[31:36.000 --> 31:38.000]  Начинаем с C7.
[31:38.000 --> 31:42.000]  C7 будет ноль, потому что строка начинается с седьмого символа.
[31:42.000 --> 31:45.000]  Это вот эта вот строка, да, решетка А.
[31:45.000 --> 31:46.000]  Она самая маленькая.
[31:46.000 --> 31:48.000]  Я ей назначаю нулевой классикой валентность.
[31:48.000 --> 31:53.000]  Она там будет одна, потому что нет других строк равных решетка А.
[31:53.000 --> 31:56.000]  Дальше идет две одинаковые строчки АВ.
[31:56.000 --> 31:58.000]  Да, вот я просто иду по моей перестановке.
[31:58.000 --> 32:02.000]  Сначала была вот эта решетка А, теперь две одинаковые строчки АВ.
[32:02.000 --> 32:04.000]  Вот она и вот она.
[32:04.000 --> 32:07.000]  Я говорю, что нулевая и третья строка,
[32:07.000 --> 32:09.000]  то есть те, которые начинаются с нулевого и третьего символа,
[32:09.000 --> 32:11.000]  они обе будут в первом классике валентности.
[32:13.000 --> 32:16.000]  Потому что они равны, они лежат в новом классе валентности,
[32:16.000 --> 32:18.000]  отличном от предыдущего.
[32:18.000 --> 32:20.000]  Я им назначаю очередное целое число.
[32:20.000 --> 32:22.000]  Один.
[32:22.000 --> 32:25.000]  Так, дальше идет ББР.
[32:25.000 --> 32:28.000]  Это отдельный класс, в котором нет никого больше.
[32:28.000 --> 32:32.000]  Поэтому я говорю, что C4 это два.
[32:32.000 --> 32:34.000]  Строка начинается в четвертом символе
[32:34.000 --> 32:36.000]  и лежит во втором классе валентности.
[32:36.000 --> 32:38.000]  Она там одна.
[32:38.000 --> 32:42.000]  Дальше, если я не ошибаюсь, у нее два раза было БС.
[32:42.000 --> 32:45.000]  Дальше следующие две строчки это БС.
[32:45.000 --> 32:47.000]  Вот она и вот она.
[32:47.000 --> 32:50.000]  Поэтому подстроки начинаются в позиции 1 и в позиции 5.
[32:50.000 --> 32:54.000]  Лежат в следующем классе валентности.
[32:54.000 --> 32:56.000]  Номер 3.
[32:56.000 --> 32:58.000]  Вот.
[32:58.000 --> 33:00.000]  Ну и там осталось что?
[33:00.000 --> 33:02.000]  Осталась цель шодка ЦА.
[33:02.000 --> 33:04.000]  Давайте напишу просто, что это должно быть.
[33:04.000 --> 33:06.000]  С6 это 4.
[33:06.000 --> 33:08.000]  С2 это 5.
[33:10.000 --> 33:12.000]  Вот.
[33:12.000 --> 33:14.000]  Понятно?
[33:14.000 --> 33:16.000]  Супер.
[33:16.000 --> 33:18.000]  И теперь я вот эту вещь хочу хранить для каждой степени двойки.
[33:18.000 --> 33:20.000]  Будем это делать сейчас.
[33:26.000 --> 33:28.000]  Так.
[33:38.000 --> 33:40.000]  Так, начало очень простое.
[33:40.000 --> 33:42.000]  Карда 0.
[33:42.000 --> 33:48.000]  Как обработать все подстроки длины 2 в 0, то есть 1?
[33:52.000 --> 33:54.000]  Посортировать символы, да?
[33:54.000 --> 33:56.000]  Потому что подстроки длины 1 это просто символы.
[34:08.000 --> 34:10.000]  Мне нужно посортировать символы.
[34:10.000 --> 34:14.000]  Ну если я считаю, что все элементы моей строки это какие-то чары,
[34:14.000 --> 34:18.000]  то я могу посортировать просто сортировкой подсчетом.
[34:18.000 --> 34:20.000]  Ну если у меня там всего 256 значений.
[34:20.000 --> 34:24.000]  256 возможных значений для всех элементов строки,
[34:24.000 --> 34:28.000]  я могу завести 256 корзинок, сложить их там туда, как надо, и посортить.
[34:28.000 --> 34:30.000]  Вот.
[34:30.000 --> 34:32.000]  Но на самом деле не нужно просто сортировка подсчетом.
[34:36.000 --> 34:38.000]  Так.
[34:38.000 --> 34:40.000]  Но я хочу ее вспомнить,
[34:40.000 --> 34:44.000]  потому что мне в дальнейшем нужна будет не абы какая сортировка подсчетом, а стабильная.
[34:44.000 --> 34:48.000]  Давайте быстренько вспомним, как работает стабильная сортировка подсчетом.
[34:48.000 --> 34:50.000]  Напоминаю, пусть есть у меня там какие-то числа.
[34:50.000 --> 34:54.000]  Ну в нашем случае это будет, видимо, символы строки.
[34:54.000 --> 34:56.000]  Вот.
[34:56.000 --> 34:58.000]  Как их посортить?
[34:58.000 --> 35:00.000]  То есть я сначала завожу массив.
[35:02.000 --> 35:04.000]  Сколько раз встречается каждый символ.
[35:04.000 --> 35:06.000]  Вот здесь видим, что там, 256 заведу его размер.
[35:06.000 --> 35:10.000]  Потому что все элементы это чары, например.
[35:10.000 --> 35:12.000]  Вот.
[35:12.000 --> 35:14.000]  Дополнен нулями.
[35:14.000 --> 35:16.000]  Дальше прохожусь по массиву.
[35:16.000 --> 35:18.000]  Увеличиваю количество вхождений каждого символа.
[35:18.000 --> 35:20.000]  Так, давайте все-таки будут резки.
[35:20.000 --> 35:22.000]  Потому что символы строки, да.
[35:22.000 --> 35:24.000]  Увеличиваю количество вхождений каждого символа.
[35:26.000 --> 35:28.000]  Это было у нас в первом смеси.
[35:28.000 --> 35:30.000]  По крайней мере, должно было быть.
[35:30.000 --> 35:32.000]  Я на всякий случай напомню.
[35:32.000 --> 35:34.000]  Значит, дальше.
[35:34.000 --> 35:36.000]  Дальше я насчитываю клетчатные суммы на этом массиве.
[35:46.000 --> 35:48.000]  Вот.
[35:48.000 --> 35:52.000]  И теперь KNTI хранит место, куда нужно положить самую правую ишку.
[35:52.000 --> 35:54.000]  Да.
[35:54.000 --> 35:56.000]  Потому что после этого KNT0 это количество нулей.
[35:56.000 --> 35:58.000]  KNT1 это количество нулей и единиц.
[35:58.000 --> 36:00.000]  KNT2 это количество нулей и единиц и двоих суммарно.
[36:00.000 --> 36:02.000]  И так далее.
[36:02.000 --> 36:04.000]  Поэтому KNTI хранит самую правую позицию.
[36:04.000 --> 36:06.000]  Куда нужно поставить самую правую ишку.
[36:08.000 --> 36:10.000]  Ну, потому что их количество точно совпадает с...
[36:12.000 --> 36:14.000]  Вот.
[36:14.000 --> 36:16.000]  Приду по массиву.
[36:16.000 --> 36:18.000]  Точнее по строке справа-налево.
[36:20.000 --> 36:22.000]  И кладу на то место, которое ей приписывается.
[36:24.000 --> 36:26.000]  Ой.
[36:26.000 --> 36:28.000]  Так.
[36:28.000 --> 36:30.000]  Сейчас будет выиграть глаз, но...
[36:30.000 --> 36:32.000]  Напишем.
[36:40.000 --> 36:42.000]  Во.
[36:42.000 --> 36:44.000]  Во, видите?
[36:44.000 --> 36:46.000]  А вы меня осуждали уже тогда.
[36:46.000 --> 36:48.000]  Вот.
[36:48.000 --> 36:50.000]  Ну, тут все...
[36:50.000 --> 36:52.000]  Что происходит?
[36:52.000 --> 36:54.000]  Мы идем по строке справа-налево.
[36:54.000 --> 36:56.000]  Видим символ SE.
[36:56.000 --> 36:58.000]  Это очередная буква нашей строки.
[36:58.000 --> 37:00.000]  KNT от SE показывает,
[37:00.000 --> 37:02.000]  на какое место этот символ надо было бы поставить.
[37:02.000 --> 37:04.000]  Ну, потому что после этого
[37:04.000 --> 37:06.000]  KNT SE это указатель,
[37:06.000 --> 37:08.000]  куда надо поставить самый правый символ SE.
[37:08.000 --> 37:10.000]  Это, поскольку я иду справа-налево,
[37:10.000 --> 37:12.000]  самый правый из посчитанных,
[37:12.000 --> 37:14.000]  я уменьшаю его на один, чтобы перейти в ноль индексацию,
[37:14.000 --> 37:16.000]  и как раз на это место
[37:16.000 --> 37:18.000]  ставлю элемент, который
[37:18.000 --> 37:20.000]  сейчас был item,
[37:20.000 --> 37:22.000]  который я только что прочитал.
[37:22.000 --> 37:24.000]  Ну и сразу я уменьшил KNT,
[37:24.000 --> 37:26.000]  поэтому если я в следующий раз увижу тот же самый символ,
[37:26.000 --> 37:28.000]  он встанет на правильное место.
[37:28.000 --> 37:30.000]  На то, которое на один левее.
[37:30.000 --> 37:32.000]  Вот.
[37:32.000 --> 37:34.000]  Это стабильная сортировка подсчетом.
[37:36.000 --> 37:38.000]  Теперь давайте SE еще посчитаем.
[37:38.000 --> 37:40.000]  И считаем SE.
[37:42.000 --> 37:44.000]  Ну, как-нибудь сделаем, наверное, да.
[37:44.000 --> 37:46.000]  То есть, что мы сделали? По факту мы отсортировали
[37:46.000 --> 37:48.000]  все вот эти вот однобуквенные строки,
[37:48.000 --> 37:50.000]  то есть все символы. Теперь мне нужно еще разбить
[37:50.000 --> 37:52.000]  на классы эквивалентности. Давайте я один раз
[37:52.000 --> 37:54.000]  напишу этот код.
[37:54.000 --> 37:56.000]  Давайте напишу один раз этот код.
[37:56.000 --> 37:58.000]  Давайте заведу кое-какую перемену x,
[37:58.000 --> 38:00.000]  которая равна номеру
[38:00.000 --> 38:02.000]  текущего класса.
[38:02.000 --> 38:04.000]  Минус один хочу сделать.
[38:04.000 --> 38:06.000]  Нет. Бог с ним.
[38:06.000 --> 38:08.000]  Дальше.
[38:08.000 --> 38:10.000]  Я иду по
[38:10.000 --> 38:12.000]  всем элементам
[38:12.000 --> 38:14.000]  нашей перестановки.
[38:14.000 --> 38:16.000]  PE это
[38:16.000 --> 38:18.000]  очередная строка в порядке
[38:18.000 --> 38:20.000]  сортировки.
[38:20.000 --> 38:22.000]  У меня P0, P1, P2 и так далее.
[38:22.000 --> 38:24.000]  Это как раз отсортированные символы. P0 самый маленький,
[38:24.000 --> 38:26.000]  P1 побольше, P2 побольше и так далее.
[38:26.000 --> 38:28.000]  Значит,
[38:28.000 --> 38:30.000]  я сделаю следующее.
[38:32.000 --> 38:34.000]  Если
[38:34.000 --> 38:36.000]  И равно 0,
[38:36.000 --> 38:38.000]  а давайте прям... Нет.
[38:38.000 --> 38:40.000]  Теорема.
[38:40.000 --> 38:42.000]  Ну ладно.
[38:44.000 --> 38:46.000]  Если И равно 0
[38:46.000 --> 38:48.000]  или
[38:48.000 --> 38:50.000]  SPIT
[38:50.000 --> 38:52.000]  равно SPI
[38:52.000 --> 38:54.000]  минус первое,
[38:56.000 --> 38:58.000]  тогда я говорю, что просто
[38:58.000 --> 39:00.000]  SPIT
[39:00.000 --> 39:02.000]  это x.
[39:02.000 --> 39:04.000]  Иначе я сначала
[39:04.000 --> 39:06.000]  увеличу x, потом положу SPIT
[39:06.000 --> 39:08.000]  равно x.
[39:08.000 --> 39:10.000]  Вот.
[39:10.000 --> 39:12.000]  Кажется так.
[39:12.000 --> 39:14.000]  Значит, ну какой смысл?
[39:14.000 --> 39:16.000]  Я иду в порядке...
[39:16.000 --> 39:18.000]  В общем, я иду по элементам моей перестановки.
[39:18.000 --> 39:20.000]  Сравниваю
[39:20.000 --> 39:22.000]  текущую строчку,
[39:22.000 --> 39:24.000]  которая начинается в позиции SPI
[39:24.000 --> 39:26.000]  с предыдущей. То есть я сравниваю символ
[39:26.000 --> 39:28.000]  стоящий на SPIT месте с символом,
[39:28.000 --> 39:30.000]  стоящим на SPI минус первом месте.
[39:30.000 --> 39:32.000]  То есть у меня вот этот предыдущий, этот следующий.
[39:32.000 --> 39:34.000]  Если они мне равны, или это вообще
[39:34.000 --> 39:36.000]  впервые, когда я зашел в этот цикл,
[39:36.000 --> 39:38.000]  тогда мне нужно сказать, что это
[39:38.000 --> 39:40.000]  x-й класс. То есть, грубо говоря, смирюсь, у меня
[39:40.000 --> 39:42.000]  все подстроки разбиты по классам.
[39:42.000 --> 39:44.000]  Сначала несколько строк 0-го класса,
[39:44.000 --> 39:46.000]  потом несколько строк 1-го класса и так далее.
[39:46.000 --> 39:48.000]  Так вот, я сначала иду
[39:48.000 --> 39:50.000]  по 1 классу, и если я только начал
[39:50.000 --> 39:52.000]  или если мой класс такой же, как у предыдущей
[39:52.000 --> 39:54.000]  строки, то есть, ну по факту,
[39:54.000 --> 39:56.000]  если просто строки одинаковые, то мой класс
[39:56.000 --> 39:58.000]  это x, тот, который был раньше.
[39:58.000 --> 40:00.000]  А иначе, когда я перемещаюсь
[40:00.000 --> 40:02.000]  между классами, когда я
[40:02.000 --> 40:04.000]  попадаю в строчку отлично от предыдущей,
[40:04.000 --> 40:06.000]  тогда мне нужно
[40:06.000 --> 40:08.000]  сначала x увеличить, я перехожу к новому классу
[40:08.000 --> 40:10.000]  и у него, ну, опять
[40:10.000 --> 40:12.000]  кладу x
[40:12.000 --> 40:14.000]  в качестве номера.
[40:14.000 --> 40:16.000]  Тогда, соответственно, все вот эти строчки будут
[40:16.000 --> 40:18.000]  нулевые, эти первые, ну и так далее.
[40:20.000 --> 40:22.000]  Норм?
[40:22.000 --> 40:24.000]  Хорошо.
[40:24.000 --> 40:26.000]  Ну, как?
[40:32.000 --> 40:34.000]  Ну, как? Потому что, как работает
[40:34.000 --> 40:36.000]  подсчет? Подсчет работает, если
[40:36.000 --> 40:38.000]  у вас значение маленькое. А здесь у вас
[40:38.000 --> 40:40.000]  значение, извините,
[40:40.000 --> 40:42.000]  26 в n-й.
[40:44.000 --> 40:46.000]  У вас работает сочировка
[40:46.000 --> 40:48.000]  подсчетом, если у вас значение элементов маленькие.
[40:48.000 --> 40:50.000]  Вот у нас это работает, потому что
[40:50.000 --> 40:52.000]  как бы значение это символы.
[40:54.000 --> 40:56.000]  Так.
[41:00.000 --> 41:02.000]  Все, значит, мы посчитали базу.
[41:02.000 --> 41:04.000]  Теперь давайте
[41:04.000 --> 41:06.000]  научимся переходить
[41:06.000 --> 41:08.000]  от ката во шага к k плюс первому.
[41:08.000 --> 41:10.000]  То есть, зная, что у меня
[41:10.000 --> 41:12.000]  в P и в C
[41:12.000 --> 41:14.000]  лежат правильные характеристики для
[41:14.000 --> 41:16.000]  подсрока длины 2 в катой,
[41:16.000 --> 41:18.000]  давайте научимся переходить
[41:18.000 --> 41:20.000]  к подсрокам длины 2 в степени k плюс 1.
[41:20.000 --> 41:22.000]  Вот. Это дело
[41:22.000 --> 41:24.000]  очень естественно, потому что все подстроки
[41:24.000 --> 41:26.000]  длины 2 в степени k плюс 1
[41:26.000 --> 41:28.000]  разбиваются на две равные, ну, как бы
[41:28.000 --> 41:30.000]  на две равные по длине строки длины 2 в
[41:30.000 --> 41:32.000]  катой. Если я рассмотрю
[41:32.000 --> 41:34.000]  строчку длины 2 в ка плюс 1,
[41:34.000 --> 41:36.000]  поделю пополам, то у меня как раз
[41:36.000 --> 41:38.000]  получится две подстроки длины 2 в катой.
[41:40.000 --> 41:42.000]  И, смотрите,
[41:42.000 --> 41:44.000]  мы же не даром храним
[41:44.000 --> 41:46.000]  эти классы эквивалентности, мы еще и с вами
[41:46.000 --> 41:48.000]  знаем, как их быстро сравнивать.
[41:48.000 --> 41:50.000]  То есть, за счет того, что мы храним номера
[41:50.000 --> 41:52.000]  класса эквивалентности для всех подстрок
[41:52.000 --> 41:54.000]  длины 2 в катой, мы умеем за единицу
[41:54.000 --> 41:56.000]  сравнить любые две подстроки длины
[41:56.000 --> 41:58.000]  2 в катой.
[41:58.000 --> 42:00.000]  Лексиграфически, конечно, потому что я как раз, я храню
[42:00.000 --> 42:02.000]  таким образом номера
[42:02.000 --> 42:04.000]  класса эквивалентности, чтобы
[42:04.000 --> 42:06.000]  сравнение подстрок
[42:06.000 --> 42:08.000]  было такое же, как сравнение классов,
[42:08.000 --> 42:10.000]  номеров классов. Вот.
[42:10.000 --> 42:12.000]  Ну, и значит, что мне надо сделать?
[42:12.000 --> 42:14.000]  Да, мне теперь надо посортить вот такие вот подстроки.
[42:14.000 --> 42:16.000]  Вот такие подстроки я могу представить,
[42:16.000 --> 42:18.000]  как, на самом деле, пара номеров
[42:18.000 --> 42:20.000]  класса эквивалентности двух половинок.
[42:20.000 --> 42:22.000]  Вот, если у меня есть вот такая строка
[42:22.000 --> 42:24.000]  длины 2 в степени
[42:24.000 --> 42:26.000]  ка плюс 1, пусть это
[42:26.000 --> 42:28.000]  какой-нибудь i, это какой-нибудь g.
[42:28.000 --> 42:30.000]  Вот первые индексы в этой подстроке.
[42:30.000 --> 42:32.000]  Тогда, на самом деле,
[42:32.000 --> 42:34.000]  меня просит просто посортировать массив вот таких
[42:34.000 --> 42:36.000]  вот пар.
[42:38.000 --> 42:40.000]  У меня подстрока длины 2 в степени ка плюс 1
[42:40.000 --> 42:42.000]  распадается на две подстроки.
[42:42.000 --> 42:44.000]  Я знаю, что номер класса эквивалентности первой половинки
[42:44.000 --> 42:46.000]  это ci, номер вот, давайте
[42:46.000 --> 42:48.000]  я даже не g напишу здесь, а i плюс 2 вкатой.
[42:48.000 --> 42:50.000]  Чтобы не плодить переменные.
[42:50.000 --> 42:52.000]  Вот.
[42:52.000 --> 42:54.000]  i плюс 2 вкатой.
[42:54.000 --> 42:56.000]  Значит, вторая половинка начинается в позиции
[42:56.000 --> 42:58.000]  i плюс 2 вкатой, я знаю номер ее класса эквивалентности.
[42:58.000 --> 43:00.000]  Да.
[43:00.000 --> 43:02.000]  Да, конечно.
[43:02.000 --> 43:04.000]  Ну, то есть, когда я рисую такую картинку,
[43:04.000 --> 43:06.000]  она имеется в виду, что если вот эти символы
[43:06.000 --> 43:08.000]  упали за пределы строки,
[43:08.000 --> 43:10.000]  то они вот там вот торчат.
[43:10.000 --> 43:12.000]  Но, как раз,
[43:12.000 --> 43:14.000]  мне только зацикленность и позволяет так
[43:14.000 --> 43:16.000]  делать, потому что, ну, я иначе даже не могу
[43:16.000 --> 43:18.000]  рассматривать все такие подстроки.
[43:18.000 --> 43:20.000]  Ну, скажем, а что если я начнусь в позиции, где вот здесь
[43:20.000 --> 43:22.000]  конец строки? Нельзя так делать.
[43:22.000 --> 43:24.000]  Именно поэтому я зациклил, чтобы у меня никогда
[43:24.000 --> 43:26.000]  не было конца строки.
[43:28.000 --> 43:30.000]  Вот. То есть, теперь сортировка
[43:30.000 --> 43:32.000]  подстрока длины 2 в степени ка плюс 1
[43:32.000 --> 43:34.000]  на следующей длины,
[43:34.000 --> 43:36.000]  это по факту просто сортировка таких пар.
[43:36.000 --> 43:38.000]  Ну, потому что ровно так и происходит сравнение
[43:38.000 --> 43:40.000]  двух подстрок. Вот есть, скажем, одна подстрока
[43:40.000 --> 43:42.000]  большой длины и другая.
[43:42.000 --> 43:44.000]  Как они сравниваются?
[43:44.000 --> 43:46.000]  Ну, они сравниваются слева-направо лексиграфически.
[43:46.000 --> 43:48.000]  Вот давайте рассмотрим, скажем,
[43:48.000 --> 43:50.000]  вот этой строке соответствует
[43:50.000 --> 43:52.000]  такая пара, этой строке, соответственно,
[43:52.000 --> 43:54.000]  какая-то другая.
[43:54.000 --> 43:56.000]  Сж,
[43:56.000 --> 43:58.000]  сж плюс 2 вкатый.
[43:58.000 --> 44:00.000]  Вот. Ну, смотрите, если вот эти
[44:00.000 --> 44:02.000]  две подстрочки различные,
[44:02.000 --> 44:04.000]  то мы это поймем, посмотрев на ци и на цж,
[44:04.000 --> 44:06.000]  тогда ци и цж будут различны и будут сравниваться
[44:06.000 --> 44:08.000]  точно так же, как подстроки, потому что
[44:08.000 --> 44:10.000]  это строки меньшей длины, для них
[44:10.000 --> 44:12.000]  номера классов ведут себя так же,
[44:12.000 --> 44:14.000]  как сами строки.
[44:14.000 --> 44:16.000]  Вот. Значит, они будут сравниваться так же, как ци и цж.
[44:16.000 --> 44:18.000]  Если они равны,
[44:18.000 --> 44:20.000]  то сравнение больших строк
[44:20.000 --> 44:22.000]  будет просто, ну, результат сравнения
[44:22.000 --> 44:24.000]  будет такой же, как на вот этих правых половинках.
[44:24.000 --> 44:26.000]  Потому что если левые половинки равны, я просто смотрю
[44:26.000 --> 44:28.000]  на правые. Ну, а правые половинки
[44:28.000 --> 44:30.000]  ведут себя как вот эти числа и
[44:30.000 --> 44:32.000]  соотносятся так же, как эти числа.
[44:32.000 --> 44:34.000]  Потому что все зациклено.
[44:34.000 --> 44:36.000]  И все индексы,
[44:36.000 --> 44:38.000]  вываливающиеся за n-1,
[44:38.000 --> 44:40.000]  они просто по модулю n берутся,
[44:40.000 --> 44:42.000]  тогда все очень шикарно.
[44:44.000 --> 44:46.000]  Вот. Все.
[44:46.000 --> 44:48.000]  Поэтому мы свели задачу
[44:48.000 --> 44:50.000]  сортировки подстрок такой длины
[44:50.000 --> 44:52.000]  к сортировке
[44:52.000 --> 44:54.000]  массива пар.
[44:54.000 --> 44:56.000]  Ну, а пары мы сортировать умеем, это опять-таки
[44:56.000 --> 44:58.000]  подстрок такой длины.
[44:58.000 --> 45:00.000]  Ну, а пары мы сортировать умеем, это опять-таки
[45:00.000 --> 45:02.000]  сортировка подсчета.
[45:02.000 --> 45:04.000]  Значит, давайте я это напишу.
[45:04.000 --> 45:06.000]  Свели задачу
[45:06.000 --> 45:08.000]  сортировки
[45:12.000 --> 45:14.000]  подстрок
[45:14.000 --> 45:16.000]  длины
[45:16.000 --> 45:18.000]  2 в степени k плюс 1
[45:18.000 --> 45:20.000]  к задаче
[45:20.000 --> 45:22.000]  сортировки
[45:24.000 --> 45:26.000]  массива пар.
[45:26.000 --> 45:28.000]  Вида
[45:28.000 --> 45:30.000]  ну, вот этого.
[45:30.000 --> 45:32.000]  Ci
[45:32.000 --> 45:34.000]  Ci плюс 2 в каты.
[45:34.000 --> 45:36.000]  Не пишу по модулю n, потому что все индексы
[45:36.000 --> 45:38.000]  всегда по модулю n все равно.
[45:38.000 --> 45:40.000]  Раз мы зациклили, то все равно
[45:40.000 --> 45:42.000]  процент n не явно подразумевается.
[45:42.000 --> 45:44.000]  Мы живем в Zn, скажем.
[45:44.000 --> 45:46.000]  Все автоматически по модулю n.
[45:50.000 --> 45:52.000]  Да, различных пар может быть этот квадрат.
[45:52.000 --> 45:54.000]  Но, смотрите,
[45:54.000 --> 45:56.000]  значения вот этих штук
[45:56.000 --> 45:58.000]  они всегда не больше, чем n, согласны?
[45:58.000 --> 46:00.000]  Потому что подстрок
[46:00.000 --> 46:02.000]  меньше длины максимум n,
[46:02.000 --> 46:04.000]  значит, номера классовых пары
[46:04.000 --> 46:06.000]  это всегда целые числа от 0 до
[46:06.000 --> 46:08.000]  ну, до n минус 1, ну, до n пусть будет.
[46:08.000 --> 46:10.000]  Не, до n минус 1 хочу.
[46:10.000 --> 46:12.000]  А номер классов всегда число от 0 до n минус 1.
[46:12.000 --> 46:14.000]  В первом семестре мы сортировали
[46:14.000 --> 46:16.000]  такие массивы,
[46:16.000 --> 46:18.000]  массив таких пар. Я сначала
[46:18.000 --> 46:20.000]  стабильно сортирую по второй компоненте,
[46:20.000 --> 46:22.000]  потом стабильно по первой.
[46:22.000 --> 46:24.000]  Ну и поскольку значения маленькие,
[46:24.000 --> 46:26.000]  то сортировка подсчетом выполняется быстро
[46:26.000 --> 46:28.000]  за от n.
[46:28.000 --> 46:30.000]  И за счет того, что у меня вторая
[46:30.000 --> 46:32.000]  сортировка по первым аргументам стабильна,
[46:32.000 --> 46:34.000]  это будет корректная сортировка.
[46:36.000 --> 46:38.000]  Еще раз, что возможно?
[46:42.000 --> 46:44.000]  n плюс k, где k максимальное значение.
[46:44.000 --> 46:46.000]  Здесь будет n плюс n как раз.
[46:46.000 --> 46:48.000]  Ага, хорошо.
[46:48.000 --> 46:50.000]  Так, мы свели
[46:50.000 --> 46:52.000]  задачу сортировки массива пар вида.
[46:52.000 --> 46:54.000]  Значит, все числа
[46:54.000 --> 46:56.000]  все числа
[46:56.000 --> 46:58.000]  целые от 0 до n минус 1,
[46:58.000 --> 47:00.000]  как я вот здесь написал.
[47:02.000 --> 47:04.000]  Ну, поэтому сортировка
[47:04.000 --> 47:06.000]  такого массива пар работает,
[47:06.000 --> 47:08.000]  например, до двумя сортировками.
[47:08.000 --> 47:10.000]  Сначала по вторым компоненту, потом по первым.
[47:20.000 --> 47:22.000]  Вот это работает.
[47:32.000 --> 47:34.000]  Для этого
[47:34.000 --> 47:36.000]  сортируем
[47:38.000 --> 47:40.000]  подсчетом
[47:42.000 --> 47:44.000]  сначала
[47:44.000 --> 47:46.000]  по
[47:46.000 --> 47:48.000]  вторым компонентом пар
[47:50.000 --> 47:52.000]  потом
[47:56.000 --> 47:58.000]  потом стабильно по первым.
[48:06.000 --> 48:08.000]  Вот.
[48:08.000 --> 48:10.000]  Тем самым мы можем массив пар
[48:10.000 --> 48:12.000]  посортировать за all at n.
[48:12.000 --> 48:14.000]  Согласны?
[48:14.000 --> 48:16.000]  Потому что я делаю две сортировки
[48:16.000 --> 48:18.000]  подсчетом, каждый работает за линейное время.
[48:18.000 --> 48:20.000]  Вот.
[48:20.000 --> 48:22.000]  Ну, более-менее все.
[48:22.000 --> 48:24.000]  Значит, можно заметить одну тонкость,
[48:24.000 --> 48:26.000]  что на самом деле
[48:26.000 --> 48:28.000]  первую сортировку можно не производить
[48:28.000 --> 48:30.000]  в каком-то смысле, потому что
[48:30.000 --> 48:32.000]  что такого? Давайте посмотрим на вторые компоненты.
[48:32.000 --> 48:34.000]  Вторые компоненты
[48:34.000 --> 48:36.000]  это на самом деле просто
[48:36.000 --> 48:38.000]  в каком-то порядке номера всех классов.
[48:38.000 --> 48:40.000]  Номера классов всех
[48:40.000 --> 48:42.000]  правых половинок, всех подстрок.
[48:42.000 --> 48:44.000]  Но извините, у меня с прошлого шага была перестановка P,
[48:44.000 --> 48:46.000]  которая мне как раз сортировала все
[48:46.000 --> 48:48.000]  мои подстроки длинной 2 вкатой.
[48:48.000 --> 48:50.000]  Теперь меня опять просит
[48:50.000 --> 48:52.000]  посортировать все мои подстроки длинной 2 вкатой.
[48:52.000 --> 48:54.000]  Поэтому на самом деле
[48:54.000 --> 48:56.000]  я могу первый шаг пропустить
[48:56.000 --> 48:58.000]  и просто сказать что-то типа
[49:00.000 --> 49:02.000]  P i t
[49:04.000 --> 49:06.000]  Сейчас.
[49:06.000 --> 49:08.000]  Да, то есть кто будет
[49:08.000 --> 49:10.000]  на этом месте? Если раньше было вот это,
[49:10.000 --> 49:12.000]  то теперь, да, если раньше было вот это,
[49:12.000 --> 49:14.000]  то теперь вот это. Минус равно
[49:14.000 --> 49:16.000]  длинной 2 вкатой должно быть.
[49:20.000 --> 49:22.000]  Потому что, еще раз,
[49:22.000 --> 49:24.000]  это такое замечание, которое не обязательно.
[49:24.000 --> 49:26.000]  Вот я говорю, что первый шаг, который
[49:26.000 --> 49:28.000]  сортировка по вторым компонентам пары,
[49:28.000 --> 49:30.000]  можно явно не выполнять,
[49:30.000 --> 49:32.000]  потому что, что такое вот вторые компоненты?
[49:32.000 --> 49:34.000]  Это по факту просто правые половинки
[49:34.000 --> 49:36.000]  всех подстрок длинной 2 в степенька
[49:36.000 --> 49:38.000]  плюс 1. Но они и так у меня уже посоршены
[49:38.000 --> 49:40.000]  в массиве P. А P это у меня как раз
[49:40.000 --> 49:42.000]  перестановка, в каком порядке
[49:42.000 --> 49:44.000]  прежние поединки идут все по сроке длинной 2 вкатой.
[49:44.000 --> 49:46.000]  Например, P 0
[49:46.000 --> 49:48.000]  это начало самой маленькой
[49:48.000 --> 49:50.000]  строки длины 2 вкатой.
[49:50.000 --> 49:52.000]  А вот P 0
[49:52.000 --> 49:54.000]  это самая маленькая строка длины 2 вкатой.
[49:54.000 --> 49:56.000]  Теперь кто тогда должен
[49:56.000 --> 49:58.000]  стоять на нулевом месте если я сортирую
[49:58.000 --> 50:00.000]  по вторым компонентам?
[50:00.000 --> 50:02.000]  Ну, видимо вот эта вот строка, которая здесь начинается.
[50:02.000 --> 50:04.000]  Потому что, если P 0 это самую маленькую
[50:04.000 --> 50:06.000]  строку длины 2 вкатой,
[50:06.000 --> 50:08.000]  то самую маленькую теперь с точки
[50:08.000 --> 50:10.000]  зрения сортировки по вторым компонентам
[50:10.000 --> 50:13.440]  Это вот эта вот строка, у которой p0 это вторая половина в точности.
[50:14.440 --> 50:16.760]  Поэтому p0 мне нужно сдвинуть влево на 2 вкатый.
[50:17.760 --> 50:18.800]  То же самое с остальными.
[50:18.800 --> 50:23.280]  Если я знаю, что p1 это вторая по величине строка длины 2 вкатый,
[50:23.280 --> 50:28.080]  то вторая по величине строка длины 2 степенека плюс 1 после сортировки по второму компоненту,
[50:28.080 --> 50:30.360]  это вот эта вот p1 минус 2 вкатый.
[50:32.160 --> 50:36.720]  Поэтому первый шаг можно сделать просто вот таким вот присвоением для всех i.
[50:38.520 --> 50:39.720]  Первая сортировка.
[50:40.000 --> 50:48.640]  Давайте я пишу так, p' i t, ну, конечно, да, p i t минус 2 вкатый, конечно, все по модулю, по модулю.
[50:50.640 --> 50:53.640]  Ну вот я, я поэтому не писал процент, я писал мод.
[50:55.640 --> 50:56.640]  Ау?
[50:56.640 --> 50:59.640]  Ну, да, да, да, ну, хорошо.
[51:02.640 --> 51:05.640]  Ну, вот, я, я поэтому не писал процент, я написал мод.
[51:06.640 --> 51:07.640]  Ау?
[51:07.640 --> 51:09.640]  Ну, да, да, да, ну, хорошо.
[51:10.640 --> 51:11.640]  Вот.
[51:12.640 --> 51:13.640]  Согласны?
[51:14.640 --> 51:17.640]  Ну все, а здесь ну как бы тут хочешь не хочешь, тут придется стабильно сортировать,
[51:17.640 --> 51:19.640]  но мы уже умеем стабильно сортировать за линию.
[51:19.640 --> 51:21.640]  Вот, там вот какая-то еще логика сортировки.
[51:23.640 --> 51:24.640]  Все.
[51:24.640 --> 51:27.640]  То есть мы получается, смотрите, мы с вами за линию научились переходить от 2 вкатой
[51:27.640 --> 51:29.640]  к 2 степенека плюс 1.
[51:30.640 --> 51:31.640]  Да.
[51:31.640 --> 51:33.640]  Ну, да, поэтому n log n.
[51:33.640 --> 51:37.640]  То есть я научился вот перестраивать p' по p.
[51:38.280 --> 51:43.280]  Я не проговорил, но точно так же тривиально пересчитывается c' по c.
[51:43.280 --> 51:46.280]  Ну, потому что, как бы, если у меня сортировка, то сравнивать
[51:46.280 --> 51:48.280]  две подстроки, то есть как бы...
[51:48.280 --> 51:50.280]  Ну, короче, класс эквивалентности тоже легко получить.
[51:50.280 --> 51:53.280]  А если у меня есть правильный порядок сортировки всех подстрок
[51:53.280 --> 51:55.280]  длины 2 в степени k плюс 1,
[51:57.280 --> 51:59.280]  то как посчитать класс эквивалентности?
[51:59.280 --> 52:01.280]  Ну, опять, пройтись по ним сверху вниз,
[52:01.280 --> 52:03.280]  проверить на равенство, если равны, то в одном классе,
[52:03.280 --> 52:05.280]  если не равны, то заводим новый класс.
[52:05.920 --> 52:07.920]  Поэтому, как бы, c' тоже тривиально пересчитывается,
[52:07.920 --> 52:09.920]  тривиально находится.
[52:09.920 --> 52:10.920]  Вот.
[52:10.920 --> 52:13.920]  Ну и так будем делать, пока мы всю строчку не покроем.
[52:13.920 --> 52:15.920]  То есть давайте увеличивать.
[52:15.920 --> 52:17.920]  Я начинаю с 2 в нулевой,
[52:17.920 --> 52:19.920]  перехожу к 2 в первой,
[52:19.920 --> 52:21.920]  2 во второй и так далее,
[52:21.920 --> 52:23.920]  пока не дойду до такого числа,
[52:23.920 --> 52:25.920]  которое больше и равно n.
[52:27.920 --> 52:29.920]  Ну, понятно, что мне нужно на это примерно
[52:29.920 --> 52:31.920]  логарифмическое количество итераций.
[52:32.560 --> 52:34.560]  Все.
[52:34.560 --> 52:36.560]  Я вот говорю, что на этом шаге мы победили.
[52:38.560 --> 52:40.560]  Потому что на этом шаге мы посортировали
[52:40.560 --> 52:42.560]  все подстроки длины
[52:42.560 --> 52:44.560]  некоторой,
[52:44.560 --> 52:46.560]  причем она хотя бы n.
[52:46.560 --> 52:48.560]  Вот.
[52:48.560 --> 52:50.560]  То есть теперь у меня посортированы
[52:50.560 --> 52:52.560]  все подстроки длины 2 вкатой,
[52:52.560 --> 52:54.560]  для какого-то очень большого k, что 2 вкатый хотя бы n.
[52:54.560 --> 52:56.560]  Знаешь, что у меня все такие подстроки
[52:56.560 --> 52:58.560]  расположены в порядке возрастания.
[52:58.560 --> 53:00.560]  Ну, тогда если я просто обрублю на первых n символах,
[53:01.200 --> 53:03.200]  то я посортировал все циклические суффиксы.
[53:03.200 --> 53:05.200]  Ну, потому что, как бы,
[53:05.200 --> 53:07.200]  если у вас есть порядок сортировки
[53:07.200 --> 53:09.200]  длинных строк, то после обрубания на
[53:09.200 --> 53:11.200]  каком-то месте у всех этих строк,
[53:11.200 --> 53:13.200]  у них порядок, конечно, не изменится.
[53:13.200 --> 53:14.700]  Я просто это отбрасываю,
[53:14.700 --> 53:16.440]  порядок между ними не меняется.
[53:16.440 --> 53:17.580]  Вот.
[53:17.580 --> 53:19.040]  Значит, у меня есть порядок
[53:19.040 --> 53:21.040]  сортировки всех циклических,
[53:21.040 --> 53:22.040]  всех просто циклических сдвигов.
[53:22.040 --> 53:24.040]  А значит, у меня есть порядок сортировки всех суффиксов.
[53:24.040 --> 53:26.040]  Я нахожу где, там, решетка, в каждой строке.
[53:26.040 --> 53:28.040]  Обрубаю еще и перед решеткой.
[53:28.040 --> 53:30.040]  И у меня получается сортировка всех суффиксов.
[53:30.040 --> 53:36.040]  исходной строки. Кажется, все. Итога 8.n лога m.
[53:36.040 --> 53:40.040]  Ну, если мы сигмы читаем постоянно.
[53:40.040 --> 53:43.040]  Ну да, да, да. Что тут будет? Плюс сигма отдельно или как?
[53:43.040 --> 53:45.040]  Плюс сигма на лога m тогда?
[53:45.040 --> 53:46.040]  Поч.
[53:46.040 --> 53:50.040]  А плюс сигма я утверждаю, потому что у меня на каждом шаге,
[53:50.040 --> 53:54.040]  то есть у меня только первый раз символы были от нуля до сигмы,
[53:54.040 --> 53:57.040]  а потом, точнее, номера классов от нуля до сигмы,
[53:57.040 --> 54:01.040]  нет, именно символы, а потом классов всегда вплоть до n максимум может быть.
[54:01.040 --> 54:04.040]  Тут, начиная со второго шага, сигмы уже нигде нету,
[54:04.040 --> 54:07.040]  потому что у меня все эти штуки, это числа от нуля до нуля с одного.
[54:07.040 --> 54:10.040]  То есть я могу написать здесь плюс сигму, но я не хочу.
[54:10.040 --> 54:11.040]  Вопрос?
[54:11.040 --> 54:12.040]  Ну ладно.
[54:12.040 --> 54:13.040]  У вас был? Нет?
[54:13.040 --> 54:16.040]  Мы можем просто первый раз подсортировать.
[54:16.040 --> 54:18.040]  А, ну да, можно и на лога n. Да, это правда, да.
[54:18.040 --> 54:22.040]  Вместо сигмы можно и на лога n вначале подсортировать, это правда.
[54:22.040 --> 54:25.040]  Так, еще вопросы?
[54:25.040 --> 54:27.040]  Да.
[54:27.040 --> 54:29.040]  Ну супер.
[54:29.040 --> 54:31.040]  Суфмасс построили.
[54:31.040 --> 54:35.040]  Так, ну теперь за оставшееся время нам надо построить массив LCP.
[54:35.040 --> 54:40.040]  Напоминаю, что кроме суфмасса для решения, например, задачи про проверку равенства подстрок,
[54:40.040 --> 54:42.040]  надо писать еще массив LCP.
[54:42.040 --> 54:45.040]  Давайте переходим к нему.
[54:45.040 --> 54:47.040]  Подсчет.
[54:47.040 --> 54:49.040]  Массив LCP.
[54:55.040 --> 54:57.040]  Так.
[54:57.040 --> 54:59.040]  Напоминаю.
[54:59.040 --> 55:07.040]  Массив LCP считают LCP-шки соседних суффиксов в порядке вот этой вот сортировки после суфмасса.
[55:07.040 --> 55:10.040]  Давайте я нарисую в каком-нибудь порядке все мои суффиксы.
[55:10.040 --> 55:13.040]  Ну, точнее, в порядке суфмасса нарисую все суффиксы.
[55:13.040 --> 55:18.040]  Такой, такой, такой, такой.
[55:18.040 --> 55:20.040]  Вот это суффиксный массив всех моих суффиксов.
[55:20.040 --> 55:22.040]  Я хочу посчитать LCP здесь, здесь, здесь, здесь, здесь, здесь, здесь и здесь.
[55:22.040 --> 55:24.040]  Только такие LCP-шки мне нужны.
[55:24.040 --> 55:28.040]  Вот.
[55:28.040 --> 55:32.040]  Что я буду делать?
[55:32.040 --> 55:39.040]  Первое, что я сделаю, нулевое, что я сделаю, это посчитаю массив PoS.
[55:39.040 --> 55:44.040]  PoS это на самом деле будет просто первое, что я сделаю.
[55:44.040 --> 55:48.040]  Второе, что я сделаю, это посчитаю массив PoS.
[55:48.040 --> 55:53.040]  PoS это на самом деле будет просто перестановка обратная к P.
[55:53.040 --> 55:59.040]  Перестановка обратная к P.
[55:59.040 --> 56:11.040]  Которая как раз мне позволяет по I понять, где I входит в суффмассе.
[56:11.040 --> 56:12.040]  Вот.
[56:12.040 --> 56:18.040]  Значит, она обратная в том смысле, что, ну, как бы, у меня вот здесь, да, у меня эта строка начинается с символа P0.
[56:18.040 --> 56:22.040]  Эта строка начинается с символа P1, это P2 и так далее, вплоть до Pn-1.
[56:22.040 --> 56:26.040]  Так, что-то у меня верхние индексы внезапно стали.
[56:26.040 --> 56:27.040]  Вот.
[56:27.040 --> 56:31.040]  А если я хочу понять, а где лежит суффикс S с верхним индексом I?
[56:31.040 --> 56:34.040]  То есть, где находится суффикс, начинается с этой позиции.
[56:34.040 --> 56:37.040]  Ну, я вот по P это понять не могу, я это определю по PoS.
[56:37.040 --> 56:39.040]  А PoS мне как раз, PoS.
[56:39.040 --> 56:46.040]  Да, да, конечно. PoS от какой-то позиции скажет, где соответствующая строка находится, соответствующий суффикс лежит.
[56:46.040 --> 56:48.040]  Вот.
[56:48.040 --> 56:49.040]  Хорошо.
[56:49.040 --> 56:52.040]  Значит, тогда, в частности, я знаю PoS0.
[56:52.040 --> 56:57.040]  Это место в суффмассе, где лежит вся строка на самом деле.
[56:57.040 --> 57:00.040]  Потому что это S с верхним индексом 0, это просто вся строка.
[57:00.040 --> 57:01.040]  Да.
[57:01.040 --> 57:05.040]  Ой.
[57:05.040 --> 57:07.040]  Уф.
[57:07.040 --> 57:09.040]  Нет, не думаю.
[57:09.040 --> 57:16.040]  Что, правда, что ли?
[57:16.040 --> 57:21.040]  Нет, потому что мы решетку приписали, которая меньше всех.
[57:21.040 --> 57:25.040]  Ого.
[57:25.040 --> 57:28.040]  Ого.
[57:28.040 --> 57:32.040]  Ну, логично, да, потому что С я когда делаю, у меня ровно такая там лыка.
[57:32.040 --> 57:33.040]  Ну, похоже на то.
[57:33.040 --> 57:34.040]  Нифига.
[57:34.040 --> 57:38.040]  Да, действительно, похоже, что PoS просто равно С.
[57:38.040 --> 57:41.040]  Ну, это какое-то откровение.
[57:41.040 --> 57:43.040]  Вот, давайте забудем про это.
[57:43.040 --> 57:45.040]  Ну, типа, это не надо.
[57:45.040 --> 57:50.040]  Так вот, давайте найдем PoS0, то есть, где в моем суффмассе лежит вся строка.
[57:50.040 --> 57:52.040]  Ну, вот она, видимо, да, самая длинная.
[57:52.040 --> 57:54.040]  Вот это вот будет PoS0.
[57:54.040 --> 58:01.040]  Давайте мы первое, что сделаем, это в тупую, наивнейшем алгоритмом, посчитаем LCP этой строки и следующий за ней.
[58:01.040 --> 58:06.040]  Ну, то есть, просто вот возьмем эту строчку и эту строчку, и будем идти слева-направо по ним обеим,
[58:06.040 --> 58:09.040]  считать, сколько у них первых символов одинаковые, ну, вплоть до первого отличия.
[58:09.040 --> 58:16.040]  Вот, если они не равны, то, значит, вот эти символы одинаковые, это LCP, а дальше уже LCP не продолжается.
[58:16.040 --> 58:22.040]  Если есть решетка, то нет одинаковых суффиксов.
[58:22.040 --> 58:25.040]  Да, у меня тоже.
[58:25.040 --> 58:26.040]  Вот.
[58:26.040 --> 58:27.040]  Понятно, да?
[58:27.040 --> 58:29.040]  Сначала наивным образом посчитаем LCP вот здесь.
[58:29.040 --> 58:31.040]  Я пока одно значение LCP посчитал.
[58:31.040 --> 58:33.040]  А дальше работает следующая магия.
[58:33.040 --> 58:37.040]  Смотрите, вот пусть мы посчитали LCP каких-то двух суффиксов.
[58:37.040 --> 58:41.040]  Скажем, S ИТОГО и S ЖИТОГО.
[58:41.040 --> 58:43.040]  Пусть я знаю их LCP.
[58:43.040 --> 58:46.040]  Давайте я скажу, что первые L символов у них одинаковые.
[58:46.040 --> 58:52.040]  Тогда давайте отбросим первый символ из обеих строк.
[58:52.040 --> 58:55.040]  Получатся какие-то новые строки.
[58:55.040 --> 58:58.040]  Давайте найдем, где они входят в наш SUFMAS.
[58:58.040 --> 59:00.040]  То есть, вот куда-то входили S ИТОГО и S ЖИТОГО.
[59:00.040 --> 59:03.040]  Ну, точнее, они были соседними в моем SUFMAS.
[59:03.040 --> 59:05.040]  Давайте отбросим первые символы от них.
[59:05.040 --> 59:08.040]  Посмотрим, где теперь эти строки в SUFMAS.
[59:08.040 --> 59:11.040]  Ну, сложно с индексами.
[59:11.040 --> 59:13.040]  Ну, вот, короче, эта строка будет вот этой.
[59:13.040 --> 59:16.040]  Это какой-то вот этой.
[59:16.040 --> 59:18.040]  Просто после отбрасывания первого символа.
[59:18.040 --> 59:19.040]  Ну, а, все просто, да?
[59:19.040 --> 59:21.040]  Это просто S и плюс один, это S Ж и плюс один.
[59:21.040 --> 59:23.040]  Да, тут все просто.
[59:23.040 --> 59:24.040]  Вот.
[59:24.040 --> 59:26.040]  Значит, замечание первое.
[59:26.040 --> 59:29.040]  Если L больше либо равно единице,
[59:29.040 --> 59:32.040]  тогда они сохранят свой относительный порядок.
[59:34.040 --> 59:37.040]  То есть, если раньше этот суффикс был меньше этого,
[59:37.040 --> 59:39.040]  то этот будет меньше этого.
[59:39.040 --> 59:41.040]  Но это очень просто, потому что, когда я отбрасываю,
[59:41.040 --> 59:43.040]  то есть, у них есть какой-то общий префикс, да?
[59:43.040 --> 59:44.040]  Не тривиальный.
[59:44.040 --> 59:46.040]  И первые позиции, где они различаются,
[59:46.040 --> 59:48.040]  здесь символ меньше, чем здесь.
[59:48.040 --> 59:51.040]  Тут скажем B, тут C.
[59:51.040 --> 59:54.040]  L это длина их наибольшего общего префикса.
[59:54.040 --> 59:56.040]  L это их LCP.
[59:56.040 --> 59:58.040]  Если отбрасываю первый символ,
[59:58.040 --> 59:59.040]  ну, точнее не так.
[59:59.040 --> 01:00:02.040]  Вот у меня есть их общий какой-то LCP L.
[01:00:02.040 --> 01:00:04.040]  Значит, первый символ, где они отличаются,
[01:00:04.040 --> 01:00:06.040]  вот здесь символ меньше, чем здесь.
[01:00:06.040 --> 01:00:08.040]  Тогда после отбрасывания первого символа,
[01:00:08.040 --> 01:00:10.040]  поскольку L хотя бы единица,
[01:00:10.040 --> 01:00:12.040]  то значит, это все останется,
[01:00:12.040 --> 01:00:14.040]  и B и C останутся на месте.
[01:00:14.040 --> 01:00:16.040]  Поэтому эти две строчки сначала будут
[01:00:16.040 --> 01:00:18.040]  с тишение L минус одного символа по-прежнему совпадать,
[01:00:18.040 --> 01:00:21.040]  а первое различие у них будет в позициях B и C.
[01:00:22.040 --> 01:00:23.040]  Вот.
[01:00:23.040 --> 01:00:25.040]  Значит, они сохранят свой относительный порядок.
[01:00:25.040 --> 01:00:27.040]  Это будет раньше этого,
[01:00:27.040 --> 01:00:29.040]  потому что у них общий префикс,
[01:00:29.040 --> 01:00:31.040]  а первые позиции, где они отличаются,
[01:00:31.040 --> 01:00:33.040]  это меньше, чем это.
[01:00:33.040 --> 01:00:36.040]  Ну, в предположении, что все строки существуют.
[01:00:36.040 --> 01:00:38.040]  Сейчас, если L равно длине строки...
[01:00:41.040 --> 01:00:43.040]  Ну, как бы у нас не явно там везде решетка,
[01:00:43.040 --> 01:00:45.040]  у нас нет конца строки,
[01:00:45.040 --> 01:00:47.040]  у нас решетка вместо конца строки всегда.
[01:00:47.040 --> 01:00:49.040]  Поэтому мы можем всегда сравнивать,
[01:00:49.040 --> 01:00:51.040]  считая, что строки бесконечны.
[01:00:53.040 --> 01:00:54.040]  Вот.
[01:00:54.040 --> 01:00:56.040]  Поэтому можно сказать,
[01:00:56.040 --> 01:00:58.040]  что LCP вот этой строки
[01:00:58.040 --> 01:01:00.040]  и следующей за ней
[01:01:00.040 --> 01:01:02.040]  имеет длину хотя бы L минус один.
[01:01:02.040 --> 01:01:04.040]  Потому что если между этими строчками
[01:01:04.040 --> 01:01:06.040]  LCP и L минус один,
[01:01:06.040 --> 01:01:08.040]  то мы знаем, как сидит в себе LCP.
[01:01:08.040 --> 01:01:10.040]  LCP между двумя суффиксами
[01:01:10.040 --> 01:01:12.040]  это минимум на отрезке LCP вот в этом массиве.
[01:01:12.040 --> 01:01:14.040]  Ну, значит, здесь все значения хотя бы L минус один,
[01:01:14.040 --> 01:01:16.040]  поэтому это тоже хотя бы L минус один.
[01:01:16.040 --> 01:01:18.040]  То есть, потенциально,
[01:01:18.040 --> 01:01:20.040]  после отбрасывания первого символа,
[01:01:20.040 --> 01:01:22.040]  эти строки могли разъехаться,
[01:01:22.040 --> 01:01:24.040]  между ними могли встроиться еще много разных других суффиксов,
[01:01:24.040 --> 01:01:26.040]  но все они должны обязательно
[01:01:26.040 --> 01:01:28.040]  сохранять вот эти первые L минус один символов.
[01:01:28.040 --> 01:01:30.040]  Поэтому LCP вот этой вот строки
[01:01:30.040 --> 01:01:32.040]  со следующей в суффмассе
[01:01:32.040 --> 01:01:34.040]  будет хотя бы L минус один по длине.
[01:01:36.040 --> 01:01:38.040]  Потому что, возможно, кто-то сюда вклинился.
[01:01:38.040 --> 01:01:40.040]  Ну, то есть, представьте себе,
[01:01:40.040 --> 01:01:42.040]  что была какая-то строка,
[01:01:42.040 --> 01:01:44.040]  которая, ну, скажем,
[01:01:44.040 --> 01:01:46.040]  вот такая,
[01:01:46.040 --> 01:01:48.040]  а здесь слева у нее другой какой-то символ.
[01:01:48.040 --> 01:01:50.040]  То есть, она была где-то там,
[01:01:50.040 --> 01:01:52.040]  нельзя, там был Y,
[01:01:52.040 --> 01:01:54.040]  и вот это вот все.
[01:01:54.040 --> 01:01:56.040]  Тогда, когда я удаляю по одному символу,
[01:01:56.040 --> 01:01:58.040]  эта строка вот сюда вот вклеивается.
[01:01:58.040 --> 01:02:00.040]  Ну, вообще говоря, типа,
[01:02:00.040 --> 01:02:02.040]  я не знаю, вклеивается или нет,
[01:02:02.040 --> 01:02:04.040]  но здесь, например,
[01:02:04.040 --> 01:02:06.040]  вот эта строка,
[01:02:06.040 --> 01:02:08.040]  я не знаю, вклеивается или нет,
[01:02:08.040 --> 01:02:10.040]  но тут точно не равен больше или бравно.
[01:02:10.040 --> 01:02:12.040]  То есть, возможно, кто-то там появился,
[01:02:12.040 --> 01:02:14.040]  возможно, нет, Бог его знает.
[01:02:14.040 --> 01:02:16.040]  Даже не хочу думать об этом.
[01:02:16.040 --> 01:02:18.040]  Вот, да, это главное.
[01:02:24.040 --> 01:02:26.040]  Поэтому, смотрите, что можно сделать.
[01:02:26.040 --> 01:02:28.040]  Можно делать так.
[01:02:28.040 --> 01:02:30.040]  Вот я насчитал LCP
[01:02:30.040 --> 01:02:32.040]  в этой точке между одной строкой и следующей.
[01:02:32.040 --> 01:02:34.040]  Давайте отбросим по одному,
[01:02:34.040 --> 01:02:36.040]  ну, как бы, по первому символу обеих этих строк.
[01:02:36.040 --> 01:02:38.040]  Поймем теперь,
[01:02:38.040 --> 01:02:40.040]  то есть, это была S0, давайте теперь поймем,
[01:02:40.040 --> 01:02:42.040]  где входит S1. Вот оно.
[01:02:42.040 --> 01:02:44.040]  И тогда я понимаю, что
[01:02:44.040 --> 01:02:46.040]  LCP в этой точке будет хотя бы L-1.
[01:02:46.040 --> 01:02:50.040]  Вот эти вот символы равны вот этим вот L-1 символу.
[01:02:50.040 --> 01:02:52.040]  Потом, если надо,
[01:02:52.040 --> 01:02:54.040]  у меня же все-таки только нижняя оценка,
[01:02:54.040 --> 01:02:56.040]  это не точное значение, давайте я дальше
[01:02:56.040 --> 01:02:58.040]  пойду по обеим этим строчкам,
[01:02:58.040 --> 01:03:00.040]  попровираю, если символы равны, я буду L наращивать.
[01:03:00.040 --> 01:03:02.040]  То есть, у меня есть только
[01:03:02.040 --> 01:03:04.040]  нижняя граница на LCP.
[01:03:04.040 --> 01:03:06.040]  Давайте ее увеличивать, если надо.
[01:03:06.040 --> 01:03:08.040]  Если эти символы равны, я ее увеличиваю.
[01:03:18.040 --> 01:03:20.040]  Да, это именно для соседей,
[01:03:20.040 --> 01:03:22.040]  для соседей в суфмассе.
[01:03:28.040 --> 01:03:30.040]  Так.
[01:03:30.040 --> 01:03:32.040]  Ну и поэтому,
[01:03:32.040 --> 01:03:34.040]  я знаю, что граница L-1,
[01:03:34.040 --> 01:03:36.040]  давайте потом
[01:03:36.040 --> 01:03:38.040]  увеличивать, если надо,
[01:03:38.040 --> 01:03:40.040]  и тем самым мы посчитаем правило значения LCP
[01:03:40.040 --> 01:03:42.040]  между вот этой строчкой и этой.
[01:03:42.040 --> 01:03:44.040]  Потом опять отбросим у них первые символы,
[01:03:44.040 --> 01:03:46.040]  поймем, где оно входит суфмассе,
[01:03:46.040 --> 01:03:48.040]  знаем, что ответ хотя бы L-1, ну и так далее.
[01:03:50.040 --> 01:03:52.040]  И смотрите, за счет того,
[01:03:52.040 --> 01:03:54.040]  что у меня L, вот эта вот общая глобальная L,
[01:03:54.040 --> 01:03:56.040]  каждый раз
[01:03:56.040 --> 01:03:58.040]  при переходе к следующей строчке
[01:03:58.040 --> 01:04:00.040]  уменьшается всего на 1 максимум,
[01:04:00.040 --> 01:04:02.040]  от L к L-1,
[01:04:02.040 --> 01:04:04.040]  то вот эти вот наращивания,
[01:04:04.040 --> 01:04:06.040]  цикл while пока символы равны L увеличивать,
[01:04:06.040 --> 01:04:08.040]  все эти наращивания будут
[01:04:08.040 --> 01:04:10.040]  суммарно работать за O от N, потому что L
[01:04:10.040 --> 01:04:12.040]  уменьшается всего на один раз при переходе
[01:04:12.040 --> 01:04:14.040]  к следующему E.
[01:04:14.040 --> 01:04:16.040]  Поэтому суммарно все вот эти наивные переходы
[01:04:16.040 --> 01:04:18.040]  будут работать за линию.
[01:04:18.040 --> 01:04:20.040]  Вот.
[01:04:20.040 --> 01:04:22.040]  Так, ну давайте это напишем.
[01:04:22.040 --> 01:04:24.040]  Давайте это напишем.
[01:04:24.040 --> 01:04:26.040]  Потому что мы начали со всей строки,
[01:04:26.040 --> 01:04:28.040]  по одному символу будем от нее
[01:04:28.040 --> 01:04:30.040]  откусывать, понятно, что рано или поздно
[01:04:30.040 --> 01:04:32.040]  мы все суффиксы переберем.
[01:04:32.040 --> 01:04:34.040]  Ну и когда я отбросил один символ,
[01:04:34.040 --> 01:04:36.040]  я посчитал для строки S1,
[01:04:36.040 --> 01:04:38.040]  отбросил два символа, посчитал для строки S2,
[01:04:38.040 --> 01:04:40.040]  и так далее. Так я все суффиксы переберу,
[01:04:40.040 --> 01:04:42.040]  для них и для всех посчитаю L,
[01:04:42.040 --> 01:04:44.040]  со следующим в суфмассе.
[01:04:44.040 --> 01:04:46.040]  Вот.
[01:04:46.040 --> 01:04:48.040]  Давайте напишем.
[01:04:48.040 --> 01:04:50.040]  Значит, вначале L равно 0.
[01:04:50.040 --> 01:04:52.040]  Перебираем все суффиксы,
[01:04:54.040 --> 01:04:56.040]  ну точнее, перебираем начало суффикса.
[01:04:56.040 --> 01:04:58.040]  Вот пусть суффикс начинается в позиции E,
[01:04:58.040 --> 01:05:00.040]  то есть S с верхним индексом E.
[01:05:00.040 --> 01:05:02.040]  То есть вот я нахожу где-то,
[01:05:02.040 --> 01:05:04.040]  где лежит SE,
[01:05:04.040 --> 01:05:06.040]  где лежит следующий, ну то есть
[01:05:06.040 --> 01:05:08.040]  какой там будет следующий, я буду считать
[01:05:08.040 --> 01:05:10.040]  сейчас вот это вот LCP.
[01:05:10.040 --> 01:05:12.040]  LCP между суффиксом SE и следующим
[01:05:12.040 --> 01:05:14.040]  в порядке суфмасса.
[01:05:14.040 --> 01:05:16.040]  Вот.
[01:05:16.040 --> 01:05:18.040]  Вот.
[01:05:18.040 --> 01:05:20.040]  Давайте сначала определим
[01:05:20.040 --> 01:05:22.040]  G
[01:05:22.040 --> 01:05:24.040]  как
[01:05:24.040 --> 01:05:26.040]  позицию E.
[01:05:26.040 --> 01:05:28.040]  Так, это мне удобно,
[01:05:28.040 --> 01:05:30.040]  вообще нет, сейчас, один момент.
[01:05:32.040 --> 01:05:34.040]  Давайте так вот сначала сделаю.
[01:05:34.040 --> 01:05:36.040]  Сначала сделаю такую обработку.
[01:05:36.040 --> 01:05:38.040]  Если я дошел до суффикса, который самый
[01:05:38.040 --> 01:05:40.040]  последний в моем суфмассе,
[01:05:40.040 --> 01:05:42.040]  то для него LCP считать не надо.
[01:05:42.040 --> 01:05:44.040]  Да, то есть, ну как бы, мне надо было
[01:05:44.040 --> 01:05:46.040]  посчитать LCP его с тем, кто ниже,
[01:05:46.040 --> 01:05:48.040]  а ниже никого нет.
[01:05:48.040 --> 01:05:50.040]  Поэтому давайте я сброшу L,
[01:05:50.040 --> 01:05:52.040]  то есть, ну то есть формально L это LCP,
[01:05:52.040 --> 01:05:54.040]  а LCP это LCP,
[01:05:54.040 --> 01:05:56.040]  то есть LCP это LCP,
[01:05:56.040 --> 01:05:58.040]  то есть LCP это LCP,
[01:05:58.040 --> 01:06:00.040]  то есть LCP это LCP,
[01:06:00.040 --> 01:06:02.040]  то есть LCP это LCP,
[01:06:02.040 --> 01:06:04.040]  то есть формально L это LCP,
[01:06:04.040 --> 01:06:06.040]  последней строки в суффмассе
[01:06:06.040 --> 01:06:08.040]  с пустой строкой,
[01:06:08.040 --> 01:06:10.040]  которая нету в суффмассе,
[01:06:10.040 --> 01:06:12.040]  поэтому я могу изнулить и делать contin, переходим.
[01:06:12.040 --> 01:06:14.040]  На это мы обработали случай, когда там одной строк нет.
[01:06:14.040 --> 01:06:16.040]  Тогда можно просто сказать,
[01:06:16.040 --> 01:06:18.040]  что L равно нулю.
[01:06:18.040 --> 01:06:20.040]  Вот. Ну а дальше надо делать примерно следующее.
[01:06:20.040 --> 01:06:22.040]  Давайте мы скажем, что G это
[01:06:22.040 --> 01:06:24.040]  P с индексом
[01:06:24.040 --> 01:06:26.040]  позит плюс один, видимо.
[01:06:26.040 --> 01:06:28.040]  Что это значит?
[01:06:28.040 --> 01:06:30.040]  Это значит, что мы нашли,
[01:06:30.040 --> 01:06:32.040]  сначала мы взяли pos i,
[01:06:32.040 --> 01:06:34.040]  это мы узнали, где в суффмассе находится
[01:06:34.040 --> 01:06:36.040]  строка s i, вот это вот.
[01:06:36.040 --> 01:06:38.040]  Потом увеличили индекс на один и взяли P.
[01:06:38.040 --> 01:06:40.040]  То есть здесь лежит строка, начинающая
[01:06:40.040 --> 01:06:42.040]  с сжитой позиции.
[01:06:42.040 --> 01:06:44.040]  s g, да?
[01:06:44.040 --> 01:06:46.040]  Потому что вот здесь лежит pos i,
[01:06:46.040 --> 01:06:48.040]  это pos i плюс один,
[01:06:48.040 --> 01:06:50.040]  P от pos i плюс один, это номер строки,
[01:06:50.040 --> 01:06:52.040]  который тут лежит.
[01:06:52.040 --> 01:06:54.040]  То есть мы как раз вот сейчас будем искать LCP
[01:06:54.040 --> 01:06:56.040]  между s it и s gt.
[01:06:58.040 --> 01:07:00.040]  Так, мы знаем, что ответ это хотя бы L.
[01:07:02.040 --> 01:07:04.040]  Или хотя бы L минус один.
[01:07:04.040 --> 01:07:06.040]  Давайте хотя бы L минус один.
[01:07:06.040 --> 01:07:08.040]  То есть по сравнению с предыдущим шагом
[01:07:08.040 --> 01:07:10.040]  у меня L может упасть на единичку.
[01:07:10.040 --> 01:07:12.040]  Поэтому я ее безопасно
[01:07:12.040 --> 01:07:14.040]  уменьшаю на единичку.
[01:07:14.040 --> 01:07:16.040]  Ну так, чтобы она отрицательной не была.
[01:07:16.040 --> 01:07:18.040]  Ну и дальше просто наивно наращиваю.
[01:07:18.040 --> 01:07:20.040]  Пока, скажем, s i плюс L,
[01:07:20.040 --> 01:07:22.040]  плохо, да?
[01:07:22.040 --> 01:07:24.040]  Пока i плюс L существует
[01:07:24.040 --> 01:07:26.040]  у нас в строке,
[01:07:26.040 --> 01:07:28.040]  или это не надо?
[01:07:38.040 --> 01:07:40.040]  Короче, пока символы существуют
[01:07:40.040 --> 01:07:42.040]  и равны, я увеличиваю L.
[01:07:52.040 --> 01:07:54.040]  Сейчас.
[01:07:56.040 --> 01:07:58.040]  Да, похоже на правду.
[01:07:58.040 --> 01:08:00.040]  Сейчас, сейчас, сейчас.
[01:08:00.040 --> 01:08:02.040]  Да, согласен.
[01:08:02.040 --> 01:08:04.040]  Да, окей.
[01:08:04.040 --> 01:08:06.040]  Вроде можно действительно безопасно удалить.
[01:08:18.040 --> 01:08:20.040]  Ну короче пока равны, увеличиваем.
[01:08:20.040 --> 01:08:22.040]  Да?
[01:08:22.040 --> 01:08:24.040]  Ну и все, и говорим, что
[01:08:24.040 --> 01:08:26.040]  теперь Lcp, видимо,
[01:08:26.040 --> 01:08:28.040]  pos it,
[01:08:28.040 --> 01:08:30.040]  pos it
[01:08:30.040 --> 01:08:32.040]  это L.
[01:08:34.040 --> 01:08:36.040]  Потому что pos i это как раз позиция,
[01:08:36.040 --> 01:08:38.040]  где it строка,
[01:08:38.040 --> 01:08:40.040]  где it суфикс находится в суфмасе.
[01:08:40.040 --> 01:08:42.040]  И вот ровно сюда, в Lcp,
[01:08:42.040 --> 01:08:44.040]  ровно с этим номером, я же вот это Lcp считаю.
[01:08:44.040 --> 01:08:46.040]  Вот я ее здесь храню,
[01:08:46.040 --> 01:08:48.040]  Lcp pos it это L, который я только что считал.
[01:08:50.040 --> 01:08:52.040]  Кажется, все.
[01:08:52.040 --> 01:08:54.040]  Что?
[01:08:54.040 --> 01:08:56.040]  А вот я L сразу обновляю, ну вот здесь.
[01:09:02.040 --> 01:09:04.040]  Так.
[01:09:04.040 --> 01:09:06.040]  Вопросы.
[01:09:10.040 --> 01:09:12.040]  Смотрите, я это не выделяю
[01:09:12.040 --> 01:09:14.040]  в отдельный шаг, оно мне автоматически,
[01:09:14.040 --> 01:09:16.040]  ну как бы, смотрите, когда i равно 0,
[01:09:16.040 --> 01:09:18.040]  i равно 0, L пока равно 0,
[01:09:18.040 --> 01:09:20.040]  ну там, если это
[01:09:20.040 --> 01:09:22.040]  проверка не срабатывает,
[01:09:22.040 --> 01:09:24.040]  давайте, что происходит при i равно 0?
[01:09:24.040 --> 01:09:26.040]  Я нахожу, где в суфмасе находится
[01:09:26.040 --> 01:09:28.040]  s0, вот это вот
[01:09:28.040 --> 01:09:30.040]  g, это как раз следующее за ней
[01:09:30.040 --> 01:09:32.040]  в суфмасе.
[01:09:32.040 --> 01:09:34.040]  Потому что pos i это где она лежит, pos i plus 1
[01:09:34.040 --> 01:09:36.040]  следующее, p от этой позиции,
[01:09:36.040 --> 01:09:38.040]  это, это как раз
[01:09:38.040 --> 01:09:40.040]  sgt. Ну и дальше,
[01:09:40.040 --> 01:09:42.040]  собственно, у меня вот этот первый шаг, который я там
[01:09:42.040 --> 01:09:44.040]  нарисовал, он у меня в этом же цикле сразу
[01:09:44.040 --> 01:09:46.040]  производится. Я нахожу
[01:09:46.040 --> 01:09:48.040]  префикс у этих двух строк длины l
[01:09:48.040 --> 01:09:50.040]  и кладу его туда.
[01:09:50.040 --> 01:09:52.040]  Так, еще вопросы.
[01:09:58.040 --> 01:10:00.040]  Почему это все за линию? Потому что давайте
[01:10:00.040 --> 01:10:02.040]  посмотрим на переменную l, как она
[01:10:02.040 --> 01:10:04.040]  себя ведет.
[01:10:04.040 --> 01:10:06.040]  Ну как бы понятно,
[01:10:06.040 --> 01:10:08.040]  основная сложность здесь только в вайле,
[01:10:08.040 --> 01:10:10.040]  все остальное работает, очевидно, за линию, for и
[01:10:10.040 --> 01:10:12.040]  тривиальной операции.
[01:10:12.040 --> 01:10:14.040]  Сложность происходит
[01:10:14.040 --> 01:10:16.040]  только из-за вайла. Каждый трансцикл
[01:10:16.040 --> 01:10:18.040]  вайл увеличивает l хотя бы на единицу,
[01:10:18.040 --> 01:10:20.040]  ну точнее ровно на единицу.
[01:10:20.040 --> 01:10:22.040]  Но при этом l, когда, как
[01:10:22.040 --> 01:10:24.040]  меняется l, оно только уменьшается на один
[01:10:24.040 --> 01:10:26.040]  максимум n раз,
[01:10:26.040 --> 01:10:28.040]  но еще вот здесь оно может дропнуться до нуля.
[01:10:28.040 --> 01:10:30.040]  Если я правильно понимаю, на самом деле
[01:10:30.040 --> 01:10:32.040]  это, можно вообще не писать, оно и так будет нулевое,
[01:10:32.040 --> 01:10:34.040]  потому что если я дошел до последней строчки,
[01:10:34.040 --> 01:10:36.040]  то там и так скорее все будет lcp 0
[01:10:36.040 --> 01:10:38.040]  со следующей, но это не точно. В любом случае
[01:10:38.040 --> 01:10:40.040]  что происходит с l? Оно n раз уменьшается
[01:10:40.040 --> 01:10:42.040]  на единицу, и возможно
[01:10:42.040 --> 01:10:44.040]  один раз еще сбрасывается до нуля.
[01:10:44.040 --> 01:10:46.040]  То есть, у меня есть переменная,
[01:10:46.040 --> 01:10:48.040]  которая много раз может
[01:10:48.040 --> 01:10:50.040]  увеличиваться на единицу, но всего
[01:10:50.040 --> 01:10:52.040]  максимум n раз уменьшается на один, и всего максимум
[01:10:52.040 --> 01:10:53.640]  один раз сбрасывается до нуля.
[01:10:53.640 --> 01:10:56.040]  Тогда obrigado делу, что увеличится на, может, максимум 3n раз кажется.
[01:10:56.040 --> 01:10:58.040]  То есть, мы сначала увеличили,
[01:10:58.040 --> 01:11:00.040]  потом на n уменьшили, опять увеличили,
[01:11:00.040 --> 01:11:02.040]  потом сбросили и увеличили. Ну потому что
[01:11:02.040 --> 01:11:04.040]  всегда просто l не больше, чем n.
[01:11:04.040 --> 01:11:06.040]  Значит, она не может на sul
[01:11:06.040 --> 01:11:08.040]  очень много, если она суммарно уменьшилась
[01:11:08.040 --> 01:11:10.040]  максимум 2 n раз, тут n,
[01:11:10.040 --> 01:11:13.160]  тут еще n, то значит, ты увеличишься, она могла максимум
[01:11:13.160 --> 01:11:14.160]  3n раз.
[01:11:14.160 --> 01:11:15.160]  Значит, суммарная линия.
[01:11:15.160 --> 01:11:16.160]  Да?
[01:11:16.160 --> 01:11:17.160]  Ну хорошо.
[01:11:17.160 --> 01:11:27.360]  Ну еще раз, смотрите, вот здесь n падает максимум
[01:11:27.360 --> 01:11:30.400]  на n суммарно, n уменьшается максимум на n.
[01:11:30.400 --> 01:11:33.720]  Здесь, повторю, вот эту строчку, ее вроде можно
[01:11:33.720 --> 01:11:36.960]  не писать, но даже если так, эта процедура уменьшает
[01:11:36.960 --> 01:11:42.240]  n, l максимум на n, изначально она 0, и оно всегда не больше
[01:11:42.240 --> 01:11:43.240]  чем n.
[01:11:43.240 --> 01:11:46.240]  Но если я 2n вычел, то сколько я могу прибавить к 0, чтобы
[01:11:46.240 --> 01:11:47.240]  получить максимум n?
[01:11:47.240 --> 01:11:48.240]  Ну 3n.
[01:11:48.240 --> 01:11:49.240]  Все равно линия.
[01:11:49.240 --> 01:11:50.240]  Все?
[01:11:50.240 --> 01:11:51.240]  Попросов нет?
[01:11:51.240 --> 01:11:56.240]  Ну давайте тогда закончим, опять пораньше получилось,
[01:11:56.240 --> 01:11:57.240]  что-то странное.
[01:11:57.240 --> 01:11:57.740]  Ну ладно.
