[00:00.000 --> 00:19.800]  а мы начинаем главу пятую 29 если я правильно помню вот так а мы начинаем главу пятую и
[00:19.800 --> 00:30.440]  на этой неделе я коммичусь вам выложить следующую задачу вот она будет называться
[00:30.440 --> 00:36.720]  геометрия как я уже проспользовался несколько неоднократно и сейчас вы поймете почему вот
[00:36.720 --> 00:42.040]  это будет задача где нужно использовать наследование во всех остальных задачах этого семестра не
[00:42.040 --> 00:49.960]  нужно использовать наследование если что да в big integer не нужно использовать наследование и
[00:49.960 --> 00:55.760]  следующей после геометрии задач не нужно использовать наследование я заранее предупреждаю
[00:55.760 --> 01:04.000]  а то некоторым хочется иногда вот квадратные матрицы наследники обычных матриц так не надо
[01:04.000 --> 01:14.640]  делать тоже я вам объяснил значит я уже говорил в прошлый раз про проблему того что ellipse не
[01:14.640 --> 01:20.400]  всегда что круг не всегда частный случай ellipse с точки зрения программирования вот ну я не буду
[01:20.400 --> 01:26.520]  сейчас повторять эти тезисы вот пересмотрите если что а тема следующая называется как как вы
[01:26.520 --> 01:35.160]  думаете после наследования нужно изучить что или максуляция была наследование было а теперь
[01:35.160 --> 01:49.480]  остается полиморфизм полиморфизм и виртуальные функции так уж вышло что они идут вместе бок о
[01:49.840 --> 01:59.720]  собственно виртуальной функции это и есть проявление полиморфизма так скажем так я
[01:59.720 --> 02:09.400]  наверное мне кодов надо будет писать мало я буду в основном рисовать на доске значит ну и первый
[02:09.400 --> 02:14.320]  параграф будет называться идея виртуальной функции собственно всю тему мы должны с вами пройти
[02:14.320 --> 02:20.560]  за две пары и сегодня я вам расскажу в принципе достаточно чтобы уже писать следующую задачу
[02:20.560 --> 02:31.040]  да вообще знаете есть такая группа научно-технический рэп вот у них есть много разных треков в том
[02:31.040 --> 02:41.640]  числе полиморфизм да вот вот значит вот вы даже знаете отлично если что можете послушать что-то
[02:41.640 --> 02:51.320]  поймете давайте я начну издалека я люблю рассказывать про то что такое виртуальная функция немножечко
[02:51.320 --> 02:58.480]  издалека и на таких абстрактных математических примерах мой любимый пример это пример с двумя
[02:58.480 --> 03:13.880]  кругами вот смотрите вот есть два вокруга как сейчас так значит вот смотрите вот у меня есть
[03:13.880 --> 03:20.440]  на координатной плоскости два кружочка один но я не знаю оба радиуса один один вот такой а другой
[03:20.440 --> 03:29.720]  вот такой вот ну там один с центром в точке один один на другой с центром в точке минус
[03:29.720 --> 03:40.560]  один один вот и я люблю задавать про эти круги два вопроса первый вопрос нет нет все без шуток
[03:40.560 --> 03:54.480]  значит вот если я вас прошу вот эти два круга они равны или нет что вы ответите ну правильный
[03:54.480 --> 04:06.320]  ответ конечно что значит равны ну вот так кто сказал да ну ожидаем а почему да да да да ну
[04:06.320 --> 04:11.360]  совершенно верно вот я значит от математика примерно такой ответ бы и ожидал да но потому
[04:11.360 --> 04:18.120]  что равны обычно когда про геометрические фигуры спрашивать имеется ввиду конгруентные да вот
[04:18.120 --> 04:26.920]  ну то есть получается там движениями один из другого вот теперь другой вопрос что такое круг
[04:26.920 --> 04:32.080]  ну круг это такая геометрическая фигура то есть это там типа множество точек задаваемая на
[04:32.080 --> 04:40.040]  плоскости уравнением там таким не уравнением неравенством вот и если я вас теперь задам вопрос
[04:40.040 --> 04:47.360]  тот же самый но сформулирую по-другому круг это же множество точек правильно вот и я вас прошу так
[04:47.360 --> 04:55.120]  равны ли эти два множества точек а то есть смотрите как интересно получается круг это множество
[04:55.120 --> 05:08.520]  точек но два круга равны а два множества точек нет как вам такое понимание мира да да да но я
[05:08.520 --> 05:13.720]  спрашиваю одни я задаю один и тот же вопрос про одни и те же два объекта но в одном случае
[05:13.720 --> 05:22.080]  поскольку я их называю кругами ответ оказывается да а в другом случае поскольку их называю более
[05:22.080 --> 05:34.520]  общим словом ответ оказывается нет вот это пример не виртуальной функции ну смотрите вот
[05:34.520 --> 05:45.360]  что на самом деле происходит когда ну у вас есть класс base и класс derived я говорю derived
[05:45.360 --> 05:56.720]  амперсант d равно b по сути я ну представьте да у меня есть два объекта там b1 b2 а потом
[05:56.720 --> 06:03.320]  я сказал derived амперсант d1 равно b1 и derived амперсант d2 равно b2 и я спрашиваю правда ли
[06:03.320 --> 06:19.840]  b1 равно b2 и мне отвечают нет а потом я спрашиваю правда ли d1 равно d2 и мне отвечают да ну у меня
[06:19.840 --> 06:26.680]  были два объекта b1 b2 ну да так конечно нельзя делать надо будет делать наоборот это это я
[06:26.680 --> 06:33.720]  накосячил надо было наоборот сказать что есть derived и я их назвал базами давайте напишу вот у
[06:33.720 --> 06:42.960]  меня был derived d1 d2 я поскольку пишу на доске экономили место поэтому объявляю в одной строке
[06:42.960 --> 06:56.280]  значит base b1 равно d1 потом base b2 равно d2 вот и ситуация такова что допустим у класса d1
[06:56.280 --> 07:12.240]  у класса derived у класса base у обоих определены операторы равно а что нет нет нет ну вот ситуация
[07:12.240 --> 07:21.200]  такая мы говорим что b как бы это родители а d это наследник и если я про наследников спрашиваю
[07:21.200 --> 07:27.120]  равны ли они то ответ получается да ну в этом примере как бы а если я про родителей спрашиваю
[07:27.120 --> 07:35.360]  равны ли они ответ получается нет хотя объекты одни и те же что ну этот тот самый пример который
[07:35.360 --> 07:49.760]  я сейчас привел понимаете я уже сделал наоборот чего все правильно здесь что потому что наоборот
[07:49.760 --> 08:16.520]  нельзя потому что ce иначе почему почему так вы поняли этот пример кто понял пример вот как
[08:16.520 --> 08:24.320]  вообще это работает на самом деле вот если у меня есть у класса derived функция f какая-нибудь ну
[08:24.320 --> 08:33.080]  пусть оператор равно равно и у класса base какая-нибудь функция f они по-разному определены если я у base
[08:33.080 --> 08:39.120]  вызову f вызовется одна версия если у derived вызову f вызовется другая версия при том что объекты
[08:39.120 --> 08:45.560]  могут быть одни и те же просто если я завел ссылку на base и подсунул под нее derived теперь f
[08:45.560 --> 08:51.040]  для этого base будет работать по-другому так ведут себя функции c плюс плюс стандартно если
[08:51.040 --> 08:58.200]  ничего специально не написать но мы с вами фактически это и видели уже в прошлый раз мы
[08:58.200 --> 09:06.840]  видели что если у меня есть ссылка на ну что статический тип то есть тип объекта b1 это base
[09:06.840 --> 09:11.560]  и поскольку компилятор в компайл тайме должен каждый вызов функции транслировать в какую-то
[09:11.560 --> 09:19.360]  прыжок на какую-то инструкцию компилятор конечно же вот этот вот оператор равно транслирует вызов
[09:19.360 --> 09:25.440]  равно для базов а он работает иначе чем для derived вот это стандартное поведение в плюсах то есть
[09:25.440 --> 09:36.800]  то как оно и работало бы если вы ничего специально не написали вот но на самом-то деле зачастую вы
[09:36.800 --> 09:45.400]  хотите чтобы это работало не так вы можете создавать ссылку на родителей и инициализирует
[09:45.400 --> 09:55.240]  ее наследником да об этом был весь прошлый раз целых три пары но вы к сожалению да посмотреть
[09:55.240 --> 10:06.800]  еще не выложили да понимаю так ну вот теперь представьте другую ситуацию у вас есть я не знаю
[10:06.800 --> 10:19.520]  там ну какая-нибудь фигура о я знаю какой пример привести у вас есть опять математика сейчас будет
[10:19.520 --> 10:29.080]  криволинейная трапеция и надо площадь посчитать что надо сделать интеграл взять вот а представьте
[10:29.080 --> 10:44.680]  что у вас а нет это опять пример нет вот смотрите вот у вас такая криволинейная трапеция на самом
[10:44.680 --> 10:54.760]  деле это квадрат вот как такой площадью такого посчитать нет ну можно интегралом но можно и
[10:54.760 --> 11:03.340]  напрямую да ну то есть смотрите если у вас вот у вас может быть объект какого-то базового типа
[11:03.340 --> 11:10.880]  который на самом деле является его частным случаем и объектом производного типа то есть у вас есть
[11:10.880 --> 11:20.360]  ну скажем вот там какой-нибудь многоугольник с большим количеством сторон и есть квадрат
[11:20.360 --> 11:27.280]  квадрат частный случай многоугольника чтобы посчитать и у вас есть метод посчитать площадь
[11:27.280 --> 11:33.120]  вот когда вас просят посчитать площадь многоугольника вы что делаете ну вы триангуляцию
[11:33.120 --> 11:38.880]  делаете скорее там разбиваете да разбиваете берете точку проводите диагональки там разбивать
[11:38.880 --> 11:45.280]  на треугольнике но если вы обнаруживаете что это квадрат вы можете не париться проще
[11:45.280 --> 11:53.920]  все сделать вы просто квадрат стороны сделаете вот хотелось бы зачастую чтобы даже если у меня
[11:53.920 --> 12:01.080]  квадрат называется прямоугольник вот когда я вам говорю посчитайте площадь этого многоугольника
[12:01.080 --> 12:06.320]  вы же не будете его на два треугольника разбивать чтобы площадь посчитать вы увидите что это квадрат
[12:06.320 --> 12:13.640]  и посчитайте нормально вот а когда вы видите что ну какой-то частный случай не попадает то вы
[12:13.640 --> 12:27.240]  работаете в общем случае вот я люблю еще приводить пример с ой господи блин я какой-то еще пример один
[12:27.240 --> 12:36.480]  хороший помнил но забыл уже ну ладно мне нравится пример с варкой крупы он такой очень древний вот
[12:36.480 --> 12:43.560]  представьте что у вас книга рецептов и там есть рецепт как варить разную крупу вот у вас есть
[12:43.560 --> 12:49.760]  значит метод варить для разных круп там для риса там для не знаю для гречки еще для чего-нибудь вот
[12:49.760 --> 12:58.480]  а есть типа общий метод как варить произвольное да что-то как просто варить крупу и отдельные
[12:58.480 --> 13:05.160]  рекомендации как варить каждый из видов круп и вот представьте что я беру рис и говорю вам сварите
[13:05.160 --> 13:12.120]  этот рис вы такие а ну сварить рис значит надо варить как рис вот а теперь представьте что я
[13:12.120 --> 13:19.040]  беру рис и говорю сварите эту крупу и вы такие ну раз ты назвал этот рис крупой значит я не буду
[13:19.040 --> 13:27.320]  варить его как рис значит я буду его варить как абстрактную крупу но это странно короче вам в
[13:27.320 --> 13:31.360]  большинстве случаев на самом деле хочется чтобы вы работали с объектом независимо от того как он
[13:31.360 --> 13:39.240]  назван вот чтобы этот пример работал не так как в первом случае вот если вы хотите чтобы ваш
[13:39.240 --> 13:45.840]  метод работал одинаково независимо от того через ссылку на что вы обратились к вашему объекту
[13:45.840 --> 13:53.760]  то вот такие методы называются виртуальными вот что такое виртуальная функция виртуальная
[13:53.760 --> 14:05.120]  функция это такая функция такой метод который версия которого не зависит от того через ссылку
[14:05.120 --> 14:10.600]  на что вы обратились через ссылку на родителей или через ссылку на наследника допустим у вашего
[14:10.600 --> 14:18.680]  класса есть вот я говорю вот у меня есть метод f у бэйза ну классический пример вот когда вас
[14:18.680 --> 14:25.200]  просят там что такое виртуальная функция нужно приводить вот такой пример у вас есть в структуре
[14:25.200 --> 14:40.720]  бейс метод f и в структуре derived есть метод f структура derived и в ней есть метод f который
[14:40.720 --> 14:48.560]  вводит 2 то есть методы называются одинаково работают по-разному и вот я завержу derived
[14:48.560 --> 14:59.480]  и у него вызываю f очевидно выведется 2 это мы уже разбирали но потом вот самое интересное я
[14:59.480 --> 15:08.480]  говорю base&% b равно d и переговорю b.f что выведется вот если написано так как сейчас то выведется
[15:08.480 --> 15:16.240]  один это вот этот случай я завел ссылку на родителя но подсунул ей наследника но компилятор
[15:16.240 --> 15:21.840]  в компайл тайми же не знает что это наследник он видит тип выражения бейс значит нужно
[15:21.840 --> 15:31.720]  транслировать вызов f вызов вот это f и вот без каких-то дополнительных значит слов это будет
[15:31.720 --> 15:36.640]  работать как в первом примере здесь выведется два здесь один хоть вы одного и того же объекта
[15:36.640 --> 15:42.600]  делаете как бы одно и то же действие но в одном случае вы его назвали родителем а в другом случае
[15:42.600 --> 15:51.320]  наследником поэтому одно сделается по-разному что-то у меня с маркерами проблема да что-то они
[15:51.320 --> 16:01.000]  не пишут плохо пишут безобразие вот но все меняется если вы пишете слово virtual вот виртуальный
[16:01.000 --> 16:11.320]  метод это такой метод который будет работать одинаково независимо от того через что вы его
[16:11.320 --> 16:21.000]  вызвали вот если я здесь напишу virtual достаточно на самом деле только в бейс можно и тут но это
[16:21.000 --> 16:32.040]  уже не что не повлияет сейчас а сейчас расскажу а сейчас у вас разумеется возникнет много вопросов
[16:32.040 --> 16:44.520]  и на них будут ответы вот до конца пары а ну вот если я напишу virtual здесь то это приведет к
[16:44.520 --> 16:54.120]  тому что компилятор будет независимо от того через ссылку на бейс или через ссылку на derived
[16:54.120 --> 17:17.720]  я обратился к f вызывать версию для derived вот ой нет версию для derived нет если объект является
[17:17.720 --> 17:22.640]  типа base то конечно для него нет никакой версии для derived но если объект является типа derived
[17:22.640 --> 17:29.920]  а потом мы завели ссылку на base и подсунули ему этот объект и вызвали уже от него f все равно
[17:29.920 --> 17:37.160]  вызовется версия для derived вызовется частный случай а не общий потому что компилятор увидит
[17:37.160 --> 17:52.160]  что на самом деле там derived а это отличный вопрос ну определение определение можно дать
[17:52.160 --> 17:57.520]  двумя способами я дал один первый способ сейчас я второй способ сейчас я дам скажем так
[17:57.520 --> 18:04.800]  альтернативное определение пользуйтесь каким более какой больше нравится это и есть альтернативное
[18:04.800 --> 18:11.840]  определение значит короче исходное определение виртуальной функции такое это такая такая фунту
[18:11.840 --> 18:20.320]  то есть такой метод виртуальными могут быть только методы это такой метод класса что если вы вызывает
[18:20.520 --> 18:28.140]  у объекта наследника класса вызывается версия наследника независимо от того была у вас ссылка
[18:28.140 --> 18:36.760]  на наследника или на родителя при этом в обычном случае если вы имеете ссылку на родителя а под
[18:36.760 --> 18:42.520]  ней лежит наследник вызывается версия родителя но в случае виртуального метода если вы имеете
[18:42.520 --> 18:46.940]  ссылку на родителя а под ней лежит наследник вызывается версия наследника несмотря на то
[18:46.940 --> 18:53.820]  что ссылка, казалось бы, имеет тип base. Вот, а теперь возникает резордный вопрос, а как это
[18:53.820 --> 18:57.820]  вообще возможно? Потому что ведь компилятор же в compile-time не знает, что под ссылкой.
[18:57.820 --> 19:09.140]  Правильно, это в compile-time. И на самом деле, чтобы это осуществить, вопрос о том, какая функция
[19:09.140 --> 19:14.220]  должна быть выизнана, приходится отложить до runtime, потому что, ну, очень легко построить пример,
[19:14.220 --> 19:19.780]  когда в compile-time просто невозможно знать, что лежит. Вот, представьте, у меня есть дирайв D,
[19:19.780 --> 19:31.140]  а еще base B, вот здесь объявлено. И тут я говорю, да, правильно, я говорю C in X какой-нибудь,
[19:31.140 --> 19:45.060]  и тут говорю, X там больше нуля, тогда B, иначе D. Вот, то есть, ну, X это int, то есть, я ввел с
[19:45.060 --> 19:50.380]  клаватуры какое-то число, а до этого у меня сочетало два объекта, base и derived, настоящий base и
[19:50.380 --> 19:57.300]  настоящий derived. Я ввел с клаватуры число и ссылку проинциализировал тернарним оператором,
[19:57.300 --> 20:04.260]  если больше нуля ввели, то base, а иначе derived. Все, в compile-time, конечно же, невозможно понять,
[20:04.260 --> 20:21.700]  что под этой ссылкой будет лежать в реальности. Нет, вне зависимости от того, какой тип имеет
[20:21.700 --> 20:26.020]  ссылка, результат будет один и тот же. Но, конечно же, результат зависит от того, что под ссылкой лежит.
[20:26.020 --> 20:31.980]  Ну, можно сказать, что при виртуальном методе результат зависит только от того,
[20:31.980 --> 20:38.820]  какой объект реально лежит, а не от того, какой тип ссылка на него имеет. Так вот, невозможно
[20:38.820 --> 20:46.660]  в compile-time вообще говоря понять под ссылкой, что лежит на самом деле. И поэтому компилятору
[20:46.660 --> 20:51.100]  приходится при вызове виртуального метода на самом деле генерировать некоторую инструкцию,
[20:51.100 --> 20:57.940]  не одну, а сложный некоторый набор инструкций, который занимается проверкой того, что там лежит на
[20:57.940 --> 21:05.020]  самом деле. То есть на самом деле для виртуальных методов компилятор в runtime хранит информацию о том,
[21:05.020 --> 21:12.940]  ну, какой-то вот флажочек типа, что это за тип на самом деле. Ну, грубо говоря, очень грубо говоря,
[21:12.940 --> 21:18.260]  я сегодня не буду рассказывать, как это устроено. Как это устроено, мы в следующий раз обсудим. Ну,
[21:18.260 --> 21:22.380]  там есть так называемая vtable, таблица виртуальных функций. Вы наверное о ней и краем уха слышали,
[21:22.380 --> 21:27.900]  может тут и не краем уха. Вот, и там это все еще как-то связано с виртуальным исследованием. Вот,
[21:27.900 --> 21:37.300]  но пока можно считать вот так, очень грубо, что для классов, у которых существуют виртуальные методы,
[21:37.300 --> 21:45.060]  компилятор просто хранит ну, что-то типа флажочка скрыта от вас тоже вот в классе в самом, в объекте,
[21:45.060 --> 21:51.260]  который он проверяет, когда виртуальный метод вызывается. И когда вызывается виртуальный
[21:51.260 --> 21:56.820]  метод, в runtime уже происходит проверка, а что там написано, какой тип, и в зависимости от этого
[21:56.820 --> 22:02.740]  либо тот вызов, либо этот делать в runtime. Так вот, альтернативное определение виртуальных функций
[22:02.740 --> 22:09.340]  можно сказать такое, это такие функции, которые, ну, выбор версий которых в runtime, а не в compile
[22:09.340 --> 22:16.060]  time происходит. Во всех остальных случаях всегда перегрузка функций, выбор версий функций в compile
[22:16.060 --> 22:20.740]  time происходит. На момент компиляции уже понятно, компилятор уже в момент компиляции решает,
[22:20.740 --> 22:25.780]  каждый вызов f, это прыжок куда в ассемблере. А для виртуальных функций компилятор так не
[22:25.780 --> 22:33.220]  решает, он лишь превращает это в runtime проверку флажочка, и в зависимости от этого вызвать либо то,
[22:33.220 --> 22:56.020]  либо все. Да. Ну вот, что ты называешь несколько кандидатов функции? Мне кажется, что ты...
[23:03.220 --> 23:25.820]  Сейчас, дай-ка я кое-что проверю сначала. А, ну все, собственно, я могу сейчас пойти дальше. Да,
[23:25.820 --> 23:30.140]  сейчас я отвечу на твой вопрос, разумеется, только я сначала проверил, не должен сначала сказать что-то
[23:30.140 --> 23:37.340]  более важное. Я должен сказать одну последнюю вещь, прежде чем перейти к сложным примерам,
[23:37.340 --> 23:45.500]  типы у которых есть хоть один виртуальный метод называются полиморфными. Ну это такое
[23:45.500 --> 23:52.340]  определение просто. Значит, если у класса есть хотя бы один виртуальный метод, то такой класс
[23:52.340 --> 24:02.540]  называется полиморфным, ну полиморфный тип, полиморфик type. Если есть хотя бы один виртуальный
[24:02.540 --> 24:07.340]  метод или унаследован хотя бы один виртуальный метод, то есть вот derive тоже полиморфный,
[24:07.340 --> 24:12.820]  потому что f автоматически виртуальная, если у родителя была такая же f виртуальная.
[24:12.820 --> 24:24.340]  Если у вас в наследнике определена функция с такой же сигнатурой, как была в родителе,
[24:24.340 --> 24:30.940]  и в родителе было написано virtual, то это тоже автоматически virtual. Поэтому я и сказал,
[24:30.940 --> 24:38.580]  неважно писать здесь virtual или нет, потому что слово virtual оно как, ну оно вот вниз протекает,
[24:38.580 --> 24:43.740]  вот до самого последнего. Если я теперь кого я не унаследую отсюда, сколько я не буду уровни
[24:43.740 --> 24:48.660]  наследования делать, все функции с такой сигнатурой будут virtual автоматически, потому что в этом и
[24:48.660 --> 24:54.780]  смысл виртуальности. Вот вы написали virtual и это значит вот по всей этой иерархии вниз вы должны
[24:54.780 --> 25:02.700]  правильную версию выбирать независимо от того, через ссылку на что вызываетесь. Вот это virtual оно
[25:02.700 --> 25:14.180]  вниз протекает. Вот, а теперь параграф 5.2 это, я не придумал еще лучше как назвать его более
[25:14.180 --> 25:21.180]  сложные примеры. Ну сейчас мы с вами разберем вот все эти картинки вида, а что если там перегрузка,
[25:21.180 --> 25:30.820]  а если там одна виртуальна, другая не виртуальна, сейчас разберем. Значит параграф, да что же это
[25:30.820 --> 25:51.140]  такое? Параграф, ну ладно, как уж есть. 5.2. Это что такое? Ладно. Нет. А что это такое? Как это?
[26:00.820 --> 26:22.260]  Сейчас на все эти вопросы я отвечу. Так, давайте более сложные примеры, запутанные примеры. Ну давай,
[26:22.260 --> 26:28.540]  можно я вот тут вот буду значит исправлять? В принципе тут можно было бы и на проектор перейти,
[26:28.540 --> 26:37.740]  но я не хочу честно говоря. Это долго, я лучше все на доске покажу. Вы можете на проекторе проверять,
[26:37.740 --> 26:41.820]  ну вы можете у себя на ноутах проверять то, что я говорю и кстати, я вам даже рекомендую,
[26:41.820 --> 26:50.620]  чтобы так сказать укладывалось лучше. Вот у меня есть виртуально AF в базе, просто AF в дирайвде,
[26:50.620 --> 26:55.860]  как я уже сказал она автоматически виртуальная. Был вопрос, а что если есть перегрузка, да, это
[26:55.860 --> 27:03.060]  что вот ты имел в виду? Что есть разные версии AF здесь что ли? То есть допустим тут еще есть AF,
[27:03.060 --> 27:16.220]  ну скажем вот это AF от INT. Вот смотри, вот тут есть AF от INT, а я еще сделаю AF от double,
[27:16.220 --> 27:33.500]  которая выводит 3. Что такое внешний бейс? Я не понял все еще что такое внешний бейс.
[27:33.500 --> 27:49.060]  А, да, хорошо, grand bays, сделаем сейчас. Ну давай сначала вот этот пример. Окей, я завожу
[27:49.060 --> 27:59.500]  дирайв, ну опять стандартный пример, я говорю дирайв д, бейс амперсант. Да, кстати, я забыл
[27:59.500 --> 28:05.380]  сказать, очень важно, очень важно, но я забыл сказать, если вы с указателями, а не с ссылками
[28:05.380 --> 28:15.180]  работаете, то то же самое все. Понятно, что неважно вы через, ну давайте я, чтобы так сказать,
[28:15.180 --> 28:27.660]  вот если я так сделаю, завел указатель на бейс, а под него положил указатель на дирайв, и теперь
[28:27.660 --> 28:32.860]  ПБ стрелоч КФ делаю, то все точно также будет работать с виртуальными функциями, с не виртуальными
[28:32.860 --> 28:56.100]  поведения, как со ссылками. Да? Что такое ПБ на звездочных указателях? Ну, наверное, раскрывает,
