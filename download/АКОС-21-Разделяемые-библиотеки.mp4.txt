[00:00.000 --> 00:08.880]  Ладно, всех поздравляю с началом очередного модуля контрольного. Вы написали плохо,
[00:08.880 --> 00:21.000]  к сожалению. Она еще до конца не проверена, я один проверяю. Так, ну а тема вообще этого
[00:21.000 --> 00:26.440]  модуля, это уже последняя часть окоса, которая формально выходит за рамки курса по окосу,
[00:26.440 --> 00:32.120]  поскольку тут не будет уже больше никакой архитектуры, про операционную систему будет тоже очень мало,
[00:32.120 --> 00:39.840]  в основном про всякие прикладные промышленные вещи, что можно делать поверх UNIX-системы и как
[00:39.840 --> 00:48.240]  это использовать программную культу. И начнем мы модуль с разделяемых библиотек. Что такое разделяемые
[00:48.240 --> 00:55.480]  библиотеки? Это важная часть любой UNIX-подобной системы, то есть есть ядро. Ядро выполняет какие-то
[00:55.480 --> 01:04.000]  системные вызовы. Системные вызовы делают к ядру обычные приложения, но если вы будете делать каждую
[01:04.000 --> 01:10.600]  отдельную программу, писать полностью для взаимодействия с ядром, вы замучаетесь и непонятно,
[01:10.600 --> 01:19.200]  зачем это нужно. Все-таки при реализации любого софта нужно иметь, реализовать какую-то осмысленную
[01:19.200 --> 01:28.400]  логику, а не бодаться низкоуровневыми вещами. Большая часть реализована в каких-то библиотеках,
[01:28.400 --> 01:37.760]  которые можно использовать и радоваться жизни. Что такое разделяемые библиотеки, если мы говорим
[01:37.760 --> 01:46.680]  про стандартный для вас язык программирования C++, либо для языка C, либо для других компилируемых
[01:46.680 --> 01:53.960]  языков, это просто некоторый набор исполняемых модулей. Когда вы компилируете любую программу,
[01:53.960 --> 02:00.680]  вы получаете сначала некоторый бинарный файл, который в UNIX-системе заканчивается на точку
[02:00.680 --> 02:07.400]  Windows, обычно точка OBSH, если Visual Studio, который содержит уже скомпилированный код, который пока
[02:07.400 --> 02:15.400]  еще не готов к выполнению. Дальше можно взять все эти бинарные модули, запаковать в архив,
[02:15.400 --> 02:21.880]  добавить к нему индекс и получим какую-то библиотеку. Раньше так и делали, сейчас практически этим
[02:21.880 --> 02:28.520]  способом никто не пользуется, это называется статическая библиотека. Не очень удобно, потому что
[02:28.520 --> 02:36.960]  в конечном итоге у вас все равно все объектные файлы на стадии линковки попадают в исполняемые
[02:36.960 --> 02:45.840]  файлы, с которыми они линкуются и никакой экономии места, экономии совместного использования памяти
[02:45.840 --> 02:53.480]  у нас не происходит. Современный способ это все-таки разделяемые библиотеки или shared libraries,
[02:53.480 --> 03:01.960]  фактически это самые обычные L-файлы точно так же, как и исполняемые файлы программы. Есть некоторые
[03:01.960 --> 03:12.640]  отличия от настоящих исполняемых файлов в том, что у них не прописана точка входа, но зато есть
[03:12.640 --> 03:19.280]  таблица экспортируемых символов, по которым можно найти какие-то определенные функции. Любая
[03:19.280 --> 03:26.560]  программа самая тривиальная, если конечно она не написана на assembler, использует как минимум одну
[03:26.560 --> 03:33.280]  библиотеку под названием libc. Может быть библиотека libc++, может быть стандартная
[03:33.280 --> 03:39.800]  математическая библиотека libm и еще куча разных дополнительных библиотек. Где ищутся библиотеки и
[03:39.800 --> 03:46.960]  кем это происходит? Когда вы запускаете программу, которая подразумевает используемый разделяемый
[03:46.960 --> 03:54.160]  библиотек, то запускается на самом деле сначала маленькая программа под названием интерпретатор
[03:54.520 --> 04:02.800]  ld.so, либо какие-то разные варианты названия этого файла в разных дистрибутивах. Что делает эта
[04:02.800 --> 04:12.760]  программка? Она читает заголовок lfile программы, строит дерево зависимости от библиотек и сначала
[04:12.760 --> 04:18.720]  загружает все библиотеки и программу, после этого уже передает управление самой программе. Где ищет
[04:18.720 --> 04:27.160]  эта программа библиотеки? В каком порядке? Во-первых, в заголовках lfile могут быть
[04:27.160 --> 04:35.720]  прописаны относительные либо абсолютные пути до каких-то файлов, которые нужно загрузить. Во-вторых,
[04:35.720 --> 04:45.320]  есть стандартные конфигурации для разных дистрибутивов. Есть текстовый файл gtcld.so.conf,
[04:45.320 --> 04:51.680]  который в свою очередь содержит загрузку еще каких-то других текстовых файлов,
[04:51.680 --> 04:59.640]  все это можно посмотреть. И там просто перечислены каталоги, где нужно искать файлы библиотек,
[04:59.640 --> 05:06.400]  если не указано путь к конкретному файлу. Затем идет поиск в переменной окружении ld library pass,
[05:06.400 --> 05:12.320]  и если библиотека найдена, все успешно, если нет, ну получаем ошибку, что программу невозможно
[05:12.320 --> 05:19.080]  запустить. Есть еще переменная окружения под названием ld preload, куда можно прописать явные
[05:19.080 --> 05:25.820]  названия некоторых файлов с библиотеками. В чем смысл этой переменной окружения? Те библиотеки,
[05:25.820 --> 05:32.280]  которые там перечислены, они загружаются в первую очередь и имеют самый высокий приоритет. Для чего
[05:32.280 --> 05:40.000]  это нужно? Нужно это для того, чтобы переопределить какие-то функции в библиотеках, для которых нет
[05:40.000 --> 05:49.040]  исходных текстов, либо нужно по каким-то причинам использовать стандартные библиотеки. Обычно
[05:49.040 --> 05:56.760]  используется в линукс-дистрибутивах для того, чтобы исправить поведение, сделать более тесную
[05:56.760 --> 06:04.960]  интеграцию для какого-то софта без исходных текстов. Итак, насчет поиска библиотек. В принципе,
[06:04.960 --> 06:10.440]  я сегодня общался с Павлом Охтямовым, он сказал, что вам все это рассказывал, поэтому я просто немного
[06:10.440 --> 06:19.040]  напоминаю. Можно закодировать путь до используемых библиотек в сам файл, в сам исполняемый файл,
[06:19.040 --> 06:26.280]  который библиотеки используют. Для этого в соответствующей секции l файла, раньше они назывались
[06:26.280 --> 06:33.320]  DT подчерканья pass, в современных линковщиках используется run pass, прописывается текст,
[06:33.320 --> 06:44.360]  где искать какие-то файлы с библиотеками. И если при линковке вы указываете параметр R pass,
[06:44.360 --> 06:52.960]  то этот каталог будет использоваться для поиска библиотек в дополнение к тем, которые используются
[06:52.960 --> 07:02.120]  для стандартного поиска, то есть переменные ld library pass и файлы etcconfig. В чем особенность
[07:02.120 --> 07:10.120]  содержимого этой секции? Там можно использовать специальные тексты подстановки, которые начинаются
[07:10.120 --> 07:19.440]  символа доллар, которые позволяют прописывать разные шаблонные параметры, которые будут
[07:19.440 --> 07:24.760]  использованы уже именно при запуске программы, а не жестко вкомпилированные. Обычно используют только
[07:24.760 --> 07:32.040]  одна из них под названием dollar origin. Это размещение текущего исполняемого файла,
[07:32.040 --> 07:38.120]  в каком каталоге он находится. В некоторых случаях можно еще использовать загрузку библиотека относительно
[07:38.120 --> 07:45.280]  текущего каталога. Если, например, говорить про систему windows, в которой тоже есть библиотеки,
[07:45.280 --> 07:54.040]  есть дллки. В windows обычно библиотеки ищутся рядом с программой, не так как в linux, и можно
[07:54.040 --> 07:58.880]  симитировать поведение, то есть положить библиотеки либо рядом с исполняемым файлом, либо на уровень
[07:58.880 --> 08:06.160]  выше в какой-нибудь подкаталог lib, ну и так далее. То есть может состоять какое-то имя и дальше по этому
[08:06.160 --> 08:13.680]  произвольному имени найти какой-то файл. Ну а как можно загружовать, использовать библиотеки?
[08:13.680 --> 08:30.160]  Некоторые тривиальные примеры. Так, видно ли что-нибудь на экране? Совсем плохо, да? Ладно,
[08:30.160 --> 08:37.760]  я постараюсь проговаривать словами основные моменты. Итак, мы можем программу разбить на какую-то
[08:37.760 --> 08:49.160]  библиотеку, но если крупнее делать, то не все влазит в том-то и проблема. Итак, у нас может быть
[08:49.160 --> 08:56.480]  какая-то функция, реализованная в отдельной библиотеке. Вопрос первый, как библиотеку
[08:56.480 --> 09:04.760]  скомпилировать? GCC либо Selang, смотря что вам больше нравится, если указать опцию shared,
[09:04.760 --> 09:16.160]  то при линковке будет генерироваться не исполняемый файл, будет генерироваться именно библиотека. Дальше
[09:16.160 --> 09:27.960]  минус O, и можно указать имя файла, моя великая библиотека. Обычной библиотеки в линукс начинается
[09:27.960 --> 09:35.480]  с префикса lib, это действие по умолчанию, и заканчивается на фикс.so. Так, ну и соответственно,
[09:35.480 --> 09:44.760]  файл или файлы, из которых библиотека собирается, и кто помнит содержимое прошлого
[09:44.880 --> 09:57.880]  семестра, что еще необходимо библиотекам? Позиционно независимый исполняемый код.
[09:57.880 --> 10:05.560]  Вот опция минус fpig говорит компилятору, что при генерации машинного кода нужно следовать
[10:05.560 --> 10:11.600]  правилам позиционно независимого кода, поскольку библиотека в общем случае может быть размещена
[10:11.600 --> 10:17.520]  в произвольной части виртуального адресного пространства. Так, все, вот у нас появился файл lib
[10:17.520 --> 10:24.280]  migrate library resso, прямо в точности как было сказано с опцией минус O. Так, ну и теперь есть некоторая
[10:24.280 --> 10:32.960]  программа, которая эту библиотеку использует. Как использовать библиотеку? Нужно для компиляции
[10:32.960 --> 10:41.240]  юнита текущего, то есть исполняемого файла программ C, знать, какая сигнатура у функции, то есть это
[10:41.240 --> 10:47.320]  можно сделать либо подключением внешнего заголовочного файла, либо явно ее прописать. И дальше,
[10:47.320 --> 10:56.560]  если мы попытаемся просто программу скомпилировать из данного исходного файла, мы честно ее доведем
[10:56.560 --> 11:02.360]  до стадии получения объектного кода, но не сможем слинковать, поскольку undefined reference
[11:02.360 --> 11:13.520]  to function опция, точнее две опции, минус L маленькая и каноническое имя библиотеки. Соответственно,
[11:13.520 --> 11:25.200]  mygre, регистр зависима, греат, library будет линковать нашу программу с библиотекой,
[11:25.200 --> 11:35.040]  которую невозможно найти. А почему невозможно найти? Наверное, потому что этот файл находится
[11:35.040 --> 11:42.920]  не в одном из путей slash-lib, slash-usr-lib, ну и так далее. То есть не в одном из путей, который является
[11:42.920 --> 11:49.880]  стандартом для размещения библиотек. При линковке можно указать дополнительную опцию, вот минус L
[11:49.880 --> 11:54.720]  большой, это дополнительный список каталогов, каждый отдельный опция, это дополнительный каталог,
[11:54.720 --> 12:00.440]  где искать файл с библиотеками. И все, на выходе мы получаем теперь наконец-то нашу программу
[12:00.440 --> 12:11.320]  program. Ну что, давайте ее запустим. Получаем ошибку. Невозможно загрузить библиотеку, нет такого файла
[12:11.320 --> 12:18.440]  или каталога, но мы же видим, что библиотека здесь есть. Почему такое опять же происходит? Ну,
[12:18.440 --> 12:25.760]  потому что если посмотреть лдд на нашу программу, а лдд тоже ничего не находит, not found.
[12:25.760 --> 12:35.200]  Not found, потому что имя библиотеки не является полным либо относительным именем файла. Это
[12:35.200 --> 12:41.320]  просто какое-то название. И название ищется в одном из стандартных каталогов. Можно, конечно,
[12:41.320 --> 12:58.120]  дописать переменное окружение, взять, например, текущий каталог. Вот теперь у нас программа
[12:58.120 --> 13:06.120]  действительно находится, и она может быть запущена. Все хорошо, все замечательно. Но переменные окружения
[13:06.120 --> 13:17.240]  у нас не всегда бывают проставлены. Опять же, не всегда бывает возможность поменять стандартное
[13:17.240 --> 13:25.440]  расположение путей. Так, отменяю переменную окружения ld library pass. Теперь моя программа опять
[13:25.440 --> 13:34.760]  не может быть запущена. Так, ну как можно использовать теперь секцию динамика run pass для того,
[13:35.120 --> 13:40.760]  чтобы наша программа всегда запускалась, независимо от того, где библиотека находится.
[13:40.760 --> 13:47.400]  Наша программа находится в некотором каталоге R pass, библиотека находится рядом. И если при
[13:47.400 --> 14:02.960]  компиляции указать еще вот такую страшную опцию, минус WL запятая, минус R pass запятая,
[14:02.960 --> 14:16.040]  одинарная кавычка, доллар, regin, slash, еще одинарная кавычка, то теперь все хорошо,
[14:16.040 --> 14:21.680]  все замечательно. И давайте посмотрим на нашу программу. В нашей программе все хорошо находится,
[14:21.680 --> 14:30.760]  программа запускается. Я могу создать еще какой-нибудь подкаталог, переместить теперь нашу программу и
[14:30.760 --> 14:44.640]  нашу библиотеку в этот подкаталог. Попытаться что-то запустить из подкаталога, и все будет
[14:44.640 --> 14:49.280]  хорошо, замечательно работать, независимо от расположения. Давайте посмотрим внимательно на
[14:49.280 --> 14:59.880]  то, что это за такая странная магическая опция, на что она влияет. Так, ну поехали. Что означает
[14:59.880 --> 15:11.800]  опция минус WL? Вам рассказывали раньше? Не помните? Ну рассказывай. Итак, на самом деле здесь есть линковщик
[15:11.800 --> 15:20.720]  по названиям LD. Можно посмотреть MAN на команду LD. Это исполняемый файл, который вызывается,
[15:20.720 --> 15:27.240]  в свою очередь, компилятором GCC и имеет кучу опций для того, чтобы собрать из
[15:27.240 --> 15:36.480]  нескольких объектных файлов что-то полезное исполняемый файл. Обычно вручную его редко кто вызывает,
[15:36.480 --> 15:43.240]  потому что там требуется прописывать огромное количество опций, которые являются специфичными
[15:43.240 --> 15:48.840]  для каждого линукс-дистрибутива, и знать их совершенно не обязательно. И для того,
[15:48.840 --> 15:55.240]  чтобы из компилятора GCC, который является оболочкой поверх LD, передать какую-то дополнительную опцию
[15:55.240 --> 16:04.000]  в линковщик, используется как раз опция минус WL, а дальше через запятую прописываются дополнительные
[16:04.000 --> 16:12.280]  опции. То есть минус R pass, это будет отдельная опция минус R pass, а дальше через пробел опция
[16:12.280 --> 16:18.600]  следующая, которая содержит строчку origin. Почему я, кстати, эту штуку заключил в одинарной кавычке?
[16:18.600 --> 16:30.480]  Да, потому что все-таки команду GCC я выполняю из интерпретатора bash. С точки зрения синтеза
[16:30.480 --> 16:37.960]  интерпретатора bash, вот $ и какое-то название означает, что нужно раскрыть переменную с
[16:37.960 --> 16:42.440]  названием origin, превратить ее в какой-то другой текст, и чтобы этого не происходило, приходится
[16:42.440 --> 16:50.520]  либо экранировать символ доллара, что некрасиво, либо заключать это в одинарной кавычке. И вот dollar
[16:50.520 --> 17:01.960]  origin у нас прямо точно попадает в нашу программу. Так, программа уже исчезла, я переместил subdir.
[17:01.960 --> 17:10.960]  Полезный инструмент для исследования исполняемых файлов e-file в библиотек называется readelf. Там куча
[17:10.960 --> 17:19.440]  всяких опций, в частности опция "-h", отображает общие заголовки про e-file, то есть мы видим,
[17:19.440 --> 17:29.160]  что наша программа это 64-битный e-file для архитектуры Arch64, для CBA Unix System 5,
[17:29.160 --> 17:36.120]  в котором пользуется Linux, есть некоторые n3-поинт, правда, рандомный, потому что это
[17:36.120 --> 17:45.200]  позиционный независимый код. Так, ну и что еще тут полезного есть? В общем-то здесь все, есть еще
[17:45.200 --> 17:55.040]  опция "-d", опция "-d", отображает текстовые секции, и вот здесь у нас есть секция под названием run pass,
[17:55.040 --> 18:04.040]  которая соответствует прямо в точности тому тексту, который передан через опцию линковки run
[18:04.040 --> 18:12.560]  pass, и затем уже при загрузке этой программы строчка $origin заменяется на каталог, в котором находится
[18:12.560 --> 18:23.560]  исполняемый файл. Для чего это в целом бывает полезно? В целом это бывает полезно для того, чтобы
[18:23.560 --> 18:31.400]  сделать какую-то нестандартную произвольную поставку программы, то есть обычно программа в Linux
[18:31.400 --> 18:38.880]  принято устанавливать через пакетный менеджер apt-get install и поехали. Но не всегда это бывает
[18:38.880 --> 18:45.760]  возможно. Почему? Потому что для того, чтобы сделать какой-то пакет, вам нужно держать отдельного
[18:45.760 --> 18:52.120]  человека под названием Montainer, который будет собирать ваши пакеты под разные дистрибутивы,
[18:52.120 --> 18:58.000]  которых огромное количество, под разные версии дистрибутивов, которых тоже очень много. В общем,
[18:58.000 --> 19:05.000]  на самом деле достаточно неблагодарная и неприятная работа. Можно поступить проще. Если у вас небольшая
[19:05.000 --> 19:11.040]  команда вы делать какой-то софт для Linux, вы можете программу один раз вашу скомпилировать,
[19:11.040 --> 19:17.480]  положить рядом все использования библиотеки, скомпилировать при этом, естественно, с опцией
[19:17.480 --> 19:27.520]  минус Rpass для того, чтобы все используемые вами библиотеки были доступны в вашей программе.
[19:27.520 --> 19:36.320]  На самом деле, с одной стороны, это плохо, потому что лучше по возможности использовать библиотеки,
[19:36.320 --> 19:41.080]  которые поставляются в поставке любого Linux дистрибутива. Во-первых, они автоматически
[19:41.080 --> 19:48.720]  обновляются, всякие security updates очень быстро накатываются. Если вы делаете свою поставку,
[19:48.720 --> 19:54.400]  включая все возможные сторонние библиотеки, то вам придется самостоятельно их поддерживать,
[19:54.400 --> 20:00.560]  обновлять. В то же время, обновление библиотек не всегда бывает полезным, особенно в наших
[20:00.560 --> 20:08.320]  современных реалиях. Слышали недавно новости всякие, что что-то ломается внезапно, потому что
[20:08.320 --> 20:16.800]  какой-нибудь автор опенсорсного проекта сделал комит под названием Russian нехорошие буквы,
[20:16.800 --> 20:25.160]  и что-нибудь в этом духе все начинает внезапно ломаться. Если вы фиксируете версии библиотек,
[20:25.160 --> 20:32.000]  то, как минимум, вы можете все протестировать и не наступить на какие-то серьезные проблемы.
[20:32.000 --> 20:39.640]  Поэтому, с одной стороны, полезно держать все библиотеки локально с точки зрения безопасности,
[20:39.640 --> 20:47.400]  но нужно внимательно отслеживать за тем, чтобы не эксплуатировались какие-то уязвимости.
[20:49.400 --> 20:57.240]  Если вы все-таки решаете пользоваться системами библиотеками, а для большинства
[20:57.240 --> 21:08.440]  опенсорсных библиотек все-таки стандарт, то вы можете их дополнительно устанавливать.
[21:08.440 --> 21:14.160]  Обычно в любых пакетных менеджерах это какие-то пакеты, которые начинаются с букв лип,
[21:14.160 --> 21:20.120]  дальше название библиотеки, и что содержится в таких пакетах. Пакеты это, как правило,
[21:20.120 --> 21:26.600]  платформы зависимые, то есть библиотеки для x86 не будут работать на армии наоборот,
[21:26.600 --> 21:34.040]  содержат вот эти самые SO-файлы, которые разложены в правильных местах. Кроме SO-файлов,
[21:34.040 --> 21:38.760]  возможно, могут быть какие-то ресурсные файлы, связанные с библиотекой. Таких библиотек очень
[21:38.760 --> 21:44.480]  много, обычно они являются зависимостими и вставятся в любом случае, даже если вы
[21:44.480 --> 21:52.080]  делаете поставку системы не под разработчика, а под офисного секретаря. Все равно куча файлов
[21:52.080 --> 21:58.720]  и пакетов с библиотеками у вас будут установлены. Кроме пакетов непосредственно с библиотеками,
[21:58.720 --> 22:05.800]  бывают еще пакеты, которые заканчиваются на суффикс минус дев, либо на суффикс минус девел.
[22:05.800 --> 22:12.840]  Как правило, это пакеты без привязки к конкретной архитектуре, то есть это платформы независимые
[22:12.840 --> 22:21.120]  файлы. Обычно они содержат заголочные файлы, dotage, dotage, HPP, то есть хидрофайлы, которые
[22:21.120 --> 22:27.000]  необходимы для того, чтобы компилятор понял, как те библиотеки использовать. И что означает строчка
[22:27.000 --> 22:43.720]  решетка include какое-то название? Это вопрос. Я услышал правильный ответ, потому что некоторые
[22:43.720 --> 22:50.600]  студенты говорят, что решетка include означает подключить библиотеку. Вот если я это услышу на
[22:50.600 --> 22:57.600]  какой-нибудь перездаче, ребят, не обижайтесь, я буду очень злый. Решетка include это просто
[22:57.600 --> 23:03.080]  включение одного текстового файла в текущую программу. Все, не более того. Подключение библиотеки
[23:03.080 --> 23:10.080]  это только на стадии линковки явным образом. Для чего нужны хидрофайлы? Для того, чтобы
[23:10.080 --> 23:16.440]  какую-то стороннюю библиотеку можно было использовать, и компилятор понял, какие сигнатуры
[23:16.440 --> 23:22.680]  в ней используются. Кроме того, что содержатся хидрофайлы, иногда в библиотеках, особенно в
[23:22.680 --> 23:29.000]  опенсорсных, содержатся дополнительные описания, например, сведения для компилятора,
[23:29.000 --> 23:36.200]  где эту библиотеку найти и какие опции компиляции требуются, чтобы эту библиотеку правильно
[23:36.200 --> 23:44.280]  использовать. Стандартом для практически любого линукс-дистрибутива является команда pkg-config,
[23:44.280 --> 23:55.160]  потому что она очень простая, и сделать для своей библиотеки маленький коротенький файл с текстом того,
[23:55.160 --> 24:03.240]  какие у нас используются опции компиляции, это не так сложно. Есть несколько режимов использования,
[24:03.240 --> 24:12.040]  то есть pkg-config с указанием названия использования библиотеки просто выдает обычным текстом опции
[24:12.040 --> 24:18.120]  для компилятора, который можете дальше скормить GCC либо Selangu, либо просто проверить,
[24:18.120 --> 24:23.440]  вернуть код возврата 0 или 1 наличия библиотеки, чтобы в этом могли как-то автоматизировать shell
[24:23.440 --> 24:28.800]  скрипти либо в make файле, и выдать код диагностическое сообщение о том, что требуется
[24:28.800 --> 24:40.480]  достановить определенную библиотеку. Где все такие файлы лежат? Давайте рассмотрим на примере
[24:40.480 --> 24:53.920]  какого-нибудь библиотеки, например, Fuse3. Что такое Fuse? Это у нас будет через несколько лекций позже,
[24:53.920 --> 25:04.960]  вам эта библиотека понадобится. Итак, у нас есть библиотека libfuse, мы можем опросить опции линковки,
[25:04.960 --> 25:10.480]  которые требуются, чтобы скомпановать что-то с библиотекой под названием Fuse3. Вот получаем
[25:10.480 --> 25:20.160]  опцию минус l Fuse3, минус l PisRed, то есть она требует еще библиотеку POSIXThreads. При этом нет опции
[25:20.160 --> 25:26.000]  минус l, значит файл с библиотекой лежит где-то в стандартном пути. Опять же,
[25:26.000 --> 25:36.080]  здесь могли быть какие-то дополнительные опции минус l. Cflux – это опции, которые требуются на
[25:36.080 --> 25:42.640]  стадии компиляции, а не на стадии линковки. Здесь могут содержаться, например, указания о том,
[25:42.640 --> 25:47.760]  что требуется позиционный независимый код, в современных дистрибутеах он и так по умолчанию
[25:47.760 --> 25:54.320]  подразумевается, либо дополнительные пути для поиска заголовочных файлов с опцией минус i.
[25:54.320 --> 26:03.680]  Что-то похожее на CMake. CMake вы, наверное, умеете использовать. Ну и где эти файлы лежат? Обычно
[26:03.680 --> 26:12.880]  это все раскидано по иерархии. Если это Debian либо Ubuntu, хотя в Ubuntu может отличаться так. Это
[26:12.880 --> 26:25.180]  называется USRLib. Что у нас есть USRLib? У USRLib есть полный триплет названия системы. Так,
[26:25.180 --> 26:37.760]  Arch Linux GNU. Дальше pkg.config. И тут куча файлов, которые заканчиваются на .pc. Давайте посмотрим,
[26:37.760 --> 26:46.120]  что это за файл библиотеки, который мы использовали. Это простой текстовый файл, который указывает,
[26:46.120 --> 26:54.360]  что все находится в префекте slash usr. Сама библиотека находится там-то. Для Debian это
[26:54.360 --> 27:00.920]  какое-то стандартное расположение. И вот то, что нужно выдавать компилятору libs. Можно повторно
[27:00.920 --> 27:07.320]  использовать переменные. И compile.flux. То есть такой очень простенький текстовый файл,
[27:07.320 --> 27:15.200]  который несложен написать. И он обычно идет в поставке, ну если не всех, но по крайней мере
[27:15.200 --> 27:28.360]  90 процентов опенсорсных библиотек. Так, для чего вообще нужны вот эти вот все инструменты,
[27:28.360 --> 27:35.760]  типа pkg.config.si, make и так далее. У вас может быть проект, который состоит из нескольких
[27:35.760 --> 27:42.000]  исходных файлов, по которому нужно получить в конечном итоге исполняемую программу. Обычно
[27:42.000 --> 27:47.640]  это делается с помощью утилиты make, которая автоматизирует процесс использовать текстовый
[27:47.640 --> 27:54.840]  make-файл. Опять же, текстовый make-файл вы писали в прошлом семестре. Когда у вас проект очень
[27:54.840 --> 28:00.520]  большой, то его поддерживать, используя make-файлы, становится достаточно тяжело. Потому что
[28:00.520 --> 28:05.240]  появляется огромное количество зависимости, которое нужно вручную поддерживать. И кроме того,
[28:05.240 --> 28:13.800]  какой самый большой недостаток make-файлов и утилиты make? Вы фактически жестко привязываетесь к
[28:13.800 --> 28:20.800]  конкретной платформе, потому что у вас может быть разное расположение внешних библиотек,
[28:20.800 --> 28:27.440]  разное расположение компиляторов, разные compilators. Make-файлы в общем случае не портируемы.
[28:27.440 --> 28:33.280]  Причем не только между разными операционными системами. Даже между похожими операционными
[28:33.280 --> 28:42.480]  системами, например, FreeBSD Linux или FreeBSD Mac, у вас могут быть какие-то отличия. Для того,
[28:42.480 --> 28:51.960]  чтобы как-то нивелировать эти различия и все-таки один раз написать файл, который правильно соберет
[28:51.960 --> 28:58.800]  вашу программу. Когда-то давным-давно пришли к выводу, что make-файлы, наверное, нужно генерировать
[28:58.800 --> 29:05.440]  автоматически для каждой целевой платформы. Сначала использовались обычные shell-скрипты,
[29:05.440 --> 29:11.200]  которые назывались Configure. Если вы что-то собирали open-source, наверняка часто встречали такие
[29:11.200 --> 29:17.360]  проекты, в которых есть shell-скрипт с названием Configure, который нужно запустить сначала. Он выполняет
[29:17.360 --> 29:24.400]  проверку, а что у вас есть в системе, создает какие-то рудименты, в частности make-файл.
[29:24.400 --> 29:29.560]  А следующей стадии это уже запуск утилиты make, который по сгенерированному make-файлу соберет вам
[29:29.560 --> 29:35.640]  проект. Чем плох Configure-скрипт? Начнем с того, чем он хорош, почему он раньше часто использовался.
[29:35.640 --> 29:42.960]  Хорош тем, что для его работы требуется только интерпретатор shell. Я не говорю слова bash,
[29:42.960 --> 29:50.960]  потому что bash, опять же, не самая портируемая штука. Shell есть на любой UNIX-платформе. Достаточно
[29:50.960 --> 29:57.120]  удобная штука. Но поддерживать shell-скрипты даже, на самом деле Configure-скрипты, они тоже генерируются
[29:57.120 --> 30:03.640]  автоматически с помощью отдельных инструментов AutoTools. Тоже достаточно замороченно. Поэтому
[30:03.640 --> 30:09.560]  сейчас практически все проекты упенсорсные постепенно переходят на утилиту по названиям CMake,
[30:09.560 --> 30:15.040]  с которой вы на первом курсе уже познакомились. Это кроссплодворный инструмент, который по
[30:15.040 --> 30:21.400]  декларативному описанию проекта умеет генерировать либо make-файл для сборки,
[30:21.400 --> 30:28.160]  либо какие-то проектные файлы для, например, Visual C или X-кода, которые вы можете в графической
[30:28.160 --> 30:38.800]  линии открыть и радоваться жизни. И вот с точки зрения поддержки библиотек, в CMake есть разные
[30:38.800 --> 30:49.120]  уровни поддержки. Слово find package вам знакомо? Молодцы. Есть библиотеки, для которых хорошая
[30:49.120 --> 30:55.160]  поддержка есть в CMake. Для некоторых обычного опенсорсных библиотек эта поддержка идет в самой
[30:55.160 --> 31:01.320]  поставке CMake. Это не сторонние модули, достаточно качественно прописанные. Все банально просто.
[31:01.320 --> 31:09.160]  Find package – такой-то пакет, который присутствует где-то среди стандартных модулях CMake. У вас
[31:09.160 --> 31:16.320]  сразу определяются все требуемые вам переменные, которые вы можете дальше использовать. Возможно,
[31:16.320 --> 31:20.000]  какие-то дополнительные функции, макросы. Все хорошо, все замечательно. Самое главное,
[31:20.000 --> 31:24.400]  что это все одинаково работает на разных платформах. Не только Linux, не только macOS,
[31:24.440 --> 31:30.880]  но еще и Windows. Наиболее показательный пример – это, например, использование Питона в качестве
[31:30.880 --> 31:36.200]  библиотек. Для всех очевидно, что Питон на самом деле – это не только интерпретатор,
[31:36.200 --> 31:46.480]  но еще и библиотека. Если не очевидно, то скоро станет очевидно. Хорошая поддержка наиболее
[31:46.480 --> 31:54.720]  популярных опенсорс-проектов, в частности, таких как Питон либо OpenSSL. Но все-таки модули
[31:54.720 --> 32:02.400]  написаны не для всех библиотек. Второй уровень поддержки, чуть хуже по качеству, но при этом
[32:02.400 --> 32:09.360]  покрывающий значительную часть всего опенсорсного, заключается в том, что можно просто взять и
[32:09.360 --> 32:15.240]  использовать существующий в ГНО-системах инструмент pkg-config, который я вам только что показал.
[32:15.240 --> 32:26.320]  Есть мод-пакет в CMake pkg-config, который добавляет новую команду checkmodules, которая, в свою очередь,
[32:26.320 --> 32:37.160]  ищет описание для pkg-config, которое для ГНО-окружения, как правило, присутствует и создает те же самые
[32:37.160 --> 32:47.600]  переменные, что и обычные пакеты для CMake, но просто плюс одно дополнительное действие. Где это работает?
[32:47.600 --> 32:54.640]  Работает, естественно, в Linux, FreeBSD, OpenBSD, в MacOS с некоторыми ограничениями, в частности.
[32:54.640 --> 33:03.320]  pkg-config не входит в базовую поставку, но если вы маковод и при этом программист либо разработчик,
[33:03.320 --> 33:08.080]  либо просто айтишник, то, скорее всего, у вас стоит хамбрю, и через хамбрю вы можете поставить все,
[33:08.080 --> 33:14.160]  что угодно. Обычно это все опенсорсное. И получать окружение близкое к Linux, и все это тоже будет
[33:14.160 --> 33:21.320]  работать. А вот с Windows уже сложнее, здесь требуется уже полноценная поставка МНГВ с кучей пакетов,
[33:21.320 --> 33:30.560]  работать будет не всегда. На тот случай, если совсем ничего у вас не опакечено, какая-то
[33:30.560 --> 33:40.320]  странная библиотека от неизвестного производителя, но для которой вы знаете имя, знаете какие в ней
[33:40.320 --> 33:48.000]  есть характерные для нее заголовочные файлы. Можно использовать функции Find Library для того,
[33:48.000 --> 33:56.440]  чтобы найти сам файл с библиотекой. И Find Path для того, чтобы найти, как правило,
[33:56.440 --> 34:06.280]  это каталоги для заголовочных файлов. И по некоторым хинтам, зная какие-то определенные заголовочные
[34:06.280 --> 34:13.120]  файлы, которые должны присутствовать в библиотеке, вы можете тоже найти. Но понятно, что здесь уже не такая
[34:13.120 --> 34:19.280]  тесная поддержка, какие-то дополнительные опции вам придется все равно прописывать вручную. Но не так
[34:19.280 --> 34:28.160]  много библиотек, которые не покрыты ни модулями CMake, ни текстовыми описаниями для ПКВ консистенции.
[34:28.160 --> 34:38.600]  Библиотеки могут быть слинкованы на стадии сборки программы. В этом случае подразумевается,
[34:38.600 --> 34:49.120]  что вот то, что я вам показывал, вывод. Давайте глянем на библиотеку. Так, вот у нас был собран
[34:49.120 --> 35:06.280]  файлик с программой. Смотрим на заголовки динамической секции Read Elf-D. Вот есть текст под
[35:06.280 --> 35:13.120]  названием Run Pass, который прописывает в лабирее дополнительный поиск. И есть еще строчки
[35:13.120 --> 35:23.000]  Read Ed. Это какие библиотеки требуются до загрузки программы. И все эти записи, они появляются на
[35:23.000 --> 35:29.000]  стадии сборки проекта. При этом вы жестко привязаны к тому, что вы какую-то библиотеку должны
[35:29.000 --> 35:36.000]  использовать. На самом деле, это не единственный способ, как можно загрузить библиотеку. Библиотеки
[35:36.000 --> 35:45.160]  можно загружать в том числе и после загрузки программы. Для чего это может понадобиться? Для того,
[35:45.160 --> 35:54.080]  чтобы выполнить какой-то произвольный код, про который вы не могли предполагать на стадии сборки.
[35:54.080 --> 36:01.840]  Как это сделать? Просто создаем с помощью мап какую-то часть виртуального адресного пространства,
[36:01.840 --> 36:10.440]  которая помечена как исполняемая. После этого загружаем туда код либо эту часть адресного
[36:10.440 --> 36:16.560]  пространства мэпим на какой-то существующий файл. Все. Дальше у вас есть начало в виртуальном
[36:16.560 --> 36:23.280]  адресном пространстве, какой-то указатель. Объявляете typedef на функцию и запускаете как
[36:23.280 --> 36:28.400]  обычную функцию и радуетесь жизни. Обычный такой подход используется на самом деле для just in time
[36:28.400 --> 36:37.400]  компиляции, когда вы код какой-то генерируете на лету и затем хотите его исполнять. Почему нельзя
[36:37.400 --> 36:43.920]  так взять просто с помощью мапа подключить файл с библиотекой? Потому что файл с библиотекой это
[36:43.920 --> 36:50.520]  на самом деле достаточно сложная штука, которая подразумевает, что вам нужно код загрузить,
[36:50.520 --> 36:56.720]  найти все еще зависимые библиотеки, аккуратно разобраться с тем, что является переменными,
[36:56.720 --> 37:03.680]  что является функцией, прописать нужные ссылки, то есть долинковать. Но в некоторых простых
[37:03.680 --> 37:12.120]  ситуациях можно обойтись и самым обычным простым ммапом. Так, ну простой пример, где можно
[37:12.120 --> 37:22.560]  использовать ммап для простой загрузки библиотеки, это использовать какую-нибудь очень простую
[37:22.560 --> 37:29.280]  функцию, которая с одной стороны не использует никакие другие функции, с другой стороны не
[37:29.280 --> 37:38.160]  использует никакие данные из, например, секции констант. Пример такой функции, это функция,
[37:38.160 --> 37:46.440]  которая вычисляет значение f-32 умножить на 5 деление на 9, проще некуда. Давайте этот код скомпилируем
[37:46.440 --> 37:53.760]  и извлечем настоящий код, который мы дальше можем подгрузить с помощью ммап. Так, ну для
[37:53.760 --> 37:58.880]  компиляции, так, здесь мне нужна только компиляция, это простая функция, никакой линковки не требуется,
[37:58.880 --> 38:05.520]  поэтому flag-C. Естественно, позиционно независимый код, если мы хотим использовать его в произвольном
[38:05.520 --> 38:15.360]  месте. Так, название файла пусть будет не суть важна, пусть будет автоматически, и вот у нас есть
[38:15.360 --> 38:22.240]  некоторый код. Компиляция, но не доведенная до стадии линковки, создает нам файл, который заканчиваем
[38:22.240 --> 38:29.880]  от .o и с помощью телета ObjDump мы теперь можем посмотреть, что в этом файле содержится. Таблица
[38:29.880 --> 38:39.840]  символов, которые содержит. Символ Fargain to Celsius мы можем посмотреть на код. Код достаточно короткий,
[38:39.840 --> 38:46.680]  всего 34 инструкции, размером 4 байта каждая, и по сути нам из этого файла нужно извлечь вот этот
[38:46.680 --> 38:55.160]  вот бинарный код, то есть последность данных D0083FF и заканчивается оно должно на 0.3.0. Все, достаточно
[38:55.160 --> 39:00.520]  извлечь вот этот маленький кусочек, загрузить в нужную часть памяти, взять указатель на вот этот
[39:00.520 --> 39:07.920]  байт с содержимым D1 и начать его выполнять. Все будет хорошо, все замечательно. Как-то, кстати,
[39:07.920 --> 39:20.520]  много получилось, вроде простая функция. Так, OS, эксперимент. Это он жестко оптимизировал,
[39:20.520 --> 39:30.160]  ну ладно. Можно поразвлекаться с разными опциями компиляции, посмотреть, что у нас тут,
[39:30.160 --> 39:39.680]  да, любая оптимизация. А, я слово Extern не написал, поэтому выкинул, понятно. Так, ладно, можно
[39:39.680 --> 39:45.640]  поразвлекаться с опциями оптимизации, чтобы делать код компактнее, но в принципе 34 инструкции
[39:45.640 --> 39:55.800]  по 4 байта каждая, это не так много. Так, точнее 34 даже меньше, это 16-личная запись. Так, ну ладно,
[39:55.800 --> 40:02.360]  вот у нас есть какой-то файл, давайте мы этот файл теперь как-нибудь загрузим и выполним. Для
[40:02.360 --> 40:12.560]  этого будем использовать обычный MAP, вот вся программа, которая это делает. Так, не обращаю
[40:12.560 --> 40:17.640]  внимания на загрузочные файлы, то есть мы хотим запустить некоторую функцию, которая принимает double,
[40:17.640 --> 40:26.160]  возвращает double. Соответственно нам нужно получить адрес этой функции, сделать каст указателю на
[40:26.160 --> 40:34.360]  функции и дальше эту функцию после каста просто взять и выполнить. Так, ну а получить указатель
[40:34.360 --> 40:40.880]  начала функции можем следующим образом. Мы должны загрузить какой-то файл, либо сразу
[40:40.880 --> 40:48.160]  взаимапить, обязательно указать protExec, что вообще означает protRead или protExec,
[40:48.160 --> 40:57.240]  это означает, что у вас памяти доступно для чтения и для выполнения. Соответственно
[40:57.240 --> 41:07.080]  получаем функцию и эту функцию просто выполняем. Так, ну а что мы туда должны загрузить, что означает
[41:07.080 --> 41:13.760]  выполнить какой-то код? Наша функция должна содержать не начало вот этого файла, она должна
[41:13.760 --> 41:24.200]  содержать что-то, что начинается с байта D10083FF. Как отсюда это все извлечь? У нас есть объектный
[41:24.200 --> 41:30.120]  файл, который получен компилятором, а мы хотим вытащить только этот код. Я вам это уже показывал на
[41:30.120 --> 41:49.160]  лекциях, хотя бы на звание команды. Что? ObjCopy. ObjCopy это команда для манипуляции объектными файлами,
[41:49.160 --> 41:57.080]  если вы посмотрите man, либо help, он будет огромный, там куча всяких возможностей, которые не факт,
[41:57.080 --> 42:03.920]  что вам понадобится. Итак, самые основные опции, которые понадобятся нам для того, чтобы что-то
[42:03.920 --> 42:11.000]  отсюда извлечь. Minus j мы хотим взять только определенную секцию, которая называется точка текста.
[42:11.000 --> 42:17.720]  Это, кстати, ограничение, почему через мап трудно загружать какой-то исполняемый код,
[42:17.720 --> 42:24.640]  потому что есть еще куча других полезных секций и надо с ними тоже что-то делать. Так,
[42:24.680 --> 42:31.240]  минус O большое, это формат, в который нужно сконвертировать, прикопировать. И форматы,
[42:31.240 --> 42:36.720]  тут всякие разные, supported targets, меня интересует формат, который называется binary, это просто
[42:36.720 --> 42:48.080]  plain binary без всяких заморочек. Имя исходного файла объектного и имя файла, в котором мы хотим
[42:48.080 --> 42:57.240]  что-то записать, пусть будет функция B. Так, получаем файл, который имеет размер 56 байт. Похоже
[42:57.240 --> 43:08.600]  это на правду или не похоже, это мы можем выяснить, если посмотрим. Раз, два, три, четыре, пять, шесть,
[43:08.600 --> 43:16.520]  семь, восемь, девять, десять, одиннадцать, тринадцать, четырнадцать строк. Кто в голове быстро умножает?
[43:16.520 --> 43:28.040]  56, ладно. Действительно, 56 байт, можно еще посмотреть hexdump этой функции. Так,
[43:28.040 --> 43:40.440]  начинается с... hexdump вредная, конечно, команда, она делает реверс. Так, D1, 0, 0, 8, 3, F, F. Ну да,
[43:40.440 --> 43:51.560]  похоже на правду. Так, заканчивается все на D6, 5F, 0, 3, C0. Да, вот, это только содержимое нашей
[43:51.560 --> 43:58.120]  исполневой функции. Ну окей, теперь, что там требовалось? Так, первый аргумент это имя файла.
[43:58.120 --> 44:08.160]  А, еще надо скомпилировать это все. Так, компилируем, запускаем теперь наш код. Скоро мы первый аргумент
[44:08.160 --> 44:18.240]  это имя файла с функции, второй аргумент это аргумент нашей функции, что-то типа 100, и получаем
[44:18.240 --> 44:25.840]  значение функции. А функцией, напомню, исходно была вот такая F-32, и, соответственно, если мы
[44:25.840 --> 44:40.440]  запустим эту функцию с аргументом 451, мы получим 232. Никому эти цифры ни о чем не говорят. У кого в
[44:40.440 --> 44:50.520]  школе был кумир? О, одного человека был. Помните, там был робот такой. Так вот, у робота была штуковина
[44:50.520 --> 45:00.320]  измерить температуру. И если вы пытались измерить температуру больше чем 232, у вас программа ломалась.
[45:00.320 --> 45:07.440]  Как вы думаете, почему? Потому что в таких условиях роботы не живут. Это сделано из
[45:07.440 --> 45:16.520]  педагогических соображений. Что это вообще за числа такие 451? 451 градус по Фаренге,
[45:16.520 --> 45:23.240]  то она же 232 градуса по Цельсию. Это температура, когда воспламеняется бумага. Ну и, соответственно,
[45:23.240 --> 45:31.080]  если бумага горит, то можно считать, что жизнь уже закончилась. Так, ладно, мы загрузили что-то
[45:31.080 --> 45:36.360]  через МАП. Почему мы это смогли сделать? Во-первых, у нас тут только одна функция. Функции, на самом деле,
[45:36.360 --> 45:42.360]  может быть, несколько. И тогда придется уже аккуратно разбираться адрес начала каждой конкретной
[45:42.360 --> 45:48.040]  функции. Для этого нужна таблица символов. У нас может быть несколько секций, а не только секция
[45:48.040 --> 45:55.320]  с кодом. И вообще много всего остального. Поэтому в реальной жизни с МАП можно поразвлекаться. Но самое
[45:55.320 --> 46:04.200]  главное, почему про это нужно знать. Потому что МАП — это некоторый базовый инструмент, но на самом
[46:04.200 --> 46:10.560]  деле в реальной жизни он не используется. Но зато позволяет не делать никакие новые системные вызовы
[46:10.560 --> 46:17.880]  для того, чтобы делать динамическую загрузку библиотека. В реальной жизни в POSIX API есть две функции,
[46:17.880 --> 46:27.640]  точнее, три. DLopen и DLC, которые загружают какие-то исполняемые модули, в частности библиотеки,
[46:27.640 --> 46:36.720]  и позволяют находить в них отдельные символы, таблицы символов, то есть указатели на функции.
[46:36.720 --> 46:43.040]  Почему это сделано в виде именно библиотечных функций, а не системных вызовов? Потому что,
[46:43.040 --> 46:48.400]  по сути, здесь не надо постоянно лазить в ядро. От ядра нам требуется только открытие файла и
[46:48.400 --> 46:55.640]  только МАП. Я вам уже показал, как используется МАП, и в рантайме нужно загрузить файл,
[46:55.640 --> 47:05.240]  дальше его аккуратно распарсить. На самом деле, опять же, в библиотеке DL это делается не вручную,
[47:05.240 --> 47:12.640]  есть другие сторонние библиотеки, которые парсят L-файлы, и в конечном итоге мы можем открыть
[47:12.640 --> 47:21.160]  библиотеку, и в открытой библиотеке мы можем найти какой-то символ по имени. Что такое символ?
[47:21.160 --> 47:28.600]  Это просто название функции в сишном синтаксисе. Есть еще функции на языке C++, есть функции на
[47:28.600 --> 47:38.080]  языке GoLang, и там немножко сложнее. Чем хорош это API? Он существует, на самом деле, не только в POSIX,
[47:38.080 --> 47:44.440]  в Windows тоже есть похожие функции, которые ведут себя, на удивление, аналогичным образом,
[47:44.440 --> 47:51.200]  просто называются по-другому. Что означает название h модуле все большими буквами? Это
[47:51.200 --> 47:59.080]  просто void звездочка. Что такое LPC str все большими буквами? Это const char звездочка. В Windows,
[47:59.080 --> 48:05.000]  конечно, немного странный программный интерфейс, к нему надо привыкать, но, на удивление, под Windows
[48:05.000 --> 48:11.360]  все то же самое будет работать, как и в POSIX, просто немного другими названиями. Ну и как этой
[48:11.360 --> 48:18.840]  штуковиной теперь можно пользоваться? Я вижу кого-то из 29 группы, у кого вчера был семинар,
[48:18.840 --> 48:29.360]  поэтому вы сейчас будете скучать и спать. Показываю для всех остальных. Как этим всем пользоваться?
[48:29.360 --> 48:49.640]  Допустим, ух, можно сделать шифт поменьше, иначе не лазит. Видно? Так, с помощью Daily Open мы открываем
[48:49.640 --> 48:58.080]  какую-то библиотеку, указывая в качестве обязательного аргумента имя файла. На самом деле,
[48:58.080 --> 49:03.720]  здесь что может быть под названием библиотеки? Это может быть абсолютное имя файла, это может
[49:03.720 --> 49:11.320]  быть относительное имя файла, либо просто название библиотеки без пути. В данном случае библиотека
[49:11.320 --> 49:17.680]  будет найдена под тем же самым правилом, что и библиотека при запуске программы. То есть просматриваются
[49:17.680 --> 49:26.920]  перемены окружения ld library pass, просматриваются конфиги lds soconf и так далее. После загрузки библиотеки
[49:26.920 --> 49:37.160]  вы ищете символ с определенным именем, используя dl sim. Что Daily Open, что dl sim возвращает ввод
[49:37.160 --> 49:44.200]  звездочка, который вы можете прикосновать чему угодно. Ну и в случае успеха вы можете по адресу
[49:44.200 --> 49:57.520]  функции уже что-то вызвать. Ладно, посмотрим это на практике. Так, ну для линковки здесь под
[49:57.520 --> 50:09.960]  Linux требуется LDL, под Mac это не требуется. Так, скомпилировали, запускаем. Так, но я поставил
[50:09.960 --> 50:15.320]  лидия паузы, чтобы можно было исследовать поведение нашей программы, а исследовать мы будем в другой вкладке.
[50:15.320 --> 50:38.040]  Для этого я выясню процесс ID 660797 и посмотрим на карту памяти для этого процесса.
[50:38.040 --> 50:54.800]  Ой, ужасно, ничего не видно. Ладно, сделаем тогда вот следующим образом. Нана, насколько я помню,
[50:54.800 --> 51:02.080]  в прошлый раз выглядела нормально. Нет, выглядит конечно ужасно. Так, ладно, давайте не будем ничего
[51:02.080 --> 51:08.320]  исследовать. Или я могу сделать просто мелкий шрифт, потом посмотреть в записи.
[51:08.320 --> 51:18.160]  Вам уже скучно стало. Так, что я хотел показать. Вот вы загрузили библиотеку, что нас ожидается
[51:18.160 --> 51:27.680]  увидеть в карте памяти. В карте памяти? Ладно, давайте я сделаю все-таки мелкий шрифт,
[51:27.680 --> 51:37.120]  посмотреть потом в записи. Если ломаете глаза, лучше их закройте. Запустили программу, мы видим
[51:37.120 --> 51:44.040]  в зависимости, в карте памяти у нас подгружена стандартная сибиблиотека, загружена библиотека
[51:44.040 --> 51:52.040]  DL, которая содержит реализацию функции DL open и так далее, загрузчик LDSO, стэк, ну все плюс-минус
[51:52.040 --> 51:58.160]  стандартно. Если у вас система x86, а не ARM, как у меня, то скорее всего с библиотеки будут идти выше,
[51:58.160 --> 52:07.400]  чем стэк. Они ниже. Так, теперь мы загружаем библиотеку. Она у нас загружена по какому-то адресу,
[52:07.400 --> 52:19.120]  что у нас при этом поменялось в карте памяти. Так, поменялось то, что у нас появилась какая-то
[52:19.120 --> 52:26.680]  библиотека, точнее ничего не появилось, это какой-то мусор, потому что я не указал
[52:26.680 --> 52:33.520]  аргумент командной строки. Так, аргументы, название библиотеки и название функций плюс аргумент.
[52:33.520 --> 52:42.320]  Так, dipm.iso, функция пусть называется sin и аргумент 0. Ладно, попытка номер два.
[52:42.320 --> 52:59.240]  Здесь поменялся, естественно, process ID. Так, вот мы запустили, теперь загружаем библиотеку. Вот она
[52:59.240 --> 53:07.920]  загружена по какому-то адресу. И библиотеку libm мы теперь можем действительно наблюдать. Она загружена,
[53:07.920 --> 53:15.240]  если x86, то ниже области стека. Почему? Потому что стек у нас уже выделен, какие-то библиотеки у нас
[53:15.240 --> 53:21.960]  загружены, и где мы можем подгружать новые библиотеки. Очевидно, уже ниже стека. На самом деле,
[53:21.960 --> 53:26.760]  если используется позиционный независимый код, то это не особо принципиально. Библиотеки
[53:26.760 --> 53:33.600]  можно загружать абсолютно куда угодно, в совершенно рандомное место. Только вот адреса загрузки у нас
[53:33.600 --> 53:38.960]  всё-таки немножко отличаются от того, что мы видим в качестве возвращаемого значения
[53:38.960 --> 53:48.960]  dlopen. Потому что dlopen просто на куче размещает метаинформацию про библиотеку, и это содержимое
[53:48.960 --> 53:57.360]  никак не связано с содержимым файлов библиотеки. Дальше находим какую-то функцию sin. А вот указатель
[53:57.400 --> 54:06.720]  на функцию sin, он уже попадает на часть загруженной библиотеки с правами чтения и исполнения. Ну и
[54:06.720 --> 54:16.480]  честно выполняем функцию sin. Все верят, что sin0 это 0. Аналогичное мы можем сделать для
[54:16.480 --> 54:32.760]  косинуса. cos0 это единица. 3,14,159. cos3,14,159-1. Вроде тоже похоже на правду.
[54:32.760 --> 54:49.320]  Ну и зачем вообще это нужно? В языке Python вы пишете импорт. В каком случае происходит
[54:49.320 --> 55:01.040]  реальный импорт какого-то файла? Вот чем удобен Python вы можете написать огромное количество импортов
[55:01.040 --> 55:06.920]  в вашей программе, но реально все будет происходить именно в момент выполнения этого кода. Более того,
[55:06.920 --> 55:14.600]  есть еще импорт лип, который позволяет динамически создавать модули и загружать. Достаточно
[55:14.600 --> 55:21.160]  гибкая штуковина, потому что вся стандартная библиотека и все сторонние библиотеки совершенно
[55:21.160 --> 55:26.120]  необязательно вам могут понадобиться сразу. Совершенно необязательно они вам могут понадобиться
[55:26.120 --> 55:33.080]  когда-нибудь. Они могут понадобиться при каких-то определенных условиях. Еще более
[55:33.080 --> 55:38.720]  понятный и распространенный пример это система плагинов. Что такое плагин я думаю объяснять не
[55:38.720 --> 55:45.240]  нужно. Вот как бы вы стали их реализовывать. Очевидно плагин это что-то, что хранится в
[55:45.240 --> 55:50.520]  отдельном файле, который вы загружаете по мере необходимости, например исходя из какой-то
[55:50.520 --> 55:59.600]  конфигурации запуска программы, либо по требованию пользователя. Кроме того, у вас могут быть какие-то
[55:59.600 --> 56:06.600]  нестандартные ситуации про расположение библиотек, в том числе если вы на лету загружаете что-то из
[56:06.600 --> 56:13.440]  интернета, запускаете, ну потом библиотек возможно удаляете, либо оставляете для работы дальше.
[56:13.440 --> 56:18.640]  Вот для всех этих ситуаций вам требуется динамическая загрузка уже после выполнения
[56:18.640 --> 56:24.960]  программы. И для этого как раз используется, на самом деле часто используются всякие
[56:24.960 --> 56:32.640]  высокоуровневые средства, но в их основе все равно лежат функции dellopen, dellsim,
[56:32.640 --> 56:40.960]  ну либо в случае с windows это luad library. Тут есть некоторые побочные эффекты, раз уж мы питон
[56:40.960 --> 56:50.800]  вспомнили, вот что сделает эта программа на питоне. Вы объявляете какую-то функцию, вот чем хороши языки
[56:50.800 --> 56:58.080]  типа питона. Мы можем обсуждать, чем они плохи, собственно курс о косу этому посвящен, но есть
[56:58.080 --> 57:06.480]  и положительные моменты, в частности всякие способы выстрелить себе в ногу, залезть в словарь
[57:06.480 --> 57:14.480]  глобальных имен, что-то в нем натворить, либо просто достать оттуда что-нибудь просто по строковому
[57:14.480 --> 57:22.280]  литералу. В частности вы можете объявить какую-то функцию, любую переменную, зайти в globals и найти
[57:22.280 --> 57:32.560]  функцию произвольную, дальше ее выполнить. Можно ли тоже сами сделать на оси или на плюсах? Нельзя, да?
[57:32.560 --> 57:49.840]  А может можно? Да, вот на самом деле можно. Есть dlopen, dlsim. Так, теперь, как это все-таки можно
[57:49.840 --> 58:00.120]  сделать на оси и на c++? У dlopen есть одна особенность, под windows, кстати, у luad library тоже, что если вместо
[58:00.120 --> 58:07.120]  имени укажется нолевой указатель, то здесь это корректная ситуация, и в данном случае возвращается
[58:07.120 --> 58:13.560]  описание метаинформации для текущего модуля. Текущий модуль имеется в виду текущий lfile. Если это
[58:13.560 --> 58:19.840]  является программой, то указатель на программу, если вы этот код запускаете из какой-то подлинкованной
[58:19.840 --> 58:28.120]  библиотеки, то соответственно ссылка на библиотеку, и если у вас есть кайт с библиотекой, который вам
[58:28.120 --> 58:37.800]  вернуло dlopen, вы можете через dlsim найти какую-то функцию произвольную, просто по ее имени, обычной
[58:37.800 --> 58:45.160]  конс-чар-звёздочкой, либо std string, и дальше эту функцию вызвать по указателю. То есть все то же
[58:45.160 --> 58:53.120]  самое, все те же самые динамические возможности интроспекции, как и Python. Ну, почти. Для этого вам
[58:53.120 --> 58:59.320]  требуется, наверно, чтобы все-таки таблица символов у нас всегда была. Для библиотек таблица символов
[58:59.320 --> 59:07.000]  это стандартная практика, а вот у исполняемых файлов таблица символов обычно отсутствует. Зачем
[59:07.000 --> 59:13.160]  таблица символов исполняемому файлу? Тем не менее, если внимательно почитать манн на команду ld,
[59:13.160 --> 59:20.720]  на линковщик, там можно найти опцию, которая называется либо "-e", либо экспорт-динамик. В описании
[59:20.720 --> 59:25.840]  написано, что эта опция заставляет линковщик добавлять все символы в экспортированную динамическую
[59:25.840 --> 59:33.040]  таблицу. Если испортить этот факт, то можно тут нахулиганить и сделать точно такой же способ
[59:33.040 --> 59:41.560]  поведения, как в Python. Так, ну давайте опять же рассмотрим такой пример. Так,
[59:41.560 --> 59:53.440]  пример программы. У нас есть две функции. Одна функция называется кошечка, другая функция
[59:53.440 --> 01:00:01.080]  называется собачка. Кошечка говорит мяу, пёсель гавкает. Соответственно, можем ли мы,
[01:00:01.080 --> 01:00:08.520]  зная название функций, вызвать какую-то правильную функцию? Ответ да, можем сделать точно так же,
[01:00:08.520 --> 01:00:15.920]  как в Python. Для этого что нам нужно сделать? У нас есть некоторая строка чарная, которая содержит
[01:00:15.920 --> 01:00:22.520]  название функции. Сначала мы получаем доступ к нашему исполняемому файлу с помощью del open,
[01:00:22.520 --> 01:00:28.880]  и самое главное, что аргументом является нулевой указатель. Соответственно, del open возвращает нам
[01:00:28.880 --> 01:00:35.600]  указатель на текущий исполняемый файл, который в свою очередь содержит функции cat и doc. Дальше
[01:00:35.600 --> 01:00:43.800]  находим в этом исполняемом файле нужную нам функцию и спокойно ее выполняем. Казатель,
[01:00:43.800 --> 01:00:52.880]  все хорошо, все будет работать точно так же, как на Python. Ну окей, давайте это все проверим.
[01:00:52.880 --> 01:01:15.720]  Компилируем, запускаем. Вот так вот, любители котиков. Что у нас пошло не так и почему? У нас
[01:01:15.720 --> 01:01:22.200]  нет таблиц символов, поэтому del sim нам честно вернул нулевой указатель, который не обрабатывается,
[01:01:22.200 --> 01:01:31.200]  получаем segmentation fold. Так, ну и как ситуацию исправить? Мы модифицируем опции пенковщика,
[01:01:31.200 --> 01:01:39.040]  заставляем его в наш исполняемый файл добавить все экспортируемые символы точно так же,
[01:01:39.040 --> 01:01:49.400]  как это было бы для библиотек. И вот теперь, так, ну что, песель на этот раз? Песель заработал.
[01:01:49.400 --> 01:02:01.520]  Ну и котик, в принципе, тоже ничем не хуже песеля. Так, ну вот, обратили внимание, что я здесь добавил
[01:02:01.520 --> 01:02:09.360]  опцию –wl, запятая та опция, которую нужно было скормить ливточкой hd, то есть –e. И здесь
[01:02:09.360 --> 01:02:16.200]  напрашивается, кстати, вот такой эффект. Если у нас есть исполняемый файл, который может содержать
[01:02:16.200 --> 01:02:24.520]  таблицу символов, на что это исполняемый файл похож? На чей-то на библиотеку. А если у нас в библиотеке
[01:02:24.520 --> 01:02:32.200]  есть функция под названием подчеркивание start, на что эта библиотека похожа? На исполняемый файл.
[01:02:32.200 --> 01:02:36.640]  То есть, на самом-то деле, кто нам мешает делать какие-то гибридные универсальные l-файлы,
[01:02:36.640 --> 01:02:44.880]  которые ведут себя и как библиотеки, и как обычно исполняемые файлы? Ну, чтобы не полонить лишние файлы,
[01:02:44.880 --> 01:02:48.640]  не полонить лишние сущности. На самом деле достаточно удобно сделать программу,
[01:02:48.640 --> 01:02:58.440]  которую можно использовать с предоставлением некоторого API. Мешает нам вот что. Несколько лет
[01:02:58.440 --> 01:03:04.760]  назад я студентам показывал вот такую опцию командной строки, которая позволяла создать
[01:03:04.760 --> 01:03:14.160]  вот такие гибридные файлы. Но в последних сборках стандартной C-библиотеки эту лавочку прикрыли. На
[01:03:14.160 --> 01:03:19.560]  самом деле это не штатная функциональность. И DL Open теперь просто ругается, что, извините,
[01:03:19.560 --> 01:03:27.640]  вы мне почему-то подсунули исполняемый файл вместо того, чтобы скормить мне библиотеку. Эта штука
[01:03:27.640 --> 01:03:33.880]  перестала работать, и вот такая опция больше, ну все, лавочка не работает. Как же нам все-таки
[01:03:33.880 --> 01:03:41.640]  сделать исполняемый файл, который ведет себя одновременно и как библиотека, и как исполняемый
[01:03:41.640 --> 01:03:53.200]  файл. Возможно ли это все-таки или нет. Но было бы, наверное, удобнее. На самом деле можно. Есть
[01:03:53.200 --> 01:04:02.880]  некоторые хаки. Так, что нам для этого нужно? Для этого нам нужно внимательно почитать MAN на
[01:04:02.880 --> 01:04:19.840]  линковщик LD. Итак, вот у нас есть файл простой. Так, и здесь требуются некоторые нестандартности.
[01:04:19.840 --> 01:04:24.040]  С одной стороны, мы хотим получить библиотеку, которая экспортирует функцию под названием Function,
[01:04:24.040 --> 01:04:29.880]  чтобы можно было эту функцию использовать где-то извне. С другой стороны, нам хотелось бы эту
[01:04:29.880 --> 01:04:36.600]  библиотеку использовать как обычный исполняемый файл. Ладно, давайте мы ее скомпилируем как библиотеку,
[01:04:36.600 --> 01:04:48.960]  то есть собственной shared, какой-то ELF файл, не важно как называется. Так, и сделаем это все из файла
[01:04:48.960 --> 01:04:54.680]  по названиям main.7. На самом деле линкового мейна здесь нет. Так, вот мы получили библиотеку,
[01:04:54.680 --> 01:05:05.280]  файл по названиям ELF, который ведет себя странно, не запускается, явно делает что-то не то. Так,
[01:05:05.280 --> 01:05:17.440]  но тем не менее мы можем теперь запустить наш любимый Python, написать import ctypes,
[01:05:17.440 --> 01:05:33.960]  дальше ctypes.luats library, знакомое название. Это название API Windows, то есть понятно,
[01:05:33.960 --> 01:05:41.960]  кто проектировал этот модуль, любители Windows. Загружаем наш файл по относительному имени,
[01:05:41.960 --> 01:05:49.600]  он даже честно загрузился. У нас там есть функция, которую мы можем найти под названием function,
[01:05:49.600 --> 01:05:56.880]  и эту функцию мы можем запустить. Она говорит, да, я действительно являюсь функцией. То есть на самом
[01:05:56.880 --> 01:06:02.560]  деле как библиотеку мы ее честно скомпилировали, понятно почему, потому что опция shared. Так,
[01:06:02.560 --> 01:06:14.600]  хорошо, давайте теперь еще раз внимательно посмотрим на исходник. Аут 16, это рандом,
[01:06:14.600 --> 01:06:23.360]  который остался от puts. То есть по умолчанию ctypes модуль Python подразумевает, что функция
[01:06:23.360 --> 01:06:32.520]  принимает аргументы типа int, неважно сколько их, и возвращает тоже int. Там у нас был мусор,
[01:06:32.520 --> 01:06:40.200]  который остался от функции puts, но видимо 16 символов, который потом оказался как возвращаемое
[01:06:40.200 --> 01:06:46.520]  значение нашей функции. В Python можно тут еще прописать, откройте документацию на ctypes,
[01:06:46.520 --> 01:06:53.280]  потому что это уже off-top, там есть параметры restype у функций и параметр argtypes, их можно
[01:06:53.280 --> 01:06:59.040]  специализировать, тогда все будет работать. Но по идее на семинарах вас тоже нужно показать. Так,
[01:06:59.040 --> 01:07:03.880]  ладно, давайте вернемся еще раз к нашему исходному коду, в котором я дописал что-то не
[01:07:03.880 --> 01:07:12.320]  стандартное, а именно функцию под названием custom.start, которая является фактически заменой точки
[01:07:12.320 --> 01:07:24.080]  входа. И при компиляции мы можем что-то дописать в секции lfile, в частности есть такая штука,
[01:07:24.080 --> 01:07:30.240]  как точка входа, и кстати точка входа совсем не обязательно может быть именно подчеркивание
[01:07:30.240 --> 01:07:45.080]  start. Для любой программы вы можете переопределить точку входа и получить какой-то исполняемый файл с
[01:07:45.080 --> 01:07:52.960]  нестандартной точкой входа. Как нам только его теперь запустить? Запуститься он уже должен. Так,
[01:07:52.960 --> 01:08:00.240]  запускаем, и за счет чего он работает? Что происходит при запуске библиотеки? Вообще,
[01:08:00.240 --> 01:08:11.160]  при обработке любого lfile. У каждого lfile есть секция, которая называется интерпретатор.
[01:08:11.160 --> 01:08:19.200]  Интерпретатор lfile как-то странно звучит, да? Ну, такая вот терминология. Два подчеркивания
[01:08:19.200 --> 01:08:24.600]  атрибут, два подчеркивания, дальше секция. Во-первых, что означает два подчеркивания атрибу,
[01:08:24.600 --> 01:08:30.800]  два подчеркивания, дальше две скобочки, что-то там, две скобочки закрываются. Это нестандартные
[01:08:30.800 --> 01:08:36.440]  возможности компиляторов GCC и Selang. Ну, насколько нестандартные? Они существуют уже много лет,
[01:08:36.440 --> 01:08:43.440]  и маловероятно, что кто-то их сломает. Атрибут section и в кавычках название секции означает,
[01:08:43.440 --> 01:08:50.520]  в какую секцию исполняемого файла именованную нужно положить ту или иную переменную, либо даже
[01:08:50.520 --> 01:09:02.960]  функцию. Так вот, секция interrupt для lfile. Это entry point 734, это как раз указатель на custom.
[01:09:02.960 --> 01:09:11.520]  Entry point, интерпретатор, это исполняемый файл, который на самом деле явно захардкожен в lfile.
[01:09:11.520 --> 01:09:17.840]  Он является обычно специфичным для каждого линукс-дистрибутива, даже не дистрибутива,
[01:09:17.840 --> 01:09:25.200]  для каждого поколения линукс-дистрибутивов, там плюс-минус несколько лет, и архитектуре
[01:09:25.200 --> 01:09:31.400]  процессора. То есть у вас там, скорее всего, будет x8664, если не Macом 1, не разбери Pi.
[01:09:31.400 --> 01:09:38.560]  То есть что у нас происходит? На самом деле, вот этот интерпретатор, это честно какая-то команда,
[01:09:38.560 --> 01:09:45.440]  которую можно запустить. И эта команда принимает в качестве аргумента исполняемый файл, является
[01:09:45.440 --> 01:09:51.760]  ничем иным, как тем самым ldso, который выполняет поиск всех библиотек, загрузку программы в память
[01:09:51.760 --> 01:10:00.320]  и передачу выполнения. Если вот эту штуку не прописать, то будет непонятно, как библиотеку
[01:10:00.320 --> 01:10:07.560]  запускать. Для библиотек это поле пустое, а для исполняемых файлов не пустое.
[01:10:07.560 --> 01:10:13.960]  Тем самым мы все-таки можем обмануть систему и сделать гибрид, который будет
[01:10:13.960 --> 01:10:25.440]  запускаться и как исполняемый файл, и в том числе мы можем теперь без потери функциональности
[01:10:25.440 --> 01:10:38.040]  использовать его как библиотеку. Давайте уже честно допишу func restypes,
[01:10:38.040 --> 01:10:45.000]  рестypes определю как ctypes. Возвращаемого типа у него нет,
[01:10:45.000 --> 01:11:05.240]  и func archetypes никаких аргументов нет.
[01:11:15.000 --> 01:11:35.240]  Файл себя ведет и как программа, и как обычная библиотека.
[01:11:35.240 --> 01:11:43.560]  Что еще можно вытворять, используя вот эти самые атрибуты?
[01:11:43.560 --> 01:11:49.000]  Синдекс есть еще раз, два подчеркивания, атрибут два подчеркивания, дальше две скобочки,
[01:11:49.000 --> 01:11:57.560]  потом что-то, потом две скобочки. Это вещь вне стандартов языка C и C++, просто устоявшаяся
[01:11:57.560 --> 01:12:03.560]  традиция. Почему именно такие страшные названия? Для того, чтобы случайно не использовать в каких-то
[01:12:03.560 --> 01:12:10.200]  легальных конструкциях, не придумать имя с похожим названием, чтобы случайно на это не наступить.
[01:12:10.200 --> 01:12:17.240]  Поскольку вещи вне стандартов, но при этом поддерживаются как компиляторами C, GC, так и C lang,
[01:12:17.240 --> 01:12:25.560]  есть еще очень полезные атрибуты у разных функций, которые свойственны различным модулям,
[01:12:25.560 --> 01:12:33.080]  в том числе библиотекам. Это конструкторы и деструкторы для исполняемых файлов. Что такое
[01:12:33.080 --> 01:12:38.480]  конструктор? Это штука, на которой выполняется при загрузке модуля. Деструктор, очевидная штука,
[01:12:38.720 --> 01:12:47.640]  выполняется при выгрузке модуля. В том числе эта штука работает с библиотеками. Конструктор
[01:12:47.640 --> 01:12:52.760]  вызывается при попытке загрузить библиотеку. Если происходит успешная загрузка, то сначала
[01:12:52.760 --> 01:12:59.360]  выполняется инициализер, который объявлен на атрибутах конструктор. Когда вы библиотеку выгружаете,
[01:12:59.360 --> 01:13:10.000]  то у вас выполняется функция деструктор. Итак, демонстрация конструктора и деструктора.
[01:13:10.000 --> 01:13:22.480]  Выглядит файл модуля очень простым образом. Есть какая-то функция,
[01:13:22.480 --> 01:13:28.520]  которую можно вызывать сколько угодно раз. Есть конструктор, который выполняется один раз.
[01:13:28.520 --> 01:13:34.280]  Есть деструктор, который может быть либо выполнен, либо не выполнен. Отчего это зависит?
[01:13:34.280 --> 01:13:43.400]  Когда вы пытаетесь закрыть библиотеку, уменьшается количество ссылок на ее использование и библиотека
[01:13:43.400 --> 01:13:48.040]  реально выгружается только тогда, когда больше никакая часть программы эту библиотеку не использует.
[01:13:48.040 --> 01:13:56.640]  Урон в этот момент может быть выполнена какая-то финализация. Компилируем этот модуль.
[01:13:56.640 --> 01:14:14.760]  Надо еще не забывать вот такую опцию, особенно если используются внешние функции.
[01:14:14.760 --> 01:14:24.080]  Модуль скомпилировали. Загружаем мы обычным дель опеном. Примерно, что я вам показывал,
[01:14:24.080 --> 01:14:31.040]  есть функция дель опен для файла, дель сим для имени функции. Название функции мы знаем.
[01:14:31.040 --> 01:14:38.080]  Давайте потом выгрузка с помощью дель close. Скомпилирую теперь раундер.
[01:14:38.080 --> 01:14:53.080]  Функция называлась function. Обратите внимание, что я явным образом не вызываю функции
[01:14:53.080 --> 01:15:06.080]  финализации и финализации. Тем не менее, они у нас будут явным образом все равно вызваны.
[01:15:06.080 --> 01:15:15.080]  Why? Потому что я не указал правильное имя файла. Так, что у нас происходит?
[01:15:15.080 --> 01:15:21.080]  У нас окружается библиотека. После того, как она именно в момент вызова дель опен,
[01:15:21.080 --> 01:15:27.080]  у нас выполняется произвольная функция этой библиотеки, которая помещена атрибутом конструктор.
[01:15:27.080 --> 01:15:34.080]  Дальше можем выполнять какие-то произвольные функции, творить все что угодно.
[01:15:34.080 --> 01:15:42.080]  В тот момент, когда мы делаем выгрузку библиотеки с помощью дель close, у нас вызывается функция,
[01:15:42.080 --> 01:15:50.080]  особенно атрибутом, деструктор. Но не факт, что это у вас в общем случае всегда будет происходить.
[01:15:50.080 --> 01:15:56.080]  Так, слова конструктор, деструктор, они вообще откуда взялись?
[01:15:56.080 --> 01:16:06.080]  Языка C++. И последнее на сегодня, язык C++. На самом деле, я вам показываю примеры на языке C,
[01:16:06.080 --> 01:16:12.080]  который содержит таблицу символ с C-шными именами. Все то же самое будет работать с плюсами.
[01:16:12.080 --> 01:16:20.080]  Тут есть одни маленькие тонкости. В плюсах есть namespaces, там есть классы, всякие перегрузки функций,
[01:16:20.080 --> 01:16:26.080]  много всего остального. Для того, чтобы разрешать всякие разные неоднозначности,
[01:16:26.080 --> 01:16:36.080]  имена в таблице символов кодируются достаточно страшным образом. Подчеркиваем Z, дальше abracadabra.
[01:16:36.080 --> 01:16:44.080]  И в этой abracadabra в принципе можно разглядеть исходные имена namespaces, классов и так далее.
[01:16:44.080 --> 01:16:55.080]  Чем плох такой способ кодирования? Плохом тем, что он является стандартом для GCC, Selang, Intel Compiler.
[01:16:55.080 --> 01:17:04.080]  Все это работает в Unix-подобных системах. Под Windows уже не так все хорошо. Там в MinGV один стиль.
[01:17:04.080 --> 01:17:09.080]  Microsoft имеет совершенно другие представления о том, как нужно кодировать имена.
[01:17:09.080 --> 01:17:15.080]  Вообще в целом никакого единого стандарта на способ именования не существует.
[01:17:15.080 --> 01:17:19.080]  Что-то похожее используется в том числе в языке программирования Rust.
[01:17:19.080 --> 01:17:25.080]  Когда вы компилируете программу на Rust, у вас все функции превращаются в какие-то страшные имена,
[01:17:25.080 --> 01:17:31.080]  которые вообще там хэши содержат. Что-то похожее есть в Go, но там, правда, не так страшно.
[01:17:31.080 --> 01:17:37.080]  В общем, есть разные способы для разных языков программирования, как закодировать имена.
[01:17:37.080 --> 01:17:44.080]  И если вы знаете этот способ, то вы можете смешивать программу на разных языках программирования,
[01:17:44.080 --> 01:17:47.080]  загружать библиотеки откуда угодно.
[01:17:47.080 --> 01:17:51.080]  В том числе вызывать различные конструкты.
[01:17:51.080 --> 01:17:57.080]  И вот на самом деле вся эта история, что я вам показываю в создании генетической загрузки библиотек,
[01:17:57.080 --> 01:18:01.080]  она к плюсам имеет большее применение, чем к языку C.
[01:18:01.080 --> 01:18:07.080]  Потому что использовать на плюсах плагины это более осмысленно.
[01:18:07.080 --> 01:18:11.080]  Вы можете контролировать полный жизненный цикл.
[01:18:11.080 --> 01:18:15.080]  И вы какие-нибудь фреймворками, библиотеками на плюсах пользуетесь?
[01:18:15.080 --> 01:18:19.080]  Или только стандартной C библиотекой в реальной жизни?
[01:18:19.080 --> 01:18:25.080]  Если пользуетесь, но можете порыться в документации ваша любимая фреймворка,
[01:18:25.080 --> 01:18:31.080]  скорее всего вы найдете что-то, что позволяет работать с механизмом плагинов.
[01:18:31.080 --> 01:18:35.080]  Механизм плагинов, по сути, вырождается в DL Open Delsie.
[01:18:35.080 --> 01:18:41.080]  На этом все. Как вы можете заметить, Рудали все хорошо обучается.
[01:18:41.080 --> 01:18:45.080]  И качество рисования картинок все лучше и лучше.
[01:18:45.080 --> 01:18:47.080]  Это вот библиотека.
[01:18:49.080 --> 01:18:51.080]  Красиво получилось.
[01:18:53.080 --> 01:18:57.080]  Да, выкатили, да, но непонятно, будет ли его адаптировать.
[01:18:57.080 --> 01:18:59.080]  Что-то непростая задача.
[01:18:59.080 --> 01:19:01.080]  Ладно, есть ли у вас вопросы?
[01:19:03.080 --> 01:19:05.080]  Ну тогда на сегодня все.
