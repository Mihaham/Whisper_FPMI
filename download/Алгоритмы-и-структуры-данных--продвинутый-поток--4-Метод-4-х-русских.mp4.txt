[00:00.000 --> 00:15.000]  Сегодня мы, по крайней мере, сколько-то времени, не гарантирую, что полностью, поговорим о такой замечательной штуке, как метод четырёхрусских.
[00:15.000 --> 00:24.000]  Вот. Как он, по крайней мере, известен в западноязычной литературе. Ну, впрочем, равно как и у нас. Как-то вот, стало привычно метод четырёхрусских.
[00:24.000 --> 00:30.000]  Ну, потому что, да, такие фамилии, как Динец, Кронрат, Фараджи, Фарлазаров, как мы уже обсуждали, это слишком сложно.
[00:30.000 --> 00:40.000]  Вот. Соответственно. Ну, что делать? Вот. То есть, кто-то, какой-то автор даже выражал недоумение по этому поводу.
[00:40.000 --> 00:46.000]  Потому что какие-то теоремы, которые там возникали в соответствующей статье, можно было просто называть теорему Кронрата.
[00:46.000 --> 00:52.000]  Потому что там даже статья утверждалась, что как бы эта статья имеет одного, там эта теорема имеет одного автора.
[00:52.000 --> 01:01.000]  Но, тем не менее. Вот. Значит, в чём же у нас будет заключаться метод?
[01:01.000 --> 01:11.000]  Так. Ну, мы его сегодня, конечно, рассмотрим на нескольких примерах. Вот. Так. Какие уже у нас будут примеры?
[01:11.000 --> 01:19.000]  Ой. Неожиданно весёлые. Вот. Ну, конечно, классический пример – это, конечно, алгоритм Фарах Колтон Бендера.
[01:19.000 --> 01:25.000]  Да. Почему-то этот алгоритм неизвестен как алгоритм двух американцев.
[01:25.000 --> 01:35.000]  Двух. Значит, Фарах Колтон – это двойная фамилия. Вот. Соответственно. Да.
[01:35.000 --> 01:43.000]  Вот. То есть классический пример. Ну, мы покажем всё. Ну, вот. Есть, конечно, там и другие примеры.
[01:43.000 --> 01:50.000]  То есть, вишенкой на торте у нас сегодня будет, собственно, неожиданно поиск наибольшей общей подпоследовательности. Внезапно.
[01:50.000 --> 01:53.000]  У меня челики заснова спрашивали, как решается.
[01:53.000 --> 01:59.000]  Ну, вот. Вот всё я тебе расскажу. Да. Соответственно. Вот.
[01:59.000 --> 02:05.000]  Ну, попробуем мы начать с кое-чего другого.
[02:05.000 --> 02:10.000]  Значит, смотрите. Начнём мы с перемножения матриц.
[02:10.000 --> 02:14.000]  Каких матриц? Правильно, битовых.
[02:14.000 --> 02:18.000]  И перемножение, естественно, булева.
[02:18.000 --> 02:25.000]  Чего? Ну, на ДФ2, если быть точнее. Да.
[02:25.000 --> 02:33.000]  Ну, то есть, в переводе к… Ну, да. То есть, фактически вместо умножения у нас будет операция И.
[02:33.000 --> 02:41.000]  Значит, вместо сложения операция или, на самом деле. Да. Или. Или, или.
[02:41.000 --> 02:44.000]  Да. Это булевое перемножение матриц.
[02:44.000 --> 02:53.000]  Чего? Да. Да. Это нексор. Да.
[02:53.000 --> 03:05.000]  Ну, на самом деле, могло быть и Ф2. Как вы видите, разницы, на самом деле, там, идеи на разнице особо никакой.
[03:05.000 --> 03:12.000]  Вот. Значит, вот у нас, допустим, есть две матрицы. Мы хотим сейчас перемножить.
[03:12.000 --> 03:20.000]  За какую точку мы умеем перемножить матрицы? Ну, стандартно, мы умеем за n куб, допустим, да?
[03:20.000 --> 03:29.000]  Да, у нас там есть какой-то там метод Штрассена. Но это мы обсудим чуть позже.
[03:29.000 --> 03:34.000]  Вот. Ну, теперь, значит, подумаем, вот о чём.
[03:34.000 --> 03:55.000]  Значит, как попытаться вообще это дело ускорить? Как попытаться ускорить там вот честные вычисления по формуле вида CITGT равно там, называется OR там, по всем k от 1 до n, там AITKT, там AND, там AKTGT.
[03:55.000 --> 03:57.000]  Вот. Это я просто вот определение написал.
[03:57.000 --> 04:01.000]  Вы хотите ускорять асимпатические или…
[04:01.000 --> 04:03.000]  Не, асимпатические, конечно.
[04:07.000 --> 04:22.000]  Ну, как сказать? Ну, можно сказать, получается, скорее переменная, потому что мы, наверное, будем вынуждены как-то поддерживать такую информацию о том, что, наверное, число n у нас всё-таки в битвое слово как-то вылезает.
[04:22.000 --> 04:23.000]  ЦВК.
[04:23.000 --> 04:24.000]  Да.
[04:24.000 --> 04:26.000]  А, вот это хорошо.
[04:26.000 --> 04:27.000]  Нет, не число n, а…
[04:27.000 --> 04:28.000]  Именно число.
[04:28.000 --> 04:38.000]  Нет, именно число… Да, само по себе число n. Ну, то есть, знаете, в первой строке входного файла записано там число n, да?
[04:38.000 --> 04:40.000]  Так вот, оно не 10 в сотый.
[04:40.000 --> 04:44.000]  Ну, или у вас там тысячиразрядный процессор там, я не знаю.
[04:44.000 --> 04:47.000]  Вот. Да. Ну, такое тоже бывает.
[04:51.000 --> 04:54.000]  Нет? Пока. Ну, пока, или ладно.
[04:54.000 --> 04:55.000]  Где?
[04:57.000 --> 04:58.000]  Чего?
[04:58.000 --> 05:00.000]  Нет, почему на себя?
[05:00.000 --> 05:03.000]  Нет, это я просто вторую не дорисовал. Перемножаем, мы их…
[05:03.000 --> 05:07.000]  Нет, на самом деле, тут у меня два ответа, на самом деле.
[05:07.000 --> 05:10.000]  Во-первых, перемножаем мы две разные матрицы.
[05:10.000 --> 05:13.000]  А во-вторых, на самом деле, без разницы.
[05:13.000 --> 05:17.000]  У вас просто написано там аид и академия.
[05:17.000 --> 05:18.000]  Да.
[05:18.000 --> 05:20.000]  А… Ой, да.
[05:20.000 --> 05:21.000]  Да, пардон.
[05:21.000 --> 05:28.000]  Хотя, на самом деле, в глобальном смысле, перемножать матрицы и возводить матрицу в квадрат – это одна и та же задача.
[05:31.000 --> 05:33.000]  Ну, вы просто скажите…
[05:33.000 --> 05:38.000]  Нет, дело вот в чем. Нет, магия просто заключается в следующем.
[05:38.000 --> 05:46.000]  Для того, чтобы перемножить матрицу A на матрицу B, на самом деле, достаточно возвести в квадрат матрицу следующего содержания.
[05:52.000 --> 05:56.000]  Ну, два – это константа.
[05:59.000 --> 06:00.000]  Да.
[06:00.000 --> 06:05.000]  И если вот внимательно посмотреть, то там, на самом деле, произведение будет вот таким.
[06:07.000 --> 06:09.000]  Так что отсюда следует, что…
[06:09.000 --> 06:14.000]  То есть, на самом деле, получается задача перемножения двух произвольных матриц
[06:14.000 --> 06:18.000]  и задача взденемации квадрата – это вообще одна и та же задача, оказывается.
[06:18.000 --> 06:22.000]  То есть, слишком легко сводящиеся друг к другу.
[06:24.000 --> 06:28.000]  Так что мы могли бы тут без ограничения общности вообще не заморачиваться и сказать, что
[06:28.000 --> 06:32.000]  а давайте возводить одну и ту же матрицу в квадрат и не париться.
[06:34.000 --> 06:35.000]  Так.
[06:36.000 --> 06:38.000]  Ну вот, внимание, вопрос.
[06:38.000 --> 06:41.000]  Да, давайте соответственно думать. Как же нам…
[06:41.000 --> 06:43.000]  Итак, нам даны две матрицы.
[06:43.000 --> 06:45.000]  Ну, давайте я так…
[06:45.000 --> 06:47.000]  Там, Бергла, накидаю какую-нибудь там матрицу.
[06:47.000 --> 06:54.000]  1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0.
[06:57.000 --> 06:58.000]  Чего?
[07:02.000 --> 07:04.000]  Ну, как сказать? Ну вот.
[07:04.000 --> 07:05.000]  Ну, давай так.
[07:05.000 --> 07:10.000]  Смотри, когда мы перемножаем матрицы, у нас тут количество столбцов должно совпадать с количеством строк.
[07:10.000 --> 07:13.000]  По идее, вот эти нули тоже можно добить так.
[07:13.000 --> 07:15.000]  Кто сказал, что эти нули квадратные?
[07:16.000 --> 07:19.000]  То есть нули можно тоже сделать так, чтобы эта матрица стала квадратной.
[07:19.000 --> 07:22.000]  Так что само по себе это не особо большая проблема.
[07:25.000 --> 07:26.000]  Вот.
[07:27.000 --> 07:33.000]  Итак, как же нам предлагается перемножать матрицы побыстрее?
[07:35.000 --> 07:39.000]  Значит, смотрите, щит заключается в следующем.
[07:39.000 --> 07:49.000]  Ну, на самом деле все методы четырех русских начинаются вот с такого вот заклинания имени Андрея Сергеевича, от которого я его впервые услышал.
[07:50.000 --> 07:55.000]  Заклинание называется зафиксируем к, которое выберем позже.
[07:57.000 --> 08:04.000]  Да, он это называл к, мы это будем называть по понятным причинам, естественным словом, бубен.
[08:06.000 --> 08:08.000]  Почему бубен? Ну, потому что мы потом подгонять это будем.
[08:10.000 --> 08:12.000]  Вот.
[08:13.000 --> 08:20.000]  Соответственно, да. То есть в этом смысле, да, есть что-то общее, конечно, с какой-то декомпозицией, хотя суть тут принципиально иная.
[08:21.000 --> 08:23.000]  Хотя, действительно, общего тоже много.
[08:24.000 --> 08:28.000]  Потому что у нас тоже будут две какие-то части алгоритма.
[08:29.000 --> 08:37.000]  Одна из которых будет работать тем дольше, чем больше будет бубен, а другая, наоборот, чем бубен будет больше, чем эта сама часть будет работать как-то меньше.
[08:38.000 --> 08:40.000]  Что это будет?
[08:41.000 --> 08:43.000]  А будет следующее.
[08:44.000 --> 08:47.000]  Значит, идея будет заключаться в следующем.
[08:48.000 --> 08:58.000]  Я хочу научиться перемножать два вектора размера не более чем бубен за от 1.
[09:01.000 --> 09:03.000]  Как я это сделаю?
[09:04.000 --> 09:10.000]  Значит, как я это сделаю? Как я научусь перемножать любые два вектора за от единицы?
[09:12.000 --> 09:13.000]  Хочется сказать никак.
[09:14.000 --> 09:15.000]  Нет.
[09:17.000 --> 09:18.000]  А, ну да.
[09:20.000 --> 09:23.000]  Да, ну да, метод имени, конечно, да, но хотелось бы.
[09:24.000 --> 09:26.000]  Значит, нет, мы это будем делать весьма нот.
[09:27.000 --> 09:29.000]  То есть метод четырех русских тут предлагает неожиданно тупой вариант.
[09:30.000 --> 09:34.000]  Мы тупо переберем все пары векторов размера не более чем бубен.
[09:35.000 --> 09:42.000]  Для каждого из них не менее тупо вычислим ответ и запишем.
[09:43.000 --> 09:47.000]  То есть единственная не тупая часть в этом, это как их адекватно закодировать.
[09:48.000 --> 09:49.000]  Это же чисто.
[09:50.000 --> 09:51.000]  Чего?
[09:52.000 --> 09:56.000]  Ну вот, но в данном случае это делается максимально простым образом, действительно.
[09:56.000 --> 09:58.000]  Но если, конечно, бубен не сильно большой.
[09:59.000 --> 10:00.000]  Иначе мы не переберем.
[10:01.000 --> 10:07.000]  Да, но да, вот поэтому мы раз мы верим, что n у нас укладывается в башинное слово, то бубен где-нибудь там не больше, чем логарифом нас устроит, правда?
[10:08.000 --> 10:12.000]  Ну так, держим в уме, что если у нас бубен больше логарифа, то будет многовато.
[10:13.000 --> 10:15.000]  Итак, идея такая.
[10:16.000 --> 10:23.000]  Мы догадываемся, думаю, не надо тут это подробно обсуждать, что по идее битовый вектор размера не более чем бубен.
[10:23.000 --> 10:31.000]  Мы догадываемся, что по идее битовый вектор размера бубен из нулей единиц прекрасно описывается масочкой, правда?
[10:32.000 --> 10:33.000]  Вот, описывается?
[10:34.000 --> 10:35.000]  Да.
[10:36.000 --> 10:37.000]  Вот, великолепно, да.
[10:38.000 --> 10:40.000]  Он очень красиво описывается масочкой.
[10:41.000 --> 10:45.000]  Вот, а два вектора бубен описываются двумя масочками.
[10:46.000 --> 10:49.000]  Вот, поэтому можно создать двумерный массив.
[10:50.000 --> 10:52.000]  Там два в степени бубен на два в степени бубен.
[10:53.000 --> 10:56.000]  Можно из них честно найти ответ и записать его в этот двумерный массив.
[10:57.000 --> 11:04.000]  Мы это будем делать, да, знаете, вообще сейчас не будем заморачиваться, потому что, как вы увидите, это вообще не принципиально на самом деле.
[11:05.000 --> 11:12.000]  Это будет работать за время два в степени два умножить на бубен.
[11:13.000 --> 11:15.000]  Умножить на бубен.
[11:16.000 --> 11:18.000]  Умножить на бубен.
[11:19.000 --> 11:20.000]  А вот так.
[11:21.000 --> 11:23.000]  А потому что мы перемножаем два вектора вот совсем в тупую.
[11:24.000 --> 11:27.000]  Мы даже не вспоминаем о том, что у нас там битвы и операции какие-то там есть.
[11:28.000 --> 11:33.000]  Мы можем просто выкосить и скорить и сразу же поддерживать типа.
[11:34.000 --> 11:36.000]  Ну, а мы тупые.
[11:41.000 --> 11:42.000]  Ну вот, а вот мы тупые.
[11:42.000 --> 11:47.000]  Да, посмотрим, вот попробуем на самом деле в будущем это ускорить и посмотрим, насколько это нам вообще поможет.
[11:48.000 --> 11:49.000]  На самом деле.
[11:50.000 --> 11:55.000]  Потому что давайте думать, как нам этот, называется, бубнопредподсчет поможет.
[11:57.000 --> 11:59.000]  Потому что теперь вот внимание, вопрос.
[12:00.000 --> 12:05.000]  Как вы думаете, за какую теперь асимптуетику мы умеем перемножать матрицы, имея такой предподсчет?
[12:05.000 --> 12:06.000]  Ну да.
[12:07.000 --> 12:12.000]  То есть заметим, что у нас как бы получается нам надо n квадрат раз перемножить строчку на столбец.
[12:13.000 --> 12:17.000]  Но каждую строчку и каждый столбец мы заранее можем как бы в бубен раз сжать. Правда?
[12:19.000 --> 12:21.000]  То есть вместо нольков и ниц ходить в какие-то вот маски.
[12:22.000 --> 12:27.000]  То есть получится n квадрат умножить на n поделить на н.
[12:28.000 --> 12:29.000]  Так.
[12:30.000 --> 12:31.000]  Ну вот.
[12:32.000 --> 12:34.000]  Теперь возникает такое естественное внимание, вопрос.
[12:35.000 --> 12:42.000]  Как подогнать бубен так, чтобы вот эта вот суммарная асимптутика была как можно меньше?
[12:42.000 --> 12:43.000]  Ну да.
[12:44.000 --> 12:49.000]  То есть на самом деле асимптатически, на самом деле, так как мы помним, мы с таким сталкивались когда-то.
[12:50.000 --> 12:54.000]  Что на самом деле асимптутика суммы – это то же самое, что асимптутика максимума.
[12:55.000 --> 12:56.000]  Да, просто это от максимума.
[12:57.000 --> 12:58.000]  Вот.
[12:59.000 --> 13:07.000]  Поэтому на самом деле надо просто перейти к тем, кто говорит, что мы как бы можем оценить асимптутику.
[13:08.000 --> 13:10.000]  Потому что мы не можем их добавлять.
[13:10.000 --> 13:19.300]  Вот, поэтому на самом деле надо просто приблизительно, то есть подогнать бубен, в чем даже не обязательно точно, но так приблизительно так, чтобы вот, там было более-менее подходило.
[13:19.300 --> 13:20.300]  Ну давайте попробовать.
[13:20.300 --> 13:23.700]  Вот если мы возьмем бубен логарифом, что получится?
[13:27.000 --> 13:35.500]  То есть на самом деле, да, если у вас, да, действительно бубен, там, допустим, логарифом n, то что у нас получится?
[13:36.000 --> 13:38.000]  2 в степени 2 логарифа, это что такое?
[13:38.000 --> 13:49.500]  Это, естественно, n квадрат, значит, еще и на лог n, и плюс, соответственно, n в кубе поделить на лог, соответственно, n.
[13:54.500 --> 13:59.500]  Нет, ну пока, нет, ну, нет, ну теперь давайте смотреть.
[13:59.500 --> 14:04.500]  Казалось бы, да, что явно кажется, что логарифом что-то мало, да?
[14:06.500 --> 14:17.500]  Но не то чтобы, потому что давайте теперь попробуем, бубен равно полтора логарифа.
[14:19.500 --> 14:21.500]  Догадываете, почему я взял именно полтора?
[14:24.500 --> 14:25.500]  Так, еще вопрос?
[14:26.500 --> 14:27.500]  Не, вопрос не к вам.
[14:27.500 --> 14:29.500]  Ну это я понял, тем не менее.
[14:30.500 --> 14:35.500]  Просто лекция идет как-то, поэтому, как знаете, вопросы можно на перемеге обсудить.
[14:40.500 --> 14:41.500]  Значит, смотрите.
[14:43.500 --> 14:45.500]  Что будет, если я подставлю полтора логарифа?
[14:47.500 --> 14:51.500]  Будет, получится очень приятно, получится n в кубе на полтора логарифа.
[14:52.500 --> 14:55.500]  Ну и плюс n в кубе поделить то, что-то там.
[14:57.500 --> 14:58.500]  Что?
[15:01.500 --> 15:03.500]  Ну я ищу подходящий бубен.
[15:04.500 --> 15:05.500]  Нет, почему?
[15:06.500 --> 15:07.500]  С каких-то пор полтора логарифа стали жестью.
[15:08.500 --> 15:09.500]  Какое жесть, и только мясо.
[15:11.500 --> 15:12.500]  Где мясо?
[15:13.500 --> 15:15.500]  Господи, бубен, он деревянный, какого мяса?
[15:16.500 --> 15:20.500]  Ну кажется, любое число меньше полтора.
[15:21.500 --> 15:24.500]  Ну да, вот тут получился такой парадокс.
[15:25.500 --> 15:28.500]  Если этот оптимальный бубен и есть, то есть такая вот мистическая,
[15:29.500 --> 15:33.500]  то есть давайте, функция бубен от n такое число, что вот это равно, допустим, этому.
[15:35.500 --> 15:41.500]  Оказывается, ну в принципе отсюда уже явно следует, что этот бубен лежит между логарифмом и полутора логарифмами.
[15:42.500 --> 15:47.500]  Но на самом деле, как функция, он как бы растет медленнее, чем полтора логари...
[15:48.500 --> 15:49.500]  Сейчас, нет.
[15:50.500 --> 15:53.500]  Ну хотя да, как бы это так сформулировать?
[15:54.500 --> 15:56.500]  Потому что вот интересно, что полтора логарифма нам не подходит,
[15:57.500 --> 16:01.500]  а логарифм, домноженный на любую константу, меньше полутора, нам неожиданно подходит.
[16:02.500 --> 16:09.500]  Ну возможно, там надо брать, знаете, что-нибудь типа 1.49 логарифмов умножить на лог, лог n там какой-нибудь, вот это вот все.
[16:10.500 --> 16:14.500]  Но на самом деле асимпатически, в общем-то, это ничего не решает.
[16:15.500 --> 16:18.500]  Потому что по факту, какой бы мы этот подходящий логарифм не взяли,
[16:19.500 --> 16:22.500]  а вот эта штука все равно будет от n в кубе поделить на лог, правда?
[16:24.500 --> 16:31.500]  Так что получается, что подогнав правильный бубен, мы решаем эту задачу за n в кубе поделить на лог n.
[16:31.500 --> 16:32.500]  Лог n.
[16:35.500 --> 16:37.500]  Теперь, кстати, вот кто-то спрашивал, да?
[16:38.500 --> 16:41.500]  Ведь мы ж могли бы там их рекурсивно перебирать и сразу хранить ответ.
[16:42.500 --> 16:47.500]  Или там вспомнить, что у масочек там есть какая-то это мистическая операция n вообще в компьютере.
[16:48.500 --> 16:49.500]  Вот.
[16:50.500 --> 16:51.500]  Вот возьми-ка этот вопрос.
[16:52.500 --> 16:53.500]  Вот уберу я этот бубен.
[16:54.500 --> 16:55.500]  Что поменяется?
[16:55.500 --> 16:59.500]  Ну, что-то может и поменяется, но как бы степень все равно будет.
[17:00.500 --> 17:02.500]  Если полтора бубна, тут будет n в кубе.
[17:03.500 --> 17:08.500]  А если меньше полтора бубна, здесь будет все, что там n в степени какой-то меньше, чем 3.
[17:09.500 --> 17:10.500]  Логично, да?
[17:11.500 --> 17:12.500]  Логично, да.
[17:13.500 --> 17:15.500]  Так что вот такая вот простота.
[17:16.500 --> 17:17.500]  Вот.
[17:18.500 --> 17:19.500]  Ну, это такая вот базовая версия метод четырехрусских.
[17:20.500 --> 17:21.500]  То есть, еще один вопрос.
[17:21.500 --> 17:24.500]  Ну, это такая вот базовая версия метод четырехрусских.
[17:25.500 --> 17:26.500]  То есть, еще раз, да.
[17:27.500 --> 17:35.500]  То есть, мы пытаемся как-то свести, как-то научиться решать задачу для каких-то маленьких объектов размера не более, чем какого-то.
[17:36.500 --> 17:38.500]  Но не константного, правда, обратите внимание, да?
[17:39.500 --> 17:40.500]  То есть, бубен у нас от n зависит.
[17:41.500 --> 17:50.500]  То есть, там перебирать все такие объекты в тупую, записать в какую-то табличку ответ, а потом попытаться сократить, собственно, себе работу.
[17:52.500 --> 17:53.500]  Вот.
[17:54.500 --> 17:55.500]  Это вот такой пример.
[17:56.500 --> 17:58.500]  Какой оптимум вы тут?
[17:59.500 --> 18:00.500]  Чего?
[18:01.500 --> 18:06.500]  Ну, как вы вот, ну, по крайней мере, в такой версии алгоритма вот n в кубе поделить на лога это оптимум.
[18:07.500 --> 18:11.500]  Ну, потому что мы видим, что бубен лога n это типа мало, а полтора лога это типа много.
[18:12.500 --> 18:17.500]  Ну, то есть, вот асимпатически это вот это слагаемое по-любому n в кубе поделить на лога без вариантов.
[18:18.500 --> 18:26.500]  Так что получается, то есть, как бы, если вы хотите выжить из этого алгоритма, то есть, делать лучше асимпточку, значит, надо как-то лучше считать.
[18:27.500 --> 18:31.500]  Вот. То есть, надо уже сам алгоритм как-то вот по шамане чуть-чуть.
[18:32.500 --> 18:33.500]  Вот.
[18:34.500 --> 18:35.500]  Собственно, с этим мы сегодня даже столкнемся.
[18:38.500 --> 18:39.500]  Вот.
[18:41.500 --> 18:45.500]  Значит, соответственно, уровень, значит, уровень следующий.
[18:46.500 --> 18:47.500]  Вот.
[18:48.500 --> 18:51.500]  Значит, что дальше можно выжить?
[18:52.500 --> 18:54.500]  А, ну ладно, пока мы тут говорим о матрицах.
[18:58.500 --> 19:06.500]  А, ну в принципе, да, если говорить о лучшей асимпточке, то можно, на самом деле, попытаться этим методом пойти немножко в другую сторону.
[19:09.500 --> 19:12.500]  Смотрите, вот у нас есть метод Штрассена, правда?
[19:12.500 --> 19:13.500]  Есть.
[19:18.500 --> 19:19.500]  Ну вот. Так вот.
[19:20.500 --> 19:22.500]  Значит, мистическая идея.
[19:24.500 --> 19:27.500]  Смотрите. То есть, вот идея будет у нас такая, такая достаточно типичная.
[19:28.500 --> 19:33.500]  Давайте запустим на алгоритм перемножения матриц метод Штрассена.
[19:34.500 --> 19:41.500]  Но при этом рекурсивно будем вызываться не прям до одного, а до какого-нибудь мистического числа.
[19:42.500 --> 19:44.500]  Ну, допустим, Бубен.
[19:47.500 --> 19:54.500]  Тогда, оказывается, это алгоритм будет работать за что-то типа n поделить на Бубен.
[19:56.500 --> 19:58.500]  Там в степени какой?
[19:59.500 --> 20:06.500]  Ну там лог 2.7 умножить на, ну скажем так, m от Бубен.
[20:06.500 --> 20:18.500]  Где m от Бубен? Это за какое время мы можем перемножить матрицы вот такого размера.
[20:19.500 --> 20:21.500]  Еще плюс какой-то предпочет.
[20:22.500 --> 20:23.500]  Ну получается.
[20:24.500 --> 20:25.500]  Вот теперь давайте думать.
[20:26.500 --> 20:29.500]  Вот у нас была бы, конечно, голубая мечта.
[20:30.500 --> 20:31.500]  Ну вот.
[20:32.500 --> 20:33.500]  Ну вот.
[20:34.500 --> 20:37.500]  Чистой теоретики сделать так, чтобы этот m от Бубен был какой?
[20:40.500 --> 20:42.500]  Ну, от единицы, конечно, совсем не подходит.
[20:43.500 --> 20:46.500]  Но скорее, я так скажу, Бубен в квадрате.
[20:48.500 --> 20:51.500]  Почему Бубен в квадрате? Время считывания, время считения этих матриц.
[21:00.500 --> 21:02.500]  Но это у нас такая мечта.
[21:03.500 --> 21:11.500]  Потому что метод с трех русских намекает, что, наверное, любые две мбулевые матрицы размера Бубен или меньше у вас там уже записаны в таблице вместе с их перемножением.
[21:27.500 --> 21:28.500]  На что забить?
[21:30.500 --> 21:31.500]  Нет, я понял.
[21:32.500 --> 21:35.500]  Почему, если мы не возьмем m от Бубен больше, мы не сможем получить цветочку?
[21:36.500 --> 21:37.500]  Ну мы потом это сделаем.
[21:38.500 --> 21:43.500]  В смысле, потому что если мы сможем получить такую, то взяв m от Бубен больше, она будет больше.
[21:44.500 --> 21:47.500]  Нет, у нас просто метод с трех русских заключается в чем?
[21:48.500 --> 21:57.500]  Он заключается в том, что мы, наверное, хотим все пары матриц размера Бубен себе просто это заранее перебрать, перемножить и записать себе в таблиц.
[21:57.500 --> 21:58.500]  Почему в квадрате?
[21:59.500 --> 22:03.500]  Потому что размер матрицы размера Бубен, Бубен в квадрате, и нам придется ее считать.
[22:04.500 --> 22:13.500]  Тот проблема в том, что заранее мы, то есть тут-то нам при перемножении, тут-то мы как бы заранее, собственно, эти вот там вектора, собственно, не меняются, они нам заранее даны.
[22:15.500 --> 22:17.500]  Ну вот, а вот тут, а, ну хотя...
[22:18.500 --> 22:26.500]  Я просто прочитал, что часть, которая, если мы немножко увеличим Бубен и сделаем это не в последней трансе, а, возможно, чуть раньше.
[22:27.500 --> 22:31.500]  Может первую часть, которую Лобо себе или Батемию перевесит, поэтому получим что-то в клубе.
[22:32.500 --> 22:33.500]  Это все, что...
[22:34.500 --> 22:35.500]  Ну, может перевесить.
[22:36.500 --> 22:37.500]  Я ничего не понимаю.
[22:38.500 --> 22:39.500]  Мы же Бубен не фиксируем.
[22:40.500 --> 22:41.500]  Ну, в смысле, мы потом его зафиксируем.
[22:42.500 --> 22:43.500]  Нет, ну вот как?
[22:44.500 --> 22:46.500]  Но нам не желать, чтобы Бубен в клубе, нам все-таки не желательно.
[22:47.500 --> 22:52.500]  Так что наша цель в смысле положить наиболее оптимальный алгоритм, для меня это был трюк с фиксацией Бубен.
[22:52.500 --> 22:53.500]  Фиксации Бубен.
[22:54.500 --> 22:55.500]  Ну, да.
[22:56.500 --> 22:59.500]  Поэтому мы пытаемся вот здесь, допустим, выжать максимум.
[23:02.500 --> 23:03.500]  Но правда, да, можем тут поиграться.
[23:04.500 --> 23:07.500]  Здесь мы просто говорили, что давайте выходим вот в этой части, да, вот прям учиться типа за от единиц.
[23:08.500 --> 23:10.500]  Ну или типа вот за метасчитывание.
[23:11.500 --> 23:18.500]  Хотя, на самом деле, если внимательно посмотреть, то как бы можно заранее посмотреть, какие там на базовом уровне будут матрицы перемножаться в принципе.
[23:22.500 --> 23:24.500]  Нет, стоп, они же походу выполнены генерацией.
[23:25.500 --> 23:26.500]  На самом деле нет, кстати.
[23:27.500 --> 23:29.500]  Ну потому что, помните, как устроен метод Штрасседа?
[23:30.500 --> 23:31.500]  Мы делим каждую матрицу на четыре части.
[23:32.500 --> 23:33.500]  А, ну хотя они, да.
[23:34.500 --> 23:35.500]  А, ну да, они походу генерятся, да.
[23:36.500 --> 23:40.500]  То есть там не только вот эти заданные матрицы есть, но там еще какие-то есть там.
[23:41.500 --> 23:46.500]  Ой, там отдельный, правда, вопрос, освоится ли это к более воумножению матриц вообще.
[23:47.500 --> 23:48.500]  Кстати.
[23:49.500 --> 23:51.500]  Ну в идее можно просто заменить.
[23:52.500 --> 23:56.500]  Ну ладно, ну ладно, давайте, давайте предполагать, да, давайте, да, в этом месте.
[23:57.500 --> 24:02.500]  Да, давайте подчеркнем, что мы все-таки в F2 живем, а не в, там, Энде, Энде и Оле, да, все-таки разные.
[24:03.500 --> 24:05.500]  Так нет, вот если у нас...
[24:06.500 --> 24:07.500]  Там еще, там мы еще вычитаем.
[24:08.500 --> 24:12.500]  Ну в Штрассене есть и вычитание, увы, так что.
[24:13.500 --> 24:14.500]  Вот.
[24:15.500 --> 24:17.500]  У нас же уровень Февалентин.
[24:18.500 --> 24:19.500]  Да.
[24:20.500 --> 24:21.500]  Да.
[24:22.500 --> 24:29.500]  Да, мы это в явном виде говорим, что если в предыдущем методе нам, в общем, не принципиально это было, это было прямо с ксором или ссором, потому что и так, и так делается, да.
[24:30.500 --> 24:32.500]  То есть здесь мы вынуждены подчеркнуть, что да, это F2.
[24:33.500 --> 24:35.500]  Да, это с ксором, да, спасибо.
[24:36.500 --> 24:37.500]  Ну а теперь вот какая-то вопрос.
[24:38.500 --> 24:40.500]  Так, за какое время мы можем предпочитать перемножение матриц?
[24:41.500 --> 24:42.500]  Размера Бубен.
[24:42.500 --> 24:43.500]  Размера Бубен.
[24:47.500 --> 24:48.500]  Ну получается, да.
[24:49.500 --> 24:50.500]  Два в степени...
[24:52.500 --> 24:53.500]  Сколько там получается?
[24:55.500 --> 24:58.500]  Да, два в степени два Бубен квадрат.
[25:02.500 --> 25:05.500]  И умножить еще на, видимо, Бубен в кубе.
[25:06.500 --> 25:07.500]  Ну чтоб совсем в тупую.
[25:07.500 --> 25:12.500]  Да, можно было коже Бубен вот в этой степени, но это, как вы догадываетесь, локально будет.
[25:13.500 --> 25:15.500]  То есть там погода нам не сделает.
[25:16.500 --> 25:19.500]  Видим сейчас два Бубен в квадрат или два Бубен в квадрат?
[25:20.500 --> 25:21.500]  Два в степени два Бубен в квадрат.
[25:23.500 --> 25:24.500]  Нет?
[25:25.500 --> 25:28.500]  Ну Бубен в квадрат в одной матрице, Бубен в квадрат в другой, это вот два Бубен в квадрат.
[25:29.500 --> 25:31.500]  Так, ну вот, спрашивается.
[25:31.500 --> 25:33.500]  Ну вот, ну значит так, вот тут давайте пробовать, да.
[25:34.500 --> 25:36.500]  Значит, N в степени лог два семь.
[25:37.500 --> 25:45.500]  Поделить на Бубен в степени лог два семь минус два.
[25:47.500 --> 25:56.500]  Значит, должно быть приблизительно равно два в степени два Бубен в квадрат.
[25:56.500 --> 26:03.500]  Но два в степени два Бубен в квадрате на Бубен в кубе.
[26:06.500 --> 26:13.500]  Так, ну значит получается, что да, N в степени лог два семь, это приблизительно равно, сколько там.
[26:14.500 --> 26:23.500]  Там Бубен, там Бубен в степени там, сколько там получается, один плюс лог два семь.
[26:26.500 --> 26:28.500]  Ну это не сильно принципиально, в общем-то.
[26:29.500 --> 26:34.500]  Потому что самое принципиальное, что это два в степени два Бубен в квадрате.
[26:36.500 --> 26:45.500]  Так, ну мы вынуждены заключить, что надо подогнать Бубен так, чтобы два Бубен в квадрате было чуть-чуть-чуть-чуть меньше, чем...
[26:46.500 --> 26:54.500]  Ну да, то есть получается пишем два Бубен в квадрате, должно быть чуть-чуть меньше, вот так вот.
[26:56.500 --> 26:58.500]  Ну я не знаю как это помещать, в общем так, пометим.
[26:59.500 --> 27:03.500]  Чем сколько? Правильно, лог два семь, лог два N.
[27:10.500 --> 27:12.500]  Ну, логарифм, двоичный логарифм, вот эти штуки, короче.
[27:15.500 --> 27:19.500]  Ну и соответственно так и пишем, что Бубен у нас естественно возникает.
[27:20.500 --> 27:31.500]  То есть, ну например, там что-нибудь типа, ну там, ну например, корень из лог два семь, лог два N.
[27:33.500 --> 27:36.500]  Ну, допустим, на три.
[27:39.500 --> 27:43.500]  Ну, главное, чуть меньше, ну, потому что если два, это будет многовато, там, на лишний логарифм.
[27:45.500 --> 27:47.500]  Ну вот, поэтому мы тут берем три.
[27:49.500 --> 27:55.500]  Ну да, нет, то как вы смотрите, да, то есть, надо сказать, что любой Бубен там меньше, чем вот такой, нам подойдет, по идее.
[27:56.500 --> 27:59.500]  Кажется, просто корень из N. Ну, корень из лог N.
[28:02.500 --> 28:03.500]  Синтетически не влияет.
[28:04.500 --> 28:09.500]  А, ну да. А, потому что лог два семь поделить на два, это типа больше нуля. Ну да.
[28:10.500 --> 28:13.500]  Ну вот корень седьмой степени или что это?
[28:14.500 --> 28:20.500]  Нет, это типа, ну, типа приблизительно, ну, там типа приблизительно равно, но чуть меньше, вот так.
[28:21.500 --> 28:24.500]  Ну да, то есть, в принципе, да, как было сказано, как правильно сказали, да.
[28:25.500 --> 28:28.500]  То есть, Бубен равный корень из лог N, в принципе, нам подойдет.
[28:32.500 --> 28:36.500]  Так, ну это мы подставили, какая симптомика у нас в итоге получается.
[28:39.500 --> 28:40.500]  Из дотной долгой.
[28:41.500 --> 28:43.500]  Ну, на самом деле, да, если...
[28:44.500 --> 28:48.500]  Мы просто забыли про кусочек, который Бубен в степени азинки создал.
[28:49.500 --> 28:50.500]  Что забыли?
[28:51.500 --> 28:53.500]  Ну, потому что это какой-то пыленок.
[28:54.500 --> 28:55.500]  А, потому что...
[28:56.500 --> 28:59.500]  У нас тут как бы есть экспоненты, ну вот.
[29:00.500 --> 29:05.500]  Если это меньше вот этого в экспоненту раз, то как бы вот это не перекупит.
[29:06.500 --> 29:10.500]  Ну хорошо, но почему-то мы не забыли про кусочек, который...
[29:16.500 --> 29:22.500]  Вот, так, вопрос как бы, да, подставляем, теперь надо подставить и понять, собственно, какая симптомика в итоге получится.
[29:25.500 --> 29:32.500]  Вот, ну получится какая-то симптомика в духе там N в степени лог 2,7.
[29:33.500 --> 29:39.500]  Ну, явно, чуть больше будет явно вот это с логами, если мы тут подставим Бубен лог N, да.
[29:40.500 --> 29:44.500]  Ну вот, ну и здесь мы пишем там лог 2N в степени какой?
[29:46.500 --> 29:48.500]  Ну вот, ну соответственно пишем...
[29:49.500 --> 29:51.500]  Нет, нет, одна вторая.
[29:52.500 --> 29:54.500]  Лог 2,7 и минус один, вот так.
[29:58.500 --> 29:59.500]  Вот.
[30:00.500 --> 30:07.500]  Так что мы, получается, мы молодцы, мы ускорили штрас, она даже не в лог раз, а чуть больше, чем в лог раз.
[30:09.500 --> 30:11.500]  А больше, кстати, вообще?
[30:12.500 --> 30:14.500]  А, черт, это меньше одного.
[30:15.500 --> 30:17.500]  Нет, ну не до столько.
[30:18.500 --> 30:20.500]  Нет, это...
[30:21.500 --> 30:24.500]  Нет, ну, породите, нет, породите, вот это, это 2.81.
[30:25.500 --> 30:26.500]  А, ну да, чуть...
[30:26.500 --> 30:28.500]  А, ну да, да, да, да.
[30:29.500 --> 30:30.500]  Да.
[30:31.500 --> 30:32.500]  Ну окей, да.
[30:38.500 --> 30:41.500]  Ну а симпатически лучше, чем тупой штрас, да.
[30:43.500 --> 30:44.500]  Ну да.
[30:50.500 --> 30:52.500]  Не-не-не, ну почему, не, ну почему?
[30:53.500 --> 30:57.500]  Чтобы это стало эффективно, должны быть какие-то, прям, восстановительные масштабы, да?
[30:58.500 --> 30:59.500]  Ну, конечно, что делать.
[31:00.500 --> 31:01.500]  То есть замедлять-то она не будет?
[31:01.500 --> 31:04.500]  Не, ну как сказать, не, ну там просто все зависит от того, как вы делаете предподсчет.
[31:05.500 --> 31:13.500]  Не говоря уже о том, что если у вас там задание перенажать булевые матрицы, то как бы много-много раз, то, наверное, предподсчет вы делаете там, раз и навсегда один раз.
[31:14.500 --> 31:17.500]  Ну может не навсегда, может вы там его иногда увеличиваете, поэтому там легче.
[31:18.500 --> 31:19.500]  А почему вы не пользуетесь?
[31:20.500 --> 31:21.500]  Чего, с чем скрепить?
[31:22.500 --> 31:23.500]  По очереди.
[31:24.500 --> 31:25.500]  С бит-сетом.
[31:25.500 --> 31:26.500]  С бит-сетом.
[31:38.500 --> 31:48.500]  Ну, не, ну формально говоря, конечно, что в худшем случае там, ну, то есть если скрепить вот это с бит-сетом не очень понятно, но в принципе сам себе бит-сет это в клубе поделить на машинное слово на самом деле.
[31:49.500 --> 31:50.500]  Чем вообще?
[31:50.500 --> 31:51.500]  Все нужно было...
[31:56.500 --> 31:58.500]  Бит-сет, по сути, это то же самое, как...
[32:03.500 --> 32:05.500]  Ну, в данной, ну, как сказать?
[32:06.500 --> 32:09.500]  Не, ну там просто ничего не прикалькается, там просто как бы мы умеем перемножать.
[32:09.500 --> 32:14.500]  Нет, то метод репетитет тем, что метод он как бы глобальный, а конкретное перемножение работает в конкретные задачи.
[32:17.500 --> 32:18.500]  Да.
[32:20.500 --> 32:21.500]  Именно так.
[32:24.500 --> 32:32.500]  Нет, это мы просто прикрутили, что как бы с помощью этой технологии можно оптимизировать алгоритм Штрафсона конкретно для булевых матриц, да.
[32:32.500 --> 32:34.500]  Точнее для вот матриц на ДВ-2.
[32:35.500 --> 32:39.500]  Ну, чтобы вы убедились, что да, что это на самом деле как бы не...
[32:39.500 --> 32:51.500]  Какой-то такая очень сложный такой способ действительно описать то, что на самом деле делается там известными в Олимпиаде технологиями с кодовым названием N-квадрат поделить на 32, вот.
[32:51.500 --> 32:54.500]  Ну, ну не знаю.
[32:55.500 --> 33:00.500]  Принято говорить на 32, хотя да, по факту он 64 в современном, по современному.
[33:01.500 --> 33:04.500]  Разные эпохи вполне себе.
[33:05.500 --> 33:12.500]  Ну да. Значит мы представляем разные поколения, я не знаю. В моем поколении как-то было принято делить на 32, а не на 64.
[33:12.500 --> 33:16.500]  А когда мы писали лебеды, там уже 30-го убитого компилятора даже не было.
[33:16.500 --> 33:25.500]  Ой, ну да, да, да, да, да. Это да. Знаете, это да. Ну знаете, когда я писал в школе лебеды, 11 стандарта не было. В принципе не было.
[33:25.500 --> 33:28.500]  Ну тогда 11 года не было в общем-то.
[33:30.500 --> 33:40.500]  Ой, длинный тур открытки. Боже мой.
[33:42.500 --> 33:43.500]  Идем.
[33:54.500 --> 33:56.500]  Значит, идем дальше.
[33:57.500 --> 34:07.500]  Значит, ну на самом деле, конечно, да, сейчас я расскажу, конечно, чуть, называется более классический пример, там, собственно, применение идеологии четырех русских.
[34:07.500 --> 34:11.500]  Это, конечно, ее величество статика РМКУ.
[34:11.500 --> 34:34.500]  Да, ну мы уже рассматривали в прошлый раз задачу статика РМКУ. То есть эта задача, типа, вам дан массив, он не меняется, вам хочется научиться, вам хочется сделать какой-то предподсчет, и после этого отвечать на запросы вида «найди минимум на подотреске».
[34:35.500 --> 34:44.500]  Вот, эта задача называется статика РМКУ. РМКУ значит «Ranch Minimum Query», но это так, просто если у вас случайно не социировалась аббревиатура.
[34:48.500 --> 34:49.500]  Значит, смотрите.
[34:55.500 --> 34:59.500]  Ну вот, оказывается, начнем с простой версии.
[34:59.500 --> 35:17.500]  Значит, давайте представим себе, что у нас есть массив, но не просто массив, а мистическим образом, откуда-то нам известно, что, ну или там, случайно оказалось, что любые два соседних числа отличаются на единицу.
[35:19.500 --> 35:21.500]  Правда, в любую сторону.
[35:30.500 --> 35:32.500]  Вот как-то так, массивчик, опять же.
[35:36.500 --> 35:40.500]  И нам очень хочется вот на нем реализовать статик РМКУ.
[35:42.500 --> 35:43.500]  Да.
[35:45.500 --> 35:47.500]  Да, модуль разницы, если быть точнее.
[35:48.500 --> 35:56.500]  Модуль аитова минус 1 равно 1. Вот, допустим, откуда-то нам это известно.
[35:57.500 --> 35:58.500]  Прям равно?
[35:58.500 --> 35:59.500]  Прям равно.
[36:01.500 --> 36:03.500]  Да, вот начнем с простого случая.
[36:07.500 --> 36:16.500]  Ну вот, ну вообще говоря, в принципе, мы эту задачу, по идее, умеем решать за предподсчет n log n и потом за от единицы на запрос.
[36:19.500 --> 36:25.500]  Ну вот, там технология называется разреженная таблица, она же Spark Stable, это мы там обсуждали, по-моему, даже не в прошлый раз уже даже.
[36:26.500 --> 36:27.500]  Вот.
[36:28.500 --> 36:30.500]  Вот, ну сегодня нам это пригодится.
[36:33.500 --> 36:35.500]  Значит, применяем абсолютно ту же технологию.
[36:38.500 --> 36:42.500]  Значит, фиксируем бубен, который выберем позже.
[36:45.500 --> 36:48.500]  Переберем все массивы размера бубен.
[36:51.500 --> 36:55.500]  Точнее, для каждого, точнее, массивы размера не более, чем бубен.
[36:56.500 --> 37:00.500]  Для каждого из них посчитаем ответ и запишем в таблицу.
[37:03.500 --> 37:06.500]  Ну правда, весь какая-то вопрос, а сколько существует массивов размера бубен?
[37:07.500 --> 37:08.500]  Видимо, не ответ, а индекс ответа.
[37:09.500 --> 37:10.500]  Да, ну и индекс ответа.
[37:11.500 --> 37:12.500]  Хотя суть одна.
[37:13.500 --> 37:17.500]  Да, но в такой форме, конечно, количество массив размера бубен, да, бесконечно много.
[37:17.500 --> 37:26.500]  Но правда, заметим, что если считать индекс массива, то заметим, что если мы к массиву прибавим или вычтем одно и то же число, то, в общем-то, позиция минимума от этого не поменяется, правда?
[37:29.500 --> 37:42.500]  Поэтому мы как бы мысленно, то есть, на самом деле, заметим, что массив с точностью вот этого вот сдвига там, да, плюс-минус там, константа, задается, то есть, вот любой массив вот такой вот, задается, на самом деле, просто информацией на тему того, кислятки, да.
[37:42.500 --> 37:51.500]  То есть, вот любой массив вот такой вот, задается, на самом деле, просто информацией на тему того, к следующей число, как бы, меньше предыдущего или больше.
[37:53.500 --> 38:02.500]  То есть, в принципе, таких вот массивчиков, то есть, у вас так, идеи на различных массивчиков, получается не более чем два в степени бубен, даже минус один.
[38:04.500 --> 38:05.500]  Согласен.
[38:06.500 --> 38:07.500]  Вот.
[38:09.500 --> 38:12.500]  Ну вот, и, оказывается, это очень удобно. То есть, мы перебираем.
[38:14.500 --> 38:18.500]  Значит, мы перебираем все массивы размера не более, правда, чем бубен.
[38:19.500 --> 38:21.500]  Сейчас увидите, почему это тут вот важно будет.
[38:22.500 --> 38:26.500]  И для каждого из них, честно, за от бубен находим ответ.
[38:27.500 --> 38:32.500]  Получается, этот прибор работает за два в степени бубен на n, на бубен, точнее.
[38:35.500 --> 38:43.500]  Но еще надо, там, на самом деле, еще по-хорошему надо, плюс два в степени бубен минус один, на бубен минус один.
[38:45.500 --> 38:53.500]  Еще надо, плюс два в степени бубен минус два, там, на, соответственно, бубен минус два.
[38:56.500 --> 38:57.500]  Ну, плюс и так далее.
[38:58.500 --> 39:02.500]  Но легко заметить, что если это все сложить, то получится от вот этого слагайбова.
[39:03.500 --> 39:08.500]  Ну, потому что это типа хотя бы в два раза меньше, это хотя бы в четыре, это хотя бы в восемь.
[39:09.500 --> 39:11.500]  В общем, короче, мажорируется геометрическая прогрессия.
[39:12.500 --> 39:14.500]  Вот. Ну, тут вот мне очень интересно.
[39:15.500 --> 39:22.500]  Интересно теперь другое. Как же мы, то есть, правда, все ли это, что мы делаем?
[39:23.500 --> 39:40.500]  Ну, в принципе, этот предподсчет теперь, ну, вкупе там с пробеганием как-то за уатен, может нам помочь найти ответ на любом подмассиве, то есть, на любом подотреске LER, где длина этого отрезка не более чем бубен, правда?
[39:41.500 --> 39:53.500]  Ну, мы же можем там, скажем, для каждого подмассива, допустим, такого, там, как, ну, за уатен предподсчета найти, собственно, масочку каждого такого элемента, правда?
[39:54.500 --> 40:01.500]  Ну, можно там вот аккуратненько вот там, во-первых, масочки насчитать для всех подмассив размера бубен, там, выкидывая последние биты, вставляя первые, да?
[40:02.500 --> 40:05.500]  Вот. Ну, а если там у нас отрезок чуть поменьше, то несколько бит там обрубим.
[40:06.500 --> 40:08.500]  Так, это понятно, о чем я говорю, да?
[40:09.500 --> 40:11.500]  Да, нет, наверное, да. Вот.
[40:13.500 --> 40:23.500]  Но, что делать, если от нас хотят найти, если от нас нам дают большой подотресок и говорят, а ну-ка, давай минимум?
[40:27.500 --> 40:28.500]  Что тогда делать?
[40:39.500 --> 40:40.500]  Да, сделать, да.
[40:42.500 --> 40:47.500]  Нет, это да, сделать ремонт квартире может, конечно, легче, чем написать мне тут четырех русских, но, по-моему, не в этом случае, вы знаете?
[40:49.500 --> 40:53.500]  Потому что, на самом деле, здесь оказывается, что большие отрезки – это хорошо.
[40:55.500 --> 40:59.500]  Потому что для больших отрезков, оказывается, вот этот предподсчет даже не нужен.
[41:01.500 --> 41:06.500]  Потому что мы легко можем разбить наш массив на блоке размера бубен.
[41:09.500 --> 41:11.500]  Вот. Бубен, бубен, бубен, бубен.
[41:13.500 --> 41:14.500]  Бубен, бубен, бубен, бубен.
[41:16.500 --> 41:17.500]  Бубен.
[41:19.500 --> 41:25.500]  Вот. На каждом из этих блоков посчитать свой минимум.
[41:26.500 --> 41:32.500]  И на этих минимумах торжественно посчитать Spark Stable.
[41:34.500 --> 41:35.500]  Понимаешь такое?
[41:36.500 --> 41:44.500]  А еще, чтобы совсем удобно было, мы в каждом блоке можем посчитать минимумы на префиксах и минимумы на суффиксах.
[41:47.500 --> 41:48.500]  Макия.
[41:49.500 --> 41:57.500]  В результате, если нам прям очень захочется найти минимум на подотреске, который не лежит внутри одного блока,
[41:58.500 --> 42:00.500]  то что же мы делаем?
[42:01.500 --> 42:10.500]  То мы просто берем минимум на суффиксе блока, минимум на префиксе блока, оба раза зова от единицы, и еще минимум из Spark Stable.
[42:12.500 --> 42:13.500]  Все.
[42:15.500 --> 42:21.500]  То есть получается, мы научились теперь, то есть мы умеем теперь с помощью таких предподсчетов искать ответ зова от единицы,
[42:21.500 --> 42:28.500]  но только предподсчет делается не только за эту асимптотику, а еще и за асимптотику построения, ну еще там за какой-то n,
[42:29.500 --> 42:31.500]  и за построение Spark Stable.
[42:32.500 --> 42:34.500]  А за сколько мы строим Spark Stable?
[42:35.500 --> 42:38.500]  N делить на Бубен умножить на log n.
[42:39.500 --> 42:41.500]  И сейчас, и суффиксы, вроде, тоже.
[42:42.500 --> 42:43.500]  Нет, ну суффиксы это тоже.
[42:44.500 --> 42:45.500]  А, суффиксы это n.
[42:46.500 --> 42:47.500]  Это тоже за линию, да.
[42:47.500 --> 42:50.500]  Не, это тоже n поделить на Бубен, если уж совсем формально писать.
[42:51.500 --> 42:58.500]  Да, понятно, что, скорее всего, как можно будет быстро убедиться, в общем-то, это не сильно принципиально будет.
[43:00.500 --> 43:04.500]  Но, действительно, хочется теперь вот аккуратно найти оптимальный Бубен.
[43:05.500 --> 43:06.500]  Как это сделать?
[43:09.500 --> 43:10.500]  Ну, давайте думать.
[43:11.500 --> 43:15.500]  Так, ну понятно, что, типа, вот эта штука возрастает, эта штука убывает, да?
[43:15.500 --> 43:16.500]  Чего?
[43:17.500 --> 43:20.500]  Ну, n, да, понятно, тут, да, можно забить, да.
[43:21.500 --> 43:22.500]  Ну, теперь поехали.
[43:23.500 --> 43:26.500]  Если мы подставим в качестве Бубна логарифом.
[43:27.500 --> 43:28.500]  Что будет?
[43:29.500 --> 43:32.500]  Ну, здесь будет n log n.
[43:33.500 --> 43:39.500]  А здесь будет, да, плюс n, плюс там n поделить на log n, там log,
[43:39.500 --> 43:44.500]  в общем, короче, явно что-то меньшее, в общем, меньшее, чем n log n, правда?
[43:45.500 --> 43:46.500]  Даже меньше n, я бы сказал.
[43:48.500 --> 43:49.500]  Но что из этого следует?
[43:50.500 --> 43:54.500]  Из этого следует, что Бубен, оптимальный Бубен, явно должен быть меньше логарифом, правда?
[43:55.500 --> 43:56.500]  Ну, или, по крайней мере, не больше.
[43:57.500 --> 44:02.500]  Но раз так, но тогда мы замечаем, что если Бубен меньше логарифма,
[44:02.500 --> 44:08.500]  то log вот это вот n поделить на Бубен, да, это равно чему?
[44:09.500 --> 44:11.500]  log n минус log Бубен.
[44:13.500 --> 44:17.500]  И, выражаясь языком математики, это равно θ от log n, на самом деле.
[44:21.500 --> 44:26.500]  То есть, в принципе, вот, то есть тут уже мы говорим, что при поиске оптимального Бубна мы видим,
[44:27.500 --> 44:29.500]  ну, а симпатически оптимального Бубна мы видим, да,
[44:29.500 --> 44:33.500]  при поиске оптимального Бубна мы видим, ну, а симпатически оптимального Бубна мы замечаем,
[44:34.500 --> 44:37.500]  что, в общем-то, действительно, вот этот вот Бубен можно прекрасно убрать.
[44:39.500 --> 44:41.500]  Значит, убираем Бубен.
[44:42.500 --> 44:45.500]  И, в результате, получается, что теперь 2 в степени Бубен,
[44:46.500 --> 44:47.500]  ну, давайте я B тут напишу для краткости, да,
[44:48.500 --> 44:52.500]  должно быть приблизительно равно n поделить на B на log n.
[44:52.500 --> 44:56.500]  Так, ну, какой же тут B нам чуть-чуть-то подогнать?
[44:57.500 --> 44:59.500]  Ну, идеальное B непонятно.
[45:01.500 --> 45:02.500]  Хотя...
[45:03.500 --> 45:04.500]  А, не, непонятно.
[45:06.500 --> 45:07.500]  Сейчас, извините, ну, может я блогу попросу?
[45:08.500 --> 45:09.500]  Давай.
[45:10.500 --> 45:16.500]  Вот, а, тут конкретно данные задачи, почему мы не можем просто минимум каждого блога за отр почитать?
[45:16.500 --> 45:17.500]  Ну...
[45:18.500 --> 45:19.500]  В смысле?
[45:20.500 --> 45:24.500]  Все n делить на log n блоков и в каждом лог квадрата отрезка.
[45:26.500 --> 45:27.500]  А, вот и все.
[45:28.500 --> 45:29.500]  Да.
[45:29.500 --> 45:30.500]  Это будет многовато, да.
[45:31.500 --> 45:33.500]  Ну, вот, значит, ну, здесь понятно.
[45:33.500 --> 45:37.500]  Ну, здесь понятно, что B явно тут, опять же, совсем идеально не получится,
[45:38.500 --> 45:41.500]  но B там, типа, логарифм n у нас есть,
[45:41.500 --> 45:44.500]  давайте скажем, что B равно, ну, например, log n пополам.
[45:46.500 --> 45:47.500]  Да?
[45:48.500 --> 45:49.500]  Тогда у нас что получится?
[45:50.500 --> 45:55.500]  Тогда заметим, что здесь у нас все еще пошлеп-шлепается.
[45:55.500 --> 45:57.500]  Ну, а симпатически, конечно, но пошлеп-шлепается.
[45:58.500 --> 45:59.500]  Ну, вот.
[45:59.500 --> 46:03.500]  А здесь получится O от n, а здесь получится какой-то какой-то, там, по-моему,
[46:03.500 --> 46:05.500]  корень из n умножить на что-то там от логарифма.
[46:06.500 --> 46:10.500]  А нельзя слушать и просто заменить, что, на самом деле, у нас минимум не изменится,
[46:10.500 --> 46:12.500]  если мы сначала все уменьшим, а потом все уменьшится.
[46:13.500 --> 46:17.500]  То есть у нас есть, если получить минимум, как будто отрезки маленького блока,
[46:18.500 --> 46:22.500]  то самое, чтобы получить минимум на просто блоке,
[46:22.500 --> 46:24.500]  где начало бывает, а конец возрастает.
[46:25.500 --> 46:28.500]  Ну, и вообще, я думаю, что это очень интересно.
[46:28.500 --> 46:30.500]  Так, сейчас одну минуту, я прошу прощения.
[46:37.500 --> 46:39.500]  Так, давайте еще раз, что вопрос стал?
[46:40.500 --> 46:42.500]  Повторись, как мы отвечаем на маленький вопрос.
[46:43.500 --> 46:45.500]  На маленький, а вот рост блока?
[46:46.500 --> 46:47.500]  Да.
[46:48.500 --> 46:49.500]  Рост блока.
[46:50.500 --> 46:51.500]  Рост блока.
[46:52.500 --> 46:53.500]  Рост блока.
[46:54.500 --> 46:55.500]  Рост блока.
[46:55.500 --> 46:56.500]  На маленький.
[46:57.500 --> 47:00.500]  На маленький, а вот ровно ради того, чтобы отвечать на маленькие запросы,
[47:01.500 --> 47:05.500]  мы перебрали все маленькие подотрески.
[47:06.500 --> 47:08.500]  Ну, мы говорим, что с точностью до вот этого вот звига,
[47:09.500 --> 47:11.500]  до прибавления константы, они на самом деле,
[47:12.500 --> 47:14.500]  их на самом деле всего два в степени бубен.
[47:15.500 --> 47:18.500]  Вот, мы все перебираем, для каждого из них можно там в тупую найти ответ.
[47:19.500 --> 47:22.500]  Ну, да, можно не в тупую, можно тоже в рекурсии его насчитывать,
[47:22.500 --> 47:25.500]  можно вот без этого бубна обойтись, но это не принципиально.
[47:26.500 --> 47:27.500]  У меня сломался мозг.
[47:28.500 --> 47:30.500]  Как мы определяем подотреску, какой вид он имеет?
[47:31.500 --> 47:32.500]  Мы явно это хренили.
[47:33.500 --> 47:34.500]  Ну, смотри.
[47:35.500 --> 47:36.500]  Конечно, кажется, в отрезку приходится.
[47:37.500 --> 47:38.500]  Но идея такая, смотри.
[47:39.500 --> 47:40.500]  Нет, смотри, смотри.
[47:41.500 --> 47:42.500]  Пиши, пиши, пиши.
[47:43.500 --> 47:45.500]  Так, смотри, ты не туда смотри, ты сюда смотри.
[47:46.500 --> 47:47.500]  Вот, смотри.
[47:48.500 --> 47:51.500]  Во-первых, для каждого блока можно в явном виде посчитать маску заранее, да?
[47:52.500 --> 47:56.500]  А если у меня подотрезок лежит внутри этого блока,
[47:57.500 --> 48:00.500]  то я из этой маски могу взять подотрезок маски.
[48:03.500 --> 48:04.500]  За вот одного.
[48:05.500 --> 48:06.500]  За вот одного, да.
[48:07.500 --> 48:10.500]  Ну, там очень правильные вот сдвиги туда-сюда решают вопрос.
[48:11.500 --> 48:14.500]  Нет, можно даже так, один сдвиг туда, один сдвиг туда.
[48:15.500 --> 48:18.500]  Знаете, такой метод, стеклоочистители такие вот этого.
[48:19.500 --> 48:23.500]  Кстати, я не знаю, если в NT делать сдвиг на переполнение, он не ЛБ?
[48:25.500 --> 48:28.500]  В NT ЛБ, в OnSide не ЛБ.
[48:29.500 --> 48:31.500]  Во, все, делайте в OnSide и будет часть.
[48:32.500 --> 48:33.500]  Хотя я не знаю.
[48:34.500 --> 48:36.500]  Хотя это должен быть какой-то очень интересный компилятор.
[48:37.500 --> 48:38.500]  Хотя вот действительно, что это за интересный компилятор,
[48:39.500 --> 48:42.500]  в который как бы INT и OnSide там делают эти операции неодинаково?
[48:43.500 --> 48:46.500]  Ну, формально они имеют право делать.
[48:46.500 --> 48:47.500]  Да.
[48:48.500 --> 48:51.500]  В OnSide в переполнении это норма, а в NT ЛБ.
[48:52.500 --> 48:56.500]  Нет, это да, это да.
[48:57.500 --> 49:01.500]  Нет, я этот прикол от стандарта помню, это да.
[49:02.500 --> 49:05.500]  Это интересно, но просто знаете, интересно,
[49:06.500 --> 49:09.500]  просто исходя из каких потенциальных архитектур
[49:10.500 --> 49:11.500]  вообще такую оговорку вставляли.
[49:11.500 --> 49:18.500]  Ну, не превосходят.
[49:19.500 --> 49:21.500]  Да, может это будет еще раз.
[49:22.500 --> 49:24.500]  В то время от квадрата в следующую.
[49:25.500 --> 49:26.500]  Что мы делаем?
[49:27.500 --> 49:30.500]  Мы говорим, что на каждом подотреске узнаем минимум.
[49:31.500 --> 49:32.500]  Вот, обход фиксированного угла.
[49:33.500 --> 49:34.500]  Что мы для этого делаем?
[49:35.500 --> 49:36.500]  Мы говорим, что на самом деле минимум на этом подотреске,
[49:37.500 --> 49:39.500]  на маленьком, внутри него,
[49:39.500 --> 49:42.500]  это то же самое, что и минимум на всем бубне,
[49:43.500 --> 49:44.500]  если у него маску заменить начальному на убывание,
[49:45.500 --> 49:46.500]  последнюю взрастает.
[49:47.500 --> 49:48.500]  Ну, вот все так, я согласен с тем,
[49:49.500 --> 49:51.500]  что при большом желании можно этот бубен убрать, да.
[49:52.500 --> 49:53.500]  Можно было даже с маской не заморачиваться,
[49:54.500 --> 49:55.500]  а еще и перебирать.
[49:56.500 --> 49:59.500]  Утверждаете, что у вас собирать с бубнами,
[50:00.500 --> 50:02.500]  условия с размером с бубнами,
[50:03.500 --> 50:04.500]  работать у отъедения нет?
[50:04.500 --> 50:08.500]  Нет, слушайте, конкретно перебор,
[50:09.500 --> 50:10.500]  можно делать рекурсивные переборы,
[50:11.500 --> 50:12.500]  сравнить там минимум на префиксе.
[50:13.500 --> 50:14.500]  Например, минимум на префиксе.
[50:15.500 --> 50:17.500]  Я не понимаю, я говорю про то, как мы запросы внутри блока.
[50:21.500 --> 50:22.500]  Сейчас, тогда давай еще раз так.
[50:23.500 --> 50:24.500]  Так, как отвечать на запрос внутри блока?
[50:25.500 --> 50:28.500]  Ну, на запросы мы в итоге там потом отвечаемся у отъединицы, например.
[50:29.500 --> 50:31.500]  Ну, а мы и мы так делаем, да, исходно.
[50:31.500 --> 50:32.500]  Собственно, нет, просто.
[50:33.500 --> 50:34.500]  Ну, давай.
[50:35.500 --> 50:38.500]  Еще раз, что такое минимум на подотрезке бубна?
[50:39.500 --> 50:42.500]  Это то же самое, что и минимум на всем бубне, но на другом.
[50:43.500 --> 50:45.500]  Я не говорю про блока.
[50:46.500 --> 50:48.500]  Э-э-э...
[50:49.500 --> 50:50.500]  Сделаем следующее преобразование, когда у нас есть какая-то маска,
[50:51.500 --> 50:52.500]  правда, отвечающая на нашу текущую блогу.
[50:53.500 --> 50:54.500]  Но...
[50:55.500 --> 50:56.500]  Сделаем следующее преобразование с этой маской.
[50:57.500 --> 50:58.500]  Если мы хотим узнать ответ на подотрезке,
[50:58.500 --> 51:01.500]  то мы за нулим все начало и за единичем весь конец.
[51:02.500 --> 51:04.500]  Что это значит с точки зрения преобразования на массиве?
[51:05.500 --> 51:07.500]  Это значит, что на самом деле мы как бы сделали,
[51:08.500 --> 51:09.500]  что с самого начала у нас весь массив убывает,
[51:10.500 --> 51:11.500]  в середине он остается такой же, как подотрезок,
[51:12.500 --> 51:13.500]  а потом весь он застает.
[51:14.500 --> 51:15.500]  Следовательно, минимум этой штуки не поменялся.
[51:16.500 --> 51:17.500]  А, а в чем прикол?
[51:18.500 --> 51:19.500]  Прикол в том, что мы здесь в таблице храним только размеры бубна,
[51:20.500 --> 51:21.500]  а не хранимся меньшие размеры, что ли, или что?
[51:22.500 --> 51:23.500]  Да, то есть на самом деле нам нужно уметь просто по груну
[51:24.500 --> 51:25.500]  получать прикальт от него.
[51:26.500 --> 51:27.500]  Ну, хорошо.
[51:28.500 --> 51:30.500]  Просто уметь замулять начало и заединять конец.
[51:31.500 --> 51:32.500]  Ну, понятно, да, в общем, да.
[51:33.500 --> 51:34.500]  Ну, понятно, то есть в общем, да.
[51:35.500 --> 51:36.500]  Это нам даже ничего просто прикольно.
[51:37.500 --> 51:38.500]  Ну, окей, да.
[51:39.500 --> 51:40.500]  Не, ну, я не знаю, да, тут философский вопрос, да,
[51:41.500 --> 51:42.500]  что лучше с точки зрения именно технической на самом деле,
[51:43.500 --> 51:44.500]  хотя...
[51:45.500 --> 51:46.500]  Очевидно...
[51:47.500 --> 51:48.500]  Можно вопрос?
[51:49.500 --> 51:50.500]  Ну, философский вопрос.
[51:51.500 --> 51:52.500]  Ну, как считаете, да.
[51:53.500 --> 51:54.500]  Ну, ладно.
[51:55.500 --> 51:56.500]  На подотрезке?
[51:56.500 --> 51:59.500]  Так что, смотри, если подотрезок попадает целиком внутри блока,
[52:00.500 --> 52:01.500]  то вот мы только что обсудили.
[52:02.500 --> 52:03.500]  А если не попадает?
[52:04.500 --> 52:05.500]  А если не попадает, то значит мы заод...
[52:06.500 --> 52:08.500]  Ну, так как у нас границы блоков, блоки там ровно по бубен,
[52:09.500 --> 52:11.500]  то можно заод единицы вычислить вот тут, так сказать,
[52:12.500 --> 52:14.500]  вот этот вот кончик какого-то блока,
[52:15.500 --> 52:17.500]  вот конец начала вот этого блока
[52:18.500 --> 52:19.500]  и вот этот вот набор блоков, который тут идет.
[52:20.500 --> 52:21.500]  Нет, это я понял.
[52:22.500 --> 52:23.500]  А если наоборот внутри блока размера бубен?
[52:24.500 --> 52:25.500]  Вот.
[52:26.500 --> 52:28.500]  А вот это мы только что обсуждали.
[52:29.500 --> 52:31.500]  Ну в том плане, что у нас есть маска...
[52:32.500 --> 52:33.500]  Ну, например, один из способов.
[52:34.500 --> 52:37.500]  У нас есть маска Бубна и в ней можно взять под маску,
[52:38.500 --> 52:39.500]  ну не под маску, вот это.
[52:40.500 --> 52:41.500]  То есть мы считаем, что это заод единицы вычислить?
[52:42.500 --> 52:43.500]  Ну да, ну, что-то считаем.
[52:44.500 --> 52:45.500]  Это естественным образом считается заод единицы,
[52:46.500 --> 52:48.500]  там, скажем, например, сдвинуть, например, вправо,
[52:49.500 --> 52:52.500]  сдвинуть влево сюда и сдвинуть вправо сюда, например.
[52:53.500 --> 52:54.500]  Нет, просто...
[52:54.500 --> 53:00.500]  Ну, работаем. Ну оно у нас все равно не более алгоритмно, так что да, работаем.
[53:04.500 --> 53:09.500]  Ну или там... или можно так... не, ну то есть по-любому работаем с битвным словом,
[53:09.500 --> 53:12.500]  потому что можно было посчитать на всех подотресках длинной бубен,
[53:12.500 --> 53:17.500]  вот прям всех подотресках маски, а потом там для каждой маски предпочитать маски всех ее префиксов,
[53:17.500 --> 53:19.500]  тоже там вписав их вот в этот предподсчет, например.
[53:19.500 --> 53:24.500]  То есть тут как бы переборы работают практически как угодно, да.
[53:24.500 --> 53:29.500]  То есть я тут могу хоть бубен сотый подставить, на самом деле асимпточка не поменяется.
[53:29.500 --> 53:33.500]  Да, с точки зрения реализации это будет, конечно...
[53:33.500 --> 53:39.500]  Ну вот. Но соответственно. Приятно?
[53:39.500 --> 53:45.500]  Вот. Это была халявная версия статика рынку.
[53:45.500 --> 53:55.500]  Но оказывается, что по большому счету ее... она эквивалентна основной статике рынку.
[53:55.500 --> 54:01.500]  И даже не просто эквивалентной, а еще она эквивалентной вообще, казалось бы, неожиданной задачей.
[54:01.500 --> 54:10.500]  Она оказалась эквивалентной задачей поиска лца в дереве. Правда, в дереве фиксировано?
[54:10.500 --> 54:17.500]  В чем? Именно вот рынку не просто на любом массиве, а вот именно на таком.
[54:17.500 --> 54:25.500]  В линкате. Не надо.
[54:25.500 --> 54:28.500]  Нет, линкат был в прошлый раз, все.
[54:28.500 --> 54:35.500]  Забудем. Ну что забудем, нет.
[54:35.500 --> 54:40.500]  Не, ну я же всегда... классика же, да. Если хочешь любить, люби. Если хочешь забыть, забудь.
[54:40.500 --> 54:45.500]  Только знай, что в конце пути все это будет на экзамене.
[54:51.500 --> 54:58.500]  У меня нет столько задач на линкат. А на ФФТ? Были же.
[54:58.500 --> 55:03.500]  Ну вот на ФФТ были, но линкат нету.
[55:03.500 --> 55:05.500]  Ну сууу, все.
[55:19.500 --> 55:22.500]  У меня есть бубен-задач на линкат, да.
[55:22.500 --> 55:24.500]  Где бубен равно...
[55:24.500 --> 55:27.500]  На этом мы не сомневаемся, кстати.
[55:27.500 --> 55:32.500]  Ага, осталось только понять, чему равно бубен, а точнее функция бубена Т.
[55:32.500 --> 55:39.500]  Так вот, значит, эта задача, кстати, да, тоже часто ее называют как статик РМКу плюс-минус один.
[55:39.500 --> 55:41.500]  Вот.
[55:41.500 --> 55:43.500]  Кстати.
[55:43.500 --> 55:45.500]  Так вот.
[55:45.500 --> 55:50.500]  А теперь представьте себе, что у нас есть задача статик ЛЦА.
[55:50.500 --> 55:53.500]  Статик.
[55:53.500 --> 56:00.500]  То есть у нас есть дерево подвешенное, состоящее из N-вершин, абсолютно произвольное,
[56:00.500 --> 56:03.500]  не какое-то и ваше сбалансированности, естественно.
[56:03.500 --> 56:07.500]  Да там даже, как бы оно и в общем двоичным быть не обязано.
[56:07.500 --> 56:13.500]  И у нас там и хочется сделать какой-то местический предподсчет
[56:13.500 --> 56:18.500]  и научиться потом за вот единицы находить ЛЦА любых в оферши.
[56:18.500 --> 56:25.500]  Но на самом деле мы в прошлый раз изучили, как на самом деле свести эту задачу, кстати, к РМКу плюс-минус один за линию.
[56:25.500 --> 56:27.500]  Как мы это делали?
[56:27.500 --> 56:28.500]  Я не вспоминаю.
[56:28.500 --> 56:35.500]  Мы просто запускаем ДФС и каждый раз, когда мы видим вершину, мы записываем ее, ее глубину, помните, да?
[56:35.500 --> 56:38.500]  Видимо разность глубины.
[56:38.500 --> 56:40.500]  Да можно и в тупую.
[56:40.500 --> 56:42.500]  Нет, именно глубины.
[56:42.500 --> 56:46.500]  То есть в данном случае набор этих глубин будет 0, 1, 2.
[56:46.500 --> 56:47.500]  Там, да, что будет дальше?
[56:47.500 --> 56:50.500]  1, 2, 1 там.
[56:50.500 --> 56:51.500]  А потом поехали.
[56:51.500 --> 56:56.500]  Там 2, 3, 2, 3, 4, 3, 4, 3, 4.
[56:59.500 --> 57:16.500]  Там 3, 4, 5, 6, 7, 6, 5, 4, 5, 6, 7, 8, нет, 5, 6, 7, 8, да, тут надо остановиться.
[57:16.500 --> 57:26.500]  7, 6, 5, 4, 3, 2, 3, 2, 1, 0, 1, 2, ну и так далее, короче, да.
[57:26.500 --> 57:28.500]  Ну принцип помнил.
[57:28.500 --> 57:30.500]  Ну принцип вспомнили, я думаю, да.
[57:30.500 --> 57:41.500]  Но самое главное, что мы тут еще название этих вершин пишем, да, что, например, ну как всегда, если это Х, это А, это Q там и так далее.
[57:41.500 --> 57:44.500]  Ну то есть естественный порядок букв такой, да.
[57:44.500 --> 57:47.500]  Ну такой, естественно, попорчи все кодировки, естественно, но тем не менее.
[57:47.500 --> 57:51.500]  Вот, значит, K, L там, ну вот, то тут получится.
[57:51.500 --> 58:04.500]  Там X, A, B, там A, D, A, там R, F, R, там G, там K, G.
[58:04.500 --> 58:06.500]  Ну в общем, тоже принцип поняли, думаю.
[58:06.500 --> 58:18.500]  Помните, да, и оказывалось, что как найти теперь L, значит, там, допустим, у буковки B и буковки, там, и буковки какой-нибудь там L, например, да, или там такой мы дошли, до буковки K.
[58:18.500 --> 58:29.500]  Мы берем первое вхождение этих буковок в этот массив, берем подотрезок, на этом подотрезке находим минимум, этому минимуму соответствует L.
[58:29.500 --> 58:33.500]  Помните принцип, да?
[58:33.500 --> 58:40.500]  Но теперь заметим, что размер этого массива, если у нас тут дерево размера N, то размер массива у нас какой?
[58:40.500 --> 58:44.500]  Мимо.
[58:44.500 --> 58:47.500]  Отточнее.
[58:47.500 --> 58:51.500]  Вот тут можно просто абсолютно точный ответ сказать.
[58:51.500 --> 58:57.500]  Мимо.
[58:57.500 --> 59:02.500]  Вот, 2N-1, потому что еще в начало есть.
[59:02.500 --> 59:07.500]  Вот мы записываем коринг, и после этого мы как бы по ребру походим по два раза и записываем конец.
[59:07.500 --> 59:14.500]  Поэтому все-таки 2N-1.
[59:14.500 --> 59:19.500]  Вот.
[59:19.500 --> 59:20.500]  Соответственно.
[59:20.500 --> 59:28.500]  И получается тогда, что мы, получается, за O от N свели задачу к статике РМК, причем плюс-минус 1.
[59:28.500 --> 59:33.500]  Потому что когда мы проходим по ребру, высота изменяется на ровно 1.
[59:33.500 --> 59:36.500]  Удобно, правда?
[59:36.500 --> 59:40.500]  Вот.
[59:40.500 --> 59:49.500]  Но теперь оказывается классический алгоритм Фарах Колтона Бендера.
[59:49.500 --> 59:56.500]  Или, как говорят, алгоритм Фарах Колтона и Бендера.
[59:56.500 --> 01:00:00.500]  То есть, правильно говорить, алгоритм Фарах Колтона Бендера.
[01:00:00.500 --> 01:00:02.500]  То есть, Фарах не надо.
[01:00:02.500 --> 01:00:08.500]  Хотя, или Фараха Колтона, наверное, надо.
[01:00:08.500 --> 01:00:10.500]  Хотя, вот, кстати, тут тоже вопрос.
[01:00:10.500 --> 01:00:17.500]  Фарах Колтона, там Бендера, или потому что есть Бендеры вообще.
[01:00:17.500 --> 01:00:19.500]  Я тут не поручусь.
[01:00:19.500 --> 01:00:21.500]  Хотя, по-моему, все-таки тут нормальная фамилия.
[01:00:21.500 --> 01:00:22.500]  Так что, да.
[01:00:22.500 --> 01:00:23.500]  Вот.
[01:00:23.500 --> 01:00:24.500]  Ну да, проспоти.
[01:00:24.500 --> 01:00:25.500]  Фарах Колтона.
[01:00:25.500 --> 01:00:26.500]  Нет.
[01:00:26.500 --> 01:00:30.500]  Нет, нет, нет, нет.
[01:00:30.500 --> 01:00:34.500]  Нет, просто там, просто я не помню там фамилия этого ученого.
[01:00:34.500 --> 01:00:37.500]  Фарах Бендер или Бендера.
[01:00:37.500 --> 01:00:41.500]  Мало ли.
[01:00:41.500 --> 01:00:42.500]  Тут я...
[01:00:42.500 --> 01:00:45.500]  Как бы я помню, что Фарах Колтон это двойная фамилия.
[01:00:45.500 --> 01:00:48.500]  Там по экзотической причине, но я не буду ее оглашать.
[01:00:48.500 --> 01:00:49.500]  Чего?
[01:00:49.500 --> 01:00:51.500]  Да, это два человека.
[01:00:51.500 --> 01:00:52.500]  Не, не Фарах Колтон.
[01:00:52.500 --> 01:00:55.500]  Фарах Колтон это один человек.
[01:00:55.500 --> 01:00:58.500]  Да, у него двойная фамилия такая, да.
[01:00:58.500 --> 01:01:00.500]  Ну он там что-то, по-моему, это...
[01:01:00.500 --> 01:01:02.500]  Там что-то женился, что ли?
[01:01:02.500 --> 01:01:04.500]  Или там поэтому...
[01:01:04.500 --> 01:01:05.500]  А.
[01:01:05.500 --> 01:01:07.500]  Можете повторить, что вот написано.
[01:01:11.500 --> 01:01:13.500]  5, 4, 3...
[01:01:18.500 --> 01:01:19.500]  Где?
[01:01:19.500 --> 01:01:21.500]  Ну 0, 1, 2, 1, 2.
[01:01:24.500 --> 01:01:27.500]  X, A, B, A, D, A, R, F, R.
[01:01:28.500 --> 01:01:32.500]  Это D, F, S, N, E, D, A, F.
[01:01:32.500 --> 01:01:33.500]  Вот именно это я спрашивал.
[01:01:33.500 --> 01:01:34.500]  Окей.
[01:01:35.500 --> 01:01:37.500]  Ну да, то прозвучало чуть по-другому, да.
[01:01:39.500 --> 01:01:40.500]  Вот.
[01:01:40.500 --> 01:01:41.500]  Так вот.
[01:01:41.500 --> 01:01:43.500]  Значит так вот, классический алгоритм говорит, что
[01:01:43.500 --> 01:01:47.500]  а теперь давайте к задаче LCA сведем задачу статика РМК.
[01:01:50.500 --> 01:01:53.500]  То есть на этот раз без вот этих вот плюс-минус единичек.
[01:01:53.500 --> 01:01:54.500]  То есть обратите внимание.
[01:01:54.500 --> 01:01:57.500]  Без вообще вот этих плюс-минус единичек как-то это сделаем.
[01:01:57.500 --> 01:01:59.500]  Просто сведем к LCA.
[01:02:00.500 --> 01:02:01.500]  Как же это сделать?
[01:02:08.500 --> 01:02:09.500]  Да.
[01:02:10.500 --> 01:02:11.500]  Ну да.
[01:02:11.500 --> 01:02:14.500]  Можно было бы сказать, что давайте за линию построим дикартовое дерево.
[01:02:18.500 --> 01:02:19.500]  Ну...
[01:02:20.500 --> 01:02:21.500]  Ну...
[01:02:22.500 --> 01:02:23.500]  Ну ладно.
[01:02:24.500 --> 01:02:25.500]  Не, ну как не прошли.
[01:02:25.500 --> 01:02:28.500]  Можно, в принципе, быстренько обсудить, что это такое, да.
[01:02:33.500 --> 01:02:34.500]  Ну-ка.
[01:02:35.500 --> 01:02:36.500]  Все, что нам потребуется, мы можем доказать?
[01:02:36.500 --> 01:02:38.500]  Нет, ну пока нам нужно только определение, да.
[01:02:38.500 --> 01:02:40.500]  Потому что что такое дикартовое дерево?
[01:02:40.500 --> 01:02:44.500]  Это такое простое по реализации двойничного дерева поиска,
[01:02:44.500 --> 01:02:46.500]  которое говорит так.
[01:02:46.500 --> 01:02:48.500]  Вот допустим, у нас есть какие-то ключи.
[01:02:50.500 --> 01:02:52.500]  Я их в возрастающем порядке напишу, допустим.
[01:02:56.500 --> 01:02:57.500]  Вот.
[01:02:57.500 --> 01:02:58.500]  И мы говорим так.
[01:02:58.500 --> 01:02:59.500]  Ну да.
[01:02:59.500 --> 01:03:02.500]  Мы из них можем составить двойничных деревьев.
[01:03:02.500 --> 01:03:03.500]  Сколько там?
[01:03:03.500 --> 01:03:04.500]  Число каталана.
[01:03:04.500 --> 01:03:05.500]  Сколько, как мы уже выясняли.
[01:03:06.500 --> 01:03:07.500]  Вправивается теперь...
[01:03:08.500 --> 01:03:09.500]  Что спрашивается?
[01:03:10.500 --> 01:03:12.500]  Ну вот теперь спрашивается, как же его балансировать.
[01:03:13.500 --> 01:03:15.500]  А принцип теперь очень простой.
[01:03:15.500 --> 01:03:19.500]  В каждой вершине мы введем такое понятие, как приоритет.
[01:03:21.500 --> 01:03:22.500]  Что это такое?
[01:03:22.500 --> 01:03:23.500]  Это число.
[01:03:23.500 --> 01:03:24.500]  В данном случае абсолютно случайное.
[01:03:26.500 --> 01:03:27.500]  Вот.
[01:03:27.500 --> 01:03:28.500]  Ну там как случайное, да.
[01:03:28.500 --> 01:03:31.500]  Какое-нибудь целое, значит равноверное, распределенное,
[01:03:31.500 --> 01:03:33.500]  там ноты и прочие заклинания.
[01:03:34.500 --> 01:03:35.500]  Вот.
[01:03:35.500 --> 01:03:36.500]  И пишем вот.
[01:03:36.500 --> 01:03:37.500]  Сейчас я напишу абсолютно какие-нибудь произвольные
[01:03:37.500 --> 01:03:38.500]  числа.
[01:03:38.500 --> 01:03:41.500]  7, 5, 8, 1, 4, там 6, 2, 5.
[01:03:42.500 --> 01:03:45.500]  9, 3.
[01:03:46.500 --> 01:03:49.500]  Потому что это еще одно дерево.
[01:03:50.500 --> 01:03:54.500]  Да, знаете, у нас этих, знаете, как это называется, деревьев
[01:03:54.500 --> 01:03:56.500]  немало у нас сложено.
[01:03:57.500 --> 01:03:59.500]  Вот сейчас я вам спою еще одно.
[01:03:59.500 --> 01:04:00.500]  Соответственно.
[01:04:01.500 --> 01:04:02.500]  Как сказал бы классик.
[01:04:03.500 --> 01:04:05.500]  Потому что у нас было АВЛ дерево.
[01:04:05.500 --> 01:04:07.500]  АВЛ дерево нас по идее всегда выручал.
[01:04:08.500 --> 01:04:10.500]  Мы сказали, что ой, нам не нравится, что поворотов
[01:04:10.500 --> 01:04:11.500]  слишком много.
[01:04:11.500 --> 01:04:13.500]  Нам хочется, чтобы поворотов было мало.
[01:04:13.500 --> 01:04:15.500]  И мы изобрели красно-черное дерево, чтобы поворотов
[01:04:15.500 --> 01:04:16.500]  было от единицы.
[01:04:17.500 --> 01:04:20.500]  Там будут какие-то там, будут какие-то там пробрасывания
[01:04:20.500 --> 01:04:22.500]  каких-то битиков, но это не глобально.
[01:04:23.500 --> 01:04:25.500]  Или, например, мы сказали, ну вот.
[01:04:25.500 --> 01:04:28.500]  Или мы сказали, что мы хотим какой-то свободы, мы хотим
[01:04:28.500 --> 01:04:30.500]  там реализации кучи вариантов.
[01:04:30.500 --> 01:04:31.500]  И мы и появился сплей.
[01:04:32.500 --> 01:04:35.500]  То есть сплей сказал, что сплей, что да, это, конечно,
[01:04:35.500 --> 01:04:37.500]  амортизация, но зато если вы тыкнули в вершину, то
[01:04:37.500 --> 01:04:39.500]  она у вас где-то рядом.
[01:04:40.500 --> 01:04:41.500]  Вот.
[01:04:41.500 --> 01:04:43.500]  То есть там вот подрождаем, ну вот.
[01:04:43.500 --> 01:04:46.500]  И там мы сказали, что мы хотим, чтобы у нас в вершине
[01:04:46.500 --> 01:04:48.500]  хранилось много информации, потому что нам в вершине
[01:04:48.500 --> 01:04:50.500]  надо скачивать, у нас появилось б дерево.
[01:04:51.500 --> 01:04:52.500]  То есть как бы дереве, ну вот.
[01:04:52.500 --> 01:04:54.500]  И это еще, я вас уверяю, это еще не все деревья, которые
[01:04:54.500 --> 01:04:55.500]  изобрели человечество.
[01:04:56.500 --> 01:04:57.500]  Ну это очевидно.
[01:04:57.500 --> 01:04:59.500]  Да, там еще, называется, там еще есть.
[01:05:02.500 --> 01:05:03.500]  Ну вот.
[01:05:03.500 --> 01:05:04.500]  Так вот.
[01:05:04.500 --> 01:05:06.500]  Но, тем не менее, цели изобрели еще одну.
[01:05:06.500 --> 01:05:09.500]  Потому что у всех тех деревьев есть маленький недостаток.
[01:05:09.500 --> 01:05:10.500]  Что он звать?
[01:05:10.500 --> 01:05:12.500]  Там реализация Берсер-Берсер.
[01:05:14.500 --> 01:05:17.500]  Поэтому оказалось придумано называть вот такое, так
[01:05:17.500 --> 01:05:19.500]  называемое дикартовое дерево.
[01:05:20.500 --> 01:05:21.500]  Вот.
[01:05:21.500 --> 01:05:23.500]  Ну мы подробно его не обсуждаем, потому что есть подозрение,
[01:05:23.500 --> 01:05:26.500]  что, что, что дикартовое дерево вы все прекрасно знаете?
[01:05:27.500 --> 01:05:28.500]  Или нет?
[01:05:29.500 --> 01:05:31.500]  Ну хотя что, ну поднимите руки.
[01:05:31.500 --> 01:05:33.500]  Кто хотя бы раз в жизни писал дикартовое дерево?
[01:05:34.500 --> 01:05:35.500]  Ну да.
[01:05:36.500 --> 01:05:37.500]  А, ну да.
[01:05:38.500 --> 01:05:40.500]  Осталось только вспомнить, у вас случайно там это, в
[01:05:40.500 --> 01:05:42.500]  каком-нибудь входном тестировании случайно продвинутый
[01:05:42.500 --> 01:05:44.500]  потоп не было задачи дикартового дерева, да?
[01:05:45.500 --> 01:05:46.500]  Не было.
[01:05:46.500 --> 01:05:47.500]  Специально тоже не было.
[01:05:48.500 --> 01:05:49.500]  Что?
[01:05:49.500 --> 01:05:51.500]  Там было значено на ДФС так.
[01:05:51.500 --> 01:05:52.500]  Ааа.
[01:05:53.500 --> 01:05:54.500]  Ну да.
[01:05:55.500 --> 01:05:57.500]  Ой, ну ДФС нам еще, ооо.
[01:05:57.500 --> 01:05:58.500]  Ну там нет.
[01:05:58.500 --> 01:05:59.500]  ДФС нам еще предстоит.
[01:06:01.500 --> 01:06:02.500]  Ну вот.
[01:06:02.500 --> 01:06:03.500]  Так что да.
[01:06:03.500 --> 01:06:04.500]  Ну да.
[01:06:04.500 --> 01:06:05.500]  Поэтому я еще когда-нибудь избегаю дикартово дерево,
[01:06:05.500 --> 01:06:07.500]  при этом хочется просто поделиться, что дикартово,
[01:06:07.500 --> 01:06:10.500]  да, что на самом деле дикартовое дерево с точки зрения идеи
[01:06:10.500 --> 01:06:12.500]  на самом деле не является обязательным.
[01:06:13.500 --> 01:06:16.500]  Но у него есть основное преимущество, что по сравнению с остальными
[01:06:16.500 --> 01:06:18.500]  деревьями, конечно оно пишется просто тупо проще.
[01:06:19.500 --> 01:06:20.500]  Ну вот.
[01:06:20.500 --> 01:06:21.500]  Ну вы знаете как песет, я думаю там сейчас воспроизводить
[01:06:21.500 --> 01:06:23.500]  это бессмысленно естественно.
[01:06:23.500 --> 01:06:24.500]  Вот.
[01:06:24.500 --> 01:06:27.500]  Но в данном случае мы что его вспомнили?
[01:06:28.500 --> 01:06:29.500]  В данном случае мы его вспомнили вот как.
[01:06:29.500 --> 01:06:31.500]  То есть на самом деле, есть вам данные отсортированные
[01:06:31.500 --> 01:06:33.500]  ключи и приоритеты.
[01:06:33.500 --> 01:06:35.820]  приоритеты, всё, кстати, неважно, даже сгенерённые
[01:06:35.820 --> 01:06:40.500]  рандомно или нерандомно, дело в том, что существует
[01:06:40.500 --> 01:06:44.860]  алгоритм, который за линию построит по вот этим ключам
[01:06:44.860 --> 01:06:47.660]  и этим приоритетам корректное дикартовое дерево.
[01:06:47.660 --> 01:06:53.820]  Но алгоритм, на самом деле, оказывается очень простой.
[01:06:53.820 --> 01:06:58.340]  Мы будем добавлять вершины слева направо и добавлять
[01:06:58.340 --> 01:06:59.580]  примерно следующим образом.
[01:06:59.580 --> 01:07:03.380]  То есть сначала, понятно, тут не интересно, у нас будет
[01:07:03.380 --> 01:07:09.460]  одна вершина, там, 1 и 7, что у нас потом ещё будет?
[01:07:09.460 --> 01:07:12.660]  Потом у нас ещё будет 3 нод, потом дальше мы будем говорить
[01:07:12.660 --> 01:07:13.660]  так.
[01:07:13.660 --> 01:07:14.660]  Так, пятёрочка.
[01:07:14.660 --> 01:07:17.740]  По идее, конечно, мы могли бы с точки зрения корректного
[01:07:17.740 --> 01:07:19.820]  двоичного дерева поиска эту тройку подвесить просто
[01:07:19.820 --> 01:07:22.740]  справа к единичке, правда?
[01:07:22.740 --> 01:07:25.420]  Но по приоритету у нас не получается, потому что
[01:07:25.420 --> 01:07:26.420]  пятёрка меньше.
[01:07:26.420 --> 01:07:30.780]  Поэтому мы тройку объявляем корнем и слева от неё вешаем
[01:07:30.780 --> 01:07:31.780]  единичку.
[01:07:32.780 --> 01:07:37.780]  Теперь, что?
[01:07:37.780 --> 01:07:45.780]  Повторить, что у нас ось Х, а что ось Игры.
[01:07:45.780 --> 01:07:46.780]  Нет у нас таких.
[01:07:46.780 --> 01:07:47.780]  У нас есть ключ.
[01:07:47.780 --> 01:07:52.780]  Ну, вот это ключ, это приоритет.
[01:07:52.780 --> 01:07:57.780]  Смотри, ключи ассортированы за сущностью.
[01:07:57.780 --> 01:08:00.780]  Ключи, ну, в смысле, у нас задача в двоичном дереве
[01:08:00.780 --> 01:08:01.780]  поиска.
[01:08:01.780 --> 01:08:02.780]  В чём заключается?
[01:08:02.780 --> 01:08:05.780]  У нас есть чёрный ящик, в котором мы кладём элементы,
[01:08:05.780 --> 01:08:06.780]  называемые ключами.
[01:08:06.780 --> 01:08:12.780]  Ну, пока отдельно, хотя это всё связано.
[01:08:15.780 --> 01:08:16.780]  Ну вот, дальше.
[01:08:16.780 --> 01:08:19.780]  Берём теперь, теперь вот смотрим.
[01:08:19.780 --> 01:08:22.780]  Четвёрочку мы могли бы тоже справа подвесить к троечке.
[01:08:22.780 --> 01:08:25.780]  В чём по приоритетам всё в порядке.
[01:08:25.780 --> 01:08:26.780]  Здрасьте, здрасьте.
[01:08:26.780 --> 01:08:31.780]  И получается, что у нас тут вот четвёрка и восьмёрка.
[01:08:31.780 --> 01:08:34.780]  Вот, получается хорошо.
[01:08:34.780 --> 01:08:35.780]  Вот.
[01:08:35.780 --> 01:08:36.780]  Теперь, смотрите.
[01:08:36.780 --> 01:08:38.780]  Теперь мы будем идти снизу.
[01:08:38.780 --> 01:08:41.780]  То есть мы как бы и семёрочку тоже могли бы повесить к четвёрочке.
[01:08:41.780 --> 01:08:42.780]  Мешает нам только одно.
[01:08:42.780 --> 01:08:46.780]  Приоритет семёрочки как-то меньше приоритет к четвёрочке.
[01:08:46.780 --> 01:08:47.780]  Правда?
[01:08:47.780 --> 01:08:50.780]  Ну, мы же могли бы подвесить её где-то к троечке, а эту
[01:08:50.780 --> 01:08:52.780]  четвёрочку подвесить тогда слева.
[01:08:52.780 --> 01:08:54.780]  Но, единичка меньше этого.
[01:08:54.780 --> 01:08:56.780]  Так, прошлись, прошлись.
[01:08:56.780 --> 01:09:01.780]  И объявили семёрку корень, к которому всё подвесили.
[01:09:01.780 --> 01:09:04.780]  Вот.
[01:09:04.780 --> 01:09:06.780]  Ой, сейчас будет, вот.
[01:09:06.780 --> 01:09:08.780]  Ну, дальше будет два неинтересно.
[01:09:08.780 --> 01:09:10.780]  Значит, дальше тут будет восемь и одиннадцать.
[01:09:10.780 --> 01:09:12.780]  Пока всё просто.
[01:09:12.780 --> 01:09:16.780]  Вот, тут будет четвёрочка, тут будет шестёрочка.
[01:09:16.780 --> 01:09:19.780]  И теперь двенадцать.
[01:09:19.780 --> 01:09:21.780]  А вот теперь, смотрите.
[01:09:21.780 --> 01:09:24.780]  Вот сейчас самый интересный случай такой паказатель.
[01:09:24.780 --> 01:09:27.780]  Могли бы двенадцать подвесить сюда, но приоритет
[01:09:27.780 --> 01:09:29.780]  у неё меньше.
[01:09:29.780 --> 01:09:33.780]  Могли бы подвесить сюда, но тоже приоритет меньше.
[01:09:33.780 --> 01:09:36.780]  Могли бы подвесить сюда, и, ой, хотим подвесить,
[01:09:36.780 --> 01:09:38.780]  тут приоритет, вот тут наоборот приоритет меньше.
[01:09:38.780 --> 01:09:40.780]  Поэтому делать будем это так.
[01:09:40.780 --> 01:09:42.780]  Берём это кислор двенадцать.
[01:09:42.780 --> 01:09:46.780]  Подвесим его, типа, объявляем его правым, ребёнком этого
[01:09:46.780 --> 01:09:47.780]  корня.
[01:09:47.780 --> 01:09:50.780]  А то, чтобы было правым под деревом до этого мы
[01:09:50.780 --> 01:10:01.300]  мы подвесим слева вот сюда вот такая вот приятность вот ну и так дальше теперь
[01:10:01.300 --> 01:10:12.380]  достраиваем но я так сразу спалю ответ там получится вот так примерно 15 и 17 вот тут
[01:10:12.380 --> 01:10:15.740]  в общем-то неинтересно уже 3 5 9 что это такое
[01:10:33.740 --> 01:10:38.740]  вот то есть смотрите то есть вот так вы построили такое дикартово дерево да
[01:10:38.740 --> 01:10:45.660]  заменим даже ну так понятно ли почему это алгоритм а работает б работает за
[01:10:45.660 --> 01:10:54.780]  линию ну то есть вот важный момент да то есть каждый момент времени у нас есть какое-то
[01:10:54.780 --> 01:11:00.740]  дерево и мы хотим добавить элемент который больше всех его элементов которые были раньше
[01:11:00.740 --> 01:11:09.860]  значит мы рассматриваем правый путь но тут что-то там какие-то под деревья весят весят весят
[01:11:09.860 --> 01:11:19.220]  вот значит новый элемент но заметим что тут вот этот вот последовательство церковно она
[01:11:19.220 --> 01:11:29.380]  а церковно попри не только по ключам но и по приоритетам а я даже определение не сказал но
[01:11:29.740 --> 01:11:36.900]  все равно все знают да что по приоритетам на самом деле в дереве должно выполняться свойства кучи в
[01:11:36.900 --> 01:11:43.860]  данном случае куча на минимум я в виде не сказал но да тут и так это все знают поэтому неважно вот
[01:11:43.860 --> 01:11:49.420]  поэтому идея такая то есть ну значит у нас есть элемент с приоритетом и мы ищем куда его тут
[01:11:49.420 --> 01:11:56.300]  надо вставить но ищем его что важно строго снизу вверх то есть можете сказать вот все эти элементы
[01:11:56.300 --> 01:12:01.660]  мы в стеке храним. Если, допустим, оказалось, что вот он где-то здесь, то тогда, значит,
[01:12:01.660 --> 01:12:08.540]  мы вместо этого ребра, там правое ребро отправляем сюда, а сюда, как левого ребёнка, подвешиваем вот это вот.
[01:12:08.540 --> 01:12:19.580]  Всё. Вот. Ну вот. Ну, в принципе, с помощью там любого амортизационного там анализа,
[01:12:19.580 --> 01:12:25.100]  там легко, легко увидеть, что это работает за линию. Ну потому что, как бы, если мы решили,
[01:12:25.100 --> 01:12:29.980]  что мы не подвешиваем сюда, то как бы автоматически эта вершина больше в правом пути никогда не будет.
[01:12:29.980 --> 01:12:39.860]  Ну да, то есть там, да, то есть как бы потенциал, длина правого пути. Всё. Или там, скажем, ну или там
[01:12:39.860 --> 01:12:44.060]  что-нибудь там, можете всё там. На каждую вершину там типа кладём монетку, и каждый раз, когда
[01:12:44.060 --> 01:12:48.740]  проходимся вверх, мы эту монетку снимаем, например, да. Поэтому, получается, сами по себе эти проходы
[01:12:48.740 --> 01:12:59.500]  ничего не стоят. Ну, в общем, как угодно, это уже мелочи. Так вот. При чём тут стать КРМКУ, казалось бы, да?
[01:12:59.500 --> 01:13:09.940]  А идея очень простая. Значит, если вам дан массив стать КРМКУ, то давайте, то вы просто говорите,
[01:13:10.420 --> 01:13:19.180]  что вы себе представляете, что в этом массиве вам дали приоритеты. То есть вы по факту строите
[01:13:19.180 --> 01:13:28.100]  стать КРМКУ вот на массиве приоритетов. Ключи, ну, например, пусть будут 1, 2, 3, 4, 5, там 6, 7, 8, 9, 10.
[01:13:28.100 --> 01:13:35.900]  То есть, ну короче, по неявному ключу что-то. Но с явными приоритетами. То есть не рандомно сгенерированными
[01:13:35.900 --> 01:13:44.900]  на этот раз. А вот так. То есть теперь я утверждаю следующее. Если вы представите, что это приоритеты и построите
[01:13:44.900 --> 01:13:51.940]  такое типа дикартового дерева, то я утверждаю, что для того, чтобы найти минимум на подотреске между
[01:13:51.940 --> 01:13:59.100]  подотрески LR, вам нужно просто взять L-ту вершину, R-ту вершину и найти между ними LCA в этом дереве.
[01:13:59.100 --> 01:14:13.300]  Почему? Ну, доказывать можно, например, так. У нас есть три типа отрезков. Содержащие минимум,
[01:14:13.300 --> 01:14:20.340]  левее минимума и правее минимума, правда? Если отрезок содержит минимум, то один из отрезок
[01:14:20.340 --> 01:14:26.700]  концов тогда будет лежать в этом подтереме, другой в этом. И их LCA будет корень. То есть
[01:14:26.700 --> 01:14:34.140]  минимум будет найден правильно. Понимаете, да? Вот. А если отрезок левее или правее, то корень это точно
[01:14:34.140 --> 01:14:40.980]  не будет. То есть минимум точно будет где-то здесь. Ну и дальше, по сути, по индукции. Вот. Понятно,
[01:14:40.980 --> 01:14:51.380]  да? То есть доказать можно привести, например, таким образом. Вот. То есть вот такой классический
[01:14:51.380 --> 01:15:00.420]  алгоритм в фарах Колтон Бендера. То есть он так технически сложен в том плане, что он сложен из
[01:15:00.420 --> 01:15:05.380]  нескольких блоков. То есть надо, чтобы найти минимум на подотреске, вам нужно, значит,
[01:15:05.380 --> 01:15:12.260]  будет потом посмотреть на вершины, вызвать LCA. При вызове LCA, значит, посмотреть тоже,
[01:15:12.260 --> 01:15:18.020]  где они находятся в рынку, ну уже немного вот этом плюс-минус один, которое другое, а в нем уже лезть
[01:15:18.020 --> 01:15:31.060]  в эту таблицу и там выкапывать еще какую-то гадость. А? Ну потому что я говорю, что мы,
[01:15:31.060 --> 01:15:39.020]  но я говорю просто, что мы сказали, что вот этот массив, который нам дан, это приоритеты, ключи,
[01:15:39.020 --> 01:15:45.300]  это просто индексы. И мы построили декартовое, и мы просто взяли и построили честное декартовое
[01:15:45.300 --> 01:15:53.620]  дерево. После этого оказалось, что RM-кун на подотреске от LR это приоритет вершин,
[01:15:53.620 --> 01:16:05.940]  который является LCA L-ты и R-ты вершины в этом дереве. Ну смотрите, ну допустим вот рассмотрим
[01:16:05.940 --> 01:16:13.820]  вот собственно минимум. Если отрезок содержит этот минимум, то тогда LCA двух вершин заведомо
[01:16:13.820 --> 01:16:20.860]  будет корень, правда? Ну потому что если у вас одна вершина из этого поддерева, а другая из
[01:16:20.860 --> 01:16:30.020]  этой, то LCA здесь. Теперь допустим у вас подотрезок, ваш подотрезок правее этого минимума,
[01:16:30.020 --> 01:16:37.500]  да? Тогда обе вершины будут в этом поддереве, и собственных LCA тоже будет где-то в этом поддереве.
[01:16:37.500 --> 01:16:43.180]  Вот рассмотрим минимум этого подотрезка, вот он двойка. Если отрезок будет начинаться до
[01:16:43.180 --> 01:16:47.540]  него и заканчиваться после него, то LCA будет в точности два и минимум будет два, все совпало,
[01:16:47.540 --> 01:16:53.260]  правда? Иначе тогда отрезок либо здесь, либо здесь. Ну вот так же вот в общем так аккуратненько
[01:16:53.260 --> 01:17:03.180]  повторяем это рассуждение. Собственно и все. Так что-то да, пока все просто.
[01:17:03.180 --> 01:17:17.860]  Ну когда отвечаем потом на запрос, да. А вы говорите, а потом аккуратненько повторяем это утверждение.
[01:17:17.860 --> 01:17:27.740]  Это было доказательство, да? Нет, это было доказательство. То есть мы берем из нашего
[01:17:27.740 --> 01:17:34.100]  дерева, строим декартовое дерево, да? Нет, мы берем из массива, строим типа декартовое дерево с
[01:17:34.100 --> 01:17:40.460]  такими приоритетами, да. Из массива, то есть... То есть задан вот рандомный массив. Да. Абсолютно
[01:17:40.460 --> 01:17:45.940]  даже не рандомный, а произвольный. Вот красный. Да. Мы строим по нему декартовое дерево с такими
[01:17:45.940 --> 01:17:54.460]  приоритетами. По этому дереву строим значит массив РМКу плюс-минус один и на нем забабачиваем
[01:17:54.460 --> 01:18:02.140]  собственно основных четырех русских. Все это делаем за линию каждый шаг. Теперь, когда на этом
[01:18:02.140 --> 01:18:09.220]  массиве нужно найти минимум? Значит LR. Мы вызываем функцию, найди, пожалуйста, вот в этом дереве LCA.
[01:18:09.220 --> 01:18:17.420]  Эта функция говорит, так, LR, LR, ага. Так, пойди вон в тот массив РМКу плюс-минус один и найди,
[01:18:17.420 --> 01:18:23.580]  пожалуйста, минимум там. А в этом массиве минимум, ну вы там уже разбираетесь. Вы там либо в таблицу
[01:18:23.580 --> 01:18:39.740]  лезете, либо в спарс тейбл с префиксами, суффиксами. Вот. Минимум на пути так не покатит.
[01:18:39.740 --> 01:18:52.660]  Ну, мне не известно. Нет, мне увы это не известно. Хотя, конечно, задача интересная.
[01:18:52.660 --> 01:19:03.900]  Вот. Что известно вместо этого? Вместо этого известно, ну да, потому что ваше предыдущее
[01:19:03.900 --> 01:19:07.780]  пороление в этом месте подробно рассказал, что на самом деле, если вы хотите решать именно задачу
[01:19:07.780 --> 01:19:14.580]  стать РМКу, то сводить ее к LCA не обязательно. То есть на самом деле четыре русских можно
[01:19:14.580 --> 01:19:22.660]  забабахать прямо здесь. Ну вот. Вот. То есть не знаю, конечно, может быть, конечно, кому-то легче будет
[01:19:22.660 --> 01:19:27.220]  забабахать уже через LCA. Ну, то есть это все равно важно, потому что тут еще, помимо всего прочего,
[01:19:27.220 --> 01:19:31.860]  мы обнаружили, что и задачу LCA можно решать за ОАТН предподсчета и от единицы на запрос, да?
[01:19:31.860 --> 01:19:43.020]  Чего? Нет. Вот сейчас увидите. Нет, сейчас вот, да, вот благодаря тому, что предыдущее поколение
[01:19:43.020 --> 01:19:47.220]  тогда вот вылезло, сейчас я это и расскажу. Нет, тут действительно прикольный метод,
[01:19:47.220 --> 01:19:52.620]  действительно. Смотрите. Сейчас все будет. Итак, то есть представим себе, что мы вот,
[01:19:52.620 --> 01:19:59.260]  как бы не хотим считать никакой LCA почему-то, а хотим напрямую.
[01:20:13.020 --> 01:20:39.660]  Вот. Ну, значит, идея будет такая. Просто хранить, конечно, больше и меньше не получится,
[01:20:39.660 --> 01:20:48.340]  потому что больше и меньше нам будет принципиально насколько. Вот. С другой стороны, конечно, да,
[01:20:48.340 --> 01:20:54.780]  если у нас произвольные числа, то и массивов размера boobin тоже бесконечно много все еще. И на
[01:20:54.780 --> 01:21:00.540]  этот раз даже хак вида прибавь там плюс-минус сколько-нибудь и нормируй, и скажи, что там пусть
[01:21:01.380 --> 01:21:13.860]  нам на этот раз не поможет. Что же делать? Что же делать? Вот. Ну, да, действительно,
[01:21:13.860 --> 01:21:34.460]  что же делать-то вообще? Так. Ну, вот. Ну, делать можно. Ну, вот. Ну, вот. Ну, собственно, логично.
[01:21:34.460 --> 01:21:40.740]  Делать можно примерно следующее. Давайте тоже еще вспомним родной восьмой класс и вспомним,
[01:21:40.740 --> 01:21:47.460]  как искать минимум на деке. Ну, получится. А, ну ладно. Ну ладно, на очереди. Хорошо. Да,
[01:21:47.460 --> 01:21:54.620]  минимум на очереди. Но не тот метод, который типа сведем к двум стэкам и возрадуемся.
[01:21:54.620 --> 01:22:02.900]  Сведем к ДУО. Не. Знаете, не-не-не. Не, вот знаете, вот на эту тему была подлянка, знаете,
[01:22:02.900 --> 01:22:08.780]  забавная. Что-то пару лет назад, по-моему, а может быть в прошлом году там было, а там несколько лет
[01:22:08.780 --> 01:22:13.900]  назад была Олимпиада для там седьмых, восьмых классов. И там вот, там была какая-то последняя
[01:22:13.900 --> 01:22:20.700]  задача. Ну, вот какая-то. Чего? Ну, Олимпиада есть, но там вот, да я просто тут помню,
[01:22:20.700 --> 01:22:25.900]  что там была какая-то мистическая задача. Я уже не помню какая. Ну, да. А, ну да,
[01:22:25.900 --> 01:22:31.180]  возможно, келдыш это и был, да. Но там была фишка такая, что там что-то, там какая-то задача типа,
[01:22:31.180 --> 01:22:37.580]  где тестирование на последней группе тестов последней задачи проводится офлайн. Там был
[01:22:37.580 --> 01:22:44.540]  прикол, что оказалось, что там N было до 10 в седьмой, там все написали ДО и получили 98 баллов. Вот ни
[01:22:44.540 --> 01:22:49.460]  у кого на 100 не упихалось. Потому что оказалось, что просто там есть вот красивые линейные решения,
[01:22:49.460 --> 01:22:55.500]  просто базирующиеся там, ну там, где-то на деке, где-то вот на амортизации вектора. Вот это вот.
[01:22:55.500 --> 01:23:04.580]  Ну, знаете, 98 баллов за ДО на 10 в седьмой это неплохо. Ну, вообще, да, как-то да. Ну, там понятно,
[01:23:04.580 --> 01:23:09.300]  что там какие-то задачи. Обычно там люди подходили уже, называется, закрывшие, остальные закрывшие там
[01:23:09.300 --> 01:23:16.540]  быстро. Вот. Так что забавно это было очень. Вот. Так же, знаете, поэтому, говорю, вспоминаем восьмой
[01:23:16.540 --> 01:23:23.180]  класс и вспоминаем. Вот представьте, что у нас есть очередь и мы хотим искать, допустим, минимум. Как
[01:23:23.180 --> 01:23:31.700]  же мы это делаем? Ну, идея очень простая. Ну, мы, конечно, вот, когда нам в очередь добавляются
[01:23:31.700 --> 01:23:44.820]  элементы, мы, конечно, храним их. Вот. Ну, да, мы, конечно, их все храним. Да, вот, давайте я тут
[01:23:44.820 --> 01:23:56.460]  добавлю несколько там. 4,6, ну, допустим, 2,5. Но внутри эти, но среди них несколько элементов у нас
[01:23:56.460 --> 01:24:04.460]  будут помечены. Кто будет помечен? Значит, помечен, просто вот, просто можно прям это
[01:24:04.460 --> 01:24:16.180]  инвариантом выявлять. Помечены будут, во-первых, минимум. Минимум справа от минимума. Минимум
[01:24:16.180 --> 01:24:32.260]  справа от минимума справа от минимума. И так далее. Ну, если бы строили ддшку, да. Ну, вот,
[01:24:32.260 --> 01:24:38.340]  но по факту, да, лучше формулировать так, потому что, ну, тут, конечно, более того, все эти элементы
[01:24:38.340 --> 01:24:48.380]  мы будем хранить в, где правильно, в стэке. Почему в стэке? Ну, потому что вот идея очень простая
[01:24:48.380 --> 01:24:56.060]  теперь. Значит, ну, во-первых, да, если вы теперь, ну, во-первых, теперь мы сейчас, ну, как бы да,
[01:24:56.060 --> 01:25:03.940]  стэк, ну, ладно, по факту он будет дэк. Ну, типа, ну, почти дэк, такой урезанный дэк. Потому что в том
[01:25:03.940 --> 01:25:11.100]  плане, что мы будем, то есть добавлять сюда слева элементы мы не будем, вот, но удалять,
[01:25:11.100 --> 01:25:17.620]  ну, удалять и отсюда, отсюда мы будем, сейчас вы увидите почему. Ну, потому что, смотрите, если у
[01:25:17.620 --> 01:25:23.460]  нас из очереди, ну, потому что, потому что если у нас из очереди там удаляется элемент, то пока он
[01:25:23.460 --> 01:25:31.140]  не помещен, в общем-то, заметим, минимум не меняется от слова никак, правда? Понимаете, да? Вот.
[01:25:31.140 --> 01:25:42.540]  Вот. А вот неожиданно удаляется и сам этот элемент. Ну, тогда давайте его просто из этой вот красной
[01:25:42.540 --> 01:25:46.180]  очереди удалим, и ничего страшного. То есть, заметим, что следующим минимумом теперь становится
[01:25:46.180 --> 01:25:52.700]  ровно это двойка, потому что по определению она этим и была. Минимум справа от минимума. Удобно,
[01:25:52.700 --> 01:26:08.300]  правда? Вот. Если мы добавляем элементы справа, ну, вот эти красные элементы, да. Вот. Значит,
[01:26:08.300 --> 01:26:15.660]  что мы будем делать здесь? Значит, здесь я вот попробую показать технологию. Вот, допустим,
[01:26:15.660 --> 01:26:22.540]  если мы добавляем 8, если этот элемент больше, чем последний помеченный элемент, то мы его
[01:26:22.540 --> 01:26:32.060]  естественно тоже помечаем. Вот. А вот если пришел элемент меньше последнего помеченного,
[01:26:32.060 --> 01:26:38.740]  ну, на самом деле, по факту, ладно, последний элемент у нас всегда помечен. Тогда что мы делаем?
[01:26:38.740 --> 01:26:46.900]  Мы делаем такую простую, естественную вещь. Мы выкидываем из, так сказать, этого стека и
[01:26:46.900 --> 01:27:00.380]  снимаем пометки у всех элементов, которые больше нас. Вот. То есть, вот такой красивый метод. А,
[01:27:00.380 --> 01:27:06.500]  ну и, конечно, сам этот элемент не забываем пометить. То есть, вот получается такой классический метод
[01:27:06.500 --> 01:27:14.900]  поиска, собственно, минимума в очереди. Тоже, правда, тоже, конечно, амортизированный. То есть,
[01:27:14.900 --> 01:27:21.580]  нельзя сказать, что он там прям лучше двух стеков. Тут амортизация, там амортизация. Но у этого метода,
[01:27:21.580 --> 01:27:28.700]  конечно, есть преимущество. Значит, зачем этот метод нам нужен? Потому что что такое вообще помеченные
[01:27:28.700 --> 01:27:35.900]  элементы? То есть нам говорят, что предположим, что мы бы искали не только минимум на всей очереди,
[01:27:35.900 --> 01:27:44.300]  но и минимум на каком-то суффиксе очереди. Правда? Тогда заметим, что помечены те и только те элементы,
[01:27:44.300 --> 01:27:50.060]  которые могут быть минимумы хоть на каком-то суффиксе. Правда? То есть, по сути, вот этот
[01:27:50.060 --> 01:27:54.300]  элемент помечен. Потом мы идем, идем, идем. Пока все элементы больше, очевидно, значит,
[01:27:54.300 --> 01:27:58.500]  и минимум на суффиксе они не будут, потому что справа от них есть вот лучше. Но как только
[01:27:58.500 --> 01:28:02.220]  нашли элемент меньше, вот значит, на этом суффиксе минимум он, ну и так далее, и так далее.
[01:28:02.220 --> 01:28:17.500]  А Дэк поддерживает обращение пыли? Ну, вообще говоря, да. Эстрелевский поддерживает. Поддерживает,
[01:28:17.500 --> 01:28:24.540]  поддерживает. Поддерживает, поддерживает. Ой, Господи, у нас когда-то, у нас когда-то еще было
[01:28:24.540 --> 01:28:30.740]  даже домашнее задание, напишите такой Дэк. Да, да. А у вас было, у нас хотя бы в теории было.
[01:28:30.740 --> 01:28:34.340]  У нас когда-то тоже когда-то было. Вот, в теории оно было. Нет, у нас когда-то, я имею в виду,
[01:28:34.340 --> 01:28:41.900]  на практике было со всеми шаблонами. Но у нас сейчас в ЧА было. А, в смысле, да. А, ну вот,
[01:28:42.620 --> 01:28:51.300]  буквально Дэк там с безопасностью. Ну слава Богу, слава Богу. Ну вот, а вы говорите,
[01:28:51.300 --> 01:29:05.300]  а вы говорите, когда вам ДЗП дикартийчиков. Да, Мещеринга. А что Мещеринга рука? А Мещеринга
[01:29:05.300 --> 01:29:34.340]  о чем тогда жалуется, почему вы у него не пишите кучи? Я не понял.
[01:29:34.340 --> 01:29:38.340]  Что за логика вообще? Что за ботва?
[01:29:38.340 --> 01:29:48.340]  Ладно, смотрите. В чем фишку? Фишку мы тут уже поняли, да?
[01:29:48.340 --> 01:29:55.340]  Так вот, на самом деле теперь вытекает неожиданная идея.
[01:29:56.340 --> 01:30:00.340]  Точнее, неожиданная и идея, да?
[01:30:00.340 --> 01:30:14.340]  Ну вот, идея теперь заключается в том, что на самом деле, если у нас очередь не сильно большая, то все вот эти помеченные элементы и не помеченные можно закодировать масочкой из ноликов и единичек.
[01:30:17.340 --> 01:30:19.340]  Логично, да?
[01:30:20.340 --> 01:30:32.340]  И в принципе, на самом деле, если нам дана очередь, то нам по ее масочке достаточно, чтобы определить минимум на любом суффиксе.
[01:30:32.340 --> 01:30:41.340]  Потому что все, что нам нужно по факту, это просто взять этот суффикс и найти первую старшую единичку в нем, правда?
[01:30:43.340 --> 01:30:45.340]  Ну вот.
[01:30:46.340 --> 01:30:49.340]  Ну, не желательно за быстро.
[01:30:50.340 --> 01:30:52.340]  Вот.
[01:30:53.340 --> 01:30:57.340]  Ну, собственно, теперь вы уже можете пробить, в общем-то, что у нас будет теперь дальше в алгоритме.
[01:30:58.340 --> 01:31:11.340]  Потому что теперь у меня идея такая. Давайте я пробегусь двумя указателями и для каждого подотреска длины не более чем, ну, например, бубен
[01:31:11.340 --> 01:31:16.340]  Я запишу вот такую масочку.
[01:31:17.340 --> 01:31:19.340]  Я же могу так сделать, правда?
[01:31:20.340 --> 01:31:28.340]  Ну, потому что, когда удаляется элемент, я убираю бит с конца, потом добавляю, значит, что-то там впихиваю в начало, еще какие-то единички обнуляю, ну, в общем, понимаете, да?
[01:31:29.340 --> 01:31:30.340]  Вот.
[01:31:31.340 --> 01:31:36.340]  И тогда у меня фактически задача сведется к простой, то есть у меня, то есть, если меня...
[01:31:37.340 --> 01:31:38.340]  Ну вот.
[01:31:38.340 --> 01:31:39.340]  Ну вот.
[01:31:40.340 --> 01:31:42.340]  Ну, то есть, для чего я это делаю?
[01:31:43.340 --> 01:31:44.340]  Ну, делаю это, например, для следующего.
[01:31:45.340 --> 01:31:59.340]  Ну, во-первых, как вы уже поняли, мы на самом деле без особых там предподсчетов, только, честно, с парстейблом и минимумом, и там, префиксами, суффиксами на блоках, умеем отвечать на все запросы, кроме тех, кто в блоки попадает, помните, да?
[01:32:00.340 --> 01:32:10.340]  То есть, для этого, обратите внимание, то есть, эта технология работает там никак не завязана на плюс-минус один, и, в общем-то, как бы, мы там LCA для этого строить не обязаны.
[01:32:12.340 --> 01:32:18.340]  Поэтому, по сути, нам нужно научиться искать за вот единицы ответ на маленьких подотрезочек.
[01:32:19.340 --> 01:32:21.340]  Ну, тогда идея очень простая.
[01:32:22.340 --> 01:32:29.340]  Любой, как бы, любой подотрезочек длины не более чем бубен, это суффикс какого-то отрезка длины бубен, правда?
[01:32:35.340 --> 01:32:37.340]  Ну, понимаю ваше сомнение, да, это неправда, конечно.
[01:32:44.340 --> 01:32:47.340]  Нет, в данном случае нас интересует, что скорее суффикс отрезка длины бубен.
[01:32:48.340 --> 01:32:53.340]  Ну, можно сделать, чтобы он был префиксом отрезка длины бубен, но мы сделаем, чтобы он был суффиксом отрезка длины бубен.
[01:32:57.340 --> 01:32:59.340]  Да, нам приспяли, что он суффиксом там.
[01:33:03.340 --> 01:33:08.340]  Ну да, подотрезок это префикс суффикса, но нам интересно сейчас, что подотрезок это суффикс префикса.
[01:33:13.340 --> 01:33:15.340]  Что такое? Что, префикс функцию не изучали?
[01:33:19.340 --> 01:33:23.340]  Нет, ну там просто такие словосочетания едва ли не алгоритм построен.
[01:33:28.340 --> 01:33:37.340]  Ну вот, в принципе любой подотрезок является либо суффиксом подотрезка длины бубен, либо суффиксом префикса длины непроисходящей бубен, правда?
[01:33:45.340 --> 01:33:46.340]  Да, это правда.
[01:33:46.340 --> 01:33:50.340]  Ну слава богу, да. От этого неужели я сказал какую-то сложную мысль, да.
[01:33:52.340 --> 01:33:57.340]  Ну хотя как всегда, знаете, вот иногда, да, как-то иногда, знаете, программистов считают умными людьми.
[01:33:58.340 --> 01:34:07.340]  Ну вот, в значительной степени потому, что они вот говорят на таком языке и вообще кажется, что они говорят что-то умное, хотя если разобраться, то в общем-то ничего умного на самом деле никто не сказал.
[01:34:07.340 --> 01:34:12.340]  А если там добавим еще и аббревиатуру, знакомы ли вы с технологией LCA?
[01:34:13.340 --> 01:34:15.340]  А по факту там вот эту фигню, вот в эту фигню.
[01:34:17.340 --> 01:34:19.340]  Так умны ли вы с технологией SOLID?
[01:34:20.340 --> 01:34:22.340]  Да, SOLID DASH, да.
[01:34:23.340 --> 01:34:24.340]  KISS AND DRIVE
[01:34:25.340 --> 01:34:26.340]  Чего?
[01:34:27.340 --> 01:34:29.340]  Не, ну да, там, да, FIFO, LIFO, там вот это все, да.
[01:34:30.340 --> 01:34:34.340]  Да, как говорится, да, мы используем там эти всякие стакедыки. Что такое стакедыки?
[01:34:35.340 --> 01:34:39.340]  Ну, FIFO, LIFO. Что такое FIFO, LIFO? Ну, но FIRST INFESTAL, что?
[01:34:40.340 --> 01:34:43.340]  Ай, просто юнит не из нашего комьюнити, да-да-да.
[01:34:44.340 --> 01:34:47.340]  А, ну ладно, это правда из другой уже оперы немножко, да.
[01:34:53.340 --> 01:34:54.340]  Ну, впрочем, да.
[01:34:56.340 --> 01:34:57.340]  Вот, значит, смотрите.
[01:34:58.340 --> 01:35:04.340]  То есть таким образом получается, в общем, да, можно говорить там кучу умных слов, а суть предельно проста.
[01:35:06.340 --> 01:35:11.340]  То есть как бы я на любом преферсе длины не более чем Бубен и на любом подотреске длины Бубен
[01:35:11.340 --> 01:35:15.340]  я могу насчитать вот эту масочку, причем сделать это за линию, правда?
[01:35:16.340 --> 01:35:23.340]  А еще для каждой масочки и для каждого ее суффикса я могу насчитать там в тупую или чуть менее в тупую ответ
[01:35:24.340 --> 01:35:28.340]  ну, за какую-нибудь там асимптотику типа там, я не знаю, два в степени Бубен на Бубен.
[01:35:29.340 --> 01:35:33.340]  Да, теска, конечно, снова будет сейчас икать от этого Бубена, но это все равно не принципиально.
[01:35:34.340 --> 01:35:36.340]  Вот, или не будет.
[01:35:36.340 --> 01:35:37.340]  Задумался, окей.
[01:35:42.340 --> 01:35:44.340]  Ладно, значит, за линию все сделали.
[01:35:45.340 --> 01:35:48.340]  Ну вот, ну и, конечно, не забываем, наш любимый n делить на Бубен.
[01:35:50.340 --> 01:35:51.340]  Там log n делить на Бубен.
[01:35:52.340 --> 01:35:56.340]  Но анализировать это заново нет смысла, потому что мы буквально это уже анализировали.
[01:35:57.340 --> 01:36:03.340]  И вывели, что при правильном, что берем просто Бубен равно log квадрат, там получается шлеп-шлеп-шлеп,
[01:36:03.340 --> 01:36:04.340]  вот это все.
[01:36:05.340 --> 01:36:07.340]  Кстати, алгоритм, кстати, не сильно сложный получился.
[01:36:09.340 --> 01:36:13.340]  То есть такой, значит, его может быть там сложнее понять, там его там сложно понять,
[01:36:14.340 --> 01:36:18.340]  но там, думаю, там программируя его, в общем-то, сильных страданий вас не ожидает.
[01:36:19.340 --> 01:36:21.340]  Это звучит реально быстро.
[01:36:22.340 --> 01:36:26.340]  То есть еще раз, берем, берем, все, берем отрезок Бубен.
[01:36:27.340 --> 01:36:28.340]  Да.
[01:36:28.340 --> 01:36:30.340]  По нему проходим с этой очереди.
[01:36:31.340 --> 01:36:35.340]  Нет, значит, первое, нет, смотрите, первое, перебираем все возможные маски.
[01:36:36.340 --> 01:36:42.340]  Для каждой маски перебираем все возможные суффиксы, и для каждого суффикса находим самую первую единичку.
[01:36:44.340 --> 01:36:45.340]  Ну, то есть по сути...
[01:36:46.340 --> 01:36:49.340]  Да, по факту, кстати, да-да-да, по сути, тут еще надо Бубен в квадрате написать.
[01:36:50.340 --> 01:36:51.340]  Сейчас, что?
[01:36:52.340 --> 01:36:53.340]  Ну, если мы совсем тупые.
[01:36:53.340 --> 01:36:58.340]  Ну, все масочки, все суффиксы масочек, минимум на суффиксе.
[01:36:59.340 --> 01:37:01.340]  А масочка у нас же не плюс-минус один маск.
[01:37:02.340 --> 01:37:03.340]  А, сейчас.
[01:37:04.340 --> 01:37:05.340]  Но масочка имеет другой смысл.
[01:37:06.340 --> 01:37:08.340]  Нам в этой масочке надо искать старшую единичку.
[01:37:09.340 --> 01:37:10.340]  А, сейчас мы ищем.
[01:37:13.340 --> 01:37:16.340]  Сейчас, все возможные маски из 0 и 1, так?
[01:37:17.340 --> 01:37:18.340]  Да.
[01:37:19.340 --> 01:37:20.340]  Потом...
[01:37:20.340 --> 01:37:21.340]  Да.
[01:37:22.340 --> 01:37:24.340]  Потом, для каждого суффикса, понимаешь...
[01:37:25.340 --> 01:37:26.340]  Ну, это можно просто изменить.
[01:37:27.340 --> 01:37:28.340]  Да.
[01:37:29.340 --> 01:37:30.340]  Ну, и неважно, короче.
[01:37:31.340 --> 01:37:32.340]  Ну, тут неважно, в общем-то, да.
[01:37:33.340 --> 01:37:38.340]  Засчитали для каждого суффикса, а потом для каждого Бубена, подразумеваем Бубен.
[01:37:39.340 --> 01:37:41.340]  Ну да, то есть мы прогуливаемся очередью.
[01:37:42.340 --> 01:37:45.340]  То есть сначала добавляем в очередь Бубен элементов.
[01:37:46.340 --> 01:37:49.340]  А потом там n-Бубен раз делаем, типа, удали первый и добавь следующий.
[01:37:50.340 --> 01:37:52.340]  И эти маски честно хранить.
[01:37:53.340 --> 01:37:54.340]  Все.
[01:37:55.340 --> 01:37:56.340]  Красота?
[01:37:57.340 --> 01:37:58.340]  Благо дать.
[01:37:59.340 --> 01:38:00.340]  Чего?
[01:38:01.340 --> 01:38:03.340]  А на большие так же, как и раньше.
[01:38:04.340 --> 01:38:05.340]  Нет, потому что...
[01:38:06.340 --> 01:38:08.340]  Нет, потому что для больших у нас была какая технология?
[01:38:09.340 --> 01:38:11.340]  Делим, массив тупо на блоке по Бубен, да?
[01:38:12.340 --> 01:38:16.340]  На каждом из них считаем минимум, и на этих минимумах считаем Spark Stable вот за эту ассинтутику.
[01:38:17.340 --> 01:38:18.340]  Вот.
[01:38:18.340 --> 01:38:21.340]  И все, тогда там для больших отрезков останется только подотрезок из блоков.
[01:38:22.340 --> 01:38:24.340]  И там минимум на префиксе, минимум на суффиксе.
[01:38:25.340 --> 01:38:26.340]  Это тоже насчитываем.
[01:38:32.340 --> 01:38:33.340]  Спарсы?
[01:38:34.340 --> 01:38:36.340]  Нет, погоди, Спарсы мы...
[01:38:37.340 --> 01:38:38.340]  Нет, Спарсы мы никак не обновляем.
[01:38:41.340 --> 01:38:43.340]  Нет, нет, погоди, а какие Спарсы?
[01:38:44.340 --> 01:38:45.340]  Зачем нам обновлять Спарсы?
[01:38:48.340 --> 01:38:56.340]  Нет, еще раз на самом деле, скажем так, нет, Спарсы и вот это вот очередь мы делаем для двух разных типов запросов.
[01:38:57.340 --> 01:39:00.340]  То есть мы хотим научиться отвечать на, значит, два типа запросов.
[01:39:01.340 --> 01:39:02.340]  Первый тип запросов это...
[01:39:03.340 --> 01:39:05.340]  То есть так, разделим массив на блоке по Бубен, да?
[01:39:06.340 --> 01:39:07.340]  И у нас есть два типа запросов.
[01:39:08.340 --> 01:39:09.340]  Тип запроса номер раз.
[01:39:10.340 --> 01:39:11.340]  Подотрезок, попавший внутрь блока.
[01:39:13.340 --> 01:39:16.340]  И второй тип запроса, который зацепляет несколько блоков.
[01:39:17.340 --> 01:39:23.340]  Значит, второй тип запросов мы с самого начала обрабатываем тупым образом следующего содержания.
[01:39:24.340 --> 01:39:28.340]  То есть дело в том, что каждый подотрезок это подотрезок блоков целиком попавших, да?
[01:39:29.340 --> 01:39:31.340]  Там суффикс какого-то блока и префикс какого-то блока.
[01:39:32.340 --> 01:39:39.340]  Тогда идея такая, значит, на каждом блоке, значит, на суффиксе насчитываем минимум прям в тупую на этот раз.
[01:39:40.340 --> 01:39:41.340]  И на префиксе насчитываем минимум тоже.
[01:39:42.340 --> 01:39:43.340]  Ну, за как?
[01:39:44.340 --> 01:39:45.340]  Да, ну сумма на этом мы делаем за N.
[01:39:46.340 --> 01:39:47.340]  Да.
[01:39:48.340 --> 01:39:49.340]  Да, вот.
[01:39:50.340 --> 01:39:53.340]  И теперь нам остается только взять минимум в каждом из этих блоков и найти среди них минимум.
[01:39:54.340 --> 01:39:55.340]  Ровно для этого мы насчитали спарстейбл.
[01:39:56.340 --> 01:39:57.340]  Стоп.
[01:39:58.340 --> 01:40:05.340]  А если у нас отрезок будет такой, что вот этот суффикс и единичка первая лежит дальше, чем этот отрезок?
[01:40:06.340 --> 01:40:09.340]  Не-не-не, в последний бит заведомо один.
[01:40:10.340 --> 01:40:15.340]  Нет, у нас же подотрезок, который мы спрашиваем, он префикс этого суффика.
[01:40:16.340 --> 01:40:18.340]  Так не надо его делать префиксом.
[01:40:19.340 --> 01:40:22.340]  Надо брать отрезок, чтобы он был его суффиксом и чтобы он был его префиксом.
[01:40:23.340 --> 01:40:24.340]  То есть, смотри, не путай.
[01:40:25.340 --> 01:40:30.340]  Когда я сейчас вот говорю про спарстейбл, я про блок говорю, то есть это массив поделил на N поделить на бубен блок.
[01:40:31.340 --> 01:40:32.340]  Это да, это ладно.
[01:40:33.340 --> 01:40:42.340]  А для того, чтобы ответить на второй тип запроса, я насчитаю масочку не для блоков, а для всех подотрезков, для каждого из подотрезков длины бубен.
[01:40:42.340 --> 01:40:45.340]  То есть для этого, для этого, для этого, для этого, для этого ровно.
[01:40:45.340 --> 01:40:47.340]  Поэтому я очередью и прогуливаюсь.
[01:40:51.340 --> 01:40:54.340]  Для каждого подотреска вы считаете все префиксы его?
[01:40:54.340 --> 01:40:55.340]  Нет-нет-нет.
[01:40:55.340 --> 01:40:58.340]  Я для каждого подотреска, такого подотреска считаю масочку.
[01:41:00.340 --> 01:41:04.340]  А, и мы отсчетем подотресок в момент, когда у него R сфотопадет с текущим...
[01:41:05.340 --> 01:41:06.340]  Ну да.
[01:41:06.340 --> 01:41:07.340]  Да, именно.
[01:41:07.340 --> 01:41:11.340]  То есть мы возьмем 2MAS, то есть как бы тот подотрезок, чтобы наш был его суффиксом.
[01:41:11.340 --> 01:41:16.340]  для всех таких масок, какие-то будут суффиксы педиксов, то есть, какие будут менять на суффиксе педиксов.
[01:41:17.340 --> 01:41:22.340]  То есть, мы считаем эту масочку, а изначально при подсчете всех масочек, он отвечает на суффиксы педиксов.
[01:41:23.340 --> 01:41:24.340]  Сейчас, еще раз.
[01:41:25.340 --> 01:41:29.340]  То есть, мы считаем для каждого отрезка длинной глубины маску,
[01:41:30.340 --> 01:41:34.340]  потом мы перед этим маском еще при просчете поняли как бы
[01:41:35.340 --> 01:41:40.340]  для всех таких масок, какие-то будут суффиксы педиксов, то есть, какие будут менять на суффиксы педиксов.
[01:41:41.340 --> 01:41:44.340]  Не-не-не, зачем, зачем, зачем?
[01:41:45.340 --> 01:41:50.340]  Нам нужны, нам даже не минимумы, нам для каждой маски, для каждого и для каждого суффикса маски,
[01:41:51.340 --> 01:41:53.340]  нужно найти старшую единичку в этом суффиксе.
[01:41:54.340 --> 01:41:56.340]  Вот все, что надо.
[01:41:57.340 --> 01:41:58.340]  Ну да.
[01:41:59.340 --> 01:42:04.340]  То есть, можно делать прям совсем в тупую, если совсем в тупую делать, бубен в квадрат, но даже это нам жизнь не испортит.
[01:42:05.340 --> 01:42:08.340]  Хотя понятно, что прям вот за бубен в квадрат вы даже делать не будете.
[01:42:08.340 --> 01:42:14.340]  Ну, потому что если в тупую, для каждой масочки, коих два в степени бубен,
[01:42:15.340 --> 01:42:20.340]  для каждого суффикса, коих бубен, мы будем находить ближайшую единичку к началу за от бубен.
[01:42:30.340 --> 01:42:33.340]  Нет, если у нас, нет, не путайте разные отрезки.
[01:42:34.340 --> 01:42:39.340]  Если у нас есть отрезок элег, мы найдем отрезок длины бубен, который имеет с ним одинаковый конец.
[01:42:41.340 --> 01:42:46.340]  Для него мы тоже масочку мы считали не только вот для вот этих блоков, но и вот для вот этих блоков тоже.
[01:42:47.340 --> 01:42:49.340]  Потому что мы очередью аккуратненько шли.
[01:42:53.340 --> 01:42:55.340]  А у нас очередь вообще удаляется с начала?
[01:42:55.340 --> 01:42:56.340]  Конечно.
[01:42:57.340 --> 01:43:05.340]  Потому что, ну, потому что мы поддерживаем, потому что нас интересует только, чтобы очередь, длина очереди была не более чем бубен.
[01:43:09.340 --> 01:43:10.340]  Мы же можем пройтись.
[01:43:11.340 --> 01:43:16.340]  Мы же когда добавляем элементы, вот у нас насчитан на суффикси корректный все еще.
[01:43:17.340 --> 01:43:21.340]  Ну окей, ты можешь поддерживать не очередь, а только маску для последних бубен.
[01:43:22.340 --> 01:43:24.340]  Но не кажется, мы никогда не удаляем начальные элементы?
[01:43:25.340 --> 01:43:26.340]  Удаляем.
[01:43:27.340 --> 01:43:29.340]  Когда мы добавляем, перед чем как добавить новый, удаляем первый.
[01:43:40.340 --> 01:43:41.340]  Ну да.
[01:43:44.340 --> 01:43:45.340]  Мы удаляем старый.
[01:43:46.340 --> 01:43:49.340]  Мы здесь явно в виде пользуемся тем, что длина этого отрезка не больше чем бубен.
[01:43:50.340 --> 01:43:56.340]  Потому что, помните, когда у вас отрезок длины бубен, напоминаю, мы как бы пользуемся уже другой технологией.
[01:43:58.340 --> 01:44:02.340]  Как бы, да, тут все базируется на том, что маску произвольного размера мы хранить не можем.
[01:44:03.340 --> 01:44:09.340]  То есть мы не можем, если бы мы могли хранить маску размера N и делать там все операции, то может мы, конечно, там Spark Stable бы не строили.
[01:44:11.340 --> 01:44:17.340]  Но правда, там для перебрать все маски размера N мы так и так не можем, даже если бы мы их могли хранить там адекватно.
[01:44:19.340 --> 01:44:23.340]  То есть на памяти мы получается используем N на бубен плюс N на бубен?
[01:44:24.340 --> 01:44:25.340]  Нет, нет, нет, нет.
[01:44:26.340 --> 01:44:27.340]  Почему это?
[01:44:32.340 --> 01:44:36.340]  Нет, смотри, мы памяти используем для хранения этих бубенов суффиксов вот столько.
[01:44:37.340 --> 01:44:39.340]  Ладно, даже не столько, а вот без двойки.
[01:44:40.340 --> 01:44:42.340]  Там два в степени бубен на бубен, потому что у нас масок всего два в степени бубен.
[01:44:42.340 --> 01:44:49.340]  И для каждого из них мы для каждого суффикса храним ответ.
[01:44:50.340 --> 01:44:52.340]  Получается памяти два в степени бубен на бубен.
[01:44:53.340 --> 01:44:55.340]  Или даже меньше.
[01:44:56.340 --> 01:45:10.340]  То есть на самом деле, да, эта вот фишка методов четырехрусских заключается в том, что если вы возьмете очень маленький бубен, то окажется, что просто вот подотресков, которые вы тут можете встретить, их на самом деле больше, чем у вас этих подотресков в принципе.
[01:45:10.340 --> 01:45:12.340]  То есть они будут повторяться, по сути.
[01:45:13.340 --> 01:45:16.340]  А мы делаем офлайн, да, и как мы на запрос отвечаем?
[01:45:17.340 --> 01:45:19.340]  Нет, боже мой, никак не офлайн.
[01:45:20.340 --> 01:45:36.340]  Ну смотрите, если у вас далее LR, вы смотрите, если этот отрезок как бы маленький, то есть там длины не больше, чем бубен, да, например, то вы говорите так, раз найдем подотрезок, который имеет с ним один и тот же конец, имеет длину бубен, ну или префикс,
[01:45:37.340 --> 01:45:43.340]  для него мы в предподсчете сохранили вот эту масочку очереди, конкретно этого отрезка.
[01:45:45.340 --> 01:45:53.340]  В этой очереди мы берем суффикс вот длины R-L плюс один, и там уже посчитан минимум, да.
[01:45:55.340 --> 01:46:02.340]  Нет, отдельная песня, что задача там найдите старшую единицу, возможно, кстати, ваш компилятор тоже уже умеет решать, или точнее ваш компьютер.
[01:46:03.340 --> 01:46:06.340]  Ну да, старшие единицы, там задний компьютер.
[01:46:07.340 --> 01:46:08.340]  Ну вот да.
[01:46:09.340 --> 01:46:13.340]  То есть в идее мы себе даже можем позволить прям большой бубен сделать, но…
[01:46:14.340 --> 01:46:17.340]  Ну, как сказать, больше логарифа вы по-любому не сделаете.
[01:46:18.340 --> 01:46:29.340]  Нет, ну как сказать, дальше все как всегда, да, то это и бубен, что в реальности вы там, скорее всего, будете пытаться подгонять и смотреть, как это реально работает.
[01:46:29.340 --> 01:46:42.340]  То есть потому что понятно, что мы тут условно асимпатический анализ производим, но если вы хотите подогнать точный бубен, вам именно точный практический бубен, то вам, конечно, тут надо бы еще константу этого и константу этого еще уметь подгонять.
[01:46:43.340 --> 01:46:45.340]  Так что тут такой, конечно, момент.
[01:46:47.340 --> 01:46:48.340]  Вот.
[01:46:49.340 --> 01:46:54.340]  Так что получается вот такой вот красивый штук.
[01:46:59.340 --> 01:47:02.340]  Так, ну что, есть ли тут какие-то вопросы?
[01:47:05.340 --> 01:47:06.340]  Ну вот.
[01:47:07.340 --> 01:47:13.340]  Да, как-то не подросально, но на этом у нас метод четырехрусских не заканчивается.
[01:47:14.340 --> 01:47:20.340]  Да, мы сегодня рассмотрим еще две задачи поиска метода четырехрусских, которые решаются методом четырехрусских.
[01:47:21.340 --> 01:47:24.340]  Но думаю, для того, чтобы их рассмотреть, нам потребуется перерыв.
[01:47:25.340 --> 01:47:33.340]  Так вот, ну вот наконец-то я стер, поэтому можно двигаться к следующей задаче, которую мы сейчас доведем до идеала методом четырехрусских.
[01:47:35.340 --> 01:47:42.340]  И эта задача – level ancestor queries.
[01:47:44.340 --> 01:47:45.340]  За что?
[01:47:46.340 --> 01:47:47.340]  За единицу.
[01:47:50.340 --> 01:47:51.340]  Ну и за линию, конечно.
[01:47:52.340 --> 01:47:53.340]  Спасибо.
[01:47:53.340 --> 01:47:55.340]  Пожалуйста, еду.
[01:47:56.340 --> 01:47:57.340]  Вот.
[01:47:58.340 --> 01:48:05.340]  Итак, level ancestor queries, которые мы с вами в прошлый раз научились тоже решать за n log n и o от единиц.
[01:48:07.340 --> 01:48:11.340]  Но для дайешего нам придется немножко вспомнить, а как мы это вообще сделали.
[01:48:14.340 --> 01:48:15.340]  Да.
[01:48:16.340 --> 01:48:20.340]  Напомню, что у нас сначала, давайте вспомним, о чем вообще задача.
[01:48:20.340 --> 01:48:25.340]  Ну задача такая, что дано дерево, и на нем нужно отвечать на запросы вида.
[01:48:26.340 --> 01:48:28.340]  Дано вершина v и число h.
[01:48:29.340 --> 01:48:32.340]  Найдите, пожалуйста, предка вершины v на расстоянии h от нее.
[01:48:34.340 --> 01:48:35.340]  Вот.
[01:48:36.340 --> 01:48:37.340]  Ну такая вот была задача.
[01:48:38.340 --> 01:48:44.340]  Значит, чтобы ее решить, мы сначала придумали, как вы помните, longest pass decomposition.
[01:48:50.340 --> 01:48:51.340]  Вот.
[01:48:52.340 --> 01:48:55.340]  Значит, мы придумали, ну вот, мы придумали longest pass decomposition.
[01:48:56.340 --> 01:48:57.340]  То есть, ну, что он говорил?
[01:48:58.340 --> 01:49:01.340]  Что как бы каждую вершину, то есть там каждая вершина понятна.
[01:49:02.340 --> 01:49:08.340]  Если она лист, то она конец пути, а если нет, то как бы мы там типа запускаемся рекурсирно от детей,
[01:49:09.340 --> 01:49:12.340]  и после этого подсовываемся к этой вершине.
[01:49:12.340 --> 01:49:18.340]  Ну понятно, если она лист, то она конец пути, а если нет, то как бы мы там типа запускаемся рекурсирно от детей,
[01:49:19.340 --> 01:49:22.340]  и после этого подсоединяем эту вершину к самому длинному пути.
[01:49:23.340 --> 01:49:24.340]  Да.
[01:49:25.340 --> 01:49:31.340]  Или что то же самое, мы из каждой вершины пытаемся найти самый длинный путь, который ведет из нее в какой-то лист.
[01:49:32.340 --> 01:49:34.340]  Ну там своего потомка, естественно.
[01:49:35.340 --> 01:49:36.340]  Вот.
[01:49:37.340 --> 01:49:38.340]  Это называется longest pass decomposition.
[01:49:39.340 --> 01:49:45.340]  Там строится за линию, и оказалось, что уже с его помощью, по идее, на всякие level ancestor queries можно отвечать за корень.
[01:49:46.340 --> 01:49:47.340]  Помните, да?
[01:49:48.340 --> 01:49:58.340]  Этот корень очень быстро превратился в лог, когда мы превратили longest pass decomposition в ladder, так сказать, decomposition.
[01:49:59.340 --> 01:50:00.340]  Напишу здесь decomposition в кавычках.
[01:50:02.340 --> 01:50:05.340]  Ну потому что, формально говоря, это не декомпозиция.
[01:50:06.340 --> 01:50:13.340]  Отличается она от longest, тем, напомню, что мы просто взяли тот же longest pass decomposition, но к каждому пути,
[01:50:14.340 --> 01:50:18.340]  вот если этот путь длинный L, мы приписали еще L предков.
[01:50:20.340 --> 01:50:23.340]  Там родители, там корни этого пути.
[01:50:24.340 --> 01:50:25.340]  Помните, да?
[01:50:25.340 --> 01:50:29.340]  Стоп, а где мы вообще были, делали не за подъемом?
[01:50:32.340 --> 01:50:33.340]  Вот, сейчас.
[01:50:34.340 --> 01:50:35.340]  Значит, мы сделали такой ladder.
[01:50:36.340 --> 01:50:41.340]  С помощью конкретно ladder decomposition подъемы, то есть подниматься на высоту h можно за логарифом.
[01:50:42.340 --> 01:50:43.340]  Но тут и фишка.
[01:50:44.340 --> 01:50:47.340]  То есть с помощью ladder decomposition подниматься можно за логарифом на высоту h.
[01:50:48.340 --> 01:50:52.340]  С помощью двоичных подъемов можно подниматься на высоту h тоже за логарифом.
[01:50:53.340 --> 01:50:59.340]  А если объединить эти две магии, то можно подниматься за от единицы.
[01:51:01.340 --> 01:51:08.340]  Потому что предположим, что у вас насчитано и ladder decomposition, и двоичные подъемы для всех вершин.
[01:51:09.340 --> 01:51:11.340]  Как мы тогда, напомню, поднимаемся?
[01:51:12.340 --> 01:51:25.340]  Тогда если нам велено подняться на высоту h, то мы поднимаемся с помощью одного двоичного подъема на максимальную степень двойки, не превосходящую h.
[01:51:28.340 --> 01:51:33.340]  То есть такую вот 2 степень h, 2 степень k меньше либо равно h и меньше чем 2 степень k плюс 1.
[01:51:34.340 --> 01:51:43.340]  И тогда оказывается, что оставшееся расстояние вы уверенно можете покрыть в ladder decomposition и подняться за от единицы.
[01:51:45.340 --> 01:51:46.340]  Почему?
[01:51:47.340 --> 01:51:53.340]  Да потому что у этой вершины в longest-pest decomposition длина пути хотя бы 2 степень k, правда?
[01:51:55.340 --> 01:51:57.340]  Ну потому что как минимум вот этот путь есть, а может и длиннее.
[01:51:58.340 --> 01:52:00.340]  Может он куда-то ответляется и идет глубже, но это еще лучше.
[01:52:01.340 --> 01:52:08.340]  То есть это означает, что в ladder decomposition получается мы наверх можем уйти на 2 степень k.
[01:52:09.340 --> 01:52:15.340]  А так как расстояние у нас оставшееся меньше чем 2 степень k, то получается мы за от единицы спокойно нужную вершину находим.
[01:52:18.340 --> 01:52:21.340]  Это было краткое содержание предыдущей серии на эту тему.
[01:52:30.340 --> 01:52:32.340]  А они где слежатся? Где мы их храним?
[01:53:00.340 --> 01:53:05.340]  Так как бы подниматься по ladder decomposition мы можем за от единицы спокойно просто перескочив массиве.
[01:53:06.340 --> 01:53:07.340]  Вот.
[01:53:08.340 --> 01:53:09.340]  Но у этого метода есть...
[01:53:10.340 --> 01:53:12.340]  Ну то есть этот метод у нас работает...
[01:53:13.340 --> 01:53:14.340]  Ну то есть это считается таким, да.
[01:53:15.340 --> 01:53:16.340]  Ну вот, такой метод.
[01:53:17.340 --> 01:53:20.340]  То есть он получается работает за n log n предподсчета и от единицы в итоге.
[01:53:21.340 --> 01:53:23.340]  За счет чего n log n?
[01:53:24.340 --> 01:53:25.340]  За счет предподсчета.
[01:53:26.340 --> 01:53:29.340]  За счет предподсчета чего?
[01:53:30.340 --> 01:53:31.340]  Чего?
[01:53:32.340 --> 01:53:33.340]  В двоичных подъемах.
[01:53:34.340 --> 01:53:35.340]  Чего? Радмила уже умирает.
[01:53:36.340 --> 01:53:38.340]  Умирает. Понятно.
[01:53:39.340 --> 01:53:40.340]  Вот.
[01:53:41.340 --> 01:53:42.340]  Ладно.
[01:53:43.340 --> 01:53:44.340]  Радмила, не умирайте.
[01:53:45.340 --> 01:53:46.340]  А не надо.
[01:53:47.340 --> 01:53:49.340]  Потому что сейчас снова придут 4 русских.
[01:53:53.340 --> 01:53:55.340]  Это напоминает мне какой-то мем, ну ладно.
[01:53:56.340 --> 01:53:57.340]  Ну да.
[01:53:58.340 --> 01:53:59.340]  Вот не знаю.
[01:54:01.340 --> 01:54:05.340]  Ой, Господи, знаете, такой странный парадокс на самом деле, да.
[01:54:06.340 --> 01:54:07.340]  Почему-то да.
[01:54:08.340 --> 01:54:09.340]  Студенты приходят на лекцию и на них хотят умиреть.
[01:54:10.340 --> 01:54:11.340]  Вот я не знаю.
[01:54:12.340 --> 01:54:13.340]  Я почему-то стал преподавателем.
[01:54:14.340 --> 01:54:15.340]  У меня что-то стало наоборот.
[01:54:16.340 --> 01:54:17.340]  Вы уходите с лекции?
[01:54:18.340 --> 01:54:19.340]  Нет, наоборот.
[01:54:20.340 --> 01:54:21.340]  Понимаете, я вот так просыпаюсь.
[01:54:22.340 --> 01:54:23.340]  А мне приходится на лекции?
[01:54:24.340 --> 01:54:25.340]  Нет, мне вот приходится как-то тяжело вставать, а что-то прочуть.
[01:54:26.340 --> 01:54:27.340]  Вот такая сегодня я с этим не справился, поэтому опоздал.
[01:54:28.340 --> 01:54:29.340]  Вот еще прошу прощения еще раз.
[01:54:30.340 --> 01:54:31.340]  Вы знаете, как-то вот весело становится.
[01:54:32.340 --> 01:54:33.340]  Я не знаю почему.
[01:54:34.340 --> 01:54:35.340]  Вот как-то вот хорошо, я не знаю.
[01:54:36.340 --> 01:54:38.340]  Я не знаю, может я, конечно, просто пожираю у вас всю энергию.
[01:54:39.340 --> 01:54:40.340]  Я не знаю.
[01:54:41.340 --> 01:54:42.340]  Так вот.
[01:54:43.340 --> 01:54:44.340]  Да, да, да.
[01:54:45.340 --> 01:54:46.340]  Только представьте, теперь еще не только я.
[01:54:47.340 --> 01:54:48.340]  Потом после обеда еще Мещерин придет.
[01:54:49.340 --> 01:54:50.340]  Собственно, не обедавший.
[01:54:53.340 --> 01:54:54.340]  Ну вот.
[01:54:55.340 --> 01:54:56.340]  И так далее.
[01:54:57.340 --> 01:54:58.340]  Так вот, смотрите.
[01:54:58.340 --> 01:55:01.340]  После Мещерина отсюда поползают все, в том числе Илья.
[01:55:02.340 --> 01:55:03.340]  Ну это да.
[01:55:04.340 --> 01:55:05.340]  Так вот.
[01:55:06.340 --> 01:55:07.340]  Ладно.
[01:55:08.340 --> 01:55:09.340]  Потому что то, что ему с нами легко, это неправда.
[01:55:10.340 --> 01:55:11.340]  Так вот, ладно.
[01:55:12.340 --> 01:55:13.340]  Ну вот, а в чем это выражается?
[01:55:14.340 --> 01:55:15.340]  Ну ему с нами не легко.
[01:55:17.340 --> 01:55:18.340]  Шо, вы ему много вопросов задаете?
[01:55:19.340 --> 01:55:20.340]  Ну мне вы как бы тоже вопросы задаете.
[01:55:21.340 --> 01:55:22.340]  Еще это нормальный процесс.
[01:55:23.340 --> 01:55:24.340]  Ну и...
[01:55:25.340 --> 01:55:26.340]  Нет, вы знаете, я вам так скажу.
[01:55:26.340 --> 01:55:27.340]  Я так скажу.
[01:55:28.340 --> 01:55:31.340]  Когда задают вопросы, особенно если они по делу активнее, то на самом деле это как бы активное общение.
[01:55:32.340 --> 01:55:33.340]  На самом деле обмен энергии.
[01:55:34.340 --> 01:55:35.340]  Поэтому как раз хорошо.
[01:55:36.340 --> 01:55:38.340]  То есть в этом смысле это гораздо лучше, чем, допустим, если я там просто четыре часа вещаю в пустоту.
[01:55:39.340 --> 01:55:41.340]  То есть это работает Зен Логан, понятно?
[01:55:42.340 --> 01:55:44.340]  Ну двоичный подъем из Зен Логан.
[01:55:45.340 --> 01:55:47.340]  Сколько будет дважды два?
[01:55:48.340 --> 01:55:52.340]  Да, вот иногда на втором курсе и до такого доходят, конечно.
[01:55:53.340 --> 01:55:54.340]  Да.
[01:55:55.340 --> 01:55:56.340]  Чего?
[01:55:57.340 --> 01:56:00.340]  Ну кто-то же записывает лекцию.
[01:56:01.340 --> 01:56:02.340]  Ну кто-то записывает, кто-то приходит.
[01:56:03.340 --> 01:56:04.340]  Ну да.
[01:56:05.340 --> 01:56:08.340]  То есть нет, их, конечно, там, да, к сожалению, тенденция такова, что там, конечно, люди все меньше и меньше, да.
[01:56:09.340 --> 01:56:10.340]  Нет, ну может там темы неинтересные, потоки там.
[01:56:11.340 --> 01:56:12.340]  В четвертом семестре вообще никто не приходит.
[01:56:13.340 --> 01:56:14.340]  В четвертый, да.
[01:56:15.340 --> 01:56:17.340]  Ну там, правда, такая оговорка, там и я не прихожу.
[01:56:18.340 --> 01:56:19.340]  Нет, а вот зря.
[01:56:20.340 --> 01:56:23.340]  На самом деле, мне кажется, на четвертом семестре на алгоритмы должны приходить как раз большее количество людей.
[01:56:24.340 --> 01:56:25.340]  Потому что там параллельно алгоритмы.
[01:56:26.340 --> 01:56:27.340]  То есть это как бы вообще не олимпиадная тема.
[01:56:28.340 --> 01:56:29.340]  Поэтому туда как бы и по идее должны приходить.
[01:56:30.340 --> 01:56:32.340]  Вообще не олимпиадная дистеритическая алгоритма.
[01:56:33.340 --> 01:56:34.340]  Ну нет, ну это хоть как-то связано.
[01:56:35.340 --> 01:56:36.340]  Ну вот это олимпиадный алгоритм реальный.
[01:56:37.340 --> 01:56:40.340]  То есть это там еще один мой тезко там вполне себе там в Тинькоффе рассказывает.
[01:56:41.340 --> 01:56:43.340]  Но я, по крайней мере, это от него узнал, но это я уже говорил.
[01:56:44.340 --> 01:56:45.340]  Так вот, ладно.
[01:56:46.340 --> 01:56:50.340]  А теперь вас начинают приветствовать четыре русских.
[01:56:51.340 --> 01:56:53.340]  Значит, где они начинают вас приветствовать?
[01:56:54.340 --> 01:56:56.340]  Ну давайте начнем с того.
[01:57:01.340 --> 01:57:05.340]  Значит, начнем с того, что мы сейчас можем в наглую оказываться.
[01:57:06.340 --> 01:57:07.340]  Вот первая идея такая неожиданно тупая.
[01:57:08.340 --> 01:57:11.340]  Мы можем решать задачу делать этот предподсчет двоечных подъемов.
[01:57:12.340 --> 01:57:15.340]  Ну заметим, что вот эти логи слайдер мы предподсчитываем за линию.
[01:57:16.340 --> 01:57:17.340]  Правда?
[01:57:18.340 --> 01:57:20.340]  Так вот, а на самом деле, ну ладно, n мы оставим.
[01:57:20.340 --> 01:57:29.340]  Но на самом деле подсчет двоичных подъемов можно делать за количество листов на логен.
[01:57:33.340 --> 01:57:40.340]  Ну идея такая, на самом деле двоичные подъемы реально нужно искать только на листах.
[01:57:43.340 --> 01:57:44.340]  Почему так?
[01:57:45.340 --> 01:57:46.340]  Ну чит заключается в следующем.
[01:57:46.340 --> 01:57:54.340]  Вместо того, чтобы подниматься из этой вершины на высоту h, мы можем спуститься из этой вершины на какой-нибудь заранее подготовленный лист у нее в поддереве.
[01:57:55.340 --> 01:58:00.340]  Мы даже заранее еще и можем предподчитать, что он там находится на глубине, допустим, d от v.
[01:58:01.340 --> 01:58:02.340]  Да?
[01:58:03.340 --> 01:58:05.340]  И, ну где вот эта вершина v?
[01:58:06.340 --> 01:58:10.340]  И после этого просто подниматься из этого листа на высоту d от v плюс h, правда?
[01:58:11.340 --> 01:58:14.340]  Ну такое своеобразное выливание воды из чайника, да?
[01:58:15.340 --> 01:58:17.340]  То есть как подняться на 57 ступенях?
[01:58:18.340 --> 01:58:20.340]  Надо сначала провалиться на 179, а потом, собственно, подняться.
[01:58:21.340 --> 01:58:22.340]  Вот, очень удобно.
[01:58:23.340 --> 01:58:25.340]  Вот, типичная ситуация такая, да.
[01:58:26.340 --> 01:58:27.340]  Вот, правда?
[01:58:29.340 --> 01:58:30.340]  Вот.
[01:58:31.340 --> 01:58:33.340]  Правда возникает такая маленькая оговорочка.
[01:58:34.340 --> 01:58:40.340]  Ведь когда мы считали двоичные подъемы, мы жестко пользовались тем, что мы считали их для всех вершин.
[01:58:40.340 --> 01:58:41.340]  Помните, да?
[01:58:42.340 --> 01:58:43.340]  Да.
[01:58:44.340 --> 01:58:52.340]  Потому что для того, чтобы посчитать двоичный подъем, скажем, на 256, нам нужно было подняться на высоту 128 и взять уже ранее подсчитанный двоичный подъем там на 128.
[01:58:53.340 --> 01:58:54.340]  Правда?
[01:58:55.340 --> 01:59:00.340]  А теперь мы как бы говорим, что мы пытаемся этого избежать, и мы пытаемся считать только для листов.
[01:59:03.340 --> 01:59:04.340]  Ну вот загадка.
[01:59:04.340 --> 01:59:05.340]  Попробуйте, как говорится, да.
[01:59:06.340 --> 01:59:08.340]  Попробуйте за 60 секунд догадаться, как вы выкручиваете.
[01:59:09.340 --> 01:59:14.340]  А, а, даже такое, чьи, да.
[01:59:15.340 --> 01:59:16.340]  Да, действительно, да.
[01:59:17.340 --> 01:59:18.340]  На самом деле, да, самый тупой вариант.
[01:59:19.340 --> 01:59:25.340]  Давайте запустим DFS, не знаю, что это, но неважно, храним в стеке все вершины, и после этого двоичные подъемы записываются честно, да.
[01:59:26.340 --> 01:59:30.340]  Тут уже даже не надо помнить, что на самом деле каждый следующий подъем выкручивается.
[01:59:31.340 --> 01:59:37.340]  Тут уже даже не надо помнить, что на самом деле каждый следующий двоичный подъем берется по предыдущему еще в том же ледер декомпозиционе, кстати.
[01:59:39.340 --> 01:59:42.340]  Да, у меня ответ изначально был такой, но ваш ответ проще, конечно, да.
[01:59:44.340 --> 01:59:45.340]  Ответ.
[01:59:46.340 --> 01:59:47.340]  Так что вот видите, как угодно.
[01:59:48.340 --> 01:59:53.340]  То есть получается, что можно на самом деле двоичный подъем, то есть получается предподсчет, он теперь за N плюс количество листов.
[01:59:54.340 --> 01:59:55.340]  Для каждого листа храним.
[01:59:56.340 --> 01:59:59.340]  Ну, для каждого листа двоичный подъем мы честно храним, да.
