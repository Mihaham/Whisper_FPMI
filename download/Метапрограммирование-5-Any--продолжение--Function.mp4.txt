[00:00.000 --> 00:10.000]  Начнём мы со страшилки. Буквально за пару часов до семинара
[00:10.000 --> 00:17.000]  мне так не повезло, что я узнал о одной замечательной фиче, которая поддерживается в языке C++,
[00:17.000 --> 00:24.000]  которую я не могу с вами не поделиться. Давайте внимательно посмотрим на то, что здесь происходит.
[00:24.000 --> 00:31.000]  Я объявил смешную структурку vector, в которой есть sizeT plan.
[00:31.000 --> 00:39.000]  И вот такая странная штука. Это как бы массив неизвестного размера, что это вообще может значить?
[00:39.000 --> 00:49.000]  Почему это компилируется? Давайте выведем размер sizeT и размер вот этой структурки vector.
[00:49.000 --> 00:57.000]  И то, и другое 8. То есть вот эта штука никаких данных, структурку не добавила.
[00:57.000 --> 01:07.000]  Теперь посмотрим на смешную функцию makeVector. Она берет, молочит размер vector plus size
[01:07.000 --> 01:17.000]  Ну и кастит к вектору. Такой сишный код. А дальше мы берем, делаем makeVector
[01:17.000 --> 01:25.000]  и в эту дату пишем keg. В конце конечно backslash 0 есть в строковых литералах.
[01:25.000 --> 01:33.000]  То есть выделили на 4 байтика больше, чем нужно было для вектора. 12 байтиков написали туда keg.
[01:33.000 --> 01:43.000]  И теперь через дату можем обратно его получить.
[01:43.000 --> 01:53.000]  Вас это не шокирует? Эта штука позволяет получить доступ к данным, лежащим за концом этой структурки.
[01:53.000 --> 02:07.000]  Абсолютно легально собрало 3 cdc++20. А под слангом такое есть?
[02:07.000 --> 02:13.000]  Под слангом должно тоже работать, потому что это часть стандарта c++. Да?
[02:13.000 --> 02:31.000]  Так, ну что? Компайлинг. Вы только посмотрите, работает.
[02:31.000 --> 02:39.000]  Я к такому жизни если честно не готов. Какая же это гадость.
[02:39.000 --> 02:45.000]  Да, после таких вещей обычно глаза хлоркой промывают.
[02:45.000 --> 02:55.000]  Ну закончим с этим. У нас там подошел дедлайн по первой домашке, поэтому предлагается ее посмотреть.
[02:55.000 --> 03:03.000]  Ну разобрать так сказать.
[03:03.000 --> 03:09.000]  Что от вас требовалось? Написать стрейнгу, которую можно в constexpr засовывать.
[03:09.000 --> 03:15.000]  Ну с этим я думаю все должны были справиться, потому что там никакой идеи нет.
[03:15.000 --> 03:23.000]  Просто пройти по ссылке и посмотреть, что можно. Можно оказывается массивы.
[03:23.000 --> 03:29.000]  То есть стдр или сишный массив фиксированной длины.
[03:29.000 --> 03:35.000]  И так как здесь у вас не требуется произвольного размера, все ограничивается 255.
[03:35.000 --> 03:41.000]  Ну как бы все нормально. То есть в типе самого стринга зашит размер,
[03:41.000 --> 03:47.000]  его используется чтобы создать стдр или пару размеров.
[03:47.000 --> 03:53.000]  Ну даже все равно пару размеров с ист и стдр или сишный массив.
[03:53.000 --> 03:57.000]  И туда записываете данные этой строки.
[03:57.000 --> 04:01.000]  А интересных здесь классматы.
[04:01.000 --> 04:11.000]  Там было очень много различных вариантов решений, и все они какие-то слишком умудренные.
[04:11.000 --> 04:17.000]  Как по мне самое правильное решение самое простое.
[04:17.000 --> 04:24.000]  Давайте сначала даже без требований на концепты и констрейнты просто реализуем маппинг.
[04:24.000 --> 04:28.000]  Как это будет выглядеть?
[04:28.000 --> 04:34.000]  Вот эту штуку скопируем.
[04:34.000 --> 04:38.000]  Основной класс я предлагаю сделать просто пустым.
[04:38.000 --> 04:45.000]  То есть ничего общего в нем не реализовывать, потом мы сюда навесим констрейнты и все.
[04:45.000 --> 04:49.000]  А дальше все кейсы разбирать специализациями.
[04:49.000 --> 04:54.000]  Ну первая специализация самая очевидная, это если у нас маппингов нет.
[04:54.000 --> 05:01.000]  В таком случае у нас выбрато и нет, кроме как вернуть no load.
[05:01.000 --> 05:09.000]  Ну и конечно же второй кейс это если хоть что-то есть.
[05:18.000 --> 05:24.000]  А если хоть что-то есть, маппинг sub.
[05:24.000 --> 05:28.000]  Ну весьма закономерно, что оно опять все рекурсивно будет действовать.
[05:28.000 --> 05:33.000]  Попробуют с первым маппингом, если получилось окей.
[05:33.000 --> 05:38.000]  Если нет, то отправляем дальше.
[05:38.000 --> 05:43.000]  Ну так вот, попробуем с первым маппингом.
[05:43.000 --> 05:53.000]  Для удобства давайте этого маппинга заведем, как бы их назвать, чтобы не было коллизий.
[05:58.000 --> 06:07.000]  А почему нельзя сделать в специализации не маппинг, а маппинг и сразу шаблонные параметры?
[06:07.000 --> 06:12.000]  Да, ты прав. Эти два варианта мне кажется эквивалентны.
[06:12.000 --> 06:16.000]  Давайте сделаем так.
[06:16.000 --> 06:26.000]  Тогда нам уже здесь нужно указывать не маппинг, а содержимый его.
[06:26.000 --> 06:30.000]  И засовывать вот сюда.
[06:30.000 --> 06:34.000]  Так, так.
[06:34.000 --> 06:41.000]  Соответственно здесь мы можем сразу попробовать сделать динамик каст.
[06:41.000 --> 06:46.000]  К рома звездочка объекта.
[06:46.000 --> 06:54.000]  Кто знает почему я делаю именно вот так, а не вот так?
[06:54.000 --> 06:56.000]  Я застучил.
[06:56.000 --> 07:03.000]  В таком случае динамик каст чем отличен всего остального?
[07:03.000 --> 07:09.000]  Он как бы безопасный. Он умеет понимать, когда каст невозможен.
[07:09.000 --> 07:12.000]  И в этом случае выдавать ошибку.
[07:12.000 --> 07:17.000]  В случае указателей ошибкой считается nullptr.
[07:17.000 --> 07:23.000]  А если мы используем ссылки, то null ссылки не бывает.
[07:23.000 --> 07:27.000]  Единственное, что нам остается, это кинуть исключения.
[07:27.000 --> 07:32.000]  Но мы же здесь знаем, что мы хотим делать в случае, если у нас ошибка.
[07:32.000 --> 07:38.000]  Исключения стоит использовать только, когда непонятно, что делать, если произошла ошибка.
[07:38.000 --> 07:43.000]  Исключительная ситуация, которую мы в текущем коде не знаем, как обработать.
[07:43.000 --> 07:49.000]  В этом коде мы знаем, как ошибку обработать, поэтому давайте не использовать исключения.
[07:49.000 --> 08:00.000]  А также чисто мое импо, что хорошим стилем является не просто их динамик каст, а явно сравнивает с nullptr.
[08:03.000 --> 08:06.000]  Ну тут по-разному можно писать, конечно.
[08:06.000 --> 08:12.000]  Так вот, если каст нам удался, то мы просто возвращаем таргет.
[08:12.000 --> 08:18.000]  Иначе нам нужно пойти рекурсивно.
[08:18.000 --> 08:27.000]  Для этого мы возьмем classMapper от того же base и таргета, но от макингсов, от которых мы откусили первый кусочек.
[08:27.000 --> 08:31.000]  И у него запустим рекурсивно.
[08:31.000 --> 08:35.000]  Собственно все. Вот и все решения задачи.
[08:35.000 --> 08:42.000]  За исключением маленьких деталей, как обычно с маленькими деталями, тут самое более.
[08:42.000 --> 08:44.000]  В чем заключаются детали?
[08:44.000 --> 08:55.000]  Первое, нам нужно законстраинтить более-менее адекватно вот это вот дело, чтобы мы могли выдавать читабельные ошибки.
[08:55.000 --> 08:59.000]  Пользователю, который случайно в маппинге что-то не то написал.
[08:59.000 --> 09:02.000]  Ну, что нужно констраинтить?
[09:02.000 --> 09:06.000]  Во-первых, то, что все классы внутри маппингсов – это маппинги.
[09:06.000 --> 09:10.000]  То есть инстанциации маппинга. Это первое.
[09:10.000 --> 09:16.000]  Второе, Chrome должен наследовать base. Публично.
[09:16.000 --> 09:20.000]  Иначе никакого динамиккаста у нас не выйдет и будет что-то странное.
[09:20.000 --> 09:28.000]  И последнее предположение, что мы делаем, это то, что вот здесь вот этот таргет, да, у него же тип авто, непонятно какой.
[09:28.000 --> 09:35.000]  Предположение в том, что вот этот таргет нам удастся скастить к вот этому таргету.
[09:35.000 --> 09:39.000]  Ну, давайте попробуем это сразу написать.
[09:39.000 --> 09:45.000]  Первое, что... ну да, concept, value и mapping.
[09:45.000 --> 09:47.000]  Так его назовем.
[09:47.000 --> 09:51.000]  И это будет относиться к...
[09:51.000 --> 09:58.000]  Так, ну также нам здесь придется указать дополнительные параметры для концепта.
[09:58.000 --> 10:02.000]  Мы должны знать, какой base и какой таргет ажитарный.
[10:02.000 --> 10:04.000]  Соответственно их и напишем.
[10:06.000 --> 10:09.000]  Ну и...
[10:12.000 --> 10:16.000]  Какой у меня сейчас компилятор стоит интересный? Вроде бы GCC.
[10:16.000 --> 10:26.000]  Тут можно специализировать не эту боупеременную на правильный маппинг, а сюда просто значение этой constexpr боупеременной вставить.
[10:26.000 --> 10:32.000]  Да, можно так, если у нас нету constexpr лямб.
[10:32.000 --> 10:35.000]  А если есть constexpr лямб, то мы можем их заобьютить.
[10:35.000 --> 10:40.000]  Я очень люблю этот трюк, и так как у меня сейчас GCC, я могу его заиспользовать.
[10:40.000 --> 10:44.000]  Ну ладно, нет, давайте считать, что мы согласны условиям полностью действиям.
[10:44.000 --> 10:51.000]  Поэтому действительно будем использовать constexpr bool.
[10:51.000 --> 10:55.000]  Темплей у нас будет точно такой же.
[11:02.000 --> 11:06.000]  Тут false, а потом специализация false.
[11:18.000 --> 11:22.000]  Вот тут немножко нетривиально написать специализацию.
[11:22.000 --> 11:30.000]  Здесь будет у нас какой-то произвольный класс f и какое-то произвольное значение t.
[11:30.000 --> 11:34.000]  Но какой тип этого значения?
[11:34.000 --> 11:43.000]  Мы здесь auto t используем, а здесь class f.
[11:43.000 --> 11:49.000]  Можно не auto t, а isConvertibleToTarget.
[11:49.000 --> 11:55.000]  Да, можно сразу так, а можно это вот здесь написать.
[12:00.000 --> 12:08.000]  Да, вот здесь мы сразу можем написать the right from base.
[12:08.000 --> 12:10.000]  Это будет работать.
[12:10.000 --> 12:15.000]  А здесь мы действительно тоже можем написать...
[12:15.000 --> 12:19.000]  Я забыл кое-что.
[12:19.000 --> 12:24.000]  Здесь мы вновь можем написать...
[12:24.000 --> 12:28.000]  Хотя это вроде не работает, у меня не работало.
[12:28.000 --> 12:33.000]  Ну, короче, это не работает, да.
[12:33.000 --> 12:39.000]  Можешь попробовать написать это и потом auto.
[12:39.000 --> 12:43.000]  Вот так нельзя, к сожалению, писать в текущем стандарте.
[12:43.000 --> 12:48.000]  Да, я не то использовал.
[12:52.000 --> 12:55.000]  У тебя неправильно специализация написана.
[12:55.000 --> 12:58.000]  Мы специализировали, да.
[12:58.000 --> 13:03.000]  Это базы и таргеты, а вот эта штука останется...
[13:03.000 --> 13:06.000]  Да, я не знаю, что...
[13:06.000 --> 13:10.000]  Какой-то кринч произошел, если честно.
[13:10.000 --> 13:13.000]  Вот.
[13:20.000 --> 13:23.000]  Там надо target type, наверное, сделать.
[13:23.000 --> 13:27.000]  Вот, короче, так хитро у нас не выйдет, нам придется вот так делать.
[13:27.000 --> 13:29.000]  Это будет...
[13:34.000 --> 13:40.000]  Нет, это хотели добавить в 20 стандарт.
[13:40.000 --> 13:42.000]  Ну, давай попробуем.
[13:42.000 --> 13:47.000]  Возможно, это сработает, но у меня память говорит, что...
[13:47.000 --> 13:51.000]  О, да, забавно.
[13:51.000 --> 13:57.000]  Вот тут очень много дискуссий было с тем, для чего можно такой краткий синтаксис использовать.
[13:57.000 --> 14:01.000]  Там, например, если у вас template-template параметры,
[14:01.000 --> 14:05.000]  пока что нельзя использовать вот такой краткий синтаксис constraints.
[14:05.000 --> 14:06.000]  К сожалению.
[14:06.000 --> 14:10.000]  А вот здесь можно, наверное, потому что и в функциях можно.
[14:10.000 --> 14:11.000]  Закономер.
[14:11.000 --> 14:17.000]  Вот, собственно, мы и сделали, и надо только концепт обернуть.
[14:17.000 --> 14:21.000]  Ну, наверное, можно даже этого и не делать.
[14:21.000 --> 14:22.000]  Хотя тогда...
[14:22.000 --> 14:26.000]  Ну, да, лучше сделать все-таки, чтобы мы вот здесь могли...
[14:29.000 --> 14:31.000]  Не здесь.
[14:31.000 --> 14:33.000]  Чтобы мы вот здесь могли классно написать.
[14:33.000 --> 14:39.000]  Valid mapping от base target.
[14:39.000 --> 14:41.000]  Вот.
[14:41.000 --> 14:43.000]  Кажется, все.
[14:43.000 --> 14:49.000]  Конечно, покрыть тестами, насколько корректно работают концепты в случае ошибок,
[14:49.000 --> 14:53.000]  ну, невозможно, мягко говоря.
[14:53.000 --> 14:57.000]  Остается только попытаться поломать, поиспользовать на практике
[14:57.000 --> 15:01.000]  и посмотреть, насколько приемлемо ошибки выдает компилятор,
[15:01.000 --> 15:07.000]  и со временем понять, что, ну, да, ок, оно удовлетворительно.
[15:07.000 --> 15:12.000]  Давайте подумаем, не забыли ли мы ничего. Вроде не забыли.
[15:12.000 --> 15:14.000]  О специализациях.
[15:14.000 --> 15:19.000]  В специализациях не надо вместо класс mapping сделать там концепт ..mapping.
[15:19.000 --> 15:25.000]  Он не будет писать, что специализация менее специализирована, чем base.
[15:25.000 --> 15:28.000]  Да, тут ты прав.
[15:31.000 --> 15:35.000]  Наверное, стоит. Наверное, стоит это сделать.
[15:35.000 --> 15:40.000]  Опять же, правила достаточно тонкие, и чем вспоминать их проще.
[15:40.000 --> 15:44.000]  Попробовать build this? Ну, давай попробуем, кстати.
[15:44.000 --> 15:48.000]  Надо как-то инстанцировать в этот раз, да.
[15:48.000 --> 15:53.000]  Например, мы украдем, конечно же, отсюда.
[15:57.000 --> 16:00.000]  И вне, чтобы не париться.
[16:07.000 --> 16:09.000]  Вот так вот.
[16:10.000 --> 16:12.000]  Что?
[16:12.000 --> 16:18.000]  Ну, видимо, это из авта. Попробуй. Возможно, это из авта.
[16:18.000 --> 16:26.000]  Он говорит, что предикат из convertible-v невозможно использовать в constexpr-контексте.
[16:26.000 --> 16:28.000]  Ну, видимо, это из авта.
[16:28.000 --> 16:35.000]  Мне кажется, что в конвертибл-в можно использовать constexpr-контексте.
[16:35.000 --> 16:36.000]  Но, видимо, это из авта.
[16:36.000 --> 16:39.000]  Мне кажется, это дефект гцс.
[16:39.000 --> 16:43.000]  Попробуй брать after, concept after.
[16:47.000 --> 16:52.000]  Не, да, если мы берем after, это будет работать не так, как мы ожидаем.
[16:52.000 --> 16:55.000]  Ноль, переключились на clan.
[16:55.000 --> 16:59.000]  Let's make project.
[16:59.000 --> 17:01.000]  Let's make project.
[17:04.000 --> 17:07.000]  Кажется, он так быстро справился.
[17:07.000 --> 17:09.000]  Нет.
[17:09.000 --> 17:11.000]  Вот это да.
[17:18.000 --> 17:25.000]  А, это дефект либо stdc++, да?
[17:29.000 --> 17:31.000]  Почему десятая?
[17:36.000 --> 17:40.000]  Действительно, непонятно, почему десятая.
[17:51.000 --> 17:55.000]  Хороший вопрос. Кто помнит, как std...
[17:55.000 --> 17:57.000]  Сейчас.
[17:59.000 --> 18:07.000]  Как аргументы в CMake?
[18:09.000 --> 18:12.000]  Compiled option.
[18:20.000 --> 18:23.000]  CMake 6.x.flux, да?
[18:23.000 --> 18:28.000]  std lib равно lib c++.
[18:29.000 --> 18:31.000]  А.
[18:38.000 --> 18:40.000]  Ага.
[18:42.000 --> 18:44.000]  Понял, понял.
[18:45.000 --> 18:47.000]  А, все, я решил, что я буду...
[18:47.000 --> 18:49.000]  Да.
[18:49.000 --> 18:51.000]  Все, вернись обратно.
[18:51.000 --> 18:53.000]  Да.
[18:53.000 --> 18:56.000]  Просто вот так сделали, все должно заработать.
[18:56.000 --> 18:58.000]  Clan 12.
[19:00.000 --> 19:02.000]  Ура.
[19:02.000 --> 19:04.000]  Вернемся сюда.
[19:04.000 --> 19:05.000]  Соберем.
[19:05.000 --> 19:06.000]  Все заработает.
[19:06.000 --> 19:08.000]  Ну да, короче, это дефект гцц.
[19:08.000 --> 19:12.000]  Все-таки не зря задание, единственное, использовать кланка.
[19:20.000 --> 19:23.000]  Да, используйте то, на чем будет работать.
[19:24.000 --> 19:28.000]  Там Microsoft, Visual Studio, лучше, как понятно, все работает.
[19:28.000 --> 19:30.000]  Ну вот.
[19:30.000 --> 19:32.000]  Кажется, у нас действительно все работает.
[19:32.000 --> 19:37.000]  И даже вот та деталь, про которую упоминалась Николай вроде, да, упоминал,
[19:37.000 --> 19:43.000]  что вот здесь меньше констрейнтов, чем вот здесь.
[19:43.000 --> 19:46.000]  Этот даже его не волнует.
[19:46.000 --> 19:48.000]  Внезапно.
[19:48.000 --> 19:53.000]  Вот здесь, где мы специализируем, здесь констрейнтов меньше.
[19:53.000 --> 19:59.000]  Я так понимаю, констрейнты из основного класса автоматом наследуются на специализацию.
[19:59.000 --> 20:01.000]  Да.
[20:01.000 --> 20:07.000]  А может это с вариадиками связано?
[20:07.000 --> 20:11.000]  Да, мне тоже кажется, что это так работает, но я уже успел забыть.
[20:11.000 --> 20:15.000]  Кажется, на первой лекции я это помнил еще.
[20:15.000 --> 20:17.000]  Ну давайте проверим просто для веселья.
[20:17.000 --> 20:25.000]  Например, сюда напишем, что у нас не конвертируется, но точно по-нормальному констэкспрессе.
[20:25.000 --> 20:30.000]  Что у нас не конвертируется, но точно по-нормальному констэкспрессе.
[20:30.000 --> 20:33.000]  Стодер рей от inds.
[20:33.000 --> 20:36.000]  Здесь, например, да.
[20:43.000 --> 20:45.000]  Чем у нас визуал?
[20:45.000 --> 20:49.000]  Угу, constraints not satisfied.
[20:49.000 --> 20:52.000]  Угу, constraints not satisfied.
[20:52.000 --> 20:55.000]  Valid mapping evaluate to false.
[20:55.000 --> 21:00.000]  Ну вот тут начинаются маленькие детальки, что у нас просто valid mapping evaluate to false.
[21:00.000 --> 21:04.000]  А хотелось бы, чтобы нам более конкретно говорили.
[21:04.000 --> 21:06.000]  Почему?
[21:06.000 --> 21:13.000]  Потому что нам не подходит target у этого матнида.
[21:13.000 --> 21:19.000]  Вот, соответственно, этот концепт еще можно докручивать и довинчивать.
[21:24.000 --> 21:30.000]  Не уверен, какой самый эффективный способ это сделать.
[21:32.000 --> 21:37.000]  Но кажется, что самое лучшее это будет проверить первое.
[21:37.000 --> 21:42.000]  М. Какая-то инстанциация маппинга.
[21:42.000 --> 21:48.000]  Второе. Сделать здесь возможность получить from.
[21:54.000 --> 21:58.000]  Вот так. Получить target и from.
[21:58.000 --> 22:02.000]  А дальше проверять просто для этих штук constraints.
[22:02.000 --> 22:07.000]  Ну, проверку на то, что инстанциация мы уже с вами писали.
[22:07.000 --> 22:14.000]  А мы даже можем это сейчас подкастрелять.
[22:14.000 --> 22:18.000]  И отсюда вот это выпилить.
[22:18.000 --> 22:21.000]  Вот это все выпилить.
[22:21.000 --> 22:31.000]  И просто сказать, что должен быть маппинга в те.
[22:31.000 --> 22:41.000]  А здесь мы сделаем compound, который будет requires.
[22:41.000 --> 22:45.000]  Ну, если более общий писать, то вот так.
[22:52.000 --> 22:56.000]  Нет, так плохо. Не очень вообще получается.
[22:56.000 --> 23:02.000]  Потому что вот это вот авто, оно очень конкретно.
[23:02.000 --> 23:04.000]  Необобщенный код.
[23:04.000 --> 23:07.000]  Поэтому мы просто сделаем вот так.
[23:07.000 --> 23:09.000]  Сделаем вот так.
[23:09.000 --> 23:24.000]  Убираю, что у нас будет m, f, base.
[23:24.000 --> 23:26.000]  Это base.
[23:26.000 --> 23:32.000]  И, наконец, convertible to.
[23:32.000 --> 23:40.000]  А вот тут можно связать вот этот замечательный синтаксист.
[23:40.000 --> 23:48.000]  m22.t convertible to target.
[23:52.000 --> 23:56.000]  Да, type name, конечно же, здесь нужно.
[23:56.000 --> 24:00.000]  Вот, получили немножко альтернативнее.
[24:01.000 --> 24:06.000]  И теперь нам пишут constraint not satisfied,
[24:06.000 --> 24:11.000]  because valid mapping evaluated to false,
[24:11.000 --> 24:15.000]  because convertible to was not satisfied.
[24:15.000 --> 24:18.000]  Мне кажется, это более хорошее решение.
[24:18.000 --> 24:20.000]  Нам сразу пишут, где проблема.
[24:20.000 --> 24:23.000]  В левом аргументе или вправо.
[24:23.000 --> 24:26.000]  Вот, соответственно, если мы вернем так, чтобы все работало,
[24:26.000 --> 24:32.000]  и сюда двоечку запихнем, а вот сюда string,
[24:38.000 --> 24:42.000]  то ошибка будет соответствующей.
[24:42.000 --> 24:46.000]  Нам скажут, что derived from провалился.
[24:46.000 --> 24:52.000]  Для чего basic string char
[24:52.000 --> 24:56.000]  и animal.
[24:56.000 --> 25:03.000]  Единственная проблема, что вот эту штуку не смогло раскрыть сразу.
[25:03.000 --> 25:05.000]  Ниже раскрыла, да?
[25:05.000 --> 25:11.000]  А, вот, animal base of basic string не вернул.
[25:11.000 --> 25:15.000]  И мне кажется, что это идеальное решение,
[25:15.000 --> 25:18.000]  за исключением маленького гадского теста,
[25:18.000 --> 25:22.000]  который требуется, чтобы...
[25:22.000 --> 25:30.000]  Там требуется, чтобы неявная конвертация не работала для этих таргетов.
[25:30.000 --> 25:34.000]  Ну, тесты я с прошлого года, разумеется, не трогал,
[25:34.000 --> 25:37.000]  и в прошлом году предполагалось, что здесь будет sameS.
[25:37.000 --> 25:41.000]  Мне теперь начало казаться, что лучше convertible to,
[25:41.000 --> 25:45.000]  но, в общем, решение, которое проходят тесты,
[25:45.000 --> 25:49.000]  но чуть менее элегантное, как по мне, — это sameS требовать.
[25:52.000 --> 25:54.000]  Там начинается что-то сложное.
[25:54.000 --> 25:57.000]  Я же в чатике пытался сказать, как это сделать,
[25:57.000 --> 25:59.000]  но у меня тогда ничего не получилось.
[26:04.000 --> 26:07.000]  Там что-то страшное...
[26:07.000 --> 26:09.000]  Я не разобрался, честно.
[26:15.000 --> 26:19.000]  Ну, вот если кто-то хочет пересерчить...
[26:19.000 --> 26:23.000]  Ну, нет, нам наоборот нужно, да?
[26:23.000 --> 26:26.000]  Нам нужно, чтобы тип T был...
[26:26.000 --> 26:28.000]  А, нет.
[26:28.000 --> 26:30.000]  А, да.
[26:30.000 --> 26:32.000]  Хорошо.
[26:32.000 --> 26:34.000]  Ну, вот.
[26:34.000 --> 26:36.000]  Ну, вот.
[26:36.000 --> 26:38.000]  Ну, вот.
[26:38.000 --> 26:40.000]  Ну, вот.
[26:40.000 --> 26:42.000]  Ну, вот.
[26:42.000 --> 26:44.000]  А, да.
[26:44.000 --> 26:46.000]  Хорошо.
[26:46.000 --> 26:49.000]  Да, нам нужно, чтобы target был,
[26:49.000 --> 26:52.000]  constructable from...
[26:56.000 --> 26:59.000]  Да, это тогда опять вот такая штука.
[27:01.000 --> 27:03.000]  Вот.
[27:12.000 --> 27:14.000]  Вот так что.
[27:14.000 --> 27:16.000]  В порядке, верно?
[27:16.000 --> 27:18.000]  Да.
[27:20.000 --> 27:22.000]  Вот, возможно, это тоже пройдут тесты.
[27:22.000 --> 27:24.000]  Я этого не гарантирую.
[27:24.000 --> 27:27.000]  Там может произойти что-то странное.
[27:27.000 --> 27:29.000]  А, потому что...
[27:31.000 --> 27:33.000]  Ну, а мы точно...
[27:33.000 --> 27:35.000]  Оператор...
[27:35.000 --> 27:37.000]  Оператор кассы.
[27:37.000 --> 27:39.000]  Да.
[27:39.000 --> 27:41.000]  Оператор кассы.
[27:41.000 --> 27:43.000]  Слати, explicit.
[27:43.000 --> 27:45.000]  Такую вещь.
[27:45.000 --> 27:47.000]  Считается.
[27:49.000 --> 27:51.000]  Ну, вот остается только надеяться.
[27:51.000 --> 27:53.000]  Но.
[27:53.000 --> 27:55.000]  Все в trucе.
[27:55.000 --> 27:57.000]  Ну, вот.
[27:57.000 --> 27:59.000]  Смотри, собственно, что происходит, да?
[27:59.000 --> 28:01.000]  Да.
[28:01.000 --> 28:03.000]  Да.
[28:03.000 --> 28:05.000]  Ошибка, почему?
[28:05.000 --> 28:07.000]  2, convertible to int.
[28:07.000 --> 28:20.400]  двойка convertible to int, да, то есть как бы convertible to он охватывает constructible from, если
[28:20.400 --> 28:28.600]  constructible from верно, если мы вот так напишем, то у нас никогда этот концепт, ну вот проблема
[28:28.600 --> 28:34.560]  собственно, все запор это, вот поэтому идеальное решение, которое еще и проходят тесты, это мне
[28:34.560 --> 29:00.080]  кажется вот так, ну невелика жалость, что-что, вот поэтому мне кажется, что convertible to лучше,
[29:00.080 --> 29:14.840]  это именно на тестах, да, проблема была или, то есть как ты делал и как у тебя ломалась смс,
[29:14.840 --> 29:33.240]  а вот, да, да, потому что двойка это, стоп, это типа деколтай под нее, но это же левой лифт,
[29:33.240 --> 30:00.640]  ну да, как бы, нет, вот он, помните, мы когда концепты стандартной библиотеки разбирали, нашли там
[30:00.640 --> 30:22.800]  common reference width, вот, вот кажется его здесь надо союзить, да, ну вот возможно так, да, то есть
[30:22.800 --> 30:30.440]  потребует что-то как бы почти одинаковые классы, но common reference width с собой тоже тащит немного
[30:30.440 --> 30:40.400]  там гадости всякой, да, он там с наследованием умеет работать и вот такие вещи, ну мне кажется не сказать,
[30:40.400 --> 30:49.280]  какой решение, самое лучшее без какой-то практики и отстреливание колен в продакшене, вот, в общем
[30:49.280 --> 30:58.440]  у нас с первой задачей на этом все, я думаю, этот код я никуда не выкладываю, я просто стираю, да,
[30:58.440 --> 31:03.160]  если вы хотите его скопипастить и сдать задачу, то еще не сдал, а вроде уже почти все сдали,
[31:03.160 --> 31:11.720]  или вообще все, вот, надо смотреть записи, или вы сейчас... переходим к второму заданию, по нему
[31:11.720 --> 31:18.840]  я тоже хочу немножко комментов кинуть, потому что оказалось, что я немножко недостаточно толстый
[31:18.840 --> 31:29.840]  я бы намекал на одну классную штуку, давайте вот эти вещи скопируем и попытаемся реализовать drop
[31:29.840 --> 31:40.920]  вот в его момент катарсис должен происходить, если он не произошел, то что-то не то, так, drop
[31:49.840 --> 31:51.840]  а, возможно
[31:57.840 --> 31:59.840]  zip вроде красиво выглядит
[32:12.840 --> 32:15.840]  ну вот, да, тут есть два пути изображать
[32:18.840 --> 32:27.840]  короче, в общем, навесили requires, короче, навесили requires, вот, но при этом компилятор такой
[32:27.840 --> 32:32.840]  короче, это не может спеша вайс, это не может как-то стрелять
[32:42.840 --> 32:47.840]  ну хотя бы из них, один из них empty это сложно подтвердить, да?
[32:47.840 --> 32:49.840]  не сложно
[32:54.840 --> 32:57.840]  да, но компилятора ты это не докажешь
[32:57.840 --> 33:00.840]  ну там, что один из них empty, оно делается
[33:03.840 --> 33:14.840]  там один из них empty, оно просто делается, там через трюк, что можно сделать там один тип empty, а потом раскрыть через там or or и 3.
[33:15.840 --> 33:20.840]  да, но компилятор не смог доказать, что это более специализированная вещь
[33:20.840 --> 33:40.840]  ну, короче, да, сначала я, короче, сделал просто барзу без констрейнков, и оно заработало, но оно работало не совсем хорошо, короче, пришлось вот type list, заменить на type sequence и еще
[33:40.840 --> 33:46.840]  а так, короче, я свободно перечитал несколько раз, но я так и не понял, в каком месте это не мог констрейнуть
[33:46.840 --> 33:49.840]  возможно, это баг компилятора
[33:49.840 --> 33:53.840]  возможно, но я не представляю, что это мог констрейнуть
[33:53.840 --> 33:55.840]  ну, да, но
[33:56.840 --> 33:59.840]  так, мы забыли про стрелку по преследованию
[33:59.840 --> 34:10.840]  а, ну, кстати, да, но я делал по-другому, я детексил, что хотя бы один из них пустой, да, что все не пустые
[34:10.840 --> 34:18.840]  ну, вы поэкспериментировали, да, да, и так оно работает отлично, и без костылей, даже не нужно вот этот вот фолды использовать, да
[34:18.840 --> 34:22.840]  можно прямо там, где кластер иточен, написать этот
[34:22.840 --> 34:25.840]  но это все ладно, это такие уже
[34:30.840 --> 34:35.840]  там не проверяется, нет, там же есть проверка, что зип конечного с бесконечным нормально работает
[34:38.840 --> 34:41.840]  а, зип произвольного количества
[34:41.840 --> 34:44.840]  но тесты слабые пока
[34:48.840 --> 35:05.840]  ну, вот, утверждается, что есть очень простое, очень красивое решение зипа, которое с конечными тоже работает
[35:05.840 --> 35:10.840]  если там теста не хватает, то давайте его добавим, да, потому что
[35:10.840 --> 35:14.840]  ну ладно, после гедлайма уже добавим
[35:14.840 --> 35:21.840]  да, так вот, как мы будем делать дроп?
[35:21.840 --> 35:28.840]  ну, не специализация, а это основная штука
[35:28.840 --> 35:32.840]  ну, какую специализацию, так, внимание
[35:32.840 --> 35:35.840]  какую специализацию легко сделать, да?
[35:35.840 --> 35:42.840]  как обычно, мы такие, ну, если дропнуть нужно ничего, то понятно, что это будет, да
[35:45.840 --> 35:50.840]  ноль, тель, ура, ура, все круто
[35:50.840 --> 35:53.840]  и, а что тут пишем?
[35:59.840 --> 36:02.840]  как это сделать вообще, как мы
[36:07.840 --> 36:10.840]  вот, и вот это первый классный хак
[36:10.840 --> 36:12.840]  можно сделать все так
[36:14.840 --> 36:16.840]  обычно
[36:16.840 --> 36:19.840]  нет, оно работает всегда
[36:19.840 --> 36:24.840]  так, давайте сначала для тех, кто потерял ход мысли
[36:24.840 --> 36:29.840]  обычно мы вот так пишем, да, эти всякие операции над тейп-листами
[36:29.840 --> 36:32.840]  сюда что-то вписываем, и сюда что-то вписываем
[36:32.840 --> 36:38.840]  но тут как бы, ну, разве что вот так можно написать, да?
[36:39.840 --> 36:41.840]  ну, да
[36:44.840 --> 36:47.840]  но если тейль пустой
[36:47.840 --> 36:50.840]  ну, еще один костыль придется сделать, да?
[36:50.840 --> 36:52.840]  нелеганно
[36:52.840 --> 36:54.840]  можно сделать вот так
[36:54.840 --> 36:58.840]  и вы автоматом, если у тейля есть head и tail
[36:58.840 --> 37:01.840]  подтащите их вот в этот скоб, да?
[37:01.840 --> 37:04.840]  юзинги из родителей перетаскиваются наследником
[37:04.840 --> 37:07.840]  а если тейль это нил
[37:07.840 --> 37:10.840]  то он удовлетворяет концепту empty-лист
[37:10.840 --> 37:13.840]  потому что дирайв с ром
[37:13.840 --> 37:18.840]  вот здесь нужно было словить катарсис, почему оно вот именно так написано
[37:18.840 --> 37:20.840]  а не просто мило до пустой список
[37:20.840 --> 37:26.840]  и там почти в каждой функции можно это свойство наследования красиво заобьюзить
[37:26.840 --> 37:28.840]  и получить конфетку
[37:28.840 --> 37:31.840]  давайте допишем
[37:31.840 --> 37:33.840]  чем мы не разобрали?
[37:33.840 --> 37:35.840]  ну, общий случай, да?
[37:35.840 --> 37:37.840]  общий случай мы, наверное, сверху даже
[37:38.840 --> 37:43.840]  здесь n
[37:43.840 --> 37:46.840]  это не ноль
[37:46.840 --> 37:49.840]  что мы будем делать?
[37:49.840 --> 37:52.840]  да, просто вот так
[37:52.840 --> 37:55.840]  но нам нужно отпустить от тейль кусочек
[37:55.840 --> 37:59.840]  а, да, мы не можем этого сделать, тейль может быть пустым
[37:59.840 --> 38:02.840]  поэтому нам во всяком случае нужно специализироваться, да?
[38:02.840 --> 38:07.840]  а специализируемся мы с помощью type-sequencer
[38:10.840 --> 38:12.840]  n-тейль
[38:12.840 --> 38:15.840]  и это ровный есть, не пустой список, да?
[38:15.840 --> 38:18.840]  у него гарантированно есть head и tail
[38:18.840 --> 38:21.840]  и что тогда нужно сделать, да?
[38:21.840 --> 38:26.840]  делегировать определение, что будет head, а что будет tail
[38:26.840 --> 38:29.840]  drop с меньшим n
[38:30.840 --> 38:33.840]  можно от наследоваться от него
[38:33.840 --> 38:37.840]  да, вот, вы начинаете мысль с правильным стороном
[38:39.840 --> 38:42.840]  а что?
[38:42.840 --> 38:44.840]  а что плохого?
[38:44.840 --> 38:48.840]  да, хочется опять начать эти using head равно ля-ля-ля
[38:48.840 --> 38:50.840]  нет, вот
[38:50.840 --> 38:55.840]  после такого мы уже знаем, что мы просто пишем вот так, и оно работает
[38:56.840 --> 39:03.840]  и, собственно, все остальное в этом задании предполагалось в таком стиле писать
[39:08.840 --> 39:11.840]  ты уже по-другому написал, да?
[39:12.840 --> 39:18.840]  можно еще раз, получается, наследование делает за нас всю эту работу с using head, да?
[39:18.840 --> 39:20.840]  да, да, да
[39:20.840 --> 39:30.840]  то есть автоматически вот эти вот using head или tail, которые, мы говорим, должны быть внутри списков, подтягиваются из наследников
[39:32.840 --> 39:35.840]  то есть здесь мы просто говорим
[39:35.840 --> 39:39.840]  ну вот на это наследование можно смотреть, как на празу мы являемся
[39:39.840 --> 39:48.840]  список, в котором drop-нули n элементов из непустого списка tail, является списком
[39:50.840 --> 39:54.840]  где drop-нули n-1 элемент из его хвоста
[39:56.840 --> 40:06.840]  если же мы дошли до нуля, то это как бы есть сам этот список
[40:07.840 --> 40:10.840]  да, остался один, конечно же, случай, если
[40:10.840 --> 40:26.840]  если список пустой, а n еще не кончилось, такое мы тоже хотим поддерживать и не какие-то ошибки выдавать
[40:29.840 --> 40:32.840]  ну в таком случае мы просто наследуем дел
[40:33.840 --> 40:37.840]  вот так тут куда-то не решен
[40:37.840 --> 40:40.840]  могут быть проблемы, как раз саппорядочено они в специализации
[40:40.840 --> 40:43.840]  но самая неприятная вещь в написании, как раз, это специализация
[40:43.840 --> 40:48.840]  подобрать специализацию так, чтобы нормально в порядке быть в этот случай
[40:48.840 --> 40:52.840]  а если у нас ноль и empty, то что должно произойти? Тоже nil, да?
[40:52.840 --> 40:56.840]  наследник у nil, а это что у наследника?
[40:56.840 --> 40:57.840]  да
[40:57.840 --> 41:03.840]  давайте, так сделаем
[41:03.840 --> 41:07.840]  и все, да? То есть покрыли все кейсы
[41:07.840 --> 41:12.840]  всего две специализации, по-моему это очень хорошо
[41:12.840 --> 41:19.840]  если дошли до нуля и что-то еще осталось, то это то, что осталось
[41:19.840 --> 41:25.840]  если еще не ноль, то тропы m1 идем дальше
[41:25.840 --> 41:28.840]  в всех иных случаях nil
[41:28.840 --> 41:35.840]  то есть это буквально объявление функций на функциональном языке
[41:35.840 --> 41:38.840]  это двуточек, а равность почти работает
[41:38.840 --> 41:45.840]  да, очень смешно получается, как мне кажется
[41:45.840 --> 41:53.840]  не знаю, насколько это стоит с продакшн тащить, но потренировать, работать со специализацией на констрейнтами и прочим
[41:53.840 --> 41:56.840]  надеюсь, полезно
[41:56.840 --> 42:02.840]  вот, если кто-то еще не брался за второе задание, еще не написал все с этим
[42:02.840 --> 42:07.840]  то стоит браться, и вот в таком стиле у вас достаточно быстро, мне кажется, пойдет дело
[42:07.840 --> 42:22.840]  да, там group by это как раз ultimate challenge в этом задании
[42:22.840 --> 42:33.840]  да, там есть разные обходные хаки, которые я тоже буду принимать, потому что это непростая штука
[42:33.840 --> 42:37.840]  то есть group by любыми хаками только сделайте
[42:37.840 --> 42:41.840]  да и в принципе все задание
[42:41.840 --> 42:46.840]  но все это можно сделать достаточно красиво и лаконично
[42:46.840 --> 42:49.840]  и было бы здорово, если бы так сделали
[42:49.840 --> 42:55.840]  давайте возвращаться к нашим парам, к TypeRage'у
[42:55.840 --> 42:59.840]  больная тема
[42:59.840 --> 43:04.840]  мы там пытались, что-то получилось, что-то не получилось
[43:04.840 --> 43:07.840]  надо для начала повторить, да?
[43:07.840 --> 43:10.840]  CRTP нас не интересует
[43:10.840 --> 43:14.840]  хотя нет, давайте про CRTP еще одно упоминание
[43:14.840 --> 43:20.840]  внезапно в C++20
[43:20.840 --> 43:28.840]  появилось еще одно смешное использование CRTP в Ranges, про которое мы будем говорить потом
[43:28.840 --> 43:33.840]  но применение тут примерно такое же, как мы смотрели
[43:33.840 --> 43:38.840]  можно некоторый класс, который называется View, не важно, что это
[43:38.840 --> 43:42.840]  отнаследовать от вот такого View-интерфейса, используя CRTP
[43:42.840 --> 43:49.840]  дальше нужно объявить BeginEnd в нашем наследнике
[43:49.840 --> 43:54.840]  вот этот хитрый интерфейс нам как бы подмешает
[43:54.840 --> 44:01.840]  внутри этого класса куча смешных дополнительных функций, реализованных через BeginEnd
[44:01.840 --> 44:04.840]  например, проверку на empty
[44:04.840 --> 44:08.840]  но тут еще хитрее все, на самом деле
[44:08.840 --> 44:14.840]  empty он подмешает только если вот этот шаблонный аргумент
[44:14.840 --> 44:18.840]  и вытворяет вот такому концепту
[44:18.840 --> 44:23.840]  там оператор bool подмешает, кажется, всегда
[44:23.840 --> 44:27.840]  ну там тоже скорее всего будет концепт
[44:27.840 --> 44:30.840]  примерно понятно, как empty реализовать, если у нас есть BeginEnd
[44:30.840 --> 44:33.840]  это какой-то картаинер
[44:33.840 --> 44:36.840]  просто проверить, сравить для BeginEnd
[44:36.840 --> 44:41.840]  оператор bool тоже самое
[44:41.840 --> 44:46.840]  дата это звездочка Begin по сути
[44:46.840 --> 44:49.840]  size это End-Begin
[44:49.840 --> 44:53.840]  ну там похитрее на самом деле
[44:53.840 --> 44:58.840]  давайте закроем
[44:58.840 --> 45:01.840]  кому-то кого-то на комиссию отправили
[45:01.840 --> 45:04.840]  видимо
[45:04.840 --> 45:07.840]  вот
[45:07.840 --> 45:11.840]  да, ну у size тоже понятно, как реализовать
[45:11.840 --> 45:15.840]  End-Begin, но такой size можно реализовать
[45:15.840 --> 45:20.840]  только если вот результат этих Begin и End можно вычитать
[45:20.840 --> 45:26.840]  соответственно тут навешаны констрейнты, которые это требуют
[45:26.840 --> 45:30.840]  ну и front и back для контейнера понятно, как реализовать
[45:30.840 --> 45:33.840]  если у нас есть BeginEnd на самом деле
[45:33.840 --> 45:35.840]  с некоторыми оговорками
[45:35.840 --> 45:38.840]  то есть на самом деле многие контейнеры в OSTD
[45:38.840 --> 45:42.840]  кажется, что можно было бы с помощью такой штуки очень удобно реализовывать
[45:42.840 --> 45:47.840]  не выписывая все вот эти вещи руками
[45:47.840 --> 45:54.840]  ну да, там требуются какие-то сложные штуки, которые мы потом будем
[45:54.840 --> 46:01.840]  ну сам OSTD Ranges сложный
[46:01.840 --> 46:05.840]  это нечто
[46:05.840 --> 46:09.840]  а Unifex будет еще больше нечто
[46:09.840 --> 46:12.840]  будет одобрее
[46:12.840 --> 46:17.840]  да, вернемся к нашему барану
[46:17.840 --> 46:20.840]  TypeRange, все, наконец-то
[46:20.840 --> 46:26.840]  мы остановились на том, что написали AnyInput
[46:26.840 --> 46:29.840]  а вообще, что такое было TypeRange?
[46:29.840 --> 46:31.840]  это такой волшебный способ
[46:31.840 --> 46:37.840]  забыть о том, какой был тип у какого-то набора значений
[46:37.840 --> 46:41.840]  с условием, что у них у всех есть некий общий функционал
[46:41.840 --> 46:45.840]  то есть функционал не забыли, а типы забыли
[46:45.840 --> 46:49.840]  и вот в Any можно положить вообще что угодно
[46:49.840 --> 46:51.840]  и мы забудем, что там лежит
[46:51.840 --> 46:54.840]  единственное, что мы можем сделать, это попутаться, вытащить
[46:54.840 --> 46:57.840]  получилось окей, не получилась беда
[46:57.840 --> 47:02.840]  а также есть функцион, который похож на OSTD Function
[47:02.840 --> 47:07.840]  он забывает все, кроме оператора вызова
[47:07.840 --> 47:10.840]  для того, что мы туда положим
[47:10.840 --> 47:14.840]  помните, что у каждой лямбды свой уникальный тип
[47:14.840 --> 47:18.840]  и лямбду просто так куда-то не сохранить
[47:18.840 --> 47:20.840]  ее тип нельзя выписать
[47:20.840 --> 47:23.840]  а вот OSTD Function или наш Function
[47:23.840 --> 47:25.840]  позволяет забыть тип этой лямбды
[47:25.840 --> 47:28.840]  и запомнить только то, что ее можно вызвать от MTA
[47:28.840 --> 47:32.840]  ну и вернуть в плагин
[47:32.840 --> 47:36.840]  вот, но то, что мы написали, оно было не очень хорошее
[47:36.840 --> 47:38.840]  давайте фиксить нехорошести
[47:38.840 --> 47:41.840]  первая нехорошесть – это динамик Cast
[47:41.840 --> 47:45.840]  мы думали в прошлый раз пять минут, как это убрать, не придумали
[47:45.840 --> 47:48.840]  но не мудрено
[47:48.840 --> 47:51.840]  не помню, это не придумать, мне кажется
[47:51.840 --> 47:57.840]  вспомним, как у нас работал весь этот type ratio
[47:57.840 --> 47:59.840]  мы хранили UniquePtr
[47:59.840 --> 48:04.840]  на наследника такого вот интерфейса
[48:04.840 --> 48:06.840]  ничего не делающего
[48:06.840 --> 48:09.840]  а наследников генерили через шаблон
[48:16.840 --> 48:19.840]  и что нам, по сути, нужно сделать
[48:19.840 --> 48:22.840]  нам нужно спросить вот этого наследника
[48:22.840 --> 48:26.840]  ну, вот этот nimpl
[48:29.840 --> 48:33.840]  попросить его выдать нам какой-то идентификатор
[48:33.840 --> 48:36.840]  какую-нибудь чиселку, которая разная
[48:36.840 --> 48:40.840]  для всех инстанциаций вот этих вот
[48:40.840 --> 48:42.840]  по сути
[48:42.840 --> 48:45.840]  если мы научимся для каждого конкретного импла
[48:45.840 --> 48:47.840]  вернее, его инстанциации
[48:47.840 --> 48:50.840]  иметь разную чиселку
[48:50.840 --> 48:52.840]  в compile-time
[48:52.840 --> 48:54.840]  то мы, по сути, победили
[48:54.840 --> 48:56.840]  мы сможем взять, инстанцировать
[48:56.840 --> 48:58.840]  вот здесь, в гете
[48:58.840 --> 49:00.840]  конкрет импл от t
[49:00.840 --> 49:02.840]  и забрать оттуда чиселку
[49:02.840 --> 49:06.840]  а также попросить чиселку из nimpl
[49:06.840 --> 49:09.840]  если они совпали, то можем reintegrate-cast
[49:09.840 --> 49:11.840]  или static-cast
[49:11.840 --> 49:14.840]  если не совпали – беда
[49:14.840 --> 49:16.840]  так вот, чиселка
[49:16.840 --> 49:19.840]  понятное дело, что чтобы
[49:19.840 --> 49:22.840]  вот отсюда вытаскивать такую чиселку
[49:22.840 --> 49:24.840]  из импла
[49:24.840 --> 49:27.840]  нам все-таки понадобится виртуальный метод
[49:34.840 --> 49:38.840]  а вместо чиселки мы будем использовать void-звездочка
[49:38.840 --> 49:40.840]  или char-звездочка
[49:40.840 --> 49:43.840]  void-звездочки нельзя сравнивать
[49:43.840 --> 49:45.840]  на равенство
[49:45.840 --> 49:47.840]  ну посмотрим
[49:47.840 --> 49:49.840]  это то, что не сильно часто приходится делать
[49:49.840 --> 49:51.840]  так что увидите
[49:51.840 --> 49:53.840]  где-то id будет
[49:59.840 --> 50:02.840]  ну и у каждого такого конкретного импла
[50:02.840 --> 50:04.840]  я хочу
[50:06.840 --> 50:08.840]  хочу заубирайтесь
[50:08.840 --> 50:11.840]  но что писать, пока мы сюда не понимаем
[50:11.840 --> 50:13.840]  как будет 0.2
[50:13.840 --> 50:15.840]  что-нибудь
[50:15.840 --> 50:17.840]  все так
[50:17.840 --> 50:19.840]  так вот
[50:19.840 --> 50:21.840]  остался последний шаг
[50:21.840 --> 50:24.840]  как сгенерить уникальную чиселку
[50:24.840 --> 50:28.840]  для каждой инстанциации конкрет импла
[50:28.840 --> 50:31.840]  конечно это будет любый хак
[50:31.840 --> 50:34.840]  без state-sum это против
[50:34.840 --> 50:36.840]  да
[50:36.840 --> 50:40.840]  мы сделаем state-void-хак
[50:40.840 --> 50:43.840]  и сделаем его
[50:43.840 --> 50:45.840]  в любом случае
[50:45.840 --> 50:47.840]  в любом случае
[50:47.840 --> 50:49.840]  в любом случае
[50:49.840 --> 50:51.840]  в любом случае
[50:51.840 --> 50:53.840]  в любом случае
[50:53.840 --> 50:55.840]  в любом случае
[50:55.840 --> 50:56.840]  хак
[50:56.840 --> 50:58.840]  и сделаем его
[50:58.840 --> 51:01.840]  зависимым от t
[51:01.840 --> 51:03.840]  на всякий случай
[51:03.840 --> 51:05.840]  потому что если сделать независимым
[51:05.840 --> 51:07.840]  может взорваться, я не уверен
[51:07.840 --> 51:09.840]  нот имплементы
[51:09.840 --> 51:11.840]  мы его имплементируем
[51:14.840 --> 51:16.840]  все хорошо
[51:16.840 --> 51:18.840]  а здесь мы вернем
[51:18.840 --> 51:20.840]  ну
[51:24.840 --> 51:26.840]  что, не так?
[51:26.840 --> 51:28.840]  да
[51:28.840 --> 51:31.840]  ну надо заринтеры вгастить
[51:31.840 --> 51:33.840]  ну или застаток вгастить
[51:41.840 --> 51:43.840]  ну понятно
[51:48.840 --> 51:50.840]  даже я не знаю
[51:50.840 --> 51:52.840]  std-sist
[51:52.840 --> 51:55.840]  а, int-ptrt
[51:55.840 --> 51:57.840]  вот это будет лучше
[51:57.840 --> 52:00.840]  int-ptrt для тех, кто впервые такую штуку видит
[52:00.840 --> 52:02.840]  это такой целочисленный тип
[52:02.840 --> 52:05.840]  размер которого равен размеру указателя
[52:05.840 --> 52:07.840]  ну то есть
[52:07.840 --> 52:10.840]  как бы std-sist формально говоря
[52:10.840 --> 52:12.840]  может быть 32 бита
[52:12.840 --> 52:14.840]  даже если у нас указатель
[52:14.840 --> 52:16.840]  это 64 бита
[52:16.840 --> 52:18.840]  такое даже бывает вроде в реальной жизни
[52:18.840 --> 52:20.840]  так что int-ptrt
[52:20.840 --> 52:22.840]  это безопасный способ взять указатель
[52:22.840 --> 52:24.840]  и использовать как просто чиселку
[52:26.840 --> 52:28.840]  ну вот мы и победили
[52:28.840 --> 52:30.840]  а здесь мы сделаем
[52:30.840 --> 52:32.840]  следующий прикол
[52:32.840 --> 52:34.840]  if
[52:34.840 --> 52:36.840]  импл
[52:36.840 --> 52:38.840]  getId
[52:38.840 --> 52:40.840]  равно
[52:40.840 --> 52:42.840]  да, конкрет
[52:42.840 --> 52:44.840]  импл
[52:44.840 --> 52:46.840]  getId
[52:46.840 --> 52:48.840]  а
[52:48.840 --> 52:50.840]  а
[52:50.840 --> 52:52.840]  мне что-то не нравится
[53:02.840 --> 53:04.840]  давайте вот эту штуку вот сюда
[53:14.840 --> 53:16.840]  да
[53:16.840 --> 53:18.840]  просто для удобства
[53:18.840 --> 53:20.840]  и здесь будем сравнивать
[53:22.840 --> 53:24.840]  этот хак можно даже
[53:24.840 --> 53:26.840]  приват отправить
[53:34.840 --> 53:36.840]  нет
[53:36.840 --> 53:38.840]  мы же не знаем, какой из наследников
[53:38.840 --> 53:40.840]  импл
[53:40.840 --> 53:42.840]  лежит вот здесь
[53:42.840 --> 53:44.840]  мы здесь
[53:44.840 --> 53:46.840]  используем то, что у нас есть
[53:46.840 --> 53:48.840]  динамическая диспетчеризация
[53:50.840 --> 53:52.840]  в зависимости от того, кто лежит
[53:52.840 --> 53:54.840]  под вот этим указателем на импл
[53:54.840 --> 53:56.840]  да
[53:56.840 --> 53:58.840]  мы выберем разный getId
[54:02.840 --> 54:04.840]  то есть то, что здесь
[54:04.840 --> 54:06.840]  хранилось, оно вернет тот
[54:06.840 --> 54:08.840]  id, который был у него
[54:08.840 --> 54:10.840]  у его тэшки
[54:10.840 --> 54:12.840]  соответственно
[54:12.840 --> 54:14.840]  здесь мы берем id тэшки, которые
[54:14.840 --> 54:16.840]  пытаемся кастить
[54:16.840 --> 54:18.840]  если они совпали
[54:18.840 --> 54:20.840]  то мы можем с уверенностью просто
[54:22.840 --> 54:24.840]  кстати
[54:24.840 --> 54:26.840]  кастить
[54:26.840 --> 54:28.840]  конкрет импл
[54:28.840 --> 54:30.840]  get
[54:30.840 --> 54:32.840]  звездочки
[54:32.840 --> 54:34.840]  импл get
[54:34.840 --> 54:36.840]  и у этой штуки получать
[54:36.840 --> 54:38.840]  get
[54:38.840 --> 54:40.840]  иначе
[54:40.840 --> 54:42.840]  что мы делали иначе
[54:56.840 --> 54:58.840]  интересный хак, не правда ли?
[54:58.840 --> 55:00.840]  только там он плохо
[55:00.840 --> 55:02.840]  работает с констами
[55:02.840 --> 55:04.840]  например, если мы хотим получить
[55:04.840 --> 55:06.840]  констант, isn't that
[55:06.840 --> 55:08.840]  да, про то, что происходит
[55:08.840 --> 55:10.840]  если у нас здесь консты не консты
[55:10.840 --> 55:12.840]  это мы еще поговорим
[55:12.840 --> 55:14.840]  это еще один кусок, который надо
[55:14.840 --> 55:16.840]  рассказать обязательно
[55:22.840 --> 55:24.840]  да-да, так и работает
[55:24.840 --> 55:26.840]  а если мы вот здесь напишем
[55:26.840 --> 55:28.840]  сразу getFloat
[55:32.840 --> 55:34.840]  прилетело
[55:34.840 --> 55:36.840]  РДТИ
[55:36.840 --> 55:38.840]  да, ну его
[55:38.840 --> 55:40.840]  не нужен он
[55:42.840 --> 55:44.840]  да, просто
[55:44.840 --> 55:46.840]  небольшой набор скромных
[55:46.840 --> 55:48.840]  хаков и все работает
[55:48.840 --> 55:50.840]  никакой РДТИ
[55:50.840 --> 55:52.840]  вот, давайте дальше
[55:52.840 --> 55:54.840]  думать, почему этот код все еще хрей
[55:56.840 --> 55:58.840]  почему этот n все еще хрей
[56:00.840 --> 56:02.840]  но констант
[56:02.840 --> 56:04.840]  не токое, гораздо более очевидное
[56:08.840 --> 56:10.840]  вот, мы так не умеем
[56:12.840 --> 56:14.840]  ну мы хотим просто
[56:14.840 --> 56:16.840]  взять и скопировать
[56:16.840 --> 56:18.840]  мы не умеем копировать сейчас эни
[56:18.840 --> 56:20.840]  да, за счет того, что
[56:20.840 --> 56:22.840]  зачем?
[56:22.840 --> 56:24.840]  ну зачем по току можно
[56:24.840 --> 56:26.840]  ну если там веки разных типов
[56:26.840 --> 56:28.840]  просто старые веки ничтожат
[56:28.840 --> 56:30.840]  ничего не надо
[56:30.840 --> 56:32.840]  ничего не надо, у нас все работает
[56:32.840 --> 56:34.840]  sharedPTR сделать
[56:34.840 --> 56:36.840]  этого тоже не надо
[56:36.840 --> 56:38.840]  у нас
[56:38.840 --> 56:40.840]  нет, sharedPTR это не то, что мы хотим
[56:40.840 --> 56:42.840]  если мы используем sharedPTR
[56:42.840 --> 56:44.840]  то у нас будет здесь
[56:44.840 --> 56:46.840]  два разных эни ссылаться
[56:46.840 --> 56:48.840]  на одно и то же значение
[56:48.840 --> 56:50.840]  а у эни должна быть семантика value
[56:50.840 --> 56:52.840]  дип копии должен происходить
[56:52.840 --> 56:54.840]  вот, а насчет деструкторов
[56:54.840 --> 56:56.840]  с деструктурами здесь уже все нормально
[56:56.840 --> 56:58.840]  за счет того, что деструктор
[56:58.840 --> 57:00.840]  в виртуальной мы используем UniquePTR
[57:00.840 --> 57:02.840]  вот в этом как раз и
[57:02.840 --> 57:04.840]  пункт технологии через виртуальные вызов
[57:04.840 --> 57:06.840]  что здесь думать-то особо не надо
[57:06.840 --> 57:08.840]  в стандартной ООП все спокойно работает
[57:14.840 --> 57:16.840]  скоро откажемся
[57:16.840 --> 57:18.840]  все-все в планах
[57:18.840 --> 57:20.840]  ну как бы
[57:20.840 --> 57:22.840]  как в ООП решается проблема
[57:22.840 --> 57:24.840]  дип копии
[57:24.840 --> 57:26.840]  пишется
[57:26.840 --> 57:34.840]  nimple UniquePTR
[57:34.840 --> 57:36.840]  clone
[57:36.840 --> 57:38.840]  что-что?
[57:38.840 --> 57:40.840]  DTO
[57:40.840 --> 57:42.840]  не до конца
[57:42.840 --> 57:44.840]  не совсем
[57:44.840 --> 57:46.840]  тут сложно сказать
[57:46.840 --> 57:48.840]  где патрон прототипа, а где просто дип копии
[57:48.840 --> 57:50.840]  прототип обычно
[57:50.840 --> 57:52.840]  подразумевает, что мы
[57:52.840 --> 57:54.840]  сильно abuse
[57:54.840 --> 57:56.840]  этот clone для конструирования
[57:56.840 --> 57:58.840]  каких-то копий
[57:58.840 --> 58:00.840]  для какого-то такого
[58:00.840 --> 58:02.840]  полиморфизма конструкторов
[58:02.840 --> 58:04.840]  а здесь просто как бы
[58:04.840 --> 58:06.840]  конструктор копирования надо вывезти
[58:16.840 --> 58:18.840]  да, наверное это из-за того, что внизу
[58:18.840 --> 58:20.840]  виртуальный или пока такая паника происходит
[58:20.840 --> 58:22.840]  давайте виртуальный
[58:24.840 --> 58:32.840]  clone overwrite
[58:32.840 --> 58:34.840]  что мы здесь будем делать?
[58:34.840 --> 58:36.840]  ничего сложного
[58:36.840 --> 58:38.840]  мы вернем U
[58:38.840 --> 58:40.840]  onCreateImple
[58:40.840 --> 58:42.840]  от
[58:42.840 --> 58:44.840]  then
[58:54.840 --> 58:56.840]  да, скорее всего
[58:56.840 --> 58:58.840]  нет
[58:58.840 --> 59:00.840]  давайте
[59:00.840 --> 59:02.840]  у меня, честно говоря, в последнее время
[59:02.840 --> 59:04.840]  какие-то проблемы с этим никому
[59:04.840 --> 59:06.840]  мне кажется, что у меня
[59:06.840 --> 59:08.840]  всю жизнь работало просто
[59:08.840 --> 59:10.840]  а потом оно почему-то перестает
[59:10.840 --> 59:12.840]  и я грущен
[59:12.840 --> 59:14.840]  а, да
[59:14.840 --> 59:16.840]  нет
[59:16.840 --> 59:18.840]  вот
[59:18.840 --> 59:20.840]  вот
[59:20.840 --> 59:22.840]  вот
[59:22.840 --> 59:24.840]  нет
[59:26.840 --> 59:28.840]  пишем тупо, не пытаясь выпендриваться
[59:28.840 --> 59:30.840]  современными фишками
[59:30.840 --> 59:32.840]  concreateImple
[59:32.840 --> 59:34.840]  вот
[59:34.840 --> 59:36.840]  то есть мы создали
[59:36.840 --> 59:38.840]  новый concreteImple
[59:38.840 --> 59:40.840]  с теми же шаблонными аргументами
[59:40.840 --> 59:42.840]  запустив
[59:42.840 --> 59:44.840]  конструктор копирования
[59:44.840 --> 59:46.840]  от вот этой тешки
[59:46.840 --> 59:48.840]  и вернули линейку ptr
[59:48.840 --> 59:50.840]  от этой штуки
[59:50.840 --> 59:52.840]  ура
[59:52.840 --> 59:54.840]  теперь мы можем реализовать
[59:54.840 --> 59:56.840]  конструктор копирования
[01:00:02.840 --> 01:00:04.840]  я не удерживаюсь
[01:00:04.840 --> 01:00:06.840]  и оператор
[01:00:06.840 --> 01:00:08.840]  присваиваем
[01:00:16.840 --> 01:00:18.840]  во-первых
[01:00:20.840 --> 01:00:22.840]  так
[01:00:26.840 --> 01:00:28.840]  в таком кейсе ничего не хотим делать
[01:00:30.840 --> 01:00:32.840]  про копирование
[01:00:32.840 --> 01:00:34.840]  мы инициализируем
[01:00:34.840 --> 01:00:36.840]  ой
[01:00:36.840 --> 01:00:38.840]  мы инициализируем импл
[01:00:38.840 --> 01:00:40.840]  импл чем?
[01:00:46.840 --> 01:00:48.840]  и все
[01:00:48.840 --> 01:00:50.840]  все
[01:00:50.840 --> 01:00:52.840]  здесь
[01:00:58.840 --> 01:01:00.840]  std
[01:01:00.840 --> 01:01:02.840]  exchange
[01:01:02.840 --> 01:01:04.840]  импл
[01:01:10.840 --> 01:01:12.840]  так же сработал
[01:01:12.840 --> 01:01:14.840]  ну как зачем
[01:01:14.840 --> 01:01:16.840]  ладно
[01:01:16.840 --> 01:01:18.840]  сделаем проще
[01:01:36.840 --> 01:01:38.840]  а стоп
[01:01:38.840 --> 01:01:40.840]  мы же копировать хотим инициализировать
[01:01:40.840 --> 01:01:42.840]  да
[01:01:42.840 --> 01:01:44.840]  что-то у меня в голове заклинило
[01:01:44.840 --> 01:01:46.840]  клон мы хотим опекивать
[01:01:46.840 --> 01:01:48.840]  все
[01:01:48.840 --> 01:01:50.840]  то бишь что происходит со старым имплом
[01:01:50.840 --> 01:01:52.840]  он спокойненько удаляется
[01:01:52.840 --> 01:01:54.840]  как удаляется любой полиморфный класс
[01:01:54.840 --> 01:01:56.840]  диструкторы вызываются, все хорошо
[01:02:02.840 --> 01:02:04.840]  а потом мы делаем клон и записываем
[01:02:04.840 --> 01:02:06.840]  о себе
[01:02:06.840 --> 01:02:08.840]  кажется теперь это должно работать
[01:02:08.840 --> 01:02:10.840]  мы взяли а
[01:02:10.840 --> 01:02:12.840]  и давайте попытаемся вывести
[01:02:12.840 --> 01:02:14.840]  ткет
[01:02:14.840 --> 01:02:16.840]  b как
[01:02:22.840 --> 01:02:24.840]  куда оно нам тычит нос
[01:02:34.840 --> 01:02:36.840]  о нет
[01:02:36.840 --> 01:02:38.840]  я пытаюсь быстро подкастрелять это
[01:02:38.840 --> 01:02:40.840]  если не выйдет
[01:02:40.840 --> 01:02:42.840]  а
[01:02:42.840 --> 01:02:44.840]  а
[01:02:44.840 --> 01:02:46.840]  а
[01:02:46.840 --> 01:02:48.840]  а
[01:02:48.840 --> 01:02:50.840]  а
[01:02:50.840 --> 01:02:52.840]  а
[01:02:52.840 --> 01:02:54.840]  а
[01:02:54.840 --> 01:02:56.840]  а
[01:02:56.840 --> 01:02:58.840]  а
[01:02:58.840 --> 01:03:00.840]  а
[01:03:00.840 --> 01:03:02.840]  а
[01:03:02.840 --> 01:03:04.840]  а
[01:03:04.840 --> 01:03:06.840]  а
[01:03:06.840 --> 01:03:08.840]  а
[01:03:08.840 --> 01:03:10.840]  а
[01:03:10.840 --> 01:03:12.840]  а
[01:03:12.840 --> 01:03:14.840]  а
[01:03:14.840 --> 01:03:16.840]  да мы хотим
[01:03:16.840 --> 01:03:18.840]  короче
[01:03:18.840 --> 01:03:20.840]  в чем ошибка
[01:03:20.840 --> 01:03:22.840]  вот этот
[01:03:22.840 --> 01:03:24.840]  синтаксис как мы знаем
[01:03:24.840 --> 01:03:26.840]  вызывает не
[01:03:26.840 --> 01:03:28.840]  оператор присваивания
[01:03:28.840 --> 01:03:30.840]  он вызывает конструктор копирования
[01:03:30.840 --> 01:03:32.840]  окей
[01:03:32.840 --> 01:03:34.840]  но
[01:03:34.840 --> 01:03:36.840]  ну ка проверим
[01:03:36.840 --> 01:03:38.840]  а вот этот сможет
[01:03:38.840 --> 01:03:40.840]  что для этого нужно сделать
[01:03:40.840 --> 01:03:42.840]  проверить requires
[01:03:42.840 --> 01:03:44.840]  для этого нужно проверить
[01:03:44.840 --> 01:03:46.840]  является ли самирегулярным
[01:03:46.840 --> 01:03:48.840]  t а t у нас н
[01:03:48.840 --> 01:03:50.840]  окей
[01:03:50.840 --> 01:03:52.840]  что проверить он самирегулярный
[01:03:52.840 --> 01:03:54.840]  нужно проверить, что он имеет конструктор
[01:03:54.840 --> 01:03:56.840]  копирования
[01:03:56.840 --> 01:03:58.840]  а вот это может он
[01:03:58.840 --> 01:04:00.840]  ну давайте проверим
[01:04:00.840 --> 01:04:12.520]  Нужно аккуратно. Вот этот костыль должен пофиксить. Не пофиксил.
[01:04:12.520 --> 01:04:27.920]  Не то, конечно. Вот так, вот так.
[01:04:27.920 --> 01:04:41.920]  Да, это надо взять в скобочки, потому что парсер больно. Вот, мы прервали бесконечные рекурсии, ну молодцы.
[01:04:41.920 --> 01:04:54.920]  Но, собственно, нам к лангтайде и жалуются, что конструктор, который принимает forwarding-reference, может захайдить это, но и советует эксплиситово пометить.
[01:04:54.920 --> 01:05:00.920]  Я не знаю, хочу ли эксплиситово пометить, потому что мне вот нравится, если честно, писать.
[01:05:00.920 --> 01:05:17.920]  Но перед тем, как Энни войдет в Overload Resolution, в Overload Set, нужно проверить, что Requirements удовлетворены.
[01:05:17.920 --> 01:05:25.920]  То есть, еще до того, как мы построили Set перегрузок, мы ушли в бесконечную рекурсию, пытаясь проверять вот этот общий минимум.
[01:05:25.920 --> 01:05:37.920]  Да, современный C++ такой, непонятно, что происходит. Ура, должно работать. Действительно работает.
[01:05:37.920 --> 01:05:48.920]  Вот мы научились копировать. Ну, move-ать, кажется, здесь учиться не надо. Move-ать, Энни, это понятно, просто move-аем линейка.
[01:05:48.920 --> 01:05:58.920]  Кажется, дефолтный move этот уже вполне работает. Да, дефолтный move-конструктор, дефолтный ратор move.
[01:05:58.920 --> 01:06:08.920]  Что-нибудь, что-нибудь надо.
[01:06:08.920 --> 01:06:14.920]  А мы проверили? Да.
[01:06:14.920 --> 01:06:24.920]  Проверим.
[01:06:24.920 --> 01:06:34.920]  Что? Не сгенерировал. Не сгенерировал, ладно, я не прав.
[01:06:34.920 --> 01:06:48.920]  Провело пти, оно не про это, это правило для программиста, а для компилятора немножко другие правила действуют.
[01:06:48.920 --> 01:07:00.920]  Вот это я тоже постоянно с этим путаюсь, если честно. Проще, конечно, всегда писать все варианты, точно не ошибешься.
[01:07:00.920 --> 01:07:24.920]  Я думаю, оно даже заработает.
[01:07:24.920 --> 01:07:42.920]  Так вот, про констрейли, и платильность, и мувабельность я вообще хотел говорить на функциях.
[01:07:42.920 --> 01:07:47.920]  Сейчас здесь попробуем поговорить.
[01:07:47.920 --> 01:08:01.920]  Что будет, начнем с простого, что будет, если мы сделаем вот так.
[01:08:01.920 --> 01:08:23.920]  Да, в чем проблема?
[01:08:23.920 --> 01:08:33.920]  Мы потребовали регуляр, да, самирегуляр.
[01:08:33.920 --> 01:08:43.920]  Это слишком жирно. Да, уникпадр не является самирегуляр, давайте откроем.
[01:08:43.920 --> 01:08:58.920]  Если бы референс был самирегуляру, копия был и дефолты не шалаизовывали, да, мне кажется, что на ошейне должен как бы и с мувабелонными типами тоже работать.
[01:08:58.920 --> 01:09:08.920]  Поэтому давайте вот это вот условие все-таки отпилим и будем более тонко смотреть.
[01:09:08.920 --> 01:09:16.920]  В чем теперь проблема? В том, что мы и там еще самирегулярно писали.
[01:09:16.920 --> 01:09:25.920]  Вот, теперь в чем проблема? Она не ушла никуда, конечно же.
[01:09:25.920 --> 01:09:41.920]  Какая ошибка, я пытаюсь понять. Вот ошибка, да. Как только мы клон пытаемся вызвать, произойдет фигня.
[01:09:41.920 --> 01:09:51.920]  Что в этом случае вообще делать?
[01:09:51.920 --> 01:10:02.920]  Оказывается, что хорошо бы рандайм ошибку делать.
[01:10:02.920 --> 01:10:13.920]  Давайте посмотрим, что STD делается в таком случае.
[01:10:13.920 --> 01:10:23.920]  А, нет, он вообще так не умеет. Ладно.
[01:10:31.920 --> 01:10:38.920]  Давайте попробуем. Все-таки лучше всего эта штука чувствуется, на примере, с функцией, чем в сцене.
[01:10:38.920 --> 01:10:48.920]  Мне кажется, Энни все-таки лучше оставить стекулярными и следовать примеру STD.
[01:10:48.920 --> 01:10:56.920]  Что еще нужно пофиксить? Консты, да?
[01:10:56.920 --> 01:11:08.920]  И не только на самом деле. Что если мы хотим мувнуть то, что лежит внутри Энни?
[01:11:08.920 --> 01:11:20.920]  У нас есть замечательная операция Get. Она сейчас возвращает 10%. Но это не очень хорошо.
[01:11:20.920 --> 01:11:28.920]  Что будет происходить, если...
[01:11:28.920 --> 01:11:36.920]  Что будет происходить, если...
[01:11:36.920 --> 01:11:46.920]  Вектор ментов, в котором лежит 1, 2, 3. Вот так хорошо.
[01:11:46.920 --> 01:12:00.920]  Энни, Б, мув, А, нет, даже не так. Вектор ментов, Get, вектор ментов.
[01:12:00.920 --> 01:12:10.920]  Что должно происходить в таком случае? Что в нашем случае произойдет?
[01:12:10.920 --> 01:12:20.920]  Да, мы вернем из Get ссылку и скопируем. Это может быть слегка неожиданно, да?
[01:12:20.920 --> 01:12:30.920]  Да, ожидается, что это полезно уметь делать.
[01:12:30.920 --> 01:12:40.920]  Давайте посмотрим, что произойдет так.
[01:12:40.920 --> 01:12:50.920]  Слово класс.
[01:12:50.920 --> 01:13:00.920]  Да, попробуем понять, что лежит теперь.
[01:13:00.920 --> 01:13:10.920]  Да, попробуем понять, что лежит теперь.
[01:13:10.920 --> 01:13:20.920]  Вот так.
[01:13:20.920 --> 01:13:30.920]  И что лежит вектор, попробуем понять.
[01:13:30.920 --> 01:13:40.920]  А, это же у нас просто... Да, все.
[01:13:40.920 --> 01:13:50.920]  3, 3, 3. Да, скопировалось. Давайте попробуем это заменить на STDN.
[01:13:50.920 --> 01:14:00.920]  Ой, а там еще все сложно. Там же не кастом.
[01:14:00.920 --> 01:14:10.920]  Не кастом, да? Да.
[01:14:10.920 --> 01:14:18.920]  То есть это не кастом. Это было свободная функция.
[01:14:18.920 --> 01:14:30.920]  Спасибо, Силан, что сделал. Ровно то, что я хотел.
[01:14:30.920 --> 01:14:40.920]  Вот так вот, да?
[01:14:40.920 --> 01:14:50.920]  Вот. Посмотрим, что здесь произойдет.
[01:14:50.920 --> 01:15:00.920]  Ага, ноль. А у нас было 3, 2, 3. То бишь, когда мы делаем гет из РВ,
[01:15:00.920 --> 01:15:10.920]  то оно как бы его забирает. Это весьма логично. И если задуматься,
[01:15:10.920 --> 01:15:16.920]  то какие-то опертки над чем-то работают точно так же.
[01:15:16.920 --> 01:15:22.920]  Давайте сделаем, чтобы у нас работало точно так же.
[01:15:22.920 --> 01:15:30.920]  Во-первых, вот такая штука у нас будет возвращаться только когда lvalue.
[01:15:30.920 --> 01:15:38.920]  Если кого-нибудь пугает.
[01:15:38.920 --> 01:15:44.920]  После метода можно дописывать различные квалифаеры, которые будут накинуты
[01:15:44.920 --> 01:15:50.920]  на то выражение, у которого мы вызываем этот метод. Если мы написали ampersand,
[01:15:50.920 --> 01:15:58.920]  то gt можно будет вызвать только у lvalue выражения. Если в ampersand,
[01:15:58.920 --> 01:16:04.920]  то у lvalue выражения. Если на весь лек конст, то только у конст выражения.
[01:16:04.920 --> 01:16:12.920]  Вот такие пироги. Соответственно, если у нас просто lvalue и не конст,
[01:16:12.920 --> 01:16:18.920]  то мы делаем lvalue. Если мы делаем вот так, то мы делаем вот так.
[01:16:18.920 --> 01:16:22.920]  Если у нас...
[01:16:30.920 --> 01:16:36.920]  Вот как-то так получается. Смотри, какой паснутый метод, который отличается примерно ничем.
[01:16:36.920 --> 01:16:42.920]  Пойнт только в том, что у них разные вот эти вот квалифаеры.
[01:16:42.920 --> 01:16:46.920]  Соответственно, если теперь мы...
[01:16:46.920 --> 01:16:50.920]  Ой, давайте...
[01:17:02.920 --> 01:17:06.920]  Сейчас я напишу этот заказ быстренько, потому что я задолбался.
[01:17:16.920 --> 01:17:20.920]  Ничего я потерять не должен был.
[01:17:46.920 --> 01:17:48.920]  Всё.
[01:17:58.920 --> 01:18:00.920]  Всё.
[01:18:04.920 --> 01:18:06.920]  Почему?
[01:18:08.920 --> 01:18:10.920]  Хорошо.
[01:18:12.920 --> 01:18:14.920]  Всё, я увидел что-то.
[01:18:16.920 --> 01:18:24.920]  Вот. Что я сейчас сделал? Я написал обёрточку такую же, как просто...
[01:18:24.920 --> 01:18:32.920]  Я написал вот эту обёрточку Anycast, которая просто полностью прогидывает всё к нашему гету,
[01:18:32.920 --> 01:18:40.920]  чтобы мне не приходилось второй раз эти Anycast заменять на нашу гету.
[01:18:40.920 --> 01:18:42.920]  Меняем на нашу гету.
[01:18:42.920 --> 01:18:44.920]  Где ошибка?
[01:18:54.920 --> 01:19:00.920]  Да, тут, к сожалению, не получилось.
[01:19:00.920 --> 01:19:04.920]  Да, всё, всё. Похоже на правую.
[01:19:04.920 --> 01:19:08.920]  Ну вот, если мы теперь запустим, мы, соответственно...
[01:19:08.920 --> 01:19:14.920]  Да, получим такое же поведение, как в STD, и всё хорошо.
[01:19:14.920 --> 01:19:20.920]  Вот, соответственно, всё да не всё.
[01:19:20.920 --> 01:19:24.920]  Возникает некоторое количество вопросов.
[01:19:24.920 --> 01:19:28.920]  А что если в УП не положили конст или ссылку?
[01:19:28.920 --> 01:19:32.920]  Давайте забанить такие случаи.
[01:19:32.920 --> 01:19:38.920]  Вот я предлагаю забанить такие случаи и не страдать.
[01:19:38.920 --> 01:19:40.920]  Хотя...
[01:19:40.920 --> 01:19:46.920]  Я Article 3.
[01:19:46.920 --> 01:19:56.520]  Я предлагаю забанить такие случаи и не страдать, хотя
[01:19:56.520 --> 01:19:59.920]  в таком может быть смысл, да?
[01:19:59.920 --> 01:20:02.240]  Зачем ссылку, если можно указать и помнить?
[01:20:02.240 --> 01:20:05.880]  Да, ссылки бессмысленно, ссылки это вообще дичь,
[01:20:05.880 --> 01:20:09.600]  это мы даже не будем пытаться использовать, даже в стандартной
[01:20:09.600 --> 01:20:14.160]  библиотеке классы типа optional со ссылками сейчас работают
[01:20:14.160 --> 01:20:15.160]  как-то крип.
[01:20:15.160 --> 01:20:22.400]  Вроде даже вообще не понятно, что должно происходить,
[01:20:22.400 --> 01:20:23.400]  вообще не понятно.
[01:20:23.400 --> 01:20:26.520]  Так, соответственно, проверяем, мы забанили то, что там
[01:20:26.520 --> 01:20:30.960]  ссылки могут получиться, да, мы забанили, потому что
[01:20:30.960 --> 01:20:34.040]  мы явно ремонт свой референс, ну и конст, собственно,
[01:20:34.040 --> 01:20:35.040]  забанили.
[01:20:35.040 --> 01:20:39.320]  Но если задуматься, то в принципе конст можно
[01:20:39.320 --> 01:20:40.320]  туда положить.
[01:20:40.320 --> 01:20:46.400]  Только непонятен смысл, потому что конст можно на
[01:20:46.400 --> 01:20:52.440]  самоиндивисит, и за счет вот этих наших хитрых форвардов
[01:20:52.440 --> 01:20:56.480]  будет происходить ровно то, чего мы хотим, чего мне
[01:20:56.480 --> 01:20:57.480]  понравилось.
[01:20:57.480 --> 01:20:58.480]  А получить конст?
[01:20:58.480 --> 01:21:03.480]  Что значит получить конст?
[01:21:03.480 --> 01:21:06.480]  Получить констинт, точнее скостовать констинту.
[01:21:06.480 --> 01:21:14.000]  Но если мы положили инт, то что можно сделать get от
[01:21:14.000 --> 01:21:15.000]  констинта?
[01:21:15.000 --> 01:21:31.840]  Get от констинта, я бы сказал, что просто нужно, не нужно
[01:21:31.840 --> 01:21:32.840]  это поддерживать.
[01:21:33.200 --> 01:21:36.200]  Использователь сам указывает правильную тэшку.
[01:21:36.200 --> 01:21:37.200]  Вот и все.
[01:21:37.200 --> 01:21:40.200]  Мне кажется, это достаточно здраво.
[01:21:40.200 --> 01:21:43.960]  И кажется, на этом вот с такой типа классической
[01:21:43.960 --> 01:21:44.960]  реализации мы закончили.
[01:21:44.960 --> 01:21:45.960]  Про функции.
[01:21:45.960 --> 01:21:57.960]  Функция у нас, на самом деле, наша самая проблема,
[01:21:58.080 --> 01:21:59.080]  была.
[01:21:59.080 --> 01:22:13.520]  Давайте я только как-то попытаюсь вот это все сделать
[01:22:13.520 --> 01:22:22.520]  вот так, сделать вот так, и все это свернуть.
[01:22:22.520 --> 01:22:23.520]  Вот.
[01:22:23.520 --> 01:22:24.520]  Все.
[01:22:24.520 --> 01:22:25.520]  Брали.
[01:22:26.080 --> 01:22:29.080]  И вот это все тоже.
[01:22:29.080 --> 01:22:30.080]  Нафиг.
[01:22:30.080 --> 01:22:33.080]  Вроде как мы все прошли, что у меня нет.
[01:22:33.080 --> 01:22:36.080]  О, и вот это нужно туда же.
[01:22:40.080 --> 01:22:41.080]  Так.
[01:22:41.080 --> 01:22:44.080]  Как слайны к другому консору.
[01:22:44.080 --> 01:22:45.080]  Так.
[01:22:53.080 --> 01:22:54.080]  Так.
[01:22:56.080 --> 01:23:01.080]  В нашей функции у нас такая же проблема.
[01:23:01.080 --> 01:23:04.080]  У нас копирование здесь не происходит.
[01:23:04.080 --> 01:23:09.080]  Ну, понятно, как ее фиксить, это уже давайте не будем
[01:23:09.080 --> 01:23:10.080]  делать.
[01:23:10.080 --> 01:23:15.080]  Но с функциями бывают более хитрые вещи.
[01:23:18.080 --> 01:23:21.080]  Что вообще хранит вот наша вот эта вот функция?
[01:23:21.080 --> 01:23:24.080]  Она хранит некоторый объект, у которого есть оператор
[01:23:24.640 --> 01:23:27.640]  круглой скобки, грубо говоря.
[01:23:27.640 --> 01:23:30.640]  Или у которого можно инвок вызвать.
[01:23:32.640 --> 01:23:37.640]  Что если этот оператор круглой скобки константный?
[01:23:37.640 --> 01:23:40.640]  А что если он не константный?
[01:23:40.640 --> 01:23:45.640]  А что если он только на R-Way не вызывается?
[01:23:48.640 --> 01:23:51.640]  А что если он на EXCEPT?
[01:23:54.080 --> 01:23:55.080]  Да.
[01:23:55.080 --> 01:23:56.080]  Да.
[01:23:59.080 --> 01:24:00.080]  Так.
[01:24:03.080 --> 01:24:06.080]  Да, понятно ли проблема?
[01:24:06.080 --> 01:24:11.080]  Что вот здесь мы как бы call делаем на f, да?
[01:24:13.080 --> 01:24:18.080]  И f у нас value и не константное.
[01:24:19.080 --> 01:24:22.080]  А что если единственный оператор круглой скобки,
[01:24:22.080 --> 01:24:25.080]  который есть вот этого типа f большое, он константный
[01:24:25.080 --> 01:24:28.080]  или там даже только R-Way вызывается?
[01:24:29.080 --> 01:24:32.080]  Вот непонятно.
[01:24:34.080 --> 01:24:37.080]  Давайте лучше пример напишем.
[01:24:46.080 --> 01:24:48.080]  Да, мы эту инфу еще и сохранить не можем.
[01:24:48.080 --> 01:24:51.080]  Нам сейчас нужно будет ее лечить.
[01:24:52.080 --> 01:24:55.080]  Ну, TypeRanger что-то непроста.
[01:25:02.080 --> 01:25:06.080]  Будет оператор круглой скобки, который отвечает на вопрос.
[01:25:06.080 --> 01:25:08.080]  Он будет константный.
[01:25:08.080 --> 01:25:11.080]  А теперь мы такие наш Function берем
[01:25:11.080 --> 01:25:18.080]  и пытаемся в него положить вот этот вот bad.
[01:25:23.080 --> 01:25:25.080]  Положилось.
[01:25:32.080 --> 01:25:35.080]  А, у нас вообще ничего не вышло, да?
[01:25:37.080 --> 01:25:40.080]  Invokeable от ARX.
[01:25:40.080 --> 01:25:42.080]  А, видите, я же не указал.
[01:25:42.080 --> 01:25:45.080]  Да, конечно, оно само не смогло вывести.
[01:25:45.080 --> 01:25:48.080]  In тот ничего.
[01:25:48.080 --> 01:25:51.080]  Вот, пока все здорово.
[01:26:09.080 --> 01:26:11.080]  Точно.
[01:26:11.080 --> 01:26:13.080]  Прикол не сработал.
[01:26:13.080 --> 01:26:15.080]  Прикол должен наоборот работать.
[01:26:15.080 --> 01:26:17.080]  Я вот так хочу.
[01:26:18.080 --> 01:26:20.080]  Да, то есть сама-то функция константная.
[01:26:20.080 --> 01:26:22.080]  Вроде как все ок.
[01:26:22.080 --> 01:26:26.080]  Ну, не можем.
[01:26:26.080 --> 01:26:29.080]  Нет, это тоже фиксится легко.
[01:26:30.080 --> 01:26:35.080]  Это фиксится просто добавлением 200 слов points.
[01:26:35.080 --> 01:26:38.080]  Отсюда констант перейдет?
[01:26:38.080 --> 01:26:40.080]  Да, сейчас все работает.
[01:26:40.080 --> 01:26:42.080]  Вот отсюда конст убираем.
[01:26:42.080 --> 01:26:44.080]  Все тоже работает.
[01:26:44.080 --> 01:26:46.080]  И все тоже работает, да.
[01:26:46.080 --> 01:26:49.080]  Хотя мы просили, чтобы только на конст-объекты позывалось.
[01:26:49.080 --> 01:26:52.080]  Ну, на константный, конечно, ничего не прошли.
[01:26:52.080 --> 01:26:54.080]  Ну, да.
[01:26:54.080 --> 01:26:56.080]  Ну, что?
[01:26:56.080 --> 01:26:58.080]  Ну, да.
[01:26:58.080 --> 01:27:01.080]  В общем, тут начинается некоторая мессия.
[01:27:01.080 --> 01:27:03.080]  Если мы вот так сделаем.
[01:27:03.080 --> 01:27:07.080]  Вот тут все сломается.
[01:27:07.080 --> 01:27:09.080]  Да, конечно.
[01:27:09.080 --> 01:27:13.080]  Потому что мы здесь просто делаем Invoke, а должны бы Invoke от f.
[01:27:13.080 --> 01:27:15.080]  Давайте постепенно это все вылечивать,
[01:27:15.080 --> 01:27:18.080]  потому что мы сейчас, я гарантирую, не напишем идеально.
[01:27:18.080 --> 01:27:20.080]  Ставим Function.
[01:27:20.080 --> 01:27:23.080]  В общем, мы здесь просто делаем Invoke, а должны бы Invoke от f.
[01:27:23.080 --> 01:27:25.080]  Давайте постепенно это все вылечивать,
[01:27:25.080 --> 01:27:27.080]  не напишем идеально. Ставим Function.
[01:27:27.080 --> 01:27:32.080]  Мы просто обозреем некоторые проблемы.
[01:27:40.080 --> 01:27:42.080]  Вот, и теперь, соответственно, начинаются проблемки.
[01:27:42.080 --> 01:27:44.080]  Можем ли мы вообще сделать вот так?
[01:27:55.080 --> 01:27:57.080]  Ну, вот начинаются приколы.
[01:27:57.080 --> 01:28:02.080]  Что нам, по сути, нужно несколько таких функций.
[01:28:09.080 --> 01:28:12.080]  И вот если мы вот так сделаем.
[01:28:13.080 --> 01:28:16.080]  И вот если мы вот так сделаем.
[01:28:27.080 --> 01:28:31.080]  То уже, кажется, все будет работать хорошо у всех кейс.
[01:28:42.080 --> 01:29:02.080]  Ну да, у нас, скорее всего, пока просто call c, call l, call r.
[01:29:13.080 --> 01:29:15.080]  Где вы даете Ref.Qualifier?
[01:29:15.080 --> 01:29:17.080]  Для другого?
[01:29:27.080 --> 01:29:37.080]  Так, и теперь должно следующая штука работать.
[01:29:37.080 --> 01:29:47.080]  Мы должны и вот так, и вот так, и вот так бить наших этих.
[01:29:49.080 --> 01:29:54.080]  И теперь, если мы делаем вот так.
[01:29:59.080 --> 01:30:03.080]  43, да? То есть пришел LV.
[01:30:07.080 --> 01:30:09.080]  Так, конечно же, нужно мурнуть.
[01:30:32.080 --> 01:30:34.080]  42, для какого?
[01:30:34.080 --> 01:30:42.080]  Если добавлю const, то тоже все должно работать.
[01:30:47.080 --> 01:30:58.080]  Вот, и это уже более-менее корректно, как бы, обработка всех кейсов.
[01:30:58.080 --> 01:31:00.080]  Да, вот проблема.
[01:31:00.080 --> 01:31:14.080]  Если нам прислали метод, у которого noexcept поменьше вот здесь,
[01:31:14.080 --> 01:31:22.080]  то очень хотелось бы, чтобы оператор круглые скобки тоже был как бы noexcept,
[01:31:22.080 --> 01:31:24.080]  но я бы не сказал, что проще.
[01:31:30.080 --> 01:31:32.080]  Мы узнаем здесь тип.
[01:31:32.080 --> 01:31:34.080]  Кого?
[01:31:34.080 --> 01:31:36.080]  Ну, кого?
[01:31:36.080 --> 01:31:40.080]  Тип импла. У нас же TypeRager произошел.
[01:31:40.080 --> 01:31:46.080]  Вот, и кажется, это уже то, на что мы не будем пытаться тратить время.
[01:31:46.080 --> 01:31:51.080]  Вместо этого мы откроем такую штуку Function2.
[01:31:51.080 --> 01:31:56.080]  Это замечательная библиотечка, которую вы уже на курсе конкарнси могли видеть.
[01:31:56.080 --> 01:32:05.080]  И среди прочего, оно умеет все эти кейсы обрабатывать.
[01:32:05.080 --> 01:32:10.080]  И они про это пишут.
[01:32:10.080 --> 01:32:26.080]  Я что-то потерял.
[01:32:26.080 --> 01:32:28.080]  Квалифаер.
[01:32:28.080 --> 01:32:30.080]  Да.
[01:32:30.080 --> 01:32:35.080]  Собственно, почти то же самое, что мы и сделали, делают и они.
[01:32:35.080 --> 01:32:39.080]  Если, ну, точнее, они эту информацию все-таки хранят в типе,
[01:32:39.080 --> 01:32:43.080]  нам бы тоже, на самом деле, хотелось в типе хранить, а не динамически.
[01:32:43.080 --> 01:32:45.080]  Вот.
[01:32:45.080 --> 01:32:51.080]  Но с таким дизайном на виртуальных вызовах оно не очень хорошо работает.
[01:32:51.080 --> 01:32:56.080]  Сейчас будет нормальный дизайн, как вы в домашке будете писать, там уже получше.
[01:32:56.080 --> 01:32:57.080]  Да.
[01:32:57.080 --> 01:33:01.080]  Да, соответственно, если тут указано конст, то у него там конст.
[01:33:01.080 --> 01:33:05.080]  Если тут указано болатайл, то у него болатайл.
[01:33:05.080 --> 01:33:09.080]  Ир-вэлью-квалификаторы можно писать, иноэксепты можно писать.
[01:33:09.080 --> 01:33:11.080]  И вообще все здорово.
[01:33:11.080 --> 01:33:13.080]  Да, но только...
[01:33:13.080 --> 01:33:22.080]  Да, вот как тут нуэксепт корректно обрабатывать.
[01:33:22.080 --> 01:33:28.080]  Если мы потребовали нуэксепт среди квалифаеров,
[01:33:28.080 --> 01:33:32.080]  но при этом...
[01:33:38.080 --> 01:33:40.080]  Ну, короче, ладно.
[01:33:40.080 --> 01:33:44.080]  Оно будет проверять статически, когда мы пытаемся запихнуть туда внутрь
[01:33:44.080 --> 01:33:47.080]  лямбда или что-то еще, что там есть нуэксепт.
[01:33:47.080 --> 01:33:54.080]  И если вдруг мы случайно вызвали на пустом функциональном объекте,
[01:33:54.080 --> 01:33:57.080]  то есть когда вот здесь noLptr, грубо говоря,
[01:33:57.080 --> 01:33:59.080]  оператор круглые скобки,
[01:33:59.080 --> 01:34:03.080]  ну вот std function вроде исключение кидает.
[01:34:05.080 --> 01:34:09.080]  Но если мы поместили оператора круглые скобки noexcept, как он кинет исключение?
[01:34:09.080 --> 01:34:13.080]  Поэтому вызывают std abort или std terminate.
[01:34:13.080 --> 01:34:20.080]  Вот, ну в общем, если вы всегда мечтали увидеть идеальную имплементацию std function,
[01:34:20.080 --> 01:34:26.080]  потому что std function вообще ни разу не идеальная на аппаратите,
[01:34:26.080 --> 01:34:33.080]  то вот function2, этот код, я думаю, интересно будет почитать,
[01:34:33.080 --> 01:34:39.080]  а нам надо к более оптимайдженному.
[01:34:39.080 --> 01:34:42.080]  Собственно, виртуальный вызов это, конечно, здорово,
[01:34:42.080 --> 01:34:46.080]  но это вообще не то, что нам хочется, не то, что нам нужно.
[01:34:46.080 --> 01:34:49.080]  Всех, по-моему, все.
[01:34:49.080 --> 01:34:51.080]  Не будет виртуальных вызовов.
[01:34:51.080 --> 01:34:54.080]  Ничего не будет. Никакого праздника.
[01:34:54.080 --> 01:34:57.080]  Начинай с нуля.
[01:34:57.080 --> 01:34:59.080]  Будет следующее.
[01:35:03.080 --> 01:35:05.080]  Ладно, я зря все это стер.
[01:35:05.080 --> 01:35:08.080]  Я думаю, лучше бы оно осталось.
[01:35:10.080 --> 01:35:14.080]  К нему упакуем namespace.
[01:35:22.080 --> 01:35:24.080]  Вот так вот.
[01:35:31.080 --> 01:35:38.080]  А мы теперь будем писать как большие мальчики.
[01:35:39.080 --> 01:35:41.080]  Девочки.
[01:35:42.080 --> 01:35:48.080]  Дея f, это у нас такие будет полноценные функциональные таблиш.
[01:35:48.080 --> 01:35:54.080]  С помощью перегрузки мы вытащим оттуда класс r
[01:35:58.080 --> 01:36:01.080]  и некоторые аргументы.
[01:36:09.080 --> 01:36:13.080]  И хранить мы, соответственно, будем банально...
[01:36:23.080 --> 01:36:25.080]  Такой же синтез?
[01:36:25.080 --> 01:36:27.080]  Нет, никакой.
[01:36:27.080 --> 01:36:29.080]  Не такой.
[01:36:34.080 --> 01:36:36.080]  А, да.
[01:36:36.080 --> 01:36:38.080]  Вот так.
[01:36:38.080 --> 01:36:41.080]  Хранить мы будем буквально этот function pt.
[01:36:49.080 --> 01:36:51.080]  Назовем его call.
[01:36:53.080 --> 01:36:56.080]  Окей, здорово. А где данные?
[01:36:56.080 --> 01:37:00.080]  Если нам прислали лямбду, внутри которой есть какой-то заслаб.
[01:37:00.080 --> 01:37:06.080]  Ну, для этого нам приходится выделить на куче некоторое количество байтиков.
[01:37:06.080 --> 01:37:09.080]  Как бы это лучше сделать?
[01:37:12.080 --> 01:37:14.080]  Да никак это не получится хорошо сделать.
[01:37:14.080 --> 01:37:17.080]  Мы будем это делать вот так.
[01:37:27.080 --> 01:37:31.080]  Нам нужен шаблонный конструктор.
[01:37:36.080 --> 01:37:38.080]  Итак.
[01:38:01.080 --> 01:38:03.080]  Дату мы положим.
[01:38:06.080 --> 01:38:08.080]  F
[01:38:14.080 --> 01:38:16.080]  И на этом устанавливаемся.
[01:38:16.080 --> 01:38:18.080]  Вот такая заготовочка.
[01:38:18.080 --> 01:38:20.080]  Тупая заготовочка, ничего нет.
[01:38:20.080 --> 01:38:25.080]  Просто объект функциональный положили на кучу куда-то дату.
[01:38:25.080 --> 01:38:28.080]  И теперь не знаем, что делать.
[01:38:30.080 --> 01:38:32.080]  Как здесь вызвать диструктор?
[01:38:32.080 --> 01:38:34.080]  Мы же забыли тим.
[01:38:36.080 --> 01:38:38.080]  Ага.
[01:38:41.080 --> 01:38:44.080]  Как здесь вызвать функцию?
[01:38:44.080 --> 01:38:46.080]  Мы же забыли тим.
[01:38:50.080 --> 01:38:52.080]  Внимание от трюков.
[01:38:52.080 --> 01:38:56.080]  Call мы положим в следующую лямбду.
[01:38:58.080 --> 01:39:00.080]  Что не дано?
[01:39:00.080 --> 01:39:02.080]  Так ты же уже все это знаешь.
[01:39:02.080 --> 01:39:04.080]  Ты же точно это видел.
[01:39:04.080 --> 01:39:06.080]  Я уже с ней разбирался.
[01:39:14.080 --> 01:39:16.080]  Причем лямба будет
[01:39:20.080 --> 01:39:22.080]  без захвата.
[01:39:26.080 --> 01:39:29.080]  Иначе как мы положим в этот показатель.
[01:39:30.080 --> 01:39:32.080]  И функцион PTR мы...
[01:39:32.080 --> 01:39:34.080]  Плюс.
[01:39:34.080 --> 01:39:36.080]  А вы не знаете плюс.
[01:39:36.080 --> 01:39:40.080]  Плюс превращает лямбду в указатель на функцию.
[01:39:40.080 --> 01:39:44.080]  Работает только если у лямбы вот здесь в захвате ничего нет.
[01:39:46.080 --> 01:39:48.080]  Мощно, правда?
[01:39:51.080 --> 01:39:53.080]  Внимание от трюков.
[01:39:53.080 --> 01:39:55.080]  Вот этот вот функцион PTR
[01:39:55.080 --> 01:39:57.080]  мы добавим будет звездочку
[01:39:57.080 --> 01:39:59.080]  звездочка помимо args.
[01:40:05.080 --> 01:40:07.080]  И это будет self.
[01:40:09.080 --> 01:40:11.080]  static cast
[01:40:11.080 --> 01:40:13.080]  f
[01:40:15.080 --> 01:40:17.080]  звездочка self
[01:40:27.080 --> 01:40:29.080]  и
[01:40:29.080 --> 01:40:31.080]  и
[01:40:31.080 --> 01:40:33.080]  и
[01:40:33.080 --> 01:40:35.080]  и
[01:40:35.080 --> 01:40:37.080]  и
[01:40:37.080 --> 01:40:39.080]  и
[01:40:39.080 --> 01:40:41.080]  и
[01:40:41.080 --> 01:40:43.080]  и
[01:40:43.080 --> 01:40:45.080]  и
[01:40:45.080 --> 01:40:47.080]  и
[01:40:47.080 --> 01:40:49.080]  и
[01:40:49.080 --> 01:40:51.080]  и
[01:40:51.080 --> 01:40:53.080]  и
[01:40:53.080 --> 01:40:55.080]  и
[01:40:55.080 --> 01:40:57.080]  и
[01:40:57.080 --> 01:40:59.080]  И да, это конечно неправильно.
[01:41:01.080 --> 01:41:05.080]  Вот теперь правильно.
[01:41:13.080 --> 01:41:15.080]  Кажется, это должно работать.
[01:41:17.080 --> 01:41:19.080]  Внимание от трюков.
[01:41:19.080 --> 01:41:21.080]  Вот эта лямба
[01:41:21.080 --> 01:41:23.080]  зависит от вот этого f
[01:41:25.080 --> 01:41:33.440]  при каждом вызове конструктора с разным функтором или лямбда или еще чем-то, вот эта f будет
[01:41:33.440 --> 01:41:41.000]  разная, а значит и лямбда будет разная, в кол будет записаны разные адреса разных функций,
[01:41:41.000 --> 01:41:48.840]  которые уже в свою очередь, каждый из них знает, какая была f, с которой ее сгенерили и туда положили.
[01:41:48.840 --> 01:42:02.360]  И теперь вот здесь мы можем написать просто com data arcs, все.
[01:42:10.760 --> 01:42:12.720]  Ощущайте силу происходящего.
[01:42:18.840 --> 01:42:31.400]  Прошлый раз мы делали TypeRager за счет того, что генерировали наследников интерфейса шаблонами,
[01:42:31.400 --> 01:42:38.880]  которым ко всем можно было через виртуальные функции обращаться одинаковым образом с помощью
[01:42:39.400 --> 01:42:48.880]  на этот раз с помощью шаблонов мы генирием не наследников интерфейса с виртуальным вызовом,
[01:42:48.880 --> 01:43:00.480]  а шаблонные функции или лямбда. Давайте даже чуть по-другому перепишем это. Давайте
[01:43:00.480 --> 01:43:11.680]  заведем функцию. Нет, мы здесь не заведем. Ладно, можем его завести.
[01:43:11.680 --> 01:43:30.160]  Сейчас я просто возьму и вытащу вот эту лямбду в глобальную функцию, чтобы было
[01:43:30.160 --> 01:43:34.560]  чуть понятнее, какого черта происходит. Возможно из-за лямбды все сложнее.
[01:44:00.160 --> 01:44:04.560]  Возможно из-за лямбды все сложнее. Возможно из-за лямбды все сложнее.
[01:44:30.160 --> 01:44:59.400]  Вот так вот. То есть еще раз для каждого такого f мы генерируем свой. Там наверное надо еще
[01:44:59.400 --> 01:45:20.120]  присваивание тоже као с нижней точкой. 200, 60, 60. Наверное паблик сделать все. Вот еще
[01:45:20.120 --> 01:45:27.960]  раз. Для каждого f, который прислали в конструктор, это шаблонный класс, мы генерируем глобальную
[01:45:27.960 --> 01:45:35.960]  функцию као. Что она берет на вход? Некоторые его звездочка, которые кастят к вот этому f,
[01:45:35.960 --> 01:45:41.280]  по которому она сгенерирована, и аргументы, с которыми она вызывает оператор круглой скобки
[01:45:41.280 --> 01:45:48.520]  у вот этого self. Чтобы было чуть более явно, давайте даже вот так напишем стрелка оператор
[01:45:48.520 --> 01:46:02.520]  в глобальной скобке от вот этого вот. Так. Я думаю мы даже это сейчас сможем протестить.
[01:46:02.520 --> 01:46:29.360]  Это получилось. Проверим что за флаг адекватно сработал.
[01:46:29.360 --> 01:46:58.880]  И вызовем f от двух. Да, там типы могли чуть-чуть полететь. Может возвращаемые значения явно
[01:46:58.880 --> 01:47:10.480]  указать. Да, действительно. Лишняя звездочка.
[01:47:10.480 --> 01:47:28.680]  Звездочка, твой звездочка, overloaded.
[01:47:40.480 --> 01:48:01.520]  Короче, у меня ощущение, что беда в том, что вот это деклдайбот авто, это уже какой-то
[01:48:01.520 --> 01:48:11.600]  перебор. Я думаю нам надо по простому сделать просто возвращаемый тип. Вот. Если честно,
[01:48:11.600 --> 01:48:16.080]  я тоже никогда не писал следа function вот этим методом. Я писал немножко другие контейнеры.
[01:48:16.080 --> 01:48:23.440]  Поэтому тут опять может быть мелкие детали, которые лучше всего конечно в библиотеке function2
[01:48:23.440 --> 01:48:28.560]  расписывали. Ну нам главное сейчас понять просто вот этот трюк.
[01:48:53.440 --> 01:49:08.640]  Почему кандидат функции не подошла? Она же подходит. Ну что, надо как-то вот так написать.
[01:49:08.640 --> 01:49:16.920]  Сейчас. Там что-то типа как-то совсем не кастится. Там написано, что function от принимает int,
[01:49:16.920 --> 01:49:26.840]  возвращает int, кастится, принимает твой звездочка int, возвращает int. Здесь у нас
[01:49:26.840 --> 01:49:33.560]  возвращается int, принимается твой звездочка, и еще один int. И здесь у нас.
[01:49:33.560 --> 01:49:51.840]  Возвращается int, принимается int, и будет звездочка есть. Это очень странно. Сейчас там.
[01:49:51.840 --> 01:50:04.560]  Да, и меня это устраивает. А нет, меня это не устраивает.
[01:50:04.560 --> 01:50:20.200]  Здесь обязательно нужно, чтобы без CVREF было, потому что мы указатели просто кастим.
[01:50:20.200 --> 01:50:37.840]  Нет, это не должно быть проблемой. Я сделал инстанциацию функции.
[01:50:37.840 --> 01:50:51.120]  Там какой-то overloaded function type может из-за этого какие-то проблемы.
[01:50:51.120 --> 01:51:14.400]  Очень странно. Давайте попробуем Clang. А это и был Clang. Давайте попробуем v-plus-plus.
[01:51:14.400 --> 01:51:30.400]  Какой он версии? Кажется, это самый свежий. По-моему, еще не выкатил эту историю.
[01:51:30.400 --> 01:51:43.240]  Там же 11.2, самое свежее вроде.
[01:51:43.240 --> 01:52:03.880]  Будем надеяться, что к этой сценам полезнее выдаст сообщение.
[01:52:03.880 --> 01:52:31.560]  Вот это прикол. Как ты создаешь его, вот этот function?
[01:52:31.560 --> 01:52:43.240]  Сейчас, у тебя второй аргумент col это int-wander-sandler.
[01:52:43.240 --> 01:52:49.240]  Второй аргумент col?
[01:52:49.240 --> 01:53:06.920]  Черт, я перевыбедливался. Не нужно ничего forwardить. Нужно просто писать тупой код, пусть копируется, потом все это можно навесить.
[01:53:06.920 --> 01:53:20.600]  Окей, мы справились. Работает ли оно таки? Оно таки работает.
[01:53:20.600 --> 01:53:34.600]  Во-первых, корректно вот этот вот объект захвата лямбда у нас на кучу перенесся с forward, что вообще приятно.
[01:53:34.600 --> 01:53:42.280]  И корректно произошел вызов. Какая-то магия.
[01:53:42.280 --> 01:53:59.080]  Цель TypeRager это забыть тип данных, но запомнить операции, которые можно с ним производить.
[01:53:59.080 --> 01:54:06.120]  Как шаблонами сгенерировать новые операции для каждого типа данных.
[01:54:06.120 --> 01:54:10.040]  Ну, собственно, это и переводит статический полиморфизм динамический.
[01:54:10.040 --> 01:54:17.960]  Раньше у нас было множество разных типов, у каждого из которых свой вызов функции.
[01:54:17.960 --> 01:54:27.160]  А теперь у нас просто множество значений, у которых одинаковый вызов функции, но сама функция runtime значений меняющаяся.
[01:54:27.160 --> 01:54:36.680]  Вот, но мы еще не все объяснили. Вот здесь. Что делать? Да понятно, что делать.
[01:54:36.680 --> 01:54:42.120]  Какая будет звездочка? Вот так, detor.
[01:54:42.120 --> 01:54:54.600]  Конечно, нужно писать не так, а вот так.
[01:54:54.600 --> 01:55:01.160]  Они говорят, что в лесу много скобок. Как это читать?
[01:55:01.160 --> 01:55:05.160]  Против часовой стрелки.
[01:55:05.160 --> 01:55:09.160]  Да, против часовой стрелки поскороли.
[01:55:09.160 --> 01:55:18.120]  Ну, вот нет. Ну, хорошо. Здесь у нас план какой? Запустить detor от data.
[01:55:18.120 --> 01:55:20.120]  Мы закончили.
[01:55:20.120 --> 01:55:26.760]  Мы закончили. А здесь план detor сохранить. Ну, с вашего позволения уже буду объюзить лямбда,
[01:55:26.760 --> 01:55:30.760]  потому что каждый раз выносить вот это вот не хочу.
[01:55:30.760 --> 01:55:34.760]  У нас будет звездочка.
[01:55:48.760 --> 01:55:52.760]  Да, и давайте сохраним
[01:55:52.760 --> 01:56:02.760]  вот этот функциональный тип, потому что мы хотим не воспользоваться, да, все-таки ремонтировать.
[01:56:12.760 --> 01:56:18.760]  Да, плюс просто пишется перед лямбдой и превращает ее в указатель на функцию.
[01:56:18.760 --> 01:56:22.760]  Написать его мы можем только перед лямбдой, где в захвате ничего.
[01:56:22.760 --> 01:56:26.760]  Если в захвате что-то есть, то это более сложная вещь, нежели просто функция.
[01:56:32.760 --> 01:56:36.760]  Таки вот, destructor вызывается.
[01:56:36.760 --> 01:56:40.760]  Наверное, это стоит проверить, как-нибудь хорошо написав тестовый кейс.
[01:56:40.760 --> 01:56:44.760]  А, так у нас еще целых 20 даже.
[01:56:48.760 --> 01:56:50.760]  Напишем tracer.
[01:57:08.760 --> 01:57:14.760]  Думаю, я стану так писать, поэтому все будет в строчку.
[01:57:18.760 --> 01:57:22.760]  Отправочка на будущее.
[01:57:48.760 --> 01:58:02.760]  Все. Все операции, которые только могут производиться с этой штукой, оно трейсит.
[01:58:02.760 --> 01:58:06.760]  Конечно, надо написать.
[01:58:12.760 --> 01:58:14.760]  Все.
[01:58:18.760 --> 01:58:30.760]  Но accept всего лишь значит, делай estate terminate, если вылетело исключение.
[01:58:30.760 --> 01:58:34.760]  Так вот.
[01:58:34.760 --> 01:58:40.760]  А, мне хочется, чтобы оператор углу в скобке был, да.
[01:58:40.760 --> 01:58:46.760]  Что он будет возвращать? Пусть он int возвращает, вперед int.
[01:58:58.760 --> 01:59:00.760]  Да.
[01:59:04.760 --> 01:59:06.760]  Что?
[01:59:06.760 --> 01:59:08.760]  Все нормально.
[01:59:10.760 --> 01:59:14.760]  OK, int положим туда.
[01:59:22.760 --> 01:59:26.760]  Должно 4 вывести, вызывается constructor и destructor.
[01:59:30.760 --> 01:59:36.760]  destructor, move constructor, destructor, destructor.
[01:59:36.760 --> 01:59:42.760]  Ну, в принципе, все правильно, потому что здесь temporary-объект сконструировался.
[01:59:42.760 --> 01:59:50.760]  Этот temporary-объект move-нулся вот здесь.
[01:59:52.760 --> 01:59:56.760]  После этого он удалился.
[01:59:56.760 --> 02:00:00.760]  Я потерял.
[02:00:00.760 --> 02:00:04.760]  После этого temporary уничтожился.
[02:00:04.760 --> 02:00:08.760]  И, наконец, вывели четверку.
[02:00:08.760 --> 02:00:14.760]  И потом вызвался destructor уже все function, который вызвал destructor-tracer.
[02:00:14.760 --> 02:00:16.760]  Все правильно.
[02:00:16.760 --> 02:00:20.760]  Ну, понятное дело, что дальше писать?
[02:00:20.760 --> 02:00:26.760]  Сейчас копии move.
[02:00:26.760 --> 02:00:32.760]  Причем move-ать мы будем из нового звездочка, другой звездочка.
[02:00:32.760 --> 02:00:38.760]  И здесь тоже из нового звездочка, другой звездочка.
[02:00:38.760 --> 02:00:42.760]  Как-то все нормально.
[02:00:42.760 --> 02:00:44.760]  Обычно я хочу на курс.
[02:00:44.760 --> 02:00:46.760]  А что не так?
[02:00:46.760 --> 02:00:56.760]  Как мы будем делать копирование?
[02:01:04.760 --> 02:01:10.760]  Копирование мы будем делать следующим моментом.
[02:01:10.760 --> 02:01:18.760]  Оба статик кастим.
[02:01:24.760 --> 02:01:28.760]  Ну, в принципе, да, в окей статик кастили.
[02:01:28.760 --> 02:01:40.760]  Ну, как бы да, как бы нет, потому что нам мало копий.
[02:01:40.760 --> 02:01:46.760]  Это скорее копий-конструктор.
[02:01:46.760 --> 02:01:54.760]  То есть на самом деле нам нужно уметь в копии-конструкторе.
[02:01:54.760 --> 02:01:58.760]  Ну, давайте здесь напишем.
[02:02:06.760 --> 02:02:08.760]  Так.
[02:02:08.760 --> 02:02:10.760]  О.
[02:02:10.760 --> 02:02:38.760]  Вот так, так сработает.
[02:02:38.760 --> 02:02:42.760]  да, какая общая цель?
[02:02:46.760 --> 02:02:50.760]  цель — вызывать копию констрактора вот этой штуки
[02:02:54.760 --> 02:03:00.760]  и понятное дело, что первым делом мы запустим деструктор нашей даты
[02:03:01.760 --> 02:03:08.760]  а дальше нам как-то нужно получить копию этой даты
[02:03:11.760 --> 02:03:15.760]  да, наверное, мы все-таки будем пользоваться антикипсиктурами
[02:03:15.760 --> 02:03:29.760]  давайте пока просто с копией
[02:03:29.760 --> 02:03:32.760]  просто еще на будущее заметочка, последние 20 минут
[02:03:32.760 --> 02:03:35.760]  наверное, лучше это не досветить
[02:03:35.760 --> 02:03:37.760]  а-а-а
[02:03:42.760 --> 02:03:44.760]  new hook
[02:03:47.760 --> 02:03:50.760]  кстати, cast self
[02:03:50.760 --> 02:04:00.760]  копия, две звездочки, две звездочки
[02:04:00.760 --> 02:04:02.760]  ну и две звездочки
[02:04:13.760 --> 02:04:15.760]  а, это Войдов не исчез, да?
[02:04:15.760 --> 02:04:17.760]  там должен быть звездочка возвращается
[02:04:18.760 --> 02:04:20.760]  вот, и так уже хорошо
[02:04:20.760 --> 02:04:30.760]  теперь мы здесь можем сказать, что дата равно ad-копии
[02:04:30.760 --> 02:04:40.760]  и, соответственно, свой код
[02:04:55.760 --> 02:04:57.760]  ок
[02:05:01.760 --> 02:05:04.760]  давайте попробуем
[02:05:06.760 --> 02:05:08.760]  оператор присваивания
[02:05:08.760 --> 02:05:10.760]  всякие мувы
[02:05:17.760 --> 02:05:20.760]  так, что нам нужно сделать, чтобы...
[02:05:20.760 --> 02:05:23.760]  а, ну, собственно, это я и написал
[02:05:24.760 --> 02:05:26.760]  да
[02:05:27.760 --> 02:05:29.760]  вот
[02:05:29.760 --> 02:05:32.760]  ну, не очень оригинально получилось, да?
[02:05:32.760 --> 02:05:35.760]  ну, на самом деле тут, конечно, куча оговорок
[02:05:35.760 --> 02:05:38.760]  вот тут, ну, ПТР бывает
[02:05:43.760 --> 02:05:46.760]  тут миллион разных оговорочек
[02:05:46.760 --> 02:05:50.760]  что потом вот у этого адера тоже замылить нужно
[02:05:50.760 --> 02:05:53.760]  а, нет, если это копия, то замылять ему ничего не нужно
[02:05:53.760 --> 02:05:56.760]  но при муве таки нужно
[02:05:56.760 --> 02:05:58.760]  вот
[02:05:59.760 --> 02:06:01.760]  в общем, весело
[02:06:01.760 --> 02:06:07.760]  а вот насчет мува, на самом деле, кажется, что даже не нужно вот такой вот метод для мува заводить, да?
[02:06:07.760 --> 02:06:11.760]  мы же просто можем дату мугнуть, все
[02:06:11.760 --> 02:06:13.760]  вот
[02:06:13.760 --> 02:06:16.760]  а теперь начинается гиралаш
[02:06:20.760 --> 02:06:23.760]  это медленно
[02:06:23.760 --> 02:06:28.760]  вот это сейчас, типа, не сильно круче, чем у нас там было с этими виртуальными вызовами
[02:06:28.760 --> 02:06:31.760]  ну ладно, это чуть быстрее
[02:06:35.760 --> 02:06:37.760]  ну да
[02:06:39.760 --> 02:06:41.760]  можно быстрее
[02:06:41.760 --> 02:06:43.760]  большая часть лямб
[02:06:43.760 --> 02:06:45.760]  она что захватывает?
[02:06:45.760 --> 02:06:47.760]  именно так
[02:06:47.760 --> 02:06:51.760]  большая часть лямб, она выглядит как-то вот как у нас здесь было раньше
[02:06:51.760 --> 02:06:54.760]  да, типа, в квадратах это и вот так
[02:06:54.760 --> 02:06:57.760]  то есть мы захватили все подряд по ссылке
[02:06:57.760 --> 02:07:00.760]  ну ссылка это там, типа, сколько?
[02:07:00.760 --> 02:07:03.760]  64 битика, да? 8 байтиков
[02:07:06.760 --> 02:07:09.760]  ну и переменных локальных у нас обычно тоже не очень много
[02:07:09.760 --> 02:07:14.760]  соответственно, суммарно, это вообще копейки
[02:07:14.760 --> 02:07:19.760]  а если компилятор умный, то он еще и как-то хитро вот этот общий захват всего подряд может соптимизироваться
[02:07:19.760 --> 02:07:20.760]  да, что?
[02:07:20.760 --> 02:07:22.760]  он же знает статические офсеты
[02:07:22.760 --> 02:07:24.760]  ну хотя не уверен, что он так делает
[02:07:24.760 --> 02:07:31.760]  в всяком случае, большая часть лямб, с которыми мы работаем, они в захвате хранят очень мало данных
[02:07:31.760 --> 02:07:38.760]  а мы для вот этого маленького кусочка данных, которое меньше 64
[02:07:38.760 --> 02:07:41.760]  или меньше чем 64 байтика может быть
[02:07:41.760 --> 02:07:44.760]  мы ради них делаем тут мю
[02:07:44.760 --> 02:07:47.760]  не камельфо
[02:07:47.760 --> 02:07:53.760]  поэтому давайте ахитрить
[02:07:53.760 --> 02:08:01.760]  давайте если у нас вот тут вот
[02:08:01.760 --> 02:08:04.760]  вернее не так
[02:08:04.760 --> 02:08:06.760]  проще написать, чем говорить
[02:08:06.760 --> 02:08:10.760]  стд variant
[02:08:10.760 --> 02:08:19.760]  и variant у нас будет из-за, грубо говоря, массива байтиков
[02:08:19.760 --> 02:08:21.760]  и его и звездочка
[02:08:21.760 --> 02:08:24.760]  а variant он не делает мю внутри себя?
[02:08:24.760 --> 02:08:26.760]  или он через union?
[02:08:26.760 --> 02:08:29.760]  в этом смысл variant
[02:08:29.760 --> 02:08:33.760]  variant это по сути unit
[02:08:33.760 --> 02:08:38.760]  то бишь он выделяет не на кучу, просто его размер
[02:08:38.760 --> 02:08:43.760]  размер variant равен максимуму из размеров его шаблонных аргументов
[02:08:43.760 --> 02:08:47.760]  и плюс 1 обычно, не факт
[02:08:47.760 --> 02:08:49.760]  там бывает оптимация
[02:08:49.760 --> 02:08:53.760]  может на стейке, а не на кучу?
[02:08:53.760 --> 02:08:57.760]  неправильно говорить, что variant хранится на стейке
[02:08:57.760 --> 02:08:59.760]  мы же хотим на стейке
[02:08:59.760 --> 02:09:01.760]  потому что никто не хочет
[02:09:01.760 --> 02:09:05.760]  нет такого противопоставления, как на стейке или на куче
[02:09:05.760 --> 02:09:08.760]  есть inline, есть на куче
[02:09:08.760 --> 02:09:14.760]  потому что никто не мешает все равно написать variant, который будет выделен на кучу
[02:09:14.760 --> 02:09:18.760]  и получается, что variant на куче хранится?
[02:09:18.760 --> 02:09:20.760]  нет, конечно
[02:09:20.760 --> 02:09:26.760]  речь о том, что variant сам к себе хранит без indirection, без выделений на куче
[02:09:26.760 --> 02:09:30.760]  в своей памяти
[02:09:30.760 --> 02:09:35.760]  не тянет меня язык сказать, что это и называется хранение на стейке
[02:09:35.760 --> 02:09:39.760]  наверное проще говорить, что variant хранится на стейке
[02:09:39.760 --> 02:09:42.760]  следует сторожевая хранительность
[02:09:42.760 --> 02:09:46.760]  следует сторожевая хранительность, да, это модные слова
[02:09:46.760 --> 02:09:48.760]  вот
[02:09:50.760 --> 02:09:52.760]  соответственно
[02:09:52.760 --> 02:09:55.760]  какие костыли предлагаются впилить?
[02:09:55.760 --> 02:09:58.760]  да, вот здесь написать
[02:09:58.760 --> 02:10:00.760]  size of f
[02:10:00.760 --> 02:10:02.760]  size of f
[02:10:02.760 --> 02:10:04.760]  size of f
[02:10:04.760 --> 02:10:06.760]  наверное func, да
[02:10:06.760 --> 02:10:08.760]  все-таки
[02:10:10.760 --> 02:10:12.760]  меньше
[02:10:12.760 --> 02:10:14.760]  давайте заведем
[02:10:21.760 --> 02:10:23.760]  такой вот констант
[02:10:25.760 --> 02:10:33.760]  и предлагается, если размер вот этого объекта, который мы сюда захватываем меньше этой константы
[02:10:33.760 --> 02:10:37.760]  то заталкиваясь все вот в такой вот array чариков
[02:10:37.760 --> 02:10:41.760]  а иначе действовать как раньше и выделять на куче
[02:10:41.760 --> 02:10:47.760]  обратите внимание, что теперь придется добавить немало костылей
[02:10:47.760 --> 02:10:51.760]  потому что во всех и копии
[02:10:51.760 --> 02:10:53.760]  и коле
[02:10:53.760 --> 02:10:56.760]  и деструкторе, и вообще везде
[02:10:56.760 --> 02:10:58.760]  придется делать что-то странное теперь
[02:10:58.760 --> 02:11:04.760]  например, в деструкторе, если вы хранили вот в этой вот онлайновой памяти свой объект
[02:11:04.760 --> 02:11:07.760]  придется теперь не просто там звать delete
[02:11:07.760 --> 02:11:10.760]  а придется звать деструктора
[02:11:10.760 --> 02:11:13.760]  по вот этому вот адресу
[02:11:13.760 --> 02:11:16.760]  и все, и ничего не деликтуется
[02:11:16.760 --> 02:11:22.760]  ну и примерно такие же выкрутасы со всеми остальными вещами
[02:11:22.760 --> 02:11:29.760]  если, например, вы хотите сделать копии
[02:11:29.760 --> 02:11:32.760]  то придется
[02:11:32.760 --> 02:11:37.760]  вместо того, чтобы там просто возвращать new func
[02:11:37.760 --> 02:11:40.760]  придется в...
[02:11:40.760 --> 02:11:45.760]  да, такая сигнатура копии не подойдет, какая подойдет, вы дома подумайте
[02:11:45.760 --> 02:11:48.760]  ну не сложно, да
[02:11:48.760 --> 02:11:53.760]  вам придется в копии передать адрес вот этого буфера
[02:11:53.760 --> 02:11:57.760]  и в нем использовать placement new
[02:11:57.760 --> 02:12:02.760]  ну, placement new для тех, кто впервые слышит
[02:12:02.760 --> 02:12:08.760]  пусть у нас есть какой-то датабуфер на много данных
[02:12:08.760 --> 02:12:13.760]  оказывается, мы можем взять
[02:12:13.760 --> 02:12:18.760]  и прямо внутри этого буфера
[02:12:18.760 --> 02:12:23.760]  инициализировать какой-то тит
[02:12:23.760 --> 02:12:28.760]  я не знаю, например, func
[02:12:28.760 --> 02:12:33.760]  и туда как бы
[02:12:33.760 --> 02:12:37.760]  вот, ну только вместо этого датабуфера
[02:12:37.760 --> 02:12:42.760]  у вас, конечно, должен быть корректно использоваться вот этот
[02:12:42.760 --> 02:12:46.760]  ну и вот, собственно, placement new это
[02:12:46.760 --> 02:12:51.760]  такой вариант оператора new, у которого в скобках потом указывается
[02:12:51.760 --> 02:12:55.760]  указатель, в какой памяти конструировать объект
[02:12:55.760 --> 02:12:58.760]  то есть он не выделяет ничего на куче
[02:12:58.760 --> 02:13:02.760]  это просто запуск конструктора на конкретной памяти
[02:13:02.760 --> 02:13:07.760]  и, соответственно, это может быть копи-конструктор, мув-конструктор, что угодно
[02:13:07.760 --> 02:13:12.760]  вот, соответственно, все кейсы вам придется отработать
[02:13:21.760 --> 02:13:24.760]  да, насчет прикольных методов STD-lib
[02:13:24.760 --> 02:13:27.760]  вот это вот у вас может сломаться
[02:13:27.760 --> 02:13:30.760]  просто если вот так делать, STD-ray чариков или
[02:13:30.760 --> 02:13:33.760]  вообще, конечно, лучше в двадцатых плюсах STD-byte использовать
[02:13:33.760 --> 02:13:36.760]  специальный тип данных для byte'иков
[02:13:36.760 --> 02:13:41.760]  то есть, ну как сказать, просто массив произвольных byte'иков
[02:13:41.760 --> 02:13:43.760]  не понятно каких
[02:13:43.760 --> 02:13:46.760]  но в каких случаях это сломается?
[02:13:46.760 --> 02:13:49.760]  вот бывают такие объекты
[02:13:49.760 --> 02:13:53.760]  которые требуют, чтобы они были выровнены в памяти
[02:13:53.760 --> 02:13:57.760]  кто может придумать пример такого объекта?
[02:13:57.760 --> 02:14:00.760]  не обязательно колобом
[02:14:00.760 --> 02:14:03.760]  потому что
[02:14:03.760 --> 02:14:06.760]  ну какие-то векторных операции там нужно, чтобы...
[02:14:06.760 --> 02:14:08.760]  да, вот оно самое
[02:14:08.760 --> 02:14:11.760]  какие-нибудь интриги, векторные операции, Синды
[02:14:11.760 --> 02:14:16.760]  они требуют выравнивания, соответственно, данные, которые мы храним и перекидываем куда-либо
[02:14:16.760 --> 02:14:18.760]  должны быть выровнены
[02:14:18.760 --> 02:14:21.760]  ну и как бы выразить это, если вы хотите
[02:14:21.760 --> 02:14:24.760]  то есть, если вы хотите выразить это
[02:14:24.760 --> 02:14:25.760]  куда-либо
[02:14:25.760 --> 02:14:27.760]  должны быть выровнены
[02:14:27.760 --> 02:14:30.760]  ну и, конечно, обычные не просто массивы флотов передают
[02:14:30.760 --> 02:14:33.760]  создают специальную структурку
[02:14:36.760 --> 02:14:39.760]  в которую уже хранится там
[02:14:39.760 --> 02:14:42.760]  четыре флота, не знаю
[02:14:42.760 --> 02:14:45.760]  давайте Вех-4 назовём
[02:14:47.760 --> 02:14:50.760]  и где-то здесь пишут
[02:14:50.760 --> 02:14:53.760]  align s
[02:14:54.760 --> 02:14:57.760]  и 4 на...
[02:14:57.760 --> 02:15:00.760]  по-моему, да, 4 на size of float
[02:15:00.760 --> 02:15:03.760]  что не так?
[02:15:07.760 --> 02:15:10.760]  да, я-то не помню, где эти аттребуты написать
[02:15:15.760 --> 02:15:18.760]  о, вот так вот, да
[02:15:18.760 --> 02:15:21.760]  то есть мы теперь потребовали, чтобы на самом деле везде в плюсах
[02:15:21.760 --> 02:15:24.760]  где используется этот тип Вех-4
[02:15:24.760 --> 02:15:27.760]  его адрес был кратен 16
[02:15:27.760 --> 02:15:30.760]  то есть он никогда не может лежать
[02:15:30.760 --> 02:15:33.760]  по адресу там
[02:15:33.760 --> 02:15:36.760]  миллион-миллионов или плохо
[02:15:36.760 --> 02:15:39.760]  ну вы поняли, да?
[02:15:39.760 --> 02:15:42.760]  остаток отделения адреса на 16 всегда был
[02:15:42.760 --> 02:15:45.760]  даже если вы на куче выделяете
[02:15:45.760 --> 02:15:48.760]  оператор в неё это будет уважать вот это вот требование align s
[02:15:48.760 --> 02:15:51.760]  и там всякие выделения на стреке
[02:15:51.760 --> 02:15:54.760]  тоже будут это уважать, если нужно будут
[02:15:54.760 --> 02:15:57.760]  пэдинги и выравнивания делаться
[02:15:57.760 --> 02:16:00.760]  а вот у нас это не уважается
[02:16:00.760 --> 02:16:03.760]  и как-то я использовал библиотеку айген, которая очень сильно
[02:16:03.760 --> 02:16:06.760]  объюзит интринзики вот такие штуки
[02:16:06.760 --> 02:16:09.760]  и если вы нарушите этот контракт с выравниванием
[02:16:09.760 --> 02:16:12.760]  вы получите такую больную ошибку
[02:16:12.760 --> 02:16:15.760]  в которую дважды только можно молитвить
[02:16:16.760 --> 02:16:19.760]  смотришь код, меняешь, что попало
[02:16:19.760 --> 02:16:22.760]  и молишься, что оно исправится
[02:16:22.760 --> 02:16:25.760]  там почему невозможно догадаться
[02:16:25.760 --> 02:16:28.760]  из-за чего оно именно так сломалось
[02:16:28.760 --> 02:16:31.760]  да, в рентайме конечно
[02:16:31.760 --> 02:16:34.760]  то есть в рентайме внезапно получается секвел
[02:16:34.760 --> 02:16:37.760]  там где он физически не мог получиться
[02:16:37.760 --> 02:16:40.760]  в стекстрейсе нет абсолютно ничего
[02:16:40.760 --> 02:16:43.760]  под дебаг режимом запускаешь секвел
[02:16:43.760 --> 02:16:46.760]  в общем грустно
[02:16:46.760 --> 02:16:49.760]  поэтому std-rate и std-bytes мы используем только чтобы
[02:16:49.760 --> 02:16:52.760]  передавать какие-то сырые данные, которые не плюсовые структуры
[02:16:52.760 --> 02:16:55.760]  если вы по сети что-то перекачиваете
[02:16:55.760 --> 02:16:58.760]  подобные вещи, вот это как раз
[02:16:58.760 --> 02:17:01.760]  а когда вы собираетесь в каком-то буфере
[02:17:01.760 --> 02:17:04.760]  хранить структуры плюсов с помощью
[02:17:04.760 --> 02:17:07.760]  оператора new, вы должны использовать
[02:17:07.760 --> 02:17:10.760]  std-alignet storage
[02:17:10.760 --> 02:17:13.760]  std-alignet storage
[02:17:31.760 --> 02:17:34.760]  просто alignet storage
[02:17:34.760 --> 02:17:37.760]  он принимает size
[02:17:37.760 --> 02:17:40.760]  и alignment
[02:17:40.760 --> 02:17:43.760]  который мы конечно же не знаем
[02:17:43.760 --> 02:17:46.760]  у кого?
[02:17:46.760 --> 02:17:49.760]  у кого ты собрался спрашивать align of?
[02:17:49.760 --> 02:17:52.760]  f?
[02:17:52.760 --> 02:17:55.760]  соответственно здесь начинается некоторая беда
[02:17:55.760 --> 02:17:58.760]  поэтому мы будем использовать
[02:17:58.760 --> 02:18:01.760]  стд-alignet storage
[02:18:01.760 --> 02:18:04.760]  стд-alignet storage
[02:18:04.760 --> 02:18:07.760]  начинается некоторая беда
[02:18:07.760 --> 02:18:10.760]  поэтому, ну да
[02:18:10.760 --> 02:18:13.760]  я не помню как он пишется
[02:18:25.760 --> 02:18:28.760]  а там же max-align вроде для
[02:18:28.760 --> 02:18:31.760]  дефолтных типов
[02:18:34.760 --> 02:18:37.760]  в данном не подходит
[02:18:37.760 --> 02:18:40.760]  ну вот тут уже начинаются такие махания руками
[02:18:40.760 --> 02:18:43.760]  что типа, ну вот столько, наверное хватит
[02:18:43.760 --> 02:18:46.760]  давайте столько бахнем и все будет хорошо
[02:18:46.760 --> 02:18:49.760]  можно ассерт добавить
[02:18:49.760 --> 02:18:52.760]  да, мы можем
[02:18:52.760 --> 02:18:55.760]  вообще размер кашлини обычно
[02:18:55.760 --> 02:18:58.760]  точно всем хватит
[02:18:58.760 --> 02:19:01.760]  можно сказать, что если у нас не такой align, то делаем new
[02:19:01.760 --> 02:19:04.760]  small-buffer это на самом деле должен быть размер кашлиний
[02:19:04.760 --> 02:19:07.760]  минус вот эти данные
[02:19:07.760 --> 02:19:10.760]  ну и здесь можем
[02:19:10.760 --> 02:19:13.760]  давайте просто вот так бахнем
[02:19:13.760 --> 02:19:16.760]  собственно когда мы будем инстанцировать конструктор
[02:19:16.760 --> 02:19:19.760]  мы можем сделать статик ассерт
[02:19:19.760 --> 02:19:22.760]  на то, что
[02:19:22.760 --> 02:19:25.760]  ну ладно
[02:19:25.760 --> 02:19:28.760]  а почему new не вызывать в этом случае?
[02:19:28.760 --> 02:19:31.760]  почему не вызывать new обычный, когда мы делаем small-buffer?
[02:19:31.760 --> 02:19:34.760]  нет, когда у нас align неподходящий
[02:19:34.760 --> 02:19:37.760]  можно, можно
[02:19:37.760 --> 02:19:40.760]  это хорошая идея, кстати
[02:19:40.760 --> 02:19:43.760]  ну это очень сложно представить себе тип
[02:19:43.760 --> 02:19:46.760]  который, да, давайте тогда скажем
[02:19:46.760 --> 02:19:49.760]  что размер меньше small-buffer size
[02:19:49.760 --> 02:19:52.760]  и align of
[02:19:52.760 --> 02:19:55.760]  func
[02:19:55.760 --> 02:19:58.760]  что должно произойти?
[02:19:58.760 --> 02:20:01.760]  нет, делимость должна быть
[02:20:01.760 --> 02:20:04.760]  там всегда степень двойки
[02:20:04.760 --> 02:20:07.760]  а align of
[02:20:07.760 --> 02:20:10.760]  гарантирована степень двойки?
[02:20:10.760 --> 02:20:13.760]  там всегда align степень двойки
[02:20:13.760 --> 02:20:16.760]  окей, здорово
[02:20:16.760 --> 02:20:19.760]  вот видите
[02:20:19.760 --> 02:20:22.760]  давайте вот так
[02:20:25.760 --> 02:20:28.760]  а ладно, за то, что мы здесь ничего не написали
[02:20:28.760 --> 02:20:31.760]  давайте напишем
[02:20:31.760 --> 02:20:34.760]  да, нам нужно нашему варианту data
[02:20:34.760 --> 02:20:37.760]  на самом деле я предлагаю
[02:20:37.760 --> 02:20:40.760]  еще один вариант добавить std monostate
[02:20:40.760 --> 02:20:43.760]  который, да, на случай, когда у нас ничего
[02:20:43.760 --> 02:20:46.760]  если он первый
[02:20:46.760 --> 02:20:49.760]  в перечислении вариантов
[02:20:49.760 --> 02:20:52.760]  то по дефолту именно он будет сидеть
[02:20:52.760 --> 02:20:55.760]  нам нужно сказать data
[02:20:55.760 --> 02:20:58.760]  как его привлечь?
[02:20:58.760 --> 02:21:01.760]  наверное просто emplace
[02:21:17.760 --> 02:21:20.760]  я, если честно, не забыл
[02:21:20.760 --> 02:21:23.760]  я вроде сработал
[02:21:23.760 --> 02:21:26.760]  то есть мы сейчас emplace или default на конструируемый
[02:21:26.760 --> 02:21:29.760]  align storage, но он ничего не делает, он пустой
[02:21:29.760 --> 02:21:32.760]  и там ничего не происходит
[02:21:32.760 --> 02:21:35.760]  теперь мы можем делать сюда target по индексу 1
[02:21:35.760 --> 02:21:38.760]  вроде вот так
[02:21:38.760 --> 02:21:41.760]  типа просто вот так
[02:21:41.760 --> 02:21:44.760]  оно вроде должно работать
[02:21:44.760 --> 02:21:47.760]  я надеюсь, по крайней мере
[02:21:47.760 --> 02:21:50.760]  да
[02:21:50.760 --> 02:21:53.760]  теперь мы можем взять этот адрес
[02:21:53.760 --> 02:21:56.760]  и вызвать new туда placement
[02:21:56.760 --> 02:21:59.760]  func от forward
[02:21:59.760 --> 02:22:02.760]  f of f
[02:22:02.760 --> 02:22:05.760]  красота
[02:22:05.760 --> 02:22:08.760]  оно все равно не перестало жаловаться
[02:22:08.760 --> 02:22:11.760]  но вот точные детали
[02:22:11.760 --> 02:22:14.760]  как это подстроить
[02:22:15.760 --> 02:22:18.760]  нет, в стандарте не надо смотреть
[02:22:18.760 --> 02:22:21.760]  потому что там косяки
[02:22:21.760 --> 02:22:24.760]  скорее всего там действительно косяки
[02:22:24.760 --> 02:22:27.760]  с учетом того, сколько косяков STD function просто
[02:22:27.760 --> 02:22:30.760]  я не удивлюсь, если и с этим
[02:22:30.760 --> 02:22:33.760]  проравнивание возможно
[02:22:33.760 --> 02:22:36.760]  стандарт сам почитать, да
[02:22:36.760 --> 02:22:39.760]  а стандартные библиотеки смотреть реализацию не стоит
[02:22:39.760 --> 02:22:42.760]  вот эти детали и размеры предлагаю с function2
[02:22:42.760 --> 02:22:45.760]  просто взять целиком
[02:22:45.760 --> 02:22:48.760]  собственно как-то в целом так
[02:22:48.760 --> 02:22:51.760]  теперь вопрос
[02:22:51.760 --> 02:22:54.760]  ничего ли я вам не забыл рассказать
[02:22:54.760 --> 02:22:57.760]  представьте, что вы это прямо сейчас пишете
[02:22:57.760 --> 02:23:00.760]  какие у вас могут быть вопросы
[02:23:03.760 --> 02:23:06.760]  да, ну и вообще нет
[02:23:06.760 --> 02:23:09.760]  там в задании не требуется callable
[02:23:09.760 --> 02:23:12.760]  мы можем даже прямо сейчас
[02:23:12.760 --> 02:23:15.760]  открыть function2
[02:23:15.760 --> 02:23:18.760]  и посмотреть, например
[02:23:21.760 --> 02:23:24.760]  что смотреть
[02:23:28.760 --> 02:23:31.760]  смотрите, как они делают
[02:23:31.760 --> 02:23:34.760]  разные функции
[02:23:34.760 --> 02:23:37.760]  у них просто один и тот же functionbase, который кастомизирован
[02:23:37.760 --> 02:23:40.760]  с помощью каких-то флажков
[02:24:01.760 --> 02:24:04.760]  дожди, я не увидел
[02:24:05.760 --> 02:24:08.760]  покажи еще раз
[02:24:16.760 --> 02:24:19.760]  в полисе бейс дизайн
[02:24:19.760 --> 02:24:22.760]  про это я тоже хочу рассказать
[02:24:22.760 --> 02:24:25.760]  что мы Александреску догоняли
[02:24:25.760 --> 02:24:28.760]  да, да, да, не подведем мы Александреску
[02:24:28.760 --> 02:24:31.760]  нужна
[02:24:31.760 --> 02:24:34.760]  class function
[02:24:37.760 --> 02:24:40.760]  вот что я забыл
[02:24:40.760 --> 02:24:43.760]  так, смотрите
[02:24:43.760 --> 02:24:46.760]  здесь у нас десяток каких-то разных указателей
[02:24:46.760 --> 02:24:49.760]  неудобно, давайте все это в одну структуру объединим
[02:24:52.760 --> 02:24:55.760]  ну по сути ровно это и будет происходить
[02:24:55.760 --> 02:24:58.760]  структурка
[02:25:01.760 --> 02:25:04.760]  птр
[02:25:04.760 --> 02:25:07.760]  где можно
[02:25:07.760 --> 02:25:10.760]  давайте как у них
[02:25:10.760 --> 02:25:13.760]  in walk table
[02:25:13.760 --> 02:25:16.760]  куда мы перенесем вот этих всех бравых ребят
[02:25:17.760 --> 02:25:20.760]  ну
[02:25:20.760 --> 02:25:23.760]  с colt птр немножко неприятно
[02:25:23.760 --> 02:25:26.760]  давайте пока оставим
[02:25:26.760 --> 02:25:29.760]  но в задании вам хватит просто вот так вот
[02:25:29.760 --> 02:25:32.760]  in walk table
[02:25:32.760 --> 02:25:35.760]  который у нас будет храниться
[02:25:35.760 --> 02:25:38.760]  такие указатели
[02:25:46.760 --> 02:25:49.760]  в общем да, здесь можно добавить указатель
[02:25:49.760 --> 02:25:52.760]  в in walk table
[02:25:52.760 --> 02:25:55.760]  но тогда у нас будет два indirection
[02:25:55.760 --> 02:25:58.760]  ну и вот здесь
[02:25:58.760 --> 02:26:01.760]  мы можем добавить
[02:26:01.760 --> 02:26:04.760]  в таблику
[02:26:04.760 --> 02:26:07.760]  в таблику
[02:26:07.760 --> 02:26:10.760]  в таблику
[02:26:10.760 --> 02:26:13.760]  в таблику
[02:26:13.760 --> 02:26:16.760]  но тогда у нас будет 2 indirection
[02:26:16.760 --> 02:26:19.760]  нам сначала разаменовать вот этот указатель нужно
[02:26:19.760 --> 02:26:22.760]  а потом разаменовать указатель функции
[02:26:22.760 --> 02:26:25.760]  это не очень приятно
[02:26:25.760 --> 02:26:28.760]  можно так, там есть разные хаки
[02:26:28.760 --> 02:26:31.760]  не зря эта библиотека такая сложная
[02:26:31.760 --> 02:26:34.760]  тут много разных хаков, которые нужно все учесть
[02:26:34.760 --> 02:26:37.760]  как-то заюзать и чтоб все было круто
[02:26:37.760 --> 02:26:59.760]  Кажется, они просто к ней наследуются. Можно вот так сделать, но давайте просто вот так сохраним и более того, да не более того, все. Давайте просто вот так на этом это оставим.
[02:26:59.760 --> 02:27:16.760]  По-моему, тут еще есть некоторое количество антимайзов, которые я уже как-то не успеваю забывать. Возможно, я мог меньше деталей и больше впихнуть, но я рекомендую попытаться почитать этот код.
[02:27:16.760 --> 02:27:30.760]  Пусть даже это будет для вас первый опыт чтения сложного шаблонного мета кода, начиная с чего-то надо. Уж очень хороша эта библиотека.
[02:27:30.760 --> 02:27:38.760]  Вот. Ничего бы не забыли ли.
[02:27:38.760 --> 02:27:59.760]  Тут просто еще один хитрый слой indirection использовать. Вот тут некоторые объекты рейжеров, которые как бы в полисе Baste умеют генерить вот эти вот таблички с type rager.
[02:27:59.760 --> 02:28:14.760]  То есть они как бы вот эту табличку разных конструкторов, деструкторов или операторов вызова или еще чего-либо тоже сделали метапрожный шаблонный, чтобы совсем улететь на Луну.
[02:28:14.760 --> 02:28:22.760]  Это, конечно, усложняет все дело.
[02:28:22.760 --> 02:28:26.760]  Класс. Рейжер, вот.
[02:28:26.760 --> 02:28:41.760]  Ну да, они изобрели VTable, потому что если вы задумаетесь глубоко и хорошо, вот эта штука – это VTable.
[02:28:41.760 --> 02:28:51.760]  И чем наше решение отличается вот текущее от решения на виртуальных функциях? Вот эти.
[02:28:51.760 --> 02:28:56.760]  Нет, нет, нет. Мы убрали здесь звездочку.
[02:28:56.760 --> 02:29:02.760]  Ну, то есть что хранится в классе с виртуальными функциями – указатель на виртуальную таблицу.
[02:29:02.760 --> 02:29:12.760]  А вот эту саму таблицу, если мы указателем собираемся ее хранить, можем ее объявить статической вот здесь вот.
[02:29:12.760 --> 02:29:21.760]  Соответственно, для каждого шаблонного аргумента будет своя такая статическая переменная сгенерена, и мы будем прокидывать указатель на нее.
[02:29:21.760 --> 02:29:27.760]  И вот тогда мы полностью переизобрели виртуальные функции.
[02:29:27.760 --> 02:29:37.760]  Если сделать вот так, то мы сделали чуть более оптимизировано, чем виртуальные функции, потому что всего за один indirection проходим, а не за два.
[02:29:37.760 --> 02:29:42.760]  И работает это действительно быстрее. Но памяти ждет больше.
[02:29:42.760 --> 02:29:46.760]  Вот, в общем, давайте на этом закончим.
[02:29:47.760 --> 02:29:55.760]  Вот этот весь месивный код я, конечно, заканчу сейчас, но зачем?
[02:29:55.760 --> 02:30:12.760]  Так, мы здесь, мы здесь.
[02:30:12.760 --> 02:30:15.760]  Вот, может, и все.
[02:30:42.760 --> 02:31:05.760]  Ура, все, у вас должен быть вот этот код.
[02:31:05.760 --> 02:31:11.760]  Он такой сунгуртный, но на правильные идеи по решению ДЗ должен натолкнуть.
[02:31:11.760 --> 02:31:14.760]  А выложу его, надеюсь, сегодня.
[02:31:14.760 --> 02:31:17.760]  Я хотел еще одну дозу впихнуть по дайп-листам.
[02:31:17.760 --> 02:31:23.760]  Помните, я говорил, чтобы посортировать, дай к чиплам, вернее, посортировать их.
[02:31:23.760 --> 02:31:28.760]  Такое несложное, надеюсь, чисто позапонить.
[02:31:28.760 --> 02:31:31.760]  Вот, я все еще планирую его сделать, но, надеюсь, его вывали.
[02:31:31.760 --> 02:31:37.760]  А вот поэтому вот прямо сегодня, видимо, уже и выложу сразу.
[02:31:37.760 --> 02:31:39.760]  Оно уже готово.
[02:31:39.760 --> 02:31:42.760]  Все, если никаких вопросов нет, всем спасибо.
[02:31:42.760 --> 02:31:43.760]  Всем стоп.
