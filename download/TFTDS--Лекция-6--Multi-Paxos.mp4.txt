[00:00.000 --> 00:10.280]  Привет! Сегодня мы продолжаем говорить про задачу консенсуса, про репликацию автомата,
[00:10.280 --> 00:18.040]  и как обычно вспоминаем, на чем мы остановились в прошлый раз. Итак, мы с вами решаем задачу
[00:18.040 --> 00:26.640]  репликации произвольного автомата. Мы ее решаем с помощью примитива под названием atomic broadcast.
[00:26.640 --> 00:41.760]  Мы сказали, возьмем наш автомат, поместим его копию на каждую реплику. Когда какой-то
[00:41.760 --> 00:46.000]  узел системы будет получать команду от пользователя, он будет с помощью atomic broadcast
[00:46.000 --> 00:50.680]  раздавать ее всем остальным репликам. Ну и каждая реплика в силу свойств atomic broadcast или
[00:50.680 --> 00:55.120]  totary order broadcast будет получать эти команды в одном и том же порядке. Она будет их применять,
[00:55.120 --> 01:00.280]  и когда сам координатор получает команду, которую он сам же отправил через atomic broadcast,
[01:00.280 --> 01:07.400]  он ее применяет и отдает ответ пользователя. Эту задачу мы в свою очередь свели к задаче консенсуса.
[01:07.400 --> 01:19.880]  Ну, там было довольно ясно, что это две примерно одинаковые задачи, и в позапрошлый раз мы с вами
[01:19.880 --> 01:26.840]  разбирались, а какие же ограничения на задачи консенсуса действуют, какие же там есть врожденные
[01:26.840 --> 01:32.800]  невозможности, скажем так. И мы выяснили, что есть, поскольку задачу консенсуса необходимо решить,
[01:32.800 --> 01:37.200]  чтобы сделать atomic broadcast, а atomic broadcast необходим для любого нетривиального RSM,
[01:37.200 --> 01:44.840]  мы разбирались задачи консенсуса и выяснили, что во-первых, в любом решении задачи консенсуса
[01:44.840 --> 01:55.920]  есть deadlock, а именно любое решение переживает только менее половина отказов узлов, и во-вторых,
[01:55.920 --> 02:02.720]  в любом решении задачи консенсуса есть livelock, то есть даже если сбоев нет, просто есть
[02:02.720 --> 02:07.480]  асинхронная сеть и детерминированный алгоритм, то этот алгоритм может сколько-годно долго не завершаться,
[02:07.480 --> 02:12.760]  если для него складывается неудачно, если просто сеть доставляет сообщение в каком-то неподходящем
[02:12.760 --> 02:24.440]  алгоритму порядке. Это была теорема FLP. И с первым результатом мы, видимо, поняли, что в алгоритме
[02:24.440 --> 02:29.560]  консенсуса, который обязан блокироваться при большом количестве отказов, должны быть какие-то
[02:29.560 --> 02:35.360]  хворомы, которые должны собираться или не собираться, если отказов слишком много, и в алгоритме консенсуса
[02:35.360 --> 02:41.440]  должны быть какие-то циклы, чтобы он мог в livelock войти. Такие нехитрые соображения. И в прошлый раз,
[02:41.440 --> 02:47.920]  на последнем занятии, мы с вами построили конкретный алгоритм, который решает эту задачу. Мы построили
[02:47.920 --> 03:00.400]  алгоритм, который назывался single decreed access. Access одного указа. Таковы наши достижения в текущем
[03:00.400 --> 03:08.160]  моменте. Вот план на сегодня. Вроде бы задача решена. То есть все, что мы написали, вроде бы дает нам
[03:08.160 --> 03:13.520]  РСМ. По модулю каких-то мелочей, которые на самом деле, конечно, не мелочи. Нам не хватает
[03:13.520 --> 03:20.400]  переконфигурации, нам не хватает экзеклиуанс, но это можно добыть. Но в принципе конструкция,
[03:20.400 --> 03:25.240]  она до конца реализована. Мы умеем решать эту задачу, мы умеем сводить эту задачу к этой с
[03:25.240 --> 03:30.640]  помощью серии консенсусов и reliable broadcast, где мы просто должны сообщение раздать всем. И мы умеем
[03:30.640 --> 03:36.400]  сводить эту задачу к этой, мы даже проговорили уже как. То есть в принципе можно отдыхать и больше
[03:36.400 --> 03:43.360]  ничего не делать. Но наша сегодняшняя цель, вот эту цепочку сведений размотать в обратную сторону и
[03:43.360 --> 03:50.680]  получить более-менее цельную конструкцию. Потому что вот такая цепочка сведений, она сама по себе
[03:50.680 --> 03:55.760]  очень неэффективна и нужно как-то аккуратнее все это сделать. Там по пути возникнет много мест,
[03:55.760 --> 04:01.560]  где можно что-то оптимизировать, как-то более удачно скомпоновать. Это конечно пойдет, идет в
[04:01.560 --> 04:06.960]  разрез. Вот с таким вот аккуратным сведением и модульностью, но с другой стороны мы получим что-то
[04:06.960 --> 04:12.360]  более применимое на практике. Мы хотим построить алгоритм, который будет называться multiplex.
[04:12.360 --> 04:25.000]  С помощью которого уже можно строить RSM, непосредственно RSM. Но для того, чтобы это сделать,
[04:25.000 --> 04:30.440]  нам нужно аккуратно вспомнить, как алгоритм работает. Ну и плюс с учетом новой домашки,
[04:30.560 --> 04:34.680]  тоже довольно актуально. Мы сейчас займемся очень скучным делом. Мы повторим просто,
[04:34.680 --> 04:39.960]  как алгоритм работает, чтобы дальше из него строить более сложное что-то.
[04:39.960 --> 04:52.160]  Итак, напомню, что в алгоритме single decreed access были роли. Были пропозеры и были аксепторы.
[04:52.160 --> 04:59.680]  Пропозеры выдвигали предложение и выполняли процедуру прополз, которая необходима для решения
[04:59.680 --> 05:04.200]  задач консенсуса, в которой она состоит. А аксепторы голосовали за предложение.
[05:04.200 --> 05:16.480]  Предложение это пара N, V, где V — это значение, которое предлагается пропозером, а N — это
[05:16.480 --> 05:24.080]  некоторый proposal number. Ну грустно, что он так называется, разумеется, но пока у нас нет для него
[05:24.080 --> 05:30.080]  более разумного, более подходящего названия. Proposal number, который уникален глобально в нашем
[05:30.080 --> 05:36.240]  алгоритме и который, видимо, является не просто некоторым числом, а он, скорее всего, является парой
[05:36.240 --> 05:47.280]  из какого-то числа и уникального идентификатора данного пропозера. Итак, процедура прополз,
[05:47.280 --> 05:53.440]  которую выполняет каждый пропозер. Обращаю ваше внимание, что алгоритм вообще не требуется,
[05:53.440 --> 05:58.000]  чтобы пропозеры и аксепторы были одними и теми же узлами. Алгоритм пропозеров — произвольное
[05:58.000 --> 06:02.360]  количество, аксепторы — фиксированное количество, потому что из них формы собираются. Вот оно выбрано,
[06:02.360 --> 06:15.840]  раз и навсегда, и не меняется. Что делает пропозер? Пропозер проходит через две фазы. Вот есть он и
[06:15.840 --> 06:21.320]  есть три аксептора. Разумеется, разные пропозеры действуют конкурентно, но мы смотрим только на
[06:21.320 --> 06:32.600]  одного. Сначала пропозер выбирает себе некоторое число n, но не число, а вот этот пропозл number и
[06:32.600 --> 06:55.760]  отправляет на аксептор сообщение prepare. Каждый аксептор хранит в себе np, максимальный n,
[06:55.760 --> 07:06.160]  который он получал в сообщениях пропозера, и хранит n, a, v, a. Это предложение, за которое аксептор в данный
[07:06.160 --> 07:14.400]  момент проголосовал. Это вот его текущий голос. В смысле, вся пара — текущий голос. Аксептор,
[07:14.400 --> 07:22.920]  получая сообщение prepare от пропозера, смотрит на его n и сравнивает его со своим np. Если n
[07:22.920 --> 07:32.640]  пропозера больше, чем np аксептора, то prepare принимается, аксептор обновляет свое локальное np,
[07:32.640 --> 07:50.400]  после чего отвечает пропозеру сообщением promise, куда прикладывает свой голос. Напомню,
[07:50.520 --> 07:57.520]  это сообщение служит сразу двум целям. Во-первых, если значение уже выбрано к этому моменту,
[07:57.520 --> 08:03.880]  то пропозер узнает об этом значении, получив голос аксептора. А во-вторых, сообщение называется
[08:03.880 --> 08:11.400]  promise, потому что аксептор заодно обещает не принимать сообщения, которые в второй
[08:11.400 --> 08:20.400]  фазе выполняются от других пропозеров с номерами меньше, чем n. В этом суть названия. Пара помогала
[08:20.400 --> 08:24.560]  узнать, что значение уже выбрано, а promise, то есть обещание не принимать более старые сообщения,
[08:24.560 --> 08:35.880]  позволяет гарантировать, что если мы этот пропозер предложим эту пару, и она победит,
[08:35.880 --> 08:42.400]  аксептор за нее проголосует, то никакие пропозлы с номерами меньше, чем наш, приняты уже не будут,
[08:42.400 --> 08:51.120]  если мы успели собрать кворум из preparer. Если мы успели собрать кворум из preparer, то мы смотрим
[08:51.120 --> 08:57.640]  на полученные пары N, A, V, A, и выбираем то значение, которое мы будем предлагать. Если мы получили
[08:57.640 --> 09:04.280]  от аксепторов хотя бы один непустой голос, то мы выбираем в качестве значения для своего
[09:04.280 --> 09:09.760]  предложения V, A с максимальным N, A. Если все голоса были пустые, то есть ни один аксептор еще ни за
[09:09.760 --> 09:15.680]  что не проголосовал, то мы берем в качестве предлагаемого значения свое собственное V. Вот так
[09:15.680 --> 09:22.320]  получается V со звездочкой. И после этого мы хотим записать его на кворум аксепторов. Для этого у нас
[09:22.320 --> 09:43.520]  есть вторая фаза и сообщение accept. Если этот accept устраивает аксептора, то есть N по-прежнему не
[09:43.520 --> 09:56.040]  меньше чем N, P, то аксептор принимает это предложение и обновляет свое N, A, V, A и отвечает
[09:56.040 --> 10:11.640]  проповоду, что его предложение принято. Если же по какой-то причине кворум, сбор кворума провалился
[10:11.640 --> 10:19.320]  на первой фазе или на второй. У нас сбор кворума может закончиться тремя способами. Он либо собрался
[10:19.320 --> 10:26.880]  все-таки успешно, то есть мы получили большинство промесов, скажем, либо он может зависнуть,
[10:26.880 --> 10:35.720]  потому что отказов слишком много, либо он может буквально провалиться, потому что мы получили
[10:35.720 --> 10:46.760]  слишком много отказов вместо промесов или вместо accepted. Если мы проходим успешно через две фазы на
[10:46.760 --> 10:56.320]  месте проповзора, то мы завершаем свой проповз, возвращаем его со звездочкой. Если же какая-то
[10:56.320 --> 11:01.520]  фаза проваливается, то мы ретраемся и проходим через две фазы заново, выбирая какой-то свежий N,
[11:01.520 --> 11:06.360]  который, видимо, больше, чем предшествующий в лексикографическом порядке, чтобы accepted все-таки
[11:06.360 --> 11:13.040]  приняли. Вот такой был алгоритм. Мы рисовали какие-то картинки с исполнением, пытались уяснить,
[11:13.040 --> 11:19.080]  в чем же смысл фаза prepare. Вроде бы выяснили это. Она с одной стороны позволяет узнать о значении,
[11:19.080 --> 11:24.360]  которое уже выбрано, а с другой стороны позволяет заблокировать конкурентов, которые уже не должны
[11:24.360 --> 11:33.440]  ничего предложить. И мы доказали safety. Мы определили, что такое выбор алгоритм Paxos. Мы сказали,
[11:33.440 --> 11:52.440]  что предложение nv chosen, если большинство acceptors ответили на него сообщением accepted. Даже не то,
[11:52.440 --> 11:57.720]  чтобы оно лежит где-то на большинстве acceptors в качестве голоса, просто acceptor какое-то
[11:57.720 --> 12:04.200]  большинство за него проголосовало. Вернее, какой-то quorum. И дальше мы доказали коллекцию safety
[12:04.200 --> 12:17.000]  свойств Paxos о том, что если с каким-то N пара nv была выбрана, то для всех N не меньше, чем это N,
[12:17.000 --> 12:22.280]  никакое другое значение, в принципе, не может быть предложено. То есть, если мы выбираем значение,
[12:22.280 --> 12:26.240]  то оно остается с нами навсегда. С другой стороны, эта теорема не обещала, что значение
[12:26.240 --> 12:32.600]  когда-либо будет выбрано, и в этом сути full P. То есть, если Paxos завершится, то замечательно,
[12:32.600 --> 12:37.760]  он свое решение не изменит. Мы гарантируем agreement. И agreement гарантировать для нас важно,
[12:37.760 --> 12:42.120]  потому что от agreement зависит order в broadcast и корректность репликации. С другой стороны,
[12:42.120 --> 12:48.600]  завершаемость мы гарантировать не могли, это было ограничение full P теоремы, мы не можем
[12:48.600 --> 12:54.960]  предалить, но мы можем на практике как-то с ним бороться с помощью времени и чего-то подобного.
[12:54.960 --> 12:58.200]  Про это сегодня еще поговорим подробнее. Да, вопрос.
[12:58.200 --> 13:09.400]  Если у нас есть выбранное значение, а потом кто-то из похолода отправляет Paxos N больше, чем выбранное?
[13:09.400 --> 13:15.800]  Ну смотри, каждый acceptor может голосовать много раз. Вот если он видит, если он уже выбрал,
[13:16.280 --> 13:21.360]  если уже глобально значение выбрано, вот пара это выбрано, предложение выбрано, а потом появился
[13:21.360 --> 13:26.520]  какой-то proposal с каким-то очень большим значением N, то он, конечно, проходит через фазу prepare и
[13:26.520 --> 13:33.280]  делает новый accept и его все принимают. Но смысл нашей теоремы был в том, что если он так делает,
[13:33.280 --> 13:39.600]  то он неизбежно будет предлагать то же самое V. С новым N, но V будет то же самое. В этом было
[13:40.600 --> 13:49.440]  то есть каждый acceptor голосует повторно, и вот эти принимаются все новые и новые пары.
[13:49.440 --> 13:57.080]  Но у каждой принятой пары V будет одно и то же. В этом была корректность. В этом было safety свойство,
[13:57.080 --> 14:03.240]  свойство agreement. В конце концов наш алгоритм-то он наружу эти N не отдаёт, он просто выбирает
[14:03.240 --> 14:11.760]  значение, а значение будет одно и то же. Мы посмотрели на все пары N, A, V, которые мы получили из
[14:11.760 --> 14:16.920]  промесов, и если хотя бы одна пара была не пустая, но поначалу у каждого acceptor пустой голос
[14:16.920 --> 14:23.160]  хранится. Там какой-нибудь ноль и пустое значение. И вот если мы получили только такие вот пустые
[14:23.160 --> 14:27.400]  голоса, то мы предлагаем свое значение, потому что, видимо, ничего еще совсем не выбрано. Но
[14:27.400 --> 14:32.600]  если мы хоть одно значение где-то увидели на quorum, то оно может быть выбрано. Мы в этом не
[14:32.600 --> 14:38.800]  уверены, поэтому мы выбираем одно из предложенных, а именно с максимальным N, A, и это дает нам
[14:38.800 --> 14:46.160]  корректность. Нет, нам нужен quorum, но мы проходим через первую фазу, мы ее завершаем только тогда,
[14:46.160 --> 14:52.120]  когда мы получили промес, то есть мы захватили вынеплание, захватили блокировку на большинстве
[14:52.120 --> 14:59.600]  acceptor. Quorum нам необходимы, когда мы этот quorum собрали, мы смотрим на все эти промесы,
[14:59.600 --> 15:04.880]  у нас большинство промесов теперь, промесы с большинства acceptor, мы посмотрели на их пары,
[15:04.880 --> 15:09.760]  выбрали себе максимум O, N, A, а если там везде пустые значения, то мы выбрали так уж и быть свое.
[15:09.760 --> 15:17.680]  Ну, алгоритм консенсации не важно, что выбрать, главное, чтобы просто выбор был общий. Ну что,
[15:17.680 --> 15:28.520]  это мы помним, да? Хорошо, тогда наша цель из этого алгоритма, из этого кирпичика построить atomic
[15:28.520 --> 15:33.920]  broadcast, который у нас будет называться multi-Paxos, потому что вот этот Paxos выбирал один единственный
[15:33.920 --> 15:39.760]  указ, судя по названию, а multi-Paxos или multi-degree Paxos выбирает серию указов, то есть это протокол
[15:39.760 --> 15:51.760]  работы греческого парламента и, видимо, в нем запускается серия консенс. Каждый из этих консенсов
[15:51.760 --> 15:57.920]  будет выбирать какое-то очередное значение, очередное сообщение в atomic broadcast и команду в RSM.
[15:57.920 --> 16:08.040]  И вот прежде чем перейти к конкретному, к построению этого алгоритма, мы будем его не описывать,
[16:08.040 --> 16:13.680]  а просто строить из каких-то общих соображений. Я хочу немного контекста дать. Мы будем решать
[16:13.680 --> 16:21.160]  не совсем задачу atomic broadcast, то есть в теории мы решали ее, но я хочу перейти
[16:21.160 --> 16:30.680]  к немного другой терминологии, а именно я хочу сказать, что мы вместо atomic broadcast решаем задачу
[16:30.680 --> 16:44.400]  репликации лога. Мы хотим построить алгоритм, который строит реплицированный лог. В чем суть?
[16:44.400 --> 16:50.560]  Ну понятие лога всем знакомое, это апенталонлиструктура данных, это может быть текстовый файл, куда
[16:50.560 --> 16:56.920]  высыпаете события. Давайте дверь закроем, если можно. Это может быть write-ahead-лог для отказа
[16:56.920 --> 17:04.720]  устойчивости на уровне одного узла, который пишет базу данных, или файловая система, или даже в
[17:04.720 --> 17:14.320]  смысле SSD. Мы хотим говорить про лог в том же самом смысле. Мы хотим говорить про такую структуру,
[17:14.320 --> 17:30.320]  у которой есть слоты, и куда будут помещаться команды пользователей. Вот команды у нас сегодня
[17:30.320 --> 17:39.760]  будут очень условные, я буду сразу их рисовать вот примерно так. Команда jump, команда move. Какие-то
[17:39.760 --> 17:47.080]  короткие ассемблерные мнимоники, потому что вам в конце концов не важно, что мы реплицируем. Вот мы
[17:47.080 --> 17:52.200]  хотим реплицировать произвольный автомат, и что для нас он значит? Ну это какой-то черный ящик.
[17:52.200 --> 18:03.040]  Что мы можем с ним делать? Мы можем взять его в некотором состоянии, и на этом состоянии сказать
[18:03.040 --> 18:14.480]  точка apply, применить какую-то команду, и получить новое состояние s' и результат применения этой
[18:14.480 --> 18:22.120]  команды, ну то есть какой-то операции пользователей. А дальше мы поместим на каждую реплику копию
[18:22.120 --> 18:28.360]  такого автомата, и хотим, чтобы на этих автоматах, на разных репликах, команды применялись в том
[18:28.360 --> 18:35.720]  же порядке. Вот порядок этих команд, он с одной стороны раньше задавал порядком доставки сообщения
[18:35.720 --> 18:42.280]  в этом эго бродкасте, а сейчас мы скажем, что этот порядок материализован в виде лого на каждой
[18:42.280 --> 18:48.480]  реплике. Вот у каждой реплики есть своя копия лого, которую помещают с команды, которые нужно
[18:48.480 --> 18:54.680]  применять к автомату. У каждой реплики своя собственная копия, и, разумеется, эти копии должны
[18:54.680 --> 19:00.760]  быть акты друг с другом синхронизированы. Эти копии не могут быть полностью тождественны в
[19:00.760 --> 19:05.400]  каждый момент времени, потому что реплики разные. Эти копии будут отличаться, в каком-то логе будет
[19:05.400 --> 19:10.440]  меньше, команд в каком-то больше, может быть даже команды в них будут разные, мы увидим почему. Но
[19:10.440 --> 19:15.280]  тем не менее, эти логи должны заполняться, и по префиксам они должны матчиться друг с другом,
[19:15.280 --> 19:22.760]  и вот каждая реплика будет по этому логу скользить. И наша задача вот реплицировать этот лог, то есть
[19:22.760 --> 19:28.560]  не мстить на каждую копию, на каждую реплику этот лог, и заботиться об их согласованности, о том,
[19:28.560 --> 19:34.280]  чтобы префиксы были одинаковыми. А что будет лежать в этом логе, команды, какие-то set или get для
[19:34.280 --> 19:40.400]  киеварю хранилища, или команды jump, move и red, какие-то условные, для нас это совершенно не важно
[19:40.400 --> 19:46.640]  уже. Для протокола репликации, вот этот автомат — это черный ящик, мы не знаем, как он устроен
[19:46.640 --> 19:57.320]  внутри, ну то есть в коде это может быть какой-то интерфейс, вот такой вот, с командой apply,
[19:57.320 --> 20:03.240]  с методом apply. И сами команды для нас тоже непрозрачны, то есть какие-то стерилизованные байты,
[20:03.240 --> 20:09.000]  которые вот эта стейт-машина реализации этого интерфейса умеет интерпретировать. Мы, реплика,
[20:09.000 --> 20:13.760]  ничего об этом не знаем. Мы просто храним свою копию лога, мы храним свою копию автомата,
[20:13.760 --> 20:22.800]  там не знаю, если это киеварю хранилищ, то мы храним отображение из ключей в значение. И вот мы читаем
[20:22.800 --> 20:27.920]  очередную команду и применяем ее. Мы помним, где мы остановились в логе, когда появляется новая
[20:27.920 --> 20:37.960]  команда, мы достаем ее, применяем к автомату и переходим в новое состояние. Вот это буквально
[20:37.960 --> 20:48.120]  называется RSM. И мы говорим сегодня про один способ реплицировать лог и с помощью него реализовать
[20:48.120 --> 21:02.640]  RSM, это мультипаксис. Ну вот и теперь уже можно на экран посмотреть наконец. Это какое-то состояние
[21:02.640 --> 21:08.640]  автомата, которое является отображением с ключей в значение. Мы говорили, что хотим построить базу
[21:08.640 --> 21:14.640]  данных, а в базе данных у нас есть. База данных строится табличная модель с транзакциями, с запросами,
[21:14.640 --> 21:18.760]  строится поверх киеварю хранилища, а киеварю хранилища большое, поэтому мы нарезаем его на шарды,
[21:18.760 --> 21:22.840]  которые называются таблетами. Каждый таблет это относительно небольшое количество ключей в
[21:22.840 --> 21:28.720]  значении, которые помещаются в одну машину. Мы их реплицируем с помощью, скажем, мультипакс,
[21:28.720 --> 21:33.560]  который мы хотим сегодня построить. Ну а каждая конкретная реплика хранит свою собственную копию.
[21:33.560 --> 21:47.600]  Эта копия была нарисована. И на свете существует довольно много, ну существуют разные алгоритмы,
[21:47.600 --> 21:54.880]  которые решают задачу репликации этого самого лога. Ну во-первых мультипаксис, но он не первый,
[21:54.880 --> 22:00.760]  и с ним есть некоторые сложности, я как раз о них хочу поговорить. А есть, наверное, исторически
[22:00.760 --> 22:11.200]  первый, это ViewStamp Replication, который был придуман еще в 80-х, но, кажется, его в таком нечеловеческом
[22:11.200 --> 22:15.680]  виде описали, что его трудно было понять, его переписали в 2000-х уже, вот это новая статья,
[22:15.680 --> 22:20.840]  поэтому ревизит. Есть протокол репликации, который называется ZooKeeper Atomic Broadcast,
[22:20.840 --> 22:26.280]  который используется в системе ZooKeeper, про которую мы как-то упоминали уже. Это RSM,
[22:26.280 --> 22:31.480]  который хранит такой эрортический набор атомиков, из помощью которого можно конфигурации в системе
[22:31.480 --> 22:37.000]  делать, задачу выбора лидера решать, но это вот отдельная лекция в параллельном курсе у вас будет.
[22:37.000 --> 22:42.800]  Это еще один протокол. Он действует не совсем так, как реплицированный лог, как я объяснил,
[22:42.800 --> 22:52.000]  но все же, в принципе, похож. Ну и есть, конечно же, алгоритм RAFT, в котором мы тоже идем,
[22:52.000 --> 22:56.360]  который является вот альтернативой алгоритма Multipax, который мы строим сегодня. Ну и вот тут
[22:56.360 --> 23:04.200]  смотрите, подходящая нам картинка про то, как в общем виде RSM функционирует. У нас есть реплики,
[23:04.200 --> 23:12.840]  это вот эти дощечки. У каждой реплики есть собственный лог, и у каждой реплики есть копия автомата.
[23:12.840 --> 23:19.200]  Когда мы клиент приходим с командой, то мы отдаем их условно такому модулю консенсуса,
[23:19.200 --> 23:25.200]  как он называется. Этот консенсус выбирает, в какой слот лога на каждый из реплик эта команда
[23:25.200 --> 23:31.440]  попадет. А сама реплика эти команды оттуда вычитывает в порядке, в котором они в этом логе
[23:31.440 --> 23:38.720]  появляются, и меняет состояние своего автомата. Ну вот здесь, видимо, реплика дошла до третьей
[23:38.720 --> 23:46.080]  команды, и вот поэтому Y сейчас равен 9. Ну вот такие алгоритмы, а есть Multipax. И здесь есть такой
[23:46.080 --> 23:53.880]  очень неловкий момент, который, как бы его описать. Дело в том, что Multipax непонятно, что это.
[23:53.880 --> 24:02.840]  Потому что вот если вы читаете статью про RAFT, то очень легко понять, что такое RAFT, потому что
[24:02.840 --> 24:09.080]  тут есть страница, одна из первых, где алгоритм просто полностью выписан. То есть вот два типа
[24:09.080 --> 24:15.840]  сообщений, два типа RPC-вызовов, append-enters и request-vote. Состояние каждой реплики и правило,
[24:15.840 --> 24:21.160]  по которому реплика реагирует на вот эти сообщения, что у них включено, как она меняет свое состояние,
[24:21.160 --> 24:26.240]  какие там роли есть. Ну в общем, если вы не хотите думать, то просто открываете эту страницу и
[24:26.240 --> 24:30.880]  переписываете. Это неправда, конечно. Думать все равно придется. Но в целом протокол вот зафиксирован.
[24:30.880 --> 24:36.800]  Если мы говорим про ViewStamp Replication, который придуман еще в 88 году, то тут тоже, в общем,
[24:36.800 --> 24:43.280]  все довольно понятно. Вы читаете статью, у вас там есть пункт 4.1, где описано, как протокол работает
[24:43.280 --> 24:47.960]  в такой стабильной конфигурации, когда никаких звуков нет. Мы получаем сообщение, отправляем
[24:48.440 --> 24:54.200]  prepare, потом получаем ответ. Тут все аргументы перечислены, что нужно делать, как менять
[24:54.200 --> 25:02.080]  состояние каждой реплики. Дальше есть протокол, который позволяет, если вдруг какой-то лидер
[25:02.080 --> 25:07.240]  умер, поменять его. Ну в общем, перейти в новую эпоху. Какие-то правила очень ясные, все описано.
[25:07.240 --> 25:11.880]  В протоколе звуки Peratomic Broadcast тоже описаны все сообщения, которые в протоколе участвуют.
[25:11.880 --> 25:22.880]  Их там уже довольно много становится в этом алгоритме, но тем не менее можно прочесть статью
[25:22.880 --> 25:32.360]  и всех выписать. А про multipaxes есть статья про греков. И вот там нет никакого канонического
[25:32.360 --> 25:37.320]  описания этого самого протокола. Вот если вам говорят, что такое RAF, то RAF более-менее один.
[25:37.320 --> 25:45.080]  Ну то есть, конечно же, есть некоторые вариации. Вот в голом RAF всего лишь два типа сообщений, но
[25:45.080 --> 25:52.080]  при этом, если вы делаете переконфигурации, то появляются новые сообщения. Если вы
[25:52.080 --> 25:56.960]  аккуратно справляетесь с асимметрией в сети, то появляются еще дополнительные сообщения,
[25:56.960 --> 26:01.760]  дополнительные фазы. Но тем не менее, что такое RAF, в целом, все понимают и понимают
[26:01.760 --> 26:06.360]  под этим одно и то же. Что такое звуки Peratomic Broadcast, тоже понимают, потому что он используется
[26:06.360 --> 26:11.280]  ровно в одной системе, и там канонично описано и реализовано. Если мы говорим про
[26:11.280 --> 26:16.440]  Ustream Replication, то тоже понятно, что такое Ustream Replication. Сообщение перечисленное, протокол
[26:16.440 --> 26:21.120]  описан. Мы даже понимаем, что такое single decreed access, потому что фазы были нарисованы,
[26:21.120 --> 26:30.840]  четыре сообщения, две фазы. Вот все очень конкретно. А multipaxes, у него канонического описания нет.
[26:30.840 --> 26:36.880]  Сколько в нем типа в сообщении, неизвестно. Как именно на них реагируется, это тоже неизвестно,
[26:36.880 --> 26:43.440]  потому что из предыдущего пункта следует. Это такой некоторый конструктор, некоторый фреймворк,
[26:43.440 --> 26:48.600]  в котором можно делать что-то свое. То есть мы сегодня придумаем общую конструкцию и поймем,
[26:48.600 --> 26:52.880]  то есть мы почти все придумаем, но у нас останутся какие-то пустые места, которые нужно чем-то
[26:52.880 --> 27:00.080]  заполнять. Вот Lamport не стремится к этому. Он оставляет эту возможность человеку читать
[27:00.080 --> 27:09.560]  ее внимательно в качестве упражнения. Ну и смотрите, чем это закончилось. Люди начали придумывать
[27:09.560 --> 27:16.160]  свои алгоритмы Paxos, в смысле свои какие-то вариации. Они их придумывали раньше и придумывают до сих
[27:16.160 --> 27:24.280]  пор. Вот я специально подобрал две свежие статьи 20 и 21 года. Они обе с названием Paxos. Это статья
[27:24.280 --> 27:29.320]  про переконфигурации, задачу которой мы еще не решили, и 21 год идет, а ее все еще решают
[27:29.320 --> 27:33.960]  подозрительно. Ну и еще одна статья с какими-то очень дикими названиями. Я не берусь это слово
[27:33.960 --> 27:41.000]  прочитать. Про то, почему разумно разносить проповзоров, аксепторов и какие оптимизации
[27:41.000 --> 27:46.480]  там можно строить. То есть Lamport дал нам большую свободу, и вот люди до сих пор ею пользуются и
[27:46.480 --> 27:52.040]  генерируют безумное количество статей. Вот есть целый такой список статей про консенсус. Если вы
[27:52.040 --> 28:01.960]  в них будете искать слово Paxos, то смотрите на счетчик. Тут 99 упоминаний. То есть можно до сих
[28:01.960 --> 28:10.720]  пор в 21 году придумывать новые вариации на тему Paxos и что-то новое в нем, не знаю, открывать или
[28:10.720 --> 28:19.080]  дорабатывать. В общем, мы сегодня обречены сразу на некоторое поражение. То есть наша работа не
[28:19.080 --> 28:28.800]  будет завершенной, потому что Paxos мы построить не можем. Их бесконечно много. Ну вот, не знаю,
[28:28.800 --> 28:39.320]  какой вывод нужно сейчас из этого сделать. Ну и с другой стороны, у вас же в домашне тоже будет
[28:39.320 --> 28:44.280]  возможность написать свой собственный Paxos. Вот кто знает, какой он у вас получится? Он у вас может
[28:44.280 --> 28:54.960]  получиться совершенно уникальный, ни на что не похожий. Ну что, давайте начинать строить алгоритм.
[29:14.280 --> 29:19.320]  Вот я надеюсь, что мы сегодня, то есть мы знаем про single decreed Paxos, больше особо ничего не знаем,
[29:19.320 --> 29:27.080]  и нам должно быть достаточно, чтобы построить что-то разумное и эффективное. Надеюсь, я вас не обману.
[29:27.080 --> 29:35.400]  Итак, я сказал, что у каждой реплики, у каждой реплика занимается задача репликации лога команд.
[29:35.400 --> 29:40.920]  Поверх этого реализован автомат, но как он устроен, мы не знаем, думать об этом не хотим,
[29:41.240 --> 29:48.320]  черный ящик. Наша задача – строить лог. Ну вот давайте этот лог еще раз аккуратно нарисуем.
[29:48.320 --> 30:05.320]  Задача мультипаксуса – поддерживать эти логи в согласованном состоянии. Ну я сказал,
[30:05.400 --> 30:12.840]  что лог – это просто материализация порядка команд в Atomic Broadcast. Ну а собственно,
[30:12.840 --> 30:20.760]  как добиться этого порядка, нужно использовать консенсус. У каждой реплики есть этот лог,
[30:20.760 --> 30:27.080]  и реплика КХД может получать команды от клиента. Вот пусть мы какая-то реплика,
[30:27.080 --> 30:48.760]  и мы получаем, в нашем логе уже лежат какие-то команды, и мы получили еще один мув. Что мы с ним
[30:48.760 --> 30:54.200]  делаем? Ну мы хотим, чтобы он попал в лог, потому что если он попадет в лог, то его можно будет
[30:54.200 --> 30:59.640]  применить к автомату и вернуть это пользователю. Первым делом мы смотрим на свой лог, ищем там
[30:59.640 --> 31:09.400]  первый свободный слот, и пытаемся поместить команду мув туда. А что значит, что мы пытаемся
[31:09.400 --> 31:16.080]  поместить туда команду? В конце концов, ну мы пытаемся, а другие реплики-то тоже пытаются,
[31:16.080 --> 31:23.240]  потому что у них свои логи, и они тоже получают какие-то команды от пользователя. Ну вот что
[31:23.320 --> 31:32.000]  значит поместить команду в лог? Скажите мне слуха бы. Видимо мы хотим в этом слоте стать
[31:32.000 --> 31:41.680]  пропузером, в смысле алгоритмом single decreed access. Вот мы реплика R, ну допустим реплика R1, есть
[31:41.680 --> 31:52.040]  реплики R2, R3, и что мы делаем? Мы начинаем фазу prepare. Ну с этого начинается алгоритм
[31:52.040 --> 32:01.320]  паксис, мы отправляем и себе в том числе, и остальным сообщения prepare. Правда,
[32:01.320 --> 32:05.800]  теперь вот это сообщение, вот этот консенсус, который мы устраиваем в третьем слоте, нужно
[32:05.800 --> 32:12.480]  как-то отделить от консенсусов в других слотах, поэтому мы просто в каждое сообщение из этого
[32:12.480 --> 32:23.120]  протокола базово добавим еще один параметр, это номер слота. Вот N у нас значит то же самое,
[32:23.120 --> 32:28.200]  это proposal number, а K это номер слота, в котором мы все это устраиваем. В любом случае K это 3.
[32:28.200 --> 32:48.640]  Мы же строим буквально atomic broadcast, только мы не говорим про операции sand и операции atomic broadcast
[32:48.640 --> 32:56.280]  и обработчик ADDriver, мы вместо этого лог реплицируем. Ну потому что этот лог, удобно думать про лог,
[32:56.280 --> 33:00.040]  потому что логи обычно хранятся на диске, а конечно же реплики должны запоминать порядок
[33:00.040 --> 33:03.680]  команд на диске, потому что они могут перезагрузиться и забыть все, что у них в оперативной памяти,
[33:03.680 --> 33:08.480]  а потом из этого лога можно восстановиться, восстановить локальное состояние. Поэтому удобно
[33:08.480 --> 33:13.240]  говорить про состояние, то есть про кодюструктуру. Вот мы говорим про лог, но по смыслу это просто
[33:13.240 --> 33:18.680]  серия консенсусов, каждый из которых выбирает команду вот в этом слоте, в каком слоте.
[33:18.680 --> 33:24.880]  Ну сейчас они должны быть практически, я не знаю, что ты имеешь в виду, а то у них в broadcast
[33:24.880 --> 33:31.560]  было свойство total order, оно говорило, что если мы берем префиксы двух любых, мы смотрим на порядок
[33:31.560 --> 33:36.440]  доставки и берем два любых префикса двух узлов, то они являются префиксами друг, ну один из них
[33:36.440 --> 33:41.360]  является префиксом другого. Вот здесь то же самое, если мы берем два префикса двух любых логов,
[33:41.360 --> 33:46.080]  то они являются префиксами друг друга. Ну чуть аккуратнее, сейчас мы до этого дойдем. Я пока
[33:46.080 --> 33:51.800]  просто поясняю, как мы используем консенсус. Мы в каждом слоте запускаем консенсус и к каждому,
[33:51.800 --> 33:56.520]  чтобы различать разные консенсусы между собой, мы к каждому сообщению добавляем новый параметр
[33:56.520 --> 34:07.680]  k. Вопрос у тебя. Когда реплика получает какую-то команду и хочет поместить ее в какой-то слот,
[34:07.680 --> 34:15.400]  то она для этого слота становится прапоузером. Когда она получает команду prepare от другой
[34:15.400 --> 34:24.480]  реплике с параметром k, то она для этого слота является аксептором. Я говорил, что аксепторы и
[34:24.480 --> 34:28.920]  пропоузеры могут находиться на одном узле, и если мы говорим про задачу консенсуса просто, то
[34:28.920 --> 34:37.520]  каждый узел является и пропоузером, и аксептором. Ну вот собираем promise, в общем, тут какая-то
[34:37.520 --> 34:46.960]  стандартная история. Протокол таким образом бежит вперед. Да, разумеется, если нам пришли сразу две
[34:46.960 --> 34:58.960]  команды, какой-нибудь еще один jump, то мы работаем с ними параллельно. То есть мы пытаемся поместить
[34:58.960 --> 35:03.720]  их в четвертый слот лога. И очередную команду в следующий слот лога свободны.
[35:03.720 --> 35:18.200]  Ну если там написано, что слот занят, если там ничего не написано, то он пустой.
[35:18.200 --> 35:33.680]  Давай с этим как раз договоримся сейчас. Вот у нас есть слот. В каком состоянии он может быть на
[35:33.680 --> 35:39.160]  каждой конкретной реплике? Во-первых, он может быть просто пуст. Вот буквально с этим слотом еще
[35:39.160 --> 35:44.640]  ничего не происходило. Мы туда ничего не пытались положить, и другие реплики тоже не пытались
[35:44.640 --> 35:50.440]  положить за что-то сами, и нам ничего об этом не говорили. Поэтому слот может быть пуст. Еще раз,
[35:50.440 --> 35:54.520]  я говорю про конкретную реплику. То есть где-то на какой-то реплике может слот быть пуст,
[35:54.520 --> 36:07.800]  а на другой уже не пуст. Смотрите, каждая реплика является аксептором для каждого отдельного слота.
[36:07.800 --> 36:17.240]  А у аксептора есть состояние NP и NAVA. Вот это состояние мы поддерживаем для каждого слота.
[36:17.240 --> 36:25.360]  То есть в каждом слоте на самом деле написано не просто команда, написано NP и NAVA. NP – это N,
[36:25.360 --> 36:31.680]  с которым какую-то команду нам кто-то предложил, возможно, мы сами. А вот значение VA – это,
[36:31.680 --> 36:38.400]  видимо, какая-то команда, за которую вы проголосовали. Так что когда я здесь пишу jump,
[36:38.400 --> 36:46.440]  не совсем понятно, что же это значит. Этот jump можно просто принять данным аксептором.
[36:46.440 --> 36:57.480]  То есть может быть вот в слоте K лежит пара NV. То есть данная реплика для данного слота
[36:57.480 --> 37:04.600]  проголосовала за какое-то предложение. Это просто локальный голос. Он не значит,
[37:04.600 --> 37:10.400]  что команду можно применять, потому что может быть этот голос изменится. Понимаете меня, да?
[37:10.400 --> 37:16.240]  Может быть на других репликах сейчас другие голоса с другими N, другие команды с другими N.
[37:16.240 --> 37:23.800]  Поэтому нам нужно различать состояние accept, где просто в логе лежит какая-то команда,
[37:23.800 --> 37:29.480]  от состояния chosen, когда она точно уже выбрана. Но я chosen не буду говорить,
[37:29.480 --> 37:36.160]  я буду говорить committed. То есть команда зафиксирована уже, всё. Она вот прибита в этом
[37:36.160 --> 37:44.640]  месте, уже измениться не может. То есть в смысле паксиса содержимое слота зафиксировано. N там
[37:44.640 --> 37:51.720]  может меняться, NP там может меняться, а вот в этом уже меняться не может. И поэтому очень полезно
[37:51.720 --> 38:03.120]  для лога понимать, какой префикс его является закоммиченным. То есть мало просто иметь какое-то
[38:03.120 --> 38:08.760]  содержимое лога. Мы можем применять это содержим, эти команды к автомату, только если мы уверены,
[38:08.760 --> 38:15.160]  что вот до текущей позиции всё закоммичено. Мы не можем применить команду 2, потому что она только
[38:15.160 --> 38:19.480]  принята сейчас данным accept, но может появиться новый проплоза, другая реплика, которая предложит
[38:19.480 --> 38:24.280]  другое значение, у неё будет N больше, и мы должны этот jump стереть и записать что-то другое.
[38:24.280 --> 38:31.080]  Поэтому нам важно очень отличать два этих состояния. Accepted и committed. Я в прошлый раз,
[38:31.080 --> 38:37.040]  когда говорил про single decrep access, задавал такой странный вопрос, он был очень не в тему. Как
[38:37.040 --> 38:41.080]  понять, что-то выбрано? То есть вы смотрите на accept-ов или вы являетесь accept-ом, как понять,
[38:41.080 --> 38:49.160]  что-то выбрано? Изолированные задачи, это может быть не так важно, а здесь важно. Вот вы реплика,
[38:49.160 --> 38:52.600]  вы смотрите на свой лог, там вроде бы слот занят, но он пока не финализирован. Непонятно,
[38:52.600 --> 38:58.840]  можно его применять или нет. Вот нужно как-то об этом озаботиться, в этом подумать. Ну вот,
[38:58.840 --> 39:06.240]  значит, слоты бывают в таких трёх состояниях. Их отличия понятны, да? Надеюсь, теперь. И когда
[39:06.240 --> 39:10.840]  я говорю, что мы ищем первый пустой слот, я имею в виду в этом смысле пустой. То есть там просто
[39:10.840 --> 39:18.160]  V пустой ещё. Ни одного голоса не было. Ну или даже, не знаю, ни одного prepr не было. Вот видите,
[39:18.160 --> 39:25.680]  появляются варианты. Но это вам останется на собственное усмотрение, как это всё сделать. В конце
[39:25.680 --> 39:35.600]  концов, вам дадут задачу и напишите её. То есть алгоритм здесь не фиксирует ничего конкретного,
[39:35.600 --> 39:42.840]  нужно только понимать, что можно делать, а что нельзя. И это самое важное. В смысле,
[39:42.840 --> 39:47.640]  что может нарушить вам корректность, а что не может нарушить. Ну в общем, понятно, да,
[39:47.640 --> 39:53.000]  конструкция? И когда я говорю, что вы предлагаете, это означает, что вы выбираете n для этого слота и
[39:53.000 --> 40:01.520]  выполняете сначала фазу prepare, потом фазу accept. Но может так получиться, что вы хотите поместить
[40:01.520 --> 40:12.120]  move сюда, но проигрываете. То есть что-то выбирается, но не ваше значение. Да может быть и не accepted.
[40:12.120 --> 40:19.520]  Ну просто ты проповзор в этом слоте, ты приходишь с командой с значением move, а в итоге выбирается не
[40:19.520 --> 40:26.400]  твой move, а что-то другое. Вот. Но консенсус, это не печарило, потому что консенсусу плевать,
[40:26.400 --> 40:32.600]  что будет выбрано. Но нам не плевать. К нам же пришёл клиент с командой move, он хочет её выполнить,
[40:32.600 --> 40:37.440]  хочет получить ответ. Мы обязаны всё-таки в лог положить. Мы его держим, пока не положим в лог.
[40:37.440 --> 40:42.280]  Что мы делаем? Ну если мы проиграли, если выиграл кто-то другой, какая-то другая реплика, положила
[40:42.280 --> 40:53.320]  туда свою команду, конкурирующую с нами, то мы не печаримся, мы просто третраемся. Ищем новый
[40:53.320 --> 41:00.200]  слот и пытаемся положить её заново. При этом мы можем вот параллельно пытаться заполнить несколько
[41:00.200 --> 41:16.160]  слотов. Хороший вопрос, он нас не интересует. Что может произойти? У нас есть некоторый лог,
[41:16.160 --> 41:23.440]  вот его префикс уже, допустим, даже закоммичен, и у нас появляются две команды A и B. И мы хотим
[41:23.440 --> 41:32.320]  поместить вот эту сюда, а эту сюда. Но не выходит, точнее вот с этой команды выходит, и B появляется
[41:32.320 --> 41:39.680]  здесь. Она комитится успешно. А в этом слоте появляется конкурент, и он кладёт сюда команду C.
[41:39.680 --> 41:53.000]  Здесь будет C написано. Ну тогда мы ретраемся и пробуем поместить A вот сюда. Это не страшно,
[41:53.000 --> 41:58.880]  потому что раз мы вообще параллельно запускали аксессы для команд A и B, это означает, что сами
[41:58.880 --> 42:05.160]  вызовы у клиентов конкурировать друг с другом. Поэтому клиенты не могут полагаться на то,
[42:05.160 --> 42:10.040]  что система применит эти команды A и B в определённом порядке. Сойдёт любой.
[42:10.040 --> 42:29.440]  Тогда такой вопрос. Вот вроде бы мы заполняем лог слева направо. Может ли так получиться,
[42:29.440 --> 42:43.640]  что в логе будут дырки? Ну вот мы реплика, и лог у нас выглядит так. Закомичный префикс,
[42:43.640 --> 42:54.280]  потом пустое место буквально. Это слот допустим 5. А в слоте 6 лежит команда.
[42:54.280 --> 43:19.560]  И мы прямо знаем, что она закомичена уже. Вот пустое в этом смысле. Вообще ничего нет.
[43:19.560 --> 43:29.680]  Во-первых, мы не можем такую команду применить. У нас всё закомичено, эта команда закомичена,
[43:29.680 --> 43:36.400]  применить мы её к себе не можем, потому что мы не знаем, что будет здесь. Здесь может оказаться
[43:36.400 --> 43:40.960]  какая-то команда, которая может повлиять на результат этой команды. Поэтому мы сначала должны
[43:40.960 --> 43:45.160]  заполнить этот слот. Ну а почему вообще дырка возникла, когда мы слева направо всё заполняли?
[43:45.160 --> 43:59.240]  Ну потому что реплик несколько. И допустим это была реплика R2, а у нас всего их было R1, R2, R3.
[43:59.240 --> 44:10.960]  И у нас были две команды. Два слота 5 и 6. И вот допустим две эти команды пришли обе на реплику
[44:10.960 --> 44:20.600]  с индексом 3. И вот эта реплика назначила номера этим двум командам. 5 и 6. И для пятой команды она
[44:20.600 --> 44:34.720]  собрала вот такой вот кворум. И закомиссила её даже. А для шестой она собрала вот такой кворум.
[44:34.720 --> 44:54.560]  Понятно ли, что это значит? Понятно ли, что происходит вернее? Что у нас есть две реплики,
[44:54.560 --> 45:15.440]  три реплики. И кто-то знает, у реплики 3 лог, префикс заполнен весь. А у реплики 2 и 1, у реплики 1 первые 5 слотов
[45:15.440 --> 45:34.320]  заполнены на шестой пустой. У реплики 2 первые 4 заполнены, пятый пустой шестой заполнен. Что делать в реплике 2?
[45:34.320 --> 45:42.320]  Ну вот смотри, буквально опять ты пишешь код, всё в твоих руках. Выдумывать то, что хочешь.
[45:42.320 --> 45:54.000]  Лэмпард тебя ни в чём не ограничивает. Я бы сказал, что Лэмпард тебе говорит более-менее одну вещь, что пока ты в каждом слоте делаешь консенсус,
[45:54.000 --> 46:08.000]  тебе ничего не угрожает. А вот когда ты начинаешь какое-то творчество, то тут уже ты идёшь по скользкой дорожке. Так вот, что делать-то?
[46:08.000 --> 46:26.880]  И что они тебе скажут? Что там находится? И что с этим делать? В каком состоянии? И главное, при чём здесь паксис-то?
[46:38.880 --> 46:48.880]  Как будто клиент обратился на вторую реплику. То есть, ты должен сначала пойти к другой реплике, узнать у неё команду, потом пытаться её положить к себе.
[46:48.880 --> 47:05.680]  Сам, или ты про это говоришь? Здесь реплика 3 рассылала запросы. Да, и допустим она взорвалась. И вообще может быть так, что она уже параллельно это делала, комитила слоты 5 и 6.
[47:06.360 --> 47:13.360]  И допустим она в шестой слот закомитила, а в пятом она просто отправила сообщение и взорвалась тут же. А сообщения ещё ни до кого не дошли.
[47:13.360 --> 47:21.360]  Вот даже непонятно, этот слот есть чем заполнить или нет. Может быть, R3 мёртвая уже, но это нормально, мы один отказ можем пережить из трёх.
[47:21.360 --> 47:31.360]  На двух других репликах пустое место и никогда она ничем не заполнится. А там тоже пусто. Что делать?
[47:36.360 --> 47:50.360]  Ну вот вы видите дырку, она вам мешает. Вот нужно поместить туда команду NOP, которая просто занимает место.
[47:50.360 --> 47:59.360]  Вот вы берёте и предлагаете NOP в любой непонятной ситуации. Если он выиграет, вы просто испортите слот.
[48:00.040 --> 48:04.040]  И не важно, вам главное, чтобы можно было через него перешагнуть.
[48:07.040 --> 48:13.040]  Мы выполняем propose с командой NOP в слоте 5.
[48:17.040 --> 48:23.040]  Ещё раз, проблема у нас там, что здесь может быть что угодно, что-то, что может повлиять на команду jump.
[48:23.720 --> 48:27.720]  Мы просто хотим как-то определить, что надо делать.
[48:27.720 --> 48:32.720]  Вот мы просто хотим зафиксировать содержимое слота 5, нам не важно, что там будет.
[48:32.720 --> 48:35.720]  Но если у нас есть своя собственная команда, то можно туда её положить.
[48:35.720 --> 48:39.720]  А если нет своей собственной команды, то возьмём NOP, он всегда есть.
[48:39.720 --> 48:43.720]  Этот NOP даже для автомата не вызывается, это просто пузырь.
[48:43.720 --> 48:51.720]  Такой бабл, который занимает место в логе и тем самым говорит нам, что в этом месте уже кроме этого пузыря ничего быть не может.
[48:52.400 --> 48:58.400]  А значит, можно спокойно этот слот пропустить и выполнять команду в слоте 6.
[49:03.400 --> 49:05.400]  Убедил тебя?
[49:08.400 --> 49:12.400]  При этом мы ничего не делаем, мы просто запускаем консенсус.
[49:12.400 --> 49:15.400]  Пока мы запускаем консенсус, нас ничего не угрожает.
[49:15.400 --> 49:17.400]  Это очень приятное свойство.
[49:18.080 --> 49:27.080]  Но не факт, что оно выиграет, может быть мы предложим NOP, а там уже что-то другое лежит.
[49:27.080 --> 49:35.080]  Допустим, вот реплика 3 успела записать, пройти через фазу accept для реплики 1.
[49:35.080 --> 49:43.080]  И сейчас реплика 3 взорвалась, удаст пустой лог в этом слоте, пустой слот.
[49:43.760 --> 49:48.760]  А у реплики 1 в слоте 5 лежит какая-то команда в состоянии accepted.
[49:48.760 --> 49:56.760]  Мы предложим NOP, мы соберем quorum и через promise возьмем эту чужую команду.
[49:58.760 --> 50:04.760]  Случится то, о чем ты говоришь, только не ручными действиями, он просто про такого консенсуса запустится и сам все это сделает.
[50:04.760 --> 50:10.760]  И в этом его преимущество на тобой, что ему не нужно специально эти случаи обрабатывать.
[50:11.440 --> 50:13.440]  Он просто сам разберется всегда.
[50:17.440 --> 50:20.440]  Да кто знает, в зависимости от того, что он на других репликах.
[50:20.440 --> 50:30.440]  Если там уже что-то лежало, то мы выполняя фазу prepare узнаем о чужой команде и в качестве высозвездочка выберем не свой NOP, а команду из чужого лога.
[50:30.440 --> 50:33.440]  Если и там, и там было пусто, то мы выберем свой NOP.
[50:33.440 --> 50:37.440]  И то, и другое нас устраивает, нам нужно чем-то заполнить слот, мы чем-то его заполним.
[50:41.440 --> 50:45.440]  А пропозы на 1 и 6 слота?
[50:45.440 --> 50:47.440]  Ну сейчас почему?
[50:47.440 --> 50:52.440]  Потому что первый пропоз это был, когда на R1 и R3 собрали.
[50:52.440 --> 50:54.440]  Сейчас, но пропозы тут делала R3.
[50:54.440 --> 50:57.440]  R3 делала 2 пропозы для 5 и 6 слота.
[50:57.440 --> 50:59.440]  Мы реплика R2.
[50:59.440 --> 51:02.440]  Мы делаем пропозы для 5 слота с NOP.
[51:02.440 --> 51:04.440]  Но это же разные реплики.
[51:04.440 --> 51:06.440]  И разные пропозы.
[51:06.440 --> 51:08.440]  Ну это же нормально.
[51:08.440 --> 51:10.440]  В консенсусе есть разные пропозы.
[51:11.120 --> 51:15.120]  Они все друг другом конкурируют и Paxos с этим разбирается.
[51:17.120 --> 51:19.120]  Получилось?
[51:23.120 --> 51:25.120]  Вообще ничего сложного.
[51:25.120 --> 51:27.120]  Мы просто Paxos и вызываем.
[51:27.120 --> 51:29.120]  О чем мы думаем вообще?
[51:33.120 --> 51:35.120]  В любой непонятной ситуации.
[51:35.120 --> 51:37.120]  Вот у нас есть пустое место в логе.
[51:37.120 --> 51:39.120]  Нам нужно чем-то его заполнить.
[51:39.800 --> 51:41.800]  Вы не знаете, что делать?
[51:41.800 --> 51:43.800]  Что?
[51:43.800 --> 51:45.800]  Вы не знаете, что делать и предлагать?
[51:45.800 --> 51:47.800]  Да.
[51:47.800 --> 51:49.800]  Ну вот предлагай NOP.
[51:49.800 --> 51:51.800]  Всегда безопасно.
[51:51.800 --> 51:53.800]  Не очень полезно, но безопасно.
[51:53.800 --> 51:55.800]  А если NOP выиграет?
[51:55.800 --> 51:57.800]  Если NOP выиграет, то он займет место в слоте 5.
[51:57.800 --> 51:59.800]  Для этого он нам и был нужен, чтобы занять место.
[51:59.800 --> 52:01.800]  А в каком случае он выиграет, если...
[52:01.800 --> 52:03.800]  Ну если вдруг в этом слоте действительно пусто.
[52:03.800 --> 52:08.800]  Если мы пойдем на Quorum и хоть один голос здесь увидим,
[52:09.480 --> 52:11.480]  чужой, с чужой командой.
[52:11.480 --> 52:13.480]  Вот отсюда.
[52:13.480 --> 52:15.480]  То это означает, что мы уже
[52:15.480 --> 52:17.480]  предложим не NOP.
[52:17.480 --> 52:19.480]  Про NOP забудем, про свое значение, про свой вход.
[52:19.480 --> 52:21.480]  А предложим что-то другое.
[52:21.480 --> 52:23.480]  Но нам не важно.
[52:30.480 --> 52:32.480]  Окей.
[52:32.480 --> 52:34.480]  Могу это удалять, да?
[52:34.480 --> 52:36.480]  Мы наконец-то это постигли.
[52:37.160 --> 52:39.160]  Хорошо.
[52:45.160 --> 52:47.160]  Тогда вопрос к вам.
[52:47.160 --> 52:51.160]  Не кажется ли вам эта конструкция супер неэффективной?
[52:54.160 --> 52:56.160]  Но она не похожа на что-то разумное,
[52:56.160 --> 52:58.160]  потому что
[52:58.160 --> 53:00.160]  у вас есть реплики,
[53:00.160 --> 53:02.160]  они независимо получают команды
[53:02.160 --> 53:04.160]  и предлагают в одних и тех же слотах
[53:04.160 --> 53:06.160]  разные команды.
[53:06.160 --> 53:08.160]  Вот реплика 1 получила одну команду,
[53:08.160 --> 53:10.160]  хочет ее положить в слот 3,
[53:10.160 --> 53:12.160]  другая реплика получила другую команду,
[53:12.160 --> 53:14.160]  а пользователь хочет положить ее в слот 3.
[53:14.160 --> 53:16.160]  И они начинают друг с другом конкурировать.
[53:16.160 --> 53:18.160]  И мы помним, что в алгоритме
[53:18.160 --> 53:20.160]  Single Decrep Access есть сценарий конкуренции,
[53:20.160 --> 53:22.160]  но есть обязан быть LifeLog
[53:22.160 --> 53:24.160]  и это LifeLog выглядит так.
[53:24.160 --> 53:26.160]  Мы говорим Prepare 1,
[53:26.160 --> 53:28.160]  Prepare 1 с синим пропаузером.
[53:28.160 --> 53:30.160]  Потом красный говорит
[53:30.160 --> 53:32.160]  Prepare 2, Prepare 2.
[53:32.160 --> 53:34.160]  И перебивает
[53:34.160 --> 53:36.160]  синего и не дает ему пройти
[53:36.160 --> 53:38.160]  через вторую фазу.
[53:38.160 --> 53:40.160]  Синий
[53:40.160 --> 53:42.160]  проваливается на фазе
[53:42.160 --> 53:44.160]  Accept,
[53:44.160 --> 53:46.160]  ретравится,
[53:46.160 --> 53:48.160]  выбирает синий пропаузер,
[53:48.160 --> 53:50.160]  перебивает синий пропаузер,
[53:50.160 --> 53:52.160]  перебивает синий пропаузер,
[53:52.160 --> 53:54.160]  Accept ретравится,
[53:54.160 --> 53:56.160]  выбирает себе новый ballot number,
[53:56.160 --> 53:58.160]  p3, p3.
[53:58.160 --> 54:00.160]  Его снова подрезают,
[54:00.160 --> 54:02.160]  p4, p4,
[54:02.160 --> 54:04.160]  и вот так продолжается бесконечно долго.
[54:08.160 --> 54:10.160]  Не факт, что это продолжается бесконечно долго,
[54:10.160 --> 54:12.160]  вряд ли это продолжается в реальности бесконечно долго,
[54:12.160 --> 54:14.160]  точнее точно не продолжается бесконечно долго,
[54:14.160 --> 54:16.160]  но все же тратится какое-то время.
[54:18.160 --> 54:20.160]  Причем что неприятно,
[54:20.160 --> 54:22.160]  неприятно, эти пропаузеры,
[54:22.160 --> 54:24.160]  то есть реплики,
[54:24.160 --> 54:26.160]  они могут друг с другом вот так вот соперничать,
[54:26.160 --> 54:28.160]  даже если они предлагают вообще одно и то же.
[54:30.160 --> 54:32.160]  То есть у них как бы команда общая,
[54:32.160 --> 54:34.160]  они хотят записать в окна,
[54:34.160 --> 54:36.160]  не могут, потому что мешают друг другу.
[54:36.160 --> 54:38.160]  Вот хочется каким-то образом
[54:38.160 --> 54:40.160]  такие сценарии исправить.
[54:40.160 --> 54:42.160]  В Single Decrease Access мы говорили,
[54:42.160 --> 54:44.160]  что для этого,
[54:44.160 --> 54:46.160]  теория МФОП говорит,
[54:46.160 --> 54:48.160]  что чтобы это исправить, вам нужно использовать время.
[54:48.160 --> 54:50.160]  Время или рандомизация, или то и другое.
[54:52.160 --> 54:54.160]  Ну и что мы могли бы сделать в Single Decrease Access?
[54:54.160 --> 54:56.160]  Мы могли бы использовать exponential book-ов.
[54:56.160 --> 54:58.160]  То есть когда мы
[54:58.160 --> 55:00.160]  проваливаем какую-то фазу, первую или вторую,
[55:00.160 --> 55:02.160]  мы перед тем, как повторить их заново,
[55:02.160 --> 55:04.160]  основываем N,
[55:04.160 --> 55:06.160]  некоторое время спим.
[55:06.160 --> 55:08.160]  Время этого сна, этой паузы,
[55:08.160 --> 55:10.160]  мы экспоненциально увеличиваем,
[55:10.160 --> 55:12.160]  потому что надеемся, что за это время
[55:12.160 --> 55:14.160]  другой наш конкурент успеет пройти
[55:14.160 --> 55:16.160]  через две фазы,
[55:16.160 --> 55:18.160]  я не знаю, сколько времени это у него займет,
[55:18.160 --> 55:20.160]  поэтому мы увеличиваем и увеличиваем до тех пор,
[55:20.160 --> 55:22.160]  пока он не влезет.
[55:22.160 --> 55:24.160]  И мы рандомизируем эти паузы
[55:24.160 --> 55:26.160]  для того, чтобы
[55:26.160 --> 55:28.160]  избавиться от совсем уж полной симметрии,
[55:28.160 --> 55:30.160]  если вдруг все работает абсолютно зеркально.
[55:32.160 --> 55:34.160]  Но это мы так делали в Single Decrease Access,
[55:34.160 --> 55:36.160]  когда у нас была задача
[55:36.160 --> 55:38.160]  выбрать одно значение.
[55:38.160 --> 55:40.160]  В задаче Multiprocess делать так неэффективно.
[55:40.160 --> 55:42.160]  Можно сделать гораздо
[55:42.160 --> 55:44.160]  и лучше,
[55:44.160 --> 55:46.160]  и в каком-то смысле проще.
[55:48.160 --> 55:50.160]  Я говорил вам,
[55:50.160 --> 55:52.160]  когда мы обсуждали FOP,
[55:52.160 --> 55:54.160]  что вот есть задача консенсуса,
[55:54.160 --> 55:56.160]  и на ней все не заканчивается.
[55:56.160 --> 55:58.160]  Можно свести ее к задаче построения
[55:58.160 --> 56:00.160]  детектора сбоев.
[56:02.160 --> 56:04.160]  То есть не пытаться время использовать
[56:04.160 --> 56:06.160]  прямо в консенсусе,
[56:06.160 --> 56:08.160]  а построить некоторый детектор,
[56:08.160 --> 56:10.160]  который будет отличать
[56:10.160 --> 56:12.160]  на каждом узле поместить детектор,
[56:12.160 --> 56:14.160]  который будет отличать смертные узлы от живых,
[56:14.160 --> 56:16.160]  и время использовать внутри него,
[56:16.160 --> 56:18.160]  потому что в конце концов нам нужно
[56:18.160 --> 56:20.160]  для того, чтобы сбои находить.
[56:20.160 --> 56:22.160]  А консенсус, пусть просто
[56:22.160 --> 56:24.160]  им пользуется как черным ящиком,
[56:24.160 --> 56:26.160]  и времени мне оперирует.
[56:28.160 --> 56:30.160]  И я даже сказал, как этот детектор должен быть устроен.
[56:30.160 --> 56:32.160]  Самый простой детектор.
[56:32.160 --> 56:34.160]  Это детектор выбора лидера,
[56:38.160 --> 56:40.160]  который по текущему времени
[56:40.160 --> 56:42.160]  на каждом узле возвращает узел,
[56:42.160 --> 56:44.160]  который, по мнению
[56:44.160 --> 56:46.160]  этого детектора, является
[56:46.160 --> 56:48.160]  текущим лидером.
[56:48.160 --> 56:50.160]  То есть смысл в том,
[56:50.160 --> 56:52.160]  чтобы избавиться от конкуренции
[56:52.160 --> 56:54.160]  выборов среди реплик
[56:54.160 --> 56:56.160]  какого-то одного,
[56:56.160 --> 56:58.160]  Лэмпард это называет выделенный пропозер.
[57:02.160 --> 57:04.160]  Мы не Лэмпард,
[57:04.160 --> 57:06.160]  мы будем говорить лидер.
[57:08.160 --> 57:10.160]  Смысл в том, что лидер один,
[57:10.160 --> 57:12.160]  и только ему разрешается предлагать команды.
[57:12.160 --> 57:14.160]  Если вы не лидер,
[57:14.160 --> 57:16.160]  то вы отдаете свою команду лидеру,
[57:16.160 --> 57:18.160]  и пусть он ее предлагает.
[57:18.160 --> 57:20.160]  Лидер фиксирует порядок команд,
[57:20.160 --> 57:22.160]  выстраивает их в паслотам лога,
[57:22.160 --> 57:24.160]  и пытается их закомиссить.
[57:24.160 --> 57:26.160]  И если другие лидеры
[57:26.160 --> 57:28.160]  не лидеры,
[57:28.160 --> 57:30.160]  то они не лидеры.
[57:30.160 --> 57:32.160]  И если другие ему не мешают,
[57:32.160 --> 57:34.160]  то он быстро проходит через две фазы
[57:34.160 --> 57:36.160]  и добивается успеха.
[57:38.160 --> 57:40.160]  И вот именно в этой подзадаче
[57:40.160 --> 57:42.160]  выбора лидера
[57:42.160 --> 57:44.160]  можно и стоит
[57:44.160 --> 57:46.160]  пользоваться временем и рандомизацией.
[57:52.160 --> 57:54.160]  Причина, по которой Паксос
[57:54.160 --> 57:56.160]  должен вам нравиться,
[57:56.160 --> 57:58.160]  состоит в том, что
[57:58.160 --> 58:00.160]  он очень сильно упрощает
[58:00.160 --> 58:02.160]  рассуждение об этом лидере,
[58:02.160 --> 58:04.160]  потому что Паксос очень хорошо
[58:04.160 --> 58:06.160]  отделяет свойства
[58:06.160 --> 58:08.160]  safety консенсуса от свойства
[58:08.160 --> 58:10.160]  liveness консенсуса, termination.
[58:10.160 --> 58:12.160]  Вот вы можете строить этот детектор
[58:12.160 --> 58:14.160]  любым способом, абсолютно любым.
[58:14.160 --> 58:16.160]  Скажем, в алгоритме,
[58:16.160 --> 58:18.160]  где вы реплицировали key value,
[58:18.160 --> 58:20.160]  вот ячейку памяти,
[58:20.160 --> 58:22.160]  там вы должны были аккуратно пользоваться временем,
[58:22.160 --> 58:24.160]  чтобы не нарушить линеризуемость.
[58:24.160 --> 58:26.160]  Там локальные часы вообще не подходили,
[58:26.160 --> 58:28.160]  где true time нужно было аккуратно
[58:28.160 --> 58:30.160]  тоже использовать, там были какие-то нюансы.
[58:30.160 --> 58:32.160]  Вот здесь творите, что хотите.
[58:34.160 --> 58:36.160]  Лидер, неправильно
[58:36.160 --> 58:38.160]  выбранный, неаккуратно выбранный,
[58:38.160 --> 58:40.160]  не способен ничего сломать.
[58:40.160 --> 58:42.160]  Если у вас лидер — это функция, которая возвращает
[58:42.160 --> 58:44.160]  собственный идентификатор, то это тоже
[58:44.160 --> 58:46.160]  легальная процедура, потому что
[58:46.160 --> 58:48.160]  в любом случае, даже если у вас
[58:48.160 --> 58:50.160]  лидеров несколько, все равно Паксос
[58:50.160 --> 58:52.160]  с этим справится.
[58:52.160 --> 58:54.160]  Но если вы все-таки выбираете лидера
[58:54.160 --> 58:56.160]  таким образом, то есть eventually он будет
[58:56.160 --> 58:58.160]  выбран все-таки один общий,
[58:58.160 --> 59:00.160]  то станет хорошо.
[59:00.160 --> 59:02.160]  Но плохо не станет.
[59:02.160 --> 59:04.160]  Никогда. А хорошо может быть.
[59:04.160 --> 59:06.160]  Вот в этом смысле
[59:06.160 --> 59:08.160]  Paxos safety от liveness
[59:08.160 --> 59:10.160]  декомпозирует совершенство.
[59:10.160 --> 59:12.160]  Здесь вы можете
[59:12.160 --> 59:14.160]  ничего не думать про задачу консенсуса.
[59:16.160 --> 59:18.160]  Ну и что предлагает Lampard?
[59:18.160 --> 59:20.160]  Как именно он предлагает
[59:20.160 --> 59:22.160]  лидера выбирать?
[59:24.160 --> 59:26.160]  Вопросы есть пока или нет?
[59:36.160 --> 59:38.160]  Да.
[59:38.160 --> 59:40.160]  Честно, он не применяет их, применяют их все.
[59:40.160 --> 59:42.160]  Лидер выбирает порядок
[59:42.160 --> 59:44.160]  и предлагает их комитет слоты.
[59:46.160 --> 59:48.160]  Все остальные этого не делают, чтобы ему не мешать.
[59:50.160 --> 59:52.160]  В этом смысле
[59:52.160 --> 59:54.160]  это некоторое узкое место,
[59:54.160 --> 59:56.160]  но такова конструкция
[59:56.160 --> 59:58.160]  RSM by design практически.
[01:00:00.160 --> 01:00:02.160]  Она по задумке
[01:00:02.160 --> 01:00:04.160]  в этом и состоит.
[01:00:04.160 --> 01:00:06.160]  Вопрос у тебя был в этом или
[01:00:06.160 --> 01:00:08.160]  в чем-то другое?
[01:00:08.160 --> 01:00:10.160]  Тогда
[01:00:10.160 --> 01:00:12.160]  говорим про какую-то очень простую
[01:00:12.160 --> 01:00:14.160]  процедуру выбора лидера,
[01:00:14.160 --> 01:00:16.160]  которую предлагает сам Lampard.
[01:00:16.160 --> 01:00:18.160]  Вот ничего проще
[01:00:18.160 --> 01:00:20.160]  и глупее придумать невозможно.
[01:00:24.160 --> 01:00:26.160]  У нас есть три реплики.
[01:00:34.160 --> 01:00:36.160]  Вот давайте каждый из них запустит,
[01:00:36.160 --> 01:00:38.160]  ну вот мы строим такой отдельный модуль,
[01:00:38.160 --> 01:00:40.160]  каждый из них будет в фоне выполнять
[01:00:40.160 --> 01:00:42.160]  такую процедуру.
[01:00:42.160 --> 01:00:44.160]  Через равные промежутки времени
[01:00:48.160 --> 01:00:50.160]  мы будем всем
[01:00:50.160 --> 01:00:52.160]  другим узлам отправлять
[01:00:52.160 --> 01:00:54.160]  сообщение, которое называется
[01:00:54.160 --> 01:00:56.160]  heartbeat
[01:00:58.160 --> 01:01:00.160]  с аргументом
[01:01:00.160 --> 01:01:02.160]  ID, где ID
[01:01:02.160 --> 01:01:04.160]  это наш идентификатор.
[01:01:04.160 --> 01:01:06.160]  Некоторый постоянный.
[01:01:06.160 --> 01:01:08.160]  Ну можно уже догадаться, как мы будем этим
[01:01:08.160 --> 01:01:10.160]  пользоваться.
[01:01:10.160 --> 01:01:12.160]  Вот давайте считать, что лидером
[01:01:12.160 --> 01:01:14.160]  будет узел, у которого максимальный
[01:01:14.160 --> 01:01:16.160]  ID, и который сейчас жив.
[01:01:16.160 --> 01:01:18.160]  Ну как мы поймем, что он жив,
[01:01:18.160 --> 01:01:20.160]  ну вот у него бьется сердце.
[01:01:20.160 --> 01:01:22.160]  Мы продолжаем получать от него вот эти сообщения
[01:01:22.160 --> 01:01:24.160]  heartbeat.
[01:01:24.160 --> 01:01:26.160]  То есть у него есть
[01:01:26.160 --> 01:01:28.160]  максимальный ID,
[01:01:28.160 --> 01:01:30.160]  который сейчас жив.
[01:01:30.160 --> 01:01:32.160]  Ну как мы понимаем, что он жив,
[01:01:32.160 --> 01:01:34.160]  ну вот у него бьется сердце.
[01:01:34.160 --> 01:01:36.160]  То есть с одной стороны мы отправляем
[01:01:36.160 --> 01:01:38.160]  эти сообщения всем, а с другой стороны
[01:01:38.160 --> 01:01:40.160]  мы слушаем эти сообщения других узлов
[01:01:40.160 --> 01:01:42.160]  и в каком-то временном окне
[01:01:42.160 --> 01:01:44.160]  просто запоминаем последнее,
[01:01:44.160 --> 01:01:46.160]  старшее ID.
[01:01:46.160 --> 01:01:48.160]  И вот по этому старшему ID мы
[01:01:48.160 --> 01:01:50.160]  выбираем, кто сейчас лидер.
[01:01:52.160 --> 01:01:54.160]  В этом смысле выбор
[01:01:54.160 --> 01:01:56.160]  лидера всегда, ну
[01:01:56.160 --> 01:01:58.160]  вы всегда знаете, кто лидер.
[01:02:00.160 --> 01:02:02.160]  Не бывает такого, что лидер неизвестен сейчас.
[01:02:02.160 --> 01:02:04.160]  По умолчанию это всегда вы,
[01:02:04.160 --> 01:02:06.160]  но если вдруг вы получите heartbeat
[01:02:06.160 --> 01:02:08.160]  с каким-то большим идентификатором,
[01:02:08.160 --> 01:02:10.160]  то вы скажете, ну окей, значит не я лидер.
[01:02:10.160 --> 01:02:12.160]  Перебьюсь.
[01:02:12.160 --> 01:02:14.160]  Но если вдруг вам этот лидер
[01:02:14.160 --> 01:02:16.160]  с большим ID перестанет присылать свои heartbeat,
[01:02:16.160 --> 01:02:18.160]  то вы понимаете, что на видимого номера
[01:02:18.160 --> 01:02:20.160]  и забудете про него.
[01:02:22.160 --> 01:02:24.160]  Так вот я же говорю,
[01:02:24.160 --> 01:02:26.160]  что мы выделили под задачу
[01:02:26.160 --> 01:02:28.160]  построение детектора сбоя,
[01:02:28.160 --> 01:02:30.160]  построение модуля выбора лидера,
[01:02:30.160 --> 01:02:32.160]  и мы используем время.
[01:02:32.160 --> 01:02:34.160]  И там мы можем сказать, вот мы ожидаем,
[01:02:34.160 --> 01:02:36.160]  что все сообщения доставляются там
[01:02:36.160 --> 01:02:38.160]  за 5 миллисекунд.
[01:02:38.160 --> 01:02:40.160]  Мы ожидаем, что если за 30 секунд
[01:02:40.160 --> 01:02:42.160]  мы heartbeat не получим,
[01:02:42.160 --> 01:02:44.160]  то мы считаем, что машина мертва.
[01:02:44.160 --> 01:02:46.160]  Вот каждое такое
[01:02:46.160 --> 01:02:48.160]  предположение может быть неверным.
[01:02:48.160 --> 01:02:50.160]  То есть машина жива,
[01:02:50.160 --> 01:02:52.160]  но 30 секунд она ничего не управляла,
[01:02:52.160 --> 01:02:54.160]  потому что я не знаю почему.
[01:02:54.160 --> 01:02:56.160]  Это не страшно,
[01:02:56.160 --> 01:02:58.160]  потому что наш модуль выбора
[01:02:58.160 --> 01:03:00.160]  лидера ошибется.
[01:03:00.160 --> 01:03:02.160]  Он исключит вот этот лидер
[01:03:02.160 --> 01:03:04.160]  с большим узелом с большим ID,
[01:03:04.160 --> 01:03:06.160]  кандидат.
[01:03:06.160 --> 01:03:08.160]  Он перестанет считать его лидером.
[01:03:08.160 --> 01:03:10.160]  Наша реплика перестанет считать этот узел
[01:03:10.160 --> 01:03:12.160]  лидером.
[01:03:12.160 --> 01:03:14.160]  И сама станет, допустим, лидером.
[01:03:14.160 --> 01:03:16.160]  То есть сама себя посчитает.
[01:03:16.160 --> 01:03:18.160]  Ну окей, пусть считает.
[01:03:18.160 --> 01:03:20.160]  Тогда она тоже будет предлагать команды.
[01:03:20.160 --> 01:03:22.160]  У нас появляется два пропаузера в системе.
[01:03:22.160 --> 01:03:24.160]  Но два пропаузера – это нормальная ситуация
[01:03:24.160 --> 01:03:26.160]  для Paxos. Paxos это переживет.
[01:03:26.160 --> 01:03:28.160]  Paxos переживает, когда у нас все пропаузеры.
[01:03:30.160 --> 01:03:32.160]  Но если здесь работает стабильно,
[01:03:32.160 --> 01:03:34.160]  то, видимо, если 30 секунд машина
[01:03:34.160 --> 01:03:36.160]  не отвечает, то действительно может быть она умерла
[01:03:36.160 --> 01:03:38.160]  и нужно перестать на нее надеяться.
[01:03:44.160 --> 01:03:46.160]  Почему всеми ко всем?
[01:03:50.160 --> 01:03:52.160]  Ничего себе.
[01:03:52.160 --> 01:03:54.160]  У тебя там 5 реплик, а не раз в 5 миллисекунд
[01:03:54.160 --> 01:03:56.160]  на 1 сообщение друг другу.
[01:03:56.160 --> 01:03:58.160]  У тебя в этом системе хочется
[01:03:58.160 --> 01:04:00.160]  сотни тысячи в секунду запросов переживать,
[01:04:00.160 --> 01:04:02.160]  а ты вот пытаешься это сообщение сэкономить.
[01:04:02.160 --> 01:04:04.160]  Ну нет, вообще, на самом деле
[01:04:04.160 --> 01:04:06.160]  зря я потешаюсь. На самом деле
[01:04:06.160 --> 01:04:08.160]  это очень разумная вещь, говоришь.
[01:04:14.160 --> 01:04:16.160]  Вот представим себе KVL-хранилище.
[01:04:16.160 --> 01:04:18.160]  Много ключей, не все
[01:04:18.160 --> 01:04:20.160]  в одну машину не помещаются.
[01:04:20.160 --> 01:04:22.160]  Мы берем это пространство ключей, делим на диапазоны.
[01:04:22.160 --> 01:04:24.160]  И говорим, вот каждый такой маленький диапазон
[01:04:24.160 --> 01:04:26.160]  будет реплицироваться независимо.
[01:04:26.160 --> 01:04:28.160]  Будет отдельным RSM-ом.
[01:04:28.160 --> 01:04:30.160]  И для каждого такого диапазона
[01:04:30.160 --> 01:04:32.160]  будут наборы, то есть у нас есть полмашины,
[01:04:32.160 --> 01:04:34.160]  допустим, 100. Мы делим набор ключей
[01:04:34.160 --> 01:04:36.160]  на тысячу диапазонов
[01:04:36.160 --> 01:04:38.160]  и каждый из тысячи
[01:04:38.160 --> 01:04:40.160]  диапазонов хранится на каких-то трех машинах
[01:04:40.160 --> 01:04:42.160]  в виде RSM-а.
[01:04:42.160 --> 01:04:44.160]  Но при этом
[01:04:44.160 --> 01:04:46.160]  каждая отдельная машина, физическая,
[01:04:46.160 --> 01:04:48.160]  она может хранить, быть репликами
[01:04:48.160 --> 01:04:50.160]  для разных диапазонов.
[01:04:50.160 --> 01:04:52.160]  И действительно в таком случае
[01:04:52.160 --> 01:04:54.160]  не делают так, что для каждого диапазона
[01:04:54.160 --> 01:04:56.160]  свои собственные хардбиты.
[01:04:56.160 --> 01:04:58.160]  Можно их поклеить.
[01:04:58.160 --> 01:05:00.160]  То есть если ваш узел является
[01:05:00.160 --> 01:05:02.160]  репликой сразу для там
[01:05:02.160 --> 01:05:04.160]  10 разных регионов
[01:05:04.160 --> 01:05:06.160]  диапазонов ключей,
[01:05:06.160 --> 01:05:08.160]  то можно склеить все хардбиты
[01:05:08.160 --> 01:05:10.160]  для всех этих диапазонов в какое-то общее сообщение.
[01:05:10.160 --> 01:05:12.160]  На этом
[01:05:12.160 --> 01:05:14.160]  так-то экономить. Так что в продакшене
[01:05:14.160 --> 01:05:16.160]  так делают. Мы так не делаем,
[01:05:16.160 --> 01:05:18.160]  потому что мы до продакшена далеки.
[01:05:20.160 --> 01:05:22.160]  Но если мы говорим
[01:05:22.160 --> 01:05:24.160]  просто про 5-7 реплик
[01:05:24.160 --> 01:05:26.160]  и сообщение раз в какое-то количество
[01:05:26.160 --> 01:05:28.160]  миллисекунд, то они же
[01:05:28.160 --> 01:05:30.160]  маленькие, их мало,
[01:05:30.160 --> 01:05:32.160]  то есть это не страшно. У тебя не бывает здесь, что
[01:05:32.160 --> 01:05:34.160]  тысячи реплик в RSM, у тебя их там 3-5-7
[01:05:34.160 --> 01:05:36.160]  какой-то такое число.
[01:05:36.160 --> 01:05:38.160]  Стоит ли так делать
[01:05:38.160 --> 01:05:40.160]  в продакшене? Нет, не стоит, ни в коем случае
[01:05:40.160 --> 01:05:42.160]  никогда так не делаете. Почему?
[01:05:42.160 --> 01:05:44.160]  Потому что это плохо кончится.
[01:05:46.160 --> 01:05:48.160]  Ну вот представьте,
[01:05:48.160 --> 01:05:50.160]  что у вас 3 реплики.
[01:06:06.160 --> 01:06:08.160]  Давайте я их логи так нарисую пока.
[01:06:08.160 --> 01:06:10.160]  И среди них
[01:06:10.160 --> 01:06:12.160]  случился partition.
[01:06:12.160 --> 01:06:14.160]  Сеть раскололась
[01:06:14.160 --> 01:06:16.160]  на две части,
[01:06:16.160 --> 01:06:18.160]  и отрезала R3 от остальных.
[01:06:18.160 --> 01:06:20.160]  Понятно, что в каждой части
[01:06:20.160 --> 01:06:22.160]  будет собственный лидер,
[01:06:22.160 --> 01:06:24.160]  потому что он всегда выбирается,
[01:06:24.160 --> 01:06:26.160]  и здесь лидером будет
[01:06:26.160 --> 01:06:28.160]  видимо R2,
[01:06:28.160 --> 01:06:30.160]  а здесь R3.
[01:06:30.160 --> 01:06:32.160]  Лидер R3
[01:06:32.160 --> 01:06:34.160]  ничего плохого в принципе сделать не может,
[01:06:34.160 --> 01:06:36.160]  потому что ни одного кворума не может собрать.
[01:06:36.160 --> 01:06:38.160]  А лидер R2, он способен работать,
[01:06:38.160 --> 01:06:40.160]  если он получает команды от пользователей,
[01:06:40.160 --> 01:06:42.160]  то он может их писать в собственный лог
[01:06:42.160 --> 01:06:44.160]  и копировать их на R1,
[01:06:44.160 --> 01:06:46.160]  собрать кворум.
[01:06:50.160 --> 01:06:52.160]  Ну вот,
[01:06:52.160 --> 01:06:54.160]  это все.
[01:06:54.160 --> 01:06:56.160]  Ну вот,
[01:06:56.160 --> 01:06:58.160]  и
[01:07:00.160 --> 01:07:02.160]  допустим,
[01:07:02.160 --> 01:07:04.160]  он принял 100-500 команд.
[01:07:04.160 --> 01:07:06.160]  Ну ладно, 100-500 много,
[01:07:06.160 --> 01:07:08.160]  давайте 100.
[01:07:08.160 --> 01:07:10.160]  Это уже будет больше похоже
[01:07:10.160 --> 01:07:12.160]  на реальность.
[01:07:12.160 --> 01:07:14.160]  Вот 100 каких-то команд
[01:07:14.160 --> 01:07:16.160]  прошел через 100
[01:07:16.160 --> 01:07:18.160]  параллельно
[01:07:18.160 --> 01:07:20.160]  прошел через 100 паксусов.
[01:07:20.160 --> 01:07:22.160]  И он-то знает,
[01:07:22.160 --> 01:07:24.160]  что теперь эти команды закомичаны,
[01:07:24.160 --> 01:07:26.160]  поэтому реплика R1 не знает про то, что они закомичаны,
[01:07:26.160 --> 01:07:28.160]  она просто получила и проголосовала за них.
[01:07:28.160 --> 01:07:30.160]  Что происходит дальше?
[01:07:30.160 --> 01:07:32.160]  Дальше partition лечится.
[01:07:40.160 --> 01:07:42.160]  R3 присоединяется к остальным.
[01:07:42.160 --> 01:07:44.160]  И видимо,
[01:07:44.160 --> 01:07:46.160]  все они понимают, что лидер теперь R3,
[01:07:46.160 --> 01:07:48.160]  потому что у него самый большой идентификатор.
[01:07:50.160 --> 01:07:52.160]  R2
[01:07:52.160 --> 01:07:54.160]  не переживает
[01:07:54.160 --> 01:07:56.160]  этой трагедии и умирает.
[01:07:58.160 --> 01:08:00.160]  А он единственный знал про то,
[01:08:00.160 --> 01:08:02.160]  что у нас 100 команд закомичаны.
[01:08:02.160 --> 01:08:04.160]  В итоге теперь у нас есть лидер R3 с пустым логом
[01:08:04.160 --> 01:08:06.160]  и R1, у которого
[01:08:06.160 --> 01:08:08.160]  лог на 100 команд заполнен,
[01:08:08.160 --> 01:08:10.160]  но он не знает, что они закомичаны.
[01:08:10.160 --> 01:08:12.160]  И что делает R3?
[01:08:12.160 --> 01:08:14.160]  Он получает команду свою
[01:08:14.160 --> 01:08:16.160]  и начинает ее коммитить.
[01:08:16.160 --> 01:08:18.160]  И понимает, что ничего не вышло,
[01:08:18.160 --> 01:08:20.160]  потому что выиграет другая команда.
[01:08:20.160 --> 01:08:22.160]  Реплика R1 на первой фазе пакса
[01:08:22.160 --> 01:08:24.160]  соответствует этому непустым голосу.
[01:08:24.160 --> 01:08:26.160]  И он будет так
[01:08:26.160 --> 01:08:28.160]  долго не спеша
[01:08:28.160 --> 01:08:30.160]  заполнять свой лог.
[01:08:30.160 --> 01:08:32.160]  Команды были закомичаны,
[01:08:32.160 --> 01:08:34.160]  поэтому они не потеряются.
[01:08:34.160 --> 01:08:36.160]  Но тем не менее мы начали с нуля
[01:08:36.160 --> 01:08:38.160]  и повторяем весь протокол заново.
[01:08:38.160 --> 01:08:40.160]  Просто потому, что мы выбрали лидера
[01:08:40.160 --> 01:08:42.160]  с пустым логом.
[01:08:42.160 --> 01:08:44.160]  Возможно, так делать не стоит.
[01:08:46.160 --> 01:08:48.160]  Лэмпард в своей статье про это пишет,
[01:08:48.160 --> 01:08:50.160]  что из полугодового отпуска
[01:08:50.160 --> 01:08:52.160]  вернулся человек,
[01:08:52.160 --> 01:08:54.160]  которого звали вот так.
[01:08:54.160 --> 01:08:56.160]  Намекает, что у него
[01:08:56.160 --> 01:08:58.160]  очень большая буква в имени,
[01:08:58.160 --> 01:09:00.160]  поэтому он стал президентом этого парламента.
[01:09:00.160 --> 01:09:02.160]  Но он ничего не знает за 6 месяцев,
[01:09:02.160 --> 01:09:04.160]  чем парламент занимался.
[01:09:04.160 --> 01:09:06.160]  Но тем не менее он становится
[01:09:06.160 --> 01:09:08.160]  этим лидером парламента
[01:09:08.160 --> 01:09:10.160]  с пустыми записями.
[01:09:10.160 --> 01:09:12.160]  Это корректность не ломает,
[01:09:12.160 --> 01:09:14.160]  но это задерживает прогресс
[01:09:14.160 --> 01:09:16.160]  всей системы.
[01:09:16.160 --> 01:09:18.160]  Наверное, так в продакшене делать не стоит.
[01:09:18.160 --> 01:09:20.160]  И в следующий раз,
[01:09:20.160 --> 01:09:22.160]  когда у нас будет алгоритм RAFT,
[01:09:22.160 --> 01:09:24.160]  мы увидим, что в этом алгоритме
[01:09:24.160 --> 01:09:26.160]  лидер выбирается...
[01:09:26.160 --> 01:09:28.160]  В RAFT все сложнее,
[01:09:28.160 --> 01:09:30.160]  потому что там
[01:09:30.160 --> 01:09:32.160]  протокол репликации
[01:09:32.160 --> 01:09:34.160]  и выбор лидера, они друг с другом связаны.
[01:09:34.160 --> 01:09:36.160]  У нас они перпендикулярно там связаны.
[01:09:36.160 --> 01:09:38.160]  Это очень важное отличие.
[01:09:38.160 --> 01:09:40.160]  И мы поймем, почему скоро.
[01:09:40.160 --> 01:09:42.160]  Но
[01:09:42.160 --> 01:09:44.160]  сбился смысл в свои.
[01:09:46.160 --> 01:09:48.160]  Да, и в RAFT
[01:09:48.160 --> 01:09:50.160]  лидер выбирается не абы как,
[01:09:50.160 --> 01:09:52.160]  он выбирается только среди тех узлов,
[01:09:52.160 --> 01:09:54.160]  у которых лог достаточно полный.
[01:09:54.160 --> 01:09:56.160]  Там невозможно
[01:09:56.160 --> 01:09:58.160]  выбрать лидера, у которого пустой лог.
[01:09:58.160 --> 01:10:00.160]  С другой стороны, там можно вообще
[01:10:00.160 --> 01:10:02.160]  не выбрать лидера, тогда вообще ничего сделать нельзя,
[01:10:02.160 --> 01:10:04.160]  потому что без лидера протокол работать не будет.
[01:10:08.160 --> 01:10:10.160]  Что?
[01:10:12.160 --> 01:10:14.160]  Ну, лидер это, как написано
[01:10:14.160 --> 01:10:16.160]  на тиске, выделенный пропозер.
[01:10:16.160 --> 01:10:18.160]  Это узел, который предлагает команда.
[01:10:18.160 --> 01:10:20.160]  И он нужен другим
[01:10:20.160 --> 01:10:22.160]  для того, чтобы...
[01:10:22.160 --> 01:10:24.160]  Мы его выбираем затем, чтобы
[01:10:24.160 --> 01:10:26.160]  пропозеры, реплики не конкурировали.
[01:10:26.160 --> 01:10:28.160]  У нас три реплики,
[01:10:28.160 --> 01:10:30.160]  чтобы среди них был только один пропозер,
[01:10:30.160 --> 01:10:32.160]  и он спокойно проходил через две фазы паксиса,
[01:10:32.160 --> 01:10:34.160]  и система совершала прогресс.
[01:10:34.160 --> 01:10:36.160]  Никто ему бы не мешал.
[01:10:36.160 --> 01:10:38.160]  Мы можем выбрать
[01:10:38.160 --> 01:10:40.160]  двух разных лидеров,
[01:10:40.160 --> 01:10:42.160]  может случиться так, что в системе может быть несколько лидеров,
[01:10:42.160 --> 01:10:44.160]  но это неизбежно.
[01:10:44.160 --> 01:10:46.160]  Но сам протокол паксис к этому устойчив,
[01:10:46.160 --> 01:10:48.160]  потому что он заточен
[01:10:48.160 --> 01:10:50.160]  под разных пропозеров, которые
[01:10:50.160 --> 01:10:52.160]  являются лидером.
[01:10:54.160 --> 01:10:56.160]  Окей.
[01:11:00.160 --> 01:11:02.160]  Промежуточный итог.
[01:11:02.160 --> 01:11:04.160]  Чего мы достигли в текущем моменту?
[01:11:04.160 --> 01:11:06.160]  Мы построили вот такой вот...
[01:11:06.160 --> 01:11:08.160]  В целом, это уже можно написать.
[01:11:08.160 --> 01:11:10.160]  Если вы это напишете, уже будет радость,
[01:11:10.160 --> 01:11:12.160]  я буду делать еще крышей кавери.
[01:11:12.160 --> 01:11:14.160]  Значит, вы
[01:11:14.160 --> 01:11:16.160]  взяли три реплики.
[01:11:20.160 --> 01:11:22.160]  Взяли клиента.
[01:11:22.160 --> 01:11:24.160]  И он приходит в вашу систему и задает запрос.
[01:11:26.160 --> 01:11:28.160]  Давайте пронумеруем.
[01:11:30.160 --> 01:11:32.160]  Один, два, три.
[01:11:32.160 --> 01:11:34.160]  И вот это лидер сейчас.
[01:11:40.160 --> 01:11:42.160]  Значит, вы клиент, вы приходите со своей командой,
[01:11:42.160 --> 01:11:44.160]  отправляете ее на какую-то машину.
[01:11:46.160 --> 01:11:48.160]  Эта машина смотрит на
[01:11:48.160 --> 01:11:50.160]  свой модуль выбора лидера, понимает, что она
[01:11:50.160 --> 01:11:52.160]  не лидер. Она предлагать команду не может.
[01:11:52.160 --> 01:11:54.160]  Она говорит, лидер, предложи.
[01:11:54.160 --> 01:11:56.160]  Лидер предлагает.
[01:11:56.160 --> 01:11:58.160]  Он говорит, prepare,
[01:11:58.160 --> 01:12:00.160]  выбирает слот, говорит,
[01:12:00.160 --> 01:12:02.160]  prepare,
[01:12:02.160 --> 01:12:04.160]  promise,
[01:12:04.160 --> 01:12:06.160]  accept,
[01:12:06.160 --> 01:12:08.160]  accept.
[01:12:08.160 --> 01:12:10.160]  После этого префикс лога
[01:12:10.160 --> 01:12:12.160]  закомитился, допустим.
[01:12:12.160 --> 01:12:14.160]  Мы применили команду.
[01:12:16.160 --> 01:12:18.160]  Мы вернули результат
[01:12:18.160 --> 01:12:20.160]  сюда.
[01:12:20.160 --> 01:12:22.160]  И вернули пользователя.
[01:12:22.160 --> 01:12:24.160]  Вот получилось
[01:12:26.160 --> 01:12:28.160]  четыре раунд три.
[01:12:28.160 --> 01:12:30.160]  Вот так делать нельзя, конечно.
[01:12:30.160 --> 01:12:32.160]  Но потому что очень медленно.
[01:12:34.160 --> 01:12:36.160]  Как сделать лучше?
[01:12:42.160 --> 01:12:44.160]  Вот где здесь есть откровенная
[01:12:44.160 --> 01:12:46.160]  тупизна?
[01:12:46.160 --> 01:12:48.160]  Что значит справой?
[01:12:50.160 --> 01:12:52.160]  Нет, ну есть
[01:12:52.160 --> 01:12:54.160]  и есть,
[01:12:54.160 --> 01:12:56.160]  но и есть.
[01:12:56.160 --> 01:12:58.160]  Вот это
[01:12:58.160 --> 01:13:00.160]  в этом
[01:13:00.160 --> 01:13:02.160]  и есть.
[01:13:02.160 --> 01:13:04.160]  И есть.
[01:13:04.160 --> 01:13:06.160]  И есть.
[01:13:06.160 --> 01:13:08.160]  И есть.
[01:13:08.160 --> 01:13:10.160]  И есть.
[01:13:10.160 --> 01:13:12.160]  И есть.
[01:13:12.160 --> 01:13:14.160]  И есть.
[01:13:14.160 --> 01:13:21.160]  Нет, ну еще раз, ты всегда собираешь корм с теми, кто быстрее, там с кем собрался, те и молодцы.
[01:13:21.160 --> 01:13:25.160]  Ты не выбираешь, кто из них лучше, а кто хуже, ты отправляешь всем, кто быстрее ответил, то ты...
[01:13:25.160 --> 01:13:32.160]  Не, я имею в виду, если нам вот левая рептика отправила команду, значит она уже как бы ответила.
[01:13:32.160 --> 01:13:37.160]  Она с клиентом общалась, кто ему будет еще отвечать.
[01:13:37.160 --> 01:13:42.160]  Ну, смотрите, мы выбираем лидера надолго.
[01:13:42.160 --> 01:13:46.160]  Вот в продакшене у вас лидер может жить неделями, скажем, ну неделя может жить.
[01:13:46.160 --> 01:13:49.160]  Никто ему не помешает, если работает хорошо.
[01:13:49.160 --> 01:13:53.160]  Поэтому вот зачем нам тратить вот этот случайный хоп?
[01:13:53.160 --> 01:13:56.160]  Вместо этого давайте...
[01:13:56.160 --> 01:14:04.160]  Вот если мы клиент, и если у нас есть вот эта машина лидер,
[01:14:04.160 --> 01:14:09.160]  то если мы придем не к лидеру сначала, это было 1.7,
[01:14:09.160 --> 01:14:15.160]  приходим к неридеру, то вместо того, чтобы фарвардить команду к лидеру,
[01:14:15.160 --> 01:14:19.160]  эта реплика скажет клиенту редирект.
[01:14:25.160 --> 01:14:30.160]  А клиенту себя закаширует, что лидер сейчас 3 и будет ходить к нему сразу потом.
[01:14:30.160 --> 01:14:33.160]  Ну то есть в первый раз он сделает лишний хоп,
[01:14:33.160 --> 01:14:39.160]  а дальше будет потенциально бесконечное время экономить себе 1 раунд трип.
[01:14:39.160 --> 01:14:45.160]  В итоге мы получим не 4 RTT, а 3 RTT, потому что вот этот 1 лишний точно будет.
[01:14:51.160 --> 01:14:53.160]  Странный вопрос.
[01:14:53.160 --> 01:15:04.160]  Еще раз, в алгоритме ПАКСС выбор лидера перпендикулярен сейфти.
[01:15:04.160 --> 01:15:10.160]  Можно выбирать лидера неправильно и постоянно неправильно.
[01:15:10.160 --> 01:15:12.160]  То есть разные узлы могут выбирать разных лидеров,
[01:15:12.160 --> 01:15:16.160]  в смысле они могут считать лидерами разные реплики.
[01:15:16.160 --> 01:15:19.160]  Эта корректность на корректность не влияет.
[01:15:19.160 --> 01:15:21.160]  Твоя задача построить такой протокол выбора лидера,
[01:15:21.160 --> 01:15:25.160]  который, когда все хорошо, позволяет поддерживать одного и того же лидера,
[01:15:25.160 --> 01:15:27.160]  не меняя его постоянно.
[01:15:27.160 --> 01:15:34.160]  Вот если мы эту задачу решили, то мы считаем, что наша процедура довольно успешна.
[01:15:34.160 --> 01:15:41.160]  Если вместо того, чтобы углубить так вызовов, мы сделаем редирект,
[01:15:41.160 --> 01:15:47.160]  то мы дальше долгое время будем ходить сразу к лидеру и экономить 1 RTT.
[01:15:47.160 --> 01:15:51.160]  Когда-нибудь наш кэш протухнет, потому что лидер поменяется.
[01:15:51.160 --> 01:15:56.160]  Узнаем нового и будем ходить дальше к новому.
[01:15:56.160 --> 01:16:02.160]  Это было очевидно, можно было и не говорить.
[01:16:02.160 --> 01:16:06.160]  А теперь самое главное.
[01:16:06.160 --> 01:16:10.160]  Все это можно было бы уже считать мультипакссом,
[01:16:10.160 --> 01:16:16.160]  но можно и не считать, потому что это каждому дураку понятно.
[01:16:16.160 --> 01:16:20.160]  Все, что было до этого момента.
[01:16:20.160 --> 01:16:24.160]  В принципе, можно на этом в домашней части ограничиться.
[01:16:24.160 --> 01:16:27.160]  Уже будет достижением некоторым.
[01:16:27.160 --> 01:16:30.160]  Но мультипаксс по-настоящему появляется тогда,
[01:16:30.160 --> 01:16:33.160]  когда мы делаем вторую важную оптимизацию, помимо выбора лидера.
[01:16:33.160 --> 01:16:37.160]  И без нее мультипаксс не мультипаксс, конечно.
[01:16:47.160 --> 01:16:51.160]  Итак, у нас есть две реплики.
[01:16:51.160 --> 01:16:55.160]  Внутри реплики есть следей них лидер и есть какая-то.
[01:16:58.160 --> 01:17:02.160]  Вот мы сказали, что хотим заполнять логи параллельно.
[01:17:02.160 --> 01:17:05.160]  Если у нас есть две команды, положим их в первый, в второй, в третий.
[01:17:05.160 --> 01:17:07.160]  Сразу запустим там паксс.
[01:17:07.160 --> 01:17:10.160]  Вот давайте так делать не будем прямо сейчас,
[01:17:10.160 --> 01:17:12.160]  а будем делать хуже.
[01:17:12.160 --> 01:17:14.160]  Будем заполнять логи последовательно.
[01:17:14.160 --> 01:17:17.160]  Почему-то это нам способно помочь.
[01:17:18.160 --> 01:17:20.160]  Итак, смотрите.
[01:17:20.160 --> 01:17:23.160]  Я лидер, я получаю команду от клиента.
[01:17:23.160 --> 01:17:25.160]  Я говорю...
[01:17:28.160 --> 01:17:35.160]  prepare, slot k, ballot number n.
[01:17:35.160 --> 01:17:37.160]  Ну и все.
[01:17:37.160 --> 01:17:40.160]  Мне другая реплика отвечает.
[01:17:40.160 --> 01:17:42.160]  Promise.
[01:17:44.160 --> 01:17:46.160]  Я говорю, здорово.
[01:17:46.160 --> 01:17:48.160]  Теперь accept.
[01:17:51.160 --> 01:17:56.160]  Accept, k, slot k, ballot number n, значение...
[01:17:56.160 --> 01:17:58.160]  Ну какое-то c.
[01:17:58.160 --> 01:18:00.160]  Команда c.
[01:18:00.160 --> 01:18:02.160]  Она отвечает.
[01:18:02.160 --> 01:18:03.160]  Принято.
[01:18:03.160 --> 01:18:05.160]  Вот я закомитил команду.
[01:18:07.160 --> 01:18:11.160]  Теперь я начинаю следующий слот.
[01:18:12.160 --> 01:18:14.160]  Говорю...
[01:18:17.160 --> 01:18:22.160]  prepare, k плюс 1, какой-то n штрих.
[01:18:22.160 --> 01:18:24.160]  Ну n штрих какой-то.
[01:18:24.160 --> 01:18:26.160]  Получаю снова promise.
[01:18:31.160 --> 01:18:33.160]  И дальше accept.
[01:18:33.160 --> 01:18:39.160]  k плюс 1, n штрих.
[01:18:39.160 --> 01:18:41.160]  Какая-то команда c штрих.
[01:18:42.160 --> 01:18:44.160]  Ну вот делаю подряд.
[01:18:44.160 --> 01:18:47.160]  Прохожу первую фазу, вторую фазу, первую фазу, вторую фазу.
[01:18:49.160 --> 01:18:52.160]  Вот представьте, что вы процессор.
[01:18:52.160 --> 01:18:56.160]  Собственно, поэтому я всякие мувовые джампы рисовал.
[01:18:56.160 --> 01:18:58.160]  И вот у вас есть команда.
[01:18:58.160 --> 01:19:01.160]  Вот у вас есть instruction pointer, он двигается вниз.
[01:19:01.160 --> 01:19:06.160]  И вот циклы, которыми вы работаете.
[01:19:06.160 --> 01:19:08.160]  И вот у вас есть инструкция.
[01:19:08.160 --> 01:19:12.160]  Там есть фазы fetch, decode, execute, writeback.
[01:19:12.160 --> 01:19:14.160]  Ну какие-то условные фазы.
[01:19:14.160 --> 01:19:16.160]  Не думаю, что они буквально соблюдаются.
[01:19:16.160 --> 01:19:19.160]  Но об этом можно было бы так думать.
[01:19:19.160 --> 01:19:23.160]  Вот чтобы выполнить инструкцию, нужно сначала загрузить ее из памяти.
[01:19:23.160 --> 01:19:25.160]  Потом декодировать ее внутри.
[01:19:25.160 --> 01:19:27.160]  Потом, собственно, как-то ее исполнить.
[01:19:27.160 --> 01:19:29.160]  Потом записать следы обратно в память.
[01:19:29.160 --> 01:19:31.160]  Потом у вас есть вторая инструкция.
[01:19:34.160 --> 01:19:42.160]  И вы говорите такие fetch, execute, fetch, decode, execute, writeback.
[01:19:42.160 --> 01:19:44.160]  Потом третий и так далее.
[01:19:44.160 --> 01:19:50.160]  Вот если вы так будете делать, то ваш компьютер будет работать бесконечно долго.
[01:19:50.160 --> 01:19:57.160]  Вместо этого вы можете заметить, что, видимо, шаги в этих инструкциях разные,
[01:19:57.160 --> 01:19:59.160]  потому что они проразные.
[01:19:59.160 --> 01:20:04.160]  Видимо, они выполняются разными какими-то модулями, блоками в процессоре,
[01:20:04.160 --> 01:20:06.160]  какими-то разными частями схемы.
[01:20:06.160 --> 01:20:10.160]  Поэтому вы говорите, что пока я декодирую первую инструкцию,
[01:20:10.160 --> 01:20:13.160]  я уже буду загружать вторую инструкцию.
[01:20:16.160 --> 01:20:20.160]  А когда я выполняю первую инструкцию, я буду декодировать вторую
[01:20:20.160 --> 01:20:22.160]  и загружать третью инструкцию.
[01:20:22.160 --> 01:20:24.160]  Вот это называется конвер.
[01:20:28.160 --> 01:20:34.160]  Конвер – это сложно, потому что нужно хорошо предсказывать следующие инструкции.
[01:20:34.160 --> 01:20:38.160]  Нужен бранч-предиктор аккуратно, и нужно, чтобы зависимости между инструкциями
[01:20:38.160 --> 01:20:40.160]  не было, чтобы все хорошо сложилось.
[01:20:40.160 --> 01:20:42.160]  Но в идеале все вот так.
[01:20:45.160 --> 01:20:49.160]  А у нас же тоже такие вот инструкции, которые есть двумя инструкциями.
[01:20:49.160 --> 01:20:53.160]  А у нас же тоже такие вот инструкции, которые из двух фаз состоят.
[01:20:54.160 --> 01:20:56.160]  И что можно заметить?
[01:20:56.160 --> 01:21:05.160]  Что в фазе accept в слоте K и в фазе prepare в слоте K плюс 1
[01:21:05.160 --> 01:21:10.160]  эти два консенсуса друг с другом напрямую никак не связаны.
[01:21:11.160 --> 01:21:14.160]  У них разные слоты и, вообще говоря, разные N.
[01:21:14.160 --> 01:21:18.160]  А может быть, не нужно N как-то независимой.
[01:21:18.160 --> 01:21:21.160]  Может быть, можно воспользоваться тем, что N у нас будет одинаковая.
[01:21:21.160 --> 01:21:24.160]  Независимые поэтому могут быть и одинаковыми.
[01:21:30.160 --> 01:21:33.160]  То есть выберем для слотов одно и то же N.
[01:21:33.160 --> 01:21:39.160]  А потом подумаем, почему мы вообще делаем prepare K плюс 1
[01:21:39.160 --> 01:21:43.160]  после accept на слоте K?
[01:21:44.160 --> 01:21:48.160]  Ведь для этого prepare даже команда не нужна.
[01:21:49.160 --> 01:21:55.160]  То есть у нас была одна команда, мы ее получили и прошли через два фазы.
[01:21:55.160 --> 01:21:57.160]  Следующей команды у нас еще нет.
[01:21:57.160 --> 01:22:05.160]  Но это же нам не мешает взять и пройти prepare сразу вот здесь.
[01:22:15.160 --> 01:22:21.160]  То есть когда мы отправляем команду accept в слоте K
[01:22:21.160 --> 01:22:24.160]  с ballot number N и командой C,
[01:22:24.160 --> 01:22:29.160]  мы можем в этом же сообщении сразу сделать prepare для слота K плюс 1.
[01:22:29.160 --> 01:22:35.160]  И тогда, когда нам придет команда C штрих,
[01:22:35.160 --> 01:22:40.160]  то мы ее получим от пользователя раз хоп,
[01:22:40.160 --> 01:22:43.160]  а потом сразу перейдем к фазе accept.
[01:22:43.160 --> 01:22:46.160]  Второй хоп, но второй round trip.
[01:22:48.160 --> 01:22:54.160]  Мы не будем проходить после получения команды от пользователя
[01:22:54.160 --> 01:22:57.160]  через две фазы, потому что через первую фазу мы уже прошли,
[01:22:57.160 --> 01:23:01.160]  потому что эта фаза не зависела от самой команды.
[01:23:03.160 --> 01:23:05.160]  И мы эту фазу уже прошли раньше.
[01:23:05.160 --> 01:23:10.160]  То есть мы комития слот K
[01:23:10.160 --> 01:23:14.160]  заодно прогреваем для будущей записи слот K плюс 1.
[01:23:14.160 --> 01:23:18.160]  Ну а теперь можно задуматься, а почему мы прогреваем только один слот?
[01:23:18.160 --> 01:23:23.160]  Давайте сделаем вместе с этим prepare еще один prepare
[01:23:26.160 --> 01:23:28.160]  K плюс 2.
[01:23:30.160 --> 01:23:34.160]  Но можно сделать три prepare.
[01:23:34.160 --> 01:23:42.160]  То есть мы говорим с одной стороны accept.
[01:23:42.160 --> 01:23:45.160]  Да, конечно же эта малина может сломаться,
[01:23:45.160 --> 01:23:47.160]  потому что мы сделаем это prepare.
[01:23:47.160 --> 01:23:51.160]  Мы прогрели будущий слот, потом сразу закомитили,
[01:23:51.160 --> 01:23:54.160]  потом прогрели будущий слот, потом сразу закомитили в один хоп.
[01:23:54.160 --> 01:23:57.160]  А потом делаем сразу accept, а он обламывается,
[01:23:57.160 --> 01:24:00.160]  потому что появился какой-то другой конкурент,
[01:24:00.160 --> 01:24:03.160]  конкурирующий с нами лидер, и он нас перебил.
[01:24:03.160 --> 01:24:05.160]  Ну это просто сброс конвейера.
[01:24:05.160 --> 01:24:08.160]  Тогда мы откатываемся на первую фазу, сделаем все заново.
[01:24:08.160 --> 01:24:14.160]  Но если такого нет, то можно это дооптимизировать до каких-то безумных пределов.
[01:24:14.160 --> 01:24:20.160]  А именно, вот выполняя accept для слота K с ballot number N
[01:24:20.160 --> 01:24:22.160]  и какой-то командой C,
[01:24:22.160 --> 01:24:33.160]  можно к нему прицепить prepare K плюс 1 N,
[01:24:33.160 --> 01:24:38.160]  пользуясь тем, что у нас команды не требуются для prepare,
[01:24:38.160 --> 01:24:42.160]  а ballot number независимая, поэтому пусть будет одни и те же K плюс 2 N.
[01:24:42.160 --> 01:24:45.160]  Ну и когда мы остановимся?
[01:24:48.160 --> 01:24:51.160]  Мы не остановимся никогда.
[01:24:51.160 --> 01:24:55.160]  Мы отправим prepare такого вида.
[01:24:55.160 --> 01:25:02.160]  Prepar, который говорит, я хочу захватить все слоты, начиная с K.
[01:25:02.160 --> 01:25:05.160]  Да, все слоты начиная с K.
[01:25:05.160 --> 01:25:09.160]  И если accept получит этот prepare и увидит, что у него все слоты пустые,
[01:25:09.160 --> 01:25:14.160]  то он у себя запомнит, что начиная с некоторого суффикса K,
[01:25:14.160 --> 01:25:19.160]  с некоторой позиции K, как будто бы для всех слотов
[01:25:19.160 --> 01:25:23.160]  этот accept получил команду prepare с ballot number N.
[01:25:23.160 --> 01:25:28.160]  То есть это бесконечно много prepare, но они описываются просто одной записью.
[01:25:32.160 --> 01:25:36.160]  Ну а дальше, после того, как мы захватили бесконечную суффикс лога,
[01:25:36.160 --> 01:25:39.160]  можно в одну фазу коммитить свои команды.
[01:25:39.160 --> 01:25:43.160]  И так мы избавляемся от еще одного round trip.
[01:25:50.160 --> 01:25:53.160]  Но мы одну посылаем.
[01:25:53.160 --> 01:25:56.160]  У нее просто бесконечный смысл.
[01:26:00.160 --> 01:26:03.160]  Ну короче, придумай, как правильно сказать об этом, а ты меня понял.
[01:26:03.160 --> 01:26:08.160]  То есть мы говорим prepare на каждом будущем слоте, начиная с K.
[01:26:08.160 --> 01:26:11.160]  Прямо на бесконечности.
[01:26:11.160 --> 01:26:15.160]  Реплика запоминает, что все слоты, начиная с K,
[01:26:15.160 --> 01:26:20.160]  они захвачены пропозером, который прислал этот prepare,
[01:26:20.160 --> 01:26:23.160]  с ballot number N.
[01:26:23.160 --> 01:26:31.160]  Если вдруг acceptor получит какой-то узел, который дал такое бесконечное обещание,
[01:26:31.160 --> 01:26:34.160]  получит какой-то prepare с большим номером для какого-то слота,
[01:26:34.160 --> 01:26:36.160]  то он может про него забыть.
[01:26:36.160 --> 01:26:39.160]  Сказать, что все больше невалидно.
[01:26:39.160 --> 01:26:43.160]  А acceptor, видимо, этот пропозер перестанет на это надеяться
[01:26:43.160 --> 01:26:46.160]  и откатится обратно на первую фазу.
[01:26:46.160 --> 01:26:49.160]  Но если ему удалось на quorum собрать такие бесконечные prepare,
[01:26:49.160 --> 01:26:54.160]  то он захватил суффиксы лога и может коммитить все в один round trip.
[01:26:56.160 --> 01:26:58.160]  И смотрите, что получается.
[01:26:58.160 --> 01:27:04.160]  За один хоб мы кашируем лидера на клиенте, попадаем сразу в него,
[01:27:04.160 --> 01:27:08.160]  а этот лидер, пользуясь тем, что он уже прогрел все суффиксы лога,
[01:27:08.160 --> 01:27:11.160]  приходит к фазе accept.
[01:27:11.160 --> 01:27:14.160]  Два RTT в итоге.
[01:27:14.160 --> 01:27:16.160]  И что получилось?
[01:27:16.160 --> 01:27:21.160]  С одной стороны, мы реплицируем таким образом произвольный автомат
[01:27:21.160 --> 01:27:24.160]  с произвольными операциями.
[01:27:24.160 --> 01:27:29.160]  На что, скажем, алгоритм со второй лекции был неспособен, который мы писали.
[01:27:29.160 --> 01:27:34.160]  И при этом мы в нем делаем всего лишь одну фазу.
[01:27:34.160 --> 01:27:37.160]  Собираем всего лишь один quorum синхронно.
[01:27:37.160 --> 01:27:39.160]  Там было два quorums.
[01:27:39.160 --> 01:27:42.160]  То есть мы решили более общую задачу и еще и быстрее.
[01:27:42.160 --> 01:27:45.160]  Ну, по крайней мере, на быстром пути быстрее.
[01:27:45.160 --> 01:27:48.160]  Иногда, конечно, так же, но это случается, допустим, редко,
[01:27:48.160 --> 01:27:52.160]  если у нас сеть работает стабильно достаточно.
[01:27:52.160 --> 01:27:57.160]  То есть мы решили более общую задачу более эффективно,
[01:27:57.160 --> 01:28:00.160]  и при этом мы не потеряли коллекции нигде.
[01:28:00.160 --> 01:28:03.160]  Да, мы как будто делаем одну фазу, но на самом деле мы не делаем одну фазу,
[01:28:03.160 --> 01:28:04.160]  мы делаем две фазы.
[01:28:04.160 --> 01:28:08.160]  Просто одна фаза делается таким батчем неявно.
[01:28:08.160 --> 01:28:12.160]  Но при этом внутри каждого слота у вас алгоритм проходит
[01:28:12.160 --> 01:28:17.160]  все-таки через две фазы, вы можете их восстановить логически.
[01:28:17.160 --> 01:28:19.160]  Ну, если вы все корректно написали, конечно.
[01:28:19.160 --> 01:28:24.160]  То есть мы по-прежнему пользуемся тем, что Paxos у нас работает в каждом слоте.
[01:28:24.160 --> 01:28:30.160]  Просто одну фазу, первую фазу для разных слотов мы склеили в одно сообщение
[01:28:30.160 --> 01:28:35.160]  и сделали один раз общий.
[01:28:35.160 --> 01:28:40.160]  Вот то, что получилось, называется multipaxos.
[01:28:41.160 --> 01:28:44.160]  Что?
[01:28:59.160 --> 01:29:04.160]  И смотрите, вот теперь, во-первых, понятна ли оптимизация?
[01:29:04.160 --> 01:29:07.160]  Понятна ли аналогия с конвейером, с бросом конвейера и всем этим?
[01:29:07.160 --> 01:29:10.160]  Если понятно, то это для нас очень полезный момент,
[01:29:10.160 --> 01:29:13.160]  потому что теперь можно объяснить, что значили все эти n, n-p,
[01:29:13.160 --> 01:29:16.160]  и вот вся эта дичь, p-r и promise.
[01:29:16.160 --> 01:29:20.160]  Потому что вот в этом алгоритме у них никакого смысла конкретного не было.
[01:29:20.160 --> 01:29:22.160]  Невозможно было объяснить, что это все значит.
[01:29:22.160 --> 01:29:28.160]  Теперь, имея multipaxos, можно легко объяснить, что такое n.
[01:29:28.160 --> 01:29:32.160]  Вот смотрите, мы здесь, мы лидер, берем это n
[01:29:32.160 --> 01:29:38.160]  и с помощью него захватываем все будущие слоты лога.
[01:29:38.160 --> 01:29:40.160]  Кто нам способен помешать в будущем?
[01:29:40.160 --> 01:29:44.160]  Какой-нибудь новый лидер, который, видимо, выберет больше n.
[01:29:44.160 --> 01:29:49.160]  Так вот, как же можно было бы это n назвать? Каким словом?
[01:29:54.160 --> 01:29:57.160]  Совсем не постарался.
[01:29:57.160 --> 01:30:03.160]  Вот, кто-то говорит слово поколение, это хорошая идея.
[01:30:03.160 --> 01:30:06.160]  Поколение, эпоха.
[01:30:06.160 --> 01:30:10.160]  Ну и не знаю, можно думать, это бесконечное количество людовиков,
[01:30:10.160 --> 01:30:13.160]  которые нумируются, они приходят к власти,
[01:30:13.160 --> 01:30:16.160]  у них новый номер больше, чем предыдущий.
[01:30:16.160 --> 01:30:18.160]  Вот здесь то же самое, у вас новый лидер,
[01:30:18.160 --> 01:30:20.160]  то есть, конечно, тут вообще n и лидеры независимы,
[01:30:20.160 --> 01:30:23.160]  то есть процедура выбора лидера никак совершенно не завязана.
[01:30:23.160 --> 01:30:25.160]  Ну во-первых, рафта завязана,
[01:30:25.160 --> 01:30:29.160]  ну и как бы по смыслу это явно должно быть согласовано,
[01:30:29.160 --> 01:30:31.160]  то есть вы выбираете нового лидера,
[01:30:31.160 --> 01:30:35.160]  и он должен захватить все слоты в логе,
[01:30:35.160 --> 01:30:37.160]  начиная с некоторого k.
[01:30:37.160 --> 01:30:40.160]  Для этого ему нужно выбрать n больше, чем был раньше.
[01:30:40.160 --> 01:30:44.160]  Вот, так что это вот n, давайте где-то это писать.
[01:30:44.160 --> 01:30:46.160]  N это эпоха.
[01:30:46.160 --> 01:30:48.160]  В рафте это называется термом,
[01:30:48.160 --> 01:30:50.160]  ну по смыслу эпоха поколения.
[01:30:50.160 --> 01:30:54.160]  А что такое np у аксептора?
[01:30:54.160 --> 01:30:58.160]  Вот мы, во-первых, сравниваем n и np,
[01:30:58.160 --> 01:31:02.160]  и если n больше, чем np, то мы np обновляем,
[01:31:02.160 --> 01:31:04.160]  а если меньше, то отвергаем.
[01:31:04.160 --> 01:31:08.160]  Что? Я какую-то шутку пропустил, мне обидно сейчас.
[01:31:08.160 --> 01:31:10.160]  Кто-нибудь.
[01:31:10.160 --> 01:31:12.160]  Да, вот именно так.
[01:31:12.160 --> 01:31:16.160]  То есть у нас каждый аксептор сейчас слушает
[01:31:16.160 --> 01:31:19.160]  какого-то лидера с каким-то n.
[01:31:19.160 --> 01:31:21.160]  Вот мы помним его поколение.
[01:31:21.160 --> 01:31:23.160]  Вот, вот, вот.
[01:31:23.160 --> 01:31:25.160]  Вот, вот.
[01:31:25.160 --> 01:31:27.160]  Вот, вот.
[01:31:27.160 --> 01:31:29.160]  Вот, вот.
[01:31:29.160 --> 01:31:31.160]  Вот, вот.
[01:31:32.160 --> 01:31:34.160]  Вот мы помним его поколение.
[01:31:34.160 --> 01:31:38.160]  Когда мы получаем prepare n и сравниваем,
[01:31:38.160 --> 01:31:41.160]  и оказывается, что np больше, чем n,
[01:31:41.160 --> 01:31:43.160]  и мы отвергаем это сообщение, то что это означает?
[01:31:43.160 --> 01:31:46.160]  То, что мы отвергаем о кого-то старого лидера.
[01:31:46.160 --> 01:31:48.160]  Когда мы обновляем np,
[01:31:48.160 --> 01:31:51.160]  потому что оно было больше, оно было меньше, чем n,
[01:31:51.160 --> 01:31:53.160]  то это означает, что мы просто услышали нового лидера
[01:31:53.160 --> 01:31:55.160]  и переходим в его эпоху.
[01:31:55.160 --> 01:31:59.160]  И даем обещание вот здесь вот старых лидеров не слушать.
[01:31:59.160 --> 01:32:01.160]  Вот.
[01:32:01.160 --> 01:32:03.160]  А что такое prepare accept?
[01:32:05.160 --> 01:32:07.160]  Ну вот prepare сообщение общее
[01:32:07.160 --> 01:32:08.160]  это такое утверждение лидерства.
[01:32:08.160 --> 01:32:10.160]  То есть я говорю, я лидер, мне говорят, хорошо.
[01:32:10.160 --> 01:32:12.160]  Наверное присягивал.
[01:32:12.160 --> 01:32:14.160]  Да.
[01:32:15.160 --> 01:32:17.160]  Как удачно ты зашел с души.
[01:32:17.160 --> 01:32:20.160]  Вот просто идеально подбираешь нужные слова.
[01:32:20.160 --> 01:32:22.160]  Значит, здесь они нам присягают,
[01:32:22.160 --> 01:32:25.160]  а тут мы просто реплицируем команду.
[01:32:25.160 --> 01:32:28.160]  И на быстром пути у нас выполняется только репликация теперь.
[01:32:30.160 --> 01:32:32.160]  То есть когда нам приходит клиент,
[01:32:32.160 --> 01:32:34.160]  он отправляет команду сразу лидеру,
[01:32:34.160 --> 01:32:36.160]  этот лидер сразу проходит через фазу accept,
[01:32:36.160 --> 01:32:38.160]  то есть реплицирует ее сразу.
[01:32:39.160 --> 01:32:42.160]  Ну потому что ему и так уже все верят.
[01:32:45.160 --> 01:32:46.160]  Что?
[01:32:46.160 --> 01:32:48.160]  Ну пока не появится новый, и все это как-то не собьется.
[01:32:51.160 --> 01:32:53.160]  Ну все здорово,
[01:32:53.160 --> 01:32:55.160]  только тут можно задуматься.
[01:32:59.160 --> 01:33:03.160]  Мы с вами уже месяц приходим сюда с субботом
[01:33:03.160 --> 01:33:06.160]  и придумали следующий алгоритм.
[01:33:06.160 --> 01:33:09.160]  У нас есть клиент, он посылает команду лидеру,
[01:33:09.160 --> 01:33:12.160]  лидер пишет ее на Quorum и подожидает ее нам.
[01:33:12.160 --> 01:33:14.160]  Это какое-то очень скромное достижение,
[01:33:14.160 --> 01:33:17.160]  можно подумать, что это можно было придумать гораздо быстрее.
[01:33:17.160 --> 01:33:19.160]  Так вот, нет, нельзя было.
[01:33:19.160 --> 01:33:25.160]  Потому что, да, 99,9% времени работает такой алгоритм,
[01:33:25.160 --> 01:33:27.160]  который придумывает любой школьник.
[01:33:27.160 --> 01:33:31.160]  Но с другой стороны, когда-то лидер меняется.
[01:33:31.160 --> 01:33:33.160]  И вот тогда происходят все сложности.
[01:33:33.160 --> 01:33:35.160]  Нужно аккуратно перейти от старого к новому
[01:33:35.160 --> 01:33:37.160]  и ничего не потерять.
[01:33:37.160 --> 01:33:39.160]  То есть все команды, которые применены,
[01:33:39.160 --> 01:33:41.160]  должны переехать в новую эпоху и не потеряться там.
[01:33:41.160 --> 01:33:43.160]  Вот ровно для этого алгоритм контакта.
[01:33:43.160 --> 01:33:45.160]  Вот был озвучен некоторое вранье,
[01:33:45.160 --> 01:33:47.160]  что алгоритм консенсуса нужен для того,
[01:33:47.160 --> 01:33:49.160]  чтобы выбирать очередное сообщение.
[01:33:49.160 --> 01:33:51.160]  Разумеется, нет, он не для этого нужен.
[01:33:51.160 --> 01:33:54.160]  Алгоритм консенсуса не про выбор очередного сообщения.
[01:33:54.160 --> 01:33:56.160]  Это просто дело лидер.
[01:33:56.160 --> 01:33:58.160]  Просто выбирал у себя там очередное сообщение,
[01:33:58.160 --> 01:34:00.160]  которое он поставит в очередной слот.
[01:34:00.160 --> 01:34:02.160]  Алгоритм консенсуса Single Decree Paxos
[01:34:02.160 --> 01:34:05.160]  это не выбор очередного сообщения,
[01:34:05.160 --> 01:34:08.160]  это случай, когда человек не хочет
[01:34:08.160 --> 01:34:12.160]  А алгоритм Paxos это не выбор очередного сообщения,
[01:34:12.160 --> 01:34:15.160]  это случай конкуренции лидеров.
[01:34:15.160 --> 01:34:18.160]  Это случай, когда у вас уже есть лидер,
[01:34:18.160 --> 01:34:20.160]  появляется новый, и они должны друг с другом
[01:34:20.160 --> 01:34:22.160]  не поломать всю конструкцию.
[01:34:22.160 --> 01:34:25.160]  А алгоритм Paxos это такой изолированный случай
[01:34:25.160 --> 01:34:27.160]  конкуренции лидеров, когда у вас каждый пропозор
[01:34:27.160 --> 01:34:29.160]  это просто лидер.
[01:34:29.160 --> 01:34:32.160]  А порядок команд выбирает, конечно, не консенсус,
[01:34:32.160 --> 01:34:34.160]  выбирает просто лидер и назначает их в некотором.
[01:34:34.160 --> 01:34:37.160]  Чтобы более наглядно это было,
[01:34:37.160 --> 01:34:40.160]  вы уже читали статью про GFS,
[01:34:40.160 --> 01:34:42.160]  и там были мутабельные чанки,
[01:34:42.160 --> 01:34:44.160]  там чанки можно было перезаписывать.
[01:34:44.160 --> 01:34:46.160]  Но мы на семинаре не стали так делать,
[01:34:46.160 --> 01:34:48.160]  а в GFS стали когда-то.
[01:34:48.160 --> 01:34:51.160]  И кто определял порядок записи в чанке?
[01:34:51.160 --> 01:34:53.160]  Для каждого чанка там выбирался праймари,
[01:34:53.160 --> 01:34:55.160]  то есть были копии чанка,
[01:34:55.160 --> 01:34:57.160]  какой-то узел из них становился праймари,
[01:34:57.160 --> 01:34:59.160]  и вот ему валились все записи,
[01:34:59.160 --> 01:35:01.160]  и он нумеровал их.
[01:35:01.160 --> 01:35:04.160]  А что было, когда он нумерал и выбирался новый?
[01:35:04.160 --> 01:35:06.160]  Да какой-то бардак был,
[01:35:06.160 --> 01:35:08.160]  потому что никаких разумных гарантий не было там.
[01:35:08.160 --> 01:35:11.160]  То есть этот праймари получал какие-то команды,
[01:35:11.160 --> 01:35:13.160]  сделал, например, получил пять команд,
[01:35:13.160 --> 01:35:15.160]  пять записей,
[01:35:15.160 --> 01:35:18.160]  четвертую и пятую записал на две реплики из трех,
[01:35:18.160 --> 01:35:19.160]  потом взорвался.
[01:35:19.160 --> 01:35:21.160]  Выбрался новый праймари,
[01:35:21.160 --> 01:35:23.160]  и как бы нет никакого протокола,
[01:35:23.160 --> 01:35:25.160]  там не было никакого протокола,
[01:35:25.160 --> 01:35:28.160]  в котором все это придется в согласованное состояние.
[01:35:28.160 --> 01:35:30.160]  Новый праймари не знал,
[01:35:30.160 --> 01:35:32.160]  какие записи уже начал сделать тот,
[01:35:32.160 --> 01:35:34.160]  он не может это никак узнать,
[01:35:34.160 --> 01:35:36.160]  не может его разумным образом восстановить.
[01:35:36.160 --> 01:35:39.160]  Ровно в этом месте
[01:35:39.160 --> 01:35:41.160]  GFS не хватало консенсуса.
[01:35:41.160 --> 01:35:44.160]  То есть там не консенсус,
[01:35:44.160 --> 01:35:47.160]  а какие-то ручные костыли,
[01:35:47.160 --> 01:35:49.160]  которые не работают,
[01:35:49.160 --> 01:35:51.160]  но и там, собственно, статьи пишут,
[01:35:51.160 --> 01:35:53.160]  что в случае смерти этого самого праймари
[01:35:53.160 --> 01:35:55.160]  никаких гарантий разумно дальше нет.
[01:35:55.160 --> 01:35:57.160]  Данные в несогласованном состоянии.
[01:35:57.160 --> 01:35:59.160]  Сингл дикрипактес нужен для того,
[01:35:59.160 --> 01:36:01.160]  чтобы как раз аккуратно перейти через эпоху
[01:36:01.160 --> 01:36:03.160]  и оставить это на согласованном состоянии,
[01:36:03.160 --> 01:36:05.160]  чтобы все логи по-прежнему
[01:36:05.160 --> 01:36:07.160]  продолжали дальше бежать синхронно.
[01:36:10.160 --> 01:36:13.160]  Вот такая глубочайшая мораль.
[01:36:15.160 --> 01:36:17.160]  Но все было бы замечательно,
[01:36:17.160 --> 01:36:19.160]  если бы мы построили алгоритм.
[01:36:19.160 --> 01:36:21.160]  А мы не построили алгоритм.
[01:36:21.160 --> 01:36:23.160]  Потому что, во-первых,
[01:36:23.160 --> 01:36:25.160]  непонятно, как выбирать вот эти n.
[01:36:25.160 --> 01:36:27.160]  Не было ни одного слова про это сказано.
[01:36:27.160 --> 01:36:29.160]  Вы выбираете как-нибудь,
[01:36:29.160 --> 01:36:31.160]  чтобы все было аккуратно, все хорошо, непонятно.
[01:36:31.160 --> 01:36:33.160]  Непонятно, как именно реагировать
[01:36:33.160 --> 01:36:35.160]  на команду prepare с бесконечным суффиксом.
[01:36:35.160 --> 01:36:37.160]  Вот я получил такую команду,
[01:36:37.160 --> 01:36:39.160]  а у меня уже есть какой-то там...
[01:36:39.160 --> 01:36:41.160]  Я получил k100,
[01:36:41.160 --> 01:36:43.160]  а у меня в 105-м слоте уже какая-то команда есть
[01:36:43.160 --> 01:36:45.160]  с большим n. Что мне делать?
[01:36:45.160 --> 01:36:47.160]  Что мне отвечать именно?
[01:36:47.160 --> 01:36:49.160]  Можно по-разному это сделать?
[01:36:51.160 --> 01:36:53.160]  Что мне делать,
[01:36:53.160 --> 01:36:55.160]  когда я лидер захватил суффикс лога,
[01:36:55.160 --> 01:36:57.160]  шлю всем accept,
[01:36:57.160 --> 01:36:59.160]  а мне какая-то реплика говорит нет?
[01:36:59.160 --> 01:37:01.160]  Понятно, что я должен
[01:37:01.160 --> 01:37:03.160]  откатиться на первую фазу.
[01:37:03.160 --> 01:37:05.160]  А как именно?
[01:37:05.160 --> 01:37:07.160]  Никакого ответа на эти вопросы
[01:37:07.160 --> 01:37:09.160]  не существует для нас.
[01:37:09.160 --> 01:37:11.160]  Лэмпард на них не ответил.
[01:37:11.160 --> 01:37:13.160]  И вот это
[01:37:13.160 --> 01:37:15.160]  породило бесконечное количество вариаций
[01:37:15.160 --> 01:37:17.160]  алгоритм-паксов, которые
[01:37:17.160 --> 01:37:19.160]  решают эти проблемы
[01:37:19.160 --> 01:37:21.160]  сериями или иным способом.
[01:37:21.160 --> 01:37:23.160]  В общем, много пустых мест.
[01:37:23.160 --> 01:37:25.160]  Интуитивно понятно, что можно чем-то их заполнить.
[01:37:25.160 --> 01:37:27.160]  Но как именно непонятно.
[01:37:27.160 --> 01:37:29.160]  И в следующий раз мы поговорим
[01:37:29.160 --> 01:37:31.160]  как раз про алгоритм, который
[01:37:31.160 --> 01:37:33.160]  автор утверждает, что он
[01:37:33.160 --> 01:37:35.160]  в отличие от паксуса понятен,
[01:37:35.160 --> 01:37:37.160]  а мне кажется, что они просто взяли
[01:37:37.160 --> 01:37:39.160]  и эти места заполнили и получили алгоритм,
[01:37:39.160 --> 01:37:41.160]  который называется raw.
[01:37:41.160 --> 01:37:43.160]  И я попытаюсь вас убедить,
[01:37:43.160 --> 01:37:45.160]  но авторы вас в одном будут убеждать,
[01:37:45.160 --> 01:37:47.160]  а я буду убеждать в противоположном,
[01:37:47.160 --> 01:37:49.160]  что в каком-то смысле
[01:37:49.160 --> 01:37:51.160]  это вот такой мультипаксус,
[01:37:51.160 --> 01:37:53.160]  в котором все зафиксировано.
[01:37:53.160 --> 01:37:55.160]  Все свободные места зафиксированы.
[01:37:55.160 --> 01:37:57.160]  Я бы сказал, что ничего, кроме мультипаксуса,
[01:37:57.160 --> 01:37:59.160]  это все мультипаксус.
[01:37:59.160 --> 01:38:01.160]  Все эти алгоритмы,
[01:38:01.160 --> 01:38:03.160]  они в принципе устроены похожим образом.
[01:38:03.160 --> 01:38:05.160]  И вот мультипаксус
[01:38:05.160 --> 01:38:07.160]  из них самый общий, потому что
[01:38:07.160 --> 01:38:09.160]  там просто много недосказанности.
[01:38:09.160 --> 01:38:11.160]  В следующий раз мы зафиксируем это все
[01:38:11.160 --> 01:38:13.160]  и в домашках мы напишем
[01:38:13.160 --> 01:38:15.160]  сначала вы напишете синглудик и паксус,
[01:38:15.160 --> 01:38:17.160]  а потом мы напишем мультипаксус
[01:38:17.160 --> 01:38:19.160]  как-нибудь,
[01:38:19.160 --> 01:38:21.160]  а потом напишем уже raft,
[01:38:21.160 --> 01:38:23.160]  как советуют авторы в статье
[01:38:23.160 --> 01:38:25.160]  с конкретным протоколом.
[01:38:25.160 --> 01:38:27.160]  И увидим, что это проще было.
[01:38:27.160 --> 01:38:29.160]  Ну или нет, я не знаю, что вы видите,
[01:38:29.160 --> 01:38:31.160]  попробуйте сами.
[01:38:31.160 --> 01:38:33.160]  На сегодня все.
[01:38:33.160 --> 01:38:35.160]  Отдыхаем 10 минут.
