[00:00.000 --> 00:17.240]  давайте начнем так сегодня я думаю наверное всю лекцию будем доказывать кодировая ну в общем
[00:17.240 --> 00:24.640]  теория мукели давайте так вы помните я сформулировал теория мукели нет и формулировал
[00:24.640 --> 00:46.000]  да да да кажется сформулировался таки да значит у нас получается число деревьев
[00:46.000 --> 00:56.720]  без учета без учета изоморфизма
[00:56.720 --> 01:14.240]  ну то есть мы считаем что изоморфные деревья но различные изоморфные деревья они то они мы считаем
[01:14.240 --> 01:20.600]  их различными второй подход когда мы склеиваем все изоморфные деревья считаем их одинаковыми да
[01:20.600 --> 01:31.080]  тогда там совсем другое число получается вот число без учета изоморфизмов на n вершинах
[01:31.080 --> 01:49.000]  равно n степени n-2 доказательства собственно через кодирование прюфера идет я вот давайте
[01:49.000 --> 01:56.600]  я тогда я просто в конце лекции я просто примеры дал кодирование кодирование алгоритм я только
[01:56.600 --> 02:02.760]  так на словах описал давайте я запишу этот алгоритм алгоритм кодирование прюфера
[02:02.760 --> 02:22.880]  да осмотреть
[02:32.760 --> 02:49.520]  отрицаем на каждом шагу на каждом шагу ищем лист с наименьшим номером
[03:02.760 --> 03:26.960]  и усекаем его давайте так коротко напишем в код пишем номер вершины вот на таких вершинах
[03:26.960 --> 03:34.480]  все-таки нужно написать 1 1 2 n код пишем номер вершины с которой лист был соединен
[03:34.480 --> 03:47.920]  вершины с которой этот лист был соединен ребят если вы не заметили но я правда только вчера
[03:47.920 --> 03:59.880]  вечером это сделал я ну я как я говорил вам я веду я веду уже сейчас пишу программу ссылки
[03:59.880 --> 04:06.720]  все делаю заранее да все загружаюсь ссылки делай заранее чтобы потом не делать очень много
[04:06.720 --> 04:12.680]  работы получается когда нет досок у тебя так ты быстро по доскам смотри я бы так бы программу
[04:12.680 --> 04:20.000]  составлял быстро по доскам смотрел доски там я писал все слова которые произношу на них вот и
[04:20.000 --> 04:26.480]  по доскам там понятно что я там прочел что я там очень быстро все составлялся когда вот так досок
[04:26.480 --> 04:32.520]  нет непосредственно отдельно выписано содержание лекции нет приходится это просматривать получается
[04:32.520 --> 04:42.040]  долго поэтому я решил сразу делать просто вот по ходу по ходу чтения и я выложил новую версию
[04:42.040 --> 04:47.280]  который буду обновлять постоянно то есть новую лекцию прочитаю добавляю ссылку добавляю тот
[04:47.280 --> 04:54.840]  материал который прочитал так далее обновляю там у себя текущую версию нужно еще наверное
[04:54.840 --> 05:00.480]  троечный список начинать составлять чтобы это было больше времени как говорится на дискуссию
[05:00.480 --> 05:07.920]  простой непростой вопрос и так далее может кто-то забыл потому что сходу смотришь этот троечный
[05:07.920 --> 05:14.720]  список иногда потом на экзамене вспоминаешь наверное нужно было еще это добавить как нужно
[05:14.720 --> 05:23.240]  заранее просто продумывать это так код пишет номер который этот усеченный лес был соединен
[05:38.520 --> 05:41.160]  а критерии остановки
[05:51.160 --> 05:54.440]  осталось одно ребром
[05:54.440 --> 06:08.360]  одно ребро его никуда не пишу она никуда не пишется
[06:08.360 --> 06:29.760]  так это алгоритм кодирования алгоритм декодирования
[06:39.360 --> 06:51.520]  почему я должен я хочу написать вот так полностью потому что мы должны свойства этих алгоритмов
[06:51.520 --> 07:00.800]  доказывать для этого нужно ну вот четко обозначить что это за алгоритмы на каждом шаге так начало
[07:00.880 --> 07:08.960]  есть код длины код длины
[07:08.960 --> 07:34.000]  n-2 а 1 2 составляем две последовательности а внизу приписываем числа от 1 до n
[07:39.400 --> 08:01.920]  вот алгоритм шаг алгоритма ищем наименьшее ищем наименьшее число внизу который отсутствует
[08:01.920 --> 08:09.680]  вверху который отсутствует вверху
[08:09.680 --> 08:32.720]  запих потом записываем записываем
[08:32.720 --> 08:45.360]  пару первая позиция кода
[08:45.360 --> 08:55.920]  а во второе слое во второе найденное число
[09:02.720 --> 09:10.840]  и вычеркиваем найденное первую позицию пары первую позицию куда и вычеркиваем
[09:10.840 --> 09:26.440]  обе обе соединенные но обе обе оба числа пары вот так
[09:26.440 --> 09:48.680]  сверху и снизу соответственно первую позицию пары снизу вторую позицию пары
[09:48.680 --> 10:02.000]  ну что ж
[10:02.000 --> 10:11.200]  критерии остановки собственно шаг такой вот у нас есть две последовательности вычеркиваем и
[10:11.200 --> 10:18.480]  ищем наименьшее номер числа внизу который отсутствует вверху вычеркиваем соединяем
[10:18.480 --> 10:36.880]  их в ребром вычеркиваем критерии остановки не осталось ни одного числа в коде вверху
[10:37.360 --> 10:50.000]  числа вверху не осталось ни одного числа вверху
[10:50.000 --> 11:01.720]  последние два числа которые остались соединяем в ребро и заканчиваем
[11:01.720 --> 11:10.800]  последние два из числа два оставшихся числа
[11:10.800 --> 11:18.480]  внизу числа
[11:18.480 --> 11:29.920]  пишем в пару соединяем пару и заканчиваем соединяем пару
[11:29.920 --> 11:42.640]  ну ребят на самом деле чисто формально что нужно проверить код прюфера по сути это
[11:42.640 --> 12:04.000]  любая последовательность из чисел любая последовательность такая что для любого
[12:04.000 --> 12:20.440]  и от единички до н-2 находится между единичкой n есть код прюфера да может служить кодом прюфера
[12:20.440 --> 12:26.400]  потому что декодировать можно любую последовательность так смотрите но в принципе
[12:27.400 --> 12:35.400]  что нужно проверить нужно проверить что тот последовательность ребер который смотрите ну во
[12:35.400 --> 12:47.000]  первых да какие вещи нам надо доказать вот если коротко давайте просто пока перечислим что надо
[12:47.000 --> 12:55.240]  доказать может служить кодом прюфера
[12:55.240 --> 13:23.320]  но надо доказать первое что процедура декодирования обязательно декодирует именно дерево
[13:23.320 --> 13:50.120]  это важно декодирование создает дерево а то вдруг есть такой код который мы декодируем
[13:50.120 --> 13:57.440]  от дерева не получится что это дает смотрите у нас есть множество давайте коротко сейчас я поясню
[13:57.440 --> 14:15.720]  вот есть деревья деревья вот коды прюфера нам нужно показать что любой код можно их декодируется
[14:15.720 --> 14:26.760]  именно в дерево потом что что ли у них что нет двух разных деревьев которые декодируется
[14:26.760 --> 14:35.560]  кодироваться были кодировались бы в один и тот же код прюфера это даст доказать докажет
[14:35.560 --> 14:45.440]  инъективность отображение дерева код прюфера так а есть идти и третье да вот это это инъективность
[14:45.440 --> 14:58.280]  так первое второе значит нет давайте так нет двух кодов
[14:58.280 --> 15:13.920]  которые декодируется в одно и то же дерево двух разных кодов это функциональность как раз правда
[15:13.920 --> 15:26.200]  двух разных кодов кодирующихся в одно и то же декодирующихся в одно и то же дерево
[15:26.200 --> 15:42.560]  ну хорошо не декодирующие в котором соответствует одно и то же дерево давайте так может быть не по
[15:42.560 --> 15:47.680]  алгоритму а может быть по какому-то другому нет ну в принципе тут подекодировали декодирующихся
[15:47.680 --> 15:55.120]  именно то есть разные коды взяли декодировали а получилось одно и то же вот может почему
[15:55.120 --> 16:02.880]  такого не бывает давайте докажем декодирующиеся в одно и то же дерево
[16:02.880 --> 16:22.480]  ну и третье нет двух деревьев которые которым бы соответствовал один код прюфера нет двух
[16:22.480 --> 16:47.200]  деревьев двух разных деревьев в котором бы соответствовал один код прюфера
[16:52.480 --> 17:03.800]  это я это как раз доказывает сюрреактивность это доказывает функциональность это доказывает
[17:03.800 --> 17:10.720]  ну смотрите то что мы описали процедура кодирования это вот отображать строить
[17:10.720 --> 17:16.920]  отображение значится деревьев новостей кодов вот эти две штуки доказывают соответственно
[17:16.920 --> 17:24.200]  функциональность сюрреактивность канадичек процедуру декодирование которое ну это же
[17:24.200 --> 17:29.120]  обратное отображение на самом деле это чисто говоря вот как раз вот первое утверждение это как
[17:29.120 --> 17:33.600]  раз часть доказательства того что это обратное отображение ну то есть декодируется именно
[17:33.600 --> 17:40.640]  дерево и второе что надо доказать но вот это вот и не хочу чисто формально проделывать что
[17:40.640 --> 17:50.160]  смотрите если мы возьмем код построим дерево мы доказали что докажем сейчас что что построится
[17:50.160 --> 17:58.760]  именно дерево а потом это дерево мы закодируем то получится тот же самый код нужно это же
[17:58.760 --> 18:05.560]  проверить правда ну что это обратное отображение то есть мы действительно получаем некое дерево
[18:05.560 --> 18:12.200]  у которого код вот такой в этом же с процедурой декодисуть процедуры заканчивается заключается
[18:12.200 --> 18:19.800]  правильно так ребят вот эту вот часть я не хочу проявить потому что это непосредственно но
[18:19.800 --> 18:26.680]  видите алгоритм декодирования если разобраться он как раз строит именно именно это то есть он
[18:26.680 --> 18:35.080]  строит что мы делаем на каждом из шагов а ребят мы ищем лист с наименьшим номером вот здесь вот
[18:35.080 --> 18:42.200]  перечисленные вершинки нашего дерева мы ищем а вот здесь просто те те вершинки с которым листы
[18:42.200 --> 18:49.240]  были соединены на каком-то шаге вот первая первая позиция это то номер вершины с которой был
[18:49.240 --> 18:55.080]  соединен первый отсеченный лист правильно ребят соответственно мы должны найти здесь вершинку с
[18:55.080 --> 19:02.400]  номером с наименьшим номером которые здесь нету ну лист не никуда не запишется правильно в коде
[19:02.400 --> 19:10.000]  поэтому ищем вершинку которая здесь нет с наименьшим номером и соединяем ее своего условно с
[19:10.000 --> 19:17.680]  вот этой получается вот то тот тот то самое усеченное ребро на первом шаге потом на следующем
[19:17.680 --> 19:24.840]  шаге на и так далее понимаете да ребят то есть действительно вот эту часть не хочется просто
[19:24.840 --> 19:31.440]  описывать довольно муторно писать что это действительно обратное отображение а это доказывает как раз
[19:31.440 --> 19:37.680]  сюрррективность индиективность мы вот отдельно проверим при активность доказывается при помощи
[19:37.680 --> 19:46.320]  катапроцедуры декодирования получается есть между когда деревьями а значит у них одинаковое
[19:46.320 --> 19:55.480]  количество элементов а кодов можем посчитать их два инских и хен степени на минус 2 вот в этом
[19:55.480 --> 20:03.080]  доказательство заключается то есть нам нужно установить три вот эти вещи давайте по очереди
[20:03.080 --> 20:10.880]  так что и стиралки тут нет что ли но и че ее мое
[20:10.880 --> 20:29.240]  вот нет первой не сюрррективность первой корректность просто доказывает
[20:29.240 --> 20:50.480]  второй но второй у нас что разные коды это инъективность вот это вот сюрррективность
[20:50.480 --> 20:58.800]  а вот это
[21:02.800 --> 21:07.520]  то та процедура которую мы описали что на корректно корректно в том смысле что она
[21:07.520 --> 21:22.280]  создает дело обязательно а сюрррективность все правильно третья сюрррективность да да это
[21:22.280 --> 21:40.720]  сюрррективность корректность декодирования да ой ой парадон парадон господи извините это
[21:40.720 --> 21:53.240]  не активность да не активность ребят поэтому собственно извините прошу прощения что я так
[21:53.240 --> 21:59.040]  много путаюсь вот это как раз последствия праздников в том смысле что на самом деле
[21:59.040 --> 22:07.640]  вот вот эти майские не майские а вот мартовские праздники февральские это кошмар для преподавателей
[22:07.640 --> 22:14.040]  знаете почему потому что это еще середина семестра и переносить сгорают занятия их нужно
[22:14.040 --> 22:23.360]  переносить их нужно компенсировать это переработка полнительная вот у меня была
[22:23.360 --> 22:29.280]  такая компенсационное занятие сейчас на этой неделе я сейчас видите совсем уставший я могу
[22:29.880 --> 22:42.640]  поправляйте меня пожалуйста это функциональность к майским праздникам таких претензий нет потому
[22:42.640 --> 22:53.080]  что там некуда переносить там уже все там уже сессия она просто сгорает а компенсировать нет уже
[22:53.080 --> 23:02.120]  пространство для маневра времени нету все вот то просто корректность называется это
[23:02.120 --> 23:13.680]  сюррективность доказывается при как я сказал при помощи тотальность процедура кодирования ну
[23:13.680 --> 23:18.880]  каждому дереву соответствует код процедура кодирование описывает а сюррективность
[23:18.880 --> 23:25.040]  доказывается при помощи вот как раз проверки корректности декодирование декодирование
[23:25.040 --> 23:32.480]  строит по коду дерево и собственно нужно еще дополнительно проверить что это действительно
[23:32.480 --> 23:42.560]  обратное отображение понятно вот то есть корректность это часть доказательства сюррективности
[23:43.360 --> 24:01.080]  вот ну давайте докажем один вот эта часть я не знаю даже на какой источник сослаться потому
[24:01.080 --> 24:08.320]  что во всех книжках эти эти вещи не доказаны сразу говорю я обычно ссылаюсь к нас что-то
[24:08.960 --> 24:17.320]  потому что я бы больше нигде них ни в каких книжках это не нашел вот обобщим доказываем
[24:17.320 --> 24:31.520]  утверждение сейчас будет вот что доказываем утверждение в такой форме которая там сформулировано
[24:31.520 --> 24:42.320]  это трудно доказать вот чуть обобщая легко уже получается смотрите данные последовательности
[24:42.320 --> 25:09.960]  последовательности значит а 1 а 2 а к-2 б 1 б 2 б к-2 б к-1 б к теперь условия давайте
[25:09.960 --> 25:25.080]  записывать ограничения где а это для любого и от единицы до к-2 а это находится в пределах
[25:25.080 --> 25:38.880]  между единичкой нет этот вот какой-то наш параметр вот сло вершин у дерева а к у нас
[25:38.880 --> 25:47.880]  бегает в пределах от единички до дат единички до нет нет нет нет нет нет нет нет нет единички
[25:47.880 --> 25:56.940]  тройки получается. Ну, чтобы-то минус два было хотя бы единица. Вот. А тройки до...
[25:56.940 --> 26:18.500]  Что выходит? n-4, да? Ой, до n. Чтобы самое длинное было n-2. Так? Вот. Дальше. Запишем это вот так.
[26:18.500 --> 26:29.660]  Внизу последовательность упорядочена по возрастанию. Причем они попарно различны.
[26:29.660 --> 26:54.020]  И еще одно слово. Догадайтесь какое. Понимаете, к чему я это пишу? Смотрите, это вот то, что
[26:54.020 --> 27:01.180]  получается на каком-то промежуточном шаге в процессе декодирования. То есть последовательность
[27:01.180 --> 27:08.900]  не обязательно подряд идущих чисел, но упорядоченных по возрастанию внизу. Число чиселок внизу на два,
[27:08.900 --> 27:16.220]  больше, чем число чиселок вверху. Все эти чиселки вот в таких пределах заключены. Что еще нужно потребовать?
[27:16.220 --> 27:29.380]  Это здесь предполагается, это есть. Что числа вверху все лежа, все находятся среди чисел внизу.
[27:29.380 --> 27:55.700]  Все числа, все числа а1, ак-2 лежат среди b1, bk.
[27:59.380 --> 28:14.500]  Ну а bt это же не подряд числа. Смотрите, на каждом промежуточном шаге вначале это верность.
[28:14.500 --> 28:22.020]  Здесь числа от 1 до n, тут все числа аi среди нижних чисел присутствуют. Когда мы начинаем
[28:22.020 --> 28:31.140]  вычеркивать, то же самое остается. Все числа вверху будут среди чисел внизу, поэтому нужно
[28:31.140 --> 28:43.940]  это зафиксировать отдельно. Даны вот такие последовательности с такими условиями. Я, наверное,
[28:43.940 --> 28:50.860]  это стирать сейчас не буду, нужно потом будет ссылаться, я не хочу это переписывать. Нужно
[28:50.860 --> 29:00.060]  доказать, что процедура декодирования по этим двум последовательностям создаст дерево.
[29:00.060 --> 29:17.540]  Что процедура декодирования по запущенной на этих двух последовательностях запущенная.
[29:30.060 --> 29:50.380]  Это промежуточный итог шагов этого алгоритма. На самом деле так проще. Я рассуждение вам
[29:50.380 --> 30:03.420]  поясню. Процедура запущена на этих последовательных стихах. Создать дерево.
[30:03.420 --> 30:21.340]  Смотрите, проще по доказательству пояснить, почему это действительно нужно именно так обобщать.
[30:21.340 --> 30:40.780]  Проблема в необходимости вообще не возникает вот в каком месте. Логично на самом деле доказывать
[30:40.780 --> 30:51.100]  подобное отвратение индукция ПН. Но если вы просто чисто логически сделаете первый шаг,
[30:51.100 --> 30:59.420]  алгоритма, создадите одно ребро и вычеркните последовательности, то получится уже корявая
[30:59.420 --> 31:04.860]  последовательность. Если вы сформулируете утверждение для последовательств вверху какое-то,
[31:04.860 --> 31:14.780]  а снизу подряд идущие просто, то этого нарушится на следующем шаге. И предположение индукции
[31:14.780 --> 31:25.260]  применить к этому уже не получится. Поэтому лучше сразу сформулировать для промежуточного
[31:25.260 --> 31:39.340]  итога работы, тогда там предположение индукции применимо. Так в длинной последовательности на
[31:39.340 --> 31:49.620]  каждом шаге уменьшаются. И это число вершин дереве. В данном случае вот эта процедура
[31:49.620 --> 31:56.100]  декодирования по этим последовательностям создаст дерево на вершинах с номерами Б1,
[31:56.100 --> 32:05.900]  Б2 и так далее до БК. Если запустить декодирование по вот этим двум последовательностям,
[32:05.900 --> 32:21.980]  то будет создано дерево на вот этих вершинках внизу перичисленных. Смотрите, индукция ПК
[32:21.980 --> 32:45.420]  БАЗа каравна единица, каравна тройки, самая маленькая тройка. Да, ну нет, конечно,
[32:45.420 --> 33:02.900]  перебор некий нужно сделать. Но внизу А1, вверху Б1, Б2, Б3. При том, что Б1, Б2, Б3 в пределах от 1 ДН,
[33:02.900 --> 33:16.100]  а А1 тоже в пределах от 1 ДН. И А1 встречается среди Б1, Б2, Б3. Совпадает с одним из,
[33:16.100 --> 33:42.380]  совпадает с одним из Б1, Б2, Б3. Вот, смотрите, но случай один. Ребят, давайте. Случай один,
[33:42.380 --> 33:55.220]  а один совпадает с Б1. Тогда процедура декодирования найдет Б2, это самая маленькая,
[33:55.220 --> 34:04.900]  которая отсутствует вверху, и соединит А1, Б2. Тогда декодируется такое, тогда декодируется такое.
[34:04.900 --> 34:30.380]  Следующие ребра. Значит, А1, Б2 и Б1, Б3. Ну, как бы он вот соединит вот эти два в ребра,
[34:30.380 --> 34:44.000]  их вычеркнет, остальные из оставшихся двух создаст ребро. А1 равно Б1. И у нас декодируется
[34:44.000 --> 35:09.960]  такая цепочка. Б2, Б1, Б3. Дерево. Второе. А1 равно Б2. В таком случае самая маленькая внизу,
[35:09.960 --> 35:19.400]  которая отсутствует вверху, это Б1. И ребро будет первое, А1, Б1, а второе, Б2, Б3. Так.
[35:19.400 --> 35:47.560]  Декодируем А1, Б1 и Б2, Б3. А1 это Б2. Ну и получается Б1, вот такая цепочка.
[35:47.560 --> 36:00.280]  Б1, Б2, Б3. Тоже дерево. Так. Ну и третий случай А1 равно Б3.
[36:17.560 --> 36:47.360]  Тогда декодируется А1, Б1 и Б2, Б3. А1 это Б3.
[36:47.360 --> 36:58.760]  Ну то есть вот такая цепочка в итоге получается. Б1, Б3, Б2. В любом случае,
[36:58.760 --> 37:06.600]  во всех трех случаях, получилось декодировать именно дерево. Окей.
[37:06.600 --> 37:21.160]  Ну не знаю, на самом деле можно было просто написать, остальные случаи рассматриваются
[37:21.160 --> 37:27.160]  аналогично, как любят писать. А вот без ограничений общности мне трудно тут представить, чтобы это
[37:27.160 --> 37:33.760]  как-то без ограничений общности было. Просто так же рассматривается. На самом деле я показал все
[37:33.760 --> 37:40.640]  три случая, чтобы вы наглядно представили, как это все работает. Хорошо. На букве нам так
[37:40.640 --> 37:53.040]  сказать уровень. Смотрите. Дальше. Переход. Пусть утверждение доказано для K.
[38:03.760 --> 38:14.240]  Рассмотрим любые две последовательности. Значит, А1, АК минус 1. Я так понимаю,
[38:14.240 --> 38:29.760]  Б1, БК минус 1, БК. БК плюс 1. Ну с такими условиями, что для любого Я, от единички до К
[38:29.760 --> 38:50.000]  минус 1, АИТ и до Н. От единички до Н. Так, что там еще? Что К не превосходит Н и больше
[38:50.000 --> 39:09.440]  либо равно, чем два, наверное. Скоро тут К минус 1. Вот. Ну и Б и Т упорядочены по возрастанию.
[39:09.440 --> 39:31.880]  Ну и еще А1. А1, АК минус 1. Все содержатся среди
[39:31.880 --> 40:01.600]  B1, BK плюс 1. Ну смотрите, что мы сделаем.
[40:01.600 --> 40:07.880]  Ну и делаем стандартный шаг алгоритма. Ищем внизу число, которое отсутствует вверху,
[40:07.880 --> 40:30.040]  наименьшее. Ну пускай это БЖТ. Пусть БЖТ, наименьшее число, число внизу, отсутствующее сверху.
[40:30.040 --> 40:59.360]  Тогда мы нарисуем А1, ребро А1 БЖТ и вычеркнем. Вот тут БЖТ, вот тоже вычеркиваем. Смотрите,
[40:59.360 --> 41:09.120]  вот эти новые получившиеся последствия, они не единичку короче. Что было куда укорачивать,
[41:09.120 --> 41:20.440]  как говорится, от трех. На единичку короче, они удовлетворяются тем же условиям. Опять же,
[41:20.440 --> 41:28.640]  все А1, А2, АК минус 1, они все в нужных пределах лежат. Это упорядочно по возрастанию.
[41:28.640 --> 41:39.360]  Низняя последовательность. И все верхние чиселки лежат среди нижних чиселок. Значит,
[41:39.360 --> 41:45.760]  мы можем к этому предположение индукции применить. И тогда оно говорит, что мы построим дерево.
[41:45.760 --> 42:09.000]  Правильно? Предположение индукции. Строить дерево. На вершинах
[42:09.000 --> 42:35.440]  Б1 меньше БЖ минус 1, меньше БЖ плюс 1. На к вершинах.
[42:39.000 --> 42:50.600]  Предположение индукции. По декодированию построено последствия ребер, которые складываются
[42:50.600 --> 43:02.080]  в дереве. На вот таком наборе вершин. Хорошо, теперь смотрите. Возвращаем вот этот лист удаленный.
[43:02.080 --> 43:12.160]  Вернее, я сразу сповернул. Нужно доказать, что это еще лист. Но это лист. Почему? Потому что
[43:12.160 --> 43:25.120]  А1 среди вот этих штук есть. Обожитого нет. То есть мы, возвращая вот это ребро,
[43:25.320 --> 43:34.080]  от существующей в дереве вершины проводим ребро в той вершине, которая доселе в этом
[43:34.080 --> 43:50.960]  дереве не присутствовала. Поняли? Поэтому это снова дерево. Поняли? То есть смотрите,
[43:50.960 --> 44:04.640]  А1 среди вот этих штук есть. По условию. Обожитого нет. Мы так искали. Его нет среди этих. Поэтому
[44:04.640 --> 44:11.800]  когда мы добавим вот это ребро, мы соединим вот эту вершинку А1, которая уже была в дереве,
[44:11.800 --> 44:18.720]  с вершинкой, которая в дереве отсутствует. Получается лист новый. Просто мы к дереву
[44:18.720 --> 44:29.040]  добавили, нарастили лист. Получилось снова дерево. Понятно? Вот. Ну вот, собственно,
[44:29.040 --> 44:36.360]  предположение индукции доказано. Просто долго записывать. Извините. Вот это все. А вот теперь вы
[44:36.360 --> 44:44.200]  наглядно представляете, как эта процедура работает. Смотрите. Да. Вот последовательность.
[44:44.200 --> 44:53.480]  Смотрите. Если мы начнем декодировать с начала, то мы конечно строим некую последовательность ребер,
[44:53.480 --> 45:00.200]  но тут нужно смотреть на самом деле с другого конца, как говорится. Если вот вы раскрутите до
[45:00.200 --> 45:07.920]  начала все и возьмете, с последнего двигаться будете к первому, с последнего к первому,
[45:07.920 --> 45:13.880]  то вы по очереди будете наращивать лист-лист-лист. Получается новый каждый раз дерево.
[45:13.880 --> 45:21.640]  А если вот с начала до конца, то не обязательно вот они так прям станут. Понимаете в чем дело? То есть
[45:21.640 --> 45:29.680]  нужно... Секрет заключается в том, что вот этот вывод декодирования нужно обернуть задом наперед,
[45:29.680 --> 45:38.180]  и тогда вы подряд, добавляя каждый раз ребро, вы будете каждый раз получать дерево. Вот. Все
[45:38.180 --> 45:46.780]  понятно сейчас, нет? Вот. На этом следующее доказательство, собственно, основывается. Вот.
[45:46.780 --> 46:03.620]  Вот здесь давайте. Очень легко после вот этого доказывается то, что двум разным кодом не
[46:03.620 --> 46:24.220]  бывает двух разных кодов, в котором соответственно одно дерево. Смотрите, как это доказывать. Второе. Пусть
[46:24.220 --> 46:44.500]  есть два разных кода. Разных кодов. Прюферы, которые декодируются в одно и то же дерево.
[46:54.220 --> 47:20.620]  Ну что тогда? Тогда, во-первых, длины кодов одинаковые. Догадаетесь почему? Да, длина кода это
[47:20.620 --> 47:27.660]  количество вершин в дереве минус два. Это, ну как задается, количество вершин в дереве, раз им
[47:27.660 --> 47:36.300]  соответствует одно и то же дерево, то у них длины одинаковые. Так, давайте кодов одинаковые длины.
[47:36.300 --> 48:04.140]  Одинаковые. В смысле, одинаковые по определению заморфаны вообще-то. Ну, еще раз. Изоморфные. Нет,
[48:04.780 --> 48:20.100]  просто в одно и то же. Не в изоморфные, в одно и то же. Ну, а если они различны, то разные деревья. Мы
[48:20.100 --> 48:29.100]  считаем это разные. Вот кодирование Пруфера это различает вообще-то. Кодирование Пруфера дает
[48:29.100 --> 48:40.460]  разные коды двум изоморфным, но различным деревьям. Поэтому здесь именно имеется
[48:40.460 --> 48:51.920]  в виду одно и то же. Именно прям вот одно и то же. Не изоморфные они там. Вот. У этих кодов одна
[48:51.920 --> 49:20.440]  и то же длина. Одинаковая длина. Так как она равна числу вершин дерева минус 2. Одно и то
[49:20.440 --> 49:40.160]  же дерево на N вершинах давайте. На N вершинах. Ну, смотрите. Вот пусть первый код. Есть второй код.
[49:40.160 --> 50:09.360]  Они разные. Ну, пусть T. Наименьшее. На меньшее число. От
[50:09.360 --> 50:29.040]  одного до N минус два. Такое что? Любовь I от единички до T. 1 равно I T равно B T. Ну,
[50:29.040 --> 50:36.000]  короче говоря, это так называемые совпадающие префиксы вот этих кодов. Ну, они разные. Значит,
[50:36.000 --> 50:45.680]  до T позиции они совпадают, а вот дальше идут разные. Идет самая первая позиция,
[50:45.680 --> 50:55.040]  на которой цифры стоят разные. Правильно? То есть у нас давайте. Наименьшее такое, что не равно,
[50:55.040 --> 51:11.560]  наоборот. А, да, равно. А T плюс 1 не равно B T плюс 1. Ну, что мы будем делать? Смотрите,
[51:11.560 --> 51:26.960]  ребята. Ну, давайте запустим процедуру декодирования и докрутим ее до этого шага.
[51:26.960 --> 51:36.880]  Она построит последовательность одинаковых ребер, потому что начало одинаковое. Ну, по идее,
[51:36.880 --> 51:53.200]  мы должны, у нас в принципе есть предположение, что у нас строится одно и то же, да? Ну, вроде так.
[51:53.200 --> 52:06.160]  Так, ну, хорошо. То есть в чем идея? Я хочу вычеркнуть вот это начало. Просто совпадающий
[52:06.160 --> 52:15.160]  начало убираем и предполагаем, что они прям стартуют с различных двух позиций. Почему тогда все плохо?
[52:15.160 --> 52:33.680]  Ну, по нашему предположению же все это декодируется в одно и то же, да? Так? Значит,
[52:33.680 --> 52:51.760]  процедура декодирования, значит, процедура декодирования на первых T шагах,
[52:51.760 --> 53:20.680]  T шагах. А, извините, T наверное все-таки вот так нужно. Наименьшее. Ну, наименьшее. Ну,
[53:20.680 --> 53:28.440]  то есть до этого все одинаковое, начиная с этого момента идут различия. Это тот момент,
[53:28.440 --> 53:41.080]  с которого начинается, после которого начинаются различия. Вот так. На T шагах создаст одни и те же
[53:41.080 --> 54:01.280]  ребра, да? На кодах A n-2 и B 1 B n-2 создаст одни и те же ребра.
[54:11.080 --> 54:40.160]  Где, где, где? Почему наименьшее лишнее? Еще раз, почему? Я не понимаю вас.
[54:40.160 --> 54:58.400]  Их может быть много. Нам нужно одно выбрать. Ну, как же, если последствия разные, то в каких-то
[54:58.400 --> 55:05.520]  мы позициях различия будут, но может быть несколько позиций. Выберем самое маленькое по номеру.
[55:10.160 --> 55:32.080]  Так, теперь я вас не понимаю.
[55:32.080 --> 55:51.280]  Таких T может быть много. Нам нужно выбрать одно. Выберем самое маленькое. Если вы не самое маленькое,
[55:51.280 --> 56:05.680]  то мы не можем утверждать, что до T все одинаковое, просто не сможем. Ну, а нет, от единички до T. Ну,
[56:05.680 --> 56:17.120]  и что? Нулевой позиции у нас нет, понимаете? Почему от нуля? Потому что может начинаться
[56:17.120 --> 56:36.520]  различие с самой первой позиции. А, сейчас. Нет, именно наименьшее. Вот, на T плюс первая разность,
[56:36.520 --> 57:04.720]  разная, разная. А на предыдущих? Вот, первое.
[57:04.720 --> 57:23.120]  Вот, второе T, вот третье T. Я выбираю самое маленькое. Для любого и от одного до T. T в данном случае три.
[57:23.120 --> 57:33.800]  От один, два, три совпадает. Тогда один, два, три совпадает, на четвертый не совпадает, на пятый
[57:33.800 --> 57:51.720]  совпадает, на шестой не совпадает. Можем, если самое маленькое возьмем. Вот, T равно 3, вот T
[57:51.720 --> 58:07.320]  на четырём. Пожалуйста. Ой, T равно 3. До трёх совпадающие позиции, на третий разные. Всё. Ну, и что?
[58:07.320 --> 58:15.560]  Зачем на второй случай? Я не понимаю, не можем взять? Да, и что? Так, я не понимаю. Так, смотрите.
[58:15.560 --> 58:26.640]  Вот одинаковые префиксы. Совпадающие префиксы максимальной длины, которые нам нужны. Всё. Нам
[58:26.640 --> 58:33.080]  нужен максимальный префикс. А вот это вот мы как бы возьмём в оставшиеся закинем. Всё, больше
[58:33.080 --> 58:47.320]  ничего нам не надо. Нам нужен префикс, самый длинный совпадающий общий префикс. Всё. Так.
[59:03.080 --> 59:23.560]  Для T плюс 1, смотрите, мы создаём одинаковые ребра. А дальше вот что пошло. Дальше у нас процедура
[59:23.560 --> 59:33.120]  декодирования. Ребят, обратите внимание. Процедура декодирования от T плюс 1 у нас пойдёт здесь от A N
[59:33.120 --> 59:49.000]  минус 2. А вот здесь B T плюс 1 B N минус 2. Вот тут разные числа уже сразу идут. Но внизу, когда мы
[59:49.000 --> 59:53.800]  процедуру декодирования, поскольку мы вычёркивали одно и то же, мы же одинаковые ребра строили. И
[59:53.800 --> 59:59.680]  ещё префиксы-то пошли одинаковые. Поэтому мы вычёркивали одно и то же снизу-сверху. Внизу будут
[59:59.680 --> 01:00:07.800]  одни и те же последовательности. Значит, вот уже на T плюс первом шаге алгоритм создаст разные ребра.
[01:00:07.800 --> 01:00:21.040]  Потому что здесь вершинка и здесь вершинка разные. Может она соединит их с одним и тем же,
[01:00:21.040 --> 01:00:32.720]  с одной и той же вершинкой, но второй конец ребра будет другой. Не всегда. Но зависит от того,
[01:00:33.320 --> 01:00:39.120]  что вверху, что внизу, как говорится. Мы же ищем самое маленькое внизу, которое отсутствует вверху.
[01:00:39.120 --> 01:00:50.160]  А вдруг оно одно и то же, а самое маленькое здесь и здесь. Ну и фиг их знает. Ну если переставить,
[01:00:50.160 --> 01:00:56.480]  просто вот если два кода, в них циферки просто переставлены местами, то уже возникает такая
[01:00:56.480 --> 01:01:12.560]  ситуация, что внизу и вверху отсутствует одно и то же. То есть разные ребра построены будут,
[01:01:12.560 --> 01:01:33.960]  а значит разные деревья. Ну извините. Тогда надо вот так. Рассмотрим такое наименьшее.
[01:01:33.960 --> 01:01:57.200]  Вот. Рассмотрим наименьшее. Удовлетворяющее тем, что существует два кода, для которых есть два кода.
[01:02:04.800 --> 01:02:10.240]  Которые декодируются. Два разных кода декодируются в одно и то же.
[01:02:10.240 --> 01:02:36.280]  Так. Ну в таком случае мы как бы сократили. Получился код поменьше, который декодируется
[01:02:36.280 --> 01:02:48.040]  тоже в одно и то же. Противоречие с тем, что мы это наименьшее. Вот. Понятно, ребят? Здесь есть тонкость,
[01:02:48.040 --> 01:02:56.080]  конечно. Тут опять видимо придется приписывать Б1Бкаты внизу. Да, ребят? То есть потому что иначе
[01:02:56.080 --> 01:03:05.200]  вообще-то немножко не работает наше рассуждение, если здесь подряд одно ОДН. А вот тут же у нас
[01:03:05.200 --> 01:03:12.880]  уже не подряд от ОДН, а какие-то возрастающие последствия. То есть нужно доказать, что для
[01:03:12.880 --> 01:03:21.520]  двухпоследовательности они декодируются. Вверху разные, но внизу одно и то же. Да, более сильное.
[01:03:21.520 --> 01:03:37.040]  Внизу одно и то же. И Н самая маленькая, возможно. Сейчас понятно, ребят? Вот. Ну, теперь давайте как
[01:03:37.040 --> 01:03:50.720]  доказать, что нет двух деревьев, у которых один код приюфер. Пусть есть два различных деревья,
[01:03:50.720 --> 01:04:16.520]  различных деревьев с одним кодом приюфера. Ну, как бы, тогда смотрите. Тогда получается,
[01:04:16.520 --> 01:04:24.280]  что процедура кодирования нехорошая. То есть она кодирует в один и тот же код два разных
[01:04:24.280 --> 01:04:49.400]  дерева. Ну, давайте проведем с этими деревьями. Пусть эти деревья... эти деревья. Т1 это 2. Ну,
[01:04:49.440 --> 01:04:59.680]  смотрите, у них одинаковое количество вершин. Почему? Потому что, да, длина кода это количество
[01:04:59.680 --> 01:05:09.200]  вершин у дерева минус два. Они на одном и том же... они имеют одинаковое количество вершин.
[01:05:19.400 --> 01:05:42.640]  Вот. Кодируем их. Кодируем Т1, Т2. Получим последствия ребер.
[01:05:49.400 --> 01:06:13.640]  Смотрите, Е1 для Т1. Это Е1, Е2, так далее. Еn-2. Это то, что... ну, и давайте Еn-1. Это
[01:06:13.640 --> 01:06:21.320]  ребро, которое... ну, как бы... То есть, смотрите, мы сначала вычеркнем ребро Е1, потом ребро Е2,
[01:06:21.320 --> 01:06:27.720]  потом, так далее. При кодировании то, что происходит. Понимаете? Мы режем ребра. Так. Ну,
[01:06:27.720 --> 01:06:36.240]  вот записываем, какие ребра режем. Вот это ребро в конце, я так обозначу, оно не пишется в код.
[01:06:36.240 --> 01:06:54.120]  Оно последнее осталось, и оно в код не записывается. Для Т2. Е1 штрих, Е2 штрих, Еn-2 штрих,
[01:06:54.120 --> 01:07:05.840]  и последнее Еn-2, Еn-1 штрих, в код не записывается. При этом, понимаете, вот при такой
[01:07:05.840 --> 01:07:16.800]  нарезке ребер у нас код одинаковый получился и там, и там. Но, смотрите, это же все ребра деревьев.
[01:07:16.800 --> 01:07:32.840]  И вот это все ребра деревьев. Так. Ну, в код не пишется просто, я обозначил. При кодировании оно
[01:07:32.840 --> 01:07:43.760]  не записывается, оно последнее осталось. Так, смотрите. Эти разные деревья, значит, есть разные
[01:07:43.760 --> 01:07:51.760]  ребра. Что такое разный граф? Это граф, у которых есть в одном графе, есть ребро между двумя вершинами,
[01:07:51.760 --> 01:07:58.520]  а в другом, а между этими вершинами, ребра нет. Вот просто критерии проверки. Что значит разный
[01:07:58.520 --> 01:08:07.480]  граф? Конкретно две вершины на одном и том же множестве вершин, а это одного ДН. Значит, смотрите,
[01:08:07.480 --> 01:08:13.240]  значит, вот эти разные ребра где-то здесь проявятся, то есть есть опять позиция, в которых расхождение
[01:08:13.240 --> 01:08:19.360]  произойдет. То есть опять выберем наименьшее Т, для которого все одинаковые ребра идут, а вот над
[01:08:19.360 --> 01:08:48.120]  этом месте разное. Т наименьшее от 1 до n-2, n-1 наименьшее. Такое, что для любого
[01:08:48.120 --> 01:09:10.360]  и от единички до t-1, e1, e и t равно e и t штрих, но e t, соответственно, штрих не равно e t. То есть
[01:09:10.360 --> 01:09:24.000]  все до этого совпадают, а на этой позиции разные. Вот все эти префиксы, весь этот префикс одинаковый,
[01:09:24.000 --> 01:09:33.400]  а вот здесь разная. Помните, как мы вам доказали, что процедура кодирования такая, что вот это все,
[01:09:34.040 --> 01:09:42.360]  все вот это вместе, все вот эти ребра с позиции до конца вместе образуют дерево.
[01:09:42.360 --> 01:09:55.640]  Ну нет, если мы вот эти ребра начальные соединим, то они в дерево не обязательно
[01:09:55.640 --> 01:10:02.240]  соединяться. Понимаете, мы можем изолированные ребра какие-нибудь получить, что-нибудь такое,
[01:10:02.240 --> 01:10:09.800]  а вот с какого-то момента и до конца это дерево. Потому что так процедура работает,
[01:10:09.800 --> 01:10:17.000]  мы каждый раз режем лист, понимаете, и то, что остается, является деревом, а там все оставшиеся
[01:10:17.000 --> 01:10:27.960]  ребра. Получается, что мы, обратите внимание, ребят, вот этот префикс одинаково убираем,
[01:10:27.960 --> 01:10:46.120]  у нас получается, если t конечно не ноль, а t не равно единицы. Нет, не на каждом шаге получается
[01:10:46.120 --> 01:10:55.920]  дерево, на каждом шаге мы отрижаем лист. Если их сложить, вот эти дерево, если вот с какого-то
[01:10:55.920 --> 01:11:03.000]  с любого момента начать и до конца взять, то получится именно дерево. Я вот это утверждаю,
[01:11:03.000 --> 01:11:09.520]  а не сначала. Начальные вы можете префикс взять, сложить, там получится лес, вообще говоря,
[01:11:09.520 --> 01:11:16.840]  но не дерево. На этом же доказательство корректности-то основывалось у нас,
[01:11:16.840 --> 01:11:23.160]  что именно с начала с какого-то момента и до самого конца, если взять, то именно дерево
[01:11:23.160 --> 01:11:28.960]  получится. А потом, если отмотать чуть-чуть назад, то мы добавим к этому дерево лист. Поняли?
[01:11:28.960 --> 01:11:38.400]  Вот. Ну, то есть, если t не равно единицы, то мы получили противоречие с наименьшитью n, да?
[01:11:38.400 --> 01:11:51.160]  Ну, то есть, смотрите, пусть есть два дерева, n наименьшее будем считать. Так-так-так-так-так,
[01:11:51.160 --> 01:12:11.600]  я опять не написал, что n наименьшее. И наименьшим числом вершин. Да, именно, сейчас вот этот
[01:12:11.600 --> 01:12:17.680]  случай я забыл рассмотреть, если t равно единицы здесь. То есть, начало различия начинается с самого
[01:12:17.680 --> 01:12:24.960]  начала. Нет, в данном случае я корректно написал t-1. То есть, если t равно единицы,
[01:12:24.960 --> 01:12:32.200]  то от единицы до t-1, короче, пустое множество. Для любого i из пустого множества, короче,
[01:12:32.200 --> 01:12:39.400]  вот так. Тут выйдет, если t равно единице, то здесь будет квантор для любого i из пустого
[01:12:39.400 --> 01:12:50.200]  множества. А он, как вы знаете, верен всегда. Но при этом с первой позиции у нас разница.
[01:12:50.200 --> 01:13:08.320]  Вот, значит, смотреть. Наименьшее среди пар деревьев с таким свойством, ну, то есть,
[01:13:08.320 --> 01:13:28.640]  у которого один код, одинаковым кодом. Видите, извините, я предполагал, что вчерашняя переработка
[01:13:28.640 --> 01:13:34.640]  и моя усталость, кажется, сегодня, что я не смогу нормально, буду путаться и буду забывать
[01:13:34.960 --> 01:13:50.760]  говорить важные вещи. Но спасибо, что поправляете. Ну, что тогда? Тогда у нас получается вот что.
[01:13:50.760 --> 01:14:00.640]  Вот здесь давайте посмотрим, если t равно единице.
[01:14:20.760 --> 01:14:34.080]  То е первое равно не равно е первое штрих. Сразу разница пошла. Ну, давайте тогда докажем в таком
[01:14:34.080 --> 01:14:49.720]  случае, что мы и код на первой позиции разный получим. Почему? А нож на первой позиции, смотрите,
[01:14:49.720 --> 01:15:14.200]  смотрите, пусть е1 это у1, в1, е2 это у1 штрих, в1 штрих. Ну, что у нас будет? Где вот это лист?
[01:15:14.200 --> 01:15:33.280]  И вот это лист. Смотрите, если у1 не равно у1 штрих, то уже беда. Да неважно какие у нас там
[01:15:33.280 --> 01:15:45.080]  листы. Мы же пишем вот эти номера вот этих вершин. Правильно? Они разные. Они разные. Поэтому
[01:15:45.080 --> 01:15:55.520]  в код запишутся разные цифры. Запишутся разные цифры на первую позицию.
[01:16:03.920 --> 01:16:04.440]  Спасибо.
[01:16:23.440 --> 01:16:24.080]  Противоречие.
[01:16:29.600 --> 01:16:30.400]  Ну, значит,
[01:16:33.280 --> 01:16:44.920]  у1 равно у2, а листы как раз разные. Ну, опять тогда плохо получается, потому что мы же выбираем
[01:16:44.920 --> 01:17:02.120]  лист с наименьшим номером. Но как бы получается, что в одном дереве у нас есть два разных ребра,
[01:17:02.120 --> 01:17:11.800]  одно идёт, они идут из одного и уже у1, но в разные листы. Да, одно меньше другого.
[01:17:11.800 --> 01:17:32.560]  Ну, то есть получается, что второй лист, наверное, не с наименьшим номером, да, у нас вышел.
[01:17:32.560 --> 01:17:38.680]  Да.
[01:17:41.800 --> 01:18:02.920]  Сейчас подумаем.
[01:18:02.920 --> 01:18:23.400]  Тогда мы получается... О чём уходит тогда? Тогда уходит, что мы можем срезать эти два листа,
[01:18:23.400 --> 01:18:35.320]  да, сократить количество вершин в дереве, а им будут соответствовать одни коды, да. Ну, как бы да.
[01:18:35.320 --> 01:18:56.520]  Получается, если, значит, но тогда срезая листы в1 и в1 штрих,
[01:18:56.520 --> 01:19:03.280]  получается два более маленьких дерева с одинаковыми кодами, противоречие.
[01:19:03.280 --> 01:19:31.600]  Два более коротких дерева, более, два дерева, различных дерева. Почему они различны? Ну,
[01:19:31.600 --> 01:19:40.000]  потому что там набор вершин даже разный. Ну, потому что там в1 штрих, здесь мы убрали в1,
[01:19:40.000 --> 01:19:48.720]  здесь убрали в1 штрих, это разные вершины, там набор вершин разный. Два различных дерева на
[01:19:48.720 --> 01:20:09.600]  n вершинах, на n-1 вершинах с одинаковым кодом. Опять противоречие. Вот здесь давайте вернёмся,
[01:20:09.600 --> 01:20:18.720]  да, правильное замечание, я забыл рассмотреть случаи, когда у нас, значит, ну t равно 0, то есть
[01:20:18.720 --> 01:20:26.320]  различия пошли в самом начале декодирования. То есть у нас в начале декодирования, в начале
[01:20:26.320 --> 01:20:48.880]  декодирования два кода, у них уже 1 не равно b1, что тогда? Ну, тогда, смотрите, если мы,
[01:20:49.080 --> 01:20:55.760]  ну мы ищем внизу наименьшие, вверху наименьшие, с таким свойством, что они,
[01:20:55.760 --> 01:21:07.440]  но тут похоже что-то нужно сделать, правильно, да, как вы думаете? То есть нужно, ну предположим,
[01:21:07.440 --> 01:21:12.520]  что они будут соединены в первый код и второй будут соединены с разными вершинами, что тогда?
[01:21:12.520 --> 01:21:29.080]  Тогда мы коды, как бы, ну, как бы, смотрите, мы срезали коды, ну, давайте, как раз в 5 минут
[01:21:29.080 --> 01:21:38.720]  закончим с этими доказательствами и это как раз, ну, по сути, это как раз теория Манафеева,
[01:21:38.720 --> 01:21:52.560]  лекцию. Как вы видите, довольно тяжелая теория Манафеева. То есть,
[01:22:08.720 --> 01:22:22.040]  ну вот это вот доказательства про декодирование, я просто забыл тут рассмотреть случаи, когда вот
[01:22:22.040 --> 01:22:35.960]  эта разница пошла с самого начала, самая первая позиция различна. Смотрите, вот тут разные числа
[01:22:35.960 --> 01:22:43.960]  стоят. Соответственно, оно должно декодироваться в одно и то же дерево, поэтому, ну, как бы,
[01:22:43.960 --> 01:22:51.440]  смотрите, но ищем здесь, да и меньшие, которые отсутствуют вверху, пускай там, не знаю,
[01:22:51.440 --> 01:23:14.440]  как это обозначить, а первое к первое, а здесь первое ко второе. Так, в таком случае, смотрите,
[01:23:14.440 --> 01:23:23.720]  мы вот здесь срежем ко первое, здесь удалим ко первое внизу, а здесь удалим ко второе внизу. Так,
[01:23:23.720 --> 01:23:34.720]  тогда у нас длины кодов последовательно сократятся, но внизу уже вот в первой
[01:23:34.720 --> 01:23:39.240]  последовательности, во второй последовательности будут разные последовательности, может разные
[01:23:39.240 --> 01:23:46.640]  числа вычеркнули, так, и мы сократим длины последовательности на единичку, противоречит
[01:23:46.640 --> 01:24:00.120]  предположении на имельшести, правильно? Нет-нет-нет, оно декодируется в одно, то есть,
[01:24:00.120 --> 01:24:28.960]  да, верно, да, так, так, так, так, так, так, так, то есть, мы, получается,
[01:24:28.960 --> 01:24:42.360]  так, вот здесь я сейчас немножко, извините, наверное, нужно продумать, все-таки нормально
[01:24:42.360 --> 01:24:49.200]  доказать на следующий раз, прошу прощения, давайте закончим, подумать надо здесь, вот это
[01:24:49.200 --> 01:24:56.640]  вопрос интересный, сейчас, скорее всего, что-то очень простое, но я то, что очень устал, я не мог
[01:24:56.640 --> 01:25:12.480]  особразить, вот, да, да, да, именно, именно, именно, в этом я понял, да, в чем проблема,
[01:25:12.480 --> 01:25:14.400]  нужно подумать, почему так не бывает.
