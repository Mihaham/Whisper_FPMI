[00:00.000 --> 00:12.000]  Добрый день! Сегодня у нас последняя лекция, ну и мы закончим разговор про вероятностные алгоритмы.
[00:12.000 --> 00:21.000]  Значит, мы начнем более-менее с того же самого места, где мы закончили.
[00:21.000 --> 00:31.000]  Мы в прошлый раз изучили много разных сложностных классов, связанных с вероятностью.
[00:31.000 --> 00:40.000]  Мы изучили, как их можно варьировать, как влияет ошибка, которую мы разрешаем.
[00:41.000 --> 00:49.000]  На основании уменьшения ошибки мы смогли доказать, что все вероятностные алгоритмы можно смоделировать
[00:49.000 --> 00:57.000]  детерминированными схемами. Вероятностные схемы тоже можно рассматривать, но они ничего не дадут дополнительно.
[00:57.000 --> 01:17.000]  Схемные классы – это не единственное, что у нас было в первой части. Некоторые связи были с классом PSPACE, с классами NP и CoNP.
[01:17.000 --> 01:27.000]  Но сейчас я хочу сказать про кое-что другое, а именно про полиномиальную иерархию.
[01:27.000 --> 01:32.000]  Это называется теорема гачи Сипсера.
[01:32.000 --> 01:53.000]  Третье заключается в том, что BPP вложено в пересечение сигма два-полиномиальная и пи два-полиномиальная.
[02:02.000 --> 02:14.000]  Хорошо. Получается, что класс BPP лежит в полиномиальной иерархии и на самом деле очень высоко, на втором уровне.
[02:14.000 --> 02:41.000]  Во-первых, определение BPP симметрично, поэтому если А лежит в BPP, то и дополнение К лежит в BPP.
[02:41.000 --> 02:51.000]  Ну или иначе говоря, можно сказать, что BPP равняется CoBPP.
[02:51.000 --> 03:01.000]  Вот. Соответственно, достаточно что-то одно из этого доказать. В смысле одно из вложений вот сюда вот и вот сюда вот.
[03:01.000 --> 03:23.000]  Да, поэтому будем доказывать, будем доказывать, что BPP вложено в пи два-полиномиальное.
[03:23.000 --> 03:37.000]  Сейчас, наоборот, мы докажем, что BPP вложено в сигма два-полиномиальное.
[03:37.000 --> 03:59.000]  Так, значит, идея. Идея сначала уменьшим ошибку, сделав ее экспоненциально малой.
[03:59.000 --> 04:05.000]  Насколько конкретно экспоненциально мало этого? Сейчас посмотрим.
[04:05.000 --> 04:32.000]  Вот. Значит, тогда в пространстве всех R множество тех, которые дают результат один,
[04:32.000 --> 04:43.000]  это множество либо совсем маленькое, либо совсем маленькое, либо очень большое, занимающее почти все.
[05:02.000 --> 05:18.000]  Это извините.
[05:18.000 --> 05:42.000]  Так, хорошо. Может быть, две ситуации, я их так условно нарисую.
[05:42.000 --> 05:50.000]  Значит, смотрите, вот это прямоугольничек. Прямоугольничек это как бы все пространство.
[05:50.000 --> 06:02.000]  Значит, пространство этих самых R.
[06:02.000 --> 06:22.000]  Так, и дальше могут быть разные ситуации. Может быть, тут вот такое небольшое какое-то множество.
[06:22.000 --> 06:32.000]  Вот, а может быть, какое-то такое вот большое.
[06:32.000 --> 06:42.000]  То есть, может быть, оно там совсем немножко занимает, а может быть, вот так вот почти все.
[06:42.000 --> 06:52.000]  Вот, и дальше смотрите. Дальше мы возьмем и так подвигаем немножко.
[06:52.000 --> 06:58.000]  То есть мы как бы возьмем и вот так вот сдвинем.
[06:58.000 --> 07:12.000]  Но тогда, если у нас множество было маленькое, то тогда, соответственно, даже если немножко подвинуть,
[07:12.000 --> 07:18.000]  то оно все равно, даже все эти копии займут немного.
[07:18.000 --> 07:32.000]  Вот, а вот если взять большое множество и его немножко подвигать.
[07:32.000 --> 07:42.000]  Вот так вот его продвигать на все стороны.
[07:42.000 --> 07:52.000]  То вот уже видно, что тут все, значит, все будет покрыто хотя бы один раз.
[07:52.000 --> 07:56.000]  Значит, я уж стрелка тут не буду рисовать.
[07:56.000 --> 08:03.000]  Ну, в общем, видно, что вот это исходное, мы его так подвинули, оно все покрыло.
[08:03.000 --> 08:09.000]  Но, конечно, то, что я рисую, это метафора, потому что наше пространство это никакие не прямоугольники.
[08:09.000 --> 08:15.000]  Это булливкуб.
[08:15.000 --> 08:19.000]  Но, тем не менее, на булливом кубе тоже есть слиги.
[08:19.000 --> 08:24.000]  Значит, слиги по каждой координате по отдельности.
[08:24.000 --> 08:32.000]  И, соответственно, тоже вот такими слигами можно покрыть все пространство.
[08:32.000 --> 08:44.000]  Значит, теперь идея.
[08:44.000 --> 09:00.000]  Значит, общая идея состоит в том, что если множество подходящих R маленькое,
[09:00.000 --> 09:23.000]  то даже если его сдвинуть на
[09:23.000 --> 09:49.000]  примерное число разных лекторов, то, соответственно, даже объединение всех копий не покроет все пространство.
[09:49.000 --> 10:07.000]  Вот, а если множество большое, если же множество большое, то, соответственно, при каком-то подборе слигов
[10:07.000 --> 10:24.000]  объединение всех множеств покроет все пространство.
[10:24.000 --> 10:38.000]  И тогда, но это еще надо доказать, значит, тогда идея такая, значит, формула будет такая, что существуют сдвиги,
[10:38.000 --> 10:54.000]  значит, такие, что любая точка попадает в образ при одном из сдвигов.
[10:54.000 --> 11:06.000]  Вот это как раз Сигма-2 формула.
[11:06.000 --> 11:18.000]  Ну, значит, теперь этот план нужно реализовать, то есть нужно доказать, что действительно будет такая же ситуация как на картинках.
[11:18.000 --> 11:40.000]  Вот, значит, но тут нам, но первая часть более-менее очевидна.
[11:40.000 --> 11:48.000]  Ну, значит, первая часть очевидна, что если это может экспоненциально маленькое, то полимерное число сдвигов тут не хватит.
[11:48.000 --> 12:03.000]  Вот, но нужно вторую часть объяснить.
[12:03.000 --> 12:23.000]  Вот, но, значит, тут будем действовать так, значит, смотрите, пусть у нас rx,
[12:23.000 --> 12:37.000]  значит, rx это множество таких r, что m от xr равно единице.
[12:37.000 --> 12:55.000]  То есть здесь длина r равна m, а размер rx у нас будет больше, больше, чем 2 в степени m на 1 минус епсилон.
[12:55.000 --> 13:09.000]  Вот, ну, а епсилонка эта экспоненциально маленькая, ну, можно считать, что епсилон равняется 1 делить на 2 в степени n, где n длина x, а m, соответственно, больше.
[13:09.000 --> 13:15.000]  Потому что случайных битов может быть нужно больше, чем длина входа.
[13:15.000 --> 13:23.000]  Так, значит, вот rx, значит, rx это вот такая штука.
[13:23.000 --> 13:29.000]  Теперь можно рассмотреть сдвиги.
[13:29.000 --> 13:54.000]  Сдвиги это r, rx поксоренное каким-то s, то есть это множество таких ксоров по битвах r плюс s, значит, таких, что m от xr равно единице.
[13:54.000 --> 14:14.000]  Вот, ну, на самом деле это также то же самое, что множество таких r, что m от x и r плюс s равно, ой, r плюс s равно единице.
[14:14.000 --> 14:26.000]  Значит, потому что, ну, неважно, да, мы тут делаем ксор или тут делаем ксор, поскольку два раза делать ксор то же самое, что ничего не изменить.
[14:26.000 --> 14:52.000]  Вот, а r все равно все значения предлагает. Ну, в принципе, все значения предлагают.
[14:52.000 --> 15:21.000]  Вот, хорошо. Значит, теперь мы хотим показать, нужно показать, что для некоторого полиномиального q будет верно, что найдутся s1,
[15:21.000 --> 15:46.000]  и так далее, sq такие, что объединение всех rx сдвинутых на s и t, значит, равно просто всем словам длины m, то есть всем возможным набору случайных битв.
[15:46.000 --> 16:07.000]  Так, это реализуется вероятностным методом. Воспользуемся вероятностным методом, но я предполагаю, что у вас уже был вероятностный метод на дискретном анализе.
[16:07.000 --> 16:19.000]  Соответственно, тут классический метод заключается в том, что мы возьмем эти сдвиги случайно и покажем, что с положительной вероятностью они все подойдут.
[16:19.000 --> 16:37.000]  Значит, реализуется метод, рассмотрим случайные сдвиги s1, и так далее, sq.
[16:37.000 --> 17:06.000]  Вот, и посчитаем вероятность того, что какой-то вектор, значит, какая-то строка не попала ни в одно из множеств rx плюс s и t.
[17:07.000 --> 17:26.000]  Вот, значит, как мы это будем делать?
[17:26.000 --> 17:40.000]  Да, оно сейчас было случайно, значит, случайное, то есть независимое и равномерно распределенное.
[17:40.000 --> 17:56.000]  Ну, и посчитаем вероятность того, что какая-то строка не попала ни в одно из множеств rx плюс s и t.
[17:56.000 --> 18:20.000]  Ну, и посчитаем вероятность того, что какая-то строка не попала ни в одно из множеств rx плюс s и t.
[18:20.000 --> 18:30.000]  Ну, а значит, что одновременно случились ку событий.
[18:30.000 --> 18:33.000]  Да, например, случился ку событий.
[18:33.000 --> 18:42.000]  Так, давайте что-нибудь писать раньше того, что w.
[18:42.000 --> 19:09.000]  Да, давайте напишем так, что для любого и у нас случилось, что w, значит, точно неверно, что w попало в rx плюс s и t.
[19:09.000 --> 19:37.000]  Вот, это равно, значит, поскольку тут можно перекидывать вот так вот, s туда и сюда, значит, это равно в точности вероятность того, что для любого и неверно,
[19:37.000 --> 19:54.000]  что w плюс s и t лежит в rx.
[19:54.000 --> 20:16.000]  Ну, то есть можно сказать, что для любого и w плюс s и t у нас лежит в rx чертой.
[20:16.000 --> 20:24.000]  Ну, а смотрите, значит, это еще независимые события, поскольку s и t независимые, и они все сразу произошли, то есть это просто произведение.
[20:24.000 --> 20:49.000]  Значит, это получается произведение и от единицы до ку вероятности того, что w плюс s и t попало в rx чертой.
[20:49.000 --> 21:12.000]  Ну, а в этом у нас вероятность епсилон, значит, равно произведению епсилонов.
[21:12.000 --> 21:30.000]  Так, и это у нас равно епсилон в степени q, то есть это равно 1 делить на 2 в степени nq.
[21:30.000 --> 21:49.000]  Так, хорошо. Ну, это пока для конкретной строки, значит, для фиксированной строки w.
[21:49.000 --> 21:59.000]  А теперь посчитаем вероятность того, что найдется такая строка.
[21:59.000 --> 22:28.000]  Вероятность того, что существует w, значит, эта штука, да, это будет меньше равно, чем сумма по всем w, вероятность вот таких вот.
[22:28.000 --> 22:43.000]  Так, сейчас только тут где-то, вот тут, наверное, должно быть меньше, тут же больше, значит, тут не равно, а меньше.
[22:43.000 --> 23:06.000]  Вот, соответственно, это получается меньше, значит, чем сумма по w, соответственно, вот этих вот штук.
[23:06.000 --> 23:15.000]  И это будет равняться 2 в степени m поделить на 2 в степени nq.
[23:15.000 --> 23:37.000]  Соответственно, это будет меньше единица при nq больше m, да, ну, то есть q больше, чем m делить на n, что есть полином.
[23:37.000 --> 23:55.000]  Вот, ну, соответственно, если, значит, если вот эта вот вероятность меньше единицы, то, соответственно, вероятность дополнения больше нуля.
[23:55.000 --> 24:20.000]  Значит, тут будет наоборот, да, для любого существует, и тут без отрицания это будет больше нуля.
[24:25.000 --> 24:44.000]  Вот, ну, а это значит, значит, значит, можно зафиксировать и осытая, так чтобы, соответственно, вот это было верно.
[24:44.000 --> 25:03.000]  Вот, ну, а это значит то, что нам нужно, значит, а это и значит вот это вот.
[25:03.000 --> 25:30.000]  Ну, вот, значит, соответственно, поскольку с другой стороны, поскольку здесь q полиномиальная, то если наоборот, если это rx совсем маленькое, экспедиционно маленькое, то тогда сдвиги, значит, сдвиги всех этих множеств не позволит покрыть все, да, потому что они экспедиционно маленькие, мы их умножаем на полином, они остаются меньше единиц.
[25:30.000 --> 25:58.000]  Вот, ну, вот, значит, вот итог получается, да, значит, итог.
[25:58.000 --> 26:19.000]  Итог получается такой, что у нас x лежит 2 тогда и только тогда, значит, тогда и только тогда, когда верно следующее.
[26:19.000 --> 26:43.000]  Когда существует s1 и так далее сq, значит, такое, что для любого w длины m, значит, соответственно, верно.
[26:43.000 --> 26:48.000]  Но вот это вот квантосуществование у нас полиномиальный, поэтому я его так распишу.
[26:48.000 --> 27:17.000]  Наш w лежит в rx плюс s1 или и так далее, или w лежит в rx плюс sqt.
[27:17.000 --> 27:26.000]  Вот, ну, вот и есть, это есть сегмент 2 форма, да, что здесь скопка тоже полиномиально проверяется.
[27:26.000 --> 27:33.000]  Вот, ну, полиномиальный x проверяется за счет того, что это полиномиальная рецензия машина.
[27:33.000 --> 27:51.000]  Значит, это получается.
[27:51.000 --> 28:18.000]  Ну, вот, значит, вот так получается.
[28:18.000 --> 28:31.000]  Ну, есть вопросы.
[28:31.000 --> 28:32.000]  Ладно.
[28:32.000 --> 28:50.000]  Следствие такое, что если p равно np, то тогда p равно ppp.
[28:50.000 --> 29:01.000]  Потому что тогда вся полиномиальная иерархия схлопывается и все, что в иерархии находится, то есть в частности ppp, будет схлопнуто.
[29:01.000 --> 29:12.000]  Так.
[29:12.000 --> 29:14.000]  Хорошо.
[29:14.000 --> 29:18.000]  Дальше.
[29:18.000 --> 29:22.000]  Вообще-то такой большой вопрос.
[29:22.000 --> 29:25.000]  Значит, а что вообще известно?
[29:25.000 --> 29:31.000]  Значит, а что вообще известно про
[29:31.000 --> 29:37.000]  Проблема равенства p и ppp?
[29:37.000 --> 29:48.000]  Два нужных знака, да, во-первых, внутри вот здесь вот, да, и во-вторых, как вообще из фразы.
[29:48.000 --> 30:12.000]  Вот. Ну, значит, на первый взгляд, на первый взгляд, ситуация похожа на вопрос, равный ли p и np.
[30:12.000 --> 30:18.000]  В каком смысле она похожа?
[30:18.000 --> 30:36.000]  Ну, в том смысле, что есть задачи, значит, которые решаются за, соответственно, в большем классе,
[30:36.000 --> 30:48.000]  в большем классе, но не решаются в меньшем.
[30:48.000 --> 30:52.000]  Значит, есть задачи, которые решаются в большем классе, но не решаются в меньшем.
[30:52.000 --> 30:59.000]  Да, типа там задача выполнимости, да, и задача проверки равенства многочленов, например.
[30:59.000 --> 31:11.000]  Вот, значит, однако в np есть полные задачи, причем достаточно много.
[31:11.000 --> 31:16.000]  В ppp их не известно.
[31:16.000 --> 31:19.000]  Да, они, конечно, могут быть, особенно если p равно ppp.
[31:19.000 --> 31:25.000]  Но ни про одну задачу никто точно не знает, не будет ли она ppp полной.
[31:25.000 --> 31:47.000]  Вот. Но проблема стоит в том, проблема в том, что определение ppp, как говорят, симантическое, а не синтаксическое.
[31:47.000 --> 32:16.000]  Значит, что это значит? Это означает, что на самом деле далеко не любая, значит, далеко не любая вероятностная машина вообще задает какой-нибудь язык из ppp.
[32:16.000 --> 32:30.000]  Вот, да, значит, нужно, чтобы вероятности были отделены от нуля.
[32:30.000 --> 32:58.000]  Значит, вероятности были отделены от нуля. Да, то есть, точнее, от нуля, а вот 1 и 2, значит, вероятность того, что машина примет слово,
[32:58.000 --> 33:27.000]  знаешь, чтобы она была, была отделена от 1 и 2, да, значит, а именно была бы либо не больше 1 и 3, не больше 1 и 3, либо больше 2 и 3.
[33:28.000 --> 33:47.000]  Вот. А заранее, значит, заранее по тексту машины невозможно понять, будет ли эта вероятность всегда в таком диапазоне.
[33:47.000 --> 34:12.000]  Вот. Ну и поэтому, значит, поэтому нет генерического полного языка вида там код машины, там код машины, вход, время работы.
[34:12.000 --> 34:37.000]  Такой, что машина принимает этот вход, значит, потому что даже если для этого конкретного входа мы можем посчитать вероятность, то, ну, если она будет между 1 и 3, 2 и 3, да, то непонятно, что с этим делать.
[34:42.000 --> 35:11.000]  Ну вот, поэтому ПП их неизвестно. Это, как бы, такой первый звоночек. Да, значит, и на самом деле, значит, на самом деле большинство исследователей, большинство исследователей верят, что P равно PPP, значит, означает, что любой вероятностный алгоритм
[35:11.000 --> 35:25.000]  можно дерандомизировать. Вот. И основание для такой веры следующее.
[35:25.000 --> 35:43.000]  Основание для такой веры. Так, первое. Ну, первое, значит, для схемных моделей, для схемных моделей это верно.
[35:43.000 --> 36:09.000]  Да, например, BPP поле. BPP поле равно P поле.
[36:09.000 --> 36:25.000]  Но это даже не очень сильный довод. Ну, значит, более того, вот это уже более сильный довод. BPP AC0 равно AC0.
[36:25.000 --> 36:38.000]  Ну, тут вот AC0 мы проходили, значит, это означает, что схемы полиминального размера и константной глубины, соответственно, скандируются с дизюнкцией произвольного лентности.
[36:38.000 --> 36:51.000]  Ну, ABP означает, что невероятностные штаммы, кроме входа, еще какие-то случайные биты. И, соответственно, ошибка не больше 1 и третья.
[36:51.000 --> 37:12.000]  Так, вот, значит, второе, может быть, даже еще более, еще более веский довод. Hardness versus randomness.
[37:12.000 --> 37:32.000]  Значит, теорема Нисана Викторсона, значит, если есть достаточно трудные задачи. Ну, что значит достаточно трудные, я сейчас не буду конкретизировать.
[37:32.000 --> 38:00.000]  Ну, они типа, ну, если NP полные, достаточно сложно решаются. Значит, то тогда можно построить достаточно хорошие генераторы псевдослучейных чисел.
[38:00.000 --> 38:15.000]  Ну, и тогда, соответственно, P равно BPP.
[38:15.000 --> 38:37.000]  Ну, и третья обскал, что также хорошие генераторы. То есть идея вообще такая, что мы хотим заменить случайные числа, которые мы используем в алгоритме, на какие-то псевдослучайные числа, которые мы можем сами генерировать или перебирать и как-то это все делать.
[38:37.000 --> 38:43.000]  Ну, и тогда нам настоящие случайные биты уже не нужны. Мы их заменили на псевдослучайные.
[38:43.000 --> 39:01.000]  Так же хорошие генераторы можно построить на базе других конструкций. Например, экстракторов. Пока что нужных конструкций неизвестно.
[39:01.000 --> 39:26.000]  Вот, однако, значит, ну, нет и никаких препятствий для их построения.
[39:26.000 --> 39:44.000]  Вот.
[39:44.000 --> 39:53.000]  Ну, то есть тоже, значит, тоже неизвестно.
[39:53.000 --> 40:03.000]  Ну вот, хорошо. Ну и последняя тема, на которой я немножко поговорю, это что известно про дарандомизацию.
[40:03.000 --> 40:18.000]  Значит, в некоторых случаях для некоторых задач, для некоторых задач процедуры дарандомизации просто напрямую известны.
[40:18.000 --> 40:24.000]  Я уж не знаю, сколько я успею. Ну, по крайней мере, одну, один метод успею рассказать.
[40:24.000 --> 40:30.000]  Значит, рассмотрим.
[40:30.000 --> 40:46.000]  В некоторых случаях работает так называемый метод условных математических ожиданий.
[40:46.000 --> 40:51.000]  Так, давайте я расскажу, как он устроен.
[40:51.000 --> 40:59.000]  Так, посмотрим на примере. Пример. Это задача MaxCut.
[40:59.000 --> 41:25.000]  Значит, тут нужно разбить вершины графа на две группы, так чтобы число ребер между группами было бы максимальным.
[41:25.000 --> 41:37.000]  Значит, если граф вообще двудольный, значит, если граф двудольный, тогда это число может быть в принципе максимальным.
[41:37.000 --> 41:50.000]  Вот, то есть все ребра можно разрезать.
[41:50.000 --> 41:56.000]  Но если граф не двудольный, то все уже нельзя разрезать, но хочется было как можно больше.
[41:56.000 --> 42:14.000]  Значит, задача NP полная.
[42:14.000 --> 42:23.000]  Но можно рассмотреть приближенную задачу.
[42:23.000 --> 42:47.000]  Мы будем стараться разрезать число ребер, которые больше либо равно, чем РО, умноженное на максимальное количество.
[42:47.000 --> 42:57.000]  Какое число меньше единицы? Больше максимума в принципе не можем разрезать, но хотим попасть между максимумом и РО на максимуму.
[42:57.000 --> 43:12.000]  Так, хорошо. Ну и можно считать, тут есть такой вероятностный метод.
[43:12.000 --> 43:24.000]  Да, выберем просто, значит, разобьем на две группы случайно.
[43:24.000 --> 43:45.000]  Значит, а именно для каждой вершины равномерно и независимо выберем, в какую часть ее отнести.
[43:45.000 --> 43:52.000]  Вот, тогда получается утверждение.
[43:52.000 --> 44:03.000]  Тогда в среднем будет разрезано хотя бы половина ребер.
[44:03.000 --> 44:25.000]  Действительно, для каждого ребра есть четыре варианта, куда будут отнесены его вершины, но из них в двух вариантах оно будет разрезано.
[44:25.000 --> 44:41.000]  То есть верности одна-вторая, ну а дальше, конечно, эти факты могут быть зависимы для разных ребер, но по линейности мат ожидания это неважно.
[44:41.000 --> 45:04.000]  Значит, по линейности мат ожидания среднее число разрезанных ребер равно, соответственно,
[45:04.000 --> 45:16.000]  Ну, именно равно, размер е пополам.
[45:16.000 --> 45:41.000]  Ну, значит, существует разрез из больше либо равно, чем е пополам ребер.
[45:41.000 --> 46:09.000]  Ну и, соответственно, также в нем будет разрезано, точнее не так же, тем более, тем более в нем будет разрезано, тем более в нем будет разрезано, тем более в нем будет разрезано, тем более в нем будет разрезано, тем более в нем будет разрезано.
[46:09.000 --> 46:23.000]  Ну или в нем будет разрезано больше или меньше, чем одна-вторая умножить на максимум ребер.
[46:23.000 --> 46:28.000]  Максимум точно не больше, чем все.
[46:28.000 --> 46:52.000]  Ну а вопрос состоится, как явным образом найти такой разрез.
[46:58.000 --> 47:11.000]  Ну, оказывается, можно действовать жадным алгоритмом.
[47:11.000 --> 47:18.000]  Давайте я сначала, наверное, напишу жадный алгоритм, а потом расскажу, как он связан с условными от ожиданиями.
[47:19.000 --> 47:23.000]  Жадный алгоритм.
[47:23.000 --> 47:37.000]  Значит, пусть уже, пусть уже часть вершин отнесена, значит, отнесена в одной из частей.
[47:37.000 --> 47:44.000]  Рассмотрим новую вершину.
[47:44.000 --> 48:03.000]  Значит, она соединена, значит, она соединена, ну, с какими-то, с какими-то уже отнесенными вершинами.
[48:03.000 --> 48:32.000]  И мы, соответственно, отправим ее в ту часть, где находится меньшее число, меньшее число, соответственно, вершин, с которыми она уже соединена.
[48:32.000 --> 48:47.000]  Это разрежет хотя бы половину ребер от данной вершины до уже рассмотренных.
[48:47.000 --> 49:15.000]  Ну и, соответственно, объединив все оценки, получим, что разрез хотя бы у половины, ну, в разрез вошла хотя бы половина всех ребер.
[49:17.000 --> 49:25.000]  Вот.
[49:25.000 --> 49:32.000]  Ну а теперь, причем здесь условные от ожидания?
[49:32.000 --> 49:37.000]  Значит, можно считать, что у нас есть случайная величина.
[49:37.000 --> 49:47.000]  Значит, пусть кси-1 и так далее, кси-s.
[49:47.000 --> 50:01.000]  Это случайная величина, случайная величина, соответственно, не как бы отвечающая за ту часть.
[50:01.000 --> 50:06.000]  Так, сейчас, почему я? Давайте n, n обычный вершин.
[50:06.000 --> 50:15.000]  Значит, кси-n, случайная величина, отвечающая за ту часть, которую попали соответствующие вершины.
[50:15.000 --> 50:25.000]  Тогда, соответственно, пусть кси-s, соответствующие вершины.
[50:25.000 --> 50:40.000]  Значит, кси-s, случайная величина, отвечающая за ту часть, которую попали соответствующие вершины.
[50:40.000 --> 50:59.000]  Тогда, соответственно, пусть значение, значит, кси-1 и так далее, ксикаты, уже заданное.
[50:59.000 --> 51:17.000]  Значит, тогда есть условная вероятность попадания ребра ежиты в разрез.
[51:17.000 --> 51:24.000]  Значит, она, соответственно, равна нулю или единице.
[51:24.000 --> 51:34.000]  Значит, если, соответственно, оба конца уже известны, куда попали.
[51:34.000 --> 51:39.000]  Ну, давайте прям явно напишем.
[51:39.000 --> 51:50.000]  Ну, если и меньше либо равно к, и меньше либо равно к, и кси-t равно кси-житому.
[51:50.000 --> 51:59.000]  Соответственно, единица, если также, но кси-t не равно кси-житому.
[51:59.000 --> 52:12.000]  Ну, если одна вторая, если и больше к или ж больше к.
[52:12.000 --> 52:22.000]  И в данном случае нет разницы, значит, нет разницы между тем оба этих индекса больше к или только один.
[52:22.000 --> 52:27.000]  Потому что если оба, то это будут те же самые две четвертых, которые у нас там были.
[52:27.000 --> 52:36.000]  А если один, то уже действительно одна вторая. Уже остаются два варианта для второго конца, из них один подходит.
[52:36.000 --> 52:50.000]  Вот, а получается, что если мы, значит, когда мы,
[52:50.000 --> 53:15.000]  когда мы определяем значение кси-t плюс один, то, соответственно, ну, ожидания, что равны одной-второй,
[53:15.000 --> 53:23.000]  либо не меняются, ну, не меняются они когда-либо, их было обе больше к.
[53:23.000 --> 53:27.000]  Значит, если даже кто-то из них к плюс один, то это останется одна вторая.
[53:27.000 --> 53:37.000]  Либо, соответственно, кто-то больше и к плюс один.
[53:37.000 --> 53:47.000]  Ну, то есть, можно сказать, что не меняется, если и больше к плюс один или ж больше, чем к плюс один.
[53:47.000 --> 54:01.000]  Значит, либо сменяются вот с одной-второй, сменяются с одной-второй на ноль или один.
[54:17.000 --> 54:45.000]  Ну, соответственно, нужно, чтобы изменений на ноль было не больше, чем изменений на один.
[54:45.000 --> 54:51.000]  Вот, ну, или можно, значит, можно сказать таким образом.
[54:51.000 --> 55:04.000]  Смотрите, мат ожидания, значит, cat, cat от s, да, это будем считать, что размер разрез, который задан s, то есть число ребр, которые идут от s к дополнению кс.
[55:04.000 --> 55:18.000]  Значит, при условии, что там какие-то значения кси один и так далее, кси cat-ы фиксированы, это будет вот что-то, это будет одна вторая.
[55:18.000 --> 55:23.000]  Значит, вот такого же ожидания.
[55:23.000 --> 55:39.000]  И при условии, что кси к плюс один равно нулю и плюс такая штука, где кси к плюс первый равно единице.
[55:39.000 --> 56:02.000]  Ну и получается, что одно из, получается, что либо вот это вот больше, либо равно, чем то, что было, да, соответственно, или то же самое для единицы.
[56:02.000 --> 56:24.000]  Вот, поэтому можно зафиксировать, значит, можно зафиксировать кси к плюс один так, чтобы условная мат ожидания не уменьшилась.
[56:24.000 --> 56:49.000]  Ну а поскольку оно изначально равно 1 и 2, то после всех этих фиксаций будет больше 1 и 2, поскольку изначально оно равно 1 и 2, то и в конце будет больше равно 1 и 2.
[56:54.000 --> 57:02.000]  Ну вот такое рассуждение.
[57:02.000 --> 57:09.000]  Значит, тут это может казаться таким излишним загромождением, вроде же, так ясно, что работает.
[57:09.000 --> 57:12.000]  Тут мы как-то терроризируем.
[57:12.000 --> 57:21.000]  На самом деле в некоторых случаях трудно обойтись, в некоторых случаях трудно обойтись без такого явного расписывания.
[57:21.000 --> 57:25.000]  Значит, поэтому сейчас я расскажу другой пример.
[57:25.000 --> 57:30.000]  Другой пример, это называется max3sat.
[57:30.000 --> 57:39.000]  Значит, тут дана формула в формате 3knf,
[57:39.000 --> 57:48.000]  в которой в каждой скобке ровно три литерала.
[57:48.000 --> 58:01.000]  Ровно три литерала, ну, значит, вот различных переменных.
[58:01.000 --> 58:14.000]  Значит, требуется максимизировать число истинных скобок.
[58:14.000 --> 58:26.000]  Ну, на каком-то наборе.
[58:26.000 --> 58:35.000]  Вот.
[58:35.000 --> 58:42.000]  Хорошо, значит, как мы это будем делать?
[58:42.000 --> 58:49.000]  Как мы это будем максимизировать?
[58:49.000 --> 59:06.000]  Ну, и, в-первых, рассмотрим случайный набор значений переменных.
[59:06.000 --> 59:24.000]  Значит, тогда каждая скобка будет выполнена с вероятностью 7 восьмых.
[59:24.000 --> 59:28.000]  Значит, каждая скобка будет выполнена сразу с 7 восьмых.
[59:28.000 --> 59:45.000]  Ну, соответственно, среднее число истинных скобок будет равно 7 восьмых m.
[59:45.000 --> 59:49.000]  Да, m это традиционно считается, что n переменных и m скобок.
[59:49.000 --> 59:53.000]  Задача выполнимости.
[59:53.000 --> 01:00:00.000]  Ну, и среднее число истинных скобок будет 7 восьмых m.
[01:00:00.000 --> 01:00:12.000]  Ну, и, соответственно, значит, для какого-то конкретного набора их будет больше.
[01:00:12.000 --> 01:00:34.000]  Ну, начнем с 7 восьмых m.
[01:00:34.000 --> 01:00:47.000]  Так.
[01:00:47.000 --> 01:00:51.000]  Теперь как его искать?
[01:00:51.000 --> 01:00:54.000]  Как его искать?
[01:00:54.000 --> 01:00:57.000]  Так, сейчас пока не будем пользоваться вот этим медом.
[01:00:57.000 --> 01:00:59.000]  Значит, попробуем просто так найти.
[01:00:59.000 --> 01:01:01.000]  Идея первая.
[01:01:01.000 --> 01:01:03.000]  Идея один.
[01:01:03.000 --> 01:01:05.000]  Рассмотрим.
[01:01:05.000 --> 01:01:16.000]  Значит, рассмотрим все скобки с применной p.
[01:01:16.000 --> 01:01:32.000]  Если больше тех, куда входит сама p, значит, положим p равно 1.
[01:01:32.000 --> 01:01:44.000]  Если больше тех, куда входит отрицание p, значит, положим p равно 0.
[01:01:44.000 --> 01:01:47.000]  Ну, если поровну, то неважно.
[01:01:47.000 --> 01:01:50.000]  Если поровну, то неважно.
[01:01:50.000 --> 01:01:55.000]  Как-нибудь положим.
[01:01:55.000 --> 01:02:02.000]  Ну, и, соответственно, теперь исключим.
[01:02:02.000 --> 01:02:26.000]  Значит, таким образом мы выполнили половину всех скобок с переменной p.
[01:02:26.000 --> 01:02:27.000]  Вот.
[01:02:27.000 --> 01:02:29.000]  Исключим их всех из рассмотрения.
[01:02:29.000 --> 01:02:37.000]  Значит, исключим их из рассмотрения.
[01:02:37.000 --> 01:02:46.000]  Значит, теперь из оставшихся рассмотрим все с переменной q.
[01:02:46.000 --> 01:02:51.000]  Так, ну, тут сейчас надо написать хотя бы половину.
[01:02:51.000 --> 01:03:02.000]  Аналогично выполним хотя бы половину из них.
[01:03:02.000 --> 01:03:05.000]  Ну, и так далее.
[01:03:05.000 --> 01:03:16.000]  Значит, в итоге выполним хотя бы половину всех скобок.
[01:03:16.000 --> 01:03:23.000]  Ну, однако это, конечно, верное рассуждение, но видно, что мы здесь совершенно не оптимально действовали.
[01:03:23.000 --> 01:03:29.000]  А именно, значит, те скобки, которые мы выкидывали, которые были ложны,
[01:03:29.000 --> 01:03:35.000]  может, было не выкидывать, а попробовать их еще раз выполнить, потому что там же еще две переменных остались.
[01:03:35.000 --> 01:03:42.000]  Но зато вот это вот точно работает, даже если у нас не ровно три литералы, а может быть меньше трех литералов.
[01:03:42.000 --> 01:03:48.000]  Потому что в дате 7 восьмых это явно исполнил, что у нас тут три разных.
[01:03:48.000 --> 01:03:55.000]  Значит, три разных переменных.
[01:03:55.000 --> 01:03:58.000]  Так, идея два.
[01:03:58.000 --> 01:04:01.000]  Значит, идея два.
[01:04:01.000 --> 01:04:10.000]  Что, ну, как в предыдущем будем действовать как выше.
[01:04:10.000 --> 01:04:29.000]  Но, соответственно, если литерал в формуле оказался ложным, то не будем выкидывать всю формулу.
[01:04:29.000 --> 01:04:37.000]  Значит, вычеркнем только этот литерал.
[01:04:37.000 --> 01:04:43.000]  И будем смотреть на оставшуюся скобку.
[01:04:43.000 --> 01:04:48.000]  Ну, оставшуюся скобка может быть из двух литералов или просто из одного.
[01:04:48.000 --> 01:04:53.000]  И, соответственно, учитывать при последующих шагах.
[01:04:53.000 --> 01:05:06.000]  Значит, и учитывать ее при последующих шагах.
[01:05:06.000 --> 01:05:26.000]  Так, значит, тут так получится выполнить хотя бы три четверти всех скобок.
[01:05:26.000 --> 01:05:49.000]  Потому что до того, как скобка окончательно станет ложной, нужно вычеркнуть три литерала.
[01:05:49.000 --> 01:06:01.000]  Вот, соответственно, а с каждым из них какая-то другая скобка станет истинной.
[01:06:01.000 --> 01:06:06.000]  То есть на одну ложь у нас как минимум три истины приходится.
[01:06:06.000 --> 01:06:10.000]  Ну, а три четвертых это все еще не семь восьмых.
[01:06:10.000 --> 01:06:29.000]  Ну и тогда, соответственно, идея три будем использовать условным от ожидания.
[01:06:29.000 --> 01:06:38.000]  Значит, идея три будем использовать условным от ожидания.
[01:06:38.000 --> 01:06:54.000]  Значит, и здесь происходит следующее.
[01:06:54.000 --> 01:06:58.000]  Ну, смотрите, пусть у нас вот есть какая-то формула phi.
[01:06:58.000 --> 01:07:06.000]  Значит, phi это наша формула.
[01:07:06.000 --> 01:07:16.000]  Точнее, посмотрим на конкретную скобку.
[01:07:16.000 --> 01:07:27.000]  Пусть C, значит, это некоторая скобка.
[01:07:27.000 --> 01:07:33.000]  Некоторая скобка, да, значит, неопременно.
[01:07:33.000 --> 01:07:57.000]  Так, значит, дальше набор значений P1 и так далее Pk задает вероятность истинности C.
[01:07:57.000 --> 01:07:59.000]  Значит, и эта вероятность будет такая.
[01:07:59.000 --> 01:08:02.000]  Это будет один.
[01:08:02.000 --> 01:08:12.000]  Значит, один, если в C есть истинный литерал.
[01:08:12.000 --> 01:08:24.000]  Дальше ноль, если в C все три литерала ложные.
[01:08:24.000 --> 01:08:29.000]  А если два ложные, то одна вторая.
[01:08:29.000 --> 01:08:40.000]  Если в C уже два литерала ложные.
[01:08:40.000 --> 01:08:48.000]  Если один ложный, то три четверти.
[01:08:48.000 --> 01:08:55.000]  Если в C один ложный литерал.
[01:08:55.000 --> 01:09:05.000]  Ну и, наконец, семь восьмых.
[01:09:05.000 --> 01:09:16.000]  Если два литерала ложные, а третий неопределенный.
[01:09:16.000 --> 01:09:21.000]  То есть тут один ложный, два неопределенных.
[01:09:21.000 --> 01:09:31.000]  И семь восьмых, если все три неопределенных.
[01:09:31.000 --> 01:09:59.000]  Вот, а получается, что определение новой переменной переводит каждую скобку либо в первую категорию,
[01:09:59.000 --> 01:10:01.000]  либо на шаг выше.
[01:10:01.000 --> 01:10:05.000]  То есть из всех этих, кроме нуля, уже никуда нельзя перейти.
[01:10:05.000 --> 01:10:08.000]  Из одной, второй, третьей, четверти, семи восьмых.
[01:10:08.000 --> 01:10:13.000]  Либо литерал истинный, тогда сразу скобка становится истинной.
[01:10:13.000 --> 01:10:17.000]  Либо ложный, тогда, соответственно, на шаг выше.
[01:10:17.000 --> 01:10:35.000]  То есть из семи восьмых можно перейти в один или в три четверти.
[01:10:35.000 --> 01:10:46.000]  То есть из трех четвертей можно перейти в один или в одну вторую.
[01:10:46.000 --> 01:11:01.000]  То есть из одной второй можно перейти в один или в ноль.
[01:11:01.000 --> 01:11:22.000]  И тут получается, что цена вопроса для скобки с одним ложным литералом вдвое выше,
[01:11:22.000 --> 01:11:49.000]  а с двумя ложными литералами в четверо выше, чем для полностью неопределенной скобки.
[01:11:49.000 --> 01:12:01.000]  Вот, ну если случается алгоритм, значит алгоритм такой, аналогично идее 2,
[01:12:01.000 --> 01:12:12.000]  но скобки из двух литералов берем с весом 2, а из четырех литералов,
[01:12:12.000 --> 01:12:21.000]  ой, в смысле из одного литерала, из одного литерала с весом 4.
[01:12:21.000 --> 01:12:30.000]  Получается, что каждый раз мы берем все оставшиеся скобки с данной переменной новой,
[01:12:30.000 --> 01:12:36.000]  вот с такими весами их складываем, смотрим, где больше те, где сама переменная,
[01:12:37.000 --> 01:12:44.000]  соответственно выбираем, чему равна переменная,
[01:12:44.000 --> 01:12:52.000]  и соответственно вычеркиваем все скобки, которые стали истинными,
[01:12:52.000 --> 01:13:01.000]  и вычеркиваем литералы, которые стали ложными, и тогда у нас в скобках уменьшится число литералов неопределенных.
[01:13:01.000 --> 01:13:08.000]  Ну и это на самом деле ровно то, что вот здесь происходит,
[01:13:08.000 --> 01:13:17.000]  то есть вот эти вот 1, 2, 3, 4, 10, 7, 8, это как бы слагаемые в этом ожидаемом размере,
[01:13:17.000 --> 01:13:21.000]  только не разрезывая уже числа выполнения скобок,
[01:13:21.000 --> 01:13:27.000]  ну и соответственно вот эти слагаемые переходят в какие-то другие, мы хотим, чтобы оно не уменьшилось.
[01:13:27.000 --> 01:13:32.000]  Вот, но как раз если мы будем делать так, как здесь написано, то оно не уменьшится.
[01:13:36.000 --> 01:13:46.000]  Вот, значит вот такой вот метод, но соответственно метод условных мат ожиданий,
[01:13:46.000 --> 01:14:02.000]  метод условных мат ожиданий можно применять всегда, когда эти самые ожидания можно вычислить.
[01:14:02.000 --> 01:14:11.000]  Потому что это, ну, соотношение-то верно всегда.
[01:14:11.000 --> 01:14:19.000]  Вот это соотношение верно всегда, всегда у нас решение стоит из битов, всегда мы их можем по очереди как-то определять.
[01:14:19.000 --> 01:14:29.000]  Вот, но если мы их не умеем считать, то мы тогда не поймем, будет вот это вот верно или вот это вот верно.
[01:14:30.000 --> 01:14:34.000]  Вот, значит вот такой вот способ.
[01:14:37.000 --> 01:14:46.000]  Так, но у меня еще остается немножко времени, я вкратце расскажу про метод парнонезависимости.
[01:14:46.000 --> 01:15:01.000]  Другой метод называется метод парнонезависимых случайных величин.
[01:15:01.000 --> 01:15:29.000]  Значит, тут идея такая, я тоже, значит, тоже на примере MaxCut, значит, например задача о максимальном разрезе.
[01:15:31.000 --> 01:15:55.000]  Так, ну тут смотрите какая идея.
[01:15:55.000 --> 01:16:10.000]  Да, значит, можно было, можно выбирать Xi1 и так далее, XiKT.
[01:16:10.000 --> 01:16:38.000]  Значит, достаточно выбирать парнонезависимые, чтобы, соответственно, ожидаемый размер разреза был бы равен числу ребер пополам.
[01:16:38.000 --> 01:16:47.000]  Значит, потому что, ну тут у нас было какое рассуждение, что у нас четыре варианта равновероятны.
[01:16:47.000 --> 01:16:52.000]  Что обе вершины налево, обе вершины направо, первые налево, вторые направо и наоборот.
[01:16:52.000 --> 01:16:58.000]  Но чтобы они были равновероятны, достаточно чтобы эти вершины попали независимо друг от друга налево и направо.
[01:16:58.000 --> 01:17:06.000]  Ну а попарнонезависимые можно генерировать довольно простым образом.
[01:17:06.000 --> 01:17:24.000]  Значит, можно сгенерировать два в степени L-1 попарнонезависимых случайных величин,
[01:17:24.000 --> 01:17:47.000]  имея только L истинно независимых, то есть независимых совокупностей, называется, независимых совокупностях случайных величин.
[01:17:47.000 --> 01:18:01.000]  Значит, именно подойдут X1 и так далее, XL. Да, они все бинарные, да, либо 0, либо единица.
[01:18:01.000 --> 01:18:28.000]  Дальше X1 плюс X2, X1 плюс X3 и так далее, там X1 плюс XL и так далее, там XL минус 1 плюс XL, там X1 плюс X2 плюс X3.
[01:18:28.000 --> 01:18:47.000]  Ну и так далее, да, в общем, это все суммы по всем непустым подможествам по модулю 2.
[01:18:47.000 --> 01:18:52.000]  Вот их раз будет 2 в степени L минус 1, да, значит, кроме нуля.
[01:18:52.000 --> 01:19:01.000]  Ну и тогда, соответственно, утверждается, что если мы две таких суммы рассмотрим, то тогда они будут независимыми.
[01:19:01.000 --> 01:19:05.000]  Но идея в том, что там есть какой-то слагаем, который есть в одной сумме и нет в другой.
[01:19:05.000 --> 01:19:11.000]  Например, вот эти вот X1 плюс X2 и X1 плюс X3. Мы можем, скажем, все кроме X3 зафиксировать.
[01:19:11.000 --> 01:19:16.000]  Да, X1 плюс X2 тоже зафиксируется, да, а вот этот будет еще равномерно 0 и единицей.
[01:19:16.000 --> 01:19:19.000]  Ну то есть развернется, совпадет или не совпадет.
[01:19:19.000 --> 01:19:26.000]  Вот, но это одно из определений по паре независимости, да, что условное распределение точно такое же, как безусловное.
[01:19:26.000 --> 01:19:51.000]  Ну а дальше, соответственно, нужно взять L будет у нас верхней целой частью от логарифма двоичного от N плюс 1.
[01:19:51.000 --> 01:20:20.000]  Да, значит, тогда можно использовать вот эти вот суммы, значит, вышеуказанные суммы вместо X1 и так далее Xn.
[01:20:20.000 --> 01:20:41.000]  И дальше идея следующая. Значит, идея следующая, да, что мат ожидания, мат ожидания по такому распределению, по такому распределению равно е пополам.
[01:20:41.000 --> 01:20:47.000]  Тут уже не будет никаких условов. Мат ожидания самообычное. Безусловно, мат ожидания равно е пополам.
[01:20:47.000 --> 01:21:06.000]  Вот, но дело в том, что тут всего есть полином вариантов. В данном случае ожидание это среднее из полинома вариантов.
[01:21:06.000 --> 01:21:25.000]  Вот, но тогда этот полином, значит, этот полином можно просто перебрать, перебрать и выбрать максимум, который не меньше мат ожидания.
[01:21:25.000 --> 01:21:39.000]  Ну вот, значит, тогда получается полиномиальный алтриц, который выбирает тоже хотя бы половину. Вот, вот такое вот рассуждение.
[01:21:39.000 --> 01:21:53.000]  Значит, ну, на этом лекционная часть курса заканчивается. Да, значит, нам предстоит еще много чего.
[01:21:53.000 --> 01:21:59.000]  Значит, у нас и самостоятельный контроль на и экзамен, и обсуждение проектов.
[01:21:59.000 --> 01:22:07.000]  Вот, но и я надеюсь многих из вас увидеть в следующем семестре на курсе допглав.
[01:22:07.000 --> 01:22:13.000]  Значит, он обязательно для кафедры ДМ, а для всех остальных по желанию в принципе тоже можно изучать.
[01:22:13.000 --> 01:22:23.000]  Вот, там будет много чего интересного. В том числе может быть и про псевдослучайные конструкции поговорим.
[01:22:23.000 --> 01:22:27.000]  Вот.
