[00:00.000 --> 00:17.000]  Добрый день. Мы начинаем говорить про потоки. Сегодня будет первая лекция, наверное, из трех.
[00:17.000 --> 00:27.800]  Вот зачем это вообще надо? Какая мотивация? Ну, смотрите. Представьте, что вы строите
[00:27.800 --> 00:32.960]  какой-нибудь трубопровод, и вам нужно передавать какой-нибудь материал из одной точки в другую,
[00:32.960 --> 00:37.880]  ну или там, не знаю, перевозить какие-нибудь грузы по дорогам. Вот. И у вас есть, соответственно,
[00:37.880 --> 00:43.440]  эти дороги, в случае, если вы перевозите грузы на машинках, либо у вас есть какой-нибудь,
[00:43.440 --> 00:48.880]  ну, действительно, трубопровод. То есть прям трубы лежат, и вы можете пропускать по этим
[00:48.880 --> 00:53.600]  трубам, там, какую-нибудь нефть или другое что-нибудь полезное. Соответственно, у каждой
[00:53.600 --> 00:58.120]  трубы или у каждой дороги есть пропускная способность, сколько там единиц воды или
[00:58.120 --> 01:07.240]  единиц груза в секунду она может пропустить. И ваша задача, соответственно, передать как
[01:07.240 --> 01:14.440]  можно больше грузов из СВТ. Или там, максимизировать скорость передачи грузов. То есть, если вас там,
[01:14.440 --> 01:18.840]  ну, мы считаем, что движение водички, оно как бы бесконечное, то есть вы так вот берете,
[01:18.840 --> 01:25.280]  и оно все сразу туда перемещается. Вот вам нужно передать как можно больше в единицу времени
[01:25.280 --> 01:30.040]  товаров. Вот. Ну и, например, здесь можно поступить как-нибудь так. Можно вот по этому пути пропустить
[01:30.040 --> 01:35.240]  единичку потока, по этому пути пропустить двоечку потока. То есть тут будет один везде течь,
[01:35.240 --> 01:42.360]  здесь будет течь два. Вот. Соответственно, у вас никакие ограничения не нарушатся, потому что,
[01:42.360 --> 01:48.120]  ну, вот скажем, по этой трубе течет три из трех. У вас ограничение сверху три, а течет три.
[01:48.240 --> 01:54.040]  Поэтому ничего не нарушается. Вот. Ну и кажется, что лучше нельзя, нельзя передать больше,
[01:54.040 --> 02:01.920]  чем три единицы потока. Наверное, это можно как-нибудь доказать. А, сейчас, я именно выйду вот так вот.
[02:01.920 --> 02:07.600]  Да, это можно доказать, потому что, например, если мы рассмотрим вот такое вот сечение нашего,
[02:07.600 --> 02:15.040]  нашей сети, то она пересекает ребро веса 1 и ребро веса 2. Вот это вот такое я нарисовал,
[02:15.040 --> 02:20.320]  корявое, пересекает два ребра веса 1 плюс 2. Ну и тогда понятно, что вот если у вас есть как бы
[02:20.320 --> 02:26.920]  левая часть вашего графа, правая часть вашего графа, тогда понятно, что, суммарно, весь поток,
[02:26.920 --> 02:32.800]  он же как-то должен перетечь слева направо. Поэтому, суммарно, ответ ограничен точно
[02:32.800 --> 02:38.000]  пропускной способностью всех вот этих ребер. То есть максимум 1 плюс 2. Ну вот мы ровно три нашли.
[02:38.000 --> 02:45.280]  Максимум, возможно, нашли. Вот, ну такая мотивировка. Теперь давайте к определению.
[02:45.280 --> 02:54.160]  Значит, сеть — это ориентированный граф и две выделенные вершинки в нём.
[03:08.880 --> 03:13.600]  Считаем, что они различные. Значит, с мы будем называть и стоком, t — стоком.
[03:13.600 --> 03:22.800]  То есть это то, откуда мы передаём водичку, t — это то, куда вода стекает.
[03:22.800 --> 03:29.800]  Так, виноват. Надо ещё, конечно, пропускные способности ввести.
[03:29.800 --> 03:38.400]  Значит, мы тоже в определение сети вставим. У нас есть граф, две выделенные вершинки,
[03:38.400 --> 03:44.320]  ещё некая функция, которая каждому ребрусу поставляет некоторое целое неотрезательное число.
[03:44.320 --> 03:49.080]  Будем это называть пропускной способностью.
[04:00.440 --> 04:05.400]  Вот, или по-английски capacity.
[04:06.120 --> 04:09.800]  Есть граф, и на каждом ребре написано какое число, ограничение сверху на то,
[04:09.800 --> 04:14.200]  сколько воды может течь в однице времени. А у каждого ребра есть какая-то capacity.
[04:14.200 --> 04:18.880]  Мы считаем, что это целое неотрезательное число, потому что отрицательное capacity — это как-то
[04:18.880 --> 04:22.800]  странно, что мы можем по дороге перевозить максимум только там минус два товара.
[04:22.800 --> 04:29.440]  Это значит, дорога бесполезна, у нас таких не будет. Целое. На самом деле не шибко
[04:29.440 --> 04:32.920]  важно. Можно было бы считать, что вещественное, но давайте для простоты считать, что все
[04:32.920 --> 04:38.680]  capacity у нас целые. Если были бы вещественные, то один из алгоритмов, который мы сегодня
[04:38.680 --> 04:42.720]  построим, не очень адекватно бы работал. Поэтому давайте считать, что всё целое.
[04:42.720 --> 04:52.280]  Дальше нам нужен поток. Пусть есть какая-то сеть.
[04:52.280 --> 05:10.240]  Тогда функция из V на V в Z называется потоком в этой сети.
[05:10.240 --> 05:27.520]  Если выполняются следующие три условия. Во-первых, самое естественное условие — это что поток
[05:27.520 --> 05:32.720]  текущий по каждому ребру должен не превосходить пропускной способности. Для любой пары вершин
[05:32.720 --> 05:44.400]  поток между ними, то есть поток из UV не превосходит C от UV. Где C — это наша пропускная способность.
[05:44.400 --> 05:51.560]  Но мы считаем, что если у нас раньше C была определена только для ребер, то
[05:51.560 --> 05:55.040]  теперь мы хотим для любой пары вершин, то есть они не обязательно соединили ребро в изначальном
[05:55.040 --> 05:59.280]  графе, но все равно для любой пары мы хотим определить capacity любой пары вершин.
[05:59.360 --> 06:04.840]  И вот если это не ребро, то там будет просто 0, потому что если дороги нету между двумя вершинами,
[06:04.840 --> 06:10.000]  то это то же самое, что если считать, что здесь есть дорога capacity 0, что мы по ней ничего
[06:10.000 --> 06:26.280]  передать не можем. Вот это вот, если считать, что при отсутствии ребра capacity UV равно 0.
[06:26.280 --> 06:34.960]  То есть можно сказать формально, что мы функцию T продолжаем, она у нас была определена на E,
[06:34.960 --> 06:38.200]  теперь мы продолжаем на весь В квадрат и говорим, что всюду, где она раньше была
[06:38.200 --> 06:46.200]  неопределена, теперь 0. Capacity в остальных местах — 0. Второе — антисимметричность свойства
[06:46.200 --> 07:02.160]  формулируется так, что для любой пары вершин поток текущий по ребру UV равен минус потоку
[07:02.160 --> 07:10.800]  текущему по ребру VU. Вот это уже чуть более странно, но смысл следующий. Представьте,
[07:10.800 --> 07:16.880]  что у вас там сколько-то потока течет слева направо по ребру V. Тогда мы вводим обратное
[07:16.880 --> 07:22.240]  ребро, вот такое вот VU, на котором будет написано что-то отрицательное. Вот если здесь написано 1,
[07:22.240 --> 07:29.680]  то здесь минус 1. И эту минус 1 можно трактовать так, что если вершина U передает вершине V одну
[07:29.680 --> 07:34.400]  единичку потока, то это как бы означает, что вершина V должна вершинке U одну единицу потока.
[07:34.400 --> 07:39.200]  Ну там не знаю, Вася дал Пете 1 рубль, тогда Петя должен Вася 1 рубль. Здесь отдал, здесь должен.
[07:39.840 --> 07:44.040]  Соответственно, они будут просто противоположными числами, написанными вот в противоположной
[07:44.040 --> 07:52.240]  стороны на одном ребре. Чуть позже мы поймем, зачем нам такое свойство. И третье, свойство сохранения потока.
[07:52.240 --> 08:05.760]  Сохранение потока. Для любой вершины, отличной от S и T,
[08:05.760 --> 08:15.080]  мы будем требовать, что сумма всех входящих потоков равна сумме всех исходящих. Так,
[08:15.160 --> 08:28.080]  как я это напишу? Сумма по всем вершинам U таким, что U-V это ребро, F-U-V равна сумма по всем вершинам W таким,
[08:28.080 --> 08:37.800]  что V-W это ребро, F-V-W. Это тоже естественное требование, что если есть какая-то вершинка V,
[08:37.800 --> 08:45.440]  то должно обязательно выполняться такое свойство. Сумма потоков в текающих V равна сумме потоков из
[08:45.440 --> 08:51.120]  текающих из V. Левая сумма то, что входит, правая то, что выходит. И это, понятно, должно выполняться для
[08:51.120 --> 08:56.760]  всех вершин, кроме S и T, потому что в S вода берется из ниоткуда, мы ее туда отдаем столько, сколько
[08:56.760 --> 09:04.200]  хотим, а вся остальная двигается без задержек, то есть у нас нету каких-то накопительных пунктов
[09:04.200 --> 09:09.000]  в вершинах, и вода, которая целиком поступила, должна куда-то дальше пойти. Поэтому пишем такое
[09:09.000 --> 09:29.160]  равенство, чтобы у нас поток нигде в вершинках не застревал. Так, вот что такое поток. Следующее
[09:29.160 --> 09:37.800]  определение это остаточная сеть. Пусть у нас есть некая сеть и поток в ней.
[09:37.800 --> 09:51.480]  Тогда можем определить остаточную сеть. Это интуитивно очень простая штука. Нам нужно оставить на
[09:51.480 --> 09:55.680]  каждом ребре то, сколько по нему можно максимум пропустить. Вот если мы уже сколько-то пустили,
[09:55.680 --> 10:00.760]  сколько поток уже по ребру течет, то в остаточной сети на этом ребре будет написана разность того,
[10:00.760 --> 10:04.080]  сколько можно и того, сколько пустили, то есть то, сколько можно добить по этому ребру.
[10:04.080 --> 10:19.960]  Значит, остаточная сеть. Будем обозначать ее уже с индексом f. Здесь множество вершин,
[10:20.120 --> 10:34.920]  а также s и t те же самые. Множество вершин s и t сохраняются. Мы только меняем пропускные
[10:34.920 --> 10:41.880]  способности и пишем, что пропускная способность под влиянием этого потока f с индексом f на
[10:41.880 --> 10:51.520]  любом ребре. Это capacity в самом начале, в исходной сети, минус f и v. То есть как раз то самое,
[10:51.520 --> 10:55.840]  сколько можно пустить, минус то, сколько мы пустили. Это есть остаточная пропускная способность.
[10:55.840 --> 11:17.020]  При этом важное условие, что ребра нулевой остаточной
[11:17.020 --> 11:35.980]  capacity мы не проводим. Ребра с нулевой остаточной capacity не проводятся. Пример.
[11:35.980 --> 11:50.620]  Вот пусть есть исходный такой граф. Давайте считать, что изначально все capacity единички,
[11:50.620 --> 11:55.340]  я не буду их писать. Напишу, что capacity везде единица. Пропускная способность всех ребер – это
[11:55.340 --> 12:00.780]  единица. Ну понятно, какой в этой сети был бы максимальный поток. Надо пусть единичку здесь,
[12:00.780 --> 12:04.540]  единичку здесь. Лучше, понятно, ее нельзя, потому что из s можно максимировать только две единицы
[12:04.540 --> 12:12.020]  потока. Один сверху, один снизу. Но представьте, что какой-нибудь глупый алгоритм пришел и сказал,
[12:12.020 --> 12:17.260]  а давайте-ка мы в самом начале пропустим единицу потока вот по такому пути, по такому неоптимальному.
[12:17.260 --> 12:23.620]  Тогда что у нас от графа останется? Ну вот эти вот три ребра насадятся, то есть по ним больше
[12:23.620 --> 12:29.260]  ничего нельзя будет передать. И останется только как два ребра, вот это и вот это. И просто используя
[12:29.260 --> 12:34.420]  их мы, конечно, поток увеличить не сможем. У нас как бы несвязанный граф станет, из s мы никогда-то
[12:34.420 --> 12:41.140]  не доберемся. Но за счет существования, во-первых, обратных ребер, вот за счет антисимметричности
[12:41.140 --> 12:46.820]  потока и за счет того, что мы будем строить остаточную сеть, у нас появится в графе вот такое обратное
[12:46.820 --> 12:52.700]  ребро. Потому что, смотрите, если у нас раньше сверху вниз текла единичка потока с capacity 1,
[12:52.700 --> 13:00.820]  давайте я нарисую это ребро, было c единица, f единица, то есть и обратное ребро с capacity 0.
[13:00.820 --> 13:05.700]  Мы вспоминаем, что все ребра, как бы не присутствующие явно в графе, имеют capacity 0.
[13:05.700 --> 13:12.140]  И тогда поток, текущий по этому ребру, это минус один по антисимметричности. Если сверху
[13:12.140 --> 13:17.340]  вниз один, то снизу вверх это минус один. Но, значит, в остаточной сети вот это ребро будет
[13:17.340 --> 13:23.020]  иметь остаточную capacity единица. 0 минус минус 1 это единица. Значит, в остаточной сети у
[13:23.020 --> 13:28.820]  меня появляется такой противоположный ребро снизу вверх. Поэтому, как минимум, в остаточной сети
[13:28.820 --> 13:34.860]  после пропускания вот этой единички потока, вот такой кривой, у нас точно будет вот такой вот путь.
[13:34.860 --> 13:46.420]  Значит, можно по нему будет пропустить единичку потока, вот такую вот. Ну и тем самым мы найдем
[13:46.420 --> 13:51.500]  поток величины 2. А по этому ребру мы как бы отменим неправильную единицу потока, потому что мы
[13:51.500 --> 13:56.260]  сначала ее здесь вот так вот пустили сверху вниз, потом отменили снизу вверх. Значит, здесь на этом
[13:56.260 --> 14:01.580]  ребре потока нет, и мой поток расщепляется как раз в те самые две оптимальные единицы потока. Верхняя
[14:01.580 --> 14:07.260]  доля и нижняя доля. Вот и, собственно, за этим и нужна остаточная сеть, потому что без нее мы,
[14:07.260 --> 14:12.540]  в общем случае, не найдем оптимальный поток. Потому что там мы сможем найти какой-то блокирующий поток
[14:12.540 --> 14:16.860]  такой, что больше его нельзя будет никак расширить без добавления вот этих обратных ребер, без отмены
[14:16.860 --> 14:33.820]  каких-то неправильных решений, которые мы сделали. В исходном? Да, могут.
[14:33.820 --> 14:47.740]  Ну, если есть в исходном графе вот такие противоположные ребра, то тут можно как угодно рассуждать,
[14:47.740 --> 14:53.140]  если, например, здесь есть капасти 1, здесь есть капасти 2, то можно, не знаю, если совсем не думать,
[14:53.140 --> 14:58.780]  можно ввести обратное ребро вот к этому ребру, то есть еще одно с капасти 0, и обратное ребро вот к
[14:58.780 --> 15:04.580]  этому ребру, то есть еще вот такое ребро с капасти 0. В принципе, если мы в алгоритме все равно храним все
[15:04.580 --> 15:09.260]  ребра как список исходящих, то нам не важно есть там кратные или нет, потому что поэтому можно
[15:09.260 --> 15:15.180]  считать, что кратненькая такая. Либо, если мы не хотим вводить ненужные ребра, то просто можно считать,
[15:15.180 --> 15:21.060]  что они обратные друг к другу, и по ним обязательно текут противоположные потоки, то есть в одну струну и в
[15:21.060 --> 15:33.780]  другую минусов. Вот, и так вот, к чему это было, что остаточная сеть нам помогает сравнивать такую
[15:33.780 --> 15:41.780]  теорему, которую мы чуть позже докажем. Теорема Форда Фалкерсона. Она утверждает, что построенный
[15:41.780 --> 15:51.540]  поток максимальный, если только если в остаточной сети нет пути из С в Т. Поток Ф в сети G максимален.
[15:51.540 --> 16:05.940]  Да, справедливое замечание. Давайте сформулирую, потом определю. Извините, это я неправильно сделал,
[16:05.940 --> 16:11.980]  но все же. Значит, поток максимален, если как бы величина, в общем, сколько воды вытекает из С.
[16:11.980 --> 16:34.380]  Если только если в GF нет пути из С в Т. Вот, то есть для поиска максимального потока,
[16:35.380 --> 16:39.420]  то есть как раз тот самый исходный вопрос, который мы решаем, сколько можно воды максимум пустить из
[16:39.420 --> 16:45.540]  С в Т, сколько можно передать водичке. Так вот, максимум достигается ровно в том случае,
[16:45.540 --> 16:51.700]  если в остаточной сети нет пути из С в Т. Вот как вот здесь, когда я строил, если бы я вот это вот
[16:51.700 --> 16:56.380]  ребро не проводил обратное снизу вверх, то у меня как раз не было бы пути, потому что было бы
[16:56.380 --> 17:00.820]  такое ребро и такое ребро и все, и собственно больше ничего нет. Но в случае, когда я провел обратное
[17:00.820 --> 17:07.140]  ребро, у меня появился путь, я по нему протолкну единичку потока и уже после этого не будет пути
[17:07.140 --> 17:12.140]  из С в Т, потому что все вот эти вот ребра насыщенные, останется только вот такой ребро сверху вниз,
[17:12.140 --> 17:17.700]  но оно, понятно, не влияет на связанность между С в Т. Вот. Эту тюремку мы чуть позже докажем,
[17:17.700 --> 17:23.140]  потому что нужно еще вспомогать на определение.
[17:30.820 --> 17:38.660]  Так, ну а величина потока как раз то, что я не сформулировал.
[17:52.660 --> 17:58.820]  Величина потока это просто то, сколько воды течет из старта. Вот у вас есть стартовая вершина,
[17:58.820 --> 18:06.380]  вы перебираете все остальные вершинки В и суммируете то, что написано на всех этих ребрах.
[18:06.380 --> 18:15.060]  Весь вытекающий поток вы суммируете. Вот. Ну и соответственно поток максимален,
[18:15.060 --> 18:22.100]  если его величина максимально. Максимально возможна среди всех возможных поток. Максимизируем
[18:22.100 --> 18:28.500]  по величине потока. Вот. Эта тюрема очень похожа на самом деле на тюрему Бержа, которая была в
[18:28.500 --> 18:33.980]  прошлый раз, что когда мы ищем максимальное просчитание, мы можем, ну в смысле, в двудольном графе.
[18:33.980 --> 18:38.940]  Ну, на самом деле Берж в произвольном работает, но тем не менее. Значит, максимальное просчитание,
[18:38.940 --> 18:44.260]  пардон, произвольное просчитание максимально, если только если относительно него нету чередующих
[18:44.260 --> 18:49.020]  вот этих увеличивающих путей, что можно взять ненасыщенную и ненасыщенную, и там чередуясь по
[18:49.020 --> 18:53.860]  ребрам из просчитания и не из просчитания дойти из одной в другую. Тут похожая вещь, что поток
[18:53.860 --> 19:03.300]  максимален, если в каком-то там соответствующем графе нет пути. Вот. Окей, чтобы это доказать,
[19:03.300 --> 19:18.900]  нужно еще определение вести разреза. СТ это разрез в СТЖ. Если С маленькое лежит на С
[19:18.900 --> 19:24.260]  большом, Т маленькое в Т большом, а они в дизинктом объединении дают все множество вершин В.
[19:24.260 --> 19:36.500]  То есть, ну у нас есть, да, какой-то исток, есть сток. Нам нужно все множество вершин разбить на два
[19:36.500 --> 19:42.980]  непересекающееся множество, так что С в левом, а Т в правом. Вот это разрез. На что? Ну просто по
[19:42.980 --> 19:57.700]  сути разбиение на два множества. Величиной такого разреза С от СТ мы будем называть просто сумму
[19:57.700 --> 20:08.460]  всех capacity тех ребер, которые идут из С в Т. Сумма по У из С, В из Т, Т у В. Просто все возможные
[20:08.460 --> 20:15.420]  ребра, которые идут слева направо, все-все-все мы перебираем и складываем на них capacity. Это будет
[20:15.420 --> 20:20.340]  величина разреза. Ну по сути, как бы, сумма пропускных способностей всех ребер, которые пересекают
[20:20.340 --> 20:30.820]  наш разрез, идут слева направо. И последнее определение, величина потока через разрез.
[20:30.820 --> 20:44.540]  Это то же самое, только мы будем суммировать не Ц, а Ф. Поток текущий через разрез ФСТ. Это опять
[20:44.540 --> 20:55.780]  сумма по У из С, В из Т, Ф у В. То же самое, как величина разреза, только мы суммируем вот здесь
[20:55.780 --> 21:00.660]  не capacity, а потоки. Сколько потока вытекает из С большого и попадает в Т большое.
[21:00.660 --> 21:29.500]  Так, Лемма, величина потока через разрез, она величине потока.
[21:29.500 --> 21:46.340]  Если Ф-поток, а СТ это разрез, то величина потока равна величине потока через разрез.
[21:46.340 --> 21:52.660]  Да, вот это то, сколько течет из С в Т, а это то, что мы определили просто
[21:52.660 --> 22:01.580]  величиной потока. Сколько водички вытекает из С маленького. Это Лемма говорит, что поток
[22:01.580 --> 22:05.020]  через разрез равен настоящему потоку. Та величина потока, которую мы определили,
[22:05.020 --> 22:09.180]  она не зависит от того, какой брать разрез. Они все будут одинаковы и равны вот тому,
[22:09.180 --> 22:16.660]  что мы определили моду Лев. Напоминаем, моду Лев это сумма по всем вершинкам ФСВ. И оказывается,
[22:16.660 --> 22:23.420]  что какой бы поток вы не взяли, величина потока через него равна величине просто потока.
[22:23.420 --> 22:30.940]  На пальцах это очевидно, понятно, что если у нас есть С маленького где-то здесь, есть сколько-то
[22:30.940 --> 22:37.620]  потока из него вытекающего, то чтобы этот весь поток из-за свойства сохранения, он должен
[22:37.620 --> 22:42.820]  как-то в Т переместиться. У нас поток в сети не накапливается, в вершинах поток не накапливается.
[22:42.820 --> 22:45.940]  Значит, все, что отсюда вытекло, должно было рано или поздно сюда перетечь,
[22:45.940 --> 22:49.860]  поэтому как бы вся эта водичка должна была пересечь разрез рано или поздно. Отсюда,
[22:49.860 --> 22:56.580]  в общем, такое равенство возникает. Но это так, неформально. Формально давайте попробуем написать.
[22:56.580 --> 23:11.700]  Так, что такое ФСТ? Ну, во-первых, совсем очевидно, что это ФСВ минус ФСС,
[23:11.700 --> 23:21.140]  потому что, ну, собственно, вот в этой сумме у меня лишние слагаемые, это те,
[23:21.140 --> 23:25.940]  когда У из С и В из С, я, соответственно, их здесь просто вычту. То есть, ну, я, ну, что
[23:25.940 --> 23:31.380]  тест сначала расширил до В, понимаю, что я это расширю с помощью С, и это теперь вычитаю. Вот.
[23:31.380 --> 23:38.540]  Дальше, вот эта штука, на самом деле, ноль. Эта штука ноль, потому что каждое ребро мы учтем два
[23:38.540 --> 23:43.940]  раза, слева направо и справа налево. Вот есть какое-то множество С большое. Я здесь перебираю все
[23:43.940 --> 23:49.660]  ребра УВ, такие, что У и В лежат в С большом. Ну и, соответственно, тогда в этой сумме есть и такое
[23:49.660 --> 23:54.140]  ребро, и обратное ребро. Но из-за свойства антисимметричности поток текущий по ребру равен
[23:54.140 --> 24:00.140]  потоку по обратному ребру. Значит, здесь все такие подойки равны нулю. Формально, давайте я это
[24:00.140 --> 24:14.180]  запишу. Значит, ФСС, это что такое? Эта сумма по У и В из С, давайте У не равно В. Сейчас, не так.
[24:14.180 --> 24:32.020]  Давайте напишу У меньше, чем В. ФУВ плюс ФВУ. Плюс еще будет сумма по всем вершинкам Х из С. ФХХ. Вот так. То есть у меня есть, как бы, пары, когда совпадают,
[24:32.020 --> 24:38.020]  начало и конец, я их отдельно выделю. И есть пары, где начало и конец не совпадают, тогда я их могу разбить на
[24:38.020 --> 24:43.980]  пары, где первая компонента меньше второй, и, соответственно, загруппировать УВВУ. Вот. Ну эта штука, понятно, ноль по
[24:43.980 --> 24:51.380]  антисимметричности, просто по антисимметричности поток по УВ, плюс поток по УВ, это ноль. Они противоположны. Вот.
[24:51.380 --> 25:01.980]  И эта штука тоже ноль, опять-таки, из-за антисимметричности, потому что ФХХ равно минус ФХХ. Опять, антисимметричность
[25:01.980 --> 25:09.780]  можем поменять начало и конец ребра, вынеся минус перед значком Ф. Значит, единственное число, которое такому
[25:09.780 --> 25:17.780]  уровню не удовлетворяет, это ноль. Поэтому поток, как бы, текущий из вершины в саму себя, это ноль всегда. Значит, это все будет нулем.
[25:17.780 --> 25:41.580]  Итак, до чего мы довели себя, что ФСТ это ФСВ просто, потому что эта штука нулевая. Дальше давайте я С большое
[25:41.580 --> 25:52.380]  раздобью на два множества. Множество, состоящее из С маленького и все остальное. С без С маленького и В.
[25:52.380 --> 25:59.380]  Но опять, да, по линии, у меня здесь как бы написана большая сумма, когда первая вершина отсюда, вторая отсюда.
[25:59.380 --> 26:04.580]  Я могу расщепить на две суммы, когда первая вершинка равна С маленькому, когда первая вершина не равна С маленькому.
[26:05.580 --> 26:16.580]  Вот. Дальше. Это просто по определению мощность потока, величина потока, сумма по всем вершинкам В, величина потока из С в.
[26:16.580 --> 26:25.580]  На это в точности величина потока, которую мы определили. А эта штука, хочется сказать, что это ноль.
[26:25.580 --> 26:32.580]  Хочется сказать, что это ноль. Ну а это следует из втор... из какого там? Третьего свойства из-за сохранения потока.
[26:32.580 --> 26:46.580]  Потому что, смотрите, для любой вершинки У из С без С маленького, что такое сумма по всем вершинам ФУВ?
[26:46.580 --> 27:00.580]  Ну вот есть какая-то вершинка, да? Мы берем и рассматриваем исходящие вот такие вот потоки по всем, всем, всем ребрам.
[27:01.580 --> 27:02.580]  По всем ребрам.
[27:08.580 --> 27:10.580]  Так. Момент.
[27:13.580 --> 27:19.580]  Сумма по всем исходящим ребрам. Я хочу сказать, что это ноль из-за свойств сохранения потока.
[27:19.580 --> 27:31.580]  Вот. Ну это можно пояснить так. Значит, смотрите, есть ребра, которые в исходном графе действительно исходили из У.
[27:31.580 --> 27:35.580]  А есть ребра, которые, наоборот, входили в У. То есть давайте я их разобью на две категории.
[27:35.580 --> 27:39.580]  Те, которые реально исходят из У. И те, которые на самом деле входят.
[27:39.580 --> 27:44.580]  Но когда я в этой сумме их беру, я по сути их беру с противоположным знаком.
[27:45.580 --> 27:49.580]  Да? Потому что ребро было скажем из В в У, а я здесь его суммирую из У в В, т.е. беру противоположное.
[27:49.580 --> 28:00.580]  Значит, вот в этой сумме я могу разбить все слагаемые на две группы — те, которые исходят из У, то есть те, которые соответствуют реально ребрам, исходящим из У, и те, которые соответствуют, наоборот, в ребрам, входящим в У.
[28:00.580 --> 28:08.580]  Да, еще какие-то нули, которые соответствуют как бы не ребрам. Да, еще какие-то нули, которые соответствуют не ребрам.
[28:08.580 --> 28:12.580]  Значит, ну и понятно, что сумма вот таких равна сумме
[28:12.580 --> 28:15.460]  вот таких, вы берете и обращаете знак у вот этих,
[28:15.460 --> 28:18.060]  потому что берете противоположное ребро, поэтому сумма обратится
[28:18.060 --> 28:19.060]  в ноль.
[28:19.060 --> 28:23.500]  Так, как я это могу расписать?
[28:23.500 --> 28:30.340]  Давайте вот эту сумму, f у v, могу разбить на три множества,
[28:30.340 --> 28:41.380]  сумма по a таким, что… Сейчас, момент, у меня бывают же
[28:41.380 --> 28:42.380]  еще вот такие ребра.
[28:42.380 --> 29:05.020]  Сейчас, на секунду.
[29:05.020 --> 29:17.080]  Не оснущается случае как раз, что если в исходном
[29:17.080 --> 29:20.540]  графе могут быть противоположные ребра, то есть ребро вот такое
[29:20.540 --> 29:21.540]  и вот такое.
[29:21.540 --> 29:38.220]  Давайте я формально напишу в случае, если в исходном
[29:38.220 --> 29:41.060]  графе не было противоположных ребер, то есть из uv и vu одновременно
[29:41.060 --> 29:42.060]  быть не может.
[29:42.060 --> 29:45.300]  Давайте я это напишу.
[29:45.300 --> 29:50.700]  Сумма по a таким, что uva это ребро в исходном графе,
[29:50.700 --> 29:51.700]  fua.
[29:51.700 --> 30:00.340]  Дальше, минус сумма по b таким, что bu это ребро в исходном
[30:00.340 --> 30:03.340]  графе, fbu.
[30:03.340 --> 30:09.060]  Ну и сумма по всем остальным таким, что не это, не ребро,
[30:09.060 --> 30:12.380]  не это, не ребро будет fuc, но это понятное дело ноль,
[30:12.380 --> 30:15.020]  потому что если нет ни одного ребра, ну не ребра
[30:15.020 --> 30:17.220]  uc, не ребра cu, тогда эта штука будет нулем.
[30:17.220 --> 30:20.100]  В общем, я просто формально расписал, что все вершины
[30:20.100 --> 30:21.260]  разбились на два множества.
[30:21.260 --> 30:25.220]  Те, в которых есть ребро, те, из которых есть ребро
[30:25.220 --> 30:29.500]  и те, с которыми нет ребра ни в одной из двух сторон.
[30:29.500 --> 30:33.100]  Тогда здесь будет нолик, а эти две суммы будут противоположны.
[30:33.100 --> 30:35.980]  То есть я здесь вынес минус, потому что поменял местами
[30:35.980 --> 30:36.980]  аргументы.
[30:36.980 --> 30:39.820]  А эти слагаемые как раз-таки взаимно уничтожатся, потому
[30:40.300 --> 30:44.820]  что в исходном графе то, сколько втекает, равно тому,
[30:44.820 --> 30:45.820]  чему втекает.
[30:45.820 --> 30:47.120]  Это все будет ноль.
[30:47.120 --> 30:52.260]  Вот, тут нужно, смотрите, тут я не очень аккуратно
[30:52.260 --> 30:53.940]  сделал, потому что бывают ребра.
[30:53.940 --> 30:56.300]  Вот если в исходном графе есть такое ребро и такое
[30:56.300 --> 31:00.020]  ребро, то по сути одна вершина мне должна попасть и в то,
[31:00.020 --> 31:04.340]  что есть вот такое ребро и такое ребро.
[31:04.340 --> 31:06.600]  Поэтому здесь нужно более аккуратно вот эти вершинки
[31:06.600 --> 31:07.600]  разбивать.
[31:07.600 --> 31:13.800]  какая-то вершина будет и там, и там, но тогда тоже понятно, что там, если, в общем, просто по
[31:13.800 --> 31:17.720]  линейности, что если у меня там здесь сколько-то течет, и здесь сколько-то течет, то по обратному
[31:17.720 --> 31:23.520]  течет, ну, противоположное количество, они все взаимно уничтожатся. Как-то так. Вот, ну все, значит,
[31:23.520 --> 31:29.520]  эта штука ноль, вот эта ноль, и мы получили, что fst это равно величине как раз потока, что и требовалось.
[31:38.600 --> 31:48.120]  Вот, теперь, наконец, мы можем, а нет, сначала нужна вторая лемма, но она совсем простая. Значит,
[31:48.120 --> 31:56.600]  я утверждаю, что величина любого потока не превосходит величины любого разреза.
[32:07.600 --> 32:14.040]  Вопрос к вам, как доказать?
[32:26.040 --> 32:32.800]  Значит, ну, первый шаг, наверное, понятен, что мы знаем, что величина потока по предыдущей
[32:32.800 --> 32:37.560]  лемме, это величина потока через разрез. И вот мы хотим доказать, что эта штука не превосходит
[32:37.560 --> 32:42.520]  величины разреза, то есть суммы capacity. Тут мы суммируем потоки, хотим ценить сверху через сумму capacity.
[32:42.520 --> 32:50.440]  Ну, это просто следует от того, давайте допишем просто по определению. Вот эта вещь,
[32:50.440 --> 33:03.600]  это сумма по U из S, V из T, F у V, а эта сумма такая же, только C у V. Ну, понятно, здесь стоит такое
[33:03.600 --> 33:09.400]  неравенство, потому что мы знаем, что для любой пары у V f не больше, чем C. То есть у меня по компонентно
[33:09.400 --> 33:13.720]  просто каждая слагаемая здесь не больше, чем каждая слагаемая здесь, поэтому, когда мы все складываем по
[33:13.720 --> 33:24.440]  одному и тому же множеству, мы получаем, что одна сумма не больше, чем вторая. Согласны? Вот, победа, то есть
[33:24.440 --> 33:32.360]  любой поток не больше, чем любой разрез. Но более того, теорема, которую мы сейчас формулируем, утверждает,
[33:32.360 --> 33:36.880]  что есть поток равный разрезу, и, соответственно, этот поток тогда является максимальным, а разрез минимальным.
[33:36.880 --> 34:00.000]  Так, теорема, как раз Форда Фалкерсона в полной формулировке, утверждает следующее, что если же эта сеть
[34:00.040 --> 34:23.200]  а f это поток в ней, то следующие условия эквивалентны. Во-первых, f это максимальный поток. То есть величина
[34:23.200 --> 34:36.040]  f максимально возможна среди всех возможных потоков. Во-вторых, в остаточной сети нет пути из С в Т,
[34:36.040 --> 34:45.320]  то есть наш поток нельзя увеличить простым проталкиванием потока в остаточной сети.
[34:45.320 --> 34:54.360]  И, наконец, третья, величина f равна величине какого-то разреза.
[35:15.320 --> 35:36.880]  Ну, доказываем. Из нинчки в двойку. Значит, почему, если поток максимальный, то в остаточной сети нет пути?
[35:36.880 --> 35:44.160]  Ну, пусть не так, пусть есть. Тогда давайте протохнем по нему нинчку потока. Наш поток увеличится, значит, сходный был не максимальный.
[35:45.160 --> 35:54.560]  Я не буду записать. Еще раз, если поток максимальный, но при этом в остаточной сети есть какой-то путь из С в Т, то есть какой-то путь из С в Т в остаточной сети.
[35:54.560 --> 36:04.560]  Значит, все вот эти capacity положительны. В остаточной сети мы оставляем только ребра с нинолевой capacity, с нинолевой пропускной способностью.
[36:04.560 --> 36:09.960]  Значит, все эти capacity положительны. Значит, по всем этим ребрам можно опустить как минимум нинчку потока.
[36:10.360 --> 36:14.960]  Вот здесь играет целочисление, что если поток целочисленный, то здесь обязательно можно опустить нинчку потока.
[36:14.960 --> 36:21.160]  Значит, мы его опускаем, тем самым мы на один больше потока выпустили из стартовой вершинки, из С.
[36:21.160 --> 36:34.360]  Значит, поток увеличился. Противоречие с тем, что исходный поток был максимальный. Согласны? Вот. Ачев. Дальше. Два-три.
[36:35.360 --> 36:45.360]  Что если нет пути, то поток равен какому-то разрезу. Ну, для этого этот разрез надо предъявить.
[36:45.360 --> 36:52.360]  Давайте скажем, что С это множество всех вершин, которые достижимы из С в остаточной сети.
[36:52.360 --> 37:01.360]  В достижима из С в остаточной сети GF.
[37:02.360 --> 37:07.360]  Ну и, соответственно, Т это все кроме С большого.
[37:10.360 --> 37:17.360]  Почему это разрез? Ну, понятно, что в С большом лежит С маленькая, просто по определению. Да, С маленькая достижима сама из себя, конечно же.
[37:17.360 --> 37:24.360]  Вот. Но Т маленькая в С большом не лежит. Вот здесь нет Т маленького, потому что если бы она там была, то был бы путь из С в Т.
[37:24.360 --> 37:29.360]  Соответственно, Т достижима из С противоречия с тем, что такого пути нет.
[37:29.360 --> 37:36.360]  Значит, мы точно можем сказать, что С маленькая в С большом, Т маленькая в Т большом, потому что еще раз Т недостижима из С.
[37:36.360 --> 37:44.360]  Значит, это действительно разрез. Выполняются вот эти свойства, и, конечно, в объединении дизюнк нам С и Т дают все В.
[37:46.360 --> 37:51.360]  И мы хотим показать, что величина этого разреза равна величине нашего потока.
[37:55.360 --> 37:56.360]  Так, ну, картинка.
[38:01.360 --> 38:04.360]  Значит, мы знаем, что в остаточной сети...
[38:06.360 --> 38:10.360]  Ну, давайте я нарисую вообще все ребра из С большой в Т большой. Вот я рисую все ребра.
[38:11.360 --> 38:18.360]  Я знаю, что в остаточной сети. И вот эти ребра отсутствуют. Все эти ребра отсутствуют в остаточной сети.
[38:19.360 --> 38:23.360]  Всутствуют в остаточной сети. Почему?
[38:23.360 --> 38:27.360]  Ну, потому что если бы хотя бы одно из них присутствовало, то я мог бы мое С увеличить.
[38:27.360 --> 38:31.360]  Что если это достижимо, и это ребро присутствует, то это величина тоже достижима.
[38:31.360 --> 38:35.360]  Значит, ни одного этого ребра нету, иначе я мог бы расширить множество достижимых.
[38:35.360 --> 38:41.360]  Но раз этих ребер нет в остаточной сети, значит их остаточная capacity это ноль.
[38:41.360 --> 38:43.360]  Capacity это ноль. Cf это ноль.
[38:44.360 --> 38:47.360]  Пропорционная способность, остаточная всех этих ребер, это ноль.
[38:47.360 --> 38:51.360]  А значит, поток по ним равен их capacity в исходном графе.
[38:55.360 --> 39:00.360]  По всем этим ребрам поток равен capacity. Ну, то есть мы будем называть эти ребра насыщенными.
[39:00.360 --> 39:03.360]  Эти ребра насыщены, по ним течет максимально возможный поток.
[39:03.360 --> 39:07.360]  Только в этом случае все они одновременно могут не присутствовать в остаточной сети.
[39:07.360 --> 39:10.360]  Значит, на всех этих ребрах поток равен capacity.
[39:10.360 --> 39:22.360]  То есть сумма из s, v, st, f, u, v равно такой же сумме t, u, v.
[39:22.360 --> 39:25.360]  Потому что все потоки равны всем capacity.
[39:26.360 --> 39:30.360]  Ну, а это по лимме равно величине нашего потока.
[39:30.360 --> 39:34.360]  Это поток через разрез, а это просто поток. Мы знаем, что это одно и то же.
[39:37.360 --> 39:39.360]  Просто.
[39:57.360 --> 40:01.360]  Ну, и наконец с 3 в 1, что если наш поток равен какому-то разрезу, то он почему-то максимальный.
[40:01.360 --> 40:04.360]  Ну, мне кажется, самое простое здесь доказательство такое.
[40:05.360 --> 40:08.360]  Смотрите, мы знаем, что любой поток не больше любого разреза.
[40:08.360 --> 40:10.360]  Величина любого потока не больше величины любого разреза.
[40:10.360 --> 40:14.360]  Значит, если я значение напишу на consolid Cavitation aptitude всё, то у меня что будет?
[40:14.360 --> 40:19.360]  У меня будет здесь вот потоки величины всех возможных потоков.
[40:19.360 --> 40:22.360]  А здесь величины всех возможных разрезов.
[40:22.360 --> 40:26.160]  всех возможных разрезов. И я знаю, что эти множества
[40:26.160 --> 40:28.080]  отделены, что любой поток не больше любого разреза.
[40:28.080 --> 40:31.320]  И при этом как-то так оказалось, что какой-то поток равен
[40:31.320 --> 40:35.240]  какому-то разрезу. Ну тогда понятно, что все потоки должны
[40:35.240 --> 40:38.080]  лежать левее, чем этот, а все разрезы правее, чем
[40:38.080 --> 40:41.960]  этот. Если множества отделены, но при этом имеют общий
[40:41.960 --> 40:45.040]  элемент, значит они по нему пересекаются, все потоки
[40:45.040 --> 40:47.160]  меньше образно, чем он, а все разрезы больше, чем
[40:47.160 --> 40:52.800]  этот. Это из-за того, что все потоки, любой поток
[40:52.800 --> 40:57.800]  не больше любого разреза, ну по величине. Значит точка
[40:57.800 --> 41:00.840]  их пересечения это одновременно точка, когда достигается
[41:00.840 --> 41:04.280]  максимальный поток и при этом минимальный разрез.
[41:04.280 --> 41:13.280]  Если f равно величине какого-то потока, то f это максимальный
[41:13.360 --> 41:24.360]  поток, а st это минимальный разрез. Ну то есть разрез
[41:24.360 --> 41:26.920]  минимальной величины, что сумма капасти ребер минимально
[41:26.920 --> 41:32.680]  возможна. То есть мы не только нашли критерии максимальности
[41:32.680 --> 41:35.640]  потока, но и при этом критерии минимальности разреза. Собственно
[41:35.640 --> 41:44.000]  одно и то же. Это максимальный, а это минимальный. Так,
[41:44.000 --> 42:01.000]  ну вот. Ну и отсюда наконец мы можем написать алгоритм
[42:01.360 --> 42:10.360]  поиска максимального потока. Алгоритм Форда Фалкерсона
[42:10.360 --> 42:13.080]  для поиска максимального потока. Алгоритм собственно
[42:13.080 --> 42:15.800]  следует просто из теоремы. Пока в остаточной сети
[42:15.800 --> 42:18.480]  есть путь, пожалуйста, найди его и протолкни по
[42:18.480 --> 42:31.960]  нему поток. Пока в gf есть путь из s в t, протолкни по
[42:31.960 --> 42:41.960]  нему поток. Больше такого протолкнуть поток. Значит
[42:41.960 --> 42:45.280]  я нахожу некий путь, скажем там dfs, да, у меня есть явно
[42:45.280 --> 42:48.800]  граф, вот эта вот остаточная сеть gf. Я в ней производным
[42:48.800 --> 42:51.120]  алгоритмом, например, dfs нахожу какой-то путь из
[42:51.120 --> 42:55.240]  s в t. На всех этих ребрах написаны какие-то остаточные
[42:55.240 --> 42:59.680]  капасити с f. Значит можно сделать, например, следующее.
[42:59.680 --> 43:02.960]  Можно взять минимальное среди них и протолкнуть
[43:02.960 --> 43:05.360]  вот ровно столько потока по этому пути. То есть,
[43:05.360 --> 43:08.200]  например, если тут какие-нибудь капасити там, не знаю, 3,
[43:08.200 --> 43:12.880]  5, 2, 4, 7, то я беру минимальные среди всех этих остаточных
[43:13.740 --> 43:18.680]  капасити, у меня будет 2. Это минимум по всем cf на
[43:18.680 --> 43:25.420]  пути. И я двойку потока пускаю по этому пути. То
[43:25.420 --> 43:28.840]  есть, здесь добавляю плюс два потока, здесь плюс два,
[43:28.840 --> 43:32.040]  здесь плюс два, здесь плюс два и не забываю, что поскольку
[43:32.040 --> 43:35.180]  у меня есть антисимметричность, то по обратному ребру я должен
[43:35.180 --> 43:37.520]  добавить минус 2. То есть, здесь минус два потока, здесь
[43:37.520 --> 43:46.040]  здесь минус два, здесь минус два, здесь минус два. Пустили максимально возможное количество потока
[43:46.040 --> 43:52.760]  вдоль этого пути и не забываем, что нужно еще отменить поток справа налево. И здесь я
[43:52.760 --> 44:03.600]  еще подпишу, что перестрой GF. Потому что поток изменился, значит должна была измениться
[44:04.480 --> 44:10.960]  какие-то ребра могли появиться из-за того, что если опустил двойку потока по этому ребру,
[44:10.960 --> 44:15.040]  то у меня точно возникает обратное ребро вот такое. Я могу эту двойку потом отменить.
[44:15.040 --> 44:20.280]  Значит нам нужно не забывать, что иногда появляются обратные ребра.
[44:33.600 --> 44:43.120]  Так, ну в примерчике давайте вот тот самый наш, который был в самом начале,
[44:43.120 --> 44:50.520]  нарисуем. Если здесь везде копасть единички, то как может работать алгоритм Форда Фалкерсона?
[44:50.520 --> 44:56.360]  Ну либо он сразу находит один путь и потом на второй итерации второй путь и дальше в
[44:56.360 --> 45:02.800]  остаточности ничего не находит. Либо он сначала, мы же никак не уточняем, как именно мы должны
[45:02.800 --> 45:07.400]  искать увеличивающий путь. Среди всех мы можем выбрать любой. В общем, какой DFS найдет,
[45:07.400 --> 45:11.240]  по такому мы и продалкиваем поток. То есть здесь мы могли бы продалкнуть единичку потока
[45:11.240 --> 45:16.040]  как раз по вот этому неправильному пути. Но если мы так сделаем, то из-за того, что мы остаточную
[45:16.040 --> 45:21.720]  сеть перестраиваем, у меня возникает обратное ребро. Если здесь единичка потока, то здесь минус
[45:21.720 --> 45:27.320]  один, то есть остаточная копасть единица. Там было ноль, а поток минус один, поэтому остаточная
[45:27.320 --> 45:31.920]  копасть здесь единица. Ну и соответственно потом он находит вот такой вот путь, проталкивает по
[45:31.920 --> 45:40.000]  нему единичку и тем самым находит максимальный поток равный двойке. Вот, картинка поинтереснее.
[45:40.000 --> 45:47.800]  Тоже самое, только копасите здесь. Давайте какие-нибудь большие возьмем. 10 девятый,
[45:47.800 --> 45:59.080]  10 девятый, 10 девятый, 10 девятый, а здесь единица. Тогда опять, если нам повезло и алгоритм наш
[45:59.080 --> 46:04.800]  находит вот эти вот два пути, сначала этот по нему пускает 10 девятый потока, потом вот этот
[46:04.800 --> 46:09.000]  по нему пускает 10 девятый поток, то мы за две итерации нашли весь наш максимальный поток.
[46:09.000 --> 46:17.040]  Но если вдруг нам не везет и мы делаем вот такую вот глупость и пытаемся опускать единичку потока
[46:17.040 --> 46:23.000]  вдоль такого пути, то мы действительно можем пустить только единицу потока. Потому что среди
[46:23.000 --> 46:26.920]  всех вот этих копасите минимум это единица. Значит все, что я могу здесь пустить это один.
[46:26.920 --> 46:32.400]  Окей, значит за одну итерацию я пустил единицу потока здесь. Теперь дальше в остаточной сети
[46:32.400 --> 46:38.120]  появляется опять-таки вот это обратное ребро и единственный путь из SFT это вот такой. То есть
[46:38.120 --> 46:42.200]  нам нужно будет отменить здесь единицу потока. Но опять только единицу, потому что копасти
[46:42.200 --> 46:49.840]  останется один. Почему? А, да, да, да, да, вы правы, можно было бы вот так. Окей, тогда не единственный,
[46:49.840 --> 46:56.800]  но вот один из, еще раз, мы не специфицируем. Вот один из тех, по которому можно пустить,
[46:56.800 --> 47:02.120]  это вот этот. Ну берет он, вот так пускает. Тем самым мы за две итерации пустили здесь единицу
[47:02.120 --> 47:07.040]  потока и здесь единицу потока. Здесь как бы пустили и отменили. И соответственно количество
[47:07.040 --> 47:12.640]  итерации может достигнуть два на десять девятый. Каждая итерация плюс единица. Суммарно в конце
[47:12.640 --> 47:20.120]  будет два на десять девятый поток. Вот, поэтому даже на таком маленьком графе, там из четырех вершин,
[47:20.120 --> 47:32.680]  количество итерации может быть большим. Давайте. Сейчас, ну смотрите, когда я пускаю единицу вот
[47:32.680 --> 47:39.000]  такую потоку, у меня вот здесь становится поток единицы и капасти была единица. Но также у меня
[47:39.000 --> 47:45.680]  всегда, не забываем, если ребро я не рисую, на нем имеется в виду капасти ноль. Но если капасти ноль,
[47:45.680 --> 47:50.840]  а по этому ребру текла единица потока, то значит по обратному поток минус один из-за антисимметричности.
[47:50.840 --> 47:58.000]  Если сверху минус один, то снизу вверх минус один. А значит разность этих величин это единица.
[47:58.000 --> 48:04.680]  Поэтому всегда, если у меня вот здесь вот единица протекла, то немедленно появляется обратная
[48:04.680 --> 48:10.520]  с капастью один. Вот, ну и собственно по нему мы как раз этот поток будем отменять. То есть мы
[48:10.520 --> 48:14.560]  единицу сверху вниз пустили, потом снизу вверх пустили, тем самым как бы отменили то, что здесь
[48:14.560 --> 48:19.560]  текло. Ну и так будем много-много раз итерироваться. Вот, поэтому лучше, что здесь можно написать в
[48:19.560 --> 48:30.400]  терминах азимтотики. Это, ну я напишу f на e, где f это та самая собственно величина МАКС потока,
[48:30.400 --> 48:42.480]  а это число Ребер. Потому что, ну как мы видим, на каждой итерации в худшем случае нам придется
[48:42.480 --> 48:48.840]  проталкивать единицу потока, и если всего поток нам равен 2 на 29, то итерация может быть 2 на 29.
[48:48.840 --> 48:55.080]  Вот, а это время работы по сути DFS. Нам нужно из s попасть в t, время работы можно ограничить там
[48:55.080 --> 49:00.120]  числом Ребер просто. То есть здесь там формально надо писать v плюс e, можно изначально там отсечь
[49:00.120 --> 49:06.920]  от графа то, что недостижимо из s, оно тогда никогда не будет достижимо, и тогда множество
[49:06.920 --> 49:15.480]  вишен будет не больше множества Ребер. Основной здесь слагаемый будет e. Вот, значит это азимтотика
[49:15.480 --> 49:19.680]  алгоритма Форда Фалкерсона, и она действительно достигается. То есть если мы никак не говорим,
[49:19.680 --> 49:24.120]  какой путь выбирается, то в худшем случае мы будем делать ровно f итераций.
[49:24.120 --> 49:36.720]  Так, это можно пофиксить с помощью алгоритма Эдманца Карпа.
[49:46.480 --> 49:54.000]  Значит он звучит так. Делай все то же самое, только путь, по которому ты пускаешь поток,
[49:54.000 --> 50:05.280]  всегда выбирай коротчайшим путь слоя Ребер. Делать то же, что в алгоритме Форда Фалкерсона,
[50:05.280 --> 50:17.760]  только выбирать коротчайший путь, ну коротчайший путь слоя Ребер.
[50:27.880 --> 50:32.080]  То есть ведем такую спецификацию, что каждый путь, который мы выбираем, это один из коротчайших
[50:32.400 --> 50:42.240]  путей из СВТ, восстанчивой сети. То есть вместо ДФС мы будем пускать БФС. Чтобы найти коротчайший
[50:42.240 --> 50:48.040]  путь, мы будем просто пускать БФС. И все, больше ничего не принято. То есть опять, просто пока есть
[50:48.040 --> 50:52.800]  путь, мы находим коротчайшие из них и пускаем поток. И тогда утверждается, что азимтотика
[50:52.800 --> 51:04.640]  здесь будет ВЕ квадрат. Где В это число вершин, а Е это число Ребер. То есть вот такая простая
[51:04.640 --> 51:11.600]  модификация нам позволяет избавиться от зависимости от величины потока. Тут будет азимтотика ВЕ квадрат.
[51:11.600 --> 51:28.240]  А, ну да. Собственно, опять давайте примерно рисуем вот это вот. В нашей сети вот такой,
[51:28.240 --> 51:37.680]  на первом же шаге, что как бы неправильного делали форда Фалкерса? Мы брали вот такой путь и
[51:37.680 --> 51:43.560]  пускали по нему денечку потока. Но в Эдманскарпе такого уже не будет, потому что этот путь имеет
[51:43.560 --> 51:49.320]  длину 3 по числу Ребер, а эти пути будут иметь длину 2. Поэтому, по крайней мере, вот на этом графе у
[51:49.320 --> 51:53.920]  нас не будет такой проблемы, что мы будем там 2 на 10, 9 раз пускать такой путь, потом его отменять,
[51:53.920 --> 51:58.280]  пускать, отменять, пускать, отменять и так далее. Мы сразу пустим максимальный поток здесь,
[51:58.280 --> 52:03.080]  максимальный поток здесь. Потому что они имеют длину 2, а вот этот промежуточный через вот это
[52:03.080 --> 52:11.120]  перемычное ребро имеет длину 3, поэтому мы его никогда даже не рассмотрим. Сейчас будем доказывать,
[52:11.120 --> 52:28.240]  это нетривиальный факт. Сейчас будем доказывать. Вот, то есть смотрите, корректность понятна,
[52:28.240 --> 52:32.320]  алгоритма очевидна, потому что это просто модификация алгоритма Форда Фалкерса. Мы
[52:32.320 --> 52:38.320]  ищем какой-то путь в восстаженной сети, пока он есть, и пускаем по нему поток. Алгоритм заканчивается,
[52:38.320 --> 52:44.840]  только если в восстаженной сети нет пути, то есть поток максимальный по теореме. Корректность
[52:44.840 --> 52:49.600]  здесь все понятна, если алгоритм закончится, то он нашел максимальный поток. Теперь будем доказывать
[52:49.840 --> 53:01.240]  симптотику. Будем доказывать симптотику с помощью нескольких лям. Лемма первая. Пусть F и F',
[53:01.240 --> 53:19.200]  два последовательных потока в алгоритме Эдманса Карпа. Да, в алгоритме Эдманса Карпа. Дальше,
[53:19.200 --> 53:42.200]  пусть D от V это DIST в графе GF из S в V, а D' от V это DIST GF'SV. DIST это вот то самое
[53:42.200 --> 53:48.800]  кратчайшее расстояние от вершинки S до вершинки V, например, S это исток. И мы меряем кратчайшее
[53:48.800 --> 53:53.320]  расстояние в двух как бы последовательных остаточных сетях. Первое расстояние в GF,
[53:53.320 --> 53:59.600]  второе в GF'. Вот как бы у меня был поток F, я прокнул путь, получился F', и вот я смотрю,
[53:59.600 --> 54:04.680]  как поменялись мои остаточные сети и как поменялось в них кратчайшее расстояние от S. Так вот тогда
[54:04.680 --> 54:19.120]  для любой вершины это расстояние могло только увеличиться. Что если я протокнул сколько-то
[54:19.120 --> 54:25.640]  потока в остаточной сети, получилось F', то кратчайшее расстояние в новой остаточной сети
[54:25.760 --> 54:46.920]  могли только увеличиться по сравнению со старым. Доказательства. Пусть не так. Пусть для какой-то
[54:46.920 --> 54:51.720]  вершины вот эта штука уменьшилась. То есть пусть нашлась какая-то вершина, для которой здесь значок меньше.
[54:51.720 --> 54:59.400]  Тогда давайте среди всех вершин, для которых это неравенство нарушается, возьмем ту, для
[54:59.400 --> 55:16.400]  которой D' от V минимально возможно. Тогда среди всех вершин D' от V меньше D' от V выберем ту,
[55:16.400 --> 55:30.400]  для которой D' от V минимально возможно. То есть у нас вот это неравенство могло выполняться для
[55:30.400 --> 55:36.240]  нескольких вершин. Среди не всех возьмем ту, у которой D' минимально возможно. Если их несколько,
[55:36.240 --> 55:48.000]  то возьмем любую. Так, хорошо, давайте тогда нарисуем этот самый путь, кратчайший из S в V в
[55:48.000 --> 55:57.160]  остаточной сети GF'. Вот есть старт, есть какой-то кратчайший путь из S в V сети GF'. Здесь достигается
[55:57.160 --> 56:03.880]  то самое D' от V минимально возможно, при котором D' от V меньше, чем D' от V. Значит первое
[56:03.880 --> 56:16.200]  замечание такое, V не равно S, так как D от S равно D' под S равно 0. Вот эта вершина, которую я выбрал,
[56:16.200 --> 56:21.120]  не может совпадать со стартовой, потому что для стартовой понятное дело обе эти штуки нулевые,
[56:21.120 --> 56:26.280]  и соответственно это неравенство не может выполняться. Потому что кратчайшее встание от S в S это 0,
[56:26.280 --> 56:32.200]  не надо проходить ни одного ребра. Значит они различны, значит я могу корректно определить
[56:32.200 --> 56:37.600]  предыдущую вершину на пути. Если они различны, то корректно предназначу предпоследнюю вершину на
[56:37.600 --> 56:59.200]  этом пути. Пусть U это предпоследняя вершина на кратчайшем пути из S в V сети GF'. Вот такая картинка,
[56:59.200 --> 57:14.840]  вот был путь из S в V, U это предпоследняя вершина на этом пути. Давайте запишем все,
[57:14.840 --> 57:21.840]  что мы знаем про вершину U. Ну во-первых, раз U это предпоследняя на кратчайшем пути, то однозначно
[57:21.840 --> 57:29.160]  можем сказать, что D3 hatu плюс 1 это D3 hat v. Потому что раз она предпоследняя, то она лежит на кратчайшем
[57:29.160 --> 57:35.280]  пути, поэтому кратчайший путь до нее увеличен на 1 ребро это как раз кратчайший путь до v. Из-за того,
[57:35.280 --> 57:42.440]  что она лежит на кратчайшем пути. Но с другой стороны отсюда следует, что D3 hatu строго меньше
[57:42.440 --> 57:55.440]  D3 hat v, а значит D3 hatu больше равно D hatu. Потому что среди всех вершин, для которых вот это не
[57:55.440 --> 58:01.680]  выполнялось, мы взяли вершину с минимальным D3 hat v. Поэтому если мы рассмотрим U, для которой D3
[58:01.680 --> 58:06.320]  меньше D3 hat v, значит для нее вот это неравенство должно выполняться. Вот как бы в обратную сторону
[58:06.320 --> 58:10.960]  не может, потому что иначе мы вместо v должны были бы взять U, значит должно выполняться вот это.
[58:10.960 --> 58:22.840]  Так вот что мы знаем про вершинку U. Теперь зададимся вопросом, откуда вообще вот это
[58:22.840 --> 58:44.320]  вот ребро находится в оснащенности GF'. Откуда ребро U, GF'. Тут есть два случая. Первый случай,
[58:44.320 --> 58:50.080]  если это ребро присутствовало в сети GF и собственно осталось, то есть оно было в предыдущем в предыдущей
[58:50.080 --> 58:54.120]  оснащенности, и осталось после пропускания единички потока. Ну или там не единички,
[58:54.120 --> 59:06.200]  а какого-то потока вдоль пути. Значит первый случай, ребро УВ было в GF и осталось в GF'.
[59:06.200 --> 59:13.360]  То есть оно было и осталось, оно никуда не пропало и ниоткуда не появилось. Оно было и осталось.
[59:13.360 --> 59:25.120]  Так, но если оно было раньше, тогда мы точно можем записать, что dV не больше, чем dU плюс 1.
[59:25.120 --> 59:34.240]  Потому что если это ребро присутствует в GF, тогда кратчайшее расстояние dV гарантированно не
[59:34.240 --> 59:37.800]  превосходит кратчайшее расстояние dU плюс 1. Ну раз есть ребро, то можем всегда дойти сначала
[59:37.800 --> 59:44.520]  с dU, потом с помощью этого ребра дойти до V. Значит точно есть такое неравенство. И вот я утверждаю,
[59:44.520 --> 59:48.600]  что теперь здесь где-то написано противоречие. Что если собрать все, что мы сейчас написали,
[59:48.600 --> 01:00:00.280]  то вот это должно найти нам где-то противоречие. Ну давайте продолжать вот эту цепочку. Значит dU
[01:00:00.280 --> 01:00:07.600]  не больше, чем dU плюс 1. Дальше мы знаем, что dU не больше, чем dU. Поэтому здесь можно написать
[01:00:07.600 --> 01:00:27.680]  dU плюс 1. И наконец мы знаем, что dU плюс 1 это в точности dV. То есть dV не больше dV. А это
[01:00:27.680 --> 01:00:34.040]  противоречие с выбором вершинки V. Мы взяли вершинку V такую, что для нее d' меньше, чем dV.
[01:00:34.040 --> 01:00:58.920]  Противоречие. Согласны? Хорошо, второй случай. Возвращаемся к вопросу, откуда у V в этой
[01:00:58.920 --> 01:01:04.560]  оснашенной сети. Мы понимаем, что оно не могло, раз первый случай не валиден, это ребро не могло
[01:01:04.560 --> 01:01:12.000]  быть в GF. Но оно же откуда-то взяло в GF штрих. Его не было раньше, но оно появилось. Как ребро
[01:01:12.000 --> 01:01:18.600]  может возникнуть в оснашенной сети? Только если по обратному ребру протокнули поток. То есть что,
[01:01:18.600 --> 01:01:25.480]  второй случай. Этого ребра не было в GF, но оно появилось в GF штрих. Значит по обратному ребру
[01:01:25.480 --> 01:01:40.160]  протокнули поток. Потому что если у меня было ребро VU, и я по нему проталкиваю поток, то у меня
[01:01:40.160 --> 01:01:49.400]  гарантированно с положительной capacity появляется обратное ребро. Потому что здесь был какой-то
[01:01:49.400 --> 01:01:55.040]  поток, здесь минус поток. Если здесь была нулевая capacity, то оснашенная capacity это плюс F, то есть
[01:01:55.040 --> 01:02:00.800]  положительная величина. То есть возникнуть это ребро могло только в случае, если я проталкиваю по
[01:02:00.800 --> 01:02:08.920]  обратному вот этому ребру VU поток. Хорошо, но раз я проталкиваю по такому пути поток, то из-за того,
[01:02:08.920 --> 01:02:15.520]  что мой алгоритм всегда находит кратчайший путь для проталкивания потока, мы знаем, что dA2 это dA2
[01:02:15.520 --> 01:02:24.160]  плюс 1. Раз Edmund Scarp проталкивает поток по кратчайшему пути, и это ребро он, собственно, задействует,
[01:02:24.160 --> 01:02:30.600]  то есть проталкивает по нему поток, значит это ребро лежит на кратчайшем пути из SFT, поэтому вот
[01:02:30.600 --> 01:02:35.200]  эта штука на ничку больше, чем вот эта. Ну раз это кратчайший путь, то здесь все вот эти вот d's
[01:02:35.200 --> 01:02:45.480]  возвращают на единицу. Окей, ну и здесь тоже из-за этого равенства тоже можно извлечь
[01:02:45.480 --> 01:02:50.520]  какое-то противоречие с тем, что мы уже написали здесь. Ну смотрите, dA2 не больше, чем d'A2.
[01:02:50.520 --> 01:03:04.320]  Так, а d'A2, что мы знаем про d'A2? Значит, видимо, сначала надо написать, что это,
[01:03:10.320 --> 01:03:17.840]  то противоречие, сейчас, секунду, подсмотрю.
[01:03:20.520 --> 01:03:36.160]  Давайте d'A2 распишем, что d'A2 это d'V-1 получается. Мы оценили d'A2 через d'A2, потому что вот
[01:03:36.160 --> 01:03:41.640]  оно там написано, а дальше d'A2 расписываем как d'V-1, потому что вот тоже слева сверху написано
[01:03:41.640 --> 01:03:55.080]  вот это равенство. Значит, что мы получили? Вот это d'A2-1 больше обравно, чем d'A2-1. Значит,
[01:03:55.080 --> 01:04:03.240]  d'A2 больше обравно d'A2 плюс 2. Ну это опять противоречие, потому что мы предполагаем,
[01:04:03.240 --> 01:04:08.760]  что здесь неравенство в обратную сторону, d'A2 меньше, чем d'A2, а тут получили, что h больше
[01:04:09.000 --> 01:04:16.920]  плюс 2. Ну все, опять противоречие с выбором вершинки V. Значит, наше исходное предположение
[01:04:16.920 --> 01:04:20.880]  неверно, раз мы во всех случаях пришли к противоречию, поэтому нет ни одной вершинки,
[01:04:20.880 --> 01:04:32.720]  для которой вот это неравенство бы выполнялось. Значит, действительно, для любой V d' может
[01:04:32.720 --> 01:04:57.920]  только возрасти, ну не строго возрасти. Вопросы? Хорошо. Тогда вторая лемма.
[01:05:02.720 --> 01:05:11.560]  Будем говорить, что ребро насыщается, если после проталкивания очередного потока вдоль пути
[01:05:11.560 --> 01:05:22.320]  оно становится насыщенным, то есть у него становится f равно c. Говорим, что ребро насыщается,
[01:05:22.320 --> 01:05:34.400]  если после проталкивания очередной порции потока, да, у меня же как бы много итераций,
[01:05:34.400 --> 01:05:54.480]  если после проталкивания потока вдоль пути становится c равно f. То есть раньше не было,
[01:05:54.480 --> 01:05:59.560]  а теперь стало. Раньше поток был меньше, а теперь стало. Ребро как бы насытилось,
[01:05:59.560 --> 01:06:05.760]  мы исчерпали полностью его возможности. Вся capacity теперь как бы задействуется,
[01:06:05.760 --> 01:06:13.040]  мы не можем больше по нему увеличивать поток. Так вот, лемма утверждает, что любое ребро
[01:06:13.040 --> 01:06:34.440]  насыщается от v раз, максимум. Тогда любое ребро может насытиться не больше от v раз.
[01:06:34.440 --> 01:06:38.280]  Где v? Это число вершин.
[01:06:38.280 --> 01:07:04.520]  Так, ну почему это верно? Доказательства. Давайте рассмотрим какое-то конкретное
[01:07:04.520 --> 01:07:11.800]  ребро из uv и посчитаем сколько раз оно могло насытиться. То есть что такое вообще? Как оно
[01:07:11.800 --> 01:07:16.600]  может насытиться несколько раз? Ауч просто. Мы сначала могли пустить какой-то поток по нему и
[01:07:16.600 --> 01:07:23.560]  это ребро насытить, соответственно в остаточной сети возникает обратное ребро. И потом, чтобы uv
[01:07:23.560 --> 01:07:28.160]  опять насытилось, то есть мы его сначала как бы должны раз насытить, оно должно перестать насыщенным,
[01:07:28.160 --> 01:07:33.280]  то есть мы должны сначала протолкнуть какой-то поток по обратном пути. Значит потом опять это
[01:07:33.280 --> 01:07:37.920]  ребро uv появляется в остаточной сети и мы его опять насыщаем и так как можно больше раз пытаемся
[01:07:37.920 --> 01:07:42.520]  сделать. Сначала насытили, оно пропало, потом чтобы его опять насытить нужно его как бы вернуть
[01:07:42.520 --> 01:07:47.560]  сначала в остаточную сеть. То есть сначала нужно протолкнуть пусть по обратному ребру. Вот это самое
[01:07:47.560 --> 01:08:01.120]  главное здесь наблюдение. Чтобы протолкнуть, sorry, чтобы насытить ребро uv два раза,
[01:08:01.120 --> 01:08:21.040]  надо сначала протолкнуть поток по обратному ребру. Протолкнуть поток по ребру vu. То есть
[01:08:21.040 --> 01:08:26.960]  между каждыми двумя последовательными насыщениями происходит хотя бы одно как бы проталкивание в
[01:08:26.960 --> 01:08:31.480]  обратную сторону. Насытили, потом раз насытили в обратную сторону. Насытили, раз насытили и так
[01:08:31.480 --> 01:08:41.360]  далее. Вот ну и здесь смотрите, мы же как бы если проталкиваем поток по какому-то пути, то это
[01:08:41.360 --> 01:08:46.480]  обязательно всегда кратчайший путь из sft. Алгоритм Эдманс Карпа всегда находит кратчайший путь и
[01:08:46.480 --> 01:08:50.480]  значит если он это ребро задействовал или это ребро задействовал, то он обязательно лежал на
[01:08:50.480 --> 01:08:54.680]  кратчайшем пути. То есть сначала вот это было кратчайший, потом вот такой был кратчайший,
[01:08:54.680 --> 01:08:58.600]  потом опять этот, возможно с какими-то изменениями, но опять через uv проходящий,
[01:08:58.600 --> 01:09:04.800]  потом вот такой обратный через vu и так далее. Вот, ну тогда смотрите, если у меня изначально было,
[01:09:04.800 --> 01:09:12.960]  что uv лежало на кратчайшем пути, то я знаю, что d от u плюс 1 это d от v. Да, раз изначально в первый
[01:09:12.960 --> 01:09:20.200]  раз, когда она насытилась, у меня uv это ребро кратчайшего пути из sft, значит выполняется такое
[01:09:20.200 --> 01:09:27.760]  условие на, собственно, конце этого ребра. Это когда оно в первый раз насытилось. Дальше, когда
[01:09:27.760 --> 01:09:33.880]  оно раз насыщается, то есть мы проталкиваем поток по обратному ребру, вот по такому vu. У меня уже
[01:09:33.880 --> 01:09:41.360]  наоборот, vu это ребро кратчайшего пути. То есть в момент, когда я раз насыщиваю моё ребро, должно
[01:09:41.360 --> 01:09:52.680]  выполняться d' от v плюс 1 равно d' от u. А вот если вот это вот это d, а вот это d'. То есть когда я
[01:09:52.680 --> 01:09:58.720]  его насыщал, у меня происходит d, а когда я его раз насыщу, происходит d'. d' это расстояние от старта
[01:09:58.720 --> 01:10:05.320]  до вершинки. Вот, значит тут выполняется такое. Наоборот, раз это ребро кратчайшего пути, то
[01:10:05.320 --> 01:10:14.240]  выполняется такое равенство. Но при этом мы знаем, что d' всегда больше 0, чем d' от v, например.
[01:10:14.240 --> 01:10:19.760]  По предыдущей лейме кратчайшие расстояния до всех вершин могут только увеличиваться.
[01:10:19.760 --> 01:10:32.320]  Ну да, тогда я могу написать такую цепочку. d' от u равно d' от v плюс 1,
[01:10:32.320 --> 01:10:51.000]  больше равно d' от v плюс 1 равно d' от u плюс 2. То есть, смотрите, мораль какая. Перед тем, как я
[01:10:51.000 --> 01:10:57.800]  смогу во второй раз насытить это ребро, у меня d' от u должно вырасти хотя бы на два по сравнению
[01:10:57.800 --> 01:11:06.360]  с d' от u. Иными словами, между двумя последовательными насыщениями ребра d' от старта вершины этого
[01:11:06.360 --> 01:11:11.720]  ребра, то есть d' от u, увеличивается хотя бы на два, чтобы стало d' от u. То есть, кратчайшее
[01:11:11.720 --> 01:11:17.320]  расстояние до начала ребра увеличивается хотя бы на два, чтобы оно насытилось во второй раз. Ну и
[01:11:17.320 --> 01:11:23.280]  так далее. Если я там посмотрю интервал времени от второго насыщения до третьего, то работает
[01:11:23.280 --> 01:11:28.160]  то же самое. И значит, между вторым и третьим насыщениями у меня опять d увеличится хотя бы
[01:11:28.160 --> 01:11:33.920]  на два. То есть, было d' от u, это хотя бы d' от u плюс 2. Дальше d' от u будет хотя бы d' от u плюс 2.
[01:11:33.920 --> 01:11:39.320]  Ну опять, хотя бы на два выросло. Ну и так далее. Ну и понятно, что d не может расти больше, чем число
[01:11:39.320 --> 01:11:48.080]  вершин. Раз у меня всего в графе v вершин, тогда d, оно всегда как бы, d долевой вершинки x не больше,
[01:11:48.080 --> 01:11:55.040]  чем видимо v-1. Может, на кратчайшем пути всегда не больше, чем v-1 ребра. Нет смысла там петлять
[01:11:55.040 --> 01:11:59.840]  по каким-то циклам, кратчайшее состояние всегда не больше, чем v-1. Ну и все, раз у меня вот эта
[01:11:59.840 --> 01:12:04.280]  штука каждый раз увеличится хотя бы на два, но при этом ограничена сверхучислон вершин, значит,
[01:12:04.280 --> 01:12:08.840]  количество насыщения это v пополам максимум. Ну там, плюс один может быть. То есть, вот f.
[01:12:08.840 --> 01:12:16.040]  Давайте эту катку запишу.
[01:12:16.040 --> 01:12:24.720]  Значит, чтобы насытить ребро еще раз,
[01:12:24.720 --> 01:12:35.240]  d от u должно увеличиться хотя бы на два.
[01:12:35.240 --> 01:12:49.080]  Но d от u всегда ограничено от v, значит, число насыщения есть от v.
[01:13:03.680 --> 01:13:04.440]  То, что требовалось.
[01:13:05.240 --> 01:13:12.560]  Вопросы?
[01:13:12.560 --> 01:13:20.280]  Хорошо. Ну вот, мы доказали нашу вторую лему, что каждый ребро насыщается не больше, чем от v раз.
[01:13:20.280 --> 01:13:27.240]  Ну и, наконец, следствие, что алгоритм Edmonds-Carp работает за v-e квадрат. Сейчас уже будет это
[01:13:27.240 --> 01:13:40.080]  просто. Работает за v-e квадрат. Ну смотрите, мы знаем, что каждое ребро насыщается максимум v раз.
[01:13:40.080 --> 01:13:46.120]  Ну v пополам, на самом деле, от v раз. Каждое ребро насыщается максимум v раз. Вопрос.
[01:13:46.120 --> 01:13:51.800]  Сколько тогда всего суммарно может быть насыщений? Ну понятно, если всего e ребер, то суммарно
[01:13:51.800 --> 01:13:57.640]  насыщений может быть v-e. Но понятно, что каждая итерация алгоритма обязательно насыщает хотя бы
[01:13:57.640 --> 01:14:02.880]  одно ребро. Потому что как работает итерация алгоритма? Мы выбираем крышейший путь, выбираем
[01:14:02.880 --> 01:14:07.880]  среди всех осадочных капаситей минимальную и пускаем, собственно, этот поток. Поток такой
[01:14:07.880 --> 01:14:13.240]  увеличенный по этому пути. Значит, хотя бы одно ребро обязательно насытится. Раз я среди всех этих
[01:14:13.240 --> 01:14:17.920]  капаситей выбрал минимальную и пустил ее, то вот то самое ребро, на котором была минимальная
[01:14:17.920 --> 01:14:22.680]  капаситет, теперь насытится. Я ее добил до максимума. То есть я по этому пути пускаю максимально
[01:14:22.680 --> 01:14:27.080]  возможное количество воды, то есть хотя бы одно ребро обязательно насытится. Иначе я мог бы увеличить
[01:14:27.080 --> 01:14:33.960]  поток. То есть каждая итерация насыщает хотя бы одно ребро. Но раз всего насыщений максимум v-e,
[01:14:33.960 --> 01:14:47.720]  то итерация максимум v-e. Значит, каждая итерация алгоритма насыщает хотя бы одно ребро.
[01:14:47.720 --> 01:15:07.160]  Значит, итерации максимум от v-e. Итерации от v-e. Ну все, если итерации столько, то что
[01:15:07.160 --> 01:15:12.480]  такое итерация? Это bfs по сути. Просто bfs и по этому пути надо что-то протолкнуть. Итерации столько,
[01:15:12.480 --> 01:15:18.080]  время работы bfs это от e, ну вообще v плюс e, но опять повторюсь, v мы считаем что не больше,
[01:15:18.080 --> 01:15:24.000]  чем e, этого можно добиться просто отрезав все, что недостижимо. Тогда e будет по порядку такой же
[01:15:24.000 --> 01:15:29.120]  как v, хотя бы. Значит, вот столько итераций, каждый работает за от e, потому что это bfs,
[01:15:29.120 --> 01:15:42.360]  перемножаем, получаем v-e квадрат. Ну вот теперь доказали. Нет, конечно,
[01:15:42.360 --> 01:15:51.640]  ну в смысле на каких-то графах, конечно, может только работать, но зачастую это прям очень такая жирная
[01:15:51.640 --> 01:15:56.960]  оценка сверху. То есть, если вы там построили какой-то граф и пустили на нем Эдман Сакарпа,
[01:15:56.960 --> 01:16:02.240]  то скорее всего у вас будет что-то сильно меньше, чем вот это. То есть, да, существуют конкретные
[01:16:02.240 --> 01:16:07.520]  графы, на которых такая симпотика достигается. Но на реальных, грубо говоря, графах, конечно,
[01:16:07.520 --> 01:16:13.400]  будет все сильно приятнее, чем вот эта вот верхняя оценка. Потому что, ну что, что такое как бы худший
[01:16:13.400 --> 01:16:18.480]  случай, да, это когда на каждой итерации ровно одно ребро насыщается. Ну если у вас, скажем там,
[01:16:18.480 --> 01:16:23.040]  capacity все это, не знаю, там единички или двойки, то у вас довольно много может ребер сразу насыть
[01:16:23.040 --> 01:16:32.160]  на одной итерации. Например, так вот. И, конечно, там будет симпотика сильно лучше, чем это. Так,
[01:16:32.160 --> 01:16:46.320]  хорошо, давайте тогда пример с задачкой посмотрим. Пример, пример. Пример с задачкой, которая,
[01:16:46.320 --> 01:16:51.240]  на первый взгляд, вообще не имеет ничего общего с потоками. Значит, смотрите, пусть есть n человек,
[01:16:51.240 --> 01:17:03.080]  есть n человек. Мы их должны распределить по двум профессиям. Ну, пусть будут математики
[01:17:03.080 --> 01:17:06.640]  и программисты. Значит, каждый человек должен стать либо математиком, либо программистом,
[01:17:06.640 --> 01:17:12.840]  и при этом каждый в каком-то смысле не любит ни то ни то. То есть, каждый предпочитает сидеть на
[01:17:12.840 --> 01:17:20.040]  диване, и он как бы, его недовольство от профессии математика это какое-то число, от профессии
[01:17:20.040 --> 01:17:24.520]  программиста это какое-то другое число. То есть, в идеале он ничего не хочет, но, к сожалению,
[01:17:24.520 --> 01:17:35.680]  придется. Значит, всех хотим заставить работать. Математиком или программистом.
[01:17:35.680 --> 01:17:52.200]  Значит, соответственно, у каждого человека есть недовольство своей будущей профессии математика,
[01:17:52.200 --> 01:18:03.440]  своей будущей профессии программиста. У Итого недовольство, а Итая быть математиком,
[01:18:03.440 --> 01:18:13.520]  и Б.И.Т. быть программистом. То есть, если его на одну из этих двух профессий назначают,
[01:18:13.520 --> 01:18:20.600]  то он недоволен вот на такую-то величину. Вот, и более того, у нас есть некие пары дружащих
[01:18:20.600 --> 01:18:28.040]  людей. Дружба заключается в следующем. Если Итого и Житого ребят назначают на разные профессии,
[01:18:28.040 --> 01:18:33.600]  то они недовольны на Ц.И.Т. и Ж.Т. То есть, они как бы хотят работать вместе. Если их разлучили,
[01:18:33.600 --> 01:18:46.520]  то суммарное недовольство увеличится на какую-то величину. Для некоторых пар и Ж.Т. есть
[01:18:46.520 --> 01:18:57.880]  недовольство тем, что их разъединят и назначат на разные профессии. Есть недовольство Ц.И.Ж.
[01:18:58.120 --> 01:19:15.320]  если их назначат на разные профессии. Вот, и наша задача, конечно, это разбить всех ребят на
[01:19:15.320 --> 01:19:20.680]  математиков-программистов так, чтобы минимизировать суммарное недовольство. Минимизировать
[01:19:20.680 --> 01:19:34.240]  суммарное недовольство. Каждому назначать профессию так, чтобы суммарное недовольство
[01:19:34.240 --> 01:19:39.160]  своими профессиями плюс суммарное количество вот этих вот расставаний и других было как можно
[01:19:39.160 --> 01:19:49.880]  меньше. Так, вопрос у меня к вам. Смотрите, сегодня мы пытались искать максимальный поток. А здесь
[01:19:49.880 --> 01:19:56.080]  нужно найти что-то минимальное. Как можно, типа, с помощью того, что мы делали, искать минимум,
[01:19:56.080 --> 01:20:06.280]  а не максимум? Ну вот, капасти, к сожалению, минус один намного не очень хорошо, потому что
[01:20:06.280 --> 01:20:15.760]  когда капасти будут отрицательные. Да, давайте сейчас все эти штуки больше на нуля. Что? Да,
[01:20:15.760 --> 01:20:22.840]  мы на самом деле вспоминаем факт, что максимальный поток равен минимальному разрезу. И более того,
[01:20:22.840 --> 01:20:26.960]  если мы нашли максимальный поток, то мы знаем минимальный разрез. По величине, по крайней мере.
[01:20:26.960 --> 01:20:39.280]  Значит, вместо максимизации потока мы будем искать минимальный разрез. Вот, ну тогда сеть будет
[01:20:39.280 --> 01:20:45.680]  такой. Мы вводим искусственно вспомогательные вершины С и Т, которые не соответствуют нашим людям,
[01:20:45.680 --> 01:20:51.640]  а просто вспомогательные вершины С и Т. И дальше проводим следующие ребра. Значит, смотрите,
[01:20:51.640 --> 01:20:59.400]  если есть два друга, которые хотят быть вместе, то мы проводим два ребра в обе стороны с капастью
[01:20:59.400 --> 01:21:05.040]  С и Ж. Соответственно, если тогда мы их как бы рассечем, да, и как бы наш разрез это как раз
[01:21:05.040 --> 01:21:09.760]  разбиение на два множества. С и Т. Так вот, если мы их рассечем и не будут в разных множествах,
[01:21:09.760 --> 01:21:19.360]  то как раз одно из этих ребер даст нам неудовольство С и Т и Ж. Теперь для каждого чувака Х мы еще,
[01:21:19.360 --> 01:21:25.640]  давайте проведем вот такое вот ребро, а Х. Тогда если оно рассекается, и соответственно Х не в С,
[01:21:25.640 --> 01:21:32.080]  то он недоволен тем, что он математик. И для каждого также человека мы проведем ребро
[01:21:32.080 --> 01:21:38.800]  с капастью B и Y из Y в T. Тогда если разрез пересекает это ребро, то это недовольство тем,
[01:21:38.800 --> 01:21:44.440]  что он стал программистом. Хорошо, тогда смотрите, вот пусть я построил в этом графике
[01:21:44.440 --> 01:21:55.360]  какой-то разрез. Какой-то разрез. На какие ребра этот разрез пересекается? Ну, во-первых,
[01:21:55.360 --> 01:22:00.600]  будут какие-то такие пары, которые я пересек, то есть будут какие-то вот такие С и Т и Ж. То есть,
[01:22:01.000 --> 01:22:06.080]  если я вот этих всех назначаю программистами, а этих математиками, то у меня возникает некоторое
[01:22:06.080 --> 01:22:12.560]  недовольство вот этих двух людей, что они не в одной команде. Дальше есть вот такие ребра из вершины
[01:22:12.560 --> 01:22:21.640]  Y какой-то в Т. То есть, если я человека отнес к первой доле, к С большому, то у меня возникло
[01:22:21.640 --> 01:22:26.000]  недовольство тем, что он B и Y, то есть он программист. Давайте считаем, что вот это все ребята это
[01:22:26.000 --> 01:22:33.160]  программисты, а эти математики. Тем самым, если мы человека отнесли к программистам,
[01:22:33.160 --> 01:22:38.600]  недовольство общее увеличилось на B и Y. Ну, то, что нужно. И, наконец, бывают вот такие ребра,
[01:22:38.600 --> 01:22:44.680]  а X. Это недовольство тем, что его назначили математиком. А это как раз множество математиков.
[01:22:44.680 --> 01:22:52.440]  Тем самым, смотрите, что мы показали. Мы показали, что каждый разрез, то есть, по сути, просто каждое
[01:22:52.440 --> 01:22:58.040]  разбиение наших людей на два множества математиков-программистов, каждый разрез по величине
[01:22:58.040 --> 01:23:03.360]  равен вот с точностью недовольству такого разбиения. Величина разреза
[01:23:03.360 --> 01:23:13.200]  СТ равна суммарному недовольству.
[01:23:13.200 --> 01:23:36.480]  Если S это программисты, а T это математики. Вот, значит, если мы хотим минимизировать это
[01:23:36.480 --> 01:23:43.720]  недовольство, то мы просто в этой сети находим максимальный поток. Его величина равна минимальному
[01:23:43.720 --> 01:23:48.320]  разрезу по величине. И это, собственно, и есть ответ. То есть, по сути, чтобы найти ответ,
[01:23:48.320 --> 01:23:52.440]  нужно просто в этой сети найти максимальный поток и вывести это как число. Удивительным
[01:23:52.440 --> 01:23:56.160]  образом, эта штука, то есть максимальный поток, равен минимальному недовольству.
[01:23:56.160 --> 01:24:01.640]  Ну, тогда на этом все. Спасибо.
