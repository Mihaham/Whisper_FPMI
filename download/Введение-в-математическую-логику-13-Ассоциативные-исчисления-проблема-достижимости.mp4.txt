[00:00.000 --> 00:18.160]  Я напомню, что в прошлый раз я сформулировал теорему
[00:18.160 --> 00:23.560]  о том, что множество общезначимых формул неразрешимо.
[00:23.560 --> 00:26.320]  Точнее речь идет о кодировках общезначимых формул.
[00:26.320 --> 00:29.400]  Мы обсуждали, как их кодировать в двоичном алфавите, в начале
[00:29.400 --> 00:33.840]  в конечном алфавите, потом в двоичном.
[00:33.840 --> 00:37.120]  Ну и пора начинать эту теорему доказывать.
[00:37.120 --> 00:40.400]  Доказательства по видео за сегодня я не закончу,
[00:40.400 --> 00:42.040]  потому что оно довольно длинное.
[00:42.040 --> 00:48.640]  Начну я с того, что отчасти повторю ваш курс алгоритмов,
[00:48.640 --> 00:50.800]  потому что, понятно, нужно доказать алгоритмическую
[00:50.800 --> 00:54.240]  неразрешимость, и чтобы быть уверенным, что у нас
[00:54.240 --> 00:57.340]  общий язык, я какие-то вещи повторю, постараюсь довольно
[00:57.340 --> 00:59.100]  быстро, естественно, все без доказательств.
[00:59.100 --> 01:07.180]  Вообще то, что можно доказывать неразрешимость чего-то,
[01:07.180 --> 01:08.340]  выглядит как некоторое чудо.
[01:08.340 --> 01:13.100]  Алгоритмов очень много, то есть по сути дела можно
[01:13.100 --> 01:16.700]  сколь угодно хитроумную процедуру придумать, и
[01:16.700 --> 01:20.060]  мы должны как-то все эти процедуры объяснить, что
[01:20.060 --> 01:21.060]  все они ломаются.
[01:21.060 --> 01:26.820]  Ну, как это делается, есть специальные задачи, для
[01:26.820 --> 01:29.540]  которых это можно сделать отдельным способом, диагональным
[01:29.540 --> 01:33.260]  методом, вам про него, наверное, рассказывали, а дальше используется
[01:33.260 --> 01:34.260]  такая техника.
[01:34.260 --> 01:37.620]  Мы плохо представляем себе все алгоритмы, но мы хорошо
[01:37.620 --> 01:40.620]  умеем строить конкретные алгоритмы, поэтому если
[01:40.620 --> 01:44.140]  у нас есть задача, про которую мы уже знаем, что алгоритмическая
[01:44.140 --> 01:45.820]  неразрешимость, идея состоит в том, что из нее получать
[01:45.820 --> 01:48.900]  новые неразрешимые задачи, и для этого используется
[01:48.900 --> 01:50.820]  техника сводимости.
[01:50.820 --> 01:54.500]  Значит, вам про это рассказывали, я уверен, но я повторю короткое
[01:54.500 --> 01:55.500]  определение.
[01:55.580 --> 02:00.060]  Язык А сводится к языку B, M сводимость меня будет интересовать.
[02:00.060 --> 02:09.820]  Если существует тотальная вычислимая функция, ну,
[02:09.820 --> 02:12.540]  я считаю, что у меня двоичные слова, то есть функция должна
[02:12.540 --> 02:14.740]  действовать из двоичных слов в двоичные слова.
[02:14.740 --> 02:26.780]  Такая, что X принадлежит A равносильно тому, что F от
[02:26.780 --> 02:27.780]  X принадлежит B.
[02:27.780 --> 02:31.180]  То есть если мы хотим ответить на вопрос о принадлежности
[02:31.180 --> 02:35.740]  слова языка, мы можем поступить иначе, мы можем применить
[02:35.740 --> 02:40.260]  эту функцию, получить какое-то новое слово F от X и проверять
[02:40.260 --> 02:43.220]  уже принадлежность языку B.
[02:44.180 --> 02:47.980]  Это удобно в силу следующих утверждений.
[02:47.980 --> 02:58.260]  Во-первых, если A, M сводится к B, значит, если A неразрешим,
[02:58.260 --> 02:59.260]  то и B неразрешим.
[02:59.260 --> 03:05.900]  Вот, собственно, основной факт, благодаря которому
[03:05.900 --> 03:09.860]  нам удается размножать, то есть чтобы построить,
[03:09.860 --> 03:12.380]  доказать сводимость, нам нужно построить алгоритм
[03:12.380 --> 03:15.900]  сводящую функцию, которая делает преобразование задач.
[03:15.900 --> 03:22.220]  И это нам проще, чем бороться со всеми алгоритмами.
[03:22.220 --> 03:26.060]  Ну и почему важна M-сводимость, потому что она еще и то
[03:26.060 --> 03:27.740]  же самое делает для неперечислимых.
[03:27.740 --> 03:33.500]  Значит, если A не перечислим, то и B не перечислим.
[03:33.500 --> 03:41.180]  Это не для всех типов сводимости такое есть, но для M-сводимости
[03:41.180 --> 03:42.180]  есть.
[03:42.220 --> 03:46.580]  Ну и дальше важное наблюдение состоит в том, что M-сводимость
[03:46.580 --> 03:47.580]  транзитивна.
[03:47.580 --> 03:54.780]  Если у вас A сводится к B, B сводится к C, то тогда A сводится
[03:54.780 --> 03:55.780]  к C.
[03:55.780 --> 03:58.500]  В результате мы можем эти сводимости строить длинные
[03:58.500 --> 03:59.500]  цепочки.
[03:59.500 --> 04:01.780]  Пользуясь транзитивностью, мы можем сделать один шаг,
[04:01.780 --> 04:04.500]  потом второй, то есть сложную задачу, ну вот перед нами
[04:04.500 --> 04:07.100]  например цель доказать неразрешимость общезначимых
[04:07.100 --> 04:08.100]  форм.
[04:08.100 --> 04:10.740]  В один шаг не очень понятно, как это сделать, мы это сделаем
[04:10.740 --> 04:11.740]  в несколько шагов.
[04:11.740 --> 04:18.860]  Ну и наконец, что еще хорошо бы сказать про это.
[04:18.860 --> 04:22.540]  А, ну да, для неперечислимости еще важно такое свойство.
[04:22.540 --> 04:28.500]  Сейчас оно мне будет не нужно, но оно очевидно из определения,
[04:28.500 --> 04:31.260]  что одна и та же сводящая функция, если она A сводит
[04:31.260 --> 04:34.260]  к B, то дополнение к A сводит дополнение к B.
[04:34.260 --> 04:37.780]  Ну это за счет того, что там равносильность, поэтому
[04:37.780 --> 04:40.420]  понятно, что X принадлежит A, равносильная F от X принадлежит
[04:40.420 --> 04:41.420]  B.
[04:41.420 --> 04:44.060]  Это, можно пересказать иначе, X не принадлежит A, равно
[04:44.060 --> 04:47.740]  сильно тому, что F от X не принадлежит B, это просто
[04:47.740 --> 04:49.980]  чисто логически равносильные вещи.
[04:49.980 --> 04:56.180]  Вот мы будем основываться на этих сводимостях.
[04:56.180 --> 04:57.580]  Ну надо от чего-то сводить.
[04:57.580 --> 05:02.140]  Я буду использовать, значит общая идея такая, если у
[05:02.140 --> 05:04.500]  вас есть какая-то универсальная модель вычислений, с ней
[05:04.500 --> 05:07.620]  легко связать какую-нибудь неразрешимую задачу.
[05:07.780 --> 05:11.260]  Более-менее, если модель универсальная, то есть такой
[05:11.260 --> 05:19.100]  базовый факт, что предсказать результат работы невозможно.
[05:19.100 --> 05:23.260]  Если бы вы могли, то там известным способом строится
[05:23.260 --> 05:24.260]  противоречие.
[05:24.260 --> 05:28.660]  Но мне будет нужна совершенно конкретная модель, которая
[05:28.660 --> 05:36.740]  у вас по счастью была, называется машиной тьюринга, одноленточная
[05:36.900 --> 05:37.900]  если строго говорить.
[05:37.900 --> 05:46.500]  И я сейчас напомню определение, потому что мне будут важны
[05:46.500 --> 05:48.180]  технические подробности.
[05:48.180 --> 05:50.900]  Для построения сводимости нужно… машина тьюринга
[05:50.900 --> 05:53.620]  такая комбинаторная модель, и вот эта комбинаторная
[05:53.620 --> 05:55.700]  структура нам и будет нужна.
[05:55.700 --> 05:57.340]  Значит из чего она состоит?
[05:57.340 --> 05:58.860]  Она состоит из двух множеств.
[05:58.860 --> 06:10.060]  Из еще таких вот элементиков, из-под множества.
[06:10.060 --> 06:14.980]  Я сейчас объясню весь смысл этих… Что, простите?
[06:14.980 --> 06:22.260]  А, нет, это… Вот у нас такие 7 элементов будут, причем
[06:22.260 --> 06:26.300]  лямбда и вот этот вот значок – это элементы множества
[06:26.300 --> 06:28.060]  А, которые называются алфавитом.
[06:28.060 --> 06:34.700]  Лямбда называется пробельный символ или пустой символ,
[06:34.700 --> 06:38.140]  а вот этот значечек треугольника – это маркер конца.
[06:38.140 --> 06:42.260]  Q0 – это элемент множества Q, множество Q называется
[06:42.260 --> 06:44.140]  множеством состояний.
[06:44.140 --> 06:48.140]  Значит Qf – это множество финальных состояний.
[06:48.140 --> 06:58.100]  Но у вас, насколько я знаю, всегда подразумевалось,
[06:58.100 --> 07:00.580]  что их два – принимающее и отвергающее.
[07:00.580 --> 07:07.300]  Ну, я привык к такой большей общности, это неважно.
[07:07.300 --> 07:10.820]  На самом деле деталей конкретного построения очень много.
[07:10.820 --> 07:14.220]  Мне будет удобно считать, что у меня какое-то множество
[07:14.220 --> 07:16.220]  финальных состояний.
[07:16.300 --> 07:19.460]  Ну и, наконец, самое интересное – это дельта – это функция.
[07:19.460 --> 07:22.540]  Она называется таблица переходов или функция переходов.
[07:22.540 --> 07:30.380]  Она отображает пары… Так, давайте я подумаю, в каком
[07:30.380 --> 07:37.140]  порядке мне удобнее записывать пары… Не помню… Неважно.
[07:37.140 --> 07:46.580]  Понятно, что порядок, в котором мы записываем символы
[07:46.580 --> 07:50.020]  и состояния, несуществны, но мы будем считать, что
[07:50.020 --> 07:51.780]  у нас такая функция переходов.
[07:51.780 --> 07:56.980]  На функцию переходов надо смотреть как на инструкцию.
[07:56.980 --> 08:01.060]  То есть это вообще говоря функция, но по сути дела
[08:01.060 --> 08:02.380]  мы от нее чего хотим?
[08:02.380 --> 08:07.500]  Мы хотим записывать инструкции такого вида.
[08:07.500 --> 08:14.820]  Видишь символ А в состоянии Q, напиши новый символ H',
[08:14.820 --> 08:16.940]  перейди в новое состояние Q и сдвинься.
[08:16.940 --> 08:23.260]  Вот эти… Третье компоненты значений функции переходов
[08:23.260 --> 08:25.060]  – это команда движения.
[08:25.060 --> 08:27.820]  То есть мы либо сдвигаемся влево, либо стоимся на месте,
[08:27.820 --> 08:28.820]  либо сдвигаемся вправо.
[08:28.820 --> 08:33.860]  Для удобства мы считаем, что дельта тотальная, всюду
[08:33.860 --> 08:34.860]  определенная.
[08:34.860 --> 08:43.620]  И я зафиксирую ее поведение на вот этом особом символе
[08:43.620 --> 08:45.100]  маркера конца.
[08:45.100 --> 08:50.100]  Поведение такое, что дельта от маркера конца в любом
[08:50.100 --> 08:54.660]  состоянии – это маркер конца, то есть она маркер конца
[08:54.660 --> 08:59.020]  не меняет, состояние может изменить, и при этом сдвигается
[08:59.020 --> 09:00.020]  обязательно вправо.
[09:00.020 --> 09:11.380]  Ну и соответственно, если значение функции символ
[09:11.380 --> 09:17.660]  является маркером конца, то тогда это может быть
[09:17.660 --> 09:22.140]  только в том случае, если в аргументе тоже стоит
[09:22.140 --> 09:23.740]  маркер конца.
[09:23.820 --> 09:24.820]  Почему такие условия?
[09:24.820 --> 09:27.980]  Я сейчас объясню, как работает машина, напомню, вам уже
[09:27.980 --> 09:31.220]  это объясняли заведомо, и станет ясно, что эти ограничения
[09:31.220 --> 09:33.260]  просто нужны для того, чтобы маркер конца всегда
[09:33.260 --> 09:35.740]  указывал на конец ленты.
[09:35.740 --> 09:38.900]  А работает машина так, она работает с полубесконечной
[09:38.900 --> 09:43.980]  лентой, самой первой ячейки которой записан маркер
[09:43.980 --> 09:46.660]  конца как раз, а дальше написаны какие-то символы
[09:46.660 --> 09:47.660]  алфавита.
[09:47.660 --> 09:57.660]  У машины есть головка, которая смотрит на какую-то конкретную
[09:57.660 --> 10:00.260]  ячейку, ячейки можно считать занумерованы не отрицательными
[10:00.260 --> 10:05.020]  целыми числами, и вот головка смотрит на конкретную ячейку
[10:05.020 --> 10:08.060]  и машина находится в каком-то состоянии Q, а дальше, как
[10:08.060 --> 10:12.980]  я уже сказал, она смотрит на пару A и Q, тут написан
[10:12.980 --> 10:15.900]  какой-то символ A, и соответственно либо движется влево, либо
[10:15.900 --> 10:19.660]  движется вправо, символ здесь меняет на то, что указано
[10:19.660 --> 10:23.780]  на аштрих, ну и состояние тоже меняет на Q-штрих.
[10:23.780 --> 10:25.980]  Это то, что называется такт работы.
[10:25.980 --> 10:29.180]  И машина циклический повторяет эти такты работы, пока не
[10:29.180 --> 10:33.100]  попадает в состояние из множества QF, тогда она останавливается.
[10:33.100 --> 10:37.380]  То есть множество QF нам нужно для того, чтобы сказать,
[10:37.380 --> 10:38.700]  когда машина останавливается.
[10:38.700 --> 10:47.140]  Ну, вообще-то, чтобы объяснить, какой полезный результат
[10:47.140 --> 10:49.580]  дает машина, нужно еще определить функцию вычислимой
[10:49.580 --> 10:53.340]  на машине тюринга, мне это не понадобится, я про это
[10:53.340 --> 10:56.940]  особо говорить не буду, ну, может быть, очень коротко
[10:56.940 --> 10:59.700]  скажу, да, значит, что-то сказать-таки надо.
[10:59.700 --> 11:04.260]  Вот что в этой модели неудачно, неудачно то, что лента бесконечная.
[11:04.260 --> 11:06.100]  Она бесконечная, потому что мы не знаем, сколько
[11:06.100 --> 11:08.580]  памяти понадобится алгоритму для своей работы.
[11:08.580 --> 11:12.540]  Поэтому мы вынуждены запасти сколько угодно много места,
[11:12.540 --> 11:13.700]  значит бесконечное место.
[11:13.700 --> 11:20.260]  Но это неудобно, потому что бесконечные объекты
[11:20.260 --> 11:23.020]  они не конструктивные, непонятно, как с произвольным бесконечным
[11:23.020 --> 11:24.740]  объектом вообще что-то конструктивное делать.
[11:24.740 --> 11:29.140]  Поэтому мы предполагаем, что у нас есть сколько-то
[11:29.140 --> 11:32.300]  символов в начальный момент, есть сколько-то символов,
[11:32.300 --> 11:37.580]  которые не пустые, а дальше вся лента заполнена пустыми
[11:37.580 --> 11:38.580]  символами.
[11:38.580 --> 11:43.820]  И ясно тогда, что после любого конечного числа
[11:43.820 --> 11:47.260]  тактов работы лента снова находится в таком состоянии,
[11:47.260 --> 11:49.020]  что начиная с какого-то места все символы пустые.
[11:49.020 --> 11:54.540]  Это вот место, когда уже идут только пустые символы,
[11:54.540 --> 11:56.820]  называется концом рабочей зоны, вот эта вот рабочая
[11:56.820 --> 12:00.580]  зона, давайте скажем, не уверен, что мне это понадобится
[12:00.580 --> 12:05.020]  слова, но скажу на всякий случай.
[12:05.020 --> 12:09.340]  Ну и вот в начале подается какое-то слово, с ним начинается
[12:09.340 --> 12:12.820]  работа, и она в какой-то момент заканчивается, нужно
[12:12.820 --> 12:13.820]  еще определить результат.
[12:13.820 --> 12:17.020]  Как-то у вас результат, я не знаю, как у вас определялся,
[12:17.020 --> 12:20.300]  его можно по-разному определять, как у вас определялся результат
[12:20.300 --> 12:21.300]  работы машины?
[12:21.300 --> 12:28.860]  А, все, что осталось на ленте, ну видите, как у вас сурово,
[12:28.860 --> 12:31.740]  то есть нужно все, кроме результата, стереть.
[12:31.740 --> 12:34.620]  Ну тогда надо и, на самом деле, маркер правого конца
[12:34.620 --> 12:37.980]  конечно сразу заводить, ну хорошо, давайте считать
[12:37.980 --> 12:44.580]  так, хотя, ну в общем, неважно, это почти всегда все равно
[12:44.580 --> 12:48.740]  нужно, и мне это особо не потребуется, потому что,
[12:48.740 --> 12:53.500]  смотрите, у меня будет такое, как говорил Орл Дабл Финг,
[12:53.500 --> 12:58.060]  я буду, когда мне нужна свадимость, и когда я буду
[12:58.060 --> 12:59.460]  устроить свадимость, я буду считать, что у меня
[12:59.460 --> 13:00.460]  вот эта вот модель.
[13:00.460 --> 13:03.460]  А когда я описываю конкретный алгоритм, я буду не стесняясь
[13:03.460 --> 13:07.740]  его описывать на верхнем уровне и ссылаться на тезис
[13:07.740 --> 13:10.340]  Черча Тьюринга, что любой алгоритм можно реализовать
[13:10.340 --> 13:13.500]  на машине Тьюрина, не обсуждая деталей этой реализации.
[13:13.500 --> 13:15.780]  Ну, вам в курсе алгоритмов что-то про это говорили,
[13:15.780 --> 13:18.260]  мне уж точно на это не хочется тратить время, тем более,
[13:18.260 --> 13:20.580]  что это, ну так, почти что очевидно, конечно, это
[13:20.580 --> 13:23.140]  очень убогий получается язык программирования,
[13:23.140 --> 13:27.820]  один массив, но правда бесконечный, вот, и команды какие-то
[13:27.820 --> 13:32.740]  очень примитивные, которые противоречат парадигме
[13:32.740 --> 13:36.260]  современного программирования, сплошные ГоУ-2, ну, как бы
[13:36.260 --> 13:37.980]  изменение состояния, это в каком смысле аналог
[13:37.980 --> 13:41.020]  команды ГоУ-2, вы идете с одной строчки в другую
[13:41.020 --> 13:42.020]  строчку.
[13:42.020 --> 13:47.740]  Но, тем не менее, этого достаточно, и, в общем, объяснить, как
[13:47.740 --> 13:51.300]  все, так сказать, приемы программирования, которые
[13:51.300 --> 13:53.980]  нам нужны реализовать на машинах Тьюринга, можно,
[13:53.980 --> 13:56.380]  для этого лучше, конечно, обобщить модель, но я это
[13:56.380 --> 13:57.380]  все пропускаю.
[13:57.460 --> 14:00.180]  Считаю, что вам что-то про это объяснили, ну, а так
[14:00.180 --> 14:04.780]  вот можете поверить, если чего-то не объяснили, поверьте,
[14:04.780 --> 14:07.100]  что любой алгоритм, который я буду рассказывать, реализуется
[14:07.100 --> 14:08.100]  на машине Тьюринга.
[14:08.100 --> 14:15.020]  Ну, и какая задача будет связана с этой моделью?
[14:15.020 --> 14:17.700]  Ну, язык даже.
[14:17.700 --> 14:20.460]  Мне будет нужен такой язык.
[14:20.460 --> 14:24.820]  Множество описаний машины и ее входа таких, что m
[14:24.900 --> 14:26.220]  останавливается на x.
[14:26.220 --> 14:31.140]  Вообще говоря, машина не обязана останавливаться,
[14:31.140 --> 14:33.540]  она может никогда не переходить в множество финальных
[14:33.540 --> 14:34.540]  состояний.
[14:34.540 --> 14:38.620]  И вот нас интересуют такие пары, ну, точнее, опять-таки
[14:38.620 --> 14:39.620]  двоичные кодировки.
[14:39.620 --> 14:42.220]  Машина, как вы видите, это такой, конечно, комбинаторный
[14:42.220 --> 14:45.780]  объект, но там алфавит может быть сколь угодно большой,
[14:45.780 --> 14:48.260]  множество состояний может быть сколь угодно большим.
[14:48.260 --> 14:50.660]  То есть все это надо как-то закодировать.
[14:50.660 --> 14:54.740]  Детали кодировки я пропускаю, потому что мы уже обсуждали,
[14:54.740 --> 14:58.020]  как счетные множество кодировать.
[14:58.020 --> 15:02.140]  Ну, можно, например, перенумеровать алфавит, перенумеровать
[15:02.140 --> 15:04.500]  состояние, записывать соответствующие двоичные
[15:04.500 --> 15:07.740]  записи, там таблицу переходов, тоже там как договориться
[15:07.740 --> 15:09.260]  к каких-то разделителях.
[15:09.260 --> 15:11.620]  В общем, все эти детали, они не очень существенные,
[15:11.620 --> 15:13.540]  их можно делать по-разному, ничего от этих деталей не
[15:13.540 --> 15:14.540]  зависит.
[15:14.540 --> 15:17.100]  Так вот, что про этот язык известно?
[15:17.100 --> 15:19.340]  Я думаю, вам это доказывали.
[15:19.340 --> 15:20.980]  Значит, h перечислим.
[15:20.980 --> 15:26.780]  Но не разрешено.
[15:26.780 --> 15:37.300]  Перечислимость проще всего понять так, что мы должны
[15:37.300 --> 15:40.740]  уметь исполнять работу машины тюринга на каком-то
[15:40.740 --> 15:41.740]  входе.
[15:41.740 --> 15:46.060]  Видно, что у нас все очень конструктивно, то есть представить
[15:46.060 --> 15:48.780]  все алгоритмы, которые моделируют работу машины тюринга очень
[15:48.780 --> 15:49.780]  легко.
[15:49.780 --> 15:58.420]  Ну а тогда уже что, тогда можно использовать представление
[15:58.420 --> 16:01.100]  перечислимых ножек как проекции разрешимых, можно
[16:01.100 --> 16:03.860]  считать, что у нас проекция разрешима, это помимо описания
[16:03.860 --> 16:07.820]  машины, описания входа, еще указано время, количество
[16:07.820 --> 16:10.180]  тактов работы, за которые она останавливается.
[16:10.180 --> 16:12.900]  И тогда уже это разрешимо, потому что если вы указали
[16:12.900 --> 16:15.380]  временную границу, за эту временную границу вы можете
[16:15.380 --> 16:19.260]  сделать еще счетчик дополнительный, считать количество тактов
[16:19.260 --> 16:22.300]  и смотреть действительно останавливается или нет.
[16:22.300 --> 16:24.860]  Так что перечислимость легко, неразрешимость, там требуются
[16:24.860 --> 16:28.340]  вот некоторые хитрости, типа как я сказал, остановится
[16:28.340 --> 16:32.620]  ли машина тюринга до нового года, ну до нового года это
[16:32.620 --> 16:34.860]  уже с ограничениями на ресурсы, а тут вообще остановится
[16:34.860 --> 16:39.060]  или нет, если у нас бы такой алгоритм был, мы могли бы
[16:39.060 --> 16:40.060]  его обманывать.
[16:40.060 --> 16:43.500]  Я это пропускаю, для меня это будет отправная точка.
[16:43.500 --> 16:51.980]  От этого языка я буду строить сводимости, то есть он уже
[16:51.980 --> 16:56.380]  неразрешим, у меня есть вот эта схема, и я буду строить
[16:56.380 --> 16:57.380]  сводимости.
[16:57.380 --> 17:00.340]  Цель моя, ближайшая, это добраться до общезначимых
[17:00.340 --> 17:01.340]  формул.
[17:01.340 --> 17:08.060]  Но цель эта будет достигнута не сразу, у нас возникнет
[17:08.060 --> 17:11.020]  промежуточная неразрешимая задача, про которую я думаю
[17:11.020 --> 17:15.180]  вам в курсе алгоритмов не рассказывали, она связана
[17:15.180 --> 17:17.460]  с задачей достижимости в ориентированных графах.
[17:17.460 --> 17:22.060]  Ну вот вы должны осторожиться, потому что вас учили, я
[17:22.060 --> 17:26.100]  думаю, что задача достижимости в графе хорошо решается.
[17:26.100 --> 17:29.940]  Ну если у вас есть граф, надо проверить есть ли путь
[17:29.940 --> 17:33.460]  из одной вершины в другой, ну там обход в глубину, обход
[17:33.460 --> 17:36.340]  в ширину, куча всяких подробностей.
[17:36.340 --> 17:39.380]  Есть очень эффективные алгоритмы, которые делают
[17:39.380 --> 17:43.020]  на гигантских данных, можно решать задачу достижимости.
[17:43.020 --> 17:48.940]  Но, все это относится к случаю, когда графы конечные,
[17:48.940 --> 17:52.540]  а меня будет интересовать бесконечные графы, и все
[17:52.540 --> 17:54.860]  становится уже намного сложнее.
[17:54.860 --> 17:56.940]  Ну с бесконечными графами нужно, конечно, договориться
[17:56.940 --> 18:00.780]  как их задавать, но я просто хочу, чтобы я сейчас буду
[18:00.780 --> 18:03.580]  вводить некоторые понятия, чтобы вам было легче с
[18:03.580 --> 18:08.340]  ними сжиться, я буду их, вы должны понимать, что
[18:08.340 --> 18:10.980]  я просто определяю бесконечные графы, я про это еще скажу,
[18:10.980 --> 18:13.260]  когда дам определение.
[18:13.260 --> 18:16.820]  А технически это будет называться ассоциативные
[18:16.820 --> 18:28.540]  исчисления, но еще их называют полутуевские
[18:28.540 --> 18:29.540]  системы.
[18:29.540 --> 18:39.980]  Значит, туэ – это математик, почему полу, потому что
[18:39.980 --> 18:45.980]  потом появятся полные, они-то нам и нужны, но проще начать
[18:45.980 --> 18:46.980]  с этих.
[18:46.980 --> 18:51.940]  Значит, как они устроены?
[18:51.940 --> 18:56.060]  Такое исчисление задается алфавитом, опять-таки, и
[18:56.060 --> 18:57.060]  множеством правил.
[18:57.060 --> 19:01.780]  Значит, алфавит – это просто некоторое конечное множество,
[19:01.780 --> 19:03.580]  а правила имеют такой вид.
[19:03.580 --> 19:19.940]  Ну, какое-то конечное тоже множество, вот это вот множество
[19:19.940 --> 19:22.500]  – это и есть множество правил.
[19:22.500 --> 19:26.260]  Значит, а все левые и правые части, значит, правило устроено
[19:26.260 --> 19:30.340]  так, есть стрелка, есть левая часть и правая часть правила,
[19:31.340 --> 19:35.180]  и левая и правая части – это просто-напросто слова
[19:35.180 --> 19:36.180]  в алфавите Сима.
[19:36.180 --> 19:43.020]  Это как с машиной Тюринга, формальное определение
[19:43.020 --> 19:47.100]  ассоциативного исчисления закончено, если по эту часть
[19:47.100 --> 19:50.380]  определение машины Тюринга, но дальше я объяснял, как
[19:50.380 --> 19:52.380]  работает машина, потому что иначе не понятно, зачем
[19:52.380 --> 19:53.380]  такое определение.
[19:53.380 --> 19:57.100]  Здесь тоже надо объяснить, к чему все это дело.
[19:57.100 --> 20:00.460]  Правило, это на самом деле, если говорить более полно,
[20:00.460 --> 20:02.940]  это правило подстановки.
[20:02.940 --> 20:06.060]  Мы определяем отношения, с помощью системы правил
[20:06.060 --> 20:07.460]  мы определяем отношения.
[20:07.460 --> 20:14.060]  Из слова У можно получить слово В, если У можно представить
[20:14.060 --> 20:24.380]  в виде, ну там какой-то U-штрих, L и T, V-штрих, а В можно представить
[20:24.380 --> 20:28.780]  в виде U-штрих, R и T, V-штрих.
[20:28.780 --> 20:30.940]  То есть другими словами мы находим какое-то подслово
[20:30.940 --> 20:35.340]  в нашем слое, которое встречается в левой части правил, и после
[20:35.340 --> 20:38.180]  этого заменяем его на правую часть правила.
[20:38.180 --> 20:39.740]  Вот конкретно это вхождение подслова.
[20:39.740 --> 20:46.780]  В результате у нас получается, если посмотреть на это отношение,
[20:46.780 --> 20:51.580]  я фактически задал ориентированный граф на множество всех слов,
[20:51.580 --> 20:54.860]  потому что эта пара, она связана, то есть одно правило
[20:54.860 --> 20:58.380]  задает на самом деле сразу бесконечно много ребер.
[20:58.380 --> 21:00.980]  Вы можете навесить любой префикс, любой суффикс,
[21:00.980 --> 21:04.820]  он не меняется, и получается так, что правил конечный,
[21:04.820 --> 21:08.780]  то есть наш граф задан конечным описанием, тоже конструктивный
[21:08.780 --> 21:12.420]  объект, но он определяет вот такой граф на очень
[21:12.420 --> 21:15.500]  большое множество, на бесконечно большое множество слов.
[21:15.500 --> 21:19.020]  И с этим, конечно, связано то, что называется транзитивное
[21:19.020 --> 21:20.820]  замыкание отношения.
[21:20.820 --> 21:24.780]  Я не знаю, использовали ли вот назад такие слова
[21:24.780 --> 21:27.780]  вас в курсе дисклетной математики, но я сейчас объясню, что
[21:27.780 --> 21:28.780]  это значит.
[21:28.780 --> 21:29.780]  Это очень просто.
[21:29.780 --> 21:36.580]  Что слово В можно получить из слова У цепочкой таких
[21:36.580 --> 21:37.580]  замен.
[21:37.580 --> 21:45.940]  То есть существует ориентированный путь в графе.
[21:45.940 --> 21:48.180]  Вот то, что я говорил, задача достижимости.
[21:48.300 --> 21:51.100]  Мы начинаем с вершины У в этом нашем графе слов
[21:51.100 --> 21:53.900]  и хотим попасть в вершину В.
[21:53.900 --> 21:57.940]  Ну, наверное, стоит какой-то простой пример разобрать.
[21:57.940 --> 22:06.580]  Давайте считать, что у нас алфавит АВ.
[22:06.580 --> 22:10.900]  Какие-нибудь надо простые правила написать.
[22:10.900 --> 22:20.900]  Давайте так, АВ переходит в БАА, АББА переходит в БА.
[22:20.900 --> 22:21.900]  Что-нибудь вот такое.
[22:21.900 --> 22:24.580]  То есть длинные слова могут быть разными в левых и правых
[22:24.580 --> 22:25.580]  частях.
[22:25.580 --> 22:28.940]  В принципе, может одно из слов быть пустым, такое
[22:28.940 --> 22:29.940]  тоже возможно.
[22:29.940 --> 22:33.420]  Ну и вот, например, значит, что?
[22:33.420 --> 22:44.100]  Давайте посмотрим и убедимся, что из слова БАВ мы можем
[22:44.100 --> 22:54.900]  получить какое-нибудь другое слово БА.
[22:54.900 --> 22:57.460]  Вот смотрите, тут я написал цепочку, каждое соседнее
[22:57.460 --> 22:59.940]  связано одним из правил.
[22:59.940 --> 23:02.820]  Тут я применяю правила к этому подслову и заменяю
[23:02.980 --> 23:03.980]  его вот на это.
[23:03.980 --> 23:07.900]  А второй раз я уже применяю вот к этому подслову и заменяю
[23:07.900 --> 23:09.580]  его вот на это.
[23:09.580 --> 23:13.860]  Ну а сокращённо это можно вот как раз записать с помощью
[23:13.860 --> 23:17.700]  транзитивного замыкания, вот такая стрелочка со звёздочкой,
[23:17.700 --> 23:24.380]  что из БАВ мы можем попасть в БАА.
[23:24.380 --> 23:28.020]  Ну это простая комбинаторная модель, более общая, чем
[23:28.020 --> 23:31.140]  машина Тьюринга, на самом деле ей эквивалентная в
[23:31.140 --> 23:32.140]  некотором смысле.
[23:32.380 --> 23:34.180]  Сейчас я ей буду объяснять, почему.
[23:35.340 --> 23:40.260]  И она возникла до теории алгоритмов, в математике
[23:40.260 --> 23:43.380]  было нужно решать вот всякие такие вопросы.
[23:43.380 --> 23:46.380]  То есть вот когда система правил конкретная и нужно
[23:46.380 --> 23:49.140]  понять, можно ли преобразовать одно слово в другое.
[23:49.500 --> 23:51.860]  Собственно, теория алгоритма во многом возникла из нужд
[23:51.860 --> 23:54.140]  вот таких вот решения, таких задач.
[23:54.820 --> 23:57.180]  Для каких-то правил удавалось придумывать алгоритмы,
[23:57.180 --> 23:59.420]  для каких-то не очень удавалось придумывать алгоритмы.
[23:59.940 --> 24:04.060]  И в какой-то момент люди поняли, что может так
[24:04.060 --> 24:05.980]  случиться, что у него нет алгоритм.
[24:07.020 --> 24:10.980]  И это всё было до возникновения теории алгоритмов, потом
[24:10.980 --> 24:14.020]  это научились уже пересказывать в правильных словах.
[24:16.700 --> 24:18.860]  Ну нас, собственно, будет что интересовать?
[24:18.860 --> 24:20.660]  Нас будет интересовать такая задача.
[24:22.540 --> 24:25.540]  Давайте я где-нибудь, ну вот я сотру ту картинку,
[24:25.540 --> 24:30.620]  чтобы она вам заведомо знакома и вряд ли так уж она.
[24:30.620 --> 24:33.540]  Она нам, конечно, понадобится, но это будет чуть позже.
[24:35.260 --> 24:36.860]  Это будет чуть позже.
[24:42.180 --> 24:44.980]  Давайте рассмотрим такой язык.
[24:46.260 --> 24:48.780]  Множество описаний, опять-таки у меня ассоциативное
[24:48.780 --> 24:52.140]  числение, это конечное множество и конечный набор правил.
[24:52.540 --> 24:55.060]  Ну всё это можно закодировать двоичным образом.
[24:55.060 --> 25:02.140]  Можно алфавит, сигма, там, сопоставить ему какие-то числа правилом.
[25:02.140 --> 25:06.260]  Ну понятно, просто пары перечислять, вот, слов в алфавите, то есть
[25:06.260 --> 25:07.460]  последности этих чисел.
[25:07.860 --> 25:09.700]  Соответственно, значит, мне нужно что?
[25:12.780 --> 25:16.060]  Мне нужны вот такие четвёрки, то есть описание таких четвёрок.
[25:16.940 --> 25:22.420]  Описание алфавита, описание правил, целевое множество,
[25:22.660 --> 25:28.060]  целевое слово и финальное слово, и нам нужно, чтобы по правилам этого
[25:28.060 --> 25:30.540]  исчисления мы из У могли попасть в В.
[25:31.260 --> 25:33.300]  То есть такая общая задача достижимости.
[25:35.860 --> 25:39.620]  Не для одного конкретного исчисления, а вот само исчисление
[25:39.620 --> 25:41.500]  тоже подаётся на вход задачи.
[25:42.340 --> 25:44.740]  То есть правила исчисления тоже являются частью входа.
[25:46.460 --> 25:50.580]  И теорема, которую, собственно, я сейчас буду доказывать.
[25:53.220 --> 25:57.260]  Состоит в том, что проблема остановки
[25:58.220 --> 26:01.460]  M сводится вот к этой самой задаче достижимости.
[26:02.220 --> 26:05.180]  Ну и поскольку проблема остановки неразрешима,
[26:06.020 --> 26:08.180]  то, значит, это множество тоже неразрешимо.
[26:17.580 --> 26:20.260]  Ну и сводимость, понятно, как должна быть устроена.
[26:20.540 --> 26:21.980]  Значит, нам нужна функция,
[26:25.540 --> 26:28.980]  которая получает на вход описание машины и входа.
[26:30.740 --> 26:33.540]  И входа. Ну, какой-то X.
[26:38.620 --> 26:40.900]  И строит по нему вот
[26:40.900 --> 26:51.140]  описание ассоциативного исчисления и пары слов,
[26:52.660 --> 26:54.740]  достижимость которых мы хотим проверить.
[26:55.780 --> 26:59.940]  Причём условие должно быть такое, что если M останавливается на X,
[27:02.180 --> 27:04.580]  это равносильно тому, что
[27:11.900 --> 27:14.380]  слово V достижимое слово U.
[27:16.060 --> 27:19.740]  Вот, собственно, доказательство теоремы будет, естественно,
[27:19.740 --> 27:21.580]  в построении такой сводимости.
[27:23.700 --> 27:28.420]  Как это делать, значит? Ну, тут надо, я вынужден был стереть уже
[27:30.380 --> 27:35.060]  такт работы машины и тюринга, но вы уже с ними имели дело,
[27:35.060 --> 27:37.940]  поэтому и так мысленно, я думаю, легко представить.
[27:38.500 --> 27:43.300]  Машина тюринга может перемещаться только на ограниченное количество
[27:43.300 --> 27:44.980]  ячеек ленты, ну, на самом деле, на одну.
[27:46.300 --> 27:50.100]  Соответственно, менять состояние ленты она может вот локально только.
[27:51.900 --> 27:57.140]  И поскольку почти вся лента пустая,
[27:59.180 --> 28:00.260]  можно связать
[28:00.260 --> 28:05.260]  с работой машины и тюринга, вот каждый данный момент есть какое-то состояние,
[28:05.260 --> 28:06.740]  оно называется конфигурацией.
[28:06.740 --> 28:11.700]  Значит, я его запишу вот так, U и V – это слова в алфавите A,
[28:14.900 --> 28:16.660]  Q – это состояние.
[28:18.500 --> 28:24.740]  То есть конкатинация U и V – это вот не пустая часть ленты.
[28:24.740 --> 28:27.860]  Причём, на самом деле, у нас есть такое состояние,
[28:27.900 --> 28:31.100]  когда слово V может заканчиваться на какие-то пустые символы.
[28:31.100 --> 28:33.700]  Понятно, что мы их можем обрезать, потому что мы знаем,
[28:33.700 --> 28:35.540]  что дальше тоже идут пустые символы.
[28:35.540 --> 28:39.820]  Вот если у нас есть бесконечная цепочка пустых символов,
[28:39.820 --> 28:43.140]  ну, часть из них можем добавить в наше описание,
[28:43.140 --> 28:46.980]  в этом вроде бы нет никакого смысла, но мне будет удобнее так,
[28:46.980 --> 28:48.980]  в дальнейшем построение.
[28:48.980 --> 28:50.100]  Значит,
[28:50.340 --> 28:54.340]  и мы договариваемся, вот тут я всё-таки вынужден нарисовать картинку.
[29:00.340 --> 29:03.540]  Мы договариваемся, нам же ещё нужно положение головки задать.
[29:03.540 --> 29:07.540]  Вот положение головки – это первый символ вот этого слова.
[29:09.540 --> 29:12.340]  Оно может быть пустым, это будет означать, что просто
[29:12.340 --> 29:14.340]  у нас есть пустые символы.
[29:14.340 --> 29:18.340]  Ну, если у нас есть пустые символы, то у нас есть пустые символы,
[29:18.580 --> 29:20.580]  что может быть пустым, это будет означать,
[29:20.580 --> 29:24.580]  что просто головка смотрит на пустой символ,
[29:24.580 --> 29:26.580]  и дальше справа все символы пустые.
[29:26.580 --> 29:28.580]  Вот это вот,
[29:28.580 --> 29:30.580]  вот это вот В,
[29:30.580 --> 29:32.580]  а вот это вот О.
[29:32.580 --> 29:36.580]  То есть мы положением головки разбиваем нашу рабочую зону
[29:36.580 --> 29:38.580]  на два слова.
[29:38.580 --> 29:40.580]  То, что до головки, и то, что после головки.
[29:40.580 --> 29:42.580]  И пишем символ состояния,
[29:42.580 --> 29:44.580]  мне хочется, чтобы это было слово,
[29:44.580 --> 29:46.580]  то есть это слово в алфавите.
[29:48.580 --> 29:52.580]  Ку в объединении с А.
[29:56.580 --> 30:00.580]  И теперь я потом скажу про это подробнее,
[30:00.580 --> 30:02.580]  но теперь уже ясно, что такт работы
[30:02.580 --> 30:06.580]  он будет менять конфигурацию как-то локально.
[30:06.580 --> 30:12.580]  То есть, поскольку изменения касаются только вот этой вот части ленты,
[30:12.580 --> 30:16.580]  значит, головка может сдвинуться влево или вправо.
[30:16.820 --> 30:18.820]  Вот у нас есть три очейки ленты,
[30:18.820 --> 30:20.820]  над которыми может быть головка.
[30:20.820 --> 30:24.820]  Здесь символ может вообще измениться.
[30:24.820 --> 30:26.820]  Но ясно, что вот только про эту тройку
[30:26.820 --> 30:28.820]  имеет смысл думать,
[30:28.820 --> 30:30.820]  когда мы говорим об изменении конфигурации.
[30:30.820 --> 30:32.820]  А все остальное не меняется.
[30:32.820 --> 30:36.820]  И это очень напоминает правила ассоциативного исчисления.
[30:36.820 --> 30:38.820]  Потому что, смотрите, у нас здесь похожая ситуация.
[30:38.820 --> 30:40.820]  Не важно, что слева, не важно, что справа,
[30:40.820 --> 30:42.820]  вот оно только изменение.
[30:42.820 --> 30:44.820]  И эта идея для нас и будет основной.
[30:46.820 --> 30:52.820]  Значит, мы будем сейчас последовательно ее реализовывать.
[30:52.820 --> 30:54.820]  Для реализации на самом деле нам нужны
[30:54.820 --> 30:56.820]  некоторые технические подробности.
[31:04.820 --> 31:06.820]  Давайте, значит, вот я зафиксировал цель,
[31:06.820 --> 31:08.820]  которую я хочу достичь.
[31:08.820 --> 31:10.820]  Значит, у меня есть машина,
[31:10.820 --> 31:12.820]  я так и буду ее описывать.
[31:12.820 --> 31:14.820]  И вот мне надо объяснить,
[31:14.820 --> 31:16.820]  какое ассоциативное исчисление я сопоставляю.
[31:16.820 --> 31:18.820]  Ну, во-первых, какой алфавит?
[31:18.820 --> 31:24.820]  Алфавитом будет объединение AQ и еще особый символ,
[31:24.820 --> 31:26.820]  который я обозначу лям-да-ноль.
[31:26.820 --> 31:28.820]  Почему лям-да-ноль?
[31:28.820 --> 31:30.820]  Это будет такой дублер пустого символа.
[31:30.820 --> 31:32.820]  В каком смысле я скажу чуть позже.
[31:32.820 --> 31:34.820]  А в каком смысле я скажу чуть позже.
[31:34.820 --> 31:36.820]  В каком смысле я скажу чуть позже.
[31:36.820 --> 31:38.820]  В каком смысле я скажу чуть позже.
[31:38.820 --> 31:40.820]  Чуть позже.
[31:40.820 --> 31:42.820]  Значит, правила – это отдельная история,
[31:42.820 --> 31:44.820]  они довольно сложные.
[31:44.820 --> 31:46.820]  А вот слова я могу сразу сказать какие.
[31:46.820 --> 31:54.820]  Это начальное слово устроено вот так.
[32:00.820 --> 32:04.820]  А конечное слово – это просто два
[32:04.820 --> 32:06.820]  вот таких специальных пробельных символа.
[32:06.820 --> 32:10.820]  Давайте прочитаем, что написано в начальном слове.
[32:10.820 --> 32:12.820]  У нас есть окаемление из этих специальных пустых символов,
[32:12.820 --> 32:16.820]  а между ними написана начальная конфигурация машины.
[32:16.820 --> 32:22.820]  Мы помним, что машина в начале работы смотрит не на маркер конца,
[32:22.820 --> 32:24.820]  а на первый символ после маркера конца.
[32:24.820 --> 32:26.820]  Соответственно, вот так это и написано.
[32:26.820 --> 32:30.820]  Есть маркер конца, дальше есть какой-то вход,
[32:30.820 --> 32:34.820]  который у нас в условии задачи задан, x.
[32:34.820 --> 32:40.820]  И начальное состояние нужно записать перед словом x,
[32:40.820 --> 32:42.820]  потому что головка смотрит на первый символ входа.
[32:46.820 --> 32:48.820]  Теперь надо задать правила.
[32:48.820 --> 32:50.820]  И это длинная история.
[32:50.820 --> 32:54.820]  Прежде чем задавать правила, я хочу объяснить,
[32:54.820 --> 32:56.820]  что мне от этих правил нужно.
[32:56.820 --> 33:02.820]  Ведь цель моя в том, чтобы остановка машины на входе x
[33:02.820 --> 33:06.820]  равна сильной достижимости вот из этого слова вот этого.
[33:06.820 --> 33:10.820]  И мне для этого потребуется два множества.
[33:10.820 --> 33:14.820]  Слов одно устроено так.
[33:14.820 --> 33:20.820]  У и В у меня уже есть, поэтому давайте я как-нибудь...
[33:20.820 --> 33:24.820]  Ну пусть будет x, q, y,
[33:24.820 --> 33:31.820]  где q принадлежит алфавит, множество состояний, прошу прощения,
[33:31.820 --> 33:35.820]  а x, y это слова в алфавите.
[33:35.820 --> 33:38.820]  Я буду называть это множество...
[33:38.820 --> 33:41.820]  А, принадлежит состоянием, но не всем,
[33:41.820 --> 33:43.820]  а обязательно не финальным, прошу прощения.
[33:43.820 --> 33:46.820]  То есть это такое буду называть рабочее множество.
[33:46.820 --> 33:49.820]  То есть если вот на это посмотреть, то видно,
[33:49.820 --> 33:51.820]  что мы кодируем конфигурацию машины.
[33:51.820 --> 33:57.820]  То есть у нас есть какая-то непустая часть ленты.
[33:57.820 --> 34:01.820]  Над ним находится где-то головка.
[34:01.820 --> 34:04.820]  Символ состояния единственный в этом слое.
[34:04.820 --> 34:06.820]  Поэтому он однозначно указывает на место,
[34:06.820 --> 34:08.820]  где находится головка,
[34:08.820 --> 34:11.820]  а сам символ указывает какое состояние машины.
[34:11.820 --> 34:13.820]  То есть это вот такая кодировка.
[34:13.820 --> 34:17.820]  При этом вообще говоря, y может заканчиваться на пустые символы.
[34:17.820 --> 34:19.820]  Я это не запрещаю.
[34:19.820 --> 34:22.820]  То есть это не то чтобы однозначная кодировка.
[34:22.820 --> 34:27.820]  И мне будет нужно финальное состояние.
[34:29.820 --> 34:31.820]  В принципе, похоже.
[34:34.820 --> 34:36.820]  Финальное множество, прошу прощения,
[34:36.820 --> 34:40.820]  но тут Q уже принадлежит как раз множеству финальных состояний.
[34:44.820 --> 34:46.820]  Это далеко не все слова.
[34:46.820 --> 34:50.820]  Но мне для сводимости проблемы остановки машины и тюрьмы
[34:50.820 --> 34:52.820]  нужны будут только эти слова.
[34:52.820 --> 34:54.820]  Никакие другие я использовать не буду.
[34:58.820 --> 35:04.820]  Какие свойства требуются от правил?
[35:04.820 --> 35:06.820]  Правила я пока не задал.
[35:06.820 --> 35:09.820]  Я сейчас сформулирую, какие свойства в терминах этих множеств
[35:09.820 --> 35:11.820]  должны быть выполнены.
[35:11.820 --> 35:14.820]  Если у нас есть слово, которое принадлежит
[35:14.820 --> 35:16.820]  рабочему множеству,
[35:18.820 --> 35:20.820]  то применимо ровно одно правило.
[35:30.820 --> 35:34.820]  И получается какое-то слово w штрих.
[35:34.820 --> 35:40.820]  И w штрих принадлежит либо рабочему, либо финальному множеству.
[35:40.820 --> 35:44.820]  То есть w штрих тоже является конфигурацией машины.
[35:44.820 --> 35:49.820]  Причем эта конфигурация и w штрих кодируют
[35:49.820 --> 35:54.820]  эта конфигурация машины на следующем такте.
[36:00.820 --> 36:02.820]  То есть вот это первое свойство говорит нам вот про что.
[36:02.820 --> 36:06.820]  Что если у нас есть какое-то слово, которое мы воспользуемся
[36:06.820 --> 36:10.820]  как запись конфигурации машины, то правила
[36:10.820 --> 36:14.820]  нашего исчисления можно применить ровно одно правило.
[36:14.820 --> 36:18.820]  И после его примения я получу конфигурацию на следующем такте.
[36:18.820 --> 36:21.820]  То есть после выполнения этого такта работа.
[36:21.820 --> 36:24.820]  Этому обязательно нужно достичь.
[36:24.820 --> 36:27.820]  И второе, что мне нужно.
[36:27.820 --> 36:29.820]  Мне нужно вот что.
[36:29.820 --> 36:32.820]  Что если слово принадлежит финальной части,
[36:32.820 --> 36:36.820]  то тогда из этого слова достижимо.
[36:36.820 --> 36:41.820]  Ну вот это вот целевое слово лямбда 0, лямбда 0.
[36:45.820 --> 36:49.820]  Я утверждаю, что если я напишу набор правил,
[36:49.820 --> 36:54.820]  для которых выполняются эти свойства, то тогда
[36:54.820 --> 36:57.820]  я построил корректную сводимость.
[36:57.820 --> 37:01.820]  Ну, если, конечно, все это строится алгоритм.
[37:04.820 --> 37:07.820]  Давайте, определение пока не буду стирать.
[37:07.820 --> 37:09.820]  Как это доказать?
[37:09.820 --> 37:13.820]  Ну, смотрите, вот у нас есть начальное слово у.
[37:13.820 --> 37:16.820]  Мы применяем наши правила.
[37:16.820 --> 37:20.820]  И у нас есть начальное слово у.
[37:21.820 --> 37:24.820]  Мы применяем наши правила.
[37:24.820 --> 37:26.820]  Получаем какое-то еще.
[37:26.820 --> 37:29.820]  Слово еще, слово и так далее.
[37:29.820 --> 37:35.820]  Значит, пока у принадлежит рабочему множеству.
[37:35.820 --> 37:37.820]  По строению.
[37:40.820 --> 37:42.820]  Если мы применяем правила
[37:42.820 --> 37:45.820]  и никогда не попадаем в финальное множество,
[37:45.820 --> 37:46.820]  то что это означает?
[37:46.820 --> 37:48.820]  Это означает, что машина не останавливается.
[37:48.820 --> 37:50.820]  Потому что она останавливается,
[37:50.820 --> 37:52.820]  когда мы попадаем в финальное состояние.
[37:52.820 --> 37:55.820]  Значит, тогда у нас получается,
[37:55.820 --> 37:58.820]  в нашем графе есть путь,
[37:58.820 --> 38:01.820]  такой бесконечный путь, начинающийся с у.
[38:01.820 --> 38:04.820]  Но v, оно-то принадлежит финального множества.
[38:04.820 --> 38:06.820]  Оно никак в этом пути быть не может.
[38:06.820 --> 38:09.820]  То есть, если машина не останавливается,
[38:09.820 --> 38:12.820]  из u в v мы достичь несостояния.
[38:12.820 --> 38:15.820]  Потому что у нас последовательность ходов из u
[38:15.820 --> 38:17.820]  она однозначно определена.
[38:17.820 --> 38:19.820]  И если машина не останавливается, то все.
[38:19.820 --> 38:22.820]  А с другой стороны, это первый случай.
[38:22.820 --> 38:25.820]  А с другой стороны, если машина останавливается,
[38:25.820 --> 38:29.820]  то у нас возникает такая же цепочка.
[38:29.820 --> 38:33.820]  Но в какой-то момент
[38:33.820 --> 38:37.820]  мы попадаем в финальное множество.
[38:37.820 --> 38:39.820]  Какое-то слово в наших преобразованиях
[38:39.820 --> 38:41.820]  окажется в финальном множестве.
[38:41.820 --> 38:43.820]  Что значит, что машина останавливается?
[38:43.820 --> 38:47.820]  Наши же замены дают кодировки конфигурации,
[38:47.820 --> 38:50.820]  ну не кодировки, а просто конфигурации,
[38:50.820 --> 38:53.820]  на следующем такте работы.
[39:03.820 --> 39:06.820]  Если машина останавливается, мы рано или поздно
[39:06.820 --> 39:10.820]  достигнем конфигурации, в которой состояние финальное.
[39:10.820 --> 39:13.820]  Ну и в этот момент мы используем второе свойство.
[39:13.820 --> 39:15.820]  Вот у нас есть где-то множество лямда 0, лямда 0.
[39:15.820 --> 39:21.820]  Мы можем достичь из этого финального слова
[39:21.820 --> 39:25.820]  достичь особое финальное слово.
[39:25.820 --> 39:28.820]  Вот, собственно, это доказательство корректности.
[39:28.820 --> 39:32.820]  Но нужно вот этим двум свойствам удовлетворить.
[39:32.820 --> 39:37.820]  Это не то чтобы очень сложно, но требует определенных усилий.
[39:38.820 --> 39:41.820]  Значит, сейчас уже будет перерыв, поэтому, наверное,
[39:41.820 --> 39:44.820]  нет смысла начинать выписывать эти правила,
[39:44.820 --> 39:47.820]  потому что их все-таки немало.
[39:49.820 --> 39:53.820]  Давайте еще раз, пока еще есть там немножко времени,
[39:53.820 --> 39:55.820]  посмотрим на саму структуру доказательств.
[39:55.820 --> 39:58.820]  Итак, мы строим свадимость. У нас есть машина,
[39:58.820 --> 40:01.820]  и мы строим вот такое вот исчисление,
[40:01.820 --> 40:03.820]  которое удовлетворяет таким правилам.
[40:03.820 --> 40:09.820]  Альфавит я задал, начальное слово задал, целевое слово задал,
[40:09.820 --> 40:13.820]  и нужно, чтобы выполнялись правила удовлетворения вот этим вот условиям.
[40:13.820 --> 40:15.820]  Тогда это будет корректная свадимость.
[40:15.820 --> 40:20.820]  За одним нюансом, который я почти что сознательно упустил,
[40:20.820 --> 40:23.820]  но вот в перерыве может быть кто-нибудь додумается,
[40:23.820 --> 40:25.820]  про что я не сказал.
[40:27.820 --> 40:29.820]  Сейчас перерыв.
[40:30.820 --> 40:35.820]  Важно мне сказать, что все-таки алфавит и состояние различаются.
[40:35.820 --> 40:38.820]  То есть мы должны по символу уметь понимать,
[40:38.820 --> 40:41.820]  это символ алфавита или символ состояния.
[40:42.820 --> 40:46.820]  Ну, формально, когда мы определяем работу машины,
[40:46.820 --> 40:48.820]  это даже не очень важно,
[40:48.820 --> 40:51.820]  потому что у нас там в функции переходов есть две координаты,
[40:51.820 --> 40:54.820]  но мне для свадимости это, конечно, нужно,
[40:54.820 --> 40:58.820]  потому что это я перемешиваю их, и, конечно, нужно.
[40:58.820 --> 41:00.820]  Спасибо, я забыл про это сказать.
[41:14.820 --> 41:16.820]  Правила будут делиться на две группы.
[41:16.820 --> 41:18.820]  Первая для нефинальных состояний,
[41:18.820 --> 41:19.820]  вторая для финальных.
[41:19.820 --> 41:22.820]  Давайте начнем для нефинальных состояний.
[41:23.820 --> 41:30.820]  Пусть у нас есть строчка в таблице переходов A, Q,
[41:30.820 --> 41:32.820]  но там куда-то.
[41:32.820 --> 41:36.820]  Значит, A штрих, Q штрих.
[41:36.820 --> 41:38.820]  Давайте ноль.
[41:38.820 --> 41:41.820]  Значит, с командой движения нужно будет по-разному разбирать.
[41:41.820 --> 41:43.820]  Вот есть такая строчка.
[41:43.820 --> 41:46.820]  Тогда ей сопоставляется такое правило.
[41:47.820 --> 41:50.820]  Значит, мы смотрим на A,
[41:50.820 --> 41:55.820]  и должны заменить состояние,
[41:55.820 --> 41:56.820]  должны заменить символ,
[41:56.820 --> 41:58.820]  но мы никуда не двигаемся.
[41:59.820 --> 42:07.820]  Это если A не пустой символ.
[42:08.820 --> 42:11.820]  Извините, не специальный пустой символ.
[42:11.820 --> 42:14.820]  Давайте я сразу оговорюсь где-нибудь,
[42:14.820 --> 42:18.820]  вот здесь он появился,
[42:18.820 --> 42:20.820]  тогда придется вот здесь написать.
[42:20.820 --> 42:22.820]  Как я уже говорил,
[42:27.820 --> 42:30.820]  вот этот специальный пустой символ
[42:30.820 --> 42:32.820]  для нас ведет себя так же,
[42:32.820 --> 42:34.820]  как обычный пустой символ.
[42:34.820 --> 42:36.820]  Поэтому таблицу переходов я продолжу.
[42:40.820 --> 42:42.820]  Таблица переходов на специальном пустом символе
[42:42.820 --> 42:44.820]  такая же, как и на обычном пустом символе.
[42:44.820 --> 42:47.820]  Поэтому мне нужно два правила.
[42:47.820 --> 42:57.820]  Если символ все-таки мы смотрим на пустой символ,
[42:57.820 --> 42:58.820]  это возможно,
[42:58.820 --> 43:02.820]  тогда мне нужно дописать A штрих,
[43:02.820 --> 43:05.820]  и только после этого лямбда ноль.
[43:05.820 --> 43:07.820]  Это если A пустой символ.
[43:07.820 --> 43:09.820]  Я сейчас буду выписывать правила,
[43:09.820 --> 43:10.820]  потом мы еще обсудим,
[43:10.820 --> 43:12.820]  почему выполняются эти свойства,
[43:12.820 --> 43:14.820]  но удобнее, наверное, все-таки выписать
[43:14.820 --> 43:15.820]  вначале все правила,
[43:15.820 --> 43:19.820]  иначе обсуждать каждый из правил,
[43:19.820 --> 43:22.820]  мне кажется, хуже.
[43:22.820 --> 43:24.820]  Значит, давайте смотреть,
[43:24.820 --> 43:27.820]  что будет, если движение вправо.
[43:28.820 --> 43:34.820]  Тогда, опять-таки, вот у нас есть QA,
[43:34.820 --> 43:36.820]  мы его заменили на A штрих
[43:36.820 --> 43:38.820]  и сдвинулись вправо.
[43:40.820 --> 43:44.820]  Это, опять-таки, если A не специальный пустой символ.
[43:44.820 --> 43:48.820]  А если A специальный пустой символ,
[43:48.820 --> 43:52.820]  то нам нужно вот такое правило,
[43:52.820 --> 43:55.820]  A штрих Q, ну и, опять-таки,
[43:55.820 --> 43:58.820]  вот этот специальный пустой символ.
[43:59.820 --> 44:00.820]  Ну и, наконец-то,
[44:00.820 --> 44:01.820]  движение влево.
[44:10.820 --> 44:13.820]  Видите, правила немножко различаются,
[44:15.820 --> 44:16.820]  поэтому их нужно выписывать
[44:16.820 --> 44:18.820]  каждое по отдельности.
[44:18.820 --> 44:20.820]  Значит, теперь у нас есть...
[44:23.820 --> 44:26.820]  уже нам нужно смотреть на контеку,
[44:27.820 --> 44:30.820]  уже нам нужно смотреть на контекст
[44:31.820 --> 44:33.820]  с обоих сторон,
[44:33.820 --> 44:35.820]  и слева и справа.
[44:35.820 --> 44:39.820]  И типичная замена состоит в том,
[44:39.820 --> 44:42.820]  что мы перемещаемся
[44:47.820 --> 44:51.820]  влево, заменяя символ.
[44:52.820 --> 44:54.820]  Так, а...
[44:56.820 --> 44:58.820]  Да, это если, опять-таки,
[44:58.820 --> 45:00.820]  A не пустой символ.
[45:01.820 --> 45:05.820]  И, наконец, если A пустой символ,
[45:06.820 --> 45:08.820]  мы также перемещаемся,
[45:08.820 --> 45:10.820]  но теперь нам нужно
[45:10.820 --> 45:13.820]  дописать вот этот вот символ A штрих.
[45:16.820 --> 45:18.820]  В значениях функции перехода
[45:18.820 --> 45:19.820]  в лямбда 0 нет.
[45:19.820 --> 45:21.820]  Там, если значение пустой символ,
[45:21.820 --> 45:23.820]  мы так пустой символы оставляем.
[45:27.820 --> 45:30.820]  Ну, это все я написал правила
[45:30.820 --> 45:33.820]  для не финальных состояний,
[45:33.820 --> 45:35.820]  правила для финальных состояний,
[45:35.820 --> 45:36.820]  они намного проще.
[45:36.820 --> 45:39.820]  Значит, если у нас есть Q,
[45:39.820 --> 45:41.820]  вот Q принадлежит финальному состоянию,
[45:41.820 --> 45:43.820]  и оно видит какой-то символ,
[45:43.820 --> 45:45.820]  ну, этот символ стирает.
[45:45.820 --> 45:49.820]  Ну, единственное, что A не равно,
[45:49.820 --> 45:51.820]  опять-таки, вот этому вот
[45:51.820 --> 45:53.820]  специальному пустому символу.
[45:54.820 --> 45:57.820]  А если символ он видит слева,
[45:57.820 --> 45:59.820]  то он его тоже стирает.
[45:59.820 --> 46:01.820]  Ну, может стереть.
[46:01.820 --> 46:04.820]  Тут уже однозначности у нас не будет.
[46:04.820 --> 46:06.820]  Ну, и, наконец,
[46:07.820 --> 46:09.820]  еще одно правило, чтобы
[46:09.820 --> 46:11.820]  достичь того, чего мы хотим,
[46:11.820 --> 46:13.820]  это вот такое.
[46:15.820 --> 46:17.820]  Если уже и слева, и справа
[46:17.820 --> 46:19.820]  он видит только специальные пустые символы,
[46:19.820 --> 46:21.820]  он себя убивает,
[46:21.820 --> 46:24.820]  остается вот ровно то слово, которое нам нужно.
[46:24.820 --> 46:25.820]  Вот такой набор правил.
[46:25.820 --> 46:27.820]  Теперь мне нужно доказать,
[46:27.820 --> 46:29.820]  что для него выполняются вот эти вот два свойства.
[46:29.820 --> 46:31.820]  Ну, доказательства, естественно,
[46:31.820 --> 46:34.820]  индукции по числу подстановок.
[46:35.820 --> 46:37.820]  Предположим, что мы находимся
[46:37.820 --> 46:39.820]  в каком-то рабочем,
[46:39.820 --> 46:41.820]  каком-то слове из рабочего множества,
[46:41.820 --> 46:43.820]  то есть у нас есть кодировка,
[46:43.820 --> 46:45.820]  ну, не кодировка, конфигурация,
[46:45.820 --> 46:47.820]  ну, кодировка, потому что еще лямда 0, лямда 0 есть,
[46:47.820 --> 46:49.820]  конфигурация машины.
[46:49.820 --> 46:52.820]  Значит, и мы применяем правила.
[46:52.820 --> 46:54.820]  Во-первых, почему правило может быть применено
[46:54.820 --> 46:56.820]  только одно? Посмотрите, у нас
[46:56.820 --> 46:58.820]  применение правила
[46:58.820 --> 47:00.820]  включает в себя символ состояния.
[47:00.820 --> 47:02.820]  Он единственный.
[47:02.820 --> 47:05.820]  И видно, что
[47:05.820 --> 47:08.820]  если мы посмотрим на символ справа,
[47:09.820 --> 47:11.820]  то у нас однозначно определена пара
[47:11.820 --> 47:13.820]  для таблиц переходов.
[47:13.820 --> 47:15.820]  Какое состояние, какой символ.
[47:15.820 --> 47:17.820]  И для каждой такой пары у нас есть
[47:17.820 --> 47:19.820]  строчка.
[47:19.820 --> 47:21.820]  Значит, когда мы ее применяем,
[47:23.820 --> 47:25.820]  вот давайте смотреть здесь,
[47:25.820 --> 47:27.820]  у нас никто никуда не сдвинулся,
[47:27.820 --> 47:29.820]  головка находится над тем же символом,
[47:29.820 --> 47:31.820]  состояние изменилось,
[47:31.820 --> 47:33.820]  символ изменился.
[47:33.820 --> 47:35.820]  Ну, то есть все корректно преобразовалось.
[47:35.820 --> 47:37.820]  Если мы смотрим на специальный пустой символ,
[47:37.820 --> 47:39.820]  я хочу поддерживать вот этот вариант,
[47:39.820 --> 47:41.820]  что конфигурация океймлена
[47:41.820 --> 47:43.820]  специальными пустыми символами.
[47:43.820 --> 47:45.820]  Ну, тогда мы не можем просто взять
[47:45.820 --> 47:47.820]  и заменить на какой-то аш-трих,
[47:47.820 --> 47:49.820]  у нас пропадет специальный пустой символ.
[47:49.820 --> 47:51.820]  Мы делаем очень просто,
[47:51.820 --> 47:53.820]  мы вставляем сюда
[47:53.820 --> 47:55.820]  специальный символ. Именно поэтому мне удобно
[47:55.820 --> 47:57.820]  допускать
[47:57.820 --> 47:59.820]  в рабочих словах, чтобы там
[47:59.820 --> 48:01.820]  были какие-то еще пустые символы,
[48:01.820 --> 48:03.820]  не обрезать максимально коротко,
[48:03.820 --> 48:05.820]  ну, иметь какую-то свободу,
[48:05.820 --> 48:07.820]  потому что правила не знают,
[48:07.820 --> 48:09.820]  что там дальше будет.
[48:09.820 --> 48:11.820]  Теперь, когда сдвигаемся вправо,
[48:11.820 --> 48:13.820]  ну, тут все то же самое, смотрите,
[48:13.820 --> 48:15.820]  с этим символом, и команда движения вправо,
[48:15.820 --> 48:17.820]  значит, этот символ у нас останется
[48:17.820 --> 48:19.820]  теперь слева
[48:19.820 --> 48:21.820]  от символа состояния. Ну, вот оно так
[48:21.820 --> 48:23.820]  заменяется. Это не работает,
[48:23.820 --> 48:25.820]  если мы нарвались
[48:25.820 --> 48:27.820]  на специальный пустой символ,
[48:27.820 --> 48:29.820]  потому что мы хотим, чтобы
[48:29.820 --> 48:31.820]  все океймлялось
[48:31.820 --> 48:33.820]  вот этими специальными пустыми символами.
[48:33.820 --> 48:35.820]  Мы хотим, чтобы
[48:35.820 --> 48:37.820]  вправо от него мы не уходили. Ну,
[48:37.820 --> 48:39.820]  так вот мы и делаем. Мы делаем такую же
[48:39.820 --> 48:41.820]  замену, но только
[48:41.820 --> 48:43.820]  записываем еще этот специальный пустой символ,
[48:45.820 --> 48:47.820]  который
[48:49.820 --> 48:51.820]  фиксирует край
[48:51.820 --> 48:53.820]  нашей рабочей зоны. Ну, и наконец,
[48:53.820 --> 48:55.820]  когда движение влево, все то же самое.
[48:55.820 --> 48:57.820]  В типичном случае
[48:57.820 --> 48:59.820]  мы меняем символ
[48:59.820 --> 49:01.820]  вот этот, но поскольку мы сдвинулись
[49:01.820 --> 49:03.820]  влево, нам нужно еще смотреть
[49:03.820 --> 49:05.820]  вот на этот символ, и мы оказываемся
[49:05.820 --> 49:07.820]  слева от него.
[49:07.820 --> 49:09.820]  Тут, конечно, вы
[49:09.820 --> 49:11.820]  можете спросить. У меня был
[49:11.820 --> 49:13.820]  еще слева
[49:13.820 --> 49:15.820]  океймление. Зачем оно нужно?
[49:15.820 --> 49:17.820]  Вот так вроде бы выясняется,
[49:17.820 --> 49:19.820]  что не очень нужно, но так удобнее.
[49:19.820 --> 49:21.820]  Потому что нам потом надо
[49:21.820 --> 49:23.820]  стирать. Можно было бы использовать
[49:23.820 --> 49:25.820]  маркер конца, но тогда
[49:25.820 --> 49:27.820]  нужно было бы как-то это рабочее множество
[49:27.820 --> 49:29.820]  сильно пересказывать, потому что на маркер конца
[49:29.820 --> 49:31.820]  головка может выходить, и тогда
[49:31.820 --> 49:33.820]  получается, что символ состояния
[49:33.820 --> 49:35.820]  окажется слева. Мне удобнее считать,
[49:35.820 --> 49:37.820]  что у меня есть символ, вот этот специальный
[49:37.820 --> 49:39.820]  пустой, который и маркер конца тоже
[49:39.820 --> 49:41.820]  ограничивает. Но в результате
[49:41.820 --> 49:43.820]  B
[49:43.820 --> 49:45.820]  для тех машин,
[49:45.820 --> 49:47.820]  которые я определил никогда,
[49:47.820 --> 49:49.820]  не может равняться специальному пустому символу.
[49:49.820 --> 49:51.820]  Почему? Потому что если
[49:51.820 --> 49:53.820]  мы видим вот такую
[49:53.820 --> 49:55.820]  конфигурацию,
[49:55.820 --> 49:57.820]  ну там что-то,
[49:57.820 --> 49:59.820]  то есть вот головка вышла
[49:59.820 --> 50:01.820]  на маркер конца, мы знаем,
[50:01.820 --> 50:03.820]  по нашим правилам, машина
[50:03.820 --> 50:05.820]  в такой ситуации
[50:05.820 --> 50:07.820]  будет делать ход обязательно вправо,
[50:07.820 --> 50:09.820]  то есть с маркера конца она уходит
[50:09.820 --> 50:11.820]  обязательно вправо,
[50:11.820 --> 50:13.820]  а это все только командам движения
[50:13.820 --> 50:15.820]  влево, значит это просто
[50:15.820 --> 50:17.820]  неприменимо. Таким образом первое свойство
[50:17.820 --> 50:19.820]  мы проверили, и все однозначно,
[50:19.820 --> 50:21.820]  то есть мы к данному
[50:21.820 --> 50:23.820]  рабочему слову, если слово
[50:23.820 --> 50:25.820]  не принадлежит рабочему множеству, конечно
[50:25.820 --> 50:27.820]  правил может быть применено несколько, например
[50:27.820 --> 50:29.820]  несколько символов состояния,
[50:29.820 --> 50:31.820]  и возле каждого мы можем применить правила.
[50:31.820 --> 50:33.820]  Но это нас абсолютно не волнует.
[50:33.820 --> 50:35.820]  Но ведь нужно только свадимость построить.
[50:35.820 --> 50:37.820]  Это исчисление больше ни для чего не нужно.
[50:39.820 --> 50:41.820]  Ну и наконец второе свойство, оно
[50:41.820 --> 50:43.820]  обеспечивается вот этим, потому что, смотрите,
[50:43.820 --> 50:45.820]  вот мы получили какое-то финальное
[50:45.820 --> 50:47.820]  слово, оно имеет вот такой вид.
[50:47.820 --> 50:49.820]  Х и у принадлежат
[50:49.820 --> 50:51.820]  А.
[50:51.820 --> 50:53.820]  Ну, тогда мы можем применять
[50:53.820 --> 50:55.820]  вот эти вот два правила
[50:55.820 --> 50:57.820]  и сокращать х и у,
[50:57.820 --> 50:59.820]  то есть вычеркивать по очереди символы.
[50:59.820 --> 51:01.820]  В у
[51:01.820 --> 51:03.820]  самый левый, в х самый правый,
[51:03.820 --> 51:05.820]  длины их будут уменьшаться,
[51:05.820 --> 51:07.820]  в какой-то момент они станут пустыми оба.
[51:07.820 --> 51:09.820]  После этого мы получаем
[51:09.820 --> 51:11.820]  вот такое как раз слово
[51:11.820 --> 51:13.820]  и нам
[51:13.820 --> 51:15.820]  нужно достичь лямда 0,
[51:15.820 --> 51:17.820]  лямда 0, вот мы его и достигаем с помощью этого
[51:17.820 --> 51:19.820]  правила. Таким образом
[51:19.820 --> 51:21.820]  мы проверили,
[51:21.820 --> 51:23.820]  что
[51:23.820 --> 51:25.820]  вот такие правила гарантируют
[51:25.820 --> 51:27.820]  выполнение этих двух свойств, а эти два свойства
[51:27.820 --> 51:29.820]  вот тут вот описаны доказательства корректности
[51:29.820 --> 51:31.820]  свадимости.
[51:33.820 --> 51:35.820]  Ну хорошо, самое время вернуться
[51:35.820 --> 51:37.820]  к тому, про что я предупредил
[51:37.820 --> 51:39.820]  перед перерывом, а во всем этом
[51:39.820 --> 51:41.820]  рассказе, в этом доказательстве
[51:41.820 --> 51:43.820]  свадимости есть пробел.
[51:43.820 --> 51:45.820]  В чем он состоит?
[51:59.820 --> 52:01.820]  Ну вот в чем состоит.
[52:01.820 --> 52:03.820]  Я напомню, что сводящая функция
[52:03.820 --> 52:05.820]  должна быть тотальной.
[52:05.820 --> 52:07.820]  То есть
[52:07.820 --> 52:09.820]  у нас не любое
[52:09.820 --> 52:11.820]  двоичное слово является описанием машины
[52:11.820 --> 52:13.820]  тюринга или входа.
[52:13.820 --> 52:15.820]  Конечно, могли бы озаботиться
[52:15.820 --> 52:17.820]  тем, чтобы любое двоичное слово
[52:17.820 --> 52:19.820]  кодировало какую-то машину тюринга и входа,
[52:19.820 --> 52:21.820]  но мы этого не сделали.
[52:21.820 --> 52:23.820]  Значит, могут быть слова,
[52:23.820 --> 52:25.820]  которые не являются
[52:25.820 --> 52:27.820]  кодировками машины тюринга и входа,
[52:27.820 --> 52:29.820]  кодировками машины тюринга и входа.
[52:29.820 --> 52:31.820]  И с ними тоже что-то нужно сделать.
[52:31.820 --> 52:33.820]  Свадящая функция что-то должна
[52:33.820 --> 52:35.820]  на них вычислять.
[52:35.820 --> 52:37.820]  При этом, что можно считать?
[52:37.820 --> 52:39.820]  Что кодировка эффективна.
[52:39.820 --> 52:41.820]  В том смысле, что глядя на слово,
[52:41.820 --> 52:43.820]  вы можете сказать, является она кодировкой машины и входа
[52:43.820 --> 52:45.820]  или не является.
[52:45.820 --> 52:47.820]  То, что я обсуждал намеками, как устроена кодировка,
[52:47.820 --> 52:49.820]  ясно, что есть алгоритм, который проверяет
[52:49.820 --> 52:51.820]  по слову, что действительно это корректная
[52:51.820 --> 52:53.820]  кодировка какой-то машины.
[52:53.820 --> 52:55.820]  Там нужно разные вещи проверять,
[52:55.820 --> 52:57.820]  потому что у нас есть
[52:57.820 --> 52:59.820]  ограничения на функцию переходов,
[52:59.820 --> 53:01.820]  и что она тотальная,
[53:01.820 --> 53:03.820]  и что там выполняются вот эти условия
[53:03.820 --> 53:05.820]  на маркере конца.
[53:05.820 --> 53:07.820]  Но это все делается, естественно, алгоритмически,
[53:07.820 --> 53:09.820]  и тем самым по тезису
[53:09.820 --> 53:11.820]  черча тюринга делается и на машине тюринга.
[53:11.820 --> 53:13.820]  Но тем не менее, нужно
[53:13.820 --> 53:15.820]  что-то сказать.
[53:15.820 --> 53:17.820]  Вот в этой свадимости нам не хватает,
[53:17.820 --> 53:19.820]  допустим, слова W
[53:19.820 --> 53:21.820]  не принадлежит
[53:21.820 --> 53:23.820]  множеству слов, которые являются
[53:23.820 --> 53:25.820]  описаниями машины тюринга и входа.
[53:25.820 --> 53:27.820]  Наша функция должна
[53:27.820 --> 53:29.820]  что-то с этим словом сделать.
[53:29.820 --> 53:31.820]  Давайте подумаем, что она
[53:31.820 --> 53:33.820]  должна сделать, чтобы свадимость была корректной.
[53:35.820 --> 53:37.820]  Нам нужна вот такая равносильность.
[53:37.820 --> 53:39.820]  То есть, если
[53:39.820 --> 53:41.820]  вход
[53:41.820 --> 53:43.820]  описывает
[53:43.820 --> 53:45.820]  машину тюринга и слово,
[53:45.820 --> 53:47.820]  на котором она останавливается,
[53:47.820 --> 53:49.820]  мы должны попасть
[53:49.820 --> 53:51.820]  в вычисления,
[53:51.820 --> 53:53.820]  где из начального слова
[53:53.820 --> 53:55.820]  достижимо конечное.
[53:55.820 --> 53:57.820]  А если нет,
[53:57.820 --> 53:59.820]  то должны попасть в вычисления,
[53:59.820 --> 54:01.820]  в которые конечное слово
[54:01.820 --> 54:03.820]  недостижимо изначально.
[54:03.820 --> 54:05.820]  Но тут вообще нет, конечно,
[54:05.820 --> 54:07.820]  ответа, потому что это даже не машина тюринга.
[54:07.820 --> 54:09.820]  Поэтому останавливается ли
[54:09.820 --> 54:11.820]  машина тюринга, если ее нет?
[54:11.820 --> 54:13.820]  Ну, она не останавливается.
[54:13.820 --> 54:15.820]  Нам нужно отправить
[54:15.820 --> 54:17.820]  это слово в какой-то конкретный
[54:17.820 --> 54:19.820]  вариант
[54:19.820 --> 54:21.820]  задачи достижимости,
[54:21.820 --> 54:23.820]  где
[54:35.820 --> 54:37.820]  ответ заведомо отрицать.
[54:37.820 --> 54:39.820]  Ну, скажем такое, алфавит из одного нуля,
[54:39.820 --> 54:41.820]  правил вообще нет,
[54:41.820 --> 54:43.820]  начальное слово ноль,
[54:43.820 --> 54:45.820]  конечное слово два нуля.
[54:45.820 --> 54:47.820]  Ну, поскольку правил вообще нет,
[54:47.820 --> 54:49.820]  граф состоит только из изолированных вершин.
[54:49.820 --> 54:51.820]  Если слова разные,
[54:51.820 --> 54:53.820]  то ни одно недостижимо из другого.
[54:53.820 --> 54:55.820]  То есть вот это вот
[54:55.820 --> 54:57.820]  технически нужно сделать. Здесь это просто
[54:57.820 --> 54:59.820]  бывают на самом деле
[54:59.820 --> 55:01.820]  свадебности, где для достижения
[55:01.820 --> 55:03.820]  всюду определенности приходится
[55:03.820 --> 55:05.820]  тратить больше сил. Обычно
[55:05.820 --> 55:07.820]  это все вот примерно так и делается,
[55:07.820 --> 55:09.820]  то есть очень часто про это забываем говорить.
[55:09.820 --> 55:11.820]  Но в принципе
[55:11.820 --> 55:13.820]  это нужно следить, потому что бывают случаи,
[55:13.820 --> 55:15.820]  когда это не столь очевидно,
[55:15.820 --> 55:17.820]  и нам требуется усилие, чтобы
[55:17.820 --> 55:19.820]  этого добиться.
[55:19.820 --> 55:21.820]  И можно создавать какие-то искусственные ситуации,
[55:21.820 --> 55:23.820]  где этого добиться нельзя, и тогда
[55:23.820 --> 55:25.820]  начинаются проблемы.
[55:25.820 --> 55:27.820]  Ну, это так в теории алгоритмов
[55:27.820 --> 55:29.820]  разные интересные упражнения с этим связаны.
[55:29.820 --> 55:31.820]  Нас уже все
[55:31.820 --> 55:33.820]  устраивает.
[55:33.820 --> 55:35.820]  Нас уже
[55:35.820 --> 55:37.820]  все устраивает, но теперь
[55:39.820 --> 55:41.820]  нужно сделать следующий шаг.
[55:41.820 --> 55:43.820]  Я напомню, я
[55:43.820 --> 55:45.820]  двигаюсь в сторону общезначимых формул,
[55:45.820 --> 55:47.820]  пока до них далеко, пока только какие-то
[55:47.820 --> 55:49.820]  подстановки
[55:49.820 --> 55:51.820]  слов, никаких тебе
[55:51.820 --> 55:53.820]  общезначимых формул. И первый шаг
[55:53.820 --> 55:55.820]  дальше
[55:55.820 --> 55:57.820]  состоит в том, чтобы
[55:57.820 --> 55:59.820]  рассмотреть вариант
[55:59.820 --> 56:01.820]  исчисления, который называются
[56:01.820 --> 56:03.820]  туевские системы
[56:03.820 --> 56:05.820]  или симметричные исчисления.
[56:05.820 --> 56:07.820]  Давайте я где-нибудь
[56:07.820 --> 56:09.820]  вот здесь
[56:09.820 --> 56:11.820]  это напишу, потому что
[56:11.820 --> 56:13.820]  мне как-то жалко стирать, там
[56:13.820 --> 56:15.820]  много мне пригодится сейчас, значит,
[56:15.820 --> 56:17.820]  симметричные исчисления.
[56:21.820 --> 56:23.820]  Формально это просто частный случай
[56:23.820 --> 56:25.820]  общих исчислений, но только
[56:27.820 --> 56:29.820]  выполняется такое
[56:29.820 --> 56:31.820]  свойство, что если у нас есть правила
[56:31.820 --> 56:33.820]  из УВ, то есть и правила из ВУ.
[56:35.820 --> 56:37.820]  Другими словами, у нас
[56:37.820 --> 56:39.820]  мы определяем фактически неориентированный
[56:39.820 --> 56:41.820]  граф. То есть правила
[56:41.820 --> 56:43.820]  подстановки можно использовать как по
[56:43.820 --> 56:45.820]  стрелке, так и против стрелки.
[56:45.820 --> 56:47.820]  Ну и получается неориентированный граф, у нас
[56:47.820 --> 56:49.820]  есть два слова, они связаны между
[56:49.820 --> 56:51.820]  собой, можем перейти из одного
[56:51.820 --> 56:53.820]  в второе, из второго в первое.
[56:53.820 --> 56:55.820]  Вот все ограничение.
[56:55.820 --> 56:57.820]  Это уже называются туевские системы.
[57:03.820 --> 57:05.820]  Потому что
[57:05.820 --> 57:07.820]  я на самом деле их изучал, я
[57:07.820 --> 57:09.820]  не уверен, что сегодня успею это
[57:09.820 --> 57:11.820]  объяснить.
[57:13.820 --> 57:15.820]  Получаем, соответственно, задачу
[57:15.820 --> 57:17.820]  достижимости для туевских систем. Вот транзитивное
[57:17.820 --> 57:19.820]  замыкание я буду обозначать тоже двойной
[57:19.820 --> 57:21.820]  стрелочкой со звездочкой. Это понятно, что
[57:21.820 --> 57:23.820]  такое. Это есть последовательность слов.
[57:23.820 --> 57:25.820]  Каждая пара соседних
[57:25.820 --> 57:27.820]  связана вот этим вот отношением,
[57:27.820 --> 57:29.820]  уже симметричным отношением.
[57:29.820 --> 57:31.820]  Поэтому мы можем идти как по стрелкам,
[57:31.820 --> 57:33.820]  так и против стрелок.
[57:34.820 --> 57:36.820]  И вопрос тот же самый.
[57:36.820 --> 57:38.820]  Нам нужно доказать, что
[57:38.820 --> 57:40.820]  не вопрос, а утверждение.
[57:42.820 --> 57:44.820]  Что
[57:44.820 --> 57:46.820]  проблемы остановки сводятся и
[57:46.820 --> 57:48.820]  к туевским системам.
[57:50.820 --> 57:52.820]  Почему я так все это сохраняю?
[57:52.820 --> 57:54.820]  Потому что тут удивительный факт.
[57:54.820 --> 57:56.820]  Вот та свадимость, которую я описал,
[57:56.820 --> 57:58.820]  она, конечно, длинная и морочная, но
[57:58.820 --> 58:00.820]  в ней есть очень много приятных
[58:00.820 --> 58:02.820]  моментов.
[58:02.820 --> 58:04.820]  В частности, она удивительным образом
[58:04.820 --> 58:06.820]  работает и для симметричного
[58:06.820 --> 58:08.820]  случая.
[58:08.820 --> 58:10.820]  То есть вот я хочу свести
[58:10.820 --> 58:12.820]  остановку машины и тюринга
[58:12.820 --> 58:14.820]  к уже симметричному исчислению.
[58:15.820 --> 58:17.820]  Я буду делать все то же самое.
[58:17.820 --> 58:19.820]  Вот такой же алфавит, такие же
[58:19.820 --> 58:21.820]  правила, все то же самое.
[58:22.820 --> 58:24.820]  Единственное, что у меня тут стрелочки были
[58:24.820 --> 58:26.820]  односторонние, а теперь они будут
[58:26.820 --> 58:28.820]  двусторонними. Но я их даже не буду писать
[58:28.820 --> 58:30.820]  двусторонними, а буду просто понимать, что
[58:30.820 --> 58:32.820]  нам разрешено делать ход как
[58:32.820 --> 58:34.820]  по стрелке, так и против стрелки.
[58:34.820 --> 58:36.820]  Это мне будет удобно в доказательстве
[58:36.820 --> 58:38.820]  именно так к этому относиться.
[58:39.820 --> 58:41.820]  То есть буквально та же свадимость.
[58:43.820 --> 58:45.820]  Это кажется удивительным, но
[58:45.820 --> 58:47.820]  тем не менее.
[58:48.820 --> 58:50.820]  Давайте посмотрим, что у нас
[58:50.820 --> 58:52.820]  меняется.
[59:00.820 --> 59:02.820]  Ну,
[59:04.820 --> 59:06.820]  случай B не меняется
[59:06.820 --> 59:08.820]  никак.
[59:08.820 --> 59:10.820]  Потому что, смотрите, если машина останавливается,
[59:10.820 --> 59:12.820]  то мы уже изучили,
[59:12.820 --> 59:14.820]  что мы можем достичь
[59:14.820 --> 59:16.820]  изначального слова конечное, двигаясь по
[59:16.820 --> 59:18.820]  стрелкам, то есть применяя правила в одном
[59:18.820 --> 59:20.820]  направлении. Ну и отлично, нам разрешено
[59:20.820 --> 59:22.820]  в обоих направлениях применять. Значит,
[59:22.820 --> 59:24.820]  в симметричном случае тоже достижено.
[59:24.820 --> 59:26.820]  То есть вот это вот мы
[59:26.820 --> 59:28.820]  сделали. А вот здесь сложнее,
[59:28.820 --> 59:30.820]  потому что теперь нам нужно
[59:30.820 --> 59:32.820]  рассматривать более сложные пути.
[59:32.820 --> 59:34.820]  Мы можем двигаться как по стрелкам,
[59:34.820 --> 59:36.820]  так и против стрелок.
[59:36.820 --> 59:38.820]  И нам нужно доказать,
[59:38.820 --> 59:40.820]  что, если мы можем достичь
[59:42.820 --> 59:44.820]  финального состояния,
[59:44.820 --> 59:46.820]  двигаясь как
[59:46.820 --> 59:48.820]  по стрелкам, так и против стрелок, мы можем
[59:48.820 --> 59:50.820]  достичь так же и двигаясь в правильном
[59:50.820 --> 59:52.820]  образом по стрелкам. Тогда мы уже доказали,
[59:52.820 --> 59:54.820]  что это...
[59:54.820 --> 59:56.820]  Если машины не останавливаются, это невозможно.
[59:56.820 --> 01:00:01.020]  То есть вот тут нужна дополнительная работа, и мне по-видимому
[01:00:01.020 --> 01:00:03.820]  придется все-таки стереть определение свадимости,
[01:00:03.820 --> 01:00:06.500]  но оно так уже довольно давно перед глазами.
[01:00:06.500 --> 01:00:10.060]  Я надеюсь, что мне, собственно, хотелось его оставить до
[01:00:10.060 --> 01:00:17.700]  того момента, когда я уточнял свадимость на особым случай.
[01:00:17.700 --> 01:00:18.980]  Почему так получается?
[01:00:18.980 --> 01:00:20.940]  Потому что у нас есть еще одно свойство.
[01:00:20.940 --> 01:00:32.420]  Вот, предположим, я из слова w1 получаю по стрелке слово w2,
[01:00:32.420 --> 01:00:36.540]  и w2 принадлежит рабочему множеству.
[01:00:36.540 --> 01:00:47.620]  Тогда и w1 тоже принадлежит рабочему множеству.
[01:00:48.460 --> 01:00:52.700]  То есть другими словами, если я хочу пойти против стрелки
[01:00:52.700 --> 01:00:55.460]  из элемента рабочего множества, я только в рабочее множество
[01:00:55.460 --> 01:00:56.460]  могу попасть.
[01:00:56.460 --> 01:01:00.060]  Ну, это можно увидеть вот из этих правил.
[01:01:00.060 --> 01:01:03.420]  Смотрите, значит, я меняю наоборот вот в обратную
[01:01:03.420 --> 01:01:07.740]  сторону, но ясно, что такое изменение мне даст опять
[01:01:07.740 --> 01:01:10.780]  такие элементы рабочего множества, потому что у
[01:01:10.780 --> 01:01:13.940]  меня опять получается какой-то символ состояния, причем
[01:01:13.940 --> 01:01:16.580]  он не финальный, потому что из финального мы не делаем
[01:01:16.580 --> 01:01:17.580]  перехода.
[01:01:17.580 --> 01:01:19.780]  Значит, получается рабочее множество.
[01:01:19.780 --> 01:01:24.260]  То есть если у нас есть такой переход, значит, двигаясь
[01:01:24.260 --> 01:01:26.860]  против стрелок, мы никогда из рабочего множества не
[01:01:26.860 --> 01:01:27.860]  выходим.
[01:01:27.860 --> 01:01:30.660]  По стрелке выйти можем, потому что у нас такое вот
[01:01:30.660 --> 01:01:31.660]  было.
[01:01:31.660 --> 01:01:34.140]  А против стрелки не можем.
[01:01:34.140 --> 01:01:38.100]  И вот это вот свойство, оно будет достаточно, чтобы
[01:01:38.100 --> 01:01:41.220]  доказать усиленный вариант вот этого утверждения.
[01:01:41.220 --> 01:01:45.540]  Двигаясь даже против стрелок, мы все равно в финальное
[01:01:45.540 --> 01:01:46.540]  множество не попадем.
[01:01:46.540 --> 01:01:48.500]  Но как это доказывается?
[01:01:48.500 --> 01:01:51.100]  Значит, доказывается это так.
[01:01:51.100 --> 01:01:54.660]  Если мы можем попасть, вот представьте, что мы попали.
[01:01:54.660 --> 01:01:59.780]  Теперь я вот как-нибудь нарисую более общую ситуацию.
[01:01:59.780 --> 01:02:05.660]  Вот мы двигаемся где-то по стрелкам, где-то против
[01:02:05.660 --> 01:02:10.220]  стрелок, где-то опять по стрелкам и так далее.
[01:02:10.300 --> 01:02:17.100]  И попадаем, наконец, в слово из финального множества.
[01:02:17.100 --> 01:02:22.820]  Значит, вот во-первых, вот этот вот последний момент,
[01:02:22.820 --> 01:02:25.420]  он обязательно будет по стрелке в силу того свойства,
[01:02:25.420 --> 01:02:26.420]  которое я сказал.
[01:02:26.420 --> 01:02:29.100]  Если мы вообще смогли попасть в финальное множество, последний
[01:02:29.100 --> 01:02:31.740]  переход был по стрелке.
[01:02:31.740 --> 01:02:34.300]  Я теперь хочу сказать, что если есть такая последовательность,
[01:02:34.300 --> 01:02:36.640]  то есть последовательность, в которой все шаги делаются
[01:02:36.640 --> 01:02:37.640]  по стрелкам.
[01:02:37.640 --> 01:02:39.860]  Этого нам будет достаточно.
[01:02:39.900 --> 01:02:42.300]  Шаги по стрелкам у нас в финальном множестве в этом
[01:02:42.300 --> 01:02:44.820]  втором случае не приводят.
[01:02:44.820 --> 01:02:46.100]  Ну как это доказать?
[01:02:46.100 --> 01:02:53.060]  Рассмотрим кратчайший путь из вот начального, кратчайший
[01:02:53.060 --> 01:02:57.460]  путь в f.
[01:02:57.460 --> 01:03:00.820]  Неважно в какое слово из f, кратчайший путь в f.
[01:03:00.820 --> 01:03:03.740]  Я утверждаю, что он идет обязательно по стрелкам.
[01:03:03.740 --> 01:03:07.980]  Ну давайте на него посмотрим.
[01:03:07.980 --> 01:03:13.260]  Ну здесь собственно нарисовано, ну давайте я его перерисую.
[01:03:13.260 --> 01:03:16.140]  Тут где-то с по стрелкам, где-то против стрелок.
[01:03:16.140 --> 01:03:22.300]  Последний ход обязательно по стрелке.
[01:03:22.300 --> 01:03:26.100]  Давайте найдем самую правую позицию, когда был сделан
[01:03:26.100 --> 01:03:27.100]  ход против стрелки.
[01:03:27.100 --> 01:03:38.180]  Правее у нас еще не может быть финального множества,
[01:03:38.180 --> 01:03:40.780]  ну точнее уитой может уже быть финального множества,
[01:03:40.780 --> 01:03:42.740]  но ход обязательно по стрелке.
[01:03:42.740 --> 01:03:46.020]  Раз-то последний ход против стрелки, дальше все ходы
[01:03:46.020 --> 01:03:49.020]  по стрелке, хотя бы один такой будет.
[01:03:49.020 --> 01:03:51.460]  Почему я так на это упираю?
[01:03:51.460 --> 01:03:55.740]  Потому что я напомню, что наши стрелки проводятся
[01:03:55.740 --> 01:03:58.740]  так, что из каждого слова выходит ровно одна стрелка.
[01:03:58.740 --> 01:04:10.180]  У нас однозначно применено, пока мы находимся в рабочей
[01:04:10.180 --> 01:04:11.180]  множестве.
[01:04:11.180 --> 01:04:12.180]  Но это что означает?
[01:04:12.180 --> 01:04:14.740]  Вот смотрите, вот одна стрелка выходит в уи плюс первая,
[01:04:14.740 --> 01:04:17.980]  а другая выходит в уи минус первая.
[01:04:17.980 --> 01:04:20.980]  Но это означает, что уи плюс первая просто равняется
[01:04:20.980 --> 01:04:21.980]  уи минус первая.
[01:04:21.980 --> 01:04:24.980]  А тогда что за кратчайший путь?
[01:04:24.980 --> 01:04:30.660]  Я могу просто уитое выбросить, и все, и путь станет короче.
[01:04:30.660 --> 01:04:31.660]  Пришли к противоречию.
[01:04:31.660 --> 01:04:35.620]  То есть кратчайший путь, он должен быть иностронним,
[01:04:35.620 --> 01:04:37.660]  мы должны применять только по стрелкам.
[01:04:37.660 --> 01:04:40.140]  Ну и отсюда следует уже доказательство корректности
[01:04:40.140 --> 01:04:52.740]  для симметричных исчислений.
[01:04:52.740 --> 01:04:55.820]  Симметричные исчисления имеют очень внятную алгебраическую
[01:04:55.820 --> 01:04:59.860]  интерпретацию, и мне она как раз будет нужна, и
[01:04:59.860 --> 01:05:01.900]  наверное я успею про нее рассказать, но я хотел
[01:05:01.900 --> 01:05:05.540]  бы хотя бы коротко объяснить про ограниченную задачу
[01:05:05.540 --> 01:05:06.540]  достижимости.
[01:05:06.540 --> 01:05:19.980]  Что?
[01:05:19.980 --> 01:05:20.980]  Мы проверяли это.
[01:05:21.980 --> 01:05:28.020]  Ну, смотрите, вот это правило можно применить к рабочему
[01:05:28.020 --> 01:05:32.040]  слову, одно из этих правил можно применить только единственным
[01:05:32.040 --> 01:05:33.040]  способом.
[01:05:33.040 --> 01:05:35.740]  Потому что по индукции мы доказываем.
[01:05:35.740 --> 01:05:38.380]  Заметьте, что количество символов состояния не меняется,
[01:05:38.380 --> 01:05:40.740]  оно все время остается равным единице.
[01:05:40.740 --> 01:05:41.740]  Правила так устроены.
[01:05:41.740 --> 01:05:46.280]  Значит, мы находим символ состояния и смотрим на следующий
[01:05:46.280 --> 01:05:48.660]  справа символ.
[01:05:48.660 --> 01:05:50.500]  По нашему построению в рабочем множестве справа
[01:05:50.500 --> 01:05:52.700]  есть символ, потому что есть окаемление, по крайней
[01:05:52.700 --> 01:05:53.700]  мере, лямда нулями.
[01:05:53.700 --> 01:05:58.700]  Ну, значит, деваться некуда, значит, есть символ состояния
[01:05:58.700 --> 01:06:00.260]  и следующий символ.
[01:06:00.260 --> 01:06:04.100]  И это отвечает таблице перехода, вот все возможности,
[01:06:04.100 --> 01:06:08.820]  для этой пары у нас значение в таблице перехода какое-то
[01:06:08.820 --> 01:06:11.220]  записано единственное, вот мы только такое правило
[01:06:11.220 --> 01:06:12.220]  можем применить.
[01:06:12.220 --> 01:06:18.180]  Любое другое будет неприменимо, потому что у нас нет другого
[01:06:18.420 --> 01:06:21.860]  подслова, которое начинается с символа состояния и потом
[01:06:21.860 --> 01:06:23.860]  идет символ алфавита.
[01:06:23.860 --> 01:06:26.180]  У нас такое подслово в рабочем слове единственное.
[01:06:26.180 --> 01:06:31.980]  Ну и к нему применимо только одно из правил.
[01:06:31.980 --> 01:06:36.180]  Значит, ограниченная задача достижимости.
[01:06:36.180 --> 01:06:41.020]  Это я, в общем, уже немножко даже сказал, но я сейчас
[01:06:41.020 --> 01:06:44.000]  хочу, вот пусть у нас есть зафиксировано какое-то
[01:06:44.000 --> 01:06:47.180]  ассоциативное исчисление, даже не обязательно симметричное,
[01:06:47.180 --> 01:06:50.380]  потому что в реальной жизни оно было именно для симметричного
[01:06:50.380 --> 01:06:51.380]  рассматривалось.
[01:06:51.380 --> 01:06:57.780]  И мы рассматриваем такой язык множество таких пар
[01:06:57.780 --> 01:07:02.580]  у и в, что из у достижимо в.
[01:07:02.580 --> 01:07:07.420]  И нас интересует разрешим ли он.
[01:07:07.420 --> 01:07:10.540]  Ну, в зависимости от того, какой язык рассматривать,
[01:07:10.540 --> 01:07:14.180]  это вот этот язык может быть и разрешимым, и не разрешимым.
[01:07:14.180 --> 01:07:16.300]  Например, если множество правил пустое, как мы уже
[01:07:16.300 --> 01:07:18.260]  обсуждали, там все очень легко.
[01:07:18.260 --> 01:07:21.060]  Мы должны просто сравнить слова у и в, если они не равны,
[01:07:21.060 --> 01:07:22.060]  то они достижимы.
[01:07:22.060 --> 01:07:23.060]  Если равны, то достижимы.
[01:07:23.060 --> 01:07:26.900]  Ну, конечно, это совсем тривиально, а в математике возникли
[01:07:26.900 --> 01:07:29.980]  разные интересные системы подстановок, в основном симметричные
[01:07:29.980 --> 01:07:30.980]  возникали.
[01:07:30.980 --> 01:07:36.100]  И я сейчас, наверное, успею сегодня объяснить, почему
[01:07:36.100 --> 01:07:37.100]  это с алгеброй связано.
[01:07:37.100 --> 01:07:44.300]  Но для каких-то простых исчислений удавалось построить такие
[01:07:44.300 --> 01:07:47.180]  преобразования, которые дают ответ на этот вопрос,
[01:07:47.180 --> 01:07:49.740]  для каких-то не удавалось, и было не очень понятно,
[01:07:49.740 --> 01:07:50.740]  что это возможно.
[01:07:50.740 --> 01:07:58.420]  Вот важная теорема состоит в том, что существует такое
[01:07:58.420 --> 01:08:03.180]  исчисление, что уже вот этот ограниченный язык не разрешим.
[01:08:03.180 --> 01:08:11.500]  То есть одно исчисление.
[01:08:11.500 --> 01:08:14.660]  Правила мы зафиксировали, только вот смотрим на начальное
[01:08:14.660 --> 01:08:15.660]  и конечное слово.
[01:08:15.660 --> 01:08:21.140]  Опять-таки, волшебная сила этой свадимости состоит
[01:08:21.140 --> 01:08:24.140]  в том, что ничего сложного исписывать еще раз с три
[01:08:24.140 --> 01:08:25.140]  доски не нужно.
[01:08:25.140 --> 01:08:27.340]  Все уже на доске есть.
[01:08:27.340 --> 01:08:29.540]  Давайте посмотрим на наши правила.
[01:08:29.540 --> 01:08:31.540]  Заметьте, как они сформулированы.
[01:08:31.540 --> 01:08:34.420]  Они от машины зависят только правила.
[01:08:34.420 --> 01:08:40.260]  Начальное и конечное слова от машины не зависят.
[01:08:40.260 --> 01:08:45.820]  Ну, значит, как получить вот такое вот исчисление?
[01:08:45.820 --> 01:08:50.860]  Нужно применить нашу свадимость к такой машине, которая работает
[01:08:50.860 --> 01:08:53.900]  и моделирует работу любой другой машины на данном
[01:08:53.900 --> 01:08:54.900]  входе.
[01:08:54.900 --> 01:08:56.740]  То есть это называется обычно универсальной машиной
[01:08:56.740 --> 01:09:00.060]  тюринга, и я надеюсь вам что-то про нее в курсе алгоритмов
[01:09:00.060 --> 01:09:01.060]  рассказывает.
[01:09:01.060 --> 01:09:02.540]  То есть такая машина есть.
[01:09:02.540 --> 01:09:05.100]  Ну вот тогда мы возьмем эту свадимость, вместо
[01:09:05.100 --> 01:09:07.980]  М подставим универсальную машину, а вместо X – описание
[01:09:07.980 --> 01:09:09.340]  произвольной машины и входа.
[01:09:09.340 --> 01:09:12.780]  И построим свадимость.
[01:09:12.780 --> 01:09:16.220]  Она будет корректной, потому что у нас всегда это работает.
[01:09:16.220 --> 01:09:19.100]  То есть в этой свадимости очень важно, что правила
[01:09:19.100 --> 01:09:22.020]  не зависят от входных слов.
[01:09:22.020 --> 01:09:24.460]  И получаем такую сложную систему.
[01:09:24.460 --> 01:09:27.380]  Конечно она будет, если реализовывать универсальную
[01:09:27.380 --> 01:09:30.020]  машину как-то тупо, она будет очень длинная.
[01:09:30.020 --> 01:09:33.180]  Но люди постарались, там есть исключительно короткие
[01:09:33.180 --> 01:09:37.940]  примеры таких систем, для которых неразрешима и
[01:09:37.940 --> 01:09:39.420]  правил там совсем немного.
[01:09:39.420 --> 01:09:43.380]  Там понятно идёт, есть два параметра, размер алфавита
[01:09:43.380 --> 01:09:44.540]  и количество правил.
[01:09:44.540 --> 01:09:47.940]  Ну и там, я боюсь ошибиться, но по-моему рекордные результаты
[01:09:47.940 --> 01:09:48.940]  типа такие.
[01:09:48.940 --> 01:09:52.100]  Если алфавит двоичный, то правил нужно семь, а если
[01:09:52.100 --> 01:09:55.820]  алфавит уже то ли троичный, то ли четверичный, то правил
[01:09:55.820 --> 01:09:58.580]  всего два вообще можно использовать, уже будет неразрешим.
[01:09:58.580 --> 01:10:02.380]  В общем, люди много этой задачи думали и разные
[01:10:02.380 --> 01:10:03.980]  интересные вещи придумывали.
[01:10:04.940 --> 01:10:09.180]  Я сейчас скорее хочу объяснить, за оставшееся сегодня время,
[01:10:09.180 --> 01:10:13.860]  почему так важны туевские системы, симметричные исчисления.
[01:10:13.860 --> 01:10:15.940]  Для этого нужно установить связь с алгеброй.
[01:10:15.940 --> 01:10:21.060]  Я в курсе алгебры про это практически ничего не рассказывал,
[01:10:21.060 --> 01:10:22.860]  потому что не было времени.
[01:10:22.860 --> 01:10:23.860]  А сейчас придётся.
[01:10:23.860 --> 01:10:27.780]  Во-первых, я напомню, что у нас есть такое понятие
[01:10:27.780 --> 01:10:28.780]  полугруппа.
[01:10:28.780 --> 01:10:33.300]  Я даже не уверен, что я обводил это понятие в курсе алгебры.
[01:10:33.300 --> 01:10:37.580]  Это тоже множество с операцией.
[01:10:37.580 --> 01:10:44.060]  Но почему это полугруппа, а не группа?
[01:10:44.060 --> 01:10:47.100]  Потому что всё, что мы требуем от операции, это ассоциативность.
[01:10:47.100 --> 01:10:58.540]  Любая группа будет полугруппой, потому что групповая операция
[01:10:58.540 --> 01:10:59.540]  ассоциативна.
[01:10:59.540 --> 01:11:03.020]  Но полугрупп, конечно, гораздо больше, потому что нам
[01:11:03.020 --> 01:11:05.340]  не нужен уже нейтральный элемент.
[01:11:05.340 --> 01:11:08.500]  Если есть нейтральный элемент полугруппа, называется,
[01:11:08.500 --> 01:11:10.540]  извините за выражение, маноидом.
[01:11:10.540 --> 01:11:15.340]  Алгебристы любят много слов, значит, маноид.
[01:11:15.340 --> 01:11:19.740]  И если у нас есть алфавит и множество слов в этом
[01:11:19.740 --> 01:11:22.700]  алфавите, на него можно смотреть как на полугруппу.
[01:11:22.700 --> 01:11:25.420]  Почему?
[01:11:25.420 --> 01:11:29.700]  Потому что у нас есть операция конкатинации, приписывание
[01:11:29.700 --> 01:11:30.700]  к одному слову другое.
[01:11:30.700 --> 01:11:31.700]  Она, естественно, ассоциативна.
[01:11:31.700 --> 01:11:35.060]  Потому что неважно, в каком порядке вы приписываете.
[01:11:35.060 --> 01:11:38.300]  Либо вы суффикс вначале приписали к бы, а потом
[01:11:38.300 --> 01:11:39.300]  префикс.
[01:11:39.300 --> 01:11:40.860]  Либо, наоборот, вначале приписали префикс, а потом
[01:11:40.860 --> 01:11:41.860]  суффикс.
[01:11:41.860 --> 01:11:46.820]  И это маноид, потому что у нас есть пустое слово,
[01:11:46.820 --> 01:11:48.900]  конкатинация с которым ничего не меняет.
[01:11:48.900 --> 01:11:53.940]  И это вот называется свободный маноид, и что более существенно
[01:11:53.940 --> 01:11:57.300]  для меня возникает важное понятие порождающих.
[01:11:57.300 --> 01:12:00.820]  Ну, про группы я тоже говорил, что группа порождается
[01:12:00.820 --> 01:12:03.100]  каким-то набором элементов.
[01:12:03.100 --> 01:12:10.140]  Вот теперь представьте, что у нас полугруппа задается
[01:12:10.140 --> 01:12:11.140]  следующим образом.
[01:12:11.140 --> 01:12:20.540]  Задается множеством как раз порождающих, то есть
[01:12:20.540 --> 01:12:24.660]  это некоторое подношение элементов группы, полугруппы,
[01:12:24.660 --> 01:12:26.980]  и множеством соотношений.
[01:12:26.980 --> 01:12:28.380]  Вот что такое соотношение?
[01:12:28.380 --> 01:12:32.700]  Ну, практически то, что я описал, только понятно,
[01:12:32.700 --> 01:12:35.260]  что в алгебре стрелочки или двойные стрелочки
[01:12:35.260 --> 01:12:37.900]  не рисуют, а просто честно пишут знак равенства.
[01:12:37.900 --> 01:12:40.700]  Уитэ равняется витэ.
[01:12:40.700 --> 01:12:47.420]  Ну, например, давайте рассмотрим, пусть сигма
[01:12:47.420 --> 01:12:55.220]  это два символа, и рассмотрим в качестве R такое правило,
[01:12:55.220 --> 01:12:58.860]  что R равняется BA.
[01:12:58.860 --> 01:13:01.900]  Мы фактически определяем некоторую полугруппу, которая
[01:13:01.900 --> 01:13:05.660]  порождается двумя своими элементами A и B, причем в
[01:13:05.660 --> 01:13:13.060]  этой полугруппе обязательно произведение AB равняется
[01:13:13.060 --> 01:13:14.060]  произведению BA.
[01:13:14.060 --> 01:13:19.740]  Ну, то, что эта полугруппа это на самом деле пары
[01:13:19.740 --> 01:13:25.180]  натуральных чисел с операцией сложения, это легко устанавливается
[01:13:25.220 --> 01:13:28.700]  но сейчас для нас более важный вопрос, почему вообще
[01:13:28.700 --> 01:13:29.700]  это корректно.
[01:13:29.700 --> 01:13:33.020]  То есть, вот смотрите, я взял какой-то набор порождающих
[01:13:33.020 --> 01:13:36.260]  и написал какой-то набор равенства, и говорю, вот
[01:13:36.260 --> 01:13:40.740]  есть полугруппа с такими образующими, с такими соотношениями.
[01:13:40.740 --> 01:13:43.380]  Первый вопрос, который задает человек из муренной
[01:13:43.380 --> 01:13:48.300]  математики, почему вообще есть, что вы имеете в виду?
[01:13:48.300 --> 01:13:50.820]  Написать можно все что угодно, а какой в этом смысл?
[01:13:50.820 --> 01:13:53.860]  Вот я сейчас объясню смысл, и это объяснение как раз
[01:13:53.860 --> 01:13:56.900]  используют симметричные исчисления.
[01:13:56.900 --> 01:13:59.900]  Собственно, они так и появились, когда математики стали
[01:13:59.900 --> 01:14:03.180]  много строить полугрупп, вот таким вот способом,
[01:14:03.180 --> 01:14:05.940]  их коллеги, которые более разборчивые, стали говорить
[01:14:05.940 --> 01:14:10.380]  вообще о чем вы в принципе говорите, и пришлось это
[01:14:10.380 --> 01:14:11.380]  аккуратно сказать.
[01:14:11.380 --> 01:14:17.500]  Вот смотрите, давайте, в результате у меня фактически
[01:14:17.500 --> 01:14:21.340]  получается симметричное исчисление, алфавит и правила
[01:14:22.020 --> 01:14:24.260]  Ну, то что там знак равенства вместо двойной стрелочки
[01:14:24.260 --> 01:14:26.060]  понимаете, ничего не значит.
[01:14:26.060 --> 01:14:28.380]  Замены мы делаем точно так же.
[01:14:28.380 --> 01:14:31.620]  Я хочу определить полугруппу, как я это делаю?
[01:14:31.620 --> 01:14:46.460]  Я определяю, даже не определяю, я прям честно скажу, что
[01:14:46.460 --> 01:14:48.540]  отношение достижимости в данном случае является
[01:14:48.700 --> 01:14:49.700]  отношением эквивалентности.
[01:14:49.700 --> 01:14:54.580]  У нас же отношение исчисления симметричное, мы можем сделать
[01:14:54.580 --> 01:14:57.740]  замены как слева направо, так и справа налево, и это
[01:14:57.740 --> 01:15:01.780]  как обычно в случае неориентированных графов, для бесконечных
[01:15:01.780 --> 01:15:04.340]  графов то же самое.
[01:15:04.340 --> 01:15:07.540]  Области достижимости задают разбиение на классы эквивалентности.
[01:15:07.540 --> 01:15:11.020]  То есть, отношение достижимости – это отношение эквивалентности.
[01:15:11.020 --> 01:15:13.700]  Если вы можете из У достичь В, из В вы можете достичь
[01:15:13.700 --> 01:15:14.700]  У.
[01:15:14.700 --> 01:15:15.700]  Из У достижимо О.
[01:15:15.860 --> 01:15:19.060]  То есть, это я проверил симметричность и рефлексивность.
[01:15:19.060 --> 01:15:21.100]  Ну и наконец-то проверить транзитивность, тоже никакой
[01:15:21.100 --> 01:15:25.060]  проблемы, если я из А попал в В, из В попал в С, как попасть
[01:15:25.060 --> 01:15:26.060]  из А в С?
[01:15:26.060 --> 01:15:29.180]  Ну, попасть в В, а потом попасть в С, то есть, просто повторить
[01:15:29.180 --> 01:15:30.180]  эти замены.
[01:15:30.180 --> 01:15:35.820]  И тогда я определяю такую полугруппу, которая состоит
[01:15:35.820 --> 01:15:38.580]  из класса эквивалентности по этому отношению.
[01:15:38.580 --> 01:15:47.700]  То есть, это множество, мне надо еще определить
[01:15:47.700 --> 01:15:48.700]  операцию.
[01:15:48.700 --> 01:15:52.180]  Операция определяется так, я напомню, что я, когда
[01:15:52.180 --> 01:15:54.740]  говорил про классы эквивалентности, очень любил квадратные
[01:15:54.740 --> 01:15:56.380]  скобки в алгебре.
[01:15:56.380 --> 01:15:58.420]  Сейчас я это напишу точно так же.
[01:15:58.420 --> 01:16:00.860]  Вот у меня есть один класс эквивалентности, есть второй
[01:16:00.860 --> 01:16:05.060]  класс эквивалентности, и я хочу определить операцию
[01:16:05.060 --> 01:16:06.060]  на них.
[01:16:06.060 --> 01:16:08.380]  То есть, в первом классе эквивалентности есть слово
[01:16:08.380 --> 01:16:11.620]  У, во втором есть слово В, тогда я говорю, что результат
[01:16:11.620 --> 01:16:13.860]  применения операции – это тот класс, в котором лежит
[01:16:13.860 --> 01:16:14.860]  их конкатинация.
[01:16:14.860 --> 01:16:21.660]  Я надеюсь, что вы помните, какая засада с определениями
[01:16:21.660 --> 01:16:22.660]  такого типа.
[01:16:22.660 --> 01:16:25.660]  Нужно корректность проверять.
[01:16:25.660 --> 01:16:26.900]  Давайте проверим корректность.
[01:16:26.900 --> 01:16:35.860]  Предположим, что у1 эквивалентно у2, v1 эквивалентно v2, нам
[01:16:35.860 --> 01:16:40.500]  нужно доказать, что тогда у1, v1 эквивалентно у2, v2, то
[01:16:40.500 --> 01:16:44.140]  есть, что результат операции не зависит от выбора представителя
[01:16:44.140 --> 01:16:45.140]  в классе эквивалентности.
[01:16:45.140 --> 01:16:48.100]  Но в данном случае это очень просто, потому что,
[01:16:48.100 --> 01:16:51.660]  смотрите, у меня есть преобразование, я длинную стрелочку нарисую,
[01:16:51.660 --> 01:16:55.740]  из у1 в у2, из v1 в v2.
[01:16:55.740 --> 01:16:59.220]  Теперь, как мне построить, зная, что у меня такие преобразования
[01:16:59.220 --> 01:17:01.860]  есть, как мне построить преобразование конкатинации.
[01:17:02.860 --> 01:17:08.220]  Ну, у нас же правила подстановки, они локальные, оттого, что
[01:17:08.220 --> 01:17:13.460]  у меня появился префикс, никто мне не мешает в префиксе
[01:17:13.460 --> 01:17:20.780]  сделать вот эту вот замену, получить из у1, у2, а потом
[01:17:20.780 --> 01:17:24.860]  то же самое сделать, не меняя уже префикса, заменить
[01:17:24.860 --> 01:17:25.860]  суффикс.
[01:17:26.860 --> 01:17:32.860]  Таким образом, мы получаем корректно определенную,
[01:17:44.860 --> 01:17:48.860]  корректно определенную полу-группу, и заметьте,
[01:17:48.860 --> 01:17:51.860]  что в результате разумно вот тот язык, который я назвал
[01:17:51.860 --> 01:17:57.860]  и это называется проблема равенства слов в полу-группе.
[01:17:57.860 --> 01:18:00.860]  У вас есть два слова в полу-группе, заданные образующими
[01:18:00.860 --> 01:18:03.860]  соотношениями, вам нужно проверить, равны они или нет.
[01:18:03.860 --> 01:18:08.860]  Ну, это то же самое, потому что в сущности равенство
[01:18:08.860 --> 01:18:11.860]  это и есть принадлежность к классу эквивалентности,
[01:18:11.860 --> 01:18:14.860]  то есть фактически наша задача о симметричных
[01:18:14.860 --> 01:18:17.860]  исчислениях, она кодирует вопрос о равенстве элементов
[01:18:17.860 --> 01:18:23.860]  в полу-группах, и мы уже видели, что в общем случае
[01:18:23.860 --> 01:18:27.860]  эта задача неразрешима, более того, есть совершенно
[01:18:27.860 --> 01:18:30.860]  конкретная полу-группа, для которой она неразрешима,
[01:18:30.860 --> 01:18:33.860]  вот как на правой доске написано, по универсальной
[01:18:33.860 --> 01:18:35.860]  машине Тюринга, я построю просто двустороннее
[01:18:35.860 --> 01:18:38.860]  исчисление, оно будет задавать какую-то полу-группу,
[01:18:38.860 --> 01:18:41.860]  и с этой полу-группой будет дедам.
[01:18:41.860 --> 01:18:46.860]  Вот, она уже будет очень сложной.
[01:18:46.860 --> 01:18:53.860]  Ну, вот это вот, фактически я здесь ничего не доказал,
[01:18:53.860 --> 01:18:57.860]  доказал какую-то корректность там, определение, но это
[01:18:57.860 --> 01:19:00.860]  вот решающий шаг, то есть сводимость было трудно
[01:19:00.860 --> 01:19:04.860]  строить для исчислений, а чтобы сделать следующий
[01:19:04.860 --> 01:19:09.860]  шаг к общезначим формулам, мне как раз нужна вот эта
[01:19:09.860 --> 01:19:12.860]  интерпретация в виде полу-групп.
[01:19:12.860 --> 01:19:15.860]  Ну, можно было бы это все пересказывать в терминах
[01:19:15.860 --> 01:19:17.860]  исчислений, получилось бы менее естественно.
[01:19:17.860 --> 01:19:19.860]  То есть дальше я буду говорить о том, что у меня есть
[01:19:19.860 --> 01:19:22.860]  полу-группа с порождающими соотношениями, и вот есть
[01:19:22.860 --> 01:19:25.860]  два слова, равенства которых я хочу проверить, и буду
[01:19:25.860 --> 01:19:30.860]  уже эту задачу, которая ЭК у меня обозначена, сводить
[01:19:30.860 --> 01:19:34.860]  проверки общезначимости форм.
[01:19:34.860 --> 01:19:36.860]  И тут симметричность очень важна.
[01:19:36.860 --> 01:19:40.860]  Заметьте, что если мы рассмотрим ориентированные графы,
[01:19:40.860 --> 01:19:42.860]  там тоже есть отношение достижимости, но оно принципиально
[01:19:42.860 --> 01:19:43.860]  сложнее.
[01:19:43.860 --> 01:19:46.860]  Оно, конечно, транзитивно, но оно не симметрично.
[01:19:46.860 --> 01:19:50.860]  Кстати, получается, какой-то такой частичный квазепорядок,
[01:19:50.860 --> 01:19:53.860]  его описывать гораздо сложнее, а вот отношение
[01:19:53.860 --> 01:19:56.860]  экологенности мы формулами первого порядка очень аккуратно
[01:19:56.860 --> 01:19:57.860]  сможем задать.
[01:19:57.860 --> 01:19:59.860]  Ну, на сегодня тогда все.
