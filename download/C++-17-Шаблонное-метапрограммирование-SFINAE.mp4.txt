[00:00.000 --> 00:11.000]  Значит, ну во-первых, давайте быстренько закончим разговор про вариант и про лондон,
[00:11.000 --> 00:17.040]  потому что в прошлый раз я в конце пары понял, что я сам не умею решать проблемы,
[00:17.040 --> 00:22.880]  о которой начал говорить, а именно у нас была проблема, я напомню, что,
[00:22.880 --> 00:36.920]  значит CP-2021, вариант, ну вот здесь мы писали, у нас была следующая проблема, вот здесь,
[00:36.920 --> 00:47.440]  когда мы делали пут, мы поняли, что вообще-то, если мы по тому же самому адресу кладем объект
[00:47.440 --> 00:53.000]  другого типа, нежели лежал там изначально, компилятор имеет право это соптимизировать,
[00:53.000 --> 01:01.440]  формально для него это УБ, вот я на самом деле нашел, значит, я нашел место в стандарте,
[01:01.440 --> 01:14.440]  в котором описывается формально, значит, это база, значит, это глава Basic Concepts, значит,
[01:14.440 --> 01:25.680]  пункт 66 Memory and Objects, и вот параграф Object Lifetime, тут есть следующий пункт 66384,
[01:25.680 --> 01:34.680]  значит 6638, тут это параграф, в котором рассказывается, что такое время жизни объекта,
[01:34.680 --> 01:40.320]  тут сказано, если после того как время жизни объекта закончилось и прежде чем сторож под него,
[01:40.320 --> 01:47.000]  который он занимал, переиспользовано или освобождено, новый объект создается на том же
[01:47.000 --> 02:06.160]  месте, на котором старый объект лежал, это описано выше, ну короче, если вкратце,
[02:06.160 --> 02:12.080]  то мы вызвали деструктор старого и на том же адресе построили Placement View нового, причем,
[02:12.080 --> 02:16.360]  если мы есть там объект с тривиальным деструктом, то деструктор даже не обязательно вызывать,
[02:16.360 --> 02:21.360]  просто как только мы сделали Placement View нового на том же адресе, а объект другого типа так вот,
[02:21.360 --> 02:27.480]  указатель, который указывал на старый объект, ссылка, которая указывала на старый объект или
[02:27.480 --> 02:33.680]  просто имя старого объекта, будет автоматически ссылаться на новый объект, и как только время
[02:33.680 --> 02:38.000]  жизни нового объекта начнется, он может быть использован, чтобы манипулировать новым объектом,
[02:38.000 --> 02:43.200]  если выполнены следующие четыре условия одновременно, ну то есть, у нас был указатель
[02:43.200 --> 02:53.040]  на старую штуку, мы решили его переиспользовать под новый объект, и объект оказался,
[02:53.040 --> 02:57.760]  ну мы уничтожили старый объект, новый объект положили в тому же указатель, вот если одновременно
[02:57.760 --> 03:04.600]  четыре условия выполнены, то это не УВ, что storage нового объекта в точности overlays,
[03:04.600 --> 03:12.440]  storage location значит в точности overlays, я кстати даже не знаю, что означает, видимо,
[03:12.440 --> 03:19.880]  оно не в точности, оно не превосходит, наверное, его по размеру, новый объект такого же типа,
[03:19.880 --> 03:26.720]  как и старый, игнорируя сивиблей и квалифаеры, тип оригинального объекта не const.qualify,
[03:26.720 --> 03:32.560]  и если это класс, не содержит никаких нестатических членов, которые const или reference,
[03:32.560 --> 03:39.440]  а также оригинальный объект был most derived объект типа T, и новый объект тоже most derived объект
[03:39.440 --> 03:50.440]  типа T, то есть они никакие не объекты базовых классов, ну вот тут пример, собственно, что вот я взял
[03:50.440 --> 04:07.000]  C1, C2, присвоил C1, C2, а оператор присваивания работает так. Каждый раз серебрыд описывается. Вот.
[04:07.000 --> 04:20.080]  То есть, допустим, у нас оператор присваивания так устроен, что он уничтожает старый объект по
[04:20.080 --> 04:27.880]  этому адресу и кладет новый. Вот. И еще и вызывает F зачем-то, не знаю зачем, но видимо для примера.
[04:27.880 --> 04:34.320]  Вот, после этого я у C1 вызываю F. Корректно ли это? Да, это корректно, ввиду вышесказанного,
[04:34.320 --> 04:40.920]  что мы уничтожили объект по старому адресу, положили плейсментом new, на него новый, но поскольку
[04:40.920 --> 04:46.880]  тип тот же самый, const qualifiers не было, ничего там на следовании не было, все нормально, это не
[04:46.880 --> 04:53.760]  УБ так делать. То есть, по факту, тут написано условие, при котором компилятор не может ничего закрешировать? Да, да, да, да,
[04:53.760 --> 04:59.240]  именно, смысл этого же в чем эти условия? В том, что компилятор, вот в чем смысл вот этого ограничения,
[04:59.240 --> 05:04.600]  что там не было констант, что не было const и не содержалось никакой non-static data member,
[05:04.600 --> 05:10.040]  который const или ссылка. Да, потому что, если бы у него был non-static data member, который const или ссылка,
[05:10.040 --> 05:15.200]  компилятор мог бы решить, например, что, а, ну, так это же const, значит, она точно не поменяется,
[05:15.200 --> 05:21.000]  значит, зачем мне второй раз ходить по указателю, там то же самое число и та же сама ссылка. А вот этот
[05:21.000 --> 05:28.120]  пункт еще более интересный. Зачем здесь нужен пункт про то, что они оба most derived объекты типа T,
[05:28.120 --> 05:35.440]  то есть, не было никаких у них наследников, которые навследовались бы от T, то есть, если у нас был
[05:35.440 --> 05:40.600]  B и D, то они оба должны быть derived, если они в иерархии наследования лежат, то оба должны быть...
[05:40.600 --> 05:49.280]  Ну, может derived, то есть, если они оба в какой-то иерархии наследования объекты, например...
[05:49.280 --> 05:54.440]  Они же одинакового типа, в смысле? Да, но при этом они не могут быть базами, они должны быть derived.
[05:54.440 --> 06:00.880]  В смысле, здесь у меня лежит аргент на BASE и еще один объект BASE, в смысле, я не могу подменить BASE на BASE?
[06:00.880 --> 06:06.560]  Да, получается так. Они оба должны быть most derived объектами. А, у них не должно быть ни одного derived?
[06:06.560 --> 06:14.240]  Да. Зачем это условие нужно? Что компилятор мог бы соптимизировать, зная, что они...
[06:14.240 --> 06:18.240]  Они... Ого-бейтс.
[06:21.760 --> 06:27.880]  Тут же написано, they are not BASE class sub-objects. То есть, он мог бы empty-based это не точно делать?
[06:27.880 --> 06:29.880]  Нет, он мог бы...
[06:33.880 --> 06:42.560]  Тут же написано нет, BASE class sub-objects, такое ощущение, что вот на derived лежат мать, отец и так далее.
[06:42.560 --> 06:48.000]  Вы имеете в виду, что мы вывожу отца на другого отца за минуту, внутри сына.
[06:48.000 --> 06:52.880]  Я вот так это понимаю. Разве нет? А, хотя нет, правда.
[06:52.880 --> 07:01.920]  Original object plus most derived object, но я не хочу лезть в детали, тут можно прочитать формально, что называется most derived object, там, скорее всего, будет объяснение с каким-нибудь...
[07:01.920 --> 07:07.000]  В общем, даже не хочу нажимать. А, ну это не так далеко отсюда, 662 всего лишь.
[07:07.000 --> 07:11.000]  Ну, в общем...
[07:11.000 --> 07:18.320]  А, ну вот написано, если это complete object, блаб-блаб-блаб. Короче, вот определение, что там most derived object.
[07:18.320 --> 07:23.560]  В общем, компилятор может делать дивиртуализацию.
[07:23.560 --> 07:29.880]  Вот есть такая легендарная статья на хабре, которую вы, возможно, даже видели. Кто-то из вас не видели вы?
[07:29.880 --> 07:31.080]  Никто. Не открывал.
[07:31.080 --> 07:36.600]  Вот ты, наверное, открывал, да, раз ты ко мне подходил с этим вопросом, вероятно, ты статью начитался.
[07:36.600 --> 07:48.360]  В общем, здесь Чел в прошлом году, это статья даже получила премию хабра, текст на тексте из 2021, Чел запарился и рассказал, что такое CD-LONDER на самом деле.
[07:48.360 --> 07:58.560]  Вот. И что оно делает именно с точки зрения... Вот здесь в конце объясняется, как именно CLN реализовывает LONDER.
[07:58.560 --> 08:10.280]  Вот. Вот здесь написано, значит, код во внутреннем представлении компилятора, что происходит, и как LONDER меняет то, что делает компилятор.
[08:10.280 --> 08:15.840]  Идея в том, что компилятор мог бы дивиртуализировать вызовы F.
[08:15.840 --> 08:27.360]  Если у вас F — это виртуальный метод, давайте вот посмотрим на какой-нибудь пример отсюда.
[08:27.360 --> 08:43.600]  Вот, скажем, здесь. Вот. Смотрите. Вот здесь у нас есть виртуальная функция F и виртуальная функция G.
[08:43.600 --> 08:52.280]  И компилятор принимает, значит, функция указатель на A, указатель на B. B — это наследник A.
[08:52.280 --> 09:02.320]  Мы вызываем F, вызываем G, вызываем еще раз G. Вот. А что это превращается в Assembler?
[09:02.320 --> 09:12.160]  Первый вызов F оказывается прямым, то есть без прохода по Vpointer'у.
[09:12.160 --> 09:22.200]  Знаете почему? Потому что FILE позволяет компилятору соптимизировать виртуальные вызовы и не ходить по Vpointer'у.
[09:22.520 --> 09:28.000]  Ну, как-то под O, как-то, как-то он должен компилировать, как читается, а он же сразу.
[09:28.000 --> 09:34.440]  Ну, под O0 из-за слова FILE он все равно. Ну, вот слово FILE на самом деле, вот вы когда-нибудь думали,
[09:34.440 --> 09:40.360]  я там в конце первого семестра говорил, что слово FILE есть еще один смысл, кроме просто допсу чтения.
[09:40.360 --> 09:43.640]  В самом деле FILE — это подсказка компилятору. Вот зачем нужно FILE?
[09:43.640 --> 09:47.000]  FILE — это подсказка компилятору, что вызовы соптимизировать можно в некоторых ситуациях.
[09:47.000 --> 09:51.760]  Вот, например, в такой ситуации. Если у вас на каком-то уровне написано, что виртуальная функция FILE,
[09:51.760 --> 09:59.480]  то значит, даже при O0, как видите, он это превратит не в хождение по Vpointer'у, а в просто прямой вызов.
[09:59.480 --> 10:00.480]  ВАЙ.
[10:01.360 --> 10:07.000]  Потому что он знает, что в классе A никто не может приопределить F.
[10:07.000 --> 10:08.320]  Значит, зачем Vpointer?
[10:08.320 --> 10:12.520]  Даже O0 же за этим нужно. Там нет O-1?
[10:12.520 --> 10:18.920]  Нет, в смысле FILE? Ну, блин, это то, что ты заведомо... Ну как, ну...
[10:19.600 --> 10:21.600]  Это как-то тривиально достаточно.
[10:21.600 --> 10:30.840]  Что я правильно понимаю, что если, допустим, у нас A, B, C, у A есть F виртуальное, у B есть FILE, у B есть C,
[10:30.840 --> 10:40.000]  то тогда он, если ему дать на C, то он автоматически понимает, что указатель на C есть и дать, а здесь еще D, допустим.
[10:40.000 --> 10:44.200]  Если ему как D подсунуть в C...
[10:44.200 --> 10:46.200]  Нет, просто если ему подсунуть...
[10:46.240 --> 10:54.360]  Если глубже, чем FILE, то он автоматически разберется до уровня FILE.
[10:54.360 --> 10:56.360]  Ну да, скорее всего, да.
[10:59.080 --> 11:05.520]  Ну, скорее всего, потому что это уже вопросы к разработчикам Капилятора, смогут они их оптимизировать в всех случаях или нет.
[11:05.520 --> 11:11.400]  Ну, короче, вызов G в A они не могут оптимизировать, вызов G требует вот таких вот маникуляций.
[11:11.400 --> 11:14.920]  Тут видите, какие происходят действия.
[11:14.920 --> 11:19.800]  A в вызов G от B он снова прямой.
[11:19.800 --> 11:24.560]  Вот, ну тут в этой статье еще перечислены ситуации, когда Капилятор может оптимизировать вызовы.
[11:24.560 --> 11:35.760]  Короче, смысл в чем? В том, что когда вы переиспользуете объект под другой тип, ну, даже под тот же самый тип,
[11:35.760 --> 11:45.160]  но у этого типа были какие-то наследники, Капилятор мог бы раньше думать, что вы...
[11:47.480 --> 11:51.400]  Ну, в общем, это попортило Капилятору возможность дивиртуализации.
[11:51.400 --> 11:58.360]  Вот это условие, насколько я понимаю, нужно для того, чтобы Капилятор мог делать дивиртуализации, чтобы у Капилятора не ломалась оптимизация дивиртуализации.
[11:58.360 --> 12:09.560]  Потому что если вы подменили бейс на бейс, а то...
[12:09.560 --> 12:19.760]  Ну, если у вас был указатель на бейс, а под ним лежал дирайвт,
[12:19.760 --> 12:36.160]  а то... Не знаю. Вот утверждается, что почему-то этот пункт нужен, чтобы Капилятор мог дивиртуализацию делать.
[12:36.160 --> 12:41.920]  Ну, я так это понимаю. Я до конца не понимаю, работает Лондор, как вы, наверное, догадались.
[12:42.880 --> 12:50.480]  Ну, мы можем только предполагать, что в C++20 они все еще раз поменяли, это, я считаю, C++17 стандарт.
[12:50.480 --> 12:59.920]  Но в C++20 там эти условия ослабили, и вроде как убрали вот это условие, 8.3, про константность.
[12:59.920 --> 13:09.440]  Вот, но... Вроде, видимо, они Капилятору запретили что-то, какие-то оптимизации делать. Не знаю, ну, в общем...
[13:09.520 --> 13:15.360]  Если кто-то... Конкурс, ну, бонусные баллы, если кто-то мне объяснит...
[13:18.400 --> 13:26.240]  Нет, на самом деле интересно, потому что мы с вами видели пример... В прошлом году я не знал еще... Где он вообще?
[13:26.240 --> 13:33.680]  В прошлом году мы не видели примера, когда Лондор реально что-то делает.
[13:33.760 --> 13:38.320]  Вот этот вот пример с вариантом, который я вам показал в прошлый раз, это вот...
[13:38.320 --> 13:43.360]  Известный мне пример, когда Лондор реально влияет на поведение Капилятора.
[13:43.360 --> 13:50.080]  Ну, то есть, если вы просто возьмете пример из вот этой вот, из статьи про Лондор,
[13:50.080 --> 13:57.200]  то тут от того, что убрать Лондор или добавить Лондор, оптимизация включить-выключить, ничего не меняется.
[13:57.360 --> 14:03.360]  Ну, может, сейчас что-то меняется, но в прошлом году я тестил от того, что Лондор убираешь, ничего не меняется.
[14:03.360 --> 14:11.440]  Поведение, наблюдаемо. Вот. Этот пример, который я вам показывал в прошлый раз, он был известным, единственным мне примером,
[14:11.440 --> 14:18.480]  при котором Лондор реально меняет поведение Капилятора. Вот. Ну, там УБ было в этом примере.
[14:18.480 --> 14:21.280]  И так и так или без Лондора?
[14:21.280 --> 14:27.440]  И так и так УБ, как мы выяснили в прошлый раз, потому что в прошлый раз мы как раз выяснили, что даже с добавлением Лондора УБ остается.
[14:27.440 --> 14:28.960]  Вы же помните?
[14:28.960 --> 14:35.200]  Потому что мы обращаемся к объекту до того, как мы его... его создал хоть кто-то.
[14:35.200 --> 14:39.840]  У него время жизни началось вообще там, вот там просто неинцелизированная штука, и...
[14:40.800 --> 14:52.400]  Вот. Сейчас я расскажу вам как раз как это фиксить, но вопрос о том, привести пример, когда Лондор реально влияет на поведение Капилятора,
[14:52.400 --> 15:02.400]  остается открытым. Короче, если кто-то найдет и приведет пример того, как функция Лондор реально меняет поведение,
[15:02.480 --> 15:10.960]  наблюдаемое поведение программы, и при этом это не УБ, то, не знаю, дам какие-нибудь бонусные баллы.
[15:10.960 --> 15:27.280]  У нас в прошлом году была такая история. Последняя пара пар. Вот у нас на последней неделе, которая будет, значит, там, 10-го,
[15:28.160 --> 15:35.120]  ну, наверное, 16-17 мая, это будет уже зачетная неделя, вот, я предлагаю сделать на зачетной неделе так же, как в прошлом году мы делали,
[15:35.120 --> 15:43.360]  а именно можно будет подготовить какой-нибудь рассказ по выбору. В прошлом году у нас человек рассказывал про рейнджи,
[15:43.360 --> 15:50.880]  вот, потому что у нас в курсе про рейнджи не рассказываем, видимо, в этом году тоже не расскажем. Может расскажем, не знаю, не успеем.
[15:50.880 --> 16:00.720]  Вот, короче, как вариант, вот, если кто-то хочет, я не знаю, какие-нибудь дополнительные плюсы к оценке, можно поговорить об этом,
[16:00.720 --> 16:08.800]  если вы найдете, если вы реально разберетесь там, как это работает, и приведете пример вот этому, вот, короче, приведете пример,
[16:08.800 --> 16:14.480]  как Лондор меняет поведение, но при этом это не УБ, то есть, корректный использователь, который реально меняет поведение.
[16:14.560 --> 16:32.720]  Вот это интересно, потому что, ну, в этой статье на Хабре есть пример, ну, есть объяснение, что делает Лондор с точки зрения внутреннего представления компилятора,
[16:32.720 --> 16:41.680]  но примера, в котором был он реально, короче, того примера, который я ищу, там нет. Давайте устраним УБ. А как устранить УБ?
[16:42.640 --> 16:50.240]  Ну, надо еще осхитить немножечко. То есть, УБ из-за того, что мы вот здесь делаем это Нью до того, как вообще имеем право обращаться к этой памяти.
[16:52.240 --> 16:59.440]  Потому что мы сейчас родители конструируем, а наследника еще, вообще, у него поля еще даже не, ну, время жизни полей не началось.
[17:01.440 --> 17:02.720]  Как устранить УБ?
[17:02.960 --> 17:10.720]  Ну, на самом деле, вот что надо сделать. И если мы посмотрим в стандартную реализацию варианта, мы примерно это увидим.
[17:10.720 --> 17:20.160]  Ну, я это уже исправил в втором ходе. Значит, давайте просто сделаем еще одного наследника. Родителя, точнее.
[17:20.160 --> 17:27.200]  У меня будет теперь вариант storage отдельно, а вариант alternative после него.
[17:30.160 --> 17:32.160]  А storage, а не вариант storage?
[17:32.720 --> 17:39.760]  Да, и storage хранится вариант storage. Теперь вариант alternative будут конструироваться после того, как создался вариант storage.
[17:39.760 --> 17:46.960]  А значит, в момент, когда создается вариант alternative, storage уже будет чем-то пренциализированным. Нам осталось лишь подложить перед него другую штуку.
[17:46.960 --> 17:48.960]  Классно, Петров.
[17:48.960 --> 17:52.960]  Вот такое решение предлагается.
[17:52.960 --> 17:54.960]  А сейчас, секунду.
[17:54.960 --> 17:58.960]  Тест. Кто понял проблему и ее решение.
[18:02.960 --> 18:06.960]  Я понял. С кем я разговариваю вообще?
[18:08.960 --> 18:10.960]  Три человека. Так, остальные?
[18:12.960 --> 18:18.960]  Нет, это как-то не очень. Давайте все-таки, чтобы я не стремлялся к ней общаться, давайте, не знаю, вопросы задайте какие-нибудь.
[18:18.960 --> 18:22.960]  А кто собирается варианты писать?
[18:26.960 --> 18:28.960]  У меня вообще еще, наверное, писано.
[18:29.200 --> 18:33.200]  Да, в принципе, можете не писать как-то. Это если кто плюс баллы хочет.
[18:35.200 --> 18:39.200]  Но я предупреждал в начале семестра, что задачи на плюс баллы будут не очень простыми.
[18:39.200 --> 18:41.200]  Ну так чего, есть вопросы?
[18:43.200 --> 18:45.200]  Или повторите все с самого начала?
[18:45.200 --> 18:47.200]  Да.
[18:47.200 --> 18:49.200]  У меня есть вопрос, связанный с этим поэтому.
[18:49.440 --> 18:59.440]  Зачем мы изобретали такую страшную реконструкцию в виде двух-тройдач, если мы могли просто сделать СТП?
[18:59.440 --> 19:05.440]  Почему мы не могли просто передать вариант-альтернативу type.variant?
[19:07.440 --> 19:09.440]  Не понял. В смысле передать?
[19:09.680 --> 19:19.680]  Ну и сейчас. Зачем мы создаем миллиарды родителей, в каждом из которых передаем все наши аргументы, если вместо всех наших аргументов можно делать себя?
[19:19.680 --> 19:27.680]  А ты хотел бы сказать, что вариант-альтернатив, что вариант, это наследник варианта-альтернатив от нас самих, то есть от варианта?
[19:27.680 --> 19:29.680]  Да.
[19:29.680 --> 19:31.680]  От варианта какого?
[19:31.680 --> 19:33.680]  От варианта с нашими типами.
[19:33.680 --> 19:35.680]  Вот это type... заменить на...
[19:35.680 --> 19:37.680]  Что это изменит?
[19:37.920 --> 19:41.920]  Идея на ничего просто новая. Идеи не будет. Просто старая терта по-обычной.
[19:41.920 --> 19:43.920]  Нет, но...
[19:43.920 --> 19:45.920]  Что это даст?
[19:45.920 --> 19:47.920]  У нас все равно будет множество наследований.
[19:47.920 --> 19:49.920]  Конечно.
[19:49.920 --> 19:51.920]  А у нас там все равно будет триточка?
[19:51.920 --> 19:59.920]  Конечно. Я просто пытаюсь понять, почему мы считаем, что вот это нечто совершенно новое, гениальное, изобретенное с какими-то там гениальными людьми, если фактически такое же мы уже делали.
[19:59.920 --> 20:01.920]  Но мы не делали с...
[20:01.920 --> 20:05.920]  Сейчас ты хочешь написать вот так. Вариант, от types, а многоточие ты хочешь оставить внешнее?
[20:06.160 --> 20:08.160]  А я могу просто вариант...
[20:08.160 --> 20:10.160]  Нет, так я же не могу.
[20:10.160 --> 20:12.160]  А как ты предлагаешь тогда? Я не понял.
[20:12.160 --> 20:14.160]  В смысле?
[20:14.160 --> 20:16.160]  Чего идеи не поменять просто?
[20:16.160 --> 20:18.160]  Сейчас. Почему я не могу просто варианты, кстати, написать?
[20:18.160 --> 20:20.160]  Так, а...
[20:20.160 --> 20:22.160]  У нас главная проблема, что T нужно.
[20:22.160 --> 20:24.160]  Мне нужно импортировать N конструкторов.
[20:24.160 --> 20:26.160]  Да.
[20:26.160 --> 20:28.160]  Чтобы перегрузка между ними делалась.
[20:28.160 --> 20:30.160]  Мне нужны N родители.
[20:30.160 --> 20:32.160]  Для этого N родители.
[20:32.160 --> 20:34.160]  И внешне многоточие будет.
[20:34.400 --> 20:36.400]  А внешне многоточие, оно будет что распаковывать?
[20:36.400 --> 20:38.400]  Если это вариант от types?
[20:38.400 --> 20:40.400]  Нет, нет. Понятно, что нужно types.
[20:40.400 --> 20:42.400]  А что здесь тогда написать?
[20:42.400 --> 20:44.400]  Ты предлагаешь вместо того, что было написано?
[20:44.400 --> 20:48.400]  Types, запятая, вариант.
[20:48.400 --> 20:50.400]  А, вариант от types?
[20:50.400 --> 20:52.400]  Типа.
[20:52.400 --> 20:54.400]  Не просто types многоточие, а вариант от types многоточие?
[20:54.400 --> 20:56.400]  Да.
[20:56.400 --> 20:58.400]  Это выглядит как что-то более сложное, чем то, что было раньше написано. Не так ли?
[21:00.400 --> 21:02.400]  Ладно.
[21:02.400 --> 21:04.400]  Ну, то есть...
[21:04.400 --> 21:06.400]  Граждалось, что можно просто так сделать, а еще не дополнительный вариант от этого.
[21:06.400 --> 21:08.400]  Ну, а потом нужно быть...
[21:08.400 --> 21:10.400]  Ну, тогда сверху нужно...
[21:10.400 --> 21:12.400]  А хотелось, чтобы написать вариант.
[21:12.400 --> 21:14.400]  Ну, и к тому же здесь, например,
[21:14.400 --> 21:16.400]  я вычисляю индекс, имея types многоточие.
[21:16.400 --> 21:18.400]  Да, это правильно.
[21:18.400 --> 21:20.400]  А если бы у меня не было варианта, то...
[21:22.400 --> 21:24.400]  Так. Так что?
[21:24.400 --> 21:26.400]  Все? Вы это там...
[21:26.400 --> 21:28.400]  Никто ничего больше не хочет сказать по этому поводу?
[21:28.400 --> 21:30.400]  Ну,
[21:30.400 --> 21:32.400]  на самом деле,
[21:32.400 --> 21:34.400]  я действительно в прошлый раз
[21:34.400 --> 21:36.400]  сам сделал некоторые открытия
[21:36.400 --> 21:38.400]  благодаря этому,
[21:38.400 --> 21:40.400]  благодаря этой истории СУБ,
[21:40.400 --> 21:42.400]  потому что у нас там
[21:42.400 --> 21:44.400]  люди, которые сдавали вариант
[21:44.400 --> 21:46.400]  вот по этой модели,
[21:46.400 --> 21:48.400]  которую я вам пропагандировал,
[21:48.400 --> 21:50.400]  а у них...
[21:54.400 --> 21:56.400]  Ну, в общем,
[21:56.400 --> 21:58.400]  в общем, там
[21:58.400 --> 22:00.400]  приходилось
[22:00.400 --> 22:02.400]  отключать
[22:02.400 --> 22:04.400]  жалобы...
[22:04.400 --> 22:06.400]  Там warning был один,
[22:06.400 --> 22:08.400]  и если поставить minus or all, то компилятор ругался.
[22:10.400 --> 22:12.400]  Maybe I'll initialize.
[22:12.400 --> 22:14.400]  И теперь я понял, почему нам приходилось,
[22:14.400 --> 22:16.400]  чтобы у них зашло в контест отключать
[22:16.400 --> 22:18.400]  конкретный warning.
[22:18.400 --> 22:20.400]  Теперь мы не будем отключать warning, я понял.
[22:20.400 --> 22:22.400]  Там просто действительно было бы это...
[22:22.400 --> 22:24.400]  Да.
[22:24.400 --> 22:26.400]  Ну, просто вот...
[22:26.400 --> 22:28.400]  Я сам не замечал этого УБР,
[22:28.400 --> 22:30.400]  я думал, что так нормально,
[22:30.400 --> 22:32.400]  а вот теперь только мы поняли, что так ненормально.
[22:32.400 --> 22:34.400]  И сейчас нам лаундер больше не нужен?
[22:34.400 --> 22:36.400]  Нет, лаундер формально все равно нужен.
[22:36.400 --> 22:38.400]  Потому что ты же нарушаешь эти условия,
[22:38.400 --> 22:40.400]  ты же покладываешь вместо одного типа другой тип.
[22:40.400 --> 22:42.400]  Разве?
[22:42.400 --> 22:44.400]  Вообще на другое место.
[22:44.400 --> 22:46.400]  А, потому что у меня там вообще чадр.
[22:46.400 --> 22:48.400]  Формально лаундер
[22:48.400 --> 22:50.400]  все еще нужен,
[22:50.400 --> 22:52.400]  но реально теперь
[22:52.400 --> 22:54.400]  лаундер не меняет поведение.
[22:54.400 --> 22:56.400]  Я вот, если сейчас это скандирую с лаундером без лаундера,
[22:56.400 --> 22:58.400]  с телландером без СС, ничего не меняется.
[22:58.400 --> 23:00.400]  Поэтому и...
[23:00.400 --> 23:02.400]  А если лаундер не написать,
[23:02.400 --> 23:04.400]  будет УБР?
[23:04.400 --> 23:06.400]  Формально, да. Кажется.
[23:06.400 --> 23:08.400]  По крайней мере все плюс 17.
[23:08.400 --> 23:10.400]  Я не уверен, все плюс 20 поменялись ли условия.
[23:10.400 --> 23:12.400]  В общем, пишите лаундер на всякий случай.
[23:14.400 --> 23:16.400]  Ладно.
[23:16.400 --> 23:18.400]  Так, окей, мы наконец-то,
[23:18.400 --> 23:20.400]  слава богу, закончили разговор про вариант.
[23:20.400 --> 23:22.400]  Да.
[23:22.400 --> 23:24.400]  Наверное, выложу условия сегодня.
[23:26.400 --> 23:28.400]  Я надеюсь.
[23:28.400 --> 23:30.400]  Все.
[23:30.400 --> 23:32.400]  Давайте пойдем дальше.
[23:34.400 --> 23:36.400]  Ну дальше будет чем попроще, наверное.
[23:36.400 --> 23:38.400]  Какое-то время.
[23:38.400 --> 23:40.400]  Нам глобально, так,
[23:40.400 --> 23:42.400]  осталось две темы пройти.
[23:42.400 --> 23:44.400]  Но
[23:44.400 --> 23:46.400]  в каждой из них можно много где
[23:46.400 --> 23:48.400]  развернуться. Значит, сейчас
[23:48.400 --> 23:50.400]  тема, которую я хочу начать, это
[23:50.400 --> 23:52.400]  с Финайе и концепты.
[23:52.400 --> 23:54.400]  Ну, про концепты мы, видимо, поговорим
[23:54.400 --> 23:56.400]  завтра.
[23:56.400 --> 23:58.400]  А сегодня мы пока поговорим
[23:58.400 --> 24:00.400]  просто про
[24:00.400 --> 24:02.400]  шаблонный метапрограммин, использовавший
[24:02.400 --> 24:04.400]  Финайе.
[24:08.400 --> 24:10.400]  Значит, давайте я
[24:10.400 --> 24:12.400]  начну.
[24:12.400 --> 24:14.400]  Что такое Финайе?
[24:14.400 --> 24:16.400]  Видимо, я так сказал,
[24:16.400 --> 24:18.400]  что все это знают.
[24:18.400 --> 24:20.400]  Кто не знает, кто не понял, тот поймет.
[24:20.400 --> 24:22.400]  Значит, тема 15-я.
[24:28.400 --> 24:30.400]  Ну, давайте я скажу,
[24:30.400 --> 24:32.400]  template,
[24:32.400 --> 24:34.400]  метапрограмминг.
[24:38.400 --> 24:40.400]  Финайе
[24:40.400 --> 24:42.400]  и
[24:42.400 --> 24:44.400]  концепт.
[24:44.400 --> 24:46.400]  Сейчас
[24:46.400 --> 24:48.400]  наша главная цель
[24:48.400 --> 24:50.400]  на сегодня, это реализовать
[24:50.400 --> 24:52.400]  все тайп трейты, которыми
[24:52.400 --> 24:54.400]  мы до этого пользовались без реализации.
[24:54.400 --> 24:56.400]  А именно, мы сейчас реализуем
[24:56.400 --> 24:58.400]  ну, не сейчас прям,
[24:58.400 --> 25:00.400]  сейчас мы сначала кое-что обсудим.
[25:00.400 --> 25:02.400]  Одну гениальную идею
[25:02.400 --> 25:04.400]  изобретенную, там, еще до 17-19.
[25:04.400 --> 25:06.400]  Вот.
[25:06.400 --> 25:08.400]  Значит, тизер на сегодня.
[25:08.400 --> 25:10.400]  Сегодня мы реализуем с вами
[25:10.400 --> 25:12.400]  compileTime проверку, есть ли в классе
[25:12.400 --> 25:14.400]  такой-то метод.
[25:14.400 --> 25:16.400]  И тем самым поймем
[25:16.400 --> 25:18.400]  окончательно, как работает
[25:18.400 --> 25:20.400]  в локатор trades,
[25:20.400 --> 25:22.400]  которые, если метод есть, вызывают его,
[25:22.400 --> 25:24.400]  а иначе делают не у сами,
[25:24.400 --> 25:26.400]  как вы помните, да.
[25:26.400 --> 25:28.400]  Дальше мы реализуем с вами
[25:28.400 --> 25:30.400]  мета функции
[25:30.400 --> 25:32.400]  из constructable, из convertible,
[25:32.400 --> 25:34.400]  из copyConstructable и moveConstructable.
[25:34.400 --> 25:36.400]  То есть, ну, такие тайп трейты,
[25:36.400 --> 25:38.400]  которые проверяют, существует ли конструктору
[25:38.400 --> 25:40.400]  класса таких-то аргументов и так далее.
[25:40.400 --> 25:42.400]  Можно ли move-нуть этот класс там.
[25:42.400 --> 25:44.400]  Дальше мы с вами реализуем проверку
[25:44.400 --> 25:46.400]  из no-from-move-constructable.
[25:46.400 --> 25:48.400]  Правда ли,
[25:48.400 --> 25:50.400]  что данный класс move-ается
[25:50.400 --> 25:52.400]  с noexcept?
[25:52.400 --> 25:54.400]  И как следствие, мы реализуем
[25:54.400 --> 25:56.400]  move of noexcept.
[25:56.400 --> 25:58.400]  Помните, у нас была проблема в векторе,
[25:58.400 --> 26:00.400]  что мы использовали move of noexcept,
[26:00.400 --> 26:02.400]  потому что не могли move просто так,
[26:02.400 --> 26:04.400]  должны move, если noexcept, и копировать иначе.
[26:04.400 --> 26:06.400]  Вот. Сегодня мы реализуем move of noexcept.
[26:06.400 --> 26:08.400]  Ну и реализуем еще
[26:08.400 --> 26:10.400]  из baseof. Проверку, что один класс
[26:10.400 --> 26:12.400]  наследник другого, в том числе, приватный.
[26:14.400 --> 26:16.400]  Вот. Секунду.
[26:16.400 --> 26:18.400]  std из baseof проверяет...
[26:18.400 --> 26:20.400]  std из baseof приватное наследование тоже распознает, да.
[26:20.400 --> 26:22.400]  Ты это уже спрашивал.
[26:22.400 --> 26:24.400]  Сейчас. Это логично, что это?
[26:24.400 --> 26:26.400]  Можем ли мы после этого
[26:26.400 --> 26:28.400]  присвоить... Вот у меня есть
[26:28.400 --> 26:30.400]  два типа u и t. Я проверяю,
[26:30.400 --> 26:32.400]  верно ли, что t, base, от u.
[26:32.400 --> 26:34.400]  Да. И потом пытаюсь
[26:34.400 --> 26:36.400]  к t присвоить u, а он такой ругается.
[26:36.400 --> 26:38.400]  Вы думали, что из baseof распознает приватное наследование?
[26:38.400 --> 26:40.400]  Да. Ну...
[26:40.400 --> 26:42.400]  Вот комитет решил, что
[26:42.400 --> 26:44.400]  для цели std из baseof это логично.
[26:44.400 --> 26:46.400]  Впрочем, c++20
[26:46.400 --> 26:48.400]  они передумали.
[26:48.400 --> 26:50.400]  Ну, нет, замечание очень правильное.
[26:50.400 --> 26:52.400]  Типа, должен ли этот...
[26:52.400 --> 26:54.400]  Функция... Ну, type-trade std
[26:54.400 --> 26:56.400]  из baseof распознает приватное наследование?
[26:56.400 --> 26:58.400]  А вот концепт
[26:58.400 --> 27:00.400]  baseof, который в 20-м появился,
[27:00.400 --> 27:02.400]  он же не распознает приватное наследование.
[27:02.400 --> 27:04.400]  Мы про это поговорим уже в непохожей.
[27:06.400 --> 27:08.400]  Вот, давайте начнем. Вот с чего.
[27:10.400 --> 27:12.400]  Бейсик.
[27:16.400 --> 27:18.400]  Наверное, меня просят, чтобы что-то работало,
[27:18.400 --> 27:20.400]  чтобы кому-то можно было присвоить его наследник.
[27:20.400 --> 27:22.400]  Я же должен это делать только если
[27:22.400 --> 27:24.400]  не приватное наследование.
[27:24.400 --> 27:26.400]  Ну, напиши свой из baseof.
[27:26.400 --> 27:28.400]  Сегодня мы... Нет, мы сегодня
[27:28.400 --> 27:30.400]  поймем, как писать, который распознает.
[27:30.400 --> 27:32.400]  Ну, раз буквально в одной строчке разница.
[27:32.400 --> 27:34.400]  Приватное или не приватное наследование,
[27:34.400 --> 27:36.400]  чтобы он включал false или true.
[27:36.400 --> 27:38.400]  Там, прям, увидишь, это легко.
[27:38.400 --> 27:40.400]  Вот.
[27:40.400 --> 27:42.400]  Ну, хорошо.
[27:42.400 --> 27:44.400]  Начнем
[27:44.400 --> 27:46.400]  с базовых приметилов для
[27:46.400 --> 27:48.400]  шаблонного метапрограммирования.
[27:48.400 --> 27:50.400]  Честно признаться, что
[27:50.400 --> 27:52.400]  вот эта тема, она моя вторая
[27:52.400 --> 27:54.400]  по любимости в курсе после
[27:54.400 --> 27:56.400]  муфсемантики. Я говорю, что муфсемантика
[27:56.400 --> 27:58.400]  любимая тема. Вот эта вторая из любимых тем.
[27:58.400 --> 28:00.400]  Это весело. То есть,
[28:00.400 --> 28:02.400]  весело, сейчас увидите. Давайте сначала...
[28:02.400 --> 28:04.400]  Вернитесь к нам.
[28:04.400 --> 28:06.400]  Вот его нет, очень жаль.
[28:06.400 --> 28:08.400]  Прям максимально так, что его сегодня нет.
[28:08.400 --> 28:10.400]  Я просто... Я мечтал
[28:10.400 --> 28:12.400]  наконец-то послушать его комментарии
[28:12.400 --> 28:14.400]  об этом, когда он его услышит. Видимо, мы не обним
[28:14.400 --> 28:16.400]  знаем его мнениях по этому вопросу.
[28:16.400 --> 28:18.400]  Значит...
[28:18.400 --> 28:20.400]  Очень жаль, конечно.
[28:20.400 --> 28:22.400]  Очень жаль, что я не услышу этих
[28:22.400 --> 28:24.400]  комментариев. Ну, ладно.
[28:26.400 --> 28:28.400]  Смотрите. У нас
[28:28.400 --> 28:30.400]  в чем
[28:30.400 --> 28:32.400]  вообще суть метапрограммирования?
[28:32.400 --> 28:34.400]  Идейно, вкратце. Мы сейчас
[28:34.400 --> 28:36.400]  пишем с вами некоторые функции.
[28:36.400 --> 28:38.400]  Типа функций, вот типов.
[28:38.400 --> 28:40.400]  То есть, мы берем типы
[28:40.400 --> 28:42.400]  и...
[28:42.400 --> 28:44.400]  Какое большее слово
[28:44.400 --> 28:46.400]  тип?
[28:46.400 --> 28:48.400]  Типа функция, типы.
[28:48.400 --> 28:50.400]  Мы берем типы
[28:50.400 --> 28:52.400]  и про них что-то
[28:52.400 --> 28:54.400]  говорить. Например, у нас была
[28:54.400 --> 28:56.400]  совсем простая метафункция
[28:56.400 --> 28:58.400]  Say.
[28:58.400 --> 29:00.400]  Ну...
[29:02.400 --> 29:04.400]  Ну, давайте я там наполню вот совсем
[29:04.400 --> 29:06.400]  быстро, значит. Что... Что делала...
[29:06.400 --> 29:08.400]  Я буду называть их метафункциями.
[29:10.400 --> 29:12.400]  Что делала функция метафункции Say?
[29:12.400 --> 29:14.400]  Там была
[29:16.400 --> 29:18.400]  using...
[29:18.400 --> 29:20.400]  Не using, там был static const
[29:20.400 --> 29:22.400]  bool value
[29:22.400 --> 29:24.400]  равно false.
[29:24.400 --> 29:26.400]  А еще у нее была специализация, которая
[29:26.400 --> 29:28.400]  для одинаковых типов
[29:28.400 --> 29:30.400]  говорила true.
[29:32.400 --> 29:34.400]  Вот. Ну, это все
[29:34.400 --> 29:36.400]  и так знают.
[29:36.400 --> 29:38.400]  Должны знать,
[29:38.400 --> 29:40.400]  по крайней мере.
[29:40.400 --> 29:42.400]  Вот. Ну, и была
[29:42.400 --> 29:44.400]  и saveware.
[29:44.400 --> 29:46.400]  Да, значит...
[29:46.400 --> 29:48.400]  Которая просто говорила,
[29:48.400 --> 29:50.400]  что...
[29:50.400 --> 29:52.400]  Это была
[29:52.400 --> 29:54.400]  булевская константа.
[29:54.400 --> 29:56.400]  Вот это метафункция,
[29:56.400 --> 29:58.400]  которая принимает два типа и возвращает
[29:58.400 --> 30:00.400]  bool.
[30:00.400 --> 30:02.400]  Есть... Бывают и другие
[30:02.400 --> 30:04.400]  метафункции, которые...
[30:04.400 --> 30:06.400]  Ну, например,
[30:06.400 --> 30:08.400]  бывает метафункция, которая принимает
[30:08.400 --> 30:10.400]  bool и возвращает тип.
[30:10.400 --> 30:12.400]  У нас была STD conditional.
[30:12.400 --> 30:14.400]  В зависимости от compiletime
[30:14.400 --> 30:16.400]  условия, либо мы
[30:16.400 --> 30:18.400]  возвращаем один тип, либо другой.
[30:18.400 --> 30:20.400]  Ну, или у нас была еще метафункция
[30:20.400 --> 30:22.400]  там remove reference, например. Вот давайте я
[30:22.400 --> 30:24.400]  напомню, что такое remove reference.
[30:24.400 --> 30:26.400]  Type name t,
[30:28.400 --> 30:30.400]  структура
[30:30.400 --> 30:32.400]  remove
[30:32.400 --> 30:34.400]  reference,
[30:36.400 --> 30:38.400]  которая
[30:42.400 --> 30:44.400]  в себе определяет using type
[30:44.400 --> 30:46.400]  равно t
[30:46.400 --> 30:48.400]  и ее специализация для ссылок,
[30:48.400 --> 30:50.400]  которая
[30:52.400 --> 30:54.400]  делает то же самое,
[30:54.400 --> 30:56.400]  просто убирает
[30:56.400 --> 30:58.400]  интерсант.
[30:58.400 --> 31:00.400]  И ее специализация для двойных
[31:00.400 --> 31:02.400]  ссылок, кстати. Когда мы писали remove
[31:02.400 --> 31:04.400]  reference впервые, мы еще не знали про
[31:04.400 --> 31:06.400]  существование remove, про существование
[31:06.400 --> 31:08.400]  R-value ссылок, поэтому нужна еще такая
[31:08.400 --> 31:10.400]  специализация.
[31:10.400 --> 31:12.400]  Вот. Я все к чему...
[31:12.400 --> 31:14.400]  Здесь это не считается?
[31:14.400 --> 31:16.400]  Универсальной ссылкой?
[31:16.400 --> 31:18.400]  Нет. Ну как?
[31:18.400 --> 31:20.400]  Универсальная ссылка
[31:20.400 --> 31:22.400]  только по параметрам функции обычно.
[31:22.400 --> 31:24.400]  Вот.
[31:24.400 --> 31:26.400]  Я это все к чему? Я к тому,
[31:26.400 --> 31:28.400]  что я сейчас хочу
[31:28.400 --> 31:30.400]  определить несколько примитивов,
[31:30.400 --> 31:32.400]  чтобы нам не приходилось в дальнейшем вот эти вот
[31:32.400 --> 31:34.400]  value и type все время
[31:34.400 --> 31:36.400]  определять.
[31:36.400 --> 31:38.400]  Все это определено в type traits.
[31:38.400 --> 31:40.400]  Во-первых, существует
[31:40.400 --> 31:42.400]  такой
[31:42.400 --> 31:44.400]  примитив,
[31:44.400 --> 31:46.400]  называемый integral constant.
[31:50.400 --> 31:52.400]  Ну, наверное, вот так.
[31:52.400 --> 31:54.400]  Значит...
[31:58.400 --> 32:00.400]  Значит, integral constant...
[32:00.400 --> 32:02.400]  Да, да, да. Значит, у меня
[32:04.400 --> 32:06.400]  struct integral
[32:08.400 --> 32:10.400]  constant.
[32:10.400 --> 32:12.400]  И в ней будет
[32:16.400 --> 32:18.400]  static
[32:18.400 --> 32:20.400]  constant
[32:20.400 --> 32:22.400]  t
[32:22.400 --> 32:24.400]  value
[32:24.400 --> 32:26.400]  равно x.
[32:26.400 --> 32:28.400]  Сейчас я
[32:28.400 --> 32:30.400]  на всякий случай
[32:30.400 --> 32:32.400]  перепроверю.
[32:34.400 --> 32:36.400]  Internet banking. Спасибо.
[32:36.400 --> 32:38.400]  Integral constant.
[32:40.400 --> 32:42.400]  Интернет не работает.
[32:42.400 --> 32:44.400]  Все так.
[32:44.400 --> 32:46.400]  Да, все правильно.
[32:46.400 --> 32:48.400]  А tv, давайте
[32:48.400 --> 32:50.400]  вот.
[32:50.400 --> 32:52.400]  Это такая статическая, ну, по сути,
[32:52.400 --> 32:54.400]  это такая метафункция, которая просто
[32:54.400 --> 32:56.400]  константная функция.
[32:56.400 --> 32:58.400]  Она принимает тип
[32:58.400 --> 33:00.400]  и
[33:00.400 --> 33:02.400]  возвращает
[33:02.400 --> 33:04.400]  какую-то константу этого типа.
[33:04.400 --> 33:06.400]  Вот. И дальше...
[33:06.400 --> 33:08.400]  Почему это все работает?
[33:08.400 --> 33:10.400]  В смысле, что
[33:10.400 --> 33:12.400]  а почему пока здесь не работает?
[33:12.400 --> 33:14.400]  Тебя смущает, что можно так
[33:14.400 --> 33:16.400]  на mttv?
[33:16.400 --> 33:18.400]  Мы-то вообще могли только int
[33:18.400 --> 33:20.400]  запихивать. Ну, в смысле...
[33:20.400 --> 33:22.400]  Ну, t должно быть...
[33:22.400 --> 33:24.400]  Ну, t должно быть таким, понятно, что если изведет sd-вектор,
[33:24.400 --> 33:26.400]  то так это вряд ли сработает.
[33:26.400 --> 33:28.400]  А что должно быть?
[33:28.400 --> 33:30.400]  Ну, вот наиболее типичное
[33:30.400 --> 33:32.400]  использование integral constant. Следующее.
[33:32.400 --> 33:34.400]  У нас сейчас будет такая структура
[33:34.400 --> 33:36.400]  под названием
[33:36.400 --> 33:38.400]  true type.
[33:44.400 --> 33:46.400]  Да, структура true type
[33:46.400 --> 33:48.400]  это будет
[33:48.400 --> 33:50.400]  integral constant
[33:52.400 --> 33:54.400]  от bool
[33:54.400 --> 33:56.400]  и
[33:56.400 --> 33:58.400]  true.
[33:58.400 --> 34:00.400]  Возможно, это юзинг. Наверное,
[34:00.400 --> 34:02.400]  правильно сказать, что это юзинг.
[34:04.400 --> 34:06.400]  Не знаю, честно говоря.
[34:06.400 --> 34:08.400]  Наверное, юзинг все-таки, действительно.
[34:08.400 --> 34:10.400]  Наверное, это в точности такой же тип.
[34:10.400 --> 34:12.400]  А false type,
[34:12.400 --> 34:14.400]  соответственно, это следующее.
[34:14.400 --> 34:16.400]  Это integral constant
[34:16.400 --> 34:18.400]  от bool
[34:18.400 --> 34:20.400]  и false.
[34:22.400 --> 34:24.400]  Теперь, на самом-то деле,
[34:24.400 --> 34:26.400]  вот это все можно не писать.
[34:26.400 --> 34:28.400]  А вместо этого можно просто написать, что
[34:28.400 --> 34:30.400]  isSame, вот тут уже не юзинг,
[34:30.400 --> 34:32.400]  тут уже наследование.
[34:32.400 --> 34:34.400]  Это
[34:34.400 --> 34:36.400]  false type.
[34:36.400 --> 34:38.400]  А isSame
[34:38.400 --> 34:40.400]  от одинаковых типов, это true type,
[34:40.400 --> 34:42.400]  но только надо
[34:42.400 --> 34:44.400]  тело пустое оставить.
[34:44.400 --> 34:46.400]  Сейчас, еще чего-то не нужно случайно.
[34:46.400 --> 34:48.400]  Как
[34:48.400 --> 34:50.400]  им теперь пользоваться?
[34:50.400 --> 34:52.400]  Все, теперь у тебя
[34:52.400 --> 34:54.400]  в isSame от двух разных
[34:54.400 --> 34:56.400]  типов есть value boolev, которое равно
[34:56.400 --> 34:58.400]  false.
[34:58.400 --> 35:00.400]  И isSame v мне все еще придется определить.
[35:00.400 --> 35:02.400]  Да, блин.
[35:02.400 --> 35:04.400]  Type name.
[35:04.400 --> 35:06.400]  Я когда-нибудь
[35:06.400 --> 35:08.400]  я установлю силуэр.
[35:08.400 --> 35:10.400]  Извините, статик,
[35:10.400 --> 35:12.400]  не статик, просто const,
[35:12.400 --> 35:14.400]  const export надо написать.
[35:14.400 --> 35:16.400]  Давайте я пишу const export,
[35:16.400 --> 35:18.400]  пока не совсем хорошо объясняю, что это.
[35:18.400 --> 35:20.400]  Но давайте я буду использовать слово const export
[35:20.400 --> 35:22.400]  иногда все-таки.
[35:22.400 --> 35:24.400]  const export значит константа времени компиляции.
[35:24.400 --> 35:26.400]  const это просто константа,
[35:26.400 --> 35:28.400]  const export константа времени компиляции.
[35:28.400 --> 35:30.400]  const export константа времени компиляции.
[35:30.400 --> 35:32.400]  Пока не будем сильно вдаваться
[35:32.400 --> 35:34.400]  на разницу, но просто вот
[35:34.400 --> 35:36.400]  здесь тоже const export правильно написать.
[35:38.400 --> 35:40.400]  Про const export у нас мы отдельно потом поговорим.
[35:40.400 --> 35:42.400]  Здесь еще где?
[35:42.400 --> 35:44.400]  Ну, статик const export value boolev.
[35:44.400 --> 35:46.400]  Статик const, оно и так
[35:46.400 --> 35:48.400]  const export будет, но
[35:48.400 --> 35:50.400]  скажем, каноничнее написать
[35:50.400 --> 35:52.400]  const export.
[35:52.400 --> 35:54.400]  isSame v
[35:54.400 --> 35:56.400]  равно
[35:56.400 --> 35:58.400]  isSame
[35:58.400 --> 36:00.400]  tu
[36:00.400 --> 36:02.400]  v.
[36:02.400 --> 36:04.400]  Вот, короче, это просто
[36:04.400 --> 36:06.400]  примитивы, через которые мы будем определять.
[36:06.400 --> 36:08.400]  То есть я в дальнейшем не буду писать никогда,
[36:08.400 --> 36:10.400]  вот сейчас мы будем с вами реализовывать всякие метафункции.
[36:10.400 --> 36:12.400]  Я не буду писать
[36:12.400 --> 36:14.400]  статик что-то там boolev
[36:14.400 --> 36:16.400]  or true, или там статик что-то.
[36:16.400 --> 36:18.400]  Нет, я буду просто
[36:18.400 --> 36:20.400]  наследоваться от true type.
[36:20.400 --> 36:22.400]  Когда буду хотеть, чтобы у меня была структура
[36:22.400 --> 36:24.400]  статик const boolev
[36:24.400 --> 36:26.400]  вот
[36:26.400 --> 36:28.400]  вот, теперь ему
[36:28.400 --> 36:30.400]  референс.
[36:32.400 --> 36:34.400]  Здесь
[36:36.400 --> 36:38.400]  а, еще
[36:38.400 --> 36:40.400]  смотрите, еще есть
[36:40.400 --> 36:42.400]  bool
[36:44.400 --> 36:46.400]  bool
[36:46.400 --> 36:48.400]  на, значит я открыл type traits
[36:48.400 --> 36:50.400]  здесь еще есть
[36:50.400 --> 36:52.400]  bool constant
[36:52.400 --> 36:54.400]  bool constant это просто
[36:54.400 --> 36:56.400]  integral constant от boolev
[36:56.400 --> 36:58.400]  типа 17, зачем мы добавили еще bool constant?
[37:08.400 --> 37:10.400]  Давайте посмотрим теперь вот на такое.
[37:12.400 --> 37:14.400]  Чтобы у нас все это сможет было так.
[37:14.400 --> 37:16.400]  Да, да, да.
[37:16.400 --> 37:18.400]  Давайте такое определим метафункцию type identity.
[37:18.400 --> 37:20.400]  Ну, я просто
[37:20.400 --> 37:22.400]  да, перепишу сейчас, чтобы значит
[37:22.400 --> 37:24.400]  следующий примитив, который я буду активно использовать
[37:24.400 --> 37:26.400]  template
[37:26.400 --> 37:28.400]  typeNameT
[37:28.400 --> 37:30.400]  struct
[37:30.400 --> 37:32.400]  typeIdentity
[37:32.400 --> 37:34.400]  это метафункция,
[37:34.400 --> 37:36.400]  которая принимает типа возвращать его же
[37:36.400 --> 37:38.400]  using type
[37:38.400 --> 37:40.400]  равно T.
[37:40.400 --> 37:42.400]  Зачем?
[37:42.400 --> 37:44.400]  Да, чтобы когда мы вот такое определяем
[37:44.400 --> 37:46.400]  мы просто не писали вот это using
[37:46.400 --> 37:48.400]  метафункция, а говорили это typeIdentity
[37:48.400 --> 37:50.400]  от T
[37:50.400 --> 37:52.400]  а здесь мы скажем, что это
[37:52.400 --> 37:54.400]  typeIdentity, ну и здесь мы скажем, что это
[37:54.400 --> 37:56.400]  typeIdentity от T.
[38:02.400 --> 38:04.400]  И здесь мы скажем, что это
[38:04.400 --> 38:06.400]  typeIdentity от T, но наверное проще будет
[38:06.400 --> 38:08.400]  скопировать вот это и 1%
[38:08.400 --> 38:10.400]  убрать.
[38:10.400 --> 38:12.400]  Хорошо.
[38:14.400 --> 38:16.400]  Вот.
[38:22.400 --> 38:24.400]  Еще typeIdentity
[38:24.400 --> 38:26.400]  T.
[38:30.400 --> 38:32.400]  Давайте подумаем,
[38:32.400 --> 38:34.400]  не можем ли мы воспользоваться, чтобы
[38:34.400 --> 38:36.400]  чтобы
[38:36.400 --> 38:38.400]  не писать ему в референс
[38:38.400 --> 38:40.400]  T свое?
[38:42.400 --> 38:44.400]  Боюсь, что нет.
[38:48.400 --> 38:50.400]  Да, ну потому что
[38:50.400 --> 38:52.400]  они догадались,
[38:52.400 --> 38:54.400]  что можно
[39:00.400 --> 39:02.400]  Да, да, да. Ну это просто
[39:04.400 --> 39:06.400]  это примитив, который
[39:06.400 --> 39:08.400]  позволяет сэкономить, не писать вот
[39:08.400 --> 39:10.400]  это вот.
[39:10.400 --> 39:12.400]  Так.
[39:12.400 --> 39:14.400]  Remove Reference T, кажется, мне все равно
[39:14.400 --> 39:16.400]  придется определить.
[39:18.400 --> 39:20.400]  Давайте подумаем,
[39:20.400 --> 39:22.400]  не могу ли я с вами typeIdentity T как-то
[39:22.400 --> 39:24.400]  от Remove Reference T
[39:24.400 --> 39:26.400]  избавиться?
[39:26.400 --> 39:28.400]  У нас может быть using вот мы
[39:28.400 --> 39:30.400]  а ладно, это пресс будет, да.
[39:36.400 --> 39:38.400]  Ну нет, кажется, не могу.
[39:38.400 --> 39:40.400]  Кажется, не могу.
[39:40.400 --> 39:42.400]  Вот.
[39:42.400 --> 39:44.400]  Ну дальше, в принципе, все.
[39:44.400 --> 39:46.400]  Легкое упражнение
[39:46.400 --> 39:48.400]  для вас должно быть теперь реализовать
[39:48.400 --> 39:50.400]  все, ну почти все
[39:50.400 --> 39:52.400]  вот эти вот typeTrait
[39:52.400 --> 39:54.400]  из Function.
[39:54.400 --> 39:56.400]  Вот. Ну. Нет.
[39:56.400 --> 39:58.400]  Из Function это не очень просто.
[39:58.400 --> 40:00.400]  Из pointer.
[40:00.400 --> 40:02.400]  Из array.
[40:02.400 --> 40:04.400]  Из array легко.
[40:04.400 --> 40:06.400]  Специализация для T квадратной
[40:06.400 --> 40:08.400]  скобочки и все.
[40:08.400 --> 40:10.400]  Ну что такое?
[40:10.400 --> 40:12.400]  Секунду, что такое type
[40:12.400 --> 40:14.400]  T квадратной скобочки?
[40:14.400 --> 40:16.400]  Вот тебе реализация STD array.
[40:16.400 --> 40:18.400]  Из array.
[40:18.400 --> 40:20.400]  Общая из array. У тебя общая версия
[40:20.400 --> 40:22.400]  false type, а если у тебя
[40:22.400 --> 40:24.400]  от типа с квадратными скобочками или от квадратных
[40:24.400 --> 40:26.400]  скобочек? Что?
[40:26.400 --> 40:28.400]  Что происходит?
[40:28.400 --> 40:30.400]  Ну что, вот.
[40:30.400 --> 40:32.400]  Чем начались последние две?
[40:32.400 --> 40:34.400]  Ну, вероятно,
[40:34.400 --> 40:36.400]  ну вероятно формально это два разных типа.
[40:36.400 --> 40:38.400]  Тип просто квадрат массив
[40:38.400 --> 40:40.400]  массив от n.
[40:40.400 --> 40:42.400]  Если вам в системах вывода
[40:42.400 --> 40:44.400]  типов есть два разных, да?
[40:44.400 --> 40:46.400]  У нас в специализации может быть больше шаблонных параметров,
[40:46.400 --> 40:48.400]  чем было?
[40:48.400 --> 40:50.400]  Конечно.
[40:50.400 --> 40:52.400]  Почему это все еще специально?
[40:52.400 --> 40:54.400]  Потому что часть лучше покрывает.
[40:54.400 --> 40:56.400]  Сейчас. Главное, что вот здесь вот
[40:56.400 --> 40:58.400]  ты говоришь array.
[40:58.400 --> 41:00.400]  В специализации у тебя один шаблонный параметр.
[41:00.400 --> 41:02.400]  А из array от чего-то конкретного?
[41:04.400 --> 41:06.400]  О господи, да.
[41:06.400 --> 41:08.400]  Я же не говорю из array от A запятая B.
[41:08.400 --> 41:10.400]  Тут мне просто нужно два
[41:10.400 --> 41:12.400]  метапараметра, чтобы объяснить
[41:12.400 --> 41:14.400]  от чего я хочу специализироваться.
[41:16.400 --> 41:18.400]  Ну вот из array. Это просто мы взяли
[41:18.400 --> 41:20.400]  и...
[41:22.400 --> 41:24.400]  Что мы сделали?
[41:24.400 --> 41:26.400]  Мы специализировались
[41:26.400 --> 41:28.400]  для случая, если у нас
[41:30.400 --> 41:32.400]  это массив.
[41:32.400 --> 41:34.400]  Что такое?
[41:34.400 --> 41:36.400]  Ну ПТРТ?
[41:36.400 --> 41:38.400]  Ну ПТРТ это тип,
[41:38.400 --> 41:40.400]  который имеет выражение NullPTR.
[41:42.400 --> 41:44.400]  Это мы в самом начале года обсуждали.
[41:44.400 --> 41:46.400]  У вас есть NullPointer.
[41:46.400 --> 41:48.400]  А зачем?
[41:48.400 --> 41:50.400]  Ну потому что какого типа
[41:50.400 --> 41:52.400]  должен быть NullPTR?
[41:52.400 --> 41:54.400]  Я обнаживаю не одна голос, нормальная.
[41:54.400 --> 41:56.400]  Ну, вот звездочка...
[41:56.400 --> 41:58.400]  Не знаю почему.
[41:58.400 --> 42:00.400]  Вообще в shared BTR можно делать
[42:00.400 --> 42:02.400]  специализацию, когда мы принимаем NullPTR
[42:02.400 --> 42:04.400]  именно через NullPTRT.
[42:04.400 --> 42:06.400]  Отдельно.
[42:06.400 --> 42:08.400]  Ооо!
[42:08.400 --> 42:10.400]  Это идеально.
[42:10.400 --> 42:12.400]  Наверное, просто NullPTRT чуть удобнее,
[42:12.400 --> 42:14.400]  чем void звездочка иметь.
[42:14.400 --> 42:16.400]  Он не явно кастится void звездочкой.
[42:16.400 --> 42:18.400]  Я думаю.
[42:18.400 --> 42:20.400]  Ну это как так передавать.
[42:20.400 --> 42:22.400]  Можно свой так делать.
[42:22.400 --> 42:24.400]  Вот. Как понять?
[42:24.400 --> 42:26.400]  Из void. Ну это просто проверка, что типа
[42:26.400 --> 42:28.400]  из integral.
[42:28.400 --> 42:30.400]  Как реализовать из integral?
[42:30.400 --> 42:32.400]  Ну просто проверить,
[42:32.400 --> 42:34.400]  что это один из следующих.
[42:42.400 --> 42:44.400]  Из floating point, аналогично.
[42:44.400 --> 42:46.400]  Проверить, что он один из
[42:46.400 --> 42:48.400]  этих трех.
[42:48.400 --> 42:50.400]  Очень легко. Из Null.
[42:50.400 --> 42:52.400]  Как реализовать из Null?
[42:56.400 --> 42:58.400]  Боюсь, что никак.
[42:58.400 --> 43:00.400]  Возвредливо.
[43:00.400 --> 43:02.400]  Потому что у нас нет синтеза
[43:02.400 --> 43:04.400]  проверить.
[43:04.400 --> 43:06.400]  Является лететь янумом.
[43:06.400 --> 43:08.400]  К сожалению. По крайней мере, я не знаю.
[43:08.400 --> 43:10.400]  Вот.
[43:10.400 --> 43:12.400]  Возможно...
[43:12.400 --> 43:14.400]  Здесь я должен сделать важную оговорку.
[43:14.400 --> 43:16.400]  Я говорю, что
[43:16.400 --> 43:18.400]  большинство этих вещей легко реализовать.
[43:18.400 --> 43:20.400]  Это простое упражнение,
[43:20.400 --> 43:22.400]  но некоторые из них не могут реализовать.
[43:22.400 --> 43:24.400]  Возможно.
[43:24.400 --> 43:26.400]  Понятно, что некоторые вещи
[43:26.400 --> 43:28.400]  нельзя реализовать на уровне языка,
[43:28.400 --> 43:30.400]  и они вшиты в компилятор.
[43:30.400 --> 43:32.400]  Например, из union и из class
[43:32.400 --> 43:34.400]  нельзя реализовать.
[43:34.400 --> 43:36.400]  Вот проверку из class
[43:36.400 --> 43:38.400]  реализовать нельзя,
[43:38.400 --> 43:40.400]  потому что...
[43:40.400 --> 43:42.400]  Сейчас мы с вами напишем
[43:42.400 --> 43:44.400]  проверку из class o union.
[43:44.400 --> 43:46.400]  Нет. Class и структура
[43:46.400 --> 43:48.400]  ничем не отличаются.
[43:48.400 --> 43:50.400]  Class от union
[43:50.400 --> 43:52.400]  отличить нельзя.
[43:52.400 --> 43:54.400]  Это только компилятор умеет.
[43:54.400 --> 43:56.400]  Из янума, из union, из class
[43:56.400 --> 43:58.400]  только компилятор может.
[43:58.400 --> 44:00.400]  Это внутреннее представление, как реализовывать.
[44:00.400 --> 44:02.400]  А int это class?
[44:02.400 --> 44:04.400]  Int это не class.
[44:04.400 --> 44:06.400]  То есть class — это user-defined
[44:06.400 --> 44:08.400]  либо class, либо структура.
[44:08.400 --> 44:10.400]  Ну да. Но не union.
[44:10.400 --> 44:12.400]  То есть мы можем определить, что это class или union,
[44:12.400 --> 44:14.400]  просто что-то не что-то из built-in types.
[44:14.400 --> 44:16.400]  А enum class тоже class?
[44:16.400 --> 44:18.400]  А...
[44:18.400 --> 44:20.400]  Enum class — это не class. Нет, это не enum.
[44:22.400 --> 44:24.400]  А...
[44:24.400 --> 44:26.400]  Class o union можно определить,
[44:26.400 --> 44:28.400]  как что-то из built-in types.
[44:28.400 --> 44:30.400]  Можно, но можно короче.
[44:30.400 --> 44:32.400]  Мы сейчас разберемся, как.
[44:32.400 --> 44:34.400]  What is function, кстати?
[44:36.400 --> 44:38.400]  Ну, я бы не сказал,
[44:38.400 --> 44:40.400]  что...
[44:40.400 --> 44:42.400]  Ну, идея напросто, много кода, но идея напросто.
[44:42.400 --> 44:44.400]  Как реализована проверка, что нечто является функцией?
[44:44.400 --> 44:46.400]  Rx6...
[44:46.400 --> 44:48.400]  Просто...
[44:48.400 --> 44:50.400]  Сейчас...
[44:52.400 --> 44:54.400]  Почему шесть?
[44:54.400 --> 44:56.400]  Точка.
[44:58.400 --> 45:00.400]  Так.
[45:00.400 --> 45:02.400]  Понятно, что is function
[45:02.400 --> 45:04.400]  общая версия — это false type.
[45:04.400 --> 45:06.400]  Дальше. Is function вот от такого
[45:06.400 --> 45:08.400]  это true type.
[45:08.400 --> 45:10.400]  Я обосновился на этом шаге, честно говоря.
[45:12.400 --> 45:14.400]  Что дальше?
[45:14.400 --> 45:16.400]  Дальше нужно перебрать всевозможные комбинации
[45:16.400 --> 45:18.400]  const volatile, ampersandы,
[45:18.400 --> 45:20.400]  двойные ampersandы,
[45:20.400 --> 45:22.400]  accept, начиная с C++17,
[45:22.400 --> 45:24.400]  но accept является частью сигнатуры,
[45:24.400 --> 45:26.400]  поэтому на accept тоже надо дописывать.
[45:30.400 --> 45:32.400]  Только у нас здесь 2х5 их?
[45:34.400 --> 45:36.400]  Ну...
[45:36.400 --> 45:38.400]  Волотайл — это вещь, которая
[45:40.400 --> 45:42.400]  связана...
[45:42.400 --> 45:44.400]  Ну, в общем...
[45:44.400 --> 45:46.400]  Сирик-валифаеры — это значит,
[45:46.400 --> 45:48.400]  что на тип, наверное, const или volatile.
[45:48.400 --> 45:50.400]  Ну, если вкратце, volatile —
[45:50.400 --> 45:52.400]  это некоторым образом
[45:52.400 --> 45:54.400]  подсказка компилятору,
[45:54.400 --> 45:56.400]  что эта переменная может
[45:56.400 --> 45:58.400]  быть изменена в неожиданный момент,
[45:58.400 --> 46:00.400]  например, другим потоком,
[46:00.400 --> 46:02.400]  поэтому ее нельзя...
[46:02.400 --> 46:04.400]  Обращение к ней нельзя оптимизировать,
[46:04.400 --> 46:06.400]  но это слово...
[46:06.400 --> 46:08.400]  Вероятно, вы это на втором курсе обсудите,
[46:08.400 --> 46:10.400]  когда будете изучать много поточек,
[46:10.400 --> 46:12.400]  мы про это не говорим,
[46:12.400 --> 46:14.400]  но вообще слово volatile устарело, по-моему,
[46:14.400 --> 46:16.400]  C++20, поэтому про него можете вообще...
[46:16.400 --> 46:18.400]  А шесть точек — это что значит?
[46:18.400 --> 46:20.400]  Давайте лучше разберемся, что такое шесть точек.
[46:20.400 --> 46:22.400]  А есть какой-нибудь версии,
[46:22.400 --> 46:24.400]  для чего это?
[46:24.400 --> 46:26.400]  Там будет пакет пакетов.
[46:28.400 --> 46:30.400]  Ну, блин...
[46:30.400 --> 46:32.400]  Интересно.
[46:34.400 --> 46:36.400]  У вас функция может в C-стайле
[46:36.400 --> 46:38.400]  принимать пакет
[46:38.400 --> 46:40.400]  и еще запитать многоточие.
[46:40.400 --> 46:42.400]  У нас же есть C-стайл,
[46:42.400 --> 46:44.400]  переменное количество
[46:44.400 --> 46:46.400]  аргументов для функции.
[46:46.400 --> 46:48.400]  Функция может принимать
[46:48.400 --> 46:50.400]  какие угодно типы,
[46:50.400 --> 46:52.400]  запитая многоточие.
[46:52.400 --> 46:54.400]  Это C-стайл многоточие.
[46:54.400 --> 46:56.400]  Оно означает, что там нужно завести
[46:56.400 --> 46:58.400]  какую-то с лишней структуркой,
[46:58.400 --> 47:00.400]  из нее вычисляется аргумент.
[47:00.400 --> 47:02.400]  Ну, потому что там не обязательно
[47:02.400 --> 47:04.400]  запятую ставить.
[47:04.400 --> 47:06.400]  Ну, ты просто пишешь
[47:06.400 --> 47:08.400]  f от int многоточие,
[47:08.400 --> 47:10.400]  и это означает,
[47:10.400 --> 47:12.400]  что она принимает int
[47:12.400 --> 47:14.400]  и еще что угодно.
[47:14.400 --> 47:16.400]  Вот, то есть, если у тебя функция
[47:16.400 --> 47:18.400]  ну, типа print...
[47:18.400 --> 47:20.400]  А почему не делать так, чтобы там
[47:20.400 --> 47:22.400]  забегать многоточие?
[47:22.400 --> 47:24.400]  Да просто так.
[47:24.400 --> 47:26.400]  В C-м уже сделано, все, больше не ставить.
[47:26.400 --> 47:28.400]  Дядюшка C.
[47:28.400 --> 47:30.400]  Ну вот.
[47:30.400 --> 47:32.400]  Вот для этого 6 точек надо.
[47:32.400 --> 47:34.400]  Хорошо. Ну, из pointerZLLEReference
[47:34.400 --> 47:36.400]  из memberObjectPointer.
[47:36.400 --> 47:38.400]  Что это такое?
[47:38.400 --> 47:40.400]  Негонятно.
[47:40.400 --> 47:42.400]  Указатель на поле.
[47:42.400 --> 47:44.400]  Проверка того, что это указатель на поле.
[47:44.400 --> 47:46.400]  Что это?
[47:46.400 --> 47:48.400]  Что ему можно передать?
[47:48.400 --> 47:50.400]  T является указателем на поле.
[47:52.400 --> 47:54.400]  Ну, давайте сначала
[47:54.400 --> 47:56.400]  из memberPointer просто
[47:56.400 --> 47:58.400]  прочитаем. Что такое из memberPointer?
[47:58.400 --> 48:00.400]  Проверка того,
[48:00.400 --> 48:02.400]  является ли T указателем
[48:02.400 --> 48:04.400]  to non-static member object or pointer,
[48:04.400 --> 48:06.400]  то есть static member function.
[48:06.400 --> 48:08.400]  Ну вот, собственно.
[48:10.400 --> 48:12.400]  В общем,
[48:12.400 --> 48:14.400]  в общем случае
[48:14.400 --> 48:16.400]  это false type,
[48:16.400 --> 48:18.400]  а в частном случае, когда у вас
[48:18.400 --> 48:20.400]  вот такой тип,
[48:22.400 --> 48:24.400]  ну то есть memberPointer,
[48:24.400 --> 48:26.400]  это true type.
[48:26.400 --> 48:28.400]  А зачем?
[48:28.400 --> 48:30.400]  Зачем там
[48:30.400 --> 48:32.400]  наследование типа
[48:32.400 --> 48:34.400]  через код?
[48:34.400 --> 48:36.400]  Потому что
[48:36.400 --> 48:38.400]  чтобы не перебирать всевозможные
[48:38.400 --> 48:40.400]  видимо, и волатайлы.
[48:44.400 --> 48:46.400]  Пожалуйста, нет для него Максимова.
[48:46.400 --> 48:48.400]  Почему из function не делали?
[48:48.400 --> 48:50.400]  Почему бы из function не делали так?
[48:50.400 --> 48:52.400]  Может там нельзя?
[48:52.400 --> 48:54.400]  А от чего ты removeCV-то сделаешь?
[48:54.400 --> 48:56.400]  От всего.
[48:58.400 --> 49:00.400]  Кстати,
[49:00.400 --> 49:02.400]  почему-то здесь typeName
[49:02.400 --> 49:04.400]  removeCVType, а не removeCVT.
[49:04.400 --> 49:06.400]  Что странно, потому что очевидно же есть
[49:06.400 --> 49:08.400]  removeCVT.
[49:08.400 --> 49:10.400]  Что-то написано до того, как придумали removeCVT.
[49:10.400 --> 49:12.400]  Это потому что, да,
[49:12.400 --> 49:14.400]  потому что видимо это писали до того, как придумали.
[49:14.400 --> 49:16.400]  Можно спросить, почему у нас вот это один тип?
[49:16.400 --> 49:18.400]  Где?
[49:18.400 --> 49:20.400]  Struct из memberPointer helper,
[49:20.400 --> 49:22.400]  tyut, вытащи звездочку.
[49:22.400 --> 49:24.400]  Это один тип?
[49:24.400 --> 49:26.400]  Ну, как ты объявляешь указатели на члены?
[49:26.400 --> 49:28.400]  Я не объявляю указатели на члены.
[49:28.400 --> 49:30.400]  Зря.
[49:32.400 --> 49:34.400]  Ну вот, у тебя есть структура ASP.
[49:34.400 --> 49:36.400]  Я думал, что это просто какой-то костыль.
[49:38.400 --> 49:40.400]  Давай объявим указатель
[49:40.400 --> 49:42.400]  на член структуры.
[49:42.400 --> 49:44.400]  Давайте.
[49:44.400 --> 49:46.400]  Это будет int
[49:46.400 --> 49:48.400]  s
[49:48.400 --> 49:50.400]  2.2. звездочка
[49:50.400 --> 49:52.400]  p равно
[49:52.400 --> 49:54.400]  амберсант s 2.2.x.
[49:54.400 --> 49:56.400]  Какой тип у p?
[49:58.400 --> 50:00.400]  Видимо int 2.2.x.
[50:04.400 --> 50:06.400]  Сейчас узнаем, какой.
[50:06.400 --> 50:08.400]  А, а,
[50:08.400 --> 50:10.400]  крылья тоже урганятся,
[50:10.400 --> 50:12.400]  и мы увидим, на что.
[50:12.400 --> 50:14.400]  Да.
[50:14.400 --> 50:16.400]  Sphinae,
[50:16.400 --> 50:18.400]  ой, не то, не то.
[50:18.400 --> 50:20.400]  StarCityPd211
[50:24.400 --> 50:26.400]  Может быть, даже нужна
[50:28.400 --> 50:30.400]  да, конечно,
[50:30.400 --> 50:32.400]  увидим.
[50:32.400 --> 50:34.400]  Ну, вот, в принципе, мы увидели.
[50:34.400 --> 50:36.400]  Кратко наверт
[50:36.400 --> 50:38.400]  вот такой тип int, правильно?
[50:38.400 --> 50:40.400]  Ну, у тебя нужно, у тебя два параллитета.
[50:40.400 --> 50:42.400]  Вот этот вот table.
[50:42.400 --> 50:44.400]  Его можно принять? Можно функцию f, пожалуйста, принять вот это?
[50:44.400 --> 50:46.400]  Конечно.
[50:46.400 --> 50:48.400]  Замаста.
[50:48.400 --> 50:50.400]  Нет, без авто.
[50:50.400 --> 50:52.400]  Я не собирался.
[50:52.400 --> 50:54.400]  Нет, я бы сказал авто, я не против, можно.
[50:54.400 --> 50:56.400]  Пожалуйста.
[50:56.400 --> 50:58.400]  Это будет указатель на член структуры.
[50:58.400 --> 51:00.400]  И ему точку звездочку можно прибелять.
[51:02.400 --> 51:04.400]  Где он?
[51:04.400 --> 51:06.400]  Там где-то.
[51:06.400 --> 51:08.400]  Так, а что у меня не так-то?
[51:08.400 --> 51:10.400]  Они закрыты.
[51:10.400 --> 51:12.400]  Вот здесь.
[51:12.400 --> 51:14.400]  Все, теперь все нормально.
[51:14.400 --> 51:16.400]  Ну, понятно.
[51:16.400 --> 51:18.400]  Нет, ленивое.
[51:18.400 --> 51:20.400]  Ага, понятно.
[51:20.400 --> 51:22.400]  Ну вот, специализация
[51:22.400 --> 51:24.400]  для такой штуки.
[51:24.400 --> 51:26.400]  Так.
[51:26.400 --> 51:28.400]  Так,
[51:28.400 --> 51:30.400]  ну, что еще здесь имеет смысл?
[51:30.400 --> 51:32.400]  Ну, мы не поняли, там мы использовали member function.
[51:32.400 --> 51:34.400]  Да, member function pointer, давайте посмотрим.
[51:34.400 --> 51:36.400]  Как отличать?
[51:36.400 --> 51:38.400]  Потому что это, а, member и еще это function,
[51:38.400 --> 51:40.400]  что-нибудь такое.
[51:40.400 --> 51:42.400]  Ну да.
[51:42.400 --> 51:44.400]  Значит, как понять,
[51:44.400 --> 51:46.400]  что это member function?
[51:46.400 --> 51:48.400]  У нас, кажется,
[51:48.400 --> 51:50.400]  была специализирована для...
[51:50.400 --> 51:52.400]  А там же
[51:52.400 --> 51:54.400]  именно, там так, ну,
[51:54.400 --> 51:56.400]  у нас тип выглядит, что нам не нужно специализировать.
[51:56.400 --> 51:58.400]  Потому что t является member function.
[51:58.400 --> 52:00.400]  А, ну да, если мы...
[52:00.400 --> 52:02.400]  Это является просто function.
[52:02.400 --> 52:04.400]  Да-да-да.
[52:04.400 --> 52:06.400]  Member to function
[52:06.400 --> 52:08.400]  pointer to function member
[52:10.400 --> 52:12.400]  он подойдет под вот этот вот
[52:12.400 --> 52:14.400]  синтаксис.
[52:14.400 --> 52:16.400]  Когда function писали, у нас же pointer to member
[52:16.400 --> 52:18.400]  попадали в ту специализацию, правильно?
[52:18.400 --> 52:20.400]  Поэтому, чтобы проверить,
[52:20.400 --> 52:22.400]  что мы member function pointer, мы просто проверяем,
[52:22.400 --> 52:24.400]  что мы member
[52:24.400 --> 52:26.400]  pointer и function.
[52:28.400 --> 52:30.400]  Вот.
[52:30.400 --> 52:32.400]  Ну, а
[52:32.400 --> 52:34.400]  чтобы сказать, что мы member object pointer,
[52:34.400 --> 52:36.400]  мы просто говорим, что мы
[52:36.400 --> 52:38.400]  member pointer и не
[52:38.400 --> 52:40.400]  member function pointer.
[52:40.400 --> 52:42.400]  Там показывают,
[52:42.400 --> 52:44.400]  что есть оператор круглой скобочки.
[52:44.400 --> 52:46.400]  Где?
[52:46.400 --> 52:48.400]  У всех этих объектов.
[52:48.400 --> 52:50.400]  У каких объектов?
[52:50.400 --> 52:52.400]  На стримочке.
[52:52.400 --> 52:54.400]  Считается, что
[52:54.400 --> 52:56.400]  там написано, что
[52:56.400 --> 52:58.400]  ему STD integral type
[52:58.400 --> 53:00.400]  есть круглый скобочек, который возвращает его
[53:00.400 --> 53:02.400]  в 2.4.2.
[53:02.400 --> 53:04.400]  Они, видимо, подставят с употреблением.
[53:04.400 --> 53:06.400]  Ну, да. Это не вот. Устранится
[53:06.400 --> 53:08.400]  притара из фаната.
[53:08.400 --> 53:10.400]  Вместо того, чтобы писать STD
[53:10.400 --> 53:12.400]  допустим из array t,
[53:12.400 --> 53:14.400]  можно писать STD из array
[53:14.400 --> 53:16.400]  круглый скобочек.
[53:16.400 --> 53:18.400]  Можно.
[53:18.400 --> 53:20.400]  Э, что?
[53:20.400 --> 53:22.400]  Где?
[53:22.400 --> 53:24.400]  Вот-вот-вот-вот.
[53:24.400 --> 53:26.400]  Синий квадрат.
[53:26.400 --> 53:28.400]  А, это?
[53:28.400 --> 53:30.400]  У integral constant такое есть?
[53:30.400 --> 53:32.400]  Да, 400 круглых скобочек.
[53:32.400 --> 53:34.400]  Сибирь плюс 14 добавили. Клёво, да.
[53:34.400 --> 53:36.400]  Прикольно, я не знал.
[53:38.400 --> 53:40.400]  Ну, это
[53:42.400 --> 53:44.400]  да, чтобы не приходилось
[53:44.400 --> 53:46.400]  писать, надпочеркиваю,
[53:46.400 --> 53:48.400]  чтобы не приходилось писать
[53:48.400 --> 53:50.400]  выточить выдачу value.
[53:50.400 --> 53:52.400]  Нет, ну вместо написания
[53:52.400 --> 53:54.400]  не t, это же integral constant.
[53:54.400 --> 53:56.400]  А, ну вот нельзя, да?
[53:56.400 --> 53:58.400]  Валют просто есть.
[53:58.400 --> 54:00.400]  Не, в тоже можно было.
[54:00.400 --> 54:02.400]  Да, ну, либо ты пишешь
[54:02.400 --> 54:04.400]  не подчерк.
[54:04.400 --> 54:06.400]  Я не уверен, что есть integral constant v.
[54:08.400 --> 54:10.400]  Не уверен.
[54:10.400 --> 54:12.400]  Я думаю, нет.
[54:12.400 --> 54:14.400]  Ну, в общем, да,
[54:14.400 --> 54:16.400]  просто можно круглые скобочки писать.
[54:16.400 --> 54:18.400]  Ну ладно. Так, всё, member object pointer тоже понятно
[54:18.400 --> 54:20.400]  построен. Это просто
[54:20.400 --> 54:22.400]  ну, понятно, это
[54:22.400 --> 54:24.400]  просто integral constant.
[54:24.400 --> 54:26.400]  Сейчас операторы наследуются.
[54:26.400 --> 54:28.400]  Конечно.
[54:28.400 --> 54:30.400]  То есть теперь мы всем можем писать круглые скобочки.
[54:30.400 --> 54:32.400]  Всем, кто наследует integral constant.
[54:32.400 --> 54:34.400]  Вот, это гораздо круче.
[54:34.400 --> 54:36.400]  В этом суть, да.
[54:36.400 --> 54:38.400]  Теперь мы не должны писать
[54:38.400 --> 54:40.400]  надпочерк ни одной нигде.
[54:40.400 --> 54:42.400]  Да, это клёво.
[54:44.400 --> 54:46.400]  Правда же, что
[54:46.400 --> 54:48.400]  функции, которые там
[54:48.400 --> 54:50.400]  в классах, они по сути не явно принимают
[54:50.400 --> 54:52.400]  указатель вот здесь в себя.
[54:52.400 --> 54:54.400]  А это как-то можно, это как-то видно
[54:54.400 --> 54:56.400]  в смысле, из того,
[54:56.400 --> 54:58.400]  как у них тип или что-то такое.
[54:58.400 --> 55:00.400]  Ну, в смысле, ну,
[55:00.400 --> 55:02.400]  вот у них же тип, а там что они принимают?
[55:02.400 --> 55:04.400]  Какие аргументы там будут? Видно, что они не принимают
[55:04.400 --> 55:06.400]  указатель на
[55:06.400 --> 55:08.400]  объект или нет?
[55:08.400 --> 55:10.400]  В смысле,
[55:10.400 --> 55:12.400]  ну, вот, когда мы писали
[55:12.400 --> 55:14.400]  из function, там вот эти арки.
[55:14.400 --> 55:16.400]  У него будет первый? Нет, конечно.
[55:16.400 --> 55:18.400]  Ну, это же скрытно.
[55:18.400 --> 55:20.400]  Ты не...
[55:20.400 --> 55:22.400]  Если бы так работало,
[55:22.400 --> 55:24.400]  то тебе было бы очень неудобно этим пользоваться
[55:24.400 --> 55:26.400]  в нормальных случаях.
[55:26.400 --> 55:28.400]  Когда STD function
[55:28.400 --> 55:30.400]  используешь, ты не хочешь думать о том,
[55:30.400 --> 55:32.400]  что это метод.
[55:32.400 --> 55:34.400]  Ты просто...
[55:36.400 --> 55:38.400]  А, нет, ты как раз должен
[55:38.400 --> 55:40.400]  до этого думать, если у тебя указатель на метод.
[55:40.400 --> 55:42.400]  Если у тебя указатель на метод, да, ты должен
[55:42.400 --> 55:44.400]  это упоминать туда.
[55:44.400 --> 55:46.400]  Если у тебя указатель на метод,
[55:46.400 --> 55:48.400]  то ты первым аргумент придёшь ссылку на
[55:48.400 --> 55:50.400]  объект класса.
[55:50.400 --> 55:52.400]  Можешь себе, к примеру, объяснить?
[55:52.400 --> 55:54.400]  Вот этот? Да.
[55:54.400 --> 55:56.400]  Нет, это книжник.
[55:56.400 --> 55:58.400]  Вот, давай посмотрим.
[55:58.400 --> 56:00.400]  int от... вот что это выражение значит?
[56:00.400 --> 56:02.400]  int от seo
[56:02.400 --> 56:04.400]  2.2.2.2 звёздочка.
[56:04.400 --> 56:06.400]  Вот что это? Seo...
[56:06.400 --> 56:08.400]  С той классы вообще, что это?
[56:08.400 --> 56:10.400]  Ну, вот это означает то же самое,
[56:10.400 --> 56:12.400]  что я писал только без скобочек.
[56:12.400 --> 56:14.400]  Вот так можно делать.
[56:16.400 --> 56:18.400]  Ну...
[56:18.400 --> 56:20.400]  Это...
[56:20.400 --> 56:22.400]  что?
[56:22.400 --> 56:24.400]  Второй скобочек на цикле.
[56:24.400 --> 56:26.400]  Сейчас, нет, это... Нет, нет, нет,
[56:26.400 --> 56:28.400]  виноват, виноват, здесь не так, здесь не так.
[56:28.400 --> 56:30.400]  Дело в том, что это поле.
[56:30.400 --> 56:32.400]  Давайте я метод объявлю.
[56:32.400 --> 56:34.400]  void.je
[56:34.400 --> 56:36.400]  фу
[56:36.400 --> 56:38.400]  от...
[56:38.400 --> 56:40.400]  вот у меня будет int.fu
[56:40.400 --> 56:42.400]  Нет чего.
[56:44.400 --> 56:46.400]  А, тогда как мне объявить указатель на фу?
[56:46.400 --> 56:48.400]  Это будет int.
[56:48.400 --> 56:50.400]  Мне надо указатель на функцию объявить.
[56:52.400 --> 56:54.400]  В обычной ситуации указатели на функцию объявляются так.
[56:54.400 --> 56:56.400]  Я говорю, возвращаемый тип
[56:56.400 --> 56:58.400]  звёздочка
[56:58.400 --> 57:00.400]  pf от чего
[57:00.400 --> 57:02.400]  равно амперсантом
[57:02.400 --> 57:04.400]  f.
[57:04.400 --> 57:06.400]  Ну, вот я могу объявить указатель
[57:06.400 --> 57:08.400]  на вот эту функцию f.
[57:10.400 --> 57:12.400]  А
[57:12.400 --> 57:14.400]  если это указатель на метод,
[57:14.400 --> 57:16.400]  то вот здесь
[57:16.400 --> 57:18.400]  мне как раз в этих скобочках нужно
[57:18.400 --> 57:20.400]  писать s2.2.2 еще.
[57:22.400 --> 57:24.400]  Вот.
[57:28.400 --> 57:30.400]  Вот так.
[57:30.400 --> 57:32.400]  И вот здесь мы просто
[57:32.400 --> 57:34.400]  указатель на метод класса
[57:34.400 --> 57:36.400]  CLS.
[57:36.400 --> 57:38.400]  Мы просто не даём ему имени.
[57:38.400 --> 57:40.400]  Это не важно.
[57:40.400 --> 57:42.400]  Является этот тип
[57:42.400 --> 57:44.400]  int.cls
[57:44.400 --> 57:46.400]  звёздочка
[57:46.400 --> 57:48.400]  указателем на метод.
[57:48.400 --> 57:50.400]  Ну, и он является
[57:50.400 --> 57:52.400]  сигнатурой такая.
[57:52.400 --> 57:54.400]  Да.
[57:54.400 --> 57:56.400]  Вот это...
[57:56.400 --> 57:58.400]  Это всё-таки указатель
[57:58.400 --> 58:00.400]  на член.
[58:00.400 --> 58:02.400]  Если я поставил вот здесь скобочки,
[58:02.400 --> 58:04.400]  но не поставил скобочки
[58:04.400 --> 58:06.400]  после этого, то нормально.
[58:06.400 --> 58:08.400]  Это указатель на объект.
[58:08.400 --> 58:10.400]  А если я вот так написал
[58:10.400 --> 58:12.400]  после этого еще скобочки,
[58:12.400 --> 58:14.400]  то это уже указатель на функцию член.
[58:14.400 --> 58:16.400]  Скобочки нужны, чтобы перечислять
[58:16.400 --> 58:18.400]  то, что он принимает, если он принимает.
[58:18.400 --> 58:20.400]  Ну да, вот эти скобочки всегда и аргументы перечисляют.
[58:22.400 --> 58:24.400]  Красота.
[58:24.400 --> 58:26.400]  Кто придумал это так писать?
[58:26.400 --> 58:28.400]  Это же вообще непонятно.
[58:28.400 --> 58:30.400]  Я не знаю.
[58:30.400 --> 58:32.400]  Создатель
[58:32.400 --> 58:34.400]  страуструб какой-нибудь.
[58:34.400 --> 58:36.400]  Я не уверен, что Таллот придумал.
[58:36.400 --> 58:38.400]  Возможно, он смирился с тем,
[58:38.400 --> 58:40.400]  что кто-то до него уже это придумал.
[58:40.400 --> 58:42.400]  Окей.
[58:42.400 --> 58:44.400]  Да.
[58:44.400 --> 58:46.400]  Так.
[58:46.400 --> 58:48.400]  Ну, в принципе,
[58:48.400 --> 58:50.400]  всё более-менее...
[58:50.400 --> 58:52.400]  Всё очевидное прошло.
[58:52.400 --> 58:54.400]  Всё очевидное закончилось.
[58:54.400 --> 58:56.400]  Давайте только я... ещё вот.
[58:56.400 --> 58:58.400]  Давайте ещё парочку.
[58:58.400 --> 59:00.400]  Все эти вещи, они
[59:00.400 --> 59:02.400]  гораздо более хитро
[59:02.400 --> 59:04.400]  реализуются. Мы сейчас посмотрели на
[59:04.400 --> 59:06.400]  type rate, которые реализуются банально
[59:06.400 --> 59:08.400]  доследованием каких-то базовых проверок
[59:08.400 --> 59:10.400]  integral const.
[59:10.400 --> 59:12.400]  Фактически мы сейчас всё выражаем через the same
[59:12.400 --> 59:14.400]  с какими-то преобразователями.
[59:14.400 --> 59:16.400]  Remove, reference, add, что-нибудь там.
[59:16.400 --> 59:18.400]  И или пишем.
[59:18.400 --> 59:20.400]  Давайте ещё посмотрим вот на такие
[59:20.400 --> 59:22.400]  три
[59:22.400 --> 59:24.400]  полезных вещи.
[59:24.400 --> 59:26.400]  Конъюнция, дизьюнция,
[59:26.400 --> 59:28.400]  отрицание.
[59:29.400 --> 59:31.400]  Смотрите.
[59:31.400 --> 59:33.400]  В смысле? Где? Что? Как? Что?
[59:33.400 --> 59:35.400]  Давайте вот посмотрим на такой замечательный
[59:35.400 --> 59:37.400]  тип метафункции
[59:37.400 --> 59:39.400]  SD convolution.
[59:41.400 --> 59:43.400]  У вас может быть несколько
[59:43.400 --> 59:45.400]  гульевских констант.
[59:45.400 --> 59:47.400]  И вы хотите сделать
[59:47.400 --> 59:49.400]  И по ним по всем.
[59:53.400 --> 59:55.400]  Так.
[59:55.400 --> 59:57.400]  Ну, то есть, например, вы хотите проверить,
[59:57.400 --> 59:59.400]  что все типы в пакете
[59:59.400 --> 01:00:01.400]  аргументов это, не знаю,
[01:00:01.400 --> 01:00:03.400]  ссылки.
[01:00:03.400 --> 01:00:05.400]  Тогда вы говорите
[01:00:05.400 --> 01:00:07.400]  conjunction от
[01:00:07.400 --> 01:00:09.400]  args многоточие
[01:00:09.400 --> 01:00:11.400]  веточие, веточие value.
[01:00:11.400 --> 01:00:13.400]  Ну, conjunction от is
[01:00:15.400 --> 01:00:17.400]  lvalue, reference
[01:00:17.400 --> 01:00:19.400]  от args
[01:00:19.400 --> 01:00:21.400]  веточие, веточие value.
[01:00:21.400 --> 01:00:23.400]  Сейчас. Что?
[01:00:23.400 --> 01:00:25.400]  Можно вопрос? Там?
[01:00:25.400 --> 01:00:27.400]  Ну, давайте я, хорошо,
[01:00:27.400 --> 01:00:29.400]  давайте это напишем. Вот у меня есть
[01:00:29.400 --> 01:00:31.400]  какая-нибудь функция ещё одна, которая
[01:00:31.400 --> 01:00:33.400]  принимает
[01:00:37.400 --> 01:00:39.400]  type name, не знаю,
[01:00:39.400 --> 01:00:41.400]  args.
[01:00:41.400 --> 01:00:43.400]  И она принимает вот там
[01:00:43.400 --> 01:00:45.400]  args многоточие.
[01:00:45.400 --> 01:00:47.400]  Ну и давайте
[01:00:47.400 --> 01:00:49.400]  я что-нибудь проверю про них про все.
[01:00:49.400 --> 01:00:51.400]  Ну, например, я хочу проверить, что все они,
[01:00:51.400 --> 01:00:53.400]  не знаю, константные.
[01:00:53.400 --> 01:00:55.400]  Или все они floating point.
[01:00:57.400 --> 01:00:59.400]  Я говорю
[01:00:59.400 --> 01:01:01.400]  static assert.
[01:01:01.400 --> 01:01:03.400]  Понятно, какой static assert, да?
[01:01:03.400 --> 01:01:05.400]  std
[01:01:05.400 --> 01:01:07.400]  conjunction
[01:01:09.400 --> 01:01:11.400]  v
[01:01:15.400 --> 01:01:17.400]  e
[01:01:19.400 --> 01:01:21.400]  так, из conjunction
[01:01:21.400 --> 01:01:23.400]  v, да, conjunction v, все нормально.
[01:01:23.400 --> 01:01:25.400]  std conjunction v, от чего?
[01:01:27.400 --> 01:01:29.400]  от
[01:01:29.400 --> 01:01:31.400]  std
[01:01:33.400 --> 01:01:35.400]  из
[01:01:35.400 --> 01:01:37.400]  не знаю.
[01:01:39.400 --> 01:01:41.400]  Ну, давайте скажу, is lvalue, reference
[01:01:41.400 --> 01:01:43.400]  от args
[01:01:45.400 --> 01:01:47.400]  многоточие.
[01:01:49.400 --> 01:01:51.400]  Вот.
[01:01:51.400 --> 01:01:53.400]  Что я сделал сейчас?
[01:01:53.400 --> 01:01:55.400]  Я сейчас проверил, правда ли,
[01:01:55.400 --> 01:01:57.400]  что f я вызвал от всех
[01:01:57.400 --> 01:01:59.400]  lvalue.
[01:01:59.400 --> 01:02:01.400]  Ну, например,
[01:02:01.400 --> 01:02:03.400]  int x равно 0, int
[01:02:03.400 --> 01:02:05.400]  y равно 0
[01:02:07.400 --> 01:02:09.400]  и напишу f от x
[01:02:09.400 --> 01:02:11.400]  zeta u.
[01:02:11.400 --> 01:02:13.400]  А здесь напишу
[01:02:13.400 --> 01:02:15.400]  f от, ну, вот
[01:02:15.400 --> 01:02:17.400]  вот это должно быть true.
[01:02:17.400 --> 01:02:19.400]  Я по всем, по всем аргументам
[01:02:19.400 --> 01:02:21.400]  пакета проверил, что они lvalue.reference.
[01:02:21.400 --> 01:02:23.400]  Но если я вызвался
[01:02:23.400 --> 01:02:25.400]  от lvalue, то arg все будут с lvalue
[01:02:25.400 --> 01:02:27.400]  с одним и персантом, правильно?
[01:02:27.400 --> 01:02:29.400]  Вот сейчас должно все
[01:02:29.400 --> 01:02:31.400]  нормально быть.
[01:02:31.400 --> 01:02:33.400]  Нет, не все нормально, а почему
[01:02:33.400 --> 01:02:35.400]  std
[01:02:35.400 --> 01:02:37.400]  lvalue.reference v
[01:02:37.400 --> 01:02:39.400]  conjunction
[01:02:39.400 --> 01:02:41.400]  нет, нет, нет, вроде
[01:02:41.400 --> 01:02:43.400]  там буквы n хочется conjunction.
[01:02:43.400 --> 01:02:45.400]  lvalue.reference без v нужно использовать.
[01:02:45.400 --> 01:02:47.400]  Почему?
[01:02:47.400 --> 01:02:49.400]  Почему?
[01:02:49.400 --> 01:02:51.400]  Потому что он принимает типы,
[01:02:51.400 --> 01:02:53.400]  которые внутри есть value, он их использует.
[01:02:53.400 --> 01:02:55.400]  О, конечно, потому что
[01:02:55.400 --> 01:02:57.400]  не может bool и принимать.
[01:02:57.400 --> 01:02:59.400]  О, все нормально.
[01:02:59.400 --> 01:03:01.400]  Как bool и принимать?
[01:03:01.400 --> 01:03:03.400]  Conjunction должен типы отдать,
[01:03:03.400 --> 01:03:05.400]  а не значения.
[01:03:05.400 --> 01:03:07.400]  А почему я не могу пакет block дать?
[01:03:07.400 --> 01:03:09.400]  А как там написать?
[01:03:09.400 --> 01:03:11.400]  У тебя есть type.
[01:03:11.400 --> 01:03:13.400]  ты не можешь написать bool 3.
[01:03:13.400 --> 01:03:15.400]  bool.bools
[01:03:21.400 --> 01:03:23.400]  Нет, вообще можно было
[01:03:23.400 --> 01:03:25.400]  написать conjunction, которое принимает bool.
[01:03:25.400 --> 01:03:27.400]  Переменное количество
[01:03:27.400 --> 01:03:29.400]  block. Как
[01:03:29.400 --> 01:03:31.400]  принять переменное количество block?
[01:03:31.400 --> 01:03:33.400]  ну
[01:03:33.400 --> 01:03:35.400]  bool.bools
[01:03:37.400 --> 01:03:39.400]  А
[01:03:39.400 --> 01:03:41.400]  syntax такого нет, наверное?
[01:03:41.400 --> 01:03:43.400]  template
[01:03:43.400 --> 01:03:45.400]  нет, сейчас, подождите.
[01:03:45.400 --> 01:03:47.400]  template
[01:03:47.400 --> 01:03:49.400]  есть
[01:03:49.400 --> 01:03:51.400]  а еще, кстати, у нас штук
[01:03:51.400 --> 01:03:53.400]  многоточие, я могу так написать?
[01:03:53.400 --> 01:03:55.400]  О, да.
[01:03:55.400 --> 01:03:57.400]  что, так можно?
[01:03:57.400 --> 01:03:59.400]  в шаблонах можно, да. Прикольно.
[01:03:59.400 --> 01:04:01.400]  У меня может быть переменное количество
[01:04:01.400 --> 01:04:03.400]  аргументов шаблона,
[01:04:03.400 --> 01:04:05.400]  но они не обязательно type name, ну давайте я
[01:04:05.400 --> 01:04:07.400]  может, например, вывернуть
[01:04:07.400 --> 01:04:09.400]  или stconjunction
[01:04:09.400 --> 01:04:11.400]  принимает именно type. Давайте вам покажу
[01:04:11.400 --> 01:04:13.400]  сейчас пример, когда
[01:04:15.400 --> 01:04:17.400]  То есть если мы хотим передать
[01:04:17.400 --> 01:04:19.400]  просто bool, мы можем
[01:04:19.400 --> 01:04:21.400]  вообще этим не пользоваться
[01:04:21.400 --> 01:04:23.400]  и просто... Вот, пожалуйста.
[01:04:23.400 --> 01:04:25.400]  Нет. Вот вам пример.
[01:04:25.400 --> 01:04:27.400]  Штуки, которые принимают
[01:04:27.400 --> 01:04:29.400]  переменное количество вещей, типа
[01:04:29.400 --> 01:04:31.400]  t, ну, это шаблонные аргументы.
[01:04:31.400 --> 01:04:33.400]  ImpagerSequence
[01:04:33.400 --> 01:04:35.400]  Или мы можем просто оператора
[01:04:35.400 --> 01:04:37.400]  n использовать?
[01:04:37.400 --> 01:04:39.400]  А, у нас же есть
[01:04:39.400 --> 01:04:41.400]  уже сейчас
[01:04:43.400 --> 01:04:45.400]  Folded Session
[01:04:45.400 --> 01:04:47.400]  Мы можем здесь использовать
[01:04:47.400 --> 01:04:49.400]  Да, мы можем здесь, в принципе, использовать
[01:04:49.400 --> 01:04:51.400]  все это в круглые скобочки поставить.
[01:04:51.400 --> 01:04:53.400]  Ну, то есть, давайте я это продемонстрирую.
[01:04:53.400 --> 01:04:55.400]  Можно написать так. Мы написать
[01:04:55.400 --> 01:04:57.400]  круглые скобочки, и вторые закрываются.
[01:04:57.400 --> 01:04:59.400]  Estadale, will you reference
[01:04:59.400 --> 01:05:01.400]  V, arcs
[01:05:01.400 --> 01:05:03.400]  и запитая многоточие.
[01:05:03.400 --> 01:05:05.400]  Скобочки закрываются.
[01:05:05.400 --> 01:05:07.400]  Почему запитая?
[01:05:07.400 --> 01:05:09.400]  Ой, не запитая,
[01:05:09.400 --> 01:05:11.400]  а двойной имперсон, конечно.
[01:05:11.400 --> 01:05:13.400]  А почему можно еще одни скобочки?
[01:05:13.400 --> 01:05:15.400]  По синтексу, потому что Folded Expression
[01:05:15.400 --> 01:05:17.400]  требует скобочек.
[01:05:17.400 --> 01:05:19.400]  Своих скобочек.
[01:05:19.400 --> 01:05:21.400]  Ну, можно и так и так, да.
[01:05:21.400 --> 01:05:23.400]  Ну, если вы
[01:05:23.400 --> 01:05:25.400]  метапрограммированием занимаетесь, то
[01:05:25.400 --> 01:05:27.400]  вам удобнее
[01:05:27.400 --> 01:05:29.400]  принимать именно типы в качестве.
[01:05:29.400 --> 01:05:31.400]  То есть вы не работаете с...
[01:05:31.400 --> 01:05:33.400]  Вы стараетесь не работать с константами
[01:05:33.400 --> 01:05:35.400]  числовыми. У вас есть TrueType.
[01:05:35.400 --> 01:05:37.400]  Will you reference это либо TrueType,
[01:05:37.400 --> 01:05:39.400]  либо FalseType. Вы в конжанкцион
[01:05:39.400 --> 01:05:41.400]  отдаете TrueType и FalseType, и возвращает
[01:05:41.400 --> 01:05:43.400]  она вам опять либо TrueType, либо FalseType.
[01:05:43.400 --> 01:05:45.400]  Это просто логично. Почему
[01:05:45.400 --> 01:05:47.400]  в конжанкцион уйдете bool, а отдаете TrueType
[01:05:47.400 --> 01:05:49.400]  и FalseType?
[01:05:49.400 --> 01:05:51.400]  Потому что эта метафункция, она из TrueType
[01:05:51.400 --> 01:05:53.400]  и FalseType делает вам снова либо
[01:05:53.400 --> 01:05:55.400]  TrueType, либо FalseType. Понимаете?
[01:05:55.400 --> 01:05:57.400]  Ну вот, если я сейчас
[01:05:57.400 --> 01:05:59.400]  сделаю f от x запитая 5,
[01:05:59.400 --> 01:06:01.400]  скажем, то будет
[01:06:01.400 --> 01:06:03.400]  f и e.
[01:06:03.400 --> 01:06:05.400]  Static Asosian failed.
[01:06:05.400 --> 01:06:07.400]  Оба причем failed.
[01:06:07.400 --> 01:06:09.400]  Понятно? Почему?
[01:06:09.400 --> 01:06:11.400]  Я не f от x запитая 5,
[01:06:11.400 --> 01:06:13.400]  а f от x запитая 5.
[01:06:13.400 --> 01:06:15.400]  Ну, по правилам
[01:06:15.400 --> 01:06:17.400]  универсальных ссылок,
[01:06:17.400 --> 01:06:19.400]  второй акс стал без ангерсанда,
[01:06:19.400 --> 01:06:21.400]  поэтому конжанкция не сработала.
[01:06:25.400 --> 01:06:27.400]  Вот.
[01:06:27.400 --> 01:06:29.400]  Можно реализовать
[01:06:29.400 --> 01:06:31.400]  а мы с вами реализовывали
[01:06:31.400 --> 01:06:33.400]  например, метафункцию изомоджинирус,
[01:06:33.400 --> 01:06:35.400]  которая проверяет, что все типы
[01:06:35.400 --> 01:06:37.400]  в пакете одинаковые.
[01:06:39.400 --> 01:06:41.400]  А мы...
[01:06:41.400 --> 01:06:43.400]  конжанкшн мы не реализовали.
[01:06:43.400 --> 01:06:45.400]  Конжанкшн мы не реализовали, да.
[01:06:45.400 --> 01:06:47.400]  Но давайте реализуем.
[01:06:47.400 --> 01:06:49.400]  Я не буду писать, наверное,
[01:06:49.400 --> 01:06:51.400]  а то что-то мы долго уже сидим на этом.
[01:06:51.400 --> 01:06:53.400]  Но давайте реализуем.
[01:06:53.400 --> 01:06:55.400]  Давайте конжанкшн
[01:06:55.400 --> 01:06:57.400]  реализуем.
[01:06:57.400 --> 01:06:59.400]  Ну как работает
[01:06:59.400 --> 01:07:01.400]  конжанкшн?
[01:07:01.400 --> 01:07:03.400]  Во времена конжанкшн
[01:07:03.400 --> 01:07:05.400]  занимает квадрат времени компиляции.
[01:07:05.400 --> 01:07:07.400]  Во время компиляции занимает квадрат
[01:07:07.400 --> 01:07:09.400]  количества аргументов.
[01:07:09.400 --> 01:07:11.400]  Давайте подумаем.
[01:07:11.400 --> 01:07:13.400]  Я думаю, что нет.
[01:07:13.400 --> 01:07:15.400]  Конжанкшн, общий случай
[01:07:15.400 --> 01:07:17.400]  это true type, конжанкшн от одного
[01:07:17.400 --> 01:07:19.400]  типа это просто он,
[01:07:19.400 --> 01:07:21.400]  конжанкшн от типа и еще каких-то типов
[01:07:21.400 --> 01:07:23.400]  это conditional,
[01:07:23.400 --> 01:07:25.400]  а значит
[01:07:27.400 --> 01:07:29.400]  если он
[01:07:31.400 --> 01:07:33.400]  если он true
[01:07:33.400 --> 01:07:35.400]  то остальные, иначе он
[01:07:35.400 --> 01:07:37.400]  вот и все.
[01:07:37.400 --> 01:07:39.400]  Причем возвращает первый false type или
[01:07:45.400 --> 01:07:47.400]  Вот. Придется ли
[01:07:47.400 --> 01:07:49.400]  сколько типов придется компилятору
[01:07:49.400 --> 01:07:51.400]  инстанцировать, чтобы вычислить конвьюнцию?
[01:07:51.400 --> 01:07:53.400]  Ну понятно, дело дается.
[01:07:53.400 --> 01:07:55.400]  Эти типы тоже длинные все.
[01:07:55.400 --> 01:07:57.400]  Это никак не влияет
[01:07:57.400 --> 01:07:59.400]  на...
[01:07:59.400 --> 01:08:01.400]  Даже не будет 256,
[01:08:01.400 --> 01:08:03.400]  он запихивает тебя, правда?
[01:08:03.400 --> 01:08:05.400]  Я?
[01:08:07.400 --> 01:08:09.400]  Вполне возможно, что
[01:08:09.400 --> 01:08:11.400]  в принципе так будет снимать.
[01:08:13.400 --> 01:08:15.400]  Может еще помедленнее поработать.
[01:08:15.400 --> 01:08:17.400]  Ну в общем, да,
[01:08:17.400 --> 01:08:19.400]  это не очень эффективно, наверное.
[01:08:19.400 --> 01:08:21.400]  Это правда.
[01:08:21.400 --> 01:08:23.400]  И о чем это?
[01:08:23.400 --> 01:08:25.400]  Ну тебе нужно инстанцировать n типов,
[01:08:25.400 --> 01:08:27.400]  каждый из которых содержит n шаблонных параметров.
[01:08:27.400 --> 01:08:29.400]  То есть ты в этот квадрате всего типов
[01:08:29.400 --> 01:08:31.400]  ну, у тебя как бы
[01:08:31.400 --> 01:08:33.400]  смаражная типа большая.
[01:08:33.400 --> 01:08:35.400]  Ну суммарная длина каких-то типов там довольно большая.
[01:08:37.400 --> 01:08:39.400]  Вот.
[01:08:39.400 --> 01:08:41.400]  Смотрите,
[01:08:41.400 --> 01:08:43.400]  здесь есть примечание.
[01:08:43.400 --> 01:08:45.400]  Short-circuit instantiation
[01:08:45.400 --> 01:08:47.400]  differentiates конвьюнцию
[01:08:47.400 --> 01:08:49.400]  from false expressions.
[01:08:49.400 --> 01:08:51.400]  Кстати, да. О, заметьте.
[01:08:51.400 --> 01:08:53.400]  Чем конвьюнция
[01:08:53.400 --> 01:08:55.400]  лучше, чем вот это?
[01:08:55.400 --> 01:08:57.400]  О, знаете, важное замечание.
[01:08:57.400 --> 01:08:59.400]  Почему использовать conjunction
[01:08:59.400 --> 01:09:01.400]  лучше, чем второе?
[01:09:01.400 --> 01:09:03.400]  Потому что в первом случае
[01:09:03.400 --> 01:09:05.400]  инстанцируется лишь
[01:09:05.400 --> 01:09:07.400]  до первого false type, а во втором случае
[01:09:07.400 --> 01:09:09.400]  инстанцируется все.
[01:09:15.400 --> 01:09:17.400]  Ну смотрите, вот.
[01:09:17.400 --> 01:09:19.400]  Short-circuit instantiation.
[01:09:19.400 --> 01:09:21.400]  Как short-circuit вычтение
[01:09:21.400 --> 01:09:23.400]  гулевских выражений.
[01:09:23.400 --> 01:09:25.400]  Он инстанцирует
[01:09:25.400 --> 01:09:27.400]  только те типы, которые
[01:09:27.400 --> 01:09:29.400]  ну, то есть он говорит
[01:09:29.400 --> 01:09:31.400]  гуль вот от этого
[01:09:31.400 --> 01:09:33.400]  если true,
[01:09:33.400 --> 01:09:35.400]  то нужно инстанцировать конвьюнцию
[01:09:35.400 --> 01:09:37.400]  от вот этих.
[01:09:37.400 --> 01:09:39.400]  Если бы мы упомянули, значит он инстанцируется?
[01:09:39.400 --> 01:09:41.400]  Мы же его написали
[01:09:41.400 --> 01:09:43.400]  в таком виде.
[01:09:43.400 --> 01:09:45.400]  Сейчас.
[01:09:45.400 --> 01:09:47.400]  Вот, когда ты дойдешь до
[01:09:47.400 --> 01:09:49.400]  если видишь, что b1 value это false,
[01:09:49.400 --> 01:09:51.400]  то ты не делаешь
[01:09:51.400 --> 01:09:53.400]  инстанцирование вот этой конвьюнции.
[01:09:53.400 --> 01:09:55.400]  Почему? А она же написана?
[01:09:55.400 --> 01:09:57.400]  Она же написана. Мы уже упомянули так.
[01:09:57.400 --> 01:09:59.400]  Вот в этом и есть short-circuit instantiation.
[01:09:59.400 --> 01:10:01.400]  Капиллятор умеет
[01:10:01.400 --> 01:10:03.400]  short-circuit instantiation. Точно так же, как
[01:10:03.400 --> 01:10:05.400]  как он догадался?
[01:10:05.400 --> 01:10:07.400]  Так он же в compa-time все вычисляет.
[01:10:07.400 --> 01:10:09.400]  Нет, потому что
[01:10:09.400 --> 01:10:11.400]  он догадался
[01:10:11.400 --> 01:10:13.400]  он догадался, в чем смысл
[01:10:13.400 --> 01:10:15.400]  std-conditional-t?
[01:10:15.400 --> 01:10:17.400]  Слушай, он догадался, в чем смысл.
[01:10:17.400 --> 01:10:19.400]  Ему нужно понять, что такое
[01:10:19.400 --> 01:10:21.400]  что за тип std-conditional-t.
[01:10:21.400 --> 01:10:23.400]  А std-conditional-t устроен так.
[01:10:23.400 --> 01:10:25.400]  Если 1 false,
[01:10:25.400 --> 01:10:27.400]  то значит там
[01:10:27.400 --> 01:10:29.400]  если 2...
[01:10:29.400 --> 01:10:31.400]  У std-conditional-t специализация для true и для false.
[01:10:31.400 --> 01:10:33.400]  Он увидел, что false
[01:10:33.400 --> 01:10:35.400]  и не пошел инстанцировать ту версию,
[01:10:35.400 --> 01:10:37.400]  которая для true.
[01:10:37.400 --> 01:10:39.400]  Потому что он увидел, что
[01:10:39.400 --> 01:10:41.400]  чтобы понять std-conditional-t, ему достаточно
[01:10:41.400 --> 01:10:43.400]  понять, что он специализация std-conditional-t для false.
[01:10:43.400 --> 01:10:45.400]  Он инстанцировал только ее, и ему не пришлось
[01:10:45.400 --> 01:10:47.400]  понимать, что std-conditional-t.
[01:10:47.400 --> 01:10:49.400]  У него же шибонным аргументом было
[01:10:49.400 --> 01:10:51.400]  второе, но он его тоже не инстанцировал.
[01:10:51.400 --> 01:10:53.400]  Короче, он слишком умный.
[01:10:53.400 --> 01:10:55.400]  Ну это, блин, это
[01:10:55.400 --> 01:10:57.400]  логично, что он так умеет.
[01:10:57.400 --> 01:10:59.400]  std-conditional-t это
[01:10:59.400 --> 01:11:01.400]  юзер определенная функция практически
[01:11:01.400 --> 01:11:03.400]  шаблонная. Ну то есть он...
[01:11:03.400 --> 01:11:05.400]  Почему тебя это удивляет?
[01:11:05.400 --> 01:11:07.400]  Это логично, что он...
[01:11:07.400 --> 01:11:09.400]  Потому что обычно, если юзер что-то определил, то он ничего не делает.
[01:11:09.400 --> 01:11:11.400]  Это какая-то мгда циклятора.
[01:11:11.400 --> 01:11:13.400]  Ну, почему бы не?
[01:11:13.400 --> 01:11:15.400]  В смысле, это не общая тенденция.
[01:11:15.400 --> 01:11:17.400]  Это просто компилятор такой сел,
[01:11:17.400 --> 01:11:19.400]  подумал, решил, что вот так можно
[01:11:19.400 --> 01:11:21.400]  сделать. Он никому
[01:11:21.400 --> 01:11:23.400]  не обещал, что он... Нет, в смысле, я хочу
[01:11:23.400 --> 01:11:25.400]  сказать, что это логично, это очень...
[01:11:25.400 --> 01:11:27.400]  Это не должно вас удивить. В смысле,
[01:11:27.400 --> 01:11:29.400]  по сути, это мета-аналог
[01:11:31.400 --> 01:11:33.400]  сокращенных вычтений булевских выражений.
[01:11:33.400 --> 01:11:35.400]  Просто аналог вычтений,
[01:11:35.400 --> 01:11:37.400]  в данном случае инстанции. Пришлось
[01:11:37.400 --> 01:11:39.400]  в компиляторе очень много что поменять, чтобы он
[01:11:39.400 --> 01:11:41.400]  так начал делать. Ну, в смысле...
[01:11:41.400 --> 01:11:43.400]  Да я не думал, что много поменять.
[01:11:43.400 --> 01:11:45.400]  Ну, к компилятору нужно
[01:11:45.400 --> 01:11:47.400]  понять, что такое конжанкшн
[01:11:47.400 --> 01:11:49.400]  от ваших типов. Обычно, если вы видите
[01:11:49.400 --> 01:11:51.400]  упоминания какого-то типа, шаблонного,
[01:11:51.400 --> 01:11:53.400]  но вы инстанцируете. Нет.
[01:11:53.400 --> 01:11:55.400]  Ну,
[01:11:55.400 --> 01:11:57.400]  если у тебя переменный число аргументов,
[01:11:57.400 --> 01:11:59.400]  то ты не... Тебе нужно понять,
[01:11:59.400 --> 01:12:01.400]  что... Тебе пользователь сказал,
[01:12:01.400 --> 01:12:03.400]  сделай мне, пожалуйста, конжанкшн от вот этих.
[01:12:03.400 --> 01:12:05.400]  А там написано,
[01:12:05.400 --> 01:12:07.400]  конжанкшн от вот этих, это
[01:12:07.400 --> 01:12:09.400]  если true, то вот этот тип,
[01:12:09.400 --> 01:12:11.400]  иначе этот тип. Так зачем же компилятору
[01:12:11.400 --> 01:12:13.400]  понимать, каким бы типом это было бы,
[01:12:13.400 --> 01:12:15.400]  если бы там было true?
[01:12:15.400 --> 01:12:17.400]  Это полный аналог, фактически шерцорка
[01:12:17.400 --> 01:12:19.400]  для булевских выражений.
[01:12:19.400 --> 01:12:21.400]  Даже если там false, у него все равно
[01:12:21.400 --> 01:12:23.400]  вторым аргументом передается конжанкшн.
[01:12:23.400 --> 01:12:25.400]  Но он...
[01:12:25.400 --> 01:12:27.400]  Он не будет делать его.
[01:12:27.400 --> 01:12:29.400]  Так как он его не использует, он может понять,
[01:12:29.400 --> 01:12:31.400]  что его можно инстанцировать.
[01:12:31.400 --> 01:12:33.400]  Просто проблема в том, что когда вы писали
[01:12:33.400 --> 01:12:35.400]  другую стиль из Prime, вот эту штуку,
[01:12:35.400 --> 01:12:37.400]  там, если то же самое сделать на ней,
[01:12:37.400 --> 01:12:39.400]  ну так нельзя использовать кондиционом,
[01:12:39.400 --> 01:12:41.400]  потому что там не типы.
[01:12:41.400 --> 01:12:43.400]  Поэтому там приходится просто пользоваться
[01:12:43.400 --> 01:12:45.400]  тернарным оператором. И вот если пользоваться
[01:12:45.400 --> 01:12:47.400]  тернарным оператором, то он инстанцирует...
[01:12:47.400 --> 01:12:49.400]  Да, тернарный оператор он инстанцирует,
[01:12:49.400 --> 01:12:51.400]  потому что тернарный оператор это...
[01:12:51.400 --> 01:12:53.400]  это expression.
[01:12:53.400 --> 01:12:55.400]  Если ты в expression упомянул,
[01:12:55.400 --> 01:12:57.400]  то ему нужно инстанцировать все.
[01:12:57.400 --> 01:12:59.400]  Зачем?
[01:12:59.400 --> 01:13:01.400]  Он же может понять, что первое уже true и все?
[01:13:01.400 --> 01:13:03.400]  Нет, тебе нужно понять, какой тип
[01:13:03.400 --> 01:13:05.400]  expression в любом expression.
[01:13:05.400 --> 01:13:07.400]  Если у тебя тернарный оператор написан,
[01:13:07.400 --> 01:13:09.400]  то тебе нужно проверить,
[01:13:09.400 --> 01:13:11.400]  что он вообще корректен, тебе нужно
[01:13:11.400 --> 01:13:13.400]  раз-раз, ну, инстанцировать.
[01:13:13.400 --> 01:13:15.400]  И второй тип,
[01:13:15.400 --> 01:13:17.400]  и третий тип, чтобы понять,
[01:13:17.400 --> 01:13:19.400]  что это за типы реально.
[01:13:19.400 --> 01:13:21.400]  Ну, типа, что в них.
[01:13:21.400 --> 01:13:23.400]  Тебе нужно развернуть шаблоны и рекурсы полностью,
[01:13:23.400 --> 01:13:25.400]  чтобы expression вычислить.
[01:13:25.400 --> 01:13:27.400]  А это не expression, потому что conditional
[01:13:27.400 --> 01:13:29.400]  T, либо этот тип, либо этот тип,
[01:13:29.400 --> 01:13:31.400]  тебе не нужно понимать, что это за тип второй,
[01:13:31.400 --> 01:13:33.400]  тебе достаточно сразу сказать, что это третий тип.
[01:13:33.400 --> 01:13:35.400]  Ты его не инстанцируешь.
[01:13:35.400 --> 01:13:37.400]  Ну, короче, не знаю, почему тебя это делает,
[01:13:37.400 --> 01:13:39.400]  меня это не удивляет.
[01:13:39.400 --> 01:13:41.400]  Ну, по сути спора нет. У нас просто
[01:13:41.400 --> 01:13:43.400]  один удивляет, а другой не удивляет.
[01:13:43.400 --> 01:13:45.400]  Я не знаю.
[01:13:45.400 --> 01:13:47.400]  Все, блин.
[01:13:47.400 --> 01:13:49.400]  Ну, у нас пара, похоже, закончилась первая часть.
[01:13:49.400 --> 01:13:51.400]  Давайте, значит, видим enable live сейчас.
[01:13:51.400 --> 01:13:53.400]  Ну, давайте маленький перерывчик
[01:13:53.400 --> 01:13:55.400]  и про enable live, про
[01:13:55.400 --> 01:13:57.400]  SFINAE поговорим, значит, вот сейчас
[01:13:57.400 --> 01:13:59.400]  все реализуем, как раз оставшиеся.
[01:13:59.400 --> 01:14:01.400]  Ну, перерывчик сейчас делаем,
[01:14:01.400 --> 01:14:03.400]  пойдем.
[01:14:05.400 --> 01:14:07.400]  Значит, идем SFINAE и enable live.
[01:14:09.400 --> 01:14:11.400]  SFINAE расшифровывается
[01:14:11.400 --> 01:14:13.400]  substitution failure
[01:14:13.400 --> 01:14:15.400]  is not an error.
[01:14:17.400 --> 01:14:19.400]  Substitution failure
[01:14:19.400 --> 01:14:21.400]  is
[01:14:21.400 --> 01:14:23.400]  not
[01:14:23.400 --> 01:14:25.400]  an error.
[01:14:25.400 --> 01:14:27.400]  А ошибка
[01:14:27.400 --> 01:14:29.400]  неудачная
[01:14:29.400 --> 01:14:31.400]  шаблонная постановка
[01:14:31.400 --> 01:14:33.400]  не ошибка компиляции.
[01:14:33.400 --> 01:14:35.400]  Давайте я
[01:14:35.400 --> 01:14:37.400]  продемонстрирую на
[01:14:37.400 --> 01:14:39.400]  простейшем примере.
[01:14:39.400 --> 01:14:41.400]  Пусть у меня есть
[01:14:45.400 --> 01:14:47.400]  какие-нибудь две функции,
[01:14:47.400 --> 01:14:49.400]  я их буду называть full.
[01:14:51.400 --> 01:14:53.400]  Вот у меня есть функция
[01:14:55.400 --> 01:14:57.400]  full,
[01:15:01.400 --> 01:15:03.400]  функция, значит,
[01:15:03.400 --> 01:15:05.400]  full,
[01:15:07.400 --> 01:15:09.400]  которая
[01:15:09.400 --> 01:15:11.400]  принимает
[01:15:11.400 --> 01:15:13.400]  темперсант
[01:15:17.400 --> 01:15:19.400]  и возвращает
[01:15:21.400 --> 01:15:23.400]  такое,
[01:15:25.400 --> 01:15:27.400]  что
[01:15:29.400 --> 01:15:31.400]  она будет выводить
[01:15:31.400 --> 01:15:33.400]  один.
[01:15:35.400 --> 01:15:37.400]  А есть еще функция,
[01:15:37.400 --> 01:15:39.400]  которая
[01:15:41.400 --> 01:15:43.400]  вынимает периметы,
[01:15:43.400 --> 01:15:45.400]  периметы
[01:15:45.400 --> 01:15:47.400]  и просто
[01:15:49.400 --> 01:15:51.400]  выводит два.
[01:15:55.400 --> 01:15:57.400]  Сейчас, а стрелочка
[01:15:57.400 --> 01:15:59.400]  вот эта декл-пайка
[01:15:59.400 --> 01:16:01.400]  стрелочка декл-пайка, ну, это
[01:16:01.400 --> 01:16:03.400]  trailing return type, кажется, я про это
[01:16:03.400 --> 01:16:05.400]  говорил когда-то.
[01:16:05.400 --> 01:16:07.400]  Что вместо авто повторять, короче.
[01:16:07.400 --> 01:16:09.400]  Да.
[01:16:09.400 --> 01:16:11.400]  Ну, типа нельзя
[01:16:11.400 --> 01:16:13.400]  на момент.
[01:16:13.400 --> 01:16:15.400]  Почему-то сейчас нельзя.
[01:16:15.400 --> 01:16:17.400]  Нет, можно, я просто trailing return type
[01:16:17.400 --> 01:16:19.400]  такой написал, имею право.
[01:16:19.400 --> 01:16:21.400]  Можно было вместо этого написать декл-тайп
[01:16:21.400 --> 01:16:23.400]  от t-комщика к икс-фу.
[01:16:23.400 --> 01:16:25.400]  Была проблема, когда мы trailing type.
[01:16:25.400 --> 01:16:27.400]  Ну, давайте я так сделаю, чтобы
[01:16:27.400 --> 01:16:29.400]  просто обычно люди пишут так в конце.
[01:16:29.400 --> 01:16:31.400]  Давайте так напишу.
[01:16:33.400 --> 01:16:35.400]  Вот.
[01:16:35.400 --> 01:16:37.400]  И давайте я теперь из мейна
[01:16:37.400 --> 01:16:39.400]  что-нибудь делаю, вызову.
[01:16:39.400 --> 01:16:41.400]  Вот у меня тут как раз...
[01:16:41.400 --> 01:16:43.400]  А будем возвращать что-нибудь
[01:16:43.400 --> 01:16:45.400]  функции, которые должно возвращать?
[01:16:45.400 --> 01:16:47.400]  Или неважно?
[01:16:47.400 --> 01:16:49.400]  Нет.
[01:16:49.400 --> 01:16:51.400]  А что?
[01:16:51.400 --> 01:16:53.400]  Давайте вот так сделаем.
[01:16:57.400 --> 01:16:59.400]  Что происходит?
[01:16:59.400 --> 01:17:01.400]  декл-тайп от чего?
[01:17:05.400 --> 01:17:07.400]  Это жестоко.
[01:17:07.400 --> 01:17:09.400]  Значит, смотрите.
[01:17:09.400 --> 01:17:11.400]  Давайте попробуем.
[01:17:11.400 --> 01:17:13.400]  Это просто жестоко.
[01:17:13.400 --> 01:17:15.400]  Это плюсы.
[01:17:15.400 --> 01:17:17.400]  Ну, это оператор запятая.
[01:17:17.400 --> 01:17:19.400]  Тихий выражение.
[01:17:19.400 --> 01:17:21.400]  Но
[01:17:21.400 --> 01:17:23.400]  подстановка t в этом выражении
[01:17:23.400 --> 01:17:25.400]  заставит его попробовать сделать
[01:17:25.400 --> 01:17:27.400]  t-комщика к икс-фу. Смотрите.
[01:17:27.400 --> 01:17:29.400]  Давайте попробую вызвать эту функцию
[01:17:29.400 --> 01:17:31.400]  от s.
[01:17:31.400 --> 01:17:33.400]  Так, а мы не должны
[01:17:33.400 --> 01:17:35.400]  дополнительно к икс-фу это запятать?
[01:17:35.400 --> 01:17:37.400]  Нет.
[01:17:37.400 --> 01:17:39.400]  Это же запятая. Зачем?
[01:17:39.400 --> 01:17:41.400]  Это же не fold expression.
[01:17:41.400 --> 01:17:43.400]  А если у нас структура, которую мы речь
[01:17:43.400 --> 01:17:45.400]  произведем?
[01:17:45.400 --> 01:17:47.400]  декл-тайп принимает выражение
[01:17:47.400 --> 01:17:49.400]  expression.
[01:17:49.400 --> 01:17:51.400]  В нем есть оператор запятая.
[01:17:55.400 --> 01:17:57.400]  Вот.
[01:17:57.400 --> 01:17:59.400]  А еще я вызову
[01:17:59.400 --> 01:18:01.400]  фу от int.
[01:18:05.400 --> 01:18:07.400]  Смотрите, если я вызываю
[01:18:07.400 --> 01:18:09.400]  фу от объекта s,
[01:18:09.400 --> 01:18:11.400]  то выводится 1.
[01:18:11.400 --> 01:18:13.400]  А если от int, то выводится 2.
[01:18:13.400 --> 01:18:15.400]  Как же это
[01:18:15.400 --> 01:18:17.400]  произошло?
[01:18:21.400 --> 01:18:23.400]  Ну, что...
[01:18:23.400 --> 01:18:25.400]  Как вообще компилятор выбирает
[01:18:25.400 --> 01:18:27.400]  версию? У него есть два варианта.
[01:18:27.400 --> 01:18:29.400]  У него есть вот эта версия перегрузки
[01:18:29.400 --> 01:18:31.400]  и вот эта версия перегрузки. Перегрузка функции.
[01:18:31.400 --> 01:18:33.400]  Какая предпочтительней?
[01:18:33.400 --> 01:18:35.400]  В обоих случаях
[01:18:35.400 --> 01:18:37.400]  предпочтительней первая.
[01:18:37.400 --> 01:18:39.400]  Если она подходит.
[01:18:39.400 --> 01:18:41.400]  Потому что, ну, пока не если,
[01:18:41.400 --> 01:18:43.400]  просто она предпочтительней по правилам
[01:18:43.400 --> 01:18:45.400]  перегрузки. Потому что она принимает один аргумент,
[01:18:45.400 --> 01:18:47.400]  а та принимает переменное количество
[01:18:47.400 --> 01:18:49.400]  аргументов. Первая лучше.
[01:18:51.400 --> 01:18:53.400]  Ну, дальше начинается интересная.
[01:18:53.400 --> 01:18:55.400]  Ну, давайте рассмотрим сначала первый вызов.
[01:18:55.400 --> 01:18:57.400]  Фу от s. Из двух версий
[01:18:57.400 --> 01:18:59.400]  предпочтительно первая. Компилятор выбирает ее.
[01:18:59.400 --> 01:19:01.400]  И ему
[01:19:01.400 --> 01:19:03.400]  нужно понять, какой возвращаемый тип.
[01:19:03.400 --> 01:19:05.400]  Ну, какой возвращаемый тип?
[01:19:05.400 --> 01:19:07.400]  Он говорит... Ну, давайте
[01:19:07.400 --> 01:19:09.400]  даже без запятой для простоты.
[01:19:09.400 --> 01:19:11.400]  С этой запятой мы потом...
[01:19:13.400 --> 01:19:15.400]  Вот так просто я сделаю.
[01:19:15.400 --> 01:19:17.400]  Ой.
[01:19:17.400 --> 01:19:19.400]  А тут будет ретерн.
[01:19:19.400 --> 01:19:21.400]  Тоже ноль.
[01:19:21.400 --> 01:19:23.400]  Ну, тоже int сделаю. Просто чтобы у них
[01:19:23.400 --> 01:19:25.400]  типы возвращаемые были одинаковыми.
[01:19:25.400 --> 01:19:27.400]  Без запятой пока.
[01:19:27.400 --> 01:19:29.400]  Возвращаемый тип. Ну, он пытается понять,
[01:19:29.400 --> 01:19:31.400]  какой тип выражения. Т, круглые скобочки,
[01:19:31.400 --> 01:19:33.400]  точка х. А это int. Значит,
[01:19:33.400 --> 01:19:35.400]  возвращаемый тип int. Все хорошо. Функция выбирается.
[01:19:35.400 --> 01:19:37.400]  Вызывается. Выводится один.
[01:19:37.400 --> 01:19:39.400]  Возвращается ноль. Теперь второй вызов.
[01:19:39.400 --> 01:19:41.400]  Фу вызывается от int.
[01:19:41.400 --> 01:19:43.400]  Предпочитнее первая версия.
[01:19:43.400 --> 01:19:45.400]  Но
[01:19:45.400 --> 01:19:47.400]  компилятор
[01:19:47.400 --> 01:19:49.400]  приходит к неудачной шаблонной
[01:19:49.400 --> 01:19:51.400]  подстановке, когда пытается подставить сюда int.
[01:19:51.400 --> 01:19:53.400]  Потому что
[01:19:53.400 --> 01:19:55.400]  int, круглые скобочки, точка х
[01:19:55.400 --> 01:19:57.400]  это некорректное выражение.
[01:19:57.400 --> 01:19:59.400]  И тут
[01:19:59.400 --> 01:20:01.400]  срабатывают следующие
[01:20:01.400 --> 01:20:03.400]  правила. Если в момент выбора
[01:20:03.400 --> 01:20:05.400]  версии функции
[01:20:05.400 --> 01:20:07.400]  у компилятора случилась
[01:20:07.400 --> 01:20:09.400]  неудачная шаблонная подстановка,
[01:20:09.400 --> 01:20:11.400]  то он не
[01:20:11.400 --> 01:20:13.400]  делает ошибку в компиляции,
[01:20:13.400 --> 01:20:15.400]  а просто выбрасывает эту функцию из кандидатов
[01:20:15.400 --> 01:20:17.400]  и смотрит среди остальных.
[01:20:17.400 --> 01:20:19.400]  Хорошо.
[01:20:19.400 --> 01:20:21.400]  Важно понять, что
[01:20:21.400 --> 01:20:23.400]  ошибка должна случиться именно
[01:20:23.400 --> 01:20:25.400]  в момент выбора версии. То есть,
[01:20:25.400 --> 01:20:27.400]  если я вот здесь напишу
[01:20:27.400 --> 01:20:29.400]  t, круглые скобочки, точка х,
[01:20:29.400 --> 01:20:31.400]  это будет ce.
[01:20:31.400 --> 01:20:33.400]  Так нельзя.
[01:20:33.400 --> 01:20:35.400]  Будет ce сейчас. Сейчас не будет.
[01:20:35.400 --> 01:20:37.400]  Почему? Он выберет.
[01:20:37.400 --> 01:20:39.400]  Он уже выберет.
[01:20:39.400 --> 01:20:41.400]  Вот если бы я здесь
[01:20:41.400 --> 01:20:43.400]  сделал int,
[01:20:43.400 --> 01:20:45.400]  а t, круглые скобочки, точка х
[01:20:49.400 --> 01:20:51.400]  сделал бы просто int.
[01:20:51.400 --> 01:20:53.400]  Да, казалось бы,
[01:20:53.400 --> 01:20:55.400]  первое слово не подходит, но
[01:20:55.400 --> 01:20:57.400]  оно не подходит на этапе каком-то другом.
[01:20:57.400 --> 01:20:59.400]  Да.
[01:20:59.400 --> 01:21:01.400]  Вот если я так сделаю, то
[01:21:01.400 --> 01:21:03.400]  будет ce, потому что
[01:21:03.400 --> 01:21:05.400]  он уже выбрал ее.
[01:21:05.400 --> 01:21:07.400]  И начал инстанцировать тело.
[01:21:07.400 --> 01:21:09.400]  И если в момент инстанцирования
[01:21:09.400 --> 01:21:11.400]  тела он понял, что t – неудачная
[01:21:11.400 --> 01:21:13.400]  подстановка, то это будет ce.
[01:21:13.400 --> 01:21:15.400]  Но если он понял, что это неудачная
[01:21:15.400 --> 01:21:17.400]  подстановка в момент инстанцирования
[01:21:17.400 --> 01:21:19.400]  самого объявления,
[01:21:19.400 --> 01:21:21.400]  то это будет не ce, это просто
[01:21:21.400 --> 01:21:23.400]  выбрасывание версии
[01:21:23.400 --> 01:21:25.400]  из кандидатов и выбор другой,
[01:21:25.400 --> 01:21:27.400]  менее предпочтительный.
[01:21:27.400 --> 01:21:29.400]  Вот этот принцип называется SFINAE.
[01:21:29.400 --> 01:21:31.400]  Это идиом называется SFINAE, то есть
[01:21:31.400 --> 01:21:33.400]  substitution failure is not an error.
[01:21:33.400 --> 01:21:35.400]  Значит, еще раз, если в момент выбора
[01:21:35.400 --> 01:21:37.400]  версии перегрузки компилятор
[01:21:37.400 --> 01:21:39.400]  неудачно подставляет
[01:21:39.400 --> 01:21:41.400]  t,
[01:21:41.400 --> 01:21:43.400]  и в момент инстанцирования
[01:21:45.400 --> 01:21:47.400]  объявления, понимая, что t
[01:21:47.400 --> 01:21:49.400]  не подходит, он не делает так ce.
[01:21:49.400 --> 01:21:51.400]  Как я думал, именно такие правила?
[01:21:51.400 --> 01:21:53.400]  В чем?
[01:21:53.400 --> 01:21:55.400]  Вот нет, почему, когда
[01:21:55.400 --> 01:21:57.400]  в объявлении ошибка всё про...
[01:21:57.400 --> 01:21:59.400]  всё просто принимается в другую функцию,
[01:21:59.400 --> 01:22:01.400]  а когда в теле ошибка...
[01:22:01.400 --> 01:22:03.400]  всё, выбор закончился.
[01:22:03.400 --> 01:22:05.400]  Почему не продолжить выбор
[01:22:05.400 --> 01:22:07.400]  после этого типа?
[01:22:07.400 --> 01:22:09.400]  Я думаю, что это просто разные стадии компиляции.
[01:22:09.400 --> 01:22:11.400]  Тебе нужно сначала понять,
[01:22:11.400 --> 01:22:13.400]  какие тебе версии и функции надо инстанцировать.
[01:22:13.400 --> 01:22:15.400]  У тебя же там объявление в одном месте, а реализация в другом.
[01:22:17.400 --> 01:22:19.400]  Тоже правда.
[01:22:19.400 --> 01:22:21.400]  А, ну или, например, по Apple.
[01:22:21.400 --> 01:22:23.400]  Да, например, по Apple.
[01:22:23.400 --> 01:22:25.400]  Вот.
[01:22:25.400 --> 01:22:27.400]  Ну, в случае шаблонных функций
[01:22:27.400 --> 01:22:29.400]  кажется,
[01:22:29.400 --> 01:22:31.400]  так оно не должно быть.
[01:22:31.400 --> 01:22:33.400]  Скорее я бы сказал, потому что
[01:22:35.400 --> 01:22:37.400]  сначала компилятор понимает, что ему нужно
[01:22:37.400 --> 01:22:39.400]  инстанцировать, потом инстанцирует.
[01:22:39.400 --> 01:22:41.400]  И наоборот, он типа не инстанцирует тело,
[01:22:41.400 --> 01:22:43.400]  пока не считает, что...
[01:22:43.400 --> 01:22:45.400]  Он же типа не инстанцирует функции, которые ни разу не вызовут.
[01:22:45.400 --> 01:22:47.400]  Ну да.
[01:22:47.400 --> 01:22:49.400]  А, он тебе должен обещать.
[01:22:49.400 --> 01:22:51.400]  Короче...
[01:22:51.400 --> 01:22:53.400]  Какая только в этом есть.
[01:22:53.400 --> 01:22:55.400]  Да, могла бы быть другая абсолютно.
[01:22:55.400 --> 01:22:57.400]  Вот, таким образом мы можем
[01:22:57.400 --> 01:22:59.400]  А...
[01:22:59.400 --> 01:23:01.400]  Например.
[01:23:01.400 --> 01:23:03.400]  Добиться
[01:23:03.400 --> 01:23:05.400]  перегрузки функций по принципу
[01:23:05.400 --> 01:23:07.400]  каких-то compile-time-проверяемых условий.
[01:23:09.400 --> 01:23:11.400]  Стоп.
[01:23:11.400 --> 01:23:13.400]  Какая-то чайная мультика стили, нет?
[01:23:13.400 --> 01:23:15.400]  Ну, можно так сказать.
[01:23:15.400 --> 01:23:17.400]  Мы можем написать
[01:23:17.400 --> 01:23:19.400]  такую функцию
[01:23:19.400 --> 01:23:21.400]  enable-if, метафункцию.
[01:23:23.400 --> 01:23:25.400]  Давайте напишем.
[01:23:27.400 --> 01:23:29.400]  enable-if
[01:23:29.400 --> 01:23:31.400]  значит...
[01:23:33.400 --> 01:23:35.400]  значит bool
[01:23:35.400 --> 01:23:37.400]  b
[01:23:37.400 --> 01:23:39.400]  type-name
[01:23:39.400 --> 01:23:41.400]  t
[01:23:41.400 --> 01:23:43.400]  Бейсик юзач не будет?
[01:23:43.400 --> 01:23:45.400]  enable-if. Чего бейсик юзач?
[01:23:45.400 --> 01:23:47.400]  Вот бейсик юзач.
[01:23:47.400 --> 01:23:49.400]  enable-if-то где?
[01:23:49.400 --> 01:23:51.400]  Сначала я реализую enable-if,
[01:23:51.400 --> 01:23:53.400]  потом покажу использование.
[01:23:53.400 --> 01:23:55.400]  Значит, вот здесь
[01:23:55.400 --> 01:23:57.400]  просто пустое тело.
[01:23:59.400 --> 01:24:01.400]  А вот здесь
[01:24:01.400 --> 01:24:03.400]  template
[01:24:03.400 --> 01:24:05.400]  type-name
[01:24:07.400 --> 01:24:09.400]  это гениально.
[01:24:09.400 --> 01:24:11.400]  t
[01:24:11.400 --> 01:24:13.400]  struct enable-if
[01:24:13.400 --> 01:24:15.400]  это гениально, я согласен.
[01:24:15.400 --> 01:24:17.400]  от true.t
[01:24:17.400 --> 01:24:19.400]  это будет type-identity
[01:24:21.400 --> 01:24:23.400]  от t
[01:24:25.400 --> 01:24:27.400]  Господи.
[01:24:27.400 --> 01:24:29.400]  Смотрите, как теперь это можно использовать.
[01:24:31.400 --> 01:24:33.400]  Вот у меня будет функция bar.
[01:24:33.400 --> 01:24:35.400]  Я хочу сделать следующую перегрузку.
[01:24:35.400 --> 01:24:37.400]  Я хочу, чтобы
[01:24:37.400 --> 01:24:39.400]  если я вызываюсь от
[01:24:39.400 --> 01:24:41.400]  ну, скажем,
[01:24:41.400 --> 01:24:43.400]  floating-point type,
[01:24:43.400 --> 01:24:45.400]  то вызывалась... ну, не floating-point,
[01:24:45.400 --> 01:24:47.400]  это чем-то поинтереснее.
[01:24:47.400 --> 01:24:49.400]  Если я вызываюсь от
[01:24:49.400 --> 01:24:51.400]  ну, от класса.
[01:24:51.400 --> 01:24:53.400]  Вот если у меня
[01:24:53.400 --> 01:24:55.400]  пункт, который я вызываюсь, это из класс.
[01:24:55.400 --> 01:24:57.400]  Мы еще пока не реализовали из класс,
[01:24:57.400 --> 01:24:59.400]  но будем считать, что у нас type-thread такой есть.
[01:24:59.400 --> 01:25:01.400]  Из class or union
[01:25:01.400 --> 01:25:03.400]  мы можем реализовать, сейчас реализуем.
[01:25:03.400 --> 01:25:05.400]  Вот из класс, у нас такой type-thread
[01:25:05.400 --> 01:25:07.400]  есть в библиотеке. Вот смотрите,
[01:25:07.400 --> 01:25:09.400]  я хочу, чтобы функция, если у меня это класс,
[01:25:09.400 --> 01:25:11.400]  то вызывалась одна версия.
[01:25:11.400 --> 01:25:13.400]  Если не класс, то другая.
[01:25:13.400 --> 01:25:15.400]  Я пишу void, ну,
[01:25:15.400 --> 01:25:17.400]  template
[01:25:17.400 --> 01:25:19.400]  template, пока просто не пишу,
[01:25:19.400 --> 01:25:21.400]  void bar
[01:25:21.400 --> 01:25:23.400]  от const c&
[01:25:23.400 --> 01:25:25.400]  и здесь
[01:25:25.400 --> 01:25:27.400]  буду выводить
[01:25:27.400 --> 01:25:29.400]  stdl
[01:25:29.400 --> 01:25:31.400]  чего?
[01:25:31.400 --> 01:25:33.400]  1
[01:25:33.400 --> 01:25:35.400]  ну,
[01:25:35.400 --> 01:25:37.400]  вот так буду говорить.
[01:25:37.400 --> 01:25:39.400]  А если меня вызвали не
[01:25:39.400 --> 01:25:41.400]  от класса,
[01:25:41.400 --> 01:25:43.400]  то...
[01:25:43.400 --> 01:25:45.400]  template type-name
[01:25:45.400 --> 01:25:47.400]  template type-name какой-нибудь
[01:25:47.400 --> 01:25:49.400]  где-нибудь, что-то с.
[01:25:49.400 --> 01:25:51.400]  Да-да-да, template сейчас сделаю.
[01:25:57.400 --> 01:25:59.400]  Значит,
[01:25:59.400 --> 01:26:01.400]  c это будет шаблонный параметр.
[01:26:11.400 --> 01:26:13.400]  Вот, как мне добиться того,
[01:26:13.400 --> 01:26:15.400]  чтобы у меня
[01:26:15.400 --> 01:26:17.400]  секундочку,
[01:26:17.400 --> 01:26:19.400]  я понимаю, что можно написать template класс
[01:26:19.400 --> 01:26:21.400]  c, но ничего не поменяется.
[01:26:21.400 --> 01:26:23.400]  Ничего не поменяется.
[01:26:23.400 --> 01:26:25.400]  То есть в качестве класс inc подойдет
[01:26:25.400 --> 01:26:27.400]  здесь, а здесь нет.
[01:26:27.400 --> 01:26:29.400]  Как мне сделать так, чтобы у меня
[01:26:29.400 --> 01:26:31.400]  в одном случае вызывалась
[01:26:31.400 --> 01:26:33.400]  первая версия, в другом
[01:26:33.400 --> 01:26:35.400]  вторая, если у меня в одном случае
[01:26:35.400 --> 01:26:37.400]  класс, в другом нет.
[01:26:37.400 --> 01:26:39.400]  Я могу сделать, конечно, это с помощью
[01:26:39.400 --> 01:26:41.400]  трюка, ну, я могу сделать, чтобы она
[01:26:41.400 --> 01:26:43.400]  была предпочтительнее другой. То есть, что я
[01:26:43.400 --> 01:26:45.400]  делаю? Я говорю, например,
[01:26:45.400 --> 01:26:47.400]  ну, типа, здесь я скажу, что
[01:26:47.400 --> 01:26:49.400]  у меня еще есть какое-нибудь
[01:26:49.400 --> 01:26:51.400]  переменное количество аргументов.
[01:26:51.400 --> 01:26:53.400]  Ну, это пока плохо.
[01:26:53.400 --> 01:26:55.400]  Я говорю,
[01:26:55.400 --> 01:26:57.400]  я хочу, чтобы первая версия была предпочтительнее,
[01:26:57.400 --> 01:26:59.400]  а вторая нет. Но если первая не получилась
[01:26:59.400 --> 01:27:01.400]  вызвать, так, чтобы это вызвать вторую.
[01:27:01.400 --> 01:27:03.400]  А что мне надо написать, чтобы первая
[01:27:03.400 --> 01:27:05.400]  отваливалась в случае, когда это не
[01:27:05.400 --> 01:27:07.400]  класс? Войдет, ну, что-то
[01:27:07.400 --> 01:27:09.400]  запятая войдет в качестве возвращаемого типа.
[01:27:11.400 --> 01:27:13.400]  Вторым аргументом принять утип
[01:27:13.400 --> 01:27:15.400]  Да!
[01:27:15.400 --> 01:27:17.400]  Давайте я только сделаю
[01:27:17.400 --> 01:27:19.400]  template, значит,
[01:27:19.400 --> 01:27:21.400]  bool b, type name
[01:27:21.400 --> 01:27:23.400]  t,
[01:27:23.400 --> 01:27:25.400]  using enable
[01:27:25.400 --> 01:27:27.400]  if t равно
[01:27:27.400 --> 01:27:29.400]  enable if
[01:27:29.400 --> 01:27:31.400]  от
[01:27:31.400 --> 01:27:33.400]  bsp t 2.2.type
[01:27:33.400 --> 01:27:35.400]  type
[01:27:35.400 --> 01:27:37.400]  type name
[01:27:37.400 --> 01:27:39.400]  еще.
[01:27:39.400 --> 01:27:41.400]  То есть, интересная штука, в большинстве
[01:27:41.400 --> 01:27:43.400]  напишу type name равно
[01:27:45.400 --> 01:27:47.400]  enable if
[01:27:47.400 --> 01:27:49.400]  t
[01:27:55.400 --> 01:27:57.400]  type name по умолчанию. Да, я могу
[01:27:57.400 --> 01:27:59.400]  сказать type name
[01:27:59.400 --> 01:28:01.400]  какой-то, но я не собираюсь
[01:28:01.400 --> 01:28:03.400]  его использовать, поэтому я просто скажу, что он
[01:28:03.400 --> 01:28:05.400]  по умолчанию равен такому, но имя ему не дам.
[01:28:05.400 --> 01:28:07.400]  Вот, enable if
[01:28:07.400 --> 01:28:09.400]  t
[01:28:09.400 --> 01:28:11.400]  что?
[01:28:11.400 --> 01:28:13.400]  из класс в
[01:28:13.400 --> 01:28:15.400]  от c
[01:28:15.400 --> 01:28:17.400]  стд из класс
[01:28:17.400 --> 01:28:19.400]  из класс в
[01:28:19.400 --> 01:28:21.400]  от c
[01:28:21.400 --> 01:28:23.400]  и все.
[01:28:23.400 --> 01:28:25.400]  Запятая еще не нужна.
[01:28:25.400 --> 01:28:27.400]  Вот, запятая не нужна, вот здесь обычно пишут
[01:28:27.400 --> 01:28:29.400]  равно void по умолчанию.
[01:28:29.400 --> 01:28:31.400]  То есть, я могу
[01:28:31.400 --> 01:28:33.400]  в enable if не давать
[01:28:33.400 --> 01:28:35.400]  никакой
[01:28:35.400 --> 01:28:37.400]  тип
[01:28:37.400 --> 01:28:39.400]  ну,
[01:28:39.400 --> 01:28:41.400]  ты можешь хотеть там, если вот эту
[01:28:41.400 --> 01:28:43.400]  штуку там, ты хочешь использовать не в таком
[01:28:43.400 --> 01:28:45.400]  контексте, а в какой-нибудь другом, чтобы действительно у тебя там
[01:28:45.400 --> 01:28:47.400]  enable if тебе какой-то тип
[01:28:47.400 --> 01:28:49.400]  возвращал, но на самом деле обычно
[01:28:49.400 --> 01:28:51.400]  тебе не надо, чтобы enable if возвращал тип, поэтому
[01:28:51.400 --> 01:28:53.400]  здесь я пишу type name t равно void
[01:28:53.400 --> 01:28:55.400]  и
[01:28:55.400 --> 01:28:57.400]  здесь у меня шаблонный аргумент по умолчанию
[01:28:59.400 --> 01:29:01.400]  чтобы это легче парсивалось, я, наверное, тут
[01:29:01.400 --> 01:29:03.400]  как-нибудь вот так сделаю
[01:29:05.400 --> 01:29:07.400]  и вот это будет закрывающая угловая скотка
[01:29:07.400 --> 01:29:09.400]  вот здесь.
[01:29:11.400 --> 01:29:13.400]  Теперь к чему это приведет?
[01:29:13.400 --> 01:29:15.400]  Это приведет к тому, что
[01:29:15.400 --> 01:29:17.400]  ну, вот если я вызову сейчас
[01:29:17.400 --> 01:29:19.400]  бар от s и бар от 1
[01:29:23.400 --> 01:29:25.400]  в одном случае я попаду
[01:29:25.400 --> 01:29:27.400]  в первую версию, то есть
[01:29:27.400 --> 01:29:29.400]  бар от s пытается выбрать
[01:29:29.400 --> 01:29:31.400]  эту, потому что она предпочтительней
[01:29:31.400 --> 01:29:33.400]  и пытается ее инстанцировать объявление
[01:29:33.400 --> 01:29:35.400]  но по умолчанию она подставляет в качестве второго
[01:29:35.400 --> 01:29:37.400]  type name enable if от вот этого
[01:29:37.400 --> 01:29:39.400]  но это же
[01:29:39.400 --> 01:29:41.400]  ну, но это в труб, поэтому все нормально
[01:29:41.400 --> 01:29:43.400]  ничего не отваливается и
[01:29:43.400 --> 01:29:45.400]  я вызываю бар от s
[01:29:45.400 --> 01:29:47.400]  первая версия предпочтительней
[01:29:47.400 --> 01:29:49.400]  потому что?
[01:29:49.400 --> 01:29:51.400]  потому что она принимает один аргумент
[01:29:51.400 --> 01:29:53.400]  а, сейчас она старается принимать, а это запятая триточка
[01:29:53.400 --> 01:29:55.400]  это сично
[01:29:55.400 --> 01:29:57.400]  да
[01:29:57.400 --> 01:29:59.400]  ну и все
[01:29:59.400 --> 01:30:01.400]  если я вызываю бар от 1
[01:30:01.400 --> 01:30:03.400]  то первая отваливается, потому что вот эта
[01:30:03.400 --> 01:30:05.400]  enable if t некорректна
[01:30:05.400 --> 01:30:07.400]  там нет type
[01:30:07.400 --> 01:30:09.400]  вот в этом месте некорректна, там нет type
[01:30:09.400 --> 01:30:11.400]  в этом enable if, который от false
[01:30:11.400 --> 01:30:13.400]  поэтому придется выбрать
[01:30:13.400 --> 01:30:15.400]  вторую, давайте проверим
[01:30:15.400 --> 01:30:17.400]  у меня цени достаточно
[01:30:17.400 --> 01:30:19.400]  он не может выбрать, потому что я не имею
[01:30:23.400 --> 01:30:25.400]  возможно ему
[01:30:25.400 --> 01:30:27.400]  но, сично
[01:30:27.400 --> 01:30:29.400]  вот можно перегрузить
[01:30:29.400 --> 01:30:31.400]  так, сейчас
[01:30:31.400 --> 01:30:33.400]  почему у меня
[01:30:33.400 --> 01:30:35.400]  что?
[01:30:35.400 --> 01:30:37.400]  что-то не то
[01:30:37.400 --> 01:30:39.400]  что?
[01:30:39.400 --> 01:30:41.400]  может фу выкинуть вообще?
[01:30:41.400 --> 01:30:43.400]  55, нет, неинтересно, что сейчас не то
[01:30:43.400 --> 01:30:45.400]  инт лишним
[01:30:45.400 --> 01:30:47.400]  а
[01:30:47.400 --> 01:30:49.400]  да, спасибо
[01:30:49.400 --> 01:30:51.400]  но
[01:30:51.400 --> 01:30:53.400]  это не меняется
[01:30:53.400 --> 01:30:55.400]  окей, давайте здесь сделаем
[01:30:55.400 --> 01:30:57.400]  многоточие args
[01:30:59.400 --> 01:31:01.400]  первый c и потом args
[01:31:01.400 --> 01:31:03.400]  или не важно
[01:31:03.400 --> 01:31:05.400]  ну, args
[01:31:05.400 --> 01:31:07.400]  вот так, просто сделаем
[01:31:07.400 --> 01:31:09.400]  сейчас точно нужно быть нормально
[01:31:09.400 --> 01:31:11.400]  вот
[01:31:11.400 --> 01:31:13.400]  все сработало
[01:31:13.400 --> 01:31:15.400]  ну вообще
[01:31:15.400 --> 01:31:17.400]  вообще
[01:31:17.400 --> 01:31:19.400]  можно и вот так написать
[01:31:19.400 --> 01:31:21.400]  просто здесь я напишу
[01:31:21.400 --> 01:31:23.400]  тут не есть класс
[01:31:29.400 --> 01:31:31.400]  а это будет работать?
[01:31:31.400 --> 01:31:33.400]  должно работать
[01:31:33.400 --> 01:31:35.400]  args убить, пожалуйста
[01:31:35.400 --> 01:31:37.400]  что?
[01:31:37.400 --> 01:31:39.400]  а вообще
[01:31:39.400 --> 01:31:41.400]  его удалить надо
[01:31:41.400 --> 01:31:43.400]  блин, не работает
[01:31:43.400 --> 01:31:45.400]  очень жаль
[01:31:45.400 --> 01:31:47.400]  потому что у него
[01:31:47.400 --> 01:31:49.400]  две функции
[01:31:49.400 --> 01:31:51.400]  с одинаковым набором аргументов, конечно
[01:31:51.400 --> 01:31:53.400]  это плохо
[01:32:01.400 --> 01:32:03.400]  да
[01:32:03.400 --> 01:32:05.400]  у меня
[01:32:05.400 --> 01:32:07.400]  не получился
[01:32:07.400 --> 01:32:09.400]  да
[01:32:09.400 --> 01:32:11.400]  так нехорошо
[01:32:11.400 --> 01:32:13.400]  давайте
[01:32:13.400 --> 01:32:15.400]  возможно здесь есть
[01:32:15.400 --> 01:32:17.400]  более красивый пример
[01:32:17.400 --> 01:32:19.400]  с enabled form
[01:32:35.400 --> 01:32:37.400]  не знаю
[01:32:37.400 --> 01:32:39.400]  красивый ли это пример
[01:32:53.400 --> 01:32:55.400]  да, common mistake
[01:32:55.400 --> 01:32:57.400]  вот я сейчас совершил common mistake
[01:32:57.400 --> 01:32:59.400]  common mistake is to declare two function templates
[01:32:59.400 --> 01:33:01.400]  that differ only in their default template arguments
[01:33:01.400 --> 01:33:03.400]  this does not work
[01:33:03.400 --> 01:33:05.400]  because the declarations are filled with other declarations
[01:33:05.400 --> 01:33:07.400]  да
[01:33:09.400 --> 01:33:11.400]  какой театр
[01:33:11.400 --> 01:33:13.400]  может
[01:33:13.400 --> 01:33:15.400]  сейчас
[01:33:15.400 --> 01:33:17.400]  я поправлю
[01:33:17.400 --> 01:33:19.400]  я сейчас справлю
[01:33:19.400 --> 01:33:21.400]  my common mistake
[01:33:21.400 --> 01:33:23.400]  вот так, что это за синтез?
[01:33:25.400 --> 01:33:27.400]  кому-то что-то присвоили
[01:33:27.400 --> 01:33:29.400]  ну это слова
[01:33:29.400 --> 01:33:31.400]  пускай им название
[01:33:31.400 --> 01:33:33.400]  а, это
[01:33:33.400 --> 01:33:35.400]  это же шаблонный аргумент
[01:33:35.400 --> 01:33:37.400]  у него есть значение
[01:33:37.400 --> 01:33:39.400]  по молчанию true
[01:33:39.400 --> 01:33:41.400]  enabled ft это тоже
[01:33:41.400 --> 01:33:43.400]  блин, блин
[01:33:43.400 --> 01:33:45.400]  сейчас, у меня там тип не тот
[01:33:45.400 --> 01:33:47.400]  мне нужно сделать bool
[01:33:47.400 --> 01:33:49.400]  да
[01:33:51.400 --> 01:33:53.400]  вот
[01:33:53.400 --> 01:33:55.400]  вот так
[01:33:55.400 --> 01:33:57.400]  класс
[01:33:57.400 --> 01:33:59.400]  enabled ft
[01:33:59.400 --> 01:34:01.400]  вот здесь скобка закрылась, равно true вот здесь
[01:34:01.400 --> 01:34:03.400]  да, вот так
[01:34:03.400 --> 01:34:05.400]  все работает
[01:34:09.400 --> 01:34:11.400]  очень так себе
[01:34:15.400 --> 01:34:17.400]  это типа написано как лучший пример использования
[01:34:17.400 --> 01:34:19.400]  enabled ft
[01:34:19.400 --> 01:34:21.400]  не лучший, а базовый
[01:34:21.400 --> 01:34:23.400]  но это классический пример, я бы сказал
[01:34:23.400 --> 01:34:25.400]  классический, а?
[01:34:25.400 --> 01:34:27.400]  можно через концепты
[01:34:27.400 --> 01:34:29.400]  да
[01:34:29.400 --> 01:34:31.400]  два вопроса
[01:34:31.400 --> 01:34:33.400]  почему у нас, вдруг, две круги с
[01:34:33.400 --> 01:34:35.400]  одинаковой сигнатурой теперь хорошо стали
[01:34:35.400 --> 01:34:37.400]  второй вопрос, что значит присвоить
[01:34:37.400 --> 01:34:39.400]  присвоить к какому-то тайку
[01:34:39.400 --> 01:34:41.400]  у них теперь разная сигнатура
[01:34:41.400 --> 01:34:43.400]  enable ft в разных классах
[01:34:43.400 --> 01:34:45.400]  это разный тип
[01:34:45.400 --> 01:34:47.400]  у них сигнатуры одинаковые
[01:34:47.400 --> 01:34:49.400]  но разные шаблонные
[01:34:49.400 --> 01:34:51.400]  аргументы, вот так
[01:34:53.400 --> 01:34:55.400]  почему?
[01:34:55.400 --> 01:34:57.400]  ну то есть у тебя получается
[01:34:57.400 --> 01:34:59.400]  у тебя есть функция
[01:34:59.400 --> 01:35:01.400]  которая принимает
[01:35:01.400 --> 01:35:03.400]  у тебя есть функция, которая принимает
[01:35:03.400 --> 01:35:05.400]  у тебя есть шаблонная функция
[01:35:05.400 --> 01:35:07.400]  у которой два шаблона аргумента
[01:35:07.400 --> 01:35:09.400]  а один, три, а другой
[01:35:09.400 --> 01:35:11.400]  какая-то штука
[01:35:11.400 --> 01:35:13.400]  какая-то
[01:35:13.400 --> 01:35:15.400]  непонятная штука
[01:35:15.400 --> 01:35:17.400]  для каждого конкретного цэ у нас в одном случае
[01:35:17.400 --> 01:35:19.400]  тип bool второй, а в другой тип
[01:35:19.400 --> 01:35:21.400]  никакой
[01:35:21.400 --> 01:35:23.400]  я бы подставлял только одна из двух
[01:35:23.400 --> 01:35:25.400]  никакого смысла
[01:35:25.400 --> 01:35:27.400]  непонятно
[01:35:27.400 --> 01:35:29.400]  Вена, или что мы
[01:35:29.400 --> 01:35:31.400]  это уже знали, или что это что-то новое
[01:35:31.400 --> 01:35:33.400]  вот такой вопрос
[01:35:33.400 --> 01:35:35.400]  какая вообще должна работать смысл?
[01:35:35.400 --> 01:35:37.400]  ну это примерно так же как с перегрузкой функций
[01:35:37.400 --> 01:35:39.400]  вы не можете перегружать обычные функции
[01:35:39.400 --> 01:35:41.400]  лишь по наличию или отсутствию дефолтного аргумента
[01:35:41.400 --> 01:35:43.400]  вот так
[01:35:43.400 --> 01:35:45.400]  то есть смотрите, у вас
[01:35:45.400 --> 01:35:47.400]  две отдельальные функции, у которых у каждого из них
[01:35:47.400 --> 01:35:49.400]  дефолтный аргумент
[01:35:49.400 --> 01:35:51.400]  нет, это не дефолтный аргумент
[01:35:51.400 --> 01:35:53.400]  это обязательный аргумент
[01:35:53.400 --> 01:35:55.400]  это не аргумент
[01:35:55.400 --> 01:35:57.400]  нет, нет, нет
[01:35:57.400 --> 01:35:59.400]  смотри, в одном случае
[01:35:59.400 --> 01:36:01.400]  у тебя функции различаются тем, что
[01:36:01.400 --> 01:36:03.400]  в одной дефолтный аргумент ты подставил такой
[01:36:03.400 --> 01:36:05.400]  а в другой другой
[01:36:05.400 --> 01:36:07.400]  то есть у меня там есть f,
[01:36:07.400 --> 01:36:09.400]  которая int и которая
[01:36:09.400 --> 01:36:11.400]  еще возможно
[01:36:11.400 --> 01:36:13.400]  но глобально enableft
[01:36:13.400 --> 01:36:15.400]  они разворачиваются в одно и то же
[01:36:17.400 --> 01:36:19.400]  а здесь у тебя
[01:36:19.400 --> 01:36:21.400]  шаблонная у тебя функция
[01:36:21.400 --> 01:36:23.400]  у которой обязательны оба
[01:36:23.400 --> 01:36:25.400]  шаблонных аргумента
[01:36:25.400 --> 01:36:27.400]  почему обязательны?
[01:36:27.400 --> 01:36:29.400]  потому что я обязательно
[01:36:29.400 --> 01:36:31.400]  должен использовать второй аргумент
[01:36:33.400 --> 01:36:35.400]  шаблонный аргумент
[01:36:35.400 --> 01:36:37.400]  не обязательный
[01:36:39.400 --> 01:36:41.400]  а у меня
[01:36:41.400 --> 01:36:43.400]  у него есть значение по умолчанию
[01:36:43.400 --> 01:36:45.400]  у кого он был?
[01:36:45.400 --> 01:36:47.400]  это шаблонный аргумент, типа
[01:36:47.400 --> 01:36:49.400]  не типа, а значение
[01:36:49.400 --> 01:36:51.400]  как это, чищенка
[01:36:51.400 --> 01:36:53.400]  можно, пожалуйста, без enableif
[01:36:53.400 --> 01:36:55.400]  написать строчку,
[01:36:55.400 --> 01:36:57.400]  в которой было бы
[01:36:57.400 --> 01:36:59.400]  там был бы type не c, запятая bool
[01:36:59.400 --> 01:37:01.400]  равно true
[01:37:01.400 --> 01:37:03.400]  enableift type
[01:37:03.400 --> 01:37:05.400]  не enableif v
[01:37:05.400 --> 01:37:07.400]  enableift
[01:37:07.400 --> 01:37:09.400]  а bool равно true
[01:37:09.400 --> 01:37:11.400]  там бы только type, это bool
[01:37:11.400 --> 01:37:13.400]  у нас бы
[01:37:13.400 --> 01:37:15.400]  bool, которого мы имя
[01:37:15.400 --> 01:37:17.400]  не назначили
[01:37:17.400 --> 01:37:19.400]  раме умолчания true
[01:37:19.400 --> 01:37:21.400]  не понятно, что значит присвоить
[01:37:21.400 --> 01:37:23.400]  типу и число
[01:37:23.400 --> 01:37:25.400]  почему в одном случае
[01:37:25.400 --> 01:37:27.400]  это считается не однозначностью в другом
[01:37:27.400 --> 01:37:29.400]  нет
[01:37:29.400 --> 01:37:31.400]  ну
[01:37:31.400 --> 01:37:33.400]  какие правила
[01:37:33.400 --> 01:37:35.400]  не знаю
[01:37:39.400 --> 01:37:41.400]  default template argument
[01:37:41.400 --> 01:37:43.400]  for and function template equivalence
[01:37:43.400 --> 01:37:45.400]  я не помню, что такое function template overloading
[01:37:45.400 --> 01:37:47.400]  что именно
[01:37:47.400 --> 01:37:49.400]  а, это
[01:37:49.400 --> 01:37:51.400]  так можно было все это время
[01:37:59.400 --> 01:38:01.400]  overload
[01:38:01.400 --> 01:38:03.400]  2
[01:38:03.400 --> 01:38:05.400]  и сжиг
[01:38:09.400 --> 01:38:11.400]  почему бы и не отсутствовать
[01:38:13.400 --> 01:38:15.400]  и сжиг
[01:38:15.400 --> 01:38:17.400]  и сжиг
[01:38:17.400 --> 01:38:19.400]  разные вещи
[01:38:19.400 --> 01:38:21.400]  разные
[01:38:21.400 --> 01:38:23.400]  ну вот, два выражения
[01:38:23.400 --> 01:38:25.400]  включающие шелонные параметры
[01:38:25.400 --> 01:38:27.400]  эквивалентные
[01:38:27.400 --> 01:38:29.400]  если два определения функции
[01:38:29.400 --> 01:38:31.400]  как все разнообразно
[01:38:33.400 --> 01:38:35.400]  сложно
[01:38:35.400 --> 01:38:37.400]  в общем
[01:38:37.400 --> 01:38:39.400]  ладно, я не
[01:38:39.400 --> 01:38:41.400]  не хочу дальше разбираться
[01:38:41.400 --> 01:38:43.400]  правильно
[01:38:43.400 --> 01:38:45.400]  а так неправильно
[01:38:45.400 --> 01:38:47.400]  это не костыльное
[01:38:47.400 --> 01:38:49.400]  это и есть классическое
[01:38:49.400 --> 01:38:51.400]  стандартное использование
[01:38:51.400 --> 01:38:53.400]  не костыльное, это концепт
[01:38:53.400 --> 01:38:55.400]  вот это нормальное использование
[01:38:55.400 --> 01:38:57.400]  до секретизации 20
[01:38:57.400 --> 01:38:59.400]  вот эта штука
[01:38:59.400 --> 01:39:01.400]  это способ сделать перегрузку
[01:39:01.400 --> 01:39:03.400]  по признаку класса
[01:39:03.400 --> 01:39:05.400]  линии класс
[01:39:05.400 --> 01:39:07.400]  вот, мы научились
[01:39:07.400 --> 01:39:09.400]  сделать перегрузку функции по признаку класса
[01:39:09.400 --> 01:39:14.320]  у нас или не класс. Вот это пример enable.if. Понятно, что я могу по
[01:39:14.320 --> 01:39:17.940]  любому по бизнесу, по любому тайт-трейд, а так делать перегрузку теперь с помощью
[01:39:17.940 --> 01:39:20.400]  enable.if.
[01:39:20.400 --> 01:39:26.400]  Когда ты предлагал enable.if, который между классами запихнуть, ты предлагал именно вот это там написать?
[01:39:26.400 --> 01:39:27.400]  Ну да.
[01:39:27.400 --> 01:39:31.400]  Совершить common mistake, копаться 2 часа, понимать почему.
[01:39:31.400 --> 01:39:36.400]  Нет, я не помню, что я там конкретно предлагал.
[01:39:36.400 --> 01:39:38.400]  Просто, куда ты enable.if напихать, чтобы...
[01:39:38.400 --> 01:39:46.400]  Нет, enable.if напихать, ну вот так я имел в виду. Возможно, я там совершил common mistake и сказал take name равно enable.if.
[01:39:46.400 --> 01:39:49.400]  Да, это было неправильно, надо вот так сделать.
[01:39:49.400 --> 01:39:54.400]  Кто понял? Ну вот, короче, что написано здесь?
[01:39:54.400 --> 01:39:56.400]  Там люди опять чего-то...
[01:39:56.400 --> 01:40:00.400]  Извините, я еще не понятно, чем... то, что мы сейчас написали лучше, чем...
[01:40:00.400 --> 01:40:03.400]  Мне тоже не понятно. На этом мы забыли.
[01:40:03.400 --> 01:40:05.400]  Ну, мы поняли.
[01:40:05.400 --> 01:40:08.400]  Ну, просто по стандарту это работает, а то нет.
[01:40:08.400 --> 01:40:16.400]  Ну типа, таковы правила выбора версии шаблонной перегрузки, что вот это считается разными версиями, а то считаются неоднозначностью.
[01:40:16.400 --> 01:40:23.400]  Там и там просто разница type name равен по умолчанию одному, а другой type name равен по умолчанию другому.
[01:40:23.400 --> 01:40:25.400]  Это считается неоднозначностью.
[01:40:25.400 --> 01:40:27.400]  А так не считается неоднозначностью, никакие правила.
[01:40:27.400 --> 01:40:43.400]  Нет, тут просто формально разные выражения, ими будут p от других аргументов, несмотря на то, что он возвращает тоже bool, но мы же не можем заранее знать, что он вернет bool, поэтому мы просто считаем, что эти выражения не идентичны.
[01:40:43.400 --> 01:40:45.400]  Наверное, p.
[01:40:45.400 --> 01:40:48.400]  Нет, он не вернет bool, он ничего не вернет.
[01:40:48.400 --> 01:40:52.400]  В каждом случае он вернет, в другом ничего не вернет, да.
[01:40:52.400 --> 01:41:01.400]  Ну вот, для любого класса только одна из них вообще может подставиться.
[01:41:01.400 --> 01:41:02.400]  Ну да.
[01:41:02.400 --> 01:41:10.400]  А мы можем также сделать, чтобы какая-то функция у нас была только одна, которая работает только для классов, то есть оставить только первые варианты.
[01:41:10.400 --> 01:41:11.400]  Да, конечно.
[01:41:11.400 --> 01:41:16.400]  А что будет, если вы же у меня от класса, то будет себе другой от версии, нет?
[01:41:16.400 --> 01:41:17.400]  Конечно.
[01:41:18.400 --> 01:41:20.400]  Так.
[01:41:20.400 --> 01:41:26.400]  Зная это, зная принцип, теперь мы можем реализовать остальные type traits, наконец.
[01:41:26.400 --> 01:41:31.400]  Ну, enable if нам уже не потребуется, мы будем просто напрямую все наесть bool.
[01:41:31.400 --> 01:41:34.400]  А может и будем сейчас использовать эти самые.
[01:41:34.400 --> 01:41:41.400]  Вот давайте реализуем, чтобы нам реализовать.
[01:41:41.400 --> 01:41:44.400]  Чтобы нам реализовать.
[01:41:44.400 --> 01:41:50.400]  Давайте я не буду новый пункт начинать, а просто покажу какой-нибудь пример с использованием SFINAE.
[01:41:50.400 --> 01:41:55.400]  Вот, например, как реализована isClass...
[01:41:55.400 --> 01:41:57.400]  Как реализовать isClassForUnion?
[01:41:57.400 --> 01:42:01.400]  А, тут мы не найдем с вами этого, потому что это требует...
[01:42:01.400 --> 01:42:06.400]  Вот давайте попробуем реализовать такой type trait.
[01:42:06.400 --> 01:42:16.400]  TypeNameT struct isClassForUnion.
[01:42:16.400 --> 01:42:18.400]  И нам мы от этого отличаем.
[01:42:18.400 --> 01:42:20.400]  И нам отличаем, да.
[01:42:20.400 --> 01:42:22.400]  Что я хочу сделать?
[01:42:22.400 --> 01:42:26.400]  Ну вот, я хочу, чтобы это было...
[01:42:26.400 --> 01:42:34.400]  Значит, содержало value равное true, если это класс или union, и false иначе.
[01:42:34.400 --> 01:42:38.400]  Вот я утверждаю, что классов union отличить мы средствами языка не сможем.
[01:42:38.400 --> 01:42:40.400]  Это только напилятор может.
[01:42:40.400 --> 01:42:45.400]  Но вот отличить класс или union от чего угодно остального мы сможем.
[01:42:45.400 --> 01:42:50.400]  Нам нужно придумать какое-то такое...
[01:42:50.400 --> 01:42:52.400]  Ну как, я не знаю...
[01:42:52.400 --> 01:42:54.400]  Заклинание, что ли?
[01:42:54.400 --> 01:42:57.400]  Что...
[01:42:57.400 --> 01:43:02.400]  Вот...
[01:43:02.400 --> 01:43:11.400]  Что-то такое сделать надо с типом T, что если бы это был класс или union, то было бы true, иначе false.
[01:43:11.400 --> 01:43:16.400]  Ну, у всех классов union есть destructor.
[01:43:16.400 --> 01:43:18.400]  Ну, у некоторых он приватный.
[01:43:18.400 --> 01:43:23.400]  Да, обычно первая идея ко всем приходящая, это давайте к destructor попробуем обратиться.
[01:43:23.400 --> 01:43:24.400]  Может using?
[01:43:24.400 --> 01:43:26.400]  Using что?
[01:43:26.400 --> 01:43:28.400]  А мы не measures using?
[01:43:28.400 --> 01:43:30.400]  Я говорю на класс.
[01:43:30.400 --> 01:43:32.400]  Мы можем sometime то же самое.
[01:43:36.400 --> 01:43:39.400]  Приватный destructor что-нибудь помню.
[01:43:39.400 --> 01:43:42.400]  Тем не менее, они думают...
[01:43:42.400 --> 01:43:50.400]  Мы даже просматривали ситуацию, если у вас, например, класс, который можно создавать только на куче, а не на стеке.
[01:43:50.400 --> 01:43:54.400]  И destructor приватный вызывать вы можете только по определенной...
[01:43:54.400 --> 01:43:55.400]  Friend?
[01:43:55.400 --> 01:43:57.400]  Да.
[01:43:57.400 --> 01:43:59.400]  Вот.
[01:43:59.400 --> 01:44:03.400]  Значит, какой-нибудь магический слава на тишину, которая запретит приватность.
[01:44:03.400 --> 01:44:05.400]  Какое...
[01:44:05.400 --> 01:44:07.400]  Каким нужно... Какое выражение? Какое expression?
[01:44:07.400 --> 01:44:09.400]  Мы можем наследоваться тентов?
[01:44:09.400 --> 01:44:10.400]  Нет.
[01:44:10.400 --> 01:44:12.400]  Ну, наследоваться может только от класса.
[01:44:12.400 --> 01:44:14.400]  Да, но нужен expression.
[01:44:14.400 --> 01:44:17.400]  Мне нужен какой-то expression, который я подставлю.
[01:44:17.400 --> 01:44:22.400]  Ну, то есть я хочу сейчас сделать что-то в стиле...
[01:44:22.400 --> 01:44:28.400]  Написать какую-нибудь функцию, у которой возвращаем идти, будет декл-тайп какой-то там.
[01:44:28.400 --> 01:44:32.400]  И вот этот expression, включающий в себя тип T, должен быть коррекцией.
[01:44:32.400 --> 01:44:35.400]  Тогда только тогда, когда...
[01:44:35.400 --> 01:44:37.400]  Надо отложить действие от одной.
[01:44:37.400 --> 01:44:39.400]  Пока что ничего умного.
[01:44:39.400 --> 01:44:42.400]  Правильный ответ указателей на члены.
[01:44:42.400 --> 01:44:44.400]  У любого класса есть члены?
[01:44:44.400 --> 01:44:47.400]  У любого класса можно объявить указатели на члены.
[01:44:47.400 --> 01:44:49.400]  И у Юниона тоже.
[01:44:49.400 --> 01:44:51.400]  Ну, просто писать T2.
[01:44:51.400 --> 01:44:54.400]  Я могу написать T2.2.
[01:44:54.400 --> 01:44:58.400]  И когда это класс или Юня, это будет корректным expression.
[01:44:58.400 --> 01:45:00.400]  В смысле, я могу...
[01:45:03.400 --> 01:45:05.400]  Ну да.
[01:45:05.400 --> 01:45:07.400]  Хотя бы не комментария для него.
[01:45:07.400 --> 01:45:09.400]  Хотя бы не комментария для него.
[01:45:09.400 --> 01:45:10.400]  Ну да.
[01:45:10.400 --> 01:45:12.400]  Значит, смотрите.
[01:45:12.400 --> 01:45:15.400]  Мне сейчас надо что-то такое написать вот здесь вот.
[01:45:16.400 --> 01:45:18.400]  Ну, то есть...
[01:45:18.400 --> 01:45:21.400]  Ну, давайте я пока скажу static const bool value.
[01:45:21.400 --> 01:45:26.400]  Хотя, конечно, надо бы унаследоваться от чего-то там.
[01:45:26.400 --> 01:45:28.400]  А равно чему?
[01:45:28.400 --> 01:45:31.400]  Ну вот, что-то...
[01:45:33.400 --> 01:45:36.400]  Ну даже не что-то, просто вот либо true, либо false.
[01:45:38.400 --> 01:45:40.400]  Вот мне надо просто вызвать...
[01:45:40.400 --> 01:45:42.400]  Сейчас мне нужно какую-то сделать...
[01:45:43.400 --> 01:45:46.400]  Ну, функцию с перегрузкой также?
[01:45:46.400 --> 01:45:50.400]  Ну да, функцию с перегрузкой, наверное, надо сделать.
[01:45:50.400 --> 01:45:54.400]  Мне нужно как-то в compile-time понять, какая версия функций вызовется.
[01:45:56.400 --> 01:45:58.400]  Constexpr?
[01:45:58.400 --> 01:46:01.400]  Ну, можно и без constexpr.
[01:46:01.400 --> 01:46:05.400]  Давайте я создам две функции.
[01:46:05.400 --> 01:46:07.400]  Одна из которых будет...
[01:46:07.400 --> 01:46:09.400]  Decltype и пытаться...
[01:46:09.400 --> 01:46:14.400]  Ну, давайте, значит, template typeNameT.
[01:46:14.400 --> 01:46:17.400]  А возвращаемый тип потом напишу.
[01:46:17.400 --> 01:46:21.400]  IsClassOrUnionHelper.
[01:46:23.400 --> 01:46:25.400]  Который ничего не принимает.
[01:46:27.400 --> 01:46:30.400]  Да хотя ладно, пусть она принимает int.
[01:46:30.400 --> 01:46:32.400]  Чем?
[01:46:32.400 --> 01:46:35.400]  Ну, потому что я же буду...
[01:46:35.400 --> 01:46:38.400]  А, ну хотя, сейчас, подождите, да, мне, наверное...
[01:46:38.400 --> 01:46:39.400]  Она ничего не понимает?
[01:46:39.400 --> 01:46:42.400]  Не, не надо, я же и на Ebbool сейчас просто использую.
[01:46:42.400 --> 01:46:43.400]  Правильно?
[01:46:43.400 --> 01:46:45.400]  Нет, не спокой, на Ebbool я использую, мне нужно явно.
[01:46:45.400 --> 01:46:49.400]  Мне нужно, чтобы она была предпочтительней, но при попытке ее выбора...
[01:46:51.400 --> 01:46:54.400]  компилятор бы наткнулся на плохой Decltype.
[01:46:54.400 --> 01:46:56.400]  Хорошо, давайте себе.
[01:46:56.400 --> 01:47:00.400]  Return, здесь я скажу return true.
[01:47:01.400 --> 01:47:04.400]  Сейчас мы поймем, что надо дописать.
[01:47:04.400 --> 01:47:07.400]  А здесь скажу return false.
[01:47:09.400 --> 01:47:12.400]  Как мне добиться того, чтобы она была предпочтительней?
[01:47:12.400 --> 01:47:14.400]  template typeNameU.
[01:47:14.400 --> 01:47:18.400]  Да нет, я просто здесь приму int, а тут приму что угодно.
[01:47:18.400 --> 01:47:21.400]  А, c перегрузка full.
[01:47:21.400 --> 01:47:23.400]  Ну да, так.
[01:47:23.400 --> 01:47:26.400]  А здесь я напишу Decltype...
[01:47:27.400 --> 01:47:29.400]  от...
[01:47:31.400 --> 01:47:35.400]  int t...
[01:47:35.400 --> 01:47:37.400]  звездочка.
[01:47:40.400 --> 01:47:42.400]  Не знаю.
[01:47:47.400 --> 01:47:51.400]  Что, я не знаю, какое-нибудь просто действие.
[01:47:52.400 --> 01:47:55.400]  Это я объявил сейчас указатель на член,
[01:47:55.400 --> 01:47:58.400]  но я могу попробовать объявить указатель на функцию, еще ее вызвать.
[01:47:58.400 --> 01:47:59.400]  Зачем?
[01:47:59.400 --> 01:48:01.400]  Ну, мне нужен expression здесь какой-то.
[01:48:01.400 --> 01:48:03.400]  Испытай bool.
[01:48:03.400 --> 01:48:04.400]  Испытай bool.
[01:48:04.400 --> 01:48:06.400]  Испытай bool.
[01:48:06.400 --> 01:48:08.400]  В втором случае можно просто...
[01:48:08.400 --> 01:48:11.400]  bool круглые скобочки только, потому что это expression должен быть.
[01:48:11.400 --> 01:48:14.400]  А во втором случае просто bool.
[01:48:14.400 --> 01:48:17.400]  Зачем нам двойные скобочки порабить?
[01:48:17.400 --> 01:48:19.400]  Потому что это...
[01:48:19.400 --> 01:48:21.400]  Должен быть expression.
[01:48:21.400 --> 01:48:24.400]  Должен быть вот это указатель на функцию,
[01:48:24.400 --> 01:48:27.400]  которая ничего не принимает.
[01:48:27.400 --> 01:48:30.400]  Возвращает int, ничего не принимает.
[01:48:30.400 --> 01:48:33.400]  Я не уверен, сейчас когда распарсится,
[01:48:33.400 --> 01:48:37.400]  может быть я лучше вот так напишу.
[01:48:37.400 --> 01:48:40.400]  То есть вот так скажу, что это int.
[01:48:40.400 --> 01:48:43.400]  В общем, вот такое выражение напишу.
[01:48:43.400 --> 01:48:44.400]  Да?
[01:48:44.400 --> 01:48:46.400]  Звучит более логично.
[01:48:46.400 --> 01:48:48.400]  А это что, наверное, на члене?
[01:48:48.400 --> 01:48:50.400]  Это указатель на член.
[01:48:50.400 --> 01:48:52.400]  И вызов его пустого конструктора.
[01:48:52.400 --> 01:48:54.400]  То есть создание его по умолчанию.
[01:48:54.400 --> 01:48:56.400]  Ну да.
[01:48:56.400 --> 01:48:58.400]  Запитай a bool,
[01:48:58.400 --> 01:49:01.400]  потому что я хочу, чтобы в итоге тип-то был bool.
[01:49:01.400 --> 01:49:03.400]  А здесь мы пишем что?
[01:49:03.400 --> 01:49:05.400]  Ну просто я говорю, из класса Union Helper...
[01:49:12.400 --> 01:49:14.400]  из класса Union Helper...
[01:49:16.400 --> 01:49:18.400]  От чего?
[01:49:19.400 --> 01:49:21.400]  От t.
[01:49:23.400 --> 01:49:25.400]  От нуля, скажем.
[01:49:28.400 --> 01:49:30.400]  Будет ошибка.
[01:49:30.400 --> 01:49:33.400]  Давайте посмотрим, понятно, что будет какая-то ошибка.
[01:49:33.400 --> 01:49:36.400]  Expected primary expression for int.
[01:49:36.400 --> 01:49:38.400]  Он так не понял.
[01:49:40.400 --> 01:49:42.400]  Сейчас, чего ему не понравилось?
[01:49:48.400 --> 01:49:50.400]  Давайте, наверное,
[01:49:50.400 --> 01:49:52.400]  даже без депутата я это сделаю.
[01:49:52.400 --> 01:49:54.400]  А просто скажу typeName
[01:49:54.400 --> 01:49:56.400]  u равно int
[01:49:56.400 --> 01:49:58.400]  2.2.2.
[01:49:58.400 --> 01:50:00.400]  вот так сделаю.
[01:50:00.400 --> 01:50:02.400]  Наверное, так будет лучше.
[01:50:02.400 --> 01:50:04.400]  А возвращаем и типу.
[01:50:04.400 --> 01:50:06.400]  У них обеих будет bool.
[01:50:08.400 --> 01:50:10.400]  О!
[01:50:10.400 --> 01:50:12.400]  Кажется, вот так.
[01:50:12.400 --> 01:50:14.400]  Сейчас, сейчас.
[01:50:14.400 --> 01:50:16.400]  Все, скомпилировано.
[01:50:16.400 --> 01:50:18.400]  Все, скомпилировалось.
[01:50:22.400 --> 01:50:24.400]  Зачем ему что-то принимать?
[01:50:24.400 --> 01:50:26.400]  Потому что я
[01:50:26.400 --> 01:50:28.400]  здесь вызываю от нуля
[01:50:28.400 --> 01:50:30.400]  и мне
[01:50:30.400 --> 01:50:32.400]  надо, чтобы он хотел пойти в эту
[01:50:32.400 --> 01:50:34.400]  в первую очередь.
[01:50:34.400 --> 01:50:36.400]  А чтобы это было менее предпочтительное.
[01:50:36.400 --> 01:50:38.400]  Что если это класс или union,
[01:50:38.400 --> 01:50:40.400]  то он бы попал сюда и все было бы хорошо.
[01:50:40.400 --> 01:50:42.400]  Вот.
[01:50:44.400 --> 01:50:46.400]  Ну, я добавил шаблонный аргумент
[01:50:46.400 --> 01:50:48.400]  по умолчанию вот такой упадатель на член.
[01:50:48.400 --> 01:50:50.400]  Давайте проверим, что это работает.
[01:50:50.400 --> 01:50:52.400]  Сейчас-то не сработает.
[01:50:52.400 --> 01:50:54.400]  Ну, давайте я...
[01:50:54.400 --> 01:50:56.400]  Понятно, что не сработает.
[01:50:56.400 --> 01:50:58.400]  Но вызов функции при вкупляться...
[01:50:58.400 --> 01:51:00.400]  Да, потому что мы пытаемся сделать
[01:51:00.400 --> 01:51:02.400]  вызов функции в compareTime. Это так нельзя.
[01:51:02.400 --> 01:51:04.400]  Пока что нельзя.
[01:51:04.400 --> 01:51:06.400]  Значит, я сейчас скажу
[01:51:06.400 --> 01:51:08.400]  const
[01:51:08.400 --> 01:51:10.400]  А почему?
[01:51:10.400 --> 01:51:12.400]  Потому что он не инстанцировал пока.
[01:51:12.400 --> 01:51:14.400]  Из classOrUnionW равно
[01:51:14.400 --> 01:51:16.400]  из classOrUnion
[01:51:16.400 --> 01:51:18.400]  от
[01:51:18.400 --> 01:51:20.400]  t2.2.0
[01:51:20.400 --> 01:51:22.400]  Здесь мы просто текст пропишем, а там не можем.
[01:51:22.400 --> 01:51:24.400]  Потому что
[01:51:24.400 --> 01:51:26.400]  формально я еще не
[01:51:26.400 --> 01:51:28.400]  объяснил, да.
[01:51:28.400 --> 01:51:30.400]  Все логично.
[01:51:30.400 --> 01:51:32.400]  Пока еще люди не поняли проблему. Только ты только понял проблему.
[01:51:32.400 --> 01:51:34.400]  Сейчас я продемонстрирую, что будет проблема
[01:51:34.400 --> 01:51:36.400]  из-за того, что мы так написали.
[01:51:36.400 --> 01:51:38.400]  Сейчас мы напишем constexpr
[01:51:38.400 --> 01:51:40.400]  для функций.
[01:51:40.400 --> 01:51:42.400]  Давайте...
[01:51:42.400 --> 01:51:44.400]  Проверь, что?
[01:51:44.400 --> 01:51:46.400]  Можно и без него.
[01:51:46.400 --> 01:51:48.400]  Сейчас я и сниму без него.
[01:51:48.400 --> 01:51:50.400]  Ну, давайте я
[01:51:50.400 --> 01:51:52.400]  выведу
[01:51:52.400 --> 01:51:54.400]  из classOrUnionW
[01:51:58.400 --> 01:52:00.400]  от s
[01:52:00.400 --> 01:52:02.400]  и
[01:52:02.400 --> 01:52:04.400]  из classOrUnionW
[01:52:06.400 --> 01:52:08.400]  от int
[01:52:12.400 --> 01:52:14.400]  Сейчас, скорее всего,
[01:52:14.400 --> 01:52:16.400]  будет ошибка компиляции.
[01:52:16.400 --> 01:52:18.400]  Вот. И именно
[01:52:18.400 --> 01:52:20.400]  понимаете,
[01:52:20.400 --> 01:52:22.400]  или вы в чем ошибка? Кто понимает?
[01:52:22.400 --> 01:52:24.400]  Ну, большинство на этот раз.
[01:52:24.400 --> 01:52:26.400]  Это хорошо.
[01:52:26.400 --> 01:52:28.400]  Потому что я в compile-time заставляю его
[01:52:28.400 --> 01:52:30.400]  сделать function call. Вот здесь.
[01:52:32.400 --> 01:52:34.400]  Вообще говоря, в compile-time
[01:52:34.400 --> 01:52:36.400]  компилятор отказывается делать вызов функций.
[01:52:36.400 --> 01:52:38.400]  Просто сказать value
[01:52:38.400 --> 01:52:40.400]  равно здесь какой-то
[01:52:40.400 --> 01:52:42.400]  compile-time вычтение сделать можно,
[01:52:42.400 --> 01:52:44.400]  но вызов функций — это не compile-time вычтение.
[01:52:44.400 --> 01:52:46.400]  Чтобы его заставить
[01:52:46.400 --> 01:52:48.400]  сделать вызов функций в compile-time,
[01:52:48.400 --> 01:52:50.400]  мне надо функцию пометить как constexpr.
[01:52:50.400 --> 01:52:52.400]  Что?
[01:52:52.400 --> 01:52:54.400]  Что?
[01:52:54.400 --> 01:52:56.400]  Дальше. Какие
[01:52:56.400 --> 01:52:58.400]  ограничения это малорядится? Что мы...
[01:53:00.400 --> 01:53:02.400]  Все, получилось. В одном случае да, в другом нет.
[01:53:04.400 --> 01:53:06.400]  Но я не хочу пока
[01:53:06.400 --> 01:53:08.400]  углубляться в тему того, когда функция
[01:53:08.400 --> 01:53:10.400]  может быть constexpr, когда нет — не любая может быть.
[01:53:10.400 --> 01:53:12.400]  Но я
[01:53:12.400 --> 01:53:14.400]  просто сделаю это
[01:53:14.400 --> 01:53:16.400]  то, как это делалось до
[01:53:16.400 --> 01:53:18.400]  constexpr функции. Я просто
[01:53:18.400 --> 01:53:20.400]  скажу, что здесь возвращаем идти в bool,
[01:53:20.400 --> 01:53:22.400]  а здесь возвращаем идти в int.
[01:53:22.400 --> 01:53:24.400]  И здесь я просто
[01:53:24.400 --> 01:53:26.400]  скажу...
[01:53:28.400 --> 01:53:30.400]  СТД
[01:53:30.400 --> 01:53:32.400]  is same
[01:53:32.400 --> 01:53:34.400]  where
[01:53:34.400 --> 01:53:36.400]  decaltime
[01:53:36.400 --> 01:53:38.400]  decaltime
[01:53:40.400 --> 01:53:42.400]  Измучили, нам не хватало.
[01:53:44.400 --> 01:53:46.400]  bool
[01:53:50.400 --> 01:53:52.400]  Все, мы обошлись без constexpr.
[01:53:52.400 --> 01:53:54.400]  Интересно. Вы молодцы.
[01:53:58.400 --> 01:54:00.400]  Вы смеетесь,
[01:54:00.400 --> 01:54:02.400]  а до C++11 это был аминтак реализован.
[01:54:02.400 --> 01:54:04.400]  Это было лучшее в том, что
[01:54:04.400 --> 01:54:06.400]  можно предложить язык C++.
[01:54:10.400 --> 01:54:12.400]  А почему
[01:54:12.400 --> 01:54:14.400]  мы не могли это
[01:54:14.400 --> 01:54:16.400]  сучение на using поменять?
[01:54:16.400 --> 01:54:18.400]  И всем, кто работает функцией на using.
[01:54:20.400 --> 01:54:22.400]  Сделать using...
[01:54:22.400 --> 01:54:24.400]  Что-то там ровно decaltime, а вы делали функционный.
[01:54:24.400 --> 01:54:26.400]  Ну, здесь вот
[01:54:26.400 --> 01:54:28.400]  template на using, он же тоже может повалиться.
[01:54:28.400 --> 01:54:30.400]  Ты еще так же копируешь.
[01:54:30.400 --> 01:54:32.400]  Где ты предлагаешь using написать?
[01:54:32.400 --> 01:54:34.400]  Вот вместо того, чтобы объявлять
[01:54:34.400 --> 01:54:36.400]  из class or union
[01:54:36.400 --> 01:54:38.400]  как функцию, почему
[01:54:38.400 --> 01:54:40.400]  мы не могли ее using сделать?
[01:54:40.400 --> 01:54:42.400]  Наш фото.
[01:54:42.400 --> 01:54:44.400]  Еще раз, где именно ты хочешь написать using?
[01:54:44.400 --> 01:54:46.400]  Где именно ты хочешь написать using? Я не понимаю.
[01:54:46.400 --> 01:54:48.400]  Ты хочешь из class or union написать using?
[01:54:48.400 --> 01:54:50.400]  Нет, написать using
[01:54:50.400 --> 01:54:52.400]  из class or union фокер равно чему-то.
[01:54:52.400 --> 01:54:54.400]  И чему?
[01:54:54.400 --> 01:54:56.400]  Да неважно.
[01:54:56.400 --> 01:54:58.400]  Неважно.
[01:54:58.400 --> 01:55:00.400]  С Finae работает при перегрузке функций.
[01:55:00.400 --> 01:55:02.400]  Выпускай равно int.
[01:55:02.400 --> 01:55:04.400]  А если вот в первом сжалке
[01:55:04.400 --> 01:55:06.400]  слушай и написать равно в
[01:55:06.400 --> 01:55:08.400]  и тогда мы можем
[01:55:08.400 --> 01:55:10.400]  стандармировать...
[01:55:10.400 --> 01:55:12.400]  А, вот так? Давай попробуем.
[01:55:14.400 --> 01:55:16.400]  Я не уверен, что Finae так сработает.
[01:55:22.400 --> 01:55:24.400]  Не, подожди, а как ты
[01:55:24.400 --> 01:55:26.400]  у тебя будет typeNameT,
[01:55:26.400 --> 01:55:28.400]  typeNameU равно такой, а ты просто
[01:55:28.400 --> 01:55:30.400]  typeNameT, и как ты сделаешь между ними выбор?
[01:55:30.400 --> 01:55:32.400]  У тебя будет
[01:55:32.400 --> 01:55:34.400]  два конфликта. У тебя не бывает же перегрузки
[01:55:34.400 --> 01:55:36.400]  using?
[01:55:36.400 --> 01:55:38.400]  Перегрузки using.
[01:55:38.400 --> 01:55:40.400]  Ну да.
[01:55:40.400 --> 01:55:42.400]  У меня функции с разными сигнатурами, с разными
[01:55:42.400 --> 01:55:44.400]  наборами шаблонных параметров, а если два using
[01:55:44.400 --> 01:55:46.400]  с разными наборами шаблонных параметров, так кажется не должно работать.
[01:55:50.400 --> 01:55:52.400]  Так, понятно
[01:55:52.400 --> 01:55:54.400]  как это работает.
[01:55:54.400 --> 01:55:56.400]  Ну, чтобы не
[01:55:56.400 --> 01:55:58.400]  заниматься вот этим вот,
[01:55:58.400 --> 01:56:00.400]  я обещал, что не буду писать
[01:56:00.400 --> 01:56:02.400]  стандарм с Bluel, я просто скажу, что это
[01:56:02.400 --> 01:56:04.400]  STD...
[01:56:04.400 --> 01:56:06.400]  что?
[01:56:06.400 --> 01:56:08.400]  LulConstant?
[01:56:08.400 --> 01:56:10.400]  Ладно.
[01:56:12.400 --> 01:56:14.400]  Вот такая.
[01:56:14.400 --> 01:56:16.400]  Lul надо оставить,
[01:56:16.400 --> 01:56:18.400]  угловая скобка закрылась.
[01:56:18.400 --> 01:56:20.400]  Зачем
[01:56:20.400 --> 01:56:22.400]  LulConstant, который
[01:56:22.400 --> 01:56:24.400]  кто-то задавал?
[01:56:24.400 --> 01:56:26.400]  Ну, если можно было вместо LulConstant
[01:56:26.400 --> 01:56:28.400]  писать...
[01:56:28.400 --> 01:56:30.400]  Я бы делал еще хуже.
[01:56:30.400 --> 01:56:32.400]  Правильно, у меня все скобочки сходятся,
[01:56:32.400 --> 01:56:34.400]  то есть вот эта скобочка, Bluel,
[01:56:34.400 --> 01:56:36.400]  ну да.
[01:56:36.400 --> 01:56:38.400]  И пустое тело структуры.
[01:56:42.400 --> 01:56:44.400]  А чем LulConstant отличается от LulConstant?
[01:56:44.400 --> 01:56:46.400]  Потому что LulConstant
[01:56:46.400 --> 01:56:48.400]  типа Bluel.
[01:56:48.400 --> 01:56:50.400]  Да, а зачем писать LulConstant
[01:56:50.400 --> 01:56:52.400]  от ESM Wave, а можно как-то писать ESM?
[01:56:52.400 --> 01:56:54.400]  Что написать?
[01:56:54.400 --> 01:56:56.400]  Нет.
[01:56:56.400 --> 01:56:58.400]  А, выточь, да, просто
[01:56:58.400 --> 01:57:00.400]  можно и так, да, это еще проще.
[01:57:00.400 --> 01:57:02.400]  Чего-то мы переговорили.
[01:57:02.400 --> 01:57:04.400]  Лучше писать LulConstant, а просто написать, что это
[01:57:04.400 --> 01:57:06.400]  унаследование STD ESM вот такого.
[01:57:08.400 --> 01:57:10.400]  Да.
[01:57:10.400 --> 01:57:12.400]  Выглядит очень
[01:57:12.400 --> 01:57:14.400]  безобидно.
[01:57:16.400 --> 01:57:18.400]  Берегите наш язык, наш прекрасный язык C++.
[01:57:18.400 --> 01:57:20.400]  Это клад, это
[01:57:20.400 --> 01:57:22.400]  настояние перед нам, наше напишение.
[01:57:24.400 --> 01:57:26.400]  Все?
[01:57:26.400 --> 01:57:28.400]  Вот, ну давайте теперь наконец
[01:57:28.400 --> 01:57:30.400]  реализуем что-нибудь полезное.
[01:57:30.400 --> 01:57:32.400]  А именно, сейчас мы реализуем
[01:57:32.400 --> 01:57:34.400]  compileTime проверку, есть ли метод
[01:57:34.400 --> 01:57:36.400]  в классе.
[01:57:36.400 --> 01:57:38.400]  Ну в принципе и так уже понятно, как это реализовать.
[01:57:38.400 --> 01:57:40.400]  Давайте, значит, это будет пункт 15.3.
[01:57:40.400 --> 01:57:42.400]  compileTime
[01:57:42.400 --> 01:57:44.400]  check
[01:57:44.400 --> 01:57:46.400]  of
[01:57:46.400 --> 01:57:48.400]  methodPresence
[01:57:48.400 --> 01:57:50.400]  в классе.
[01:57:50.400 --> 01:57:52.400]  Когда нам это
[01:57:52.400 --> 01:57:54.400]  надо было? Ну вот, в локатор
[01:57:54.400 --> 01:57:56.400]  trace, да,
[01:57:56.400 --> 01:57:58.400]  hasMethodConstract.
[01:57:58.400 --> 01:58:00.400]  Ты, видимо, лекции в прошлом году смотрел, да?
[01:58:02.400 --> 01:58:04.400]  Просто я это...
[01:58:04.400 --> 01:58:06.400]  Я смотрю раньше, чем его локатеры
[01:58:06.400 --> 01:58:08.400]  изучали. А, я понял. Просто hasMethodConstract
[01:58:08.400 --> 01:58:10.400]  я это называю. Ну да.
[01:58:10.400 --> 01:58:12.400]  Давайте реализуем метафункцию hasMethodConstract.
[01:58:12.400 --> 01:58:14.400]  Это будет что?
[01:58:14.400 --> 01:58:16.400]  Это проверка, имеет ли класс
[01:58:16.400 --> 01:58:18.400]  такой-то метод констракт
[01:58:18.400 --> 01:58:20.400]  от таких-то аргументов,
[01:58:20.400 --> 01:58:22.400]  от таких-то типов. Собственно,
[01:58:22.400 --> 01:58:24.400]  в локатор trace это и написано.
[01:58:26.400 --> 01:58:28.400]  Значит, у нас будет шаблонная структура.
[01:58:28.400 --> 01:58:30.400]  templateTypeNameT
[01:58:30.400 --> 01:58:32.400]  TypeName многоточие
[01:58:32.400 --> 01:58:34.400]  args
[01:58:36.400 --> 01:58:38.400]  Значит, метафункция
[01:58:38.400 --> 01:58:40.400]  hasMethodConstract
[01:58:42.400 --> 01:58:44.400]  Вот.
[01:58:44.400 --> 01:58:46.400]  Что в ней будет?
[01:58:50.400 --> 01:58:52.400]  Ну.
[01:58:52.400 --> 01:58:54.400]  Ну давайте,
[01:58:54.400 --> 01:58:56.400]  что мне надо? Мне нужно
[01:58:56.400 --> 01:58:58.400]  стать aCostBullValue
[01:59:00.400 --> 01:59:02.400]  Ну, которая будет...
[01:59:02.400 --> 01:59:04.400]  Как всегда,
[01:59:04.400 --> 01:59:06.400]  нужно сделать выражение,
[01:59:06.400 --> 01:59:08.400]  в котором мы попросим вызов
[01:59:08.400 --> 01:59:10.400]  метод констракта. Ну, не вызов, а просто
[01:59:10.400 --> 01:59:12.400]  метод того, что мы запитали.
[01:59:12.400 --> 01:59:14.400]  Ну да.
[01:59:16.400 --> 01:59:18.400]  Запитая будет.
[01:59:18.400 --> 01:59:20.400]  И отлично.
[01:59:20.400 --> 01:59:22.400]  Ну, можно сделать опять
[01:59:22.400 --> 01:59:24.400]  hasMethodConstractHelper
[01:59:24.400 --> 01:59:26.400]  Я не буду это прям в структуре.
[01:59:26.400 --> 01:59:28.400]  У меня будет hasMethodConstractHelper
[01:59:36.400 --> 01:59:38.400]  Это, наверное, функция?
[01:59:38.400 --> 01:59:40.400]  Да, это функция.
[01:59:42.400 --> 01:59:44.400]  Которая возвращает
[01:59:44.400 --> 01:59:46.400]  деклтайп
[01:59:52.400 --> 01:59:54.400]  Ну да. Что она делает?
[01:59:54.400 --> 01:59:56.400]  деклтайп
[01:59:56.400 --> 01:59:58.400]  Тут я вот это вот...
[01:59:58.400 --> 02:00:00.400]  Тут можно точно так же делать. TypeName
[02:00:00.400 --> 02:00:02.400]  Но тут, правда, TypeName многоточие
[02:00:02.400 --> 02:00:04.400]  уже есть. Это плохо.
[02:00:04.400 --> 02:00:06.400]  Давайте напишем здесь деклтайп
[02:00:06.400 --> 02:00:08.400]  Вот чего?
[02:00:08.400 --> 02:00:10.400]  t
[02:00:10.400 --> 02:00:12.400]  что?
[02:00:12.400 --> 02:00:14.400]  t это type
[02:00:14.400 --> 02:00:16.400]  Да.
[02:00:16.400 --> 02:00:18.400]  А, да, все правильно.
[02:00:18.400 --> 02:00:20.400]  t2.2.construct
[02:00:22.400 --> 02:00:24.400]  Нет, стоп.
[02:00:24.400 --> 02:00:26.400]  Нельзя. Нужен констракт, даже не статический.
[02:00:26.400 --> 02:00:28.400]  Мне нужен объект типа t.
[02:00:28.400 --> 02:00:30.400]  Так, круглые скобочки
[02:00:30.400 --> 02:00:32.400]  для выточения констракта.
[02:00:32.400 --> 02:00:34.400]  А если круглые скобочки, приватный констракт?
[02:00:34.400 --> 02:00:36.400]  Отличный вопрос.
[02:00:36.400 --> 02:00:38.400]  Это сейчас мы исправим.
[02:00:38.400 --> 02:00:40.400]  Пока давайте считать, что
[02:00:40.400 --> 02:00:42.400]  он есть.
[02:00:42.400 --> 02:00:44.400]  Значит, вот такой мне нужен
[02:00:44.400 --> 02:00:46.400]  примерно.
[02:00:46.400 --> 02:00:48.400]  Syntaxes
[02:00:48.400 --> 02:00:50.400]  zptBool
[02:00:50.400 --> 02:00:52.400]  круглые скобочки.
[02:00:52.400 --> 02:00:54.400]  Так.
[02:00:54.400 --> 02:00:56.400]  А тут bool has met oi.
[02:00:56.400 --> 02:00:58.400]  Это страт.
[02:00:58.400 --> 02:01:00.400]  И англична проблема с args,
[02:01:00.400 --> 02:01:02.400]  но правда args.
[02:01:02.400 --> 02:01:04.400]  У args не было конструкции по умолчанию,
[02:01:04.400 --> 02:01:06.400]  но у t есть определенный констракт.
[02:01:06.400 --> 02:01:08.400]  Все это правильное замечание.
[02:01:08.400 --> 02:01:10.400]  Вы пока еще не...
[02:01:10.400 --> 02:01:12.400]  Сейчас, а что такое args?
[02:01:12.400 --> 02:01:14.400]  Зачем они нам нужны вообще?
[02:01:14.400 --> 02:01:16.400]  Констракт данных аргументов.
[02:01:16.400 --> 02:01:18.400]  А, есть ли у него метод констракта,
[02:01:18.400 --> 02:01:20.400]  понимающий данные аргументы?
[02:01:20.400 --> 02:01:22.400]  Все. А раньше у нас не было проблем с...
[02:01:22.400 --> 02:01:24.400]  А, у нас был только bool.
[02:01:24.400 --> 02:01:26.400]  Все хорошо.
[02:01:26.400 --> 02:01:28.400]  А здесь просто bool.
[02:01:28.400 --> 02:01:30.400]  И опять мы делаем, что
[02:01:30.400 --> 02:01:32.400]  этот хелпер принимает int.
[02:01:32.400 --> 02:01:34.400]  А может быть он не принимал ничего,
[02:01:34.400 --> 02:01:36.400]  а этот принимал три точки?
[02:01:36.400 --> 02:01:38.400]  Первый ничего, второй три точки.
[02:01:40.400 --> 02:01:42.400]  Возможно.
[02:01:42.400 --> 02:01:44.400]  Давайте проверим, наверное, да.
[02:01:44.400 --> 02:01:46.400]  Ну и это будет return true,
[02:01:46.400 --> 02:01:48.400]  а это будет return false.
[02:01:54.400 --> 02:01:56.400]  И констракт спор.
[02:01:56.400 --> 02:01:58.400]  Да, ну и давайте...
[02:01:58.400 --> 02:02:00.400]  Ладно, я не буду все-таки так делать.
[02:02:00.400 --> 02:02:02.400]  И констракт спор давайте напишу здесь,
[02:02:02.400 --> 02:02:04.400]  чтобы он не жаловался,
[02:02:04.400 --> 02:02:06.400]  что я...
[02:02:06.400 --> 02:02:08.400]  вот так.
[02:02:10.400 --> 02:02:12.400]  Так.
[02:02:12.400 --> 02:02:14.400]  За секунду.
[02:02:16.400 --> 02:02:18.400]  Мы сделали
[02:02:20.400 --> 02:02:22.400]  две штуки.
[02:02:22.400 --> 02:02:24.400]  Одна от ничего, вторая от чего.
[02:02:24.400 --> 02:02:26.400]  И давайте теперь я напишу,
[02:02:26.400 --> 02:02:28.400]  что это просто...
[02:02:28.400 --> 02:02:30.400]  А что это такое?
[02:02:30.400 --> 02:02:32.400]  Ну, он должен...
[02:02:32.400 --> 02:02:34.400]  У нас следовался bool constant,
[02:02:34.400 --> 02:02:36.400]  а т.д. констракт, я вот перекручиваю скобочки.
[02:02:36.400 --> 02:02:38.400]  Ну, там конкретными...
[02:02:38.400 --> 02:02:40.400]  Ну, получается так, да.
[02:02:40.400 --> 02:02:42.400]  Давайте у нас следуемся т.д. bool constant.
[02:02:42.400 --> 02:02:44.400]  Она же 17 появилась, да?
[02:02:44.400 --> 02:02:46.400]  А мы могли свои пользоваться.
[02:02:46.400 --> 02:02:48.400]  т.д.
[02:02:48.400 --> 02:02:50.400]  констракт.
[02:02:54.400 --> 02:02:56.400]  Ну, можно было бы без констракт спор
[02:02:56.400 --> 02:02:58.400]  петь через the same.
[02:02:58.400 --> 02:03:00.400]  HasBetConstructHelper
[02:03:00.400 --> 02:03:02.400]  под t запятая arcs
[02:03:02.400 --> 02:03:04.400]  многоточие
[02:03:04.400 --> 02:03:06.400]  с пустыми круглыми скобочками,
[02:03:06.400 --> 02:03:08.400]  угловая скобочка закрылась, пустое тело.
[02:03:10.400 --> 02:03:12.400]  Ага. Так, и через...
[02:03:12.400 --> 02:03:14.400]  Какой у нас был bool из класса UnifB,
[02:03:14.400 --> 02:03:16.400]  а под констракт спора?
[02:03:16.400 --> 02:03:18.400]  Причем еще раз метод включался?
[02:03:18.400 --> 02:03:20.400]  Мы дикто это написали.
[02:03:20.400 --> 02:03:22.400]  Вместо того, чтобы возвращать
[02:03:22.400 --> 02:03:24.400]  bool из функции, мы просто
[02:03:24.400 --> 02:03:26.400]  из функции возвращаем разные типы,
[02:03:26.400 --> 02:03:28.400]  а здесь мы сравниваем, какой тип вернулся.
[02:03:28.400 --> 02:03:30.400]  Здесь я точно
[02:03:30.400 --> 02:03:32.400]  так же мог бы сделать.
[02:03:32.400 --> 02:03:34.400]  Ну, давайте будем считать, что мы понимаем,
[02:03:34.400 --> 02:03:36.400]  что это констэкспорт. Ну, в данном случае
[02:03:36.400 --> 02:03:38.400]  понятно, что это констэкспорт. Вообще
[02:03:38.400 --> 02:03:40.400]  констэкспорт появилась в 2011
[02:03:40.400 --> 02:03:42.400]  плюсах, к слову,
[02:03:42.400 --> 02:03:44.400]  и оно появилось исходно для
[02:03:44.400 --> 02:03:46.400]  функций, т.е. вот это вот слово...
[02:03:46.400 --> 02:03:48.400]  Слово констэкспорт много смысла.
[02:03:48.400 --> 02:03:50.400]  Мы с вами уже видели один из них,
[02:03:50.400 --> 02:03:52.400]  а именно if констэкспорт.
[02:03:52.400 --> 02:03:54.400]  Но это только в 17 появилось.
[02:03:54.400 --> 02:03:56.400]  Исходно констэкспорт появилось именно для функций,
[02:03:56.400 --> 02:03:58.400]  именно вот для такой ситуации.
[02:03:58.400 --> 02:04:00.400]  И ограничение на функции было,
[02:04:00.400 --> 02:04:02.400]  что они могут состоять только
[02:04:02.400 --> 02:04:04.400]  из одного return и все.
[02:04:04.400 --> 02:04:06.400]  Вот в C++11
[02:04:06.400 --> 02:04:08.400]  ограничение на констэкспорт функций
[02:04:08.400 --> 02:04:10.400]  было таким. Просто нужно быть
[02:04:10.400 --> 02:04:12.400]  return сразу же, не быть этой в большей действии.
[02:04:12.400 --> 02:04:14.400]  Если функция что-то кроме return содержит,
[02:04:14.400 --> 02:04:16.400]  то это CE. Дальше эти ограничения
[02:04:16.400 --> 02:04:18.400]  ослаблялись вплоть до того,
[02:04:18.400 --> 02:04:20.400]  что констэкспорт Vector можно создавать
[02:04:20.400 --> 02:04:22.400]  в C++20, потому что констэкспорт
[02:04:22.400 --> 02:04:24.400]  Properator.New появился. Но
[02:04:24.400 --> 02:04:26.400]  это мы покозже обсудим, а пока...
[02:04:34.400 --> 02:04:36.400]  А, еще появились...
[02:04:38.400 --> 02:04:40.400]  Констэкспорт Properator.New это не самое смешное.
[02:04:42.400 --> 02:04:44.400]  Были констэкспорт циклы?
[02:04:44.400 --> 02:04:46.400]  Это понятно. Констэкспорт циклы уже давно были.
[02:04:46.400 --> 02:04:48.400]  Это нормально.
[02:04:48.400 --> 02:04:50.400]  Появился констэкспорт полиморфизм
[02:04:50.400 --> 02:04:52.400]  и констэкспорт динамик кастом.
[02:04:56.400 --> 02:04:58.400]  Я вам покажу пример
[02:04:58.400 --> 02:05:00.400]  с констэкспорт динамик кастом.
[02:05:00.400 --> 02:05:02.400]  Это самое смешное, если за последний год.
[02:05:02.400 --> 02:05:04.400]  Я просто ржал голос
[02:05:04.400 --> 02:05:06.400]  когда мне лекцию про это рассказывали,
[02:05:06.400 --> 02:05:08.400]  но это мы через пару недель
[02:05:08.400 --> 02:05:10.400]  обсудим.
[02:05:10.400 --> 02:05:12.400]  Вот сейчас
[02:05:12.400 --> 02:05:14.400]  только так используем.
[02:05:14.400 --> 02:05:16.400]  Так вот.
[02:05:16.400 --> 02:05:18.400]  Какая у нас проблема?
[02:05:18.400 --> 02:05:20.400]  Круглые скобочки.
[02:05:20.400 --> 02:05:22.400]  Ну давайте
[02:05:22.400 --> 02:05:24.400]  сначала проверим, что это работает.
[02:05:24.400 --> 02:05:26.400]  Давайте какую-нибудь структуру заведу, не знаю...
[02:05:28.400 --> 02:05:30.400]  Не знаю...
[02:05:30.400 --> 02:05:32.400]  Эмпти.
[02:05:32.400 --> 02:05:34.400]  Тест.
[02:05:34.400 --> 02:05:36.400]  Сейчас я...
[02:05:38.400 --> 02:05:40.400]  Давайте проверим, что
[02:05:40.400 --> 02:05:42.400]  у меня
[02:05:42.400 --> 02:05:44.400]  в тесте есть метод констракта
[02:05:44.400 --> 02:05:46.400]  от двух интов, скажем.
[02:05:48.400 --> 02:05:50.400]  И нет метода кон...
[02:05:50.400 --> 02:05:52.400]  Вот есть метод констракта от двух интов,
[02:05:52.400 --> 02:05:54.400]  есть метод констракта от трех интов.
[02:05:56.400 --> 02:05:58.400]  Не знаю, от int, double, int.
[02:05:58.400 --> 02:06:00.400]  Но нет метода от одного инта.
[02:06:00.400 --> 02:06:02.400]  Ну ладно, от двух интов, от трех интов, но нет от одного.
[02:06:02.400 --> 02:06:04.400]  Причем у них будут разных типов
[02:06:04.400 --> 02:06:06.400]  возвращенных, это не важно.
[02:06:06.400 --> 02:06:08.400]  Вот давайте проверим, что...
[02:06:08.400 --> 02:06:10.400]  И констракт от int...
[02:06:12.400 --> 02:06:19.400]  А, значит, проверяю, hes... Ну, hes-метод-констракт В еще, конечно, надо.
[02:06:22.400 --> 02:06:24.400]  Господи, ладно.
[02:06:26.400 --> 02:06:31.400]  hes-метод-констракт В равно... это какой-то статистический букл?
[02:06:33.400 --> 02:06:36.400]  hes-метод-констракт В это...
[02:06:36.400 --> 02:06:38.400]  hes-метод-констракт?
[02:06:38.400 --> 02:06:40.400]  hes-метод-констракт
[02:06:42.400 --> 02:06:44.400]  Да, у нас T маленький, кстати, да.
[02:06:47.400 --> 02:06:49.400]  Как это произошло?
[02:06:51.400 --> 02:06:53.400]  Что я сделал?
[02:06:53.400 --> 02:06:54.400]  Капс не нажал.
[02:06:54.400 --> 02:06:57.400]  Нет, я же вроде... ладно, ладно.
[02:07:00.400 --> 02:07:03.400]  hes-метод-констракт, вот T, запытаю, arts...
[02:07:03.400 --> 02:07:05.400]  value
[02:07:05.400 --> 02:07:17.400]  Давайте проверим, что hes-метод-констракт от тест-инт-инт,
[02:07:17.400 --> 02:07:22.400]  hes-метод-констракт В, тест-инт...
[02:07:24.400 --> 02:07:28.400]  Но нет hes-метод-констракт от...
[02:07:29.400 --> 02:07:33.400]  Ладно. Нет, нет, нет hes-метод-констракт...
[02:07:33.400 --> 02:07:38.400]  Ну, есть hes-метод-констракт от двух интов, есть hes-метод-констракт от трех интов.
[02:07:38.400 --> 02:07:43.400]  У меня плохие новости. Call is ambiguous, то есть так нельзя в перегрузках.
[02:07:44.400 --> 02:07:49.400]  Сейчас выпаиваю логик. Не привыкать, не переводить, говорится.
[02:07:49.400 --> 02:07:51.400]  А, мы перегрузки... ну, там ими можно принять.
[02:07:51.400 --> 02:07:52.400]  Да, да.
[02:07:52.400 --> 02:07:55.400]  А, то есть твоя идея... это же ты сам и предложил.
[02:07:55.400 --> 02:07:57.400]  Все, завалили.
[02:07:57.400 --> 02:08:01.400]  А, сейчас. А может, не в эту проблему?
[02:08:01.400 --> 02:08:05.400]  То есть перегрузка, по принципу, нет аргументов или что угодно принято, не работает?
[02:08:05.400 --> 02:08:07.400]  Не, у тебя же не в эту проблему есть.
[02:08:07.400 --> 02:08:11.400]  Так, сейчас, короче, давайте я протестирую.
[02:08:11.400 --> 02:08:17.400]  Call is ambiguous, потому что у него есть версия...
[02:08:20.400 --> 02:08:26.400]  Ну, давайте сделаем, давайте проверим, если здесь добавить инт.
[02:08:27.400 --> 02:08:33.400]  А здесь добавить... а здесь... да, и здесь я буду вызывать... вот инта получается.
[02:08:33.400 --> 02:08:35.400]  От нуля.
[02:08:38.400 --> 02:08:40.400]  От нуля.
[02:08:42.400 --> 02:08:46.400]  Все, работает. Ну, значит, такая перегрузка, все-таки, не разрешена.
[02:08:46.400 --> 02:08:48.400]  Ну, все, работает.
[02:08:49.400 --> 02:08:56.400]  Помогу на вопрос, хотим ли мы распознавать приватные...
[02:08:56.400 --> 02:09:00.400]  Я думаю, что это будет вопрос на какой-нибудь вход на экзамен, на такой курсе.
[02:09:00.400 --> 02:09:04.400]  Раньше это было вопросом на отм, но я думаю, что пора повышать форму.
[02:09:04.400 --> 02:09:11.400]  Ты послушаешь несколько... давай, короче, на экзамене можно менять... повышать оценку постфактом.
[02:09:11.400 --> 02:09:15.400]  Потому что первые несколько людей, которые очень сильно обосрутся,
[02:09:15.400 --> 02:09:19.400]  и ты еще будешь считать, что они просто тупые, а не весь поток такой.
[02:09:19.400 --> 02:09:23.400]  Они получат низкую оценку, а остальные, когда ты уже посмиришься с ним, что все тупые,
[02:09:23.400 --> 02:09:26.400]  и начнешь с него все выше и выше стоять, можешь потом первым, если менять,
[02:09:26.400 --> 02:09:28.400]  каким-нибудь оценку поднять обратно.
[02:09:28.400 --> 02:09:30.400]  Вот до этого и нужен письменный экзамен.
[02:09:30.400 --> 02:09:33.400]  А, точно, все, письменный экзамен будет. Все, все, отлично.
[02:09:33.400 --> 02:09:38.400]  Потому что на усном есть еще и такая проблема, что твои ожидания от людей меняются
[02:09:38.400 --> 02:09:42.400]  по мере того, как новые люди, прикольно.
[02:09:42.400 --> 02:09:49.400]  Поэтому, кстати, когда на экзамен запускают сначала людей с высокими результатами семестра,
[02:09:49.400 --> 02:09:54.400]  а потом с низкими, то для последних это более плохие новости, чем когда запускают наоборот.
[02:09:54.400 --> 02:09:57.400]  Ну да, для первых сложных, для всех.
[02:09:57.400 --> 02:09:59.400]  Да, для всех, да.
[02:10:02.400 --> 02:10:05.400]  Но запускать наоборот было бы как-то совсем халяво.
[02:10:07.400 --> 02:10:08.400]  Ладно.
[02:10:09.400 --> 02:10:12.400]  Так вот, вопрос главный, не главный.
[02:10:12.400 --> 02:10:16.400]  Вопрос, хотим ли мы уметь распознавать приватный конструктор?
[02:10:16.400 --> 02:10:17.400]  Да.
[02:10:19.400 --> 02:10:20.400]  Все.
[02:10:20.400 --> 02:10:25.400]  А можем ли мы, а можем ли мы можем сделать ремни, шаблонные?
[02:10:25.400 --> 02:10:29.400]  Сейчас, мы не можем сейчас тем, что у каждого из элементов ARX есть конструктор по умолчанию.
[02:10:29.400 --> 02:10:33.400]  Да, да, значит, у этой реализации есть одна фундаментальная проблема.
[02:10:33.400 --> 02:10:37.400]  Ни ты, ни ARX, вообще говоря, не обязаны иметь конструктор по умолчанию.
[02:10:37.400 --> 02:10:38.400]  Ага.
[02:10:38.400 --> 02:10:40.400]  Или они могут его иметь, но он приватный.
[02:10:40.400 --> 02:10:45.400]  И вся эта конструкция перестанет работать, ну, для локатора.
[02:10:45.400 --> 02:10:47.400]  Ну, где собираемся? В локатор трейдс.
[02:10:47.400 --> 02:10:51.400]  Это важно, потому что если у какого-то из ARX нет конструктора по умолчанию,
[02:10:51.400 --> 02:10:54.400]  это все отвалится, но не по причине, что методоконстракт не было,
[02:10:54.400 --> 02:10:58.400]  а по причине, что вот в этом выражении он ARX не смог сконструировать по умолчанию.
[02:10:58.400 --> 02:11:00.400]  Что же делать?
[02:11:01.400 --> 02:11:05.400]  Нужно как-то научиться конструировать, когда мы вообще не знаем, есть у меня хоть один конструктор.
[02:11:05.400 --> 02:11:07.400]  А кто-нибудь знает? Ты знаешь решение?
[02:11:07.400 --> 02:11:09.400]  У меня есть идея, но очень странная.
[02:11:09.400 --> 02:11:12.400]  Ты просто если смотрел лекции прошлых лет, то может ты знаешь.
[02:11:12.400 --> 02:11:16.400]  Я их смотрю домой, я их смотрю, когда хотела взять матрицы, и мне там...
[02:11:16.400 --> 02:11:17.400]  А, понятно.
[02:11:17.400 --> 02:11:18.400]  У меня есть очень странная идея.
[02:11:18.400 --> 02:11:20.400]  Ну, вот мы хотим когда-то получить объект нашего типа, из ничего.
[02:11:20.400 --> 02:11:21.400]  Да.
[02:11:21.400 --> 02:11:23.400]  Ринтерпрет кастом, каким-нибудь.
[02:11:23.400 --> 02:11:25.400]  В смысле.
[02:11:25.400 --> 02:11:27.400]  А из чего ты подумаешь?
[02:11:27.400 --> 02:11:29.400]  Да хоть из ЛПТР.
[02:11:32.400 --> 02:11:33.400]  В принципе, можно.
[02:11:33.400 --> 02:11:35.400]  То есть ты говоришь, Ринтерпрет кастом.
[02:11:37.400 --> 02:11:38.400]  Каркс.
[02:11:40.400 --> 02:11:41.400]  Каркс.
[02:11:43.400 --> 02:11:44.400]  Нет, Каркс.
[02:11:47.400 --> 02:11:49.400]  Каркс звездочка, и потом еще звездочка.
[02:11:49.400 --> 02:11:50.400]  Звездочка.
[02:11:52.400 --> 02:11:53.400]  Может еще...
[02:12:00.400 --> 02:12:02.400]  Без X и плюс-плюс не исчерпаем.
[02:12:04.400 --> 02:12:06.400]  И все обогащается с быстротой поражающей.
[02:12:09.400 --> 02:12:10.400]  Ну, вроде так...
[02:12:11.400 --> 02:12:12.400]  Проверим.
[02:12:13.400 --> 02:12:14.400]  Вроде так должно работать.
[02:12:16.400 --> 02:12:17.400]  Это ужасно.
[02:12:19.400 --> 02:12:20.400]  Это работает.
[02:12:26.400 --> 02:12:29.400]  Но это не очень хорошее решение.
[02:12:32.400 --> 02:12:33.400]  Мы сами понимаем, почему.
[02:12:33.400 --> 02:12:34.400]  Нет.
[02:12:37.400 --> 02:12:40.400]  Оно менее костылем, чем все, что мы писали до этого.
[02:12:41.400 --> 02:12:42.400]  Ну вот а что с Т делать?
[02:12:43.400 --> 02:12:44.400]  То же самое.
[02:12:44.400 --> 02:12:45.400]  То же самое?
[02:12:47.400 --> 02:12:48.400]  Ну да.
[02:12:49.400 --> 02:12:51.400]  Просто тут знаете, какая проблема есть?
[02:12:51.400 --> 02:12:53.400]  Тут есть еще проблема с value.
[02:12:53.400 --> 02:12:54.400]  С видом value.
[02:12:55.400 --> 02:12:56.400]  С каким?
[02:12:56.400 --> 02:12:57.400]  Какого value?
[02:12:57.400 --> 02:13:01.400]  Мы сейчас получили L-value, типа ARKS.
[02:13:02.400 --> 02:13:04.400]  Если мы так сделаем с Т, у нас будет L-value типа T.
[02:13:07.400 --> 02:13:08.400]  А мы хотим...
[02:13:08.400 --> 02:13:09.400]  R-value.
[02:13:09.400 --> 02:13:10.400]  Вот.
[02:13:10.400 --> 02:13:11.400]  А мы хотим, чтобы...
[02:13:11.400 --> 02:13:13.400]  Мы хотим скорее R-value.
[02:13:13.400 --> 02:13:14.400]  Чтобы у нас есть...
[02:13:14.400 --> 02:13:18.400]  Чтобы если у нас был констракт от R-value, мы его тоже распознали.
[02:13:19.400 --> 02:13:22.400]  Ну то есть, вдруг у нас конструктор мог принимать констракт, что...
[02:13:22.400 --> 02:13:23.400]  Сейчас, сейчас, сейчас.
[02:13:23.400 --> 02:13:25.400]  Вот этот рибер-пидкаст нам что отдал?
[02:13:25.400 --> 02:13:26.400]  L-value.
[02:13:27.400 --> 02:13:28.400]  Этот рибер-пидкаст дал pointer.
[02:13:28.400 --> 02:13:29.400]  Но мы разаменовали pointer.
[02:13:29.400 --> 02:13:31.400]  Разаменование pointer дает нам L-value.
[02:13:31.400 --> 02:13:32.400]  Ну, можно вообще...
[02:13:33.400 --> 02:13:34.400]  Можно, да.
[02:13:35.400 --> 02:13:36.400]  Что?
[02:13:43.400 --> 02:13:48.400]  Мне очень нравится мой предмет тем, что наверняка это единственный предмет,
[02:13:48.400 --> 02:13:50.400]  на котором просто на последних...
[02:13:51.400 --> 02:13:53.400]  В апрель-май это каждая вторая лекция.
[02:13:53.400 --> 02:13:55.400]  Это люди просто время прям держат в голове.
[02:13:56.400 --> 02:13:58.400]  Мне кажется, в других предметах такого нет.
[02:13:58.400 --> 02:13:59.400]  Я очень горжусь.
[02:14:00.400 --> 02:14:01.400]  В общем, нас...
[02:14:02.400 --> 02:14:03.400]  Да.
[02:14:04.400 --> 02:14:05.400]  В таком-то смысле, да.
[02:14:06.400 --> 02:14:07.400]  В замечении такое весело.
[02:14:09.400 --> 02:14:13.400]  Я покажу вам, что придумал комитет для решения этих проблем.
[02:14:14.400 --> 02:14:18.400]  Я думаю, сейчас вы посмеетесь еще сильнее.
[02:14:19.400 --> 02:14:21.400]  Смотрите, нам нужна просто какая-то конструкция,
[02:14:21.400 --> 02:14:23.400]  ну, просто не хочется построиться от ринтер-пидкаста.
[02:14:23.400 --> 02:14:26.400]  Наверное, так можно было бы, то есть всегда лепить ринтер-пидкаст,
[02:14:26.400 --> 02:14:27.400]  но на самом деле есть...
[02:14:27.400 --> 02:14:29.400]  А если напишем фигурные скобочки, что будет?
[02:14:29.400 --> 02:14:30.400]  Тоже самое.
[02:14:30.400 --> 02:14:31.400]  Тоже самое, да?
[02:14:31.400 --> 02:14:32.400]  Можно просто...
[02:14:33.400 --> 02:14:36.400]  Ну, есть примитив метапрограммирования, еще один,
[02:14:36.400 --> 02:14:41.400]  который позволяет просто по типу T получить объект типа T.
[02:14:42.400 --> 02:14:46.400]  Стаб иногда бывает нужно по типу T для вот таких контекстов,
[02:14:46.400 --> 02:14:48.400]  для Anomaly Edited Context.
[02:14:48.400 --> 02:14:49.400]  Это же Anomaly Edited Context.
[02:14:49.400 --> 02:14:51.400]  Мы под декл-тайпом находимся.
[02:14:52.400 --> 02:14:55.400]  Он не будет реально создавать объект типа T.
[02:14:55.400 --> 02:14:59.400]  Ему нужно просто некоторые выражения типа T подставить, имея тип T.
[02:14:59.400 --> 02:15:00.400]  Ну да.
[02:15:00.400 --> 02:15:02.400]  Для этого в стандартной библиотеке существует функция,
[02:15:02.400 --> 02:15:04.400]  которая называется DECLVAL.
[02:15:04.400 --> 02:15:08.400]  А можно же ее сделать через ринтер-пидкаст и больше не мучиться?
[02:15:09.400 --> 02:15:10.400]  Смотрите.
[02:15:10.400 --> 02:15:11.400]  DECLVAL.
[02:15:11.400 --> 02:15:12.400]  Что она делает?
[02:15:14.400 --> 02:15:17.400]  Она имеет следующий синдекс использования.
[02:15:17.400 --> 02:15:20.400]  DECLVAL с шаблонным параметром T, пустые скобочки.
[02:15:20.400 --> 02:15:22.400]  Ой, шаблонный параметр MAX.
[02:15:24.400 --> 02:15:28.400]  И здесь я пишу DECLVAL с шаблонным параметром T, пустые скобочки.
[02:15:31.400 --> 02:15:35.400]  Это выражение, это функция, которая просто возвращает T.
[02:15:36.400 --> 02:15:38.400]  И ничего не принимает.
[02:15:40.400 --> 02:15:42.400]  Это будет R-value.
[02:15:42.400 --> 02:15:45.400]  Но если я ему бы сказал так, это было бы L-value.
[02:15:45.400 --> 02:15:48.400]  Но я могу ему сказать, понятно, сколько амперсантов я доведу.
[02:15:48.400 --> 02:15:50.400]  То есть она возвращает тип...
[02:15:50.400 --> 02:15:52.400]  Ну, какой надо.
[02:15:52.400 --> 02:15:53.400]  Вот.
[02:15:53.400 --> 02:15:54.400]  Вопрос.
[02:15:54.400 --> 02:15:57.400]  А что на самом деле, как она реализована?
[02:15:58.400 --> 02:15:59.400]  Ответ.
[02:15:59.400 --> 02:16:00.400]  Никак.
[02:16:05.400 --> 02:16:06.400]  Все.
[02:16:08.400 --> 02:16:12.400]  Ей не нужна реализация, потому что она никогда не должна вызываться.
[02:16:12.400 --> 02:16:14.400]  Но ее не может быть реализована.
[02:16:14.400 --> 02:16:19.400]  Ну, вероятно, можно с интерпрет-кастом намутить то, что вы там придумали.
[02:16:19.400 --> 02:16:21.400]  Ну, наверное, это...
[02:16:22.400 --> 02:16:27.400]  Я не знаю, может быть, кстати, это действительно бы ракомпилировалось во всех случаях.
[02:16:27.400 --> 02:16:29.400]  Нам нужна реализация DECLVAL.
[02:16:29.400 --> 02:16:33.400]  А если 40, 50, 100 константов не нужно, потому что DECLTYPE...
[02:16:33.400 --> 02:16:34.400]  Вот DECLTYPE не нужно даже.
[02:16:34.400 --> 02:16:36.400]  Я не вызываю константов.
[02:16:36.400 --> 02:16:38.400]  А разве факт в том, что...
[02:16:39.400 --> 02:16:40.400]  Нет.
[02:16:40.400 --> 02:16:41.400]  Не вызываю.
[02:16:41.400 --> 02:16:42.400]  Это ангелы от конкурса.
[02:16:42.400 --> 02:16:46.400]  Я не смотрю тип выражения, который получится, если бы ее вызвали.
[02:16:46.400 --> 02:16:47.400]  Но я не собираюсь ее вызывать.
[02:16:47.400 --> 02:16:48.400]  Нормально, да.
[02:16:51.400 --> 02:16:52.400]  Классно.
[02:16:53.400 --> 02:16:55.400]  Почему она называется DECLVAL?
[02:16:55.400 --> 02:16:59.400]  Ну, это value, который используется DECLTYPE.
[02:16:59.400 --> 02:17:00.400]  Не знаю.
[02:17:00.400 --> 02:17:03.400]  Потому что это в каком-то смысле противоположность DECLTYPE.
[02:17:03.400 --> 02:17:05.400]  Это операция обратная DECLTYPE.
[02:17:05.400 --> 02:17:09.400]  У вас DECLTYPE по выражению говорит, какой у него тип.
[02:17:09.400 --> 02:17:14.400]  А DECLVAL, наоборот, по типу дает вам выражение какого-то такого типа.
[02:17:16.400 --> 02:17:20.400]  DECLVAL и DECLTYPE это взаимно обратные в каком-то смысле операции.
[02:17:22.400 --> 02:17:26.400]  DECLTYPE вам дает из типа и значение тип.
[02:17:26.400 --> 02:17:28.400]  DECLVAL вам из типа дает значение.
[02:17:28.400 --> 02:17:30.400]  DECLTYPE от DECLVAL от T это T.
[02:17:31.400 --> 02:17:32.400]  Ну, да.
[02:17:34.400 --> 02:17:37.400]  DECLVAL это функция, а DECLTYPE это метафункция.
[02:17:39.400 --> 02:17:40.400]  На него реально работает.
[02:17:41.400 --> 02:17:42.400]  Хорошо, вопрос такой.
[02:17:43.400 --> 02:17:46.400]  Если у нас есть констракт...
[02:17:48.400 --> 02:17:49.400]  Два вопроса.
[02:17:50.400 --> 02:17:55.400]  У нас у констракта могут быть, во-первых, value, что-то там справа.
[02:17:55.400 --> 02:17:57.400]  Во-вторых, может быть const qualifier.
[02:17:57.400 --> 02:18:00.400]  В-третьих, может быть volatile qualifier.
[02:18:01.400 --> 02:18:03.400]  Я сейчас вызвал констракт от R-value.
[02:18:03.400 --> 02:18:04.400]  Да.
[02:18:05.400 --> 02:18:06.400]  Любой из твоих вариантов...
[02:18:06.400 --> 02:18:07.400]  Ну, только если...
[02:18:07.400 --> 02:18:08.400]  Нет, нет, нет.
[02:18:08.400 --> 02:18:10.400]  У ARKS все нормально, все понятно.
[02:18:11.400 --> 02:18:13.400]  Типа ты хочешь спросить, что если у меня...
[02:18:13.400 --> 02:18:15.400]  У меня в констракт обязательно...
[02:18:16.400 --> 02:18:18.400]  Что распознает эта функция сейчас?
[02:18:19.400 --> 02:18:21.400]  Я даю R-value.
[02:18:21.400 --> 02:18:24.400]  Вот я сейчас пытаюсь от R-value типа T вызвать констракт,
[02:18:24.400 --> 02:18:26.400]  и издав туда R-value типа в ARKS.
[02:18:26.400 --> 02:18:30.400]  То есть, если бы у меня был L-value qualifier...
[02:18:30.400 --> 02:18:32.400]  Ну, давай я просто тебе...
[02:18:32.400 --> 02:18:34.400]  Вот я сейчас L-value qualifier здесь поставлю,
[02:18:34.400 --> 02:18:36.400]  и мы увидим, что ноль будет пристрелиться.
[02:18:36.400 --> 02:18:37.400]  Во, да, окей.
[02:18:37.400 --> 02:18:38.400]  То есть, мы сейчас распознаем.
[02:18:39.400 --> 02:18:40.400]  Если нет...
[02:18:40.400 --> 02:18:41.400]  Все.
[02:18:41.400 --> 02:18:42.400]  Все, ну, логично.
[02:18:42.400 --> 02:18:43.400]  Все понятно, в смысле.
[02:18:43.400 --> 02:18:44.400]  А хотим ли мы так?
[02:18:44.400 --> 02:18:45.400]  Или нет?
[02:18:45.400 --> 02:18:46.400]  Нет.
[02:18:46.400 --> 02:18:47.400]  Ну...
[02:18:47.400 --> 02:18:48.400]  Ну...
[02:18:48.400 --> 02:18:49.400]  Можно еще одну версию написать?
[02:18:49.400 --> 02:18:50.400]  В смысле?
[02:18:50.400 --> 02:18:51.400]  Чтобы идти и те распознавать?
[02:18:51.400 --> 02:18:52.400]  Ну, да.
[02:18:52.400 --> 02:18:54.400]  Ну, это разная штука просто, да, поэтому...
[02:18:54.400 --> 02:18:55.400]  Пока.
[02:18:55.400 --> 02:18:58.400]  Ммм...
[02:18:58.400 --> 02:19:00.400]  Вот, можно здесь...
[02:19:00.400 --> 02:19:01.400]  Можно вот так сделать.
[02:19:03.400 --> 02:19:04.400]  Тогда это будет распознаваться.
[02:19:04.400 --> 02:19:07.400]  Но мы должны выбрать, по сути, что с этим, как распознать.
[02:19:09.400 --> 02:19:11.400]  Я вот здесь имперсан поставлю.
[02:19:11.400 --> 02:19:12.400]  Да, да, да.
[02:19:12.400 --> 02:19:21.440]  я вот здесь имперсант поставил, понятно что теперь это стало L-value и поэтому
[02:19:21.440 --> 02:19:25.860]  теперь это распознает. Да, но теперь если L-value-coolifier написать, то обратное
[02:19:25.860 --> 02:19:34.680]  программное. Да, конечно. Вот сейчас я вас немножечко еще удивлю, вероятно. Но вообще, если мы
[02:19:34.680 --> 02:19:39.880]  проверяем только наличие, сейчас. Мы сейчас не умеем проверять просто наличие.
[02:19:39.880 --> 02:19:45.680]  Ну по сути она спрашивает, если бы у меня был объект такого типа, был бы у меня такой метод, вот он тебе ответит.
[02:19:45.680 --> 02:19:52.280]  Да, он правильно ответит. Сейчас я вас немножечко удивлю. Давайте посмотрим на DecalVal.
[02:19:52.280 --> 02:19:56.640]  Внимательно. Вы можете заметить, что сигнатура не совсем такая, как я сказал.
[02:19:56.640 --> 02:20:07.840]  Adderley Reference. Вопрос. Зачем? Обычно нужно. Почему DecalVal на самом деле
[02:20:07.840 --> 02:20:20.040]  возвращает не, во-первых, но Accept. Это очень важно, кстати. Почему? А разве? Да. Вы поймете почему.
[02:20:20.040 --> 02:20:30.000]  Мы же не вызываем ее. Давайте, ладно. Сейчас вызовем. Ладно, DecalVal берем на Accept.
[02:20:30.000 --> 02:20:42.120]  Почему Adderley Reference, а не просто T? Потому что мы не можем просто так взять T и добавить два амперсанда.
[02:20:42.120 --> 02:20:47.960]  Зачем вообще добавлять два амперсанда? Сейчас, пусть нам дали тип T, в смысле вот мы хотим
[02:20:47.960 --> 02:20:56.720]  здесь использовать, сейчас. Пусть мы хотим использовать HasMethodConstruct. Да. И нам отдали в качестве
[02:20:56.720 --> 02:21:06.120]  шаблонного аргумента T двойной амперсант. А FTD Adderley Reference не просто добавит два амперсанда,
[02:21:06.120 --> 02:21:12.160]  а сделает ровно два амперсанда. Я спрашиваю, почему у нас Adderley Reference вместо двух амперсанда?
[02:21:12.160 --> 02:21:19.280]  Зачем вообще добавлять амперсанды? Более того, что ты не можешь это сделать руками. Зачем? Почему мы
[02:21:19.280 --> 02:21:27.560]  возвращаем T двойной амперсант, а не просто T? Снять проще, чем навесить. Сейчас. Чего? Нет, у нас
[02:21:27.560 --> 02:21:35.600]  возможно там правило того, какой тип выражения. Вот этот пункт с углоскопочкой, он же, кажется, немножко и так определяется просто.
[02:21:35.600 --> 02:21:49.400]  Сейчас, я не помню, есть ли здесь ответ.
[02:21:54.400 --> 02:21:57.760]  Не помню, есть ли ответ у нас. Во, вот этот вопрос.
[02:22:06.600 --> 02:22:32.920]  Ну, потому что, потому что, если бы мы возвращали чисто T, то ему бы приходилось, ну, вот вам пример, когда это бы не сработало.
[02:22:32.920 --> 02:22:41.120]  У вас существует так называемое понятие incomplete type в стандарте. Это тип,
[02:22:41.120 --> 02:22:45.760]  либо у которого тело, это либо класс, который объявлен, но не определен, либо это, например,
[02:22:45.760 --> 02:22:57.240]  класс, у которого деструктор приватный. Нет, у него не определен деструктор, он не объявлен, но не определен. А еще он приватный.
[02:22:57.240 --> 02:23:08.520]  Он написан в комментариях, ошибка inaccessible destructor. Inaccessible, это значит он приватный. Недоступный, недоступный, значит приватный. Вот.
[02:23:08.520 --> 02:23:23.320]  Спасибо. Следующие типы incomplete. А, нет, виноват. Значит, класс приватным деструктором не считается incomplete.
[02:23:23.320 --> 02:23:37.000]  Ну, вот эти типы считаются incomplete. Короче, что меняет, что я возвращаю T, а не T2? Если бы я попытался, например,
[02:23:37.000 --> 02:23:55.080]  для такого класса попробовать сделать Decal Perval, это было бы CE. Потому что, чтобы компилятору,
[02:23:55.080 --> 02:24:01.640]  ну, чтобы корректным было выражение, чтобы вернуть ссылку на что-то, не нужно, чтобы это что-то
[02:24:01.640 --> 02:24:09.320]  можно было бы создать. А чтобы вернуть сам этот тип, нужно еще, например, проверить, что деструктор не приватный,
[02:24:09.320 --> 02:24:18.600]  или что у него вообще есть определение. Вы можете вернуть RLU ссылку на T, ну, то есть возвращение RLU ссылки на T
[02:24:18.600 --> 02:24:25.800]  не приводит к Compiled-up Error'у в аналогической контексте, если объект типа T нельзя создать в принципе.
[02:24:25.880 --> 02:24:31.880]  А возвращение объекта типа T привело бы к CE, потому что, ну, например, если бы у него был приватный деструктор,
[02:24:31.880 --> 02:24:41.000]  то нельзя было бы вообще вызывать функцию, которая возвращает T. Само возвращение T, потенциальное, приводило бы к CE.
[02:24:41.000 --> 02:24:47.240]  Вот вам пример с приватным деструктором, вот вам пример с классом, который объявлен неопределен.
[02:24:48.200 --> 02:24:57.720]  Вот, еще интересный момент. А если бы T был каким-то шаблонным классом, то возвращение T
[02:24:57.720 --> 02:25:04.520]  не заставлял бы компилятор инстанцировать этот шаблонный класс. А если вы возвращаете прям T,
[02:25:04.520 --> 02:25:10.280]  то компилятор пытается понять, что это такое, он мог начать выинстанцировать.
[02:25:11.240 --> 02:25:15.160]  Вот, поэтому здесь возвращается T-двойной амперсант.
[02:25:15.160 --> 02:25:17.160]  А почему там это...
[02:25:17.160 --> 02:25:19.160]  Это следующий хороший вопрос, сейчас поймем.
[02:25:19.160 --> 02:25:21.160]  А мне что? А не T-двойной амперсант?
[02:25:21.160 --> 02:25:25.160]  Сейчас, смотрите. Давайте сначала, почему двойной, а не одинарный?
[02:25:25.160 --> 02:25:31.160]  Потому что одинарный всегда выдавал L-value, а двойной никогда не портит категорию значения.
[02:25:31.160 --> 02:25:38.280]  То есть, если я здесь пишу с одинарным амперсантом, то мне и возвращается одинарный амперсант.
[02:25:38.280 --> 02:25:42.760]  А если я пишу T без амперсантов или с двойным амперсантом, то мне двойной и вернется.
[02:25:42.760 --> 02:25:47.320]  То есть, категория value никогда не испортится от того, что я возвращаю двойной амперсант.
[02:25:47.320 --> 02:25:53.080]  Просто я в случаях, когда у меня был приватный деструктор или неопределенный класс,
[02:25:53.080 --> 02:25:56.040]  сумел бы его тоже здесь использовать.
[02:25:56.040 --> 02:25:58.040]  Почему adder value reference...
[02:25:58.040 --> 02:26:00.040]  А, потому что константность, если есть.
[02:26:00.040 --> 02:26:03.080]  Почему adder value reference, а не просто T-двойной амперсант?
[02:26:03.160 --> 02:26:09.640]  Потому что если бы это был void, то навешивание бы двойного амперсанта на void выдавало бы CE.
[02:26:09.640 --> 02:26:15.480]  Но здесь написано, the return type is T-двойной амперсант, unless T is posted to CV-qualified void,
[02:26:15.480 --> 02:26:17.800]  in which case the return type is T.
[02:26:17.800 --> 02:26:19.800]  Condition void?
[02:26:19.800 --> 02:26:21.800]  Ну да.
[02:26:21.800 --> 02:26:23.800]  Не трогай меня, астроту.
[02:26:23.800 --> 02:26:27.800]  Вот.
[02:26:27.800 --> 02:26:29.800]  Потому что...
[02:26:31.800 --> 02:26:33.800]  Ну вот еще такое adder value reference.
[02:26:33.800 --> 02:26:35.800]  Если T...
[02:26:35.800 --> 02:26:37.800]  Бла-бла-бла-бла-бла-бла...
[02:26:37.800 --> 02:26:39.800]  Ну короче, если...
[02:26:53.800 --> 02:26:57.800]  Ну, написано в ноуте, как раз, про то, что...
[02:26:57.800 --> 02:26:59.800]  Смогли.
[02:26:59.800 --> 02:27:03.800]  Adder value reference. Это double-type detail try adder value reference.
[02:27:05.800 --> 02:27:07.800]  От нуля.
[02:27:07.800 --> 02:27:09.800]  Try adder value reference.
[02:27:09.800 --> 02:27:13.800]  Это, значит, либо такая штука...
[02:27:13.800 --> 02:27:15.800]  Ну, опять с финагея.
[02:27:15.800 --> 02:27:19.800]  Смотрите, что такое adder value reference.
[02:27:19.800 --> 02:27:21.800]  Это...
[02:27:21.800 --> 02:27:23.800]  Try adder value reference.
[02:27:23.800 --> 02:27:25.800]  От нуля.
[02:27:25.800 --> 02:27:27.800]  Try adder value reference. Это функция...
[02:27:27.800 --> 02:27:29.800]  Без дела.
[02:27:29.800 --> 02:27:31.800]  У которой есть перегрузка от intitle, от чего угодно.
[02:27:31.800 --> 02:27:33.800]  Она пытается добавить adder value reference.
[02:27:33.800 --> 02:27:37.800]  И если получается, то, значит, такой типы есть.
[02:27:37.800 --> 02:27:39.800]  А если не получается, например, это был void,
[02:27:39.800 --> 02:27:41.800]  то, значит, это просто void и остается.
[02:27:41.800 --> 02:27:43.800]  Вот и все.
[02:27:43.800 --> 02:27:47.800]  Вот вам применение с финагея в очередной раз.
[02:27:47.800 --> 02:27:49.800]  Type identity.
[02:27:49.800 --> 02:27:51.800]  Почему их четыре? Трое?
[02:27:51.800 --> 02:27:53.800]  Потому что там LL еще есть.
[02:27:59.800 --> 02:28:01.800]  Так, ну все. Кажется, мы справились.
[02:28:09.800 --> 02:28:11.800]  Оно можно, наверное, adder value reference.
[02:28:11.800 --> 02:28:13.800]  Т.
[02:28:13.800 --> 02:28:15.800]  Ну да.
[02:28:15.800 --> 02:28:17.800]  Капитанчик.
[02:28:17.800 --> 02:28:21.800]  Так, ну еще. Попробуем реализовать, например, из constructible быстренько.
[02:28:21.800 --> 02:28:25.800]  Из constructible, из copy constructible, из move constructible.
[02:28:25.800 --> 02:28:29.800]  Вообще, конечно, в идеале нам реализовать из no from move constructible и move no accept еще.
[02:28:29.800 --> 02:28:31.800]  Но давайте реализуем из constructible.
[02:28:31.800 --> 02:28:33.800]  Как устроим...
[02:28:33.800 --> 02:28:35.800]  Из constructible.
[02:28:35.800 --> 02:28:37.800]  T, args.
[02:28:37.800 --> 02:28:39.800]  Что это такое?
[02:28:39.800 --> 02:28:41.800]  Например, до того, существует ли конструктор...
[02:28:41.800 --> 02:28:43.800]  По умолчанию?
[02:28:43.800 --> 02:28:45.800]  Нет, от args.
[02:28:45.800 --> 02:28:47.800]  То же самое.
[02:28:47.800 --> 02:28:49.800]  Он даже проще.
[02:28:49.800 --> 02:28:51.800]  Ну, в принципе, можно сказать, упражнение это слушать.
[02:28:51.800 --> 02:28:53.800]  Или то же самое, например.
[02:28:53.800 --> 02:28:55.800]  Да, то же самое. Ничего интересного.
[02:28:55.800 --> 02:28:57.800]  Ну просто я проверяю вот здесь.
[02:28:57.800 --> 02:28:59.800]  Все то же самое абсолютно.
[02:28:59.800 --> 02:29:01.800]  Просто здесь я напишу...
[02:29:01.800 --> 02:29:03.800]  Я попытаюсь decalval T.
[02:29:03.800 --> 02:29:05.800]  Круглые скобочки.
[02:29:05.800 --> 02:29:07.800]  Круглые скобочки.
[02:29:09.800 --> 02:29:11.800]  Нет, не так.
[02:29:11.800 --> 02:29:13.800]  Я здесь без decalval.
[02:29:13.800 --> 02:29:15.800]  Круглые скобочки от decalval от args.
[02:29:15.800 --> 02:29:17.800]  Вот и все.
[02:29:17.800 --> 02:29:19.800]  Все остальное абсолютно то же самое.
[02:29:19.800 --> 02:29:21.800]  Даже не хочу реализовывать.
[02:29:29.800 --> 02:29:31.800]  То же самое.
[02:29:31.800 --> 02:29:33.800]  Ну, какая разница?
[02:29:33.800 --> 02:29:35.800]  Нет, я помню, что я угадал.
[02:29:35.800 --> 02:29:37.800]  Если он только T, то угадал.
[02:29:39.800 --> 02:29:41.800]  А как такое может быть?
[02:29:41.800 --> 02:29:43.800]  Если у тебя есть конструктор от T и T2S.
[02:29:43.800 --> 02:29:45.800]  А как он вообще должен выбирать?
[02:29:45.800 --> 02:29:47.800]  Если у тебя есть конструктор от T и T2S,
[02:29:47.800 --> 02:29:49.800]  то это ambiguous call.
[02:29:49.800 --> 02:29:51.800]  Ты не можешь делать перегрузку
[02:29:51.800 --> 02:29:53.800]  по значению или по ссылке.
[02:29:53.800 --> 02:29:55.800]  Ты можешь перегрузку делать по разным видам ссылок,
[02:29:55.800 --> 02:29:57.800]  но не перегрузку по значению или по ссылке.
[02:29:57.800 --> 02:29:59.800]  А вот это не используется как раз.
[02:29:59.800 --> 02:30:01.800]  Да.
[02:30:01.800 --> 02:30:03.800]  Ладно?
[02:30:03.800 --> 02:30:05.800]  Да.
[02:30:05.800 --> 02:30:07.800]  Короче, давайте считать, что мы поняли,
[02:30:07.800 --> 02:30:09.800]  как реализовывается конструкция.
[02:30:09.800 --> 02:30:11.800]  Просто объекты, это все одно и то же.
[02:30:15.800 --> 02:30:17.800]  А что ж там?
[02:30:17.800 --> 02:30:19.800]  Ну, из constructible...
[02:30:21.800 --> 02:30:23.800]  Ну, тут еще есть test-privilege-constructible
[02:30:23.800 --> 02:30:25.800]  и no-fro-constructible.
[02:30:25.800 --> 02:30:27.800]  Вот я сейчас хочу реализовывать...
[02:30:27.800 --> 02:30:29.800]  Блин, я не знаю, может все-таки я это скопил.
[02:30:29.800 --> 02:30:31.800]  Давайте я, наверное,
[02:30:31.800 --> 02:30:33.800]  вот сейчас скопипашу
[02:30:33.800 --> 02:30:35.800]  и скажу просто, что мы
[02:30:35.800 --> 02:30:37.800]  вот это вот все я копирую
[02:30:37.800 --> 02:30:39.800]  и говорю...
[02:30:39.800 --> 02:30:41.800]  Просто заменяю здесь
[02:30:41.800 --> 02:30:43.800]  heads-method-construct, везде на is-constructible.
[02:30:49.800 --> 02:30:51.800]  На is-constructible.
[02:30:55.800 --> 02:30:57.800]  Что?
[02:30:57.800 --> 02:30:59.800]  heads-method-construct.
[02:31:03.800 --> 02:31:05.800]  Неужели я опечатываюся?
[02:31:05.800 --> 02:31:07.800]  В смысле?
[02:31:07.800 --> 02:31:09.800]  Так, еще раз.
[02:31:11.800 --> 02:31:13.800]  А, потому что надо сказать s же.
[02:31:19.800 --> 02:31:21.800]  Вот. И здесь просто я пишу
[02:31:21.800 --> 02:31:23.800]  не 2 колвала t, а просто пишу t...
[02:31:27.800 --> 02:31:29.800]  Да, приятно.
[02:31:35.800 --> 02:31:37.800]  Ну и все.
[02:31:37.800 --> 02:31:39.800]  Просто is-constructible.
[02:31:39.800 --> 02:31:41.800]  Еще интересно.
[02:31:41.800 --> 02:31:43.800]  Теперь, как определить
[02:31:43.800 --> 02:31:45.800]  is-copy-constructible и is-move-constructible?
[02:31:47.800 --> 02:31:49.800]  Правда ли, что
[02:31:49.800 --> 02:31:51.800]  тип копируемый
[02:31:51.800 --> 02:31:53.800]  как-то определить?
[02:31:53.800 --> 02:31:55.800]  Темплей type-name-t, ну давайте я
[02:31:55.800 --> 02:31:57.800]  просто здесь вот так вот
[02:31:59.800 --> 02:32:01.800]  эту часть копирую.
[02:32:01.800 --> 02:32:03.800]  Значит, что такое
[02:32:03.800 --> 02:32:05.800]  copy-constructible?
[02:32:05.800 --> 02:32:07.800]  Мне уже не нужно args вот здесь.
[02:32:07.800 --> 02:32:09.800]  is-copy-constructible.
[02:32:09.800 --> 02:32:11.800]  Так, у вас следующая пара есть,
[02:32:11.800 --> 02:32:13.800]  а то у вас уже, наверное, пускать надо.
[02:32:13.800 --> 02:32:15.800]  А, ну все тогда, сейчас.
[02:32:15.800 --> 02:32:17.800]  А, блин, уже все, у меня пора заканчивать.
[02:32:17.800 --> 02:32:19.800]  Жаль.
[02:32:19.800 --> 02:32:21.800]  Видимо, move-move-move-accept мы не успели реализовать.
[02:32:21.800 --> 02:32:23.800]  Ну ладно.
[02:32:23.800 --> 02:32:25.800]  Is-copy-constructible.
[02:32:25.800 --> 02:32:27.800]  Что мне надо написать?
[02:32:27.800 --> 02:32:29.800]  Ну это просто
[02:32:29.800 --> 02:32:31.800]  is-constructible, причем я даже думаю, что
[02:32:31.800 --> 02:32:33.800]  это уже
[02:32:33.800 --> 02:32:35.800]  is-copy-constructible.
[02:32:35.800 --> 02:32:37.800]  Is-constructible
[02:32:39.800 --> 02:32:41.800]  от
[02:32:41.800 --> 02:32:43.800]  te-
[02:32:43.800 --> 02:32:45.800]  const-em-percent.
[02:32:45.800 --> 02:32:47.800]  Type-name
[02:32:47.800 --> 02:32:49.800]  нет. Все, я просто сказал, что это точно
[02:32:49.800 --> 02:32:51.800]  такой тип. Is-copy-constructible
[02:32:51.800 --> 02:32:53.800]  это вообще-то
[02:32:53.800 --> 02:32:55.800]  та, что
[02:32:55.800 --> 02:32:57.800]  ну да, это тип.
[02:32:57.800 --> 02:32:59.800]  А te
[02:32:59.800 --> 02:33:01.800]  is-copy-constructible
[02:33:01.800 --> 02:33:03.800]  v это просто будет
[02:33:03.800 --> 02:33:05.800]  все то же самое, просто is-copy-constructible.
[02:33:05.800 --> 02:33:07.800]  Ну is-move-constructible
[02:33:07.800 --> 02:33:09.800]  то же самое, только с двумя персами.
[02:33:09.800 --> 02:33:11.800]  То есть, формально вот,
[02:33:11.800 --> 02:33:13.800]  который
[02:33:13.800 --> 02:33:15.800]  в общем и тихо направлял
[02:33:15.800 --> 02:33:17.800]  с тем
[02:33:17.800 --> 02:33:19.800]  template, конструктором копии,
[02:33:19.800 --> 02:33:21.800]  и формально здесь же ответ
[02:33:21.800 --> 02:33:23.800]  да будет copy-constructible,
[02:33:23.800 --> 02:33:25.800]  хотя, ну здесь
[02:33:25.800 --> 02:33:27.800]  непонятно.
[02:33:27.800 --> 02:33:29.800]  Проблема была в том, что
[02:33:29.800 --> 02:33:31.800]  copy-constructible
[02:33:31.800 --> 02:33:33.800]  был
[02:33:33.800 --> 02:33:35.800]  нет. Ответ
[02:33:35.800 --> 02:33:37.800]  вопрос, можно ли
[02:33:37.800 --> 02:33:39.800]  является ли тип копируемым?
[02:33:39.800 --> 02:33:41.800]  Если вызвать тест, попробовать создать
[02:33:41.800 --> 02:33:43.800]  от const-em-percent, это будет работать?
[02:33:43.800 --> 02:33:45.800]  Да. Как это будет работать?
[02:33:45.800 --> 02:33:47.800]  Непонятно, но
[02:33:47.800 --> 02:33:49.800]  а если вот, типа копируемый
[02:33:49.800 --> 02:33:51.800]  у него нет?
[02:33:51.800 --> 02:33:53.800]  А если именно, если copy-constructible
[02:33:53.800 --> 02:33:55.800]  не пересекнуть delete,
[02:33:55.800 --> 02:33:57.800]  надо оставить template.
[02:33:57.800 --> 02:33:59.800]  Скорее всего, он будет работать как надо
[02:33:59.800 --> 02:34:01.800]  в таком случае. Нет, это нет.
[02:34:01.800 --> 02:34:03.800]  Будет false, конечно.
[02:34:05.800 --> 02:34:07.800]  Конечно, ты же выбираешь
[02:34:07.800 --> 02:34:09.800]  версию перегрузки и видишь,
[02:34:09.800 --> 02:34:11.800]  что она delete.
[02:34:11.800 --> 02:34:13.800]  В этом именно и смысл.
[02:34:13.800 --> 02:34:15.800]  Ну is-move-constructible
[02:34:15.800 --> 02:34:17.800]  тоже понятно.
[02:34:17.800 --> 02:34:19.800]  Вот, нам
[02:34:19.800 --> 02:34:21.800]  видимо, так придется
[02:34:21.800 --> 02:34:23.800]  закончить сейчас, ну значит завтра
[02:34:23.800 --> 02:34:25.800]  продолжим. Мы хотим реализовать
[02:34:25.800 --> 02:34:27.800]  move-of-no-except.
[02:34:27.800 --> 02:34:29.800]  Но нужно придумать... move-of-no-except
[02:34:29.800 --> 02:34:31.800]  это функция, которая должна возвращать
[02:34:31.800 --> 02:34:33.800]  lvalue, если
[02:34:33.800 --> 02:34:35.800]  там тип был no-from-move-constructible.
[02:34:35.800 --> 02:34:37.800]  Наоборот, она должна move-ить,
[02:34:37.800 --> 02:34:39.800]  если это был no-from-move-constructible.
[02:34:39.800 --> 02:34:41.800]  И
[02:34:41.800 --> 02:34:43.800]  не move-ать, если это был не no-from-move-constructible.
[02:34:43.800 --> 02:34:45.800]  Нужно уметь проверять qualifier
[02:34:45.800 --> 02:34:47.800]  no-except. У нас есть
[02:34:47.800 --> 02:34:49.800]  no-except, есть копочка выражения
[02:34:49.800 --> 02:34:51.800]  У нас есть оператор no-except.
[02:34:51.800 --> 02:34:53.800]  Ну вот, короче...
[02:34:53.800 --> 02:34:55.800]  Вроде это звучит не очень сложно.
[02:34:55.800 --> 02:34:57.800]  Да, это не очень сложно, но там
[02:34:57.800 --> 02:34:59.800]  есть над чем подумать.
[02:34:59.800 --> 02:35:01.800]  Ну минут за 10 мы будем реализовали
[02:35:01.800 --> 02:35:03.800]  и обсудили, но уже
[02:35:03.800 --> 02:35:05.800]  я не буду задерживать, поэтому давайте закончим.
