[00:00.000 --> 00:10.000]  Дальше мы будем добавлять f2. Это еще какой-то другой путь, начинающийся из корня.
[00:10.000 --> 00:14.000]  Его конец мы тоже обозначим терминальной вершиной.
[00:14.000 --> 00:22.000]  Может быть, например, такое, что очередное слово частично совпадает с каким-то уже построенным путем, где-то в каком-то месте начинает цветвиться.
[00:22.000 --> 00:28.000]  Например, s3 у меня. Ну и какой-нибудь s4 может быть вообще префиксом уже добавленного слова.
[00:28.000 --> 00:32.000]  То есть может быть такое, что у вас одна терминаль является предком другой терминальной.
[00:32.000 --> 00:36.000]  Это в случае, если одно слово является префиксом другого слова.
[00:36.000 --> 00:38.000]  Вот.
[00:42.000 --> 00:50.000]  Соответственно, давайте напишем какой-нибудь мини-код, который добавляет набор слов в бор.
[00:50.000 --> 00:55.000]  То есть по факту строит бор по набору слов. Обстроение бора.
[00:55.000 --> 01:09.000]  Так. Ну давайте я скажу, что по умолчанию при создании вершины у меня tu заполняется минусоденицами, как знак того, что нет перехода ни по одной из букв.
[01:09.000 --> 01:13.000]  А терм по умолчанию false. То есть вершина по умолчанию не терминальная.
[01:13.000 --> 01:15.000]  Вот. Значит как у меня строится бор?
[01:15.000 --> 01:21.000]  Ну вот давайте я буду считать, что у меня уже вершина номер ноль в боре лежит.
[01:21.000 --> 01:25.000]  Да, и это будет корень. Корень нашего бора.
[01:25.000 --> 01:27.000]  Тогда добавление слова выглядит так.
[01:27.000 --> 01:35.000]  Давайте я напишу какой-нибудь там void, add, строчку. Как я добавляю строчку в бор?
[01:38.000 --> 01:44.000]  Надо просто поддерживать текущую вершину, где мы находимся. Изначально это будет корень.
[01:44.000 --> 01:53.000]  Дальше буду спускаться по этому бору, параллельно лететь по строке, и каждый раз нам нужно пройти по очередной букве нашего слова.
[01:53.000 --> 02:02.000]  Я буду сейчас в цикле идти, скажем, по всем i от нуля до размера s-1.
[02:02.000 --> 02:05.000]  Давайте я вот так напишу lem-s-1.
[02:07.000 --> 02:11.000]  И сейчас мне как бы хочется из вершины v прочитать букву s-i.
[02:11.000 --> 02:16.000]  Да, и если она уже есть, то мне нужно просто по ней спуститься, а если нет, то нужно ее завести.
[02:16.000 --> 02:21.000]  Вот это можно обработать, например, так, что если...
[02:21.000 --> 02:25.000]  Ну и давайте где-то у меня там был какой-нибудь...
[02:27.000 --> 02:29.000]  Вектор нодов.
[02:30.000 --> 02:35.000]  А, это, собственно, описание бора как просто набор вершин.
[02:35.000 --> 02:41.000]  Набор вершин бора, t, v, t, это вершина, отвечающая от значения v.
[02:41.000 --> 02:53.000]  Итак, значит, если t, v, tu от там s-i минус a равно минус 1,
[02:54.000 --> 03:02.000]  то это как раз значит, что из вершины v нельзя прочитать букву s-i.
[03:02.000 --> 03:10.000]  То есть t, v это вершина, у нее есть поле tu, которое для каждого символа хранит номер вершины, куда мы попадаем, если читаем такую букву.
[03:10.000 --> 03:13.000]  А это минус 1 означает, что такого перехода нет.
[03:13.000 --> 03:15.000]  Значит, нам надо его создать.
[03:17.000 --> 03:21.000]  Ну, например, можно сделать вот так вот это.
[03:24.000 --> 03:36.000]  Равно там t точка size и в t pushback новый вершин.
[03:36.000 --> 03:53.000]  Тем самым я, получается, обработал такой случай, когда из v не было перехода по нужной букве, а теперь я его создаю и, соответственно, заодно создаю новый вершин.
[03:53.000 --> 04:06.000]  То есть я в мой вектор pushback новую вершину и говорю, что теперь вот это t, v, в ней переход по букве s-i ведет ровно сюда, вот в эту новую добавленную вершину, потому что у нее был такой номер.
[04:06.000 --> 04:10.000]  Вот. Ну и все, дальше просто делаю переход.
[04:10.000 --> 04:24.000]  Спускаюсь как раз по этой стрелочке, то есть мне надо было взять и пройти из вершины v по букве s-i, вот я сейчас по ней прохожу.
[04:24.000 --> 04:27.000]  Так, это вот этот форм был.
[04:27.000 --> 04:33.000]  Вот, и в конце надо не забыть пометить ее терминальней, потому что она соответствует одному из слов.
[04:36.000 --> 04:37.000]  Конец.
[04:41.000 --> 04:42.000]  Вроде все очень просто.
[04:42.000 --> 04:46.000]  Да, то есть просто идем сверху вниз по бору, слева направо по строке.
[04:46.000 --> 04:54.000]  Если буквы, которые мне нужно прочитать, еще нету в списке исходящих ребер, то ее нужно создать, надо создать вот такой переход.
[04:54.000 --> 05:00.000]  Но потом, если мы его создали или если он был раньше, то я просто спускаюсь по этой букве с помощью этой строки.
[05:00.000 --> 05:04.000]  Ну и в конце, когда я всю строчку прочитал, надо последнюю посещенную вершину пометить терминальней.
[05:04.000 --> 05:10.000]  То есть я вот так вот спускаюсь по бору, читая буквы по одной и вершину, в которой я закончил, пометить терминальней.
[05:10.000 --> 05:12.000]  Вот вроде все.
[05:12.000 --> 05:13.000]  Понятно все?
[05:14.000 --> 05:16.000]  Тут вроде все совсем просто.
[05:17.000 --> 05:18.000]  Так, хорошо.
[05:21.000 --> 05:22.000]  Хорошо.
[05:22.000 --> 05:29.000]  Да, еще раз подчеркну, что терминальные вершины, это в точности те, которые соответствуют одному из этих слов, которые в самом начале мне дали.
[05:29.000 --> 05:33.000]  То есть у меня есть некий набор слов, я их буду называть словарными иногда, словарные слова.
[05:34.000 --> 05:36.000]  Которые мне дали в самом начале.
[05:37.000 --> 05:40.000]  Вот, да, ну в словаре в каком-то они лежат, в каком-то множестве.
[05:40.000 --> 05:44.000]  И вот в точности словарные слова будут соответствовать терминальным вершинам.
[05:48.000 --> 05:49.000]  Так, хорошо.
[05:49.000 --> 05:54.000]  Давайте еще обсудим, как можно по-другому хранить множество переходов.
[05:54.000 --> 06:04.000]  Ну понятно, что если у меня размер алфавита какой-то маленький, то весьма удобно просто с помощью массива хранить, да, для каждой буквы мы знаем переход какой-то быт.
[06:04.000 --> 06:05.000]  Вот.
[06:05.000 --> 06:08.000]  Вопрос, что делать если размер алфавита большой?
[06:08.000 --> 06:11.000]  Вопрос, что делать если размер алфавита большой?
[06:11.000 --> 06:14.000]  Ну понятно, да, можно хранить мапы или можно хранить хэштаблицу.
[06:14.000 --> 06:18.000]  Ну собственно, как бы у нас есть всякие структуры данных, которые можно пользоваться.
[06:18.000 --> 06:20.000]  Ну давайте их по сравнению.
[06:20.000 --> 06:22.000]  Как хранить множество переходов ту.
[06:22.000 --> 06:28.000]  Как хранить множество переходов.
[06:32.000 --> 06:34.000]  Так, да, ну давайте.
[06:34.000 --> 06:44.000]  Три способа у нас есть, массив, мап и хэштаблица.
[06:44.000 --> 06:45.000]  Вот.
[06:45.000 --> 06:52.000]  Ну и давайте скажем еще, что из вершины будет выстировано кастрелок.
[06:52.000 --> 06:58.000]  Тогда давайте померяем, сколько ему нужно памяти на хранение этого всего и за сколько это будет работать.
[06:58.000 --> 07:01.000]  Давайте с памяти начнем.
[07:01.000 --> 07:08.000]  Сколько памяти нужно массива, если я знаю, что из вершины выходит кастрелок, то я буду хранить массив.
[07:08.000 --> 07:11.000]  Давайте начнем.
[07:11.000 --> 07:23.000]  Сколько памяти нужно массива, если я знаю, что из вершины выходит кастрелок, а алфавит размера сигма.
[07:23.000 --> 07:28.000]  Сколько памяти нужно хранить в вершине, чтобы с помощью массива уметь переходить.
[07:28.000 --> 07:30.000]  Ну сигма, да, просто.
[07:30.000 --> 07:33.000]  Потому что мне нужно для каждой буквы знать, куда ведет переход.
[07:33.000 --> 07:36.000]  Ну а если нет, то там какое-то значение типа минус один.
[07:36.000 --> 07:38.000]  В мапе это, видимо, вот ка.
[07:38.000 --> 07:40.000]  Я не буду писать, о, я просто буду писать ка.
[07:40.000 --> 07:47.000]  Хаш таблицы тоже ка, потому что, кажется, если у нас есть ка или мяких хаш таблицы, то она имеет, например, типа 2к.
[07:47.000 --> 07:49.000]  Вроде у нас какая-то такая договоренность была, примерно.
[07:49.000 --> 07:50.000]  Вот.
[07:50.000 --> 07:56.000]  Поэтому здесь с точки зрения памяти все более-менее, ну, пропорционально число переходов.
[07:56.000 --> 07:57.000]  Вот.
[07:57.000 --> 07:59.000]  А что еще нужно делать?
[07:59.000 --> 08:06.000]  Значит, вот, видимо, нужен там проверка существования или создание нового перехода.
[08:06.000 --> 08:09.000]  То есть вот здесь, да, я сначала проверяю, есть ли такой переход.
[08:09.000 --> 08:11.000]  Если его нет, я его создаю.
[08:11.000 --> 08:15.000]  И в конце концов в любом случае перехожу по этому переходу.
[08:15.000 --> 08:20.000]  Значит, ну вот мне нужно, давайте я просто сделаю запрос.
[08:20.000 --> 08:24.000]  Потому что это все по факту, как бы, запрос к конкретной букве.
[08:24.000 --> 08:27.000]  Есть такая буква в нашем массиве или нет.
[08:27.000 --> 08:30.000]  В массиве работает все за единицу, понятное дело, да, просто вот.
[08:30.000 --> 08:34.000]  Все эти операции, это обращение к какому-то элементу массива работает за единицу.
[08:34.000 --> 08:37.000]  Дальше в мапе это все будет за лог к.
[08:37.000 --> 08:42.000]  И добавление, и проверка наличия, и получение значения.
[08:42.000 --> 08:44.000]  Это все работает за лог к.
[08:44.000 --> 08:48.000]  Ну а хаш таблица в среднем учетная единица, да, получается.
[08:48.000 --> 08:51.000]  Ну, давайте, я пишу, в среднем учетная единица.
[08:51.000 --> 08:53.000]  Да, один со звездочкой.
[08:53.000 --> 08:55.000]  Вот.
[08:55.000 --> 09:00.000]  Ну, поэтому как бы, и видимо хаш таблица прям идеальная всего работает.
[09:00.000 --> 09:03.000]  Потому что она жрет оптимальное количество памяти.
[09:03.000 --> 09:06.000]  Не требуется хранить весь алфавит.
[09:06.000 --> 09:09.000]  Ну и в среднем на запрос отвечает за единицу учетную.
[09:09.000 --> 09:11.000]  Это более-менее как бы оптимальное всего, что есть.
[09:11.000 --> 09:14.000]  Но с другой стороны, конечно, хаш таблицу писать сложнее, чем, скажем, использовать массив.
[09:14.000 --> 09:17.000]  Поэтому, наверное, разумно, если у вас алфавит маленький,
[09:17.000 --> 09:20.000]  наверное, проще всего с помощью массива это делать.
[09:20.000 --> 09:21.000]  Вот.
[09:21.000 --> 09:25.000]  Поэтому, ну, я бы сказал, что, в общем, что-то из этого надо обычно выбирать.
[09:25.000 --> 09:29.000]  Потому что если у вас обычно большой размер массива,
[09:29.000 --> 09:32.000]  то, ну, и вам надо использовать либо мап.
[09:32.000 --> 09:35.000]  Ну, конечно, на самом деле тоже бывает полезно.
[09:35.000 --> 09:38.000]  Да, что если со временем все достаточно хорошо
[09:38.000 --> 09:40.000]  и можно вместо единицы здесь использовать логарифм,
[09:40.000 --> 09:43.000]  то почему бы не использовать логарифм?
[09:43.000 --> 09:46.000]  Да, вопрос?
[09:46.000 --> 09:48.000]  Ну, хаш таблица это прям наша хаш таблица,
[09:48.000 --> 09:51.000]  которую мы в первом семестре обсуждали там.
[09:51.000 --> 09:53.000]  Ну, или, правильно, какой-то аннордеритмап, не знаю.
[09:53.000 --> 09:55.000]  Аннордеритмап вроде фигов работает просто.
[09:55.000 --> 09:58.000]  Ну, прям рукописная фишта таблицы, да.
[10:02.000 --> 10:05.000]  Вот.
[10:19.000 --> 10:25.000]  Ну, давайте несколько задач посмотрим про числа.
[10:25.000 --> 10:27.000]  Значит, первое.
[10:27.000 --> 10:32.000]  Давайте научимся реализовывать функционал дерево поиска,
[10:32.000 --> 10:36.000]  если все элементы это числа.
[10:36.000 --> 10:42.000]  То есть реализовать дерево поиска,
[10:42.000 --> 10:53.000]  если элементы это числа из отрезка от нуля до, скажем,
[10:53.000 --> 10:56.000]  2 в кадре минус 1.
[10:56.000 --> 10:59.000]  Ну, целая.
[10:59.000 --> 11:02.000]  То есть вставлять, удалить, проверять таблича.
[11:02.000 --> 11:06.000]  Если мы знаем, что все элементы это числа.
[11:06.000 --> 11:08.000]  Вот.
[11:08.000 --> 11:10.000]  Ну, можно, например, просто все числа представить
[11:10.000 --> 11:12.000]  и сбитыми строками скобить.
[11:12.000 --> 11:15.000]  Да, и сканули в единиц.
[11:15.000 --> 11:19.000]  И добавлять их в БОР, как вот такие бинарные строки.
[11:19.000 --> 11:22.000]  Тогда добавление, это просто вот такая процедура.
[11:22.000 --> 11:25.000]  На добавление строки в БОР.
[11:25.000 --> 11:30.000]  Удаление, ну, это там надо опять пройтись по вот этим вот K символам.
[11:30.000 --> 11:34.000]  И последнюю вершину сделать опять не терминальный.
[11:34.000 --> 11:37.000]  А проверка наличия это, ну, как бы пройти по БОРу,
[11:37.000 --> 11:39.000]  потому что мы дошли до какой-то вершины,
[11:39.000 --> 11:41.000]  и проверка наличия терминальности.
[11:41.000 --> 11:44.000]  Вот, то есть тут на самом деле решение очень простое.
[11:48.000 --> 11:51.000]  Сохраним числа.
[11:53.000 --> 11:56.000]  Как бинарные строки, длинные камеры.
[12:03.000 --> 12:06.000]  Складываем БОР.
[12:07.000 --> 12:10.000]  Согласны?
[12:10.000 --> 12:11.000]  Вот.
[12:11.000 --> 12:15.000]  Ну, единственное может быть тонкость, что как в идеале удалять.
[12:15.000 --> 12:19.000]  Да, потому что если мы, скажем, просто пройдем весь путь строки
[12:19.000 --> 12:21.000]  и просто снимем здесь сложок терминальности,
[12:21.000 --> 12:24.000]  то есть скажем, что там было true, а станет false.
[12:24.000 --> 12:25.000]  Вот.
[12:25.000 --> 12:27.000]  Тогда, если, например, нам сначала добавили кучу чисел,
[12:27.000 --> 12:29.000]  потом удалили кучу чисел,
[12:29.000 --> 12:32.000]  то у нас будет большой БОР, где ничего слежать, но нет.
[12:32.000 --> 12:35.000]  А вот, например, будет такой БОР большой,
[12:35.000 --> 12:37.000]  где все вершины не терминальны.
[12:37.000 --> 12:41.000]  Но можно тогда, на самом деле, когда вас просят удалить что-то,
[12:41.000 --> 12:44.000]  не просто помечать вот эту вот вершину не терминальной,
[12:44.000 --> 12:47.000]  но еще и пройти все вот эти вот вершины вплоть до первого ветвления
[12:47.000 --> 12:50.000]  и все вот эти вершины удалить.
[12:52.000 --> 12:55.000]  Ну, просто чтобы освободить память.
[12:57.000 --> 12:58.000]  Вот.
[12:58.000 --> 13:01.000]  И тогда суммарное место, которое занимает ваш БОР,
[13:01.000 --> 13:03.000]  будет пропорциональное к количеству чисел в нем,
[13:03.000 --> 13:04.000]  а не...
[13:04.000 --> 13:06.000]  Ну, то есть тут не будет каких-то вот таких вот пустых веток,
[13:06.000 --> 13:08.000]  которые ведут в никуда,
[13:08.000 --> 13:10.000]  да, и как раз тогда память будет пропорциональная тому,
[13:10.000 --> 13:13.000]  чему надо, к количеству элементов в сайте, в множестве.
[13:14.000 --> 13:15.000]  Вот.
[13:16.000 --> 13:17.000]  Второе.
[13:17.000 --> 13:19.000]  Ну, например, если то же самое,
[13:19.000 --> 13:22.000]  то мы, например, можем довольно эффективно числа сортировать.
[13:22.000 --> 13:23.000]  Отсортировать.
[13:24.000 --> 13:25.000]  Целые числа.
[13:28.000 --> 13:31.000]  Ну, опять-таки в диапазоне от нуля до два-встепенька.
[13:38.000 --> 13:39.000]  Вот.
[13:39.000 --> 13:42.000]  Опять давайте прочитаем все числа, сложим их в БОР,
[13:42.000 --> 13:44.000]  а дальше мы будем говорить о том,
[13:44.000 --> 13:46.000]  что мы будем говорить о том,
[13:46.000 --> 13:48.000]  что мы будем говорить о том,
[13:48.000 --> 13:50.000]  что мы будем говорить о том,
[13:50.000 --> 13:52.000]  если мы сложим их в БОР,
[13:52.000 --> 13:54.000]  а дальше будем, типа,
[13:54.000 --> 13:56.000]  жадным алгоритмом их все выводить.
[13:56.000 --> 13:58.000]  Потому что вот есть какой-то большой БОР
[13:58.000 --> 14:00.000]  большой бинарный БОР.
[14:02.000 --> 14:03.000]  Вот.
[14:03.000 --> 14:05.000]  Как найти самое маленькое число?
[14:05.000 --> 14:07.000]  Ну, понятно надо налево просто идти всегда,
[14:07.000 --> 14:09.000]  когда возможно.
[14:09.000 --> 14:11.000]  И если у вас есть развитвление в точке,
[14:11.000 --> 14:13.000]  то есть можно пойти и по нулю, и по единице,
[14:13.000 --> 14:15.000]  то понятно наименьше из них имеет ноль
[14:15.000 --> 14:17.000]  и оно где-то слева лежит, да,
[14:17.000 --> 14:18.000]  значит надо идти налево.
[14:18.000 --> 14:19.000]  Здесь вариантов нет.
[14:19.000 --> 14:21.340]  минимальный из них лежит понятное дело слева.
[14:21.340 --> 14:24.340]  Но вот дошли до сюда, вы знаете какое самое маленькое число.
[14:24.340 --> 14:28.340]  Потом, ну как бы, ваши рекурсы возвращаются до первой точки ветвления.
[14:28.340 --> 14:33.340]  Второе число, соответственно, лежит вот здесь, ну и здесь опять идете по самой левой ветке.
[14:33.340 --> 14:40.340]  Вот, тем самым простой по факту DFS вам сразу выводит все листья в порядке
[14:40.340 --> 14:43.340]  вот, в порядке следования слева направо, значит в порядке возрастания.
[14:43.340 --> 14:47.340]  Просто давайте напишу, что это просто DFS.
[14:47.680 --> 14:52.680]  Он сразу все числа отсортировает. Согласны?
[14:55.680 --> 14:57.680]  Хорошо.
[15:01.680 --> 15:04.680]  Вот, ну это там вкопилку алгоритмов сортировки.
[15:04.680 --> 15:08.680]  Он, конечно, далеко не самый полезный, но тоже нормально.
[15:08.680 --> 15:11.680]  Например, с помощью этого же можно строки сортировать, да?
[15:11.680 --> 15:13.680]  Представьте, что у вас не числа, а строки даны,
[15:13.680 --> 15:15.680]  и вам надо кучу строк отсортировать.
[15:15.680 --> 15:20.680]  Вы их также сложите в БОР, потом пройдете DFS в лексикографическом порядке,
[15:20.680 --> 15:22.680]  то есть предпочитая маленькие буквы большим.
[15:22.680 --> 15:24.680]  И точно так же, каждый раз, когда дошли до листа,
[15:24.680 --> 15:28.680]  то вы, получается, вывели, ну не до листа, а до терминальной вершины.
[15:28.680 --> 15:32.680]  Вы выводите очередное слово в порядке возрастания.
[15:37.680 --> 15:41.680]  Вот, такая структура данных нехитрая.
[15:42.680 --> 15:45.680]  Так, есть вопросы?
[15:48.680 --> 15:51.680]  Ну, это получается за nk.
[15:53.680 --> 15:59.680]  Вроде бы, потому что добавление такой строки в БОР работает за от ее длины, то есть за от k.
[16:01.680 --> 16:06.680]  Ну и потом, чтобы все это вывести, нам надо запустить DFS.
[16:06.680 --> 16:10.680]  Он работает за линейное время размерографа, то есть опять-таки за nk.
[16:10.680 --> 16:14.680]  Ну то есть, если k маленько, то это хороший алгоритм какой-то.
[16:14.680 --> 16:21.680]  Но если k большой, то это будет n на 30, что не особенно лучше обычных сортировок за n log n.
[16:25.680 --> 16:30.680]  Все, ну и теперь с помощью такой штуки, с помощью БОРа мы можем переходить к алгоритму Ахкарасик,
[16:35.680 --> 16:38.680]  который позволяет решать две следующие задачи.
[16:38.680 --> 16:40.680]  Значит, задача.
[16:41.680 --> 16:43.680]  Есть набор словарных слов.
[16:46.680 --> 16:48.680]  S1, S2 и так далее, SN.
[16:49.680 --> 16:51.680]  И есть некий текст T.
[16:54.680 --> 16:58.680]  Ну и надо найти суммарное количество вхождений всех словарных слов в текст.
[16:58.680 --> 17:03.680]  Суммарное количество вхождений всех словарных слов в текст.
[17:12.680 --> 17:13.680]  Вот.
[17:13.680 --> 17:18.680]  Это почти задача о нахождении всех словарных слов в текст.
[17:18.680 --> 17:22.680]  Только теперь у вас много строк, вам нужно, ну вот, суммарно по всем строчкам вывести все их вхождения в T.
[17:23.680 --> 17:30.680]  А, если раньше на прошлом деле мы это решали там, например, через префикс или через Z функцию, склеивая две строчки,
[17:30.680 --> 17:34.680]  то здесь это будет уже не очень эффективно, потому что если вы для каждой строки отдельно
[17:34.680 --> 17:40.680]  построите такую строчку, для нее бахнете префикс функции, то вы не можете на этой строчке bloat.
[17:40.680 --> 17:43.160]  То есть здесь это будет уже не очень эффективно,
[17:43.160 --> 17:44.940]  потому что если вы для каждой строки отдельно.
[17:44.940 --> 17:46.400] ely
[17:46.400 --> 17:48.800]  Построите такую строчку, для нее бахнете префикс функцию
[17:48.800 --> 17:49.660]  или z функцию,
[17:49.660 --> 17:50.800]  То...
[17:50.800 --> 17:51.840]  Ну это долго будет, короче
[17:51.840 --> 17:53.800]  То есть представьте, что у вас много таких строк
[17:53.800 --> 17:55.580]  Много маленьких строк, вот таких вот
[17:55.580 --> 17:56.960]  И один большой текст t
[17:56.960 --> 17:59.160]  И если вы каждый раз, для каждой маленькой s и t
[17:59.160 --> 18:00.380]  Будете вот так вот их склеивать
[18:00.380 --> 18:01.940]  То, ну будет долго, понятно
[18:01.940 --> 18:03.760]  Потому что если у вас много маленьких строк
[18:03.760 --> 18:04.260]  То...
[18:04.260 --> 18:05.780]  И все это работает за линию от t
[18:05.780 --> 18:07.540]  то это будет, короче
[18:07.640 --> 18:08.620]  Неприятно
[18:08.620 --> 18:09.840]  Вот
[18:09.840 --> 18:16.640]  получше сделаем. Ну и вторая задача здесь же рядышком, почти такая же, нужно найти не суммарное
[18:16.640 --> 18:28.120]  количество вхождений, а прям вывести все вхождения. Напишу найти все вхождения. То есть прям вывести,
[18:28.120 --> 18:34.120]  что S1 встречается здесь, здесь, здесь и здесь, S2 здесь, здесь, здесь и здесь и так далее. То есть
[18:34.120 --> 18:41.400]  прям список всех вхождений с описанием того, какое словарное слово входит и где входит,
[18:41.400 --> 18:46.600]  то есть прям полная информация о том, где все они, где все они встречаются. Полная информация в
[18:46.600 --> 19:08.160]  вхождениях. Вот. Ну начало здесь весьма прозаичное, давайте построим бор на наших словарных словах.
[19:16.600 --> 19:32.440]  Дальше договоренность. Я буду говорить, что слово есть в боре, если его можно прочитать,
[19:32.440 --> 19:41.960]  начиная с корня. Давайте пример какой-нибудь я нарисую, тупой. Вот если у меня, например,
[19:42.120 --> 19:48.720]  есть такая ветка, начинающаяся с корня, то я говорю, что epsilon есть в боре, a есть в боре,
[19:48.720 --> 19:54.920]  ab, abc, abca все есть в боре. Даже если они не терминальные. То есть есть в боре, значит просто
[19:54.920 --> 20:01.160]  читается из корня. Есть такой путь начинающий с корня по такой последности букв. Давайте я
[20:01.160 --> 20:22.520]  прям в калычке это возьму. Слово есть в боре, если его можно прочитать из корня. Я мог бы говорить,
[20:22.520 --> 20:27.040]  слово можно прочитать из корня, но это более громовская конструкция, чем просто что он есть.
[20:27.040 --> 20:33.920]  Вот я буду так сокращать, буду говорить, что есть, если его можно прочитать. Так, хорошо,
[20:33.920 --> 20:42.640]  ну вот теперь давайте какой-нибудь пример построим. Пример бора на наборе словарных слов.
[20:42.640 --> 20:58.600]  Так, или не буду я его делать. Нет, ну видимо надо. Вот так не хочется, конечно.
[21:12.640 --> 21:30.040]  Ну вот так давайте сделаем. Вот пусть у меня есть четыре таких словарных слова. Давайте
[21:30.040 --> 21:44.200]  построим на них сначала бор. Как он выглядит? Есть сначала длинное abcaba. Так, дальше abada. Смотрите,
[21:44.200 --> 21:58.440]  начало есть уже, aba уже есть. Надо только здесь разветвиться и дописать в конце da, cabc и bada. Еще
[21:58.440 --> 22:08.440]  одна отдельная такая вот веточка будет. Построили бор по исходному набору слов. Дальше опять
[22:08.440 --> 22:16.640]  договоренность. Я буду всюду теперь дальше отождествлять вершину и ту строчку, которая ведет в нее
[22:16.640 --> 22:22.920]  из корня. Например, вот если вот это у меня v, то я буду говорить, что v это то же самое, что aba.
[22:22.920 --> 22:28.160]  У меня вершина бора однозначно соответствует некоторой строке, которая получается, ну,
[22:28.160 --> 22:33.480]  чтением от корня до нее. Я буду дальше всюду перемешивать понятия вершина и строка. Ну,
[22:33.480 --> 22:37.640]  потому что как бы по строке однозначно определяется вершина и наоборот. Если есть какая-то вершина,
[22:37.640 --> 22:42.520]  можно от корня дойти до нее и записать то, что здесь написано, они будут друг другу соответствовать.
[22:42.520 --> 22:47.960]  А поэтому v всюду дальше у меня будет взаимозаменяться со строкой aba.
[22:47.960 --> 23:12.360]  Так, все, ну и теперь я могу ввести наконец определение. Link для v это максимальный
[23:12.360 --> 23:34.080]  собственный суффикс. Строки v, которые есть в боре. То есть вот есть какая-то строка v,
[23:34.080 --> 23:38.240]  напоминаю v это вообще говоря вершина, но понятно она однозначно соответствует какой-то строке.
[23:38.240 --> 23:45.200]  Вот есть строка v. Я хочу найти самый длинный ее суффикс, отличный от нее самой, собственно,
[23:45.200 --> 23:50.680]  значит отличный от всей строки, самый длинный суффикс, который можно было бы прочитать из корня.
[23:50.680 --> 23:57.440]  То есть вот скажем вот это вот, если эту строчку можно прочитать из корня, то я говорю, что это link
[23:57.440 --> 24:03.480]  ее. Например, вот здесь вот давайте на строке aba-tsaba, давайте вот на эту вершину посмотрим,
[24:03.480 --> 24:08.400]  какой у нее самый длинный суффикс, который можно прочитать в боре. Вот смотрим на aba-tsaba.
[24:08.400 --> 24:12.520]  Вся aba-tsaba своей линкой не является, потому что мне нужен собственный суффикс,
[24:12.520 --> 24:17.480]  значит хотя бы первый символ мне нужно отбросить. Ba-tsaba такой строки прочитать нельзя,
[24:17.480 --> 24:23.400]  да, разве что вот bada здесь есть, поэтому b тоже придется отбросить. A-tsaba кажется тоже нет,
[24:23.400 --> 24:34.000]  tsaba нету, есть только aba, нет и сейчас вот она aba есть, поэтому суффсылка отсюда будет вести вот
[24:34.000 --> 24:45.040]  сюда, link будет вести вот сюда. Согласны? Потому что я рассматриваю вот для этой вершины, я рассматриваю
[24:45.040 --> 24:50.680]  какая строка ей соответствует, это строка aba-tsaba, я перебираю все ее суффиксы в порядке убывания длины
[24:50.680 --> 24:56.040]  и оставляю максимальный, который можно было прочитать из корня. Ну вот здесь aba является ее
[24:56.040 --> 25:03.040]  суффиксом и также можно ее прочитать из корня, вот она aba, поэтому стрелка ведет вот так. Дальше,
[25:03.040 --> 25:09.360]  например, для строки abada, для вот этой вот строки, для этой вершины мы можем, мы видим, да, что это
[25:09.360 --> 25:15.360]  строка abada, вот она, и можно, например, оставить вот такой ее суффикс, потому что есть такая строка,
[25:16.240 --> 25:25.420]  значит суффсылка отсюда будет вести вот сюда. Ну просто оставляю максимальный суффикс,
[25:25.420 --> 25:29.360]  который можно прочитать из корня, и так делаю для всех вершин, например, для вот этой вот sa,
[25:29.360 --> 25:34.320]  для строки ca у меня суффсылка будет вести в a, потому что вот это максимальный суффикс,
[25:34.320 --> 25:40.640]  который можно прочитать, для строки ca-b можно оставить суффикс ab, ну и так далее, короче,
[25:40.640 --> 25:47.840]  для каждой вершины я определяю линк вот просто по такому правилу вот это первое
[25:47.840 --> 25:55.700]  второе что мне будет нужно это go для каждой вершины и для каждого символа
[25:55.700 --> 26:03.860]  алфавита на ц это какой-то элемент сигмы ц это элемент сигмы это максимальный
[26:03.860 --> 26:13.140]  суффикс строки в плюс ц который опять таки есть в боря
[26:13.140 --> 26:28.140]  вот то есть что будет если я возьму строчку в припишу с них к ней вправо в конец буковку
[26:28.140 --> 26:33.980]  ц какой теперь у этой строки максимальный суффикс который есть в боря причем уже не
[26:33.980 --> 26:37.820]  обязательно собственно здесь слово собственно я не пишу возможно он совпадает со всей строкой
[26:37.820 --> 26:43.940]  в плюс ц да но в общем случае это что-то вот такое какой самый длинный суффикс такой строки можно
[26:43.940 --> 26:51.700]  прочитать из корня так ну давайте тоже какой-нибудь пример я нарисую если здесь
[26:51.700 --> 27:09.600]  что-то содержательное ну например вот отсюда смотрите а нет тут такое уже тоже есть а да вот
[27:09.600 --> 27:16.040]  например смотрите отсюда если я буду из этой вершины пытаться приписывать букву ц то я попаду
[27:16.040 --> 27:24.000]  видимо вот сюда вот потому что смотрите вот у меня есть такое длинное слово аба цаб и я пытаюсь
[27:24.000 --> 27:28.760]  дописать в конец букву ц ну понятно просто дописать вниз ц нельзя потому что нет такого
[27:28.760 --> 27:34.240]  перехода но я могу дописать эту букву отбросить первые три буквы и у меня получится ц и аб и ц
[27:34.240 --> 27:42.120]  и я попаду вот сюда поэтому у меня будет вот такая вот стрелка гоу по букве ц логично
[27:42.120 --> 27:52.960]  вот но вроде более длинных суфиков суффиксов таких нету ба ца нету а ца нету значит да действительно
[27:52.960 --> 27:57.760]  вот это самый длинный суффикс который получается после дописывания буквы ц вот ну и опять-таки
[27:57.760 --> 28:03.520]  я хочу эту же штуку насчитать для всех вершин и для всех символов для каждой вы для каждого ц
[28:03.520 --> 28:08.320]  знать куда я куда я перейду какой останется самый длинный суффикс если я дописываю одну
[28:08.320 --> 28:17.840]  буковку вот такие такие вещи соответственно алгоритмах карасик он насчитывает и линки и
[28:17.840 --> 28:29.600]  вот эти гоу все что делать алгоритм это их просто вычисляет давайте давайте поймем как он это делает
[28:47.840 --> 28:59.440]  он находит линк от в для всех в и гоу в ц для всех в и для всех символов алфейта ц
[28:59.440 --> 29:16.520]  так значит как он это будет делать вот у меня есть построенный бор я буду по нему идти чем-то
[29:16.520 --> 29:22.160]  в стиле бфс а я буду обрабатывать вершины порядка увеличения глубины сначала обработаю
[29:22.160 --> 29:26.800]  корень потом обработаю все вершины на глубине 1 все вершины глубине 2 3 и так далее то есть по
[29:26.800 --> 29:32.960]  факту просто запущу бфс в этом графе тем самым буду перебирать вершины порядка увеличения
[29:32.960 --> 29:41.920]  расстояния от корня теперь пусть для вершины в я уже посчитал все что нужно я посчитал для
[29:41.920 --> 29:48.400]  нее но точнее не так я посчитал линк и гоу для всех вершин на глубины не больше чем глубина в
[29:48.400 --> 29:57.240]  в частности для в вот пусть здесь у меня все пощита дальше из в выходят какие-то ребра я хочу
[29:57.240 --> 30:04.200]  понять ну например я хочу понять какие у этих вершин будут линки потому что это какие-то
[30:04.200 --> 30:11.040]  вершины бора в них еще не посчитано ответ я хочу понять какие линк будут для этих вершин но давайте
[30:11.040 --> 30:16.400]  скажем что здесь будет какая-нибудь буква ц давайте конкретный переход один рассмотрим у меня
[30:16.400 --> 30:22.240]  вот есть конкретный переход по букве ц он ведет меня вершину у я хочу понять чему равно линк от у
[30:22.240 --> 30:34.000]  значит смотрите у меня была строка в я к ней приписал один символ ц у меня получилась строка
[30:34.000 --> 30:46.080]  у хочу понять чему равно линк от у вот значит мне нужно оставить максимальный
[30:46.080 --> 30:52.240]  собственно суфик здесь на который можно было бы прочитать искорно я утверждаю что линк считается
[30:52.240 --> 31:04.400]  следующим образом значит это либо 0 если вы равно 0 напоминаю 0 это у меня всегда номер корня
[31:04.400 --> 31:18.080]  вот а иначе это go от от линк от в по ц
[31:18.080 --> 31:28.880]  вот значит почему это верно но в случае если вы равно 0 то линк равно 0 очевиден потому что
[31:28.880 --> 31:35.840]  если вы это корень то у это просто один символ и что такое линк от строки из одного символа это
[31:35.840 --> 31:40.200]  максимальный собственно суфик с которым можно прочитать из корня но извините если у состоит из
[31:40.200 --> 31:45.360]  одного символа то единственный ее суфик собственно этот пустая строка которая соответствует
[31:45.360 --> 31:51.960]  сочности корня поэтому этот случай тривиально вот теперь откуда берется вот это вот безобразие
[32:03.960 --> 32:11.080]  так давайте соображать то есть во первых что такое линк от в линк от в уже оставляет от
[32:11.200 --> 32:15.240]  какой-то максимальный собственно суффикс на какой-то суффикс то есть вот было большой
[32:15.240 --> 32:23.200]  в я от нее оставил некий суффикс линк prettier дальше я приписываю вот к этой стрurança уже
[32:23.200 --> 32:30.000]  буковку ц и оставляя от вновь получ影 falsely robbery самый длинные суффикс да потому что
[32:30.000 --> 32:35.380]  такое go этоожалуйста самое длинное суффикс а после приписыванияProfessor и вот як вот ты
[32:35.380 --> 32:40.480]  ст face Dassault Liu и оставляю самый длинный суффикс который есть в боре то естьzw Moroccan
[32:40.480 --> 32:45.040]  Ну и я утверждаю, что это в точности то, что нам нужно,
[32:45.040 --> 32:47.560]  потому что я сначала дописываю букву C, а потом оставляю
[32:47.560 --> 32:49.480]  самый длинный собственный суффикс, но я вот сначала
[32:49.480 --> 32:52.000]  оставил в принципе самый длинный собственный суффикс,
[32:52.000 --> 32:54.400]  который был вот здесь, а потом вспомню, что еще
[32:54.400 --> 32:57.160]  C нужно добавить, значит мне нужно отсюда еще по
[32:57.160 --> 33:00.960]  переходу GO сделать, пройтись по переходу GO, чтобы оставить
[33:00.960 --> 33:03.640]  самый длинный вот в точности у такой строки собственный
[33:03.640 --> 33:04.640]  суффикс.
[33:04.640 --> 33:08.040]  Смотрите, давайте вот это утверждение докажем,
[33:08.480 --> 33:10.640]  с первым случаем понятное дело мы это разобрали.
[33:10.640 --> 33:14.320]  Во первых давайте сначала с корректности это все разберемся.
[33:14.320 --> 33:17.180]  Почему в обще я выделяю отдельно, выношу этот случай,
[33:17.180 --> 33:18.180]  если вы равно нулю.
[33:18.180 --> 33:21.840]  Потому что если вы равно нулю, то я не имею права запрашивать
[33:21.840 --> 33:22.840]  линк от нуля.
[33:22.840 --> 33:26.320]  Потому что нуль это пустая строка, линк от нуля формально
[33:26.320 --> 33:29.080]  это максимальный собственный суффикс пустой строки, такой
[33:29.080 --> 33:30.120]  что бла бла бла.
[33:30.120 --> 33:32.500]  Но у пустой строки собственных соб 셋ов не существует.
[33:32.500 --> 33:35.520]  Поэтому линк для корни не определен вообще говоря,
[33:35.520 --> 33:39.360]  право его запрашивать. То есть я мог бы его, наверное, как-нибудь правильно определить,
[33:39.360 --> 33:41.420]  чтобы это правильно работало, но я не буду этого делать.
[33:41.420 --> 33:47.040]  линк от нуля я не буду трогать, потому что не определен формально. Вот. Но линк от v
[33:47.040 --> 33:54.200]  это всегда вершина, глубины меньше, чем v. Потому что глубина соответствует длине,
[33:54.200 --> 33:59.880]  просто строки, да, глубина, это просто длина строки. Линк от v это какой-то
[33:59.880 --> 34:04.840]  собственный суффикс, то есть ее длина еще меньше. Значит, для нее, ну то есть линк от v
[34:04.840 --> 34:09.760]  где-то определено, вот она где-то здесь лежит, а линк от v. И поскольку ее глубина
[34:09.760 --> 34:14.120]  меньше, чем глубина v, ну даже достаточно меньше либо равна, то для нее тоже уже
[34:14.120 --> 34:18.040]  определено go, потому что для всех вершин на глубине не больше, чем v, мы
[34:18.040 --> 34:21.880]  знаем вот эти go, да, по предположению, что у меня здесь все посчитано, поэтому
[34:21.880 --> 34:26.880]  линк от v посчитано и go для нее тоже посчитано. Поэтому эти все значения у меня
[34:26.880 --> 34:30.640]  уже посчитаны в боре, уже есть.
[34:34.840 --> 34:43.120]  Вот, а теперь содержательно, почему вот так картиночка работает. Смотрите, то есть я
[34:43.120 --> 34:47.760]  утверждаю, что если взять сначала линку от v, потом к ней переписать c и перейти по
[34:47.760 --> 34:53.640]  go, то получится в точности самый длинный собственный суффикс u. Почему так? Ну, во-первых,
[34:53.640 --> 34:57.560]  понятно, что мы получаем какой-то суффикс u, причем точно собственный, да, потому что
[34:57.560 --> 35:02.320]  если мы в самом начале взяли собственный, собственный суффикс v, то по крайней мере
[35:02.320 --> 35:05.960]  один символ из начала я отбросил, значит точно у меня уже собственный суффикс u
[35:05.960 --> 35:11.040]  получается. То есть это получается какой-то собственный суффикс, какой-то
[35:11.040 --> 35:21.080]  собственный суффикс u. Вот, пусть он внезапно не максимальный, то есть пусть есть
[35:21.080 --> 35:26.160]  настоящий максимальный собственный суффикс, который получился длиннее, а вот такой.
[35:26.640 --> 35:33.040]  Тогда, извините, тогда понятное дело, что вот это вот, да, все кроме последнего символа C, это
[35:33.040 --> 35:37.840]  собственный суффикс v. Ну потому что, собственно, следует как минимум один символ
[35:37.840 --> 35:42.880]  из начала я удалил, поэтому это точно собственный суффикс v. Значит линк имеет
[35:42.880 --> 35:46.980]  или такое же длину линка из v, либо такую же длину, либо даже еще больше. То есть линк
[35:46.980 --> 35:49.960]  какой-то вот такой и линк от v какой-то такой, потому что
[35:49.960 --> 35:54.560]  вот это какой-то собственный суффикс v, а линк от v это максимальный собственный
[35:54.560 --> 35:56.800]  суффикс, поэтому он имеет длину больше равной, чем
[35:56.800 --> 35:57.800]  такую.
[35:57.800 --> 35:59.800]  То есть он либо такой, либо такой какой-то, да?
[35:59.800 --> 36:00.800]  Вот.
[36:00.800 --> 36:03.080]  Ну и дальше получается, что я вот к строке такого
[36:03.080 --> 36:06.640]  вида приписываю C и оставляю максимальный собственный
[36:06.640 --> 36:07.640]  суффикс.
[36:07.640 --> 36:09.400]  Но понятное дело, что какую бы я такую строчку не взял
[36:09.400 --> 36:12.560]  и дописал бы к ней C, вот это вот, раз это есть в Боре,
[36:12.560 --> 36:14.960]  да, то есть я предлагаю, что это настоящий ответ,
[36:14.960 --> 36:18.840]  то есть это есть в Боре, то, ну уж точно, вот это вот
[36:18.840 --> 36:21.200]  строчку хотя бы вот такой длины я увижу в качестве
[36:21.200 --> 36:24.200]  го вот здесь.
[36:24.200 --> 36:26.120]  Ну и все, значит, мы доказали в обе стороны, что, ну то
[36:26.120 --> 36:29.120]  есть, что настоящий собственный суффикс имеет длину хотя
[36:29.120 --> 36:32.680]  бы то, что выдает эта формула, и наоборот настоящий
[36:32.680 --> 36:34.520]  собственный суффикс имеет длину, ну вот не больше
[36:34.520 --> 36:37.440]  чем то, что мы выдали, потому что вот из этой конструкции,
[36:37.440 --> 36:40.400]  когда я беру линк, после нее дописываю C и беру
[36:40.400 --> 36:42.640]  го, то у меня получится хотя бы вот это вот, значит
[36:42.640 --> 36:43.640]  они в точности равны.
[36:43.640 --> 36:48.440]  Все, поэтому мы получили формулу пересчета линк
[36:48.440 --> 36:51.200]  для всех вот дочерних вершин, вершины В.
[36:51.200 --> 36:57.320]  И это более-менее все, то есть самое содержательное
[36:57.320 --> 36:59.320]  здесь вот эта вот формула, дальше все пойдет как по
[36:59.320 --> 37:00.320]  маслу.
[37:00.320 --> 37:15.840]  Итак, значит, как будет работать наш собственный алгоритм?
[37:15.840 --> 37:18.200]  Давайте напишем какой-то кусок кода.
[37:18.200 --> 37:20.920]  Сначала давайте, вот я тут говорю, да, вот у меня
[37:20.920 --> 37:24.360]  здесь в начале, ответы, то есть все линки и все го посчитаны
[37:24.360 --> 37:27.760]  для какого-то начала нашего бора, то есть для всех вершин
[37:27.760 --> 37:29.240]  на какой-то глубине не больше чем к.
[37:29.240 --> 37:31.200]  Давайте я сначала с корнем разберусь.
[37:31.200 --> 37:32.200]  Да.
[37:32.200 --> 37:37.200]  Может быть, что посчитаны для некоторых вершин на глубине
[37:37.200 --> 37:40.200]  к, а для некоторых не очень?
[37:40.200 --> 37:43.800]  Не-не, вот у меня именно будет, что если я обрабатываю
[37:43.800 --> 37:47.040]  вершину В, то есть нахожу ответы для ее детей, то
[37:47.040 --> 37:49.800]  для всех вершин на глубине меньше либо равно, чем глубина
[37:49.800 --> 37:51.480]  В, у меня все обработано.
[37:51.480 --> 37:54.120]  На самом деле так же БФС работает, то есть как работает
[37:54.120 --> 37:55.120]  БФС?
[37:55.120 --> 37:57.400]  Что если мы из очереди достаем вершину на расстоянии
[37:57.400 --> 38:02.360]  D, то все вершины на расстоянии D в нее уже положены и остаются
[38:02.360 --> 38:05.320]  только вершины на расстоянии D плюс 1.
[38:05.320 --> 38:07.920]  Поэтому здесь даже не строго неравенство.
[38:07.920 --> 38:11.040]  Итак, значит, разбираемся с корнем.
[38:11.040 --> 38:16.160]  Что такое линк от корня?
[38:16.160 --> 38:19.520]  Ну, как я уже сказал, оно формально не определено.
[38:19.520 --> 38:21.600]  Это максимальный субфикс пустой строки, который
[38:21.600 --> 38:22.600]  бла-бла-бла.
[38:22.600 --> 38:23.600]  Такого нету.
[38:23.600 --> 38:25.680]  Ну, давайте поставим там минус 1, потому что оно не
[38:25.680 --> 38:26.680]  определено.
[38:26.680 --> 38:27.680]  Нет такой вершины.
[38:27.680 --> 38:28.680]  Дальше.
[38:28.680 --> 38:30.240]  Что делать с гоу?
[38:30.240 --> 38:32.120]  Ну, давайте перебирать все символы из алфавита.
[38:32.120 --> 38:39.280]  Что такое гоу ноль С?
[38:39.280 --> 38:40.280]  Тут есть два варианта.
[38:40.280 --> 38:44.880]  Если из нуля есть переход по букве С, то есть если
[38:44.880 --> 38:49.320]  2 неравно минус 1, то его нужно просто скопировать
[38:49.320 --> 38:52.320]  в гоу.
[38:52.320 --> 38:53.320]  Потому что что такое гоу?
[38:53.320 --> 38:56.160]  Это максимальный субфикс, который появляется после
[38:56.160 --> 38:57.920]  дописывания буквы С.
[38:57.920 --> 39:01.160]  Но если все это слово, если всю эту букву можно представить
[39:01.160 --> 39:03.120]  из корня, то она же будет гоу.
[39:03.120 --> 39:04.320]  Ну и так будет всегда.
[39:04.320 --> 39:10.920]  Если из вершины торчит какая-то буква, то гоу в С будет
[39:10.920 --> 39:14.000]  просто совпадать с 2, ну там, как я это обозначал,
[39:14.000 --> 39:15.000]  то это будет 2ВСТ.
[39:15.000 --> 39:20.000]  Давайте это переобозначу, будет просто 2ВСТ.
[39:20.000 --> 39:25.000]  То есть если переход вниз есть, то гоу это то же самое,
[39:25.000 --> 39:26.000]  что 2.
[39:26.000 --> 39:27.280]  Гоу содержателен только в случае, если перехода
[39:27.280 --> 39:28.280]  нету.
[39:28.280 --> 39:29.640]  Если перехода вниз, по такой букве нету.
[39:29.640 --> 39:32.000]  Иначе он просто совпадает с этим 2.
[39:32.000 --> 39:40.400]  Итак, значит, если 2 нулевое СТ неравно минус 1, тогда
[39:40.400 --> 39:48.320]  гоу нулевое СТ это просто то же самое 2.
[39:48.320 --> 39:55.000]  А иначе, в случае, если нет такого перехода, то у
[39:55.000 --> 39:56.000]  меня что было?
[39:56.000 --> 39:58.400]  У меня, получается, была пустая строка, я к ней дописываю
[39:58.400 --> 40:01.600]  букву С, которую нельзя из нее прочитать, и мне нужно
[40:01.600 --> 40:03.480]  оставить максимальный субфикс, который есть в
[40:03.480 --> 40:04.480]  боре.
[40:04.480 --> 40:08.280]  Что это тогда такое?
[40:08.280 --> 40:09.280]  Скажите, пожалуйста.
[40:09.280 --> 40:18.560]  Стоит слово корень, все правильно.
[40:18.560 --> 40:20.280]  Потому что у меня была пустая строка, я к ней приписал
[40:20.280 --> 40:23.320]  С, то есть просто С, причем саму С из корни прочитать
[40:23.320 --> 40:25.360]  нельзя, значит, всю строчку оставить нельзя, не надо
[40:25.360 --> 40:26.360]  хотя бы что-то удалить.
[40:26.360 --> 40:29.040]  Вот я ее удаляю, остается пустая строка, пустую строчку
[40:29.040 --> 40:30.680]  уже можно из корни прочитать, останется корень.
[40:30.680 --> 40:33.600]  Все, корень обработали.
[40:33.600 --> 40:43.080]  Дальше, дальше заводим очередь вершин, так же, как в BFS-е,
[40:43.080 --> 40:46.240]  куда будем сваливать уже обработанные вершины, для
[40:46.240 --> 40:48.560]  которых найдены и линк, и го, как видим, для корня
[40:48.560 --> 40:51.920]  уже найдена и линк, и го, поэтому в Ку я могу смело запушить
[40:51.920 --> 40:52.920]  ноль.
[40:52.920 --> 40:53.920]  Ку пуш ноль.
[40:54.920 --> 41:06.560]  Далее, пока очередь не пустая, я достаю из нее вершину
[41:06.560 --> 41:19.200]  В, и сейчас буду, вот, сейчас прихожу ровно к этой картинке.
[41:19.200 --> 41:21.440]  Для всех вершин на глубины не больше, чем В, у меня все
[41:21.600 --> 41:24.760]  посчитано, я хочу посчитать ответ для всех детей В и
[41:24.760 --> 41:25.760]  добавить их в очередь.
[41:25.760 --> 41:32.280]  Так, ну давайте, видимо, вот это сотру.
[41:32.280 --> 41:41.960]  Что такое дети В?
[41:41.960 --> 41:45.120]  Мне нужно пройтись по всем буквам алфавита, если
[41:45.120 --> 41:47.000]  у меня есть переход по этой букве, причем переход
[41:47.000 --> 41:50.960]  в терминах ту, да, то есть если есть вот такая стрелка,
[41:50.960 --> 41:52.800]  то мне нужно для вершины У что-то посчитать.
[41:52.800 --> 42:02.720]  Я перебираю все символы алфавита, пусть У это то,
[42:02.720 --> 42:07.640]  куда я попадаю при переходе по этой букве, если никуда
[42:07.640 --> 42:09.520]  не попадаю, то есть если такого перехода нет, то
[42:09.520 --> 42:12.760]  я это игнорирую, делаю continue просто, ну потому что такого
[42:12.760 --> 42:15.320]  ребра нет, нет такой вершины, я ее пропускаю.
[42:15.320 --> 42:20.640]  Иначе, это именно вот такая картинка, да, и мне нужно
[42:20.640 --> 42:24.840]  для У посчитать линк и го, линк у меня уже написано,
[42:24.840 --> 42:31.160]  для линк все написано, поэтому если В равно нулю, а давайте
[42:31.160 --> 42:33.800]  даже так напишу, давайте тернарный оператор бахну,
[42:33.800 --> 42:34.800]  я же программист, правильно.
[42:34.800 --> 42:49.080]  Все вообще офигенно, да, не-не-не, у меня все супер
[42:49.080 --> 42:58.520]  проще, я-то могу себе позволить, да, правда написал же, ну
[42:58.520 --> 43:04.480]  просто то написал, видите, тернарный оператор, вот,
[43:04.480 --> 43:11.440]  что, я научился, да, вот, все с линкой все хорошо, теперь
[43:11.440 --> 43:16.320]  с го, с го чуть похитрее, потому что для вершины У
[43:16.320 --> 43:19.320]  мне нужно теперь еще перебрать все буковки, да, потому что
[43:19.320 --> 43:22.240]  мне нужно для У и для всех символов алфавита насчитать
[43:22.240 --> 43:24.560]  го для нее, то есть мне нужно как бы по факту еще сейчас
[43:24.560 --> 43:29.480]  сделать вложенный цикл, перебирающий все, ну все символы алфавита,
[43:29.480 --> 43:31.480]  пусть это будет Д.
[43:31.480 --> 43:42.560]  Ну а сейчас я буду считать го у Д.
[43:42.560 --> 43:47.480]  Опять два случая, если такой переход есть даже в ту,
[43:47.480 --> 43:49.760]  то есть как вот здесь, просто если из У есть стрелка по
[43:49.760 --> 43:57.560]  букве Д, если из У есть стрелка по букве Д, тогда го совпадает
[43:57.560 --> 44:06.840]  с этой стрелкой, го у ДТ равно ту у ДТ, потому что если
[44:06.840 --> 44:10.120]  из вершины У есть стрелка по букве Д, то собственно
[44:10.120 --> 44:13.200]  она же и есть максимальный суффикс вот этой строки
[44:13.200 --> 44:16.160]  у плюс Д, которая читается из корни, надо просто дойти
[44:16.160 --> 44:18.720]  до у, потом дочитать в, это будет та самая полная
[44:18.720 --> 44:22.360]  строка, поэтому го просто совпадает с ту.
[44:22.360 --> 44:27.560]  А иначе, картинка такая, давайте сюда вернусь, вот
[44:27.560 --> 44:33.080]  есть у, а вот есть у, и дальше я хочу дописать букву Д,
[44:33.080 --> 44:36.120]  которой отсюда нету, то есть здесь нет стрелки по
[44:36.120 --> 44:38.680]  букве Д, но я хочу тем не менее понять, чему равно
[44:38.680 --> 44:39.680]  го у Д.
[44:39.680 --> 44:44.480]  То есть у меня была строка у, я хочу к ней дописать
[44:44.480 --> 44:46.960]  букву Д и понять, какой максимальный суффикс такой
[44:46.960 --> 44:49.960]  строки есть в боре, при этом этот суффикс точно будет
[44:49.960 --> 44:53.000]  собственный, потому что вся строка точно в боре
[44:53.000 --> 44:55.880]  не лежит, у плюс Д в боре не лежит, потому что нет
[44:55.880 --> 44:59.520]  стрелки, я сейчас нахожусь в случае else, значит я могу
[44:59.520 --> 45:02.360]  брать не просто суффикс, а собственный суффикс, а
[45:02.360 --> 45:03.920]  мне нужен максимальный собственный суффикс вот
[45:04.540 --> 45:08.220]  этой вот строки, которая есть в боре, но извините,
[45:08.220 --> 45:10.720]  вот в точности то, что мы уже сделали, мы приписали
[45:10.720 --> 45:15.180]  к строке букву, и пытаемся найти для нее линк.
[45:15.180 --> 45:17.120]  Линк, это максимальный собственный суффикс, который
[45:17.120 --> 45:18.120]  есть в боре.
[45:18.120 --> 45:19.600]  Вот здесь мы это только что делали.
[45:19.600 --> 45:21.820]  Мы приписывали к в букву ц и брали максимальный
[45:21.820 --> 45:23.600]  собственный суффикс такой строки, которой есть в
[45:23.600 --> 45:24.260]  боре.
[45:24.260 --> 45:26.860]  Тоже самое, у нас есть у, я приписал один символ,
[45:26.860 --> 45:29.460]  теперь мне нужно взять опять максимальный
[45:29.460 --> 45:31.860]  собственный суффикс, который есть в боре, я вот только
[45:31.860 --> 45:32.820]  что это сделал.
[45:32.820 --> 45:37.180]  То есть теперь мне нужно в этой формуле всюду v поменять
[45:37.180 --> 45:46.740]  на u, c на d, а вот это вот поменять на go u d.
[45:46.740 --> 45:48.540]  Короче, у меня здесь будет следующее.
[45:48.540 --> 45:53.420]  Так, давайте вы пока не будете переписывать эту строчку,
[45:53.420 --> 45:56.020]  я сейчас еще ее напишу сначала, потом мы ее с вами пофиксим.
[45:56.020 --> 46:05.420]  Значит опять два случая, да, либо ноль, если, или я не буду это делать.
[46:05.420 --> 46:11.860]  Короче, я не буду, этот случай не достигается, потому что u заведомо не ноль,
[46:11.860 --> 46:18.460]  потому что u это имеет длину хотя бы один, потому что я хотя бы один раз по символу прошел,
[46:18.460 --> 46:23.420]  поэтому u, она не пустая, значит для нее точно можно определить линку.
[46:23.420 --> 46:26.780]  Значит этот случай можно игнорировать и просто написать эту формулу.
[46:26.780 --> 46:31.180]  Сейчас скажу.
[46:31.180 --> 46:44.660]  Так, правда же? Да, вроде правда. Почему посчитано? Ну, смотрите,
[46:44.660 --> 46:52.420]  потому что линк от u имеет глубину не больше, чем v, да, потому что ну depth от u,
[46:52.420 --> 47:05.700]  давайте напишу так, depth от u, это depth от v плюс 1, depth от линк от u, соответственно, будет меньше,
[47:05.700 --> 47:11.580]  чем эта глубина, то есть меньше равна, чем depth от v. Ну, а для всех вершин на глубины меньше
[47:11.580 --> 47:18.100]  равного, чем depth от v, я уже go знаю, потому что так работает BFS. Если я обрабатываю вершину v,
[47:18.100 --> 47:22.780]  вот если здесь у меня из очереди извлеклась v, то для всех вершин на глубины не больше,
[47:22.780 --> 47:27.220]  чем она, я знаю go, значит я знаю вот это. Вот.
[47:27.220 --> 47:38.860]  For закончился, не забываю в конце написать, что u обработано, то есть ее добавить в очередь,
[47:38.860 --> 47:43.340]  ну и на этом вроде ахкарасик закончился.
[47:48.100 --> 47:59.860]  Вот. Значит еще раз обзор того, что произошло. Я поддерживаю то свойство, что у меня в каждом
[47:59.860 --> 48:05.220]  момент времени, когда я из очереди достаю вершину v, для всех вершин на глубины не больше, чем глубина v,
[48:05.220 --> 48:11.380]  все найдено, то есть и go, и линки для них для всех найдены. Сначала обрабатываю корень, добавляю его
[48:11.380 --> 48:16.980]  в очередь, купуш 0. Теперь достаю его из корня, понятно дело выполняется мой вариант, да, что ну там
[48:16.980 --> 48:22.140]  так bfs работает, что когда я достаю вершину из очереди, то все вершины на глубины меньше
[48:22.140 --> 48:27.300]  обраны, чем она, уже полностью посчитаны. Теперь я хочу, зная, что у меня ответы вот здесь,
[48:27.300 --> 48:34.100]  вот везде посчитаны, посчитать ответ для всех детей вершины v. Для этого я перебираю, собственно,
[48:34.100 --> 48:41.300]  ребенка, ну пропускаю, если это фиктивный ребенок, то есть если это переход по несуществующей букве,
[48:41.300 --> 48:45.900]  я его просто скипаю. Дальше линк, сначала насчитываю линк для этого ребенка, ну линк мы
[48:45.900 --> 48:51.100]  вот здесь с вами по полную форму написали, доказали, а здесь я просто ее зафиксировал. Дальше,
[48:51.100 --> 48:56.980]  теперь мне нужно для u найти не только линк, но и все go. Вот давайте я для всех d из алфавита буду
[48:56.980 --> 49:05.900]  искать go u d. Вот, что такое go u d? Это мне нужно приписать к u какую-то букву d и найти максимальный
[49:05.900 --> 49:14.100]  суффикс этой стреки, которая читается из корня. Есть два случая, если из u просто была стрелка по
[49:14.100 --> 49:23.020]  букве d в нашем боре изначально, то go, собственно, ведет сюда. Всегда, если из вершины просто читается
[49:23.020 --> 49:27.220]  буква вниз, то go то же самое, что tu, потому что можно просто всю строчку эту оставить u
[49:27.220 --> 49:32.500]  плюс d. Это какая-то вершина бора, она читается из корня, поэтому я просто ее оставляю банально.
[49:32.500 --> 49:41.020]  Интереснее ситуация, если такого перехода нету, как вот здесь, такого перехода нету. В этом случае
[49:41.140 --> 49:46.600]  работает предыдущая логика. У меня была некая строка, я приписал букву, и мне нужно оставить
[49:46.600 --> 49:50.900]  максимальный, собственно, суффикс такой строчке, которая считается из корня. Собственный, ну потому
[49:50.900 --> 49:53.860]  что всю строчку оставить нельзя. Мы только что поняли, что вся строка в боре и не лежит,
[49:53.860 --> 49:59.180]  поэтому нужен собственный суффикс. Ну а это мы точно разбирали. У меня была строка,
[49:59.180 --> 50:04.540]  я предписал на ней символ, мне нужно найти максимальный собственный суффикс для нее. Ну здесь,
[50:04.540 --> 50:10.280]  мы это только что доказывали. Причем это случає не достигается, поскольку у у не 0. U это уже
[50:10.280 --> 50:15.160]  корень, потому что это сын какой-то вершины. Нужно просто вот это написать с
[50:15.160 --> 50:22.520]  переводом v в u и c в d. Ну, здесь вроде написано. Вот. Дальше соображаем, что это
[50:22.520 --> 50:26.120]  корректно, потому что эта вершина имеет глубину не больше, чем глубина v, значит
[50:26.120 --> 50:29.000]  для нее все go уже посчитаны, поэтому так можно сделать. Там уже все посчитано
[50:29.000 --> 50:34.920]  правильно. В конце не забываем, что теперь мы для вершины u нашли все ответы,
[50:34.920 --> 50:39.280]  добавляем ее в очередь, ну и дальше потом из нее наш BFS будет дальше всю эту
[50:39.280 --> 50:44.880]  информацию проталкивать. Вроде все.
[50:46.800 --> 50:49.800]  Бросаем.
[50:51.520 --> 50:54.520]  Круто.
[50:54.520 --> 51:15.560]  Так. Хорошо. Хорошо. Все. Собственно, мы нашли все линки и все go. Ахкарафик
[51:15.560 --> 51:20.720]  делал вот в точности вот это. Находит все линки и все go до всех вершин. Дальше.
[51:20.720 --> 51:24.480]  Перед тем, как возвращаться к исходной задаче и находить все вхождения, все
[51:24.480 --> 51:29.440]  словарных слов в текст, давайте я сначала сделаю две динамики на вот этом
[51:29.440 --> 51:37.400]  нашем боре. Значит первое. Пусть dp 1 от вершины v. Это будет количество
[51:37.400 --> 51:44.600]  терминальных вершин. Давайте просто dp не буду не буду обозначать, просто будет
[51:44.600 --> 51:57.480]  dp от v. Это количество терминальных вершин среди списка v, линк от v, линк от
[51:57.480 --> 52:03.960]  линк от v и так далее. Ну вплоть до того момента, пока эта линка
[52:03.960 --> 52:08.560]  определена. У меня каждый раз линк сокращает текущую длину, я вот беру
[52:08.560 --> 52:12.480]  линк, линк, линк, рано или поздно дойду до корня, ну и у корня уже линк не
[52:12.480 --> 52:19.840]  определена. Вот сколько средних терминальных. Как считать такую динамику?
[52:19.840 --> 52:24.880]  Ну очень просто. Понятно, что если, например, вот я рассмотрю дерево суффиксных
[52:24.880 --> 52:28.400]  ссылок, вот этих вот линков, да, кстати я ни разу не написал, но линк это
[52:28.400 --> 52:35.960]  называется по-русски суффиксная ссылка, суффиксная ссылка. Так вот, если я
[52:35.960 --> 52:39.200]  рассмотрю множество суффиксных ссылок, как они себя ведут, понятно, что это будет
[52:39.200 --> 52:50.160]  дерево. Будет корень, вершина номер ноль, ну и как-то в нее там кто-то ведет, кто-то
[52:50.160 --> 52:56.360]  ведет в них, кто-то ведет в них, ну и так далее. Ну понятно, что это дерево, потому что при
[52:56.360 --> 53:00.640]  взятии линк у меня глубина уменьшается, поэтому это точно ациклический граф. Ну
[53:00.640 --> 53:04.400]  и они все сводятся к корню, потому что пустая строка всегда является
[53:04.400 --> 53:09.680]  собственным суффиксом, который есть в боре, поэтому если я многократно беру вот этот самый
[53:09.680 --> 53:14.320]  максимальный собственный суффикс, то рано или поздно дойду до пустой строки. Поэтому вот
[53:14.320 --> 53:20.840]  это вот, да, набор суффиксных ссылок у меня именно, что сводится снизу вверх к корню. Вот. И дальше
[53:20.840 --> 53:25.560]  теперь для каждой вершины В, что мне нужно? Мне нужно всего лишь понять, сколько из вот этих вот
[53:25.560 --> 53:31.720]  вершин терминальных. Ну это простая динамика по дереву. Да, я знаю там, является корень терминальный
[53:31.720 --> 53:36.480]  или нет, я знаю, в чём ровно ДП от нуля. Дальше могу посчитать ДП для этих вершин, ДП для этих
[53:36.480 --> 53:43.400]  вершин, ДП для этих вершин, ДП для этой вершины. А это простой там ДФС, БФС, как угодно делается.
[53:43.400 --> 53:59.120]  Это простая динамика по дереву. Согласны? Хорошо. Давай зачем-то надо, чуть-чуть позже скажу.
[54:01.720 --> 54:22.120]  Это первое, что нужно делать. Второе, это давайте я назову Compressed. Ненавижу длинное
[54:22.120 --> 54:35.000]  название беременных. Compressed от В. Это ближайшая сувсылка в терминальную вершину. Давайте так и напишу.
[54:35.000 --> 54:49.520]  Ближайшая. Криво, криво, это не по-русски будет. Давайте так, первая вершина из списка
[54:49.520 --> 55:15.360]  Link от В, Link от Link от В и так далее. Являющийся терминальный. Не учитываем, да. Вот, тоже вроде
[55:15.360 --> 55:20.720]  понятное определение. Вот у нас есть В. Ну понятно, если она там терминальная, не терминальная, мы ее учтем,
[55:20.720 --> 55:27.240]  если надо. А дальше, вот давайте, мы будем несколько раз брать Link. Link, Link, Link. То есть Link от В,
[55:27.240 --> 55:33.800]  Link от В, Link от В и так далее. Вот давайте дождемся, когда будет впервые терминальная вершина. И вот на нее
[55:33.800 --> 55:54.000]  будет указывать наша сжатая компресс, сжатая суффиксная ссылка. Хорошо. Тоже вроде насчитывается
[55:54.000 --> 56:01.680]  тупой динамикой по дереву. Если вот так вот идти по нему сверху вниз, то что такое компресс для
[56:01.680 --> 56:09.680]  вершины В? Это мы смотрим на Link от В. Если она терминальная, то на нее и надо ссылаться. Да,
[56:09.680 --> 56:15.440]  но это просто ближайшая, просто первая терминальная. Если же она не терминальная, то мне нужно, видимо,
[56:15.440 --> 56:23.480]  взять просто компресс от Link от В. Вот есть В, вот есть Link от В. Дальше, из нее ведет какой-то компресс,
[56:23.480 --> 56:28.440]  уже посчитанное. Ну значит, мне нужно просто его сюда перекопировать, потому что вот на этом пути
[56:28.440 --> 56:37.480]  первая терминальная это вот эта. Значит, мне нужно опять из В показывать ровно сюда. Тоже вроде тупая
[56:37.480 --> 56:49.240]  линейная динамика по дереву. Что? Да, да. Нет. Будем считать? Нет, считать также сверху вниз. То есть я
[56:49.240 --> 56:53.280]  иду сверху вниз по дереву. Вот считаете, что я для всех вершин это посчитал, в частности для Link
[56:53.280 --> 56:59.720]  от В. Теперь как пишать для В? Ну если для Link от В уже все посчитано, то это либо просто Link от В,
[56:59.720 --> 57:04.800]  если она терминальная, либо компресс от Link от В, если она не терминальная. Поэтому сверху вниз скорее.
[57:04.800 --> 57:16.200]  Ну либо снизу вверх, тогда рекурсия нужна неприятно. Вот, хорошо. Такие две штуки ввели. Все, теперь
[57:16.200 --> 57:22.000]  давайте вооружившись с этим делом, давайте решать обе наши задачи. Напоминаю, задача первого
[57:22.320 --> 57:28.360]  в том, чтобы вывести общее количество вхождений, словарных слов текст. Второе, это вывести сами
[57:28.360 --> 57:39.080]  вхождения. Напечатать, где какая строка встречается. Хорошо. Значит, давайте я наш текст представлю,
[57:39.080 --> 57:52.440]  как последний символов и буду его читать в нашем боре с помощью Go. Следующим образом,
[57:52.440 --> 57:58.760]  я начинаю сначала в пустой строке, то есть в корне, а дальше на каждом шаге просто применяю
[57:58.760 --> 58:07.480]  Go к предыдущей вершине по очередному символу. Это будет Go от предыдущей вершины по новому
[58:07.480 --> 58:14.400]  символу строки tj. То есть я встал в корень, потом с помощью Go прочитал t1, попал в какой-то v1,
[58:14.400 --> 58:19.560]  потом с помощью Go прочитал t2, попал в v2, t3, v3 и так далее и так далее. То есть, ну как бы,
[58:19.560 --> 58:28.720]  каждый символ читаю, перехожу по Go от этого символа. Тогда замечание первое, ну короче, факт,
[58:29.520 --> 58:52.040]  vj это максимальный суффикс строки t1 и так далее tj, который есть в боре. То есть вот, скажем,
[58:52.040 --> 58:58.160]  я читаю мою строчку слева направо, в какой-то момент дочитал дожитого символа. Тогда я
[58:58.160 --> 59:03.200]  утверждаю, что vj будет отвечать самому длинному суффиксу текущей прочитанной строки,
[59:03.200 --> 59:10.480]  который есть в боре. Ну просто Go работает. Я по одному дописываю справа символы,
[59:10.480 --> 59:16.280]  оставляя каждый раз максимальный суффикс, который можно. Но если я каждый раз оставлял
[59:16.280 --> 59:20.920]  максимальный, то, понятно дело, в конце остается тоже максимальный. Вот более формально,
[59:20.920 --> 59:27.600]  очевидно, что vj это какой-то суффикс такой строки. Потому что я каждый раз
[59:27.960 --> 59:31.480]  дописывал по символу. То есть я вот дописал символы, оставил суффикс. Дописал символ,
[59:31.480 --> 59:34.300]  оставил суффикс, оставил символ, оставил суффикс и так далее. Понятно,
[59:34.300 --> 59:39.940]  что в конце vj это какой-то суффикс этой строки. Почему он максимальный? Потому что если,
[59:39.940 --> 59:43.660]  скажем, вот это настоящий максимальный суффикс строки, который есть в боре, то,
[59:43.660 --> 59:51.280]  скажем, дойдя вот досюда, у меня все вот эти вот строчки тоже читались бы в боре, и я бы их
[59:51.280 --> 59:56.580]  точно не сокращал. При проходе по Go я бы вот эти символы точно не отрезал. Ну значит,
[59:56.580 --> 59:59.500]  у меня тогда, соответственно, вот это вот было бы найдено в качестве выжитого.
[59:59.500 --> 01:00:05.580]  Противоречие. Значит, действительно, выжита максимальный суффикс, как бы
[01:00:05.580 --> 01:00:11.060]  максимальный суффикс этой строки, который считается в боре. И теперь я
[01:00:11.060 --> 01:00:15.340]  что буду делать? Смотрите, при, в момент времени, когда я прочитал очередной
[01:00:15.340 --> 01:00:18.940]  символ tg, когда я определил максимальный суффикс, который
[01:00:18.940 --> 01:00:23.580]  считается в боре, вот давайте сейчас учтем все вхождения всех словарных слов,
[01:00:23.580 --> 01:00:28.860]  которые только что появились. Вот я дописал в конце tg, какие вхождения
[01:00:28.860 --> 01:00:34.500]  появились. Ну, понятно, только какие-то такие. Это только суффиксы. Потому что
[01:00:34.500 --> 01:00:39.620]  когда дописывается символ, все другие вхождения, его не содержащие уже раньше
[01:00:39.620 --> 01:00:44.620]  были, появились только те, которые только что закончились. Очевидно, что других
[01:00:44.620 --> 01:00:49.140]  подстрок новых не появилось, только те, которые здесь закончились. Ну, а, и причем
[01:00:49.140 --> 01:00:52.340]  все они, это понятное дело, конечно, какие-то строки в боре, потому что
[01:00:52.340 --> 01:00:57.900]  словарные слова, их точно можно прочитать из корни. А это самое длинное слово бора,
[01:00:57.900 --> 01:01:01.380]  которое, которое является суффиксом. Значит, смотрите, мне нужно у вот этой
[01:01:01.380 --> 01:01:09.620]  строки понять, сколько ее суффиксов являются терминальными вершинами. А это
[01:01:09.620 --> 01:01:16.180]  в точность dp. Потому что вот есть какой-то самый длинный суффикс, который, который
[01:01:16.180 --> 01:01:21.300]  читается в боре. Мне нужно найти все его суффиксы, которые являются терминальными
[01:01:21.300 --> 01:01:27.420]  вершинами. Ну, смотрите, я каждый раз, что такое там link от v, link от link от v и так далее. Это я
[01:01:27.420 --> 01:01:32.740]  удаляю минимальное количество символов в начале так, чтобы оставшаяся строка была строкой из бора.
[01:01:32.740 --> 01:01:37.860]  Значит, link от v это скажем, ну, вот эта вот строка. Дальше я беру link от link от v, это
[01:01:37.860 --> 01:01:42.580]  следующее по длине строка и так далее. То есть многократное применение линки, это по факту
[01:01:42.580 --> 01:01:47.820]  перебор вообще всех суффиксов текущей строки, которые читаются из корни. Но и среди них мне
[01:01:47.820 --> 01:01:51.460]  нужно найти количество терминальных, потому что это в точности те строчки, которые только что
[01:01:51.460 --> 01:02:06.340]  получили вхождение. Итого можем написать следующее. В момент прочтения символа тж,
[01:02:06.340 --> 01:02:21.580]  новое вхождение, получают словарные слова,
[01:02:21.580 --> 01:02:32.380]  достижимые из vj многократными прыжками после ссылки.
[01:03:02.380 --> 01:03:15.340]  Ну и тогда все. Первая задача получается решается так. Мне нужно каждый раз, когда я считал символ
[01:03:15.340 --> 01:03:20.500]  и пересчитал текущий максимальный суффикс vj, мне нужно будет к ответу просто прибавить dp от vj.
[01:03:20.500 --> 01:03:28.260]  Потому что dp от вершины это в точности число терминальных вот среди вот этого вот списка.
[01:03:28.260 --> 01:03:33.660]  А здесь как раз вот все терминальные это то, что мне нужно. Все терминальные в этом списке это в
[01:03:33.660 --> 01:03:38.260]  точности те слова, которые только что получили вхождение, которые только что завершились. Все
[01:03:38.260 --> 01:03:45.900]  вот эти слова у меня как раз существуются. Получается первая задача решается так. Я строю
[01:03:45.900 --> 01:03:51.900]  бор, запускаю, говорит, махкарасик. Дальше для строки t, ну как бы иду по ней слева направо,
[01:03:51.900 --> 01:03:58.100]  поддерживаю в vj текущий максимальный суффикс, который читается из бора, и просто к ответу
[01:03:58.100 --> 01:04:07.180]  добавляю dp для текущей вершины. Вот это была первая задача без штриха. Задача. Вот. Чтобы
[01:04:07.180 --> 01:04:13.980]  решить вторую задачу, мне нужно просто ну по сжатым ссылкам пропрыгать. Потому что что такое
[01:04:13.980 --> 01:04:19.260]  сжатые ссылки? Это в точности перечисление, то есть многократное применение сжатой суффиксной
[01:04:19.260 --> 01:04:23.700]  ссылки. Это в точности перечисление всех суффиксов, которые являются терминальными вершинами.
[01:04:23.700 --> 01:04:29.200]  Ну вот благо как раз я с помощью компресс, с помощью вот этих вот сжатых суффиксных ссылок умею
[01:04:29.200 --> 01:04:35.260]  упрыгать только по терминальным. То есть из всего вот этого списка я знаю какая ближайшая терминальная.
[01:04:35.260 --> 01:04:41.180]  То есть у меня есть много стрелок, и вот выше-выше они идут. Я знаю где терминальные. Вот это вот первая
[01:04:41.180 --> 01:04:51.500]  терминальная. Вот это вторая, третья и так далее. Для задачи штрих. Ну мне нужно просто как бы
[01:04:51.500 --> 01:05:10.860]  просмотреть. В, компресс от В, компресс от компресс от В, ну и так далее. Вот. И поскольку они перебирают
[01:05:10.860 --> 01:05:18.860]  не вообще все вот эти вот, да, не все вершины из этого списка, а только терминальные, то вот время
[01:05:18.860 --> 01:05:23.700]  работы этого цикла в точности равно количеству вхождений, которые мы только что получили. Ну и
[01:05:23.700 --> 01:05:27.820]  понятно, что если нам их нужно все вывести, да, вот у меня задача вот эта штрихованная как раз просит
[01:05:27.820 --> 01:05:32.700]  вывести список всех вхождений всех словарных слов. Я как раз, получается у меня каждый прыжок по
[01:05:32.700 --> 01:05:38.340]  суффсылке, сжатый вот такой, он получает очередное вхождение очередного словарного слова в нашу
[01:05:38.340 --> 01:05:44.740]  строчку. Да, потому что он как раз прыгает по терминальным суффсылкам. Каждое компресс, да,
[01:05:44.740 --> 01:05:49.500]  многократное применение компресс, это очередное вхождение словарного слова в текст. Ну раз их
[01:05:49.500 --> 01:06:06.860]  мне нужно напечатать, то я просто по ним пробегаю и печатаю. Вот. Вроде все. Так, вопросы есть? Ну ладно.
[01:06:06.860 --> 01:06:19.660]  Давайте тогда со симптотикой разберемся. Да. Ну вот именно, поэтому я написал здесь просмотреть,
[01:06:19.660 --> 01:06:25.220]  то есть если она терминальная, то ее надо учесть. Если не терминальная, то не надо учитывать. А дальше
[01:06:25.220 --> 01:06:30.460]  просто список всех компрессов. Да, ну то есть вот тут отдельно еще и фаятс, и в, является ли она
[01:06:30.460 --> 01:06:34.540]  терминальной. Если является, надо вывести, иначе не надо. А дальше вот список компрессов, это в
[01:06:34.540 --> 01:06:39.500]  точности все терминальные. Поэтому вот с ней надо отдельно еще и флот, да. Вот. Давайте со симптотикой
[01:06:39.500 --> 01:06:49.260]  разберемся. В первой задаче скажите, пожалуйста, за сколько работает алгоритмах Карасик по симптотике.
[01:06:49.260 --> 01:07:10.540]  Как-то я его пропустил. Еще раз, учитывая. Ну даже учитывая, да. Вот. Там действительно может показаться
[01:07:10.540 --> 01:07:16.020]  сигма квадрат, потому что два ложных символа С и Д. Но на самом деле это просто В на сигма квадрат.
[01:07:16.700 --> 01:07:30.820]  Просто В на сигма. Где В это число вершин. Число вершин Бора. Ну да, число вершин Бора. Почему? То есть там
[01:07:30.820 --> 01:07:38.620]  формально было два вложенных цикла, да. По С из сигма и по D из сигма. Вот. Но на самом деле вот здесь
[01:07:38.620 --> 01:07:43.860]  я выхожу, я делаю континью в момент, если у это не вершина. То есть на самом деле вот это вот это
[01:07:43.860 --> 01:07:50.500]  просто цикл по всем вершинам. А дальше для каждой вершины цикл по D. Поэтому симптотика будет
[01:07:50.500 --> 01:07:56.940]  В на сигма. То есть вот это вложенное здесь получается только если это соответствует
[01:07:56.940 --> 01:08:06.900]  некоторой вершине. Ну значит вот как раз такая симптотика. Сигма квадрата там нет. Вот. Ну это
[01:08:06.900 --> 01:08:16.020]  ахкарасик, да. Построение ахкарасик. Давайте напишем, что это ахкарасик. Плюс динамика. Ну там динамика вообще
[01:08:16.020 --> 01:08:21.900]  тривиальная за O от В считается, потому что это просто там ДПшка по дереву. Поэтому я ее здесь не
[01:08:21.900 --> 01:08:30.340]  пишу. Ну а дальше я видимо за линейное время удлины текста могу посчитать все вот эти вот. Ну да, то есть
[01:08:30.340 --> 01:08:34.420]  я просто к канцу добавляю все вот эти ДПшки. Поэтому дальше будет просто линия удлины текста Т.
[01:08:34.420 --> 01:08:42.660]  Я текст читаю слева направо, пробегаю по его символам с помощью Go и к ответу добавляю ДП
[01:08:42.660 --> 01:08:50.500]  от текущей вершины. Вот. Ну а здесь в задаче, где нужно вывести все вхождения, это будет то же
[01:08:50.500 --> 01:09:01.740]  самое В на сигма плюс Т. Но еще плюс ans, где ans это собственно величина ответа. То есть количество
[01:09:01.740 --> 01:09:13.500]  всех вхождений. Ну потому что суммарное время работы вот этого цикла, когда я многократно беру
[01:09:13.500 --> 01:09:18.780]  компресс от компресс от компресс, время работы этого цикла в точности равно числу вхождений,
[01:09:18.780 --> 01:09:24.300]  которые только что получились. То есть время работы вот этого цикла равно просто ДП от ВЖ. Сколько
[01:09:24.900 --> 01:09:31.860]  слов только что получили вхождение. Вот. Ну и если мне нужно как бы каждый из них напечатать,
[01:09:31.860 --> 01:09:37.220]  а мне по условию именно что нужно было создать список всех вхождений, кто где входит, значит вот
[01:09:37.220 --> 01:09:43.260]  это вот работает с точностью за величину ответа. Сколько вхождений за столько это и работает. Ну и
[01:09:43.260 --> 01:09:48.060]  понятно, что быстрее нельзя, потому что если мне это нужно напечатать, то время работы хотя бы
[01:09:48.060 --> 01:10:03.500]  будет ans. Вот оно здесь и получается. Вот. Что, вопрос есть? Ну ладно. Давайте тогда закончим
[01:10:03.500 --> 01:10:05.300]  чуть пораньше сегодня. Вроде все.
