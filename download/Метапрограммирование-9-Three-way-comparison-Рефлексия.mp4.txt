[00:00.000 --> 00:14.680]  Сегодня у нас будут две темы, почти никак не связанные, но в каком-то смысле противоположные,
[00:14.680 --> 00:24.320]  потому что от космического корабля никаких удивлений не будет. Давно ждали, и вот наконец
[00:24.320 --> 00:32.640]  появилось. А вот от рефлексии мы должны получить катаасис. Ну, во всяком случае,
[00:32.640 --> 00:40.960]  рефлексия ближе ко второй половине. Поэтому космический корабль. Наконец-то операторы
[00:40.960 --> 00:50.560]  сравнения в плюсах стало удобно использовать. Ну, почти, со звездочкой. Появился новый оператор
[00:50.760 --> 01:00.720]  тройного сравнения. Более того, операторы сравнения теперь бывают дефолтными внезапно. То есть
[01:00.720 --> 01:08.480]  всякие простые кейсы, когда и держу понятно, как вы хотите сравнивать какие-то объекты. Компилятор
[01:08.480 --> 01:14.640]  теперь сам умеет выводить и генерить. Но более того, компилятор теперь умеет догадываться,
[01:14.640 --> 01:20.560]  как выразить один оператор сравнений из другого. И теперь нет нужды писать по шесть разных
[01:20.560 --> 01:27.640]  операторов сравнения. Вот, в общем и целом оно всё так, но дьявол, как всегда, в мелочах. Поэтому
[01:27.640 --> 01:35.120]  давайте повнимательнее об этом всём поговорим. Первый вопрос. Вот эти два выражения, они
[01:35.120 --> 01:46.720]  эквивалентны? А равно равно Б и А не меньше и не больше В? Ну, вроде бы нет. Вот это верно,
[01:46.720 --> 01:53.640]  они действительно не эквивалентны. Например, для флотов. Кто-нибудь знает пример конкретного флота,
[01:53.640 --> 02:07.480]  который ломает эту идею? Нам? Нам, да. Нам имеют очень странные свойства сравнения, и он не
[02:07.480 --> 02:13.640]  позволяет нам просто так сказать, что травенство это то же самое, что ни меньше ни больше. То есть
[02:13.640 --> 02:21.560]  чтобы вот это вот работало, нужно, если в терминах УКТЧ, кто его помнит, чтобы множество образовало
[02:21.560 --> 02:32.040]  лун, линейно-опрядачное множество. Но это ещё не всё. Есть более тонкая штука. А, я забыл брать
[02:32.040 --> 02:39.960]  подсказку, чёрт. В общем, вопрос такой. Вот А равно Б именно через оператор сравнивания, и А не отличима
[02:39.960 --> 02:52.880]  от Б? Одно и то же или нет? Не отличима это значит, что ты никак не сможешь написать код,
[02:52.880 --> 03:03.480]  который отличит два элемента друг от друга. Ну, что за такое? Подсказка не наталкивает на мысли?
[03:03.480 --> 03:16.360]  Ну так какой ответ, да или нет? Да, они опять не эквивалентны. И вот как именно это пример
[03:16.360 --> 03:27.200]  опровергает? Если мы сравниваем точки на плоскости по Х, то точки с одинаковым Х, но разным Y они
[03:27.200 --> 03:35.840]  будут равны по оператору равно равно, но мы можем их отличить. Например, взяв у обоих из них Y,
[03:35.840 --> 03:43.040]  и вот эти Y уже будут разными. И вот то, что слева называется эквиваленс, а то, что справа,
[03:43.040 --> 03:51.200]  называется equality. И чтобы это было одним и тем же, нам вновь нужно сохранение предикатов.
[03:52.200 --> 04:08.200]  Помните, когда мы говорили про концепты? Именно так. Ну, любое отношение эквивалентности можно
[04:08.200 --> 04:15.080]  трактовать как равенство, но тут всё очень сильно убирается в вопрос, а что такое вообще равенство?
[04:15.080 --> 04:20.760]  И как вы, возможно, помните изматологики, этот вопрос убойный, и можно в него копать бесконечно
[04:20.760 --> 04:31.760]  много. Вот тут предлагается такая терминология, стандарт, насколько я понимаю. Ну то есть,
[04:31.760 --> 04:39.200]  оператор равенства, он вам сдаёт какое-то отношение эквалентности на объектах, но оно не обязано
[04:39.200 --> 04:48.000]  как бы работать как вот реальное равенство. Если вы вспомните аксиоматику, как его символа равно,
[04:48.000 --> 05:01.040]  то там одна из аксиомов и вообще основная была, что для любого X, X равно X. И обратное, соответственно,
[05:01.040 --> 05:16.680]  наверное, что-то типа, нет, обратное не верно, ну типа, сейчас как это сказать. Тут опять опираемся
[05:16.680 --> 05:22.160]  во всякие артефакты матлогики, смотря как это всё определить, смотря какая модель, какая
[05:22.160 --> 05:29.320]  интерпретация, смотря по-разному. Но понт в том, что бывают такие элементы, такие вещи, такие
[05:29.320 --> 05:35.040]  объекты, которые как бы, вижу понятно, что неравны с такой повседневной точки зрения, например,
[05:35.040 --> 05:43.640]  две точки, но при этом какой-то оператор равенства может говорить, что они такие равны. И вот в этом
[05:43.640 --> 05:51.600]  состоит отличие терминов. И чтобы отличить все вот эти разные степени, какой вообще порядок у
[05:51.600 --> 05:58.760]  нас, какое у нас равенство, стандарт нанесли три вот таких типа. Давайте думать, что это просто
[05:58.760 --> 06:09.960]  янама. Вроде на самом деле не так, но почти так. И эти янамы ровно соответствуют тем трем категориям,
[06:09.960 --> 06:18.840]  которые мы рассмотрели. Соответственно, стронг ордеринг — это линейно порядочное множество,
[06:18.840 --> 06:26.960]  но не просто, а еще и сохраняющее свое равенство при любых функциях. То есть, если вспомним пример с
[06:26.960 --> 06:35.840]  точками на плоскости, вот функция проекции на оси y, она не будет сохранять равенство. Потому
[06:35.840 --> 06:40.480]  что у нас могли быть две точки с равными x, но при проекции на y результат вот применения этой
[06:40.480 --> 06:46.720]  функции проекции, они уже как бы неравны эти результаты. То есть, равенство не сохраняется.
[06:46.720 --> 06:54.760]  Weak ordering — это просто любой лун не обязан сохраняться равенства, и partial ordering — это
[06:54.760 --> 07:01.240]  частично порядочное множество, то есть чум. Чуть поподробнее. Strong ordering состоит из следующих
[07:01.240 --> 07:08.760]  элементов — less, equivalent, equal, greater. И может показаться странным, разве мы только что не сказали,
[07:08.760 --> 07:14.160]  что в случае стронг ордеринга equivalent, equal — это одно и то же. Ну так и да, это одно и то же,
[07:14.160 --> 07:21.040]  и equivalent здесь есть чисто для консистентности, потому что equivalent есть у всех других ордерингов,
[07:21.040 --> 07:28.080]  и чтобы нам проще было как-то писать обобщенный код, его добавили и сюда. Ну тогда вопрос, а зачем
[07:28.080 --> 07:34.480]  добавили equal? Чтобы подчеркнуть, что здесь equivalent — это не просто equivalent, а вот прям посильнее
[07:34.480 --> 07:42.720]  утверждение. Соответственно, строго говоря, что значит это сохранение равенства? Это значит,
[07:42.720 --> 07:50.120]  что любая функция, которая видит только то, что доступно по константной ссылке кому-то извне,
[07:50.120 --> 07:59.360]  то есть приватные кэши мутабельные мы не учитываем, любая такая функция должна сохранять
[07:59.360 --> 08:07.240]  равенство. Если а было равно b, то и f, а равно b. Заметь, f не обязан тип сохранять, то есть f может
[08:07.240 --> 08:13.200]  из нашего конкретного типа в какое-то другое переводить, у которого очевидно должно быть тоже
[08:13.200 --> 08:22.520]  определено равенство. И идея вот именно в этом, что если объекты в понимании человеческом равны,
[08:22.520 --> 08:27.280]  это значит, что они неразличимы по константссылкам. То есть как бы мы не извращались с этими
[08:27.280 --> 08:32.720]  константссылками, как бы мы не пытались что-то публичное оттуда достать, мы бы не смогли понять,
[08:32.720 --> 08:39.800]  в чем отличие между ними. Это вполне естественное ожидание от любого адекватного типа. Если равны,
[08:39.800 --> 08:46.960]  то не отличимы. Викордеринг почти то же самое, только икул не определяют, подчеркивая, что здесь
[08:46.960 --> 08:56.840]  эквивалентность не гарантирует этой неотличимости. А partial добавляет нам unordered, то есть два предыдущих
[08:56.840 --> 09:02.400]  они требовали, чтобы любые два элемента, они были либо равны, либо меньше, либо больше. Одно из трех,
[09:02.400 --> 09:11.680]  а вот здесь может быть четвертый вариант, что они вообще никак не упорядочны. Вот, как-то так.
[09:11.680 --> 09:16.880]  Ну вот мы определили три каких-то енамчика с какими-то элементами, и все эти элементы
[09:16.880 --> 09:23.160]  консистентны и одинаковы, но вот хочется какой-то универсальный простой способ по элементу одного из
[09:23.160 --> 09:29.960]  эти ордерингов понять, что он обозначает. Больше, меньше, равно, но при этом не прибегает к шаблонному
[09:29.960 --> 09:40.640]  коду. Для этого ввели в стандарт, не знаю, справедливо ли это назвать, костылем, но такой красивый хак.
[09:40.640 --> 09:47.480]  Вместо того, чтобы явно сравнивать с какими-то элементами янама или строить шаблоны, мы будем
[09:47.480 --> 09:54.800]  сравнивать эти элементы с нулем. Соответственно less это всегда меньше нуля, независимо это less
[09:54.800 --> 10:01.360]  и strong, weakly, partial, ordering. Equivalent equal всегда равны нулю из любого из ордерингов, greater
[10:01.360 --> 10:07.160]  больше и unordered не равны нулю. Соответственно, что конкретно там будет в unordered, не уточняется.
[10:07.160 --> 10:15.280]  Да, и сравнивать вот эти элементы этих янамчиков, их можно только с нулем, именно с нулем,
[10:15.280 --> 10:21.360]  литералом ноль, в коде должно быть написано просто ноль. То есть даже если вы constexpr переменную
[10:21.360 --> 10:27.200]  объявите и присвоите и ноль, и потом с ней будете сравнивать, это anti-fine behavior, так делать нельзя.
[10:27.200 --> 10:34.880]  Нужно явно в коде писать меньше, больше или равно нулю. Ну макрос, в крайнем случае.
[10:34.880 --> 10:42.120]  И соответственно с любыми другими типами сравнения ДУБ, да, даже сам том, сравнение ДУБ, несмотря
[10:42.120 --> 10:49.680]  что литерал ноль, он как бы int. И между собой их тоже можно сравнивать, но в каких ситуациях это
[10:49.680 --> 10:57.000]  нужно я сейчас не скажу. Ну и на этих оркерингах вполне естественным образом получается
[10:57.000 --> 11:06.480]  свой порядок на этих оркерингах. Вот эти стрелочки означают сильнее чем. То есть стронгордеринг
[11:06.480 --> 11:13.760]  сильнее чем виг, а виг сильнее чем паршоп. Но и с другой стороны оно значит, что то, что сильнее,
[11:13.760 --> 11:19.160]  можно преобразовать в то, что слабее. То есть если какие-то объекты можно сравнивать по
[11:19.160 --> 11:24.640]  стронгордерингу, это нам автоматически говорит, что их можно сравнивать и по виг и по паршал.
[11:24.640 --> 11:32.200]  Из одних эксем следуют другие. То есть паршал базовая, виг добавили еще одно требование, стронг
[11:32.200 --> 11:43.400]  еще одно требование. Как-то так. Соответственно космический корабль или НЛО, по-английски его
[11:43.400 --> 11:52.280]  и spaceship называют и flying saucer. Ну согласно стандарту это называется three-way comparison,
[11:52.280 --> 12:00.480]  то есть трехстороннее сравнение. Оно выглядит в общем случае вот так, возвращает какой-то из
[12:00.480 --> 12:06.800]  ордеров, может быть как non-member, так и member, и на вход принимает по концу ссылкам объект.
[12:06.800 --> 12:13.680]  Ну тут вы должны сказать, что ну позвольте, в плюсах можно операторы перегружать как
[12:13.680 --> 12:19.800]  мы хотим, для любых типов, любые возвращаемые значения, любые аргументы. Почему именно так?
[12:19.800 --> 12:26.840]  Ну действительно оператор spaceship можно перегрузить как вообще вы хотите, возвращая оттуда что угодно
[12:26.840 --> 12:35.880]  и принимая что угодно, используя его как угодно, но крайне не рекомендуется это делать. Мы скоро это
[12:35.880 --> 12:44.960]  увидим, причины этому есть, они достаточно веские. Ну окей, оператор spaceship мы можем определить для
[12:44.960 --> 12:52.440]  нашего типа, но хочется как-то более формализованно сказать, что оператор spaceship
[12:52.440 --> 12:58.560]  определён корректно. Конечно же, для этого завезли и концепт, который собственно можно
[12:58.560 --> 13:04.640]  использовать, чтобы проверять есть ли у типа spaceship. Он выглядит поначалу как-то страшно,
[13:04.640 --> 13:11.560]  как обычно, но если разобраться, всё легко. Первое требование weekly equality comparable with.
[13:11.560 --> 13:16.400]  Ну на самом деле это просто говорит о том, что есть оператор равенства и неравенства. Они
[13:16.400 --> 13:26.640]  определены и консистентны. То есть равно это не равно всегда. Purchase order with это тоже самое,
[13:26.640 --> 13:34.600]  но для меньше больше и меньше либо равно больше. Те же самые требования, что меньше это не больше
[13:34.600 --> 13:47.640]  либо равно. Вот, и последнее, это то, что выражение меньше равно больше, ну или a spaceship b,
[13:47.640 --> 13:57.000]  определено и возвращает что-то, что сильнее, чем категория, которую мы указали. Сверху видно,
[13:57.000 --> 14:02.440]  что этот концепт принимает вообще говоря произвольную категорию, но по умолчанию
[14:02.440 --> 14:11.720]  partial ordering. И вот этот вспомогательный концепт compare size, он приводит к наименьшему элементу и
[14:11.720 --> 14:19.560]  требует, чтобы этот наименьший элемент был таким же как cat. Сложно как-то сказать. Common
[14:19.560 --> 14:28.280]  comparison категории t внизу, это наименьший элемент среди набора в порядке на ордерингах. Тот,
[14:28.280 --> 14:37.640]  что я показывал из трех ордерингов. Мы говорим, что минимальный элемент в этом порядке это и есть
[14:37.640 --> 14:47.920]  cat. Ну то бишь, что spaceship для a и b вернет нам что-то либо такой же силы как cat, либо более
[14:47.920 --> 14:55.600]  сильной. Выглядит достаточно сложно для того, что в итоге получилось в стандарте, но раньше
[14:55.600 --> 15:02.920]  ордерингов было пять, если я не ошибаюсь, и вся эта машинерия имела больше смысла, чем когда их
[15:02.920 --> 15:08.360]  всего три, а как мы увидим в итоге, еще и не рекомендуется не использовать ни один из них,
[15:08.360 --> 15:17.520]  кроме стронга. Ну да ладно. Ну как-то так. Тут сразу вопрос должен возникнуть. Мы только что
[15:17.520 --> 15:23.320]  говорили в начале, что теперь можно не определять шесть операторов сравнения, а тут в концепте требуют,
[15:23.320 --> 15:30.760]  чтобы уже были определены и равно-равно, и неравно, и меньше, и больше, и все остальные. Ну требуют,
[15:30.760 --> 15:40.280]  а не требуют, но в язык добавлена новая фишка, которая дает вам их бесплатно. То есть это требование,
[15:40.280 --> 15:53.840]  оно такое фантомное на самом деле, как мы увидим. В итоге, мне кажется, что вот эти два требования,
[15:53.840 --> 16:02.480]  weekly, quality, partial, ordered, live, они нужны только если вы захотели заоптимизить и самостоятельно
[16:02.480 --> 16:11.160]  руками. Написали операторы меньше, больше и прочее. А во всех остальных случаях тут на самом деле
[16:11.160 --> 16:15.600]  все автоматом гарантируется. Единственное, что нам важно, это что spaceship определен и возвращать
[16:15.600 --> 16:22.480]  нужную категорию. Ну да ладно, идем дальше. Конечно же, для обстроенных типов spaceship сделан.
[16:22.480 --> 16:30.520]  Для integral он конечно же возвращает strong ordering, тут никаких сюрпризов. Для floating point partial,
[16:30.520 --> 16:37.160]  как мы уже сказали, у нас есть нам, он то ли ни с кем не сравним, то ли даже себе не равен,
[16:37.160 --> 16:42.960]  то ли еще что-то. При ближайшем рассмотрении оказывается, что только partial получается.
[16:42.960 --> 16:55.200]  Соответственно, для янамов тоже есть ordering, и он совпадает с тем, какой типы указали использовать
[16:55.200 --> 17:03.280]  для этих янамов. Надеюсь, вы помните, что после эту точку можно указывать янамам,
[17:03.280 --> 17:10.800]  какой тип использовать. И если мне сейчас память не изменяет, то этот тип всегда обязан быть
[17:10.800 --> 17:21.920]  std integral, а значит, ну всегда strong ordering. Кажется, что написано про underlining в стандарте,
[17:21.920 --> 17:31.760]  возможно, это заделка на будущее. Последние это pointer, для них есть strong ordering. Кажется,
[17:31.760 --> 17:37.720]  тоже никаких сюрпризов. Сюрприз есть только с одним пунктиком, когда вы используете вот этот
[17:37.720 --> 17:46.480]  встроенный меньше равно больше для целочисленных типов, работают все приведения, как и в любой
[17:46.480 --> 17:54.720]  другой арифметике, но не с bool. То есть, если вы сравниваете int с long-long, то у вас и то,
[17:54.720 --> 17:59.800]  и другое приведется в long-long. Но если вы сравниваете int с bool, то это будет ошибка компиляции,
[17:59.800 --> 18:10.400]  bool можно только самим собой. Почему такое исключение, я не уверен. Возможно, ладно,
[18:10.400 --> 18:16.480]  я не уверен. Вот, но тут стоит еще сделать одно уговор. Возможно, вы это знали, возможно,
[18:16.480 --> 18:25.520]  не знали, но сравнивание произвольных указателей это unspecified behavior, вообще говоря.
[18:25.520 --> 18:32.560]  Нет, там вроде прямо сразу уб, если указатели не имеют общего происхождения.
[18:32.560 --> 18:38.560]  По-моему, unspecified именно, а не undefined. Ладно, еще гляну.
[18:38.560 --> 18:47.600]  Да, так вот, о чем идет речь. Если у вас указатели указывают в адреса, которые являются частью одного
[18:47.600 --> 18:55.800]  объекта или одного массива, то все нормально. Они сравниваются адекватно в порядке хранения внутри
[18:55.800 --> 19:02.600]  массива или объекта. Но вот если вы указываете в два разных объекта или два разных массива,
[19:02.600 --> 19:10.720]  то их сравнение внезапно становится implementation defined, то есть unspecified. А почему так?
[19:10.720 --> 19:18.320]  Комитет верит, что до сих пор существуют архитектуры, на которых память нелинейна,
[19:18.320 --> 19:27.880]  то бишь не представляет собой массив подряд идущих байтов, от 0 до 2 в 48. Если у вас есть
[19:28.040 --> 19:32.000]  примеры таких архитектур, обязательно мне об этом сообщить, и мне реально интересно,
[19:32.000 --> 19:37.640]  где вообще такое найти? Вот эту мифическую архитектуру с сегментированной памятью.
[19:37.640 --> 19:48.920]  Мне в голову так и в рту приходят, но и куда возможно? Но куда это все равно не стандартные C++?
[19:48.920 --> 19:56.320]  В общем, не знаю. Если кто-то располагает информации, почему это до сих пор не убрали,
[19:56.320 --> 20:03.520]  пожалуйста, расскажите. Ну да, так вот, почему у нас там...
[20:03.520 --> 20:13.120]  Насчет указателей. В стандарте есть какая-то цитата, судя по описанию сравнения неравных
[20:13.120 --> 20:21.480]  указателей на объекты, тут есть пункт про то, что указатель выглядит как partial ordering даже.
[20:21.480 --> 20:31.480]  Ну да, имеется в виду именно это. Идея в том, что у нас бывают архитектуры с сегментированной
[20:31.480 --> 20:39.640]  памятью. Они раньше были, их было много, а сейчас уже где-то было найти. То есть у них не была одна
[20:39.640 --> 20:50.520]  оперативная память подряд идущая. Даже на GPU тогда она не сегментированная. Какую вам
[20:50.520 --> 20:57.520]  абстракцию операционная система предоставляет? Виртуальная память, она идет подряд. То есть
[20:57.520 --> 21:03.480]  иллюзия того, что вам выделили огромный чанк на 2.48 байтика, что хотите с ним, то и делитесь.
[21:03.480 --> 21:10.720]  И вот предполагается, что бывают такие операционные системы, которые работают не так, которые не
[21:10.720 --> 21:17.520]  предоставляют вам виртуальное адресное пространство, работают как-то по-другому. Возможно,
[21:17.520 --> 21:24.280]  это происходит, когда на embedded-системах, где несколько чипов с памятью, эти чипы
[21:24.280 --> 21:33.720]  напрямую предоставляются программе и считаются как бы вообще отдельными областями памяти. То есть,
[21:33.720 --> 21:39.160]  например, какой-нибудь битик отвечает за то, к какой планке памяти микроконтроллер обращается.
[21:39.160 --> 21:50.560]  Теоретически стандарт такое поддерживает, но это очень странно. Вот. Я не там читал,
[21:50.560 --> 21:56.560]  все-таки действительно он специфивает. Надо отдельно читать обычные операторы сравнения,
[21:56.560 --> 22:03.000]  отдельно трехсторонние, вот я не туда полетел. То есть, вот тут как бы такой конфликт. С одной
[22:03.000 --> 22:08.440]  стороны, в стандарте издревле принято считать, что существует архитектура с сегментированной
[22:08.440 --> 22:16.120]  памятью. С другой стороны, поинтеры выдают в стронгордере. Ну, видимо, потому что невозможно
[22:16.120 --> 22:21.640]  понять, в какой момент этот уб действительно уб, а поэтому невозможно сказать, когда нужно
[22:21.640 --> 22:29.240]  возвращать аннорго. Ну и это сильно усложнило жизнь тем, кто пишет код, хоть сколько-то обобщенный,
[22:29.240 --> 22:37.760]  если поинтеры partial сравнивались. Ну да ладно. Так, идем дальше. Этот код. Работает ли он? А тут
[22:37.760 --> 22:47.280]  уже ответ есть. Работает. Вам не кажется, что это магия? Компилятор научили понимать, что неравно
[22:47.280 --> 22:56.240]  это не равно. Представляете, до чего технологии дошли? Что не позволяло это сделать еще 30 лет назад?
[22:56.240 --> 23:02.040]  Загадка. Вот. Но теперь действительно достаточно только оператор равно определить вообще где
[23:02.040 --> 23:09.280]  угодно, в любой ситуации, и неравно автоматом будет доступен. Более того, если вы определили
[23:09.280 --> 23:17.040]  оператора spaceship, то вам доступны все операторы. То, о чем я говорил раньше, в концепте указаны
[23:17.040 --> 23:24.160]  вот эти вот требования, чтобы равно-неравно остальные четыре штуки были определены. Ну так
[23:24.160 --> 23:30.360]  если spaceship есть, то они уже определены как бы. Так что вот так. Не очень ясно, почему именно такой
[23:30.360 --> 23:40.520]  концепт. Да. Но даже круче можно. Вот здесь уже сложнее понять, что происходит. Давайте внимательно.
[23:40.520 --> 23:54.200]  Есть Q, есть C. Две разных структуры. Мы определили оператор сравнения C и Q. Слева C, справа Q. А внизу в
[23:54.800 --> 24:02.320]  мы сравниваем слева Q, а справа C. То есть не в том порядке, как определили. И это все равно работает.
[24:02.320 --> 24:08.080]  То есть компиляторы научили понимать, что равенство должно быть транзитивным,
[24:08.080 --> 24:19.160]  симметричным всегда, даже для разных типов. Ну а теперь подробнее. Как именно это работает?
[24:19.160 --> 24:25.400]  Есть вот такая табличка. Слева написаны исходные выражения, которые встречаются у вас в коде.
[24:25.400 --> 24:34.480]  Вообще говоря, выражения как слева должны привести к чему? Мы начинаем формировать список перегрузок,
[24:34.480 --> 24:41.280]  которые нам подходят. Потом выбираем из этих перегрузок наилучшую и ее используем. Теперь
[24:41.280 --> 24:47.640]  чуть по-другому. В этот список перегрузок подмешиваются так называемые переписанные
[24:47.640 --> 24:55.080]  кандидаты. То есть обратите внимание, когда мы пишем они равно B, в список перегрузок,
[24:55.080 --> 25:04.160]  то есть различных операторов не равно, подмешают как кандидата оператор равно. Странная штука,
[25:04.160 --> 25:12.000]  правда ли? Но при этом, если именно этот кандидат был выбран из всех перегрузок, в итоге в код
[25:12.000 --> 25:20.160]  вкомпилируется не вызов оператора равно, а отрицание вызова оператора равно. То есть вот так
[25:20.160 --> 25:27.800]  странно она работает. При грузке одних операторов теперь могут находить другие операторы. Ну и тут
[25:27.800 --> 25:33.680]  про приоритеты стоит сказать. Приоритеты абсолютно естественные. Вот то, что с синеньким отмечено,
[25:33.680 --> 25:40.080]  это так называемые синтезированные кандидаты. Это значит, что там переставлен порядок аргументов.
[25:40.080 --> 25:48.000]  И вот их стараются в последнюю очередь брать. То есть вот внизу порядок. Сначала мы стараемся
[25:48.000 --> 25:56.000]  обычных кандидатов найденных, как раньше, для операторов брать. Потом переписанные. Здесь это
[25:56.000 --> 26:03.960]  всего две строчки. Мы можем не равно переписать на равно, не поменяв местами аргументы. И можем
[26:03.960 --> 26:20.840]  любой оператор в сравнении переписать на spaceship. Мне кажется, тут нужно еще указать слева,
[26:20.840 --> 26:28.680]  где собачка, что равенство тоже может быть. По-моему, я не уверен. Кажется, не совсем. По-моему,
[26:28.680 --> 26:35.560]  это выпиливали как раз. Ага, то есть равенство все-таки не выражается через spaceship и табличка
[26:35.560 --> 26:41.600]  правильная? По-моему, да. Там где-то писалось, что они в какой-то момент заметили, что они
[26:41.600 --> 26:49.040]  раньше что-то перестали использовать в районе spaceship и выпили какие-то кучи всего. Надо
[26:49.040 --> 26:56.040]  пересчитать, короче. Но вроде правда, что-то написано. Ну, будем надеяться, что прошлый препод сделал
[26:56.040 --> 27:02.800]  правильную табличку. И пометим себе, что все эти вещи запоминать наизусть не нужно, а нужно
[27:02.800 --> 27:10.320]  помнить, как в цепо были переперн слезть и все это перечитать заново, когда понадобится. Вот,
[27:10.320 --> 27:17.280]  соответственно, просто сравнение меньше-больше через spaceship либо spaceship с переставленным. И
[27:17.280 --> 27:27.080]  обратите внимание, сам spaceship может быть переписан через spaceship. Это важно с переставленными
[27:27.080 --> 27:35.280]  аргументами. К тому, почему это важно. Давайте вот такой оператор spaceship рассмотрим. Вот он
[27:35.280 --> 27:43.200]  нехороший. Он int возвращает. Я сказал, что не стоит int возвращать. Ну и что он делает? Он
[27:43.200 --> 27:50.280]  возвращает просто разницу. И, конечно же, если эта разница меньше нуля, то числа были меньше. Если
[27:50.280 --> 27:56.880]  она равна нулю, то равны. Если больше, то больше. Но проблема тут не в этом. Проблема возникнет,
[27:56.880 --> 28:07.800]  если мы вот так сделаем. Вот тут два декл-тайпа написаны. Какие, по-вашему, типы будут выведены
[28:07.800 --> 28:21.400]  этими декл-тайпами? Отмечу, что тут теперь две разных структурки. Возвращается все еще int,
[28:23.400 --> 28:31.640]  и порядок, к которому эти структурки переданы в spaceship, здесь разные. А вот тут фиксирован
[28:32.520 --> 28:42.840]  порядок. Ну давайте, что в первой строчке выведется? Ну конечно нет. Мы здесь просто вызвали оператор
[28:42.840 --> 28:51.320]  меньше равно больше. Да, согласно приоритетам, если обычный кандидат, как и раньше, вот типа
[28:51.320 --> 28:58.320]  традиционный кандидат, подходит, все остальные не участвуют вообще. Ну действительно, вот этот
[28:58.320 --> 29:04.960]  оператор меньше равно больше. Просто функция, просто определена. Подходит, подходит. Он всех
[29:04.960 --> 29:16.120]  побеждает. А вот когда мы B и A меняем местами, то обычный кандидат нам уже не подходит. Смотрим
[29:16.120 --> 29:27.520]  в табличку. Самая нижняя строчка. Для A spaceship B есть синтетический кандидат, B spaceship A. B и A
[29:27.520 --> 29:36.640]  переставляются местами, но при этом переписанное выражение, оно сравнивает результат B spaceship A
[29:36.640 --> 29:46.960]  с нулем тоже spaceship. То есть многоуровневый spaceship. И в итоге мы получаем strong ordering. И вот это
[29:46.960 --> 29:54.480]  еще один веский аргумент, помимо, собственно, того, что у вас переписываются выражения. Не
[29:54.480 --> 30:01.680]  использовать ничего, кроме ordering. Пользователь не ожидает. Вернее, даже не так. Не пытаться
[30:01.680 --> 30:08.440]  использовать теперь эти операторы ни для чего, кроме честных сравнений. Вот если вы такой же
[30:08.440 --> 30:14.600]  фанат функциональных языков, как я, вам, возможно, хочется иногда оператор больше либо равно использовать
[30:14.600 --> 30:22.360]  как какую-нибудь нам хитрую функциональную конструкцию, делающую что-то с функциями. Не стоит,
[30:22.360 --> 30:28.040]  потому что она начнет переписываться как другие какие-то операторы, начнется всякий бред с
[30:28.040 --> 30:33.120]  перестановкой аргументов, выведением strong ordering вместо того возвращаемого типа,
[30:33.120 --> 30:44.760]  который вы хотели. Будет больно, не стоит. Едем дальше. Ну, если вы любитель STL, то наверняка
[30:44.760 --> 30:51.680]  знаете про функциональные объекты less, less equal, greater, greater. Это такие типы, у которых
[30:51.680 --> 30:59.320]  определенные операторы круглые скобки, которые любой шаблонный D сравнивает с соответствующим
[30:59.320 --> 31:06.200]  оператором. Да, меньше, больше и так далее. Ну и теперь такое же для CompereStriva есть. Никаких
[31:06.200 --> 31:14.160]  сюрпризов. Но есть бонус. Когда вы используете вот этот функциональный объект для сравнения
[31:14.160 --> 31:25.600]  указателей, он внезапно гарантирует strong ordering и уже никакого уб. Почему так? Ну, как бы вот так.
[31:25.600 --> 31:39.000]  То бишь, если вы собрались писать алгоритм STD log тупым путем сортировки мьюдексов по адресам,
[31:39.000 --> 31:46.520]  вы теперь можете это написать согласно стандарту. Вам нужно всего лишь использовать CompareStriva.
[31:46.520 --> 31:57.200]  Хотя раньше тоже можно было к Inkspot RT скастить, и это тоже работало. А еще STD less и STD greater тоже дают.
[31:57.200 --> 32:02.400]  Тоже дают? Тоже дают порядок на указателях. Именно поэтому можно в мапе их использовать,
[32:02.400 --> 32:10.960]  как указатель в мапах, как ключи. А, точно. Блин, да, это очень логично на самом деле. К сожалению,
[32:10.960 --> 32:17.920]  с Reway мы все еще не можем использовать никаких стандартных алгоритмах, так что да. Но скажете вы,
[32:17.920 --> 32:25.880]  а как же левость? Вот это все новое накрутили, а кода уже написана куча, и оно будет все не дружить
[32:25.880 --> 32:31.280]  друг с другом. Если мы внезапно начнем общенный код на оператор spaceship писать,
[32:31.280 --> 32:38.760]  использовать новый функтор, все полетит. Но на самом деле не полетит. Давайте попробуем
[32:38.760 --> 32:50.280]  BinPolsk написать на spaceship. Написали. Заметьте, раньше, если бы вы писали BinPolsk для произвольного
[32:50.280 --> 33:01.400]  T, вы бы в обоих ветках F A вызывали соответствующий оператор сравнения у T. А есть ли это строки?
[33:01.400 --> 33:13.480]  Да? Строки сравнивать дорого. И поэтому какое-то время все жаловались, что у Lulu надо строк MP
[33:13.480 --> 33:19.200]  использовать, а не операторы меньше-больше равно для строк производительности, и т.д. и т.п.
[33:19.200 --> 33:27.400]  Теперь можно такой же производительности, как у сей, добиться и на плюсах, используя spaceship.
[33:27.400 --> 33:37.440]  Сэкономили nano, micro, ms. Ура! В крупных подбазах это, кстати, возможно, повлияет, потому что одно
[33:37.440 --> 33:43.040]  сравнение строк вместо двух, и если у нас весь код чуть более чем полностью состоит из сравнения
[33:43.040 --> 33:54.800]  строк, это весьма весомо. Вот. Так что профит. Но теперь вместо T подставили старый тип какой-нибудь.
[33:54.800 --> 34:02.080]  Докажется, даже те же самые строки в стандарте еще оператор spaceship не определяет. Но я не уверен.
[34:02.080 --> 34:10.880]  Возможно, определяют. Ну и что делать? Нам дали старый тип, для него нет spaceship, а зато есть все
[34:10.880 --> 34:19.840]  старые операторы сравнения. Напомнить, приходит вот такая штука, и ее рекомендуется использовать во
[34:19.840 --> 34:28.320]  всем обобщенном коде. Она пытается использовать spaceship, если не получается, делает за два сравнения
[34:28.320 --> 34:33.800]  с помощью старых операторов. Если быть точным, с помощью меньше и равно.
[34:33.800 --> 34:45.200]  С строком все-таки завезли оператор. А, завезли? Ну, здорово. Ну, к моему классу T строка,
[34:45.200 --> 34:56.040]  который написали 20 лет назад, еще не завезли. Так что штука полезная, тем не менее. Да, ну,
[34:56.040 --> 35:02.560]  если мы, соответственно, собрались вот так вот двумя путями T через либо spaceship, либо через
[35:02.560 --> 35:10.960]  старое, то сразу как-то вот надалкивает на мысли, что точка кастомизации нужна, чтобы вот подкостыливать
[35:10.960 --> 35:20.680]  библиотеки. Ну и действительно так и есть. Тут написано, что точек кастомизации 6. На самом деле
[35:20.680 --> 35:27.280]  точками кастомизации являются только strong order, weak order и partial order. Первые три. Остальные три
[35:27.280 --> 35:36.920]  просто добавляют fullback на традиционные операторы сравнения. Так вот, что делает стд что-то
[35:36.920 --> 35:48.280]  order? Первые три. Он, первое, пытается использовать цпошку с таким же названием. Надеюсь, вы помните,
[35:48.280 --> 35:56.360]  как это работает. В контексте, где неопределенно стд xorder, он пытается вызвать функцию xorder,
[35:56.360 --> 36:01.680]  если такая глобальная функция находится для соответствующих типов, используется она,
[36:01.680 --> 36:15.920]  если находится ADL-ом что-то, используется оно. Ну вот, то есть неблоид, тот самый. Опять. Дальше
[36:15.920 --> 36:24.040]  идет кастомизация флотов внезапно. Он гарантирует нужный order, то есть для strong
[36:24.040 --> 36:31.560]  order strong, для weak order weak, ну partial order и так. Оказывается, в стандарте ee-e-e что-то там,
[36:31.560 --> 36:40.640]  что-то там, то есть в стандарте флотов, есть способ как упорядочить сильно plotting point числа.
[36:40.640 --> 36:47.120]  И ровно этот способ и используется. То есть, если вы хотите флоты сравнивать строго,
[36:47.120 --> 36:53.640]  вам нужно использовать именно вот эти вот функции. Ну и поэтому в общенном коде, собственно,
[36:53.640 --> 37:00.400]  не рекомендуется спейс шип использовать как таковой. Вот либо эту штуку, что-то order,
[37:00.400 --> 37:11.920]  либо с holdback. Вот. Дальше идет функтор compare3way в общенном функциональном объекте. И после этого
[37:11.920 --> 37:21.320]  xorder пытается использовать более слабый порядок, более сильный. То есть, если мы запросили partial
[37:21.320 --> 37:31.600]  order на int, то он проигнорит первые три пункта, а в четвертом обнаружит, что функция strong
[37:31.600 --> 37:40.280]  order для int работает. Используем ее как-то так. А order fallback просто пытается сделать что-то
[37:40.280 --> 37:49.720]  order. И если не получилось, используют выражение «через меньше равно равно». То есть, если меньше,
[37:49.720 --> 37:59.320]  то вернуть минус один, иначе если равно вернуть ноль, иначе один. Соответственно, в общенном коде,
[37:59.320 --> 38:07.520]  то есть в шаблонах, всегда используем fallback как вариант. И только его, во избежание казусов,
[38:07.520 --> 38:31.200]  проблем и плохого кода. Дальше идем. Что я хотел сказать? Да, кажется, этот код должен быть вам
[38:31.200 --> 38:38.640]  знаком, если вы когда-нибудь решали вычислительную геометрию на олимпиаде. Часто приходится точки
[38:38.640 --> 38:48.320]  закинуть в какой-нибудь мэпчик, в какую-нибудь другую хитрую структуру на порядках основанную. Но
[38:48.320 --> 38:54.800]  для точки на плоскости вот такой оператор сравнения лексикографический, он абсолютно
[38:54.800 --> 39:02.040]  бессмысленен. В чем смысл физический? Почему именно в таком порядке? Почему наоборот? Почему
[39:02.040 --> 39:07.280]  не повернуть систему координат? То есть, как бы он даже в преобразовании никаких не сохраняет
[39:07.280 --> 39:14.280]  систему координат. Это какая-то плохая функция для точек на плоскости. Поэтому рекомендуется
[39:14.280 --> 39:21.400]  использовать ровно вот эту цеплошку для таких случаев. Если вам нужно закинуть в обещанный
[39:21.400 --> 39:29.840]  алгоритм, который не предоставляет компаратора вашу точку, но и при этом использует спейс шип и его
[39:29.840 --> 39:37.840]  друзей, используйте цепло стронг ворда, объявляете глобальную функцию и все в шоколаде. Правда,
[39:37.840 --> 39:42.920]  пока в стандарте нет ни одного алгоритма, который бы использовал вот эти вот вещи,
[39:42.920 --> 39:50.120]  но когда-нибудь они наверное появятся. То есть, как бы сделали хорошо, но не до конца, как обычно.
[39:50.120 --> 39:57.640]  Да, то есть знания классные, но бесполезные. Возможно, если вы свой обещанный код алгоритма
[39:57.640 --> 40:04.720]  будете писать, вы захотите это сделать не через компаратора, а через точки кастомизации. Иногда
[40:04.720 --> 40:15.840]  это разумно, иногда не очень. Так вот, следующий пункт программы — дефолтные сравнения. Теперь
[40:15.840 --> 40:26.600]  можно так делать. Кажется, радость. Кажется, круто, ура. Логично предположить, что все будет
[40:26.600 --> 40:33.720]  лексикографическое, но на самом деле никакой радости нет и ничего лексикографического тоже нет.
[40:33.720 --> 40:44.120]  Да, об этом чуть позже. Сейчас PRO меньше равно больше, его тоже можно делать дефолтным,
[40:44.120 --> 40:51.160]  и оно вам сгенерит бесплатно оператор равенства. И вот тут уже все будет хорошо.
[40:51.160 --> 41:01.720]  Мне не нравится порядок слайдов, ну да ладно. Даже так можно сделать, но при определенных условиях.
[41:01.720 --> 41:11.800]  Подробнее. Для меньше и его друзей это все не работает. То есть вот это определение равно дефолт,
[41:11.800 --> 41:21.760]  оно ничего не сделает, вообще ничего. Никак не повлияет на результат работы программы. Почему так?
[41:21.760 --> 41:28.880]  Ну так сложилось. А вот для равно оно будет работать, для спейсшипа тоже будет адекватно
[41:28.880 --> 41:34.960]  работать. То есть если вы хотите дефолтные операторы сравнения, вы либо равно определяете
[41:34.960 --> 41:40.720]  дефолтным, либо спейсшип. Про то, что вот эти вот пять штук можно делать дефолтными, вообще забудьте.
[41:40.720 --> 41:48.560]  Но чтобы понять, как они это делают, нам нужно понять такое, как экспандут листов subobjects.
[41:48.560 --> 41:58.400]  Но оно определяется ровно так, как звучит. Все базовые классы, все поля, ну и рекурсивно идем.
[41:59.200 --> 42:07.040]  А массивы соответственно по элементам сравниваются. Заметьте, что это значит, что на std-векторе
[42:08.880 --> 42:12.800]  все может сломаться, если он конечно не определяет сам оператор меньше равно больше.
[42:13.840 --> 42:19.840]  Тут такая проблема может быть. Так вот, как работает дефолтное сравнение.
[42:21.600 --> 42:27.600]  Берется экспандут листов subobjects для левого и правого аргумента равенства.
[42:28.720 --> 42:35.200]  И просто требуется, чтобы все они были попарно равны. Но кажется, что hf работает так, как и хотелось бы.
[42:36.000 --> 42:43.120]  Здорово. То есть запомнили, оператор равно можно всегда описать дефолтным. Все будет круто, все будет работать.
[42:44.160 --> 42:50.400]  Кроме особенных случаев, когда у вас какие-нибудь кэши внутри или что-нибудь такое.
[42:50.400 --> 43:02.160]  Но это так. Сменьше равно больше. Конечно же, оно делает лексикографическое сравнение в таком порядке, как
[43:03.600 --> 43:10.000]  подобъекты были объявлены. Ну то есть согласно этому определению, насколько я понимаю, мы сначала идем
[43:10.000 --> 43:17.360]  рекурсивно в первый базовый класс и для него получаем экспандут листов subobjects, потом второй базовый класс и так далее.
[43:18.080 --> 43:23.760]  А потом к всему этому дописываем все свои поля, попутно разворачивая массивы как отдельные элементы.
[43:26.240 --> 43:31.040]  Вот. В порядке объявления средства поля разворачиваем.
[43:34.080 --> 43:38.720]  И я думаю, код лексикографического сравнения вы все умеете писать.
[43:39.760 --> 43:43.120]  Вопрос только, какой ордеринг будет возвращаться в случае авто.
[43:44.080 --> 43:53.200]  Ну, здравый смысл подсказывает, что должен самый слабый из всех ордерингов, что вернули spaceship для x-ых ибрикад.
[43:53.200 --> 44:02.960]  Ну, оно так и есть. Но при этом, если хоть один из этих spaceship-ов вернул не ордеринг, то все ломается, конечно же, как обычно.
[44:02.960 --> 44:04.960]  Возвращайте только ордеринг.
[44:04.960 --> 44:17.280]  Что еще? Да, ну, самый слабый, это вот опять, так же, как в самом концепте с 3-way comparable определялось, ну, только наоборот, самый слабый, а не самый сильный.
[44:17.360 --> 44:28.720]  Да, но если у вас не у всех подобъектов определен ордеринг, может, где-то у них авто указано или еще что-нибудь такое, то вы можете явно прописать ордеринг.
[44:28.720 --> 44:30.720]  Или если вы хотите его усилить явно.
[44:30.720 --> 44:38.720]  И таки да, а если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
[44:38.800 --> 44:42.800]  И таки да, а если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
[44:42.800 --> 44:44.800]  Или если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
[44:44.800 --> 44:46.800]  И таки да, а если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
[44:46.800 --> 44:48.800]  И таки да, а если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
[44:48.800 --> 44:50.800]  И таки да, а если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
[44:50.800 --> 44:52.800]  И таки да, а если вы хотите, чтобы ордеринг был не ордеринг, то вы можете прописать ордеринг.
[44:52.880 --> 44:54.880]  Но мне кажется, с этим все равно не стоит рисковать.
[44:54.880 --> 44:56.880]  Но мне кажется, с этим все равно не стоит рисковать.
[44:56.880 --> 44:58.880]  Но мне кажется, с этим все равно не стоит рисковать.
[44:58.880 --> 45:00.880]  Но мне кажется, с этим все равно не стоит рисковать.
[45:00.880 --> 45:02.880]  Но мне кажется, с этим все равно не стоит рисковать.
[45:02.880 --> 45:04.880]  Но мне кажется, с этим все равно не стоит рисковать.
[45:04.880 --> 45:06.880]  Но мне кажется, с этим все равно не стоит рисковать.
[45:06.880 --> 45:08.880]  Но мне кажется, с этим все равно не стоит рисковать.
[45:08.880 --> 45:10.880]  Но мне кажется, с этим все равно не стоит рисковать.
[45:10.880 --> 45:12.880]  Но мне кажется, с этим все равно не стоит рисковать.
[45:12.880 --> 45:14.880]  Но мне кажется, с этим все равно не стоит рисковать.
[45:14.880 --> 45:16.880]  Но мне кажется, с этим все равно не стоит рисковать.
[45:16.880 --> 45:20.880]  Но мне кажется, с этим все равно не стоит рисковать.
[45:20.960 --> 45:22.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:22.960 --> 45:24.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:24.960 --> 45:26.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:26.960 --> 45:28.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:28.960 --> 45:30.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:30.960 --> 45:32.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:32.960 --> 45:34.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:34.960 --> 45:36.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:36.960 --> 45:38.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:38.960 --> 45:40.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:40.960 --> 45:42.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:42.960 --> 45:44.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:44.960 --> 45:46.960]  Но мне кажется, с этим все равно не стоит рисковать.
[45:47.040 --> 45:49.040]  Но мне кажется, с этим все равно не стоит рисковать.
[45:49.040 --> 45:51.040]  Но мне кажется, с этим все равно не стоит рисковать.
[45:51.040 --> 45:53.040]  Но мне кажется, с этим все равно не стоит рисковать.
[45:53.040 --> 45:55.040]  Но мне кажется, с этим все равно не стоит рисковать.
[45:55.040 --> 45:57.040]  Но мне кажется, с этим все равно не стоит рисковать.
[45:57.040 --> 45:59.040]  Но мне кажется, с этим все равно не стоит рисковать.
[45:59.040 --> 46:01.040]  Но мне кажется, с этим все равно не стоит рисковать.
[46:01.040 --> 46:03.040]  Но мне кажется, с этим все равно не стоит рисковать.
[46:03.040 --> 46:05.040]  Но мне кажется, с этим все равно не стоит рисковать.
[46:05.040 --> 46:07.040]  Но мне кажется, с этим все равно не стоит рисковать.
[46:07.040 --> 46:09.040]  Но мне кажется, с этим все равно не стоит рисковать.
[46:09.040 --> 46:11.040]  Но мне кажется, с этим все равно не стоит рисковать.
[46:11.040 --> 46:13.040]  Но мне кажется, с этим все равно не стоит рисковать.
[46:13.120 --> 46:15.120]  Дефолтное равно, так?
[46:15.120 --> 46:17.120]  Да.
[46:17.120 --> 46:19.120]  А вот с переписанными операторами пока непонятно.
[46:19.120 --> 46:21.120]  А вот с переписанными операторами пока непонятно.
[46:21.120 --> 46:23.120]  Да, то есть, видимо, поэтому равно не переписывается в spaceship.
[46:23.120 --> 46:25.120]  Да, то есть, видимо, поэтому равно не переписывается в spaceship.
[46:25.120 --> 46:27.120]  Да, то есть, видимо, поэтому равно не переписывается в spaceship.
[46:27.120 --> 46:29.120]  Потому что у нас есть...
[46:29.120 --> 46:31.120]  Потому что у нас есть...
[46:31.120 --> 46:33.120]  Если мы дефолтный spaceship используем, и так есть дефолтное равно.
[46:33.120 --> 46:35.120]  Если мы дефолтный spaceship используем, и так есть дефолтное равно.
[46:35.120 --> 46:37.120]  Если мы дефолтный spaceship используем, и так есть дефолтное равно.
[46:37.120 --> 46:39.120]  Более того, обычно на равенство
[46:39.120 --> 46:41.120]  Более того, обычно на равенство
[46:41.200 --> 46:43.200]  и можно проверить более эффективно, чем на меньше или больше.
[46:43.200 --> 46:45.200]  и можно проверить более эффективно, чем на меньше или больше.
[46:51.200 --> 46:53.200]  Бывают же еще типы, на которых нет порядка,
[46:53.200 --> 46:55.200]  но у них есть оператор равенства.
[46:55.200 --> 46:57.200]  Но у них есть оператор равенства.
[46:57.200 --> 46:59.200]  Такое тоже бывает.
[46:59.200 --> 47:01.200]  Такое тоже бывает.
[47:01.200 --> 47:03.200]  Вероятно, для того, чтобы с такими типами
[47:03.200 --> 47:05.200]  не возникало каких-то конфузов,
[47:05.200 --> 47:07.200]  равно не переписываются в spaceship.
[47:07.200 --> 47:09.200]  Мне кажется, с этим пока надо смириться.
[47:09.280 --> 47:11.280]  Мне кажется, с этим пока надо смириться.
[47:11.280 --> 47:13.280]  Когда-нибудь эту деталь мы для себя сами откроем
[47:13.280 --> 47:15.280]  в один прекрасный день.
[47:15.280 --> 47:17.280]  Чуть-чуть осталось.
[47:17.280 --> 47:19.280]  Давайте потерпим, сколько у нас там времени.
[47:19.280 --> 47:21.280]  Давайте потерпим, сколько у нас там времени.
[47:21.280 --> 47:23.280]  А, час прошел.
[47:23.280 --> 47:25.280]  Да, скоро будет перерыв.
[47:25.280 --> 47:27.280]  Так, что в этом случае получится?
[47:27.280 --> 47:29.280]  Так, что в этом случае получится?
[47:31.280 --> 47:33.280]  Кем будет автор?
[47:39.280 --> 47:41.280]  Паршал.
[47:41.280 --> 47:43.280]  Кажется, что
[47:43.280 --> 47:45.280]  по логике должен быть паршал.
[47:45.280 --> 47:47.280]  И кажется, он действительно есть паршал.
[47:53.280 --> 47:55.280]  Здесь должен был быть какой-то понт,
[47:55.280 --> 47:57.280]  но я забыл.
[47:57.280 --> 47:59.280]  Возможно, мы просто утвердили,
[47:59.280 --> 48:01.280]  что все поняли,
[48:01.280 --> 48:03.280]  как работает вот этот дефолтный spaceship.
[48:03.280 --> 48:05.280]  Берет наиболее слабый
[48:05.280 --> 48:07.280]  из всех подобъектов.
[48:07.360 --> 48:09.360]  Есть флот.
[48:09.360 --> 48:11.360]  У IntaStrong у флота паршал.
[48:11.360 --> 48:13.360]  Наиболее слабый – это паршал.
[48:19.360 --> 48:21.360]  Опять возникает вопрос про легаси.
[48:21.360 --> 48:23.360]  Но я уже забыл, какой.
[48:27.360 --> 48:29.360]  А вот такой.
[48:29.360 --> 48:31.360]  Если у нас есть какие-то
[48:31.360 --> 48:33.360]  объекты из библиотеки,
[48:33.360 --> 48:35.360]  откуда-то еще,
[48:35.440 --> 48:37.440]  все операторы сравнения, в принципе,
[48:37.440 --> 48:39.440]  определяют.
[48:39.440 --> 48:41.440]  И мы его хотим использовать в новом коде,
[48:41.440 --> 48:43.440]  где хотим автоматически выводить
[48:43.440 --> 48:45.440]  оператор spaceship.
[48:45.440 --> 48:47.440]  Должно ли такое работать?
[48:47.440 --> 48:49.440]  Конечно же, должно.
[48:49.440 --> 48:51.440]  Legacy написано миллионы строк.
[48:51.440 --> 48:53.440]  Мы такое хотим поддерживать.
[48:53.440 --> 48:55.440]  Поэтому я вас немного обманул.
[48:55.440 --> 48:57.440]  На самом деле,
[48:57.440 --> 48:59.440]  когда вы указываете явно
[48:59.440 --> 49:01.440]  возвращаемый ordering в дефолтом spaceship,
[49:01.440 --> 49:03.440]  это еще и помогает
[49:03.520 --> 49:05.520]  компилятору в тех ситуациях,
[49:05.520 --> 49:07.520]  когда все операторы сравнения
[49:07.520 --> 49:09.520]  как бы есть
[49:09.520 --> 49:11.520]  у какого-то подобъекта,
[49:11.520 --> 49:13.520]  а spaceshipа нет.
[49:13.520 --> 49:15.520]  То бишь с legacy-кодом работать.
[49:17.520 --> 49:19.520]  И ровно в этой ситуации
[49:19.520 --> 49:21.520]  автор работать не будет.
[49:21.520 --> 49:23.520]  Если мы вот здесь вместо
[49:23.520 --> 49:25.520]  стронгордеринг напишем автор,
[49:25.520 --> 49:27.520]  компилятор скажет эге,
[49:27.520 --> 49:29.520]  а какой ordering ты хочешь?
[49:29.520 --> 49:31.520]  Чего возвращать?
[49:31.600 --> 49:33.600]  Сам он по операторам сравнения
[49:33.600 --> 49:35.600]  догадаться не может.
[49:35.600 --> 49:37.600]  Операторы сравнения могут
[49:37.600 --> 49:39.600]  как угодно работать,
[49:39.600 --> 49:41.600]  пока явно ordering не уточнили,
[49:41.600 --> 49:43.600]  работать не будет.
[49:43.600 --> 49:45.600]  И тут тонкость в том,
[49:45.600 --> 49:47.600]  что
[49:51.600 --> 49:53.600]  x и y теперь сравниваются
[49:53.600 --> 49:55.600]  не spaceship,
[49:55.600 --> 49:57.600]  на самом деле,
[49:57.600 --> 49:59.600]  когда мы указываем
[49:59.680 --> 50:01.680]  что они сравниваются уже не spaceshipом,
[50:01.680 --> 50:03.680]  а в специальном
[50:03.680 --> 50:05.680]  sinstreeway,
[50:05.680 --> 50:07.680]  который и по сути
[50:07.680 --> 50:09.680]  то же самое, что fallback,
[50:09.680 --> 50:11.680]  только
[50:11.680 --> 50:13.680]  хитрый.
[50:13.680 --> 50:15.680]  Мне кажется,
[50:15.680 --> 50:17.680]  они просто не смогли нормально
[50:17.680 --> 50:19.680]  сформулировать стандарт, но то,
[50:19.680 --> 50:21.680]  что имеется в виду, понятно.
[50:21.680 --> 50:23.680]  В зависимости от того,
[50:23.680 --> 50:25.680]  что указали в redte,
[50:25.680 --> 50:27.680]  вот такие фы получаются.
[50:27.760 --> 50:29.760]  Либо из strongordering
[50:29.760 --> 50:31.760]  соответствующие элементы,
[50:31.760 --> 50:33.760]  либо из wika,
[50:33.760 --> 50:35.760]  либо из partial.
[50:39.760 --> 50:41.760]  Последний пункт программы
[50:41.760 --> 50:43.760]  по spaceship
[50:43.760 --> 50:45.760]  рекомендации, как его использовать
[50:45.760 --> 50:47.760]  в своем входе.
[50:51.760 --> 50:53.760]  Каждый тип должен делать
[50:53.760 --> 50:55.760]  одно из трех.
[50:55.840 --> 50:57.840]  Но определять все
[50:57.840 --> 50:59.840]  операторы сравнения
[51:01.840 --> 51:03.840]  имеется в виду каким-то образом.
[51:03.840 --> 51:05.840]  Либо через spaceship,
[51:09.840 --> 51:11.840]  либо руками,
[51:11.840 --> 51:13.840]  если этого так хочется и необходимо
[51:13.840 --> 51:15.840]  производительностью.
[51:15.840 --> 51:17.840]  Это первый вариант,
[51:17.840 --> 51:19.840]  когда тип упорядоченный.
[51:19.840 --> 51:21.840]  Второй вариант.
[51:21.840 --> 51:23.840]  Тип только сравниваемый.
[51:23.920 --> 51:25.920]  Он должен определять только равенство и неравенство.
[51:25.920 --> 51:27.920]  И третий вариант.
[51:27.920 --> 51:29.920]  Про тип ничего нельзя сказать,
[51:29.920 --> 51:31.920]  ничего не должно быть определено.
[51:31.920 --> 51:33.920]  Это очень естественные категории,
[51:33.920 --> 51:35.920]  и если вы посмотрите в любые другие языки,
[51:35.920 --> 51:37.920]  там это работает почти всегда так же.
[51:39.920 --> 51:41.920]  Объявляют какие-то
[51:41.920 --> 51:43.920]  трейды, тайп-классы, интерфейсы
[51:43.920 --> 51:45.920]  и прочие монстры,
[51:45.920 --> 51:47.920]  которые говорят
[51:47.920 --> 51:49.920]  equality и ordering.
[51:49.920 --> 51:51.920]  Ordering подразумевает equality,
[51:52.000 --> 51:54.000]  а все промежуточное
[51:54.000 --> 51:56.000]  считается плохим стилем,
[51:56.000 --> 51:58.000]  плохим кодом и прочее.
[52:00.000 --> 52:02.000]  Следующий гайдлайн.
[52:04.000 --> 52:06.000]  Сравнение должно идти
[52:06.000 --> 52:08.000]  по множеству тех вещей,
[52:08.000 --> 52:10.000]  которые по факту копируются,
[52:10.000 --> 52:12.000]  когда вы копируете объект.
[52:12.000 --> 52:14.000]  Иначе это было бы странно.
[52:14.000 --> 52:16.000]  Если сравнение использует
[52:16.000 --> 52:18.000]  что-то некопируемое,
[52:18.000 --> 52:20.000]  например, кэш какой-то,
[52:20.080 --> 52:22.080]  то вот вы скопировали объект
[52:22.080 --> 52:24.080]  и равенство изменилось.
[52:24.080 --> 52:26.080]  Из меньше превратилось в больше.
[52:26.080 --> 52:28.080]  Это очень неожиданно и неприятно.
[52:30.080 --> 52:32.080]  Просто человеческая натура не ожидает такого.
[52:32.080 --> 52:34.080]  Поэтому давайте так не делать.
[52:34.080 --> 52:36.080]  И наконец,
[52:36.080 --> 52:37.280]  не используйте никакие ordering
[52:37.280 --> 52:39.280]  без кроме strong.
[52:39.280 --> 52:41.280]  Внизу написано equality and equality
[52:41.280 --> 52:43.280]  should be identical,
[52:43.280 --> 52:45.280]  но подразумевается именно,
[52:45.280 --> 52:47.280]  что, пожалуйста, не используйте ничего,
[52:47.280 --> 52:49.280]  кроме strong.
[52:49.280 --> 52:51.280]  Потому что с чумами
[52:51.280 --> 52:53.280]  мы не умеем делать примерно ничего.
[52:53.280 --> 52:55.280]  У нас нет никаких алгоритмов
[52:55.280 --> 52:57.280]  для чумов.
[52:57.280 --> 52:59.280]  Мы не можем закинуть их в мэпчик.
[52:59.280 --> 53:01.280]  Мы не можем какие-то
[53:01.280 --> 53:03.280]  вычислительные алгоритмы,
[53:03.280 --> 53:05.280]  типа геометрических,
[53:05.280 --> 53:07.280]  использовать для чумов.
[53:07.280 --> 53:09.280]  Так что только strong ordering
[53:09.280 --> 53:11.280]  кроме случаев, когда вы можете
[53:11.280 --> 53:13.280]  и себе, и другим доказать,
[53:13.280 --> 53:15.280]  что здесь действительно
[53:15.280 --> 53:17.280]  необходим weak или partial.
[53:19.280 --> 53:21.280]  Да, предпочитайте
[53:21.280 --> 53:23.280]  default эти операторы сравнения,
[53:23.280 --> 53:25.280]  оператор spaceship.
[53:29.280 --> 53:31.280]  Но несуть важно, что там дальше написано.
[53:33.280 --> 53:35.280]  Дальше.
[53:35.280 --> 53:37.280]  Не заводите операторы сравнению
[53:37.280 --> 53:39.280]  типов, для которых
[53:39.280 --> 53:41.280]  эти операторы сравнения
[53:41.280 --> 53:43.280]  не имеют смысла.
[53:43.280 --> 53:45.280]  Например, делайте в вашей библиотеке
[53:45.280 --> 53:47.280]  для точки в онумерном пространстве
[53:47.280 --> 53:49.280]  оператор spaceship default
[53:49.280 --> 53:51.280]  это предъятельно.
[53:51.280 --> 53:53.280]  Ну, сама структура точки,
[53:53.280 --> 53:55.280]  математическая концепция,
[53:55.280 --> 53:57.280]  она не подразумевает никакого порядка.
[53:57.280 --> 53:59.280]  И люди этого не будут ждать.
[53:59.280 --> 54:01.280]  А с какой целью
[54:01.280 --> 54:03.280]  так делается обычно?
[54:03.280 --> 54:05.280]  Чтобы в мэпчик засунуть.
[54:05.280 --> 54:07.280]  И гайдайн состоит в том,
[54:07.280 --> 54:09.280]  чтобы не делать так,
[54:09.280 --> 54:11.280]  а либо через тут цепочку
[54:11.280 --> 54:13.280]  кастомизировать, когда мэпчик начнет
[54:13.280 --> 54:15.280]  это поддерживать, либо засовывать
[54:15.280 --> 54:17.280]  просто правило хорошего стимуля.
[54:21.280 --> 54:23.280]  Я не понимаю,
[54:23.280 --> 54:25.280]  что значит следующий гайдлайн,
[54:25.280 --> 54:27.280]  но на всякий случай я его оставил.
[54:29.280 --> 54:31.280]  Если кто-то понимает,
[54:31.280 --> 54:33.280]  поведайте.
[54:39.280 --> 54:41.280]  Кажется, это патология, да?
[54:41.280 --> 54:43.280]  Используйте слабый ордер,
[54:43.280 --> 54:45.280]  а слабое сравнение.
[54:45.280 --> 54:47.280]  Спасибо, Кэп,
[54:47.280 --> 54:49.280]  в этом все определение
[54:49.280 --> 54:51.280]  век ордера.
[54:51.280 --> 54:53.280]  Последний гайдлайн
[54:53.280 --> 54:55.280]  мы уже говорили,
[54:55.280 --> 54:57.280]  не используйте меньше равно больше,
[54:57.280 --> 54:59.280]  используйте compare
[54:59.280 --> 55:01.280]  fallback,
[55:01.280 --> 55:03.280]  как он назывался,
[55:03.280 --> 55:05.280]  strong, compare, strong
[55:05.280 --> 55:07.280]  order, fallback, вроде так.
[55:09.280 --> 55:11.280]  По крайней мере в обобщенном коде,
[55:11.280 --> 55:13.280]  делайте с конкретными типами,
[55:13.280 --> 55:15.280]  spaceship и spaceship,
[55:15.280 --> 55:17.280]  в шаблонах только с fallback.
[55:23.280 --> 55:25.280]  Этот совет долгое время
[55:25.280 --> 55:27.280]  считался нормой,
[55:27.280 --> 55:29.280]  теперь не считается нормой,
[55:31.280 --> 55:33.280]  но не знаю в общем.
[55:33.280 --> 55:35.280]  Тут была некая мотивировка,
[55:35.280 --> 55:37.280]  что
[55:37.280 --> 55:39.280]  с свободными функциями
[55:39.280 --> 55:41.280]  проще работать,
[55:41.280 --> 55:43.280]  когда у вас представляется порядок
[55:43.280 --> 55:45.280]  аргументов, да?
[55:45.280 --> 55:47.280]  То есть как бы, если вы
[55:47.280 --> 55:49.280]  хотите сравниваться с int,
[55:49.280 --> 55:51.280]  то вы определяете в своем классе
[55:51.280 --> 55:53.280]  member, оператор сравнения
[55:53.280 --> 55:55.280]  с int
[55:55.280 --> 55:57.280]  и второй оператор сравнения с int,
[55:57.280 --> 55:59.280]  который free function,
[55:59.280 --> 56:01.280]  потому что a меньше int
[56:01.280 --> 56:03.280]  и int больше a,
[56:03.280 --> 56:05.280]  и то и другое должно работать.
[56:05.280 --> 56:07.280]  Но теперь у нас есть переписывание,
[56:07.280 --> 56:09.280]  и эти советы все не актуальны
[56:09.280 --> 56:11.280]  по поводу того, как лучше
[56:11.280 --> 56:13.280]  member или free.
[56:13.280 --> 56:15.280]  Теперь можно писать как угодно.
[56:17.280 --> 56:19.280]  Последний совет
[56:21.280 --> 56:23.280]  противоположен предыдущему.
[56:23.280 --> 56:25.280]  Да, и
[56:25.280 --> 56:27.280]  тут есть некоторая
[56:27.280 --> 56:29.280]  аргументация,
[56:29.280 --> 56:31.280]  все аргументы
[56:31.280 --> 56:33.280]  они не валимы.
[56:33.280 --> 56:35.280]  То есть
[56:35.280 --> 56:37.280]  с одной стороны раньше говорилось так,
[56:37.280 --> 56:39.280]  теперь говорится сяк,
[56:39.280 --> 56:41.280]  и я скажу следующее, делайте как хотите.
[56:41.280 --> 56:43.280]  Теперь оба решения
[56:43.280 --> 56:45.280]  эквивалентны как по мне,
[56:45.280 --> 56:47.280]  у кого-то слово friend это
[56:47.280 --> 56:49.280]  триггер, это начнет
[56:49.280 --> 56:51.280]  трясти, пена из рта,
[56:51.280 --> 56:53.280]  так что лучше не произносить.
[56:53.280 --> 56:55.280]  Не знаю,
[56:55.280 --> 56:57.280]  может у кого-то в кодбазе забанено слово
[56:57.280 --> 56:59.280]  friend, и поэтому лучше member.
[56:59.280 --> 57:01.280]  Мне кажется как бы
[57:01.280 --> 57:03.280]  и последнее.
[57:03.280 --> 57:05.280]  Ну не делайте сами с partial ordering ничего
[57:05.280 --> 57:07.280]  вообще, ну пожалуйста.
[57:07.280 --> 57:09.280]  Ничто не поддерживает
[57:09.280 --> 57:11.280]  partial ordering в этом мире.
[57:11.280 --> 57:13.280]  И смысла так делать нет.
[57:13.280 --> 57:15.280]  Кажется его вообще в стандарт
[57:15.280 --> 57:17.280]  завезли только ради флотов,
[57:17.280 --> 57:19.280]  чтобы в очередной раз
[57:19.280 --> 57:21.280]  всем напомнить о том,
[57:21.280 --> 57:23.280]  что существует надо,
[57:23.280 --> 57:25.280]  и нельзя просто так впихивать
[57:25.280 --> 57:27.280]  флоты во всякие разные алгоритмы,
[57:27.280 --> 57:29.280]  не думая, что из этого получится.
[57:29.280 --> 57:31.280]  Типа, задумайтесь.
[57:33.280 --> 57:35.280]  Вот, следующая тема
[57:35.280 --> 57:37.280]  от рефлексии для бодтипов,
[57:37.280 --> 57:39.280]  но перед этим мы отдыхаем,
[57:39.280 --> 57:41.280]  если есть какие-то вопросы, давайте сейчас
[57:41.280 --> 57:43.280]  нам всех них постараемся ответить.
[57:51.280 --> 57:53.280]  Да, равно
[57:53.280 --> 57:55.280]  и меньше нельзя,
[57:55.280 --> 57:57.280]  давай вернемся к
[57:57.280 --> 57:59.280]  переписыванию,
[57:59.280 --> 58:01.280]  что нам позволяет определять меньше
[58:01.280 --> 58:03.280]  операторов. Вот эта там табличка.
[58:03.280 --> 58:05.280]  Операторы сравнения,
[58:05.280 --> 58:07.280]  меньше-больше,
[58:07.280 --> 58:09.280]  переписываются только через spaceship.
[58:09.280 --> 58:11.280]  То есть если ты хочешь минимум
[58:11.280 --> 58:13.280]  операторов обойтись,
[58:13.280 --> 58:15.280]  тебе нужно равно и spaceship.
[58:19.280 --> 58:21.280]  Ну что значит все?
[58:23.280 --> 58:25.280]  Ну как правило, у тебя очень
[58:25.280 --> 58:27.280]  элегантный код в spaceship получается.
[58:27.280 --> 58:29.280]  Представь, как ты строки
[58:29.280 --> 58:31.280]  и будешь сравнивать через spaceship.
[58:31.280 --> 58:33.280]  Ты идешь подряд,
[58:33.280 --> 58:35.280]  и как только нашел
[58:35.280 --> 58:37.280]  что-то неравное, возвращаешь
[58:37.280 --> 58:39.280]  меньше или больше.
[58:39.280 --> 58:41.280]  А потом в итоге,
[58:41.280 --> 58:43.280]  вне цикла,
[58:43.280 --> 58:45.280]  если дошел до конца и ничего не нашел,
[58:45.280 --> 58:47.280]  возвращаешь и код.
[58:47.280 --> 58:49.280]  То есть spaceship, это незначительство,
[58:49.280 --> 58:51.280]  нужно написать и меньше, и больше
[58:51.280 --> 58:53.280]  внутри него. Как правило, реализация
[58:53.280 --> 58:55.280]  spaceship проще, чем реализация
[58:55.280 --> 58:57.280]  меньше и больше соответствующая.
[58:57.280 --> 58:59.280]  Для длинной арифметики такая же реализация
[58:59.280 --> 59:01.280]  spaceship, как для строк.
[59:01.280 --> 59:03.280]  Вот, как-то так.
[59:03.280 --> 59:05.280]  Так что,
[59:05.280 --> 59:07.280]  в итоге мы все свели к домовым операторам.
[59:07.280 --> 59:09.280]  Просто вместо большей или меньшей
[59:09.280 --> 59:11.280]  оператор для сравнения
[59:11.280 --> 59:13.280]  теперь spaceship.
[59:13.280 --> 59:15.280]  Как-то так.
[59:17.280 --> 59:19.280]  Итак,
[59:19.280 --> 59:21.280]  пришло время научиться
[59:21.280 --> 59:23.280]  рефлексировать.
[59:23.280 --> 59:25.280]  Но для того,
[59:25.280 --> 59:27.280]  чтобы научиться рефлексировать,
[59:27.280 --> 59:29.280]  нам надо понять,
[59:29.280 --> 59:31.280]  что мы собрались рефлексировать.
[59:31.280 --> 59:33.280]  То есть, что такое подтипы?
[59:33.280 --> 59:35.280]  Подтипы это ничего, в принципе.
[59:35.280 --> 59:37.280]  Раньше в стандарте было такое
[59:37.280 --> 59:39.280]  определение, как plain old,
[59:39.280 --> 59:41.280]  data, type.
[59:41.280 --> 59:43.280]  Но теперь его нет, есть
[59:43.280 --> 59:45.280]  определение trivial и
[59:45.280 --> 59:47.280]  copyable и так далее.
[59:47.280 --> 59:49.280]  CDTrivial, по-моему, тоже есть.
[59:49.280 --> 59:51.280]  Но оно не совсем
[59:51.280 --> 59:53.280]  совпадает с тем,
[59:53.280 --> 59:55.280]  что мы имеем в виду.
[59:55.280 --> 59:57.280]  Но тут примерный список
[59:57.280 --> 59:59.280]  того, что имеется в виду,
[59:59.280 --> 01:00:01.280]  обозначен. По сути,
[01:00:01.280 --> 01:00:03.280]  это структурки из сеть,
[01:00:03.280 --> 01:00:05.280]  грубо говоря. Внутри которых
[01:00:05.280 --> 01:00:07.280]  могут быть другие структурки,
[01:00:07.280 --> 01:00:09.280]  но в итоге все сходится к
[01:00:09.280 --> 01:00:11.280]  интам, флотам и прочим
[01:00:11.280 --> 01:00:13.280]  драматильным типам.
[01:00:13.280 --> 01:00:15.280]  Почти.
[01:00:15.280 --> 01:00:17.280]  Все это, конечно, очень нестрого.
[01:00:17.280 --> 01:00:19.280]  Просто
[01:00:19.280 --> 01:00:21.280]  пытаемся себя
[01:00:21.280 --> 01:00:23.280]  оберечь от
[01:00:23.280 --> 01:00:25.280]  всяких
[01:00:25.280 --> 01:00:27.280]  кейсов, где вообще ничего невозможно сделать.
[01:00:27.280 --> 01:00:29.280]  Например, битовые поля мы будем
[01:00:29.280 --> 01:00:31.280]  рассматривать. Это извращенство.
[01:00:31.280 --> 01:00:33.280]  Дефолтные значения
[01:00:33.280 --> 01:00:35.280]  для полей мы не позволяем.
[01:00:35.280 --> 01:00:37.280]  Приватные не позволяем.
[01:00:37.280 --> 01:00:39.280]  То есть в целом должно вот как-то так
[01:00:39.280 --> 01:00:41.280]  выглядеть.
[01:00:41.280 --> 01:00:43.280]  Так вот, что мы собрались с этим всем
[01:00:43.280 --> 01:00:45.280]  делать? Мы собрались
[01:00:45.280 --> 01:00:47.280]  в compile-time
[01:00:47.280 --> 01:00:49.280]  определять количество
[01:00:49.280 --> 01:00:51.280]  полей,
[01:00:51.280 --> 01:00:53.280]  типы полей
[01:00:53.280 --> 01:00:55.280]  и ссылку на поля
[01:00:55.280 --> 01:00:57.280]  по его индексу.
[01:00:59.280 --> 01:01:01.280]  И, конечно,
[01:01:01.280 --> 01:01:03.280]  никакие лютые
[01:01:03.280 --> 01:01:05.280]  припроцессоры нам не дозволены,
[01:01:05.280 --> 01:01:07.280]  как есть в некоторых
[01:01:07.280 --> 01:01:09.280]  расширениях плюсов,
[01:01:09.280 --> 01:01:11.280]  вроде Qt
[01:01:11.280 --> 01:01:13.280]  и припроцессора
[01:01:13.280 --> 01:01:15.280]  Unreal Engine. Мы хотим
[01:01:15.280 --> 01:01:17.280]  просто подхачить это, вот, используя
[01:01:17.280 --> 01:01:19.280]  стандарт.
[01:01:21.280 --> 01:01:23.280]  И рассмотрим несколько способов
[01:01:23.280 --> 01:01:25.280]  все эти дела сделать.
[01:01:25.280 --> 01:01:27.280]  Какие-то из них лучше, какие-то хуже.
[01:01:27.280 --> 01:01:29.280]  Суммарно все костыли,
[01:01:29.280 --> 01:01:31.280]  но на этих костылях основаны
[01:01:31.280 --> 01:01:33.280]  некоторые библиотеки.
[01:01:35.280 --> 01:01:37.280]  И если кто-то из вас
[01:01:37.280 --> 01:01:39.280]  уже читал домашку
[01:01:39.280 --> 01:01:41.280]  последнюю, там от вас
[01:01:41.280 --> 01:01:43.280]  требуется название
[01:01:43.280 --> 01:01:45.280]  янамов,
[01:01:45.280 --> 01:01:47.280]  вытащить
[01:01:47.280 --> 01:01:49.280]  количество элементов янама
[01:01:49.280 --> 01:01:51.280]  и по индексу,
[01:01:51.280 --> 01:01:53.280]  и не только по индексу,
[01:01:53.280 --> 01:01:55.280]  по индексу и по его значению
[01:01:55.280 --> 01:01:57.280]  выдавать элемент янам.
[01:01:57.280 --> 01:01:59.280]  Но все это в какой-то степени
[01:01:59.280 --> 01:02:01.280]  связано, но не сильно.
[01:02:03.280 --> 01:02:05.280]  Я думаю, те, кто пытался
[01:02:05.280 --> 01:02:07.280]  решать, наверное, пока это никто,
[01:02:07.280 --> 01:02:09.280]  но тем не менее, те, кто пытался
[01:02:09.280 --> 01:02:11.280]  решать, должны были увидеть,
[01:02:11.280 --> 01:02:13.280]  что там упоминается
[01:02:13.280 --> 01:02:15.280]  такая вещь, как претефанкшн,
[01:02:15.280 --> 01:02:17.280]  который умеет свои шаблонные аргументы
[01:02:17.280 --> 01:02:19.280]  показывать.
[01:02:19.280 --> 01:02:21.280]  Это макрос,
[01:02:21.280 --> 01:02:23.280]  выводящий название функции,
[01:02:23.280 --> 01:02:25.280]  включая шаблонные аргументы.
[01:02:25.280 --> 01:02:27.280]  И на основе этого
[01:02:27.280 --> 01:02:29.280]  предлагалось и вытаскивать
[01:02:33.280 --> 01:02:35.280]  название янама,
[01:02:35.280 --> 01:02:37.280]  название элементов янама
[01:02:37.280 --> 01:02:39.280]  и даже лучше.
[01:02:39.280 --> 01:02:41.280]  Но вот здесь
[01:02:41.280 --> 01:02:43.280]  такие привыки нам
[01:02:43.280 --> 01:02:45.280]  не особо подходят.
[01:02:45.280 --> 01:02:47.280]  Это нам не поможет посчитать
[01:02:47.280 --> 01:02:49.280]  количество элементов,
[01:02:49.280 --> 01:02:51.280]  количество
[01:02:51.280 --> 01:02:53.280]  полей в структуре.
[01:02:53.280 --> 01:02:55.280]  Количество и
[01:02:55.280 --> 01:02:57.280]  номера элементов янам
[01:02:57.280 --> 01:02:59.280]  работало, если вы придумали,
[01:02:59.280 --> 01:03:01.280]  как решать задачу, а здесь нет.
[01:03:03.280 --> 01:03:05.280]  Зато работает
[01:03:05.280 --> 01:03:07.280]  другой тюк.
[01:03:09.280 --> 01:03:11.280]  Что будет, если мы сделаем
[01:03:11.280 --> 01:03:13.280]  вот так?
[01:03:13.280 --> 01:03:15.280]  Все нормально будет.
[01:03:15.280 --> 01:03:17.280]  Оно возьмет инициализируется
[01:03:17.280 --> 01:03:19.280]  нулями, если что.
[01:03:21.280 --> 01:03:23.280]  А так?
[01:03:23.280 --> 01:03:25.280]  Х будет единичкой,
[01:03:25.280 --> 01:03:27.280]  а Y инициализируется нулем.
[01:03:27.280 --> 01:03:29.280]  И так тоже все будет работать.
[01:03:31.280 --> 01:03:33.280]  А вот так уже не будет.
[01:03:35.280 --> 01:03:37.280]  Поняли, как находить количество
[01:03:37.280 --> 01:03:39.280]  элементов?
[01:03:39.280 --> 01:03:41.280]  Да.
[01:03:41.280 --> 01:03:43.280]  И это даже сложно назвать
[01:03:43.280 --> 01:03:45.280]  костылем, если честно.
[01:03:45.280 --> 01:03:47.280]  Это вполне естественный способ понять, сколько элементов
[01:03:47.280 --> 01:03:49.280]  в структуре.
[01:03:49.280 --> 01:03:51.280]  Ну то есть задача проста
[01:03:51.280 --> 01:03:53.280]  написать шаблон, который вот то же самое,
[01:03:53.280 --> 01:03:55.280]  что мы сейчас делали руками,
[01:03:55.280 --> 01:03:57.280]  делает автоматом.
[01:04:01.280 --> 01:04:03.280]  То бишь перебирать arcs
[01:04:03.280 --> 01:04:05.280]  от 0 до
[01:04:05.280 --> 01:04:07.280]  бесконечности.
[01:04:07.280 --> 01:04:09.280]  В какой-то момент мы встретим
[01:04:09.280 --> 01:04:11.280]  то, что не компилируется,
[01:04:11.280 --> 01:04:13.280]  и в этот момент нужно ответом
[01:04:13.280 --> 01:04:15.280]  дать size-1.
[01:04:19.280 --> 01:04:21.280]  Итак, вопрос.
[01:04:21.280 --> 01:04:23.280]  Откуда взять, собственно, аргументы?
[01:04:23.280 --> 01:04:25.280]  Мы тут такие умные единичку
[01:04:25.280 --> 01:04:27.280]  и char указывали,
[01:04:27.280 --> 01:04:29.280]  но мы же хотим произвольное, в принципе, типа
[01:04:29.280 --> 01:04:31.280]  поддерживать, да, более-менее.
[01:04:31.280 --> 01:04:33.280]  Какие есть идеи?
[01:04:41.280 --> 01:04:43.280]  Кто-нибудь помнит про
[01:04:43.280 --> 01:04:45.280]  операторы каста?
[01:04:47.280 --> 01:04:49.280]  Помним, помним.
[01:04:49.280 --> 01:04:51.280]  Нам нужен шаблонный
[01:04:51.280 --> 01:04:53.280]  оператор. Да!
[01:04:53.280 --> 01:04:55.280]  Мы можем сделать шаблонный оператор
[01:04:55.280 --> 01:04:57.280]  каста, который позволяет
[01:04:57.280 --> 01:04:59.280]  нашу структуру,
[01:04:59.280 --> 01:05:01.280]  которую мы назовем ubi-констрактор,
[01:05:01.280 --> 01:05:03.280]  кастоваться к любому типу.
[01:05:07.280 --> 01:05:09.280]  То есть синтаксис
[01:05:09.280 --> 01:05:11.280]  обычно оператор и название
[01:05:11.280 --> 01:05:13.280]  типа, да, ind, bool или что-нибудь такое.
[01:05:13.280 --> 01:05:15.280]  А мы сделали его шаблонным
[01:05:15.280 --> 01:05:17.280]  и подставили сюда произвольный тип.
[01:05:17.280 --> 01:05:19.280]  И я не помню,
[01:05:19.280 --> 01:05:21.280]  мы в это влезали или не влезали,
[01:05:21.280 --> 01:05:23.280]  когда говорили про шаблоны в самом начале.
[01:05:25.280 --> 01:05:27.280]  Вывод типов работы для операторов
[01:05:27.280 --> 01:05:29.280]  каста.
[01:05:29.280 --> 01:05:31.280]  Оно способно понять, какой шаблонный тип
[01:05:31.280 --> 01:05:33.280]  здесь указывать.
[01:05:33.280 --> 01:05:35.280]  Вот.
[01:05:35.280 --> 01:05:37.280]  И, собственно, на этом основном есть трюк.
[01:05:39.280 --> 01:05:41.280]  Шаблонный ССТ
[01:05:41.280 --> 01:05:43.280]  аргумент здесь нужен
[01:05:43.280 --> 01:05:45.280]  просто для удобства.
[01:05:45.280 --> 01:05:47.280]  То есть к самой этой структурке он не имеет
[01:05:47.280 --> 01:05:49.280]  отношения. Это вот, как мы ее использовали,
[01:05:49.280 --> 01:05:51.280]  собрались.
[01:05:51.280 --> 01:05:53.280]  Использовали мы ее собрались так.
[01:05:53.280 --> 01:05:55.280]  Знаю много букв.
[01:05:55.280 --> 01:05:57.280]  Давайте постепенно попытаемся разобраться.
[01:05:57.280 --> 01:05:59.280]  Читать будем,
[01:05:59.280 --> 01:06:01.280]  начиная с третьей строчки.
[01:06:01.280 --> 01:06:03.280]  constexpr, sidestack, count,
[01:06:03.280 --> 01:06:05.280]  field, simple.
[01:06:05.280 --> 01:06:07.280]  Оно принимает индекс sequence.
[01:06:07.280 --> 01:06:09.280]  Про индекс sequence
[01:06:09.280 --> 01:06:11.280]  помню, мы вроде с ним играли все же.
[01:06:11.280 --> 01:06:13.280]  И, соответственно,
[01:06:13.280 --> 01:06:15.280]  по переданному ей индекс
[01:06:15.280 --> 01:06:17.280]  sequence, она восстанавливает
[01:06:17.280 --> 01:06:19.280]  последовательность
[01:06:19.280 --> 01:06:21.280]  sidestacks, там,
[01:06:21.280 --> 01:06:23.280]  DAD, видимо.
[01:06:23.280 --> 01:06:25.280]  Дальше
[01:06:27.280 --> 01:06:29.280]  она берет и
[01:06:29.280 --> 01:06:31.280]  в эту последовательность
[01:06:31.280 --> 01:06:33.280]  дописывает нолик
[01:06:33.280 --> 01:06:35.280]  и просто передает
[01:06:35.280 --> 01:06:37.280]  ее в себя же дальше рекурсивно,
[01:06:37.280 --> 01:06:39.280]  указывая T.
[01:06:39.280 --> 01:06:41.280]  Единственный настоящий шаблонный
[01:06:41.280 --> 01:06:43.280]  аргумент.
[01:06:43.280 --> 01:06:45.280]  То есть пока это просто вот та рекурсивная
[01:06:45.280 --> 01:06:47.280]  часть.
[01:06:47.280 --> 01:06:49.280]  И самое главное
[01:06:49.280 --> 01:06:51.280]  здесь это вот
[01:06:51.280 --> 01:06:53.280]  constraint на второй строчке
[01:06:53.280 --> 01:06:55.280]  constructable from.
[01:06:55.280 --> 01:06:57.280]  То есть эта функция
[01:06:57.280 --> 01:06:59.280]  вызовется,
[01:06:59.280 --> 01:07:01.280]  вернее, подойдет
[01:07:01.280 --> 01:07:03.280]  среди набора перегрузок,
[01:07:03.280 --> 01:07:05.280]  только если T конструируется
[01:07:05.280 --> 01:07:07.280]  от ubic-конструктора от ish.
[01:07:07.280 --> 01:07:09.280]  Ну, а если
[01:07:09.280 --> 01:07:11.280]  она не подошла, нам
[01:07:11.280 --> 01:07:13.280]  нужен fallback.
[01:07:13.280 --> 01:07:15.280]  Ну вот же.
[01:07:15.280 --> 01:07:17.280]  Как и говорили,
[01:07:17.280 --> 01:07:19.280]  берем size of ish
[01:07:19.280 --> 01:07:21.280]  и вычитаем единичку.
[01:07:21.280 --> 01:07:23.280]  То есть мы будем стартовать
[01:07:23.280 --> 01:07:25.280]  с пустого index sequence
[01:07:25.280 --> 01:07:27.280]  и
[01:07:27.280 --> 01:07:29.280]  пытаться конструировать
[01:07:29.280 --> 01:07:31.280]  с T от ubic
[01:07:31.280 --> 01:07:33.280]  конструкторов
[01:07:33.280 --> 01:07:35.280]  столько штук, сколько элементов в i
[01:07:35.280 --> 01:07:37.280]  в index sequence.
[01:07:37.280 --> 01:07:39.280]  Пока у нас получается,
[01:07:39.280 --> 01:07:41.280]  вызывается вторая перегрузка.
[01:07:43.280 --> 01:07:45.280]  Она каждый раз дописывает еще по одному
[01:07:45.280 --> 01:07:47.280]  молику в index sequence.
[01:07:47.280 --> 01:07:49.280]  То есть index sequence в размере растет.
[01:07:49.280 --> 01:07:51.280]  И вот как только у нее перестало
[01:07:51.280 --> 01:07:53.280]  получаться конструировать, мы провалимся
[01:07:53.280 --> 01:07:55.280]  в первую перегрузку
[01:07:55.280 --> 01:07:57.280]  и выдадим ответ
[01:07:57.280 --> 01:07:59.280]  size of i-1.
[01:07:59.280 --> 01:08:01.280]  Понятно, почему
[01:08:01.280 --> 01:08:03.280]  это работает?
[01:08:03.280 --> 01:08:05.280]  Надеюсь, что да.
[01:08:05.280 --> 01:08:07.280]  Пока ничего
[01:08:07.280 --> 01:08:09.280]  сложного, просто код
[01:08:09.280 --> 01:08:11.280]  на слайде выглядит
[01:08:11.280 --> 01:08:13.280]  неприятно.
[01:08:13.280 --> 01:08:15.280]  Ну и
[01:08:15.280 --> 01:08:17.280]  запускать это мы собрались
[01:08:17.280 --> 01:08:19.280]  соответственно вот так.
[01:08:19.280 --> 01:08:21.280]  Пустой index sequence передаем
[01:08:21.280 --> 01:08:23.280]  и конкретный их термин.
[01:08:23.280 --> 01:08:25.280]  И это будет работать.
[01:08:25.280 --> 01:08:27.280]  Вопрос,
[01:08:27.280 --> 01:08:29.280]  что здесь выдастся?
[01:08:33.280 --> 01:08:35.280]  Наверное,
[01:08:35.280 --> 01:08:37.280]  1.
[01:08:37.280 --> 01:08:39.280]  Почему 0,
[01:08:39.280 --> 01:08:41.280]  почему 1?
[01:08:41.280 --> 01:08:43.280]  Потому что он может запилить
[01:08:43.280 --> 01:08:45.280]  конструктор копирования.
[01:08:45.280 --> 01:08:47.280]  Да, именно так.
[01:08:47.280 --> 01:08:49.280]  Хотелось бы, чтобы было 0.
[01:08:49.280 --> 01:08:51.280]  Мы от 0 аргументов пытаемся
[01:08:51.280 --> 01:08:53.280]  сконструировать. Работает.
[01:08:53.280 --> 01:08:55.280]  Дальше пытаемся от одного аргумента.
[01:08:55.280 --> 01:08:57.280]  И у нас срабатывает конструктор копирования.
[01:08:59.280 --> 01:09:01.280]  Неприятно.
[01:09:01.280 --> 01:09:03.280]  Тут нужно подкрутить
[01:09:03.280 --> 01:09:05.280]  костыль.
[01:09:05.280 --> 01:09:07.280]  И вместо constructable from,
[01:09:07.280 --> 01:09:09.280]  который мы там использовали выше,
[01:09:09.280 --> 01:09:11.280]  можно ли сконструировать
[01:09:11.280 --> 01:09:13.280]  от ubic?
[01:09:13.280 --> 01:09:15.280]  Использовать свой концепт.
[01:09:15.280 --> 01:09:17.280]  Который явно
[01:09:17.280 --> 01:09:19.280]  делает именно агрегатную унициализацию,
[01:09:19.280 --> 01:09:21.280]  а не какую-то там,
[01:09:21.280 --> 01:09:23.280]  какую constructable делает.
[01:09:23.280 --> 01:09:25.280]  И вот она
[01:09:25.280 --> 01:09:27.280]  запретит, если мне память
[01:09:27.280 --> 01:09:29.280]  не изменяет, формулировка такая,
[01:09:29.280 --> 01:09:31.280]  запретит вызывать конструктор
[01:09:31.280 --> 01:09:33.280]  копирования, если для этого требуется
[01:09:33.280 --> 01:09:35.280]  implicit cast.
[01:09:35.280 --> 01:09:37.280]  Ну и ubic
[01:09:37.280 --> 01:09:39.280]  именно implicit cast приводим к
[01:09:39.280 --> 01:09:41.280]  нужному типу, поэтому
[01:09:41.280 --> 01:09:43.280]  копирование не произойдет.
[01:09:43.280 --> 01:09:45.280]  И вот теперь это точно
[01:09:45.280 --> 01:09:47.280]  полностью работает.
[01:09:47.280 --> 01:09:49.280]  Здесь мы его заменили в requirement.
[01:09:51.280 --> 01:09:53.280]  А, для ubic
[01:09:53.280 --> 01:09:55.280]  правильно поделались.
[01:09:55.280 --> 01:09:57.280]  Что, для ubic?
[01:09:57.280 --> 01:09:59.280]  Это ты вопрос задаешь.
[01:09:59.280 --> 01:10:01.280]  У ubic это
[01:10:01.280 --> 01:10:03.280]  exposition only, так сказать.
[01:10:03.280 --> 01:10:05.280]  Да.
[01:10:05.280 --> 01:10:07.280]  Не рассматриваем всякие
[01:10:07.280 --> 01:10:09.280]  патологические случаи.
[01:10:09.280 --> 01:10:11.280]  В целом, все хорошо.
[01:10:11.280 --> 01:10:13.280]  Раньше это делали
[01:10:13.280 --> 01:10:15.280]  по-другому.
[01:10:15.280 --> 01:10:17.280]  Почему-то.
[01:10:17.280 --> 01:10:19.280]  По-моему, это придумал Антон Полухин
[01:10:19.280 --> 01:10:21.280]  вообще всю эту тему.
[01:10:21.280 --> 01:10:23.280]  И технология была такая.
[01:10:23.280 --> 01:10:25.280]  Давайте оценим количество
[01:10:25.280 --> 01:10:27.280]  полей, которых
[01:10:27.280 --> 01:10:29.280]  мы делали.
[01:10:29.280 --> 01:10:31.280]  Ну, в общем,
[01:10:31.280 --> 01:10:33.280]  давайте оценим количество полей
[01:10:33.280 --> 01:10:35.280]  структурки сверху как
[01:10:35.280 --> 01:10:37.280]  sizeof этой структурки.
[01:10:37.280 --> 01:10:39.280]  Весьма логичное предположение.
[01:10:39.280 --> 01:10:41.280]  Так как каждый объект
[01:10:41.280 --> 01:10:43.280]  в плюсах, он не может быть
[01:10:43.280 --> 01:10:45.280]  меньше одного байта.
[01:10:45.280 --> 01:10:47.280]  Да?
[01:10:47.280 --> 01:10:49.280]  Битфилды сразу вообще не рассматриваем.
[01:10:49.280 --> 01:10:51.280]  Ну и базовые классы тоже.
[01:10:51.280 --> 01:10:53.280]  Да.
[01:10:53.280 --> 01:10:55.280]  Соответственно, с базовыми классами
[01:10:55.280 --> 01:10:57.280]  это тоже, кажется, возможно, сработает.
[01:10:57.280 --> 01:10:59.280]  Но лучше не рисковать.
[01:10:59.280 --> 01:11:01.280]  Ну типа UBO там все-таки работает, поэтому...
[01:11:01.280 --> 01:11:03.280]  Да, UBO.
[01:11:03.280 --> 01:11:05.280]  Это ты в правильном направлении мыслишь.
[01:11:05.280 --> 01:11:07.280]  Но в целом и в общем
[01:11:07.280 --> 01:11:09.280]  оно как бы работало.
[01:11:09.280 --> 01:11:11.280]  И дальше мы брали
[01:11:11.280 --> 01:11:13.280]  и наоборот уменьшали количество
[01:11:13.280 --> 01:11:15.280]  аргументов.
[01:11:15.280 --> 01:11:17.280]  Вероятно, задачу про ИНАМ
[01:11:17.280 --> 01:11:19.280]  вы хотите решать примерно так же.
[01:11:19.280 --> 01:11:21.280]  Только оценку брать из другого места
[01:11:21.280 --> 01:11:23.280]  и проверять
[01:11:23.280 --> 01:11:25.280]  работает или не работает
[01:11:25.280 --> 01:11:27.280]  другим способом.
[01:11:29.280 --> 01:11:31.280]  Да, и соответственно вместо концептов
[01:11:31.280 --> 01:11:33.280]  юзалась ФИНАЕ. Здесь тоже можно
[01:11:33.280 --> 01:11:35.280]  завязать, но концепты.
[01:11:35.280 --> 01:11:37.280]  Но с 17 стандарта
[01:11:37.280 --> 01:11:39.280]  эта штука вообще плохо будет
[01:11:39.280 --> 01:11:41.280]  работать.
[01:11:41.280 --> 01:11:43.280]  Появилась вот такая
[01:11:43.280 --> 01:11:45.280]  штука. Возможно, вы про нее
[01:11:45.280 --> 01:11:47.280]  слышали.
[01:11:47.280 --> 01:11:49.280]  Называется No Unique Address.
[01:11:51.280 --> 01:11:53.280]  Вот тут упомянулось уже UBO.
[01:11:53.280 --> 01:11:55.280]  Это...
[01:11:55.280 --> 01:11:57.280]  Стоп, что?
[01:11:57.280 --> 01:11:59.280]  UBO?
[01:11:59.280 --> 01:12:01.280]  Андрей, при чем тут UBO было?
[01:12:01.280 --> 01:12:03.280]  Оно было к тому, что кажется
[01:12:03.280 --> 01:12:05.280]  я могу наспаунить там
[01:12:05.280 --> 01:12:07.280]  сотню базовых классов, которые
[01:12:07.280 --> 01:12:09.280]  займут 0 байт.
[01:12:09.280 --> 01:12:11.280]  Это EBCO называется?
[01:12:11.280 --> 01:12:13.280]  Ну я это называю EBO, типа empty
[01:12:13.280 --> 01:12:15.280]  base просто.
[01:12:15.280 --> 01:12:17.280]  UBO?
[01:12:17.280 --> 01:12:19.280]  Я сказал E, empty.
[01:12:19.280 --> 01:12:21.280]  А!
[01:12:21.280 --> 01:12:23.280]  А, EBO, все, я понял.
[01:12:23.280 --> 01:12:25.280]  Да, в общем,
[01:12:25.280 --> 01:12:27.280]  просто UBO это термин из компьютерной
[01:12:27.280 --> 01:12:29.280]  графики. У меня уже все...
[01:12:29.280 --> 01:12:31.280]  А что назначают?
[01:12:31.280 --> 01:12:33.280]  Uniform Buffer Object.
[01:12:33.280 --> 01:12:35.280]  Но не важно.
[01:12:35.280 --> 01:12:37.280]  Да, есть такая штука как empty
[01:12:37.280 --> 01:12:39.280]  base class optimization.
[01:12:39.280 --> 01:12:41.280]  Мы, кажется, говорили о ней.
[01:12:41.280 --> 01:12:43.280]  То бишь, что происходит?
[01:12:43.280 --> 01:12:45.280]  Если вы наследуете класс, у которого
[01:12:45.280 --> 01:12:47.280]  нет полей, то под него не выделяются
[01:12:47.280 --> 01:12:49.280]  байты. Вообще.
[01:12:49.280 --> 01:12:51.280]  А вот этот атрибут волшебный
[01:12:51.280 --> 01:12:53.280]  с 17 стандарта появившийся,
[01:12:53.280 --> 01:12:55.280]  он позволяет просто полю сказать,
[01:12:55.280 --> 01:12:57.280]  что у тебя может не быть уникального
[01:12:57.280 --> 01:12:59.280]  адреса.
[01:12:59.280 --> 01:13:01.280]  То есть так же, как у предка
[01:13:01.280 --> 01:13:03.280]  могло не быть уникального адреса, он занимал бы
[01:13:03.280 --> 01:13:05.280]  0 байт. Так же и поле теперь
[01:13:05.280 --> 01:13:07.280]  может занимать 0 байт.
[01:13:07.280 --> 01:13:09.280]  То есть размер
[01:13:09.280 --> 01:13:11.280]  этой всей структурки x будет
[01:13:11.280 --> 01:13:13.280]  4 на
[01:13:13.280 --> 01:13:15.280]  адекватных архитектурах.
[01:13:15.280 --> 01:13:17.280]  То бишь, таким же, как сайзы фонта.
[01:13:17.280 --> 01:13:19.280]  Ну и это ломается,
[01:13:19.280 --> 01:13:21.280]  если вы сверху оцениваете размер
[01:13:21.280 --> 01:13:23.280]  своего класса как
[01:13:25.280 --> 01:13:27.280]  сайзов.
[01:13:27.280 --> 01:13:29.280]  Так что да.
[01:13:29.280 --> 01:13:31.280]  Еще одно примечание.
[01:13:31.280 --> 01:13:33.280]  Вот если новый уник адрес отмести,
[01:13:33.280 --> 01:13:35.280]  то
[01:13:35.280 --> 01:13:37.280]  можно
[01:13:37.280 --> 01:13:39.280]  всю эту технологию
[01:13:39.280 --> 01:13:41.280]  бинпоиском делать.
[01:13:41.280 --> 01:13:43.280]  Почему она
[01:13:43.280 --> 01:13:45.280]  ломается снова уник адрес?
[01:13:45.280 --> 01:13:47.280]  У меня
[01:13:47.280 --> 01:13:49.280]  вылетело из головы.
[01:13:55.280 --> 01:13:57.280]  Нет, я не понимаю,
[01:13:57.280 --> 01:13:59.280]  почему она ломается. Мне кажется,
[01:13:59.280 --> 01:14:01.280]  можно и снова уник адресом тоже сделать
[01:14:01.280 --> 01:14:03.280]  залогариф. Но каким образом?
[01:14:03.280 --> 01:14:05.280]  Проверяем до 0,
[01:14:05.280 --> 01:14:07.280]  проверяем до единички.
[01:14:07.280 --> 01:14:09.280]  А дальше пытаемся увеличивать вдвое.
[01:14:09.280 --> 01:14:11.280]  То есть 2, 4, 8,
[01:14:11.280 --> 01:14:13.280]  16, пока не перестанет проходить.
[01:14:13.280 --> 01:14:15.280]  Потом получившись им травал,
[01:14:15.280 --> 01:14:17.280]  делим пополам.
[01:14:17.280 --> 01:14:19.280]  Это тоже будет работать залогариф.
[01:14:21.280 --> 01:14:23.280]  В двоичном подъеме такая технология
[01:14:23.280 --> 01:14:25.280]  используется, когда мы как бы не делим
[01:14:25.280 --> 01:14:27.280]  пополам, а пытаемся
[01:14:27.280 --> 01:14:29.280]  расти на степени двойки.
[01:14:31.280 --> 01:14:33.280]  Но подобные извращения
[01:14:33.280 --> 01:14:35.280]  в домашке, если хотите, напишите,
[01:14:35.280 --> 01:14:37.280]  но, по-моему, без этого сработает.
[01:14:39.280 --> 01:14:41.280]  Следующий пункт
[01:14:41.280 --> 01:14:43.280]  самый адский.
[01:14:43.280 --> 01:14:45.280]  Как вытащить типы болейки?
[01:14:49.280 --> 01:14:51.280]  Мы посмотрим на 4 решения.
[01:14:51.280 --> 01:14:53.280]  Хорошего среди них
[01:14:53.280 --> 01:14:55.280]  сразу говорить не будет.
[01:14:55.280 --> 01:14:57.280]  Все они в какой-то степени плохие.
[01:14:59.280 --> 01:15:01.280]  Так что надо выбирать то, которое
[01:15:01.280 --> 01:15:03.280]  вам в душе резонирует
[01:15:03.280 --> 01:15:05.280]  с вашим духом
[01:15:05.280 --> 01:15:07.280]  авантюризма.
[01:15:07.280 --> 01:15:09.280]  И вот первое, мне кажется,
[01:15:09.280 --> 01:15:11.280]  совсем плохое.
[01:15:11.280 --> 01:15:13.280]  Никому не рекомендую.
[01:15:13.280 --> 01:15:15.280]  Я даже половину информации о нем
[01:15:15.280 --> 01:15:17.280]  выкинул из лекции.
[01:15:17.280 --> 01:15:19.280]  Потому что совсем умыло.
[01:15:19.280 --> 01:15:21.280]  Я сам заснул, когда в прошлом году
[01:15:21.280 --> 01:15:23.280]  это рассказывалось.
[01:15:23.280 --> 01:15:25.280]  Но для справки.
[01:15:25.280 --> 01:15:27.280]  Вот мы написали UBIQ.
[01:15:29.280 --> 01:15:31.280]  Давайте даже реализуем
[01:15:31.280 --> 01:15:33.280]  этот метод.
[01:15:35.280 --> 01:15:37.280]  Когда мы внутри этого оператора
[01:15:37.280 --> 01:15:39.280]  кастом, мы знаем тип.
[01:15:39.280 --> 01:15:41.280]  Потому что он нам вывелся.
[01:15:41.280 --> 01:15:43.280]  Что если мы его
[01:15:43.280 --> 01:15:45.280]  как-то вытащим наружу?
[01:15:45.280 --> 01:15:47.280]  В принципе, все дальнейшие
[01:15:47.280 --> 01:15:49.280]  способы, кроме последнего,
[01:15:49.280 --> 01:15:51.280]  основаны на этой идее.
[01:15:51.280 --> 01:15:53.280]  Вопрос только в том, как вытаскивать тип наружу.
[01:15:53.280 --> 01:15:55.280]  Мы же не можем его в переменную засунуть.
[01:15:57.280 --> 01:15:59.280]  Ну, можем.
[01:15:59.280 --> 01:16:01.280]  Давайте организуем множество
[01:16:01.280 --> 01:16:03.280]  кострелей и научимся
[01:16:03.280 --> 01:16:05.280]  конвертировать любой тип в чиселка.
[01:16:07.280 --> 01:16:09.280]  И как это делать?
[01:16:09.280 --> 01:16:11.280]  Это вопрос, не имеющий
[01:16:11.280 --> 01:16:13.280]  однозначного ответа.
[01:16:13.280 --> 01:16:15.280]  Миллион вариантов придумано.
[01:16:15.280 --> 01:16:17.280]  Один другого хуже.
[01:16:17.280 --> 01:16:19.280]  Конечно, всем стандартным типом
[01:16:19.280 --> 01:16:21.280]  можно наплодить
[01:16:21.280 --> 01:16:23.280]  идентификаторов каким-нибудь
[01:16:23.280 --> 01:16:25.280]  macros.
[01:16:25.280 --> 01:16:27.280]  Можно даже сделать macros для
[01:16:27.280 --> 01:16:29.280]  регистрации пользовательских типов,
[01:16:29.280 --> 01:16:31.280]  которые тоже каким-то образом будут
[01:16:31.280 --> 01:16:33.280]  ID-шник выдавать, но не автоматом.
[01:16:33.280 --> 01:16:35.280]  А мы сами будем прописывать
[01:16:35.280 --> 01:16:37.280]  ID-шники, потом они начинают конфликтовать.
[01:16:37.280 --> 01:16:39.280]  Не расчеряем.
[01:16:39.280 --> 01:16:41.280]  Потом...
[01:16:41.280 --> 01:16:43.280]  Да.
[01:16:43.280 --> 01:16:45.280]  Но что делается?
[01:16:45.280 --> 01:16:47.280]  Пользовательские типы.
[01:16:47.280 --> 01:16:49.280]  Яна.
[01:16:49.280 --> 01:16:51.280]  Это тоже пользовательские типы,
[01:16:51.280 --> 01:16:53.280]  но они немножко отличаются.
[01:16:55.280 --> 01:16:57.280]  Самую главную проблему
[01:16:57.280 --> 01:16:59.280]  все-таки составляют указатели
[01:16:59.280 --> 01:17:01.280]  и CV-квалификаторы.
[01:17:01.280 --> 01:17:03.280]  Вот как вы будете отличать
[01:17:03.280 --> 01:17:05.280]  тип int от int-звездочка
[01:17:05.280 --> 01:17:07.280]  от int-2-звездочки
[01:17:07.280 --> 01:17:09.280]  от int-3-звездочки.
[01:17:09.280 --> 01:17:11.280]  И так далее до бесконечности.
[01:17:11.280 --> 01:17:13.280]  Ну а с интов не хватит.
[01:17:13.280 --> 01:17:15.280]  Очень неприятно.
[01:17:15.280 --> 01:17:17.280]  Количество типов экспоненциально
[01:17:17.280 --> 01:17:19.280]  растет на самом деле.
[01:17:19.280 --> 01:17:21.280]  И вот ответ
[01:17:21.280 --> 01:17:23.280]  костылять.
[01:17:23.280 --> 01:17:25.280]  И мне так не нравится костылять,
[01:17:25.280 --> 01:17:27.280]  что я про него даже не буду рассказывать
[01:17:27.280 --> 01:17:29.280]  подробно. Я покажу вот эту картинку.
[01:17:29.280 --> 01:17:31.280]  Нижние
[01:17:31.280 --> 01:17:33.280]  желтенькие байты.
[01:17:33.280 --> 01:17:35.280]  Картинка, кстати, из доклада
[01:17:35.280 --> 01:17:37.280]  Полухина, если я не ошибаюсь.
[01:17:37.280 --> 01:17:39.280]  Желтенькие байты зарезервированы
[01:17:39.280 --> 01:17:41.280]  под сам тип
[01:17:41.280 --> 01:17:43.280]  с правой стороны ID-шника,
[01:17:43.280 --> 01:17:45.280]  который 64 бита занимает.
[01:17:45.280 --> 01:17:47.280]  А с левой стороны ID-шника
[01:17:47.280 --> 01:17:49.280]  биты идут тройками.
[01:17:49.280 --> 01:17:51.280]  Каждые тройки
[01:17:51.280 --> 01:17:53.280]  биты соответственно обозначают
[01:17:53.280 --> 01:17:55.280]  навешен ли конст,
[01:17:55.280 --> 01:17:57.280]  навешен ли указатель,
[01:17:57.280 --> 01:17:59.280]  навешен ли вола тайл.
[01:17:59.280 --> 01:18:01.280]  И эти тройки могут
[01:18:01.280 --> 01:18:03.280]  идти сколько угодно,
[01:18:03.280 --> 01:18:05.280]  ну, вернее, сколько влезет.
[01:18:05.280 --> 01:18:07.280]  Заметьте, пользовательские типы здесь
[01:18:07.280 --> 01:18:09.280]  на самом деле не поддерживаются.
[01:18:09.280 --> 01:18:11.280]  То есть
[01:18:11.280 --> 01:18:13.280]  вот эти пять битиков
[01:18:13.280 --> 01:18:15.280]  это только на встроенные типы.
[01:18:17.280 --> 01:18:19.280]  Можно расширить для пользовательских,
[01:18:19.280 --> 01:18:21.280]  но все равно это все-таки костыли,
[01:18:21.280 --> 01:18:23.280]  мне это так сильно нравится.
[01:18:23.280 --> 01:18:25.280]  Ну, чтобы чуть лучше понять,
[01:18:25.280 --> 01:18:27.280]  все-таки посмотрим внимательно
[01:18:27.280 --> 01:18:29.280]  на этот пункт.
[01:18:29.280 --> 01:18:31.280]  Там подряд идет
[01:18:31.280 --> 01:18:33.280]  0.1.0, троечка,
[01:18:33.280 --> 01:18:35.280]  а потом 0.0.1.
[01:18:35.280 --> 01:18:37.280]  И почему
[01:18:37.280 --> 01:18:39.280]  так?
[01:18:39.280 --> 01:18:41.280]  Вот красное
[01:18:41.280 --> 01:18:43.280]  оно относится к самому внешнему
[01:18:43.280 --> 01:18:45.280]  указателю,
[01:18:45.280 --> 01:18:47.280]  на который
[01:18:47.280 --> 01:18:49.280]  не навешен конст на самом деле.
[01:18:49.280 --> 01:18:51.280]  Потому что конст, который
[01:18:51.280 --> 01:18:53.280]  слева указан, он, как вы знаете,
[01:18:53.280 --> 01:18:55.280]  на самом деле относится к самому
[01:18:55.280 --> 01:18:57.280]  шарту.
[01:18:57.280 --> 01:18:59.280]  То есть это указатель
[01:18:59.280 --> 01:19:01.280]  на указатель на конст-шорт.
[01:19:01.280 --> 01:19:03.280]  И
[01:19:03.280 --> 01:19:05.280]  вот это
[01:19:05.280 --> 01:19:07.280]  мне даже кажется, здесь неправильно указано.
[01:19:11.280 --> 01:19:13.280]  Нет, кажется, идея в том, что
[01:19:13.280 --> 01:19:15.280]  единичка
[01:19:15.280 --> 01:19:17.280]  означает просто указатель,
[01:19:17.280 --> 01:19:19.280]  1.0 означает указатель
[01:19:19.280 --> 01:19:21.280]  на конст,
[01:19:21.280 --> 01:19:23.280]  0.1.1
[01:19:23.280 --> 01:19:25.280]  означает,
[01:19:25.280 --> 01:19:27.280]  видимо,
[01:19:27.280 --> 01:19:29.280]  указатель на волота,
[01:19:29.280 --> 01:19:31.280]  1.0.0 указатель на конст волота.
[01:19:31.280 --> 01:19:33.280]  Еще сюда ссылки можно
[01:19:33.280 --> 01:19:35.280]  приобрести.
[01:19:35.280 --> 01:19:37.280]  Еще вопрос, а как квалифицировать сами указатели?
[01:19:37.280 --> 01:19:39.280]  Добавив еще один блок.
[01:19:39.280 --> 01:19:41.280]  Хотя, да, видимо, они квалифицируются
[01:19:41.280 --> 01:19:43.280]  на конст волота. Они следующим блоком квалифицируются.
[01:19:43.280 --> 01:19:45.280]  В общем,
[01:19:45.280 --> 01:19:47.280]  эту идею можно добить до ума
[01:19:47.280 --> 01:19:49.280]  в некоторых системах
[01:19:49.280 --> 01:19:51.280]  промышленных. Это даже доводилось
[01:19:51.280 --> 01:19:53.280]  до ума и использовалось прямо.
[01:19:53.280 --> 01:19:55.280]  Но мне это так не нравится,
[01:19:55.280 --> 01:19:57.280]  что я вам не рекомендую податься в домашки
[01:19:57.280 --> 01:19:59.280]  и это написать.
[01:19:59.280 --> 01:20:01.280]  Так вот, прос.
[01:20:01.280 --> 01:20:03.280]  Это просто работает, хоть что-то,
[01:20:03.280 --> 01:20:05.280]  хоть как-то вытащили.
[01:20:05.280 --> 01:20:07.280]  Соответственно, дальше нам еще обратно
[01:20:07.280 --> 01:20:09.280]  нужно научиться конвертировать
[01:20:09.280 --> 01:20:11.280]  число в тип
[01:20:11.280 --> 01:20:13.280]  тоже костылями и ефами.
[01:20:13.280 --> 01:20:15.280]  Конст текст про ефами,
[01:20:15.280 --> 01:20:17.280]  прошу за мисс.
[01:20:17.280 --> 01:20:19.280]  Но, да,
[01:20:19.280 --> 01:20:21.280]  недостатков полно.
[01:20:21.280 --> 01:20:23.280]  Тут почти ничего не поддерживается,
[01:20:23.280 --> 01:20:25.280]  полная боль. Так что давайте следующий способ.
[01:20:25.280 --> 01:20:27.280]  Это такое
[01:20:27.280 --> 01:20:29.280]  реактивное решение
[01:20:29.280 --> 01:20:31.280]  немножко.
[01:20:31.280 --> 01:20:33.280]  Вот мы знаем здесь тип, да,
[01:20:33.280 --> 01:20:35.280]  но мы его не можем
[01:20:35.280 --> 01:20:37.280]  вернуть. Это, надеюсь, еще в прошлый раз
[01:20:37.280 --> 01:20:39.280]  все поняли, да, что мы как бы
[01:20:41.280 --> 01:20:43.280]  так как мы эти юбики
[01:20:43.280 --> 01:20:45.280]  засовываем в конструктор дэшки,
[01:20:45.280 --> 01:20:47.280]  ничего вернуть из этой функции напрямую
[01:20:47.280 --> 01:20:49.280]  не можем.
[01:20:49.280 --> 01:20:51.280]  Ну, подобные проблемы
[01:20:51.280 --> 01:20:53.280]  еще возникают, когда мы какой-нибудь
[01:20:53.280 --> 01:20:55.280]  асинхронный код пишем.
[01:20:55.280 --> 01:20:57.280]  И там была идея такая,
[01:20:57.280 --> 01:20:59.280]  давайте не возвращать наружу
[01:20:59.280 --> 01:21:01.280]  через возвращаемое значение,
[01:21:01.280 --> 01:21:03.280]  а колбэк использовать.
[01:21:05.280 --> 01:21:07.280]  То же самое.
[01:21:07.280 --> 01:21:09.280]  Мы постараемся
[01:21:09.280 --> 01:21:11.280]  сюда затолкать колбэк,
[01:21:11.280 --> 01:21:13.280]  но будет это все
[01:21:13.280 --> 01:21:15.280]  сделано, конечно, очень
[01:21:15.280 --> 01:21:17.280]  неудобно,
[01:21:17.280 --> 01:21:19.280]  потому что нам нужно
[01:21:19.280 --> 01:21:21.280]  будет накопить
[01:21:21.280 --> 01:21:23.280]  каким-то образом
[01:21:23.280 --> 01:21:25.280]  пак из всех этих типов,
[01:21:25.280 --> 01:21:27.280]  которые пришли в разные юбики.
[01:21:29.280 --> 01:21:31.280]  Соответственно,
[01:21:31.280 --> 01:21:33.280]  теперь юбик еще и принимает
[01:21:33.280 --> 01:21:35.280]  пак, и
[01:21:35.280 --> 01:21:37.280]  каждый следующий
[01:21:37.280 --> 01:21:39.280]  юбик
[01:21:39.280 --> 01:21:41.280]  он должен будет взять у предыдущего
[01:21:41.280 --> 01:21:43.280]  юбика этот элемент каким-то
[01:21:43.280 --> 01:21:45.280]  образом
[01:21:45.280 --> 01:21:47.280]  и засунуть свой.
[01:21:47.280 --> 01:21:49.280]  Давайте внимательно
[01:21:49.280 --> 01:21:51.280]  на это посмотрим.
[01:21:53.280 --> 01:21:55.280]  То есть как бы раньше
[01:21:55.280 --> 01:21:57.280]  мы все юбики сразу впихивали,
[01:21:59.280 --> 01:22:01.280]  а теперь мы как бы будем
[01:22:01.280 --> 01:22:03.280]  ну, вернее, уже
[01:22:03.280 --> 01:22:05.280]  найдя размер структурки,
[01:22:05.280 --> 01:22:07.280]  мы будем эти
[01:22:07.280 --> 01:22:09.280]  юбики сначала
[01:22:09.280 --> 01:22:11.280]  как бы
[01:22:11.280 --> 01:22:13.280]  будет второй проход
[01:22:13.280 --> 01:22:15.280]  от нуля длины
[01:22:15.280 --> 01:22:17.280]  до n, и в этом
[01:22:17.280 --> 01:22:19.280]  втором проходе мы будем каждый раз
[01:22:19.280 --> 01:22:21.280]  накапливать
[01:22:21.280 --> 01:22:23.280]  типы.
[01:22:23.280 --> 01:22:25.280]  Причем этот второй проход идет рекурсивно.
[01:22:25.280 --> 01:22:27.280]  Мы изначально запускаемся
[01:22:27.280 --> 01:22:29.280]  от только одного аргумента
[01:22:31.280 --> 01:22:33.280]  соответственно
[01:22:33.280 --> 01:22:35.280]  t от юбик-констрактора
[01:22:35.280 --> 01:22:37.280]  одного.
[01:22:37.280 --> 01:22:39.280]  То есть он внутри себя
[01:22:39.280 --> 01:22:41.280]  уже знает первый тип
[01:22:41.280 --> 01:22:43.280]  и запустит опять рекурсивно
[01:22:43.280 --> 01:22:45.280]  foreach field and depth
[01:22:45.280 --> 01:22:47.280]  уже с одним известным типом.
[01:22:47.280 --> 01:22:49.280]  Теперь мы запустимся от двух юбиков.
[01:22:49.280 --> 01:22:51.280]  И вот второй из юбиков
[01:22:51.280 --> 01:22:53.280]  нас запустит
[01:22:53.280 --> 01:22:55.280]  с соответствующим
[01:22:55.280 --> 01:22:57.280]  вторым типом.
[01:22:57.280 --> 01:22:59.280]  То есть
[01:22:59.280 --> 01:23:01.280]  во втором аргументе,
[01:23:01.280 --> 01:23:03.280]  втором юбике уже будет известен второй тип
[01:23:03.280 --> 01:23:05.280]  и мы запустим foreach
[01:23:05.280 --> 01:23:07.280]  уже от двух типов.
[01:23:07.280 --> 01:23:09.280]  Надеюсь, эта идея ясна.
[01:23:13.280 --> 01:23:15.280]  Спросите вопрос. Мне кажется, она не очень ясна.
[01:23:15.280 --> 01:23:17.280]  Возможно, вам нужно посмотреть
[01:23:17.280 --> 01:23:19.280]  этот код, а мне помолчать.
[01:23:35.280 --> 01:23:37.280]  А как мы поймем, что у нас все конец?
[01:23:37.280 --> 01:23:39.280]  Мы все нужные типы ставили.
[01:23:39.280 --> 01:23:41.280]  У нас что-то рекурсивно вызывается
[01:23:41.280 --> 01:23:43.280]  foreach field.
[01:23:43.280 --> 01:23:45.280]  Ну да, этот момент здесь упущен.
[01:23:45.280 --> 01:23:47.280]  Но его надо дописать.
[01:23:47.280 --> 01:23:49.280]  Но мы до этого еще можем
[01:23:49.280 --> 01:23:51.280]  с помощью юбиков найти количество полей
[01:23:51.280 --> 01:23:53.280]  и соответственно
[01:23:53.280 --> 01:23:55.280]  ровно столько запустить
[01:23:55.280 --> 01:23:57.280]  по глубине, сколько мы можем
[01:23:57.280 --> 01:23:59.280]  запустить по глубине, сколько мы можем
[01:23:59.280 --> 01:24:01.280]  запустить по глубине, сколько мы можем
[01:24:01.280 --> 01:24:03.280]  запустить по глубине.
[01:24:03.280 --> 01:24:05.280]  Сколько запустить по глубине, сколько нужно.
[01:24:07.280 --> 01:24:09.280]  Еще мы можем сравнить
[01:24:09.280 --> 01:24:11.280]  sizeOfTypes
[01:24:11.280 --> 01:24:13.280]  с sizeOfE.
[01:24:13.280 --> 01:24:15.280]  Собственно,
[01:24:15.280 --> 01:24:17.280]  по-моему, это дальше по
[01:24:17.280 --> 01:24:19.280]  слайдам даже делается, если их не вырезал.
[01:24:21.280 --> 01:24:23.280]  Да, мы добавим перегрузку.
[01:24:25.280 --> 01:24:27.280]  В тот момент,
[01:24:27.280 --> 01:24:29.280]  когда sizeOfTypes станет таким же,
[01:24:29.280 --> 01:24:31.280]  как количество полей,
[01:24:31.280 --> 01:24:33.280]  которые мы до этого узнали,
[01:24:33.280 --> 01:24:35.280]  которые мы до этого узнали,
[01:24:35.280 --> 01:24:37.280]  мы запустим калбэк.
[01:24:39.280 --> 01:24:41.280]  Ну да, тут
[01:24:41.280 --> 01:24:43.280]  была попытка продемонстрировать,
[01:24:43.280 --> 01:24:45.280]  что ретерном ничего никуда вернуть не выйдет,
[01:24:45.280 --> 01:24:47.280]  мы обратно из всей этой глубокой
[01:24:47.280 --> 01:24:49.280]  рекурсии полетим
[01:24:49.280 --> 01:24:51.280]  и ни к чему хорошему не придем.
[01:24:51.280 --> 01:24:53.280]  Зато
[01:24:53.280 --> 01:24:55.280]  калбэк мы вызвать можем.
[01:24:55.280 --> 01:24:57.280]  И калбэк будет
[01:24:57.280 --> 01:24:59.280]  тоже шаблонный compile time.
[01:25:01.280 --> 01:25:03.280]  Да, все, весь этот код,
[01:25:03.280 --> 01:25:05.280]  что здесь написан, нужно какой-нибудь текст пропометить
[01:25:05.280 --> 01:25:07.280]  по-хорошему.
[01:25:09.280 --> 01:25:11.280]  Ну да, все типы узнали,
[01:25:11.280 --> 01:25:13.280]  их столько, сколько нужно,
[01:25:13.280 --> 01:25:15.280]  мы их можем в калбэк засунуть,
[01:25:15.280 --> 01:25:17.280]  а в итоге
[01:25:17.280 --> 01:25:19.280]  запускать это вот как-то так
[01:25:19.280 --> 01:25:21.280]  из внешнего кода.
[01:25:23.280 --> 01:25:25.280]  Пихаем forest-field-meistract
[01:25:25.280 --> 01:25:27.280]  и пихаем лямбду.
[01:25:27.280 --> 01:25:29.280]  Лямбда шаблонная,
[01:25:29.280 --> 01:25:31.280]  и в types нам придут в итоге
[01:25:31.280 --> 01:25:33.280]  список типов, которые есть
[01:25:33.280 --> 01:25:35.280]  в структурке.
[01:25:35.280 --> 01:25:37.280]  Мы их можем напечатать,
[01:25:39.280 --> 01:25:41.280]  ну и примерно больше ничего с ними не можем сделать.
[01:25:43.280 --> 01:25:45.280]  То есть это как бы не решение проблемы,
[01:25:45.280 --> 01:25:47.280]  мы до сих пор не смогли вытащить
[01:25:47.280 --> 01:25:49.280]  из юбика тип,
[01:25:49.280 --> 01:25:51.280]  мы просто
[01:25:51.280 --> 01:25:53.280]  позволили дописать еще немного
[01:25:53.280 --> 01:25:55.280]  кода в итоге к этим всем юбикам.
[01:25:55.280 --> 01:25:57.280]  Иногда этого хватает,
[01:25:57.280 --> 01:25:59.280]  то есть это не самое плохое решение,
[01:26:01.280 --> 01:26:03.280]  но хочется большего.
[01:26:05.280 --> 01:26:07.280]  Хочется большего.
[01:26:09.280 --> 01:26:11.280]  Да, прос мы поддерживаем
[01:26:11.280 --> 01:26:13.280]  на самом деле все типы.
[01:26:13.280 --> 01:26:15.280]  Вот эта технология,
[01:26:15.280 --> 01:26:17.280]  ей без разницы какие типы
[01:26:17.280 --> 01:26:19.280]  в структурке.
[01:26:19.280 --> 01:26:21.280]  Виктора, стринги, все поддерживается,
[01:26:21.280 --> 01:26:23.280]  все замечательно.
[01:26:25.280 --> 01:26:27.280]  И даже другие структурки.
[01:26:27.280 --> 01:26:29.280]  Вообще все.
[01:26:31.280 --> 01:26:33.280]  Но мы не можем вытащить результат.
[01:26:35.280 --> 01:26:37.280]  Еще одна большая
[01:26:37.280 --> 01:26:39.280]  проблема,
[01:26:39.280 --> 01:26:41.280]  это то, что эта штука работает за квадрат инстанциации.
[01:26:45.280 --> 01:26:47.280]  То есть нам нужно
[01:26:47.280 --> 01:26:49.280]  проинстанцировать все
[01:26:49.280 --> 01:26:51.280]  для всех длин
[01:26:51.280 --> 01:26:53.280]  типов от одного до
[01:26:53.280 --> 01:26:55.280]  два.
[01:26:55.280 --> 01:26:57.280]  Как мы знаем, это квадрат.
[01:26:57.280 --> 01:26:59.280]  И это может работать действительно долго.
[01:26:59.280 --> 01:27:01.280]  Рома, насчет инстанцирования.
[01:27:01.280 --> 01:27:03.280]  Да.
[01:27:03.280 --> 01:27:05.280]  А верно ли, что у нас самый первый юбик
[01:27:05.280 --> 01:27:07.280]  постоянно будет к списку
[01:27:07.280 --> 01:27:09.280]  дописывать поле первого,
[01:27:09.280 --> 01:27:11.280]  ну, к своему списку будет дописывать
[01:27:11.280 --> 01:27:13.280]  тип первого поля?
[01:27:15.280 --> 01:27:17.280]  Первый раз инстанцировать?
[01:27:17.280 --> 01:27:19.280]  Да, да, я тоже эту проблему тут заменил.
[01:27:19.280 --> 01:27:21.280]  И вот что-то тут вообще наэкспоненциальный
[01:27:21.280 --> 01:27:23.280]  прикол смахивает какой-то.
[01:27:23.280 --> 01:27:25.280]  Да, надо тут это обрубить.
[01:27:25.280 --> 01:27:27.280]  Я думаю, здесь это неопробленно,
[01:27:27.280 --> 01:27:29.280]  потому что на слайды не влезло.
[01:27:29.280 --> 01:27:31.280]  Дописывать я поленился,
[01:27:31.280 --> 01:27:33.280]  если честно.
[01:27:33.280 --> 01:27:35.280]  Ну и опять же слайд был бы гораздо больший и страшнее.
[01:27:35.280 --> 01:27:37.280]  То есть вот здесь необходимо
[01:27:37.280 --> 01:27:39.280]  для всех, кроме последнего аргумента,
[01:27:39.280 --> 01:27:41.280]  каким-то образом им сказать,
[01:27:41.280 --> 01:27:43.280]  не запускай дальше рекурсию.
[01:27:43.280 --> 01:27:45.280]  Ну, то бишь,
[01:27:45.280 --> 01:27:47.280]  если и
[01:27:47.280 --> 01:27:49.280]  нумируются
[01:27:49.280 --> 01:27:51.280]  от 0 до n,
[01:27:51.280 --> 01:27:53.280]  то...
[01:27:55.280 --> 01:27:57.280]  Ну, в общем, это неудобно.
[01:27:57.280 --> 01:27:59.280]  А, ну, там вы не делали сайзовом параметру парка?
[01:27:59.280 --> 01:28:01.280]  Да, нет, это неудобно.
[01:28:01.280 --> 01:28:03.280]  Нам нужно все равно таскать за собой.
[01:28:05.280 --> 01:28:07.280]  Ну, как бы,
[01:28:07.280 --> 01:28:09.280]  это неудобно.
[01:28:09.280 --> 01:28:11.280]  А...
[01:28:11.280 --> 01:28:13.280]  Ну, как бы...
[01:28:13.280 --> 01:28:15.280]  Да, нам нужно сделать,
[01:28:15.280 --> 01:28:17.280]  чтобы и был от 0 до
[01:28:17.280 --> 01:28:19.280]  сайзового параметра пака,
[01:28:19.280 --> 01:28:21.280]  а дальше в юбик еще как-то передать...
[01:28:21.280 --> 01:28:23.280]  А, ему и так параметр пака...
[01:28:23.280 --> 01:28:25.280]  Дальше что-то даем?
[01:28:25.280 --> 01:28:27.280]  Да, то есть нужно сравнить и с сайзовым параметром пака.
[01:28:27.280 --> 01:28:29.280]  Ты прав.
[01:28:29.280 --> 01:28:31.280]  Ну, в общем, да.
[01:28:31.280 --> 01:28:33.280]  Это доделывается,
[01:28:33.280 --> 01:28:35.280]  и, в принципе, работает.
[01:28:35.280 --> 01:28:37.280]  Но за квадрат.
[01:28:37.280 --> 01:28:39.280]  А вот дальше будет круто.
[01:28:41.280 --> 01:28:43.280]  Что же там может быть словом
[01:28:43.280 --> 01:28:45.280]  «аркейн» помечено?
[01:28:45.280 --> 01:28:47.280]  Даже не знаю.
[01:28:47.280 --> 01:28:49.280]  Так.
[01:28:49.280 --> 01:28:51.280]  Ты не спылиришь.
[01:28:51.280 --> 01:28:53.280]  Я все не спылиришь.
[01:28:53.280 --> 01:28:55.280]  Возможно, кого-то ждет Катарсис.
[01:28:55.280 --> 01:28:57.280]  Вопрос.
[01:28:57.280 --> 01:28:59.280]  Всегда ли
[01:28:59.280 --> 01:29:01.280]  верен этот статик ассорт?
[01:29:01.280 --> 01:29:03.280]  Да.
[01:29:03.280 --> 01:29:05.280]  Почему так не верен?
[01:29:05.280 --> 01:29:07.280]  Тут угловые скобки нужны.
[01:29:07.280 --> 01:29:09.280]  Ну ладно.
[01:29:09.280 --> 01:29:11.280]  Ну это да.
[01:29:11.280 --> 01:29:13.280]  Я копирую некоторые слайды
[01:29:13.280 --> 01:29:15.280]  с прошлого года.
[01:29:15.280 --> 01:29:17.280]  Половина.
[01:29:17.280 --> 01:29:19.280]  Так что ошибки тоже остаются.
[01:29:21.280 --> 01:29:23.280]  Ну, хотелось бы, что
[01:29:23.280 --> 01:29:25.280]  я бы сказал, что
[01:29:25.280 --> 01:29:27.280]  у нас есть
[01:29:27.280 --> 01:29:29.280]  очень много
[01:29:29.280 --> 01:29:31.280]  ну, хотелось бы, что
[01:29:31.280 --> 01:29:33.280]  да, очень хотелось бы,
[01:29:33.280 --> 01:29:35.280]  если бы мир был
[01:29:35.280 --> 01:29:37.280]  так добрый к нам.
[01:29:37.280 --> 01:29:39.280]  А вот так.
[01:29:39.280 --> 01:29:41.280]  Нет.
[01:29:41.280 --> 01:29:43.280]  А тут нет. Почему?
[01:29:43.280 --> 01:29:45.280]  Может, даже оператор быть
[01:29:45.280 --> 01:29:47.280]  неопределен. Что-что?
[01:29:47.280 --> 01:29:49.280]  Оператор может даже быть
[01:29:49.280 --> 01:29:51.280]  неопределен.
[01:29:51.280 --> 01:29:53.280]  Ну да, но давайте считать,
[01:29:53.280 --> 01:29:55.280]  что все-таки это адекватное равенство.
[01:29:59.280 --> 01:30:01.280]  Ну тогда, если это адекватное,
[01:30:01.280 --> 01:30:03.280]  то по определению должно быть.
[01:30:03.280 --> 01:30:05.280]  Ну, что значит
[01:30:05.280 --> 01:30:07.280]  глобальная функция?
[01:30:11.280 --> 01:30:13.280]  В constexpr функциях нельзя
[01:30:13.280 --> 01:30:15.280]  использовать глобальные переменные.
[01:30:15.280 --> 01:30:17.280]  Да, заметьте, там и тут
[01:30:17.280 --> 01:30:19.280]  constexpr.
[01:30:19.280 --> 01:30:21.280]  И статические переменные тоже в constexpr
[01:30:21.280 --> 01:30:23.280]  функциях вроде как писать нельзя.
[01:30:23.280 --> 01:30:25.280]  Хотелось бы, чтобы
[01:30:25.280 --> 01:30:27.280]  это было всегда так.
[01:30:27.280 --> 01:30:29.280]  Ведь все, что у нас до сих пор
[01:30:29.280 --> 01:30:31.280]  было в compile-тайме,
[01:30:31.280 --> 01:30:33.280]  оно работает
[01:30:33.280 --> 01:30:35.280]  как в математике, как в функпрове.
[01:30:35.280 --> 01:30:37.280]  Очень декларативно.
[01:30:37.280 --> 01:30:39.280]  Вы объявили что-то, это оно всегда такое.
[01:30:39.280 --> 01:30:41.280]  Имутабельно.
[01:30:41.280 --> 01:30:43.280]  Но никогда не меняется, и все нормально.
[01:30:43.280 --> 01:30:45.280]  Reference transparency
[01:30:45.280 --> 01:30:47.280]  есть такое понятие.
[01:30:49.280 --> 01:30:51.280]  Неважно, по какой ссылке вы
[01:30:51.280 --> 01:30:53.280]  обращаетесь к значению,
[01:30:53.280 --> 01:30:55.280]  оно всегда одно и то же.
[01:30:55.280 --> 01:30:57.280]  Что-то вроде того.
[01:30:57.280 --> 01:30:59.280]  Если честно, уже не помню
[01:30:59.280 --> 01:31:01.280]  правильную формулировку.
[01:31:01.280 --> 01:31:03.280]  Но суть ясна. Все имутабельное,
[01:31:03.280 --> 01:31:05.280]  есть только значение, никаких переменных.
[01:31:07.280 --> 01:31:09.280]  Но вот оказывается, что все это...
[01:31:11.280 --> 01:31:13.280]  А, еще вот такой пример.
[01:31:15.280 --> 01:31:17.280]  То есть мы даже никакие функции
[01:31:17.280 --> 01:31:19.280]  не вызывали.
[01:31:19.280 --> 01:31:21.280]  Вот объявили две переменные.
[01:31:21.280 --> 01:31:23.280]  Одного и того же типа.
[01:31:23.280 --> 01:31:25.280]  Да? Будет ли у них одинаковый тип?
[01:31:31.280 --> 01:31:33.280]  Может и будет, а может и нет.
[01:31:33.280 --> 01:31:35.280]  Ну, хотелось бы.
[01:31:35.280 --> 01:31:37.280]  Но ответ на все три
[01:31:37.280 --> 01:31:39.280]  вопроса нет.
[01:31:39.280 --> 01:31:41.280]  Вы что, думали, в сказку попали?
[01:31:41.280 --> 01:31:43.280]  С оговоркой, что только
[01:31:43.280 --> 01:31:45.280]  в современном.
[01:31:49.280 --> 01:31:51.280]  Мы сделаем вот так.
[01:31:59.280 --> 01:32:01.280]  Надо потупить
[01:32:01.280 --> 01:32:03.280]  и понять, что происходит.
[01:32:03.280 --> 01:32:05.280]  Первая структура.
[01:32:05.280 --> 01:32:07.280]  У нее есть два шаблонных
[01:32:07.280 --> 01:32:09.280]  аргумента. Первый, который ни на что
[01:32:09.280 --> 01:32:11.280]  не влияет. И второй,
[01:32:11.280 --> 01:32:13.280]  не типовой,
[01:32:13.280 --> 01:32:15.280]  который равен
[01:32:15.280 --> 01:32:17.280]  дефолту.
[01:32:19.280 --> 01:32:21.280]  Но
[01:32:21.280 --> 01:32:23.280]  каждая лямбда
[01:32:23.280 --> 01:32:25.280]  имеет уникальный тип
[01:32:25.280 --> 01:32:27.280]  и уникальное значение.
[01:32:27.280 --> 01:32:29.280]  Каждая лямбда, вообще любая.
[01:32:31.280 --> 01:32:33.280]  И при инстанциации
[01:32:33.280 --> 01:32:35.280]  этого класса
[01:32:37.280 --> 01:32:39.280]  считается, что вот этот дефолтный
[01:32:39.280 --> 01:32:41.280]  аргумент объявлен там, где происходит
[01:32:41.280 --> 01:32:43.280]  инстанциация.
[01:32:43.280 --> 01:32:45.280]  То есть при разных инстанциациях
[01:32:45.280 --> 01:32:47.280]  будут разные лямбды.
[01:32:47.280 --> 01:32:49.280]  Даже более того,
[01:32:49.280 --> 01:32:51.280]  если вы один и тот же первый аргумент
[01:32:51.280 --> 01:32:53.280]  подставите,
[01:32:53.280 --> 01:32:55.280]  int и int, как было в прошлых примерах,
[01:32:55.280 --> 01:32:57.280]  все равно оно
[01:32:57.280 --> 01:32:59.280]  будет заново инстанцировать этот класс,
[01:32:59.280 --> 01:33:01.280]  считая, что опа, второй аргумент
[01:33:01.280 --> 01:33:03.280]  отличается, потому что это новая лямбда.
[01:33:05.280 --> 01:33:07.280]  Да, это работает вот так вот странно.
[01:33:09.280 --> 01:33:11.280]  Ну и во втором
[01:33:11.280 --> 01:33:13.280]  примере тоже понятно, что происходит.
[01:33:13.280 --> 01:33:15.280]  Каждый раз, когда мы вызываем
[01:33:15.280 --> 01:33:17.280]  эту функцию в любом виде,
[01:33:17.280 --> 01:33:19.280]  это будет новая инстанциация шаблона,
[01:33:21.280 --> 01:33:23.280]  которая будет возвращать
[01:33:23.280 --> 01:33:25.280]  новое уникальное значение.
[01:33:27.280 --> 01:33:29.280]  Магия.
[01:33:31.280 --> 01:33:33.280]  Так вот, как это относится
[01:33:33.280 --> 01:33:35.280]  к нашему делу?
[01:33:35.280 --> 01:33:37.280]  Мы хотим вытащить тип.
[01:33:39.280 --> 01:33:41.280]  Давайте познакомимся
[01:33:41.280 --> 01:33:43.280]  с дефектом стандарта
[01:33:43.280 --> 01:33:45.280]  номер 2118.
[01:33:47.280 --> 01:33:49.280]  Я не знаю, точно ли в стандарте было 2117
[01:33:49.280 --> 01:33:51.280]  дефектов до этого,
[01:33:51.280 --> 01:33:53.280]  но размер
[01:33:53.280 --> 01:33:55.280]  числа впечатляет.
[01:33:57.280 --> 01:33:59.280]  Вот такой код есть.
[01:34:01.280 --> 01:34:03.280]  Уже когда с порцияртоп
[01:34:03.280 --> 01:34:05.280]  упоминали,
[01:34:05.280 --> 01:34:07.280]  что френдов можно писать
[01:34:07.280 --> 01:34:09.280]  в классах
[01:34:09.280 --> 01:34:11.280]  и даже объявлять.
[01:34:11.280 --> 01:34:13.280]  Вот так написали,
[01:34:13.280 --> 01:34:15.280]  и больше ничего не написали.
[01:34:15.280 --> 01:34:17.280]  Что это будет?
[01:34:17.280 --> 01:34:19.280]  Конечно же, это будет ошибка компиляции.
[01:34:19.280 --> 01:34:21.280]  Лобхол не объявлен.
[01:34:23.280 --> 01:34:25.280]  То, что мы написали в его френдом
[01:34:25.280 --> 01:34:27.280]  для тега,
[01:34:27.280 --> 01:34:29.280]  означает, что в внешнем скопе
[01:34:29.280 --> 01:34:31.280]  произошла
[01:34:31.280 --> 01:34:33.280]  декларация лобхола.
[01:34:33.280 --> 01:34:35.280]  Но диффинишена нет.
[01:34:35.280 --> 01:34:37.280]  Поэтому извините.
[01:34:37.280 --> 01:34:39.280]  Компайл Aurora.
[01:34:41.280 --> 01:34:43.280]  Но тут есть
[01:34:43.280 --> 01:34:45.280]  детали.
[01:34:47.280 --> 01:34:49.280]  Давайте даже пока сюда
[01:34:49.280 --> 01:34:51.280]  посмотрим.
[01:34:51.280 --> 01:34:53.280]  Лобхол возвращает
[01:34:53.280 --> 01:34:55.280]  авто.
[01:34:55.280 --> 01:34:57.280]  А если вы помните
[01:34:57.280 --> 01:34:59.280]  предыдущие разговоры,
[01:34:59.280 --> 01:35:01.280]  как только мы возвращаем авто,
[01:35:01.280 --> 01:35:03.280]  декларация
[01:35:03.280 --> 01:35:05.280]  как бы декларацией для функции
[01:35:05.280 --> 01:35:07.280]  не считается.
[01:35:07.280 --> 01:35:09.280]  Потому что мы всю сигнатуру функции
[01:35:09.280 --> 01:35:11.280]  не описали.
[01:35:11.280 --> 01:35:13.280]  Мы сказали, что
[01:35:13.280 --> 01:35:15.280]  а вы, види мне, сигнатуру из тела.
[01:35:15.280 --> 01:35:17.280]  В шаблонах это удобно.
[01:35:21.280 --> 01:35:23.280]  Что делает
[01:35:23.280 --> 01:35:25.280]  френд авто лобхол?
[01:35:25.280 --> 01:35:27.280]  Непонятно.
[01:35:27.280 --> 01:35:29.280]  Он как бы делает декларацию
[01:35:29.280 --> 01:35:31.280]  во внешнем скопе,
[01:35:31.280 --> 01:35:33.280]  но как бы ее не делает,
[01:35:33.280 --> 01:35:35.280]  авто не позволяет
[01:35:35.280 --> 01:35:37.280]  декларировать.
[01:35:37.280 --> 01:35:39.280]  А теперь мы добавляем вот это.
[01:35:39.280 --> 01:35:41.280]  И тут
[01:35:41.280 --> 01:35:43.280]  мы сделали
[01:35:43.280 --> 01:35:45.280]  френда лобхол,
[01:35:45.280 --> 01:35:47.280]  но еще и определили его.
[01:35:47.280 --> 01:35:49.280]  Да, в ЦРТП мы так делали.
[01:35:49.280 --> 01:35:51.280]  И собственно с оператором Spaceship
[01:35:51.280 --> 01:35:53.280]  также делали.
[01:35:53.280 --> 01:35:55.280]  Определяют френда внутри класса.
[01:35:55.280 --> 01:35:57.280]  Он попадает во внешний скоп,
[01:35:57.280 --> 01:35:59.280]  с помощью ADL находится.
[01:35:59.280 --> 01:36:01.280]  Никого не шокируют текущие слова.
[01:36:01.280 --> 01:36:03.280]  Правда, если шокируют, то вопрос знайте.
[01:36:05.280 --> 01:36:07.280]  Как ты мог все забыть?
[01:36:07.280 --> 01:36:09.280]  В общем, если вы написали
[01:36:09.280 --> 01:36:11.280]  вот такую функцию
[01:36:13.280 --> 01:36:15.280]  френд с определением
[01:36:15.280 --> 01:36:17.280]  внутри класса,
[01:36:17.280 --> 01:36:19.280]  это просто значит, что вы во внешнем скопе
[01:36:19.280 --> 01:36:21.280]  определили новую функцию
[01:36:21.280 --> 01:36:23.280]  с таким названием,
[01:36:23.280 --> 01:36:25.280]  которая автоматически
[01:36:25.280 --> 01:36:27.280]  френд для текущего класса,
[01:36:27.280 --> 01:36:29.280]  но при этом
[01:36:29.280 --> 01:36:31.280]  эту функцию нельзя вызвать явно.
[01:36:33.280 --> 01:36:35.280]  Ее можно вызвать только с помощью
[01:36:35.280 --> 01:36:37.280]  ArgumentDependentLockup.
[01:36:41.280 --> 01:36:43.280]  Когда из аргумента
[01:36:43.280 --> 01:36:45.280]  мы понимаем, в каком на Emspace
[01:36:45.280 --> 01:36:47.280]  лежит функция.
[01:36:53.280 --> 01:36:55.280]  Смотрим еще раз на код.
[01:36:55.280 --> 01:36:57.280]  Два шаблона.
[01:36:57.280 --> 01:36:59.280]  Оба они объявляют
[01:36:59.280 --> 01:37:01.280]  френд автолуп холл.
[01:37:01.280 --> 01:37:03.280]  Но первая из них объявляет
[01:37:03.280 --> 01:37:05.280]  только
[01:37:05.280 --> 01:37:07.280]  объявляет, а вторая еще определяет.
[01:37:09.280 --> 01:37:11.280]  Если мы вот так напишем.
[01:37:11.280 --> 01:37:13.280]  Изменилось ли что-то?
[01:37:17.280 --> 01:37:19.280]  Нет, мы же не специализировали
[01:37:19.280 --> 01:37:21.280]  френд автолуп холл.
[01:37:23.280 --> 01:37:25.280]  Да, ничего не изменилось.
[01:37:25.280 --> 01:37:27.280]  Мы не инстанцировали луп холл,
[01:37:27.280 --> 01:37:29.280]  а поэтому
[01:37:31.280 --> 01:37:33.280]  френда нет.
[01:37:33.280 --> 01:37:35.280]  Мы про это, кажется, уже упоминали,
[01:37:35.280 --> 01:37:37.280]  что когда вы френда
[01:37:37.280 --> 01:37:39.280]  вписываете таким образом шаблон,
[01:37:39.280 --> 01:37:41.280]  начинается магия.
[01:37:41.280 --> 01:37:43.280]  Подобная функция у вас
[01:37:43.280 --> 01:37:45.280]  определяется для каждой инстанциации.
[01:37:47.280 --> 01:37:49.280]  Так как мы еще ни разу
[01:37:49.280 --> 01:37:51.280]  не инстанцировали луп холл,
[01:37:51.280 --> 01:37:53.280]  пока что нет ни одного
[01:37:53.280 --> 01:37:55.280]  определения в коде для функции
[01:37:55.280 --> 01:37:57.280]  луп холл.
[01:37:57.280 --> 01:37:59.280]  Но как только мы
[01:37:59.280 --> 01:38:01.280]  инстанцируем
[01:38:01.280 --> 01:38:03.280]  луп холл,
[01:38:05.280 --> 01:38:07.280]  внезапно оно
[01:38:07.280 --> 01:38:09.280]  будет работать.
[01:38:09.280 --> 01:38:11.280]  То есть теперь
[01:38:11.280 --> 01:38:13.280]  функция луп холл определена.
[01:38:15.280 --> 01:38:17.280]  В зависимости от того,
[01:38:17.280 --> 01:38:19.280]  вписана ли у вас в коде уже вот эта
[01:38:19.280 --> 01:38:21.280]  строчка, а вернее
[01:38:21.280 --> 01:38:23.280]  обработана ли уже компилятором,
[01:38:23.280 --> 01:38:25.280]  вот это выражение
[01:38:25.280 --> 01:38:27.280]  даст разный результат.
[01:38:27.280 --> 01:38:29.280]  Оно либо
[01:38:29.280 --> 01:38:31.280]  ошибку компиляции даст,
[01:38:31.280 --> 01:38:33.280]  либо скомпилируется.
[01:38:33.280 --> 01:38:35.280]  Понимаете ли вы,
[01:38:35.280 --> 01:38:37.280]  что мы научились делать?
[01:38:37.280 --> 01:38:39.280]  Мы научились
[01:38:39.280 --> 01:38:41.280]  хранить один бит
[01:38:41.280 --> 01:38:43.280]  в памяти компилятора.
[01:38:43.280 --> 01:38:45.280]  Устанавливается?
[01:38:45.280 --> 01:38:47.280]  Его из нуля в единицы.
[01:38:47.280 --> 01:38:49.280]  Да, мы научились
[01:38:49.280 --> 01:38:51.280]  пока только из нуля в единицы
[01:38:51.280 --> 01:38:53.280]  его устанавливать.
[01:38:53.280 --> 01:38:55.280]  А мы не можем сделать
[01:38:55.280 --> 01:38:57.280]  декл-тайп
[01:38:57.280 --> 01:38:59.280]  от возвращаемого значения
[01:38:59.280 --> 01:39:01.280]  получить сразу тип?
[01:39:01.280 --> 01:39:03.280]  Что, что еще раз?
[01:39:03.280 --> 01:39:05.280]  Если делать декл-тайп
[01:39:05.280 --> 01:39:07.280]  от луп холл,
[01:39:07.280 --> 01:39:09.280]  то тег ноль,
[01:39:09.280 --> 01:39:11.280]  то мы получим тип наверх.
[01:39:11.280 --> 01:39:13.280]  Правильную сторону выслеживаешь.
[01:39:13.280 --> 01:39:15.280]  Я не знаю,
[01:39:15.280 --> 01:39:17.280]  честно, что произойдет,
[01:39:17.280 --> 01:39:19.280]  если два раза инстанцировать луп холл.
[01:39:19.280 --> 01:39:21.280]  Это все
[01:39:21.280 --> 01:39:23.280]  очень близко
[01:39:23.280 --> 01:39:25.280]  к призыву ктулзу.
[01:39:25.280 --> 01:39:27.280]  То есть тот код,
[01:39:27.280 --> 01:39:29.280]  что вы увидите,
[01:39:29.280 --> 01:39:31.280]  он стандарту подлежит.
[01:39:31.280 --> 01:39:33.280]  Это не undefined behavior,
[01:39:33.280 --> 01:39:35.280]  это не unspecified behavior.
[01:39:35.280 --> 01:39:37.280]  Это код,
[01:39:37.280 --> 01:39:39.280]  про который стандарт
[01:39:39.280 --> 01:39:41.280]  просто ничего не говорит.
[01:39:41.280 --> 01:39:43.280]  Мы задумались,
[01:39:43.280 --> 01:39:45.280]  что так можно написать.
[01:39:45.280 --> 01:39:47.280]  Раз код стандарту не противоречит,
[01:39:47.280 --> 01:39:49.280]  значит все окей.
[01:39:49.280 --> 01:39:51.280]  Но на стандарт
[01:39:51.280 --> 01:39:53.280]  ничего не говорит.
[01:39:53.280 --> 01:39:55.280]  Поэтому непонятно,
[01:39:55.280 --> 01:39:57.280]  что начнет происходить,
[01:39:57.280 --> 01:39:59.280]  если мы два раза луп холл напишем
[01:39:59.280 --> 01:40:01.280]  или еще подобные вещи.
[01:40:01.280 --> 01:40:03.280]  Я бы сказал,
[01:40:03.280 --> 01:40:05.280]  что если мы второй раз
[01:40:05.280 --> 01:40:07.280]  напишем луп холл
[01:40:07.280 --> 01:40:09.280]  с таким же интом,
[01:40:09.280 --> 01:40:11.280]  то будет ошибка компиляции,
[01:40:11.280 --> 01:40:13.280]  потому что ambiguous.
[01:40:13.280 --> 01:40:15.280]  Мне кажется так.
[01:40:15.280 --> 01:40:17.280]  Но я не уверен.
[01:40:19.280 --> 01:40:21.280]  Так вот.
[01:40:21.280 --> 01:40:23.280]  Мы добавим
[01:40:23.280 --> 01:40:25.280]  еще и т.
[01:40:29.280 --> 01:40:31.280]  И это т,
[01:40:31.280 --> 01:40:33.280]  оно как раз будет
[01:40:33.280 --> 01:40:35.280]  кажется спасать
[01:40:35.280 --> 01:40:37.280]  и у нас будет
[01:40:37.280 --> 01:40:39.280]  кажется спасать
[01:40:39.280 --> 01:40:41.280]  от этой ошибки
[01:40:41.280 --> 01:40:43.280]  ambiguity.
[01:40:43.280 --> 01:40:45.280]  Да, мы же собрались написать
[01:40:45.280 --> 01:40:47.280]  рефлексию для любой структуры.
[01:40:47.280 --> 01:40:49.280]  Если мы собрались
[01:40:49.280 --> 01:40:51.280]  как-то это использовать,
[01:40:51.280 --> 01:40:53.280]  хотелось бы, чтобы нашу рефлексию
[01:40:53.280 --> 01:40:55.280]  можно было не один раз за всю программу использовать.
[01:40:55.280 --> 01:40:57.280]  Соответственно,
[01:40:57.280 --> 01:40:59.280]  t это будет тип структуры,
[01:40:59.280 --> 01:41:01.280]  f это тип поля,
[01:41:01.280 --> 01:41:03.280]  а n это номер поля.
[01:41:03.280 --> 01:41:05.280]  То есть
[01:41:05.280 --> 01:41:07.280]  как это понимать?
[01:41:07.280 --> 01:41:09.280]  Верхняя структурка
[01:41:09.280 --> 01:41:11.280]  определяет для каждого t
[01:41:11.280 --> 01:41:13.280]  и для каждого числа n
[01:41:13.280 --> 01:41:15.280]  флажок,
[01:41:15.280 --> 01:41:17.280]  который может быть 0 или 1.
[01:41:17.280 --> 01:41:19.280]  Изначально все эти флажки нот.
[01:41:21.280 --> 01:41:23.280]  А нижняя структурка
[01:41:23.280 --> 01:41:25.280]  пишет в этот флажок
[01:41:25.280 --> 01:41:27.280]  1
[01:41:27.280 --> 01:41:29.280]  и волшебным образом
[01:41:29.280 --> 01:41:31.280]  протаскивает f
[01:41:31.280 --> 01:41:33.280]  через этот флажок.
[01:41:33.280 --> 01:41:35.280]  Я бы даже сказал так.
[01:41:37.280 --> 01:41:39.280]  Это optional тип,
[01:41:39.280 --> 01:41:41.280]  переменная типа.
[01:41:41.280 --> 01:41:43.280]  Для каждого t и n
[01:41:43.280 --> 01:41:45.280]  нижняя структурка
[01:41:45.280 --> 01:41:47.280]  пишет тип
[01:41:47.280 --> 01:41:49.280]  в это поле.
[01:41:49.280 --> 01:41:51.280]  Осталось научиться
[01:41:51.280 --> 01:41:53.280]  вытаскивать.
[01:41:55.280 --> 01:41:57.280]  Ну, уже сказали,
[01:41:57.280 --> 01:41:59.280]  вытаскивать мы будем декл-тайм.
[01:41:59.280 --> 01:42:01.280]  Итак,
[01:42:01.280 --> 01:42:03.280]  loophole
[01:42:03.280 --> 01:42:05.280]  от tag от t и n
[01:42:05.280 --> 01:42:07.280]  внизу желтым подчеркнутое,
[01:42:07.280 --> 01:42:09.280]  это глобальная
[01:42:09.280 --> 01:42:11.280]  переменная типовая
[01:42:11.280 --> 01:42:13.280]  внутри компилятора.
[01:42:15.280 --> 01:42:17.280]  В loophole get
[01:42:17.280 --> 01:42:19.280]  мы просто
[01:42:19.280 --> 01:42:21.280]  читаем ее.
[01:42:21.280 --> 01:42:23.280]  Если не выездит,
[01:42:23.280 --> 01:42:25.280]  то ошибка компиляции,
[01:42:25.280 --> 01:42:27.280]  можно даже
[01:42:27.280 --> 01:42:29.280]  это с детектить
[01:42:29.280 --> 01:42:31.280]  с помощью свиная.
[01:42:31.280 --> 01:42:33.280]  Но нам это не интересно сейчас.
[01:42:33.280 --> 01:42:35.280]  А сверху
[01:42:35.280 --> 01:42:37.280]  ubik,
[01:42:37.280 --> 01:42:39.280]  который мы до этого смотрели.
[01:42:39.280 --> 01:42:41.280]  А, кстати, я не сказал ubik
[01:42:41.280 --> 01:42:43.280]  от слова ubiquitus,
[01:42:43.280 --> 01:42:45.280]  то бишь
[01:42:45.280 --> 01:42:47.280]  универсальный в каком-то смысле.
[01:42:47.280 --> 01:42:49.280]  Вот, и этот новый ubik
[01:42:49.280 --> 01:42:51.280]  он выглядит в принципе
[01:42:51.280 --> 01:42:53.280]  так же, как и старый.
[01:42:53.280 --> 01:42:55.280]  Только мы теперь еще и t-шку
[01:42:55.280 --> 01:42:57.280]  делаем.
[01:42:57.280 --> 01:42:59.280]  И внутри каста
[01:42:59.280 --> 01:43:01.280]  мы делаем loophole set.
[01:43:01.280 --> 01:43:03.280]  Таким образом,
[01:43:03.280 --> 01:43:05.280]  в этот слот
[01:43:07.280 --> 01:43:09.280]  с ключом
[01:43:09.280 --> 01:43:11.280]  ti
[01:43:11.280 --> 01:43:13.280]  пишем type.
[01:43:15.280 --> 01:43:17.280]  После этого в любой момент
[01:43:17.280 --> 01:43:19.280]  можно запустить loophole get
[01:43:19.280 --> 01:43:21.280]  с нужным ключом,
[01:43:21.280 --> 01:43:23.280]  структуркой номер поля
[01:43:23.280 --> 01:43:25.280]  и выключить тип этого поля.
[01:43:29.280 --> 01:43:31.280]  А дальше мы их можем затолкать
[01:43:31.280 --> 01:43:33.280]  в тюкл и передать пользователю.
[01:43:35.280 --> 01:43:37.280]  По-моему, это отлично.
[01:43:37.280 --> 01:43:39.280]  Так вот,
[01:43:39.280 --> 01:43:41.280]  что по этому поводу
[01:43:41.280 --> 01:43:43.280]  говорят
[01:43:43.280 --> 01:43:45.280]  серьезные дяди?
[01:43:45.280 --> 01:43:47.280]  Читаем дословно.
[01:43:47.280 --> 01:43:49.280]  This technique is arcane
[01:43:49.280 --> 01:43:51.280]  and should be made informed.
[01:43:53.280 --> 01:43:55.280]  Я не придумал слово arcane.
[01:43:55.280 --> 01:43:57.280]  Это официальная терминология.
[01:43:59.280 --> 01:44:01.280]  И да,
[01:44:03.280 --> 01:44:05.280]  все согласны, что эту технику
[01:44:05.280 --> 01:44:07.280]  надо выпилить,
[01:44:07.280 --> 01:44:09.280]  но никто не знает как,
[01:44:09.280 --> 01:44:11.280]  поэтому продолжаем танцевать.
[01:44:11.280 --> 01:44:13.280]  И на основе
[01:44:13.280 --> 01:44:15.280]  этой лютой техники
[01:44:15.280 --> 01:44:17.280]  можно придумать еще кучу всего
[01:44:17.280 --> 01:44:19.280]  очень страшного,
[01:44:19.280 --> 01:44:21.280]  очень-очень страшного.
[01:44:21.280 --> 01:44:23.280]  Но мне кажется, мы уже сегодня
[01:44:23.280 --> 01:44:25.280]  не успеем все это страшное
[01:44:25.280 --> 01:44:27.280]  посмотреть.
[01:44:27.280 --> 01:44:29.280]  Я предлагаю вам самим играться.
[01:44:29.280 --> 01:44:31.280]  Есть ли какие-то еще вопросы
[01:44:31.280 --> 01:44:33.280]  про вот эту штуку?
[01:44:33.280 --> 01:44:35.280]  Может быть, вы не поняли
[01:44:35.280 --> 01:44:37.280]  и вам нужно еще раз посмотреть на код?
[01:44:43.280 --> 01:44:45.280]  Кажется, тут можно обобщить
[01:44:45.280 --> 01:44:47.280]  до какого-то там type2ply
[01:44:47.280 --> 01:44:49.280]  или еще какого-нибудь более крутого ключа.
[01:44:51.280 --> 01:44:53.280]  Кажется, что можно.
[01:44:55.280 --> 01:44:57.280]  А как только ты попробуешь,
[01:44:59.280 --> 01:45:01.280]  ты будешь жалеть о своем решении.
[01:45:01.280 --> 01:45:03.280]  Ну, я как-то уже пробовал.
[01:45:03.280 --> 01:45:05.280]  Я пока еще не осознал
[01:45:05.280 --> 01:45:07.280]  несколько шагов.
[01:45:07.280 --> 01:45:09.280]  Там на каждом шагу
[01:45:09.280 --> 01:45:11.280]  ошибки компилятора,
[01:45:11.280 --> 01:45:13.280]  которые говорят тебе ни о чем.
[01:45:13.280 --> 01:45:15.280]  Вот ты просто пытаешься
[01:45:15.280 --> 01:45:17.280]  что-то сделать с этой техникой,
[01:45:17.280 --> 01:45:19.280]  а тебе компилятор говорит, ошибка, я ошибся.
[01:45:21.280 --> 01:45:23.280]  И все.
[01:45:23.280 --> 01:45:25.280]  И ты никак не понимаешь,
[01:45:25.280 --> 01:45:27.280]  что происходит, почему.
[01:45:27.280 --> 01:45:29.280]  То есть это такие дебри,
[01:45:29.280 --> 01:45:31.280]  с которыми весело иногда поиграться.
[01:45:31.280 --> 01:45:33.280]  И мне даже удалось,
[01:45:33.280 --> 01:45:35.280]  по советам ребят с реддита,
[01:45:35.280 --> 01:45:37.280]  сделать примитивную версию
[01:45:37.280 --> 01:45:39.280]  боров чекера,
[01:45:39.280 --> 01:45:41.280]  который автоматически следит
[01:45:41.280 --> 01:45:43.280]  за тем, где начинается один регион
[01:45:43.280 --> 01:45:45.280]  и где он заканчивается.
[01:45:47.280 --> 01:45:49.280]  Да, вот настолько.
[01:45:51.280 --> 01:45:53.280]  Но оно, конечно, работало отвратительно
[01:45:53.280 --> 01:45:55.280]  из-за специфики того,
[01:45:55.280 --> 01:45:57.280]  как именно вот эти вот
[01:45:57.280 --> 01:45:59.280]  сеты происходят.
[01:45:59.280 --> 01:46:01.280]  Нужно иметь в виду,
[01:46:01.280 --> 01:46:03.280]  что вот этот сет, он происходит
[01:46:03.280 --> 01:46:05.280]  не в момент запуска функции,
[01:46:05.280 --> 01:46:07.280]  а в момент инстанциации.
[01:46:09.280 --> 01:46:11.280]  То есть как только мы тело
[01:46:11.280 --> 01:46:13.280]  оператора каста инстанцировали,
[01:46:13.280 --> 01:46:15.280]  лобхол сет уже сработал.
[01:46:17.280 --> 01:46:19.280]  И у нас все в нужный момент
[01:46:19.280 --> 01:46:21.280]  происходит только за счет того,
[01:46:23.280 --> 01:46:25.280]  что мы параметризировали этот
[01:46:25.280 --> 01:46:27.280]  оператор каста
[01:46:27.280 --> 01:46:29.280]  в куче шаблонов
[01:46:29.280 --> 01:46:31.280]  и Т, и И, и еще и Тайпа.
[01:46:37.280 --> 01:46:39.280]  Ладно, давайте
[01:46:39.280 --> 01:46:41.280]  подумаем
[01:46:41.280 --> 01:46:43.280]  преимуществами недостатки.
[01:46:43.280 --> 01:46:45.280]  Вот я бы сказал, что это
[01:46:45.280 --> 01:46:47.280]  самое лучшее решение.
[01:46:49.280 --> 01:46:51.280]  Оно поддерживает все,
[01:46:51.280 --> 01:46:53.280]  никаких костылей
[01:46:53.280 --> 01:46:55.280]  просто идеально.
[01:46:55.280 --> 01:46:57.280]  Ну, как никаких костылей.
[01:46:57.280 --> 01:46:59.280]  Если древнюю магию
[01:46:59.280 --> 01:47:01.280]  темную с призывом
[01:47:01.280 --> 01:47:03.280]  ктулфу не считать
[01:47:03.280 --> 01:47:05.280]  костылем, то это не используется.
[01:47:07.280 --> 01:47:09.280]  Еще и быстро работает компиляция
[01:47:09.280 --> 01:47:11.280]  здесь за вот единицы
[01:47:11.280 --> 01:47:13.280]  получения каждого этого.
[01:47:13.280 --> 01:47:15.280]  Ну и да, это могут пофиксить,
[01:47:15.280 --> 01:47:17.280]  но шансы малы, поэтому
[01:47:19.280 --> 01:47:21.280]  я предлагаю домашку либо вот этим способом делать,
[01:47:21.280 --> 01:47:23.280]  либо следующим.
[01:47:25.280 --> 01:47:27.280]  Вот прошлый лектор это решение
[01:47:27.280 --> 01:47:29.280]  назвал хорошим,
[01:47:29.280 --> 01:47:31.280]  но это зависит от вашего взгляда на жизнь.
[01:47:31.280 --> 01:47:33.280]  Кто-то может назвать его
[01:47:33.280 --> 01:47:35.280]  в десять раз хуже предыдущего,
[01:47:35.280 --> 01:47:37.280]  это уже дело вкуса.
[01:47:37.280 --> 01:47:39.280]  В семнадцатых плюсах добавили
[01:47:39.280 --> 01:47:41.280]  вот такую штуку.
[01:47:43.280 --> 01:47:45.280]  Стракчер к байндинге.
[01:47:45.280 --> 01:47:47.280]  Знаете про них? Используйте.
[01:47:47.280 --> 01:47:49.280]  Да.
[01:47:49.280 --> 01:47:51.280]  Классная вещь.
[01:47:51.280 --> 01:47:53.280]  Позволит ли они нам...
[01:47:53.280 --> 01:47:55.280]  Великолепная. Что-что?
[01:47:55.280 --> 01:47:57.280]  Великолепная вещь.
[01:47:57.280 --> 01:47:59.280]  Позволит ли они нам вытащить
[01:47:59.280 --> 01:48:01.280]  типы?
[01:48:05.280 --> 01:48:07.280]  Да, что такое стракчер к байндинге?
[01:48:09.280 --> 01:48:11.280]  Если value это агрегатный тип
[01:48:11.280 --> 01:48:13.280]  tuple,
[01:48:13.280 --> 01:48:15.280]  stdra, структурка,
[01:48:17.280 --> 01:48:19.280]  в общем и целом любая штука,
[01:48:19.280 --> 01:48:21.280]  которая понятна, как разбить
[01:48:21.280 --> 01:48:23.280]  на несколько частей,
[01:48:23.280 --> 01:48:25.280]  то ты можешь написать следующий синтаксец
[01:48:25.280 --> 01:48:27.280]  через запятую
[01:48:27.280 --> 01:48:29.280]  какие-то идентификаторы
[01:48:29.280 --> 01:48:31.280]  в квадратных скобках.
[01:48:31.280 --> 01:48:33.280]  Слева авто, справа равно value.
[01:48:33.280 --> 01:48:35.280]  И оно тебе автоматом
[01:48:35.280 --> 01:48:37.280]  разобьет value
[01:48:37.280 --> 01:48:39.280]  на вот эти части.
[01:48:39.280 --> 01:48:41.280]  Заметь, что здесь a, b и c
[01:48:41.280 --> 01:48:43.280]  будут непеременными,
[01:48:43.280 --> 01:48:45.280]  это будут
[01:48:45.280 --> 01:48:47.280]  алиасами на обращение
[01:48:47.280 --> 01:48:49.280]  к частям value.
[01:48:49.280 --> 01:48:51.280]  То есть если value это tuple
[01:48:51.280 --> 01:48:53.280]  из трех элементов,
[01:48:53.280 --> 01:48:55.280]  a, b и c это будут
[01:48:55.280 --> 01:48:57.280]  алиасы на std get 0,
[01:48:57.280 --> 01:48:59.280]  std get 1, std get 2.
[01:48:59.280 --> 01:49:01.280]  Если value это массив из трех элементов,
[01:49:01.280 --> 01:49:03.280]  то a, b и c будут
[01:49:03.280 --> 01:49:05.280]  алиасами на value 0,
[01:49:05.280 --> 01:49:07.280]  value 1, value 2.
[01:49:07.280 --> 01:49:09.280]  Или если value это структурка
[01:49:09.280 --> 01:49:11.280]  из трех полей,
[01:49:11.280 --> 01:49:13.280]  то a, b и c будут алиасами
[01:49:13.280 --> 01:49:15.280]  на обращение к элементам этой структурки
[01:49:15.280 --> 01:49:17.280]  через точку.
[01:49:17.280 --> 01:49:19.280]  И можно писать
[01:49:19.280 --> 01:49:21.280]  авто-амперсант, авто-два-амперсанда
[01:49:21.280 --> 01:49:23.280]  и просто авто.
[01:49:23.280 --> 01:49:25.280]  Соответственно, это будет влиять
[01:49:27.280 --> 01:49:29.280]  на что-то.
[01:49:35.280 --> 01:49:37.280]  Если честно, я забыл,
[01:49:37.280 --> 01:49:39.280]  как конкретно это работает,
[01:49:39.280 --> 01:49:41.280]  но с точностью до
[01:49:41.280 --> 01:49:43.280]  деталей можно считать,
[01:49:43.280 --> 01:49:45.280]  что мы объявили новую переменную,
[01:49:45.280 --> 01:49:47.280]  которая либо ссылка,
[01:49:47.280 --> 01:49:49.280]  либо копия, либо
[01:49:49.280 --> 01:49:51.280]  rvalue-ссылка.
[01:49:51.280 --> 01:49:53.280]  Но на деле это именно алиасы,
[01:49:53.280 --> 01:49:55.280]  а не новые переменные.
[01:49:55.280 --> 01:49:57.280]  То есть если вы запишете что-то в a,
[01:49:59.280 --> 01:50:01.280]  оно определено как авто,
[01:50:01.280 --> 01:50:03.280]  кажется, это вообще не сработает
[01:50:03.280 --> 01:50:05.280]  и не скомпилируется.
[01:50:05.280 --> 01:50:07.280]  Не уверен.
[01:50:07.280 --> 01:50:09.280]  В общем, это все не важно.
[01:50:09.280 --> 01:50:11.280]  Главное, что мы умеем структуру
[01:50:11.280 --> 01:50:13.280]  по ее полям разбить.
[01:50:13.280 --> 01:50:15.280]  Ну, мы знаем
[01:50:15.280 --> 01:50:17.280]  количество элементов уже у структуры,
[01:50:17.280 --> 01:50:19.280]  напишем через запятую столько
[01:50:19.280 --> 01:50:21.280]  переменных, и вот их готово.
[01:50:21.280 --> 01:50:23.280]  Мы вытащили типы.
[01:50:23.280 --> 01:50:25.280]  Просто декл-тайп нужно вернуть.
[01:50:27.280 --> 01:50:29.280]  Да.
[01:50:31.280 --> 01:50:33.280]  И да.
[01:50:33.280 --> 01:50:35.280]  К сожалению,
[01:50:35.280 --> 01:50:37.280]  придется сделать так.
[01:50:37.280 --> 01:50:39.280]  Пока что
[01:50:39.280 --> 01:50:41.280]  structured-байндинги
[01:50:41.280 --> 01:50:43.280]  не поддерживают развертку
[01:50:43.280 --> 01:50:45.280]  паков
[01:50:45.280 --> 01:50:47.280]  внутрь них.
[01:50:49.280 --> 01:50:51.280]  Очень хочется, предложение в стандарт
[01:50:51.280 --> 01:50:53.280]  есть, но пока что это не поддерживается.
[01:50:53.280 --> 01:50:55.280]  Соответственно,
[01:50:55.280 --> 01:50:57.280]  предлагается написать вот такую
[01:50:57.280 --> 01:50:59.280]  кастыльную штуку.
[01:50:59.280 --> 01:51:01.280]  Наверное, даже нагенерить ее
[01:51:01.280 --> 01:51:03.280]  с помощью макросов.
[01:51:03.280 --> 01:51:05.280]  Что здесь происходит?
[01:51:05.280 --> 01:51:07.280]  Мы принимаем по ссылке структуру
[01:51:07.280 --> 01:51:09.280]  типа T. Используем
[01:51:09.280 --> 01:51:11.280]  наш метод для подсчета количества
[01:51:11.280 --> 01:51:13.280]  полей. В compile-тайме
[01:51:13.280 --> 01:51:15.280]  заметьте.
[01:51:15.280 --> 01:51:17.280]  И дальше, с помощью
[01:51:17.280 --> 01:51:19.280]  ifconstexpr, понимаем, сколько
[01:51:19.280 --> 01:51:21.280]  элементов в structured-байндинг
[01:51:21.280 --> 01:51:23.280]  нужно написать.
[01:51:23.280 --> 01:51:25.280]  А дальше
[01:51:25.280 --> 01:51:27.280]  мы можем вернуть
[01:51:27.280 --> 01:51:29.280]  дюпл ссылок
[01:51:29.280 --> 01:51:31.280]  на каждый из полей.
[01:51:31.280 --> 01:51:33.280]  И это очень круто.
[01:51:33.280 --> 01:51:35.280]  Потому что мы, во-первых, теперь знаем
[01:51:35.280 --> 01:51:37.280]  тип каждого поля,
[01:51:37.280 --> 01:51:39.280]  а во-вторых, еще можем по номеру,
[01:51:39.280 --> 01:51:41.280]  что раньше анонсировалось,
[01:51:41.280 --> 01:51:43.280]  записать в нужное
[01:51:43.280 --> 01:51:45.280]  поле.
[01:51:47.280 --> 01:51:49.280]  Есть ли вопросы по тому, как вот это работает?
[01:52:03.280 --> 01:52:05.280]  Сейчас тут же
[01:52:05.280 --> 01:52:07.280]  возможно
[01:52:07.280 --> 01:52:09.280]  придется немножко
[01:52:09.280 --> 01:52:11.280]  повоевать с тем, что
[01:52:11.280 --> 01:52:13.280]  std-tie на всю ссылку навешивает?
[01:52:13.280 --> 01:52:15.280]  Мы хотим вернуть
[01:52:15.280 --> 01:52:17.280]  ссылки в этом идее.
[01:52:17.280 --> 01:52:19.280]  Просто
[01:52:19.280 --> 01:52:21.280]  если мы пытались
[01:52:21.280 --> 01:52:23.280]  метаприковы делать,
[01:52:23.280 --> 01:52:25.280]  то там придется руками срывать
[01:52:25.280 --> 01:52:27.280]  постоянно. То есть тут была идея
[01:52:27.280 --> 01:52:29.280]  еще и бесплатно получить
[01:52:29.280 --> 01:52:31.280]  возможность по номеру поля
[01:52:31.280 --> 01:52:33.280]  присваивать ему что-то.
[01:52:33.280 --> 01:52:35.280]  И вот этот четвертый метод
[01:52:35.280 --> 01:52:37.280]  бесплатно позволяет
[01:52:37.280 --> 01:52:39.280]  это сделать.
[01:52:39.280 --> 01:52:41.280]  ОК?
[01:52:41.280 --> 01:52:43.280]  Думаю, что ОК.
[01:52:43.280 --> 01:52:45.280]  Ну,
[01:52:45.280 --> 01:52:47.280]  мне кажется, что вот эта
[01:52:47.280 --> 01:52:49.280]  необходимость в копипасте для всех
[01:52:49.280 --> 01:52:51.280]  размеров — это боль.
[01:52:51.280 --> 01:52:53.280]  С другой стороны, как мы
[01:52:53.280 --> 01:52:55.280]  уже уяснили,
[01:52:55.280 --> 01:52:57.280]  аскел, скала,
[01:52:57.280 --> 01:52:59.280]  fsh — все не стесняются
[01:52:59.280 --> 01:53:01.280]  в пластичь 60 раз определение
[01:53:01.280 --> 01:53:03.280]  тепла и
[01:53:03.280 --> 01:53:05.280]  нормального. C-sharp тоже самое.
[01:53:05.280 --> 01:53:07.280]  Возможно, и нам
[01:53:07.280 --> 01:53:09.280]  это норм, обернуть в macros
[01:53:09.280 --> 01:53:11.280]  и поехали.
[01:53:11.280 --> 01:53:13.280]  Хотя я не уверен, как macros-ами нормально
[01:53:13.280 --> 01:53:15.280]  через запятую нагенерить
[01:53:15.280 --> 01:53:17.280]  нужное количество
[01:53:17.280 --> 01:53:19.280]  structured-binding.
[01:53:19.280 --> 01:53:21.280]  Думаю, это можно
[01:53:21.280 --> 01:53:23.280]  сделать, но это уже
[01:53:23.280 --> 01:53:25.280]  macros-ная магия, а в ней
[01:53:25.280 --> 01:53:27.280]  я не эксперт.
[01:53:29.280 --> 01:53:31.280]  Да, можно
[01:53:31.280 --> 01:53:33.280]  лучше,
[01:53:33.280 --> 01:53:35.280]  можно перегрузками.
[01:53:35.280 --> 01:53:37.280]  Да,
[01:53:37.280 --> 01:53:39.280]  как бы тут
[01:53:39.280 --> 01:53:41.280]  диспетчеризация через теги идет.
[01:53:41.280 --> 01:53:43.280]  Последний аргумент — вот этот sizeT
[01:53:43.280 --> 01:53:45.280]  подчеркивание с чем-то
[01:53:45.280 --> 01:53:47.280]  с числом в аргументах шаблона.
[01:53:47.280 --> 01:53:49.280]  Это такой же тег
[01:53:49.280 --> 01:53:51.280]  или valueTag, как мы видели уже много
[01:53:51.280 --> 01:53:53.280]  раз.
[01:53:53.280 --> 01:53:55.280]  И результат constexpr функции можно подставить
[01:53:55.280 --> 01:53:57.280]  в шаблонный аргумент и дальше
[01:53:57.280 --> 01:53:59.280]  диспетчеризироваться под тегу.
[01:54:01.280 --> 01:54:03.280]  Это, возможно, чуть удобнее, чем
[01:54:03.280 --> 01:54:05.280]  писать with constexpr.
[01:54:09.280 --> 01:54:11.280]  В принципе, преимущества такие же, как у
[01:54:11.280 --> 01:54:13.280]  предыдущего — это идеальное
[01:54:13.280 --> 01:54:15.280]  с точки зрения пользователя решение.
[01:54:15.280 --> 01:54:17.280]  Но как бы
[01:54:17.280 --> 01:54:19.280]  тут вот опять, сколько нужно
[01:54:19.280 --> 01:54:21.280]  этих,
[01:54:21.280 --> 01:54:23.280]  для какого максимального
[01:54:23.280 --> 01:54:25.280]  размера нам нужно наопределять.
[01:54:25.280 --> 01:54:27.280]  Говорили когда-то, что 100
[01:54:27.280 --> 01:54:29.280]  мегабайт — достаточно для любой задачи.
[01:54:29.280 --> 01:54:31.280]  Ну вот как теперь?
[01:54:31.280 --> 01:54:33.280]  Достаточно или нет?
[01:54:33.280 --> 01:54:35.280]  100 — достаточно или нет?
[01:54:35.280 --> 01:54:37.280]  А вдруг кто-то из джейсонов
[01:54:37.280 --> 01:54:39.280]  генерирует структурки в плюсах,
[01:54:39.280 --> 01:54:41.280]  а у них там нормальная тема — вообще
[01:54:41.280 --> 01:54:43.280]  200? Не понятно.
[01:54:43.280 --> 01:54:45.280]  Так что да.
[01:54:45.280 --> 01:54:47.280]  Ну и остался последний пунктик.
[01:54:49.280 --> 01:54:51.280]  Это, собственно, получить ссылку на поле
[01:54:51.280 --> 01:54:53.280]  по индексу. Для четвертого подхода
[01:54:53.280 --> 01:54:55.280]  со structured binding — это бесплатно.
[01:54:55.280 --> 01:54:57.280]  Предыдущие три подхода
[01:54:57.280 --> 01:54:59.280]  ничего в этом не говорят.
[01:54:59.280 --> 01:55:01.280]  Поэтому мы должны придумать
[01:55:01.280 --> 01:55:03.280]  отдельный костыль.
[01:55:05.280 --> 01:55:07.280]  По сути, он сводится к тому, чтобы
[01:55:07.280 --> 01:55:09.280]  скастить нашу структуру к теплу.
[01:55:13.280 --> 01:55:15.280]  Ну, с рендермет кастить.
[01:55:17.280 --> 01:55:19.280]  Конечно же, это undefined
[01:55:19.280 --> 01:55:21.280]  behavior.
[01:55:21.280 --> 01:55:23.280]  Ну и что тут происходит?
[01:55:23.280 --> 01:55:25.280]  Мы опять получаем количество
[01:55:25.280 --> 01:55:27.280]  полей.
[01:55:27.280 --> 01:55:29.280]  Мы достаем
[01:55:31.280 --> 01:55:33.280]  наши...
[01:55:35.280 --> 01:55:37.280]  Вернее, не так. Мы
[01:55:37.280 --> 01:55:39.280]  объявляем функцию
[01:55:39.280 --> 01:55:41.280]  asTubl.
[01:55:41.280 --> 01:55:43.280]  Ее через любой из предыдущих упомянутых
[01:55:43.280 --> 01:55:45.280]  методов можно реализовать,
[01:55:45.280 --> 01:55:47.280]  которая просто
[01:55:47.280 --> 01:55:49.280]  делает
[01:55:49.280 --> 01:55:51.280]  tubl с теми же элементами
[01:55:51.280 --> 01:55:53.280]  как типы
[01:55:53.280 --> 01:55:55.280]  полей у структурки.
[01:55:55.280 --> 01:55:57.280]  То есть тут
[01:55:57.280 --> 01:55:59.280]  на слайде, на самом деле, много визуального
[01:55:59.280 --> 01:56:01.280]  шума.
[01:56:01.280 --> 01:56:03.280]  Единственное, что важно, это что using tubl —
[01:56:03.280 --> 01:56:05.280]  вот этот tubl, у него
[01:56:05.280 --> 01:56:07.280]  типы элементов такие же, как
[01:56:07.280 --> 01:56:09.280]  у полей в нашей структурке, в том же порядке.
[01:56:09.280 --> 01:56:11.280]  Дальше
[01:56:11.280 --> 01:56:13.280]  мы нашу структуру value
[01:56:13.280 --> 01:56:15.280]  рендермет кастим к этому теплу
[01:56:15.280 --> 01:56:17.280]  и делаем
[01:56:17.280 --> 01:56:19.280]  другую индексу.
[01:56:19.280 --> 01:56:21.280]  План надежный, как
[01:56:21.280 --> 01:56:23.280]  швейцарские часы.
[01:56:23.280 --> 01:56:25.280]  Одна проблема только.
[01:56:25.280 --> 01:56:27.280]  Теплы иногда
[01:56:27.280 --> 01:56:29.280]  компрессируют элементы.
[01:56:29.280 --> 01:56:31.280]  Им это никто
[01:56:31.280 --> 01:56:33.280]  стандартом не запретил.
[01:56:33.280 --> 01:56:35.280]  То есть, как вы знаете,
[01:56:35.280 --> 01:56:37.280]  есть некоторые требования к layout
[01:56:37.280 --> 01:56:39.280]  структурок в стандарте.
[01:56:39.280 --> 01:56:41.280]  Про выравнивание, паддинги,
[01:56:41.280 --> 01:56:43.280]  прочие штуки.
[01:56:43.280 --> 01:56:45.280]  И они для AsTubl
[01:56:45.280 --> 01:56:47.280]  немного отличаются.
[01:56:47.280 --> 01:56:49.280]  Соответственно,
[01:56:49.280 --> 01:56:51.280]  вот этот рендермет каст
[01:56:51.280 --> 01:56:53.280]  на каких-то компиляторах может сломаться и полететь.
[01:56:53.280 --> 01:56:55.280]  Ну и, конечно же,
[01:56:55.280 --> 01:56:57.280]  это UB.
[01:56:57.280 --> 01:56:59.280]  Но нам
[01:56:59.280 --> 01:57:01.280]  надо сделать свой tubl, чтобы
[01:57:01.280 --> 01:57:03.280]  это точно работало.
[01:57:03.280 --> 01:57:05.280]  Если мы сделаем
[01:57:05.280 --> 01:57:07.280]  свой tubl, у которого
[01:57:07.280 --> 01:57:09.280]  гарантированно так называемый
[01:57:09.280 --> 01:57:11.280]  standard layout, то есть такой же layout,
[01:57:11.280 --> 01:57:13.280]  как у структурок, то
[01:57:13.280 --> 01:57:15.280]  мы в шоколаде.
[01:57:21.280 --> 01:57:23.280]  Так.
[01:57:25.280 --> 01:57:27.280]  К чему это было?
[01:57:35.280 --> 01:57:37.280]  Да.
[01:57:37.280 --> 01:57:39.280]  Tubl мы свой используем?
[01:57:43.280 --> 01:57:45.280]  А. Есть
[01:57:45.280 --> 01:57:47.280]  читерная попытка
[01:57:47.280 --> 01:57:49.280]  избежать UB.
[01:57:49.280 --> 01:57:51.280]  Что
[01:57:51.280 --> 01:57:53.280]  если мы посчитаем,
[01:57:53.280 --> 01:57:55.280]  вот все эти касты
[01:57:55.280 --> 01:57:57.280]  к tubl как бы
[01:57:57.280 --> 01:57:59.280]  проведем, но воображаем.
[01:57:59.280 --> 01:58:01.280]  То есть,
[01:58:01.280 --> 01:58:03.280]  выяснили tubl
[01:58:03.280 --> 01:58:05.280]  и
[01:58:05.280 --> 01:58:07.280]  выяснили
[01:58:07.280 --> 01:58:09.280]  в этом tubl offset
[01:58:09.280 --> 01:58:11.280]  интересующего нас элемента.
[01:58:11.280 --> 01:58:13.280]  Да. Если у нас и структурка
[01:58:13.280 --> 01:58:15.280]  tubl одинакового layout,
[01:58:15.280 --> 01:58:17.280]  то offset
[01:58:17.280 --> 01:58:19.280]  от начала структурки или tubl
[01:58:19.280 --> 01:58:21.280]  у нужного индекса,
[01:58:21.280 --> 01:58:23.280]  поля нужного индекса,
[01:58:23.280 --> 01:58:25.280]  он будет одинаковым.
[01:58:25.280 --> 01:58:27.280]  Соответственно, мы
[01:58:27.280 --> 01:58:29.280]  выясняем
[01:58:29.280 --> 01:58:31.280]  эти offset
[01:58:31.280 --> 01:58:33.280]  достаточно
[01:58:33.280 --> 01:58:35.280]  простым образом.
[01:58:35.280 --> 01:58:37.280]  Берем DPL,
[01:58:37.280 --> 01:58:39.280]  tubl, то бишь,
[01:58:39.280 --> 01:58:41.280]  и берем get
[01:58:41.280 --> 01:58:43.280]  tubl,
[01:58:43.280 --> 01:58:45.280]  и разница
[01:58:45.280 --> 01:58:47.280]  и будет offset.
[01:58:49.280 --> 01:58:51.280]  Для этого нам, конечно, необходимо создать
[01:58:51.280 --> 01:58:53.280]  пустой tubl соответствующего
[01:58:53.280 --> 01:58:55.280]  типа.
[01:58:55.280 --> 01:58:57.280]  Там уже давно
[01:58:57.280 --> 01:58:59.280]  много слайдов назад было,
[01:58:59.280 --> 01:59:01.280]  с tubl input возвращал
[01:59:01.280 --> 01:59:03.280]  tubl с
[01:59:03.280 --> 01:59:05.280]  такими же элементами, но пустой.
[01:59:05.280 --> 01:59:07.280]  Он его не заполнял.
[01:59:07.280 --> 01:59:09.280]  Вот. Как только этот offset
[01:59:09.280 --> 01:59:11.280]  мы имеем,
[01:59:11.280 --> 01:59:13.280]  мы можем
[01:59:13.280 --> 01:59:15.280]  взять и применить такой же offset к
[01:59:15.280 --> 01:59:17.280]  оригинальной структурке,
[01:59:17.280 --> 01:59:19.280]  то есть скастить ее к чару,
[01:59:19.280 --> 01:59:21.280]  предпоследняя строчка,
[01:59:21.280 --> 01:59:23.280]  прибавить offset,
[01:59:23.280 --> 01:59:25.280]  а
[01:59:25.280 --> 01:59:27.280]  результатирующий offset
[01:59:27.280 --> 01:59:29.280]  обратно зареинтерпреткастить
[01:59:29.280 --> 01:59:31.280]  к нашему типу поля.
[01:59:33.280 --> 01:59:35.280]  И вот тут уже как бы все хорошо,
[01:59:35.280 --> 01:59:37.280]  вот этот реинтерпреткаст не является
[01:59:37.280 --> 01:59:39.280]  UB.
[01:59:39.280 --> 01:59:41.280]  Но при этом разыминование
[01:59:41.280 --> 01:59:43.280]  этого указателя все
[01:59:43.280 --> 01:59:45.280]  равно является UB.
[01:59:45.280 --> 01:59:47.280]  Потому что в стандарте очень
[01:59:47.280 --> 01:59:49.280]  хитрым образом вся эта вещь прописана.
[01:59:49.280 --> 01:59:51.280]  Важно не только
[01:59:51.280 --> 01:59:53.280]  куда указывает указатель,
[01:59:53.280 --> 01:59:55.280]  а откуда вы его получили.
[01:59:55.280 --> 01:59:57.280]  И вот указатель, который вы
[01:59:57.280 --> 01:59:59.280]  получили нелегально, он все равно
[01:59:59.280 --> 02:00:01.280]  вас будет, как бы
[02:00:01.280 --> 02:00:03.280]  все равно приведет к UB.
[02:00:03.280 --> 02:00:05.280]  Если вы когда-нибудь слышали
[02:00:05.280 --> 02:00:07.280]  об std-london,
[02:00:07.280 --> 02:00:09.280]  вот там похожая проблема.
[02:00:09.280 --> 02:00:11.280]  Компилятор помнит,
[02:00:11.280 --> 02:00:13.280]  откуда вы притащили этот указатель,
[02:00:13.280 --> 02:00:15.280]  и помнит, что вы нашалили
[02:00:15.280 --> 02:00:17.280]  akata и pantyfan behavior.
[02:00:19.280 --> 02:00:21.280]  Ну, конечно, по факту ни один компилятор
[02:00:21.280 --> 02:00:23.280]  этого не помнит.
[02:00:23.280 --> 02:00:25.280]  И это помнит только
[02:00:25.280 --> 02:00:27.280]  виртуальная машина C++,
[02:00:27.280 --> 02:00:29.280]  которая описывается в стандарте
[02:00:29.280 --> 02:00:31.280]  мифическое.
[02:00:31.280 --> 02:00:33.280]  И это решение по факту
[02:00:33.280 --> 02:00:35.280]  работ. Есть такая библиотека
[02:00:35.280 --> 02:00:37.280]  boost.pfr.
[02:00:37.280 --> 02:00:39.280]  В ней реализовано
[02:00:39.280 --> 02:00:41.280]  ровно это. То, что мы вот здесь
[02:00:41.280 --> 02:00:43.280]  сейчас с вами обсуждали.
[02:00:43.280 --> 02:00:45.280]  И получение
[02:00:45.280 --> 02:00:47.280]  по индексу указателя
[02:00:47.280 --> 02:00:49.280]  вот именно этот метод,
[02:00:49.280 --> 02:00:51.280]  а получение самих
[02:00:51.280 --> 02:00:53.280]  типов я забыл.
[02:00:53.280 --> 02:00:55.280]  Вот.
[02:00:57.280 --> 02:00:59.280]  Как-то так.
[02:00:59.280 --> 02:01:01.280]  Кажется, мы
[02:01:01.280 --> 02:01:03.280]  дошли до конца
[02:01:03.280 --> 02:01:05.280]  презентации.
[02:01:05.280 --> 02:01:07.280]  Мой голос умирает.
[02:01:11.280 --> 02:01:13.280]  Но это успех.
[02:01:13.280 --> 02:01:15.280]  150 слайдеров.
[02:01:19.280 --> 02:01:21.280]  Да, про вот эти вот хаки
[02:01:21.280 --> 02:01:23.280]  с рендер-бредкастами. Есть ли какие-то вопросы?
[02:01:29.280 --> 02:01:31.280]  Видимо, нет.
[02:01:39.280 --> 02:01:41.280]  Надо собраться с мыслями.
[02:01:41.280 --> 02:01:43.280]  В принципе, у нас еще есть
[02:01:43.280 --> 02:01:45.280]  некоторое время.
[02:01:45.280 --> 02:01:47.280]  Давайте попробуем
[02:01:47.280 --> 02:01:49.280]  пошалить.
[02:01:55.280 --> 02:01:57.280]  Мы
[02:01:57.280 --> 02:01:59.280]  Ну, вернее, я
[02:01:59.280 --> 02:02:01.280]  попишу код,
[02:02:01.280 --> 02:02:03.280]  потому что
[02:02:03.280 --> 02:02:05.280]  тут непонятно,
[02:02:05.280 --> 02:02:07.280]  какой код писать.
[02:02:07.280 --> 02:02:09.280]  Да, лучше
[02:02:09.280 --> 02:02:11.280]  это.
[02:02:11.280 --> 02:02:13.280]  Так.
[02:02:13.280 --> 02:02:15.280]  Это все не то.
[02:02:15.280 --> 02:02:17.280]  Спасибо, Силлайн.
[02:02:17.280 --> 02:02:19.280]  Спасибо, Силлайн.
[02:02:41.280 --> 02:02:43.280]  Так.
[02:02:47.280 --> 02:02:49.280]  Наверное, мы начнем
[02:02:49.280 --> 02:02:51.280]  отсюда.
[02:02:51.280 --> 02:02:53.280]  Потому что тут уже
[02:02:53.280 --> 02:02:55.280]  нужный код
[02:02:55.280 --> 02:02:57.280]  определен.
[02:02:59.280 --> 02:03:01.280]  Да.
[02:03:03.280 --> 02:03:05.280]  Тут уже, в принципе, есть
[02:03:05.280 --> 02:03:07.280]  все, что вам нужно.
[02:03:07.280 --> 02:03:09.280]  Вот кейкзампус для
[02:03:09.280 --> 02:03:11.280]  выполнения DZ
[02:03:11.280 --> 02:03:13.280]  с помощью вот этого
[02:03:13.280 --> 02:03:15.280]  читерного, хитрого метода.
[02:03:15.280 --> 02:03:17.280]  Давайте лучше
[02:03:19.280 --> 02:03:21.280]  поиграемся с самим
[02:03:21.280 --> 02:03:23.280]  юбиком.
[02:03:23.280 --> 02:03:25.280]  Вернее, с самим фолом.
[02:03:27.280 --> 02:03:29.280]  Нет, стоп.
[02:03:39.280 --> 02:03:41.280]  Да, нет.
[02:03:41.280 --> 02:03:43.280]  Да, нет.
[02:03:47.280 --> 02:03:49.280]  Вот.
[02:03:49.280 --> 02:03:51.280]  Вот отсюда начинается
[02:03:51.280 --> 02:03:53.280]  фол.
[02:03:53.280 --> 02:03:55.280]  Значит, вот это нас не интересует сейчас.
[02:03:55.280 --> 02:03:57.280]  И
[02:03:57.280 --> 02:03:59.280]  вот это нас сейчас не
[02:03:59.280 --> 02:04:01.280]  интересует.
[02:04:03.280 --> 02:04:05.280]  Ладно, нас ничего не интересует.
[02:04:05.280 --> 02:04:07.280]  Пусть все это будет закомменчено.
[02:04:07.280 --> 02:04:09.280]  Все равно коммитить то, что сейчас напишу,
[02:04:09.280 --> 02:04:11.280]  не буду. Тут уже достаточно
[02:04:11.280 --> 02:04:13.280]  адекватный фигмент.
[02:04:13.280 --> 02:04:15.280]  Например, закоммитчено.
[02:04:15.280 --> 02:04:17.280]  Да,
[02:04:17.280 --> 02:04:19.280]  как мы поняли,
[02:04:19.280 --> 02:04:21.280]  вот эта пара аргументов выступает
[02:04:21.280 --> 02:04:23.280]  своего рода
[02:04:23.280 --> 02:04:25.280]  ключами.
[02:04:29.280 --> 02:04:31.280]  Вот это F,
[02:04:31.280 --> 02:04:33.280]  который мы возвращаем
[02:04:33.280 --> 02:04:35.280]  из лупхола в итоге.
[02:04:39.280 --> 02:04:41.280]  Вернее,
[02:04:41.280 --> 02:04:43.280]  экземпляр, который мы возвращаем
[02:04:43.280 --> 02:04:45.280]  и в итоге превращаем автор в нее,
[02:04:45.280 --> 02:04:47.280]  служит значением.
[02:04:47.280 --> 02:04:49.280]  В каком-то смысле это такая
[02:04:49.280 --> 02:04:51.280]  мутабельная мапа
[02:04:51.280 --> 02:04:53.280]  в компиляторе.
[02:04:53.280 --> 02:04:55.280]  Давайте
[02:04:55.280 --> 02:04:57.280]  попробуем сделать вот что.
[02:04:59.280 --> 02:05:01.280]  Попробуем написать
[02:05:03.280 --> 02:05:05.280]  constexpr функцию
[02:05:09.280 --> 02:05:11.280]  которая возвращает
[02:05:11.280 --> 02:05:13.280]  каждый раз число на один больше.
[02:05:15.280 --> 02:05:17.280]  То есть счетчик.
[02:05:17.280 --> 02:05:19.280]  constexpr.
[02:05:19.280 --> 02:05:21.280]  Какая будет общая идея?
[02:05:25.280 --> 02:05:27.280]  Ну, сейчас я убрал отсюда
[02:05:27.280 --> 02:05:29.280]  второй аргумент, и сейчас у нас есть
[02:05:29.280 --> 02:05:31.280]  просто мапчик
[02:05:31.280 --> 02:05:33.280]  из идутов
[02:05:33.280 --> 02:05:35.280]  в класс.
[02:05:35.280 --> 02:05:37.280]  Вернее, даже не так.
[02:05:37.280 --> 02:05:39.280]  В maybe класс.
[02:05:39.280 --> 02:05:41.280]  То есть
[02:05:41.280 --> 02:05:43.280]  изначально, когда мы вот это
[02:05:43.280 --> 02:05:45.280]  не инстанцировали,
[02:05:45.280 --> 02:05:47.280]  соответствующий счет ни во что
[02:05:47.280 --> 02:05:49.280]  не отображается.
[02:05:49.280 --> 02:05:51.280]  Как только инстанцировали,
[02:05:51.280 --> 02:05:53.280]  отображается.
[02:05:53.280 --> 02:05:55.280]  Давайте попробуем
[02:05:55.280 --> 02:05:57.280]  научиться детектить,
[02:05:57.280 --> 02:05:59.280]  отображается ли во что-то
[02:05:59.280 --> 02:06:01.280]  конкретный общий
[02:06:01.280 --> 02:06:03.280]  идут.
[02:06:03.280 --> 02:06:05.280]  Общая идея будет
[02:06:05.280 --> 02:06:07.280]  какова?
[02:06:07.280 --> 02:06:09.280]  Использовать
[02:06:09.280 --> 02:06:11.280]  Sphinae либо
[02:06:11.280 --> 02:06:13.280]  Constraint.
[02:06:13.280 --> 02:06:15.280]  Тут
[02:06:15.280 --> 02:06:17.280]  были некоторые проблемы
[02:06:17.280 --> 02:06:19.280]  с тем, что Sphinae работает
[02:06:19.280 --> 02:06:21.280]  чутка по-другому.
[02:06:21.280 --> 02:06:23.280]  Но мне кажется, нам сейчас удастся
[02:06:23.280 --> 02:06:25.280]  достать и отработать на Constraint.
[02:06:25.280 --> 02:06:27.280]  А...
[02:06:31.280 --> 02:06:33.280]  Давайте попробуем
[02:06:33.280 --> 02:06:35.280]  объявить
[02:06:35.280 --> 02:06:37.280]  следующую constexpr
[02:06:37.280 --> 02:06:39.280]  функцию.
[02:06:39.280 --> 02:06:41.280]  constexpr bool is set
[02:06:49.280 --> 02:06:51.280]  для соответствующего int.
[02:06:51.280 --> 02:06:53.280]  Она будет
[02:06:53.280 --> 02:06:55.280]  требоваться,
[02:06:55.280 --> 02:06:57.280]  чтобы
[02:07:01.280 --> 02:07:03.280]  loophole от
[02:07:03.280 --> 02:07:05.280]  тега attend
[02:07:05.280 --> 02:07:07.280]  был определен.
[02:07:09.280 --> 02:07:11.280]  И эта перегрузка
[02:07:11.280 --> 02:07:13.280]  будет возвращать
[02:07:13.280 --> 02:07:15.280]  true.
[02:07:17.280 --> 02:07:19.280]  Соответственно, будет
[02:07:19.280 --> 02:07:21.280]  и вторая перегрузка, которая уже
[02:07:21.280 --> 02:07:23.280]  ничего не требует
[02:07:23.280 --> 02:07:25.280]  и возвращает false.
[02:07:27.280 --> 02:07:29.280]  Пока что ничего сложного.
[02:07:29.280 --> 02:07:31.280]  Все очень понятно.
[02:07:31.280 --> 02:07:33.280]  Да, конечно же,
[02:07:33.280 --> 02:07:35.280]  я вот так хочу сделать.
[02:07:37.280 --> 02:07:39.280]  Давайте
[02:07:39.280 --> 02:07:41.280]  попробуем, сработает ли это.
[02:07:41.280 --> 02:07:43.280]  Сейчас
[02:07:43.280 --> 02:07:45.280]  по умолчанию loophole не для кого,
[02:07:45.280 --> 02:07:47.280]  конечно же,
[02:07:47.280 --> 02:07:49.280]  не установлен.
[02:07:49.280 --> 02:07:51.280]  И мы попробуем сделать
[02:07:51.280 --> 02:07:53.280]  static assert
[02:07:57.280 --> 02:07:59.280]  на то, что
[02:07:59.280 --> 02:08:01.280]  is set 0.
[02:08:05.280 --> 02:08:07.280]  А не is set o.
[02:08:07.280 --> 02:08:09.280]  По дефолту работает.
[02:08:09.280 --> 02:08:11.280]  То есть, вот эта перегрузка
[02:08:11.280 --> 02:08:13.280]  отбрасывается,
[02:08:13.280 --> 02:08:15.280]  мы идем в эту.
[02:08:15.280 --> 02:08:17.280]  Окей.
[02:08:17.280 --> 02:08:19.280]  И мы инстанцируем
[02:08:19.280 --> 02:08:21.280]  loophole set
[02:08:21.280 --> 02:08:23.280]  с 0,
[02:08:23.280 --> 02:08:25.280]  но не важно чем.
[02:08:29.280 --> 02:08:31.280]  Попробуем теперь
[02:08:31.280 --> 02:08:33.280]  за static assert, что is set.
[02:08:39.280 --> 02:08:41.280]  Да, так мы, конечно, ничего не поймем.
[02:08:41.280 --> 02:08:43.280]  Нам нужен
[02:08:43.280 --> 02:08:45.280]  loophole ubic, мы хотим его забилдить.
[02:08:47.280 --> 02:08:49.280]  И ничего не вышло.
[02:09:01.280 --> 02:09:03.280]  Интересно, почему
[02:09:03.280 --> 02:09:05.280]  возможно,
[02:09:05.280 --> 02:09:07.280]  из-за порядка компиляции
[02:09:17.280 --> 02:09:19.280]  мы сделаем вот так.
[02:09:47.280 --> 02:09:49.280]  Кажется,
[02:09:49.280 --> 02:09:51.280]  это сработало.
[02:09:51.280 --> 02:09:53.280]  А до, оно должно
[02:09:53.280 --> 02:09:55.280]  выдать ошибку компиляции.
[02:09:55.280 --> 02:09:57.280]  Действительно.
[02:09:57.280 --> 02:09:59.280]  Да.
[02:09:59.280 --> 02:10:01.280]  То есть, до
[02:10:01.280 --> 02:10:03.280]  loophole set
[02:10:03.280 --> 02:10:05.280]  вызов loophole не компилируется,
[02:10:05.280 --> 02:10:07.280]  после компилируется.
[02:10:07.280 --> 02:10:09.280]  А я знаю, почему у нас
[02:10:09.280 --> 02:10:11.280]  ничего не сработало.
[02:10:11.280 --> 02:10:13.280]  Потому что для 0
[02:10:13.280 --> 02:10:15.280]  мы уже
[02:10:15.280 --> 02:10:17.280]  инстанцировали,
[02:10:17.280 --> 02:10:19.280]  так сказать.
[02:10:21.280 --> 02:10:23.280]  Вернее, мы уже нашли
[02:10:23.280 --> 02:10:25.280]  перегрузку, которая нас интересует.
[02:10:25.280 --> 02:10:27.280]  Вот эту.
[02:10:27.280 --> 02:10:29.280]  И вот этому даже не пытаемся инстанцировать.
[02:10:29.280 --> 02:10:31.280]  Кажется.
[02:10:31.280 --> 02:10:33.280]  Давайте
[02:10:33.280 --> 02:10:35.280]  вспомним, что в самом начале
[02:10:35.280 --> 02:10:37.280]  разговора про темную магию.
[02:10:37.280 --> 02:10:39.280]  Вспомним, что в самом начале
[02:10:39.280 --> 02:10:41.280]  разговора про темную магию.
[02:10:43.280 --> 02:10:45.280]  Мы добавим вот такую штуку.
[02:10:45.280 --> 02:10:47.280]  Тем самым
[02:10:47.280 --> 02:10:49.280]  заставив компилятор
[02:10:49.280 --> 02:10:51.280]  каждый раз заново искать инстанциацию.
[02:10:53.280 --> 02:10:55.280]  Так.
[02:10:59.280 --> 02:11:01.280]  Хоба.
[02:11:01.280 --> 02:11:03.280]  Ничего не получилось.
[02:11:07.280 --> 02:11:09.280]  Какая новость.
[02:11:13.280 --> 02:11:15.280]  Если у кого-то есть предположения,
[02:11:15.280 --> 02:11:17.280]  обязательно о них скажите.
[02:11:27.280 --> 02:11:29.280]  Занимаясь черной магией,
[02:11:29.280 --> 02:11:31.280]  такое бывает, что
[02:11:31.280 --> 02:11:33.280]  ничего не работает, непонятно, почему.
[02:11:37.280 --> 02:11:39.280]  Давайте подклетим, что ли?
[02:11:43.280 --> 02:11:45.280]  В подсказке используется
[02:11:45.280 --> 02:11:47.280]  SFINAE.
[02:11:53.280 --> 02:11:55.280]  В подсказке используется
[02:11:55.280 --> 02:11:57.280]  SFINAE.
[02:11:59.280 --> 02:12:01.280]  В подсказке используется
[02:12:01.280 --> 02:12:03.280]  SFINAE.
[02:12:03.280 --> 02:12:05.280]  В подсказке используется SFINAE.
[02:12:05.280 --> 02:12:07.280]  В подсказке используется SFINAE.
[02:12:07.280 --> 02:12:09.280]  Делаем это.
[02:12:09.280 --> 02:12:11.280]  Сфинаэв,
[02:12:11.280 --> 02:12:13.280]  смартфон.
[02:12:13.280 --> 02:12:15.280]  Сфинаэв,
[02:12:15.280 --> 02:12:17.280]  смартфон.
[02:12:17.280 --> 02:12:19.280]  Штант.
[02:12:19.280 --> 02:12:21.280]  Штант.
[02:12:21.280 --> 02:12:23.280]  Штант.
[02:12:23.280 --> 02:12:25.280]  Штант.
[02:12:25.280 --> 02:12:27.280]  Штант.
[02:12:27.280 --> 02:12:29.280]  Штант.
[02:12:29.280 --> 02:12:31.280]  Штант.
[02:12:31.280 --> 02:12:42.120]  посмотрим хоть немного. да, хорошая идея. я примерно тем же занимался пару дней назад,
[02:12:42.120 --> 02:12:47.640]  но в другом проекте, который я вам показывать не могу, потому что там планы длиннейших домашек,
[02:12:47.640 --> 02:13:08.480]  а внезапно это работает. ну, в общем, кажется проблема в том, что оно считает вот эту
[02:13:08.480 --> 02:13:18.320]  перегрузку более приоритетной, и вот эту даже не пытается рассматривать. да, соответственно,
[02:13:18.320 --> 02:13:25.560]  давайте как-то навяжем компилятору, чтобы вот эта перегрузка была более приоритетной. я предлагаю
[02:13:25.560 --> 02:13:35.760]  это сделать так. сюда принять int, сюда принять float. теперь и set нужно вызывать от аргумента,
[02:13:35.760 --> 02:13:46.880]  причем именно от 0, вот именно от литерала 0. почему это сработает? вот эта перегрузка принимает
[02:13:46.880 --> 02:13:56.120]  на вход int, а 0 это int, и не нужна implicit cast, поэтому эта перегрузка более приоритетна,
[02:13:56.120 --> 02:14:11.080]  если доступны обе из них. да, для флота нужно за implicit cast, поэтому float откидывает. и теперь оно
[02:14:11.080 --> 02:14:22.560]  кажется... да чтоб его... ну хорошо, хорошо, убедили. давайте уберем вот это и посмотрим,
[02:14:22.560 --> 02:14:34.560]  почему оно не хочет убирать вторую перегрузку. теперь хочет. кажется, мы все еще не избавились от
[02:14:34.560 --> 02:14:43.600]  вот этого каширования результаты инстанциации. вот вообще это каширование, насколько я помню,
[02:14:43.600 --> 02:14:50.040]  в 8 гцц когда появилось, оно поломало очень многие реализации constexpr счетчика. нет, тут все
[02:14:50.040 --> 02:14:56.640]  работало. я просто помню, что была такая история, когда я интересовался этой темой,
[02:14:56.640 --> 02:15:06.760]  и по итогу пришлось просто искать запрос constexpr счетчика, работать в гцц8. нет, я на выходных
[02:15:06.760 --> 02:15:15.720]  написал код, который работал в планк 13 и гцц10. все нормально. мое уважение. вопрос только,
[02:15:15.720 --> 02:15:45.560]  как я это сделал. давайте попробуем последовать примеру прошлогодним.
[02:15:45.720 --> 02:16:05.720]  и вот эту штуку кинуть сюда. да, инстанцировать будем зубовым. даже больше? нет, ладно,
[02:16:05.720 --> 02:16:19.840]  допустим, так и останется. что он скажет? все равно failed.
[02:16:35.720 --> 02:16:59.480]  вопрос. он скомпилится или constexpr-каунтер прошлогодний? а он скомпилился. давайте сравнивать.
[02:17:05.720 --> 02:17:25.560]  окей, я кажется понял. вот эта тема не работает. нам нужно сюда принимать авто и каждый раз
[02:17:25.560 --> 02:17:52.160]  его указывать заново. давайте напишем wrapper. вот такой.
[02:17:56.440 --> 02:17:59.000]  и возможно теперь это сработает.
[02:18:03.520 --> 02:18:04.160]  да.
[02:18:04.160 --> 02:18:11.120]  нет.
[02:18:25.560 --> 02:18:38.520]  есть некая очень тонкая комбинация. есть очень тонкая комбинация параметров,
[02:18:38.520 --> 02:18:45.560]  которая позволяет этому работать. ладно, давайте посмотрим, какой у меня компилятор включен.
[02:18:55.660 --> 02:18:57.320]  пробуем много�иться.
[02:18:57.320 --> 02:19:17.480]  и там
[02:19:17.480 --> 02:19:35.320]  а не указывали ли тут явно нет да указывали это и так был гсс а если накладки
[02:19:35.320 --> 02:19:41.760]  черт
[02:19:47.480 --> 02:19:57.640]  не на самом деле это очень сильно удивляет
[02:19:57.640 --> 02:20:09.520]  а констекс про каунтер а стоп кажется не нажал это так
[02:20:09.520 --> 02:20:30.400]  констекс про каунтер на клавиа работает
[02:20:31.000 --> 02:20:32.840]  о
[02:20:32.840 --> 02:20:33.600]  Ох!
[02:20:57.500 --> 02:21:01.580]  Ну, давайте тогда просто прочитаем код констект не imagine.counter,
[02:21:01.580 --> 02:21:17.660]  почему-то абсолютно аналогичный код здесь почему-то не работает ok ну тут все то же самое тот же самый
[02:21:17.660 --> 02:21:28.380]  луп холл только мы теперь ничего не устанавливаем и просто его определяем кстати тут уже прописан был
[02:21:31.980 --> 02:21:33.260]  это не должно работать
[02:21:37.060 --> 02:21:44.340]  но возможно именно в этом и отличия что здесь була там авто это немножко по-разному работающие
[02:21:44.340 --> 02:21:53.020]  механизмы взлома компилятора но поинт тот же пока мы не инстанцировали в райтор луп холл не
[02:21:53.020 --> 02:22:06.700]  определен и вызываться не будет странно
[02:22:12.020 --> 02:22:19.700]  во во важный поинт вот если вот так сделать и попытаться сделать requires я вот здесь написал
[02:22:19.700 --> 02:22:38.500]  когда-то раньше да то это работать не будет вот этот requires скажет вам ок даже если у
[02:22:38.500 --> 02:22:47.700]  вас просто определена объявлена функция но не определена и чтобы вот с таким requires оно
[02:22:47.700 --> 02:22:56.260]  работало важно именно авто здесь использовать в этом же примере используется был но при этом
[02:22:56.260 --> 02:23:07.160]  мы не просто requires пихаем эту штуку мы требуем ее значение посчитать результат и записать в
[02:23:07.160 --> 02:23:19.040]  шаблонный аргумент ну чуть подробнее что именно мы требуем как именно пойдем с класса
[02:23:19.040 --> 02:23:28.560]  рида ридер запускается рекурсивно он начинает всегда с нуля это именно счетчик рекурсии и
[02:23:28.560 --> 02:23:38.760]  всегда увеличивается также вешка есть но она просто прокидывается насквозь именно чтобы
[02:23:38.760 --> 02:23:44.600]  каширование избежать да это вот опять вот это лямбда чертова и здесь она чем-то работает не
[02:23:44.600 --> 02:23:54.480]  работает фаза лумы не совпало вот но в какой момент обрубится рекурсия в момент когда вот
[02:23:54.480 --> 02:24:02.720]  эта штука приведет к ошибке это будет имидиат контекст для этого шаблона так называемо поэтому
[02:24:02.720 --> 02:24:13.140]  произойдет с финайя то есть с финайи здесь не в том что флоп холл не объявлен он объявлен в том
[02:24:13.140 --> 02:24:18.840]  что нереализован и поэтому вычислить его значение для того чтобы присвоить этому дефолтному
[02:24:18.840 --> 02:24:28.840]  аргумент не выйдет произойдет ошибка подстановки и мы улетим вот в эту штуку в ридер уже от флота
[02:24:28.840 --> 02:24:38.560]  да тут видите опять трюк используется чтобы приоритизировать вот это вот интерфлот но как
[02:24:38.560 --> 02:24:45.480]  только мы сюда улетели мы запустим райтор который собственно лоб холл сет тоже самое да и он
[02:24:45.480 --> 02:24:56.680]  соответствующий ячейку соответствующий номер напишет себя как бы это выглядит странно но на
[02:24:56.680 --> 02:25:05.000]  самом деле тут два шага первое мы инстанцируем брайтер от это это создаст функцию холл а также
[02:25:05.000 --> 02:25:16.520]  это н позволит вернуть наружу вот почему именно так пропустить надо не знаю и в итоге из всей
[02:25:16.520 --> 02:25:25.240]  этой рекурсии вернется первая н при котором еще не был объявлен лоб холл а также лоб холл станет
[02:25:25.240 --> 02:25:32.600]  объявлен для этого то бишь когда мы для нулевого запустим оно сразу провалится сюда объявит лоб
[02:25:32.600 --> 02:25:39.400]  холл для нуля и вернет ноль в следующий раз когда мы запустим мэкс где нуля уже был объявлен
[02:25:39.400 --> 02:25:46.280]  лоб холл и ну то есть мэкс просто ридер от нуля запускает да это сейчас мы туда не посмотрели пока
[02:25:46.280 --> 02:25:52.160]  не суть важно в следующий раз когда мы ридер от нуля запустим он увидит что глуп холл для нуля
[02:25:52.160 --> 02:25:59.720]  есть выберется вот это специально вот эта перегрузка она пойдет рекурсивно и уже теперь
[02:25:59.720 --> 02:26:06.600]  провалится в первую и для единички мы тоже поставим лоб холл и вернем единичку и так далее
[02:26:06.600 --> 02:26:13.920]  то есть такая последовательность флажков каждый из которых устанавливается последовательно
[02:26:13.920 --> 02:26:23.560]  когда мы до него доходим и в итоге мы умеем в констекспере получать а б и ц если запустим
[02:26:23.560 --> 02:26:28.520]  а б и ц разные 0 1 2 магия
[02:26:28.520 --> 02:26:41.680]  мне все-таки интересно может кому-то удастся почувствовать потому что их иного
[02:26:41.680 --> 02:26:52.360]  способа не почему не работает вот эта штука вероятно я знаю почему вероятно не знаю
[02:26:52.360 --> 02:26:58.800]  я бы попробовал следующий брать вот это
[02:26:58.800 --> 02:27:14.400]  брать вот это и здесь теперь трубу возвращать а вот здесь именно что вызывает лоб холл
[02:27:22.360 --> 02:27:43.080]  интересно почему оно пытается определить имя может это из-за того что я уже тут кодом
[02:27:43.640 --> 02:27:48.440]  все не пытается отлично
[02:27:48.440 --> 02:28:01.280]  да но это у нас не имидиат контекст никакого с финэ не произойдет все еще нужно вот это
[02:28:01.280 --> 02:28:12.640]  холл сад сломался а да мы теперь не хотим
[02:28:12.640 --> 02:28:15.720]  так
[02:28:31.280 --> 02:28:41.920]  окей кажется оно действительно должно быть помечен констекспер да слушайте скорее всего
[02:28:41.920 --> 02:28:48.080]  из-за этого все не работала да я тут начал придумать какие-то танцы с бубном просто
[02:28:48.080 --> 02:29:11.360]  true но пол оба все 2 3 потом такие
[02:29:11.360 --> 02:29:25.720]  опа да кстати на вопрос что будет что будет если два раза сделать сет кажется ничего он
[02:29:25.720 --> 02:29:36.560]  просто два раза сетнусь ну вернее что это значит сет происходит при инстанциации лоб холл сета
[02:29:36.560 --> 02:29:43.360]  если мы второй раз такой же лоб холл сет используем по инстанциации это уже есть по
[02:29:43.360 --> 02:29:51.120]  форме инстанциации не будет а вот если ее заинфорсить с помощью лямб лучше об этом не думать
[02:29:51.120 --> 02:29:57.840]  но на самом деле это не сработает потому что если мы сюда еще лямб до запихнем чтобы запретить
[02:29:57.840 --> 02:30:04.960]  кеширование инстанциации это будет уже другой слот то есть мы даже гет не сможем сделать так
[02:30:05.000 --> 02:30:11.280]  что да не так все просто кажется а нет сможем слушать
[02:30:15.440 --> 02:30:25.320]  3 definition вот все то есть когда мы в двух разных инстанциациях сделаем то это будет
[02:30:25.320 --> 02:30:36.280]  3 definition все сломается а так работает и теперь мы можем засердцить что ну например сначала
[02:30:36.280 --> 02:30:44.920]  установить третий и он будет установлен правда колдовство
[02:30:55.280 --> 02:30:58.520]  я даже могу обернуть лоб холл сет функцию
[02:30:58.520 --> 02:31:03.800]  да каунтер мы уже разобрали не интересно
[02:31:03.800 --> 02:31:29.640]  кажется вот так
[02:31:29.640 --> 02:31:54.600]  вот по моему это идеальная вертка теперь это выглядит даже читаем я бы сказал если учитывать
[02:31:54.600 --> 02:32:01.680]  то что мы здесь делаем просто сет и сет но возвращает констекспробул другое устанавливает
[02:32:04.680 --> 02:32:14.160]  плак то есть если вы покажете этот код невинному человеку он сперва может и не понять что-то
[02:32:14.160 --> 02:32:23.720]  происходит да ну что какие-то глобальные перемены устанавливать ассерты до статик статик ассерты
[02:32:23.720 --> 02:32:32.440]  одно и то же выражение разные моменты времени разный результат жесть вот и в общем на этом
[02:32:32.440 --> 02:32:44.840]  все можно если это еще и с макросами скрестить сделать аналог скопов из раз-то там
[02:32:44.840 --> 02:32:55.320]  ну или приизвестим у всем антику в каком-то смысле но мне не удалось добить эту идею до
[02:32:55.320 --> 02:33:03.800]  конца а здесь кажется никто раз там не увлекается поэтому давайте наверное на этом закончим я
[02:33:03.800 --> 02:33:11.640]  очень рекомендую поиграться еще с этой темой это очень весело но хоть и опасно для здоровья
[02:33:11.640 --> 02:33:17.600]  наверное все-таки это за коммичу
[02:33:17.600 --> 02:33:28.200]  как только это все
[02:33:28.200 --> 02:33:38.600]  скоммичу в таком виде если захотите раскоммитить те и
[02:33:38.600 --> 02:33:55.160]  что здесь было раньше в общем ладно на этом все
[02:33:55.160 --> 02:34:08.160]  надеюсь вы испытали катарсис чуть-чуть домашку выложу через часик скоммичу тоже через часик
[02:34:08.160 --> 02:34:16.720]  и ну запись тоже будет выложена но всего что в папке сам экземплу вам должно хватить чтобы
[02:34:16.720 --> 02:34:25.320]  пришли домашку если у кого больше нет никаких вопросов то всем спасибо всем пока
