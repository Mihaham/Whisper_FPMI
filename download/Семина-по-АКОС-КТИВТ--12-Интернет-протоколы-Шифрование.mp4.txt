[00:00.000 --> 00:13.200]  Думаю, можно начинать. Запись, тем более, тоже стартовала. И кто хотел, тот подключился. Начнем с теории,
[00:13.200 --> 00:19.460]  опять же, потому что у вас нет отдельных лекций. Ну и периодически я буду переключаться на какие-то
[00:19.460 --> 00:26.180]  практические моменты. Итак, в прошлый раз мы разобрали штуковые сокеты. В качестве домашнего
[00:26.180 --> 00:31.420]  задания вам даже нужно было сделать простую реализацию веб-сервера. Но кроме того, с прошлого
[00:31.420 --> 00:40.660]  года вы помните, особенно 12-я группа, как устроить протокол HTTP. Ну и как мы обрабатываем
[00:40.660 --> 00:45.780]  протокол HTTP и на каком уровне это все лежит. Вот у нас есть всякие низкоуровневые протоколы,
[00:45.780 --> 00:52.300]  которые мы не затрагиваем в рамках нашего курса. И поверх этого сетевой интерфейса, то есть что
[00:52.300 --> 00:57.860]  нужно знать? У вас есть некоторый сетевой интерфейс, неважно, это провод, какой-то VPN,
[00:57.860 --> 01:04.580]  виртуальное соединение или Wi-Fi. Вы можете отправлять какие-то пакеты через сетевой интерфейс,
[01:04.580 --> 01:09.580]  которые имеют строго фиксированный размер, в который вы можете запихать полезную нагрузку.
[01:09.580 --> 01:17.940]  Дальше, внутри этих пакетов запихиваются некоторые IP пакеты. Что есть в IP пакетах? В IP пакетах
[01:17.940 --> 01:26.100]  у нас уже появляется IP адрес, как отправителя, так и получателя. И на уровне IP у нас определяется
[01:26.100 --> 01:31.340]  маршрутизация, как от одного компьютера до другого доставить какой-то содержимый блок данных.
[01:31.340 --> 01:36.820]  Ну а дальше мы можем передавать либо короткие сообщения UDP, либо выстраивать двусторонние
[01:36.820 --> 01:42.620]  цепи взаимодействия, которые от UDP отличаются тем, что мы можем в две стороны туда-обратно
[01:42.620 --> 01:47.820]  передавать данные, как будто вы взаимодействуете с каким-то, например, локальным терминалом.
[01:47.820 --> 01:55.820]  Ну и на уровне процессов тут уже можно выстраивать что-то более высокого уровня,
[01:55.820 --> 02:04.940]  в частности, протокол TCP, который, по сути, работает поверх протокола TCP, обмениваясь текстовыми данными.
[02:04.940 --> 02:15.900]  Я не помню, я вам в прошлый раз телнет показывал, телнет, в котором было написано example.com,
[02:15.900 --> 02:23.900]  да, было такое. Так вот, в чем прикол? В случае с example.com все хорошо, все замечательно,
[02:23.900 --> 02:36.660]  напоминаю, как выглядит host example.com, обычный текстный запрос и получаем ответ в обычном текстовом виде.
[02:36.660 --> 02:49.460]  Так, теперь другая проблема, если я напишу то же самое, но, например, не example.com, а какой-нибудь
[02:49.460 --> 03:00.260]  yandex.ru, google.com, неважно что, любой современный веб-сервер и напишу точно такую же строчку,
[03:00.260 --> 03:11.780]  host.yandex.ru, то никакого ответа я не получу, точнее, я получаю ответ, но он не содержит никаких данных.
[03:12.100 --> 03:21.460]  Получается, код ответа http 301, страница постоянно перемещена на какой-то адрес. Это не ошибочный заголовок,
[03:21.460 --> 03:30.740]  то есть в http все коды, которые начинаются с цифры 1, 2, либо 3, это статус успеха, и их можно по-разному интерпретировать.
[03:30.740 --> 03:38.180]  Если начинаются четверки, либо с пятерки, это ошибка. И что значит страница постоянно перемещена?
[03:38.580 --> 03:47.860]  Здесь в заголовке указан location, вроде как тот же самый yandex.ru, но не протокол http, а протокол http с буквкой s на конце.
[03:47.860 --> 03:55.740]  Что означает буквка s на конце? Значит, что явно требуется шифрование данных, и без этого дальнейшее
[03:55.740 --> 04:04.700]  действие невозможно. Браузеры обычно это запоминают, и каждый раз потом лишний раз не загружают
[04:04.700 --> 04:14.140]  yandex.ru по обычным протокол http, а сразу и протокол https. И вот протокол https уже подразумевает шифрование,
[04:14.140 --> 04:24.020]  и обычным телнетом здесь уже не обойтись. На самом деле верхний уровень процессов, если посмотреть на
[04:24.020 --> 04:28.860]  классическую модель Ic, которая приводится во всех стандартных учебниках, и которые почему-то
[04:28.860 --> 04:37.220]  иногда любят спрашивать некоторые HR на собеседованиях. Там еще есть разделение на три подуровня, это уровень
[04:37.220 --> 04:43.740]  сеанса, уровень представления, уровень приложений. На самом деле в современных реалиях четкой границы
[04:43.740 --> 04:50.780]  между этими тремя уровнями нет, поскольку в зависимости от протокола здесь любое приложение может
[04:50.780 --> 04:57.540]  взаимодействовать так, как ему захочется. Итак, на уровне приложений. Вот протокол http, у вас есть четкий
[04:57.540 --> 05:05.660]  текстовый запрос, четкий текстовый ответ, который в том числе может содержать, например, уровень представлений,
[05:05.660 --> 05:10.660]  как данные дальше передаются, либо половинтекстом, либо используя какое-то сжатие, но заголовки
[05:10.660 --> 05:26.620]  вас идут все равно обычным текстом. А вот уровень сеанса обычно подразумевает, что вам нужно
[05:26.620 --> 05:36.820]  предварительно как-то установить соединение, после этого как-то согласовать сеанс и используя
[05:36.820 --> 05:43.620]  то же самое http-соединение уже по какому-то другому протоколу выполнять взаимодействие. В частности,
[05:43.620 --> 05:50.620]  таким образом работает протокол https, на самом деле это обычный телнет, когда отправляются какие-то
[05:50.620 --> 05:57.340]  команды на согласование сеанса, и после этого уже идет взаимодействие в каком-то бинарном виде
[05:57.340 --> 06:04.660]  по другому протоколу. В частности, для взаимодействия https, тут мы можем использовать вместо телнета
[06:04.660 --> 06:10.420]  другую утилиту, точнее это некоторый швейцарский нож всех возможных разных утилит под названием
[06:10.420 --> 06:19.780]  OpenSSL, и одна из утилит, входящая в поставку OpenSSL, называется sClient, secure client, который
[06:19.780 --> 06:26.980]  подключается и работает подобно телнету, но уже в the strongly. Команда OpenSSL есть во всех Linux
[06:26.980 --> 06:35.700]  дистрибутивах, в том числе и в BSD дистрибутивах, включая Mac. Общий вид команда OpenSSL, дальше какая-то
[06:35.700 --> 06:45.180]  из утилит, входящая в состав OpenSSL, поскольку там много разных инструментов, и вот connect, дальше
[06:45.180 --> 06:53.580]  яндекс.ру, там много всякого мусора, поэтому уж, конечно, я.ру, ну ладно, будет яндекс.ру, и порт
[06:53.580 --> 07:00.060]  443, в отличие от 80-го, он как раз явным образом подозревает, что используется защищенным соединением.
[07:00.060 --> 07:06.500]  Соединяемся, и что у нас происходит? Сначала происходит согласование сеанса, вот OpenSSL нам пишет
[07:06.500 --> 07:15.980]  кучу всяких протокол взаимодействия, на самом деле вдаваться в подробности здесь пока не обязательно,
[07:15.980 --> 07:24.820]  здесь сервер отправляет фотосертификат, выполняет свою проверку, в случае, если он успешен, то
[07:24.820 --> 07:32.060]  клиент генерирует свой ключ, отправит серверу, про это я чуть позже более подробно остановлюсь. Вот и после
[07:32.060 --> 07:41.140]  того, как выполнено какое-то согласование сеансов, я могу написать строчку get slash htp11 host
[07:41.140 --> 07:56.580]  yandex.ru, и после этого яндекс меня переодресует на какую-то штуку, пройти какую-то капчу,
[07:56.580 --> 08:06.460]  потому что он думает, что я какой-то робот, который массово что-то пытается сделать, но ладно,
[08:06.460 --> 08:10.740]  это уже заморозь к яндексу. Тем не менее, мы получаем уже какой-то другой текст, самое главное,
[08:10.740 --> 08:19.900]  что здесь мы получаем в отличие от обычных протоколов. Если я запущу какой-нибудь инструмент,
[08:19.900 --> 08:28.460]  например wireshark, это опенсорсный инструмент, есть под разные операционные системы, неважно
[08:28.460 --> 08:40.380]  какие, windows, linux, mac, он кроссплатформенный, позволяет мониторить, что у нас происходит
[08:40.380 --> 08:50.620]  в плане сетевого взаимодействия. Давайте я запущу это wireshark на текущем соединении, он сейчас
[08:50.620 --> 08:56.980]  будет генерировать огромное количество, видите, сколько данных передается, чтобы не засорять вывод
[08:56.980 --> 09:02.900]  и понять, как у нас происходит взаимодействие с кем-нибудь конкретным. Давайте зафиксируем,
[09:02.900 --> 09:13.740]  что мы будем смотреть на вывод example.com, чтобы сфильтровать это все от остального мусора. У него есть
[09:13.740 --> 09:25.540]  какой-то определенный IP-адрес, для этого напишем фильтр, что IP-адрес у нас ровно такой-то и будем
[09:25.540 --> 09:36.940]  просматривать, что у нас будет выдаваться. Я пока время выйду из виртуалки, чтобы это действительно
[09:36.940 --> 09:46.780]  честно отлавливать. Итак, example.com хорош тем, что он позволяет работать так по обычным 80-м
[09:46.780 --> 09:53.660]  протоколу, так и по протоколу HTTPS. Итак, подключаемся по 80-м порту, что мы видим? Мы установили
[09:53.660 --> 10:00.620]  какое-то TCP-соединение, то есть мы отправили от нашего источника какой-то пакет у протокола TCP
[10:00.620 --> 10:10.740]  с флагом SIN начала взаимодействия. Нам в ответ пришел TCP фрагмент, ответ, что это флаг SIN
[10:10.740 --> 10:18.460]  подтверждение взаимодействия, ну и дальше мы что-то отправили, transmission control, да, ну просто первый
[10:18.460 --> 10:30.100]  блок пустой, мы готовы что-то писать. Ну давайте напишем get slash HTTP 1.1 host example.com. Отправляем
[10:30.100 --> 10:36.540]  запрос и ответ, что мы наблюдаем? Огромное количество дальше пакетов на отправку. Вот чем
[10:36.540 --> 10:43.820]  плох протокол TCP? У него даже на небольшое взаимодействие нужно отправлять огромное количество
[10:43.820 --> 10:54.180]  запросов. И вот где-то есть содержательная часть внутри протокола TCP. Что у нас вообще представляет
[10:54.180 --> 11:01.060]  вывод утилиты Wireshark и как это все интерпретировать? Выбираем нужный нам пакет, вот мы отправили
[11:01.060 --> 11:08.220]  запрос GET по протоколу HTTP. Во что он превращается? Вот наш текст, который мы отправили плейнтекстом.
[11:08.220 --> 11:17.580]  GET, host такой-то, все. Дальше, этот HTTP кусок, вот он виден в наших бинарных данных чуть пониже,
[11:17.580 --> 11:25.140]  он в свою очередь заворачивается внутрь протокола TCP, то есть у нас есть какая-то полезная нагрузка,
[11:25.140 --> 11:34.460]  здесь она выделена зеленым цветом. И что у нас есть еще внутри протокола TCP? Внутри протокола TCP есть
[11:34.460 --> 11:47.100]  некоторый порт исходника, 53138, порт назначения, вот порт source 5.3.138. Насколько смыслено это число?
[11:47.100 --> 11:57.380]  Кто помнит с прошлого раза? Это некоторый рандом, который ядро само выбирает. Указывается порядковый
[11:57.380 --> 12:06.220]  номер пакета относительно всего сеанса. Здесь уже утилита Wireshark сама это пересчитывает
[12:06.220 --> 12:13.020]  относительно установки соединений, на самом деле в самих TCP заголовках идет сквозная нумерация
[12:13.020 --> 12:23.660]  от того момента как ядро запустилось и все пакеты у нас как разным образом умируются. А если переполняется,
[12:23.660 --> 12:30.580]  то сбрасывается и ничего страшного в этом не происходит. Номер подтверждаем пакетом и так далее.
[12:30.580 --> 12:38.340]  Ну и где-то среди этого, среди, после заголовков TCP у нас уже следует, у нас заканчивается заголовок,
[12:38.340 --> 12:52.180]  где-то 0D, 0A и после него уже идет полезная нагрузка. До протокола TCP у нас есть заголовок IP
[12:52.180 --> 13:02.500]  протокола, что у нас содержит IP протокол, который идет до протокола TCP, до заголовка TCP. В заголовке IP
[13:02.500 --> 13:14.020]  у нас есть размер, identification, разные флаги не очень важные по дефолту, time to leave 64,
[13:14.020 --> 13:22.860]  протокол нежележащий, это некоторое число. Для TCP это соответствует номер 6, для UDP номер 17,
[13:22.860 --> 13:29.660]  насколько я помню. Остальные в принципе не используют числа. Вот когда противоположная
[13:29.660 --> 13:36.220]  сторона получает IP пакет, она смотрит на номер протокола в заголовке и уже понимает,
[13:36.220 --> 13:43.020]  как дальше интерпретировать следующий заголовок. Ну и самое важное, source адрес и destination
[13:43.020 --> 13:51.860]  адрес. Ну а дальше это все запихивается уже в Ethernet пакет, у которого есть MAC адрес,
[13:51.860 --> 13:57.220]  но здесь уже MAC адрес привязан уже жестко к конкретному компьютеру и особо нам не
[13:57.220 --> 14:02.820]  интересен. Ну и в конечном итоге нам присылают какой-то еще ответ, который точно так же можно
[14:02.820 --> 14:13.540]  наблюдать. Как обычный плентекст, вот то, что нам прислали. Понятно, что вся информация,
[14:13.540 --> 14:23.060]  если я ее вижу wireshark, значит все то же самое видят те, кто сидят за маршрутизаторами всех
[14:23.060 --> 14:28.660]  уровней. То есть вы фактически передаете данные открытым текстом и никакой приватности,
[14:28.660 --> 14:34.660]  безопасности речи в принципе не идет. Давайте теперь я это все очищу и
[14:34.660 --> 14:57.540]  сделаем все то же самое, но уже через протокол SSL. OpenSSL as client connect,
[14:57.540 --> 15:12.180]  тот же самый для честности example.com or 443. Тоже самое напишу строчку get-htp11, host-example.com.
[15:12.180 --> 15:22.140]  Получает точно такой же ответ, но если посмотреть на вывод в том же wireshark,
[15:22.140 --> 15:31.780]  что у нас происходит? У нас происходит установка соединения. Дальше мы отправляем заголовок уже
[15:31.780 --> 15:41.460]  некоторого протокола TLS, он же SSL, это просто два разных названия, двое тоже протокола. Дальше
[15:41.460 --> 15:50.820]  взаимодействия, обмен сертификатами и когда речь доходит до HTTP в самом конце, где-то мы
[15:50.860 --> 15:59.500]  отправляем application data, что мы видим? Мы видим просто какой-то application data и какой-то мусор. Узнать,
[15:59.500 --> 16:04.940]  что мы реально передаем, ни на каких уровнях здесь уже невозможно. Понять это может только тот сервер,
[16:04.940 --> 16:15.820]  которым мы отправляем данные. И по дороге нет способа как это все разобрать. Для этого как раз
[16:15.820 --> 16:21.980]  предназначаются безопасные соединения, которые называются, правильным словом, transport player
[16:21.980 --> 16:30.820]  security. Этот стандарт TLS. Почему я говорю, что есть синоним SSL? Потому что SSL это вообще зарегистрированный
[16:30.820 --> 16:37.740]  товарный знак некоторой компании Neatscape, которая была кем-то куплена, потом наверняка еще
[16:37.740 --> 16:43.940]  раз кем-то куплена. Но исторически так называют, потому что многие библиотеки называются SSL. Фактически
[16:43.940 --> 16:51.260]  одно и то же, только TLS это открытый стандарт. Как вообще можно взаимодействовать по протоколу TLS,
[16:51.260 --> 16:58.260]  либо SSL? В случае протокола HTTP есть просто приговоренность, что используется отдельный
[16:58.260 --> 17:05.860]  номер порта. То есть телнетом я подключаюсь к порту номер 80 и текстом взаимодействую. А если я
[17:05.860 --> 17:11.660]  хочу взаимодействовать с защищенным протоколом HTTPS, то здесь уже приходится использовать другой
[17:11.660 --> 17:18.540]  отдельный порт 443, и тем самым мы не перепутаем, что мы хотим взаимодействовать по другому протоколу.
[17:18.540 --> 17:33.660]  Порты меньше тысячи. Если они открываются на сервере, то их можно открыть. Есть два способа.
[17:33.660 --> 17:43.180]  Первый способ простой небезопасный. Это просто запускать сервер с правами root, хотя это небезопасно,
[17:43.180 --> 17:50.460]  но единственное, где это может быть использовано, это запускать, например, с ssh сервер. И второй способ,
[17:50.460 --> 17:57.740]  это локально для выполнения операции bind, делать повышение привилегий для того, чтобы связать
[17:57.740 --> 18:05.100]  с портом. Как вообще в общем случае это можно сделать? Хороший вопрос. Поскольку у нас сервера обычно
[18:05.100 --> 18:11.180]  запускаются непривилегированные, то как сделать реализацию сервера, которые работают на порту
[18:11.180 --> 18:22.220]  меньше тысячи? Есть так называемый сет user ID flag. Например, его можно наблюдать у некоторых
[18:22.220 --> 18:27.100]  команд, например, классическая команда sudo.
[18:27.100 --> 18:52.860]  Давайте посмотрим на usr bind sudo, какие у нее права. Чтение запись выполнения для владельца и
[18:52.860 --> 18:59.820]  чтение выполнений для всех остальных. И еще вот стоит такой флаг под названием s, который называется
[18:59.820 --> 19:06.380]  sticky bit. А что этот флаг означает? Это означает, что программа, исполняемый файл, который в составе
[19:06.380 --> 19:15.660]  sticky bit, всегда запускается из-под того же пользователя, в данном случае root, который является
[19:15.660 --> 19:25.260]  владельцем данной программы. То есть, как можно безопасно открыть порт, который явно меньше
[19:25.260 --> 19:31.180]  тысячи, и при этом сам процесс запускать не с правами рута? Вы можете написать вспомогательную
[19:31.180 --> 19:38.780]  программу helper, которая выполняет ровно одно действие, вызывает системный вызов bind.
[19:38.860 --> 19:47.100]  Почему мы можем вызвать bind из какой-нибудь дочерней программы, передав ей койнт номер socket?
[19:47.100 --> 19:52.660]  Потому что, когда вы запускаете дочерний процесс, файловый дескриптор у нас наследуется. И файловые
[19:52.660 --> 19:57.860]  дескрипторы связаны с каким-то объектом, который в ядре персональной системы работает
[19:57.860 --> 20:05.940]  одинамаково для всех. То есть, локальное решение есть библиотека, которая использует как раз такой
[20:05.940 --> 20:15.460]  подход и выполняет только bind. Я сейчас сходу не вспомню, как это называется. Но она используется
[20:15.460 --> 20:21.940]  многими веб-службами, хотя никто не мешает на вам ручками написать. В общем, общий подход как
[20:21.940 --> 20:28.940]  открыть порт с портом меньше тысячи. Вы запускаете дочерний процесс, и в нем запускаете через exec
[20:28.940 --> 20:39.140]  маленькую программку, у которой стоит setUserIdFlag стикибит. Это не стикибит, это
[20:39.140 --> 20:47.820]  называется suidflag, setUserId. Выставляет setUserIdFlag, и она выполняет только операцию bind на
[20:47.820 --> 20:52.500]  файловый дескриптор с определенным номером. И связывает его с определенным номером порта.
[20:52.500 --> 21:01.020]  И завершает свою работу. Поэтому весь сервер у вас может работать без рута дальше, и все достаточно
[21:01.020 --> 21:13.780]  безопасно. У нас есть 80-й порт для HTTP, 440 для HTTPS. В некоторых случаях вы можете не открывать
[21:13.780 --> 21:19.620]  отдельный порт, если вам требуется защищенное соединение. Например, протокол почтового сервера,
[21:19.620 --> 21:25.260]  он поразумевает, что вы в текстовом виде начинаете эмоциировать тлс-сессию просто
[21:26.660 --> 21:32.100]  отдельной командой для переключения в режим тлс. Здесь как вы договоритесь, так и исключите.
[21:32.100 --> 21:42.380]  Зачем это бывает нужно? Мы могли наблюдать через Wireshark, что у нас данные теперь перехватить
[21:42.380 --> 21:48.420]  в принципе никак невозможно. А для чего наши данные могут перехватывать? Во-первых, если мы
[21:48.740 --> 21:56.740]  заедем в кафе Теория, там есть бесплатный Wi-Fi. Он без пароля. Чем плох Wi-Fi без пароля, кто знает?
[21:56.740 --> 22:07.740]  Ну, казалось бы, да. Там требуется авторизация, нужно один раз ввести номер телефона и подтвердить
[22:07.740 --> 22:12.900]  мак-адрес. Тем не менее, Wi-Fi без пароля подозревает, что шифрование данных вообще в принципе не
[22:12.900 --> 22:20.220]  используется. И данные в пределах этой кафешки летают в не зашифрованном виде. Запускайте
[22:20.220 --> 22:30.380]  снифер и начнете раздвигаться. Второй момент, в московское метро. Что? В программе Wireshark? Да, нет.
[22:30.380 --> 22:35.460]  Но чтобы Wi-Fi ловить, вам еще дополнительные тулзы нужны, чтобы прослушивать именно трафик.
[22:35.460 --> 22:44.620]  Для телефонов такое есть. Во-вторых, в московское метро бесплатное. Сейчас они вроде бы поправили,
[22:44.620 --> 22:52.620]  раньше, точнее сейчас не только поправили, в московском метро стало бесполезно. Так же,
[22:52.620 --> 22:59.940]  как и некоторые нехорошие мобильные операторы, не буду называть их названия, любили подмешивать
[22:59.940 --> 23:07.860]  свою рекламу в обычный Http-трафик. При этом иногда ломался ежимая страница, падла сверсь,
[23:07.860 --> 23:13.820]  невозможно пользоваться. Плюс есть некоторые протоколы, которые поверх Http, например,
[23:13.820 --> 23:21.340]  Microsoft Exchange Server работает. Тоже они выдавали кучу ошибок. Ну и банальное шифрование данных,
[23:21.340 --> 23:31.660]  оно всегда полезно, чтобы никто не подглядывал. Поэтому сейчас очень сложно встретить ресурсы,
[23:31.660 --> 23:37.420]  которые работают только, например, протокол Http без шифрования. Есть только Example.com,
[23:37.420 --> 23:43.180]  поскольку его назначение так раз демонстрировать, как устроен интернет. Все остальные ресурсы уже
[23:43.180 --> 23:48.580]  давно перешли на Http с принудительным образом. Причем стало это возможным относительно недавно,
[23:48.580 --> 23:54.540]  почему все ресурсы перешли на зашифрованный протокол. До этого сертификаты стоили достаточно
[23:54.540 --> 24:03.020]  ощутимых денег, и нужно было их покупать за деньги. И на самом деле многие делали деньги из воздуха,
[24:03.020 --> 24:09.660]  просто продавая сертификаты. Сейчас можно купить на бесплатном ресурсе Ветсенкрипт, даже не купить,
[24:09.660 --> 24:15.100]  а бесплатно получить для своего ресурса. И бесплатная польза, например, на Еджа же стоит,
[24:15.100 --> 24:27.660]  денег не просят, вполне себе безопасна работа. Что такое Http? Я про это напомню. Для шифрования
[24:27.660 --> 24:33.220]  вот протокол Http требуется специальный сертификат, который является кем-то подписанным. Я чуть позже
[24:33.220 --> 24:38.140]  расскажу, зачем он вообще нужен. Хотя в общем случае, на самом деле, с технической точки зрения,
[24:38.140 --> 24:44.460]  он не нужен. Если вы доверяете самоподписанному сертификату, который вы сами выпустили на
[24:44.460 --> 24:50.380]  своем сервере, раскидали по своим ресурсам, по своим клиентам, этого вполне достаточно. Но на
[24:50.380 --> 24:56.420]  общей публике вы должны кому-то доверять. Теперь краткий обзор, какие вообще бывают
[24:56.420 --> 25:02.380]  криптографические алгоритмы. Они бывают в трех разных видов. Во-первых, это алгоритмы,
[25:02.380 --> 25:10.700]  которые по какому-то блоку исходных данных произвольного размера строят блок данных
[25:10.700 --> 25:18.700]  какой-то фиксированного размера и получают просто некоторое число определенного размера.
[25:18.700 --> 25:27.100]  Например, бит четности. Это тоже в какой-то мере криптографический алгоритм, который по произвольному
[25:27.100 --> 25:32.940]  биту данных, под произвольным данным говорит, четная получается ваша сумма или не четная. Это
[25:32.940 --> 25:40.860]  простейшая хэш-функция. Есть хэш-функция более сложная CRC32, которая обычно используется для
[25:40.860 --> 25:49.260]  контроля целостности файла и более популярные MD5 и SHA. Что это за функции такие, как ими
[25:49.260 --> 26:03.460]  пользоваться? В большинстве дистрибутивов есть вот такие команды, например, MD5SUM или SHA256SUM,
[26:03.460 --> 26:15.180]  которые по произвольному файлу считают какое-то число. SHA еще 512 бывает.
[26:15.180 --> 26:25.540]  Так, технологий программирования у вас были, да? Вот такие длинные цифры. Где эти вам раньше
[26:25.540 --> 26:42.540]  встречались технологии в программировании? Не только токен, а еще у гита используется SHA256 для того,
[26:42.540 --> 26:50.460]  чтобы однозначно определить какой-то конкретный комит. Точнее у гитхаба, у гита, там он сокращается,
[26:50.460 --> 26:57.020]  то есть средняя часть вырезается. Можно по сокращенному варианту первые и последние цифры
[26:57.020 --> 27:03.300]  достать, но в случае, если есть неоднозначность, то можно полностью написать полную длину хэша.
[27:03.300 --> 27:16.900]  Ну да, то есть очень высокая вероятность, что хэш будет уникальным, если взять только его
[27:16.900 --> 27:23.620]  начальные цифры и конечные цифры, но если он не уникальный, то можно в дите по крайней мере
[27:23.620 --> 27:31.540]  использовать полную хэш. Так вот, что такое хэш? Это некоторое значение, которое всегда является
[27:31.540 --> 27:41.620]  уникальным для разных дан. На счет всегда, тут на самом деле это не совсем так, поскольку мы никак не
[27:41.620 --> 27:49.420]  можем взять из хэша обратно данные, восстановить и поставить строго точное соответствие. И понятно,
[27:49.420 --> 27:57.380]  что есть возможные комбинации. Например, для алгоритма MD5 у нас два в 128 степени разных комбинаций
[27:57.380 --> 28:03.100]  вообще всех любых объемов данных, которые только могут быть. Понятно, что есть какая-то вероятность,
[28:03.100 --> 28:10.940]  что для двух разных данных, разных кусков данных у нас получится одинаковый хэш. Такие ситуации
[28:10.940 --> 28:18.820]  называют хэш-коллизиями, и чем больше у нас длина хэша, тем меньше вероятность хэш-коллизии.
[28:18.820 --> 28:26.620]  И есть отдельные задачи для хакеров. Это нахождение осмысленных каких-то одинаковых данных,
[28:26.620 --> 28:33.060]  для которых хэши совпадают. Такое решение, задача называется компрометацией хэш-алгоритма.
[28:33.060 --> 28:41.100]  MD5 уже давно скомпрометирован, то есть подобраны такие данные, для которых хэши совпадают.
[28:41.100 --> 28:46.540]  Для SECHE256, я не помню, для неосмысленных каких-то рандомных данных это подобрано,
[28:46.540 --> 28:53.660]  для осмысленных пока еще нет. Для SECHE512 пока еще нет. То есть это считается устойчивым,
[28:53.660 --> 29:01.340]  не взломанным хэш-алгоритмом. То есть мы можем гарантировать, что если у вас данные совпадают,
[29:01.340 --> 29:08.300]  то хэши их совпадают. Где на практике используется хэш-сумма? Например, скачать какой-нибудь
[29:08.300 --> 29:14.980]  дистрибутив, рядом обычно с большим файлом лежит контрольная сумма по одному из алгоритмов,
[29:14.980 --> 29:22.460]  fmd5 либо SECHE256. Для чего она нужна? Для того, чтобы посчитать локально контрольную сумму и удостовериться,
[29:22.460 --> 29:28.460]  что во-первых, файл не был поврежден при скачивании и скачался полностью до конца. Во-вторых,
[29:28.460 --> 29:33.740]  чтобы скачали его из правильного источника, он не модифицировал. Например, если это код из зеркала.
[29:33.740 --> 29:45.260]  И еще один способ применения – это файл с базой данных пользователей и паролей,
[29:45.260 --> 29:53.500]  и tc-паспорт. В современных UNIX-системах он, конечно, не хранится паролей одновременно, но можно
[29:53.500 --> 30:01.220]  посмотреть на файл tc-shadow, который хранит только пароли. Он, правда, доступен только из-под рта
[30:01.220 --> 30:10.580]  для увеличения безопасности. И по какому-то из алгоритмов хэширования, я уже не помню какой
[30:10.580 --> 30:23.980]  здесь у меня, в большинстве случаев это какой-нибудь blowfish, хранится пароль. Можете ли вы восстановить
[30:23.980 --> 30:29.820]  мой пароль на этой системе? Наверное, это возможно только методом прямого перебора,
[30:29.820 --> 30:37.860]  что займет очень много непозвонительного времени. Хэши обычно используются в межных целях, в том числе
[30:37.860 --> 30:48.740]  для того, чтобы хранить пароли. Можно использовать в том числе алгоритм md5. Для этих целей его обычно
[30:48.740 --> 30:56.260]  бывает вполне достаточно, не обязательно использовать с lch. Допустим, у меня есть пользователь Вася,
[30:56.260 --> 31:06.700]  который хочет слагониться в систему. Что должна сделать система? Кроме команд md5 есть аналогичная
[31:06.700 --> 31:13.620]  команда в составе фреймворка OpenSSL, которая работает похожим образом. Закодируем какой-нибудь
[31:13.620 --> 31:26.500]  пароль, например, самый популярный пароль qwerty и направим в пателете md5. Если пользователь вводит
[31:26.500 --> 31:32.980]  пароль qwerty, для него вычисляется какой-то хэш. Этот хэш один раз может храниться как правильный,
[31:32.980 --> 31:39.580]  потом пользователь, например, входит с неправильным паролем. Что у него будет? У него будет какой-то
[31:39.580 --> 31:45.660]  другой хэш. И сравнивая только хэши, можно принимать решение о том, допускаем мы пользователя
[31:45.660 --> 31:54.500]  систему или не допускаем. И по хэшу обратно декодировать пароль у нас не получится. Кстати,
[31:54.500 --> 32:03.860]  вот в нулевые годы по телевизору зомбоящиков как-то в новостях активно педалировали всякие дурацкие
[32:03.860 --> 32:09.620]  абсолютно новости. Например, о том, что какой-то школьник сделал супер крутую мега операционную
[32:09.620 --> 32:15.580]  систему сейчас Windows станет нужда, слава России. Что операционная система себя представляла?
[32:15.580 --> 32:21.260]  Назвалась на BOLGNVS. Куча мемасиков про нее в интернете распространилась, может даже и живые.
[32:21.260 --> 32:31.060]  Просто убонту с другими нескучными обои. Одна из новостей в контексте таких же новостей,
[32:31.060 --> 32:36.100]  которые журналисты пиарят, сами не понимают техническую составляющую, какой-нибудь школьник
[32:36.100 --> 32:43.460]  российский сделал супер мега софт архиватор, который сжимает очень сильно. Архиватор имеется
[32:43.460 --> 32:53.860]  в виду обычные утилиты хэширов. Понятно, что это все ерунда, верить такому нельзя, и по 128-битному
[32:53.860 --> 32:59.580]  значению нельзя декодировать обратно какие-то произвольные данные. Здесь, возможно,
[32:59.580 --> 33:10.300]  трансляция данных только в одну сторону. Допустим, у нас есть база паролей, вида, что есть
[33:13.700 --> 33:19.460]  я сделаю свою базу паролей, по названию, что есть пользователь с ID 1000, которого зовут Вася,
[33:19.460 --> 33:27.020]  у которого пароль вот такой-то. Как ты захэшировал? Пользователь с ID такой-то, по названиям Петя,
[33:27.020 --> 33:40.500]  у которого хэш какой-нибудь, например, вот такой.
[33:43.620 --> 33:50.020]  Казалось бы, хорошая безопасная система хранения паролей, согласна? И, например, есть пользователь
[33:50.020 --> 33:59.540]  под названием Admin, который может делать все что угодно, даже пользователь root. И так случайно
[33:59.540 --> 34:10.660]  совпало, совершенно случайно, что пароль хэш вот такой, что злоумысленник может,
[34:10.660 --> 34:15.700]  получивший доступ к этому файлу, сказать про пользователя root.
[34:15.700 --> 34:27.980]  Да, злоумысленник может понять, что есть пользователь Вася, можно подойти к Вася,
[34:27.980 --> 34:34.580]  сказать Вася, скажи пароль. Если Вася не хочет говорить пароль, можно на Вася как-то воздействовать,
[34:34.580 --> 34:44.700]  материально, физически, еще как-нибудь, и добыть пароль Вася. Если мы добудем пароль Вася, то что
[34:44.700 --> 34:53.140]  получается? Мы добыли пароль root. Такая система явно небезопасная, и для рандомизации какой-то
[34:53.140 --> 35:02.380]  хэшей обычно дополнительно используется какое-то еще одно значение. Что мы можем здесь, как мы можем
[35:02.380 --> 35:08.900]  эту ситуацию исправить, чтобы гарантировать, что даже при одинаковых паролях у нас всегда будут разные хэши.
[35:08.900 --> 35:19.060]  Дописывать какое-то уникальное для каждого из пользователей значение до хэширования,
[35:19.060 --> 35:25.460]  и считать это частью пароля, используя какой-нибудь нелегальный символ, который им не в пароли не может
[35:25.460 --> 35:37.540]  встречаться. Например, user ID, либо имя пользователя. Если мы хэшируем пароль не просто qwerty, а qwerty
[35:41.540 --> 35:51.900]  собака Вася, то мы получим один хэш, qwerty собака root, какой-нибудь другой хэш. Они
[35:51.900 --> 35:59.860]  гарантированно будут различаться, и вот такая операция по добавлению к данным каких-то дополнительных
[35:59.860 --> 36:05.460]  сведений для того, чтобы сделать их более разнообразным, называется добавление соли.
[36:05.460 --> 36:13.020]  Солью мы еще чуть дальше более подробно обсудим, когда будем использовать блокчина эшифрования.
[36:13.020 --> 36:26.900]  В Linux в дистрибутивах обычно этот файл защищен, во FreeBSD, насколько я помню, он не защищен.
[36:26.900 --> 36:37.140]  В Linux хранится в отдельном файле, на счет FreeBSD не помню. Обычно тоже делается запрет на
[36:37.140 --> 36:43.260]  доступ, но кроме обычной базы пароля в Unix бывают разные другие стемы авторизации, где можно
[36:43.260 --> 36:49.940]  достаточно легко получить доступ. Банально в базе данных SQL доступ пользователя к сайту, если вы
[36:49.940 --> 36:56.380]  получили доступ к базе данных, если какой-нибудь пользователь, задача которого выполнять по счету
[36:56.380 --> 37:04.220]  статистики или выполнять обслуживание базы данных, то все равно у вас есть какой-то доступ к паролям,
[37:04.220 --> 37:12.180]  потому что у вас есть доступ к базе данных. И если вы храните пароли плейнтекстом, ну некоторые так и делают,
[37:12.180 --> 37:19.140]  да, я думаю, если почитаете хаббор, поиск по информационной безопасности, будет описание
[37:19.140 --> 37:25.540]  многих разных кейсов, когда реально хранятся пароли плейнтекстом и каким последствиям это приводит.
[37:25.540 --> 37:33.260]  Просто вот из-за банальной глупости. Если хотя бы хэшировать, тогда уже такой глупости не возникает.
[37:33.260 --> 37:51.940]  Если вы хэшируете не только пароль, но пароль с добавлением соли, то такой проблемы нет.
[37:51.940 --> 37:59.140]  Более того, есть разные движки, типовые там Django, например, или какие-нибудь движки там типа WordPress.
[37:59.140 --> 38:08.220]  Типовой софт, который имеет свою какую-то базу данных использовать. И там обычно есть еще при установке
[38:08.220 --> 38:14.100]  генерации своего рандомного токена, который хранится строго закодирован для конкретного сервера,
[38:14.100 --> 38:20.100]  на тот случай, если пользователь вдруг с одинаковым именем, одинаковым паролем, будет регистрироваться
[38:20.100 --> 38:25.820]  в разных сервисах на одном и том же движке, чтобы добавить еще какую-то соль дополнительную уже
[38:25.820 --> 38:39.660]  привязку. Совпадающие хэши это как раз в зависимости от того, какой хэш вы выберете. Как раз хорошая хэш-функция,
[38:39.660 --> 38:45.260]  идеальная хэш-функция, она подразумевает, что для разных данных у вас будут всегда генерироваться
[38:45.260 --> 38:50.660]  разные хэши. Поэтому такая вероятность, она стремится к нулю. Если вы используете SCE 512,
[38:50.660 --> 38:56.340]  то очень малая вероятность, что на 10 миллионов пользователей у вас такая ситуация возникнет.
[38:56.340 --> 39:02.660]  То есть понятно, что если вы выбраете MD5, такая вероятность повышается. 512 битных ключей с
[39:02.660 --> 39:08.300]  LTE, свою проблему уже не должно возникнуть. И об этом можно не заморачиваться с практически точки
[39:08.300 --> 39:17.580]  зрения. Хотя, если будут кланаты вычисления доступные, тогда все пропало. Это то, что было
[39:17.580 --> 39:23.980]  про хэш-функции. Что такое хэш-функции с алгоритмической точки зрения? Я думаю,
[39:23.980 --> 39:28.900]  на алгоритмах вам рассказываю, как они реализуются. Тут плюс-минус все стандартно.
[39:28.900 --> 39:38.140]  Другой класс алгоритмов – это блочное шифрование. Причем для них может использоваться некоторый
[39:38.140 --> 39:44.220]  симметричный ключ. Что такое блочное шифрование? Это когда вы бьете данные на блоки код фиксированного
[39:44.220 --> 39:52.100]  размера и каждому из блоков применяете какое-то преобразование. Одним из самых простых преобразований
[39:52.100 --> 39:58.780]  является шифр Цезаря с ключом. Бывает, кстати, блочное шифрование не обязательно подразумевает,
[39:58.780 --> 40:08.780]  что вы используете какой-то шифр, подразумевающий наличие ключа. Давайте сделаем какой-нибудь файлик,
[40:08.780 --> 40:16.780]  чтобы было с чем работать HelloText. Этот файлик теперь с помощью утилита OpenSSL закодируем во
[40:16.780 --> 40:24.380]  что-нибудь. Кодирование и декодирование OpenSSL вставляется командой Yank. Кодирование прямой – это
[40:24.380 --> 40:35.780]  без двукоцин, минус D, это в обратную сторону. Закодируем с помощью шифра base64 наш файл HelloText.
[40:35.780 --> 40:52.900]  Закодируем полное название команды OpenSSL, закодировать. Дальше название шифра, например,
[40:52.900 --> 41:02.420]  base64. И in-out – это если не нужно работать с стандартом ввода, стандартом ввода. Да, в ридинг
[41:02.420 --> 41:07.820]  немного хабидно, подробно описаны все команды, которые вам понадобятся. И вот получаем какую-то
[41:07.820 --> 41:18.620]  штуку. В чем особенность этой штуки? Эту штуку я могу теперь обратно декодировать, указывая тот
[41:18.620 --> 41:26.740]  же самый алгоритм base64. Я не указываю теперь имя входного файла и в этом случае вторая часть
[41:26.740 --> 41:34.100]  команды OpenSSL, просто прочитая все стандартно потока ввода. И обязательно опцию минус D. И получаем
[41:34.100 --> 41:39.260]  обратно декодирование хлыб. И обратите внимание, что здесь у меня утилита OpenSSL не запрашивает
[41:39.260 --> 41:44.500]  пароль ни в каком виде, потому что бывают алгоритмы, которые ключ не требуют. Кстати,
[41:44.500 --> 41:51.500]  что за вывод такой? Получился S, G, V, S, B, G, 8K. На самом деле это просто какая-то последовательность
[41:51.500 --> 41:59.300]  латинских букв и цифр. В случае с текстовыми файлами это не особо осмыслено. А вот если я применю
[41:59.300 --> 42:11.260]  это к какому-то бинарному файлу, такое становится уже более осмысленным. Я получаю какой-то текст из
[42:11.260 --> 42:21.420]  abracadabra, который как-то даже красиво отформатирован, но содержит внутри себя только ограниченный
[42:21.420 --> 42:31.940]  набор кодировки ASCII. Для чего бывает полезен шифр BS64. Он сделал размер нашего файла намного больше,
[42:31.940 --> 42:40.700]  поскольку он использовал только 64 символа из ASCII. То есть каждому байту соответствует только 64
[42:40.700 --> 42:48.900]  элемента. Это понятно, что у нас очень сильно увеличивается объем данных, но зато мы можем теперь
[42:48.900 --> 42:54.660]  скопипасить вот это как обычный текст и использовать систему передачи данных,
[42:54.660 --> 43:03.100]  которые могут работать только с текстом. Например, электронная почта, как ни странно, это тоже текстовый
[43:03.100 --> 43:12.340]  протокол. Когда вы нажимаете в почтовом приложении приложить файл, файл кодируется одним из образов
[43:12.340 --> 43:19.020]  либо OE, либо BS64, и дальше таким плейнтекстом вставляется содержимое вашего письма как приложение.
[43:19.020 --> 43:26.940]  Везде, где нужно использовать передачу текста, BS64 позволяет закодировать данные так, чтобы они
[43:26.940 --> 43:32.980]  гарантированно не повредились, неважно какая у вас кодировка, неважно как вы текст форматируете,
[43:32.980 --> 43:40.260]  все равно вы дальше обратно сможете восстановить ваш файл, и этот файл будет в точности до байта
[43:40.260 --> 43:50.380]  совпадать. Ну и все-таки более смысленно использовать BS64, это использовать
[43:50.380 --> 44:03.700]  блочное шифрование, это использовать какой-то из шифров, которые уже требуют ввода какого-то ключа.
[44:03.700 --> 44:14.100]  Минус IES, да, название, например, IES 256, это один из алгоритмов. Так, здесь уже требуется ввести
[44:14.100 --> 44:26.060]  какой-то пароль, например, самый популярный пароль, и получаем какой-то мусор винарный,
[44:26.060 --> 44:30.380]  с которым можем дальше что-то сделать, например, сохранить
[44:30.380 --> 44:41.860]  какой-то зашифрованный файл. Так, вот я еще, так, выбираю QRT.
[44:41.860 --> 44:52.100]  Ну и вообще-то теперь, у меня получился файл примерно такого же размера, на самом деле,
[44:52.180 --> 44:59.740]  не совсем такого же. И что я могу с этим файлом сделать? Я могу теперь выполнить к нему обратную
[44:59.740 --> 45:08.660]  операцию. Так, в качестве входного файла я указываю это Hello Young, минус D чтобы делать обратно,
[45:08.660 --> 45:15.020]  но поскольку у меня ожидается текстовый вывод, я не указываю имя выходного файла. Так, теперь,
[45:15.020 --> 45:23.140]  если я ввожу правильный пароль, то я получаю содержимое этого файла. Все хорошо, все замечательно.
[45:23.140 --> 45:30.740]  Так, если я ввожу неправильный пароль, то я получаю некоторую ошибку, причем здесь,
[45:30.740 --> 45:36.980]  в зависимости от того, какой алгоритм используется, мы можем либо поймать эту ошибку на
[45:36.980 --> 45:42.860]  стадии декодирования, либо получить просто неправильный ответ. Например, вот классический
[45:42.860 --> 45:48.380]  шифр Цезаря со сдвигом там на определенное количество символов, он не контролирует ошибки,
[45:48.380 --> 46:02.060]  но получается какой-то мусор. А ворнинг кидают? Депракейка и деривейшн. У меня просто в поставке
[46:03.060 --> 46:16.740]  не стоит утилита для проверки паролей по словарю. Это, кстати, кидается в поток ошибок,
[46:16.740 --> 46:25.180]  поэтому он не будет записан в файл. Такие у нас бывают наиболее популярные криптографические
[46:25.420 --> 46:32.780]  на самом деле их много, но исторически одним из первых и когда-то популярных был алгоритм ДЭС,
[46:32.780 --> 46:41.580]  когда-то его даже студентов заставляли писать его реализацию. Сейчас используется в основном
[46:41.580 --> 46:52.580]  один из двух, либо алгоритм АЕС, это американский, но и его аналог под названием Ghost 3412-2015,
[46:52.580 --> 46:58.860]  но просто потому что у нас в России требуется в некоторых случаях использовать российский
[46:58.860 --> 47:03.180]  криптографический алгоритм. Там где-то требуется, там используется алгоритм Ghost и вообще его называют
[47:03.180 --> 47:09.220]  кузнецик. На самом деле они работают по одному и тому же принципу. У вас данные бьются на блоки
[47:09.220 --> 47:18.860]  фиксированного размера, каждому блоку по отдельности применяется некоторая последовательность операций
[47:18.860 --> 47:27.420]  из применения ключа по какой-то схеме со сдвигами, по разрядным операциям и так далее.
[47:27.420 --> 47:35.060]  Причем для каждого блока применяется несколько раз несколько итераций применения ключа из
[47:35.060 --> 47:42.620]  входного блока, называется один раунд, обычных несколько раундов и все это потом сохраняется в
[47:42.620 --> 47:50.220]  качестве итогового результата. И причем здесь очень важно, что для криптографических алгоритмов
[47:50.220 --> 47:57.380]  с симметричным ключом эта операция является обратимой, если вы знаете ключ. Какие есть параметры
[47:57.380 --> 48:07.940]  у алгоритмов с симметричным ключом? Самый главный параметр это размер блока, он же размер ключа,
[48:07.940 --> 48:14.700]  и этот параметр фигурирует в частности по названию алгоритма AES-256. Здесь подразумевается ключ
[48:14.700 --> 48:21.100]  размером 256 бит. Чем больше у вас размер ключа, тем более стойкий у вас алгоритм шифрования.
[48:21.100 --> 48:34.220]  Можно посмотреть с помощью команды pencil-eng, swifters или еще более простой это лист. Вот такая
[48:34.220 --> 48:41.540]  команда отображает список всех поддерживаемых в данной поставке OpenSSL алгоритмов шифрования.
[48:41.540 --> 48:49.020]  Причем в разных дистрибутивах, в разных системах они могут быть разными. Например, в Debian это один
[48:49.020 --> 48:55.660]  список, российский Alt Linux, Astro Linux или еще что-нибудь, там еще наверняка будет какой-нибудь
[48:55.660 --> 49:06.700]  алгоритм Ghost, например в Mac тоже. Не странно, в Mac поддержка Госта, правда 89 года тоже есть,
[49:06.700 --> 49:18.540]  а более современный по-моему здесь отсутствует. Что еще есть у алгоритмов шифрования из параметров,
[49:18.540 --> 49:25.460]  кроме того, какой разрядность ключа они используют. Даже у одного и того же алгоритма AES,
[49:26.260 --> 49:40.940]  256. Есть разные вариации по кодируем. CFB, CTR и ECB. Что это такое? Это способы, как у нас применяются
[49:40.940 --> 49:50.700]  данные к разным блокам шифрования. Здесь возникает некоторая проблемка о том, как мы включаем камеру.
[49:56.460 --> 50:06.500]  Надеюсь, что-то будет видно на этой доске. Так, если не видно, говорите. Давайте закодируем
[50:06.500 --> 50:13.380]  какую-то последность данных. Я постараюсь пожирнее рисовать. Видно что-нибудь? Вот у нас есть блок данных.
[50:19.500 --> 50:24.660]  Или не видно? Похоже, это потрачено.
[50:25.460 --> 50:30.020]  Так, тогда будем учиться рисовать на доске.
[50:47.260 --> 50:48.740]  Вот у нас есть какой-то блок данных.
[50:48.740 --> 50:58.460]  Мы бьем его на какие-то кусочки равного размера. Так, мы знаем какой-то ключ.
[50:58.460 --> 51:06.820]  Теперь, как мы получаем подходу к данным? У нас есть ключик. Мы каждому блоку применяем
[51:06.820 --> 51:18.900]  вот этот ключик. На выходе получаем какой-то результат. Раз блок, два блок вместе с ключиком.
[51:18.900 --> 51:33.900]  Куча независимых кусочков. Вот такой алгоритм шифрования называется ECB, он же электроник код-боку.
[51:33.980 --> 51:46.740]  Чем такой способ кодирования хорош? У нас каждый блок, по сути, независимо при чем, кодируется как
[51:46.740 --> 51:52.980]  отдельный блок данных. Чем это хорошо? Тем, что вы можете пропустить огромное количество данных,
[51:52.980 --> 52:01.140]  и вам не обязательно декодировать все до начала. Взять и зашифровать, либо разшифровать,
[52:01.140 --> 52:11.220]  только один кусочек. И середина. Да, вы можете этот поток просто пропустить,
[52:11.220 --> 52:22.780]  но зная какие у вас есть предыдущие куски, если вы знаете хотя бы один кусок, либо вы знаете
[52:22.780 --> 52:30.300]  какую-то закономерность, то вы можете легко зашифровать. Есть классическая картинка по этому
[52:30.300 --> 52:34.780]  поводу, которая называется ECB-пингвин.
[52:34.780 --> 53:01.860]  Вот, пингвинчик исходный.
[53:04.780 --> 53:13.580]  И что будет, если мы будем применять вот такое алгоритм шифрования к нашей картинке? Понятно,
[53:13.580 --> 53:20.980]  что мы данные испортим, и картинка станет не похожа на то, чтобы она стала другой. Мы кучу
[53:20.980 --> 53:26.260]  данных потеряли. Мы потеряли данных о том, какие тут цвета, некоторая точность пикселей и так далее.
[53:26.260 --> 53:31.740]  Но в целом очертания пингвинов здесь видите? Да, в целом очертания пингвина наблюдать можно,
[53:31.740 --> 53:38.380]  и это реальный use case, что происходит, если мы кодируем обычным IS с ECB, просто применяя там
[53:38.380 --> 53:48.260]  к отдельным пиксикам. В исходных статьях, где это все проводилось, там не png брали, там делали
[53:48.260 --> 53:57.980]  сохранение в текстовый файл, он назывался... В общем, есть форматы, которые прямо в тексте...
[53:57.980 --> 54:04.820]  А вот ppm называется. А ppm это просто текст, который выглядит... Там название сейчас...
[54:04.820 --> 54:14.460]  Короче, там текстовый файл, каждый пиксель, он отдельной строкой, это очень неоптимальный формат.
[54:14.460 --> 54:24.740]  Да, ну там просто как текст, там можно откусить заголовок и дальше просто уже... В общем,
[54:24.740 --> 54:32.100]  с разными вариациями можно получить просто поврежденные картинки, но все равно пингвин будет
[54:32.100 --> 54:38.740]  здесь прослеживаться. Просто за счет того, что мы используем какие-то знания о том, что каждый
[54:38.740 --> 54:42.580]  блок независимо кодируется, каждый блок независимо преобразуется во что-то другое,
[54:42.580 --> 54:48.500]  не похоже на исходное, но все равно в зависимости от ключа мы получаем в целом картинку очень похоже.
[54:48.500 --> 54:57.460]  Например, вот такая проблема при шифровании видеопотока очень хорошо себя проявляет.
[54:57.460 --> 55:04.300]  Если вы кодируете видеопоток, с одной стороны, да, вы легко можете начать его декодировать с середины,
[55:04.300 --> 55:11.700]  но дальше восстановить это до какой-то картинки, особенно если это видео, исходное не составляет
[55:11.700 --> 55:23.860]  никакого труда. Другой способ, который возможен, здесь просто каждая разная картинка, это разные ключи.
[55:23.860 --> 55:30.380]  То есть в зависимости от того, какой ключ, мы получаем просто разные вариации картинки,
[55:30.380 --> 55:34.860]  но при этом все равно чертание пингвина у нас всегда можно делать.
[55:34.860 --> 55:43.820]  Один блок, все-таки не один, пиксель, 256 бит можно достаточно много запихать,
[55:43.820 --> 55:49.820]  но просто пиксель и его окрестность. Все это дальше зависит от того, разрешающегося пространство этой картинки.
[55:49.820 --> 55:57.700]  Нет, на этих картинках, то, что здесь у меня, на экране здесь,
[55:57.700 --> 56:03.700]  каждой картинке соответствуют разные ключи, просто разные варианты, что у вас может получаться.
[56:04.540 --> 56:09.540]  То есть в зависимости от ключа вы получаете картинку с разными искажениями,
[56:09.540 --> 56:14.540]  но в целом от чертания пингвина вы наблюдать можете. Просто еще от того,
[56:14.540 --> 56:19.540]  что у вас каждый блок кодируется независимо друг от друга.
[56:20.380 --> 56:23.380]  Так, это можно поправить.
[56:25.380 --> 56:28.380]  Обложаем рисование тачпедом.
[56:31.380 --> 56:33.380]  Престираем это все.
[56:40.380 --> 56:42.380]  Теперь другой способ.
[56:43.220 --> 56:45.220]  Это елки.
[56:48.220 --> 56:51.220]  Кто знает, как в зуме рисовал?
[56:59.220 --> 57:01.220]  Рисуем.
[57:03.220 --> 57:06.220]  Бьем блок опять же на кусочки равного размера.
[57:07.220 --> 57:09.220]  У нас опять же есть ключ.
[57:10.060 --> 57:15.060]  Что мы можем сделать так, чтобы у нас блоки не зависели только от ключа?
[57:17.060 --> 57:19.060]  Решение достаточно простое.
[57:19.060 --> 57:25.060]  Мы можем применять ключ для вычисления блока.
[57:29.060 --> 57:34.060]  И помимо ключа вычисляем следующий блок.
[57:40.060 --> 57:42.060]  Хотим закодировать следующий.
[57:42.060 --> 57:44.060]  Что мы применяем?
[57:44.060 --> 57:49.060]  Мы применяем ключ и предыдущий блок.
[57:53.060 --> 57:55.060]  Либо какая-то статистика основанная.
[57:55.060 --> 57:57.060]  То есть есть два способа.
[57:57.060 --> 58:02.060]  Если использовать весь блок дорого, то можно хотя бы какую-то статистику,
[58:02.060 --> 58:04.060]  которую вы посчитали в предыдущем блоке.
[58:04.060 --> 58:06.060]  Не обязательно весь блок целиком.
[58:06.900 --> 58:10.900]  Мы зависим каждый раз от предыдущего вычисленного блока,
[58:10.900 --> 58:12.900]  который тоже участвует в кодировании.
[58:12.900 --> 58:16.900]  И тем самым у вас в зависимости от того, какие исходные данные,
[58:16.900 --> 58:20.900]  независимо от того, насколько у вас стойкий ключ,
[58:20.900 --> 58:26.900]  все равно увеличивается мусорность зашифрованных данных.
[58:26.900 --> 58:31.900]  И здесь уже вы не сможете даже общее чертание картинки никак восстановить.
[58:31.900 --> 58:33.900]  Но чем такой подход плох?
[58:34.740 --> 58:36.740]  Ну тоже понятно, почему он не всегда используется.
[58:36.740 --> 58:43.740]  Например, если вам нужно прочитать только среднюю часть,
[58:43.740 --> 58:51.740]  вам не нужно все это делать, то вам придется все равно декодировать все от самого начала,
[58:51.740 --> 58:53.740]  даже если сначала вам не нужно.
[58:53.740 --> 58:57.740]  Такой подход плох, например, для шифрования дисков.
[58:57.740 --> 59:01.740]  Поэтому для шифрования дисков это не используется.
[59:02.580 --> 59:04.580]  И здесь еще возникает одна особенность.
[59:04.580 --> 59:09.580]  Каждый последующий блок зависит от предыдущего и ключа.
[59:09.580 --> 59:11.580]  А самый первый блок что?
[59:13.580 --> 59:15.580]  Самый первый блок от ключа.
[59:15.580 --> 59:21.580]  На самом деле в такой ситуации есть некоторый начальный initialization vector.
[59:21.580 --> 59:27.580]  Понятие initialization vector надо запомнить, оно вам дальше пригодится при решении, в том числе, домашки.
[59:28.420 --> 59:32.420]  Ключ plus initialization vector это два числа,
[59:32.420 --> 59:38.420]  которые каким-то образом получаются с помощью хэширования из данных произвольного вида.
[59:38.420 --> 59:44.420]  И вот такой способ называется code block chaining.
[59:44.420 --> 59:50.420]  Одна из вариаций всех распространенных алгоритмов симметричного шифрования.
[59:52.420 --> 59:56.420]  Возвращаемся к обычному sharing без картинок.
[59:57.260 --> 59:59.260]  Списки этих всех алгоритмов.
[59:59.260 --> 01:00:01.260]  Тут есть разные вариации.
[01:00:01.260 --> 01:00:05.260]  IS, ECB это как раз независимое кодирование.
[01:00:05.260 --> 01:00:09.260]  IS, CBC это код блок чейнинг.
[01:00:09.260 --> 01:00:17.260]  IS, CTR, CFB это примерно то же самое, что CBC,
[01:00:17.260 --> 01:00:25.260]  но только вместо блока целиком используется просто статистика полученной на вычислении предыдущего блока.
[01:00:26.100 --> 01:00:32.100]  То же самое для алгоритмов DES.
[01:00:32.100 --> 01:00:38.100]  То же самое для алгоритмов GOST, ECB.
[01:00:38.100 --> 01:00:42.100]  GOST counter тоже подсчет по статистике.
[01:00:42.100 --> 01:00:48.100]  ECB, CNT, CBC нет у GOST.
[01:00:48.100 --> 01:00:52.100]  Просто GOST это алиас на какой-то из более сильных GOST.
[01:00:52.940 --> 01:00:58.940]  Вариация алгоритмов, когда у вас не указывается способ выбора блоков,
[01:00:58.940 --> 01:01:02.940]  это просто алиас более стойкого.
[01:01:06.940 --> 01:01:10.940]  Эта операция является обратимой для шифрования.
[01:01:10.940 --> 01:01:16.940]  Все же чем такой способ шифрования данных плох.
[01:01:16.940 --> 01:01:20.940]  Здесь вам всегда требуется некоторый ключик.
[01:01:21.780 --> 01:01:27.780]  Если у вас требуется какой-то ключ, то это уже возникает слабое место,
[01:01:27.780 --> 01:01:32.780]  потому что помимо передачи данных вы еще как-то должны передавать ключ в противоположной стороне,
[01:01:32.780 --> 01:01:36.780]  которая должна вашу данную разшифровывать.
[01:01:36.780 --> 01:01:39.780]  Ну и как вы этот ключ можете передать?
[01:01:39.780 --> 01:01:41.780]  Вы можете использовать какой-то побочный канал связи.
[01:01:41.780 --> 01:01:43.780]  Например, данные передаете по интернету,
[01:01:43.780 --> 01:01:45.780]  а ключ на какой-то защищенной флешке,
[01:01:45.780 --> 01:01:47.780]  в сопровождении солдат с автоматом,
[01:01:48.620 --> 01:01:52.620]  но солдат с автоматом тоже может стукнуть по башке и флешку отобрать.
[01:01:52.620 --> 01:01:53.620]  Это ненадежно.
[01:01:53.620 --> 01:01:55.620]  Точно так же, как любая бумажка.
[01:01:55.620 --> 01:01:59.620]  Все равно побочный канал связи тоже бывает ненадежным.
[01:02:03.620 --> 01:02:09.620]  Другой класс алгоритмов, который не заменяет полностью собой симметричные шифры,
[01:02:09.620 --> 01:02:11.620]  а дополняет его,
[01:02:11.620 --> 01:02:13.620]  это алгоритмы со симметричной парой ключей,
[01:02:13.620 --> 01:02:15.620]  когда у вас ключ состоит из двух частей.
[01:02:16.460 --> 01:02:19.460]  Одна из частей является открытой,
[01:02:19.460 --> 01:02:21.460]  а другая является закрытой.
[01:02:23.460 --> 01:02:25.460]  И вы делите ключ на две части.
[01:02:25.460 --> 01:02:28.460]  Одну часть передаваете в противоположной стороне,
[01:02:28.460 --> 01:02:30.460]  в том числе можете использовать какие-то открытые,
[01:02:30.460 --> 01:02:32.460]  не зашифрованные каналы передачи данных.
[01:02:32.460 --> 01:02:36.460]  А дальше используя противоположную часть ключа,
[01:02:36.460 --> 01:02:39.460]  вы данные только дешифруете.
[01:02:39.460 --> 01:02:43.460]  Ну и такой подход он используется практически повсеместно,
[01:02:44.300 --> 01:02:46.300]  в частности и в TLS, в подколе HTTPS.
[01:02:46.300 --> 01:02:48.300]  Вы же не договаривались с Яндексом о том,
[01:02:48.300 --> 01:02:53.300]  что вы получаете какую-то флешку с ключом для шифрования вашего персонала?
[01:02:53.300 --> 01:02:55.300]  Вообще нет.
[01:02:55.300 --> 01:02:57.300]  Здесь сначала выполняется согласование ключей,
[01:02:57.300 --> 01:02:59.300]  а потом уже шифрование данных.
[01:02:59.300 --> 01:03:01.300]  Ну и вот SSH, например, тоже.
[01:03:01.300 --> 01:03:07.300]  Кстати, я часто показываю, что я к виртуалке цепляюсь по SSH,
[01:03:07.300 --> 01:03:11.300]  и при этом я ни разу не ввожу парой.
[01:03:11.300 --> 01:03:13.300]  Как это вообще возможно?
[01:03:14.140 --> 01:03:20.140]  Есть паточка с сервертлогинами, которые руководят их за троллеймусом?
[01:03:22.140 --> 01:03:25.140]  Что это такое, что они себя представляют?
[01:03:25.140 --> 01:03:27.140]  Давайте показываю сначала.
[01:03:27.140 --> 01:03:34.140]  Вот есть такой каталог у текущего пользователя в домашнем каталоге SSH,
[01:03:34.140 --> 01:03:40.140]  в котором есть файлики IDRSA и IDRSAPAL.
[01:03:40.140 --> 01:03:42.140]  Это в случае клиента, вот эти два файла.
[01:03:42.980 --> 01:03:47.980]  Вот IDRSA его показывать не буду ни в коем случае,
[01:03:47.980 --> 01:03:53.980]  а IDRSA.PAP является публичным ключом,
[01:03:53.980 --> 01:03:56.980]  который в принципе разошелся.
[01:03:56.980 --> 01:03:59.980]  Вы когда заводили себе аккаунт на GitHub,
[01:03:59.980 --> 01:04:01.980]  вы тоже такой ключик создавали.
[01:04:01.980 --> 01:04:03.980]  Было дело такое.
[01:04:03.980 --> 01:04:05.980]  И вот эту часть, точнее вот этот весь текст,
[01:04:05.980 --> 01:04:07.980]  дальше копировали куда-то на GitHub.
[01:04:08.820 --> 01:04:11.820]  Точно так же вы можете на удаленном сервере
[01:04:13.820 --> 01:04:17.820]  сделать этот ключик.
[01:04:20.820 --> 01:04:22.820]  На удаленном сервере, куда хотите подключаться,
[01:04:22.820 --> 01:04:25.820]  там есть еще файлик по названию AuthorizedCase.
[01:04:29.820 --> 01:04:31.820]  Он тоже не является секретным.
[01:04:32.820 --> 01:04:37.820]  Туда вы просто добавляете отдельной строчкой каждый отдельный ключик.
[01:04:38.820 --> 01:04:40.820]  Публичный ключик.
[01:04:40.820 --> 01:04:42.820]  Что дальше происходит?
[01:04:42.820 --> 01:04:44.820]  Когда вы подключаетесь к серверу по SSH?
[01:04:44.820 --> 01:04:46.820]  Когда вы подключаетесь к серверу по SSH,
[01:04:46.820 --> 01:04:50.820]  то сервер, используя вот этот закрытый ключ,
[01:04:50.820 --> 01:04:52.820]  который соответствует вам,
[01:04:52.820 --> 01:04:54.820]  генерирует какую-то последняя часть данных
[01:04:54.820 --> 01:04:56.820]  и просит вас ее расшифровать.
[01:04:58.820 --> 01:05:00.820]  Если у вас, используя вашу приватную часть,
[01:05:00.820 --> 01:05:02.820]  расшифровать получается,
[01:05:02.820 --> 01:05:04.820]  то сервер вас пускает.
[01:05:04.820 --> 01:05:06.820]  Если не получается, значит не судьба.
[01:05:07.660 --> 01:05:09.660]  Это называется использование пары ключей.
[01:05:11.660 --> 01:05:13.660]  Работает эта штука примерно следующим образом.
[01:05:15.660 --> 01:05:19.660]  Я уже спрашивал у ИВТ-шников, знакомы ли им имена Ника и Вадим.
[01:05:21.660 --> 01:05:23.660]  Это студенты, которые уже отчислены.
[01:05:25.660 --> 01:05:27.660]  Когда-то читали с заданиями.
[01:05:30.660 --> 01:05:36.660]  Допустим, один товарищ хочет передать другому какие-то искреченные данные.
[01:05:37.660 --> 01:05:39.660]  Как это делается?
[01:05:39.660 --> 01:05:41.660]  Предварительно один товарищ, получая этот синенький,
[01:05:41.660 --> 01:05:43.660]  должен создать пару ключей.
[01:05:43.660 --> 01:05:45.660]  Обычно это делается при инициации сессии.
[01:05:45.660 --> 01:05:47.660]  Ключи генерируются рандомным образом.
[01:05:50.660 --> 01:05:52.660]  Дальше один ключик, который называется открытым,
[01:05:52.660 --> 01:05:54.660]  он передает для ошифрования в противоположной стороне,
[01:05:54.660 --> 01:05:56.660]  противоположная сторона ошифрует.
[01:05:56.660 --> 01:05:58.660]  А дальше для ошифровки используются уже две части.
[01:06:00.660 --> 01:06:02.660]  Во-первых, исходные данные, которые получили зашифрованные,
[01:06:02.660 --> 01:06:04.660]  и противоположная часть ключа.
[01:06:04.660 --> 01:06:06.660]  И получаем какие-то данные.
[01:06:07.500 --> 01:06:09.500]  Все хорошо, все замечательно.
[01:06:09.500 --> 01:06:11.500]  Все-таки слабое место здесь есть в этом взаимодействии.
[01:06:14.500 --> 01:06:16.500]  Ключ Е.
[01:06:16.500 --> 01:06:20.500]  Этот ключ может быть использован только для ошифрования.
[01:06:20.500 --> 01:06:22.500]  Для расшифровки он бесполезен.
[01:06:22.500 --> 01:06:24.500]  Даже если его кто-то перехватит,
[01:06:24.500 --> 01:06:26.500]  он не сможет данные декодировать.
[01:06:26.500 --> 01:06:28.500]  Зато можно подсунуть какие-нибудь фейковые данные.
[01:06:28.500 --> 01:06:30.500]  Что тоже не очень хорошо.
[01:06:31.340 --> 01:06:39.340]  Если кто-то подхватит этот ключ и сможет использовать его как фейковый,
[01:06:39.340 --> 01:06:41.340]  то можно подсунуть неправильные данные.
[01:06:41.340 --> 01:06:43.340]  Кто раньше данные отправит,
[01:06:43.340 --> 01:06:47.340]  то те данные будут использованы из жарки.
[01:06:51.340 --> 01:06:53.340]  Оба из них генерируют два файла,
[01:06:53.340 --> 01:06:55.340]  используя один и тот же открытый ключ,
[01:06:55.340 --> 01:06:57.340]  подписывают и отправляют.
[01:06:58.180 --> 01:07:00.180]  А дальше что мы получаем?
[01:07:00.180 --> 01:07:02.180]  Совершенно непонятно.
[01:07:02.180 --> 01:07:04.180]  И здесь уже дополнительным фактором безопасности
[01:07:04.180 --> 01:07:06.180]  является сертификат открытого ключа.
[01:07:06.180 --> 01:07:08.180]  Тот самый, который когда-то нужно было
[01:07:08.180 --> 01:07:10.180]  за приличные денежки покупать.
[01:07:10.180 --> 01:07:12.180]  Сейчас уже не обязательно за это платить.
[01:07:16.180 --> 01:07:18.180]  Точнее, для прокурора HTTP
[01:07:18.180 --> 01:07:20.180]  вы ключик можете заказать в Let's Encrypt.
[01:07:20.180 --> 01:07:22.180]  Он бесплатный.
[01:07:22.180 --> 01:07:24.180]  Бывают еще также ключи подписи для софта.
[01:07:25.020 --> 01:07:27.020]  Кто устанавливал софт, например,
[01:07:27.020 --> 01:07:29.020]  под Windows или под Mac,
[01:07:29.020 --> 01:07:31.020]  может видели, что
[01:07:31.020 --> 01:07:33.020]  выскакивает окошко,
[01:07:33.020 --> 01:07:35.020]  доверяет ли вы не доверять этому производителю.
[01:07:35.020 --> 01:07:37.020]  Причем под Mac вы вообще не сможете
[01:07:37.020 --> 01:07:39.020]  ничего установить,
[01:07:39.020 --> 01:07:41.020]  если сами не подпишете софт
[01:07:41.020 --> 01:07:43.020]  локально.
[01:07:43.020 --> 01:07:45.020]  Под Windows вам требуется
[01:07:45.020 --> 01:07:47.020]  подвести про администратора.
[01:07:47.020 --> 01:07:49.020]  Под Windows вы можете просто
[01:07:49.020 --> 01:07:51.020]  в яму и образом ключик.
[01:07:51.020 --> 01:07:53.020]  Что это такое?
[01:07:53.860 --> 01:07:55.860]  Я думаю, что и PortWatch.PS вам нужен
[01:07:55.860 --> 01:07:57.860]  какой-то сертификат,
[01:07:57.860 --> 01:07:59.860]  который достоверяет,
[01:07:59.860 --> 01:08:01.860]  что я являюсь отправителем,
[01:08:01.860 --> 01:08:03.860]  а не злобным троллем.
[01:08:03.860 --> 01:08:05.860]  То есть свои данные при согласовании сессии
[01:08:05.860 --> 01:08:07.860]  я обязан отправить какой-то сертификат,
[01:08:07.860 --> 01:08:09.860]  который дальше должен быть проверен
[01:08:09.860 --> 01:08:11.860]  уже самим клиентом и с чем-то сферем.
[01:08:11.860 --> 01:08:13.860]  С чем он может быть сферен?
[01:08:13.860 --> 01:08:15.860]  Есть некоторый набор
[01:08:15.860 --> 01:08:17.860]  удостоверяющих центров.
[01:08:17.860 --> 01:08:19.860]  Это какая-нибудь из уважаемых
[01:08:19.860 --> 01:08:21.860]  организаций, которая выдает
[01:08:21.860 --> 01:08:23.860]  эти сертификаты вашим серверам
[01:08:23.860 --> 01:08:25.860]  и подтверждает,
[01:08:25.860 --> 01:08:27.860]  что данный сертификат соответствует
[01:08:27.860 --> 01:08:29.860]  какому-то доменному имени,
[01:08:29.860 --> 01:08:31.860]  либо если вы подписываете софт,
[01:08:31.860 --> 01:08:33.860]  что он соответствует какому-то разработчику,
[01:08:33.860 --> 01:08:35.860]  и так далее.
[01:08:35.860 --> 01:08:37.860]  Задача этих удостоверяющих центров
[01:08:37.860 --> 01:08:42.860]  это хранить ключи надежным образом
[01:08:42.860 --> 01:08:44.860]  и выдавать свой открытый ключ
[01:08:44.860 --> 01:08:46.860]  всем клиентам, включать его
[01:08:46.860 --> 01:08:48.860]  в поставки всех возможных браузеров.
[01:08:48.860 --> 01:08:50.860]  Например, в браузере Chrome
[01:08:50.860 --> 01:08:53.860]  и в браузере Safari
[01:08:53.860 --> 01:08:55.860]  достаточно трудно
[01:08:55.860 --> 01:08:57.860]  добраться до сертификатов.
[01:08:57.860 --> 01:08:59.860]  Например, в Firefox
[01:08:59.860 --> 01:09:01.860]  под Windows он открывает
[01:09:01.860 --> 01:09:03.860]  родной системный, под Linux есть
[01:09:03.860 --> 01:09:05.860]  общий хранический сертификат.
[01:09:05.860 --> 01:09:07.860]  С каждой поставкой операционной системы
[01:09:07.860 --> 01:09:09.860]  есть свой набор сертификатов
[01:09:09.860 --> 01:09:11.860]  разных удостоверяющих центров,
[01:09:11.860 --> 01:09:13.860]  этих корневых,
[01:09:13.860 --> 01:09:15.860]  с помощью которых проверяется
[01:09:15.860 --> 01:09:17.860]  корректность, что действительно
[01:09:17.860 --> 01:09:19.860]  именно удостоверяющими центрами
[01:09:19.860 --> 01:09:21.860]  написаны те сертификаты,
[01:09:21.860 --> 01:09:23.860]  которые вы получаете в протоколу HTTP.
[01:09:23.860 --> 01:09:25.860]  Если вы получаете правильный
[01:09:25.860 --> 01:09:27.860]  сертификат, то
[01:09:27.860 --> 01:09:29.860]  хорошо вы проверяете
[01:09:29.860 --> 01:09:31.860]  уже содержимый сертификат,
[01:09:31.860 --> 01:09:33.860]  и он должен совпадать с тем доменом,
[01:09:33.860 --> 01:09:35.860]  с которым вы взаимодействуете.
[01:09:35.860 --> 01:09:37.860]  Если злобный тролль
[01:09:37.860 --> 01:09:39.860]  вам отправляет данные,
[01:09:39.860 --> 01:09:41.860]  например, какое-нибудь
[01:09:41.860 --> 01:09:43.860]  доменное имя,
[01:09:43.860 --> 01:09:45.860]  фейковый сайт,
[01:09:45.860 --> 01:09:47.860]  кто-то, например,
[01:09:47.860 --> 01:09:49.860]  подменил вам в DNS ответ
[01:09:49.860 --> 01:09:51.860]  госуслуги.ру не на госуслуги.ру,
[01:09:51.860 --> 01:09:53.860]  а на какую-нибудь там созданную копию сайта,
[01:09:53.860 --> 01:09:55.860]  что произойдет,
[01:09:55.860 --> 01:09:57.860]  если это именно копия сайта,
[01:09:57.860 --> 01:09:59.860]  а не настоящий сайт,
[01:09:59.860 --> 01:10:01.860]  то, соответственно,
[01:10:01.860 --> 01:10:03.860]  на СССР сертификат у вас не будет
[01:10:03.860 --> 01:10:05.860]  валидным, и браузер отругается,
[01:10:05.860 --> 01:10:07.860]  что вы даете кучу предупреждений,
[01:10:07.860 --> 01:10:09.860]  действительно ли вы хотите зайти,
[01:10:09.860 --> 01:10:11.860]  сертификат недействителен либо устарел.
[01:10:11.860 --> 01:10:13.860]  Это лишний повод
[01:10:13.860 --> 01:10:15.860]  задуматься, правильно ли вы
[01:10:15.860 --> 01:10:17.860]  ничего непроисходит.
[01:10:17.860 --> 01:10:19.860]  Вот, кстати,
[01:10:19.860 --> 01:10:21.860]  взаимодействие через
[01:10:21.860 --> 01:10:23.860]  бесплатный Wi-Fi в Московском метро
[01:10:23.860 --> 01:10:25.860]  сейчас уже
[01:10:25.860 --> 01:10:27.860]  такого не происходит,
[01:10:27.860 --> 01:10:29.860]  а вот раньше, в первое время,
[01:10:29.860 --> 01:10:31.860]  пока все сайты по качеству EPS
[01:10:31.860 --> 01:10:33.860]  не были массовым явлением,
[01:10:33.860 --> 01:10:35.860]  вот часто такие ошибки выскакивают,
[01:10:35.860 --> 01:10:37.860]  потому что пытались что-то подменить.
[01:10:37.860 --> 01:10:39.860]  Что?
[01:10:39.860 --> 01:10:41.860]  А, девочка Ника,
[01:10:41.860 --> 01:10:43.860]  товарищ Вадим
[01:10:43.860 --> 01:10:45.860]  пытался сдать
[01:10:45.860 --> 01:10:47.860]  и окост, и прогу,
[01:10:47.860 --> 01:10:49.860]  я уже не помню, что из них,
[01:10:49.860 --> 01:10:51.860]  по-моему, окост все-таки,
[01:10:51.860 --> 01:10:53.860]  комиссию по окост.
[01:10:53.860 --> 01:10:55.860]  Девочка Ника сливала ему
[01:10:55.860 --> 01:10:57.860]  решение готовых задач,
[01:10:57.860 --> 01:10:59.860]  собирая всех одногруппников и прямо
[01:10:59.860 --> 01:11:01.860]  скидывая в чат.
[01:11:01.860 --> 01:11:03.860]  В общем, так делать нехорошо.
[01:11:03.860 --> 01:11:05.860]  А?
[01:11:07.860 --> 01:11:09.860]  Нет, товарища
[01:11:09.860 --> 01:11:11.860]  отчислили за окост, Нику потом
[01:11:11.860 --> 01:11:13.860]  отчислили за что-то другое.
[01:11:13.860 --> 01:11:15.860]  Не за окост.
[01:11:15.860 --> 01:11:17.860]  И не я.
[01:11:21.860 --> 01:11:23.860]  Главное требование к этим
[01:11:23.860 --> 01:11:25.860]  удостоверяющим центрам
[01:11:25.860 --> 01:11:27.860]  это доверие, потому что бывают случаи,
[01:11:27.860 --> 01:11:29.860]  когда закрытые ключи
[01:11:29.860 --> 01:11:31.860]  тоже утекают.
[01:11:31.860 --> 01:11:33.860]  И что происходит в ситуации,
[01:11:33.860 --> 01:11:35.860]  когда утекают закрытые ключи
[01:11:35.860 --> 01:11:37.860]  удостоверяющих центров?
[01:11:37.860 --> 01:11:39.860]  Это означает, что кто угодно
[01:11:39.860 --> 01:11:41.860]  с этим закрытым ключом и подписать себе
[01:11:41.860 --> 01:11:43.860]  кучу неволидных сертификатов
[01:11:43.860 --> 01:11:45.860]  самоподписанных,
[01:11:45.860 --> 01:11:47.860]  что очень плохо.
[01:11:47.860 --> 01:11:49.860]  И в таких ситуациях обычно
[01:11:49.860 --> 01:11:51.860]  объявляется там большая паника.
[01:11:51.860 --> 01:11:53.860]  Google срочно выпускает не только
[01:11:53.860 --> 01:11:55.860]  Google и Microsoft, Apple
[01:11:55.860 --> 01:11:57.860]  все срочно выпускают обновления браузеров
[01:11:57.860 --> 01:11:59.860]  с исправлением базы данных сертификатов
[01:11:59.860 --> 01:12:01.860]  и так далее.
[01:12:03.860 --> 01:12:05.860]  А взаимодействие я вам в принципе уже показывал
[01:12:05.860 --> 01:12:07.860]  по утилите опыт-сель S-Connect.
[01:12:07.860 --> 01:12:09.860]  Сервер отправляет свой сертификат,
[01:12:09.860 --> 01:12:11.860]  который содержит этот ключ.
[01:12:11.860 --> 01:12:13.860]  Дальше клиент проверяет
[01:12:13.860 --> 01:12:15.860]  базы данных открытых ключей.
[01:12:15.860 --> 01:12:17.860]  То есть клиент – это браузер,
[01:12:17.860 --> 01:12:19.860]  который используя поставку базы данных
[01:12:19.860 --> 01:12:21.860]  открытых ключей из операционной системы
[01:12:21.860 --> 01:12:23.860]  проверяет сертификаты,
[01:12:23.860 --> 01:12:25.860]  выполняет проверку подлинности.
[01:12:25.860 --> 01:12:27.860]  Если сертификат действительно подлинный,
[01:12:27.860 --> 01:12:29.860]  то клиент уже дальше генерирует пару ключей.
[01:12:29.860 --> 01:12:31.860]  Одну из них отправляет
[01:12:31.860 --> 01:12:33.860]  серверу.
[01:12:33.860 --> 01:12:35.860]  Но открытый ключ свой, опять же,
[01:12:35.860 --> 01:12:37.860]  поскольку у нас уже есть
[01:12:37.860 --> 01:12:39.860]  открытый ключ сервера,
[01:12:39.860 --> 01:12:41.860]  то мы можем зашифровать данные,
[01:12:41.860 --> 01:12:43.860]  отправить это к серверу,
[01:12:43.860 --> 01:12:45.860]  и сервер дальше дешифрует этот ключ
[01:12:45.860 --> 01:12:47.860]  и может его использовать для шифрования данных.
[01:12:47.860 --> 01:12:49.860]  Такое двустороннее взаимодействие
[01:12:49.860 --> 01:12:51.860]  с обязательной проверкой,
[01:12:51.860 --> 01:12:53.860]  что это действительно общение с сервером,
[01:12:53.860 --> 01:12:55.860]  а не с кем-то другим.
[01:12:55.860 --> 01:12:57.860]  И корневые сертификаты.
[01:12:57.860 --> 01:12:59.860]  Про покупку это уже стало не очень актуально,
[01:12:59.860 --> 01:13:01.860]  можно в лице накрепить получить.
[01:13:01.860 --> 01:13:03.860]  Но и когда они были дорогие,
[01:13:03.860 --> 01:13:05.860]  еще была распространена практика
[01:13:05.860 --> 01:13:07.860]  корпоративных корневых сертификатов,
[01:13:07.860 --> 01:13:09.860]  когда крупные компании
[01:13:11.860 --> 01:13:13.860]  могли просто покупать,
[01:13:13.860 --> 01:13:15.860]  генерировать сами
[01:13:15.860 --> 01:13:17.860]  свои сертификаты
[01:13:17.860 --> 01:13:19.860]  и просто раскидывать по всем
[01:13:19.860 --> 01:13:21.860]  локальным компьютерам своим
[01:13:21.860 --> 01:13:23.860]  для того, чтобы браузеры
[01:13:23.860 --> 01:13:25.860]  выполняли взаимодействие
[01:13:25.860 --> 01:13:27.860]  и выполняли проверку,
[01:13:27.860 --> 01:13:29.860]  что действительно правильный сертификат.
[01:13:29.860 --> 01:13:31.860]  То есть это тоже вручную установить возможно.
[01:13:31.860 --> 01:13:33.860]  Вручную добавить, если у вас есть право администратора,
[01:13:33.860 --> 01:13:35.860]  тоже произвольный сертификат.
[01:13:37.860 --> 01:13:39.860]  На счет реализации шифрования,
[01:13:39.860 --> 01:13:41.860]  помимо команды OpenSSL,
[01:13:43.860 --> 01:13:45.860]  есть еще библиотека
[01:13:45.860 --> 01:13:47.860]  под названием LibreSSL.
[01:13:49.860 --> 01:13:51.860]  Что такое библиотека LibreSSL?
[01:13:51.860 --> 01:13:53.860]  LibreSSL – это
[01:13:53.860 --> 01:13:55.860]  форк библиотека OpenSSL,
[01:13:55.860 --> 01:13:57.860]  который прямо по API один в один
[01:13:57.860 --> 01:13:59.860]  с ним совместим.
[01:13:59.860 --> 01:14:01.860]  Чем он лучше в библиотеке OpenSSL?
[01:14:03.860 --> 01:14:05.860]  Кроме того, что там меньше багов,
[01:14:05.860 --> 01:14:07.860]  у него хорошая документация.
[01:14:07.860 --> 01:14:09.860]  В OpenSSL документация отвратительная.
[01:14:09.860 --> 01:14:11.860]  Поэтому, когда вы будете делать домашки,
[01:14:11.860 --> 01:14:13.860]  вам нужно будет писать вот,
[01:14:13.860 --> 01:14:15.860]  используйте библиотеки LibCrypto,
[01:14:15.860 --> 01:14:17.860]  пользуйтесь документацией
[01:14:17.860 --> 01:14:19.860]  из LibreSSL.
[01:14:23.860 --> 01:14:25.860]  Здесь библиотеку документация не понравилась,
[01:14:25.860 --> 01:14:27.860]  в итоге Stack Overflow поможет?
[01:14:27.860 --> 01:14:29.860]  Stack Overflow может помочь,
[01:14:29.860 --> 01:14:31.860]  но в документации по LibreSSL
[01:14:31.860 --> 01:14:33.860]  поковыряться по правильным названиям
[01:14:33.860 --> 01:14:35.860]  этого более чем достаточно.
[01:14:35.860 --> 01:14:37.860]  OpenSSL – плохая библиотека,
[01:14:37.860 --> 01:14:39.860]  хотя является стандартом.
[01:14:39.860 --> 01:14:41.860]  Почему LibreSSL
[01:14:41.860 --> 01:14:43.860]  до сих пор не во всех дистрибутеях
[01:14:43.860 --> 01:14:45.860]  по умолчанию? Потому что по функциональности
[01:14:45.860 --> 01:14:47.860]  она пока еще не полная,
[01:14:47.860 --> 01:14:49.860]  но там выкинули всю функциональность,
[01:14:49.860 --> 01:14:51.860]  которая считается условно на legacy.
[01:14:51.860 --> 01:14:53.860]  Но в большинстве случаев это
[01:14:53.860 --> 01:14:55.860]  более чем достаточно.
[01:14:55.860 --> 01:14:57.860]  Ладно, время 8.23,
[01:14:57.860 --> 01:14:59.860]  поэтому кто хочет отключиться
[01:14:59.860 --> 01:15:01.860]  от семинара – отключайтесь.
[01:15:01.860 --> 01:15:03.860]  Мы, пользуясь традицией
[01:15:03.860 --> 01:15:05.860]  12-й группы,
[01:15:05.860 --> 01:15:07.860]  вечерний продолжаем
[01:15:07.860 --> 01:15:09.860]  семинар дальше.
[01:15:09.860 --> 01:15:11.860]  Закрываю разбор задач,
[01:15:11.860 --> 01:15:13.860]  продолжаю запись семинара.
[01:15:13.860 --> 01:15:15.860]  Давайте посмотрим теперь
[01:15:15.860 --> 01:15:17.860]  практически, что мы можем
[01:15:17.860 --> 01:15:19.860]  делать с разными данными,
[01:15:19.860 --> 01:15:21.860]  как их кодировать и декодировать.
[01:15:21.860 --> 01:15:23.860]  Кодирование
[01:15:23.860 --> 01:15:25.860]  еще раз напомню,
[01:15:25.860 --> 01:15:27.860]  что у нас есть алгоритм кодирования
[01:15:27.860 --> 01:15:29.860]  с симметричным шифрованием.
[01:15:29.860 --> 01:15:31.860]  Здесь мне приходится вводить
[01:15:31.860 --> 01:15:33.860]  какой-то пароль,
[01:15:33.860 --> 01:15:35.860]  также повторять навод,
[01:15:35.860 --> 01:15:37.860]  если мы
[01:15:37.860 --> 01:15:39.860]  хотим как-то
[01:15:39.860 --> 01:15:41.860]  это автоматизировать.
[01:15:41.860 --> 01:15:43.860]  Как мы можем...
[01:15:43.860 --> 01:15:45.860]  Понятно, что если у вас, например,
[01:15:45.860 --> 01:15:47.860]  есть какая-то система
[01:15:47.860 --> 01:15:49.860]  по автоматизации шифрования,
[01:15:49.860 --> 01:15:51.860]  то
[01:15:51.860 --> 01:15:53.860]  вы не будете вручную вводить пароль.
[01:15:53.860 --> 01:15:55.860]  Все должно работать автоматически,
[01:15:55.860 --> 01:15:57.860]  например, сясь, борк.
[01:15:57.860 --> 01:15:59.860]  Но что вы можете сделать?
[01:15:59.860 --> 01:16:01.860]  Написать echo,
[01:16:01.860 --> 01:16:03.860]  qwerty,
[01:16:03.860 --> 01:16:05.860]  или направить вывод,
[01:16:05.860 --> 01:16:07.860]  OpenSale и так далее.
[01:16:07.860 --> 01:16:09.860]  OpenSale умный,
[01:16:09.860 --> 01:16:11.860]  он команду echo не понимает,
[01:16:11.860 --> 01:16:13.860]  но зато вы можете написать
[01:16:13.860 --> 01:16:15.860]  явно образом пароль
[01:16:15.860 --> 01:16:17.860]  либо плейнтекстом,
[01:16:17.860 --> 01:16:19.860]  потом c-pass задает,
[01:16:19.860 --> 01:16:21.860]  таким образом вы указываете пароль.
[01:16:21.860 --> 01:16:23.860]  Разные варианты.
[01:16:23.860 --> 01:16:25.860]  Во-первых, вы можете написать
[01:16:25.860 --> 01:16:27.860]  вот такую штуку.
[01:16:27.860 --> 01:16:29.860]  Все, пароль у вас никто не спрашивает
[01:16:29.860 --> 01:16:31.860]  с стандартом протока ввода.
[01:16:31.860 --> 01:16:33.860]  Вы такую строчку можете запихать, например,
[01:16:33.860 --> 01:16:35.860]  в файл скрипта, задеплоить на сервер.
[01:16:35.860 --> 01:16:37.860]  Согласны?
[01:16:37.860 --> 01:16:39.860]  Это плохо.
[01:16:39.860 --> 01:16:41.860]  Это плохо, потому что смысл шифрования
[01:16:41.860 --> 01:16:43.860]  теряется у вас
[01:16:43.860 --> 01:16:45.860]  в файле скрипта, который выполняет
[01:16:45.860 --> 01:16:47.860]  шифрование прямо за хардкожин пароль.
[01:16:47.860 --> 01:16:49.860]  Что нехорошо.
[01:16:49.860 --> 01:16:51.860]  Какие еще возможные варианты
[01:16:51.860 --> 01:16:53.860]  указания пароля?
[01:16:53.860 --> 01:16:55.860]  Вы можете пароль написать, например,
[01:16:55.860 --> 01:16:57.860]  в отдельный текстовый файл
[01:17:01.860 --> 01:17:03.860]  с паролем.
[01:17:03.860 --> 01:17:05.860]  Уже немножко лучше, но
[01:17:05.860 --> 01:17:07.860]  если вы, например, используете GitLab,
[01:17:07.860 --> 01:17:09.860]  какой-нибудь GitLab.si для сборки,
[01:17:09.860 --> 01:17:11.860]  опять же, у вас файл
[01:17:11.860 --> 01:17:13.860]  должен где-то лежать в доступном месте
[01:17:13.860 --> 01:17:15.860]  и достучаться до него.
[01:17:15.860 --> 01:17:17.860]  Здесь его сможете.
[01:17:17.860 --> 01:17:19.860]  Тоже не панацея.
[01:17:19.860 --> 01:17:21.860]  Какие еще варианты?
[01:17:23.860 --> 01:17:25.860]  Еще вариант.
[01:17:25.860 --> 01:17:27.860]  Запустить OpenSCale из внешней программы,
[01:17:27.860 --> 01:17:29.860]  создать явно файл-дискриптер
[01:17:29.860 --> 01:17:31.860]  и указать номер
[01:17:31.860 --> 01:17:33.860]  файла-дискриптера, например, третьей.
[01:17:33.860 --> 01:17:35.860]  Такое тоже возможно,
[01:17:35.860 --> 01:17:37.860]  но обычно для этого требуется создание
[01:17:37.860 --> 01:17:39.860]  внешней обертки скрипта,
[01:17:39.860 --> 01:17:41.860]  которая запускает OpenSCale.
[01:17:41.860 --> 01:17:43.860]  Это жутко неудобно, хотя в некоторых случаях
[01:17:43.860 --> 01:17:45.860]  например, когда OpenSCale
[01:17:45.860 --> 01:17:47.860]  вызывается из каких-то внешних программ.
[01:17:47.860 --> 01:17:49.860]  Например, программка запросить пароль.
[01:17:49.860 --> 01:17:51.860]  Диалоговая кошка,
[01:17:51.860 --> 01:17:53.860]  которая спрашивает пароль, передает
[01:17:53.860 --> 01:17:55.860]  OpenSCale и так далее.
[01:17:55.860 --> 01:17:57.860]  И более
[01:17:57.860 --> 01:17:59.860]  полезный вариант
[01:17:59.860 --> 01:18:01.860]  это временное переменное окружение,
[01:18:01.860 --> 01:18:03.860]  которое как-то сдается в конфидегах,
[01:18:03.860 --> 01:18:05.860]  которые скрыты.
[01:18:07.860 --> 01:18:09.860]  Как эта штука работает?
[01:18:09.860 --> 01:18:11.860]  Вы пишете пример окружения
[01:18:11.860 --> 01:18:13.860]  с паспортом
[01:18:13.860 --> 01:18:15.860]  и запускаете команду OpenSCale.
[01:18:15.860 --> 01:18:17.860]  Но когда стало не нужно,
[01:18:19.860 --> 01:18:21.860]  он сет паспорт
[01:18:21.860 --> 01:18:23.860]  либо еще что-нибудь.
[01:18:23.860 --> 01:18:25.860]  Это наиболее безопасный способ,
[01:18:25.860 --> 01:18:27.860]  когда вы отдельно передаете
[01:18:27.860 --> 01:18:29.860]  переменное окружение
[01:18:29.860 --> 01:18:31.860]  отдельно от файлов, которые у вас хранятся.
[01:18:31.860 --> 01:18:33.860]  И это переменное окружение
[01:18:33.860 --> 01:18:35.860]  берется откуда-то снаружи.
[01:18:35.860 --> 01:18:37.860]  В том числе вы можете закодировать
[01:18:37.860 --> 01:18:39.860]  произвольные данные большого размера.
[01:18:39.860 --> 01:18:41.860]  Дальше этот ключ
[01:18:41.860 --> 01:18:43.860]  с паролем кому-то передаете.
[01:18:43.860 --> 01:18:45.860]  Хорошо, все замечательно.
[01:18:45.860 --> 01:18:47.860]  Теперь вариант шифрования
[01:18:47.860 --> 01:18:49.860]  без использования пары ключей
[01:18:49.860 --> 01:18:51.860]  а с использованием
[01:18:51.860 --> 01:18:53.860]  симметричного шифрования.
[01:18:53.860 --> 01:18:55.860]  Это уже интересно.
[01:18:57.860 --> 01:18:59.860]  Допустим, у нас есть
[01:19:01.860 --> 01:19:03.860]  передатчик
[01:19:03.860 --> 01:19:05.860]  и третья вкладка.
[01:19:05.860 --> 01:19:07.860]  Это будет
[01:19:07.860 --> 01:19:09.860]  получатель.
[01:19:09.860 --> 01:19:11.860]  Вот две вкладки.
[01:19:11.860 --> 01:19:13.860]  Я создаю два подкаталога
[01:19:13.860 --> 01:19:15.860]  на одном и том же серии
[01:19:15.860 --> 01:19:17.860]  для того чтобы симитировать процесс передачи данных.
[01:19:17.860 --> 01:19:19.860]  Тут нас будет интересовать
[01:19:19.860 --> 01:19:21.860]  только
[01:19:21.860 --> 01:19:23.860]  непроцессный процесс шифрования.
[01:19:23.860 --> 01:19:25.860]  Итак, для того чтобы использовать
[01:19:27.860 --> 01:19:29.860]  пару симметричных ключей
[01:19:29.860 --> 01:19:31.860]  у нас
[01:19:31.860 --> 01:19:33.860]  нужно чтобы получатель
[01:19:33.860 --> 01:19:35.860]  сначала сгенерировал какую-то
[01:19:35.860 --> 01:19:37.860]  удобную пару ключей.
[01:19:39.860 --> 01:19:41.860]  Открытый ключ, закрытый ключ.
[01:19:41.860 --> 01:19:43.860]  Для этого использовать инструмент
[01:19:43.860 --> 01:19:45.860]  OpenSSL под названием
[01:19:45.860 --> 01:19:47.860]  GenRSA.
[01:19:47.860 --> 01:19:49.860]  Это примерно аналог
[01:19:49.860 --> 01:19:51.860]  SSH KeyGen, который вы использовали
[01:19:51.860 --> 01:19:53.860]  для SSH ключов.
[01:19:53.860 --> 01:19:55.860]  В самом деле ключ SSH
[01:19:55.860 --> 01:19:57.860]  и ключ RSA это одно и то же.
[01:19:57.860 --> 01:19:59.860]  Это один и тот же RSA ключ.
[01:19:59.860 --> 01:20:01.860]  Одна и та же пара ключей, но просто они могут
[01:20:01.860 --> 01:20:03.860]  храниться в разных форматах данных.
[01:20:03.860 --> 01:20:05.860]  GenRSA
[01:20:05.860 --> 01:20:07.860]  и дальше вы
[01:20:07.860 --> 01:20:09.860]  можете опционально указать
[01:20:09.860 --> 01:20:11.860]  размер ключа
[01:20:11.860 --> 01:20:13.860]  на примере
[01:20:13.860 --> 01:20:15.860]  4096 бит
[01:20:15.860 --> 01:20:17.860]  или
[01:20:17.860 --> 01:20:19.860]  65536 бит
[01:20:19.860 --> 01:20:21.860]  только здесь.
[01:20:21.860 --> 01:20:23.860]  Эта штука будет очень
[01:20:23.860 --> 01:20:25.860]  долго считаться.
[01:20:27.860 --> 01:20:29.860]  Кто-нибудь из вас
[01:20:29.860 --> 01:20:31.860]  по базовым указаниям у вас еще не было распределения.
[01:20:31.860 --> 01:20:33.860]  На некоторых базовых
[01:20:33.860 --> 01:20:35.860]  хафедрах еще есть отдельный курс
[01:20:35.860 --> 01:20:37.860]  по криптографии, по монояндексе.
[01:20:37.860 --> 01:20:39.860]  Там более подробно
[01:20:39.860 --> 01:20:41.860]  будут разбираться математические основы
[01:20:41.860 --> 01:20:43.860]  этих алгоритмов.
[01:20:43.860 --> 01:20:45.860]  RSA он
[01:20:45.860 --> 01:20:47.860]  основан на использовании
[01:20:47.860 --> 01:20:49.860]  разных пар
[01:20:49.860 --> 01:20:51.860]  из временно простых чисел.
[01:20:51.860 --> 01:20:53.860]  Соответственно, простые числа
[01:20:53.860 --> 01:20:55.860]  они
[01:20:55.860 --> 01:20:57.860]  сложности генерации
[01:20:57.860 --> 01:20:59.860]  возрастают квадратично.
[01:20:59.860 --> 01:21:01.860]  Очень большой
[01:21:01.860 --> 01:21:03.860]  размер чисел
[01:21:03.860 --> 01:21:05.860]  размер ключа
[01:21:05.860 --> 01:21:07.860]  дает нам
[01:21:07.860 --> 01:21:09.860]  очень медленное время работы.
[01:21:09.860 --> 01:21:11.860]  По умолчанию у нас используется ключ
[01:21:11.860 --> 01:21:13.860]  размером 2048 бит.
[01:21:13.860 --> 01:21:15.860]  Давайте будем его использовать.
[01:21:17.860 --> 01:21:19.860]  Сохраним его
[01:21:21.860 --> 01:21:23.860]  как приватный ключ.
[01:21:25.860 --> 01:21:27.860]  Сгенерировали.
[01:21:27.860 --> 01:21:29.860]  Что-то
[01:21:29.860 --> 01:21:31.860]  бинарное закодировано
[01:21:31.860 --> 01:21:33.860]  в кодировке
[01:21:33.860 --> 01:21:35.860]  BS64.
[01:21:35.860 --> 01:21:37.860]  Чтобы этот текст можно было передать
[01:21:37.860 --> 01:21:39.860]  сохранить как-нибудь с копипастить
[01:21:39.860 --> 01:21:41.860]  и так далее.
[01:21:41.860 --> 01:21:43.860]  Теперь нам нужно
[01:21:43.860 --> 01:21:45.860]  из этого приватного ключа извлечь
[01:21:45.860 --> 01:21:47.860]  публичный ключ.
[01:21:49.860 --> 01:21:51.860]  OpenSSL здесь
[01:21:51.860 --> 01:21:53.860]  используется
[01:21:53.860 --> 01:21:55.860]  утилита RSA
[01:21:55.860 --> 01:21:57.860]  для манипуляции ключами
[01:21:57.860 --> 01:21:59.860]  берем наш
[01:21:59.860 --> 01:22:01.860]  исходный файл
[01:22:01.860 --> 01:22:03.860]  приватный
[01:22:03.860 --> 01:22:05.860]  выполняем операцию
[01:22:05.860 --> 01:22:07.860]  pubout
[01:22:07.860 --> 01:22:09.860]  и получаем
[01:22:09.860 --> 01:22:11.860]  какой-то более коротенький ключик
[01:22:11.860 --> 01:22:13.860]  который опять же можем куда-то сохранить
[01:22:13.860 --> 01:22:15.860]  например файл public.
[01:22:15.860 --> 01:22:17.860]  key
[01:22:17.860 --> 01:22:19.860]  ключ, заметьте,
[01:22:19.860 --> 01:22:21.860]  получается намного более короткий
[01:22:21.860 --> 01:22:23.860]  чем пара ключей, которые здесь
[01:22:23.860 --> 01:22:25.860]  в приватном ключе сохранены.
[01:22:27.860 --> 01:22:29.860]  Теперь
[01:22:29.860 --> 01:22:31.860]  можем скопировать наш публичный
[01:22:31.860 --> 01:22:33.860]  ключ нашему
[01:22:33.860 --> 01:22:35.860]  отправителю
[01:22:37.860 --> 01:22:39.860]  и переходим к отправителю.
[01:22:39.860 --> 01:22:41.860]  Что должно сделать отправитель?
[01:22:41.860 --> 01:22:43.860]  Отправитель должен сделать
[01:22:43.860 --> 01:22:45.860]  какой-то файл, который хочется отправить
[01:22:47.860 --> 01:22:49.860]  пусть будет строчка
[01:22:49.860 --> 01:22:51.860]  hello
[01:22:51.860 --> 01:22:53.860]  Дальше
[01:22:53.860 --> 01:22:55.860]  отправитель
[01:22:55.860 --> 01:22:57.860]  использует
[01:22:57.860 --> 01:22:59.860]  RSA
[01:22:59.860 --> 01:23:01.860]  утилита
[01:23:01.860 --> 01:23:03.860]  утилита
[01:23:03.860 --> 01:23:05.860]  кто не запоминает такие вещи
[01:23:05.860 --> 01:23:07.860]  на гитхабе
[01:23:07.860 --> 01:23:09.860]  проведены прямо в тексты
[01:23:09.860 --> 01:23:11.860]  которые можно использовать в качестве бипасты
[01:23:13.860 --> 01:23:15.860]  шифруем, используя
[01:23:15.860 --> 01:23:17.860]  публичный ключ
[01:23:17.860 --> 01:23:19.860]  и используем в качестве ключа
[01:23:19.860 --> 01:23:21.860]  файл
[01:23:21.860 --> 01:23:23.860]  public. key, который нам передали
[01:23:23.860 --> 01:23:25.860]  имя файла
[01:23:25.860 --> 01:23:27.860]  hello.txt
[01:23:27.860 --> 01:23:29.860]  out.hello.
[01:23:29.860 --> 01:23:31.860]  зашифрование
[01:23:33.860 --> 01:23:35.860]  Получаем некоторые файлы
[01:23:37.860 --> 01:23:39.860]  что он представляет?
[01:23:39.860 --> 01:23:41.860]  он представляет какой-то мусор
[01:23:43.860 --> 01:23:45.860]  самое интересное, что этот мусор
[01:23:45.860 --> 01:23:47.860]  имеет размер
[01:23:47.860 --> 01:23:49.860]  256
[01:23:51.860 --> 01:23:53.860]  что такое 256?
[01:23:57.860 --> 01:23:59.860]  256 умножаем на 8
[01:24:01.860 --> 01:24:03.860]  получаем 2048
[01:24:03.860 --> 01:24:05.860]  что этого мне напоминает?
[01:24:05.860 --> 01:24:07.860]  это размер ключа RSA
[01:24:07.860 --> 01:24:09.860]  результатом работы алгоритма RSA является
[01:24:09.860 --> 01:24:11.860]  что-то совпадающее с размером ключа
[01:24:13.860 --> 01:24:15.860]  и там как-то закодированы наши данные
[01:24:17.860 --> 01:24:19.860]  дальше отправитель может
[01:24:19.860 --> 01:24:21.860]  отправить
[01:24:21.860 --> 01:24:23.860]  нам эти данные
[01:24:35.860 --> 01:24:37.860]  наш получатель
[01:24:37.860 --> 01:24:39.860]  RSA
[01:24:39.860 --> 01:24:41.860]  URL
[01:24:41.860 --> 01:24:43.860]  дальше Decrypt
[01:24:43.860 --> 01:24:45.860]  обратная операция
[01:24:45.860 --> 01:24:47.860]  может использовать
[01:24:47.860 --> 01:24:49.860]  либо злобный тролль
[01:24:49.860 --> 01:24:51.860]  может использовать наш public. key
[01:24:55.860 --> 01:24:57.860]  ничего не получается
[01:24:57.860 --> 01:24:59.860]  если мы перехватили
[01:24:59.860 --> 01:25:01.860]  этого ключа нам недостаточно
[01:25:01.860 --> 01:25:03.860]  поэтому здесь придется
[01:25:03.860 --> 01:25:05.860]  задействовать наш private. key
[01:25:05.860 --> 01:25:07.860]  который есть только у нашего
[01:25:07.860 --> 01:25:09.860]  получателя
[01:25:09.860 --> 01:25:11.860]  и больше никому не доступен
[01:25:11.860 --> 01:25:13.860]  но ему строчку нормально дешифровать
[01:25:15.860 --> 01:25:17.860]  почему?
[01:25:21.860 --> 01:25:23.860]  тогда нужно
[01:25:23.860 --> 01:25:25.860]  еще пару ключов
[01:25:31.860 --> 01:25:33.860]  публично имеется в виду тот ключ
[01:25:33.860 --> 01:25:35.860]  который вам не страшно
[01:25:35.860 --> 01:25:37.860]  потерять и раздать кому угодно
[01:25:39.860 --> 01:25:41.860]  обычно в реальной жизни он генерируется
[01:25:41.860 --> 01:25:43.860]  рандомно
[01:25:45.860 --> 01:25:47.860]  теперь
[01:25:47.860 --> 01:25:49.860]  сделаю все то же самое
[01:25:49.860 --> 01:25:51.860]  но только зашифрую файл
[01:25:51.860 --> 01:25:53.860]  не int.xt
[01:25:53.860 --> 01:25:55.860]  а какой-нибудь
[01:25:55.860 --> 01:25:57.860]  usr, bin, cat
[01:25:59.860 --> 01:26:01.860]  и файл
[01:26:01.860 --> 01:26:03.860]  пусть будет cat.exe
[01:26:05.860 --> 01:26:07.860]  получаем ошибку
[01:26:07.860 --> 01:26:09.860]  ошибку потому что
[01:26:09.860 --> 01:26:11.860]  мы наступили на ограничение
[01:26:11.860 --> 01:26:13.860]  алгоритма RSA
[01:26:13.860 --> 01:26:15.860]  размер данных
[01:26:15.860 --> 01:26:17.860]  не должен превышать
[01:26:17.860 --> 01:26:19.860]  размера ключа
[01:26:21.860 --> 01:26:23.860]  как можно все-таки
[01:26:23.860 --> 01:26:25.860]  зашифровать безопасным образом
[01:26:27.860 --> 01:26:29.860]  вариант первый блоками
[01:26:29.860 --> 01:26:31.860]  вариант второй
[01:26:31.860 --> 01:26:33.860]  у нас же есть хорошие быстрые алгоритмы
[01:26:33.860 --> 01:26:35.860]  надежные для симметричного шифрования
[01:26:35.860 --> 01:26:37.860]  всякие IES и прочие
[01:26:39.860 --> 01:26:41.860]  главная проблема здесь в чем?
[01:26:41.860 --> 01:26:43.860]  потому что нам надо еще каким-то образом
[01:26:43.860 --> 01:26:45.860]  передать ключ
[01:26:47.860 --> 01:26:49.860]  поэтому как используется настоящий взаимодействие
[01:26:49.860 --> 01:26:51.860]  по протоколам ssh
[01:26:51.860 --> 01:26:53.860]  либо htps
[01:26:53.860 --> 01:26:55.860]  там используется несколько алгоритмов
[01:26:57.860 --> 01:26:59.860]  то есть мы можем
[01:26:59.860 --> 01:27:01.860]  сгенерировать рандомно
[01:27:01.860 --> 01:27:03.860]  какой-то ключ
[01:27:05.860 --> 01:27:07.860]  размером например
[01:27:07.860 --> 01:27:09.860]  не превышающим
[01:27:09.860 --> 01:27:11.860]  200
[01:27:11.860 --> 01:27:13.860]  2048 бит
[01:27:13.860 --> 01:27:15.860]  дальше этот ключ мы кодируем
[01:27:15.860 --> 01:27:17.860]  по RSA, передаем в противоположной стороне
[01:27:17.860 --> 01:27:19.860]  а дальше уже
[01:27:19.860 --> 01:27:21.860]  используем этот ключ
[01:27:21.860 --> 01:27:23.860]  кодируем обычным алгоритмом
[01:27:23.860 --> 01:27:25.860]  IES AMCBC
[01:27:25.860 --> 01:27:27.860]  и на самом деле вот такой подход
[01:27:27.860 --> 01:27:29.860]  реально используется различными серверами
[01:27:31.860 --> 01:27:33.860]  то есть зайдем там
[01:27:33.860 --> 01:27:35.860]  у Яндекса
[01:27:35.860 --> 01:27:37.860]  какая-нибудь экзотические
[01:27:37.860 --> 01:27:39.860]  алгоритмы
[01:27:39.860 --> 01:27:41.860]  хотя можно посмотреть
[01:27:41.860 --> 01:27:43.860]  какие алгоритмы он использует
[01:27:43.860 --> 01:27:45.860]  short certificate
[01:27:45.860 --> 01:27:47.860]  в подробностях есть еще
[01:27:47.860 --> 01:27:49.860]  какие алгоритмы у нас используются
[01:27:51.860 --> 01:27:53.860]  для шифровой подписи
[01:27:53.860 --> 01:27:55.860]  у нас используется
[01:27:55.860 --> 01:27:57.860]  256 RSA
[01:28:01.860 --> 01:28:03.860]  нет у нас не RSA
[01:28:03.860 --> 01:28:05.860]  яндекс использует алгоритм
[01:28:05.860 --> 01:28:07.860]  для передачи ключа
[01:28:07.860 --> 01:28:09.860]  а для
[01:28:09.860 --> 01:28:11.860]  непосредственного шифрования данных
[01:28:11.860 --> 01:28:13.860]  используется
[01:28:21.860 --> 01:28:23.860]  где найти это
[01:28:23.860 --> 01:28:25.860]  в Safari
[01:28:25.860 --> 01:28:27.860]  не особо представляю
[01:28:27.860 --> 01:28:29.860]  ну так
[01:28:29.860 --> 01:28:31.860]  лептические кривые
[01:28:35.860 --> 01:28:37.860]  давайте откроем
[01:28:37.860 --> 01:28:39.860]  другой браузер
[01:28:39.860 --> 01:28:41.860]  Яндекс
[01:28:51.860 --> 01:28:53.860]  Яндекс ком
[01:28:53.860 --> 01:28:55.860]  смотрим на
[01:28:59.860 --> 01:29:01.860]  7 баллов в пробке
[01:29:01.860 --> 01:29:03.860]  зима
[01:29:03.860 --> 01:29:05.860]  где там
[01:29:05.860 --> 01:29:07.860]  подробности
[01:29:07.860 --> 01:29:09.860]  подробности
[01:29:09.860 --> 01:29:11.860]  о сертификате
[01:29:13.860 --> 01:29:15.860]  вот connection
[01:29:15.860 --> 01:29:17.860]  connection encrypted
[01:29:17.860 --> 01:29:19.860]  IES 1056 CG
[01:29:23.860 --> 01:29:25.860]  дальше подробности
[01:29:25.860 --> 01:29:27.860]  елки
[01:29:29.860 --> 01:29:31.860]  в разных базах
[01:29:31.860 --> 01:29:33.860]  можно посмотреть
[01:29:33.860 --> 01:29:35.860]  для каких сайтов
[01:29:35.860 --> 01:29:37.860]  какие алгоритмы для чего используются
[01:29:37.860 --> 01:29:39.860]  а Google тоже может
[01:29:39.860 --> 01:29:41.860]  что-нибудь нестандартное
[01:29:43.860 --> 01:29:45.860]  какой у него адрес
[01:29:45.860 --> 01:29:47.860]  Moodle
[01:29:47.860 --> 01:29:49.860]  Moodle Fistahead
[01:29:49.860 --> 01:29:51.860]  Кафедра АТП
[01:29:57.860 --> 01:29:59.860]  обратиться к тем
[01:29:59.860 --> 01:30:01.860]  кто его создавал
[01:30:01.860 --> 01:30:03.860]  Кафедра АТП
[01:30:03.860 --> 01:30:05.860]  не по отношению к IT следей
[01:30:05.860 --> 01:30:07.860]  не имеет абсолютно и полностью
[01:30:07.860 --> 01:30:09.860]  IES 128 CG
[01:30:09.860 --> 01:30:11.860]  и RSA для
[01:30:11.860 --> 01:30:13.860]  подмена ключей
[01:30:13.860 --> 01:30:15.860]  все равно какая-то вариация ключа
[01:30:15.860 --> 01:30:17.860]  либо RSA, либо лептические кривые
[01:30:17.860 --> 01:30:19.860]  по отношению к IES
[01:30:19.860 --> 01:30:21.860]  странно, что ребята используют IES 128
[01:30:23.860 --> 01:30:25.860]  вот вам наводка
[01:30:25.860 --> 01:30:27.860]  что-то старое, что не поддерживает
[01:30:27.860 --> 01:30:29.860]  IES 256
[01:30:31.860 --> 01:30:33.860]  на самом деле IES 128 тоже достаточно надежный
[01:30:35.860 --> 01:30:37.860]  обычно используется именно пара
[01:30:37.860 --> 01:30:39.860]  алгоритмов шифрования
[01:30:39.860 --> 01:30:41.860]  это
[01:30:41.860 --> 01:30:43.860]  что-нибудь типа IES
[01:30:43.860 --> 01:30:45.860]  либо RSA, либо лептические кривые
[01:30:47.860 --> 01:30:49.860]  и немножко про симметричное шифрование
[01:30:49.860 --> 01:30:51.860]  и про использование соли
[01:30:51.860 --> 01:30:53.860]  один важный момент
[01:30:53.860 --> 01:30:55.860]  и потом я вас тогда уже отпущу
[01:30:57.860 --> 01:30:59.860]  строчка Hello
[01:30:59.860 --> 01:31:01.860]  давайте мы ее закодируем
[01:31:05.860 --> 01:31:07.860]  обычным
[01:31:09.860 --> 01:31:11.860]  IES 256
[01:31:11.860 --> 01:31:13.860]  и также
[01:31:15.860 --> 01:31:17.860]  используем одно имя тоже файла
[01:31:17.860 --> 01:31:19.860]  hello.txt
[01:31:19.860 --> 01:31:21.860]  используем пароль
[01:31:21.860 --> 01:31:23.860]  plain.txt
[01:31:23.860 --> 01:31:25.860]  чтобы все было честно
[01:31:25.860 --> 01:31:27.860]  и запишем за все файл
[01:31:27.860 --> 01:31:29.860]  1.eng
[01:31:31.860 --> 01:31:33.860]  и сделаем то же самое
[01:31:33.860 --> 01:31:35.860]  для файла 2.eng
[01:31:35.860 --> 01:31:37.860]  файл содержит одно и то же
[01:31:37.860 --> 01:31:39.860]  закодированный паролем qwerty
[01:31:39.860 --> 01:31:41.860]  размер первого файла
[01:31:41.860 --> 01:31:43.860]  32
[01:31:43.860 --> 01:31:45.860]  размер второго файла
[01:31:45.860 --> 01:31:47.860]  тоже 32
[01:31:47.860 --> 01:31:49.860]  вроде как
[01:31:49.860 --> 01:31:51.860]  пока похоже на правду, согласны?
[01:31:51.860 --> 01:31:53.860]  как там понять одинаковые файлы
[01:31:53.860 --> 01:31:55.860]  или не одинаковые, несмотря на их содержимое?
[01:31:57.860 --> 01:31:59.860]  да, можно посмотреть хэш-сумму
[01:31:59.860 --> 01:32:01.860]  можно использовать OpenSSL
[01:32:01.860 --> 01:32:03.860]  можно использовать более короткие команды
[01:32:03.860 --> 01:32:05.860]  если у вас Linux
[01:32:05.860 --> 01:32:07.860]  давайте посмотрим одинаковые эти файлы или не одинаковые
[01:32:09.860 --> 01:32:11.860]  файлы-то у нас разные получились
[01:32:11.860 --> 01:32:13.860]  с чем это может быть связано?
[01:32:13.860 --> 01:32:15.860]  да
[01:32:15.860 --> 01:32:17.860]  здесь у нас повлияла соль
[01:32:17.860 --> 01:32:19.860]  которая использована для дополнительной
[01:32:19.860 --> 01:32:21.860]  рандомизации данных
[01:32:23.860 --> 01:32:25.860]  если посмотреть
[01:32:25.860 --> 01:32:27.860]  хэкс-дампом
[01:32:27.860 --> 01:32:29.860]  содержимое
[01:32:31.860 --> 01:32:33.860]  хэкс-дампом некрасивое
[01:32:33.860 --> 01:32:35.860]  xxd-r
[01:32:35.860 --> 01:32:37.860]  хэкс-дамп
[01:32:37.860 --> 01:32:39.860]  что у нас есть в файле?
[01:32:41.860 --> 01:32:43.860]  так лучше
[01:32:43.860 --> 01:32:45.860]  минус c
[01:32:45.860 --> 01:32:47.860]  кто помнит опцию xxd
[01:32:47.860 --> 01:32:49.860]  чтобы он побайтовый
[01:32:49.860 --> 01:32:51.860]  и не группировался?
[01:32:51.860 --> 01:32:53.860]  никто не помнит
[01:32:53.860 --> 01:32:55.860]  полезно это вспомнить
[01:32:55.860 --> 01:32:57.860]  формат calls
[01:32:57.860 --> 01:32:59.860]  а
[01:32:59.860 --> 01:33:01.860]  минус c1
[01:33:01.860 --> 01:33:03.860]  нет
[01:33:03.860 --> 01:33:05.860]  не то
[01:33:05.860 --> 01:33:07.860]  а
[01:33:07.860 --> 01:33:09.860]  минус page
[01:33:13.860 --> 01:33:15.860]  так вот у нас получается
[01:33:15.860 --> 01:33:17.860]  ладно
[01:33:17.860 --> 01:33:19.860]  не буду извращаться
[01:33:19.860 --> 01:33:21.860]  извращаться с выводом
[01:33:21.860 --> 01:33:23.860]  у нас есть вывод salty
[01:33:23.860 --> 01:33:25.860]  это обычный ASCII
[01:33:25.860 --> 01:33:27.860]  некоторый префикс salty дальше
[01:33:27.860 --> 01:33:29.860]  а после
[01:33:29.860 --> 01:33:31.860]  идет какой-то рандом
[01:33:31.860 --> 01:33:33.860]  если мы посмотрим на
[01:33:33.860 --> 01:33:35.860]  то же самое в файле 2
[01:33:35.860 --> 01:33:37.860]  эти байтики у нас отличаются
[01:33:37.860 --> 01:33:39.860]  и они каждый раз берутся
[01:33:39.860 --> 01:33:41.860]  рандом
[01:33:41.860 --> 01:33:43.860]  если я напишу
[01:33:43.860 --> 01:33:45.860]  при оцифровании
[01:33:45.860 --> 01:33:47.860]  опцию еще одну
[01:33:47.860 --> 01:33:49.860]  но salt
[01:33:51.860 --> 01:33:53.860]  то же самое
[01:33:53.860 --> 01:33:55.860]  и для первого и второго файла
[01:33:55.860 --> 01:33:57.860]  теперь посчитаем
[01:33:57.860 --> 01:33:59.860]  на 5
[01:33:59.860 --> 01:34:01.860]  каждого из файлов
[01:34:01.860 --> 01:34:03.860]  они будут совпадать
[01:34:03.860 --> 01:34:05.860]  и что у нас будет представлять собой
[01:34:07.860 --> 01:34:09.860]  в этом представлении
[01:34:09.860 --> 01:34:11.860]  в этом представлении у нас уже не содержит
[01:34:11.860 --> 01:34:13.860]  префикса ASCII salty
[01:34:13.860 --> 01:34:15.860]  и каких-то дополнительных 8 байтов
[01:34:15.860 --> 01:34:17.860]  это может быть вам полезно
[01:34:17.860 --> 01:34:19.860]  для отладки
[01:34:19.860 --> 01:34:21.860]  когда вы генерируете себе тестовые данные
[01:34:21.860 --> 01:34:23.860]  для решения второй задачи
[01:34:23.860 --> 01:34:25.860]  вот таким образом можно указать
[01:34:25.860 --> 01:34:27.860]  и дальше
[01:34:27.860 --> 01:34:29.860]  строчку вида 00
[01:34:29.860 --> 01:34:31.860]  01,02,03,04,05,06,07
[01:34:31.860 --> 01:34:33.860]  что это такое
[01:34:33.860 --> 01:34:35.860]  это соль
[01:34:35.860 --> 01:34:37.860]  заданная
[01:34:37.860 --> 01:34:39.860]  явным образом
[01:34:39.860 --> 01:34:41.860]  получаем salty
[01:34:41.860 --> 01:34:43.860]  а дальше циферки 01,02,03,04,05,06,07
[01:34:45.860 --> 01:34:47.860]  8 байтиков
[01:34:47.860 --> 01:34:49.860]  16 личной записи
[01:34:49.860 --> 01:34:53.860]  соль фиксированная
[01:34:53.860 --> 01:34:55.860]  может использоваться
[01:34:55.860 --> 01:34:57.860]  либо для тестирования
[01:34:57.860 --> 01:34:59.860]  каких-то криптографических алгоритмов
[01:34:59.860 --> 01:35:01.860]  например получать какой-то
[01:35:01.860 --> 01:35:03.860]  строго фиксированный результат
[01:35:03.860 --> 01:35:05.860]  в наборе тестов
[01:35:05.860 --> 01:35:07.860]  либо при дебаге
[01:35:07.860 --> 01:35:09.860]  других назначений у фиксированной соли
[01:35:09.860 --> 01:35:11.860]  у нас нет, иначе смысл весь соли у нас теряется
[01:35:13.860 --> 01:35:15.860]  на этом все
[01:35:15.860 --> 01:35:17.860]  есть ли у вас вопросы
[01:35:19.860 --> 01:35:21.860]  соль это значит фактически ее отсутствие
[01:35:21.860 --> 01:35:23.860]  это фактически 0 бит
[01:35:23.860 --> 01:35:25.860]  да, просто не будет соли
[01:35:29.860 --> 01:35:31.860]  это просто оски представления
[01:35:31.860 --> 01:35:33.860]  но это то же самое
[01:35:33.860 --> 01:35:35.860]  что в коне
[01:35:35.860 --> 01:35:37.860]  каждый символ 1 байт
[01:35:37.860 --> 01:35:39.860]  в предположении что это оски
[01:35:39.860 --> 01:35:41.860]  то что не оски
[01:35:41.860 --> 01:35:43.860]  оно кодируется просто
[01:35:43.860 --> 01:35:45.860]  все невидимые символы кодируются невидимыми символами
[01:35:45.860 --> 01:35:47.860]  так
[01:35:47.860 --> 01:35:49.860]  последние
[01:35:49.860 --> 01:35:51.860]  раз, два, три, четыре
[01:35:51.860 --> 01:35:53.860]  пять, шесть, семь
[01:35:53.860 --> 01:35:55.860]  да, восемь байт
[01:35:55.860 --> 01:35:57.860]  то есть если оно совпадает с сольской солти
[01:35:57.860 --> 01:35:59.860]  два подчеркивания, значит соли есть
[01:35:59.860 --> 01:36:01.860]  если нет, не совпадает, то соли нет
[01:36:01.860 --> 01:36:03.860]  да, соли может быть
[01:36:03.860 --> 01:36:05.860]  файл, который сгенерирован
[01:36:05.860 --> 01:36:07.860]  с опцией no-salt
[01:36:09.860 --> 01:36:11.860]  если соль есть, тогда нужно
[01:36:11.860 --> 01:36:13.860]  вот эти байтики извлечь
[01:36:13.860 --> 01:36:15.860]  все остальное
[01:36:15.860 --> 01:36:17.860]  у нас идет
[01:36:17.860 --> 01:36:19.860]  можно посмотреть
[01:36:19.860 --> 01:36:21.860]  опять же
[01:36:21.860 --> 01:36:23.860]  я уже удалил
[01:36:23.860 --> 01:36:25.860]  если даже не будет
[01:36:25.860 --> 01:36:27.860]  я убираю явную соль
[01:36:27.860 --> 01:36:29.860]  и сразу
[01:36:29.860 --> 01:36:31.860]  это будет файл
[01:36:31.860 --> 01:36:33.860]  1 янк и xxd 1 янк
[01:36:33.860 --> 01:36:35.860]  давайте сравним
[01:36:35.860 --> 01:36:37.860]  что у нас отличается
[01:36:37.860 --> 01:36:39.860]  у нас отличаются вот эти байтики
[01:36:39.860 --> 01:36:41.860]  данные все равно отличаются
[01:36:41.860 --> 01:36:43.860]  да, логично
[01:36:45.860 --> 01:36:47.860]  так, ладно
[01:36:47.860 --> 01:36:49.860]  есть ли у вас еще вопросы
[01:36:53.860 --> 01:36:55.860]  так, ну и что у нас там дальше
[01:36:55.860 --> 01:36:57.860]  давайте немножко посмотрим
[01:36:57.860 --> 01:36:59.860]  на
[01:36:59.860 --> 01:37:01.860]  конец семестра, поскольку сегодня
[01:37:01.860 --> 01:37:03.860]  22 ноября
[01:37:05.860 --> 01:37:07.860]  вот и хороший вопрос
[01:37:07.860 --> 01:37:09.860]  сколько вам, да
[01:37:09.860 --> 01:37:11.860]  я реально там оставил что-нибудь
[01:37:11.860 --> 01:37:13.860]  на потом, что можно просто выкинуть
[01:37:13.860 --> 01:37:15.860]  так, open-sale тема важная
[01:37:15.860 --> 01:37:17.860]  согласны? согласны
[01:37:17.860 --> 01:37:19.860]  давайте сразу календарь
[01:37:23.860 --> 01:37:25.860]  так, 28
[01:37:25.860 --> 01:37:27.860]  значит 29 все заканчивается
[01:37:27.860 --> 01:37:29.860]  логично
[01:37:29.860 --> 01:37:31.860]  так, дальше 29 у вас закрывается конец
[01:37:31.860 --> 01:37:33.860]  до 6
[01:37:33.860 --> 01:37:35.860]  это еще один
[01:37:35.860 --> 01:37:37.860]  там по плану было
[01:37:37.860 --> 01:37:39.860]  фьюзы
[01:37:39.860 --> 01:37:41.860]  это реализация своих файловых систем
[01:37:41.860 --> 01:37:43.860]  а потом у нас еще остается
[01:37:43.860 --> 01:37:45.860]  хайлоут
[01:37:45.860 --> 01:37:47.860]  а, ну в принципе нормально
[01:37:47.860 --> 01:37:49.860]  все укладываемся, все хорошо, все замечательно
[01:37:49.860 --> 01:37:51.860]  29 по 6
[01:37:51.860 --> 01:37:53.860]  вы делаете
[01:37:57.860 --> 01:37:59.860]  блин, да
[01:37:59.860 --> 01:38:01.860]  следующий контент открывается
[01:38:01.860 --> 01:38:03.860]  27, 4, 11
[01:38:03.860 --> 01:38:05.860]  в любом случае
[01:38:05.860 --> 01:38:07.860]  да, у вас по семинарам количество
[01:38:07.860 --> 01:38:09.860]  ходит
[01:38:09.860 --> 01:38:11.860]  и там задачи, которые
[01:38:11.860 --> 01:38:13.860]  на
[01:38:13.860 --> 01:38:15.860]  файловые системы
[01:38:15.860 --> 01:38:17.860]  они не сложные, но они
[01:38:17.860 --> 01:38:19.860]  громоздкие по реализации
[01:38:19.860 --> 01:38:21.860]  а задачи, которые на епол они
[01:38:21.860 --> 01:38:23.860]  небольшие по объему, но там
[01:38:23.860 --> 01:38:25.860]  требуется понимание писать
[01:38:25.860 --> 01:38:27.860]  ну смотри, на фьюз там нужно
[01:38:27.860 --> 01:38:29.860]  писать пеленку в несколько экранов кода
[01:38:29.860 --> 01:38:31.860]  поэтому
[01:38:31.860 --> 01:38:33.860]  их проходим раньше, а потом
[01:38:33.860 --> 01:38:35.860]  хайлоут
[01:38:35.860 --> 01:38:37.860]  нормально все успеваем по 15 часам
[01:38:45.860 --> 01:38:47.860]  домашней которой
[01:38:47.860 --> 01:38:49.860]  нет, там главное
[01:38:49.860 --> 01:38:51.860]  аккуратно все писать
[01:38:51.860 --> 01:38:53.860]  и локально потестировать, прежде чем отправлять
[01:38:53.860 --> 01:38:55.860]  потому что если вы
[01:38:55.860 --> 01:38:57.860]  типовая проблема прошлого года, то что
[01:38:57.860 --> 01:38:59.860]  отправляли не протестированные решения
[01:38:59.860 --> 01:39:01.860]  совсем
[01:39:01.860 --> 01:39:03.860]  на тесте, где
[01:39:03.860 --> 01:39:05.860]  размер чуть больше, чем размер ключа
[01:39:07.860 --> 01:39:09.860]  если вы хотя бы протестируете, что у вас
[01:39:09.860 --> 01:39:11.860]  входные данные размером больше, чем размер
[01:39:11.860 --> 01:39:13.860]  ключа, проходят, то большая часть
[01:39:13.860 --> 01:39:15.860]  работы уже выполнена
[01:39:19.860 --> 01:39:21.860]  оглашу, но не сейчас, да
[01:39:21.860 --> 01:39:23.860]  чем больше, тем лучше
[01:39:23.860 --> 01:39:25.860]  стандартный ответ
[01:39:27.860 --> 01:39:29.860]  но вы фистейки, чем больше, тем лучше
