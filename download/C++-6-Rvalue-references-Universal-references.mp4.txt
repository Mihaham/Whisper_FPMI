[00:00.000 --> 00:12.600]  Значит, я быстренько напомню, что мы делали. Я определял, что такое lvalue и rvalue формально.
[00:12.600 --> 00:27.400]  Значит, что такое lvalue и что такое rvalue? Значит, имя переменной это lvalue, литерал это rvalue.
[00:27.400 --> 00:36.800]  Дальше там бинарные всякие операторы. Плюс, минус, умножить и так далее. Это lvalue.
[00:36.800 --> 00:44.080]  Тьфу, наоборот. Бинарные плюс равно, минус равно, умножить равно и так далее. Это lvalue.
[00:44.080 --> 00:55.480]  А плюс, минус, умножить, разделить и так далее. Это rvalue. Дальше унарная звездочка и возможно
[00:55.480 --> 01:07.560]  что-то еще. Это lvalue, амперсант, тильда и прочее. Это rvalue. Потом у нас был префиксный
[01:07.560 --> 01:19.080]  инкремент. Это lvalue, постфиксный инкремент. Это rvalue. Дальше, кажется, я говорил про тернарный
[01:19.080 --> 01:27.320]  оператор. Ну, я не буду уж дальше все это делать. Тернарный оператор там когда-то lvalue,
[01:27.320 --> 01:40.520]  когда-то rvalue. И последний пункт, точнее последние два пункта, самое для нас важное. Это вызов функции,
[01:40.520 --> 01:58.160]  если возвращаемое значение, значит, с возвращаемым значением t амперсант,
[01:58.160 --> 02:09.440]  а здесь вызов функции, у которого возвращаемое значение t или t двойной амперсант, где t не
[02:09.440 --> 02:17.160]  при тип. Бессылочный. То есть, если мы возвращаем тип с одним амперсантом, то результат вызов этой
[02:17.160 --> 02:29.400]  функции lvalue. Если возвращаем с двумя, то rvalue или без амперсантов. И cast expression с возвращаемым
[02:29.400 --> 02:44.720]  типом t амперсант. То же самое. Это lvalue, в то время как cast expression к t или t двойному амперсанту,
[02:44.720 --> 02:55.800]  это rvalue. И вот тут начинает проявляться понимание того, что такое t с двойным амперсантом.
[02:55.800 --> 03:07.960]  То есть, по сути, t с двойным амперсантом это такая ссылка, которая в общем-то как обычная ссылка,
[03:07.960 --> 03:16.240]  но если ее вернуть из функции или из cast expression, то это будет считаться rvalue, а не lvalue.
[03:16.240 --> 03:25.680]  Вот в чем, по сути, смысл. Пока это, конечно, еще все не отвечает на очень многие вопросы,
[03:25.680 --> 03:43.520]  но что-то начинает проясняться. Если вспомнить реализацию sdmove, которую мы писали в прошлый раз,
[03:43.520 --> 03:50.840]  то там мы вспоминаем, что было написано static cast к... что-то там с двумя амперсантами,
[03:50.840 --> 04:00.400]  это как раз получается rvalue. И возвращаемый тип с двумя амперсантами, это получается rvalue.
[04:00.400 --> 04:05.960]  Поэтому, когда мы вызываем sdmove, мы всегда получаем rvalue. То есть, результат вызывая sdmove
[04:05.960 --> 04:16.800]  это rvalue, при этом вот это тот самый объект, от которого был sdmove. То есть, по сути,
[04:16.800 --> 04:24.200]  sdmove это rvalue... это можно было бы сказать... можно было бы назвать rvalue cast. sdmove
[04:24.200 --> 04:41.800]  это просто cast rvalue. Был какой-то объект. Давайте трактовать его как rvalue теперь. Вот и все.
[04:41.800 --> 04:49.480]  Ну, есть еще несколько пунктов, которые я не перечислил. Давайте, наверное, сейчас я открою,
[04:49.480 --> 05:02.400]  поскольку у меня теперь есть интернет и импровизированный проектор досках. Я могу открыть
[05:02.400 --> 05:14.560]  страницу с формальным описанием всего этого. Сейчас на нее посмотрим. То есть, я таблицу нарисовал
[05:14.560 --> 05:27.120]  для такого основного перечтения. Вот, давайте посмотрим на то, что такое lvalue формально. Ну вот,
[05:27.120 --> 05:42.080]  еще я не упомянул результат вызова оператора точки. Если a само было lvalue, то a. что-то это
[05:42.080 --> 05:47.360]  тоже lvalue. Если мы к полю обращаемся, и стрелочка то же самое, и точка со звездочкой, и стрелочка со
[05:47.360 --> 05:55.160]  звездочкой. Вот если у меня a это lvalue, то результат такого это тоже будет lvalue. Вот, но тут по некоторым
[05:55.160 --> 06:04.360]  техническим причинам довольно, значит, ну есть некоторый странный пункт. Например, стринг
[06:04.360 --> 06:09.400]  литерала это lvalue считается. Не любой литерал считается lvalue, а rvalue, а стринг литерал считается
[06:09.400 --> 06:15.720]  lvalue. Но это такие технические тонкости, где-то костыли про которые я не хочу говорить. Вот, ну и
[06:15.720 --> 06:26.240]  есть понятие rvalue, которое определяет себе два понятия на самом деле. prvalue и xvalue. Вот, и тут
[06:26.240 --> 06:32.760]  перечислено, что это такое. Я сейчас не хочу говорить даже о том, что такое xvalue, чем он
[06:32.760 --> 06:42.040]  отличается от prvalue. Давайте просто пока сойдемся на том, что это все называется rvalue, и для понимания
[06:42.040 --> 06:47.800]  муксимантики на самом деле этого будет достаточно. А про то, что такое xvalue мы тоже поговорим, конечно,
[06:47.800 --> 06:57.760]  но через, ну чуть попозже, когда поем основное. Ну вот, ну а теперь самое время поговорить о том,
[06:57.760 --> 07:05.240]  что такое все-таки вот эти rvalue ссылки. Ну то есть, вот это вот было формальное
[07:05.240 --> 07:12.120]  определение lvalue, rvalue. А теперь давайте поговорим о том, что такое rvalue references. Ну я назову
[07:12.120 --> 07:28.400]  следующий пункт. Собственно, это будет параграф 10.6, кажется. Значит, rvalue references. Так, что у меня
[07:28.400 --> 07:34.640]  какие-то вещественные числа получились вместо обычного r. rvalue references и их свойства.
[07:34.640 --> 07:52.400]  Теперь, когда я определил все это, можно объяснить, что такое rvalue ссылка на самом деле. Ну, во-первых,
[07:52.400 --> 08:02.720]  это ссылка. То есть, все свойства, присущие ссылкам, что касается того, что она неотвечима от объекта,
[08:02.720 --> 08:08.920]  вот это вот все, что присваивание ей, это присваивание объекту, это все остается вверх. То есть,
[08:08.920 --> 08:19.480]  это ссылка. Главная разница в том, что, во-первых, инициализировать эту ссылку можно лишь через rvalue,
[08:19.480 --> 08:32.160]  а второе, это что возвращая эту ссылку из функции вы получаете rvalue. Сейчас поясню. Вот, допустим,
[08:32.160 --> 08:42.800]  у меня есть какой-то... Наверное, тут я лучше код открою. У меня есть какой-то, ну скажем,
[08:42.800 --> 08:59.520]  int обычный. Вот давайте на примере кода посмотрим, как работают rvalue ссылки. Вот есть у меня int.
[08:59.520 --> 09:18.400]  Я могу сказать int&r равно x, и это обычная ссылка. Могу сказать const int&r равно x или r, без разницы.
[09:18.400 --> 09:24.440]  Это будет константная ссылка. Вот такие ссылки отныне мы будем называть lvalue ссылками. Ну,
[09:24.440 --> 09:39.920]  просто ссылки, они же lvalue ссылки. Что такое rvalue ссылка? rvalue ссылка int двойной амперсант rr может
[09:39.920 --> 09:52.600]  быть инициализирована только посредством rvalue. То есть, если я напишу и вот так,
[09:52.600 --> 10:02.560]  это будет CE. Давайте я продемонстрирую. Вот, cannot bind rvalue regions of type lvalue of type int.
[10:02.560 --> 10:21.240]  Заметьте, lvalue of type int. lvalue это не часть type int, а выражение lvalue. Хорошо. Я напоминаю,
[10:21.240 --> 10:26.960]  что lvalue ссылки нельзя инициализировать посредством rvalue, а rvalue ссылки наоборот.
[10:26.960 --> 10:38.080]  Дальше. Могу ли я... ну, окей, хорошо. Ну, тогда, наверное, я могу написать вот так. Вот так я бы не
[10:38.080 --> 10:52.120]  мог написать, как вы, я надеюсь, помните. А вот так могу. Потому что справа lvalue. В этом идее
[10:52.120 --> 11:02.200]  lvalue ссылки. Инициализируется она с помощью lvalue тока. А что надо сделать, если я хочу сделать
[11:02.200 --> 11:14.840]  lvalue ссылку на x? lvalue cast. Правильно, нужно сделать sdmove. Чтобы инициализировать lvalue ссылку
[11:14.840 --> 11:24.000]  существующим объектам, нужно, чтобы выражение справа стало lvalue. Но lvalue to lvalue cast,
[11:24.000 --> 11:37.200]  он так не явно не происходит, его явно надо делать. Вот. То есть, с помощью функции sdmove,
[11:37.200 --> 11:45.320]  я явно говорю, в этом есть некоторая аналогия между константами и неконстантами. Грубо говоря,
[11:45.320 --> 11:57.080]  lvalue это такая штука, которая, ну, lvalue это такая штука, которая, скажем так, не все позволяет над
[11:57.080 --> 12:04.000]  собой делать. Ну, условно. Какая-то аналогия прослеживается. В чем смысл move? Это значит,
[12:04.000 --> 12:10.680]  мы сейчас отдадим этот объект куда-то, чтобы его испортить. Ну, грубо говоря, да. И если мы
[12:10.680 --> 12:19.240]  хотим lvalue ссылку у него создать, обычно это означает, что мы собираемся сейчас его как-то
[12:19.240 --> 12:28.680]  дальше пропихнуть, чтобы из него забрали содержимое. Но вот просто lvalue ссылку
[12:28.680 --> 12:32.880]  пронициализировать объектами так нельзя. Нужно явно написать, что я cast делаю к lvalue.
[12:32.880 --> 12:44.640]  Вопрос на понимание. Вот я сейчас напишу им двойной имперсант, не знаю, rr, равно rr.
[12:44.640 --> 12:58.480]  Вроде да. Нет, потому что rr это же lvalue. Отлично. Правильно. Значит, господин Садович, молодец.
[12:58.480 --> 13:03.120]  Вот господин Евтеев сделал ошибку, которую я предрекал в прошлый раз. Я говорил вам,
[13:03.120 --> 13:14.680]  что вы еще ошибетесь. Нельзя, конечно. Так нельзя, потому что справа lvalue. Понятно?
[13:14.680 --> 13:26.480]  Значит, не важно какой тип, важно какой вид value. Когда вы имеете дело с rvalue ссылкой, то,
[13:26.480 --> 13:32.640]  что у нее тип rvalue ссылка, не означает, что объект теперь под ней. Вообще объект не бывает rvalue
[13:32.640 --> 13:42.240]  или lvalue, но имя переменной всегда lvalue. Всегда, когда вы функцию передали, значит, что-то по rvalue
[13:42.240 --> 13:47.760]  ссылке, там оно уже снова lvalue стало. Если вы хотите его дальше move-нуть, то надо опять явно
[13:47.760 --> 13:56.360]  написать move. Это будет опять rvalue cast. Давайте с конс теперь разберемся. Как это все работает
[13:56.360 --> 14:03.800]  вместе с const? Ну, независимо. const – это вещь, которая продолжает работать, как и раньше,
[14:03.800 --> 14:10.600]  независимо от всего того, что я сказал. Артагональные вещи. Ну, то есть, по-прежнему
[14:10.600 --> 14:18.880]  можно навешивать const на это все. Но это довольно бессмысленно. Я не знаю практически полезных
[14:18.880 --> 14:31.840]  примеров, где нужно было бы использовать const rvalue ссылку. Но скорее это такие уроцы,
[14:31.840 --> 14:40.240]  искусственно созданные типы, но довольно бесполезные. const lvalue ссылка отличается
[14:40.240 --> 14:48.120]  от обычной lvalue ссылки тем, что ее можно инициализировать через rvalue. Я тут пишу 5,
[14:48.120 --> 15:03.520]  что является rvalue, но мог бы написать и вот так, например. То есть, константная ссылка, а в отличие
[15:03.520 --> 15:08.560]  от обычной ссылки, мы это обсуждали в первом семестве, обладает тем свойством, что ее можно
[15:08.560 --> 15:14.160]  инициализировать посредством rvalue. Не посредством константы, а посредством rvalue, вот что важно. То
[15:14.160 --> 15:21.840]  есть, литерала или, например, результат sdmove. А вот эту вот нельзя посредством lvalue, как я уже
[15:21.840 --> 15:36.040]  говорил. Что такое const rvalue ссылка? Ну, все точно так же, как если бы мы const висели на обычную
[15:36.040 --> 15:44.080]  ссылку. В одну сторону можно, в обратную нельзя. Ну, то есть, я могу сделать sdmove от rr и
[15:44.080 --> 15:54.160]  проинициализировать таким образом const rvalue ссылку. Если потом у меня опять будет rvalue ссылка,
[15:54.160 --> 16:08.720]  rr равно sdmove от crr, то так уже нельзя, потому что с видом value на этот раз все хорошо,
[16:08.720 --> 16:17.040]  но константность нарушена. Значит, binding, reference of type, bla-bla-bla, discards, qualifiers,
[16:17.040 --> 16:28.800]  знакомые слова вам уже, я думаю. Вот. Ну, зато вот так можно. Константность не нарушена.
[16:34.800 --> 16:46.520]  Итак, в чем поняли? Мы поняли, что у нас теперь есть такой особенный вид ссылок, который
[16:46.520 --> 16:56.080]  обладает всеми теми же свойствами, что и обычными ссылки, но есть два важных ключевых отличия. Вот
[16:56.080 --> 17:06.680]  самая главная суть. Их инициализировать можно только посредством rvalue, а еще возвращение их из
[17:06.680 --> 17:13.720]  функций это rvalue, а не lvalue. Это приводит нас к тому, что мы теперь способны делать перегрузку по
[17:13.720 --> 17:22.320]  виду value. Вдумайтесь, вот эти правила, вот в точности они позволяют нам делать перегрузку по виду
[17:22.320 --> 17:31.280]  value. То есть иногда мы можем, если мы ничего явно не будем писать, все будет работать как раньше,
[17:31.280 --> 17:38.680]  никакого move, никаких rvalue ссылок, но если мы, в обратную сторону, как бы неявные касты работают,
[17:38.680 --> 17:43.920]  то есть я могу конст, инт, амперсант проинициализировать результатом move. Это
[17:43.920 --> 17:49.480]  будет работать как и раньше. Если у меня нету версии для двойного амперсанда, то каст в сторону
[17:49.480 --> 17:54.680]  конст, инт, амперсанда не явно сделается, а двойного амперсанда конст, инт, амперсанду сделается,
[17:54.680 --> 18:05.440]  а в обратную сторону не сделается без явного каста. Но не просто он не сделается, а еще и вид
[18:05.440 --> 18:11.400]  value должен совпасть. То есть чтобы мне попасть в версию, которая принимает инт двойного амперсанда,
[18:11.400 --> 18:17.040]  но не инт двойного амперсанда, а т двойного амперсанда, произвольный т, мне мало чтобы
[18:17.040 --> 18:21.880]  передаваемый аргумент был с типом двойного амперсанда, мне надо чтобы еще вид value был у него
[18:21.880 --> 18:28.320]  правильнее. Ну поэтому у меня и работает перегрузка. Вот если у меня есть вектор,
[18:28.320 --> 18:36.440]  а давайте-ка я наверное вот здесь вот снова открою вектор. Вот у нас был вектор, в очередной
[18:36.440 --> 18:50.480]  раз я открываю вектор, и тут есть pushback. Вот теперь я могу, значит, этот pushback скопировать,
[18:50.480 --> 18:58.560]  и это в pushback будет отличаться от того pushback'а, по сути, только вот этим. Ну я, конечно,
[18:58.560 --> 19:06.840]  нехорошо сделал кипя пасту, но сейчас простительно. Теперь у меня есть два pushback'а, в частности,
[19:06.840 --> 19:13.880]  вектор. Один принимает т двойного амперсанда, другой примет код с т амперсанда. И если я в pushback
[19:13.880 --> 19:26.520]  передаю rvalue, то вот это становится предпочтительной вещью. Если же я в pushback передаю lvalue,
[19:26.520 --> 19:33.960]  в частности, пусть даже я передаю туда rvalue ссылку, но передаю ее какими-то переменной. Вот эта
[19:33.960 --> 19:38.960]  версия отпадает, потому что она, ну потому что не подходит эта версия. Нельзя принцелизировать это
[19:38.960 --> 19:45.640]  посредством того, что я дал. Значит, выбирается эта версия. Если же у меня не было бы вот этой
[19:45.640 --> 19:51.880]  версии вообще, то в любом случае выбиралась бы эта версия по-прежнему, потому что в эту сторону
[19:51.880 --> 20:09.120]  каст нормально работает. Ну вот сейчас, по сути, я, можно сказать, озвучил всю часть про move.
[20:09.120 --> 20:15.880]  Это еще не все. Сейчас у нас еще остались не закрытые некоторые гестальты. Но про то,
[20:15.880 --> 20:23.520]  как работает move, про то, как работает выбор вот этих вот версий, и что такое rvalue ссылка,
[20:23.520 --> 20:30.440]  вот сейчас должно стать понятно. Ну, если забыть про то, что у нас там в move была принималась
[20:30.440 --> 20:34.080]  т двойная персанда, мы не понимали, что это означает в том контексте. Забудьте про ту
[20:34.080 --> 20:42.880]  проблему, и просто как будто вы о ней не слышали. И вот тогда все должно быть понятно. Вот есть ли
[20:42.880 --> 20:51.600]  вопросы про эту часть. Когда, за счет чего мы теперь решили проблемы с разными версиями pushback,
[20:51.600 --> 20:59.200]  как работает move. Они точно появятся, когда мы начнем мапу писать, но пока все вроде кажется,
[20:59.200 --> 21:16.400]  что все понятно. Окей, хорошо. Еще раз, вкратце, главные мифы. Разоблачение мифов. Главное,
[21:16.400 --> 21:24.960]  что нужно помнить. Во-первых, std move сама по себе как функция ничего не делает с объектом. Она
[21:24.960 --> 21:29.760]  вообще не генерирует процессорных инструкций. Это просто каст для компилятора, говорящий о том,
[21:29.760 --> 21:34.360]  какую версию перегрузки выбрать надо. Если вы просто вызовете std move от чего-то,
[21:34.360 --> 21:39.240]  точка запятой, и ничему не присвоите результат, ничего с объектом не произойдет. Это вообще
[21:39.240 --> 21:47.640]  проигнорируется. Второй миф. rvalue и lvalue это свойство выражений, а не объектов. Не имеет
[21:47.640 --> 21:54.160]  смысла спросить данный объект rvalue или lvalue. Имеет смысл спросить синтоксические данные выражения.
[21:55.040 --> 22:01.480]  И выбор происходит между этими версиями именно по виду value, в первую очередь.
[22:01.480 --> 22:11.840]  Ну и третье, в частности, rvalue ссылка, это не такая ссылка, что вот она rvalue является. Это такая
[22:11.840 --> 22:18.080]  ссылка, что инициализировать ее можно посредством только rvalue. И возвращая ее из функции вы получаете
[22:18.080 --> 22:23.840]  rvalue выражение. Вот в чем суть rvalue ссылки, а не в том, что она якобы сама rvalue. Вообще
[22:23.840 --> 22:28.880]  нет смысла спрашивать, она является чем. Это свойство выражения еще, повторяю, а не объектов.
[22:32.880 --> 22:40.160]  У нас осталась еще одна проблема. А, прежде чем говорить про еще одну проблему, я вот что скажу.
[22:40.160 --> 22:50.320]  Вот сейчас... Илья, можно вопрос? Да, конечно. Ты сказал, что если вернуть rvalue ссылку из
[22:50.320 --> 22:58.800]  функции, то получится rvalue. Да. Это потому что то, что получится при возвращении с функции, зависит
[22:58.800 --> 23:07.000]  не от типа выражения, а уже от типа данных, которые мы возвращаем. Нет, если... Сейчас, вот это вот...
[23:07.000 --> 23:18.960]  Вот тут вот я перечислял, что является rvalue. И тут написано, что если выражение представляет
[23:18.960 --> 23:24.720]  себя функциональный вызов, в котором возвращаемый тип что-то с двойным имперсантом, то такой
[23:24.720 --> 23:30.920]  функциональный вызов это rvalue выражение. Это место, где что-то зависит от типа, с которым мы работаем. Да, это
[23:30.920 --> 23:38.840]  правда. Это правда. Ну, не совсем корректно говорить, что это чисто синтоксическое свойство, но это в
[23:38.840 --> 23:47.560]  большей степени синтоксическое свойство. То есть компилятор смотрит в определение функции и решает
[23:47.560 --> 23:57.080]  в зависимости от возвращаемого типа, что это будет зависеть от этого. Окей. Ну да, это правда. Это вот то
[23:57.080 --> 24:05.200]  самое место, где оно зависит от типа. Так вот, сейчас я хочу еще поговорить про ссылочные
[24:05.200 --> 24:16.720]  квалификаторы. Вектор я закрою. Открою снова вот это. Вот смотрите, у меня есть какой-нибудь класс...
[24:16.720 --> 24:30.040]  Ой, какой void. Ну, многие из вас уже знают про это. Ну, давайте теперь мы аккуратненько уже с новыми
[24:30.040 --> 24:43.480]  знаниями проговорим. Значит, мы научились сейчас, по сути, делать выбор версии функций по виду
[24:43.480 --> 24:54.480]  value принимаемого значения. Ну, по аналогии с тем, как у нас бывали раньше конст-квалификаторы,
[24:54.480 --> 25:01.000]  можно было бы захотеть сделать и ссылочные квалификаторы. Что такое конст-квалификаторы?
[25:01.000 --> 25:22.520]  Вот у меня есть void f, не знаю, которая выводит 1, а есть void f const, которая выводит 2. И что это такое?
[25:22.520 --> 25:31.840]  Это перегрузка по константности самого того объекта, которого мы вызываем. Это ни у кого вопросов
[25:31.840 --> 25:39.240]  уже не должно вызывать. Но я могу организовать перегрузку, начиная с плюс плюс одиннадцать,
[25:39.240 --> 25:49.000]  и по виду value моего объекта. Не по виду value принимаемого объекта, как я научился это делать,
[25:49.960 --> 26:07.280]  а по виду value самого того объекта, от которого я вызываюсь. Ну, как бы, подкол засчитан, но понятно,
[26:07.280 --> 26:13.920]  что я имел в виду, имел в виду, что вот если я пишу что-то типа x, вот что-то, точка f,
[26:13.920 --> 26:23.480]  вот в зависимости от вида value того, что тут, я хочу, чтобы вызывалась либо одна f, либо другая.
[26:23.480 --> 26:40.600]  Ну, вид value не самого объекта, а как бы того, той ипостасии, в которую он перед нами предстал,
[26:40.600 --> 26:46.360]  когда мы вызывали f. Вот он может быть, он мог быть подан нам как lvalue в некотором выражении,
[26:46.360 --> 26:51.960]  ну, как rvalue. Вот в зависимости от этого разные версии f вызвать можно. Например,
[26:51.960 --> 27:05.360]  давайте я заведу такую my struct s и напишу s.f. Вот так я хочу, чтобы вызвался один. А если бы я
[27:05.360 --> 27:19.640]  написал, скажем, plus у меня нет, я мог написать std move от s.f, должно вывестись 2. Ну, или если бы
[27:19.640 --> 27:30.400]  я просто написал my struct .f, тоже должно вывестись 2. Потому что вот это rvalue. Это подпадает под
[27:30.400 --> 27:36.320]  пункт вызов функции возвращаемый тип, который без ссылок. Ну, это вызов конструктора, как бы.
[27:36.320 --> 27:42.720]  То есть вызов user defined метода, у которого возвращаемый тип, это t без всяких ссылок.
[27:42.720 --> 27:48.040]  Значит, это rvalue. Так, вопрос в чате. Правда ли, что если какая-то моя функция будет типа t,
[27:48.040 --> 27:55.720]  то никогда не станет хуже, если я вместо этого напишу return std move от result? Неправда. Иногда
[27:55.720 --> 28:03.560]  станет хуже и про это мы скоро поговорим. А именно станет хуже в случае, когда там была rvo. Про
[28:03.560 --> 28:12.480]  это мы поговорим. Мы успеем сегодня поговорить про это. Stay tuned, мы дойдем до этого. Так вот,
[28:12.480 --> 28:20.440]  как это делается, ну вы наверно уже знаете, многие из вас, делается это так. Я могу написать
[28:20.440 --> 28:31.560]  ссылочный квалификатор там на том же месте, где обычно я ставлю конструктор. Вот. Вот такой
[28:31.560 --> 28:38.360]  квалификатор означает, что эта функция пригодна только для lvalue левого аргумента. То есть до
[28:38.360 --> 28:44.280]  точки lvalue должно стоять. А это значит только для lvalue левого аргумента. Если нет вообще ссылочного
[28:44.280 --> 28:50.880]  квалификатора, это значит функция пригодна для чего угодно. Скомпилируем. Ну вот получилось,
[28:50.880 --> 28:57.600]  как я говорил, 1, 2, 2. Вот. Если бы у меня была вот такая функция и такая функция, то это было бы ce,
[28:57.600 --> 29:07.960]  кажется. Сейчас проверим. Да. То есть я либо определяю одну для обоих видов value, либо я
[29:07.960 --> 29:12.840]  определяю только одну для какого-то вида value, а для второго тогда он будет запрещено. Либо я
[29:12.840 --> 29:19.040]  определяю две для раз. Ну вот, короче, делать такую перегрузку нельзя. Но можно сделать перегрузку вот
[29:19.040 --> 29:31.680]  такую. Зачем это может быть надо? Ну, например, у вас объект хранит себе какой-то большой блок
[29:31.680 --> 29:39.640]  данных. И вы собираетесь написать функцию, которая этот блок данных вам возвращает. Вот представившим
[29:39.640 --> 29:58.680]  функцию возвращает там, не знаю, ну, str, скажем. А в полях тут есть собственно str. Вот. Тогда
[29:58.680 --> 30:19.400]  здесь я мог бы, скажем, сказать return str, а тут я мог бы сказать return std move от str. Самое главное,
[30:19.400 --> 30:27.200]  я вам формально все это рассказываю, но мы совсем забыли об идее, зачем move надо. Move надо,
[30:27.200 --> 30:32.400]  когда мы собираемся. Ну, вот это то, что обычно говорят. Все лекции по move семантике обычно
[30:32.400 --> 30:39.680]  начинаются со слов. Иногда мы хотим сказать, как бы что объект скоро будет уничтожен, нам больше не
[30:39.680 --> 30:44.920]  нужен. Вот это скоро будет уничтожено, нам больше не нужно. Мне очень не нравится, потому что непонятно
[30:44.920 --> 30:52.760]  совершенно формально, что это значит. Но надо понимать это как просто мотивацию к всему тому,
[30:52.760 --> 31:00.880]  что я здесь рассказал. Когда мы используем std move? Когда мы понимаем, что этот объект больше,
[31:00.880 --> 31:07.080]  содержимый этого объекта больше не нужен. Он скоро уничтожится все равно или будет замещен чем-то
[31:07.080 --> 31:18.520]  другим. Поэтому если мы имеем дело с объектом, с rvalue, как бы ссылкой на объект, как сказать,
[31:18.520 --> 31:26.880]  вот я говорю с rvalue объектом, чтобы упростить слова с синтаксическим выражением, которое
[31:26.880 --> 31:33.040]  представляет нам объект этот как rvalue. Вот rvalue объект это сокращение, чтобы не говорить вот этого.
[31:33.040 --> 31:45.720]  Вот если мы имеем дело вот с таким, то мы можем отдать просто string через move. Во второй реализации
[31:45.720 --> 32:06.880]  не стинговый написан должен быть. Нет. Зачем? Вот сейчас идея в том, что давайте я скажу,
[32:06.880 --> 32:34.000]  что у меня поле публичное, я вот так вот сделаю. Вот смотрите, вот я утверждаю, что сейчас вот в
[32:34.000 --> 32:45.600]  этой ситуации я получу строку копированием той строки из полей, а в этой ситуации я получу строку
[32:45.600 --> 32:56.160]  губанием. То есть вот здесь вот никакой лишней копии не случится. И еще в структуре s больше будет
[32:56.160 --> 33:04.960]  строки, верно? Да, и после этой строки кода в структуре s будет пустая строка лежать.
[33:04.960 --> 33:13.600]  Так, вот посмотрите на эту строчку и поймите, почему в этой строке кода не произойдет ни
[33:13.600 --> 33:20.880]  одного копирования. Это не совсем очевидно. Ну тут понятно, тут произойдет копирование.
[33:26.320 --> 33:33.400]  А тут почему не произойдет ни одного копирования? Понимаете?
[33:40.640 --> 33:48.360]  Значит, вот здесь я попадаю в эту версию из-за того, что у меня std move перегрузка
[33:48.360 --> 33:55.160]  выбирает вот эту версию. Я говорю return std move от str. Вот это std string инициализируется выражением
[33:55.160 --> 34:00.720]  std move от str, а значит называется move constructor, а не copy constructor. Значит, вот это str становится
[34:00.720 --> 34:09.080]  пустой и все содержимое string переходит, это str переходит в эту string. А потом вот это string
[34:09.080 --> 34:17.720]  инициализируется результатом вызова вот этого. То есть мы вызываем конструктор просто от rvalue?
[34:17.720 --> 34:27.120]  Но это тоже rvalue. Поэтому тоже move constructor будет выбран, если вообще будет. Ну тут на
[34:27.120 --> 34:33.120]  самом деле копия лежим произойдет, но я пока еще не рассказывал, что это такое. Ну даже вот на
[34:33.120 --> 34:38.200]  уровне наших текущих знаний понятно, что не будет ни одного копирования. Потому что вот здесь
[34:38.200 --> 34:43.440]  будет выбран move constructor, потому что от stmove мы конструируемся, вот здесь вот когда написано str2
[34:43.440 --> 35:02.440]  равно что-то, будет выбран move constructor, потому что с правой rvalue написано. И move constructor по
[35:02.440 --> 35:10.960]  правилу он предпочтительнее будет выбран. То есть в худшем случае, если даже компилятор ничего не
[35:10.960 --> 35:18.880]  сооптимизирует, здесь просто будет два move, но ни одного копирования. Почему нет? А почему нет?
[35:18.880 --> 35:37.360]  Почему что? Почему ничто? Типа почему бы так не написать? Или что? Значит, ну я объяснил, почему
[35:37.360 --> 35:45.360]  вот здесь вот возвращаем значение str2 это ок, копирования не будет. Я так полагаю вопрос,
[35:45.360 --> 35:57.440]  почему бы не написать вот так, чем будет хуже? На самом деле будет хуже. А именно как раз, ну давайте
[35:57.440 --> 36:05.160]  я этот вопрос положу в стэк, и вот мы короче, в очередь вот так, мы на него ответим, когда чуть
[36:05.160 --> 36:14.000]  попозже. Но если так написать, то не будет оптимизации, потому что при такой записи компилятор вообще не
[36:14.000 --> 36:21.320]  будет вызывать, произведет copy elision так называемый, второго конструктора вообще не будет вызвано. А вот
[36:21.320 --> 36:31.040]  при таком компилятор менее вероятно сооптимизирует, и ему придется второй раз move constructor вызывать.
[36:31.040 --> 36:58.480]  А, минуточку. Сейчас, я неправильно сказал. Виноват, тут все еще хуже. Давайте вот подумаем,
[36:58.480 --> 37:00.080]  действительно, что будет, если вот так написать?
[37:00.080 --> 37:17.520]  У нас же как бы просто ссылка возвращается. У нас ссылка на объект, который только что уничтожен?
[37:17.520 --> 37:37.040]  Ну он не уничтожен, но вот тут мы получили R-value ссылку на str, тут мы получили R-value ссылку на вот тот
[37:37.040 --> 37:55.640]  самый str. То есть, короче говоря, F дает нам R-value ссылку на вот тот самый str. И мы получили str2 как str. Нет, ну кажется,
[37:55.640 --> 38:07.880]  что нормально. Кажется, что будет работать, да. Ну кажется, будет работать, да. Ну то есть, UB вроде не
[38:07.880 --> 38:32.520]  будет. А это правда, это правильное замечание. Вот если бы, вот это правильное замечание. Вот поэтому
[38:32.520 --> 38:41.000]  и безопаснее писать str без амперсантов. Вот если бы мы не поле возвращали, а создавали бы какую-то строку str,
[38:41.000 --> 38:51.640]  местный str, который какой-то результатом обработки того str является, и его бы возвращали, то вот тогда это
[38:51.640 --> 39:03.880]  было бы проблемой. Ну то есть, вот я, допустим, написал std string new str равно std move от str, а потом еще написал
[39:03.880 --> 39:16.920]  вот так. Вот тогда это было бы UB, потому что, понятно почему, потому что это была бы сбитая ссылка. А при такой
[39:16.920 --> 39:22.920]  реализации не было бы. Ну то есть, я неправильно сказал вам, что там будет один лишний конструктор,
[39:22.920 --> 39:34.400]  забудьте. Но кажется, что без амперсантов писать просто безопаснее. Значит, вопрос. Если бы s был
[39:34.400 --> 39:42.200]  const, мой страх, мы бы получили ce или дополнительное копирование? Давайте и на этот вопрос ответим. Так,
[39:42.200 --> 39:55.160]  я верну, как было, значит, я верну без амперсантов. Так, хорошо. Если бы s был const,
[39:55.160 --> 40:09.120]  мой страх, если бы s был const, мой страх, то я думаю, что дополнительное копирование, ну,
[40:09.120 --> 40:18.480]  по тому же самому принципу, по которому и... Сейчас, нет, так не могу сходу ответить. Ну,
[40:18.480 --> 40:30.640]  давайте подумаем. std move дает нам rvalue. То есть, у нас есть, по сути, const, мой страх, двойной амперсант.
[40:30.640 --> 40:40.480]  И нужно либо выбрать версию, которая просто мой страх, двойной амперсант,
[40:40.480 --> 40:47.320]  либо версию, которая одинарный амперсант. Нет, это будет ce. Это должен быть ce,
[40:47.320 --> 41:02.880]  давайте проверим. Так, я не сохранил, кажется. Да, это ce. Смотрите, почему ce, потому что эту
[41:02.880 --> 41:08.440]  версию, ну, у нас теперь this имеет тип const, мой страх, двойной амперсант. Эту версию мы не можем
[41:08.440 --> 41:12.680]  выбрать, потому что const нарушается, а эту версию мы не можем выбрать, потому что rvalue нарушается.
[41:12.680 --> 41:21.240]  А если бы у нас не было первого... Почему? Потому что нельзя перегружать так, чтобы у одной не было,
[41:21.240 --> 41:27.440]  было ноль ссылок у второй две ссылки. Ну, так бы можно было выбрать первую. Ах, нет, нельзя.
[41:27.440 --> 41:34.840]  Нет, так бы можно было выбрать первую, но перегружать так нельзя. Нет, вот этот одиночный амперсант
[41:34.840 --> 41:42.280]  за что только lvalue сюда можно отдавать. Вот эта фраза Discalce Qualifiers, она теперь применима не
[41:42.280 --> 41:49.800]  только к константности, а еще и к амперсантности, так скажем. Вот, тут константность нарушается,
[41:49.800 --> 42:00.360]  а тут игнорируется квалификатор вот этот вот. Давайте пойдем дальше, потому что еще, на самом деле,
[42:00.360 --> 42:08.880]  достаточно много надо обсудить. Следующий пункт будет называться Проблема Perfect Formatting.
[42:08.880 --> 42:21.640]  Мы обсудили move и более-менее поняли, как работают рвелые ссылки. У нас осталась важная проблема.
[42:21.640 --> 42:48.880]  Следующая. Смотрите. Представьте, что у меня есть. Ну, давайте начнем вот с чего. Давайте даже
[42:48.880 --> 43:00.040]  не отсюда начнем, а опять вернемся в вектор. Вот в векторе такой метод есть emplaceback. Следующий
[43:00.040 --> 43:12.400]  пункт будет называться, это пункт 10.7, он будет называться Perfect Forwarding Problem.
[43:18.880 --> 43:31.000]  В векторе есть такой метод emplaceback. Что делает emplaceback? Он принимает аргументы конструктора t
[43:31.000 --> 43:47.800]  и избегает создания промежуточного t. Ну, например, если у меня есть, ну я не знаю, вот представьте,
[43:47.800 --> 44:08.040]  что у меня вектор векторов. Сейчас как бы мне это организовать. Давайте я применю. Вот представьте,
[44:08.040 --> 44:22.160]  что у меня есть вектор векторов. std vector от std vector v, ну там от int. И я хочу вектор векторов
[44:22.160 --> 44:40.280]  положить вектор, скажем, из 10 int. Я могу написать v.emplaceback 10. Что это будет означать? Понимаете,
[44:40.280 --> 44:46.960]  это я, значит, говорю, положи в вектор такой объект, который бы получился, если ты вызвал
[44:46.960 --> 44:52.880]  конструктор внутреннего типа с параметром 10. То есть после этого в моем векторе будет лежать
[44:52.880 --> 45:05.520]  один вектор с десятью нулями. Эта функция, она тоже, начиная с c++11 появилась, и появилась она для того,
[45:05.520 --> 45:11.440]  чтобы избегать создания промежуточного объекта, когда вы что-то в вектор кладёте. Ну не только в
[45:11.440 --> 45:18.640]  вектор, в любой контейнер. Она точно так же есть. В map можно написать map.emplace вместо insert.
[45:18.640 --> 45:24.840]  Значит, понятна разница? Вместо того, чтобы передавать объект типа t, я передаю параметры
[45:24.840 --> 45:39.600]  конструктора для объекта типа t. Я могу написать так v.emplaceback 10.1. Это будет означать, что у меня
[45:39.600 --> 45:45.560]  будет вектор, в нем первый вектор то 10 нулей, а второй вектор то 10 единиц. Вот эти параметры,
[45:45.560 --> 46:06.200]  они передаются в тот самый конструктор. Ну да. Вот. Значит, понятно разница между pushback и
[46:06.200 --> 46:14.560]  emplaceback. Вот. Ну и с помощью emplaceback можно было бы на самом деле избегать копирований как
[46:14.560 --> 46:40.240]  раз в той ситуации, с которой мы начинали. Вот. Когда я говорил там, что значит. Ну вот. Вот если бы я так
[46:40.240 --> 46:48.640]  написал и сделал pushback вместо emplaceback, то было бы лишнее копирования. Ну, в старом смысле лишний
[46:48.640 --> 46:54.240]  вызов конструктора t. Потому что pushback принимает t, ему нужно было бы сконструировать t вот от этого,
[46:54.240 --> 47:02.320]  а потом другое t от того t, который он сконструировал. Emplaceback позволяет избежать этой проблемы путем того,
[47:02.320 --> 47:09.160]  что в самом placeback вы принимаете лишь параметры конструктора для t, но не t готовы еще. И t
[47:09.160 --> 47:21.040]  конструируется один раз, а не два раза. Вот. Но возникает новая проблема. А проблема вот как.
[47:21.040 --> 47:35.840]  Вот я перейду сейчас сюда и задам вам вопрос. А как реализовать emplaceback? Emplaceback. Что должно
[47:35.840 --> 47:53.560]  быть типами принимаемых параметров? Какой-нибудь арк с двойным персантом. Вот. Я не могу написать так деле.
[47:53.560 --> 48:01.440]  Потому что. А вдруг они не константные там? Ну, точнее нет. Не в этом дело. Не потому, что вдруг они не
[48:01.440 --> 48:12.120]  константные там. Вдруг не передали rvalue? То есть я мог бы так написать. Я мог бы так написать. И я мог бы на самом деле
[48:12.120 --> 48:27.320]  вот здесь сказать, бла-бла-бла-бла-бла, new arccz t от arcs. Многоточие. И pushback на самом деле просто выражается
[48:27.320 --> 48:40.360]  через emplaceback в одну строчку. Это просто emplaceback от value. А это emplaceback это stmove от value.
[48:40.360 --> 48:49.920]  Но вот здесь, если я так напишу, у меня будет опять проблема с лишними копированиями. Откуда берется
[48:49.920 --> 48:56.720]  проблема с лишними копированиями? Потому что я все аргументы принял в константной ссылке. А вдруг они были rvalue?
[48:56.720 --> 49:13.640]  Некоторые из них, по крайней мере. То есть смотрите, у меня есть параметры, которые могут быть как lvalue,
[49:13.640 --> 49:25.920]  так и rvalue. И я хочу обработать их правильно в любом случае. В случае pushback у меня просто есть
[49:25.920 --> 49:32.480]  перегрузка. В одном случае я точно сдал объект как lvalue, и я его не буду мувать. В другом случае я не
[49:32.480 --> 49:46.520]  имею права мувать просто. Это не было бы CE, но не имею права. А здесь у меня много аргументов,
[49:46.520 --> 50:00.360]  и часть из них может быть lvalue, а часть rvalue. Я не могу написать просто перегрузку для const.arq с
[50:00.360 --> 50:04.120]  ampersand, а потом перегрузку для args с двойным ampersand в старом смысле. Потому что аргументов
[50:04.120 --> 50:11.880]  много. Если я напишу вот так, это будет неэффективно, потому что я все их скопирую. Но все мувнуть я тоже
[50:11.880 --> 50:23.480]  не могу. Что же делать? То есть если я вот так напишу и напишу здесь the move от args, то это вообще
[50:23.480 --> 50:29.760]  очень плохо, потому что я тем самым мувнул все аргументы, в том числе те, которые возможно мувнуть
[50:29.760 --> 50:36.840]  было нельзя. Что же делать? Это как раз называется проблема perfect forwarding, проблема идеальной
[50:36.840 --> 50:43.880]  передачи. Когда у меня есть много аргументов, да и даже не обязательно много аргументов, пусть даже это
[50:43.880 --> 50:49.520]  один аргумент, но он может быть как rvalue, так и lvalue. И мне надо передать его дальше в следующую
[50:49.520 --> 51:05.040]  функцию с сохранением вида value, с которой мне его дали изначально. Почему const.arq повлечет лишнее
[51:05.040 --> 51:28.080]  копирования? Потому что я вызываю конструктор T от параметров, каждый из которых const что-то там
[51:28.080 --> 51:39.360]  амперсант. А если бы у меня эти параметры были переданы мне как rvalue, то я мог бы вызвать move
[51:39.360 --> 51:51.160]  конструктор T. Ну банальный пример, если я сделал in place back от string, от другого вектора, я его здесь
[51:51.160 --> 51:57.280]  принял как const вектор амперсант и передал конструктор того нового вектора от const вектор
[51:57.280 --> 52:01.960]  амперсант и вызвал конструктор копирования, а мне его дали изначально через move. Я move его должен был,
[52:01.960 --> 52:14.520]  а не должен, а не стал. Я мог бы move, а не стал. Это лишнее копирования аргументов. Так, понятно ли
[52:14.520 --> 52:28.920]  проблема? Кто-нибудь скажите. Да, понятно. Верно, что к каст двойного амперсанта,
[52:28.920 --> 52:35.880]  если бы мы сняли in place back от args двойного амперсанта и дайща, то все бы спокойно попадало туда.
[52:35.880 --> 52:58.560]  Да, но из того, что я сказал до этого, это еще не следует. Это следующее, что я как раз
[52:58.560 --> 53:09.360]  собираюсь сказать. Так, окей, если никто больше ничего не говорит и не спрашивает,
[53:09.360 --> 53:12.560]  то я считаю, что проблема понятна. Сейчас я буду объяснить, как решать проблему.
[53:12.560 --> 53:24.080]  Что я должен принять в первую очередь? Вот мне надо, чтобы я мог принимать как R-value,
[53:24.080 --> 53:31.200]  так и L-value. Если я буду принимать con start с амперсант, то все, я уже ничего с
[53:31.200 --> 53:36.200]  этим не сделаю. Лишние копирования потом будут. А если я буду принимать вот так,
[53:36.200 --> 53:49.680]  то я как будто бы принимаю R-value ссылку и получается, что я могу как будто только R-value принимать.
[53:49.680 --> 54:00.840]  В общем, нет и ввели костыль. Сейчас будет очень странный костыль, который прям в
[54:00.840 --> 54:12.080]  стандарте зафиксирован, но не я это придумал. Возможно, если бы я это придумывал, скорее всего
[54:12.080 --> 54:16.160]  мы бы не придумали ничего лучше. В общем, комитет не придумал ничего лучше, как вести следующий
[54:16.160 --> 54:27.280]  ужасный костыль. Если у вас ARX это шаблонный аргумент функции, то ARX с двойным амперсантом
[54:27.280 --> 54:30.920]  имеет не тот же смысл, как если бы он не был шаблонным аргументом.
[54:30.920 --> 54:42.400]  Когда ARX любой шаблонный или когда он именно несколько содержит в себе?
[54:42.400 --> 54:48.960]  Когда он любой шаблонный аргумент. Вот если у меня ARX, который принимает им двойной амперсант X,
[54:48.960 --> 54:57.680]  то сюда можно передавать только R-value. Но если у меня функция с шаблонным параметром T,
[54:57.680 --> 55:06.160]  которая принимает вот такую вещь, то сюда можно передавать как L-value, так и R-value.
[55:06.160 --> 55:19.120]  Это костыль. Что будет? А что именно будет, вот раз можно принимать, что это значит?
[55:19.120 --> 55:25.720]  Пока я не сказал, что будет, сейчас вот такое правило. Если у вас это является шаблонным
[55:25.720 --> 55:30.760]  аргументом функции, то такую ссылку можно интеллизировать как посредством R-value,
[55:30.760 --> 55:41.240]  так и посредством R-value. Такие ссылки называются универсальные ссылки. По-русски они называются
[55:41.240 --> 55:48.080]  универсальные ссылки или еще они называются forwarding references. Надо понимать, что это не официальный
[55:48.080 --> 55:55.680]  термин стандарта. Это просто такой синтоксический, ну такой костыль. Но на жаргоне, можно так сказать,
[55:55.680 --> 56:02.880]  между собой это называется forwarding reference, универсальная ссылка. Вот это конкретно ссылка.
[56:02.880 --> 56:09.560]  Она не R-value ссылка, потому что ее не только посредством R-value можно интеллизировать,
[56:09.560 --> 56:15.760]  она просто с шаблонным параметром T. Вот из-за того, что тут шаблонный параметр T, ее можно
[56:15.760 --> 56:21.520]  интеллизировать как R-value, так и R-value, поэтому она универсальна. Вот эта вот ссылка.
[56:21.520 --> 56:37.120]  Теперь рецепт, как решить проблему. Я принимаю ARC с двойной амперсант. Это универсальная ссылка,
[56:37.120 --> 56:43.320]  и по вот этому костыльному правилу сюда можно передать как R-value, так и R-value. И вот здесь мне
[56:43.320 --> 56:49.320]  нужно что-то написать. Просто ARC передать я не могу, потому что это будет L-value, значит опять скопируется.
[56:49.320 --> 56:58.400]  SDMove от ARC передать я не могу, потому что я move-ну что-то лишнее. Это будет даже хуже,
[56:58.400 --> 57:03.720]  чем если бы я скопировал. Это я нарушу, я испорчу пользовательские объекты. Мне
[57:03.720 --> 57:08.080]  нужна другая специальная волшебная функция для такой ситуации, которая называется SDForward.
[57:08.080 --> 57:26.520]  Она вызывается шаблонным параметром T. Возможно, тут немножко усложняет дело наличие этого
[57:26.520 --> 57:37.880]  переменного количества аргументов. То есть я говорю бла-бла-бла, ну я что-то делаю в этой функции,
[57:37.880 --> 57:50.640]  а потом вызываю другую функцию, скажем, h от stdforward от t от x. Вот этот вот stdforward это такая
[57:50.640 --> 57:58.320]  волшебная функция, которая следующим хитрым образом работает. Она возвращает R-value,
[57:58.320 --> 58:04.320]  если изначально тот x я принял как R-value, и возвращает L-value в противном случае.
[58:04.320 --> 58:26.480]  Вот эта конструкция приводит к тому, что для тех и только тех ARCs, которые были даны мне как L-value,
[58:26.480 --> 58:34.880]  результат вызова SDForward даст L-value. Ну L-value ссылку, а поэтому L-value. А для тех ARCs,
[58:34.880 --> 58:40.600]  которые были изначально даны мне как R-value, результат вызова SDForward даст мне R-value ссылку,
[58:40.600 --> 58:46.800]  то есть R-value. И поэтому в конструктор T я отдам те и только те аргументы по R-value ссылки,
[58:46.800 --> 58:57.480]  которые мне изначально пришли в эту функцию как R-value. И на самом деле вот этот pushback я тоже
[58:57.480 --> 59:06.520]  могу выразить через emplaceback. И я могу сказать, вот здесь вот просто я делаю emplaceback stdmove от
[59:06.520 --> 59:15.560]  value. В этом случае emplaceback скопирует, а в этом случае emplaceback movenet, потому что SDForward умеет
[59:15.560 --> 59:27.160]  вот здесь как раз можно. Ну вот я избавился от copypasta заодно и разобрал emplaceback,
[59:27.160 --> 59:31.960]  еще так реализован emplaceback, но тут правда конечно Allocator, ну вы все понимаете.
[59:31.960 --> 59:42.920]  Вот теперь вам должно быть понятно, почему мы в Move принимали T2 и November Sound.
[59:42.920 --> 59:48.800]  Я напомню, как выглядит реализация stdmove.
[59:48.800 --> 01:00:10.120]  Как выглядит реализация stdmove? Мы принимали туда вот такой тип.
[01:00:10.120 --> 01:00:18.320]  Возвращали мы вот такой странный тип, а принимали мы T2&. Теперь вы понимаете,
[01:00:18.320 --> 01:00:24.520]  почему T2&&? Потому что в Move мы должны уметь принимать как R-value, так и L-value. И вот по
[01:00:24.520 --> 01:00:28.480]  этому костыльному правилу, которое введено специально, чтобы такую ситуацию победить,
[01:00:28.480 --> 01:00:37.040]  T, поскольку шаблонный параметр нашей функции, он является и любой вид value подойдет сюда.
[01:00:37.040 --> 01:00:47.400]  А еще теперь вы должны понять следующее, что вот например, давайте посмотрим сюда.
[01:00:47.400 --> 01:00:56.480]  Так, опять потерял.
[01:00:56.480 --> 01:01:03.840]  Ладно, давайте зайдем в вектор.
[01:01:03.840 --> 01:01:17.720]  Ну вот если мы посмотрим на Allocator.
[01:01:17.720 --> 01:01:23.400]  Господи, где Allocator стандартный?
[01:01:23.400 --> 01:01:33.440]  И посмотрим на функцию Construct в Allocator, то здесь, как вы видите, написано тоже
[01:01:33.440 --> 01:01:39.880]  ARC с двойным амперсаном. Я все это время опускал эту деталь и писал код Stark с амперсантом.
[01:01:39.880 --> 01:01:48.720]  Ну вот этот вот Placement new, который я вызываю с std forward, он на самом деле в Allocator спрятан.
[01:01:48.720 --> 01:01:54.400]  То есть на самом деле я же вызываю не Placement new явно из вектора, я вызываю Allocator trades
[01:01:54.400 --> 01:02:05.160]  Construct опять-таки от std forward от ARCs. И в Allocator уже вызывается Placement new и опять написано
[01:02:05.160 --> 01:02:13.640]  std forward там. То есть вот здесь вот должно быть написано new от вот этого вот std forward.
[01:02:13.640 --> 01:02:21.400]  Ровно по этой причине. Потому что Construct должен мовнуть те и только те
[01:02:21.400 --> 01:02:26.680]  аргументы, которые были приняты как R-value.
[01:02:26.680 --> 01:02:35.960]  Так, теперь вам должно быть понятно
[01:02:35.960 --> 01:02:47.240]  почему вот эти двойные... что такое универсальная ссылка? Как и когда использовать std forward?
[01:02:47.240 --> 01:02:53.440]  И почему в Allocator и в emplaceback именно такие ссылки и std forward написаны?
[01:02:53.440 --> 01:03:02.800]  И следующая вещь, которую надо понять, а как это работает? Опять мы поняли,
[01:03:02.840 --> 01:03:10.720]  мы закрыли Gestalt про то, почему было t2n% в муве, поняли что emplaceback,
[01:03:10.720 --> 01:03:16.640]  поняли почему двойные ссылки в Construct и поняли как пользоваться std forward,
[01:03:16.640 --> 01:03:22.560]  в каких ситуациях. Но мы теперь не понимаем, и это последнее что нам осталось понять,
[01:03:22.560 --> 01:03:27.440]  а как это работает? Вот когда мы это поймем, мы, можно сказать, до конца поймем,
[01:03:27.440 --> 01:03:31.840]  ну почти до конца поймем мув-семантику и останемся только про RVO и copy&paste поговорить.
[01:03:31.840 --> 01:03:53.280]  Плохо слышно очень, я не понимаю. Ты спросил про шаблонный аргумент что-то,
[01:03:53.280 --> 01:03:55.600]  только с шаблонным аргументом работает универсальная ссылка?
[01:03:55.600 --> 01:04:03.720]  Нет, я вообще нет. Повторить, что мы, по твоему, еще не знаем, что мы еще не придумали.
[01:04:03.720 --> 01:04:11.440]  А, мы не понимаем, да, как это работает, как std forward работает, как это цель достигается. Мы
[01:04:11.440 --> 01:04:17.880]  все поняли, кроме того, как вот эта часть работает. Как часть с t2n% работает мы уже
[01:04:17.880 --> 01:04:29.600]  понимаем, как часть с std forward работает. Вот, окей. А, ну еще мы не понимаем, что такое
[01:04:29.600 --> 01:04:35.640]  xvalue. Ну, в общем, еще пару вещей потом останется. Окей, мы поняли проблему,
[01:04:35.640 --> 01:04:48.200]  поняли решение, теперь как это работает. Значит, параграф 10.8 будет называться std forward
[01:04:48.200 --> 01:05:07.160]  implementation и, значит, свойства универсальных ссылок. Ну, я не буду писать это, давайте назовем
[01:05:07.160 --> 01:05:12.520]  просто std forward implementation. Прежде чем написать реализацию std forward, нам надо понять вообще,
[01:05:12.880 --> 01:05:22.920]  а как работает вот этот вот костыль с двойным персандом в параметрах. Вопрос, который у меня
[01:05:22.920 --> 01:05:30.600]  возникает следующий, ну и у вас он, наверное, должен возникать. А какой тип имеет выражение,
[01:05:30.600 --> 01:05:41.280]  вот здесь вот, x, когда мы его сюда передали. То есть, вот я сюда передал x по универсальной
[01:05:41.280 --> 01:05:52.200]  ссылке. Какой вот здесь вот будет тип x? Вот тип этого выражения, какой? Не with value,
[01:05:52.200 --> 01:06:03.280]  with value это lvalue, понятно. А тип какой? То есть, сколько реально персандов будет у x? x это будет
[01:06:03.280 --> 01:06:20.800]  lvalue. Это должно работать как-то так, чтобы когда мы передали lvalue, x оказался с двумя
[01:06:20.800 --> 01:06:27.280]  персандами тут. А когда мы передали lvalue, надо, чтобы какой-то магией x оказался одним
[01:06:27.280 --> 01:06:32.720]  персандом. Тогда std forward бы по этому принципу сумел различать, когда сделать move, когда не
[01:06:32.720 --> 01:06:42.880]  сделать move. Вот здесь вот std forward, он понимает в итоге вернуть rvalue или lvalue, как раз в
[01:06:42.880 --> 01:06:50.840]  зависимости от того, а сколько амперсандов было у x, который в него пришел. И нужно как-то так
[01:06:50.840 --> 01:06:56.840]  правило ввести приемы по универсальным ссылкам, чтобы когда мы передали lvalue, x получил в итоге
[01:06:56.840 --> 01:07:04.960]  1 амперсант. А когда мы передали rvalue, x получил бы в итоге 2 амперсанта. Можно вопрос? Да. Мы как-то,
[01:07:04.960 --> 01:07:09.160]  кажется, обсуждали, что если у нас t, ну если у нас был тип, у которого был 1 амперсант,
[01:07:09.160 --> 01:07:15.480]  если на него сверху навесим еще 2 амперсанта, то получится 1 амперсант все равно. Да. А нет такого,
[01:07:15.480 --> 01:07:20.520]  что тогда, когда мы, как раз универсальный ссылка, у нас по сути получаются разные t. То есть,
[01:07:20.520 --> 01:07:28.880]  если x, ну если мы вызвали lvalue, у нас t было бы тип с 1 амперсантом, а если rvalue, то без амперсантов,
[01:07:28.880 --> 01:07:44.400]  по сути. Гениально. Все так. Именно так это и работает. Давайте задумываемся о том, а что вообще такое
[01:07:44.400 --> 01:07:56.320]  t здесь? Когда мы вызываем какую-то шаблонную функцию с параметром t, во что превращается t? Вот в
[01:07:56.320 --> 01:08:07.720]  нормальной ситуации, если я вызываю какую-то функцию с шаблонным параметром t, ну без пока, вот пока мы
[01:08:07.720 --> 01:08:18.080]  не знаем ничего о двойных амперсантах. Вот, допустим, я вызову эту функцию от x, int x равно 1, f от x.
[01:08:18.080 --> 01:08:28.400]  Чему становится равен t? t становится равен int. И амперсант навешивается поверх t. Правильно так работает
[01:08:28.400 --> 01:08:34.560]  шаблонный вывод, вывод шаблонного параметра. t, он без амперсанта, оказывается. Другой вопрос,
[01:08:34.800 --> 01:08:51.480]  если я напишу int % r равно x, чему будет равно t? Вот смотрите, вот давайте такой эксперимент
[01:08:51.480 --> 01:09:04.080]  проведем. Вот если я сейчас вызову f от r, чему будет равно t? Ну давайте я просто проверю,
[01:09:04.080 --> 01:09:23.080]  вот я же могу написать std isSame v t, запятая int % Да, понятно, что я сделал. Давайте вектор,
[01:09:23.080 --> 01:09:29.360]  наверное, я закрою, мне это уже сейчас не пригодится. Так, я оставлю вот это. Вот смотрите,
[01:09:29.440 --> 01:09:40.360]  я взял x, взял lvalue ссылку на x и вызвался от нее. И спрашиваю t, чему равно? Это равно int %?
[01:09:42.360 --> 01:09:47.520]  Вообще t это lvalue reference, я могу спросить t это isLvalueReference.
[01:09:47.520 --> 01:10:06.560]  Что? Не понял, а где вывод? А, потому что я забыл type traits подключить, сейчас подключу.
[01:10:06.560 --> 01:10:33.680]  Type traits. Да что такое это? А, потому что c++17 не поставил. Ноль. t это не int % t это int.
[01:10:36.560 --> 01:10:47.400]  Вот смотрите, когда я передаю, когда я вызываю f от ссылки от int % type r это int % в шаблонном
[01:10:47.400 --> 01:10:54.960]  выводе t всроснуться int, а не int % И int значит сверху. То есть вот в этой функции t означает int,
[01:10:54.960 --> 01:11:06.080]  а не int %. То же самое, если бы здесь было const t % Ой, если я напису const t %
[01:11:06.080 --> 01:11:11.360]  t это было бы просто int, а const и int % повесились бы сверху на него.
[01:11:11.360 --> 01:11:27.720]  Но все меняется, когда здесь два анперсанда. И это как раз особенное правило для универсальных
[01:11:27.720 --> 01:11:37.880]  ссылок. И это тот самый костыль, благодаря которому работает sdfoward. Если я здесь вызываю,
[01:11:37.880 --> 01:11:45.960]  если я принимаю здесь t с двумя анперсантами, то есть если это универсальная ссылка, то внезапно
[01:11:45.960 --> 01:12:02.600]  оказывается, что t это ни с того ни с сего int % Смотрите еще раз, следите за руками. Сейчас
[01:12:02.600 --> 01:12:09.080]  может у кого-то крышу снести. Что я сделал? Я принял в f t двойной анперсант, где t шаблон
[01:12:09.080 --> 01:12:22.920]  f. Это универсальная ссылка. И я спросил, правда ли, что t равно, давайте, наверное, вот так вот
[01:12:22.920 --> 01:12:29.360]  сделаю. Вот я просто вот скажу, чему равно t? Это int, int с двумя анперсантами или int с одним
[01:12:29.360 --> 01:12:36.080]  анперсантами. И сейчас я внезапно обнаруживаю, что t это int с одним анперсантами.
[01:12:42.080 --> 01:12:46.800]  Ну нет, это даже выглядит визуально логично, как бы там два анперсанда мы передали с одним
[01:12:46.800 --> 01:12:53.240]  анперсанда, в одне один остался и все такое. Хорошо, что если я от x вызовусь, а не от r?
[01:12:53.240 --> 01:12:59.360]  Чему теперь будет равно t? Только не говорите, что int. Там всегда будет один анперсант, если мы
[01:12:59.360 --> 01:13:08.440]  вызвали с этого value. Правильно. И более анперсантов иначе. Да, все так. Значит, это правило работает
[01:13:08.440 --> 01:13:13.120]  независимо от типа того, от чего я вызвался, а в зависимости от вида value от того, от чего я вызвался.
[01:13:13.120 --> 01:13:18.360]  Правило вот этот костыль звучит следующим образом. Если функция приводит вниверсальную ссылку,
[01:13:18.360 --> 01:13:26.680]  то шаблонный вывод t работает не так, как обычно, а вот как. Если в вызове f в данной
[01:13:26.680 --> 01:13:33.080]  ситуации было lvalue выражение, то на t навешится анперсант лишний. А иначе ничего не навешивается.
[01:13:33.080 --> 01:13:41.160]  Поэтому если я вызовусь от x, то у меня все равно будет t равно int анперсант, несмотря на то,
[01:13:41.160 --> 01:13:50.240]  что x без анперсантов был вообще. А вот если я вызовусь от rvalue, ну, например, от одного,
[01:13:50.240 --> 01:14:06.360]  то t будет без анперсантов. Это будет просто int. И если я вызовусь от std move от x, теперь я вызываюсь
[01:14:06.360 --> 01:14:12.560]  от int с двумя анперсантами. Тип выражения std move от x это int 2 анперсанта. Но важен не
[01:14:12.560 --> 01:14:19.920]  тип, а вид value. Вид value это rvalue. А раз rvalue, то никаких анперсантов t не получает. Сейчас опять
[01:14:19.920 --> 01:14:34.840]  будет просто int. Вот такая вот странная шаблонная магия. А поэтому можно уже понять, как forward
[01:14:34.840 --> 01:14:44.440]  работает, исходя из этого правила. Как работает forward? В forward мы не случайно перейдем вот
[01:14:44.440 --> 01:14:51.600]  этот шаблонный параметр t. Он важен. Без него forward не скомпилируется. Нужно явно указать t.
[01:14:51.600 --> 01:14:59.560]  И вот этот t как раз и позволяет forward понять. Мы сейчас от lvalue или от rvalue. Потому что когда
[01:14:59.560 --> 01:15:04.800]  мы от rvalue были, вот это t будет без анперсантов. А когда от lvalue, оно будет с один анперсантом.
[01:15:04.800 --> 01:15:13.480]  Поэтому давайте просто сейчас напишу реализацию forward. template type name t. А давайте подумаем.
[01:15:13.480 --> 01:15:25.680]  Значит forward. А это просто forward. Такой слабенький forward. Это какой-то слабенький forward. В смысле слабенький
[01:15:25.680 --> 01:15:33.280]  forward можно вызывать от пакета самого. Нет, минуточку. forward вызывается от одного аргумента,
[01:15:33.280 --> 01:15:52.000]  а не от пакета. Многоточие оно ставится вот здесь, а не тут. Я рассказывал, что многоточие означает
[01:15:52.000 --> 01:15:56.840]  повторить все это через запятую. То выражение, после которого оно стоит. Поэтому на самом деле это
[01:15:56.840 --> 01:16:01.560]  выглядит как stforward от первого, а это stforward от второго, stforward от третьего. Все это через запятую.
[01:16:01.560 --> 01:16:06.800]  Для каждого из них по отдельности называется stforward. И они либо превращаются в rvalue ссылкой,
[01:16:06.800 --> 01:16:13.000]  либо в lvalue ссылкой, смотря какое t. Ну давайте подумаем. Какой должен быть возвращаемый тип,
[01:16:13.000 --> 01:16:18.440]  какой принимаемый тип. Не подглядывайте себе. Переференс. Давайте. Какой? Принимаемый,
[01:16:18.440 --> 01:16:25.400]  универсальная ссылка, понятное дело. Универсальная ссылка, говорите вы. Ну, допустим. А возвращаемый?
[01:16:29.760 --> 01:16:37.960]  Тоже универсальная ссылка? Нет, вы достойно. Даже хуже. А, стоп, можно удалить все ссылки,
[01:16:37.960 --> 01:16:48.480]  еще что-то навесить. Возвращаемым типом должен быть либо, значит, либо... Ремофф референс с 2 амперсантом,
[01:16:48.480 --> 01:16:54.280]  либо ремофф референс с 1 амперсантом. Что-то такое. Нам нужно как-то перегрузку сделать,
[01:16:54.280 --> 01:17:00.920]  в зависимости от t. Нам, видимо, нужно template type name t и template type name t амперсант. Это как
[01:17:00.920 --> 01:17:10.120]  такого штука, чтобы различать t у нас. Проблема вот в чем. Если вы будете принимать forward t с
[01:17:10.120 --> 01:17:15.160]  2 амперсантом, то опять будет правило с универсальными ссылками работать, и на это t навесится
[01:17:15.160 --> 01:17:27.760]  дополнительный амперсант. Вот вы же здесь от LVL вызываетесь, не так ли? И независимо от того,
[01:17:27.840 --> 01:17:37.120]  что там было до этого, вы здесь получите x с 1 амперсантом, и t будет с 1 амперсантом,
[01:17:37.120 --> 01:17:44.040]  если вы так напишете. Само t будет всегда с 1 амперсантом, если вы такое примете,
[01:17:44.040 --> 01:17:48.640]  по правилам универсальных ссылок. Поэтому нельзя forward принимать t с 2 амперсантом,
[01:17:48.640 --> 01:17:55.120]  это неправильно. Вы ничего не различите таким способом, потому что t всегда с 1 амперсантом будет
[01:17:55.120 --> 01:18:13.320]  в обоих случаях. Принимать надо t с 1 амперсантом. А если мы const передали или что-то такое? Нет,
[01:18:13.320 --> 01:18:24.240]  const сохраняется, с const ничего не будет. На самом деле, я немножечко обманул не совсем t с 1
[01:18:24.240 --> 01:18:31.320]  амперсантом, но так тоже будет работать. Это будет почти правильнее forward. Сейчас обсудим,
[01:18:31.320 --> 01:18:37.520]  почему не совсем еще правильнее. Значит, t с 1 амперсантом я принимаю forward, а вот возвращаю
[01:18:37.520 --> 01:18:46.160]  t с 2 амперсантом. И по сути я говорю return static cast к t с 2 амперсантом от x.
[01:18:54.240 --> 01:19:07.680]  Смотрите, что происходит. Если я вызывался вот здесь от lvalue, то есть вот этот вот,
[01:19:07.680 --> 01:19:13.560]  давайте я как-нибудь по-другому назову, вот я не знаю, давайте я назову это, может быть,
[01:19:13.560 --> 01:19:27.600]  t, нет, это будет y. Смотрите, если я вызывался от lvalue, то есть я получил x как lvalue, t здесь
[01:19:27.600 --> 01:19:37.840]  будет с одиночным амперсантом, типом x будет int амперсант, и t здесь будет int амперсант.
[01:19:37.840 --> 01:19:49.480]  Я приду сюда, t будет уже, т будет, поскольку я явно указал шаблонный аргумент, по-прежнему int
[01:19:49.480 --> 01:19:56.600]  амперсант, я же явно указал шаблонный аргумент, t будет int амперсант, int амперсант, еще раз
[01:19:56.600 --> 01:20:02.200]  амперсант, ну это все еще один амперсант, ссылка на ссылку, это по-прежнему обычная ссылка.
[01:20:02.200 --> 01:20:14.960]  И здесь произойдет так называемый референс коллапсинг. Что такое референс коллапсинг?
[01:20:14.960 --> 01:20:20.520]  Когда у меня есть int амперсант, и на него намешиваются еще два амперсанда, то считается,
[01:20:20.520 --> 01:20:27.720]  что это один амперсант. Вот это вот превратится для компиляторов int амперсант, а поверх него
[01:20:27.720 --> 01:20:33.480]  еще два амперсанда, но один амперсант побеждает, потому что если вы, ну как, у вас была lvalue
[01:20:33.480 --> 01:20:42.760]  lvalue и rvalue, логично, что нужно сохранить lvalue, ну как, вы типа были, у вас была обычная ссылка,
[01:20:42.760 --> 01:20:46.760]  но вы на нее навесили двойную ссылку, но это все еще должно остаться обычной ссылкой, это еще нельзя
[01:20:46.760 --> 01:20:54.840]  муготь как бы. Это называется референс коллапсинг. Давай я это запишу, референс коллапсинг rules.
[01:20:54.840 --> 01:21:06.180]  Значит, один амперсант плюс один амперсант, это один амперсант. Один амперсант плюс два амперсанда,
[01:21:06.180 --> 01:21:13.400]  это один амперсант. Два амперсанда плюс один амперсант, это один амперсант,
[01:21:13.400 --> 01:21:16.400]  и два амперсанда, на которые навешены два амперсанты, получается два амперсанда.
[01:21:16.400 --> 01:21:20.920]  Вот здесь вот сработает правило, что один амперсант, и 2 амперсанты – это один амперсант,
[01:21:20.920 --> 01:21:31.000]  амперсант. И вернется int одиночный амперсант, то есть l-value. Если же я принял x как r-value,
[01:21:31.000 --> 01:21:37.920]  t будет без амперсантов, здесь x имеет тип int двойной амперсант. Но это не важно,
[01:21:37.920 --> 01:21:44.920]  какой тип здесь имеет x, потому что проинциализирую я его все равно вот так,
[01:21:44.920 --> 01:21:50.200]  ну это будет здесь y будет все равно иметь тип int амперсант, потому что x это l-value,
[01:21:50.200 --> 01:21:58.120]  t будет без амперсантов, y будет иметь тип int амперсант, но статик k будет к двойному амперсанту,
[01:21:58.120 --> 01:22:12.200]  потому что t без амперсантов. И это будет аналог MOV по сути. Вот так работает forward.
[01:22:12.200 --> 01:22:30.200]  Кто понял? Отлично, теперь бы это еще все выучить. Тут я сказал, что немножечко вас обманул,
[01:22:30.200 --> 01:22:39.680]  обманул я вас вот в чем. Тут на самом деле не t, а std remove reference t под t и 1 амперсант
[01:22:39.680 --> 01:22:59.560]  поверх этого уже. У этого есть два объяснения. Первое объяснение такое, почему так лучше,
[01:22:59.560 --> 01:23:07.160]  а не так как было написано раньше. Потому что это вынуждает вас явно писать шарлонный
[01:23:07.160 --> 01:23:14.320]  аргумент при вызове forward. Если бы forward был реализован так, как до этого мы написали,
[01:23:14.320 --> 01:23:19.560]  то можно было бы вызывать forward без шарлонного аргумента, и он бы вызывался, это бы не было в CE.
[01:23:19.560 --> 01:23:29.600]  И при этом бы это неправильно работало. Потому что он бы не пробрасывал этот амперсант,
[01:23:29.600 --> 01:23:35.400]  когда надо. Потому что мы же по одиночной ссылке принимаем, на t амперсант не навешивается. Вы бы,
[01:23:35.400 --> 01:23:41.880]  забыв написать шарлонный аргумент явно, не получили бы CE, а получили бы не forward,
[01:23:41.880 --> 01:23:48.720]  а просто копирование. Ой, не копирование, а move они бы получили всегда. Forward бы работал
[01:23:48.720 --> 01:23:54.760]  как move, если бы вы забыли написать шарлонный аргумент. Вот при таком параметре компилятор
[01:23:54.760 --> 01:24:00.000]  не может сам вывести шарлонный аргумент, поэтому вам его приходится явно писать.
[01:24:00.000 --> 01:24:05.600]  А есть и вторая причина, есть еще вторая перегрузка у форварда на самом деле, вот такая.
[01:24:05.600 --> 01:24:18.200]  Есть и вот такая перегрузка у форварда. Мы не рассмотрели случай, когда forward приходит rvalue.
[01:24:18.200 --> 01:24:27.560]  Заметьте, что оба случая, которые мы рассмотрели, это было, когда мы forward перейдем lvalue. А бывает,
[01:24:27.560 --> 01:24:34.600]  что мы forward rvalue передаем? Такое вообще, это вообще осмысленно, но потому что в прошлой нашей
[01:24:34.600 --> 01:24:40.320]  реализации forward вообще не умел принимать rvalue. А осмысленно ли вообще хоть когда-то forward
[01:24:40.320 --> 01:24:47.320]  передавать rvalue? Если мы вызвали forward от rvalue, какое-то ситуация, было бы CE.
[01:24:47.320 --> 01:24:56.120]  А осмысленно ли forward передавать rvalue? Когда это может быть осмысленно?
[01:24:56.120 --> 01:25:04.600]  Когда? Понятно или непонятно, когда? Непонятно. Непонятно, когда.
[01:25:04.600 --> 01:25:14.920]  Если мы знаем rvalue, можно MOOC вызвать. Да, но мы можем не знать rvalue или это. Это может быть вот в какой ситуации.
[01:25:14.920 --> 01:25:21.720]  Допустим, мы вызываем forward не от просто x, а еще от какой-то другой функции, которая от x.
[01:25:27.720 --> 01:25:33.920]  И эта функция тоже может в свою очередь как lvalue, так и rvalue вернуть в зависимости от чего-нибудь там.
[01:25:33.920 --> 01:25:49.920]  Ну, например, это та самая функция, вот та, которая была, забери str, либо копию вернет, либо там,
[01:25:49.920 --> 01:26:05.920]  ну, что? Да, ну, наша f, вот которая там, которая ссылочным квалификатором, либо ссылку вернет, либо копию, либо rvalue копию.
[01:26:05.920 --> 01:26:14.920]  Вот, и тогда forward иногда может получиться, что мы от rvalue пытаемся вызвать. В такой ситуации мы в старой реализации бы не смогли просто,
[01:26:15.920 --> 01:26:31.920]  а теперь это не будет CE, просто мы попадем вот сюда. Ну, и все правильно сработает. Тут у меня произойдет, значит, что у меня произойдет?
[01:26:31.920 --> 01:26:43.920]  Ну, все нормально будет, так rvalue останется. То есть на самом деле вот так вот реализован forward, у него две версии. Вот с таким параметром и с таким параметром.
