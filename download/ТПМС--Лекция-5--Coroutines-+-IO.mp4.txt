[00:00.000 --> 00:09.000]  Ну что, мы продолжаем нашу историю про конкурентность,
[00:09.000 --> 00:11.600]  и давайте вспомним для начала, чем занимались в прошлый
[00:11.600 --> 00:12.600]  раз.
[00:12.600 --> 00:15.360]  Мы изучали устройство потоков, и я сказал, что для этого
[00:15.360 --> 00:18.840]  мы изучим однопоточные фиберы, кооперативные однопоточные
[00:18.840 --> 00:19.840]  фиберы.
[00:19.840 --> 00:23.040]  И вот из понимания этих фиберов мы выведем для себя
[00:23.040 --> 00:24.640]  понимание обычных поток.
[00:24.640 --> 00:28.400]  Но у нас, точнее, у меня перед вами остался некоторый
[00:28.400 --> 00:31.640]  долг, потому что, во-первых, я вас уверял, что если мы
[00:31.640 --> 00:33.240]  поймем фиберы, то мы поймем потоки.
[00:33.240 --> 00:36.280]  Хотя, конечно, фиберы отличались от потоков, они были кооперативные
[00:36.280 --> 00:37.280]  и непараллельные.
[00:37.280 --> 00:41.200]  Во-вторых, фиберы, которые мы в прошлый раз рассмотрели,
[00:41.200 --> 00:43.080]  они не делали ничего полезного, они только запускались
[00:43.080 --> 00:44.080]  и переключались.
[00:44.080 --> 00:47.760]  На семинаре я поговорил про синхронизацию немного,
[00:47.760 --> 00:50.400]  но по-прежнему эти фиберы не умеют общаться с внешним
[00:50.400 --> 00:54.020]  миром, поэтому они, кажется, непригодны для исходной
[00:54.020 --> 00:59.420]  задачи, которую они планировали решать, а именно построение
[00:59.420 --> 01:00.780]  масштабируемых сетевых сервисов.
[01:00.780 --> 01:06.500]  И я сегодня обещаю почти все эти проблемы исправить.
[01:06.500 --> 01:10.380]  То есть сегодня мы научим фиберы быть параллельными,
[01:10.380 --> 01:12.980]  одновременно запускаться на разных ядрах процессора,
[01:12.980 --> 01:18.820]  а во-вторых, мы научим фиберы ввода-вывода.
[01:18.820 --> 01:35.140]  Ну и давайте начнем с распараллеливания фиберов, а для этого я предлагаю
[01:35.140 --> 01:42.100]  вам вспомнить один момент с прошлой реакции, который
[01:42.100 --> 01:46.580]  может быть не слишком значительным, но мне кажется, что благодаря
[01:46.580 --> 01:48.300]  нему мы сегодня фиберы распараллелим.
[01:48.300 --> 01:56.540]  Помните, мы когда рассматривали пример, как фиберы работают,
[01:56.540 --> 01:59.180]  мы говорили, что в этом примере самое необычное.
[01:59.180 --> 02:01.460]  Это вот процедура yield, в которую мы заходим один
[02:01.460 --> 02:03.980]  раз, выходим дважды с одной стороны в другом фибере,
[02:03.980 --> 02:06.100]  а потом, в конце концов, возвращаемся обратно из
[02:06.100 --> 02:07.100]  нее.
[02:07.100 --> 02:09.100]  И вот там происходит некоторая магия, которую мы назвали
[02:09.100 --> 02:11.700]  переключение контекста, и мы это переключение контекста
[02:11.700 --> 02:12.700]  разбирали в прошлый раз.
[02:13.700 --> 02:19.020]  Это такой, давайте я его открою, такой девайс, который умел
[02:19.020 --> 02:24.260]  в себя сохранять состояние текущего исполнения с процессора
[02:24.260 --> 02:27.420]  и активировать на процессоре состояние другого ранее
[02:27.420 --> 02:30.300]  замороженного, ну или еще не стартовавшего ни разу
[02:30.300 --> 02:32.300]  исполнения.
[02:32.300 --> 02:34.900]  И обладая вот таким вот инструментом, который умел
[02:34.900 --> 02:40.300]  операцию switch2, то есть сохранить состояние исполнения в
[02:40.300 --> 02:42.980]  контексте слева switch2 и активировать состояние
[02:42.980 --> 02:46.660]  контекста справа switch2, мы могли бы реализовать вот
[02:46.660 --> 02:49.060]  наши кооперативные фиберы, потому что просто могли
[02:49.060 --> 02:52.220]  бы переключаться с одного фибер на другой.
[02:52.220 --> 02:54.540]  Но мы почему-то вот прямо так не сделали, то есть мы
[02:54.540 --> 02:57.580]  не стали переключить фибер прямо на другой фибер, хотя
[02:57.580 --> 02:59.500]  это в какой-то степени разумно.
[02:59.500 --> 03:05.140]  Вместо этого мы ввели некоторую косвенность и сказали, что
[03:05.140 --> 03:08.940]  между двумя фиберами всегда будет находиться планировщик.
[03:08.940 --> 03:12.500]  То есть когда мы переключаемся, мы всегда передаем управление
[03:12.500 --> 03:15.300]  не следующему фиберу, а планировщику.
[03:15.300 --> 03:23.140]  Возвращаемся в цикл планирования, и он уже выбирает из очереди
[03:23.140 --> 03:28.300]  следующий очередной фибер и запускает его, переключает
[03:28.300 --> 03:31.340]  свой контекст на контекст этого фибера.
[03:31.340 --> 03:33.260]  Этот фибер он либо еще не стартовал ни разу, либо
[03:33.260 --> 03:36.220]  он уже находится внутри вызова yield, и этот вызов yield продолжится
[03:36.300 --> 03:37.300]  после.
[03:37.300 --> 03:41.700]  Вот вопрос, а зачем нам нужна была такая косвенность?
[03:41.700 --> 03:44.020]  Ну, с одной стороны, она исправляла некоторые граничные
[03:44.020 --> 03:46.900]  случаи, потому что у нас в конце концов есть там
[03:46.900 --> 03:50.660]  фибер, у них есть свои стейки, а еще есть и основный поток,
[03:50.660 --> 03:53.860]  в котором исполнится функция main, в которой исполняется
[03:53.860 --> 03:58.140]  сам планировщик, ну и почему бы этот поток с его стеком
[03:58.140 --> 03:59.940]  не отдать на исполнение цикла планирования.
[03:59.940 --> 04:05.140]  Но мы увидим, что на самом деле так можно, так нужно
[04:05.140 --> 04:07.540]  сделать, так следует делать еще по одной причине.
[04:07.540 --> 04:11.620]  Но прежде чем я ее объясню, давайте я вам еще один пример
[04:11.620 --> 04:12.620]  приведу.
[04:12.620 --> 04:14.740]  Я, кажется, на семинарах, по крайней мере, рассказывал
[04:14.740 --> 04:19.300]  про xv6, про учебную операционную систему в MIT, и вот там тоже
[04:19.300 --> 04:23.100]  есть планировщик, разумеется, в этой операционной системе,
[04:23.100 --> 04:28.220]  там есть многозадачность, там есть физическая параллельность,
[04:28.220 --> 04:32.020]  и планировщик там тоже активный, то есть он переключает,
[04:32.020 --> 04:34.820]  в нем есть цикл планирования, и вот он ищет очередной
[04:34.820 --> 04:37.900]  процесс, который готов исполняться в состоянии runnable, и переключает
[04:37.900 --> 04:40.220]  контекст планировщика на контекст этого самого
[04:40.220 --> 04:41.220]  процесса.
[04:41.220 --> 04:43.860]  Да и даже процедура переключения контекста там похожая, если
[04:43.860 --> 04:49.420]  мы сейчас сможем ее быстро увидеть, то... секунду, сможем-сможем.
[04:49.420 --> 05:02.580]  То процедура переключения контекста нам даже устроена
[05:02.580 --> 05:05.060]  так же, как и наше переключение контекста.
[05:05.060 --> 05:09.180]  Мы пушим на стэк, замораживаем его, замораживаем его исполнение
[05:09.180 --> 05:11.780]  регистра, call you saved, потом переключаем стэки двумя
[05:11.780 --> 05:15.460]  мувами, потом мы зеркально снимаем со стэка то, что
[05:15.460 --> 05:17.660]  мы заморозили на нем.
[05:17.660 --> 05:21.740]  Ну и у нас вот точно такой же код, просто для другой
[05:21.740 --> 05:23.500]  архитектуры, поэтому немного отличается.
[05:23.500 --> 05:29.980]  Ну вот, мы почему-то пренебрегаем возможностью переключаться
[05:30.820 --> 05:34.020]  и добавляем вот эту косвенность в виде планировщика.
[05:34.020 --> 05:38.220]  Это, да, делает наш код симпатичнее, делает наш код понятнее,
[05:38.220 --> 05:39.980]  избавляет нас от некоторых граничных случаев, но все
[05:39.980 --> 05:45.220]  же вот благодаря именно вот такой передаче управления,
[05:45.220 --> 05:47.220]  благодаря тому, что там планировщик участвует, мы
[05:47.220 --> 05:51.740]  можем сегодня увидеть, как эти файберы вот этот планировщик
[05:51.740 --> 05:52.740]  сделать параллельно.
[05:52.740 --> 05:55.700]  Но кажется, что задача не очень простая, потому
[05:55.700 --> 05:58.060]  что вот мы смотрим на этот планировщик, и тут много
[05:58.060 --> 06:05.420]  всего написано, и там разные очереди, контексты, переключение,
[06:05.420 --> 06:06.420]  много сложной логики.
[06:06.420 --> 06:09.980]  Но если вот вы смотрите этот планировщик, то в нем
[06:09.980 --> 06:12.140]  есть две такие разные задачи.
[06:12.140 --> 06:15.780]  Ну, во-первых, тут есть код, который переключает контексты.
[06:15.780 --> 06:21.860]  Вот мы сохраняем контекст текущего исполнения в поле
[06:21.860 --> 06:25.100]  файбера и активируем контекст планировщика, когда возвращаемся
[06:25.100 --> 06:27.220]  в планировщик, ну и в обратную сторону, точно так же.
[06:27.220 --> 06:33.500]  Это вот одни функции, которые планировщик, одни задачи,
[06:33.500 --> 06:34.500]  которые планировщик решает.
[06:34.500 --> 06:37.500]  Переключение контекста из файбера в файбер.
[06:37.500 --> 06:41.300]  И вторая обязанность планировщика – это, собственно, планирование.
[06:41.300 --> 06:44.380]  То есть он выбирает, какой файбер будет исполняться
[06:44.380 --> 06:45.380]  дальше.
[06:45.380 --> 06:46.380]  Вот для этого у него есть ранг-ю.
[06:46.380 --> 06:50.900]  В планировщике вот мы видим одни поля про ранг-ю, другие
[06:50.900 --> 06:51.900]  при переключении контекста.
[06:51.900 --> 06:56.780]  И я не знаю, если у вас такое впечатление, но у меня оно
[06:56.780 --> 06:57.780]  точно есть.
[06:57.780 --> 06:59.620]  Мне кажется, что этот код, он очень монолитный.
[06:59.620 --> 07:02.780]  Тут много разных задач сплавлено в один класс.
[07:02.780 --> 07:07.700]  Тут и переключение контекста, и очереди, и планирование
[07:07.700 --> 07:10.460]  этих самых файберов на единственный поток операционной системы.
[07:10.460 --> 07:14.700]  И можно задуматься о том, а можно было бы этот код
[07:14.700 --> 07:15.700]  как-то декомпозировать.
[07:15.700 --> 07:21.740]  Вот что, если мы сможем как-то исключить из этого
[07:21.740 --> 07:24.740]  кода планировщика, который, казалось бы, про планирование,
[07:24.740 --> 07:26.060]  логику переключения контекста.
[07:26.060 --> 07:32.060]  И вот оказывается, что если мы так сделаем, мы сейчас
[07:32.060 --> 07:38.940]  этим займемся, то от планировщика останется только очередь,
[07:38.940 --> 07:41.580]  и эту очередь уже можно параллелить.
[07:41.580 --> 07:44.260]  Но вот мы этим недавно занимались, если вы помните.
[07:44.260 --> 07:45.260]  У нас был полпоток.
[07:45.260 --> 07:50.300]  Вот это наш план, такой короткий, пока очень туманный.
[07:50.300 --> 07:55.980]  И давайте я даже не буду вас спрашивать, какую бы
[07:55.980 --> 07:58.260]  абстракцию, какой бы механизм тут можно было выделить
[07:58.260 --> 08:00.940]  при переключении контекста, а просто расскажу вам.
[08:00.940 --> 08:04.980]  Этот механизм называется, если вы хорошо знаете программирование
[08:04.980 --> 08:09.100]  и наблюдаете его в течение последнего полувека, то
[08:09.100 --> 08:10.100]  наверное, вам механизм известен.
[08:10.100 --> 08:15.660]  Но, возможно, нам он неизвестен, поэтому скажем, что этот
[08:15.660 --> 08:21.900]  механизм – это корутина или сопрограмма.
[08:21.900 --> 08:26.620]  Я буду говорить, наверное, и так, и так.
[08:26.620 --> 08:29.380]  Обычно люди называют корутина.
[08:29.380 --> 08:31.460]  Корректнее говорить сопрограмму, я, наверное, буду путаться.
[08:31.460 --> 08:32.780]  Но попробую сопрограмму говорить сегодня.
[08:32.780 --> 08:38.420]  Итак, сопрограмма или короутинг, по аналогии с подпрограммами,
[08:38.420 --> 08:43.100]  это процедура, которая отличается от подпрограммы тем, что
[08:43.100 --> 08:47.420]  в нее можно зайти несколько раз в один вызов этой сопрограммы
[08:47.420 --> 08:49.700]  и несколько раз его покинуть.
[08:49.700 --> 08:52.540]  Для этого у сопрограммы есть операция, для того, чтобы
[08:52.540 --> 08:55.420]  остановиться внутри исполнения, внутри вызова, у сопрограммы
[08:55.420 --> 08:58.700]  есть операция suspend, а для того, чтобы потом возменить
[08:58.700 --> 09:00.700]  сопрограмму, есть операция resume.
[09:00.700 --> 09:03.860]  Ну, эта сопрограмма естественным образом расширяет понятие
[09:03.860 --> 09:09.020]  подпрограммы, subrouting, потому что у подпрограммы есть только
[09:09.020 --> 09:10.980]  одну точку входа, в один раз ее вызываете, в один раз
[09:10.980 --> 09:13.060]  она завершается, возвращает вам управление.
[09:13.060 --> 09:15.100]  Вот в сопрограмму, в вызов сопрограммы можно заходить
[09:15.100 --> 09:17.580]  несколько раз и несколько раз возвращаться из него
[09:17.580 --> 09:18.580]  обратно.
[09:18.580 --> 09:24.980]  И вот именно эта сущность в себе инкапсулирует логику
[09:24.980 --> 09:27.460]  переключения контекста, и мы ее из планировщика
[09:27.460 --> 09:28.460]  сможем изъять.
[09:28.460 --> 09:31.660]  Ну, вот давайте посмотрим, как сопрограмма себя ведет.
[09:31.660 --> 09:37.500]  У нас, вообще говоря, строго говоря, сопрограмма – это
[09:37.500 --> 09:39.820]  некоторая сущность на уровне языка программирования,
[09:39.820 --> 09:41.500]  то есть она как-то синтактически может быть представлена
[09:41.500 --> 09:42.500]  и должна быть.
[09:42.900 --> 09:48.380]  Вот наш класс coroutine, сопрограмма – это не прямо сопрограмма,
[09:48.380 --> 09:51.380]  это скорее вызов сопрограммы, если быть строго, вызов
[09:51.380 --> 09:54.100]  сопрограммы, который исполняет вот эту процедуру.
[09:54.100 --> 09:59.780]  И вот видите, здесь операция suspend остановится, и у сопрограммы
[09:59.780 --> 10:03.020]  есть операция resume возобновить исполнение.
[10:03.020 --> 10:08.060]  Здесь мы конструируем экземпляр класса coroutine вызов сопрограммы.
[10:08.060 --> 10:10.380]  И в этот момент пока ничего не происходит, мы просто
[10:10.380 --> 10:11.380]  ее создали.
[10:12.380 --> 10:16.660]  Дальше мы печатаем step1, и вот здесь вот уже мы первый
[10:16.660 --> 10:20.100]  раз стартуем сопрограмму.
[10:20.100 --> 10:25.620]  Мы начинаем ее вызов, говорим resume, и в этот момент управление
[10:25.620 --> 10:30.260]  передается из этого вызова вот сюда.
[10:30.260 --> 10:34.660]  Печатается step2, после чего сопрограмма встречает
[10:34.660 --> 10:40.300]  операцию suspend для остановки и возвращает управление
[10:40.300 --> 10:42.820]  к тому коду, который вызвал сопрограмму.
[10:42.820 --> 10:47.180]  То есть мы заходим suspend и выходим из этого resume, возвращаемся
[10:47.180 --> 10:48.180]  из него.
[10:48.180 --> 10:50.380]  Но опять, нелокальная передача управления, оно окажется
[10:50.380 --> 10:53.900]  после файберов, это не должно уже нас так удивлять.
[10:53.900 --> 10:59.020]  Мы печатаем step3, после этого говорим resume, и возвращаемся
[10:59.020 --> 11:02.540]  в вызов сопрограммы, выходим из этого suspenda, печатаем
[11:02.540 --> 11:05.500]  четвертый шаг, и после этого вызов сопрограмма завершается.
[11:05.500 --> 11:09.980]  Но вот это был один вызов, и мы в него зашли дважды.
[11:09.980 --> 11:13.300]  Вот первый резюм, вот второй резюм.
[11:13.300 --> 11:17.540]  Первый раз мы начали исполнение со старта процедуры, второй
[11:17.540 --> 11:21.180]  раз мы вышли из этого suspenda.
[11:21.180 --> 11:24.260]  Ну давайте, чтобы убедиться, что все работает так, как
[11:24.260 --> 11:29.740]  должно, запустим и посмотрим, да.
[11:29.740 --> 11:35.260]  Вот все произошло предсказуемо.
[11:35.260 --> 11:37.060]  Пока ничего удивительного, да?
[11:37.620 --> 11:41.820]  Все как обычно, хорошо.
[11:41.820 --> 11:45.540]  Дальше можно заметить, что у сопрограммы, видимо,
[11:45.540 --> 11:48.780]  вероятно, есть свой собственный stack.
[11:48.780 --> 11:52.020]  Вот наши сопрограммы, которые мы здесь рассматриваем,
[11:52.020 --> 11:55.940]  они носят название stackful сопрограммы, видимо, потому
[11:55.940 --> 11:59.580]  что у них есть stack, потому что в самом деле мы создали
[11:59.580 --> 12:02.780]  сопрограмму, которая будет исполнять функцию foo, и в
[12:02.780 --> 12:05.620]  функции foo мы вызвали функцию bar, в функции bar мы вызвали
[12:05.620 --> 12:10.740]  функцию bus, в функции bus мы собираемся остановиться.
[12:10.740 --> 12:16.140]  И если мы запустимся и вот встанем на этом брейкпойнте,
[12:16.140 --> 12:20.780]  то мы увидим, что мы находимся на стэке foo bar bus.
[12:20.780 --> 12:31.860]  И когда мы наступаем вот на этот suspend, то мы фактически
[12:31.860 --> 12:35.180]  останавливаем весь этот stack вызовов, то есть внутри
[12:35.180 --> 12:39.540]  сопрограммы он был, и вот мы из этого stack выпрыгнули.
[12:39.540 --> 12:49.100]  Все три вызова в сопрограмме заморозились как будто бы.
[12:49.100 --> 12:51.980]  Есть и другие сопрограммы, они называются stackless
[12:51.980 --> 12:52.980]  сопрограммы.
[12:52.980 --> 12:56.900]  Ну, тут можно подумать, что у одних stack есть, а другим
[12:56.900 --> 12:59.220]  stack как будто бы не нужен, но это, разумеется, не так,
[12:59.220 --> 13:01.380]  потому что любому коду, чтобы исполняться, нужен
[13:01.380 --> 13:04.820]  call stack, чтобы просто двигаться по вызовам функций.
[13:04.820 --> 13:12.140]  Так что разница немного… конечно, речь про stack, но
[13:12.140 --> 13:14.940]  разница немного тоньше, и придет время, мы об этом
[13:14.940 --> 13:15.940]  поговорим.
[13:15.940 --> 13:18.100]  Вот пока сегодня мы говорим про сопрограммы, которые
[13:18.100 --> 13:22.100]  реализуются прямо нами на уровне библиотеки, и мы
[13:22.100 --> 13:28.540]  называем такие сопрограммы stackless сопрограммами.
[13:28.540 --> 13:32.460]  Как видно, сопрограммы напоминают файберы, ну, потому что
[13:32.460 --> 13:39.460]  эти и другие умеют запускаться и останавливаться, и в тех
[13:39.460 --> 13:42.820]  и других есть нелокальная передача управления, и
[13:42.820 --> 13:44.700]  она реализуется с помощью механизма переключения
[13:44.700 --> 13:45.700]  контекста.
[13:45.700 --> 13:54.180]  Но все же разница между файберами и коррутинами
[13:54.180 --> 13:55.180]  есть.
[13:55.180 --> 13:56.420]  Давайте посмотрим такой пример.
[13:57.420 --> 14:04.300]  Вот, собственно, где коррутины и файберы будут связываться.
[14:04.300 --> 14:08.100]  Здесь мы запускали коррутину из… коррутина, начинаю
[14:08.100 --> 14:11.980]  говорить, сопрограмму из вот этой функции, вот
[14:11.980 --> 14:13.340]  дважды ее возобновляли.
[14:13.340 --> 14:15.700]  У нас была одна сопрограмма, а в этом примере все немного
[14:15.700 --> 14:18.380]  интереснее, потому что у нас здесь сопрограммы две,
[14:18.380 --> 14:20.260]  каждый из них делает по два шага, каждый из них делает
[14:20.260 --> 14:24.860]  suspend между двумя этими шагами, и мы чередуем исполнение
[14:24.860 --> 14:25.860]  этих сопрограмм.
[14:26.060 --> 14:28.420]  То есть мы делаем первый шаг – первый, первый шаг
[14:28.420 --> 14:32.100]  – второй, потом снова первый шаг – первый, потом снова
[14:32.100 --> 14:38.020]  первый шаг – второй, и печатаем что-нибудь, что-нибудь такое.
[14:38.020 --> 14:39.180]  Один, два, один, два.
[14:39.180 --> 14:45.300]  Вот видите, это же вот в чистом виде конкуренция.
[14:45.300 --> 14:50.540]  У нас есть две сопрограммы, мы чередуем их исполнение.
[14:50.540 --> 14:54.300]  Вот чередование – это же вот как будто бы про файберы,
[14:54.300 --> 14:57.220]  но нет, файберов пока никаких нет, это именно сопрограммы,
[14:57.220 --> 15:00.660]  и я бы сказал так, что вот конкуренция – это единица
[15:00.660 --> 15:03.020]  конкуренции вообще на свете, это сопрограмма, вот она
[15:03.020 --> 15:05.180]  в чистом виде эту идею выражает.
[15:05.180 --> 15:08.380]  Я на первой лекции говорил вам, что конкуренция и параллелизм
[15:08.380 --> 15:11.020]  – это вот вообще перпендикулярные вещи, может быть одно без
[15:11.020 --> 15:12.020]  другого.
[15:12.020 --> 15:14.620]  Вот в прошлый раз у нас были однопоточные файберы,
[15:14.620 --> 15:17.100]  в которых никакого параллелизма не было, но там еще были
[15:17.100 --> 15:19.420]  планировщики, очереди, вот какая-то дополнительная
[15:19.420 --> 15:20.420]  механика.
[15:20.420 --> 15:24.100]  Здесь сопрограмма – вот это вот чистое представление
[15:24.100 --> 15:25.100]  конкарнации.
[15:25.100 --> 15:28.340]  Но все же, вот файберы и сопрограммы – это разные
[15:28.340 --> 15:29.340]  вещи.
[15:29.340 --> 15:30.980]  Да, они похожи, да, они локальная передача управления, механизм
[15:30.980 --> 15:34.140]  приключения контекста, свои стейки, чередование
[15:34.140 --> 15:37.740]  на процессоре, но в чем же разница?
[15:37.740 --> 15:41.900]  Вот когда мы говорим про файберы, то мы имеем в виду
[15:41.900 --> 15:45.100]  как правило кооперативную многозадачность.
[15:45.100 --> 15:47.860]  У нас есть какие-то независимые исполнения, там обработчики
[15:47.860 --> 15:49.740]  запросов пользователей.
[15:49.740 --> 15:53.460]  Они чередуются на процессоре, потому что разных пользователей
[15:53.460 --> 15:56.620]  нужно обслуживать одновременно.
[15:56.620 --> 15:59.700]  Эти обработчики, эти активности могут друг с другом синхронизироваться,
[15:59.700 --> 16:02.140]  то есть файберам, наверное, нужны приметилы синхронизации
[16:02.140 --> 16:06.220]  – мьютексы, кондвары, каналы и так далее.
[16:06.220 --> 16:08.460]  Файберам, безусловно, нужен планировщик, который будет
[16:08.460 --> 16:09.460]  их запускать.
[16:09.460 --> 16:12.260]  Он будет решать в каком порядке, какие файберы будут запускаться
[16:12.260 --> 16:13.260]  вообще.
[16:13.260 --> 16:17.100]  Ну и файберы могут быть однопоточными, как в прошлый
[16:17.100 --> 16:19.700]  раз, и могут быть и многопоточными, то есть они могут одновременно
[16:19.700 --> 16:21.220]  исполняться на разных ядрах.
[16:21.220 --> 16:23.140]  Тут никаких, вроде бы, ограничений в этом нет.
[16:23.140 --> 16:29.140]  Крутины, сопрограммы гораздо проще устроены.
[16:29.140 --> 16:34.340]  Вот они гораздо ближе просто к обычным функциям.
[16:34.340 --> 16:37.340]  Они не связаны с потоками совсем.
[16:37.340 --> 16:40.540]  Тут про параллелизм никакой речи не идет.
[16:40.540 --> 16:42.180]  Сопрограмма – это как будто бы вызов функции.
[16:42.180 --> 16:47.540]  И он ведет себя как вызов функции еще и потому, что,
[16:47.540 --> 16:49.460]  скажем, с исключениями работает также.
[16:49.540 --> 16:53.100]  То есть если мы вот запустили сопрограмму, и в ней было
[16:53.100 --> 16:55.100]  брошено исключение, которое не было в этой сопрограмме
[16:55.100 --> 16:57.100]  обработано, то это исключение вылетит на руль через вызов
[16:57.100 --> 17:01.260]  резюм, и коллер его должен обработать.
[17:01.260 --> 17:06.340]  Ну и собственно, роли такие же, как в вызовах функций,
[17:06.340 --> 17:07.340]  вызовах процедур.
[17:07.340 --> 17:13.100]  Есть коллер, который вызывает сопрограмму, и есть колли
[17:13.100 --> 17:14.100]  – это сама сопрограмма.
[17:14.100 --> 17:18.420]  Ну вот такие же роли, как в обычном структурном
[17:18.420 --> 17:19.420]  программировании.
[17:19.420 --> 17:24.020]  Параллельности нет, никакой конкуренции прямой здесь
[17:24.020 --> 17:28.180]  в понятии сопрограммы нет, примитива в синхронизации
[17:28.180 --> 17:29.180]  для сопрограммы не нужна.
[17:29.180 --> 17:34.780]  Это скорее более базовый инструмент, более примитивный,
[17:34.780 --> 17:37.180]  в смысле более универсальный поэтому.
[17:37.180 --> 17:40.340]  Вот видимо, сопрограммы будут участвовать в построении
[17:40.340 --> 17:43.340]  файберов многопоточных, ну или однопоточных, даже
[17:43.340 --> 17:44.340]  не очень важно.
[17:44.340 --> 17:48.300]  Но применение сопрограмм файберами не исчерпывается,
[17:48.300 --> 17:52.140]  поэтому я вот хочу показать вам, как сопрограммы могут
[17:52.140 --> 17:55.060]  быть полезны сами по себе.
[17:55.060 --> 17:57.780]  Более того, они были придуманы как раз, ну, они были придуманы
[17:57.780 --> 18:00.060]  даже не для многопоточности, не для конкуренции, а для
[18:00.060 --> 18:01.060]  других задач.
[18:01.060 --> 18:06.100]  Но перед этим маленькое замечание.
[18:06.100 --> 18:09.100]  Чем сопрограммы отличаются, скажем, ну как можно разделить
[18:09.100 --> 18:12.820]  в своем уме понятие сопрограмма и понятие переключения контекста,
[18:12.820 --> 18:15.060]  execution контекста, который у нас был.
[18:15.060 --> 18:18.220]  Вроде бы и то, и другое чем-то похоже, то есть мы нелокально
[18:18.220 --> 18:21.100]  придаем управление, тоже какие-то классы, вот как
[18:21.100 --> 18:25.420]  можно различать корутину и переключение контекста.
[18:25.420 --> 18:32.060]  Ну, я бы сказал так, что сопрограмма – это сущность, которая,
[18:32.060 --> 18:34.740]  как правило, имеет некоторое представление на уровне
[18:34.740 --> 18:35.740]  языка программирования.
[18:35.740 --> 18:37.900]  Вот эта сущность в языке программирования.
[18:37.900 --> 18:41.180]  У нее есть просто лексическое представление какое-то.
[18:41.180 --> 18:46.380]  Вот вы в языке можете сопрограмму описать.
[18:46.460 --> 18:48.700]  Контекст исполнения – он гораздо ниже находится
[18:48.700 --> 18:50.700]  на уровнях абстракции.
[18:50.700 --> 18:53.700]  Он про процессор, он про регистры.
[18:53.700 --> 18:57.380]  Вот на уровне языка программирования у такого execution контекста
[18:57.380 --> 19:00.940]  никакого представления нет, конечно.
[19:00.940 --> 19:04.740]  Ну вот, я вас убеждаю, что сопрограмма – это сущность
[19:04.740 --> 19:07.380]  самостоятельная, у нее есть свой собственный независимый
[19:07.380 --> 19:11.220]  смысл и можно применять ее без относительно конкуренции.
[19:11.220 --> 19:13.180]  Ну и давайте я расскажу вам пример, который мне кажется
[19:13.180 --> 19:14.180]  очень красивым.
[19:15.180 --> 19:19.180]  Он связан с итерацией.
[19:21.180 --> 19:25.180]  Вот представим себе, что мы пишем итератор.
[19:25.180 --> 19:28.180]  Мы пишем итератор, скажем, по контейнеру эстедалист,
[19:28.180 --> 19:31.180]  который устроен, видимо, как двусвязанный список.
[19:31.180 --> 19:34.180]  Вот как будет выглядеть состояние итератора?
[19:34.180 --> 19:36.180]  Итератор – это объект, у которого есть метод плюс-плюс
[19:36.180 --> 19:38.180]  или move to next или что-нибудь подобное.
[19:38.180 --> 19:40.180]  То есть сделать шаг вперед, сдвинуться к следующему
[19:40.180 --> 19:43.180]  элементу контейнера.
[19:43.180 --> 19:45.180]  Вот как мы опишем состояние итератора?
[19:45.180 --> 19:47.180]  Какие у него будут поля просто?
[19:50.180 --> 19:51.180]  Ты что-то сложное говоришь.
[19:51.180 --> 19:53.180]  Я думаю, что состояние итератора – это указательный
[19:53.180 --> 19:55.180]  текущий узел двусвязанного списка.
[19:55.180 --> 19:58.180]  Этого тебе хватит, чтобы двигаться вперед-назад.
[19:58.180 --> 20:00.180]  Вот, то есть один pointer просто.
[20:00.180 --> 20:02.180]  На каком узле списка мы сейчас стоим?
[20:02.180 --> 20:04.180]  Ну, конечно, итератор знает про внутреннее устройство,
[20:04.180 --> 20:07.180]  но обычное дело.
[20:07.180 --> 20:10.180]  А теперь представим себе, что у нас не односвязанный
[20:10.180 --> 20:12.180]  список, а бинарное дерево.
[20:12.180 --> 20:14.180]  Ну, откуда оно взялось – совершенно неважно.
[20:14.180 --> 20:16.180]  А важно, что мы просто можем его построить.
[20:18.180 --> 20:19.180]  Вот мы строим бинарное дерево.
[20:19.180 --> 20:22.180]  У него есть внутренние узлы, есть листья.
[20:22.180 --> 20:25.180]  И мы хотим построить итератор.
[20:28.180 --> 20:31.180]  Мы хотим написать вот такой вот код.
[20:33.180 --> 20:34.180]  Мы уже его написали, мы хотим итератор написать,
[20:34.180 --> 20:36.180]  который бы работал.
[20:36.180 --> 20:38.180]  То есть мы хотим итерироваться по дереву
[20:38.180 --> 20:42.180]  и вот в цикле выводить данные очередного узла.
[20:44.180 --> 20:46.180]  Вот давайте подумаем, как выглядит состояние
[20:46.180 --> 20:48.180]  такого итератора.
[20:48.180 --> 20:52.180]  Указатель?
[20:58.180 --> 21:00.180]  Какая-то магия.
[21:00.180 --> 21:02.180]  Я, наверное, не понял от тебя.
[21:02.180 --> 21:04.180]  Во-первых, одного pointer будет мало.
[21:04.180 --> 21:07.180]  У нас здесь дерево без polyparent.
[21:09.180 --> 21:10.180]  Да.
[21:10.180 --> 21:14.180]  Ну, вообще, как написать состояние,
[21:14.180 --> 21:17.180]  как представить себе в уме такой вот итератор,
[21:17.180 --> 21:18.180]  который ходит по дереву.
[21:18.180 --> 21:21.180]  Его состояние – это узел в этом дереве,
[21:21.180 --> 21:23.180]  где он сейчас стоит.
[21:23.180 --> 21:26.180]  Ну, путь в дереве, грубо говоря.
[21:26.180 --> 21:29.180]  А еще нам важно помнить, как мы в этот узел попали.
[21:29.180 --> 21:32.180]  То есть мы пришли оттуда сверху, спустились.
[21:32.180 --> 21:34.180]  Мы вернулись из левого по дереву.
[21:34.180 --> 21:35.180]  Мы вернулись из правого по дереву.
[21:35.180 --> 21:37.180]  Потому что без этого мы не знаем, куда идти дальше.
[21:38.180 --> 21:39.180]  Вот.
[21:39.180 --> 21:42.180]  Ну, короче говоря, у нас есть путь и плюс вот
[21:42.180 --> 21:45.180]  три варианта, откуда мы пришли.
[21:46.180 --> 21:48.180]  А теперь представьте, что вы пишете вот такой вот
[21:48.180 --> 21:52.180]  итератор, который двигается так по дереву.
[21:52.180 --> 21:56.180]  Я думаю, что это сложно было бы написать, да?
[21:56.180 --> 21:59.180]  Ну, по крайней мере, не так приятно, как со списком.
[21:59.180 --> 22:02.180]  Пришлось бы какие-то случаи обрабатывать как-то вот…
[22:02.180 --> 22:04.180]  Ну, вместо этого можно поступить проще.
[22:04.180 --> 22:07.180]  Вместо этого можно представить себе…
[22:07.180 --> 22:09.180]  То есть если бы вас заставили такое писать,
[22:09.180 --> 22:11.180]  вы бы не стали так делать.
[22:11.180 --> 22:13.180]  Вы бы сказали, что давайте я лучше напишу рекурсивный
[22:13.180 --> 22:15.180]  обход дерева.
[22:15.180 --> 22:18.180]  Ну, потому что итератор для дерева делать неудобно.
[22:18.180 --> 22:20.180]  Лучше я напишу вот такую рекурсивную процедуру
[22:20.180 --> 22:23.180]  Три Волк, которая ходит по дереву в инордере.
[22:23.180 --> 22:26.180]  Идет влево сначала, потом вправо.
[22:26.180 --> 22:28.180]  И когда она приходит в узел,
[22:28.180 --> 22:30.180]  то просто вызывает какой-то колбэк.
[22:30.180 --> 22:33.180]  Делает обратный вызов, вызывает пользовательский
[22:33.180 --> 22:35.180]  обработчик, и вот этот обработчик обрабатывает
[22:35.180 --> 22:37.180]  очередной узел.
[22:37.180 --> 22:40.180]  Если мы хотим вывести все узлы дерева в инордер-обходе,
[22:40.180 --> 22:43.180]  то мы строим вот такой колбэк,
[22:43.180 --> 22:46.180]  передаем его в рекурсивную процедуру,
[22:46.180 --> 22:50.180]  и она уже реализуется совершенно тривиально.
[22:50.180 --> 22:53.180]  Ну, то есть удобный способ написать итерацию по дереву –
[22:53.180 --> 22:55.180]  это вот такая рекурсивная процедура.
[22:55.180 --> 22:57.180]  Кажется, мы в этом не сомневаемся.
[23:06.180 --> 23:10.180]  Мы сейчас говорим не про то,
[23:10.180 --> 23:12.180]  как написать самый эффективный код,
[23:12.180 --> 23:15.180]  а про то, как написать самый понятный код.
[23:15.180 --> 23:18.180]  И, как правило, люди ставят приоритеты так.
[23:18.180 --> 23:20.180]  Они сначала пишут хороший код,
[23:20.180 --> 23:23.180]  а потом в рамках текущих абстракций
[23:23.180 --> 23:25.180]  пытаются его оптимизировать.
[23:25.180 --> 23:27.180]  Если абстракции хороши, то это получается сделать.
[23:27.180 --> 23:29.180]  Вопрос, на самом деле, разумный,
[23:29.180 --> 23:31.180]  т.е. стек всегда может переполниться,
[23:31.180 --> 23:35.180]  но, в общем, мне кажется,
[23:35.180 --> 23:39.180]  что гораздо проще решить эту проблему
[23:39.180 --> 23:41.180]  в нашем случае, чем решать проблему
[23:41.180 --> 23:43.180]  с нерекурсированным обходом дерева.
[23:43.180 --> 23:45.180]  Но вопрос разумный, да.
[23:45.180 --> 23:47.180]  Я сейчас скорее говорю не про то,
[23:47.180 --> 23:49.180]  как делать это супероптимально,
[23:49.180 --> 23:51.180]  а про то, как…
[23:51.180 --> 23:53.180]  про инструменты выразительности,
[23:53.180 --> 23:55.180]  про то, как писать код.
[23:55.180 --> 23:57.180]  Вот так писать код гораздо проще для итерации по дереву.
[23:57.180 --> 24:00.180]  Использовать обратные вызовы, использовать колбэки.
[24:00.180 --> 24:02.180]  А теперь подумаем.
[24:02.180 --> 24:04.180]  Вот мы вызываем колбэк.
[24:04.180 --> 24:06.180]  Здесь вот, да?
[24:06.180 --> 24:08.180]  Вот как описать состояние
[24:08.180 --> 24:10.180]  нашей процедуры обхода рекурсивной?
[24:17.180 --> 24:19.180]  Вот мы находимся здесь.
[24:19.180 --> 24:21.180]  Вот здесь это что значит?
[24:21.180 --> 24:23.180]  Ну, мы находимся где-то в рекурсии.
[24:23.180 --> 24:25.180]  Мы находимся в каком-то узле,
[24:25.180 --> 24:28.180]  и мы к нему пришли через цепочку рекурсивных вызовов.
[24:28.180 --> 24:30.180]  И вот эта цепочка рекурсивных вызовов,
[24:30.180 --> 24:32.180]  вот call stack,
[24:32.180 --> 24:34.180]  это же буквально путь в дереве.
[24:35.180 --> 24:37.180]  Вот каждый стековый фрейм, каждый вызов,
[24:37.180 --> 24:39.180]  это обработка какого-то узла.
[24:41.180 --> 24:44.180]  А еще, мы же в этом рекурсивном вызове
[24:44.180 --> 24:46.180]  могли…
[24:46.180 --> 24:48.180]  Ну, где мы можем находиться? Мы можем находиться вот здесь сейчас.
[24:48.180 --> 24:50.180]  Мы можем выходить отсюда, можем заходить сюда,
[24:50.180 --> 24:52.180]  можем заходить сюда, возвращаться отсюда.
[24:52.180 --> 24:54.180]  Ну, короче говоря, у нас есть еще…
[24:55.180 --> 24:57.180]  Помимо… Если мы хотим описать
[24:57.180 --> 24:59.180]  мгновенное состояние этой процедуры обхода,
[24:59.180 --> 25:01.180]  то мы говорим, что у нас есть call stack, во-первых,
[25:01.180 --> 25:03.180]  а во-вторых, есть instruction pointer,
[25:03.180 --> 25:05.180]  где мы сейчас стоим.
[25:05.180 --> 25:07.180]  В каком месте этой процедуры?
[25:08.180 --> 25:10.180]  И вот смотрите,
[25:10.180 --> 25:12.180]  представьте себе обычный итератор
[25:12.180 --> 25:14.180]  нерекурсивный. У него есть состояние,
[25:14.180 --> 25:16.180]  вот там, stack, путь в дереве,
[25:16.180 --> 25:18.180]  плюс состояние, откуда мы пришли,
[25:18.180 --> 25:20.180]  слева, справа, там, сверху,
[25:20.180 --> 25:22.180]  слева, справа.
[25:22.180 --> 25:24.180]  Есть декурсивная процедура,
[25:24.180 --> 25:26.180]  и ее состояние,
[25:26.180 --> 25:28.180]  это call stack,
[25:28.180 --> 25:30.180]  тоже, по сути, путь в дереве,
[25:30.180 --> 25:32.180]  и instruction pointer, которые, по сути,
[25:32.180 --> 25:34.180]  то же самое. Откуда мы пришли?
[25:34.180 --> 25:36.180]  Сверху, вернулись слева,
[25:36.180 --> 25:38.180]  вернулись справа.
[25:40.180 --> 25:42.180]  Вот кажется, что очень похожие вещи.
[25:44.180 --> 25:46.180]  А теперь внимание, что такое
[25:46.180 --> 25:48.180]  сапрограмма? Это вызов,
[25:48.180 --> 25:50.180]  из которого можно выпрыгнуть, который может
[25:50.180 --> 25:52.180]  завершиться, ну не завершиться, а приостановиться.
[25:54.180 --> 25:56.180]  И у сапрограмма появляется состояние,
[25:56.180 --> 25:58.180]  у остановленной сапрограммы появляется состояние,
[25:58.180 --> 26:00.180]  в каком стеке она сейчас
[26:00.180 --> 26:02.180]  находится, в какой цепочке вызовов
[26:02.180 --> 26:04.180]  она остановилась,
[26:04.180 --> 26:06.180]  и где у нее стоит instruction pointer.
[26:08.180 --> 26:10.180]  И вот понимая это, что вот, по сути,
[26:10.180 --> 26:12.180]  сапрограмма сохраняет состояние,
[26:12.180 --> 26:14.180]  которое нужно было бы итератору нашему,
[26:14.180 --> 26:16.180]  можно написать
[26:16.180 --> 26:18.180]  гораздо проще код, если у нас
[26:18.180 --> 26:20.180]  вот есть такой волшебный инструмент.
[26:20.180 --> 26:22.180]  Смотрите,
[26:22.180 --> 26:24.180]  мы строим итератор, он получает
[26:24.180 --> 26:26.180]  корень дерева и
[26:26.180 --> 26:28.180]  конструирует сапрограмму.
[26:30.180 --> 26:32.180]  Что она делает?
[26:32.180 --> 26:34.180]  Она вызывает
[26:34.180 --> 26:36.180]  рекурсивную процедуру treewalk.
[26:36.180 --> 26:38.180]  И в этой рекурсивной процедуре мы идем
[26:38.180 --> 26:40.180]  влево, идем вправо,
[26:40.180 --> 26:42.180]  а между этими шагами мы
[26:42.180 --> 26:44.180]  запоминаем, на каком узле
[26:44.180 --> 26:46.180]  мы сейчас стояли, запоминаем данные из этого
[26:46.180 --> 26:48.180]  узла чуть точнее.
[26:50.180 --> 26:52.180]  После этого
[26:52.180 --> 26:54.180]  говорим suspend,
[26:54.180 --> 26:56.180]  приостанавливаем сапрограмму, мы выпрыгиваем
[26:56.180 --> 26:58.180]  из этого рекурсивного вызова.
[26:58.180 --> 27:00.180]  То есть мы фиксируем текущий
[27:00.180 --> 27:02.180]  путь в дереве, мы при suspendi,
[27:02.180 --> 27:04.180]  переключая контекст, фиксируем
[27:04.180 --> 27:06.180]  в том числе instruction pointer,
[27:06.180 --> 27:08.180]  как мы делали на прошлой лекции,
[27:08.180 --> 27:10.180]  и выпрыгиваем
[27:12.180 --> 27:14.180]  вот сюда.
[27:14.180 --> 27:16.180]  Ну, точнее, выпрыгиваем из этого вызова
[27:16.180 --> 27:18.180]  resume в moveToNext. Вот moveToNext
[27:18.180 --> 27:20.180]  это значит возобновить исполнение
[27:20.180 --> 27:22.180]  сапрограммы. Она
[27:22.180 --> 27:24.180]  возобновляется, встречает очередной
[27:24.180 --> 27:26.180]  suspend, и вызов
[27:26.180 --> 27:28.180]  moveToNext завершается.
[27:28.180 --> 27:30.180]  После этого мы можем вызывать метод
[27:30.180 --> 27:32.180]  data, потому что мы знаем,
[27:32.180 --> 27:34.180]  что перед suspend
[27:34.180 --> 27:36.180]  корутина сапрограмма
[27:36.180 --> 27:38.180]  запомнила в итераторе
[27:40.180 --> 27:42.180]  фактически указательные текущие данные.
[27:44.180 --> 27:46.180]  И вот мы с помощью
[27:46.180 --> 27:48.180]  сапрограммы просто выпрямили рекурсию,
[27:48.180 --> 27:50.180]  выпрямили ее в итерацию.
[27:54.180 --> 27:56.180]  Вот это, мне кажется, ну, я не знаю,
[27:56.180 --> 27:58.180]  как на ваш вкус, на мой вкус это
[27:58.180 --> 28:00.180]  безумно красиво.
[28:00.180 --> 28:02.180]  И вот мы фактически
[28:02.180 --> 28:04.180]  взяли переключение контекста, мы
[28:04.180 --> 28:06.180]  взяли рекурсивную процедуру, проанализировали,
[28:06.180 --> 28:08.180]  что stack и instruction pointer – это
[28:08.180 --> 28:10.180]  буквально состояние нерекурсивного обхода
[28:10.180 --> 28:12.180]  дерева, и
[28:12.180 --> 28:14.180]  сапрограмма здесь
[28:14.180 --> 28:16.180]  такой клей, который склеил
[28:16.180 --> 28:18.180]  наш линейный обход
[28:18.180 --> 28:20.180]  и вот рекурсивные вызовы.
[28:20.180 --> 28:22.180]  Скрыл для нас вот эту рекурсию.
[28:24.180 --> 28:26.180]  Без сапрограммы мы такой код написать
[28:26.180 --> 28:28.180]  бы не смогли. Ну, то есть мы бы смогли
[28:28.180 --> 28:30.180]  написать код нерекурсивного обхода,
[28:30.180 --> 28:32.180]  но он был бы очень сложный, очень непонятный,
[28:32.180 --> 28:34.180]  его бы никто не прочитал. Этот
[28:34.180 --> 28:36.180]  код читается очень просто, потому что, ну, вот он
[28:36.180 --> 28:38.180]  тривиальный. Идем левое по дереву, идем вправое по дереву.
[28:42.180 --> 28:44.180]  Можно эту идею
[28:44.180 --> 28:46.180]  развивать и дальше.
[28:46.180 --> 28:48.180]  Можно...
[28:50.180 --> 28:52.180]  Ну, во-первых, все понятно пока.
[28:52.180 --> 28:54.180]  Нужно ли что-то пояснять?
[28:54.180 --> 28:56.180]  Вопрос? Нет?
[28:58.180 --> 29:00.180]  Тогда следующий пример. Он уже
[29:00.180 --> 29:02.180]  немного хитрее.
[29:02.180 --> 29:04.180]  Точнее, я расскажу идею, этот самый пример
[29:04.180 --> 29:06.180]  слишком сложный, чтобы целиком описывать.
[29:08.180 --> 29:10.180]  Вот мы воспользовались
[29:10.180 --> 29:12.180]  сапрограммой для того, чтобы
[29:12.180 --> 29:14.180]  скрыть, ну, вот выпрямить рекурсию
[29:14.180 --> 29:16.180]  для пользователя.
[29:16.180 --> 29:18.180]  Написать итератор по рекурсивной структуре данных.
[29:18.180 --> 29:20.180]  Но рекурсия, она же в программировании
[29:20.180 --> 29:22.180]  встречается не только в виде
[29:22.180 --> 29:24.180]  структур данных, она встречается
[29:24.180 --> 29:26.180]  еще где?
[29:30.180 --> 29:32.180]  Но где вы с рекурсией встречаетесь
[29:32.180 --> 29:34.180]  в программировании?
[29:34.180 --> 29:36.180]  В программировании.
[29:44.180 --> 29:46.180]  Ну, ладно.
[29:46.180 --> 29:48.180]  Если вы изучаете языки
[29:48.180 --> 29:50.180]  программирования, давайте я так скажу,
[29:50.180 --> 29:52.180]  то рекурсию вы встречаете в двух местах.
[29:52.180 --> 29:54.180]  Во-первых, в виде
[29:54.180 --> 29:56.180]  структур данных, во-вторых, в виде синтоксических
[29:56.180 --> 29:58.180]  деревьев.
[29:58.180 --> 30:00.180]  Вот синтоксические структуры в языке
[30:00.180 --> 30:02.180]  это деревья, как правило.
[30:02.180 --> 30:04.180]  По ним тоже нужно ходить.
[30:04.180 --> 30:06.180]  Вот когда вы что-то парсите, вы
[30:06.180 --> 30:08.180]  строите дерево.
[30:08.180 --> 30:10.180]  Вы пишете какой-то рекурсивный парсер, который там
[30:10.180 --> 30:12.180]  спускается там влево, вправо, в эфирических выражениях.
[30:12.180 --> 30:14.180]  И вот дерево образуется.
[30:14.180 --> 30:16.180]  А теперь представим
[30:16.180 --> 30:18.180]  себе такую задачу. Ну, она выглядит довольно абстрактной,
[30:18.180 --> 30:20.180]  в смысле довольно далеко от вас,
[30:20.180 --> 30:22.180]  но тем не менее она возникает. А представьте,
[30:22.180 --> 30:24.180]  что вы пишете какую-нибудь
[30:24.180 --> 30:26.180]  сложную, распределённую систему,
[30:26.180 --> 30:28.180]  которая вычисляет что-то,
[30:28.180 --> 30:30.180]  делает какие-то вычисления, и вы
[30:30.180 --> 30:32.180]  парсите поток данных из сети, и парсите
[30:32.180 --> 30:34.180]  в нём, скажем, джейсоны. Ну, не важно что-то.
[30:34.180 --> 30:36.180]  И вот
[30:36.180 --> 30:38.180]  у вас есть процедура рекурсивного парсинга
[30:38.180 --> 30:40.180]  вот такого-то джейсона. Ну, не знаю, дерево вы
[30:40.180 --> 30:42.180]  строите, в конце концов.
[30:42.180 --> 30:44.180]  Вам удобно писать в виде рекурсии.
[30:44.180 --> 30:46.180]  Но при этом
[30:46.180 --> 30:48.180]  вы парсите не статическую строчку,
[30:48.180 --> 30:50.180]  которая у вас уже есть, а вы парсите
[30:50.180 --> 30:52.180]  поток, который вы читаете из сети.
[30:52.180 --> 30:54.180]  А его прямо сейчас нет, он
[30:54.180 --> 30:56.180]  кусочком к вам приходит.
[30:56.180 --> 30:58.180]  Вы читаете соки, то получаете очередной чанк.
[30:58.180 --> 31:00.180]  И
[31:00.180 --> 31:02.180]  вы не можете прямо в рекурсивной
[31:02.180 --> 31:04.180]  процедуре запускать какое-нибудь блокирующее
[31:04.180 --> 31:06.180]  чтение, которое даст вам очередной чанк,
[31:06.180 --> 31:08.180]  потому что вы блокируете поток целое.
[31:08.180 --> 31:10.180]  Мы этого не хотим делать. Это как бы вторая наша
[31:10.180 --> 31:12.180]  половина истории сегодня.
[31:12.180 --> 31:14.180]  Так вот, вам хочется как-то отделить
[31:14.180 --> 31:16.180]  собственно парсинг рекурсивный
[31:16.180 --> 31:18.180]  и вычитывание данных из сети,
[31:18.180 --> 31:20.180]  сделать его синхронным.
[31:20.180 --> 31:22.180]  И
[31:22.180 --> 31:24.180]  сопрограмма – это способ
[31:24.180 --> 31:26.180]  как одно отделить от другого, потому что
[31:26.180 --> 31:28.180]  это тот же самый рекурсивный обход дерева,
[31:28.180 --> 31:30.180]  который
[31:30.180 --> 31:32.180]  можно выпрямить
[31:32.180 --> 31:34.180]  и вот между...
[31:34.180 --> 31:36.180]  и запускать вот этот самый
[31:36.180 --> 31:38.180]  move to next только после того,
[31:38.180 --> 31:40.180]  как у вас появится очередная порция данных.
[31:40.180 --> 31:42.180]  Вы загрузите очередной
[31:42.180 --> 31:44.180]  чанк из сети, возобновите
[31:44.180 --> 31:46.180]  сопрограмму, которая парсит там очередной
[31:46.180 --> 31:48.180]  JSON, она где-то в середине остановится,
[31:48.180 --> 31:50.180]  потому что данных не хватает, и вы вернетесь
[31:50.180 --> 31:52.180]  к себе и вот дальше
[31:52.180 --> 31:54.180]  запланируете очередное синхронное
[31:54.180 --> 31:56.180]  чтение. Но это может быть сложный пример, сложно
[31:56.180 --> 31:58.180]  представить себя, но
[32:00.180 --> 32:02.180]  давайте я покажу немного
[32:02.180 --> 32:04.180]  более простой пример.
[32:04.180 --> 32:06.180]  Вот с помощью сопрограммы можно
[32:06.180 --> 32:08.180]  строить не только итераторы, можно строить
[32:08.180 --> 32:10.180]  ну, генераторы можно строить,
[32:10.180 --> 32:12.180]  здесь называется процессор.
[32:12.180 --> 32:14.180]  Процессор – это такой объект,
[32:14.180 --> 32:16.180]  который представляет собой исполнение,
[32:16.180 --> 32:18.180]  у которого есть минут ресив.
[32:18.180 --> 32:20.180]  Вот вы можете
[32:20.180 --> 32:22.180]  что-то получать снаружи.
[32:22.180 --> 32:24.180]  То есть, когда вы вызываете ресив
[32:24.180 --> 32:26.180]  и ожидаете строчку,
[32:26.180 --> 32:28.180]  то вызов этого процессора
[32:28.180 --> 32:30.180]  останавливается до тех пор, пока строчку вам снаружи
[32:30.180 --> 32:32.180]  не передадут. Не передадут ее
[32:32.180 --> 32:34.180]  с помощью метода send.
[32:36.180 --> 32:38.180]  Вот здесь вот,
[32:38.180 --> 32:40.180]  смотрите, у нас такая цепочка.
[32:40.180 --> 32:42.180]  Я строю ридер, который
[32:42.180 --> 32:44.180]  получает откуда-то чанки.
[32:44.180 --> 32:46.180]  Вот кусочки байт,
[32:46.180 --> 32:48.180]  ну, какие-то порции байт.
[32:48.180 --> 32:50.180]  Этот ридер берет и эти
[32:50.180 --> 32:52.180]  чанки разбивает на символы
[32:52.180 --> 32:54.180]  и кормит этими символами
[32:54.180 --> 32:56.180]  токенайзер.
[32:56.180 --> 32:58.180]  Токенайзер что делает? Он
[32:58.180 --> 33:00.180]  пожирает эти символы по одному
[33:00.180 --> 33:02.180]  и бьет
[33:02.180 --> 33:04.180]  поток этих символов на слова.
[33:04.180 --> 33:06.180]  И кормит
[33:06.180 --> 33:08.180]  ими принтер. Принтер их печатает.
[33:10.180 --> 33:12.180]  Вот представьте себе, что было бы,
[33:12.180 --> 33:14.180]  если бы вы писали это
[33:14.180 --> 33:16.180]  на процедурах
[33:16.180 --> 33:18.180]  обычных, на вызовах.
[33:18.180 --> 33:20.180]  Вот вам неудобно было бы писать
[33:20.180 --> 33:22.180]  этот токенайзер процедурой, потому что у него есть
[33:22.180 --> 33:24.180]  состояние. У него есть текущее накопленное
[33:24.180 --> 33:26.180]  слово.
[33:26.180 --> 33:28.180]  Если бы вы писали с помощью
[33:28.180 --> 33:30.180]  обычного программирования, обычных там вызовов
[33:30.180 --> 33:32.180]  функций, то вам бы пришлось
[33:32.180 --> 33:34.180]  склеивать цикл
[33:34.180 --> 33:36.180]  чтения
[33:36.180 --> 33:38.180]  данных и
[33:38.180 --> 33:40.180]  вот этот перемен и состояние токен
[33:40.180 --> 33:42.180]  текущий. У вас они были бы
[33:42.180 --> 33:44.180]  в одной функции. Это как бы
[33:44.180 --> 33:46.180]  нарушение просто границ слоев.
[33:46.180 --> 33:48.180]  Здесь
[33:48.180 --> 33:50.180]  код, который получает данные
[33:50.180 --> 33:52.180]  откуда-то, неважно,
[33:52.180 --> 33:54.180]  ничего не знает про это политокен.
[33:54.180 --> 33:56.180]  Про эту локальную переменную.
[33:56.180 --> 33:58.180]  Она целиком спрятана вот в этом процессоре.
[34:00.180 --> 34:02.180]  И вот токенайзер, он только про
[34:02.180 --> 34:04.180]  собственно токенизацию, про взбиение
[34:04.180 --> 34:06.180]  на слова. Он не знает
[34:06.180 --> 34:08.180]  ничего, откуда данные берутся и
[34:08.180 --> 34:10.180]  кто их дальше будет обрабатывать.
[34:10.180 --> 34:12.180]  Ему безразлично.
[34:12.180 --> 34:14.180]  Вот без сопрограмм
[34:14.180 --> 34:16.180]  код с такой вот
[34:16.180 --> 34:18.180]  изоляцией написать трудно.
[34:20.180 --> 34:22.180]  И смотрите, что интересно.
[34:22.180 --> 34:24.180]  Сопрограммы
[34:24.180 --> 34:26.180]  это понятие, оно довольно
[34:26.180 --> 34:28.180]  базовое, точнее оно супербазовое.
[34:28.180 --> 34:30.180]  Это вот такое естественное
[34:30.180 --> 34:32.180]  расширение понятия под программой.
[34:32.180 --> 34:34.180]  И придумали его очень давно.
[34:34.180 --> 34:36.180]  Вот придумали его
[34:36.180 --> 34:38.180]  сейчас я найду
[34:38.180 --> 34:40.180]  буквально
[34:40.180 --> 34:42.180]  60 лет назад.
[34:42.180 --> 34:44.180]  В 1963 году.
[34:44.180 --> 34:46.180]  Это довольно удивительно,
[34:46.180 --> 34:48.180]  потому что в C++ сопрограммы появились
[34:48.180 --> 34:50.180]  только в C++20, то есть спустя
[34:50.180 --> 34:52.180]  ну вот сколько времени.
[34:52.180 --> 34:54.180]  Это, конечно, интересный вопрос, почему
[34:54.180 --> 34:56.180]  так долго потребовалось? Почему так много времени
[34:56.180 --> 34:58.180]  потребовалось? Потому что
[34:58.180 --> 35:00.180]  сопрограммы появились, но перед тем, как они
[35:00.180 --> 35:02.180]  появились, люди долго думали, о каком виде они
[35:02.180 --> 35:04.180]  должны появиться. Были разные варианты, и вот
[35:04.180 --> 35:06.180]  все могло сложиться по-другому.
[35:06.180 --> 35:08.180]  Короче, вопрос сложный.
[35:08.180 --> 35:10.180]  Да, и в C++
[35:10.180 --> 35:12.180]  сопрограммы добавили именно
[35:12.180 --> 35:14.180]  для того, чтобы делать асинхронность.
[35:14.180 --> 35:16.180]  Чтобы запускать конкурентные
[35:16.180 --> 35:18.180]  исполнения, которые бы там работали
[35:18.180 --> 35:20.180]  с водом-выводом. Короче говоря,
[35:20.180 --> 35:22.180]  делать, ну это не то, что файбер,
[35:22.180 --> 35:24.180]  но вот конкурентность делать.
[35:24.180 --> 35:26.180]  Но если мы вернемся в прошлое,
[35:26.180 --> 35:28.180]  посмотрим на историю, то
[35:28.180 --> 35:30.180]  сопрограммы появились как раз,
[35:30.180 --> 35:32.180]  когда сопрограммы появились
[35:32.180 --> 35:34.180]  в 1963 году, никакой конкуренции, конечно,
[35:34.180 --> 35:36.180]  не было, и
[35:36.180 --> 35:38.180]  они были задуманы для того, чтобы люди
[35:38.180 --> 35:40.180]  писали компиляторы.
[35:40.180 --> 35:42.180]  Вот буквально, была задача
[35:42.180 --> 35:44.180]  декомпозировать разные
[35:44.180 --> 35:46.180]  стадии компиляции.
[35:48.180 --> 35:50.180]  И сопрограммы
[35:50.180 --> 35:52.180]  это вот тот механизм, который изолирует одну
[35:52.180 --> 35:54.180]  стадию от другой. Вот я пытался это вам
[35:54.180 --> 35:56.180]  передать вот этим примером.
[35:58.180 --> 36:00.180]  Короче говоря,
[36:00.180 --> 36:02.180]  сопрограммы отличаются
[36:02.180 --> 36:04.180]  от файберов, это более базовый
[36:04.180 --> 36:06.180]  механизм, он скорее проузов функции,
[36:06.180 --> 36:08.180]  и он позволяет вот эти функции декомпозировать
[36:08.180 --> 36:10.180]  друг от друга, и вот выстраивать между ними
[36:10.180 --> 36:12.180]  такой конвейер, pipeline.
[36:12.180 --> 36:14.180]  Вот можно представить себе, что это такие шестеренки,
[36:14.180 --> 36:16.180]  которые двигаются, ну, у них разное количество
[36:16.180 --> 36:18.180]  зубьев, у них как бы разный масштаб,
[36:18.180 --> 36:20.180]  тут строчки, тут символы, и вот они цепляются
[36:20.180 --> 36:22.180]  друг за друга, и вот вместе работают.
[36:22.180 --> 36:24.180]  Но
[36:24.180 --> 36:26.180]  для нас, конечно же, корутины
[36:26.180 --> 36:28.180]  интересны, потому что мы собираемся
[36:28.180 --> 36:30.180]  из них строить файберы,
[36:30.180 --> 36:32.180]  делать многопоточность. Вот для нас
[36:32.180 --> 36:34.180]  сегодня сопрограммы – это
[36:34.180 --> 36:36.180]  дорога к такому параллельному
[36:36.180 --> 36:38.180]  многопоточному ГО.
[36:38.180 --> 36:40.180]  Да.
[36:48.180 --> 36:50.180]  Ну, в этом примере, может быть, можно было бы,
[36:50.180 --> 36:52.180]  но
[36:56.180 --> 36:58.180]  как тебе сказать, ты чертовски
[36:58.180 --> 37:00.180]  прав.
[37:00.180 --> 37:02.180]  Но пока я не могу тебе объяснить, насколько
[37:02.180 --> 37:04.180]  ты прав.
[37:04.180 --> 37:06.180]  Ну,
[37:06.180 --> 37:08.180]  да, ну, скажем,
[37:08.180 --> 37:10.180]  класс с методами, вот здесь ты мог бы
[37:10.180 --> 37:12.180]  еще написать, но если бы у тебя
[37:12.180 --> 37:14.180]  процедура, тут, смотрите, тут есть токеназер,
[37:14.180 --> 37:16.180]  а после токеназера обычно парсер идет,
[37:16.180 --> 37:18.180]  а парсер декурсивный, и вот
[37:18.180 --> 37:20.180]  все, класс бы ты там уже не написал.
[37:20.180 --> 37:22.180]  Во-первых, да?
[37:22.180 --> 37:24.180]  Да, точно бы не написал.
[37:24.180 --> 37:26.180]  А во-вторых,
[37:26.180 --> 37:28.180]  во-вторых, ты прав. Иногда все-таки
[37:28.180 --> 37:30.180]  можно написать класс, но мы к этому вернемся
[37:30.180 --> 37:32.180]  через полтора месяца.
[37:32.180 --> 37:34.180]  И я отвечу на твой вопрос, так ты.
[37:34.180 --> 37:36.180]  Ну вот, мы
[37:36.180 --> 37:38.180]  хотим, значит, пока с такими примерами
[37:38.180 --> 37:40.180]  покончить на сегодня
[37:40.180 --> 37:42.180]  и поговорить про параллелизм.
[37:42.180 --> 37:44.180]  Вот для нас
[37:44.180 --> 37:46.180]  сопрограмма – это дорога к параллельным
[37:46.180 --> 37:48.180]  файберам.
[37:48.180 --> 37:50.180]  Вот мы хотели бы с помощью этого
[37:50.180 --> 37:52.180]  с помощью этих сопрограмм
[37:52.180 --> 37:54.180]  взять наш планировщик
[37:54.180 --> 37:56.180]  однопоточный для файберов.
[37:56.180 --> 37:58.180]  И вот эти переключения контекста
[37:58.180 --> 38:00.180]  из него спрятать.
[38:00.180 --> 38:02.180]  Ну вот, в самом деле, смотрите,
[38:02.180 --> 38:04.180]  у нас есть планировщик, он запускает
[38:04.180 --> 38:06.180]  файбер. Файбер работает, доходит
[38:06.180 --> 38:08.180]  до точки остановки, до какого-нибудь иилда,
[38:08.180 --> 38:10.180]  возвращает управление планировщику
[38:10.180 --> 38:12.180]  и вот выбирает новый
[38:12.180 --> 38:14.180]  файбер. Вот
[38:14.180 --> 38:16.180]  смотрите, у планировщика
[38:16.180 --> 38:18.180]  и у файбера есть некоторая
[38:18.180 --> 38:20.180]  иерархия. Вот планировщик запускает файбер,
[38:20.180 --> 38:22.180]  и файберы у него возвращаются. Только так устроена передача управления.
[38:22.180 --> 38:24.180]  И это же вот похоже
[38:24.180 --> 38:26.180]  на тот
[38:26.180 --> 38:28.180]  сценарий, с которым работают сопрограммы.
[38:28.180 --> 38:30.180]  У нас есть колер, который говорит резюм
[38:30.180 --> 38:32.180]  на сопрограмме. Сопрограмма возобновляется,
[38:32.180 --> 38:34.180]  работает, встречает точку suspend
[38:34.180 --> 38:36.180]  и возвращает управление обратно колеру.
[38:38.180 --> 38:40.180]  Вот давайте подумаем, как теперь можно
[38:40.180 --> 38:42.180]  планировщик наш декомпозировать
[38:42.180 --> 38:44.180]  помощью сопрограмм?
[38:50.180 --> 38:52.180]  Ну вот, как будто бы каждый файбер
[38:52.180 --> 38:54.180]  это сопрограмма, да?
[38:54.180 --> 38:56.180]  И мы резюмим эту сопрограмму.
[38:56.180 --> 38:58.180]  Она работает, потом встречает
[38:58.180 --> 39:00.180]  yield, потом возвращается обратно.
[39:02.180 --> 39:04.180]  Ну, я бы сказал, что это не
[39:04.180 --> 39:06.180]  точно. В смысле, файбер
[39:06.180 --> 39:08.180]  это не только сопрограмма. Вот давайте
[39:08.180 --> 39:10.180]  я вам покажу, как файбер мог бы
[39:10.180 --> 39:12.180]  выглядеть.
[39:14.180 --> 39:16.180]  Ну вот, у файбера чуть
[39:16.180 --> 39:18.180]  больше полей, чем одна сопрограмма.
[39:18.180 --> 39:20.180]  Но сейчас
[39:20.180 --> 39:22.180]  это не очень важно. То есть пока можно
[39:22.180 --> 39:24.180]  представить себе, что да, действительно
[39:24.180 --> 39:26.180]  пусть файбер – это почти
[39:26.180 --> 39:28.180]  то же самое, что сопрограмма.
[39:28.180 --> 39:30.180]  И вот мы можем
[39:30.180 --> 39:32.180]  эту логику вынести из планировщика
[39:32.180 --> 39:34.180]  в сопрограмму, в отдельный класс.
[39:34.180 --> 39:36.180]  А что
[39:36.180 --> 39:38.180]  станет тогда в планировщике?
[39:40.180 --> 39:42.180]  Давайте
[39:42.180 --> 39:44.180]  по-другому. А что он вообще будет делать?
[39:46.180 --> 39:48.180]  Ну, в нем по-прежнему есть очередь,
[39:48.180 --> 39:50.180]  потому что планировщик, он про порядок
[39:50.180 --> 39:52.180]  исполнения же, да? Он выбирает, в каком
[39:52.180 --> 39:54.180]  порядке файберы запускаются.
[39:54.180 --> 39:56.180]  А что значит запустить файбер?
[39:56.180 --> 39:58.180]  Отлично.
[39:58.180 --> 40:00.180]  Вот давайте теперь подумаем. Вот есть планировщик
[40:00.180 --> 40:02.180]  такой монолитный. Мы из него вынесли
[40:02.180 --> 40:04.180]  сопрограмму файбера.
[40:04.180 --> 40:06.180]  В нем осталась очередь и запуск.
[40:08.180 --> 40:10.180]  Запуск чего?
[40:10.180 --> 40:12.180]  Ну, сопрограмм, да?
[40:12.180 --> 40:14.180]  А с другой стороны, нужно
[40:14.180 --> 40:16.180]  ли планировщику знать, что он запускает
[40:16.180 --> 40:18.180]  сопрограммы?
[40:20.180 --> 40:22.180]  Давайте вот склеим две последние лекции
[40:22.180 --> 40:24.180]  просто сейчас.
[40:30.180 --> 40:32.180]  Ну, смотрите, вот сопрограмма, она же
[40:32.180 --> 40:34.180]  не про параллелизм, в конце концов.
[40:34.180 --> 40:36.180]  Вот даже если мы скажем, что файбер, он
[40:36.180 --> 40:38.180]  примерно похож на сопрограмму,
[40:38.180 --> 40:40.180]  то как
[40:40.180 --> 40:42.180]  исполнять вот такие вот сопрограммы файберы
[40:42.180 --> 40:44.180]  параллельно?
[40:44.180 --> 40:46.180]  Вот у нас есть тредпул. Это в конце концов
[40:46.180 --> 40:48.180]  просто очередь, да? Очередь, которая запускает
[40:48.180 --> 40:50.180]  задачи. Какие-то, неизвестно какие.
[40:50.180 --> 40:52.180]  Неважно, какие задачи. Просто кусочки
[40:52.180 --> 40:54.180]  синхронного кода, которые не блокируются.
[40:56.180 --> 40:58.180]  Ну, а теперь давайте представим себе
[40:58.180 --> 41:00.180]  что такое запуск
[41:00.180 --> 41:02.180]  файберы. Вот мы стартуем
[41:02.180 --> 41:04.180]  файбер.
[41:04.180 --> 41:06.180]  Как это представить себе в коде?
[41:06.180 --> 41:08.180]  Ну, в уме пока, разумеется.
[41:10.180 --> 41:12.180]  Очереди. Какой у нас очередь?
[41:12.180 --> 41:14.180]  У нас нет большей очереди. У нас есть пул потоков.
[41:22.180 --> 41:24.180]  Смотрите.
[41:24.180 --> 41:26.180]  Вот у меня сопрограмма.
[41:26.180 --> 41:28.180]  И вот я бросил ее в пул потоков.
[41:28.180 --> 41:30.180]  Вот пул потоков. Вот сопрограмма.
[41:30.180 --> 41:32.180]  Я вот бросил сопрограмму в пул потоков. Сделал там резью.
[41:34.180 --> 41:36.180]  И вот
[41:36.180 --> 41:38.180]  кусочек этой
[41:38.180 --> 41:40.180]  сопрограммы исполнился.
[41:40.180 --> 41:42.180]  Потом она завершилась.
[41:42.180 --> 41:44.180]  Ну, я дождался этого таким вот примитивным образом.
[41:44.180 --> 41:46.180]  Потом бросил туда еще раз.
[41:46.180 --> 41:48.180]  Она сделала второй шаг.
[41:50.180 --> 41:52.180]  А что если у меня теперь много таких сопрограмм?
[41:52.180 --> 41:54.180]  Я их бросаю все в пул потоков.
[41:54.180 --> 41:56.180]  Ну, они исполняются параллельно.
[42:00.180 --> 42:02.180]  И теперь я говорю, что сопрограмма,
[42:02.180 --> 42:04.180]  ну, файбер, он включает
[42:04.180 --> 42:06.180]  себя сопрограмму.
[42:06.180 --> 42:08.180]  Собственно, исполнение файбера – это исполнение сопрограммы.
[42:11.180 --> 42:13.180]  Когда оно запускается в пуле потоков,
[42:13.180 --> 42:15.180]  ну, просто туда, чтобы запустить файбер
[42:15.180 --> 42:17.180]  в пуле потоков, нужно
[42:17.180 --> 42:19.180]  в пул потоков бросить задачу,
[42:19.180 --> 42:21.180]  которая что сделает?
[42:21.180 --> 42:23.180]  Резюм сопрограммы.
[42:25.180 --> 42:27.180]  И что получается?
[42:27.180 --> 42:29.180]  Ну, давайте пока
[42:29.180 --> 42:31.180]  с этим остановимся.
[42:31.180 --> 42:33.180]  Вот уже прямая дорога к параллельности
[42:33.180 --> 42:35.180]  файберов.
[42:35.180 --> 42:37.180]  У нас есть отдельность программы, отдельно пул потоков,
[42:37.180 --> 42:39.180]  совмещаем их и получаем вроде бы
[42:39.180 --> 42:41.180]  параллельное исполнение.
[42:41.180 --> 42:43.180]  А что такое Yield в файбере?
[42:43.180 --> 42:45.180]  Вот, в конце концов, чтобы сделать файбер, нужно написать Yield.
[42:47.180 --> 42:49.180]  Вот что будет делать Yield?
[42:51.180 --> 42:53.180]  Ну, я сказал уже, что сопрограмма
[42:53.180 --> 42:55.180]  и файбер – это не совсем одно и то же.
[42:57.180 --> 42:59.180]  Вот Yield приостанавливает
[42:59.180 --> 43:01.180]  файбер.
[43:01.180 --> 43:03.180]  После этого, ну, вот в однопоточных файберах как было?
[43:03.180 --> 43:05.180]  Yield передает управление планировщику,
[43:05.180 --> 43:07.180]  планировщик выбирает следующий файбер и запускает его.
[43:09.180 --> 43:11.180]  Просто сделать suspend мало.
[43:13.180 --> 43:15.180]  Ну, вот, да,
[43:15.180 --> 43:17.180]  после Yield мы же хотим
[43:17.180 --> 43:19.180]  попасть в конец очереди сами.
[43:19.180 --> 43:21.180]  Но правда, у нас нет теперь очереди, у нас просто
[43:21.180 --> 43:23.180]  есть пул потоков.
[43:23.180 --> 43:25.180]  Поэтому, когда мы сделаем Yield, мы что сделаем?
[43:25.180 --> 43:27.180]  Мы
[43:27.180 --> 43:29.180]  сначала выполним suspend
[43:29.180 --> 43:31.180]  сопрограммы.
[43:31.180 --> 43:33.180]  Она становится
[43:33.180 --> 43:35.180]  и после этого
[43:35.180 --> 43:37.180]  в той же задаче пула
[43:37.180 --> 43:39.180]  потоков
[43:39.180 --> 43:41.180]  мы сделаем еще один
[43:41.180 --> 43:43.180]  submit прямо из этого пула,
[43:43.180 --> 43:45.180]  который добавит, который
[43:45.180 --> 43:47.180]  снова нас запланирует на исполнение.
[43:47.180 --> 43:49.180]  И если в планировщике,
[43:49.180 --> 43:51.180]  если в пуле потоков есть вот такая
[43:51.180 --> 43:53.180]  глобальная общая очередь,
[43:53.180 --> 43:55.180]  то вот буквально мы переместимся в ее конец.
[43:57.180 --> 43:59.180]  Но при этом, то есть у нас теперь задача
[43:59.180 --> 44:01.180]  в пуле потоков – это не просто резюм
[44:01.180 --> 44:03.180]  сопрограммы, это резюм
[44:03.180 --> 44:05.180]  сопрограммы, после чего мы перепланируемся.
[44:05.180 --> 44:07.180]  Схватили все?
[44:07.180 --> 44:09.180]  И смотрите,
[44:09.180 --> 44:11.180]  в этой конструкции, во-первых, получается
[44:11.180 --> 44:13.180]  параллелизм совершенно тривиально.
[44:13.180 --> 44:15.180]  То есть мы разделили пул потоков,
[44:15.180 --> 44:17.180]  мы разделили планировщик на сопрограммы
[44:17.180 --> 44:19.180]  и пул потоков,
[44:19.180 --> 44:21.180]  это вот параллельно, это вот
[44:21.180 --> 44:23.180]  независимо, а дальше мы их комбинируем,
[44:25.180 --> 44:27.180]  причем пул потоков
[44:27.180 --> 44:29.180]  понятия не имеет о том, что он
[44:29.180 --> 44:31.180]  запускает, он запускает задачи
[44:31.180 --> 44:33.180]  совершенно
[44:33.180 --> 44:35.180]  непрозрачные ему,
[44:35.180 --> 44:37.180]  а файберы
[44:37.180 --> 44:39.180]  ничего не знают про пул потоков,
[44:39.180 --> 44:41.180]  они пользуются только тем, что у
[44:41.180 --> 44:43.180]  пул потоков есть метод Submit,
[44:43.180 --> 44:45.180]  в который можно бросить задачу.
[44:45.180 --> 44:47.180]  И вот мы получили
[44:47.180 --> 44:49.180]  две совершенно перпендикулярные сущности,
[44:49.180 --> 44:51.180]  которые друг про друга ничего не знают,
[44:51.180 --> 44:53.180]  которые хорошо комбинируются
[44:53.180 --> 44:55.180]  и которые полезны сами по себе,
[44:55.180 --> 44:57.180]  они универсальные. Вот
[44:57.180 --> 44:59.180]  пул потоков, он нужен для
[44:59.180 --> 45:01.180]  файберов, допустим, а еще нужен просто для того,
[45:01.180 --> 45:03.180]  чтобы какие-то вычисления делать
[45:03.180 --> 45:05.180]  или там, не знаю, фьючи,
[45:05.180 --> 45:07.180]  кулбеки для фьючи исполнять.
[45:07.180 --> 45:09.180]  Он полезен сам по себе
[45:09.180 --> 45:11.180]  и не знает ничего про файберы.
[45:11.180 --> 45:13.180]  Также есть программа, она полезна сама по себе,
[45:13.180 --> 45:15.180]  с помощью нее можно делать итераторы, с помощью нее
[45:15.180 --> 45:17.180]  можно делать вот такие вот конвейеры
[45:17.180 --> 45:19.180]  из таких зацепленных модулей,
[45:19.180 --> 45:21.180]  а можно делать файберы.
[45:21.180 --> 45:23.180]  Вот две штуки
[45:23.180 --> 45:25.180]  полезные сами по себе и при этом, которые
[45:25.180 --> 45:27.180]  хорошо сочетаются.
[45:27.180 --> 45:29.180]  Между ними есть очень тонкая граница,
[45:29.180 --> 45:31.180]  очень простая,
[45:31.180 --> 45:33.180]  очень простая граница,
[45:33.180 --> 45:35.180]  всего лишь один метод – сабмит.
[45:35.180 --> 45:37.180]  Файберы рассчитывают, что
[45:37.180 --> 45:39.180]  задача, запланированная через
[45:39.180 --> 45:41.180]  сабмит, и в Энчуре исполнится,
[45:41.180 --> 45:43.180]  где-то исполнится.
[45:43.180 --> 45:45.180]  Вот этого достаточно,
[45:45.180 --> 45:47.180]  вот такого знания достаточно файбером,
[45:47.180 --> 45:49.180]  чтобы научиться,
[45:49.180 --> 45:51.180]  ну, запускаться, научиться делать
[45:51.180 --> 45:53.180]  yield, научиться делать,
[45:53.180 --> 45:55.180]  ну, что еще можно делать.
[45:55.180 --> 45:57.180]  Mutex'ы потом можно делать.
[45:57.180 --> 45:59.180]  Уже файберные,
[45:59.180 --> 46:01.180]  разумеется, которые не блокируют потоки.
[46:01.180 --> 46:03.180]  Можно каналы делать.
[46:03.180 --> 46:05.180]  Можно там
[46:05.180 --> 46:07.180]  Select делать, как в Go.
[46:07.180 --> 46:09.180]  И вот для того, чтобы
[46:09.180 --> 46:11.180]  так вот в эту сторону файберы развивать,
[46:11.180 --> 46:13.180]  нам не нужно знать ничего
[46:13.180 --> 46:15.180]  про планировщика, кроме того,
[46:15.180 --> 46:17.180]  что в нем есть один метод – сабмит.
[46:17.180 --> 46:19.180]  И все благодаря тому, что мы вот
[46:19.180 --> 46:21.180]  придумали с программы.
[46:21.180 --> 46:23.180]  Ну, не мы придумали, а кто-то когда-то придумал
[46:23.180 --> 46:25.180]  с программой.
[46:25.180 --> 46:27.180]  Кажется, что очень мощная идея.
[46:27.180 --> 46:29.180]  И ровно по этой причине
[46:29.180 --> 46:31.180]  с программой есть
[46:31.180 --> 46:33.180]  буквально в любом языке
[46:33.180 --> 46:35.180]  программирования современным.
[46:35.180 --> 46:37.180]  Ну, и не в современном тоже,
[46:37.180 --> 46:39.180]  но в современном точно должны быть.
[46:39.180 --> 46:41.180]  Я думаю, что вы с ними знакомы
[46:41.180 --> 46:43.180]  по языку Python.
[46:43.180 --> 46:45.180]  Ну, в C++ мы их тоже
[46:45.180 --> 46:47.180]  в этом курсе изучим
[46:47.180 --> 46:49.180]  когда-нибудь.
[46:49.180 --> 46:51.180]  Итак, мне кажется, что
[46:51.180 --> 46:53.180]  я объяснил, зачем...
[46:53.180 --> 46:55.180]  объяснил, что такое
[46:55.180 --> 46:57.180]  с программой,
[46:57.180 --> 46:59.180]  как они могут быть полезны,
[46:59.180 --> 47:01.180]  в каких сценариях, и как с помощью
[47:01.180 --> 47:03.180]  них распролелить файберы.
[47:03.180 --> 47:05.180]  Получилось у меня или нет?
[47:05.180 --> 47:07.180]  Убедил я вас.
[47:07.180 --> 47:09.180]  Хорошо, тогда можно
[47:09.180 --> 47:11.180]  заняться чем-то совершенно другим.
[47:11.180 --> 47:13.180]  А именно поговорить...
[47:13.180 --> 47:15.180]  Ну, у нас две задачи было на сегодня.
[47:15.180 --> 47:17.180]  Во-первых, как файберы распролелить.
[47:17.180 --> 47:19.180]  Что?
[47:19.180 --> 47:21.180]  Что?
[47:21.180 --> 47:23.180]  А как резюм suspension?
[47:23.180 --> 47:25.180]  Тоже.
[47:25.180 --> 47:27.180]  Ну, конечно же,
[47:27.180 --> 47:29.180]  это домашняя работа.
[47:29.180 --> 47:31.180]  Вообще
[47:31.180 --> 47:33.180]  все к этому идет. Я обычно на лекции рассказываю,
[47:33.180 --> 47:35.180]  что мы хотим сделать, а в домашних ты это делаешь.
[47:35.180 --> 47:37.180]  Так это обычно устроено.
[47:37.180 --> 47:39.180]  Но в двух словах, примерно же понятно,
[47:39.180 --> 47:41.180]  что такое резюм и suspension.
[47:41.180 --> 47:43.180]  Это переключение контекста.
[47:43.180 --> 47:45.180]  То есть нам снова нужен execution
[47:45.180 --> 47:47.180]  контекст, мы как-то им пользоваться будем.
[47:47.180 --> 47:49.180]  А как именно, ну вот, придется самому подумать.
[47:55.180 --> 47:57.180]  Так нам и в файбере нужно было это понимать.
[47:57.180 --> 47:59.180]  У нас для этого был трамплин, помнишь?
[47:59.180 --> 48:01.180]  Вот такая же история.
[48:07.180 --> 48:09.180]  Так, а вторая
[48:09.180 --> 48:11.180]  половина
[48:11.180 --> 48:13.180]  сегодня, это вот вывод.
[48:13.180 --> 48:15.180]  То есть файберы научатся быть параллельными,
[48:15.180 --> 48:17.180]  но пока файберы не умеют общаться с внешним миром,
[48:17.180 --> 48:19.180]  они бесполезны для нас.
[48:19.180 --> 48:21.180]  Да.
[48:25.180 --> 48:27.180]  Тебе или...
[48:31.180 --> 48:33.180]  Ну как же, мы же построили
[48:33.180 --> 48:35.180]  вот специальный execution контекст,
[48:35.180 --> 48:37.180]  и он был отдельной библиотекой,
[48:37.180 --> 48:39.180]  потому что он был про исполнение,
[48:39.180 --> 48:41.180]  он был очень низко на уровнях абстракции, и он
[48:41.180 --> 48:43.180]  годится и для того, чтобы делать вот
[48:43.180 --> 48:45.180]  файберы напрямую,
[48:45.180 --> 48:47.180]  и годится также для того, чтобы сделать сапрограммы,
[48:47.180 --> 48:49.180]  а сапрограммы сделать файберы.
[48:49.180 --> 48:51.180]  Вот он слишком общий,
[48:51.180 --> 48:53.180]  он подойдет тебе и в одном случае, и в другом случае.
[48:53.180 --> 48:55.180]  То есть нового ассемблера
[48:55.180 --> 48:57.180]  не нужно, достаточно вот этого switch2.
[48:59.180 --> 49:01.180]  Хорошо.
[49:03.180 --> 49:05.180]  Вторая часть нашего рассказа,
[49:05.180 --> 49:07.180]  это вот вывод.
[49:07.180 --> 49:09.180]  Я вам показывал уже этот пример,
[49:09.180 --> 49:11.180]  вот на библиотеке Азио, который
[49:11.180 --> 49:13.180]  многопоточно обрабатывает
[49:13.180 --> 49:15.180]  соединение клиентов
[49:15.180 --> 49:17.180]  к эхо-серверу.
[49:17.180 --> 49:19.180]  Вот мы их принимаем с помощью метода accept.
[49:21.180 --> 49:23.180]  Мы создаем серверный сокет внутри
[49:23.180 --> 49:25.180]  этого объекта acceptor.
[49:25.180 --> 49:27.180]  Там принимаем эти сокеты,
[49:27.180 --> 49:29.180]  принимаем клиентов, конструируем новые
[49:29.180 --> 49:31.180]  сокеты и обрабатываем каждый из них
[49:31.180 --> 49:33.180]  независимо в отдельном потоке
[49:33.180 --> 49:35.180]  в функции session.
[49:35.180 --> 49:37.180]  В ней мы в бесконечном цикле читаем из сокета
[49:37.180 --> 49:39.180]  и пишем обратно в сокет.
[49:39.180 --> 49:41.180]  Что такое сокет?
[49:41.180 --> 49:43.180]  Вы, наверное, уже представляете все, да?
[49:43.180 --> 49:45.180]  На ОКОСе вы этим сейчас, надеюсь,
[49:45.180 --> 49:47.180]  занимаетесь. Это
[49:47.180 --> 49:49.180]  концы TCP-соединения.
[49:49.180 --> 49:51.180]  TCP-соединение – это такая абстракция прямого
[49:51.180 --> 49:53.180]  провода между двумя компьютерами, где бы они
[49:53.180 --> 49:55.180]  ни находились, чтобы между ними не было.
[49:55.180 --> 49:57.180]  Не знаю, магистальные кабели,
[49:57.180 --> 49:59.180]  подводные кабели, какие-нибудь
[49:59.180 --> 50:01.180]  коммутационные фабрики сложенные в дата-центрах,
[50:01.180 --> 50:03.180]  это все неважно. Как будто бы у вас есть прямой
[50:03.180 --> 50:05.180]  провод, его концы – это сокеты,
[50:05.180 --> 50:07.180]  и вы можете на них говорить send
[50:07.180 --> 50:09.180]  receive и отправить получать поток byte.
[50:09.180 --> 50:11.180]  Этот поток byte как будто бы не перерывный,
[50:11.180 --> 50:13.180]  нигде ничего не перепорядочивается, не рвется,
[50:13.180 --> 50:15.180]  но не теряется и так далее.
[50:15.180 --> 50:17.180]  Проблема этого кода в том, что
[50:17.180 --> 50:19.180]  вызовы здесь блокирующие.
[50:19.180 --> 50:21.180]  Когда вы вызываете лицам,
[50:21.180 --> 50:23.180]  это в конце концов какой-то
[50:23.180 --> 50:25.180]  syscall, и в этом syscall вы блокируете поток.
[50:25.180 --> 50:27.180]  А мы говорим, что потоки –
[50:27.180 --> 50:29.180]  это дорогой ресурс, мы не можем
[50:29.180 --> 50:31.180]  заводить их в том масштабе, в котором у нас вообще клиенты
[50:31.180 --> 50:33.180]  появляются.
[50:33.180 --> 50:35.180]  Что же делать?
[50:37.180 --> 50:39.180]  Вы, наверное, знаете, что делать.
[50:39.180 --> 50:41.180]  Нужно использовать сокеты в неблокирующем режиме.
[50:43.180 --> 50:45.180]  Мы ставим специальную опцию
[50:45.180 --> 50:47.180]  флажок на сокете, и после этого,
[50:47.180 --> 50:49.180]  когда мы читаем из сокета,
[50:49.180 --> 50:51.180]  то либо мы получаем данные
[50:51.180 --> 50:53.180]  оттуда, либо, если сокет не готов
[50:53.180 --> 50:55.180]  сейчас, потому что клиент
[50:55.180 --> 50:57.180]  ничего не прислал, мы вместо того, чтобы блокироваться,
[50:57.180 --> 50:59.180]  возвращаем пользователю ошибку
[50:59.180 --> 51:01.180]  evilblock. То есть я бы заблокировался,
[51:01.180 --> 51:03.180]  говорит нам сокет.
[51:03.180 --> 51:05.180]  Он сейчас не готов читать ничего.
[51:05.180 --> 51:07.180]  Это, конечно, здорово, но пока не понятно,
[51:07.180 --> 51:09.180]  то есть мы же хотим
[51:09.180 --> 51:11.180]  от потоков избавиться, поэтому мы должны
[51:11.180 --> 51:13.180]  перейти в какой-то неблокирующий режим.
[51:13.180 --> 51:15.180]  Но пока не понятно, как
[51:15.180 --> 51:17.180]  именно мы узнаем, когда же из неблокирующего
[51:17.180 --> 51:19.180]  сокета можно читать.
[51:19.180 --> 51:21.180]  И для этого нам операционная система дает какой-то
[51:21.180 --> 51:23.180]  API. API называется,
[51:23.180 --> 51:25.180]  если мы говорим про современную операционную систему,
[51:25.180 --> 51:27.180]  про Linux конкретно,
[51:27.180 --> 51:29.180]  то нам дается
[51:29.180 --> 51:31.180]  епол. Нам дается некоторая
[51:31.180 --> 51:33.180]  очередь событий,
[51:33.180 --> 51:35.180]  которая поддерживает ядро.
[51:35.180 --> 51:37.180]  Что вы можете сделать? Вы можете взять свой
[51:37.180 --> 51:39.180]  сокет, файловый дескриптор, и зарегистрировать
[51:39.180 --> 51:41.180]  в этом еполе. Сказать, что я хочу
[51:41.180 --> 51:43.180]  получать уведомления тогда,
[51:43.180 --> 51:45.180]  когда сокет какой-нибудь готов
[51:45.180 --> 51:47.180]  обслужить
[51:47.180 --> 51:49.180]  без блокировки операцию
[51:49.180 --> 51:51.180]  чтения или без блокировки операции записи.
[51:53.180 --> 51:55.180]  И с помощью этого епола можно
[51:55.180 --> 51:57.180]  написать эхо-сервер, который
[51:57.180 --> 51:59.180]  будет работать и обслуживать
[51:59.180 --> 52:01.180]  десятки, сотни, тысяч,
[52:01.180 --> 52:03.180]  миллионы клиентов в один поток
[52:03.180 --> 52:05.180]  операционной системы.
[52:05.180 --> 52:07.180]  Вот тут в документации
[52:07.180 --> 52:09.180]  приведен некоторый псевдокод,
[52:09.180 --> 52:11.180]  ну, почти что псевдокод, давайте
[52:11.180 --> 52:13.180]  мы его быстро разберем.
[52:13.180 --> 52:15.180]  Что здесь происходит? Мы
[52:15.180 --> 52:17.180]  конструируем очередь событий,
[52:17.180 --> 52:19.180]  получаем
[52:19.180 --> 52:21.180]  епол.fd.
[52:21.180 --> 52:23.180]  После этого мы регистрируем
[52:23.180 --> 52:25.180]  в этой очереди
[52:25.180 --> 52:27.180]  серверный
[52:27.180 --> 52:29.180]  сокет, на котором мы слушаем клиентов.
[52:31.180 --> 52:33.180]  После этого
[52:33.180 --> 52:35.180]  мы крутимся
[52:35.180 --> 52:37.180]  вот в таком цикле,
[52:37.180 --> 52:39.180]  в котором мы вызываем сисколу
[52:39.180 --> 52:41.180]  еполвейт. Семантика
[52:41.180 --> 52:43.180]  еполвейт, мы туда передаем
[52:43.180 --> 52:45.180]  некоторое количество сокетов,
[52:45.180 --> 52:47.180]  точнее, мы зарегистрировали
[52:47.180 --> 52:49.180]  в очереди события какое-то количество сокетов,
[52:49.180 --> 52:51.180]  и мы блокируемся на некоторое
[52:51.180 --> 52:53.180]  время, пока
[52:53.180 --> 52:55.180]  либо это время не истечет, либо мы набиваем
[52:55.180 --> 52:57.180]  какое-то количество событий, то есть до тех
[52:57.180 --> 52:59.180]  пор, пока не появится некоторый сокет, который
[52:59.180 --> 53:01.180]  готов обслужить нашу операцию
[53:01.180 --> 53:03.180]  в неблокирующем режиме.
[53:05.180 --> 53:07.180]  Когда еполвейт
[53:07.180 --> 53:09.180]  под этом управление, мы знаем, что
[53:09.180 --> 53:11.180]  какие-то сокеты готовы к чтению
[53:11.180 --> 53:13.180]  записи, и просто перебираем
[53:13.180 --> 53:15.180]  все готовые
[53:15.180 --> 53:17.180]  сокеты. И смотрим,
[53:17.180 --> 53:19.180]  если этот сокет
[53:19.180 --> 53:21.180]  это серверный сокет, то, видимо,
[53:21.180 --> 53:23.180]  мы готовы принять соединение клиента.
[53:23.180 --> 53:25.180]  Мы вызываем accept, и мы уверены, что мы здесь
[53:25.180 --> 53:27.180]  не заблокируемся уже.
[53:27.180 --> 53:29.180]  Вот, получили нового клиента,
[53:29.180 --> 53:31.180]  перевели его в неблокирующий режим,
[53:31.180 --> 53:33.180]  и сказали,
[53:33.180 --> 53:35.180]  что мы хотим на этом клиентском
[53:35.180 --> 53:37.180]  сокете обслуживать, отслеживать события
[53:37.180 --> 53:39.180]  сокет готов на чтение.
[53:39.180 --> 53:41.180]  Регистрируем этот клиентский
[53:41.180 --> 53:43.180]  сокет снова в еполе,
[53:43.180 --> 53:45.180]  в очереди событий, ну и
[53:45.180 --> 53:47.180]  завершаем обработку
[53:47.180 --> 53:49.180]  готовности
[53:49.180 --> 53:51.180]  серверного сокета.
[53:51.180 --> 53:53.180]  Ну, а может быть,
[53:53.180 --> 53:55.180]  события, а может быть,
[53:55.180 --> 53:57.180]  сокет готов к чтению или записи,
[53:57.180 --> 53:59.180]  а может быть,
[53:59.180 --> 54:01.180]  к чтению или записи готов сокет
[54:01.180 --> 54:03.180]  не серверный, а какой-то уже клиентский.
[54:03.180 --> 54:05.180]  Вот мы обработаем его
[54:05.180 --> 54:07.180]  тут.
[54:07.180 --> 54:09.180]  Вот примерно так выглядит
[54:09.180 --> 54:11.180]  любой код, написанный на еполе.
[54:11.180 --> 54:13.180]  Вы, наверное, его писали, правда?
[54:13.180 --> 54:15.180]  Вот. Тогда ответьте мне,
[54:15.180 --> 54:17.180]  что такое вот этот фрагмент кода?
[54:17.180 --> 54:19.180]  Ну вот, какие фрагменты кода написаны
[54:19.180 --> 54:21.180]  здесь? Чем они занимаются?
[54:21.180 --> 54:23.180]  Один занимается новым отключением,
[54:23.180 --> 54:25.180]  другой обрабатывает запросы второго.
[54:25.180 --> 54:27.180]  Ну, в общем случае, это обработчики
[54:27.180 --> 54:29.180]  некоторых событий.
[54:29.180 --> 54:31.180]  Обработчик события, серверный сокет
[54:31.180 --> 54:33.180]  готов к приему клиента.
[54:33.180 --> 54:35.180]  События, там, клиентский сокет готов
[54:35.180 --> 54:37.180]  к чтению из него.
[54:37.180 --> 54:39.180]  Клиентский сокет готов к записи в него.
[54:39.180 --> 54:41.180]  Вот такие вот обработчики.
[54:41.180 --> 54:43.180]  Но, конечно же,
[54:43.180 --> 54:45.180]  да, и вот этот
[54:45.180 --> 54:47.180]  способ, который позволяет вам писать код
[54:47.180 --> 54:49.180]  эффективно, писать эффективный
[54:49.180 --> 54:51.180]  код, который будет
[54:51.180 --> 54:53.180]  гораздо лучше масштабироваться,
[54:53.180 --> 54:55.180]  чем
[54:57.180 --> 54:59.180]  чем вот такой
[54:59.180 --> 55:01.180]  код,
[55:01.180 --> 55:03.180]  где мы блокируем поток просто.
[55:03.180 --> 55:05.180]  Но, с другой стороны,
[55:05.180 --> 55:07.180]  писать код так совершенно невыносимо,
[55:07.180 --> 55:09.180]  потому что, ну, дело тут не все
[55:09.180 --> 55:11.180]  даже, а
[55:11.180 --> 55:13.180]  в том, что этот код
[55:13.180 --> 55:15.180]  это вывернут наизнанку.
[55:15.180 --> 55:17.180]  Вот давайте посмотрим, как этот же код
[55:17.180 --> 55:19.180]  можно было бы переписать на
[55:19.180 --> 55:21.180]  C++.
[55:21.180 --> 55:23.180]  Для этого нам потребуется
[55:23.180 --> 55:25.180]  библиотека, фреймворк, который называется
[55:25.180 --> 55:27.180]  ASIO, асинхронный вот вывод,
[55:27.180 --> 55:29.180]  потому что, ну, это такой стандартный
[55:29.180 --> 55:31.180]  event loop для C++, но
[55:31.180 --> 55:33.180]  на всякий случай
[55:33.180 --> 55:35.180]  мы сейчас не изучаем конкретную библиотеку.
[55:35.180 --> 55:37.180]  Для нас ASIO это конкретная
[55:37.180 --> 55:39.180]  библиотека, но это всего лишь какой-то пример
[55:39.180 --> 55:41.180]  такого вот event loopа цикла событий.
[55:41.180 --> 55:43.180]  Вот этот код, он называется
[55:43.180 --> 55:45.180]  event loop, потому что мы
[55:45.180 --> 55:47.180]  в цикле обрабатываем события
[55:47.180 --> 55:49.180]  на socket, на файловых дискриптерах.
[55:51.180 --> 55:53.180]  Окей, как бы этот код
[55:53.180 --> 55:55.180]  можно было переписать
[55:55.180 --> 55:57.180]  лучше, ну, как можно было
[55:57.180 --> 55:59.180]  переписать его на C++?
[56:07.180 --> 56:09.180]  Ну, смотрите, тут дело непростое.
[56:11.180 --> 56:13.180]  Давайте я даже начну с примера не с
[56:13.180 --> 56:15.180]  эквивалентного кода
[56:15.180 --> 56:17.180]  эхо, а с кода, с примера,
[56:17.180 --> 56:19.180]  попроще.
[56:21.180 --> 56:23.180]  Давайте попробуем осмыслить
[56:23.180 --> 56:25.180]  вот такую программу.
[56:25.180 --> 56:27.180]  Вот вся программа умещается на один экран.
[56:29.180 --> 56:31.180]  Какие сущности у нас появляются?
[56:31.180 --> 56:33.180]  Ну, вот в этом коде
[56:33.180 --> 56:35.180]  есть очередь событий.
[56:35.180 --> 56:37.180]  Это вот епол.
[56:37.180 --> 56:39.180]  И есть цикл, который
[56:39.180 --> 56:41.180]  из этого епола достает
[56:41.180 --> 56:43.180]  готовые события.
[56:45.180 --> 56:47.180]  Этот цикл event loop
[56:47.180 --> 56:49.180]  здесь называется ее контекстом.
[56:49.180 --> 56:51.180]  И он крутится вот в этом
[56:51.180 --> 56:53.180]  вызове run.
[56:53.180 --> 56:55.180]  То есть где-то внутри этого кода спрятан епол
[56:55.180 --> 56:57.180]  этого объекта.
[56:57.180 --> 56:59.180]  И мы
[56:59.180 --> 57:01.180]  крутимся на нем
[57:01.180 --> 57:03.180]  вот внутри этого рана.
[57:03.180 --> 57:05.180]  Теперь что мы делаем?
[57:05.180 --> 57:07.180]  Мы создаем таймер. Мы допустим
[57:07.180 --> 57:09.180]  хотим выполнить некоторый код спустя 3 секунды.
[57:11.180 --> 57:13.180]  Мы создаем объект таймер, он называется
[57:13.180 --> 57:15.180]  в ASIO IO object.
[57:15.180 --> 57:17.180]  Мы говорим
[57:17.180 --> 57:19.180]  на нем async weight.
[57:19.180 --> 57:21.180]  Регистрируем обработчик
[57:21.180 --> 57:23.180]  события.
[57:23.180 --> 57:25.180]  Прошло 3 секунды.
[57:25.180 --> 57:27.180]  Это происходит все мгновенно.
[57:27.180 --> 57:29.180]  После этого мы блокируемся
[57:29.180 --> 57:31.180]  вызове run.
[57:31.180 --> 57:33.180]  И вот возможно внутри этого вызова
[57:33.180 --> 57:35.180]  async weight мы зарегистрировали
[57:35.180 --> 57:37.180]  в еполе таймер, который должен истечаться
[57:37.180 --> 57:39.180]  спустя 3 секунды.
[57:39.180 --> 57:41.180]  Кажется, епол таймеры умеет, да? Прямо вот напрямую.
[57:43.180 --> 57:45.180]  Мы могли бы здесь
[57:45.180 --> 57:47.180]  создать 100-500 таймеров.
[57:47.180 --> 57:49.180]  Кажется, никакой проблемы бы не было.
[57:49.180 --> 57:51.180]  Нам все равно
[57:51.180 --> 57:53.180]  потребовалась бы одна очередь событий
[57:53.180 --> 57:55.180]  и один event loop вот здесь.
[57:57.180 --> 57:59.180]  Вот этот код нам
[57:59.180 --> 58:01.180]  нужен, чтобы продемонстрировать, какие есть
[58:01.180 --> 58:03.180]  участники. Есть io-контекст, это
[58:03.180 --> 58:05.180]  епол, есть IO object,
[58:05.180 --> 58:07.180]  это socket или таймер.
[58:07.180 --> 58:09.180]  Есть асинхронная операция.
[58:09.180 --> 58:11.180]  Сделать что-то в будущем.
[58:13.180 --> 58:15.180]  И вот если это
[58:15.180 --> 58:17.180]  примерно понятно, то давайте мы посмотрим
[58:17.180 --> 58:19.180]  на то, как можно переписать
[58:19.180 --> 58:21.180]  на таком фреймворке
[58:21.180 --> 58:23.180]  echo-сервер.
[58:23.180 --> 58:25.180]  Опять, есть некоторый
[58:25.180 --> 58:27.180]  io-контекст,
[58:27.180 --> 58:29.180]  в котором есть епол.
[58:29.180 --> 58:31.180]  И вот мы его крутим,
[58:31.180 --> 58:33.180]  и вот ровно здесь происходит исполнение
[58:33.180 --> 58:35.180]  вот всего кода.
[58:35.180 --> 58:37.180]  Что это за код?
[58:37.180 --> 58:39.180]  Я уже показывал вам
[58:39.180 --> 58:41.180]  этот пример и сказал, что
[58:41.180 --> 58:43.180]  в этом цикле исполняются обработчики событий.
[58:43.180 --> 58:45.180]  И наш код
[58:45.180 --> 58:47.180]  он будет более высокоуровневым,
[58:47.180 --> 58:49.180]  но в конце концов он состоит из обработчиков событий.
[58:51.180 --> 58:53.180]  Когда мы его
[58:53.180 --> 58:55.180]  стартуем,
[58:55.180 --> 58:57.180]  когда мы пишем сервер на этом коде,
[58:57.180 --> 58:59.180]  мы его конструируем здесь.
[58:59.180 --> 59:01.180]  И в конструкторе этот сервер
[59:01.180 --> 59:03.180]  стартует асинхронную операцию
[59:03.180 --> 59:05.180]  accept.
[59:05.180 --> 59:07.180]  Она не блокирует
[59:07.180 --> 59:09.180]  текущий поток.
[59:09.180 --> 59:11.180]  Это асинхронная операция,
[59:11.180 --> 59:13.180]  которая просто говорит
[59:13.180 --> 59:15.180]  еполу, что
[59:15.180 --> 59:17.180]  вот я регистрирую
[59:19.180 --> 59:21.180]  серверный socket.
[59:23.180 --> 59:25.180]  Я...
[59:25.180 --> 59:27.180]  Нет, серверный socket это accept, конечно.
[59:27.180 --> 59:29.180]  И эта операция говорит,
[59:29.180 --> 59:31.180]  что я хочу принять соединение от клиента
[59:33.180 --> 59:35.180]  в этот объект socket.
[59:35.180 --> 59:37.180]  Но я не буду дожидаться,
[59:37.180 --> 59:39.180]  пока это случится.
[59:39.180 --> 59:41.180]  Я вместо этого подпишусь
[59:41.180 --> 59:43.180]  на результат.
[59:43.180 --> 59:45.180]  То есть я регистрирую серверный socket,
[59:45.180 --> 59:47.180]  вот этот вот,
[59:47.180 --> 59:49.180]  в еполе,
[59:49.180 --> 59:51.180]  который лежит здесь,
[59:51.180 --> 59:53.180]  и прошу
[59:53.180 --> 59:55.180]  этот ее контекст,
[59:55.180 --> 59:57.180]  когда на этом socket-е серверном
[59:57.180 --> 59:59.180]  случится событие, socket готов к чтению,
[01:00:01.180 --> 01:00:03.180]  выполнить accept
[01:00:03.180 --> 01:00:05.180]  и после этого вызвать
[01:00:05.180 --> 01:00:07.180]  этот обработчик,
[01:00:07.180 --> 01:00:09.180]  который я передал в операцию
[01:00:09.180 --> 01:00:11.180]  вторым аргументом.
[01:00:21.180 --> 01:00:23.180]  Так тут все в одном потоке
[01:00:23.180 --> 01:00:25.180]  исполнится. Что значит два клиента?
[01:00:25.180 --> 01:00:27.180]  Нет, просто вот соединение принимается
[01:00:27.180 --> 01:00:29.180]  в этот socket, внутри этого socket.
[01:00:29.180 --> 01:00:31.180]  Асинхронная операция
[01:00:31.180 --> 01:00:33.180]  инициализирует вот этот socket, который передается
[01:00:33.180 --> 01:00:35.180]  в этот объект.
[01:00:37.180 --> 01:00:39.180]  Я бы сказал, что это
[01:00:39.180 --> 01:00:41.180]  не при чем.
[01:00:43.180 --> 01:00:45.180]  Нет, SharedPTR здесь совершенно по другим причинам.
[01:00:53.180 --> 01:00:55.180]  Вот, давайте
[01:00:55.180 --> 01:00:57.180]  чуть дальше пойдем,
[01:00:57.180 --> 01:00:59.180]  я покажу еще один пример и дальше разберу
[01:00:59.180 --> 01:01:01.180]  детальнее.
[01:01:01.180 --> 01:01:03.180]  Вот мы получили клиентский socket,
[01:01:03.180 --> 01:01:05.180]  где-то был вызван
[01:01:05.180 --> 01:01:07.180]  наш обработчик,
[01:01:07.180 --> 01:01:09.180]  и мы в этом
[01:01:09.180 --> 01:01:11.180]  обработчике построили объект сессия,
[01:01:13.180 --> 01:01:15.180]  ему отдали клиентский socket
[01:01:17.180 --> 01:01:19.180]  и эта сессия
[01:01:23.180 --> 01:01:25.180]  первым своим делом
[01:01:25.180 --> 01:01:27.180]  выполнила на socket-е асинхронную операцию
[01:01:27.180 --> 01:01:29.180]  readSAM.
[01:01:29.180 --> 01:01:31.180]  Я хочу
[01:01:31.180 --> 01:01:33.180]  из этого socket-а прочесть
[01:01:33.180 --> 01:01:35.180]  данный вот в этот буфер,
[01:01:35.180 --> 01:01:37.180]  который является полем моего класса.
[01:01:37.180 --> 01:01:39.180]  И когда эта
[01:01:39.180 --> 01:01:41.180]  асинхронная операция завершится,
[01:01:41.180 --> 01:01:43.180]  я хочу, чтобы был вызван этот обработчик.
[01:01:45.180 --> 01:01:47.180]  Я вот говорю слово асинхронная операция,
[01:01:47.180 --> 01:01:49.180]  а кажется его еще не вводил.
[01:01:49.180 --> 01:01:51.180]  Ну а асинхронная операция – синхронный вызов.
[01:01:51.180 --> 01:01:53.180]  Вот что такое синхронный вызов? Синхронный вызов
[01:01:53.180 --> 01:01:55.180]  это вызов, который
[01:01:55.180 --> 01:01:57.180]  вызов синхронный,
[01:01:57.180 --> 01:01:59.180]  если операция завершается
[01:01:59.180 --> 01:02:01.180]  вместе с этим вызовом. То есть вызов
[01:02:01.180 --> 01:02:03.180]  завершился, операция завершилась.
[01:02:03.180 --> 01:02:05.180]  Вот вы блокируетесь на чтении socket-а,
[01:02:05.180 --> 01:02:07.180]  и когда вы выходите
[01:02:11.180 --> 01:02:13.180]  из readSAM, из этого вызова, то и операция
[01:02:13.180 --> 01:02:15.180]  чтения завершилась.
[01:02:15.180 --> 01:02:17.180]  Здесь вызов асинхронный,
[01:02:17.180 --> 01:02:19.180]  то есть вызов завершается мгновенно,
[01:02:19.180 --> 01:02:21.180]  а операция, ну вот,
[01:02:21.180 --> 01:02:23.180]  будет исполнена в будущем где-то.
[01:02:23.180 --> 01:02:25.180]  И когда она
[01:02:25.180 --> 01:02:27.180]  исполнится, будет вызван этот обработчик,
[01:02:29.180 --> 01:02:31.180]  который что сделает?
[01:02:31.180 --> 01:02:33.180]  Вызовет do write,
[01:02:33.180 --> 01:02:35.180]  в котором
[01:02:35.180 --> 01:02:37.180]  стартует еще одно синхронную операцию,
[01:02:37.180 --> 01:02:39.180]  которое пишет socket то,
[01:02:39.180 --> 01:02:41.180]  что прочитал предыдущее.
[01:02:45.180 --> 01:02:47.180]  И когда эта
[01:02:47.180 --> 01:02:49.180]  синхронная запись завершится,
[01:02:49.180 --> 01:02:51.180]  будет вызван
[01:02:51.180 --> 01:02:53.180]  этот обработчик,
[01:02:53.180 --> 01:02:55.180]  который что сделает?
[01:03:03.180 --> 01:03:05.180]  Ну вот, эхо-север, он в цикле читает,
[01:03:05.180 --> 01:03:07.180]  пишет, читает, пишет.
[01:03:07.180 --> 01:03:09.180]  Вот вы запланировали чтение,
[01:03:09.180 --> 01:03:11.180]  оно завершилось, вызван обработчик.
[01:03:11.180 --> 01:03:13.180]  В этом обработчике вы стартовали запись
[01:03:13.180 --> 01:03:15.180]  асинхронную.
[01:03:15.180 --> 01:03:17.180]  Когда оно завершится, будет вызван следующий обработчик,
[01:03:17.180 --> 01:03:19.180]  который сделает обратно в цикле чтения.
[01:03:19.180 --> 01:03:21.180]  На всякий случай,
[01:03:21.180 --> 01:03:23.180]  это не рекурсия, вы понимаете это, да?
[01:03:25.180 --> 01:03:27.180]  Тут рекурсии вообще нет.
[01:03:43.180 --> 01:03:45.180]  Ну это правда, да.
[01:03:45.180 --> 01:03:47.180]  Если мы встретим ошибку, то мы просто перестанем
[01:03:47.180 --> 01:03:49.180]  планировать эти задачи.
[01:03:49.180 --> 01:03:51.180]  На всякий случай, как это все исполняется?
[01:03:51.180 --> 01:03:53.180]  Давайте я картинку покажу.
[01:03:55.180 --> 01:03:57.180]  В общем, как это все смачить в голове
[01:03:57.180 --> 01:03:59.180]  с Яполом?
[01:03:59.180 --> 01:04:01.180]  Вот в Яполе вы видите такие фрагменты
[01:04:03.180 --> 01:04:05.180]  фрагменты кода, обработчики.
[01:04:07.180 --> 01:04:09.180]  Они запускаются в некотором цикле,
[01:04:09.180 --> 01:04:11.180]  в цикле Япола самого, в event loop.
[01:04:11.180 --> 01:04:13.180]  Вот эти обработчики,
[01:04:13.180 --> 01:04:15.180]  здесь вот они, то есть мы также делим
[01:04:15.180 --> 01:04:17.180]  код на фрагменты, на кусочки.
[01:04:19.180 --> 01:04:21.180]  И эти кусочки запускаются где?
[01:04:21.180 --> 01:04:23.180]  Кто их запускает вообще?
[01:04:23.180 --> 01:04:25.180]  Вот этот вызов run.
[01:04:27.180 --> 01:04:29.180]  Что он делает? Смотрите.
[01:04:29.180 --> 01:04:31.180]  Первым делом
[01:04:31.180 --> 01:04:33.180]  в этот вызов run попадает
[01:04:33.180 --> 01:04:35.180]  операция accept or async accept.
[01:04:35.180 --> 01:04:37.180]  То есть код пользователя,
[01:04:37.180 --> 01:04:39.180]  в котором пользователь говорит
[01:04:39.180 --> 01:04:41.180]  я хочу принять очередного клиента.
[01:04:41.180 --> 01:04:43.180]  И внутри этой операции,
[01:04:43.180 --> 01:04:45.180]  внутри реализации accept
[01:04:45.180 --> 01:04:47.180]  в этой асинхронной операции
[01:04:47.180 --> 01:04:49.180]  мы регистрируем в Япол
[01:04:49.180 --> 01:04:51.180]  серверный сокет
[01:04:51.180 --> 01:04:53.180]  и кладем туда обработчик.
[01:04:55.180 --> 01:04:57.180]  Вот его.
[01:04:57.180 --> 01:04:59.180]  Вот такой вот лямбду.
[01:05:01.180 --> 01:05:03.180]  Дальше event loop крутится
[01:05:03.180 --> 01:05:05.180]  и блокируется на Яполе.
[01:05:05.180 --> 01:05:07.180]  Ждет очередного события.
[01:05:07.180 --> 01:05:09.180]  Когда вот этот
[01:05:09.180 --> 01:05:11.180]  событие.
[01:05:11.180 --> 01:05:13.180]  Когда в этом Яполе появляется событие
[01:05:13.180 --> 01:05:15.180]  на вот этом сокете,
[01:05:15.180 --> 01:05:17.180]  то
[01:05:17.180 --> 01:05:19.180]  вот в этой ветке кода
[01:05:21.180 --> 01:05:23.180]  мы выполняем accept,
[01:05:23.180 --> 01:05:25.180]  переводим сокет в неблокирующий режим,
[01:05:25.180 --> 01:05:27.180]  принимаем клиента,
[01:05:27.180 --> 01:05:29.180]  переводим сокет в неблокирующий режим
[01:05:29.180 --> 01:05:31.180]  и вызываем
[01:05:31.180 --> 01:05:33.180]  вот этот обработчик.
[01:05:33.180 --> 01:05:35.180]  А этот обработчик
[01:05:35.180 --> 01:05:37.180]  делает две вещи.
[01:05:37.180 --> 01:05:39.180]  Он, во-первых, снова планирует
[01:05:39.180 --> 01:05:41.180]  следующий accept,
[01:05:41.180 --> 01:05:43.180]  то есть снова бросает
[01:05:43.180 --> 01:05:45.180]  такой вот, снова выполняет такой код
[01:05:45.180 --> 01:05:47.180]  и снова подписывает Япол
[01:05:47.180 --> 01:05:49.180]  на серверный сокет.
[01:05:53.180 --> 01:05:55.180]  А во-вторых, строит
[01:05:55.180 --> 01:05:57.180]  объект сессия
[01:05:57.180 --> 01:05:59.180]  и в методе start у него
[01:05:59.180 --> 01:06:01.180]  стартует асинхронную операцию
[01:06:01.180 --> 01:06:03.180]  асинхронную операцию асинкрицам,
[01:06:03.180 --> 01:06:05.180]  которая в Яполе
[01:06:05.180 --> 01:06:07.180]  регистрирует уже клиентский сокет
[01:06:07.180 --> 01:06:09.180]  и когда на очередной
[01:06:09.180 --> 01:06:11.180]  итерации Япол
[01:06:11.180 --> 01:06:13.180]  достанет этот сокет из
[01:06:13.180 --> 01:06:15.180]  на очередной итерации event loop
[01:06:15.180 --> 01:06:17.180]  из Япола
[01:06:17.180 --> 01:06:19.180]  будет извлечен этот сокет клиента,
[01:06:19.180 --> 01:06:21.180]  то на нем будет выполнена операция чтения
[01:06:21.180 --> 01:06:23.180]  и
[01:06:23.180 --> 01:06:25.180]  после этого
[01:06:25.180 --> 01:06:27.180]  этот самый event loop выполнит обработчик
[01:06:27.180 --> 01:06:29.180]  клиента, в котором написано,
[01:06:29.180 --> 01:06:31.180]  что do write,
[01:06:31.180 --> 01:06:33.180]  async write.
[01:06:33.180 --> 01:06:35.180]  Этот async write
[01:06:35.180 --> 01:06:37.180]  снова регистрирует в Яполе сокет
[01:06:37.180 --> 01:06:39.180]  клиента, но уже на запись
[01:06:39.180 --> 01:06:41.180]  и когда
[01:06:41.180 --> 01:06:43.180]  event loop достанет из Япола этот сокет,
[01:06:43.180 --> 01:06:45.180]  то
[01:06:45.180 --> 01:06:47.180]  будет вызван сискол write
[01:06:47.180 --> 01:06:49.180]  и после этого будет вызван обработчик
[01:06:51.180 --> 01:06:53.180]  async write, то есть
[01:06:53.180 --> 01:06:55.180]  то есть
[01:06:57.180 --> 01:06:59.180]  то есть do read, то есть
[01:06:59.180 --> 01:07:01.180]  асинкрицам.
[01:07:03.180 --> 01:07:05.180]  Понимаете все, что происходит сейчас
[01:07:05.180 --> 01:07:07.180]  или нет?
[01:07:07.180 --> 01:07:09.180]  Это всего лишь способ обернуть
[01:07:09.180 --> 01:07:11.180]  в некоторые объекты тот код,
[01:07:11.180 --> 01:07:13.180]  который вы уже писали на C.
[01:07:13.180 --> 01:07:15.180]  То есть вот такой вопрос,
[01:07:15.180 --> 01:07:17.180]  то есть если в какой-то момент
[01:07:17.180 --> 01:07:19.180]  вот концептор, не запланирован
[01:07:19.180 --> 01:07:21.180]  новый асцепт, то сьемку с Япола он
[01:07:21.180 --> 01:07:23.180]  снился. Вернее, когда
[01:07:23.180 --> 01:07:25.180]  происходит событие, он снимается. Если не запланирован,
[01:07:25.180 --> 01:07:27.180]  он туда же не положится.
[01:07:27.180 --> 01:07:29.180]  И смотрите,
[01:07:29.180 --> 01:07:31.180]  это же как раз и интересно.
[01:07:31.180 --> 01:07:33.180]  Давайте еще раз я проговорю, понятно
[01:07:33.180 --> 01:07:35.180]  ли, что здесь написано?
[01:07:37.180 --> 01:07:39.180]  Ну, то есть понятно, что
[01:07:39.180 --> 01:07:41.180]  новый фреймворк, новый билетек, вы видите
[01:07:41.180 --> 01:07:43.180]  первый раз возможно, поэтому все непонятно
[01:07:43.180 --> 01:07:45.180]  разумеется, но принцип должен быть понятен.
[01:07:45.180 --> 01:07:47.180]  Картинка должна быть понятна.
[01:07:47.180 --> 01:07:49.180]  Вот видите, мы как бы
[01:07:49.180 --> 01:07:51.180]  такие вот очереди
[01:07:51.180 --> 01:07:53.180]  цепочки, циклы
[01:07:53.180 --> 01:07:55.180]  задач строим.
[01:07:55.180 --> 01:07:57.180]  Вот такие отдельные
[01:07:57.180 --> 01:07:59.180]  не блокирующие фрагменты.
[01:07:59.180 --> 01:08:01.180]  Здесь нет ни строчки блокирующего
[01:08:01.180 --> 01:08:03.180]  кода.
[01:08:03.180 --> 01:08:05.180]  Здесь блокироваться может только вызов Япол,
[01:08:05.180 --> 01:08:07.180]  который дожидается очередного события.
[01:08:07.180 --> 01:08:09.180]  И все происходит в одном потоке.
[01:08:09.180 --> 01:08:11.180]  А теперь вопрос на понимание.
[01:08:11.180 --> 01:08:13.180]  Он довольно хитрый.
[01:08:13.180 --> 01:08:15.180]  Вот смотрите, я создал
[01:08:15.180 --> 01:08:17.180]  объект сессия, который представляет
[01:08:17.180 --> 01:08:19.180]  собой обработчик клиентского запроса.
[01:08:19.180 --> 01:08:21.180]  Я создал его на куче.
[01:08:25.180 --> 01:08:27.180]  Забудьте, по-другому.
[01:08:29.180 --> 01:08:31.180]  Вот
[01:08:31.180 --> 01:08:33.180]  пойдем с другой стороны.
[01:08:33.180 --> 01:08:35.180]  Вот у нас есть код
[01:08:35.180 --> 01:08:37.180]  сначала неэффективный, на потоках.
[01:08:37.180 --> 01:08:39.180]  Мы здесь
[01:08:39.180 --> 01:08:41.180]  принимаем соединение клиента
[01:08:41.180 --> 01:08:43.180]  с блокирующим синхронной
[01:08:43.180 --> 01:08:45.180]  мопи. Создаем поток,
[01:08:45.180 --> 01:08:47.180]  и в этом потоке мы читаем из
[01:08:47.180 --> 01:08:49.180]  сокета в буфер,
[01:08:49.180 --> 01:08:51.180]  пишем в сокет из буфера.
[01:08:51.180 --> 01:08:53.180]  Где буфер
[01:08:53.180 --> 01:08:55.180]  живет? Буфер живет на стеке потока.
[01:08:55.180 --> 01:08:57.180]  Локальная
[01:08:57.180 --> 01:08:59.180]  переменная. А теперь
[01:08:59.180 --> 01:09:01.180]  вопрос, а где
[01:09:01.180 --> 01:09:03.180]  будет жить... Ну у нас
[01:09:03.180 --> 01:09:05.180]  теперь по-прежнему много клиентов, зато у нас теперь один
[01:09:05.180 --> 01:09:07.180]  поток. Вот где нам...
[01:09:07.180 --> 01:09:09.180]  Где будут жить буферы для каждого
[01:09:09.180 --> 01:09:11.180]  соединения?
[01:09:11.180 --> 01:09:13.180]  На стеке потока
[01:09:13.180 --> 01:09:15.180]  у нас один поток,
[01:09:15.180 --> 01:09:17.180]  а соединений много. Они же не могут с одним буфером
[01:09:17.180 --> 01:09:19.180]  работать. Это было бы странно.
[01:09:19.180 --> 01:09:21.180]  Они бы его перетирали постоянно.
[01:09:23.180 --> 01:09:25.180]  Ну у каждого клиента свой буфер,
[01:09:25.180 --> 01:09:27.180]  разумеется. Вот там 100 тысяч
[01:09:27.180 --> 01:09:29.180]  клиентов прочитали в буфер свои данные,
[01:09:29.180 --> 01:09:31.180]  потом должны записать.
[01:09:35.180 --> 01:09:37.180]  Не подождите, забудь про класс, я вот зря про него сказал.
[01:09:37.180 --> 01:09:39.180]  Вот нет никакого класса. Есть...
[01:09:41.180 --> 01:09:43.180]  Где стеки... Где
[01:09:43.180 --> 01:09:45.180]  буферы должны жить? На стеке... У нас...
[01:09:45.180 --> 01:09:47.180]  А? Ну на куче, потому что
[01:09:47.180 --> 01:09:49.180]  стеков больше нет у нас. Мы от них отказались здесь.
[01:09:51.180 --> 01:09:53.180]  С одной стороны, это хорошо, у нас теперь нет потоков, решение
[01:09:53.180 --> 01:09:55.180]  масштабируется. А с другой стороны,
[01:09:55.180 --> 01:09:57.180]  где-то должны эти буферы жить.
[01:09:57.180 --> 01:09:59.180]  И что мы делаем в этом коде? Мы
[01:09:59.180 --> 01:10:01.180]  переносим их в кучу.
[01:10:01.180 --> 01:10:03.180]  Мы
[01:10:03.180 --> 01:10:05.180]  конструкцию сессия превращаем в объект
[01:10:05.180 --> 01:10:07.180]  сессия, который мы
[01:10:07.180 --> 01:10:09.180]  алоцируем на куче.
[01:10:09.180 --> 01:10:11.180]  И буфер
[01:10:11.180 --> 01:10:13.180]  становится его полем.
[01:10:13.180 --> 01:10:15.180]  Схватили, да?
[01:10:15.180 --> 01:10:17.180]  В этом есть некоторая глубокая мораль,
[01:10:17.180 --> 01:10:19.180]  которую мы пока не понимаем.
[01:10:19.180 --> 01:10:21.180]  Смотрите, что происходит дальше.
[01:10:21.180 --> 01:10:23.180]  Мы конструируем объект сессия,
[01:10:23.180 --> 01:10:25.180]  то есть мы конструируем
[01:10:25.180 --> 01:10:27.180]  shared pointer, который ссылается на объект сессия.
[01:10:27.180 --> 01:10:29.180]  А после этого,
[01:10:29.180 --> 01:10:31.180]  после этой строчки shared pointer разрушается.
[01:10:33.180 --> 01:10:35.180]  Странно, да?
[01:10:35.180 --> 01:10:37.180]  У вас там совершенно
[01:10:37.180 --> 01:10:39.180]  последний человек,
[01:10:39.180 --> 01:10:41.180]  который сама принимает
[01:10:41.180 --> 01:10:43.180]  владение собой.
[01:10:43.180 --> 01:10:45.180]  Смотрите, после этой строчки shared pointer, который мы
[01:10:45.180 --> 01:10:47.180]  конструировали здесь, будет разрушен. Это правда.
[01:10:47.180 --> 01:10:49.180]  Это вообще странно.
[01:10:49.180 --> 01:10:51.180]  Но мы успели
[01:10:51.180 --> 01:10:53.180]  после конструирования и перед разрушением
[01:10:53.180 --> 01:10:55.180]  вызвать старт.
[01:10:55.180 --> 01:10:57.180]  А в этом старте мы вызвали дурид, а в этом дуриде
[01:10:57.180 --> 01:10:59.180]  мы построили shared pointer
[01:10:59.180 --> 01:11:01.180]  на себя
[01:11:01.180 --> 01:11:03.180]  и в обработчик
[01:11:03.180 --> 01:11:05.180]  асинхронной операции
[01:11:05.180 --> 01:11:07.180]  мы передали не только
[01:11:07.180 --> 01:11:09.180]  зыз, но и self.
[01:11:09.180 --> 01:11:11.180]  То есть обработчик, пока
[01:11:11.180 --> 01:11:13.180]  асинхронная операция не завершилась и не вызван обработчик,
[01:11:13.180 --> 01:11:15.180]  этот обработчик,
[01:11:15.180 --> 01:11:17.180]  находясь где-то в недрах
[01:11:17.180 --> 01:11:19.180]  этого самого ио-контекста,
[01:11:19.180 --> 01:11:21.180]  продляет жизнь объекту сессия,
[01:11:21.180 --> 01:11:23.180]  продляет жизнь буферу.
[01:11:25.180 --> 01:11:27.180]  И вот у нас
[01:11:27.180 --> 01:11:29.180]  здесь получилось уже два shared pointer,
[01:11:29.180 --> 01:11:31.180]  все это во-первых разрушился вот здесь вот
[01:11:31.180 --> 01:11:33.180]  и остался один.
[01:11:33.180 --> 01:11:35.180]  То есть пока в очереди,
[01:11:35.180 --> 01:11:37.180]  пока есть хотя бы одна незавершенная
[01:11:37.180 --> 01:11:39.180]  асинхронная операция для данной сессии,
[01:11:39.180 --> 01:11:41.180]  она продляет жизнь этому
[01:11:41.180 --> 01:11:43.180]  объекту сession.
[01:11:47.180 --> 01:11:49.180]  А теперь вопрос, а почему мы
[01:11:49.180 --> 01:11:51.180]  используем
[01:11:51.180 --> 01:11:53.180]  error кода какие-то?
[01:11:53.180 --> 01:11:55.180]  Почему мы так обрабатываем ошибки?
[01:11:55.180 --> 01:11:57.180]  Понятно ли это?
[01:11:57.180 --> 01:11:59.180]  Почему же у нас нет
[01:11:59.180 --> 01:12:01.180]  исключений?
[01:12:01.180 --> 01:12:03.180]  Медленно.
[01:12:03.180 --> 01:12:05.180]  Черт.
[01:12:05.180 --> 01:12:07.180]  У нас нет
[01:12:07.180 --> 01:12:09.180]  ну да, вот исключения разматывают стэк,
[01:12:09.180 --> 01:12:11.180]  а ну как бы вот у нас
[01:12:11.180 --> 01:12:13.180]  стэка нету. У нас есть как бы один
[01:12:13.180 --> 01:12:15.180]  ну нет у нас стэка здесь, у нас один
[01:12:15.180 --> 01:12:17.180]  поток всего с одним стэком.
[01:12:17.180 --> 01:12:19.180]  Кроме того, ну представьте себе,
[01:12:19.180 --> 01:12:21.180]  исключение вылетает когда?
[01:12:21.180 --> 01:12:23.180]  Когда вот во время выполнения операции
[01:12:23.180 --> 01:12:25.180]  возникает ошибка.
[01:12:25.180 --> 01:12:27.180]  У нас операция асинхронная.
[01:12:27.180 --> 01:12:29.180]  Вот мы ее вызываем,
[01:12:29.180 --> 01:12:31.180]  и вот внутри этого вызова
[01:12:31.180 --> 01:12:33.180]  никакой ошибки,
[01:12:33.180 --> 01:12:35.180]  насколько мы еще не получили. Мы просто
[01:12:35.180 --> 01:12:37.180]  зарегистрировали его в Epole.
[01:12:37.180 --> 01:12:39.180]  Тут как бы рано бросать ошибку.
[01:12:41.180 --> 01:12:43.180]  Так что мы не можем использовать исключения,
[01:12:43.180 --> 01:12:45.180]  мы можем только передать ошибку в
[01:12:45.180 --> 01:12:47.180]  обработчик, в колбэк.
[01:12:51.180 --> 01:12:53.180]  Ну вот.
[01:12:53.180 --> 01:12:55.180]  А как вообще эти колбэки получились,
[01:12:55.180 --> 01:12:57.180]  понимаете ли вы или нет?
[01:12:57.180 --> 01:12:59.180]  Откуда они вообще взялись?
[01:12:59.180 --> 01:13:01.180]  Чем они занимаются?
[01:13:03.180 --> 01:13:05.180]  Ну или по-другому, как
[01:13:05.180 --> 01:13:07.180]  из этого решения
[01:13:07.180 --> 01:13:09.180]  простого, понятного
[01:13:09.180 --> 01:13:11.180]  получилось вообще вот это?
[01:13:17.180 --> 01:13:19.180]  Ну или как из этого решения
[01:13:19.180 --> 01:13:21.180]  получилось вот такое вот?
[01:13:23.180 --> 01:13:25.180]  Ну очень просто. Мы взяли
[01:13:25.180 --> 01:13:27.180]  нашу функцию session,
[01:13:27.180 --> 01:13:29.180]  нашли в ней блокирующие
[01:13:29.180 --> 01:13:31.180]  вызовы.
[01:13:33.180 --> 01:13:35.180]  И просто вот разбили функцию на кусочки.
[01:13:35.180 --> 01:13:37.180]  И каждый кусочек
[01:13:37.180 --> 01:13:39.180]  превратился вот в такой вот обработчик.
[01:13:41.180 --> 01:13:43.180]  Раньше мы их писали вот
[01:13:43.180 --> 01:13:45.180]  в коде на C. Мы писали
[01:13:45.180 --> 01:13:47.180]  их вот прямо внутри этого event loop.
[01:13:47.180 --> 01:13:49.180]  Сейчас мы одно от другого отделили,
[01:13:49.180 --> 01:13:51.180]  но по-прежнему у нас вот есть такие фрагменты.
[01:13:51.180 --> 01:13:53.180]  Наш код
[01:13:53.180 --> 01:13:55.180]  разбился на вот такие вот
[01:13:55.180 --> 01:13:57.180]  фрагменты.
[01:13:57.180 --> 01:13:59.180]  Мы потеряли исключение.
[01:13:59.180 --> 01:14:01.180]  Мы потеряли control flow.
[01:14:01.180 --> 01:14:03.180]  У нас теперь нет циклов.
[01:14:03.180 --> 01:14:05.180]  Вместо циклов, понятного while,
[01:14:05.180 --> 01:14:07.180]  у нас вот есть такая вот странная, ну не рекурсия,
[01:14:07.180 --> 01:14:09.180]  но вот такой цикл задач.
[01:14:15.180 --> 01:14:17.180]  Ты верно говоришь,
[01:14:17.180 --> 01:14:19.180]  но мы к этому и идем.
[01:14:19.180 --> 01:14:21.180]  Вот что у нас сейчас есть?
[01:14:21.180 --> 01:14:23.180]  У нас сейчас есть решение
[01:14:23.180 --> 01:14:25.180]  очень простое, в смысле понятное.
[01:14:25.180 --> 01:14:27.180]  Его удобно писать,
[01:14:27.180 --> 01:14:29.180]  но не масштабируемое.
[01:14:29.180 --> 01:14:31.180]  И у нас есть решение очень
[01:14:31.180 --> 01:14:33.180]  хорошее, в смысле оно эффективное,
[01:14:33.180 --> 01:14:35.180]  масштабируемое.
[01:14:35.180 --> 01:14:37.180]  Но его и писать неудобно,
[01:14:37.180 --> 01:14:39.180]  и читать сложно.
[01:14:39.180 --> 01:14:41.180]  Ну вот попробуй здесь увидеть цикл while.
[01:14:41.180 --> 01:14:43.180]  Это не очень тривиально.
[01:14:43.180 --> 01:14:45.180]  А тут их даже два.
[01:14:45.180 --> 01:14:47.180]  Вот один, а вот
[01:14:47.180 --> 01:14:49.180]  второй.
[01:14:51.180 --> 01:14:53.180]  Ну почему такая беда возникает?
[01:14:53.180 --> 01:14:55.180]  Потому что мы не хотим блокироваться
[01:14:55.180 --> 01:14:57.180]  нигде. Мы себе это запретили.
[01:14:57.180 --> 01:14:59.180]  Мы запретили это на лекции про thread pool,
[01:14:59.180 --> 01:15:01.180]  и вот снова себе запретили.
[01:15:01.180 --> 01:15:03.180]  Потому что в конце концов мы снова хотим
[01:15:03.180 --> 01:15:05.180]  делать это все в thread pool.
[01:15:05.180 --> 01:15:07.180]  Так вот,
[01:15:07.180 --> 01:15:09.180]  как же справиться с нашим кодом?
[01:15:09.180 --> 01:15:11.180]  Он вывернут наизнанку. Вот этот код,
[01:15:13.180 --> 01:15:15.180]  простите, этот код, он подчиняется
[01:15:15.180 --> 01:15:17.180]  вашей логике. Вот у вас написан цикл,
[01:15:17.180 --> 01:15:19.180]  потому что вы его написали, потому что вот в вашей
[01:15:19.180 --> 01:15:21.180]  логике есть цикл.
[01:15:21.180 --> 01:15:23.180]  А здесь исполнение подчиняется
[01:15:23.180 --> 01:15:25.180]  циклу event loop. Вот вы под него подстраиваетесь.
[01:15:27.180 --> 01:15:29.180]  Хочется как-то
[01:15:29.180 --> 01:15:31.180]  проблему эту решить.
[01:15:31.180 --> 01:15:33.180]  Вот у вас
[01:15:33.180 --> 01:15:35.180]  есть некоторый фрагмент кода. Смотрите, вы
[01:15:35.180 --> 01:15:37.180]  прочли данные из сокета.
[01:15:37.180 --> 01:15:39.180]  И вот вы выполняете такой код.
[01:15:39.180 --> 01:15:41.180]  Нужно стартовать синхронную
[01:15:41.180 --> 01:15:43.180]  операцию записи обратно в сокет.
[01:15:43.180 --> 01:15:45.180]  И вы,
[01:15:45.180 --> 01:15:47.180]  у вас есть фрагмент кода
[01:15:47.180 --> 01:15:49.180]  до записи в сокет
[01:15:49.180 --> 01:15:51.180]  и после записи в сокет.
[01:15:51.180 --> 01:15:53.180]  Но они разрываются,
[01:15:53.180 --> 01:15:55.180]  потому что синхронная операция и callback.
[01:15:57.180 --> 01:15:59.180]  Вот было бы здорово их склеить.
[01:16:03.180 --> 01:16:05.180]  Было бы здорово написать
[01:16:05.180 --> 01:16:07.180]  нечто такое.
[01:16:07.180 --> 01:16:09.180]  Вот было бы здорово
[01:16:09.180 --> 01:16:11.180]  написать код, который выглядит
[01:16:11.180 --> 01:16:13.180]  как простой синхронный,
[01:16:15.180 --> 01:16:17.180]  а исполняется как
[01:16:17.180 --> 01:16:19.180]  асинхронный.
[01:16:19.180 --> 01:16:21.180]  Ну не то, что вот похожим образом исполняется,
[01:16:21.180 --> 01:16:23.180]  а вот ровно так исполняется.
[01:16:23.180 --> 01:16:25.180]  То есть мы пишем вот такой код,
[01:16:25.180 --> 01:16:27.180]  ну вернее вот такой код,
[01:16:27.180 --> 01:16:29.180]  а исполняется он
[01:16:29.180 --> 01:16:31.180]  вот ровно так.
[01:16:33.180 --> 01:16:35.180]  Ну и давайте подумаем,
[01:16:35.180 --> 01:16:37.180]  что можно было бы внутри этого
[01:16:37.180 --> 01:16:39.180]  рецама написать.
[01:16:39.180 --> 01:16:41.180]  Но, видимо, мы хотим
[01:16:41.180 --> 01:16:43.180]  воспользоваться
[01:16:43.180 --> 01:16:45.180]  сопрограммами, файберами,
[01:16:45.180 --> 01:16:47.180]  что вам ближе сейчас, какое слово.
[01:16:51.180 --> 01:16:53.180]  Вот что мы хотим сделать
[01:16:53.180 --> 01:16:55.180]  внутри рецама?
[01:16:55.180 --> 01:16:57.180]  Мы внутри рецама в конце концов должны
[01:16:57.180 --> 01:16:59.180]  вызывать сокет асинкрецам,
[01:16:59.180 --> 01:17:01.180]  асинхронный вызов.
[01:17:01.180 --> 01:17:03.180]  И вроде бы наша текущая задача
[01:17:03.180 --> 01:17:05.180]  завершится.
[01:17:05.180 --> 01:17:07.180]  Но мы же говорили вот до этого в начале лекции,
[01:17:07.180 --> 01:17:09.180]  что сокет это же, ой,
[01:17:09.180 --> 01:17:11.180]  файбер это же буквально цепочка
[01:17:11.180 --> 01:17:13.180]  вызовов задач,
[01:17:13.180 --> 01:17:15.180]  которые перепланируются постоянно.
[01:17:15.180 --> 01:17:17.180]  Но вот же она цепочка вызовов.
[01:17:17.180 --> 01:17:19.180]  Раз-два, раз-два, они вращаются
[01:17:19.180 --> 01:17:21.180]  просто.
[01:17:21.180 --> 01:17:23.180]  Так вот, что мы сделаем внутри рецама?
[01:17:23.180 --> 01:17:25.180]  Мы, конечно же, стартуем
[01:17:25.180 --> 01:17:27.180]  асинхронную операцию.
[01:17:29.180 --> 01:17:31.180]  Вот ее.
[01:17:31.180 --> 01:17:33.180]  Но она же не может завершиться тут же.
[01:17:37.180 --> 01:17:39.180]  Мы вроде бы должны завершить задачу.
[01:17:39.180 --> 01:17:41.180]  Но мы при этом файбер. Что мы можем сделать
[01:17:41.180 --> 01:17:43.180]  в таком случае?
[01:17:43.180 --> 01:17:45.180]  Ну или сопрограммы.
[01:17:45.180 --> 01:17:47.180]  Мы остановимся
[01:17:47.180 --> 01:17:49.180]  внутри вызова рецам.
[01:17:49.180 --> 01:17:51.180]  Из вызова не выйдем пока.
[01:17:53.180 --> 01:17:55.180]  А что мы напишем в обработчики этого рецама?
[01:17:57.180 --> 01:17:59.180]  Вот здесь, в колбеке.
[01:18:03.180 --> 01:18:05.180]  А в колбеке мы напишем
[01:18:05.180 --> 01:18:07.180]  резюм файбера и сопрограммы.
[01:18:07.180 --> 01:18:09.180]  И когда
[01:18:09.180 --> 01:18:11.180]  асинхронное чтение завершится,
[01:18:11.180 --> 01:18:13.180]  мы зарезюмим корутину,
[01:18:13.180 --> 01:18:15.180]  сопрограмму и вот наконец
[01:18:15.180 --> 01:18:17.180]  выйдем из этого рецама.
[01:18:17.180 --> 01:18:19.180]  И вот внутри этого рецама
[01:18:19.180 --> 01:18:21.180]  есть такая склейка вот этих
[01:18:21.180 --> 01:18:23.180]  вот задач.
[01:18:23.180 --> 01:18:25.180]  Но при этом пользователь этого не замечает.
[01:18:25.180 --> 01:18:27.180]  Пользователь просто пишет вот такой вот синхронный
[01:18:27.180 --> 01:18:29.180]  код. То есть мы снова,
[01:18:29.180 --> 01:18:31.180]  вот мы в примере с
[01:18:31.180 --> 01:18:33.180]  чем?
[01:18:33.180 --> 01:18:35.180]  В примере, в примере с
[01:18:35.180 --> 01:18:37.180]  корутинами. Мы выпрямили
[01:18:37.180 --> 01:18:39.180]  рекурсию с помощью файберов.
[01:18:39.180 --> 01:18:41.180]  О, с помощью сопрограмм.
[01:18:41.180 --> 01:18:43.180]  Вот здесь вот.
[01:18:43.180 --> 01:18:45.180]  А здесь мы вот выпрямили такую,
[01:18:45.180 --> 01:18:47.180]  ну не то что выпрямили, мы склеили
[01:18:47.180 --> 01:18:49.180]  разрыв асинхронных операций.
[01:18:49.180 --> 01:18:51.180]  С помощью файберов.
[01:18:53.180 --> 01:18:55.180]  С помощью файберов, сопрограмм. Простите, я путаюсь постоянно.
[01:18:55.180 --> 01:18:57.180]  То же самое
[01:18:57.180 --> 01:18:59.180]  с socket-write.
[01:18:59.180 --> 01:19:01.180]  Стартуем асинхронную операцию,
[01:19:01.180 --> 01:19:03.180]  останавливаем сопрограмму, а в обработчике
[01:19:03.180 --> 01:19:05.180]  мы эту сопрограмму возобновляем
[01:19:05.180 --> 01:19:07.180]  резюме.
[01:19:07.180 --> 01:19:09.180]  И вот получается такая
[01:19:09.180 --> 01:19:11.180]  синхронная
[01:19:11.180 --> 01:19:13.180]  асинхронность. У нас под капотом
[01:19:13.180 --> 01:19:15.180]  асинхронные вызовы, потому что это единственный
[01:19:15.180 --> 01:19:17.180]  способ эффективно
[01:19:17.180 --> 01:19:19.180]  исполнять код. Эффективно упаковывать
[01:19:19.180 --> 01:19:21.180]  много конкурентных активностей в малое число поток.
[01:19:21.180 --> 01:19:23.180]  Но пишется он
[01:19:23.180 --> 01:19:25.180]  совершенно прямолинейный цикл while есть.
[01:19:25.180 --> 01:19:27.180]  Это первое достижение.
[01:19:27.180 --> 01:19:29.180]  А второе,
[01:19:29.180 --> 01:19:31.180]  буквально три минуты, но очень важные три минуты.
[01:19:31.180 --> 01:19:33.180]  Вот смотрите,
[01:19:33.180 --> 01:19:35.180]  я показывал вам вот такую реализацию
[01:19:35.180 --> 01:19:37.180]  кода, вот такую реализацию
[01:19:37.180 --> 01:19:39.180]  эхо-севера
[01:19:39.180 --> 01:19:41.180]  с помощью синхронности.
[01:19:41.180 --> 01:19:43.180]  И на потоках.
[01:19:43.180 --> 01:19:45.180]  Вот
[01:19:45.180 --> 01:19:47.180]  заметьте, что
[01:19:47.180 --> 01:19:49.180]  преобразовав, что вот этот код,
[01:19:49.180 --> 01:19:51.180]  этот код можно переписать
[01:19:51.180 --> 01:19:53.180]  вот этот код
[01:19:53.180 --> 01:19:55.180]  совершенно бездумно, совершенно механически.
[01:19:55.180 --> 01:19:57.180]  У нас была функция
[01:19:57.180 --> 01:19:59.180]  session
[01:19:59.180 --> 01:20:01.180]  сейчас по-другому.
[01:20:01.180 --> 01:20:03.180]  У нас была функция
[01:20:03.180 --> 01:20:05.180]  session
[01:20:05.180 --> 01:20:07.180]  она во что превратилась?
[01:20:09.180 --> 01:20:11.180]  В класс.
[01:20:11.180 --> 01:20:13.180]  В ней были локальные переменные.
[01:20:15.180 --> 01:20:17.180]  Они стали
[01:20:17.180 --> 01:20:19.180]  полями класса.
[01:20:21.180 --> 01:20:23.180]  У нас
[01:20:23.180 --> 01:20:25.180]  у нас
[01:20:25.180 --> 01:20:27.180]  был такой цельный кусок
[01:20:27.180 --> 01:20:29.180]  кода,
[01:20:29.180 --> 01:20:31.180]  а он превратился в такую
[01:20:31.180 --> 01:20:33.180]  стоит машину, автомат.
[01:20:33.180 --> 01:20:35.180]  Мы разбили
[01:20:35.180 --> 01:20:37.180]  его в точках блокирующих вызовов
[01:20:37.180 --> 01:20:39.180]  и сделали из них обработчики.
[01:20:39.180 --> 01:20:41.180]  Вот
[01:20:41.180 --> 01:20:43.180]  обратите внимание, что это преобразование
[01:20:43.180 --> 01:20:45.180]  абсолютно механическое, абсолютно предсказуемое.
[01:20:45.180 --> 01:20:47.180]  И
[01:20:47.180 --> 01:20:49.180]  ну забегая сильно вперед,
[01:20:49.180 --> 01:20:51.180]  если вдруг
[01:20:51.180 --> 01:20:53.180]  вы
[01:20:53.180 --> 01:20:55.180]  разработчики
[01:20:55.180 --> 01:20:57.180]  языка программирования
[01:20:57.180 --> 01:20:59.180]  поддержите сопрограммы
[01:20:59.180 --> 01:21:01.180]  прямо в своем языке
[01:21:01.180 --> 01:21:03.180]  на уровне компилятора,
[01:21:03.180 --> 01:21:05.180]  то вы можете
[01:21:05.180 --> 01:21:07.180]  преобразовывать синхронный код
[01:21:07.180 --> 01:21:09.180]  в осинхронный
[01:21:09.180 --> 01:21:11.180]  как здесь вот
[01:21:11.180 --> 01:21:13.180]  не на уровне библиотеки,
[01:21:13.180 --> 01:21:15.180]  а просто вы можете
[01:21:15.180 --> 01:21:17.180]  просить компилятор
[01:21:17.180 --> 01:21:19.180]  переписать вот этот
[01:21:19.180 --> 01:21:21.180]  код таким образом.
[01:21:23.180 --> 01:21:25.180]  Просто сам компилятор за вас выполнит эту
[01:21:25.180 --> 01:21:27.180]  трансформацию, потому что она
[01:21:27.180 --> 01:21:29.180]  абсолютно понятная, она абсолютно структурированная
[01:21:29.180 --> 01:21:31.180]  механическая.
[01:21:31.180 --> 01:21:33.180]  Нужно ему только кое-что
[01:21:33.180 --> 01:21:35.180]  объяснить, некоторые детали.
[01:21:35.180 --> 01:21:37.180]  Объяснить ему,
[01:21:37.180 --> 01:21:39.180]  где у вас в коде
[01:21:39.180 --> 01:21:41.180]  будут синхронные вызовы,
[01:21:43.180 --> 01:21:45.180]  а дальше он сам
[01:21:45.180 --> 01:21:47.180]  ваш красивый синхронный код
[01:21:47.180 --> 01:21:49.180]  вывернет наизнанку, построит вот такую
[01:21:49.180 --> 01:21:51.180]  стейт-машину, локальные перемены
[01:21:51.180 --> 01:21:53.180]  сделают полями, и
[01:21:53.180 --> 01:21:55.180]  вы будете
[01:21:55.180 --> 01:21:57.180]  писать простой код, а исполняется он будет
[01:21:57.180 --> 01:21:59.180]  быстро. Вот мы сейчас
[01:21:59.180 --> 01:22:01.180]  это сделаем вдомашки своими руками,
[01:22:01.180 --> 01:22:03.180]  а потом мы посмотрим,
[01:22:03.180 --> 01:22:05.180]  как эту проблему решает C++.
[01:22:05.180 --> 01:22:07.180]  Но механизм один и тот же – это программа.
[01:22:09.180 --> 01:22:11.180]  Все, спасибо.
