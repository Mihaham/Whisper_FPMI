[00:00.000 --> 00:11.540]  Отлично. Значит, начинаем лекцию и сегодня и на следующей неделе мы будем говорить про библиотеку
[00:11.540 --> 00:19.440]  STL или про стандартную библиотеку C++, стандартную библиотеку шаблонов. Поговорим о том, что в ней
[00:19.440 --> 00:25.600]  есть, для чего это можно применять, как это применять наиболее эффективно. Ну и рассмотрим
[00:25.600 --> 00:31.920]  некоторые там особые приемы, которые связаны с использованием стандартной библиотеки. Значит,
[00:31.920 --> 00:37.480]  ну понятно, что эту лекцию, например, можно было, наверное, привести там условно за полчаса. То есть
[00:37.480 --> 00:44.280]  сказать, что вот, ну хорошо, вот есть контейнеры, есть условный вектор, есть рэй, есть мап, который
[00:44.280 --> 00:49.800]  там представляет из себя бинарное дерево поиска, есть условно там unordered set, который представляет
[00:49.800 --> 00:54.440]  из себя хэш таблиц. Ну вот так вот в обзорном ключе быстренько по всему пройтись и на этом
[00:54.440 --> 01:01.040]  закончить. Но, к сожалению, так не получится. И вот по следующей причине. Ну, во-первых,
[01:01.040 --> 01:08.840]  ну я приведу там пример небольшой из жизни. В общем, я пытался однажды это писать на некотором
[01:08.840 --> 01:13.920]  другом языке программирования и обратился к своему знакому, который является там разработчиком на
[01:13.920 --> 01:18.760]  этом языке. Вот и я как-то там у него потенциировался, как средствами этого языка, как средствами там
[01:18.760 --> 01:23.760]  стандартной библиотеки этого языка можно сделать там ту или иную вещь наиболее эффективно. Вот, то
[01:23.760 --> 01:28.920]  есть хотелось бы, чтобы там был как можно более эффективный код. Вот на что я получил ответ, что,
[01:28.920 --> 01:36.120]  ну как бы, ну я не знаю, он говорит, я пользуюсь этим вот и как бы это делает то, что мне нужно. Вот.
[01:36.120 --> 01:42.840]  В C++ такой подход он не особо принят. То есть если что-то, какой-то алгоритм или какой-то контейнер
[01:42.840 --> 01:47.320]  делает то, что вам нужно, это на самом деле не значит, что это происходит наиболее эффективно.
[01:47.320 --> 01:53.960]  Все-таки если вы пользуетесь C++, если вы все-таки пишете на C++ и так далее, то вопрос эффективности у
[01:53.960 --> 01:59.160]  вас, ну скорее всего, стоят, наверное, в первую очередь. Потому что язык C++ в первую очередь
[01:59.160 --> 02:06.280]  используется в тех местах, где критична какая-то производительность, там критично, ну да,
[02:06.280 --> 02:13.960]  производительность, время работы и тому подобное. Вот. Поэтому важно знать не только там, что делают
[02:13.960 --> 02:18.360]  те или иные контейнеры, те или иные алгоритмы, но и то, как они устроены, за какое время работают. Ну и
[02:18.360 --> 02:22.440]  собственно, да, понимание внутреннего устройства на самом деле очень сильно помогает при разработке
[02:22.440 --> 02:27.880]  программ. Ну, потому что если вы понимаете, когда все устроено внутри, то вы можете выбирать те
[02:27.880 --> 02:32.240]  или иные стратегии использования того или иного контейнера, алгоритма и тому подобное. Вот. Поэтому
[02:32.240 --> 02:37.480]  разговор будет, ну, понятное дело, мы поговорим там про саму библиотеку, про то, что в ней есть,
[02:37.480 --> 02:43.520]  как она устроена и так далее, но и отдельное внимание также уделим внутреннему устройству и наиболее
[02:43.520 --> 02:50.320]  эффективную использованию тех или иных контейнеров и алгоритмов. Вот. Ну, это такая вот небольшая
[02:50.320 --> 02:57.160]  преампула. Теперь непосредственно про стандартную библиотеку шаблонов, про STL. Вообще говоря,
[02:57.160 --> 03:02.640]  STL, это стандартная библиотека шаблонов, это не только набор тех контейнеров и тех алгоритмов,
[03:02.640 --> 03:07.760]  которые в ней есть. На самом деле, STL это нечто большее. В общем, это выходит за рамки просто
[03:07.760 --> 03:12.320]  некоторого набора классов и функций. Это на самом деле некоторое соглашение или некоторая философия
[03:12.320 --> 03:17.600]  программирования на C++. Дело в том, что если вы придете, например, в какую-нибудь другую компанию,
[03:17.600 --> 03:23.280]  особенно если это какая-то крупная компания, то скорее всего вам не придется работать именно
[03:23.280 --> 03:28.240]  STL с этими контейнерами и алгоритмами, потому что, как правило, в достаточно крупных компаниях
[03:28.240 --> 03:32.880]  написаны свои реализации стандартной библиотек, написаны свои реализации контейнеров и тому
[03:32.880 --> 03:39.840]  подобное. Это происходит по нескольким причинам. Во-первых, код style, который принят
[03:39.840 --> 03:45.360]  непосредственно в стандартной библиотеке C++, может отличаться от код style, который принят в вашей
[03:45.360 --> 03:51.440]  компании. Вы наверняка с этим столкнулись. У нас на курсе код style несколько отличается от того,
[03:51.440 --> 03:58.000]  который есть в STL. У нас там именование функций идет в camel case, в стандартной библиотеке C++,
[03:58.000 --> 04:04.240]  в snake case и так далее. Но это, естественно, не главная проблема. Главная проблема заключается в том,
[04:04.240 --> 04:08.800]  что если компания разрабатывает какой-то продукт, то для этого продукта необходимо, условно,
[04:08.800 --> 04:17.760]  какая-то конкретная реализация определенного контейнера. Если мы возьмем какой-нибудь
[04:17.760 --> 04:23.320]  контейнер set, забегая вперед скажу, что STL C++ есть такой шаблонный класс как set,
[04:23.320 --> 04:28.600]  который представляет из себя, условно, интерфейс множества, но реализован в виде красно-черного
[04:28.600 --> 04:34.560]  дерева. Как правило, он реализован в виде красно-черного дерева. В прошлом семестре вы
[04:34.560 --> 04:39.280]  изучали, скажем, AVL дерево. И вот AVL дерево имеет несколько преимуществ перед, скажем,
[04:39.280 --> 04:44.400]  красно-черным деревом. В частности, операция поиска работает быстрее, чем красно-черное дерево.
[04:44.400 --> 04:48.120]  Красно-черное дерево наоборот. Операции вставки и удаления работают чуть быстрее, чем в AVL,
[04:48.120 --> 04:54.880]  как правило, в среднем. Если, скажем, в вашем продукте очень критичен быстрый поиск,
[04:54.880 --> 04:58.280]  то есть у вас вставки и удаления происходят не очень часто, а вот поиск осуществляется довольно
[04:58.280 --> 05:04.120]  быстро, то заменив красно-черное дерево на AVL дерево, вы получаете больше перфоманс в вашем
[05:04.120 --> 05:09.800]  продукте. Поэтому в вашей компании условно сет может быть реализован в виде AVL дерева,
[05:09.800 --> 05:17.640]  например. Поэтому мы изучаем STL не для того, чтобы научиться пользоваться конкретными контейнерами,
[05:17.640 --> 05:23.240]  а чтобы изучить на примере, как устроена договоренность между разработчиками на C++,
[05:23.240 --> 05:26.920]  как должны выглядеть те или иные контейнеры. То есть условно контейнеры должны содержать такие
[05:26.920 --> 05:31.920]  методы, контейнеры должны работать за какое-то время, или условно алгоритмы должны удовлетворять
[05:31.920 --> 05:38.520]  следующему интерфейсу. То есть разговор в качестве одной из запасательных разговоров мы будем
[05:38.520 --> 05:44.320]  говорить про интерфейсы, то есть что гарантируют контейнеры, как они взаимодействуют с пользователем
[05:44.320 --> 05:51.000]  и так далее. STL это больше не про сами контейнеры и их устройства, а про условно договоренность или
[05:51.000 --> 05:58.320]  интерфейс. В общем, длинное опрямование в итоге получилось, давайте перейдем непосредственно к теме.
[05:58.320 --> 06:05.720]  Сегодня мы говорим про последовательные контейнеры. Что такое контейнер? Тут небольшие
[06:05.720 --> 06:10.040]  формализации. Контейнер это некоторый тип данных, который обеспечивает хранение объектов других
[06:10.040 --> 06:14.400]  типов, а также интерфейс для доступа к ним. То есть если вам нужно сохранить какие-то данные, то
[06:14.400 --> 06:19.640]  как правило вы используете некоторые контейнеры. То есть вам приходит что-то со входа, вам нужно
[06:19.640 --> 06:25.520]  эти данные сохранить, и вы как правило их сохраняете в некотором контейнере. Среди всех контейнеров
[06:25.520 --> 06:29.800]  выделяются последовательные контейнеры, ассоциативные контейнеры. Последовательный контейнер
[06:29.800 --> 06:34.920]  это такой контейнер, который обеспечивает у порядочный способ хранения элементов, который
[06:34.920 --> 06:39.520]  зависит от времени и места их добавления, но не зависит от их значений. Что это значит? Это
[06:39.520 --> 06:46.560]  значит, что вы в каждый момент времени можете условно понять или даже управлять тем, куда будет
[06:46.560 --> 06:50.760]  вставлен тот или иной объект. Если у вас есть последовательность из трех элементов, вы можете
[06:50.760 --> 06:57.760]  что теперь на второй позиции должен стоять элемент x, или вы хотите добавить очередные элементы, скажем, 5 элементов, и добавляете их в конец.
[06:57.760 --> 07:03.760]  И вы можете быть уверены, что эти 5 элементов обязательно станут в конец. В общем случае это не так.
[07:03.760 --> 07:08.760]  Понятное дело, там есть ассоциативные контейнеры, например, бинарное деревье поиска.
[07:08.760 --> 07:13.760]  Порядок элементов в бинарном дереве поиска определяется непосредственно построением дерева.
[07:14.760 --> 07:18.760]  То есть вы не можете сказать, что вот этот элемент должен обязательно стоять в корне дерева,
[07:18.760 --> 07:23.760]  или этот элемент обязательно должен стоять в качестве самого левого объекта дерева,
[07:23.760 --> 07:25.760]  потому что дерево хранит свойственный порядок.
[07:25.760 --> 07:31.760]  В последовательном контейнере вы можете сами контролировать, в каком порядке идут те или иные элементы.
[07:31.760 --> 07:38.760]  И первый контейнер, про который мы сегодня поговорим, это контейнер std array.
[07:38.760 --> 07:43.760]  С std array, я думаю, многие уже знакомы, то есть его нужно было реализовывать в первом задании.
[07:43.760 --> 07:45.760]  Просто проговорим несколько важных вещей.
[07:45.760 --> 07:50.760]  std array – это шаблонный класс, который представляет себя аналог C style массива,
[07:50.760 --> 07:53.760]  то есть обычный C-шный массив, которого вы выделяете на стеке.
[07:53.760 --> 08:02.760]  Так как мы помним, что, так как C-шные массивы имеют фиксированный размер,
[08:02.760 --> 08:06.760]  то в качестве дополнительного шаблонного параметра, помимо типа хранимых элементов,
[08:06.760 --> 08:09.760]  мы его параметризуем количеством хранимых элементов.
[08:09.760 --> 08:16.760]  И вот std array tn, по сути, эквивалентен использованию C-style массива из пяти элементов на стеке.
[08:16.760 --> 08:19.760]  То есть вот эти две записи, они в некотором смысле эквивалентны.
[08:19.760 --> 08:24.760]  И первая строка… Да, кстати, мышку уже видно, да? Все нормально?
[08:24.760 --> 08:25.760]  Все видно.
[08:25.760 --> 08:26.760]  Да, отлично.
[08:26.760 --> 08:30.760]  То есть вот если вы используете обычный C-шный массив, то по сути это то же самое,
[08:30.760 --> 08:33.760]  как если бы вы использовали std array из стандартной библиотеки C++.
[08:33.760 --> 08:37.760]  Потому что и тот, и тот, они выделяют память на стеке и пользуются ей.
[08:37.760 --> 08:41.760]  Ну и скажем, здесь в первом примере я создал C-шный массив из пяти элементов,
[08:41.760 --> 08:45.760]  заполнил его значением 1, 2, 3, все остальные два элемента заполнились нулями.
[08:45.760 --> 08:48.760]  В случае std array абсолютно точно так же.
[08:48.760 --> 08:55.760]  Ну и, собственно, ровно здесь все указано, если вы создаете std array из примитивных типов,
[08:55.760 --> 09:00.760]  то он, как и в языке C, как и при создании обычных C-шных массивов,
[09:00.760 --> 09:04.760]  он заполняется, как говорят обычно, мусором, но вообще говоря он ничем не инициализирован,
[09:04.760 --> 09:06.760]  и обращение к этим элементам это undefinedBehaviour.
[09:06.760 --> 09:10.760]  То есть если вы читаете эти данные, прежде чем туда что-то записать.
[09:10.760 --> 09:14.760]  В случае, если вы используете не примитивные типы, а типы класса,
[09:14.760 --> 09:16.760]  то это работает немного иначе.
[09:16.760 --> 09:20.760]  Мы знаем, что если вы написали свой класс, то у классов, в отличие от примитивных типов,
[09:20.760 --> 09:24.760]  всегда есть, ну не всегда хорошо, но, как правило, есть там дефолтный конструктор.
[09:24.760 --> 09:27.760]  И если вы создаете пять элементов из какого-то класса,
[09:27.760 --> 09:31.760]  то у вас выделяется на стеге память достаточное для хранения этих пяти элементов,
[09:31.760 --> 09:34.760]  и для каждого из этих элементов вызывается конструктор по умолчанию.
[09:34.760 --> 09:37.760]  Поэтому обращение к этим элементам все нормально.
[09:37.760 --> 09:41.760]  Важно понимать, что если вы создаете просто массивные инициализации для примитивных типов,
[09:41.760 --> 09:43.760]  то он заполняется мусором.
[09:43.760 --> 09:48.760]  То есть при обращении к этим элементам у вас, при чтении этих элементов,
[09:48.760 --> 09:49.760]  происходит undefinedBehaviour.
[09:49.760 --> 09:54.760]  Если вы создаете std array из пяти элементов, которые имеют тип некоторого класса,
[09:54.760 --> 09:57.760]  то они заполняются дефолтным конструктором.
[09:57.760 --> 09:58.760]  Если такое есть.
[09:58.760 --> 10:01.760]  Естественно, если у вас нет в классе дефолтного конструктора,
[10:01.760 --> 10:04.760]  то создать std array таким образом у вас не получится.
[10:04.760 --> 10:06.760]  Потому что компилятор попытается вызвать дефолтный конструктор,
[10:06.760 --> 10:08.760]  у вас ничего не выйдет.
[10:08.760 --> 10:13.760]  Нужно будет использовать вот эту обычную классическую инициализацию с помощью фигурных скобок.
[10:17.760 --> 10:23.760]  Ну и, собственно, мы поговорили, в чем похожа обычная инициализация std array,
[10:23.760 --> 10:25.760]  но также, понятное дело, у них есть ряд отличий.
[10:25.760 --> 10:28.760]  Ну вот, в частности, мы с вами на первой лекции говорили о том, что
[10:28.760 --> 10:30.760]  стишный массив нельзя скопировать.
[10:30.760 --> 10:33.760]  То есть если вы хотите, например, создать копию обычного стишного массива,
[10:33.760 --> 10:35.760]  то вот с помощью такого синтаксиса в первой строчке,
[10:35.760 --> 10:38.760]  у вас не получится это сделать, потому что так нельзя.
[10:38.760 --> 10:42.760]  Но при этом, если у вас есть некоторая структура или класс,
[10:42.760 --> 10:45.760]  у которой в качестве поля выступает обычный стишный массив,
[10:45.760 --> 10:48.760]  то внезапно такое копирование начинает работать.
[10:48.760 --> 10:50.760]  Это тоже мы обсуждали на первой лекции,
[10:50.760 --> 10:54.760]  потому что копирование для std arrays работает так, как вы ожидаете.
[10:54.760 --> 10:58.760]  То есть просто возьмется ваш array и скопируется в новое место.
[10:58.760 --> 11:01.760]  То есть у вас есть cpp-style array, то есть std array,
[11:01.760 --> 11:03.760]  и вы его скопировали в новый массив.
[11:03.760 --> 11:05.760]  То есть произойдет обычное копирование.
[11:05.760 --> 11:08.760]  Второе отличие, ну второе важное отличие опять же заключается в том,
[11:08.760 --> 11:12.760]  что если вы попытаетесь принять стишный массив по значению,
[11:12.760 --> 11:15.760]  то у вас ничего не получится, потому что даже если вы тут написали
[11:15.760 --> 11:19.760]  как бы синтаксис объявления переменной, то компилятору на это плевать.
[11:19.760 --> 11:22.760]  Он просто скажет, что мы тут будем принимать массив по указателю,
[11:22.760 --> 11:25.760]  точнее просто будем принимать указатель на первый элемент.
[11:25.760 --> 11:29.760]  И соответственно внутри функции getCRA нет никакой возможности
[11:29.760 --> 11:31.760]  узнать размер массива и так далее.
[11:31.760 --> 11:34.760]  И более того, компилятор вообще не будет проверять,
[11:34.760 --> 11:37.760]  верно ли, что вы передали массив из пяти элементов,
[11:37.760 --> 11:39.760]  или вы передали массив кого-то другого размера.
[11:39.760 --> 11:42.760]  То есть никаких проверок не происходит, потому что по факту
[11:42.760 --> 11:45.760]  компилятор принимает это все как указатель.
[11:46.760 --> 11:49.760]  Вот в случае STDRA это не так, STDRA это конкретный тип,
[11:49.760 --> 11:51.760]  ну то есть это прям тип, это класс.
[11:51.760 --> 11:54.760]  А что это у вас в линутации нету?
[11:57.760 --> 11:59.760]  Прошу прощения.
[12:08.760 --> 12:10.760]  Сейчас исправим.
[12:12.760 --> 12:14.760]  Готово?
[12:15.760 --> 12:17.760]  Да, все пофиксилось.
[12:17.760 --> 12:19.760]  Отлично.
[12:24.760 --> 12:27.760]  Я остановился на том, что если вы функцию принимаете STDRA,
[12:27.760 --> 12:30.760]  то STDRA это обычный тип, тип класса, который имеет тип,
[12:30.760 --> 12:32.760]  в данном случае int 5.
[12:32.760 --> 12:36.760]  И поэтому в эту функцию вы можете передать только массив из пяти элементов.
[12:36.760 --> 12:41.760]  При этом при передаче массива сюда у вас массив будет скопирован.
[12:41.760 --> 12:43.760]  То есть обычная темантика копирования,
[12:43.760 --> 12:48.760]  как это устроено для любых других типов.
[12:49.760 --> 12:52.760]  Ну и соответственно, если вы хотите передать массив в функцию,
[12:52.760 --> 12:55.760]  точнее STDRA в функцию, и при этом хотите избежать копирования,
[12:55.760 --> 12:58.760]  то вы можете передать его по ссылке или по константной ссылке,
[12:58.760 --> 13:00.760]  как любую другую переменную.
[13:00.760 --> 13:04.760]  Вот в последнем боксе это указано.
[13:08.760 --> 13:11.760]  Ну и соответственно, что еще?
[13:11.760 --> 13:14.760]  Какие еще есть правила использования STDRA?
[13:14.760 --> 13:20.760]  Смотрите, у C++ наследство языка AC досталось очень много функций,
[13:20.760 --> 13:23.760]  которые работают с обычным C-шным массивом.
[13:23.760 --> 13:25.760]  Но обычные C-шные массивы – это не что иное,
[13:25.760 --> 13:28.760]  как правило, просто указатель и его размер.
[13:28.760 --> 13:32.760]  Допустим, вам необходимо использовать вот такого рода функцию.
[13:32.760 --> 13:35.760]  То есть функцию, которая принимает на вход какой-то указатель на массив
[13:35.760 --> 13:37.760]  и принимает его размер.
[13:37.760 --> 13:39.760]  А у вас на руках только STDRA.
[13:39.760 --> 13:41.760]  Так как вы разрабатываете код на C++,
[13:41.760 --> 13:45.760]  то вы пользуетесь стандартными безопасными обертками.
[13:45.760 --> 13:47.760]  Что в этом случае делать?
[13:47.760 --> 13:50.760]  На этот счет у STDRA есть специальный метод дата,
[13:50.760 --> 13:53.760]  который просто-напросто берет и возвращает указатель на первый элемент.
[13:53.760 --> 13:55.760]  То есть, на самом деле, вы бы могли,
[13:55.760 --> 13:58.760]  аналогично вместо дата, вы могли бы использовать, скажем,
[13:58.760 --> 14:01.760]  амперсант A0, рэй.
[14:01.760 --> 14:05.760]  И по сути, это бы означало то же самое.
[14:05.760 --> 14:07.760]  Когда вы пишете ra.data,
[14:07.760 --> 14:10.760]  это более наглядно показывает ваше намерение.
[14:10.760 --> 14:12.760]  То есть, вы хотите указатель на первый элемент,
[14:12.760 --> 14:14.760]  то есть указатель на обычный массив,
[14:14.760 --> 14:16.760]  вот он вам тут и возвращается.
[14:16.760 --> 14:19.760]  И, соответственно, с помощью метода size вы возвращаете размер массива.
[14:19.760 --> 14:23.760]  Еще одно преимущество использования STDRA перед обычными C++ массивами –
[14:23.760 --> 14:26.760]  STDRA всегда знает свой собственный размер.
[14:26.760 --> 14:28.760]  Чтобы получить размер C++ массива,
[14:28.760 --> 14:31.760]  вам нужно поиграться с size и так далее.
[14:31.760 --> 14:33.760]  Какие еще есть методы для доступа данным?
[14:33.760 --> 14:35.760]  Понятное дело, есть методы квадратной скопки,
[14:35.760 --> 14:37.760]  есть методы front,
[14:37.760 --> 14:38.760]  есть методы back.
[14:38.760 --> 14:40.760]  Я думаю, по логике понятно, что они делают.
[14:40.760 --> 14:42.760]  Back берет последний элемент, front берет первый элемент.
[14:42.760 --> 14:44.760]  И есть специальный метод add,
[14:44.760 --> 14:47.760]  который работает точно так же, как квадратные скопки.
[14:47.760 --> 14:50.160]  Но в случае выхода за границем массива
[14:50.160 --> 14:51.160]  он дополнительно проверяет,achtenly,
[14:51.160 --> 14:53.160]  вышли вы за границем массива или нет.
[14:53.160 --> 14:55.160]  И если вышли, то бросают исключение.
[14:55.160 --> 14:57.160]  Квадратные скопки не бросают исключение,
[14:57.160 --> 14:59.160]  они не проверяют выход за границем массива.
[14:59.160 --> 15:01.760]  И, как вы понимаете, квадратные скопки работают чуть эффективней,
[15:01.760 --> 15:06.760]  чем add, потому что они не используют некоторого, они не используют, собственно, проверок.
[15:06.760 --> 15:12.760]  Поэтому если вам, скажем, нужен безопасный код, то вы пишете add, если вам нужен быстрый код, то вы используете квадратные скобки.
[15:12.760 --> 15:18.760]  Опять же, это самая вилка или выбор между безопасным кодом и эффективным кодом.
[15:18.760 --> 15:24.760]  Ну, понятно, есть методы emptySize, которые говорят, пусть ли массив и возвращает его размер.
[15:24.760 --> 15:28.760]  При этом массив считается empty только если у него n равно 0.
[15:28.760 --> 15:41.760]  То есть если вы инстанцировали, скажем, std array int и 0, то empty возвращает true только для такого массива.
[15:41.760 --> 15:45.760]  Для любых других std arrays empty всегда возвращает true.
[15:45.760 --> 15:47.760]  Ну и также есть методы fill и swap.
[15:47.760 --> 15:49.760]  Ну, значит, с методом fill, думаю, все понятно.
[15:50.760 --> 15:54.760]  Fill принимает некоторый объект и заполняет этим объектом все элементы вашего массива.
[15:54.760 --> 15:58.760]  Ну а метод swap он просто берет и обменивает содержимое всех массивов.
[15:58.760 --> 16:02.760]  При этом этот swap, важно отметить, работает за o от n.
[16:02.760 --> 16:05.760]  То есть он работает за линейное время от размера массива.
[16:05.760 --> 16:06.760]  Почему так?
[16:06.760 --> 16:10.760]  То есть мы вроде как говорили, что у нас есть муфсемантика отличная,
[16:10.760 --> 16:14.760]  и когда мы делаем swap, мы там меняем, грубо говоря, указатели и так далее,
[16:14.760 --> 16:17.760]  и все работает быстро за o от единицы.
[16:17.760 --> 16:23.760]  Вот почему у нас, скажем, swap работал быстро для стека.
[16:23.760 --> 16:25.760]  То есть когда у нас был стек, то есть стек это что?
[16:25.760 --> 16:28.760]  Это просто указатель на динамически элоцированную память,
[16:28.760 --> 16:31.760]  ну и другой стек это тоже указатель на динамически элоцированную память.
[16:31.760 --> 16:36.760]  И вот чтобы их обменять, нам достаточно было просто обменять два указателя.
[16:36.760 --> 16:39.760]  И, соответственно, все это работает за o от единицы.
[16:39.760 --> 16:41.760]  В случае с std array не так.
[16:41.760 --> 16:45.760]  То есть std array на самом деле в памяти он, то есть вот это все находится на стеке,
[16:45.760 --> 16:49.760]  вот это находится в динамической области памяти.
[16:49.760 --> 16:55.760]  В случае std array сам массив, он хранится на стеке.
[16:55.760 --> 16:58.760]  То есть сами данные массива, они хранятся на стеке.
[16:58.760 --> 17:04.760]  То есть std array хранит не указатель, а именно сам массив целиком, как переменную.
[17:04.760 --> 17:09.760]  Поэтому если вам нужно обменять содержимое двух ячеек памяти,
[17:09.760 --> 17:12.760]  а в этих ячейках памяти, собственно, хранятся сами эти объекты,
[17:12.760 --> 17:14.760]  то есть не указатель, а сами объекты.
[17:14.760 --> 17:16.760]  Так вот, чтобы обменять содержимое этих двух ячеек памяти,
[17:16.760 --> 17:22.760]  вам нужно за линейное время пройтись и по очереди обменять каждый из этих элементов.
[17:22.760 --> 17:25.760]  Поэтому swap для std array работает за линейное время.
[17:25.760 --> 17:30.760]  Ну как раз-таки это следствие того, что std array хранит свои данные на стеке, а не в куче.
[17:30.760 --> 17:33.760]  Если он хранил свои данные в куче, то достаточно было обменять два указателя,
[17:33.760 --> 17:35.760]  указатели, которые ведут в кучу.
[17:38.760 --> 17:42.760]  Ну и std array, как и на самом деле любые другие контейнеры,
[17:42.760 --> 17:45.760]  их можно сравнивать между собой на больше-меньше равенства-неравенства,
[17:45.760 --> 17:47.760]  и сравнение происходит в лексикографическом порядке.
[17:47.760 --> 17:49.760]  То есть сначала сравним с первыми элементами,
[17:49.760 --> 17:51.760]  с вторыми элементами, ну и так далее.
[17:52.760 --> 17:54.760]  На этом, кажется, все.
[17:54.760 --> 17:56.760]  Есть вопросы?
[17:56.760 --> 17:58.760]  Std array.
[18:03.760 --> 18:05.760]  Видимо, нет. Окей.
[18:05.760 --> 18:08.760]  Тогда переходим, наверное, к наиболее интересному контейнеру,
[18:08.760 --> 18:10.760]  про который мы поговорим больше всего.
[18:10.760 --> 18:12.760]  Это контейнер std vector.
[18:12.760 --> 18:15.760]  Тут будет достаточно длинный и обстоятельный разговор.
[18:15.760 --> 18:17.760]  Смотрите.
[18:17.760 --> 18:19.760]  Ну, во-первых, что такое std vector?
[18:19.760 --> 18:21.760]  Это, опять же, шаблонный класс, который представляет из себя
[18:21.760 --> 18:24.760]  динамически расширяющийся массив элементов типа T.
[18:24.760 --> 18:27.760]  То есть это шаблонный класс, он параметризуется типом хранимых элементов
[18:27.760 --> 18:30.760]  и, соответственно, представляет из себя массив.
[18:30.760 --> 18:33.760]  В чем его, то есть как бы std array-массив и std vector-массив?
[18:33.760 --> 18:35.760]  В чем их отличие?
[18:35.760 --> 18:38.760]  Их главный отличие заключается в том, что std vector хранит свои данные в куче.
[18:38.760 --> 18:39.760]  Это первое.
[18:39.760 --> 18:43.760]  А во-вторых, std vector умеет расширять свой размер.
[18:43.760 --> 18:46.760]  То есть его размер не является фиксированным, а может постепенно расширяться.
[18:46.760 --> 18:49.760]  Вот у std array размер фиксирован и известен заранее.
[18:49.760 --> 18:53.760]  Вы его указываете заранее в треугольных скобках в качестве параметра шаблона.
[18:53.760 --> 18:55.760]  std vector не так.
[18:55.760 --> 18:57.760]  Он может в какой-то момент быть нулевым, в какой-то момент стать равным 10,
[18:57.760 --> 19:00.760]  потом миллион и так далее.
[19:00.760 --> 19:03.760]  То есть если бы мы приводили некоторую аналогию вектора
[19:03.760 --> 19:05.760]  с какими-то другими известными вам штуками,
[19:05.760 --> 19:08.760]  это, наверное, массив, который вы делаете в куче.
[19:08.760 --> 19:11.760]  Скажем, вам приходится входа с консоли число n,
[19:11.760 --> 19:15.760]  и вы можете создать свой массив размера n с помощью операции new.
[19:15.760 --> 19:19.760]  Аналогичного можно достичь, если вы создаете вектор
[19:19.760 --> 19:22.760]  и передаете ему в качестве параметра конструктора n.
[19:22.760 --> 19:27.760]  То есть и cstyle, и cppstyle хранят свои данные в куче.
[19:27.760 --> 19:30.760]  Но важный момент заключается в том, что вектор,
[19:30.760 --> 19:34.760]  во-первых, в отличие от cstyle, он знает свой размер.
[19:34.760 --> 19:36.760]  Вот у этого cstyle это просто указатель.
[19:36.760 --> 19:38.760]  У указателя вы не можете спросить,
[19:38.760 --> 19:40.760]  а какого размера данные ты указываешь.
[19:40.760 --> 19:42.760]  То есть вам нужно обязательно хранить некоторую отдельную переменду.
[19:42.760 --> 19:45.760]  Во-вторых, для cstyle вам нужно обязательно помнить о том,
[19:45.760 --> 19:47.760]  что нужно вызвать для него delete.
[19:47.760 --> 19:49.760]  Для std vector, естественно, этого не нужно.
[19:49.760 --> 19:51.760]  Потому что у std vector есть деструктор,
[19:51.760 --> 19:53.760]  который эту память вовремя очистит.
[19:53.760 --> 19:56.760]  Ну и плюс вот этот cstyle массив,
[19:56.760 --> 19:58.760]  он не умеет самостоятельно расширяться.
[19:58.760 --> 19:59.760]  То есть если в какой-то момент вы поняли,
[19:59.760 --> 20:01.760]  что вам n элементов недостаточно,
[20:01.760 --> 20:03.760]  вам придется вручную снова выделить память,
[20:03.760 --> 20:05.760]  потом скопировать все элементы
[20:05.760 --> 20:07.760]  и дальше пользоваться новым массивом.
[20:07.760 --> 20:08.760]  С вектором это не так.
[20:08.760 --> 20:10.760]  С вектором вы можете спокойно добавлять элементы
[20:10.760 --> 20:12.760]  и можете даже не задумываться о том,
[20:12.760 --> 20:14.760]  в какой момент происходит расширение и так далее.
[20:14.760 --> 20:17.760]  Просто вектор подстраивается под нужный вам размер.
[20:17.760 --> 20:19.760]  Ну и забегая вперед,
[20:19.760 --> 20:21.760]  или не забегая вперед, а просто скажу,
[20:21.760 --> 20:24.760]  что расширение, естественно, происходит по мультипликативной схеме,
[20:24.760 --> 20:27.760]  той, которую вы обсуждали в прошлом семестре.
[20:27.760 --> 20:30.760]  Потому что, скажем, вектор имеет изначально размер n.
[20:30.760 --> 20:31.760]  Потом, если ему нужно расшириться,
[20:31.760 --> 20:33.760]  то расширяется до 2n, дальше до 3n и так далее.
[20:33.760 --> 20:34.760]  Для чего это нужно?
[20:34.760 --> 20:38.760]  Это обеспечивает амортизационную константу при добавлении элементов.
[20:38.760 --> 20:40.760]  То есть если вы добавляете не мультипликативно,
[20:40.760 --> 20:41.760]  а, скажем, аддитивно,
[20:41.760 --> 20:45.760]  то там уже возникает квадратичная сложность от числа элементов.
[20:49.760 --> 20:50.760]  Как можно создать вектор?
[20:50.760 --> 20:52.760]  Вектор можно создать многими разными способами,
[20:52.760 --> 20:54.760]  и некоторые из них перечислены здесь.
[20:54.760 --> 20:56.760]  Ну, самые основные, наверное.
[20:56.760 --> 20:59.760]  Во-первых, можно создать пустой вектор или пустой массив.
[20:59.760 --> 21:02.760]  Пустой массив просто эквалентен нулевому указателю или nullptr.
[21:02.760 --> 21:05.760]  То есть у него нулевой размер, он ничего не хранит.
[21:05.760 --> 21:07.760]  Ну, в общем, банальный пустой массив.
[21:07.760 --> 21:09.760]  Если вы хотите создать массив из n элементов,
[21:09.760 --> 21:13.760]  и при этом каждый из этих элементов прорендеризировать по умолчанию,
[21:13.760 --> 21:15.760]  вы можете воспользоваться вот таким конструктором.
[21:15.760 --> 21:17.760]  То есть передать просто количество элементов.
[21:17.760 --> 21:21.760]  В этот момент создастся вектор в куче,
[21:21.760 --> 21:23.760]  выделен для n элементов.
[21:23.760 --> 21:27.760]  И каждый из этих элементов будет создан с помощью дефолтного конструктора.
[21:27.760 --> 21:29.760]  Если вы хотите все эти элементы заполнить не дефолтным образом,
[21:29.760 --> 21:30.760]  а к каким-то определенным значениям,
[21:30.760 --> 21:32.760]  вы можете воспользоваться вот такой формой конструктора.
[21:32.760 --> 21:35.760]  То есть передать размер и передать значение,
[21:35.760 --> 21:39.760]  которым нужно заполнить все элементы вектора.
[21:39.760 --> 21:42.760]  Дальше есть списочная инициализация массива.
[21:42.760 --> 21:44.760]  То есть если вы хотите заполнить его конкретными значениями,
[21:44.760 --> 21:46.760]  вы можете их написать в фигурных скопках.
[21:46.760 --> 21:50.760]  В данном случае вектор D является массивом из трех элементов,
[21:50.760 --> 21:53.760]  который заполнен значениями 1, 2, 3.
[21:54.760 --> 21:58.760]  Ну и естественно для векторов существуют операции копирования,
[21:58.760 --> 22:01.760]  конструктор копирования, которые работают напрямую.
[22:01.760 --> 22:03.760]  Ну и существует конструктор перемещения,
[22:03.760 --> 22:05.760]  который перемещает содержимое за ход единицы.
[22:05.760 --> 22:08.760]  Ну понятно, почему перемещение работает за ход единицы,
[22:08.760 --> 22:11.760]  потому что перемещение это, по сути, просто,
[22:11.760 --> 22:13.760]  ну мы это с вами обсуждали...
[22:13.760 --> 22:17.760]  Просто достаточно просто взять и украсть указатель
[22:17.760 --> 22:19.760]  у того объекта, который мы перемещаем.
[22:19.760 --> 22:22.760]  То есть перемещение указателя или просто присваивание указатель
[22:22.760 --> 22:24.760]  Константное время.
[22:28.760 --> 22:34.760]  У вектора есть те же самые операции для доступа к элементам, которые мы обсуждали до этого.
[22:34.760 --> 22:37.760]  Это методы квадратной скобки, add, front, back, data.
[22:37.760 --> 22:40.760]  То есть тут все то же самое, что мы говорили про std array.
[22:40.760 --> 22:42.760]  Также есть методы empty и size.
[22:42.760 --> 22:45.760]  empty возвращает, если у вас в векторе на самом деле ничего не хранится.
[22:45.760 --> 22:47.760]  Если что-то хранится, то он возвращает true.
[22:47.760 --> 22:53.760]  Также есть метод fill, который заполняет все элементы вектора определенным значением.
[22:53.760 --> 22:56.760]  И есть метод swap, который теперь уже работает за от единицы.
[22:56.760 --> 23:00.760]  И за от единицы он работает по тем же самым причинам, почему у вас перемещение работ за от единицы.
[23:00.760 --> 23:06.760]  То есть теперь вы можете спокойно просто обменять указатели вектора и на этом все.
[23:06.760 --> 23:10.760]  На этом обмен содержимым вектора заканчивается.
[23:10.760 --> 23:16.280]  копировать, точнее копировать содержимые векторов целиком, вам достаточно просто обменять указатели.
[23:16.280 --> 23:27.800]  Теперь, вот все, что мы обсуждали до этого, это то, чем вектор похож на STD array.
[23:27.800 --> 23:32.480]  Как я сказал, в отличие от STD array, STD вектор умеет динамически расширяться, он умеет добавлять
[23:32.480 --> 23:37.760]  внутри себя элементы или удалять элементы. Основными методами вставки удаления являются
[23:37.760 --> 23:42.840]  методы pushback и popback. То есть, если вы хотите добавить элемент в конец вектора, то вы используете pushback,
[23:42.840 --> 23:48.560]  если вы хотите удалить элемент с конца из вектора, то вы используете popback. И pushback и popback
[23:48.560 --> 23:51.920]  работают за единицу. При этом pushback работает амортизированно за единицу,
[23:51.920 --> 23:57.600]  popback работает за единицу в худшем случае. Чтобы сделать popback, вам достаточно просто удалить
[23:57.600 --> 24:03.040]  элемент с конца, то есть, двинуть size, удалить элементы и так далее. Если вы хотите вставить
[24:03.040 --> 24:08.240]  элемент в середину или в начало, или, скажем, удалить элемент из середины из начала, то тут вам
[24:08.240 --> 24:13.760]  помогут методы insert и erase. Значит, insert и erase принимают довольно интересные вещи, про которые мы
[24:13.760 --> 24:18.880]  поговорим на второй части лекции, но, забегая вперед, скажу, что в качестве первого аргумента
[24:18.880 --> 24:27.360]  insert принимает итератор или просто некоторую, так скажем, позицию, куда нужно вставить элемент.
[24:27.360 --> 24:31.800]  В данном случае я сказал, что я хочу вставить элемент в первую позицию, то есть, я говорю, что я
[24:31.800 --> 24:35.880]  беру начало вектора и сдвигаюсь на одну единицу вправо. То есть, в данном случае я говорю, что я
[24:35.880 --> 24:40.040]  должен осуществить ставку на первую позицию моего вектора. Ну и в данном случае действительно я вижу,
[24:40.040 --> 24:47.280]  что у меня был вектор 1, 2, 3, и в первую позицию у меня оказался элемент 0. Значит, здесь я сказал
[24:47.280 --> 24:52.360]  следующую вещь. Да, есть insert, который принимает три аргумента, здесь я сказал следующее. Я хочу
[24:52.360 --> 24:57.600]  в третью позицию вектора, то есть, вектор позиции номер 3, то есть, которая от начала расположена на
[24:57.600 --> 25:03.920]  три шага вправо, я хочу там расположить 2 минус единицы. В этом случае у меня вот, начиная со
[25:03.920 --> 25:10.480]  второй позиции, точнее, начиная с третьей позиции, 0, 1, 2, 3, третья позиция, там расположились 2 минус
[25:10.480 --> 25:15.840]  единицы. Ну и при этом, естественно, как вы понимаете, это все работает за линейное время в худшем
[25:15.840 --> 25:20.120]  случае. Ну почему? Потому что как вставить элемент в середину массива? То есть, ну, это не список,
[25:20.120 --> 25:25.160]  там нельзя просто провязать указатели. Нужно, во-первых, сдвинуть элементы вправо, то есть,
[25:25.160 --> 25:28.600]  освободить место для новых элементов и только потом вставить. Ну, собственно, вот этот сдвиг,
[25:28.600 --> 25:34.520]  он занимает линейное время. Ну и аналогично с Erase, Erase тоже принимает указатель или итератор на
[25:34.520 --> 25:38.880]  позицию, из которой нужно удалить элемент. В данном случае, я говорю, что я из первой позиции хочу
[25:38.880 --> 25:44.440]  удалить элемент, то есть, выбегин плюс 1, и в итоге у меня из вектора удалился 0, который находился в
[25:44.440 --> 25:49.000]  первой позиции. Дальше я говорю, что, дальше вторая форма Erase, я говорю, что мне нужно удалить все
[25:49.000 --> 25:54.200]  элементы со второго по четвертой, то есть, начиная со второго по четвертой, я хочу удалить там все
[25:54.200 --> 26:00.800]  элементы. Ну, при этом, как и любой другой алгоритм, здесь имеется в виду полуоткрытый интервал, то
[26:00.800 --> 26:06.280]  есть, начало включительно, конец не включительно. Ну, то есть, полуоткрытый интервал. Соответственно,
[26:06.280 --> 26:10.640]  второй элемент это минус единица, четвертый элемент это тройка. Ну, по тройку не включительно,
[26:10.640 --> 26:17.960]  я удалил все минус единицы и в итоге вернулся в исходное состояние 1, 2, 3. Есть вопросы тут?
[26:17.960 --> 26:32.800]  Хорошо. Еще один способ вставить или удалить элементы, это использовать методы Resize и Clear.
[26:32.800 --> 26:39.240]  Ну скажем, если вы хотите принудительно увеличить размер вектора на какое-то число, ну или вставить
[26:39.240 --> 26:44.520]  сразу несколько элементов в конец вектора, вы можете воспользоваться Resize. Значит, вот пример
[26:44.520 --> 26:50.760]  такой. У меня есть вектор, изначально у него размер два элемента. Я делаю Resize 4, и он
[26:50.760 --> 26:57.000]  увеличивает свой размер до четырех. Так как я использую int, то, собственно, вот эти дополнительные
[26:57.000 --> 27:00.800]  два элемента, которые у меня были добавлены в конец, они проинциализированы мусором. То есть,
[27:00.800 --> 27:06.640]  там пока ничего не хранится, ну, то есть, просто неинциализированная память. Дальше я могу
[27:06.640 --> 27:12.040]  воспользоваться другой формой Resize, то есть, передать размер, до которого я хочу увеличить свой
[27:12.040 --> 27:16.880]  массив, и передать ему дополнительный параметр value, то есть, какими значениями я хочу заполнить.
[27:16.880 --> 27:20.520]  То есть, если в первой форме я сказал, что мне не важно, чем ты там заполнишь, то есть, он
[27:20.520 --> 27:24.560]  заполнит это все по умолчанию. Ну, то есть, для базовых типов ничего не сделает, для примитивных
[27:24.560 --> 27:29.280]  типов ничего не сделает, а для типов классов он вызовет конструктора по умолчанию. Здесь я же
[27:29.280 --> 27:33.320]  говорю, что дополнительные элементы я хочу заполнить значением минус один. Ну и, действительно,
[27:33.320 --> 27:38.520]  у меня размер увеличился на единицу, то есть, до пяти, и все дополнительные значения заполнились
[27:38.520 --> 27:43.560]  минус единицей. Ну и также, в любой момент, я могу уменьшить размер вектора, сказать Resize2,
[27:43.560 --> 27:48.040]  то есть, уменьшить размер до двух. Все. То есть, в итоге у меня осталось два элемента, а все остальные
[27:48.040 --> 27:54.320]  элементы, они забылись, то есть, их теперь в моем векторе, по сути, нет. Вот. Ну и есть метод Clear,
[27:54.320 --> 27:58.160]  который позволяет очистить содержимое вектора. То есть, если у меня был вектор из двух элементов,
[27:58.160 --> 28:05.240]  то я вызвал Clear. В общем, теперь, после этого, размер вектора стал равным нулю. Ну здесь, как бы,
[28:05.240 --> 28:14.440]  кажется, что методы сами говорят сами за себя, тут должно быть понятно. Вот. Ну и теперь нужно
[28:14.440 --> 28:18.160]  чуть подробнее остановиться, ну, на самом деле, даже не чуть, а достаточно подробно остановиться на том,
[28:18.160 --> 28:23.560]  как устроен вектор, что он, на самом деле, хранит и так далее. Вот. Все это время мы говорили про такую
[28:23.560 --> 28:28.440]  характеристику как Size, то есть, про размер вектора. Так вот, под Size или под размером вектора
[28:28.440 --> 28:34.800]  поюнимается реально хранимое количество реально хранимые объекты в векторе. То есть, если у вас Size
[28:34.800 --> 28:39.640]  равен 4, то это значит, что реально в векторе хранится 4 элемента. Ну, помимо характеристики Size или
[28:39.640 --> 28:45.400]  размер, у вектора есть такая характеристика как Capacity или вместимость вектора. Ну, для чего она
[28:45.400 --> 28:50.280]  нужна? Ну, я думаю, вы понимаете, что если вы будете, ну, скажем, вот, постоянно поддерживать Size,
[28:50.280 --> 28:54.720]  нужного вам размера, скажем, вот, у вас 4 объекта, вот, и вам нужно вставить там два элемента
[28:54.720 --> 28:59.680]  дополнительно. Ну, чтобы вставить два элемента, вам нужно выделить массив большего размера, и вот вы его
[28:59.680 --> 29:05.960]  выделяете на два больше. В какой-то момент вам нужно вставить еще один элемент. Вы берете там,
[29:05.960 --> 29:09.800]  перевыделяете память и вставляете вот этот дополнительный элемент. Ну, как вы понимаете,
[29:09.800 --> 29:17.080]  это неэффективно. Почему? Ну, потому что на каждую вставку вам, по сути, нужно скопировать
[29:17.080 --> 29:23.880]  весь предыдущий вектор целиком. Вот. Поэтому вектор, как правило, хранит памяти больше, чем вам
[29:23.880 --> 29:28.680]  нужно. Ну, с этой техникой вы уже с прошлого семестра знакомы, да, это вот как раз таки динамический
[29:28.680 --> 29:33.400]  массив. То есть, чтобы вставка осуществлялась быстро, амортизирована за единицу, вы, как бы,
[29:33.400 --> 29:37.200]  выделяете всегда чуть больше, чем вам нужно. Ну, в частности, там, как правило, в два раза больше,
[29:37.200 --> 29:42.160]  чем вам нужно. И тогда вот вставка дополнительных элементов будет осуществляться довольно быстро.
[29:42.160 --> 29:48.560]  И количество реаллокации, количество перевыделения памяти будет довольно редким. Вот. Ну, и будет
[29:48.560 --> 29:53.480]  казаться, что вы работаете всегда, ну, то есть, что суммарно вы работаете за линейное время.
[29:53.480 --> 29:59.600]  Ну, и в связи с этим у вектора есть две характеристики. Есть характеристика size и есть
[29:59.600 --> 30:04.120]  характеристика capacity. Size говорит о том, сколько элементов у вас реально задействовано в векторе,
[30:04.120 --> 30:09.200]  а capacity говорит о том, сколько элементов ваш вектор может вместить без реаллокации. То есть,
[30:09.200 --> 30:13.640]  если вы заполнили capacity элементов и даже вставляете еще один, то у вас происходит реаллокация,
[30:13.640 --> 30:18.000]  то есть выделяется массив большего размера. Вот. Если у вас размер меньше, чем capacity,
[30:18.000 --> 30:21.080]  то вы сможете спокойно вставлять туда дополнительные элементы без реаллокации.
[30:21.080 --> 30:32.560]  Ну, вот здесь у меня есть небольшая демка. Давайте ее посмотрим. Давайте так. Видно, да?
[30:32.560 --> 30:46.400]  Да. Так, вот. Ну, просто небольшая демонстрация. У меня есть вектор,
[30:46.400 --> 30:52.520]  и есть функция, которая просто принимает вектор и выводит его размер, и выводит его capacity,
[30:52.520 --> 30:56.000]  то есть выводит его размер и выводит его вместимость. Ну, и дальше я просто в цикле
[30:56.000 --> 31:05.200]  последовательно добавляю элементы и вывожу размер и вместимость вектора. Вот. Ну,
[31:05.200 --> 31:20.760]  и давайте посмотрим, как это работает, что будет выведено на экран. Ну, вот. Собственно,
[31:20.760 --> 31:26.160]  я добавляю 8 элементов, и что я вижу? Изначально у меня вектор хранит 0 элементов, естественно,
[31:26.160 --> 31:31.120]  и его вместимость равна 0, то есть никакого буфера, никакого массива внутри себя не хранит. Я добавил
[31:31.120 --> 31:34.880]  один элемент, size стало равным единице, вместимость стала равной единицей. Я добавил
[31:34.880 --> 31:38.680]  второй элемент, у меня произошло перевыделение памяти, то есть вектор увеличился в два раза.
[31:38.680 --> 31:44.040]  То есть и в первом случае, и в втором случае произошло перевыделение. Теперь дальше я добавляю
[31:44.040 --> 31:48.080]  третий элемент, старой вместимости мне не хватало, поэтому мне пришлось перевыделить массив,
[31:48.080 --> 31:52.440]  и я выделяю массив большего размера. Теперь он стал равным 4. Я добавляю четвертый элемент,
[31:52.440 --> 31:56.360]  size стал равным 4, но при этом capacity не изменился. То есть я добавил элемент, ну,
[31:56.360 --> 32:00.800]  старый массив, который у меня был выделен до этого. Я добавляю пятый элемент, вместимости не
[32:00.800 --> 32:05.760]  хватает, поэтому я увеличиваю вместимость в два раза. Следующие элементы 6, 7, 8 я могу
[32:05.760 --> 32:11.640]  вставлять спокойно без перевыделения памяти и без лишних копирований. Вот классическая схема
[32:11.640 --> 32:20.640]  увеличения динамического массива, которая в частности реализована в библиотеке GCC.
[32:20.640 --> 32:30.240]  Как управлять размером? Мы разобрались, мы до этого обсуждали, что есть всякие
[32:30.240 --> 32:35.120]  пушбэки, есть попбэки, есть ресайзы, есть инсерт и так далее. Возникает вопрос, а можно ли
[32:35.120 --> 32:38.800]  управлять самим хранилищем? То есть можно ли управлять непосредственно вот вместимостью
[32:38.800 --> 32:44.320]  вектора? То есть скажем, у меня размер вектора равен 4, а я, допустим, понимаю, что мне нужно
[32:44.320 --> 32:48.840]  дополнительно будет вставить еще 100 элементов. И как бы зачем мне выполнять много реалокаций,
[32:48.840 --> 32:52.800]  если я могу там, скажем, заранее выделить память для хранения 100 элементов? Могу ли я так сделать?
[32:52.800 --> 32:58.080]  Ответ – да, можете. И это на самом деле довольно часто используется. Ну, например, у вас есть вектор из
[32:58.080 --> 33:04.080]  5 элементов. И, собственно, если вы создали вектор из 5 элементов, то у вас size вектор равен 5,
[33:04.080 --> 33:08.120]  а capacity больше либо равен 5. То есть по стандарту вам гарантировано, что, естественно, у вас
[33:08.120 --> 33:14.640]  вместимость больше либо равна, чем то количество элементов, которые вы храните. И, допустим,
[33:14.640 --> 33:21.040]  в какой-то момент вы понимаете, что вам понадобится 10 элементов. Вы можете вручную, не отдавая
[33:21.040 --> 33:26.360]  всю налодку вектор, вы можете вручную выделить память нужного размера. Для этого вызываете
[33:26.360 --> 33:32.440]  просто v.reserve и нужное количество памяти. Как работает Reserve? Reserve принимает собственное значение,
[33:32.440 --> 33:38.040]  которое вы ему передали, и выделяет столько памяти, сколько было бы достаточно для хранения такого
[33:38.040 --> 33:42.680]  количества элементов. При этом минимум. Он выделяет минимум столько памяти, сколько было бы
[33:42.680 --> 33:48.320]  достаточно для хранения элементов. Ну, например, если вы просили v.reserve10, то вектор, в принципе,
[33:48.320 --> 33:54.120]  может теоретически выделить вам и 20, и 15, но как минимум 10 он вам гарантирует. Ну, как правило,
[33:54.120 --> 33:57.680]  компиляторы, как правило, современные реализации, они всё-таки выделяют ровно столько,
[33:57.680 --> 34:02.680]  сколько вы просили, но по стандарту стандарт-хайлиотека может выделить вам и больше, чем вы
[34:02.680 --> 34:08.240]  попросили. Поэтому после вызова этого резерва у вас size осталось ровно 5, а capacity увеличился минимум
[34:08.240 --> 34:14.120]  до 10. Теперь, что произойдёт, если вы попытаетесь зарезервировать количество памяти меньше, чем
[34:14.120 --> 34:17.880]  у вас реально сейчас есть? В этом случае, на самом деле, по стандарту просто ничего не произойдёт.
[34:17.880 --> 34:22.200]  То есть, если вы попросили, что вектору нужно хранить как минимум два элемента, то есть нужно
[34:22.200 --> 34:26.400]  выделить память для хранения как минимум двух элементов. Ну, а вектор уже содержит у вас 10
[34:26.400 --> 34:30.880]  элементов, поэтому он ничего делать не будет, он просто, ну, посмотрит, сравнит то, что вы попросили
[34:30.880 --> 34:34.880]  с тем, что у него реально есть, поймёт, что до того количества памяти, которое вы просили, уже
[34:34.880 --> 34:40.520]  достаточно, вот, и ничего не произойдёт. То есть, уменьшение capacity не произойдёт. Таким образом,
[34:40.520 --> 34:45.760]  уменьшить вместимость у вас не получится. А с помощью чего можно уменьшить вместимость? С помощью
[34:45.760 --> 34:52.080]  метода, который называется shrink-to-fit. Вот метод shrink-to-fit уменьшает capacity до size. Ну,
[34:52.080 --> 34:56.560]  как это работает? Вот, допустим, вы создали вектор из тысячи элементов, вот как-то с ним поработали,
[34:56.560 --> 35:00.200]  и даже в какой-то момент поняли, что, ну, всё, остальных тысячи элементов вам не достаточно,
[35:00.200 --> 35:04.760]  вам теперь достаточно работать с первым десятью или только с первым элементом. Вот, вы делаете
[35:04.760 --> 35:08.440]  resize, и таким образом говорите, что теперь у вас размер вектора равен единице, то есть вы имеете
[35:08.440 --> 35:14.280]  право использовать только первый элемент, но при этом resize, он не влияет на вместимость. То есть,
[35:14.280 --> 35:17.760]  у вас вместимость как была тысяча, так и осталась. Ну, и как-то возникает не очень
[35:17.760 --> 35:21.520]  приятная ситуация, что вы пользуетесь реально одним объектом, а в память у вас, ну, собственно,
[35:21.520 --> 35:26.000]  в память у вас выделено для тысячи объектов. Так вот, чтобы этого избежать, вы можете взять и
[35:26.000 --> 35:32.760]  принудительно уменьшить capacity или вместимость вектора до размера с помощью метода shrink-to-fit. Вот,
[35:32.760 --> 35:38.040]  когда вы вызвали shrink-to-fit, у вас capacity принудительно уменьшился до реального количества
[35:38.040 --> 35:43.280]  элементов. Вот. Ну, и более того, shrink-to-fit — это, вообще говоря, единственный метод, который может
[35:43.280 --> 35:47.920]  уменьшить capacity. Все остальные методы типа resize и reserve уменьшить capacity не могут. Могут
[35:47.920 --> 35:53.240]  только увеличить. Поэтому, если вы в какой-то момент понимаете, что в памяти у вас вектор жирет
[35:53.240 --> 35:57.880]  слишком много, ну, по сравнению с тем, сколько вам реально нужно, вы можете вызвать метод shrink-to-fit.
[35:57.880 --> 36:05.360]  Вот. Так, ну, перерывы мы будем делать. До перерыва осталось три минуты. Вот, давайте до перерыва
[36:05.360 --> 36:12.280]  попробуем разобраться с некоторыми проблемами или с некоторыми загадками C++, которые в связи с
[36:12.280 --> 36:23.000]  этим возникают. Ну, вот, смотрите. Да. Ну, смотрите. Допустим, у меня есть вектор, который хранит другие
[36:23.000 --> 36:27.280]  вектора. Вектор векторов. Ну, или, на самом деле, вектор, который хранит любые другие тяжелые объекты.
[36:27.280 --> 36:31.240]  Ну, вектор — это все-таки достаточно тяжелый объект, если он хранит много элементов. Но в данном случае
[36:31.240 --> 36:37.640]  я задаю вектор, который хранит 100 других векторов, каждый из которых имеет размер миллион. То есть,
[36:37.640 --> 36:47.000]  по сути, двумерный массив. Здесь 100 элементов. И каждый из них хранит вектор, который хранит
[36:47.000 --> 36:53.840]  10 шестой элементов. Ну, и в какой-либо момент вы поняли, что там все 100 векторов размера миллион
[36:53.840 --> 36:59.040]  вам не нужно, вам нужно только первые 10. То есть, вы делаете resize до 10, но в итоге у вас
[36:59.040 --> 37:06.120]  capacity остался равным сотня. Или хуже того, вы понимаете, что вектор вам больше не нужен,
[37:06.120 --> 37:12.760]  вам такой вектор не нужен, вы делаете clear. То есть, его очищаете. И тут возникает вопрос, а что
[37:12.760 --> 37:18.800]  произойдет с этими векторами? Ну, то есть, если вы реализовывали свой string в первом задании, то,
[37:18.800 --> 37:25.760]  ну, давайте так, я спрошу кого-нибудь. Кто реализовал string? Как был устроен resize и как
[37:25.760 --> 37:34.360]  был устроен clear? Что вы делали? В общем, заключается resize до меньшего размера или clear. Да, просто
[37:34.360 --> 37:39.560]  меняли size. Ну, смотрите, тут возникает такой вопрос. Ну, хорошо, если в векторе clear просто меняет
[37:39.560 --> 37:43.920]  size, ну, скажем, clear просто устанавливает size равным нулю, да, resize просто устанавливает size
[37:43.920 --> 37:49.560]  равным 10. Что происходит с памятью? То есть, вы понимаете, что если вы просто изменяете размер, то у
[37:49.560 --> 37:55.960]  вас вот оставшаяся часть, вот, если вы уменьшили размер вот до сих, то вот вся вот эта память, она у вас
[37:55.960 --> 37:59.880]  висит. То есть, она все еще висит в системе, вы как бы эти векторы реально не удалили, да, то есть,
[37:59.880 --> 38:05.720]  они реально есть. И, соответственно, они жрут там вашу память. Ну, как вы понимаете, там 100 векторов
[38:05.720 --> 38:10.560]  по миллиону элементов, это достаточно много. Вот, есть какая-то вопроса, хотим ли мы этого? Хотим ли мы,
[38:10.560 --> 38:15.360]  чтобы действительно при resize до меньшего размера или при clear, да, который просто устанавливает
[38:15.360 --> 38:19.400]  size равным нулю, у нас все эти векторы реально висели в памяти? Ну, или теоретически эти тяжелые
[38:19.400 --> 38:28.200]  объекты висели в памяти? Ну, скорее всего, нет. Другая проблема. У меня есть вектор, и я делаю
[38:28.200 --> 38:36.520]  reserve 100, и этот вектор хранит элементы типа A. Что делает reserve? Ну, как мы сейчас понимаем,
[38:36.520 --> 38:43.720]  reserve, скорее всего, он выделяет память, да, то есть, он вызывает что-то типа new A 100, ну, и сохраняет в буфер.
[38:43.720 --> 38:51.840]  То есть, на текущем уровне понимания мы думаем, что он выступает вот таким образом. Но это
[38:51.840 --> 38:57.440]  неизбежно приводит к проблеме. Смотрите, что делает new? Ну, new с квадратными скобками. Он выделяет
[38:57.520 --> 39:04.280]  память и вызывает конструкторы, да, то есть мы знаем, что new — когда вы вызываете new, он выделяет память,
[39:04.280 --> 39:08.840]  и плюс вызывает конструкторы для каждого объекта, которые вы создали. Вопрос. Значит,
[39:08.840 --> 39:15.000]  какой конструктор тут будет вызван? Ну, так как это массив, так как это new с квадратными скобками,
[39:15.000 --> 39:19.480]  каждый элемент этого массива будет создан с помощью конструктора по умолчанию. Ну, или компилятор
[39:19.480 --> 39:24.640]  попытается все создать с помощью конструктора по умолчанию. Ну, а что если у объекта A нет
[39:24.640 --> 39:30.480]  конструктора по умолчанию в принципе. То есть получается, что вы, то есть смотрите, с одной
[39:30.480 --> 39:34.800]  стороны, с точки зрения логики, с точки зрения логики вы в векторе еще не храните ни одного объекта a.
[39:34.800 --> 39:39.880]  То есть у вас size равен нулю. То есть формально вы сказали, что вектор a ничего не хранит, я просто
[39:39.880 --> 39:45.720]  зарезервировал память под 100 элементов. Но реально при такой реализации у вас возникнет ошибка
[39:45.720 --> 39:50.120]  компиляции, на том, что компилятор скажет, что у объекта a нет конструктора по умолчанию,
[39:50.120 --> 39:55.280]  ну а вы как бы никаких конструкторов вроде как сами не вызывали. То есть получается, что при такой
[39:55.280 --> 40:00.160]  реализации у вас вектор не может хранить и не имеет права хранить элементы, у которых нет конструктора
[40:00.160 --> 40:05.040]  по умолчанию. Ну это довольно сильное ограничение на самом деле. Ну мало ли почему вы не хотите
[40:05.040 --> 40:14.280]  использовать конструктор по умолчанию. Беда. Более того, давайте вот пару слайдов закончим,
[40:14.280 --> 40:21.200]  мы и на перерыв пойдем. С этим возникает еще три вопроса. Первый. За сколько работает метод clear?
[40:21.200 --> 40:26.640]  Ну вот как мы с вами обсудили, при реализации стринга достаточно было просто взять и выставить size
[40:26.640 --> 40:32.800]  равным нулю. Казалось бы, метод clear работает за ездицу. То есть выставить size равным нулю
[40:32.800 --> 40:37.800]  это довольно быстро. Следующий вопрос. Сколько работает resize при уменьшении размера? Ну тоже,
[40:37.800 --> 40:44.880]  кажется, что понятно, что если у вас был какой-то size до этого s и вы уменьшили размер до s-стрих,
[40:44.880 --> 40:54.240]  то достаточно просто сделать size равно new size и все. То есть это тоже занимает от единицы.
[40:54.240 --> 41:00.160]  Скорее всего от единицы, скорее всего от единицы. Ну и сколько работает метод reserve при
[41:00.160 --> 41:04.960]  увеличении вместимости? Ну тут кажется, все работает так. Значит у вас была память, скажем, n,
[41:04.960 --> 41:11.920]  вы увеличили до n-стрих. Ну n это вместимость, ну давайте c. c вместимости, тут c-стрих
[41:11.920 --> 41:17.920]  вместимость. Что делает reserve при увеличении памяти? Ну он вызывает new для c-стрих элементов,
[41:17.920 --> 41:22.680]  и для каждого из этих c-стрих элементов вызывается конструктор по умолчанию. Поэтому, ну кажется,
[41:22.680 --> 41:28.000]  что он работает за c-стрих плюс c. Ну потому что старые c-элементов нужно скопировать новый
[41:28.000 --> 41:35.960]  буфер. Давайте посмотрим на то, как устроена реальность. Сейчас давайте просто-напросто
[41:35.960 --> 41:44.760]  заглянем в справку по вектору и узнаем сколько реально работают все эти методы.
[41:44.760 --> 42:06.360]  Нам нужны reserve, clear и resize. Ну например, посмотрим на clear. Мы думаем, ну наше понимание устроено
[42:06.360 --> 42:10.880]  так, что clear работает за единицу, потому что он просто уменьшает размер до единицы.
[42:10.880 --> 42:14.880]  Но если мы посмотрим вратил complexity, то мы видим, что оказывается clear работает за
[42:14.880 --> 42:19.360]  линейное время от размера контейнера внезапно. То есть внезапно он выполняет какую-то работу,
[42:19.360 --> 42:24.840]  которая требует ему линейных затрат памяти, линейных затрат по времени для линейных от
[42:24.840 --> 42:33.280]  размера контейнера время. Затрат по времени. Странно. Окей, смотрим дальше. Значит есть метод
[42:33.280 --> 42:47.920]  reserve. И тут внезапно написано, что reserve работает максимум за size от размера контейнера. То есть
[42:47.920 --> 42:51.480]  у вас есть контейнер, у него size. Вы увеличивали вместимость. И казалось бы, что нужно сделать?
[42:51.480 --> 42:57.040]  Нужно создать этот массив новый, то есть потратить как минимум capacity времени и плюс скопировать все
[42:57.040 --> 43:00.320]  старые элементы в новый вектор. То есть как минимум capacity времени вам, наверное, нужно было
[43:00.320 --> 43:07.240]  потратить. Но при этом как бы справка утверждает, что он работает максимум за size, а не за capacity.
[43:07.240 --> 43:14.440]  Ну окей, давайте посмотрим на resize. Что мы ожидаем от resize? От resize мы ожидаем, что если он будет
[43:14.440 --> 43:20.080]  уменьшать свой размер, то он будет работать, скажем, за единицу. Потому что мы уменьшаем размер,
[43:20.080 --> 43:24.320]  достаточно просто изменить size на новый size и все. Но при этом, если мы посмотрим на complexity,
[43:24.320 --> 43:31.600]  то увидим, что он всегда работает за линейное время от разницы между начальным size и конечным
[43:31.600 --> 43:38.760]  size. То есть даже если вы уменьшаете размер вектора, даже если вы уменьшаете размер вектора вот здесь,
[43:38.760 --> 43:45.440]  с s большого до s-трих, который меньше, чем s большое, вы все равно тратите какое-то время,
[43:45.440 --> 43:58.040]  которое пропорционально вот этой самой разнице. Вот. Беда. Ну и вот, собственно, с тем,
[43:58.040 --> 44:02.440]  почему это работает именно так и почему это должно работать так, мы разберемся после перерыва.
[44:02.440 --> 44:08.960]  Ну и, собственно, давайте перейдем к объяснению того, почему это работает именно так и как,
[44:08.960 --> 44:16.320]  вообще, это работает. Ну, снова, наверное, демонстрация.
[44:16.320 --> 44:29.560]  Значит, демонстрация выглядит следующим образом. Вот у меня есть некоторая структура s,
[44:29.560 --> 44:35.040]  которая просто в какой-то момент говорит, если мы ее создали с помощью default-конструирования,
[44:35.040 --> 44:39.080]  мы говорим, что создался объект этого типа. Ну и в случае вызова деструктора,
[44:39.080 --> 44:48.080]  эта структура пишет, что она была разрушена. Вот. Ну и дальше я создаю вектор из этих объектов,
[44:48.080 --> 44:59.280]  ну из объектов типа s и вывожу на экран, что я с этим всем делаю. В частности, я сначала
[44:59.280 --> 45:05.160]  вызываю резерв, то есть я резервирую место для 100 элементов типа s. Вот. Дальше вызываю resize,
[45:05.160 --> 45:10.400]  то есть увеличиваю размер моего вектора до 5, потом, говорю, делаю resize до 2, то есть уменьшаю
[45:10.400 --> 45:15.840]  размер моего вектора до 2. Ну и дальше вызываю clear, то есть полностью очищаю мой вектор. Давайте
[45:15.840 --> 45:21.560]  посмотрим, что на это будет говорить s. Ну да, что будет на это говорить s, то есть в какой момент
[45:21.560 --> 45:37.520]  какие конструкторы у меня вызываются. Вот. Для этого соберем этот код и запустим. И что мы видим?
[45:37.520 --> 45:43.720]  Смотрите, сначала у меня вызывается резерв 100, то есть в программе у меня вызывается резерв 100
[45:43.720 --> 45:48.960]  для вектора, я резервирую место для хранения 100 элементов массива. Вот. При этом, заметьте,
[45:49.560 --> 45:54.640]  что ни одного конструктора реально у меня вызвано не было. То есть реально ни одного вызова
[45:54.640 --> 46:00.840]  дефолтного конструктора у меня не было. То есть вектор сказал «хорошо, я выделил память,
[46:00.840 --> 46:07.480]  но при этом вроде как ничего не произошло». Окей. Когда я сделал resize 5, вот в этот момент у меня
[46:07.480 --> 46:13.000]  создалось 5 элементов. То есть когда я реально попросил, чтобы у меня размер вектора увеличился,
[46:13.000 --> 46:18.180]  то есть изначально размер вектора был 0, я сказал увеличить его до 5. И вот именно в этот момент
[46:18.180 --> 46:23.660]  у меня появились новые 5 элементов, вот как следует из вывода программы. Дальше интереснее,
[46:23.660 --> 46:29.700]  я вызываю resize2, то есть я говорю, нужно уменьшить размер вектора с 5 до 2, ну казалось бы, да, то есть
[46:29.700 --> 46:34.260]  мы обсуждали до этого, казалось бы, достаточно просто сказать size равен 2 и все. Но мы видим, что в
[46:34.260 --> 46:41.060]  этот момент вызвалось 3 деструктора, то есть вот эти лишние 3 элементы реально были уничтожены,
[46:41.060 --> 46:45.940]  то есть они там не то что как бы просто лежат в памяти или как-то охранят, они были реально
[46:45.940 --> 46:50.900]  уничтожены, то есть для них был вызван деструктор. Ну и после того, как я вызвал clear, у меня
[46:50.900 --> 46:59.260]  уничтожились оставшиеся два объекта. И это на самом деле не приводит нас к пониманию, как это устроено,
[46:59.260 --> 47:04.540]  да, и почему это работает именно так, но это хотя бы приводит нас к некоторой идее, почему clear
[47:04.540 --> 47:10.740]  работает за линейное время, почему resize работает всегда за, ну минимум, за size-count времени,
[47:10.740 --> 47:17.860]  почему reserve работает за size. Ну понятно, почему clear работает за size, потому что, ну как мы
[47:17.860 --> 47:22.620]  увидели до этого, clear, помимо того, что уменьшает size до нуля, он еще почему-то вызывает деструкторы
[47:22.620 --> 47:28.660]  для всех элементов, которые были заполнены до этого. Плюс resize, когда даже если вы уменьшаете size
[47:28.660 --> 47:36.580]  до какого-то размера, то resize вызывает деструкторы для каждого из лишних элементов. И это наталкивает
[47:36.580 --> 47:42.340]  нас на мысль, что скорее всего, вектор реально не обладает той проблемой, которую мы описали
[47:42.340 --> 47:47.580]  здесь. То есть здесь реально, когда вы вызываете resize, у вас не хранится 100 векторов размера миллион,
[47:47.580 --> 47:52.020]  а для каждого из этих лишних векторов, то есть для каждого из этих лишних 90 векторов, у вас будет
[47:52.020 --> 47:56.500]  вызван деструктор, то есть память будет очищена. И более того, когда вы вызываете clear, у вас size
[47:56.500 --> 47:59.860]  станет равен нулю, и все остальные оставшиеся вектора размера миллион тоже уничтожатся.
[47:59.860 --> 48:08.180]  Значит, понятно идейно, что здесь происходит?
[48:08.180 --> 48:20.820]  Да. Отлично. Теперь осталось разобраться, а как это все устроено. То есть мы же вроде
[48:20.820 --> 48:26.780]  как знаем, что… Смотрите, как мы выделяем память? Память мы выделяем с помощью new. Если мы
[48:26.780 --> 48:32.660]  выделяем с помощью new n элементов, то мы знаем, что первое, выделяется память,
[48:32.660 --> 48:43.940]  и второе, мы все это время говорили, что вызываются n конструкторов. Хотя мы до этого видели, что
[48:43.940 --> 48:48.220]  резерв, который априори должен выделять какую-то память, он никаких конструкторов не вызывал. Как
[48:48.220 --> 48:59.100]  так? Более того, мы знаем, что если мы хотим очистить память, то у нас сначала вызываются
[48:59.100 --> 49:05.140]  деструкторы, а потом память освобождается. Но при этом в то же время мы видели, что у нас
[49:05.140 --> 49:13.100]  элементы уничтожались просто так, сами по себе. То есть память не освобождалась, потому что мы
[49:13.100 --> 49:17.340]  просто уменьшили, а та память, которая была, должна была остаться. То есть мы просто сумели
[49:17.340 --> 49:24.300]  вызвать деструктор без уничтожения памяти как таковой. И, собственно, сейчас пойдет довольно
[49:24.300 --> 49:30.020]  длинный разговор про new, про delete, как это все устроено, и как это вообще в принципе устроено
[49:30.020 --> 49:41.540]  он-директор, как он достигает таких успехов, скажем. Здесь три вопроса. Есть три строчки и вопрос,
[49:41.540 --> 49:48.060]  что делает первая строка. Давайте так. Что происходит, когда вы вызываете new t? Ну, желательно
[49:48.060 --> 49:58.540]  полностью пошагово. Ну, допустим, t это некоторый тип, который имеет там конструктор. Этот тип
[49:58.540 --> 50:05.460]  это некоторый глаз. Как вы себе представляете, что делает new? Он создает под него память в куче и
[50:05.460 --> 50:12.060]  запускает конструктор. Да, отлично. Ну, какой конструктор. По умолчанию. Да, конструктор по
[50:12.060 --> 50:16.460]  умолчанию, действительно. То есть когда мы вызываем new, мы говорим, что нужно выделить
[50:16.460 --> 50:21.920]  элементы в кучи. То есть нужно выделить память достаточно для хранения элемента typeT и вызвать
[50:21.920 --> 50:25.340]  конструктор. В данном случае конструктор по умолчанию. В второй строчке происходит то же самое.
[50:25.340 --> 50:31.020]  Мы тоже выделяем память достаточно для хранения объекта typeT, но уже вызываем конструктор,
[50:31.020 --> 50:35.740]  конкретный конструктор с параметрами x и y. В третьей строчке происходит ровно то же самое,
[50:35.740 --> 50:40.220]  мы выделяем память уже достаточную для хранения n элементов типа t, и каждый из этих элементов мы
[50:40.220 --> 50:48.780]  заполняем по умолчанию. То есть вот все то, что я описал, описано здесь. То есть каждый из этих
[50:48.780 --> 50:54.180]  трех вызовов операции new, он выделяет памяти достаточную для хранения того, что стоит справа.
[50:54.180 --> 51:00.500]  И плюс вызывает какие-то конструкторы. То есть при вызове new неизбежно происходят две вещи.
[51:00.500 --> 51:07.620]  Первое, это выделение памяти, второе вызов конструктора. Когда вы вызываете операцию new,
[51:07.620 --> 51:14.900]  у вас происходят две вещи. Выделение памяти, вызов конструктора. Ну и тут встает резонный вопрос.
[51:14.900 --> 51:20.700]  Ну смотрите, new выполняет по сути две вещи, то есть по сути два действия. А можно ли эти два действия
[51:20.700 --> 51:26.020]  как-то разделить во времени? То есть можно ли как-то, допустим, просто выделить память без создания
[51:26.020 --> 51:31.300]  элемента? То есть просто выделить сырую память, в которой ничего не лежит. Можно ли сделать так? Это
[51:31.300 --> 51:35.700]  первый вопрос. А второй вопрос, а можно ли, вот допустим, у вас откуда-то, ну непонятно откуда, но есть
[51:35.700 --> 51:39.940]  память. Вот вам откуда-то сверху вот спустили, вот у вас есть память, в ней вы можете расположить
[51:39.940 --> 51:44.340]  что угодно. Можете ли вы в этой памяти создать какой-то объект? То есть просто вызвать конструктора
[51:44.340 --> 51:49.260]  и сказать, что вот этот конструктор должен создать элемент здесь. И вот на эти вопросы мы сейчас
[51:49.260 --> 51:58.220]  попытаемся ответить. Значит, ответим на первый вопрос. Как выделить сырую память? Ну тут есть несколько
[51:58.220 --> 52:03.340]  вариантов. Первый вариант — это воспользоваться обычной C-шной функцией malloc. То есть в наследство
[52:03.340 --> 52:09.340]  языка C нам досталась стандартная функция malloc, которая принимает количество байт,
[52:09.340 --> 52:14.340]  которые мне нужно выделить, и возвращает void указатель. Ну количество байт, понятно, это сколько
[52:14.340 --> 52:18.540]  байт, сколько памяти в байтах мне нужно выделить. А почему она возвращает void указатель? Ну потому
[52:18.540 --> 52:22.980]  что как раз-таки она возвращает ту самую сырую память, то есть нетипизированную память. То есть там
[52:22.980 --> 52:29.300]  на самом деле ничего не лежит, это просто вот вам память и делайте с ней что хотите. И при этом нам
[52:29.300 --> 52:33.860]  гарантировано, что malloc не будет вызывать конструкторов никаких. Почему? Ну как минимум потому,
[52:33.860 --> 52:37.940]  что malloc пришел нам EC, а в языке EC никаких конструкторов нет. Ну это во-первых. Ну во-вторых,
[52:37.940 --> 52:43.380]  еще раз повторюсь, malloc возвращает void со свездочкой, но это значит, что там никакого типа
[52:43.380 --> 52:48.180]  реально не содержится. Если вы хотите выделить память достаточно для хранения объекта типа T,
[52:48.180 --> 52:52.900]  вы вызываете sd malloc size of T. Или если вы хотите выделить память достаточно для хранения n
[52:52.900 --> 52:57.940]  элементов типа D, то вы вызываете sd malloc size of T умножить на n. То есть на размер в байтах объекта
[52:57.940 --> 53:03.300]  типа D и умножить на n. Ну и память, выделенную с помощью malloc, нужно освобождать с помощью free.
[53:03.300 --> 53:08.660]  Ну естественно free тоже не вызывает никаких конструкторов, никаких деструкторов. Ну как и malloc
[53:08.660 --> 53:15.480]  не вызывает конструкторов. Но это все как бы, это все C-шный стайл в языке C. Какие у нас есть
[53:15.480 --> 53:23.200]  альтернативы в языке C++? В C++ вы можете сделать следующую вещь. Вы можете выделить массив чаров.
[53:23.200 --> 53:29.320]  Ну почему массив чаров? Ну смотрите, чар в памяти занимает всегда один байт. То есть если вам нужно
[53:29.320 --> 53:34.320]  выделить определенное количество байт, то вы можете воспользоваться new char и в квадратных
[53:34.320 --> 53:41.960]  скобках передать сколько байт вам нужно. Соответственно new char выделит вам массив размера
[53:41.960 --> 53:48.440]  size of t. Ну и так мы хотим сырую память, то есть мы хотим работать с этой памятью сырой, а не как с
[53:48.440 --> 53:53.800]  char-указателем. Мы приводим ее к void-звездочке и сохраняем в single. Но то же самое, если мы хотим
[53:53.800 --> 53:59.920]  выделить память, достаточно для хранения n элементов типа t. Делаем то же самое. То есть
[53:59.920 --> 54:05.920]  выделяем просто нужное нам количество байт. Но у этого подхода есть проблема, которая связана с
[54:05.920 --> 54:11.800]  тем, что память выделенную с помощью new нужно очищать с помощью оператора delete, ну операции
[54:11.800 --> 54:17.600]  delete. А операция delete на вход, точнее в качестве своего параметра, ожидает типизированный указатель. То
[54:17.600 --> 54:24.320]  есть если вы выделяли с помощью new объекты типа char, то удалять вы должны объекты типа char. Ну или скажем так,
[54:24.320 --> 54:40.920]  если вы писали new t, то при вызове delete ptr, вот тип ptr должен быть как раз-таки типом t. Ну
[54:40.920 --> 54:48.680]  или типом t-указатель, ну или он должен быть там, ну короче, если у вас есть наследование, то он
[54:48.680 --> 54:52.680]  должен быть там базовым классом, то он должен быть базовым классом там того объекта, который вы
[54:52.680 --> 54:57.240]  реально выделяли. Ну давайте так, в общем случае, если вы удаляете указатель, то тип этого указателя
[54:57.240 --> 55:02.720]  должен совпадать ровно с тем типом, который вы выделяли с помощью new. Иначе это приводит к undefined
[55:02.720 --> 55:10.160]  behavior. То есть если вы вызываете delete для, скажем, какого-то u-указателя, который даже если он
[55:10.160 --> 55:15.160]  указывает на ту же самую область памяти, то это undefined behavior. То есть если вы выделяли объекты типа t,
[55:15.160 --> 55:20.160]  то и удалять вы должны указатель на t. Поэтому перед тем, как выполнить удаление, мы все приводим
[55:20.160 --> 55:25.600]  обратно к char звездочки. Это неудобно, это проблема. То есть мало того, что нужно помнить, что нужно
[55:25.600 --> 55:29.400]  вызывать delete с кваратными скопками, так еще нужно помнить, что нужно обязательно удалить этот
[55:29.400 --> 55:36.680]  указатель как указатель на char, а не как указатель на void или на какой-то другой объект. Вот. Ну,
[55:36.680 --> 55:42.800]  так или иначе, в C++ есть более правильный способ выделения сырой памяти, ну и более современный
[55:42.800 --> 55:50.480]  по сравнению с C. И это, ну сейчас будет немного шизы, но в общем выделение сырой памяти производится
[55:50.480 --> 55:56.840]  с помощью функции оператор new. Вот. Оператор new — это вот прям функция. То есть в языке C++ есть
[55:56.840 --> 56:03.280]  функция под названием оператор new. И это функция. Да, не путать с операцией new. То есть вот new,
[56:03.280 --> 56:09.520]  который мы вызывали до этого в такой форме, я буду называть операцией. Вот. Это операция new. Если
[56:09.520 --> 56:13.840]  я говорю оператор new, я буду иметь в виду вот конкретно функцию. Ну или иначе вот эту вот штуку я
[56:13.840 --> 56:20.080]  буду называть еще, возможно, иногда выражением new. То есть, да, выражение new. То есть это выражение,
[56:20.080 --> 56:30.760]  ну или expression. Вот. Ну или операция. А это функция оператора new, которая, ну по большому счету,
[56:30.760 --> 56:35.240]  отношения к операции не имеет, но на самом деле, ну в общем, на самом деле имеет, но как бы это две
[56:35.240 --> 56:39.680]  разные сущности. Так вот, возвращаемся. Значит, есть функция оператор new, да, которая так и пишется.
[56:39.680 --> 56:44.520]  Вот два слова. Оператор new. И которая принимает, ну собственно, количество байт, которое нужно
[56:44.520 --> 56:49.240]  выделить. И работает она, по сути, точно так же, как и sttmalloc. То есть тоже выделяет нужное вам
[56:49.240 --> 56:53.400]  количество байт, возвращает void-указатель. Вот если вам нужно выделить память, достаточно для
[56:53.400 --> 56:58.240]  хранения массива, вы вызываете sizeof t умножить на n и передаете это значение в оператор new. И он
[56:58.240 --> 57:03.160]  тоже выделяет вам сырую память. То есть там никаких объектов не задается, возвращается просто void-указатель.
[57:03.160 --> 57:09.560]  Вот. Ну ключевое отличие, наверное, оператор new от sttmalloc заключается в том, что оператор new в
[57:09.560 --> 57:15.120]  случае, если ему не хватает памяти, он бросает исключение sttmalloc. А sttmalloc в случае, если ему не
[57:15.120 --> 57:20.360]  хватает памяти, то он возвращает, ну возвращал просто nullptr. Ну вот это, наверное, самое главное
[57:20.360 --> 57:27.920]  отличие этих двух операций, операторов. Ну и также память выделена с помощью оператора new, с помощью
[57:27.920 --> 57:33.920]  функции оператора new нужно освободить с помощью функции оператор delete. Ну снова, значит, не путать
[57:33.920 --> 57:45.040]  с операцией delete, которая... Вот. Это операция delete, вот, которая приводит к очищению памяти и вызову
[57:45.040 --> 57:49.160]  деструктора. Ну, наоборот, вызову деструктора очищению памяти. А есть функция оператор delete,
[57:49.160 --> 57:57.280]  которая просто очищает память, предварительно выделенную с помощью оператора new. Вот. И теперь
[57:57.280 --> 58:03.240]  становится немного понятнее, как устроена операция new, вот, вот эта штука, и как устроена операция
[58:03.240 --> 58:10.000]  delete. Вот дело в том, что, ну вот мы говорили, что к чему приводит new, как работает new. New обязательно,
[58:10.000 --> 58:17.200]  первое, выделяет память, и второе, new обязательно вызывает конструктор. Так вот, выделение памяти
[58:17.200 --> 58:24.640]  происходит с помощью функции оператора new. То есть new работает в два шага. Первое, это вызов
[58:24.640 --> 58:30.400]  функции оператора new, второе вызов конструктора. И вот с первым шагом мы уже разобрались. То есть мы
[58:30.400 --> 58:37.200]  понимаем, что new в самом начале вызывает оператор new, то есть выделяет просто сырую память. Вот. Как
[58:37.200 --> 58:41.040]  действует delete? Как действует delete? Delete действует следующим образом. Он сначала вызывает деструктор,
[58:41.040 --> 58:47.400]  а потом зовет оператор delete по тому указателю, который вы туда передали. Вот. Собственно,
[58:47.400 --> 58:53.320]  возврат ресурсов в систему осуществляется с помощью функции оператора delete. Пока все ясно.
[58:53.320 --> 59:15.640]  Есть вопросы? Наверное, должны быть. Или все ок. Отлично. Идем дальше. Ну, также существует,
[59:15.640 --> 59:19.200]  помимо функции оператора new и оператора delete, существует функции оператора new с квадратными
[59:19.200 --> 59:25.680]  скопками и оператора delete с квадратными скопками. Они ничем не отличаются от обычных. Единственное
[59:25.680 --> 59:29.760]  отличие заключается в том, что оператор new с квадратными скопками вызывается, когда вы используете
[59:29.760 --> 59:33.000]  оператор new с квадратными скопками, и оператор delete с квадратными скопками вызывается, когда вы
[59:33.000 --> 59:38.160]  используете операцию delete с квадратными скопками. А вообще их внутреннее устройство абсолютно
[59:38.160 --> 59:43.240]  точно такое же. То есть они тоже выделяют количество памяти то, которое попросили. Просто на вход
[59:43.240 --> 59:59.640]  оператора new, в данном случае, на вход оператора new приходит size of t умножить на n. Вот и все. То есть,
[59:59.640 --> 01:00:07.360]  по сути, их реализации ничем не отличаются. Тогда возникает вопрос, зачем нам два оператора,
[01:00:07.360 --> 01:00:10.880]  то есть оператор new с квадратными скопками и оператор new без квадратных скопок, если они
[01:00:10.880 --> 01:00:16.120]  делают, по сути, то же самое. Ну вот это все связано с тем, что есть некоторые детали реализации,
[01:00:16.120 --> 01:00:22.160]  которые есть некоторые детали реализации, которые необходимо поддерживать. Но в частности,
[01:00:22.160 --> 01:00:26.520]  вот давайте посмотрим на последнюю строчку здесь. Когда вы вызываете delete с квадратными скопками,
[01:00:26.520 --> 01:00:33.960]  операции delete нужно каким-то образом понять, сколько деструкторов нужно вызвать. И вот как-то
[01:00:33.960 --> 01:00:39.720]  просто извлечь эту информацию из указателя delete не очень удается. Вот поэтому оператор new с
[01:00:39.720 --> 01:00:44.760]  квадратными скопками он действует немного хитрее. Ну это правда, вот то, что я сейчас рассказываю,
[01:00:44.760 --> 01:00:49.520]  это просто внутреннее устройство конкретного компилятора, например, JCC. Вот JCC делает
[01:00:49.520 --> 01:00:52.760]  следующим образом. Когда вызывается оператор new с квадратными скопками, он, на самом деле,
[01:00:52.760 --> 01:00:55.920]  выделяет не столько памяти, сколько попросили, то есть он реально выделяет не вот столько памяти,
[01:00:55.920 --> 01:01:02.160]  а выделяет столько памяти плюс 8 байт. На что уходит это 8 байт? Эти дополнительные 8 байт он
[01:01:02.160 --> 01:01:06.800]  выделяет для того, чтобы сохранить дополнительную информацию о том, сколько элементов нужно было
[01:01:06.800 --> 01:01:12.560]  создать. В частности, вот это число n, он сохраняет в эту дополнительную ячейку. И delete,
[01:01:12.560 --> 01:01:16.680]  когда вызываете операцию delete, delete просто смотрит в эту ячейку и понимает, ага, там хранится
[01:01:16.680 --> 01:01:24.680]  условно 10 элементов, значит нужно вызвать 10 деструкторов. Ну это просто внутренняя деталь
[01:01:24.680 --> 01:01:29.760]  реализации, которая поддерживается с помощью оператора new с квадратными скопками и оператора delete
[01:01:29.760 --> 01:01:35.560]  с квадратными скопками. Ну здесь тоже есть небольшая демонстрация, давайте тоже на ней, наверное, остановимся.
[01:01:35.560 --> 01:01:47.320]  Как она называется? new delete. Ну вот, значит, у меня есть некоторая структура, у которой есть,
[01:01:47.320 --> 01:01:51.960]  так скажем, нетривиальный деструктор. Ну почему нетривиальный? Потому что если бы деструктур
[01:01:51.960 --> 01:01:56.560]  был тривиальным, то есть как у обычных примитивных типов, то на самом деле вот эта информация о
[01:01:56.560 --> 01:02:00.960]  деструктурах не сохраняется. Вот для того, чтобы компилятор сохранил информацию о деструктуре,
[01:02:00.960 --> 01:02:07.160]  я как бы притворился, что у меня деструктур какой-то особенный, он делает какое-то важное дело.
[01:02:07.160 --> 01:02:16.520]  Ну так или иначе, что я делаю? Я выделяю память для хранения 1213 объектов A, вот, и дальше выполняю
[01:02:16.520 --> 01:02:23.360]  некоторую страшную магию, которую делать нельзя, но я ее делаю просто чтобы показать, как устроен
[01:02:23.360 --> 01:02:26.920]  конкретно мой компилятор. Вообще говоря, это не является нормативным способом, то есть так реально,
[01:02:26.920 --> 01:02:32.320]  в общем случае, делать нельзя. Тут дисклеймер по этому поводу написан. Ну что я делаю? Смотрите,
[01:02:32.320 --> 01:02:40.800]  я беру мой указатель, привожу его к указателю на sizeT и шагаю на один шаг влево. То есть я беру
[01:02:40.800 --> 01:02:47.360]  мой указатель и говорю, что на sizeT шагов, то есть на 8 байт, нужно отойти влево. Вот отхожу влево
[01:02:47.360 --> 01:02:53.840]  на 8 байт и читаю данные оттуда. Формально так делать нельзя, как вы понимаете, то есть то,
[01:02:53.840 --> 01:02:58.360]  что находится в левее вашего массива, это не принадлежит вам, но я так все равно сделаю,
[01:02:58.360 --> 01:03:02.720]  вам так делать нельзя. Давайте посмотрим, что произойдет.
[01:03:02.720 --> 01:03:17.720]  И запущу. Вот. И на экране я вижу вот эти самые 1213, то есть ровно то число,
[01:03:17.720 --> 01:03:22.240]  которое я указывал здесь. Ну, чтобы меня не заподозрили в том, что я специально подобрал
[01:03:22.240 --> 01:03:32.320]  число, может кто-нибудь в чате написать свое число, мы проверим, кто первый. Давайте другое.
[01:03:32.320 --> 01:03:51.040]  Я понял. Поколение мемов. Ладно. Компилируем, запускаем 6,9, 6,9. Вот. Нет, такое число я не буду
[01:03:51.040 --> 01:03:57.840]  вводить. У нас трансляция упадет. Ну вот, в общем, мораль в том, что когда вызываете
[01:03:57.840 --> 01:04:02.320]  ньюскворатными скопками, то есть компилятор предпринимает дополнительные действия. Он
[01:04:02.320 --> 01:04:08.680]  выделяет то есть нужное количество памяти и плюс дополнительно выделяет 8 байт слева для того,
[01:04:08.680 --> 01:04:13.200]  чтобы дилит мог понять, сколько деструкторов ему нужно вызвать. Вот. И эту информацию, собственно,
[01:04:13.200 --> 01:04:16.840]  эту информацию даже мы можем прочитать. Но опять же, вот на конкретной системе, в конкретном
[01:04:16.840 --> 01:04:20.480]  компиляторе. В других компиляторах может устроено по-другому, в других компиляторах может вот
[01:04:20.480 --> 01:04:34.560]  эти вот лишние 8 байта никогда не выделяются. Вот. Окей. Продолжим. Ну, еще давайте чуть-чуть поговорим
[01:04:34.560 --> 01:04:40.720]  про функции оператора new. Значит, у функции оператора new на самом деле есть несколько форм. То есть,
[01:04:40.720 --> 01:04:46.400]  не только та форма, которую я показал. То есть, не только, скажем, можно не только передать там
[01:04:46.400 --> 01:04:49.120]  количество байтов, которые нужно выделить, но можно передать какую-то дополнительную информацию.
[01:04:49.120 --> 01:04:53.160]  Ну, в частности, вот есть первая форма, про которую мы поговорили. Вы просто передаете количество
[01:04:53.160 --> 01:04:57.760]  байтов, которые нужно выделить, и к вам возвращается сырой указатель на эту память. Вот. Вы можете
[01:04:57.760 --> 01:05:07.480]  передать в качестве оргумента std nothrow. Ну, специальную переменную, которая облина в сценарии
[01:05:07.480 --> 01:05:13.880]  библиотеки. И эта перемена имеет тип std nothrow t. Так вот, если вы в оператора new, помимо размера,
[01:05:13.880 --> 01:05:17.640]  передадите вот эту вот самую переменную, которая имеет этот тип, то будет выбрана, естественно,
[01:05:17.640 --> 01:05:22.520]  эта перегрузка. И эта перегрузка просто делает то же самое, что и обычный оператор new. Просто она не
[01:05:22.520 --> 01:05:26.160]  бросает исключений. То есть, вместо того, чтобы бросить исключения, она ведет себя как malloc. То есть,
[01:05:26.160 --> 01:05:31.520]  она просто возвращает нулевой указатель в случае, если памяти недостаточно. Вот. И ровно вот этот
[01:05:31.520 --> 01:05:39.000]  оператор new и вызывается, когда вы используете new std nothrow t. Ну, помните, когда мы обсуждали
[01:05:39.000 --> 01:05:45.840]  исключения, мы говорили, что если вы new в круглых скобках передадите std nothrow, то это означает,
[01:05:46.640 --> 01:05:50.800]  что new не должен бросать исключений. И вот он не бросает исключений ровно вот по этой причине, что вот
[01:05:50.800 --> 01:05:56.040]  эта оператор ниу вызывает.. Точнее, вот эта операция new вызывает функцию оператора new, которая в качестве
[01:05:56.040 --> 01:06:04.440]  второго аргумента принимает nothrow. Вот поэтому он не бросает исключений. Вот. И есть еще некоторая
[01:06:04.440 --> 01:06:09.440]  особенная операция, ну, то есть, некоторая особенная функция оператора new, которая, в качестве второго
[01:06:09.440 --> 01:06:15.040]  аргумента принимает указатель на указатель на память и вот это довольно интересная
[01:06:15.040 --> 01:06:20.000]  функция оператор new потому что она реально не выделяет память вот прям вот не выделяет
[01:06:20.000 --> 01:06:31.440]  память то есть если вы вызовите эту функцию не знаю оператор new 10 и передать и передать
[01:06:31.440 --> 01:06:38.520]  какой-нибудь указатель ptr то никакого выделения памяти происходить не будет а вернет это функция
[01:06:38.520 --> 01:06:42.400]  оператор new ровно тот же самый указатель что вы передали то есть эта функция ничего не
[01:06:42.400 --> 01:06:47.280]  делает а просто возвращает ваш второй аргумент ну может показаться что это какая-то бесполезная
[01:06:47.280 --> 01:06:51.400]  оператор new то есть она ни зачем не нужна и так далее на самом деле это очень важная это очень
[01:06:51.400 --> 01:06:56.280]  важная функция оператор new и мы к ней обязательно вернемся вот она нам поможет решить что-то нам
[01:06:56.280 --> 01:07:00.680]  поможет решить в общем это вот среди этих трех на сегодняшней лекции вот третья это самое
[01:07:00.680 --> 01:07:07.200]  полезное в общем запомните ее вот ну и в общем случае в общем случае то есть понятное дело есть
[01:07:07.200 --> 01:07:11.720]  много других функций оператора new более того на следующем слайде я покажу вы можете определять
[01:07:11.720 --> 01:07:17.200]  свои собственные функции оператор new то есть вы можете перегружать оператор new вот и вызываются
[01:07:17.200 --> 01:07:23.120]  они с помощью вот и вызываются они тогда когда вы зовете операцию new с вот таким синтаксисом то
[01:07:23.120 --> 01:07:26.680]  есть если пишете операцию new и даже в круглых скобках указываете что-то то есть какие-то
[01:07:26.680 --> 01:07:31.880]  аргументы то первым делом вас вызывается функция оператора new ну понятное дело в качестве
[01:07:31.880 --> 01:07:35.400]  первой аргумента передается количество байт которые нужно выделить ну в данном случае сайзов
[01:07:35.400 --> 01:07:40.240]  t вот а в качестве следующих аргументов передается именно то что вы попросили вот ну это я уже
[01:07:40.240 --> 01:07:46.440]  говорил когда мы обсуждали вот как работает new с sd not role то есть операции new вы можете
[01:07:46.440 --> 01:07:54.840]  передать какие-то аргументы вот это ну это вот новая вещь которую мы сегодня должны понять что
[01:07:54.840 --> 01:07:59.960]  операции new вы можете передать какие-то аргументы и эти аргументы в итоге попадут в специальную
[01:07:59.960 --> 01:08:04.720]  функцию которая называется оператор и вот и все здесь есть вопросы
[01:08:12.720 --> 01:08:22.000]  тогда бежим дальше ну да как я анонсировал значит ну например вы можете переопределить
[01:08:22.920 --> 01:08:28.820]  перегрузить операцию new да вы можете да вы можете перегрузить вы можете ввести свои собственные
[01:08:28.820 --> 01:08:34.220]  операции new и более того вы можете переопределить встро reducing new ну например вот я переопределил
[01:08:34.220 --> 01:08:39.880]  стоянную операции new вот таким образом то есть моя операция new она тоже принимает count ну и
[01:08:39.880 --> 01:08:44.800]  она просто на самом деле вы говорит что ну я вот хочу выделить count byte то есть понятное
[01:08:44.800 --> 01:08:49.080]  дело что обычная эта цель ничего не уводит но я хочу чтобы выводила ну и выделяю память
[01:08:49.080 --> 01:08:57.560]  с помощью std-malloc. Ну вот, понятное дело, что так делать не стоит, потому что если вы
[01:08:57.560 --> 01:09:02.080]  переопределяете операцию new стандартную, то она переопределяется на всю программу целиком.
[01:09:02.080 --> 01:09:07.560]  Ну и если вы пишете какой-то файл и внутри своего файла переопределяете операцию new,
[01:09:07.560 --> 01:09:11.920]  то есть какой-то другой разработчик, который пишет свою часть кода, то он будет крайне
[01:09:11.920 --> 01:09:16.560]  удивлен, когда увидит, что операция new работает не так, как стандартная. Возможно, он этого не
[01:09:16.560 --> 01:09:21.520]  хотел. Поэтому, естественно, переопределение глобальной операции new является плохим тоном,
[01:09:21.520 --> 01:09:25.520]  так делать не стоит, но просто есть такая возможность. Скажем, если вы работаете над
[01:09:25.520 --> 01:09:29.760]  каким-то небольшим проектом, вы понимаете, что вам нужна какая-то особая логика операции new,
[01:09:29.760 --> 01:09:33.240]  и вы как бы всей командой договорились, что вам нужна такая особая логика, то, наверное,
[01:09:33.240 --> 01:09:39.600]  это имеет смысл, но в общем случае нет. Вы можете определить свою собственную перегрузку операции new,
[01:09:39.600 --> 01:09:45.280]  ну, например, написать свою перегрузку операции new, которая будет принимать в качестве дополнительного
[01:09:45.280 --> 01:09:50.160]  параметра, буллевский флаг, нужно ли бросать исключение или не нужно, точнее, нужно ли всегда
[01:09:50.160 --> 01:09:55.400]  бросать исключение или не нужно. Ну, например, если вы передали сюда true, то у вас new всегда будет
[01:09:55.400 --> 01:10:00.920]  приводить к выбросу исключения BDLog. Если передали false, то он будет приводить к исключению BDLog,
[01:10:00.920 --> 01:10:07.880]  только если у вас реально не хватает памяти. То есть, если вы вызываете new true, скажем,
[01:10:07.880 --> 01:10:16.760]  t, то у вас всегда будет бросаться исключение. Если вы вызываете new false, t, то исключение будет бросаться
[01:10:16.760 --> 01:10:24.000]  не всегда, только при необходимости. Ну, игрушечный пример, просто так можно делать. Кроме того,
[01:10:24.000 --> 01:10:29.040]  операции new можно переопределять, и вот это, на самом деле, уже более-менее осмысленное
[01:10:29.040 --> 01:10:34.560]  применение, вы можете переопределять или перегружать операции new для своих собственных структур или классов.
[01:10:34.560 --> 01:10:42.440]  Ну вот, в частности, вы можете написать, если вы пишете функции оператора new внутри структуры или
[01:10:42.440 --> 01:10:47.160]  внутри класса, то считается, что вот эта функция оператора new или оператор new с квадратными
[01:10:47.160 --> 01:10:51.920]  скобками будет вызываться, ну, когда вы попытаетесь с помощью new выделить этот класс. То есть,
[01:10:51.920 --> 01:10:57.960]  когда вы будете вызывать new a, будет вызываться вот эта штука. Когда вы вызываете new a с квадратными
[01:10:57.960 --> 01:11:05.200]  скобками, будет вызываться вот эта штука. Ну, и вы можете написать какую-то свою логику,
[01:11:05.200 --> 01:11:11.040]  ну, в общем, как угодно. Но самое главное, ну, то есть, одно из, наверное, главных применений, хотя не
[01:11:11.040 --> 01:11:16.360]  очень часто используемых, точнее, крайне редко используемых, это ситуация, если вы вдруг по какой-то
[01:11:16.360 --> 01:11:22.760]  причине хотите запретить выделять ваши элементы на стэке, ой, в куче. Допустим, у вас есть класс,
[01:11:22.760 --> 01:11:27.400]  вы хотите просто запретить выделять его в куче по каким-то, не знаю, религиозным или каким-то другим
[01:11:27.400 --> 01:11:33.400]  причинам, не хотите, чтобы эти объекты выделялись в куче. Тогда вы просто можете определить оператор new
[01:11:33.400 --> 01:11:41.560]  и определить их как delete. Тогда объект и структуру a нельзя выделять в куче. Ну, никак. Все. Ну, вообще никак.
[01:11:41.560 --> 01:11:48.720]  Ну, точнее, c++ язык возможностей, наверное, как-то можно это обойти, но вот нормативным способом не
[01:11:48.720 --> 01:12:00.120]  получится. Вот, наверное, такой забавный факт. Вот. Да, ну, еще что-то стоит сказать. Значит, если вы
[01:12:00.120 --> 01:12:05.640]  переоперили свою операцию new, то для них обязательно нужно написать свои версии delete. Вот это обязательно,
[01:12:05.640 --> 01:12:12.120]  иначе у вас, ну, иначе undefinedBehaviour просто. Короче, если вы определили свой new по какой-то причине,
[01:12:12.120 --> 01:12:21.120]  то нужно обязательно определить свой delete. Вот. Ну, здесь это написано. Ну, это скорее, ну, это не совсем
[01:12:21.120 --> 01:12:25.680]  относится к тому, что я хочу рассказать, просто вот такой забавный факт. Можно операцию new
[01:12:25.680 --> 01:12:33.000]  переопределять, тогда new будет вести себя по-другому. Давайте к более реальным вещам. Значит,
[01:12:33.000 --> 01:12:42.240]  с функцией оператор new разобрались. Остались у кого-то какие-то вопросы? Сейчас пойдем дальше просто.
[01:12:52.240 --> 01:12:58.040]  Окей, вопросов нет. Значит, теперь мы поняли, как выделять сырую память. То есть, если нам
[01:12:58.040 --> 01:13:03.560]  нужна сырая память, мы поняли, что нужно воспользоваться функцией оператор new. Окей, но у нас
[01:13:03.560 --> 01:13:07.400]  есть еще вторая эпостазь, которую мы не обсудили. Это, а как создать объект? Ну, хорошо, мы умеем
[01:13:07.400 --> 01:13:12.280]  выделять сырую память. А вот, допустим, вот в этой сырой памяти я хочу создать объект. Как мне это
[01:13:12.280 --> 01:13:19.240]  сделать? Какой у меня вообще есть способ создать объект или какой у меня вообще есть способ
[01:13:19.240 --> 01:13:26.600]  вызвать конструктор? Ну, у меня есть способ вызвать операцию new. Но при этом я знаю, что операция new
[01:13:26.600 --> 01:13:32.520]  у меня всегда вызывает функцию оператора new. То есть, она выделяет память и, во-вторых, она создает
[01:13:32.520 --> 01:13:42.360]  объект. Так вот, смотрите, мне нужно как-то вызвать new new t. Но мне нужно сделать как-то так, чтобы new
[01:13:42.360 --> 01:13:50.400]  не выделял память, а воспользовался памятью, которую хочу я. То есть, я хочу ему
[01:13:50.400 --> 01:13:56.520]  предоставить какую-то память, ну, как-то передать в new какой-то указатель и сделать так, чтобы он
[01:13:56.520 --> 01:14:03.760]  воспользовался этим указателем, чтобы создать там объект. Вопрос. Понимаете ли вы, как это сделать?
[01:14:16.280 --> 01:14:20.760]  Смотрите, мы знаем, что операцией new можно передавать информацию. То есть, мы с этим
[01:14:20.760 --> 01:14:30.760]  разобрались. То есть, мы знаем, что new можно передать какие-то аргументы. То есть, мы хотим new как-то
[01:14:30.760 --> 01:14:36.280]  сообщить о том, что тебе не нужно выделять память, тебе нужно просто взять наш указатель и воспользоваться
[01:14:36.280 --> 01:14:39.400]  им. Ничего не напоминает.
[01:14:39.400 --> 01:14:50.160]  Третий вариант, оператор new.
[01:14:50.160 --> 01:15:00.640]  Во, отлично. Да, давайте откатимся назад и посмотрим вот сюда. Я говорил, что это нам пригодится, и вот этот
[01:15:00.640 --> 01:15:07.400]  момент настал. Да, у нас есть, условно, третья форма оператора new, которая принимает указатель. И вот эта
[01:15:07.400 --> 01:15:11.520]  форма, она с этим указателем ничего не делает, то есть, она ничего не делает, ничего не взяет, она просто
[01:15:11.520 --> 01:15:17.920]  берет указатель и возвращает его же. То есть, по сути, это оператор new подменяет выделение памяти
[01:15:17.920 --> 01:15:26.560]  просто тем указателем, который вы ей передали. И все. Все. Вот это ровно то, что нам нужно.
[01:15:26.560 --> 01:15:33.920]  Ну и вопрос, как мне заставить, ну то есть, ну и теперь понятно, что если я хочу, скажем, у меня есть
[01:15:33.920 --> 01:15:39.000]  какой-то указатель ptr, ну не знаю, откуда-то мне его дали, и я хочу вот по этому указателю вот в этом
[01:15:39.000 --> 01:15:47.520]  месте создать объекти pt. Мне достаточно просто вызвать new в скобках ptr t, ну и возможно какие-то
[01:15:47.520 --> 01:15:56.680]  аргументы, возможно какие-то аргументы конструктора передать, там x и y. Что теперь тут произойдет? Вот
[01:15:56.680 --> 01:16:04.480]  эта операция new, она вызовет функцию оператора new вот эту, и в качестве второго аргумента ей
[01:16:04.480 --> 01:16:10.240]  передаст вот этот ptr. Эта функция оператора new выделять память не будет, а просто вернет нужный
[01:16:10.240 --> 01:16:17.480]  указатель. Все. New, вот операция new примет этот указатель, и внутри этого указателя, то есть,
[01:16:17.480 --> 01:16:22.960]  по этому месту памяти создаст нужный нам объект. Все. То есть, по сути, вот эта версия new, то есть,
[01:16:22.960 --> 01:16:28.600]  вызывая new вот так, мы говорим, что нужно создать объект вот конкретно в этом месте в памяти. И
[01:16:28.600 --> 01:16:34.240]  таким образом мы решили вторую проблему. Все. То есть, теперь мы умеем первое, выделять вторую
[01:16:34.240 --> 01:16:38.920]  память с помощью функции оператора new, а во-вторых, умеем просто вызывать конструктор в нужном месте
[01:16:38.920 --> 01:16:51.120]  в памяти. И делается это вот таким образом. Как это можно применять? Данная форма new,
[01:16:51.120 --> 01:16:55.960]  которая не выделяет память, а просто создает объект в нужном месте, называется placement new.
[01:16:55.960 --> 01:17:01.160]  Вообще формально placement new называется любая форма new, которая принимает аргументы. Но,
[01:17:01.160 --> 01:17:05.800]  как правило, принято называть placement new именно вот такую форму, которая принимает указатель.
[01:17:05.800 --> 01:17:13.160]  Какие приколы я теперь могу вытворять? Ну, например, я могу взять массив чаров на стэке. То есть,
[01:17:13.160 --> 01:17:20.280]  могу взять просто массив byte на стэке и внутри этого массива создать объект. Объект типа T.
[01:17:20.280 --> 01:17:29.520]  То есть, теперь есть у меня массив чаров, но внутри этого массива чаров реально расположен
[01:17:29.520 --> 01:17:35.080]  объект типа T. Если я проинтерпретирую биты вот этого массива чаров как T,
[01:17:35.080 --> 01:17:40.200]  то там будет реальный объект, к которому можно пользоваться и так далее. И пользоваться этими
[01:17:40.200 --> 01:17:46.480]  объектами я могу, например, с помощью указателя ptr, который мне вернет new. Ну, undue вернет мне
[01:17:46.480 --> 01:17:50.440]  собственно адрес объекта. Поэтому можно воспользоваться как объектом, так и ptr.
[01:17:50.440 --> 01:18:01.800]  Ну и плюс я могу вручную создавать элементы в куче. Ну, как я это делаю? Я могу вызвать оператор
[01:18:01.800 --> 01:18:06.520]  new. То есть, выделить нужное количество памяти для хранения объекта типа T. То есть,
[01:18:06.520 --> 01:18:12.280]  сохранить указатель ptr и дальше по этому указателю создать объект. Вот это вот ровно всё,
[01:18:12.280 --> 01:18:17.920]  вот это вот всё, эквивалентно, ну, по сути, в некотором смысле эквивалентно, просто вызову new T.
[01:18:17.920 --> 01:18:25.360]  Вот это ровно то, что делает new T. Выделяет вторую память и дальше создает объект. Вот ровно
[01:18:25.360 --> 01:18:30.880]  вот эти два действия мы сделали сейчас вручную. И мы умеем так делать. Окей, ну и тут возникает два
[01:18:30.880 --> 01:18:38.480]  вопроса. Ну, смотрите, вот здесь у меня объект хранится на стеке. Что я знаю про объекты на стеке?
[01:18:38.480 --> 01:18:44.280]  Про объекты на стеке я знаю, что для них автоматически вызывается деструктор. Но здесь я как бы вызвал
[01:18:44.280 --> 01:18:50.160]  конструктор не совсем нормативным способом. То есть, я тут создал объект типа T в каком-то месте,
[01:18:50.160 --> 01:18:54.640]  который на самом деле зарезервирован под какую-то другую переменную. Возникает вопрос, будет ли
[01:18:54.640 --> 01:19:00.880]  вызван деструктор для этого объекта, который я создал с помощью new. Ну и второй момент, вот как во
[01:19:00.880 --> 01:19:09.440]  втором случае мне корректно очистить память и вызвать деструкторы. Так вот, ответы следующие. В первой
[01:19:09.440 --> 01:19:13.520]  ситуации компилятор, естественно, не догадается вызвать деструктор. Ну, потому что тут, по сути,
[01:19:13.520 --> 01:19:18.120]  вы компилятор, ну, немного обманываете. Потому что вы говорите, что, ага, вот есть место в памяти, область
[01:19:18.120 --> 01:19:24.160]  памяти, которая занимает объект. И это область памяти, это массив чаров. А дальше вы просто берете и
[01:19:24.160 --> 01:19:32.280]  говорите, что, ну вот, на этом месте массива чаров вы создаете объект. Ну, естественно, когда вы
[01:19:32.280 --> 01:19:35.760]  выходите из скобка, то есть, когда вы выходите из области действия, то есть, когда закрывается
[01:19:35.760 --> 01:19:39.920]  фигурная скобка, компилятор смотрит на все ваши переменные и смотрит, ага, значит, вот есть
[01:19:39.920 --> 01:19:43.680]  переменная там такая-то, нужно вызвать для нее деструктор. Дальше он смотрит сюда и видит, ага, есть
[01:19:43.680 --> 01:19:50.400]  переменная типа char, типа массив чаров, и он уничтожит этот объект, точнее, уничтожит эту память
[01:19:50.400 --> 01:19:57.000]  как массив чаров, а не как объект типа T. Потому что компилятор, в принципе, ну как ему понять, что вот
[01:19:57.000 --> 01:20:00.720]  в этом месте, которое называется массив чаров, ну как он может догадаться, что там реально хранится
[01:20:00.720 --> 01:20:06.800]  объект типа T. Ну, это же маразм, поэтому он так не делает. Поэтому, если вы создали объект вручную,
[01:20:06.800 --> 01:20:12.120]  то есть вот вручное управление временем жизни, то есть, если вы вручную создали объект с помощью new,
[01:20:12.120 --> 01:20:20.280]  то простите, но вы обязаны вручную его уничтожить, то есть вызвать деструктор вручную. И это, на самом
[01:20:20.280 --> 01:20:25.200]  деле, вот первый способ, ну вот первые случаи в нашем курсе, когда вызов вручную деструктора имеет
[01:20:25.200 --> 01:20:30.660]  смысл. Во всех остальных случаях нет. Вот если вы вручную создали объект сами с помощью placement
[01:20:30.660 --> 01:20:37.720]  new, то вы обязаны его вручную удалить. Ну и во втором случае то же самое, так как вы вручную
[01:20:37.720 --> 01:20:42.200]  создавали объект, то будьте добры вручную его уничтожить. То есть вы вручную должны сначала вызвать
[01:20:42.200 --> 01:20:49.080]  деструктор для этого объекта, а потом вызвать оператор delete, то есть вернуть сурую память. На
[01:20:49.080 --> 01:20:55.360]  самом деле вот эти две строчки можно заменить на deleteptr, ну как можно. Нельзя формально,
[01:20:55.360 --> 01:21:00.480]  формально это define behavior, но скорее всего это будет работать. Я пробовать не советую,
[01:21:00.480 --> 01:21:07.080]  просто такая информация. Ну просто delete можно вызвать только на те указатели, которые были
[01:21:07.080 --> 01:21:11.600]  выделены с помощью операции new. А вы вызвали не операцию new, а вы как бы вручную все делали,
[01:21:11.600 --> 01:21:19.200]  поэтому вручную нужно все удалять. Так, короче, вопрос есть? Вот что происходит здесь и что
[01:21:19.200 --> 01:21:29.040]  происходит здесь? Понятно ли, почему я должен вручную вызвать деструктор и почему я должен
[01:21:29.040 --> 01:21:31.960]  во втором случае тоже вручную вызвать деструктор и вручную вызвать оператор delete?
[01:21:31.960 --> 01:21:45.360]  Окей, видимо вопросов нет. Ну хорошо, давайте вернемся. Теперь я утверждаю, что мы понимаем,
[01:21:45.360 --> 01:21:51.120]  как устроен внутри себя stvector. Вот stvector устроен хитро, то есть он не просто вызывает
[01:21:51.120 --> 01:21:55.040]  операцию new и операцию delete, он на самом деле вот так вот вручную на низком уровне управляет
[01:21:55.040 --> 01:21:58.760]  памятью и управляет временем жизни объектов. Ну то есть формально, если вам нужен массив,
[01:21:58.760 --> 01:22:04.360]  в котором size элементов и память выделена под capacity элементов, реально происходит следующая
[01:22:04.360 --> 01:22:13.880]  вещь. Выделяется буфер размера size of tail умножить на capacity byte, то есть вот выделяется
[01:22:13.880 --> 01:22:21.600]  большой буфер и дальше в цикле для каждой ячейки памяти от 0 до size вы создаете объект. То есть вы
[01:22:21.600 --> 01:22:25.320]  создали объект здесь, вы создали объект здесь, создали объект здесь, создали объект здесь и все,
[01:22:25.320 --> 01:22:33.160]  остановились. Теперь у вас вот эта часть, это size, а все остальное это capacity. И при этом вот эта
[01:22:33.160 --> 01:22:38.360]  часть является непроинитерализированной, то есть там реально объектов нет. Поэтому вектор всегда
[01:22:38.360 --> 01:22:42.560]  стремится к тому и достигает того, что у вас реально в каждый момент хранится size объектов.
[01:22:42.560 --> 01:22:47.080]  Вся остальная память, она не проинитерализирована никак, то есть там объектов реально не хранится.
[01:22:47.080 --> 01:22:53.840]  И это хорошо. Ну и как устроен destructor вектора? Ну, например, возможная реализация. Ну,
[01:22:53.880 --> 01:23:00.400]  мы должны просто в цикле пройтись и уничтожить каждый элемент size, то есть уничтожить этот элемент,
[01:23:00.400 --> 01:23:05.640]  этот элемент, этот элемент, этот элемент, ну и дальше освободить, вернуть память системе,
[01:23:05.640 --> 01:23:13.280]  то есть вызвать функцию оператор delete. Таким образом, clear не просто восстанавливает size равным
[01:23:13.280 --> 01:23:19.360]  нулю, но и вызывает destructor для size объектов, поэтому он работает за size, за o от size. Resize не
[01:23:19.360 --> 01:23:23.560]  просто обновляет size, но и при необходимости вызывает destructor для лишних объектов и вызывает
[01:23:23.560 --> 01:23:29.920]  constructor для дополнительных объектов, которые вы создали. Ну и также resize. Resize не только выделяет
[01:23:29.920 --> 01:23:37.000]  память для capacity, но еще и переносит size элементов в нужные места. А остальные там лишние элементы,
[01:23:37.000 --> 01:23:46.320]  то есть лишняя память, он никак не заполняет, поэтому на это время не уходит. Ну и, видимо,
[01:23:46.320 --> 01:23:54.600]  пора сделать перерыв. Давайте 10 минут отдохнем и продолжим говорить про контейнеры. Так, давайте
[01:23:54.600 --> 01:24:01.120]  сначала так. Есть вопросы? Если есть вопросы, давайте сначала разберемся, потом отдохнем.
[01:24:01.120 --> 01:24:12.280]  Зачем нам может понадобиться самим вот вручную по конкретному указателю сначала выделить
[01:24:12.280 --> 01:24:18.360]  струю памяти, а потом сделать там конкретный объект? Конкретно вам, наверное, не зачем. Если вы
[01:24:18.360 --> 01:24:23.480]  пользуетесь стандартными классами типа vector, если вы пользуетесь стандартными классами, то вам
[01:24:23.480 --> 01:24:27.320]  это не зачем делать, это все происходит за вас автоматически. То есть вот этот весь разговор про
[01:24:27.320 --> 01:24:32.720]  operator new, про ручное создание объектов, ручное удаление объектов, это про то, ну это для того,
[01:24:32.720 --> 01:24:36.520]  что вы понимали, как внутри устроен vector на самом деле. Возвращаясь к преамбуле,
[01:24:36.520 --> 01:24:41.400]  которую я говорил в начале, если вы понимаете, что устроен vector внутри, то, ну я надеюсь,
[01:24:41.400 --> 01:24:45.480]  что это там добавило вам знаний и небольшого понимания того, как это устроено, и вы можете
[01:24:45.480 --> 01:24:52.120]  там vector пользоваться более эффективно. Реально вам лично, наверное, это не нужно. То есть самим
[01:24:52.120 --> 01:24:57.360]  вручную вызвать operator new и так далее. Все это сделает за вас vector и любые другие классы.
[01:24:57.360 --> 01:25:05.600]  Ну или ну такой более прагматичный ответ, зачем это вам нужно. У вас есть задание, задание vector.
[01:25:05.600 --> 01:25:09.920]  В этом задании есть дополнительная часть. Вот если вы собираетесь ее решать, то вот вам
[01:25:09.920 --> 01:25:15.680]  понадобится использовать это. И продолжим. Значит тут поступил вопрос, ну насколько я понял, да,
[01:25:15.680 --> 01:25:26.600]  можно ли, скажем, вызвать условно, давайте тут. Ну опять же, если вопрос был не такой, то поправьте.
[01:25:26.600 --> 01:25:33.280]  Ну типа можно ли делать вот так, можно ли вызвать ну обычный new, потом вручную вызвать
[01:25:33.280 --> 01:25:43.680]  destructor, а потом operator delete. Ну скажем так, здесь так нельзя как минимум по двум причинам.
[01:25:43.680 --> 01:25:49.600]  Ну первая причина, потому что если вы вызывали с помощью new, то нужно вызывать delete с квадратным
[01:25:49.600 --> 01:25:56.200]  скобками. Это первое. А второе, скорее всего, если вы тут позовете квадратные скобки, то опять же
[01:25:56.200 --> 01:26:00.920]  скорее всего это заработает, но формально с точки зрения языка это undefined behavior. Почему? Потому что
[01:26:00.920 --> 01:26:06.840]  в стандарте жестко прописано, что если вы уже вызываете new вот таким образом, то и вот этот вот
[01:26:06.840 --> 01:26:13.320]  указатель вы тоже должны для него вызывать delete с квадратными скобками. То есть логика такая,
[01:26:13.320 --> 01:26:19.260]  если вы управляете памятью вручную, то вы как бы должны делать все вручную. То есть вручную вызывать
[01:26:19.260 --> 01:26:24.360]  operator delete и destructor. Если вы делаете это не вручную, то с помощью операции new и операции delete,
[01:26:24.360 --> 01:26:33.880]  то это надо делать с помощью операции new и delete. Еще до перерыва был вопрос, зачем нам это нужно.
[01:26:33.880 --> 01:26:39.280]  Я подумал, то есть, возможно, человек-миловедующий другую интерпретацию этот вопрос. Давайте я на другую
[01:26:39.280 --> 01:26:44.280]  интерпретацию вопроса отвечу. То есть не для чего это конкретно нужно нам вручную, а для чего это
[01:26:44.280 --> 01:26:50.880]  вообще пригождается. Ну вернемся и к начальной проблеме, которую мы поставили до того, как это
[01:26:50.880 --> 01:27:00.120]  обсуждать вот сюда. Мы говорили о том, что, смотрите, если бы это не было так, то есть если мы не
[01:27:00.120 --> 01:27:04.840]  могли вручную это делать, то есть если бы не было такой возможности, то здесь при выполнении resize и
[01:27:04.840 --> 01:27:14.040]  clear нам бы приходилось держать в памяти целую кучу, в частности 90 лишних лекторов, которые
[01:27:14.040 --> 01:27:18.080]  имеют размер миллион. То, что мы умеем вручную управлять память, то есть вручную управлять
[01:27:18.080 --> 01:27:22.580]  в временном жизни объекты, это на самом деле классно. Почему? Потому что мы можем, не уменьшая сам
[01:27:22.580 --> 01:27:28.760]  буфер, не уменьшая сам буфер вот это capacity, мы можем уничтожить вот эти вот объекты, чтобы они
[01:27:28.760 --> 01:27:33.080]  там не занимали лишние ресурсы. Ну а как вы понимаете, если у меня там хранятся вектора размера миллион, то
[01:27:33.080 --> 01:27:38.200]  они жрут много памяти. Ну или в принципе другие объекты. Это вот одно объяснение. Второе объяснение
[01:27:38.200 --> 01:27:45.320]  здесь. Я теперь могу в векторе по сути хранить элементы, которые не имеют конструктора по умолчанию.
[01:27:45.320 --> 01:27:49.280]  Почему? Потому что при вызове резерв мне теперь не нужно конструктора по умолчанию. Резерв
[01:27:49.280 --> 01:27:54.360]  мне лишь выделяет сырую память. Сырая память ничего про объекты не знает. Теперь я могу
[01:27:54.360 --> 01:28:01.720]  собственно делать pushback и делать pushback нужных мне объектов без вызова конструктора по умолчанию и
[01:28:01.720 --> 01:28:10.960]  так далее. Вот и второй момент. Ну и третий момент. Представьте себе такую ситуацию, что вам
[01:28:10.960 --> 01:28:16.200]  что-то приходит с консоль, то есть вам приходит какой-то вход, и в зависимости от входа, типа если х,
[01:28:16.200 --> 01:28:23.880]  то нужно там сказать, ну не знаю, у вас есть там, ну какая-то переменная а, и в зависимости
[01:28:23.880 --> 01:28:30.520]  того, если он пришел х, то вам нужно в а что-то записать, а иначе в а ничего не нужно записывать.
[01:28:30.520 --> 01:28:37.780]  Но при этом, чтобы сохранить что-то в переменную а, вам эту перемену нужно создать. То есть вам
[01:28:37.780 --> 01:28:41.340]  нужно создать эту переменную. Эта переменная должна создаться там с помощью конструктора по умолчанию,
[01:28:41.340 --> 01:28:46.340]  ну или с помощью какого-то другого конструктора, ну и дальше вы там ее держите в памяти. Ну а теперь
[01:28:46.340 --> 01:28:51.980]  снова представьте, что это какой-то тяжелый объект. И чтобы как бы что-то ему присвоить,
[01:28:51.980 --> 01:28:55.740]  вам нужно как бы создать этот объект. А этот объект тяжелый, то есть его долго создавать.
[01:28:55.740 --> 01:29:04.100]  Поэтому, чтобы этого не происходило, в standard-ability.x++ есть такой класс std-optional.
[01:29:04.100 --> 01:29:11.140]  Вот этот и класс std-optional, он параметризуется типом t, и вот std-optional он хорош тем, что он не
[01:29:11.140 --> 01:29:16.620]  создает объект до тех пор, пока вы не попросили его создать. Вот если вы объявили переменную типа
[01:29:16.620 --> 01:29:22.260]  std-optional, которую вы, кстати, будете обсуждать на семинарах, вот на семинарах вы на примере
[01:29:22.260 --> 01:29:27.580]  класса std-optional попробуете все эти трюки поделать. Так вот, если вы объявите переменную типа std-optional,
[01:29:27.580 --> 01:29:33.460]  то std-optional просто-напросто выделяет память под вашу переменную, но при этом объекта
[01:29:33.460 --> 01:29:38.260]  само не создает. То есть никаких дополнительных сложностей на создание объекта вам тратить не нужно.
[01:29:38.260 --> 01:29:41.940]  Ну и даже уже в зависимости того, нужен вам будет впоследствии от объекта или нет,
[01:29:41.940 --> 01:29:48.420]  вы можете там что-то создать или не создавать. Опять же, повышение эффективности программ
[01:29:48.420 --> 01:29:52.900]  за счет того, что вы избегаете лишних созданий, лишних вызовов конструкторов, если они вам реально не нужны.
[01:29:52.900 --> 01:30:03.100]  Окей, это было продолжение секции с вопросами. Теперь давайте пробуем быстро закончить с
[01:30:03.100 --> 01:30:08.620]  вектором и пойти дальше. Значит, помимо того, что у вектора есть методы insert и pushback, у вектора есть
[01:30:08.620 --> 01:30:13.780]  еще размещающие методы, это emplace и emplaceback. В общем, их ключевое отличие заключается в том,
[01:30:13.780 --> 01:30:18.220]  ну давайте для начала с проблемой определимся. Ну вот снова, у меня есть вектор векторов, то есть
[01:30:18.220 --> 01:30:23.940]  ну или вектор каких-то тяжелых объектов. Когда я вызываю вектор, ну когда я вызываю vw.pushback и
[01:30:23.940 --> 01:30:29.140]  там pushback какой-то вектор, потенциально большой, точнее, я понимаю, что мне нужно внутрь вектора
[01:30:29.140 --> 01:30:36.460]  спихнуть еще один вектор размера 10 или какого-то другого размера. Что мне нужно сделать?
[01:30:36.460 --> 01:30:40.220]  Мне нужно написать вызов конструктора этого вектора и передать в pushback. То есть что у меня
[01:30:40.220 --> 01:30:45.900]  происходит? Создается временный объект, а дальше этот временный объект перемещается внутрь вектора.
[01:30:45.900 --> 01:30:50.060]  Ну и то же самое происходит с insert. Если мне нужно в середину вектора заинсертить какой-то
[01:30:50.060 --> 01:30:56.220]  третий вектор, то снова мне нужно создать временный вектор, и потом этот вектор будет
[01:30:56.220 --> 01:31:00.580]  перемещен в нужное место. То есть тут как бы тратится лишнее время, лишнее время на то,
[01:31:00.580 --> 01:31:07.040]  чтобы переместить этот вектор и так далее. Тут появляюсь вопрос, а что если у меня как бы
[01:31:07.040 --> 01:31:15.420]  для какого-то класса нет перемещения условно. Или нет копирования. Ну допустим, нет перемещения.
[01:31:15.420 --> 01:31:19.580]  Вот копирование есть, а перемещения нет. Копирование при этом дорогое. И тогда,
[01:31:19.580 --> 01:31:23.100]  что будет происходить? У меня создается объект и дальше он будет копироваться в нужное место.
[01:31:23.100 --> 01:31:26.100]  То есть, опять же, допустим, копия дорогая.
[01:31:26.100 --> 01:31:27.100]  Что делать?
[01:31:27.100 --> 01:31:30.100]  Так вот, методы emplace и emplaceback позволяют вам
[01:31:30.100 --> 01:31:32.100]  разместить сразу объект в нужном месте.
[01:31:32.100 --> 01:31:35.100]  То есть, что вы делаете? Вы теперь не создаете объект заранее,
[01:31:35.100 --> 01:31:38.100]  а вы просто передаете параметры конструктора.
[01:31:38.100 --> 01:31:43.100]  То есть, вы передаете параметры конструктора, скажем, 10 и 1, и 5 и минус 1.
[01:31:43.100 --> 01:31:47.100]  Что это означает? Это означает, что этот метод возьмет эти аргументы
[01:31:47.100 --> 01:31:51.100]  и непосредственно в нужном месте сразу же создаст объект с этими параметрами.
[01:31:51.100 --> 01:31:54.100]  Без лишних копий, без лишних перемещений.
[01:31:54.100 --> 01:31:57.100]  Короче говоря, мораль, как правило,
[01:31:57.100 --> 01:32:00.100]  использование emplaceback и emplace гораздо эффективнее,
[01:32:00.100 --> 01:32:02.100]  ну или не гораздо, ну просто эффективнее,
[01:32:02.100 --> 01:32:05.100]  чем использование обычных pushback и insert,
[01:32:05.100 --> 01:32:12.100]  потому что это позволяет вам сэкономить на копированиях и перемещениях.
[01:32:14.100 --> 01:32:17.100]  Ну и как бы, да, мы где-то уже видели такое,
[01:32:17.100 --> 01:32:19.100]  что мы передаем не сами объекты,
[01:32:19.100 --> 01:32:21.100]  а параметры конструктора или что-то еще.
[01:32:21.100 --> 01:32:24.100]  Ну, в частности, когда мы обсуждали MakeUnique и MakeSharad.
[01:32:24.100 --> 01:32:30.100]  Ну и здесь, собственно, все это выглядит ровно так, как было раньше.
[01:32:30.100 --> 01:32:35.100]  То есть, вы принимаете универсальную ссылку,
[01:32:35.100 --> 01:32:43.100]  дальше все параметры конструктора форвардите в конструктор объекта T.
[01:32:43.100 --> 01:32:46.100]  То есть, сразу же в нужной позиции
[01:32:46.100 --> 01:32:49.100]  создаете объект с нужными параметрами конструктора.
[01:32:49.100 --> 01:32:52.100]  Вот это, ну, так это и работает.
[01:32:52.100 --> 01:32:54.100]  То есть, теперь с помощью синтактиса,
[01:32:54.100 --> 01:32:56.100]  размещающего и new, мы можем сразу создать объект
[01:32:56.100 --> 01:32:59.100]  с нужными параметрами конструктора в нужном месте.
[01:32:59.100 --> 01:33:02.100]  Ну и давайте перейдем к нескольким полезным советам
[01:33:02.100 --> 01:33:05.100]  по работе с std-вектор.
[01:33:07.100 --> 01:33:09.100]  Ну, короче, просто некоторые трюки,
[01:33:09.100 --> 01:33:13.100]  которые позволят более эффективно пользоваться вектором и так далее.
[01:33:13.100 --> 01:33:17.100]  Первый, возможно, банальный совет – это использовать резерв.
[01:33:17.100 --> 01:33:20.100]  Классический подход к решению задач,
[01:33:20.100 --> 01:33:22.100]  которые у нас есть в контесте,
[01:33:22.100 --> 01:33:25.100]  ну, или, в принципе, любых задач из жизни,
[01:33:25.100 --> 01:33:28.100]  это примерно такой.
[01:33:28.100 --> 01:33:31.100]  Вам откуда-то приходит информация о том,
[01:33:31.100 --> 01:33:33.100]  сколько элементов вам нужно хранить,
[01:33:33.100 --> 01:33:37.100]  и все эти элементы, естественно, вы будете хранить в классе вектор.
[01:33:37.100 --> 01:33:41.100]  Ну и дальше вы последовательно считываете все эти n элементы,
[01:33:41.100 --> 01:33:44.100]  и добавляете в конец вектор V.
[01:33:44.100 --> 01:33:46.100]  В чем здесь неэффективность?
[01:33:46.100 --> 01:33:48.100]  А неэффективность здесь заключается в том,
[01:33:48.100 --> 01:33:50.100]  что вы создали изначально пустой вектор,
[01:33:50.100 --> 01:33:52.100]  и потом, ну, добавляете все элементы в конец.
[01:33:52.100 --> 01:33:57.100]  А при добавлении в конец вектор иногда перевыделяет память.
[01:33:57.100 --> 01:33:59.100]  У вас вектор расширился до определенного момента,
[01:33:59.100 --> 01:34:01.100] �а перевыделил память.
[01:34:01.100 --> 01:34:03.100]  Вот почему оно передвеляет память?
[01:34:03.100 --> 01:34:05.100]  Ну, потому что вы вектору не сообщили,
[01:34:05.100 --> 01:34:07.100]  вообще заранее не сообщили,
[01:34:07.100 --> 01:34:09.100]  сколько элементов он должен хранить.
[01:34:09.100 --> 01:34:18.860]  хранить. Так вот, чтобы не выполнять лишнее переводеление памяти, вам нужно перед тем,
[01:34:18.860 --> 01:34:26.020]  как что-то запихивает вектор, вызывать резерв. Ну как это работает? Вот вы считали, сколько данных
[01:34:26.020 --> 01:34:31.420]  вам понадобится, ну или как-то поняли, сколько данных вам понадобится, создали вектор, сразу
[01:34:31.420 --> 01:34:35.820]  зарезервировали нужное количество памяти, и уже дальше делаете pushback. И вот тут уже никаких
[01:34:35.820 --> 01:34:39.580]  перелокаций не происходит. Почему? Потому что вы заранее выделили нужное количество памяти и уже
[01:34:39.580 --> 01:34:48.140]  потом просто-напросто заполняете эти все эти все ячейки. И все. У меня, по-моему, есть по этому поводу
[01:34:48.140 --> 01:35:02.820]  какая-то демонстрация. Что здесь происходит? У меня есть два теста. Тест no-reserve, то есть,
[01:35:02.820 --> 01:35:10.100]  ну вот, собственно, тот самый код без резерва, и есть код с резервом. И, собственно, все что здесь
[01:35:10.100 --> 01:35:14.980]  происходит, я просто измеряю время, за сколько работает тот или иной код. Но давайте посмотрим
[01:35:14.980 --> 01:35:29.260]  на разницу во времени работы тест с резервом и тест без резерва. Что мы сделаем?
[01:35:29.260 --> 01:35:36.460]  Резерв трикнули. Давайте сразу включим оптимизации компилятора, чтобы сравнить реальное время.
[01:35:36.460 --> 01:35:44.940]  Запускаем. Вот, и видим следующую вещь. То есть там, по-моему, 500 тысяч элементов. Да, я заполняю 500
[01:35:44.940 --> 01:35:49.980]  тысяч элементов. И что я вижу? Если я выполняю резерв заранее, то там все работает в две тысячи
[01:35:49.980 --> 01:35:54.860]  секунды. Если я делаю все без резерва, то все выполняется в четыре тысячи секунды. То есть,
[01:35:54.860 --> 01:36:00.260]  в два раза, то есть, без резерва и с резервом, отличие в два раза. Ну и, на самом деле, понятно, откуда берется
[01:36:00.260 --> 01:36:08.220]  это в два раза. Это все истюарь исследует, на самом деле. Если вы помните амортиционный анализ,
[01:36:08.220 --> 01:36:15.100]  как работает динамический массив, то там возникает такой коэффициент, как k на k-1, где k – это коэффициент
[01:36:15.100 --> 01:36:23.360]  решения. Вот, то есть, если вы вектор увеличиваете каждый раз в два раза, то, то есть, k равно 2, то у
[01:36:23.360 --> 01:36:30.900]  вас количество лишнего, то есть в общее количество действий равно 2n. Вот, если вектор увеличивается в
[01:36:30.900 --> 01:36:36.580]  три раза, то общее количество действий у вас равно 3 second n. Ну и так далее. Ну и, собственно,
[01:36:36.580 --> 01:36:44.060]  мы здесь, на практике, вот это вот самое в два раза. Ну есть еще один забавный пример, по-моему. Да,
[01:36:44.060 --> 01:36:50.060]  Это реальный код, который я видел два года назад, в общем, как делать не стоит.
[01:36:50.060 --> 01:36:59.060]  Даже если вы используете резервы, если вы пользуетесь векторами, это все равно не спасает вас выстрела себе в ногу и всяких неэффективностей.
[01:36:59.060 --> 01:37:02.060]  Вот, например, один из студентов делает следующую вещь.
[01:37:02.060 --> 01:37:08.060]  Вот у вас есть вектор V, и он понимает, что ему нужно вставить один дополнительный элемент каждый раз.
[01:37:08.060 --> 01:37:11.060]  И вот чтобы вставить один дополнительный элемент, естественно, нужно зарезвировать память.
[01:37:11.060 --> 01:37:13.060]  Подает один элемент.
[01:37:13.060 --> 01:37:16.060]  То есть, у меня есть size, мне нужно добавить один элемент.
[01:37:16.060 --> 01:37:21.060]  Значит, мне нужно обеспечить то, чтобы как бы вектора хватило, чтобы добавить этот дополнительный элемент.
[01:37:21.060 --> 01:37:24.060]  Ну и соответственно, в цикле я каждый раз вызываю резерв на один больше.
[01:37:24.060 --> 01:37:28.060]  Ну и я думаю, я надеюсь, вы понимаете, почему это приведет так.
[01:37:28.060 --> 01:37:30.060]  Значит, надо выключить LOL.
[01:37:30.060 --> 01:37:34.060]  Вот, запускаем.
[01:37:34.060 --> 01:37:38.060]  Ну и уже, в общем, понятна мораль.
[01:37:38.060 --> 01:37:45.060]  Да, тут немного время изменилось, но все, собственно, в сети же в два раза, все тоже в два раза отличия.
[01:37:45.060 --> 01:37:50.060]  Когда-нибудь остановится.
[01:37:50.060 --> 01:37:54.060]  Ну, в общем, а, все, вот, 18 секунд.
[01:37:54.060 --> 01:37:57.060]  Понятно, что произошло или объяснить?
[01:37:57.060 --> 01:38:00.060]  Ладно, давайте объясним, в общем, на всякий случай.
[01:38:00.060 --> 01:38:02.060]  Как работает резерв?
[01:38:02.060 --> 01:38:05.060]  Значит, изначально у меня вектор имеет нулевой размер и нулевой capacity.
[01:38:06.060 --> 01:38:09.060]  Я здесь говорю, что мне нужно зарядировать память под один элемент.
[01:38:09.060 --> 01:38:12.960]  Хорошо, я создаю массив из одного элемента, добавляю его туда.
[01:38:12.960 --> 01:38:15.960]  На следующей тр Professional мне резерву говорит, нужно зарядить память по два элемента.
[01:38:15.960 --> 01:38:18.960]  Хорошо, я перевыделяю память на два элементы, добавляю элементы.
[01:38:18.960 --> 01:38:20.960]  А дальше мне говорит, перевыделить память по три элемента.
[01:38:20.960 --> 01:38:22.960]  Перевыделяю память по три элемента и так далее.
[01:38:22.960 --> 01:38:28.960]  То есть я каждый раз перевыделяю память и увеличиваю массив на единицу.
[01:38:28.960 --> 01:38:29.960]  Понятно, почему это плохо?
[01:38:29.960 --> 01:38:33.960]  То есть в итоге у нас все вылилось в квадратичную сложность этого цикла.
[01:38:33.960 --> 01:38:41.880]  нужно сделать один резерв заранее, а не много резервов. Мораль понятна, да? Можем идти дальше.
[01:38:41.880 --> 01:38:55.600]  С советом первым разобрались? Все разумно? Хорошо, значит, второй совет. Смотрите, мы знаем,
[01:38:55.600 --> 01:39:00.960]  что удаление из середины массива, оно достаточно долгое. То есть, если вы делаете eRace и удаляете
[01:39:00.960 --> 01:39:04.080]  элементы откуда-то из середины, то потенциально это работает за линейное время. Ну понятно,
[01:39:04.080 --> 01:39:09.480]  нужно удалить элемент и дальше все элементы сдвинуть на один влево. То есть, если удаляете,
[01:39:09.480 --> 01:39:13.880]  допустим, из начала, то это может привести к линейной сложности от размера всего массива.
[01:39:13.880 --> 01:39:18.360]  Так вот, есть трюк, который позволяет удалять вам элементы из массива, из вектора,
[01:39:18.360 --> 01:39:24.640]  ну и вообще из любого другого контейнера за единицу. Но, правда, при одном условии,
[01:39:24.640 --> 01:39:28.520]  что если вам действительно не важен порядок исследования элементов в векторе, то есть,
[01:39:28.520 --> 01:39:32.960]  если вам в векторе не важно, в каком порядке идут элементы, то вы можете это сделать за единицу.
[01:39:32.960 --> 01:39:35.960]  И трюк, на самом деле, очень простой. А у нас должна отображаться презентация?
[01:39:35.960 --> 01:39:45.640]  По идее, да. Давайте вернемся. Отлично. Ну в общем, да, вот то, что я говорил. Нам
[01:39:45.640 --> 01:39:52.520]  нужно удалить все элементы из середины вектора. Соответственно, это можно сделать за единицу,
[01:39:52.520 --> 01:39:55.520]  если вам не важен порядок исследования элементов. То есть, если вам не важно,
[01:39:55.520 --> 01:40:00.400]  то есть, если вам реально порядок элементов не важен, то есть, если у вас массив не отсортирован,
[01:40:00.400 --> 01:40:04.520]  или вы не требуете, чтобы этот элемент обязательно стоял на третьей позиции,
[01:40:04.520 --> 01:40:07.400]  этот элемент обязательно стоял на четвертой позиции, вы можете удалять элементы за единицу.
[01:40:07.400 --> 01:40:13.880]  Как это происходит? Ну, допустим, вам нужно удалить элемент х, вот этот элемент. Что вы делаете?
[01:40:13.880 --> 01:40:18.960]  Что мы знаем вообще про вектор? Мы знаем, что удалять из вектора эффективно можно только из конца.
[01:40:18.960 --> 01:40:26.640]  Поэтому давайте просто возьмем элемент у, который находится в конце, и переместим его на место х.
[01:40:26.640 --> 01:40:35.520]  То есть, выполним следующую строчку. В той позиции, где находится х, туда мувнем элемент с конца.
[01:40:35.520 --> 01:40:42.440]  То есть, теперь вот тут, после этой операции, на месте х у меня расположен у. Ну а на месте бывшего у
[01:40:42.440 --> 01:40:47.920]  теперь расположен какой-то пустой объект условно. И теперь этот пустой объект я могу спокойно удалить
[01:40:47.920 --> 01:40:54.360]  за единицу с помощью popback. Таким образом, получилось так, что я элемент из середины,
[01:40:54.360 --> 01:40:59.960]  то есть элемент х, удалил за от единицы. И при этом все остальные элементы у меня остались в векторе.
[01:40:59.960 --> 01:41:03.760]  Трюк понятен?
[01:41:03.760 --> 01:41:08.760]  Да.
[01:41:08.760 --> 01:41:15.440]  То есть, на практике довольно часто испортится, но опять же повторюсь еще раз, что если вам не
[01:41:15.440 --> 01:41:19.240]  важен порядок элементов в векторе, если у вас вектор отсортирован, естественно, это не работает.
[01:41:19.240 --> 01:41:24.320]  То есть, после этого у вас вектор не будет отсортирован. Я думаю, это понятно.
[01:41:24.320 --> 01:41:35.360]  Ну и еще одна очень популярная идеома или очень популярный прием, это erase-remove-идеома.
[01:41:35.360 --> 01:41:39.880]  Задача такая. Представьте себе, что вам нужно из вектора удалить все элементы, которые
[01:41:39.880 --> 01:41:43.880]  удовлетворяют определенному критерию. Ну, допустим, все четные элементы, все нечетные, или все
[01:41:43.880 --> 01:41:49.320]  элементы равные нулю. Но в данном случае я удаляю все элементы, которые равны нулю.
[01:41:49.320 --> 01:41:56.160]  Как можно сделать, не зная эту erase-remove-идеома?
[01:41:56.160 --> 01:42:02.600]  Можно сделать так. Мы просто проходится по массиву, и если я встречаю ноль, то вызывать erase.
[01:42:02.600 --> 01:42:08.640]  Если я встречал ноль, то я вызываю erase, если я встречал мне ноль, то я просто увеличиваю счетчик на единицу,
[01:42:08.640 --> 01:42:12.520]  перехожу к следующему элементу и так далее. Естественно, это работает в худшем случае за n квадрат.
[01:42:12.520 --> 01:42:16.680]  Почему? Ну, потому что вы там проходите по всем элементам, и для каждого элемента потенциально
[01:42:16.680 --> 01:42:22.680]  вызываете erase, а erase работает за линейное время. Поэтому идея заключается в следующем.
[01:42:22.680 --> 01:42:26.920]  Идея заключается в том, чтобы использовать последовательность из двух алгоритмов.
[01:42:26.920 --> 01:42:31.560]  Первый алгоритм — это remove, а второй — это erase. Что делает remove?
[01:42:31.560 --> 01:42:41.920]  Вот, допустим, у вас есть вот такой массив. Значит, если вы вызвали remove 0, то есть если вы говорите
[01:42:41.920 --> 01:42:49.440]  убрать все нули из этого вектора, то на самом деле std remove, вот эта вот функция, она не удаляет их,
[01:42:49.440 --> 01:42:54.240]  она просто переупорядочивает ваш массив так, чтобы все нули или все те объекты, которые вы
[01:42:54.240 --> 01:42:58.600]  просили, чтобы они оказались в конце. То есть после вызова remove у вас получится вот такой массив —
[01:42:58.600 --> 01:43:07.920]  1,24, 0,0,0. При этом remove работает за линейное время, ну и это, на самом деле, наверное, неплохое
[01:43:07.920 --> 01:43:11.880]  упражнение. То есть попробуйте самостоятельно резать remove, то есть вот такой вот remove,
[01:43:11.880 --> 01:43:14.880]  который принимает значение, и переупорядочивает элементы так, чтобы все остались в конце,
[01:43:14.880 --> 01:43:21.240]  а относительный порядок всех остальных элементов, то есть 1,24, например, остался таким же. То есть не
[01:43:21.240 --> 01:43:26.720]  просто поставить все элементы в конец, а те, которые не равны 0, поставить в начало, а переставить именно так,
[01:43:26.720 --> 01:43:32.840]  чтобы относительный порядок элементов сохранился, но при этом все нули остались в конце. Этим занимается
[01:43:32.840 --> 01:43:37.120]  remove, и remove умеет это делать за линейное время. И теперь смотрите, теперь у меня все нужные мне
[01:43:37.120 --> 01:43:41.080]  элементы, то есть те элементы, которые нужно удалить, они оказались в конце. Ну а с конца я умею
[01:43:41.080 --> 01:43:46.440]  удалить эффективно, причем я могу их удалить, да и с конца я могу удалить довольно эффективно,
[01:43:46.440 --> 01:43:51.560]  за линейное время. То есть я вызываю erase и говорю, что мне нужно удалить все элементы от begin,
[01:43:51.560 --> 01:44:02.400]  то есть вот этого элемента, до конца массива, то есть до end. Это zeros, begin, а это end. Да, ну тут
[01:44:02.400 --> 01:44:07.680]  надо сказать о том, что такое zeros, begin, но дело в том, что функция stay-remove, она возвращает указатель
[01:44:07.680 --> 01:44:18.080]  вот zeros, begin, она возвращает указатель на первый, то есть на первый удаленный элемент, точнее на
[01:44:18.080 --> 01:44:22.800]  первый элемент, который там был перемещен вправо, ну точнее на начало вот этой самой концевой
[01:44:22.800 --> 01:44:27.560]  последовательности. Вот и дальше вы, начиная с этого элемента и до конца, удаляете все элементы.
[01:44:27.560 --> 01:44:31.240]  Естественно, это тоже происходит за линейное время. Все, то есть мы таким образом улучшили
[01:44:31.240 --> 01:44:35.280]  сложность нашего алгоритма, удаление всех элементов, всех элементов, которые удовлетворяют
[01:44:35.280 --> 01:44:42.800]  некоторому критерию, с квадратичной до линейной. Здесь тоже все понятно, да?
[01:44:42.800 --> 01:44:58.680]  Да. Ну отлично. Так, ну на этом, видимо, с вектором все. Давайте идти к следующим контейнерам. Ну и
[01:44:58.680 --> 01:45:04.280]  следующий контейнер на очереди это std-deck. std-deck представляет из себя шаблонный класс в двунаправленной
[01:45:04.280 --> 01:45:10.000]  очереди, и вообще говоря, std-deck ведет себя ровно так же, как std-vector, то есть с деком можно делать
[01:45:10.000 --> 01:45:14.920]  то же самое, что и с вектором, то есть добавлять элементы в конец, там обращаться к элементам по индексу
[01:45:14.920 --> 01:45:18.920]  за вот единицы, там узнавать его размер, ну и так далее, и так далее. В общем, дек это, по сути,
[01:45:18.920 --> 01:45:34.120]  обычный вектор, но с парой изменений. Дек, помимо того, что позволяет эффективно добавлять
[01:45:34.120 --> 01:45:39.520]  элементы в конец, он еще позволяет добавлять элементы в начало за вот единицы, то есть вектор,
[01:45:39.520 --> 01:45:43.640]  естественно, такого делать не может, потому что это обычный массив, а в дек, в направленную очередь,
[01:45:43.640 --> 01:45:50.320]  вы можете добавлять элементы и в начало, и ударять из начала за от единицы. Ну и так же у него,
[01:45:50.320 --> 01:45:55.880]  в отличие от вектора, нет методов reserve и capacity, но при этом есть shrink to fit. Ну, просто дело в том,
[01:45:55.880 --> 01:46:03.040]  что дек устроен несколько иначе, чем вектор, об этом мы еще поговорим. Значит, еще одна ипостаси дека,
[01:46:03.040 --> 01:46:11.240]  в чем дек, скажем так, лучше, чем вектор. Давайте посмотрим на следующий пример. Вот у меня есть
[01:46:11.240 --> 01:46:17.840]  вектор, и я в какой-то момент сохранил ссылку на пятый элемент вектора. То есть у меня есть
[01:46:17.840 --> 01:46:27.080]  int % x, я сохранил ссылку на пятый элемент. Дальше я вызываю pushback и говорю x равно нулю. Что здесь
[01:46:27.080 --> 01:46:34.600]  может пойти не так? Как вы думаете? У нас вектор перекопировался в другое место, и x уже указывает
[01:46:34.600 --> 01:46:40.120]  на не ту область памяти, которая нам нужна. Да, смотрите, что происходит. То есть у вас есть
[01:46:40.120 --> 01:46:45.760]  массив, вы взяли там пятый элемент и сохранили ссылку x вот сюда. Дальше вы выполнили pushback,
[01:46:45.760 --> 01:46:50.920]  и так могло получиться, что pushback просто взял и расширил ваш массив. А что такое расширение
[01:46:50.920 --> 01:46:58.640]  массива? Расширение массива — это удаление старого и создание нового. И теперь у вас x ссылается или
[01:46:58.640 --> 01:47:03.280]  указывает на элемент, который, по сути, уже удален, то есть который вам вообще не принадлежит. И вот
[01:47:03.280 --> 01:47:07.240]  такая ситуация называется инвалидация ссылок. То есть если вы в какой-то момент сохранили указатель или
[01:47:07.240 --> 01:47:14.040]  ссылку в середину массива, в какой-то элемент массива, то в определенный момент, даже если вы этот
[01:47:14.040 --> 01:47:17.960]  элемент никак не удаляли, то есть никак его не изменяли, он может просто-напросто инвалидироваться.
[01:47:17.960 --> 01:47:24.600]  То есть вот так, короче говоря, этой ссылкой указателем нельзя больше пользоваться в какой-то
[01:47:24.600 --> 01:47:30.280]  момент. Потому что у вас вектор периодически расширяется или уменьшает свой размер, а это
[01:47:30.280 --> 01:47:34.680]  происходит при этом при этом происходит перевыделение памяти, и теперь ваш x или ваш
[01:47:34.680 --> 01:47:39.520]  указатель ссылается на область памяти, которая, вообще говоря, не принадлежит вам. Это, естественно,
[01:47:39.520 --> 01:47:48.400]  defined behavior и все плохо. Так вот, дек таким такой проблемой не обладает. Тоже самое
[01:47:48.400 --> 01:47:54.560]  может произойти с указателем, вот здесь все показано. Так вот, дек таким проблем не
[01:47:54.560 --> 01:48:00.400]  обладает. То есть дек, даже несмотря на то, что дек действительно, то есть дек тоже, как и вектор,
[01:48:00.400 --> 01:48:06.760]  он расширяется. Дек тоже может там динамически измерять свой размер и так далее, но при этом дек
[01:48:06.760 --> 01:48:11.560]  всегда позволяет вам обращаться по указателю, по ссылке к тем элементам, которые вы не трогали.
[01:48:11.560 --> 01:48:16.760]  То есть если вы элемент никак не удаляли, не удаляли элементы перед ним и так далее, то есть
[01:48:16.760 --> 01:48:23.080]  вообще никак не двигали, то ссылки и указатели, они всегда валидные. Даже если вы выполнили pushback
[01:48:23.080 --> 01:48:29.800]  и теоретически pushback привел к увеличению памяти, все остается нормально. То есть дек не
[01:48:29.800 --> 01:48:35.000]  инвалидирует ссылки и указатели. Вот еще один момент. То есть дек, в отличие от вектора, умеет
[01:48:35.000 --> 01:48:40.760]  эффективно добавлять в начало и удалять из начала. Второе, дек умеет, ну дек не инвалидирует ссылки
[01:48:40.760 --> 01:48:44.920]  и указатели. Соответственно, вроде как получается, что дек это некоторая такая улучшенная версия вектора,
[01:48:44.920 --> 01:48:50.280]  и зачем нам вообще вектор, если есть такой замечательный дек. Ну, как вы понимаете,
[01:48:50.280 --> 01:48:56.000]  собственно, бесплатных обедов не бывает, но фриланч. То есть за все приходится платить. Но, естественно,
[01:48:56.000 --> 01:49:03.000]  дек, несмотря на то, что он такой крутой, естественно, на это все, на поддержание вот этих свойств приходится
[01:49:03.000 --> 01:49:08.360]  тратить какие-то ресурсы. Какие-то ресурсы по памяти, какие-то ресурсы по времени. И вот тут нужно
[01:49:08.360 --> 01:49:12.480]  коротко поговорить про то, как устроен дек. Значит, я не буду подробно на этом останавливаться. В общем,
[01:49:12.480 --> 01:49:18.880]  совсем коротко это выглядит так. Давайте, главная проблема, как мне поддержать возможность
[01:49:18.880 --> 01:49:24.760]  эффективного добавления в начало, добавление в конец и не инвалидации ссылок и указателей.
[01:49:24.760 --> 01:49:34.000]  Все устроено следующим образом. Представь себе, что у меня есть такой дек. Ну, сейчас я нарисую и
[01:49:34.000 --> 01:49:47.440]  поясню, что я имею ввиду. Значит, дек устроен примерно вот таким образом. Это front, это back. Значит,
[01:49:47.520 --> 01:49:55.600]  как устроен дек? Дек на самом деле хранит внутри себя массив, массив указателей на динамические
[01:49:55.600 --> 01:50:02.320]  массивы. То есть дек – это массив указателей на динамические массивы. То есть каждый вот это динамический
[01:50:02.320 --> 01:50:06.780]  массив, он хранит внутри себя данные. При этом, как все устроено. То есть, данные расположены
[01:50:06.780 --> 01:50:10.460]  последовательно. Последовotechnology друг за другом. То есть, это нулевой элемент, это первый,
[01:50:10.460 --> 01:50:13.200]  Это будет 3, первый, второй, второй, это второй, 3, 4, 5, и так далее.
[01:50:13.200 --> 01:50:17.340]  То есть, вы идёте по одному динамическому массиву.
[01:50:17.340 --> 01:50:18.700]  However, once the dynamic mass is finished,
[01:50:18.700 --> 01:50:21.340]  вы переходите к следующему динамическому массиву
[01:50:21.340 --> 01:50:24.100]  и начинаете проходить по нему.
[01:50:24.100 --> 01:50:27.580]  Все динамические массивы расположены друг при другу,
[01:50:27.580 --> 01:50:30.940]  но их указатели расположены друг за другом.
[01:50:30.940 --> 01:50:33.580]  Поэтому, вы понимаете, какой массив за каким следует,
[01:50:33.580 --> 01:50:38.880]  что происходит при добавлении элемента, скажем, в начало, вот здесь.
[01:50:38.880 --> 01:50:44.280]  Допустим, я добавил кучу элементов начала. Что у меня произошло? Давайте посмотрим.
[01:50:44.280 --> 01:50:52.480]  Значит, если я надобавлял кучу элементов начала, то у меня центральный массив целиком заполнился.
[01:50:52.480 --> 01:50:57.680]  Соответственно, так у меня центральный массив целиком заполнился, и мне больше некуда добавлять элементов начала,
[01:50:57.680 --> 01:51:06.680]  я перехожу на ступень выше, то есть вот в эту ячейку, и там создаю, ну скажем, новый дополнительный динамический массив.
[01:51:06.680 --> 01:51:20.680]  И начинаю заполнять его. Теперь это фронт. Но тут back остаётся на месте. Вот так.
[01:51:20.680 --> 01:51:28.680]  То есть таким образом я поддерживаю операцию добавления за единицу. То есть я либо за единицу добавляю элементы в нужный мне массивчик,
[01:51:28.680 --> 01:51:34.680]  либо если у меня места не хватает, я просто выделяю дополнительную память, то есть сохраняю вот сюда новый указатель на буфер,
[01:51:34.680 --> 01:51:42.680]  и начинаю заполнять его. То же всё происходит за единицу. Что если у меня вот этот вот внешний массив,
[01:51:42.680 --> 01:51:46.680]  что если у меня у внешнего массива закончилась память? Ну я могу сделать, например, следующую вещь.
[01:51:46.680 --> 01:51:55.680]  Я могу сам внешний массив расширить. Вот эти у меня три массива, которые у меня были до этого.
[01:51:55.680 --> 01:52:03.680]  И просто перенести указатели вот сюда. Ну точнее, давайте более корректно нарисуем.
[01:52:03.680 --> 01:52:15.680]  Вот я расширил внешний массив и просто перекинул указатели на старые массивчики, которые у меня были до этого.
[01:52:15.680 --> 01:52:24.680]  Ну а это, естественно, удалился. И таким образом становится понятно, почему у меня не инвалидируются ссылки указателя.
[01:52:24.680 --> 01:52:31.680]  Потому что у меня, если у меня есть какая-то ссылка X, которая ведет вот сюда, то даже при приведении памяти она останется на месте.
[01:52:31.680 --> 01:52:37.680]  Потому что сами вот эти массивы, я никуда не... ну то есть я с ними ничего не делаю. Я их не удаляю, я их не расширяю.
[01:52:37.680 --> 01:52:44.680]  Расширяется у меня лишь внешний массив, который хранит указатели. Ну и теперь, соответственно, если мне нужно добавить элементы какие-то в конец,
[01:52:44.680 --> 01:52:58.680]  и вот этот массив у меня допустим заполнен, то я расширил массив указателей, и дальше в этот массив добавляю очередной внутренний массив.
[01:52:58.680 --> 01:53:12.680]  И теперь вот это back. Понятно? То есть у меня ссылки и указатели не инвалидируются,
[01:53:12.680 --> 01:53:23.680]  потому что сами вот эти массивы, где хранятся элементы, с ними ничего не происходит. То есть я их не перевыделяю, они просто как были выделены в памяти, так они и остаются.
[01:53:23.680 --> 01:53:29.680]  То есть единственное, что меня перевыделяется, это вот этот самый внешний массив, который содержит указатели.
[01:53:29.680 --> 01:53:35.680]  Ну а когда я выделяю новый массив с указателями, мне достаточно просто эти указатели скопировать быстро, и все.
[01:53:35.680 --> 01:53:45.680]  То есть перенос старых данных в новые происходит просто переносом указателей, и все. При этом сами массивы, которые хранят данные, они остаются на месте.
[01:53:45.680 --> 01:53:54.680]  Ну и понятно, что в такой парадигме можно реализовать и доступ по индексу за единицу, и в общем доступ по индексу тоже можно определить за единицу.
[01:53:54.680 --> 01:53:59.680]  То есть если вы находитесь в начале здесь, то я думаю понятно, как определить, где находится n-тый элемент.
[01:53:59.680 --> 01:54:04.680]  То есть вы просто смотрите, сколько элементов здесь, ну и даже смотрите просто количество заполненных массивов здесь.
[01:54:04.680 --> 01:54:18.680]  То есть просто за несколько операций деления понимаете, в какой массив вам нужно прийти, и в какой ячейке этого массива находится нужный вам элемент.
[01:54:18.680 --> 01:54:24.680]  Все понятно.
[01:54:24.680 --> 01:54:35.680]  Ну и естественно за это удовольствие приходится платить, в частности. В чем тут неэффективность?
[01:54:35.680 --> 01:54:43.680]  Ну я думаю понятно, что доступ к элементу по индексу происходит гораздо дольше, чем в случае вектора.
[01:54:43.680 --> 01:54:50.680]  То есть в векторе вам нужно просто выполнить адресную арифметику. То есть взять начало и отступить, там нужно количество шагов вправо.
[01:54:50.680 --> 01:55:00.680]  В случае с тдек вам нужно выполнять деление, вычислить, в каком массивчике у вас хранится элемент, дальше внутри этого массива понять, в какой ячейке у вас находится элемент.
[01:55:00.680 --> 01:55:05.680]  В общем доступ по индексу у вас происходит дольше. Плюс тдек хранит свои данные не непрерывно.
[01:55:05.680 --> 01:55:14.680]  То есть если вектор хранит свои данные непрерывно в памяти, то тдек хранит свои данные в несколько разрозненном виде.
[01:55:14.680 --> 01:55:21.680]  То есть этот массив может находиться в одном месте в памяти, этот массив может находиться в другом месте памяти, третий массив вообще в третьем месте в памяти.
[01:55:21.680 --> 01:55:26.680]  Но естественно вот такие вот прыжки по памяти они тоже ни к чему хорошему не приводят.
[01:55:26.680 --> 01:55:33.680]  А вектор позволяет довольно эффективно, когда вы сгружаете данные из вектора, то есть вам можно загрузить целую область памяти целиком,
[01:55:33.680 --> 01:55:40.680]  и дальше она в кэше процессора быстро обрабатывается, и все работает гораздо быстрее.
[01:55:40.680 --> 01:55:45.680]  Ну в общем мораль, используйте старый добрый принцип C++, не плати за то, что не используешь.
[01:55:45.680 --> 01:55:56.680]  То есть если вам реально не нужны вставки в начало, если вам реально не нужно использовать инвалидацию ссылок или указателей, то вам дек на самом деле не нужен.
[01:55:56.680 --> 01:56:07.680]  Как правило в 95% случаев вам нужен вектор, и вектор работает быстро, эффективно, и все. Вот такая мораль.
[01:56:07.680 --> 01:56:16.680]  Ну и дальше давайте коротко пройдемся по спискам, потом сделаем перерыв.
[01:56:16.680 --> 01:56:25.680]  В качестве списочного контейнера в языке C++ есть такой класс, как std-list.
[01:56:25.680 --> 01:56:28.680]  std-list – это шаблонный класс двухсвязанного списка.
[01:56:28.680 --> 01:56:32.680]  Ну понятно, какие у него методы есть. У него есть методы pushback, pushfront, emplacement, emplacement.
[01:56:32.680 --> 01:56:35.680]  Ну в общем все то же самое, что есть у дека или у вектора.
[01:56:35.680 --> 01:56:40.680]  Понятно, что в связной списке вы можете добавлять элементы как конец, так и в начало, причем все зовут единицы.
[01:56:40.680 --> 01:56:48.680]  Вы можете обратиться к первому элементу списка, к последнему элементу списка с помощью метода front и back.
[01:56:48.680 --> 01:56:52.680]  А вот к остальным элементам списка обратиться довольно сложно.
[01:56:52.680 --> 01:56:57.680]  Дело в том, что у листа нет квадратных скобок и нет методы add.
[01:56:57.680 --> 01:57:02.680]  Ну понятно почему, потому что вы обратитесь к третьему элементу листа, вы не можете просто воспользоваться квадратными скобками.
[01:57:02.680 --> 01:57:07.680]  То есть вы не можете просто сказать, что давайте от первого элемента возьмем плюс три и сразу прыгнем туда.
[01:57:07.680 --> 01:57:12.680]  Все-таки лист – это связанная списка, и чтобы получить третий элемент, вам нужно последовательно пройтись по трем элементам.
[01:57:12.680 --> 01:57:16.680]  И чтобы это сделать, вам нужно использовать такую штуку как итератор.
[01:57:16.680 --> 01:57:20.680]  Которую я планировал рассказать сегодня, но посмотрим как получится, возможно в следующий раз.
[01:57:20.680 --> 01:57:25.680]  Ну так или иначе, доступ к элементам листа осуществляется с помощью итератора.
[01:57:25.680 --> 01:57:35.680]  Ну и так как лист устроен как двухсвязанный список, вставка и удаление в любое место списка осуществляется за единицу.
[01:57:35.680 --> 01:57:40.680]  Ну я думаю понятно, что если вам нужно вставить элемент в какую-то позицию, то как это происходит?
[01:57:40.680 --> 01:57:45.680]  Ну вы просто перевешиваете указатель сюда, вы сюда, и вот так.
[01:57:45.680 --> 01:57:52.680]  То есть вы просто провязываете четыре указателя, и все работает быстро за единицу.
[01:57:52.680 --> 01:57:57.680]  Ну и понятно, что в отличие от вектора, он не инвалидирует ссылки указателей на элементы.
[01:57:57.680 --> 01:58:02.680]  То есть если у вас есть этот элемент, то неважно, вставили ли вы элементы после него, вставили ли вы элементы до него.
[01:58:02.680 --> 01:58:07.680]  Ссылка на этот элемент всегда будет жить, то есть она всегда будет корректной.
[01:58:07.680 --> 01:58:11.680]  Потому что сама ячейка, сам узел, он остается в памяти всегда.
[01:58:11.680 --> 01:58:15.680]  Не важно, вставили в начало, вставили в конец.
[01:58:15.680 --> 01:58:20.680]  Про список, что самое главное, наверное, нужно знать, это про методы splice.
[01:58:20.680 --> 01:58:28.680]  То есть это, наверное, та операция, которая позволит вам довольно эффективно пользоваться стелестом.
[01:58:28.680 --> 01:58:33.680]  Ну смотрите, допустим, у вас есть два списка, там ваш список и какой-то другой список.
[01:58:33.680 --> 01:58:37.680]  И вам нужно быстро перенести элементы из одного списка в другой список.
[01:58:37.680 --> 01:58:40.680]  Естественно, вы можете воспользоваться методами insert и erase.
[01:58:40.680 --> 01:58:46.680]  То есть вы можете сделать insert well, то есть вызвать insert, и дальше вызвать erase у other.
[01:58:46.680 --> 01:58:49.680]  То есть вставить элемент в well и удалить у other.
[01:58:49.680 --> 01:58:54.680]  И тут есть небольшая неэффективность, которая заключается в том, что при вставке элемента в well,
[01:58:54.680 --> 01:58:57.680]  то у вас, естественно, создается некоторый новый узел.
[01:58:57.680 --> 01:58:59.680]  То есть условно создается новая нода.
[01:58:59.680 --> 01:59:03.680]  То есть это не то, как устроено C++, ну просто как бы в алгоритмическом смысле.
[01:59:04.680 --> 01:59:11.680]  На вас есть указатель на prev, у вас есть указатель на next, и у вас есть сам элемент value.
[01:59:11.680 --> 01:59:14.680]  Так вот, когда вы вызываете insert, у вас создается новая вершина.
[01:59:14.680 --> 01:59:17.680]  То есть вы создаете новую вершину, и только потом ее вставляете в список.
[01:59:17.680 --> 01:59:21.680]  А дальше берете другой вектор и оттуда удаляете старую вершину.
[01:59:21.680 --> 01:59:28.680]  Так вот, смотрите, если у вас в другом списке, вот здесь какой-то другой список.
[01:59:28.680 --> 01:59:33.680]  Вот если у вас есть, если у вас в другом списке, если вы хотите взять этот элемент и перенести его в новый список,
[01:59:33.680 --> 01:59:38.680]  вы же можете просто взять и этот узел, без создания, просто взять и украсть к себе.
[01:59:38.680 --> 01:59:40.680]  Да, то есть это гораздо эффективнее.
[01:59:40.680 --> 01:59:43.680]  И ровно этим и занимается splice.
[01:59:43.680 --> 01:59:46.680]  Вот, то есть как работает splice.
[01:59:46.680 --> 01:59:48.680]  Значит, у splice есть три формы.
[01:59:48.680 --> 01:59:55.680]  Первая форма это, когда вы задаете конкретную позицию, скажем, вот у вас есть ваш список,
[01:59:55.680 --> 01:59:58.680]  и есть какой-то другой список, давайте я его так изображу.
[01:59:58.680 --> 02:00:02.680]  И допустим, вы хотите вставить элемент вот на эту позицию.
[02:00:02.680 --> 02:00:06.680]  То есть вы хотите, чтобы в этой позиции теперь стояли все элементы другого списка.
[02:00:06.680 --> 02:00:09.680]  Ну тогда вы вызываете splice, и у вас происходит следующая картина.
[02:00:09.680 --> 02:00:12.680]  Давайте, один, два, три, четыре.
[02:00:12.680 --> 02:00:14.680]  Теперь тут становится элемент один.
[02:00:14.680 --> 02:00:18.680]  Дальше, после элемента один, в позиции один встал другой список.
[02:00:18.680 --> 02:00:21.680]  То есть вы просто взяли и все узлы перенесли туда.
[02:00:21.680 --> 02:00:23.680]  То есть просто перенесли ссылки.
[02:00:23.680 --> 02:00:28.680]  И заполнили дальше элементами 3 и 4.
[02:00:28.680 --> 02:00:31.680]  Вот это первая форма splice.
[02:00:31.680 --> 02:00:38.680]  Вторая форма splice позволяет перенести вам не все элементы другого списка сразу,
[02:00:38.680 --> 02:00:40.680]  а только один элемент.
[02:00:40.680 --> 02:00:42.680]  Ну, я думаю, тоже понятно.
[02:00:42.680 --> 02:00:46.680]  Вот у вас есть один список, вот у вас есть другой список.
[02:00:46.680 --> 02:00:49.680]  Вы хотите вот этот элемент перенести вот на эту позицию.
[02:00:49.680 --> 02:00:55.680]  При этом на этот элемент у вас есть итератор elm.
[02:00:55.680 --> 02:00:57.680]  Но опять же, что-то по итераторам поговорим в следующий раз.
[02:00:57.680 --> 02:01:01.680]  Просто можно считать, что это некоторый указатель на элемент.
[02:01:01.680 --> 02:01:03.680]  У вас есть указатель elm на этот элемент.
[02:01:03.680 --> 02:01:07.680]  У вас есть позиция pos, в которую нужно вставить этот элемент.
[02:01:07.680 --> 02:01:08.680]  И вы делаете splice.
[02:01:08.680 --> 02:01:10.680]  И splice устроен в следующем образом.
[02:01:10.680 --> 02:01:16.680]  Вы просто берете и провязываете указатели с этим списком.
[02:01:16.680 --> 02:01:18.680]  А эту связь разрываете.
[02:01:18.680 --> 02:01:22.680]  Все, то есть никаких затрат на создание нового узла у вас не уходит.
[02:01:22.680 --> 02:01:25.680]  То есть вы просто как бы меняете указатели списка друг другу, и все.
[02:01:25.680 --> 02:01:33.680]  Ну и есть третья форма splice, которая позволяет, скажем, ну опять же, давайте нарисуем.
[02:01:33.680 --> 02:01:37.680]  Вот у вас есть такой список, и у вас есть вот такой другой список.
[02:01:37.680 --> 02:01:43.680]  И вы хотите перенести, скажем, не один элемент из другого списка и не весь список целиком.
[02:01:43.680 --> 02:01:48.680]  А вы хотите перенести конкретные элементы, скажем, вот отсюда до сюда.
[02:01:48.680 --> 02:01:54.680]  Ну, естественно, полуинтервал, то есть по последним не включите.
[02:01:54.680 --> 02:01:59.680]  То есть, по сути, вы хотите взять вот эти элементы и перенести их вот в эту позицию.
[02:01:59.680 --> 02:02:03.680]  Вот взять вот эти элементы и перенести их в позицию номер один.
[02:02:03.680 --> 02:02:08.680]  И тут возникает интересный вопрос, а за сколько работает вообще вот этот splice?
[02:02:08.680 --> 02:02:12.680]  И в догонку новый вопрос, а за сколько работает метод size внезапно?
[02:02:12.680 --> 02:02:18.680]  Так вот, ответ заключается в следующем.
[02:02:18.680 --> 02:02:24.680]  Дело в том, что вот этот splice, ну несмотря на то, что его можно реализовать за единицу, как вы понимаете,
[02:02:24.680 --> 02:02:27.680]  то есть тоже можно просто взять вот этот указатель, провязать сюда,
[02:02:27.680 --> 02:02:29.680]  взять этот указатель, провязать сюда.
[02:02:29.680 --> 02:02:35.680]  То есть тоже поменять значение четырех указателей, и по сути, вы получите то же самое.
[02:02:35.680 --> 02:02:40.680]  Но проблема заключается в том, что если бы это можно было делать за единицу,
[02:02:40.680 --> 02:02:45.680]  то если бы это реально было реализовано так, то нельзя было реализовать size за единицу.
[02:02:45.680 --> 02:02:46.680]  Понимаете почему?
[02:02:46.680 --> 02:02:52.680]  Понимаете почему, вот если бы splice работал за единицу, то size обязан было бы работать за o от n.
[02:02:57.680 --> 02:02:59.680]  Понимаете ли вы почему так?
[02:03:06.680 --> 02:03:09.680]  Ну хорошо, объясню. Да-да, слушаю.
[02:03:11.680 --> 02:03:18.680]  Ну, при вставке за единицу мы просто привязываем начало и конец,
[02:03:18.680 --> 02:03:20.680]  и мы не знаем, сколько элементов было между ними.
[02:03:20.680 --> 02:03:22.680]  Да, отлично.
[02:03:22.680 --> 02:03:24.680]  То есть нам нужно пройти и посчитать их.
[02:03:24.680 --> 02:03:27.680]  Да, правильно. Смотрите, если у меня splice выполнен за единицу,
[02:03:27.680 --> 02:03:31.680]  ну смотрите, вот в данной версии splice я не знаю, сколько.
[02:03:34.680 --> 02:03:37.680]  Сколько элементов я переставил из одного списка в другой?
[02:03:37.680 --> 02:03:40.680]  Смотрите, если я переставляю элементы одного списка в другой список,
[02:03:40.680 --> 02:03:49.680]  то мне нужно как-то обновить l.size и надо как-то обновить other.size.
[02:03:50.680 --> 02:03:52.680]  Но я не знаю, сколько элементов.
[02:03:52.680 --> 02:03:57.680]  Чтобы мне посчитать количество элементов между первым элементом списка и вторым элементом списка,
[02:03:57.680 --> 02:03:59.680]  мне нужно их как-то посчитать.
[02:03:59.680 --> 02:04:05.680]  Если я не хочу их считать, то тогда я должен как бы смириться с тем, что size обновить я не смогу.
[02:04:05.680 --> 02:04:08.680]  И поэтому size я обязан всегда считать за o от n.
[02:04:08.680 --> 02:04:10.680]  Ну как происходит подсчет элементов в списке?
[02:04:10.680 --> 02:04:15.680]  Ну просто прохожусь от начала до конца, и сколько элементов встретил, столько такой у меня размер.
[02:04:15.680 --> 02:04:17.680]  Либо наоборот.
[02:04:17.680 --> 02:04:19.680]  Либо я должен выполнять splice за o от n.
[02:04:19.680 --> 02:04:25.680]  Ну в смысле, мой splice должен честно считать, сколько элементов он переносит из одного списка в другой.
[02:04:25.680 --> 02:04:28.680]  Ну тогда в этом случае я могу обеспечить size за единицу.
[02:04:28.680 --> 02:04:33.680]  То есть возникает чуть ли не моральный выбор, что я хочу.
[02:04:33.680 --> 02:04:37.680]  Я хочу эффективно выполнять splice, или я хочу всегда эффективно выполнять size.
[02:04:37.680 --> 02:04:43.680]  И вот в этом смысле комитет по стандартизации C++ принял решение,
[02:04:43.680 --> 02:04:51.680]  что лучше size за o от единицы, чем splice в такой форме за o от единицы.
[02:04:51.680 --> 02:04:55.680]  Поэтому splice в такой форме у вас работает за линейное время.
[02:04:55.680 --> 02:04:59.680]  То есть даже несмотря на то, что чисто алгоритмически это можно сделать за единицу,
[02:04:59.680 --> 02:05:04.680]  в списке Vistadlist это происходит за линейное время.
[02:05:04.680 --> 02:05:08.680]  Но зато у вас в списке Vistadlist size работает за единицу,
[02:05:08.680 --> 02:05:14.680]  и вы всегда за единицу можете узнать, какой размер вашего списка.
[02:05:14.680 --> 02:05:17.680]  Вопросы?
[02:05:24.680 --> 02:05:25.680]  Хорошо.
[02:05:25.680 --> 02:05:28.680]  Ну и наконец forward list.
[02:05:28.680 --> 02:05:30.680]  Там был вопрос в чате.
[02:05:30.680 --> 02:05:33.680]  Да, так я чат не включил.
[02:05:33.680 --> 02:05:39.680]  Что будет, если вызвать splice, то есть beginn поменять местами,
[02:05:39.680 --> 02:05:41.680]  просто не скомплируйтесь за заключение какой-то или что-то еще.
[02:05:41.680 --> 02:05:43.680]  А, да, еще важный момент, который не сказал про splice.
[02:05:43.680 --> 02:05:47.680]  Посмотрите, если у вас adder совпадает с l,
[02:05:47.680 --> 02:05:52.680]  ну, то есть если вы вызываете l.splice, там что-то, что-то, l и так далее.
[02:05:52.680 --> 02:05:55.680]  То есть если вы переносите элементы внутри одного и того же списка,
[02:05:55.680 --> 02:05:57.680]  то это работает за от единицы.
[02:05:57.680 --> 02:06:01.680]  Понятное дело, что если вы переносите элементы из списка в сам себя,
[02:06:01.680 --> 02:06:03.680]  то у вас размер не меняется.
[02:06:03.680 --> 02:06:05.680]  Поэтому в этом случае можно гарантировать splice за единицу.
[02:06:05.680 --> 02:06:07.680]  И это так работает.
[02:06:07.680 --> 02:06:10.680]  Теперь вопрос. Что будет, если begin и end поменять местами?
[02:06:10.680 --> 02:06:13.680]  UndefinedBehaviour.
[02:06:13.680 --> 02:06:16.680]  Ожидается, что если вы передали begin и end,
[02:06:16.680 --> 02:06:19.680]  то у вас begin находится слева, а end находится справа.
[02:06:19.680 --> 02:06:23.680]  Если вы сделали по-другому, то есть если вы сказали, что это begin, а это end,
[02:06:23.680 --> 02:06:25.680]  то что будет происходить?
[02:06:25.680 --> 02:06:27.680]  Ну, он будет просто идти с...
[02:06:27.680 --> 02:06:29.680]  А, сейчас.
[02:06:29.680 --> 02:06:31.680]  А это интересный вопрос.
[02:06:31.680 --> 02:06:33.680]  Ну, вообще, давайте так.
[02:06:33.680 --> 02:06:36.680]  Наверное, с точки зрения стандарта, формально, это undefinedBehaviour,
[02:06:36.680 --> 02:06:41.680]  потому что все-таки std list ожидает, что у вас begin находится левее, чем end.
[02:06:41.680 --> 02:06:43.680]  Но что произойдет на практике?
[02:06:43.680 --> 02:06:45.680]  Наверное, произойдет довольно интересный эффект.
[02:06:45.680 --> 02:06:47.680]  У вас вот этот элемент...
[02:06:47.680 --> 02:06:51.680]  Условно, этот элемент пойдет вот сюда.
[02:06:55.680 --> 02:06:58.680]  Нет, я все-таки думаю, ничего хорошего не будет,
[02:06:58.680 --> 02:07:00.680]  потому что ничего хорошего не будет.
[02:07:00.680 --> 02:07:03.680]  То есть вы говорите begin и end, что они идут слева направо,
[02:07:03.680 --> 02:07:05.680]  они на самом деле идут справа налево,
[02:07:05.680 --> 02:07:07.680]  поэтому там многое испортится.
[02:07:07.680 --> 02:07:10.680]  Потому что begin, например, ожидает, что next у него будет там,
[02:07:10.680 --> 02:07:12.680]  а next у него на самом деле там.
[02:07:12.680 --> 02:07:14.680]  Ну, в общем, беда будет, так нельзя.
[02:07:14.680 --> 02:07:17.680]  То есть begin обязательно должен стоять левее end.
[02:07:17.680 --> 02:07:19.680]  Ну, точнее, не правее end.
[02:07:21.680 --> 02:07:23.680]  Ну, ошибки эмпиляции, естественно, не будет.
[02:07:23.680 --> 02:07:26.680]  То есть компилятор не умеет проверять, где у вас там begin, где у вас там end.
[02:07:26.680 --> 02:07:28.680]  Это полностью на вашей совести.
[02:07:28.680 --> 02:07:32.680]  Скорее всего, будет там какая-то runtime ошибка.
[02:07:32.680 --> 02:07:35.680]  Что он попытается пойти вправо, а справа ничего нет,
[02:07:35.680 --> 02:07:38.680]  ну и, соответственно, все сломается.
[02:07:38.680 --> 02:07:40.680]  Так, значит, forward list.
[02:07:40.680 --> 02:07:43.680]  Ну, с forward list все понятно, это тоже самый список,
[02:07:43.680 --> 02:07:45.680]  но просто одно направление.
[02:07:45.680 --> 02:07:49.680]  То есть он просто хранит ссылки на следующий элемент вправо.
[02:07:49.680 --> 02:07:51.680]  И все.
[02:07:53.680 --> 02:07:55.680]  Ну и, соответственно, в отличие от sdlist,
[02:07:55.680 --> 02:07:58.680]  у него есть все те же самые методы, точнее, не так.
[02:07:58.680 --> 02:08:01.680]  Он ведет себя точно так же, как и обычный список,
[02:08:01.680 --> 02:08:03.680]  но у него нет возможности добавления в конец.
[02:08:03.680 --> 02:08:06.680]  То есть, естественно, если у вас есть односвязанный список,
[02:08:06.680 --> 02:08:09.680]  и вы храните, скажем, указатель только на начало,
[02:08:09.680 --> 02:08:12.680]  то у вас есть возможность добавлять только вот в начало.
[02:08:12.680 --> 02:08:17.680]  То есть только делать push front и pop front.
[02:08:19.680 --> 02:08:24.680]  Ну, сразу скажу, забегая вперед, что указатель на back, указатель на конец,
[02:08:24.680 --> 02:08:26.680]  значит forward list не хранит.
[02:08:26.680 --> 02:08:28.680]  То есть forward list хранит указатель только на начало.
[02:08:28.680 --> 02:08:29.680]  Все.
[02:08:29.680 --> 02:08:32.680]  То есть вы можете, поэтому вы можете добавлять элементы только в начало,
[02:08:32.680 --> 02:08:34.680]  в конец не можете.
[02:08:34.680 --> 02:08:38.680]  Есть еще ограничения, тоже алгоритмические.
[02:08:38.680 --> 02:08:41.680]  Значит, смотрите, вот в обычном двухсвязном списке,
[02:08:41.680 --> 02:08:45.680]  ну мы это уже как-то обсуждали, когда обсуждали эти хэштаблицы.
[02:08:45.680 --> 02:08:47.680]  Давайте обсудим еще раз.
[02:08:47.680 --> 02:08:49.680]  Вот, допустим, я хочу удалить вот этот элемент.
[02:08:49.680 --> 02:08:51.680]  Если я ударяю его в двухсвязном списке, то все ок.
[02:08:51.680 --> 02:08:53.680]  То есть мне достаточно его удалить,
[02:08:53.680 --> 02:08:56.680]  и дальше я просто указатели провязываю там друг с другом
[02:08:56.680 --> 02:08:58.680]  у предыдущего и следующего элемента.
[02:08:58.680 --> 02:09:00.680]  Ну, потому что у меня через вот этот элемент
[02:09:00.680 --> 02:09:03.680]  есть доступ как к предыдущему, так и к следующему элементу.
[02:09:03.680 --> 02:09:05.680]  Поэтому я могу спокойно удалять.
[02:09:05.680 --> 02:09:07.680]  А в случае forward списка не так.
[02:09:07.680 --> 02:09:09.680]  Вот, если у меня есть forward список,
[02:09:09.680 --> 02:09:11.680]  я хочу удалить вот этот элемент,
[02:09:11.680 --> 02:09:13.680]  то есть если у меня есть указатель на этот элемент,
[02:09:13.680 --> 02:09:16.680]  то просто вызвать erase я не могу.
[02:09:16.680 --> 02:09:17.680]  Почему?
[02:09:17.680 --> 02:09:19.680]  Потому что если я его удалю,
[02:09:19.680 --> 02:09:22.680]  то мне нужно вот этот вот указатель провязать сюда.
[02:09:22.680 --> 02:09:25.680]  А доступ к этому элементу я получить не могу.
[02:09:25.680 --> 02:09:30.680]  Потому что у меня у вот этого элемента нет обратной ссылки.
[02:09:30.680 --> 02:09:33.680]  То есть он не может получить своего левого соседа.
[02:09:33.680 --> 02:09:37.680]  И поэтому операций insert и erase в forward листе нет.
[02:09:37.680 --> 02:09:42.680]  Но есть методы insertActor и eraseActor.
[02:09:42.680 --> 02:09:45.680]  Ну как это работает?
[02:09:45.680 --> 02:09:48.680]  У вас есть одна направленный список,
[02:09:48.680 --> 02:09:53.680]  и у вас есть указатель на какой-то элемент списка.
[02:09:53.680 --> 02:09:57.680]  Вот сам этот элемент x вы удалить не можете.
[02:09:57.680 --> 02:09:59.680]  Но вы можете удалить,
[02:09:59.680 --> 02:10:02.680]  простите, вы можете удалить элемент y,
[02:10:02.680 --> 02:10:06.680]  просто позвав eraseActor.
[02:10:06.680 --> 02:10:08.680]  То есть вы говорите удалить не этот элемент,
[02:10:08.680 --> 02:10:10.680]  а удалить элемент, который стоит после него.
[02:10:10.680 --> 02:10:12.680]  Всё, таким образом вы удаляете элемент y
[02:10:12.680 --> 02:10:16.680]  и просто-напросто провязываете ссылку на следующий элемент.
[02:10:16.680 --> 02:10:19.680]  И никаких проблем нет.
[02:10:19.680 --> 02:10:21.680]  Ну с insert тоже самое.
[02:10:21.680 --> 02:10:23.680]  Вы не можете вставить элемент на текущую позицию,
[02:10:23.680 --> 02:10:25.680]  вы можете вставить элемент только после этого элемента.
[02:10:25.680 --> 02:10:27.680]  Потому что чтобы вставить элемент в текущую позицию,
[02:10:27.680 --> 02:10:29.680]  вам надо знать предыдущего соседа,
[02:10:29.680 --> 02:10:32.680]  а его вы знать не можете.
[02:10:32.680 --> 02:10:36.680]  Аналогично, вместо привычных методов splice в списке,
[02:10:36.680 --> 02:10:39.680]  у вас в односвязанном списке есть метод spliceActor.
[02:10:39.680 --> 02:10:41.680]  Ну и работают они точно так же,
[02:10:41.680 --> 02:10:43.680]  но просто вставляют элементы после того,
[02:10:43.680 --> 02:10:46.680]  на который вы указываете.
[02:10:46.680 --> 02:10:49.680]  Да, ещё забавный факт, у std forward лист нет size.
[02:10:49.680 --> 02:10:52.680]  Ну, короче, size выпадывать не можете,
[02:10:52.680 --> 02:10:55.680]  то есть вы обязаны самостоятельно его как-то хранить.
[02:10:55.680 --> 02:10:58.680]  Вот.
[02:11:05.680 --> 02:11:08.680]  Вопросы есть?
[02:11:08.680 --> 02:11:11.680]  Так, продолжим.
[02:11:11.680 --> 02:11:15.680]  Постараемся в течение 15 минут закончить с контейнерами
[02:11:15.680 --> 02:11:18.680]  и коротко поговорить про итераторы,
[02:11:18.680 --> 02:11:20.680]  чтобы мы могли уже как-то ими пользоваться.
[02:11:20.680 --> 02:11:23.680]  Ну, ещё пару слов про std forward лист.
[02:11:23.680 --> 02:11:26.680]  Значит, снова возникает естественный вопрос.
[02:11:26.680 --> 02:11:28.680]  Ну вот у нас есть список,
[02:11:28.680 --> 02:11:30.680]  которым можно пользоваться.
[02:11:30.680 --> 02:11:32.680]  Ну, если вы хотите,
[02:11:32.680 --> 02:11:35.680]  вы можете пользоваться стд forward лист,
[02:11:35.680 --> 02:11:37.680]  но снова возникает естественный вопрос.
[02:11:37.680 --> 02:11:39.680]  Ну вот у нас есть список,
[02:11:39.680 --> 02:11:41.680]  в котором использоваться удобно.
[02:11:41.680 --> 02:11:44.680]  У него есть insert и erase, и так далее, и так далее.
[02:11:44.680 --> 02:11:46.680]  А есть std forward лист,
[02:11:46.680 --> 02:11:48.680]  который односвязанный,
[02:11:48.680 --> 02:11:50.680]  и в принципе не очень удобно пользоваться.
[02:11:50.680 --> 02:11:52.680]  То есть всякий insertActor, raceActor,
[02:11:52.680 --> 02:11:55.680]  плюс ещё size нельзя узнать и так далее.
[02:11:55.680 --> 02:11:57.680]  В чём преимущество forward лист?
[02:11:57.680 --> 02:12:00.680]  Ну, снова, здесь опять же классический принцип.
[02:12:00.680 --> 02:12:03.680]  Не плати за то, что не используешь.
[02:12:03.680 --> 02:12:05.680]  То есть если вам реально по факту нужно
[02:12:05.680 --> 02:12:07.680]  только вставлять элементы, скажем, в начало,
[02:12:07.680 --> 02:12:09.680]  или удалять элементы откуда-то,
[02:12:09.680 --> 02:12:11.680]  и середина эффективна,
[02:12:11.680 --> 02:12:13.680]  и при этом вам не нужно бегать по списку туда-обратно,
[02:12:13.680 --> 02:12:15.680]  то стоит рассмотреть возможность
[02:12:15.680 --> 02:12:17.680]  использования std forward листа. Почему?
[02:12:17.680 --> 02:12:19.680]  Потому что, так как у него нет size,
[02:12:19.680 --> 02:12:22.680]  то у него нет дополнительных лишних overhead'ов
[02:12:22.680 --> 02:12:24.680]  на то, чтобы обеспечивать вам size за единицу
[02:12:24.680 --> 02:12:26.680]  и вообще как-то поддерживать размер.
[02:12:26.680 --> 02:12:28.680]  Это первое.
[02:12:28.680 --> 02:12:30.680]  Второе, он не тратит все узлы,
[02:12:30.680 --> 02:12:32.680]  ни один из узлов не тратит лишнюю память,
[02:12:32.680 --> 02:12:34.680]  ссылку назад.
[02:12:34.680 --> 02:12:37.680]  Вы понимаете, что если вы храните список интов,
[02:12:37.680 --> 02:12:39.680]  помимо того что вы храните int,
[02:12:39.680 --> 02:12:41.680]  вы ещё храните условно 2 указателя,
[02:12:41.680 --> 02:12:44.680]  указатель 1 и указатель 2 указательно supers coincide
[02:12:44.680 --> 02:12:46.680]  на следующий элемент. В итоге вместо того,
[02:12:46.680 --> 02:12:48.680]  чтобы хранить один элемент на 4 байта,
[02:12:48.680 --> 02:12:51.680]  вместо того чтобы хранить на один узел 4 байта,
[02:12:51.680 --> 02:12:53.680]  то есть, по сути, на 1 intimate envelope,
[02:12:53.680 --> 02:12:55.680]  вы храните 20 байт.
[02:12:55.680 --> 02:12:57.680]  То есть вы в 5 раз тратите больше памяти,
[02:12:57.680 --> 02:13:01.680]  чем на самом деле нужно для хранения элементов.
[02:13:01.680 --> 02:13:06.680]  У форерд-листа с этим получше, потому что он хранит только одну ссылку,
[02:13:06.680 --> 02:13:09.680]  поэтому затрата памяти поменьше.
[02:13:09.680 --> 02:13:13.680]  Мораль в том, что контейнеры нужно выбирать под задачу,
[02:13:13.680 --> 02:13:16.680]  соответственно, если вам не нужны возможности двунаправленного списка,
[02:13:16.680 --> 02:13:19.680]  то рассмотрите возможность односвязанного списка.
[02:13:19.680 --> 02:13:22.680]  Даже несмотря на то, что им возможно как-то неудобно исполнить,
[02:13:22.680 --> 02:13:25.680]  хотя к этому можно быстро привыкнуть.
[02:13:25.680 --> 02:13:30.680]  Ну и последний пункт контейнеров – это типы члены.
[02:13:30.680 --> 02:13:38.680]  Смотрите, внутри класса, вы понимаете, что внутри класса можно объявить свои собственные типы,
[02:13:38.680 --> 02:13:42.680]  например, создать свою собственную структуру или завести некоторый псевдоним,
[02:13:42.680 --> 02:13:49.680]  например, using type равно int.
[02:13:49.680 --> 02:13:52.680]  И этим типом вы можете пользоваться вне этой структуры,
[02:13:52.680 --> 02:14:00.680]  например, вы хотите узнать, вы можете написать a.type и завести переменную x этого типа.
[02:14:00.680 --> 02:14:03.680]  Грубо говоря, структурой класса они задают некоторую область видимости,
[02:14:03.680 --> 02:14:06.680]  в которую вы можете объявлять свои собственные классы,
[02:14:06.680 --> 02:14:10.680]  вы можете объявлять свои собственные псевдонимы типов и ими пользоваться снаружи,
[02:14:10.680 --> 02:14:13.680]  с помощью операции разрешения области видимости.
[02:14:13.680 --> 02:14:19.680]  И вот в частности для стандартных контейнеров есть следующие типы,
[02:14:19.680 --> 02:14:22.680]  которые в них обязаны быть.
[02:14:22.680 --> 02:14:24.680]  Это тип value type.
[02:14:24.680 --> 02:14:30.680]  То есть вы можете у вектора спросить std.2.2.vector, например int,
[02:14:30.680 --> 02:14:34.680]  и дальше написать 2.2.value type.
[02:14:34.680 --> 02:14:40.680]  Value type хранит тип элемента, который он хранит.
[02:14:40.680 --> 02:14:44.680]  В частности, value type является псевдонимом типа int.
[02:14:44.680 --> 02:14:48.680]  Дальше есть тип size type, который говорит о том, в чем измеряется размер вектора.
[02:14:48.680 --> 02:14:52.680]  Грубо говоря, что вектор ожидает от вас на вход в операциях resize и reserve,
[02:14:52.680 --> 02:14:55.680]  и что он возвращает в качестве ответа на size.
[02:14:55.680 --> 02:14:58.680]  То есть если вы хотите понять, какой тип вам нужно передать в resize или reserve,
[02:14:58.680 --> 02:15:02.680]  то эта информация хранится в типе членей size type.
[02:15:02.680 --> 02:15:05.680]  Есть difference type, это в чем измеряется расстояние между элементами.
[02:15:05.680 --> 02:15:10.680]  То есть когда вы берете разность двух указателей или разность двух итераторов,
[02:15:10.680 --> 02:15:12.680]  то бегай вперед.
[02:15:12.680 --> 02:15:16.680]  Есть типы reference, constreference, pointer.
[02:15:16.680 --> 02:15:20.680]  И const pointer – это какой тип имеет ссылка на элемент,
[02:15:20.680 --> 02:15:24.680]  или какой тип имеет указательный элемент.
[02:15:24.680 --> 02:15:26.680]  Для чего это все нужно?
[02:15:26.680 --> 02:15:28.680]  То есть казалось бы, ну смотрите, у меня же есть вектор int.
[02:15:28.680 --> 02:15:32.680]  Ну что, я дурак, я что-ли не понимаю, что у меня там value type – это int.
[02:15:32.680 --> 02:15:34.680]  Что у меня ссылка на int – это ссылка на int.
[02:15:34.680 --> 02:15:38.680]  Что у меня константная ссылка на int – это константная ссылка на int и так далее.
[02:15:38.680 --> 02:15:40.680]  Но на самом деле вы не всегда этого понимаете.
[02:15:40.680 --> 02:15:42.680]  Особенно если вы пишете шаблонный код.
[02:15:42.680 --> 02:15:44.680]  Значит пример.
[02:15:44.680 --> 02:15:47.680]  Ну вот представьте себе, опять же игрушечный пример,
[02:15:47.680 --> 02:15:50.680]  но он там демонстрирует необходимость этих всех типов.
[02:15:50.680 --> 02:15:53.680]  Ну представьте себе, что у меня есть функция, точнее я хочу написать функцию,
[02:15:53.680 --> 02:15:56.680]  которая мне принимает произвольный контейнер
[02:15:56.680 --> 02:16:01.680]  и возвращает динамический массив, который содержит элементы этого контейнера.
[02:16:01.680 --> 02:16:05.680]  Вот функция toSistaLRA, которая выделяет память,
[02:16:05.680 --> 02:16:07.680]  заполняет его как-то элементами контейнера
[02:16:07.680 --> 02:16:10.680]  и дальше возвращает указатель на этот самый массив.
[02:16:10.680 --> 02:16:12.680]  И тут возникает сразу куча проблем.
[02:16:12.680 --> 02:16:15.680]  Ну смотрите, я принимаю произвольный контейнер.
[02:16:15.680 --> 02:16:21.680]  Вопрос – какие элементы хранит этот контейнер?
[02:16:21.680 --> 02:16:24.680]  Ну непонятно.
[02:16:24.680 --> 02:16:29.680]  Ну тогда если я не понимаю, какой тип хранит этот контейнер,
[02:16:29.680 --> 02:16:34.680]  то я в общем случае не понимаю, что мне нужно вернуть.
[02:16:34.680 --> 02:16:36.680]  Указатель на какой тип мне нужно вернуть?
[02:16:36.680 --> 02:16:38.680]  Какой указатель мне нужно тут создать? И так далее.
[02:16:38.680 --> 02:16:40.680]  Ну то есть понимаете, да?
[02:16:40.680 --> 02:16:42.680]  То есть я не понимаю, что находится внутри контейнера банально,
[02:16:42.680 --> 02:16:45.680]  потому что у меня контейнер – это шаблонный тип.
[02:16:45.680 --> 02:16:48.680]  И мне нужно из него как-то извлечь, а что там лежит.
[02:16:48.680 --> 02:16:55.680]  Так вот, это можно сделать с помощью вот этих самых типов членов.
[02:16:55.680 --> 02:16:57.680]  То есть мне достаточно написать.
[02:16:57.680 --> 02:16:58.680]  Давайте отсюда начнём.
[02:16:58.680 --> 02:17:02.680]  Чтобы создать массив из нужных мне элементов,
[02:17:02.680 --> 02:17:05.680]  я могу обратиться к контейнеру 2.2.2.type.
[02:17:05.680 --> 02:17:10.680]  И так как внутри каждого контейнера C++ есть определённо псевдоним
[02:17:10.680 --> 02:17:12.680]  для того типа, который он хранит,
[02:17:12.680 --> 02:17:15.680]  то с помощью вот этого 2.2.2.type вы можете получить тип,
[02:17:15.680 --> 02:17:17.680]  который хранит контейнер.
[02:17:17.680 --> 02:17:19.680]  Это первый момент.
[02:17:19.680 --> 02:17:22.680]  Второй момент, ну окей, вот здесь можно написать авто.
[02:17:22.680 --> 02:17:25.680]  Здесь в качестве возвращаемого значения вы можете указать pointer.
[02:17:25.680 --> 02:17:27.680]  То есть контейнер 2.2.2.pointer.
[02:17:27.680 --> 02:17:30.680]  То есть ваша функция tu-c style array возвращает указатель
[02:17:30.680 --> 02:17:33.680]  на элементы, которые хранит контейнер.
[02:17:33.680 --> 02:17:38.680]  Таким образом, вы можете расставить типы, даже если они вам явно не подаются на вход.
[02:17:41.680 --> 02:17:43.680]  Мотивация понятна, да?
[02:17:47.680 --> 02:17:49.680]  Ну, видимо, да.
[02:17:49.680 --> 02:17:51.680]  Тут есть небольшой тонкий момент.
[02:17:51.680 --> 02:17:54.680]  Тут написаны слова typeName и typeName.
[02:17:56.680 --> 02:17:59.680]  Я, к сожалению, сейчас нет времени подробно объяснять,
[02:17:59.680 --> 02:18:01.680]  почему тут нужно писать typeName.
[02:18:01.680 --> 02:18:05.680]  Либо запомните, что в таких ситуациях нужно писать typeName.
[02:18:05.680 --> 02:18:07.680]  Либо компилятор сам подскажет.
[02:18:07.680 --> 02:18:09.680]  В этом смысле компилятор добрый.
[02:18:09.680 --> 02:18:12.680]  У вас возникает ошибка компиляции, в которой будет написано,
[02:18:12.680 --> 02:18:14.680]  что добавьте здесь typeName, и все заработает.
[02:18:14.680 --> 02:18:18.680]  Если коротко, то typeName здесь нужно, чтобы компилятор понял,
[02:18:18.680 --> 02:18:21.680]  что вот это value type – это на самом деле действительно тип,
[02:18:21.680 --> 02:18:24.680]  то есть это действительно typeName, а не статическое поле.
[02:18:24.680 --> 02:18:28.680]  Потому что представьте, что если у вас в контейнере есть статическое поле,
[02:18:28.680 --> 02:18:31.680]  то к нему вы тоже можете обратиться вот так.
[02:18:31.680 --> 02:18:34.680]  То есть компилятор паникует, он не понимает, что это.
[02:18:34.680 --> 02:18:37.680]  Он не понимает, это статическое поле или это тип.
[02:18:37.680 --> 02:18:40.680]  Но чтобы сказать ему, что это тип, и не беспокойся,
[02:18:40.680 --> 02:18:42.680]  то нужно писать typeName.
[02:18:42.680 --> 02:18:45.680]  Возможно, как-то позже об этом поговорим.
[02:18:45.680 --> 02:18:46.680]  Все, отлично.
[02:18:46.680 --> 02:18:48.680]  Значит, с контейнерами все.
[02:18:48.680 --> 02:18:53.680]  Давайте вопросы минута и коротко поговорим про итераторы.
[02:18:58.680 --> 02:19:00.680]  Все, отлично. Вопросов нет.
[02:19:00.680 --> 02:19:03.680]  Переходим к итераторам.
[02:19:06.680 --> 02:19:09.680]  Сразу вместо «в карьер» проблема.
[02:19:09.680 --> 02:19:13.680]  Во-первых, мы знаем, когда мы обсуждали контейнеры,
[02:19:13.680 --> 02:19:15.680]  у нас уже возникла проблема с тем,
[02:19:15.680 --> 02:19:18.680]  что мы не можем обратиться к элементам списка.
[02:19:18.680 --> 02:19:20.680]  Мы можем обратиться к первому элементу списка,
[02:19:20.680 --> 02:19:22.680]  можем обратиться к последнему элементу списка,
[02:19:22.680 --> 02:19:24.680]  а куда-то в середину непонятно,
[02:19:24.680 --> 02:19:28.680]  непонятно получить центральный элемент списка, например.
[02:19:28.680 --> 02:19:30.680]  Или вот еще одна проблема.
[02:19:30.680 --> 02:19:32.680]  Представьте, что вы пишете функцию,
[02:19:32.680 --> 02:19:35.680]  которая просто печатает содержимое контейнера на экран.
[02:19:35.680 --> 02:19:38.680]  Вы принимаете произвольный контейнер,
[02:19:38.680 --> 02:19:40.680]  естественно, функция шаблонная,
[02:19:40.680 --> 02:19:42.680]  потому что она принимает произвольный контейнер,
[02:19:42.680 --> 02:19:45.680]  контейнеры могут содержать произвольные типы и так далее.
[02:19:45.680 --> 02:19:47.680]  Вы проходите по этому контейнеру,
[02:19:47.680 --> 02:19:49.680]  допустим, с помощью счетчика И,
[02:19:49.680 --> 02:19:51.680]  то есть от нуля до размера контейнера,
[02:19:51.680 --> 02:19:53.680]  то есть от нуля до размера контейнера
[02:19:53.680 --> 02:19:57.680]  вы выводите содержимое контейнера И.
[02:19:57.680 --> 02:19:59.680]  И сразу возникает проблема,
[02:19:59.680 --> 02:20:01.680]  потому что, вообще говоря,
[02:20:01.680 --> 02:20:04.680]  не все контейнеры позволяют индексировать себя.
[02:20:04.680 --> 02:20:08.680]  Например, deck может, stray может, vector может,
[02:20:08.680 --> 02:20:11.680]  а односвязанный списк и односвязанный списк они не могут.
[02:20:11.680 --> 02:20:13.680]  То есть возникает проблема.
[02:20:13.680 --> 02:20:15.680]  То есть как мне написать функцию,
[02:20:15.680 --> 02:20:18.680]  которая может просто взять и вывести содержимое произвольного контейнера?
[02:20:18.680 --> 02:20:22.680]  Например, для связанного списка вы могли написать какой-то такой код,
[02:20:22.680 --> 02:20:26.680]  если вы знали внутреннее устройство листа,
[02:20:26.680 --> 02:20:28.680]  если вы знали, какой тип имеет узел,
[02:20:28.680 --> 02:20:30.680]  что он внутри себя хранит,
[02:20:30.680 --> 02:20:32.680]  то вы могли пройти как-то так.
[02:20:32.680 --> 02:20:34.680]  Но этого не можете сделать.
[02:20:34.680 --> 02:20:36.680]  Это первое.
[02:20:36.680 --> 02:20:38.680]  А второе.
[02:20:38.680 --> 02:20:40.680]  Тогда вам придется для каждого контейнера писать свою версию print,
[02:20:40.680 --> 02:20:42.680]  что, естественно, неудобно.
[02:20:42.680 --> 02:20:44.680]  То есть для каждого контейнера вам, по сути,
[02:20:44.680 --> 02:20:46.680]  нужно написать свой алгоритм.
[02:20:46.680 --> 02:20:48.680]  Вы можете отсортировать вектор.
[02:20:48.680 --> 02:20:50.680]  Хорошо, вы его сортируете одним способом.
[02:20:50.680 --> 02:20:52.680]  Теперь вам нужно отсортировать, не знаю, stray,
[02:20:52.680 --> 02:20:54.680]  и вам нужно для него писать другой алгоритм, видимо.
[02:20:54.680 --> 02:20:56.680]  Ну, подождите, да?
[02:20:56.680 --> 02:20:58.680]  У меня же и вектор, и array, они, по сути, представляют в себе массив.
[02:20:58.680 --> 02:21:00.680]  То есть, наверное, их можно обрабатывать каким-то единым образом.
[02:21:00.680 --> 02:21:02.680]  То же самое deck.
[02:21:02.680 --> 02:21:06.680]  Deck, несмотря на то, что у него память расположения непрерывно,
[02:21:06.680 --> 02:21:08.680]  вы можете к нему обращаться по индексу.
[02:21:08.680 --> 02:21:10.680]  Поэтому, наверное, его тоже можно отсортировать эффективно.
[02:21:10.680 --> 02:21:12.680]  То есть возникает проблема.
[02:21:12.680 --> 02:21:14.680]  Как написать обобщенные алгоритмы,
[02:21:14.680 --> 02:21:16.680]  которые бы работали вообще с произвольным контейнером,
[02:21:16.680 --> 02:21:18.680]  и неважно, как бы они внутри были устроены.
[02:21:18.680 --> 02:21:22.680]  И вот ровно эту проблему нам помогают побороть итераторы.
[02:21:22.680 --> 02:21:26.680]  Да, хочется иметь унифицированный способ обхода контейнеров
[02:21:26.680 --> 02:21:28.680]  и обращения к их элементам.
[02:21:28.680 --> 02:21:30.680]  Ну, или, на самом деле, не просто обходы контейнеров вообще.
[02:21:30.680 --> 02:21:34.680]  Хочется писать алгоритмы, которые бы не зависели от типа контейнера.
[02:21:34.680 --> 02:21:38.680]  И это можно сделать с помощью так называемых итераторов.
[02:21:38.680 --> 02:21:40.680]  Так вот, что такое итератор?
[02:21:40.680 --> 02:21:44.680]  То есть про итератор можно думать в следующем ключе.
[02:21:44.680 --> 02:21:48.680]  Итератор — это просто особенный указатель.
[02:21:48.680 --> 02:21:52.680]  Итератор — это просто указатель, который знает информацию про свой контейнер.
[02:21:52.680 --> 02:21:57.680]  Ну, в частности, если у вас есть массив,
[02:21:57.680 --> 02:22:00.680]  и у вас есть указатель p,
[02:22:00.680 --> 02:22:02.680]  то вы можете спокойно с помощью этого указателя
[02:22:02.680 --> 02:22:04.680]  получить указатель на следующий элемент,
[02:22:04.680 --> 02:22:06.680]  то есть получив plus-plus-p.
[02:22:06.680 --> 02:22:09.680]  Или по этому указателю вы можете спокойно получить значение
[02:22:09.680 --> 02:22:16.880]  того элемента, на который вы указываете. А что если речь идет про список? Так вот, если вы
[02:22:16.880 --> 02:22:21.120]  используете итераторы, то в случае списков вы можете использовать точно такой же интерфейс для
[02:22:21.120 --> 02:22:25.160]  указателей, как и для массивов. То есть у вас есть некоторый итератор, давайте я его назову it,
[02:22:25.160 --> 02:22:32.480]  который в некотором смысле указывает на какой-то элемент списка, и дальше вызываете у него
[02:22:32.480 --> 02:22:38.800]  plus plus it. И вот когда вы вызываете plus plus it у итератора, итератор на самом деле не делает вот
[02:22:38.800 --> 02:22:44.680]  plus plus в смысле адреса в памяти, а plus plus it просто понимает, ага, я указываю на контейнер типа
[02:22:44.680 --> 02:22:51.040]  list, то есть я итератор листа, поэтому мне нужно там, скажем, посмотреть на next, то есть на указатель
[02:22:51.040 --> 02:22:56.760]  next, и в итоге он оказывается здесь. То есть итератор знает про внутреннее устройство контейнера,
[02:22:56.760 --> 02:23:02.960]  и собственно реализует операции там plus plus, minus minus или разыминование с учетом этих знаний.
[02:23:02.960 --> 02:23:08.320]  Понятно, то есть теперь вы можете пользоваться итераторами просто как обычными указателями,
[02:23:08.320 --> 02:23:13.160]  и при этом не задумываться о том, как внутри устроены контейнеры. Ну вот, например,
[02:23:13.160 --> 02:23:20.480]  вот пример функции print. Как можно было написать функцию print, работая с итераторами? Очень просто,
[02:23:20.480 --> 02:23:26.600]  мы принимаем произвольный контейнер и мы проходим все итератором от начала до конца.
[02:23:26.600 --> 02:23:32.000]  Как получить итератор на начало? Очень просто. У каждого контейнера, у любого контейнера,
[02:23:32.000 --> 02:23:37.280]  есть метод begin. Вот metod begin это значит получить указатель начала, ну или получить итератор
[02:23:37.280 --> 02:23:42.520]  на начало. Правильно говорите, итератор. Вот вы получаете итератор на первый элемент. Дальше,
[02:23:42.520 --> 02:23:46.560]  как получить итератор на последний элемент? То есть как понять в какой момент нужно остановиться?
[02:23:46.560 --> 02:23:52.560]  Очень просто тоже. Нужно вызвать метод end. Вот метод end возвращает вам
[02:23:52.560 --> 02:23:57.560]  итератор на, на самом деле не на последний элемент, а на элемент следующий за последним.
[02:23:57.560 --> 02:24:02.560]  То есть снова begin и end, ну как и все в стандартной библиотеке C++. Опять же возвращаемся к вопросу
[02:24:02.560 --> 02:24:07.560]  о соглашениях. Вот в стандартной библиотеке C++, ну и в принципе C++ принято, что у вас все интервалы
[02:24:07.560 --> 02:24:13.560]  полуоткрытые. То есть начало включается, а конец не включается. Вот поэтому container end
[02:24:13.560 --> 02:24:18.560]  на самом деле указывает на элемент, который находится за последним. Ну и в списке тоже самое.
[02:24:18.560 --> 02:24:25.560]  Тут есть какой-то фиктивный элемент, который является end. То есть вы получили итератор
[02:24:25.560 --> 02:24:29.560]  сначала, итератор на конец, то есть на конец последовательности. Ну и дальше вы делаете
[02:24:29.560 --> 02:24:35.560]  следующую вещь. Пока у вас итератор не дошел до конца, пока у вас итератор не равен end, вы
[02:24:35.560 --> 02:24:41.560]  увеличиваете итератор. Все. А чтобы получить элемент или чтобы увести его на экран, вы просто
[02:24:41.560 --> 02:24:45.560]  разыминовываете итератор. То есть теперь давайте вот просто мысленно забудем про слово
[02:24:45.560 --> 02:24:52.560]  итератор и посмотрим на этот код. Вот так как будто бы it это был указатель. Согласитесь,
[02:24:52.560 --> 02:24:55.560]  ровно так себе ведет указатель. Указатель можно ингриментировать, указатель можно сравнивать
[02:24:55.560 --> 02:24:59.560]  на равенство не равенство, указатель можно разыминовать. Итератор – это по сути ну опять же
[02:24:59.560 --> 02:25:05.560]  указатель на максималках. То есть указатель может указывать только скажем на массив,
[02:25:05.560 --> 02:25:10.560]  а итератор может указывать в произвольный контейнер и при этом у этого контейнера,
[02:25:10.560 --> 02:25:15.560]  Понимая его внутреннюю структуру, идти определенным образом вправо или влево.
[02:25:15.560 --> 02:25:18.560]  Идея основная понятна?
[02:25:18.560 --> 02:25:21.560]  Или есть вопросы?
[02:25:21.560 --> 02:25:24.560]  Понятно.
[02:25:24.560 --> 02:25:28.560]  Супер.
[02:25:28.560 --> 02:25:31.560]  Для чего нужны итераторы?
[02:25:31.560 --> 02:25:35.560]  Итераторы нужны, чтобы абстрагироваться от конкретного контейнера.
[02:25:35.560 --> 02:25:39.560]  Снова возвращаемся к вопросу о сортировке.
[02:25:39.560 --> 02:25:42.560]  Мы понимаем, что сортировать можно не только вектором.
[02:25:42.560 --> 02:25:45.560]  Сортировать можно array, сортировать можно deck.
[02:25:45.560 --> 02:25:48.560]  Потому что они позволяют в произвольное место эффективно получать доступ.
[02:25:48.560 --> 02:25:52.560]  Если вы понимаете, как устроена быстрая сортировка,
[02:25:52.560 --> 02:25:58.560]  то быстро сортировки нужно в его момент быстро получать элемент по нужному индексу.
[02:25:58.560 --> 02:26:03.560]  И, соответственно, stdsort, встроенный алгоритм сценария библиотеки sort, он так и устроен.
[02:26:03.560 --> 02:26:06.560]  Он принимает не контейнер, который вам нужно отсортировать.
[02:26:06.560 --> 02:26:11.560]  Он принимает не контейнер и ничего другое, а он принимает именно пару итераторов.
[02:26:11.560 --> 02:26:14.560]  Какую последовательность вам нужно отсортировать?
[02:26:14.560 --> 02:26:16.560]  Begin, end.
[02:26:16.560 --> 02:26:21.560]  Чтобы отсортировать вектор, я должен передать vBegin, vEnd.
[02:26:21.560 --> 02:26:27.560]  Теперь он с этой последовательностью будет работать через итераторы.
[02:26:27.560 --> 02:26:32.560]  Он просто будет у итератора звать plus, plus, или plus равно, или квадратные скобки.
[02:26:32.560 --> 02:26:35.560]  Потому что у указателя можно брать квадратные скобки.
[02:26:35.560 --> 02:26:38.560]  Также у итератора вектора можно брать квадратные скобки.
[02:26:38.560 --> 02:26:40.560]  Точно так же можно отсортировать, например, deck.
[02:26:40.560 --> 02:26:43.560]  То есть вы можете назвать dBegin или dEnd.
[02:26:43.560 --> 02:26:46.560]  Кроме того, чем еще хорошие итераторы?
[02:26:46.560 --> 02:26:52.560]  Чем еще хороший этот способ с применением алгоритмов над итераторами, а не над контейнерами?
[02:26:52.560 --> 02:26:58.560]  Представьте, что у вас есть массив, или любой другой контейнер,
[02:26:58.560 --> 02:27:03.560]  и вам хочется отсортировать элементы с третьего по десятой, не включительно.
[02:27:03.560 --> 02:27:07.560]  Как бы мы это сделали, если бы sort принимал контейнер?
[02:27:07.560 --> 02:27:09.560]  Нужно было сделать две вещи.
[02:27:09.560 --> 02:27:12.560]  Нужно было взять все эти элементы.
[02:27:12.560 --> 02:27:14.560]  Скопировать какой-то новый массив.
[02:27:14.560 --> 02:27:17.560]  Потом этот массив передать обратно в сортировку.
[02:27:17.560 --> 02:27:19.560]  Сортировка бы этот массив отсортировал.
[02:27:19.560 --> 02:27:23.560]  И нам нужно было взять этот массив и скопировать все обратно сюда.
[02:27:24.560 --> 02:27:27.560]  То есть если бы сортировка работала с контейнерами,
[02:27:27.560 --> 02:27:29.560]  то нужно было создавать временный контейнер,
[02:27:29.560 --> 02:27:30.560]  передавать его в сортировку,
[02:27:30.560 --> 02:27:35.960]  потом из этого временного контейра еще копировать обратно. Но это неэффективно. А здесь, если вам нужно
[02:27:35.960 --> 02:27:42.560]  отсортировать, скажем, все элементы с третьего по десятой, то достаточно просто позвать std sort
[02:27:42.560 --> 02:27:54.920]  скажем v.Begin плюс 3, запятая v.Begin плюс 10. Все, и теперь эта сортировка будет работать с
[02:27:54.920 --> 02:28:02.000]  элементами с третьего по десятой. Вот и все. То есть сортировка будет думать, что это начало
[02:28:02.000 --> 02:28:07.120]  массива, а это конец массива, и вся сортировка будет осуществляться только здесь и только здесь.
[02:28:07.120 --> 02:28:21.320]  На этом, я думаю, закончим. Время вышло. Давайте еще раз спрошу, есть ли у вас вопросы по тому,
[02:28:21.320 --> 02:28:25.800]  что на текущий момент было рассказано. А в следующий раз продолжим обсудить
[02:28:25.800 --> 02:28:28.000]  итераторы и другие контейнеры.
