[00:00.000 --> 00:09.320]  Мы продолжаем говорить про суевкисный автомат.
[00:09.320 --> 00:11.080]  Давайте напомним, на чем мы остановились.
[00:11.080 --> 00:15.080]  Мы остановились на том, что если есть произвольная
[00:15.080 --> 00:21.560]  вершина, то множество ребер в нее входящих обязательно
[00:21.560 --> 00:24.360]  имеют написанную одну и ту же буковку, допустим,
[00:24.360 --> 00:25.360]  С.
[00:25.360 --> 00:27.920]  На всех ребрах, входящих в какую-то конкретную вершину,
[00:27.920 --> 00:32.800]  на одну и ту же букву, а также вершины начала этих
[00:32.800 --> 00:37.360]  ребер, они являются, в общем, они лежат на одном пути
[00:37.360 --> 00:39.200]  по суевиксным ссылкам, то есть если мы рассмотрим
[00:39.200 --> 00:43.640]  на них самую длинную с максимальным лен и будем
[00:43.640 --> 00:45.840]  брать многократно суевиксную ссылку, то мы целиком этот
[00:45.840 --> 00:48.200]  весь путь как раз покроем все множество вершин, из
[00:48.200 --> 00:51.360]  которых есть ребров В, в произвольную фиксированную
[00:51.360 --> 00:52.360]  вершину В.
[00:52.360 --> 00:53.960]  Это мы доказали в прошлый раз.
[00:53.960 --> 01:01.680]  И теперь нам надо, зная все вот это вот безобразие,
[01:01.680 --> 01:04.760]  нам нужно построить алгоритм, напоминаю, как он у нас был
[01:04.760 --> 01:05.760]  устроен.
[01:05.760 --> 01:10.360]  У нас был суфиксный автомат для строки С, и мы инкрементально
[01:10.360 --> 01:13.440]  по одному символу расширяем нашу строчку, дописываем
[01:13.440 --> 01:15.920]  новые и новые символы, там С, Д и так далее.
[01:15.920 --> 01:18.080]  Идем просто по строке и дописываем их по одному
[01:18.080 --> 01:20.640]  и перестраиваем автомат из старого в новый.
[01:20.640 --> 01:24.480]  Что мы еще установили?
[01:24.480 --> 01:29.680]  Мы установили, что у нас будет новых максимум два
[01:29.680 --> 01:39.600]  состояния, у нас обязательно появляется вершина, отвечающая
[01:39.600 --> 01:45.800]  классу СС, ну потому что это новая строка, которой
[01:45.800 --> 01:48.920]  не было, теперь она появилась, для нее нужно обязательно
[01:49.680 --> 01:53.280]  И мы также охарактеризовали весь этот класс, значит,
[01:53.280 --> 02:02.720]  это все суффиксы СС, которые не являлись под строками
[02:02.720 --> 02:03.720]  С.
[02:03.720 --> 02:10.680]  Не являлись под строками С.
[02:10.680 --> 02:16.760]  То есть у нас обязательно появляется новое состояние,
[02:16.760 --> 02:19.920]  это как бы всем новым подстрочкам.
[02:19.920 --> 02:26.400]  Все, что раньше не являлось под строками С, а теперь
[02:26.400 --> 02:29.280]  после дописания очередного символа стало под строкой
[02:29.280 --> 02:31.800]  СС, ну под строки СС новые это только обязательно
[02:31.800 --> 02:34.520]  суффиксы, у нас никаких подстрок не возникло.
[02:34.520 --> 02:37.440]  Значит, здесь в этом классе лежат в точности все суффиксы,
[02:37.440 --> 02:39.600]  которые раньше не присутствовали, а вот теперь появились.
[02:39.600 --> 02:43.520]  То есть это СС и несколько его самых длинных суффиксов,
[02:43.520 --> 02:45.840]  которых раньше никогда не было, раньше в С не встречались.
[02:45.840 --> 02:51.880]  Вот, и у нас есть еще второй кандидат на новое состояние,
[02:51.880 --> 02:57.920]  я его обзывал Т, но давайте вот ведем, обозначим через
[02:57.920 --> 03:18.360]  С0 самый длинный суффикс строки СС, являющийся под
[03:19.360 --> 03:20.360]  строкой С.
[03:20.360 --> 03:31.040]  И в прошлый раз мы доказали, что если появляется хотя
[03:31.040 --> 03:33.840]  бы еще какой-то класс, если есть что-то новое, если есть
[03:33.840 --> 03:37.520]  еще новое состояние, то обязательно С0 это лонгис
[03:37.520 --> 03:38.520]  в этом классе.
[03:38.520 --> 03:54.640]  Если какой-то еще класс появляется, появляется,
[03:54.640 --> 04:06.360]  то С0 это лонгест в нем, это было у нас в прошлый раз.
[04:06.800 --> 04:09.560]  То есть мы там, я там говорил, пусть кроме этого класса
[04:09.560 --> 04:14.080]  есть, появляется еще какой-то новый, в нем Т, строка Т это
[04:14.080 --> 04:17.840]  лонгест, тогда она обязательно удовлетворяет такому условию.
[04:17.840 --> 04:20.280]  Поэтому если я сейчас через С0 определю вот ту самую
[04:20.280 --> 04:23.160]  строчку, самый длинный суффикс, который раньше встречался,
[04:23.160 --> 04:26.840]  то если вот это вот Т и появляется в качестве нового лонгеста,
[04:26.840 --> 04:29.400]  то она обязательно равна С0.
[04:29.400 --> 04:32.040]  Но, возможно, Т не появляется, потому что, возможно, больше
[04:32.040 --> 04:34.920]  вообще нет никакого класса нового, кроме вот этого,
[04:34.920 --> 04:38.800]  потому я как бы за С0 обозначаю строчку, а Т это вот новый
[04:38.800 --> 04:40.760]  лонгест, и если он есть, то он обязательно равен С0.
[04:40.760 --> 04:51.320]  Так, ну тогда смотрите, давайте мы разберемся вот с этим
[04:51.320 --> 04:52.880]  классом, что здесь происходит.
[04:52.880 --> 04:55.240]  Плюс к тому же мы уже знаем, как устроены все ребра ведущие
[04:55.240 --> 04:56.240]  в это самое С.
[04:56.240 --> 04:58.840]  То есть мы знаем, пусть у нас был какой-то суффиксный
[04:58.840 --> 05:05.560]  автомат для строки С, автомат для С.
[05:05.560 --> 05:07.960]  Мы понимаем, что обязательно должно появиться новое
[05:07.960 --> 05:13.120]  состояние, отвечающее строке СС, и вести в нее должны
[05:13.120 --> 05:16.640]  все стрелочки, значит, в нее нужно нарисовать ребра
[05:16.640 --> 05:20.200]  из вершин, лежащих на суффиксном пути, на пути по суффссылкам,
[05:20.200 --> 05:22.360]  и на всех этих ребрах должен быть написано вот тот самый
[05:22.360 --> 05:25.640]  символ С, потому что этот символ указывает на то,
[05:25.640 --> 05:27.960]  какой символ мы приписываем в самом конце.
[05:27.960 --> 05:30.280]  Поэтому из каких-то вершин, вот здесь вот нужно нарисовать
[05:30.280 --> 05:34.120]  такой переход по буквке С, вопрос, что это за вершины.
[05:34.120 --> 05:39.880]  Вот это, например, какая вершина?
[05:39.880 --> 05:44.720]  Да, просто самая длинная строка, из которой после
[05:44.720 --> 05:47.440]  дописывания С мы попадаем в новый класс СС, ну конечно,
[05:47.440 --> 05:48.440]  это С.
[05:48.440 --> 05:51.120]  Но вот строка С раньше лежала в автомате для строки
[05:51.120 --> 05:54.200]  С, в частности для нее гарантированно появляется такой переход
[05:54.200 --> 05:58.280]  из СВС, ну, точнее, из класса, отвечающего С, в класс, отвечающий
[05:58.280 --> 05:59.280]  СС.
[05:59.280 --> 06:01.280]  Ну и значит, здесь мы должны несколько раз взять суффиксную
[06:01.280 --> 06:04.920]  ссылку и провести все вот такие вот ребра по букве
[06:04.920 --> 06:05.920]  С.
[06:05.920 --> 06:07.160]  Надо понять, сколько раз их нужно взять.
[06:07.160 --> 06:11.560]  Значит, самый простой случай.
[06:11.560 --> 06:15.720]  Давайте мы возьмем в этом автомате строчку С, будем
[06:15.720 --> 06:20.200]  брать от нее суффссылку, и предположим, что вот мы
[06:20.200 --> 06:23.120]  берем-берем-берем суффссылку, и из всех вершин на этом
[06:23.120 --> 06:25.720]  пути ни разу не было ни одного ребра по букве С.
[06:25.720 --> 06:29.440]  То есть, я вот беру суффссылки многократно, я понимаю,
[06:29.440 --> 06:33.280]  что из них должны быть ребра, из этих вершин должны быть
[06:33.280 --> 06:36.000]  ребра по букве С в нашу новую вершинку.
[06:36.000 --> 06:38.140]  И вот пусть ни за одной из них не было перехода
[06:38.140 --> 06:39.140]  по С.
[06:39.140 --> 06:43.080]  Так, как бы я это обозначил.
[06:43.080 --> 06:47.040]  Ну давайте я прям сразу псевдокод напишу, пусть
[06:47.040 --> 06:51.720]  П это класс, отвечающий строке С.
[06:51.720 --> 06:58.200]  Значит, дальше пока П не минус единица, и из П нет
[06:58.200 --> 07:07.720]  перехода по букве С.
[07:07.720 --> 07:08.720]  Мы этот переход заводим.
[07:08.720 --> 07:15.400]  Ну я вот так напишу, что если П это текущая вершинка
[07:15.400 --> 07:18.480]  на этом пути, и из нее раньше не было перехода по С, то
[07:18.480 --> 07:20.560]  теперь я его насильно добавляю, говорю, что отсюда есть
[07:20.560 --> 07:21.560]  переход в С.
[07:21.560 --> 07:24.520]  И перехожу по суффссылке.
[07:24.520 --> 07:27.520]  П равно линк от П.
[07:27.520 --> 07:32.080]  Вот, и в случае, если у меня этот вайл заканчивается
[07:32.080 --> 07:35.480]  кейсом П равно единице, то есть П равно единице это
[07:35.480 --> 07:39.240]  когда я поднимаюсь, ну вот так вот, спускаюсь по суффссылкам
[07:39.240 --> 07:41.320]  вплоть до корня, и потом пытаюсь взять суффссылку
[07:41.320 --> 07:42.320]  у корня.
[07:42.320 --> 07:45.080]  Потому что только у корня у меня суффссылка вот такая
[07:45.080 --> 07:48.000]  П равна минус единице, потому что у корня ничего нельзя
[07:48.000 --> 07:49.880]  отрезать, чтобы получить из-под строка.
[07:49.880 --> 07:52.640]  Поэтому у корня суффссылка как бы не определена, и
[07:52.640 --> 07:55.720]  тогда оно закончится в П равно минус единице.
[07:55.720 --> 08:01.040]  То есть если П равно минус единице, то это как раз случай,
[08:01.040 --> 08:03.480]  когда из всех вершин не было ни одного перехода по
[08:03.480 --> 08:04.480]  С.
[08:04.480 --> 08:06.880]  Тогда я утверждаю, что в этом случае нужно просто
[08:06.880 --> 08:12.120]  сделать, назначить суффссылку от СС вот сюда вот.
[08:12.120 --> 08:19.480]  Напишу так, линк от СС равно root, то есть суффссылка будет
[08:19.480 --> 08:20.480]  вести вот сюда.
[08:20.480 --> 08:23.320]  И на этом обработка закончится.
[08:23.320 --> 08:26.200]  Давайте я напишу там что-нибудь типа return.
[08:26.200 --> 08:33.840]  И так, я утверждаю следующее, что если у меня был автомат
[08:33.840 --> 08:39.640]  для строки С с таким свойством, что если я беру и прыгаю по
[08:39.800 --> 08:42.320]  суффссылкам от С вплоть до корня, и из всех этих
[08:42.320 --> 08:45.380]  вершин не было перехода по С, то для того чтобы перестроить
[08:45.380 --> 08:48.400]  автомат с появлением новой строки СС, ну точнее с добавлением
[08:48.400 --> 08:50.760]  нового символа вот этого вот, мне нужно просто из
[08:50.760 --> 08:53.360]  всех вершин на этом суффиксном пути добавить с перехода
[08:53.360 --> 08:56.320]  по С, ну а также назначить, что суффссылка отсюда ведет
[08:56.320 --> 08:57.320]  в корень.
[08:57.320 --> 08:59.400]  И на этом перестройка автомата закончится.
[08:59.400 --> 09:04.280]  В частности, вот не будет этого нового состояния Т.
[09:04.280 --> 09:08.440]  Так, ну начальная вершина автомата.
[09:08.440 --> 09:14.560]  Да, спасибо, это я не вводил, давайте я это запишу, корень
[09:14.560 --> 09:20.840]  это стартовая вершина автомата, собственно то откуда мы все
[09:20.840 --> 09:21.840]  слова читаем.
[09:21.840 --> 09:37.720]  Вершина автомата, то есть Q0, да, да, ну например так,
[09:37.720 --> 09:39.960]  или так же как у нас было в Боре, например, мы храним
[09:39.960 --> 09:43.120]  мапу, не вектор, а мапу, для каждого символа, если
[09:43.120 --> 09:45.880]  есть переход, то куда он ведет, если нет, то у нас
[09:45.880 --> 09:50.040]  нет такого ключа в мапе просто, то есть это можно
[09:50.480 --> 09:52.040]  и как вектор, и как мапу.
[09:52.040 --> 10:01.120]  Тут как раз набор переходов, это для каждой вершины
[10:01.120 --> 10:03.600]  и для каждого символа мы храним, куда есть переход.
[10:03.600 --> 10:08.480]  Ну да, да, да, только с такой помеченной, с пометочками
[10:08.480 --> 10:10.120]  на ребрах, с буквами.
[10:10.120 --> 10:15.200]  Ну да, то есть тут как бы нужно еще класс написать,
[10:15.200 --> 10:17.040]  иметь в виду вот именно та вершина, которая соответствует
[10:17.040 --> 10:18.040]  строке СС.
[10:19.040 --> 10:22.120]  Итак, почему-то верно, значит, я утверждаю, что характеризация
[10:22.120 --> 10:25.640]  такого кейса, это когда, значит, это происходит, это
[10:25.640 --> 10:35.040]  происходит ровно в том случае, когда символ С, символ
[10:35.040 --> 10:44.480]  С не встречался в С, не встречался в С, значит, вот эта картинка
[10:44.480 --> 10:46.480]  соответствует случаю, когда С вообще впервые у нас
[10:46.920 --> 10:47.920]  появился в нашей строке.
[10:47.920 --> 10:50.480]  Его раньше нигде не было, в С его не было, и только
[10:50.480 --> 10:52.040]  после приписа у него впервые стрейтлс.
[10:52.040 --> 10:57.520]  Ну, собственно, это более-менее понятно, потому что раз у
[10:57.520 --> 11:01.520]  нас даже из корня нет перехода по букве С, собственно, раньше
[11:01.520 --> 11:04.520]  его нигде быть не могло, в строке С он не мог встречаться,
[11:04.520 --> 11:06.760]  потому что, ну, как минимум, если у нас был корректный
[11:06.760 --> 11:09.600]  автомат для строки С, то из корня уж точно должны
[11:09.600 --> 11:11.440]  были быть переходы по всем буквам, потому что все
[11:11.440 --> 11:15.440]  это как бы начальные символы каких-то суффиксов, поэтому
[11:15.440 --> 11:18.000]  точно из корня можно прощать любой символ, встречающийся
[11:18.000 --> 11:19.000]  в строке.
[11:19.000 --> 11:22.120]  А если его раньше здесь не было, то, соответственно,
[11:22.120 --> 11:26.280]  его и, ну да, если его здесь не было, то, значит, его
[11:26.280 --> 11:28.320]  и во всей строке тоже не было.
[11:28.320 --> 11:31.120]  Вот, ну и в этом случае, конечно же, не просто из
[11:31.120 --> 11:33.200]  корня его не будет, а его вообще нигде не будет.
[11:33.200 --> 11:38.560]  Так, ну окей, значит, сейчас, надо, наверное, как-то по
[11:38.560 --> 11:39.560]  формане наказать.
[11:39.560 --> 11:43.960]  Давайте слева направо, да, слева направо.
[11:43.960 --> 11:46.220]  Если мы так пропрыгали и даже из корня нашли символ
[11:46.220 --> 11:48.640]  С, то, значит, конечно, его нельзя прочитать.
[11:48.640 --> 12:04.080]  Значит, если даже из корня нет перехода по С, то С не
[12:04.080 --> 12:08.920]  встречался в С, это очевидно, потому что из корня точно
[12:08.920 --> 12:10.280]  можно прощать все символы строки.
[12:10.280 --> 12:16.080]  Значит, обратно, если он не встречался, то, конечно,
[12:16.080 --> 12:18.080]  перехода по символу С вообще нигде нет, поэтому, если
[12:18.080 --> 12:20.800]  я буду прыгать по сувсылкам начиная с С, то я всюду
[12:20.800 --> 12:23.440]  не найду такого перехода и из корня тоже не найду.
[12:23.440 --> 12:25.880]  То есть я весь этот путь проскочу, здесь не найду
[12:25.880 --> 12:29.080]  ни одного перехода, закончу, когда П будет равно минус
[12:29.080 --> 12:30.080]  единиц.
[12:30.080 --> 12:36.600]  Значит, право-налево то же самое, если С нет в С,
[12:36.600 --> 12:38.600]  то в автомате нет ни одного перехода помещенного
[12:38.600 --> 12:51.480]  буквой С в автомате, нет ни одного перехода, помещенного
[12:51.480 --> 12:59.640]  символом С, значит, вот такой вот проход по сувсылкам
[12:59.640 --> 13:02.600]  закончится в корне и даже от корня попробую взять
[13:02.600 --> 13:03.600]  сувсылки.
[13:04.600 --> 13:08.360]  Значит, в конце будет П равно минус единицы.
[13:08.360 --> 13:14.000]  То есть я прыгаю-прыгаю-прыгаю по сувсылкам в поисках перехода
[13:14.000 --> 13:18.160]  по С и нигде не нахожу, тогда вот как раз, когда мы дойдем
[13:18.160 --> 13:21.000]  до корня, мы возьмем сувсылку, сувсылка ведет в пективную
[13:21.000 --> 13:23.680]  вершину минус один, мы как бы считаем, что у корня
[13:23.680 --> 13:25.960]  сувсылка минус единица, ну и вот как раз ровно это
[13:25.960 --> 13:26.960]  случай происходит.
[13:26.960 --> 13:29.840]  Вот, ну а в этом случае нужно поступать ровно так, как
[13:29.840 --> 13:32.880]  я здесь нарисовал, потому что, смотрите, какие мне
[13:32.880 --> 13:33.880]  вообще нужны переходы.
[13:33.880 --> 13:39.440]  В СС у меня содержатся все суффиксы, которые впервые
[13:39.440 --> 13:42.840]  встретились, но если характеризация этого кейса – это когда
[13:42.840 --> 13:45.800]  у меня С впервые вообще появился в строке, то здесь
[13:45.800 --> 13:49.640]  находятся вообще все суффиксы, кроме пустого, здесь находятся
[13:49.640 --> 13:52.680]  все суффиксы, кроме пустого, потому что они все заканчиваются
[13:52.680 --> 13:56.800]  на символ С, ну и соответственно они раньше нигде в автомате
[13:56.800 --> 13:58.600]  не встречались, они содержат символ, который только что
[13:58.600 --> 13:59.600]  появился.
[14:00.100 --> 14:08.280]  Значит вот сюда вот мне нужно провести ребра из всех
[14:08.280 --> 14:11.880]  предыдущих суффиксов, потому что здесь все новые суффиксы,
[14:11.880 --> 14:13.640]  поэтому мне нужно из всех старых суффиксов провести
[14:13.640 --> 14:15.080]  ребро отсюда по букве С.
[14:15.080 --> 14:18.160]  Ну вот я ровно это и делаю, потому что раньше у меня
[14:18.160 --> 14:21.080]  сувсылки, начиная от С, если я многократно применяю
[14:21.080 --> 14:26.800]  сувсылку, то я как раз прохожу все возможные суффиксы,
[14:26.800 --> 14:29.320]  потому что сувсылки для С устроены, это все суффиксы
[14:29.320 --> 14:34.320]  порядка убывания. Ну, из них и всех я должен провести переход по C. Почему
[14:34.320 --> 14:39.480]  сувсылка для СС это корень? Ну, потому что здесь находятся все суффиксы, кроме
[14:39.480 --> 14:48.520]  пустого. Давайте я нарисую класс СС в этом случае. Это сама строка СС и все ее
[14:48.520 --> 14:53.480]  непустые суффиксы, вплоть до суффикса из одного элемента C.
[14:53.480 --> 14:58.240]  Когда сувсылка такого класса, напоминаю, сувсылка, это нам нужно взять самую
[14:58.240 --> 15:01.680]  короткую строчку и отбросить один символ. Тогда будет пустая строка в качестве
[15:01.680 --> 15:07.960]  сувсылки. Ну, вот это мы и назначаем. Мы у последней вершинки говорим, что
[15:07.960 --> 15:15.720]  сувсылка это корень. Ну и, соответственно, давайте посмотрим на С0,
[15:15.720 --> 15:20.840]  почему она не образует дополнительного класса. С0-то самый длинный суффикс строки СТ
[15:20.840 --> 15:25.600]  являешься под строкой С. Чему равно С0 в этом случае?
[15:29.360 --> 15:34.200]  Да, пустая строка, потому что все остальные суффиксы, ну как бы все
[15:34.200 --> 15:38.120]  суффиксы длины хотя бы один, не были под строками С, потому что С нигде не было.
[15:38.120 --> 15:45.240]  Поэтому в этом случае С0-эпсилон. Ну, оно и так раньше было
[15:45.240 --> 15:48.680]  лонгистом в своем классе. Это как бы корень. Пустая строка у нас соответствует
[15:48.680 --> 15:56.720]  корню, корень автомата. Ну и поэтому новым состоянием эта штука точно не будет,
[15:56.720 --> 16:00.240]  потому что она и так уже была лонгистом. Стать новым лонгистом она не может,
[16:00.240 --> 16:05.000]  потому что это был уже отдельный класс. Все, значит обработка в этом случае закончилась.
[16:05.000 --> 16:09.000]  Окей? Хорошо.
[16:09.000 --> 16:14.800]  Так, едем дальше.
[16:35.000 --> 16:40.000]  Значит теперь происходит что-то другое. Мы шли-шли-шли вот так по суффсылкам и в какой-то момент мы нашли переход по С.
[16:40.000 --> 16:50.160]  У нас была С. Мы несколько раз берем суффсылку. Из всех вот этих промежуточных не было перехода по С,
[16:50.160 --> 16:56.320]  а вот из какой-то очередной вершинки П был переход по С. Пусть он ведет в какую-то вершинку Q.
[16:56.320 --> 17:01.440]  То есть вот здесь переходов не было и я их соответственно тогда просто провожу по
[17:01.440 --> 17:08.000]  букве С в наше новое состояние С. А из очередной вот следующей вершинной пути такой переход уже был.
[17:08.000 --> 17:19.000]  Был переход по символу С в какую-то другую вершинку Q. Тогда я утверждаю, во-первых,
[17:19.000 --> 17:32.760]  следующее, что С0 обязательно это лонгест от П плюс С. То есть вот та самая наша строка С0,
[17:32.760 --> 17:39.760]  которой самый длинный суффикс С является под строкой С, это лонгест от П плюс С.
[17:39.760 --> 17:46.760]  Ну почему это так? Вспоминаем, когда мы берем суффиксные ссылки от С, мы по сути перебираем все суффиксы С в порядке убывания длины.
[17:47.520 --> 17:54.520]  Здесь С вместе с несколькими своими самыми длинными суффиксами, потом следующий по длине суффикс вот здесь опять с несколькими своими самыми длинными суффиксами.
[17:54.520 --> 18:01.520]  Ну и так далее. И вот в какой-то момент мы доходим до какого-то суффикса С, который можно было продлить буквами С.
[18:01.520 --> 18:07.520]  А вот эти все более длинные нельзя было. Да, то есть после них, если я там как-то дошел на этой вершинке,
[18:07.520 --> 18:13.520]  то я С не мог прочитать в исходном автомате. То есть вот эти строки не продолжались символом С в исходной строке С.
[18:14.280 --> 18:20.280]  Все, вот это вот нельзя было продолжить символом С, а это можно. Ну значит, просто самая длинная строка, ведущая в П,
[18:20.280 --> 18:28.280]  является суффиксом строки С, после которого можно прочитать С. Ну значит, собственно, это есть наша самая С0.
[18:28.280 --> 18:40.280]  Давайте это запишу, что поскольку... Не обязательно, потому что здесь, возможно, еще какие-то другие слова.
[18:41.040 --> 18:43.040]  Ку могут быть какие-то другие слова.
[18:44.040 --> 19:03.040]  Поскольку те более длинные суффиксы С, строки С не продлевались символом С вправо.
[19:03.800 --> 19:05.800]  Символом С вправо.
[19:08.800 --> 19:13.800]  Но это продлевается, соответственно, это вот та самая длинная строка, которая была раньше в автомате.
[19:13.800 --> 19:15.800]  Самый длинный суффикс С.
[19:16.800 --> 19:24.800]  Так. И вот здесь опять возникают разные случаи. В хорошем случае, если, как вы сказали, С0 это вот
[19:25.560 --> 19:29.560]  лонгест от Ку, тогда все хорошо. Это будет второй случай наш.
[19:30.560 --> 19:40.560]  Если лонгест от Ку равно С0. То есть С0 это самая длинная строка в классе Ку.
[19:44.560 --> 19:48.560]  То новых классов не появляется.
[19:49.560 --> 19:51.560]  Новых классов не появляется.
[19:55.560 --> 20:02.360]  Потому что мы с вами знаем, что единственный кандидат на то, чтобы стать новым лонгестом
[20:02.360 --> 20:03.560]  Это Вот эта самая С0, которой мы знаем, как выглядит.
[20:05.560 --> 20:07.560]  Единственный кандидат на новый лонгест — это С0.
[20:07.560 --> 20:11.120]  И если он раньше был лонгестом, мы знаем, что С0 лежала в этом состоянии,
[20:12.120 --> 20:19.580]  И если он раньше и был лонгестом в своем состоянии , то нового ничего не появляется .
[20:19.580 --> 20:20.580]  Единственная новая вершина — это Сce.
[20:20.580 --> 20:21.580]  А С0, как тут была лонгестом, так и остается.
[20:21.580 --> 20:25.740]  В этом случае, если s0 это longest был изначально, то
[20:25.740 --> 20:28.180]  у меня больше вершин не появляется.
[20:28.180 --> 20:33.220]  И единственное, что мне нужно сделать, это видимо
[20:33.220 --> 20:39.460]  назначить просто link от sc равно q и return.
[20:39.460 --> 20:52.380]  Так, значит, почему это верно?
[20:52.380 --> 20:56.900]  Почему в случае, если s0 раньше было longest и соответствовал
[20:56.900 --> 20:59.340]  вершинке q, то мне ничего не нужно делать, новый хребер
[20:59.340 --> 21:01.740]  не появится, мне нужно только назначить сувсылку
[21:01.740 --> 21:02.740]  из scq.
[21:02.740 --> 21:04.900]  Во-первых, почему такая сувсылка корректная, это
[21:04.900 --> 21:07.180]  более-менее понятно, потому что мы с вами замечали не
[21:07.180 --> 21:10.260]  однократно, что link от вот этого класса sc это обязательно
[21:10.260 --> 21:11.260]  s0.
[21:11.260 --> 21:16.020]  Потому что в sc лежат те суффиксы sc, которые не являются
[21:16.020 --> 21:20.820]  под строками s, и если я, то есть вот это sc, потом
[21:20.820 --> 21:23.020]  еще следующий суффикс, не являющийся под строкой
[21:23.020 --> 21:26.300]  s, еще-еще-еще-еще, мы так вот уменьшаем до того момента,
[21:26.300 --> 21:28.980]  пока не встретим суффикс sc, являющийся под строкой
[21:28.980 --> 21:29.980]  s.
[21:29.980 --> 21:32.740]  И это будет в точности наша s0, самый длинный суффикс
[21:32.740 --> 21:35.460]  sc, являвшийся под строкой s.
[21:35.460 --> 21:39.140]  Поэтому сувсылка от sc обязательно всегда ведет
[21:39.140 --> 21:43.420]  в s0, пунктирная сувсылка обязательно ведет всегда
[21:43.420 --> 21:44.420]  в s0.
[21:44.420 --> 21:45.740]  Так же как вот здесь у нас получилось, смотрите,
[21:45.740 --> 21:49.020]  вот в этом случае, у меня сувсылка из sc вела в корень,
[21:49.020 --> 21:52.740]  а корень как раз соответствовал s0, здесь также выполняется,
[21:52.740 --> 21:56.700]  что сувсылка от sc ведет в s0, точнее от класса, отвечающего
[21:56.700 --> 22:01.180]  sc, ведет в класс, отвечающий s0.
[22:01.180 --> 22:04.020]  Поэтому этот переход по сувсылке будет корректный,
[22:04.020 --> 22:05.300]  но больше ничего не происходит.
[22:05.300 --> 22:08.620]  Ну мы поняли, что вершин больше не появляется, потому
[22:08.620 --> 22:11.060]  что только это могло стать новый вершин, но оно и так
[22:11.060 --> 22:14.380]  было лонгистом, поэтому ничего нового не происходит.
[22:14.380 --> 22:16.420]  Почему мы добавили все ребра?
[22:16.420 --> 22:21.500]  Ну давайте думать, какие вообще могли появиться
[22:21.500 --> 22:22.500]  ребра?
[22:22.500 --> 22:26.460]  Раз у меня вот эти вот вершины все не меняются, в старом
[22:26.460 --> 22:28.540]  автомате не появляется новый вершин, кроме вот
[22:28.540 --> 22:32.220]  этого, то значит, ребра, располагавшиеся внутри
[22:32.220 --> 22:34.220]  вот этого старого автомата также не меняются, просто
[22:34.220 --> 22:37.660]  потому что здесь не меняются как бы классы, классы эквалентности
[22:37.660 --> 22:38.660]  здесь не меняются.
[22:38.660 --> 22:40.740]  Все, кто были лонгистами, они же и остались, но их
[22:40.740 --> 22:41.740]  не появилось.
[22:41.740 --> 22:44.460]  Поэтому все классы эквалентности внутри старого автомата
[22:44.460 --> 22:46.820]  сохранились, а значит, и все переходы между ними
[22:46.820 --> 22:49.340]  тоже сохранились, потому что мы там рисовали, как
[22:49.340 --> 22:51.540]  у нас устроен переход из одного стани в другое.
[22:51.540 --> 22:54.660]  Если есть слово здесь, такое, что после дописания одного
[22:54.660 --> 22:57.780]  символа мы попадаем в слово сюда, но раз все классы здесь
[22:57.780 --> 22:59.780]  не изменились, то значит, и переходы между ними остались
[22:59.820 --> 23:00.820]  такими же.
[23:12.980 --> 23:13.980]  Итак.
[23:20.260 --> 23:21.260]  Сейчас, секунду.
[23:26.580 --> 23:27.580]  Ну, у вас лонгистов.
[23:30.220 --> 23:31.220]  Кроме СС.
[23:33.740 --> 23:34.740]  Не появляется.
[23:38.460 --> 23:39.460]  Значит.
[23:41.260 --> 23:42.580]  Классы эквалентности.
[23:44.300 --> 23:45.540]  Классы эквалентности.
[23:46.660 --> 23:47.660]  Старого автомата.
[23:51.780 --> 23:53.180]  То есть автомат для строки С.
[23:54.140 --> 23:55.140]  Не изменяются.
[24:00.060 --> 24:02.580]  Потому что новых лонгистов не появляется, там тоже
[24:02.580 --> 24:05.580]  самое разбиение на классы, и эти классы, как множество
[24:05.580 --> 24:07.620]  слов, сохраняются прямо такими же.
[24:07.620 --> 24:10.620]  Значит, между ними сохраняются все переходы.
[24:10.620 --> 24:18.020]  Значит, между ними сохраняются все переходы.
[24:21.300 --> 24:24.060]  Поэтому вот то, что у меня было здесь, старый кусок
[24:24.060 --> 24:26.580]  автомата, он вообще никак не изменился.
[24:26.580 --> 24:28.420]  Потому что здесь с ним не поменялись классы, не поменялись
[24:28.420 --> 24:29.420]  ребра.
[24:29.420 --> 24:30.820]  То есть здесь я ничего не меняю.
[24:30.820 --> 24:33.980]  Единственное, что меняется, это только ребра в СС.
[24:33.980 --> 24:37.340]  Ну, а собственно, вот я их здесь все построил.
[24:37.340 --> 24:39.860]  Все вот эти вот вершинки, из которых не было перехода
[24:39.860 --> 24:46.100]  по С, я завожу переход в СС, и все, и это все возможные
[24:46.100 --> 24:47.100]  переходы в СС.
[24:47.100 --> 24:50.460]  То есть, смотрите сейчас, что я сказал.
[24:50.460 --> 24:54.580]  Я сказал, что вот в этом случае, если С0 это лонгистат Ку,
[24:54.580 --> 24:56.180]  то у меня старый автомат не поменялся, и все, что
[24:56.180 --> 24:59.580]  нужно сделать, это провести ребра из вот этих вершинок
[24:59.580 --> 25:03.300]  на все, что мы дошли до П, провести ребра по букве
[25:03.300 --> 25:05.100]  С в СС, и больше ничего делать не нужно.
[25:05.100 --> 25:17.060]  Что значит, что лонгисты сравним по длине?
[25:17.060 --> 25:19.700]  Нет, лонгисты – это какая-то конкретная строка.
[25:19.700 --> 25:28.500]  Да, но вот если они одинаковы как строки… Ну, это одно
[25:28.500 --> 25:31.300]  и то же, что по длине, это то же самое, что длинный
[25:31.300 --> 25:32.300]  процесс сравнить.
[25:32.300 --> 25:36.740]  Вот это условие равносильно тому, что лен от Ку равно
[25:36.740 --> 25:37.740]  лен от В плюс один.
[25:37.740 --> 25:54.380]  Так, значит, мы поняли, что внутри старого автомата
[25:54.380 --> 25:55.380]  ничего не меняется.
[25:55.380 --> 25:58.860]  Нам нужно понять, какие появляются переходы в СС.
[25:59.860 --> 26:13.660]  Как в него должны выглядеть ребра, ведущие в это самое
[26:13.660 --> 26:14.660]  СС.
[26:14.660 --> 26:17.940]  Ну, мы знаем, что это несколько ребер, на которых написан
[26:17.940 --> 26:20.900]  один и тот же символ, отвечающий последнему символу вот здесь.
[26:20.900 --> 26:25.900]  И они являются друг от дружки с уфиктными ссылками.
[26:25.900 --> 26:31.980]  И мне нужно вспомнить, какая классификация у этого
[26:31.980 --> 26:32.980]  множества слов.
[26:32.980 --> 26:35.940]  Значит, это слова, у которых раньше не было вхождений.
[26:35.940 --> 26:39.180]  Это такие слова, которые получили первое вхождение.
[26:39.180 --> 26:46.700]  То есть это суффиксы СС, давайте их нарисую.
[26:46.700 --> 26:57.220]  Так вот СС, это такие суффиксы, которые раньше не встречались.
[26:57.220 --> 27:01.900]  Иными словами, это такие суффиксы С, что приписывание
[27:01.900 --> 27:04.700]  С к ним в строке С невозможно, а теперь стало возможно.
[27:04.700 --> 27:09.540]  Ну, а то есть вот здесь вот хранятся все такие суффиксы,
[27:09.540 --> 27:11.780]  вот эти вот кружочки, овальчики, которых раньше не было
[27:11.780 --> 27:12.780]  в строке С.
[27:12.780 --> 27:14.420]  То есть это мы должны были взять какой-то суффикс
[27:14.420 --> 27:17.140]  из строки С, дописать к нему один символ.
[27:17.140 --> 27:19.220]  И как бы вот раньше нельзя было дописать С, то есть
[27:19.220 --> 27:21.500]  раньше с дописанием С это не было под строкой, теперь
[27:21.500 --> 27:22.500]  стало под строкой.
[27:22.500 --> 27:24.660]  Ну, значит, мне нужно просто взять всевозможные суффиксы
[27:24.660 --> 27:27.780]  строки С, из которых не было перехода по С, и добавить
[27:27.780 --> 27:29.260]  переход в СС.
[27:29.260 --> 27:31.300]  Вот ровно это мы и сделали.
[27:31.300 --> 27:37.260]  А мы прошлись по всем суффиксам строки С и проверили, если
[27:37.260 --> 27:40.020]  не было перехода по С, то я его создаю, а если есть,
[27:40.020 --> 27:41.740]  то я останавливаюсь, потому что из всех более коротких
[27:41.740 --> 27:42.740]  тем более есть.
[27:43.740 --> 27:47.740]  Ну, значит, вот мы целиком работали, это случай, вот этот.
[27:59.740 --> 28:01.740]  Так, давайте это напишем.
[28:01.740 --> 28:10.740]  В СС есть переходы из всех суффиксов С.
[28:11.740 --> 28:13.740]  Из всех суффиксов С.
[28:16.740 --> 28:18.740]  Из которых раньше не было перехода по С.
[28:19.740 --> 28:25.740]  Из которых раньше не было перехода по С.
[28:29.740 --> 28:33.740]  Значит, мне, чтобы восстановить все эти переходы, нужно
[28:33.740 --> 28:36.740]  взять С, многократно взять всю ссылку, то есть рассматривать
[28:36.740 --> 28:38.740]  все суффиксы строки С.
[28:38.740 --> 28:40.740]  Когда нет перехода по С, нужно его создать, а
[28:40.740 --> 28:44.740]  как только он появляется вот этот переход есть,
[28:44.740 --> 28:46.740]  то значит из всех коротких суффиксов тоже падавно
[28:46.740 --> 28:48.740]  будет такой переход, потому что это, соответственно,
[28:48.740 --> 28:50.740]  в какой-то строке в каком-то суффиксе после которого
[28:50.740 --> 28:53.740]  можно было прочитать С, а это какой-то еще
[28:53.740 --> 28:54.740]  более короткий суффикс, patent j negitime- crisesires takes
[28:54.740 --> 29:06.740]  meaning after a longer time probably could be
[29:06.740 --> 29:09.900]  куда они ведут неважно, они сохраняются, но главное,
[29:09.900 --> 29:11.860]  что больше ничего перенаправлять не нужно.
[29:11.860 --> 29:14.660]  То есть мы вот эти вот просмотрели, добавили такие переходы
[29:14.660 --> 29:16.980]  и на этом автомат перестроили.
[29:16.980 --> 29:20.860]  Так, вопрос есть сейчас?
[29:20.860 --> 29:21.860]  Хорошо.
[29:21.860 --> 29:28.700]  Ну и остается третий случай, это когда лонгест от Q не
[29:28.700 --> 29:31.700]  равно S0.
[29:31.700 --> 29:35.580]  Лонгест от Q не равно S0.
[29:36.580 --> 29:41.580]  То есть лен от Q не равно лен от P плюс 1.
[29:45.580 --> 29:47.580]  Значит, в этом случае картинка примерно следующая.
[29:49.580 --> 29:54.580]  Вот у нас была вершина P, отвечающая нескольким строчкам.
[29:57.580 --> 29:59.580]  Например, что-то такое.
[29:59.580 --> 30:00.580]  Самая длинная из них была S0.
[30:00.580 --> 30:03.580]  S0 это не так, не совсем.
[30:04.580 --> 30:06.580]  Два какая-то лонгеста от P.
[30:06.580 --> 30:09.580]  Дальше я дописываю символ C и получаю состояние Q.
[30:09.580 --> 30:12.580]  Поэтому все вот эти вот строчки после дописывания
[30:12.580 --> 30:14.580]  C попадают тоже в состояние Q.
[30:14.580 --> 30:15.580]  Что-то я их здесь нарисую.
[30:20.580 --> 30:21.580]  Вот.
[30:21.580 --> 30:22.580]  И это уже S0.
[30:22.580 --> 30:25.580]  Вот это вот самая длинная строка SP после приписывания
[30:25.580 --> 30:26.580]  C, это S0.
[30:26.580 --> 30:29.580]  Но это не самая длинная строка в Q.
[30:29.580 --> 30:31.580]  Значит, кто-то есть еще более длинный.
[30:31.580 --> 30:33.580]  То есть в Q есть какие-то более длинные строчки.
[30:33.580 --> 30:36.580]  Они тоже, конечно, все заканчиваются на C, потому что они все
[30:36.580 --> 30:37.580]  суффиксы один другого.
[30:37.580 --> 30:39.580]  Ну вот какие-то строчки есть более длинные.
[30:39.580 --> 30:42.580]  Значит, в частности, чтобы они существовали, сюда
[30:42.580 --> 30:44.580]  в Q должны быть какие-то еще другие переходы по букве
[30:44.580 --> 30:48.580]  C из каких-то там других более длинных вершин.
[30:48.580 --> 30:51.580]  Потому что здесь есть какие-то слова лишние.
[30:51.580 --> 30:54.580]  Ну не лишние, а длиннее, чем S0.
[30:54.580 --> 30:56.580]  Поэтому они в частности откуда-то появляются.
[30:56.580 --> 30:58.580]  Есть еще какие-то другие входящие ребра.
[30:59.580 --> 31:05.580]  Ну смотрите, мы же с вами знаем, что S0 – это теперь
[31:05.580 --> 31:07.580]  будет обязательно новый лонгест.
[31:07.580 --> 31:09.580]  S0 обязательно становится новым лонгестом.
[31:09.580 --> 31:12.580]  Если оно раньше не было лонгестом, то теперь обязательно станет.
[31:15.580 --> 31:17.580]  Так, это надо объяснить почему.
[31:17.580 --> 31:18.580]  Секунду.
[31:19.580 --> 31:21.580]  То есть я утверждаю, что в этом случае на самом деле
[31:21.580 --> 31:23.580]  вот этот класс большой, который раньше отвечал
[31:23.580 --> 31:26.580]  одной вершинки Q, он расшипляется на 2.
[31:26.580 --> 31:28.580]  Он расшипляется вот по этой линии.
[31:28.580 --> 31:31.580]  То есть слова, которые были длиннее, чем S0, остаются
[31:31.580 --> 31:32.580]  в этом состоянии Q.
[31:32.580 --> 31:36.580]  А все, которые S0 короче, вот это все ниже, чем S0,
[31:36.580 --> 31:40.580]  это будет отдельное состояние, которое вот образуется
[31:40.580 --> 31:42.580]  за счет того, что S0 становится лонгестом.
[31:43.580 --> 31:45.580]  Так, надо вспомнить критерий лонгест.
[31:47.580 --> 31:48.580]  Продлевается…
[31:51.580 --> 31:53.580]  Продлевается налево двумя разными буквками, да?
[31:53.580 --> 31:55.580]  Раньше не продлевался.
[31:55.580 --> 31:56.580]  Ну да.
[31:56.580 --> 31:58.580]  Значит, почему S0 становится…
[31:58.580 --> 32:00.580]  Это вот мы в конце прошлой лекции обсуждали, да?
[32:00.580 --> 32:02.580]  Почему это то самое, наша T?
[32:02.580 --> 32:04.580]  Потому что раньше, в предыдущем автомате,
[32:04.580 --> 32:06.580]  S0 влево продолжался единственным образом.
[32:07.580 --> 32:09.580]  Единственный образ, единственный способ,
[32:09.580 --> 32:11.580]  как эту строчку можно дополнить, буквой слева,
[32:11.580 --> 32:14.580]  до под строки S, это дописать вот эту букву,
[32:14.580 --> 32:16.580]  которая лежит в том же состоянии…
[32:16.580 --> 32:18.580]  Ну точнее, нужно взять строчку на один побольше
[32:18.580 --> 32:20.580]  из того же состояния, вот эта строчка,
[32:20.580 --> 32:22.580]  и этот символ сюда записать.
[32:22.580 --> 32:24.580]  Больше никаких других предыдущих символов быть не могло,
[32:24.580 --> 32:26.580]  потому что иначе, если бы эту строчку S0
[32:26.580 --> 32:28.580]  можно было бы двумя разными способами продлить влево,
[32:28.580 --> 32:30.580]  то это был бы уже обязательно лонгест.
[32:30.580 --> 32:32.580]  У нас есть критерий лонгеста.
[32:32.580 --> 32:34.580]  Напоминаю, критерий лонгеста – это что?
[32:34.580 --> 32:38.580]  Либо это префикс, либо есть два разных продолжения влево.
[32:38.580 --> 32:40.580]  И вот если у нас уже одно продолжение влево точно есть,
[32:40.580 --> 32:42.580]  то это не префикс, а если было бы другое,
[32:42.580 --> 32:44.580]  то это был бы лонгест.
[32:44.580 --> 32:48.580]  Но раз это не было лонгестом раньше,
[32:48.580 --> 32:50.580]  почему он теперь становится новым лонгестом?
[32:50.580 --> 32:52.580]  Ну потому что мы получим новое вхождение,
[32:52.580 --> 32:54.580]  и...
[32:56.580 --> 32:58.580]  Момент.
[33:22.580 --> 33:24.580]  Rick Showy
[33:49.580 --> 33:51.580]  Самый длинный суффикс.
[33:52.580 --> 34:13.960]  Да, да, смотрите, раньше у меня S0 влево продолжалось
[34:13.960 --> 34:16.460]  единственным образом, вот этим символом, а теперь
[34:16.460 --> 34:22.900]  мы точно знаем, что линк от класса, отвечающего
[34:22.900 --> 34:30.620]  S0, это S0, да, поэтому если я запишу S и все более короткие
[34:30.620 --> 34:39.140]  суффиксы, лежащие в том же классе, вплоть до S0, то
[34:39.140 --> 34:41.220]  мы понимаем, что гарантированно S0 должен быть лонгистом
[34:41.220 --> 34:43.220]  в своем классе, потому что я вот так вот отрезаю по
[34:43.220 --> 34:47.300]  одному символу, отрезал, отрезал, отрезал, вот все
[34:47.300 --> 34:50.260]  вот эти первые были не под строками S, а потом начиная
[34:50.260 --> 34:53.780]  с кого-то стали под строками S, ну значит, просто потому
[34:53.780 --> 34:56.640]  как устроен у нас класс эквивалентности, S0 обязательно лонгист в своем
[34:56.640 --> 34:58.620]  классе, потому что я отрезал по одному, оставался в
[34:58.620 --> 35:01.780]  одном классе, отрезал очередной, перешел в другой класс,
[35:01.780 --> 35:04.380]  да, ну как бы, если это не лонгист, то какая-то из
[35:04.380 --> 35:07.820]  этих должна была быть лонгистом в своем классе, поэтому
[35:07.820 --> 35:11.060]  вот эта вот S0, оно обязательно должно быть лонгистом в
[35:11.060 --> 35:25.460]  новом автомате, S0 обязательно является лонгистом в новом
[35:25.460 --> 35:26.460]  автомате.
[35:26.460 --> 35:33.780]  Ну вот, собственно, вот отвечает в случае, что вот этот символ
[35:33.780 --> 35:37.100]  какой-нибудь там, не знаю, X, отличен вот от этого Y,
[35:37.100 --> 35:40.180]  мы рисовали тоже в конце прошлой лекции, что это
[35:40.180 --> 35:43.300]  такая самая длинная строка, что у нее раньше каждое ее
[35:43.300 --> 35:46.660]  вхождение продлевалось влево Y, а теперь продлевается
[35:46.660 --> 35:50.580]  в частности каким-то новым X, что X не равен Y, вот, и
[35:50.580 --> 35:53.340]  это тогда обязательно новый лонгист, и раньше оно
[35:53.340 --> 35:56.020]  лонгистом не было, то теперь происходит расщепление
[35:56.020 --> 36:00.300]  вот этого класса Q, да, потому что раньше здесь было все
[36:00.300 --> 36:02.620]  вместе, а теперь это стало лонгистом, а поэтому здесь
[36:02.620 --> 36:03.620]  должно произойти расщепление.
[36:03.620 --> 36:23.260]  Так, вывод, класс должен расщепиться, должен расщепиться.
[36:23.260 --> 36:26.140]  Ну и понятно как, да, значит, должно появиться новое
[36:26.140 --> 36:29.300]  состояние, содержащее S0 и все более короткие, а
[36:29.300 --> 36:33.380]  в Q остаются все более длинные, чем S0.
[36:33.380 --> 36:36.420]  Давайте тогда для этого заведем новое состояние,
[36:36.420 --> 36:43.220]  заведем новое состояние, я его назову клон, потому
[36:43.220 --> 36:48.820]  что оно будет во многом очень похоже на Q, значит,
[36:48.820 --> 36:55.420]  лонгист от клон это будет S0, вот тот самый новый класс,
[36:55.420 --> 37:00.660]  который возникает из расщепления Q, ну а в Q остаются все остальные,
[37:00.740 --> 37:09.100]  остаются все остальные, все остальные строки, которые
[37:09.100 --> 37:11.300]  раньше там были, да, то есть вот эти вот более длинные,
[37:11.300 --> 37:12.300]  чем S0 остаются в Q.
[37:30.660 --> 37:37.380]  Так, значит, тогда у меня возникает новое состояние
[37:37.380 --> 37:44.300]  клон, где в частности лежит S0, строка S0, мне нужно понять,
[37:44.300 --> 37:51.580]  что происходит с ребрами из Q и в Q и из клона в клон,
[37:51.580 --> 37:54.380]  мы понимаем, что больше никаких вершин в нашем
[37:54.380 --> 37:56.100]  автомате не появляется, мы сказали, что их максимум
[37:56.100 --> 37:58.460]  две, вот они две появились, поэтому больше точно ничего
[37:58.460 --> 38:00.460]  не происходит, новых вершин не появится.
[38:00.460 --> 38:03.180]  Значит, что происходит с ребрами, смотрите, ну мы
[38:03.180 --> 38:07.460]  знаем, что в Q лежит в частности S0, поэтому вот этот переход
[38:07.460 --> 38:11.260]  из P по буквице мне нужно точно будет перенаправить
[38:11.260 --> 38:15.660]  вот сюда, да, потому что S0 это что такое, S0 это лонгист
[38:15.660 --> 38:18.900]  от P плюс C, вот я его должен точно так перенаправить,
[38:18.900 --> 38:21.540]  потому что раньше как бы этот переход был сюда,
[38:21.540 --> 38:23.540]  теперь он ведет в клон, потому что ну просто S0 тут
[38:23.540 --> 38:27.220]  лежит по определению, это ребро я удаляю, это перенаправляю
[38:27.220 --> 38:30.980]  сюда, ну и то же самое я должен делать со всеми
[38:30.980 --> 38:34.260]  вершинами на суффиксном пути, ну на пути по ссылкам
[38:34.260 --> 38:36.860]  из P, которые раньше вели в Q, то есть все вот эти вот
[38:36.860 --> 38:40.980]  ребра, ведущие раньше в Q, я должен удалить и перенаправить
[38:40.980 --> 38:44.700]  их в клон, потому что давайте опять S0 картинку, значит
[38:44.700 --> 38:48.980]  в Q лежит какая-то самая длинная строка, затем в какой-то
[38:48.980 --> 38:53.900]  момент будет S0 и какие-то ее суффиксы, соответственно
[38:53.900 --> 39:02.060]  Юна П отвечает какому-то вот этому отрезку и вот
[39:02.060 --> 39:05.180]  эти все отрезочки я должен перенаправить в клона, потому
[39:05.180 --> 39:06.860]  что теперь это новый, отдельный класс, отвечающий
[39:06.860 --> 39:11.500]  к клону, да, я должен все эти стрелки перенаправить,
[39:11.500 --> 39:14.900]  потому что они просто отщепились в отдельный класс, то есть
[39:14.900 --> 39:21.500]  это будет отвечать следующему, пока, ну как это можно реализовать,
[39:21.500 --> 39:30.940]  k, p не минус 1, и tu, p по букви c равно cu, мне нужно перенаправить
[39:30.940 --> 39:45.620]  стрелку клона и взять сувсылку. p равно линк от p.
[39:45.620 --> 39:48.780]  Потому что, как бы, вот я стоял в p все более ранние
[39:48.780 --> 39:54.820]  как бы сувсылки, ну точнее многократно применю сувсылки к p. Если из них был
[39:54.820 --> 39:57.580]  переход в cu, то соответственно это какие-то более короткие строки, чем с 0,
[39:57.580 --> 40:01.060]  они обязательно должны вести вот в новое cu, потому что сюда я свалил все более
[40:01.060 --> 40:11.780]  короткие строки. Так, вот, это я какие-то ребра перенаправил, но причем, смотрите,
[40:11.780 --> 40:16.540]  важно, что в cu какие-то ребра по-прежнему будут входить. Я многие перенаправил,
[40:16.540 --> 40:20.260]  но какие-то по-прежнему входят, которые отвечают вот этим более длинным строчкам.
[40:20.260 --> 40:25.460]  Мы уже замечали, что раз в cu были какие-то более длинные строки, то в cu еще кто-то входил,
[40:25.460 --> 40:33.660]  еще были какие-то ребра из более длинных строк. Вот это вот, да, вот оно. Что-то здесь было,
[40:33.660 --> 40:39.220]  какие-то были еще ребра, которые не лягут на пути по сувсылкам xp, и их я не трогаю. Все,
[40:39.220 --> 40:43.860]  что отвечало более длинным строкам, я не трогаю, оставляю так же, как было. Потому что это какая-то
[40:43.860 --> 40:48.420]  старая строка, она не изменилась при дописывании c, значит и в автомате тоже ничего не происходит.
[40:48.420 --> 40:52.900]  Вот, то есть какие-то ребра остаются, не то что у меня cu остается подвешенным в воздухе, в него
[40:52.900 --> 40:57.260]  кто-то ведет, но я просто на эти вершинки, я их даже не перебираю в моем алгоритме, я перебираю
[40:57.260 --> 41:05.340]  только те, которые вот, начиная с s0 и к более коротким. Их все я перенаправляю в клон. Так,
[41:05.340 --> 41:15.140]  что еще? Да, ну вот здесь в какой-то момент я мог перейти к вершине, которая по буквице вела уже
[41:15.140 --> 41:20.380]  не в q, а в какую-то другую вершину, не q. Тогда с ней я уже ничего не меняю, потому что мне нужно
[41:20.380 --> 41:26.140]  было только перенаправить вот эти вот ребра, ведущие в то, что было в q. То, что я от q отщепил
[41:26.140 --> 41:30.820]  какой-то кусок, в них нужно перенаправить ребра. А все, что еще более короткое, да, вот эти вот еще
[41:30.820 --> 41:35.500]  более короткие строки, они как были в отдельном состоянии, так там и остаются, поэтому я их тоже
[41:35.500 --> 41:43.640]  не меняю. Я меняю только то, что отвечало вот этому вот куску с s0. Так, это перестроил. Вот, и тем
[41:43.640 --> 41:48.780]  самым мы с вами уже определили все входящие ребра в q и в клона. То есть в q остаются все более
[41:48.780 --> 41:53.580]  длинные, вот эти вот мы их не трогаем, а все более короткие, которые раньше вели в q, теперь
[41:53.580 --> 41:58.940]  перенаправляются в клона. Вот, вот в этом цикле я перенаправляю все ребра нужные из q в клона,
[41:58.940 --> 42:06.380]  больше ничего делать с этими ребрами не нужно. Последнее, с ребрами это нужно разобраться,
[42:06.380 --> 42:13.860]  какие ребра ведут из q и из клона, что происходит с ребрами, исходящими из q и из клона. Ребра
[42:13.860 --> 42:26.500]  входящие в них мы разобрались. Что такое входящие ребра в q и в клон? Так, что сказал? Наоборот,
[42:26.500 --> 42:36.780]  исходящими. Что происходит с ребрами, с ребрами, исходящими из q и из клона.
[42:49.140 --> 42:53.060]  Чтобы это понять, полезно заметить следующее.
[42:56.500 --> 43:12.820]  Если мы рассмотрим правые контексты вот этих наших состоений относительно нового слова s,
[43:12.820 --> 43:22.140]  то они отличаются только эпсилоном. А именно, что в клоне есть эпсилон в качестве одного из
[43:22.140 --> 43:32.900]  элементов правого контекста, а в q его нет. Значит, почему это верно? Почему это верно?
[43:32.900 --> 43:41.180]  Ну, давайте смотреть. Чтобы понять, как соотносятся правые контексты, по сути,
[43:41.180 --> 43:47.300]  мне нужно посмотреть на вхождение вот этих вот слов в нашу строчку s, потому что каждый
[43:47.300 --> 43:51.700]  элемент из правого контекста, если что-то лежит в правом контексте, то значит вот
[43:51.700 --> 43:57.860]  здесь вот заканчивается очередное вхождение одного из слов нашего класса эквивалентности.
[43:57.860 --> 44:02.180]  Поэтому, по сути, правые контексты тоже самое, что множество вхождений в каком-то смысле. Множество
[44:02.180 --> 44:07.220]  вхождений однозначно создает правый контекст. Вот. Значит, как тогда отличаются правые контексты
[44:07.220 --> 44:15.900]  клона и q? Ну, мы знаем как. Единственное, чем они отличаются, то, что s0 получило новое вхождение,
[44:15.900 --> 44:22.980]  которое вот отвечает суффиксу строки sc. То есть, раньше они были все в одном классе, раньше все эти
[44:22.980 --> 44:30.300]  строчки были в одном классе. Потом у меня появился, у меня s расширилась, и s0 получило новое вхождение.
[44:30.300 --> 44:34.300]  Ну, значит, все вот эти более короткие тоже получили новое вхождение. А эти не получили.
[44:34.300 --> 44:40.900]  Раз они как бы не являются суффиксами sc, то есть s0 это самый длинный суффикс sc,
[44:41.900 --> 44:46.980]  то это значит не суффикс sc. Поэтому эти строчки вхождения как бы не получили, а эти получили. И,
[44:46.980 --> 44:52.180]  значит, единственное отличие множества вхождений, это то, что эти получили вот только что вот последнее
[44:52.180 --> 44:58.660]  вхождение. Оно заканчивается там же, где заканчивается sc. Давайте это запишем. Строки
[44:58.660 --> 45:13.260]  из множества клон, отвечающие классу клон, имеют на одно вхождение вsc больше,
[45:13.260 --> 45:37.500]  больше, чем строки sc. Да, то есть если вот, ну давайте я там нарисую какие-нибудь вхождения,
[45:37.500 --> 45:45.740]  вот там где-то какие-то вхождения элементов sc, то в дополнение к ним у клона есть еще вот такое
[45:45.740 --> 45:51.140]  вхождение. Ну, значит, правый контекст у них отличается только тем, что вот появляется такой,
[45:51.140 --> 45:56.700]  как бы правый контекст для такого слова, то есть епсилон. Ну и, собственно, ровно это здесь и
[45:56.700 --> 46:02.060]  написано. На что единственное отличие правых контекстов уклона и уку только в том, что здесь
[46:02.060 --> 46:06.420]  есть епсилон, а здесь нету. Ну и здесь нету, потому что это не суффикс sc, а это суффикс sc.
[46:06.420 --> 46:16.820]  Отсюда будет следовать следующее. Смотрите, правый контекст этих двух классов отличается
[46:16.820 --> 46:21.980]  только тем, что здесь есть епсилон. Поэтому эта вершинка как бы должна быть терминальная,
[46:21.980 --> 46:27.540]  терминальная как раз те, у которых, у которых в правом контексте есть епсилон. Значит,
[46:27.540 --> 46:32.820]  это должна быть терминальная, а кроме этого их как бы продолжение, всё что можно дописать
[46:32.820 --> 46:40.860]  справа, не отличается. Поэтому если я рассмотрю вершины к и клон, то все возможные пути добраться
[46:40.860 --> 46:45.680]  из к и или из клона до терминальной должны быть одинаковыми. Ну просто потому что у них одинаковые
[46:45.680 --> 46:51.040]  правые контексты кроме вот этого епсилона. То есть все не тревиальные пути из к или
[46:51.040 --> 46:55.860]  из колона до терминальной – это как бы одни и те же пути, просто потому что у них одинаковые правые
[46:55.860 --> 47:00.660]  контексты, по сути. А правые контексты — это как раз вот если я встал, то как я могу добраться до
[47:00.660 --> 47:06.340]  терминальной? Правые контексты — это то, какие строчки можно дописать справа к этой вершинке,
[47:06.340 --> 47:11.340]  чтобы попасть в терминальную вершину. Если у них одинаковые правые контексты, то эти пути у них
[47:11.340 --> 47:17.780]  устроены одинаково. Все, что было здесь, ну как бы все пути отсюда до терминалов, это то же самое,
[47:17.780 --> 47:23.340]  что пути отсюда до терминала. Кроме еще добавления, что это тоже терминальная сама по себе. И это
[47:23.340 --> 47:32.100]  единственное отличие между ними. Поэтому скажите, пожалуйста, какой вывод? Как должен выглядеть
[47:32.100 --> 47:49.180]  массив переходов из клона? Чему он равен? Что? Да, да, да. Просто тот ку. То есть еще раз,
[47:49.180 --> 47:54.820]  клон — это такая вершина, которая с точки зрения правых контекстов, с точки зрения продолжения
[47:54.820 --> 47:59.180]  до терминальных вершин ничем не отличается от ку. Поэтому вот если здесь были какие-то
[47:59.180 --> 48:07.980]  переходы, не знаю, там по а сюда, так сейчас я нарисую, это ку, по а сюда, по б сюда, то если
[48:07.980 --> 48:13.820]  я просто проведу такие же ребра, по а сюда же и по б сюда же, то у них будет одинаковый правый
[48:13.820 --> 48:18.260]  контекст. Все, что как бы справа написано, у них одинаковые пути. Просто потому что одинаковое
[48:18.260 --> 48:24.020]  начало, ну и дальше тоже все одинаково. Поэтому если я просто перекопирую содержимое этого массива
[48:24.020 --> 48:29.340]  вот сюда, ну или там мап, да, смотря как вы храните все эти переходы, вот если это просто массив для
[48:29.340 --> 48:33.660]  каждой буквы хранится, куда есть переход, то мне нужно просто этот массив целиком сюда перекопировать.
[48:33.660 --> 48:46.220]  Вот. И тем самым мы разобрались, как устроены ребра, исходящие из клона. Ну а ребра, исходящие из ку,
[48:46.220 --> 48:53.420]  остаются, потому что, ну тут все равно, да, тут остаются какие-то слова, вот ку это слова,
[48:53.420 --> 48:57.460]  которые длиннее, чем ис 0, там все переходы остаются такими же, как были, потому что если
[48:57.460 --> 49:04.420]  был какой-то переход отсюда по какому-то символу D в другую вершину, то он по-прежнему остается,
[49:04.420 --> 49:07.500]  да, здесь есть все равно, можно взять любое слово отсюда, дописать D и попасть сюда,
[49:07.500 --> 49:11.500]  поэтому все более старые переходы остаются. Появляются только новые переходы из клона,
[49:11.500 --> 49:21.460]  которые по сути просто дублируют все, что было раньше из ку. Вот. Все, значит все время разобрались,
[49:21.460 --> 49:32.020]  да. Вот, да, осталось с линками разобраться, давайте напишем сейчас. Ну, линк от ку чему равно? Это вы
[49:32.020 --> 49:43.980]  можете мне сказать. Да, давайте напишу так, new link от ку равно клон, ну просто надо посмотреть
[49:43.980 --> 49:50.540]  на картинку, вот оно ку, а вот он клон, что такое сувсылка? Это нам нужно отбрасывать первый символ
[49:50.540 --> 49:54.460]  до тех пор, пока не перейдем в новое состояние, вот оно новое состояние, поэтому сувсылка
[49:54.460 --> 50:04.220]  ведет сюда. А что такое новая сувсылка для клона? Это предыдущая для ку, потому что предыдущая для
[50:04.220 --> 50:08.260]  ку это была вот эта вот как раз маленькая строчка, да, лежащая в другом классе, ну,
[50:08.260 --> 50:18.140]  поэтому нужно ее сохранить в качестве новой сувсылки для клона. New link для клона это то,
[50:18.140 --> 50:24.460]  что раньше было линк от ку, потому что линк от ку это самая длинная строка, лежащая не в ку,
[50:24.460 --> 50:30.020]  но теперь я просто ку расщепил, расщепил на два, значит эта сувсылка будет теперь новой сувсылкой
[50:30.020 --> 50:39.300]  для меньшего из классов для клона. А сувсылка для sc мы уже знаем как выглядит, это всегда s0,
[50:39.300 --> 50:45.540]  сувсылка для sc это всегда класс содержащий s0, но в нашем случае это клон,
[50:45.540 --> 50:55.460]  потому что в клоне как раз самая длинная строка будет s0. Вот вроде мы все написали.
[51:09.540 --> 51:15.740]  Так, тогда давайте сейчас я напишу код этого всего безобразия вместе, все три случая,
[51:15.740 --> 51:26.540]  и мы разберемся с асимптотикой. Значит, что мне надо? Мне нужно какая-то струк нод,
[51:26.540 --> 51:39.740]  где я храню как бы всю информацию про вершинку. Здесь в частности есть линк, тул, лен, ну нет,
[51:39.740 --> 51:47.620]  флаг терминальности не буду, вроде этого хватает мне, да. То есть у меня вершинки будут
[51:47.620 --> 51:54.060]  занумерованы числами, линк от вершинки это номер вершинки куда ведется сувсылка,
[51:54.060 --> 52:01.540]  лен это длина лонгиста в этой вершинке. Ну а тут давайте сейчас что это мапа по каждому символу,
[52:01.540 --> 52:06.340]  если этот символ есть в множестве переходов, то мы отобираемся в номер вершинки куда попадаем,
[52:06.340 --> 52:12.220]  если символа нету в множестве переходов, то просто такого ключа в мапе нет. Что дальше,
[52:12.220 --> 52:18.300]  например, какой-нибудь вектор нодов, ну я его привык называть Т, пусть он у меня будет Т,
[52:18.300 --> 52:25.540]  это вот собственно наш сувстамат, там будут просто перечислены вершины, в смысле просто в каком-то
[52:25.540 --> 52:32.300]  порядке валяться все вершины. И в мейне где-нибудь там в самом начале мы в Т пушбэкнем пустую вершину,
[52:32.300 --> 52:43.260]  пушбэк нод, это будет корень. Изначально мы добавим в наш в наш автомат просто корневую вершинку,
[52:43.260 --> 52:48.820]  это будет автомат отвечающий в пустой строке, то есть корень без переходов, вот просто пустая
[52:48.820 --> 52:55.020]  вершина да стартовая из которой ничего нельзя прочитать, это пустая строка. Дальше наша процедура
[52:55.020 --> 53:07.420]  добавление символа C, чар С. Так момент, сейчас мне еще нужна переменная last,
[53:07.420 --> 53:26.900]  это переменная отвечающая S, переменная номер класса S, изначально С это пустая строка и last
[53:26.900 --> 53:41.140]  равно нулю как номер корня, номер корня ноль. Добавляем символ. Для этого сначала мы заводим новую
[53:41.140 --> 53:52.940]  вершинку отвечающую классу, отвечающую строке С, ну давайте я сделаю T пушбэк нод, да добавил
[53:52.940 --> 54:00.260]  список вершин к еще одну вершину. Давайте я скажу, что у нее номер кур равен там T.size-1,
[54:00.260 --> 54:18.020]  да простит меня автоматическое приведение типов. Так, что еще? Что еще я хочу сделать? А, ну нужно
[54:18.020 --> 54:30.940]  у кура например выставить лен. Скажите пожалуйста чему равно T кур точка лен? То есть кур это вершина
[54:30.940 --> 54:39.260]  отвечающая С, вон она, давайте я здесь нарисую, что вот это вот это это кур, а это last, предыдущая
[54:39.260 --> 54:47.940]  вершина отвечающая С. Тогда чему равно T кур точка лен? Какая у нее длина? Ну да, last точка лен плюс один.
[54:47.940 --> 55:00.260]  T last точка лен плюс один, потому что отличается дописывание одному символу от С. Дальше,
[55:00.260 --> 55:13.220]  P равно last и я беру многократную сувсылку от этого P пока нет перехода по букве С. Этот кусок кода
[55:13.220 --> 55:18.980]  я уже писал, но продублирую, значит пока P не минус 1, а да здесь по умолчанию значение сувсылки
[55:18.980 --> 55:32.460]  это минус 1. Кур это вершина отвечающая С. Так, ну раз-то у меня мапа, то я должен написать,
[55:32.460 --> 55:44.580]  я вот так это пишу, tp to counts C. Вот так, да, то есть если в мапе tp.to нет буквы С,
[55:44.580 --> 55:57.100]  тогда я должен переход создать tp.to по букве С равно кур. Я создаю переход из P кур и прыгаю по
[55:57.100 --> 56:09.940]  сувсылке из P. P равно tp.link. Встал сначала в last, вот P равно last. Потом многократно применяю
[56:09.940 --> 56:14.020]  сувсылку до тех пор, пока не найду переход по букве С. И пока этого перехода не было,
[56:14.020 --> 56:24.100]  я завожу переход по букве С в новой сцене кур. Первый случай, если P равно минус 1. Это
[56:24.100 --> 56:29.220]  случай, когда буква С появляется впервые в нашем слове. Буква С раньше никогда не было,
[56:29.220 --> 56:35.380]  нет ни одного перехода по букве С. Тогда больше ничего с автоматом не происходит. Нужно просто
[56:35.380 --> 56:41.460]  назначить кур.link. Мы знаем, что в этом случае нужно отправиться в корень, то есть вершинку
[56:41.460 --> 56:51.300]  номер ноль. Здесь я еще напишу last равно кур, потому что меняется указатель на последнюю вершину,
[56:51.300 --> 56:53.900]  отвечающую всей строке, ну и return.
[56:53.900 --> 57:22.620]  Иначе, P это какая-то вершинка, нормальная вершина, из которой есть переход по C.
[57:22.620 --> 57:38.100]  Тогда давайте пусть он ведет в вершинку Q. То есть Q это tp.tuc. Второй случай, если tq.len равно tp.len
[57:38.100 --> 57:45.700]  плюс 1. Это хороший случай, когда S0 не является новым лонгестом, потому что она и так раньше
[57:45.700 --> 57:50.820]  была лонгестом. S0 было равно лонгест от Q. Ничего не расщепляется, нужно просто переназначить
[57:50.820 --> 58:06.220]  су-всылку. tq.link равно Q. Точно так же last равно кур и return. Это второе случае у нас было,
[58:06.220 --> 58:12.420]  когда ничего не расщепляется. Ну и, конечно, третье, когда Q расщепляется в две вершинки Q и
[58:12.420 --> 58:20.900]  clon. Нам нужно сначала завести новую вершинку, то есть в вектор вершин добавить новую какую-то,
[58:20.900 --> 58:31.620]  t pushback node. Добавили новую вершинку и сказали, что она равна, ну ее номер это clon. clon равно
[58:31.620 --> 58:32.980]  опять t.size минус 1.
[58:44.900 --> 58:54.540]  Так, теперь перенаправляем ребра, ведущие в Q, чтобы они теперь вели в clon. Пока p не равно
[58:54.540 --> 59:06.140]  минус 1 и tp tu t равно clon равно Q. Нужно их перенаправить в clon.
[59:24.540 --> 59:51.700]  Что? Да, да, действительно, спасибо. Так, это мы сделали. Теперь надо разобраться,
[59:51.700 --> 01:00:00.580]  наоборот, с исходящими ребрами. Я могу прям так написать tclon.tu равно tq.tu, потому что это
[01:00:00.580 --> 01:00:06.060]  мапы и можно их просто перекопировать. Теперь нужно с характеристиками clon еще разобраться.
[01:00:06.060 --> 01:00:15.540]  Во-первых, какая у него link мы знаем. Это то, что раньше было линкой для Q. И мы знаем,
[01:00:15.540 --> 01:00:28.060]  что у него линка, у него лен. tclon.len. Это что такое tclon.len? Еще раз.
[01:00:28.060 --> 01:00:47.980]  Ну, мы с вами писали, что s0 – это лонгест… Да, да, да, да. Напоминаю, что s0 – это лонгест от
[01:00:47.980 --> 01:00:55.100]  p плюс символ c, и при этом оно же – это лонгест от clon. Мы clon так вводим, что s0 – в нем новый
[01:00:55.100 --> 01:01:00.940]  лонгест. Значит, просто длина этой штуки на один больше, чем длина лонгеста от p. То есть,
[01:01:00.940 --> 01:01:12.420]  мы нужно взять tp.len и прибавить единицу. Так, len, link, разобрались. Дальше напишу вот так.
[01:01:12.420 --> 01:01:30.780]  tqr.link равно tq.link равно clon. Ну, мы писали, что у обеих этих вершинок ссылка будет вести в clon.
[01:01:30.780 --> 01:01:42.500]  Вот, я их здесь же переназначаю. Вроде все, last равно qr и return. Конец.
[01:01:42.500 --> 01:02:11.900]  Вот. Еще раз. А нам p не нужно уже. Да, вы гений. Надо вот сюда просто написать. Давайте вот
[01:02:11.900 --> 01:02:20.420]  это вот просто сюда перенесу. Спасибо. Вот. До вот этого подсчета я посчитаю tclon.len. Так
[01:02:20.420 --> 01:02:27.900]  лучше? Все, хорошо. Действительно, да, это важное замечание. Иначе у нас p какая-то фигня. Вот. Ну,
[01:02:27.900 --> 01:02:32.900]  вроде все сделали. Все случаи рассмотрели, написали. Значит, повторюсь, что эта штука,
[01:02:32.900 --> 01:02:37.820]  add c, она добавляет по одному символу, и если мы хотим постойте автомат для строки s,
[01:02:37.820 --> 01:02:43.100]  то нам нужно запустить add для всех символов строки s. Вот. И дальше, если нам нужно еще
[01:02:43.100 --> 01:02:50.420]  терминальности пометить, значит, после add, давайте я напишу. Значит, add. Если запускаю add для
[01:02:50.420 --> 01:02:58.900]  всех символов строки нашей, от s0 до sn-1, то в конце last отвечает классу строки s. Ну, и чтобы
[01:02:58.900 --> 01:03:02.500]  пометить терминальности, чтобы отметить все вершины, которые являются терминальными,
[01:03:02.500 --> 01:03:06.340]  не нужно многократно брать у этой штуки соусылку и все их помечать терминальными,
[01:03:06.340 --> 01:03:11.260]  потому что как раз last – это s и несколько самых длинных суффиксов. Чтобы взять следующий
[01:03:11.260 --> 01:03:21.340]  суффикс, нужно взять соусылку, ну и так далее. Чтобы пометить терминальные вершины,
[01:03:21.340 --> 01:03:32.780]  нам нужно сделать что-то типа такого. Пока while last не равно минус 1, нам нужно там сказать
[01:03:32.780 --> 01:03:46.860]  t last.term равно true, пометить терминальные и взять соусылку. last равно t last link. Да,
[01:03:46.860 --> 01:03:50.740]  если у меня есть вершина, отвечающая все строки s, то мне нужно просто много раз взять у нее
[01:03:50.740 --> 01:03:55.660]  соусылку, все их пометить терминальными. Это будут как раз все суффиксы и только они. И только они.
[01:03:55.660 --> 01:04:05.580]  Вот в самом конце, в мейне, грубо говоря, когда вы все эдды запустили, в мейне вы делаете еще вот
[01:04:05.580 --> 01:04:19.740]  это while. То есть это не в эдде, а в самом конце в мейне. Вопросы? Окей. Значит,
[01:04:19.740 --> 01:04:23.260]  всегда нужно разобраться с симптотикой. Для этого нам нужно будет следующее утверждение.
[01:04:23.260 --> 01:04:49.060]  Пусть суффиксный автомат постоит по строке длины n. Тогда в нем, во-первых,
[01:04:49.060 --> 01:05:01.860]  не больше, чем 2n-1 вершина, во-вторых, не больше, чем 3n-4 ребра. Вот это все работает,
[01:05:01.860 --> 01:05:10.300]  кажется, если n хотя бы тройка. Давайте напишем, да, если n хотя бы, давайте напишу n хотя бы n0.
[01:05:10.300 --> 01:05:17.900]  То есть при всех n, начиная с некоторого, вот это будут верные оценки. Вот, то есть асимптотически
[01:05:17.940 --> 01:05:23.060]  у нас вершин максимум 2n и ребра максимум 3n. И отсюда будет следовать, что время работы будет
[01:05:23.060 --> 01:05:27.260]  линейная, потому что если у нас... Т.е. у нас на самом деле так, почти понятно, что все линейное,
[01:05:27.260 --> 01:05:31.740]  потому что на каждом шаге заводятся две вершинки всего, максимум. У нас тутża непонятность,
[01:05:31.740 --> 01:05:36.260]  что с ребрами. Когда мы их перенаправляем, вот, например, вот здесь, вот. Вот, тут когда мы
[01:05:36.260 --> 01:05:41.340]  делаем перенаправление ребер, и тут когда мы копируем это вот это теклон. avail.tu,
[01:05:41.340 --> 01:05:46.340]  равно текуто т. т., непонятно сколько там ребр копируется. Но если вот суммарно их всего линейное
[01:05:46.340 --> 01:05:48.660]  количество, в то время работа будет тоже линейным.
[01:05:48.660 --> 01:05:52.660]  Так, ну доказательства.
[01:05:52.660 --> 01:06:10.020]  Во-первых, а, ну хорошо, да, давайте так напишем,
[01:06:10.020 --> 01:06:11.020]  начиная с двойки.
[01:06:11.020 --> 01:06:16.020]  Значит так, а2, да, похоже на правый.
[01:06:16.420 --> 01:06:18.980]  Давайте попытаемся понять, как может выглядеть автомат
[01:06:18.980 --> 01:06:21.420]  на слове из двух элементов.
[01:06:21.420 --> 01:06:25.780]  Если он равно 2, то у нас есть всего два слова, по сути,
[01:06:25.780 --> 01:06:30.780]  это слова аа и аб, ну как бы с точки зрения равенства
[01:06:30.780 --> 01:06:33.700]  символов, с точки зрения того, как выглядит автомат,
[01:06:33.700 --> 01:06:35.180]  либо это одинаковые символы, либо разные.
[01:06:35.180 --> 01:06:38.060]  В этом случае, что такое автомат?
[01:06:38.060 --> 01:06:42.260]  Это же, видимо, что-то такое, ну там терминальность
[01:06:42.260 --> 01:06:45.220]  не буду обозначать, но это вот такая штучка, и это
[01:06:45.220 --> 01:06:52.660]  как раз 2n-1, в этом случае будет вот такой путь, и видимо
[01:06:52.660 --> 01:06:53.660]  вот такой путь.
[01:06:53.660 --> 01:07:10.380]  Аа это аб, тут тоже максимум 2n-1 вершина, еще раз, ага,
[01:07:10.380 --> 01:07:12.820]  да, ну значит, хорошо, значит, это верно для всех n, начиная
[01:07:12.820 --> 01:07:15.980]  с двойки, а это, видимо, для всех начиная с, ну вот
[01:07:15.980 --> 01:07:20.060]  я поэтому и написал, начиная с какого-то, вот, ну, давайте
[01:07:20.060 --> 01:07:23.220]  все-таки верну вот эту вот общую запись, потому что
[01:07:23.220 --> 01:07:28.100]  неважно, что там происходит для маленьких n, вот, но
[01:07:28.100 --> 01:07:30.940]  здесь уже верно для двойки, что там, как бы строка ни
[01:07:30.940 --> 01:07:33.300]  выглядела, здесь максимум вот столько вершин, но дальше,
[01:07:33.300 --> 01:07:35.620]  раз на каждом шаге добавляются максимум две, то их всего
[01:07:35.620 --> 01:07:48.500]  максимум 2n-1, начиная с, наверное, двойки, так-так-так-так-так,
[01:07:48.500 --> 01:07:52.620]  при n больше двойки каждый раз добавляется максимум
[01:07:52.620 --> 01:07:59.260]  две вершины, каждый раз добавляется не больше двух
[01:07:59.260 --> 01:08:11.900]  вершин, значит, их всегда не больше, чем 2n-1, так,
[01:08:11.900 --> 01:08:22.980]  пункт b, пункт b, давайте я веду такое, в общем, буду
[01:08:22.980 --> 01:08:29.220]  называть ребро жестким, если оно ведет, ну, не так сейчас
[01:08:29.220 --> 01:08:38.300]  момент, значит, ребро из p в q, назовем жестким, назовем
[01:08:38.300 --> 01:08:52.420]  жестким, если len от p плюс 1 равно len от q, ну, это вот
[01:08:52.420 --> 01:08:57.220]  как раз тот хороший случай, когда мы взяли лонгест отсюда,
[01:08:57.220 --> 01:09:00.100]  дописали один сим и получили лонгест отсюда, тогда такое
[01:09:00.100 --> 01:09:04.140]  ребро я буду называть жестким, а если у них len и на 1 отличаются
[01:09:04.140 --> 01:09:09.580]  ровно, тогда, во-первых, понятно, что в каждую вершину
[01:09:09.580 --> 01:09:15.900]  входит ровно одно жесткое ребро, кроме корня, в каждую
[01:09:15.900 --> 01:09:18.020]  вершину, отличную от корня, входит ровно одно жесткое
[01:09:18.020 --> 01:09:20.620]  ребро, потому что, ну, что такое вершина, вот какая-то
[01:09:20.620 --> 01:09:26.580]  вершина, есть соответствует некий набор слов, мы знаем,
[01:09:26.580 --> 01:09:30.460]  как выглядят все ребра, ведущие в эту вершину, это какое-то
[01:09:30.460 --> 01:09:33.980]  разбиение вот этого множества слов на подотрезке, да,
[01:09:33.980 --> 01:09:36.580]  от них от всех надо отбросить последний символ, соответственно,
[01:09:36.580 --> 01:09:39.580]  это там первая вершина, это вторая, это третья, значит,
[01:09:39.580 --> 01:09:42.820]  просто если возьму вот эту, то это будет жесткое ребро,
[01:09:42.820 --> 01:09:46.620]  в каждую вершину кроме корня входит ровно одно жесткое
[01:09:46.620 --> 01:09:51.860]  ребро, значит, если я оставлю только жесткие ребра, то
[01:09:51.860 --> 01:09:56.420]  у меня будет максимум 2n-2 ребра, и останется посмотреть
[01:09:56.420 --> 01:09:58.940]  только на нежесткие ребра и доказать, что их не очень
[01:09:58.940 --> 01:10:23.860]  много. Каждую вершину, отличную от корня, ведет ровно одно
[01:10:23.860 --> 01:10:39.420]  жесткое ребро, следовательно, всего жестких ребер не больше
[01:10:39.420 --> 01:10:49.500]  чем 2n-2, верно? Все кроме корня, не больше чем 2n-2. Теперь
[01:10:49.500 --> 01:10:57.020]  рассматриваем нежесткие ребра. Нежесткая. Давайте
[01:10:57.020 --> 01:11:03.940]  докажем, что нежестких ребер мало. Для этого давайте
[01:11:03.940 --> 01:11:07.180]  каждому нежесткому ребрусу поставим следующую строчку.
[01:11:07.180 --> 01:11:11.340]  Сначала мы берем, ну, по сути, просто лонгест, вот
[01:11:11.340 --> 01:11:14.540]  у меня есть ребро из ПФК, нежесткое. Сначала я беру
[01:11:14.540 --> 01:11:17.580]  лонгест от П, то есть самый длинный путь от стартовой
[01:11:17.580 --> 01:11:22.860]  вершинки, вот корня, до П, самый длинный путь. То
[01:11:22.860 --> 01:11:26.140]  есть это по сути просто лонгест от П. Затем пишу
[01:11:26.140 --> 01:11:29.500]  этот символ на этом ребре, и в конец еще приписываю
[01:11:29.500 --> 01:11:33.660]  самый длинный путь из Q в какую-то терминальную вершину.
[01:11:33.660 --> 01:11:38.700]  Самый длинный. Из всех возможных окончаний Q до терминала,
[01:11:38.700 --> 01:11:40.860]  из всех возможных путей отсюда до терминальной
[01:11:40.860 --> 01:11:44.300]  вершины, я выбираю самый длинный. И для этого нежесткого
[01:11:44.300 --> 01:11:47.980]  ребра, ну, как бы, ставлю ему в соответствующую строчку,
[01:11:47.980 --> 01:11:52.460]  давайте я напишу ее там, альфа, ц, бета. Ц у меня
[01:11:52.460 --> 01:11:56.620]  приходит в альфа, ц, бета. Самый длинный путь из стартов
[01:11:56.620 --> 01:12:04.620]  П, потом ц, потом самый длинный путь из Q до терминала. Тогда,
[01:12:04.620 --> 01:12:11.580]  да. Нет, не обязательно. Более того, гарантировано,
[01:12:11.660 --> 01:12:15.100]  гарантировано неравно, потому что если бы это было всей
[01:12:15.100 --> 01:12:17.060]  строкой, то все ребра были бы жесткие по дороге на
[01:12:17.060 --> 01:12:23.060]  самом деле. Мы еще это заметим. Значит, верно, чуть более,
[01:12:23.060 --> 01:12:25.580]  верно, другое. Верно, что все вот эти вот строчки
[01:12:25.580 --> 01:12:28.980]  для различных нежестких ребер, во-первых, суффиксы
[01:12:28.980 --> 01:12:32.540]  строки С, во-вторых, все различные, попарно различные.
[01:12:32.540 --> 01:12:36.700]  Значит, почему это все суффиксы? Почему это суффикс? Да,
[01:12:36.700 --> 01:12:39.740]  это не С, это суффикс С. Ну, просто потому что это
[01:12:39.740 --> 01:12:42.140]  означает в некотором пути от старта до терминала,
[01:12:42.140 --> 01:12:45.780]  поэтому это гарантированно суффикс. С другой стороны,
[01:12:45.780 --> 01:12:49.540]  все вот эти строчки по разным нежестким ребрам С, они обязательно
[01:12:49.540 --> 01:12:52.180]  различные, потому что можно легко понять, что на этом
[01:12:52.180 --> 01:12:55.820]  пути обязательно все ребра жесткие. Ну, потому что если
[01:12:55.820 --> 01:13:00.820]  здесь есть хоть нежесткое ребро… Так, давайте разбираться.
[01:13:00.820 --> 01:13:05.900]  Давайте разбираться. Сейчас, одну секунду. Сейчас, сейчас,
[01:13:30.900 --> 01:13:37.900]  у меня есть некая стартовая вершина и вершина П, я выбираю
[01:13:39.060 --> 01:13:44.420]  самый длинный путь из Q0 в П. Почему на нем все ребра
[01:13:44.420 --> 01:13:46.740]  жесткие обязательно? Почему Лен каждый раз увеличивает
[01:13:46.740 --> 01:13:53.740]  все равно на 1? Ну, здесь все понятно, потому что
[01:14:00.820 --> 01:14:04.820]  здесь есть какой-то конкретный Лен от П. Лен от П у нас
[01:14:04.820 --> 01:14:07.380]  означает как раз самое длинное слово, которое можно
[01:14:07.380 --> 01:14:11.620]  пересчитать от старта до вершинки П. Поэтому… Ну,
[01:14:11.620 --> 01:14:14.420]  точно есть путь вот такой длины. Что происходит с
[01:14:14.420 --> 01:14:17.060]  ребрами на этом пути? Почему они все обязательно жесткие?
[01:14:17.060 --> 01:14:20.220]  Ну, я вот так вот беру и еду по этому пути, вот такой
[01:14:20.220 --> 01:14:25.860]  вот длины из стартов П. Они все у меня обязательно
[01:14:25.860 --> 01:14:28.660]  жесткие, потому что Лен вот здесь возрастает ровно
[01:14:28.660 --> 01:14:31.580]  на единичку. Здесь у меня было слово длины 0, тут слово
[01:14:31.580 --> 01:14:35.060]  длины 1, 2, 3, 4 и так далее, Лен от П. И если в какой-то
[01:14:35.060 --> 01:14:37.540]  момент у меня было такое, что Лен отсюда, ну там не
[01:14:37.540 --> 01:14:42.100]  знаю, пусть это будет х, у, если вдруг Лен от у больше
[01:14:42.100 --> 01:14:49.100]  чем 1 плюс Лен от х, то значит этот путь можно был… Да,
[01:14:50.900 --> 01:14:55.060]  то значит отсюда до сюда есть более длинный путь. Противоречие,
[01:14:55.060 --> 01:14:58.780]  потому что я предположил, что это самый длинный. Значит
[01:14:58.780 --> 01:15:01.740]  просто на этом пути от Q0 до P самый длинный путь имеет
[01:15:01.740 --> 01:15:04.300]  такую длину, поэтому все ребра на нём обязательно
[01:15:04.300 --> 01:15:09.500]  жесткие, иначе есть какой-то более длинный путь. Ну то
[01:15:09.500 --> 01:15:15.180]  же самое с Q и каким-то терминалом. Да, если я рассмотрю самый
[01:15:15.180 --> 01:15:20.620]  длинный путь от Q до терминала, почему здесь все ребра обязательно
[01:15:20.620 --> 01:15:28.220]  жесткие. Так, секунду.
[01:15:50.620 --> 01:15:57.620]  Ну видим примерно потому же, что если здесь есть неколебро
[01:16:09.620 --> 01:16:13.220]  из х в у, такое, что Лен от у больше чем 1 плюс Лен
[01:16:13.220 --> 01:16:18.620]  от х, то значит, что до у можно дойти более длинным
[01:16:18.620 --> 01:16:22.180]  путем и опять путь увеличить. И возможно, если что, можно
[01:16:22.180 --> 01:16:26.100]  будет перейти в другую терминальную вершину, как-то вот так,
[01:16:26.100 --> 01:16:29.300]  и тем самым еще больше наш путь увеличить. Так,
[01:16:29.300 --> 01:16:32.220]  значит здесь я понял, что я не до конца понимаю.
[01:16:32.220 --> 01:16:35.740]  Давайте это оставим на следующий раз. Сейчас не могу сказать.
[01:16:35.740 --> 01:16:39.260]  На пути. Здесь все понятно, просто потому что если
[01:16:39.260 --> 01:16:41.100]  есть нежесткая ребра, то тогда вот это начало можно
[01:16:41.100 --> 01:16:46.540]  изменить на более длинное. Тут я пока не до конца соображаю.
[01:16:46.540 --> 01:16:53.540]  Так что давайте это оставим пока. На пути от Q до терминальной,
[01:17:00.540 --> 01:17:01.540]  все ребра тоже жесткие.
[01:17:01.540 --> 01:17:14.540]  Почему? А, просто первое... А, ну да, кстати.
[01:17:15.540 --> 01:17:22.540]  Типа просто у них отличаются первые... Да, действительно,
[01:17:22.540 --> 01:17:24.860]  смотрите. Возможно, это и правда не нужно, потому
[01:17:24.860 --> 01:17:28.740]  что что я здесь утверждал? Я утверждаю, что вот эти
[01:17:28.740 --> 01:17:31.620]  вот строчки А, С, Б, которые я строю для всех нежестких
[01:17:31.620 --> 01:17:34.180]  ребр, они все будут попарно различными. Но это просто
[01:17:34.180 --> 01:17:37.260]  верно потому, что если я рассматриваю различные
[01:17:37.260 --> 01:17:40.340]  нежесткие ребра, то по сути у меня вот эта А, С, Б, это
[01:17:40.340 --> 01:17:47.340]  первое нежесткое ребро. И если у меня вот эти строчки
[01:17:51.140 --> 01:17:55.620]  совпадают для каких-то разных ребер, то получается, что
[01:17:55.620 --> 01:18:01.940]  здесь есть... Да, то есть у них тогда вот совпадают
[01:18:01.940 --> 01:18:04.380]  эти префиксы по жестким ребрам, значит они вот здесь
[01:18:04.380 --> 01:18:06.900]  вот общие, потом идет то же самое обязательно нежесткое
[01:18:06.900 --> 01:18:09.820]  ребро, а мы предположим, что они разные. Поэтому вроде
[01:18:09.820 --> 01:18:11.940]  действительно нам не обязательно даже понимать, что здесь
[01:18:11.940 --> 01:18:14.900]  все ребра жесткие, главное, что на этом префиксе они
[01:18:14.900 --> 01:18:17.900]  жесткие, потому что тогда если двум разным нежестким
[01:18:17.900 --> 01:18:21.260]  ребрам отвечают одинаковые слова, то у них должны совпадать
[01:18:21.260 --> 01:18:24.260]  первые нежесткие, то есть С, С штрихом, а это мы предположим,
[01:18:24.260 --> 01:18:27.980]  что разные ребра. Окей, значит ну все, тогда получается,
[01:18:27.980 --> 01:18:30.780]  что нежестких ребер не больше, чем различных суффиксов
[01:18:30.780 --> 01:18:36.500]  строки С. И при этом более того, вся строка С никакому
[01:18:36.500 --> 01:18:39.340]  вот такому цени соответствует, потому что если мы рассматриваем
[01:18:39.340 --> 01:18:54.980]  строчку С, значит в пути, отвечающем строке С, все
[01:18:54.980 --> 01:19:01.380]  ребра жесткие. Ну просто потому что это вообще самый
[01:19:01.380 --> 01:19:04.300]  длинный путь из ку-ноль куда-либо. Самый длинный
[01:19:04.300 --> 01:19:06.660]  путь из ку-ноль куда-либо, это как бы самая длинная
[01:19:06.660 --> 01:19:16.900]  подстрока С, то есть С, так как С самый длинный путь
[01:19:16.900 --> 01:19:22.780]  из С0, из ку-ноль, из стартовой вершинки. Итого, с тем нежестким
[01:19:22.780 --> 01:19:26.340]  ребром отвечают различные суффиксы, и при этом С как
[01:19:26.340 --> 01:19:30.100]  суффикс никому не отвечает. Вывод нежестких не больше
[01:19:30.100 --> 01:19:40.940]  чем n-1. Нежестких ребер не больше, чем n-1. На каждом
[01:19:40.940 --> 01:19:42.940]  ребру соответствует суффикс, все суффиксы различные,
[01:19:42.940 --> 01:19:46.580]  при этом ни один из суффиксов не равен S. Ну и не равен
[01:19:46.580 --> 01:19:48.820]  конечно Эпсилоном, потому что в Эпсилоне у меня вообще
[01:19:48.820 --> 01:19:54.140]  нет ни одного символа, а тут есть символы. Поэтому
[01:19:54.140 --> 01:19:57.140]  всего суммарно мы получили, что ребер максимум 3n-3.
[01:19:58.140 --> 01:20:02.140]  Сейчас еще единичку можно тоже скостить. Так, 5 минут
[01:20:02.140 --> 01:20:03.140]  осталось.
[01:20:14.140 --> 01:20:22.140]  Ой, значит из того, ребер не больше чем 3n-3, но при
[01:20:22.140 --> 01:20:26.140]  этом их может быть ровно 3n-3, если у меня вот здесь
[01:20:26.140 --> 01:20:34.140]  вот достигается ровно 2n-1. На самом деле можно показать,
[01:20:34.140 --> 01:20:45.140]  можно показать, что вершин будет 2n-1, если и только если
[01:20:45.140 --> 01:20:49.140]  строка имеет вид, если и только если строка имеет
[01:20:49.140 --> 01:20:59.140]  вид, а, и потом куча раз Б. Если что-то другое, то
[01:20:59.140 --> 01:21:03.140]  классов меньше будет. Ну и соответственно нам нужно
[01:21:03.140 --> 01:21:06.140]  понять следующее, что для строк такого вида у меня
[01:21:06.140 --> 01:21:11.140]  максимум 3n-4 ребер, а для строка другого вида мы уже
[01:21:11.140 --> 01:21:14.140]  понимаем, что здесь тогда будет меньше вершин 2n-2,
[01:21:14.140 --> 01:21:17.140]  и поэтому здесь можно оценку будет еще на один уточнить.
[01:21:20.140 --> 01:21:28.140]  Для строк вида А и Б повторено, наверное, с один раз, но
[01:21:28.140 --> 01:21:31.140]  нужно вот понять, как выглядит автомат, давайте его нарисую.
[01:21:31.140 --> 01:21:47.140]  Так, и кажется, кажется, он будет выглядеть вот так,
[01:21:47.140 --> 01:21:50.140]  значит это будет сюда вот, а нет.
[01:21:50.140 --> 01:22:15.140]  Ну и здесь ребер, в общем-то, столько же, сколько вершин,
[01:22:15.140 --> 01:22:18.140]  потому что просто один цикл, и здесь ребер на самом деле
[01:22:18.140 --> 01:22:28.140]  будет ровно 2n-1, да, да, ребер 2n-1, что меньше либо равно
[01:22:28.140 --> 01:22:33.140]  чем 3n-4, для тех и начиная с некоторого. Вот, ну и все,
[01:22:33.140 --> 01:22:36.140]  а для всех остальных строчек у них меньше вершин будет
[01:22:36.140 --> 01:22:38.140]  обязательно меньше, чем вот столько, поэтому оценку
[01:22:38.140 --> 01:22:41.140]  можно еще на один уточнить, из-за вот здесь вот, да, у
[01:22:41.140 --> 01:22:44.140]  меня здесь было жестких ребер, не больше, чем вершин.
[01:22:44.140 --> 01:22:48.140]  Если у меня число вершин еще можно точнее, точнее
[01:22:48.140 --> 01:22:51.140]  оценить, то еще будет минус 1 вот здесь вот в оценке,
[01:22:51.140 --> 01:22:53.140]  и будет как раз 3 и минус 4.
[01:22:56.140 --> 01:22:58.140]  Так, questions.
[01:23:05.140 --> 01:23:06.140]  Хорошо.
[01:23:08.140 --> 01:23:11.140]  Ну и осталось, что со симптотикой? Симптотика алгоритма, да,
[01:23:11.140 --> 01:23:13.140]  симптотика алгоритма.
[01:23:14.140 --> 01:23:19.140]  Ну, мы сказали, что почти все линейное, потому что вот,
[01:23:19.140 --> 01:23:26.140]  например, когда мы делали операцию teclon.tu равно tecu.tu,
[01:23:26.140 --> 01:23:30.140]  мы как бы по сути, да, перекопируем всю мапу отсюда-сюда,
[01:23:30.140 --> 01:23:33.140]  но поскольку ребер суммарно на каждом этапе у меня максимум
[01:23:33.140 --> 01:23:36.140]  линейное количество, то когда я вот отсюда перекопирую
[01:23:36.140 --> 01:23:39.140]  ребра сюда, у меня их будет, ну, все еще не более, чем
[01:23:39.140 --> 01:23:42.140]  линейное количество суммарно, значит, но амортизировано,
[01:23:42.140 --> 01:23:45.140]  все такие перекопирования занимают единицу, а суммарно
[01:23:45.140 --> 01:23:49.140]  ребер линейное количество, поэтому это можно считать
[01:23:49.140 --> 01:23:51.140]  работать за амортизированную единицу.
[01:23:51.140 --> 01:23:57.140]  Самое тонкое место, это когда мы перенаправляем ребра.
[01:23:57.140 --> 01:24:01.140]  Значит, у нас в какой-то момент мы перенаправляем все
[01:24:01.140 --> 01:24:07.140]  ребра, ведущие ску, чтобы они теперь вели в клона,
[01:24:07.140 --> 01:24:09.140]  чтобы они теперь вели в клона.
[01:24:10.140 --> 01:24:14.140]  Вот. И это как раз у нас число ребер не меняется,
[01:24:14.140 --> 01:24:16.140]  сколько ребер удалил, столько ребер добавил, поэтому
[01:24:16.140 --> 01:24:20.140]  число ребер не увеличивается, но можно проследить, что
[01:24:20.140 --> 01:24:26.140]  когда я делаю вот это перенаправление, у меня уменьшается
[01:24:26.140 --> 01:24:33.140]  следующий потенциал. Давайте скажем, что потенциал
[01:24:33.140 --> 01:24:50.140]  и это число вершин на пути по совсылкам от максимальной
[01:24:50.140 --> 01:24:51.140]  вершины.
[01:24:55.140 --> 01:24:58.140]  Значит, если раньше у меня была S, да, и какие-то вот
[01:24:58.140 --> 01:25:02.140]  у нее были родители, ну, точнее, путь по совсылкам,
[01:25:02.140 --> 01:25:08.140]  то теперь, когда я пишу СС, изменяю автомат и смотрю
[01:25:08.140 --> 01:25:10.140]  на этот путь по совсылкам, то у меня будет примерно
[01:25:10.140 --> 01:25:14.140]  следующее. Несколько первых вершинок будут иметь ребро
[01:25:14.140 --> 01:25:18.140]  в СС, затем несколько вершинок, начиная с П, будут иметь
[01:25:18.140 --> 01:25:22.140]  ребро в клона, который является совсылкой вершинки СС.
[01:25:22.140 --> 01:25:25.140]  Вот. Ну и так далее оно будет разбиваться вот такими
[01:25:25.140 --> 01:25:27.140]  вершинами, что из них и всех будет ребро в очередную
[01:25:27.140 --> 01:25:30.140]  вершину на вот этом суффиксном пути. И соответственно,
[01:25:30.140 --> 01:25:33.140]  чем больше вершин вот из этого второго слоя я перенаправил,
[01:25:33.140 --> 01:25:38.140]  тем короче у меня будет путь по совсылкам, начиная
[01:25:38.140 --> 01:25:44.140]  от СС, тем короче будет вот этот вот путь. То есть,
[01:25:44.140 --> 01:25:48.140]  чем больше ребер я перенаправил отсюда, ну, точнее, из кув
[01:25:48.140 --> 01:25:50.140]  клона, тем как бы больше у меня вершин вот здесь вот
[01:25:50.140 --> 01:25:53.140]  склеилось в одну, и значит у меня стал этот путь короче.
[01:25:53.140 --> 01:25:55.140]  Путь по совсылкам стал короче. Значит, каждая
[01:25:55.140 --> 01:25:58.140]  итерация вот этого вайла перенаправления ребра уменьшает
[01:25:58.140 --> 01:26:03.140]  длину пути по совсылкам на единицу. Ну и поскольку
[01:26:03.140 --> 01:26:05.140]  он растет на единицу, максимум на единицу за счет добавления
[01:26:05.140 --> 01:26:08.140]  новой вершинки, а убывает каждый раз, когда делает
[01:26:08.140 --> 01:26:11.140]  итерацию цикловайл, значит суммарная итерация цикловайл
[01:26:11.140 --> 01:26:13.140]  вот здесь вот перекопирование будет линейное количество.
[01:26:13.140 --> 01:26:17.140]  Ну все, все остальное это там линейные перекопирования,
[01:26:17.140 --> 01:26:22.140]  которые, понятно, занимает ОАТН. На этом все. Спасибо.
