[00:00.000 --> 00:08.000]  Давайте сделаем вид, как будто мы сначала пропустили, вот мы уже все это написали.
[00:08.000 --> 00:18.000]  Мы продолжаем разговор про эллеровые циклы, эллеровые графы. Напомню, что мы пытаемся в графе
[00:18.000 --> 00:24.000]  найти такой цикл, который идет по всем ребрам этого графа, причем ровно один раз.
[00:24.000 --> 00:29.000]  То есть этот цикл не пропускает ни одного ребра, и плюс по каждому ребру
[00:29.000 --> 00:35.000]  проходит не более одного раза. Мы выписали два критерия эллеровости.
[00:35.000 --> 00:39.000]  Один критерий эллеровости для неориентированных графов,
[00:39.000 --> 00:43.000]  второй критерий полуэллеровости для неориентированных графов.
[00:43.000 --> 00:51.000]  Теперь давайте разберемся с тем же самым, но только для ориентированных графов.
[00:51.000 --> 01:13.000]  Так его один, эллеровость урграфов.
[01:13.000 --> 01:33.000]  Так, давайте слабо связанный урграф G эллеров, тогда и только тогда.
[01:33.000 --> 01:36.000]  Но смотрите, в случае неориентированных графов что у нас было?
[01:36.000 --> 01:40.000]  У нас степень каждой вершины четна. Для чего это нам нужно было?
[01:40.000 --> 01:44.000]  Ну чтобы если мы попали в какую-то вершину, то мы из нее обязательно должны выйти.
[01:44.000 --> 01:47.000]  То есть у нас не бывает такое, что путь где-то прерывается.
[01:47.000 --> 01:51.000]  Но здесь это условие вырождается в следующее.
[01:51.000 --> 02:01.000]  Для любой вершины из множества вершин графа G выполнено следующее.
[02:01.000 --> 02:12.000]  Входящая степень, точнее степень захода вершины V совпадает со степенью ее исхода.
[02:12.000 --> 02:19.000]  Ну и естественно, уже слабо связанный.
[02:19.000 --> 02:28.000]  То есть если у вас есть какая-то вершина, то количество исходящих ребер должно совпадать с количеством входящих.
[02:28.000 --> 02:33.000]  Вот, ну доказывается все аналогично.
[02:33.000 --> 02:44.000]  Аналогично теореме 1.1.
[02:44.000 --> 02:46.000]  Вот.
[02:46.000 --> 02:50.000]  Ну и аналогичная теорема.
[02:50.000 --> 02:57.000]  Аналогичные проблемы.
[02:57.000 --> 03:02.000]  Теорема 2.2.
[03:02.000 --> 03:15.000]  Ну соответственно полуэйлерость.
[03:15.000 --> 03:23.000]  Ну слабо связанный граф G полуэйлеров.
[03:23.000 --> 03:27.000]  Тогда и только тогда, когда...
[03:27.000 --> 03:32.000]  Смотрите, ну в чем отличие эйлерового графа от полуэйлерового графа?
[03:32.000 --> 03:35.000]  В эйлеровом графе есть цикл, который проходит по всем ребрам.
[03:35.000 --> 03:38.000]  Полуэйлеров тоже проходит по всем ребрам, но он не цикл.
[03:38.000 --> 03:43.000]  Вот как из нет цикла сделать цикл?
[03:43.000 --> 03:45.000]  Да, ну просто добавить некоторых ребров.
[03:45.000 --> 03:51.000]  То есть если у вас цикл был ориентирован так, то достаточно добавить всего лишь одно ребро.
[03:51.000 --> 03:55.000]  Точнее, наоборот, да, должно быть вот так.
[03:55.000 --> 03:57.000]  Вот, а теперь, ну смотрите, это граф эйлеров.
[03:57.000 --> 04:01.000]  По критерию эйлеровости у него, у каждой вершины, степень захода равна степени исхода.
[04:01.000 --> 04:05.000]  А теперь давайте уберем это ребро, что у нас получится.
[04:05.000 --> 04:10.000]  У всех вершин степень захода равна степени захода, кроме двух,
[04:10.000 --> 04:15.000]  у которых степень захода на один больше и степень исхода на один больше, ну соответственно.
[04:15.000 --> 04:17.000]  Окей?
[04:17.000 --> 04:44.000]  Так вот, у всех вершин, кроме, может быть, двух, степень захода совпадает степень захода.
[04:44.000 --> 05:00.000]  А у оставшихся, степень захода минус степень исхода равна,
[05:00.000 --> 05:04.000]  на этом напишу, плюс 1 и минус 1.
[05:04.000 --> 05:09.000]  Ну, у одной вершины степень захода больше.
[05:09.000 --> 05:11.000]  Точнее, вот у этой вершины степень захода больше на одну,
[05:11.000 --> 05:21.240]  сходы на одну больше. Вот. Ну в смысле, у одной из них плюс один, у другой из них
[05:21.240 --> 05:26.240]  минус один. Вот. Ну, оказывается, тоже аналогично.
[05:31.240 --> 05:45.240]  Теоремия 2.1. Нет, 1.2. Всё. В общем, данные две теоремы, они дают что нам? Они дают нам
[05:45.240 --> 05:50.240]  некоторые способы, как понять, можно ли на данном графе построить эллировцикл или нет.
[05:50.240 --> 05:54.240]  То есть, что мы делаем в случае неориентированных графов? Просто смотрим на степени всех вершин.
[05:54.240 --> 05:59.240]  То есть, если у нас граф связный, ну может быть, за исключением каких-то изолированных вершин.
[05:59.240 --> 06:03.240]  То есть, понятное дело, что если у вас есть какие-то изолированные вершины, а весь остальной
[06:03.240 --> 06:08.240]  граф связан, то в нём тоже можно построить эллировцикл. То есть, грубо говоря, если у вас есть
[06:08.240 --> 06:12.240]  ровно одна компонента связанности, которая содержит ребра, и тут все степени вершин чётные,
[06:12.240 --> 06:17.240]  то значит, постановка задачи поиска эллирового цикла корректна, и можно запустить какой-то алгоритм.
[06:17.240 --> 06:23.240]  Для ориентиранных графов то же самое. Проверяем на всех вершинах неизолированных, что степень
[06:23.240 --> 06:29.240]  захода равна степени исхода, и если это так, то можем применять на нём поиск эллирового цикла.
[06:29.240 --> 06:37.240]  Ну и давайте наконец разберёмся, как эти самые эллировые циклы искать алгоритм.
[06:38.240 --> 06:44.240]  Да, и заодно как раз докажем, что мы там. Мы не доказали обратное следствие.
[06:44.240 --> 06:48.240]  Помните, мы писали, что в одну сторону понятно, а в другую сторону докажем конструктивно.
[06:48.240 --> 06:54.240]  Ну вот сейчас мы как раз предъявим алгоритм и покажем, что он корректно находит эллирово цикл.
[06:58.240 --> 07:05.240]  Вот алгоритм, как бы странно это ни звучало, тоже будет использовать обход в глубину.
[07:05.240 --> 07:09.240]  То есть мы за рамки обхода в глубину в принципе пока не выходим.
[07:09.240 --> 07:13.240]  Идея такая, давайте возьмём какой-нибудь граф.
[07:26.240 --> 07:33.240]  И запустим на нём обход DFS. В чём проблема? Если мы запустим обычный DFS,
[07:33.240 --> 07:40.240]  то всё будет плохо. Почему? Потому что DFS в каждую вершину заходит ровно один раз.
[07:40.240 --> 07:45.240]  А нас это как бы не очень устраивает, потому что в принципе эллиров цикл может в каждую вершину заходить по несколько раз.
[07:45.240 --> 07:49.240]  Вот например здесь. Мы можем пройтись вот так, потом вот так, потом вот так.
[07:49.240 --> 07:54.240]  Снова зайти в эту вершину и из неё достроить путь.
[07:54.240 --> 07:59.240]  То есть это свойство DFS, что он заходит в каждую вершину ровно один раз, нас не устраивает.
[07:59.240 --> 08:04.240]  Поэтому, давайте сделаем следующую вещь. Давайте забьём на то,
[08:04.240 --> 08:11.240]  что у нас DFS заходит точнее так. Давайте уберём требования на DFS, чтобы он в каждую вершину заходил ровно один раз.
[08:11.240 --> 08:13.240]  А что нас на самом деле интересует?
[08:13.240 --> 08:18.520]  Нас на самом деле интересует обход графа, при котором он ходит каждое ребро ровно один раз.
[08:19.960 --> 08:24.680]  То есть нам не нужно в каждую вершину заходить ровно один раз, нам нужно в каждое ребро заходить ровно один раз.
[08:25.440 --> 08:28.640]  Ну а давайте DFS модифицируем таким образом, что он будет просто следить за
[08:29.720 --> 08:32.080]  непосредственно посещенными ребрами, а не за посещенными вершинами.
[08:34.240 --> 08:36.240]  Вот давайте напишу
[08:37.080 --> 08:40.680]  DFS для поиска error цикла. Значит есть граф g.
[08:42.240 --> 08:44.240]  Есть p.
[08:44.280 --> 08:49.920]  Что такое p, потом объясню. Давайте запускаемся DFS на графе g
[08:50.680 --> 08:52.680]  от вершины v.
[08:53.680 --> 08:55.680]  Что мы делаем?
[08:55.680 --> 08:57.320]  Что мы делаем?
[08:57.320 --> 09:00.440]  Просто проходимся по всем ребрам, точнее по всем соседним вершинам v.
[09:07.000 --> 09:09.440]  То есть по всем ребрам, которые торчат из v.
[09:10.440 --> 09:13.440]  Что мы сделаем? Во-первых, мы скажем следующее.
[09:22.400 --> 09:24.400]  Удалим ребро v.
[09:25.040 --> 09:32.000]  Так как мы по каждому ребру хотим пройтись ровно один раз, то в тот момент, когда мы начинаем проходить по ребру v, мы это ребро удаляем.
[09:32.120 --> 09:34.440]  Ну, от греха, чтобы потом его еще раз не пройти.
[09:36.600 --> 09:38.600]  Удалили.
[09:38.720 --> 09:40.720]  Ну а дальше просто запускаем рекурсивно
[09:43.480 --> 09:47.520]  поиск error цикла на графе g от вершины u.
[09:48.320 --> 09:51.760]  И здесь пишем вершину v. Вот эта вершина p, это что? Это
[09:55.200 --> 09:57.520]  родитель, ну или предок
[10:00.200 --> 10:01.520]  DFS.
[10:01.520 --> 10:05.960]  То есть это та вершина, из которой мы вызвали DFS от этой вершины.
[10:06.960 --> 10:12.360]  То есть мы вызвали DFS для вершины u, находясь в обходе для вершины v.
[10:14.800 --> 10:17.960]  И DFS для вершины v мы вызывались находясь в вершине p.
[10:23.480 --> 10:26.240]  Ну, по сути все, дальше в конце просто делаем следующую вещь.
[10:32.200 --> 10:34.200]  Push front
[10:36.800 --> 10:39.800]  ребро v. Нет, ребро pv.
[10:44.400 --> 10:51.520]  P это родитель вершины v. То есть мы как-то с помощью нашего DFS гуляли, попали в вершину v. И вот в вершину v мы попали находясь из вершины p.
[10:54.120 --> 11:01.000]  Точнее, в вершину v мы пришли по ребру pv. Вот так. Ну, то есть можно сказать, что pv это то ребро, по которому мы попали в вершину v.
[11:05.960 --> 11:07.960]  Вот.
[11:11.680 --> 11:16.640]  По большому счету все. То есть LRPAF, естественно, это изначально
[11:19.120 --> 11:21.040]  пустой массив.
[11:21.040 --> 11:25.400]  Пустой массив, а потом в начало просто добавляем ребра. Вот весь алгоритм.
[11:26.600 --> 11:29.160]  Чуть-чуть модифицировали DFS. Понятно?
[11:29.160 --> 11:31.160]  Асимптотика. Ну, с асимптотикой...
[11:32.880 --> 11:36.720]  Ну, это на самом деле не интересно. То есть тут нельзя просто сказать, что асимптотика это просто
[11:37.480 --> 11:43.840]  асимптотика DFS, потому что мы тут немного поменяли алгоритмы. Но в целом понятно, что по каждому ребру мы проходим все ровно один раз, поэтому от E.
[11:44.840 --> 11:46.840]  Да?
[11:47.840 --> 11:49.840]  Вот.
[11:49.840 --> 11:51.840]  Вот E.
[11:51.840 --> 11:53.840]  Ну, еще плюс V. Ну, давайте скажем, что
[11:54.200 --> 11:56.200]  V это чтобы найти
[11:59.560 --> 12:01.560]  компоненту связности,
[12:02.600 --> 12:04.600]  содержащую
[12:04.600 --> 12:06.600]  ребро.
[12:06.600 --> 12:12.840]  Ну, что имеется ввиду? Вот ту картинку, которую я рисовал, да, вот, допустим, у вас есть какая-то компонент связности, вот, есть изолированные вершины.
[12:12.840 --> 12:18.560]  То есть нельзя просто взять из произвольной вершины и запустить поезд LRW цикла. То есть вы обязательно должны стартовать вот этот
[12:18.680 --> 12:32.000]  компонент связности. Ну, чтобы этот компонент связности найти, нужно потратить там V шагов. Ну, поэтому
[12:33.560 --> 12:35.560]  такая асимптотика.
[12:37.820 --> 12:43.780]  Давайте попробуем применить алгоритм, чтобы понять, как он работает.
[12:49.560 --> 12:54.280]  Ну, 1, 2, 3, 4.
[12:55.480 --> 13:02.280]  Ну, из какой вершины запустимся? Так, давайте сделаем граф неориентированным. Хотя этот алгоритм работает и для ориентированных, и для неориентированных графов.
[13:08.280 --> 13:11.840]  Важно. Давайте запустимся от вершины 1.
[13:12.600 --> 13:20.480]  Запускаемся от вершины 1. Ну, давайте, я тут порядок вызова DFS буду писать. Из вершины 1, допустим, идем в вершину 4.
[13:22.040 --> 13:25.960]  Дальше. Удаляем ребро. Как только мы прошли по ребру, мы его удаляем.
[13:27.000 --> 13:30.920]  Дальше. Из вершины 4, мы проходим, допустим, вершину, давайте, 3.
[13:32.000 --> 13:35.280]  4, 3. Из вершины 3 проходим вершину 2.
[13:36.760 --> 13:38.760]  Из вершины 2 проходим вершину 4.
[13:42.600 --> 13:50.640]  Здесь не очень получилось. Ну ладно, из вершины 4 проходим вершину 0. Из вершины 0 проходим вершину 1.
[13:52.880 --> 13:57.600]  Все, из вершины 1 никуда нельзя попасть, поэтому мы начинаем выписывать ответ.
[13:59.400 --> 14:01.400]  Выписываем 0, 1.
[14:01.400 --> 14:05.440]  Дальше откатываемся в вершину 0, из него нельзя никуда пройти, поэтому пишем
[14:06.000 --> 14:10.600]  4, 0. Ну и так далее. То есть мы как раз в этом порядке и выпишем.
[14:11.280 --> 14:17.280]  2, 4. 3, 2. 4, 3. 1, 4.
[14:22.000 --> 14:24.000]  Что?
[14:25.600 --> 14:28.960]  Во, да, давайте такой вариант разберем. Вот мне как раз такой вариант и нужен был.
[14:30.280 --> 14:38.080]  Ну в таком варианте все понятно, да? Ну как бы мы прошлись как раз по эрилу циклу. Давайте теперь действительно разберем плохую ситуацию, когда мы
[14:41.520 --> 14:47.280]  пошли не совсем по эллеровому циклу. То есть стартовались единицы.
[14:48.720 --> 14:54.880]  Стартовались единицы. Дальше прошли в четверку, а из четверки прошли в ноль.
[14:59.520 --> 15:01.520]  Из нуля прошли в единицу.
[15:04.640 --> 15:06.640]  Из единицы идти некуда.
[15:06.800 --> 15:09.280]  Все, выписываем ответ. Точнее, выписываем
[15:09.760 --> 15:12.640]  ребро 0, 1. Потому что в единицу мы пришли через ноль.
[15:14.120 --> 15:20.200]  Откатываемся в ноль. Из нуля снова нельзя никуда пойти, поэтому пишем 4, 0. Так, я тут...
[15:30.880 --> 15:32.880]  Так, выписали 0, 1 и 4, 0.
[15:33.040 --> 15:38.480]  Из нуля вышли, возвращаемся в четверку. Вот, а из четверки можем пройти куда хотите? В двойку, в тройку.
[15:41.000 --> 15:45.880]  Вот, из четверки проходим в двойку. Из двойки проходим в тройку.
[15:49.040 --> 15:51.040]  Из тройки в четверку.
[15:51.360 --> 15:53.360]  Все, из четверки идти некуда.
[15:54.640 --> 15:59.600]  Из четверки идти некуда, поэтому завершаем одни работы и выписываем ребро 3, 4.
[16:00.600 --> 16:04.440]  Из тройки идти некуда, выписываем ребро 2, 3.
[16:06.680 --> 16:08.680]  Ребро 4, 2 и 1, 4.
[16:12.480 --> 16:14.480]  Ну вот, в порядке завершение.
[16:15.920 --> 16:22.960]  Давайте проверять. 1, 4, 4, 2, 2, 3, 3, 4, 4, 0, 0, 1. Корректный эйвер в циклу.
[16:22.960 --> 16:28.080]  Ну, естественно, вы мне на слово не поверите, что он работает всегда, поэтому давайте попробуем доказать, что
[16:29.080 --> 16:31.080]  опять же, этот результат получился не случайно.
[16:32.080 --> 16:36.080]  Доказательства проведем в три этапа.
[16:37.080 --> 16:39.080]  Утверждение 1.
[16:41.080 --> 16:43.080]  Алгоритм.
[16:43.200 --> 16:45.200]  Утверждение 1.
[16:47.200 --> 16:49.200]  Алгоритм.
[16:54.200 --> 16:56.200]  Проходит
[16:57.200 --> 16:59.200]  по всем ребрам
[17:01.200 --> 17:03.200]  ровно один раз.
[17:07.200 --> 17:11.200]  Ну это утверждение, я думаю, понятно, да? У нас все вершины достижимы.
[17:11.320 --> 17:15.320]  И плюс при обходе каждой вершины мы проходимся по всем ее соседям.
[17:16.320 --> 17:18.320]  Давайте без перерыва сегодня, окей?
[17:18.320 --> 17:20.320]  Вот.
[17:21.320 --> 17:23.320]  Доказательства.
[17:23.320 --> 17:25.320]  Все
[17:25.320 --> 17:27.320]  вершины
[17:27.320 --> 17:29.320]  достижимы.
[17:32.320 --> 17:34.320]  И у каждой
[17:38.320 --> 17:40.320]  просматриваем
[17:41.320 --> 17:43.320]  все инцидентные
[17:49.320 --> 17:51.320]  ребра
[17:52.320 --> 17:54.320]  по одному разу.
[17:55.320 --> 17:57.320]  Ну почему по одному разу? Потому что как только мы прошлись по ребру, мы его тут же удаляем.
[17:58.320 --> 18:00.320]  Следовательно, в следующий раз мы больше никогда по этому ребру не пройдемся.
[18:06.320 --> 18:08.320]  Так, это утверждение понятно.
[18:08.320 --> 18:10.320]  Дальше, более содержательное утверждение.
[18:11.320 --> 18:13.320]  Заключается в следующем.
[18:15.320 --> 18:17.320]  В момент
[18:19.320 --> 18:21.320]  добавления
[18:23.320 --> 18:25.320]  ребра в ответ
[18:29.320 --> 18:31.320]  степени всех вершин
[18:33.320 --> 18:35.320]  всех
[18:36.320 --> 18:38.320]  вершин
[18:38.320 --> 18:40.320]  четны.
[18:40.440 --> 18:42.440]  В случае ориентированных графов в степени всех вершин
[18:43.440 --> 18:45.440]  есть баланс.
[18:45.440 --> 18:47.440]  Давайте для случая ориентированного графа я буду обсуждать.
[18:47.440 --> 18:49.440]  Для ориентированного все аналогично, естественно.
[18:50.440 --> 18:52.440]  Степени всех вершин четны.
[18:52.440 --> 18:54.440]  То есть, что имеется в виду?
[18:54.440 --> 18:56.440]  Вот в этой строке
[18:58.440 --> 19:00.440]  степени всех вершин снова четны.
[19:00.440 --> 19:02.440]  То есть, я запускаю
[19:02.440 --> 19:04.440]  алгоритм, у меня у всех вершин степени
[19:04.440 --> 19:06.440]  четны по теореме.
[19:06.560 --> 19:08.560]  Понятное дело, что в процессе работы
[19:08.560 --> 19:10.560]  у меня степень каких-то вершин
[19:10.560 --> 19:12.560]  могут становиться нечетными.
[19:12.560 --> 19:14.560]  Хотя бы в самый первый момент времени,
[19:14.560 --> 19:16.560]  когда я просто беру
[19:16.560 --> 19:18.560]  и прохожусь по первому ребру.
[19:18.560 --> 19:20.560]  В этот момент я у стартовой вершины
[19:20.560 --> 19:22.560]  и у этой вершины отнял по одной степени.
[19:22.560 --> 19:24.560]  Поэтому в этот момент их степень нечетный.
[19:24.560 --> 19:26.560]  Но вот утверждается, что как только я дошел
[19:26.560 --> 19:28.560]  до этой строки, вот до последней,
[19:28.560 --> 19:30.560]  все степени вершин снова четные.
[19:30.560 --> 19:32.560]  Доказательство будет картинкой.
[19:32.560 --> 19:34.560]  Вы не против?
[19:34.560 --> 19:36.560]  Ну, смотрите, вот мы берем
[19:36.560 --> 19:38.560]  какую-то вершину v
[19:38.560 --> 19:40.560]  и запускаем поиск
[19:40.560 --> 19:42.560]  скейлерового цикла из нее.
[19:42.560 --> 19:44.560]  Что мы делаем?
[19:44.560 --> 19:46.560]  Мы как-то идем, идем, заходим
[19:46.560 --> 19:48.560]  повторно в какие-то вершины,
[19:48.560 --> 19:50.560]  вот так.
[19:50.560 --> 19:52.560]  То есть, в принципе, мы не запрещаем
[19:52.560 --> 19:54.560]  себе заходить в некоторые вершины
[19:54.560 --> 19:56.560]  по несколько раз.
[19:56.560 --> 19:58.560]  И вот, допустим, мы будем
[19:58.560 --> 20:00.560]  и вот, допустим, мы закончили
[20:00.560 --> 20:02.560]  обход DFS в какой-то вершине u.
[20:04.560 --> 20:06.560]  То есть,
[20:06.560 --> 20:08.560]  пусть
[20:08.560 --> 20:10.560]  мы закончили
[20:12.560 --> 20:14.560]  в вершине
[20:16.560 --> 20:18.560]  u, при этом
[20:18.560 --> 20:20.560]  не совпадающей с v.
[20:20.560 --> 20:22.560]  Что можно сказать про степень вершин?
[20:22.560 --> 20:24.560]  Ну, понятно, что у всех
[20:24.560 --> 20:26.560]  промежуточных вершин, вот здесь,
[20:26.560 --> 20:28.560]  на этом пути, у них все
[20:28.560 --> 20:30.560]  все степени четные.
[20:30.560 --> 20:32.560]  Почему? Потому что мы в нее вошли и вышли,
[20:32.560 --> 20:34.560]  вошли и вышли.
[20:34.560 --> 20:36.560]  В вершины здесь.
[20:36.560 --> 20:38.560]  Мы в нее один раз вошли, один раз вышли.
[20:38.560 --> 20:40.560]  Вот эта вершина. Мы в нее два раза зашли
[20:40.560 --> 20:42.560]  и два раза вышли.
[20:42.560 --> 20:44.560]  Путь так просто на пусту устроен.
[20:44.560 --> 20:46.560]  А есть ли здесь вершины, у которых
[20:46.560 --> 20:48.560]  степень нечетная?
[20:48.560 --> 20:50.560]  u и v.
[20:50.560 --> 20:52.560]  u и v, да.
[20:52.560 --> 20:54.560]  Меня на самом деле больше интересует вершина u.
[20:54.560 --> 20:56.560]  Могло ли получиться так,
[20:56.560 --> 20:58.560]  что я вошел
[20:58.560 --> 21:00.560]  в вершину u, а выйти из нее не могу?
[21:02.560 --> 21:04.560]  Цикл.
[21:04.560 --> 21:06.560]  Почему?
[21:06.560 --> 21:08.560]  Да, понятно.
[21:08.560 --> 21:10.560]  Изначально в моем графе все вершины четные.
[21:10.560 --> 21:12.560]  Точнее, все степени вершин четные.
[21:12.560 --> 21:14.560]  Поэтому, если я в какую-то вершину попал,
[21:14.560 --> 21:16.560]  то я из нее обязательно могу выйти.
[21:16.560 --> 21:18.560]  То есть, если я закончил в вершине u,
[21:18.560 --> 21:20.560]  которая не совпадает v,
[21:20.560 --> 21:22.560]  то это значит,
[21:26.560 --> 21:28.560]  что
[21:28.560 --> 21:30.560]  это значит,
[21:32.560 --> 21:34.560]  что
[21:34.560 --> 21:36.560]  ее степень
[21:40.560 --> 21:42.560]  нечетна.
[21:42.560 --> 21:44.560]  То есть, если я в нее попал,
[21:44.560 --> 21:46.560]  то если я в нее попал
[21:46.560 --> 21:48.560]  и из нее не вышел,
[21:48.560 --> 21:50.560]  то я отобрал у нее одно ребро.
[21:50.560 --> 21:52.560]  То есть,
[21:52.560 --> 21:54.560]  если у нее изначально была степень
[21:54.560 --> 21:56.560]  четная, то я отобрал у нее одно ребро,
[21:56.560 --> 21:58.560]  соответственно, у нее стала степень
[21:58.560 --> 22:00.560]  нечетная. А если у нее степень нечетная,
[22:00.560 --> 22:02.560]  то что это значит?
[22:02.560 --> 22:04.560]  То есть, у нее есть хотя бы одно ребро,
[22:04.560 --> 22:06.560]  которое мы еще не посетили.
[22:06.560 --> 22:08.560]  Понятно это?
[22:08.560 --> 22:10.560]  Это значит,
[22:10.560 --> 22:12.560]  что степень нечетна,
[22:12.560 --> 22:28.560]  Есть непосещенное ребро, исходящее из У.
[22:28.560 --> 22:31.560]  Ну, противоречие. Согласны?
[22:31.560 --> 22:45.560]  Вот мы и предположили. Пусть закончили вершине У, которое не совпадает с В.
[22:45.560 --> 22:50.560]  Вот я просто показываю, что такого быть в принципе не может.
[22:50.560 --> 23:09.560]  Значит, У равно В. Если я где-то и закончил, то только в стартовой вершине.
[23:09.560 --> 23:36.560]  У из этого, собственно, следует в момент завершения степени всех вершин черный.
[23:36.560 --> 23:44.560]  Вот, то есть я запустил мой обход из вершины В, как-то походил-походил, и завершился в В.
[23:44.560 --> 23:49.560]  Выписал какое-то ребро. Дальше с помощью DFS откатился в какую-то вершину вот эту.
[23:49.560 --> 23:52.560]  Снова из нее как-то походил-походил, и снова в нее вернулся.
[23:52.560 --> 23:55.560]  Снова все степени вершин черные и так далее.
[23:55.560 --> 23:59.560]  То есть в момент добавления каждого ребра у меня степени всех вершин оставались черными.
[23:59.560 --> 24:04.560]  Вот и все. Понятно?
[24:04.560 --> 24:10.560]  Какие вопросы есть? Все окей?
[24:10.560 --> 24:13.560]  Что значит в момент завершения?
[24:13.560 --> 24:20.560]  В момент завершения давайте обозначим. В момент завершения, в смысле в момент завершения вызова.
[24:20.560 --> 24:23.560]  Давайте вот эту строчку обозначим звездочкой.
[24:23.560 --> 24:34.560]  В момент завершения, то есть в момент звездочка в степени всех вершин черные.
[24:34.560 --> 24:46.560]  То есть что это означает? Если вам больше некуда идти, то значит вы вернулись в начало.
[24:46.560 --> 24:58.560]  Еще вопросы? Хорошо.
[24:58.560 --> 25:00.560]  Ну и последнее утверждение.
[25:00.560 --> 25:19.560]  Выписанные ребра образуют корректный путь.
[25:19.560 --> 25:31.560]  Что это значит? Это значит, что если мы посмотрим на массив в любое время, то у вас будет следующая картина.
[25:31.560 --> 25:46.560]  Здесь v, здесь p от v, здесь снова p от v, здесь p от p от v.
[25:46.560 --> 26:02.560]  Последовательно выписанные вершины совпадают конечная. У того ребра, который стоит слева, конечная вершина совпадает с начальной вершиной следующего ребра.
[26:02.560 --> 26:11.560]  Понятно, что это значит, что у нас путь корректный.
[26:11.560 --> 26:31.560]  Пусть выписали ребро p, v и v.
[26:31.560 --> 26:41.560]  Что это значит? Это значит, что мы закончили обработку вершины v и откатываемся по рекурсии dfs обратно.
[26:41.560 --> 26:52.560]  А куда мы откатываемся? В p от v, да? Потому что p от v по определению родитель вершины v.
[26:52.560 --> 27:13.560]  Откатываемся, ну или продолжаем запуск dfs от p от v.
[27:13.560 --> 27:29.560]  А что мы знаем о запуске dfs от p от v? Вот в этот момент что я знаю? В этот момент все вершины, все степени всех вершин четные, да?
[27:29.560 --> 27:44.560]  По утверждению 2, степени всех вершин четные.
[27:44.560 --> 28:04.560]  А из этого что следует? Вот смотрите, я как-то походил-походил, закончил искать путь для вершины v и откатился в вершину p от v.
[28:04.560 --> 28:11.560]  И в этот момент у меня в графе все вершины четные. Но согласитесь, что из p от v я куда-то пройдусь, да?
[28:11.560 --> 28:17.560]  Ну, либо никуда не пройдусь. Ну давайте рассмотрим случай, когда я куда-то все-таки пройду. То есть из p от v есть какой-то путь.
[28:17.560 --> 28:24.560]  Ну что тогда? Тогда по утверждению 2 я и закончу в вершине p от v.
[28:24.560 --> 28:33.560]  То есть если я начал снова искать путь из вершины p от v, то и закончу я в этой же вершине p от v.
[28:33.560 --> 28:59.560]  Следовательно, этот вызов завершится в вершине p от v.
[28:59.560 --> 29:04.560]  А если этот вызов завершится в вершине p от v, то что это значит?
[29:04.560 --> 29:14.560]  Да, то это значит, что как раз таки следующим ребром я выпишу ребро, которое будет заканчиваться в вершине p от v.
[29:14.560 --> 29:33.560]  А в следующем будет выписано ребро p от p от v в.
[29:33.560 --> 29:42.560]  Мне кажется, все. Ну то есть еще раз. В чем смысл данного утверждения?
[29:42.560 --> 29:49.560]  Я запустил dfs от v, как-то гулял-гулял-гулял, и в ней же закончил. Это следует из утверждения 2.
[29:49.560 --> 29:56.560]  Я в ней закончил. То есть когда я в ней закончил, я выписал ребро p от v.
[29:56.560 --> 30:02.560]  Если я закончил с вершины v, то я должен откатиться в ее родителя. То есть я откатываюсь в родители p от v.
[30:02.560 --> 30:06.560]  В этот момент для p от v я начинаю искать новое ребро, куда бы мне еще пройтись.
[30:06.560 --> 30:13.560]  Если я не нашел никакого ребра, который торчит из p от v, то я просто его сразу выписываю. То есть все верно.
[30:13.560 --> 30:19.560]  Просто выписываю ребро p от v, и тогда у меня конец этого ребра совпадает с началом предыдущего.
[30:19.560 --> 30:25.560]  А если мне есть куда идти, то я из него выхожу и начинаю искать какой-то еще маленький цикл.
[30:25.560 --> 30:28.560]  Ну и по утверждению 2 я обязательно закончу в той же вершине p от v.
[30:28.560 --> 30:33.560]  Но раз я в ней закончу, то соответственно я как раз выпишу ребро, которое заканчивается вот в вершине p от v.
[30:41.560 --> 30:45.560]  Ну и там теорема, корректность,
[30:52.560 --> 30:54.560]  алгоритм,
[30:55.560 --> 30:57.560]  корректно
[30:58.560 --> 31:00.560]  находит
[31:02.560 --> 31:04.560]  феверов
[31:04.560 --> 31:06.560]  цикл.
[31:08.560 --> 31:14.560]  Ну это просто-напросто следует из утверждения 1, 2 и 3.
[31:16.560 --> 31:21.560]  Ну почему это следует из утверждения 1, 2 и 3? Ну на самом деле следует из утверждения 1 и 2.
[31:21.560 --> 31:26.560]  Что там говорит утверждение 1? В утверждении 1 говорит, что все ребра будут выписаны.
[31:26.560 --> 31:31.560]  Ну помните, да? Все ребра будут подсяжены, вследствие всех ребра будут выписаны.
[31:31.560 --> 31:36.560]  А утверждение 3 говорит, что те ребра, которые я выписал, они будут образовывать корректный путь.
[31:36.560 --> 31:39.560]  Ну все, если у меня есть все ребра и они образуют корректный путь,
[31:39.560 --> 31:42.560]  ну следовательно, Элер в цикл найден.
[31:45.560 --> 31:47.560]  Все.
[31:51.560 --> 31:56.560]  Вопросы?
[31:56.560 --> 32:02.560]  Что осталось непонятное?
[32:02.560 --> 32:07.560]  Для доказательств утверждения 3.
[32:07.560 --> 32:13.560]  Всё, можем идти дальше?
[32:13.560 --> 32:18.560]  Отлично. Ну хорошо, с эйлеровым циклом закончили.
[32:19.560 --> 32:24.560]  Давайте в качестве упражнения оставлю.
[32:24.560 --> 32:29.560]  Есть такое понятие, как гамелитонов цикл.
[32:33.560 --> 32:38.560]  Ну, это как эйлеров цикл, только он проходит по каждой вершине ровно один раз.
[32:48.560 --> 32:53.560]  Ну и упражнения придумать алгоритм.
[33:00.560 --> 33:05.560]  Нет, нет, только гамельдонов. Эйлеров отдельно.
[33:05.560 --> 33:10.560]  Всё, давайте к следующей теме перейдём.
[33:10.560 --> 33:15.560]  Следующая тема у нас
[33:15.560 --> 33:20.560]  точки сочленения.
[33:20.560 --> 33:25.560]  А следующая тема у нас
[33:25.560 --> 33:30.560]  точки сочленения.
[33:30.560 --> 33:35.560]  Точки сочленения.
[33:52.560 --> 33:57.560]  Что такое точки сочленения?
[33:57.560 --> 34:02.560]  Точки сочленения это в некотором смысле такие слабые места в графе.
[34:02.560 --> 34:07.560]  Точка сочленения такая вершина графа, удаление которой приводит к разваливанию графа на несколько кусков.
[34:07.560 --> 34:12.560]  Грубо говоря, при удалении точки сочленения у вас теряется связанность какой-то из компонентов.
[34:12.560 --> 34:17.560]  Давайте определение.
[34:17.560 --> 34:22.560]  Эта вершина
[34:27.560 --> 34:32.560]  удаление которой
[34:32.560 --> 34:37.560]  приводит
[34:37.560 --> 34:42.560]  к увеличению
[34:42.560 --> 34:47.560]  компонент связанности.
[34:47.560 --> 34:52.560]  Ребра не могут идти
[34:52.560 --> 34:57.560]  никуда.
[34:57.560 --> 35:02.560]  Поэтому удаляется вершина и все инцидентные ей ребра.
[35:02.560 --> 35:07.560]  Пример какой?
[35:07.560 --> 35:12.560]  Тот же самый граф.
[35:12.560 --> 35:17.560]  Вот эта точка сочленения.
[35:17.560 --> 35:22.560]  Если я удаляю эту вершину, то у меня граф компонент связанности разваливается на две.
[35:22.560 --> 35:27.560]  Вот это является точкой сочленения?
[35:27.560 --> 35:32.560]  Нет, это не точка сочленения, потому что я ее удаляю и число компонентов связанности у меня никак не меняется.
[35:32.560 --> 35:37.560]  Нет.
[35:37.560 --> 35:42.560]  Вот такая ситуация.
[35:42.560 --> 35:47.560]  Вот это является точкой сочленения?
[35:47.560 --> 35:52.560]  У меня есть граф и изолированная вершина.
[35:52.560 --> 35:57.560]  Нет, число компонентов связанности у меня уменьшилось, а должно было увеличиться.
[35:57.560 --> 36:02.560]  Это не точка сочленения тоже.
[36:02.560 --> 36:07.560]  Отлично.
[36:07.560 --> 36:12.560]  Ну и как вы понимаете, задача состоит в том, чтобы посмотреть на граф
[36:12.560 --> 36:17.560]  и найти в нем точку сочленения, то есть найти все эти слабые вершины.
[36:17.560 --> 36:22.560]  У вас есть какая-то глобальная компьютерная сеть, вам нужно найти сервера или пункты, узлы,
[36:22.560 --> 36:27.560]  уничтожение которых приведет к раку, к коллапсу.
[36:27.560 --> 36:32.560]  Вот такие места, которые нужно усилить.
[36:32.560 --> 36:37.560]  Так, давайте разбираться.
[36:37.560 --> 36:42.560]  Давайте теорему сразу напишем.
[36:42.560 --> 36:47.560]  Теорема, которая позволит искать точки сочленения в графе.
[36:47.560 --> 36:52.560]  Пусть...
[36:52.560 --> 36:57.560]  Важный момент.
[36:57.560 --> 37:02.560]  Это я, конечно, плох.
[37:02.560 --> 37:07.560]  Вершина удаления, которая к увлечению компонентов связанности.
[37:07.560 --> 37:12.560]  Точки сочленения имеют смысл только для неориентированных графов.
[37:12.560 --> 37:17.560]  В случае ориентированных графов, точки сочленения не играют никакой роли.
[37:17.560 --> 37:22.560]  Пусть...
[37:22.560 --> 37:27.560]  Неориентированный граф.
[37:27.560 --> 37:32.560]  Говорить про точки сочленения в контексте ориентированных графов не имеет смысла.
[37:32.560 --> 37:37.560]  Поэтому зафиксировали, граф у нас неориентированный.
[37:37.560 --> 37:42.560]  Пусть запустили DFS.
[37:42.560 --> 37:47.560]  Вот.
[37:47.560 --> 37:52.560]  Со стартовой вершиной.
[38:00.560 --> 38:03.560]  Р. Ну корень.
[38:03.560 --> 38:08.560]  То есть взяли граф, выбрали какую-то вершину, запустили от нее DFS.
[38:08.560 --> 38:13.560]  Вот утверждается следующее. В теореме два пункта.
[38:13.560 --> 38:18.560]  Первый пункт такой.
[38:18.560 --> 38:23.560]  Вершина U равная R.
[38:23.560 --> 38:28.560]  Точка сочленения тогда и только тогда.
[38:28.560 --> 38:33.560]  Вот как вы думаете, когда?
[38:33.560 --> 38:38.560]  Какой-то граф.
[38:38.560 --> 38:43.560]  Я запустил от него DFS. От вершины R.
[38:43.560 --> 38:48.560]  Как-то обошел одну часть, обошел вторую часть, еще что-то обошел.
[38:48.560 --> 38:53.560]  Вот в каком случае R будет являться точкой сочленения?
[38:53.560 --> 38:58.560]  Ну не совсем.
[38:58.560 --> 39:03.560]  Ну точнее так, если из вершины R мы нашли более одной белой вершины.
[39:03.560 --> 39:08.560]  То есть понятно почему так.
[39:08.560 --> 39:13.560]  Вот смотрите, мы запустили DFS от R и обошли какую-то компоненту здесь.
[39:13.560 --> 39:18.560]  Вот нашли какую-то белую вершину, обошли здесь.
[39:19.560 --> 39:24.560]  Потом, вернулись в эту же вершину и из нее нашли другую компоненту.
[39:24.560 --> 39:29.560]  А потом еще одну.
[39:29.560 --> 39:34.560]  Что это означает? Это значит, что из этой компоненты я не смог попасть в эту компоненту.
[39:34.560 --> 39:39.560]  И из этой же компоненты я не смог попасть в эту компоненту.
[39:39.560 --> 39:44.560]  Единственное, что связывает вот эту компоненту с остальными, это вершина R.
[39:44.560 --> 39:51.360]  увеличению числа компонент связанности. Согласны? Вот поэтому вершина, то есть корень обхода DFS
[39:51.360 --> 40:04.360]  является точкой сочинения тогда и только тогда, когда у r более одного сына
[40:04.360 --> 40:12.360]  в дереве обходы в глубину.
[40:14.560 --> 40:44.360]  Так, ну давайте сначала с чем докажем достаточность. Ну вот есть вершина r и вот у нее более одного сына. Что? Что еще раз? Да, потом. Сначала давайте сразу пункты и сразу доказательства, потом второй пункт.
[40:44.360 --> 40:54.160]  Ну, собственно, я уже все проговорил, да? Если более одного сына, то вот 1, 2 и так далее k.
[40:54.160 --> 41:19.960]  Но из этого следует из, из под дерева 1 не можем добраться в 2, 3 и так далее k.
[41:19.960 --> 41:45.760]  Из этого следует, что r единственная вершина, которая их связывает. Все.
[41:45.760 --> 42:04.760]  Ну и наоборот. Вот если r это точка сочинения, то что можно сказать? Ну, допустим, давайте так. Допустим, у r один сын.
[42:04.760 --> 42:33.760]  Ну, то есть r образует только одно под дерево. Ну, точнее, картинка должна быть такой. Есть r, есть один сын, из которого торчит дерево.
[42:33.760 --> 42:54.760]  Ну чего? Ну, тогда r не точка сочинения. Ну вот отсюда следует. Да? Вот я взял вершину r, запустил из нее DFS.
[42:54.760 --> 43:02.760]  Соответственно, я нашел всю компоненту связанности, в которой лежит r. Ну, тогда граф у меня выглядит следующим образом.
[43:02.760 --> 43:11.760]  Из r я могу добраться в какую-то вершину. Ну, хорошо, возможно, еще есть такие перебра.
[43:11.760 --> 43:21.760]  Ну так или иначе, удаление r вообще ни на что не влияет. У меня как было вот это дерево, точнее под дерево, так оно и останется связанным.
[43:21.760 --> 43:35.760]  Вот все. Противоречисла человек.
[43:35.760 --> 43:53.760]  А, да, кстати, ну вообще можно понять так. Допустим, мы попали сначала в вершину 1. Вот. Если мы могли из вершины 1 по какому-то другому ребро добраться до вершины 2, точнее, до под дерева 2,
[43:53.760 --> 44:09.760]  ну тогда мы бы его тоже обошли. Просто по лемме о белых путях. Вот. Но можно сказать все умнее. То есть мы вроде говорили, что на семинарах мы обсудим следующую вещь, что в неорграфах
[44:09.760 --> 44:27.760]  нет прямых и перекрестных ребер.
[44:27.760 --> 44:37.760]  Следовательно, если вы построите дерево обхода DFS для неориентированного графа, то у вас ребра могут идти только вот так.
[44:37.760 --> 44:47.760]  Но при этом между компонентами ребер быть не может. То есть перекрестных ребер быть не может для неориентированных графов.
[44:47.760 --> 45:06.760]  Второй пункт. Ну, что? Вершина U не равна R. Точка сочленения тогда и только тогда.
[45:06.760 --> 45:31.760]  Тогда что? Когда U существует потомок V, даже не потомок, а давайте сын напишем.
[45:31.760 --> 45:59.760]  Ну, сын в смысле обхода в глубину, естественно. Существует сын V такой, что из V нельзя попасть в предка U,
[45:59.760 --> 46:27.760]  двигаясь только по ребрам дерева и обратно.
[46:27.760 --> 46:45.760]  Ну, что это значит? Давайте в одну сторону. Давайте смысл второй части поясню. Вот у вас есть вершина U, и у нее есть сын V.
[46:45.760 --> 46:51.760]  Не смущайте, что я пишу стрелки. Я считаю, что у меня граф по-прежнему не ориентирован.
[46:51.760 --> 46:59.760]  Просто я пишу стрелки сверху вниз, я рисую ребра дерева, а снизу вверх это обратные ребра.
[46:59.760 --> 47:06.760]  Ну и, соответственно, у U есть какой-то предок. Там есть какое-то поддерево, которое ведет в U.
[47:06.760 --> 47:12.760]  Ну, смотрите, если я из V, то есть что у меня есть V? Из V у меня торчит какой-то свой подграф.
[47:12.760 --> 47:23.760]  Представьте, что из V, из этой вообще компоненты, я вообще никак не могу подняться выше U.
[47:23.760 --> 47:29.760]  У меня есть вершина U, есть поддерево, которое торчит из ее сына V.
[47:29.760 --> 47:36.760]  Представьте, что отсюда я вообще никак не могу подняться на высоту ни в какого предка вершина U.
[47:36.760 --> 47:40.760]  Загласны ли вы, что тогда у меня U является точкой сочленения?
[47:40.760 --> 47:45.760]  Вот такие ребра у меня могут быть, а вот таких быть не может.
[47:45.760 --> 47:50.760]  Тогда понятно, что если я удалю вершину U, то тогда у меня вот этот компонент отвалится.
[47:50.760 --> 47:55.760]  Вот, собственно, второй пункт как раз об этом.
[47:55.760 --> 48:24.760]  Пусть U точка сочленения. Пусть для любого сына V, из любого сына V можно попасть в предка U.
[48:24.760 --> 48:37.760]  Что это значит? Вот есть вершина U, и у нее есть куча детей.
[48:37.760 --> 48:47.760]  Из каждого из них можно попасть в какую-то компоненту.
[48:47.760 --> 49:03.760]  Тогда что получается? Получаются у меня предки вершины U связаны со всеми потомками вершины U.
[49:03.760 --> 49:10.760]  Значит, U не является точкой сочленения, потому что U связывает предков и своих детей.
[49:10.760 --> 49:14.760]  Если я удаляю вершину U, то дети и предки остаются связаны.
[49:14.760 --> 49:22.760]  Ну все, U тогда не является точкой сочленения, у меня ничего не разваливается.
[49:22.760 --> 49:29.760]  У меня нет точек сочленения.
[49:29.760 --> 49:38.760]  Ну или вот эта картинка. Если у меня есть хотя бы одно ребро, то удаление вершины U ни к чему плохому мне не приводит.
[49:38.760 --> 49:41.760]  У меня есть предки, у меня есть мой сын.
[49:41.760 --> 49:48.760]  Поэтому предки и сын связаны, а больше ничего другого U не связывает.
[49:48.760 --> 49:56.760]  Здесь обратное.
[49:56.760 --> 50:02.760]  Обратное. Что у нас? Пусть у U существует сын.
[50:02.760 --> 50:10.760]  Ну действительно, пусть у вершины U есть потомок. Ну, собственно, все уже нарисовано на самом деле.
[50:10.760 --> 50:22.760]  Есть U, есть некоторый сын V.
[50:22.760 --> 50:42.760]  Если из V нельзя добраться в предков вершины U, то что это значит?
[50:42.760 --> 51:02.760]  Это значит, что V и предки U связаны только посредством вершины U.
[51:02.760 --> 51:21.760]  Ну и все из этого следует. U разделяет V и V.
[51:21.760 --> 51:24.760]  То есть в таком графе они связаны, то есть V от U и V.
[51:24.760 --> 51:27.760]  А если я вершину U удалю, то так как из V я ни в какого предка не могу попасть,
[51:27.760 --> 51:44.760]  ну двигаясь вот по этим ребрам и по обратным ребрам, то все плохо.
[51:44.760 --> 51:47.760]  Все понятно?
[51:47.760 --> 51:53.760]  Ну, собственно, теорема как раз дает нам некоторый алгоритм, ну, точнее как дает,
[51:53.760 --> 51:56.760]  дает нам некоторую идею алгоритма, как можно находить точки сочленения.
[51:56.760 --> 52:00.760]  То есть что мы делаем? Мы берем произвольную вершину, запускаем от нее DFS.
[52:00.760 --> 52:06.760]  И дальше смотрим. Вот если вершина корень, то считаем ее количеством детей.
[52:06.760 --> 52:10.760]  Если вершина не корень, то есть та вершина, которую мы посетили, не является корнем,
[52:10.760 --> 52:14.760]  то смотрим, существуют ли у нее дети, из которых нельзя попасть в предков.
[52:14.760 --> 52:18.760]  Вот и все. Причем заметьте, что пункты 2 и 1, они не пересекаются.
[52:18.760 --> 52:20.760]  То есть нельзя применять корню пункт 2.
[52:20.760 --> 52:24.760]  И к вершине, которая не является корнем, пункт 1 тоже нельзя применять.
[52:25.760 --> 52:33.760]  Окей. Контрпримеры привести или? Понятно. Что? Верим. Окей, хорошо.
[52:33.760 --> 52:36.760]  Вот. Но на самом деле остается непонятным что.
[52:36.760 --> 52:40.760]  Ну, для корня все очевидно. Ну, посчитали количество его детей и окей.
[52:40.760 --> 52:43.760]  Точнее, непосредственных детей.
[52:43.760 --> 52:48.760]  Для пункта 2 непонятно, как проверять для каждой вершины, верно ли что из предка,
[52:48.760 --> 52:50.760]  точнее верно ли что и сына нельзя попасть в предка.
[52:50.760 --> 52:52.760]  Ну, кажется, звучит как что-то сложное.
[52:52.760 --> 53:02.760]  Ну, давайте попробуем разобраться, как можно это все распутать.
[53:04.760 --> 53:06.760]  Давайте нарисую какой-нибудь граф.
[53:10.760 --> 53:13.760]  Точнее, давайте я сразу нарисую некоторые дерева обхода в глубину.
[53:19.760 --> 53:20.760]  Вот так.
[53:22.760 --> 53:25.760]  Пусть это вершина 0, 1.
[53:38.760 --> 53:46.760]  Вершина 0, это 1, это 2, пусть это 3, 4, 5, 6.
[53:46.760 --> 53:48.760]  Вот. Допустим, так выглядит дерево обхода в глубину.
[53:48.760 --> 53:51.760]  Ну, в смысле, я нарисовал сейчас ребра дерева.
[53:51.760 --> 53:54.760]  Как мы обозначали обратные ребра?
[53:54.760 --> 53:56.760]  Красным цветом, не помните?
[53:56.760 --> 54:03.760]  Ну, ладно. Вот так. И вот так.
[54:03.760 --> 54:07.760]  Это обратные.
[54:08.760 --> 54:11.760]  Ну, пусть красным будет, у меня обратные ребра.
[54:12.760 --> 54:16.760]  Ну, пусть красным будет, у меня обратные ребра.
[54:16.760 --> 54:19.760]  То есть вот я обошел мой граф с помощью обхода в глубину,
[54:19.760 --> 54:23.760]  черным цветом я нарисовал ребра дерева, красным цветом обратные ребра.
[54:23.760 --> 54:26.760]  То есть у меня граф не ориентированный по-прежнему.
[54:26.760 --> 54:29.760]  Я просто нарисовал направление обхода.
[54:32.760 --> 54:38.760]  Так, а помните, на самом первом лекции с DFS мы там что-то подсчитывали, какую-то дополнительную информацию?
[54:38.760 --> 54:41.760]  В качестве одной из такой информации было время захода.
[54:41.760 --> 54:43.760]  То есть время, когда мы впервые посетили вершину.
[54:43.760 --> 54:45.760]  Вот сейчас эта информация нам пригодится.
[54:45.760 --> 54:49.760]  Давайте для каждой вершины напишем время ее посещения.
[54:49.760 --> 54:52.760]  Ну, стартовали мы с вершины 0, поэтому мы посетили ее в момент времени 0.
[54:52.760 --> 54:55.760]  Дальше, допустим, мы спустили с вершины 2.
[54:55.760 --> 54:57.760]  Время посещения это 1.
[54:57.760 --> 55:00.760]  Дальше вернулись в вершину 0 и, допустим, пошли в вершину 5.
[55:00.760 --> 55:02.760]  Значит, здесь момент посещения 2.
[55:02.760 --> 55:05.760]  Вершина 3, момент посещения 3.
[55:05.760 --> 55:07.760]  Дальше пошли в вершину 1.
[55:07.760 --> 55:11.760]  4, здесь 5, здесь 6.
[55:11.760 --> 55:14.760]  Все, посчитали время захода.
[55:14.760 --> 55:17.760]  То есть время первого посещения данной вершины.
[55:17.760 --> 55:19.760]  А теперь смотрите.
[55:19.760 --> 55:21.760]  Идея такая.
[55:21.760 --> 55:23.760]  Давайте посмотрим произвольный путь.
[55:23.760 --> 55:26.760]  Путь по ребрам дерева, сверху вниз.
[55:27.760 --> 55:33.760]  Заметьте, что время захода вдоль каждого пути только возрастает.
[55:33.760 --> 55:38.760]  Но оно и понятно, потому что если какая-то вершина является потомком другой вершины,
[55:38.760 --> 55:40.760]  то время ее захода позже.
[55:40.760 --> 55:43.760]  Потому что в процессе обхода этой вершины я обнаружил своего потомка.
[55:43.760 --> 55:45.760]  То есть потомка я обнаружил позже, чем предка.
[55:45.760 --> 55:51.760]  Поэтому, соответственно, время захода больше, чем время захода для предка.
[55:52.760 --> 56:16.760]  То есть время захода на пути от предка к потомкам возрастает.
[56:16.760 --> 56:34.760]  А это значит, что time in можно использовать как меру глубины.
[56:34.760 --> 56:36.760]  Условно глубины.
[56:36.760 --> 56:39.760]  Давайте в кавычки возьмем.
[56:39.760 --> 56:44.760]  Грубо говоря, чем больше у меня time in, тем глубже у меня находится вершина.
[56:45.760 --> 56:48.760]  Понятное дело, что не имеет смысла сравнить, например, вершину 4 и вершину 5.
[56:48.760 --> 56:50.760]  То есть какая из них глубже.
[56:50.760 --> 56:53.760]  Имеет смысл только сравнить вершины, которые находятся вдоль одного пути.
[56:53.760 --> 56:58.760]  Но тем не менее, вдоль одного пути я могу говорить, что чем глубже у меня вершина, тем больше у нее там in.
[57:02.760 --> 57:05.760]  Давайте я заведу еще одну характеристику и назову ее time up.
[57:05.760 --> 57:10.760]  Time up от вершины v.
[57:10.760 --> 57:18.760]  Это глубина, глубина в смысле time in,
[57:18.760 --> 57:47.760]  на которую можно подняться, двигаясь только по ребрам дерева
[57:47.760 --> 57:58.760]  и одному обратному вибру.
[57:58.760 --> 58:02.760]  То есть, грубо говоря, time up говорит, насколько высоко вы можете запрыгнуть.
[58:02.760 --> 58:06.760]  Допустим, из вершины 3 вы можете сразу прыгнуть,
[58:06.760 --> 58:13.760]  или вы можете как-то оттолкнуться, спуститься вниз и потом резко выпрыгнуть на один шаг вперед.
[58:13.760 --> 58:15.760]  То есть time up, насколько высоко вы можете выпрыгнуть.
[58:15.760 --> 58:18.760]  Давайте просто для каждой вершины посчитаем через черту.
[58:18.760 --> 58:21.760]  Для вершины 0 насколько высоко я могу подняться?
[58:21.760 --> 58:24.760]  Только в нее же саму, поэтому 0.
[58:24.760 --> 58:27.760]  Из вершины 2 как высоко я могу подняться?
[58:27.760 --> 58:29.760]  Ну снова, только в нее саму.
[58:29.760 --> 58:32.760]  Выше в нее я подняться не могу, поэтому 2.
[58:32.760 --> 58:41.760]  Так, не 2, а 1, потому что у нее time in 1.
[58:41.760 --> 58:46.760]  Смотрите, глубина, на которую можно подняться, двигаясь только по ребрам дерева и одному обратному вибру.
[58:46.760 --> 58:48.760]  У нее есть ребра дерева?
[58:48.760 --> 58:50.760]  Нет, из нее не торчит ребра дерева.
[58:50.760 --> 58:54.760]  Обратное вибро торчит, поэтому я могу остаться только в ней, то есть 1.
[58:54.760 --> 58:58.760]  Ну 1 это time in ее.
[58:58.760 --> 59:04.760]  То есть глубина задается у меня time in.
[59:04.760 --> 59:06.760]  1, 1.
[59:06.760 --> 59:08.760]  И с пятерки.
[59:08.760 --> 59:10.760]  Вот с пятеркой поинтереснее.
[59:10.760 --> 59:12.760]  Могу в 0, согласны?
[59:12.760 --> 59:16.760]  Смотрите, из пятерки я могу сначала оттолкнуться, то есть пойти в тройку,
[59:16.760 --> 59:20.760]  а потом резко подняться в 0 по обратному ребру.
[59:20.760 --> 59:21.760]  Поэтому 0.
[59:21.760 --> 59:22.760]  Для тройки.
[59:22.760 --> 59:24.760]  Для тройки я могу сразу прыгнуть в 0.
[59:24.760 --> 59:26.760]  Поэтому 0.
[59:26.760 --> 59:28.760]  Ну 0 в смысле time in, вот этот.
[59:28.760 --> 59:30.760]  Я сюда смотрю.
[59:30.760 --> 59:32.760]  Вот.
[59:32.760 --> 59:36.760]  То есть я смотрю не на номер вершины, а на time in, потому что time in мне задает глубину.
[59:36.760 --> 59:39.760]  Для четверки.
[59:39.760 --> 59:42.760]  Да, и с четверки тоже могу подняться только в 0.
[59:42.760 --> 59:44.760]  И с четверки.
[59:44.760 --> 59:46.760]  Тут была единица, тут четверка.
[59:46.760 --> 59:48.760]  Могу остаться только в ней.
[59:48.760 --> 59:50.760]  То есть шестерка.
[59:50.760 --> 59:54.760]  Шестерка.
[59:54.760 --> 59:58.760]  Давайте, чтобы никому не смущать, напишу 1.
[59:58.760 --> 01:00:01.760]  Тут 0, окей?
[01:00:01.760 --> 01:00:07.760]  Чтобы вы отличали номер вершины и time in.
[01:00:07.760 --> 01:00:11.760]  Пример понятен?
[01:00:11.760 --> 01:00:12.760]  Все.
[01:00:12.760 --> 01:00:19.760]  Ну а теперь.
[01:00:19.760 --> 01:00:21.760]  Все, самый главный пункт на сегодня.
[01:00:21.760 --> 01:00:27.760]  Второй пункт.
[01:00:27.760 --> 01:00:31.760]  Теоремы.
[01:00:31.760 --> 01:00:37.760]  Эквивалентен следующему.
[01:00:37.760 --> 01:00:44.760]  Time up от v.
[01:00:44.760 --> 01:00:48.760]  Связан с time in от u как?
[01:00:48.760 --> 01:00:52.760]  Из вершины v нельзя попасть в предка.
[01:00:52.760 --> 01:00:53.760]  То есть что это значит?
[01:00:53.760 --> 01:00:57.760]  Это значит, что глубина, на которую я могу подняться из вершины v,
[01:00:57.760 --> 01:01:03.760]  она больше либо равна, чем time in от u.
[01:01:03.760 --> 01:01:09.760]  Согласны?
[01:01:09.760 --> 01:01:19.760]  u это вершина, v это сын, вершина u.
[01:01:19.760 --> 01:01:24.760]  То есть так как из сына u, то есть из вершины v, я не могу подняться выше, чем вершина u,
[01:01:24.760 --> 01:01:27.760]  то это значит, что у нее time up больше, чем time in.
[01:01:27.760 --> 01:01:31.760]  То есть она находится ниже, чем вершина u.
[01:01:31.760 --> 01:01:39.760]  Понятно?
[01:01:39.760 --> 01:01:45.760]  Нет, все нормально.
[01:01:45.760 --> 01:01:53.760]  Из v нельзя попасть в предка u означает, что time up от v.
[01:01:53.760 --> 01:01:56.760]  Давайте я нарисую, чтобы было понятней.
[01:01:56.760 --> 01:02:00.760]  В терминах глубины так, мне кажется, будет проще осознать.
[01:02:00.760 --> 01:02:08.760]  От u.
[01:02:08.760 --> 01:02:16.760]  От v.
[01:02:16.760 --> 01:02:18.760]  Вот так понятней, да?
[01:02:18.760 --> 01:02:30.760]  То есть вершина u находится выше, чем то место, куда я могу подняться из вершины v.
[01:02:30.760 --> 01:02:35.760]  Давайте по этому критерию попробуем в данном графе понять, где у меня точки сочленения.
[01:02:35.760 --> 01:02:41.760]  Является ли вершина 1 точкой сочленения?
[01:02:41.760 --> 01:02:46.760]  Вот таким критерием в вершине 1 нельзя пользоваться. Почему?
[01:02:46.760 --> 01:02:48.760]  Потому что это корень, для корня отдельный критерий.
[01:02:48.760 --> 01:02:50.760]  Вершина 1 является точкой сочленения?
[01:02:50.760 --> 01:02:52.760]  Да, у нее больше, чем один сын.
[01:02:52.760 --> 01:02:55.760]  Поэтому, давайте, звездочка, это точка сочленения.
[01:02:55.760 --> 01:02:58.760]  Проверим для пятерки.
[01:02:58.760 --> 01:03:03.760]  Смотрим, у нее time in 2, и с тройки можно подняться в ноль.
[01:03:03.760 --> 01:03:09.760]  То есть time up у ее сына меньше, чем у нее time in.
[01:03:09.760 --> 01:03:12.760]  То есть 2 больше, чем ноль.
[01:03:12.760 --> 01:03:16.760]  Поэтому это не точка сочленения.
[01:03:16.760 --> 01:03:20.760]  Time in от u это 2, time up от v это ноль.
[01:03:20.760 --> 01:03:22.760]  Вот это неравенство не выполнено.
[01:03:22.760 --> 01:03:24.760]  Все, это не точка сочленения.
[01:03:24.760 --> 01:03:32.760]  Тройка у нее вообще нет сыновей, поэтому она не может в принципе являться точкой сочленения.
[01:03:32.760 --> 01:03:36.760]  Так, эта вершина тоже у нее нет сыновей, она не является...
[01:03:36.760 --> 01:03:39.760]  В общем, тут ничего не пишите, она не является точкой сочленения.
[01:03:39.760 --> 01:03:43.760]  Эта вершина, по тем же самым причинам, не является точкой сочленения.
[01:03:43.760 --> 01:03:45.760]  Шестерка не является точкой сочленения.
[01:03:45.760 --> 01:03:49.760]  Вот ноль, давайте проверим ноль.
[01:03:49.760 --> 01:03:53.760]  Является ли ноль точкой сочленения?
[01:03:53.760 --> 01:03:55.760]  Она является точкой сочленения почему?
[01:03:55.760 --> 01:04:00.760]  Потому что у нее существует сын, вот этот вот гаденыш,
[01:04:00.760 --> 01:04:07.760]  у которого time up 6, и он больше либо равен, чем time in у этой вершины, то есть 4.
[01:04:08.760 --> 01:04:11.760]  Да, существует, существует достаточно одного.
[01:04:11.760 --> 01:04:14.760]  То есть здесь 4 меньше либо равно, чем 6.
[01:04:14.760 --> 01:04:17.760]  Поэтому ноль это точка сочленения.
[01:04:17.760 --> 01:04:19.760]  Ну и мы не успели выписать алгоритм,
[01:04:19.760 --> 01:04:25.760]  на самом деле алгоритм заключается просто в одном обходе в глубину.
[01:04:25.760 --> 01:04:29.760]  Давайте я просто выпишу формулу, по которой можно посчитать time up.
[01:04:29.760 --> 01:04:34.760]  Ну а алгоритм разберете на семинарах, ну и в следующий раз лекцию начнем с этого.
[01:04:34.760 --> 01:04:42.760]  Time up от v посчитать очень легко прямо во время обхода dfs.
[01:04:42.760 --> 01:04:45.760]  То есть если вы думаете, что time up это что-то сложное, нет,
[01:04:45.760 --> 01:04:47.760]  его очень просто посчитать прямо во время обхода в глубину,
[01:04:47.760 --> 01:04:49.760]  ровно так же как и time in и time out.
[01:04:49.760 --> 01:04:54.760]  Это просто минимум из следующих величин.
[01:04:54.760 --> 01:04:57.760]  Ну, во-первых, зададимся таким вопросом,
[01:04:57.760 --> 01:05:00.760]  как высоко я могу подняться из вершины v?
[01:05:00.760 --> 01:05:03.760]  Я могу никуда не двигаться, могу остаться сам в себе.
[01:05:03.760 --> 01:05:05.760]  Я могу никуда не двигаться.
[01:05:05.760 --> 01:05:09.760]  Поэтому time in от v.
[01:05:09.760 --> 01:05:11.760]  То есть это у меня никто не отберет.
[01:05:11.760 --> 01:05:13.760]  Дальше.
[01:05:13.760 --> 01:05:21.760]  Меньше и минимум из time in от...
[01:05:21.760 --> 01:05:27.760]  Давайте back напишу.
[01:05:27.760 --> 01:05:38.760]  Где vback это обратное ребро.
[01:05:38.760 --> 01:05:41.760]  Ну понятно, как еще можно подняться наверх?
[01:05:41.760 --> 01:05:45.760]  Можно просто взять, подпрыгнуть и подняться в предках с помощью обратного ребра.
[01:05:45.760 --> 01:05:47.760]  Да?
[01:05:47.760 --> 01:05:49.760]  То есть что мы делаем?
[01:05:49.760 --> 01:05:52.760]  Мы сначала инициализируем time up от v с помощью time in от v,
[01:05:52.760 --> 01:05:54.760]  дальше запускаем обход в глубину,
[01:05:54.760 --> 01:05:58.760]  только мы встречаем обратное ребро, мы обновляем наш time up.
[01:05:58.760 --> 01:06:00.760]  То есть берем минимум.
[01:06:00.760 --> 01:06:02.760]  Ну и последний.
[01:06:02.760 --> 01:06:05.760]  Как еще можно подняться по жизни?
[01:06:05.760 --> 01:06:07.760]  Можно посмотреть в time up детей.
[01:06:07.760 --> 01:06:09.760]  То есть если вы сами не можете прыгнуть,
[01:06:09.760 --> 01:06:11.760]  то можете воспользоваться связями и спросить,
[01:06:11.760 --> 01:06:13.760]  а вы там можете подняться?
[01:06:13.760 --> 01:06:15.760]  Если вы можете, то и я могу.
[01:06:15.760 --> 01:06:23.760]  Time up от 3, где v.
[01:06:23.760 --> 01:06:32.760]  3 это ребро дерева.
[01:06:32.760 --> 01:06:40.760]  Ну то есть для вершины v я могу остаться на том же уровне,
[01:06:40.760 --> 01:06:44.760]  могу подняться с помощью обратного ребра,
[01:06:44.760 --> 01:06:50.760]  могу спуститься в ребёнка и подняться из него.
[01:06:50.760 --> 01:06:56.760]  Вот три возможных способа обновить time up.
[01:06:56.760 --> 01:07:00.760]  То есть обратные ребра мы умеем определять во время обход DFS?
[01:07:00.760 --> 01:07:01.760]  Умеем.
[01:07:01.760 --> 01:07:03.760]  Рёбра дерева мы умеем определять во время обход DFS?
[01:07:03.760 --> 01:07:04.760]  Умеем.
[01:07:04.760 --> 01:07:08.760]  Соответственно time up от v тоже умеем вычислять во время обход DFS.
