[00:00.000 --> 00:10.040]  мы в прошлый раз закончили вот на таком примере значит у нас продолжается тема лямбду функций
[00:10.040 --> 00:24.600]  и последний раз я вам рассказывал про списки захвата в лямбдах вот тут мы рассматривали
[00:24.600 --> 00:34.680]  пример что если я в классе нахожусь то поля класса они мне капчер был то есть я не могу
[00:34.680 --> 00:38.640]  написать а в квадратных скобочках вот если я здесь пишу а в квадратных скобочках то это будет
[00:38.640 --> 00:45.640]  ошибка компиляции нет никакого а который можно было бы захватить возможно кстати это я не
[00:45.640 --> 00:56.320]  показывал давайте я напомню так г плюс плюс ага да г плюс плюс 11 у меня все замечательно
[00:56.320 --> 01:07.120]  г плюс плюс 11 лямбда captures вот я не могу захватить а потому что non variable ну потому
[01:07.120 --> 01:19.320]  что это нелокальная переменная она не подлежит захвату да да но я могу вот так написать понимаете
[01:19.320 --> 01:27.640]  почему потому что это как если бы я ну я скажу заведи внутри себя в лямбде внутреннее поле а
[01:27.640 --> 01:33.560]  которая будет про инициализировано текущим актор я вижу локально вот так нормально то есть
[01:33.560 --> 01:40.760]  это да вот здесь я уже честно захватил по копии все нормально и теперь когда объект
[01:40.760 --> 01:54.280]  умрет у меня не не сломается ничего я мог бы написать вот так и тогда бы опять была та же
[01:54.280 --> 02:03.480]  самая проблема ну это я захватил по ссылке как бы на инт назвав ее а то что я видел как
[02:03.480 --> 02:15.320]  а вот это я своей лямбде создал ссылку на инт ну как поле в объекте которая ссылается на текущие
[02:15.440 --> 02:25.240]  но опять если объект умрет ссылка будет неволидной вот ладно еще один пример который я здесь
[02:25.240 --> 02:31.320]  покажу прежде чем дальше пойти это статические переменные вот представьте что у меня есть
[02:31.320 --> 02:40.720]  статическая переменная static int я даже не знаю как назвать а равно 3 чтобы не сконфликтовать
[02:40.720 --> 02:50.080]  именами другими и вот я пытаюсь значит вот эту вот лямбду но только я тоже не назвать по-другому
[02:50.080 --> 03:03.840]  аж например вот я хочу сказать давай-ка я вот такую лямбду заведу вот получится у меня или нет ну нет
[03:03.840 --> 03:14.960]  потому что статические тоже не захватываемые ну нет захватываемая да я ошибся значит так
[03:14.960 --> 03:33.720]  можно писать но интересно если я скажу c++ так равно warning ну ладно вот если я так напишу
[03:33.720 --> 03:48.920]  что будет но вот кажется что оно должно работать несмотря на то что я не захватил потому что а
[03:48.920 --> 03:58.720]  а это статическая переменная а стало быть она не должна присутствовать списках захвата и вот
[03:58.720 --> 04:03.880]  странно насколько я понял это должно было быть ошибкой но почему-то это не являлась ошибкой
[04:03.880 --> 04:11.240]  ну ладно давайте так попробуем да так работает естественно статическая переменная то мне не
[04:11.240 --> 04:17.400]  надо писать в захват потому что она статическая она не локально но она локальная статическая но
[04:17.400 --> 04:24.640]  она не локальная в том смысле что ее время жизни не ограничивается этой функцией вот короче
[04:24.640 --> 04:33.200]  для статических переменных все работает не так как можно было бы подумать и кстати вот
[04:33.200 --> 04:44.200]  допустим я здесь увеличил бы а я бы сказал здесь вот так
[04:44.200 --> 05:06.040]  и выведем сейчас аж от чего от 5 вот что будет во-первых могу ли я увеличивать а а ведь казалось
[05:06.040 --> 05:18.160]  бы ну я не написал мютабл я не сказал что лямбда мютабл а как а значит казалось бы я не
[05:18.160 --> 05:28.040]  должен уметь захват но я же не захватила а да чего-чего не на аргумент она то что мы захватили а
[05:28.040 --> 05:35.040]  а мы не захватили она нам и так доступно то есть это будет работать и это реально изменит нашу а
[05:35.040 --> 05:47.600]  будет 9 ну там дальше еще что-то выявилось но первым числом выявилось 9 вот
[05:47.600 --> 06:03.320]  не понял вопрос что значит структуру с таким же смыслом
[06:03.320 --> 06:23.360]  да сейчас на самом деле я как раз хочу перейти к пункту следующему и я сегодня вам покажу вот
[06:23.360 --> 06:28.200]  сейчас как лямбда работает изнутри то есть на самом деле вот то что мы сейчас все делаем это какие-то
[06:28.200 --> 06:36.400]  такие это мы так исследуем слона там потрогали за хвост потрогали за хобот как это бывает в известной
[06:36.400 --> 06:45.120]  фритче но на самом деле все эти вопросы сразу становятся очевидными если просто понять что на
[06:45.120 --> 06:50.360]  самом деле делает компилятор когда видеть лямбда вот сейчас мы на это посмотрим ну вот последний
[06:50.360 --> 06:57.000]  момент вот мы здесь написали а в квадратных скобках вот почему ворнинг то есть это не ошибка
[06:57.000 --> 07:02.760]  компиляции мы его как будто бы захватили но на самом деле нет мы вот я не знаю почему это не
[07:02.760 --> 07:07.560]  ошибка компиляции это странно что это не эррор ну минус эррор это был бы эррор то есть мы написали
[07:07.560 --> 07:14.320]  статическую переменную как будто мы ее захватываем но на самом деле мы ее не мы не создали ее копию она
[07:14.320 --> 07:20.240]  все еще статическая и мы все еще обращаемся к ней как будто она из мейна и меняем ее если
[07:20.240 --> 07:28.720]  инкриментируем вот такие дела ну можно еще поэкспериментировать что было бы я ссылку
[07:28.720 --> 07:36.360]  написал например ну то же самое ну без разницы все равно я бы обращался к ней самой таким способом
[07:36.360 --> 07:47.880]  короче опасно это статические переменные в лямбде в общем да когда вы что-нибудь в лямбду захватываете
[07:47.880 --> 07:53.520]  надо очень аккуратными быть надо вообще думать если вы из лямбды используете какие-то вещи кроме
[07:53.520 --> 08:00.600]  как аргументы лямбды то надо все время все время быть внимательным все время думать это вы захватили
[08:00.600 --> 08:06.360]  по ссылке или по значению они закончится ли время жизни этой штуки раньше чем вы ее используете и
[08:06.360 --> 08:20.720]  так далее вот ну ладно так вот сейчас будет самое интересное это пункт 10 3 лямбды как объекты
[08:20.720 --> 08:37.800]  ой не 10 3 13 3 closures as objects напоминаю что такое closure это слово переводим замыкание
[08:37.800 --> 08:44.960]  замыканием называется вот тот тип который получается из лямбды ну это просто такой термин
[08:44.960 --> 08:49.520]  с функционального программирования closure замыкание почему так называется ну не знаю
[08:49.520 --> 08:53.720]  исторически так называется можно в википедии кстати найти я нашел статью википедии на русском
[08:53.720 --> 08:59.760]  языке замыкание в скобочках программирования ну да есть это не c++ специфичное название просто
[08:59.760 --> 09:05.320]  вот такие объекты называется замыканиями вот там в каких-то функциональных языках они очень
[09:05.320 --> 09:13.840]  часто встречаются так вот я вам покажу сейчас такой замечательный сайт который называется cpp
[09:13.840 --> 09:29.520]  insights точка его вот и он ну кажется что тут я могу соврать возможно это как-то связано
[09:29.520 --> 09:34.400]  с год болтам в общем есть сайт год болт который вы наверное знаете который вам позволяет
[09:34.400 --> 09:39.600]  смотреть какой какой ассемблер ваш код превращается вот но люди пошли дальше и
[09:39.600 --> 09:46.520]  создали сайт cpp insights который позволяет вам посмотреть во что превращается ваш код на плюсах
[09:46.520 --> 09:55.360]  до того как он превращается в ассемблер то есть компилятор компилируя ваш код на самом деле
[09:55.360 --> 10:01.080]  его некоторым образом преобразует а уже потом генерирует ассемблер и вот ну например вот
[10:01.080 --> 10:04.600]  здесь в качестве учебного при в качестве ознакомительного примера вот такой вот
[10:04.600 --> 10:10.840]  пример приведен можно жать на кнопочку получить результат вот можно увидеть что на самом деле
[10:10.840 --> 10:17.800]  с точки зрения компилятора то что здесь написано range based for вот этот вот разворачивая во первых
[10:17.800 --> 10:25.360]  conchard r10 разворачивается вот в такое тут 10 нуле еще стоит а во вторых range based for
[10:25.360 --> 10:33.920]  разворачивается вот такое очень удобно приятно можно смотреть как компиля ну здесь можно смотреть
[10:33.920 --> 10:40.400]  например как компилятор расшифровывает range based for как компилятор там некоторые
[10:40.400 --> 10:45.400]  шаблоны инстанцирует ну и вот пожалуй одно из самого полезного что здесь можно увидеть во что
[10:45.400 --> 10:53.080]  компилятор лямбуда превращает давайте я просто покажу вам вот я напишу авто f равно ну стандартно
[10:53.080 --> 11:08.080]  ничего не захватываю int x int y а return x меньше y и скажу там std seout f от 1 2 ну include o stream надо
[11:08.080 --> 11:17.080]  написать вот сейчас я нажимаю на кнопочку play и чудесным образом я сейчас увижу
[11:17.080 --> 11:33.280]  чего почему я еще пока не нажал вот смотрите что произошло ну тут довольно мелко вот так можно то
[11:33.280 --> 11:39.920]  есть смотрите что на самом деле для компилятора означает лямбда вот мы сейчас копнем вглубь и
[11:39.920 --> 11:51.360]  поймем что такое лямбда на самом деле на самом деле да чего да на самом деле компилятор видя лямбду
[11:51.360 --> 11:58.640]  создает локальный класс с каким-то техническим внутренним названием это вот это название конечно
[11:58.640 --> 12:04.200]  же никем не гарантируется это компилятор сам он придумывает какое-нибудь название для этого класса
[12:04.200 --> 12:07.680]  так чтобы оно не пересекалось ни с каким из ваших существующих в общем по какому-то
[12:07.680 --> 12:14.600]  внутреннему там принципу придумают лямбда 8 11 я так полагаю что 8 это номер строки 11 номер
[12:14.600 --> 12:25.120]  номер столбца в котором он встретил а в которой самое главное что есть это inline был оператор
[12:25.120 --> 12:36.480]  круглые скобочки конст который возвращает x меньше игр а почему конст ну потому что
[12:36.480 --> 12:43.560]  обычно компаратор ожидает ну когда вы в мэп передаете лямбду например в компаратор то он
[12:43.560 --> 12:48.440]  ожидает ну у мэпа компаратор например ждает что оператор круглые скобочки конст да и у
[12:48.440 --> 12:55.480]  сортировок ну короче логично что круглые скобочки должен быть конст с точки зрения лямбда да конст
[12:55.480 --> 13:02.080]  текстур закомментированный видимо это видимо начиная с какого-то стандарта это должно быть
[13:02.080 --> 13:08.560]  конст экспорт но пока нет я не знаю почему так написано дальше дальше смотрите что еще есть у
[13:08.560 --> 13:20.520]  этой лямбды у этой лямбды есть такой замечательный метод ну во-первых вот такой using using red
[13:20.520 --> 13:30.200]  type 8 11 это вот это что это такое это указательная функция то есть на самом деле лямбда еще неявно
[13:30.200 --> 13:40.840]  конвертируема в да function pointer то есть какой какие требования стандарта кладывает на вот этот
[13:40.840 --> 13:46.320]  вот тип closure во-первых должен быть константный оператор круглые скобочки от ваших типов которые
[13:46.320 --> 13:55.520]  возвращает то что вам надо во-вторых а должна быть неявная конверсия и вот это именно она это
[13:55.520 --> 14:03.680]  оператор приведения неявного к типу вот этому то есть лямбда не явно конвертируема в function
[14:03.680 --> 14:15.760]  pointer объект этой лямбды и возвращает он чтобы вы думали вот эту штуку а это некоторая статическая
[14:15.760 --> 14:23.120]  функция которая по сути просто создает человековые объекты вызывает мне оператор круглые скобочки то
[14:23.120 --> 14:30.160]  есть ну во что должен сконвертировать компилятор эту лямбду если я попросил конверсию к оператору
[14:30.160 --> 14:38.960]  господи к function pointer он должен вернуть как pointer на какую-то сишную функцию от двух параметров
[14:38.960 --> 14:44.440]  на какую но она просто статически еще тут объявлена отдельно на ряду совсем тем что
[14:44.440 --> 14:54.640]  да да да это статическая функция от двух аргументов вот и она таким образом я могу
[14:54.640 --> 15:06.600]  function pointer значит сконвертировать ну вызвать лямбду как function pointer ну вот он значит написал
[15:06.600 --> 15:13.680]  вот это все и сразу же дальше я объявил объект такого класса по умолчанию а дальше просто я
[15:13.680 --> 15:21.320]  сказал ну стд си аут точка оператор такой-то f точка оператор такой-то от вот этого вот что на
[15:21.320 --> 15:41.000]  самом деле происходит когда я делаю вот так вот а теперь главный вопрос после которого вам у
[15:41.000 --> 15:50.600]  вас должно что-то проясниться в голове вот смотрите давайте опять вот этот пример рассмотрю
[15:50.600 --> 16:11.080]  да у меня есть что у меня есть ну в общем такая штука и я значит сравниваю по расстоянию до
[16:11.080 --> 16:26.480]  середины что на самом деле ну я захвачу вот это вот да господи что на самом деле будет с объектом
[16:26.480 --> 16:39.160]  что что появится справа если я так вот сделаю вот это мит которая я захватил это что это поле
[16:39.160 --> 16:48.800]  класса конечно то есть на самом деле когда я что-то в класс захватываю что появляется у этого
[16:48.800 --> 16:56.000]  класса да у него появляется просто приватное поле а также появляется конструктор от этой
[16:56.000 --> 17:04.080]  штуки захваченной по ссылке который инициализирует это поле значением копируя его
[17:04.080 --> 17:16.680]  но а по ссылке здесь будет интомперсант они и и это должно теперь вам вот теперь вам должно
[17:16.680 --> 17:23.680]  стать понятно почему я не могу написать плюс плюс мит здесь да потому что круглые скобочки
[17:23.680 --> 17:30.400]  так он а мид это поле когда я захватил по значению на самом деле у меня в классе появилось поле
[17:30.400 --> 17:37.880]  просто в классе лям в классе closure но поскольку круглые скобочки должны быть константными я не
[17:37.880 --> 17:48.640]  могу поля менять а мид это моё поле сейчас вопрос почему не констант логично оператор круглые
[17:48.640 --> 17:59.920]  скобочки константные зачем ему быть констант кто требует этого чего что от этого станет
[17:59.980 --> 18:04.320]  понятнее у нас есть требование что круглые скобочки должны быть константными круглые скобочки
[18:04.320 --> 18:14.320]  должны не менять объект но поля этого объекта они ну обычные поля да почему почему я не могу
[18:14.320 --> 18:20.080]  менять поля и скобочек да потому что поля констант потому что круглые скобочки константный если
[18:20.080 --> 18:25.160]  я пишу здесь мьютобыл то это просто приводит к тому что
[18:29.920 --> 18:31.920]  что круглые скобочки перестают быть константными
[18:34.280 --> 18:37.000]  да, кстати, интересно, можно было бы mutable написать здесь
[18:37.000 --> 18:39.600]  ну, нет, ну, ну это странно, да
[18:46.160 --> 18:48.160]  ну вот перестают быть константными круглые скобочки
[18:48.920 --> 18:51.400]  вот, а если я по ссылке захватываю
[18:52.520 --> 18:53.560]  и не пишу mutable
[18:54.200 --> 18:55.040]  что происходит?
[19:00.920 --> 19:02.920]  как это работает?
[19:02.920 --> 19:04.920]  я говорю плюс плюс мид
[19:04.920 --> 19:07.920]  у меня теперь поле это интом персант
[19:13.920 --> 19:16.920]  вот это конст не запрещает менять мне вот этот мид
[19:17.920 --> 19:20.920]  потому что технически это указатель наверное
[19:20.920 --> 19:23.920]  да, значит это может вас шокировать
[19:23.920 --> 19:25.920]  если у вас восприятие ссылок
[19:26.920 --> 19:30.920]  значит как не отличимых от исходного объекта вещей
[19:30.920 --> 19:33.920]  но на самом деле мы это обсуждали в первом семестре
[19:33.920 --> 19:35.920]  что если у вас ссылка является полем
[19:35.920 --> 19:39.920]  то константость метода не влияет на возможность вашу менять вот это поле
[19:43.920 --> 19:46.920]  да, то есть я могу менять мид тем самым меняя то что под ссылкой
[19:46.920 --> 19:49.920]  но как бы с точки зрения компилятора поле я не поменял
[19:49.920 --> 19:50.920]  вот
[19:52.920 --> 19:55.920]  поэтому если я захватываю по ссылке то я могу менять
[19:55.920 --> 19:59.920]  а если я захватываю по значению то я не могу менять если только mutable не напишу
[20:00.920 --> 20:01.920]  вот так это работает
[20:01.920 --> 20:03.920]  вот это объясняет почему все так устроено
[20:06.920 --> 20:07.920]  а дальше
[20:08.920 --> 20:09.920]  хорошо
[20:10.920 --> 20:11.920]  ну давайте вернемся к
[20:19.920 --> 20:20.920]  ну я же говорил мы можем
[20:20.920 --> 20:23.920]  мы можем написать авто ну std sconst мы можем написать
[20:27.920 --> 20:29.920]  просто это поле будет константное да?
[20:30.920 --> 20:32.920]  тогда у меня будет
[20:32.920 --> 20:34.920]  compilation failed
[20:34.920 --> 20:36.920]  потому что
[20:37.920 --> 20:41.920]  нет потому что no member named sconst
[20:43.920 --> 20:45.920]  господи а где оно в утилите может быть
[20:49.920 --> 20:50.920]  да
[20:51.920 --> 20:53.920]  да теперь это константная ссылка
[20:55.920 --> 20:58.920]  да я вам в прошлый раз неправильно сказал я вам в прошлый раз вот так сказал
[20:58.920 --> 21:00.920]  надо писать meet равно std sconst meet
[21:00.920 --> 21:03.920]  но это это все равно было бы meet это было бы значением
[21:03.920 --> 21:05.920]  а вот так я могу константную ссылку написать
[21:06.920 --> 21:07.920]  вот
[21:14.920 --> 21:15.920]  ну хорошо
[21:15.920 --> 21:16.920]  хорошо что?
[21:21.920 --> 21:22.920]  кто?
[21:28.920 --> 21:30.920]  ну да похоже уже не костуется
[21:38.920 --> 21:39.920]  сейчас
[21:40.920 --> 21:41.920]  для
[21:41.920 --> 21:46.920]  если в лямбде есть захват то да к function pointer она уже не костуется потому что
[21:47.920 --> 21:49.920]  ну потому что непонятно как потому что нужно
[21:50.920 --> 21:57.920]  неявным первым параметром принять вис туда и там поля какие-то использовать уже не понятно как это делается
[21:59.920 --> 22:02.920]  что оно не костуется к function pointer в таком случае
[22:05.920 --> 22:06.920]  да
[22:12.920 --> 22:13.920]  вот
[22:19.920 --> 22:25.920]  я думаю что идея не сработает потому что конст же отбрасывается при выводе типа
[22:25.920 --> 22:28.920]  он же что делает он выводит тип снова вот здесь
[22:28.920 --> 22:30.920]  но если у тебя конст значения
[22:31.920 --> 22:32.920]  ну если я пишу вот так
[22:33.920 --> 22:37.920]  равно std sconst то это как если бы я написал авто
[22:37.920 --> 22:40.920]  x проинцелизировав его этой штукой
[22:40.920 --> 22:41.920]  но
[22:41.920 --> 22:44.920]  конста отбросится если у тебя там просто значение
[22:45.920 --> 22:50.920]  вот если у тебя там была ссылка то конст не отбросится а если было значение то конст отбрасывается потому что это бессмысленно
[22:51.920 --> 22:54.920]  бессмысленно навешивать конст на объект
[22:54.920 --> 22:56.920]  на не ссылку
[23:00.920 --> 23:03.920]  ну мало ли просто был бы интересный способ оставить
[23:04.920 --> 23:05.920]  вот ну то есть все равно int
[23:06.920 --> 23:07.920]  вот ладно
[23:08.920 --> 23:11.920]  да здесь можно мувать как вы помните
[23:12.920 --> 23:15.920]  там вроде можно вообще все что угодно писать
[23:15.920 --> 23:16.920]  да можно любой expression писать
[23:16.920 --> 23:19.920]  ну вот если я кстати так напишу что будет
[23:25.920 --> 23:27.920]  будет ошибка компиляции сейчас
[23:28.920 --> 23:30.920]  потому что я пытаюсь
[23:30.920 --> 23:33.920]  проинцелизировать non constant value reference
[23:34.920 --> 23:35.920]  посредством rvl
[23:35.920 --> 23:39.920]  да все отлично все вы вы вы усвоили да хорошо
[23:41.920 --> 23:43.920]  могу написать это forward здесь
[23:43.920 --> 23:45.920]  ну ладно в общем вы все поняли
[23:46.920 --> 23:48.920]  да здесь вот так я написать не могу
[23:49.920 --> 23:50.920]  так не разрешено
[23:51.920 --> 23:56.920]  только либо 0 амперсантов либо 1 амперсант 2 амперсантов ну не разрешено так делать
[23:58.920 --> 24:00.920]  вот да просто такой синтаксис не добавили
[24:00.920 --> 24:02.920]  ладно хорошо
[24:03.920 --> 24:07.920]  давайте дальше так вот у меня есть значит такой такой объект f
[24:08.920 --> 24:09.920]  и теперь я говорю
[24:15.920 --> 24:16.920]  вот так говорю
[24:17.920 --> 24:18.920]  нормально все
[24:19.920 --> 24:22.920]  возьму создам f2 копирование msf
[24:23.920 --> 24:24.920]  все нормально
[24:28.920 --> 24:31.920]  должен сделать конструктор копирования а что не явно не до определиться
[24:33.920 --> 24:36.920]  почему нет я здесь целое число поставил
[24:37.920 --> 24:38.920]  все нормально
[24:39.920 --> 24:40.920]  без проблем
[24:41.920 --> 24:46.920]  ну у такого типа не явный конструктор копирования все нормально я создал копию этого объекта
[24:51.920 --> 24:52.920]  хорошо
[24:53.920 --> 24:54.920]  вот так могу ли я написать
[24:54.920 --> 24:57.920]  такого же типа как f сделай мне f2
[25:00.920 --> 25:03.920]  да будет ли конструктор по умолчанию хороший вопрос
[25:08.920 --> 25:15.920]  ну смотрите если читать буквально то что тут написано тут сгенерирован конструктор от int амперсант
[25:16.920 --> 25:17.920]  и
[25:17.920 --> 25:21.920]  как мы помним а мы же помним правда если у нас есть хоть один
[25:21.920 --> 25:25.920]  кастомный конструктор то дефолтный конструктор компилятором не генерируется
[25:26.920 --> 25:28.920]  поэтому сейчас будет ce
[25:29.920 --> 25:31.920]  так написать нельзя
[25:32.920 --> 25:34.920]  нету дефолтного конструктора но
[25:35.920 --> 25:37.920]  начиная си плюс плюс двадцать можно
[25:38.920 --> 25:40.920]  то есть я частично
[25:40.920 --> 25:45.920]  си плюс плюс двадцать добавили в стандарт требования что компилятор обязан сгенерировать еще и дефолтный конструктор
[25:46.920 --> 25:47.920]  а нет вру
[25:47.920 --> 25:49.920]  он обязан возгенерировать только если нету
[25:50.920 --> 25:56.920]  этих capture да если если есть capture все равно не будет вот если у меня нету capture то нормально
[26:00.920 --> 26:03.920]  что компилятор обязан сгенерировать дефолтный конструктор если нету захвата
[26:03.920 --> 26:05.920]  а что изменилось
[26:06.920 --> 26:11.920]  что компилятор обязан сгенерировать дефолтный конструктор если нету захвата а если есть
[26:14.920 --> 26:16.920]  давайте уберем захват и посмотрим
[26:19.920 --> 26:21.920]  вот если я так напишу
[26:22.920 --> 26:23.920]  то
[26:24.920 --> 26:25.920]  господи
[26:26.920 --> 26:27.920]  подождите
[26:28.920 --> 26:29.920]  си плюс плюс двадцать нормально
[26:30.920 --> 26:32.920]  вот а си плюс плюс семнадцать
[26:33.920 --> 26:35.920]  кажется это не работало еще
[26:36.920 --> 26:39.920]  по какой-то причине да это еще не работало
[26:40.920 --> 26:41.920]  а
[26:42.920 --> 26:44.920]  ну вот по кочану
[26:49.920 --> 26:51.920]  а чего так сейчас что
[26:52.920 --> 26:53.920]  no matching конструктор
[27:03.920 --> 27:05.920]  ну в общем до си плюс плюс двадцать
[27:06.920 --> 27:11.920]  несмотря на то что казалось бы по логике вещей конструктор должен генерироваться он не генерировался
[27:12.920 --> 27:15.920]  ну вот нельзя было так создавать лямбда по умолчанию а начиная си плюс плюс двадцать можно
[27:16.920 --> 27:18.920]  но только если нет захвата если есть захват то
[27:19.920 --> 27:26.920]  ну понятно потому что непонятно чем мид проницилизировать чем его проницилизировать нулем что ли ну типа это как ну не очень понятно как-то странно
[27:27.920 --> 27:29.920]  сейчас зачем нам две лямбда функции одного типа
[27:31.920 --> 27:32.920]  ээээ
[27:33.920 --> 27:40.920]  ну тут скорее вопрос не зачем нам две лямбда функции одного типа нам то может быть много зачем ну как типа ну у тебя может быть
[27:41.920 --> 27:45.920]  у них поля разные ну как они могут иметь
[27:46.920 --> 27:52.920]  ну это стейтфул лямбда это же стейтфул объекты у них у каждого есть свое поле у каждой есть какие-то данные
[27:53.920 --> 28:00.920]  если у тебя есть функция в которой хранятся какие-то данные она когда вычисляется что-то с этими данными делает вообще говоря
[28:00.920 --> 28:06.920]  у тебя может быть много таких этих функторов которые каждый в своем состоянии находится
[28:07.920 --> 28:16.920]  как раз как раз если у тебя есть как раз если есть захват то осмысленно иметь ну легко придумать сценарий в котором может быть осмысленно иметь много
[28:17.920 --> 28:23.920]  лямбда функции одинакового типа потому что они с состоянием они стейтфул у них есть у каждой какое-то поле
[28:24.920 --> 28:27.920]  которая что-то хранит и говорит о состоянии текущей лямбда функции сейчас
[28:27.920 --> 28:32.920]  разве ты еще не сказал что если у них есть захват тогда тут нельзя сделать
[28:33.920 --> 28:37.920]  нельзя по умолчанию создавать но так можно я могу копию создать
[28:38.920 --> 28:39.920]  вот
[28:40.920 --> 28:44.920]  кстати начиная си плюс плюс двадцать я могу даже так написать
[28:49.920 --> 28:51.920]  типа он умеет с мелькалявными кастовать?
[28:51.920 --> 28:52.920]  нет
[28:53.920 --> 28:58.920]  не не не я не могу написать вот так и в два равно f это мы выясняли в прошлый раз так сейчас
[28:59.920 --> 29:04.920]  вот если я так напишу это будет ce потому что у этих лямб это разные типы вообще-то
[29:05.920 --> 29:12.920]  это ну даже даже если здесь было бы еще раз вот если здесь было бы одинаково если бы код был абсолютно идентичный
[29:13.920 --> 29:18.920]  это бы все равно не работало потому что разные классы да ну и что что код одинаковый компилятор два разных класса сгенерирует
[29:18.920 --> 29:21.920]  но начиная си плюс плюс двадцать я могу вот так написать
[29:26.920 --> 29:29.920]  ну это си плюс 17 сейчас я двадцатый выберу
[29:30.920 --> 29:35.920]  в си плюс плюс 17 нельзя было писать лямбду в аннуэлэйтинг контексте мы это обсуждали в прошлый раз
[29:36.920 --> 29:40.920]  а еще не было конструктора по умолчанию а вот си плюс плюс двадцать так можно
[29:41.920 --> 29:47.920]  и это кстати приводит к интересному следствию вместо того чтобы в мэп вот вам нужно мэп завести
[29:51.920 --> 29:57.920]  вам можно не создавать объекты писать декл тайпа вам можно сразу написать декл тайп вот здесь и лямбду
[30:00.920 --> 30:03.920]  ну то есть вот здесь вот вам же не нужно
[30:03.920 --> 30:09.920]  ну вы можете просто вот так написать и все и это лямбда будет использоваться как компаратор в мэпе
[30:10.920 --> 30:15.920]  вам нужно тип указать компаратора но он сам сможет создать объект этого компаратора там внутри себя
[30:16.920 --> 30:17.920]  вот
[30:18.920 --> 30:22.920]  ладно дальше можно ли присваивать
[30:23.920 --> 30:27.920]  вот я сказал декл тайп от f f2 равно f
[30:28.920 --> 30:32.920]  теперь хочу присвоить f равно f2 можно ли присваивать
[30:33.920 --> 30:35.920]  хотелось почему нет
[30:36.920 --> 30:41.920]  ну да если нет захвата то можно но есть захват поэтому нельзя
[30:42.920 --> 30:45.920]  ну потому что сейчас он не умеет кастовать
[30:46.920 --> 30:52.920]  потому что да потому что опять есть не дефолтный конструктор копирования
[30:53.920 --> 30:59.920]  и значит копия signet-оператор implicitly-deleted ну это логично считается что
[30:59.920 --> 31:04.920]  у нас есть не дефолтный конструктор и для таких лямбд мы типа
[31:05.920 --> 31:07.920]  ну компилятор считает что мы не должны генерировать
[31:08.920 --> 31:09.920]  а
[31:10.920 --> 31:14.920]  signet-оператор но если бы не было захвата опять
[31:15.920 --> 31:17.920]  то это должно нормально работать
[31:20.920 --> 31:24.920]  вот если без захвата то пожалуйста присваивайте
[31:25.920 --> 31:27.920]  вот
[31:28.920 --> 31:31.920]  ну и что еще
[31:33.920 --> 31:35.920]  а
[31:36.920 --> 31:38.920]  а вот кстати еще пример хороший
[31:39.920 --> 31:41.920]  представьте что у меня такая вещь
[31:44.920 --> 31:47.920]  std-unique-ptr на int
[31:48.920 --> 31:52.920]  u от new int от 5
[31:52.920 --> 31:57.920]  и я тут говорю
[31:58.920 --> 32:01.920]  u равно std ну понятно что так я не смогу написать
[32:02.920 --> 32:04.920]  всем понятно что так я не смогу написать будет ce
[32:07.920 --> 32:09.920]  кому понятно почему вот это ce
[32:10.920 --> 32:12.920]  unique-ptr нельзя копировать
[32:13.920 --> 32:15.920]  но я могу написать вот так
[32:16.920 --> 32:18.920]  я могу в лямбду move-нуть
[32:19.920 --> 32:21.920]  ну у меня может быть какая-то штука
[32:22.920 --> 32:27.920]  которая в лямбду у меня может быть объект который move-only объект
[32:28.920 --> 32:30.920]  и я могу его захватить в лямбду посредством move-а
[32:31.920 --> 32:32.920]  тогда я могу
[32:33.920 --> 32:35.920]  ну я могу в этой лямбде его использовать
[32:36.920 --> 32:38.920]  я могу сказать x-звездочка u например
[32:39.920 --> 32:40.920]  y-звездочка u
[32:41.920 --> 32:42.920]  но
[32:42.920 --> 32:43.920]  но
[32:44.920 --> 32:46.920]  что будет если я вот так попытаюсь написать
[32:47.920 --> 32:48.920]  а тут опять будет ce
[32:49.920 --> 32:51.920]  потому что эта лямбда уже некопируемая
[32:52.920 --> 32:54.920]  потому что в ней есть поле unique-ptr
[32:57.920 --> 32:59.920]  no member unique-ptr
[33:00.920 --> 33:02.920]  include memory
[33:04.920 --> 33:06.920]  вот такая лямбда уже некопируемая потому что
[33:07.920 --> 33:08.920]  в ней есть поле
[33:09.920 --> 33:11.920]  unique-ptr
[33:13.920 --> 33:15.920]  copy-constructor of
[33:16.920 --> 33:18.920]  вот это is implicit deleted because вот такое
[33:19.920 --> 33:21.920]  поле has deleted copy-constructor очень информативно
[33:22.920 --> 33:23.920]  вот
[33:24.920 --> 33:25.920]  но
[33:26.920 --> 33:28.920]  вот так я могу сделать
[33:29.920 --> 33:31.920]  ну должен быть по крайней мере
[33:32.920 --> 33:34.920]  move-ать лямбду мне по идее никто не мешает
[33:35.920 --> 33:37.920]  вот пожалуйста move-ать лямбду можно
[33:38.920 --> 33:40.920]  такую то есть я забрал из той лямбды
[33:40.920 --> 33:42.920]  ее поля и
[33:43.920 --> 33:45.920]  соответственно если теперь я вызову f
[33:47.920 --> 33:49.920]  вот если я сейчас запущу код
[33:50.920 --> 33:51.920]  то что будет
[33:52.920 --> 33:54.920]  мы упадем в рантайме конечно же
[33:55.920 --> 33:56.920]  какое ce откуда ce
[33:57.920 --> 33:58.920]  я move-нул из
[33:59.920 --> 34:00.920]  и что
[34:01.920 --> 34:02.920]  move-нутый объект валиден
[34:03.920 --> 34:05.920]  я move-нул поле теперь по unique-ptr
[34:06.920 --> 34:08.920]  лежит null-ptr но он корректен
[34:08.920 --> 34:10.920]  обращение к move-нутому объекту это не ошибка
[34:11.920 --> 34:12.920]  компиляции
[34:13.920 --> 34:14.920]  и даже не runtime-error
[34:15.920 --> 34:16.920]  обращаться к move-нутому объекту корректно
[34:17.920 --> 34:18.920]  но просто move-нутый unique-ptr
[34:19.920 --> 34:20.920]  нельзя разыминовывать
[34:21.920 --> 34:22.920]  он null-ptr
[34:23.920 --> 34:24.920]  поэтому если я сейчас это запущу
[34:25.920 --> 34:26.920]  то я упаду из-за того что обращаюсь к move-нутому unique-ptr
[34:27.920 --> 34:28.920]  который там в полях остался
[34:29.920 --> 34:30.920]  ну разыминовываю
[34:31.920 --> 34:32.920]  а под ним null-ptr
[34:33.920 --> 34:35.920]  есть ли здесь утечка памяти
[34:36.920 --> 34:37.920]  в этом коде
[34:39.920 --> 34:40.920]  ну нет конечно
[34:41.920 --> 34:42.920]  разумеется нет потому что unique-ptr
[34:43.920 --> 34:44.920]  освобождается сам когда все
[34:45.920 --> 34:46.920]  когда уничтожается
[34:47.920 --> 34:48.920]  когда f2 уничтожается
[34:51.920 --> 34:52.920]  ну f2 вызовет сейчас корректно
[34:53.920 --> 34:54.920]  когда f2 уничтожается
[35:01.920 --> 35:02.920]  кстати запустить то здесь можно хоть
[35:03.920 --> 35:04.920]  похоже нельзя
[35:09.920 --> 35:10.920]  ладно да здесь нельзя запускать код
[35:11.920 --> 35:12.920]  ну очень жаль
[35:13.920 --> 35:14.920]  ну в принципе мне от cpp-insights
[35:15.920 --> 35:16.920]  больше ничего и не надо сегодня
[35:17.920 --> 35:18.920]  я думаю
[35:19.920 --> 35:20.920]  вот
[35:21.920 --> 35:22.920]  давайте я создам файл
[35:23.920 --> 35:24.920]  closures cpp
[35:25.920 --> 35:26.920]  и сюда скопи пащу
[35:27.920 --> 35:28.920]  и посмотрим что будет реально
[35:35.920 --> 35:36.920]  вот все скомпилировалось
[35:36.920 --> 35:37.920]  здесь ноль
[35:38.920 --> 35:39.920]  почему ноль
[35:40.920 --> 35:41.920]  ну потому что действительно двойка
[35:42.920 --> 35:43.920]  ближе к пяти чем один
[35:44.920 --> 35:45.920]  если я здесь делаю один
[35:46.920 --> 35:47.920]  если я здесь вызову вот это f
[35:48.920 --> 35:49.920]  то я сейчас упаду
[35:50.920 --> 35:51.920]  потому что разыминовал null-ptr
[35:54.920 --> 35:55.920]  вот
[35:56.920 --> 35:57.920]  короче лямбды это
[36:00.920 --> 36:01.920]  не могу сказать что это сложно
[36:02.920 --> 36:03.920]  но это требует аккуратности
[36:04.920 --> 36:05.920]  когда вы их используете
[36:07.920 --> 36:08.920]  а так
[36:18.920 --> 36:19.920]  тип вот этого поля
[36:22.920 --> 36:23.920]  ну он автоматически выводит
[36:24.920 --> 36:25.920]  как если бы я
[36:26.920 --> 36:27.920]  написал авто у равно sdm-u
[36:28.920 --> 36:29.920]  ну это то есть уник-ptr будет
[36:33.920 --> 36:34.920]  если бы я так написал
[36:34.920 --> 36:35.920]  он бы выводил как если бы
[36:36.920 --> 36:37.920]  я сказал авто амперсанту у равно sdm-u в ату
[36:38.920 --> 36:39.920]  то есть это было бы ce
[36:40.920 --> 36:41.920]  потому что
[36:42.920 --> 36:43.920]  lvl-reference инициализируется lvl
[36:45.920 --> 36:46.920]  кстати
[36:47.920 --> 36:48.920]  что если вот так написать
[37:00.920 --> 37:01.920]  а давайте подумаем что будет
[37:02.920 --> 37:03.920]  ты там зря отвлекся
[37:04.920 --> 37:05.920]  очень интересный пример
[37:06.920 --> 37:07.920]  вот так
[37:08.920 --> 37:09.920]  Денис Васюк значит
[37:10.920 --> 37:11.920]  ты зря это пример
[37:12.920 --> 37:13.920]  мне кажется тебя должен порадовать
[37:15.920 --> 37:16.920]  вы знаете у нас каждый год
[37:17.920 --> 37:18.920]  каждый год
[37:20.920 --> 37:21.920]  вот
[37:22.920 --> 37:23.920]  к концу года остается немного человек
[37:24.920 --> 37:25.920]  которые активно следят за происходящими
[37:26.920 --> 37:27.920]  со мной разговаривают
[37:28.920 --> 37:29.920]  и обязательно вот каждый год есть
[37:29.920 --> 37:30.920]  человек который очень эмоционально
[37:31.920 --> 37:32.920]  реагирует на все происходящее
[37:33.920 --> 37:34.920]  вот в прошлом году
[37:35.920 --> 37:36.920]  был один такой человек
[37:37.920 --> 37:38.920]  вот в этом году видимо эта роль
[37:39.920 --> 37:40.920]  достается тебе мне очень надо чтобы
[37:41.920 --> 37:42.920]  ты ходил на оставшиеся лекции
[37:43.920 --> 37:44.920]  потому что
[37:45.920 --> 37:46.920]  мне нужны чьи-то восторженные
[37:47.920 --> 37:48.920]  комментарии от того что нам предстоит
[37:51.920 --> 37:52.920]  лекции иначе будут скучными
[37:54.920 --> 37:55.920]  мне нужна какая-то
[37:56.920 --> 37:57.920]  аудитория которая бы
[37:59.920 --> 38:00.920]  ну по идее ничего не произойдет
[38:01.920 --> 38:02.920]  ну в смысле все будет нормально
[38:03.920 --> 38:04.920]  хотелось бы чтобы мы умерли в этот момент
[38:05.920 --> 38:06.920]  по ЗАЕ
[38:07.920 --> 38:08.920]  ну типа так
[38:09.920 --> 38:10.920]  ты ему кажется мы урем
[38:11.920 --> 38:12.920]  нет типа кастэлвэльюсюки
[38:13.920 --> 38:14.920]  затем кастэлконстэлвэльюсюки
[38:15.920 --> 38:16.920]  как это вообще будет происходить
[38:19.920 --> 38:20.920]  ну что такое эсконст
[38:22.920 --> 38:23.920]  тут надо подумать о том что такое эсконст
[38:24.920 --> 38:25.920]  так сейчас я
[38:26.920 --> 38:27.920]  открою
[38:27.920 --> 38:28.920]  да да да я
[38:29.920 --> 38:30.920]  специально отрубился чтобы
[38:35.920 --> 38:36.920]  чтобы не палить поисковую строку браузера
[38:37.920 --> 38:38.920]  да а то там
[38:39.920 --> 38:40.920]  всякие вещи
[38:41.920 --> 38:42.920]  будут на видео записаны
[38:43.920 --> 38:44.920]  у меня кстати интернет опять не работает
[38:45.920 --> 38:46.920]  что за дела
[38:47.920 --> 38:48.920]  да ладно на записи мы
[38:49.920 --> 38:50.920]  остановили на минутку
[38:51.920 --> 38:52.920]  потом продолжили
[38:53.920 --> 38:54.920]  сейчас придется себе
[38:55.920 --> 38:56.920]  раздавать интернет конечно
[38:57.920 --> 38:58.920]  ну вот
[38:59.920 --> 39:00.920]  работал перестал
[39:03.920 --> 39:05.920]  а может это просто cpp референс лежит
[39:06.920 --> 39:08.920]  вот это неловкая ситуация будет если это так
[39:09.920 --> 39:10.920]  а нет
[39:11.920 --> 39:12.920]  нет
[39:12.920 --> 39:14.920]  подождите у меня лежит cpp референс кажется
[39:18.920 --> 39:20.920]  а то есть проблема не в интернете
[39:21.920 --> 39:22.920]  то есть мы не можем открыть cpp референс
[39:23.920 --> 39:24.920]  ну вот
[39:24.920 --> 39:25.920]  а то есть проблема не в интернете
[39:26.920 --> 39:27.920]  то есть мы не можем открыть cpp референс
[39:28.920 --> 39:29.920]  класс
[39:31.920 --> 39:32.920]  а так
[39:33.920 --> 39:34.920]  хорошо тогда мы попробуем по-другому
[39:35.920 --> 39:36.920]  черт
[39:37.920 --> 39:38.920]  все лекция закончена
[39:39.920 --> 39:40.920]  не не не не
[39:41.920 --> 39:42.920]  сейчас мы сейчас мы сделаем хитрее
[39:43.920 --> 39:44.920]  сейчас я вас научу лайфхаком
[39:45.920 --> 39:46.920]  давайте попробуем вот так
[39:47.920 --> 39:48.920]  у меня он подал признаки жизни
[39:50.920 --> 39:51.920]  и где-то по пути закончилась
[39:52.920 --> 39:54.920]  да давайте вот так сделаем
[39:55.920 --> 39:57.920]  я думаю что
[39:58.920 --> 40:00.920]  да если вы не знаете
[40:01.920 --> 40:03.920]  очень рекомендую всем
[40:04.920 --> 40:05.920]  всем
[40:06.920 --> 40:07.920]  айтишникам просто в порядке
[40:08.920 --> 40:09.920]  обязательно нужно знать эту вещь
[40:10.920 --> 40:11.920]  а прекрасно
[40:12.920 --> 40:13.920]  got 301 response от crawl-time
[40:14.920 --> 40:15.920]  замечательно
[40:16.920 --> 40:17.920]  давайте попробуем какой-нибудь другой день
[40:22.920 --> 40:23.920]  тоже мы не можем
[40:24.920 --> 40:25.920]  хорошо а вот здесь что было
[40:26.920 --> 40:27.920]  может быть здесь мы можем
[40:34.920 --> 40:35.920]  класс
[40:36.920 --> 40:37.920]  замечательно
[40:38.920 --> 40:39.920]  короче мы не можем открыть cpp референс
[40:40.920 --> 40:41.920]  очень жаль
[40:42.920 --> 40:43.920]  ну
[40:44.920 --> 40:45.920]  да вообще если cpp референс не работает
[40:46.920 --> 40:47.920]  то конечно печально
[40:48.920 --> 40:49.920]  потому что
[40:49.920 --> 40:50.920]  ладно у нас есть у нас есть аналоги
[40:51.920 --> 40:52.920]  у нас есть cpp референс дома
[40:53.920 --> 40:54.920]  смотрите у нас же есть сайт c++.com
[40:55.920 --> 40:56.920]  кто c++.com
[40:57.920 --> 40:58.920]  вот
[40:59.920 --> 41:00.920]  давайте
[41:01.920 --> 41:02.920]  мм
[41:04.920 --> 41:05.920]  воспользуемся им
[41:06.920 --> 41:07.920]  да
[41:08.920 --> 41:09.920]  вот
[41:10.920 --> 41:11.920]  давайте
[41:12.920 --> 41:13.920]  мм
[41:14.920 --> 41:15.920]  воспользуемся им
[41:16.920 --> 41:17.920]  да
[41:17.920 --> 41:18.920]  правда
[41:19.920 --> 41:20.920]  правда
[41:21.920 --> 41:22.920]  почему-то
[41:23.920 --> 41:24.920]  правда
[41:25.920 --> 41:26.920]  правда правда
[41:27.920 --> 41:28.920]  правда
[41:29.920 --> 41:30.920]  к сожалению
[41:31.920 --> 41:32.920]  он не такой удобный
[41:33.920 --> 41:34.920]  ару
[41:35.920 --> 41:36.920]  кто не знал что есть сайт cpp
[41:37.920 --> 41:38.920]  dps-reference.ru
[41:39.920 --> 41:40.920]  так
[41:41.920 --> 41:42.920]  может быть cpp референс ru работает
[41:43.920 --> 41:44.920]  так ладно короче не хочу этим заниматься
[41:45.920 --> 41:46.920]  не работает так не работает
[41:47.920 --> 41:48.920]  в общем
[41:49.920 --> 41:50.920]  в общем это
[41:51.920 --> 41:52.920]  кажется
[41:53.920 --> 41:54.920]  должно компилироваться
[41:55.920 --> 41:56.920]  правда делать какую-то ерунду
[41:57.920 --> 41:58.920]  ну то есть что я сейчас сделал
[41:59.920 --> 42:00.920]  я как бы сделал
[42:01.920 --> 42:02.920]  константную ссылку на
[42:03.920 --> 42:04.920]  rvlu
[42:05.920 --> 42:06.920]  ссылку
[42:07.920 --> 42:08.920]  ура
[42:09.920 --> 42:10.920]  ааа
[42:11.920 --> 42:12.920]  кстати
[42:13.920 --> 42:14.920]  вот на cpp референс написано что
[42:15.920 --> 42:16.920]  вариант с туманперсандами он просто
[42:17.920 --> 42:18.920]  а ну тогда это все объясняет
[42:19.920 --> 42:20.920]  то есть он просто
[42:21.920 --> 42:22.920]  да поэтому я хотел сказать тебе референс
[42:23.920 --> 42:24.920]  значит там просто закостылено что если мы rvlu ссылки вызываемся то
[42:25.920 --> 42:26.920]  падай
[42:27.920 --> 42:28.920]  ну потому что не надо так делать
[42:29.920 --> 42:30.920]  ну я в принципе согласен да
[42:31.920 --> 42:32.920]  ладно
[42:33.920 --> 42:34.920]  вообще это должно работать теоретически
[42:35.920 --> 42:36.920]  ааа
[42:37.920 --> 42:38.920]  в целом все вроде что я хотел рассказать про
[42:39.920 --> 42:40.920]  closures s-objects
[42:41.920 --> 42:42.920]  нет
[42:43.920 --> 42:44.920]  сейчас кстати
[42:45.920 --> 42:46.920]  а в чем проблема вот этого вот
[42:47.920 --> 42:48.920]  константную ссылку
[42:49.920 --> 42:50.920]  на временный объект
[42:51.920 --> 42:52.920]  почему бы не разрешить
[42:53.920 --> 42:54.920]  rvlu ссылку кастовать
[42:55.920 --> 42:56.920]  в константную lp
[42:57.920 --> 42:58.920]  ну что в этом плохом
[42:59.920 --> 43:00.920]  я не знаю у меня нет ответа
[43:01.920 --> 43:02.920]  почему они это запретили я не знаю
[43:03.920 --> 43:04.920]  ну вот запретили
[43:05.920 --> 43:06.920]  ну понятно что если я просто
[43:07.920 --> 43:08.920]  статик касс бы написал то это бы сработало
[43:09.920 --> 43:10.920]  так
[43:11.920 --> 43:12.920]  да еще один маленький вопросик
[43:13.920 --> 43:14.920]  последний
[43:14.920 --> 43:15.920]  смотрите
[43:16.920 --> 43:19.920]  вот вы теперь понимаете что если я напишу
[43:20.920 --> 43:21.920]  sizeof
[43:22.920 --> 43:24.920]  мне надо что-нибудь вернуть как было
[43:27.920 --> 43:28.920]  вот я могу здесь написать
[43:29.920 --> 43:30.920]  например sizeof
[43:31.920 --> 43:32.920]  ну я могу например спросить
[43:33.920 --> 43:34.920]  sizeof от
[43:36.920 --> 43:37.920]  f
[43:40.920 --> 43:41.920]  вы понимаете что это значит
[43:41.920 --> 43:42.920]  вы понимаете теперь
[43:43.920 --> 43:44.920]  должны сколько это будет
[43:45.920 --> 43:46.920]  размер u
[43:47.920 --> 43:48.920]  да вам просто выяснится размер u
[43:49.920 --> 43:50.920]  то есть
[43:51.920 --> 43:52.920]  каков размер объекта лямбды
[43:53.920 --> 43:54.920]  это кстати непраздный вопрос
[43:55.920 --> 43:56.920]  когда вы лямбду куда-нибудь передаете
[43:57.920 --> 43:58.920]  в качестве параметра
[43:59.920 --> 44:00.920]  в функцию
[44:01.920 --> 44:02.920]  вам нужно понимать а размер самого объекта лямбды
[44:03.920 --> 44:04.920]  он какой вот лямбду
[44:05.920 --> 44:06.920]  если куда-то передаете лучше по значению или по ссылке
[44:07.920 --> 44:08.920]  передать
[44:09.920 --> 44:10.920]  вот и кстати говоря
[44:11.920 --> 44:14.920]  к вопросу еще о том зачем может быть нужно копировать лямбды
[44:15.920 --> 44:17.920]  да если вы лямбду саму как объект куда-то хотите
[44:18.920 --> 44:19.920]  передать в другую функцию
[44:20.920 --> 44:21.920]  по значению или по ссылке
[44:22.920 --> 44:23.920]  вам как действовать
[44:24.920 --> 44:25.920]  вот
[44:26.920 --> 44:27.920]  если лямбда ничего не захватывает то ее sizeof это просто 1
[44:28.920 --> 44:29.920]  если я допустим в лямбду захватил 1 int
[44:30.920 --> 44:31.920]  то ее размер был бы 4
[44:32.920 --> 44:33.920]  а если я захватил ссылку на int
[44:34.920 --> 44:35.920]  то ее размер был бы 8
[44:36.920 --> 44:37.920]  то есть захвачу int по значению будет размер 4
[44:38.920 --> 44:39.920]  захвачу int по ссылке будет размер 8
[44:39.920 --> 44:41.920]  ну и понятно что размер лямбды он как
[44:42.920 --> 44:43.920]  ну опять как сумма
[44:44.920 --> 44:45.920]  ну то есть просто размер объекта
[44:46.920 --> 44:47.920]  вот сейчас размер лямбды будет
[44:48.920 --> 44:49.920]  таков каков размер Unique PTR
[44:50.920 --> 44:51.920]  а кстати каков размер Unique PTR
[44:56.920 --> 44:58.920]  8 ну 0 это второе
[44:59.920 --> 45:02.920]  да размер Unique PTR 8 почему 8
[45:03.920 --> 45:04.920]  сначала страшно стало
[45:05.920 --> 45:07.920]  да Unique PTR в себе хранит всего лишь 1 pointer и все
[45:07.920 --> 45:08.920]  а как же дилитер
[45:10.920 --> 45:11.920]  дилитер у нас
[45:12.920 --> 45:14.920]  а он сооптимизирован через MTBase Optimization
[45:15.920 --> 45:17.920]  поэтому размер Unique PTR это всего лишь размер 1 pointer
[45:19.920 --> 45:20.920]  все
[45:21.920 --> 45:22.920]  вот дальше
[45:23.920 --> 45:25.920]  давайте теперь поговорим вот о какой штуке
[45:26.920 --> 45:27.920]  еще один пункт
[45:28.920 --> 45:29.920]  раньше это не выделял отдельным пунктом
[45:30.920 --> 45:35.920]  но сейчас выделю в связи с тем что в c++20 появилось кое-что более интересное
[45:36.920 --> 45:37.920]  generic lambdas
[45:44.920 --> 45:45.920]  generic lambdas
[45:48.920 --> 45:49.920]  лямбды могут быть
[45:50.920 --> 45:51.920]  generic
[45:52.920 --> 45:53.920]  generic
[45:54.920 --> 45:55.920]  что такое generic
[45:56.920 --> 45:57.920]  java какой-то попахивает
[45:58.920 --> 45:59.920]  обобщенные лямбды это что
[46:00.920 --> 46:02.920]  ну я могу в лямбду принять авто
[46:05.920 --> 46:07.920]  я могу сказать авто f равно
[46:08.920 --> 46:09.920]  авто x
[46:10.920 --> 46:11.920]  авто y
[46:12.920 --> 46:14.920]  return x меньше y
[46:16.920 --> 46:18.920]  f от 1 2 опять сказать
[46:21.920 --> 46:23.920]  ну извините что я все время вывожу
[46:24.920 --> 46:28.920]  используя этот пример ну просто он самый простой и на нем все можно продемонстрировать вот
[46:29.920 --> 46:34.920]  все ну в общем-то тут и говорить то почти не о чем было бы если бы не
[46:36.920 --> 46:39.920]  вопрос а как это работает вот у кого сейчас
[46:40.920 --> 46:43.920]  вызывает вопросики эта конструкция
[46:44.920 --> 46:45.920]  если у вас сейчас
[46:46.920 --> 46:49.920]  вот нет у вас сейчас ощущения типа а как
[46:50.920 --> 46:54.920]  какая магия как это работает какой тип uef вообще что это такое
[46:55.920 --> 46:58.920]  как это вообще может работать у вас нет такого вопроса в голове
[46:59.920 --> 47:01.920]  я не верю что мы когда вызываем то сдавляем
[47:01.920 --> 47:03.920]  это что это шаблон
[47:04.920 --> 47:06.920]  если делается локальный шаблонный класс
[47:07.920 --> 47:09.920]  это что с тигом uef
[47:10.920 --> 47:12.920]  не в смысле просто шаблонный круглый
[47:13.920 --> 47:14.920]  да
[47:15.920 --> 47:17.920]  на самом деле f это не шаблон
[47:18.920 --> 47:23.920]  оператор круглой скобки в ней шаблон то есть сама по себе f это не сама по себе f не шаблонного типа
[47:24.920 --> 47:26.920]  поэтому объект f
[47:27.920 --> 47:28.920]  он
[47:28.920 --> 47:30.920]  никакими трудными проблемами не обладает
[47:31.920 --> 47:32.920]  переференцов жил
[47:34.920 --> 47:35.920]  давайте попробуем
[47:50.920 --> 47:52.920]  по моему он еще у меня работал недавно
[47:55.920 --> 47:56.920]  пару часов назад
[47:58.920 --> 47:59.920]  а
[48:10.920 --> 48:12.920]  ну на пинг отвечает
[48:16.920 --> 48:18.920]  ай ладно у меня не установлен
[48:19.920 --> 48:20.920]  а
[48:21.920 --> 48:24.920]  да короче это просто шаблонный оператор круглой скобки
[48:24.920 --> 48:29.920]  просто шаблонный оператор так я извимо должен уметь так копировать же правда
[48:30.920 --> 48:32.920]  давайте я попробую это сюда скопи пастить
[48:34.920 --> 48:37.920]  нет так не работает копирование извимо к сожалению
[48:39.920 --> 48:40.920]  x клип у меня тоже не установлен
[48:41.920 --> 48:44.920]  ну в общем ладно вы мне поверите что это просто шаблонный оператор круглой скобки
[48:45.920 --> 48:46.920]  а
[48:47.920 --> 48:49.920]  конечно же я могу вот так написать например
[48:54.920 --> 48:59.920]  тогда будет шаблонный оператор круглой скобки который принимает ссылки тогда это уже не скомпилируется
[49:01.920 --> 49:02.920]  понятно почему
[49:03.920 --> 49:05.920]  потому что опять таки
[49:07.920 --> 49:08.920]  так не то
[49:09.920 --> 49:11.920]  я не то я не то компилирую
[49:14.920 --> 49:19.920]  это не компилируется потому что я передаю rvalue по lvalue ссылки
[49:20.920 --> 49:21.920]  но если я здесь напишу
[49:21.920 --> 49:23.920]  const auto ampersand то это компилируется
[49:24.920 --> 49:25.920]  если я здесь напишу вот так
[49:27.920 --> 49:28.920]  то это тоже компилируется
[49:32.920 --> 49:33.920]  вот
[49:34.920 --> 49:39.920]  кстати вопрос вот этот оператор круглой скобки у него будет сколько шаблонных параметров
[49:40.920 --> 49:41.920]  два
[49:41.920 --> 49:44.920]  два конечно t и u то есть вот это разные типы вообще говоря
[49:45.920 --> 49:46.920]  я
[49:48.920 --> 49:49.920]  вот эта функция
[49:52.920 --> 49:55.920]  это будет не та же самая функция что функция двух интов
[49:57.920 --> 49:58.920]  вот
[49:59.920 --> 50:03.920]  если я сделаю f от 1 2 потом f от 1 2 0 будет это будут разные функции
[50:04.920 --> 50:05.920]  а
[50:07.920 --> 50:10.920]  что можно делать например
[50:11.920 --> 50:12.920]  используя такую штуку
[50:15.920 --> 50:16.920]  можно например
[50:21.920 --> 50:25.920]  в лямбды захватывает другие лямбды давайте я вам сейчас покажу пример один который мне
[50:26.920 --> 50:29.920]  довольно таки понравился вот смотрите вот у меня есть функция f
[50:30.920 --> 50:31.920]  которая
[50:31.920 --> 50:32.920]  ничего не принимает
[50:33.920 --> 50:34.920]  и просто делает
[50:41.920 --> 50:44.920]  печатает high я ее назову print high
[50:44.920 --> 50:51.920]  я могу сделать функтор ну то есть функцию над функцией
[50:52.920 --> 50:53.920]  которая
[50:54.920 --> 50:55.920]  что я себя буду представлять
[50:55.920 --> 51:02.920]  да то есть смотрите я могу сделать функцию над функцию от функции которая
[51:03.920 --> 51:04.920]  принимает функцию
[51:04.920 --> 51:06.920]  и возвращает другую функцию
[51:11.920 --> 51:12.920]  и
[51:13.920 --> 51:14.920]  и
[51:15.920 --> 51:16.920]  и
[51:17.920 --> 51:18.920]  и
[51:19.920 --> 51:20.920]  и
[51:21.920 --> 51:22.920]  и
[51:23.920 --> 51:24.920]  и
[51:25.920 --> 51:26.920]  ну то есть
[51:26.920 --> 51:29.920]  нет сейчас do twice от f это
[51:30.920 --> 51:32.920]  да это просто два раза вызвать f
[51:33.920 --> 51:34.920]  вот но я могу
[51:35.920 --> 51:36.920]  сделать
[51:38.920 --> 51:39.920]  штуку которая
[51:43.920 --> 51:44.920]  возвращает мне
[51:49.920 --> 51:50.920]  функцию
[51:50.920 --> 51:55.920]  это что это что питон
[51:56.920 --> 51:59.920]  смотрите я
[52:00.920 --> 52:01.920]  сейчас написал функцию
[52:02.920 --> 52:05.920]  которая принимает функцию и возвращает функцию
[52:06.920 --> 52:07.920]  а
[52:12.920 --> 52:13.920]  и теперь могу сказать
[52:20.920 --> 52:30.920]  нормально то есть я взял
[52:31.920 --> 52:34.920]  ну да тут какая-то ерунда
[52:35.920 --> 52:38.920]  вот давайте я попробую вызвать print high high
[52:39.920 --> 52:41.920]  print high high это значит
[52:42.920 --> 52:43.920]  callable
[52:43.920 --> 52:44.920]  вызываемый объект
[52:45.920 --> 52:46.920]  а ну да
[52:46.920 --> 52:47.920]  а ну да
[52:48.920 --> 52:50.920]  вот давайте проверим что это работает
[52:51.920 --> 52:54.920]  может очень забыл нет все работает и действительно получается high high
[52:57.920 --> 52:59.920]  вот почему по rvlu ссылке
[53:00.920 --> 53:01.920]  ну
[53:06.920 --> 53:09.920]  можно было бы и по значению в принципе это тоже бы работало
[53:10.920 --> 53:12.920]  но rvlu ссылка она более универсальная
[53:12.920 --> 53:14.920]  потому что не любая функция копируется
[53:15.920 --> 53:17.920]  не любой объект копируется а тут вот
[53:20.920 --> 53:21.920]  вот
[53:21.920 --> 53:22.920]  такие дела
[53:24.920 --> 53:27.920]  а если там авто два амперсанта мы передаем
[53:28.920 --> 53:29.920]  какую-то
[53:30.920 --> 53:31.920]  ссылку
[53:32.920 --> 53:33.920]  какую ссылку
[53:34.920 --> 53:38.920]  ну авто два амперсанта это универсальная ссылка работает по правилам вывода универсальных ссылок
[53:43.920 --> 53:44.920]  вот
[53:45.920 --> 53:49.920]  я кстати мог бы здесь и вот так написать наверное это бы тоже сработало
[54:00.920 --> 54:02.920]  так вы поняли все этот пример
[54:03.920 --> 54:04.920]  чего
[54:07.920 --> 54:11.920]  можно авто ну в данном случае да потому что print high она ничего не
[54:15.920 --> 54:16.920]  что еще раз
[54:18.920 --> 54:22.920]  ну все тоже будет нормально здесь не важно как принять хоть с одним амперсантом хоть с двумя
[54:33.920 --> 54:38.920]  в смысле захвата вот здесь вот захватится ли копия или захватится ссылка это кстати интересный вопрос
[54:45.920 --> 54:46.920]  я думаю что копия
[54:49.920 --> 54:53.920]  я думаю что копия захватится потому что все равно вы как если бы авто
[54:54.920 --> 54:55.920]  ну передаете в конструктор
[54:56.920 --> 54:57.920]  без амперсантов передаете
[54:57.920 --> 55:00.920]  ну в нашем примере это не важно потому что будет работать в любом случае
[55:04.920 --> 55:07.920]  можно кстати посмотреть на c++ insight да на cpp insights
[55:08.920 --> 55:14.920]  ну давайте вы это сами сделайте потому что уже мы долго сидим на этом не очень стоит вот
[55:17.920 --> 55:22.920]  ладно это generic лямбны понятно что генерируется шаблонный оператор круглой скобки
[55:22.920 --> 55:28.920]  также понятно что generic лямбны уже к function pointer не кастится потому что тоже непонятно к какому кастить
[55:29.920 --> 55:31.920]  что какой тип у function pointer должен быть непонятно
[55:34.920 --> 55:35.920]  вот
[55:40.920 --> 55:43.920]  как template type-name-t type-name-u оператор
[55:43.920 --> 55:46.920]  как template type-name-t type-name-u оператор
[55:47.920 --> 55:48.920]  что ты
[55:55.920 --> 55:56.920]  ну вот
[56:00.920 --> 56:03.920]  кажется нет кажется так не должен не будет работать
[56:03.920 --> 56:06.920]  слушайте не знаю может он и генерирует такой оператор
[56:07.920 --> 56:10.920]  сейчас то есть нам надо будет тогда просто по идее
[56:11.920 --> 56:12.920]  а может кстати генерирует и правда
[56:13.920 --> 56:17.920]  ну тогда нам нужно явно ему будет передать шаблонные параметры кстати говоря
[56:19.920 --> 56:24.920]  давайте попробуем ладно я вот отсюда извимо я не умею как это делать
[56:25.920 --> 56:26.920]  ну вот
[56:27.920 --> 56:34.920]  давайте попробуем ладно я вот отсюда извимо я не умею копировать но отсюда я должен суметь копировать
[56:37.920 --> 56:42.920]  сейчас давайте я попробую давайте посмотрим что cppinsight мне скажет
[56:51.920 --> 56:54.920]  так ну вот это лямбда которая print high она неинтересная
[56:54.920 --> 57:08.920]  дальше лямбда которая do twice лямбда 11 21 вот у нее есть параметр шаблонный оператор круглой скобки отсылки на
[57:09.920 --> 57:18.920]  на объект внутри которого есть еще один локальный класс в котором есть оператор круглой скобки без параметров
[57:18.920 --> 57:19.920]  и уже нет полей
[57:24.920 --> 57:27.920]  кстати нет полей в нем заметьте что интересно
[57:32.920 --> 57:35.920]  он решил что они ему не нужны просто
[57:35.920 --> 57:41.920]  да вот это интересно почему он возможно потому что он не читает f локальной переменной там
[57:44.920 --> 57:49.920]  а так нельзя а так можно но полей он все равно не сделал
[57:52.920 --> 57:53.920]  сейчас покажу
[57:54.920 --> 57:55.920]  вот так вот
[57:55.920 --> 58:01.920]  ну как будто бы является но почему-то он решил как поле ее не добавлять к себе
[58:06.920 --> 58:07.920]  ну так ducking
[58:07.920 --> 58:15.920]  Илья, а правда ли, что f для внутренней лянды просто не является локальной переменной, поэтому не хватило?
[58:15.920 --> 58:25.920]  Ну как будто бы является, но почему-то он решил как поле ее не добавлять к себе.
[58:25.920 --> 58:35.920]  Ну я думаю, что компилятор имеет право делать преобразование кода, сохраняя эквивалентность так, чтобы там все наблюдаемое поведение не менялось.
[58:35.920 --> 58:49.920]  Не, ну кстати, это же плохо по идее. Мы же можем эти лянды вообще разделить друг от друга, и вот эта ссылка, она может там просрочиться или что-то такое.
[58:49.920 --> 58:54.920]  Ну, то есть по-хорошему он должен сохранять их значение.
[58:54.920 --> 59:00.920]  Давайте вот так попробуем написать. Может он действительно не считает ее локальной переменной и поэтому не захватил.
[59:00.920 --> 59:03.920]  Да, вот теперь захватил.
[59:03.920 --> 59:15.920]  Да, возможно у него такие же правила сработали, как и были с классом, что если эта штука является параметром функции, в которой мы сейчас находимся, то он ее тоже не считает локальной переменной и не захватывает.
[59:19.920 --> 59:22.920]  Что еще раз сработало, какие правила?
[59:22.920 --> 59:31.920]  Ну, потому что это как будто бы не локальная переменная, а параметр функции, в которой мы сейчас находимся.
[59:31.920 --> 59:36.920]  Это странно, потому что мне кажется, что она должна считаться локальной переменной, но почему-то он ее решил.
[59:36.920 --> 59:39.920]  А попробуем вместо F, Q, C.
[59:39.920 --> 59:47.920]  Давайте я не буду больше ничего пробовать. Мы пойдем дальше, потому что так можно очень долго на этом сидеть целый час и пробовать разные варианты.
[59:47.920 --> 59:49.920]  Ну, в общем...
[59:49.920 --> 01:00:02.920]  Мы добились того, чего хотели, это работает, а вот эти все сценарии, когда он что захватил, когда нет, это не очевидно, скажем так, и нужно себя перепроверять лишний раз.
[01:00:02.920 --> 01:00:06.920]  Вот видите, мы в очередной раз столкнулись с тем, что не очевидно, он захватил или не захватил.
[01:00:06.920 --> 01:00:11.920]  Да, открылся CP Reference. Отлично просто открылся. Смотрите, как прекрасно он открылся.
[01:00:11.920 --> 01:00:15.920]  Можно еще раз обновить страницу, может он сейчас нормально прогрузится?
[01:00:15.920 --> 01:00:17.920]  За я ответ сделал.
[01:00:17.920 --> 01:00:19.920]  Да качо.
[01:00:19.920 --> 01:00:22.920]  А, ну все, да.
[01:00:22.920 --> 01:00:29.920]  В лямбде еще можно захватывать переменное количество аргументов, если он в шаблоне, начиная с C++20, по-моему.
[01:00:29.920 --> 01:00:34.920]  Но это я не буду вам показывать, это уже на CP Reference сами увидите.
[01:00:34.920 --> 01:00:37.920]  Ну вот, еще чего?
[01:00:37.920 --> 01:00:39.920]  Переменное количество аргументов.
[01:00:39.920 --> 01:00:41.920]  Ну вот, еще чего?
[01:00:41.920 --> 01:00:43.920]  Переменное количество аргументов.
[01:00:43.920 --> 01:00:47.920]  Если мы в шаблонном методе, то можно здесь написать вот так, args.
[01:00:47.920 --> 01:00:52.920]  Если бы мы были в шаблонном методе, где args это пакет, то можно было бы распаковать пакет вот так.
[01:00:52.920 --> 01:00:54.920]  И можно было бы написать вот так.
[01:00:54.920 --> 01:00:58.920]  args равно std forward от args, от args.
[01:00:58.920 --> 01:01:00.920]  Ну вот.
[01:01:00.920 --> 01:01:02.920]  Ну вот.
[01:01:02.920 --> 01:01:07.920]  Начиная с C++20, лямбды могут быть шаблонными.
[01:01:07.920 --> 01:01:15.920]  То есть у нас могли быть до этого обобщенные лямбды, вот этот джинель к лямбды, которые принимают авто.
[01:01:15.920 --> 01:01:19.920]  Но начиная с C++20, лямбды могут быть шаблонными.
[01:01:19.920 --> 01:01:25.920]  То есть у нас могли быть обобщенные лямбды, вот этот джинель к лямбды, которые принимают авто.
[01:01:25.920 --> 01:01:29.920]  Но начиная с C++20, лямбды могут быть шаблонными.
[01:01:29.920 --> 01:01:31.920]  Принимают авто.
[01:01:31.920 --> 01:01:38.920]  Но начиная с C++20, мы можем просто явно назвать, какой t.
[01:01:43.920 --> 01:01:53.920]  И тогда мы можем в возвращаемом типе использовать что-то связанное с t.
[01:01:53.920 --> 01:02:00.920]  Ну например, я могу сказать std remove reference t от t.
[01:02:02.920 --> 01:02:04.920]  Вот.
[01:02:06.920 --> 01:02:08.920]  Вот.
[01:02:08.920 --> 01:02:17.920]  Ну, если бы мы с вами были в настоящем C++20, и если бы мы знали чуть побольше, то я бы сказал, для чего это может быть нужно.
[01:02:17.920 --> 01:02:22.920]  Это может быть нужно для того, чтобы requirements написать на t, ну, концепты использовать.
[01:02:22.920 --> 01:02:26.920]  Можно бы здесь потребовать, например, что t должно быть из Invocable.
[01:02:26.920 --> 01:02:30.920]  Но пока мы этого не умеем, поэтому пока я просто вот такой игрушечный пример покажу.
[01:02:30.920 --> 01:02:32.920]  Вот. Давайте проверим, что это работает.
[01:02:32.920 --> 01:02:34.920]  Да, что?
[01:02:34.920 --> 01:02:38.920]  Могли бы через tackle-type получить тип, написав tackle-type в маленькой?
[01:02:38.920 --> 01:02:44.920]  Но если бы у нас было написано авто вместо явного шаблона, мы могли бы через tackle-type получить тип?
[01:02:44.920 --> 01:02:46.920]  Могли бы, да.
[01:02:46.920 --> 01:02:52.920]  Ну, там, конечно, были бы проблемы с этими ссылочками там всякие там.
[01:02:52.920 --> 01:02:57.920]  Ну, надо было помнить, что он там иногда отбрасывает персанды, иногда не отбрасывает, вот эта вся история.
[01:02:57.920 --> 01:02:59.920]  Но вообще, да, могли бы.
[01:02:59.920 --> 01:03:02.920]  Ну, то есть, функционально ничего нового не добавилось.
[01:03:02.920 --> 01:03:04.920]  Ну, просто синтаксис появился более удобный.
[01:03:04.920 --> 01:03:06.920]  Обращаться к t.
[01:03:06.920 --> 01:03:10.920]  Так-то мы могли бы и сказать, что tackle-type от чего-то.
[01:03:10.920 --> 01:03:14.920]  Можно ли явно указывать шаблонные параметры каким-то образом?
[01:03:14.920 --> 01:03:16.920]  Когда лямду вызываешь?
[01:03:16.920 --> 01:03:21.920]  Да. Но если там написать, повторять, явно, оператор, круглые скобочки и еще.
[01:03:21.920 --> 01:03:23.920]  Ну, как функции?
[01:03:23.920 --> 01:03:25.920]  Вот, кстати, этого не знаю.
[01:03:33.920 --> 01:03:36.920]  Думаю, что нельзя, но не буду пробовать.
[01:03:37.920 --> 01:03:41.920]  Ну, нет, если ты оператор круглые скобочки вызываешь, то там, наверно, может.
[01:03:41.920 --> 01:03:46.920]  Ну типа, написать f.операции.
[01:03:46.920 --> 01:03:48.920]  В errado.
[01:03:48.920 --> 01:03:57.920]  Наверное, так можно, но просто f с круглыми скобочками, с угловыми скобочками так должно быть нельзя, потому что это не f шаблонный же, а оператор круглые скобочки в нем.
[01:03:57.920 --> 01:04:07.920]  Но я не уверен, это это все появилось совсем недавно, сейчас 20, может они такой возможности не добавили, добавили только, только эту.
[01:04:07.920 --> 01:04:16.920]  Вот, ну ладно. Все, про генерик лямбда я вроде все сказал, что хотел.
[01:04:16.920 --> 01:04:31.920]  Напоследок, нам сейчас надо, мы сейчас изучим один прекрасный класс, очень полезный и важный, как с точки зрения теории, так и с точки зрения практики.
[01:04:31.920 --> 01:04:44.920]  Вот мы дофига посмотрели разных возможностей функционального программирования, на самом деле Федя вам рассказал про рейнджи, это тоже относится к теме функционального программирования, потому что по сути вы,
[01:04:44.920 --> 01:04:55.920]  ну по сути рейнджи это тоже в каком-то смысле, ну вот эти вот функторы, когда палкой там конвейер создаете и разных операций что делать, а потом его разом выполняете.
[01:04:55.920 --> 01:05:14.920]  Вот, есть один замечательный класс, который тоже появился в C++11 впервые, и он позволяет вам хранить любой вызываемый объект.
[01:05:14.920 --> 01:05:26.920]  Ну давайте это будет пункт 13.5, правда я обещал, что пункт про рейнджи будет 13.5, ну давайте это будет 13.6.
[01:05:26.920 --> 01:05:34.920]  Фанкшн, STD-фанкшн.
[01:05:34.920 --> 01:05:59.920]  Так, где у нас лежит STD-фанкшн, я опять забыл, то ли в утилите, то ли в функционал, будем надеяться, что в функционал.
[01:05:59.920 --> 01:06:09.920]  Значит смотрите, что позволяет делать мне класс STD-фанкшн.
[01:06:09.920 --> 01:06:14.920]  Ну во-первых, это шаблонный класс, у которого шаблонный параметр должен быть функциональным типом.
[01:06:14.920 --> 01:06:33.920]  Я могу вот так сказать.
[01:06:33.920 --> 01:06:44.920]  Значит STD-фанкшн, это такой тип, шаблонный, его шаблонным параметром является тип функции, функциональный тип.
[01:06:44.920 --> 01:06:56.920]  Да, функциональный тип вот так записывается, смотрите, у нас бывает тип указатель на функцию, это вот так записывается, у нас бывает тип ссылка на функцию, это вот так записывается.
[01:06:56.920 --> 01:07:00.920]  А это, это просто функция.
[01:07:00.920 --> 01:07:12.920]  Функция формально это тоже некоторый тип, да, функция работает типом.
[01:07:12.920 --> 01:07:21.920]  Да не думаю.
[01:07:21.920 --> 01:07:27.920]  Нет, у многих все еще вызывает недоумение, что это за тип такой, потому что объявить переменную такого типа я не могу.
[01:07:27.920 --> 01:07:35.920]  Но формально все еще это такой тип, и он должен быть шаблонным параметром.
[01:07:35.920 --> 01:07:39.920]  Ты же можешь объявить такую типу?
[01:07:39.920 --> 01:07:41.920]  Переменную такого типа, нет.
[01:07:41.920 --> 01:07:43.920]  В глобальном скопе называется она функция?
[01:07:43.920 --> 01:07:45.920]  Нет, это не будет переменной.
[01:07:45.920 --> 01:07:47.920]  Это не будет переменной считаться.
[01:07:47.920 --> 01:07:49.920]  Это примерно оно и есть.
[01:07:49.920 --> 01:07:53.920]  А так, SD-фанкшн.
[01:07:53.920 --> 01:08:01.920]  Вот, этот функшн можно теперь вызывать, у него есть оператор круглой скобочки, как ни странно.
[01:08:01.920 --> 01:08:05.920]  Что еще есть у SD-фанкшна?
[01:08:05.920 --> 01:08:09.920]  А cpp-референс, о, таки наконец прогрузился cpp-референс.
[01:08:09.920 --> 01:08:14.920]  Да, ну вот, собственно, на cpp-референс перечислены возможные синтаксисы лямпт.
[01:08:14.920 --> 01:08:17.920]  И возможные варианты, что может быть в списках захвата.
[01:08:17.920 --> 01:08:23.920]  В общем, я эту страничку предлагаю вам самим посмотреть, вот что может быть в списках захвата лямпт.
[01:08:23.920 --> 01:08:26.920]  Но я уже не буду сейчас к этому возвращаться.
[01:08:26.920 --> 01:08:32.920]  Давайте я попробую открыть страничку про SD-фанкшн.
[01:08:35.920 --> 01:08:44.920]  Ну, в целом, как бы ничего пока удивительного.
[01:08:44.920 --> 01:08:46.920]  Ну, объект и объект.
[01:08:46.920 --> 01:08:48.920]  Проинициализировали его лямбдой.
[01:08:48.920 --> 01:08:58.920]  Но прикол в том, что этот тип SD-фанкшн может в рантайме подменять функцию, которая под ним лежит.
[01:08:59.920 --> 01:09:02.920]  Я могу, например, сказать...
[01:09:04.920 --> 01:09:06.920]  Ну, я не знаю.
[01:09:13.920 --> 01:09:16.920]  Я могу взять, например, и такую функцию объявить.
[01:09:16.920 --> 01:09:17.920]  Increment XA.
[01:09:17.920 --> 01:09:21.920]  И сказать, теперь f это будет increment.
[01:09:22.920 --> 01:09:26.920]  Типа не по ссылке?
[01:09:26.920 --> 01:09:28.920]  Да дело не в ссылке.
[01:09:28.920 --> 01:09:36.920]  То, что функции не явно конвертируются в указатели на функции, это мы и раньше знали.
[01:09:36.920 --> 01:09:42.920]  Проблема в том, чудо этой истории в том, что вообще-то под f лежал объект лямбды.
[01:09:42.920 --> 01:09:43.920]  Closure.
[01:09:43.920 --> 01:09:48.920]  А потом я взял и такой сказал, окей, теперь храни обычный указательностичный фунсток, окей.
[01:09:48.920 --> 01:09:53.920]  А потом я ему скажу, а теперь у меня есть еще такой класс.
[01:09:53.920 --> 01:09:55.920]  Ну, структура.
[01:09:57.920 --> 01:10:00.920]  Ну, не compare, а структура, не знаю, decrement.
[01:10:04.920 --> 01:10:09.920]  И в ней будет int, оператор, круглые скобочки, от int.
[01:10:09.920 --> 01:10:17.920]  Const, который берет и возвращает минус-минус X.
[01:10:17.920 --> 01:10:23.920]  И я такой говорю, хорошо, а теперь ты храни, пожалуйста, decrement.
[01:10:23.920 --> 01:10:26.920]  И снова спрошу, чему равно f от 2.
[01:10:30.920 --> 01:10:32.920]  Ну, можно и не const, да.
[01:10:32.920 --> 01:10:34.920]  Пожалуйста.
[01:10:34.920 --> 01:10:36.920]  То есть, у меня сначала функции была лямбда.
[01:10:36.920 --> 01:10:38.920]  Потом обычная осишная функция.
[01:10:38.920 --> 01:10:40.920]  Потом некоторые функциональные объекты в старом стиле.
[01:10:40.920 --> 01:10:42.920]  И все это...
[01:10:48.920 --> 01:10:55.920]  И все это я спокойно могу присваивать функции.
[01:10:57.920 --> 01:11:01.920]  А могу вообще функции изначально...
[01:11:01.920 --> 01:11:03.920]  Функции изначально...
[01:11:06.920 --> 01:11:08.920]  Объявить как пустую.
[01:11:09.920 --> 01:11:11.920]  Ну, я могу сказать, например, так.
[01:11:11.920 --> 01:11:15.920]  auto ff равно std move от f.
[01:11:17.920 --> 01:11:22.920]  Я забрал функцию, которая хранила f.
[01:11:23.920 --> 01:11:27.920]  И сейчас я попробую вывести f от 2 и, скорее всего, упаду.
[01:11:28.920 --> 01:11:30.920]  Ну да.
[01:11:30.920 --> 01:11:32.920]  Это exception.
[01:11:32.920 --> 01:11:34.920]  Bad function call.
[01:11:34.920 --> 01:11:36.920]  То есть, функция хранит некоторую функцию в себе.
[01:11:36.920 --> 01:11:38.920]  Но я ее могу забрать у нее.
[01:11:38.920 --> 01:11:40.920]  И теперь она пустая.
[01:11:40.920 --> 01:11:43.920]  Это было бы то же самое, как если бы я std function объявил вот так.
[01:11:43.920 --> 01:11:46.920]  То есть, я могу сказать, std function f без параметра.
[01:11:46.920 --> 01:11:48.920]  Ну, ничем не проинциализировав изначально.
[01:11:48.920 --> 01:11:50.920]  Она хранит как бы пустую...
[01:11:50.920 --> 01:11:52.920]  nullptr она хранит в каком-то смысле.
[01:11:52.920 --> 01:11:56.920]  А дальше она просто в себе подкладывает то лямбду,
[01:11:56.920 --> 01:12:02.920]  то function pointer, то стандартный, то компаратор в старом...
[01:12:02.920 --> 01:12:04.920]  Ну, функциональный объект в старом стиле.
[01:12:04.920 --> 01:12:10.920]  И это все она в рантайме может подменять один тип на другой.
[01:12:10.920 --> 01:12:14.920]  Так еще прикол в том, что если мы ее вызываем, когда ничего нет,
[01:12:14.920 --> 01:12:16.920]  там не exception полетает, а не...
[01:12:16.920 --> 01:12:18.920]  Да-да-да.
[01:12:18.920 --> 01:12:20.920]  Но она, когда мы ее вызываем...
[01:12:20.920 --> 01:12:23.920]  Ну, у него есть оператор круглой скобочки у этого объекта.
[01:12:23.920 --> 01:12:27.920]  И он видит, если мы от пустого вызываемся, то кидает exception.
[01:12:27.920 --> 01:12:29.920]  Ну, он видит себя, я пустой или нет.
[01:12:29.920 --> 01:12:32.920]  Вот, себе переференс прогрузился.
[01:12:32.920 --> 01:12:33.920]  Смотрите, что у нас есть.
[01:12:33.920 --> 01:12:35.920]  Ну, у нас есть конструкторы, деструкторы.
[01:12:35.920 --> 01:12:38.920]  Swap, assign, оператор bool.
[01:12:38.920 --> 01:12:39.920]  Что такое оператор bool?
[01:12:39.920 --> 01:12:42.920]  Ну, это как раз cast проверка пустая функция или нет.
[01:12:42.920 --> 01:12:45.920]  То есть, можно написать iff, то есть, если там что-то лежит.
[01:12:45.920 --> 01:12:47.920]  Вот.
[01:12:50.920 --> 01:12:52.920]  Давайте посмотрим на конструкторы.
[01:12:52.920 --> 01:12:54.920]  Вот, да.
[01:12:54.920 --> 01:12:58.920]  Ну, тут написано, что это general purpose polymorphic function wrapper.
[01:12:58.920 --> 01:13:04.920]  Каждые объекты function могут хранить, копировать и вызывать
[01:13:04.920 --> 01:13:08.920]  любой copy constructable callable target.
[01:13:08.920 --> 01:13:14.920]  А это функции обычные, сишные, лямдовыражения, байндовыражения
[01:13:14.920 --> 01:13:16.920]  или другие функции.
[01:13:16.920 --> 01:13:20.920]  А также указатели на члены и указатели на методы.
[01:13:20.920 --> 01:13:28.920]  В этом списке вам должно быть понятно все, кроме того, что такое bind expression.
[01:13:28.920 --> 01:13:31.920]  Про bind expression мы сейчас отдельно поговорим.
[01:13:31.920 --> 01:13:37.920]  Вот какие есть, значит,
[01:13:37.920 --> 01:13:40.920]  конструкторы.
[01:13:40.920 --> 01:13:44.920]  А сейчас будет табличка, значит, смех в зале.
[01:13:44.920 --> 01:13:49.920]  Посмотрите внимательно на вот эти вот версии конструктора.
[01:13:49.920 --> 01:13:52.920]  Аллокатор они принимают.
[01:13:52.920 --> 01:13:55.920]  Но здесь...
[01:13:55.920 --> 01:14:00.920]  Ну, как можно догадаться, функция фантастики, фантастика
[01:14:00.920 --> 01:14:05.920]  фантастики, фантастика фантастики, фантастика фантастики,
[01:14:05.920 --> 01:14:09.920]  как можно догадаться, функцион объекту оно лоцирует кое-что в динамической памяти,
[01:14:09.920 --> 01:14:13.920]  потому что ему, чтобы сохранить этот объект функции, ему нужно его где-то,
[01:14:13.920 --> 01:14:18.920]  примерно так же, как и sharedPTR, его нужно сохранить в динамической памяти выделив.
[01:14:18.920 --> 01:14:22.920]  Но тут есть смешной момент.
[01:14:22.920 --> 01:14:27.920]  Это было удалено все плюс 17.
[01:14:27.920 --> 01:14:32.920]  Значит, анекдот вот какой.
[01:14:32.920 --> 01:14:38.920]  А СТЛ, не СТЛ, а комитет, конечно же, по инерции,
[01:14:38.920 --> 01:14:44.920]  решил, что, ребята, раз мы храним что-то в динамической памяти, давайте добавлять аллокатор.
[01:14:44.920 --> 01:14:50.920]  Но, к моменту C++17, все поняли, что аллокаторы всех так задолбали,
[01:14:50.920 --> 01:14:56.920]  что они решили, и компиляторы все еще не смогли поддержать функцион с кастомным аллокатором нормально.
[01:14:56.920 --> 01:15:01.920]  То есть, sharedPTR с кастомным аллокатором они еще поддержали и сказали, ладно.
[01:15:01.920 --> 01:15:05.920]  Но когда они еще и Function, которые в C++17 появились, добавили с кастомным аллокатором,
[01:15:05.920 --> 01:15:09.920]  разработчики компиляторов сказали, да вы задолбали, мы не будем это поддерживать.
[01:15:09.920 --> 01:15:15.920]  То есть, там до, вплоть до вот C++17 компиляторы все еще не научились поддерживать кастомный аллокатор Function.
[01:15:15.920 --> 01:15:19.920]  Тогда комитет сказал, ладно, сдаемся, не поддерживайте кастомный аллокатор Function.
[01:15:19.920 --> 01:15:21.920]  Мы не хотим этим.
[01:15:21.920 --> 01:15:23.920]  Чтобы отказаться от этой идеи.
[01:15:23.920 --> 01:15:24.920]  Что-что?
[01:15:24.920 --> 01:15:26.920]  Чтобы отказаться от этой дебильной идеи.
[01:15:27.920 --> 01:15:31.920]  Значит, комитет решил отказаться от аллокаторов как части типа,
[01:15:31.920 --> 01:15:34.920]  и Function не стала его поддерживать.
[01:15:34.920 --> 01:15:37.920]  На самом деле, я вам открою секрет,
[01:15:37.920 --> 01:15:42.920]  в C++17, и об этом нам предстоит вскоре поговорить,
[01:15:42.920 --> 01:15:45.920]  вероятно сегодня мы не успеем, но в следующий раз,
[01:15:45.920 --> 01:15:48.920]  появились так называемые полиморфик аллокаторы.
[01:15:50.920 --> 01:15:53.920]  На самом деле тот факт, что аллокаторы являются части типа контейнеров,
[01:15:53.920 --> 01:15:57.920]  всех изрядно задолбал уже к моменту C++11 и C++14,
[01:15:57.920 --> 01:16:01.920]  и все уже понимали, что это была какая-то ошибка довольно старая,
[01:16:01.920 --> 01:16:03.920]  от которой бы пора избавить язык,
[01:16:03.920 --> 01:16:06.920]  но по инерции все навешивали вот эти костыли,
[01:16:06.920 --> 01:16:09.920]  скопт аллокатор адаптер и прочая вот эта вот дрянь,
[01:16:09.920 --> 01:16:11.920]  которую все очень задолбались поддерживать.
[01:16:11.920 --> 01:16:14.920]  Но начиная с C++17, вы, возможно, замечали,
[01:16:14.920 --> 01:16:19.920]  появился новый вид контейнеров, у которых аллокатор это не часть типа,
[01:16:19.920 --> 01:16:21.920]  а который динамически может подменяться.
[01:16:23.920 --> 01:16:25.920]  Это же в реализации совсем мясо.
[01:16:25.920 --> 01:16:30.920]  Да нет, и это как раз, как ни странно, в реализации не так уж сложно,
[01:16:30.920 --> 01:16:36.920]  как поддерживать все эти пропагейт он контейнер, копия ассайнмент,
[01:16:36.920 --> 01:16:39.920]  и тому подобное, скопт аллокатор адаптер и прочее.
[01:16:39.920 --> 01:16:45.920]  Вот, и вот видите, здесь у Анну, ну да, здесь мы уже потратили.
[01:16:45.920 --> 01:16:51.920]  В общем, мы на самом деле с вами плавненько подходим к следующей теме крупной,
[01:16:51.920 --> 01:16:55.920]  которая у нас займет несколько пар,
[01:16:55.920 --> 01:16:59.920]  и на которую у вас будет и задача sharedPTR, и следующая задача,
[01:16:59.920 --> 01:17:02.920]  но она будет там пересекаться с разными темами,
[01:17:02.920 --> 01:17:04.920]  это тема стирания типов.
[01:17:04.920 --> 01:17:09.920]  А именно, у нас с вами вот уже в нескольких местах возникла одна и та же проблема.
[01:17:09.920 --> 01:17:13.920]  Мы хотим уметь динамически подменять тип хранимого объекта.
[01:17:13.920 --> 01:17:18.920]  Мы хотим уметь в sharedPTR динамически подменять тип дилитера и типа аллокатора.
[01:17:18.920 --> 01:17:22.920]  Мы хотим в Function уметь динамически подменять тип хранимого объекта.
[01:17:22.920 --> 01:17:27.920]  Мы хотим в контейнерах сделать так, чтобы аллокатор не был частью типа,
[01:17:27.920 --> 01:17:30.920]  и тоже в контейнерах хотим уметь динамически подменять аллокатор,
[01:17:30.920 --> 01:17:33.920]  что научились делать с Fibonacci 17.
[01:17:33.920 --> 01:17:39.920]  Ну и еще кое-где мы это хотим научиться делать, и мы увидим, где это еще помогает.
[01:17:39.920 --> 01:17:44.920]  И это будет наша следующая тема, и вот сегодня наша цель это успеть обсудить,
[01:17:44.920 --> 01:17:46.920]  как это сделано в sharedPTR.
[01:17:46.920 --> 01:17:49.920]  И после этого вы сможете начать писать sharedPTR.
[01:17:52.920 --> 01:17:55.920]  Класс Function на самом деле мы с вами тоже реализуем.
[01:17:55.920 --> 01:17:57.920]  Мы с вами обсудим, как он устроен изнутри.
[01:17:57.920 --> 01:18:03.920]  И это очень хорошая такая содержательная задача – реализовать Function.
[01:18:03.920 --> 01:18:07.920]  И вообще это могло бы быть целой отдельной задачей, домашней,
[01:18:07.920 --> 01:18:12.920]  но в силу нехватки времени, потому что у вас и так много задач, это не будет домашней задачей.
[01:18:12.920 --> 01:18:18.920]  Но на самом деле реализовать Function полноценно, чтобы оно работало как надо и все делать умело,
[01:18:18.920 --> 01:18:22.920]  это прям полноценная задача. Мы ее реализуем в упрощенном варианте,
[01:18:22.920 --> 01:18:27.920]  но вы увидите, насколько там много, насколько глубока кроличья нора, так сказать.
[01:18:27.920 --> 01:18:31.920]  Как из sharedPTR, сколько проблем скрывает за собой реализация STD Function.
[01:18:33.920 --> 01:18:39.920]  Тем не менее, прежде чем к этому переходить, я вам покажу еще несколько фокусов с STD Function.
[01:18:39.920 --> 01:18:45.920]  Во-первых, STD Function умеет хранить указатели на члены, как уже было сказано.
[01:18:47.920 --> 01:18:51.920]  То есть, указатели на методы, например, она умеет хранить.
[01:18:53.920 --> 01:18:56.920]  А, например, у меня может быть метод…
[01:19:02.920 --> 01:19:05.920]  Не знаю, тест, я не силен в придумывании названий.
[01:19:05.920 --> 01:19:07.920]  У меня может быть метод…
[01:19:09.920 --> 01:19:13.920]  Который тоже принимает int.
[01:19:14.920 --> 01:19:17.920]  Давайте у меня будет поле какое-нибудь типа int.
[01:19:20.920 --> 01:19:25.920]  Метод add, который принимает y и возвращает x плюс y.
[01:19:27.920 --> 01:19:30.920]  Это метод класса Test.
[01:19:31.920 --> 01:19:37.920]  STD Function умеет хранить любой callable.
[01:19:37.920 --> 01:19:41.920]  Любой callable, любую callable сущность.
[01:19:41.920 --> 01:19:43.920]  Что такое callable здесь написано?
[01:19:51.920 --> 01:19:54.920]  Тут написано, значит, много интересного.
[01:19:54.920 --> 01:19:57.920]  Мы вскоре разберемся в том, что тут написано.
[01:20:01.920 --> 01:20:05.920]  Но указатель на метод тоже callable.
[01:20:06.920 --> 01:20:08.920]  Как вызывать указатель на метод?
[01:20:09.920 --> 01:20:15.920]  Ну вот у меня есть тест t, и я могу сказать, что t, давайте вспомним,
[01:20:15.920 --> 01:20:21.920]  точка звездочка add, вот 5, например.
[01:20:21.920 --> 01:20:26.920]  Только надо в скобке взять это, потому что круглый скобок приоритет выше, чем у точки со звездочкой.
[01:20:30.920 --> 01:20:40.920]  В параграфе 3.10, если мне не изменяет память.
[01:20:45.920 --> 01:20:47.920]  Не, это мы и делали.
[01:20:52.920 --> 01:20:55.920]  Ну это и есть он, это метод просто.
[01:20:56.920 --> 01:20:57.920]  Указатель на метод.
[01:20:57.920 --> 01:20:59.920]  Ну давайте проверим, что я вас не обманываю.
[01:20:59.920 --> 01:21:01.920]  Давайте я вот это все удалю.
[01:21:02.920 --> 01:21:05.920]  Блин, зря я это удалил, надо, наверное, было это закомментировать.
[01:21:12.920 --> 01:21:15.920]  А, ой, извините, я чушь написал, действительно.
[01:21:16.920 --> 01:21:18.920]  Это не указатель на метод, это я написал чушь.
[01:21:18.920 --> 01:21:20.920]  Мне нужен указатель на метод.
[01:21:20.920 --> 01:21:22.920]  Сначала мне нужен указатель на метод.
[01:21:22.920 --> 01:21:24.920]  Да, это бред, написан.
[01:21:24.920 --> 01:21:26.920]  Сейчас, конечно, это не сработает, давайте проверим.
[01:21:26.920 --> 01:21:28.920]  Да, это вообще не было declared in the scope.
[01:21:28.920 --> 01:21:30.920]  Извините, я написал чушь.
[01:21:30.920 --> 01:21:32.920]  Давайте я объявлю указатель на метод.
[01:21:32.920 --> 01:21:33.920]  Как он объявляется?
[01:21:33.920 --> 01:21:35.920]  Тест 2.2. звездочка.
[01:21:36.920 --> 01:21:39.920]  Только это в скобочках, а перед этим возвращаемый тип.
[01:21:39.920 --> 01:21:44.920]  Значит int test 2.2. звездочка at int.
[01:21:45.920 --> 01:21:47.920]  И вот здесь имя.
[01:21:47.920 --> 01:21:49.920]  padd, например.
[01:21:49.920 --> 01:21:53.920]  Равно amp test 2.2.add.
[01:21:53.920 --> 01:21:55.920]  Вот, теперь это указатель на метод.
[01:21:56.920 --> 01:22:00.920]  И теперь, имея объект t, я могу по указателю на метод вызвать метод.
[01:22:01.920 --> 01:22:02.920]  Нормально?
[01:22:02.920 --> 01:22:04.920]  Вот теперь должно быть нормально.
[01:22:06.920 --> 01:22:09.920]  Все работает и выводит ничего.
[01:22:09.920 --> 01:22:10.920]  Почему?
[01:22:10.920 --> 01:22:12.920]  Потому что я не вывел все аут, давайте выведу.
[01:22:13.920 --> 01:22:15.920]  Должно вывести 7, кажется, да?
[01:22:15.920 --> 01:22:18.920]  Так вот, такую штуку я тоже могу присвоить к функциону.
[01:22:18.920 --> 01:22:21.920]  То есть я могу завести function, в который положить эту штуковину.
[01:22:21.920 --> 01:22:23.920]  Вот этот вот указатель на метод.
[01:22:25.920 --> 01:22:27.920]  std function.
[01:22:27.920 --> 01:22:28.920]  Но вот вопрос.
[01:22:28.920 --> 01:22:32.920]  А как мне function-то, значит...
[01:22:34.920 --> 01:22:40.920]  Кажется, первым параметром, который у меня есть, это стд function.
[01:22:40.920 --> 01:22:42.920]  Дикол-тайп.
[01:22:43.920 --> 01:22:47.920]  Кажется, первым параметром надо передать какой-нибудь...
[01:22:47.920 --> 01:22:50.920]  Ну, вообще, у меня в SimpleFuse 17, кажется, есть
[01:22:50.920 --> 01:22:52.920]  class-template-argument-deduction.
[01:22:52.920 --> 01:22:54.920]  Может, мне это поможет?
[01:22:54.920 --> 01:22:58.920]  Давайте я попробую просто сказать, что std function f равно padd.
[01:22:58.920 --> 01:23:00.920]  И пусть он сам отгадает шаблонные параметры.
[01:23:00.920 --> 01:23:01.920]  Может, он сможет?
[01:23:01.920 --> 01:23:03.920]  Мы не можем просто дикол-тайп?
[01:23:03.920 --> 01:23:05.920]  К сожалению, нет, он не смог.
[01:23:05.920 --> 01:23:07.920]  Потому что...
[01:23:07.920 --> 01:23:09.920]  Но он объяснил, почему.
[01:23:09.920 --> 01:23:11.920]  У него много, в общем, было трудностей.
[01:23:11.920 --> 01:23:13.920]  В общем, он не смог отгадать шаблонные параметры таким способом.
[01:23:13.920 --> 01:23:15.920]  К сожалению, не вышло.
[01:23:15.920 --> 01:23:17.920]  Придется указывать их явно.
[01:23:17.920 --> 01:23:19.920]  Что же делать?
[01:23:19.920 --> 01:23:21.920]  Ну, можно попробовать, да, сказать, дикол-тайп.
[01:23:21.920 --> 01:23:23.920]  От padd.
[01:23:27.920 --> 01:23:29.920]  Тоже не получилось.
[01:23:29.920 --> 01:23:33.920]  Мы же до этого присваивали не указатель на функцию, а функцию.
[01:23:35.920 --> 01:23:37.920]  Да.
[01:23:37.920 --> 01:23:39.920]  Мне нужно здесь, чтобы был...
[01:23:39.920 --> 01:23:41.920]  Вот здесь был тип функции.
[01:23:41.920 --> 01:23:43.920]  Ладно, давайте я вам скажу, какой тип должен быть у этой
[01:23:43.920 --> 01:23:45.920]  штуки.
[01:23:45.920 --> 01:23:47.920]  На самом деле, у этой функции тип должен быть int,
[01:23:47.920 --> 01:23:49.920]  ссылка на тест
[01:23:49.920 --> 01:23:51.920]  и второй параметр int.
[01:23:51.920 --> 01:23:53.920]  Так, есть.
[01:23:53.920 --> 01:23:55.920]  Ну, он не явно первым аргументом берет ссылку
[01:23:55.920 --> 01:23:57.920]  на себя, на объект.
[01:23:57.920 --> 01:23:59.920]  Вот такой функции можно присвоить
[01:23:59.920 --> 01:24:01.920]  указатель на метод.
[01:24:01.920 --> 01:24:03.920]  А можем ли мы таким образом вызвать метод?
[01:24:03.920 --> 01:24:05.920]  Да, можем, если у меня объект
[01:24:05.920 --> 01:24:07.920]  есть.
[01:24:07.920 --> 01:24:09.920]  Чтобы мне вызвать указатель на метод, мне нужно
[01:24:09.920 --> 01:24:11.920]  иметь объект t,
[01:24:11.920 --> 01:24:13.920]  а также передать ему что-то вторым параметром.
[01:24:13.920 --> 01:24:15.920]  Вот я могу дикол-тайп,
[01:24:15.920 --> 01:24:17.920]  а я могу дикол-тайп,
[01:24:17.920 --> 01:24:19.920]  а я могу дикол-тайп,
[01:24:19.920 --> 01:24:21.920]  а также передать ему что-то вторым параметром.
[01:24:21.920 --> 01:24:23.920]  Вот я могу точно так же сказать, да, что...
[01:24:31.920 --> 01:24:33.920]  Думаю, не сработает.
[01:24:33.920 --> 01:24:35.920]  Ну, давай проверим.
[01:24:37.920 --> 01:24:39.920]  Ну, я не пробовал, ну давай проверим.
[01:24:41.920 --> 01:24:43.920]  Нет.
[01:24:43.920 --> 01:24:45.920]  Да.
[01:24:45.920 --> 01:24:47.920]  Нет, к сожалению, как раз
[01:24:47.920 --> 01:24:49.920]  из-за этого нам потребуется
[01:24:49.920 --> 01:24:51.920]  как раз из-за этого нам потребуется
[01:24:51.920 --> 01:24:53.920]  вот это вот, все, что тут
[01:24:53.920 --> 01:24:55.920]  написано.
[01:24:55.920 --> 01:24:57.920]  Потому что указатель
[01:24:57.920 --> 01:24:59.920]  на метод и другой синтаксис вызова.
[01:24:59.920 --> 01:25:01.920]  Короче, нет, так не работает.
[01:25:03.920 --> 01:25:05.920]  Как он внутри понимает это указатель на метод
[01:25:05.920 --> 01:25:07.920]  или...
[01:25:07.920 --> 01:25:09.920]  А вот, а вот,
[01:25:09.920 --> 01:25:11.920]  а я вам говорил, что real night function это хорошая задача.
[01:25:11.920 --> 01:25:13.920]  Да, и что?
[01:25:13.920 --> 01:25:15.920]  У него левым аргументом объекта
[01:25:15.920 --> 01:25:17.920]  правым аргументом pointerToMember
[01:25:17.920 --> 01:25:19.920]  должен быть.
[01:25:19.920 --> 01:25:21.920]  Вот, но еще интереснее,
[01:25:21.920 --> 01:25:23.920]  что на самом деле можно так делать
[01:25:23.920 --> 01:25:25.920]  не только pointerToMember, но и pointerTo...
[01:25:25.920 --> 01:25:27.920]  не pointerToMethod, а pointerTo...
[01:25:27.920 --> 01:25:29.920]  указатель на поля, короче,
[01:25:29.920 --> 01:25:31.920]  так можно вызывать, вызывать
[01:25:31.920 --> 01:25:33.920]  указатель на поля.
[01:25:33.920 --> 01:25:35.920]  Смотрите, я могу сказать
[01:25:35.920 --> 01:25:37.920]  std function
[01:25:37.920 --> 01:25:39.920]  std function
[01:25:39.920 --> 01:25:41.920]  std function
[01:25:41.920 --> 01:25:43.920]  от int
[01:25:43.920 --> 01:25:45.920]  тест
[01:25:45.920 --> 01:25:47.920]  от int
[01:25:47.920 --> 01:25:49.920]  от тест
[01:25:49.920 --> 01:25:51.920]  и все
[01:25:51.920 --> 01:25:53.920]  ff равно, ну, мне нужно
[01:25:53.920 --> 01:25:55.920]  указатель на поле, int
[01:25:55.920 --> 01:25:57.920]  тест
[01:25:57.920 --> 01:25:59.920]  тест, уже без скобочек
[01:25:59.920 --> 01:26:01.920]  2.2. звездочка
[01:26:01.920 --> 01:26:03.920]  px равно
[01:26:03.920 --> 01:26:05.920]  amp test
[01:26:05.920 --> 01:26:07.920]  2.2.x
[01:26:07.920 --> 01:26:09.920]  И вот, если я сейчас ничего не путаю,
[01:26:09.920 --> 01:26:11.920]  кажется, что мне получится
[01:26:11.920 --> 01:26:13.920]  вот так сделать.
[01:26:13.920 --> 01:26:15.920]  Давайте проверим.
[01:26:15.920 --> 01:26:17.920]  Да, все работает.
[01:26:17.920 --> 01:26:19.920]  И я таким образом могу
[01:26:19.920 --> 01:26:21.920]  у объекта
[01:26:21.920 --> 01:26:23.920]  вызывать поле, как бы.
[01:26:23.920 --> 01:26:25.920]  По ссылке на объект
[01:26:25.920 --> 01:26:27.920]  возвращает его поле.
[01:26:27.920 --> 01:26:29.920]  Да.
[01:26:31.920 --> 01:26:33.920]  По сути, это функция getter такой.
[01:26:33.920 --> 01:26:35.920]  Зачем это может быть надо?
[01:26:35.920 --> 01:26:37.920]  Ну, например,
[01:26:37.920 --> 01:26:39.920]  вот у вас есть
[01:26:39.920 --> 01:26:41.920]  структура или у вас есть тупл.
[01:26:41.920 --> 01:26:43.920]  А вы хотите отсортировать
[01:26:43.920 --> 01:26:45.920]  этот тупл по какому-то
[01:26:45.920 --> 01:26:47.920]  из полей. Тогда вы можете
[01:26:47.920 --> 01:26:49.920]  просто передать в
[01:26:51.920 --> 01:26:53.920]  в качестве
[01:26:59.920 --> 01:27:01.920]  Не отсортировать тупл. У вас есть
[01:27:01.920 --> 01:27:03.920]  вектор из туплов, ну, или вектор
[01:27:03.920 --> 01:27:05.920]  пар. А вы хотите отсортировать
[01:27:05.920 --> 01:27:07.920]  его по какому-нибудь полю.
[01:27:09.920 --> 01:27:11.920]  Вот.
[01:27:11.920 --> 01:27:13.920]  И
[01:27:13.920 --> 01:27:15.920]  тогда вы могли бы, ну, я правда не уверен,
[01:27:15.920 --> 01:27:17.920]  что это работать будет
[01:27:17.920 --> 01:27:19.920]  с std-сортом.
[01:27:21.920 --> 01:27:23.920]  В смысле, стд-сорту передать
[01:27:23.920 --> 01:27:25.920]  о панке сейчас?
[01:27:25.920 --> 01:27:27.920]  Кстати, нам же Федя
[01:27:27.920 --> 01:27:29.920]  показывал такой прикол, что там...
[01:27:29.920 --> 01:27:31.920]  Ну да, да, это значит, это такая
[01:27:31.920 --> 01:27:33.920]  проекция. Вы как бы берете и...
[01:27:37.920 --> 01:27:39.920]  Ладно, я сейчас затрудняюсь пример привести.
[01:27:39.920 --> 01:27:41.920]  Давайте я его потом в следующий раз приведу, когда мы будем
[01:27:41.920 --> 01:27:43.920]  Invoke делать. Когда мы будем Function реализовывать,
[01:27:43.920 --> 01:27:45.920]  короче, мы в следующий раз будем Function реализовывать.
[01:27:45.920 --> 01:27:47.920]  И там
[01:27:47.920 --> 01:27:49.920]  я этот пример приведу.
[01:27:49.920 --> 01:27:51.920]  Вы узнаете, зачем нужна функция std-invoke.
[01:27:51.920 --> 01:27:53.920]  Вот. Пока просто
[01:27:53.920 --> 01:27:55.920]  мы знаем, что можно так делать.
[01:27:55.920 --> 01:27:57.920]  Кстати,
[01:27:57.920 --> 01:27:59.920]  вопросик. Если я здесь
[01:27:59.920 --> 01:28:01.920]  пишу,
[01:28:01.920 --> 01:28:03.920]  все нормально будет?
[01:28:07.920 --> 01:28:09.920]  Нет. Почему?
[01:28:11.920 --> 01:28:13.920]  Это такой вопрос на
[01:28:13.920 --> 01:28:15.920]  глубокое понимание очередное.
[01:28:15.920 --> 01:28:17.920]  Смотрите, у меня константный метод.
[01:28:17.920 --> 01:28:19.920]  А вы не константный тип
[01:28:19.920 --> 01:28:21.920]  в... Да.
[01:28:21.920 --> 01:28:23.920]  А я пытаюсь
[01:28:23.920 --> 01:28:25.920]  штуку, которая
[01:28:25.920 --> 01:28:27.920]  на самом деле константная
[01:28:27.920 --> 01:28:29.920]  по отношению к объекту,
[01:28:29.920 --> 01:28:31.920]  отдать туда, где ожидается штука,
[01:28:31.920 --> 01:28:33.920]  которая на самом деле не константная
[01:28:33.920 --> 01:28:35.920]  по отношению к объекту. То есть я пытаюсь сказать,
[01:28:35.920 --> 01:28:37.920]  а
[01:28:37.920 --> 01:28:39.920]  f, ну,
[01:28:39.920 --> 01:28:41.920]  вот моя функция, она имеет
[01:28:41.920 --> 01:28:43.920]  право менять тестом...
[01:28:43.920 --> 01:28:45.920]  Ну вот, менять свой первый
[01:28:45.920 --> 01:28:47.920]  аргумент. Я не
[01:28:47.920 --> 01:28:49.920]  могу
[01:28:49.920 --> 01:28:51.920]  ей присвоить штуку,
[01:28:51.920 --> 01:28:53.920]  которая не может менять свой первый аргумент.
[01:28:53.920 --> 01:28:55.920]  Именно в эту сторону, а не
[01:28:55.920 --> 01:28:57.920]  обратную. Вот если бы у меня здесь
[01:28:57.920 --> 01:28:59.920]  было так,
[01:28:59.920 --> 01:29:01.920]  вот если бы у меня здесь было так,
[01:29:01.920 --> 01:29:03.920]  то это нормально.
[01:29:03.920 --> 01:29:05.920]  Вот, смотрите.
[01:29:05.920 --> 01:29:07.920]  Так, сейчас. Нет, подождите, здесь это...
[01:29:19.920 --> 01:29:21.920]  Я забыл написать конст
[01:29:21.920 --> 01:29:23.920]  вот здесь еще.
[01:29:25.920 --> 01:29:27.920]  Так, сейчас.
[01:29:39.920 --> 01:29:41.920]  Тут что ли конст мне надо написать? Нет, это как
[01:29:41.920 --> 01:29:43.920]  странно.
[01:29:55.920 --> 01:29:57.920]  Да.
[01:29:57.920 --> 01:29:59.920]  О, теперь работает.
[01:30:03.920 --> 01:30:05.920]  Сейчас, да, давайте вот здесь
[01:30:05.920 --> 01:30:07.920]  сотрем.
[01:30:07.920 --> 01:30:09.920]  Да, наверное, я все-таки перепутал.
[01:30:09.920 --> 01:30:11.920]  Не в ту сторону нельзя, в другую сторону нельзя.
[01:30:13.920 --> 01:30:15.920]  Да, в эту сторону можно.
[01:30:15.920 --> 01:30:17.920]  Сказал, что
[01:30:17.920 --> 01:30:19.920]  важно не перепутать и перепутал.
[01:30:19.920 --> 01:30:21.920]  Бывает. Как прям с курткой в прошлый раз.
[01:30:21.920 --> 01:30:23.920]  есть константную функцию.
[01:30:23.920 --> 01:30:25.920]  Да, да, эта функция может
[01:30:25.920 --> 01:30:27.920]  менять, да.
[01:30:27.920 --> 01:30:29.920]  Ну, конечно, конечно.
[01:30:29.920 --> 01:30:31.920]  Моя функция
[01:30:31.920 --> 01:30:33.920]  гипотетически может менять первый аргумент.
[01:30:33.920 --> 01:30:35.920]  А я и даю функцию, которая не может менять первый аргумент,
[01:30:35.920 --> 01:30:37.920]  ну окей.
[01:30:37.920 --> 01:30:39.920]  Но в обратную сторону нельзя,
[01:30:39.920 --> 01:30:41.920]  если бы моя функция должна
[01:30:41.920 --> 01:30:43.920]  не уметь менять первый аргумент.
[01:30:43.920 --> 01:30:45.920]  А я и даю функцию, которая
[01:30:45.920 --> 01:30:47.920]  умеет менять первый аргумент. Я нарушаю
[01:30:47.920 --> 01:30:49.920]  константность.
[01:30:49.920 --> 01:30:56.620]  вот если я здесь теперь сотру конст тоset это будет тоет все сломает вот
[01:30:56.620 --> 01:31:01.300]  здесь вот будет ошибка потому что она первым аргументом не яна принимает
[01:31:01.300 --> 01:31:05.680]  тестом establish а я пытаюсь отдать туда где требуется конст тестом важна первым
[01:31:05.680 --> 01:31:13.040]  аргументом вот вот именно сейчас все правильно вот именно в эту сторону
[01:31:13.040 --> 01:31:17.780]  нельзя я пытаюсь функции которая не меняет
[01:31:17.780 --> 01:31:20.860]  первый аргумент подсунуть функцию, которая меняет
[01:31:20.860 --> 01:31:23.240]  первый аргумент.
[01:31:23.240 --> 01:31:25.340]  Моя функция не должна уметь менять первый аргумент,
[01:31:25.340 --> 01:31:26.660]  а я и подсовываю.
[01:31:26.660 --> 01:31:29.060]  Я обещал в сигнатуре этой функции, что она не меняет
[01:31:29.060 --> 01:31:30.060]  первый аргумент.
[01:31:30.060 --> 01:31:31.900]  А я и подсовываю функцию, которая меняет первый аргумент,
[01:31:31.900 --> 01:31:32.900]  вот так не должно работать.
[01:31:32.900 --> 01:31:34.840]  Вот.
[01:31:34.840 --> 01:31:44.740]  Окей, это, что касается stfunction.
[01:31:44.740 --> 01:31:47.020]  И последнее самое.
[01:31:47.020 --> 01:32:01.660]  что в этой теме я вам расскажу это bind штука под названием std bind cpp-reference давай работай
[01:32:01.660 --> 01:32:18.220]  значит пункт давайте в этом же файле скажу пункт 13.7 будет
[01:32:18.220 --> 01:32:26.380]  назваться std bind смотрите что насколько велик и могучий язык c++ что мне позволяет делать
[01:32:26.380 --> 01:32:41.260]  язык c++ он мне позволяет делать карирование кто значит такое карирование да да о ты знаешь
[01:32:41.260 --> 01:32:44.740]  такое карирование значит функциональном программировании есть наряду с термином
[01:32:44.740 --> 01:32:53.540]  замыкания что такой термин карирование каринг по-моему пишется так но я не уверен
[01:32:53.540 --> 01:32:59.180]  лучше не буду писать это по английски можно на wikipedia открыть статью класс
[01:32:59.180 --> 01:33:09.940]  нет нет карри это фамилия не от слова нести карри а от фамилии ученого который занимался
[01:33:09.940 --> 01:33:18.100]  там логикой логикой и всякими подобными вещами лямбда исчисления в части кажется занималась
[01:33:18.100 --> 01:33:25.500]  комбинаторной логикой занимался короче если у меня есть функция ну давайте опять напишу авто
[01:33:25.500 --> 01:33:30.380]  моя любимая авто
[01:33:36.820 --> 01:33:37.620]  f равно
[01:33:44.220 --> 01:33:52.100]  назову ее less вот на этот раз я придумаю нормальное название назову less функция
[01:33:52.100 --> 01:34:01.380]  которая сравнивает два аргумент кто из них меньше но я могу а захотеть сделать из этой
[01:34:01.380 --> 01:34:15.900]  функции другую функцию функция будет от одного аргумента которая проверяет правда ли что ее
[01:34:15.900 --> 01:34:24.500]  аргумент меньше чем 5 я хочу взять эту функцию и зафиксировать в ней один аргумент ну конечно
[01:34:24.500 --> 01:34:38.460]  же я могу это сделать тоже через лямбда то есть я могу ну наподобие того что я делал тогда я
[01:34:38.460 --> 01:34:53.940]  могу сказать типа ну да я могу типа вот так сделать и сказать return опять лямбда
[01:34:53.940 --> 01:35:03.860]  которая принимает сейчас less than 5 это что такое это функция которая принимает один аргумент
[01:35:03.860 --> 01:35:16.100]  а и эта штука мне возвращать должна мы же вызываем а да все я не должен еще одну лямбу мне
[01:35:16.100 --> 01:35:28.260]  просто нужно сказать проверить что x что less от x и 5 вот так я могу сделать нет да все все нормально
[01:35:28.260 --> 01:35:35.180]  да да да я сказал что less than 5 это функция которая возвращает less от x и 5 получилась
[01:35:35.180 --> 01:35:40.860]  функция не маргман но на самом деле такая штука есть но у меня есть функция стандартной
[01:35:40.860 --> 01:35:47.820]  функция стандартной библиотеки которая позволяет мне это делать она называется ст байнд я могу
[01:35:47.820 --> 01:36:06.460]  сказать следующее это удалю стд байнд less дальше очень странно знак подчеркивания 1 5 ну не
[01:36:06.460 --> 01:36:19.500]  знак подчеркивания 2 на самом деле здесь надо добавить стд placeholders смотрите это такая штука
[01:36:19.500 --> 01:36:25.740]  что как ст байнд это вещь которая берет функцию а дальше она принимает переменное количество
[01:36:25.740 --> 01:36:33.260]  аргументов из которых нужно ну вот стд placeholders знак подчеркивания 2 это некоторые специальные
[01:36:33.260 --> 01:36:39.460]  объект которые исключительно функции стд байт понимаемый она говорит ей что на второе по
[01:36:39.460 --> 01:36:52.860]  счету место нужно подставить то что я следующим тебе передал пятерку это хороший вопрос да
[01:36:52.860 --> 01:37:05.420]  вот давайте я вам открою страничку на cpp референс про байнд только я надеюсь ну она пока грузится
[01:37:05.420 --> 01:37:14.900]  почему нельзя просто в нормальном порядке вот тихо тихо что значит в нормальном порядке
[01:37:14.900 --> 01:37:42.300]  передавать чтобы она понимала на какое место подставить вот это я скорее всего что-то забыл
[01:37:45.300 --> 01:37:50.340]  возможно я перепутал порядок сначала надо писать 5 а потом ст placeholders
[01:37:50.340 --> 01:37:58.020]  а
[01:38:10.220 --> 01:38:10.940]  я
[01:38:10.940 --> 01:38:22.940]  Я все еще не понимаю, в какой функции...
[01:38:22.940 --> 01:38:24.940]  А, да, вот наконец-то нам открылось...
[01:38:24.940 --> 01:38:28.940]  В каком цели выполняет неподчерканное банно?
[01:38:28.940 --> 01:38:35.940]  Показать вместо какого аргумента функции подставить то, что вы дали в байке?
[01:38:35.940 --> 01:38:39.940]  В смысле, что вместо второго аргумента функции подставить?
[01:38:39.940 --> 01:38:43.940]  А нельзя просто в таком порядке их написать, чтобы на втором месте среди аргумента...
[01:38:43.940 --> 01:38:45.940]  А ты хочешь снимать эти аргументы?
[01:38:45.940 --> 01:38:49.940]  А ты хочешь сделать затычку для пропуска аргумента?
[01:38:49.940 --> 01:38:52.940]  В смысле? Я не понимаю почему.
[01:38:52.940 --> 01:38:54.940]  Мы хотим пропускать аргументы, но тебе за что?
[01:38:54.940 --> 01:38:56.940]  В первом оставить пустыню?
[01:38:56.940 --> 01:38:58.940]  В смысле, первое оставить пустыню?
[01:38:58.940 --> 01:38:59.940]  В прямом.
[01:38:59.940 --> 01:39:01.940]  Это у тебя новая функция получается?
[01:39:01.940 --> 01:39:04.940]  Я не понимаю, что значит первое оставить пустыню?
[01:39:04.940 --> 01:39:17.940]  Тебе нужно сделать новую функцию, которая первым аргументом передаст дальше ту функцию, которая в этом случае,
[01:39:17.940 --> 01:39:21.940]  а на второй аргумент будет подставлять вот эту.
[01:39:21.940 --> 01:39:24.940]  Эм...
[01:39:51.940 --> 01:39:55.940]  Что у тебя там твоего lesson 5 это...
[01:39:55.940 --> 01:39:59.940]  Так же прописать явно принимаемые параметры и явно прописать, чтобы там...
[01:39:59.940 --> 01:40:01.940]  Типа mx?
[01:40:01.940 --> 01:40:03.940]  Или что-то иное.
[01:40:03.940 --> 01:40:05.940]  Ну да, lesson 5 для mx.
[01:40:05.940 --> 01:40:07.940]  Ну типа это было в 1.8 в часе.
[01:40:07.940 --> 01:40:09.940]  Это как-то ты не забрал меня встать.
[01:40:09.940 --> 01:40:13.940]  Ну блин, просто это кажется было бы в 100 раз короче.
[01:40:15.940 --> 01:40:16.940]  И меньше потенциальных параметров.
[01:40:16.940 --> 01:40:19.940]  Почему-то у меня не работает.
[01:40:20.940 --> 01:40:22.940]  Просто это дичь какая-то.
[01:40:22.940 --> 01:40:24.940]  Сейчас, я пытаюсь понять, что я не так сделал.
[01:40:26.940 --> 01:40:31.940]  Просто так вы делаете на шаблонах, а так это были бы отдельные симптические конструкции.
[01:40:31.940 --> 01:40:33.940]  Так это было бы супер спресс.
[01:40:39.940 --> 01:40:43.940]  Что-то я не то сделал, но не понимаю что.
[01:40:45.940 --> 01:40:47.940]  К сожалению.
[01:40:49.940 --> 01:40:51.940]  Вась, просто логика сперса.
[01:40:51.940 --> 01:40:55.940]  Давайте сделаем отдельный стиль поисковая, приводим в основном вот к этому.
[01:40:55.940 --> 01:40:57.940]  И это логично.
[01:41:04.940 --> 01:41:07.940]  Может они с нуля нумируют аргументы просто?
[01:41:11.940 --> 01:41:13.940]  Ага, интересно.
[01:41:13.940 --> 01:41:15.940]  С единицей говоришь можно?
[01:41:15.940 --> 01:41:17.940]  Ага, с единицей получается.
[01:41:17.940 --> 01:41:19.940]  Окей.
[01:41:23.940 --> 01:41:25.940]  А видимо там нужно связанный отрезок.
[01:41:25.940 --> 01:41:27.940]  А, видимо я не могу указать второй, не указав первый.
[01:41:27.940 --> 01:41:29.940]  Вот в чем дело, да, хорошо.
[01:41:29.940 --> 01:41:31.940]  По смыслу это что значит?
[01:41:31.940 --> 01:41:35.940]  Что типа, куда фихать соответствующие аргументы, которые в полночьем не функционируют?
[01:41:35.940 --> 01:41:37.940]  В смысле, мы не можем все равно пропустить аргументы?
[01:41:37.940 --> 01:41:39.940]  Если мы не можем пропустить аргументы, мы не можем пропустить аргументы?
[01:41:39.940 --> 01:41:41.940]  В смысле, мы не можем все равно пропустить аргументы?
[01:41:41.940 --> 01:41:45.940]  Если мы не можем пропустить аргументы, зачем вообще весь этот синтаксис?
[01:41:45.940 --> 01:41:47.940]  Можем, можем, я забыл как.
[01:41:53.940 --> 01:41:55.940]  О, это Хаскл Харри.
[01:41:55.940 --> 01:41:57.940]  Тут сами до человека.
[01:41:59.940 --> 01:42:01.940]  Говорите, я логик.
[01:42:03.940 --> 01:42:07.940]  Да, что-то у меня не получается второй аргумент подставить вместо первого.
[01:42:07.940 --> 01:42:11.940]  Экспентальным путем было обнаружено, что вам всего 29 поисков дали.
[01:42:13.940 --> 01:42:16.940]  Да, ну в общем, ну в общем, да, я могу подставить.
[01:42:16.940 --> 01:42:18.940]  Вот смотрите, ну еще раз, что я написал.
[01:42:18.940 --> 01:42:25.940]  Я сказал, создай мне из функции less новую функцию, которая на первое место подставляет пятерку.
[01:42:25.940 --> 01:42:29.940]  А второй аргумент как бы пробрасывает как надо.
[01:42:29.940 --> 01:42:35.940]  Господи, я все перепутал, все не так.
[01:42:39.940 --> 01:42:42.940]  Плейсхолдер, да, плейсхолдер это как раз что пропустить надо.
[01:42:42.940 --> 01:42:45.940]  Опять это что подставить на второе место, вот как это работает.
[01:42:45.940 --> 01:42:47.940]  Вот, вот как это работает.
[01:42:47.940 --> 01:42:50.940]  Если я напишу вот так, это плейсхолдер.
[01:42:50.940 --> 01:42:54.940]  Да, это я, извините, опять, в который раз это работает.
[01:42:54.940 --> 01:42:59.940]  Да, теперь я создал функцию как бы с двумя аргументами, эквивалентно исходной.
[01:42:59.940 --> 01:43:04.940]  Вот, я мог бы сказать, вот так.
[01:43:04.940 --> 01:43:08.940]  Правда, все равно непонятно, почему так не работает.
[01:43:11.940 --> 01:43:15.940]  Попробуем после этого плейсхолдер один поставить, чисто по приколу.
[01:43:15.940 --> 01:43:19.940]  Нет, плейсхолдер вместо двойки у плейсхолдера один.
[01:43:19.940 --> 01:43:23.940]  И запустим, и скомпилируем.
[01:43:27.940 --> 01:43:29.940]  Я угадал.
[01:43:29.940 --> 01:43:33.940]  Да, все, мы методом проб и ошибок поняли как работают плейсхолдеры, да.
[01:43:33.940 --> 01:43:35.940]  Да, только один работает.
[01:43:35.940 --> 01:43:36.940]  Да.
[01:43:36.940 --> 01:43:37.940]  Да.
[01:43:37.940 --> 01:43:43.940]  Плейсхолдеры, короче, я нумирую плейсхолдеры с единицы, независимо от того, в каком порядке я что перечисляю.
[01:43:43.940 --> 01:43:50.940]  Сейчас у меня получилась функция, которая проверяет больше, чем пять, да.
[01:43:50.940 --> 01:43:56.940]  То есть тот аргумент, который я передаю в less than five, он как бы подставляется на место вот этой штуки.
[01:43:56.940 --> 01:44:02.940]  То есть, если я перечисляю плейсхолдеры с единицей, то у меня получается, что я перечисляю плейсхолдеры,
[01:44:02.940 --> 01:44:07.940]  то этот аргумент, который я передаю в less than five, он как бы подставляется на место вот этой штуки.
[01:44:07.940 --> 01:44:12.940]  И в итоге получается функция, правда ли, что пять меньше моей штуки, которую я передал сюда.
[01:44:12.940 --> 01:44:14.940]  А, ну понятно, зачем это сделано.
[01:44:14.940 --> 01:44:18.940]  Мы же хотим, чтобы у нас плейсхолдеры могли использоваться несколько раз с одним номером.
[01:44:18.940 --> 01:44:20.940]  Типа один параметр в несколько и так далее.
[01:44:20.940 --> 01:44:22.940]  Да, да, да, это правда.
[01:44:22.940 --> 01:44:29.940]  Вот, я могу здесь, да, например, если у меня есть функция х умножить на у,
[01:44:29.940 --> 01:44:34.940]  я могу сделать функцию square, которая просто берет один и тот же плейсхолдер в два раза.
[01:44:34.940 --> 01:44:36.940]  Вот.
[01:44:36.940 --> 01:44:40.940]  Я могу также сделать функцию, которая меняет местами аргументы.
[01:44:40.940 --> 01:44:42.940]  То есть, я могу, например, сказать, авто...
[01:44:43.940 --> 01:44:58.940]  Автогрейтор равно std bind less std placeholders.
[01:44:58.940 --> 01:45:00.940]  Два.
[01:45:00.940 --> 01:45:04.940]  Два std placeholders один.
[01:45:04.940 --> 01:45:09.940]  Во.
[01:45:09.940 --> 01:45:11.940]  И, ну то есть, я меняю местами аргументы.
[01:45:11.940 --> 01:45:15.940]  То, что мне в выражении передают первым, я отдам вторым.
[01:45:15.940 --> 01:45:18.940]  А то, что мне передали вторым, я отдам первым.
[01:45:18.940 --> 01:45:21.940]  Опять Мексика.
[01:45:21.940 --> 01:45:23.940]  Вот, это std bind.
[01:45:23.940 --> 01:45:25.940]  Вот.
[01:45:25.940 --> 01:45:28.940]  Какой тип имеет вот это выражение?
[01:45:28.940 --> 01:45:30.940]  std bind.
[01:45:30.940 --> 01:45:31.940]  Ну, вообще, грейтер.
[01:45:31.940 --> 01:45:35.940]  И у него какой тип?
[01:45:35.940 --> 01:45:40.940]  Отличный вопрос, правда?
[01:45:40.940 --> 01:45:42.940]  Грейтер.
[01:45:42.940 --> 01:45:48.940]  На самом деле, я уже видел вот в этих ошибках компиляции, какой тип у него.
[01:45:52.940 --> 01:45:56.940]  Ну вот, std bind main lambda intent.
[01:45:56.940 --> 01:45:59.940]  Короче, это еще одна какая-то внутренняя штуковина.
[01:45:59.940 --> 01:46:03.940]  То есть это еще, наеду с лямбдами, bind объекты.
[01:46:03.940 --> 01:46:07.940]  Это такие штуковины, которые тоже генерируются компилятором из bind expressions.
[01:46:07.940 --> 01:46:11.940]  И на самом деле, их тип он тоже внутри где-то в STL определенно.
[01:46:11.940 --> 01:46:13.940]  Ну, вот это std bind.
[01:46:13.940 --> 01:46:18.940]  Это некоторый внутренний тип, который в STL где-то написан.
[01:46:18.940 --> 01:46:20.940]  Но вас он не должен интересовать.
[01:46:20.940 --> 01:46:26.940]  Вот на себе перейфе сказано, что тип возвращаемого значения unspecified.
[01:46:26.940 --> 01:46:30.940]  Это компилятор решает, какой у него конкретно тип.
[01:46:30.940 --> 01:46:37.940]  Но на самом деле, bind в отличие от лямбды можно реализовать самим.
[01:46:37.940 --> 01:46:42.940]  То есть можно написать реализацию байнда.
[01:46:42.940 --> 01:46:48.940]  И реализация байнда вместе с реализацией function, это была бы очень хорошая содержательно-интересная задача.
[01:46:48.940 --> 01:46:49.940]  Вот.
[01:46:49.940 --> 01:46:55.940]  У вас, наверное, сейчас должно вызывать некоторую отрыв и страх, как можно реализовать bind самим.
[01:46:55.940 --> 01:46:57.940]  Ну, bind можно реализовать.
[01:46:57.940 --> 01:46:59.940]  Можно нагуглить, кстати, как bind реализован.
[01:46:59.940 --> 01:47:01.940]  Там есть пост на хабрид.
[01:47:03.940 --> 01:47:06.940]  Ну, нужно будет много шаблонной магии для этого.
[01:47:06.940 --> 01:47:16.940]  Ещё интересная штука, что плейсхоберы, учитывая, что они даже в STL ограниченные, то чуть проще становится жить.
[01:47:16.940 --> 01:47:17.940]  Вот.
[01:47:17.940 --> 01:47:20.940]  Ну, в общем, да.
[01:47:20.940 --> 01:47:27.940]  Реализовывать bind мы, наверное, не будем, и заданий у вас не будет реализовать bind, потому что некогда нам.
[01:47:27.940 --> 01:47:29.940]  Function мы реализуем, но bind не будем.
[01:47:29.940 --> 01:47:34.940]  Но для интересующихся там, я не знаю, это может быть какой-нибудь...
[01:47:34.940 --> 01:47:35.940]  Не знаю.
[01:47:35.940 --> 01:47:39.940]  В качестве вопроса на отл-10 на экзамене можно там...
[01:47:39.940 --> 01:47:40.940]  Реализовать bind.
[01:47:40.940 --> 01:47:43.940]  Да, типа идею реализации bind рассказать.
[01:47:43.940 --> 01:47:50.940]  Что bind из себя, как он идейно вообще, что он делает, то есть что должен он хранить, что вообще этот объект из себя представляет, что это такое.
[01:47:50.940 --> 01:47:54.940]  Можно, кстати, спросить опять-таки на CPP Insights.
[01:47:54.940 --> 01:48:02.940]  Ну, на CPP Insights мы, скорее всего, не увидим, ничего интересного, потому что это просто внутренний тип, который в STL где-то определён, что такое bind.
[01:48:02.940 --> 01:48:06.940]  Ну, какой-то внутренний тип, который там на шаблонах написан.
[01:48:06.940 --> 01:48:07.940]  Вот.
[01:48:07.940 --> 01:48:10.940]  Но Function умеет хранить и bind объекты тоже.
[01:48:10.940 --> 01:48:15.940]  Вот у вас здесь написано, что...
[01:48:15.940 --> 01:48:20.940]  Ну, короче, результаты bind-expression они тоже являются callable.
[01:48:20.940 --> 01:48:21.940]  Ну, логично.
[01:48:21.940 --> 01:48:30.940]  Да, то есть Function может лежать как указательный метод, так указательный член, так и, значит, bind-expression, bind-объект.
[01:48:30.940 --> 01:48:35.940]  Вообще вопрос, почему bind не всегда возвращает лямбль?
[01:48:35.940 --> 01:48:39.940]  Ну, bind возвращает некоторый специальный тип,
[01:48:39.940 --> 01:48:41.940]  который сделан...
[01:48:41.940 --> 01:48:46.940]  Ты же bind можешь байнить не только лямбды, ты же bind можешь делать не только из лямбды.
[01:48:49.940 --> 01:48:51.940]  Ну, bind – это специальная структура.
[01:48:51.940 --> 01:48:54.940]  Почему мы хотим вообще различные типы возвращать как результат bind?
[01:48:54.940 --> 01:48:56.940]  Потому что bind написан кодом.
[01:48:56.940 --> 01:48:59.940]  Bind – это штука, которая реализована прям.
[01:49:00.940 --> 01:49:02.940]  Bind – это шаблонная некоторая вещь.
[01:49:02.940 --> 01:49:04.940]  Там шаблонный класс стрёмный,
[01:49:04.940 --> 01:49:09.940]  который с помощью шаблонной магии вычисления вот этих вот позиций подставляет на нужные места
[01:49:09.940 --> 01:49:12.940]  и возвращает объект себя этого шаблонного класса.
[01:49:12.940 --> 01:49:16.940]  Потому что bind просто реализован в стандартной библиотеке как класс.
[01:49:16.940 --> 01:49:21.940]  Ну, bind, тип байнда реализован как класс.
[01:49:21.940 --> 01:49:24.940]  Ладно, мы вроде справились, да.
[01:49:24.940 --> 01:49:30.940]  А правда ли, что до появления ASTO никаких лямбдов или лямбдов не могло быть?
[01:49:30.940 --> 01:49:34.940]  Я не знаю, могло ли быть, но они появились одновременно.
[01:49:34.940 --> 01:49:38.940]  Я имею в виду, что нельзя было бы объявить тип назвать крепким.
[01:49:38.940 --> 01:49:41.940]  Ну, кажется, что да, нельзя было.
[01:49:41.940 --> 01:49:43.940]  А там же такой тип был.
[01:49:43.940 --> 01:49:44.940]  Кажется, что нельзя было.
[01:49:44.940 --> 01:49:47.940]  Но в случае с bind декл-тайп...
[01:49:47.940 --> 01:49:48.940]  Да, давайте перерыв.
[01:49:48.940 --> 01:49:50.940]  Всё, мы закончили тему 13.
[01:49:51.940 --> 01:49:55.940]  Вот, значит, мы начинаем новую тему.
[01:49:55.940 --> 01:50:00.940]  Как я уже сказал, она будет называться стирание типов.
[01:50:06.940 --> 01:50:09.940]  Значит, тема 14.
[01:50:13.940 --> 01:50:16.940]  Называется type erasure.
[01:50:16.940 --> 01:50:19.940]  Стирание типов.
[01:50:19.940 --> 01:50:25.940]  И в этой главе мы окончательно превратим плюсы в питон.
[01:50:28.940 --> 01:50:34.940]  Как я уже сказал, мы с вами уже несколько раз столкнулись с ситуацией,
[01:50:34.940 --> 01:50:38.940]  что нам хотелось бы динамически подменять тип хранимого объекта.
[01:50:38.940 --> 01:50:40.940]  О, мне нужно зарядку подключить.
[01:50:42.940 --> 01:50:45.940]  Динамически подменять тип хранимого объекта.
[01:50:49.940 --> 01:50:51.940]  Например...
[01:50:55.940 --> 01:50:59.940]  Например, когда мы с вами говорили про shared PTR,
[01:50:59.940 --> 01:51:02.940]  мы поняли, что мы бы хотели, чтобы он...
[01:51:02.940 --> 01:51:06.940]  Чтобы Allocator и Deleter не были частью его типа.
[01:51:06.940 --> 01:51:09.940]  Но мы пока не умели это делать.
[01:51:09.940 --> 01:51:16.940]  Потом мы вспоминали, что мы хотим, чтобы Allocator и Deleter не были частью его типа.
[01:51:16.940 --> 01:51:18.940]  Но мы пока не умели это делать.
[01:51:18.940 --> 01:51:23.940]  Потом мы встретились с STD Function и поняли, что в самом деле она из той же серии.
[01:51:23.940 --> 01:51:28.940]  Это тоже тип, который может динамически подменять, хранить под собой разные вещи.
[01:51:30.940 --> 01:51:35.940]  И на самом деле мы в контейнерах тоже бы хотели, начиная с C++17,
[01:51:35.940 --> 01:51:40.940]  у нас есть проблема, что мы не хотим иметь Allocator частью типа контейнер.
[01:51:40.940 --> 01:51:46.940]  Это проблема, которую Комитет осознал довольно давно, но решение придумал не так давно.
[01:51:47.940 --> 01:51:50.940]  Мы начнем с очень простого.
[01:51:50.940 --> 01:51:53.940]  Мы сразу решим все эти проблемы разом.
[01:51:53.940 --> 01:51:57.940]  Я сейчас в пункте 14.1 познакомлю вас с одним замечательным классом,
[01:51:57.940 --> 01:52:00.940]  название которого я вам уже заспойлерил названием этого файла.
[01:52:00.940 --> 01:52:03.940]  Мы познакомимся с замечательным классом,
[01:52:03.940 --> 01:52:13.940]  на примере которого сразу увидим, как можно устроить динамическую типизацию в плюсах.
[01:52:14.940 --> 01:52:18.940]  Тип этот будет называться std-any.
[01:52:18.940 --> 01:52:23.940]  Он есть в стандартной библиотеке в заголочном файле any.
[01:52:23.940 --> 01:52:26.940]  Смотрите, как это чудесно работает.
[01:52:26.940 --> 01:52:31.940]  Я беру и говорю std-any a равно 5.
[01:52:31.940 --> 01:52:34.940]  А потом говорю a равно 3.14.
[01:52:34.940 --> 01:52:38.940]  А потом говорю a равно abcdf.
[01:52:38.940 --> 01:52:46.940]  А потом говорю a равно std-vector int 1,2.
[01:52:49.940 --> 01:52:51.940]  И все прекрасно работает.
[01:52:53.940 --> 01:52:56.940]  Пока мы не компилируем.
[01:52:56.940 --> 01:53:01.940]  Но нет, все работает, даже если это скомпилировать.
[01:53:02.940 --> 01:53:04.940]  Ну, вектор у меня не подключен.
[01:53:04.940 --> 01:53:07.940]  Сейчас подключим, господи, проблем-то.
[01:53:08.940 --> 01:53:13.940]  А вот тут есть логичный вопрос.
[01:53:13.940 --> 01:53:17.940]  Мы по производительности и случайно к питону такими фильмками не приближаемся?
[01:53:17.940 --> 01:53:19.940]  А вот на этот вопрос мы сейчас ответим.
[01:53:19.940 --> 01:53:24.940]  Мы сейчас с вами реализуем эдик просто в этом пункте, и вы все поймем.
[01:53:24.940 --> 01:53:29.940]  Итак, господа, этот тип, правда начиная с c++17 только появился,
[01:53:29.940 --> 01:53:33.940]  но на самом деле для его реализации не нужно ничего знать сверх того, что вы уже знаете.
[01:53:33.940 --> 01:53:40.940]  Вообще, на самом деле при ваших текущих знаниях это можно рассматривать как задачу на подумать.
[01:53:40.940 --> 01:53:44.940]  Как реализовать такое поведение?
[01:53:44.940 --> 01:53:47.940]  Нет, ну, естественно, можно реализовать такое поведение,
[01:53:47.940 --> 01:53:52.940]  что просто template-оператор присваивания игнорирует то, что ему дали.
[01:53:52.940 --> 01:53:55.940]  Это, конечно, можно, но нет, мы не такое поведение хотим.
[01:53:55.940 --> 01:53:58.940]  Мы хотим, чтобы они можно было доставать то, что в нем хранится.
[01:53:58.940 --> 01:54:02.940]  Ну, например... А, кстати, а как прочитать то, что в Any лежит?
[01:54:02.940 --> 01:54:04.940]  Вот это отличный вопрос.
[01:54:04.940 --> 01:54:06.940]  Там какой-нибудь Get и указать...
[01:54:06.940 --> 01:54:08.940]  Get с типом, правильно.
[01:54:11.940 --> 01:54:12.940]  Подождите.
[01:54:14.940 --> 01:54:17.940]  Подождите, подождите, значит, std...
[01:54:17.940 --> 01:54:20.940]  Вот, чтобы прочитать из Any то, что в нем сейчас лежит,
[01:54:20.940 --> 01:54:25.940]  есть замечательная функция, которая называется std AnyCast.
[01:54:26.940 --> 01:54:28.940]  И я говорю, к какому типу.
[01:54:31.940 --> 01:54:34.940]  Вот, я здесь говорю std AnyCast к Double,
[01:54:34.940 --> 01:54:39.940]  тут я говорю std AnyCast к чему, кстати?
[01:54:40.940 --> 01:54:43.940]  Хонс Чар, наверное, звездочки.
[01:54:44.940 --> 01:54:48.940]  Я, кстати, не уверен, может быть и к String.
[01:54:48.940 --> 01:54:49.940]  Ну, сейчас проверим.
[01:54:49.940 --> 01:54:50.940]  А тут к Intu.
[01:54:50.940 --> 01:54:51.940]  Ну, не суть там.
[01:54:51.940 --> 01:54:54.940]  Если конча звездочка не сработает, напишем String.
[01:54:54.940 --> 01:54:55.940]  Вот.
[01:54:55.940 --> 01:54:57.940]  Да, все работает прекрасно.
[01:54:58.940 --> 01:54:59.940]  Что, если я не отгадаю тип?
[01:54:59.940 --> 01:55:02.940]  Например, вот здесь я напишу
[01:55:03.940 --> 01:55:07.940]  опять AnyCast к конча звездочки, хотя на самом деле там уже вектор лежит.
[01:55:07.940 --> 01:55:08.940]  Ну, ты проиграл.
[01:55:08.940 --> 01:55:09.940]  А что будет?
[01:55:09.940 --> 01:55:10.940]  Ну, нет.
[01:55:10.940 --> 01:55:12.940]  Убе это как-то слишком жестко.
[01:55:12.940 --> 01:55:14.940]  Все-таки нет.
[01:55:14.940 --> 01:55:16.940]  Но будет exception.
[01:55:16.940 --> 01:55:17.940]  Логично.
[01:55:18.940 --> 01:55:19.940]  Bad AnyCast.
[01:55:20.940 --> 01:55:21.940]  Специальный тип exception.
[01:55:22.940 --> 01:55:23.940]  Как он понял, что...
[01:55:23.940 --> 01:55:26.940]  А вот он должен...
[01:55:27.940 --> 01:55:28.940]  Там...
[01:55:28.940 --> 01:55:31.940]  Ну, он должен понимать, какой тип в нем лежит, конечно.
[01:55:31.940 --> 01:55:32.940]  Зачем?
[01:55:34.940 --> 01:55:37.940]  Ну, например, для того, чтобы мы могли
[01:55:37.940 --> 01:55:39.940]  спрашивать его, что в нем сейчас лежит.
[01:55:41.940 --> 01:55:42.940]  А зачем тогда...
[01:55:42.940 --> 01:55:45.940]  Понимать, что в нем лежит, надо и для более прагматичных целей.
[01:55:45.940 --> 01:55:46.940]  Например...
[01:55:46.940 --> 01:55:51.940]  Если он понимает, что в нем лежит, зачем мы ему шаблонный параметр для AnyCast придаем вообще?
[01:55:51.940 --> 01:55:53.940]  Зачем нам вообще AnyCast?
[01:55:53.940 --> 01:55:54.940]  Почему...
[01:55:59.940 --> 01:56:01.940]  Почему тогда этот костюм используем?
[01:56:01.940 --> 01:56:02.940]  Давай...
[01:56:02.940 --> 01:56:04.940]  Вот над каким вопросом задумываемся сейчас.
[01:56:05.940 --> 01:56:07.940]  Допустим, в нем лежит вектор.
[01:56:07.940 --> 01:56:09.940]  И потом я говорю, а равно...
[01:56:09.940 --> 01:56:10.940]  Вот я делаю это.
[01:56:11.940 --> 01:56:14.940]  А я сейчас вопрос напишу.
[01:56:18.940 --> 01:56:21.940]  А как вектор-то уничтожается?
[01:56:23.940 --> 01:56:25.940]  Кто-нибудь вызывает деструктор вектора и в какой момент?
[01:56:25.940 --> 01:56:28.940]  И как он понимает, что надо вызвать деструктор вектора сейчас?
[01:56:28.940 --> 01:56:30.940]  Когда у него типы не совпадают.
[01:56:31.940 --> 01:56:34.940]  А как он понимает, что нужно вызвать деструктор вектора?
[01:56:34.940 --> 01:56:35.940]  Вот именно.
[01:56:35.940 --> 01:56:37.940]  Он должен знать, какой у него тип.
[01:56:37.940 --> 01:56:41.940]  Как минимум для того, чтобы корректно уничтожать то, что в нем раньше лежало.
[01:56:43.940 --> 01:56:46.940]  А зачем тогда мы для AnyCast даем ему тип?
[01:56:47.940 --> 01:56:54.940]  А как бы ты представлял себе это без указания типа?
[01:56:55.940 --> 01:56:59.940]  Ну просто видишь ли, если бы ты не говорил о том, что у него тип...
[01:57:00.940 --> 01:57:05.940]  Ну просто видишь ли, если бы ты не говорил AnyCast, то ты бы...
[01:57:05.940 --> 01:57:08.940]  Что? У тебя было бы A, у A тип Any.
[01:57:08.940 --> 01:57:12.940]  Я не мог бы в SDC Out, например, отдать Any.
[01:57:12.940 --> 01:57:17.940]  Ну это что? Это должно компилироваться или нет, если пишу SDC Out A?
[01:57:17.940 --> 01:57:20.940]  A это Any. Там может быть что угодно.
[01:57:20.940 --> 01:57:23.940]  Ну вообще говоря, не все может выводиться в C Out.
[01:57:23.940 --> 01:57:27.940]  Просто в некоторых ситуациях мне нужно посмотреть на Any как на что-то конкретное.
[01:57:27.940 --> 01:57:30.940]  Чтобы C Out, например, знал, что в него сейчас выводят.
[01:57:30.940 --> 01:57:40.940]  Нельзя сделать тип Any Value, который будет наследником какой-нибудь общей фигни.
[01:57:40.940 --> 01:57:42.940]  Что-что-что? Any Value?
[01:57:42.940 --> 01:57:46.940]  Шарлонный тип Any Value, который типа T.
[01:57:46.940 --> 01:57:49.940]  И он наследуется в какой-нибудь общей фигни.
[01:57:49.940 --> 01:57:52.940]  Мы у себя храним указатель на общую фигню.
[01:57:52.940 --> 01:57:55.940]  Ты сейчас мне расскажешь, как Any реализовать или что?
[01:57:55.940 --> 01:57:56.940]  Ну да.
[01:57:56.940 --> 01:57:58.940]  Спасибо. Молодец.
[01:57:58.940 --> 01:58:03.940]  Ты придумал как резотение.
[01:58:03.940 --> 01:58:04.940]  Классно.
[01:58:07.940 --> 01:58:10.940]  Ну да, ты только что решил задачу реализации.
[01:58:10.940 --> 01:58:12.940]  Там только надо Vertical написать, где надо.
[01:58:12.940 --> 01:58:14.940]  Да, да, так и надо.
[01:58:14.940 --> 01:58:16.940]  Все, можешь идти писать shared PTR.
[01:58:16.940 --> 01:58:18.940]  Тебе это и нужно там сделать.
[01:58:20.940 --> 01:58:24.940]  Только там Deletor и Allocator нужно одновременно разными поддерживать.
[01:58:27.940 --> 01:58:30.940]  Давайте поговорим о том, как реализовать Any.
[01:58:39.940 --> 01:58:45.940]  Действительно, ну а кто, кроме господина Андрусова, да, Андрусов?
[01:58:45.940 --> 01:58:51.940]  Андрусов, да, извиняюсь, понял, что сделать надо.
[01:58:51.940 --> 01:59:01.940]  Как же нам добиться такого поведения, используя известные нам средства языка?
[01:59:01.940 --> 01:59:05.940]  То есть на самом деле я вам сейчас никакой лайфхак не расскажу,
[01:59:05.940 --> 01:59:10.940]  ну в смысле я не расскажу вам сейчас ничего нового,
[01:59:10.940 --> 01:59:14.940]  в смысле каких-то языковых средств, которых мы раньше не проходили.
[01:59:14.940 --> 01:59:18.940]  Надо просто с умом использовать то, что мы уже знаем.
[01:59:18.940 --> 01:59:22.940]  Ну, казалось бы, да, это какой-нибудь указатель на void.
[01:59:22.940 --> 01:59:24.940]  И чего?
[01:59:24.940 --> 01:59:30.940]  Вот если мы будем хранить void звездочку, то как мы будем понимать какой это тип, чтобы его корректно уничтожать?
[01:59:30.940 --> 01:59:32.940]  А вот это уже другой вопрос.
[01:59:32.940 --> 01:59:34.940]  Да, в этом главная сложность.
[01:59:34.940 --> 01:59:36.940]  Сохранить указатель на функцию деструктора.
[01:59:36.940 --> 01:59:44.940]  Да, можно, конечно, сохранить указатель на объект, а также указатель на...
[01:59:44.940 --> 01:59:46.940]  Указатель на метод деструктора.
[01:59:46.940 --> 01:59:52.940]  А также указатель на соответствующие его методы, которые надо вызывать в случае,
[01:59:52.940 --> 01:59:57.940]  когда, например, мы присваиваем один другому, когда мы уничтожаем, когда мы копируем и так далее.
[01:59:57.940 --> 02:00:01.940]  Тяжеловесно.
[02:00:01.940 --> 02:00:06.940]  Нет, это как раз более эффективная реализация была бы.
[02:00:06.940 --> 02:00:12.940]  Но мы сейчас напишем более простую, но менее эффективную реализацию.
[02:00:12.940 --> 02:00:17.940]  Вот именно так, как я сейчас сказал, фанкшн реализована.
[02:00:17.940 --> 02:00:19.940]  Вот именно так.
[02:00:19.940 --> 02:00:21.940]  Потом.
[02:00:21.940 --> 02:00:23.940]  Вот будем реализовывать фанкшн, увидишь.
[02:00:23.940 --> 02:00:25.940]  Пока мы простую реализацию обсуждаем.
[02:00:25.940 --> 02:00:27.940]  Мы, по сути, что вы предлагаете сделать?
[02:00:27.940 --> 02:00:35.940]  Давайте хранить void звездочку, а также хранить поинтеры на методы соответствующие, которые надо вызывать, когда что-то происходит с объектом.
[02:00:35.940 --> 02:00:43.940]  Так я говорю, а зачем это делать, если у нас уже в языке есть механизм, делающий то же самое за нас?
[02:00:43.940 --> 02:00:45.940]  Знаете, как он называется?
[02:00:45.940 --> 02:00:47.940]  Таблица виртуальных функций.
[02:00:47.940 --> 02:00:53.940]  Ведь, по сути, то, что вы сейчас предложили, это давайте напишем свою таблицу виртуальных функций просто для этого объекта.
[02:00:53.940 --> 02:00:57.940]  Но ведь, по сути, у нас уже есть механизм в языке, который нам это и делает.
[02:00:57.940 --> 02:01:07.940]  Он хранит typeinfo, а также указательный на то, что делать с объектом, если с ним деструктор вызвался, что-нибудь еще сделалось, что-нибудь еще сделалось и так далее.
[02:01:07.940 --> 02:01:16.940]  Ну, конечно же, логично, что если мы хотим runtime типизацию, нам нужен runtime полиморфизм, то нам нужно использовать virtual.
[02:01:16.940 --> 02:01:24.940]  Вот вы так много внифпопад говорили, давайте сделаем что-нибудь виртуальным, отнаследуемся виртуально, что-нибудь еще сделаем.
[02:01:24.940 --> 02:01:33.940]  И это было совсем не нужно, в итераторах это все не нужно, потому что там все в шаблонах, там все делается в compile-time.
[02:01:33.940 --> 02:01:38.940]  Вот сейчас настал момент, когда нам нужны виртуальные функции, наконец-то, по-настоящему.
[02:01:38.940 --> 02:01:47.940]  Мы просто сделаем сейчас динамический полиморфизм, мы просто сделаем, что компилятор за нас будет помнить, какой тип там лежит и вызывать ему правильные методы.
[02:01:47.940 --> 02:01:49.940]  А как мы этого добьемся?
[02:01:49.940 --> 02:01:51.940]  А у нас будет следующая...
[02:01:51.940 --> 02:01:53.940]  У нас будет виртуальный деструктор.
[02:01:53.940 --> 02:01:55.940]  Хитрость, конечно, у нас будет виртуальный деструктор.
[02:01:55.940 --> 02:02:03.940]  У нас будет следующая интересная структура, давайте я назову base, в которой будет виртуальный деструктор.
[02:02:08.940 --> 02:02:12.940]  Ну, я даже не знаю чисто виртуально, но давайте я напишу равно default.
[02:02:12.940 --> 02:02:14.940]  Зачем мне виртуальный деструктор?
[02:02:14.940 --> 02:02:17.940]  Ну, для того, чтобы этот тип полиморфным стал.
[02:02:17.940 --> 02:02:19.940]  А теперь смотрите, что я говорю.
[02:02:19.940 --> 02:02:29.940]  Говорите play type name t, struct derived, это наследник base.
[02:02:36.940 --> 02:02:37.940]  Вот.
[02:02:37.940 --> 02:02:46.940]  Что на самом деле происходит?
[02:02:46.940 --> 02:02:48.940]  Что я храню?
[02:02:48.940 --> 02:02:50.940]  А я храню указательно base.
[02:02:55.940 --> 02:02:59.940]  Что происходит, когда я создаю any?
[02:02:59.940 --> 02:03:03.940]  Ну, у меня очевидно должен быть шаблонный конструктор.
[02:03:07.940 --> 02:03:11.940]  Any от t.
[02:03:15.940 --> 02:03:17.940]  Давайте назвать p obj.
[02:03:17.940 --> 02:03:19.940]  И что я делаю?
[02:03:21.940 --> 02:03:23.940]  Чем я инициализирую p obj?
[02:03:27.940 --> 02:03:34.940]  Я говорю p obj это new.
[02:03:34.940 --> 02:03:46.940]  Сейчас, если вы внимательно слушаете лекции, у вас должно быть в глубине неприятное ощущение.
[02:03:46.940 --> 02:03:50.940]  Как же это не new, а как же allocator?
[02:03:50.940 --> 02:03:55.940]  Но нет, мы уже забили на allocator к этому моменту.
[02:03:55.940 --> 02:04:01.940]  То есть мы пишем any, в any тоже нестандартный allocator не поддерживается.
[02:04:01.940 --> 02:04:09.940]  Комитет решил, что нет, это overkill поддерживает allocator.
[02:04:09.940 --> 02:04:13.940]  Тем более мы скоро придумаем allocator, который динамически подменяемый.
[02:04:13.940 --> 02:04:15.940]  Ну так вот.
[02:04:15.940 --> 02:04:20.940]  Использование слишком чрезмерное переусложнение.
[02:04:20.940 --> 02:04:34.940]  New derived с шаблонным параметром t от obj.
[02:04:34.940 --> 02:04:52.940]  А что делает диструктор any?
[02:04:52.940 --> 02:05:02.940]  И о чудо!
[02:05:02.940 --> 02:05:04.940]  Это же корректная работа.
[02:05:04.940 --> 02:05:06.940]  Правда у нас derived еще должен уметь создаваться.
[02:05:06.940 --> 02:05:10.940]  А derived от чего должен уметь создаваться?
[02:05:10.940 --> 02:05:15.940]  От const t obj и что в нем должно быть?
[02:05:15.940 --> 02:05:18.940]  А в нем просто этот объект и будет лежать.
[02:05:18.940 --> 02:05:20.940]  И о чудо!
[02:05:20.940 --> 02:05:23.940]  Вот и все, вот и все работает.
[02:05:23.940 --> 02:05:29.940]  Вот и вся почти реализация.
[02:05:29.940 --> 02:05:36.940]  Я наоборот утверждал, что это работает менее эффективно.
[02:05:36.940 --> 02:05:46.940]  Я наоборот утверждал, что это работает менее эффективно.
[02:05:46.940 --> 02:05:56.940]  Сейчас мы это обсудим, давайте сначала все поймут, что это работает как надо.
[02:05:56.940 --> 02:06:00.940]  Еще правда нам надо оператор присваивания и конструктор копирования, но сейчас мы напишем.
[02:06:00.940 --> 02:06:06.940]  Это называется idioma type erasure.
[02:06:06.940 --> 02:06:10.940]  На самом деле type erasure называется как раз вот это.
[02:06:10.940 --> 02:06:19.940]  Там спорный вопрос, что именно сейчас принято называть type erasure, но вот это классическая type erasure.
[02:06:19.940 --> 02:06:25.940]  Это способ хранить в объекте вещи переменного типа и динамически подменять их.
[02:06:25.940 --> 02:06:30.940]  Почему это корректно работает? Как работает delete p obj?
[02:06:30.940 --> 02:06:36.940]  За счет виртуального деструктора он понимает, что ему реально нужно сделать в деструкторе.
[02:06:36.940 --> 02:06:41.940]  В частности он понимает, что ему надо уничтожить вот это.
[02:06:41.940 --> 02:06:50.940]  Здесь t является полем, но он его тоже корректно уничтожит, потому что деструктор виртуальный, а виртуальный деструктор он корректно отрабатывает на наследниках.
[02:06:50.940 --> 02:07:02.940]  Я уже унаследовался от Base, а у Base виртуальный деструктор.
[02:07:02.940 --> 02:07:09.940]  Это уже значит, что у меня тоже деструктор виртуальный, а значит все будет корректно отрабатывать.
[02:07:09.940 --> 02:07:14.940]  Если бы я здесь не написал вот этого, то все бы конечно не работало.
[02:07:14.940 --> 02:07:19.940]  Работа компилировалась бы, но были бы утечки памяти постоянно.
[02:07:19.940 --> 02:07:22.940]  Ну мы хотим еще оператора присваивания.
[02:07:22.940 --> 02:07:28.940]  Давайте напишем конструктор копирования для начала, вот это интересно.
[02:07:28.940 --> 02:07:36.940]  А еще разве мы не хотим конструктор по умолчанию, который не создает указатель?
[02:07:36.940 --> 02:07:44.940]  Ну как, чтобы я мог сказать std any, я могу сказать auto b равно a, вот я могу так написать?
[02:07:44.940 --> 02:07:47.940]  Как это не могу? Должен уметь.
[02:07:47.940 --> 02:07:52.940]  Нет, со std я могу, это же std any.
[02:07:52.940 --> 02:07:55.940]  Стандартный any конечно можно копировать.
[02:07:55.940 --> 02:08:04.940]  Вот, когда-то это тоже была задачей на отл, но теперь это стало задачей на хор,
[02:08:04.940 --> 02:08:09.940]  потому что язык развивается, как известно.
[02:08:09.940 --> 02:08:13.940]  Так, на самом деле это тоже интересный вопрос.
[02:08:13.940 --> 02:08:15.940]  Как написать конструктор копирования?
[02:08:15.940 --> 02:08:25.940]  Мне нужно написать any от const any % other, давайте скажу.
[02:08:25.940 --> 02:08:28.940]  И что сделать надо?
[02:08:34.940 --> 02:08:36.940]  Конструктор не бывает виртуальными.
[02:08:36.940 --> 02:08:46.940]  Значит, вопрос, что написать? Вот это задача на подумать.
[02:08:46.940 --> 02:08:52.940]  Да, вот мне нужно скопировать any, чтобы все так же получилось.
[02:08:52.940 --> 02:09:02.940]  Откуда я знаю, какой t там был?
[02:09:03.940 --> 02:09:10.940]  Все, тихо молчи, ты понял, давайте еще кто-нибудь поймет.
[02:09:10.940 --> 02:09:14.940]  Он догадался, еще кто-нибудь догадайтесь.
[02:09:22.940 --> 02:09:28.940]  Ну ладно, ну да, надо сделать просто еще одну виртуальную функцию вот здесь.
[02:09:28.940 --> 02:09:31.940]  Давайте я назову ее getCopy.
[02:09:39.940 --> 02:09:42.940]  Ну она будет pure virtual, пускай.
[02:09:42.940 --> 02:09:48.940]  Вот, а здесь она будет реализована, как она будет реализована?
[02:09:48.940 --> 02:09:54.940]  Ну она будет, ну я могу сказать авто, ну нет, мне надо сказать все-таки.
[02:09:54.940 --> 02:10:01.940]  B и звездочка, getCopy, override.
[02:10:01.940 --> 02:10:04.940]  Мы же можем написать rewrite в звездочку.
[02:10:04.940 --> 02:10:10.940]  Где? Здесь? Не, мне нужна функция с такой же сигнатурой, иначе override не сработает, напоминаю.
[02:10:13.940 --> 02:10:17.940]  Ну я делаю override, это значит мне нужно полностью соответствовать.
[02:10:17.940 --> 02:10:21.940]  Вот, и что эта функция будет возвращать? Да просто она будет возвращать, return.
[02:10:24.940 --> 02:10:33.940]  Ну return u derived t от obj.
[02:10:33.940 --> 02:10:38.940]  Да, можно и не писать здесь t.
[02:10:38.940 --> 02:10:45.940]  Соответственно, что должна делать? Должен конструктор копирования, но он должен просто делать pobj,
[02:10:45.940 --> 02:10:56.940]  инициализировать его other, getCopy, да и все.
[02:10:56.940 --> 02:11:09.940]  Нет, other.pobj.getCopy, other.pobj.getCopy, да.
[02:11:09.940 --> 02:11:19.940]  Давайте напишем boop-конструктор.
[02:11:19.940 --> 02:11:28.940]  Ну видимо мы тоже должны делать такой.
[02:11:28.940 --> 02:11:37.940]  А, указатель.
[02:11:37.940 --> 02:11:43.940]  А что намешается брать просто указатель? Да, move-конструктор вообще тривиальный, можно сказать.
[02:11:43.940 --> 02:11:54.940]  pobj просто other.pobj, other.pobj равно nullptr.
[02:11:54.940 --> 02:11:58.940]  Ну можно написать оператор присваивания еще, но не будем.
[02:11:58.940 --> 02:12:01.940]  Вот, такие дела.
[02:12:01.940 --> 02:12:06.940]  std any.
[02:12:06.940 --> 02:12:10.940]  Давайте посмотрим на cpp-reference.
[02:12:10.940 --> 02:12:15.940]  Может быть там еще есть что-нибудь интересное, о чем стоит.
[02:12:15.940 --> 02:12:23.940]  std any, any это конструктор.
[02:12:23.940 --> 02:12:27.940]  Что это похоже на node-based node?
[02:12:27.940 --> 02:12:31.940]  Да что вы говорите, наследование они вообще...
[02:12:31.940 --> 02:12:32.940]  Похоже.
[02:12:32.940 --> 02:12:35.940]  Да, еще похоже на mother и son тоже.
[02:12:35.940 --> 02:12:37.940]  Знаете, была такая чувство.
[02:12:37.940 --> 02:12:47.940]  Крайне с медведем, да.
[02:12:47.940 --> 02:12:51.940]  Ну, к сожалению, cpp-reference нас не радует сегодня.
[02:12:51.940 --> 02:13:01.940]  Ну что, господа, самое время понять, как же устроен shared-ptr на самом деле.
[02:13:01.940 --> 02:13:09.940]  Да, в shared-ptr используются виртуальные функции.
[02:13:09.940 --> 02:13:14.940]  Если вы откроете код настоящего shared-ptr, вы увидите там слово virtual.
[02:13:14.940 --> 02:13:20.940]  Потому что там используется именно эта идиома type-array.
[02:13:20.940 --> 02:13:28.940]  У меня уже было, вот здесь вот, был черновичок shared-ptr.
[02:13:28.940 --> 02:13:30.940]  Напоминаю.
[02:13:30.940 --> 02:13:34.940]  Значит, да, у меня будет пункт 14.2.
[02:13:34.940 --> 02:13:47.940]  Называться shared-ptr with custom deleter and allocator.
[02:13:47.940 --> 02:14:06.940]  Давайте для начала придумаем, как сделать custom deleter shared-ptr.
[02:14:06.940 --> 02:14:15.940]  Все-таки в том примере с base-derived там можно у переопределяемого метода было делать указательный derived, а не на base.
[02:14:15.940 --> 02:14:17.940]  Да.
[02:14:17.940 --> 02:14:22.940]  И override написать, и он бы не ругался.
[02:14:22.940 --> 02:14:28.940]  Это вроде просто захархожено, что так можно делать.
[02:14:28.940 --> 02:14:43.940]  Давай попробую.
[02:14:43.940 --> 02:14:46.940]  Ну ладно.
[02:14:46.940 --> 02:14:48.940]  Значит, можно и так.
[02:14:48.940 --> 02:14:53.940]  Я здесь тип не точно назвал.
[02:14:53.940 --> 02:14:59.940]  Я, наверное, могу просто сказать авто и не париться.
[02:14:59.940 --> 02:15:00.940]  Все.
[02:15:00.940 --> 02:15:02.940]  Надежно.
[02:15:02.940 --> 02:15:05.940]  Так.
[02:15:05.940 --> 02:15:06.940]  Так вот.
[02:15:06.940 --> 02:15:07.940]  Что же с shared-ptr?
[02:15:07.940 --> 02:15:12.940]  Вы помните, какая проблема-то была?
[02:15:12.940 --> 02:15:16.940]  У shared-ptr может быть custom deleter.
[02:15:16.940 --> 02:15:24.940]  И allocator.
[02:15:24.940 --> 02:15:34.940]  Не, но как сказать.
[02:15:34.940 --> 02:15:39.940]  Вы все-таки не хотите, чтобы можно было любой любой объект туда класть?
[02:15:39.940 --> 02:15:44.940]  Надо, чтобы там все-таки лежал allocator какой-то.
[02:15:44.940 --> 02:15:49.940]  Давайте, вам это писать.
[02:15:49.940 --> 02:15:53.940]  Я сейчас не буду реализовывать shared-ptr за вас.
[02:15:53.940 --> 02:15:59.940]  Я только попробую сказать обтекаемо, как его нужно делать, чтобы все работало в нем.
[02:15:59.940 --> 02:16:03.940]  А как вообще, что хранить в shared-ptr?
[02:16:03.940 --> 02:16:08.940]  Мы поняли, что в shared-ptr, вы помните вообще, что в shared-ptr нам хранить приходилось?
[02:16:08.940 --> 02:16:11.940]  У нас, во-первых, был ptr и count.
[02:16:11.940 --> 02:16:16.940]  Но потом мы поняли, что нам нужно на самом деле shared-count и weak-count отдельно.
[02:16:16.940 --> 02:16:20.940]  А потом мы поняли, что у нас вообще еще control-block должен быть иногда.
[02:16:20.940 --> 02:16:23.940]  Иногда нет.
[02:16:23.940 --> 02:16:24.940]  Так вот, есть следующее предложение.
[02:16:24.940 --> 02:16:32.940]  Давайте сделаем структуру base-control-block.
[02:16:32.940 --> 02:16:34.940]  Смотрите.
[02:16:34.940 --> 02:16:40.940]  Я заведу такую структуру.
[02:16:40.940 --> 02:16:47.940]  Base-control-block, в которой будет нечто общее для всех control-block.
[02:16:47.940 --> 02:16:50.940]  А это что?
[02:16:50.940 --> 02:17:04.940]  Это shared-count и weak-count.
[02:17:04.940 --> 02:17:09.940]  А также там будет виртуальная вот эта штука.
[02:17:09.940 --> 02:17:14.940]  Там еще будут всякие штуки для копирования нужные.
[02:17:14.940 --> 02:17:20.940]  А дальше мне нужно два разных control-block.
[02:17:20.940 --> 02:17:29.940]  Один на случай, если осознан через make-shared, а другой на случай, если осознан не через make-shared.
[02:17:29.940 --> 02:17:35.940]  Помните, в чем разница, если осознан через make-shared и не через make-shared?
[02:17:35.940 --> 02:17:40.940]  Если осознан через make-shared, у меня на самом деле две...
[02:17:40.940 --> 02:17:47.940]  Господи, да какой же ты.
[02:17:47.940 --> 02:17:56.940]  Давайте я попробую shared-ptr открыть.
[02:17:56.940 --> 02:18:00.940]  Конструктор shared-ptr я попробую открыть.
[02:18:00.940 --> 02:18:08.940]  Мне нужно посмотреть какие конструкторы у shared-ptr.
[02:18:08.940 --> 02:18:20.940]  Есть две разных ситуации. Я могу создавать shared-ptr напрямую, а могу создавать через make-shared.
[02:18:20.940 --> 02:18:23.940]  Если я создаю через...
[02:18:23.940 --> 02:18:27.940]  Эни прогрузился, я надеюсь сейчас shared-ptr прогрузится.
[02:18:27.940 --> 02:18:35.940]  Если я создаю shared-ptr напрямую, то у меня что может быть?
[02:18:35.940 --> 02:18:46.940]  У меня может быть кастомный deletor, кастомный allocator.
[02:18:46.940 --> 02:18:50.940]  Ну и, собственно, мне надо хранить сам pointer на объект.
[02:18:50.940 --> 02:18:58.940]  Мне надо хранить объект allocator, объект deletor и pointer на сам объект, на t.
[02:18:58.940 --> 02:19:02.940]  Если я создаюсь через make-shared, что у меня может быть?
[02:19:02.940 --> 02:19:13.940]  У меня все еще может быть кастомный allocator, но кастомного deletor у меня уже не может быть.
[02:19:13.940 --> 02:19:32.940]  Кастомный deletor может быть только если я создаюсь напрямую, а не через make-shared.
[02:19:32.940 --> 02:19:39.940]  Потому что если я создаюсь через make-shared, то make-shared за меня создает объект.
[02:19:39.940 --> 02:19:40.940]  Что такое make-shared?
[02:19:40.940 --> 02:19:42.940]  Это за меня выдели память и создай объект.
[02:19:42.940 --> 02:19:45.940]  И тогда deletor считается, что должен...
[02:19:45.940 --> 02:19:52.940]  Кастомный deletor нужен на случай, если в момент удаления вам нужно не delete сделать, а что-то другое.
[02:19:52.940 --> 02:19:56.940]  Но make-shared сам за вас делает new.
[02:19:56.940 --> 02:20:00.940]  Ну тогда у вас не должно быть свободы вместо delete сделать что-то другое.
[02:20:00.940 --> 02:20:04.940]  Если вы создаетесь через make-shared, то есть просите за вас его вызвать new,
[02:20:04.940 --> 02:20:14.940]  то вы тем самым подразумеваете, что вместо, что в момент удаления надо будет сделать delete.
[02:20:14.940 --> 02:20:23.940]  Сейчас, но ведь вот когда мы делали, допустим, delete с локатором, у нас же был...
[02:20:23.940 --> 02:20:27.940]  У нас просили сделать...
[02:20:27.940 --> 02:20:31.940]  Просили выделить память, но не для t, а для base-node.
[02:20:31.940 --> 02:20:33.940]  Нет, это уже другая проблема.
[02:20:33.940 --> 02:20:34.940]  Это rebind локаторов.
[02:20:34.940 --> 02:20:36.940]  Ребайнт локаторов вы тоже сделаете сами.
[02:20:36.940 --> 02:20:38.940]  Ну вот а в чем проблема здесь?
[02:20:38.940 --> 02:20:41.940]  Точно так же для rebind локатора на...
[02:20:41.940 --> 02:20:43.940]  Подожди, я сейчас вообще про другую проблему говорю.
[02:20:43.940 --> 02:20:47.940]  Я говорю про проблему того, что deleter может быть кастомный, а может не быть.
[02:20:47.940 --> 02:20:50.940]  Deleter и allocator это разные сущности.
[02:20:50.940 --> 02:20:55.940]  Понимаете, у тебя может быть одновременно и deleter, и allocator отдельно переданы.
[02:20:55.940 --> 02:21:01.940]  Почему у make-shared у нас нет deleter?
[02:21:01.940 --> 02:21:02.940]  Еще раз объясняю.
[02:21:02.940 --> 02:21:03.940]  Что такое deleter вообще?
[02:21:03.940 --> 02:21:05.940]  Это что за штуковина?
[02:21:05.940 --> 02:21:10.940]  Deleter это функция, это функциональный объект, который с оператором круглые скобочки,
[02:21:10.940 --> 02:21:16.940]  который будет вызван над вашим pointer вместо delete-pointer.
[02:21:16.940 --> 02:21:22.940]  Вы можете хотеть, чтобы sharedptr, когда отпускал ваш объект, когда уничтожал его,
[02:21:22.940 --> 02:21:24.940]  не освобождал память, а что-то другое делал.
[02:21:24.940 --> 02:21:29.940]  Например, закрывал файл, если ваш объект был файлом.
[02:21:29.940 --> 02:21:34.940]  Или разрывал соединение по сети, если ваш объект был сетью.
[02:21:34.940 --> 02:21:38.940]  Или разлучивал mutex, если вы знаете, что это такое.
[02:21:38.940 --> 02:21:40.940]  Если ваш объект был mutex-ом.
[02:21:40.940 --> 02:21:44.940]  Не delete делать нужно в конце, когда вы закончили поле с объектом, а что-то иное.
[02:21:44.940 --> 02:21:50.940]  Deleter это функция, которая выполняется вместо delete над вашим объектом,
[02:21:50.940 --> 02:21:52.940]  когда последний sharedptr на него умирает.
[02:21:52.940 --> 02:21:55.940]  Это понятно, но почему при make-shared нельзя?
[02:21:55.940 --> 02:21:58.940]  Потому что make-shared за вас делает new.
[02:21:58.940 --> 02:22:04.940]  А значит, при удалении надо сделать именно delete, а не что-то другое.
[02:22:04.940 --> 02:22:06.940]  Илья, вот такой вопрос.
[02:22:06.940 --> 02:22:10.940]  Почему эту функцию, эту функциональную нельзя поместить в destructor?
[02:22:10.940 --> 02:22:12.940]  Кого?
[02:22:12.940 --> 02:22:14.940]  Ну, вот то, что мы хотим делать.
[02:22:14.940 --> 02:22:16.940]  Destructor кого?
[02:22:16.940 --> 02:22:18.940]  Destructor кого?
[02:22:18.940 --> 02:22:21.940]  Объекта, на которые указывают наш птр.
[02:22:21.940 --> 02:22:24.940]  Оно не дало видение правого места destructor.
[02:22:26.940 --> 02:22:31.940]  Нет, ну вот допустим, у меня есть sharedptr, который указывает на объект файла.
[02:22:31.940 --> 02:22:35.940]  Почему я в destructor не могу прописать?
[02:22:35.940 --> 02:22:40.940]  Если у тебя хранится указатель на него.
[02:22:40.940 --> 02:22:49.940]  Я же буду вызывать destructor, когда кончились ссылки.
[02:23:01.940 --> 02:23:03.940]  Ну, наверное, можешь.
[02:23:15.940 --> 02:23:18.940]  Ну, тогда тебе в deletre вообще ничего не надо будет делать.
[02:23:18.940 --> 02:23:20.940]  Ну, вот да.
[02:23:20.940 --> 02:23:23.940]  В этом и вопрос. Откуда появилась идея делать deletre?
[02:23:23.940 --> 02:23:27.940]  Просто мне казалось, что специально ровно для этого мы придумали destructor.
[02:23:27.940 --> 02:23:29.940]  Нет, ребята.
[02:23:31.940 --> 02:23:37.940]  Сейчас я подумаю.
[02:23:37.940 --> 02:23:39.940]  Какой-нибудь другой сценарий.
[02:23:39.940 --> 02:24:02.940]  Типа, если у меня соединение по сети, то destructor этого соединения просто делает там разъединение.
[02:24:02.940 --> 02:24:05.940]  Если у меня файл, то destructor этого файла.
[02:24:05.940 --> 02:24:11.940]  Тут, наверное, видишь какой момент.
[02:24:11.940 --> 02:24:17.940]  У тебя эта штука, на которую ты держишь указатель, она может не быть объектом даже.
[02:24:17.940 --> 02:24:26.940]  Но если ты работаешь с каким-нибудь сичным интерфейсом, у тебя указатель на файл, это даже не объект.
[02:24:26.940 --> 02:24:31.940]  Это указатель на какую-нибудь структуру, которая ничего не умеет сама по себе.
[02:24:31.940 --> 02:24:36.940]  Как и socket сетевой.
[02:24:36.940 --> 02:24:39.940]  Он хранит себе какие-то числа, и ничего больше не умеет.
[02:24:39.940 --> 02:24:44.940]  И все, что ты с ним делаешь, в функциональном стиле, ты над ним выполняешь некоторые операции.
[02:24:44.940 --> 02:24:54.940]  И вот в таком сценарии, если у тебя указатель хранит какую-нибудь штуку, которая не в объектно-ориентированном стиле написана, а просто которая...
[02:24:54.940 --> 02:24:56.940]  Сичный pointer на что-то.
[02:24:56.940 --> 02:25:00.940]  Ну, в общем-то, да, если у тебя штука была бы...
[02:25:00.940 --> 02:25:03.940]  SharedPattern хранит сичный pointer.
[02:25:07.940 --> 02:25:11.940]  Это штука, над которой в конце надо, может быть, что-то сделать.
[02:25:11.940 --> 02:25:15.940]  С этим pointer нужно вызвать над ним какую-нибудь функцию.
[02:25:15.940 --> 02:25:17.940]  А сам он не умеет.
[02:25:17.940 --> 02:25:24.940]  Например, сичный файл, дескриптор сичного файла, как он там называется, он не умеет для себя ничего делать.
[02:25:25.940 --> 02:25:27.940]  Да-да-да-да.
[02:25:27.940 --> 02:25:29.940]  Ну, например, такое.
[02:25:30.940 --> 02:25:34.940]  То же самое с сетевыми штуками, если у тебя есть сетевой socket какой-нибудь.
[02:25:34.940 --> 02:25:36.940]  Он точно так же устроен, он ничего не умеет.
[02:25:36.940 --> 02:25:42.940]  Т.е. пилитер, по сути, это такой кастрид для случаев, когда у нас не объект, а дескриптор все-таки нужен.
[02:25:42.940 --> 02:25:44.940]  Ну, типа того, да.
[02:25:45.940 --> 02:25:47.940]  Похоже на то.
[02:25:47.940 --> 02:25:49.940]  Что там?
[02:25:52.940 --> 02:26:01.940]  Кстати, любые сущности, связанные с низкоуровневым программированием, процесс, операционная система.
[02:26:01.940 --> 02:26:02.940]  Такая же фигня.
[02:26:02.940 --> 02:26:07.940]  Т.е. в конце надо будет, может быть, нужно что-нибудь сделать, дождаться, пока он завершится, например.
[02:26:07.940 --> 02:26:10.940]  Но он же в своем деструкторе этого не делает.
[02:26:10.940 --> 02:26:12.940]  Или trap, например, тот же самый.
[02:26:12.940 --> 02:26:16.940]  Он в своем деструкторе ничего не дожидается, он просто грохается.
[02:26:16.940 --> 02:26:20.940]  А вам, может быть, надо, прежде чем он закончится, что-то с ним сделать.
[02:26:20.940 --> 02:26:22.940]  Например, дождаться окончания.
[02:26:23.940 --> 02:26:29.940]  Ну, короче, деструктор объекта и дилитер, это, может быть, разная операция, да.
[02:26:29.940 --> 02:26:37.940]  И, возвращаясь к предыдущей теме, если мы делаемся через make-share, значит, мы не должны нестандартный дилитер использовать.
[02:26:37.940 --> 02:26:39.940]  Следующий вопрос.
[02:26:39.940 --> 02:26:44.940]  Если у нас есть нестандартный дилитер, на кой черт нам еще и нестандартный локатор может быть нужен?
[02:26:46.940 --> 02:26:54.940]  Ну, потому что выделять кого?
[02:27:00.940 --> 02:27:01.940]  Нет.
[02:27:01.940 --> 02:27:09.940]  Если у нас нестандартный дилитер, это значит, что мы создаемся через конструктор напрямую, а не через make-share.
[02:27:09.940 --> 02:27:13.940]  А это значит, что когда мы создаем share-ptr, объект уже создан.
[02:27:14.940 --> 02:27:18.940]  Для чего мы тогда локатор еще передаем нестандартный?
[02:27:18.940 --> 02:27:23.940]  Чтобы контрольный блок выделялся на нестандартном локаторе.
[02:27:23.940 --> 02:27:27.940]  Вот этот вот конструктор, вот он самый непонятный, вот этот вот.
[02:27:27.940 --> 02:27:32.940]  Зачем нам нужен одновременно и дилитер нестандартный, и локатор нестандартный?
[02:27:32.940 --> 02:27:41.940]  А для того, чтобы когда объект закончил жить, мы над ним сделали кастомную функцию, например, там файл закрыли.
[02:27:41.940 --> 02:27:47.940]  Но в то же время контрольные блоки мы выделяли не через new, а через что-то другое.
[02:27:47.940 --> 02:27:51.940]  И освобождали бы контрольные блоки счетчиками через что-то другое.
[02:27:51.940 --> 02:27:59.940]  То есть в данном случае локатор нужен для выделения контрольных блоков, а сам объект уже создан.
[02:27:59.940 --> 02:28:03.940]  И когда он уничтожается, мы не дилит делаем, а вот эту функцию дилитер.
[02:28:03.940 --> 02:28:05.940]  Но локатор кастомный.
[02:28:05.940 --> 02:28:09.940]  Короче, у нас есть два принципиально разных сценария.
[02:28:09.940 --> 02:28:14.940]  Один сценарий мы создали через мейкшерет, другой сценарий мы создали напрямую через конструктор.
[02:28:14.940 --> 02:28:24.940]  И в первом из этих сценариев нам надо хранить только локатор.
[02:28:24.940 --> 02:28:30.940]  Во втором из этих сценариев нам надо хранить и дилитер и локатор.
[02:28:30.940 --> 02:28:36.940]  Я напишу template typeNameT, typeNameU давайте скажу.
[02:28:36.940 --> 02:28:44.940]  struct controlBlockMakeshared
[02:28:47.940 --> 02:28:51.940]  Не призываю вас так ее называть, может вы придумаете название получше.
[02:28:51.940 --> 02:28:55.940]  Да, и это наследник BaseControlBlock, разумеется.
[02:28:55.940 --> 02:28:59.940]  То есть я делаю Type и Rager, но с умом.
[02:28:59.940 --> 02:29:06.940]  Мой ControlBlock он таков, что в нем будет сейчас храниться дилитер и локатор.
[02:29:06.940 --> 02:29:11.940]  Ой нет, через мейкшерет только локатор.
[02:29:11.940 --> 02:29:15.940]  Вот в ControlBlock, который для мейкшерет, только локатор хранится.
[02:29:15.940 --> 02:29:17.940]  Откуда локатор возьмется?
[02:29:17.940 --> 02:29:19.940]  Из шаблона.
[02:29:19.940 --> 02:29:22.940]  А где? Что? Написай.
[02:29:22.940 --> 02:29:25.940]  Ну вот здесь шаблон.
[02:29:26.940 --> 02:29:31.940]  А локатор это будет шаблоны параметра этой структуры, а не самого SharedPTR, для чего мы и старались.
[02:29:31.940 --> 02:29:35.940]  Ну а лок, наверное, равно для локатора?
[02:29:35.940 --> 02:29:40.940]  Нет, давайте вот такими словами бросаться тут не будем.
[02:29:40.940 --> 02:29:43.940]  Короче, а лок.
[02:29:43.940 --> 02:29:51.940]  Это внутренний класс вообще, SharedPTR, это внутренняя структура SharedPTR, мы пока ничего по дефолту не знаем, что хотим.
[02:29:52.940 --> 02:29:55.940]  Вот. Мы будем...
[02:29:55.940 --> 02:29:59.940]  Вот, а лок здесь хранится. А еще что должно храниться?
[02:30:10.940 --> 02:30:13.940]  Ну, наверное, сам Пойнтер, да. Пойнтер на U.
[02:30:16.940 --> 02:30:20.940]  Только заметьте, уже на U, а не на T. Тип-то, вообще говоря, может быть и другим.
[02:30:20.940 --> 02:30:22.940]  Я напоминаю, что у нас все еще может...
[02:30:22.940 --> 02:30:26.940]  Ну, T и U, они могут быть и то, что один наследник другого.
[02:30:26.940 --> 02:30:31.940]  Один может быть мамой, другой папой, а указывают они на сына на самом деле оба.
[02:30:31.940 --> 02:30:40.940]  То есть, типы T и U, это не обязательно один и тот же тип, и даже не обязательно T наследник U или наоборот.
[02:30:40.940 --> 02:30:43.940]  У вас может быть SharedPTR на сына.
[02:30:43.940 --> 02:30:45.940]  Ну, вы можете создать изначально SharedPTR на сына.
[02:30:46.940 --> 02:30:52.940]  Потом его сказать, SharedPTR на маму равно ему, SharedPTR на папу равно ему, а SharedPTR на сына грохнуть.
[02:30:52.940 --> 02:30:55.940]  И у вас будет SharedPTR на маму, SharedPTR на папу.
[02:30:55.940 --> 02:30:59.940]  Оба они указывают на сына и share вот этот вот control-блок.
[02:30:59.940 --> 02:31:07.940]  Хотя у них у обоих тип в SharedPTR не тот, который на самом деле лежит под указателем.
[02:31:07.940 --> 02:31:14.940]  Но все еще это должно работать корректно, при условии, что там у вас виртуальные методы в этом сыне.
[02:31:14.940 --> 02:31:16.940]  Короче, ради поддержки виртуальности.
[02:31:20.940 --> 02:31:24.940]  Ради поддержки наследования, чтобы SharedPTR мог указывать не на...
[02:31:24.940 --> 02:31:27.940]  Наследование у нас диструкция другая, с виртуальностью нормально.
[02:31:39.940 --> 02:31:43.940]  А SharedPTR на T хранит у тебя указатель на U.
[02:31:43.940 --> 02:31:48.940]  И он знает, что хранит указатель на U, и за счет TypeRanger он правильный диструктор вызовет.
[02:31:48.940 --> 02:31:50.940]  Даже если там не было.
[02:31:50.940 --> 02:31:52.940]  Он вызовет диструктор для типа U.
[02:31:53.940 --> 02:32:01.940]  Ну, в смысле, за счет TypeRanger мы, когда будем уничтожать объект, мы вызовем диструктор вот этого control-блока MakeShared.
[02:32:01.940 --> 02:32:06.940]  Но этот control-блок MakeShared он сделает правильную вещь за нас.
[02:32:06.940 --> 02:32:10.940]  Он сделает delete PTR, а PTR это U.
[02:32:12.940 --> 02:32:14.940]  И удалит правильно.
[02:32:14.940 --> 02:32:18.940]  Вот, короче, если у нас вот такая ситуация, то мы храним вот это.
[02:32:20.940 --> 02:32:22.940]  Только ли это или еще что-то?
[02:32:22.940 --> 02:32:24.940]  Нет, не только это мы храним.
[02:32:27.940 --> 02:32:31.940]  Вы вообще помните, ради чего мы MakeShared-то придумали изначально?
[02:32:33.940 --> 02:32:37.940]  Чтобы они рядом лежали, сам объект и счетчики.
[02:32:37.940 --> 02:32:41.940]  Когда мы через MakeShared создаем объект, то мы храним это.
[02:32:41.940 --> 02:32:45.940]  И счетчики, когда мы через MakeShared создаемся, мы объект сами создаем.
[02:32:45.940 --> 02:32:47.940]  Мы сам объект где-то хранить должны.
[02:32:47.940 --> 02:32:50.940]  На самом деле в control-блоке MakeShared мы сам объект храним.
[02:32:51.940 --> 02:32:53.940]  Control-блок у нас вначале для чего был?
[02:32:53.940 --> 02:32:55.940]  Для того чтобы объект хранить.
[02:32:55.940 --> 02:32:57.940]  Вместе со счетчиками.
[02:32:57.940 --> 02:33:01.940]  То есть на самом деле мы храним объект здесь, а не PTR.
[02:33:01.940 --> 02:33:03.940]  Вот.
[02:33:17.940 --> 02:33:19.940]  Так.
[02:33:19.940 --> 02:33:21.940]  Хорошо.
[02:33:27.940 --> 02:33:29.940]  Ну, вроде пока так.
[02:33:29.940 --> 02:33:31.940]  Если у нас control-блок не MakeShared.
[02:33:34.940 --> 02:33:36.940]  Давайте я назову control-блок direct.
[02:33:37.940 --> 02:33:39.940]  Почему мы на локатор выделяем память?
[02:33:39.940 --> 02:33:40.940]  Что?
[02:33:40.940 --> 02:33:42.940]  Почему мы на локатор выделяем память?
[02:33:42.940 --> 02:33:44.940]  Где? Мы пока ничего не выделяем.
[02:33:44.940 --> 02:33:48.940]  Ну, мы по идее действительно новый единик адрес поменяли.
[02:33:51.940 --> 02:33:52.940]  Чего, чего, чего?
[02:33:52.940 --> 02:33:54.940]  Ну, единик адрес, что такое, да?
[02:33:54.940 --> 02:33:57.940]  А, ты про это? Ну да, это вы сами сделаете.
[02:33:58.940 --> 02:34:00.940]  Почему мы на локатор выделяем память?
[02:34:00.940 --> 02:34:01.940]  Да.
[02:34:01.940 --> 02:34:02.940]  Вообще, да.
[02:34:02.940 --> 02:34:04.940]  17 это все через ГБО сделано, как обычно.
[02:34:04.940 --> 02:34:08.940]  То есть эти control-блоки, они еще наследники локаторов и дилитеров соответствующих.
[02:34:08.940 --> 02:34:10.940]  Там все умно.
[02:34:10.940 --> 02:34:14.940]  Если вы начнете STL читать, там все вообще классно написано.
[02:34:15.940 --> 02:34:18.940]  Там еще есть оптимизации на случай, там если, то все.
[02:34:18.940 --> 02:34:19.940]  Ну, короче, да.
[02:34:19.940 --> 02:34:21.940]  Вот.
[02:34:22.940 --> 02:34:26.940]  Если же у нас control-блок direct, то мы храним дилитер.
[02:34:27.940 --> 02:34:29.940]  А локатор и объект.
[02:34:30.940 --> 02:34:32.940]  Указательный объект.
[02:34:36.940 --> 02:34:38.940]  Вот.
[02:34:42.940 --> 02:34:52.940]  В полях самого shared PTR мы храним указатель на control-блок.
[02:34:54.940 --> 02:34:56.940]  На base control-блок, разумеется.
[02:34:57.940 --> 02:35:08.940]  Под который может лежать как один, так и другой control-блок, смотря, что там было сделано.
[02:35:08.940 --> 02:35:10.940]  Да.
[02:35:12.940 --> 02:35:14.940]  Вот.
[02:35:19.940 --> 02:35:23.940]  А еще в полях shared PTR мы будем хранить указатель на T.
[02:35:24.940 --> 02:35:26.940]  Знаете зачем?
[02:35:26.940 --> 02:35:28.940]  А чтобы быстрее доступ к объекту получать.
[02:35:30.940 --> 02:35:34.940]  В shared PTR мы будем хранить не только, в shared PTR мы будем хранить два поинтера.
[02:35:34.940 --> 02:35:38.940]  Один это поинтер на блок, а второй это поинтер на сам T.
[02:35:38.940 --> 02:35:42.940]  Зачем мы в shared PTR в полях храним поинтер на сам T еще раз?
[02:35:42.940 --> 02:35:46.940]  Да чтобы быстро через shared PTR можно было T получать.
[02:35:46.940 --> 02:35:52.940]  Потому что если мы будем так делать, то нам постоянно надо будет два разыминования делать, чтобы до T достучаться.
[02:35:52.940 --> 02:36:00.940]  Shared PTR в себе хранит сам, как поле, тот PTR, за который он ответственен.
[02:36:00.940 --> 02:36:10.940]  Он его пробрасывает из control-блока, хранит, чтобы не делать лишнюю индирекцию, что называется.
[02:36:10.940 --> 02:36:14.940]  То есть мы жертвуем памяти, чтобы повлиять.
[02:36:14.940 --> 02:36:20.940]  Ну да, да, мы в shared PTR хотим, чтобы PTR, наш самый главный, был близко доступен.
[02:36:25.940 --> 02:36:27.940]  Ну какие у нас остались вопросы?
[02:36:36.940 --> 02:36:38.940]  Что еще осталось не обсужденным?
[02:36:38.940 --> 02:36:44.940]  Ну в принципе-то все, я вот такую заготовку написал, с ней уже можно shared PTR идти писать.
[02:36:44.940 --> 02:36:47.940]  Control-блок direct, он вообще используется?
[02:36:47.940 --> 02:36:56.940]  Control-блок direct, это когда мы создали shared PTR через прямой вызов конструктора.
[02:37:00.940 --> 02:37:02.940]  Я все еще не понял, когда мы его используем?
[02:37:02.940 --> 02:37:04.940]  Что значит когда используем?
[02:37:04.940 --> 02:37:07.940]  В смысле, зачем нам этот стракт вообще нужен?
[02:37:07.940 --> 02:37:09.940]  Для type erasure?
[02:37:14.940 --> 02:37:19.940]  Хорошо, я создал shared PTR через прямой вызов конструктора.
[02:37:19.940 --> 02:37:21.940]  Где мне хранить счетчики для начала?
[02:37:21.940 --> 02:37:24.940]  Ты предлагаешь их в полях хранить? Прям в shared PTR?
[02:37:24.940 --> 02:37:26.940]  Ну окей, в control-блоке.
[02:37:26.940 --> 02:37:28.940]  Отлично, в control-блоке.
[02:37:28.940 --> 02:37:32.940]  У меня есть базовый control-блок, вот такой shared count и weak count.
[02:37:32.940 --> 02:37:36.940]  Ты предлагаешь какого типа control-блок хранить в таком shared PTR?
[02:37:36.940 --> 02:37:40.940]  Я говорю, что у меня есть подвид control-блока, вот такой.
[02:37:40.940 --> 02:37:46.940]  В котором есть два счетчика, а также deleter-аллокатор и мой у.
[02:37:49.940 --> 02:37:50.940]  Настоящий.
[02:37:53.940 --> 02:37:55.940]  Ну еще мне надо хранить deleter-аллокатор где-то,
[02:37:55.940 --> 02:37:59.940]  потому что они могут быть кастомными, когда меня создавали напрямую через конструктор.
[02:37:59.940 --> 02:38:01.940]  Кто все понимает до сих пор?
[02:38:04.940 --> 02:38:06.940]  Обожаю, да, да, да.
[02:38:23.940 --> 02:38:26.940]  Зачем нам здесь хранить указатель на u в control-блоке еще?
[02:38:26.940 --> 02:38:28.940]  Может быть и не нужно.
[02:38:28.940 --> 02:38:30.940]  Может быть и без него будет работать, кстати.
[02:38:30.940 --> 02:38:37.940]  Но могут быть проблемы, я боюсь, что будут проблемы с наследованием, если здесь не хранить.
[02:38:39.940 --> 02:38:45.940]  Даже если мы его храним, мы же все равно потом используем test-озвездочку.
[02:38:47.940 --> 02:38:48.940]  Ну что?
[02:38:48.940 --> 02:38:53.940]  Нет, control-блок должен хранить указатель на объект, как он его воспринимает, где начало.
[02:38:53.940 --> 02:39:01.940]  Да, например, смотрите, если у меня множественное наследование, там есть мама, папа, дружная семья, несколько мам, несколько бабушек.
[02:39:01.940 --> 02:39:08.940]  Вот этот control-блок будет хранить u в том смысле, как его настоящий объект.
[02:39:08.940 --> 02:39:10.940]  А Shered-PTR-то хранит указатель на t.
[02:39:10.940 --> 02:39:15.940]  Он воспринимает объект, как экземпляр того t, от которого сам Shered-PTR.
[02:39:31.940 --> 02:39:33.940]  Наоборот, не уверен.
[02:39:33.940 --> 02:39:35.940]  Наоборот, не уверен.
[02:39:35.940 --> 02:40:01.420]  наоборот не уверен так я не знаю как получится да это очень правильный вопрос да это еще
[02:40:01.420 --> 02:40:06.500]  один момент который мы недообсудили я спросил тут все ли хорошо вот это пожалуй последняя
[02:40:06.500 --> 02:40:16.940]  вещь которую надо обсудить да это совершенно ведь подожди нет а локатор нет а локатор
[02:40:16.940 --> 02:40:35.740]  а локатор в мейк шерот выделяет только блок объект уже создан объект создается не
[02:40:35.740 --> 02:40:45.380]  через локатор но точнее точнее он создается может и через локатор но только а локатор не
[02:40:45.380 --> 02:40:49.780]  используется для удаления само объекта локатор когда мы через мейк шерот создаемся а локатор
[02:40:49.780 --> 02:41:13.100]  используется только для создания блока вот да кого мы храним а локатор конечно мы должны хранить
[02:41:14.100 --> 02:41:20.940]  у нас есть функция allocate shared вот давайте о отлично смотрите давайте в качестве завершающего
[02:41:20.940 --> 02:41:26.500]  упражнения напишем функцию allocate shared есть функция мейк шерот которая
[02:41:26.500 --> 02:41:40.780]  type name t type name многоточий arcs которая возвращает shared ptr от t мейк шерот я напомню
[02:41:40.780 --> 02:41:51.460]  что она делает она принимает значит arcs двойной имперсант многоточий arcs и она на самом-то деле
[02:41:52.020 --> 02:41:59.060]  просто выражается через allocate shared мейк шерот это просто allocate shared со стандартным
[02:41:59.060 --> 02:42:04.180]  локатором и вся магия заключена в allocate shared на самом деле эта функция просто делать return
[02:42:04.180 --> 02:42:24.660]  shared ptr ой return нет она делал allocate shared от std а локатор а локатор от чего ну а ты давайте
[02:42:24.660 --> 02:42:41.940]  скажем и std forward от arcs как это я объект я вызываю функцию я передаю объект в нее и на самом
[02:42:41.940 --> 02:42:50.980]  деле самое-то главное интересный вопрос что делает а локатор ну что делает allocate
[02:42:50.980 --> 02:43:04.180]  shared type name t type name alloc type name многоточие arcs shared ptr от allocate shared вот это очень
[02:43:04.180 --> 02:43:13.020]  интересный вопрос но я сейчас не реализую эту функцию целиком потому что ну я проговорю как ее
[02:43:13.020 --> 02:43:20.260]  реализовать ну я типа скажу словами но не напишу вам это предстоит самим написать мне надо здесь
[02:43:20.660 --> 02:43:28.900]  вот этим а локатором выделить штуковину в которой будет одновременно лежать и счетчики и объект
[02:43:28.900 --> 02:43:44.860]  потом мне нужно поместить на нужный адрес мой объект и запомнить а локатор мне дали на t а
[02:43:45.460 --> 02:43:52.020]  локатор мне дали для того чтобы я им выделил память я должен этим локатором выделить память
[02:43:52.020 --> 02:43:58.340]  под свой контрол блок а потом положить на нужный адрес из в этом вон друге свой объект то есть
[02:43:58.340 --> 02:44:05.500]  я должен сказать то есть я сейчас должен да я сейчас должен сделать rebind этого локатора на тип
[02:44:05.500 --> 02:44:26.300]  до блог какой да я сейчас должен сделать rebind а локатора на тип контрол блок мэйк шерет
[02:44:26.300 --> 02:44:43.220]  с таким типом и таким аллок как мне дали вот дальше я на том локаторе который получился делаю
[02:44:43.220 --> 02:44:53.220]  allocate 1 я не буду это писать потому что сами напишите это это часть задачи я сейчас rebind
[02:44:53.220 --> 02:44:59.980]  же локатор на то чтобы он создавал мне контрол блок говорю на этом локаторе allocate 1 штуку потом
[02:44:59.980 --> 02:45:07.220]  на этом же локаторе ну на самом деле кажется даже не на локаторе просто через new потому что
[02:45:07.220 --> 02:45:13.860]  мне локатор не нужен для создания объекта я просто могу placement new положить по нужному
[02:45:13.860 --> 02:45:19.340]  адресу внутри контрол блока уже я знаю где он уже наш объект из тех аргументов которые мне дали
[02:45:20.100 --> 02:45:35.580]  я не уверен что локатор так делает возможно кстати это изменилось начиная с си плюс плюс какого-то
[02:45:35.580 --> 02:45:45.780]  да но да но я говорил что когда мы делаем через мэйк шерет allocate шерет локатор нужен только
[02:45:45.780 --> 02:45:53.060]  для блока они для объекта я не помню это менялась от стандарта к стандарту я не помню по моему до
[02:45:53.060 --> 02:45:58.100]  си плюс 17 не использовался локатор для того чтобы констракт вызывать дело здесь потом начал
[02:45:58.100 --> 02:46:04.220]  использоваться уточните на себе переэфференциал locate шерет использует прям констракт или
[02:46:04.220 --> 02:46:10.860]  placement new чтобы сконструировать по моему это изменилось си плюс 17 то есть раньше он использовал
[02:46:11.460 --> 02:46:15.820]  потом стал использоваться локатор короче мы делаем либо констракт либо placement new по
[02:46:15.820 --> 02:46:24.060]  нужному адресу этим локаторам а потом сам этот локатор ну точнее вот этот объект локатора
[02:46:24.060 --> 02:46:31.740]  который нам далее вместе со всем тем чем надо кладем вот этот блок ну и там же его и сохраняем
[02:46:31.740 --> 02:46:39.420]  то есть вот этот лок который нам далее мы в тот самый блок и кладем как поле нам надо заполнить
[02:46:39.420 --> 02:46:48.020]  этот блок всеми этими штуками и там счетчик вот и там счетчики правильно проставить последний
[02:46:48.020 --> 02:46:57.900]  вопрос последний вопрос а что делать когда мне нужно уничтожить объект но еще не уничтожать
[02:46:57.900 --> 02:47:04.780]  блок помните если у меня на объект существует закончились указывать шерет птр но еще остались
[02:47:05.540 --> 02:47:15.180]  то мне надо деструктор у вызвать вот здесь но контролл блок еще должен оставаться в памяти и
[02:47:15.180 --> 02:47:26.740]  контролл блок впоследствии мне надо будет освободить локатором но у меня тайп и рейджер вот этот
[02:47:26.740 --> 02:47:31.060]  контракт вот деструктор этого контролл блока должен вызваться в самый последний момент когда
[02:47:31.060 --> 02:47:37.100]  я уже уничтожаю контролл блок у меня должен уничтожаться объекту локатора в частности то есть
[02:47:37.100 --> 02:47:45.700]  когда будет умирать послед kimse вик птр должен вызваться диструктор вpr блок мейк � Suit но
[02:47:45.700 --> 02:47:53.120]  при этом диструктор у должен быть вызван до этого а в момент когда будет умирать контролл
[02:47:53.120 --> 02:47:57.780]  блок мэйк шерет деструктора уже не должен вызываться он раньше был вызван что же делать
[02:47:57.780 --> 02:48:07.620]  что вот именно проблема в том что когда я буду в самом конце когда будет умирать вик птр буду
[02:48:07.620 --> 02:48:13.100]  уничтожать контрол блок мэйк шерет вызовутся деструкторы всех полей неизбежны как подошли
[02:48:13.100 --> 02:48:18.100]  виртуальный диструктор он вызовет диструктор и этого аллок этого у но диструктору уже должен
[02:48:18.100 --> 02:48:23.300]  был быть мной вызван когда умирал шерет птр а когда мэйк птр диструктору нельзя вызывать уже
[02:48:23.300 --> 02:48:28.700]  то есть когда будет умирать контрол блок мэйк шерет мне надо вот это поле избежать его вызову
[02:48:28.700 --> 02:48:43.660]  диструктора каким-то чудом как же мне этого это сделать кого мунуть на самом деле короче на
[02:48:43.660 --> 02:48:53.260]  самом деле мне здесь придется это у хранить не как у а как массив чаров потому что мне вручную
[02:48:53.260 --> 02:49:01.540]  нужно решать когда его диструктурирует но можно как илайн storage да то есть я здесь напишу чар
[02:49:01.540 --> 02:49:20.260]  элайны ну там чар значит илайн с илайн с у чар сайз офу обж вот вот для чего да потому что
[02:49:20.260 --> 02:49:25.900]  когда будет умирать последний век птр иначе он диструктурирует тату а он уже был уничтожен
[02:49:25.900 --> 02:49:43.060]  дважды выдастся диструктурируй потому что это массив чаров я рассказал все что планировал
[02:49:43.060 --> 02:49:48.620]  сегодня на этой торжественной счастливой ноте я вам выдаю четвертую задачу шерет птр
[02:49:48.620 --> 02:49:56.660]  сейчас пара закончилась но если хотите можно задать вопросы да и кстати можно поздавать еще
