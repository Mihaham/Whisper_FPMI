[00:00.000 --> 00:09.000]  Ну окей, Лан, давайте начинать. У нас сегодня с вами новый
[00:09.000 --> 00:11.640]  семестр начинается, я вас поздравляю с прекрасной
[00:11.640 --> 00:16.440]  первой парой нового семестра. Тут должны были быть…
[00:16.440 --> 00:22.360]  Нет, сверчки. Соответственно, в этом семестре мы занимаемся
[00:22.360 --> 00:24.680]  глобально двумя вещами – это графы и строковые
[00:24.680 --> 00:27.840]  алгоритмы. Быть может, еще что-нибудь зацепим, но
[00:27.840 --> 00:32.920]  это вряд ли. Собственно, на графы у нас будет примерно
[00:32.920 --> 00:36.760]  три модуля. Первый – это будут всякие обходы графов
[00:36.760 --> 00:41.880]  DFS, BFS. Второй – это будут кратчайшие пути и около
[00:41.880 --> 00:47.640]  задачи. И третий – это будут потоки. Вот. Как бы план
[00:47.640 --> 00:51.280]  очень простой. По поводу системы оценения она немножко
[00:51.280 --> 00:56.780]  изменится, потому что, ну, как бы так мягче сказать,
[00:56.860 --> 00:59.980]  теорки дискредитировали себя наличием мобильного
[00:59.980 --> 01:04.220]  непроверяемого плагиата. Вот. В связи с этим было
[01:04.220 --> 01:08.900]  решено их удалить из системы оценивания. Вот. Это первое
[01:08.900 --> 01:12.380]  в нововведении. Второе – задачный ревью будет меньше
[01:12.380 --> 01:15.340]  с одной стороны. С другой стороны, требования будут
[01:15.340 --> 01:19.820]  общими для всех групп базовые. То есть, это значит, что
[01:19.820 --> 01:23.100]  у вас условно задача из прошлого семестра, не знаю,
[01:23.100 --> 01:26.700]  про многоугольники, найдите выпуклую оболочку. Вы должны
[01:26.700 --> 01:32.020]  уметь шаблоны закидывать тип параметризующей точку,
[01:32.020 --> 01:37.700]  многоугольник тип параметризующий саму точку многоугольника
[01:37.700 --> 01:39.940]  в класс, получающий выпуклую оболочку, задавать произвольные
[01:39.940 --> 01:43.020]  скалярные произведения и так далее. Вот. Это будет
[01:43.020 --> 01:50.220]  общим для всех. Вот. Да, я надеюсь, что я вас обескуражил
[01:50.220 --> 01:52.300]  этим заявлением. Зато таких задач в контесте будет
[01:52.300 --> 02:00.780]  максимум 2-3 к каждому. Тобственно, вот. Может быть, 2-1. Я не знаю
[02:00.780 --> 02:06.180]  еще точно, что это такое будет. Соответственно, сочувствую,
[02:06.180 --> 02:09.180]  но ничего не поделать. По поводу системы оценивания
[02:09.180 --> 02:14.260]  точная формула будет выложена на этой неделе. Первое задание
[02:14.260 --> 02:17.460]  тоже на этой неделе. Ну и все остальное тоже на этой
[02:17.460 --> 02:20.980]  неделе будет. Вот. А теперь давайте оторвем момент
[02:20.980 --> 02:30.780]  и прием к содержанию. Так, лекция первая. Ну, давайте
[02:30.780 --> 02:33.900]  наверное скажем еще, что такое граф. Вот. Ну, один
[02:33.900 --> 02:39.580]  раз скажем и забудем. Потом будем воспринимать картинку.
[02:40.580 --> 02:59.900]  Пара VE называется графом, если, ну, давайте, не так,
[02:59.900 --> 03:07.340]  не если, а где V меньше бесконечности, это множество вершин. Да,
[03:07.340 --> 03:14.420]  мы будем рассматривать только конечную графу. А E, оно будет
[03:14.420 --> 03:18.860]  у нас под множеством V на V. Таким что. Ну, сейчас
[03:18.860 --> 03:23.580]  будем перечислять требования. В общем случае в графе
[03:23.580 --> 03:28.380]  мы не позволяем себе петель в определении именно графа,
[03:28.380 --> 03:37.260]  поэтому для любой V из V пара VV не лежит в множестве
[03:37.260 --> 03:43.380]  ребер. Это требование на отсутствие петель. Второе,
[03:43.380 --> 03:49.020]  что мы будем требовать, что для любой, для любых UV
[03:49.020 --> 03:57.900]  из вершинок наличие ребра VU лежит в E. Это равносильно
[03:57.900 --> 04:03.260]  тому, что у вас есть ребро UV. Это неориентированность.
[04:03.260 --> 04:06.700]  То есть по умолчанию мы считаем графы неориентированными.
[04:06.700 --> 04:08.940]  Если нам требуется ориентированная графа, мы будем это явно
[04:08.940 --> 04:15.620]  проговаривать. И третье, самое интересное, это то, что
[04:15.620 --> 04:19.740]  у нас отсутствуют кратные ребра. Я долго думал как-то
[04:19.740 --> 04:22.980]  записать на языке кванторов, но давайте запишем это
[04:22.980 --> 04:33.220]  так. Ну будто бы да, но будто бы можно сказать, что
[04:33.220 --> 04:35.260]  можно рассматривать это как мультимножество из
[04:35.260 --> 04:44.260]  этого множества. Ну это просто набор элементов. Все, это
[04:44.260 --> 04:47.780]  мог быть повторяющийся ответ такой. Вот что такое
[04:47.780 --> 04:49.700]  мультимножество. Ну окей Илон, давайте скажем, что
[04:49.700 --> 04:52.540]  кратных ребер нет, и если что мы их ведем. Ну давайте
[04:52.540 --> 04:55.580]  так определим. Хорошо. Не особо принципиально, потому
[04:55.580 --> 04:57.380]  что к этому определению мы возвращаться особо не
[04:57.380 --> 05:06.060]  будем больше. Вот. Ну графы ориентированы, если, давайте,
[05:06.060 --> 05:15.580]  неориентированность, это отсутствие петель. Ну и
[05:15.580 --> 05:18.340]  как замечание, то, что у нас действительно нет кратных
[05:18.340 --> 05:21.900]  ребер. Если в графе есть петли, то это называется
[05:21.900 --> 05:28.220]  мультипсевдограф. Если граф вот этот вот неверно,
[05:28.220 --> 05:32.820]  то граф ориентированный. Вау. Если в графе есть кратные
[05:32.820 --> 05:35.900]  ребра, это называется мультиграф. Тобственно, вот эти вот слова
[05:35.900 --> 05:39.420]  ориентированный, мультипсевдограф можете переставлять как хотите
[05:39.420 --> 05:46.020]  и получать любые комбинации. Вот. Окей. Все, договорились
[05:46.020 --> 05:52.020]  о определениях. Теперь начнем с... Закончим с математикой.
[05:52.020 --> 06:04.580]  Там снегопад пошел. Во время ночи лекция. Окей. Так. Как
[06:04.580 --> 06:08.940]  хранить граф вообще в программах? И вообще какая мотивация
[06:08.940 --> 06:11.540]  работать с графами? Ну графы это вообще достаточно
[06:11.540 --> 06:13.380]  естественная структура для представления каких-то
[06:13.380 --> 06:17.100]  данных. Ну и самое простое, такие там карты городов.
[06:17.100 --> 06:26.260]  Вот. Окей. Так, хранение графа. Потому что чтобы работать
[06:26.260 --> 06:30.180]  с графом, нам нужно его хранить вообще как-то. Есть несколько
[06:30.180 --> 06:35.300]  способов. Мы будем развивать обычно два. И первый это
[06:35.300 --> 06:48.540]  матрица смежности. Что такое матрица смежности? Это
[06:48.540 --> 06:57.300]  матрица В на В размеров. Размеров, естественно. Вот. Мощность
[06:57.300 --> 07:16.460]  В на мощность В. Где... Да, я сразу буду говорить, что,
[07:16.460 --> 07:19.860]  в общем-то, у нас не всегда существует индексация на
[07:19.860 --> 07:22.940]  множество вершин. Ну, если следовать этому определению.
[07:22.940 --> 07:27.340]  Вот. Ну и вообще не очень понятно, как можно индексировать
[07:27.340 --> 07:31.020]  такие объекты. Вдруг вершина, это что-то сложное. Но я
[07:31.020 --> 07:33.980]  позволю себе наглость, что раз на бесконечное множество
[07:33.980 --> 07:38.620]  я могу как-то их пронумеровать. Вот. А если я могу как-то
[07:38.620 --> 07:40.980]  пронумеровать, то имеется в виду, что здесь жито и
[07:40.980 --> 07:44.940]  жито. Это индикатор того, что из вершины И, ну с номером
[07:44.940 --> 07:48.420]  И. Дальше тут просто вершина И говорится. Есть ребро
[07:48.420 --> 07:57.260]  в вершину с номером жи. Просто жи. Далее. Вот. И второй
[07:57.260 --> 08:03.460]  вариант. Это список смежности, ну или списки смежности.
[08:03.460 --> 08:20.180]  Что такое список смежности? Это массив списков размера,
[08:20.180 --> 08:23.900]  имеется в виду массив размера модуль В здесь. Списки могут
[08:23.900 --> 08:43.300]  быть произвольного размера. Так. Где в этом списке лежат
[08:43.300 --> 08:50.700]  соседи этой вершины. Сразу скажу в ориентированном
[08:50.700 --> 08:55.180]  графе. То есть если у вас есть какая-то такая картинка
[08:55.180 --> 09:05.380]  у ВВ, то соседом вершины В является В только. То есть
[09:05.380 --> 09:08.580]  мы обратные ребра не рассматриваем. Под соседями подживаются
[09:08.580 --> 09:10.700]  те, до кого вы можете достичь непосредственно по ребру.
[09:10.700 --> 09:15.100]  Вот. Так. Это список смежности. Давайте рассматривать
[09:15.100 --> 09:18.580]  разные операции, которые мы хотим от графа вообще.
[09:18.580 --> 09:26.300]  Ну, наверное, хочется узнать операция. И первое узнать,
[09:26.300 --> 09:39.380]  есть ли ребро между У и В. Ли ребро у В. Так, давайте
[09:39.380 --> 09:47.780]  это будет матрица смежности. Это будет список смежности.
[09:47.780 --> 09:51.100]  Какую табличку будем делать? Матрица смежности, за сколько
[09:51.100 --> 10:01.220]  мы умеем узнавать, есть ли ребро? За единицу, да. А списки?
[10:01.220 --> 10:07.260]  Ну не совсем. Более точно от степени вершины. Да,
[10:07.260 --> 10:11.820]  DECU – это степень вершины, то есть число нисходящих
[10:11.820 --> 10:17.260]  ребер. Вот. Ну что еще? Наверное, хочется уметь получать
[10:17.260 --> 10:26.420]  список соседей вершины явно, чтобы по нему итерироваться.
[10:26.420 --> 10:37.540]  Получить список соседей У. Ну, будем считать, что
[10:37.540 --> 10:41.700]  матрица смежности, так как у нас есть нули, нам все
[10:41.700 --> 10:43.740]  равно придется там… То есть, что мы хотим? Мы хотим
[10:43.740 --> 10:45.500]  по нему итерироваться на самом деле. Мы явно список
[10:45.500 --> 10:48.260]  не хотим получать. Мы хотим уметь получать какой-то
[10:48.260 --> 10:51.220]  контейнер, который имеет метод «дай мне следующего
[10:51.220 --> 10:55.820]  соседа». Вот. Итого полное время итерирования – то,
[10:55.820 --> 11:00.140]  что нас интересует. В частности, для матрицы смежности нам
[11:00.140 --> 11:03.180]  придется добежать до конца, в любом случае, до конца
[11:03.180 --> 11:06.540]  строчки, чтобы понять, есть ли в конце там соседей.
[11:06.540 --> 11:14.380]  То есть от числа вершин. Тогда как для списка смежности,
[11:14.380 --> 11:17.260]  в общем-то, вам не нужно будет пропускать вершины,
[11:17.260 --> 11:18.980]  которые не являются соседями, потому что они у вас просто
[11:18.980 --> 11:22.580]  не хранятся здесь. Поэтому полное время итерирования
[11:22.580 --> 11:29.340]  также составит ту отстепень. Ну, и классическое время
[11:29.340 --> 11:37.340]  и построение, и память точнее на построение. Время построения.
[11:37.340 --> 11:45.060]  Вот за сколько матриц смежности можно построить? Ну, будто
[11:45.060 --> 11:46.860]  бы давайте считать, что мы можем память вылить за
[11:46.860 --> 11:55.100]  единицу. В на В. Ну, мы же можем, не знаю, там у нас есть
[11:55.100 --> 11:58.620]  в графе, наверное, список ребер какой-нибудь нам данный.
[11:58.620 --> 12:02.020]  То есть, казалось бы, от Е хочется делать. Но давайте
[12:02.020 --> 12:06.780]  мы все-таки оставим этот спор за тем, что нам хватит
[12:06.780 --> 12:15.060]  оценки в квадрат. Ну, потому что, банально, давайте там
[12:15.060 --> 12:17.100]  считать, что память выделится немгновенно, потому что
[12:17.100 --> 12:22.060]  можно нулями все заполнить хотя бы изначально. Окей.
[12:22.060 --> 12:30.700]  Списки смежности. За сколько он строится? Ну, еще ни
[12:30.700 --> 12:34.700]  одного правильного ответа нет. Да, В плюс Е на самом
[12:34.700 --> 12:41.500]  деле. Почему это так? Почему здесь нужно модуль В вообще
[12:41.500 --> 12:43.260]  учитывать? Потому что вдруг у вас в графе очень мало
[12:43.260 --> 12:46.180]  ребер. Ну, он разреженный такой. Но он же все равно
[12:46.180 --> 12:49.660]  нужно там пройтись и создать какие-то пустые списки
[12:49.660 --> 12:53.380]  за модуль В. Поэтому обычно это учитывают так или иначе.
[12:53.380 --> 13:01.660]  Ну и память. Здесь я уже заполню сам, потому что слишком
[13:01.660 --> 13:12.260]  просто. Вот. Итого. То есть, матрица смежности, конечно,
[13:12.260 --> 13:14.620]  неплохая сама по себе, потому что позволяет нам проверить,
[13:14.620 --> 13:18.180]  есть ли ребро. Но есть нюанс в том, что у нее время и память
[13:18.660 --> 13:23.780]  занимают. То есть, как бы для графов, которые не близки
[13:23.780 --> 13:27.740]  к полным, вот это вот очень плохая оценка. Это вот куда
[13:27.740 --> 13:33.660]  лучше. Вот. Так, Кейм. Есть ли вопросы по тому, как граф
[13:33.660 --> 13:41.780]  хранить? Супер. Так, ну теперь мы будем учиться обходить
[13:41.780 --> 13:45.220]  граф, потому что пока что мы с ним ничего делать не
[13:45.220 --> 13:49.100]  умеем. Ну, точнее, мы уже умеем его в память записывать.
[13:49.100 --> 13:51.380]  Это, конечно, классно. Но как с ним надо оперировать?
[13:51.380 --> 13:54.140]  В том семестре мы научились с вами обходить деревья.
[13:54.140 --> 13:58.020]  Ну, было такое там преордер, энордер и так далее обходы.
[13:58.020 --> 14:01.940]  Вот здесь немножко сложнее, но не сильно на самом деле.
[14:01.940 --> 14:12.380]  И первое, что мы будем рассматривать, это DFS. Расшипровывается
[14:12.380 --> 14:28.340]  как depth-first-search или по-русски поиск в глубину. Вот. Собственно,
[14:28.340 --> 14:30.980]  в чем суть алгоритма? Вы запускаете от какой-то
[14:30.980 --> 14:35.180]  вершины, перебираете всех ее соседей, перешли в первого
[14:35.180 --> 14:39.740]  соседа, запустились рекурсивно. Ну, все. Все гениально и
[14:39.740 --> 14:51.740]  очень просто. То есть, казалось бы, что-нибудь там типа void DFS от int v.
[14:51.740 --> 14:54.820]  Ну, вообще, от вершины здесь произвольно написать. Ну,
[14:54.820 --> 15:00.460]  давайте от int a по номеру вершинки v. Давайте мы будем считать,
[15:00.460 --> 15:16.660]  что у нас есть int v от graph. Graph g int v. Если, что здесь если? Зачем здесь если?
[15:16.660 --> 15:35.660]  Нужен for. Мы проявляемся по соседям for, after, u, g, getNeighbors от v. Ну да,
[15:35.660 --> 15:38.820]  допустим у нас у графа есть метод дай мне соседей по вершинке.
[15:38.820 --> 15:52.340]  Собственно, то, что мы с вами обсуждали. Делай DFS от g u. Какие есть проблемы у этого кода?
[15:52.340 --> 16:02.940]  Да, если у вас есть просто ребро в графе, он зациклется. Очень просто. Потому что он будет
[16:02.940 --> 16:09.180]  ходить туда-сюда. Поэтому, наверное, надо как-то это фиксить. Фиксить это очень просто тем,
[16:09.180 --> 16:16.020]  что мы вводим массив visited, used. Там куча названий у него. Давайте напишем так.
[16:16.020 --> 16:40.700]  Пусть used от v. Это индикатор того, что v уже посещена обходом. Вот тогда что мы должны сделать?
[16:40.700 --> 16:48.740]  Мы должны здесь будто бы проверить. Если вершина не посещена, то делай то-то и
[16:48.740 --> 16:59.540]  поставь, что она посещена. То есть сюда нужно вставить следующий блок кода. Что если не used от v,
[16:59.540 --> 17:14.900]  то used от v равно true. И вот это вот все дело, этот цикл можно вот сюда вот запихать. То есть
[17:15.660 --> 17:22.660]  я хочу проверить, что если вершина не использована, то давайте сделаем не так. Проверим по-другому,
[17:22.660 --> 17:28.300]  чтобы это адекватно смотрелось. Да, давайте сделаем так, что если она использована,
[17:28.300 --> 17:42.580]  ужасные тряпки, стерки в этот раз. Если она использована, то return просто делаем. И здесь
[17:42.580 --> 17:57.780]  делаем used от v равно true. Вот так вот это пойдет. Даже соберется по идее. Первый вопрос,
[17:57.780 --> 18:07.900]  за сколько это работает? Ну да, потому что мы посетим каждую вершину один раз и каждое
[18:07.900 --> 18:18.940]  ребро не более двух раз. Давайте допустим, что у нас тут есть какое-то ребро. Это вершина u,
[18:18.940 --> 18:28.740]  v. Допустим, DFS пришел в вершину u раньше. Тогда DFS посмотрит сюда и пойдет в вершину v. ДФС
[18:28.740 --> 18:34.620]  по вершине v просмотрит всех соседей, включая вершину u. Но u-то уже была посещена, поэтому
[18:34.620 --> 18:40.340]  он ее дальше рассматривать не будет. Но ребро мы посмотрим ровно два раза. Из вершины u и вершины v.
[18:40.340 --> 18:46.300]  Поэтому всего ребра мы посмотрели два раза и каждую вершину тоже не очень много раз
[18:46.300 --> 18:57.220]  Посмотрим на самом деле. Вот, по крайней мере мы DFS от нее будем вызывать. Вот, поэтому время работы.
[18:57.220 --> 19:14.860]  Окей, казалось бы круто, да? Но на самом деле этот код не рабочий и он не обойдет весь граф,
[19:14.860 --> 19:20.300]  в общем случае. Да, потому что на самом деле мы запускаемся лишь от одной вершины, будто бы
[19:20.300 --> 19:27.660]  где-то там в мейне. Если мы вызовем DFS от одной вершины, то пока еще не докажем утверждение,
[19:27.660 --> 19:34.220]  то мы посетим ровно компоненту связанности с вершиной v. Не более чем. Да, это еще придется доказывать.
[19:34.220 --> 19:42.500]  Поэтому в общем случае DFS выглядит так, что вот эта вот сама функция рекурсивного обхода, а есть еще
[19:42.500 --> 19:49.020]  мейн, который перебирает вершинки в порядке возрастания, и если она еще не помечена вот этим вот used,
[19:49.020 --> 20:01.460]  то она будет запускать от него DFS. Вот, тогда мы все посмотрим. То есть здесь будет что-то типа for v
[20:01.460 --> 20:23.260]  меньше, чем уголь v. Если не use.v, то делай DFS над gv. Что-то такое будет. Теперь мы посетим весь граф,
[20:23.260 --> 20:30.220]  и тут вы уже можете заметить, что с архитектурной точки зрения массив used будто бы это какая-то
[20:30.220 --> 20:35.380]  глобальная переменная, потому что мы вот здесь никуда не передаем. И в текущем написании это как бы да.
[20:37.380 --> 20:42.060]  А как именно исправлять это, вам предстоит познакомиться на семинарах. А именно тысяча и одно
[20:42.060 --> 20:48.820]  архитектурное решение, как писать DFS. Там действительно куча способов разных. Ну окей.
[20:48.820 --> 20:56.780]  Так, теперь надо сформулировать несколько утверждений о DFS, чтобы понять, зачем он нам нужен, кроме того,
[20:56.780 --> 21:05.620]  чтобы ходить по графу. И давайте введем такое понятие, как цвета вершин. Цвета вершин.
[21:05.620 --> 21:20.540]  Одя DFS. У нас будет всего три цвета. И немного не толерантно получится, но все-таки в ходе классики
[21:20.540 --> 21:29.740]  у нас будет все-таки три цвета. Это будет белый, серый и черный. Вот. Первый цвет-то белый. Эта вершина не была еще посещена.
[21:29.740 --> 21:56.460]  Вот. Второе. Это серцвет. Уже посещена, но не обработана. Под словом обработана,
[21:56.460 --> 22:02.620]  здесь я подразумеваю, что вызов DFS от этой вершины закончился. То есть мы вызвались от всех соседей
[22:02.620 --> 22:07.980]  рекурсивно и вылетели из такой рекурсии уже из этой вершинки. Вот. А мы находимся где-то,
[22:07.980 --> 22:16.660]  что еще не вышли из нее. И третий. Это будет черный цвет вершинки. Уже обработано.
[22:16.660 --> 22:35.660]  Давайте посмотрим на примере графа эволюция цветов. Давайте нарисуем граф какой-нибудь.
[22:46.660 --> 22:59.700]  Много вершин получилось, но я думаю, мы поймем, когда остановится. Вот. Ну и запускаем DFS 3 единицы.
[22:59.700 --> 23:14.660]  Что мы будем делать с этим всем? Ну, окей. Давайте сделаем вот что. Посмотрим на эволюцию цветов вершин.
[23:14.660 --> 23:23.460]  Один, два, три, четыре, пять, шесть. Здесь будут цвета. И изначально все вершинки белые,
[23:23.460 --> 23:35.180]  потому что мы никого не посетили еще. Окей. Ну W это white. Дальше запускается DFS к единице.
[23:35.180 --> 23:42.380]  Что происходит? Мы помечаем ее серой, потому что мы зашли в нее. То есть она останется с gray.
[23:42.380 --> 23:53.180]  Окей. Запускаемся от вершины один. Ну и там вот рекурсивный запуск от всех соседей. У нее
[23:53.180 --> 24:06.180]  все только двойка. Поэтому становится снова gray. Gray это W. Ну и давайте положим, что мы идем в четверку
[24:06.180 --> 24:25.300]  для начала. Ну, так жизнь сложилась. Пришли в четверку. W, W, W. Ну и в четверке мы
[24:25.300 --> 24:36.940]  интеррируемся по соседям. Допустим, в пятерку пришли. Серый, серый. Белый, серый. Серый, белый.
[24:36.940 --> 24:43.940]  Смотрим соседей пятерки. Это 4,6. Казалось бы, 4 с меньшим номером, поэтому будто бы мы в нее
[24:43.940 --> 24:50.100]  пошли сначала. Но она уже использована. Ну, типа у нее use там равно true. Ну или она уже не белого
[24:50.100 --> 25:03.620]  цвета. Поэтому мы должны идти только в шестерку дальше. Окей. Из шестерки пытаемся пройти соседи.
[25:03.620 --> 25:11.340]  Смотрим. 5. Уже использовано. 4 уже использовано. То есть мы не можем как бы из шестерки никуда
[25:11.340 --> 25:21.340]  дальше пойти. Поэтому stack recursion выходит из шестерки наверх. И раз мы вышли из шестерки,
[25:21.340 --> 25:30.980]  мы пишем ей black. Черный цвет. Прошли обратно. Ну, я думаю, дальше понятно, да, как будет
[25:30.980 --> 25:41.140]  устроено все. Вот. Как можно вводить цвета эти явно? Куда в коде их вставлять? Ну, вы делаете
[25:41.140 --> 25:49.580]  следующее, что у вас изначально, забывайте такой массив уже new stack colors. И здесь у вас изначально
[25:49.580 --> 25:55.900]  у вас все тут пишут, что там цвета все белые. Дальше у вас здесь что? Цвет вершинки в серый. И
[25:55.900 --> 26:02.740]  пытайтесь вот здесь вот типа. А потом, когда уже вы закончили for, вы пишете, что цвет вершинки
[26:02.740 --> 26:16.500]  черный. Здесь как бы ничего интеллектуального нет. Зачем мы вводили эти цвета вершин? Для того,
[26:16.500 --> 26:26.100]  чтобы доказать очередное утверждение, очевидно же. Алема о белых путях. О белых путях.
[26:26.100 --> 26:45.460]  Звучит так, что рассмотрим все такие вершины,
[26:45.460 --> 27:14.540]  что достижимы из V по белым путям в момент покраски V.
[27:15.540 --> 27:24.340]  Серый цвет. То есть рассматриваем все такие вершинки, что как только мы пришли в V,
[27:24.340 --> 27:28.500]  это все достижимы из нее по белым путям. По белым путям это значит, что все вершины в пути белые.
[27:28.500 --> 27:50.860]  В момент покраски V черный. Данное множество вершин
[27:50.860 --> 28:06.060]  станет черным. Формулировка сложнее доказательства на самом деле. Ну ладно,
[28:06.060 --> 28:17.980]  не прямо уж это так просто. То есть что иметься в виду? Рассмотрим момент времени,
[28:17.980 --> 28:27.420]  когда ДФС зашел в вершинку 2. То есть 4-5-6 еще не посещены. То есть мы находимся на вот этой
[28:27.420 --> 28:33.100]  вот стадии. Покрасили двойку в серый. Вот утверждается, что когда мы покрасим двойку в черный,
[28:33.100 --> 28:43.700]  все вот эти вот вершины станут черными. Вот что утверждает Лемма. Давайте доказывать.
[28:43.700 --> 28:56.500]  До момента покраски этой вершины в черный цвет эти уже будут черными. Ну или к моменту. Давайте
[28:56.500 --> 29:08.540]  пробуем доказать. Давайте докажем, что будто бы это, предположим, что это неверно. Докажем
[29:08.540 --> 29:25.700]  противного. Предположим противное. То есть у нас есть какая-то вершина, которая была, то есть у нас
[29:25.700 --> 29:37.620]  есть какая-то вот наша вершинка В. Вот это все они были достижены по белым путям.
[29:37.620 --> 29:51.900]  Еще тут как-нибудь так. Они все белые. Вот этот момент времени 1, когда мы покрасили в серый.
[29:51.900 --> 30:13.780]  Теперь времени 2. Это уже черная. Вот все они были достижены по белым путям. Теперь предполагаем,
[30:13.780 --> 30:22.740]  что здесь есть какая-то вершина, которая не стала еще черной. Допустим, это вершина У. Пусть
[30:22.740 --> 30:47.620]  вершина У. Ближайшая не черная вершина к В. Ближайшая имеется в виду по числу ребер.
[30:47.620 --> 30:55.220]  Вот она. Какие у нее могут быть варианты? Может быть белый вообще в этот момент? Будто бы.
[30:55.220 --> 31:19.380]  И пусть П это предок У на пути из В У. То есть как мы могли отметить, что DFS он просто строит
[31:19.380 --> 31:25.300]  какие-то ребра, потом поднимается наверх, тут что-то строит и так далее. Граф вход DFS он не очень
[31:25.300 --> 31:32.580]  интеллектуальный. То есть если рассмотреть путь от вершины У до В, то вот наша вершинка П.
[31:32.580 --> 31:48.100]  Вот. А, ну и соответственно, если П, заметим, что раз П это предок, значит П ближе к В. Раз
[31:48.100 --> 31:57.260]  мы выбрали У, это ближайшая не черная вершина, значит П не черная. Ой, да-да, извините, да. Значит
[31:57.260 --> 32:11.820]  П черная. П черная вершина. Ну если П черная вершина, то мы что с вами сделали? Давайте рассмотрим
[32:11.820 --> 32:23.500]  случай У белая. Первый случай У белая. Ну что тогда? Ну если У белая, значит мы в нее еще не
[32:23.500 --> 32:31.180]  заходили, но есть ребро ПУ, которое мы уже проверили, потому что П это черное, значит У не может быть белый,
[32:31.180 --> 32:56.460]  но У белое, но П черное, и ребро ПУ лежит в множестве ребер. Ну раз так, следует, что и У не белое,
[32:56.460 --> 33:10.060]  так ребро должно было быть рассмотрено. Второй случай У серое. Хорошо. Что значит, что У серое?
[33:10.060 --> 33:37.300]  Ну это не очевидно, кстати. Давайте посмотрим так, что если У серое и при этом П черное,
[33:37.300 --> 33:44.900]  значит будто бы мы должны были сначала зайти У, потом в П. Согласны? Только такая конфигурация, возможно.
[33:44.900 --> 33:53.340]  Ну тогда да, тогда у вас нет, не в этом проблема. Прям в том, чтобы вы в П раньше вошли, чем в У,
[33:53.340 --> 34:17.220]  потому что у вас П это предок вершины У в дереве ДФС. В плане? Ну окей, мы можем взять из У в В корчайший путь для определенности, это не сильно ломает.
[34:17.220 --> 34:31.020]  Ну даже если не так, все равно мне кажется ничего не сломается здесь. То есть если у вас У серое, следует что? И П черное.
[34:31.020 --> 34:45.540]  То есть смотрите, если у вас У серое и П это черная вершина, это значит, что вы все-таки вышли из П раньше, чем вышли из У.
[34:45.540 --> 35:10.500]  Ну хорошо, вот так вот согласны. То есть вышли из П раньше, чем из У. Но проблема-то в том, что П у нас будто бы выше на пути.
[35:10.500 --> 35:30.180]  То есть мы должны были бы раньше выйти из У, чем из П. П предок У. Мы определяли предка так, что у нас есть отношение быть предком, что мы из вершины П пришли в вершину У в ходе ДФС непосредственно, в ходе перехода.
[35:30.860 --> 35:34.860]  Вы, в общем, докажете, что у нас в вершине все вершины в черной покрасятся?
[35:34.860 --> 35:53.860]  Нет, я утверждаю, что в момент этого оно покрасится. То есть я утверждаю, что все вершины достижены по белым путям, они покрасятся в черный. Вот. Я предполагаю противное. И вроде как я доказал, что такого быть не может.
[35:54.540 --> 36:13.540]  Ну там есть два варианта, как доказывается. Первый вариант через того, в кого раньше пришли. Вот смотрите, если у нас П черная, так, давайте так посмотрим, что П была посещена ДФСом раньше, чем У, потому что мы П у ребра рассматривали в ходе ДФСа.
[36:14.220 --> 36:23.220]  Вот, но с другой стороны, если У все еще серая, а П черная, это значит, что у нас будто бы рассматривалось ребро УП.
[36:25.220 --> 36:33.220]  Но это же не правда, мы рассматривали ребро ПУ, то есть в обратную сторону. Это первый вариант. Второй вариант через времена выхода.
[36:33.900 --> 36:48.900]  Ну плюс-минус рассуждение будет аналогичным в итоге придем. То есть мы придем, что в такой посылке, в таком предположении, что будто бы мы в У пришли раньше, чем в П, но мы положили, что П определяется ровно так, что наоборот, чтобы сначала в П пришли, а потом в У.
[36:49.580 --> 37:00.580]  Можно так? Это абсолютно аналогичное рассуждение, что рассматриваются, чтобы быть предком на самом деле. Вот, окей, ну будто бы доказали.
[37:01.260 --> 37:16.260]  Лему о белых путях. И у нее есть несколько следствий. Первое следствие, тривиальное, это то, что если вы рассматриваете ДФС от вершинки какой-то, то к моменту окончания ДФС от этой вершинки, вы пустите всю компоненту связанности и только ее.
[37:16.940 --> 37:33.940]  Доказывается тривиальным образом тем, что давайте рассмотрим ДФС от С, стартовой вершины С. Хорошо, она была белой. Рассмотрим это, когда ее покрасили в серый, то есть самый старт ДФС. Утверждается, что все вершины, которые достижены из нее, они достижены ровно по белой вершине С.
[37:34.620 --> 37:51.620]  А к моменту конца они все станут черными. То есть мы все их посетим, и других вершин посетить мы не могли. Вот. Давайте я просто напишу утверждение, а этот полет мысли ставлю вам на вольное конспектирование.
[37:52.300 --> 37:54.080]  Так.
[38:19.080 --> 38:20.580] л
[38:20.580 --> 38:20.800]  в
[38:20.800 --> 38:49.000]  Так, следствие первое, DFS от V посетит все вершины
[38:49.000 --> 39:01.640]  достижимые из V и только их. В частности, да, здесь говорят люди уже про компоненты
[39:01.640 --> 39:07.800]  связанности, но здесь я немножко их предостережу, что если графы ориентированы, то там немного
[39:07.800 --> 39:14.760]  некорректно об этом говорить. Поэтому оставим формулировку, что все вершины достижимые из.
[39:14.760 --> 39:34.840]  Второе, в графе есть цикл, цикл достижимый из V. Тогда и только тогда,
[39:34.840 --> 39:59.560]  когда есть ребро в серую вершину. Как вам идея ставить это упражнение для читателя?
[39:59.560 --> 40:10.840]  Нет, смотрите, у вас будто бы ситуация в эстанатом графе следующая. Вот у вас четверка
[40:10.840 --> 40:17.480]  серая здесь уже, да, и вот вы рассмотрите ребро 6-4. Вот вы пришли в серую, а четверка серая,
[40:17.480 --> 40:44.760]  потому что. Все, значит цикл. Во все графы это верно. Ну имейте в виду это, да. Хорошо,
[40:44.760 --> 40:59.720]  давайте в ходе обхода. Когда в ходе обхода есть ребро. Давайте так. В ходе обхода обнаружено
[40:59.720 --> 41:23.880]  ребро в серую вершину. Ну будто бы да. Такое средненькое. Все еще не прокатывает,
[41:23.880 --> 41:35.720]  когда у вас одно ребро. Давайте вот так вот. Не предок. Вот так вот. Теперь никакой педант не
[41:35.720 --> 41:44.760]  докопается. Ну вы могли бы, не знаю, как-нибудь там фильтровать, что ли, чтобы предок у вас не
[41:44.760 --> 41:48.600]  рассматривается в ходе ДФСа по другим причинам. Не то, чтобы он там какой-то цвет другого,
[41:48.600 --> 41:54.680]  не белого. Вот. Читателям это утверждение оказалось неочевидным, судя по вопросам,
[41:54.680 --> 42:02.400]  в то время пережил, поэтому давайте доказывать. Ну это примерно так, как сказать, что и будет
[42:02.400 --> 42:07.920]  сейчас устроено. Ну давайте докажем, что если есть цикл, то есть ребро в серую вершину. Хорошо.
[42:07.920 --> 42:29.920]  Ну рассмотрим этот цикл. Рассмотрим цикл С, вершина В. Это первая посещенная ДФС,
[42:29.920 --> 42:44.240]  вершина С. То есть давайте нарисуем. Вот у вас есть цикл какой-то. Что? Что считаем?
[42:44.240 --> 43:04.960]  Это В, а это У. То есть вот у вас, вот у вас вершинка В ваша, из которой вы стартовали ДФС,
[43:04.960 --> 43:12.160]  вот у вас первая посещенная вершина У. Вот я утверждаю, что в первое время, то есть когда мы
[43:12.160 --> 43:21.320]  только пришли в вершину У и покрасили ее серой, все вершины на цикле, они белые. Согласны, да?
[43:21.320 --> 43:29.800]  Потому что это все по белым путям было. Но когда мы выходим из У, то есть когда мы У крашим в черный,
[43:29.800 --> 43:38.280]  у нас все эти вершины уже черные. Давайте рассмотрим момент, когда мы эту вершину покрасили в серый,
[43:38.280 --> 43:45.520]  вот предшествующей по цику. Допустим, что мы пошли в этом направлении. Но когда это было серой,
[43:45.520 --> 43:55.480]  это и подавно было серой. Значит мы нашли ребро в серую вершину. Сложный логический переход. Давайте,
[43:55.480 --> 44:16.120]  окей. Пусть это W. Пусть W это предшествующая у вершины С. То есть вы выбрали вот такое направление
[44:16.120 --> 44:23.040]  обхода цикла, ваш ДФС так пошел. И вот вы пришли в вершину В. Рассмотрим момент, когда вершина В была
[44:23.040 --> 44:48.920]  покрашена в серый. Рассмотрим момент, когда покрасили W в серый. Вот я утверждаю, что в этом
[44:48.920 --> 44:54.840]  по премию вершина У все еще серая. Почему это так? Потому что вершина У белой быть не может,
[44:54.840 --> 45:00.480]  мы уже ее посетили. Значит она либо серая, либо черная. Почему она не может быть черной? Потому что
[45:00.480 --> 45:07.800]  если это серая, то по лемме о белых путях мы еще не вышли из У. Раз мы еще не вышли из У, значит она серая.
[45:07.800 --> 45:32.120]  Все. По лемме о белых путях. Этот момент времени. У все еще серая.
[45:37.800 --> 45:45.200]  Ну доказали в эту сторону. Нашли льбров в серую вершину в ходе обхода. В обратную сторону,
[45:45.200 --> 45:53.000]  что если у вас есть льбров в серую вершину, доказывается совсем просто. Вы просто
[45:53.000 --> 45:57.760]  рассматриваете стек рекурсии и говорите, окей, я нашел льбров в серую вершину. Значит у меня в стеке
[45:57.760 --> 46:05.120]  рекурсии лежат все вот эти вот вершинки. Потому что в стеке рекурсии лежат только серые вершины.
[46:05.120 --> 46:09.680]  Белые там не могут лежать, потому что они еще не посещены. Черные не могут лежать, потому что они
[46:09.680 --> 46:18.480]  соответственно удалены были бы уже из стек рекурсии. Все. Доказывается в обратную сторону. Давайте
[46:18.480 --> 46:43.320]  напишем здесь такое. Напишите для формальности. Стек рекурсии только серые вершины. Откуда
[46:43.320 --> 47:01.320]  следует, что ребро первое, это ребро в вершину. Здесь я должен еще сильнее наклониться. Нет,
[47:01.320 --> 47:09.440]  я постараюсь держать. Плюс-минус горизонтальное написание. Вершина из стека. Просто переход
[47:09.440 --> 47:15.520]  в вершину стека. Значит у нас в стеке рекурсии лежит весь цикл, который мы хотели. Все. Конец.
[47:15.520 --> 47:44.600]  Вроде бы доказали. Если вы верите, то давайте начнем еще один раздел.
[47:44.600 --> 47:55.720]  Вот его мы, видимо, уже не успеем сегодня закончить. Но если успеем, то будет вообще классно. Это
[47:55.720 --> 48:17.520]  ДФС на ориентированных графах. Что это значит? Это не значит, что все выше сказанное не работало
[48:17.520 --> 48:23.280]  для ориентированных графов. Это значит, что то, что будет сказано сейчас, работает только для
[48:23.280 --> 48:33.840]  ориентированных. Вот так надо понимать. И определение первое и следующее. Определение.
[48:33.840 --> 48:51.920]  Пусть ж ве, то есть граф, потому что он вершин ве, потому что он вере, это ориентированный граф.
[48:51.920 --> 49:14.720]  Назовем sigma из s модуль v, то есть перестановку топологической сортировкой. Вы что, не ждали,
[49:14.720 --> 49:25.360]  да? Сортировки даже здесь бывают. Мне здесь к топологии мало отношения с сортировкой. Ну или я,
[49:25.360 --> 49:40.040]  крайне вероятно, его не знаю. Если для любых ув из v таких, что пара ув лежит ве, верно,
[49:40.040 --> 49:45.920]  что sigma от u меньше, чем sigma от v. То есть вы пронумеровали вершины так, чтобы были ребра,
[49:45.920 --> 49:57.400]  то есть вот если у вас ребро из u в v, то ребра только из меньших больше. То есть у вас как-то
[49:57.400 --> 50:05.960]  пронумерованы вершины, ну не знаю, давайте скажем что-нибудь такого. 1, 3, 2. Топологическая
[50:05.960 --> 50:13.840]  сортировка у вас превратит эту нумерацию в 1, 2, 3. То есть у вас из меньших больше шли ребра и только.
[50:13.840 --> 50:25.480]  Казалось бы, зачем это нужно? Ну это вам позволит, ну считать, что будто бы, ну, то есть это вам
[50:25.480 --> 50:31.000]  позволит удобно итерироваться по вашему графу, если вы хотите что-то считать. Потому что вам
[50:31.000 --> 50:43.240]  достаточно допустить хор от минимальных номеров и победа, в общем-то. Во, это важно. Я же не сказал,
[50:43.240 --> 50:49.400]  что она существует. Я говорю, что вот назовем эту штуку такой. А теперь давайте доказывать
[50:49.400 --> 51:05.280]  утверждение. Топологическая сортировка или топ-сорт на жиргонизме, на жиргоне существует
[51:05.280 --> 51:19.040]  тогда и только тогда, когда граф цикличен. Вот такое утверждение или теорема, можете считать.
[51:19.040 --> 51:37.040]  Давайте доказывать. В какую сторону кажется проще? Ну да. От противного. Доказываем отсюда-сюда.
[51:37.040 --> 51:42.640]  Давайте скажем, что если в графе есть цикл, то топ-сорт не существует. Это вроде очевидно на самом деле.
[51:42.640 --> 51:51.200]  Ну что, если у вас есть график цикл, то как бы вы не переставляйте, у вас стоит, что одна вершина
[51:51.200 --> 52:08.320]  строго меньше другой. Ну давайте так рассмотрим произвольную сигму и цикл v1, v2, vn, v1.
[52:08.320 --> 52:26.400]  Узнается, что мы как-то переупорядочили. Тогда сигма топ-сорт. Этого следует, что сигма v1 меньше,
[52:26.480 --> 52:42.640]  чем сигма v2 меньше, чем сигма vn меньше, чем сигма v1 конец. Противоречие. Здесь можно бы сказать тем,
[52:42.640 --> 52:52.720]  что у вас порядок меньше, цикличен, и вы пытаетесь его вести на вершинах. Но можно описать это подробнее.
[52:52.720 --> 53:03.760]  Давайте в обратную сторону. Если у вас граф цикличен, то топ-сорт существует,
[53:03.760 --> 53:08.440]  и у вас есть методы доказательств того, что что-то существует.
[53:08.440 --> 53:15.620]  Ну да, давайте просто приведем алгоритм, который у вас строит.
[53:22.720 --> 53:37.960]  В обратную сторону. Я забыл ввести парочку штук определения, которые ему удобно оперировать.
[53:37.960 --> 53:42.280]  Давайте мы их сначала введем, потом будем им оперировать.
[53:42.280 --> 53:59.920]  Соответственно, определение t и над v. Время вода в вершину v.
[53:59.920 --> 54:09.300]  Момент, когда ее посетили. Когда покрасили ее в серый.
[54:09.300 --> 54:32.220]  Т.е. tout от v. Это время выхода из вершины v.
[54:32.820 --> 54:40.020]  Момент, когда покрасили ее в черный.
[54:40.020 --> 54:54.780]  Все, теперь я могу говорить на родном языке, языке DFS.
[54:54.780 --> 55:06.940]  Все, доказываем в обратную сторону. Я утверждаю следующее, что если отсортировать вершины
[55:06.940 --> 55:18.620]  по убыванию времени выхода, то это победа. Для этого нужно рассмотреть ребро uv, рассмотрим
[55:18.620 --> 55:41.180]  uv из e, т.е. ребро. Вот я утверждаю, что время выхода из вершинки u строго больше, чем время
[55:41.180 --> 55:55.860]  выхода из вершины v. Утверждение tout от u строго больше, чем tout от v. Доказательства.
[55:55.860 --> 56:11.540]  Первый случай. t in от u больше, чем t in от v. Т.е. мы сначала вошли в вершину v, затем в вершину u.
[56:11.540 --> 56:20.260]  Графоцикличен, значит, мы не можем добраться до вершины u никак.
[56:20.260 --> 56:49.700]  Т.е. так как графоцикличен, из вершины v нет пути в u. Откуда следует, что мы сначала
[56:49.700 --> 57:06.500]  выйдем из вершины v, потом как-то наш DFS дойдет до вершины u, а это строго меньше, чем tout от u по
[57:06.500 --> 57:27.940]  определению. Доказали. Второй случай. t in от u меньше, чем t in от v. Что это значит? Это значит,
[57:27.940 --> 57:37.780]  что мы сначала пастили u, потом пришли v. Полемия о белых путях снова. К моменту,
[57:37.780 --> 57:47.740]  когда мы покрасили вершинку u в черный, это уже должна стать черный, вершина v. Полемия о белых
[57:47.740 --> 58:10.540]  путях. Что это значит, что tout от v меньше, чем tout от u? От v меньше, чем tout от u. Так,
[58:10.540 --> 58:24.940]  эта часть доказали. Ну все, победа. Если у вас есть графоцикличен, то значит tout от u, tout от v
[58:24.940 --> 58:35.020]  не устроит порядок на touts на самом деле. Вот. Почему это так? Потому что я предполагал,
[58:35.020 --> 58:40.900]  что графоцикличен, тогда у меня, если есть ребро в Waze, то верно вот это вот. То есть меня
[58:40.900 --> 59:01.340]  устраивает полностью порядок touts. Значит, порядок в убывании touts, tout,
[59:01.340 --> 59:14.260]  нас устраивает. Окей, казалось бы, все. Давайте для каждой вершины
[59:14.260 --> 59:27.780]  посчитаем tout, за v лог v отсортируем победу. Это уныло. Так не хочется делать. Почему? Потому
[59:27.780 --> 59:34.180]  что быстрее, может, за линию. Потому что на самом деле, в ходе DFS, а что вы делаете? Вы,
[59:34.180 --> 59:37.780]  когда красите вершину в черный, вы можете добавлять ее просто в какой-то списочек,
[59:37.780 --> 59:44.700]  ну там вектор, пушить ее. Он утверждается, что у вас вершины будут отсортированы по возрастанию touts.
[59:44.700 --> 59:50.900]  Значит, вам нужно просто развернуть этот список, это победа. В ходе DFS,
[59:50.900 --> 01:00:11.220]  момент покраски в f черный, будем добавлять ее в массив.
[01:00:21.900 --> 01:00:22.900]  Это к чему вопрос?
[01:00:22.900 --> 01:00:28.220]  Будто бы это неправда.
[01:00:28.220 --> 01:00:39.580]  То есть, там как бы не очевидно, что у вас, то есть, в прямом том, что у вас есть
[01:00:39.580 --> 01:00:45.060]  есть interval v и z, у вас может быть что то, что это. Но tout и точно соотношение соблюдено.
[01:00:45.060 --> 01:01:04.300]  Покраски f черный, будем брать ее в массив. Добавили в массив, тогда в массиве вершины
[01:01:04.300 --> 01:01:17.780]  отсортированы по возрастанию tout. Следовательно, осталось
[01:01:17.780 --> 01:01:32.340]  превернуть. Конец. Заодно привиляет алгоритм по строению топологической сортировки за линейное
[01:01:32.340 --> 01:01:38.620]  время. Почему за линейное время? Потому что tout и можно считать за линию. Это просто DFS запустить.
[01:01:38.620 --> 01:01:41.340]  Так, по этому вопросу остались?
[01:01:41.340 --> 01:01:55.740]  Это? Ну мы рассмотрим, что tout больше, чем tout. То есть, мы сначала вошли в...
[01:01:55.740 --> 01:02:05.980]  Сейчас. Сначала вошли в u, потом в v. Нет, наоборот в room. Сначала в v, потом u. Потому что tout
[01:02:05.980 --> 01:02:11.380]  в v меньше, значит мы к ней пришли раньше. Пришли раньше в v. Так как у нас графоцикличен,
[01:02:11.380 --> 01:02:17.740]  у нас нельзя отсюда как-то прийти в вершину u. То есть, нет такого пути. Иначе мы нашли цикл.
[01:02:17.740 --> 01:02:25.140]  Значит, DFS, когда пришел в вершину v, он сначала тут как-то походит, потом выйдет из вершины v и
[01:02:25.140 --> 01:02:31.820]  только потом придет в вершину u. Когда мы его запустим из другого в мейне, когда будем запускать
[01:02:31.820 --> 01:02:37.820]  вот этот вот. То есть, нам есть фор и запускаем вершины, если они еще не посещены. То есть,
[01:02:37.820 --> 01:02:49.820]  мы придем в u позже. Вот это этот случай. Второе, это когда у вас сначала пришли в u, потом v.
[01:02:49.820 --> 01:03:02.620]  В полеме о белых путях, когда у вас u покрасилось в черный, v уже стало черным. Значит, в момент
[01:03:02.620 --> 01:03:09.380]  времени того, как v покрасилось в черный, произошел раньше, чем мы покрасили u в черный. Ну все,
[01:03:09.380 --> 01:03:28.820]  это вот это и есть. Окей, давайте еще определение попишем тогда. Определение. Вершины u и v сильно
[01:03:28.820 --> 01:03:56.020]  связаны, если есть путь из u в v и есть путь из v в u. О как! Очень концептуальное определение.
[01:03:56.020 --> 01:04:06.900]  У вас есть ориентированный граф. Например, вот такой вот граф. Вот есть ли в нем хотя бы одна
[01:04:06.900 --> 01:04:23.300]  пара сильно связанных вершин? Что? Да, здесь нет вершин сильно связанных. Хотя, казалось бы,
[01:04:23.300 --> 01:04:32.620]  граф ориентированный. Соответственно, вершины u и v называются слабо связаны в ориентированном
[01:04:32.620 --> 01:04:42.900]  графе, если убрать ориентацию ребер и найдется путь из u в v. Окей, так, что нам нужно теперь?
[01:04:42.900 --> 01:04:51.940]  Я утверждаю, что это отношение транзитивно. То есть, если у вас u и v сильно связаны,
[01:04:51.940 --> 01:05:01.420]  и v w сильно связаны, то и u w сильно связаны. Это очевидно, да. Очевидная симметрия данного
[01:05:01.420 --> 01:05:11.420]  отношения. То есть, если у вас u и v сильно связаны, то v и u сильно связаны. Концепт. Теперь надо
[01:05:11.420 --> 01:05:19.660]  разобраться с рефлексивностью. Давайте для галочки будем считать, что она выполнена. Что из u есть путь
[01:05:19.660 --> 01:05:28.140]  в u и из u есть путь в u длины 0. Вот, поэтому рефлексивность формально выполнена. А значит,
[01:05:28.140 --> 01:05:33.060]  это отношение эквивалентности. А если у нас есть отношение эквивалентности, значит, что мы можем
[01:05:33.060 --> 01:05:40.980]  сделать? Вот, да, определение. Нет, давайте утверждение сначала, что это отношение эквивалентности.
[01:05:40.980 --> 01:05:50.740]  И доказательства будет, ну, не знаю, это, наверное, любой семиклассник,
[01:05:50.740 --> 01:06:02.300]  который умеет рисовать стрелочки, проведет. Вот, данное отношение. Это отношение эквивалентности.
[01:06:02.300 --> 01:06:25.800]  Да, данное выше, которое. Следующее определение. Назовем классом. Назовем классу. Классом мы
[01:06:25.800 --> 01:06:48.320]  называть никого не будем. Класс эквивалентности. По данному отношению компоненту, компонент
[01:06:48.680 --> 01:07:08.080]  сильной связности. Сильной связности. Далее их буду называть КСС. Есть еще компоненту слабой связности,
[01:07:08.080 --> 01:07:14.080]  внезапно. Это те, которые достижимы, если брать ориентацию. Но мы их рассматривать не будем,
[01:07:14.080 --> 01:07:23.840]  поэтому КСС определяется однозначно. Вот. Зачем они нам нужны вообще? Ну, на самом деле,
[01:07:23.840 --> 01:07:28.080]  есть много интересных применений. Да, наверное, то, что в КСС вы можете от каждой вершины добраться
[01:07:28.080 --> 01:07:36.480]  до каждой. Вот. То есть, это такой аналог связности в ориентированных графах. И очень хотелось бы,
[01:07:36.480 --> 01:07:42.320]  чтобы все графы были сильно связанными, но нет. Так, к сожалению, не получится. А, ну да,
[01:07:42.320 --> 01:07:48.520]  в качестве замечания граф называется сильно связанным, если он представляет собой одну большую
[01:07:48.520 --> 01:07:55.280]  компоненту сильной связности. Аналогично, как граф называется связанным, если он связан.
[01:07:55.280 --> 01:08:10.040]  Ну да, как бы тут лучше договориться о понятиях заранее, иначе можно разойтись
[01:08:10.040 --> 01:08:19.840]  на достаточно концептуальном уровне какое-то время. Вот. Ну ладно. А-па-па-пам. Еще определение.
[01:08:19.840 --> 01:08:45.280]  Графом конденсации по отношению какому-то, по произвольному отношению, по отношению эквивалентности
[01:08:45.280 --> 01:09:08.880]  назовем граф, где классы эквивалентности сжаты в одну вершину. Да, заметьте, здесь не уточняю,
[01:09:08.880 --> 01:09:13.840]  какое именно отношение эквивалентности, потому что у нас будет следующая лекция отношения
[01:09:13.840 --> 01:09:17.760]  реберной двухсвязанности, вершины двухсвязанности, будут соответствующие компоненты,
[01:09:17.760 --> 01:09:26.880]  соответствующие конденсации, бла-бла-бла. Вот. Так, это про граф конденсации. Утверждение.
[01:09:26.880 --> 01:09:52.560]  Граф конденсации по отношению сильной связанности оцикличен. Надеюсь, доктатство,
[01:09:52.560 --> 01:10:00.400]  то есть минус возникло в голове. Или надо пояснить, что такое граф конденсации все-таки? Давайте пример.
[01:10:00.400 --> 01:10:22.040]  Хорошо. Нарисуем. Сжаты. Ну, по-хорошему надо. Скажем так, я ограничусь картинкой и вашим
[01:10:22.040 --> 01:10:29.240]  пониманием. Ну, окей, вы можете рассмотреть ребра в новом графе, описать их по-хорошему,
[01:10:29.240 --> 01:10:34.120]  что да, действительно переберем все ребра в старом графе, посмотрим, каким классом эквивалентности
[01:10:34.120 --> 01:10:41.720]  лежат их концы и скажем, что вот нам новое ребро в графе конденсации. Если такое ребро уже было,
[01:10:41.720 --> 01:10:51.920]  то пропускаем. Мы не на формалках, чтобы это вводить. Вот. По действиям конденсации эта штука
[01:10:51.920 --> 01:11:03.920]  перейдет вот такой вот. Почему? Потому что вот у вас компонента сильной связанности одна. Здесь все
[01:11:03.920 --> 01:11:08.600]  друг с другом достижимы. Но расширить ее не можете. Из-за этой вершины эти не достижимы уже.
[01:11:08.600 --> 01:11:17.880]  Аналогично здесь все достижимы. Поэтому по действиям конденсации вот эти вот компоненты
[01:11:17.880 --> 01:11:29.480]  мы сжали. Ну и вершинка осталась. Вот и все. Ну, тогда, я думаю, доказывать здесь особо не нужно.
[01:11:29.480 --> 01:11:41.640]  Ну, давайте докажем. Вперед времени много. Да, вы это будете доказывать. Вы будете доказывать,
[01:11:41.640 --> 01:11:46.040]  что любой сильно связанный компонент есть цикл. Да, это правда. Потому что если у вас...
[01:11:46.040 --> 01:11:53.600]  А вот это не факт. Утверждается, что компонент сильно связанности можно разбить в объединение циклов.
[01:11:53.600 --> 01:12:03.920]  Быть может пересекающихся. Вот это будет правдой. Окей, так, что мы хотим? Доказать,
[01:12:03.920 --> 01:12:20.360]  что граф конденсации отличный. Ну, от противного. Пусть C1 и C2 это вершины графа конденсации.
[01:12:20.360 --> 01:12:43.440]  Да. И C1 и C2 лежат на цикле. Да, то есть вот C1, вот у вас C2. Можно как-то добраться сюда,
[01:12:43.440 --> 01:12:49.760]  можно как-то добраться обратно. Ну, логично, что тогда это все одна большая компонента сильной
[01:12:49.760 --> 01:12:55.200]  связанности. Потому что вы возьмете какую-нибудь отсюда вершину U, какую-нибудь отсюда вершину V,
[01:12:55.200 --> 01:13:00.480]  и вы получите, что они сильно связаны. Почему? Ну, давайте рассмотрим маршрут между C1 и C2.
[01:13:00.480 --> 01:13:10.920]  Это будет U1, это будет V1. В силу сильной связанности существует маршрут из U в U1,
[01:13:10.920 --> 01:13:21.280]  здесь из V1 в V. Логично рассмотрим V2 и U2. Ну, все, вот мы построили в общем-то маршрута.
[01:13:21.280 --> 01:13:42.880]  Пусть U1, U2. Так, рассмотрим произвольную, рассмотрим произвольную,
[01:13:42.880 --> 01:14:06.200]  произвольную U из C1, V из C2. И маршруты, ну или пути U1, V1, где U1 лежит в C1, V1 лежит в C2,
[01:14:06.200 --> 01:14:17.240]  и V2, U2, где V2 лежит в C2, U2 лежит в C1. То есть рассмотрим вот такие вот маршруты.
[01:14:17.240 --> 01:14:39.120]  Так как C1 и C2 КСС, с этого следует, что существуют маршруты U, U1, U2, U. Также существует,
[01:14:39.120 --> 01:14:52.760]  это потому что C1 КСС. Дальше существуют маршруты V1, V, V2, потому что C2 КСС.
[01:14:52.760 --> 01:15:18.720]  Значит, что из этого всего следует, что U, маршрут U1, маршрут V1, маршрут V, маршрут V2, маршрут U2, маршрут U – это цикл.
[01:15:18.720 --> 01:15:39.160]  Откуда следует, что U и V лежат в одной КСС. Но мы утверждали, что они в разных КСС, потому что C1 и C2 – разные вершины.
[01:15:39.160 --> 01:15:53.960]  Но здесь нам вообще без разницы. Мы можем просто вырезать этот кусок. Здесь, ну, можно сказать, что это...
[01:15:53.960 --> 01:16:07.040]  Скажем так, обычно циклы разрешают делать и то, и то. Чаще всего подразумевают, что цикл не пересекается по вершинам,
[01:16:07.040 --> 01:16:12.720]  потому что если у вас есть какое-то пересечение по вершинам, что-нибудь типа такого, то вы можете эту петлю просто вырезать.
[01:16:12.720 --> 01:16:21.000]  То есть это то, что это был цикл, цикл он останется. Здесь проблем особо нет с этим, как определять.
[01:16:21.000 --> 01:16:34.040]  Вот. Не, ну я достаточно знатно растянул время, доказывая это простейшего утверждения.
[01:16:34.040 --> 01:16:41.040]  В целом, можно закончить на этом лекцию. На следующей лекции нас ждет алгоритм Касараю,
[01:16:41.040 --> 01:16:46.320]  который нам позволит искать КСС. Вот с помощью утверждения на той доске про таута как раз.
[01:16:46.320 --> 01:16:50.520]  Вот. А пока на этом все. До следующей недели.
