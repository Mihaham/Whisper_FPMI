[00:00.000 --> 00:25.040]  Так, ну чё, поехали.
[00:25.040 --> 00:28.000]  Мы сегодня начинаем последний блок.
[00:28.000 --> 00:32.000]  В триллекс у нас нету идёт всё про деревья.
[00:32.000 --> 00:36.000]  Пообсуждаем всякие разные алгоритмы на них.
[00:36.000 --> 00:40.000]  Определение давайте я дам такое.
[00:40.000 --> 00:46.000]  Пусть g это неориентированный граф.
[00:46.000 --> 00:50.000]  Тогда он называется деревом, если он связан и не содержит циклов.
[00:58.000 --> 01:12.000]  Сразу замечание, что можем сказать про деревья.
[01:12.000 --> 01:25.000]  Если же это дерево, то, во-первых, мы можем сразу сказать, что в нём количество рёбер на 1 меньше, чем число вершин.
[01:26.000 --> 01:30.000]  Ну потому что, что вот это значит?
[01:30.000 --> 01:32.000]  Что значит, что он связан и не содержит циклов?
[01:32.000 --> 01:34.000]  Ну давайте я сделаю следующее.
[01:34.000 --> 01:41.000]  Давайте я нарисую вершин нашего графа.
[01:41.000 --> 01:46.000]  И буду проводить постепенно рёбра.
[01:46.000 --> 01:48.000]  Буду проводить постепенно рёбра.
[01:48.000 --> 01:52.000]  При этом циклы не появляются, и в конце все они попадут в одну и ту же компоненту связанности.
[01:52.000 --> 01:57.000]  Каждый раз, когда я провожу рёбро, я провожу рёбро между разными компонентами связанности, то есть я беру, соединяю.
[01:57.000 --> 02:03.000]  Раньше я считаю, что все вершины — это отдельная компонента связанности, стоящая за одной только вершинкой.
[02:03.000 --> 02:05.000]  Потом провожу рёбра и объединяю компоненты.
[02:05.000 --> 02:11.000]  Вот компоненты, вот компоненты, потом могу их союдить, станет вот такая большая компонент, ну и так далее.
[02:11.000 --> 02:17.000]  А раз циклов нет, то я не могу проводить рёбров внутри одной компоненты, а только между компонентами.
[02:17.000 --> 02:22.000]  Ну и в конце они все должны склеиться в одну большую компоненту, значит всего шагов был ровно минус один.
[02:22.000 --> 02:29.000]  Если на каждом шаге две компоненты склеиваются, а в конце все в одной компоненте, значит шагов ровно на один меньше, чем вершин.
[02:29.000 --> 02:31.000]  Вот такое простое рассуждение.
[02:31.000 --> 02:42.000]  Ну и второе замечание такое, что между любыми двумя вершинами существует ровно один простой путь.
[02:42.000 --> 02:47.000]  Существует единственный простой путь между ними.
[02:56.000 --> 03:07.000]  Ну тут я менее формально скажу, смотрите, вот если есть две вершинки у и в, если вдруг предположить, что между ними есть два разных пути каких-то, вот такой вот и такой вот,
[03:07.000 --> 03:11.000]  ну тогда как бы видно на картинке есть цикл.
[03:11.000 --> 03:19.000]  Да, это так неформально, чтобы доказать формально и показать, что при наличии двух разных путей в графе найдется цикл,
[03:19.000 --> 03:26.000]  надо сказать, ну давайте посмотрим на множество ребер, используемых в этих путях, возьмем их симметрическую разность, и это получится в точности цикл.
[03:26.000 --> 03:33.000]  Потому что поскольку пути различные, то это будет какое-то непустое множество, и в нем у всех вершин будет степень 2 как раз такие,
[03:33.000 --> 03:38.000]  ну за счет того, что мы берем симметрическую разность, мы что-то похоже уже делали, когда эти ребер же доказывали,
[03:38.000 --> 03:45.000]  брали симметрическую разность двух множеств, ну здесь будет как раз цикл, ну точнее цикл там или несколько циклов может быть,
[03:45.000 --> 03:53.000]  если возьму вот такое что-нибудь и вот такое, ну тогда вот вам, пожалуйста, куча циклов получается.
[03:53.000 --> 04:05.000]  Так, значит давайте посмотрим на следующую характеристику графа.
[04:05.000 --> 04:16.000]  Определение диаметром графа G называется максимально возможное кратчайшее расстояние между всеми парами вершин.
[04:17.000 --> 04:30.000]  Максимум по всем УВ, дист УВ, ну где дист как обычно это число ребер на пути между ними, ну на кратчайшем пути между ними.
[04:30.000 --> 04:36.000]  Более того, поскольку мы сказали, что путь на самом деле единственный между вершинами, то можно даже не особо вариться про то,
[04:36.000 --> 04:42.000]  что он кратчайший, не кратчайший, он единственный, на единственный путь между У и В есть.
[04:42.000 --> 04:49.000]  Вот, простой. Ну и давайте научимся как в дереве находить диаметр.
[04:58.000 --> 05:00.000]  Ну давайте алгоритм.
[05:00.000 --> 05:14.000]  С помощью DFS, если мы запустим DFS от произвольной вершины дерева, мы на самом деле сможем все дерево подвесить за вот этот корень, за эту вершинку,
[05:14.000 --> 05:22.000]  и по сути тогда картинка будет примерно такая. Вот мы какую-то вершину назначили в качестве корня, потом у них будет сколько-то детей на первом уровне,
[05:22.000 --> 05:27.000]  потом у них будут дети на втором уровне соответственно, ну и так далее.
[05:27.000 --> 05:36.000]  То есть это в каком-то смысле как дерево обхода BFS, мы взяли корень, соответственно все вершины смежные с ним лежат на первом уровне,
[05:36.000 --> 05:40.000]  все новые вершины смежные с ним на втором и так далее.
[05:40.000 --> 05:47.000]  Но поскольку в графе у нас все пути единственны между парами вершин, то это может быть даже не BFS, а просто DFS,
[05:47.000 --> 05:53.000]  и каждый раз, когда мы переходим в новую вершину, мы сразу понимаем, что то расстояние, которое мы донесли, это есть кратчайшее расстояние.
[05:53.000 --> 05:57.000]  Поэтому вместо BFS можно всегда использовать DFS на деревьях.
[05:57.000 --> 06:01.000]  Просто встали в R, пошли куда угодно, это получается вершина на глубине 1.
[06:01.000 --> 06:05.000]  Пошли в любую непосещенную вершину из нее, это вершина на глубине 2, ну и так далее.
[06:05.000 --> 06:10.000]  Потому что назад я никуда не перепрыгну и более коротких пути никогда не найду.
[06:10.000 --> 06:14.000]  Поэтому если я нашел путь какой-то длины, то он есть кратчайший путь до вершины.
[06:14.000 --> 06:17.000]  Поэтому это можно делать с DFS.
[06:17.000 --> 06:19.000]  Ну тогда давайте скажем следующее.
[06:19.000 --> 06:38.000]  Давайте x это произвольная вершина дерева, запустим DFS от x, и тем самым мы найдем все глубины всех вершин, если x это корень.
[06:38.000 --> 06:43.000]  То есть вот я подвесил наше дерево за x, у каждой вершины теперь есть своя глубина.
[06:43.000 --> 06:46.000]  Это глубина 0, глубина 1, глубина 2 и так далее.
[06:46.000 --> 06:48.000]  Давайте от depth обозначу.
[06:48.000 --> 06:53.000]  Глубина здесь 0, тут 1, тут 2.
[06:53.000 --> 06:57.000]  И давайте найдем параллельную вершину с максимальной глубиной.
[06:57.000 --> 07:07.000]  Пусть y, вершина с максимальным depth от y.
[07:07.000 --> 07:10.000]  То есть другими словами y это самая удаленная от x вершина.
[07:10.000 --> 07:14.000]  Потому что глубина по факту просто расстояние от корня или там до корня.
[07:14.000 --> 07:17.000]  Вот пусть y самая глубокая вершина.
[07:17.000 --> 07:20.000]  Вершина с максимальной глубиной.
[07:20.000 --> 07:31.000]  Тогда давайте мы запустим DFS от y.
[07:31.000 --> 07:40.000]  Ну опять пусть z это вершина с максимальной глубиной, ну теперь уже относительно y.
[07:40.000 --> 07:46.000]  То есть я переподвесил моё дерево, запустил новый DFS от y, вынес y в корень и заново насчитал все глубины.
[07:46.000 --> 07:56.000]  Так вот пусть z это вершина с максимальным значением глубины от z.
[07:56.000 --> 07:57.000]  Вот.
[07:57.000 --> 08:09.000]  Тогда я утверждаю, что y, z это диаметр.
[08:09.000 --> 08:15.000]  То есть на пути между ними как раз достигается то самое максимальное кратчайшее расстояние.
[08:15.000 --> 08:16.000]  То есть смотрите, что мы сделали.
[08:16.000 --> 08:21.000]  Наша цель была найти вообще максимальное кратчайшее расстояние между всеми парами вершин.
[08:21.000 --> 08:22.000]  Что я сделал?
[08:22.000 --> 08:27.000]  Я сделал произвольный x, нашёл самую далёкую от него y, нашёл от y самую далёкую z.
[08:27.000 --> 08:30.000]  И вот оказывается, что y, z это диаметр.
[08:30.000 --> 08:38.000]  То есть нет более длинных путей, чем пути между y и z.
[08:38.000 --> 08:42.000]  Понятно, что это работает за o от n.
[08:42.000 --> 08:47.000]  Потому что по факту мы просто два раза запустили DFS, а DFS работает за n плюс m.
[08:47.000 --> 08:56.000]  А поскольку у нас в нашем дереве m от n минус 1, то значит всё работает просто o от n.
[08:56.000 --> 09:06.000]  Теперь почему-то всё корректно.
[09:06.000 --> 09:08.000]  Давайте рассмотрим настоящий диаметр.
[09:18.000 --> 09:23.000]  Вот есть a, вот есть b.
[09:23.000 --> 09:27.000]  Пусть между ними, единственный простой путь между ними, это диаметр.
[09:27.000 --> 09:33.000]  Тут какие-то вершинки есть.
[09:33.000 --> 09:37.000]  Тогда давайте поймём вообще, как дерево всё может выглядеть, если a, b это диаметр.
[09:37.000 --> 09:45.000]  То есть мы вот так вот взяли две самые далёкие вершины, растянули их, нарисовали дерево так, что a и b образуют какую-то прямую.
[09:46.000 --> 09:49.000]  Давайте поймём, как вообще всё остальное дерево может выглядеть.
[09:49.000 --> 09:54.000]  Я утверждаю, что вот здесь вот вершин быть не может.
[09:54.000 --> 10:02.000]  Потому что если бы у b был какой-то сосед отлично от вот этого, тогда мы бы могли найти путь от a до сюда, и получился бы путь длиннее диаметра.
[10:02.000 --> 10:03.000]  Такого не бывает.
[10:03.000 --> 10:05.000]  Значит здесь никого нет.
[10:05.000 --> 10:07.000]  Что может быть здесь?
[10:07.000 --> 10:12.000]  Я утверждаю, что к этой вершине, давайте вот так нарисую,
[10:12.000 --> 10:19.000]  что если я рассмотрю компоненту связанности, который получается после удаления этих двух ребер, подвешенный в это вершине,
[10:19.000 --> 10:22.000]  то здесь будет дерево глубины максимум 1.
[10:22.000 --> 10:27.000]  Потому что если отсюда есть глубина 2, то я точно так же мог бы от a дойти до сюда,
[10:27.000 --> 10:31.000]  и потом вместо шага в b сделать два шага вниз, получить путь больше, чем диаметр.
[10:31.000 --> 10:37.000]  Поэтому всё, что находится здесь, это под дерево глубины максимум 1.
[10:37.000 --> 10:41.000]  Ну и давайте симметрично скажем, здесь ничего нет, здесь под дерево глубины максимум 1,
[10:41.000 --> 10:47.000]  здесь под дерево глубины максимум 2, потому что если было бы 3, то я мог бы от a дойти до сюда,
[10:47.000 --> 10:49.000]  и в этом вместо этих двух ребер использовать 3 ребра вниз.
[10:49.000 --> 10:55.000]  Симметрично здесь не больше, чем 2 глубина, здесь не больше, чем 3, не больше, чем 3,
[10:55.000 --> 11:00.000]  ну и здесь центрально имеет глубину максимум 4.
[11:00.000 --> 11:04.000]  Ну как-то так выглядит наше дерево.
[11:04.000 --> 11:07.000]  И теперь если просто аккуратно проанализировать, что делает наш алгоритм,
[11:07.000 --> 11:12.000]  то мы поймём, что реально y и z это тоже будет диаметр.
[11:12.000 --> 11:16.000]  Ну давайте что-нибудь нарисую. Давайте скажу, что x где-нибудь вот здесь вот лежало.
[11:16.000 --> 11:19.000]  Пусть x было здесь.
[11:19.000 --> 11:24.000]  Тогда y это самая далёкая вершина от x.
[11:24.000 --> 11:29.000]  Так, я утверждаю, что...
[11:29.000 --> 11:34.000]  Так, сейчас будет мерзкая формула, но я её хочу написать всё равно.
[11:37.000 --> 11:48.000]  Я утверждаю, что если я найду самую далёкую вершину от x, y,
[11:48.000 --> 11:51.000]  ну не знаю, где-нибудь вот здесь пусть,
[11:51.000 --> 11:58.000]  тогда максимальное расстояние от y до a или от y до b, максимум до двух расстояний, это диаметр.
[11:58.000 --> 12:08.000]  Так, одну секунду.
[12:08.000 --> 12:10.000]  Да, почему?
[12:10.000 --> 12:14.000]  Ну потому что если не так, то я на самом деле мог бы вместо y взять a или b,
[12:14.000 --> 12:16.000]  и расстояние от x я бы увеличил.
[12:16.000 --> 12:23.000]  Ну например, давайте скажем, что y где-нибудь вот здесь вот находится.
[12:23.000 --> 12:28.000]  Y находится где-нибудь вот здесь, то есть на расстоянии от 1 от вот этой вершины.
[12:28.000 --> 12:33.000]  Ну тогда понятно, что ни a y, ни b y, это не диаметр, потому что они меньше длины имеют.
[12:33.000 --> 12:36.000]  Ну тогда смотрите, на самом деле можно было бы от x дойти до сюда,
[12:36.000 --> 12:41.000]  и вместо того, чтобы идти до y, дойти до b, мы бы получили только больше расстояния.
[12:41.000 --> 12:45.000]  Поэтому y не может быть самой далёкой вершины от x.
[12:45.000 --> 12:50.000]  Ну и вообще в любом случае можно показать, что если y находится...
[12:50.000 --> 12:55.000]  То есть на самом деле вот это равенство можно интерпретировать так,
[12:55.000 --> 13:00.000]  что y это вершина в одном из этих поддеревьев на максимально возможной глубине.
[13:00.000 --> 13:04.000]  То есть если она здесь лежит, то она обязательно на глубине y, на глубине 3 лежит.
[13:04.000 --> 13:07.000]  То есть на максимально возможной, какой у нас есть тут ограничение.
[13:07.000 --> 13:13.000]  Потому что если она лежала бы выше, то тогда b была бы дальше от x, чем y.
[13:13.000 --> 13:16.000]  Можно дойти до сюда, и вместо того, чтобы пройти меньше, чем 3 ребра здесь,
[13:16.000 --> 13:21.000]  можно пройти 3 ребра здесь и попасть в более далёкую вершину.
[13:21.000 --> 13:28.000]  Ну значит y как раз вот на максимально глубоком расстоянии,
[13:28.000 --> 13:32.000]  возможном от очередной вершины нашего пути.
[13:32.000 --> 13:35.000]  Ну а раз она на максимально возможном расстоянии от этой вершины,
[13:35.000 --> 13:39.000]  то тогда либо досюда диаметр, либо досюда диаметр.
[13:39.000 --> 13:43.000]  Ну более-менее всё.
[13:43.000 --> 13:47.000]  Поэтому потом, когда я запускаю DFS от y и нахожу самую далёкую вершину от y,
[13:47.000 --> 13:52.000]  мы найдём как раз-таки либо a, либо b, либо на самом деле возможно что-то ещё.
[13:52.000 --> 13:55.000]  Например, мы могли бы найти вот такой вот путь.
[13:55.000 --> 13:58.000]  Это тоже может быть диаметр.
[13:58.000 --> 14:01.000]  Ну его длина такая же, как длина пути a-b.
[14:01.000 --> 14:04.000]  То есть никто не гарантирует, что вы найдёте тот самый диаметр a-b,
[14:04.000 --> 14:07.000]  но длину вы найдёте такую же.
[14:07.000 --> 14:12.000]  Потому что раз вот это вот верно, максимальное расстояние от y до a или от y до b, это диаметр.
[14:12.000 --> 14:15.000]  Мы найдём самую далёкую вершину от y в качестве z,
[14:15.000 --> 14:21.000]  но понимаем, что она находится на расстоянии в точности таком же, как диаметр.
[14:21.000 --> 14:24.000]  Вопросики?
[14:24.000 --> 14:27.000]  Ну тут рука махается.
[14:27.000 --> 14:32.000]  На самом деле надо просто въехать, что глубины вот этих подеревьев вот так вот ограничены,
[14:32.000 --> 14:37.000]  и понять, что делает DFS, что делает вот этот алгоритм, если x где-то лежит.
[14:37.000 --> 14:42.000]  Где может лежать y?
[14:42.000 --> 14:47.000]  Так, хорошо.
[14:47.000 --> 14:50.000]  Тогда давайте определение.
[14:50.000 --> 14:53.000]  Скажем, вот здесь хорошая картинка.
[14:53.000 --> 14:56.000]  Вот эта вершина называется центром.
[14:56.000 --> 14:59.000]  Центр всего дерева.
[14:59.000 --> 15:03.000]  То есть по факту это просто серединка диаметра.
[15:03.000 --> 15:08.000]  Вот, короче, любого, да?
[15:08.000 --> 15:13.000]  Если чётность не совпала, то там будут две вершины посередине, они обе центры.
[15:13.000 --> 15:16.000]  Значит, определение.
[15:16.000 --> 15:23.000]  Если диам, вот g, ну я считаю, что g-дерево здесь,
[15:23.000 --> 15:28.000]  если диаметр имеет чётную длину,
[15:28.000 --> 15:35.000]  то его середина называется центром.
[15:35.000 --> 15:42.000]  Ну а если длина нечётна,
[15:42.000 --> 15:47.000]  то две центральные вершины на нём это будет центры.
[15:47.000 --> 15:51.000]  То есть, например, если у меня есть вот такие вот пять ребер,
[15:51.000 --> 15:57.000]  то две центральные вершины это центры.
[15:57.000 --> 16:03.000]  Вот, и простое утверждение говорит о том,
[16:03.000 --> 16:06.000]  что центры лежат на всех диаметрах.
[16:06.000 --> 16:09.000]  То есть сколько бы ни было центров, один или два,
[16:09.000 --> 16:12.000]  то есть такая картинка или такая,
[16:12.000 --> 16:15.000]  эти центры лежат на всех диаметрах.
[16:15.000 --> 16:19.000]  То есть, если у меня есть вот эти центры,
[16:19.000 --> 16:22.000]  то они лежат на всех диаметрах.
[16:22.000 --> 16:24.000]  Если бы ни было центров, один или два,
[16:24.000 --> 16:27.000]  то есть такая картинка или такая,
[16:27.000 --> 16:30.000]  эти центры всегда лежат на всех диаметрах вообще.
[16:30.000 --> 16:47.000]  Любой центр лежит на любом диаметре.
[16:47.000 --> 16:50.000]  Ну давайте докажем.
[16:50.000 --> 16:52.000]  Посмотрим случай сначала отчётной длины,
[16:52.000 --> 16:54.000]  когда центр однозначно определён.
[16:54.000 --> 16:57.000]  Давайте нарисую какой-то диаметр.
[16:57.000 --> 17:00.000]  Вот его центр.
[17:00.000 --> 17:04.000]  Пусть какой-то другой диаметр через этот центр не проходит.
[17:04.000 --> 17:06.000]  Значит, он целиком либо вот здесь слева,
[17:06.000 --> 17:09.000]  либо целиком вот здесь справа.
[17:21.000 --> 17:24.000]  Ну вот, да.
[17:28.000 --> 17:31.000]  Ой, как мерзко.
[17:34.000 --> 17:36.000]  Сейчас я полминутки позалипаю.
[17:36.000 --> 17:39.000]  Если не получится, то руками помашем.
[17:51.000 --> 17:54.000]  Ну вот, да.
[17:54.000 --> 17:57.000]  Но вот не очень понятно, на самом деле.
[17:57.000 --> 18:00.000]  Ладно, да, окей, придётся.
[18:03.000 --> 18:05.000]  Ну да, смотрите.
[18:05.000 --> 18:08.000]  Давайте вот опять нарисуем вот эти вот по деревьям.
[18:08.000 --> 18:11.000]  То есть я знаю, если я ещё продлю его немножечко,
[18:11.000 --> 18:13.000]  я знаю, что здесь по дереву глубины максимум 2,
[18:13.000 --> 18:15.000]  здесь по дереву глубины максимум 1,
[18:15.000 --> 18:17.000]  здесь ничего нет, но здесь то же самое.
[18:17.000 --> 18:19.000]  Но если я предположу вдруг,
[18:19.000 --> 18:22.000]  что есть какой-то диаметр, не проходящий из этого центра,
[18:22.000 --> 18:26.000]  то значит, второй диаметр находится целиком либо здесь, либо здесь.
[18:26.000 --> 18:29.000]  Ну вот, да.
[18:29.000 --> 18:32.000]  Ну вот, да.
[18:32.000 --> 18:35.000]  Ну вот, да.
[18:35.000 --> 18:38.000]  Второй диаметр находится целиком либо здесь, либо здесь.
[18:38.000 --> 18:41.000]  Но давайте попытаемся найти максимально возможную длину пути,
[18:41.000 --> 18:44.000]  которая находится вот в этом подграфе,
[18:44.000 --> 18:47.000]  не содержащем этого центра слева.
[18:47.000 --> 18:50.000]  Ну, видимо, он имеет длину максимум 4.
[18:50.000 --> 18:53.000]  Ну, в нашем случае, да.
[18:53.000 --> 18:56.000]  На самом деле, он имеет длину строго меньше, чем вот этот большой диаметр,
[18:56.000 --> 18:59.000]  потому что, ну, как он может выглядеть?
[18:59.000 --> 19:02.000]  Если он даже находится где-то вот здесь,
[19:02.000 --> 19:05.000]  ну, вот так вот, 2 вверх, 2 вниз.
[19:05.000 --> 19:08.000]  Ну а если он идет куда-то влево,
[19:08.000 --> 19:11.000]  то опять-таки длину максимум 2 может себе прибавить.
[19:21.000 --> 19:24.000]  Ну да, да, да.
[19:24.000 --> 19:27.000]  В любом случае, этот путь выглядит как-то так.
[19:27.000 --> 19:30.000]  Мы из одного под дерево идем куда-то влево и спускаемся в другое под дерево.
[19:30.000 --> 19:33.000]  Мы из одного под дерево идем, ходим.
[19:33.000 --> 19:36.000]  Но понятно, что тогда суммарная длина вот этого пути,
[19:36.000 --> 19:39.000]  просто длина этого пути, меньше, чем...
[19:39.000 --> 19:42.000]  Ну, короче, меньше, чем...
[19:42.000 --> 19:45.000]  Да. Меньше равно, чем вот этот путь, видимо.
[19:45.000 --> 19:48.000]  3, 4. Удвоенный, да.
[19:48.000 --> 19:51.000]  Вот.
[19:51.000 --> 19:54.000]  Ну, неприятно, короче.
[19:54.000 --> 19:57.000]  Ну, кому-то понятно.
[19:57.000 --> 20:00.000]  Хорошо.
[20:00.000 --> 20:03.000]  Я говорю, что путь вот здесь лежащий, он строго меньше длины имеет.
[20:03.000 --> 20:06.000]  Строго меньше длины имеет.
[20:06.000 --> 20:09.000]  То же самое, если у нас два центра, давайте вот это вот рассмотрим.
[20:09.000 --> 20:12.000]  Вот они два центра.
[20:12.000 --> 20:15.000]  Если вдруг диаметр не содержит, скажем, вот эту вершину,
[20:15.000 --> 20:18.000]  значит, он находится целиком либо здесь, либо здесь.
[20:18.000 --> 20:21.000]  Ну и тот же самый аргумент проходит.
[20:21.000 --> 20:24.000]  Скажем, если он лежит здесь,
[20:24.000 --> 20:27.000]  то значит, мы знаем, как здесь ограничены глубины всех этих под деревьев.
[20:27.000 --> 20:30.000]  Ну и опять, если посчитать максимально возможную длину пути,
[20:30.000 --> 20:33.000]  которая здесь находится...
[20:39.000 --> 20:42.000]  Обе-обе. Любой центр лежит на любом диаметре.
[20:42.000 --> 20:45.000]  Ну, понятно, что они...
[20:45.000 --> 20:48.000]  Неважно, да, в любом случае это одно и то же рассуждение.
[20:48.000 --> 20:51.000]  Неважно, как это сказать, можно ли слаться из одного в другое.
[20:51.000 --> 20:54.000]  Ну, то же самое, если здесь померить максимальную длину пути,
[20:54.000 --> 20:57.000]  то она будет меньше, чем весь большой диаметр.
[20:57.000 --> 21:00.000]  Вот, хорошо.
[21:00.000 --> 21:03.000]  Вот.
[21:03.000 --> 21:06.000]  Вот.
[21:06.000 --> 21:09.000]  Вот.
[21:09.000 --> 21:12.000]  Так, следующая полезная характеристика.
[21:12.000 --> 21:15.000]  Центроид.
[21:15.000 --> 21:18.000]  Вершина.
[21:18.000 --> 21:21.000]  Вершина.
[21:21.000 --> 21:24.000]  Вершина.
[21:24.000 --> 21:27.000]  Вершина.
[21:27.000 --> 21:30.000]  Вершина.
[21:30.000 --> 21:33.000]  Вершина.
[21:33.000 --> 21:36.000]  Вершина.
[21:36.000 --> 21:39.000]  Вершина.
[21:39.000 --> 21:42.000]  Вершина.
[21:42.000 --> 21:45.000]  Вершина.
[21:45.000 --> 21:48.000]  Вершина.
[21:48.000 --> 21:51.000]  Вершина.
[21:51.000 --> 21:54.000]  Вершина.
[21:54.000 --> 21:57.000]  Вершина.
[21:57.000 --> 22:00.000]  Вершина.
[22:00.000 --> 22:03.000]  Если после ее удаления размер всех компонент связанности
[22:03.000 --> 22:08.600]  g-v, то есть в графе, получающемся удалением вершины v, ну и, соответственно, всех реберезней исходящих,
[22:08.600 --> 22:12.600]  если в этом графе все компоненты связности
[22:18.600 --> 22:25.600]  имеют размер не больше, чем n пополам, ну где n, как обычно, число вершин.
[22:33.000 --> 23:00.000]  Утверждение такое же, что центроид всегда существует, и он либо единствен, либо их два, и не соедини ребром.
[23:03.000 --> 23:17.000]  Центроид всегда существует, и он либо единствен, либо их два, и не соедини ребром.
[23:17.000 --> 23:37.000]  Так, давайте сначала докажем, что он всегда существует. Давайте придадим алгоритм поиска центроида.
[23:47.000 --> 24:12.000]  Алгоритм такой. Давайте мы в нашем DFS еще посчитаем для каждого поддерева его размер.
[24:12.000 --> 24:18.000]  Вот смотрите, мы подвешиваем, мы всегда подвешиваем дерево за какую-то вершину, за какой-то корень,
[24:18.000 --> 24:25.000]  и, соответственно, неявно мы ориентировали все ребра сверху вниз, да, от корня вниз к листам.
[24:25.000 --> 24:31.000]  Давайте мы для каждой вершины сохраним, сколько вершин лежит в ее поддереве.
[24:31.000 --> 24:38.000]  То есть вот для каждой вершины v мы хотим посчитать, сколько, вот здесь вот суммарно, вершин находятся в ее поддереве,
[24:38.000 --> 24:45.000]  то есть сколько вершин достижено из нее по ребрам вниз. Это будет называться sub3 от v, размер поддерева.
[24:45.000 --> 24:52.000]  Это очень легко посчитать с помощью DFS, ну потому что если я для какой-то вершины,
[24:52.000 --> 24:57.000]  точнее если я для всех детей какой-то вершины знаю размер их поддеревьев, то есть я знаю сколько здесь, знаю сколько здесь,
[24:57.000 --> 25:03.000]  то размер вот этого поддерева с корнем в этой вершинке, эта сумма размеров поддеревьев с корнями в ее детях плюс один.
[25:03.000 --> 25:10.000]  То есть мне надо либо в поддерево пойти, либо остаться в вершине v, сумма поддеревьев плюс один.
[25:10.000 --> 25:17.000]  Вот, значит хорошо, давайте мы с помощью DFS насчитаем все наши sub3.
[25:17.000 --> 25:27.000]  С помощью DFS найдем все sub3.
[25:28.000 --> 25:33.000]  Для всех вершин посчитаем размер поддерева.
[25:33.000 --> 25:40.000]  Ну а дальше делаем следующее, смотрите, вот у меня есть корень v.
[25:40.000 --> 25:46.000]  Понятно, что его размер в точности n. В поддереве корни лежат все вершины.
[25:46.000 --> 25:54.000]  Давайте сделаем следующее, давайте мы будем идти в такого сына, у которого размер поддерева хотя бы n пополам.
[25:54.000 --> 26:01.000]  Вот если здесь sub3 хотя бы n пополам, то мы в него спускаемся.
[26:01.000 --> 26:06.000]  Здесь то же самое, если есть какой-то сын, у которого размер поддерева хотя бы n пополам, мы в него спускаемся.
[26:06.000 --> 26:11.000]  И так далее, пока соответственно не дойдем до вершины, у которой нет такого сына.
[26:11.000 --> 26:20.000]  То есть мы закончимся либо в вершине вообще без детей, либо в вершине, у которой все дети имеют sub3 строго меньше, чем n пополам.
[26:20.000 --> 26:25.000]  А сама вершина еще имеет sub3 больше набравной, чем n пополам.
[26:28.000 --> 26:34.000]  Ну тогда понятно, что вот эта вершина, последняя вершина, у которой sub3 больше, чем n пополам, является центроидом.
[26:34.000 --> 26:38.000]  Потому что после ее удаления что происходит? Давайте так нарисуем.
[26:38.000 --> 26:46.000]  Что происходит после удаления? Во-первых, все поддеревья дочерние становятся компонентами связности, но мы знаем, что их размеры меньше, чем n пополам.
[26:46.000 --> 26:49.000]  Потому что у них sub3 было меньше, чем n пополам.
[26:49.000 --> 26:54.000]  С другой стороны, мы знаем, что все вот это поддерево суммарно имело размер хотя бы n пополам.
[26:54.000 --> 27:00.000]  Значит, дополнение, все остальное, имеет размер не больше, чем n пополам.
[27:00.000 --> 27:04.000]  Потому что если здесь хотя бы половина, то в дополнении не больше половины всех вершин.
[27:04.000 --> 27:11.000]  Ну а значит, удаление этой вершины как раз оставляет мне несколько компонент связности и вот эту большую.
[27:11.000 --> 27:14.000]  Все размеры которых не больше, чем n пополам.
[27:15.000 --> 27:17.000]  Профит.
[27:17.000 --> 27:25.000]  То есть по факту алгоритм очень простой. Мы просто спускаемся вниз в произвольную вершину sub3 хотя бы n пополам, пока так можно делать.
[27:25.000 --> 27:38.000]  Пока есть сын с размером поддерева хотя бы n пополам, спуск в него.
[27:38.000 --> 27:43.000]  Последние вершины, в которые мы закончили, это будет центроид.
[27:43.000 --> 27:48.000]  Понятно, что этот алгоритм конечен, но мы не можем бесконечно долго спускаться по нашему дереву, потому что он просто конечен.
[27:48.000 --> 27:52.000]  Значит, рано или поздно мы закончимся в вершине, которая удовлетворяет всем этим свойствам.
[27:57.000 --> 28:01.000]  Мы нашли какой-то, мы показали, что он существует.
[28:03.000 --> 28:07.000]  Конечно, иногда их бывает два, например, в таком интеллектуальном дереве.
[28:08.000 --> 28:10.000]  Здесь обе вершины центроида.
[28:12.000 --> 28:14.000]  В более сложном дереве, вот таком тоже.
[28:14.000 --> 28:16.000]  А не обе центроида.
[28:20.000 --> 28:22.000]  На самом деле это может быть.
[28:22.000 --> 28:26.000]  Мы нашли самый низкий центроид.
[28:26.000 --> 28:29.000]  Возможно, еще вот этот товарищ тоже центроид.
[28:29.000 --> 28:31.000]  Потому что для него тоже самое верно.
[28:31.000 --> 28:38.000]  Если размер вот этого по дереву ровно напополам, то получается после удовлетворения этой вершины здесь будет напополам и сверху меньше напополам.
[28:38.000 --> 28:42.000]  Ну, значит, возможно вот эти два центроида.
[28:42.000 --> 28:44.000]  Ну, неважно.
[28:44.000 --> 28:47.000]  То есть вот это рассуждение нужно, чтобы показать, что он существует.
[28:47.000 --> 28:49.000]  Теперь мы докажем, что их не больше, чем два.
[28:49.000 --> 28:52.000]  Значит, это мы показали, что он существует.
[28:52.000 --> 28:59.000]  Почему центроидов не больше, чем два?
[29:02.000 --> 29:04.000]  Ну, пусть их...
[29:08.000 --> 29:10.000]  Я скажу так.
[29:10.000 --> 29:19.000]  Пусть есть два центроида, не соединенные ребром.
[29:25.000 --> 29:27.000]  Придем к противоречию сейчас.
[29:27.000 --> 29:31.000]  Если мы это сделаем, то мы покажем на самом деле, что центроида всегда не больше, чем два.
[29:31.000 --> 29:35.000]  Потому что если бы у нас было три центроида, то понятное дело, что хотя бы два из них ребром не соединены,
[29:35.000 --> 29:38.000]  но не может быть такого, что все они соединены ребром.
[29:38.000 --> 29:39.000]  Иначе есть цикл.
[29:39.000 --> 29:41.000]  Значит, мы показали, что центроидов будут не больше, чем два.
[29:41.000 --> 29:43.000]  И если их два, то они соединены ребром.
[29:44.000 --> 29:46.000]  Ну собственно то, что мы хотели показать.
[29:47.000 --> 29:50.000]  Давайте предположим, что есть два центроида не соединенные ребром.
[29:50.000 --> 29:53.000]  Ну вот есть какой-то у, есть какой-то в.
[29:53.000 --> 29:59.240]  есть кое-то v. Давайте рассмотрим путь между ними. Здесь будет хотя бы одна
[29:59.240 --> 30:03.600]  промежуточная вершина, потому что там не ребро, значит хотя бы два ребра между
[30:03.600 --> 30:10.560]  ними. Вот. Ну и давайте напишем следующее. Давайте опять у нас есть какой-то путь,
[30:10.560 --> 30:14.200]  давайте рассмотрим это под дерево, это под дерево, вот это под дерево. То есть
[30:14.200 --> 30:17.720]  компоненты связанности, на которые распадается дерево после удаления всех
[30:17.720 --> 30:28.960]  ребер этого пути. Ну смотрите, размер вот этой штуки хотя бы n пополам, потому что
[30:28.960 --> 30:35.960]  поскольку u это центроид, то после ее удаления вот это вот все будет связанной
[30:35.960 --> 30:39.800]  компонентом размера не больше н пополам. Но после удаления u все, что
[30:39.800 --> 30:42.720]  лежит здесь справа на этом пути и в под деревьях, имеет размер не больше н
[30:42.720 --> 30:46.520]  пополам. Значит вот это вот как дополнение имеет размер хотя бы n
[30:46.520 --> 30:53.600]  пополам. Согласны? Ну то же самое для v, верно? Вот это вот под дерево имеет
[30:53.600 --> 30:57.200]  размер хотя бы половина, потому что поскольку v центроид, то после удаления
[30:57.200 --> 31:01.800]  вот это вот имеет размер максимум n пополам, а значит дополнение к нему хотя бы
[31:01.800 --> 31:06.400]  n пополам. Ну все, противоречие. Мы получили, что есть два под дерево размера n
[31:06.400 --> 31:11.120]  пополам, между которыми есть еще по крайней мере одна вершина. Значит суммарный
[31:11.120 --> 31:14.880]  размер дерева это хотя бы n пополам плюс хотя бы n пополам плюс хотя бы один. А
[31:15.520 --> 31:22.920]  надо n получить, но такого не бывает. Мы получили, что n больше чем n пополам
[31:22.920 --> 31:28.320]  плюс n пополам плюс один равно n плюс один. Противоречие.
[31:44.880 --> 31:52.880]  Нет, вот здесь я когда пишу n пополам, это у меня всегда число, сравнение как с
[31:52.880 --> 31:57.000]  числами обычными. Я здесь нигде ничего никуда не округляю. Это вам в коде, если
[31:57.000 --> 32:01.560]  надо, вам надо будет подумать куда округлить. А вот здесь я все, ну как бы у
[32:01.560 --> 32:04.480]  меня математика была, у меня не программирую, у меня математика была, без округления
[32:04.480 --> 32:06.760]  работала.
[32:14.880 --> 32:29.280]  Так, хорошо. Значит, ну с центроидами тоже разобрались. Упражнения, ну это вот
[32:29.280 --> 32:34.680]  часто окажется, да, что центры и центроиды что-то похожее, что там их всегда один или
[32:34.680 --> 32:39.040]  два, и они тоже там, если два соединяются ребром, но вот придумайте деревья, в которых
[32:39.040 --> 32:51.720]  центроиды и центры это разные вершины. Ну вот придумайте. Придумать дерево, в котором
[32:51.720 --> 33:13.320]  центры это не то же самое, что центроиды. Так, хорошо. Следующий сюжет про изоморфизмы.
[33:13.320 --> 33:34.160]  Определение. Пусть g и h этого графа, тогда функция phi, действующая из множества вершин
[33:34.160 --> 33:50.120]  графа g, множество вершин графа h, называется изоморфизмом, если выполняются одновременно
[33:50.120 --> 34:00.120]  два условия. Во-первых, фиетабеекция. Во-вторых, ребра, соединенные ребром, переводится
[34:00.120 --> 34:03.200]  в ребра, соединенные ребром, а ребра, не соединенные ребром, переводится в ребра,
[34:03.200 --> 34:13.680]  не соединенные ребром. Значит, если uv это ребро графа g, то, соответственно, фиату,
[34:13.680 --> 34:22.200]  fiat g, fiat v, то есть это ребро графа h. А если не ребро, то не ребро.
[34:43.680 --> 34:53.800]  Вот. Значит, на самом деле изоморфизм это по факту просто перенумерация вершин такая, что вот после
[34:53.800 --> 35:00.920]  нее граф остается самим собой. То есть в каком-то смысле g и h это один и тот же граф, отличающийся
[35:00.920 --> 35:05.520]  лишь перенумерация ребр. Ну что такое биекция? Это как раз перенумерация. Мы все вершинки
[35:05.520 --> 35:10.560]  перенумеровываем просто, и у нас сохраняются все ребра. То есть, например, вот есть такой граф,
[35:10.560 --> 35:21.040]  и такой граф. Вот. Они изоморфизм, ну понятно, у них одинаковая структура. Понятно, что их можно
[35:21.040 --> 35:24.600]  перенумеровать так, что один переводится в другой. Надо сказать, что вот это вот перенумеруется в
[35:24.600 --> 35:34.200]  тройку, вот это в единицу, но эти два в двойку-четверку. То есть изоморфизм это как бы одинаковость с
[35:34.200 --> 35:41.640]  точностью до перенумерации вершин. Вообще говоря, задача проверки графов на изоморфность,
[35:41.640 --> 35:49.080]  задача сложная, и пока ее за пленом решать не умеют. То есть если вам даны два графа, произвольные,
[35:49.080 --> 35:53.760]  неориентированные два графа, и спрашивают изоморфы они или нет, то есть ну можно ли перенумеровать
[35:53.760 --> 35:57.800]  вершины одного так, чтобы получить другой, это сложная задача, пока ее никто решать не умеет за пленом.
[35:57.800 --> 36:08.840]  А с деревья мы решим за n log n. Наверное, не буду записывать, не очень важна информация. С деревьями давайте
[36:08.840 --> 36:24.360]  научимся проверять изоморфность двух деревьев. Значит сначала давайте считать, что деревья корневые,
[36:24.440 --> 36:45.040]  и давайте проверим два корневых дерева на изоморфность. Корневые это по факту значит,
[36:45.040 --> 36:52.600]  что они просто за какую-то вершину подвешены, и корень должен перейти в корень. Давай считать,
[36:52.600 --> 37:00.200]  что вот они корневые у нас. Ну здесь все очень просто. Идея следующая. Давайте мы для каждого
[37:00.200 --> 37:04.720]  поддерева, который у нас в принципе существует в одном из наших деревьев, давайте мы каждому
[37:04.720 --> 37:15.680]  поддереву сопоставим какой-то номер CO2, который однозначно определяет класс эквивалентности вот
[37:15.680 --> 37:21.400]  этого всего поддерева. То есть мне нужно сделать так, что изоморфные поддеревья отображаются в одно
[37:21.440 --> 37:25.920]  то же число, а разные, точнее не изоморфные, поддеревья отображаются в разные числа.
[37:25.920 --> 37:31.200]  То есть мне нужно биекции из поддеревьев в натуральные числа, чтобы изоморфные соответствовали
[37:31.200 --> 37:37.480]  одинаковым числам, не изоморфные – разным. Например, можно поддеревья, состоящие из одной
[37:37.480 --> 37:44.640]  вершины, все отобразить в ноль. Ну понятно, это все изоморфные поддеревья, состоящие из одной
[37:44.640 --> 37:51.880]  только вершины, они и заморфнут. А если у меня, скажем, вот такие есть два дерева, то они должны
[37:51.880 --> 37:57.480]  в разные числа отобразиться. Например, это в один, это в два. Ну или наоборот, как угодно.
[37:57.480 --> 38:01.920]  Разные поддеревья в разные числа, одинаковые в одинаковые. Как это сделать? Ну смотрите, вот есть дерево.
[38:01.920 --> 38:10.880]  Давайте мы каким-нибудь DFS-ом сейчас посчитаем классы эквалентности всех поддеревьев.
[38:10.880 --> 38:18.400]  Ну для листьев понятно. Давайте скажем, что лист это по факту поддерево из одной вершины.
[38:18.400 --> 38:24.400]  Давайте сразу скажем, что такое поддерево кодируется нулем. Теперь пусть есть какая-то вершина.
[38:24.400 --> 38:31.280]  И для всех ее детей мы уже знаем номер класса эквалентности соответствующего поддерева.
[38:31.280 --> 38:36.880]  То есть если есть V, то я рекурсивно запустился от всех детей и уже знаю C для всех вот этих
[38:36.880 --> 38:44.400]  поддеревьев. Ну давайте скажем, что это у1, у2, у3. Соответственно у меня класс эквалентности это C от у1,
[38:44.400 --> 38:56.880]  C от у2, C от у3. Ну они рекурсивно там нашлись с помощью DFS. А дальше смотрите, чтобы понять класс
[38:56.880 --> 39:03.820]  эквалентности V, мне на самом деле достаточно знать вот эти вот числа как мультимножество. Потому что
[39:03.820 --> 39:07.660]  понятно дело, что от перестановки этих чисел между собой у меня изоморфинность не пропадает. Я
[39:07.660 --> 39:12.260]  всегда могу просто поменять порядок следований детей, так что у меня поменяются два числа местами.
[39:12.260 --> 39:17.980]  С другой стороны, если есть какая-то другая вершина, у которой вот это вот множество классов детей
[39:17.980 --> 39:23.820]  отлично от вот этого множества, то они понятное дело неизоморфны. То есть если здесь скажем классы
[39:23.820 --> 39:32.780]  0,1,4, а есть другая вершина, у которой классы 0,1,3. Ну понятно дело они неизоморфны. Мы не можем
[39:32.780 --> 39:39.100]  понять, что 0 надо отобразить на 0, 1 на 1, а 4 на 3 мы никак не отобразим, потому что они неизоморфны.
[39:39.100 --> 39:47.540]  Неизоморфны соответствуют разным числам. Значит у меня каждая вершина по факту кодируется мультимножеством
[39:47.540 --> 39:53.540]  вот этих вот классовых эквалентностей детей. Давайте после перерыва доведем этот алгоритм.
[39:53.540 --> 40:01.260]  Итак, давайте алгоритм напишем, может быть в гоблинском переводе, но все же. Смотрите, я сказал,
[40:01.260 --> 40:07.780]  что мне вот здесь вот нужно как бы мультимножество сравнивать на равенство между собой. Для этого давайте
[40:07.780 --> 40:13.580]  я просто сложу их в вектор, вот эти вот числа я сложу в вектор и посорчу его. Тогда понятно, что равным
[40:13.580 --> 40:18.820]  мультимножством соответствуют одинаковые векторы, разным разным. После сортировки одинаковое
[40:18.820 --> 40:22.660]  мультимножство дают одинаковые векторы, разные разные. То есть я вот это складываю просто в вектор,
[40:22.660 --> 40:35.500]  вектор int и сортирую его. И чтобы узнавать, какой номер класса эквалентности будет соответствовать
[40:35.500 --> 40:48.420]  вот этому вот вектору, я заведу map из вектор в int. У меня будет map из вектор в int. Ну давайте
[40:48.420 --> 40:58.300]  как-нибудь назову num. Эта штука говорит следующее, что если у вершины вектор детей образует вот такой
[40:58.300 --> 41:05.060]  вот набор классов, тогда номер класса эквалентности самой вершины вот такой-то. А отображение из
[41:05.060 --> 41:09.860]  вектор в номер, что если дети вот такие, то сама вершина имеет такой класс эквалентности.
[41:09.860 --> 41:21.660]  Слово hash только у вас в голове пока что. У меня его нет, у меня нет и не будет. Итак,
[41:21.660 --> 41:46.020]  DFS. Значит, давайте заведем какой-нибудь вектор A. Проходим по всем детям. Ну давайте здесь я имею в виду,
[41:46.020 --> 41:50.460]  что как бы вот сейчас, во-первых, всех именно детей. Если у меня граф был не ориентирован,
[41:50.460 --> 41:53.700]  то мне нужно проверить, что я не поднялся в родителя, но давайте там в комментариях напишу.
[41:53.700 --> 42:03.460]  Tu это ребенок V. Если у вас граф не ориентирован, надо проверить, что вы не в родителя поднялись,
[42:03.460 --> 42:12.020]  а именно вниз пошли, в новую вершинку. Но это легко делается. Запускаемся рекурсивно и считаем,
[42:12.020 --> 42:18.100]  что этот DFS уже сделал так, что ceut tu корректно определено. Ceut tu это номер класса эквалентности
[42:18.100 --> 42:32.540]  по дереву с корнем вту. Значит, его надо pushback-нуть в A. A pushback ceut tu. После этого цикла в A лежит как
[42:32.540 --> 42:37.260]  раз-таки то самое мультимножество номеров класса эквалентности детей. Дальше у него нужно посортировать.
[42:37.260 --> 42:50.060]  Ну и, собственно, в вершине V присвоить классы эквалентности, которые соответствуют этому
[42:50.060 --> 42:55.460]  вектору A в нашей мапе. Но, возможно, его, правда, еще не существует. Давайте когда его заведем и
[42:55.460 --> 43:00.820]  скажем, что вектор A соответствует какому-то новому числу. То есть, если его в мапе еще не было,
[43:00.820 --> 43:03.940]  давайте положим и скажем, что он соответствует какому-то новому натуральному числу,
[43:03.940 --> 43:09.940]  которого еще не было. Давайте какой-нибудь глобальный счетчик я заведу, каунтер какой-нибудь,
[43:09.940 --> 43:17.980]  равный нулю изначально. Если, ну тут опять я напишу как умею, вы наверняка это лучше можете
[43:17.980 --> 43:32.860]  написать. Значит, если в num не было A, если неверно, что он там был, тогда я его туда кладу с новым
[43:32.860 --> 43:37.180]  каунтером. То есть, я завожу новый класс эквалентности, говорю, что этот вектор A соответствует
[43:37.180 --> 43:52.180]  кнтшке и кнт увеличиваю. numata равно knt++. Все, теперь у меня в мапе я знаю, что этот вектор A
[43:52.180 --> 44:10.900]  чему-то соответствует. Но надо сказать, что c от v равно numata. Конец. Теперь мы для каждого
[44:10.900 --> 44:14.620]  подерева знаем номер классикой эквалентности. При этом, одинаковым и заморфовым подеревям
[44:14.620 --> 44:20.260]  соответствует одинаковая классика эквалентности, разным и разным. Ну и в терминах исходной задачи,
[44:20.260 --> 44:26.100]  если есть два корневых дерева, вот есть одно дерево, есть другое дерево, как проверить,
[44:26.100 --> 44:31.540]  что они не заморфованы? Ну давайте запустим dfs здесь, оба посчитают класс эквалентности для
[44:31.540 --> 44:37.660]  корней. Если они одинаковые, то дерево изоморфное, если нет, то не изоморфное. Ну потому что, как бы,
[44:37.660 --> 44:44.260]  у нас вот сохраняется вот это свойство, что одинаковым векторам соответствует одинаковое число.
[44:44.260 --> 44:54.100]  Значит, изоморфность это то, что у нас вот эти цешки в корнях одинаковые. Да-да, корневые деревья
[44:54.100 --> 44:58.660]  у нас, поэтому мы подвесили за корень, и соответственно тогда корень обязательно должен в корень перейти.
[44:58.660 --> 45:13.180]  Не торопитесь, пожалуйста. В точку. Значит, за сколько это работает? Я отражаю, что за inlog. Почему?
[45:13.180 --> 45:20.300]  Вообще не очень понятно. Потому что в мапе у меня лежат в качестве ключей векторы, а векторы
[45:20.300 --> 45:27.060]  сами сами могут быть достаточно длинными. Я их pushback'у расширяю. Но за сколько вообще тогда
[45:27.060 --> 45:32.180]  работает сравнение, за сколько работает запрос к мапе? Вот это вот за сколько работает, вот это вот
[45:32.180 --> 45:43.260]  за сколько это работает? Ordered map написано. Я unordered не знаю, что такое, и вам не советую, и вам не советую.
[45:43.260 --> 45:54.180]  Так вот, вопрос к вам. За сколько работает вот такая операция? Проверка вхождения a в num.
[45:54.180 --> 46:08.740]  Чуть дольше, потому что как бы за логарифом действие в мапе, но каждое действие это сравнение a с каким-то другим ключом.
[46:08.740 --> 46:15.020]  Как у нас работает дерево поиска? Мы встали в корень, сравниваем корень с нашим a, и спускаемся там влево
[46:15.020 --> 46:21.180]  или вправо. Поэтому не просто логарифом, а логарифом умножить на время сравнения. И поскольку у меня
[46:21.180 --> 46:26.180]  векторы это какие-то сложные объекты, то их сравнение работает задолго, но на самом деле за модуль a.
[46:26.180 --> 46:35.380]  Потому что чтобы сравнить вектор a с каким-то другим вектором, достаточно вот такого времени. Мы идем
[46:35.380 --> 46:41.740]  слева-направо по обоим векторам, либо один из них кончился, либо мы нашли два, ну короче,
[46:41.740 --> 46:46.580]  обычное лексиграфическое сравнение векторов. Либо один кончился, либо мы нашли позицию, в которой один
[46:46.580 --> 46:51.860]  отличается от другого, тогда мы знаем, кто из них меньше, кто больше. Вот, ну тогда все вот эти штуки
[46:51.860 --> 47:02.100]  работают за analog-n. Поэтому суммарное время работы это, ну вот здесь вот какая-то линия из-за всяких
[47:02.100 --> 47:14.700]  DFS-ов, push-backs и так далее, плюс сумма по всем вершинам, ну по a давайте напишу, analog-n. Вот, а вот это вот, это n.
[47:14.700 --> 47:23.620]  Потому что размер a это в точности количество детей у вершины v, а суммарное количество детей
[47:23.860 --> 47:41.060]  по всем вершинам, это просто общее число вершин. Все, поэтому это будет analog-n. Понятно? Чудно, ну все,
[47:41.060 --> 47:46.260]  значит корневые деревья мы на изоморфность научились проверять. Теперь некроневые.
[47:53.620 --> 48:08.180]  Решение очень простое. Давайте оба дерева подвесим, ну скажем, за центроид. Идеальный мир, это когда
[48:08.180 --> 48:12.060]  центроид единственный. Тогда мы точно знаем, за какую вершину надо подвергать первый дерево, за
[48:12.060 --> 48:18.220]  какое второе. И понятное дело, и понятное дело, что при изоморфизме центроид перейдет в центроид.
[48:18.220 --> 48:23.700]  Ну потому что у меня полностью графы сохраняются, значит все свои тоже сохраняются. Вот, поэтому если
[48:23.700 --> 48:28.340]  были единственные, мы бы просто за них подвесили, запустили тот алгоритм и проверили, что корневые
[48:28.340 --> 48:33.140]  деревья изоморфны. Ну а если там два центрои, давайте просто переберем, за какой центроид мы
[48:33.140 --> 48:45.860]  подержим в каждом дереве. И хотя бы в одном из случаев должна быть изоморфность. Переберем в качестве
[48:45.860 --> 49:04.180]  корней центроиды обоих деревьев. Ну все, дальше дерево становится корневым, мы умеем проверять
[49:04.180 --> 49:13.740]  корневую изоморфность. Собственно все. Конечно, можно центры. Можно взять в качестве корня любую
[49:13.740 --> 49:20.060]  характеристику, которая от единицы вариантов. Тогда симплотика останется точно такой же.
[49:20.060 --> 49:28.580]  Я не шарю. На самом деле здесь можно два, потому что можно в первом один зафиксировать, а второй
[49:28.580 --> 49:35.900]  перебирать. Можно не перебирать в первом. Я не знаю, кто единственный там. Давайте напишу, что можно
[49:35.900 --> 49:56.900]  центры. Альтернативно можно подвесить за центры. Ну вот. Поэтому симплотика остается такой же,
[49:57.260 --> 50:15.940]  Вопросики? Смотрите, не можем, потому что без сортировки мы, скорее всего, никуда не продвинемся.
[50:15.940 --> 50:23.900]  Да, кстати, я забыл посчитать время работы сортировки, но понятно, что сортировка работает
[50:23.900 --> 50:30.940]  за аллога. И это меньше, чем аллогн. Поэтому вот это вот доминируется вот этим. Хэш таблица,
[50:30.940 --> 50:35.580]  говорю, не даст выигрыша, потому что вам нужно что? У вас самое главное, это проверять мульти-множество
[50:35.580 --> 50:42.700]  на одинаковость или различность. Вот без сортировки я не умею этого делать. Ну то есть нет, можно
[50:42.700 --> 50:47.700]  как-нибудь просто каждому числу поставить что-нибудь большое, как-нибудь проксорить. Ну можно, да.
[50:47.700 --> 51:17.020]  Ну ладно, короче, вы меня поняли или нет? Это хороший вопрос. Тоже думаю,
[51:17.020 --> 51:22.420]  что ничего не даст, потому что у вас хоть векторы маленькие, но там числа могут быть до n. И поэтому
[51:22.420 --> 51:28.140]  у вас тогда будет за n каждый с сортировкой таких n штук. Короче, подумайте, но мне кажется,
[51:28.140 --> 51:37.060]  что быстрее чем аллогн не будет. Чего? Ну подумайте. Ну вы что, вам аллогн не нравится, что ли? Если
[51:37.060 --> 51:45.380]  хотите лучше, думайте сами. Так, последний сюжет на сегодня это LCA, он же наименьший общепредок.
[51:45.380 --> 52:03.340]  Я его не давал, ну сейчас скажу. Неформально, да? Я что делаю? Корневое дерево, когда выделена какая-то
[52:03.340 --> 52:17.940]  вершина, названная корнем, и я подвешиваю все дерево за нее. Скажу так, формально, что такое, вот так скажу,
[52:17.940 --> 52:25.420]  значит, корневое дерево это когда ребра ориентированы по направлению от какой-то одной вершины ко всем
[52:25.420 --> 52:33.460]  остальным. То есть я перехожу к ориентированному уже графу, но просто путем введения ориентации
[52:33.460 --> 52:40.060]  на всех этих ребрах по направлению от одной вершины, от корня до всех остальных. Это то же самое,
[52:40.060 --> 52:44.380]  то есть мы как бы любую вершину можем назначить корнем, просто сказать, что ты корень, запустили
[52:44.380 --> 52:49.580]  DFS, ориентируй ребра из нее вниз. И тогда, соответственно, вот эта вот штука, вот здесь,
[52:49.780 --> 53:04.380]  в точности мы проходим всех детей в порядке сверху вниз. Неважно, мы можем выбрать что угодно, мы знаем,
[53:04.380 --> 53:09.860]  что вот если наши деревья вот эти вот некорневые, если некорневые деревья изоморфные, ну давайте
[53:09.860 --> 53:15.140]  с центроидами. Понятно дело, что центроид перейдет в центроид, потому что вообще изоморфизм это как бы
[53:15.140 --> 53:19.460]  просто перенумерация вершин по факту. Тогда понятно, что если в исходном дереве какая-то
[53:19.460 --> 53:23.420]  вершина была такова, что ее удаление оставляет все компоненты размера n пополам, не больше чем
[53:23.420 --> 53:28.580]  n пополам, то в другом, после перенумерации, она сохраняет это свойство, там все равно все компоненты
[53:28.580 --> 53:33.700]  будут не больше чем n пополам. Вот, ну вот давайте я насильно, тогда понятно, что центроид должен
[53:33.700 --> 53:39.980]  перейти в центроид. Давайте я насильно назначу центроиды корнями обоих деревьев, подвешу, ориентирую
[53:39.980 --> 53:48.140]  все деревья сверху вниз от центроида вниз. Может, может, может, поэтому я и говорю, я перебираю
[53:48.140 --> 53:54.020]  центроид в первом дереве, перебираю центроид во втором по дереве и проверяю, можно ли первый пересел
[53:54.020 --> 53:59.820]  в второй. Ну а уже после этого я их объявляю корнями и проверяю их заморсанность как корневых
[53:59.820 --> 54:04.820]  деревьев. То есть я перебираю центроид в первом, во втором, за них подвешиваю и проверяю как корневые.
[54:04.820 --> 54:21.580]  Так, хорошо. Дальше LCA, наименьший общий предок. Наименьший общий предок. Ну по английски это,
[54:21.580 --> 54:42.700]  соответственно, List Common Ancestor. Здесь опять работаем с корневыми деревьями, то есть неформально какая-то
[54:42.700 --> 54:55.340]  вершина назначена корнем и все пути они вот как бы сверху вниз у нас идут. Насчет такого LCA, для
[54:55.340 --> 55:08.380]  двух каких-то вершин U и V, это такая вершина на пути между U и V, которая наиболее близка к R. То есть
[55:08.380 --> 55:15.580]  я рассматриваю пути между ними, вот он, и на нем выбираю самую высокую вершину, самую близкую к R.
[55:15.580 --> 55:31.060]  LCA U и V это, ну давайте я так и напишу, самая высокая вершина, вершина на пути
[55:31.060 --> 55:42.100]  от U до V. Самая высокая, то есть с наименьшей глубиной, то есть наиболее близкая к корню R.
[55:42.100 --> 55:50.980]  Значит альтернативно можно было бы определить так. Смотрите, что это за вершина? Как вообще
[55:50.980 --> 56:01.900]  выглядит любой путь от U до V? Ну давайте сначала поймем, как выглядят вообще пути от U до корня,
[56:01.900 --> 56:07.060]  например, от U до R. Понятно, что бы дойти от U до R, мне нужно просто каждый раз подниматься вверх по
[56:07.060 --> 56:12.580]  ребру, то есть в родителей идти каждый раз. Путь от вершины до корня очень легко определить. Если
[56:12.580 --> 56:17.140]  я запускаю DFS сверху вниз, то я у каждой вершины знаю предыдущие пути, соответственно мне нужно
[56:17.140 --> 56:23.100]  просто пропрыгать по предыдущему. То же самое я знаю путь от V до корня, вот так, вот так, вот так.
[56:23.100 --> 56:28.900]  Ну и теперь если я посмотрю, где эти пути впервые пересекаются, соответственно тогда я знаю, что надо
[56:28.900 --> 56:34.500]  от U дойти до сюда, от V дойти до сюда, и вот как раз тогда у меня эти два пути состыкуются. И вот эта
[56:34.500 --> 56:44.740]  вершина, где они состыкуются, будет как раз LCA. Можно альтернативно сказать, можно сказать, что это
[56:44.740 --> 56:54.540]  такая вершина наиболее глубокая, что она является общим предком и для U, и для V. Давайте напишу альтернативно.
[56:54.540 --> 57:21.540]  Вершина LCA от U и V это самая глубокая вершина, являющаяся предком U и V. Ну а предок это такая вершина,
[57:21.540 --> 57:30.900]  которая, можно сказать так, что вот относительно нее U и V лежат в ее поддереве, то есть ниже от нее,
[57:30.900 --> 57:39.940]  где-то ниже. Меня интересует самый глубокий общепредок. Например, вот это их общепредок,
[57:39.940 --> 57:45.140]  потому что они обе лежат в поддереве этой вершины. Вот это их тоже общепредок, потому что все они
[57:45.140 --> 57:49.420]  лежат в поддереве R, но при этом это не самая глубокая вершина. Самая глубокая это вот она.
[57:49.420 --> 57:55.820]  Но, например, вот это это не общепредок, потому что V не лежит в этом поддереве. Ну и так далее.
[57:55.820 --> 58:03.460]  И вот наша задача научиться находить LCA как-нибудь забыстро. Тогда, например, в частности, если мы
[58:03.460 --> 58:08.740]  научимся искать LCA забыстро, то мы вообще можем быстро понимать, как выглядит путь от U до V.
[58:08.740 --> 58:18.340]  Например, его длину можем определять. Если мы знаем их LCA, то путь между U и V выглядит так.
[58:18.340 --> 58:29.500]  Сначала от U надо дойти до LCA, потом от LCA до V. То есть LCA такая очень полезная характеристика для
[58:29.500 --> 58:33.460]  двух вершин. Мы так все пути можем характеризовать, что сначала от U поднимаемся до куда-то,
[58:33.460 --> 58:36.380]  потом от этого куда-то спускаемся до V.
[58:53.380 --> 59:00.140]  Так, ну давайте научимся это как-нибудь делать. Способ первый. Дваичные подъемы.
[59:03.460 --> 59:16.260]  Сначала мне нужно будет вести процедуру, которая проверяет, является ли одна вершина предком другой.
[59:16.260 --> 59:31.420]  Давайте я напишу, был консестор, int, давайте x, y. Эта процедура проверяет, правда ли, что x является предком y.
[59:31.420 --> 59:53.900]  Верно ли, что x предок y? Предок, то есть повторю, y лежит в подделье x. Вот есть корень, за который мы подвесили все дерево, где-то есть x и где-то в его подделье y, тогда x это предок.
[59:54.380 --> 01:00:11.380]  Ну как это можно сделать? Можно, например, ввести, как мы это делали, когда писали DFS, можно вернуть ti на tout, как времена входа и выхода вершины из вершины.
[01:00:11.380 --> 01:00:20.380]  Вот скажем этот DFS фиксируется так. Вот здесь при входе я говорю, что ti на tv равно timer++, здесь при выходе говорю tout на tv равно timer++.
[01:00:20.860 --> 01:00:30.860]  То есть каждый раз при входе и при выходе из вершины я говорю, что время увеличивается на 1 и соответственно я фиксирую времена входа и выхода из каждой вершины.
[01:00:30.860 --> 01:00:48.340]  Тогда я утверждаю, что вот эта функция пишется так. Надо проверить, что ti над x меньше либо равен ti над y и tout от x больше либо равен tout от y.
[01:01:01.340 --> 01:01:15.340]  Так, ну это вообще работает на самом деле для любого DFS, для DFS в любом неориентированном графе.
[01:01:15.340 --> 01:01:27.340]  Если я записываю ti на tout, то мы когда-то на самом деле с вами понимали, что вот эти вот отрезки, отрезок времени между входом в вершину и выходом из вершины,
[01:01:27.820 --> 01:01:40.820]  все вот такие отрезки, любая пара отрезков, либо не пересекается вообще, это значит, что мы сначала проходим одно дерево, а потом другое, ну под деревом, либо одно вложено в другое.
[01:01:40.820 --> 01:01:49.820]  Значит, я сначала вошел в одно под дерево, потом спустился куда-то, целиком прошел под дерево другой вершины и потом вышел и только после этого закончил по дереву первую вершину.
[01:01:50.300 --> 01:01:54.300]  То есть такие отрезки, они либо не пересекаются, либо вложены друг с другом.
[01:01:54.300 --> 01:02:02.300]  Так работает DFS, так работает обход графа в глубину, что такие отрезки либо не пересекаются, либо вложены.
[01:02:02.300 --> 01:02:08.300]  Ну вот здесь я пересекаюсь, что они вложены друг с другом, при этом отрезок y вложен в отрезок x.
[01:02:08.300 --> 01:02:18.300]  Ну понятно, вот это вот ровно такая картинка, что я сначала вошел в x, потом что-то поделал, потом нашел y, его целиком обошел, вышел из него,
[01:02:18.780 --> 01:02:25.780]  и только после этого вышел из x. То есть я сначала вошел в x, потом в y, потом вышел из y, потом вышел из x.
[01:02:25.780 --> 01:02:29.780]  Вот ровно вот это вот условие я проверяю здесь.
[01:02:29.780 --> 01:02:40.780]  Да, а как бы антоним к этому условию, это что либо они здесь поменены местами тогда y предок x, либо они не пересекаются, но тогда понятно, что ни один из них не предок другого.
[01:02:40.780 --> 01:02:44.780]  Поэтому это условие ровно то, что нам нужно делать, за от изницы.
[01:02:48.780 --> 01:03:10.780]  Так, хорошо, тогда сделаем следующее, собственно двоичный подъем.
[01:03:11.260 --> 01:03:24.260]  Давайте для каждой вершины и для каждой степени двойки, 1, 2, 4, 8 и так далее, посчитаем ее предка в поколении с номером этой степени двойки.
[01:03:24.740 --> 01:03:28.740]  Ну как-нибудь давайте я назову лифтс.
[01:03:28.740 --> 01:03:40.740]  Катая ветая, это родитель, ну давайте предок v в двовкатом поколении.
[01:03:41.220 --> 01:03:55.220]  То есть предок, например, в первом поколении это просто родитель, на 1 ребро вверх, во втором поколении это на 2, в четвертом поколении, соответственно, на 4 ребра вверх.
[01:03:55.220 --> 01:03:59.220]  Это про дедушка, но не важно, короче.
[01:03:59.220 --> 01:04:07.220]  То есть получается, где я окажусь, и иными словами, где я окажусь, если я из v вот столько вот раз поднимусь в родителя.
[01:04:07.700 --> 01:04:16.700]  Значит, это либо предок, либо корень, если предка в таком поколении нет.
[01:04:16.700 --> 01:04:22.700]  То есть я вот прыгаю-прыгаю и хочу еще выше прыгнуть, например, на 100-500 вверх подняться, а такого просто нет.
[01:04:22.700 --> 01:04:24.700]  Тогда я просто корень храню.
[01:04:24.700 --> 01:04:26.700]  Либо корень, если такого предка нет.
[01:04:34.700 --> 01:04:36.700]  Вот это собственно двоичные подъемы.
[01:04:37.180 --> 01:04:39.180]  Лифтс.
[01:04:44.180 --> 01:04:46.180]  Извините, лифтс.
[01:04:46.180 --> 01:04:48.180]  Вот.
[01:04:48.180 --> 01:04:50.180]  Значит, как его заполнять сначала?
[01:04:50.180 --> 01:04:52.180]  Заполнять очень просто.
[01:04:52.180 --> 01:04:54.180]  Что такое лифтс нулевое?
[01:04:54.180 --> 01:04:58.180]  Лифтс нулевое от v.
[01:04:58.180 --> 01:05:04.180]  Это предок в 2 в 0, то есть в первом поколении, то есть просто родитель v.
[01:05:04.660 --> 01:05:06.660]  Родитель v.
[01:05:09.660 --> 01:05:15.660]  Но это очень просто заполнить, потому что для корня это он сам, потому что у корня нет родителя.
[01:05:15.660 --> 01:05:20.660]  А у всех остальных, когда я спускаюсь из вершины v в вершину 2,
[01:05:20.660 --> 01:05:26.660]  я могу сразу сказать, что лифтс нулевое тут это v.
[01:05:26.660 --> 01:05:30.660]  Каждый раз, когда я в нашем DFS спускаюсь по ребру,
[01:05:30.660 --> 01:05:33.660]  я сразу записываю, что родитель этой вершины это v.
[01:05:34.140 --> 01:05:38.140]  Тем самым я нулевой слой нашей, по сути, динамики заполню.
[01:05:40.140 --> 01:05:43.140]  Теперь пусть мне известны все лифтсы нулевые.
[01:05:43.140 --> 01:05:47.140]  Пусть, даже не так, пусть известны все на item-слоя.
[01:05:47.140 --> 01:05:59.140]  Пусть известны все лифтс kt для любой вершины v.
[01:05:59.620 --> 01:06:07.620]  Тогда как найти лифтс k плюс первое v?
[01:06:10.620 --> 01:06:17.620]  Смотрите, я хочу понять, где я окажусь, если я из вершины v прыгну вверх 2 в степени k плюс 1 раз.
[01:06:17.620 --> 01:06:21.620]  Вот если я вверх поднимаюсь вот на столько ребер,
[01:06:21.620 --> 01:06:24.620]  где я окажусь?
[01:06:24.620 --> 01:06:28.620]  И при этом я умею подниматься на 2 в степени k ребер.
[01:06:29.620 --> 01:06:32.620]  Ну как обычно, мы один раз прыгаем на 2 вкатый, второй раз прыгаем на 2 вкатый.
[01:06:32.620 --> 01:06:38.620]  Так же, как в спортстейбле у нас было, отрезок большой длины я покрываю двумя отрезками длины вдвое меньше.
[01:06:38.620 --> 01:06:40.620]  Поэтому, чтобы прыгнуть на 2 в степени k плюс 1,
[01:06:40.620 --> 01:06:44.620]  я сначала прыгаю на 2 вкатый, потом из него еще раз на 2 вкатый.
[01:06:47.620 --> 01:06:50.620]  Значит, если вы хотите убить себе глаза,
[01:06:50.620 --> 01:06:52.620]  можно писать вот так.
[01:06:53.100 --> 01:07:04.100]  Вот лифт с k плюс 1 vt это лифт с kt от лифт с kt vt.
[01:07:09.100 --> 01:07:12.100]  То есть, я сначала поднимаюсь на 2 вкатый из v,
[01:07:12.100 --> 01:07:15.100]  и потом еще поднимаюсь на 2 вкатый из нее.
[01:07:15.580 --> 01:07:22.580]  При этом, вот это вот граничное условие, что если мы пытаемся прыгнуть выше, чем положено,
[01:07:22.580 --> 01:07:25.580]  выше, чем за корень, то здесь тоже все будет нормально.
[01:07:25.580 --> 01:07:28.580]  Потому что, скажем, если вот это вот внезапно стало корень,
[01:07:28.580 --> 01:07:30.580]  то здесь любой прыжок к нему тоже будет корень.
[01:07:30.580 --> 01:07:34.580]  Поэтому здесь не будет никаких проблем с этим условием.
[01:07:34.580 --> 01:07:36.580]  Короче, с этим условием все будет нормально.
[01:07:37.060 --> 01:07:38.060]  Да.
[01:07:42.060 --> 01:07:45.060]  Ну, для корня в самом начале скажут, что лифт с ульевой от корня это корень.
[01:07:54.060 --> 01:07:57.060]  Так, теперь, зачем это нам было нужно?
[01:08:00.060 --> 01:08:02.060]  Давайте я нарисую картинку.
[01:08:02.060 --> 01:08:04.060]  Смотрите, мы хотим найти...
[01:08:04.540 --> 01:08:08.540]  Все, я теперь начитал все лифцы, да, начитал все двоичные подъемы.
[01:08:08.540 --> 01:08:10.540]  Понятно дело с УЗН логН.
[01:08:11.540 --> 01:08:14.540]  Потому что нет смысла брать k больше, чем логН.
[01:08:15.540 --> 01:08:18.540]  Там логН, округленный куда-нибудь, вверх, например.
[01:08:19.540 --> 01:08:22.540]  Но нет смысла брать степень двойки, превосходящую количество вершин в графе.
[01:08:23.540 --> 01:08:25.540]  Поэтому это можно сделать с УЗН логН.
[01:08:26.540 --> 01:08:29.540]  Так вот, как найти лица между У и В?
[01:08:30.020 --> 01:08:36.020]  Давайте я буду прыгать из У в предке по вот этим двоичным подъемам.
[01:08:37.020 --> 01:08:39.020]  От больших степеней к меньшим.
[01:08:39.020 --> 01:08:42.020]  То есть, скажем, вот здесь я прыгну, скажем, на 8.
[01:08:42.020 --> 01:08:44.020]  Вот здесь вот на 4.
[01:08:44.020 --> 01:08:46.020]  И здесь еще на 1.
[01:08:46.020 --> 01:08:51.020]  Я буду прыгать по вот этим степеням двойки вверх, вверх, вверх, пока могу.
[01:08:51.020 --> 01:08:55.020]  И найду тем самым самую высокую вершину, которая еще не является предком В.
[01:08:56.020 --> 01:08:58.020]  Вот такое странное условие.
[01:08:58.500 --> 01:09:01.500]  Я сейчас вверх, сохраняю условие, что У это не порядок В.
[01:09:02.500 --> 01:09:06.500]  Тогда если я так сделаю, то я на самом деле допрыгаю до вот этого левого сына, их LCA.
[01:09:08.500 --> 01:09:11.500]  И чтобы найти сам LCA, нужно будет просто один раз перейти в родителя.
[01:09:15.500 --> 01:09:17.500]  Сейчас будет код.
[01:09:17.980 --> 01:09:34.980]  Так, LCA для У и В.
[01:09:34.980 --> 01:09:36.980]  Ну, во-первых, простой случай.
[01:09:36.980 --> 01:09:38.980]  Если У это порядок В, то У это ответ.
[01:09:47.980 --> 01:09:51.980]  Если одна вершина предка другой, то она, собственно, есть их LCA.
[01:09:51.980 --> 01:09:53.980]  Потому что путь выглядит как-то вот так.
[01:09:53.980 --> 01:09:55.980]  Путь сверху вниз от У до В.
[01:09:55.980 --> 01:09:58.980]  Понятно, что самая высокая вершина в этом пути, это она сама У.
[01:10:00.980 --> 01:10:02.980]  Это простой случай.
[01:10:02.980 --> 01:10:04.980]  Теперь более интересный случай, когда У это не порядок В.
[01:10:04.980 --> 01:10:06.980]  И картинка какая-то такая.
[01:10:06.980 --> 01:10:12.980]  Так вот, давайте я буду прыгать ушкой по вот этим вот нашим двоичным подъемам.
[01:10:13.980 --> 01:10:16.980]  Сохраняя условие, что У это не порядок В.
[01:10:17.980 --> 01:10:24.980]  Значит, дальше давайте мы сохранять условие, что У не предок В.
[01:10:28.980 --> 01:10:32.980]  Значит, вот я хочу прыгнуть как можно выше из У.
[01:10:32.980 --> 01:10:35.980]  Поддерживаю условие, что У это не предок В.
[01:10:36.980 --> 01:10:38.980]  Делается тривиально.
[01:10:39.460 --> 01:10:45.460]  Ка, ну давайте вот Ка Макс до нуля.
[01:10:48.460 --> 01:10:52.460]  Если можно прыгнуть на двафкатой, сохраняя условие, что это не предок В, то прыгаем.
[01:10:56.460 --> 01:10:58.460]  Так, если неверно, что предок
[01:11:01.460 --> 01:11:03.460]  лифтс
[01:11:03.460 --> 01:11:05.460]  катая утая
[01:11:05.460 --> 01:11:07.460]  В
[01:11:09.460 --> 01:11:14.460]  тогда У это вот этот самый лифтс катая утая.
[01:11:20.460 --> 01:11:22.460]  Вот.
[01:11:22.460 --> 01:11:24.460]  Все, в конце, после этого фора
[01:11:24.460 --> 01:11:27.460]  у меня по-прежнему выполняется, что У это не предок В,
[01:11:27.460 --> 01:11:29.460]  потому что я всегда эти условия сохраняю.
[01:11:29.460 --> 01:11:31.460]  И я утверждаю, что У тогда это вот эта вот вершина,
[01:11:31.460 --> 01:11:33.460]  самая высокая вершина на этой части пути,
[01:11:33.460 --> 01:11:35.460]  которая все еще не предок В.
[01:11:35.460 --> 01:11:37.460]  То есть по факту это просто вот этот ребеночек кольца.
[01:11:37.940 --> 01:11:40.940]  И тогда в качестве этого нужно вернуть родителя нашей У.
[01:11:42.940 --> 01:11:44.940]  Return
[01:11:44.940 --> 01:11:46.940]  лифтс
[01:11:46.940 --> 01:11:48.940]  нулевое утая.
[01:12:01.940 --> 01:12:03.940]  Так, еще раз.
[01:12:03.940 --> 01:12:05.940]  Понятно, что вот это условие у меня всегда сохраняется.
[01:12:06.420 --> 01:12:08.420]  Вот до этого момента У это не предок В.
[01:12:08.420 --> 01:12:10.420]  Изначально это не предок В,
[01:12:10.420 --> 01:12:12.420]  потому что это условие не сработало.
[01:12:12.420 --> 01:12:14.420]  И дальше я всегда поддерживаю,
[01:12:14.420 --> 01:12:16.420]  что если я У пересчитываю, меняю на что-то,
[01:12:16.420 --> 01:12:18.420]  то У это не предок В остается.
[01:12:18.420 --> 01:12:20.420]  Но при этом я поднимаюсь вверх.
[01:12:20.420 --> 01:12:22.420]  Так вот, я утверждаю,
[01:12:22.420 --> 01:12:24.420]  что после этого фора
[01:12:24.420 --> 01:12:26.420]  У это самая высокая вершина,
[01:12:26.420 --> 01:12:28.420]  которая является предком изначального У,
[01:12:28.420 --> 01:12:30.420]  которая все еще не предок В.
[01:12:30.420 --> 01:12:32.420]  Почему это самая высокая?
[01:12:32.420 --> 01:12:34.420]  Почему это действительно последний вершинный пути
[01:12:34.420 --> 01:12:36.420]  до Ульца?
[01:12:36.420 --> 01:12:38.420]  Давайте сделаем так.
[01:12:38.420 --> 01:12:40.420]  Давайте померяем вот это вот расстояние.
[01:12:42.420 --> 01:12:44.420]  Сколько у меня здесь было?
[01:12:44.420 --> 01:12:46.420]  13, да?
[01:12:46.420 --> 01:12:48.420]  Вот пусть расстояние у У до Ульца это 13.
[01:12:48.420 --> 01:12:50.420]  Тогда что я делаю?
[01:12:50.420 --> 01:12:52.420]  Я иду по степеням двойки сверху вниз.
[01:12:52.420 --> 01:12:54.420]  И по факту я вот это число 13 разбиваю
[01:12:54.420 --> 01:12:56.420]  в двоичную систему счисления.
[01:12:56.420 --> 01:12:58.420]  Как как раз таки 8
[01:12:58.420 --> 01:13:00.420]  плюс 4 плюс 1.
[01:13:00.420 --> 01:13:02.420]  Прыгаю сначала на 8,
[01:13:02.420 --> 01:13:04.420]  потом все еще ниже чем Ульца.
[01:13:04.420 --> 01:13:06.420]  Потом еще на 4 все еще ниже чем Ульца.
[01:13:08.420 --> 01:13:10.420]  Так, сейчас, плохо, плохо.
[01:13:10.420 --> 01:13:12.420]  Извините, извините.
[01:13:12.420 --> 01:13:14.420]  Одну секунду.
[01:13:14.420 --> 01:13:16.420]  Плох сказал.
[01:13:16.420 --> 01:13:18.420]  13 это вот это вот.
[01:13:18.420 --> 01:13:20.420]  Не до Ульца расстояние,
[01:13:20.420 --> 01:13:22.420]  а до вот этого сына Ульца как раз.
[01:13:22.420 --> 01:13:24.420]  Вот до него.
[01:13:24.420 --> 01:13:26.420]  Тогда как раз я раскладываю число
[01:13:26.420 --> 01:13:28.420]  по степеням двойки.
[01:13:28.420 --> 01:13:30.420]  Ну и каждую возможную степень двойки прыгаю.
[01:13:30.420 --> 01:13:32.420]  Как раз 8, 4, 1 будет.
[01:13:32.420 --> 01:13:34.420]  Я закончусь вот здесь.
[01:13:34.420 --> 01:13:36.420]  То есть получается, каким бы ни было это расстояние,
[01:13:36.420 --> 01:13:38.420]  я просто с жадным алгоритмом
[01:13:38.420 --> 01:13:40.420]  от больших степеней к меньшим, я его обязательно пройду.
[01:13:40.420 --> 01:13:42.420]  И закончусь вот в этой вот вершинке
[01:13:42.420 --> 01:13:44.420]  в сыне Ульца,
[01:13:44.420 --> 01:13:46.420]  которая все еще не под дерево,
[01:13:46.420 --> 01:13:48.420]  не предок В.
[01:13:48.420 --> 01:13:50.420]  Чтобы стать предок В, надо подняться
[01:13:50.420 --> 01:13:52.420]  на один верх.
[01:13:52.420 --> 01:13:54.420]  Вы видите расстояние от У до Ульца?
[01:13:54.420 --> 01:13:56.420]  Нет, ну смотрите,
[01:13:56.420 --> 01:13:58.420]  если отсюда до Ульца 12,
[01:13:58.420 --> 01:14:00.420]  то мне нужно прыгнуть на 11.
[01:14:00.420 --> 01:14:02.420]  Согласны?
[01:14:02.420 --> 01:14:04.420]  11 это 8, плюс 2, плюс 1.
[01:14:04.420 --> 01:14:06.420]  Ну вот так вот.
[01:14:06.420 --> 01:14:08.420]  Вот так вот.
[01:14:08.420 --> 01:14:10.420]  Вот так вот.
[01:14:10.420 --> 01:14:12.420]  Вот так вот.
[01:14:12.420 --> 01:14:14.420]  Вот так вот.
[01:14:14.420 --> 01:14:16.420]  Вот так вот.
[01:14:16.420 --> 01:14:18.420]  Вот так вот.
[01:14:18.420 --> 01:14:20.420]  Вот так вот.
[01:14:20.420 --> 01:14:22.420]  Потому что, смотрите,
[01:14:22.420 --> 01:14:24.420]  когда я прыгаю на 8,
[01:14:24.420 --> 01:14:26.420]  если я потом пытаюсь прыгнуть на 4,
[01:14:26.420 --> 01:14:28.420]  я уже становлюсь предком В,
[01:14:28.420 --> 01:14:30.420]  поэтому я на 4 не прыгаю.
[01:14:30.420 --> 01:14:32.420]  Значит, 4 игнорируется.
[01:14:32.420 --> 01:14:34.420]  А на 2 и на 1 я спокойно прыгаю,
[01:14:34.420 --> 01:14:36.420]  и как раз окажусь в этом ребенке Ульца.
[01:14:40.420 --> 01:14:42.420]  Еще раз?
[01:14:44.420 --> 01:14:46.420]  Да, ровно это я и говорю.
[01:14:46.420 --> 01:14:48.420]  То есть вот эта штука,
[01:14:48.420 --> 01:14:50.420]  это просто разложение,
[01:14:50.420 --> 01:14:52.420]  ну да, просмотр выставленных бит
[01:14:52.420 --> 01:14:54.420]  в расстоянии от У
[01:14:54.420 --> 01:14:56.420]  до вот этого сына Ильца.
[01:14:56.420 --> 01:14:58.420]  Да, это правда.
[01:14:58.420 --> 01:15:00.420]  Ну вот.
[01:15:00.420 --> 01:15:02.420]  Все, значит, смотрите,
[01:15:02.420 --> 01:15:04.420]  что у нас получилось с асимптотикой?
[01:15:04.420 --> 01:15:06.420]  У меня получился предподсчет
[01:15:06.420 --> 01:15:08.420]  за n лог n,
[01:15:10.420 --> 01:15:12.420]  потому что двоичные подъемы.
[01:15:12.420 --> 01:15:14.420]  И запрос еще за логарифы.
[01:15:14.420 --> 01:15:16.420]  Потому что в цикле
[01:15:16.420 --> 01:15:18.420]  по k от k-max до 0.
[01:15:30.420 --> 01:15:32.420]  Ну, давай тогда быстренько,
[01:15:32.420 --> 01:15:34.420]  второй способ.
[01:15:34.420 --> 01:15:36.420]  Чуть более быстрый.
[01:15:36.420 --> 01:15:38.420]  Ну, его быстрее объяснить.
[01:15:38.420 --> 01:15:40.420]  Ну, вот так вот.
[01:15:40.420 --> 01:15:42.420]  Вот так вот.
[01:15:42.420 --> 01:15:44.420]  Ну, его быстрее объяснить.
[01:15:44.420 --> 01:15:46.420]  Значит, это Эйлеров обход.
[01:15:50.420 --> 01:15:52.420]  На примере.
[01:15:54.420 --> 01:15:56.420]  Пусть есть вот такой граф,
[01:15:56.420 --> 01:15:58.420]  такое дерево.
[01:15:58.420 --> 01:16:00.420]  И опять дерево корневое,
[01:16:00.420 --> 01:16:02.420]  вот оно пусть подвешено,
[01:16:02.420 --> 01:16:04.420]  завершу номер два.
[01:16:04.420 --> 01:16:06.420]  Тогда Эйлеров обход
[01:16:06.420 --> 01:16:08.420]  это запуск DFS-а,
[01:16:08.420 --> 01:16:10.420]  который каждый раз,
[01:16:10.420 --> 01:16:12.420]  когда входит,
[01:16:12.420 --> 01:16:14.420]  точнее, каждый раз, когда попадает в вершину,
[01:16:14.420 --> 01:16:16.420]  записывает ее.
[01:16:16.420 --> 01:16:18.420]  То есть, смотрите, мы начали в двойке,
[01:16:18.420 --> 01:16:20.420]  давайте запишем двойку.
[01:16:20.420 --> 01:16:22.420]  Потом идем в шесть, записали шесть.
[01:16:22.420 --> 01:16:24.420]  Спустились в один, записали один.
[01:16:24.420 --> 01:16:26.420]  Вышли из один, поднялись по этому ребру.
[01:16:26.420 --> 01:16:28.420]  И опять оказались в шестерке.
[01:16:28.420 --> 01:16:30.420]  Написали шесть.
[01:16:30.420 --> 01:16:32.420]  Потом спуск в семь,
[01:16:32.420 --> 01:16:34.420]  подъем обратно в шесть.
[01:16:34.420 --> 01:16:36.420]  Потом все это по дереву уже обойдено,
[01:16:36.420 --> 01:16:38.420]  поднимаемся вверх в двойку,
[01:16:38.420 --> 01:16:40.420]  потом подъем опять в тройку,
[01:16:40.420 --> 01:16:42.420]  в двойку, в четверку и в двойку.
[01:16:42.420 --> 01:16:44.420]  То есть, по факту,
[01:16:44.420 --> 01:16:46.420]  это просто запись,
[01:16:46.420 --> 01:16:48.420]  как DFS посещает все вершины.
[01:16:48.420 --> 01:16:50.420]  То есть, он либо спускается вниз,
[01:16:50.420 --> 01:16:52.420]  и тогда вершину печатает,
[01:16:52.420 --> 01:16:54.420]  либо разворачивает рекурсию,
[01:16:54.420 --> 01:16:56.420]  поднимается из вершины вверх к родителю
[01:16:56.420 --> 01:16:58.420]  и тоже печатает эту вершину.
[01:16:58.420 --> 01:17:00.420]  То есть, если я поднимаюсь снизу вверх,
[01:17:00.420 --> 01:17:02.420]  я тоже вершину записываю.
[01:17:02.420 --> 01:17:04.420]  Вот это Эйлеров обход.
[01:17:08.420 --> 01:17:10.420]  Он хорош тем, что здесь любые две вершины
[01:17:10.420 --> 01:17:12.420]  это ребро графа.
[01:17:12.420 --> 01:17:14.420]  Любые две соседние вершины
[01:17:14.420 --> 01:17:16.420]  это ребро графа.
[01:17:16.420 --> 01:17:18.420]  Потому что я либо сверху вниз прошел,
[01:17:18.420 --> 01:17:20.420]  либо снизу вверх.
[01:17:20.420 --> 01:17:22.420]  Потому что каждый раз, когда я прошел по ребру,
[01:17:22.420 --> 01:17:24.420]  я печатаю очередную вершину.
[01:17:24.420 --> 01:17:26.420]  Вот у меня 2,6, 6,1, 1,6
[01:17:26.420 --> 01:17:28.420]  это ребро снизу вверх,
[01:17:28.420 --> 01:17:30.420]  6,7, 7,6 снизу вверх и так далее.
[01:17:30.420 --> 01:17:32.420]  Каждые соседи вершины
[01:17:32.420 --> 01:17:34.420]  это соседи в графе,
[01:17:34.420 --> 01:17:36.420]  соединенные ребром вершины.
[01:17:36.420 --> 01:17:38.420]  Тогда утверждается следующее.
[01:17:38.420 --> 01:17:40.420]  Чтобы найти
[01:17:42.420 --> 01:17:44.420]  LCA УВ,
[01:17:44.420 --> 01:17:46.420]  нужно найти вершину
[01:17:46.420 --> 01:17:48.420]  с минимальной глубиной
[01:17:48.420 --> 01:17:50.420]  на отрезке между УВ.
[01:17:56.420 --> 01:17:58.420]  Вершину с минимальной глубиной,
[01:17:58.420 --> 01:18:00.420]  с минимальным depth,
[01:18:00.420 --> 01:18:02.420]  на отрезке
[01:18:06.420 --> 01:18:08.420]  между УВ.
[01:18:10.420 --> 01:18:12.420]  Например, вот здесь
[01:18:12.420 --> 01:18:14.420]  у меня есть 1,7,
[01:18:14.420 --> 01:18:16.420]  их LCA это 6.
[01:18:16.420 --> 01:18:18.420]  Потому что на отрезке
[01:18:18.420 --> 01:18:20.420]  между 1,7
[01:18:20.420 --> 01:18:22.420]  их наименее глубокая вершина,
[01:18:22.420 --> 01:18:24.420]  минимальная глубокая вершина между ними
[01:18:24.420 --> 01:18:26.420]  это 6.
[01:18:26.420 --> 01:18:28.420]  LCA, например, в семерке и пятерке,
[01:18:28.420 --> 01:18:30.420]  мне нужно вот на этом отрезке
[01:18:30.420 --> 01:18:32.420]  найти вершину с минимальной глубиной,
[01:18:32.420 --> 01:18:34.420]  это будет 2.
[01:18:34.420 --> 01:18:36.420]  Сейчас.
[01:18:36.420 --> 01:18:38.420]  Очень простая идея.
[01:18:38.420 --> 01:18:40.420]  Почему работает? Ну понятно почему.
[01:18:40.420 --> 01:18:42.420]  Потому что путь между вот этими вхождениями,
[01:18:42.420 --> 01:18:44.420]  это вхождение вверх-вниз, вверх-вниз,
[01:18:44.420 --> 01:18:46.420]  ну и значит понятно дело,
[01:18:46.420 --> 01:18:48.420]  что мы в частности путь между ними целиком пройдем.
[01:18:48.420 --> 01:18:50.420]  Мне нужно от семерки попасть в пять,
[01:18:50.420 --> 01:18:52.420]  значит между ними я весь путь напечатаю.
[01:18:52.420 --> 01:18:54.420]  И ясное дело, что я выше этого пути никуда не поднимусь.
[01:18:54.420 --> 01:18:56.420]  Потому что если я иду из УВ
[01:18:56.420 --> 01:18:58.420]  и как-то вот так вот
[01:18:58.420 --> 01:19:00.420]  выше, чем до LCA зашел,
[01:19:00.420 --> 01:19:02.420]  что значит?
[01:19:02.420 --> 01:19:04.420]  Что значит, что я посещаю вершину выше, чем LCA?
[01:19:04.420 --> 01:19:06.420]  Ну это бред, потому что если я прохожу
[01:19:06.420 --> 01:19:08.420]  вот это ребро снизу вверх, то я потом уже не вернусь.
[01:19:08.420 --> 01:19:10.420]  Снизу вверх я иду только,
[01:19:10.420 --> 01:19:12.420]  если у меня все внизу обойдено.
[01:19:12.420 --> 01:19:14.420]  Поэтому таких ребров точно не будет
[01:19:14.420 --> 01:19:16.420]  на этом пути.
[01:19:16.420 --> 01:19:18.420]  Ну а LCA точно будет.
[01:19:18.420 --> 01:19:20.420]  Любое.
[01:19:20.420 --> 01:19:22.420]  Неважно.
[01:19:22.420 --> 01:19:24.420]  Потому что все равно, если я когда-то находился в У,
[01:19:24.420 --> 01:19:26.420]  то чтобы попасть когда-то в В,
[01:19:26.420 --> 01:19:28.420]  мне нужно весь путь между ними пройти.
[01:19:28.420 --> 01:19:30.420]  Неважно какое вхождение.
[01:19:30.420 --> 01:19:32.420]  А что мы будем с собой брать?
[01:19:34.420 --> 01:19:36.420]  Мы sparse table на этом сделаем?
[01:19:36.420 --> 01:19:38.420]  Вот.
[01:19:38.420 --> 01:19:40.420]  Значит, смотрите, мы получили ref-обход.
[01:19:40.420 --> 01:19:42.420]  На нем, с помощью sparse table,
[01:19:42.420 --> 01:19:44.420]  мы можем найти
[01:19:44.420 --> 01:19:46.420]  минимумы на отрезках за единицу
[01:19:46.420 --> 01:19:48.420]  с предпочетом за n log n.
[01:19:50.420 --> 01:19:52.420]  Еще раз?
[01:19:54.420 --> 01:19:56.420]  Почему?
[01:19:56.420 --> 01:19:58.420]  Она и так за n решалась.
[01:19:58.420 --> 01:20:00.420]  Можно было просто DFS запустить
[01:20:00.420 --> 01:20:02.420]  на те расстояния, там путь.
[01:20:02.420 --> 01:20:04.420]  Значит, предпочет
[01:20:04.420 --> 01:20:06.420]  n log n
[01:20:06.420 --> 01:20:08.420]  запрос за единицу.
[01:20:10.420 --> 01:20:12.420]  Вот.
[01:20:12.420 --> 01:20:14.420]  Это уже лучше, чем то,
[01:20:14.420 --> 01:20:16.420]  но надо написать sparse table.
[01:20:20.420 --> 01:20:22.420]  Написать sparse table.
[01:20:22.420 --> 01:20:24.420]  Вопрос, вопрос.
[01:20:24.420 --> 01:20:26.420]  Единственное, смотрите,
[01:20:26.420 --> 01:20:28.420]  давайте вот здесь замечу,
[01:20:28.420 --> 01:20:30.420]  что длина вот этого массива,
[01:20:30.420 --> 01:20:32.420]  она будет примерно вдвое
[01:20:32.420 --> 01:20:34.420]  больше, чем число вершин.
[01:20:36.420 --> 01:20:38.420]  Потому что каждая
[01:20:38.420 --> 01:20:40.420]  бропа факту рассмотрится
[01:20:40.420 --> 01:20:42.420]  дважды, сверху вниз и снизу вверх.
[01:20:42.420 --> 01:20:44.420]  Значит, каждая вершина напечатается
[01:20:44.420 --> 01:20:46.420]  примерно столько раз, как у нее степень.
[01:20:46.420 --> 01:20:48.420]  А суммарная будет в два раза больше,
[01:20:48.420 --> 01:20:50.420]  чем число вершин.
[01:20:50.420 --> 01:20:52.420]  Поэтому здесь на самом деле sparse table
[01:20:52.420 --> 01:20:54.420]  больше.
[01:20:54.420 --> 01:20:56.420]  Но это, конечно, не важно.
[01:20:56.420 --> 01:20:58.420]  Все, до следующего раза.
