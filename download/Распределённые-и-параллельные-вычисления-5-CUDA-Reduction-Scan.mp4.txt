[00:00.000 --> 00:16.000]  Все, всем привет! Сегодня мы продолжаем и заканчиваем говорить закуду. Может быть потом еще что-нибудь поговорим на каких-нибудь семинарах или дополнительных историях.
[00:16.000 --> 00:26.000]  Но сегодня будет у нас самая математическая лекция. То есть то, что мы читали пропускные способности сетей, вот это вот все, это был детский сад, ромашка.
[00:26.000 --> 00:38.000]  Сегодня будет рум-математика. И сегодня мы будем решать две задачи. Первая задача это редакшн. То есть мы будем что-то с вами вычислять в какую-то общую копилку.
[00:38.000 --> 00:46.000]  И вторая задача это задача сканирования. Вот. Так, сейчас. Ты листать будешь? Вот.
[00:46.000 --> 01:01.000]  Значит, план. Решить задачу редакшн, дать формулировку задачи редакшн, дать формулировку задачи сканирования. После этого решить задачу фильтрации, реализовать функцию фильтр.
[01:01.000 --> 01:06.000]  Знаете, что в питоне функция фильтр делает?
[01:06.000 --> 01:16.000]  Ну, наверное, знаете. Или нет? Нет? Ладно.
[01:16.000 --> 01:31.000]  Так. Она делает следующее. Я забыл, где у нее итеры, куда у нее итеры болтаются.
[01:31.000 --> 01:36.000]  Я не знаю.
[01:36.000 --> 01:43.000]  Как вы думаете, что она сделает?
[01:43.000 --> 01:53.000]  Ну, создать генератор, который будет выкидывать числа 1 и 3. То есть вы передаете лямбда функцию, которая...
[01:53.000 --> 02:04.000]  Вообще какую-то функцию, относительно которой возвращает true либо false, и вам нужно оставить только те объекты, у которых значение условия true.
[02:04.000 --> 02:13.000]  Вот. Это функция фильтр. Вот. И потом мы с промышлением этой всей истории реализуем quicksort.
[02:13.000 --> 02:18.000]  Да. В общем, может быть, не эффективно реализуем, но реализуем. Вот. Это наш план.
[02:18.000 --> 02:24.000]  И в конце, может быть, еще немножко поговорим вообще про то, какие библиотеки бывают для работы с кудой,
[02:24.000 --> 02:34.000]  потому что многое из чего, что есть и можно реализовать на видеокарте, обычному разработчику не реализовать.
[02:34.000 --> 02:37.000]  Вот. Поэтому это спрятанный набор библиотек.
[02:37.000 --> 02:43.000]  Итак. Задача редакшн. У нас есть массив, нам надо посчитать в нем сумму элементов.
[02:46.000 --> 02:52.000]  Вот. Вопрос. Вот. У нас есть классическое решение. Мы делаем n операции по регистрам.
[02:52.000 --> 02:57.000]  Ну что, мы пишем обычный for, да? Я не знаю.
[02:57.000 --> 03:02.000]  Не привычно мне код писать на доске, но, в общем, обычное сложение это элемент массива.
[03:02.000 --> 03:07.000]  Вот. В общем, мы делаем n операции по регистрам.
[03:07.000 --> 03:12.000]  Ну что, мы пишем обычный for, да? Я не знаю.
[03:28.000 --> 03:37.000]  Ну, можно, да. Вот. В общем, что у нас получается? У нас с вами n операции.
[03:37.000 --> 03:46.000]  Сколько потоков они исполняются у нас? Один.
[03:46.000 --> 03:52.000]  Так. Умные люди говорят, что так лучше не делать.
[03:52.000 --> 03:57.000]  Как можно сделать умнее, если у нас есть с вами ap параллельно исполняемых потоков?
[04:09.000 --> 04:15.000]  А, ну это уже совсем умное решение. Это, видимо, на семинаре, что ли, уже рассказали?
[04:15.000 --> 04:22.000]  А, понятно. Да, немножко спеллернули. Вот.
[04:22.000 --> 04:27.000]  Давайте тупое решение с учетом того, что мы еще не знаем продвинутого решения.
[04:36.000 --> 04:42.000]  Тоже можно. Да. То есть у нас есть p количество потоков.
[04:43.000 --> 04:52.000]  Можно сделать так. Первое решение. Это взять, вообще тупо массив на p-части поделить,
[04:55.000 --> 05:02.000]  в каждом из них сложить, а потом сделать общий результат. Это на каком темпе, на каком темпу на p делается.
[05:02.000 --> 05:09.000]  Вот. Но на видеокарте это будет работать слишком медленно.
[05:09.000 --> 05:15.000]  Я не знаю. Я по крайней мере своей группе показывал на семинаре, что это будет очень медленно работать.
[05:15.000 --> 05:19.000]  Я не знаю, у других показывали, почему так работает сильно медленнее.
[05:19.000 --> 05:26.000]  Нет, ну короче смотри. Давай я тебе скажу, где это смотреть.
[05:27.000 --> 05:34.000]  Да, да, ну конечно. Так, сейчас.
[05:34.000 --> 05:40.000]  Там просто, правда, бардак?
[05:40.000 --> 05:46.000]  Ну что там, сильный бардак?
[05:46.000 --> 05:50.000]  Нормааас.
[05:50.000 --> 05:58.000]  Кто сможет сделать, можно законтрибьютить это, сделать оглавляшку. Я буду благодарен.
[05:58.000 --> 06:05.000]  Так. Где это? Вот. Вот. Вот это вот пример.
[06:08.000 --> 06:12.000]  Классический. Я не знаю, видно или нет.
[06:12.000 --> 06:18.000]  Короче, это реализован нормально, стипетет реализован фигово.
[06:18.000 --> 06:22.000]  Стипетет, по сути, суммулированное вычисление элементов последнего.
[06:22.000 --> 06:25.000]  Почему это плохо? Потому что это кашли не ломает.
[06:25.000 --> 06:28.000]  Которое мы с вами в прошлый раз говорили.
[06:28.000 --> 06:35.000]  Да, вот. Поэтому это бет с Алешей.
[06:35.000 --> 06:47.000]  Второе решение, которое предлагает, это попытаться складывать элементы с шагом каким-то.
[06:47.000 --> 06:56.000]  То есть, один поток будет заниматься сложением нулевого, 32-го, 64-го элемента и так далее.
[06:56.000 --> 07:04.000]  Первый поток будет складывать, первый, там, не знаю, третий и так далее.
[07:04.000 --> 07:10.000]  Ну и потом, ой, 33-й. И потом они все дружно сложат.
[07:10.000 --> 07:14.000]  Можно сделать так, но мы тут тоже лимитированы.
[07:14.000 --> 07:18.000]  К сожалению, но это один из способов предобработки.
[07:18.000 --> 07:22.000]  Здесь у нас что получается? Какое количество операций?
[07:34.000 --> 07:37.000]  Да, P плюс N делить на P.
[07:37.000 --> 07:42.000]  Вот. Ну в чем минус этого подхода?
[07:42.000 --> 07:46.000]  Смотрите. Давайте посчитаем.
[07:46.000 --> 07:52.000]  N у нас порядка 10 в 9. Если у нас N порядка 10 в 9,
[07:52.000 --> 08:01.000]  а P порядка, я не знаю, сколько?
[08:01.000 --> 08:07.000]  Ну давайте 4 на 10 в кубе. Ну это количество кудов потоков.
[08:07.000 --> 08:10.000]  Сколько это получается у нас с вами?
[08:31.000 --> 08:35.000]  Ну, смотрите, тут операции немножко неодинаковые.
[08:35.000 --> 08:39.000]  Потому что если вот это мы можем сделать где?
[08:39.000 --> 08:43.000]  С вами.
[08:43.000 --> 08:48.000]  На ЦПУ, на ГПУ.
[08:48.000 --> 08:51.000]  Да, мы, в принципе, на ГПУ можем сделать там.
[08:51.000 --> 08:55.000]  Но если мы будем делать где?
[08:55.000 --> 08:58.000]  На ЦПУ, на ГПУ.
[08:58.000 --> 09:01.000]  Да, мы, в принципе, на ГПУ можем сделать там.
[09:01.000 --> 09:04.000]  Сделать форик, да.
[09:04.000 --> 09:07.000]  И еще, особенность этого подхода, это первое.
[09:07.000 --> 09:10.000]  То вот это мы на чем делаем?
[09:15.000 --> 09:19.000]  Ну, мы сложили в каждом из этих подблоков.
[09:19.000 --> 09:22.000]  Да, получились, потом надо посложить, складывать.
[09:23.000 --> 09:26.000]  Да, на ЦПУ.
[09:32.000 --> 09:35.000]  Пока мы можем, но пока не можем.
[09:39.000 --> 09:42.000]  Не, не можем, потому что пока не научились.
[09:45.000 --> 09:49.000]  Так, а теперь смотрите, еще в чем подвох.
[09:49.000 --> 09:52.000]  Тут нечистая константа П будет.
[09:54.000 --> 09:58.000]  Потому что эффективно распараллеливать в П раз мы не умеем.
[09:59.000 --> 10:02.000]  Опять же вспоминаем структуру видеокарты.
[10:04.000 --> 10:09.000]  Если бы мы хотели бы это написать, да, то что у нас получается?
[10:09.000 --> 10:13.000]  For int и равно нулю и меньше, чем блок size и погнали, да?
[10:13.000 --> 10:16.000]  У нас есть ограничение на размер блока.
[10:17.000 --> 10:22.000]  У нас внутри блока выполняются не все операции единовременно.
[10:23.000 --> 10:25.000]  А только варпы.
[10:27.000 --> 10:33.000]  То есть у нас не получится ровно N делить на P слагаемых в результате.
[10:36.000 --> 10:38.000]  Понимаете почему?
[10:38.000 --> 10:41.000]  Блок size максимально где-то 10 в кубе, да?
[10:42.000 --> 10:45.000]  Блок size максимально 10 в кубе.
[10:47.000 --> 10:50.000]  1024.
[10:54.000 --> 10:57.000]  Теперь смотрите, в чем прикол.
[10:58.000 --> 11:01.000]  Прикол заключается в том, что...
[11:05.000 --> 11:09.000]  На самом деле мы, если напишем реализацию на видеокарте,
[11:10.000 --> 11:13.000]  то мы получим здесь не константу П.
[11:17.000 --> 11:22.000]  Мы здесь получим величину блок size.
[11:26.000 --> 11:30.000]  Блок size умножен на количество стриминг мотивроцессоров.
[11:35.000 --> 11:38.000]  Товарищи, почему это так?
[11:38.000 --> 11:41.000]  Напоминаю, что P это у нас...
[11:42.000 --> 11:47.000]  где-то приблизительно 64 умножек на количество стриминг мотивроцессоров.
[12:01.000 --> 12:04.000]  Да, это курт попугая.
[12:04.000 --> 12:07.000]  Почему здесь такая штука произойдет?
[12:12.000 --> 12:14.000]  Ну, за обработку...
[12:14.000 --> 12:18.000]  Там в стриминг мотивроцессоре лежит несколько варпов на эксплуатации.
[12:18.000 --> 12:21.000]  И у нас есть еще одна штука.
[12:21.000 --> 12:24.000]  И у нас есть еще одна штука.
[12:24.000 --> 12:27.000]  И у нас есть еще одна штука.
[12:27.000 --> 12:30.000]  И у нас есть еще одна штука.
[12:30.000 --> 12:32.000]  За обработку...
[12:32.000 --> 12:35.000]  Там в стриминг мотивроцессоре лежит несколько варпов на исполнении.
[12:35.000 --> 12:38.000]  Ну да, два варпа в каждом 32.
[12:38.000 --> 12:41.000]  Давайте такую спеку возьмем.
[12:42.000 --> 12:45.000]  Почему именно так?
[12:48.000 --> 12:51.000]  Напоминаю, почему это так.
[12:51.000 --> 12:54.000]  Потому что вот это у нас, это физическое представление.
[13:00.000 --> 13:03.000]  А вот это у нас какое?
[13:05.000 --> 13:08.000]  Представление?
[13:09.000 --> 13:12.000]  Ну, логическое.
[13:21.000 --> 13:23.000]  Во!
[13:23.000 --> 13:26.000]  Не, мы, конечно, эту штуку можем выровнять.
[13:26.000 --> 13:29.000]  Но тогда нам нужно указывать блок size64.
[13:30.000 --> 13:33.000]  Это раз.
[13:34.000 --> 13:37.000]  Ну то есть, если мы укажем блок size не 1024, а 64, в принципе, это мы можем сделать.
[13:37.000 --> 13:40.000]  Ну то есть, если мы укажем блок size64, не 1024, а 64, в принципе, это мы можем сделать.
[13:40.000 --> 13:43.000]  Да, тогда у нас эти чиселки сравняются.
[13:43.000 --> 13:46.000]  Ну согласны, да?
[13:48.000 --> 13:51.000]  Ну да, типа блок size мы сами можем устанавливать.
[13:51.000 --> 13:54.000]  Вот. Но в чем проблема возникает?
[13:54.000 --> 13:57.000]  Проблема возникает в том,
[13:57.000 --> 14:04.000]  что нам чтобы это еще эффективно реализовывать.
[14:04.000 --> 14:08.000]  Нам нужно во втором параметре ядра явно передавать количество стрелк-антипроцессоров.
[14:08.000 --> 14:11.000]  Нам нужно во втором параметре ядра явно передавать количество стрелк-антипроцессоров.
[14:11.000 --> 14:14.000]  чтобы это все максимально эффективно реализовывалось.
[14:16.000 --> 14:19.000]  Вот.
[14:19.000 --> 14:22.000]  Если не думая, вообще в тупую не думая,
[14:22.000 --> 14:25.840]  вообще в тупую, не думая, и отдать все по автоматике,
[14:25.840 --> 14:31.200]  то у нас количество операций будет немножечко больше.
[14:31.200 --> 14:34.400]  У нас количество операций будет...
[14:34.400 --> 14:35.760]  Сколько?
[14:35.760 --> 14:44.080]  Давайте 1024 умножить...
[14:44.080 --> 14:46.560]  Стреминг метеопроцессоров сколько у нас?
[14:46.560 --> 14:48.880]  Я положил.
[14:48.880 --> 14:52.080]  По автомату 64, поделите у нас, а не 64.
[14:52.080 --> 14:56.240]  Да, ну где-то 64.
[14:56.240 --> 15:02.640]  А эта константа у нас с вами не меняется.
[15:02.640 --> 15:08.560]  Да, кажется, она у нас не меняется.
[15:08.560 --> 15:17.680]  И уже получается немножечко неприятно.
[15:17.760 --> 15:23.440]  Мы что-то ошиблись так, с процентов на 20.
[15:23.440 --> 15:25.600]  А?
[15:25.600 --> 15:27.440]  Ну, все равно.
[15:27.440 --> 15:30.720]  А, еще я учитываю, что у нас есть накладные расходы,
[15:30.720 --> 15:33.280]  которые нам нужны для сложения.
[15:33.280 --> 15:36.720]  Это скопировать, перекопировать.
[15:36.720 --> 15:42.960]  Сами знаете, что копирование данных у нас занимает до 90% времени.
[15:42.960 --> 15:45.760]  Да, то есть это еще...
[15:45.840 --> 15:51.040]  На 9 перемножить, вот тогда получим эффективную цифру.
[15:51.040 --> 15:55.280]  Так, ну хорошо.
[15:55.280 --> 15:58.400]  Тогда вопрос, а что же с этим делать?
[15:58.400 --> 16:04.560]  Ну, идея такая, давайте вот эту операцию попытаемся максимально реализовать эффективно на ГПУ.
[16:04.560 --> 16:06.800]  То есть этот ЦПУ заменить на ГПУ.
[16:06.800 --> 16:14.080]  Наша задача сегодня, это научиться читать сумму чисел в блоке.
[16:14.080 --> 16:16.800]  Понять, за сколько это можно эффективно сделать.
[16:16.800 --> 16:17.760]  Угу.
[16:17.760 --> 16:21.520]  Ну вот, то есть если сумма не влияет на сумму чисел?
[16:21.520 --> 16:22.800]  Да, да.
[16:22.800 --> 16:28.800]  То есть у нас получается, что сейчас сумма считается поблочно.
[16:28.800 --> 16:30.080]  Да, вот в той абстракции.
[16:30.080 --> 16:32.960]  Поэтому нам нужно считать сумму по блокам.
[16:32.960 --> 16:37.840]  То есть мы для каждого блока можем посчитать сумму значений внутри этого блока.
[16:37.840 --> 16:39.760]  Да.
[16:39.760 --> 16:42.800]  А дальше попробовать это каким-то образом агрегировать.
[16:42.800 --> 16:46.800]  А размер блока у нас 1024?
[16:46.800 --> 16:50.800]  Нет, размер блока у нас 1024 будет.
[16:50.800 --> 16:52.800]  А где 1024?
[16:52.800 --> 16:58.800]  Ну, ну можно 64, но типа обычно ставят побольше.
[16:58.800 --> 17:01.360]  Ну типа это эффективнее будет.
[17:01.360 --> 17:05.840]  Вот, параллельное решение на ЦПУ, оно типа вот такое, оно более простое.
[17:05.840 --> 17:11.840]  На ГПУ вопрос, ну типа, опять же мы обсудили, что нельзя получить и наделить на С.
[17:11.840 --> 17:19.840]  Поэтому, смотрите, давайте поймем, за сколько мы можем обработать каждый блок по времени.
[17:19.840 --> 17:25.840]  Вот, утверждение такое, как тут Байер говорил, надо складывать все пирамидкой.
[17:25.840 --> 17:31.840]  Вот, вы смотрите, предположение, блок size у нас является размером двойки.
[17:31.840 --> 17:33.840]  Да, мы его задаем.
[17:33.840 --> 17:37.840]  Поэтому мы можем начать складывать вот таким вот образом.
[17:37.840 --> 17:41.840]  То есть берем значение, которое у нас есть.
[17:41.840 --> 17:47.840]  Берем и говорим, что нулевой трет будет заниматься сложением чисел 0,1.
[17:47.840 --> 17:51.840]  Второй трет будет заниматься вторым и третьим и так далее.
[17:51.840 --> 17:59.840]  В итоге после первой операции, которая по сути делается за одну, за один логический такт,
[17:59.840 --> 18:04.840]  на физических тактах там будет чутка побольше, мы вычисляем сумму по два.
[18:04.840 --> 18:08.840]  На следующей итерации мы вычисляем сумму по четыре.
[18:08.840 --> 18:16.840]  Взяв значение суммы, которая у нас находится в нулевом потоке и во втором потоке.
[18:16.840 --> 18:23.840]  Потом нулевой четвертой суммы по четыре получаем восемь и так далее.
[18:23.840 --> 18:26.840]  Пирамидкой.
[18:26.840 --> 18:35.840]  Ну, мы не используем ничетные блоки, но сейчас обсудим как раз это тоже интересная особенность.
[18:35.840 --> 18:40.840]  А, ну да, но они простаивают.
[18:40.840 --> 18:43.840]  Как вы думаете, это эффективно?
[18:43.840 --> 18:45.840]  Нет.
[18:45.840 --> 18:51.840]  Хороший вопрос про ничетные блоки, за счет этого как раз возникает неэффективность.
[18:52.840 --> 18:58.840]  Давайте поймем, почему эта операция выполняется за n делить на... так.
[18:58.840 --> 19:02.840]  Каждый блок можно обработать за...
[19:02.840 --> 19:06.840]  Чего кажется, константа какая-то другая.
[19:06.840 --> 19:10.840]  За алгорифм от размера блока точно.
[19:10.840 --> 19:13.840]  Да.
[19:13.840 --> 19:17.840]  Давайте я поправлю константу.
[19:21.840 --> 19:26.840]  Это количество итераций алгоритма.
[19:26.840 --> 19:31.840]  Каждый такт за сколько исполняется?
[19:31.840 --> 19:34.840]  1 цикл 4.
[19:34.840 --> 19:39.840]  Ну да, но учитывайте, что у нас блок состоит из нескольких ворпов.
[19:39.840 --> 19:43.840]  Да, то есть это...
[19:43.840 --> 19:46.840]  Каждая операция
[19:46.840 --> 19:51.840]  будет выполняться за...
[19:51.840 --> 19:53.840]  Одна итерация.
[19:53.840 --> 19:58.840]  Ворпсайз.
[20:00.840 --> 20:03.840]  Что?
[20:03.840 --> 20:06.840]  VS это ворпсайз.
[20:06.840 --> 20:09.840]  Ворпсайз.
[20:09.840 --> 20:12.840]  Ворпсайз.
[20:12.840 --> 20:15.840]  Ворпсайз.
[20:16.840 --> 20:19.840]  Что?
[20:19.840 --> 20:22.840]  VS это ворпсайз.
[20:22.840 --> 20:26.840]  То есть у нас блок делится несколько ворпов.
[20:26.840 --> 20:31.840]  Да, и каждый ворп выполняется за один такт времени.
[20:31.840 --> 20:36.840]  А нам нужно пройти по размеру всему блока.
[20:36.840 --> 20:39.840]  По всему блоку.
[20:39.840 --> 20:44.840]  В одном ворпе все потоки работают одновременно.
[20:45.840 --> 20:50.840]  А в блоке ворпы работают последовательно.
[20:50.840 --> 20:52.840]  Ну давайте еще честно...
[20:52.840 --> 20:57.840]  На самом деле надо на количество ворпшедулеров помножить.
[21:03.840 --> 21:06.840]  Вот такая формула на самом деле.
[21:06.840 --> 21:11.840]  Потому что у нас два ворпа могут работать параллельно внутри одного.
[21:11.840 --> 21:14.840]  А?
[21:14.840 --> 21:17.840]  Ну да, это ворпсайз называется.
[21:17.840 --> 21:20.840]  Так.
[21:20.840 --> 21:25.840]  Это вот если в тупую реализовывать, а это реализовываться в тупую.
[21:25.840 --> 21:28.840]  Давайте экономить.
[21:28.840 --> 21:31.840]  Смотрите.
[21:31.840 --> 21:33.840]  Как реализовывать?
[21:33.840 --> 21:36.840]  Можно делать так.
[21:36.840 --> 21:43.840]  Реализовывать так, как на картинке указано, что 0-ой, 2-ой, 4-ой поток, 8-ой, 6-ой, 8-ой и так далее отвечают сложению.
[21:43.840 --> 21:46.840]  А можно сделать так, как предложила София.
[21:46.840 --> 21:50.840]  Эти воспользуемся нечетными нитрацами.
[21:50.840 --> 21:54.840]  То есть у нас получается, 0-ой поток будет заниматься сложением 0-ого и 1-ого.
[21:54.840 --> 21:57.840]  1-ой поток будет заниматься сложением 2-ого и 3-его.
[21:57.840 --> 22:02.840]  2-ой поток занимается сложением 4-ого и 5-ого и так далее.
[22:02.840 --> 22:05.840]  Как вы думаете, что быстрее будет работать?
[22:16.840 --> 22:19.840]  Да, да.
[22:22.840 --> 22:25.840]  Да, во второе будет кошмидсу, да.
[22:25.840 --> 22:33.840]  Ну, вообще думаем, но оно не будет играть существенную роль в этой задаче.
[22:36.840 --> 22:39.840]  Ну вот, смотрите.
[22:39.840 --> 22:42.840]  Давайте посчитаем.
[22:42.840 --> 22:46.840]  Вопрос, который я хочу задать.
[22:46.840 --> 22:49.840]  Представим, что размер блока 256.
[22:50.840 --> 22:54.840]  В первой операции сколько варпов у нас будет работать?
[22:54.840 --> 23:00.840]  За сколько варпов мы посчитаем первый элемент?
[23:05.840 --> 23:08.840]  Нет, количество варпов именно.
[23:11.840 --> 23:14.840]  Нет, почему два?
[23:15.840 --> 23:19.840]  Да, варпсайд 32, размер блока 256.
[23:19.840 --> 23:22.840]  Ну, смотрите.
[23:22.840 --> 23:25.840]  У нас за первую итерацию вычисляются элементы 0-ой.
[23:25.840 --> 23:29.840]  Берется 0-ой поток, 2-ой поток, 4-ой поток, 6-ой поток.
[23:29.840 --> 23:32.840]  Так далее.
[23:32.840 --> 23:35.840]  254-ый поток.
[23:37.840 --> 23:41.840]  Первый варп, это потоки с 0-ого по 31-ый.
[23:41.840 --> 23:44.840]  Это один.
[23:46.840 --> 23:49.840]  Да, все варпы будут работать.
[23:49.840 --> 23:52.840]  32, 63. Это второй варп.
[23:52.840 --> 23:55.840]  И получается последний.
[23:55.840 --> 23:58.840]  Давайте я сделаю так.
[23:58.840 --> 24:01.840]  256-32, 255.
[24:01.840 --> 24:05.840]  Это 8. Итого 8 варпов будут работать за эту итерацию.
[24:05.840 --> 24:10.840]  Ну, что в каждом куске из 32 подряд идущих потоков
[24:10.840 --> 24:13.840]  существует как минимум один, который работает.
[24:13.840 --> 24:17.840]  Это значит, что у нас варп точно работает.
[24:17.840 --> 24:21.840]  Просто у него половину потоков простаивает.
[24:21.840 --> 24:24.840]  Неэффективно.
[24:24.840 --> 24:27.840]  Согласна. Что-то все работает.
[24:27.840 --> 24:30.840]  На первой итерации 8.
[24:30.840 --> 24:35.840]  На второй итерации, кстати, вопрос, сколько будет варпов работать?
[24:35.840 --> 24:38.840]  Опять все. 8.
[24:38.840 --> 24:41.840]  То есть они через 4. Третья итерация.
[24:42.840 --> 24:45.840]  Опять все?
[24:45.840 --> 24:48.840]  Четвертая итерация.
[24:51.840 --> 24:54.840]  Ну, смотрите, почему все?
[24:54.840 --> 24:57.840]  Потому что у нас номер потока, который отвечает от них,
[24:57.840 --> 25:00.840]  они идут от 0 до 256 шагом 8.
[25:01.840 --> 25:04.840]  Да? 8.
[25:04.840 --> 25:07.840]  А?
[25:07.840 --> 25:10.840]  Что?
[25:10.840 --> 25:13.840]  Да, да, да. Ну, да.
[25:13.840 --> 25:16.840]  Так, на четвертой итерации тоже 8.
[25:16.840 --> 25:19.840]  Потому что они пока через 16.
[25:23.840 --> 25:26.840]  Через 32 опять 8.
[25:26.840 --> 25:29.840]  Потому что в каждом есть ровно по одному варпу.
[25:29.840 --> 25:32.840]  В 64 сколько будет? Через 64 когда?
[25:32.840 --> 25:35.840]  7. Нет, не 7.
[25:35.840 --> 25:38.840]  4. Половина уйдет.
[25:38.840 --> 25:41.840]  А?
[25:41.840 --> 25:44.840]  Ну, потому что у нас будут отвечать за сложение
[25:44.840 --> 25:47.840]  0, 64, 128 и 192.
[25:47.840 --> 25:50.840]  То есть с 31 по 63 пропадут.
[25:53.840 --> 25:56.840]  Ну и так, каждый второй.
[25:56.840 --> 25:59.840]  И последнее сложение будет двумя варпами.
[25:59.840 --> 26:02.840]  Итого, если я правильно посчитал,
[26:02.840 --> 26:05.840]  будет 46 варп итераций.
[26:05.840 --> 26:08.840]  46 в раз мы затригмируем ворп.
[26:08.840 --> 26:11.840]  Запоминаем цифру.
[26:11.840 --> 26:14.840]  46.
[26:14.840 --> 26:17.840]  И вот это 46.
[26:17.840 --> 26:20.840]  А?
[26:20.840 --> 26:23.840]  Нет, не только высота.
[26:23.840 --> 26:26.840]  Ну вот она, у нас по сути получилась
[26:26.840 --> 26:29.840]  достижимая верхняя оценка, плюс-минус константа какая-то.
[26:29.840 --> 26:32.840]  Почему константа появляется?
[26:32.840 --> 26:35.840]  Потому что, вот здесь, какая?
[26:35.840 --> 26:38.840]  Ну вот, а что такое 8 у нас?
[26:38.840 --> 26:41.840]  Ну вот, а что такое 8 у нас?
[26:41.840 --> 26:44.840]  Ну вот, а что такое 8 у нас?
[26:44.840 --> 26:47.840]  Ну вот.
[26:47.840 --> 26:50.840]  Ну вот, а что такое 8 у нас?
[26:50.840 --> 26:53.840]  Сколько варпов у нас
[26:53.840 --> 26:56.840]  используется внутри блока?
[26:56.840 --> 26:59.840]  Да.
[26:59.840 --> 27:02.840]  Вот, как раз у нас 8.
[27:02.840 --> 27:05.840]  Блок size поделить на warp size.
[27:05.840 --> 27:08.840]  Ну и на каждой итерации они
[27:08.840 --> 27:11.840]  оттригируются.
[27:11.840 --> 27:14.840]  Ну потому что на самом деле
[27:14.840 --> 27:17.840]  если бы был один ворп-шедулер,
[27:17.840 --> 27:20.840]  то у нас в блоке бы все ворпы
[27:20.840 --> 27:23.840]  исполнялись последовательно.
[27:23.840 --> 27:26.840]  А так мы можем раскинуть на два ворпа параллельных.
[27:26.840 --> 27:29.840]  Так, теперь предлагаем умный подход.
[27:29.840 --> 27:32.840]  Давайте сделаем по-честному.
[27:32.840 --> 27:35.840]  Давайте картинку нарисуем для того, чтобы было понятно.
[27:35.840 --> 27:38.840]  Ну вот.
[27:38.840 --> 27:41.840]  Ну вот.
[27:41.840 --> 27:44.840]  То есть у нас с вами
[27:44.840 --> 27:47.840]  нулевой поток отвечает
[27:47.840 --> 27:50.840]  за сложение нулевого первого.
[27:50.840 --> 27:53.840]  Сначала
[27:53.840 --> 27:56.840]  первый поток за сложение второго
[27:56.840 --> 27:59.840]  плюс третьего и так далее.
[27:59.840 --> 28:02.840]  Тут поток, по-моему, 127.
[28:02.840 --> 28:05.840]  Будет заниматься сложением 254
[28:05.840 --> 28:08.840]  плюс 255.
[28:08.840 --> 28:11.840]  Почему у нас тут задействовано?
[28:11.840 --> 28:14.840]  Половина. Потому что вторая со 128
[28:14.840 --> 28:17.840]  уже не работает.
[28:17.840 --> 28:20.840]  А?
[28:20.840 --> 28:23.840]  Чего?
[28:23.840 --> 28:26.840]  Да, да.
[28:26.840 --> 28:29.840]  Сначала подвое.
[28:29.840 --> 28:32.840]  Но только номера поток, в которые занимаются этим, уже другие.
[28:32.840 --> 28:35.840]  Ну, потому что
[28:35.840 --> 28:38.840]  у нас ворпы с ID-шниками
[28:38.840 --> 28:41.840]  со 128 там до 159
[28:41.840 --> 28:44.840]  простаивает, потому что он не используется.
[28:44.840 --> 28:47.840]  А?
[28:47.840 --> 28:50.840]  Да, эти потоки не используются, поэтому ворп не используется.
[28:50.840 --> 28:53.840]  Ну ворп опираться по ним.
[28:53.840 --> 28:56.840]  Вот. Дальше нулевой будет складывать.
[28:56.840 --> 28:59.840]  Первый будет складывать.
[29:02.840 --> 29:05.840]  И так далее.
[29:05.840 --> 29:08.840]  И тут, по-моему, 63 должен быть сложить.
[29:08.840 --> 29:11.840]  Вот такую вещь.
[29:11.840 --> 29:14.840]  Какие-то четыре последних.
[29:14.840 --> 29:17.840]  И сложно считать.
[29:17.840 --> 29:20.840]  Сколько здесь ворпов будет использоваться?
[29:20.840 --> 29:23.840]  Два.
[29:23.840 --> 29:26.840]  Ну, дальше видите картинку.
[29:28.840 --> 29:31.840]  Начиная с какого-то момента
[29:31.840 --> 29:34.840]  мы с вами будем уже использовать слишком
[29:34.840 --> 29:37.840]  меньше операций.
[29:37.840 --> 29:40.840]  То есть у нас константа, вот смотрите,
[29:40.840 --> 29:43.840]  было 46, стало 11.
[29:43.840 --> 29:46.840]  Четыре раза сэкономили.
[29:55.840 --> 29:58.840]  Ну, получится в два раза.
[29:58.840 --> 30:01.840]  Ну, не в четыре, но в два.
[30:01.840 --> 30:04.840]  Это еще не вся магия.
[30:04.840 --> 30:07.840]  Ну, в два раза.
[30:07.840 --> 30:10.840]  Ну, в два раза.
[30:10.840 --> 30:13.840]  Это еще не вся магия.
[30:13.840 --> 30:16.840]  А?
[30:16.840 --> 30:19.840]  Ну, во-первых, они в последний,
[30:19.840 --> 30:22.840]  а во-вторых, это просто так процессора.
[30:22.840 --> 30:25.840]  Мы отправляем так процессора вычислить задачу.
[30:25.840 --> 30:28.840]  А если мы еще должны элементы массива взять оттуда,
[30:28.840 --> 30:31.840]  то это еще полто с операцией.
[30:31.840 --> 30:34.840]  Если они не в shared память.
[30:34.840 --> 30:37.840]  На самом деле все элементы массива изначально
[30:37.840 --> 30:40.840]  мы складываем, мы можем использовать al1cache,
[30:40.840 --> 30:43.840]  то бишь shared блок, для использования этой операции.
[30:43.840 --> 30:46.840]  Там все равно блокировка потом будет.
[30:46.840 --> 30:49.840]  Так что cache-miss, не cache-miss, там вообще
[30:49.840 --> 30:52.840]  особо нет.
[30:52.840 --> 30:55.840]  Вот.
[30:55.840 --> 30:58.840]  Но, когда мы с вами используем
[30:58.840 --> 31:01.840]  даже вот эту вот историю,
[31:01.840 --> 31:04.840]  вот эту операцию,
[31:04.840 --> 31:07.840]  потому что, типа, у нас нулевой поток
[31:07.840 --> 31:10.840]  исполняет операцию. 0 плюс 1, 0 плюс 2, плюс 3.
[31:10.840 --> 31:13.840]  Первый будет использовать 4 плюс 5, плюс 6, плюс 7.
[31:13.840 --> 31:16.840]  Это тоже не очень хорошо.
[31:16.840 --> 31:19.840]  Вспоминаем размер кашления.
[31:19.840 --> 31:22.840]  И чего у нас размер кашления?
[31:22.840 --> 31:25.840]  32.
[31:25.840 --> 31:28.840]  И теперь я хочу рассказать про одну особенность,
[31:28.840 --> 31:31.840]  связанную с использованием shared памяти.
[31:31.840 --> 31:34.840]  Она называется,
[31:34.840 --> 31:37.840]  по сути, такая супер кашление,
[31:37.840 --> 31:40.840]  она называется банк.
[31:40.840 --> 31:43.840]  Вот вы,
[31:43.840 --> 31:46.840]  классический пример, который я привожу,
[31:46.840 --> 31:49.840]  входили в ОФЦ?
[31:49.840 --> 31:52.840]  Там куча окошечек, да,
[31:52.840 --> 31:55.840]  которые вас направляют.
[31:55.840 --> 31:58.840]  Вопрос. Если вас отправили в одно окошко,
[31:58.840 --> 32:01.840]  и другого человека отправили в одно и то же окошко,
[32:01.840 --> 32:04.840]  то что произойдет?
[32:07.840 --> 32:10.840]  Это если мы с вами злые люди
[32:10.840 --> 32:13.840]  и любим по конфликту.
[32:13.840 --> 32:16.840]  Кто-то будет ждать.
[32:16.840 --> 32:19.840]  Так вот.
[32:19.840 --> 32:22.840]  Shared памяти — это у нас МФЦ такое,
[32:22.840 --> 32:25.840]  в котором есть 32
[32:25.840 --> 32:28.840]  окошка.
[32:35.840 --> 32:38.840]  И смотрите, в чем прикол.
[32:38.840 --> 32:41.840]  Если у вас
[32:41.840 --> 32:44.840]  какой-то из потоков
[32:44.840 --> 32:47.840]  обратится к пятому окну,
[32:47.840 --> 32:50.840]  и какой-то другой поток
[32:50.840 --> 32:53.840]  обратится к пятому окну,
[32:53.840 --> 32:56.840]  обратится к пятому окну,
[32:56.840 --> 32:59.840]  то что произойдет?
[32:59.840 --> 33:02.840]  Кого-то поставят на ожидание.
[33:02.840 --> 33:05.840]  Кого-то поставят на ожидание.
[33:05.840 --> 33:08.840]  Да, то есть у вас может случиться так,
[33:08.840 --> 33:11.840]  даже,
[33:11.840 --> 33:14.840]  что у вас там вот этот поток,
[33:14.840 --> 33:17.840]  смотрите, особенно в чем опасно.
[33:17.840 --> 33:20.840]  Если это происходит внутри варпа,
[33:20.840 --> 33:23.840]  допустим, это первый поток внутри варпа
[33:23.840 --> 33:26.840]  обратился к пятому окошку,
[33:26.840 --> 33:29.840]  а тут шестой поток обратился в окошко,
[33:29.840 --> 33:32.840]  в пятое окошко,
[33:32.840 --> 33:35.840]  тогда эта операция будет осуществлена
[33:35.840 --> 33:38.840]  не за один такт времени, а за два.
[33:38.840 --> 33:41.840]  Потому что каждый друг друга будет ждать.
[33:44.840 --> 33:47.840]  Эта история называется банконфликт.
[33:50.840 --> 33:53.840]  Особенно в том, что
[33:53.840 --> 33:56.840]  внутри варпа операция
[33:56.840 --> 33:59.840]  осуществляется за один такт,
[33:59.840 --> 34:02.840]  вместо того, что мы обращаемся
[34:02.840 --> 34:05.840]  с shared памятью, у нас возникает блокировка на shared память,
[34:05.840 --> 34:08.840]  и в итоге вместо одного обращения к памяти
[34:08.840 --> 34:11.840]  мы будем два такта работать.
[34:11.840 --> 34:14.840]  Потому что нам нужно, по сути,
[34:14.840 --> 34:17.840]  освободить обслуживающий персонал,
[34:17.840 --> 34:20.840]  который будет здесь.
[34:20.840 --> 34:23.840]  А теперь смотрите, прикол,
[34:23.840 --> 34:26.840]  у нас нулевой поток в какой-то момент времени
[34:26.840 --> 34:29.840]  нулевой поток складывал элементы
[34:29.840 --> 34:36.840]  0 плюс 16.
[34:39.840 --> 34:42.840]  Да, там реализация важная,
[34:42.840 --> 34:45.840]  что элементы у нас с вами
[34:45.840 --> 34:48.840]  будут храниться таким же образом.
[34:48.840 --> 34:51.840]  Т.е. thread ID будет заниматься не тот,
[34:51.840 --> 34:54.840]  а сумма элементов будет складываться именно так.
[34:54.840 --> 34:57.840]  Т.е. в нулевом элементе у нас будет храниться с вами
[34:57.840 --> 35:00.840]  сумма нулевого и первого,
[35:00.840 --> 35:03.840]  во втором элементе складываться будет
[35:03.840 --> 35:06.840]  сумма второго и третьего и так далее.
[35:09.840 --> 35:12.840]  Вопрос.
[35:12.840 --> 35:15.840]  Если мы перейдем до очень плохой стадии
[35:15.840 --> 35:18.840]  в shared памяти,
[35:18.840 --> 35:21.840]  то у нас возникнет когда-то такая проблема.
[35:21.840 --> 35:24.840]  Я сейчас ее нарисую.
[35:30.840 --> 35:33.840]  Смотрите, вот у нас тут вот
[35:33.840 --> 35:36.840]  нулевой элемент,
[35:36.840 --> 35:39.840]  вот тут сумма находится от нулевого до
[35:39.840 --> 35:42.840]  пятнадцатого,
[35:42.840 --> 35:45.840]  да, нулевого до пятнадцатого,
[35:45.840 --> 35:48.840]  а в шнадс на блоке находится сумма
[35:48.840 --> 35:51.840]  шестнадцатого до тридцать первого.
[35:57.840 --> 36:00.840]  Да, это массивы.
[36:00.840 --> 36:03.840]  В 32 элементе будет находиться сумма
[36:03.840 --> 36:06.840]  32 по 47,
[36:06.840 --> 36:09.840]  а 48 из 48 по 63.
[36:12.840 --> 36:15.840]  И тут смотрите, что говорит.
[36:17.840 --> 36:20.840]  Нулевой элемент для того, чтобы посчитать
[36:20.840 --> 36:23.840]  сумму вот этого плюс вот этого,
[36:23.840 --> 36:26.840]  должен за три гирицы,
[36:26.840 --> 36:29.840]  давайте их жирными обведу,
[36:29.840 --> 36:32.840]  вот этот нулевой
[36:32.840 --> 36:35.840]  плюс шестнадцать, т.е. вот это вот шестнадцать.
[36:35.840 --> 36:38.840]  А первый поток
[36:38.840 --> 36:41.840]  будет триггерить сумму 32 плюс 48
[36:41.840 --> 36:44.840]  элемента массива.
[36:46.840 --> 36:49.840]  В чем проблема?
[36:53.840 --> 36:56.840]  Напоминаю, что получение
[36:56.840 --> 36:59.840]  данных и шеред памяти
[36:59.840 --> 37:02.840]  происходит по 32 окнам.
[37:05.840 --> 37:08.840]  Смотрите, в чем заключается
[37:08.840 --> 37:11.840]  проблема. Первый поток значений
[37:11.840 --> 37:14.840]  32 элемента из какого окна будет получать?
[37:17.840 --> 37:20.840]  Из нулевого.
[37:28.840 --> 37:31.840]  Почему из первого?
[37:31.840 --> 37:34.840]  Не, смотрите.
[37:34.840 --> 37:37.840]  История такая, что здесь у нас
[37:37.840 --> 37:40.840]  в нулевом элементе хранится сумма от нулевого до пятнадцатого,
[37:40.840 --> 37:43.840]  в шестнадцатом элементе от шестнадцатого до тридцать первого.
[37:43.840 --> 37:46.840]  А здесь мы берем, что
[37:46.840 --> 37:49.840]  в 32 элементе массива хранится сумма
[37:49.840 --> 37:52.840]  32 до 47, а в 48
[37:52.840 --> 37:55.840]  от 48 до 63.
[37:55.840 --> 37:58.840]  То есть это у нас
[37:58.840 --> 38:01.840]  массив А, в котором мы хотим
[38:01.840 --> 38:04.840]  посчитать сумму.
[38:06.840 --> 38:09.840]  Почему?
[38:09.840 --> 38:12.840]  От нулевого до пятнадцатого.
[38:18.840 --> 38:21.840]  В чем проблема?
[38:21.840 --> 38:24.840]  Товарищи, смотрите.
[38:24.840 --> 38:27.840]  Вот этот вот элемент, то есть как это перекладывается в код?
[38:27.840 --> 38:30.840]  Тут у нас А0 и плюс А16 будут,
[38:30.840 --> 38:33.840]  а здесь у нас будет
[38:33.840 --> 38:36.840]  А32 и плюс А48.
[38:36.840 --> 38:39.840]  Вопрос.
[38:39.840 --> 38:42.840]  А32 из какого окна будем получать?
[38:42.840 --> 38:45.840]  Из нулевого.
[38:45.840 --> 38:48.840]  Давайте его так.
[38:48.840 --> 38:51.840]  То есть А0 мы будем получать из окна
[38:51.840 --> 38:54.840]  ноль, а А32
[38:54.840 --> 38:57.840]  мы будем получать из окна под номером ноль.
[39:00.840 --> 39:03.840]  Причем вот эта операция,
[39:03.840 --> 39:06.840]  операция загрузки элемента, она будет происходить в один такт времени.
[39:06.840 --> 39:09.840]  Что произойдет?
[39:09.840 --> 39:12.840]  А? Один будет ждать.
[39:12.840 --> 39:15.840]  А?
[39:15.840 --> 39:18.840]  Ну, потому что элементы
[39:18.840 --> 39:21.840]  грузят в массив последовательно,
[39:21.840 --> 39:24.840]  там опять же все кошлини поделены на размер 32.
[39:24.840 --> 39:27.840]  Вот и все.
[39:35.840 --> 39:38.840]  Там все, там фиксировано.
[39:38.840 --> 39:41.840]  Ты приходишь на почту, да?
[39:41.840 --> 39:44.840]  Вот у тебя индекс написан
[39:44.840 --> 39:47.840]  141.701, да?
[39:47.840 --> 39:50.840]  Да, берется в процент 32,
[39:50.840 --> 39:53.840]  это фиксированный адрес,
[39:53.840 --> 39:56.840]  то есть у тебя именно фиксированное окно.
[39:56.840 --> 39:59.840]  Тебя так или иначе отправляют, потому что там, если смотреть
[39:59.840 --> 40:02.840]  в банковской сфере, там талон B, что-то там.
[40:02.840 --> 40:05.840]  Да, и тебя сразу отправляют в определенный О,
[40:05.840 --> 40:08.840]  потому что у тебя буква Б начинается.
[40:08.840 --> 40:11.840]  Вот, у нас возникает проблема, у нас возникает банк конфликт.
[40:11.840 --> 40:14.840]  Понятно, да, откуда возникает он?
[40:14.840 --> 40:17.840]  Вот.
[40:17.840 --> 40:20.840]  У нас банк конфликт.
[40:20.840 --> 40:23.840]  Да, я тут написал, что такое банк конфликт.
[40:23.840 --> 40:26.840]  Это поведение к ворб в shared memory, когда два потока внутри одного ворпа
[40:26.840 --> 40:29.840]  запрашивают данные разных кошлини по одинаковому индексу,
[40:29.840 --> 40:32.840]  по модуле ворб-сайз. Мы как раз на картинке это обсудили.
[40:32.840 --> 40:35.840]  Они устраиваются в очередь, ну и возникает проблема.
[40:35.840 --> 40:38.840]  Значит, как это решать?
[40:38.840 --> 40:41.840]  А решается это вот так вот, вот такой картинкой.
[40:47.840 --> 40:50.840]  То есть нулевой элемент теперь будет заниматься сложением...
[40:50.840 --> 40:53.840]  То есть давайте как раз картинку поясню.
[40:53.840 --> 40:56.840]  Здесь у нас блок size на этой картинке равен к чему?
[40:56.840 --> 40:59.840]  32, да?
[40:59.840 --> 41:02.840]  Смотрите, что происходит.
[41:02.840 --> 41:05.840]  Нулевой элемент будет заниматься сложением нулевого
[41:05.840 --> 41:08.840]  и 128-го элемента.
[41:08.840 --> 41:11.840]  Первый будет заниматься сложением первого
[41:11.840 --> 41:14.840]  и 129-го элемента и так далее.
[41:17.840 --> 41:20.840]  То есть они будут заниматься сложением не последних элементов,
[41:20.840 --> 41:23.840]  а через проскок.
[41:26.840 --> 41:29.840]  Короче, дайте, чтобы не запутаться.
[41:32.840 --> 41:35.840]  С вами нарисуем картинку.
[41:35.840 --> 41:38.840]  Вот так вот.
[41:39.840 --> 41:41.840]  То есть этот будет заниматься сложением...
[41:41.840 --> 41:44.840]  Нулевой поток будет заниматься сложением вот этого.
[41:44.840 --> 41:47.840]  Первый поток будет заниматься сложением вот так.
[41:50.840 --> 41:53.840]  Второй вот так вот.
[41:53.840 --> 41:56.840]  А 127-й вот так вот.
[41:59.840 --> 42:02.840]  Вот.
[42:02.840 --> 42:12.040]  вот так вот. Ну типа считать, что вы берете вот этот массив и параллельно
[42:12.040 --> 42:19.520]  переносите на первую половину. И отчисляем еще раз такую операцию. Тогда давайте
[42:19.520 --> 42:25.840]  рассмотрим, что у нас произойдет на моменте, когда у нас будет 16. То есть у нас
[42:25.840 --> 42:40.480]  с вами самый интересный момент. Это когда у нас с вами тут 31, 63. Какие потоки у нас
[42:40.480 --> 42:51.320]  с вами будут задействованы? Нулевой будет складываться с 32, первый будет складываться
[42:51.320 --> 43:03.320]  с 33, а 31, 63. Тут даже видно, что они обращаются по модулю 32 всегда к разным ячейкам.
[43:03.320 --> 43:20.360]  И вот она у нас с вами как раз естественная версия без кэш миссов. И занимает она у нас
[43:20.480 --> 43:45.280]  11 операций сложений внутри блока. 11 варпсайзов. 11 варпов. Ну потому что у нас кэшлиния
[43:45.280 --> 43:50.320]  загружается параллельно внутри варпа, а первый поток будет обращаться к первому и к этому.
[43:50.320 --> 43:58.040]  129. Там кэш мисс считается, проблема была бы если бы у нас нулевой поток обращался к нулему,
[43:58.040 --> 44:04.600]  а первый поток бы обращался к второму элементу. У нас же кэшлиния подгружается последовательно,
[44:04.600 --> 44:10.680]  то есть на ворп на один. То есть они все дружненько взяли элемент, потом дружненько все взяли второй
[44:10.680 --> 44:20.960]  элемент и сложили. Ну да, ну и параллельно с этим, с первым подъедет 29, второму 130 и так далее.
[44:20.960 --> 44:41.560]  Не-не-не, смотри, прикол. Когда нулевой поток подгружает кэш для нулевого,
[44:41.560 --> 44:49.320]  у первого же тоже стоит операция взять первый элемент. У нас же код как написан?
[44:49.320 --> 45:03.920]  Не, они просто, вот эти вот все первые 31 операции они выполнят просто за одну команду ассемблера.
[45:03.920 --> 45:24.000]  Ну вот, да, вот это, то есть у нас операция какая-то, аит равно аит плюс а, вот такая вот, да?
[45:24.000 --> 45:39.040]  Вот, там просто когда мы хотим вот это, что у нас такое, лот, аит, да, она просто для и от нулевого до 31
[45:39.040 --> 45:46.640]  выполняется за один такт, просто за одну команду. Поэтому этим ребятам нул подгружается своя кашление.
[45:46.640 --> 46:05.440]  В варпе одинаково работают, это главная особенность видеокарты, что внутри в варпа прямо просто
[46:05.440 --> 46:14.880]  синхронно. Ну это по сути, я бы сказал, со скоростью света, да, то есть там просто, по сути, импульс дается и все.
[46:14.880 --> 46:27.520]  Вот, вот эти, честно, один от спор по операции, вот они вот здесь получаются. Вот, то есть мы научились
[46:27.840 --> 46:36.560]  складывать сумму массивов на ЦПУ, ой, на ГПУ внутри блок. Значит, как можно сделать сумму массивов на несколько блоков?
[46:36.560 --> 46:55.040]  Давайте обсудим. Ну да, можно так, типа, можно пирамидальную историю сделать, то есть у вас
[46:55.120 --> 47:01.440]  сначала один блок, потом второй блок, потом третий блок, то есть у вас сначала делаете сумму массива
[47:01.440 --> 47:10.560]  внутри блока, потом внутри блока блоков и так далее. Вот, можно попытаться посчитать сумму массивов
[47:10.560 --> 47:20.080]  внутри блока, сумму массивов внутри этого. По каждому блоку, вот как, как саккумулировали мы с вами, в начале обсуждали,
[47:20.080 --> 47:24.480]  как это делать, а потом сделать сумму массива внутри блока, но там надо считать, что лучше получается.
[47:24.480 --> 47:30.720]  Вот, так, по сложению, по операциям понятно?
[47:30.720 --> 47:49.360]  Ну да, там проблемы с ГПУ памяти у нас есть.
[47:49.360 --> 48:04.240]  Итак, упоротые фишки. Так, товарищи, значит, шайтанские фишки, которые мы посмотрим с вами на семинаре.
[48:04.240 --> 48:12.800]  Помните, про ИЛП мы с вами рассуждали в прошлый раз, очень-очень долго, типа, что взять одну операцию,
[48:12.960 --> 48:19.760]  продублировать ее, тем самым уменьшить блок size в два раза, там, либо количество блока в два раза.
[48:19.760 --> 48:26.240]  Здесь это можно сделать на этапе загрузки в shared память и сэкономить себе очень-очень сильно.
[48:26.240 --> 48:33.440]  То есть вы там, как код выглядит, вы берете, копируете весь массив блока в shared память,
[48:33.440 --> 48:40.240]  потом в shared памяти выполнять какие-то операции. Вы вместо того, чтобы копировать сразу в shared
[48:40.240 --> 48:48.160]  память, вы делаете операцию, первый блок на первом уровне и кладете это все в shared память.
[48:48.160 --> 48:55.840]  То есть вот это вот элемент, то есть вместо того, чтобы сразу сделать копию массива 256,
[48:55.840 --> 49:07.120]  вы создаете массив размера 128 и выполняете первую операцию, сложение и присваивание в shared память.
[49:07.200 --> 49:10.240]  Понятно, или рассказать, или показать?
[49:12.240 --> 49:19.920]  Смотрите, давайте, давайте, может быть, я код даже напишу, какой-нибудь псевдокод.
[49:23.920 --> 49:25.040]  Давайте vim.
[49:38.080 --> 49:39.760]  Неважно, что там происходит, да?
[49:40.960 --> 49:53.920]  Значит, важно с вами, что у нас есть x, ну и, допустим, у нас массив a.
[49:57.920 --> 50:00.960]  Вот, смотрите, первое, что мы могли бы сделать.
[50:07.120 --> 50:12.240]  Так, мы могли бы сделать вот такую вот вещь.
[50:16.240 --> 50:24.640]  A idx, idx мы умеем высчитывать, да, я не показывал, как его высчитывать.
[50:24.640 --> 50:48.160]  Это первая версия, ага, вторая, она немножко вот такая вот.
[50:48.160 --> 50:55.680]  Так, по-моему, shared все-таки неправильно обознать, да.
[50:55.680 --> 51:08.400]  То есть мы делаем, смотрите, какую вещь, да, тут флоты, здесь делаем вот так вот, x.
[51:18.160 --> 51:33.920]  Вот, первая версия у нас обычная, вторая версия умная.
[51:33.920 --> 51:49.680]  То есть вместо того, что в тупую скопировать массив, мы берем, делаем операцию, потом копируем массив.
[51:49.680 --> 51:54.320]  Нам все равно количество операций на чтении не поменяется за все время работы алгоритма.
[51:54.320 --> 51:58.880]  Хоть мы выдергиваем вот так вот, хоть мы два раза выдергиваем.
[51:59.840 --> 52:04.800]  Да, но при этом количество записей и shared на памяти уменьшается в два раза.
[52:12.800 --> 52:17.760]  Ну можно, но это уже смысла там нету, там уже нет такого профита.
[52:19.760 --> 52:23.040]  Вот, вот такая вот вещь.
[52:23.200 --> 52:33.040]  Вторая вещь, вообще, вторая вещь крутая, которая заключается в том, что когда вы уже находитесь внутри одного варпа,
[52:33.040 --> 52:48.640]  да, когда у вас все операции внутри одного варпа идут, то есть у вас вот тут вот, да, вопрос, зачем нам здесь цикл уже?
[52:53.040 --> 53:02.320]  А? Незачем? Вот, поэтому вы доходите суммой цикла до размера 32, а потом берете и разворачиваете эту фигню.
[53:02.320 --> 53:07.120]  Просто пять операций сложения пишете, что-то типа такого.
[53:23.120 --> 53:27.120]  Ускорение до 16 раз.
[53:33.120 --> 53:41.120]  Ну пять, потому что это 32, 16, там и так далее.
[53:41.120 --> 53:47.120]  Третий вообще кук-хацкер. В куде девятый плюс появилась регистровая операция,
[53:47.200 --> 53:49.200]  которая умеет делать магию.
[53:51.200 --> 54:01.200]  Есть операция shuffle-down-sink, которая за одну регистровую команду, это реально регистровая команда, берет и сделает битовый сдвиг внутри элементов массива.
[54:01.200 --> 54:05.200]  А? Да блин, задолбала.
[54:05.280 --> 54:15.280]  Ну то есть, смотрите, у вас элемент был А16, да, после применения этой операции, если сдвиг на 16 идет, то он берет и делает его А0.
[54:21.280 --> 54:29.280]  И там просто пять регистровых операций выписывается, которые типа битовые.
[54:29.360 --> 54:33.360]  В ассамблерные команды это чуть-чуть быстрее получается.
[54:33.360 --> 54:35.360]  Что, не работает?
[54:37.360 --> 54:39.360]  Вот.
[54:39.360 --> 54:43.360]  На семинаре посмотрите эти примеры, они все есть в репозиториях.
[54:45.360 --> 54:49.360]  Это сложение, мы с сложением разобрались.
[54:49.360 --> 54:53.360]  Да, у нас еще сколько минут? Два часа.
[54:53.440 --> 54:55.440]  Попробуем со сканированием разобраться.
[54:55.440 --> 54:59.440]  Значит, по суммированию понятно?
[54:59.440 --> 55:03.440]  Теперь сложная задача, которая еще хуже параллеляется.
[55:03.440 --> 55:07.440]  У нас есть массив А, нам нужно посчитать сумму на префиксе.
[55:11.440 --> 55:13.440]  Кто-нибудь решал такую задачу параллельно?
[55:13.440 --> 55:15.440]  Нет?
[55:15.440 --> 55:19.440]  Ну, в общем-то, у нас есть массив А, нам нужно посчитать сумму на префиксе.
[55:19.520 --> 55:23.520]  Кто-нибудь решал такую задачу параллельно?
[55:23.520 --> 55:25.520]  Вообще нет.
[55:25.520 --> 55:27.520]  Давайте разобраться.
[55:27.520 --> 55:29.520]  Смотрите.
[55:29.520 --> 55:31.520]  Первый алгоритм наивный.
[55:31.520 --> 55:33.520]  То есть, что вам происходит?
[55:43.520 --> 55:45.520]  Давайте я на бумажке тогда расскажу.
[55:45.520 --> 55:47.520]  На доске.
[55:49.520 --> 55:51.520]  А?
[55:51.520 --> 55:55.520]  Да-да-да, массив сумма на префиксе.
[55:59.520 --> 56:01.520]  Давайте я тогда рисовать начну.
[56:03.520 --> 56:05.520]  Ну, все равно нам поможет картинка.
[56:05.520 --> 56:09.520]  Давайте рассмотрим массив из 8 элементов.
[56:13.520 --> 56:17.520]  Это, если что, индекс элементов массива.
[56:19.520 --> 56:21.520]  Итак, смотрите, что мы делаем.
[56:21.520 --> 56:23.520]  Наберем...
[56:23.520 --> 56:25.520]  Складываем массивы по одному.
[56:27.520 --> 56:29.520]  Потом один-два.
[56:41.520 --> 56:43.520]  Потом один-два.
[56:43.600 --> 56:45.600]  Потом через два.
[56:51.600 --> 56:53.600]  Один-четыре.
[56:53.600 --> 56:55.600]  Два-пять.
[56:57.600 --> 56:59.600]  Ну, и потом последняя операция.
[57:07.600 --> 57:09.600]  0,7.
[57:09.680 --> 57:11.680]  0,7.
[57:11.680 --> 57:13.680]  Скажите, почему это плохо?
[57:13.680 --> 57:15.680]  Почему так делать плохо?
[57:21.680 --> 57:23.680]  Именно так, как показано это на экране.
[57:25.680 --> 57:27.680]  Конкурирующая запись.
[57:27.680 --> 57:29.680]  Конкурирующая запись мы пишем в шерп память.
[57:31.680 --> 57:33.680]  То есть, когда мы будем писать, допустим,
[57:35.680 --> 57:37.680]  вот информацию вот сюда,
[57:37.760 --> 57:39.760]  да?
[57:39.760 --> 57:41.760]  У нас вот этот вот элемент,
[57:41.760 --> 57:43.760]  который начнет писать информацию сюда,
[57:45.760 --> 57:47.760]  он может уже взять информацию
[57:47.760 --> 57:49.760]  не суммы второго и третьего,
[57:49.760 --> 57:51.760]  суммы третьего элемента,
[57:51.760 --> 57:53.760]  а суммы второго и третьего взять.
[57:55.760 --> 57:57.760]  Потому что мы перезапишем это значение.
[57:59.760 --> 58:01.760]  То есть у нас гонка данных возникает.
[58:03.760 --> 58:05.760]  Поэтому такая реализация отстойная.
[58:07.760 --> 58:09.760]  Давайте поумнее что-нибудь придумаем.
[58:13.760 --> 58:15.760]  Это, знаете, задача
[58:15.760 --> 58:17.760]  на уровне этих лохотронов по телеку,
[58:17.760 --> 58:19.760]  которые показывают.
[58:19.760 --> 58:21.760]  Уберите лишние стрелочки на экране, чтобы это работало.
[58:27.760 --> 58:29.760]  Ну, вы знаете, там бывает,
[58:29.760 --> 58:31.760]  по телеку показывают там эти всякие, типа...
[58:31.840 --> 58:33.840]  Да, да.
[58:37.840 --> 58:39.840]  Ну, а, фу ты.
[58:39.840 --> 58:41.840]  А, да, ёптись.
[58:41.840 --> 58:43.840]  Сейчас.
[58:43.840 --> 58:45.840]  Да.
[58:45.840 --> 58:47.840]  Ну, а оно там получается так.
[58:49.840 --> 58:51.840]  То есть и так, тут 0,3, тут 0,2,
[58:51.840 --> 58:53.840]  0,1 и тут 0.
[58:53.840 --> 58:55.840]  Потому что 0,1,
[58:55.840 --> 58:57.840]  тут мы складываем.
[58:57.840 --> 58:59.840]  Чё?
[58:59.920 --> 59:01.920]  0,1,2?
[59:03.920 --> 59:05.920]  Да, вот потому что здесь мы складываем
[59:05.920 --> 59:07.920]  0,1,2.
[59:07.920 --> 59:09.920]  Тут получаем 0,2.
[59:09.920 --> 59:11.920]  Там и так далее.
[59:11.920 --> 59:13.920]  Тут понятно, что мы складываем
[59:15.920 --> 59:17.920]  0,1,4.
[59:17.920 --> 59:19.920]  Да.
[59:19.920 --> 59:21.920]  Вопрос. Давайте сотрём стрелочки
[59:21.920 --> 59:23.920]  на экране так, чтобы было верно.
[59:29.920 --> 59:31.920]  Можем ли мы так сделать?
[59:37.920 --> 59:39.920]  Давайте начнём с этой стрелочки.
[59:43.920 --> 59:45.920]  Вопрос. 3,4 у нас где-нибудь используется?
[59:47.920 --> 59:49.920]  Давайте проследим. Вот тут вот операция.
[59:49.920 --> 59:51.920]  3,4 идёт.
[59:51.920 --> 59:53.920]  Вопрос.
[59:53.920 --> 59:55.920]  3,4 у нас где-нибудь используется?
[59:56.000 --> 59:58.000]  Давайте проследим.
[59:58.000 --> 01:00:00.000]  Вот тут вот операция. 3,4 идёт.
[01:00:00.000 --> 01:00:02.000]  Да? Где она используется?
[01:00:04.000 --> 01:00:06.000]  3,4,5,6.
[01:00:12.000 --> 01:00:14.000]  3,4,5,6. 3,6 используется.
[01:00:14.000 --> 01:00:16.000]  Где у нас?
[01:00:18.000 --> 01:00:20.000]  0,2 и 3,6.
[01:00:26.000 --> 01:00:28.000]  Так.
[01:00:30.000 --> 01:00:32.000]  Вопрос.
[01:00:32.000 --> 01:00:34.000]  Могли бы мы это как-то другим
[01:00:34.000 --> 01:00:36.000]  способом получить?
[01:00:40.000 --> 01:00:42.000]  То есть мы написали с вами, что 0,6
[01:00:42.000 --> 01:00:44.000]  это 0,2
[01:00:44.000 --> 01:00:46.000]  плюс 3,6.
[01:00:52.000 --> 01:00:54.000]  Как мы это ещё можем написать?
[01:00:54.080 --> 01:00:56.080]  Давайте по степеням 2 это разложение сделаем.
[01:01:08.080 --> 01:01:10.080]  Можем так посчитать?
[01:01:20.080 --> 01:01:22.080]  То есть 0,6
[01:01:22.160 --> 01:01:24.160]  это сумма от 0 до 3, сумма от 4 до 5, сумма
[01:01:24.160 --> 01:01:26.160]  от 6 элементов.
[01:01:26.160 --> 01:01:28.160]  Поэтому...
[01:01:32.160 --> 01:01:34.160]  Ну да, немножечко другую.
[01:01:36.160 --> 01:01:38.160]  Смотрите, история такая. Вот у нас
[01:01:38.160 --> 01:01:40.160]  concurrency возникает, raise
[01:01:40.160 --> 01:01:42.160]  возникает из-за того, что мы берём сумму
[01:01:42.160 --> 01:01:44.160]  3 и 4, чтобы посчитать сумму 3 и 4.
[01:01:46.160 --> 01:01:48.160]  Давайте убирать лишние стрелки.
[01:01:48.240 --> 01:01:50.240]  Оставим только 4.
[01:01:54.240 --> 01:01:56.240]  Здесь оставим 6.
[01:01:58.240 --> 01:02:00.240]  То есть будем аккумулировать сумму по степеням 2.
[01:02:06.240 --> 01:02:08.240]  Ну потому что у нас...
[01:02:08.240 --> 01:02:10.240]  Смотри, что мы делаем.
[01:02:10.240 --> 01:02:12.240]  Вот когда мы считаем
[01:02:12.240 --> 01:02:14.240]  сумму
[01:02:14.240 --> 01:02:16.240]  2,3
[01:02:16.320 --> 01:02:18.320]  и 3,4,
[01:02:18.320 --> 01:02:20.320]  что такое 3,4?
[01:02:20.320 --> 01:02:22.320]  Это сумма 3 и 4.
[01:02:22.320 --> 01:02:24.320]  Но у нас может случиться такой момент,
[01:02:24.320 --> 01:02:26.320]  что уже сумма 2 и 3 в этом моменте
[01:02:26.320 --> 01:02:28.320]  уже была посчитана.
[01:02:28.320 --> 01:02:30.320]  И поэтому мы вместо суммы
[01:02:30.320 --> 01:02:32.320]  вместо 3 элемента поставим сумму 2 и 3.
[01:02:32.320 --> 01:02:34.320]  Здесь получается 2 плюс 3 плюс 4.
[01:02:36.320 --> 01:02:38.320]  Это плохо.
[01:02:38.320 --> 01:02:40.320]  Вот.
[01:02:40.320 --> 01:02:42.320]  Поэтому смотрите, история такая.
[01:02:42.320 --> 01:02:44.320]  По степеням 2 сохраняем значение
[01:02:44.400 --> 01:02:46.400]  элементов.
[01:02:46.400 --> 01:02:48.400]  Получаем вот такую картинку.
[01:02:48.400 --> 01:02:50.400]  Тут 4.
[01:02:50.400 --> 01:02:52.400]  Тут 2.
[01:02:54.400 --> 01:02:56.400]  Тут 2.
[01:03:00.400 --> 01:03:02.400]  Это что-то похоже
[01:03:02.400 --> 01:03:04.400]  на структуру под названием дерева Фенвика.
[01:03:04.400 --> 01:03:06.400]  Если вы знакомы с такой.
[01:03:14.400 --> 01:03:16.400]  Сейчас, секунду.
[01:03:16.400 --> 01:03:18.400]  И получается, к сожалению,
[01:03:18.400 --> 01:03:20.400]  неполная сумма.
[01:03:22.400 --> 01:03:24.400]  Получается небольшой огрысток.
[01:03:24.400 --> 01:03:26.400]  А?
[01:03:26.400 --> 01:03:28.400]  4,5, 4,5.
[01:03:28.400 --> 01:03:30.400]  Они везде тут остаются.
[01:03:30.400 --> 01:03:32.400]  Да.
[01:03:32.400 --> 01:03:34.400]  Ну тут смотрите, чем недостаток
[01:03:34.400 --> 01:03:36.400]  этого алгоритма.
[01:03:36.400 --> 01:03:38.400]  Что если мы начинаем стирать что-то лишнее,
[01:03:38.400 --> 01:03:40.400]  у нас сейчас стрелочек,
[01:03:40.400 --> 01:03:42.400]  проблемы с кондиционами не будет никаких.
[01:03:42.480 --> 01:03:44.480]  Вот такая вот.
[01:03:44.480 --> 01:03:46.480]  Такой массив.
[01:03:46.480 --> 01:03:48.480]  Давайте стрелки нарисую.
[01:03:50.480 --> 01:03:52.480]  То есть,
[01:03:52.480 --> 01:03:54.480]  здесь сложение идет так.
[01:04:00.480 --> 01:04:02.480]  Здесь массив идет так.
[01:04:04.480 --> 01:04:06.480]  А здесь элементы идут так.
[01:04:08.480 --> 01:04:10.480]  Вроде проблем со стрелками теперь у нас
[01:04:10.560 --> 01:04:12.560]  не возникает.
[01:04:20.560 --> 01:04:22.560]  Да?
[01:04:22.560 --> 01:04:24.560]  Но в чем проблема у нас с вами получается?
[01:04:34.560 --> 01:04:36.560]  Не, он требует 0,1 и 2,3.
[01:04:36.640 --> 01:04:38.640]  Ну в 0,1 и 2,3 при этом мы не пишем ничего.
[01:04:40.640 --> 01:04:42.640]  То есть в эти ячейки мы ничего не пишем
[01:04:42.640 --> 01:04:44.640]  по ходу операции.
[01:04:44.640 --> 01:04:46.640]  Вот, а теперь вопрос.
[01:04:46.640 --> 01:04:48.640]  Как это собрать?
[01:04:56.640 --> 01:04:58.640]  Ну да.
[01:04:58.640 --> 01:05:00.640]  То есть смотрите, у нас получается есть
[01:05:00.640 --> 01:05:02.640]  0,01,2,0,3,4,4,5,6,0,7.
[01:05:02.720 --> 01:05:04.720]  Да, то есть с определенной степени двойки.
[01:05:06.720 --> 01:05:08.720]  Так, давайте тогда не будем обращать то,
[01:05:08.720 --> 01:05:10.720]  что на доске, а попытаемся
[01:05:10.720 --> 01:05:12.720]  с этим сделать алгоритму.
[01:05:14.720 --> 01:05:16.720]  Итак, дальше.
[01:05:20.720 --> 01:05:22.720]  Рисуем этот массив.
[01:05:22.720 --> 01:05:24.720]  Этот алгоритм двустодейный,
[01:05:24.720 --> 01:05:26.720]  если что.
[01:05:26.800 --> 01:05:28.800]  0,01.
[01:05:38.800 --> 01:05:40.800]  Давайте поймем, как посчитать сумму
[01:05:40.800 --> 01:05:42.800]  с нулевого до шестого.
[01:05:44.800 --> 01:05:46.800]  Ну, мы, кажется, это писали.
[01:05:46.800 --> 01:05:48.800]  Ну да.
[01:05:48.800 --> 01:05:50.800]  Ну да.
[01:05:50.800 --> 01:05:52.800]  Ну да.
[01:05:52.800 --> 01:05:54.800]  Ну да.
[01:05:54.880 --> 01:05:56.880]  Мы, кажется, это писали.
[01:06:00.880 --> 01:06:02.880]  Это 0,03, плюс 4,5, плюс 6.
[01:06:06.880 --> 01:06:08.880]  То есть что нам нужно сложить
[01:06:08.880 --> 01:06:10.880]  здесь, чтобы получить сумму
[01:06:10.880 --> 01:06:12.880]  от нулевого до шестого?
[01:06:12.880 --> 01:06:14.880]  Какие элементы?
[01:06:14.880 --> 01:06:16.880]  Ну да.
[01:06:16.880 --> 01:06:18.880]  Давайте подчеркнем.
[01:06:18.960 --> 01:06:20.960]  Давайте я конечную картинку нарисую,
[01:06:20.960 --> 01:06:22.960]  которая должна быть.
[01:06:22.960 --> 01:06:24.960]  Сумму элементов от нулевого
[01:06:24.960 --> 01:06:26.960]  до седьмого запомним.
[01:06:28.960 --> 01:06:30.960]  А здесь мы сделаем такую вещь.
[01:06:30.960 --> 01:06:32.960]  Как нейтральный элемент будем обозначать?
[01:06:34.960 --> 01:06:36.960]  Посложение.
[01:06:36.960 --> 01:06:38.960]  Я предлагаю его обозначить епсиловым.
[01:06:38.960 --> 01:06:40.960]  Вы не против?
[01:06:44.960 --> 01:06:46.960]  Да, е.
[01:06:47.040 --> 01:06:49.040]  Да, е.
[01:06:57.040 --> 01:06:59.040]  Так, главное, чтобы у меня
[01:06:59.040 --> 01:07:01.040]  тут сдвиг не случился.
[01:07:05.040 --> 01:07:07.040]  Вот такую историю
[01:07:07.040 --> 01:07:09.040]  мы с вами будем моделировать.
[01:07:09.120 --> 01:07:11.120]  Давайте я тут.
[01:07:19.120 --> 01:07:21.120]  Вот так вот сделаем.
[01:07:25.120 --> 01:07:27.120]  Не, не.
[01:07:27.120 --> 01:07:29.120]  Это особенность такая.
[01:07:29.120 --> 01:07:31.120]  Ну давайте думать,
[01:07:31.120 --> 01:07:33.120]  что мы можем сделать с этой штукой.
[01:07:33.120 --> 01:07:35.120]  Ну что мы можем сделать с этой штукой?
[01:07:35.200 --> 01:07:37.200]  Да.
[01:07:37.200 --> 01:07:39.200]  То есть смотрите,
[01:07:39.200 --> 01:07:41.200]  у нас
[01:07:41.200 --> 01:07:43.200]  0,3.
[01:07:43.200 --> 01:07:45.200]  Я сейчас напишу стрелочки.
[01:07:45.200 --> 01:07:47.200]  У нас 0,3 должен уйти сюда.
[01:07:47.200 --> 01:07:49.200]  4,5 должен уйти сюда.
[01:07:49.200 --> 01:07:51.200]  И 0,7, ой.
[01:07:51.200 --> 01:07:53.200]  И 6 должен уйти сюда.
[01:07:59.200 --> 01:08:01.200]  Ну вот.
[01:08:01.280 --> 01:08:03.280]  Да?
[01:08:03.280 --> 01:08:05.280]  Вопрос.
[01:08:05.280 --> 01:08:07.280]  Куда нам нужно утащить 0,3?
[01:08:07.280 --> 01:08:09.280]  В каких элементах у нас присутствует 0,3?
[01:08:17.280 --> 01:08:19.280]  В 0,3.
[01:08:21.280 --> 01:08:23.280]  Смотрите, он у нас
[01:08:23.280 --> 01:08:25.280]  во второй половине должен быть.
[01:08:25.280 --> 01:08:27.280]  Этого массива.
[01:08:27.360 --> 01:08:29.360]  А здесь 0,3 нету.
[01:08:29.360 --> 01:08:31.360]  Он нам не нужен во второй половине.
[01:08:33.360 --> 01:08:35.360]  Поэтому знаете, что делаем?
[01:08:41.360 --> 01:08:43.360]  Перетаскиваем его сюда.
[01:08:43.440 --> 01:08:45.440]  Перетаскиваем его сюда.
[01:08:53.440 --> 01:08:55.440]  Ну то есть перетачиваем его сюда,
[01:08:55.440 --> 01:08:57.440]  потому что он должен быть во второй половине.
[01:09:03.440 --> 01:09:05.440]  А здесь что у нас должен быть на замену?
[01:09:05.440 --> 01:09:07.440]  Сюда нужно поставить кандидата,
[01:09:07.440 --> 01:09:09.440]  который не содержит 0,3.
[01:09:09.520 --> 01:09:11.520]  Сюда нужно поставить кандидата,
[01:09:11.520 --> 01:09:13.520]  который не содержит 0,3.
[01:09:17.520 --> 01:09:19.520]  А давайте сюда E поставим.
[01:09:21.520 --> 01:09:23.520]  Ну типа есть 0,3, нет 0,3.
[01:09:27.520 --> 01:09:29.520]  Остальное пока оставляем.
[01:09:31.520 --> 01:09:33.520]  Тут обычно еще в классическом алгоритме
[01:09:33.520 --> 01:09:35.520]  делают вот так.
[01:09:35.520 --> 01:09:37.520]  0,7 выкидываем, вставим E и делаем замену.
[01:09:39.520 --> 01:09:41.520]  То есть меняем этот элемент
[01:09:41.520 --> 01:09:43.520]  с этими местами.
[01:09:47.520 --> 01:09:49.520]  Так, давайте дальше придумывать.
[01:09:49.520 --> 01:09:51.520]  4,5. Что нам с 4,5 нужно?
[01:09:55.520 --> 01:09:57.520]  Вот у нас тут 4,5 находится.
[01:10:01.520 --> 01:10:03.520]  Куда его нам надо отправить?
[01:10:05.520 --> 01:10:07.520]  Да, опять в правую половину отправить.
[01:10:09.520 --> 01:10:11.520]  А 0,3 где у нас должен быть?
[01:10:17.520 --> 01:10:19.520]  Да, там где четверка.
[01:10:19.520 --> 01:10:21.520]  0,3 отправляем сюда специально.
[01:10:23.520 --> 01:10:25.520]  А здесь нам уже не нужен сам 0,3
[01:10:25.520 --> 01:10:27.520]  и сам 0,4,5.
[01:10:27.520 --> 01:10:29.520]  Нам нужен 0,5.
[01:10:31.520 --> 01:10:33.520]  Поэтому здесь мы берем и складываем эту штуку.
[01:10:35.520 --> 01:10:37.520]  Ой, 0,5.
[01:10:37.600 --> 01:10:39.600]  Здесь аналогичная картинка будет.
[01:10:53.600 --> 01:10:55.600]  То есть такой перекрестный алгоритм получается.
[01:11:01.600 --> 01:11:03.600]  Здесь получается 0,5.
[01:11:03.680 --> 01:11:05.680]  Здесь получается 4.
[01:11:07.680 --> 01:11:09.680]  И здесь идет сложение.
[01:11:13.680 --> 01:11:15.680]  Понятно?
[01:11:17.680 --> 01:11:19.680]  То есть 2 стадии на алгоритм.
[01:11:19.680 --> 01:11:21.680]  Первым мы собираем сумму по степеням 2,
[01:11:21.680 --> 01:11:23.680]  во втором мы их перекидываем.
[01:11:27.680 --> 01:11:29.680]  Так, что как думаете?
[01:11:29.680 --> 01:11:31.680]  Проектор завершен.
[01:11:31.760 --> 01:11:33.760]  Я честно не знаю.
[01:11:33.760 --> 01:11:35.760]  Надо посмотреть.
[01:11:37.760 --> 01:11:39.760]  Вот.
[01:11:39.760 --> 01:11:41.760]  Давайте я сейчас пытаюсь подключиться еще раз.
[01:11:51.760 --> 01:11:53.760]  Я надеюсь, он подрубится.
[01:11:53.760 --> 01:11:55.760]  Опять же тут проблемы с варпами идут.
[01:11:55.840 --> 01:11:57.840]  Смотрите.
[01:11:57.840 --> 01:11:59.840]  Сначала сумма по степеням.
[01:12:01.040 --> 01:12:04.400]  Нулевой поток вычисляет сумму нулевой и первого элемента.
[01:12:07.400 --> 01:12:09.820]  Нулевой поток потом будет вычислять сумму первого и третьего элемента.
[01:12:09.820 --> 01:12:11.820]  Ну, он берет элемент 1 и берет элемент 3.
[01:12:13.820 --> 01:12:18.120]  Нулевой поток будет вычислять сумму третьего, третьего, poner и зайittle www.
[01:12:18.120 --> 01:12:20.120]  Не advantить yarn,
[01:12:20.120 --> 01:12:22.120]  это залово.
[01:12:22.120 --> 01:12:24.120]  Но вы Hmntămat all the same
[01:12:24.120 --> 01:12:28.120]  Нолевой поток будет вычислять сумму третьего и седьмого элемента.
[01:12:28.120 --> 01:12:31.120]  Согласны?
[01:12:31.120 --> 01:12:33.120]  Опять же по картинке.
[01:12:33.120 --> 01:12:38.120]  То есть нолевой поток будет вычислять сумму вот этого и вот этого элемента.
[01:12:38.120 --> 01:12:42.120]  Нолевой поток вычисляет сумму седьмого и пятнадцатого.
[01:12:42.120 --> 01:12:46.120]  Пятнадцатого и тридцать первого.
[01:12:46.120 --> 01:12:50.120]  Пятнадцатый поток будет вычислять в этот момент сумму 32-го и 33-го потока.
[01:12:56.120 --> 01:13:00.120]  Ой, что я пишу? Почему 32-го и 33-го?
[01:13:02.120 --> 01:13:05.120]  Скажите, где баг.
[01:13:05.120 --> 01:13:07.120]  А, нет.
[01:13:07.120 --> 01:13:13.120]  Шестнадцатый поток в нулевой операции будет складывать сумму 32-го и 33-го элемента.
[01:13:13.120 --> 01:13:15.120]  Да, то есть пример.
[01:13:15.120 --> 01:13:23.120]  То есть у нас где-то в той истории возникает поток 32-го и 33-го, мы их складываем.
[01:13:27.120 --> 01:13:29.120]  Видите проблему?
[01:13:31.120 --> 01:13:33.120]  Что это проблема?
[01:13:35.120 --> 01:13:37.120]  Опять конфликт. У нас нолевой поток.
[01:13:37.120 --> 01:13:39.120]  Здесь это нолевой поток, здесь это шестнадцатый поток.
[01:13:39.120 --> 01:13:43.120]  Они внутри одного вакпана находятся и конфликтует по нулевому элементу.
[01:13:43.120 --> 01:13:45.120]  Это первый конфликт.
[01:13:45.120 --> 01:13:49.120]  Чем дальше мы поднимемся, тем шире конфликт.
[01:13:49.120 --> 01:13:53.120]  Потому что у нас количество повторяющих элементов будет все еще больше и больше и больше.
[01:13:57.120 --> 01:13:59.120]  Очень много банков конфликтов.
[01:13:59.120 --> 01:14:01.120]  Как будем разрешать их?
[01:14:03.120 --> 01:14:05.120]  Не, здесь не получится.
[01:14:05.120 --> 01:14:07.120]  Здесь история очень жесткая, сейчас попытаюсь рассказать.
[01:14:07.120 --> 01:14:09.120]  Делаем паддинг.
[01:14:11.120 --> 01:14:13.120]  Мы еще позже начали.
[01:14:13.120 --> 01:14:15.120]  У вас пара есть дальше?
[01:14:17.120 --> 01:14:19.120]  Дайте, я сейчас попытаюсь рассказать эту историю.
[01:14:19.120 --> 01:14:21.120]  Делаем паддинг.
[01:14:23.120 --> 01:14:25.120]  В чем он заключается?
[01:14:27.120 --> 01:14:29.120]  Он заключается в том, что вы делаете 25-й кадр.
[01:14:31.120 --> 01:14:33.120]  Кто знает, что такое 25-й кадр?
[01:14:33.120 --> 01:14:35.120]  Вставка какая-то не нужная.
[01:14:35.120 --> 01:14:37.120]  Вставка ненужная.
[01:14:37.120 --> 01:14:41.120]  Вы берете и каждый 32-й элемент вставляете ненужный.
[01:14:41.120 --> 01:14:45.120]  Давайте сейчас я попытаюсь на картинке нарисовать это.
[01:14:45.120 --> 01:14:49.120]  И тогда конфликты пропадут, но не все.
[01:14:53.120 --> 01:14:55.120]  Давайте на той картинке разберем.
[01:14:55.120 --> 01:14:57.120]  Смотрите.
[01:14:57.120 --> 01:15:01.120]  Делаем 0, 1, 2, 3.
[01:15:01.120 --> 01:15:03.120]  31.
[01:15:03.120 --> 01:15:05.120]  Дальше идет фигня.
[01:15:07.120 --> 01:15:09.120]  32.
[01:15:09.120 --> 01:15:11.120]  33.
[01:15:11.120 --> 01:15:13.120]  34.
[01:15:13.120 --> 01:15:15.120]  35.
[01:15:15.120 --> 01:15:17.120]  36.
[01:15:17.120 --> 01:15:19.120]  37.
[01:15:19.120 --> 01:15:21.120]  38.
[01:15:21.120 --> 01:15:23.120]  39.
[01:15:23.120 --> 01:15:25.120]  32.
[01:15:25.120 --> 01:15:27.120]  33.
[01:15:27.120 --> 01:15:29.120]  60.
[01:15:29.120 --> 01:15:31.120]  Сколько?
[01:15:31.120 --> 01:15:33.120]  3.
[01:15:33.120 --> 01:15:35.120]  Фигня.
[01:15:35.120 --> 01:15:37.120]  64.
[01:15:37.120 --> 01:15:41.120]  Причем позицию элементов нам нужно тоже сохранять.
[01:15:43.120 --> 01:15:45.120]  0, 1, 2, 3.
[01:15:45.120 --> 01:15:47.120]  31.
[01:15:47.120 --> 01:15:51.120]  Этот элемент у нас будет 32, 33, 34.
[01:15:51.120 --> 01:15:53.120]  64 будет...
[01:15:55.120 --> 01:15:57.120]  Вот так.
[01:15:57.120 --> 01:15:59.120]  Это элементы массива.
[01:15:59.120 --> 01:16:01.120]  Тогда вопрос.
[01:16:01.120 --> 01:16:05.120]  Нулевой элемент будет складывать первое.
[01:16:05.120 --> 01:16:07.120]  Сумма нулевого и первого.
[01:16:11.120 --> 01:16:13.120]  Айдишники будут такие же.
[01:16:13.120 --> 01:16:15.120]  16-й поток.
[01:16:15.120 --> 01:16:17.120]  Сумму каких элементов будет складывать?
[01:16:21.120 --> 01:16:23.120]  Он будет складывать 32 плюс 33.
[01:16:23.120 --> 01:16:25.120]  Но в каких айдишниках он находится?
[01:16:29.120 --> 01:16:31.120]  Не-не-не.
[01:16:31.120 --> 01:16:33.120]  33, 34.
[01:16:37.120 --> 01:16:39.120]  По модулю 32
[01:16:41.120 --> 01:16:43.120]  они начинают отличаться.
[01:16:43.120 --> 01:16:45.120]  Они начинают отличаться.
[01:16:47.120 --> 01:16:49.120]  Мы избегаем конфликта.
[01:16:53.120 --> 01:16:57.120]  То есть мы специально делаем сдвиг, чтобы избежать этого конфликта.
[01:17:01.120 --> 01:17:03.120]  Да, ну вот в коде вы посмотрите, как это делать.
[01:17:07.120 --> 01:17:09.120]  Нет, смотрите.
[01:17:09.120 --> 01:17:13.120]  Мы смотрим на варп-конфликты внутри одной регистровой операции.
[01:17:13.120 --> 01:17:15.120]  То есть загрузку из регистра.
[01:17:19.120 --> 01:17:21.120]  То есть вот эта одна операция у нас выполняется внутри варп.
[01:17:21.120 --> 01:17:23.120]  То есть внутри этой операции нужно смотреть,
[01:17:23.120 --> 01:17:25.120]  если конфликт нет.
[01:17:25.120 --> 01:17:27.120]  И внутри этой операции мы смотрим, если конфликт нет.
[01:17:31.120 --> 01:17:35.120]  И дальше можно посмотреть историю, что если добавлять паддинги
[01:17:35.120 --> 01:17:37.120]  раз в 32.
[01:17:37.120 --> 01:17:43.680]  раз 32, то эта вся история будет отрабатывать так же. Мы избавимся от большей части банк
[01:17:43.680 --> 01:17:50.640]  конфликтов, к сожалению от всех не избавимся. Там по-моему еще каждый какой-то кадр нужно будет
[01:17:50.640 --> 01:17:56.000]  еще один конфликт, padding добавлять, мусор, и тогда это будет у нас с вами работать.
[01:17:56.000 --> 01:18:11.520]  Так, тут история как это еще можно посчитать. Давайте разберем. Смотрите, замечаем, что, как
[01:18:11.520 --> 01:18:20.480]  вообще типа костыльнуть эта история. Замечаем, что 1024 это 32 на 32. 1024 это максимальный размер блока.
[01:18:20.480 --> 01:18:33.440]  История такая, что внутри регистровых операций у нас ворб конфликтов особо не возникает. Поэтому
[01:18:33.440 --> 01:18:40.840]  мы берем, считаем по сути один раз сумму внутри регистров, да, вот с операциями shuffle up sync,
[01:18:40.840 --> 01:18:48.000]  вот, вот shuffle up sync, а потом еще второй раз выполняем функцию операции shuffle up sync,
[01:18:48.000 --> 01:18:53.440]  и в итоге у нас получается пирамидка, 2 стадины обработка. Сначала каждые 32 складываем,
[01:18:53.440 --> 01:19:07.280]  потом еще каждые 32, внутри 32 эти 32. Вот, ну да, она уже пропала, но я думаю, что это,
[01:19:07.280 --> 01:19:15.840]  мы можем закончить на этом. К сожалению, мы не посмотрели quicksort, как работает, но в качестве
[01:19:15.840 --> 01:19:24.040]  заданий я скажу, что при помощи операции скана можно делать операцию фильтрации. Там, по сути,
[01:19:24.040 --> 01:19:30.480]  нужно сделать так, вы те элементы, которые подходят под условия, отмечаете единичками, те элементы,
[01:19:30.480 --> 01:19:35.880]  которые не подходят под условия, отмечаете нолькой. Дальше считаете сумму на массиве, сумму на префексе,
[01:19:35.880 --> 01:19:40.760]  как раз вы получаете айдишники тех элементов, которые вам нужно вычешивать. То есть, это не
[01:19:40.760 --> 01:20:02.480]  сложная вещь. А quicksort это что, по сути? Как quicksort реализуется? Ну да, а теперь мы умеем
[01:20:02.480 --> 01:20:10.600]  получать все элементы меньше такого, все элементы больше такого. Запускаем два ядра и делаем это
[01:20:10.600 --> 01:20:17.600]  рекурсивно. К сожалению, это вкратце. Извините, что я вас задержал. Вроде бы мы посмотрели так или
[01:20:17.600 --> 01:20:24.240]  иначе все, что связано с теоретической кудой. Практическую куду обычно уже никто не реализует,
[01:20:24.240 --> 01:20:29.760]  а просто используют в библиотеке, которую NVIDIA дает. Там есть особенность реализации. Я думаю,
[01:20:29.760 --> 01:20:36.600]  если что, можете поморожить семинаристов или меня в чате по поводу применения, я там что-нибудь
[01:20:36.600 --> 01:20:48.000]  покидаю. Ну все, всем спасибо тогда. Дальше вроде буду вести уже не я, а лекции. В следующей
[01:20:48.000 --> 01:20:54.760]  лекции уже будет вести Олег. И там будет уже распределенная часть. А параллельную часть,
[01:20:54.760 --> 01:21:04.920]  по сути, мы с вами закончили. Осталось это все распрактиковать и добить. Давайте вопросы задавайте,
[01:21:04.920 --> 01:21:14.280]  если есть. Там презентацию я выложил, там есть некоторый обзор библиотек на видеокарте,
[01:21:14.280 --> 01:21:23.480]  которую использовать. Вот ее может будет посмотреть. Усё. Да, спасибо, спасибо.
[01:21:44.280 --> 01:22:01.240]  Ура!
