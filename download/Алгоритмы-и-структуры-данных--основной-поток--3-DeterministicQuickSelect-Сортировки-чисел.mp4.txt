[00:00.000 --> 00:07.600]  Напомним, мы в прошлый раз обсудили, как писать
[00:07.600 --> 00:10.840]  быструю сортировку, но давайте очень быстро напомним, как
[00:10.840 --> 00:11.840]  это делается.
[00:11.840 --> 00:14.760]  Есть массив, мы выбираем случайно его элемент в
[00:14.760 --> 00:15.760]  качестве пилота.
[00:15.760 --> 00:18.320]  Напоминаю, выбирается он именно случайно, равновероятно
[00:18.320 --> 00:20.640]  среди всех возможных элементов массива.
[00:20.640 --> 00:23.560]  Дальше в идеале, ну и точнее на самом деле, как мы и будем
[00:23.560 --> 00:26.540]  делать, мы разбиваем наш массив с помощью процедуры
[00:26.540 --> 00:32.660]  partition на три куска, сначала идут элементы меньше x, затем
[00:32.660 --> 00:35.180]  элементы равны x, затем элементы больше x.
[00:35.180 --> 00:38.060]  Я на прошлой лекции показал, как разбить на два куска,
[00:38.060 --> 00:41.460]  что сначала меньше, потом больше либо равное, ну можно
[00:41.460 --> 00:44.300]  там еще раз, еще одним циклом пройтись и сначала записать
[00:44.300 --> 00:47.440]  вот из этого блока, выделить все x, написать их сюда, потом
[00:47.440 --> 00:48.440]  оставить все больше.
[00:48.440 --> 00:51.180]  То есть, грубо говоря, это мы все-таки предполагаем,
[00:51.180 --> 00:52.180]  что ровно так мы массив разбиваем.
[00:53.180 --> 00:58.300]  Ну и дальше рекурсивно сортируем вот эти вот два кусочка, да,
[00:58.300 --> 01:00.260]  те кто меньше x, а те кто больше x, а просто рекурсивно
[01:00.260 --> 01:01.980]  сортируем и в результате получается сортированный
[01:01.980 --> 01:02.980]  массив.
[01:02.980 --> 01:07.060]  Вот это была быстрая сортировка.
[01:07.060 --> 01:10.060]  Quick sort.
[01:10.060 --> 01:16.860]  Теперь давайте посмотрим алгоритм quick select.
[01:16.940 --> 01:17.940]  Сначала определение ввиду.
[01:17.940 --> 01:27.420]  Значит пусть a1, a2 и так далее, an массив, давайте массив
[01:27.420 --> 01:42.340]  чисел пусть будет, пусть b1, b2 и так далее bn его отсортированная
[01:42.340 --> 01:43.340]  версия.
[01:47.860 --> 01:51.860]  А то есть, какой массив будет после сортировки.
[01:51.860 --> 01:55.660]  То есть, мульти множество чисел здесь такое же как
[01:55.660 --> 01:58.460]  здесь, только они расположены в прядке возрастания.
[01:58.460 --> 02:06.900]  Значит тогда через a с нижним индексом в скобочках i я буду
[02:06.900 --> 02:13.300]  обозначать bt, то есть тот элемент, который после
[02:13.300 --> 02:19.300]  сортировки стал бы item, а с нижним индексом круглые
[02:19.300 --> 02:20.300]  скобочки i.
[02:20.300 --> 02:22.820]  Это, собственно, то самое bi, которое было бы на этом
[02:22.820 --> 02:26.460]  месте после сортировки, и я называю это it-порядковой
[02:26.460 --> 02:29.460]  статистикой.
[02:29.460 --> 02:36.860]  Называем it-порядковой статистикой.
[02:36.860 --> 02:46.540]  Вот, очень простое определение, а с нижним индексом i в скобочках
[02:46.540 --> 02:48.620]  это то число, которое после сортировки было бы на этом
[02:48.620 --> 02:50.860]  месте, если бы мы посортировали.
[02:50.860 --> 02:51.860]  Очень простое определение.
[02:51.860 --> 02:59.740]  Ну и задача, по массиву, исходному вот этих ашек,
[02:59.740 --> 03:04.060]  найти катую порядковую статистику, желательно без сортировки.
[03:05.060 --> 03:13.340]  Значит, по массиву и числу k найти а с нижним индексом
[03:13.340 --> 03:17.180]  k в скобочках, то есть катую порядковую статистику.
[03:17.180 --> 03:24.060]  Ну понятно, можно было бы просто сортировать массив
[03:24.060 --> 03:26.860]  и вывести катый элемент, но это как-то слишком скучно.
[03:26.860 --> 03:33.940]  Вот, давайте мы бахнем алгоритм Quick Select, который сделает
[03:33.940 --> 03:36.940]  нашу задачу за линейное время в среднем.
[03:36.940 --> 03:47.620]  Алгоритм, собственно, Quick Select, реализуется очень похоже
[03:47.620 --> 03:50.140]  на Quick Sort.
[03:50.140 --> 03:51.700]  Начало идентичное.
[03:51.700 --> 04:02.060]  Давайте мы выберем случайный пивот, вот у меня есть массив,
[04:02.060 --> 04:07.260]  я выбираю в нем случайный элемент x, случайный пивот,
[04:07.260 --> 04:12.380]  произвожу процедуру partition, ну и после нее мой массив
[04:12.380 --> 04:14.540]  опять-таки разбивается на три куска.
[04:14.540 --> 04:17.500]  Элементы меньше x, элементы равны x, элементы больше
[04:17.500 --> 04:18.500]  x.
[04:18.500 --> 04:21.900]  Давайте я обозначу количество элементов меньше, чем x через
[04:21.900 --> 04:22.900]  a.
[04:22.900 --> 04:25.740]  Так, ну а плохо, а все-таки занято у меня массивом,
[04:25.740 --> 04:28.860]  ну давайте какой-нибудь пусть будет b, ладно.
[04:28.860 --> 04:31.860]  Значит, здесь будет b элементов меньше, чем x, c элементов
[04:31.860 --> 04:34.460]  равных x и d элементов больше, чем x.
[04:34.460 --> 04:41.460]  Тогда, ну смотрите, замечание первое.
[04:41.460 --> 04:46.100]  Если k меньше либо равно, чем b, то нам достаточно
[04:46.100 --> 04:48.580]  рекурсивно запуститься вот от этого кусочка и искать
[04:48.580 --> 04:51.140]  катую порядковую статистику.
[04:51.140 --> 04:54.740]  Ну потому что понятно, что после сортировки вот этого
[04:54.740 --> 04:57.580]  массива у меня здесь как-то переставятся элементы,
[04:57.740 --> 04:59.900]  все эти x останутся на месте, и здесь внутри этого блока
[04:59.900 --> 05:02.460]  тоже как-то переставятся элементы, поэтому если
[05:02.460 --> 05:05.840]  k не больше чем b, то катая порядковая статистика останется
[05:05.840 --> 05:08.500]  внутри вот этого блока, ну и она сохранится у номера
[05:08.500 --> 05:09.500]  k.
[05:09.500 --> 05:14.420]  Значит, мне достаточно запустить Quick Select на вот этом вот первом
[05:14.420 --> 05:15.420]  блоке с параметром k.
[05:15.420 --> 05:22.660]  Так, давайте я это назову как-нибудь a1, a2, a3, три куска
[05:22.660 --> 05:23.660]  моего массива.
[05:23.780 --> 05:29.060]  Значит, тогда пишу, запускаю Quick Select на первом куске
[05:29.060 --> 05:32.180]  нашего массива, то есть на a1, с тем же самым параметром
[05:32.180 --> 05:33.180]  k.
[05:33.180 --> 05:36.580]  Вот, то есть у меня, ну как бы я сузился на этот массив
[05:36.580 --> 05:38.580]  и еще опять катую статистику.
[05:38.580 --> 05:39.580]  Вроде верно.
[05:39.580 --> 05:44.460]  Дальше, иначе, если внезапно k попало вот сюда, то есть
[05:44.460 --> 05:49.340]  k больше чем b, но не больше чем b плюс c, если выполняется
[05:49.340 --> 05:53.500]  вот такое вот неравенство, тогда скажите, пожалуйста,
[05:53.500 --> 05:55.380]  чему равен ответ?
[05:55.380 --> 05:56.380]  Конечно.
[05:56.380 --> 06:03.700]  А потому что, если k вот здесь, то после сортировки
[06:03.700 --> 06:06.940]  k-та статистика будет вот здесь, внутри этого блока,
[06:06.940 --> 06:07.940]  поэтому ответ равен x.
[06:07.940 --> 06:14.220]  Ну и последний случай, если k больше чем b плюс c внезапно,
[06:14.220 --> 06:16.940]  то ясное дело, нужно искать статистику вот здесь, потому
[06:16.940 --> 06:19.700]  что даже несмотря на перестановки, которые получаются здесь
[06:19.700 --> 06:22.620]  после сортировки, здесь будет b элементов, здесь будет
[06:22.620 --> 06:26.020]  c элементов, а элемент с таким номером останется
[06:26.020 --> 06:27.940]  внутри вот этого блока.
[06:27.940 --> 06:29.420]  Поэтому его достаточно искать здесь.
[06:29.420 --> 06:34.940]  Значит, я могу рекурсивно запустить процедуру quickselect
[06:34.940 --> 06:39.180]  на вот этом третьем блоке, но здесь нужно немножко
[06:39.180 --> 06:42.180]  аккуратнее написать, потому что мне уже внутри этого
[06:42.180 --> 06:46.300]  блока нужна не k-та статистика, а какая?
[06:46.300 --> 06:49.300]  k-b-c-t, спасибо.
[06:49.300 --> 06:52.220]  Потому что, какая у меня номерация, раз, два, три,
[06:52.220 --> 06:56.580]  и так далее, b, b плюс 1, и так далее, b плюс c, но поскольку
[06:56.580 --> 06:59.140]  я эти два блока сразу отбросил, я понимаю, что мой ответ
[06:59.140 --> 07:01.900]  не там, он где-то вот здесь вот.
[07:01.900 --> 07:04.860]  Ну, значит, его номер я уменьшу на b плюс c, потому
[07:04.860 --> 07:08.020]  что я вот этот кусок отбросил, вот эти два куска отбросил.
[07:08.020 --> 07:10.740]  Значит, мне достаточно искать ответ вот здесь вот, только
[07:10.740 --> 07:12.740]  у него номер теперь будет k-b-c.
[07:12.740 --> 07:14.740]  Здесь алгоритм.
[07:14.740 --> 07:28.380]  Ну, я могу только повторить.
[07:28.380 --> 07:29.380]  Партишн понятно, что сделал?
[07:29.380 --> 07:36.900]  Да, ну, обычный партишн, разделили массив на три
[07:36.900 --> 07:37.900]  куска.
[07:37.900 --> 07:40.180]  Дальше, пусть b, c, d, это размер этих кусков.
[07:40.180 --> 07:44.740]  Если k не больше, чем b, то ответ вот здесь, в первом
[07:44.740 --> 07:45.740]  блоке.
[07:45.740 --> 07:49.340]  Значит, мне достаточно запуститься рекурсивной процедурой
[07:49.340 --> 07:52.020]  и искать катую порядковую статистику вот в этом блоке.
[07:52.020 --> 07:56.340]  Ну, потому что после сортировки катое число останется вот
[07:56.340 --> 07:57.340]  здесь вот.
[07:57.340 --> 07:59.980]  У меня вот эти как-то переставятся после сортировки.
[07:59.980 --> 08:02.140]  Эти останутся на месте, эти как-то переставятся
[08:02.140 --> 08:03.420]  внутри своего блока.
[08:03.420 --> 08:05.220]  Значит, катое останется здесь.
[08:05.220 --> 08:07.420]  Поэтому мне нужно искать ответ не во всем массиве,
[08:07.420 --> 08:10.300]  а только здесь, с номером k.
[08:10.300 --> 08:11.300]  Вот.
[08:11.300 --> 08:15.140]  Если k внезапно попало вот сюда, от b плюс 1 до b плюс
[08:15.140 --> 08:17.140]  c, то ответ это x.
[08:17.140 --> 08:18.820]  Потому что у меня будет первая, вторая и так далее
[08:18.820 --> 08:23.060]  бета-статистика здесь, с b плюс 1 по b плюс c здесь.
[08:23.060 --> 08:24.060]  Поэтому надо вернуть x.
[08:24.060 --> 08:28.620]  Если же k больше, чем b плюс c, то есть попадает в третий
[08:28.620 --> 08:30.780]  блок, то мне нужно искать ответ в третьем блоке,
[08:30.780 --> 08:33.900]  вот с таким индексом, ну, потому что мне нужна статистика
[08:33.900 --> 08:35.700]  с номером k во всем массиве.
[08:35.780 --> 08:38.540]  Но после удаления первых двух блоков, его номер уменьшается
[08:38.540 --> 08:39.540]  на b плюс c.
[08:39.540 --> 08:42.420]  Получается, что мне нужно в этом массиве, вот в этом
[08:42.420 --> 08:44.700]  третьем блоке найти статистику с таким номером.
[08:44.700 --> 08:49.700]  Мы же ищем номер, правильно?
[08:49.700 --> 08:50.700]  Мы ищем значение.
[08:50.700 --> 08:55.540]  Вот как я здесь x возвращаю число, вот найти a с индексом
[08:55.540 --> 08:58.620]  k, то есть найти значение, которое было бы на k-том месте
[08:58.620 --> 08:59.620]  после сортировки.
[08:59.620 --> 09:00.620]  Вот.
[09:00.620 --> 09:03.620]  Вопросы есть по алгоритму?
[09:04.540 --> 09:07.540]  Почему мы не обладаем достаточным арсеналом?
[09:07.540 --> 09:08.540]  Что?
[09:08.540 --> 09:09.540]  Почему мы не обладаем достаточным арсеналом?
[09:09.540 --> 09:12.540]  Ну, вот это утверждение, которое я пока не обладаю,
[09:12.540 --> 09:17.420]  для которого мы пока не обладаем достаточным арсеналом
[09:17.420 --> 09:19.540]  доказательств, потому что здесь какой-то тярвер.
[09:19.540 --> 09:23.140]  У меня там происходит какой-то случайный выбор пивота.
[09:23.140 --> 09:26.460]  Мне хотелось бы как-нибудь доказать, сколько в среднем
[09:26.460 --> 09:28.140]  операций я сделаю.
[09:28.140 --> 09:30.740]  Ну, идея на самом деле следующая, если вам интересно,
[09:30.740 --> 09:31.740]  как это доказывается.
[09:31.740 --> 09:32.740]  Идея в следующем.
[09:32.740 --> 09:37.580]  Нужно просто сравнить, сколько раз между собой сравняются
[09:37.580 --> 09:41.020]  вот такие два числа.
[09:41.020 --> 09:43.260]  Потому что, когда вообще два числа сравниваются
[09:43.260 --> 09:46.860]  вот в процессе нашего алгоритма, сравнение чисел внутри
[09:46.860 --> 09:49.460]  массива происходит только во время партишна.
[09:49.460 --> 09:53.340]  Когда я выбираю случайный пивот, случайный х, и делаю
[09:53.340 --> 09:55.580]  партишн только в это время, у меня все элементы сравнятся
[09:55.580 --> 09:56.580]  с х.
[09:56.580 --> 10:00.100]  Ну и понятно более-менее, что время работы алгоритма
[10:00.140 --> 10:02.300]  пропорционально к количеству сравнений, которые делает
[10:02.300 --> 10:03.300]  ваш алгоритм.
[10:03.300 --> 10:05.780]  Потому что здесь сложность только в партишне.
[10:05.780 --> 10:09.340]  Я сделал партишн за линию от массива, потом развивал
[10:09.340 --> 10:13.940]  три случая и перехожу рекурсивно в одну из двух частей.
[10:13.940 --> 10:17.860]  Поэтому время работы практически в точности равно числу сравнений,
[10:17.860 --> 10:20.380]  которые делает ваш алгоритм.
[10:20.380 --> 10:23.240]  Ну и затем нужно просто оценить, с какой вероятностью
[10:23.240 --> 10:26.140]  два числа, которые стояли бы на итом и нажитом месте
[10:26.140 --> 10:29.040]  в массиве после сортировки, с какой вероятностью они
[10:29.040 --> 10:30.040]  сравняются.
[10:30.040 --> 10:31.920]  Вот с какой вероятностью эти числа сравняются?
[10:31.920 --> 10:34.120]  Ну видимо, для этого вам нужно, чтобы вот эти вот
[10:34.120 --> 10:39.440]  числа между ними никогда пивотами не были.
[10:39.440 --> 10:40.440]  Как минимум.
[10:40.440 --> 10:42.760]  Потому что если кто-то из них, вот какой-то х отсюда
[10:42.760 --> 10:45.680]  побывал бы пивотом, то значит аи и ажи уже между собой
[10:45.680 --> 10:47.680]  сравниться не могли бы, потому что я бы их сначала
[10:47.680 --> 10:51.840]  посплитил с х, ну то есть я бы сравнил сначала их
[10:51.840 --> 10:55.480]  с х, они бы пошли в разные стороны, один скажем сюда,
[10:55.480 --> 10:59.640]  другой сюда, но я бы их уже между собой не сравнивал.
[10:59.640 --> 11:01.520]  Ну и отсюда можно заключить, что вероятность того, что
[11:01.520 --> 11:07.520]  два конкретных числа сравняться, это что-то в стиле, ну вот
[11:07.520 --> 11:11.360]  такое видимо.
[11:11.360 --> 11:13.160]  Потому что первый пивот, который выбирается на этом
[11:13.160 --> 11:17.040]  отрезке должен быть этот или этот, но не один из них.
[11:17.040 --> 11:18.640]  Ну и дальше если сложить, то как раз получится что
[11:18.640 --> 11:19.640]  надо.
[11:19.640 --> 11:22.120]  Идея примерно такая, но разворачивать не буду,
[11:22.200 --> 11:26.400]  потому что как бы у нас нет тервера пока еще.
[11:26.400 --> 11:27.400]  Такие дела.
[11:27.400 --> 11:32.960]  Значит, утверждение без заказательства, этот алгоритм
[11:32.960 --> 11:48.520]  работает за УАТН в среднем, то есть мат ожидания времени
[11:48.520 --> 12:04.960]  на массиве длины n есть УАТН.
[12:04.960 --> 12:14.480]  Другая задача, сортировка, а у нас все-таки не сортировка,
[12:14.480 --> 12:15.480]  а поиск одного значения.
[12:16.440 --> 12:32.120]  В идеале, представьте себе, я каждый раз выбираю внезапно
[12:32.120 --> 12:34.000]  средний элемент, то есть тот элемент, который после
[12:34.000 --> 12:37.400]  сортировки был бы центральным, тогда у меня будет вот где-то
[12:37.400 --> 12:40.240]  х в середине, массив разбился примерно на два равных
[12:40.240 --> 12:42.880]  куска, я запускаю скажем от одного из них, причем
[12:42.880 --> 12:47.440]  здесь я потратил примерно n операции, согласны?
[12:47.440 --> 12:50.440]  Чтобы сделать этот partition, я трачу примерно n действий,
[12:50.440 --> 12:51.440]  примерно n сравнений.
[12:51.440 --> 12:54.240]  Дальше я запускаюсь рекурсивно от вот этой половинки.
[12:54.240 --> 12:55.240]  Сколько здесь элементов?
[12:55.240 --> 12:57.600]  Ну примерно n пополам, то есть я оставляю только
[12:57.600 --> 13:03.400]  этот массив, длины n пополам, в нем опять как-то волшебным
[13:03.400 --> 13:06.840]  образом выбрал элемент примерно срединный, сделал
[13:06.840 --> 13:11.440]  по нему partition, и это заняло у меня время примерно n пополам.
[13:11.440 --> 13:15.120]  И потом опять перехожу в какой-то из двух блоков,
[13:15.120 --> 13:17.280]  ну и так далее, размер каждый раз уменьшается в два раза,
[13:17.280 --> 13:19.320]  это вот прям идеальный случай, если каждый раз внезапно
[13:19.320 --> 13:22.720]  получается ткнуть ровно вот в этот центральный элемент.
[13:22.720 --> 13:27.720]  Ну и эта сумма, да, вот эта вот сумма таких дробей сходится
[13:27.720 --> 13:40.800]  к двум n, это линия как раз от m, да, нет-нет-нет, звездочка
[13:40.800 --> 13:43.760]  еще это амортизация, по крайней мере, в моих обозначениях.
[13:43.760 --> 13:47.920]  Я так и буду писать oatn в среднем, звездочку пока
[13:47.920 --> 13:48.920]  не использую.
[13:48.920 --> 13:52.480]  Не знаю, возможно в каких-то других источниках так, но
[13:52.480 --> 13:55.980]  мне кажется, что обычно подписывают, то есть в среднем
[13:55.980 --> 13:58.000]  или там амортизировано, обычно это всегда пишут
[13:58.000 --> 14:01.640]  словами, поэтому я пока этих сокращений не использую.
[14:01.640 --> 14:04.920]  Ну хорошо, какая-то магия утверждает, что она работает
[14:05.920 --> 14:12.080]  А давайте сделаем алгоритм на базе вот этого всего,
[14:12.080 --> 14:16.720]  который работает гарантированно за oatn, ищет катую порядковую
[14:16.720 --> 14:19.000]  статистику, и мы докажем, почему он работает за линейное
[14:19.000 --> 14:20.000]  время.
[14:20.000 --> 14:22.200]  Ну и, соответственно, это нам тогда можно было бы
[14:22.200 --> 14:23.200]  и не доказывать.
[14:23.200 --> 14:30.240]  Ну вот, справедливо, если у нас действительно массив
[14:30.240 --> 14:34.760]  чисел, да, а если числа очень большие, ну что-нибудь
[14:34.760 --> 14:35.760]  такое.
[14:35.760 --> 14:39.800]  Вот, давайте мы сделаем то, что называется детерминированный
[14:39.800 --> 14:56.040]  quick-select, детерминированный quick-select, сейчас попрошу
[14:56.040 --> 14:57.720]  быть очень внимательными, сейчас будет очень много
[14:57.720 --> 14:59.320]  индексов, в которых надо не запутаться.
[14:59.320 --> 15:04.120]  Как работает алгоритм?
[15:04.120 --> 15:06.640]  Опять, задача та же, есть массив длины n, надо найти
[15:06.640 --> 15:09.120]  катую статистику, катую порядковую статистику.
[15:09.120 --> 15:16.000]  Я сделаю следующую магию, я разобью весь мой массив
[15:16.000 --> 15:20.800]  длины n на блоке из пяти элементов, первые пять
[15:20.800 --> 15:23.320]  элементов, еще пять элементов, еще пять элементов и так
[15:23.320 --> 15:24.320]  далее.
[15:24.320 --> 15:27.960]  Ну, если он не делится на пять, то последний блок
[15:27.960 --> 15:32.400]  будет не целый, неважно, хочу, могу дополнить m какими-то
[15:32.400 --> 15:35.280]  элементами бесконечностями вот здесь, вот тогда все
[15:35.280 --> 15:37.120]  будет делиться на пять, если надо, можно считать, что
[15:37.120 --> 15:39.080]  он делится на пять, если не надо, то последний блок
[15:39.080 --> 15:40.080]  просто не полный.
[15:40.080 --> 15:45.520]  Дальше сделаю следующее, я в каждом блоке найду медиану,
[15:46.240 --> 15:57.480]  на всякий случай дам, медианой массива из n элементов называется
[15:57.480 --> 16:07.560]  а с нижним индексом, ой, сейчас скажу, n пополам пойдет
[16:07.560 --> 16:12.360]  не пойдет вверх, если округлить, то пойдет, вот так вот хочу,
[16:12.440 --> 16:18.560]  n пополам округлить вверх, вот, это просто вот как раз
[16:18.560 --> 16:21.160]  та самая центральная статистика, если я церстирую, что будет
[16:21.160 --> 16:24.000]  на центральном месте, какой элемент будет в самом центре,
[16:24.000 --> 16:26.040]  и, например, если у меня массив из пяти элементов,
[16:26.040 --> 16:27.680]  а у меня сейчас все вот эти маленькие блоки будут
[16:27.680 --> 16:30.120]  как раз из пяти элементов, представьте себе, у меня
[16:30.120 --> 16:35.280]  массив а1, а2, а3, а4, а5, что такое вот эта его порядка
[16:35.280 --> 16:41.920]  статистика, ну это видимо третья в точности, да, а3,
[16:42.040 --> 16:45.160]  вот эта вот медиана, это а с нижним индексом 3 в скобочках,
[16:45.160 --> 16:47.920]  то есть третья порядка статистики, вот какой элемент после
[16:47.920 --> 16:51.280]  сортировки этого массива был бы третьим, это его медиана,
[16:51.280 --> 16:56.800]  так вот, давайте я в каждом из этих маленьких блоков
[16:56.800 --> 17:01.440]  возьму его медиану и обзову их б-шками, пусть это b1, это
[17:01.440 --> 17:05.720]  b2, это b3, это соответственно b с индексом n делить на 5,
[17:05.720 --> 17:07.760]  поскольку у меня n делить на 5 блоков, в каждом блоке
[17:07.760 --> 17:11.560]  своя медиана, у меня получается n делить на 5 чисел, повторю,
[17:11.560 --> 17:17.120]  давайте я это зафиксирую, что b и и это медиана этого
[17:17.120 --> 17:25.640]  блока длины 5, я разбил на кусочке длины 5, в каждом
[17:25.640 --> 17:33.920]  нашел медиану, обозначил за b и и, так, давайте я введу
[17:33.920 --> 17:36.560]  здесь немножко обозначений, да, quick select что принимает,
[17:36.560 --> 17:40.440]  он принимает массив а и число ка, пытается найти катую
[17:40.440 --> 17:45.480]  статистику в массиве а, дальше сделаем внезапный рекурсивный
[17:45.480 --> 17:56.720]  вызов, давайте скажем что x это quick select от массива
[17:56.720 --> 18:10.080]  b с индексом n делить на 10, да, а вам больно, но мне все
[18:10.160 --> 18:22.720]  равно, но я раз уж начал, я не хочу переделывать, да,
[18:22.720 --> 18:25.320]  я его все еще описываю, подожди, он еще не завершился,
[18:25.320 --> 18:28.240]  пока начало такое, что я разбил его на блоке из 5 элементов,
[18:28.240 --> 18:31.440]  в каждом взял медиану, это я еще описываю, это еще не
[18:31.440 --> 18:37.600]  завершится алгоритм, что, можно я сначала закончу
[18:37.600 --> 18:39.880]  алгоритм, потом мы поймем зачем это так, почему это
[18:39.880 --> 18:44.360]  так далее, так вот, возвращаемся, я рекурсивно запускаюсь
[18:44.360 --> 18:47.400]  на массиве вот этом b, на массиве медиан пятерок
[18:47.400 --> 18:51.560]  с индексом n на 10, ну понятно, я на самом деле в этом массиве
[18:51.560 --> 18:54.480]  тогда просто найду опять медиану, потому что их там
[18:54.480 --> 18:57.920]  n делить на 5, я выбираю статистику с номером n делить на 10,
[18:57.920 --> 19:00.600]  это как раз медиан на массивы медиан по факту, согласны,
[19:00.600 --> 19:03.400]  да, у меня много медиан, я из них выбираю медиану,
[19:03.400 --> 19:06.080]  то есть опять центральную статистику с индексом n
[19:06.080 --> 19:11.320]  делить на 10, а дальше делаю стандартную вещь, я запускаю
[19:11.320 --> 19:20.680]  partition по x, ну и дальше добавляю вот те вот три строчки,
[19:20.680 --> 19:23.840]  то есть по факту детерминированный quick select, все что делает,
[19:23.840 --> 19:27.480]  это более умный выбор x, вот если раньше у меня x выбирался
[19:27.480 --> 19:31.000]  случайно, равновероятно среди всех элементов,
[19:31.000 --> 19:35.040]  то теперь я его считаю такой магией, я выбираю медианы
[19:35.040 --> 19:41.040]  во всех пятерках, выбираю медиану в этом массиве медиан
[19:41.040 --> 19:43.840]  и по нему делаю partition, ну а дальше все стандартное,
[19:43.840 --> 19:47.720]  у меня массив разбился на три куска, меньше x равный
[19:47.720 --> 19:51.960]  x и больше x, и дальше в зависимости от того, как соотносится
[19:51.960 --> 19:55.800]  k с размерами этих блоков, этих корзиночек, я запускаюсь
[19:55.800 --> 20:00.240]  либо сюда, либо сюда, либо возвращаю x, ну давайте я продублирую,
[20:00.240 --> 20:08.000]  пусть это опять будет a1, a2, a3, пусть здесь размер,
[20:08.000 --> 20:13.480]  опять b занято, пусть будет c, d, e, извините, дальше все
[20:13.480 --> 20:21.240]  как обычно, если k не больше, чем c, тогда return, ну вот
[20:21.240 --> 20:23.640]  это наш детерминистик quick select, пусть будет я его
[20:23.640 --> 20:29.280]  так назову, от a1 с индексом k, то есть я в этом блоке ищу
[20:29.280 --> 20:35.240]  катую статистику, если c меньше k, меньше либо равно
[20:35.240 --> 20:48.280]  c плюс d, return x, ну и наконец, если c больше, чем c плюс d,
[20:48.280 --> 20:54.940]  тогда return, детерминистик quick select, от третьего блока,
[20:54.940 --> 21:00.700]  ну и опять-таки с исправленным индексом k-c-d, потому что
[21:00.700 --> 21:04.860]  опять, поскольку я отбросил вот эти элементы, то катая
[21:04.860 --> 21:14.380]  статистика стала k-c-d. Теперь описание алгоритма закончено.
[21:14.380 --> 21:17.380]  Есть вопросы по тому, как устроен алгоритм? Давайте.
[21:17.380 --> 21:34.740]  Выбираем медиану в каждом блоке, да, да, да. Так, ну давайте
[21:34.740 --> 21:38.700]  я здесь тоже напишу, детерминистик quick select, я запускаю сам этот
[21:38.700 --> 21:41.260]  же алгоритм, не тот рандомизированный, а вот этот новый, который
[21:41.260 --> 21:48.020]  я сейчас строю. Да, извините. Ну, этот массив длины n-delete
[21:48.020 --> 21:51.220]  на 5, я в нем выбираю статистику с номером n-delete на 10, то есть
[21:51.220 --> 21:55.820]  я выбираю по факту медиану в этом массиве b. Да. И используем
[21:55.820 --> 21:57.620]  теперь этот x в качестве пивота, а дальше все как
[21:57.620 --> 22:01.060]  всегда. То есть у меня единственное, что поменялось, это вместо
[22:01.060 --> 22:03.180]  использования случайного пивота, вот как раньше у
[22:03.180 --> 22:08.940]  меня было, x случайный пивот. Я теперь говорю x это медиан
[22:08.940 --> 22:12.180]  на массиве медиан пятерок, а вся остальная логика
[22:12.180 --> 22:18.180]  также как в рандомизированном случае. Нет, ну вот это,
[22:18.180 --> 22:21.260]  это медиан на массиве медиан, но это не медиана всего массива,
[22:21.260 --> 22:30.100]  я такого пока не утверждал. Если мы докажем какую-то
[22:30.100 --> 22:32.580]  оценку на то, сколько вообще работает детерминистик
[22:32.580 --> 22:35.260]  quick select, тогда мы и поймем, вот сейчас мы займемся оценкой
[22:35.260 --> 22:40.860]  8 точек. Вот так сработает. Давайте проверим, почему
[22:40.860 --> 22:43.660]  работает, потом посудим, можно ли выбирать какое-то
[22:43.660 --> 22:45.060]  другое количество. На самом деле это будет задача
[22:45.060 --> 22:46.860]  в домашней, поэтому я вряд ли буду много про это
[22:46.860 --> 22:55.140]  говорить. В каком плане бесполезен? Ну его также
[22:55.140 --> 22:59.660]  можно написать, я про это тоже скажу чуть позже. Нет,
[22:59.660 --> 23:03.140]  ну конечно нет. Тут хорошо только то, что мы избавляемся
[23:03.300 --> 23:05.700]  от случайных битов. Если нам внезапно это сложно
[23:05.700 --> 23:08.180]  делать, если мы не хотим использовать рандом, то вот
[23:08.180 --> 23:12.140]  можно сделать так. Так, еще вопрос где-то был. Да.
[23:12.140 --> 23:22.420]  Не скажу, секрет. Утверждение. Предъявленный алгоритм,
[23:22.420 --> 23:25.860]  заметьте, он уже детерминированный, у меня нет никаких случайностей.
[23:25.860 --> 23:27.620]  Так вот, я утверждаю, что такой алгоритм работает
[23:27.620 --> 23:43.020]  за отэн. Доказательства. Сперва я хочу оценить,
[23:43.020 --> 23:49.540]  насколько эффективный pivot x. Вот та медиана, массива
[23:49.540 --> 23:52.180]  медиан пятерок, которую я выбираю, насколько это
[23:52.180 --> 24:03.900]  хороший pivot. Вот я утверждаю, что x является статистикой,
[24:03.900 --> 24:13.020]  ну порядковой статистикой, с номером от трех десятых
[24:13.020 --> 24:24.100]  n до семидесятых n. Давайте сначала это поймем, почему
[24:24.100 --> 24:27.980]  так. То есть, вот тот x, который я выбираю, он в каком-то смысле
[24:27.980 --> 24:30.820]  достаточно хороший, потому что, что такое вообще плохие
[24:30.820 --> 24:34.020]  пивоты с точки зрения partition? Плохие пивоты — это
[24:34.020 --> 24:36.420]  те, которые очень близки к минимальному элементу
[24:36.420 --> 24:39.500]  или очень близки к максимальному. Тогда partition мне почти ничего
[24:39.500 --> 24:42.220]  не дал. Я разбил на что-то очень маленькое и что-то
[24:42.220 --> 24:44.740]  очень большое. Ну и, скорее всего, запускаюсь от этого
[24:44.740 --> 24:47.980]  большого куска. Поэтому x-ы, близкие к первой статистике
[24:47.980 --> 24:52.340]  или к n-ой, они довольно невыгодны. Я почти ничего не сделал.
[24:52.340 --> 24:54.820]  Так вот, я утверждаю, что тот x, который я выбираю в моем
[24:54.820 --> 24:59.140]  алгоритме, как медиану массива медиан пятерок, такой x
[24:59.140 --> 25:02.700]  будет весьма выгодный. Он не будет близок к единице,
[25:02.700 --> 25:06.340]  хотя бы на 3 десятых n, и не будет близок к n, ну в смысле
[25:06.340 --> 25:09.820]  к n-ной статистике, хотя бы опять-таки на 3 десятых n.
[25:09.820 --> 25:16.940]  Почему? Картинка очень простая. Смотрите, давайте я
[25:16.940 --> 25:20.980]  все вот эти блоки длины 5 нарисую 5 точечек в каждом
[25:20.980 --> 25:23.940]  из них. То есть, вот эти 5 элементов. Здесь 5 элементов,
[25:23.940 --> 25:29.260]  здесь 5 элементов, здесь 5 элементов, ну и так далее.
[25:29.260 --> 25:33.380]  Дальше давайте представим виртуально, что я все эти
[25:33.380 --> 25:42.380]  блоки длины 5 посортировал. Вот так вот я нарисую неравенство.
[25:42.380 --> 25:51.180]  Значит, это один блок длины 5, второй блок длины 5 и так
[25:51.180 --> 26:00.620]  далее. И каждый я посортировал. Заметьте, сейчас я доказываю
[26:00.620 --> 26:03.900]  асимптотику алгоритма. Я могу в доказательстве асимптотики
[26:03.900 --> 26:07.580]  делать что угодно. Сортировки в настоящем алгоритме не
[26:07.580 --> 26:10.900]  происходят. Это не то, что делает наш алгоритм, это
[26:10.900 --> 26:14.180]  то, что я делаю для доказательства утверждения. Этого не происходит
[26:14.180 --> 26:18.140]  в настоящем алгоритме. Прошу заметить. Итак, вот
[26:18.220 --> 26:21.980]  пусть я посортировал все вот эти мои пятерки. Ну понятно,
[26:21.980 --> 26:23.580]  там 5 элементов, я их могу переставить так, чтобы они
[26:23.580 --> 26:27.340]  возрастали сверху вниз. Дальше, я могу вот эти столбики
[26:27.340 --> 26:29.980]  из 5 элементов теперь еще так переупорядочить между
[26:29.980 --> 26:33.220]  собой, чтобы выполнялись вот такие вот неравенства.
[26:33.220 --> 26:43.980]  А именно, чтобы у меня медианы возрастали слева направо.
[26:43.980 --> 26:48.940]  Ну понятно, можно так сделать. Вот у меня есть n делить на 5 столбиков,
[26:48.940 --> 26:52.900]  медиана в каждом, это вот как раз третий кружочек. Давайте я выполню
[26:52.900 --> 26:56.620]  сортировку этих столбиков по третьему кружочку. В порядке
[26:56.620 --> 26:59.820]  возрастания. То есть я могу их так переставить, чтобы у меня
[26:59.820 --> 27:02.780]  третьи кружочки возрастали слева направо. Я их просто так
[27:02.780 --> 27:09.460]  переставил, чтобы они возрастали. Тогда скажите, пожалуйста, где находится
[27:09.460 --> 27:17.380]  x? В этой вот нашей, ну в центре, да. x это в точности центральный элемент
[27:17.380 --> 27:20.460]  на такой картинке. Потому что, смотрите, вот повторюсь,
[27:20.460 --> 27:24.380]  третьи кружочки в каждом столбце, это медианы соответствующих блоков,
[27:24.380 --> 27:29.940]  медианы блоков длины 5. Теперь я их посортировал. И если я посмотрю на
[27:29.940 --> 27:34.820]  центральную медиану, то есть, вот смотрите, у меня здесь n делить на 5 медиан,
[27:34.820 --> 27:39.140]  если я смотрю n делить на десятую из них, да, медиану вот с таким
[27:39.140 --> 27:43.340]  номером, то это будет в точности x. Ну, потому что x это медиан на массивы медиан.
[27:43.340 --> 27:48.900]  Вот он, массив медиан, отсортированный. Понятно, что x там будет в центре.
[27:50.100 --> 27:56.940]  Чудесно. Теперь мы на самом деле почти все сделали. Мы нашли x на этой картинке.
[27:56.940 --> 28:00.380]  Теперь давайте оценим количество элементов меньше x и количество элементов
[28:00.380 --> 28:06.260]  больше x. Ну, вот я утверждаю, что все, что здесь меньше x, все, что здесь больше x.
[28:06.260 --> 28:11.580]  Ну, вроде понятно по цепочкам. Да, смотрите, вот у меня есть этот столбик.
[28:11.580 --> 28:16.460]  Здесь при движении вверх у меня значения уменьшаются, здесь при движении влево у меня
[28:16.460 --> 28:20.620]  тоже значения уменьшаются. То есть, я могу уменьшать медиану, потом в столбике дойти
[28:20.620 --> 28:24.100]  до соответствующих элементов опять с помощью уменьшения. Поэтому все элементы в этом
[28:24.100 --> 28:30.620]  прямоугольнике точно меньше x. Ну, не меньше либо равно x. Вот. То же самое здесь. При движении
[28:30.620 --> 28:36.460]  направо я увеличиваю элемент, и при движении вниз, то есть я могу дойти до какого-то кружочка,
[28:36.460 --> 28:41.020]  потом при движении вниз опять элемент только увеличивать. Поэтому здесь будет опять-таки хотя
[28:41.020 --> 28:48.100]  бы вот этот прямоугольник элементов, который больше, чем x. Больше равный, чем x. Вот. Ну,
[28:48.100 --> 28:53.460]  теперь осталось понять сколько их. Ну, их везде хотя бы 3 на 10. Потому что это
[28:53.460 --> 29:00.540]  прямоугольник со стороной 3 и n делить на 10. Это прямоугольник со стороной 3 и n делить на 10.
[29:00.540 --> 29:10.300]  Значит, я считаю, что я доказал вот это утверждение. Вопросы есть по вот этому утверждению? Пока не
[29:10.300 --> 29:18.380]  иду вот сюда, пока просто вот это доказал. Понятно. Да, ну картинка просто. Супер. Ну,
[29:18.380 --> 29:22.940]  более-менее все. Дальше анализ симптотики, сейчас мы его проделаем аккуратненько. Да, значит,
[29:22.940 --> 29:30.100]  я доказал вот это утверждение. Теперь надо доказать все про время работы. Смотрите,
[29:30.100 --> 29:35.380]  давайте я, как обычно, обозначу через t от n время работы на массиве длины n. Максимальное время
[29:35.380 --> 29:51.580]  работы на массиве длины n. На массиве длины n. Тогда я утверждаю, что выполняется следующее
[29:51.580 --> 29:59.860]  соотношение. t от n не больше, чем t от n делить на 5, плюс t от 7n делить на 10, плюс o от n.
[29:59.860 --> 30:11.060]  Откуда это все взялось? Давайте проанализируем, как работает алгоритм на массиве длины n. Вспоминаем,
[30:11.060 --> 30:16.500]  что он делает первое. Он разбивает массив на блоке по 5 элементов и в каждом находит медиану.
[30:16.500 --> 30:22.100]  Я утверждаю, что это делается за линейное время. Потому что у меня линейное количество блоков,
[30:22.100 --> 30:28.260]  каждый блок константного размера. Чтобы найти в блоке константного размера третью порядку
[30:28.260 --> 30:32.700]  статистику, понятно, можно обойтись от 1 действий. Просто у вас есть массив из 5 элементов,
[30:32.700 --> 30:37.940]  как-нибудь уж вы, наверное, в нем третью статистику найдете за от 1, хоть там за 100 действий,
[30:37.940 --> 30:45.180]  но главное, что за от 1. Тем самым вы нашли массив b, а массив медиан всех пятерок. Это от n пока что.
[30:45.180 --> 30:55.140]  Что делаем дальше? Запускаем тот же алгоритм, рекурсивно запускаем себя на массиве длины n
[30:55.140 --> 31:02.140]  делить на 5. Вот вам первое слагаемое. Давайте напишем, что это рекурсивный запуск нашего
[31:02.140 --> 31:15.220]  детерманистики quick select на массиве b. На массиве медиан пятерок. Напомню, время меряется от
[31:15.220 --> 31:25.580]  размера массива. Это номер порядковой статистики. А я именно от размера массива считаю. Дальше. Дальше
[31:25.580 --> 31:31.180]  partition. Но мы знаем, что partition работает еще за линию, поэтому здесь вот в o от n еще константа
[31:31.180 --> 31:39.380]  как-то увеличится. Но она там съедена, она там ущетена. Ну и наконец проверка трех случаев и
[31:39.380 --> 31:45.940]  рекурсивный запуск, в худшем случае рекурсивный запуск, в одну из частей. Но при этом эта часть,
[31:45.940 --> 31:52.140]  я утверждаю, обязательно имеет размер не больше чем 7 на 10. Потому что наш pivot вот такой хороший.
[31:52.140 --> 31:59.740]  Слева от него и справа от него хотя бы 3n на 10 элементов. Значит, ну давайте картинка. Вот у меня
[31:59.740 --> 32:04.580]  был массив, я выбрал некий pivot, который после сортировки имеет индекс от такого до такого.
[32:04.580 --> 32:12.060]  Значит, ну после того, как я запускаю рекурсивные, то есть вот эти два запуска, я запускаюсь либо для
[32:12.060 --> 32:18.140]  всех элементов меньше x, либо для элементов больше x. Но я знаю, что их везде не больше чем 7n на 10.
[32:18.140 --> 32:26.140]  Потому что x это статистика, которая от минимум отстает хотя бы на 3n на 10. Значит, больше него
[32:26.140 --> 32:31.500]  элементов не больше чем 7n на 10. И от максимум отстает тоже не больше, в смысле хотя бы на 3n
[32:31.500 --> 32:37.180]  делить на 10. Значит, меньше него тоже элементов не больше чем 7n делить на 10. То есть в этих частях
[32:37.180 --> 32:45.700]  массива элементов не больше чем 7n делить на 10, потому что x вот такой. Отсюда получается такая
[32:45.700 --> 32:53.620]  рекуррента. Согласны? Вот, ну все, теперь надо просто аккуратно проанализировать и доказать,
[32:53.620 --> 33:01.900]  что O от n является решением такой рекурренты. Значит, общий совет. Значит, как такое делать?
[33:01.900 --> 33:07.020]  Что делать в таком случае? Ну, во-первых, нам надо раскрыть определение O от n и сказать,
[33:07.020 --> 33:10.860]  что это не просто n на какую-то константу, которая где-то там есть. А вот давайте конкретную какую-то
[33:10.860 --> 33:30.700]  С возьмем. Смотрите, вот это вы поняли откуда? Нет-нет-нет, вот это определение T от n. А вот это
[33:30.700 --> 33:34.900]  следует из того, как устроен наш алгоритм. Я вот объясняю, что мы сначала берем медиану массива
[33:34.900 --> 33:38.900]  пятерок, это вот столько времени занимает. Потом делаем partition, это вот столько времени
[33:38.900 --> 33:44.340]  занимает. Потом запускаемся рекурсивно от одного из кусков длины не больше чем 7n на 10. Отсюда вот
[33:44.340 --> 33:49.260]  это слагаемое. Получается, что на T от n верно вот такое, для T от n верно вот такое рекуррентное
[33:49.260 --> 33:57.780]  соотношение. Это доказано. Сейчас мы будем понимать, почему отсюда следует, что T от n это линия. Так вот,
[33:57.780 --> 34:04.900]  давайте раскроем вот это O от n. Раз здесь O от n, значит существует конкретная C, некоторая, что T от n
[34:04.900 --> 34:17.060]  не больше чем T от n делить на 5, плюс T от 7n делить на 10, плюс Cn. Ну потому что O от n на O от n это не
[34:17.060 --> 34:26.220]  больше чем Cn всегда для кого-то C. Вот, дальше давайте я, чтобы никого не запутывать, докажу,
[34:26.220 --> 34:45.540]  что T от n не больше чем 10Cn для любого n. Ну, база как-нибудь антривиальна. База n равна единице,
[34:45.540 --> 34:50.140]  уж как-нибудь там разберемся. Если массив из одного элемента, то вообще даже делать ничего не надо,
[34:50.140 --> 34:55.400]  можно просто вернуть катовую статистику, в этом случае k равна единице. Понятно, что T от 1 не
[34:55.400 --> 35:01.680]  больше чем 10C на 1. Ну, можно считать, что C достаточно большое, если надо. Короче,
[35:01.680 --> 35:08.840]  база вот в таких реквинентах всегда как бы почти автоматически выполняется. Ну, переход. Значит,
[35:08.840 --> 35:16.280]  пусть вот это соотношение верно для всех меньших n. Тогда давайте докажем для n. Пока что все,
[35:16.280 --> 35:30.960]  что я знаю про T от n, это вот это. Давайте напишем. Пока переписал. Дальше применим
[35:30.960 --> 35:37.800]  предположение индукции к вот этим двум слагаемым. Поскольку здесь аргумент меньше чем n, значит для
[35:37.800 --> 35:43.960]  них справедливое предположение индукции, я могу написать, что вот это вот не больше чем 10C умножить
[35:43.960 --> 35:48.880]  на аргумент, это не больше чем 10C умножить на аргумент. Давайте так и напишем. Это не больше
[35:48.880 --> 35:56.680]  чем 10C на n делить на 5 по предположению индукции, это не больше чем 10C умножить на 7n делить на 10.
[35:56.680 --> 36:04.160]  Вновь по предположению индукции. И что бы вы думали будет, если мы все это сложим, верно 10Cn.
[36:04.160 --> 36:14.360]  Вроде не обманываем, да, потому что здесь будет 2Cn, здесь будет 7Cn, здесь еще 1Cn. Доказали.
[36:14.360 --> 36:28.720]  Доказываем по индукции. Доказываем по индукции. Считаем, что для всех меньших n это верно, то есть
[36:28.720 --> 36:33.880]  если n-штрих меньше чем n, то для n-штрих верно это соотношение. Теперь, чтобы доказать это для T от n,
[36:33.880 --> 36:39.160]  я переписываю то, что мне известно про T от n, оцениваю оба вот этих слагаемых через
[36:39.160 --> 36:48.240]  предположение индукции и получаю то, что мне нужно в точности 10Cn. Вот эти-то? Ну как,
[36:48.240 --> 36:54.120]  предположение индукции просто. Я считаю, что вот это вот верно для всех меньших n. Ну то есть
[36:54.120 --> 37:03.100]  формально, да, если k меньше чем n, то T от k не больше чем 10Ck. Это предположение индукции,
[37:03.100 --> 37:11.440]  но я вот тут написал, тут написал. То есть T для меньших аргументов не больше чем 10C на аргумент.
[37:11.440 --> 37:17.460]  Вот здесь не больше 10C на аргумент, не больше 10C на аргумент, просто предположение индукции.
[37:17.460 --> 37:25.700]  а дальше складываю, получаю внезапно 10 цен. Да, конечно, но константа 10 так подобрана, чтобы
[37:25.700 --> 37:29.700]  здесь было не больше 10 цен. Если бы я взял, например, 11 цен, у меня бы здесь было чуть
[37:29.700 --> 37:35.740]  меньше, чем 11 цен, я бы мог его сверху оценить 11 ценами. Вот я и сказал, я здесь специально написал
[37:35.740 --> 37:40.140]  константу 10, чтобы не вводить очередное там какое-то, а, большое, да, какую-то константу,
[37:40.140 --> 37:44.780]  потом ее подбирать, я сразу вам засполилировал ответ, с ним доказал. Да, 10 специально подобран.
[37:44.780 --> 38:14.220]  Ну, например, да. Что там, кто что-то заметил? Ну, да, да, да, да. Я услышал вопрос. Это,
[38:14.220 --> 38:25.540]  оказалось, все понятно? Можно дальше идти? Давайте. Сейчас я отвечу на вопрос, я помню его, да. Да,
[38:25.540 --> 38:40.420]  на нем рекурсивно запускаем тот же алгоритм. Ну, давайте так, то есть формально, если там,
[38:40.420 --> 38:46.180]  не думая отвечать на ваш вопрос, я могу сделать так. Если n не больше, чем 10, то, наверное,
[38:46.180 --> 38:51.260]  на массиве длины 10 я могу найти любую статистику, которую меня попросили. Значит, давайте,
[38:51.260 --> 38:55.540]  я мой алгоритм исправлю так, ну, прям вот, как работает DQS, он принимает массив длины n,
[38:55.540 --> 39:00.700]  если n не больше, чем 10, сделай что-нибудь тупое и найди катую статистику, а иначе делай вот это.
[39:00.700 --> 39:06.220]  Ответил? Опять, мне не важно поведение на маленьких n, я рассматриваю только на бесконечности, да, в этом
[39:06.220 --> 39:10.420]  весь пафос вообще всех алгоритмов, что нам не важно работа на маленьких n, не важно только на
[39:10.420 --> 39:15.620]  бесконечности. Так же и здесь, да, для маленьких я могу что-то отдельно развивать, и вот здесь,
[39:15.620 --> 39:21.580]  как бы, я считаю, что все корректно индексам. Итак, отвечаю на вопрос, который мы задали минимум
[39:21.580 --> 39:29.020]  четыре раза, почему пять, а не другое число? Правильно это, потому что работает. Вопрос,
[39:29.020 --> 39:35.740]  с какими другими числами сработает. Ну вот, в домашней будет задача описать все вот эти вот
[39:35.740 --> 39:42.580]  числа, которые можно поставить вместо пятерки, так, чтобы это работало. Интуиция. Ну, наверное,
[39:42.580 --> 39:47.820]  естественно, выбирать нечетное вот это число, да, нам не интересно брать 4, 6 и так далее,
[39:47.820 --> 39:53.260]  потому что ну там сложно медиану просто определить. Да, я выбираю пятерку нечетной, чтобы можно было
[39:53.260 --> 39:59.220]  взять медиану в этом блоке. Это тривиальный аргумент. Дальше вопрос, почему нельзя бить на блоке длины
[39:59.220 --> 40:05.300]  1 или 3? Но бить на блоке длины 1, это как-то совсем глупо, вы вообще ничего не сделали, да? Вот, бить на блоке
[40:05.300 --> 40:10.820]  длины 3, вот, типа, оказывается, что если вы будете бить на блоке длины 3, то там будет плохая симптотика.
[40:10.820 --> 40:15.180]  То есть, грубо говоря, если вы вот это все распишете, то там будет, ну, короче, оно не будет сворачиваться в
[40:15.180 --> 40:20.540]  вот-эн. Вот тройки мало. Если вы с тройкой это сделаете, то здесь будут как бы вот, то есть, эти штуки,
[40:20.540 --> 40:26.780]  они так внезапно работают для пятерки, что это все сворачивается в вот-эн. Вот для тройки не сработает.
[40:26.780 --> 40:34.020]  Получается, пятерка как бы, ну, минимальный кандидат, для которого все подходит. Вот вам и ответ.
[40:34.020 --> 40:42.620]  Можно больше, да. Можно больше, но как бы это уже вряд ли осмыслено, потому что чем больше вы
[40:42.620 --> 40:51.140]  выбираете размер блока, тем сложнее вам искать медиану в массиве вот этого блока. Окей? Вопросы?
[40:51.140 --> 41:03.420]  Ответы. Хорошо. Еще раз? Ну, конечно, ну, как бы с точки зрения практики, наверное, если вы возьмете
[41:03.420 --> 41:09.260]  вместо пятерки там 21 и будете искать медиану в, ну, короче, у вас константа просто вырастет,
[41:09.260 --> 41:19.660]  скорее всего, но это не точно. Так, ура! Все, мы нашли, значит, катую статистику за линейное время.
[41:19.660 --> 41:29.460]  Тривиальное следствие. Можно написать детерминистик. Quick sort.
[41:29.460 --> 41:46.820]  Основанная той же идее, но уже без использования случайных бит. Как это делать? Как?
[41:49.660 --> 42:02.660]  Можно просто медиану выбрать. Да, значит, работа следующим образом. Вместо того, чтобы выбирать пивот
[42:02.660 --> 42:14.460]  случайно, давайте выберем его детерминированно медианой. Благо мы уже написали линейный по времени
[42:14.460 --> 42:20.340]  алгоритм, который находит нам катую статистику для любого k. Ну, то есть, какую k мне сказали,
[42:20.340 --> 42:29.660]  такую я найду. Я взял и нашел в моем массиве медиану. Дальше все, как обычно. Partition по x.
[42:29.660 --> 42:40.580]  У вас массив разбивается на три куска. Ну, давайте вот так напишу. Сколько-то x, меньше x и больше x.
[42:40.580 --> 42:47.260]  За счет того, что у вас x это медиана, у вас вот здесь элементов не больше чем половина и здесь
[42:47.260 --> 42:53.740]  элементов не больше чем половина. И это прям самый идеальный случай, лучшей на что можно надеяться.
[42:53.740 --> 42:59.860]  Когда вы выбираете в качестве пивота медиану, у вас массив разбивается на вот такие два куска размера
[42:59.860 --> 43:08.900]  не больше чем n пополам. Ну, а значит здесь работает такая рекуррента. А мы знаем, что ее решением
[43:08.900 --> 43:24.980]  является n log n. Эту картинку я точно когда-то рисовал. Если у меня получается делать partition
[43:24.980 --> 43:31.340]  с медианой всегда, то есть с элементом, который центральный после сортировки, то у меня время
[43:31.340 --> 43:36.660]  работы такого алгоритма точно будет n log n. Потому что я каждый раз по факту бью массив на два куска
[43:36.660 --> 43:41.940]  и рекурсив на их сортирую за время t от n пополам. То есть у меня есть такая рекуррента и мы вроде
[43:41.940 --> 43:49.580]  уже доказывали, что это вот n log n, верно же? Ну вот, все. Значит, если просто вместо случайного пивота
[43:49.580 --> 43:53.700]  выбирать медиану с помощью вот того алгоритма, то вот, пожалуйста, детерминированная сортировка
[43:53.820 --> 44:05.940]  n log n. Еще одна. Вот. Так, ну хорошо. Это сделали.
[44:05.940 --> 44:32.940]  Так, выдыхаем. Идем дальше. Переходим к сортировке чисел непосредственно. Сортировка чисел.
[44:35.940 --> 44:43.820]  Значит, до этого момента все сортировки, которые мы рассматривали, основывались исключительно на
[44:43.820 --> 44:50.340]  сравнениях. Мы не пользовались информацией о том, что на самом деле за элементы лежат в массиве.
[44:50.340 --> 44:56.140]  Все, что мы делали над элементами, это только их сравнивали и переставляли между собой. Так вот,
[44:56.140 --> 45:01.820]  давайте теперь вспомним, ну или, по крайней мере, рассмотрим случай, когда мы сортируем именно числа.
[45:01.820 --> 45:09.660]  Ну и желательно, числа не очень большие. Значит, самая простая постановка такая. Давайте в ноль
[45:09.660 --> 45:22.940]  индексации теперь. Надо оно мне. Вот есть массив чисел. Представьте, что все элементы — это целые
[45:22.940 --> 45:31.260]  числа из множества от нуля до k. Ну где k тоже не очень большой. Представьте, что там n и k порядка
[45:31.260 --> 45:43.100]  миллиона что-нибудь. Надо сделать сортировку. В такой постановке это вроде совсем просто. Давайте
[45:43.100 --> 45:52.740]  самый простой алгоритм сортировки. Называется сортировка подсчетом. Делается очень просто.
[45:52.740 --> 45:59.780]  Давайте мы сначала пройдемся по массиву и посчитаем, сколько раз каждое число встретилось. Давайте
[45:59.780 --> 46:05.660]  заведем какие-нибудь контейнеры, точнее, какие-то счетчики. Knt от x — это сколько раз встречается
[46:05.660 --> 46:17.460]  число x в нашем массиве. Сколько раз x встречается в A, в исходном нашем массиве. Но это очень легко
[46:17.460 --> 46:24.100]  сделать. Давайте заведем просто массив с индексами от нуля до k, заполним его нулями, пройдемся по
[46:24.100 --> 46:29.140]  массиву. Каждый раз, когда видим число, увеличиваем количество его вхождений. Это тривиально. А дальше
[46:29.140 --> 46:34.420]  просто, если у меня для каждого числа написано число вхождений, давайте я выведу каждое число
[46:34.420 --> 46:43.820]  столько раз, сколько оно в массиве встречается. То есть для всех x от нуля до k, там скажем для i от
[46:43.820 --> 46:54.780]  одного до knt от x, принт x — такой интеллектуальный алгоритм сортировки. Вроде работает.
[46:54.780 --> 47:01.740]  Мы идем по всем возможным числам, которые могут быть в массиве в порядке возрастания,
[47:01.740 --> 47:06.940]  и печатаем каждый из них столько раз, сколько оно в массиве присутствует. От одного до knt от x идем
[47:06.940 --> 47:18.980]  в цикле, и каждый раз печатаем x. Понятно все? Массив. У меня же все числа от нуля до k.
[47:18.980 --> 47:31.100]  Еще раз, к knt я могу просто так объявить. Knt — это массив размера k плюс 1, который заполнен
[47:31.100 --> 47:37.500]  изначально нулями. Я сразу сказал, что k небольшое. Если k небольшое, то я могу завести такой массив,
[47:37.500 --> 47:45.980]  занулить его и дальше вот так пройти и все сделать. Очевидно, что такой алгоритм работает за n плюс k.
[47:49.900 --> 47:55.980]  На что тратится это время? На считывание массива от n, на создание массива knt от k, на опять-таки
[47:55.980 --> 48:01.260]  прохождение по всему массиву и увеличение количества вхождения каждого x. Еще от n,
[48:01.260 --> 48:05.820]  потому что я по этому массиву прошел. Ну и вот здесь еще от n плюс k, потому что я для всех чисел
[48:05.820 --> 48:18.180]  массива печатаю сколько раз оно входит. Поэтому n плюс k. Повторю, это адекватно,
[48:18.180 --> 48:23.300]  если это что-то адекватное, то есть если k там миллионы, возможно десятки миллионов,
[48:23.300 --> 48:36.420]  тогда это хорошо. Так, что-то еще хотел сказать? Забыл. Да, могут быть. Сейчас, момент,
[48:36.860 --> 48:49.100]  что-то еще хотел сказать. Ну ладно, бог с ним. Так, хорошо. Теперь давайте модифицируем эту
[48:49.100 --> 48:54.540]  сортировку так, чтобы она стала стабильной. Это определение, что такое стабильная сортировка.
[48:54.540 --> 49:05.700]  Ну вообще говоря, формально мы знаем, что такое сортировка. Это поиск перестановки входных
[49:05.700 --> 49:10.740]  элементов так, чтобы они стали в порядке возрастания. То есть формально обычная
[49:10.740 --> 49:19.500]  сортировка это поиск перестановки из 1, 2 и так далее n в 1, 2 и так далее n такой,
[49:19.500 --> 49:30.300]  что ассо сигма 1 не больше ассо сигма 2 и так далее. Вот где а изначальный массив. Так вот,
[49:30.300 --> 49:41.780]  стабильность, это когда равные элементы сохраняют свой относительный порядок. Давайте я сначала
[49:41.780 --> 49:45.580]  на примере, потом формальное определение как не допишем. Вот представьте себе такой массив.
[49:45.580 --> 49:58.340]  Ну понятно, его сортировка это 1, 1, 1, 2, 2, 3. Так вот, я хочу, чтобы сортировка была стабильная,
[49:59.260 --> 50:04.580]  чтобы равные элементы сохраняли свой относительный порядок. То есть, что вот те 3 единицы,
[50:04.580 --> 50:10.940]  которые идут в начале, вот эта соответственно вот этой, вот эта вот этой, а эта вот этой. Дальше
[50:10.940 --> 50:14.820]  идут двойки, и они тоже сохраняют свой относительный порядок. Сначала вот эта двойка,
[50:14.820 --> 50:19.660]  самая левая, потом вот эта левая, потом вот эта двойка, следующая за ней. Ну и тройка вот такая.
[50:19.660 --> 50:31.100]  Формально. Мне нужна такая перестановка, что, ой, не разу написал это формально,
[50:31.100 --> 50:46.900]  мне кажется, я умру сейчас. Сейчас, сейчас, потому что sigma это то, куда встает, нет, момент.
[50:46.900 --> 50:57.740]  Сейчас, нет, недостаточно. Сейчас, sigma 1, кто-то встал на первое место.
[50:57.740 --> 51:14.220]  Вот нет, мне так не нравится.
[51:16.900 --> 51:26.020]  Нет, нет, вы не так говорите, потому что sigma и это не то, на какое место встал этот элемент. А то,
[51:26.020 --> 51:29.660]  кто стоит на этом месте теперь? Видимо, надо sigma в минус первый. То есть, формально, конечно,
[51:29.660 --> 51:45.820]  надо писать так. Потому что это не то, на какое место встал этот элемент, а скорее кто встал на
[51:45.820 --> 51:51.900]  такое-то место. Поэтому мне нужно, чтобы место, на которое встало и, было меньше местное,
[51:51.900 --> 52:02.260]  которое встало ажи. Так правильно, как думаете? Да, да, не похоже. Сейчас, дайте я еще 30 секунд подумаю
[52:02.260 --> 52:09.540]  и пойдем дальше в любом случае. Сейчас, подождите, пожалуйста. Сигма 1, кто встал на первое место.
[52:09.540 --> 52:17.340]  Сигма в минус первый от 1. Да, да, все правильно, потому что, смотрите, потому что на самом деле
[52:17.340 --> 52:31.700]  sigma в минус первый от какой-то позиции p это место, куда встало число ap. Куда встало ap.
[52:31.700 --> 52:47.900]  Тогда вроде все правильно писал. Что значит тот индекс, который был? Это тот, кто перешел на…
[52:47.900 --> 53:10.980]  При условии, что ai равно ажи. Ладно, в общем, что-то, извините, формально вроде так, можно,
[53:10.980 --> 53:14.780]  наверное, по-другому. Еще раз, главное, чтобы все поняли качественно, что происходит. Я хочу,
[53:14.780 --> 53:20.380]  чтобы равные элементы, если один был левее другого, то после сортировки первый будет опять-таки левее
[53:20.380 --> 53:35.260]  второго. Сигма – это перестановка, в каком порядке я представляю элементы. Сигма 1 – это то число,
[53:35.260 --> 53:38.860]  которое встало на первое место. Сигма 2 – это то, которое встало на второе место. Сигма n – это то,
[53:38.940 --> 53:46.380]  число, которое встало на n-ое место. Да, это изначально номер элемента, который встал на такое-то место.
[53:46.380 --> 53:56.980]  Вот, значит, минус 1 – обратная перестановка. Ну, это вот обратная перестановка. Это тот,
[53:56.980 --> 54:02.260]  кто встал на… Точнее, если сигма от двух – это тот, кто встал на второе место, то сигма в минус
[54:02.260 --> 54:12.420]  1 и это то… Ну вот, сигма в минус 1 от P – это место, куда встало АП. Ладно, еще раз. Нет,
[54:12.420 --> 54:21.060]  сигма от P – это кто встал на это место. А здесь я спрашиваю, куда пошло АП. Ладно, все, еще раз,
[54:21.060 --> 54:24.580]  давайте, я не хочу здесь задерживаться. Если вы не поняли, давайте на качественном уровне поймете.
[54:24.580 --> 54:32.060]  Стабильная сортировка такая, что если два числа равны, то после сортировки они
[54:32.060 --> 54:36.780]  сохраняют относительный порядок. Вот как здесь вот были две единицы, после сортировки это пришло
[54:36.780 --> 54:41.460]  сюда, это сюда. Вот мне именно что нужно, если это было левее этой единицы, то они сохранили свой
[54:41.460 --> 54:46.340]  порядок, что это осталось левее, чем это. Все. Если формально не понятно или если не согласны,
[54:46.340 --> 54:55.980]  записывайте так, как правильно. Вот, теперь давайте напишем стабильную сортировку под счетом.
[54:55.980 --> 55:23.460]  То есть, я хочу не просто оба как переставить мои элементы,
[55:23.460 --> 55:29.580]  да, ну потому что в том алгоритме я вообще не слежу за тем, в каком порядке шли, вот если там
[55:29.580 --> 55:34.340]  несколько равных было, я вообще не слежу за тем, в каком порядке они шли. Я просто их куда-то
[55:34.340 --> 55:39.420]  сваливаю вот в одну кучу и просто их печатаю. Я даже не знаю, на каком месте все они были изначально.
[55:39.420 --> 55:47.460]  Вот, давайте это исправим. Начало будет такое же. Давайте я здесь, наверное, напишу все-таки немножко
[55:47.460 --> 55:58.100]  кода. Давайте я заведу массив knt из нулей, пройдусь по всем элементам массива и увеличу количество
[55:58.100 --> 56:11.300]  вхождений числа ai. На плюс плюс число это увеличение числа на единичку. Вот, сейчас в массиве knt лежит
[56:11.300 --> 56:18.780]  количество вхождений каждого числа, ну также как вот здесь. knt от x это сколько раз x встречается
[56:18.780 --> 56:30.540]  в массиве a. Дальше я сделаю следующую магию. Для всех i от 1 до k я к knt i прибавлю knt i-1.
[56:41.300 --> 56:57.340]  Вот. Все элементы до k. После этого, смотрите, давайте поймем, что теперь хранится в массиве knt
[56:57.340 --> 57:01.540]  после этого цикла. Ну к knt 0 у меня осталось количество нулей, потому что к knt 0 здесь не
[57:01.540 --> 57:07.260]  меняется. Дальше к knt 1 я прибавил к knt 0. То есть теперь в knt 1 лежит количество нулей плюс
[57:07.260 --> 57:13.140]  количество единиц. Дальше, что такое в knt 2? к knt 2 я прибавил новое значение к knt 1. К knt 2
[57:13.140 --> 57:18.980]  увеличил на knt 1. В knt 1 лежит количество нулей плюс единиц. Значит в knt 2 теперь лежит количество
[57:18.980 --> 57:25.380]  2 к нулей единиц. То есть всех не больше чем 2. Ну легко понять, что после выполнения этого цикла,
[57:25.380 --> 57:34.140]  давайте здесь подпишу, что knt от x это количество числа не больше чем x. Ну потому что как бы я
[57:34.140 --> 57:38.780]  вот посчитал сколько их всего и протолкнул вперед. То есть каждое x я протолкаю во все
[57:38.780 --> 57:44.220]  больше. Тем самым я его учту во всех больших аргументах, во всех больших индексах. Вот.
[57:44.220 --> 57:53.100]  Прелесть в том, вот зря я перешел все-таки в ноль индексации, вот здесь не больше всего удобно
[57:53.100 --> 58:04.020]  один индексация. Ну ладно. Смотрите, если бы я использовал один индексацию, то у меня элемент,
[58:04.020 --> 58:12.820]  скажем с номером knt от x в один индексации должен был быть самым правым x. Потому что смотрите,
[58:12.820 --> 58:18.940]  вот у меня есть knt от x. Что такое knt от x? Это количество элементов не больше чем x. Значит,
[58:18.940 --> 58:24.180]  элемент с номером, вот если я возьму один индексацию на время, элемент с номером knt от x,
[58:24.180 --> 58:30.900]  вот здесь вот расположены все элементы не больше чем x, значит здесь расположен самый правый x.
[58:30.900 --> 58:42.820]  Самый правый x. Ну если x вообще конечно существует. Потому что вот здесь вот на этих позициях должны
[58:42.820 --> 58:48.020]  располагаться все числа не больше чем x, потому что их вот ровно столько. Самое правое из них
[58:48.020 --> 58:58.180]  должно быть самым большим, самым правым числом, то есть самый правый x. Поэтому теперь я буду идти по
[58:58.180 --> 59:07.020]  моему массиву исходному справа налево и x класть вот в эту ячейку. Да, ну вот я уточнил,
[59:07.020 --> 59:14.380]  если x вообще существует. Если не существует, то конечно там другое число. Сейчас учтем, не переживайте.
[59:18.020 --> 59:25.180]  Вот. Мораль такая, что я хочу класть, вот если я теперь пойду по исходному массиву справа налево
[59:25.180 --> 59:32.140]  и вижу x, то я его хочу поставить на позицию knt от x. Давайте ровно это и сделаем. Значит,
[59:32.140 --> 59:40.340]  идем по массиву справа налево, в порядке убывания индекса. Вот пусть x, давайте обозначим x это
[59:40.340 --> 59:46.860]  текущее число, я хочу поставить его на место knt от x. Да, вот это вот самый правый из увиденных
[59:46.860 --> 59:53.340]  x, я хочу поставить его на место knt от x. Ну, то было в 1 индексации, в 0 индексации, это будет что-то
[59:53.340 --> 59:59.460]  типа, давайте напишу ans knt x минус 1, да, потому что если мы хотим в 0 индексации жить, то мне
[59:59.460 --> 01:00:09.020]  нужно единичку вычесть. Сюда поставить вот это самое x. Вот. И нужно уменьшить knt от x на единичку,
[01:00:09.020 --> 01:00:16.060]  а минус минус knt от x, то есть уменьшаем knt от x, чтобы следующий встреченный x встал не на то
[01:00:16.060 --> 01:00:22.980]  же самое место, а на место на единичку левее. Потому что если у меня в массиве есть несколько x,
[01:00:22.980 --> 01:00:30.540]  я иду по массиву справа налево, это поставил на место knt от x, это на место knt от x минус 1,
[01:00:30.540 --> 01:00:36.180]  это на место knt от x минус 2, потому что каждый раз, когда я поставил x, я уменьшаю позицию,
[01:00:36.180 --> 01:00:42.580]  на которую надо поставить x. То есть теперь в каком-то смысле можно понимать, что knt от x это
[01:00:42.580 --> 01:00:47.820]  не количество, а позиция, куда надо ставить очередной x. Ну вот я просто иду справа налево,
[01:00:47.820 --> 01:01:04.260]  ставлю. Вот. В конце, давайте вот после этого, теперь ans 0 и так далее ans n-1 содержат стабильно
[01:01:04.260 --> 01:01:25.380]  отсортированную версию A. Вот такие дела. Сейчас все будет, вы опять сбегаете вперед. Вот пока,
[01:01:25.980 --> 01:01:40.420]  сейчас будем применять. Еще вопросы есть? Давайте. X это текущее значение, мы знаем,
[01:01:40.420 --> 01:01:45.820]  куда его надо поставить, ставим туда. Да ans это ответ.
[01:01:45.820 --> 01:01:57.980]  Нет-нет-нет. Смотрите, вот если у меня есть несколько x, я сначала увижу этот,
[01:01:57.980 --> 01:02:05.220]  поставлю его на место knt от x минус 1, потом уменьшу это число на 1, потом буду идти справа налево,
[01:02:05.220 --> 01:02:11.860]  увижу этот x, опять тот же самый x. И в значении knt хранится правильное место для него, потому что я
[01:02:11.860 --> 01:02:16.700]  его уменьшил. Опять ставлю, куда надо, уменьшаю. Дохожу до него, опять ставлю, куда надо, уменьшаю.
[01:02:16.700 --> 01:02:21.460]  То есть у меня как бы вот эти x поставятся подряд справа налево, начиная с позиции knt от x.
[01:02:21.460 --> 01:02:40.940]  Ну конечно, да. Вот. Зачем это надо? Действительно, пока непонятно зачем, у нас все так как бы были
[01:02:40.940 --> 01:02:45.780]  числа, мы их переставили и получили опять отсортированную версию. Зачем это надо один?
[01:02:45.780 --> 01:02:55.820]  Да. А что такое просто стабильная сортировка? В смысле просто сортировка подсчетом? Ну тем,
[01:02:55.820 --> 01:02:59.540]  что она стабильна. Вот это была просто або какая сортировка, теперь я сделаю ее стабильной. Сейчас
[01:02:59.540 --> 01:03:05.940]  я покажу зачем может быть нужна стабильная сортировка. Пример. Сортировка пар чисел.
[01:03:05.940 --> 01:03:21.660]  Представьте себе, что элементы вашего массива это не числа, а пары чисел. Давайте я напишу
[01:03:21.660 --> 01:03:33.300]  формально. У вас есть массив пар а0, b0, а1, b1 и т.д. аn-1, bn-1. Ну и опять все значения это какие-нибудь
[01:03:33.300 --> 01:03:44.580]  маленькие целые числа. Все аi и bi целые числа от 0 до k. Опять хочу отсортировать как-нибудь
[01:03:44.580 --> 01:03:56.780]  за быстро. Давайте я сделаю следующее. Так, вроде справа налево надо сделать. Шаг 1. Стабильная
[01:03:56.780 --> 01:04:17.060]  сортировка по b. Шаг 2. Стабильная сортировка по a. Конец. И здесь важно, что она стабильная.
[01:04:17.060 --> 01:04:28.780]  Давайте пример какой-нибудь нарисуем. Такая пара, такая пара. Сейчас, одну секунду. Такая
[01:04:28.780 --> 01:04:43.220]  пара. Такая пара. Ну еще что-нибудь. 2, 3 нарисую. Да, вопрос? Пара сравнивается классически как,
[01:04:43.220 --> 01:04:52.060]  да, это я не сказал, но давайте напишу формально. Значит пара x, y меньше пары x' и y'. Если только
[01:04:52.060 --> 01:05:01.620]  если верно одно из двух. Либо x меньше, чем x', либо они равны, но y меньше, чем y'. Ну так всегда так.
[01:05:01.620 --> 01:05:08.260]  Векторы так сравниваются в плюсах. Классическое сравнение пар. Слева направо, лексиграфически
[01:05:08.260 --> 01:05:13.460]  сравнение это называется. Компоненты сравним слева направо. Впервые когда находим неравенство,
[01:05:13.460 --> 01:05:19.660]  знак неравенства между первым несовпадением совпадает со знаком сравнения пар. Вот.
[01:05:19.660 --> 01:05:25.140]  Ну вот давайте такой пример посмотрим, что происходит. Я сначала сортирую по b. Давайте как-то
[01:05:25.140 --> 01:05:31.220]  они переставятся. Сначала будет видимо вот это. То есть первый шаг. Сортировка по b. Вот это
[01:05:31.220 --> 01:05:49.860]  минимальная. Дальше 1,3,2,3 и вот это 2,4,1,4. Шаг второй. Сортировка по a. Так, эти остаются, причем
[01:05:49.860 --> 01:05:56.620]  стабильная сортировка по a. Эти два остались на месте. Это переместилось сюда, потому что единичка
[01:05:56.620 --> 01:06:02.100]  первая. Здесь осталось 2,3,2,4, потому что стабильно. Относительный порядок равных
[01:06:02.100 --> 01:06:06.140]  элементов. Сейчас равенство подразумевается по a. Относительный порядок элементов не изменился.
[01:06:06.140 --> 01:06:16.380]  Ну как видим, вроде реально посортировалась. Неважно, можно просто сортировку, это правда.
[01:06:16.380 --> 01:06:24.900]  Ну я уже для красоты написал. Почему это работает? Смотрите, после завершения первого этапа у меня все
[01:06:24.900 --> 01:06:31.420]  пары отсортированы слева направо в порядке возрастания b. Что я делаю потом? Я сортирую по
[01:06:31.420 --> 01:06:39.060]  a. Понятно тогда, что если у двух пар были разные значения a, вот пусть скажем было x и x' и одно
[01:06:39.060 --> 01:06:43.860]  меньше другого, тогда понятно, что после второго шага они будут правильно расположены между собой.
[01:06:43.860 --> 01:06:49.180]  Поскольку у меня сейчас происходит сортировка по первому аргументу, по a, по первой компоненте.
[01:06:49.180 --> 01:06:54.380]  Значит после этого шага, понятное дело, элементы с разными ашками у меня будут правильно
[01:06:54.380 --> 01:06:59.140]  отсортированы между собой. А раньше тот, кто меньше. Единственное вопрос, что происходит с теми ашками,
[01:06:59.140 --> 01:07:07.820]  которые равны. Так вот, поскольку сортировка стабильна, то те пары, у которых ашки совпадают,
[01:07:07.820 --> 01:07:13.580]  сохранят свой порядок по сравнению с тем, что было после первой итерации. То есть они будут
[01:07:13.580 --> 01:07:19.380]  сравнены как раз по b. Потому что после первой итерации у меня все пары отсортированы в порядке
[01:07:19.380 --> 01:07:25.780]  возрастания по b. И получается при равных a я оставляю этот порядок, то есть при равных a я их буду
[01:07:25.780 --> 01:07:32.300]  как бы сравнивать по b, потому что они отсортированы после первого шага по b как раз. Вот, поэтому это
[01:07:32.300 --> 01:07:48.020]  корректная сортировка. Еще раз? Да, можно и нестабильно, это правда. Вопросы? Да, ну это простые вещи.
[01:07:48.020 --> 01:07:51.860]  Сортировать по счетам даже стабильно мы умеем, вот как бы алгоритм только что предъявлен.
[01:07:51.860 --> 01:08:07.980]  Ну смотрите, у вас есть n элементов, у вас массив из n элементов. При стабильной сортировке вы
[01:08:07.980 --> 01:08:12.580]  смотрите только на конкретный компонент пары. Здесь на b, здесь на a. Вы игнорируете второй
[01:08:12.580 --> 01:08:20.740]  компонент. Ну и дальше вот так вот сортируете. Ну да, поэтому вы делаете две разные сортировки,
[01:08:20.740 --> 01:08:25.740]  все правильно. Здесь вы игнорируете первый компонент пары, здесь вы игнорируете второй
[01:08:25.740 --> 01:08:31.460]  компонент пары и сортируете так, как будто бы этого второго компонента просто нет. Ну и тогда
[01:08:31.460 --> 01:08:42.460]  работает вот обычная сортировка по счетам стабильная. Я проговаривал, что в случае
[01:08:42.500 --> 01:08:49.220]  совпадения a-шек вторая сортировка не поменяет их порядок, потому что она стабильная, стабильная
[01:08:49.220 --> 01:08:53.260]  по a. Значит, в случае равенства они сохранят свой относительный порядок после первого шага,
[01:08:53.260 --> 01:08:58.500]  то есть если две a-шки равны, то после второго шага их порядок такой же относительной,
[01:08:58.500 --> 01:09:06.180]  такой же, как был после первого шага, потому что она стабильна. Но они же посортированы
[01:09:06.180 --> 01:09:10.500]  после первого шага по b-шке, после первого шага они отсортированы в порядка разр peaks по b-шке,
[01:09:10.500 --> 01:09:16.940]  Значит, если две ашки равны, то они вот здесь вот были в том же порядке, в котором надо, в порядке
[01:09:16.940 --> 01:09:21.180]  возрастания по b, потому что мы сначала сделали сортировку по b, а поскольку вторая стабильна,
[01:09:21.180 --> 01:09:28.100]  то их порядок не изменится. Как вот здесь, смотрите, вот у меня было 1,2, 1,3. Они между собой по бшке
[01:09:28.100 --> 01:09:32.860]  правильно упорядочены, ну потому что первый шаг такой, что у меня возрастание по b идет,
[01:09:32.860 --> 01:09:37.940]  потом я их стабильно сортирую по а, но если их значения равны, то я сохраняю их позиции просто.
[01:09:37.940 --> 01:09:44.180]  Тут, наверное, интереснее было бы увидеть вот это, например. Вот это переходит сюда, а это сюда.
[01:09:44.180 --> 01:09:49.380]  Их относительный порядок сохраняется, потому что сортировка стабильная, ну и это правильно,
[01:09:49.380 --> 01:09:53.580]  потому что сначала должно быть 1,2, потом 1,4. И именно из-за стабильности у меня получается
[01:09:53.580 --> 01:10:06.380]  корректность. Если у нас есть вообще quicksort, то можно вообще этого не делать? Нет, все-таки
[01:10:06.380 --> 01:10:13.020]  лучше сортировку почетом делать. Если k маленькая, смотрите, если k маленькая, то мы на все про все
[01:10:13.020 --> 01:10:20.300]  потратили вот столько времени. Наверное, это лучше там, ну зависит, конечно, от n и k, но обычно это
[01:10:20.300 --> 01:10:33.260]  лучше, чем n log n. Как это можно еще использовать кроме сортировки пар? Можно это использовать в так
[01:10:33.260 --> 01:10:56.140]  называемой паразрядной цифровой сортировке. Паразрядная цифровая сортировка. Вот, мы сейчас
[01:10:56.140 --> 01:11:17.180]  осмотрим то, что называется LSD, Lift Significant Digit. Значит, как работает? В чем была проблема
[01:11:17.180 --> 01:11:23.300]  сортировки под счетом просто чисел? В том, что числа могут быть большие. Если k там 10 в 9,
[01:11:23.300 --> 01:11:29.100]  то нам не хочется заводить массив размера 10 в 9. Представьте, если k 10 в 18 или даже еще больше.
[01:11:29.100 --> 01:11:37.140]  Так вот, давайте мы представим все наши числа как строки в десятичной системе
[01:11:37.140 --> 01:11:43.220]  числения. Ну или там можно было бы и в двоичную, давайте в десятичную. Значит, каждое число,
[01:11:43.220 --> 01:11:52.180]  не знаю там, в 128, например, это число вот такого вида, например, в десятичной системе
[01:11:52.180 --> 01:11:58.980]  числения. Если числа разные длины, то я могу их добить нужным числом нулей слева, чтобы они все
[01:11:58.980 --> 01:12:03.780]  были одинаковые длины. Я сейчас буду считать, что все числа будут у меня одинаковые длины в
[01:12:03.780 --> 01:12:10.300]  десятичной системе числения. Если что, я могу нулями слева добить. Тогда ее очень простая. Давайте
[01:12:10.300 --> 01:12:16.980]  мы, то есть вот у меня есть много таких чисел, описываемых как строки. Давайте я сначала их
[01:12:16.980 --> 01:12:23.580]  отсортирую по последней цифре, потом стабильно по предпоследней, потом стабильно по предпоследней
[01:12:23.580 --> 01:12:29.180]  и так далее, вплоть до самых старших битов, точнее вплоть до самых старших разрядов. Я утверждаю,
[01:12:30.020 --> 01:12:34.980]  что у меня получится правильная сортировка. Логика ровно такая же. Смотрите, что происходит
[01:12:34.980 --> 01:12:40.580]  после последнего шага. После последнего шага, когда я сортирую самые старшие разряды, у меня
[01:12:40.580 --> 01:12:45.640]  разные разряды, то есть, если у двух чисел различные первые разряды, они точно встанут
[01:12:45.640 --> 01:12:50.960]  как надо. Ну, например, если здесь было два, а здесь три, то после самой последней сортировки это
[01:12:50.960 --> 01:12:54.780]  будет раньше, чем вот это. Потому что так работает сортировка под счетом. Вот это будет раньше,
[01:12:54.780 --> 01:12:58.240]  лучшеerness чем это. Но, если же было какое-то
[01:12:58.240 --> 01:13:02.260]  число с одинаковом, ну, точнее, старшим разрядом,
[01:13:02.260 --> 01:13:04.780]  то поскольку последняя сортировка стабильна, то
[01:13:04.780 --> 01:13:07.820]  они сохранят свой порядок после вот этой предпоследней
[01:13:07.820 --> 01:13:10.720]  сортировки. То есть, они, наследуют свой порядок
[01:13:10.720 --> 01:13:14.480]  от вот этих кусочков. От всего, кроме старшего
[01:13:14.480 --> 01:13:17.960]  разряда. Ну ровно так числа и сравниваются. Если старшие
[01:13:17.960 --> 01:13:19.500]  разряды различные, то больше
[01:13:19.500 --> 01:13:21.840]  то, у кого больший разряд, вот этот вот старший. Если
[01:13:21.840 --> 01:13:24.640]  они одинаковые, то я как будто бы игнорирую старший
[01:13:24.640 --> 01:13:28.640]  разряд и сравниваю опять-таки все, начиная со второго разряда.
[01:13:28.640 --> 01:13:32.640]  То есть так можно сравнить большие числа за логами?
[01:13:32.640 --> 01:13:34.640]  Да, типа того.
[01:13:38.640 --> 01:13:40.640]  Так, понятно все здесь?
[01:13:40.640 --> 01:13:43.640]  Просто справа налево сортирую по разрядам.
[01:13:43.640 --> 01:13:45.640]  Стабильно каждый раз.
[01:13:45.640 --> 01:13:50.640]  Ну и соответственно, давайте напишем, что если все числа
[01:13:50.640 --> 01:13:57.640]  а0, а1 и так далее были опять-таки целыми от 0 до k,
[01:13:57.640 --> 01:14:06.640]  то этот алгоритм работает за...
[01:14:06.640 --> 01:14:13.640]  Ну, я напишу, видимо, n до лог k,
[01:14:13.640 --> 01:14:16.640]  но вот я здесь уточню, что по основанию 10.
[01:14:16.640 --> 01:14:19.640]  Пока вот я по вреднейшему уточню, основание 10.
[01:14:19.640 --> 01:14:23.640]  Но потому что у меня n-чисел, я запускаю вот столько сортировок,
[01:14:23.640 --> 01:14:26.640]  потому что у меня разрядов ровно столько,
[01:14:26.640 --> 01:14:30.640]  здесь число гриф мотка, столько разрядов,
[01:14:30.640 --> 01:14:33.640]  сколько разрядов, столько у меня будет
[01:14:33.640 --> 01:14:35.640]  стабильных сортировок подсчетом.
[01:14:35.640 --> 01:14:38.640]  Ну и каждая сортировка подсчетом работает за n.
[01:14:38.640 --> 01:14:41.640]  Точнее за n плюс 10, давайте я еще более повыпендриваюсь,
[01:14:41.640 --> 01:14:44.640]  напишу, здесь n плюс 10.
[01:14:44.640 --> 01:14:47.640]  Потому что сортировка подсчетом работает за количество чисел
[01:14:47.640 --> 01:14:50.640]  Ну, вот это вот k, да, плюс наибольшее значение числа.
[01:14:50.640 --> 01:14:52.640]  Да.
[01:14:52.640 --> 01:14:57.640]  Когда мы ставим, что 0,5 в целом число для объектов,
[01:14:57.640 --> 01:15:00.640]  для объектов, которые в штрафнении проявляют себя одинаковыми,
[01:15:00.640 --> 01:15:02.640]  мы же обязаны эти объекты сохранять,
[01:15:02.640 --> 01:15:05.640]  потому что мы можем просто в каунт сохранять,
[01:15:05.640 --> 01:15:07.640]  а потом вот так же.
[01:15:07.640 --> 01:15:11.640]  Но смотрите, в каунт я на самом деле не сохраняю объекты,
[01:15:11.640 --> 01:15:13.640]  я сохраняю количество объектов только.
[01:15:13.640 --> 01:15:16.640]  И вот здесь я когда делаю, смотрите, я иду справа-налево по массиву,
[01:15:16.640 --> 01:15:18.640]  то есть у меня массив исходный сохранен.
[01:15:18.640 --> 01:15:22.640]  Я считаю, на какое место надо его поставить,
[01:15:22.640 --> 01:15:24.640]  и ставлю его туда.
[01:15:24.640 --> 01:15:26.640]  То есть формально здесь надо было написать...
[01:15:26.640 --> 01:15:28.640]  Да, здесь все правильно написано, более-менее.
[01:15:28.640 --> 01:15:30.640]  То есть именно я смотрю на элемент,
[01:15:30.640 --> 01:15:32.640]  я смотрю на нужную его цифру, на очередную его цифру,
[01:15:32.640 --> 01:15:35.640]  знаю, где его надо поставить, ставлю его туда.
[01:15:35.640 --> 01:15:37.640]  Вроде все нормально.
[01:15:37.640 --> 01:15:39.640]  Что?
[01:15:39.640 --> 01:15:44.640]  Ну, потому что сортировка под счетом, напоминаю,
[01:15:44.640 --> 01:15:47.640]  если бы у меня были все числа от 0 до k,
[01:15:47.640 --> 01:15:49.640]  я бы просто одну сортировку под счетом сделал,
[01:15:49.640 --> 01:15:51.640]  то это было бы n плюс k.
[01:15:51.640 --> 01:15:53.640]  Ну, потому что мне нужно завести массив размера k,
[01:15:53.640 --> 01:15:55.640]  ну и так далее.
[01:15:55.640 --> 01:16:00.640]  Но здесь k это 10, потому что у меня значение в каждом разряде от 0 до 9.
[01:16:00.640 --> 01:16:02.640]  Поэтому n плюс 10.
[01:16:04.640 --> 01:16:06.640]  Ну, это вот, собственно, непосредственно
[01:16:06.640 --> 01:16:08.640]  именно паразрядная сортировка.
[01:16:08.640 --> 01:16:11.640]  Понятное дело, что можно это немножко улучшить,
[01:16:11.640 --> 01:16:14.640]  и, например, сортировать не по циферно,
[01:16:14.640 --> 01:16:16.640]  а, например, блоками из нескольких цифр.
[01:16:16.640 --> 01:16:21.640]  Там по 4, по 5, по 6 цифр вполне спокойно можно сортировать.
[01:16:21.640 --> 01:16:23.640]  Ну, потому что вот здесь вот эта вот плюс 10,
[01:16:23.640 --> 01:16:25.640]  понятно, это несодержательная добавка,
[01:16:25.640 --> 01:16:27.640]  а если бы я сортировал не по циферно,
[01:16:27.640 --> 01:16:29.640]  а, ну скажем, по миллионно,
[01:16:29.640 --> 01:16:34.640]  то есть я выбираю 6 разрядов и по ним сортирую,
[01:16:34.640 --> 01:16:36.640]  тогда здесь бы у меня было плюс 10 в шестой,
[01:16:36.640 --> 01:16:38.640]  это не очень страшно,
[01:16:38.640 --> 01:16:40.640]  но зато здесь логарифм значительно уменьшается,
[01:16:40.640 --> 01:16:42.640]  будет логарифм по основанию 10 в шестой.
[01:16:42.640 --> 01:16:44.640]  Потому что теперь у меня количество сортировок,
[01:16:44.640 --> 01:16:46.640]  которые я делаю,
[01:16:46.640 --> 01:16:48.640]  это логарифм k по основанию того,
[01:16:48.640 --> 01:16:51.640]  какое здесь максимальное значение числа берется.
[01:16:54.640 --> 01:16:56.640]  Ну, дальше уже как бы ваша фантазия.
[01:16:56.640 --> 01:16:58.640]  Сколько вам, если вам хочется это сделать,
[01:16:58.640 --> 01:17:00.640]  то вы можете сами подобрать там,
[01:17:00.640 --> 01:17:02.640]  ну да, можно менять систему числения, пожалуйста.
[01:17:02.640 --> 01:17:05.640]  Можно выбирать правильный размер блока,
[01:17:05.640 --> 01:17:08.640]  то есть по сколько разрядов одновременно вы сортируете.
[01:17:08.640 --> 01:17:10.640]  Ну и как-нибудь там подобрать,
[01:17:10.640 --> 01:17:12.640]  чтобы константа была прям супермаленькая,
[01:17:12.640 --> 01:17:14.640]  если надо.
[01:17:14.640 --> 01:17:16.640]  Это еще раз,
[01:17:16.640 --> 01:17:18.640]  это если сортировать не по циферно,
[01:17:18.640 --> 01:17:20.640]  то есть не по разрядно,
[01:17:20.640 --> 01:17:22.640]  а сразу по 6 разрядов за раз.
[01:17:22.640 --> 01:17:24.640]  То есть я считаю, что у меня число определяется
[01:17:24.640 --> 01:17:26.640]  не остатком по моделю 10,
[01:17:26.640 --> 01:17:28.640]  а остатком по моделю 10 в шестой.
[01:17:28.640 --> 01:17:30.640]  И тогда вот здесь у меня все числа будут
[01:17:30.640 --> 01:17:32.640]  не от 0 до 9,
[01:17:32.640 --> 01:17:34.640]  от 0 до миллиона минус 1,
[01:17:34.640 --> 01:17:36.640]  ну а сортировать числа от 0 до миллиона минус 1 я умею,
[01:17:36.640 --> 01:17:38.640]  сортировка под счетом.
[01:17:38.640 --> 01:17:40.640]  Так я сортировал по младшим 6 разрядам,
[01:17:40.640 --> 01:17:42.640]  потом по следующим 6,
[01:17:42.640 --> 01:17:44.640]  потом по следующим 6, опять стабильно каждый раз.
[01:17:44.640 --> 01:17:46.640]  То есть как бы я здесь
[01:17:46.640 --> 01:17:48.640]  не пользовался нигде
[01:17:48.640 --> 01:17:50.640]  тем, что я именно
[01:17:50.640 --> 01:17:52.640]  по циферно сортировал,
[01:17:52.640 --> 01:17:54.640]  я могу сортировать по 2, по 3 цифры одновременно.
[01:17:54.640 --> 01:17:56.640]  Да, да, так и было,
[01:17:56.640 --> 01:17:58.640]  там было просто плюс 10.
[01:18:00.640 --> 01:18:02.640]  Так, ну все, спасибо за внимание,
[01:18:02.640 --> 01:18:04.640]  до следующего раза.
[01:18:06.640 --> 01:18:08.640]  Аплодисменты.
