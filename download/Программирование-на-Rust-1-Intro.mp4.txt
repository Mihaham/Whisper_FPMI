[00:00.000 --> 00:10.020]  Значит так, я всех вас поздравляю, пришли на курс по самому замечательному современному
[00:10.020 --> 00:13.560]  языку, который я сейчас вам докажу, что гораздо
[00:13.560 --> 00:16.760]  лучше C++, который его превосходит на голову и который стоит
[00:16.760 --> 00:20.420]  изучать. Он в будущем будет активно использоваться
[00:20.420 --> 00:22.780]  во всех компаниях, но я в этом уверен, я попробую
[00:22.780 --> 00:26.760]  вас в этом убедить. Если вы не уверены, то в общем
[00:26.760 --> 00:31.240]  для вас первая половина лекции. Давайте начнем.
[00:31.240 --> 00:33.800]  Для начала вообще о чем курс. Мы будем изучать здесь
[00:33.800 --> 00:36.640]  основы всякого синтаксиса, коллекции, ну там знаете
[00:36.640 --> 00:40.720]  битремэп, хэшмэп и подобные штуки. Потом будем изучать
[00:40.720 --> 00:44.040]  что такое трейты, ну это уже особенность Раста, которая
[00:44.040 --> 00:48.120]  похожа на концепты в плюсах, ну и на интерфейс. Мы будем
[00:48.120 --> 00:51.880]  сравнивать это. Потом будут всякие найтли фичи, например
[00:51.880 --> 00:57.960]  trade specialization. Будет параллел в карт-компьютинг, ну это
[00:57.960 --> 01:01.640]  для тех, кто не знает курс TPMS. Ну мало ли тут есть
[01:01.640 --> 01:03.800]  второкурсники. Кстати есть тут второкурсники сейчас
[01:03.800 --> 01:07.080]  прямо на лекции. Вот есть целый один второкурсник,
[01:07.080 --> 01:11.760]  кажется. Два. Отлично. К нам зашли те, кто чисто
[01:11.760 --> 01:16.400]  заинтересован в том, чтобы изучать язык. Потом метапрограммирование.
[01:16.400 --> 01:19.400]  Опять же, кто не знает, метапрограммирование это код генерации.
[01:19.480 --> 01:24.280]  Раста, она оформлена не только как, знаете, там template
[01:24.280 --> 01:28.120]  metaprogramming, как оно в плюсах, но также есть макросы. А макросы
[01:28.120 --> 01:31.800]  умеют даже, например, ходить в сеть, в базы данных и
[01:31.800 --> 01:34.360]  все такое. То есть это такая очень продвинутая штука
[01:34.360 --> 01:39.160]  код на Расте, которая генерирует код на Расте прямо внутри.
[01:39.160 --> 01:43.480]  Изучим всякий туллинг. Ну, например, там будут анализаторы
[01:43.480 --> 01:50.680]  вроде Мири, которые проверяют unsaved код на defined behavior и
[01:50.680 --> 01:55.000]  подобные вещи. Ну и во время курса вы еще будете пользоваться
[01:55.000 --> 01:59.640]  очень часто Clippy и FMT. И тем самым вы узнаете, как писать
[01:59.640 --> 02:03.400]  идиоматичный код на Расте. В крайней мере, я надеюсь на то,
[02:03.400 --> 02:06.440]  что пока вы будете писать код и если вас форсить к тому,
[02:06.440 --> 02:08.920]  чтобы вы использовали FMT и Clippy, то в таком случае
[02:08.920 --> 02:12.280]  у вас должно получиться так, что вы в себя берете
[02:12.280 --> 02:17.800]  все концепции Раста, как на нем писать код идиоматично.
[02:17.800 --> 02:22.600]  Ну, по крайней мере, в шаде получилось, на мой взгляд.
[02:22.600 --> 02:26.040]  Ну и System Safety. System Safety — это про систему типов. Это то,
[02:26.040 --> 02:28.520]  что, собственно, делает Раст безопасным. Мы сейчас
[02:28.520 --> 02:30.600]  обсудим, что такое вообще безопасность и в чем особенность
[02:30.600 --> 02:36.800]  Раста. Так, и пререквизиты. Нам понадобится знание
[02:36.800 --> 02:40.520]  плюсов. Без них мы никуда не денемся. Мы будем очень
[02:40.520 --> 02:43.740]  часто с плюсами сравниваться. Этот курс рассчитан на
[02:43.740 --> 02:48.040]  тех, кто знает C++ уже. Потом нам понадобится понимание
[02:48.040 --> 02:51.320]  конкарантия, потому что иначе будет примерно пара лекций
[02:51.320 --> 02:55.320]  по параллелиям с распределенным вечеслением и на них вы будете
[02:55.320 --> 02:58.400]  плавать, если не будете проходить. Не пройдете достаточно
[02:58.400 --> 03:03.040]  хорошо этот курс. Понадобится знание окоса. Окос нам
[03:03.040 --> 03:05.240]  будет вообще беспрерывно помогать, по сути. То есть
[03:05.240 --> 03:08.360]  нам нужно понимать, как внутри устроены, как лежат
[03:08.360 --> 03:12.760]  типы в памяти, как устроена наша операционная система.
[03:12.760 --> 03:14.640]  И, в частности, на последние лекции мы вообще будем
[03:14.640 --> 03:18.760]  рассуждать, как ускорять код на Расте. В том числе
[03:18.760 --> 03:22.520]  специфичным, например, для Линукса, Link Time Optimization,
[03:22.520 --> 03:26.680]  подобные вещи. Ну и, конечно же, если вы, наверное, занимаетесь
[03:26.680 --> 03:29.040]  фронтендом и подобными вещами, то, наверное, вам Раст не
[03:29.040 --> 03:33.240]  так интересен, поэтому очень важно, чтобы вас интересовала
[03:33.320 --> 03:38.240]  кент-разработка. Ну что, все готовы? Есть какие-нибудь
[03:38.240 --> 03:43.160]  вопросы по организации курса? Хорошо, я постараюсь
[03:43.160 --> 03:52.160]  говорить громче, так нормально. Я их сюда не написал, но
[03:52.160 --> 03:54.680]  вообще у нас домашки будут. Пока что вы репозиторий
[03:54.680 --> 04:01.520]  не видите. Он появится сегодня-завтра примерно. И еще примерно
[04:01.520 --> 04:04.480]  в течение месяца, то есть до первого дедлайна гарантированно
[04:04.480 --> 04:07.520]  уже будет настроена ACI, в которую быстро, как на курсе
[04:07.520 --> 04:09.480]  Рома Липовского, точно так же отправлять задачки.
[04:09.480 --> 04:20.400]  В плане, ну вообще, что они представляют? Сколько времени
[04:20.400 --> 04:26.480]  занимает сделать ДЗ, я так понимаю? Это Depends. Если делать
[04:26.480 --> 04:30.600]  на U3, то очень просто. А если на U10, то будет крайне
[04:30.600 --> 04:33.600]  сложно. Там домашки будут занимать, наверное, часов
[04:33.600 --> 04:37.720]  20-30 неделю, а на U3 вы сделаете все буквально за первый
[04:37.720 --> 04:40.640]  месяц и все. И первый месяц он будет для вас очень
[04:40.640 --> 04:44.600]  простым. То есть там задач буквально 10-12. Я не буквально
[04:44.600 --> 04:49.800]  по самому основному языку. Ну, в среднем я бы сказал,
[04:49.800 --> 04:54.280]  если все делать, наверное, часов 20 в неделю нужно будет
[04:54.280 --> 05:00.520]  на курсе. Это если прям вообще все делать на U10. Еще какие-нибудь
[05:00.520 --> 05:07.160]  вопросы? Ну что, давайте мы сначала поговорим о том,
[05:07.160 --> 05:12.760]  зачем RAST был придуман, как он появился. У нас с самого
[05:12.760 --> 05:15.360]  начала были машинные коды. Когда появились первые
[05:15.360 --> 05:19.920]  компьютеры, были перфокарты, и на перфокартах убивали
[05:19.920 --> 05:23.680]  собственно код, который исполнялся на компьютере.
[05:23.680 --> 05:25.920]  Преимущество было в том, что мы, конечно, исполняли
[05:25.920 --> 05:29.560]  ровно тот код, который забили. И более того, вы перфокарту
[05:29.560 --> 05:32.880]  вставили, и больше ничего компьютеру не надо. Код
[05:32.880 --> 05:36.000]  исполняет, который вы убили оттуда внутрь. Но очень
[05:36.000 --> 05:38.160]  легко сделать ошибку. То есть вы просто банально
[05:38.160 --> 05:40.480]  неправильную инструкцию убили, и теперь вот вы сидите
[05:40.480 --> 05:44.200]  и не знаете, где же ваша ошибка. Такой код очень сложно
[05:44.200 --> 05:49.200]  читать по тем же причинам и сложно дебажить. Его практически
[05:49.200 --> 05:53.080]  невозможно переиспользовать. И для того, чтобы сделать
[05:53.080 --> 05:54.800]  сложную программу, ну, сложную программу вообще в целом
[05:54.800 --> 05:57.360]  невозможно сделать на перфокартах. Это, представьте, вот такую
[05:57.360 --> 06:04.360]  штуку. Огромное количество карточек. Вот. Ну и, собственно,
[06:04.360 --> 06:07.240]  даже на простую программу уходил много времени. И
[06:07.240 --> 06:10.800]  код менялся от машины к машине. Потом люди, конечно,
[06:10.800 --> 06:12.640]  поняли, что перфокарты не очень. Давайте прямо на
[06:12.640 --> 06:15.160]  компьютерах писать. Вот появился ассемблер, появился ассемблер
[06:15.160 --> 06:19.960]  на инструкции на английском. Вот. Те же самые преимущества.
[06:19.960 --> 06:23.160]  Мы напрямую исполняем код, который мы написали. Мы
[06:23.160 --> 06:27.120]  не требуем никакого ронтайма вокруг. И теперь уже невозможно
[06:27.120 --> 06:30.200]  написать код, которого просто нет. Потому что у нас транслятор
[06:30.200 --> 06:32.560]  ассемблера, он просто проверяет, если он не понимает, что
[06:32.560 --> 06:36.240]  за инструкцию он ее запрещает. Поэтому мы, обращая внимание,
[06:36.240 --> 06:39.240]  мы избавились от какого-то класса ошибок за счет того,
[06:39.240 --> 06:43.960]  что у нас язык так устроен. Вот. Но нам все еще сложно
[06:43.960 --> 06:47.880]  дебажить, сложно писать сложную логику, сложно переиспользовать
[06:47.880 --> 06:53.680]  такой код. И, опять же, ну, много времени нужно, чтобы
[06:53.680 --> 07:03.040]  написать его. Потом появился си. Си, язык это, си, язык
[07:03.040 --> 07:05.680]  прекрасный. Он до сих пор используется активно,
[07:05.680 --> 07:09.680]  как вы прекрасно знаете. И, в отличие от ассемблера,
[07:09.680 --> 07:12.960]  он уже дает некоторый уровень абстракции. Потому что
[07:12.960 --> 07:15.800]  мы уже не пишем непосредственно под машину. Мы пишем логику
[07:15.800 --> 07:18.320]  самого кода. Иногда нам, конечно, приходится спускаться
[07:18.320 --> 07:20.600]  на уровень ассемблера, когда мы, например, пишем всякие
[07:20.600 --> 07:26.600]  драйвера или подобные вещи. Но большую часть времени,
[07:26.600 --> 07:34.080]  в общем-то, надо... В общем, забудьте последние слова.
[07:34.080 --> 07:38.400]  Так. Ну, этот язык немножко сложен, потому что, на
[07:38.400 --> 07:41.200]  самом деле, он требует того, чтобы мы вручную управляли
[07:41.200 --> 07:43.880]  памятью. И, соответственно, мы получаем всякие секволты,
[07:43.880 --> 07:49.240]  буферы ворфлоуст, там есть нул-указатели, датарейсы,
[07:49.320 --> 07:54.320]  в конце концов, undefined behaviors, которым вы наверняка сталкивались.
[07:54.320 --> 07:57.440]  Он не очень продуктивен, потому что все-таки, по сравнению
[07:57.440 --> 08:01.040]  с какими-то современными языками, например, C-sharp,
[08:01.040 --> 08:05.000]  как-то синтаксического сахара не хватает. Хочется иногда
[08:05.000 --> 08:09.560]  написать кумит лямб, дуалямб никаких нет. И вот тоже
[08:09.560 --> 08:12.840]  один из серьезных недостатков — нет общей системы сборки.
[08:12.840 --> 08:15.640]  То есть вы захотите, например, сделать какой-то... Скомпилировать
[08:15.640 --> 08:21.120]  сложный код из многих файлов, большую систему. И дело в том,
[08:21.120 --> 08:23.880]  что в случае C у вас нет никакого общего решения.
[08:23.880 --> 08:28.960]  У вас там есть CMake, скажем, Bazel, Ninja, на Ninja основывается
[08:28.960 --> 08:33.640]  Mesa, ну, такие вот системы сборки. Но общего решения
[08:33.640 --> 08:36.680]  нет. Каждой компанией оно свое обычно. Давайте мы
[08:36.680 --> 08:39.560]  вспомним, что такое undefined behavior, чтобы начать бояться
[08:39.560 --> 08:43.440]  снова. Смотрите, вот есть такая въязвимость
[08:43.440 --> 08:50.560]  CVE, она была в Gleap C. Она как устроена? В общем-то, в Gleap C
[08:50.560 --> 08:58.080]  был такой баг, из-за которого была уязвимость в OpenSSL. Srandom
[08:58.080 --> 09:01.040]  — это такая функция, которая ставит seed для генератора
[09:01.040 --> 09:05.080]  случайных чисел. И в чем уязвимость заключается?
[09:05.080 --> 09:07.880]  У нас там был какой-то код, который, когда не мог
[09:07.880 --> 09:13.120]  читать из defrandom случайные биты, он пытался их сгенерировать.
[09:13.160 --> 09:19.000]  То есть, перед этим вызываю вот такой вот код, который вы видите на слайде.
[09:19.000 --> 09:23.720]  Вот скажите, что тут не так в этом коде? Кто-нибудь видит его?
[09:23.720 --> 09:29.800]  Так, кто-нибудь еще? Так, хорошо, Андрей, что?
[09:29.800 --> 09:33.320]  — Ну, вот тут у нас происходит чтение внинициализируя переменные.
[09:33.320 --> 09:36.480]  — Да, у нас тут есть внинициализированная переменная на стеке.
[09:36.480 --> 09:40.400]  Вот, и дело в том, что, так как это undefined behavior, компилятор
[09:40.440 --> 09:44.720]  думает, ну, в общем-то, раз undefined behavior, значит, этот код недостижим,
[09:44.720 --> 09:48.240]  такого быть не может, и вообще, в общем-то, мы можем делать с этим кодом все, что захотим.
[09:48.240 --> 09:52.520]  И однажды он такой взял и просто удалил вот это вот все.
[09:52.520 --> 09:59.320]  Ну, и получилась уязвимость, потому что мы могли банально на стеке сделать нужный нам мусор.
[09:59.320 --> 10:05.280]  И, соответственно, у нас было зерно, которое мы уже заранее знали.
[10:05.280 --> 10:08.920]  Вот. Потом у нас есть memory unsafety.
[10:08.920 --> 10:17.720]  Memory unsafety — это когда вы допускаете доступ, как сказать, читаете из памяти,
[10:17.720 --> 10:21.120]  которую вам читать нельзя, в общем-то.
[10:21.120 --> 10:26.120]  Проблема в том, что у вас процесс имеет доступ ко всей памяти процесса.
[10:26.120 --> 10:29.320]  И когда вы так читаете, у вас сайд-эффекты просто непредсказуемы.
[10:29.320 --> 10:32.800]  Вот, например, какая беда вот в этом коде?
[10:32.800 --> 10:40.840]  Можно по громче, пожалуйста.
[10:40.840 --> 10:54.640]  На самом деле, тут все очень просто.
[10:54.640 --> 10:57.040]  Что еще раз?
[10:57.640 --> 10:59.640]  Какие-то проблемы с реаллокацией?
[10:59.640 --> 11:01.200]  Нет.
[11:01.200 --> 11:03.200]  Ну, память на стеке же выделена.
[11:03.200 --> 11:05.200]  Да, память на стеке.
[11:05.200 --> 11:07.200]  Ну, да, у нас...
[11:07.200 --> 11:14.640]  Берем указатель на стековой памяти, возможно, могут изникнуть какие-то проблемы.
[11:14.640 --> 11:16.640]  Гитлайн кажется реалоцирует.
[11:16.640 --> 11:20.640]  Да, кажется, гитлайн реалоцирует.
[11:20.640 --> 11:24.320]  И дело в том, что эта память на стеке пытается реалоцировать память на стеке.
[11:24.320 --> 11:31.520]  И, в общем-то, это очень плохо, если вы вдруг решили записать больше чем 4024 бита вайта.
[11:31.520 --> 11:34.120]  Ну, и слойте, соответственно, memory and safety.
[11:34.120 --> 11:41.400]  Доступ к... Ну, сначала вы попробуете очистить память, которая вообще-то не была реалоцирована.
[11:41.400 --> 11:45.200]  Ну, и потом уже дальше сайд-эффекты вообще непредсказуемы.
[11:45.200 --> 11:48.040]  Есть еще такая замечательная история про мем-копию.
[11:48.040 --> 11:51.240]  Я думаю, вы все помните вот такую вот функцию.
[11:51.480 --> 11:53.480]  Особенно, если вы проходили курс-окос.
[11:53.480 --> 11:56.480]  В общем-то, у мем-копии есть такая особенность.
[11:56.480 --> 12:04.480]  Она требует, чтобы в области памяти, из которой вы копируете и в которой вы копируете, не пересекались.
[12:04.480 --> 12:06.000]  Это контракт.
[12:06.000 --> 12:11.000]  Но однажды пришли такие разработчики из Intel.
[12:11.000 --> 12:13.000]  Просто вот у них процессоры такие вот новые были.
[12:13.000 --> 12:17.000]  Они решили, что теперь мы будем копироваться с левого направа, с правого налевого.
[12:17.000 --> 12:19.000]  Потому что так быстрее на наших процессорах работает.
[12:19.000 --> 12:21.000]  Ну, в принципе, все логично, оно должно работать.
[12:21.760 --> 12:23.760]  Потому что они не пересекаются.
[12:23.760 --> 12:29.760]  Но однажды, после того, как они закомитили это, чуть-чуть попозже, осенью,
[12:29.760 --> 12:33.760]  в одной из бета-сборок Fedora Linux, юзер запускает такой флэш-плеер,
[12:33.760 --> 12:39.760]  а он вместо того, чтобы издавать звук, выдаёт треск.
[12:39.760 --> 12:43.760]  И когда это ресерчили, выяснили, что в общем-то там была проблема в том,
[12:43.760 --> 12:45.760]  что пересекались в области памяти.
[12:45.760 --> 12:49.760]  Ну, а кто виноват вот в том, что вот это произошло вообще?
[12:50.520 --> 12:52.520]  Есть две разные точки зрения.
[12:54.520 --> 12:57.520]  Вот разработчики Gleap C и, собственно, Linux оторвались.
[12:59.520 --> 13:03.520]  Один говорит, что виноваты те, кто пишет такое ужасное ПО,
[13:03.520 --> 13:09.520]  а второй говорит, что вы можете говорить всё, что угодно про это.
[13:09.520 --> 13:11.520]  Но, в общем-то, если им копия сам не предупреждает про это,
[13:11.520 --> 13:14.520]  а нет никакого покрытия тестами, то вы сами виноваты.
[13:14.520 --> 13:17.520]  Даже самое хорошее программное обеспечение может иметь баги.
[13:18.280 --> 13:19.280]  Вот.
[13:19.280 --> 13:21.280]  Забегай наперёд.
[13:21.280 --> 13:25.280]  Rust это про второе, а C++ скорее про первое.
[13:27.280 --> 13:28.280]  Вот.
[13:29.280 --> 13:32.280]  Наконец-то давайте вот мы C немножко посмотрели на C,
[13:32.280 --> 13:34.280]  теперь посмотрим на C++.
[13:34.280 --> 13:36.280]  C++ такой язык, который не требует runtime.
[13:36.280 --> 13:38.280]  Конечно, со звёздочкой немножко runtime есть.
[13:38.280 --> 13:42.280]  Там нужно всякие exception-ы ловить, stack unwinding,
[13:42.280 --> 13:43.280]  такие вот вещи.
[13:43.280 --> 13:45.280]  Ну, можно сказать, что, в общем-то, runtime нет.
[13:46.040 --> 13:50.040]  Ну, например, garbage collector такие вещи.
[13:50.040 --> 13:52.040]  Ну, ещё одна программа, которая работает сейчас.
[13:54.040 --> 13:55.040]  Вот.
[13:55.040 --> 13:56.040]  Не нужен никакой runtime.
[13:56.040 --> 13:57.040]  Не...
[13:57.040 --> 14:00.040]  Поддерживает, ну, даёт большой толстый уровень абстракции.
[14:02.040 --> 14:05.040]  У вас там есть всякие лямбды, темплейты, классы,
[14:05.040 --> 14:07.040]  то есть прям такое OOP.
[14:07.040 --> 14:13.040]  И у вас очень-очень толстый слой между вашим железом
[14:13.040 --> 14:14.040]  и между вашей программой.
[14:14.800 --> 14:16.800]  То есть вы, по сути, пишете уже код абсолютно отдельно
[14:16.800 --> 14:17.800]  от вашего железа.
[14:18.800 --> 14:20.800]  На C++ вы, конечно, можете очень легко спуститься
[14:20.800 --> 14:21.800]  до нужного уровня.
[14:22.800 --> 14:24.800]  Ну, вообще, это выска уровня у языка.
[14:25.800 --> 14:27.800]  Недостаток в том, что никуда не ушли недостатки C
[14:27.800 --> 14:31.800]  про seek fault, entified behavior, memory and safety и так далее.
[14:32.800 --> 14:35.800]  Ещё, как мне кажется, такой ужасный минус,
[14:35.800 --> 14:37.800]  это то, что там просто...
[14:38.800 --> 14:40.800]  Ну, стандарт плюсов, оно так исторически получилось.
[14:40.800 --> 14:42.800]  Они долго пытались поддерживать
[14:43.560 --> 14:45.560]  всё то, что есть в C,
[14:45.560 --> 14:47.560]  и в конце концов просто
[14:47.560 --> 14:49.560]  получилось так, что стандарт и CMS.
[14:51.560 --> 14:53.560]  Там очень много ошибок, и мы будем их обсуждать,
[14:53.560 --> 14:55.560]  когда мы будем смотреть на то, как устроен Rust.
[14:56.560 --> 14:58.560]  Ну, и точно так же нет общей системы сборки.
[15:00.560 --> 15:02.560]  Давайте опять посмотрим на плюсовое OOP.
[15:03.560 --> 15:05.560]  Кто-нибудь знает, что за проблема вот тут
[15:05.560 --> 15:07.560]  в этом вот коде?
[15:13.560 --> 15:15.560]  Так, ну давайте я тогда подскажу.
[15:15.560 --> 15:17.560]  Ну, у нас createStreams,
[15:17.560 --> 15:19.560]  это какая-то функция, которая возвращает вектор строк.
[15:19.560 --> 15:21.560]  И, в общем-то, это временный объект
[15:21.560 --> 15:23.560]  в случае этого фора.
[15:23.560 --> 15:25.560]  Вот мы возвращаем временный объект,
[15:25.560 --> 15:27.560]  потом у нас add 0,
[15:27.560 --> 15:29.560]  то есть мы берём строк на нулевом индексе.
[15:29.560 --> 15:31.560]  Но дело в том, что по стандарту плюсов
[15:31.560 --> 15:33.560]  у нас так работает
[15:33.560 --> 15:35.560]  диструк...
[15:35.560 --> 15:37.560]  диструк...
[15:37.560 --> 15:39.560]  диструк...
[15:39.560 --> 15:41.560]  диструк...
[15:42.320 --> 15:44.320]  удаление временных объектов,
[15:44.320 --> 15:46.320]  что в тот момент, когда мы сделаем
[15:46.320 --> 15:48.320]  add 0, то в таком случае у нас
[15:48.320 --> 15:50.320]  уже будет вектор диалацирован,
[15:50.320 --> 15:52.320]  потому что временный объект всё уже закончил
[15:52.320 --> 15:54.320]  с временем жизни, мы пришли типа к другому.
[15:54.320 --> 15:56.320]  И в итоге у нас это
[15:56.320 --> 15:58.320]  будет сцентрироваться по памяти,
[15:58.320 --> 16:00.320]  которая не инициализирована.
[16:00.320 --> 16:02.320]  Это undefinedBehaviour.
[16:02.320 --> 16:04.320]  К моменту вызову функции add,
[16:04.320 --> 16:06.320]  результат выключённой createStreams
[16:06.320 --> 16:08.320]  уже будет иничтожен?
[16:08.320 --> 16:10.320]  Сейчас к моменту вызову add функции?
[16:11.080 --> 16:12.080]  А, add.
[16:12.080 --> 16:14.080]  После add, когда ты зайдёшь в цикл,
[16:14.080 --> 16:16.080]  у тебя будет уже чар
[16:16.080 --> 16:18.080]  взятый из функции
[16:18.080 --> 16:20.080]  и строки, которая уже удалена.
[16:20.080 --> 16:22.080]  Но, естественно, когда ты пойдёшь к следующей,
[16:22.080 --> 16:24.080]  ты вообще уже по неинциализированной памяти будешь ходить.
[16:26.080 --> 16:28.080]  Ну да, мы хотим, чтобы вы не показали,
[16:28.080 --> 16:30.080]  и он как-то, я вот так понимаю.
[16:30.080 --> 16:32.080]  Так.
[16:32.080 --> 16:34.080]  Ну, смотрите.
[16:34.080 --> 16:36.080]  Есть такой отмен, который в профункторе буквально пару часов назад
[16:36.080 --> 16:38.080]  появился.
[16:38.080 --> 16:40.080]  Эта вот штука
[16:40.080 --> 16:42.080]  в общем-то был пропозал, который должен был починить эту штуку
[16:42.080 --> 16:44.080]  в 23 стажете плюсов,
[16:44.080 --> 16:46.080]  но его, в общем-то,
[16:46.080 --> 16:48.080]  зарежектили, и теперь до 26
[16:48.080 --> 16:50.080]  плюсов как минимум это не починится.
[16:50.080 --> 16:52.080]  И, в общем-то, если вы хотите дальше
[16:52.080 --> 16:54.080]  работать с языком, который
[16:54.080 --> 16:56.080]  беспрерывно что-то реджекти,
[16:56.080 --> 16:58.080]  то можете продолжать.
[16:58.080 --> 17:00.080]  Ну, это не совсем правда, потому что есть ещё
[17:00.080 --> 17:02.080]  дефек-репорты, так что если совсем повезёт,
[17:02.080 --> 17:04.080]  этот патч привезёт
[17:04.080 --> 17:06.080]  к дефек-репорту, примерно.
[17:06.080 --> 17:08.080]  Если очень сильно повезёт, только.
[17:08.080 --> 17:10.080]  Ну, стандарт
[17:10.080 --> 17:12.080]  очень плохо развивается.
[17:12.080 --> 17:14.080]  В плюсах это факт.
[17:14.080 --> 17:16.080]  Он уже как-то забораживается.
[17:18.080 --> 17:20.080]  Так, а теперь давайте посмотрим
[17:20.080 --> 17:22.080]  на другой класс языков, который развивался параллельно.
[17:22.080 --> 17:24.080]  Это всякие языки, у которых есть
[17:24.080 --> 17:26.080]  garbage collection. Java, C-Sharp,
[17:26.080 --> 17:28.080]  подобное.
[17:28.080 --> 17:30.080]  У них runtime в принципе достаточно
[17:30.080 --> 17:32.080]  быстрее, потому что там just-in-time
[17:32.080 --> 17:34.080]  компиляция, она начинает быстро там
[17:34.080 --> 17:36.080]  по горячим путям оптимизировать всё,
[17:36.080 --> 17:38.080]  то есть видеть какие функции чаще вызываются
[17:38.080 --> 17:40.080]  и лайнит их автоматически.
[17:40.080 --> 17:42.080]  Это, конечно, зачастую всё ещё
[17:42.080 --> 17:44.080]  медленнее, чем языки
[17:44.080 --> 17:46.080]  вроде плюсов
[17:46.080 --> 17:48.080]  или C, потому что всё-таки
[17:48.080 --> 17:50.080]  вы это делаете в runtime,
[17:50.080 --> 17:52.080]  а не просто в compile-time.
[17:52.080 --> 17:54.080]  И, в общем-то,
[17:54.080 --> 17:56.080]  зачастую не так быстро.
[17:56.080 --> 17:58.080]  У них достаточно много
[17:58.080 --> 18:00.080]  абстракций зачастую.
[18:00.080 --> 18:02.080]  Вы можете запускать код
[18:02.080 --> 18:04.080]  везде, где есть runtime, то есть вам не нужно
[18:04.080 --> 18:06.080]  дождаться, пока перенесут компилятор.
[18:06.080 --> 18:08.080]  Если у вас есть runtime, то вы уже запускаете свой код
[18:08.080 --> 18:10.080]  спокойно.
[18:10.080 --> 18:12.080]  Например, там есть Java JIT,
[18:12.080 --> 18:14.080]  Java Virtual Machine.
[18:14.080 --> 18:16.080]  В C-Sharp
[18:16.080 --> 18:18.080]  CLR, по-моему,
[18:18.080 --> 18:20.080]  так называется.
[18:20.080 --> 18:22.080]  Эти языки безопаснее, чем C
[18:22.080 --> 18:24.080]  или C++, потому что они уже не позволяют
[18:24.080 --> 18:26.080]  не дают
[18:26.080 --> 18:28.080]  Memorian Safety.
[18:28.080 --> 18:30.080]  Но, тем не менее, всякие штуки вроде
[18:30.080 --> 18:32.080]  Data Races у вас никуда не ушли.
[18:32.080 --> 18:34.080]  То есть, например, в Java
[18:34.080 --> 18:36.080]  выкидываются Exception, если вы пытаетесь
[18:36.080 --> 18:38.080]  к одной переменности наскольких поток
[18:38.080 --> 18:40.080]  обратиться, и при этом
[18:40.080 --> 18:42.080]  вы никак не синхронизируетесь.
[18:42.080 --> 18:44.080]  Или, например, к структуре данных,
[18:44.080 --> 18:46.080]  которая предположительно
[18:46.080 --> 18:48.080]  должна была быть однопоточной.
[18:50.080 --> 18:52.080]  Давайте ещё посмотрим на минусы.
[18:54.080 --> 18:56.080]  В общем-то, Garbage Collection
[18:56.080 --> 18:58.080]  достаточно дорого.
[18:58.080 --> 19:00.080]  Вы не можете заранее предсказать, какой у вас
[19:00.080 --> 19:02.080]  есть тв-хет по памяти
[19:02.080 --> 19:04.080]  Garbage Collection.
[19:04.080 --> 19:06.080]  Потом вы не знаете, в какой момент у вас
[19:06.080 --> 19:08.080]  может ГЦ вызваться.
[19:08.080 --> 19:10.080]  Это тоже нужно учитывать.
[19:12.080 --> 19:14.080]  И, в общем-то,
[19:14.080 --> 19:16.080]  из-за этого использовать
[19:16.080 --> 19:18.080]  серверных приложений достаточно бывает
[19:18.080 --> 19:20.080]  дорого. Например, на сервере вы не хотите,
[19:20.080 --> 19:22.080]  чтобы у вас на несколько секунд
[19:22.080 --> 19:24.080]  он просто завис, потому что у вас
[19:24.080 --> 19:26.080]  запустился ГЦ.
[19:26.080 --> 19:28.080]  В частности, мы сейчас рассмотрим такие истории.
[19:30.080 --> 19:32.080]  Смотрите, это дискорд.
[19:32.080 --> 19:34.080]  Он переписывал часть своего кода с ГО на РАСТ.
[19:34.080 --> 19:36.080]  ГО тоже современный язык,
[19:36.080 --> 19:38.080]  простой, хороший.
[19:38.080 --> 19:40.080]  Он с ГЦ.
[19:42.080 --> 19:44.080]  Они переписали всё на РАСТ.
[19:44.080 --> 19:46.080]  Почему переписали? Потому что вы можете
[19:46.080 --> 19:48.080]  заметить такие спайки.
[19:48.080 --> 19:50.080]  РАСТ примерно в 2 минуты.
[19:50.080 --> 19:52.080]  Это вызывался
[19:52.080 --> 19:54.080]  Garbage Collection, и из-за этого у них был
[19:54.080 --> 19:56.080]  такой неравномерный
[19:56.080 --> 19:58.080]  latency. На latency это время
[19:58.080 --> 20:00.080]  от прихода запроса до ответа.
[20:00.080 --> 20:02.080]  А он постоянно
[20:02.080 --> 20:04.080]  прыгал. То есть был то небольшой,
[20:04.080 --> 20:06.080]  то потом резко увеличивался.
[20:06.080 --> 20:08.080]  Из-за паузы ГЦ.
[20:08.080 --> 20:10.080]  Им это не нравилось, они переписали всё
[20:10.080 --> 20:12.080]  на РАСТ, который
[20:12.080 --> 20:14.080]  без ГЦ и работает примерно
[20:14.080 --> 20:16.080]  как плюсы здесь.
[20:20.080 --> 20:22.080]  А графики не запостились вас?
[20:22.080 --> 20:24.080]  Графики не запостились вас?
[20:24.080 --> 20:26.080]  Графики не запостились вас?
[20:26.080 --> 20:28.080]  Не запустили, там есть ссылочка,
[20:28.080 --> 20:30.080]  можно посмотреть. Прямо можно быть открыть
[20:30.080 --> 20:32.080]  презентацию.
[20:32.080 --> 20:34.080]  То же самое
[20:34.080 --> 20:36.080]  писали в линкетине.
[20:36.080 --> 20:38.080]  Что у них были
[20:38.080 --> 20:40.080]  большие паузы по 5 секунд
[20:40.080 --> 20:42.080]  целых в их приложениях на Джава.
[20:42.080 --> 20:44.080]  Вы тоже можете почитать статью здесь
[20:44.080 --> 20:46.080]  по ссылочке.
[20:46.080 --> 20:48.080]  Ну и давайте дальше
[20:48.080 --> 20:50.080]  посмотрим. У нас
[20:50.080 --> 20:52.080]  всякие языки вроде Джава,
[20:52.080 --> 20:54.080]  например, не позволяют
[20:54.080 --> 20:56.080]  делать всякие мануальные оптимизации.
[20:56.080 --> 20:58.080]  Мне, кстати говоря,
[20:58.080 --> 21:00.080]  вот один из фактов,
[21:00.080 --> 21:02.080]  я не эксперт Джава, но знаю один из фактов,
[21:02.080 --> 21:04.080]  например, что их генерики
[21:04.080 --> 21:06.080]  работают так, что они
[21:06.080 --> 21:08.080]  в самом начале компилируются код, а уже потом
[21:08.080 --> 21:10.080]  подставляется тип. В то время, как
[21:10.080 --> 21:12.080]  например, в том же C++, который вы уже
[21:12.080 --> 21:14.080]  знаете, ну и в РАСТ в частности,
[21:14.080 --> 21:16.080]  в самом начале подставляется тип,
[21:16.080 --> 21:18.080]  а потом уже копируется. Соответственно
[21:18.080 --> 21:20.080]  раз сколько там нужно для каждого
[21:20.080 --> 21:22.080]  типа класса,
[21:22.080 --> 21:24.080]  а потом уже он оптимизируется
[21:24.080 --> 21:26.080]  и, соответственно, специфичные для типа
[21:26.080 --> 21:28.080]  оптимизации появляются,
[21:28.080 --> 21:30.080]  что гораздо быстрее.
[21:30.080 --> 21:32.080]  Ну и соответственно
[21:32.080 --> 21:34.080]  мануальная оптимизация, как я написал на слайде,
[21:34.080 --> 21:36.080]  у нас ГЦ
[21:36.080 --> 21:38.080]  оптимизирует в последние случаи
[21:38.080 --> 21:40.080]  всякие использования памяти и, соответственно,
[21:40.080 --> 21:42.080]  ну всякие вещи
[21:42.080 --> 21:44.080]  связанные с когерентностью кэшей, например,
[21:44.080 --> 21:46.080]  не можем оптимизировать.
[21:46.080 --> 21:48.080]  Beta Interoperability
[21:48.080 --> 21:50.080]  Кто-нибудь знает, что это значит?
[21:54.080 --> 21:56.080]  Да, это про то, как
[21:56.080 --> 21:58.080]  взаимодействуют коды
[21:58.080 --> 22:00.080]  на разных языках.
[22:00.080 --> 22:02.080]  Ну и, конечно, они не очень
[22:02.080 --> 22:04.080]  хорошо подходят для системного программирования.
[22:04.080 --> 22:06.080]  Системное программирование, конечно,
[22:06.080 --> 22:08.080]  на самом деле
[22:08.080 --> 22:10.080]  подходит, например, ГО считается даже системным языком,
[22:10.080 --> 22:12.080]  но все-таки
[22:12.080 --> 22:14.080]  то, что у них есть ГЦ,
[22:14.080 --> 22:16.080]  оптимизирует области,
[22:16.080 --> 22:18.080]  в которых их можно использовать.
[22:18.080 --> 22:20.080]  Ты имел в виду Beta Interoperability
[22:20.080 --> 22:22.080]  между разными рамтаймами?
[22:22.080 --> 22:24.080]  Ну да,
[22:24.080 --> 22:26.080]  если у тебя язык без ГЦ
[22:26.080 --> 22:28.080]  и язык с ГЦ, если ты вызываешь
[22:28.080 --> 22:30.080]  без ГЦ и с ГЦ, то в таком случае все хорошо.
[22:30.080 --> 22:32.080]  В обратную сторону уже плохо,
[22:32.080 --> 22:34.080]  например, если два ГЦ, там вообще очень плохо.
[22:34.080 --> 22:36.080]  Нет, потому что, например, там
[22:36.080 --> 22:38.080]  прокамы, написанные на разных языках
[22:38.080 --> 22:40.080]  по JVM, скорее всего, как-то могут нормально взаимодействовать.
[22:40.080 --> 22:42.080]  Ну это да,
[22:42.080 --> 22:44.080]  там Kotlin и Java хорошо взаимодействуют.
[22:46.080 --> 22:48.080]  Так, ну давайте
[22:48.080 --> 22:50.080]  поймем, что такое системное программирование.
[22:50.080 --> 22:52.080]  Это вообще процесс написания программ,
[22:52.080 --> 22:54.080]  которые взаимодействуют в первую очередь
[22:54.080 --> 22:56.080]  с другими программами и не пользовательными.
[22:56.080 --> 22:58.080]  Ну в качестве примеров это операционные системы,
[22:58.080 --> 23:00.080]  прошивки,
[23:00.080 --> 23:02.080]  базы данных, виртуальные машины,
[23:02.080 --> 23:04.080]  браузеры.
[23:04.080 --> 23:06.080]  Браузеры вообще отдельная тема, это по сути тоже
[23:06.080 --> 23:08.080]  операционная система в каком-то роде,
[23:08.080 --> 23:10.080]  потому что они тоже исполняют программы,
[23:10.080 --> 23:12.080]  на себе.
[23:12.080 --> 23:14.080]  Ну и не очень сложные.
[23:16.080 --> 23:18.080]  Обычно мы от
[23:18.080 --> 23:20.080]  программ систем
[23:20.080 --> 23:22.080]  ожидаем то, что они будут быстро исполняться и стабильно.
[23:22.080 --> 23:24.080]  То есть мы
[23:24.080 --> 23:26.080]  может быть хотим, чтобы чуть-чуть медленнее, но при этом
[23:26.080 --> 23:28.080]  стабильно, а не как у нас только что было с ГЦ,
[23:28.080 --> 23:30.080]  там раз в пять секунд у нас spike.
[23:30.080 --> 23:32.080]  Потом, если у нас
[23:32.080 --> 23:34.080]  случается какой-то баг, ну, например, мы там
[23:34.080 --> 23:36.080]  BD накосячили, у нас просто
[23:36.080 --> 23:38.080]  вся BD стерлась, потому что мы там где-то что-то
[23:38.080 --> 23:40.080]  неправильно написали.
[23:40.080 --> 23:42.080]  Поэтому у нас высокая чувствительность к всяким багам.
[23:42.080 --> 23:44.080]  Ну и high security, это чтобы, например, пользовательские данные
[23:44.080 --> 23:46.080]  не утикали,
[23:46.080 --> 23:48.080]  всякие пароли за счет того,
[23:48.080 --> 23:50.080]  чтобы неправильно написали какую-то часть кода.
[23:52.080 --> 23:54.080]  Вот.
[23:54.080 --> 23:56.080]  Почему мы все еще используем C для системного
[23:56.080 --> 23:58.080]  программирования? Вообще Assembler он
[23:58.080 --> 24:00.080]  как-то строго лучше,
[24:00.080 --> 24:02.080]  AC строго лучше, чем Assembler,
[24:02.080 --> 24:04.080]  а Assembler строго лучше, чем машины АКД.
[24:04.080 --> 24:06.080]  Но сказать, что C++
[24:06.080 --> 24:08.080]  строго лучше C это как-то
[24:08.080 --> 24:10.080]  не очень правильно, потому что все-таки
[24:10.080 --> 24:12.080]  C++ слишком сложный язык.
[24:12.080 --> 24:14.080]  И неспроста он
[24:14.080 --> 24:16.080]  не используется в ядре Linux,
[24:16.080 --> 24:18.080]  например.
[24:18.080 --> 24:20.080]  Его очень сложно контролировать.
[24:20.080 --> 24:22.080]  И, ну,
[24:22.080 --> 24:24.080]  например, мы не можем,
[24:24.080 --> 24:26.080]  а не буду, наверное, на этом этап
[24:26.080 --> 24:28.080]  пока что примеры проводить.
[24:28.080 --> 24:30.080]  Так.
[24:30.080 --> 24:32.080]  И вот появляется вопрос, а быть ли когда-нибудь язык,
[24:32.080 --> 24:34.080]  который строго лучше C?
[24:34.080 --> 24:36.080]  Ну, то есть просто вот решает какую-то проблему,
[24:36.080 --> 24:38.080]  никаких новых не добавляет.
[24:40.080 --> 24:42.080]  Вот у нас появляется Rust
[24:42.080 --> 24:44.080]  на арене.
[24:44.080 --> 24:46.080]  Он не требует никакого рентайма.
[24:46.080 --> 24:48.080]  Ну, снова же, со звездочкой там есть что-то вроде
[24:48.080 --> 24:50.080]  Exception, это паника.
[24:50.080 --> 24:52.080]  И там нужен рентайм вокруг.
[24:52.080 --> 24:54.080]  Мы там линкуем
[24:54.080 --> 24:56.080]  свою Gleap C, по сути, программу,
[24:56.080 --> 24:58.080]  поэтому у нас достаточно большая программа
[24:58.080 --> 25:00.080]  на Rust, но, тем не менее,
[25:00.080 --> 25:02.080]  рентайма мы получаем не требуем.
[25:02.080 --> 25:04.080]  Он представляет достаточно толстый
[25:04.080 --> 25:06.080]  слой абстракции.
[25:06.080 --> 25:08.080]  Там очень много всяких вещей, вроде
[25:08.080 --> 25:10.080]  closures,
[25:10.080 --> 25:12.080]  есть структура,
[25:12.080 --> 25:14.080]  генерики,
[25:14.080 --> 25:16.080]  итераторы. На системе типов
[25:16.080 --> 25:18.080]  вообще можно всякие прекрасные вещи делать,
[25:18.080 --> 25:20.080]  как мы потом увидим.
[25:20.080 --> 25:22.080]  Самое главное, то, что обещает Rust,
[25:22.080 --> 25:24.080]  то, что в сейв подножии Rust у вас никогда
[25:24.080 --> 25:26.080]  не будет memory unsafety и undefined behavior.
[25:26.080 --> 25:28.080]  Это прекрасно,
[25:28.080 --> 25:30.080]  потому что мы можем доверять своей программе.
[25:30.080 --> 25:32.080]  У нас компилятор
[25:32.080 --> 25:34.080]  будет на этапе компиляции
[25:34.080 --> 25:36.080]  выкидывать какую-то часть ошибок.
[25:36.080 --> 25:38.080]  Плюс у нас там
[25:38.080 --> 25:40.080]  современный стандарт,
[25:40.080 --> 25:42.080]  в котором практически нет никаких
[25:42.080 --> 25:44.080]  серьезных бирок,
[25:44.080 --> 25:46.080]  как в плюсах. Мы это увидим.
[25:46.080 --> 25:48.080]  Плюс есть целая система
[25:48.080 --> 25:50.080]  сборки и dependency
[25:50.080 --> 25:52.080]  management. Это Cargo.
[25:52.080 --> 25:54.080]  Мы с ним тоже познакомимся.
[25:54.080 --> 25:56.080]  Кстати говоря,
[25:56.080 --> 25:58.080]  тут есть две прекрасные статьи от Microsoft
[25:58.080 --> 26:00.080]  и Chromium, которые говорят, что
[26:00.080 --> 26:02.080]  эти две ошибки,
[26:02.080 --> 26:04.080]  два класса ошибок, memory unsafety
[26:04.080 --> 26:06.080]  undefined behavior, это 70% багов
[26:06.080 --> 26:08.080]  вообще в ПО.
[26:08.080 --> 26:10.080]  70%.
[26:12.080 --> 26:14.080]  У Rust, конечно, есть недостатки.
[26:14.080 --> 26:16.080]  Его очень сложно изучать,
[26:16.080 --> 26:18.080]  поэтому нужно быть к этому готовым.
[26:18.080 --> 26:20.080]  Особенно в начале.
[26:20.080 --> 26:22.080]  Потом он
[26:22.080 --> 26:24.080]  компилируемый, поэтому
[26:24.080 --> 26:26.080]  так же, как на Python,
[26:26.080 --> 26:28.080]  он очень легко прототипирует,
[26:28.080 --> 26:30.080]  сделать скриптик на него не получится.
[26:30.080 --> 26:32.080]  И если у вас очень много оптимизации,
[26:32.080 --> 26:34.080]  как вы потом увидите, вам придется
[26:34.080 --> 26:36.080]  очень часто использовать unsave.
[26:36.080 --> 26:38.080]  Это такое другое подношество Rust,
[26:38.080 --> 26:40.080]  где вы можете, грубо говоря, только разуменовывать
[26:40.080 --> 26:42.080]  указатели.
[26:42.080 --> 26:44.080]  Но это уже добавляет
[26:44.080 --> 26:46.080]  одновременно всю мощь C и все проблемы C,
[26:46.080 --> 26:48.080]  поэтому мы будем это максимально избегать.
[26:50.080 --> 26:52.080]  То есть это для решения
[26:52.080 --> 26:54.080]  наследия какого-то?
[26:54.080 --> 26:56.080]  Что еще?
[26:56.080 --> 26:58.080]  Это для решения проблем наследия.
[26:58.080 --> 26:59.080]  Зачем нам использовать
[26:59.080 --> 27:01.080]  контент C?
[27:01.080 --> 27:03.080]  Я имею в виду, когда мы там будем
[27:03.080 --> 27:05.080]  энтеристики всякие использовать,
[27:05.080 --> 27:07.080]  там уже просто нужно будет
[27:07.080 --> 27:09.080]  самому заботиться о том, чтобы память была
[27:09.080 --> 27:11.080]  выровнена как нужно.
[27:11.080 --> 27:13.080]  Раст это не будет проверять, он просто
[27:13.080 --> 27:15.080]  использует, а это на тебе будет все.
[27:15.080 --> 27:17.080]  И поэтому он unsave использует.
[27:17.080 --> 27:19.080]  Ну, требует unsave.
[27:19.080 --> 27:21.080]  Теперь давайте мы посмотрим
[27:21.080 --> 27:23.080]  на код простенького
[27:23.080 --> 27:25.080]  вектора на C, чтобы понять, как у нас
[27:25.080 --> 27:27.080]  общий раст устроен.
[27:27.080 --> 27:29.080]  Я думаю, что для вас
[27:29.080 --> 27:31.080]  маловато, да?
[27:31.080 --> 27:33.080]  Так нормально?
[27:35.080 --> 27:37.080]  Еще больше?
[27:41.080 --> 27:43.080]  Мы сейчас посмотрим
[27:43.080 --> 27:45.080]  ошибки в C, и потом посмотрим,
[27:45.080 --> 27:47.080]  а что бы мог сделать компилятор,
[27:47.080 --> 27:49.080]  чтобы эти ошибки предотвратить.
[27:49.080 --> 27:51.080]  Так.
[27:51.080 --> 27:53.080]  Давайте поищем баги.
[27:53.080 --> 27:55.080]  Какие баги сейчас видите?
[27:55.080 --> 27:57.080]  Так. Какой баг видишь?
[28:01.080 --> 28:03.080]  Да, правильно. Здесь мы возвращаем
[28:03.080 --> 28:05.080]  память на стеке указатель.
[28:05.080 --> 28:07.080]  Ну, понятное дело, мы возвращаем такой
[28:07.080 --> 28:09.080]  висящий указатель.
[28:09.080 --> 28:11.080]  Ну и соответственно...
[28:13.080 --> 28:15.080]  Что вот здесь вот есть
[28:15.080 --> 28:17.080]  в этой функции?
[28:19.080 --> 28:21.080]  Ну, во-первых,
[28:21.080 --> 28:23.080]  я бы, конечно...
[28:23.080 --> 28:25.080]  Вообще я взял код
[28:25.080 --> 28:27.080]  из Стэнфорда, скажем так.
[28:27.080 --> 28:29.080]  У них тут, на самом деле, есть еще один баг.
[28:29.080 --> 28:31.080]  Вектор у нас все-таки не байтовый,
[28:31.080 --> 28:33.080]  а интовый.
[28:33.080 --> 28:35.080]  И здесь нужно лоцировать
[28:35.080 --> 28:37.080]  sizeOfInt на newCapacity.
[28:37.080 --> 28:39.080]  Так мы и просто newCapacity.byte
[28:39.080 --> 28:41.080]  выделили.
[28:41.080 --> 28:43.080]  А у нас это обязательно нужно?
[28:43.080 --> 28:45.080]  Да.
[28:45.080 --> 28:47.080]  А у нас это обязательно нужно?
[28:47.080 --> 28:49.080]  Обязательно.
[28:51.080 --> 28:53.080]  В плане вот здесь вот?
[28:53.080 --> 28:55.080]  Нет, просто если функция
[28:55.080 --> 28:57.080]  передастся 0.2, то у нас все будет...
[28:57.080 --> 28:59.080]  Ну да, это тоже point, то что у нас может
[28:59.080 --> 29:01.080]  нуловый быть вектор.
[29:01.080 --> 29:03.080]  Мы даты не очищаем старую.
[29:03.080 --> 29:05.080]  Так, что еще раз не очищаем?
[29:05.080 --> 29:07.080]  Старую дату не очищаем.
[29:07.080 --> 29:09.080]  Да, вот здесь, вот в этой строчке мы не очищаем старую дату.
[29:09.080 --> 29:11.080]  У нас, соответственно, получается память,
[29:11.080 --> 29:13.080]  которую мы не очистили. Это по ухо тоже.
[29:13.080 --> 29:15.080]  Кажется, тут все.
[29:15.080 --> 29:17.080]  Так.
[29:17.080 --> 29:19.080]  И вот в этих вот двух функциях, что вы видите?
[29:23.080 --> 29:25.080]  Так, давайте,
[29:25.080 --> 29:27.080]  назовите номер строчки ошибку.
[29:27.080 --> 29:29.080]  38, 39, swap.
[29:29.080 --> 29:31.080]  Так, хорошо, да.
[29:31.080 --> 29:33.080]  39, освобождение.
[29:33.080 --> 29:35.080]  Да, тут double-free.
[29:35.080 --> 29:37.080]  В общем-то,
[29:37.080 --> 29:39.080]  сначала нужно освободить
[29:39.080 --> 29:41.080]  буфер вектора, а потом уже сам вектор.
[29:41.080 --> 29:43.080]  Ну, и тут еще один баг есть.
[29:49.080 --> 29:51.080]  Нулевой.
[30:05.080 --> 30:07.080]  Ну да, когда мы
[30:07.080 --> 30:09.080]  берем указатель
[30:09.080 --> 30:11.080]  вот здесь вот на
[30:11.080 --> 30:13.080]  векдейта, а потом пушим,
[30:13.080 --> 30:15.080]  то в таком случае у нас здесь может возникнуть
[30:15.080 --> 30:17.080]  реаллокация. Конкретно в данном примере она даже обязательно
[30:17.080 --> 30:19.080]  возникнет.
[30:19.080 --> 30:21.080]  Ну, вообще так делать плохо. Сначала пушить вектор,
[30:21.080 --> 30:23.080]  а потом надеяться на то, что указатели
[30:23.080 --> 30:25.080]  не инвалидировались.
[30:27.080 --> 30:29.080]  Да-да, здесь тоже есть double-free.
[30:35.080 --> 30:37.080]  New и push.
[30:39.080 --> 30:41.080]  За счет чего?
[30:45.080 --> 30:47.080]  А, ну да-да, тут плюс один еще.
[30:47.080 --> 30:49.080]  Stanford, скажем так, очень
[30:49.080 --> 30:51.080]  постарался баги посадить.
[30:53.080 --> 30:55.080]  Так. Ну, в общем, самое
[30:55.080 --> 30:57.080]  главное, мы нашли 4
[30:57.080 --> 30:59.080]  типа ошибок.
[30:59.080 --> 31:01.080]  Давайте мы по ним пройдемся.
[31:01.080 --> 31:03.080]  Вот у нас был такой вот код.
[31:03.080 --> 31:05.080]  И мы в нем нашли такой вот баг, что мы возвращали
[31:05.080 --> 31:07.080]  указатель с такой переменной.
[31:07.080 --> 31:09.080]  Не было ли это классно, если бы вектор
[31:09.080 --> 31:11.080]  не обратил внимание, что вообще-то мы
[31:11.080 --> 31:13.080]  на что даем указатель, что уже
[31:13.080 --> 31:15.080]  выходит за свой скоп?
[31:15.080 --> 31:17.080]  То есть это компилятор
[31:17.080 --> 31:19.080]  бы казалось бы легко мог словить, да?
[31:19.080 --> 31:21.080]  Потом у нас был
[31:21.080 --> 31:23.080]  double-free ошибка. Например, вот здесь.
[31:25.080 --> 31:27.080]  Не было ли классно, если бы он не обратил внимание,
[31:27.080 --> 31:29.080]  что вообще-то пытаемся освободить память,
[31:29.080 --> 31:31.080]  которую мы уже освободили внутри?
[31:33.080 --> 31:35.080]  Еще есть интератор
[31:35.080 --> 31:37.080]  Invalidation.
[31:37.080 --> 31:39.080]  И здесь компилятор мог бы
[31:39.080 --> 31:41.080]  чуть-чуть поменял код, потому что
[31:41.080 --> 31:43.080]  у него просто техи не получилось, сделал так, чтобы формат
[31:43.080 --> 31:45.080]  тоже в желтом был, но неважно.
[31:47.080 --> 31:49.080]  В общем-то, здесь тоже компилятор мог бы
[31:49.080 --> 31:51.080]  обратить внимание на то, что мы с самого начала
[31:51.080 --> 31:53.080]  изменили вектор, а потом мы
[31:53.080 --> 31:55.080]  пытаемся вывести элемент.
[31:55.080 --> 31:57.080]  В общем-то, все эти
[31:57.080 --> 31:59.080]  типа ошибок умеет компилятор вылавлять.
[31:59.080 --> 32:01.080]  Ну, и еще один. Memory leak есть.
[32:01.080 --> 32:03.080]  Здесь компилятор тоже мог бы
[32:03.080 --> 32:05.080]  обратить внимание на то, что мы
[32:05.080 --> 32:07.080]  затираем указатель на ту память,
[32:07.080 --> 32:09.080]  которую мы еще не освободили.
[32:09.080 --> 32:11.080]  Последний указатель.
[32:13.080 --> 32:15.080]  В общем-то, Rust, он как раз эти проблемы
[32:15.080 --> 32:17.080]  решает, и это доказано теоретически.
[32:17.080 --> 32:19.080]  Это доказал
[32:19.080 --> 32:21.080]  вот такой вот человек, его зовут
[32:21.080 --> 32:23.080]  Ralph Junk, если я его правильно
[32:23.080 --> 32:25.080]  прочитал. Есть целых
[32:25.080 --> 32:27.080]  три награды у его
[32:27.080 --> 32:29.080]  PHD, кажется,
[32:29.080 --> 32:31.080]  или просто статьи,
[32:31.080 --> 32:33.080]  которые как раз
[32:33.080 --> 32:35.080]  занимались тем, что доказывал
[32:35.080 --> 32:37.080]  безопасность Rust. Если быть
[32:37.080 --> 32:39.080]  более конкретным, то он сделал такую модель, которая называется
[32:39.080 --> 32:41.080]  Rust Belt. Это такая теоретическая
[32:41.080 --> 32:43.080]  модель Rust, упрощенная несколько,
[32:43.080 --> 32:45.080]  но она имеет все корневые концепции,
[32:45.080 --> 32:47.080]  поэтому она полная.
[32:49.080 --> 32:51.080]  В общем-то, он доказал, что Safe Rust
[32:51.080 --> 32:53.080]  действительно безопасен, что он не позволяет
[32:53.080 --> 32:55.080]  делать вещи вроде Undefined
[32:55.080 --> 32:57.080]  Behavior, Memory Unsafety.
[32:57.080 --> 32:59.080]  Он
[32:59.080 --> 33:01.080]  сформулировал основные
[33:05.080 --> 33:07.080]  условия для того, чтобы
[33:07.080 --> 33:09.080]  считать TI безопасной абстракции.
[33:11.080 --> 33:13.080]  И доказал Soundness. Soundness
[33:13.080 --> 33:15.080]  это означает то, что
[33:15.080 --> 33:17.080]  тип является Sound, если
[33:17.080 --> 33:19.080]  он не дает
[33:19.080 --> 33:21.080]  убей или Memory Unsafety при
[33:21.080 --> 33:23.080]  любом обращении с ним.
[33:23.080 --> 33:25.080]  Он доказал
[33:25.080 --> 33:27.080]  с помощью Coq и Iris,
[33:27.080 --> 33:29.080]  что основные
[33:29.080 --> 33:31.080]  вещи, которые используются в Rust,
[33:31.080 --> 33:33.080]  мы, конечно, с ними еще познакомимся,
[33:33.080 --> 33:35.080]  Cell, Ref, Cell,
[33:35.080 --> 33:37.080]  Threadspawn и прочее, они безопасны.
[33:37.080 --> 33:39.080]  Среди них
[33:39.080 --> 33:41.080]  те, кто с курсом
[33:41.080 --> 33:43.080]  Concurrency знаком, уже должны знать
[33:43.080 --> 33:45.080]  про Mutex, Rwlock, Threadspawn.
[33:45.080 --> 33:47.080]  Еще можно
[33:47.080 --> 33:49.080]  догадаться, что такое Arc, это у нас
[33:49.080 --> 33:51.080]  Atomic Pointer.
[33:51.080 --> 33:53.080]  Smart Pointer.
[33:55.080 --> 33:57.080]  И вообще история Rust такова, что
[33:57.080 --> 33:59.080]  в Mozilla компании
[33:59.080 --> 34:01.080]  был такой человек, звали его
[34:01.080 --> 34:03.080]  Graydon Haar. И он в какой-то
[34:03.080 --> 34:05.080]  момент, изучая другие языки
[34:05.080 --> 34:07.080]  программирования, понял, что
[34:07.080 --> 34:09.080]  tooling к ним.
[34:09.080 --> 34:11.080]  Что вообще-то все эти
[34:11.080 --> 34:13.080]  проверки прямо на этапе
[34:13.080 --> 34:15.080]  runtime и на этапе компиляции
[34:15.080 --> 34:17.080]  сделал достаточно хороший язык.
[34:17.080 --> 34:19.080]  И он в течение 4-х лет перелил
[34:19.080 --> 34:21.080]  этот язык. И потом в какой-то момент
[34:21.080 --> 34:23.080]  показал его внутри Mozilla.
[34:25.080 --> 34:27.080]  Людям он понравился,
[34:27.080 --> 34:29.080]  команда начала расти, они начали
[34:29.080 --> 34:31.080]  его делать.
[34:31.080 --> 34:33.080]  Потом Rust улучшал систему типов
[34:33.080 --> 34:35.080]  внутри, но там появлялись
[34:37.080 --> 34:39.080]  очень сильные type system
[34:39.080 --> 34:41.080]  в этот момент.
[34:41.080 --> 34:43.080]  Приявился Cargo, который пакетный менеджер.
[34:43.080 --> 34:45.080]  Кстати говоря, NPM,
[34:45.080 --> 34:47.080]  то, что пакетный менеджер, кажется,
[34:47.080 --> 34:49.080]  это JavaScript.
[34:49.080 --> 34:51.080]  Это пакетный менеджер.
[34:51.080 --> 34:53.080]  Те, кто его делает,
[34:53.080 --> 34:55.080]  Foundation, сказали, что Rust
[34:55.080 --> 34:57.080]  это такой язык, который
[34:57.080 --> 34:59.080]  boring to deploy. В общем, скучный
[34:59.080 --> 35:01.080]  для того, чтобы его вообще деплоить.
[35:01.080 --> 35:03.080]  И это хорошо, потому что вы же не хотите
[35:03.080 --> 35:05.080]  приключений себе на попу, если вы
[35:05.080 --> 35:07.080]  что-то деплоите в прод.
[35:09.080 --> 35:11.080]  После этого, с 2014 до
[35:11.080 --> 35:13.080]  сегодняшнего дня Rust рос.
[35:13.080 --> 35:15.080]  Если вам интересно, можете посмотреть, кстати,
[35:15.080 --> 35:17.080]  в ссылочке,
[35:17.080 --> 35:19.080]  там, если это рассказать чуть подробнее,
[35:19.080 --> 35:21.080]  но, кажется, что основные
[35:21.080 --> 35:23.080]  포인ты я уже сказал.
[35:23.080 --> 35:25.080]  Да, это
[35:25.080 --> 35:27.080]  они уже отделились, там уже
[35:27.080 --> 35:29.080]  Rust Foundation, это отдельная вещь, но
[35:29.080 --> 35:31.080]  основной
[35:31.080 --> 35:33.080]  разработчик языка это Mozilla.
[35:37.080 --> 35:39.080]  Ну, и кто использует на данный момент
[35:39.080 --> 35:41.080]  Rust? Не нишевый ли это все еще язык?
[35:41.080 --> 35:43.080]  Ну, во-первых, Google, они
[35:43.080 --> 35:45.080]  прямо сейчас активно пушат Rust
[35:45.080 --> 35:47.080]  в ядро Linux. Я напоминаю, что там сейчас
[35:47.080 --> 35:49.080]  основной языком был только C.
[35:49.080 --> 35:51.080]  То есть появляется Rust спустя много-много
[35:51.080 --> 35:53.080]  лет.
[35:53.080 --> 35:55.080]  Потом Google делает
[35:55.080 --> 35:57.080]  os-фуксию и разрешает
[35:57.080 --> 35:59.080]  использовать Rust на Android.
[35:59.080 --> 36:01.080]  А Meta,
[36:01.080 --> 36:03.080]  который бывший Facebook, у них есть
[36:03.080 --> 36:05.080]  своя система контроля версии
[36:05.080 --> 36:07.080]  Mononoke,
[36:07.080 --> 36:09.080]  DM Blockchain
[36:09.080 --> 36:11.080]  и, собственно, они пилят
[36:11.080 --> 36:13.080]  metaverse на Rust.
[36:13.080 --> 36:15.080]  Поэтому, если вы хотите
[36:15.080 --> 36:17.080]  пойти в мета пилить metaverse,
[36:17.080 --> 36:19.080]  то вам нужно будет знать Rust.
[36:21.080 --> 36:23.080]  Один из самых
[36:23.080 --> 36:25.080]  активных, наверное, пользователей Rust
[36:25.080 --> 36:27.080]  среди больших компаний, потому что
[36:27.080 --> 36:29.080]  больше всего новостей, это Amazon.
[36:29.080 --> 36:31.080]  Они захайлили всех тех,
[36:31.080 --> 36:33.080]  кто разрабатывает библиотеку Tokio.
[36:33.080 --> 36:35.080]  Ну, это такой синхронный фреймворк.
[36:35.080 --> 36:37.080]  Если вы знаете, в плюсах есть ASIO,
[36:37.080 --> 36:39.080]  это что-то подобное, но это даже круче
[36:39.080 --> 36:41.080]  на самом деле Tokio.
[36:41.080 --> 36:43.080]  Потом Firecracker,
[36:43.080 --> 36:45.080]  это такая система виртуализации.
[36:45.080 --> 36:47.080]  Bottle Rocket, это
[36:47.080 --> 36:49.080]  Linux-based контейнер такой.
[36:49.080 --> 36:51.080]  Ну, и Nitro,
[36:51.080 --> 36:53.080]  это Compute Environments.
[36:53.080 --> 36:55.080]  Такие вот вещи.
[36:55.080 --> 36:57.080]  Ну, и Microsoft тоже потихоньку адоптит.
[36:57.080 --> 36:59.080]  Они, например, на Windows
[36:59.080 --> 37:01.080]  переписали небольшую компоненту на Rust
[37:01.080 --> 37:03.080]  и были восхищены.
[37:03.080 --> 37:05.080]  Все, что оранжевое, если что, это ссылочки.
[37:05.080 --> 37:07.080]  Это все можно протыкать и прямо прочитать.
[37:07.080 --> 37:09.080]  Потом у нас есть
[37:09.080 --> 37:11.080]  прямо враппер
[37:11.080 --> 37:13.080]  вокруг WinAPI.
[37:13.080 --> 37:15.080]  Растовский.
[37:15.080 --> 37:17.080]  Растовский враппер вокруг WinAPI.
[37:17.080 --> 37:19.080]  Вот.
[37:19.080 --> 37:21.080]  Ну, давайте поговорим про плохую сторону.
[37:21.080 --> 37:23.080]  Почему все-таки компании иногда
[37:23.080 --> 37:25.080]  не используют Rust?
[37:25.080 --> 37:27.080]  Ну, во-первых, иногда в компаниях
[37:27.080 --> 37:29.080]  бывает очень много написанного кода
[37:29.080 --> 37:31.080]  уже на Rust.
[37:31.080 --> 37:33.080]  Не на Rust, а на другом языке.
[37:33.080 --> 37:35.080]  Например, там в Гугле, если у вас написаны
[37:35.080 --> 37:37.080]  его на струче кода на плюсах,
[37:37.080 --> 37:39.080]  то вы вряд ли захотите что-то взять и переписать.
[37:39.080 --> 37:41.080]  Это очень много усилий.
[37:41.080 --> 37:43.080]  Потом
[37:43.080 --> 37:45.080]  нужно будет поддерживать внутренние
[37:45.080 --> 37:47.080]  инструменты на Rust.
[37:47.080 --> 37:49.080]  То есть,
[37:49.080 --> 37:51.080]  например, там, если вы работали
[37:51.080 --> 37:53.080]  в Яндексе, там вот в Аркадии есть
[37:53.080 --> 37:55.080]  свои инструментарии, там Rust
[37:55.080 --> 37:57.080]  не поддерживается.
[37:57.080 --> 37:59.080]  Также, если вы в большой компании,
[37:59.080 --> 38:01.080]  то вы хотите иметь свой собственный комитет
[38:01.080 --> 38:03.080]  для того, чтобы поддерживать
[38:03.080 --> 38:05.080]  всякие RFC,
[38:05.080 --> 38:07.080]  которые пытаются пройти в язык,
[38:07.080 --> 38:09.080]  которые вам интересны.
[38:09.080 --> 38:11.080]  Или, наоборот, блокировать
[38:11.080 --> 38:13.080]  сприкейтинг, чего-то. Если у вас, например,
[38:13.080 --> 38:15.080]  в компании много чего написано,
[38:15.080 --> 38:17.080]  и вы считаете использованием какой-то фичи,
[38:17.080 --> 38:19.080]  и вы хотите, чтобы его не выпиливали.
[38:19.080 --> 38:21.080]  Ну, и
[38:21.080 --> 38:23.080]  язык, на самом деле, достаточно новый.
[38:23.080 --> 38:25.080]  Поэтому найти на него разработчиков
[38:25.080 --> 38:27.080]  очень сложно.
[38:27.080 --> 38:29.080]  Ну, сколько им получается лет? 10 лет сейчас.
[38:29.080 --> 38:31.080]  Раз-два.
[38:31.080 --> 38:33.080]  Ну, это с учетом еще того, что
[38:33.080 --> 38:35.080]  он четыре из них года был
[38:35.080 --> 38:37.080]  исключительно проектом
[38:37.080 --> 38:39.080]  Gradonahar.
[38:39.080 --> 38:41.080]  Ну, и плюс еще
[38:41.080 --> 38:43.080]  разработчики на Rust такие люди, которые
[38:43.080 --> 38:45.080]  очень много денег хотят,
[38:45.080 --> 38:47.080]  очень умные ребята, поэтому
[38:47.080 --> 38:49.080]  представьте себе, вы так хотите
[38:49.080 --> 38:51.080]  за бесплатно кандидаты найти, он приходит,
[38:51.080 --> 38:53.080]  он, конечно, крутой, но целый
[38:53.080 --> 38:55.080]  вагон денег просит, поэтому
[38:55.080 --> 38:57.080]  их сложно найти.
[38:57.080 --> 38:59.080]  Вот.
[38:59.080 --> 39:01.080]  Ну, и в основном
[39:01.080 --> 39:03.080]  те, кто использует
[39:03.080 --> 39:05.080]  всё-таки Rust, это всякие не особо крупные
[39:05.080 --> 39:07.080]  компании на данный момент, стартапы,
[39:07.080 --> 39:09.080]  ну, и, конечно, есть большие компании вроде бы
[39:09.080 --> 39:11.080]  вроде Amazon,
[39:11.080 --> 39:13.080]  которые там адоптят Rust, но
[39:13.080 --> 39:15.080]  преимущественно всё-таки сейчас небольшие компании
[39:15.080 --> 39:17.080]  его используют. Я считаю, что
[39:17.080 --> 39:19.080]  в будущем Rust будут
[39:19.080 --> 39:21.080]  использоваться гораздо больше.
[39:21.080 --> 39:23.080]  Потому что новые проекты сейчас активно пишутся
[39:23.080 --> 39:25.080]  именно на Rust. Вы можете смотреть новости
[39:25.080 --> 39:27.080]  и обратить на это внимание.
[39:27.080 --> 39:29.080]  Вот.
[39:29.080 --> 39:31.080]  Ну, кстати говоря, я могу еще сказать такой, ну,
[39:31.080 --> 39:33.080]  я как работник Яндекса, я могу
[39:33.080 --> 39:35.080]  вам сказать, например, информацию
[39:35.080 --> 39:37.080]  про то, как у нас
[39:37.080 --> 39:39.080]  вообще настроение про Rust.
[39:39.080 --> 39:41.080]  У нас есть такие две категории людей.
[39:41.080 --> 39:43.080]  Та категория, которая пофигует
[39:43.080 --> 39:45.080]  на Rust, она всегда будет.
[39:45.080 --> 39:47.080]  И те, кому интересно.
[39:47.080 --> 39:49.080]  И вот те, кому интересно, вот я слышал такой интересный
[39:49.080 --> 39:51.080]  пони, что мы сейчас можем просто пропустить
[39:51.080 --> 39:53.080]  момент, не добавляя
[39:53.080 --> 39:55.080]  Rust в Arcadia, то есть внутреннюю
[39:55.080 --> 39:57.080]  монорепозиторию Яндекса.
[39:57.080 --> 39:59.080]  Как это когда-то произошло с
[39:59.080 --> 40:01.080]  питоном вторым в Яндексе. Ну, то есть
[40:01.080 --> 40:03.080]  третьим, точнее. Мы сидели долго
[40:03.080 --> 40:05.080]  на втором питоне, а потом только перешли на третий.
[40:05.080 --> 40:07.080]  И это было уже очень поздно как-то.
[40:07.080 --> 40:09.080]  Ну, и можем упустить момент.
[40:09.080 --> 40:11.080]  Вот.
[40:11.080 --> 40:13.080]  Есть какие-то вопросы по той части?
[40:13.080 --> 40:15.080]  Прежде чем мы перейдем непосредственно к самому Rust.
[40:19.080 --> 40:21.080]  Ты упомянул, что у Rust
[40:21.080 --> 40:23.080]  есть стандарт?
[40:25.080 --> 40:27.080]  Это правда?
[40:27.080 --> 40:29.080]  Ты имеешь ввиду стандарт, который прям PDF-ка такая?
[40:29.080 --> 40:31.080]  Ну, типа да.
[40:31.080 --> 40:33.080]  Спецификация есть.
[40:33.080 --> 40:35.080]  Спецификация есть, конечно, да.
[40:35.080 --> 40:37.080]  Спецификация есть, конечно, да.
[40:37.080 --> 40:39.080]  Ну,
[40:39.080 --> 40:41.080]  Скажем так, я никогда не видел
[40:41.080 --> 40:43.080]  никакой прям PDF-ки,
[40:43.080 --> 40:45.080]  как при сахтокопе стандарта.
[40:45.080 --> 40:47.080]  Скорее всего, и нет.
[40:47.080 --> 40:49.080]  Но очень легко можно найти
[40:49.080 --> 40:51.080]  описание того,
[40:51.080 --> 40:53.080]  что мы требуем и от каких функций.
[40:53.080 --> 40:55.080]  Вообще, по факту, сейчас есть
[40:55.080 --> 40:57.080]  только одна имплементация Rust,
[40:57.080 --> 40:59.080]  Rust-C. Она работает на LLVM.
[40:59.080 --> 41:01.080]  Ну, если вы знаете,
[41:01.080 --> 41:03.080]  это кодогенерация такая, да.
[41:03.080 --> 41:05.080]  Предназначена для того, чтобы делать
[41:05.080 --> 41:07.080]  на нем языки.
[41:07.080 --> 41:09.080]  Вот. Сейчас, конечно, делать так, чтобы еще можно было
[41:09.080 --> 41:11.080]  на GCC писать.
[41:11.080 --> 41:13.080]  Ну, то есть, писать Rust-код
[41:13.080 --> 41:15.080]  и конкурировать его через GCC.
[41:15.080 --> 41:17.080]  Но пока что этот проект достаточно сырой.
[41:17.080 --> 41:19.080]  Потому что эталонная имплементация Rust
[41:19.080 --> 41:21.080]  только одна.
[41:21.080 --> 41:23.080]  Вот так вот.
[41:23.080 --> 41:25.080]  Эталонная, это, скорее всего, должна быть одна.
[41:25.080 --> 41:27.080]  Профессионной имплементации, кроме эталонной,
[41:27.080 --> 41:29.080]  пока нет.
[41:29.080 --> 41:31.080]  Ну, есть такая частичная GCC, наверное,
[41:31.080 --> 41:33.080]  но пока что больше ничего нет.
[41:33.080 --> 41:35.080]  Еще что-нибудь?
[41:39.080 --> 41:41.080]  Так. Ну, давайте для начала напишем
[41:41.080 --> 41:43.080]  Hello World.
[41:43.080 --> 41:45.080]  Когда без этого?
[41:45.080 --> 41:47.080]  Так.
[41:47.080 --> 41:49.080]  Смотрите, у нас все, как и во всех языках,
[41:49.080 --> 41:51.080]  начинается с функции Main.
[41:53.080 --> 41:55.080]  Сколько у нас времени? Прошел только часик?
[41:55.080 --> 41:57.080]  Отлично.
[41:57.080 --> 41:59.080]  Вот у нас есть такой прекрасный Main.
[41:59.080 --> 42:01.080]  Sprint-len
[42:01.080 --> 42:03.080]  Hello World.
[42:03.080 --> 42:05.080]  Sprint-len, вот что значит
[42:05.080 --> 42:07.080]  восклицательный знак? Это вообще значит, что это
[42:07.080 --> 42:09.080]  macros. Что такое macros, пока что
[42:09.080 --> 42:11.080]  можете не задумываться. Можете воспринимать это
[42:11.080 --> 42:13.080]  просто как обыкновенную функцию.
[42:13.080 --> 42:15.080]  На самом деле, там, конечно, происходит код
[42:15.080 --> 42:17.080]  генерация, то есть там по факту
[42:17.080 --> 42:19.080]  лочится stdin
[42:19.080 --> 42:21.080]  и потом в него пишется
[42:21.080 --> 42:23.080]  что-то. То есть вам прежде чем что-то записать в
[42:23.080 --> 42:25.080]  stdin, нужно гарантировать то, что вы единственный
[42:25.080 --> 42:27.080]  писатель, иначе у вас там будет
[42:27.080 --> 42:29.080]  крокодиабра,
[42:29.080 --> 42:31.080]  если вы в несколько потоках будете
[42:31.080 --> 42:33.080]  писать.
[42:33.080 --> 42:35.080]  Пока что можете просто воспринимать это как функцию.
[42:35.080 --> 42:37.080]  Ну и
[42:37.080 --> 42:39.080]  это просто способ
[42:39.080 --> 42:41.080]  задекларить функцию.
[42:41.080 --> 42:43.080]  Вот. Вот так вот
[42:43.080 --> 42:45.080]  компилируется. Можно компилировать
[42:45.080 --> 42:47.080]  непосредственно с помощью RSC-компилятора.
[42:47.080 --> 42:49.080]  То есть это точно так же, если вы
[42:49.080 --> 42:51.080]  напишете, например, GCC
[42:51.080 --> 42:53.080]  или Clang++,
[42:53.080 --> 42:55.080]  G++, Clang++
[42:55.080 --> 42:57.080]  и скомпилируется, соответственно, код.
[42:57.080 --> 42:59.080]  Вот. Ну и запускается.
[42:59.080 --> 43:01.080]  Ну, на самом деле, это не едиматично,
[43:01.080 --> 43:03.080]  лучше пользоваться Cargo. Ну, мы чуть-чуть
[43:03.080 --> 43:05.080]  на него посмотрим попозже.
[43:05.080 --> 43:07.080]  Еще можно вот так вот написать
[43:07.080 --> 43:09.080]  Main. Ну это уже такое
[43:09.080 --> 43:11.080]  просто, просто чисто фановый слайд.
[43:13.080 --> 43:15.080]  Ну, тут, по сути, написано то же самое,
[43:15.080 --> 43:17.080]  что и в прошлом слайде. То есть
[43:17.080 --> 43:19.080]  тут написано,
[43:19.080 --> 43:21.080]  что вы
[43:21.080 --> 43:23.080]  за хардкожен Hello World и вызывается
[43:23.080 --> 43:25.080]  системный вызов.
[43:27.080 --> 43:29.080]  Вот так вот.
[43:29.080 --> 43:31.080]  Вот. Такие вот есть типы в расте
[43:31.080 --> 43:33.080]  базовых переменных.
[43:33.080 --> 43:35.080]  Думаю, что тут
[43:35.080 --> 43:37.080]  в принципе все понятно, там и 16,
[43:37.080 --> 43:39.080]  и 64,
[43:39.080 --> 43:41.080]  и 16.
[43:41.080 --> 43:43.080]  И особенно в сравнении
[43:43.080 --> 43:45.080]  с плюсами это, во-первых, то, что у нас
[43:45.080 --> 43:47.080]  есть 128-битные числовые типы в стандарте.
[43:47.080 --> 43:49.080]  То есть мы можем прямо их использовать.
[43:49.080 --> 43:51.080]  Во-вторых, у нас
[43:51.080 --> 43:53.080]  и size, и usize, но это как
[43:53.080 --> 43:55.080]  sizeT и
[43:55.080 --> 43:57.080]  sizeT в плюсах.
[43:57.080 --> 43:59.080]  Они, соответственно, зависит от
[43:59.080 --> 44:01.080]  платформы. Это размер указателей.
[44:03.080 --> 44:05.080]  Так. Чтобы объявить
[44:05.080 --> 44:07.080]  переменную, нам нужно использовать
[44:07.080 --> 44:09.080]  led, ключевое слово.
[44:09.080 --> 44:11.080]  Забегая наперед, скажу, что на самом деле это
[44:11.080 --> 44:13.080]  led, это pattern matching.
[44:13.080 --> 44:15.080]  То есть на самом деле его можно посмотреть даже более глубоко,
[44:15.080 --> 44:17.080]  чем просто на ключевое слово для
[44:17.080 --> 44:19.080]  создания переменной.
[44:23.080 --> 44:25.080]  Видим чуть попозже.
[44:25.080 --> 44:27.080]  Это забегай наперед просто.
[44:27.080 --> 44:29.080]  Пока что можете воспринимать led просто как способ объявить
[44:29.080 --> 44:31.080]  переменную.
[44:31.080 --> 44:33.080]  Вот. Смотрите.
[44:33.080 --> 44:35.080]  В первой строчке
[44:35.080 --> 44:37.080]  я объявил переменную idx,
[44:37.080 --> 44:39.080]  который тип usize.
[44:39.080 --> 44:41.080]  То есть, видите, я пишу не как в плюсах
[44:41.080 --> 44:43.080]  там sizeT idx,
[44:43.080 --> 44:45.080]  а пишу led idx usize
[44:45.080 --> 44:47.080]  через двоеточие.
[44:47.080 --> 44:49.080]  Тип не обязательно писать.
[44:49.080 --> 44:51.080]  Там есть type inference.
[44:51.080 --> 44:53.080]  Мы на него еще посмотрим. И вы его тем более
[44:53.080 --> 44:55.080]  еще очень часто будете видеть в домашке, он очень прекрасен.
[44:55.080 --> 44:57.080]  Сейчас
[44:57.080 --> 44:59.080]  объясню, что это.
[44:59.080 --> 45:01.080]  Потом есть всякие литералы.
[45:01.080 --> 45:03.080]  Просто вот качество примеров.
[45:03.080 --> 45:05.080]  Тут мы можем писать шестнадцатеричное число,
[45:05.080 --> 45:07.080]  восьмеричное
[45:07.080 --> 45:09.080]  и двоичное число.
[45:09.080 --> 45:11.080]  Да, нижнее
[45:11.080 --> 45:13.080]  подчеркивание. В плюсах, кажется, кавычки используется.
[45:17.080 --> 45:19.080]  Еще переменные
[45:19.080 --> 45:21.080]  по дефолту не мутабельные.
[45:21.080 --> 45:23.080]  Чтобы сделать все мутабельные,
[45:23.080 --> 45:25.080]  нужно дописать let mute.
[45:25.080 --> 45:27.080]  Это то же самое,
[45:27.080 --> 45:29.080]  грубо говоря, то же самое, на самом деле.
[45:29.080 --> 45:31.080]  Чуть-чуть отличается,
[45:31.080 --> 45:33.080]  что const в плюсах.
[45:33.080 --> 45:35.080]  То есть вы получаете, грубо говоря,
[45:35.080 --> 45:37.080]  вы являетесь переменной константами.
[45:37.080 --> 45:39.080]  А потом
[45:39.080 --> 45:41.080]  если вы захотите сделать не константной,
[45:41.080 --> 45:43.080]  то вам нужно написать mute.
[45:43.080 --> 45:45.080]  Дело в том, что зачастую, когда вы пишете код,
[45:45.080 --> 45:47.080]  вам не нужно мутировать переменные.
[45:47.080 --> 45:49.080]  Особенно если вы пишете в каком-нибудь функциональном стиле.
[45:49.080 --> 45:51.080]  Раз такое позволяет.
[45:53.080 --> 45:55.080]  А можно на лету
[45:55.080 --> 45:57.080]  делать переменные?
[45:57.080 --> 45:59.080]  На лету?
[45:59.080 --> 46:01.080]  А не в рэнтайме?
[46:01.080 --> 46:03.080]  Приходишь в unsafe, обещаешь,
[46:03.080 --> 46:05.080]  и код опять пишешь.
[46:05.080 --> 46:07.080]  В смысле, ну как cast
[46:07.080 --> 46:09.080]  к неконстантному типу?
[46:11.080 --> 46:13.080]  Ну, я не очень понимаю, зачем это нужно.
[46:13.080 --> 46:15.080]  Вообще,
[46:15.080 --> 46:17.080]  если я примерно правильно понял
[46:17.080 --> 46:19.080]  твой вопрос, то на самом деле в расе такое
[46:19.080 --> 46:21.080]  делать намеренно это ub.
[46:21.080 --> 46:23.080]  То есть это обязательно
[46:23.080 --> 46:25.080]  будет использоваться unsafe, и это получится ub.
[46:25.080 --> 46:27.080]  То есть так лучше не делать.
[46:27.080 --> 46:29.080]  И кажется, это никогда не надо.
[46:31.080 --> 46:33.080]  И на секундочку. То, что type inference,
[46:33.080 --> 46:35.080]  вот вы помните, в расе есть ключевое слово
[46:35.080 --> 46:37.080]  авто.
[46:37.080 --> 46:39.080]  Авто просто, оно берет такое
[46:39.080 --> 46:41.080]  и вот вы пишете, авто х
[46:41.080 --> 46:43.080]  сравняется с чего-то там.
[46:43.080 --> 46:45.080]  С++ есть типа авто, да?
[46:49.080 --> 46:51.080]  Ну, в общем-то, он
[46:51.080 --> 46:53.080]  просто берет и смотрит на правую часть,
[46:53.080 --> 46:55.080]  присваивает значение левой, да?
[46:55.080 --> 46:57.080]  А в расе, на самом деле,
[46:57.080 --> 46:59.080]  type inference он хитрее.
[46:59.080 --> 47:01.080]  Он смотрит на то, как вы используете
[47:01.080 --> 47:03.080]  переменную даже дальше. То есть вы можете
[47:03.080 --> 47:05.080]  написать, например, вот как я объявил,
[47:07.080 --> 47:09.080]  представьте, что я и dx, вот этот вот usize,
[47:09.080 --> 47:11.080]  сейчас
[47:11.080 --> 47:13.080]  покажу, наверное, будет видно.
[47:13.080 --> 47:15.080]  Ладно, потом дальше будет видно
[47:15.080 --> 47:17.080]  на слайдах.
[47:17.080 --> 47:19.080]  Представьте, что я здесь не написал двоеточие usize,
[47:19.080 --> 47:21.080]  просто ui и dx равняется 92. Это тоже
[47:21.080 --> 47:23.080]  валидно.
[47:23.080 --> 47:25.080]  Раст по умолчанию будет считать, что это тип i32.
[47:25.080 --> 47:27.080]  Если бы это были какие-то более сложные
[47:27.080 --> 47:29.080]  типы, то он бы с самого начала посмотрел,
[47:29.080 --> 47:31.080]  а как вы дальше пользуетесь этим типом в коде.
[47:31.080 --> 47:33.080]  Например, если это вектор,
[47:33.080 --> 47:35.080]  вы объявили вектор весь
[47:35.080 --> 47:37.080]  template значения.
[47:37.080 --> 47:39.080]  Ну, знаете, у вас век может быть из i32,
[47:39.080 --> 47:41.080]  а может быть из чего-то еще.
[47:41.080 --> 47:43.080]  Вот раз будет смотреть,
[47:43.080 --> 47:45.080]  а что вы пушите вектор?
[47:45.080 --> 47:47.080]  Он поймет и выведет тип.
[47:47.080 --> 47:49.080]  И если, например, будет несколько возможных типов,
[47:49.080 --> 47:51.080]  то он скажет, что
[47:51.080 --> 47:53.080]  не могу вывести,
[47:53.080 --> 47:55.080]  укажи явно.
[47:55.080 --> 47:57.080]  Это на самом деле удобно.
[47:57.080 --> 47:59.080]  То есть я вам советую даже большую часть времени
[47:59.080 --> 48:01.080]  не писать типы явно.
[48:01.080 --> 48:03.080]  Это будет
[48:03.080 --> 48:05.080]  и красивее, и более того,
[48:05.080 --> 48:07.080]  раз у вас будет делать большую часть работы.
[48:09.080 --> 48:11.080]  Смотрите, вот у нас есть
[48:11.080 --> 48:13.080]  еще bool, который может
[48:13.080 --> 48:15.080]  иметь два значения, true и false.
[48:15.080 --> 48:17.080]  В отличие от плюсов, где мы могли бы написать
[48:17.080 --> 48:19.080]  bool x равняется 12,
[48:19.080 --> 48:21.080]  это бы даже работало,
[48:21.080 --> 48:23.080]  в расти такое нельзя сделать.
[48:23.080 --> 48:25.080]  Он скажет, что вы попробовали
[48:25.080 --> 48:27.080]  присвоить целочисленное значение, что очень
[48:27.080 --> 48:29.080]  плохо.
[48:29.080 --> 48:31.080]  Плюс ко всему bool у нас занимает
[48:31.080 --> 48:33.080]  всегда один байт в памяти.
[48:33.080 --> 48:35.080]  Это будет важнее.
[48:35.080 --> 48:37.080]  То есть несмотря на то, что у нас только true и false значения,
[48:37.080 --> 48:39.080]  мы будем занимать не один бит, а один байт целый.
[48:39.080 --> 48:41.080]  То есть как мы это
[48:41.080 --> 48:43.080]  ожидаем на самом деле.
[48:43.080 --> 48:45.080]  Так, ну базовая рифметика тут есть
[48:45.080 --> 48:47.080]  на типах, плюс, минус, умножить, равно,
[48:47.080 --> 48:49.080]  делить.
[48:49.080 --> 48:51.080]  Есть деление и деление с остатком,
[48:51.080 --> 48:53.080]  которое по умолчанию округляет
[48:53.080 --> 48:55.080]  до нуля. В плюсах, насколько вы знаете,
[48:55.080 --> 48:57.080]  если вы будете отрицательное число
[48:57.080 --> 48:59.080]  делить, либо делить на
[48:59.080 --> 49:01.080]  отрицательное число, то у вас будут всякие
[49:01.080 --> 49:03.080]  непредсказуемые результаты, а в расти все
[49:03.080 --> 49:05.080]  прекрасно с этим.
[49:05.080 --> 49:07.080]  Обратите внимание на то,
[49:07.080 --> 49:09.080]  как я, кстати, объявляю переменные.
[49:09.080 --> 49:11.080]  Let x, y, например,
[49:11.080 --> 49:13.080]  в скобочках. Я сразу же
[49:13.080 --> 49:15.080]  несколько переменных объявляю.
[49:17.080 --> 49:19.080]  Значит,
[49:21.080 --> 49:23.080]  это тоже очень удобно.
[49:25.080 --> 49:27.080]  Скобочки, знаешь, в плюсах
[49:29.080 --> 49:31.080]  можно автопейер.
[49:31.080 --> 49:33.080]  То есть если хочется разбить
[49:33.080 --> 49:35.080]  пару, например, то там
[49:35.080 --> 49:37.080]  через авто это можно сделать. Примерно
[49:37.080 --> 49:39.080]  то же самое, но только в расти это на самом деле
[49:39.080 --> 49:41.080]  еще лучше устроено. Там можно, например,
[49:41.080 --> 49:43.080]  есть переменных так объявлять.
[49:45.080 --> 49:47.080]  А, как питоник?
[49:47.080 --> 49:49.080]  Да, да.
[49:49.080 --> 49:51.080]  По-моему, x, y за 5 и там
[49:51.080 --> 49:53.080]  присваивается.
[49:53.080 --> 49:55.080]  Да, здесь просто на самом деле вот этот вот
[49:55.080 --> 49:57.080]  тюпл. То есть может такой тюпл еще знаем?
[49:59.080 --> 50:01.080]  Пока что опять же можете посмотреть это
[50:01.080 --> 50:03.080]  просто как на какую-то фигню в скобочках, а потом мы
[50:03.080 --> 50:05.080]  поймем, что это на самом деле тюпл, а потом еще и
[50:05.080 --> 50:07.080]  поймем, что это pattern matching.
[50:07.080 --> 50:09.080]  Так.
[50:09.080 --> 50:11.080]  Ну, есть всякие побитые операции.
[50:11.080 --> 50:13.080]  Очень важный момент у нас нет.
[50:13.080 --> 50:15.080]  Операции плюс-плюс-инкремент.
[50:15.080 --> 50:17.080]  Вы знаете, у нас есть префиксные и постфиксные
[50:17.080 --> 50:19.080]  плюсах-инкременты, из-за них может случайно
[50:19.080 --> 50:21.080]  случиться головная боль. В плюсах
[50:21.080 --> 50:23.080]  если вы хотите добавить или отнять,
[50:23.080 --> 50:25.080]  в плюсах пишется плюс равно один, минус равно один.
[50:25.080 --> 50:27.080]  В питоне, например,
[50:27.080 --> 50:29.080]  он бы сделал точно так же.
[50:29.080 --> 50:31.080]  На самом деле это никакой головной боли не
[50:31.080 --> 50:33.080]  дает, это просто удобно.
[50:33.080 --> 50:35.080]  В том смысле, что
[50:35.080 --> 50:37.080]  не нужно думать
[50:37.080 --> 50:39.080]  какой он там
[50:39.080 --> 50:41.080]  префиксный или постфиксный, нужно использовать
[50:41.080 --> 50:43.080]  инкременты, как перегружать свои классы
[50:43.080 --> 50:45.080]  и так далее.
[50:45.080 --> 50:47.080]  Так. Ну, и всякие есть функции
[50:47.080 --> 50:49.080]  прекрасные. Вот, например, у нас есть
[50:49.080 --> 50:51.080]  на числе минус 92
[50:51.080 --> 50:53.080]  и 32 функция ABS. Ну, соответственно
[50:53.080 --> 50:55.080]  она вернет просто 92.
[50:55.080 --> 50:57.080]  Через точечку позвали на числе
[50:57.080 --> 50:59.080]  что-то. Count once это pop-knt,
[50:59.080 --> 51:01.080]  если вы знаете такую инструкцию
[51:01.080 --> 51:03.080]  на компьютере. То есть число единичек считает.
[51:05.080 --> 51:07.080]  Там скобочки используются
[51:07.080 --> 51:09.080]  потому что
[51:09.080 --> 51:11.080]  минус? Да, да, да.
[51:11.080 --> 51:13.080]  Скобочки потому что
[51:13.080 --> 51:15.080]  минус, так бы было не обязательно.
[51:15.080 --> 51:17.080]  Если без скобочек, то тогда
[51:17.080 --> 51:19.080]  получится минус 92, потому что
[51:19.080 --> 51:21.080]  сначала точка применится, потом минус.
[51:21.080 --> 51:23.080]  У нас каждый
[51:23.080 --> 51:25.080]  человек объект, у них есть
[51:25.080 --> 51:27.080]  эти методы?
[51:27.080 --> 51:29.080]  Ну да, там можно имплементировать
[51:29.080 --> 51:31.080]  в будущем, поговорим про трейты,
[51:31.080 --> 51:33.080]  и можно будет имплементировать трейты
[51:33.080 --> 51:35.080]  для чисел. То есть там
[51:35.080 --> 51:37.080]  интерфейсы для чисел.
[51:39.080 --> 51:41.080]  Ну, можно будет протыгать потом на ссылочку
[51:41.080 --> 51:43.080]  на презентации, там будет полный список
[51:43.080 --> 51:45.080]  операторов всяких.
[51:45.080 --> 51:47.080]  Что еще раз?
[51:47.080 --> 51:49.080]  Возведение степени
[51:49.080 --> 51:51.080]  Быстрая возведение степени
[51:55.080 --> 51:57.080]  Так, потом у нас нет
[51:59.080 --> 52:01.080]  неявного кастотипов.
[52:01.080 --> 52:03.080]  То есть, например
[52:03.080 --> 52:05.080]  ну, можете пока посмотреть, пока я водичку
[52:17.080 --> 52:19.080]  Ну, как видите, у нас X это U16
[52:19.080 --> 52:21.080]  переменная, а Y это
[52:21.080 --> 52:23.080]  U32. И
[52:23.080 --> 52:25.080]  дело в том, что когда мы пытаемся Q32
[52:25.080 --> 52:27.080]  U16 применить, то, казалось бы, оно
[52:27.080 --> 52:29.080]  должно было бы и работать, как в плюсах,
[52:29.080 --> 52:31.080]  но в первый раз такое не позволяет.
[52:31.080 --> 52:33.080]  Он просит явно с помощью S
[52:33.080 --> 52:35.080]  сконвертировать.
[52:35.080 --> 52:37.080]  То есть как-то можно увидеть
[52:37.080 --> 52:39.080]  чуть-чуть ниже.
[52:43.080 --> 52:45.080]  Ну, просто чтоб все было явно.
[52:45.080 --> 52:47.080]  Там могут быть всякие непредсказуемые
[52:47.080 --> 52:49.080]  последствия из-за этого. Например, вот здесь
[52:49.080 --> 52:51.080]  было бы еще нормально, а когда
[52:51.080 --> 52:53.080]  пытаешься скастовать более большой
[52:53.080 --> 52:55.080]  тип, более маленький, там врезаются
[52:55.080 --> 52:57.080]  байты, и получается плохо.
[52:57.080 --> 52:59.080]  Мы можем этого не ожидать.
[52:59.080 --> 53:01.080]  На самом деле, это то, что иногда раздражает
[53:01.080 --> 53:03.080]  людей в расте, вот эта вот
[53:03.080 --> 53:05.080]  слишком большая явность.
[53:11.080 --> 53:13.080]  Да, кстати, у меня здесь
[53:13.080 --> 53:15.080]  на самом деле
[53:15.080 --> 53:17.080]  появляется X, а потом используется Y, который
[53:17.080 --> 53:19.080]  не объявлен. Ну, здесь
[53:19.080 --> 53:21.080]  это должен быть X. И здесь
[53:21.080 --> 53:23.080]  это должно быть...
[53:23.080 --> 53:25.080]  Да-да, кажется.
[53:25.080 --> 53:27.080]  Да-да-да.
[53:27.080 --> 53:29.080]  Да, сейчас. Я просто, наверное,
[53:29.080 --> 53:31.080]  пропустил строчку. Здесь должно быть
[53:31.080 --> 53:33.080]  let y у 32 равняется
[53:33.080 --> 53:35.080]  xs у 32, где-то.
[53:35.080 --> 53:37.080]  И после этого, если вы хотите
[53:37.080 --> 53:39.080]  Z из Y сделать, тогда вам нужно S у 16
[53:39.080 --> 53:41.080]  написать. Плюс есть такая штука
[53:41.080 --> 53:43.080]  называется Inta.
[53:43.080 --> 53:45.080]  Она пытается ваш текущий тип
[53:45.080 --> 53:47.080]  привести к тому типу,
[53:47.080 --> 53:49.080]  который слева.
[53:49.080 --> 53:51.080]  То есть это опять же TypeInference.
[53:51.080 --> 53:53.080]  Он раз попытается понять, к какому типу
[53:53.080 --> 53:55.080]  вы пытаетесь привести.
[53:55.080 --> 53:57.080]  И, например, если вы написали let y
[53:57.080 --> 53:59.080]  равняется xInta и не используете
[53:59.080 --> 54:01.080]  этот тип, то раз бы не понял,
[54:01.080 --> 54:03.080]  почему вы пытаетесь привести. А если вы после этого
[54:03.080 --> 54:05.080]  попробуете к Y, например, присвоить значение
[54:05.080 --> 54:07.080]  к кому-нибудь y32, то тогда
[54:07.080 --> 54:09.080]  Rast поймет, ага, ну, значит он после этого
[54:09.080 --> 54:11.080]  пользуется как y32 этим.
[54:11.080 --> 54:13.080]  Соответственно, этот Inta должен
[54:13.080 --> 54:15.080]  перевести y в y32.
[54:15.080 --> 54:17.080]  В чем отличие?
[54:17.080 --> 54:19.080]  То есть Inta просто
[54:19.080 --> 54:21.080]  отдельно не угадываем к какому типу.
[54:21.080 --> 54:23.080]  Ну, Inta это на самом деле метод трейта.
[54:23.080 --> 54:25.080]  Это такая штука,
[54:25.080 --> 54:27.080]  чуть более продвинутая.
[54:27.080 --> 54:29.080]  И не обязательно пока что пользоваться
[54:29.080 --> 54:31.080]  на уровне числовых типов. Я думаю, что
[54:31.080 --> 54:33.080]  даже, наверное, лучше дождаться третьей лекции, чтобы
[54:33.080 --> 54:35.080]  понять, что это. Это я заранее написал.
[54:35.080 --> 54:37.080]  То есть, честно, лучше использовать
[54:37.080 --> 54:39.080]  as, а с более большими
[54:39.080 --> 54:41.080]  объектами.
[54:43.080 --> 54:45.080]  Ну, нет, на самом деле
[54:45.080 --> 54:47.080]  Inta пытается
[54:47.080 --> 54:49.080]  закастить один тип к другому.
[54:51.080 --> 54:53.080]  Вот, ну, мы имплементируем как бы
[54:53.080 --> 54:55.080]  ну, представьте в плюсах, что у вас появилась функция
[54:55.080 --> 54:57.080]  Inta, которая принимает
[54:57.080 --> 54:59.080]  на вход, ну, функция класса,
[54:59.080 --> 55:01.080]  которая берет
[55:01.080 --> 55:03.080]  ваш текущий объект, класса,
[55:03.080 --> 55:05.080]  и превращает его в какой-то другой,
[55:05.080 --> 55:07.080]  возвращает его. Вот Inta
[55:07.080 --> 55:09.080]  это то самое.
[55:09.080 --> 55:11.080]  А s это такой
[55:11.080 --> 55:13.080]  явный оператор кастинга
[55:13.080 --> 55:15.080]  просто. Он только с примитивными
[55:15.080 --> 55:17.080]  работает всякими кастами.
[55:21.080 --> 55:23.080]  И там всякие есть способы
[55:23.080 --> 55:25.080]  обрезать лидинг зирус.
[55:29.080 --> 55:31.080]  Еще вот, важный такой момент,
[55:31.080 --> 55:33.080]  то, что кастинг нетрандитивен.
[55:33.080 --> 55:35.080]  То есть, у вас может такое
[55:35.080 --> 55:37.080]  случиться, что если вы сначала
[55:37.080 --> 55:39.080]  в u1 переведете, а потом в u2,
[55:39.080 --> 55:41.080]  то это не то же самое, что вы сразу
[55:41.080 --> 55:43.080]  в u2 переведете.
[55:43.080 --> 55:45.080]  Это будет явно видно,
[55:45.080 --> 55:47.080]  то есть, числами типов нет, но
[55:47.080 --> 55:49.080]  когда у вас будут более сложные типы, тогда уже
[55:49.080 --> 55:51.080]  может быть совсем неправдой.
[55:51.080 --> 55:53.080]  Ну, мы это увидим
[55:53.080 --> 55:55.080]  что-то попозже.
[55:57.080 --> 55:59.080]  Нет, там будут трейд-объекты,
[55:59.080 --> 56:01.080]  там сложнее будут s, там на них
[56:01.080 --> 56:03.080]  тоже работает.
[56:03.080 --> 56:05.080]  В общем, пока что просто запомните
[56:05.080 --> 56:07.080]  то, что кастинг это нетрандитивная
[56:07.080 --> 56:09.080]  вещь.
[56:09.080 --> 56:11.080]  Примеры будут чуть-чуть попозже.
[56:11.080 --> 56:13.080]  Почему?
[56:13.080 --> 56:15.080]  Сейчас, вы еще раз сказали,
[56:15.080 --> 56:17.080]  что s работает с примитивными
[56:17.080 --> 56:19.080]  типами.
[56:19.080 --> 56:21.080]  Примитивные типы
[56:21.080 --> 56:23.080]  кастуют только всякие числовые типы,
[56:23.080 --> 56:25.080]  еще всякие трейты, такие вот вещи.
[56:25.080 --> 56:27.080]  Он не способен
[56:27.080 --> 56:29.080]  кастовать один клад с другому, например.
[56:29.080 --> 56:31.080]  Для этого нужно писать
[56:31.080 --> 56:33.080]  trade-into.
[56:33.080 --> 56:35.080]  Я, наверное, вас
[56:35.080 --> 56:37.080]  пугаю, конечно. Trade-into, да?
[56:37.080 --> 56:39.080]  Никто ничего не понял, наверное.
[56:39.080 --> 56:41.080]  Все испугались.
[56:41.080 --> 56:43.080]  Да, ну, вообще, не берите пока что в голову,
[56:43.080 --> 56:45.080]  это не то, что обязательно понимать на этой лекции.
[56:45.080 --> 56:47.080]  Если вы не поняли, значит, все хорошо.
[57:11.080 --> 57:13.080]  Так, еще вот такая вот необычность есть.
[57:13.080 --> 57:15.080]  Вот мы берем.
[57:15.080 --> 57:17.080]  Тут, кстати, говорит, ошибка
[57:17.080 --> 57:19.080]  есть у меня.
[57:19.080 --> 57:21.080]  Если что, функция maxValue, она
[57:21.080 --> 57:23.080]  deprecated. Используйте функцию,
[57:23.080 --> 57:25.080]  то есть двоеточие, там просто max.
[57:25.080 --> 57:27.080]  Это я опечатался конкретно на этом слайде.
[57:27.080 --> 57:29.080]  Ладно, потом будет видно.
[57:29.080 --> 57:31.080]  Тоже будет уже нормальная max.
[57:31.080 --> 57:33.080]  Deprecated функция, в общем.
[57:33.080 --> 57:35.080]  Если вы, как субпроводитель,
[57:35.080 --> 57:37.080]  добавите единичку, ну, тогда у вас, по идее,
[57:37.080 --> 57:39.080]  в плюсах бы получился
[57:39.080 --> 57:41.080]  minValue, да?
[57:41.080 --> 57:43.080]  То есть там минус сколько, там, 2 миллиарда.
[57:43.080 --> 57:45.080]  Вот. А в расе
[57:45.080 --> 57:47.080]  вы получите, в случае дебаг-сборки,
[57:47.080 --> 57:49.080]  по умолчанию, как вы можете заметить,
[57:49.080 --> 57:51.080]  вот пакет manager.cargo,
[57:51.080 --> 57:53.080]  да и, в принципе, расе, они компилируют
[57:53.080 --> 57:55.080]  в дебаг-сборке.
[57:55.080 --> 57:57.080]  И они,
[57:57.080 --> 57:59.080]  ну, в общем-то, паникуют,
[57:59.080 --> 58:01.080]  если такое происходит. Вот в релизе
[58:01.080 --> 58:03.080]  вы получите, ну, правильное значение,
[58:03.080 --> 58:05.080]  которое вы ожидаете, скажем так.
[58:05.080 --> 58:07.080]  Чтобы этого не было, нужно использовать
[58:07.080 --> 58:09.080]  всякие там saturating cut,
[58:11.080 --> 58:13.080]  там unwrapped, at и подобное.
[58:15.080 --> 58:17.080]  Вот, вот здесь нормально уже написано.
[58:17.080 --> 58:19.080]  Вот, не запоминайте,
[58:19.080 --> 58:21.080]  в общем-то, вот в эти вот maxValue,
[58:21.080 --> 58:23.080]  запомните вот это вот.
[58:23.080 --> 58:25.080]  Это не deprecated, правильно
[58:25.080 --> 58:27.080]  писать вот так вот.
[58:29.080 --> 58:31.080]  Ну, смотрите, в wrapping cut мы получаем
[58:31.080 --> 58:33.080]  один конкретно.
[58:33.080 --> 58:35.080]  Если мы делаем saturating cut,
[58:35.080 --> 58:37.080]  то мы, ну, в wrapping это
[58:37.080 --> 58:39.080]  просто, по сути, мы переходим
[58:39.080 --> 58:41.080]  даже как и в плюсах все работает.
[58:41.080 --> 58:43.080]  Saturating это как бы
[58:43.080 --> 58:45.080]  с английского правильно
[58:45.080 --> 58:47.080]  перевести, наполняющий, да,
[58:47.080 --> 58:49.080]  насыщающий, вот так вот.
[58:49.080 --> 58:51.080]  Он добавляет до тех пор, пока у вас не получится
[58:51.080 --> 58:53.080]  max.
[58:53.080 --> 58:55.080]  Потом есть overflowing cut,
[58:55.080 --> 58:57.080]  если у вас overflow получился, тогда он вернет
[58:57.080 --> 58:59.080]  вам, ну, то есть он возвращает по факту tuple
[58:59.080 --> 59:01.080]  из двух элементов.
[59:01.080 --> 59:03.080]  Один результат суммы, а второй
[59:03.080 --> 59:05.080]  это boo,
[59:05.080 --> 59:07.080]  переполнились ли вы.
[59:07.080 --> 59:09.080]  Ну, как вы видите, этот tuple,
[59:09.080 --> 59:11.080]  как в питоне, вот,
[59:11.080 --> 59:13.080]  я его раскрыл.
[59:13.080 --> 59:15.080]  Ну и assert это такой macros, который паникует,
[59:15.080 --> 59:17.080]  если внутри него что-то false.
[59:17.080 --> 59:19.080]  С ошибкой.
[59:21.080 --> 59:23.080]  В wrapping cut
[59:23.080 --> 59:25.080]  это просто как в плюсах
[59:25.080 --> 59:27.080]  начинает все работать, то есть, ну, там идет
[59:27.080 --> 59:29.080]  вокруг. То есть мы перейдем в
[59:29.080 --> 59:31.080]  min значение и дальше.
[59:31.080 --> 59:33.080]  Я надеюсь нормально.
[59:33.080 --> 59:35.080]  Так.
[59:35.080 --> 59:37.080]  Ну и, соответственно,
[59:37.080 --> 59:39.080]  получим в случае с overflowing cut,
[59:39.080 --> 59:41.080]  то же самое, что с rating cut, но еще
[59:41.080 --> 59:43.080]  получим результат overflowing
[59:43.080 --> 59:45.080]  у нас или нет.
[59:45.080 --> 59:47.080]  А дальше, смотрите, у нас есть такая штука,
[59:47.080 --> 59:49.080]  называется match.
[59:49.080 --> 59:51.080]  Вот, мы пытаемся
[59:51.080 --> 59:53.080]  добавить единичку.
[59:53.080 --> 59:55.080]  Если у нас,
[59:55.080 --> 59:57.080]  ну, checked at, это такая штука,
[59:57.080 --> 59:59.080]  которая на самом деле возвращает
[59:59.080 --> 01:00:01.080]  option. Что такое option?
[01:00:01.080 --> 01:00:03.080]  Тоже увидим чуть-чуть попозже на слайдах.
[01:00:03.080 --> 01:00:05.080]  Match, он, ну,
[01:00:05.080 --> 01:00:07.080]  option это такой genum,
[01:00:07.080 --> 01:00:09.080]  который имеет сам значение,
[01:00:09.080 --> 01:00:11.080]  ну, сам value, либо
[01:00:11.080 --> 01:00:13.080]  noun. Сам value,
[01:00:13.080 --> 01:00:15.080]  если у нас вернулся сам y,
[01:00:15.080 --> 01:00:17.080]  какой-то там y, то в таком случае,
[01:00:17.080 --> 01:00:19.080]  ну, у нас такое не может произойти, есть такой
[01:00:19.080 --> 01:00:21.080]  macros unreachable, который паникует,
[01:00:21.080 --> 01:00:23.080]  если вдруг мы до него дошли.
[01:00:23.080 --> 01:00:25.080]  В курсе липовского, кстати, вы могли это видеть.
[01:00:25.080 --> 01:00:27.080]  Каких-то строчков.
[01:00:27.080 --> 01:00:29.080]  Ну, и если
[01:00:29.080 --> 01:00:31.080]  noun, то тогда мы выводим
[01:00:31.080 --> 01:00:33.080]  overflow.
[01:00:33.080 --> 01:00:35.080]  Так.
[01:00:35.080 --> 01:00:37.080]  Match, он похож на switch,
[01:00:37.080 --> 01:00:39.080]  но он на самом деле другой.
[01:00:39.080 --> 01:00:41.080]  Это крутой pattern matching,
[01:00:41.080 --> 01:00:43.080]  который, ну, pattern matching мы сейчас
[01:00:43.080 --> 01:00:45.080]  разберем.
[01:00:45.080 --> 01:00:47.080]  Довольно просто сложно, когда
[01:00:47.080 --> 01:00:49.080]  только начинаешь изучать раст,
[01:00:49.080 --> 01:00:51.080]  очень много концепций, которые друг за друга держатся,
[01:00:51.080 --> 01:00:53.080]  в том числе trait, и вот я не знал,
[01:00:53.080 --> 01:00:55.080]  как это подать.
[01:00:55.080 --> 01:00:57.080]  Вот.
[01:00:57.080 --> 01:00:59.080]  И теперь давайте посмотрим на float.
[01:00:59.080 --> 01:01:01.080]  У нас есть
[01:01:01.080 --> 01:01:03.080]  f32,
[01:01:03.080 --> 01:01:05.080]  и, в общем-то,
[01:01:05.080 --> 01:01:07.080]  у нас по умолчанию кажется
[01:01:07.080 --> 01:01:09.080]  f64 при выводе.
[01:01:09.080 --> 01:01:11.080]  Да, у нас кажется
[01:01:11.080 --> 01:01:13.080]  f64 по дефолту для float,
[01:01:13.080 --> 01:01:15.080]  поэтому x будет f64,
[01:01:15.080 --> 01:01:17.080]  туда мы присваиваем.
[01:01:17.080 --> 01:01:19.080]  Вот.
[01:01:19.080 --> 01:01:21.080]  Так. Ну, и очень важно
[01:01:21.080 --> 01:01:23.080]  писать точку, потому что иначе мы просто получаем
[01:01:23.080 --> 01:01:25.080]  целочистое значение.
[01:01:25.080 --> 01:01:27.080]  Ну, и всякие macros,
[01:01:27.080 --> 01:01:29.080]  non, infinity,
[01:01:29.080 --> 01:01:31.080]  infinity.
[01:01:31.080 --> 01:01:33.080]  Ну, и точно так же есть всякие
[01:01:33.080 --> 01:01:35.080]  sales, sin, round, square root
[01:01:35.080 --> 01:01:37.080]  у float.
[01:01:37.080 --> 01:01:39.080]  Почему там добавляется STD
[01:01:39.080 --> 01:01:41.080]  2.0? До этого мы вроде не добавляли.
[01:01:41.080 --> 01:01:43.080]  Вот это
[01:01:43.080 --> 01:01:45.080]  зависит от того,
[01:01:45.080 --> 01:01:47.080]  заимпорчено это или нет.
[01:01:47.080 --> 01:01:49.080]  То есть у нас
[01:01:49.080 --> 01:01:51.080]  какая-то вещь, какую-то
[01:01:51.080 --> 01:01:53.080]  часть библиотеки раст импортирует
[01:01:53.080 --> 01:01:55.080]  в STD prelude. Это, знаете, грубо говоря,
[01:01:55.080 --> 01:01:57.080]  include prelude.
[01:01:57.080 --> 01:01:59.080]  И prelude это какой-то
[01:01:59.080 --> 01:02:01.080]  набор вещей,
[01:02:01.080 --> 01:02:03.080]  которые используются практически в каждый раз в
[01:02:03.080 --> 01:02:05.080]  программе, и поэтому их не нужно
[01:02:05.080 --> 01:02:07.080]  отдельно импортить.
[01:02:07.080 --> 01:02:09.080]  Можно prelude убрать, но чаще всего это не
[01:02:09.080 --> 01:02:11.080]  делают.
[01:02:11.080 --> 01:02:13.080]  Ну, и конкретно вот эти вещи, они не
[01:02:13.080 --> 01:02:15.080]  заимпорчены, поэтому мы прописываем
[01:02:15.080 --> 01:02:17.080]  полностью.
[01:02:19.080 --> 01:02:21.080]  Так.
[01:02:21.080 --> 01:02:23.080]  У нас
[01:02:23.080 --> 01:02:25.080]  есть Boolean.
[01:02:25.080 --> 01:02:27.080]  Тут все просто. Кажется true.
[01:02:27.080 --> 01:02:29.080]  Не true, скажем так.
[01:02:29.080 --> 01:02:31.080]  И true или не true.
[01:02:31.080 --> 01:02:33.080]  Вот. С этой части
[01:02:33.080 --> 01:02:35.080]  есть вопрос?
[01:02:35.080 --> 01:02:37.080]  Кажется, все супер просто.
[01:02:37.080 --> 01:02:39.080]  А lazy это значит
[01:02:39.080 --> 01:02:41.080]  как?
[01:02:41.080 --> 01:02:43.080]  Ну, то есть если там
[01:02:43.080 --> 01:02:45.080]  n, то видишь, то слева уже 0,
[01:02:45.080 --> 01:02:47.080]  то можно не проверять.
[01:02:47.080 --> 01:02:49.080]  Второе, и то же самое с form, если
[01:02:49.080 --> 01:02:51.080]  левая часть уже 1.
[01:02:53.080 --> 01:02:55.080]  Так. Наконец мы дошли до tuples.
[01:02:55.080 --> 01:02:57.080]  Tuple такая вещь, которая пишется
[01:02:57.080 --> 01:02:59.080]  в скобочках.
[01:02:59.080 --> 01:03:01.080]  Да. Ну, вообще конкретно
[01:03:01.080 --> 01:03:03.080]  это называется compound type.
[01:03:07.080 --> 01:03:09.080]  С нет.
[01:03:09.080 --> 01:03:11.080]  Ну, то есть я
[01:03:11.080 --> 01:03:13.080]  можно, наверное, проверить.
[01:03:13.080 --> 01:03:15.080]  Если сделать struct, например,
[01:03:15.080 --> 01:03:17.080]  там, не знаю.
[01:03:17.080 --> 01:03:19.080]  Сделаем какой-нибудь struct i, ну, структурку
[01:03:19.080 --> 01:03:21.080]  и внутри структурки можем попробовать
[01:03:21.080 --> 01:03:23.080]  создать f32 и 32
[01:03:23.080 --> 01:03:25.080]  и привести его к tuple.
[01:03:25.080 --> 01:03:27.080]  Но кажется, что это не должно работать.
[01:03:27.080 --> 01:03:29.080]  Я никогда так не делал.
[01:03:29.080 --> 01:03:31.080]  Ну, скорее всего, вас так не прикастует,
[01:03:31.080 --> 01:03:33.080]  потому что там непонятно,
[01:03:33.080 --> 01:03:35.080]  что внутри структуры находится.
[01:03:35.080 --> 01:03:37.080]  Вот.
[01:03:37.080 --> 01:03:39.080]  Да, даже, наверное, не прикастует без unsafe.
[01:03:39.080 --> 01:03:41.080]  Вот.
[01:03:41.080 --> 01:03:43.080]  Слева вы
[01:03:43.080 --> 01:03:45.080]  на PR можете видеть, как мы пишем
[01:03:45.080 --> 01:03:47.080]  через запятую типы, а справа, ну, собственно,
[01:03:47.080 --> 01:03:49.080]  значение. Ну, и точно так же
[01:03:49.080 --> 01:03:51.080]  например, деструктуризацию
[01:03:51.080 --> 01:03:53.080]  пары сделать.
[01:03:53.080 --> 01:03:55.080]  У нас есть пара, да, и слева у нас есть
[01:03:55.080 --> 01:03:57.080]  x, y в скобочках.
[01:03:57.080 --> 01:03:59.080]  И соответственно, у нас получится в x и y значение
[01:03:59.080 --> 01:04:01.080]  0, а в y и 92.
[01:04:01.080 --> 01:04:03.080]  Это то же самое, что снизу.
[01:04:03.080 --> 01:04:05.080]  То есть latX
[01:04:05.080 --> 01:04:07.080]  это PR0, ну, PR0
[01:04:07.080 --> 01:04:09.080]  и PR1 это y.
[01:04:09.080 --> 01:04:11.080]  Только есть
[01:04:11.080 --> 01:04:13.080]  тут такой нюансик. Дело в том, что здесь
[01:04:13.080 --> 01:04:15.080]  используется такая штука, называется
[01:04:15.080 --> 01:04:17.080]  shadowing.
[01:04:17.080 --> 01:04:19.080]  Думаю, кажется, на следующих слайдах будет.
[01:04:19.080 --> 01:04:21.080]  Да, там будет про shadowing.
[01:04:21.080 --> 01:04:23.080]  В общем-то,
[01:04:23.080 --> 01:04:25.080]  в двух словах, это когда вы
[01:04:25.080 --> 01:04:27.080]  переменную
[01:04:27.080 --> 01:04:29.080]  затеняете, ну, то есть вы объявляете
[01:04:29.080 --> 01:04:31.080]  одну, потом другую с таким же именем,
[01:04:31.080 --> 01:04:33.080]  первая не диалацируется.
[01:04:33.080 --> 01:04:35.080]  Она просто, по сравнению со
[01:04:35.080 --> 01:04:37.080]  второй,
[01:04:37.080 --> 01:04:39.080]  ну, как сказать,
[01:04:39.080 --> 01:04:41.080]  так.
[01:04:41.080 --> 01:04:43.080]  В общем,
[01:04:43.080 --> 01:04:45.080]  она просто скрывает
[01:04:45.080 --> 01:04:47.080]  другую переменную и используется последняя
[01:04:47.080 --> 01:04:49.080]  из них дальше в коде.
[01:04:49.080 --> 01:04:51.080]  Нельзя как-то обратиться к той?
[01:04:51.080 --> 01:04:53.080]  Ну, сейчас будут примеры.
[01:04:53.080 --> 01:04:55.080]  Обратиться к той выше нельзя?
[01:04:55.080 --> 01:04:57.080]  Нет, такого же. То есть мы
[01:04:57.080 --> 01:04:59.080]  память в добратье
[01:04:59.080 --> 01:05:01.080]  устраиваем?
[01:05:01.080 --> 01:05:03.080]  Там раз будет сам дропать значения,
[01:05:03.080 --> 01:05:05.080]  если, ну, например, в данном случае x и y,
[01:05:05.080 --> 01:05:07.080]  старые нам
[01:05:07.080 --> 01:05:09.080]  не понадобятся, и раз их,
[01:05:09.080 --> 01:05:11.080]  если мы компилируем с оптимизацией, даже дропнет.
[01:05:11.080 --> 01:05:13.080]  Ну, я покажу, там есть примеры, где я
[01:05:13.080 --> 01:05:15.080]  даже проверил это в Godbolt,
[01:05:15.080 --> 01:05:17.080]  что это работает как нужно.
[01:05:17.080 --> 01:05:19.080]  Так.
[01:05:19.080 --> 01:05:21.080]  Потом у нас есть void result.
[01:05:21.080 --> 01:05:23.080]  Смотрите, у нас есть такой
[01:05:23.080 --> 01:05:25.080]  тип, называется unit.
[01:05:25.080 --> 01:05:27.080]  В плюсах. А unit это просто
[01:05:27.080 --> 01:05:29.080]  пустой тюпл, то есть сковочки.
[01:05:29.080 --> 01:05:31.080]  И println
[01:05:31.080 --> 01:05:33.080]  и всякие такие вещи они получают и
[01:05:33.080 --> 01:05:35.080]  возвращают union.
[01:05:35.080 --> 01:05:37.080]  Ну, точнее не union,
[01:05:37.080 --> 01:05:39.080]  unit.
[01:05:39.080 --> 01:05:41.080]  Еще, когда вы объявляете
[01:05:41.080 --> 01:05:43.080]  всякие вещи, связанные
[01:05:43.080 --> 01:05:45.080]  с перечислением тюпла,
[01:05:45.080 --> 01:05:47.080]  то вы можете, например, писать запятую в самом конце.
[01:05:47.080 --> 01:05:49.080]  Вот смотрите, здесь вот battle,
[01:05:49.080 --> 01:05:51.080]  здесь есть запятая.
[01:05:51.080 --> 01:05:53.080]  Ее можно и не писать.
[01:05:53.080 --> 01:05:55.080]  То есть это просто уже на ваше
[01:05:55.080 --> 01:05:57.080]  усмотрение. Но чаще всего удобно.
[01:05:57.080 --> 01:05:59.080]  Так, теперь давайте поговорим
[01:05:59.080 --> 01:06:01.080]  про следование чуть побольше.
[01:06:01.080 --> 01:06:03.080]  println возвращает
[01:06:03.080 --> 01:06:05.080]  unit.
[01:06:05.080 --> 01:06:07.080]  И как бы это аналог void?
[01:06:07.080 --> 01:06:09.080]  Ну да, это аналог void, но только void
[01:06:09.080 --> 01:06:11.080]  в плюсах это вообще просто
[01:06:11.080 --> 01:06:13.080]  отсутствие значения. А здесь это целый тип.
[01:06:13.080 --> 01:06:15.080]  Нет, здесь unit.
[01:06:15.080 --> 01:06:17.080]  Все заменяет.
[01:06:17.080 --> 01:06:19.080]  То есть даже функции, которые не возвращают значение,
[01:06:19.080 --> 01:06:21.080]  на самом деле возвращают unit.
[01:06:21.080 --> 01:06:23.080]  Да.
[01:06:23.080 --> 01:06:25.080]  Вот.
[01:06:25.080 --> 01:06:27.080]  А что выведет этот код, как вы думаете?
[01:06:27.080 --> 01:06:29.080]  Вот у нас здесь
[01:06:29.080 --> 01:06:31.080]  shadow, как вы можете видеть. У нас есть
[01:06:31.080 --> 01:06:33.080]  x равняется 10, а дальше мы там в цикле
[01:06:33.080 --> 01:06:35.080]  если x равен 10, то тогда выводим
[01:06:35.080 --> 01:06:37.080]  if.
[01:06:37.080 --> 01:06:39.080]  Обратите внимание, здесь
[01:06:39.080 --> 01:06:41.080]  в println я написал как будто это f строки
[01:06:41.080 --> 01:06:43.080]  в плюсах. Ну то есть я там
[01:06:43.080 --> 01:06:45.080]  в фигуристых скобочках написал if.
[01:06:45.080 --> 01:06:47.080]  Если что, этот синтакс сейчас появился
[01:06:47.080 --> 01:06:49.080]  буквально пару недель в 1.58.1
[01:06:49.080 --> 01:06:51.080]  расте. То есть самым последним.
[01:06:51.080 --> 01:06:53.080]  Поэтому вот
[01:06:53.080 --> 01:06:55.080]  современность.
[01:06:55.080 --> 01:06:57.080]  Конечно.
[01:06:57.080 --> 01:06:59.080]  Так.
[01:06:59.080 --> 01:07:01.080]  Ну да, он уже
[01:07:01.080 --> 01:07:03.080]  1.58.1 раст будет.
[01:07:03.080 --> 01:07:05.080]  Так.
[01:07:05.080 --> 01:07:07.080]  Ну и вот смотрите.
[01:07:07.080 --> 01:07:09.080]  И дальше x равняется 12.
[01:07:09.080 --> 01:07:11.080]  Казалось бы, это x
[01:07:11.080 --> 01:07:13.080]  заменил на 12.
[01:07:13.080 --> 01:07:15.080]  Ну и как вы думаете, что выведет этот код?
[01:07:15.080 --> 01:07:17.080]  5 раз
[01:07:17.080 --> 01:07:19.080]  выведет
[01:07:19.080 --> 01:07:21.080]  от 0 до
[01:07:21.080 --> 01:07:23.080]  4.
[01:07:23.080 --> 01:07:25.080]  Так, мне кажется, здесь
[01:07:25.080 --> 01:07:27.080]  да
[01:07:27.080 --> 01:07:29.080]  сильно. Ладно, ладно.
[01:07:29.080 --> 01:07:31.080]  А, я понял. Я забыл.
[01:07:31.080 --> 01:07:33.080]  Давайте на этот код посмотрим.
[01:07:33.080 --> 01:07:35.080]  Чтобы вам было видно, я сделал так, чтобы это...
[01:07:35.080 --> 01:07:37.080]  А, ну у меня еще и output
[01:07:37.080 --> 01:07:39.080]  тут неправильный, короче, будет.
[01:07:39.080 --> 01:07:41.080]  Потому что я полностью все обезматил.
[01:07:41.080 --> 01:07:43.080]  Здесь должно быть вместо 10 и 12.
[01:07:43.080 --> 01:07:45.080]  Да, здесь должно быть 12.
[01:07:45.080 --> 01:07:47.080]  Я просто менял несколько раз там положение
[01:07:47.080 --> 01:07:49.080]  принта и такое вот.
[01:07:49.080 --> 01:07:51.080]  Ну, в общем-то, здесь должно быть конкретно в данном случае
[01:07:51.080 --> 01:07:53.080]  0,12, 1,12,
[01:07:53.080 --> 01:07:55.080]  2,12. Ну то есть вы, по сути, правильно
[01:07:55.080 --> 01:07:57.080]  ответили на этот вот вопрос.
[01:07:59.080 --> 01:08:01.080]  То есть, как вы видите, x никуда не девается.
[01:08:01.080 --> 01:08:03.080]  Просто у нас в новом скопе другая переменная.
[01:08:03.080 --> 01:08:05.080]  Вот.
[01:08:05.080 --> 01:08:07.080]  А в ступле можно несколько?
[01:08:07.080 --> 01:08:09.080]  То есть там может быть
[01:08:09.080 --> 01:08:11.080]  быстрее объекты внутри, типа или только два?
[01:08:11.080 --> 01:08:13.080]  Сколько угодно.
[01:08:13.080 --> 01:08:15.080]  Ну, не прямо сколько угодно, до 32.
[01:08:15.080 --> 01:08:17.080]  В ступле объектов
[01:08:17.080 --> 01:08:19.080]  объявите на какое-то имя xxx,
[01:08:19.080 --> 01:08:21.080]  ладно?
[01:08:21.080 --> 01:08:23.080]  В плане let xxx
[01:08:23.080 --> 01:08:25.080]  равняется там, не знаю. Нет, это же
[01:08:25.080 --> 01:08:27.080]  то же самое будет, что let x равняется,
[01:08:27.080 --> 01:08:29.080]  let x равняется, let x равняется.
[01:08:29.080 --> 01:08:31.080]  А плане не сломается? Просто вот
[01:08:31.080 --> 01:08:33.080]  будет значение последнее
[01:08:33.080 --> 01:08:35.080]  под x?
[01:08:35.080 --> 01:08:37.080]  Не расскажу, что вы...
[01:08:37.080 --> 01:08:39.080]  вам нельзя так делать.
[01:08:43.080 --> 01:08:45.080]  А у нас есть объединение
[01:08:45.080 --> 01:08:47.080]  какой-то тюпл?
[01:08:47.080 --> 01:08:49.080]  Ну, вот если мы хотим
[01:08:49.080 --> 01:08:51.080]  в тюпл, давайте третье значение.
[01:08:51.080 --> 01:08:53.080]  То есть, что
[01:08:53.080 --> 01:08:55.080]  мы хотим? У нас есть тюпл.
[01:08:55.080 --> 01:08:57.080]  А, ну, это уже
[01:08:57.080 --> 01:08:59.080]  какая-то вещь с метапрограммированием
[01:08:59.080 --> 01:09:01.080]  уже, по сути.
[01:09:01.080 --> 01:09:03.080]  То есть, мы хотим, чтобы нам
[01:09:03.080 --> 01:09:05.080]  на вход какая-то функция приходила.
[01:09:05.080 --> 01:09:07.080]  То есть, тюпл это не изменяет объекты?
[01:09:07.080 --> 01:09:09.080]  Нет, тюпл это такой тип, у которого
[01:09:09.080 --> 01:09:11.080]  фиксирована длина, все такое.
[01:09:11.080 --> 01:09:13.080]  Если вы хотите сделать новый тюпл новой длины,
[01:09:13.080 --> 01:09:15.080]  то вам нужна уже какая-то функция, которая будет принимать
[01:09:15.080 --> 01:09:17.080]  на вход тюплы разных длин
[01:09:17.080 --> 01:09:19.080]  с разными типами и как-то их
[01:09:19.080 --> 01:09:21.080]  между собой суммировать.
[01:09:21.080 --> 01:09:23.080]  А на другие значения
[01:09:23.080 --> 01:09:25.080]  тюпл можно менять?
[01:09:25.080 --> 01:09:27.080]  Так, ну, если вы объявите мутабельный тюпл,
[01:09:27.080 --> 01:09:29.080]  то да.
[01:09:29.080 --> 01:09:31.080]  То есть, вы напишете, например,
[01:09:31.080 --> 01:09:33.080]  тюпл что-то там и можете написать,
[01:09:33.080 --> 01:09:35.080]  например, тюпл 7 равняется что-то там.
[01:09:35.080 --> 01:09:37.080]  А если его при этом
[01:09:37.080 --> 01:09:39.080]  инициировать
[01:09:39.080 --> 01:09:41.080]  не мутабельными значениями?
[01:09:41.080 --> 01:09:43.080]  То есть, есть два не мутабельных
[01:09:43.080 --> 01:09:45.080]  мута?
[01:09:45.080 --> 01:09:47.080]  То есть, как это должно быть?
[01:09:47.080 --> 01:09:49.080]  Как это должно произойти?
[01:09:49.080 --> 01:09:51.080]  Как должно, я не знаю.
[01:09:51.080 --> 01:09:53.080]  Ну, я просто не знаю, как
[01:09:53.080 --> 01:09:55.080]  такой тюпл даже объявить,
[01:09:55.080 --> 01:09:57.080]  чтобы он был не весь мутабельный.
[01:09:57.080 --> 01:09:59.080]  Нет, в смысле, ну, вот завели там
[01:09:59.080 --> 01:10:01.080]  x и y
[01:10:01.080 --> 01:10:03.080]  какими-то значениями,
[01:10:03.080 --> 01:10:05.080]  а потом объявляется
[01:10:05.080 --> 01:10:07.080]  мутабельный тюпл, который
[01:10:07.080 --> 01:10:09.080]  вот конструируется
[01:10:09.080 --> 01:10:11.080]  из этих времен.
[01:10:11.080 --> 01:10:13.080]  Там муфсимантика в расти есть,
[01:10:13.080 --> 01:10:15.080]  по умолчанию. Там будет передача владения,
[01:10:15.080 --> 01:10:17.080]  x и y будут
[01:10:17.080 --> 01:10:19.080]  не
[01:10:19.080 --> 01:10:21.080]  муфнуться, в общем-то, в этот
[01:10:21.080 --> 01:10:23.080]  тюпл. И, соответственно, у нас будет
[01:10:23.080 --> 01:10:25.080]  нормальный мутабельный тюпл.
[01:10:41.080 --> 01:10:43.080]  Так, ну, это
[01:10:43.080 --> 01:10:45.080]  просто для вашей информации.
[01:10:45.080 --> 01:10:47.080]  Посмотрите, я вектор объявляю
[01:10:47.080 --> 01:10:49.080]  два вектора.
[01:10:49.080 --> 01:10:51.080]  Один 0.1.2.3, другой 4.5.6.7.
[01:10:51.080 --> 01:10:53.080]  Как видите, тут шедуинг.
[01:10:53.080 --> 01:10:55.080]  И потом возвращаю нулевой элемент вектора.
[01:10:57.080 --> 01:10:59.080]  Если вы зайдете на Godbolt, то вы можете
[01:10:59.080 --> 01:11:01.080]  обратить внимание то, что, по умолчанию,
[01:11:01.080 --> 01:11:03.080]  без оптимизации у вас
[01:11:03.080 --> 01:11:05.080]  вектор.
[01:11:05.080 --> 01:11:07.080]  Ну, в общем-то, у вас будет
[01:11:07.080 --> 01:11:09.080]  создаваться, честно, два вектора,
[01:11:09.080 --> 01:11:11.080]  потом возвращаться значение второго.
[01:11:11.080 --> 01:11:13.080]  Ну, то есть точно так же, как у вас
[01:11:13.080 --> 01:11:15.080]  написан здесь вот код.
[01:11:15.080 --> 01:11:17.080]  Если вы сделаете оптимизацию, то в таком
[01:11:17.080 --> 01:11:19.080]  случае вы уже увидите то, что вектор у вас
[01:11:19.080 --> 01:11:21.080]  просто возвращает ноль сразу же.
[01:11:21.080 --> 01:11:23.080]  Ну, то есть у вас буквально там rad 0 просто.
[01:11:27.080 --> 01:11:29.080]  А, 4, извините.
[01:11:29.080 --> 01:11:31.080]  Четверка.
[01:11:33.080 --> 01:11:35.080]  Так.
[01:11:35.080 --> 01:11:37.080]  Потом у нас есть...
[01:11:37.080 --> 01:11:39.080]  Ну, это я уже сказал про юнит.
[01:11:39.080 --> 01:11:41.080]  Он выглядит вот так вот. И у него есть еще
[01:11:41.080 --> 01:11:43.080]  другой способ объявления. Это с фигурными
[01:11:43.080 --> 01:11:45.080]  скобочками. Это то же самое.
[01:11:45.080 --> 01:11:47.080]  Это такой малоизвестный, кстати, факт,
[01:11:47.080 --> 01:11:49.080]  что в Rast это одно и то же.
[01:11:49.080 --> 01:11:51.080]  А еще, если вы хотите сделать
[01:11:51.080 --> 01:11:53.080]  tuple из одного элемента, то вам нужно обязательно
[01:11:53.080 --> 01:11:55.080]  написать запятую после первого элемента.
[01:11:55.080 --> 01:11:57.080]  Иначе Rast подумает, что это просто
[01:11:57.080 --> 01:11:59.080]  значение, которое вы нафига-то взяли в
[01:11:59.080 --> 01:12:01.080]  скобочке. Чтобы ему сказать, что это
[01:12:01.080 --> 01:12:03.080]  tuple, нужно запятую явно написать.
[01:12:07.080 --> 01:12:09.080]  Ну, tuple в памяти
[01:12:09.080 --> 01:12:11.080]  это просто структура
[01:12:11.080 --> 01:12:13.080]  из подряд отущих полей.
[01:12:13.080 --> 01:12:15.080]  Ну, то есть, вот, например, у вас семерка
[01:12:15.080 --> 01:12:17.080]  это int какой-то,
[01:12:17.080 --> 01:12:19.080]  где вот так вот в памяти располагается.
[01:12:19.080 --> 01:12:21.080]  А если у вас 7.263
[01:12:21.080 --> 01:12:23.080]  tuple из двух элементов, тогда у вас, честно, будут
[01:12:23.080 --> 01:12:25.080]  два вот таких вот элемента
[01:12:25.080 --> 01:12:27.080]  подряд записаны.
[01:12:31.080 --> 01:12:33.080]  Так. И вообще, tuple это
[01:12:33.080 --> 01:12:35.080]  zero cost abstraction. То есть, вы можете не стесняться
[01:12:35.080 --> 01:12:37.080]  использовать tuple сколько вам
[01:12:37.080 --> 01:12:39.080]  душа угодно. Они не будут влиять на вашу
[01:12:39.080 --> 01:12:41.080]  производительность. Здесь есть такой небольшой
[01:12:41.080 --> 01:12:43.080]  proof. Он использует указатели,
[01:12:43.080 --> 01:12:45.080]  но не вдавайте с подробностей,
[01:12:45.080 --> 01:12:47.080]  я просто скажу вам, что здесь происходит.
[01:12:47.080 --> 01:12:49.080]  Здесь просто берется tuple
[01:12:49.080 --> 01:12:51.080]  и я беру на него указатель.
[01:12:51.080 --> 01:12:53.080]  Как на
[01:12:53.080 --> 01:12:55.080]  i32.
[01:12:55.080 --> 01:12:57.080]  Точнее, на сам tuple
[01:12:57.080 --> 01:12:59.080]  и на нулевой его элемент.
[01:12:59.080 --> 01:13:01.080]  В принципе, это было видно еще из прошлого слайда.
[01:13:01.080 --> 01:13:03.080]  То, что это один тот же
[01:13:03.080 --> 01:13:05.080]  указатель.
[01:13:05.080 --> 01:13:07.080]  В Python вот видно, что если вы сделаете
[01:13:07.080 --> 01:13:09.080]  tuple и элемент tuple, то они имеют
[01:13:09.080 --> 01:13:11.080]  разные ID-шники.
[01:13:11.080 --> 01:13:13.080]  Это даже разные
[01:13:13.080 --> 01:13:15.080]  типы.
[01:13:15.080 --> 01:13:17.080]  И там происходит боксинг, так называемый в Python.
[01:13:17.080 --> 01:13:19.080]  То есть, это не zero cost abstraction.
[01:13:25.080 --> 01:13:27.080]  Да, это просто на уровне системы
[01:13:27.080 --> 01:13:29.080]  типов. То есть, оно существует только для вас
[01:13:29.080 --> 01:13:31.080]  или для компилятора.
[01:13:33.080 --> 01:13:35.080]  Да, это очень близко к массивам,
[01:13:35.080 --> 01:13:37.080]  только здесь разные типы у tuple могут быть.
[01:13:37.080 --> 01:13:39.080]  То есть, каждый элемент может быть разным.
[01:13:39.080 --> 01:13:41.080]  А он всегда копирует?
[01:13:41.080 --> 01:13:43.080]  То есть, tuple равно
[01:13:43.080 --> 01:13:45.080]  что-то не легальное,
[01:13:45.080 --> 01:13:47.080]  а он не скопирует?
[01:13:47.080 --> 01:13:49.080]  Tuple равно. Смотри.
[01:13:49.080 --> 01:13:51.080]  Во-первых, зависит от ситуации,
[01:13:51.080 --> 01:13:53.080]  что ты там делаешь конкретно.
[01:13:53.080 --> 01:13:55.080]  Во-вторых, да.
[01:13:55.080 --> 01:13:57.080]  Вообще, зачастую RAS, если ты берешь значение,
[01:13:57.080 --> 01:13:59.080]  присваивавшую какой-то другопеременный,
[01:13:59.080 --> 01:14:01.080]  там происходит move.
[01:14:01.080 --> 01:14:03.080]  Move в RAS это просто мен копия.
[01:14:03.080 --> 01:14:05.080]  Ну и на уровне
[01:14:05.080 --> 01:14:07.080]  системы типов,
[01:14:07.080 --> 01:14:09.080]  то есть, где компилятор еще живет,
[01:14:09.080 --> 01:14:11.080]  он помещает переменную неинцелизированной.
[01:14:11.080 --> 01:14:13.080]  Ну, мы это увидим
[01:14:13.080 --> 01:14:15.080]  чуть-чуть попозже в лекции. У нас
[01:14:15.080 --> 01:14:17.080]  будет разговор про ужасный borrow-checker,
[01:14:17.080 --> 01:14:19.080]  который будет нам мешать первое время
[01:14:19.080 --> 01:14:21.080]  писать код, а потом помогать.
[01:14:21.080 --> 01:14:23.080]  А вы можете к этим элементам киву через квадратные
[01:14:23.080 --> 01:14:25.080]  скулочки обращать? Нет, только через точку.
[01:14:25.080 --> 01:14:27.080]  А в некоторых наоборот? Да.
[01:14:27.080 --> 01:14:29.080]  В некоторых массивах наоборот.
[01:14:31.080 --> 01:14:33.080]  Здесь, кажется, у меня получилось
[01:14:33.080 --> 01:14:35.080]  2 слайда.
[01:14:41.080 --> 01:14:43.080]  Потом у нас есть всякие массивы.
[01:14:43.080 --> 01:14:45.080]  Я здесь явно прописал
[01:14:45.080 --> 01:14:47.080]  тип массива. Смотрите, у нас
[01:14:47.080 --> 01:14:49.080]  тип массива это U8
[01:14:49.080 --> 01:14:51.080]  и размеры 3.
[01:14:51.080 --> 01:14:53.080]  Я явно написал 1, 2, 3.
[01:14:53.080 --> 01:14:55.080]  Потом у нас есть
[01:14:55.080 --> 01:14:57.080]  собственно,
[01:14:57.080 --> 01:14:59.080]  я им пользуюсь. У нас есть XS,
[01:14:59.080 --> 01:15:01.080]  у которого я проверяю, что первое элемент действительно 1.
[01:15:01.080 --> 01:15:03.080]  А еще у типов точно также есть всякие функции.
[01:15:03.080 --> 01:15:05.080]  Ну, например, land.
[01:15:05.080 --> 01:15:07.080]  Я узнал, что land это 3.
[01:15:07.080 --> 01:15:09.080]  Потом у нас
[01:15:09.080 --> 01:15:11.080]  можно объявлять точно так же работает
[01:15:11.080 --> 01:15:13.080]  вывод типов, только единственное,
[01:15:13.080 --> 01:15:15.080]  если вы так вот делаете
[01:15:15.080 --> 01:15:17.080]  в коде, то тогда, наверное, лучше написать
[01:15:17.080 --> 01:15:19.080]  какой вы тип
[01:15:19.080 --> 01:15:21.080]  первый хотите.
[01:15:21.080 --> 01:15:23.080]  Смотрите, особенность в том, что
[01:15:23.080 --> 01:15:25.080]  первый раз мы когда объявляли справа
[01:15:25.080 --> 01:15:27.080]  в правой части XS, у нас была
[01:15:27.080 --> 01:15:29.080]  1, 2, 3 через запятую, а здесь
[01:15:29.080 --> 01:15:31.080]  мы объявили 1024 0.
[01:15:31.080 --> 01:15:33.080]  То есть мы через точку запятую
[01:15:33.080 --> 01:15:35.080]  написали значение, а потом сколько раз.
[01:15:35.080 --> 01:15:37.080]  Как, например, на векторе
[01:15:37.080 --> 01:15:39.080]  у нас есть один из конструкторов плюса.
[01:15:41.080 --> 01:15:43.080]  А если бы вы написали просто 0,
[01:15:43.080 --> 01:15:45.080]  а не 0 в U8,
[01:15:45.080 --> 01:15:47.080]  тогда бы раз сказал,
[01:15:47.080 --> 01:15:49.080]  зависит от того, конечно,
[01:15:49.080 --> 01:15:51.080]  как пользоваться им.
[01:15:51.080 --> 01:15:53.080]  Вообще раз бы сказал, что я не понимаю, какой здесь тип.
[01:15:55.080 --> 01:15:57.080]  Если мы перешли точку 0, как мне не так,
[01:15:57.080 --> 01:15:59.080]  то с права ставим 1,
[01:15:59.080 --> 01:16:01.080]  и у нас в крайней части 0,0.
[01:16:01.080 --> 01:16:03.080]  А, это нет, это не произойдет так.
[01:16:03.080 --> 01:16:05.080]  Это будет два разных типа.
[01:16:05.080 --> 01:16:07.080]  То есть с левого будет тип U8-10,
[01:16:07.080 --> 01:16:09.080]  а с правого будет U8-3.
[01:16:09.080 --> 01:16:11.080]  Ему это не понравится.
[01:16:11.080 --> 01:16:13.080]  Да.
[01:16:21.080 --> 01:16:23.080]  В плане,
[01:16:23.080 --> 01:16:25.080]  мы убрали полностью эту часть.
[01:16:25.080 --> 01:16:27.080]  Да, точка запятой.
[01:16:29.080 --> 01:16:31.080]  Ну, то есть сразу же после 3 квадратных скобчика
[01:16:31.080 --> 01:16:33.080]  точка запятой.
[01:16:33.080 --> 01:16:35.080]  То есть не инициализировали, просто сказали.
[01:16:35.080 --> 01:16:37.080]  Но если мы попробуем воспользоваться, то раз скажет,
[01:16:37.080 --> 01:16:39.080]  вы пользуетесь не инициализированной переменной.
[01:16:39.080 --> 01:16:41.080]  И не искомпилирует это.
[01:16:43.080 --> 01:16:45.080]  Сейчас вроде не говорилось, мы можем вообще
[01:16:45.080 --> 01:16:47.080]  не инициализировать переменное?
[01:16:47.080 --> 01:16:49.080]  Да, можем не инициализировать переменное.
[01:16:49.080 --> 01:16:51.080]  Там дальше будет еще такой
[01:16:51.080 --> 01:16:53.080]  сладик с дропфлекс забавный.
[01:16:53.080 --> 01:16:55.080]  Примерно.
[01:16:55.080 --> 01:16:57.080]  Ну, то есть это чуть-чуть подальше будет.
[01:16:57.080 --> 01:16:59.080]  Инициализировать переменную можно, но для ее
[01:16:59.080 --> 01:17:01.080]  использования Rast обязательно проверит,
[01:17:01.080 --> 01:17:03.080]  что вы ее потом инициализируете.
[01:17:05.080 --> 01:17:07.080]  Так.
[01:17:07.080 --> 01:17:09.080]  На самом деле есть еще в Rast ссылочки.
[01:17:09.080 --> 01:17:11.080]  Это на самом деле просто
[01:17:11.080 --> 01:17:13.080]  pointer на уровне
[01:17:13.080 --> 01:17:15.080]  рентайма программы.
[01:17:15.080 --> 01:17:17.080]  Он не может быть нулом,
[01:17:17.080 --> 01:17:19.080]  потому что он обязательно
[01:17:19.080 --> 01:17:21.080]  проинциализирован, он указывает на какой-то объект.
[01:17:21.080 --> 01:17:23.080]  Он гарантирует то, что объект жив.
[01:17:23.080 --> 01:17:25.080]  То есть если у вас есть ссылочка,
[01:17:25.080 --> 01:17:27.080]  тогда объект обязательно живой.
[01:17:27.080 --> 01:17:29.080]  Это одна из важных гарантий Rast.
[01:17:29.080 --> 01:17:31.080]  У нас есть
[01:17:31.080 --> 01:17:33.080]  обычная ссылочка и мутабельная
[01:17:33.080 --> 01:17:35.080]  ссылочка. Точнее, не сама ссылочка
[01:17:35.080 --> 01:17:37.080]  мутабельная, а ссылочка на мутабельный элемент.
[01:17:37.080 --> 01:17:39.080]  Вот так вот. В отличие от плюсов,
[01:17:39.080 --> 01:17:41.080]  мы читаем слева-направо,
[01:17:41.080 --> 01:17:43.080]  а не справа-налево, как у нас в случае с указателем.
[01:17:43.080 --> 01:17:45.080]  По-моему, мне кажется, следующее
[01:17:45.080 --> 01:17:47.080]  пример.
[01:17:47.080 --> 01:17:49.080]  Ну, значит, чуть-чуть будет подальше пример
[01:17:49.080 --> 01:17:51.080]  как читать типы такие.
[01:17:53.080 --> 01:17:55.080]  Ну, вот видите, у нас тут есть x,
[01:17:55.080 --> 01:17:57.080]  i32 с значением 98.
[01:17:57.080 --> 01:17:59.080]  Здесь мы создаем
[01:17:59.080 --> 01:18:01.080]  R это какая-то ссылка на мутабельный
[01:18:01.080 --> 01:18:03.080]  i32. То есть вот мы читаем
[01:18:03.080 --> 01:18:05.080]  ссылку на мутабельный i32.
[01:18:05.080 --> 01:18:07.080]  А это как сишный указатель?
[01:18:09.080 --> 01:18:11.080]  Это как сишный указатель.
[01:18:11.080 --> 01:18:13.080]  Но дело в том, что Rast на этапе компиляции
[01:18:13.080 --> 01:18:15.080]  с помощью системы типов своей мощной
[01:18:15.080 --> 01:18:17.080]  проверяет то, что вы правильно пользуетесь.
[01:18:17.080 --> 01:18:19.080]  И не пропускает, если вы пользуетесь неправильно.
[01:18:23.080 --> 01:18:25.080]  Там есть такие. Есть Vox,
[01:18:25.080 --> 01:18:27.080]  есть RC, есть Arc.
[01:18:27.080 --> 01:18:29.080]  С Arc мы пока что не будем
[01:18:29.080 --> 01:18:31.080]  на них смотреть, но на Vox
[01:18:31.080 --> 01:18:33.080]  мы сегодня посмотрим и RC
[01:18:33.080 --> 01:18:35.080]  на следующей лекции.
[01:18:43.080 --> 01:18:45.080]  92. Тут, кстати, наверное,
[01:18:45.080 --> 01:18:47.080]  лучше было написать mute x,
[01:18:47.080 --> 01:18:49.080]  а не
[01:18:49.080 --> 01:18:51.080]  mute 92.
[01:18:55.080 --> 01:18:57.080]  В плане вот это вот мют.
[01:18:57.080 --> 01:18:59.080]  Мы же хотим сказать, что это
[01:18:59.080 --> 01:19:01.080]  будет смутабельная ссылка.
[01:19:01.080 --> 01:19:03.080]  То есть чтобы типы сошлись.
[01:19:05.080 --> 01:19:07.080]  Получается, вот там был пример,
[01:19:07.080 --> 01:19:09.080]  когда мы возвращаем ссылку на
[01:19:09.080 --> 01:19:11.080]  ременную стеки.
[01:19:11.080 --> 01:19:13.080]  То, что мы возвращали,
[01:19:13.080 --> 01:19:15.080]  ты говоришь пример с Vector,
[01:19:15.080 --> 01:19:17.080]  когда мы возвращали ссылку.
[01:19:21.080 --> 01:19:23.080]  Мы не будем подробно
[01:19:23.080 --> 01:19:25.080]  сегодня разговаривать про ссылки,
[01:19:25.080 --> 01:19:27.080]  потому что там чуть-чуть сложная история
[01:19:27.080 --> 01:19:29.080]  с lifetime.
[01:19:29.080 --> 01:19:31.080]  Есть такая штука как lifetime.
[01:19:31.080 --> 01:19:33.080]  Там вкратце будет
[01:19:33.080 --> 01:19:35.080]  обратить внимание, что lifetime
[01:19:35.080 --> 01:19:37.080]  это ссылочки, вот этот вот скоп.
[01:19:37.080 --> 01:19:39.080]  Мы пытаемся дальше запушить.
[01:19:39.080 --> 01:19:41.080]  То есть продлевать ссылки
[01:19:41.080 --> 01:19:43.080]  нельзя просто, потому что
[01:19:43.080 --> 01:19:45.080]  они не длеваются?
[01:19:45.080 --> 01:19:47.080]  Ну да, их продлеть не получится.
[01:19:49.080 --> 01:19:51.080]  Так, и смотрите,
[01:19:51.080 --> 01:19:53.080]  у нас в плюсах
[01:19:53.080 --> 01:19:55.080]  ссылочки это не first class object,
[01:19:55.080 --> 01:19:57.080]  как говорится.
[01:19:57.080 --> 01:19:59.080]  Ну, в общем-то, если захотим
[01:19:59.080 --> 01:20:01.080]  запушить на Vector, то нам придется
[01:20:01.080 --> 01:20:03.080]  сделать примерно так. У нас есть
[01:20:03.080 --> 01:20:05.080]  reference writer, который из себя представляет
[01:20:05.080 --> 01:20:07.080]  ссылку в какой-то элемент. Ну, такая умная
[01:20:07.080 --> 01:20:09.080]  то же самое, что имперсандик обычный,
[01:20:09.080 --> 01:20:11.080]  но умнее.
[01:20:11.080 --> 01:20:13.080]  А в Rastia можете
[01:20:13.080 --> 01:20:15.080]  спокойно сделать Vector, как вы видите,
[01:20:15.080 --> 01:20:17.080]  и запушить в него просто X,
[01:20:17.080 --> 01:20:19.080]  ссылку на X, и тогда тип Vector
[01:20:19.080 --> 01:20:21.080]  будет VECO от ссылки
[01:20:21.080 --> 01:20:23.080]  на I32. И это легально.
[01:20:27.080 --> 01:20:29.080]  Правда, тогда Rast
[01:20:29.080 --> 01:20:31.080]  естественно должен дать гарантии safety
[01:20:31.080 --> 01:20:33.080]  и будет проверять, что у вас
[01:20:33.080 --> 01:20:35.080]  действительно ссылки эти живут не меньше,
[01:20:35.080 --> 01:20:37.080]  чем Vector.
[01:20:37.080 --> 01:20:39.080]  Но об этом будем говорить чуть попозже.
[01:20:41.080 --> 01:20:43.080]  Вот, кстати, как раз пример про то, как
[01:20:43.080 --> 01:20:45.080]  все это делать, читать.
[01:20:45.080 --> 01:20:47.080]  Указатели у нас еще есть в Rastia.
[01:20:47.080 --> 01:20:49.080]  Они бесполезны
[01:20:49.080 --> 01:20:51.080]  без unsafe, потому что мы их не можем
[01:20:51.080 --> 01:20:53.080]  разыменовывать. То есть вы можете
[01:20:53.080 --> 01:20:55.080]  их суммировать, умножать, что хотите
[01:20:55.080 --> 01:20:57.080]  делать, но если вы захотите по ним пройти
[01:20:57.080 --> 01:20:59.080]  куда-нибудь на память, то в таком
[01:20:59.080 --> 01:21:01.080]  случае вам нужно будет
[01:21:01.080 --> 01:21:03.080]  воспользоваться unsafe. И Rastia
[01:21:03.080 --> 01:21:05.080]  не скажет, ну в общем-то вы сами себя
[01:21:05.080 --> 01:21:07.080]  малейшего сборотина, если вы
[01:21:07.080 --> 01:21:09.080]  прошли куда-то, где память не
[01:21:09.080 --> 01:21:11.080]  нациализирована, не ваша, или что-нибудь такое.
[01:21:11.080 --> 01:21:13.080]  Они могут быть нулами,
[01:21:13.080 --> 01:21:15.080]  ну как можно увидеть, в принципе, на слайде
[01:21:15.080 --> 01:21:17.080]  у нас есть примеры.
[01:21:17.080 --> 01:21:19.080]  То есть в целом указатели не редко ходят?
[01:21:19.080 --> 01:21:21.080]  Да, они
[01:21:21.080 --> 01:21:23.080]  ну, конечно, зависит от того, что вы
[01:21:23.080 --> 01:21:25.080]  конкретно пишете, но вообще очень редко.
[01:21:25.080 --> 01:21:27.080]  Чем более вниз спускаетесь,
[01:21:27.080 --> 01:21:29.080]  тем чаще вам нужно будет unsafe,
[01:21:29.080 --> 01:21:31.080]  но чаще всего он не нужен вообще.
[01:21:31.080 --> 01:21:33.080]  И в частности
[01:21:33.080 --> 01:21:35.080]  у нас примерно в 10 или 11
[01:21:35.080 --> 01:21:37.080]  домашних вообще не будет никакого
[01:21:37.080 --> 01:21:39.080]  unsafe.
[01:21:39.080 --> 01:21:41.080]  Даже будет forbidden, то есть если вы будете писать
[01:21:41.080 --> 01:21:43.080]  слово unsafe, то в таком случае UCI
[01:21:43.080 --> 01:21:45.080]  будет рубить вам код.
[01:21:45.080 --> 01:21:47.080]  Так.
[01:21:47.080 --> 01:21:49.080]  Дальше.
[01:21:49.080 --> 01:21:51.080]  Ну вот смотрите, как это все дело читать.
[01:21:51.080 --> 01:21:53.080]  У нас
[01:21:53.080 --> 01:21:55.080]  в плюсах как читалось? У нас
[01:21:55.080 --> 01:21:57.080]  есть константный указатель
[01:21:57.080 --> 01:21:59.080]  на константный win32t.
[01:21:59.080 --> 01:22:01.080]  А в разности мы будем читать
[01:22:01.080 --> 01:22:03.080]  слева-направо.
[01:22:03.080 --> 01:22:05.080]  То есть у нас не мутабельный,
[01:22:05.080 --> 01:22:07.080]  мют нет, указатель на константный
[01:22:07.080 --> 01:22:09.080]  i32.
[01:22:09.080 --> 01:22:11.080]  Ну то есть не вот это вот арабская магия,
[01:22:11.080 --> 01:22:13.080]  что мы справа-налево читаем, а слева-направо.
[01:22:13.080 --> 01:22:15.080]  А что сейчас?
[01:22:17.080 --> 01:22:19.080]  Ну да.
[01:22:19.080 --> 01:22:21.080]  Ну да.
[01:22:27.080 --> 01:22:29.080]  Да, можно сделать массив массив,
[01:22:29.080 --> 01:22:31.080]  вектор векторов, там чего хочешь.
[01:22:31.080 --> 01:22:33.080]  То есть там
[01:22:33.080 --> 01:22:35.080]  тип просто будет,
[01:22:35.080 --> 01:22:37.080]  внутри тип элемента будет другой
[01:22:37.080 --> 01:22:39.080]  массив.
[01:22:39.080 --> 01:22:41.080]  Так.
[01:22:41.080 --> 01:22:43.080]  Ну кажется
[01:22:43.080 --> 01:22:45.080]  с этим все понятно, да?
[01:22:45.080 --> 01:22:47.080]  С этим слайдом. Нам не особо стоит сейчас
[01:22:47.080 --> 01:22:49.080]  на нем затерживаться, потому что unsafe нам не особо нужен.
[01:22:49.080 --> 01:22:51.080]  И указатель у нас
[01:22:51.080 --> 01:22:53.080]  не будет.
[01:22:53.080 --> 01:22:55.080]  Так.
[01:22:59.080 --> 01:23:01.080]  Ну да.
[01:23:01.080 --> 01:23:03.080]  Это правда.
[01:23:03.080 --> 01:23:05.080]  Так.
[01:23:05.080 --> 01:23:07.080]  У нас в сети будет домашечка,
[01:23:07.080 --> 01:23:09.080]  в которой ему нужно будет написать bst,
[01:23:09.080 --> 01:23:11.080]  причем написать bst без
[01:23:11.080 --> 01:23:13.080]  unsafe.
[01:23:13.080 --> 01:23:15.080]  Ну то есть это будет прикольная штука.
[01:23:15.080 --> 01:23:17.080]  А bst это кто?
[01:23:17.080 --> 01:23:19.080]  BAN research 3, ну то есть какое-нибудь
[01:23:19.080 --> 01:23:21.080]  овейль дерева напишем.
[01:23:21.080 --> 01:23:23.080]  Потому что это на самом деле на расте очень-очень
[01:23:23.080 --> 01:23:25.080]  больно, но это полезно.
[01:23:25.080 --> 01:23:27.080]  Потому что один раз напишете и после этого станете
[01:23:27.080 --> 01:23:29.080]  гуру овнэшипа,
[01:23:29.080 --> 01:23:31.080]  который мы сейчас разберем.
[01:23:31.080 --> 01:23:33.080]  А сколько у нас сегодня домашек будет?
[01:23:33.080 --> 01:23:35.080]  Домашек будет 13, но это далеко не первая домашка.
[01:23:35.080 --> 01:23:37.080]  Не далеко не первая,
[01:23:37.080 --> 01:23:39.080]  она в первой половине, но в конце первой половины.
[01:23:39.080 --> 01:23:41.080]  Перед убийством.
[01:23:41.080 --> 01:23:43.080]  Да, в шаде
[01:23:43.080 --> 01:23:45.080]  тоже такое было.
[01:23:45.080 --> 01:23:47.080]  Там была задачка на bst, причем даже проще.
[01:23:47.080 --> 01:23:49.080]  Там нужно было написать наивное bst,
[01:23:49.080 --> 01:23:51.080]  и тем не менее у людей очень
[01:23:51.080 --> 01:23:53.080]  много плакали в чате,
[01:23:53.080 --> 01:23:55.080]  что сложная задачка.
[01:23:59.080 --> 01:24:01.080]  Так, так, так.
[01:24:01.080 --> 01:24:03.080]  Ну в общем-то у нас есть BOX.
[01:24:03.080 --> 01:24:05.080]  BOX это штука, которая алоцирует память.
[01:24:05.080 --> 01:24:07.080]  Она работает
[01:24:07.080 --> 01:24:09.080]  примерно точно так же, как
[01:24:09.080 --> 01:24:11.080]  Unique Pointer,
[01:24:11.080 --> 01:24:13.080]  только она не может быть null.
[01:24:15.080 --> 01:24:17.080]  Вот конкретно мы здесь объявляем
[01:24:17.080 --> 01:24:19.080]  BOX типа E32,
[01:24:19.080 --> 01:24:21.080]  то есть соответственно алоцируем 92
[01:24:21.080 --> 01:24:23.080]  где-то на куче и возвращаем указатель.
[01:24:23.080 --> 01:24:25.080]  Ну это умный такой указатель.
[01:24:25.080 --> 01:24:27.080]  Объект целый.
[01:24:29.080 --> 01:24:31.080]  Так, ну давайте
[01:24:31.080 --> 01:24:33.080]  пообъявляем всякие функции.
[01:24:33.080 --> 01:24:35.080]  Ну есть самая дефолтная функция,
[01:24:35.080 --> 01:24:37.080]  которая просто пустая,
[01:24:37.080 --> 01:24:39.080]  то есть она ничего не возвращает,
[01:24:39.080 --> 01:24:41.080]  она ничего не делает.
[01:24:41.080 --> 01:24:43.080]  И как вы можете обратить внимание,
[01:24:43.080 --> 01:24:45.080]  как я вам говорил, у нас
[01:24:45.080 --> 01:24:47.080]  ничего не возвращать, это аналог,
[01:24:47.080 --> 01:24:49.080]  возвращать unit, точнее.
[01:24:49.080 --> 01:24:51.080]  То есть объявление функции 1, функции 2
[01:24:51.080 --> 01:24:53.080]  абсолютно эквивалентны.
[01:24:53.080 --> 01:24:55.080]  Это одинаковая функция.
[01:24:55.080 --> 01:24:57.080]  Потом чтобы вернуть E32,
[01:24:57.080 --> 01:24:59.080]  ну вот мы пишем такую
[01:24:59.080 --> 01:25:01.080]  стрелочку, да,
[01:25:01.080 --> 01:25:03.080]  и пишем тип возвращаемого значения.
[01:25:05.080 --> 01:25:07.080]  Да, можно просто без return,
[01:25:07.080 --> 01:25:09.080]  но у нас есть такое понятие как
[01:25:09.080 --> 01:25:11.080]  expressions and statements в расте.
[01:25:11.080 --> 01:25:13.080]  Expressions это выражение,
[01:25:13.080 --> 01:25:15.080]  то есть это какое-то значение, например.
[01:25:15.080 --> 01:25:17.080]  Сейчас мы, ну там кажется
[01:25:17.080 --> 01:25:19.080]  чуть дальше будет, да?
[01:25:19.080 --> 01:25:21.080]  Да, там будет.
[01:25:21.080 --> 01:25:23.080]  Мы обсудим это. Здесь мы просто
[01:25:23.080 --> 01:25:25.080]  возвращаем 0 без return. В следующей строчке
[01:25:25.080 --> 01:25:27.080]  мы возвращаем x, ну можем написать
[01:25:27.080 --> 01:25:29.080]  return тоже самое.
[01:25:29.080 --> 01:25:31.080]  Принимаем на вход x и возвращаем
[01:25:31.080 --> 01:25:33.080]  x.
[01:25:33.080 --> 01:25:35.080]  Потом у нас какая-то другая
[01:25:35.080 --> 01:25:37.080]  есть функция, в которой мы принимаем уже
[01:25:37.080 --> 01:25:39.080]  два значения через запятую.
[01:25:39.080 --> 01:25:41.080]  Обратите внимание, что mute у
[01:25:41.080 --> 01:25:43.080]  у нас, то есть это мутабельная переменная,
[01:25:43.080 --> 01:25:45.080]  которую можно обменять функцией.
[01:25:45.080 --> 01:25:47.080]  Например, x, если бы я точно так же x
[01:25:47.080 --> 01:25:49.080]  что-то присвоил, то Rast бы сказал, что
[01:25:49.080 --> 01:25:51.080]  переменные не мутабельные нельзя.
[01:25:51.080 --> 01:25:53.080]  Честно при этом,
[01:25:55.080 --> 01:25:57.080]  ну то, кто передал y,
[01:25:57.080 --> 01:25:59.080]  не заметит это.
[01:25:59.080 --> 01:26:01.080]  Ну,
[01:26:01.080 --> 01:26:03.080]  у нас, кстати, в Rast все с этим
[01:26:03.080 --> 01:26:05.080]  делом прекрасно, то есть
[01:26:05.080 --> 01:26:07.080]  конкретно U64 это такой
[01:26:07.080 --> 01:26:09.080]  тип, который копируем, то есть если вы
[01:26:09.080 --> 01:26:11.080]  передаете U64,
[01:26:11.080 --> 01:26:13.080]  то он просто скопируется функцией.
[01:26:13.080 --> 01:26:15.080]  Естественно, этот человек не заметит
[01:26:15.080 --> 01:26:17.080]  этого.
[01:26:17.080 --> 01:26:19.080]  А если кто-то
[01:26:19.080 --> 01:26:21.080]  с более сложной какой-то структурой
[01:26:21.080 --> 01:26:23.080]  придет, ну то есть с более сложной объявления,
[01:26:23.080 --> 01:26:25.080]  то у нас там есть понятие
[01:26:25.080 --> 01:26:27.080]  ссылки, то есть мы будем принимать по ссылке точно
[01:26:27.080 --> 01:26:29.080]  так же, по мутабельной ссылке
[01:26:29.080 --> 01:26:31.080]  и по значению.
[01:26:31.080 --> 01:26:33.080]  А если
[01:26:33.080 --> 01:26:35.080]  U64 меньше?
[01:26:35.080 --> 01:26:37.080]  Ну, то же самое
[01:26:37.080 --> 01:26:39.080]  будет копироваться, U128
[01:26:39.080 --> 01:26:41.080]  будет копироваться.
[01:26:41.080 --> 01:26:43.080]  Там зависит от того, имплеметировать
[01:26:43.080 --> 01:26:45.080]  ли тип трейты, клоуны,
[01:26:45.080 --> 01:26:47.080]  копии, мы чуть-чуть попозже про них поговорим.
[01:26:47.080 --> 01:26:49.080]  Пока что у вас все прекрасно, у вас простая
[01:26:49.080 --> 01:26:51.080]  домашка будет, на этот раз у вас все будет копироваться.
[01:26:51.080 --> 01:26:53.080]  То есть вы
[01:26:53.080 --> 01:26:55.080]  не заметите разницу с плюсами.
[01:26:55.080 --> 01:26:57.080]  А потом уже будет
[01:26:57.080 --> 01:26:59.080]  ну, будете натыкаться на всяких приколах.
[01:26:59.080 --> 01:27:01.080]  А вот когда вам передает функция
[01:27:01.080 --> 01:27:03.080]  объект надCMove, что он
[01:27:03.080 --> 01:27:05.080]  по ссылке передавался?
[01:27:05.080 --> 01:27:07.080]  Не, для того, чтобы
[01:27:07.080 --> 01:27:09.080]  если вы хотите передать по ссылке,
[01:27:09.080 --> 01:27:11.080]  то нам нужно быть явно, например, написать
[01:27:11.080 --> 01:27:13.080]  вызывая функцию, там нужно будет написать
[01:27:13.080 --> 01:27:15.080]  например фанк3 и там нужно будет
[01:27:15.080 --> 01:27:17.080]  фанк4
[01:27:17.080 --> 01:27:19.080]  А там нужно будет явно написать &x
[01:27:19.080 --> 01:27:21.080]  если бы это было по ссылке. То есть мы будем
[01:27:21.080 --> 01:27:23.080]  прям видеть, вызывая функцию,
[01:27:23.080 --> 01:27:25.080]  что вот мы ее по ссылке передали.
[01:27:25.080 --> 01:27:27.080]  Это значение.
[01:27:27.080 --> 01:27:29.080]  как вернуть?
[01:27:29.080 --> 01:27:31.080]  унит вернуть?
[01:27:31.080 --> 01:27:33.080]  ну можно вот например вот здесь
[01:27:33.080 --> 01:27:35.080]  если бы здесь был унит
[01:27:35.080 --> 01:27:37.080]  тогда можно было здесь тоже скобочки просто написать
[01:27:37.080 --> 01:27:39.080]  или return скобочки
[01:27:39.080 --> 01:27:41.080]  то есть точно такое же значение
[01:27:41.080 --> 01:27:43.080]  да, это просто объявление
[01:27:43.080 --> 01:27:45.080]  по сути
[01:27:45.080 --> 01:27:47.080]  пустой структуры
[01:27:47.080 --> 01:27:49.080]  ничего не вернуть
[01:27:49.080 --> 01:27:51.080]  ничего не вернуть нельзя
[01:27:51.080 --> 01:27:53.080]  в расе всегда возвращается унит
[01:27:53.080 --> 01:27:55.080]  вы этого даже не замечаете
[01:27:55.080 --> 01:27:57.080]  в случае первой функции
[01:27:57.080 --> 01:27:59.080]  унит вы не видите, а он есть
[01:27:59.080 --> 01:28:01.080]  что с точки запятой здесь?
[01:28:01.080 --> 01:28:03.080]  что с точки запятой здесь?
[01:28:03.080 --> 01:28:05.080]  это хороший вопрос
[01:28:05.080 --> 01:28:07.080]  вот здесь вот
[01:28:07.080 --> 01:28:09.080]  expression sustainments
[01:28:09.080 --> 01:28:11.080]  это вот сейчас со следующего слайда
[01:28:11.080 --> 01:28:13.080]  вот return вот конкретно вот здесь вот здесь
[01:28:13.080 --> 01:28:15.080]  это на самом деле правильно
[01:28:15.080 --> 01:28:17.080]  вы в расе можете и то и то сделать
[01:28:17.080 --> 01:28:19.080]  он разрешает
[01:28:19.080 --> 01:28:21.080]  именно в return в смысле?
[01:28:21.080 --> 01:28:23.080]  да, да, да
[01:28:23.080 --> 01:28:25.080]  если вы здесь что-то не напишете
[01:28:25.080 --> 01:28:27.080]  то он на вас пожалуется
[01:28:29.080 --> 01:28:31.080]  давайте теперь
[01:28:31.080 --> 01:28:33.080]  поймем, что такое expression sustainments
[01:28:33.080 --> 01:28:35.080]  дело в том, что у нас в расе
[01:28:35.080 --> 01:28:37.080]  всякая строчка является
[01:28:37.080 --> 01:28:39.080]  значением, каким-то выражением
[01:28:39.080 --> 01:28:41.080]  например какая-то функция, которая даже
[01:28:41.080 --> 01:28:43.080]  ничего не возвращает, это на самом деле
[01:28:43.080 --> 01:28:45.080]  штука, которая возвращает кругло скобочки
[01:28:45.080 --> 01:28:47.080]  даже ив, по умолчанию, возвращает
[01:28:47.080 --> 01:28:49.080]  что-то из своего скопа
[01:28:49.080 --> 01:28:51.080]  если вы напишете точку
[01:28:51.080 --> 01:28:53.080]  запятой в самом конце, то это будет означать
[01:28:53.080 --> 01:28:55.080]  что он возвращает значение вот этой строчки
[01:28:55.080 --> 01:28:57.080]  вот, например, конкретно в данном случае
[01:28:57.080 --> 01:28:59.080]  у икса будет значение
[01:28:59.080 --> 01:29:01.080]  y плюс 534
[01:29:01.080 --> 01:29:03.080]  сейчас, а тогда
[01:29:03.080 --> 01:29:05.080]  если вот функция
[01:29:05.080 --> 01:29:07.080]  мы не написали return
[01:29:07.080 --> 01:29:09.080]  но возвращаем значение и поставим точку запятой
[01:29:09.080 --> 01:29:11.080]  в профильку
[01:29:11.080 --> 01:29:13.080]  по масштабу предыдущий слайд
[01:29:13.080 --> 01:29:15.080]  вот func
[01:29:15.080 --> 01:29:17.080]  6
[01:29:17.080 --> 01:29:19.080]  если мы поставим точку запятой в конце
[01:29:19.080 --> 01:29:21.080]  тогда функция начнет возвращать
[01:29:21.080 --> 01:29:23.080]  унит
[01:29:23.080 --> 01:29:25.080]  потому что точка запятой означает, что вот эта фигня
[01:29:25.080 --> 01:29:27.080]  стала унитом
[01:29:27.080 --> 01:29:29.080]  то есть это стала стейк
[01:29:29.080 --> 01:29:31.080]  то есть у нас случится ошибка из того, что мы написали
[01:29:31.080 --> 01:29:33.080]  что мы возвращаем u32
[01:29:33.080 --> 01:29:35.080]  да, он скажет mismatch types
[01:29:35.080 --> 01:29:37.080]  типа у нас ожидался u32
[01:29:37.080 --> 01:29:39.080]  вернулся унит
[01:29:43.080 --> 01:29:45.080]  так
[01:29:45.080 --> 01:29:47.080]  кажется, на этот слайд мы посмотрели
[01:29:47.080 --> 01:29:49.080]  очень прекрасную офичату
[01:29:49.080 --> 01:29:51.080]  что можно написать vx, сравняется if
[01:29:51.080 --> 01:29:53.080]  и там
[01:29:53.080 --> 01:29:55.080]  по выбору слева или справа
[01:29:55.080 --> 01:29:57.080]  какое-то значение
[01:29:57.080 --> 01:29:59.080]  1 или 2
[01:29:59.080 --> 01:30:01.080]  нет, y плюс 534
[01:30:01.080 --> 01:30:03.080]  у меньше 42 не правда
[01:30:03.080 --> 01:30:05.080]  соответственно, мы пойдем в вторую ветку
[01:30:05.080 --> 01:30:07.080]  и иксу будет присваиваться значение y плюс 534
[01:30:07.080 --> 01:30:09.080]  а если одна из частей
[01:30:09.080 --> 01:30:11.080]  не expression, то он ошибку выдаст?
[01:30:11.080 --> 01:30:13.080]  что еще?
[01:30:13.080 --> 01:30:15.080]  если одна из частей не expression, то он ошибку выдаст?
[01:30:15.080 --> 01:30:17.080]  например, если ты напишешь точку запятой
[01:30:17.080 --> 01:30:19.080]  то он скажет, вот здесь
[01:30:19.080 --> 01:30:21.080]  возвращаешь u32, вот здесь возвращаешь unit
[01:30:21.080 --> 01:30:23.080]  что-то не то
[01:30:23.080 --> 01:30:25.080]  то есть так нельзя
[01:30:25.080 --> 01:30:27.080]  да, то есть вам важно то, что
[01:30:27.080 --> 01:30:29.080]  у вас в скопе
[01:30:29.080 --> 01:30:31.080]  фигуристых скопков
[01:30:31.080 --> 01:30:33.080]  я думаю, что x обязательно в этом итоге
[01:30:33.080 --> 01:30:35.080]  должен получиться
[01:30:35.080 --> 01:30:37.080]  одного и того же типа, вне зависимости
[01:30:37.080 --> 01:30:39.080]  того, куда мы пойдем
[01:30:39.080 --> 01:30:41.080]  он должен иметь конкретный тип
[01:30:41.080 --> 01:30:43.080]  можно
[01:30:43.080 --> 01:30:45.080]  в этом ифе, кстати, можно сверху
[01:30:45.080 --> 01:30:47.080]  произвольную логику, например, написать
[01:30:47.080 --> 01:30:49.080]  то есть, что хотите
[01:30:49.080 --> 01:30:51.080]  хоть в BD обращайтесь за этим иксом
[01:30:51.080 --> 01:30:53.080]  а if в ифе?
[01:30:53.080 --> 01:30:55.080]  да, это тоже можно
[01:30:55.080 --> 01:30:57.080]  главное, чтобы у вас возвращалось значение
[01:30:57.080 --> 01:30:59.080]  нужное
[01:30:59.080 --> 01:31:01.080]  то есть, вот если вместо
[01:31:01.080 --> 01:31:03.080]  345 напишем if
[01:31:03.080 --> 01:31:05.080]  то он автоматически
[01:31:05.080 --> 01:31:07.080]  у него будет значение
[01:31:07.080 --> 01:31:09.080]  то есть, вот если вместо
[01:31:09.080 --> 01:31:11.080]  345 напишем if
[01:31:11.080 --> 01:31:13.080]  то он автоматически
[01:31:13.080 --> 01:31:15.080]  да, если вы напишете
[01:31:15.080 --> 01:31:17.080]  if true, return 1
[01:31:17.080 --> 01:31:19.080]  else 2, то в таком случае
[01:31:19.080 --> 01:31:21.080]  у вас там вернется единичка
[01:31:21.080 --> 01:31:23.080]  из этого ифа, и соответственно
[01:31:23.080 --> 01:31:25.080]  из этого всего скопа вернется тоже единичка
[01:31:27.080 --> 01:31:29.080]  а вот чтобы иметь значение
[01:31:29.080 --> 01:31:31.080]  я могу по одному строчку
[01:31:31.080 --> 01:31:33.080]  да, можно написать в одну строчку
[01:31:33.080 --> 01:31:35.080]  но при этом
[01:31:35.080 --> 01:31:37.080]  без скопок нельзя
[01:31:37.080 --> 01:31:39.080]  да, фигурные скопочки обязательно
[01:31:41.080 --> 01:31:43.080]  так
[01:31:43.080 --> 01:31:45.080]  мы дошли до того, что теперь нам нужно объявлять структурки
[01:31:45.080 --> 01:31:47.080]  что-то более сложное
[01:31:47.080 --> 01:31:49.080]  есть какая-то
[01:31:49.080 --> 01:31:51.080]  такая примерная структурка у нас
[01:31:51.080 --> 01:31:53.080]  у которой есть два поля
[01:31:53.080 --> 01:31:55.080]  operCount, которая у size и date
[01:31:55.080 --> 01:31:57.080]  которая i32
[01:31:57.080 --> 01:31:59.080]  опять же, обратите внимание на то, что я здесь тоже написал запятую
[01:32:01.080 --> 01:32:03.080]  вот, то есть, это запятая
[01:32:03.080 --> 01:32:05.080]  ее можете не писать, а можете писать
[01:32:05.080 --> 01:32:07.080]  по желанию, раз вам разрешают делать так и так
[01:32:07.080 --> 01:32:09.080]  ну, чаще всего удобно
[01:32:11.080 --> 01:32:13.080]  и очень-очень важно
[01:32:13.080 --> 01:32:15.080]  вы не можете рассчитывать
[01:32:15.080 --> 01:32:17.080]  на то, как у вас Rust в памяти
[01:32:17.080 --> 01:32:19.080]  типы расположен
[01:32:19.080 --> 01:32:21.080]  даже вот такой банальный пример
[01:32:21.080 --> 01:32:23.080]  у вас есть структура A, где X это экземпл
[01:32:23.080 --> 01:32:25.080]  и структура B, где Y это экземпл
[01:32:25.080 --> 01:32:27.080]  и дело в том, что Rust вам не гарантирует
[01:32:27.080 --> 01:32:29.080]  то, что в памяти эти два типа будут
[01:32:29.080 --> 01:32:31.080]  одинаково располагаться
[01:32:31.080 --> 01:32:33.080]  то есть, там могут произвольно быть перемешанные
[01:32:33.080 --> 01:32:35.080]  поля и что угодно
[01:32:35.080 --> 01:32:37.080]  и даже более того, тут если я напишу
[01:32:37.080 --> 01:32:39.080]  X тоже, то есть даже названия совпадут
[01:32:39.080 --> 01:32:41.080]  все равно Rust
[01:32:41.080 --> 01:32:43.080]  по барабану будет оптимизировать так
[01:32:43.080 --> 01:32:45.080]  ему больше нравится
[01:32:45.080 --> 01:32:47.080]  это на самом деле то, что мы даем меньше
[01:32:47.080 --> 01:32:49.080]  гарантий
[01:32:49.080 --> 01:32:51.080]  оно нам позволяет больше оптимизировать
[01:32:51.080 --> 01:32:53.080]  кода. Соответственно, Rust
[01:32:53.080 --> 01:32:55.080]  потенциально гораздо быстрее, чем plus
[01:32:55.080 --> 01:32:57.080]  например
[01:32:57.080 --> 01:32:59.080]  все же тоже не гарантирует
[01:33:11.080 --> 01:33:13.080]  да, можно сейчас посмотрим
[01:33:21.080 --> 01:33:23.080]  тут
[01:33:23.080 --> 01:33:25.080]  такой прекрасный вопрос про скорость Rust
[01:33:25.080 --> 01:33:27.080]  Rust
[01:33:27.080 --> 01:33:29.080]  на практике оказывается
[01:33:29.080 --> 01:33:31.080]  чуть-чуть медленнее, чем plus
[01:33:31.080 --> 01:33:33.080]  обычно, но это
[01:33:33.080 --> 01:33:35.080]  мне кажется все равно временно, потому что
[01:33:35.080 --> 01:33:37.080]  Rust за счет своих сильных гарантий
[01:33:37.080 --> 01:33:39.080]  позволяет оптимизировать гораздо сильнее
[01:33:39.080 --> 01:33:41.080]  например, на окосе вы могли слышать
[01:33:41.080 --> 01:33:43.080]  про такое понятие, как aliasing
[01:33:43.080 --> 01:33:45.080]  и вот эти все ссылки
[01:33:45.080 --> 01:33:47.080]  которые мы только что рассмотрели, они одновременно
[01:33:47.080 --> 01:33:49.080]  дают гарантию, что у вас
[01:33:49.080 --> 01:33:51.080]  будет сколько-либо немутабельных ссылок
[01:33:51.080 --> 01:33:53.080]  либо одна мутабельная
[01:33:53.080 --> 01:33:55.080]  если вам дали две мутабельные ссылки
[01:33:55.080 --> 01:33:57.080]  то в таком случае вы
[01:33:57.080 --> 01:33:59.080]  можете быть уверены в том, что они указывают
[01:33:59.080 --> 01:34:01.080]  на два разных объекта
[01:34:01.080 --> 01:34:03.080]  и соответственно вы можете
[01:34:03.080 --> 01:34:05.080]  оптимизировать соответствующий код
[01:34:05.080 --> 01:34:07.080]  напомните, пожалуйста
[01:34:07.080 --> 01:34:09.080]  я забыл как там это называется
[01:34:09.080 --> 01:34:11.080]  когда указатель
[01:34:11.080 --> 01:34:13.080]  гарантирует то, что он ни с кем не пересекается
[01:34:15.080 --> 01:34:17.080]  еще раз скажи
[01:34:17.080 --> 01:34:19.080]  да, restrict
[01:34:19.080 --> 01:34:21.080]  по сути Rust в свое время
[01:34:21.080 --> 01:34:23.080]  я даже включил эту фигню
[01:34:23.080 --> 01:34:25.080]  когда он начал во все указатели
[01:34:25.080 --> 01:34:27.080]  фигачить restrict в LVM
[01:34:27.080 --> 01:34:29.080]  и за счет этого
[01:34:29.080 --> 01:34:31.080]  код
[01:34:31.080 --> 01:34:33.080]  конечно стал быстрее, но дело в том, что выплыл
[01:34:33.080 --> 01:34:35.080]  еще одновременно огромная куча багов
[01:34:35.080 --> 01:34:37.080]  в LVM
[01:34:37.080 --> 01:34:39.080]  и пришлось это
[01:34:39.080 --> 01:34:41.080]  то отключать, то включать
[01:34:41.080 --> 01:34:43.080]  то есть они говорят пофиксили в LVM
[01:34:43.080 --> 01:34:45.080]  отключают Rust, опять находятся новые ошибки
[01:34:45.080 --> 01:34:47.080]  отключают
[01:34:47.080 --> 01:34:49.080]  просто
[01:34:49.080 --> 01:34:51.080]  потому что на самом деле все
[01:34:51.080 --> 01:34:53.080]  такие вещи
[01:34:53.080 --> 01:34:55.080]  не включаются и соответственно
[01:34:55.080 --> 01:34:57.080]  они
[01:34:57.080 --> 01:34:59.080]  плохо протестированы
[01:35:05.080 --> 01:35:07.080]  я кстати думаю, что
[01:35:07.080 --> 01:35:09.080]  я думаю сейчас
[01:35:09.080 --> 01:35:11.080]  дойдем до Borrow Checker и наверное
[01:35:11.080 --> 01:35:13.080]  отдохнем чуть-чуть
[01:35:13.080 --> 01:35:15.080]  но это быстро
[01:35:15.080 --> 01:35:17.080]  есть семинар
[01:35:17.080 --> 01:35:19.080]  типа две лекции
[01:35:25.080 --> 01:35:27.080]  по приколу можно взять
[01:35:31.080 --> 01:35:33.080]  давайте добавим некоторые методы
[01:35:33.080 --> 01:35:35.080]  как раз был вопрос про то
[01:35:35.080 --> 01:35:37.080]  можно ли добавлять методы
[01:35:37.080 --> 01:35:39.080]  для этого есть ключевое слово impo
[01:35:39.080 --> 01:35:41.080]  implementation
[01:35:41.080 --> 01:35:43.080]  давайте имплементируем экзампл
[01:35:43.080 --> 01:35:45.080]  давайте добавим функцию new
[01:35:45.080 --> 01:35:47.080]  которая является конструктором
[01:35:47.080 --> 01:35:49.080]  она является ассоциированной
[01:35:49.080 --> 01:35:51.080]  мы сейчас увидим, как ассоциированная функция работает
[01:35:51.080 --> 01:35:53.080]  ну плюсов если что это статик функции
[01:35:53.080 --> 01:35:55.080]  статик функции
[01:35:57.080 --> 01:35:59.080]  плюс ко всему
[01:35:59.080 --> 01:36:01.080]  то, что я назвал ее new
[01:36:01.080 --> 01:36:03.080]  это очень широко распространенное
[01:36:03.080 --> 01:36:05.080]  соглашение в Rust
[01:36:05.080 --> 01:36:07.080]  то, что у вас конструктор
[01:36:07.080 --> 01:36:09.080]  самый обычный, дефолтный
[01:36:09.080 --> 01:36:11.080]  должен быть, должен называться new
[01:36:11.080 --> 01:36:13.080]  пустую структуру, например
[01:36:15.080 --> 01:36:17.080]  потом вы можете увидеть такое вот
[01:36:17.080 --> 01:36:19.080]  с большой буквы self
[01:36:19.080 --> 01:36:21.080]  если что, это означает
[01:36:21.080 --> 01:36:23.080]  что вы сюда должны подставить
[01:36:23.080 --> 01:36:25.080]  текущий тип
[01:36:25.080 --> 01:36:27.080]  конкретно текущий тип это то, что написано там в импл
[01:36:27.080 --> 01:36:29.080]  вот написано example, значит self
[01:36:29.080 --> 01:36:31.080]  это просто алиас на слово example
[01:36:31.080 --> 01:36:33.080]  то есть здесь на самом деле
[01:36:33.080 --> 01:36:35.080]  возвращается example
[01:36:35.080 --> 01:36:37.080]  можно написать example?
[01:36:37.080 --> 01:36:39.080]  да, можно
[01:36:39.080 --> 01:36:41.080]  а что еще раз работать?
[01:36:41.080 --> 01:36:43.080]  ну типа если там в example мы объявили еще какую-то структуру
[01:36:43.080 --> 01:36:45.080]  типа вот сейчас мы
[01:36:45.080 --> 01:36:47.080]  объясним конструктор
[01:36:47.080 --> 01:36:49.080]  структуры
[01:36:49.080 --> 01:36:51.080]  в плане мы структуру структуры объявили?
[01:36:51.080 --> 01:36:53.080]  ну там же тоже будет
[01:36:53.080 --> 01:36:55.080]  example возвращаться
[01:36:55.080 --> 01:36:57.080]  или ты имеешь в виду какие-то темплейты?
[01:36:57.080 --> 01:36:59.080]  нет, в плане структуры мы еще одну структуру объявили
[01:36:59.080 --> 01:37:01.080]  и тот конструктор
[01:37:01.080 --> 01:37:03.080]  а не структура описывает
[01:37:03.080 --> 01:37:05.080]  там же импл поддельная
[01:37:05.080 --> 01:37:07.080]  так
[01:37:07.080 --> 01:37:09.080]  сейчас вы говорите
[01:37:11.080 --> 01:37:13.080]  self это просто алиас
[01:37:13.080 --> 01:37:15.080]  на тип example
[01:37:15.080 --> 01:37:17.080]  который у нас сейчас есть и все
[01:37:17.080 --> 01:37:19.080]  то есть вы можете его спокойно использовать внутри
[01:37:19.080 --> 01:37:21.080]  блока импл
[01:37:21.080 --> 01:37:23.080]  это достаточно удобно
[01:37:23.080 --> 01:37:25.080]  еще его можно использовать
[01:37:25.080 --> 01:37:27.080]  кстати говоря слово self ключевое
[01:37:27.080 --> 01:37:29.080]  в блоке struct
[01:37:29.080 --> 01:37:31.080]  то есть struct example я бы мог написать
[01:37:31.080 --> 01:37:33.080]  опер count
[01:37:33.080 --> 01:37:35.080]  если вы напишите правда просто self
[01:37:35.080 --> 01:37:37.080]  то у вас бесконечного размера структуры
[01:37:37.080 --> 01:37:39.080]  потому что у вас там будет
[01:37:39.080 --> 01:37:41.080]  example сам себя вкладываться бесконечно
[01:37:41.080 --> 01:37:43.080]  еще что можно
[01:37:43.080 --> 01:37:45.080]  можно тоже использовать слово self
[01:37:45.080 --> 01:37:47.080]  то есть в объявлении структурки
[01:37:47.080 --> 01:37:49.080]  с большой буквы
[01:37:49.080 --> 01:37:51.080]  ну смотри
[01:37:51.080 --> 01:37:53.080]  например пусть я опер count сказал
[01:37:53.080 --> 01:37:55.080]  что это box от example
[01:37:55.080 --> 01:37:57.080]  а теперь я могу
[01:37:57.080 --> 01:37:59.080]  example написать просто self
[01:37:59.080 --> 01:38:01.080]  это тоже удобно бывает
[01:38:01.080 --> 01:38:03.080]  как-то у нас поле в границе
[01:38:03.080 --> 01:38:05.080]  массив самого себя
[01:38:05.080 --> 01:38:07.080]  сейчас поле хранится
[01:38:07.080 --> 01:38:09.080]  ну вот например был
[01:38:09.080 --> 01:38:11.080]  с боксом
[01:38:11.080 --> 01:38:13.080]  я привел
[01:38:13.080 --> 01:38:15.080]  в пример именно бокс
[01:38:15.080 --> 01:38:17.080]  потому что у нас есть одна проблемка здесь
[01:38:17.080 --> 01:38:19.080]  если мы
[01:38:19.080 --> 01:38:21.080]  напишем просто self опер count
[01:38:21.080 --> 01:38:23.080]  тогда у нас структура будет бесконечного размера
[01:38:23.080 --> 01:38:25.080]  она будет сложена
[01:38:25.080 --> 01:38:27.080]  то есть у нас это раскроется в даты
[01:38:27.080 --> 01:38:29.080]  и в общем-то
[01:38:29.080 --> 01:38:31.080]  так нельзя делать но Растов
[01:38:31.080 --> 01:38:33.080]  даже не предупредит
[01:38:33.080 --> 01:38:35.080]  они скомпилируются
[01:38:37.080 --> 01:38:39.080]  еще вы можете обратить внимание
[01:38:39.080 --> 01:38:41.080]  на ключевое слово pub
[01:38:41.080 --> 01:38:43.080]  то есть публичное
[01:38:43.080 --> 01:38:45.080]  пока что во всех домашних везде
[01:38:45.080 --> 01:38:47.080]  вы будете писать именно это слово
[01:38:47.080 --> 01:38:49.080]  оно означает то что оно
[01:38:49.080 --> 01:38:51.080]  публичное его видят все
[01:38:51.080 --> 01:38:53.080]  все функции
[01:38:53.080 --> 01:38:55.080]  все структуры внутри
[01:38:55.080 --> 01:38:57.080]  этого модуля
[01:38:57.080 --> 01:38:59.080]  что такое модуль мы пока что не знаем
[01:38:59.080 --> 01:39:01.080]  пока что вы можете просто писать pub
[01:39:01.080 --> 01:39:03.080]  и воспринимать его как public
[01:39:03.080 --> 01:39:05.080]  в c++
[01:39:05.080 --> 01:39:07.080]  просто
[01:39:07.080 --> 01:39:09.080]  подробности по тому как это работает
[01:39:09.080 --> 01:39:11.080]  и всякие там super
[01:39:11.080 --> 01:39:13.080]  namespace этому все рассмотрим на лекции
[01:39:13.080 --> 01:39:15.080]  покарга
[01:39:15.080 --> 01:39:17.080]  не берите пока что в голову просто пишите pub
[01:39:17.080 --> 01:39:19.080]  вот мой вам совет
[01:39:19.080 --> 01:39:21.080]  потом есть
[01:39:21.080 --> 01:39:23.080]  у нас функция push какая-то
[01:39:23.080 --> 01:39:25.080]  и она внезапно на этот раз принимает
[01:39:25.080 --> 01:39:27.080]  мутабельную ссылочку на self
[01:39:27.080 --> 01:39:29.080]  это означает что она не ассоциирована
[01:39:29.080 --> 01:39:31.080]  то есть например если у нас будет
[01:39:31.080 --> 01:39:33.080]  какая-то
[01:39:33.080 --> 01:39:35.080]  какой-то тип
[01:39:35.080 --> 01:39:37.080]  ну какая-то переменная которая имеет тип
[01:39:37.080 --> 01:39:39.080]  example то в таком случае
[01:39:39.080 --> 01:39:41.080]  вызывая на ней push
[01:39:41.080 --> 01:39:43.080]  вы сможете через точку
[01:39:43.080 --> 01:39:45.080]  вызвать на ней push и вы сможете
[01:39:45.080 --> 01:39:47.080]  мутировать эту переменную
[01:39:47.080 --> 01:39:49.080]  вот
[01:39:49.080 --> 01:39:51.080]  ассоциированность объединяется на вечер
[01:39:51.080 --> 01:39:53.080]  все в качестве перелома
[01:39:53.080 --> 01:39:55.080]  да
[01:39:55.080 --> 01:39:57.080]  здесь еще
[01:39:57.080 --> 01:39:59.080]  помимо этого вот
[01:39:59.080 --> 01:40:01.080]  example если что у нас
[01:40:01.080 --> 01:40:03.080]  upper count plus 1 data push
[01:40:03.080 --> 01:40:05.080]  все такое
[01:40:05.080 --> 01:40:07.080]  еще кстати забыл сказать
[01:40:07.080 --> 01:40:09.080]  вот здесь смотрите есть
[01:40:09.080 --> 01:40:11.080]  self.uppercount это для того чтобы обратиться
[01:40:11.080 --> 01:40:13.080]  к своим полям вообще-то я вспомнил
[01:40:13.080 --> 01:40:15.080]  это на Python уже похоже
[01:40:15.080 --> 01:40:17.080]  в Python мы тоже самое делаем
[01:40:19.080 --> 01:40:21.080]  еще да
[01:40:21.080 --> 01:40:23.080]  да все правильно здесь
[01:40:23.080 --> 01:40:25.080]  снизу и сверху включаются
[01:40:27.080 --> 01:40:29.080]  сейчас self
[01:40:29.080 --> 01:40:31.080]  вот self с большой буквы это просто текущий тип
[01:40:31.080 --> 01:40:33.080]  а self с маленькой буквы
[01:40:33.080 --> 01:40:35.080]  это текущий
[01:40:35.080 --> 01:40:37.080]  короче грубо говоря переменная я сам
[01:40:37.080 --> 01:40:39.080]  да
[01:40:39.080 --> 01:40:41.080]  а раз додумал бы сейчас
[01:40:41.080 --> 01:40:43.080]  self это зарезервированное слово
[01:40:43.080 --> 01:40:45.080]  да это зарезервированное слово
[01:40:49.080 --> 01:40:51.080]  так ну и вот еще помимо mute self
[01:40:51.080 --> 01:40:53.080]  есть просто self
[01:40:53.080 --> 01:40:55.080]  то есть это
[01:40:55.080 --> 01:40:57.080]  смотрите да это у нас был просто метод
[01:40:57.080 --> 01:40:59.080]  а теперь вот по сути const метод в плюсах
[01:40:59.080 --> 01:41:01.080]  ну то есть вы же знаете например что
[01:41:01.080 --> 01:41:03.080]  векторик когда вы называете length
[01:41:03.080 --> 01:41:05.080]  или size
[01:41:05.080 --> 01:41:07.080]  то в таком случае у вас в пишется const
[01:41:07.080 --> 01:41:09.080]  при фигурными скобочками чтобы показать что
[01:41:09.080 --> 01:41:11.080]  это не мутирует вектор точно так же
[01:41:11.080 --> 01:41:13.080]  просто ссылочка на self это что-то что не может мутировать
[01:41:13.080 --> 01:41:15.080]  если бы я здесь попробовал что-то
[01:41:15.080 --> 01:41:17.080]  запушить то я бы провалился
[01:41:17.080 --> 01:41:19.080]  потому что раз обратил бы внимание
[01:41:19.080 --> 01:41:21.080]  я пытаюсь мутировать текущий объект
[01:41:21.080 --> 01:41:23.080]  хотя он у меня есть только в redone режиме
[01:41:23.080 --> 01:41:25.080]  так
[01:41:27.080 --> 01:41:29.080]  потом есть it self
[01:41:29.080 --> 01:41:31.080]  ну здесь
[01:41:31.080 --> 01:41:33.080]  вот еще можно помимо того по значению
[01:41:33.080 --> 01:41:35.080]  принимать
[01:41:35.080 --> 01:41:37.080]  на самом деле это не совсем как в плюсах
[01:41:37.080 --> 01:41:39.080]  работает вы ожидаете например того что
[01:41:39.080 --> 01:41:41.080]  вы скопируете
[01:41:41.080 --> 01:41:43.080]  элемент да ну например
[01:41:43.080 --> 01:41:45.080]  если у вас есть в плюсах есть функция
[01:41:45.080 --> 01:41:47.080]  которая принимает на вход STD вектор
[01:41:47.080 --> 01:41:49.080]  то получание передаивая вектор
[01:41:49.080 --> 01:41:51.080]  у вас он скопируется
[01:41:51.080 --> 01:41:53.080]  но
[01:41:53.080 --> 01:41:55.080]  в расте вы
[01:41:55.080 --> 01:41:57.080]  по получению мовните туда то есть
[01:41:57.080 --> 01:41:59.080]  сделайте то же самое что и стд мов
[01:41:59.080 --> 01:42:01.080]  передадите владение
[01:42:11.080 --> 01:42:13.080]  нет нет
[01:42:13.080 --> 01:42:15.080]  self это такое особенное ключевое слово
[01:42:17.080 --> 01:42:19.080]  ну да
[01:42:19.080 --> 01:42:21.080]  ну в плюсах вы не пишете self
[01:42:21.080 --> 01:42:23.080]  например вообще у вас там статик
[01:42:23.080 --> 01:42:25.080]  если только написать чтобы ассоциированные функции
[01:42:25.080 --> 01:42:27.080]  сделать в получении она функция класс
[01:42:27.080 --> 01:42:29.080]  как бы вот
[01:42:29.080 --> 01:42:31.080]  а здесь
[01:42:31.080 --> 01:42:33.080]  в плане статичная
[01:42:33.080 --> 01:42:35.080]  ну мы сейчас увидим
[01:42:35.080 --> 01:42:37.080]  как она используется
[01:42:37.080 --> 01:42:39.080]  вы сейчас сказали что
[01:42:39.080 --> 01:42:41.080]  во всех функциях по получению
[01:42:41.080 --> 01:42:43.080]  вы не копируете
[01:42:43.080 --> 01:42:45.080]  нет все у нас
[01:42:45.080 --> 01:42:47.080]  все по молчанию
[01:42:49.080 --> 01:42:51.080]  в питоне же
[01:42:51.080 --> 01:42:53.080]  ссылки
[01:42:53.080 --> 01:42:55.080]  там тоже
[01:42:55.080 --> 01:42:57.080]  я не помню как это работает
[01:42:57.080 --> 01:42:59.080]  маленькие объекты копируются
[01:42:59.080 --> 01:43:01.080]  огромные листы они там по ссылке
[01:43:01.080 --> 01:43:03.080]  идут ну в общем
[01:43:03.080 --> 01:43:05.080]  в питоне вообще не очевидно
[01:43:05.080 --> 01:43:07.080]  а в расте наоборот все очень строго и классно
[01:43:07.080 --> 01:43:09.080]  мы это посмотрим потом
[01:43:09.080 --> 01:43:11.080]  а сейчас
[01:43:11.080 --> 01:43:13.080]  сейчас
[01:43:13.080 --> 01:43:15.080]  self маленькая
[01:43:15.080 --> 01:43:17.080]  подробно
[01:43:17.080 --> 01:43:19.080]  это просто указатель на себя
[01:43:19.080 --> 01:43:21.080]  давай я перейду к примерам и мы как раз увидим
[01:43:21.080 --> 01:43:23.080]  что это значит
[01:43:25.080 --> 01:43:27.080]  на предыдущем слайде
[01:43:27.080 --> 01:43:29.080]  там же
[01:43:29.080 --> 01:43:31.080]  вверху был комментарий что у нас
[01:43:31.080 --> 01:43:33.080]  ассоциированный, смотри, self здесь нет с маленькой буквы
[01:43:33.080 --> 01:43:35.080]  а ассоциированный
[01:43:35.080 --> 01:43:37.080]  то есть она не является функцией класса
[01:43:37.080 --> 01:43:39.080]  давай все таки к примерам перейдем
[01:43:39.080 --> 01:43:41.080]  если мы добавляем self, то это уже не эстетическая функция
[01:43:41.080 --> 01:43:43.080]  да, это функция класса
[01:43:43.080 --> 01:43:45.080]  вот смотрите здесь я
[01:43:45.080 --> 01:43:47.080]  объявляю x это example
[01:43:47.080 --> 01:43:49.080]  какой-то мутир
[01:43:49.080 --> 01:43:51.080]  x который мутабельный
[01:43:51.080 --> 01:43:53.080]  я его объявляю как operCount
[01:43:53.080 --> 01:43:55.080]  0 и data это какой-то
[01:43:55.080 --> 01:43:57.080]  новый вектор
[01:43:57.080 --> 01:43:59.080]  еще насколько вы помните я
[01:43:59.080 --> 01:44:01.080]  создавал функцию new, которая была ассоциирована
[01:44:01.080 --> 01:44:03.080]  как видите я могу ее вызвать вот так
[01:44:03.080 --> 01:44:05.080]  через
[01:44:05.080 --> 01:44:07.080]  два двоеточия
[01:44:07.080 --> 01:44:09.080]  и потом есть еще
[01:44:09.080 --> 01:44:11.080]  xpush10
[01:44:11.080 --> 01:44:13.080]  это то что вы можете
[01:44:13.080 --> 01:44:15.080]  заметить за self
[01:44:15.080 --> 01:44:17.080]  если бы здесь я не написал
[01:44:17.080 --> 01:44:19.080]  mute, то в таком случае я бы не мог сделать
[01:44:19.080 --> 01:44:21.080]  xpush потому что мне бы пришлось передать
[01:44:21.080 --> 01:44:23.080]  мутабельную ссылку
[01:44:23.080 --> 01:44:25.080]  раз не даст такое сделать
[01:44:25.080 --> 01:44:27.080]  потому что
[01:44:27.080 --> 01:44:29.080]  примерно не мутабельная, мы пытаемся мутировать через push
[01:44:31.080 --> 01:44:33.080]  тогда
[01:44:33.080 --> 01:44:35.080]  вот вторая и третья строчка
[01:44:35.080 --> 01:44:37.080]  это гарантия на порядок
[01:44:37.080 --> 01:44:39.080]  учтения
[01:44:39.080 --> 01:44:41.080]  на порядок индициализации
[01:44:41.080 --> 01:44:43.080]  кажется что там есть
[01:44:43.080 --> 01:44:45.080]  там есть сейчас
[01:44:45.080 --> 01:44:47.080]  гарантия на то что они обязательно
[01:44:47.080 --> 01:44:49.080]  нативизируются в том порядке в котором есть
[01:44:49.080 --> 01:44:51.080]  но там сейчас пока что это все дело плавает
[01:44:55.080 --> 01:44:57.080]  давай я не знаю
[01:44:57.080 --> 01:44:59.080]  закину тебе там rfc наверное
[01:44:59.080 --> 01:45:01.080]  как-нибудь в личку
[01:45:01.080 --> 01:45:03.080]  это
[01:45:03.080 --> 01:45:05.080]  как работает
[01:45:05.080 --> 01:45:07.080]  очень много раст кода
[01:45:07.080 --> 01:45:09.080]  по умолчанию раст не давал никаких гарантий
[01:45:09.080 --> 01:45:11.080]  и он их все еще и не дает
[01:45:11.080 --> 01:45:13.080]  но по факту он их всегда
[01:45:13.080 --> 01:45:15.080]  индициализирует в одном и том же порядке
[01:45:15.080 --> 01:45:17.080]  в котором они написаны
[01:45:17.080 --> 01:45:19.080]  и так как
[01:45:19.080 --> 01:45:21.080]  очень много раст кода на это полагается
[01:45:21.080 --> 01:45:23.080]  в итоге появился rfc
[01:45:23.080 --> 01:45:25.080]  давайте мы это стабилизируем
[01:45:25.080 --> 01:45:27.080]  пусть они всегда в таком порядке
[01:45:27.080 --> 01:45:29.080]  честно говоря
[01:45:29.080 --> 01:45:31.080]  я следил за тем какой он сейчас
[01:45:31.080 --> 01:45:33.080]  статус у него
[01:45:33.080 --> 01:45:35.080]  то есть возможно его уже приняли
[01:45:35.080 --> 01:45:37.080]  и сейчас они уже в каком-то порядке
[01:45:37.080 --> 01:45:39.080]  в определенном
[01:45:39.080 --> 01:45:41.080]  гарантированно индициализируются
[01:45:41.080 --> 01:45:43.080]  но лучше на это не полагать
[01:45:43.080 --> 01:45:45.080]  вообще что-то мы задаем кто-то
[01:45:45.080 --> 01:45:47.080]  раст или нет
[01:45:47.080 --> 01:45:49.080]  думал о том что он создан на стеке
[01:45:49.080 --> 01:45:51.080]  у нас есть вообще такие понятия
[01:45:51.080 --> 01:45:53.080]  да у нас есть понятия есть так и куча
[01:45:53.080 --> 01:45:55.080]  то есть вот эти две структуры у нас там
[01:45:55.080 --> 01:45:57.080]  да смотри
[01:45:57.080 --> 01:45:59.080]  example сам находится
[01:45:59.080 --> 01:46:01.080]  на стеке
[01:46:01.080 --> 01:46:03.080]  все поля вектора
[01:46:03.080 --> 01:46:05.080]  будут тоже на стеке внутри example
[01:46:05.080 --> 01:46:07.080]  а буфер вектора
[01:46:07.080 --> 01:46:09.080]  будет находиться уже на куче
[01:46:09.080 --> 01:46:11.080]  там внутри будет какой-то указатель
[01:46:11.080 --> 01:46:13.080]  который будет показывать на кучу
[01:46:13.080 --> 01:46:15.080]  в получении у нас все
[01:46:15.080 --> 01:46:17.080]  в расте как в плюсах все на стеке
[01:46:17.080 --> 01:46:19.080]  там достаточно явно
[01:46:19.080 --> 01:46:21.080]  все работает с кучей
[01:46:21.080 --> 01:46:23.080]  ну и тут
[01:46:23.080 --> 01:46:25.080]  upper count который бы сработал и без mute
[01:46:25.080 --> 01:46:27.080]  над x
[01:46:27.080 --> 01:46:29.080]  еще в ассерте
[01:46:29.080 --> 01:46:31.080]  так все ли
[01:46:31.080 --> 01:46:33.080]  с этим понятно
[01:46:33.080 --> 01:46:35.080]  можно перегружать метод
[01:46:37.080 --> 01:46:39.080]  кстати вот тоже хороший вопрос
[01:46:39.080 --> 01:46:41.080]  можно ли перегружать метод вообще перегружать
[01:46:41.080 --> 01:46:43.080]  методы нельзя в расте то есть вы делаете
[01:46:43.080 --> 01:46:45.080]  это специально сделано чтобы вы
[01:46:45.080 --> 01:46:47.080]  не делали там 50 реконструктора
[01:46:47.080 --> 01:46:49.080]  и потом плакали у вас например
[01:46:49.080 --> 01:46:51.080]  в векторе если вы хотите создать пустой
[01:46:51.080 --> 01:46:53.080]  вектор то у вас век new
[01:46:53.080 --> 01:46:55.080]  если вы хотите создать вектор с преалацированной памяти
[01:46:55.080 --> 01:46:57.080]  то вы пишите век vifcapacity
[01:46:57.080 --> 01:46:59.080]  то есть там бы вместо new было написано
[01:46:59.080 --> 01:47:01.080]  vifcapacity в скобчиках написали с каким capacity
[01:47:01.080 --> 01:47:03.080]  то есть все чтобы было красивенько и явно
[01:47:03.080 --> 01:47:05.080]  ну такой язык очень
[01:47:05.080 --> 01:47:07.080]  то есть за счет того что какой конструктор
[01:47:07.080 --> 01:47:09.080]  это идеальная функция
[01:47:09.080 --> 01:47:11.080]  не ну new
[01:47:11.080 --> 01:47:13.080]  раз на самом деле ничего не знает про то что
[01:47:13.080 --> 01:47:15.080]  это конструктор это просто такое соглашение
[01:47:15.080 --> 01:47:17.080]  что new мы называем какие-то конструкторы
[01:47:17.080 --> 01:47:19.080]  которые возвращают self
[01:47:19.080 --> 01:47:21.080]  сейчас а если
[01:47:21.080 --> 01:47:23.080]  в экземпле
[01:47:23.080 --> 01:47:25.080]  мы же можем
[01:47:25.080 --> 01:47:27.080]  заводить в экземпле переменные
[01:47:27.080 --> 01:47:29.080]  или ты имеешь ввиду переменные
[01:47:29.080 --> 01:47:31.080]  в скобке которые вот где выше
[01:47:31.080 --> 01:47:33.080]  вот тут вот
[01:47:33.080 --> 01:47:35.080]  нет не можем
[01:47:35.080 --> 01:47:37.080]  это просто такой блок который означает
[01:47:37.080 --> 01:47:39.080]  что здесь вот имплементация экземпля
[01:47:39.080 --> 01:47:41.080]  оно относится к экземплям
[01:47:41.080 --> 01:47:43.080]  а еще вот про мутабельность
[01:47:43.080 --> 01:47:45.080]  ну вот у нас сейчас был
[01:47:45.080 --> 01:47:47.080]  с мутабельностью
[01:47:47.080 --> 01:47:49.080]  ну то есть мы бушили
[01:47:49.080 --> 01:47:51.080]  в настоящем снаряжении
[01:47:53.080 --> 01:47:55.080]  сейчас
[01:47:55.080 --> 01:47:57.080]  ну в общем мы
[01:47:57.080 --> 01:47:59.080]  структуру
[01:47:59.080 --> 01:48:01.080]  которая объявили
[01:48:01.080 --> 01:48:03.080]  не мутабельной можем
[01:48:03.080 --> 01:48:05.080]  изменить ее поле
[01:48:05.080 --> 01:48:07.080]  не мутабельной изменить ее поле
[01:48:07.080 --> 01:48:09.080]  нет не можем, не ну вообще по факту
[01:48:09.080 --> 01:48:11.080]  если вы пользуетесь unsafe то можете
[01:48:11.080 --> 01:48:13.080]  то есть вы можете
[01:48:13.080 --> 01:48:15.080]  unsafe вообще вся гарантия
[01:48:15.080 --> 01:48:17.080]  не выбирай
[01:48:17.080 --> 01:48:19.080]  это такое я вам могу скинуть
[01:48:19.080 --> 01:48:21.080]  чатик в этом мем скрабом которому выдают
[01:48:21.080 --> 01:48:23.080]  пулемет
[01:48:23.080 --> 01:48:25.080]  он может сделать все что угодно
[01:48:25.080 --> 01:48:27.080]  в своем случае, ну лучше не делайте
[01:48:33.080 --> 01:48:35.080]  да да мы не можем мутабель
[01:48:35.080 --> 01:48:37.080]  делать
[01:48:47.080 --> 01:48:49.080]  сейчас подожди точка
[01:48:49.080 --> 01:48:51.080]  рет
[01:49:07.080 --> 01:49:09.080]  там есть
[01:49:09.080 --> 01:49:11.080]  в расте
[01:49:11.080 --> 01:49:13.080]  два трейта есть там
[01:49:13.080 --> 01:49:15.080]  индекс и индекс мьют
[01:49:15.080 --> 01:49:17.080]  не разбирайтесь
[01:49:19.080 --> 01:49:21.080]  то есть одно вызывает в одном случае
[01:49:21.080 --> 01:49:23.080]  другое в другом
[01:49:25.080 --> 01:49:27.080]  так
[01:49:27.080 --> 01:49:29.080]  давайте мы теперь дженерики напишем
[01:49:29.080 --> 01:49:31.080]  в отличие от плюсов нам не нужно писать
[01:49:31.080 --> 01:49:33.080]  просто слово template мы просто пишем
[01:49:33.080 --> 01:49:35.080]  такие астракты example и
[01:49:35.080 --> 01:49:37.080]  в кавычках такие вот
[01:49:37.080 --> 01:49:39.080]  и пишем прежде что мы
[01:49:39.080 --> 01:49:41.080]  дженерик по т
[01:49:41.080 --> 01:49:43.080]  теперь
[01:49:43.080 --> 01:49:45.080]  если мы будем дописывать
[01:49:45.080 --> 01:49:47.080]  в импл какие-то
[01:49:47.080 --> 01:49:49.080]  какие-то типы
[01:49:49.080 --> 01:49:51.080]  мы дописываем фигурный скобчик
[01:49:51.080 --> 01:49:53.080]  te в импл и в example
[01:49:53.080 --> 01:49:55.080]  кажется что это как-то перебор
[01:49:55.080 --> 01:49:57.080]  писать в двух местах
[01:49:57.080 --> 01:49:59.080]  на самом деле ответ наперед просто у нас там могут быть
[01:49:59.080 --> 01:50:01.080]  всякие дженерики у нас
[01:50:01.080 --> 01:50:03.080]  могут быть имплы трейтов для
[01:50:03.080 --> 01:50:05.080]  структуры и там уже
[01:50:07.080 --> 01:50:09.080]  специализация это вообще
[01:50:09.080 --> 01:50:11.080]  другая тема там
[01:50:11.080 --> 01:50:13.080]  забудь про нее пока что
[01:50:19.080 --> 01:50:21.080]  вообще это
[01:50:21.080 --> 01:50:23.080]  сделано для того чтобы в импл вы написали все
[01:50:23.080 --> 01:50:25.080]  аргументы по которым вы дженерика
[01:50:25.080 --> 01:50:27.080]  после этого их расфасовали
[01:50:27.080 --> 01:50:29.080]  и все
[01:50:29.080 --> 01:50:31.080]  так
[01:50:37.080 --> 01:50:39.080]  импл и экземпл да да да
[01:50:39.080 --> 01:50:41.080]  такое может быть запросто
[01:50:41.080 --> 01:50:43.080]  то есть особенно если у вас там какой-то
[01:50:43.080 --> 01:50:45.080]  трейд имплементироваться у вас там будет
[01:50:45.080 --> 01:50:47.080]  импл те у допустим у вас там
[01:50:47.080 --> 01:50:49.080]  экземпл те
[01:50:49.080 --> 01:50:51.080]  у может быть
[01:50:51.080 --> 01:50:53.080]  такое разразенное типа
[01:50:53.080 --> 01:50:55.080]  импл это просто почему вы дженерик
[01:50:55.080 --> 01:50:57.080]  после этого расставляете
[01:50:59.080 --> 01:51:01.080]  если вы не понимаете что такое трейд
[01:51:01.080 --> 01:51:03.080]  то забудьте пока что
[01:51:03.080 --> 01:51:05.080]  пока что примите как данность
[01:51:05.080 --> 01:51:07.080]  вот
[01:51:07.080 --> 01:51:09.080]  здесь вот так вот принимаем
[01:51:09.080 --> 01:51:11.080]  на вход экс как т
[01:51:11.080 --> 01:51:13.080]  точно так же его пушим то есть вообще
[01:51:13.080 --> 01:51:15.080]  ничего не изменилось
[01:51:19.080 --> 01:51:21.080]  вню
[01:51:21.080 --> 01:51:23.080]  просто создаем вектор
[01:51:23.080 --> 01:51:25.080]  ну вот через self
[01:51:25.080 --> 01:51:27.080]  да это ключевое слово
[01:51:27.080 --> 01:51:29.080]  ну вот это вот
[01:51:29.080 --> 01:51:31.080]  тут правда чуть-чуть отличаются цвета
[01:51:31.080 --> 01:51:33.080]  но это же не моя беда
[01:51:33.080 --> 01:51:35.080]  беда
[01:51:35.080 --> 01:51:37.080]  латехного мента
[01:51:37.080 --> 01:51:39.080]  который не умеет подсвечивать
[01:51:39.080 --> 01:51:41.080]  ну в общем это два ключевых слова
[01:51:41.080 --> 01:51:43.080]  и здесь кстати говоря self будет просто
[01:51:43.080 --> 01:51:45.080]  экземпл те
[01:51:45.080 --> 01:51:47.080]  то есть self это экземпл те
[01:51:47.080 --> 01:51:49.080]  да то есть
[01:51:49.080 --> 01:51:51.080]  self равно экземпл те
[01:51:51.080 --> 01:51:53.080]  то есть это алис на
[01:51:53.080 --> 01:51:55.080]  вот это вот название
[01:51:55.080 --> 01:51:57.080]  а вот это
[01:51:59.080 --> 01:52:01.080]  сейчас где
[01:52:01.080 --> 01:52:03.080]  а тип
[01:52:03.080 --> 01:52:05.080]  век это какой-то стандартный вектор
[01:52:05.080 --> 01:52:07.080]  или это какой-то
[01:52:07.080 --> 01:52:09.080]  он находится в стандартной библиотеке
[01:52:09.080 --> 01:52:11.080]  он импортирован по умолчанию
[01:52:11.080 --> 01:52:13.080]  это обычный вектор как в плюсах
[01:52:13.080 --> 01:52:15.080]  а мы в него не придаем тип его элемента
[01:52:15.080 --> 01:52:17.080]  просто у нас же сейчас
[01:52:17.080 --> 01:52:19.080]  он его выводит автоматически
[01:52:19.080 --> 01:52:21.080]  раса умеет выводить
[01:52:21.080 --> 01:52:23.080]  да, то какой тип век
[01:52:23.080 --> 01:52:25.080]  да, здесь будет тип век те
[01:52:25.080 --> 01:52:27.080]  просто раз он понимает
[01:52:27.080 --> 01:52:29.080]  вот, видит так, ага, значит у нас
[01:52:29.080 --> 01:52:31.080]  дейта это век те, значит когда мы создаем
[01:52:31.080 --> 01:52:33.080]  век нью, значит это век те нью
[01:52:33.080 --> 01:52:35.080]  вот и все
[01:52:35.080 --> 01:52:37.080]  ну и дальше кажется
[01:52:37.080 --> 01:52:39.080]  это мы
[01:52:39.080 --> 01:52:41.080]  посмотрим еще
[01:52:43.080 --> 01:52:45.080]  то есть у нас импл без
[01:52:45.080 --> 01:52:47.080]  структуры не может быть
[01:52:47.080 --> 01:52:49.080]  да, у нас не может быть
[01:52:49.080 --> 01:52:51.080]  простого импла, мы можем
[01:52:51.080 --> 01:52:53.080]  ориентировать только структур
[01:52:53.080 --> 01:52:55.080]  либо трейд для структуры
[01:52:55.080 --> 01:52:57.080]  а можно как-то в одном месте сделать
[01:52:57.080 --> 01:52:59.080]  типа если я хочу
[01:52:59.080 --> 01:53:01.080]  ну то есть
[01:53:01.080 --> 01:53:03.080]  у меня есть структура
[01:53:03.080 --> 01:53:05.080]  у нее должны быть функции
[01:53:05.080 --> 01:53:07.080]  но
[01:53:07.080 --> 01:53:09.080]  ну как бы
[01:53:09.080 --> 01:53:11.080]  не хочется это в отдельное место переносить
[01:53:11.080 --> 01:53:13.080]  то есть сейчас, я так понимаю, нужно писать
[01:53:13.080 --> 01:53:15.080]  сначала объявление структуры
[01:53:15.080 --> 01:53:17.080]  потом объявление импла
[01:53:17.080 --> 01:53:19.080]  а как-то один в одном
[01:53:19.080 --> 01:53:21.080]  вообще, кстати, можно и наоборот
[01:53:21.080 --> 01:53:23.080]  насколько я помню, Rast
[01:53:23.080 --> 01:53:25.080]  он просто не плюсы в этом смысле
[01:53:25.080 --> 01:53:27.080]  ему пару барабанов в каком порядке объявлять
[01:53:27.080 --> 01:53:29.080]  переменные
[01:53:29.080 --> 01:53:31.080]  в любом случае должны быть два текста
[01:53:31.080 --> 01:53:33.080]  структура и импл
[01:53:33.080 --> 01:53:35.080]  можно, кстати, без импла
[01:53:35.080 --> 01:53:37.080]  если вам просто нужна структура, можно без импла
[01:53:37.080 --> 01:53:39.080]  я в чем вопрос?
[01:53:39.080 --> 01:53:41.080]  нужно структура с функцией
[01:53:41.080 --> 01:53:43.080]  ну как обычно классно писать
[01:53:43.080 --> 01:53:45.080]  нет, тут в Rast
[01:53:45.080 --> 01:53:47.080]  в OOP такого OOP нет
[01:53:47.080 --> 01:53:49.080]  то есть тут вот так все устроено
[01:53:49.080 --> 01:53:51.080]  на самом деле это даже прекрасно
[01:53:51.080 --> 01:53:53.080]  что тут такого нет
[01:53:53.080 --> 01:53:55.080]  потому что это немножко упрощает жизнь
[01:53:55.080 --> 01:53:57.080]  еще вопрос
[01:53:57.080 --> 01:53:59.080]  мы сейчас инфинитируем
[01:53:59.080 --> 01:54:01.080]  экземпл с шаблоном
[01:54:01.080 --> 01:54:03.080]  generic, а для него структура
[01:54:03.080 --> 01:54:05.080]  с этой структуры должна объявлять
[01:54:05.080 --> 01:54:07.080]  generic
[01:54:07.080 --> 01:54:09.080]  в плане структуры должны объявлять generic
[01:54:09.080 --> 01:54:11.080]  у нас
[01:54:11.080 --> 01:54:13.080]  импл T и экземпл D
[01:54:13.080 --> 01:54:15.080]  значит, должен быть
[01:54:15.080 --> 01:54:17.080]  соответствующая структура
[01:54:17.080 --> 01:54:19.080]  ну да, экземпл T
[01:54:19.080 --> 01:54:21.080]  должна быть
[01:54:21.080 --> 01:54:23.080]  которая такое объявление имеет
[01:54:25.080 --> 01:54:27.080]  а мы можем
[01:54:31.080 --> 01:54:33.080]  мы можем структуру без шаблона
[01:54:35.080 --> 01:54:37.080]  инфинитировать
[01:54:37.080 --> 01:54:39.080]  структуру без шаблона
[01:54:39.080 --> 01:54:41.080]  инфинитировать с шаблоном
[01:54:41.080 --> 01:54:43.080]  то есть структуру хранить
[01:54:43.080 --> 01:54:45.080]  я не очень понял концепт вопроса
[01:54:45.080 --> 01:54:47.080]  а что значит имплементация с шаблоном
[01:54:47.080 --> 01:54:49.080]  без шаблона
[01:54:49.080 --> 01:54:51.080]  методы
[01:54:51.080 --> 01:54:53.080]  можно написать
[01:54:53.080 --> 01:54:55.080]  pub, fn, u, T
[01:54:55.080 --> 01:54:57.080]  и там внутри уже использовать тип T
[01:54:57.080 --> 01:54:59.080]  но он будет присутствовать
[01:54:59.080 --> 01:55:01.080]  только внутри этой функции new
[01:55:01.080 --> 01:55:03.080]  только внутри new
[01:55:03.080 --> 01:55:05.080]  а тут у нас же по сути
[01:55:05.080 --> 01:55:07.080]  то же самое
[01:55:07.080 --> 01:55:09.080]  не, не то же самое, здесь T, у нас все
[01:55:09.080 --> 01:55:11.080]  то есть T виден везде
[01:55:11.080 --> 01:55:13.080]  и у нас generic все функции
[01:55:13.080 --> 01:55:15.080]  то есть и new generic, и push generic
[01:55:19.080 --> 01:55:21.080]  спецификация generic есть вообще?
[01:55:21.080 --> 01:55:23.080]  а что значит спецификация?
[01:55:23.080 --> 01:55:25.080]  то есть я хочу имплементировать
[01:55:25.080 --> 01:55:27.080]  другого для inta
[01:55:27.080 --> 01:55:29.080]  имплементировать generic
[01:55:29.080 --> 01:55:31.080]  для inta?
[01:55:31.080 --> 01:55:33.080]  функция push у меня для inta
[01:55:33.080 --> 01:55:35.080]  а, специализацию ты имеешь в виду какую-то?
[01:55:35.080 --> 01:55:37.080]  нет, такого нет
[01:55:37.080 --> 01:55:39.080]  нет
[01:55:39.080 --> 01:55:41.080]  ты конечно можешь сделать
[01:55:41.080 --> 01:55:43.080]  здесь push
[01:55:43.080 --> 01:55:45.080]  да, ты можешь делать так
[01:55:45.080 --> 01:55:47.080]  на самом деле можешь
[01:55:47.080 --> 01:55:49.080]  ты можешь написать импл T
[01:55:49.080 --> 01:55:51.080]  в R и там нужно будет использовать
[01:55:51.080 --> 01:55:53.080]  трейтер для того чтобы отсечь все
[01:55:53.080 --> 01:55:55.080]  кроме I32, например
[01:55:55.080 --> 01:55:57.080]  а потом в push написать
[01:55:57.080 --> 01:55:59.080]  то есть написать еще один импл, где T
[01:55:59.080 --> 01:56:01.080]  в R, T, I32
[01:56:01.080 --> 01:56:03.080]  но это нет в программе
[01:56:03.080 --> 01:56:05.080]  ну да, там выйдет блок в R
[01:56:05.080 --> 01:56:07.080]  на следующей лекции поговорим об этом
[01:56:07.080 --> 01:56:09.080]  такие примерно вещи
[01:56:09.080 --> 01:56:11.080]  можно делать
[01:56:11.080 --> 01:56:13.080]  то есть что-то типа перегрузки
[01:56:13.080 --> 01:56:15.080]  для разных типов по-разному
[01:56:15.080 --> 01:56:17.080]  писать имплементации
[01:56:17.080 --> 01:56:19.080]  например, для вектора, если у вас тип имеет
[01:56:19.080 --> 01:56:21.080]  нулевой размер, то на самом деле вектор
[01:56:21.080 --> 01:56:23.080]  это просто счетчик
[01:56:23.080 --> 01:56:25.080]  то есть на самом деле там нет никакого буфера
[01:56:25.080 --> 01:56:27.080]  ну зачем действительно, если у вас тип
[01:56:27.080 --> 01:56:29.080]  нулевого размера, хранить вам буфер
[01:56:31.080 --> 01:56:33.080]  давайте этим воспользуемся
[01:56:33.080 --> 01:56:35.080]  добром, что мы сделали
[01:56:35.080 --> 01:56:37.080]  у нас есть экземпл I32
[01:56:37.080 --> 01:56:39.080]  заметьте, я вот
[01:56:39.080 --> 01:56:41.080]  написал тип вот так вот I32
[01:56:41.080 --> 01:56:43.080]  и указал
[01:56:43.080 --> 01:56:45.080]  опер каунт, дейта
[01:56:45.080 --> 01:56:47.080]  чему равно
[01:56:47.080 --> 01:56:49.080]  можно написать еще слева тип
[01:56:49.080 --> 01:56:51.080]  let mute x, двоеточие экземпл I32
[01:56:51.080 --> 01:56:53.080]  равняется экземплу I32
[01:56:53.080 --> 01:56:55.080]  ну раз тут и так все выйдет
[01:56:55.080 --> 01:56:57.080]  то есть не нужно этого делать
[01:56:57.080 --> 01:56:59.080]  потом есть
[01:56:59.080 --> 01:57:01.080]  Y, который у нас объявляется
[01:57:01.080 --> 01:57:03.080]  ну у нас есть new
[01:57:03.080 --> 01:57:05.080]  у нас есть такой синтаксис
[01:57:05.080 --> 01:57:07.080]  два двоеточия и скобочки
[01:57:07.080 --> 01:57:09.080]  он называется turbofish
[01:57:09.080 --> 01:57:11.080]  это на самом деле некоторые достижения
[01:57:11.080 --> 01:57:13.080]  Rasta, потому что в отличие от плюсов
[01:57:13.080 --> 01:57:15.080]  за счет этого вам не нужно
[01:57:15.080 --> 01:57:17.080]  вы легко отличаете между собой типы
[01:57:17.080 --> 01:57:19.080]  и сами функции
[01:57:19.080 --> 01:57:21.080]  это позволяет несколько раз
[01:57:21.080 --> 01:57:23.080]  не парсить файлы
[01:57:27.080 --> 01:57:29.080]  и дальше давайте мы посмотрим
[01:57:29.080 --> 01:57:31.080]  ну вот
[01:57:33.080 --> 01:57:35.080]  без двоеточий не скомпилируется
[01:57:35.080 --> 01:57:37.080]  ну или в плане ты имеешь в виду Y
[01:57:37.080 --> 01:57:39.080]  где, если я двоеточие уберу
[01:57:39.080 --> 01:57:41.080]  где-нибудь вот тут
[01:57:41.080 --> 01:57:43.080]  без этого не скомпилируется
[01:57:43.080 --> 01:57:45.080]  то есть ты как бы экземпл, потом говоришь
[01:57:45.080 --> 01:57:47.080]  я имею в виду экземпл, который вот такие от
[01:57:47.080 --> 01:57:49.080]  генерики, а после этого вызываешь на нем new
[01:57:49.080 --> 01:57:51.080]  сейчас, а вот это два объявления Z
[01:57:51.080 --> 01:57:53.080]  они полностью эквивалентные
[01:57:53.080 --> 01:57:55.080]  да, они
[01:57:55.080 --> 01:57:57.080]  полностью эквивалентные, кстати говоря
[01:57:57.080 --> 01:57:59.080]  в этом только вчера, если честно
[01:57:59.080 --> 01:58:01.080]  я просто чисто случайно написал два двоеточия здесь
[01:58:01.080 --> 01:58:03.080]  я выяснил, что конкретно в этом вот случае
[01:58:03.080 --> 01:58:05.080]  но не в этом, вот в этом случае
[01:58:05.080 --> 01:58:07.080]  вы можете типы эти два одинаковые
[01:58:11.080 --> 01:58:13.080]  ну короче, просто выяснять, что
[01:58:13.080 --> 01:58:15.080]  это две одинаковые вещи
[01:58:15.080 --> 01:58:17.080]  ну точно так же
[01:58:17.080 --> 01:58:19.080]  пушим, смотрим на аутеркан, все работает
[01:58:19.080 --> 01:58:21.080]  здесь у нас такой
[01:58:21.080 --> 01:58:23.080]  генерик тип, где можно кроме E32
[01:58:23.080 --> 01:58:25.080]  еще что-нибудь запустить
[01:58:27.080 --> 01:58:29.080]  потом, ну давайте
[01:58:29.080 --> 01:58:31.080]  собственно посмотрим
[01:58:31.080 --> 01:58:33.080]  на E, while, for и подобные вещи
[01:58:33.080 --> 01:58:35.080]  у нас есть
[01:58:35.080 --> 01:58:37.080]  примерно X
[01:58:37.080 --> 01:58:39.080]  мутабельная, которая равняется двум
[01:58:39.080 --> 01:58:41.080]  потом если X равняется двум, вот мы что-то делаем
[01:58:41.080 --> 01:58:43.080]  их мы в принципе уже видели
[01:58:43.080 --> 01:58:45.080]  я кстати не обратил ваше внимание, но вообще
[01:58:45.080 --> 01:58:47.080]  в эфи, как вы могли заметить, мы скобчики
[01:58:47.080 --> 01:58:49.080]  не пишем, это особенность
[01:58:49.080 --> 01:58:51.080]  раз-та, то есть в плюсах
[01:58:51.080 --> 01:58:53.080]  например, вам нужно это делать, раз-те не мы
[01:58:53.080 --> 01:58:55.080]  while то же самое
[01:58:55.080 --> 01:58:57.080]  то есть на условии не нужно ставить скобочки
[01:59:03.080 --> 01:59:05.080]  ну тогда
[01:59:05.080 --> 01:59:07.080]  компилятор скажет, что-то у вас код ставил, хромает
[01:59:07.080 --> 01:59:09.080]  варнинг выдаст
[01:59:09.080 --> 01:59:11.080]  то есть скомпилирует, но скажет
[01:59:11.080 --> 01:59:13.080]  уберите, пожалуйста, скобочки, желательно
[01:59:13.080 --> 01:59:15.080]  не надо
[01:59:19.080 --> 01:59:21.080]  это
[01:59:21.080 --> 01:59:23.080]  на самом деле особенная функция, которая называется
[01:59:23.080 --> 01:59:25.080]  накросы, их можно пока что
[01:59:25.080 --> 01:59:27.080]  воспринимать просто как функции
[01:59:27.080 --> 01:59:29.080]  на самом деле они кодогенерацию производят
[01:59:29.080 --> 01:59:31.080]  не давать подробностей
[01:59:47.080 --> 01:59:49.080]  потом у нас есть луп
[01:59:49.080 --> 01:59:51.080]  то есть у нас был while, а есть
[01:59:51.080 --> 01:59:53.080]  раз-те луп, у которого нет условий, который
[01:59:53.080 --> 01:59:55.080]  просто крутится
[01:59:55.080 --> 01:59:57.080]  он крутится до тех пор, пока
[01:59:57.080 --> 01:59:59.080]  не произойдет return, break
[01:59:59.080 --> 02:00:01.080]  или вообще
[02:00:01.080 --> 02:00:03.080]  никогда не возвращается
[02:00:05.080 --> 02:00:07.080]  ну смотрите
[02:00:07.080 --> 02:00:09.080]  сейчас, ну да, это while true, но
[02:00:09.080 --> 02:00:11.080]  только на самом деле чуть хитрее, потому что
[02:00:11.080 --> 02:00:13.080]  ну сейчас объясню, там
[02:00:13.080 --> 02:00:15.080]  оптимизация компилятора есть
[02:00:15.080 --> 02:00:17.080]  в общем
[02:00:17.080 --> 02:00:19.080]  как вы видите, конкретно луп
[02:00:19.080 --> 02:00:21.080]  ну break здесь происходит, мы из него
[02:00:21.080 --> 02:00:23.080]  выходим, все нормально, то есть вроде бы понятно, что
[02:00:23.080 --> 02:00:25.080]  этот код делает, можете обратить внимание
[02:00:25.080 --> 02:00:27.080]  на то, что точку запятой нам тоже не обязательно ставить
[02:00:27.080 --> 02:00:29.080]  точно так же, как и в return в случае break
[02:00:33.080 --> 02:00:35.080]  и мы еще в раз-те умеем
[02:00:35.080 --> 02:00:37.080]  возвращаться, брейкаться с значением
[02:00:39.080 --> 02:00:41.080]  это прям то, аналога чего, нет вообще
[02:00:41.080 --> 02:00:43.080]  в плюсах, мы можем возвращаться
[02:00:43.080 --> 02:00:45.080]  с значением, конкретно вот эта вот штука вернет
[02:00:45.080 --> 02:00:47.080]  20, то есть мы какой-то создаем
[02:00:47.080 --> 02:00:49.080]  каунтер, а потом result присваиваем значение
[02:00:49.080 --> 02:00:51.080]  loop и loop
[02:00:51.080 --> 02:00:53.080]  в свою очередь там какой-то каунтер крутит
[02:00:53.080 --> 02:00:55.080]  до 10 и возвращает
[02:00:55.080 --> 02:00:57.080]  каунтер на 2
[02:00:57.080 --> 02:00:59.080]  видите, break, каунтер на 2
[02:00:59.080 --> 02:01:01.080]  и вот получается, что
[02:01:01.080 --> 02:01:03.080]  loop это точно так же expression, который
[02:01:03.080 --> 02:01:05.080]  вернет какое-то значение
[02:01:09.080 --> 02:01:11.080]  так, всем понятно?
[02:01:13.080 --> 02:01:15.080]  все еще можно было loop
[02:01:15.080 --> 02:01:17.080]  но на самом деле
[02:01:17.080 --> 02:01:19.080]  это не одинаковые вещи
[02:01:19.080 --> 02:01:21.080]  сейчас еще чуть-чуть дальше буквально
[02:01:25.080 --> 02:01:27.080]  return у нас с функцией возвращается
[02:01:27.080 --> 02:01:29.080]  а break у нас с цикла
[02:01:29.080 --> 02:01:31.080]  или if
[02:01:31.080 --> 02:01:33.080]  из if он не возвращает
[02:01:33.080 --> 02:01:35.080]  то есть if это просто if
[02:01:35.080 --> 02:01:37.080]  что значит брейкнуться из if
[02:01:41.080 --> 02:01:43.080]  то есть здесь будет
[02:01:43.080 --> 02:01:45.080]  возвращаться внешний loop
[02:01:45.080 --> 02:01:47.080]  а еще мы еще одна вещь
[02:01:47.080 --> 02:01:49.080]  что-то типа gota
[02:01:49.080 --> 02:01:51.080]  но это на самом деле не gota
[02:01:51.080 --> 02:01:53.080]  оно существует только для циклов
[02:01:53.080 --> 02:01:55.080]  мы можем выходить из внешних циклов
[02:01:57.080 --> 02:01:59.080]  мы заходим в какой-то цикл
[02:01:59.080 --> 02:02:01.080]  наш loop там внутри какой-то
[02:02:01.080 --> 02:02:03.080]  от 0 до 10 еще один for
[02:02:03.080 --> 02:02:05.080]  мы заходим
[02:02:05.080 --> 02:02:07.080]  внутренний цикл
[02:02:07.080 --> 02:02:09.080]  и потом возвращаемся, смотрите
[02:02:09.080 --> 02:02:11.080]  break outer, то есть возвращаемся в outer loop
[02:02:11.080 --> 02:02:13.080]  вот, соответственно мы выйдем вот сюда
[02:02:13.080 --> 02:02:15.080]  ну и наш код выйдет
[02:02:15.080 --> 02:02:17.080]  entered the outer loop, entered the inner loop
[02:02:17.080 --> 02:02:19.080]  и потом exited the outer loop
[02:02:25.080 --> 02:02:27.080]  вот это вот
[02:02:27.080 --> 02:02:29.080]  3 outer
[02:02:29.080 --> 02:02:31.080]  ну это просто специальный синтаксис
[02:02:31.080 --> 02:02:33.080]  для таких именованных
[02:02:35.080 --> 02:02:37.080]  да, ну там
[02:02:37.080 --> 02:02:39.080]  конечно в рамках разумного
[02:02:39.080 --> 02:02:41.080]  не помню точно какие там уже
[02:02:41.080 --> 02:02:43.080]  буковки можно писать конкретно
[02:02:43.080 --> 02:02:45.080]  да, кстати
[02:02:45.080 --> 02:02:47.080]  тоже в прикольный момент
[02:02:47.080 --> 02:02:49.080]  Rasta вообще поддерживает для названия всяких переменных
[02:02:49.080 --> 02:02:51.080]  всего такого полностью UTF-8
[02:02:51.080 --> 02:02:53.080]  так что вы можете
[02:02:53.080 --> 02:02:55.080]  какое-то время назад, кстати, была шутка
[02:02:55.080 --> 02:02:57.080]  совсем недавно
[02:02:57.080 --> 02:02:59.080]  вы могли использовать, эмоджи нельзя
[02:02:59.080 --> 02:03:01.080]  запрещено вообще
[02:03:01.080 --> 02:03:03.080]  но они сделали компилятор, специально там
[02:03:03.080 --> 02:03:05.080]  запушили такую фичу, что если вы в качестве
[02:03:05.080 --> 02:03:07.080]  идентификатора используете смайлик
[02:03:07.080 --> 02:03:09.080]  крабика, эмоджи
[02:03:09.080 --> 02:03:11.080]  то в таком случае раньше
[02:03:11.080 --> 02:03:13.080]  Rasta писал нельзя использовать эмоджи, а теперь он пишет
[02:03:13.080 --> 02:03:15.080]  ferris нельзя использовать как идентификатор
[02:03:15.080 --> 02:03:17.080]  ferris это если что
[02:03:17.080 --> 02:03:19.080]  москот языка, это то что вы видите
[02:03:19.080 --> 02:03:21.080]  в чате курса у нас эти крабики
[02:03:21.080 --> 02:03:23.080]  которые танцуют в кружке
[02:03:23.080 --> 02:03:25.080]  ну то есть вы можете написать там
[02:03:25.080 --> 02:03:27.080]  не знаю, я люблю 1s
[02:03:27.080 --> 02:03:29.080]  на русском
[02:03:29.080 --> 02:03:31.080]  и вот прекрасно быть
[02:03:31.080 --> 02:03:33.080]  я 1s программист
[02:03:33.080 --> 02:03:35.080]  так
[02:03:35.080 --> 02:03:37.080]  ну и наконец for loop
[02:03:37.080 --> 02:03:39.080]  смотрите, у нас есть такой прикольный
[02:03:39.080 --> 02:03:41.080]  синтаксис range
[02:03:41.080 --> 02:03:43.080]  вот у нас и здесь будет
[02:03:43.080 --> 02:03:45.080]  итерироваться от 0 до 10
[02:03:45.080 --> 02:03:47.080]  то есть здесь вот невключительная
[02:03:47.080 --> 02:03:49.080]  не включительная итерация
[02:03:49.080 --> 02:03:51.080]  этот синтаксис специально он создает
[02:03:51.080 --> 02:03:53.080]  range какого-то типа
[02:03:53.080 --> 02:03:55.080]  то есть он там сам выведет
[02:03:55.080 --> 02:03:57.080]  i32, size или что-нибудь еще
[02:03:57.080 --> 02:03:59.080]  конкретно в данном случае здесь будет
[02:03:59.080 --> 02:04:01.080]  i32
[02:04:01.080 --> 02:04:03.080]  если вы допишите еще равно
[02:04:03.080 --> 02:04:05.080]  то в таком случае у вас будет
[02:04:05.080 --> 02:04:07.080]  включительно, то есть второй цикл выведет
[02:04:07.080 --> 02:04:09.080]  все от 0 до 10 включительно
[02:04:09.080 --> 02:04:11.080]  еще вы можете например
[02:04:11.080 --> 02:04:13.080]  захардкодить какие-нибудь
[02:04:13.080 --> 02:04:15.080]  массивы
[02:04:15.080 --> 02:04:17.080]  от 1 до 4
[02:04:17.080 --> 02:04:19.080]  и выводить
[02:04:19.080 --> 02:04:21.080]  то есть также можно например итерироваться
[02:04:21.080 --> 02:04:23.080]  по вектору, еще сейчас увидим slice
[02:04:23.080 --> 02:04:25.080]  и подобным еще
[02:04:25.080 --> 02:04:27.080]  так
[02:04:27.080 --> 02:04:29.080]  потом есть for loop
[02:04:29.080 --> 02:04:31.080]  значит так
[02:04:31.080 --> 02:04:33.080]  for loop
[02:04:33.080 --> 02:04:35.080]  это по векторам собственно example
[02:04:35.080 --> 02:04:37.080]  как это можно сделать
[02:04:37.080 --> 02:04:39.080]  ну вот мы создаем вектор это
[02:04:39.080 --> 02:04:41.080]  1,2,3,4 и вот мы здесь итерируемся
[02:04:41.080 --> 02:04:43.080]  по нему, по ссылке
[02:04:43.080 --> 02:04:45.080]  а потом дальше мы
[02:04:45.080 --> 02:04:47.080]  итерируемся по вектору еще раз
[02:04:47.080 --> 02:04:49.080]  он выведет то же самое, но разница в том
[02:04:49.080 --> 02:04:51.080]  что вот в этом вот случае
[02:04:51.080 --> 02:04:53.080]  мы moving вектор в интерцикла
[02:04:53.080 --> 02:04:55.080]  мы сейчас разберемся
[02:04:55.080 --> 02:04:57.080]  что такое boring
[02:04:57.080 --> 02:04:59.080]  я просто заранее говорю, что можно написать ссылку
[02:04:59.080 --> 02:05:01.080]  mute ссылку
[02:05:01.080 --> 02:05:03.080]  или просто вот
[02:05:03.080 --> 02:05:05.080]  писать по значению
[02:05:05.080 --> 02:05:07.080]  то есть это все нормальная вещь
[02:05:09.080 --> 02:05:11.080]  так и очень прекрасная такая фича
[02:05:11.080 --> 02:05:13.080]  rasta, которую вы наверняка полюбите
[02:05:13.080 --> 02:05:15.080]  в расте есть янамы
[02:05:15.080 --> 02:05:17.080]  янам
[02:05:17.080 --> 02:05:19.080]  ну вот смотрите у нас есть first, second, third
[02:05:19.080 --> 02:05:21.080]  и так далее, какой-то янамчик
[02:05:23.080 --> 02:05:25.080]  ну и второй янамчик
[02:05:25.080 --> 02:05:27.080]  которому мы даже смотрите объявили
[02:05:27.080 --> 02:05:29.080]  даже template, то есть мы можем конечно
[02:05:29.080 --> 02:05:31.080]  не объявлять их, можем объявлять
[02:05:31.080 --> 02:05:33.080]  и в скобочках написали
[02:05:33.080 --> 02:05:35.080]  что из себя представляет
[02:05:35.080 --> 02:05:37.080]  вариант этого янума
[02:05:37.080 --> 02:05:39.080]  то есть это по сути уже будут какие-то типы
[02:05:41.080 --> 02:05:43.080]  вот и снизу я создаю x, который
[02:05:43.080 --> 02:05:45.080]  my-yenam-first
[02:05:45.080 --> 02:05:47.080]  и y, который
[02:05:47.080 --> 02:05:49.080]  my-yenam-first
[02:05:49.080 --> 02:05:51.080]  я просто написал явно, что
[02:05:51.080 --> 02:05:53.080]  чтобы иметь тип my-yenam
[02:05:53.080 --> 02:05:55.080]  значение конкретно my-yenam-first
[02:05:57.080 --> 02:05:59.080]  ну и z это соответственно
[02:05:59.080 --> 02:06:01.080]  создание другого янама, который
[02:06:01.080 --> 02:06:03.080]  из себя представляет какое-то чиселка
[02:06:03.080 --> 02:06:05.080]  и дальше
[02:06:05.080 --> 02:06:07.080]  ту самую структуру q-example, которая у нас
[02:06:07.080 --> 02:06:09.080]  template-ная, мы
[02:06:09.080 --> 02:06:11.080]  инициализируем и пихаем внутрь янам
[02:06:11.080 --> 02:06:13.080]  в плане
[02:06:13.080 --> 02:06:15.080]  ну на самом деле
[02:06:15.080 --> 02:06:17.080]  раст по получению не дает циферки
[02:06:21.080 --> 02:06:23.080]  по получению раст не дает никаких циферок
[02:06:23.080 --> 02:06:25.080]  на это все, можно конечно написать
[02:06:25.080 --> 02:06:27.080]  first равняется один секунд, равняется два
[02:06:27.080 --> 02:06:29.080]  third равняется три, то есть конкретное значение
[02:06:29.080 --> 02:06:31.080]  но раст по получению
[02:06:31.080 --> 02:06:33.080]  просто мы у янам делаем
[02:06:33.080 --> 02:06:35.080]  это все
[02:06:35.080 --> 02:06:37.080]  потому что на самом деле это не структура
[02:06:37.080 --> 02:06:39.080]  это штука, которая
[02:06:39.080 --> 02:06:41.080]  может принимать одно из возможных
[02:06:41.080 --> 02:06:43.080]  значений
[02:06:43.080 --> 02:06:45.080]  то есть в конкретном данном случае это либо
[02:06:45.080 --> 02:06:47.080]  tuple-i32, либо tuple-u64
[02:06:47.080 --> 02:06:49.080]  example-t
[02:06:49.080 --> 02:06:51.080]  янам примет значение
[02:06:51.080 --> 02:06:53.080]  ну и там он умеет
[02:06:53.080 --> 02:06:55.080]  внутри определять, какой он
[02:06:55.080 --> 02:06:57.080]  какой-то значение
[02:06:57.080 --> 02:06:59.080]  ну и там он умеет
[02:06:59.080 --> 02:07:01.080]  определять значение
[02:07:01.080 --> 02:07:03.080]  ну и там он умеет
[02:07:03.080 --> 02:07:05.080]  он умеет внутри определять
[02:07:05.080 --> 02:07:07.080]  какое он сейчас именно значение имеет
[02:07:07.080 --> 02:07:09.080]  ну какой вариант у него
[02:07:11.080 --> 02:07:13.080]  это одновременно юнион и янам
[02:07:13.080 --> 02:07:15.080]  мы сейчас сравним
[02:07:19.080 --> 02:07:21.080]  после i32
[02:07:21.080 --> 02:07:23.080]  это тоже tuple будет
[02:07:27.080 --> 02:07:29.080]  дело в том, что это специальный синтакт
[02:07:29.080 --> 02:07:31.080]  так работает
[02:07:33.080 --> 02:07:35.080]  если что
[02:07:41.080 --> 02:07:43.080]  если бы мы хотели что
[02:07:45.080 --> 02:07:47.080]  если вы захотите
[02:07:47.080 --> 02:07:49.080]  обратиться к первому элементу
[02:07:49.080 --> 02:07:51.080]  то напишите
[02:07:51.080 --> 02:07:53.080]  допустим у вас
[02:07:53.080 --> 02:07:55.080]  z это one more yinam zwei
[02:07:57.080 --> 02:07:59.080]  если вы захотите обратиться к первому элементу
[02:07:59.080 --> 02:08:01.080]  то напишите z.0
[02:08:01.080 --> 02:08:03.080]  ну и точно так же
[02:08:03.080 --> 02:08:05.080]  если бы это был ein
[02:08:05.080 --> 02:08:07.080]  я имею ввиду, что
[02:08:07.080 --> 02:08:09.080]  ein это tuple или нет?
[02:08:09.080 --> 02:08:11.080]  ein это tuple
[02:08:11.080 --> 02:08:13.080]  к нулевому элементу нужно обращаться
[02:08:13.080 --> 02:08:15.080]  но чаще всего этим как tuple
[02:08:15.080 --> 02:08:17.080]  мне конечно не пользуется
[02:08:17.080 --> 02:08:19.080]  сейчас увидим как это делается
[02:08:19.080 --> 02:08:21.080]  наконец-то мы дошли до того, чтобы
[02:08:21.080 --> 02:08:23.080]  я вас испугал опшеном когда-то
[02:08:23.080 --> 02:08:25.080]  в начале лекции, вот он как выглядит
[02:08:25.080 --> 02:08:27.080]  очень-очень простая структурка, но при этом столько мощи дает
[02:08:27.080 --> 02:08:29.080]  они предназначены
[02:08:29.080 --> 02:08:31.080]  для error handling
[02:08:31.080 --> 02:08:33.080]  преимущественно
[02:08:33.080 --> 02:08:35.080]  например, если вы в векторе хотите
[02:08:35.080 --> 02:08:37.080]  взять какой-то элемент
[02:08:37.080 --> 02:08:39.080]  по индексу
[02:08:39.080 --> 02:08:41.080]  если у вас индекс выходит за рамки
[02:08:41.080 --> 02:08:43.080]  то вы хотите наверно
[02:08:43.080 --> 02:08:45.080]  вернуть что-то нормальное
[02:08:45.080 --> 02:08:47.080]  то есть сказать, что нет значения
[02:08:47.080 --> 02:08:49.080]  или если есть само значение
[02:08:49.080 --> 02:08:51.080]  вот опшен говорит, что у вас либо
[02:08:51.080 --> 02:08:53.080]  какое-то значение, либо ничего
[02:08:53.080 --> 02:08:55.080]  если вы знакомы с функциональными языками
[02:08:55.080 --> 02:08:57.080]  то там вы могли знать про maybe
[02:08:57.080 --> 02:08:59.080]  maybe как раз там
[02:08:59.080 --> 02:09:01.080]  ну и есть еще
[02:09:01.080 --> 02:09:03.080]  result, result это
[02:09:03.080 --> 02:09:05.080]  просто наперед показывают, есть такая штука
[02:09:05.080 --> 02:09:07.080]  которая может либо иметь значение
[02:09:07.080 --> 02:09:09.080]  либо типа ошибки
[02:09:09.080 --> 02:09:11.080]  например, если вы читаете
[02:09:11.080 --> 02:09:13.080]  из какого-нибудь файлика
[02:09:13.080 --> 02:09:15.080]  то вы можете вернуть, например, либо
[02:09:15.080 --> 02:09:17.080]  прочитанные байты, либо
[02:09:17.080 --> 02:09:19.080]  код ошибки
[02:09:19.080 --> 02:09:21.080]  то есть вы просто посмотрите, что из этого
[02:09:21.080 --> 02:09:23.080]  получили, ok или error
[02:09:23.080 --> 02:09:25.080]  а то, что вот как раз
[02:09:25.080 --> 02:09:27.080]  включается про runtime было
[02:09:27.080 --> 02:09:29.080]  то, что мы можем все
[02:09:29.080 --> 02:09:31.080]  заменить, все exceptions
[02:09:31.080 --> 02:09:33.080]  result
[02:09:33.080 --> 02:09:35.080]  в плане не сейчас
[02:09:35.080 --> 02:09:37.080]  в начале лекции говорили, что это не runtime
[02:09:37.080 --> 02:09:39.080]  за исключением того, что
[02:09:39.080 --> 02:09:41.080]  когда мы используем банки
[02:09:41.080 --> 02:09:43.080]  мы вокруг них
[02:09:43.080 --> 02:09:45.080]  добавляем runtime
[02:09:45.080 --> 02:09:47.080]  ну да, там же stack unwinding это точно
[02:09:47.080 --> 02:09:49.080]  так же как в плюсах, мы идем в ноль
[02:09:49.080 --> 02:09:51.080]  то есть ну
[02:09:51.080 --> 02:09:53.080]  до самого конца, до мейна
[02:09:53.080 --> 02:09:55.080]  и там мейн сам нужно обернуть
[02:09:55.080 --> 02:09:57.080]  для того, чтобы словить этот unwinding
[02:09:57.080 --> 02:09:59.080]  вывести пользователи сообщения и уже
[02:09:59.080 --> 02:10:01.080]  выйти с ошибки
[02:10:01.080 --> 02:10:03.080]  соответственно можно все банки заменить на обработку
[02:10:03.080 --> 02:10:05.080]  результатов
[02:10:05.080 --> 02:10:07.080]  ну да, да, ну как раз для того предназначено
[02:10:07.080 --> 02:10:09.080]  чтобы грамотно обрабатывать ошибки
[02:10:09.080 --> 02:10:11.080]  то есть если нам выпала
[02:10:11.080 --> 02:10:13.080]  ошибка, чтобы мы могли, например, ее красиво
[02:10:13.080 --> 02:10:15.080]  проигнорировать, либо если ошибка
[02:10:15.080 --> 02:10:17.080]  там еще что-то сделать
[02:10:17.080 --> 02:10:19.080]  это будет очень хорошо видно, наверное, дальше
[02:10:19.080 --> 02:10:21.080]  и плюс когда вы будете решать домашнее задание
[02:10:21.080 --> 02:10:23.080]  как это работает
[02:10:23.080 --> 02:10:25.080]  так
[02:10:25.080 --> 02:10:27.080]  match это, наверное
[02:10:27.080 --> 02:10:29.080]  это единственный способ
[02:10:29.080 --> 02:10:31.080]  за счет которого вы можете выяснить
[02:10:31.080 --> 02:10:33.080]  о какой же все-таки сейчас текущее значение
[02:10:33.080 --> 02:10:35.080]  у янама
[02:10:35.080 --> 02:10:37.080]  например, если вы захотите узнать
[02:10:37.080 --> 02:10:39.080]  first ли значение у янама, то вы можете
[02:10:39.080 --> 02:10:41.080]  в будущем сможете воспользоваться еще if
[02:10:41.080 --> 02:10:43.080]  сейчас узнаем как это
[02:10:43.080 --> 02:10:45.080]  либо match
[02:10:45.080 --> 02:10:47.080]  вот
[02:10:47.080 --> 02:10:49.080]  как это работает, смотрите
[02:10:49.080 --> 02:10:51.080]  мы матчем X
[02:10:51.080 --> 02:10:53.080]  он, если он
[02:10:53.080 --> 02:10:55.080]  на янам first, то мы вводим first
[02:10:55.080 --> 02:10:57.080]  если second, то там
[02:10:57.080 --> 02:10:59.080]  выводим числа от 0 до 4 и еще
[02:10:59.080 --> 02:11:01.080]  second сообщение
[02:11:01.080 --> 02:11:03.080]  и потом, смотрите, есть такой специальный значок
[02:11:03.080 --> 02:11:05.080]  который мы уже встречали, underscope
[02:11:05.080 --> 02:11:07.080]  нижнее подчеркивание
[02:11:07.080 --> 02:11:09.080]  он матчит вообще все
[02:11:09.080 --> 02:11:11.080]  то есть раз, то он буквально
[02:11:11.080 --> 02:11:13.080]  просто берет такой и проверяет
[02:11:13.080 --> 02:11:15.080]  каждое значение по отдельности
[02:11:15.080 --> 02:11:17.080]  но матч только с янамами работает
[02:11:17.080 --> 02:11:19.080]  или с произвольными типами?
[02:11:19.080 --> 02:11:21.080]  с произвольными типами, даже с sentami работает
[02:11:21.080 --> 02:11:23.080]  сейчас посмотрим
[02:11:23.080 --> 02:11:25.080]  а он останавливается, когда
[02:11:25.080 --> 02:11:27.080]  находится в падении?
[02:11:27.080 --> 02:11:29.080]  да, находится в падении, там не нужно как в плюсах
[02:11:29.080 --> 02:11:31.080]  switch a break писать
[02:11:31.080 --> 02:11:33.080]  он уже все знает раз
[02:11:33.080 --> 02:11:35.080]  то есть вот нижнее подчеркивание
[02:11:35.080 --> 02:11:37.080]  это только
[02:11:37.080 --> 02:11:39.080]  если он выше всего
[02:11:39.080 --> 02:11:41.080]  да, читайте, это placeholder
[02:11:41.080 --> 02:11:43.080]  для дефолтного значения, то есть все остальное
[02:11:43.080 --> 02:11:45.080]  тогда правда же, что мы можем
[02:11:45.080 --> 02:11:47.080]  все что угодно, вот так вот читать
[02:11:47.080 --> 02:11:49.080]  будут матчи, если у нас x
[02:11:49.080 --> 02:11:51.080]  не маги нам
[02:11:51.080 --> 02:11:53.080]  что бы мы могли больше передать
[02:11:53.080 --> 02:11:55.080]  а если это не так
[02:11:55.080 --> 02:11:57.080]  ну раз, это проверит на уровне
[02:11:57.080 --> 02:11:59.080]  системы типов и скажет, что нет
[02:11:59.080 --> 02:12:01.080]  вы что-то не то матчите, более того
[02:12:01.080 --> 02:12:03.080]  матч, он проверяет то
[02:12:03.080 --> 02:12:05.080]  что вы действительно поматчили всевозможные
[02:12:05.080 --> 02:12:07.080]  значения, то есть
[02:12:07.080 --> 02:12:09.080]  если у вас там будет second, third
[02:12:09.080 --> 02:12:11.080]  fourth и так далее, то
[02:12:11.080 --> 02:12:13.080]  если вы удалите вот это вот дефолтное значение
[02:12:13.080 --> 02:12:15.080]  то в таком случае вам расскажут
[02:12:15.080 --> 02:12:17.080]  а вы еще два значения как-то не заматчили
[02:12:17.080 --> 02:12:19.080]  и у вас в коде
[02:12:19.080 --> 02:12:21.080]  может быть, не знаю, уб или что-нибудь такое
[02:12:21.080 --> 02:12:23.080]  если другое
[02:12:23.080 --> 02:12:25.080]  код просто first
[02:12:25.080 --> 02:12:27.080]  в данном случае просто first
[02:12:27.080 --> 02:12:29.080]  ну можно поиграться там, написать second
[02:12:29.080 --> 02:12:31.080]  например, или что-то еще такое
[02:12:31.080 --> 02:12:33.080]  то есть
[02:12:33.080 --> 02:12:35.080]  раз одновременно
[02:12:35.080 --> 02:12:37.080]  проверяет, что
[02:12:37.080 --> 02:12:39.080]  все что мы указали
[02:12:39.080 --> 02:12:41.080]  мы указали
[02:12:41.080 --> 02:12:43.080]  вместо Maya Nam quest
[02:12:43.080 --> 02:12:45.080]  что она тоже часть того
[02:12:45.080 --> 02:12:47.080]  типа, что имеется
[02:12:47.080 --> 02:12:49.080]  ну он просто знает, где матч, что он матчит
[02:12:49.080 --> 02:12:51.080]  Maya Nam
[02:12:51.080 --> 02:12:53.080]  то есть, соответственно, он ожидает
[02:12:53.080 --> 02:12:55.080]  увидеть всевозможные варианты Maya Nam
[02:12:55.080 --> 02:12:57.080]  давайте чуть-чуть подробнее
[02:12:57.080 --> 02:12:59.080]  про Underscope поговорим
[02:12:59.080 --> 02:13:01.080]  он называется еще
[02:13:01.080 --> 02:13:03.080]  забыл как раз такое слово, замечательный
[02:13:03.080 --> 02:13:05.080]  Weald Card, он матчит все
[02:13:05.080 --> 02:13:07.080]  вот смотрите, вы конечно не знаете
[02:13:07.080 --> 02:13:09.080]  что такое Collect еще
[02:13:09.080 --> 02:13:11.080]  ну вообще эта вот штука
[02:13:11.080 --> 02:13:13.080]  ну вот от 0 до 10
[02:13:13.080 --> 02:13:15.080]  есть range, потом вы его захотите
[02:13:15.080 --> 02:13:17.080]  заколлектить, Rust может это делать хоть даже в hashset
[02:13:17.080 --> 02:13:19.080]  вы что хотите вообще
[02:13:19.080 --> 02:13:21.080]  то есть там
[02:13:21.080 --> 02:13:23.080]  главное указать им
[02:13:23.080 --> 02:13:25.080]  во что он будет коллектить
[02:13:25.080 --> 02:13:27.080]  формально
[02:13:27.080 --> 02:13:29.080]  то есть, забегая наперед
[02:13:29.080 --> 02:13:31.080]  говорю, что там нужен тоже trade
[02:13:31.080 --> 02:13:33.080]  другой он называется fromiter
[02:13:33.080 --> 02:13:35.080]  для того, чтобы Collect работал
[02:13:35.080 --> 02:13:37.080]  в общем-то нам нужно указать
[02:13:37.080 --> 02:13:39.080]  что мы конкретно в вектор хотим собрать
[02:13:39.080 --> 02:13:41.080]  все эти значения
[02:13:41.080 --> 02:13:43.080]  и обратить внимание, я указал что вектор
[02:13:43.080 --> 02:13:45.080]  но не указал какой тип
[02:13:45.080 --> 02:13:47.080]  и раз такой понимает, ага
[02:13:47.080 --> 02:13:49.080]  он мне дал Underscope, значит мне нужно самому
[02:13:49.080 --> 02:13:51.080]  что-то с этим сделать
[02:13:51.080 --> 02:13:53.080]  и он после того, как я сделал
[02:13:53.080 --> 02:13:55.080]  век push 42.u64
[02:13:55.080 --> 02:13:57.080]  он понял, ага, значит он хочет вектор u64
[02:13:57.080 --> 02:13:59.080]  и сам вывел тип
[02:13:59.080 --> 02:14:01.080]  а если бы мы не указали
[02:14:01.080 --> 02:14:03.080]  эти скопки
[02:14:03.080 --> 02:14:05.080]  да, он бы сказал
[02:14:05.080 --> 02:14:07.080]  что-то такого типа нет
[02:14:07.080 --> 02:14:09.080]  укажите, пожалуйста, там template
[02:14:09.080 --> 02:14:11.080]  да, еще
[02:14:11.080 --> 02:14:13.080]  если вы будете
[02:14:13.080 --> 02:14:15.080]  Unused variable делать
[02:14:15.080 --> 02:14:17.080]  тогда Rust
[02:14:17.080 --> 02:14:19.080]  нижнее подчеркивание x
[02:14:19.080 --> 02:14:21.080]  оно говорит о том, что x не используется
[02:14:21.080 --> 02:14:23.080]  и при этом
[02:14:23.080 --> 02:14:25.080]  Rust скажет вам, что
[02:14:25.080 --> 02:14:27.080]  без Underscope он выдаст warning
[02:14:27.080 --> 02:14:29.080]  а с Underscope варнига не будет
[02:14:29.080 --> 02:14:31.080]  все нормально, не используется x
[02:14:31.080 --> 02:14:33.080]  и ладно
[02:14:33.080 --> 02:14:35.080]  то есть это способ пометить переменную, что я ее дальше не использую
[02:14:35.080 --> 02:14:37.080]  хоть она и объявлена
[02:14:37.080 --> 02:14:39.080]  полезно иногда функция бывает
[02:14:41.080 --> 02:14:43.080]  еще он может несколько
[02:14:43.080 --> 02:14:45.080]  одновременно match
[02:14:45.080 --> 02:14:47.080]  объектов match
[02:14:47.080 --> 02:14:49.080]  ну вот, смотрите, я написал такой tuple
[02:14:49.080 --> 02:14:51.080]  по факту он конечно все еще один объект match
[02:14:51.080 --> 02:14:53.080]  то есть он match один tuple
[02:14:53.080 --> 02:14:55.080]  который имеет тип tuple из
[02:14:55.080 --> 02:14:57.080]  one more enum и запятая my enum
[02:14:57.080 --> 02:14:59.080]  да
[02:14:59.080 --> 02:15:01.080]  но для нас
[02:15:01.080 --> 02:15:03.080]  выглядит так, будто мы матчим два элемента
[02:15:03.080 --> 02:15:05.080]  и вот то, что называется pattern matching
[02:15:05.080 --> 02:15:07.080]  смотрите
[02:15:07.080 --> 02:15:09.080]  я написал в скобочках
[02:15:09.080 --> 02:15:11.080]  что-то там amx
[02:15:11.080 --> 02:15:13.080]  и смотрите, дело в том, что
[02:15:13.080 --> 02:15:15.080]  я здесь вот знаю
[02:15:15.080 --> 02:15:17.080]  что вот это вот x
[02:15:17.080 --> 02:15:19.080]  я внутри этого скобка
[02:15:19.080 --> 02:15:21.080]  буду иметь эту переменную
[02:15:21.080 --> 02:15:23.080]  он поматчит то, что
[02:15:23.080 --> 02:15:25.080]  находится внутри x, а точнее
[02:15:25.080 --> 02:15:27.080]  двойку, то есть я буду здесь иметь 2
[02:15:29.080 --> 02:15:31.080]  так, я думаю
[02:15:31.080 --> 02:15:33.080]  так, да, давайте попробую еще раз
[02:15:33.080 --> 02:15:35.080]  ну и мы даем
[02:15:35.080 --> 02:15:37.080]  вот такой вот pattern, что типа я
[02:15:37.080 --> 02:15:39.080]  ожидаю увидеть что-то вида one more enum
[02:15:39.080 --> 02:15:41.080]  amx, my enum first
[02:15:41.080 --> 02:15:43.080]  такой вот tuple ожидаю увидеть
[02:15:43.080 --> 02:15:45.080]  если этот tuple подходит
[02:15:45.080 --> 02:15:47.080]  то такой раз так, а ну значит я вот этим вот переменным
[02:15:47.080 --> 02:15:49.080]  внутри, конкретно вот эта переменная
[02:15:49.080 --> 02:15:51.080]  называется x, и я присвою значение
[02:15:51.080 --> 02:15:53.080]  двойке, например, ну вот у нас
[02:15:53.080 --> 02:15:55.080]  просто пример сверху с двойкой
[02:15:55.080 --> 02:15:57.080]  и он соответственно здесь вот будет x
[02:15:57.080 --> 02:15:59.080]  ну лучше было бы, если бы я здесь написал
[02:15:59.080 --> 02:16:01.080]  не фоллоу, а какой-нибудь там, в главной скобочке x
[02:16:01.080 --> 02:16:03.080]  тогда бы этот код выводил двойку
[02:16:05.080 --> 02:16:07.080]  в том, что нам доступно значение 2
[02:16:07.080 --> 02:16:09.080]  внутри матча
[02:16:09.080 --> 02:16:11.080]  внутри вот этого
[02:16:11.080 --> 02:16:13.080]  ну то есть там
[02:16:13.080 --> 02:16:15.080]  не нужно нам опять после этого
[02:16:15.080 --> 02:16:17.080]  то есть как бы обобщение
[02:16:17.080 --> 02:16:19.080]  можно сделать обобщение
[02:16:21.080 --> 02:16:23.080]  с чем мы сравнивались
[02:16:23.080 --> 02:16:25.080]  да, ну это просто
[02:16:25.080 --> 02:16:27.080]  то, с чем мы сравниваем, вот это вот это типа
[02:16:27.080 --> 02:16:29.080]  паттерн называется слева
[02:16:29.080 --> 02:16:31.080]  паттерн такой вот, мы ожидаем его увидеть
[02:16:31.080 --> 02:16:33.080]  если мы его видим
[02:16:33.080 --> 02:16:35.080]  он пропускает его
[02:16:35.080 --> 02:16:37.080]  и запускает
[02:16:37.080 --> 02:16:39.080]  и там внутри
[02:16:41.080 --> 02:16:43.080]  вот нет, кстати говоря, вот здесь вот
[02:16:43.080 --> 02:16:45.080]  x будет как раз шедуинг внутри
[02:16:49.080 --> 02:16:51.080]  сейчас подождите
[02:16:51.080 --> 02:16:53.080]  какой предыдущий пример?
[02:16:53.080 --> 02:16:55.080]  там, где у нас матч был
[02:16:55.080 --> 02:16:57.080]  вот это
[02:16:57.080 --> 02:16:59.080]  вот тут и шедуста
[02:16:59.080 --> 02:17:01.080]  внутри
[02:17:01.080 --> 02:17:03.080]  так в плане, он нигде не используется
[02:17:03.080 --> 02:17:05.080]  а если бы использовался
[02:17:05.080 --> 02:17:07.080]  например там в цикле
[02:17:07.080 --> 02:17:09.080]  нет, конкретно его здесь нельзя было бы
[02:17:09.080 --> 02:17:11.080]  использовать, потому что
[02:17:11.080 --> 02:17:13.080]  матч, на самом деле, вот здесь вот
[02:17:13.080 --> 02:17:15.080]  тоже передача владения x
[02:17:15.080 --> 02:17:17.080]  то есть мы еще
[02:17:17.080 --> 02:17:19.080]  пока не знаем, что такое владение
[02:17:19.080 --> 02:17:21.080]  но
[02:17:21.080 --> 02:17:23.080]  x передает владение
[02:17:23.080 --> 02:17:25.080]  поэтому, на самом деле, он не будет доступен
[02:17:25.080 --> 02:17:27.080]  он будет жить где-то
[02:17:27.080 --> 02:17:29.080]  внутри матча
[02:17:29.080 --> 02:17:31.080]  а если бы написали ссылку на x, то по-моему
[02:17:31.080 --> 02:17:33.080]  работали бы
[02:17:35.080 --> 02:17:37.080]  так
[02:17:37.080 --> 02:17:39.080]  и вот
[02:17:39.080 --> 02:17:41.080]  возвращаясь к этому примеру, дальше вы увидите
[02:17:41.080 --> 02:17:43.080]  я могу точно также андерскопом
[02:17:43.080 --> 02:17:45.080]  давайте о чем-нибудь поигнори
[02:17:45.080 --> 02:17:47.080]  если бы у меня на первом месте был 2i
[02:17:47.080 --> 02:17:49.080]  что-то там, то вот это вот что-то там
[02:17:49.080 --> 02:17:51.080]  я просто игнорирую что там
[02:17:51.080 --> 02:17:53.080]  и второй аргумент тоже игнорирую
[02:17:55.080 --> 02:17:57.080]  а это просто название какое-то
[02:17:57.080 --> 02:17:59.080]  это я сам бинжу такое название
[02:17:59.080 --> 02:18:01.080]  говорю, вот у меня такой паттерн
[02:18:01.080 --> 02:18:03.080]  я его уже даю увидеть
[02:18:03.080 --> 02:18:05.080]  если он соответствует, тогда вот этим вот переменным
[02:18:05.080 --> 02:18:07.080]  пред свой нужное значение
[02:18:07.080 --> 02:18:09.080]  и зайди с ними вот сюда
[02:18:09.080 --> 02:18:11.080]  как-то так
[02:18:11.080 --> 02:18:13.080]  а чтобы мы его использовали потом
[02:18:13.080 --> 02:18:15.080]  когда он
[02:18:15.080 --> 02:18:17.080]  ну это
[02:18:17.080 --> 02:18:19.080]  это просто нам очень удобно
[02:18:19.080 --> 02:18:21.080]  мы можем деструктуризовать и просто посмотреть
[02:18:21.080 --> 02:18:23.080]  что внутри сидит
[02:18:23.080 --> 02:18:25.080]  здесь вот 2
[02:18:25.080 --> 02:18:27.080]  здесь вот 2
[02:18:29.080 --> 02:18:31.080]  здесь вот если бы x был
[02:18:31.080 --> 02:18:33.080]  2 и что-то там
[02:18:33.080 --> 02:18:35.080]  то в таком случае здесь было бы значение
[02:18:35.080 --> 02:18:37.080]  2 и что-то там, а вот это мы бы игнорировали
[02:18:37.080 --> 02:18:39.080]  вот это я бы мог написать
[02:18:39.080 --> 02:18:41.080]  здесь b и c, тогда бы они тоже были бы доступны
[02:18:41.080 --> 02:18:43.080]  я бы получил b и c
[02:18:43.080 --> 02:18:45.080]  в случае x
[02:18:45.080 --> 02:18:47.080]  а этот был шэдинг
[02:18:47.080 --> 02:18:49.080]  ну да, здесь будет шэдинг
[02:18:49.080 --> 02:18:51.080]  а хотя стойте
[02:18:51.080 --> 02:18:53.080]  здесь мув тоже
[02:18:53.080 --> 02:18:55.080]  здесь мы же муваем тюп
[02:18:55.080 --> 02:18:57.080]  поэтому вот это вот уже
[02:18:57.080 --> 02:18:59.080]  другой x в общем-то
[02:18:59.080 --> 02:19:01.080]  он по часть того x, а ну другой
[02:19:03.080 --> 02:19:05.080]  так
[02:19:05.080 --> 02:19:07.080]  примерно так
[02:19:07.080 --> 02:19:09.080]  мы можем мачить числа
[02:19:09.080 --> 02:19:11.080]  кроме намов
[02:19:11.080 --> 02:19:13.080]  вот например единичка
[02:19:13.080 --> 02:19:15.080]  и еще можем сразу несколько значений написать
[02:19:15.080 --> 02:19:17.080]  например
[02:19:17.080 --> 02:19:19.080]  через or и такие вот
[02:19:19.080 --> 02:19:21.080]  если это или это
[02:19:21.080 --> 02:19:23.080]  тогда вот это
[02:19:23.080 --> 02:19:25.080]  еще можем мачить рейнджи
[02:19:25.080 --> 02:19:27.080]  вот такие вот
[02:19:27.080 --> 02:19:29.080]  ну что-то так
[02:19:31.080 --> 02:19:33.080]  здесь есть вопрос?
[02:19:39.080 --> 02:19:41.080]  значит так, здесь мы мачим
[02:19:41.080 --> 02:19:43.080]  пару
[02:19:43.080 --> 02:19:45.080]  значит
[02:19:45.080 --> 02:19:47.080]  здесь
[02:19:47.080 --> 02:19:49.080]  и как вы можете заметить у нас есть if
[02:19:49.080 --> 02:19:51.080]  еще после этого, то есть мы можем написать
[02:19:51.080 --> 02:19:53.080]  вроде бы два одинаковых
[02:19:53.080 --> 02:19:55.080]  две одинаковых вот здесь значения
[02:19:55.080 --> 02:19:57.080]  но если мы можем еще дополнительно
[02:19:57.080 --> 02:19:59.080]  здесь вот какое-то условие написать
[02:19:59.080 --> 02:20:01.080]  пойдем мы или нет
[02:20:05.080 --> 02:20:07.080]  ух, ну это на самом деле достаточно
[02:20:07.080 --> 02:20:09.080]  тривиально, но такое
[02:20:09.080 --> 02:20:11.080]  типа ручная какая-то работа
[02:20:11.080 --> 02:20:13.080]  написать все строгие правила
[02:20:13.080 --> 02:20:15.080]  как перебрать
[02:20:15.080 --> 02:20:17.080]  он просто проверяет, что при всех возможных значениях
[02:20:17.080 --> 02:20:19.080]  как-то можно
[02:20:19.080 --> 02:20:21.080]  и кстати говоря, если вы например напишете
[02:20:21.080 --> 02:20:23.080]  помачите числой, например вы напишете
[02:20:23.080 --> 02:20:25.080]  матчи 13 и остальные не напишете
[02:20:25.080 --> 02:20:27.080]  то он скажет, что от типа до 13
[02:20:27.080 --> 02:20:29.080]  и от 13 до максимума
[02:20:29.080 --> 02:20:31.080]  от минимума 13 до максимума
[02:20:31.080 --> 02:20:33.080]  у вас рейнджи
[02:20:33.080 --> 02:20:35.080]  как бы нет
[02:20:35.080 --> 02:20:37.080]  их матча и соответственно вы учтите это
[02:20:37.080 --> 02:20:39.080]  то есть раз даже пишет вам
[02:20:39.080 --> 02:20:41.080]  какие вы не учли случай
[02:20:49.080 --> 02:20:51.080]  да, тейфы кстати называются guard
[02:20:51.080 --> 02:20:53.080]  понятно
[02:20:53.080 --> 02:20:55.080]  синий вопрос, но как быстро компилируется?
[02:20:55.080 --> 02:20:57.080]  раз, на самом деле
[02:20:57.080 --> 02:20:59.080]  достаточно медленно компилируется
[02:20:59.080 --> 02:21:01.080]  то есть не вечность конечно
[02:21:01.080 --> 02:21:03.080]  он там на какую-то константу медленнее плюсов
[02:21:03.080 --> 02:21:05.080]  какую-то константу раз
[02:21:05.080 --> 02:21:07.080]  раз, но он
[02:21:07.080 --> 02:21:09.080]  не настолько медленный
[02:21:15.080 --> 02:21:17.080]  в больших проектах сейчас есть проблема
[02:21:17.080 --> 02:21:19.080]  с раз, потому что
[02:21:19.080 --> 02:21:21.080]  у него нет стабильного аби
[02:21:21.080 --> 02:21:23.080]  в больших проектах понятно
[02:21:23.080 --> 02:21:25.080]  но на маленьких вы даже
[02:21:25.080 --> 02:21:27.080]  не заметите разницы
[02:21:27.080 --> 02:21:29.080]  быстро компилируете
[02:21:29.080 --> 02:21:31.080]  на больших, но там да
[02:21:31.080 --> 02:21:33.080]  а вот получается x и y это не типы
[02:21:33.080 --> 02:21:35.080]  да, переменные
[02:21:35.080 --> 02:21:37.080]  то есть условно переменные
[02:21:37.080 --> 02:21:39.080]  ну да
[02:21:39.080 --> 02:21:41.080]  тут можно было бы написать
[02:21:41.080 --> 02:21:43.080]  new x например
[02:21:43.080 --> 02:21:45.080]  а если бы у нас был тип x
[02:21:45.080 --> 02:21:47.080]  строк x
[02:21:47.080 --> 02:21:49.080]  где-то сверху
[02:21:49.080 --> 02:21:51.080]  был бы шедуинг
[02:21:51.080 --> 02:21:53.080]  то есть тогда был бы в другом
[02:21:53.080 --> 02:21:55.080]  сколке какой-то другой x
[02:21:55.080 --> 02:21:57.080]  а в чем разница?
[02:21:57.080 --> 02:21:59.080]  в третьем случае мы написали x
[02:21:59.080 --> 02:22:01.080]  и нижнее подчеркивание
[02:22:01.080 --> 02:22:03.080]  а мы просто хотим это проигнорировать
[02:22:03.080 --> 02:22:05.080]  ну то есть нам неинтересен y
[02:22:05.080 --> 02:22:07.080]  зачем нам его просто так рассказать
[02:22:07.080 --> 02:22:09.080]  давайте его берем
[02:22:09.080 --> 02:22:11.080]  кстати, если вы напишите y
[02:22:11.080 --> 02:22:13.080]  то вам расскажут, а вы как-то не используете y
[02:22:13.080 --> 02:22:15.080]  давайте вы его поместите вот этим
[02:22:15.080 --> 02:22:17.080]  нижним подчеркиванием
[02:22:17.080 --> 02:22:19.080]  если поместите, то станет хорошо
[02:22:19.080 --> 02:22:21.080]  но еще лучше просто сразу нижним подчеркиванием написать
[02:22:21.080 --> 02:22:23.080]  ну я игнорирую типы значения
[02:22:23.080 --> 02:22:25.080]  там наверное копируют просто
[02:22:25.080 --> 02:22:27.080]  что копируют?
[02:22:27.080 --> 02:22:29.080]  а нет
[02:22:29.080 --> 02:22:31.080]  так
[02:22:35.080 --> 02:22:37.080]  он просто подряд матчит
[02:22:41.080 --> 02:22:43.080]  да
[02:22:43.080 --> 02:22:45.080]  то что он подряд идет
[02:22:45.080 --> 02:22:47.080]  то на что вы можете полагаться
[02:22:47.080 --> 02:22:49.080]  матч это тоже
[02:22:49.080 --> 02:22:51.080]  expression, то есть вы можете вот так
[02:22:51.080 --> 02:22:53.080]  поматчить boolean
[02:22:53.080 --> 02:22:55.080]  boolean, кстати, почему у меня boolean
[02:22:55.080 --> 02:22:57.080]  это 13, это отдельный вопрос
[02:22:57.080 --> 02:22:59.080]  давайте прикинемся
[02:22:59.080 --> 02:23:01.080]  что я написал
[02:23:01.080 --> 02:23:03.080]  нормально
[02:23:03.080 --> 02:23:05.080]  если 13, то вернем 0
[02:23:05.080 --> 02:23:07.080]  дальше если
[02:23:09.080 --> 02:23:11.080]  смотрите
[02:23:11.080 --> 02:23:13.080]  13 если foo
[02:23:13.080 --> 02:23:15.080]  foo это какая-то получается функция
[02:23:15.080 --> 02:23:17.080]  которая возвращает bool
[02:23:17.080 --> 02:23:19.080]  если она true, то выполнется это
[02:23:19.080 --> 02:23:21.080]  если false, то тогда выполнется второе
[02:23:21.080 --> 02:23:23.080]  если мы не 13, то мы пойдем в третью
[02:23:23.080 --> 02:23:25.080]  третью метку
[02:23:25.080 --> 02:23:27.080]  и соответственно у нас x будет
[02:23:27.080 --> 02:23:29.080]  соответствующий значение 0, 1 или 2
[02:23:29.080 --> 02:23:31.080]  конкретно в данном случае
[02:23:31.080 --> 02:23:33.080]  функция foo не определена
[02:23:33.080 --> 02:23:35.080]  я тут ее просто оставил за рамками слайдов
[02:23:35.080 --> 02:23:37.080]  но если foo это просто какая-то структурка
[02:23:37.080 --> 02:23:39.080]  которая возвращает true
[02:23:39.080 --> 02:23:41.080]  функция которая возвращает true, то тогда у нас будет 0
[02:23:41.080 --> 02:23:43.080]  x
[02:23:45.080 --> 02:23:47.080]  так
[02:23:49.080 --> 02:23:51.080]  вот тут такие вот приколы есть
[02:23:51.080 --> 02:23:53.080]  можно игнорировать часть tuple
[02:23:55.080 --> 02:23:57.080]  ну вот у нас есть
[02:23:57.080 --> 02:23:59.080]  какой-то triple
[02:23:59.080 --> 02:24:01.080]  из трех типов
[02:24:01.080 --> 02:24:03.080]  вот мы можем
[02:24:03.080 --> 02:24:05.080]  если у нас первый тип 0
[02:24:05.080 --> 02:24:07.080]  а остальное мы просто как-то назвали
[02:24:07.080 --> 02:24:09.080]  то в таком случае мы говорим
[02:24:09.080 --> 02:24:11.080]  то что первое 0, y какой-то там y и z
[02:24:11.080 --> 02:24:13.080]  а какое-то там z
[02:24:13.080 --> 02:24:15.080]  потом мы можем просто игнорировать
[02:24:15.080 --> 02:24:17.080]  если 1 а все остальное
[02:24:17.080 --> 02:24:19.080]  нам по барабану
[02:24:19.080 --> 02:24:21.080]  то мы просто забываем
[02:24:21.080 --> 02:24:23.080]  вот
[02:24:23.080 --> 02:24:25.080]  ну и все остальные значения
[02:24:25.080 --> 02:24:27.080]  как-то матчем
[02:24:27.080 --> 02:24:29.080]  тут понятно?
[02:24:35.080 --> 02:24:37.080]  вот просто запомните
[02:24:37.080 --> 02:24:39.080]  объявление структурки
[02:24:39.080 --> 02:24:41.080]  потому что даже чуть длиннее
[02:24:41.080 --> 02:24:43.080]  код чем слайд
[02:24:43.080 --> 02:24:45.080]  x это какой-то tuple из двух элементов
[02:24:45.080 --> 02:24:47.080]  и y это
[02:24:47.080 --> 02:24:49.080]  ну какое-то число
[02:24:49.080 --> 02:24:51.080]  мы можем деструктуризовать структурки
[02:24:51.080 --> 02:24:53.080]  то есть даже паттерн матчем
[02:24:53.080 --> 02:24:55.080]  по структуркам
[02:24:55.080 --> 02:24:57.080]  вот мы матчем
[02:24:57.080 --> 02:24:59.080]  если x это 1, b
[02:24:59.080 --> 02:25:01.080]  и какой-то там y, то мы можем вывести
[02:25:01.080 --> 02:25:03.080]  например вот x это что-то
[02:25:03.080 --> 02:25:05.080]  ну x это 1, b это что-то
[02:25:05.080 --> 02:25:07.080]  и y это что-то
[02:25:07.080 --> 02:25:09.080]  ну и потом тоже самое
[02:25:09.080 --> 02:25:11.080]  можем сделать
[02:25:11.080 --> 02:25:13.080]  ну в обратном порядке
[02:25:13.080 --> 02:25:15.080]  так тоже можно
[02:25:15.080 --> 02:25:17.080]  если y это 2, x это какой-то там i
[02:25:17.080 --> 02:25:19.080]  то в таком случае
[02:25:19.080 --> 02:25:21.080]  сделать какой-то еще
[02:25:21.080 --> 02:25:23.080]  и можем проигнорировать сейчас значения
[02:25:23.080 --> 02:25:25.080]  вообще
[02:25:27.080 --> 02:25:29.080]  там у y 2
[02:25:29.080 --> 02:25:31.080]  x и ну у нас же x вроде
[02:25:31.080 --> 02:25:33.080]  tuple
[02:25:33.080 --> 02:25:35.080]  у нас же x tuple
[02:25:35.080 --> 02:25:37.080]  ну да tuple
[02:25:37.080 --> 02:25:39.080]  ну у нас tuple может быть i
[02:25:39.080 --> 02:25:41.080]  и 0 и 2
[02:25:41.080 --> 02:25:43.080]  и 1 будет
[02:25:43.080 --> 02:25:45.080]  то есть это прям уже t будет, а не 2 отдельных
[02:25:45.080 --> 02:25:47.080]  сейчас
[02:25:49.080 --> 02:25:51.080]  b это просто паттерн матчем
[02:25:51.080 --> 02:25:53.080]  я говорю, что давайте 2 элемент tuple в x
[02:25:53.080 --> 02:25:55.080]  будет называться b
[02:25:55.080 --> 02:25:57.080]  я вот хочу его дальше вывести
[02:25:57.080 --> 02:25:59.080]  то есть мы можем запринять
[02:25:59.080 --> 02:26:01.080]  вообще любой объект
[02:26:01.080 --> 02:26:03.080]  кстати хороший вопрос
[02:26:03.080 --> 02:26:05.080]  запринять мы можем
[02:26:05.080 --> 02:26:07.080]  не совсем любой объект
[02:26:07.080 --> 02:26:09.080]  а тот, который имплементирует соответствующие
[02:26:09.080 --> 02:26:11.080]  трейты, ну я не буду
[02:26:11.080 --> 02:26:13.080]  наверное подробно останавливаться
[02:26:13.080 --> 02:26:15.080]  например, какие-то простые типа
[02:26:15.080 --> 02:26:17.080]  tuple, ну типа tuple
[02:26:17.080 --> 02:26:19.080]  вы можете вот так вот выводить
[02:26:19.080 --> 02:26:21.080]  а если вектора tuple, то вы можете вот так вот
[02:26:21.080 --> 02:26:23.080]  их выводить
[02:26:23.080 --> 02:26:25.080]  две точки вопроса
[02:26:25.080 --> 02:26:27.080]  означают, что типа debug вывод
[02:26:27.080 --> 02:26:29.080]  и тогда там будет
[02:26:29.080 --> 02:26:31.080]  форматироваться все красивенько
[02:26:31.080 --> 02:26:33.080]  бывает полезно
[02:26:35.080 --> 02:26:37.080]  и кстати сейчас мы дойдем
[02:26:37.080 --> 02:26:39.080]  до вопроса, который мне уже даже
[02:26:39.080 --> 02:26:41.080]  спросили в личке
[02:26:41.080 --> 02:26:43.080]  про то
[02:26:43.080 --> 02:26:45.080]  как
[02:26:45.080 --> 02:26:47.080]  биндить
[02:26:47.080 --> 02:26:49.080]  к значениям
[02:26:49.080 --> 02:26:51.080]  названия
[02:26:51.080 --> 02:26:53.080]  то есть смотрите
[02:26:53.080 --> 02:26:55.080]  вот мы матчем какой-то age
[02:26:55.080 --> 02:26:57.080]  и мы хотим, вот смотрите
[02:26:57.080 --> 02:26:59.080]  если ноль, то мы там что-то выводим
[02:26:59.080 --> 02:27:01.080]  а что если у нас от 1 до 12
[02:27:01.080 --> 02:27:03.080]  мы хотим с ним что-то внутри сделать
[02:27:03.080 --> 02:27:05.080]  если мы просто ставим 1.12
[02:27:05.080 --> 02:27:07.080]  то у нас внутри никакого числа не будет
[02:27:07.080 --> 02:27:09.080]  ну что нам с ним сделать
[02:27:09.080 --> 02:27:11.080]  если мы хотим
[02:27:11.080 --> 02:27:13.080]  допустим его на 2 умножить и вывести
[02:27:13.080 --> 02:27:15.080]  соответственно мы используем
[02:27:15.080 --> 02:27:17.080]  такую штуку, которая тоже является частью
[02:27:17.080 --> 02:27:19.080]  паттерн матчинга, это n и такой
[02:27:19.080 --> 02:27:21.080]  значок собаки
[02:27:21.080 --> 02:27:23.080]  который соответственно означает, что
[02:27:23.080 --> 02:27:25.080]  мы биндим
[02:27:25.080 --> 02:27:27.080]  к этому значению, который
[02:27:27.080 --> 02:27:29.080]  вот сюда вот подходит
[02:27:29.080 --> 02:27:31.080]  название n
[02:27:31.080 --> 02:27:33.080]  как-то так
[02:27:33.080 --> 02:27:35.080]  это наверное такой достаточно
[02:27:35.080 --> 02:27:37.080]  экзотический синтаксис, поэтому
[02:27:37.080 --> 02:27:39.080]  если вы его не особо понимаете
[02:27:39.080 --> 02:27:41.080]  наверное тоже можете пока что забить
[02:27:55.080 --> 02:27:57.080]  потом у нас есть биндинг
[02:27:57.080 --> 02:27:59.080]  как раз
[02:27:59.080 --> 02:28:01.080]  что мы можем в лупе что-то делать
[02:28:01.080 --> 02:28:03.080]  с массивом
[02:28:03.080 --> 02:28:05.080]  смотрите, вот s, то у меня какой-то массив
[02:28:05.080 --> 02:28:07.080]  потом ut это slice
[02:28:07.080 --> 02:28:09.080]  что такое slice, это
[02:28:09.080 --> 02:28:11.080]  под массив
[02:28:11.080 --> 02:28:13.080]  под массив может быть в том числе всем массивом
[02:28:13.080 --> 02:28:15.080]  то есть это какое-то непрерывное
[02:28:15.080 --> 02:28:17.080]  от одного индекса до другого
[02:28:17.080 --> 02:28:19.080]  под массив массива
[02:28:19.080 --> 02:28:21.080]  он не копируется
[02:28:21.080 --> 02:28:23.080]  это просто два указателя
[02:28:23.080 --> 02:28:25.080]  и даже не грубо говоря, это так и есть
[02:28:25.080 --> 02:28:27.080]  это просто два указателя
[02:28:27.080 --> 02:28:29.080]  по которому можете индексироваться соответственно
[02:28:29.080 --> 02:28:31.080]  вот смотрите
[02:28:31.080 --> 02:28:33.080]  в цикле я делаю так, я матчу t
[02:28:33.080 --> 02:28:35.080]  смотрите, и дальше паттерн матчем
[02:28:35.080 --> 02:28:37.080]  такой хитрый, если я беру head
[02:28:37.080 --> 02:28:39.080]  а tail называю все остальное
[02:28:39.080 --> 02:28:41.080]  типа вот мы две фичи
[02:28:41.080 --> 02:28:43.080]  сразу же использовали
[02:28:43.080 --> 02:28:45.080]  типа я вывожу head
[02:28:45.080 --> 02:28:47.080]  дальше at присваиваю значение tail
[02:28:47.080 --> 02:28:49.080]  то есть таким образом у меня
[02:28:49.080 --> 02:28:51.080]  на первой итерации вместо 1,2,3,4 slice станет
[02:28:51.080 --> 02:28:53.080]  2,3,4
[02:28:53.080 --> 02:28:55.080]  и точно так же второй раз матчу
[02:28:55.080 --> 02:28:57.080]  вывожу двойку, 3,4 становится tail
[02:28:57.080 --> 02:28:59.080]  как slice делается
[02:28:59.080 --> 02:29:01.080]  с других элементов
[02:29:01.080 --> 02:29:03.080]  как slice делает
[02:29:03.080 --> 02:29:05.080]  например 2,3
[02:29:05.080 --> 02:29:07.080]  2,3 элемента
[02:29:09.080 --> 02:29:11.080]  не весь
[02:29:11.080 --> 02:29:13.080]  а сразу укороченный
[02:29:15.080 --> 02:29:17.080]  как брать укороченный slice сверху
[02:29:17.080 --> 02:29:19.080]  смотри
[02:29:19.080 --> 02:29:21.080]  вот как раз эти две точки означают range
[02:29:21.080 --> 02:29:23.080]  просто это бесконечный range
[02:29:23.080 --> 02:29:25.080]  от минуса бесконечности до плюс бесконечности
[02:29:25.080 --> 02:29:27.080]  если например напишешь 1,2
[02:29:27.080 --> 02:29:29.080]  то в таком случае получишь range
[02:29:29.080 --> 02:29:31.080]  от одного включительного, от двух не включительного
[02:29:31.080 --> 02:29:33.080]  если напишешь 1,2 просто
[02:29:33.080 --> 02:29:35.080]  тогда там плюс бесконечности будет
[02:29:39.080 --> 02:29:41.080]  вообще тут имперсант важен
[02:29:41.080 --> 02:29:43.080]  это мы попозже поговорим
[02:29:43.080 --> 02:29:45.080]  когда будем говорить про dynamic size types
[02:29:45.080 --> 02:29:47.080]  пока что не берите у голов
[02:29:47.080 --> 02:29:49.080]  просто пишите так
[02:29:49.080 --> 02:29:51.080]  вот
[02:29:53.080 --> 02:29:55.080]  мы можем даже для инамов писать всякие имплы
[02:29:55.080 --> 02:29:57.080]  прикольные
[02:29:57.080 --> 02:29:59.080]  у нас есть инам какой-то
[02:29:59.080 --> 02:30:01.080]  потом мы делаем для него функцию unwrap
[02:30:05.080 --> 02:30:07.080]  если у нас self это ax
[02:30:07.080 --> 02:30:09.080]  то возвращает x
[02:30:09.080 --> 02:30:11.080]  а если b, то в таком случае мы паникуем
[02:30:11.080 --> 02:30:13.080]  в частности это то
[02:30:13.080 --> 02:30:15.080]  как именно работает unwrap
[02:30:15.080 --> 02:30:17.080]  в инами option
[02:30:17.080 --> 02:30:19.080]  которые мы уже видели
[02:30:19.080 --> 02:30:21.080]  вам придется очень часто пользоваться unwrap
[02:30:21.080 --> 02:30:23.080]  и expect
[02:30:29.080 --> 02:30:31.080]  иногда нам нужно
[02:30:31.080 --> 02:30:33.080]  в одном варианте
[02:30:33.080 --> 02:30:35.080]  что-то сделать
[02:30:35.080 --> 02:30:37.080]  я как раз взял option
[02:30:37.080 --> 02:30:39.080]  я хочу
[02:30:39.080 --> 02:30:41.080]  в случае если это сам
[02:30:41.080 --> 02:30:43.080]  вывести сам, а иначе ничего не сделать
[02:30:43.080 --> 02:30:45.080]  ну собственно
[02:30:45.080 --> 02:30:47.080]  это можно сделать немножко попроще
[02:30:47.080 --> 02:30:49.080]  с этим понятно
[02:30:49.080 --> 02:30:51.080]  что мы делаем
[02:30:51.080 --> 02:30:53.080]  мне такое чувство, что все потерялись
[02:30:53.080 --> 02:30:55.080]  с pattern match
[02:30:55.080 --> 02:30:57.080]  наверное очень сложная тема
[02:30:57.080 --> 02:30:59.080]  а что такое сам?
[02:30:59.080 --> 02:31:01.080]  сам это
[02:31:01.080 --> 02:31:03.080]  то что у нас option был
[02:31:03.080 --> 02:31:05.080]  просто там еще
[02:31:05.080 --> 02:31:07.080]  можно писать option
[02:31:07.080 --> 02:31:09.080]  но компилятор
[02:31:09.080 --> 02:31:11.080]  оно в прелюд
[02:31:11.080 --> 02:31:13.080]  в прелюд написано, что можно просто писать сам
[02:31:13.080 --> 02:31:15.080]  там написано use option
[02:31:19.080 --> 02:31:21.080]  это инструктура
[02:31:21.080 --> 02:31:23.080]  это yinam option
[02:31:23.080 --> 02:31:25.080]  я показывал yinam option t
[02:31:25.080 --> 02:31:27.080]  где сам t и yinam
[02:31:27.080 --> 02:31:29.080]  а это оно и есть
[02:31:29.080 --> 02:31:31.080]  он догадывается, что это не с option
[02:31:31.080 --> 02:31:33.080]  да
[02:31:33.080 --> 02:31:35.080]  ну и мы сказали
[02:31:35.080 --> 02:31:37.080]  просто в прелюде
[02:31:37.080 --> 02:31:39.080]  оно так есть
[02:31:39.080 --> 02:31:41.080]  сам это получается t
[02:31:43.080 --> 02:31:45.080]  сам
[02:31:45.080 --> 02:31:47.080]  option alaminate tip
[02:31:47.080 --> 02:31:49.080]  option i32
[02:31:49.080 --> 02:31:51.080]  2.option i32
[02:31:57.080 --> 02:31:59.080]  так
[02:32:01.080 --> 02:32:03.080]  ну что ж
[02:32:03.080 --> 02:32:05.080]  давайте попробуем
[02:32:05.080 --> 02:32:07.080]  написать это получше
[02:32:07.080 --> 02:32:09.080]  iflet это pattern match
[02:32:09.080 --> 02:32:11.080]  iflet дальше я матчу
[02:32:11.080 --> 02:32:13.080]  если сам i равняется option
[02:32:13.080 --> 02:32:15.080]  если справа
[02:32:15.080 --> 02:32:17.080]  кажется, что
[02:32:17.080 --> 02:32:19.080]  у нас как раз сам что-то там
[02:32:19.080 --> 02:32:21.080]  то в таком случае получим i
[02:32:21.080 --> 02:32:23.080]  внутри
[02:32:23.080 --> 02:32:25.080]  по сути
[02:32:25.080 --> 02:32:27.080]  это специальная конструкция iflet
[02:32:27.080 --> 02:32:29.080]  которая предназначена
[02:32:29.080 --> 02:32:31.080]  как раз для такого прекрасного матча
[02:32:31.080 --> 02:32:33.080]  а вне ifa
[02:32:33.080 --> 02:32:35.080]  какой вариант не пройдет?
[02:32:35.080 --> 02:32:37.080]  вне ifa такой матч не пройдет
[02:32:37.080 --> 02:32:39.080]  let some и optional
[02:32:39.080 --> 02:32:41.080]  он кажется не имеет никакого смысла
[02:32:41.080 --> 02:32:43.080]  можно просто
[02:32:43.080 --> 02:32:45.080]  андроид сделать во-первых
[02:32:45.080 --> 02:32:47.080]  во-вторых он не прокатит
[02:32:47.080 --> 02:32:49.080]  потому что iflet это специальная конструкция
[02:32:49.080 --> 02:32:51.080]  у нас была с этого option
[02:32:51.080 --> 02:32:53.080]  не было написано
[02:32:53.080 --> 02:32:55.080]  option sum от чего-то
[02:32:55.080 --> 02:32:57.080]  но даже там не понятно
[02:32:57.080 --> 02:32:59.080]  что такое sum
[02:32:59.080 --> 02:33:01.080]  там sum t
[02:33:01.080 --> 02:33:03.080]  там sum t был
[02:33:03.080 --> 02:33:05.080]  optional
[02:33:05.080 --> 02:33:07.080]  или как
[02:33:07.080 --> 02:33:11.080]  sum это один из вариантов enum
[02:33:11.080 --> 02:33:13.080]  у него есть значение
[02:33:13.080 --> 02:33:15.080]  внутри t
[02:33:15.080 --> 02:33:17.080]  конкретно в случае t
[02:33:17.080 --> 02:33:19.080]  равняется i30
[02:33:19.080 --> 02:33:21.080]  вот так
[02:33:27.080 --> 02:33:29.080]  а там одно равно?
[02:33:29.080 --> 02:33:31.080]  да
[02:33:31.080 --> 02:33:33.080]  да
[02:33:33.080 --> 02:33:35.080]  типа присваивания
[02:33:37.080 --> 02:33:39.080]  то же самое можно сделать
[02:33:39.080 --> 02:33:41.080]  вообще абсолютно то же самое
[02:33:41.080 --> 02:33:43.080]  у нас sum 0
[02:33:43.080 --> 02:33:45.080]  и пока
[02:33:45.080 --> 02:33:47.080]  оно не больше 9
[02:33:47.080 --> 02:33:49.080]  мы просто итерируемся
[02:33:49.080 --> 02:33:51.080]  и присваиваем значение optional
[02:33:51.080 --> 02:33:53.080]  sum i плюс 1
[02:33:53.080 --> 02:33:55.080]  и все
[02:33:55.080 --> 02:33:57.080]  если вы увидите у нас pattern matching
[02:33:57.080 --> 02:33:59.080]  мы получаем sum 3i
[02:33:59.080 --> 02:34:01.080]  мы матчим i
[02:34:01.080 --> 02:34:03.080]  если оно больше 9
[02:34:03.080 --> 02:34:05.080]  и выходим
[02:34:05.080 --> 02:34:07.080]  и если нет
[02:34:07.080 --> 02:34:09.080]  то в таком случае optional делаем sum i плюс 1
[02:34:09.080 --> 02:34:11.080]  и снова матч
[02:34:11.080 --> 02:34:13.080]  можно наоборот
[02:34:13.080 --> 02:34:15.080]  let optional равно sum i?
[02:34:15.080 --> 02:34:17.080]  нет
[02:34:17.080 --> 02:34:19.080]  то есть у нас не везде одно равно
[02:34:19.080 --> 02:34:21.080]  если 3 равняется 7
[02:34:21.080 --> 02:34:23.080]  то вы 2 равно купишь
[02:34:23.080 --> 02:34:25.080]  то есть это просто прямое присваивание?
[02:34:25.080 --> 02:34:27.080]  это можно даже воспринимать
[02:34:27.080 --> 02:34:29.080]  как присваивание
[02:34:29.080 --> 02:34:31.080]  то есть мы делаем sum i равняется optional
[02:34:31.080 --> 02:34:33.080]  просто этот sum i это типа pattern
[02:34:33.080 --> 02:34:35.080]  он пытается посмотреть
[02:34:35.080 --> 02:34:37.080]  ага, похожи они или нет
[02:34:37.080 --> 02:34:39.080]  типа как их сопоставить
[02:34:41.080 --> 02:34:43.080]  такс
[02:34:43.080 --> 02:34:45.080]  мы дошли до того
[02:34:45.080 --> 02:34:47.080]  чем же отличается yinam и yinim
[02:34:47.080 --> 02:34:49.080]  в расте и в плюсах
[02:34:49.080 --> 02:34:51.080]  у нас yinam
[02:34:51.080 --> 02:34:53.080]  так
[02:34:53.080 --> 02:34:55.080]  yinam c++
[02:34:55.080 --> 02:34:57.080]  давайте я вычитаю, чтобы порядке получилось
[02:34:57.080 --> 02:34:59.080]  так
[02:34:59.080 --> 02:35:01.080]  у нас во-первых для того чтобы выяснить
[02:35:01.080 --> 02:35:03.080]  какой у нас вариант yinam у нас есть такая штука
[02:35:03.080 --> 02:35:05.080]  называется дискриминант
[02:35:05.080 --> 02:35:07.080]  это какое-то число бит
[02:35:07.080 --> 02:35:09.080]  которое показывает какой на данный момент
[02:35:09.080 --> 02:35:11.080]  вариант yinam есть
[02:35:11.080 --> 02:35:13.080]  например если у вас option из двух вариантов
[02:35:13.080 --> 02:35:15.080]  то у вас где-то есть один битик
[02:35:15.080 --> 02:35:17.080]  который означает
[02:35:17.080 --> 02:35:19.080]  какой сейчас вариант yinam
[02:35:19.080 --> 02:35:21.080]  0 или 1
[02:35:21.080 --> 02:35:23.080]  если у вас допустим 30 вариантов у yinam
[02:35:23.080 --> 02:35:25.080]  то у вас где-то будет 5 битиков
[02:35:25.080 --> 02:35:27.080]  причем эти битики
[02:35:27.080 --> 02:35:29.080]  они могут распределены совершенно произвольно
[02:35:29.080 --> 02:35:31.080]  то есть
[02:35:31.080 --> 02:35:33.080]  я сейчас вам покажу пример
[02:35:33.080 --> 02:35:35.080]  где раст раскидывает в неиспользуемые биты переменных
[02:35:35.080 --> 02:35:37.080]  булов всяких
[02:35:39.080 --> 02:35:41.080]  биты для того чтобы экономить память
[02:35:43.080 --> 02:35:45.080]  так
[02:35:47.080 --> 02:35:49.080]  это в принципе я все сказал
[02:35:49.080 --> 02:35:51.080]  это одновременно по сути union yinam c++
[02:35:53.080 --> 02:35:55.080]  потому что у нас yinam имеет размер
[02:35:55.080 --> 02:35:57.080]  точно такой
[02:35:57.080 --> 02:35:59.080]  какой имеет максимальное поле
[02:35:59.080 --> 02:36:01.080]  у yinam
[02:36:01.080 --> 02:36:03.080]  ну и соответственно максимальной
[02:36:03.080 --> 02:36:05.080]  поодинкой всех элементов
[02:36:13.080 --> 02:36:15.080]  вот давайте такой пример посмотрим
[02:36:15.080 --> 02:36:17.080]  какой-то тест где first табул, second, third, fourth
[02:36:17.080 --> 02:36:19.080]  смотрим такие
[02:36:19.080 --> 02:36:21.080]  assert тест 1 байт
[02:36:21.080 --> 02:36:23.080]  проходит
[02:36:23.080 --> 02:36:25.080]  у нас тест
[02:36:25.080 --> 02:36:27.080]  yinam тест имеет размер 1 байт
[02:36:27.080 --> 02:36:29.080]  одно значение этого yinam
[02:36:29.080 --> 02:36:31.080]  почему так получается
[02:36:31.080 --> 02:36:33.080]  нам же казалось бы нужно еще где-то 2 битика
[02:36:33.080 --> 02:36:35.080]  для того чтобы
[02:36:35.080 --> 02:36:37.080]  вшифровать какой у нас вариант yinam
[02:36:37.080 --> 02:36:39.080]  он их использует где-то
[02:36:39.080 --> 02:36:41.080]  где они используются булом биты
[02:36:41.080 --> 02:36:43.080]  как я говорил у нас
[02:36:43.080 --> 02:36:45.080]  бул имеет 1 байт размер
[02:36:45.080 --> 02:36:47.080]  но используется в нем только 1 бит
[02:36:47.080 --> 02:36:49.080]  потому что он имеет значение только либо true либо false
[02:36:49.080 --> 02:36:51.080]  ну и соответственно остальные 7 бит
[02:36:51.080 --> 02:36:53.080]  он использует себе пользу
[02:36:59.080 --> 02:37:01.080]  если бы здесь был кстати u32
[02:37:01.080 --> 02:37:03.080]  то в таком случае здесь бы был
[02:37:03.080 --> 02:37:05.080]  размер
[02:37:05.080 --> 02:37:07.080]  8 байт
[02:37:09.080 --> 02:37:11.080]  потому что u32 он может любое значение
[02:37:11.080 --> 02:37:13.080]  принять он соответственно не может
[02:37:13.080 --> 02:37:15.080]  в u32 никакие биты переиспользовать
[02:37:15.080 --> 02:37:17.080]  ему нужно добавить какие-то
[02:37:17.080 --> 02:37:19.080]  свои поля внутри для дискриминанта
[02:37:19.080 --> 02:37:21.080]  он добавит в данном случае
[02:37:21.080 --> 02:37:23.080]  1 байт и еще паддинг
[02:37:23.080 --> 02:37:25.080]  3 байт
[02:37:27.080 --> 02:37:29.080]  а если бы там была структурка
[02:37:29.080 --> 02:37:31.080]  у которой внутри был
[02:37:31.080 --> 02:37:33.080]  структурка у которой внутри был
[02:37:33.080 --> 02:37:35.080]  это тоже самое было бы
[02:37:35.080 --> 02:37:37.080]  он понимает
[02:37:39.080 --> 02:37:41.080]  потом у нас есть
[02:37:41.080 --> 02:37:43.080]  size of option box i32
[02:37:43.080 --> 02:37:45.080]  option box это уже полный аналог
[02:37:45.080 --> 02:37:47.080]  получается unique pointer
[02:37:47.080 --> 02:37:49.080]  c++
[02:37:49.080 --> 02:37:51.080]  потому что box если у нас это просто
[02:37:51.080 --> 02:37:53.080]  что-то алоцированное на куче не null
[02:37:53.080 --> 02:37:55.080]  то в таком случае если мы навесим еще option
[02:37:55.080 --> 02:37:57.080]  то у нас будет либо sum box
[02:37:57.080 --> 02:37:59.080]  либо null
[02:38:01.080 --> 02:38:03.080]  интересно потерялись ли люди на этом моменте
[02:38:03.080 --> 02:38:05.080]  и нам и оказались
[02:38:05.080 --> 02:38:07.080]  в этом очень-очень сложном
[02:38:07.080 --> 02:38:09.080]  1 указатель и 1 бит
[02:38:09.080 --> 02:38:11.080]  еще раз повторяю
[02:38:11.080 --> 02:38:13.080]  нам нужен 1 указатель
[02:38:13.080 --> 02:38:15.080]  для 1 бит
[02:38:15.080 --> 02:38:17.080]  да
[02:38:17.080 --> 02:38:19.080]  но смотри здесь есть одна хитрость
[02:38:19.080 --> 02:38:21.080]  мы же знаем что box
[02:38:21.080 --> 02:38:23.080]  внутри box это просто 1 указатель
[02:38:23.080 --> 02:38:25.080]  но дело в том что этот указатель
[02:38:25.080 --> 02:38:27.080]  может быть null и такой раз
[02:38:27.080 --> 02:38:29.080]  почему бы мне для 0 не использовать
[02:38:29.080 --> 02:38:31.080]  как единственный бит
[02:38:31.080 --> 02:38:33.080]  если какое-то значение значит это box если 0 значит это null
[02:38:33.080 --> 02:38:35.080]  все просто
[02:38:35.080 --> 02:38:37.080]  вот он такой оптимизация
[02:38:43.080 --> 02:38:45.080]  что может быть
[02:38:45.080 --> 02:38:47.080]  да
[02:38:47.080 --> 02:38:49.080]  это будет 0 size
[02:38:59.080 --> 02:39:01.080]  разные объекты один и тот же адрес
[02:39:01.080 --> 02:39:03.080]  но вообще нет
[02:39:03.080 --> 02:39:05.080]  если только unsafe не пользоваться
[02:39:05.080 --> 02:39:07.080]  и не начинать там указатели
[02:39:13.080 --> 02:39:15.080]  что-то не подсказывает
[02:39:15.080 --> 02:39:17.080]  что такая ссылка
[02:39:17.080 --> 02:39:19.080]  будет иметь мало значения
[02:39:19.080 --> 02:39:21.080]  вообще скорее всего это просто
[02:39:21.080 --> 02:39:23.080]  так как эту ссылку нельзя будет использовать
[02:39:23.080 --> 02:39:25.080]  ведь вы не можете никакого взять поле у структуры
[02:39:25.080 --> 02:39:27.080]  в таком случае у вас просто
[02:39:27.080 --> 02:39:29.080]  этот указатель
[02:39:29.080 --> 02:39:31.080]  какое бы значение не имел
[02:39:31.080 --> 02:39:33.080]  он не будет иметь смысл
[02:39:33.080 --> 02:39:35.080]  поэтому в принципе можно
[02:39:35.080 --> 02:39:37.080]  не знаю какой конкретный ответ
[02:39:37.080 --> 02:39:39.080]  на этот вопрос если честно
[02:39:39.080 --> 02:39:41.080]  так что
[02:39:41.080 --> 02:39:43.080]  ответ на этот вопрос если честно
[02:39:45.080 --> 02:39:47.080]  скорее всего это не имеет значения
[02:39:47.080 --> 02:39:49.080]  как оно имплементировано
[02:39:53.080 --> 02:39:55.080]  смотрите
[02:39:55.080 --> 02:39:57.080]  буквально вчера тоже проверил
[02:39:57.080 --> 02:39:59.080]  если вы возьмете
[02:39:59.080 --> 02:40:01.080]  одно поле из двух булов
[02:40:01.080 --> 02:40:03.080]  а потом возьмете 254
[02:40:03.080 --> 02:40:05.080]  поля еще добавите
[02:40:05.080 --> 02:40:07.080]  соответственно в сумме 255 да
[02:40:07.080 --> 02:40:09.080]  в таком случае у вас получится
[02:40:09.080 --> 02:40:11.080]  в таком случае у вас получится размер все те же 2 вайта
[02:40:11.080 --> 02:40:13.080]  потому что
[02:40:13.080 --> 02:40:15.080]  казалось бы нам нужно
[02:40:15.080 --> 02:40:17.080]  нам нужно 7 получается
[02:40:17.080 --> 02:40:19.080]  нет 8 бит
[02:40:19.080 --> 02:40:21.080]  для того чтобы все это зашифровать
[02:40:21.080 --> 02:40:23.080]  все варианты инамы
[02:40:23.080 --> 02:40:25.080]  и один из битов переедет
[02:40:25.080 --> 02:40:27.080]  в другой бул
[02:40:27.080 --> 02:40:29.080]  то есть он прямо будет имачить
[02:40:29.080 --> 02:40:31.080]  и вы это должны будете видеть
[02:40:31.080 --> 02:40:33.080]  только если вы добавите еще одно поле
[02:40:33.080 --> 02:40:35.080]  то уже будет 3
[02:40:35.080 --> 02:40:37.080]  почему не знаю
[02:40:37.080 --> 02:40:39.080]  с каких-то достаточно больших значений
[02:40:39.080 --> 02:40:41.080]  эффективнее
[02:40:41.080 --> 02:40:43.080]  просто иметь отдельное поле дискриминента
[02:40:51.080 --> 02:40:53.080]  вот у нас есть
[02:40:53.080 --> 02:40:55.080]  вектор
[02:40:55.080 --> 02:40:57.080]  как все плюсы призначены
[02:40:57.080 --> 02:40:59.080]  у нас есть поинтер
[02:40:59.080 --> 02:41:01.080]  на консте length и capacity
[02:41:01.080 --> 02:41:03.080]  он стоит примерно точно так же
[02:41:03.080 --> 02:41:05.080]  здесь есть еще такой комментарий
[02:41:05.080 --> 02:41:07.080]  это вот чтобы вам
[02:41:07.080 --> 02:41:09.080]  просто жизни не казалось простой
[02:41:09.080 --> 02:41:11.080]  я вам заранее скажу что на самом деле
[02:41:11.080 --> 02:41:13.080]  в случае раз
[02:41:13.080 --> 02:41:15.080]  нужно учитывать что у вас еще в типе
[02:41:15.080 --> 02:41:17.080]  написано и поэтому там будет phantom date
[02:41:17.080 --> 02:41:19.080]  чтобы это все учесть
[02:41:19.080 --> 02:41:21.080]  наш указатель
[02:41:21.080 --> 02:41:23.080]  это указатель 1
[02:41:23.080 --> 02:41:25.080]  да
[02:41:25.080 --> 02:41:27.080]  почему не constant
[02:41:27.080 --> 02:41:29.080]  это указатель
[02:41:29.080 --> 02:41:31.080]  constant a
[02:41:31.080 --> 02:41:33.080]  да там mut
[02:41:33.080 --> 02:41:35.080]  указатель нам mut
[02:41:35.080 --> 02:41:37.080]  все правильно
[02:41:37.080 --> 02:41:39.080]  это ошибка
[02:41:39.080 --> 02:41:41.080]  так
[02:41:41.080 --> 02:41:43.080]  кстати говоря
[02:41:43.080 --> 02:41:45.080]  я здесь явно прописал
[02:41:45.080 --> 02:41:47.080]  до этого не прописал
[02:41:47.080 --> 02:41:49.080]  istedimium-sizeof
[02:41:49.080 --> 02:41:51.080]  по умолчанию
[02:41:51.080 --> 02:41:53.080]  не импортировано
[02:41:53.080 --> 02:41:55.080]  нужно импортировать вот так вот
[02:41:55.080 --> 02:41:57.080]  либо просто прописывать полностью
[02:41:57.080 --> 02:41:59.080]  mem-sizeof
[02:41:59.080 --> 02:42:01.080]  даже интересно как оно сюда попало
[02:42:01.080 --> 02:42:03.080]  значит размер вектора
[02:42:03.080 --> 02:42:05.080]  ну это просто
[02:42:05.080 --> 02:42:07.080]  усайс на 3
[02:42:07.080 --> 02:42:09.080]  очевидно почему
[02:42:09.080 --> 02:42:11.080]  потому что у нас там по сути есть 3 усайза
[02:42:11.080 --> 02:42:13.080]  это один указатель, два усайза
[02:42:13.080 --> 02:42:15.080]  kp-stillenv
[02:42:15.080 --> 02:42:17.080]  ну создаем вектор
[02:42:17.080 --> 02:42:19.080]  можем создать вектор с помощью
[02:42:19.080 --> 02:42:21.080]  макроса, если вы через запятую напишете
[02:42:21.080 --> 02:42:23.080]  у вас будет 3 элемента здесь
[02:42:23.080 --> 02:42:25.080]  если вы напишете элемент точкой запятой
[02:42:25.080 --> 02:42:27.080]  и число, то у вас будет какое число
[02:42:27.080 --> 02:42:29.080]  знаков элемента
[02:42:29.080 --> 02:42:31.080]  в принципе понятно
[02:42:33.080 --> 02:42:35.080]  потом у нас есть вот
[02:42:35.080 --> 02:42:37.080]  вот слайсы
[02:42:37.080 --> 02:42:39.080]  это к вопросу о том, как они правильно
[02:42:39.080 --> 02:42:41.080]  пользоваться, вот можно всякие вот такие вот штуки делать
[02:42:41.080 --> 02:42:43.080]  например до 2
[02:42:43.080 --> 02:42:45.080]  то есть это получается
[02:42:45.080 --> 02:42:47.080]  что первый слайс будет 2, 3, 4, а второй будет
[02:42:47.080 --> 02:42:49.080]  просто 2
[02:42:51.080 --> 02:42:53.080]  первый слайс если что берется от a
[02:42:53.080 --> 02:42:55.080]  а второй слайс берется
[02:42:55.080 --> 02:42:57.080]  от слайса того
[02:42:57.080 --> 02:42:59.080]  и получается соответственно
[02:42:59.080 --> 02:43:01.080]  просто 2
[02:43:09.080 --> 02:43:11.080]  так ну смотри
[02:43:11.080 --> 02:43:13.080]  если мы возьмем от 1 до 4
[02:43:13.080 --> 02:43:15.080]  то мы возьмем элементы 1, 2, 3, 2, 3, 4
[02:43:15.080 --> 02:43:17.080]  второй слайс
[02:43:17.080 --> 02:43:19.080]  мы возьмем элементы все до 2
[02:43:19.080 --> 02:43:21.080]  0, 1, 2
[02:43:23.080 --> 02:43:25.080]  может быть я тоже опечатался
[02:43:25.080 --> 02:43:27.080]  не, не
[02:43:27.080 --> 02:43:29.080]  так сейчас подождите
[02:43:29.080 --> 02:43:31.080]  да, я наверное продолбался
[02:43:31.080 --> 02:43:33.080]  здесь тоже должна быть троечка
[02:43:33.080 --> 02:43:35.080]  2, 3
[02:43:39.080 --> 02:43:41.080]  ну тут если что индексация идет
[02:43:41.080 --> 02:43:43.080]  от другого слайса, то есть вы кого-то
[02:43:43.080 --> 02:43:45.080]  создаете дополнительно
[02:43:45.080 --> 02:43:47.080]  мы же взяли
[02:43:47.080 --> 02:43:49.080]  2, 3, 4
[02:43:51.080 --> 02:43:53.080]  слайс 1, 2, 3, 4
[02:43:53.080 --> 02:43:55.080]  потом мы от 1 добавим
[02:43:55.080 --> 02:43:57.080]  все элементы
[02:43:57.080 --> 02:43:59.080]  до 2 невключительно
[02:43:59.080 --> 02:44:01.080]  то есть 0, 1
[02:44:01.080 --> 02:44:03.080]  да
[02:44:07.080 --> 02:44:09.080]  вот там
[02:44:09.080 --> 02:44:11.080]  это индексы указаны
[02:44:11.080 --> 02:44:13.080]  где мы берем
[02:44:13.080 --> 02:44:15.080]  да, это типа range
[02:44:15.080 --> 02:44:17.080]  то есть то же самое синтаксис
[02:44:17.080 --> 02:44:19.080]  что в порах у нас был
[02:44:19.080 --> 02:44:21.080]  что когда мы матчили
[02:44:21.080 --> 02:44:23.080]  от x до y
[02:44:23.080 --> 02:44:25.080]  если вы первое не пишете там минус бесконечности
[02:44:25.080 --> 02:44:27.080]  если второе не пишете там плюс бесконечности
[02:44:27.080 --> 02:44:29.080]  если не то не то не пишете у вас просто бесконечный range
[02:44:29.080 --> 02:44:31.080]  что сейчас
[02:44:31.080 --> 02:44:33.080]  отрицательные
[02:44:33.080 --> 02:44:35.080]  вы не можете индексировать массивы
[02:44:35.080 --> 02:44:37.080]  отрицательными, но вообще range можно
[02:44:37.080 --> 02:44:39.080]  от 1 до 3 сделать
[02:44:41.080 --> 02:44:43.080]  да, кстати очень важный момент
[02:44:43.080 --> 02:44:45.080]  индексировать все массивы
[02:44:45.080 --> 02:44:47.080]  вектора и так далее
[02:44:47.080 --> 02:44:49.080]  можно только усайзом
[02:44:49.080 --> 02:44:51.080]  то есть если вы попробуете
[02:44:51.080 --> 02:44:53.080]  с помощью i32 это сделать
[02:44:53.080 --> 02:44:55.080]  у вас будут проблемы
[02:44:55.080 --> 02:44:57.080]  раз вам это запретить делать
[02:44:59.080 --> 02:45:01.080]  так, теперь да
[02:45:01.080 --> 02:45:03.080]  время паниковать
[02:45:03.080 --> 02:45:05.080]  у нас есть такой макрос
[02:45:05.080 --> 02:45:07.080]  который начинает паниковать
[02:45:07.080 --> 02:45:09.080]  он работает
[02:45:09.080 --> 02:45:11.080]  как я уже говорил как экзепшн
[02:45:11.080 --> 02:45:13.080]  просто stack unwinder до самого конца
[02:45:13.080 --> 02:45:15.080]  и говорит нам сообщение об ошибке вместе
[02:45:15.080 --> 02:45:17.080]  с stack trace
[02:45:17.080 --> 02:45:19.080]  так можно
[02:45:19.080 --> 02:45:21.080]  без точки запятой
[02:45:25.080 --> 02:45:27.080]  на самом деле там логично
[02:45:27.080 --> 02:45:29.080]  вы наверное еще пока не писали на расте
[02:45:29.080 --> 02:45:31.080]  то есть пришли на первые лекции
[02:45:37.080 --> 02:45:39.080]  это не зависит от if не if
[02:45:39.080 --> 02:45:41.080]  можно вне ifa
[02:45:41.080 --> 02:45:43.080]  выше где x равняется 42
[02:45:43.080 --> 02:45:45.080]  просто написать панику и все равно все заработает
[02:45:45.080 --> 02:45:47.080]  это просто возвращение
[02:45:47.080 --> 02:45:49.080]  юниона будет
[02:45:49.080 --> 02:45:51.080]  ну можно
[02:45:55.080 --> 02:45:57.080]  если после паники
[02:45:57.080 --> 02:45:59.080]  что-то еще написать
[02:45:59.080 --> 02:46:01.080]  хоть и раз будет понимать что после паники
[02:46:01.080 --> 02:46:03.080]  код не будет исполняться
[02:46:03.080 --> 02:46:05.080]  он скажет что вообще-то
[02:46:05.080 --> 02:46:07.080]  у вас здесь вернулось уже значение
[02:46:07.080 --> 02:46:09.080]  то есть у вас expression, а дальше идет statement
[02:46:09.080 --> 02:46:11.080]  что-то не то
[02:46:11.080 --> 02:46:13.080]  в этом случае это правильное утверждение
[02:46:13.080 --> 02:46:15.080]  у нас есть несколько макросов
[02:46:15.080 --> 02:46:17.080]  которые паникуют, вы их увидите в задачке
[02:46:17.080 --> 02:46:19.080]  ассерт и ассерт и икол
[02:46:19.080 --> 02:46:21.080]  первые три
[02:46:21.080 --> 02:46:23.080]  это все одно и то же
[02:46:23.080 --> 02:46:25.080]  с разными названиями
[02:46:27.080 --> 02:46:29.080]  предназначенные для разных вещей
[02:46:29.080 --> 02:46:31.080]  чтобы было понятнее тому
[02:46:31.080 --> 02:46:33.080]  кто словил ошибку
[02:46:33.080 --> 02:46:35.080]  ассерт это просто вещь
[02:46:35.080 --> 02:46:37.080]  которая проверяет
[02:46:37.080 --> 02:46:39.080]  true или что-то внутри
[02:46:39.080 --> 02:46:41.080]  ассерт и икол проверяет через запятую
[02:46:41.080 --> 02:46:43.080]  если они не равны
[02:46:43.080 --> 02:46:45.080]  то он прям вам выведет в консольке
[02:46:45.080 --> 02:46:47.080]  у вас сработался артикл
[02:46:47.080 --> 02:46:49.080]  там паника
[02:46:49.080 --> 02:46:51.080]  почему было равно левое значение
[02:46:51.080 --> 02:46:53.080]  и правое значение
[02:47:01.080 --> 02:47:03.080]  а подожди
[02:47:03.080 --> 02:47:05.080]  у32 к булу
[02:47:05.080 --> 02:47:07.080]  нет, так нет
[02:47:07.080 --> 02:47:09.080]  я просто подумал в обратную сторону
[02:47:09.080 --> 02:47:11.080]  хотя нет
[02:47:11.080 --> 02:47:13.080]  см тоже не конвертируется
[02:47:13.080 --> 02:47:15.080]  вообще не конвертируется
[02:47:15.080 --> 02:47:17.080]  см
[02:47:17.080 --> 02:47:19.080]  так
[02:47:19.080 --> 02:47:21.080]  лучшее средство для дебага
[02:47:21.080 --> 02:47:23.080]  принт лм
[02:47:23.080 --> 02:47:25.080]  у нас
[02:47:25.080 --> 02:47:27.080]  есть всякие вещи
[02:47:27.080 --> 02:47:29.080]  которые позволяют нам удобно принтить
[02:47:29.080 --> 02:47:31.080]  как я уже говорил
[02:47:31.080 --> 02:47:33.080]  есть в фигурных скобочках x
[02:47:33.080 --> 02:47:35.080]  можно писать только название переменных
[02:47:35.080 --> 02:47:37.080]  в фигурных скобочках
[02:47:37.080 --> 02:47:39.080]  можно написать x и y внутри
[02:47:39.080 --> 02:47:41.080]  это сейчас
[02:47:41.080 --> 02:47:43.080]  раз еще недостаточно развился
[02:47:43.080 --> 02:47:45.080]  этот синтекс
[02:47:45.080 --> 02:47:47.080]  даже сам к себе недавно появился
[02:47:47.080 --> 02:47:49.080]  буквально пару недель назад
[02:47:49.080 --> 02:47:51.080]  возможности x и y писать пока нет
[02:47:51.080 --> 02:47:53.080]  потом
[02:47:53.080 --> 02:47:55.080]  значение x
[02:47:55.080 --> 02:47:57.080]  что там классное
[02:47:57.080 --> 02:47:59.080]  здесь можно через запятую написать
[02:47:59.080 --> 02:48:01.080]  что вы хотите
[02:48:01.080 --> 02:48:03.080]  в фигурных скобочках написать
[02:48:03.080 --> 02:48:05.080]  что бы истиномить в фигурных скобочках
[02:48:05.080 --> 02:48:07.080]  если бы у вас было 3 фигурных скобочки
[02:48:07.080 --> 02:48:09.080]  то раз бы ожидал
[02:48:09.080 --> 02:48:11.080]  что у вас здесь было бы 3 переменных
[02:48:11.080 --> 02:48:13.080]  не больше не меньше
[02:48:13.080 --> 02:48:15.080]  ну да
[02:48:15.080 --> 02:48:17.080]  быть прям проверять compile time
[02:48:17.080 --> 02:48:19.080]  то есть там macros так работает
[02:48:19.080 --> 02:48:21.080]  он проверяет
[02:48:21.080 --> 02:48:23.080]  потом
[02:48:23.080 --> 02:48:25.080]  есть всякие форматирования
[02:48:25.080 --> 02:48:27.080]  про них подробнее я не буду рассказывать
[02:48:27.080 --> 02:48:29.080]  посмотрите документации если интересно
[02:48:29.080 --> 02:48:31.080]  вот можно написать например
[02:48:31.080 --> 02:48:33.080]  0042
[02:48:33.080 --> 02:48:35.080]  или например
[02:48:35.080 --> 02:48:37.080]  сделать вот такое форматирование типа value
[02:48:37.080 --> 02:48:39.080]  а value это x
[02:48:39.080 --> 02:48:41.080]  можно выводить вектор
[02:48:41.080 --> 02:48:43.080]  например debash
[02:48:43.080 --> 02:48:45.080]  или другим способом
[02:48:45.080 --> 02:48:47.080]  форматировать его
[02:48:47.080 --> 02:48:49.080]  в том числе можно выводить tuple
[02:48:49.080 --> 02:48:51.080]  как видите они форматируются красиво
[02:48:51.080 --> 02:48:53.080]  а второй принц
[02:48:53.080 --> 02:48:55.080]  там x почему
[02:48:55.080 --> 02:48:57.080]  через запятую
[02:48:57.080 --> 02:48:59.080]  его вместо скобок
[02:49:01.080 --> 02:49:03.080]  сейчас подожди какой x через запятую
[02:49:03.080 --> 02:49:05.080]  там где
[02:49:05.080 --> 02:49:07.080]  the value of x есть
[02:49:07.080 --> 02:49:09.080]  второй принц
[02:49:09.080 --> 02:49:11.080]  запятая x
[02:49:11.080 --> 02:49:13.080]  воспример это как print function
[02:49:13.080 --> 02:49:15.080]  точно так же примерно работает
[02:49:17.080 --> 02:49:19.080]  раз x это пример
[02:49:19.080 --> 02:49:21.080]  объявленная высшего
[02:49:21.080 --> 02:49:23.080]  что с форматом в итоге
[02:49:25.080 --> 02:49:27.080]  да тут кстати есть
[02:49:27.080 --> 02:49:29.080]  прям macros формат
[02:49:29.080 --> 02:49:31.080]  восклистательный знак
[02:49:31.080 --> 02:49:33.080]  и собственно принтерлайн
[02:49:33.080 --> 02:49:35.080]  внутри пользуется работает абсолютно точно так же
[02:49:35.080 --> 02:49:37.080]  только не выводит
[02:49:39.080 --> 02:49:41.080]  это означает дабак вывод
[02:49:41.080 --> 02:49:43.080]  а если еще дописать вот такой вот sharp
[02:49:43.080 --> 02:49:45.080]  то это означает что красивенько мне выведет
[02:49:45.080 --> 02:49:47.080]  третья принц
[02:49:47.080 --> 02:49:49.080]  просто вектор
[02:49:49.080 --> 02:49:51.080]  он скажет что
[02:49:51.080 --> 02:49:53.080]  вектор не имплементирует вывод
[02:49:53.080 --> 02:49:55.080]  потому что дабак вывод
[02:49:55.080 --> 02:49:57.080]  разработчики понимают что такое дабак вывод
[02:49:57.080 --> 02:49:59.080]  примерно вот так вот вектор нужно дабажно выводить
[02:49:59.080 --> 02:50:01.080]  что значит просто вывести вектор
[02:50:01.080 --> 02:50:03.080]  через запятую через пробел
[02:50:03.080 --> 02:50:05.080]  через что
[02:50:05.080 --> 02:50:07.080]  это нужно руками сделать
[02:50:09.080 --> 02:50:11.080]  да у нас еще целый
[02:50:11.080 --> 02:50:13.080]  барау чекер впереди
[02:50:17.080 --> 02:50:19.080]  ну что будем
[02:50:19.080 --> 02:50:21.080]  будем барау чекер добивать
[02:50:25.080 --> 02:50:27.080]  так ну
[02:50:27.080 --> 02:50:29.080]  сейчас
[02:50:29.080 --> 02:50:31.080]  135 слайдов
[02:50:31.080 --> 02:50:33.080]  то есть еще 20 слайдов
[02:50:33.080 --> 02:50:35.080]  справитесь с
[02:50:35.080 --> 02:50:37.080]  домашней бизнесом
[02:50:37.080 --> 02:50:39.080]  так а сейчас
[02:50:39.080 --> 02:50:41.080]  погодите две секундочки
[02:50:41.080 --> 02:50:43.080]  ну все давайте хотя бы
[02:50:43.080 --> 02:50:45.080]  барау чекер добить
[02:50:45.080 --> 02:50:47.080]  у нас есть вот
[02:50:49.080 --> 02:50:51.080]  вот фанкшн
[02:50:51.080 --> 02:50:53.080]  мы когда пытаемся
[02:50:53.080 --> 02:50:55.080]  написать T32
[02:50:55.080 --> 02:50:57.080]  то раз говорят что
[02:50:57.080 --> 02:50:59.080]  тип не соответствует
[02:50:59.080 --> 02:51:01.080]  что мы хотели вернуть T32
[02:51:01.080 --> 02:51:03.080]  вернули июнь
[02:51:03.080 --> 02:51:05.080]  ну а как тогда работает такой вот код
[02:51:07.080 --> 02:51:09.080]  тут написали
[02:51:09.080 --> 02:51:11.080]  он же не возвращает
[02:51:11.080 --> 02:51:13.080]  T32 как же он работает
[02:51:13.080 --> 02:51:15.080]  но есть такой специальный тип
[02:51:15.080 --> 02:51:17.080]  не населенный переводится
[02:51:19.080 --> 02:51:21.080]  вот этот тип отличается тем
[02:51:21.080 --> 02:51:23.080]  что он никогда не сконструируется
[02:51:23.080 --> 02:51:25.080]  это Rust прекрасно знает
[02:51:25.080 --> 02:51:27.080]  и поэтому если что-то возвращает
[02:51:27.080 --> 02:51:29.080]  инхабитат
[02:51:29.080 --> 02:51:31.080]  то он никогда не сконструируется
[02:51:31.080 --> 02:51:33.080]  поэтому если что-то возвращает
[02:51:33.080 --> 02:51:35.080]  то он знает что
[02:51:35.080 --> 02:51:37.080]  дальше код не пойдет
[02:51:37.080 --> 02:51:39.080]  и соответствующая оптимизация применяет
[02:51:39.080 --> 02:51:41.080]  кстати говоря
[02:51:41.080 --> 02:51:43.080]  как раз про loop будет
[02:51:43.080 --> 02:51:45.080]  то что я говорил про loop
[02:51:45.080 --> 02:51:47.080]  то что у нас
[02:51:47.080 --> 02:51:49.080]  был while и loop
[02:51:49.080 --> 02:51:51.080]  чем они отличаются
[02:51:51.080 --> 02:51:53.080]  Rust знает про то
[02:51:53.080 --> 02:51:55.080]  что while выполняется пока условие
[02:51:55.080 --> 02:51:57.080]  даже если вы напишите while true
[02:51:57.080 --> 02:51:59.080]  Rust все равно не будет оптимизировать
[02:51:59.080 --> 02:52:01.080]  как будто он бесконечно
[02:52:01.080 --> 02:52:03.080]  исполняется
[02:52:03.080 --> 02:52:05.080]  а если вы напишете loop
[02:52:05.080 --> 02:52:07.080]  и внутри не будет никаких брейков
[02:52:07.080 --> 02:52:09.080]  всего такого
[02:52:09.080 --> 02:52:11.080]  то Rust будет об этом прекрасно знать
[02:52:11.080 --> 02:52:13.080]  и соответственно он сможет сделать
[02:52:13.080 --> 02:52:15.080]  соответствующей оптимизации
[02:52:15.080 --> 02:52:17.080]  что эта функция никогда не возвращается
[02:52:17.080 --> 02:52:19.080]  то есть отличаются эти штуки
[02:52:19.080 --> 02:52:21.080]  информация о потоке управления
[02:52:25.080 --> 02:52:27.080]  это примерно то же самое
[02:52:27.080 --> 02:52:29.080]  у нас может быть простая структура
[02:52:29.080 --> 02:52:31.080]  а inhabited type это то же самое
[02:52:31.080 --> 02:52:33.080]  что просто и нам
[02:52:33.080 --> 02:52:35.080]  его нельзя сконструировать
[02:52:35.080 --> 02:52:37.080]  потому что у него нет никаких значений
[02:52:37.080 --> 02:52:39.080]  можно мемчик посмотреть
[02:52:39.080 --> 02:52:41.080]  я надеюсь
[02:52:41.080 --> 02:52:43.080]  что вам первая лекция понравилась
[02:52:43.080 --> 02:52:45.080]  и что вы
[02:52:45.080 --> 02:52:47.080]  на ней не погибли
[02:52:47.080 --> 02:52:49.080]  хотя у меня есть чувство
[02:52:49.080 --> 02:52:51.080]  что примерно на матче все посыпались
[02:52:57.080 --> 02:52:59.080]  это ключевая механика
[02:52:59.080 --> 02:53:01.080]  того как работает
[02:53:01.080 --> 02:53:03.080]  безопасность Rust
[02:53:03.080 --> 02:53:05.080]  там есть понятие того
[02:53:05.080 --> 02:53:07.080]  что у первеных есть владение
[02:53:11.080 --> 02:53:13.080]  я думаю что лучше перенести
[02:53:17.080 --> 02:53:19.080]  тогда всем спасибо
[02:53:19.080 --> 02:53:21.080]  всем пока
