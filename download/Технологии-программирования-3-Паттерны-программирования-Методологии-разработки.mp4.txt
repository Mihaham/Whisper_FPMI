[00:00.000 --> 00:10.720]  Всем доброго дня, мы с вами продолжаем курс по технологиям программирования, и сегодня у нас не
[00:10.720 --> 00:17.280]  заработал проектор, да, то есть как говорится, мы тут про софт, но hardware нам тоже важен,
[00:17.280 --> 00:24.520]  поэтому я сегодня буду рассказывать все на доске, посмотрим как это пойдет, но в целом все тезисы
[00:24.520 --> 00:30.680]  есть в презентациях, давайте вспомним, на чем мы с вами остановились в прошлый раз, что мы с вами
[00:30.680 --> 00:40.680]  успели пройти в прошлый раз, да, мы с вами ввели четыре аббревиатура, значит первое это solid,
[00:40.680 --> 00:51.160]  какие еще были аббревиатура, да, значит давайте я их расположу в порядке снизу вверх,
[00:51.160 --> 00:59.920]  значит первое у нас идет ягни, нам этого не надо, после этого идет кис, мы стараемся все содержать
[00:59.920 --> 01:07.520]  как можно проще, дальше у нас do not repeat yourself и после этого у нас только идет solid и применение
[01:07.520 --> 01:15.080]  паттернов проектирования, то есть именно в таком порядке нам важно именно использовать эти принципы,
[01:15.320 --> 01:22.120]  то есть сначала выкидываем все лишнее, особенно когда мы говорим это про техническое задание какое-нибудь,
[01:22.120 --> 01:28.920]  вот вы составляете техническое задание и думаете так, что именно сделать, и вы такие думаете-думаете-думаете,
[01:28.920 --> 01:35.720]  а потом говорят, типа вы не прописываете чего-то, чего вы не будете делать и потом вам прилетает,
[01:35.720 --> 01:41.440]  так сказать, требование, а почему вы не сделали того, что мы хотели, хотя по факту вы не
[01:41.440 --> 01:47.840]  регламентировали то, что вы этого не делаете, в общем здесь у нас указываются как раз принципы,
[01:47.840 --> 01:54.960]  значит это параллельно презентации, и на самом деле мы с вами начали рассматривать первые паттерны,
[01:54.960 --> 02:04.920]  мы с вами рассмотрели один паттерн, кто помнит какой, да, мы посмотрели с вами фабричный метод,
[02:04.920 --> 02:15.760]  это пример порождающего паттерна, к сожалению, сегодня у меня будет уходить некоторое время на
[02:15.760 --> 02:27.200]  стирание с доски, давайте как раз вспомним к какому типу паттернов этот паттерн относится,
[02:27.200 --> 02:34.400]  это порождающий паттерн, это структурный паттерн или это, да, это порождающий паттерн,
[02:34.400 --> 02:41.960]  вот, и как раз мы сказали, что он полезен для создания объектов, для того, чтобы у нас не
[02:41.960 --> 02:49.600]  нарушался принцип open-closed, и сейчас мы с вами посмотрим еще один пример, собственно мы
[02:49.600 --> 02:54.440]  смотрели пример с буквой о, и сейчас мы с вами закроем так называемый технический долг и
[02:55.080 --> 03:02.040]  рассмотрим пример с буквой D, это dependency inversion, давайте вспомним, что это, что это за
[03:02.040 --> 03:08.520]  принцип-то такой, вкратце мы его можем нарисовать таким образом, что у нас с вами есть некоторый
[03:08.520 --> 03:15.080]  прямоугольник, то есть у нас есть два класса, которые зависят каким-то образом от третьего класса,
[03:15.080 --> 03:28.120]  да, то есть у нас есть класс B и C, и мы сказали, что у нас с вами детали не должны зависеть от
[03:28.120 --> 03:34.240]  абстракции, то есть что мы с вами сделали, мы с вами сказали, что у нас здесь будет два интерфейса,
[03:34.240 --> 03:44.840]  интерфейс E, интерфейс F, собственно, вот этот вот метод будет реализовывать два
[03:44.840 --> 03:57.520]  интерфейса, а значит B и C будут использовать эти интерфейсы, вот, то есть картинка у нас
[03:57.520 --> 04:05.320]  будет выглядеть вот таким образом, тем самым мы с вами можем успешно адаптировать наш код,
[04:05.320 --> 04:14.080]  и вот каким образом реализовывается этот паттерн, этот метод на самом деле, он зачастую использует
[04:14.080 --> 04:18.000]  так называемые обертки, они же являются адаптерами, то есть наша цель сейчас
[04:18.000 --> 04:32.520]  посмотреть в чем заключается паттерн-адаптер, так, значит мы с вами рассматриваем паттерн-адаптер,
[04:32.520 --> 04:43.840]  как раз мы вчера с вами опубликовали первое проектное задание, и вы начали спрашивать,
[04:43.840 --> 04:48.080]  какие библиотеки можно использовать, какие библиотеки нельзя использовать, было такое,
[04:48.080 --> 04:55.560]  начали уже спрашивать, вот, и оказывается, что некоторые библиотеки ну прямо реально монструозные,
[04:55.560 --> 05:00.160]  кто-то у меня спросил, можно ли использовать unity, но мы с вами понимаем, что unity это такой вот
[05:00.160 --> 05:06.320]  комбайнер, который не очень целесообразно использовать для написания всяких игр,
[05:06.320 --> 05:10.960]  ну, точнее для игр удобно писать, но если мы хотим проецировать какую-то более крупную систему,
[05:10.960 --> 05:17.200]  то, соответственно, там ее каким-то образом наследовать, то это будет не очень хорошо,
[05:17.200 --> 05:24.160]  поэтому наша цель посмотреть, а можем ли мы использовать какую-то другую совместимость для
[05:24.160 --> 05:30.240]  того, чтобы мы могли с вами работать с библиотекой, значит, смотрите, важный момент, который заключается
[05:30.240 --> 05:38.080]  здесь, вот представьте, вы написали некоторую функцию, которая там, не знаю, вычисляет какие-то
[05:38.080 --> 05:44.880]  величины, грубо говоря, функцию для вычисления математики, либо для конвертации типов, вы при
[05:44.880 --> 05:52.920]  этом зависите от какой-то конкретной библиотеки, то есть вы сказали, что у вас есть класс А, значит,
[05:52.920 --> 06:06.840]  он использует какой-то класс В в том плане, что он вызывает функцию x, y, с какими-то параметрами x, y,
[06:06.840 --> 06:15.040]  и что у нас с вами выходит, представьте себе, что разработчики библиотеки В, а это какая-то
[06:15.040 --> 06:24.160]  сторонняя система, допустим, меняет сигнатуру функции, что означает, меняет сигнатуру, то есть
[06:24.160 --> 06:29.200]  меняет параметр, с которыми она вызывается и меняет то, что она возвращает, соответственно,
[06:29.200 --> 06:39.280]  в чем возникает проблема в данной картинке? Да, мы уже вызываемся к несуществующей библиотеке,
[06:39.280 --> 06:43.840]  у нас, возможно, даже сигнатура функции совпадать не будет, ладно, если мы это обнаружим на стадии
[06:43.840 --> 06:49.560]  компиляции нашего проекта, но если мы с вами обнаружим это на стадии рантайма, стадии исполнения
[06:49.560 --> 06:56.680]  проекта, это будет намного опаснее, потому что те же самые динамические библиотеки, такие как
[06:56.680 --> 07:04.680]  Python и другие вещи, либо если мы работаем с вами с динамическими библиотеками, у нас может
[07:04.680 --> 07:11.040]  случиться такое, что опа, мы подключаем библиотеку, вроде даже линковка произошла, а на время запуска
[07:11.040 --> 07:15.520]  проекта у нас говорится, что такой библиотеки нет, все, у нас все не работает, или у вас,
[07:15.520 --> 07:20.800]  допустим, версия библиотеки обновилась, а обратной совместимости нет. Что такое обратная
[07:20.800 --> 07:26.360]  совместимость? Это вы, когда, образно говоря, берете какой-нибудь код, который написан на версии Python
[07:26.360 --> 07:37.920]  3.6 и пытаетесь запустить на версии Python 3.7. Что означает концепция, которая стоит здесь? Здесь
[07:37.920 --> 07:48.800]  мне, наверное, нужно рассказать про такую вещь, как семантик вершининг. Что такое семантик вершининг?
[07:48.800 --> 07:57.640]  Это специальный способ нумерации версии нашего продукта, который состоит из трех составных
[07:57.640 --> 08:13.040]  пунктов обычно. Значит, здесь указываются точки. У нас с вами есть так называемая мажорная версия,
[08:13.040 --> 08:28.240]  у нас с вами есть минорная версия и есть патч-версия. Давайте проведем мысленный
[08:28.240 --> 08:35.200]  эксперимент. У кого ноутбук с собой? У всех ноутбук. Давайте попробуем в командной строке написать
[08:35.200 --> 08:45.600]  Python минус V. По-моему, такая команда. Сейчас я проверю у себя локально. Скажите, какая версия
[08:45.600 --> 09:10.040]  Python у вас используется? Python минус V. Я проверил. У кого что написано? 3.11.7. У кого еще что?
[09:16.080 --> 09:30.880]  Давайте свой компьютер назову. 3.11.6. Что еще? Давайте зайду на свой домашний компьютер, тоже там сделаю.
[09:30.880 --> 09:55.120]  На моем домашнем компьютере 3.10.10. Кто-то еще хочет назвать версию? Ладно. Представьте,
[09:55.120 --> 10:03.040]  что есть какой-то компьютер, который давно не включался. Лет так 5.7. Тогда у него будет версия
[10:03.040 --> 10:13.360]  допустим 2.7.13. То есть будет вторая версия Python. Что означают вот эти разные версии? Мы видим,
[10:13.360 --> 10:19.600]  что где-то у нас отличаются первые цифры, где-то отличаются уже вторые числа, где-то третья. У нас
[10:19.600 --> 10:26.200]  есть большое количество примеров. Смотрите, когда мы меняем мажорную версию, это означает,
[10:26.200 --> 10:32.720]  что код, который запускается на более новой версии, может не запуститься на старой версии. Это
[10:32.720 --> 10:40.800]  ломает обратную совместимость. То есть мы с вами понимаем, что код, который запускается на версии
[10:40.800 --> 10:55.400]  Python 3, не запустится на версии Python 2. Классический пример. В Python 3 что такое print? Функция. А в Python 2
[10:55.400 --> 11:05.400]  print это была команда. То есть она писалась без круглосковок. Вот. То есть видите, уже есть обратная
[11:05.400 --> 11:12.180]  совместимость, и код на Python 3 без некоторых учрених не запустится на Python 2. То есть когда мы
[11:12.180 --> 11:19.080]  меняем мажорную версию, то зачастую мы ломаем обратную совместимость. Вот. Если у нас есть
[11:19.080 --> 11:25.120]  минорная версия, меняется минорная версия, то мы меняем какую-то функциональность. Возможно,
[11:25.120 --> 11:30.000]  добавляем новую функциональность, но при этом сохраняем обратную совместимость. То есть код,
[11:30.000 --> 11:39.920]  который написан на Python 3.11.7, будет запускаться на версии Python 3.10.10. Точнее, наоборот, код,
[11:39.920 --> 11:49.400]  который написан на версии Python 3.10.10, будет запускаться на Python 3.11.7. Вот. А вот эта вот
[11:49.400 --> 11:55.680]  штука, она меня, если мы идем в патч-версию, это означает, что мы вносим небольшие правки,
[11:55.680 --> 12:02.920]  которые по факту устраняют какие-то проблемы. То есть мы исправляем какие-то баги, не меняя
[12:02.920 --> 12:10.920]  основной функциональности нашей системы. Так. Теперь смотрите. Представим себе в этом примере,
[12:10.920 --> 12:20.480]  что у нас Python 3.10.10 решил внести новую функциональность, и у нас по факту меняется
[12:20.480 --> 12:25.200]  сигнатура некоторых функций. То есть мы не правим баги, меняется сигнатура некоторых функций. Как вы
[12:25.200 --> 12:34.200]  думаете, какая следующая версия за ней будет? Есть мысли? Обратная совместимость сохраняется.
[12:34.200 --> 12:46.960]  3.11.0. То есть новая версия у нас стирает новый, старый указатель. То есть когда мы переходим
[12:46.960 --> 12:54.000]  в версии 3.10.10, то мы переходим на версию 3.11.0. Если мы не меняем обратную совместимость,
[12:54.160 --> 12:59.720]  если мы сохраняем обратную совместимость, но при этом у нас какой-то patch fix, то мы идем в
[12:59.720 --> 13:09.640]  версию 3.10.11. Вот. А если мы меняем мажорную версию, то тогда мы переходим в 4.0.0. Версия
[13:09.640 --> 13:17.320]  Python 4.0.0. Ну, наверное, это произойдет тогда, когда в Python ведут типизацию. Причем какой-нибудь
[13:17.320 --> 13:24.240]  строгой типизацию. А об этом разговоры ведутся. Но, как ни странно, какие-то вот фундаментальные
[13:24.240 --> 13:30.040]  версии продуктов, если мы с вами говорим, они зачастую не получают так или иначе четвертую
[13:30.040 --> 13:38.120]  версию. Как-то сложилось. Вы, наверное, знаете, есть такая игра Half-Life. Слышали? Все ожидают
[13:38.120 --> 13:46.480]  там третью версию Half-Life, а ее все еще нет. Вот так же и здесь. В Python 3 до сих пор, наверное,
[13:46.720 --> 13:52.920]  четвертую версию Python не дождутся. Если мы с вами говорим про такой инструмент, который мы будем
[13:52.920 --> 14:00.520]  с вами разбирать под названием CMake. Это система сборки для проектов на C++. Там тоже нет четвертой
[14:00.520 --> 14:15.280]  версии. Там 3.28. Что-то. Какие из проектов еще? Есть оболочка для рабочего стола GNOME. Там,
[14:15.280 --> 14:20.280]  как ни странно, тоже четвертой версии не дождались. И решили сделать следующую. Поскольку у нас
[14:20.280 --> 14:26.760]  ядро системы достаточно сильно устоялось, то мы меняем нумерацию нашей версии и просто отбрасываем
[14:26.760 --> 14:32.280]  то, что у нас происходит в мажорной версии. То есть в какой-то момент времени может случиться такое,
[14:32.280 --> 14:39.800]  что с библиотекой у вас была версия, допустим, 3.12.1, 3.13.2, 3.14. И так далее. Потом понимаем,
[14:39.800 --> 14:45.880]  что проект устоялся. Мы откидываем эту мажорную версию. У нас версия GNOME теперь 14, 15, 16, 17,
[14:45.880 --> 14:54.160]  18, 19, 20 и так далее. То есть такое тоже вполне может быть. И это касается, допустим, джавы.
[14:54.160 --> 14:58.560]  Языка программирования джавы, в которой мы говорим, что у нас существует обратная совместимость
[14:58.560 --> 15:05.400]  полностью. И это там гарантируется самим языком программирования. Поэтому до версии,
[15:05.400 --> 15:11.600]  допустим, 1.7 была версия 1.8, а дальше отбросили единичку и начали называть версии джавы,
[15:11.600 --> 15:18.080]  9, 10, 11 и так далее. В каких-то продуктах, если мы говорим про версионность цикла, то они
[15:18.080 --> 15:29.080]  нумируются именно даты выпуска. Давайте попробуем привести примеры того, какие продукты
[15:29.080 --> 15:38.920]  нумируются именно версии выпуска. C++ мы про стандарт больше говорим. Да, стандарт C++ нумируется
[15:38.920 --> 15:51.320]  годом. Еще? Да, Windows сейчас, если посмотреть версии сборки, там 22х, 22х. Я честно забываю,
[15:52.080 --> 16:06.800]  по-моему, 22х и что-то там. Еще? Вы не поверите, я буду вангой, если я скажу, что через два месяца
[16:06.800 --> 16:29.320]  выйдет Ubuntu 24.04. Давайте подумаем. 24-й год, апрель. То есть новая версия Ubuntu выходит раз
[16:29.320 --> 16:39.160]  в полгода. Вот. То есть тоже есть такие нумерации. Так вот, ладно. Это у нас был разговор вообще про
[16:39.160 --> 16:45.960]  баторный адаптер, но мы вышли на версионирование нашего продукта. Тоже крайне полезная вещь для
[16:45.960 --> 16:50.320]  прежней разработки, чтобы вы понимали, каким образом вы можете нумировать ваши версии продукта.
[16:50.320 --> 16:57.200]  Если у вас есть проект какой-то, то у вас получится интересная нумерация, скорее всего. Версии до
[16:57.200 --> 17:05.760]  первой, в semantic versioning есть важная особенность, что версии до первой обычно меняют только
[17:05.760 --> 17:11.760]  минорную версию, мажорную не меняют. То есть у вас получится так, что по факту в итерациях
[17:11.760 --> 17:19.720]  проекта вашего у вас будет версия 0.1, 0.2, 0.3 и, собственно, к концу семестра у вас появится версия
[17:19.720 --> 17:29.080]  1.0. Да. То есть вы можете прямо использовать версионирование. Причем, если мы говорим про
[17:29.080 --> 17:38.280]  версионирование, на семинарах гид все прошли? Вот. Мы можем эти версии привязывать при помощи
[17:38.280 --> 17:44.520]  именованных коммитов. То есть эти коммиты называются теги. То есть вместо команды
[17:44.520 --> 17:50.760]  git-commit, которая двигает ветку, вы можете указать команду git-tech и у вас появится указатель на
[17:50.760 --> 17:58.800]  commit. Допустим, вы можете сказать git-tech там, не знаю, 3.10.10. И у вас появится commit с версией
[17:58.800 --> 18:04.680]  3.10.10. Тогда другие разработчики легко могут понять, что вот вам нужно перейти на конкретную
[18:04.680 --> 18:12.800]  эту версию, чтобы ее, допустим, скачать, склонировать, собрать и так далее. Так, это понятно. Хорошо,
[18:12.920 --> 18:17.960]  мы тут заговорились про адаптер. Давайте теперь я покажу, собственно, каким образом
[18:17.960 --> 18:25.680]  реализовывается адаптер. Собственно, цель адаптера будет состоять в том, чтобы отвязаться от прямой
[18:25.680 --> 18:32.000]  зависимости через как раз механизм dependency inversion. То есть нам нужно, допустим, принять
[18:32.000 --> 18:39.800]  какой-то файл. Представьте, мы принимаем какой-то архивный файл. Он в формате zip. А нам
[18:39.800 --> 18:45.000]  нужно, допустим, не знаю, прислать картинку. Тогда что мы можем под капотом сделать? Мы можем с вами
[18:45.000 --> 18:50.800]  разархивировать эту картинку, разархивировать архив и вытащить из него картинку. Это будет
[18:50.800 --> 18:57.400]  делаться под капотом. Собственно, теперь давайте я нарисую диаграмму, которая позволит это нам
[18:57.400 --> 19:02.880]  сделать. Значит, смотрите, представим себе, что у нас есть A. Это определенный клиент.
[19:09.800 --> 19:22.960]  И он хочет использовать некоторую функцию B. Так, это у нас класс A. И вот у нас есть код функции,
[19:22.960 --> 19:38.400]  которую мы хотим вызвать. Тогда мы делаем следующее. Мы говорим, окей, давайте мы здесь создадим этот
[19:38.400 --> 19:53.760]  метод под названием adapter. Здесь у нас будет, давайте назовем его service method. А у адаптера будет
[19:53.760 --> 20:08.480]  сам метод. Это у нас будет интерфейс. Адаптер-интерфейс. Вот. И у него, напомню, что у интерфейсов у нас
[20:08.480 --> 20:16.080]  есть только методы. И они являются публичными. Тогда наш адаптер, который будет сделать, он будет
[20:16.080 --> 20:23.440]  делать следующее. У него будет своя собственная реализация метода, которая будет вызывать этот
[20:23.440 --> 20:34.240]  метод. То есть класс A будет хранить в себе реализацию вот этого интерфейса. То есть ссылку на вот этот
[20:34.240 --> 20:40.480]  объект, на экземпляр этого интерфейса. Тогда смотрите, в чем удобство. Представьте себе,
[20:40.480 --> 20:54.120]  что у нас была версия продукта, там не знаю, B, была версия там 3.4, а мы переходим на версию
[20:54.120 --> 21:06.920]  продукта V4.0. То есть смотрите, у нас вместо B появляется B'. Что нам нужно сделать с этой
[21:06.920 --> 21:15.760]  картинкой, чтобы все работало? Да, смотрите, нам нужно будет переписать только адаптер. И адаптер
[21:15.760 --> 21:30.320]  можно будет легко заменить. Допустим, это будет плюс, допустим, метод V4, если у нас не сохраняется
[21:30.320 --> 21:38.320]  обратная совместимость. А внутри, на самом деле, тут мы можем делать все что угодно. Допустим,
[21:38.320 --> 21:44.360]  мы можем даже взять вот этот вот метод, который у нас есть, там вызвать его, а дальше сконвертировать
[21:44.360 --> 21:52.120]  результаты в четвертую версию. Все, то есть смотрите, чем это удобно? Мы хотим использовать
[21:52.120 --> 22:00.160]  какой-нибудь внешний интерфейс, внешние функции, и мы можем с вами их как раз вполне легко использовать.
[22:00.160 --> 22:15.960]  Вот, давайте подумаем, в чем плюс и минус этих подходов. Да, если что-то менять, то нам нужно
[22:15.960 --> 22:23.840]  менять именно в одном месте. Да, минус и плодим кучу классов. Ну, здесь мы говорим следующее,
[22:23.840 --> 22:30.280]  что мы, в принципе, работаем в парадигме ООП, и наша цель именно качество нашего продукта,
[22:30.280 --> 22:40.920]  именно, так сказать, выполнение нашего кода в визуальной архитектуре, чтобы это все было и успешно
[22:40.920 --> 22:45.040]  работало. То есть большое количество классов, в принципе, не проблема, если мы эти классы грамотно
[22:45.040 --> 22:51.480]  организуем. И здесь есть, опять же, практики написания кода, которые заключаются в следующем,
[22:51.720 --> 22:59.440]  чтобы визуально видеть наш проект, недостаточно его писать в одном файле. А, допустим, у вас есть
[22:59.440 --> 23:14.800]  какой-то класс, вы берете, допустим, и создаете, образно говоря, следующее. Вы делаете следующую
[23:14.800 --> 23:25.480]  вещь. Вот у вас есть, допустим, какой-нибудь класс, типа, бейс-класс, ну и, допустим, у него там
[23:25.480 --> 23:37.040]  наследники, какие там, сквер, триангл, серкал и так далее. Ну, понятно, что это нарушает принцип
[23:37.040 --> 23:42.480]  замены баррелизков, но что мы с вами можем сделать? Мы с вами можем сделать следующее, что вместо того,
[23:42.480 --> 23:56.520]  чтобы эти классы написать в одном файле, написать для него каждый файл, допустим, точка cpp. А вот это
[23:56.520 --> 24:08.280]  вот все вынести в директорию под названием shapes. То есть у нас получается вот такая структура пакетов,
[24:08.280 --> 24:14.280]  с которой мы с вами легко можем работать. Да, поэтому, если вы будете оформлять свои проекты,
[24:14.280 --> 24:19.320]  то, пожалуйста, делайте вот таким образом. Если мы говорим про cpp-шные проекты, то там
[24:19.320 --> 24:27.560]  бывает еще одно разделение, что у нас в папке src хранятся cpp-шные файлы, а папке include у нас
[24:27.560 --> 24:36.720]  хранится хедера. То есть это прям можно разводить, и не бойтесь о том, что проект у вас не скомпилируется,
[24:36.720 --> 24:40.920]  допустим, для этого как раз есть системы сборки, которые будут подсказывать, где ваша директория,
[24:40.920 --> 24:51.200]  где ваш файл находится. Как раз один из следующих семинаров будет посвящен как раз Semeiko. Так,
[24:51.200 --> 25:00.640]  давайте я остановлюсь и спрошу, есть ли у вас вопросы по этой вещи. Да, вопросы крайне желательно
[25:00.640 --> 25:16.840]  задавать. Да, про все что угодно на самом деле, любые обертки. Собственно, иногда это называют еще
[25:16.840 --> 25:22.760]  в рапперам, но здесь именно мы говорим про то, что он называется, паттерн называется адаптер.
[25:30.640 --> 25:40.120]  Смотрите, значит, почему здесь интерфейс. Мы, смотрите, отвязываемся от конкретной
[25:40.120 --> 25:46.120]  реализации, то есть как бы наша суть будет состоять в том, что у нас метод, который здесь есть,
[25:46.120 --> 25:58.880]  он просто должен вызвать какой-то, так сказать, как бы сказать, а почему мы именно напрямую не
[25:58.880 --> 26:12.000]  вызываем их. Смотрите, это будет связано с кодом, который будет написан. Давайте попробуем написать
[26:12.000 --> 26:24.760]  код. У вас просто может быть такое, что оно даже не скомпилируется, то есть у нас что получается,
[26:25.440 --> 26:40.280]  допустим, мы создаем с вами аинтерфейс. Что у нас получается? Аинтерфейс, как называть,
[26:40.280 --> 26:51.800]  давайте AD назовем его. Да, тут я пишу вот так вот. U-адаптер, то есть здесь именно особенности
[26:51.800 --> 27:05.680]  op играют. Допустим, a.ad, ad. Опять же, тут нужно сеттеры. Ну и дальше мы вызываем a.metod. То есть на
[27:05.680 --> 27:13.480]  этапе компиляции у нас это будет работать. А теперь представьте себе, что, допустим, у нас,
[27:13.480 --> 27:20.440]  когда есть интерфейс, мы можем, допустим, поверх него поставить какой-нибудь абстрактный класс и
[27:20.440 --> 27:30.040]  сделать свое собственное дерево наследования. И тогда нам это позволит сделать. Мы просто должны
[27:30.040 --> 27:37.520]  заменить дочерний класс. Более того, мы можем, допустим, типизацию сделать. В зависимости от того,
[27:37.520 --> 27:42.440]  какой аргумент нам принимается, мы, собственно, переопределяем этот дочерний класс. То есть по
[27:42.440 --> 27:47.880]  факту, что у нас происходит? Когда нам нужно перейти на новый класс, нам нужно поменять здесь в
[27:47.880 --> 27:54.960]  одном месте вызов этого кода. Либо, допустим, сказать, что нам нужно провести какое-нибудь
[27:54.960 --> 28:01.160]  тестирование, проверить быстродействия разных версий API, программируем интерфейс. То есть вот
[28:01.160 --> 28:08.600]  эта версия и вот эта версия. Мы меняем здесь вызов кода и по факту мы скрываем все детали
[28:08.600 --> 28:19.400]  реализации, которые у нас происходят под капотом. То есть минимальные изменения кода – это как раз
[28:19.400 --> 28:25.120]  главное свойство, про которое мы с вами должны говорить. Это свойство называется поддерживаемость
[28:25.120 --> 28:34.120]  продукта. То есть чем более поддерживаемый продукт, тем просто нам с ним приятнее работать. Так, я
[28:34.120 --> 28:48.520]  ответил на вопрос? Хорошо. Так. Адаптер, да. Адаптер – это структурный паттерн. Так, хорошо.
[28:48.520 --> 28:56.720]  Значит, мы с вами рассмотрели пример dependency version. И давайте рассмотрим первый антипаттерн,
[28:56.720 --> 29:11.200]  который есть с нарушением этой структуры. Значит, смотрите, что мы с вами поняли. Мы с
[29:11.200 --> 29:23.960]  вами поняли в солиде, мы закрыли с вами букву D, мы с вами закрыли букву O. Какие буквы мы с
[29:24.000 --> 29:31.320]  вами еще не закрыли? Мы не закрыли с вами буквы S, L и I. Значит, про interface segregation мы с вами по
[29:31.320 --> 29:38.600]  факту показали тоже примеры использования его. Ну и про солид немного тоже поговорили. Теперь
[29:38.600 --> 29:49.240]  осталось поговорить про S. И здесь получается так, что вместо того, чтобы привести паттерн,
[29:49.240 --> 29:55.840]  мы будем с вами приводить антипаттерн, то есть того, как не надо делать. И этот паттерн,
[29:55.840 --> 30:10.240]  если мы говорим русифицированно, это божественный объект. В англоязычной литературе это GodObject.
[30:10.240 --> 30:20.160]  То есть у нас есть класс, который пытается максимально сильно вобрать в себя всю
[30:20.160 --> 30:28.760]  функциональность. Вот. Как идентифицировать такие классы? Значит, первый класс, который здесь есть,
[30:28.760 --> 30:36.640]  это если у вас класс называется системы, наверное, что-то с вашей системой не так. Почему? Потому что
[30:36.640 --> 30:42.200]  в систему можно впихнуть все что угодно. И это превращается в GodObject. Потом мы с вами еще
[30:42.200 --> 30:51.160]  приводили пример под названием... Так. Какой еще у нас был пример? Университет, допустим. То есть
[30:51.160 --> 30:59.160]  это все объемлющие объекты из нашей предметной области. То есть такие лучше исчленять. Вот.
[30:59.640 --> 31:07.960]  И еще есть один паттерн, который, в принципе, практически иногда называют антипаттерном. Это
[31:07.960 --> 31:18.760]  паттерн-одиночка. Сингл тон называется. На семинарах прямо посмотрите его реализацию. Суть этого
[31:18.760 --> 31:27.120]  паттерна состоит в следующем. Чтобы хранить объект всегда в единственном экземпляре. То есть цель
[31:27.120 --> 31:31.720]  состоит в том, чтобы создать объект таким образом, чтобы он у вас хранился в одном экземпляре.
[31:31.720 --> 31:48.280]  Да, нельзя было создать еще один объект того же типа. А, вам на плюсах говорили про сингл?
[31:48.280 --> 31:58.640]  А, вам даже реализацию на плюсах показали? Хорошо. Ничего себе. Обалдеть. Вот. И, значит,
[31:58.640 --> 32:04.480]  есть такая тенденция. Вот у вас система 1, университет 1. Поэтому, если вы неправильно
[32:04.480 --> 32:09.520]  реализуете сингл тон, то он легко может превратиться в got object. Вот. Про это тоже
[32:09.520 --> 32:14.560]  нужно понимать. Опять же, давайте я тогда перечислю все паттерны. Еще один паттерн,
[32:14.560 --> 32:24.160]  который может быть стать тоже got object. Это паттерн под названием фасад. Собственно,
[32:24.160 --> 32:33.000]  это то, каким образом работают так называемые программируемые интерфейсы. API, application
[32:33.000 --> 32:56.160]  programming interface. Вот пример. Классически. Заходите вы на строительство Яндекса. Ну,
[32:56.160 --> 33:03.880]  на любого сайта. Ну, давайте говорим Яру. И дальше у вас в вашем сайте летит огромное
[33:03.880 --> 33:09.160]  количество всяких загружается частей страниц. На самом деле у вас там загружается сервис погоды,
[33:09.160 --> 33:14.280]  сервис почты, сервис поиска и так далее. Это все делается параллельно, но это делается через
[33:14.280 --> 33:22.440]  одну общую точку. Зачастую. Это именно через API. То есть у вас скорее всего, когда вы посмотрите
[33:22.440 --> 33:29.120]  на сайт, у вас там будет slash API slash что-то там. Вот. То есть у вас все запросы летят сначала в одно
[33:29.120 --> 33:35.200]  место. А дальше вы эти запросы распределяете по другим тоже так называемым фасадам. То есть у вас
[33:35.200 --> 33:44.240]  по факту... Вот классический пример, чтобы вы понимали. Вот вы заходите в какой-нибудь фистех,
[33:44.240 --> 33:53.760]  образно говоря. Вот. Представьте только, что фистех был бы не вот такой вот, этот, не открытым
[33:53.760 --> 34:00.360]  университетом, а собственно вы проходили бы все через одну точку. Через один пропускной пункт. Вот.
[34:00.360 --> 34:05.400]  Вы заходите в один пропускной пункт, а дальше проходите по разным корпусам. Собственно у вас
[34:05.400 --> 34:11.120]  получается фасад. Это общая точка, в которой вы ходите. А дальше внутри фасада могут быть разные
[34:11.120 --> 34:19.520]  подфасада на каждую из компонент. Вот. И как раз тем самым вы можете, допустим, у вас API, допустим,
[34:19.520 --> 34:30.640]  slash потом music, вы идете в Яндекс.Музыку. Там slash maps, вы идете в Яндекс.Карт. То есть ваш запрос
[34:30.640 --> 34:39.560]  переадресуется. Понятно, что если вы не делаете этой переадресации, то у вас по факту будет именно
[34:39.560 --> 34:47.360]  такой объект, типа, всеобъемлющий. И это не очень хорошо делать. То есть если мы делаем вот такие
[34:47.360 --> 34:55.200]  обертки, то мы делаем их через фасад. Более того, тут есть еще один паттерн. Я не знаю, наверное,
[34:55.200 --> 35:02.640]  мы про него чуть попозже поговорим. Который позволит, собственно, ограничивать доступ. Вот. Важно,
[35:02.720 --> 35:10.360]  что? Вот. Почему это фасад? Фасад это что такое? Вот давайте попробуем форулировать. Что такое фасад?
[35:10.360 --> 35:18.800]  Лицо здания. Вы можете зайти в прекрасное здание. Оно внешне кажется красивым. Заходите внутрь,
[35:18.800 --> 35:26.440]  а там непонятно что. Вот. То есть мы как бы скрываем все, что находится под забором. Точнее,
[35:26.440 --> 35:48.040]  за забором. Вот. То есть, опять же, СРП мы с вами тоже разобрали. Да. Так и надо делать. Это нормально.
[35:48.040 --> 35:55.840]  Как раз мы говорим с вами про кохиженный каплинг. Так, хорошо. Я не знаю, как дальше мы поступать
[35:55.840 --> 36:01.560]  с вами будем. Потому что следующий блок, который я планировал рассказать, это блок про UML, про Unified
[36:01.560 --> 36:08.240]  Modeling Language. Но там именно надо смотреть на диаграммы в большом количестве. Поскольку у нас презентации
[36:08.240 --> 36:13.240]  нет, то, к сожалению, наверное, мы этот пункт с вами пропустим. Я надеюсь, в следующий раз мы с вами его
[36:13.240 --> 36:20.800]  разберем. То есть тут как именно выделять классы, какие диаграммы есть и так далее. Но я думаю, будет
[36:20.800 --> 36:29.680]  более целесообразно рассказать про это, когда вы просмотрите идеи ваших проектов. Вот. И дальше мы
[36:29.680 --> 36:35.240]  это применим. Поэтому давайте я с вами сегодня обслуживаю еще один аспект. Мы с вами начнем
[36:35.240 --> 36:42.720]  говорить про методологию разработки программного обеспечения. Это то, каким образом мы с вами будем
[36:42.720 --> 36:50.560]  разрабатывать проект. То есть это не про то, что мы сели, начали писать код и ничего не думали. А это
[36:50.560 --> 36:57.440]  про координацию процессов, которые у нас есть в наших металлогиях разработки. Что включает
[36:57.440 --> 37:05.640]  в себя методологии разработки ПО? Это подход к организации работы. И здесь нам нужно сказать,
[37:05.640 --> 37:12.200]  из каких стадий состоит методология разработки ПО? Вообще, из каких стадий состоит разработка
[37:12.200 --> 37:27.560]  проекта? Любого. Первая стадия — это проектирование. Собственно, первую часть,
[37:27.560 --> 37:35.520]  которую мы с вами занимались на курсе — это про проектирование нашей системы. То есть на
[37:35.520 --> 37:41.520]  этой стадии нам нужно будет выработать архитектуру нашего проекта, оценить риски, то есть каким
[37:41.520 --> 37:48.280]  образом, что у нас может пойти не так и какие ресурсы нам нужны. Второе — это разработка.
[37:48.280 --> 38:08.080]  Это, собственно, мы с вами код пишем. Третье — это тестирование. То есть мы с
[38:08.080 --> 38:15.320]  вами пытаемся максимально четко поддержать именно тестирование этого кода. То есть,
[38:15.320 --> 38:21.160]  как ни странно, не поверите, вот первую часть мы с вами уже разбирали. Про третью мы будем
[38:21.160 --> 38:27.680]  детально говорить про тестирование с вами и на лекциях, и на семинарах. Четвертое — это внедрение.
[38:27.680 --> 38:35.160]  И отчасти мы эту тему тоже затронем ближе к техническим заданиям в конце. И пятая вещь,
[38:35.400 --> 38:39.160]  про которую мы с вами, может быть, тоже чуть-чуть затронем — это сопровождение.
[38:39.160 --> 38:49.240]  Вот. Про разработку, про качественную разработку мы больше будем говорить с вами в концепциях
[38:49.240 --> 38:54.120]  инструментов, которые мы можем использовать для разработки, и касательно вот паттернов
[38:54.120 --> 39:00.720]  проектирования, которые нам позволят минимально сократить наш код, минимально сократить изменение
[39:00.720 --> 39:09.440]  нашего кода. Вот. Давайте теперь построим по временной шкале и поймем, если у нас есть какая-то
[39:09.440 --> 39:18.440]  итерация нашего цикла, то, собственно, каким образом осуществляется распределение этих стадий по
[39:18.440 --> 39:26.880]  проекту. Значит, они идут подряд, но, как вы думаете, они как бы идут независимо друг друга,
[39:27.840 --> 39:34.200]  или совместно? Конечно, совместно. То есть, смотрите, изначально мы большую часть времени тратим на
[39:34.200 --> 39:40.840]  планирование, то есть это же так один, на проектирование. Дальше мы переходим постепенно
[39:40.840 --> 39:46.560]  к разработке. Два. Третье — тестируем. То есть, видите, у нас даже некоторые части могут пересекаться
[39:47.000 --> 39:57.360]  между собой. Четыре. И, допустим, пятое. То есть, видите, у нас получаются такие холмы типа колоколов,
[39:57.360 --> 40:11.200]  и вот у нас получается вот таким образом идет наш проект. Преимущественно. А зависит от проекта,
[40:11.280 --> 40:15.760]  то есть, возможно, что вам проект это какой-нибудь... Смотрите, значит, тут
[40:15.760 --> 40:22.760]  бывают разные типы проектов. Опять же, если мы говорим про около научную среду,
[40:22.760 --> 40:28.040]  либо про среду производства. Если мы говорим про научную среду, то в ней выделяем следующие
[40:28.040 --> 40:35.680]  части. Значит, первое — это научные исследования, они называются NE. И как раз, значит, я тут немного
[40:35.680 --> 40:42.440]  скажу, что ближе к концу бакалавриата вы будете этим заниматься. Вам же надо диплом защищать. Вот.
[40:42.440 --> 40:49.280]  Вот вы будете заниматься научным исследованием. Дальше, значит, стадия... И тогда у нас на стадии
[40:49.280 --> 40:54.000]  сопровождения уходит очень мало времени. Нам нужно просто показать стенд, представить его и сказать,
[40:54.000 --> 40:58.640]  вот, смотрите. Типа, мы провели работу, написали вот такие-то отчеты. Собственно,
[40:58.640 --> 41:03.360]  люди могут воспользоваться результатами этого отчета, и тогда оно никуда не внедряется,
[41:03.360 --> 41:15.400]  практически. Вторая стадия — это не окр. Значит, если мы говорим про иностранную литературу,
[41:15.400 --> 41:23.440]  то, как ни странно, не окр расшифров... Это у нас, давайте расскажу. Научные исследования и опытно
[41:23.440 --> 41:32.000]  конструкторские работы. Вот. А то в иностранной литературе, в иностранных вещах это называют
[41:32.000 --> 41:44.920]  модным словом R&D. Research and development. Собственно, здесь у нас идет research. Здесь у нас идет не
[41:44.920 --> 41:49.760]  окр. И дальше у нас, собственно, промышленная разработка, промышленный проект, который мы с
[41:49.760 --> 41:56.360]  вами внедряем. То есть обычное ПО. Вот. И как раз в стадии не окр понятно, что у нас идет внедрение,
[41:56.360 --> 42:02.640]  и, собственно, продукт тоже в какой-то степени поддерживается. Но опять же, аккуратнее с поддержкой,
[42:02.640 --> 42:10.120]  потому что у нас, если мы просмотрим про какую-то стандартную версию ПО, то вот, допустим,
[42:10.120 --> 42:18.840]  там у нас осталось на этой доске убунта? О, осталось. Значит, здесь вот эта вот версия убунта,
[42:18.920 --> 42:35.400]  она будет иметь статус LTS. Long term support. То есть цикл с долгой поддержкой. Это означает,
[42:35.400 --> 42:41.320]  что обновление на эту операционную систему, то есть сопровождение, будет идти в течение пяти лет.
[42:41.320 --> 42:49.680]  То есть все баги, все проблемы безопасности будут поддерживаться в течение пяти лет.
[42:49.680 --> 42:56.000]  В отличие от версии убунта 2310, которая не имеет статус LTS и у нее время поддержки два года.
[42:56.000 --> 43:05.120]  То есть в зависимости от версии у нас может быть разная продолжительность цикла поддержки
[43:05.120 --> 43:24.480]  нашего продукта сопровождения. Да, все то же самое. Нет, ну понятно, что каждый продукт обеспечивает
[43:24.480 --> 43:31.520]  свой цикл поддержки. Более того, этот цикл поддержки может быть спокойно продлен. Вот если мы говорим
[43:31.520 --> 43:40.760]  про тот же самый Python 2, они прекратили поддержку всего этого в 2020 году, хотя изначально они
[43:40.760 --> 43:46.200]  целили, что они закрывают поддержку в 2018 году. Просто переход на новую версию, он бы затратил
[43:46.200 --> 43:54.200]  намного больше проблем, чем вот имеется сейчас. То есть если бы все резко перешли на Python 3,
[43:54.200 --> 44:03.480]  то это бы ничего не мешало. Более того, бывают такие кейсы, что разработчики специально внедряют
[44:03.480 --> 44:11.240]  такую фишку, что пожалуйста не используйте этот способ, он больше устарел. Типа он пишет,
[44:11.240 --> 44:18.880]  что этот метод deprecated, пожалуйста перейдите на новую версию. И был такой веселый момент,
[44:18.880 --> 44:26.120]  значит есть такой пакетный менеджер, он называется Poetry. Возможно кто-то сталкивался с ним, это
[44:26.120 --> 44:32.880]  пакетный менеджер, который работает параллельно pip в Python. И в общем у них была одна функция,
[44:32.880 --> 44:41.240]  которая считалась явно deprecated, и чтобы люди перестали этой пункции пользоваться, они сделали
[44:41.240 --> 44:48.080]  хитрую вещь. Они с вероятностью 5 процентов сделали следующее, что вы запускаете сборку,
[44:48.080 --> 44:52.120]  вы запускаете установку зависимости, у вас вероятности 5 процентов это не проходит.
[44:52.120 --> 45:02.360]  Ну чтобы было не явно, типа ладно перезапустим, сработает.
[45:11.240 --> 45:15.000]  Ну да, потому что эта функция была устаревшая, переходить на новую.
[45:15.000 --> 45:39.000]  Да, я говорю, что это стандартный этот, стандартный воркфлоу, стандартный рабочий процесс,
[45:39.000 --> 45:47.480]  конечно же он может идти не так. И как раз вы упоминаете про методологию, ну вообще про
[45:47.480 --> 45:53.360]  концепцию Test Dream and Development, когда сначала пишется тест, а потом пишется код. Более того,
[45:53.360 --> 45:58.360]  вы на самом деле затронули интересную методологию, мы будем ее рассматривать,
[45:58.360 --> 46:08.000]  это методология под названием V-модель, в которой выход теста, который написан на каждой стадии,
[46:08.000 --> 46:16.160]  является предварением стадии разработки. Хорошо, так, вот значит это стадия методологии,
[46:16.160 --> 46:24.560]  произвольная методология разработки, которая у нас могут быть. Так, это понятно? Хорошо,
[46:24.560 --> 46:30.880]  давайте поймем, что же влияет на выбор методологии, что может влиять, давайте ваши мысли.
[46:30.880 --> 46:48.480]  Да, спецификация проекта, еще, ну бюджет, да, строки, да. Для кого мы пишем, кстати? Еще.
[46:48.480 --> 46:58.360]  Да, какого качества и какие сертификаты у нас качества должны быть, потому что проект обычно
[46:58.360 --> 47:13.440]  должен быть сертифицирован, продукт. Масштаб проекта, да. Знаете, вы еще, наверное, не сталкивались,
[47:13.440 --> 47:21.000]  но в текущих реалиях есть такая особенность, вы читаете любой продукт и вот про стадию внедрения
[47:21.000 --> 47:29.240]  в производство. Значит, давайте опрос, у кого какая операционная система, вот именно операционные
[47:29.240 --> 47:45.080]  системы. Ну, называйте. Windows и Arch Linux. Windows, Arch Linux, так, еще. Windows, Mac OS, да. Windows Ubuntu, хорошо.
[47:45.080 --> 47:58.960]  Arch Gintu, хорошо. Так, у меня Mac Linux Mint, допустим, Windows есть. Так, а теперь вопрос,
[47:58.960 --> 48:14.920]  кто это назвал следующие операционные системы? RedOS, Alt Linux. У кого Alt Linux стоит?
[48:14.920 --> 48:25.640]  Или, допустим, дай еще похлеще, Astro Linux. А вот вы сейчас читаете какие-нибудь внедрения
[48:25.640 --> 48:30.440]  в крупных компаниях, в наших, и говорят, вам нужно внедрять ваш продукт под Astro Linux. Вот
[48:30.440 --> 48:38.120]  что делаете, то и делаете. Как хотите, так и выкручиваетесь. Вот, типа местная отечественная
[48:38.120 --> 48:44.680]  разработка. Вот, и приходится выяснять, а как же работает это Astro Linux и лицензию на нее купить
[48:44.680 --> 48:51.040]  ну, далеко не везде можно. Я, по крайней мере, не сталкивался с онлайн-дистрибьюторами их, но вот
[48:51.040 --> 49:01.080]  как бы в крупных компаниях в нашей территории, да, которые именно больше в государственном
[49:01.080 --> 49:06.160]  корпоративном секторе работают, вот там именно внедрение. А если, конечно, вы пойдете в какой-нибудь
[49:06.160 --> 49:12.160]  зеленый банк, то там тоже есть своя собственная операционная система работать. Вот, то есть,
[49:12.200 --> 49:17.560]  на самом деле, выбор металлогии может влиять много. В-первых, особенности этого проекта. Количество
[49:17.560 --> 49:25.320]  людей в проекте тоже сильно зависит. То есть, у нас могут быть сроки, бюджет, вариант поставки,
[49:25.320 --> 49:31.560]  вариант внедрения и качество этого всего. Дополнительно у нас может быть особенность команды. То
[49:31.560 --> 49:38.800]  есть, команда, из каких специалистов собрана, грубо говоря, это, возможно, какой-то стартап,
[49:38.800 --> 49:44.360]  которому нужно быстро-быстро показать какой-то прототип, а может быть еще и особенность
[49:44.360 --> 49:51.160]  заказчика. То есть, есть человек, ну или, грубо говоря, компания, которая заинтересована в этом
[49:51.160 --> 49:56.200]  проекте и это, собственно, заказчик. И он тоже может внедрять какие-то дополнительные требования.
[49:56.200 --> 50:02.080]  Допустим, может быть такая вещь, что, грубо говоря, практически каждая строчка кода должна быть
[50:02.080 --> 50:09.280]  задокументирована. И с таким тоже можно сталкиваться. Или вам, допустим, нужно предоставить
[50:09.280 --> 50:13.760]  документацию к проекте вот в таком-то формате файлов. Поэтому про документацию тоже важно
[50:13.760 --> 50:19.360]  следовать. Значит, теперь давайте поймем. Это что касается именно выбора методологии. Если мы с
[50:19.360 --> 50:28.720]  вами говорим про внешние факторы, то какие внешние факторы могут повлиять на нашу методологию?
[50:28.720 --> 50:36.240]  Вот давайте начнем с следующей вещи. Это так называемые форс-мажорные обстоятельства. То есть,
[50:36.240 --> 50:43.240]  что может относиться к форс-мажорным обстоятельствам? Значит, обычно они прописываются в договоре,
[50:43.240 --> 50:49.840]  который вы заключаете. То есть, у вас есть договор и в связи с форс-мажорными обстоятельствами
[50:49.840 --> 50:54.400]  мы можем с вами приостановить работу над нашим проектом. Ну, собственно, или поменять что-то. Вот
[50:54.480 --> 51:09.000]  давайте подумаем, какие форс-мажорные обстоятельства могут случиться. Это не форс-мажор. Обычно это
[51:09.000 --> 51:19.840]  нарушение договоренности заказчиком называется. Да, заказчик обанкротился. Да, интернет упал.
[51:24.400 --> 51:35.360]  Да, вполне возможно, как бы это печально не было. Серв разгорел, но не по нашей причине. Громко
[51:35.360 --> 51:40.560]  говоря, электричество долбануло вне, конечно же, мы за это не отвечаем. Но для этого нужно предусмотреть
[51:40.560 --> 51:48.320]  внешние бэкапы данных, чтобы понятно, чтобы данные у нас не утерялись. Еще. Ну, опять же,
[51:48.320 --> 51:55.120]  давайте наводнение, собственно, там что, цунами, ураганы и так далее. Это тоже обычные
[51:55.120 --> 51:58.640]  форс-мажорные обстоятельства. Ну, и дополнительные форс-мажорные обстоятельства тоже могут быть
[51:58.640 --> 52:03.000]  прописаны. Соответственно, если у вас случается форс-мажорное обстоятельство, то понятно,
[52:03.000 --> 52:08.720]  что продолжительство проекта может быть увеличенным. Значит, сразу говорю, что такое проект. Вот это важно.
[52:08.720 --> 52:16.440]  А проект – это некоторое мероприятие по созданию нового продукта. И вот смотрите, важная особенность,
[52:16.680 --> 52:23.360]  что у проекта всегда есть срок начала и срок его конца. То есть, я обращу внимание, что у него
[52:23.360 --> 52:33.800]  есть срок конца. Это не ремонт, который, как известно, нельзя закончить, его можно только
[52:33.800 --> 52:38.800]  приостановить. То есть, обычно говорят сроки окончания проекта. Опять же, эти сроки могут
[52:38.800 --> 52:45.440]  сдвигаться, но желательно так не делать. Более того, некоторые методологии, которые мы с вами
[52:45.440 --> 52:51.800]  будем рассматривать, вы можете заключать контракт таким образом, что типа сроки проекта могут
[52:51.800 --> 52:58.400]  быть даже пересмотрены не в дальнюю сторону на увеличение, но и на уменьшение сроков. Ну понятно,
[52:58.400 --> 53:04.600]  тогда все будут довольны. Представьте себе, вы заказчику проекта даете на готовые продукты,
[53:04.600 --> 53:10.920]  даете на три месяца раньше. Он, конечно, будет рад и, скорее всего, с вами заключит новый договор.
[53:11.280 --> 53:18.000]  Так, дальше. Значит, внешние факторы – это государственные органы и распоряжение. Это
[53:18.000 --> 53:26.600]  такой тонкий момент, с которым нужно все-таки считаться. Допустим, из таких распоряжений в
[53:26.600 --> 53:36.960]  нашей стране – это закон о хранении персональных данных. Федеральный закон номер 152. Опять же,
[53:36.960 --> 53:43.280]  если вы хотите пользоваться каким-то сервером или каким-то оборудованием, то желательно использовать
[53:43.280 --> 53:53.280]  именно данные в связи с этим законом. Там есть четыре уровня защиты, которые подозревают общие
[53:53.280 --> 54:00.000]  данные, персональные данные, персональные данные, которые касаются медицинских характеристик
[54:00.000 --> 54:05.800]  этого человека. Поэтому, если мы говорим с вами про обычные данные, которые хранятся, то это хорошо.
[54:06.680 --> 54:14.920]  Допустим, есть биомедицинские данные. Какие-то ваши антропараметрические характеристики, состав крови,
[54:14.920 --> 54:21.520]  вот это вот все. Это должно находиться на другом уровне защиты. Или, допустим, у вас есть государственное
[54:21.520 --> 54:28.760]  распоряжение, что у вас шифрование должно проходить по российским сертификатам, образно говоря. То есть,
[54:28.760 --> 54:33.440]  вы защищаете свое соединение, защита вашего соединения должна проходить по специальному
[54:33.440 --> 54:40.200]  протоколу. То есть, такое вполне тоже возможно. Вот. И если мы говорим про распоряжение, они могут
[54:40.200 --> 54:45.560]  быть следующие. Они могут быть регламентирующие, то есть, описывают порядок того, что необходимо
[54:45.560 --> 54:52.400]  делать. Они бывают запрещающими. То есть, вам запрещено, допустим, распространять данные. И если
[54:52.400 --> 54:59.520]  вы какие-то данные отдаете, то они должны быть в обезличенном виде. То есть, вы выдаете данные,
[54:59.520 --> 55:06.720]  и грубо говоря, к примеру, Вася Петров получил отл-10 за курс технологии программирования,
[55:06.720 --> 55:13.240]  сдав задание вот это на два балла, вот это на три балла, там, грубо говоря, вот это на 100-500 баллов.
[55:13.240 --> 55:18.880]  Это, собственно, строчка о том, как Вася Петров сдавал курс технологии программирования. Понятно,
[55:18.880 --> 55:24.480]  что если мы даем данные, допустим, куда-нибудь, статистически, то понятно, что вот этого Вася
[55:24.560 --> 55:29.600]  Петрова нужно исключить из этой таблицы. Просто вот, товарищи, вот статистика. Смотрите,
[55:29.600 --> 55:37.120]  собственно, каким образом этот человек сдавал это все дело. И последнее, это сертификация. То есть,
[55:37.120 --> 55:45.640]  это важно. И в нашей концепции, если мы говорим с вами про качество ПОО, то нам нужно соответствовать,
[55:45.640 --> 55:53.520]  так сказать, сертификату, так сказать, стандарту о сертификации. Обычно, если мы говорим про
[55:53.520 --> 56:02.040]  сертификацию, то это качество кода. Значит, здесь есть две спецификации, которые мы с вами будем
[56:02.040 --> 56:11.360]  смотреть. Наверное, не сегодня. Я пока что закину удочку. Это два стандарта. Значит, это ИСО. ИСО
[56:11.360 --> 56:19.920]  это Международный центр сертификации. И у него есть два стандарта по качеству программного
[56:19.920 --> 56:30.640]  продукта. Вторая версия, это ИСО 9126. Она говорит о том, что, собственно, из каких компонент состоит
[56:30.640 --> 56:37.920]  качество ПОО. И есть более новая версия стандарта, ИСО 2510, которая пришла на замену ИСО 9126.
[56:37.920 --> 56:49.000]  Значит, в данной концепции 9126 было 6 составных характеристик, 6 частей. Здесь у нас получается
[56:49.080 --> 56:59.280]  с вами 8 составных частей. То есть, некоторые две части, которые были здесь, они разделились и у нас
[56:59.280 --> 57:06.440]  получилось всего 8 частей. Одно из них, про которое мы с вами поговорили, это поддерживаемость кода.
[57:06.440 --> 57:19.160]  Это так называемое мейнтеннабилити. Там есть еще и другие. То есть, мы больше, когда мы говорим про
[57:19.160 --> 57:26.320]  проектирование, наша цель именно говорить еще и про качество нашего кода, про его поддерживаемость.
[57:26.320 --> 57:35.040]  Так, хорошо. Еще один внешний фактор, это действия конкурентов.
[57:35.040 --> 57:42.080]  Собственно, давайте подумаем, какие действия конкурентов могут быть?
[57:42.080 --> 57:46.360]  Ну, кибератаки, да, могут быть.
[57:46.360 --> 57:56.800]  Переманивание конкурентов.
[57:56.800 --> 58:09.840]  Ну, это, собственно, те же самые. Смотрите, значит, они бывают такие. Первое, это экономические.
[58:09.840 --> 58:17.640]  Ну, то есть, это какие-то вещи. Допустим, представьте себе, что ваши конкуренты начинают скупать,
[58:17.640 --> 58:25.160]  образно говоря, там не то что сотрудников, а покупать какие-нибудь объекты недвижимости.
[58:25.160 --> 58:29.880]  Либо закупают огромное количество серверов. Понятно, что у них теперь вычислительных
[58:29.880 --> 58:34.640]  мощностей становится намного больше. Второе, действия конкурентов, это управленческие.
[58:34.640 --> 58:44.480]  И вот сейчас, как раз, если мы говорим про управленческие проекты, то бывают такие скандалы.
[58:44.480 --> 58:51.560]  Я не знаю, слышали про такую компанию OpenAI? Да, и вот как раз там недавно был управленческий
[58:51.560 --> 58:58.560]  скандал, когда глава компании SEO Altman сказали, типа, ты молодец, ты, конечно, сделал чат ГПТ,
[58:58.560 --> 59:05.840]  но ты делаешь его коммерческим. Пожалуйста, идите вот, делайте свои коммерческие проекты.
[59:05.840 --> 59:11.680]  Ну, в итоге это выросло в достаточно крупный скандал и вернули, собственно, его на роль SEO,
[59:11.680 --> 59:18.480]  это Chief Executive Officer. То есть, в нашем русском языке, я бы так сказал, это перевод генеральный директор
[59:18.480 --> 59:25.000]  компании. Вот, его вернули, собственно, был скандал, ну, благо, оно не повлияло на репутацию. А
[59:25.480 --> 59:31.960]  управленческие действия, они влияют на конкуренцию, допустим. Либо, экономически, образно говоря,
[59:31.960 --> 59:39.520]  действия конкурентов, это, допустим, ваш конкурент начал выделять финансы на, вот, на неокр,
[59:39.520 --> 59:44.880]  так сказать, на раздел R&D, то есть, на исследование, для того, чтобы, допустим, улучшить новые продукты.
[59:44.880 --> 59:53.560]  Как говорится, на хайпе, там, ввести поддержку искусственного интеллекта в ваши продукты.
[59:53.960 --> 59:58.040]  Этим сейчас, кстати, большое количество компаний занимается. И есть содержательные действия
[59:58.040 --> 01:00:02.880]  конкурентов, то есть, это то, что они внедряют именно в свой собственный продукт. То есть,
[01:00:02.880 --> 01:00:08.440]  у вас появилась какая-то новая функциональность в продукте, и сразу что делают остальные конкуренты?
[01:00:08.440 --> 01:00:17.600]  Да, сразу пытаются их внедрить к себе как можно быстрее, чтобы просто не потерять темп. Вот, то
[01:00:17.600 --> 01:00:28.080]  есть, эти внешние факторы как раз могут влиять. И более того, есть очень важно, что, как ни странно,
[01:00:28.080 --> 01:00:35.400]  экономические действия конкурентов могут влиять с этими, с теми государственными органами и распоряжениями,
[01:00:35.400 --> 01:00:41.840]  которые у нас есть. Возможно, вы знаете, что если у вас есть какое-то разное количество компаний,
[01:00:41.840 --> 01:00:49.080]  вот вы крупная компания, образно говоря, тот же самый зеленый банк, и вы хотите купить компанию
[01:00:49.080 --> 01:00:59.160]  поменьше, образно говоря. Я не знаю, какие у нас есть эти сервисы доставки еды? Самокат, кстати,
[01:00:59.160 --> 01:01:08.800]  по-моему, я не помню, самокат чей, по-моему, самокат, кстати, под часть Сбера. Да-да-да. Ну вот,
[01:01:08.800 --> 01:01:17.600]  представьте себе, вы все делаете, а дальше зеленый банк хочет купить еще один систему доставки. Денег
[01:01:17.600 --> 01:01:22.120]  много, почему бы не сделать? Так вот, есть такая замечательная служба, называется федеральная
[01:01:22.120 --> 01:01:27.560]  антимонопольная служба. И, собственно, все крупные сделки, которые идут по слиянию поглощения,
[01:01:27.560 --> 01:01:33.120]  проходят через федеральную антимонопольную службу для того, чтобы не было вот таких вот больших
[01:01:33.120 --> 01:01:39.880]  конфликтов. Например, из таких классических примеров, вы знаете, что там, допустим,
[01:01:39.880 --> 01:01:46.720]  в продуктовых магазинах пятерочек, образно говоря, либо шестерочек не может быть больше, чем 25% от
[01:01:46.720 --> 01:01:52.960]  всех магазинов в городе. То есть, это именно регламентированно вот этим вот фактором,
[01:01:52.960 --> 01:01:58.760]  что вы не можете покупать вот больше, чем такое количество магазинов.
[01:01:58.760 --> 01:02:09.960]  Ну, понятно, что есть ограничения при определенном наличии. Ну, и странно,
[01:02:09.960 --> 01:02:12.440]  если в городе у нас будет один продуктовый магазин.
[01:02:12.440 --> 01:02:24.160]  Для этого открываем определение города. Город – это населенный пункт, по-моему,
[01:02:24.160 --> 01:02:30.720]  населением не менее чем 12 тысяч человек, там имеющие вот такие вот свойства. Понятно,
[01:02:30.720 --> 01:02:39.520]  что интересно, если у нас один продуктовый магазин на 12 тысяч человек. Ну, тогда по одному каждого.
[01:02:39.520 --> 01:02:53.440]  Ну, это да. Ну, тогда, ну, это, всегда есть частники, которые могут открыть небольшой
[01:02:53.440 --> 01:03:09.280]  магазинчик и начать торговать. О, рога и копыта, так сказать. Так. Да, да, да. Вот, допустим,
[01:03:09.280 --> 01:03:16.200]  кстати, пример есть в городе на Долгопрудном. Далеко ходить не надо. Хорошо, давайте тогда,
[01:03:16.200 --> 01:03:20.840]  если вот это понятно, мы начнем с вами разбирать методологи разработки, которые существуют.
[01:03:20.840 --> 01:03:29.720]  Значит, давайте я буду их рисовать. Первая методология разработки, которая появилась
[01:03:29.720 --> 01:03:52.480]  в самом начале, она называется водопадный или waterfall. Она подходит для очень маленьких проектов,
[01:03:52.480 --> 01:03:58.960]  в которых вы знаете, когда у вас есть четкое начало, четкий конец и четкие графики,
[01:03:58.960 --> 01:04:06.560]  и вы представляете прекрасно, что и как каждая часть этого проекта состоит. Давайте приведем
[01:04:06.560 --> 01:04:20.360]  пример. Вам когда сдавать следующее задание по Мотону? Ну, ладно, короче, когда-то надо. Вы
[01:04:20.360 --> 01:04:26.200]  понимаете, что вот у вас есть некоторый набор задач, которым надо решить. Более того, вам
[01:04:26.200 --> 01:04:36.040]  рассказали, по какому алгоритму решать эти задачи? Не, в большей части. Ну, какие типичные
[01:04:36.040 --> 01:04:43.200]  задачи? Ну, какие способы существуют для решения задач. Соответственно, у вас заранее есть четко
[01:04:43.200 --> 01:04:48.720]  регламентированные строки, в которых вы можете это сделать. И тогда эти стадии располагаются
[01:04:48.720 --> 01:04:58.400]  именно по водопаду. Проектирование, после этого разработка, после этого тестирование,
[01:04:58.400 --> 01:05:25.440]  внедрение, поддержка. Вот, то есть видно водопад. Движемся сверху вниз. Давайте поймем, в чем
[01:05:25.440 --> 01:05:33.840]  возникает проблема в водопадной модели. Ну, смотрите, давайте поймем, что если мы на стадии
[01:05:33.840 --> 01:05:42.880]  тестирования внезапно поймем, что у нас что-то идет не так, то все заново. То есть у нас проект
[01:05:42.880 --> 01:05:50.280]  останавливается, у нас возникают большие проблемы, и там нам надо будет платить либо неустойку,
[01:05:50.280 --> 01:05:55.240]  либо договариваться с заказчиком о том, что что-то идет не так. В нашем случае это будет
[01:05:55.240 --> 01:06:04.200]  преподаватель по мотану, который говорит, а можно, пожалуйста, нам дедлайн на неделю продлить. То есть
[01:06:04.200 --> 01:06:11.000]  вот у нас типичная проблема, которая здесь возникает. Так, давайте я сейчас следующую вещь открою.
[01:06:11.000 --> 01:06:16.600]  Значит, следующая методология, которая умеет это расширять, это, допустим, мы с вами можем понять,
[01:06:16.840 --> 01:06:26.160]  что на стадии тестирования у нас что-то может пойти не так, и мы можем делать отвилку на стадию
[01:06:26.160 --> 01:06:35.840]  проектирования. То есть, в принципе, делать некоторые откаты. В принципе, такое тоже возможно. Так,
[01:06:35.840 --> 01:06:42.240]  давайте вопрос. Я пока, к сожалению, посмотрю, что у меня в презентации по этим штукам нарисовано,
[01:06:42.240 --> 01:06:53.760]  потому что, к сожалению, в презентацию это уже, так сказать, я забегаю на следующую лекцию. Так,
[01:06:53.760 --> 01:06:55.640]  есть ли вопросы по водопадной модели?
[01:06:55.640 --> 01:07:23.680]  У нас как раз здесь возникает проблема долгостроев. То есть, если у нас какая-то
[01:07:23.680 --> 01:07:28.280]  концепция пошла не так, то, к сожалению, дальше мы ничего сделать не можем.
[01:07:28.280 --> 01:07:34.280]  Значит, теперь давайте как раз поговорим про следующую модель. А это как раз V-модель.
[01:07:34.280 --> 01:07:42.680]  Смотрите, значит, здесь важно понять, каким образом вообще происходит проектирование продукта,
[01:07:42.680 --> 01:08:00.800]  из каких стадий она состоит. Сейчас вы поймете, почему это V-модель. Значит, первая стадия – это
[01:08:00.800 --> 01:08:12.640]  бизнес-анализ. То есть, вы смотрите на так называемые требования со стороны бизнеса. То есть,
[01:08:12.640 --> 01:08:18.120]  что это означает? Это означает, что ваш продукт, допустим, должен… Вы нажимаете на кнопочку,
[01:08:18.120 --> 01:08:28.120]  у вас производится какой-то заказ, дальше заказ через какое-то время доставляется, и все замечательно.
[01:08:28.120 --> 01:08:33.800]  Клиент доволен, деньги к нему идут. Вот это как раз бизнес-требование, чтобы, грубо говоря,
[01:08:33.800 --> 01:08:43.680]  ваш продукт позволял, так сказать, осуществлять онлайн-заказы. Дальше мы спускаемся на следующий
[01:08:43.680 --> 01:08:57.120]  уровень – это системный анализ. То есть, вы анализируете уже требования чуть детальнее,
[01:08:57.120 --> 01:09:01.720]  у вас возникают так называемые функциональные требования к системе и не функциональные
[01:09:01.720 --> 01:09:05.000]  требования к системе. Функциональные требования к системе – это требования,
[01:09:05.000 --> 01:09:13.360]  которые вы говорите, окей, значит, у вас система должна по нажатию кнопки выполнять
[01:09:13.360 --> 01:09:19.280]  определенные действия. Раз, прописывайте, раз, два, три, четыре, пять. Или, допустим,
[01:09:19.280 --> 01:09:26.800]  система должна работать в течение там девяносто девяти процентов времени. То есть, это уже не
[01:09:26.800 --> 01:09:32.880]  функциональное требование. Или, допустим, у вас должен быть английский язык, поддержка английского
[01:09:32.880 --> 01:09:40.160]  языка и локализация. Что еще может быть, это версия для слабовидящих. Особенно, когда вы
[01:09:40.160 --> 01:09:45.120]  регламентируете вот такие вещи. То есть, если это как раз системный анализ, то есть, он не с точки
[01:09:45.120 --> 01:09:53.040]  зрения бизнеса, он уже чуть ниже спускается. Дальше у нас мы спускаемся с вами на такую вещь,
[01:09:53.040 --> 01:09:58.000]  про которую мы с вами уже говорили. Это архитектура. То есть, это то, как взаимодействуют
[01:09:58.000 --> 01:10:05.840]  составные части вашего проекта. И самый более низкий уровень – это проектирование модулей.
[01:10:05.840 --> 01:10:19.440]  Иногда это объединяется в стадии разработки. Мы видим с вами, что в этой модели по факту
[01:10:19.440 --> 01:10:27.200]  проектирования разложено на несколько составных частей. А теперь мы с вами параллельно с этой штукой
[01:10:27.200 --> 01:10:35.480]  говорим следующее. Прежде чем мы после выхода каждой стадии, мы с вами создаем требования для
[01:10:35.480 --> 01:10:43.640]  верификации того, что вот у нас эти требования выполнены. И здесь возникает пирамида тестирования,
[01:10:43.640 --> 01:10:48.920]  которые мы далее будем детали разбирать. Первое, что у нас возникает – это модульное тестирование.
[01:10:48.920 --> 01:10:58.000]  Его еще иногда называют unit-тестирование. То есть, вы проверяете функциональность каждого
[01:10:58.000 --> 01:11:05.120]  модуля, который у вас есть в системе. Дальше у нас возникает интеграционное тестирование.
[01:11:05.120 --> 01:11:17.520]  Интеграционное. То есть, вы проверяете взаимодействие между несколькими компонентами в системе.
[01:11:17.520 --> 01:11:33.800]  Дальше идет системное тестирование. То есть, вы тестируете систему. Вы, так сказать,
[01:11:33.800 --> 01:11:38.920]  около вакуумных условиях. То есть, вы запускаете вашу систему в сферическом коне в вакууме и
[01:11:38.920 --> 01:11:46.360]  проверяете, насколько хорошо она работает. И последняя часть – это приемочное тестирование.
[01:11:46.360 --> 01:12:00.840]  Или, как говорят в жаргонном языке, это приемка. То есть, по факту вы говорите,
[01:12:01.360 --> 01:12:06.680]  у нас запускало все на локальном компьютере, все замечательно, все зашибись. А теперь вам
[01:12:06.680 --> 01:12:11.920]  надо это запустить как раз на той Astra Linux, которую мы с вами перечислили с ограниченными ресурсами.
[01:12:11.920 --> 01:12:21.560]  Вперед. Или у вас вы писали код под убунтой, вам надо запустить это на Windows. Или там, допустим,
[01:12:21.560 --> 01:12:26.680]  режим пиковой производительности. То есть, мы пишем в функциональных требованиях, что наша
[01:12:26.680 --> 01:12:34.560]  система должна выдерживать нагрузку до 10 000 человек. Что делать, если 10 000 человек придет?
[01:12:34.560 --> 01:12:40.560]  Ну, можно молиться. Что еще можно делать?
[01:12:40.560 --> 01:12:51.120]  Да, нам нужен какой-то запас прочности. А теперь представьте, что мы систему разрабатываем без
[01:12:51.120 --> 01:12:58.280]  этого запаса прочности. Да, все ляжет. Ну, собственно, примеры я уже много приводил,
[01:12:58.280 --> 01:13:06.520]  когда система может лечь. Так вот, смотрите, в итоге получается так, что перед самой разработкой
[01:13:06.520 --> 01:13:15.640]  мы с вами заранее определяем процедуру тестирования каждой из составных частей. И обычно внизу
[01:13:15.640 --> 01:13:24.240]  разработка идет. То есть, что у нас получается? В этой картинке, если мы переставляем все это дело,
[01:13:24.240 --> 01:13:33.200]  то у нас по факту... Смотрите, какие стадии между собой меняются здесь. Да, смотрите, первую очередь
[01:13:33.200 --> 01:13:39.000]  у нас меняется между собой разработка и тестирование. И отчасти, на самом деле, стадия внедрения,
[01:13:39.000 --> 01:13:48.040]  потому что тесты, в принципе, для внедрения у нас уже готовы. Мы делаем трюк и меняем их местами.
[01:13:48.040 --> 01:13:56.240]  Значит, в каких местах это применяется? На самом деле, это применяется в тех местах, когда есть
[01:13:56.240 --> 01:14:03.440]  строгая приемка. То есть, вам прямо жестко, на уровне того, что если у вас что-то не выполнится,
[01:14:03.440 --> 01:14:10.600]  допустим, ракетостроение какое-нибудь, космическая отрасль, то понятно, к чему это может привести.
[01:14:10.600 --> 01:14:17.200]  Это может привести к большим печальным последствиям. Примеры с компанией Boeing это показывает нам. То есть,
[01:14:17.200 --> 01:14:22.840]  вы заранее должны прописать те процедуры, по которым вы будете тестировать ваши самолеты.
[01:14:22.840 --> 01:14:33.280]  Это что касается именно V-модели. Значит, про вот эти виды тестирования мы с вами еще будем говорить.
[01:14:33.280 --> 01:14:41.560]  Так, понятно это или нет. И последняя методология, которую мы сегодня с вами успеем рассмотреть,
[01:14:41.560 --> 01:14:55.800]  это спиральная методология. Значит, она очень хорошо подходит на, как ни странно, ни стадии
[01:14:55.800 --> 01:15:02.320]  проектирования. Она хорошо подходит, когда вы начинаете договариваться с кем-то о создании
[01:15:02.320 --> 01:15:09.960]  проекта. То есть, прежде чем вы начинаете саму разработку. Потому что проект, как мы с вами сказали,
[01:15:09.960 --> 01:15:15.640]  прежде чем начать проект, нам нужно оговориться о его сроках, о начале и его завершении.
[01:15:15.640 --> 01:15:21.160]  То есть, там мы начинаем раскручивать спираль. Сейчас я вспомню, из каких блоков он состоит.
[01:15:21.160 --> 01:15:44.120]  Господи. Так, здесь у нас стадия разработки. Здесь у нас риски. Здесь у нас это проектируется,
[01:15:44.120 --> 01:15:57.680]  это у нас получается планирование. И это у нас с вами называется это определение задач,
[01:15:57.680 --> 01:16:04.880]  которое нам нужно сделать. То есть, мы будем сейчас по спирали раскручивать эту всю концепцию. То есть,
[01:16:05.360 --> 01:16:16.280]  начинается мы с вами определяем задачи, оцениваем риски, разрабатываем часть, планируем следующую
[01:16:16.280 --> 01:16:26.040]  итерацию. У нас возникает вот такая вот спираль, которая внедряется дальше. Теперь смотрите,
[01:16:26.040 --> 01:16:34.360]  как раз вот то, что у нас по водопадной модели идет, оно находится на вот этих стадиях. То есть,
[01:16:34.360 --> 01:16:40.840]  здесь у нас как раз раз, два, три, четыре, пять. То есть, это основной аспект. Но при этом они
[01:16:40.840 --> 01:16:45.440]  разделяются между собой. То есть, изначально, допустим, нам нужно определить сроки нашего
[01:16:45.440 --> 01:16:52.600]  проекта. То есть, здесь мы создаем концепцию. То есть, как наш продукт геотически будет выглядеть.
[01:16:52.600 --> 01:16:58.320]  Дальше вы разрабатываете такой, понятие как жизненный цикл. То есть, сколько ваш продукт проживет
[01:16:58.320 --> 01:17:05.320]  и вообще он будет релевантным. Оцениваете риск и в конце первой стадии спирали вы получаете
[01:17:05.320 --> 01:17:17.360]  некоторый прототип. Вот. Дальше вы тестируете этот прототип. То есть, идете разработку этого
[01:17:17.360 --> 01:17:25.120]  прототипа. То есть, у вас получается разработка. Потом, собственно, у вас вот здесь вот получается
[01:17:25.120 --> 01:17:30.960]  следующее. Вы по факту моделируете то, что у вас происходит. То есть, смотрите изначально, что у вас
[01:17:30.960 --> 01:17:37.480]  есть. Вот, если вы разрабатываете какой-нибудь автомобиль, да, что вам проще... О, давайте поезд. Вот,
[01:17:37.480 --> 01:17:43.560]  поезд это хороший пример. Вот, что вам нужно... Представьте себе, что у вас поехал поезд по
[01:17:43.560 --> 01:17:51.200]  электричке. Да, он поехал, все замечательно. Вагон этого поезда. Что нам нужно сначала сделать? Нам
[01:17:51.280 --> 01:17:57.120]  нужно сначала сделать маленький эскиз этого вагона. Да, посмотреть, как он выходит. Потом, значит,
[01:17:57.120 --> 01:18:03.160]  сделать копию этого вагона шире. Представить его на выставке. То есть, расширить нашу модель. И
[01:18:03.160 --> 01:18:10.280]  только потом, собственно, сделать этот вагон. И прогнать его на приемочных тестах. То есть,
[01:18:10.280 --> 01:18:14.640]  проверить, грубо говоря, выдерживает ли он нагрузку, выдерживает ли он резкое торможение и
[01:18:14.640 --> 01:18:21.240]  так далее. Но это можно сделать не с большим вагоном, а с маленьким прототипом вагона. Потому что,
[01:18:21.240 --> 01:18:26.160]  если мы опустим большой вагон и случайно он не выдержит теста, то это катастрофически для людей.
[01:18:26.160 --> 01:18:32.360]  И так вот, после каждой итерации этого цикла мы сужаем риски нашего проекта. То есть, у нас
[01:18:32.360 --> 01:18:39.920]  сначала, если мы говорим, что 1х это скорость разработки нашего проекта, ну, ожидаемая,
[01:18:39.920 --> 01:18:47.360]  то после первой итерации у вас скорость, типа, диапазон рамок окончания проекта будет
[01:18:47.360 --> 01:18:53.320]  от 1 4х, ну, приблизительно, это статистические выводы, до 4х. Потом, после следующей итерации,
[01:18:53.320 --> 01:19:02.240]  вы его сужаете. То есть, у вас получается, смотрите, нелинейная шкала здесь, а экспоненциальная. То есть,
[01:19:02.240 --> 01:19:07.960]  допустим, вы указываете, понимаете, что здесь полу х на 2х. И тем самым вы после каждой стадии
[01:19:07.960 --> 01:19:11.800]  прохождения спирали все-таки понимаете, сколько времени, в более уточненном варианте,
[01:19:11.800 --> 01:19:21.200]  вас занимает разработка этого проекта. Так, понятен ли цикл? То есть, это именно
[01:19:21.200 --> 01:19:26.920]  большая часть договоренностей, прототипов, выяснений вот этих всех сценариев. Так, хорошо,
[01:19:26.920 --> 01:19:32.000]  значит, мы с вами сегодня немножко перестроились. Поговорили сегодня про семантическое
[01:19:32.000 --> 01:19:39.160]  версионирование. Добили паттерны и антипаторны первые и начали говорить про методологию
[01:19:39.160 --> 01:19:43.520]  разработки. Я надеюсь, в следующий раз с проектором будет лучше и мы с вами будем говорить про UML.
[01:19:43.520 --> 01:19:46.880]  Спасибо.
