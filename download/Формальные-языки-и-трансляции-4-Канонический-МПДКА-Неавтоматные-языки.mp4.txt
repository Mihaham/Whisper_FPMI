[00:00.000 --> 00:11.640]  так всем доброго дня мы с вами продолжаем сегодня не знаю получится у нас быстро
[00:11.640 --> 00:17.760]  или не получится но если что время перерыва украдем вот приношу извинения я думаю в следующих
[00:17.760 --> 00:24.320]  парах у нас такого не будет значит сегодня нашей целью будет закончить тему вообще
[00:24.320 --> 00:31.280]  связано с автоматами вот и чтобы в следующий раз мы могли перейти на другую тему я пока не
[00:31.280 --> 00:38.480]  знаю кто будет следующую лекцию читать возможно я возможно виталий вот пока еще не решили ну
[00:38.480 --> 00:43.040]  потому что мне возможно в какое-то место надо будет уехать вот дать вспомним что у нас было
[00:43.040 --> 00:54.640]  в предыдущих сериях так это был спойлер кто умеет спойлеры читать никто что было на прошлой
[00:54.640 --> 01:02.040]  лекции да первое что мы сделали мы доказали что по любому регулярному языку можно построить
[01:02.040 --> 01:06.760]  конечный автомат по любому конечному автомату может построить регулярный язык ага что еще мы
[01:06.760 --> 01:15.940]  с вами сделали да мы определили понятие эквалентных состояний в пдк и определили
[01:15.940 --> 01:24.040]  понятие эквалентных слов по по языку и какой мы автомат с вами построили в конце прошлой лекции
[01:24.040 --> 01:41.240]  мы построили по любому mpdk pdk без эквалютных состояний а на чем мы там не закончили по
[01:41.240 --> 01:51.560]  мы в итоге вы закончили да мы закончили на самом конце вон там было 4 свойства которые надо было
[01:51.560 --> 01:58.280]  доказывать долго и муторно вот и сегодня мы с вами продолжим эту штуку вот а факт на самом
[01:58.280 --> 02:04.280]  деле заключается в следующем что мы не совсем построили минимальный пдк мы построили его про
[02:04.280 --> 02:10.760]  образ потому что в минимальном пдк ну давайте скажем что это будет у нас пдк с минимальным
[02:10.760 --> 02:15.760]  количеством состояний вот и мы будем доказывать что он является наименьшим то есть он будет
[02:15.760 --> 02:21.280]  единственным с точностью до изоморфизма значит мы будем доказать следующий факт что у нас
[02:21.280 --> 02:27.040]  автомат минимальный пдк том и только в том случае когда у него во-первых любые два состояния
[02:27.040 --> 02:36.360]  попарно не эквалентны есть второе условие что все состояния достижимы из стартового вот эти
[02:36.360 --> 02:41.960]  факты мы с вами будем доказать давайте поймем какого свойства нам не хватало для того что в
[02:41.960 --> 02:52.120]  прошлый раз сказать что наш построенный автомат является минимальным чего нам не
[02:52.120 --> 02:59.600]  хватило до достижения стартовых состояний а давайте подумаем ну пока я пока говорю пока
[02:59.600 --> 03:07.920]  доска сохнет просто я хочу сказать следующую давайте мысленно прокрутим идея допустим у
[03:07.920 --> 03:18.240]  нас с вами есть минимальный пдк да вопрос что можно сказать если в нем есть какие-то два
[03:18.240 --> 03:28.720]  эквалентных состояния что можем сделать объединить их то есть построить на самом деле построить
[03:28.720 --> 03:33.680]  автомат без попарно эквалентных состояния потому что мы два эквалентных состояния переводим в
[03:33.680 --> 03:41.040]  одном множестве это раз да я пока говорю я жду пока доска высохнет вот значит строим вот
[03:41.040 --> 03:48.080]  такой вот автомат отлично а если у нас есть какое-то состояние недостижимые стартового то что
[03:48.080 --> 03:54.720]  мы с ним можем сделать удалить и при этом язык который у нас остается распознаваем этим автоматом
[03:54.720 --> 04:06.680]  никак не меняется давайте эвристически поймем почему это так ну да если мы в терминах
[04:06.680 --> 04:13.600]  конфигурации напишем то получается у нас не может быть из конфигурации стартовое слово произвольное
[04:13.600 --> 04:19.120]  слово ну стартовое состояние произвольное слово в этом недостижимом состоянии любого слова то
[04:19.120 --> 04:23.920]  есть у нас просто состояние конфигурации не определено для вот этой пары то есть они не
[04:23.920 --> 04:29.320]  находятся не находится в одном классе так сказать в одном отношении вот поэтому недостижимый мы тоже
[04:29.320 --> 04:37.080]  можем убрать убираем состояние и так далее вот а теперь мы с вами начнем доказывать следующий
[04:37.080 --> 04:44.320]  факт почему это работает вы обратную сторону давайте формулируйте арену
[04:44.320 --> 04:58.440]  минимальные тогда и только тогда когда любые
[04:58.440 --> 05:07.440]  такие валентные и все состояния достижимые стартового
[05:07.440 --> 05:17.680]  попарно да если бы они были бы все попарно эквалентно то понятно что это было бы одно
[05:17.680 --> 05:31.680]  состояние так и все состояния достижимые стартового значит доказательства в одну
[05:31.680 --> 05:39.680]  сторону мы уже с вами обсудили называется уменьшаем число состояний
[05:39.680 --> 05:58.480]  если не так а в обратную сторону давайте посмотрим у нас с вами предположим что у
[05:58.480 --> 06:06.160]  нас есть м которым автомат в котором любые два состояния являются попарно не эквалентными
[06:06.160 --> 06:14.360]  помните у нас было с вами некоторое соотношение на количество состояния в автомате и мощность
[06:14.360 --> 06:27.440]  множество сигмаса звездой кто его мне может напомнить она была у нас какая сверху ограничена
[06:27.480 --> 06:35.880]  на на произвольной автомате вот и хочется вот вот это вот место что-то подставить
[06:35.880 --> 06:46.080]  да оценку снизу поставить хочется сказать что это будет как раз количество состоянием нашему
[06:46.080 --> 06:54.800]  пдк м нашим автоматем который сейчас есть и тогда этот автомат явно будет сразу минимальным по
[06:54.840 --> 07:04.960]  количеству вершин давайте вспомним как мы вот этот факт доказывали какая лемма у нас была
[07:04.960 --> 07:25.080]  мы говорили что у нас сигма со звездой л это объединение среди классов в альку
[07:25.080 --> 07:43.520]  напомню что такой альку альку это у нас множество слов в которых дельта q 0 w равно
[07:43.520 --> 07:56.560]  да совпадение правых классов то есть мы приписывая справа произвольный суффикс либо
[07:56.560 --> 08:02.320]  мы попадаем язык либо не попадаем язык и навременно вот ну то есть получается у нас
[08:02.320 --> 08:08.240]  следующее свойство то есть если у нас и как мы этот факт доказывали давайте вспомним
[08:13.520 --> 08:26.240]  мы говорили что если два если два у нас как сказать мы сказали следующее что если у нас
[08:26.240 --> 08:32.920]  два произвольных слова попадает в одно состояние то они эквалютны да здесь необходимо сделать что-то
[08:32.920 --> 08:39.760]  обратное чтобы получить противоположную оценку поэтому давайте посмотрим значит для этого мы
[08:39.760 --> 08:45.360]  сделаем следующее пусть у нас в м нет эквалютных состояний да и мы будем доказывать следующее что
[08:45.360 --> 08:53.400]  если у нас дельта от q 0 по слову дв 1 не равняется дельта от q 0 по слову дв 2 то что хочется сказать
[08:53.400 --> 09:00.160]  про эти два слова да что они продлежат класс мы разно-классовая эквалентность
[09:00.160 --> 09:22.960]  тогда смотрите так как у нас в автомате нет эквалентных состояний да то есть это
[09:22.960 --> 09:38.840]  значит что сейчас из этого будет следовать что не эквалентно по слову дубль во 2 да и со
[09:38.840 --> 09:43.280]  состоянию нас не совпадают они не эквалентно а теперь смотрите что мы сделаем мы говорим
[09:43.280 --> 09:58.320]  что существует у такое что дельта у 0 в 1 у принадлежит f давайте скажем сразу без ограничения
[09:58.320 --> 10:13.480]  общности потому что неважно как мы смотрим на эти два слова и дельта от дельта q 0 не принадлежит f вот
[10:13.480 --> 10:22.120]  это чему эквалентно опять же мы понимаем что это двойное дельта мы можем конкатонировать то что
[10:22.120 --> 10:29.520]  у нас было поэтому получаем дельта q 0 в 1 у а это эквалентно тому что у нас
[10:29.520 --> 10:38.760]  дубль в 1 у принадлежит языку l а это получается эквалентно тому что дельта
[10:38.760 --> 10:52.760]  у не принадлежит f а это эквалентно тому что дубль в 2 у не лежит в л то есть у нас
[10:52.760 --> 11:03.000]  существует такое слово у что в 1 у лежит в л а в 2 у не лежит в л а потому что у нас
[11:03.000 --> 11:10.600]  состояние не эквалентно между собой это значит что существует слово который различает эти два
[11:10.600 --> 11:15.880]  состояния но мы говорим только без ограничения в общем в общности что здесь принадлежит а здесь
[11:15.880 --> 11:26.440]  не принадлежит можем повернуть знаки и получается что у нас с вами что в 1 не эквалентно дубль в 2
[11:26.440 --> 11:39.160]  а теперь давайте подумаем что из этого следует что в нашем автомате если у нас состояние не
[11:39.160 --> 11:45.160]  совпадают ой если у нас мы приходим в разные состоянии то мы попадаем в разные классы
[11:45.160 --> 11:55.000]  эквалентности ну из этого следует что количество состояния как минимум столько же ой сейчас скажу
[11:55.000 --> 12:11.320]  слова не эквалентны тогда и только тогда когда существует какое-то слово что приписывая к
[12:11.320 --> 12:19.080]  нему справа мы в одном слове попадаем язык в другом не попадаем это определение мы давали в
[12:19.080 --> 12:25.760]  прошлый раз вот это значит смотрите что давайте рассмотрим просто все состояния в нашем автомате
[12:25.760 --> 12:44.640]  и смотрите здесь важно играет роль что все состояния достижимые стартового
[12:44.640 --> 12:52.320]  да давайте пронумеруем то есть у нас состояние будет ку-1 ку-0 ку-1
[12:52.320 --> 12:57.760]  для каждого существует слово
[12:57.760 --> 13:25.000]  кукаты из этого следует что w 0 w попарно не эквалентно
[13:25.000 --> 13:35.480]  а это значит что количество классов
[13:35.480 --> 13:45.680]  не меньше чем количество классов автомате количество состояния в автомате
[13:45.680 --> 13:51.520]  давайте я все-таки напишу здесь куштрих и напишу для произвольного автомата
[13:51.520 --> 14:07.160]  да то есть вот оно играет свойство о том что все состояния достижимые стартового тогда
[14:07.160 --> 14:28.760]  и ку-1 и получается наш автомат m на самом деле минимальный то есть мы доказали
[14:28.760 --> 14:35.640]  что через количество классов эквалентный сигма со звездой по l то что количество
[14:35.640 --> 14:40.040]  состояния наш построенном автомате не больше чем количество состояний в произвольном другом
[14:40.040 --> 15:04.240]  автомате это доказательства понятно какая а вот это откуда мы начали рассуждать просто пусть у
[15:04.240 --> 15:11.760]  нас две вершины пусть у нас есть какие-то два состояния ку-1 и ку-2 которые не совпадают
[15:11.760 --> 15:17.520]  каким-то образом но существует два слова просмотрим два произвольных слова которые приводят нас в
[15:17.520 --> 15:25.480]  разных в разных состоянии старта и докажем что они не эквалентны будут да это мы предполагаем
[15:25.480 --> 15:41.440]  тогда что мы можем сказать про минимальный автомат чему в нем равняется количество состояний
[15:41.440 --> 15:54.040]  да множество классы эквалентности по языку да то есть количество состояния минимального
[15:54.400 --> 16:05.280]  зависит не от автомата а от языка можем ли мы сказать что автомат тогда будет зависеть от
[16:05.280 --> 16:12.440]  языка минимально и на самом деле ответ на этот вопрос положительный да это собственно доказательства
[16:12.440 --> 16:20.560]  вот и теперь мы будем доказывать единственность этого автомата с точностью до изоморфизма
[16:20.560 --> 16:26.880]  что сегодня у нас у нас сухих тряпок сегодня нет ну ладно в общем будем доказывать что для
[16:26.880 --> 16:32.960]  любого автомата существует единственная с точностью для любого минимального пдк существует
[16:32.960 --> 16:41.200]  единственной с точностью до изоморфизма минимальный автомат такой что л равно л от
[16:41.320 --> 16:58.840]  вашем дать скажем единственность для любого l существует единственный
[16:58.840 --> 17:12.800]  с точностью до изоморфизма а теперь давайте подумаем как определить изоморфизм
[17:12.800 --> 17:24.560]  да во-первых он должен сохранять состояние во-вторых он должен сохранить переходы и
[17:24.560 --> 17:31.200]  третьего что он должен сохранять завершает состояние да так такое что
[17:31.200 --> 17:43.760]  давайте зададим определение значит давайте обозначим си
[17:43.760 --> 18:04.280]  физом если значит во-первых но я не знаю давайте не будем говорить что а наверное надо сказать да
[18:04.280 --> 18:25.040]  q1 и q2 объективны q02 то есть стартовая переходит стартовая си ну поскольку это би так стоп
[18:25.040 --> 18:34.120]  давайте я скажу следующее что в си я плохо написал да иску
[18:34.120 --> 18:57.800]  не давайте изоморфизм будем определять только для пдк так си от q01 равняется q02 си от f1 равняется
[18:57.800 --> 19:09.720]  f2 да и получается что еще нам нужно ну тут можно писать все дельта 1 равняется дельта 2 но я
[19:09.720 --> 19:30.240]  напишу следующее сейчас секунду да давайте напишем что если у нас получается есть переход
[19:30.240 --> 19:47.280]  из q1 по а в q2 принадлежит дельта тогда я только тогда когда получается си от q1 а
[19:47.280 --> 19:59.520]  си от q2 принадлежит дельта 2 то есть переходы согласованы я не знаю что делать сегодня с
[19:59.520 --> 20:15.600]  этой доской вот определение такое и да вот можно так определить и давайте вот сделаем вот
[20:15.600 --> 20:30.320]  такую вот вещь ведем такое понятие как канонически минимальный полный детерминированный автомат да да и
[20:30.320 --> 20:37.240]  сейчас и напишу смотрите а что мы доказали с вами мы доказали с вами на самом деле что если язык
[20:37.240 --> 20:46.960]  автоматный да то сигма со звездой количество классов эквалентности оно конечно да потому что
[20:46.960 --> 20:53.540]  если у нас язык автоматный то для него существует автомат да а если для него существует автомат
[20:53.540 --> 20:57.380]  то он ограничивает сверху количество классов эквалентность сигма со звездой по этому языку
[20:57.380 --> 21:06.200]  поэтому мы можем построить автомат вот потому что нам важно было как конечно
[21:06.200 --> 21:14.720]  количество классов эквалетности. Итак, обозначу его m0.
[21:22.520 --> 21:34.000]  Так, смотрите, как он обозначается. Это сигма со звездой по l, а алфавит у него
[21:34.000 --> 21:40.240]  будет сигма. Значит, дальше множество переходов пределим. Класс эквалентности
[21:40.240 --> 21:46.520]  пустого слова будет являться стартовым состоянием, а завершающим состоянием
[21:46.520 --> 21:57.200]  будет следующее. Множество классов эквалентности слова w такое, что w принадлежит языку l.
[21:57.200 --> 22:08.880]  И будем говорить следующее, что переход от класса эквалентности u по слову a равняется
[22:08.880 --> 22:17.400]  класс эквалентности слова ua. Так, ну теперь давайте поймем, что нам надо сделать для того,
[22:17.400 --> 22:29.480]  чтобы сказать, что этот автомат вообще существует. Во-первых, нам надо доказать,
[22:29.480 --> 22:39.880]  что все состояния существуют, все они не эквалентны попарно. А вас не смущает,
[22:39.880 --> 22:46.160]  что там завершающие состояния так определяются? А вас не смущает, что переходы так определяются?
[22:46.160 --> 23:09.160]  Да, сразу скажу, что l автоматный язык у нас. Давайте я напишу. Давайте проверим свойства этого
[23:09.160 --> 23:24.720]  автомата. Первое свойство, которое нам надо проверить, следующее, что если u эквалентно v,
[23:24.720 --> 23:37.120]  u лежит в языке l, то v лежит в языке l. Почему? Это мы доказываем согласованное
[23:37.120 --> 23:49.200]  множество завершающих состояний. Да, допишем слово. Значит, u эквалентно v это значит,
[23:49.200 --> 24:00.640]  что для любого слова w, которое в нашем случае мы положим равное epsilon, l тогда и только тогда,
[24:00.640 --> 24:09.520]  когда v принадлежит l. Это у нас u будет, это у нас будет l. Завершающее состояние мы с вами
[24:09.520 --> 24:25.600]  согласовали. А дальше, что нам надо согласовать с вами? Переходы. На самом деле, кто-то может
[24:25.600 --> 24:32.640]  сказать, что мы повторяем лишнюю работу. Как говорят принципы чистого кода do not repeat
[24:32.640 --> 24:40.480]  yourself. Но тут это, к сожалению, не совсем срабатывает, поэтому мы будем исполнять
[24:40.480 --> 24:56.840]  принцип wet. Кстати, вы знаете, что такое принцип wet в программировании? Как расшифровывается?
[24:56.840 --> 25:08.760]  Да, да, да. Именно так он расшифровывается. Да, забавно. То есть, либо сухой, либо мокрый.
[25:08.760 --> 25:21.600]  Что? А, вот здесь? Ну, мы говорим, что мы хотели бы, чтобы по переходу из класса эквалентности мы
[25:21.600 --> 25:27.840]  попадали бы в класс эквалентности. Пока непонятно, почему это может работать. Для этого нам надо
[25:27.840 --> 25:35.760]  доказать следующий факт, что если у нас u эквалентно v, то из этого будет следовать,
[25:35.760 --> 25:51.080]  что уa эквалентно va. Почему это так? Да, потому что вот это что у нас такое? Мы говорим, что uv для
[25:51.080 --> 26:05.080]  любого v, uv лежит l тогда и только тогда, когда vw лежит vl, но если рассмотрим w равное ax,
[26:05.080 --> 26:16.960]  то мы получим uax лежит vl тогда и только тогда, когда vax лежит vl. Ну и получается у нас вот
[26:16.960 --> 26:23.280]  это условие выполнено для любого x. Да, поэтому из этого будет следовать эквалентности. Третье,
[26:23.280 --> 26:40.320]  что нам надо доказать, что это pdk. Почему это pdk? По любой буквы есть переход. И он
[26:40.320 --> 26:53.520]  переходит к автоклассу. Так, дальше нам нужно доказать, что это минимальный pdk. Ну да,
[26:53.520 --> 27:15.760]  мы можем сказать, что в нем третий. А теперь нам надо понять, почему он будет являться наименьшим.
[27:15.760 --> 27:25.520]  Так, вспоминаем курс теории чисел. Что такое минимальный, что такое наименьший?
[27:25.520 --> 27:38.280]  Да, минимальный это тот, меньше которого нет, а наименьший это тот, который не больше,
[27:38.280 --> 27:44.720]  чем все остальные. Да, то есть мы определим, смотрите, давайте мы будем на автоматах,
[27:44.720 --> 27:50.360]  на самом деле можно определить частичный порядок. Грубо говоря, один автомат будет не больше,
[27:50.360 --> 27:56.840]  чем второй автомат. Мы про pdk говорим, что если из большего автомата можно схлопнуть некоторые
[27:56.840 --> 28:05.560]  вершинки и получить меньший автомат. Вот, и в таких терминах наш автомат получится наименьшим.
[28:05.560 --> 28:14.760]  Вот. Меня просто, так сказать, в прошлых запусках этого курса, ну в прошлом запуске,
[28:14.760 --> 28:22.520]  меня ругали, почему спрашивают факт доказательства. Значит, почему существует наименьший pdk,
[28:22.520 --> 28:30.080]  ой, почему существует минимальный pdk в классическом определении минимального pdk. Давайте сформулируем
[28:30.080 --> 28:35.160]  халявное доказательство, которое вообще не отражает факту по курсу. Напоминаю, минимальный pdk
[28:35.160 --> 28:45.120]  это pdk, в котором наименьшее число состояний. Почему он существует? Да, значит, существует
[28:45.120 --> 28:52.240]  автомат, в котором состояние как можно меньше. Вот он минимальный, все, отстаньте от меня. Вот,
[28:52.240 --> 28:57.240]  а на самом деле мы как раз сказали, что у нас автомат будет наименьшим, потому что в нем все
[28:57.240 --> 29:15.320]  состояния будут попарно не эквивалентными, то есть нельзя схлопнуть его ниже. Чего? Ну вот,
[29:15.320 --> 29:20.400]  но если мы сейчас это все все автоматы сведем к общему знаменателю, да, скажем, что он один,
[29:20.400 --> 29:26.000]  тогда у нас не получится, что в нашем частичном порядке есть там, грубо говоря, вот такие два
[29:26.000 --> 29:40.800]  автомата. Вот. Да, с точностью до изоморфизма, то есть мы разрешаем, да, для этого мы, то есть мы
[29:40.800 --> 29:46.600]  говорим, что два автомата на самом деле одинаковые, если они одинаковые с точностью до изоморфизма.
[29:46.600 --> 29:52.720]  Вот, давайте доказывать этот факт, значит, для этого нам нужно построить канонический изоморфизм.
[29:52.720 --> 30:06.720]  Пусть у нас с вами есть автомат m, который считается тоже минимальным.
[30:06.720 --> 30:27.920]  Давайте назовем дельта ноль тогда. Давайте определим канонический изоморфизм.
[30:27.920 --> 30:39.800]  Определим изоморфизм си из q в сигма со звездой,
[30:39.800 --> 30:54.200]  то доказывается, куда он будет бить наш этот ксиатку.
[30:54.200 --> 31:22.400]  Ну, в какой-то класс эквалентности. Ну да, утверждает, что это... Так, стоп. Да, сейчас, секунду.
[31:22.400 --> 31:37.200]  Давайте напишу такое. Помните льку, как мы определили? Это все слова,
[31:37.200 --> 31:45.600]  которые доходят из стартового состояния до кутова. Тогда что нам необходимо доказать?
[31:45.600 --> 31:52.960]  Да, нам надо доказать, что си изоморфизм.
[31:52.960 --> 32:07.600]  И смотрите, делается следующий факт. Давайте я немножечко проговорю. Вообще пусть у нас есть
[32:07.600 --> 32:13.840]  два автомата, любых, два минимальных автомата. Тогда, если мы построим с вами канонический
[32:13.840 --> 32:29.920]  изоморфизм, образно говоря, у нас был автомат м1 и м2, тогда мы можем построить си1 из q1 и си2 сигма со звездой по л,
[32:29.920 --> 32:36.720]  такие что... Ну, это изоморфизмы. Тогда скажите, как можно сделать изоморфизм из м1 в м2?
[32:36.720 --> 32:55.520]  Да, взять си1 и построить си2 в м1, то есть композировать. И тут надо будет доказывать,
[32:55.520 --> 33:00.720]  что эта композиция является изоморфизмом. Так, давайте промотаем.
[33:00.720 --> 33:14.480]  Да, тогда получается, что любые два автомата изоморфны просто через этот канонический изоморфизм мы используем
[33:14.480 --> 33:25.840]  как медиатор. Да, любых два минимальных автомата изоморфны между собой. Итак, давайте проверим,
[33:25.840 --> 33:31.960]  что необходимо показать. Первое, что необходимо показать, что psi от q0 действительно будет пустое
[33:31.960 --> 33:50.440]  слово. Это почему? Да, корректность, давайте корректность.
[34:01.960 --> 34:25.360]  Так, почему? Ну да. Так, сейчас секунду. Ну, здесь нужно сказать следующее, что дельта от q0 по
[34:25.360 --> 34:45.960]  epsilon равняется q0. Да, это значит, что epsilon принадлежит, так сказать, чему? Да, psi от q0.
[34:45.960 --> 34:58.200]  Сейчас скажу, что здесь мы используем, чтобы в нашем автомате одинаковое количество состояний.
[34:58.200 --> 35:10.000]  То есть, что в нашем минимальном автомате все автоматы имеют одинаковое количество
[35:10.000 --> 35:16.120]  состояний. Следующий факт, который нам надо проверить будет, это, наверное, согласованность
[35:16.120 --> 35:34.520]  переходов. А, не, ну, что завершающее состояние совпадает. Второе. Это почему?
[35:46.120 --> 36:02.880]  Ну да, во-первых, у нас мы понимаем с вами, что, грубо говоря, если мы возьмем вершинки qf1, qfkat,
[36:02.880 --> 36:32.880]  qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt, qt
[36:32.880 --> 36:38.640]  Qường qt Qfqt Qc1
[36:39.200 --> 36:45.460]  Qc1 Qc1 xdxfd xdx fd xDx selection xc1 Qc1 xQc1 card xdx幸 и xdx fdselection
[36:45.460 --> 36:49.460]  будет равняться QFGT.
[36:49.460 --> 36:55.460]  Вот. И каждый из WFGT будет обрабатывать свой класс.
[36:55.460 --> 36:58.460]  Почему у нас там в состоянии не принадлежат P?
[36:58.460 --> 37:02.460]  Потому что они и принадлежат F.
[37:02.460 --> 37:06.460]  А? Да, да, да, да.
[37:06.460 --> 37:13.460]  Вот. Ну и получается WFGT это канонический представитель в каждом из...
[37:13.460 --> 37:15.460]  в каждом из состояний.
[37:15.460 --> 37:22.460]  То есть смотрите, мы здесь все равно пользуемся тем фактом, теми фактами, которые мы доказывали при построении минимального автомата.
[37:22.460 --> 37:28.460]  И третье, что нам надо доказать, что если delta Q1A равно Q2,
[37:28.460 --> 37:35.460]  то delta от переходов равняется psi от переходов.
[37:35.460 --> 37:38.460]  Ну а это как сделать?
[37:44.460 --> 37:50.460]  Третье. Если у нас получается delta от Q1...
[37:57.460 --> 37:59.460]  Ой.
[38:01.460 --> 38:03.460]  ...psi.
[38:07.460 --> 38:09.460]  Угу.
[38:09.460 --> 38:12.460]  Ну, смотрите, тут достаточно все просто.
[38:13.460 --> 38:20.460]  А если psi от Q1 это какой-то классы квалитности U...
[38:24.460 --> 38:26.460]  А, psi от Q2, да.
[38:30.460 --> 38:32.460]  Угу.
[38:32.460 --> 38:36.460]  А, тогда смотрите, чему равняется...
[38:37.460 --> 38:41.460]  Да, тогда delta от...
[38:41.460 --> 38:43.460]  Ага.
[38:47.460 --> 38:50.460]  Это класс UA.
[38:50.460 --> 38:52.460]  Угу.
[38:52.460 --> 39:00.460]  И тогда нам нужно доказать, что если у нас какое-то слово лежит в этом классе квалитности, да, в Q2,
[39:00.460 --> 39:04.460]  то тогда мы попадаем в классы квалитности слова UA.
[39:04.460 --> 39:08.460]  Еще секунду, давайте поймем, как это сделать.
[39:11.460 --> 39:14.460]  Я сейчас хочу красиво написать.
[39:15.460 --> 39:18.460]  Значит, psi Q2...
[39:21.460 --> 39:24.460]  Нам надо доказать, что это...
[39:24.460 --> 39:27.460]  psi от Q2 равно delta от UA.
[39:31.460 --> 39:35.460]  Ну, psi от Q2 это psi от delta от Q1 по A.
[39:35.460 --> 39:37.460]  Стоп, что?
[39:37.460 --> 39:41.460]  Ну, нам известно, что Q2 равно delta от Q1 по A.
[39:41.460 --> 39:44.460]  Q2 равно delta от Q1 по A, да.
[39:44.460 --> 39:48.460]  Значит, psi от Q2 это psi от delta от Q1 по A.
[39:51.460 --> 39:54.460]  А в этом классе лежит некоторый...
[39:54.460 --> 39:56.460]  Стоп, а почему psi от...
[39:56.460 --> 39:59.460]  Не-не-не, нам это как раз доказать надо вроде бы.
[40:11.460 --> 40:14.460]  Ну да, можно так сказать.
[40:15.460 --> 40:17.460]  Сейчас, секунду.
[40:26.460 --> 40:30.460]  Ну, тут по-хорошему надо писать все в терминах слов.
[40:30.460 --> 40:34.460]  Да, то есть у нас, допустим, оказалось, что...
[40:35.460 --> 40:37.460]  psi от Q2...
[40:39.460 --> 40:41.460]  это класс эквалитности Q...
[40:41.460 --> 40:43.460]  класс эквалитности некоторого слова W.
[40:43.460 --> 40:47.460]  Тогда нам надо доказать, что V эквалентно W... это...
[40:50.460 --> 40:54.460]  V эквалентно UA. Нам надо вот это доказывать.
[40:56.460 --> 40:59.460]  Ну, смотрите, как это делается.
[41:00.460 --> 41:03.460]  Значит, что такое вот это вот все?
[41:03.460 --> 41:05.460]  Напоминаю по определению.
[41:06.460 --> 41:08.460]  Что такое psi от Q2?
[41:09.460 --> 41:12.460]  Это слово W. Значит, тогда из этого следует, что...
[41:13.460 --> 41:16.460]  delta от Q0V...
[41:16.460 --> 41:18.460]  равняется Q2.
[41:22.460 --> 41:23.460]  Угу.
[41:23.460 --> 41:25.460]  А с другой стороны?
[41:27.460 --> 41:29.460]  delta от Q0UA...
[41:30.460 --> 41:34.460]  это что такое? Это delta от Q0U...
[41:34.460 --> 41:36.460]  и перейдя это еще раз по A.
[41:37.460 --> 41:39.460]  А это, собственно, тоже будет Q2.
[41:40.460 --> 41:44.460]  Вот. А поскольку наш автомат с вами минимальный...
[41:45.460 --> 41:47.460]  то что мы можем в нем сказать?
[41:51.460 --> 41:54.460]  Если мы переходим в состояние... да, доходим до какого-то состояния...
[41:54.460 --> 41:56.460]  да, вообще до произвольного состояния...
[41:57.460 --> 42:00.460]  то, по сути, не важно, приписывая какое слово справа...
[42:00.460 --> 42:03.460]  мы одновременно либо попадаем в конец, либо не попадаем в конец.
[42:03.460 --> 42:05.460]  Из этого будет следовать как раз, что...
[42:06.460 --> 42:08.460]  W эквалентно UA.
[42:12.460 --> 42:16.460]  То есть тут надо было воспользоваться определением нашего канонического изоморфизма.
[42:18.460 --> 42:21.460]  То, что W принадлежит LQ.
[42:22.460 --> 42:24.460]  Так, вас еще нет.
[42:25.460 --> 42:27.460]  Вы еще держитесь?
[42:30.460 --> 42:32.460]  Так, на самом деле мы...
[42:34.460 --> 42:37.460]  Ну, мы не доказали, кстати, инъективность с вами.
[42:39.460 --> 42:41.460]  Мы не доказали, что эта штука не инъективна.
[42:41.460 --> 42:43.460]  Давайте инъективность проговорим быстренько.
[42:43.460 --> 42:47.460]  Предположим, что Psi от Q1 равняется Psi от Q2.
[42:48.460 --> 42:51.460]  Да, тогда что у нас получается с вами?
[42:51.460 --> 42:53.460]  У нас существует такое слово,
[42:54.460 --> 42:58.460]  которое приводит по одному слову в одинаковые... в разные состояния.
[42:58.460 --> 43:01.460]  Якобы в разные, если бы эта штука была бы не инъективной.
[43:03.460 --> 43:06.460]  Но можем ли мы по слову прийти в одно и то же... это...
[43:06.460 --> 43:09.460]  по одному и тому же слову прийти в два разных состояния?
[43:09.460 --> 43:11.460]  Хорошая DKA.
[43:11.460 --> 43:13.460]  Ну да, хорошая DKA.
[43:13.460 --> 43:15.460]  Вот, тогда эти два состояния совпадают.
[43:15.460 --> 43:17.460]  Значит, это состояние объективно.
[43:17.460 --> 43:19.460]  Это мы тоже с вами обсудили.
[43:20.460 --> 43:22.460]  Это мы тоже с вами обсудили.
[43:23.460 --> 43:25.460]  И переходы мы тоже согласовали.
[43:26.460 --> 43:30.460]  Итак, то есть канонический изоморфизм мы с вами построили.
[43:31.460 --> 43:33.460]  Так?
[43:34.460 --> 43:37.460]  Теперь докажем, что если у нас есть два автомата,
[43:37.460 --> 43:39.460]  M1, M2, PDA,
[43:39.460 --> 43:41.460]  то вот такая штука, которую мы с вами определили,
[43:41.460 --> 43:43.460]  является каноническим изоморфизмом.
[43:46.460 --> 43:48.460]  Вот.
[43:49.460 --> 43:51.460]  Сейчас, секунду.
[43:52.460 --> 43:56.460]  Да, тогда эта штука будет являться изоморфизмом из одного автомата в другой.
[43:57.460 --> 44:01.460]  Единственное, что, скажите, здесь бы неплохо было бы показать.
[44:02.460 --> 44:06.460]  Чтобы действительно сказать, что композиция изоморфизмов это изоморфизм.
[44:09.460 --> 44:13.460]  Ну что, обратно... то есть обратно и изоморфизм тоже можно было бы изоморфизм делать?
[44:13.460 --> 44:15.460]  Ну да.
[44:16.460 --> 44:18.460]  Давайте поймем, верно ли это.
[44:18.460 --> 44:22.460]  Что обратно к изоморфизму в том плане, который мы определили, тоже будет изоморфизмом.
[44:24.460 --> 44:26.460]  Но обратная биекция биекции.
[44:27.460 --> 44:31.460]  Если у нас был переход там, то у нас есть переход там.
[44:31.460 --> 44:35.460]  То есть у нас по факту еще биекция между множеством переходов дельта строилась.
[44:35.460 --> 44:37.460]  Согласованность переходов.
[44:38.460 --> 44:39.460]  Да?
[44:40.460 --> 44:41.460]  Вот.
[44:42.460 --> 44:46.460]  Завершающее состояние тоже вроде бы строится, по сути, между собой биективно.
[44:47.460 --> 44:48.460]  Сохраняет структуру.
[44:49.460 --> 44:52.460]  Но поэтому, применяя каждый из этих свойств к автомату...
[44:53.460 --> 44:58.460]  Ну, для каждого из этих нож по факту построили биекцию, а композиция биекции – биекция.
[44:59.460 --> 45:02.460]  Вообще-то это вообще свойство для всех твоих моделей и так далее.
[45:03.460 --> 45:04.460]  Ну да.
[45:05.460 --> 45:07.460]  Ну, все-таки стоит проговорить.
[45:07.460 --> 45:08.460]  Ну да.
[45:10.460 --> 45:15.460]  Итак, теперь смотрите, как мы можем два МПДК проверять на эквалентность.
[45:16.460 --> 45:22.460]  Мы строим минимальный ПДК для языков, проверяем МПДК на изоморфизм.
[45:23.460 --> 45:27.460]  Тут вопрос, как строить МПДК, но давайте предположим, что у нас есть два минимальных автомата.
[45:28.460 --> 45:33.460]  Скажите мне, пожалуйста, проверка двух графов на изоморфизм – это какая задача?
[45:33.460 --> 45:34.460]  По сложности.
[45:35.460 --> 45:36.460]  Ну, тяжелая какая-то.
[45:37.460 --> 45:41.460]  Возможно, тяжелая, но тогда всем банковским системам хана.
[45:42.460 --> 45:44.460]  Значит, ну, если тяжелая, то тяжелая.
[45:45.460 --> 45:52.460]  А скажите, почему проверка двух автоматов на изоморфизм – это все-таки не тяжелая задача?
[45:55.460 --> 45:56.460]  Ну, полных автоматов.
[45:56.460 --> 45:57.460]  Почему?
[45:58.460 --> 46:03.460]  Ну да, потому что на самом деле у нас на переходах автоматов написаны буквы.
[46:04.460 --> 46:11.460]  И мы, по сути, можем сказать, что у нас, не знаю, если мы построим автомат с переходом для каждой буквы,
[46:12.460 --> 46:14.460]  то степень каждой вершины в этом автомате будет равна единице.
[46:15.460 --> 46:16.460]  То есть, по факту, это будет функция.
[46:17.460 --> 46:19.460]  А там проверить две функции на изоморфизм.
[46:19.460 --> 46:22.460]  Ну, это уже какая-то, мне кажется, не сложная задача.
[46:23.460 --> 46:30.460]  Ну, то есть, вам нужно просто проверить, что если у вас есть переход по одной букве и переход по второй букве,
[46:31.460 --> 46:40.460]  вам просто, не знаю, можно мапчик хранить, STD-мап, который просто будет обновляться с проходом BFS по нашему PDK.
[46:40.460 --> 46:47.460]  Если вдруг у нас какая-то неконсистенция си обнаружится, допустим, мы перешли по одному переходу в одно состояние, оказались в другом,
[46:48.460 --> 46:51.460]  значит, скорее всего, у нас два автомата не изоморфны между собой.
[46:53.460 --> 46:54.460]  А теперь вопрос.
[46:55.460 --> 46:56.460]  Как строить минимально PDK?
[46:58.460 --> 46:59.460]  Так.
[47:00.460 --> 47:02.460]  А теперь я спрошу, у кого был минимальный PDK?
[47:03.460 --> 47:04.460]  У кого был минимальный PDK?
[47:04.460 --> 47:05.460]  Ага.
[47:06.460 --> 47:10.460]  Значит, у вас, по идее, уже должен быть этот факт был озвучен.
[47:11.460 --> 47:12.460]  Как строить?
[47:13.460 --> 47:14.460]  Большая табличка.
[47:15.460 --> 47:16.460]  Да, большая табличка.
[47:17.460 --> 47:26.460]  На самом деле, для того, чтобы строить эквивалентность MPDK, нам нужно эквивалентность MPDK.
[47:26.460 --> 47:38.460]  На самом деле, для того, чтобы строить эквивалентность MPDK, нам нужно эквивалентность определить не для всех слов, а для слов ограниченной длины.
[47:40.460 --> 47:42.460]  И мы это с вами как раз сейчас будем делать.
[47:43.460 --> 47:47.460]  Необходимо получить не эквивалентные состояния, но у нас есть только слова.
[47:48.460 --> 47:51.460]  В общем, идея такая, вводим эквивалентность по словам малой длины.
[47:52.460 --> 47:55.460]  Мы ему говорим, что два слова эквивалентны по N.
[47:56.460 --> 48:00.460]  Если для любого слова длины не больше, чем N, у нас выполнены условия эквалентности.
[48:02.460 --> 48:03.460]  А?
[48:07.460 --> 48:12.460]  Ой, да, эквалентность состояния по словам малой длины.
[48:15.460 --> 48:16.460]  Так, где мы будем писать?
[48:16.460 --> 48:18.460]  Опять же говорю, что мы здесь фиксируем язык L.
[48:46.460 --> 48:52.460]  Ой, блин, уже то.
[48:55.460 --> 48:57.460]  Давайте покажем следующее свойство.
[49:00.460 --> 49:03.460]  Скажите мне, пожалуйста, следующую вещь.
[49:04.460 --> 49:13.460]  Если Q1 и эквалент на Q2 по слову N плюс 1, то из этого что мы можем вывести?
[49:17.460 --> 49:18.460]  По N, да.
[49:23.460 --> 49:25.460]  А еще что мы можем сказать про tilde N?
[49:26.460 --> 49:27.460]  Какое это отношение?
[49:33.460 --> 49:34.460]  Отношение эквалентности, конечно.
[49:40.460 --> 49:44.460]  А теперь давайте построим цепочку следующего толка.
[49:44.460 --> 49:48.460]  Опять же, мы можем определить фактор множества.
[49:49.460 --> 49:51.460]  Ой, это и все история. Q от tilde N.
[49:53.460 --> 49:54.460]  Разбей на классы эквалентности.
[49:55.460 --> 50:03.460]  Вопрос. Как между собой связаны вот эти два класса?
[50:09.460 --> 50:10.460]  Кто кого?
[50:15.460 --> 50:17.460]  Первый не больше, чем второй.
[50:18.460 --> 50:20.460]  Хорошо. Первый не больше второго.
[50:21.460 --> 50:24.460]  Ну и в итоге мы можем с вами простроить эту цепочку.
[50:24.460 --> 50:28.460]  Чем мы этим множеству сверху можно ограничить?
[50:29.460 --> 50:30.460]  Q slash tilde.
[50:30.460 --> 50:33.460]  Да, Q slash tilde. Либо Q slash tilde бесконечность.
[50:36.460 --> 50:39.460]  Ну и в итоге мы можем с вами простроить эту цепочку.
[50:39.460 --> 50:42.460]  Чем мы этим множеству сверху можно ограничить?
[50:43.460 --> 50:44.460]  Q slash tilde.
[50:44.460 --> 50:47.460]  Да, Q slash tilde. Либо Q slash tilde бесконечность.
[50:51.460 --> 50:54.460]  А теперь вопрос, который я хочу задать.
[50:55.460 --> 51:01.460]  Если у нас в каком-то месте у нас бесконечная цепочка знаков не больше,
[51:03.460 --> 51:05.460]  то что можно сказать про это?
[51:06.460 --> 51:09.460]  То что можно сказать про эту цепочку?
[51:10.460 --> 51:11.460]  У нее есть предел.
[51:12.460 --> 51:13.460]  У нее есть предел. Ладно.
[51:14.460 --> 51:16.460]  А если мы рассмотрим про предель, ой, про дискретный случай,
[51:17.460 --> 51:19.460]  это все-таки у нас на тро...
[51:20.460 --> 51:22.460]  Да, с какого момента они станут все одинаковыми?
[51:23.460 --> 51:24.460]  Вот.
[51:25.460 --> 51:27.460]  И давайте докажем следующий факт.
[51:28.460 --> 51:29.460]  По факту это будет LEMO.
[51:36.460 --> 51:40.460]  Которое на самом деле нам скажет, что при первом нарушении...
[51:41.460 --> 51:43.460]  При первом знаке равенства мы можем останавливаться.
[51:45.460 --> 51:47.460]  Значит, оно говорит следующее.
[51:48.460 --> 51:52.460]  Если у нас Q1 эквалентно Q2,
[51:55.460 --> 52:01.460]  следует, что Q1 эквалентно Q2 по множеству словам длины не больше, чем n плюс 1,
[52:01.460 --> 52:12.460]  то получается Q1 эквалентно Q2 по n плюс 2.
[52:16.460 --> 52:18.460]  Так, сейчас давайте-ка я точно сформулирую это все дело,
[52:19.460 --> 52:21.460]  потому что кажется, я мог сформулировать это не так.
[52:32.460 --> 52:33.460]  А?
[52:39.460 --> 52:42.460]  Да, не особо. Я утверждаю просто следующее, что если у нас
[52:43.460 --> 52:47.460]  два состояния внезапно ультворяли этому соотношению,
[52:48.460 --> 52:53.460]  да, грубо говоря, что при добавлении классов у нас с вами ничего не произошло,
[52:54.460 --> 52:58.460]  то и дальше у нас при добавлении классов ничего особенного происходить не будет.
[52:58.460 --> 53:00.460]  Итак, давайте вот так скажем.
[53:01.460 --> 53:03.460]  Вот лучше вот так говорить.
[53:04.460 --> 53:06.460]  Да, да, да, согласен.
[53:25.460 --> 53:27.460]  Из этого следует это, то будет...
[53:28.460 --> 53:33.460]  будет выполнено вот это свойство.
[53:34.460 --> 53:40.460]  Итак, давайте посмотрим следующее.
[53:41.460 --> 53:45.460]  Что такое... сейчас.
[53:46.460 --> 53:52.460]  Нам нужно сделать хитрый фильм тушами.
[53:53.460 --> 53:56.460]  Значит, давайте рассмотрим два слова.
[53:57.460 --> 53:58.460]  Сейчас.
[54:02.460 --> 54:06.460]  Что происходит с произвольными словами длины не больше, чем n плюс два?
[54:07.460 --> 54:15.460]  Рассмотрим произвольные q1, q1, q2.
[54:16.460 --> 54:22.460]  Давайте рассмотрим для любого слова длины не больше, чем n плюс два q1.
[54:27.460 --> 54:28.460]  Так.
[54:36.460 --> 54:39.460]  Вот, выполнено вот это следующее соотношение.
[54:41.460 --> 54:42.460]  Смотрите.
[54:44.460 --> 54:47.460]  Чему это утверждение эквалентно?
[54:47.460 --> 54:49.460]  Ну, во-первых...
[54:51.460 --> 54:55.460]  Я хочу сказать, что мы просто сейчас будем... это в итоге будет...
[54:55.460 --> 54:56.460]  Давайте так напишу.
[54:56.460 --> 54:57.460]  q1.
[55:00.460 --> 55:02.460]  Вот это утверждение эквалентно этому.
[55:04.460 --> 55:06.460]  Вот это утверждение эквалентно этому.
[55:07.460 --> 55:09.460]  Вот это утверждение эквалентно этому.
[55:09.460 --> 55:11.460]  А теперь смотрите, что сделаем.
[55:11.460 --> 55:16.460]  Если в нашем слове длина хотя бы два, то можем написать следующее.
[55:40.460 --> 55:41.460]  Угу.
[55:44.460 --> 55:46.460]  Ну, первую букву вытащили.
[55:47.460 --> 55:48.460]  Угу.
[55:48.460 --> 55:50.460]  А тогда вот это как переписывается?
[55:52.460 --> 55:54.460]  Если мы букву a фиксируем.
[56:02.460 --> 56:04.460]  Давайте фиксируем букву a.
[56:09.460 --> 56:11.460]  Плюс один, да.
[56:29.460 --> 56:30.460]  Угу.
[56:30.460 --> 56:32.460]  А это чему эквалентно?
[56:40.460 --> 56:43.460]  Какие состояния у нас тогда n плюс один эквалентно?
[56:49.460 --> 56:50.460]  Да.
[57:02.460 --> 57:04.460]  А из этого что будет следовать?
[57:04.460 --> 57:05.460]  А?
[57:08.460 --> 57:13.460]  Эти же два состояния уже n эквалентны.
[57:16.460 --> 57:18.460]  У нас классы не расширились.
[57:18.460 --> 57:21.460]  То есть если мы из класса n-того в n плюс один перешли,
[57:21.460 --> 57:24.460]  и состояния у нас не увеличились,
[57:25.460 --> 57:28.460]  то тогда, типа, если у нас...
[57:28.460 --> 57:32.460]  была n плюс один эквалентность для каких-то произвольных состояний,
[57:32.460 --> 57:37.460]  то этот класс, грубо говоря, не расширился, он остался тем же самым.
[57:37.460 --> 57:41.460]  Поэтому если для двух вершин у нас выполнена n плюс один эквалентность,
[57:41.460 --> 57:45.460]  то для этого класса, для этих вершин, будет выполнена n эквалентность.
[57:46.460 --> 57:48.460]  Вот это основная идея перехода.
[57:48.460 --> 57:53.460]  Мы сказали следующее, что если у нас q1 эквалентная q2 в n плюс два,
[57:54.460 --> 57:59.460]  это значит, что если для любой буквы a, у нас будет выполнено вот это свойство.
[58:04.460 --> 58:11.460]  Да, n плюс один эквалентный, q2 эквалентный, q1 эквалентный, q2 эквалентный, q2 эквалентный.
[58:11.460 --> 58:13.460]  У нас будет выполнено вот это свойство.
[58:17.460 --> 58:19.460]  Да, n плюс один, да.
[58:19.460 --> 58:22.460]  А из этого будет следовать, если это свойство выполнено,
[58:22.460 --> 58:25.460]  из этого будет следовать, что дельта q1 а уже n эквалентна.
[58:27.460 --> 58:31.460]  А теперь нам надо вот это все провернуть обратно.
[58:36.460 --> 58:38.460]  Ой, сори.
[58:41.460 --> 58:43.460]  Что у нас получается?
[58:43.460 --> 58:46.460]  У нас получается следующее, что для любого a,
[58:48.460 --> 58:52.460]  для любого слова u такое, что u не больше, чем n,
[58:54.460 --> 58:58.460]  дельта q1 по au
[59:11.460 --> 59:13.460]  а u лежит в f, да?
[59:33.460 --> 59:35.460]  А это чему эквалентно?
[59:36.460 --> 59:38.460]  А это эквалентно тому, что у нас q1
[59:41.460 --> 59:43.460]  n плюс один.
[59:43.460 --> 59:45.460]  То есть рассмотрим два произвольных состояния,
[59:45.460 --> 59:48.460]  если они были n плюс два эквалентны, то они тоже будут n плюс один эквалентными.
[59:54.460 --> 59:56.460]  Ох, стоп, стоп, стоп, стоп.
[59:56.460 --> 59:58.460]  В смысле?
[01:00:06.460 --> 01:00:10.460]  Так, сейчас, секунду, мне надо было наоборот, видимо, да?
[01:00:10.460 --> 01:00:13.460]  Да, мне надо было эту всю историю наоборот провернуть.
[01:00:20.460 --> 01:00:22.460]  Да, да, да, да.
[01:00:23.460 --> 01:00:26.460]  Мне надо было доказать, что если две вершины n плюс один эквалентны,
[01:00:26.460 --> 01:00:28.460]  то они будут n плюс два эквалентны.
[01:00:28.460 --> 01:00:30.460]  Давайте фиксить.
[01:00:40.460 --> 01:00:43.460]  Когда вот я делал f с частичками n,
[01:00:43.460 --> 01:00:46.460]  и я подумал, что состояние отель находится на азии,
[01:00:46.460 --> 01:00:49.460]  и кое-кто отель находится на азии,
[01:00:49.460 --> 01:00:52.460]  я переведу по общему отношению.
[01:00:52.460 --> 01:00:54.460]  Ага.
[01:00:54.460 --> 01:00:56.460]  Хотя они были эквалентны по азии.
[01:00:56.460 --> 01:00:58.460]  Да, так, давайте посмотрим,
[01:00:58.460 --> 01:01:02.460]  будет ли это корректно, если мы эквалентно заменим на не эквалентно?
[01:01:04.460 --> 01:01:07.460]  Не, не, не, сейчас, секунду, дайте-ка это.
[01:01:07.460 --> 01:01:10.460]  Я, по-моему, еще зала...
[01:01:12.460 --> 01:01:15.460]  Так, давайте посмотрим, что тут предъявляется.
[01:01:26.460 --> 01:01:28.460]  Да, да, да, да, да, так.
[01:01:33.460 --> 01:01:35.460]  Смотрите.
[01:01:35.460 --> 01:01:37.460]  Хотите научу это читать?
[01:01:38.460 --> 01:01:40.460]  Надо читать в обратном порядке.
[01:01:42.460 --> 01:01:44.460]  У нас же следствие будет спереди.
[01:01:44.460 --> 01:01:45.460]  А?
[01:01:45.460 --> 01:01:47.460]  Мы не в следствие, а по стороне.
[01:01:47.460 --> 01:01:51.460]  А, давайте нам, единственное, вот тут надо понять, что это...
[01:01:54.460 --> 01:01:57.460]  Смотрите, на самом деле следствие такое у нас.
[01:01:59.460 --> 01:02:01.460]  Я утверждаю, что здесь знак туда-сюда.
[01:02:01.460 --> 01:02:03.460]  Почему?
[01:02:03.460 --> 01:02:07.460]  Потому что мы говорили, что если любых двух состояний,
[01:02:07.460 --> 01:02:09.460]  если у нас n эквалентность,
[01:02:09.460 --> 01:02:11.460]  то она станет n плюс 1 эквалентностью.
[01:02:11.460 --> 01:02:13.460]  Выполнено. У нас это условие выполнено.
[01:02:14.460 --> 01:02:17.460]  Да, поэтому здесь мы можем вернуться вот сюда.
[01:02:18.460 --> 01:02:19.460]  В обе стороны.
[01:02:19.460 --> 01:02:22.460]  Отсюда-сюда это верно просто так, просто по определению,
[01:02:22.460 --> 01:02:24.460]  а отсюда-сюда эта история верна,
[01:02:24.460 --> 01:02:26.460]  потому что мы используемся нашим свойством.
[01:02:33.460 --> 01:02:34.460]  Ага.
[01:02:35.460 --> 01:02:38.460]  Понятно, почему мы можем все это выражение читать снизу наверх?
[01:02:40.460 --> 01:02:42.460]  Давайте я напишу даже.
[01:02:58.460 --> 01:03:00.460]  Все, доказали.
[01:03:01.460 --> 01:03:02.460]  А?
[01:03:05.460 --> 01:03:06.460]  Не, ну можно.
[01:03:06.460 --> 01:03:10.460]  Только когда рассказывать экзаминатору, рассказывать в обратном порядке.
[01:03:11.460 --> 01:03:12.460]  Ну, то есть давайте еще раз.
[01:03:12.460 --> 01:03:14.460]  Если q1, q2, n плюс 1 эквалентны,
[01:03:14.460 --> 01:03:17.460]  тогда для любого слова длины не больше, чем n плюс 1,
[01:03:17.460 --> 01:03:18.460]  у нас выполнена эта штука.
[01:03:19.460 --> 01:03:20.460]  Давайте рассмотрим первую букву.
[01:03:21.460 --> 01:03:27.460]  И тогда окажется, что у нас delta q1a и delta q2a будут n эквалентными.
[01:03:27.460 --> 01:03:31.460]  А если они n эквалентны, то они n плюс 1 эквалентны.
[01:03:32.460 --> 01:03:35.460]  Тогда для любого слова u длины не больше, чем n плюс 1,
[01:03:35.460 --> 01:03:36.460]  у нас есть эквалентность.
[01:03:37.460 --> 01:03:41.460]  Приписываем букву a, поскольку у нас буква a произвольная,
[01:03:41.460 --> 01:03:44.460]  то это верно будет для любого слова длины не больше, чем n плюс 2.
[01:03:46.460 --> 01:03:47.460]  Перевернули.
[01:03:53.460 --> 01:03:54.460]  Такой факт.
[01:03:54.460 --> 01:03:55.460]  Теперь смотрите.
[01:03:57.460 --> 01:03:58.460]  Как строить...
[01:03:58.460 --> 01:03:59.460]  Так, количество левым понятно?
[01:04:01.460 --> 01:04:05.460]  То есть получается, если в какой-то момент количество классовой количества совпало,
[01:04:05.460 --> 01:04:06.460]  то дальше можно не двигаться.
[01:04:08.460 --> 01:04:10.460]  А и на семинарах вы как раз это делаете.
[01:04:11.460 --> 01:04:12.460]  Но мы с вами это делаем.
[01:04:13.460 --> 01:04:14.460]  Да, Вить?
[01:04:14.460 --> 01:04:19.460]  Помните, была табличка, где мы смотрели переходы по букве a по букве b
[01:04:19.460 --> 01:04:21.460]  и смотрели, разбиваются ли у нас классы.
[01:04:21.460 --> 01:04:23.460]  Если у нас классы разбиваются, двигаемся дальше.
[01:04:23.460 --> 01:04:25.460]  Если не разбиваются, заканчиваем.
[01:04:27.460 --> 01:04:28.460]  Вот.
[01:04:29.460 --> 01:04:31.460]  Собственно, и количество состояний, за которые это происходит,
[01:04:31.460 --> 01:04:33.460]  это количество состояний минус 2.
[01:04:33.460 --> 01:04:36.460]  Потому что у нас внизу q0 это 2.
[01:04:36.460 --> 01:04:39.460]  Это у нас завершающее или незавершающее состояние.
[01:04:39.460 --> 01:04:41.460]  А в конце у нас количество классов q.
[01:04:44.460 --> 01:04:45.460]  Вот.
[01:04:45.460 --> 01:04:47.460]  Теперь как строится алгоритм.
[01:04:47.460 --> 01:04:50.460]  У нас q0 это f или q без f.
[01:04:51.460 --> 01:04:54.460]  И дальше у нас расширяется класс тогда, когда
[01:04:56.460 --> 01:05:01.460]  либо у нас q1, q2 не эквалентны, а q1 и q2 оказались не n плюс 1 эквалентны.
[01:05:01.460 --> 01:05:04.460]  Значит, у нас есть переход по букве, который перевел нас в разные классы.
[01:05:05.460 --> 01:05:07.460]  Ну и собственно, переход по первой букве,
[01:05:07.460 --> 01:05:10.460]  то есть если мы смотрим слово длины n плюс 1,
[01:05:10.460 --> 01:05:13.460]  первая буква у нас н плюс 1.
[01:05:14.460 --> 01:05:16.460]  Смотрим слово длины n плюс 1.
[01:05:16.460 --> 01:05:20.460]  Первая буква нас переводит в класс эквалентности по n.
[01:05:20.460 --> 01:05:22.460]  То есть на одну букву меньше.
[01:05:24.460 --> 01:05:29.460]  Значит, кто хочет, тут есть замечательный пример,
[01:05:29.460 --> 01:05:32.460]  в котором можно прямо проехаться по этой штуке.
[01:05:33.460 --> 01:05:34.460]  В общем.
[01:05:39.460 --> 01:05:41.460]  Не-не-не, но это семинарский блок,
[01:05:41.460 --> 01:05:45.460]  поэтому все-таки я советую перед контрольной посмотреть.
[01:05:45.460 --> 01:05:47.460]  Да, и кстати, про контрольную.
[01:05:47.460 --> 01:05:49.460]  Контрольная будет на шестой неделе курса.
[01:05:51.460 --> 01:05:53.460]  Вот, первая контрольная.
[01:05:53.460 --> 01:05:56.460]  А то Виталий меня просил передать.
[01:05:59.460 --> 01:06:00.460]  У нас четвертая...
[01:06:00.460 --> 01:06:01.460]  Стоп.
[01:06:01.460 --> 01:06:03.460]  У нас четвертая лекция, да.
[01:06:06.460 --> 01:06:07.460]  То есть еще будет лекция,
[01:06:07.460 --> 01:06:09.460]  а после лекции неделя будет контрольная.
[01:06:12.460 --> 01:06:15.460]  Вот, теперь смотрите, это одна из задач контрольной будет.
[01:06:16.460 --> 01:06:19.460]  По регулярному выражению надо будет построить импдк.
[01:06:19.460 --> 01:06:21.460]  Давайте поймем, что нам надо делать.
[01:06:21.460 --> 01:06:23.460]  Нам нужно построить nk с однобуквенными переходами,
[01:06:23.460 --> 01:06:25.460]  убрать epsilon-переходы.
[01:06:26.460 --> 01:06:27.460]  Строим dk.
[01:06:27.460 --> 01:06:29.460]  Тут, кстати, знак не более пропущен.
[01:06:29.460 --> 01:06:30.460]  Строим dk.
[01:06:30.460 --> 01:06:31.460]  Строим pdk.
[01:06:31.460 --> 01:06:33.460]  Минимизируем его.
[01:06:35.460 --> 01:06:36.460]  Вот.
[01:06:37.460 --> 01:06:38.460]  Пять.
[01:06:38.460 --> 01:06:40.460]  Это самая муторная.
[01:06:44.460 --> 01:06:46.460]  Пара, пара, да.
[01:06:49.460 --> 01:06:51.460]  Да, она будет на семинаре.
[01:06:52.460 --> 01:06:55.460]  Ну и, наверное, коллеги-семинаристы вам рассказывали,
[01:06:55.460 --> 01:06:57.460]  что это все можно запрогать.
[01:07:00.460 --> 01:07:01.460]  Во.
[01:07:01.460 --> 01:07:03.460]  Значит, давайте дальше двинемся.
[01:07:04.460 --> 01:07:07.460]  А на самом деле те факты, которые у нас сегодня были,
[01:07:07.460 --> 01:07:10.460]  позволяют привести примеры неавтоматных языков,
[01:07:10.460 --> 01:07:12.460]  которые не являются автоматными.
[01:07:12.460 --> 01:07:15.460]  И вот за последние 15 минут нам надо разобраться с этим.
[01:07:15.460 --> 01:07:17.460]  Значит, первая теорема, которая у нас будет,
[01:07:17.460 --> 01:07:19.460]  это теорема Махилла Нейроуда,
[01:07:19.460 --> 01:07:21.460]  которая говорит следующим,
[01:07:21.460 --> 01:07:24.460]  что язык автоматный тогда и только тогда,
[01:07:24.460 --> 01:07:28.460]  когда количество классов эквалютности конечна.
[01:07:29.460 --> 01:07:30.460]  Так.
[01:07:46.460 --> 01:07:49.460]  Мы, кажется, в прошлый раз делали безуспешную попытку
[01:07:49.460 --> 01:07:51.460]  это доказать.
[01:07:53.460 --> 01:07:55.460]  Итак, давайте докажем.
[01:07:56.460 --> 01:07:57.460]  Да.
[01:07:57.460 --> 01:07:59.460]  Значит, L автоматный.
[01:08:02.460 --> 01:08:04.460]  Существует PDK.
[01:08:07.460 --> 01:08:08.460]  M.
[01:08:10.460 --> 01:08:11.460]  L от M.
[01:08:12.460 --> 01:08:13.460]  Да.
[01:08:13.460 --> 01:08:17.460]  И в чем, как ограничивается у нас количество состояния
[01:08:17.460 --> 01:08:19.460]  количества классов эквалютности?
[01:08:23.460 --> 01:08:24.460]  Ну да.
[01:08:24.460 --> 01:08:26.460]  В обратную сторону.
[01:08:27.460 --> 01:08:28.460]  Да.
[01:08:28.460 --> 01:08:31.460]  Строим так, как sigma.
[01:08:35.460 --> 01:08:38.460]  То мы проведем алгоритм построения.
[01:08:51.460 --> 01:08:54.460]  Поскольку я не любитель аббревиатур, давайте напишем M0.
[01:08:54.460 --> 01:08:57.460]  У нас у него было определение.
[01:08:57.460 --> 01:08:59.460]  Я прямо написал, что это M0.
[01:09:01.460 --> 01:09:02.460]  Ну все.
[01:09:05.460 --> 01:09:06.460]  Обратно.
[01:09:06.460 --> 01:09:08.460]  Мы сказали, что количество классов эквалютности бесконечно.
[01:09:08.460 --> 01:09:09.460]  Ой, конечно.
[01:09:09.460 --> 01:09:13.460]  Значит, мы можем построить по языку канонические MPDK.
[01:09:13.460 --> 01:09:16.460]  Он не зависит от инструкции, он зависит только от языка.
[01:09:16.460 --> 01:09:17.460]  Что упал?
[01:09:17.460 --> 01:09:18.460]  Не упал.
[01:09:18.460 --> 01:09:19.460]  А.
[01:09:21.460 --> 01:09:22.460]  Господи.
[01:09:22.460 --> 01:09:23.460]  Ладно.
[01:09:23.460 --> 01:09:29.460]  Давайте докажем один пример, который крайне интересный.
[01:09:29.460 --> 01:09:31.460]  Ну мы с этим языком еще поработаем.
[01:09:32.460 --> 01:09:34.460]  Значит, пример такой.
[01:09:35.460 --> 01:09:36.460]  Почему он не автоматный?
[01:09:36.460 --> 01:09:42.460]  Нам необходимо привести бесконечное количество по пару неней эквалютных слов.
[01:09:42.460 --> 01:09:45.460]  А bright and dark?
[01:09:45.460 --> 01:09:47.460]  Мы не будем делать это.
[01:09:47.460 --> 01:09:51.460]  Мы будем делать это по параметрам, по параметрам.
[01:09:51.460 --> 01:09:53.460]  Мы будем делать это по параметрам.
[01:09:55.460 --> 01:09:58.460]  Мы будем делать это по параметрам.
[01:09:58.460 --> 01:10:00.460]  А на предыдущем этапе?
[01:10:00.460 --> 01:10:01.460]  Ну да.
[01:10:01.460 --> 01:10:20.100]  слов? N произвольная. Да, да. Мы говорим, что для любых N и N, неравных N, N, а в N не
[01:10:20.100 --> 01:10:30.660]  эквалентно A в N-ты. Почему? Мы что, рассмотрим слово W равное? B в N-ты, получаем A в N-ты,
[01:10:30.660 --> 01:10:43.820]  B в N-ты принадлежит языку. L, ой, наоборот. Все. Ну, неравном можно сказать, неважно.
[01:10:43.820 --> 01:11:01.780]  У нас количество букв должно совпадать. Вот. Вот мы научились на лекции решать еще
[01:11:01.780 --> 01:11:09.340]  одну задачу с контрольной. Ну, нет, конечно, они будут сложнее, на семинарах будут рассмотрены
[01:11:09.340 --> 01:11:17.100]  примеры, но там нужно будет по языку понять, является он автоматным или не является. А в N-ты,
[01:11:17.100 --> 01:11:23.780]  B в N-ты это первый пример не автоматных языков. Но есть еще один факт, который мы сейчас тоже,
[01:11:23.780 --> 01:11:31.540]  несмотря на то, что у нас осталось десять минут, мы с вами его тоже докажем. Он называется
[01:11:31.540 --> 01:11:45.020]  лемма о разрастании. И это слово у нас прозвучит далеко не один раз. В англоязычном
[01:11:45.020 --> 01:11:54.580]  литературе называется помпинг лемма, лемма о накачке. Так, собственно, это мы посмотрели.
[01:11:55.540 --> 01:12:00.020]  Вот. Я пока ищу зарядку, а вы вдупляете, что тут происходит.
[01:12:00.020 --> 01:12:21.500]  Значит, лемма о разрастании. В чем она заключается? Что существует такое слово,
[01:12:21.500 --> 01:12:30.500]  что существует такое P, что для любого слова из языка такое, что его длина хотя бы P. Существует
[01:12:30.500 --> 01:12:36.980]  разбиение на слова x, y, z. Для любого слова существует разбиение такое, что v равно x,
[01:12:36.980 --> 01:12:44.700]  y, z. Длина x, y не больше, чем p, y не пустое. И тогда для этого слова мы можем разрастать серединку.
[01:12:51.500 --> 01:13:02.100]  Не, прикол в том, что… Нет, длина y… Да, существует разбиение на слова x, y. Существует
[01:13:02.100 --> 01:13:09.100]  такое, что оно будет выполнено условием, и для любого k будет выполнена такая фигня.
[01:13:09.100 --> 01:13:30.100]  Так. Для любого слова… Существует P. А? P это константа какая-то.
[01:13:39.100 --> 01:13:56.060]  Так, доказательство. Рассмотрим автомат с однобуквенными переходами.
[01:13:56.060 --> 01:14:19.260]  С однобуквенными переходами такие, что l от m равно l. И положим P равное
[01:14:19.260 --> 01:14:36.180]  количеству состояния в автомате. Тогда смотрите, если у нас длина слова хотя бы P… Что мы можем
[01:14:36.180 --> 01:14:51.500]  сказать? Если длина слова хотя бы P равное количество состояния в Q, то если мы рассмотрим цепочку,
[01:14:51.500 --> 01:15:06.860]  смотрите. Ну, допустим, это у нас v1, и так далее, vkt. w1, vkt. За один переход мы переходим qe, t.
[01:15:06.860 --> 01:15:18.940]  Ну, давайте напишу. qe, t получается v, it, plus 1, и так далее, vkt. qk, t, которая, опять же,
[01:15:18.940 --> 01:15:30.940]  у нас будет в завершающем состоянии, l. Что мы можем сказать про последовательность q0, и так далее, qk, t?
[01:15:30.940 --> 01:15:51.500]  Ну, смотрите. Всего членов последовательности хотя бы k, plus 1 здесь. Это равняется как минимум
[01:15:51.500 --> 01:15:59.100]  больше равно, чем к количеству состояния plus 1. А сколько у нас состояния в этом автомате? q.
[01:15:59.100 --> 01:16:14.780]  Впоминаем принцип дирекле. Существуют две вершины, в которых qe равно к уже тому. Возьмем
[01:16:14.780 --> 01:16:44.540]  минимальное такое же. Давайте я теперь картинку покажу просто. Вот тут вот у нас и qe,
[01:16:44.780 --> 01:16:50.780]  и вот тут у нас qt. Тогда давайте вот эту вещь обозначим за x, эту за y, эту за z.
[01:16:50.780 --> 01:17:07.260]  Тогда у нас для любого k x, y, y, z будет лежать в языке? Да, почему? Ну, сколько-то раз по циклу
[01:17:07.260 --> 01:17:17.500]  прошлись, и ладно с ним. Дальше скажите мне, почему длина x, y не больше, чем p? Это самое
[01:17:17.500 --> 01:17:34.780]  интересное, что тут здесь есть. Мы взяли минимальное такое g. Минимальное g, следовательно q0, qg-1 различно.
[01:17:34.780 --> 01:17:46.340]  Но из этого будет следовать, что g-1 не больше количества состояния минус 1. Вот так вот.
[01:17:46.340 --> 01:17:58.980]  Ой, это получается не больше, чем количество. Сейчас, секунду. Нумерация 0. Это получается,
[01:17:58.980 --> 01:18:08.300]  если у нас 1. Это q. Не, количество состояния минус 1, да. Вот, а слово w1, wg, начнем длина не
[01:18:08.300 --> 01:18:20.220]  больше, чем количество состояния. Вопрос, почему игрок не пустой? Да, иначе и равно g.
[01:18:20.220 --> 01:18:35.100]  Я автомат, у нас однобуконными переходами. Так, теперь смотрите. Я сейчас буду писать страшную
[01:18:35.100 --> 01:18:41.940]  вещь, но нам надо ее написать для того, чтобы мы с вами ее могли понять. Напишем отрицание этой
[01:18:41.940 --> 01:18:56.340]  фигни. Так, что нам надо сделать для того, чтобы написать отрицание? Да, для любого p существует такое
[01:18:56.340 --> 01:19:08.500]  слово, длина слова, хотя бы p. Такое, что для любых w равна x, y, z. Таких, что длина x, y не больше p,
[01:19:08.500 --> 01:19:28.380]  длина y не равняется нулю. Дальше. Существует k. Тут что? Не лежит в языке l. Из этого следует
[01:19:28.380 --> 01:19:39.500]  что? l не автоматный. То есть смотрите, по сравнению с вот этим страшным свойством, что нам говорит
[01:19:39.500 --> 01:19:46.740]  отрицание? Нам достаточно подобрать одно слово для произвольного p. Достаточно рассмотреть его
[01:19:46.740 --> 01:19:54.620]  произвольное разбиение. Кстати, сразу скажу, контрольный. Если где-то в ваших мыслях проверяющий
[01:19:54.620 --> 01:20:01.140]  увидишь, что здесь знак не для любого a существует, вам поставят ноль за задачу. Такие правила.
[01:20:01.140 --> 01:20:09.220]  Если в мыслях на контрольной будут здесь внезапно вместо знака для любого, окажется знак существует.
[01:20:09.220 --> 01:20:21.340]  Это такая критическая ошибка. Ладно, давайте воспользуемся этим для слова awn и bwn. Для
[01:20:21.340 --> 01:20:35.620]  нашего языка awn и bwn. Рассмотрим p из лемы. И рассмотрим слово w равное awp и bp.
[01:20:35.620 --> 01:20:52.740]  Тогда что мы можем сказать про слова x, y? Рассмотрим произвольный x, y и z. Если у нас длина
[01:20:52.740 --> 01:21:03.860]  x, y не больше чем p, то что из этого следует? Да, из этого автоматически будет следовать,
[01:21:03.860 --> 01:21:20.580]  что из устройства нашего слова x равно awn, y равно awm, но az равняется awp-m-l на bp.
[01:21:20.580 --> 01:21:41.540]  Какое слово тогда нам не подойдет? Какое слово выбьет нас из автомата? Да, x, y квадрат нас выбьет из языка.
[01:21:41.540 --> 01:21:48.820]  Что у нас получается? А в чем?
[01:21:48.820 --> 01:22:11.860]  Am больше нуля, ну потому что у нас игрок не пустой.
[01:22:18.820 --> 01:22:34.060]  Из этого получаем, что l не автоматный. Не поверите, мы даже уложили сегодня вовремя.
[01:22:34.060 --> 01:22:40.580]  Вот, в общем, смотрите, давайте подытожим, что мы сегодня с вами научились делать. Мы с вами,
[01:22:40.580 --> 01:22:50.380]  во-первых, построили минимальный pdk, доказали, что он является наименьшим, и дальше, значит,
[01:22:50.380 --> 01:22:57.860]  да, тут еще дополнительные трюки, которые можно применять. Можно их тоже в их семинаре посмотреть.
[01:22:57.860 --> 01:23:04.580]  В общем, мы построили с вами наименьший автомат сегодня, раз, доказали, что он именно наименьший,
[01:23:04.580 --> 01:23:11.780]  и три, мы посмотрели, как можно доказывать, что языки не являются автоматными. Все, в следующий раз
[01:23:11.780 --> 01:23:16.820]  будет уже другая конструкция, которая немножко обобщает конструкцию автомата.
