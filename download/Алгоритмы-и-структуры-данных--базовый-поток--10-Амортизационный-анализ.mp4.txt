[00:00.000 --> 00:06.480]  Сегодня будет некоторая теоретическая лекция опять на примере того, что это такое,
[00:06.480 --> 00:12.680]  как это работает, для чего это нужно, почему это важно и что вы с этим можете делать.
[00:12.680 --> 00:17.720]  Как вы думаете, почему называется амортизационный анализ?
[00:17.720 --> 00:22.440]  Чего? Что? Для чего? Есть какие-нибудь идеи?
[00:22.440 --> 00:29.600]  Квиксорт оценивается. Квиксорт оценивается амортизационно.
[00:29.600 --> 00:34.320]  Что еще раз среднее?
[00:34.320 --> 00:43.200]  То есть это среднее время работы. Ну типа.
[00:43.200 --> 00:47.080]  Хорошо, но это не совсем правда.
[00:47.080 --> 00:58.520]  Смотрите, на самом деле амортизационный анализ работает для некоторых вещей и
[00:58.520 --> 01:04.680]  чаще всего он связан с оценкой конкретной операции. Квиксорт не является такой глобальной операцией
[01:04.680 --> 01:10.080]  по факту. Вы можете посмотреть, за сколько он в среднем работает и что он делает,
[01:10.080 --> 01:14.720]  но это скорее оценка именно конкретно какой-то операции.
[01:14.720 --> 01:21.320]  Да, в сортировках, то есть мы можем сказать, что у нас может то выполняться, то не выполняться,
[01:21.320 --> 01:26.800]  тот или иной И, грубо говоря. У нас количество свопов от этого будет меняться, значит и время
[01:26.800 --> 01:31.680]  будет меняться. Да, это можно смотреть, но опять же здесь вопрос скорее про то,
[01:31.680 --> 01:39.640]  за сколько работает именно какая-то операция. А для начала ведем некоторые определения,
[01:39.640 --> 01:48.040]  которые нам нужны, а дальше поймем, что это все значит. Смотрите, нет ревиальный процесс, момент.
[01:48.040 --> 01:57.400]  Давайте еще попробуем левое окошко закрыть.
[01:57.400 --> 02:09.360]  Я попал, отлично. Короче, какие у нас есть здесь определения? Первое, что нам нужно знать об
[02:09.360 --> 02:15.360]  аморитетонном анализе. Ну, предположим, у нас есть какие-то операции. У один, у НТ есть такие операции,
[02:15.360 --> 02:21.560]  мы с ними пытаемся как-то работать и пытаемся их как-то оценивать и понимать, что там происходит.
[02:21.560 --> 02:30.480]  Вот здесь у меня индекс поехал, но это неважно. Пусть реальное время работы каждой операции равно Т1,
[02:30.480 --> 02:40.960]  и так далее, ТН. И что будет, если мы нарисуем это на каком-нибудь таком вот графике? Предположим,
[02:40.960 --> 02:50.120]  у нас есть вот это время работы, а вот это номер нашей операции. Я тебе чуть поменьше это сделаю.
[02:50.120 --> 02:57.960]  Вот. А к чему все это может приводить? Это может приводить к следующим интересным вещам. Пусть у меня
[02:57.960 --> 03:04.240]  там первая операция занимает всего два действия. Два каких-то вот таких вот тривиальных,
[03:04.240 --> 03:09.560]  фундаментальных действия, то есть две единицы чего-то. Ну, тиков, времени, как хотите можете
[03:09.560 --> 03:15.640]  назвать. А другая операция может занимать чуть побольше. Третья вообще очень много, четвертая мало,
[03:15.640 --> 03:22.240]  потом еще что-то большое, потом опять мало, потом еще меньше, а потом опять большое, и так далее.
[03:22.240 --> 03:28.680]  Вот это реальное время работы. Это не прикольно оценивать, не интересно с этим работать. Почему?
[03:28.680 --> 03:33.120]  Потому что это каждый раз зависит от каких-то условий, от чего-то, что произошло, от чего-то,
[03:33.120 --> 03:39.120]  что нам нужно будет в конкретном времени оценить. И мы не хотим этого делать. Почему? По очень простой
[03:39.120 --> 03:44.480]  причине. Потому что какая-то операция может повлиять за собой другую операцию, какая-то может
[03:44.480 --> 03:51.040]  зависеть от предыдущих операций, что-то может происходить. И это оценивается очень нетривиально. И
[03:51.040 --> 04:03.720]  общее время работы какое? Ну, это вот все, что вот тут вот так вот. Я сейчас повыделяю. Вот. К чему мы все
[04:03.720 --> 04:11.400]  это хотим свести? Мы хотим свести это к какому-то новому амортизационному времени. Вот это ТИТ со
[04:11.400 --> 04:19.520]  звездочкой. Это и есть то самое амортизационное время. Я просто буду пытаться сделать так,
[04:19.520 --> 04:26.440]  что у меня все будет плюс-минус выровнено. Максимум какие-нибудь небольшие ямочки есть или там
[04:26.440 --> 04:34.240]  вот такие выбенки. Но в итоге я пытаюсь это все выровнять между собой. И у меня получается такое
[04:34.240 --> 04:44.720]  среднее время работы одной операции. То есть я беру и раскидываю это на все. И вот это все,
[04:44.720 --> 04:51.720]  это суммарное время, это Т звездочка. То есть амортизационное время работы алгоритма. А вот
[04:51.720 --> 04:59.720]  это суммарное время работы нашего алгоритма реальная. И мы для того, чтобы оценивать хоть как-то
[04:59.720 --> 05:05.400]  с помощью больших и так далее, говорим, что вот эта Т со звездочкой, она должна быть больше, чем наша Т.
[05:05.400 --> 05:11.720]  Заметьте, что амортизационно не означает, что они все одинаковые. Да, мы пытаемся свести к какому-то
[05:11.720 --> 05:18.920]  такому одинаковому конструкту, но в том суть, что мы здесь пытаемся это сделать не обязательно
[05:18.920 --> 05:27.200]  на сто процентов. Понятно? То есть здесь мы можем работать амортизационно как хотим. Есть пока к этому
[05:27.200 --> 05:38.880]  вопросу. Вот, а надо на семинарах больше сидеть. Короче, в действительности, смотрите, у нас есть
[05:38.880 --> 05:47.200]  реальное время работы. Вот Т1, к примеру, работает там за два каких-то такта. Т2 работает, не знаю,
[05:47.200 --> 05:59.200]  там за четыре. Т3 за десять. Т4 опять за два и так далее. Вот это неудобно понимать и оценивать каким-то
[05:59.200 --> 06:05.600]  образом. Я хочу все это свести так, чтобы оно было все плюс-минус равномерно. Я пытаюсь его оценить,
[06:05.600 --> 06:12.360]  чтобы суммарное время вот этих времен, сумму мы возьмем вот этого всего, оно равнялось вот примерной
[06:12.360 --> 06:17.360]  сумме вот этого, но было больше, потому что благодаря тому, что оно будет больше,
[06:17.360 --> 06:33.000]  оно всегда позволит нам с этим работать. Понятно? Вот. Это не совсем правда, потому что мы очень
[06:33.000 --> 06:39.000]  часто хотим оценить время работы одной операции. Тебе все равно придется понять вот этот столбик,
[06:39.000 --> 06:47.800]  почему он равен? Понятно? То есть ты точно знаешь, что Т и Т звездочка, это равно там Т, ну грубо говоря,
[06:47.800 --> 06:53.800]  разделить на какой-нибудь Н. То есть у тебя Н операции, у тебя есть Т, вот Т со звездочкой только,
[06:53.800 --> 07:02.560]  прошу прощения. Ну вот среднее, грубо говоря, вот эморфиционное время, оно такое. Понятно? Да.
[07:02.560 --> 07:24.720]  У нас есть четкое количество действий, грубо говоря, целое всегда. Правильно? Представь,
[07:24.720 --> 07:31.840]  что у себя нечетное количество, а здесь четное количество операций. Ну не знаю, операции 10,
[07:31.840 --> 07:46.000]  суммарное время их 91. Ну где-то же, значит, что-то будет чуть выше. Нет. Это важный момент здесь. Да.
[07:46.000 --> 08:07.960]  Это важная информация. Почему? Потому что вы чаще всего, в каком случае вы эморфиационный
[08:07.960 --> 08:15.240]  анализ применяете, в случае какого-то дисбаланса с точки зрения операции. Мы сегодня рассмотрим
[08:15.240 --> 08:20.280]  с вами несколько структур данных на то, что где у нас это не работает. Вы дальше с ней встретитесь,
[08:20.280 --> 08:26.160]  и кто-то из вас писал, что вектор же можно использовать. Вектор, он работает за ввод единички только
[08:26.160 --> 08:32.360]  эморфиционно. Не работает всегда за ввод единички. Добавление элементов, к примеру. Это тоже отдельно
[08:32.360 --> 08:39.520]  доказывает, это тоже отдельно работает. И нам важно, во сколько мы, в принципе, получаем этот ответ.
[08:39.520 --> 08:48.800]  Если у нас было одно расширение, изменение, еще что-то, которое глобально повело то, что у нас
[08:48.800 --> 08:55.840]  время резко вскочило, а потом опять очень долго идет маленьким временем, то нам интересно понять,
[08:55.840 --> 09:02.480]  вот оно повлияет настолько сильно, что у нас будут проблемы с точки зрения времени. То есть,
[09:02.480 --> 09:08.240]  не знаю, элемент мы добавляем за у от логарифма, за у от н или за у от единиц. Вот это важная для
[09:08.240 --> 09:13.600]  нас информация. Потому что мы никогда не работаем с одной конкретной операцией. Мы работаем с каким-то
[09:13.600 --> 09:21.400]  количеством операций. Вот и все. Поэтому здесь, да, мы можем терять информацию о конкретной операции,
[09:21.400 --> 09:30.960]  но мы можем предполагать, даже когда это было. Но это не будет проблемой для нас. Еще есть вопросы?
[09:33.120 --> 09:41.760]  Теперь все понятно. Ну хорошо, посмотрим, как вам все понятно. Смотрите. Ну вот, графички я вам
[09:41.760 --> 09:49.720]  порисовал, сделал. То, вообще, из этого можно сделать. То есть, нам нужно как-то вот вычленить вот эти
[09:49.720 --> 09:57.680]  тейты со звездочкой всегда и как-то с ними работать. Вообще, самые популярные методы амортизованного
[09:57.680 --> 10:04.840]  анализа это следующее. Это метод усреднения, бухгалтерский метод, банковский метод, метод,
[10:04.840 --> 10:11.680]  не знаю, там, бухучета, всегда по-разному называют. Вот, почувствуем сегодня себя немножко бухгалтерами.
[10:11.680 --> 10:24.600]  Да, посмотрите, я про все вам расскажу. Вот, и существует еще метод потенциала. Мы с вами сегодня будем
[10:24.600 --> 10:32.000]  рассматривать каждый из этих методов, но первое, для чего мы это вообще будем оценивать, в каком случае.
[10:32.000 --> 10:39.720]  И мы с вами хотим поработать со следующей структурой данных. Структура данных — это очередь
[10:39.720 --> 10:48.600]  на двух стеках. Встречали такое? Кто-то да, кто-то нет. Давайте с вами подумаем, как нам с помощью
[10:48.600 --> 10:57.160]  стеков реализовать очередь. Для этого, ой, да, все правильно. Как с помощью стеков можно это сделать?
[10:57.160 --> 11:01.800]  У нас есть два каких-то стека, и мы как-то будем перекладывать элементики друг из дружки,
[11:01.800 --> 11:13.840]  чтобы у нас получилось это в виде очереди. То есть, мы с вами помним, что стек по какому правилу работает?
[11:13.840 --> 11:34.440]  Ли-фо. Откуда фи-фо? Это в очереди правильно. Вот, нам нужно из-за этого принципа перейти сюда
[11:34.440 --> 11:41.040]  с помощью некоторых каких-то конструкций того, что у нас происходит. У вас здесь расписано. Давайте
[11:41.040 --> 11:49.240]  порисуем. Рисовать всегда полезно и интересно. Предположим, у нас есть два стека. У нас есть
[11:49.240 --> 12:05.200]  стек ау, у нас есть стек ин. И представим что-то в виде очереди. Я утверждаю следующее. Я буду
[12:05.200 --> 12:15.680]  класть элементы, то есть, пушить в свою очередь какую-то кью, а я их буду просто класть в наш стек ин.
[12:15.680 --> 12:27.480]  Предположим, что я положил сюда один, два, три. С точки зрения очереди это будет как выглядеть? Если
[12:27.480 --> 12:34.600]  я добавил сначала один, потом два, потом три. Предположим, очередь выходит сюда, входит сюда.
[12:34.600 --> 12:52.960]  Три, два, один. Они приходят отсюда, уходят отсюда. Это первый нюанс. Второй нюанс. Предположим,
[12:52.960 --> 12:58.760]  что я хочу из своей очереди убрать элементы. Для того, чтобы убрать, я должен убрать единичку,
[12:58.760 --> 13:07.600]  правильно? В стеке я не могу докопаться до этой единички. Согласны? Что в этом случае делаю? Я
[13:07.600 --> 13:19.320]  в этом случае все элементы переношу в стек ау. Я отсюда забираю, сюда кладу. У меня здесь поп,
[13:19.320 --> 13:42.160]  сюда пуш. Получаю здесь три, два, один. И отсюда эти элементы уходят. Получается вот такая вот картина.
[13:42.160 --> 13:53.040]  И после того, как я пытаюсь удалить элемент, я просто удаляю его из стека ау. Получается,
[13:53.040 --> 14:00.600]  что я удаляю единичку. Теперь я отсюда удалил эту единичку. У меня эта очередь сдвинулась.
[14:00.600 --> 14:15.800]  Лучше я вот так вот сделаю. Один, два, три. Тут еще место в очереди есть. Я удалил эту единичку.
[14:15.800 --> 14:23.520]  Теперь я хочу запушить элемент. Пушить я всегда буду, ну, ставить в очередь, я всегда буду в
[14:23.520 --> 14:32.920]  стек in. Я поставлю сюда четыре. И четыре у меня встает как бы в мою очередь. Теперь предположим,
[14:32.920 --> 14:41.440]  что я хочу удалить элемент. Какой мне удалить надо элемент? Из ау, то есть два. Вот этот элемент я
[14:41.440 --> 14:51.240]  удаляю, я удаляю опять из этого стека. То есть смотрите, пока стек ау не пуст, я удаляю элементы
[14:51.240 --> 15:02.840]  просто из него. Как только стек out пуст, я переношу все элементы из in в стек out и оттуда удаляю.
[15:02.840 --> 15:12.280]  Понятно? Понятно, как это реализовано? Всем? Точно? Да.
[15:22.240 --> 15:30.680]  Почему нам нужно удалить? Еще раз, мы делаем очередь, мы не делаем себе массив, мы делаем очередь.
[15:30.680 --> 15:36.680]  Мы четыре удалим только после того, как все удалим впереди. Еще есть вопросы?
[15:39.040 --> 15:43.280]  Неужели все понятно? Чудеса? Можно.
[15:51.240 --> 15:57.640]  Да, очередь очень можно быстро написать. Когда я обычно спрашиваю на экзамене,
[15:57.640 --> 16:07.080]  как, на чем написать очередь, мне люди говорят, ну, на двухшестном списке, они на одна связана.
[16:07.080 --> 16:15.440]  А стек можно на одна связана написать. В этом случае все ломаются. И мы посмотрим с вами сейчас,
[16:15.440 --> 16:22.120]  за сколько это все работает. Предположим, что у вас написан только стек. Вы с этим как-то живете.
[16:22.120 --> 16:31.000]  Окей? А это на самом деле очень удобная конструкция в изряд. Какое ваше предположение, за сколько это работает?
[16:31.000 --> 16:38.560]  А? Ну вот представьте, у нас есть n элементов в очереди, мы n элементов вставляем, n элементов
[16:38.560 --> 16:43.560]  убираем. Вот наша, по сути, операция здесь является и вставкой, и удалением.
[16:43.560 --> 17:00.320]  За what n? Почему? Это другой вопрос. Грустная история. Ну ничего, значит, мы сейчас рассмотрим это еще раз.
[17:00.320 --> 17:07.400]  Действительности да. Смотрите, вот это перенос элементов с одного стека на другой занимает много времени,
[17:07.400 --> 17:15.560]  согласны? Но в то же время, если я удаляю просто элементы и у меня out не пуст, тогда это происходит быстро,
[17:15.560 --> 17:21.520]  за what единички. Я предполагаю, что push и pop это такие вот фундаментальные вещи, фундаментальные
[17:21.520 --> 17:31.560]  операции, и они работают за единицу времени. Окей? Ну типа, это не сложно. Так вот, с одной стороны в одном
[17:31.560 --> 17:37.440]  случае удаление, оно сработает всего за одну операцию, ой, за один тик такой, а в другом случае за
[17:37.440 --> 17:45.240]  количество элементов в n. Вот это тот самый дисбаланс, который непонятно, как решать с точки зрения
[17:45.240 --> 17:51.320]  обычного анализа алгоритмов, как мы с вами сделали. То есть, если я скажу, что работает за what n,
[17:51.320 --> 17:58.440]  это не круто, это непонятно, потому что в действительности оно не всегда так работает, и мы хотим понять,
[17:58.440 --> 18:03.080]  за сколько это будет действительно работать. Поэтому здесь нам на помощь приходит тот самый
[18:03.080 --> 18:08.640]  амортизационный анализ. И на примере очереди на двух стэках мы с вами будем сейчас разбираться с тем,
[18:08.640 --> 18:17.160]  что здесь есть, как это делать. На примере всех трех амортизационных анализов, его методов,
[18:17.160 --> 18:30.440]  которые я вам говорил. Поехали. Вот если мы говорим с точки зрения вот такого некоторого обобщения,
[18:30.440 --> 18:40.520]  то то, что мы сейчас с вами проговорили, это вот здесь вот и описано. То есть, по факту вот
[18:40.520 --> 18:45.240]  интуитивно мы видим, вот когда вы понимаете, что нужен амортизационный анализ, вы интуитивно
[18:45.240 --> 18:53.240]  видите, что у вас после какой-то одной тяжелой операции есть много маленьких и легких. Значит,
[18:53.240 --> 19:00.200]  здесь что-то не так. Значит, здесь есть какая-то хитрость, и почему-то это было сделано. И с этим
[19:00.200 --> 19:06.520]  необходимо поработать. И первый метод, с которым мы с вами знакомимся, это метод усреднения. Метод
[19:06.520 --> 19:14.920]  усреднения очень прост в своем представлении. Вы просто считаете количество действий, которые
[19:14.920 --> 19:23.320]  у вас выполняется на всем промежутке действий. Получается таким образом амортизационное время и
[19:23.320 --> 19:29.640]  говорите, что в среднем, то есть вот это ТИТ звездочка амортизационное время одной операции
[19:29.640 --> 19:36.840]  равно Т звездочка разделить наверное. Понятно? Вот это в этом заключается метод усреднения.
[19:36.840 --> 19:43.040]  Метод усреднения очень прост, но не всегда работает. Это не означает, что мы с помощью
[19:43.040 --> 19:48.520]  него можем посчитать абсолютно все. Нет, к сожалению, у нас будут здесь проблемы. Вот, и мы с вами
[19:48.520 --> 19:56.160]  с этим столкнемся на следующей лекции, когда будем говорить про новое бинарное дерево поиска. Но,
[19:56.360 --> 20:02.040]  пока здесь этим можно еще посчитать. Это очень часто применяется в каких-то достаточно простых
[20:02.040 --> 20:11.040]  структурах данных. И очередь на двух стэках одним из таких является. Смотрите, для простоты я буду
[20:11.040 --> 20:17.720]  говорить, что очередь в начале и в конце является пустой. То есть я в начале в нее что-то вставляю,
[20:17.720 --> 20:24.360]  она была пустой, что-то какие-то элементы есть, и в конце обязательно все элементы удалю. Вот я буду
[20:24.360 --> 20:33.040]  пока говорить в таком обобщении. Это просто упрощается с точки зрения подсчета. Поехали
[20:33.040 --> 20:39.360]  с вами дальше. Первое, добавление элементов. Добавление элементов требует всего лишь один
[20:39.360 --> 20:52.080]  push. Вот сюда. Согласны? Вот. То есть вот push это происходит вот так. Мы делаем этот push и
[20:52.080 --> 20:58.320]  если я буду вставлять n элементов, то есть я говорю, у меня есть n элементы, которые вставляются в мою
[20:58.320 --> 21:05.240]  очередь. Я вставляю n элементов, значит у меня получается n умножить на единичку, n вот таких
[21:05.240 --> 21:12.920]  вот простейших операций будет сделано. Согласны? Теперь поехали с вами в удаление. С точки зрения
[21:12.920 --> 21:22.480]  удаления. Когда мы с вами просто берем и удаляем элемент из out, это вот один раз происходит,
[21:22.480 --> 21:27.920]  и больше этого элемента у нас не появляется. Поэтому в этом случае мы говорим, что каждый
[21:27.920 --> 21:34.600]  элемент так или иначе был будет удален из out. Согласны? Поэтому мы говорим, что это количество
[21:34.600 --> 21:43.000]  операций, которая там займет, количество вот этих простых тиков, это будет 1 умножить на n. То есть n
[21:43.000 --> 21:54.960]  попов из out будет. Окей? Теперь давайте с вами рассуждать. Представим следующую картину. У меня
[21:54.960 --> 22:06.200]  вот есть stack out, а есть stack in. Я вначале перебрасываю вот сюда, а как я там обозначал, это n и t. Хорошо.
[22:06.200 --> 22:15.000]  Вот у меня есть n и t элементов, вот я их перебрасываю сюда, они у меня становятся. Потом я начинаю еще
[22:15.000 --> 22:21.280]  раз удалять все эти элементы, в это время там что-то вставлялось, и у меня появляется n и
[22:21.280 --> 22:27.360]  плюс первое, к примеру, элементы. И я опять их перебрасываю. Согласны, что каждая переброска
[22:27.360 --> 22:35.120]  одного элементика, это два действия. Отсюда pop, отсюда push. Правда? А теперь мне нужно понять,
[22:35.120 --> 22:45.720]  чему равна сумма всех этих n? Так как я вставляю суммарно n элементов, то у меня всегда вот эта
[22:45.720 --> 22:51.200]  переброска элементов, я должен буду удалить все n элементы, то вот эта переброска элементов
[22:51.200 --> 23:02.000]  будет происходить вот по сумме n и t, а сумма n и t это равно суммарно n. Потому что все элементы
[23:02.000 --> 23:09.080]  побывали здесь и сюда тоже перешли, и каждый это сделал единожды. Окей? Понятно?
[23:09.080 --> 23:21.440]  Мне не нравятся ваши потухшие лица. Это просто вытащить элементик.
[23:21.440 --> 23:35.040]  Тащить элементику не надо, он и так бедный. Еще раз, добавление вот было,
[23:35.040 --> 23:41.640]  мы с вами только что говорили про это. Добавить это 1 умножить на n. Тоже n операция нам требуется.
[23:41.640 --> 23:50.840]  Подожди, там у меня написано именно удаление элементов, вот это является пересчетом удаления,
[23:50.840 --> 24:00.920]  только лишь удаление. Вот, то есть смотрите, я перетаскиваю n элементов отсюда сюда и для того,
[24:00.960 --> 24:09.080]  чтобы их перетащить, я сначала удаляю вот отсюда, потом вставляю вот сюда, поэтому это умножается
[24:09.080 --> 24:29.200]  еще и на 2. Вот, благодаря этому мы с вами получаем, что у нас удаление, друзья, удаление суммарно
[24:29.240 --> 24:44.440]  занимает 3n простых операций, простейших. Согласны? Понятно? Нет, мы не заполняем, вот это только лишь
[24:44.440 --> 24:55.680]  удаление. Удаление всех n элементов из очереди займет 3n действий. Нет, из нашей очереди, из очереди.
[24:55.680 --> 25:10.000]  Очередь это равно вот этой композиции. Смотри, вначале все пусто, потом я кидаю элементы сюда,
[25:10.000 --> 25:17.760]  я и могу удалять и вставлять элементы в любой момент времени, абсолютно в любой. Я вставляю сюда
[25:17.760 --> 25:24.200]  элементы и я говорю, что каждый элемент вставляется всего лишь один раз и все, что нужно для вставления,
[25:24.200 --> 25:32.360]  это сделать push. Поэтому мне нужны n операции простых, ну типа n таких вот действий, простейших,
[25:32.360 --> 25:38.640]  для того, чтобы вставить элементы. Получается n вещей. Теперь удаление элементов. Что происходит в
[25:38.640 --> 25:44.360]  момент удаления элементов? В момент удаления элементов я должен перетащить часть, если у меня
[25:44.360 --> 25:52.000]  out пустой, то перетащить часть элементов отсюда сюда, а это два раза, то есть отсюда pop делаю,
[25:52.000 --> 25:59.320]  сюда push этого элемента, а потом отсюда еще удалить. Получается три действия таких. Два действия
[25:59.320 --> 26:06.080]  на перенос, одно действие на удаление. Сколько я переношу элементов? Ну предположим, что их
[26:06.080 --> 26:13.200]  перекидываю периодически. Каждый раз я перекидываю, ну вот каждый элемент, который перебрасывается,
[26:13.200 --> 26:21.200]  он перебрасывается едино, он не может переброситься потом еще раз. Согласен? Этому на самом деле вот
[26:21.200 --> 26:26.160]  с переброской у нас будет делаться следующее. Вот у нас есть какое-то нытое элементы, к примеру. Нам
[26:26.160 --> 26:35.240]  нужно их перебросить. Мы их перебрасываем сюда. Это займет два нытох простых операций. Потом я
[26:35.240 --> 26:43.040]  беру, удаляю из out, удаляю из out это тоже будет нытое. Согласен? Потом я беру, у меня здесь уже что-то
[26:43.040 --> 26:47.840]  вставилось, еще раз перебрасываю, еще раз что-то происходит и так далее. Поэтому удаление у меня
[26:47.840 --> 26:55.560]  занимает 3n таких операций. То есть удаление и вставка мы с вами посмотрели. Суммарно они будут
[26:55.560 --> 27:10.800]  стоить 4n для моей очереди. Ой, сейчас будет смешной косяк, 4n делить внутри. Прошу прощения. Такое тоже
[27:10.800 --> 27:33.280]  бывает. Вспоминаю себя на олимпиадах. Неправда. Мы добавляем, удаляем, вставляем, удаляем. Нет,
[27:33.280 --> 27:42.640]  нет, смотрите. Я сказал, что у меня есть всего лишь элементарные операции push и pop. Еще раз,
[27:42.640 --> 27:46.960]  у меня есть элементарные операции. Я не смотрю, как реализован стэк. Стэк можно вообще на этом
[27:46.960 --> 27:53.040]  реализовать. Кстати, еще очень важный момент. К примеру, почему очередь иногда можно сделать
[27:53.040 --> 28:00.120]  на стэке? Потому что очередь у вас всегда нужен односвязанный список, а стэк можно представить
[28:00.120 --> 28:10.440]  в виде расширяющегося массива. Подумайте об этом. Ну типа, вы просто кладете в массив и удаляете
[28:10.440 --> 28:19.640]  с конца. Удалять с конца за 1 можно в любом массиве. Ставить в конец тоже за 1. Но можете взять
[28:19.640 --> 28:27.080]  очень большой массив и просто мусор хранить и вот понимать, где вы находитесь сейчас. Вот вам
[28:27.080 --> 28:47.400]  применение вот этого чуда. Очень полезно. Да. Будет, но еще раз, если вы сделаете его,
[28:47.400 --> 28:52.040]  к примеру, на 10 тысяч или на 100 тысяч элементов, ничего критического не произойдет, если это инты.
[28:52.040 --> 29:01.720]  Да, такое возможно. Никто не спорит. Никто не говорит, что это мир идеален. Вот, но что поделать?
[29:01.720 --> 29:11.560]  Вот, поэтому, да, ну там 4, естественно. Поэтому в действительности амортизационное время работы
[29:11.560 --> 29:17.960]  с одним элементом и вставкой его и удалением это 4. Если хотите, можете разбить, что амортизационное
[29:17.960 --> 29:25.920]  время вставки это единичка, амортизационное время удаления это 3. Три таких вот простейших действия.
[29:25.920 --> 29:34.400]  И это хорошо. То есть мы говорим, что амортизационный это работает за у от единички. Нет здесь никакого у от н.
[29:34.400 --> 29:52.280]  Окей, понятно. Вопросы к этому есть? Еще раз. Перекладывание за счет чего работает? За счет того,
[29:52.280 --> 30:03.720]  что мы удаляем отсюда, вставляем сюда. Это два. Окей, вопросы есть? Вопросов нет. Хорошо.
[30:03.720 --> 30:10.960]  Пересмотрите следующее. Следующий это банковский метод. В самом деле, банковский метод периодически
[30:10.960 --> 30:15.960]  определяют по-разному. Вы можете самостоятельно, мы с вами посмотрим и один случай, и второй случай,
[30:15.960 --> 30:21.440]  как здесь что происходит. Банковский метод представляет собой следующее. Представьте,
[30:21.440 --> 30:29.240]  что вы бухгалтер и работаете с монетками. Ну, например, с рублями. Не знаю, у вас по одному рублю,
[30:29.240 --> 30:35.640]  у нас инфляция и так типа хорошая. Можете с центом и так же играться. Короче, плюс-минус одно и
[30:35.640 --> 30:42.960]  тоже будет. Короче, представьте, у вас монетка. Рубль у вас есть, вы с ним как раз-таки что-то
[30:42.960 --> 30:50.200]  делаете. И вот вы за каждую простейшую операцию должны будете компьютером. То есть у вас компьютер
[30:50.200 --> 30:57.600]  такой, вы могате. Либо он будет что-то делать, либо не будет. Причем, пока у вас есть деньги,
[30:57.600 --> 31:02.080]  он делать что-то будет. Но как только они у вас закончатся, ваша дружба закончилась,
[31:02.080 --> 31:06.760]  все, к сожалению, у вас не будет больше компьютера, он не будет ничего выполнять. То есть вы не можете
[31:06.760 --> 31:17.960]  никогда вылезать в долги. Запомните это на рабоучение. А суть банковского метода в следующем. У
[31:17.960 --> 31:23.440]  вас есть какой-то мешочек с монетками, и вы их можете раздать. Либо какой-то конкретной операции
[31:23.440 --> 31:28.920]  давать какое-то определенное количество монеток, либо элементам, которые есть, они будут тратить
[31:28.920 --> 31:35.360]  эти монеты. Вот вы можете исходить из этого. И тогда в этом случае вот то количество монет,
[31:35.440 --> 31:44.480]  которое вы отдали, является тем самым амортизационным общим временем. Причем каждый элемент в каждый
[31:44.480 --> 31:49.880]  момент времени или суммарно, вы не должны действительно залезать в отрицательное число.
[31:49.880 --> 31:59.320]  Нельзя быть должником компьютера. Это машина, а вы всего лишь кожаный мешок. Поэтому, к сожалению,
[31:59.320 --> 32:06.440]  здесь ничего не будет работать. Только за деньги, к сожалению. Таким образом, в этом случае,
[32:06.440 --> 32:13.600]  когда у нас есть тот самый мешочек, с которым мы с вами работаем, мы и начинаем с ним что-то
[32:13.600 --> 32:22.300]  делать. И так мы сможем оценить время необходимое нашей работе. В данном случае лучше всего раздать
[32:22.300 --> 32:30.860]  каждому из элементиков какое-то количество монеток. Вот в этом случае можно это сделать.
[32:30.860 --> 32:35.980]  А предположим, что мы каждому элементику дадим четыре монетки.
[32:35.980 --> 32:46.500]  Ну мы живем в цифровом мире. Представь, что у тебя есть биткоин, и ты богатая. Вот,
[32:46.500 --> 33:01.660]  ну все. К сожалению, все. Ну в действительности вот так. Просто представить. Да. Изначально мы
[33:01.660 --> 33:07.540]  просто это придумываем на самом деле. То есть мы с помощью этого пытаемся оценить. И вот грубо
[33:07.540 --> 33:13.740]  говоря, если я возьму и дам три монеты мне, и я попытаюсь их как-то раздать, как-то оптимизировать,
[33:13.740 --> 33:19.780]  у меня ничего не получится. Я буду в долгах, а значит, это не работает. Вот. Мы здесь с вами
[33:19.780 --> 33:24.780]  работаем с точки зрения времени. Вот эта монетка обозначает одно время, грубо говоря. И каждая
[33:24.780 --> 33:34.140]  операция будет стоить какое-то время для нас. По-хорошему. То есть каждая операция стоит ту самую
[33:34.140 --> 33:43.580]  монетку. Вот монетка равно время. Время, деньги, запомнили? Нет, нет, нет, нет, нет. Вы можете
[33:43.580 --> 33:49.060]  просто прикинуть, как вы можете это раздать и как с этим работать. Вот здесь я понимаю,
[33:49.060 --> 33:56.260]  анализируя просто, типа, саму структуру данных, что на push мне нужно, ну на вставку элемента мне
[33:56.260 --> 34:02.220]  нужно одна монетка. На то, чтобы убрать элемент, мне понадобится точно три монетки. И вот если я
[34:02.220 --> 34:08.580]  раздам четыре монетки каждому из элементов в своей очереди, то есть, грубо говоря, в push я возьму
[34:08.580 --> 34:15.580]  и еще дам три, заплачу сам, и еще дам три монетки элемента, тогда он всегда сможет оттуда уйти с
[34:15.580 --> 34:24.540]  этой очереди. Вот такая адская карусель получается. Поэтому как-то так. И вот здесь сама суть в том,
[34:24.540 --> 34:30.980]  что, типа, мы раздали эти монетки, получили что-то, и если мы потратили 4 монеток, значит, в среднем одна
[34:30.980 --> 34:41.660]  операция стоила четыре. Понятно? Отличается от подхода. В среднем, я считаю количество действий,
[34:41.660 --> 34:47.660]  получаю сумму и уже тут смотрю. Здесь у меня есть какое-то определенное количество денег,
[34:47.660 --> 35:00.100]  и я от него отталкиваюсь. Да. Это твоя интуиция должна быть. В этом действительности есть свой
[35:00.100 --> 35:06.220]  шарм этого всего. То есть, да, вы откадываете от того, сколько вам монеток нужно. Вы можете
[35:06.220 --> 35:11.380]  поанализировать код, понять, что с ним делать. То, что у вас существует метод усреднения, равно, что он
[35:11.380 --> 35:16.900]  всегда очень полезен, очень интересен. Мы с вами посмотрим на более сложные структуры данных, что с
[35:16.900 --> 35:39.020]  ним происходит, окей? Могу пять монеток всем раздать. Элементы идут радостно с одной монеткой. Могу,
[35:39.020 --> 35:46.980]  могу. Мне главное оценить вот само качество, количество. Вот. Поэтому здесь в действительности
[35:46.980 --> 35:52.700]  с банковским методом все просто. Вот именно с точки зрения стека на двух, ой, господи,
[35:52.700 --> 36:00.780]  очереди на двух стеках. Самое интересное всегда происходит в методе потенциалов. Вот здесь ваша
[36:00.780 --> 36:08.740]  интуиция должна работать на полную катушку. Что здесь подразумевается? Смотрите. Ведем некоторые
[36:08.740 --> 36:19.020]  потенциал. Потенциал из состояния нашего какого-то в не отрицательные целые числа. Он может быть
[36:19.020 --> 36:28.140]  нулевой, но он всегда не отрицательный. Это первый важный момент. И я скажу, что амортизационная
[36:28.140 --> 36:36.100]  стоимость одного действия будет равна реальному количеству действий, которое у меня было,
[36:36.100 --> 36:41.660]  плюс потенциал, который был, плюс разность потенциалов, которая изменилась в этот момент.
[36:41.660 --> 36:51.700]  Понятно, что я сейчас сделал? Непонятно. Грустная история. Смотрите. А, предположим,
[36:51.700 --> 37:02.060]  ну вот я говорю, что ТИТ со звёздочкой равно ТИТ плюс ФИ СИТОВА минус ФИ СИ минус первое.
[37:02.060 --> 37:11.940]  Что такое СИТ? Это состояние какой-то моей структуры. Что такое может быть состояние?
[37:11.940 --> 37:20.820]  Состояние просто сколько элементов в структуре? Сколько, не знаю, элементов в левом стыке? Сколько
[37:20.820 --> 37:28.100]  элементов в массиве? Может быть логарифм от количества элементов и так далее. То есть
[37:28.100 --> 37:34.700]  вот этот потенциал, он должен как-то из состояния возвращать чиселка. Как это вы можете делать?
[37:34.700 --> 37:42.220]  Это любое ваше представление. Главное, что должно быть здесь, что каждый потенциал не отрицателен. То
[37:42.220 --> 37:52.740]  есть для любого И ФИ СИТОВА больше либо равно нуля и первое, что у вас есть, что ФИ в нулевом
[37:52.740 --> 38:03.540]  состоянии равно нулю. Вот это является потенциал. Вы же физики. Кто тебе такое сказал?
[38:03.540 --> 38:18.980]  Ещё раз. Нулевой равен нулю. Хорошо. Первый может быть равен трём, а второй может быть равен нулю или один.
[38:18.980 --> 38:31.220]  Ну СНОЛЬ это состояние в самом начале. Начальное самое состояние. Ну ещё раз у меня может быть
[38:31.220 --> 38:37.940]  сначала. Ну представь, что я убрал элементы. У меня сумма элементов типа в моей очереди. Я убрал
[38:37.940 --> 38:44.100]  элементы. У меня состояние-то уменьшилось. И ФИ уменьшилось. У меня нет возрастания здесь.
[38:49.860 --> 38:57.100]  Ещё. Первое точно возрастёт или не убывает? Ну ещё раз. У тебя может быть вот такой график.
[38:57.100 --> 39:10.380]  Ну да. Ну у тебя иначе вот это не будет выполнено. В начале вниз мы не пойдём,
[39:10.380 --> 39:15.860]  но потом мы можем ходить. Вот такой график спокойно может быть. Да.
[39:19.980 --> 39:34.100]  ТИТ и ТИТ? ТИТ и СИТ, конечно, связаны. Да, смотрите. Для того, чтобы перейти с СИ-1 в СИТ,
[39:34.100 --> 39:39.140]  я должен был потратить какое-то количество действий, какое-то количество времени. Вот этот
[39:39.140 --> 39:46.020]  переход занял у меня таитое время. Это реальное время, которое заняло. Понятно? Всё, вопрос.
[39:46.020 --> 39:57.820]  Да. Потенциал. Потенциал – это просто функция из состояния внеотритательные числа, обладающая тем,
[39:57.820 --> 40:02.420]  что первое у нас нулевое. Ну вот в данном случае я буду говорить об этом. И для любого он
[40:02.420 --> 40:11.020]  не отрицательный. Всё, это функция. А я говорю здесь выполняется равенство – это уже дальше.
[40:11.020 --> 40:15.500]  Потенциал – это просто функция. Выполняется равенство – это я говорю, что у меня будет такая
[40:15.500 --> 40:22.660]  мартизационная стоимость ТИТ-го звёздочка. Для чего я это делаю? Смотрите, важно понять,
[40:22.660 --> 40:34.180]  для чего я это делаю. Давайте смотреть. Предположим, что СИТ-я звёздочка равно ТИТ плюс ИСИТ минус ФИ
[40:34.180 --> 40:46.420]  от СИ-1. Да? Согласны? Вопрос следующий. Чему равно Т звёздочка? Оно равно сумме СИТ-я звёздочка.
[40:46.420 --> 40:58.740]  Согласны? И оно равно сумме, получается, стейтах. Да? А потом здесь у меня чё начинается? Плюс ФИ от С1
[40:58.740 --> 41:13.860]  минус ФИ от С0, плюс ФИ от С2 минус ФИ от С1 и так далее. Закончится это всё, что будет плюс ФИ от СМТ
[41:13.900 --> 41:30.660]  минус ФИ от СН-1. Согласны? Это получается, что сумма стейтах плюс ФИ от СНТ минус ФИ от С0. Вот это
[41:30.660 --> 41:41.220]  у меня ноль. Согласны? Вот это у меня не отрицательное. Правда? Получается, что всё это больше либо равно,
[41:41.220 --> 41:53.620]  чем Т, потому что вот это это Т. Поняли, в чём суть, в чём фичает этого всего? Вот именно в этом.
[41:53.620 --> 42:02.060]  Зачем я говорю, что у меня ФИ С0 должно быть нулевым? Потому что вот этот минус, он не должен
[42:02.060 --> 42:07.980]  мне случайно убить. Это так, чтобы Т со звёздочкой было меньше, чем Т. Мне этого не нужно. Мне нужно
[42:07.980 --> 42:14.140]  сказать, что у меня амортизационное время должно быть всегда больше, чем Т. А вот это может быть
[42:14.140 --> 42:20.300]  какое-то больше либо равно нуля. Может быть ноль, может быть нет. Понятно? Почему это называется
[42:20.300 --> 42:26.340]  метапотенциалов? Ну я думаю, вы с потенциальными полями, по типу, ну со школы ещё знакомые, по типу
[42:26.340 --> 42:32.780]  вот силопритяжения. Вы неважно, по какому пути пройдёте, у вас работа одинакова. Вот это оттуда же.
[42:32.780 --> 42:46.660]  Просто дискретно. Вопросы? Сейчас мы всё будем смотреть. Подождите, сначала теоретическую часть.
[43:02.780 --> 43:12.580]  У вас могут быть возникать проблемы с тем, что у вас что-то будет не работать. Важный момент здесь
[43:12.580 --> 43:26.700]  какой? Мне надо подобрать такой потенциал, что все ты и ты одинаковы почти с точки зрения, ну типа,
[43:26.700 --> 43:32.700]  не знаю, симпатически, можно сказать. Ну то есть этот там работает за один, этот за два, этот за три,
[43:32.700 --> 43:40.740]  но это нормально. Тогда в этом случае ты хотя бы понимаешь, чему равна сумма Т равна, понимаешь? Вот.
[43:40.740 --> 43:49.020]  А вот всего остального здесь уже начинается интрига. Если же ты потенциалы ведёшь такие,
[43:49.020 --> 43:56.340]  что у тебя ты и ты будут различаться, то тебе это не даст ровным счётом ничего. Почему? Потому что
[43:56.340 --> 44:02.380]  я хочу сделать так, чтобы я написал, что Т со звёздочкой примерно равно ты и ты какая-нибудь
[44:02.380 --> 44:10.860]  звёздочка, любая и ты, умножить на Н. Я хочу к этому свести. Я хочу убрать тот самый дисбаланс,
[44:10.860 --> 44:15.980]  про который мы говорили с самого начала. Вот это перекидывание, чтобы у меня не было дисбаланса.
[44:15.980 --> 44:26.300]  Функция Fee в смысле?
[44:26.300 --> 44:50.580]  Примерно то же самое хотим. Мы хотим, чтобы вот это было одинаково. Но функция потенциала может
[44:51.580 --> 45:02.660]  прям абсолютно. И мы с вами посмотрим на следующей лекции. Обычно после неё умирают. Не в прямом
[45:02.660 --> 45:15.060]  смысле, а то мало ли ещё что-нибудь скажут. Но в действительности да, это всё сделано для того,
[45:15.140 --> 45:23.060]  чтобы вот это мракетационное время работать. То есть весь фокус именно вот в этом. И всё.
[45:23.060 --> 45:30.380]  Понятно? А теперь предложить потенциал для очереды на двух стэков.
[45:30.380 --> 45:54.980]  Каком-то в каком? Почему? Это было пальцем в небо или как? Интуиция почти верна, но не
[45:54.980 --> 46:04.300]  совсем. Разность тоже не сильно нам поможет. Разность всегда будет при удалении, к примеру,
[46:04.300 --> 46:18.860]  единичка. Ин плюс три аут. Может быть, что-то и получится на самом деле. Я не думал. Но в
[46:19.860 --> 46:28.900]  вам важно понимать, как подойти к выбору потенциалов. А выбор потенциалов должен
[46:28.900 --> 46:37.300]  заключаться в следующем. Когда у вас есть какая-то дешёвая операция, разность потенциалов должна
[46:37.300 --> 46:46.540]  быть дешёвая. Потому что у вас вот это время ТИТ, оно дешёвое. А значит, вот эта разница должна
[46:47.500 --> 46:56.860]  не быть дорогой. Это первое. Второе. Когда вот эта операция дорогая, вот эта разность потенциалов
[46:56.860 --> 47:02.420]  должна быть скорее отрицательна для того, чтобы выровнять что-то дешёвое. Понятно?
[47:02.420 --> 47:18.180]  Да, это правда. Только двойное количество элементов. Потому что у нас время, ну вот
[47:18.180 --> 47:27.900]  типа реальное время работы. Это же нужно сделать поп и сделать push. Два раза количество. Можем. У
[47:27.900 --> 47:36.500]  тебя получится, что время работы будет h. Смотри. Давайте сейчас я попишу, потом я раскрою все карты.
[47:36.500 --> 47:50.940]  Смотрите, все очень просто. Если вы говорите, что ваш phi от s этого равен количеству элементов
[47:51.620 --> 48:02.380]  Предположим. Согласны? Вот мы это взяли. Предположим, что мы перекидываем элементы. Вот в моем а,
[48:02.380 --> 48:11.260]  вот это пусть будет h какое-то. Я перекидываю эти элементы в alt. Тогда моя ТИТ звёздочка равно
[48:11.700 --> 48:26.860]  Оно равно 2a плюс 1. Потому что я сделал поп отсюда h элементов, push сюда h элементов и pop верхнего
[48:26.860 --> 48:38.420]  элемента. Согласны? А теперь разность потенциалов. Потенциал, который есть сейчас, так как я перекинул
[48:38.420 --> 48:44.500]  все элементы, у меня ноль. Согласны? Ну у меня высота стокеин стала ноль. Я ж удалил элементы.
[48:44.500 --> 48:56.660]  Подожди, я говорю phi s это. Я ещё не сделал minus phi s. И делаю минус. Phi s и минус первое. На
[48:56.660 --> 49:06.220]  si минус первом шаге у меня h элементов лежало в моем стокеин. Согласны? Минус h. Смотри, у тебя
[49:06.220 --> 49:20.260]  время работы это h плюс 1. Проблема. А вот если я возьму два на количество элементов и сделаю
[49:20.260 --> 49:31.820]  минус два h, все будет хорошо. И в этом случае у меня будет здесь просто единичка. Осталось проверить
[49:31.820 --> 49:43.940]  для других элементов, что это будет происходить так. Вот это удаление с перекидыванием. Что
[49:43.940 --> 49:48.180]  будет происходить с удалением без перекидывания? С удалением без перекидывания все будет очень
[49:48.180 --> 49:54.420]  просто. Я буду говорить, что ты звездочка, это равно. Если я удаляю элементы, у меня в аут что-то
[49:54.420 --> 50:00.500]  есть, то мне не важно удалил я элементы из аут или нет. У меня потенциал остался такой же. Согласны?
[50:00.500 --> 50:09.380]  Как был h, так и остался. Поэтому я говорю, что это 1, потому что я сделал поп из аута. Плюс h
[50:09.380 --> 50:22.140]  минус h. Это 1. Ну и последнее, что у меня осталось, это t и t со звездочкой в случае вставки элемента.
[50:22.140 --> 50:31.980]  В случае вставки элемента я говорю, что 1 тик трачу на push, правильно? Стало у меня количество элементов
[50:31.980 --> 50:46.900]  h, ну или h плюс 1, как хотите. Тут 2 на h плюс 1, можно так делать. Минус 2 h, это равно 3. Смотрите,
[50:46.900 --> 51:00.300]  1, 1, 3. Они все в силке, они никак не зависят от n, они ни от чего не зависят. Значит,
[51:00.300 --> 51:05.940]  у меня вот в принципе, вот если я возьму все это t и t, я вот этого знаю, что там будет 3,
[51:05.940 --> 51:15.620]  вот этого всего, там n, суммарно. Ну у меня получится то же самое. Будет 4n,
[51:15.620 --> 51:23.060]  у меня будет 4 просто. То есть среднее время работы операции будет такое же. Вот и все, да.
[51:23.060 --> 51:37.540]  Фив всегда постоянно, иначе ты не можешь их… Ты можешь пытаться подбирать ее, как хочешь.
[51:37.540 --> 51:43.940]  Главное, чтобы в итоге у тебя была она одна, была определенная и ко всему подходила.
[51:54.060 --> 52:08.900]  Чего? Я не понял вопроса. Что значит переменная зависит от h?
[52:08.900 --> 52:22.780]  Типа ты коэффициенты пытаешься подобрать. Ну я только что это делал. Я вот
[52:22.780 --> 52:29.660]  первое, что рассмотрел, мне сказали, пусть будет это h. Просто h. Мы рассмотрели здесь и получили,
[52:29.660 --> 52:36.980]  что у нас здесь будет h плюс 1. И мы поняли, что это нам не подходит. Поэтому я такой, а давай я на 2
[52:36.980 --> 52:44.940]  домножу. Домножу. Получил здесь 1. Осталось проверить для всех остальных. Для всех остальных это
[52:44.940 --> 52:58.380]  тоже подходит. Для всех остальных это тоже подходит. Я нашел потенциал. Ну еще раз, вы подбираете
[52:58.380 --> 53:06.420]  потенциал, вот здесь вы идете прям вообще по наичу. Нет такого, что вы такие типа, блин, все, я знаю,
[53:06.420 --> 53:11.980]  как выбирать потенциалы. Почти, наверное, нет. Это всегда вот просто наработка, интуиция,
[53:11.980 --> 53:18.060]  понимание того, как это происходит. Главная суть потенциалов, что вот благодаря тому, что мы с вами
[53:18.060 --> 53:25.260]  там получили, мы говорим о том, что амортизационное время у нас корректно работает. Понятно? Вот.
[53:25.260 --> 53:42.500]  Если мы все времена просуммируем. Еще раз, нет, подождите. Нет. Вот это удаление, вот это тоже
[53:42.500 --> 53:51.860]  удаление, друзья. Вы чего? Просто какие-то элементы удаляются с помощью, с помощью того,
[53:51.860 --> 53:57.660]  что мы перебрасываем элементы. Какие-то элементы удаляются просто из-за ута. Но не может быть такое,
[53:57.660 --> 54:03.940]  что элементы и так, и так удаляются. Он один раз удаляется. Вот, поэтому четыре суммарные.
[54:03.940 --> 54:25.980]  Вот откуда вот это? Вот это, да? Смотрите, у вас есть 1 стэк, у вас есть 2 стэк. Вот это пустой,
[54:25.980 --> 54:33.220]  вот это вот я считаю именно для вот этого случая, когда это пустой, а здесь аж элементы. Что я должен
[54:33.220 --> 54:41.860]  сделать? Я должен сделать поп из аж элементов, а потом push. А последнее, так как я удаляю элементы,
[54:41.860 --> 54:53.260]  то я должен сделать еще один поп. Вот, поэтому 2 аж плюс 1. Вот это? Это вставка. Когда я вставляю
[54:53.260 --> 55:01.140]  элемент, я всегда вставляю свой стэк in. Согласен? Было аж элементов, стало аж плюс 1 элемент.
[55:01.140 --> 55:10.580]  Я говорю, что вставка занимает одно время, 1 тик, в реальное время. Вот это и так. 2 аж плюс 1 — это
[55:10.580 --> 55:18.220]  новый потенциал. Когда я обновил его, то есть я вставил этот элемент, у меня стало 2 на аж
[55:18.220 --> 55:27.860]  плюс 1 потенциал. А 2 аж предыдущий, 2 аж-2 аж сокращается, получается 3. Еще вопрос. У меня
[55:27.860 --> 55:35.580]  потенциал очень важный, очень нужный, не раз там пригодится. Для вектора пригодится,
[55:35.580 --> 55:45.980]  для сплэй дерева пригодится. Но где вы его еще встретите потом? Очень удобная штука. Окей,
[55:45.980 --> 55:54.820]  вопрос к этому есть? Видимо, нет. Но здесь вот написано примерно то же самое. Да,
[55:54.820 --> 56:09.820]  вот не примерно, а то же самое. Ага. Вопросы есть? Вопросов, видимо, нет. Можно.
[56:09.820 --> 56:23.300]  Еще раз, я могу реализовать стэк с помощью массива, очередь не могу.
[56:23.300 --> 56:34.540]  Ну да, можно.
[56:42.260 --> 56:50.500]  Усреднение не всегда считается, вообще не всегда. Вот мы с вами посмотрим, что это не работает в
[56:50.500 --> 56:58.900]  сплэй дереве. Нормально вы не посчитаете. А банковский метод, он более такой игрушечный и
[56:58.900 --> 57:05.420]  ну типа периодически с помощью него можно посчитать, это нет никаких проблем, можно это сделать.
[57:05.420 --> 57:30.700]  Метод потенциал строго математичен. Каких? Каких возможностей я реализовываю стэк на массиве? Еще раз?
[57:36.340 --> 57:40.460]  Ты не сможешь хранить разные типы значений в стэке? Кто тебе сказал?
[57:40.460 --> 57:56.420]  Хорошо. Вы шаблоны уже прошли? Со структурами? Так, ну да, меня смущает. И делать имплейтные ноды нет,
[57:56.420 --> 58:00.420]  тоже у вас не будет нормально это работать, потому что у вас должен один тот же тип указаться.
[58:00.420 --> 58:10.180]  Ты всё пытаешься теперь сделать так, чтобы это не работало, но это работает. Это можно использовать.
[58:10.180 --> 58:24.220]  Вот, то есть мы можем. Точное количество мы не получим. Амортизационное время еще раз,
[58:24.220 --> 58:29.620]  это тоже это среднее, но у него может быть и снизу и сверху еще ограничения какие-то.
[58:29.620 --> 58:35.180]  Мы получили среднее время. Мы никогда не получим точное,
[58:35.180 --> 58:38.860]  потому что если мы говорим вообще про реальное время, то оно вот так скочет.
[58:38.860 --> 58:49.420]  Что мы делали в прошлых методах? Мы делали, за сколько работает алгоритм, алгоритм, а не конкретная операция.
[58:49.420 --> 59:03.060]  И рассматривали это асимпатически. Здесь я рассматриваю не асимпатически. Вот вообще не асимпатически.
[59:03.060 --> 59:10.740]  Я рассматриваю конкретные n элементы. Понимаете, в чем вся проблема? Когда вы будете говорить про асимптотику,
[59:10.740 --> 59:15.260]  асимптотика где начинает выполняться? У вас может быть какая-то вот такая вот функция,
[59:15.260 --> 59:24.660]  а потом она вот так идет. Вот ее асимптотика там на 10 в 20 степени начинается. Асимптотика, асимптотика.
[59:24.660 --> 59:37.540]  По сути своей да, но здесь в принципе мы к этому не пришли.
[59:37.540 --> 59:52.420]  Потому что меня будет интересовать, за сколько я удаляю из очереди такой конфигурации. Потому что я то за n удаляю,
[59:52.420 --> 01:00:01.380]  то нет. Я могу взять и ограничить только сверху от n сказать. Я хочу понять, как это работает с точки зрения вот такого элемента.
[01:00:01.380 --> 01:00:09.100]  Точно ли вот то, что одна большая тяжелая операция, она перекрывается маленькими или нет?
[01:00:09.100 --> 01:00:16.660]  Давайте с вами посмотрим еще на какую-нибудь интересную штуку. Например, счетчик, двоичный счетчик.
[01:00:16.660 --> 01:00:25.220]  Двоичный счетчик очень прост. У нас есть массив S,K, ячейщик. Там хранятся нолики и единички. И все,
[01:00:25.300 --> 01:00:34.740]  что есть у двоичного счетчика, это инкримент. Берем и увеличиваем чиселка, то есть на единичку.
[01:00:34.740 --> 01:00:44.740]  И нам нужно перекидывать бит. За сколько работает инкримент? Амортизационно или в принципе, как вы думаете?
[01:00:44.740 --> 01:01:01.780]  Так, а? Почему? Потому что я спрашиваю, что... Смотри, ну типа самое первое, самое грубое оценка это у от nk.
[01:01:01.780 --> 01:01:11.140]  Потому что мы можем поменять в k-бит. Теперь мы рассмотрим опять три разных метода, которые есть, только мы будем это рассмотреть быстрее,
[01:01:11.140 --> 01:01:17.700]  потому что, я надеюсь, вы поняли саму суть методов, окей? А первый метод это метод усреднения.
[01:01:17.700 --> 01:01:23.700]  Когда мы говорим с вами, тут много слов написано, я специально написал, потому что это больше для вас почитать.
[01:01:23.700 --> 01:01:31.780]  Я буду рассказывать это больше, окей? Вот, чтобы вы потом к экзамену или к семинару спокойно могли взять, открыть и прочитать.
[01:01:32.740 --> 01:01:46.420]  А здесь мы будем говорить о следующем. Смотрите, как часто меняется первый бит, а нулевой? Он меняется каждые два раза.
[01:01:46.420 --> 01:01:53.540]  Вот инкримент в начале был ноль, потом один, мы увеличиваем его, он меняется каждый раз. Согласны?
[01:01:54.100 --> 01:02:02.900]  Второй бит как часто меняется? Инкримент. Мы раз сделали инкримент, он мог не поменяться, потом сделали два и он уже поменялся.
[01:02:02.900 --> 01:02:14.020]  Каждый второй раз меняется второй бит. Потом мы говорим, что каждый четвертый раз меняется третий бит и так далее.
[01:02:14.020 --> 01:02:24.020]  Понятно, что я имею в виду. То есть мы когда делаем инкримент, наше изменение одного бита какого-то будет сопровождаться,
[01:02:24.020 --> 01:02:31.700]  выполняется только каждое n делить на какое-то количество раз, два в степени i.
[01:02:31.700 --> 01:02:41.540]  Вот благодаря этому мы можем посчитать количество действий. Понятно, почему так происходит, я надеюсь. Правда? Нет?
[01:02:41.540 --> 01:02:43.540]  Кто понимает, что происходит? Давайте так.
[01:02:47.540 --> 01:02:51.540]  Кто не понимает и боится что-то спросить?
[01:02:53.540 --> 01:03:03.540]  Смотрите, у нас число представлено в двоичной форме, в двоичной записи. Все, что делает двоичный счетчик, он берет и прибавляет единичку числу i.
[01:03:03.540 --> 01:03:09.540]  И нам нужно взять и пересчитать это в массиве. Давайте порисуем.
[01:03:09.540 --> 01:03:17.540]  Лучше задавайте вопросы, потому что потом вам с этим работать. Я знаю, как с этим работать, мне не сложно.
[01:03:17.540 --> 01:03:23.540]  А вас не хочется подставлять. Смотрите, у нас есть какое число? 1, 0, 1, 1, 1, 0.
[01:03:23.540 --> 01:03:33.540]  Все делает двоичный, вот это число x. И вот это вот, все это a, вот это i. Это и есть все двоичный счетчик.
[01:03:33.540 --> 01:03:43.540]  И у меня все, что есть, это инкримент. То есть это x плюс 1.
[01:03:43.540 --> 01:03:51.540]  Когда я сделаю один инкримент, у меня будет 1, 0, 1, 1, 1, 1, 1. Первый инкримент.
[01:03:51.540 --> 01:03:57.540]  Мне нужно поменять всего один бит. То есть вот здесь всего одно действие.
[01:03:58.540 --> 01:04:09.540]  Когда я сделаю еще один инкримент, я получу 1, 1, 0, 0, 0, 0. И здесь у меня поменяется, уже будет 6 действий.
[01:04:12.540 --> 01:04:17.540]  Понятно? И мне интересно, за сколько работает инкримент амортизационный.
[01:04:17.540 --> 01:04:26.540]  То есть вот это как раз пример того, когда у нас действия как-то вот так вот увеличиваются, увеличиваются, потом берут, уменьшаются, потом увеличиваются.
[01:04:26.540 --> 01:04:31.540]  И так далее. Вот это вот разнобой как раз будет. Понятно?
[01:04:31.540 --> 01:04:35.540]  И вот здесь может быть разное увеличение количества этих единичек.
[01:04:35.540 --> 01:04:42.540]  Вот. И я говорю о том, что я точно уверен, что первый бит меняется n раз.
[01:04:42.540 --> 01:04:50.540]  То есть вот я n раз делал инкримент, n раз менялся этот бит. Он менялся то на 0, то на единичку, то единичку, то на 0. Понятно?
[01:04:50.540 --> 01:05:00.540]  Прям прибило вас, я смотрю. Вот если смотреть так в центр, то очень грустно выглядит эта картина.
[01:05:00.540 --> 01:05:06.540]  По бокам ничего, не знаю. Настроение, какой-то радиус поражения.
[01:05:06.540 --> 01:05:15.540]  Ну ладно. Так вот. Первый бит меняется n раз, второй бит меняется n пополам раз,
[01:05:15.540 --> 01:05:23.540]  третий бит n на 3 раза. Ой, n на 4, прошу прощения. Этот n на 8 и так далее. Почему?
[01:05:23.540 --> 01:05:28.540]  Потому что если у меня был здесь 0 и я сделал инкримент, вот этот бит не меняется.
[01:05:28.540 --> 01:05:35.540]  А вот если была единичка и я сделал плюс один, то этот бит поменяется. То есть вот это n пополам.
[01:05:35.540 --> 01:05:42.540]  Аналогично дальше n на 4 и так далее. Понятно? Вот. И с этим мы всегда работаем. Да!
[01:05:45.540 --> 01:05:57.540]  Да, извиняюсь, там это проблема. Да, два в степени этого логорики. Да, вот.
[01:05:57.540 --> 01:06:03.540]  Но в общем суть такая, что мы с вами берем это и сделаем. И когда мы суммируем все это,
[01:06:03.540 --> 01:06:11.540]  мы с вами получаем геометрию. Какую? Правильную геометрическую прогрессию.
[01:06:11.540 --> 01:06:17.540]  Это верно. Вот у нас один плюс одна вторая, плюс одна четвертая и так далее.
[01:06:17.540 --> 01:06:25.540]  Возможно вы видели мем, что заходит математик в бар и вот это вот все. Вот примерно то же самое.
[01:06:25.540 --> 01:06:34.540]  Ну короче, здесь получим, что у нас будет два n действий. После n инкриментов у нас будет два n действий.
[01:06:34.540 --> 01:06:39.540]  Оно ограничено сверху двумя n, когда мы делаем бесконечную эту прогрессию.
[01:06:39.540 --> 01:06:50.540]  Поэтому мы говорим, что у нас в принципе в среднем амортизационно работа инкримента это два действия.
[01:06:50.540 --> 01:06:56.540]  То есть у от единички. То есть инкримент здесь работает за у от единицы.
[01:06:56.540 --> 01:06:59.540]  Могли бы вы когда-нибудь об этом подумать вообще?
[01:07:04.540 --> 01:07:09.540]  Я спрошу обязательно на экзамен. Именно про это.
[01:07:09.540 --> 01:07:16.540]  В действительности да. То есть смотрите, вот с точки зрения подсчета здесь подсчет не тривиальный.
[01:07:16.540 --> 01:07:20.540]  Нужно было понять как это делать. Согласны?
[01:07:20.540 --> 01:07:24.540]  Давайте посмотрим на банковский мет. Что там происходит?
[01:07:24.540 --> 01:07:29.540]  Не скажу, что вам он больше понравится. Здесь тоже много-много слов.
[01:07:29.540 --> 01:07:33.540]  Я буду вам все это пояснять еще раз.
[01:07:33.540 --> 01:07:38.540]  Это вот типа это часть для того, чтобы был такой маленький конспектик у вас по итогу.
[01:07:38.540 --> 01:07:41.540]  Это такая дополнительная часть для вас.
[01:07:41.540 --> 01:07:44.540]  Здесь подразумевается следующее.
[01:07:48.540 --> 01:07:51.540]  Ой, у меня тут это поехало, но не суть важна.
[01:07:51.540 --> 01:07:54.540]  Смотрите, стоимость каждой операции, стоимость каждой записи.
[01:07:54.540 --> 01:07:57.540]  Это один какой-то рубль, одна монетка.
[01:07:58.540 --> 01:08:06.540]  Я, как владелец мешочка с деньгами, буду теперь выдавать не элементы, а операции.
[01:08:06.540 --> 01:08:08.540]  Денюшки.
[01:08:08.540 --> 01:08:12.540]  Инкременту дам два рубля за записи денег.
[01:08:12.540 --> 01:08:16.540]  А удалению ноль.
[01:08:16.540 --> 01:08:25.540]  Я люблю больше увеличения на единицу, с нуля на единицу перезаписывать, чем просто нулевой делать и чайку.
[01:08:25.540 --> 01:08:30.540]  Прям вообще все поехало. Прошу прощения, я пофикшиваю.
[01:08:30.540 --> 01:08:36.540]  Что мы будем делать? Смотрите, при каждой установке бита в единичку,
[01:08:36.540 --> 01:08:41.540]  то есть каждый раз, когда я делаю бит, который был нулевым единицей,
[01:08:41.540 --> 01:08:46.540]  я трачу один рубль на то, чтобы поменять этот бит.
[01:08:46.540 --> 01:08:57.540]  И плюсом к этому всему, я прикрепляю к рассматриваемому биту еще один рубль.
[01:08:57.540 --> 01:09:00.540]  Типа рубль в уме.
[01:09:00.540 --> 01:09:02.540]  То есть мой инкремент тратит два рубля.
[01:09:02.540 --> 01:09:06.540]  Один на то, чтобы вставить, второй отдает вот этому биту.
[01:09:06.540 --> 01:09:10.540]  И каждый раз над каждой единичкой у меня будет рублик.
[01:09:10.540 --> 01:09:12.540]  Согласны?
[01:09:13.540 --> 01:09:18.540]  А теперь, когда я еще раз увеличиваю, у меня становится ноль,
[01:09:18.540 --> 01:09:23.540]  я же должен тоже откуда-то взять деньги на то, чтобы поменять вот этот ноль.
[01:09:23.540 --> 01:09:24.540]  Согласны?
[01:09:24.540 --> 01:09:29.540]  Тогда в этом случае я беру и делаю следующее.
[01:09:29.540 --> 01:09:32.540]  Я беру вот этот рубль, который я оставил, это единички.
[01:09:32.540 --> 01:09:36.540]  Я единички люблю больше, чем нольки, получается.
[01:09:36.540 --> 01:09:41.540]  А я трачу его на то, чтобы здесь поменялся элемент.
[01:09:41.540 --> 01:09:43.540]  И стало нулем.
[01:09:43.540 --> 01:09:45.540]  Ага.
[01:09:45.540 --> 01:09:47.540]  Понятно?
[01:09:47.540 --> 01:09:49.540]  Вот.
[01:09:49.540 --> 01:09:55.540]  Ну смотрите, вот благодаря этой экономности, с точки зрения денег,
[01:09:55.540 --> 01:10:02.540]  у меня получится, что я могу потратить всего 2n рублей.
[01:10:02.540 --> 01:10:07.540]  Смотрите, здесь вообще интересное представление того, как мы вдаем монетки.
[01:10:07.540 --> 01:10:11.540]  Это не просто так происходит, это происходит только лишь благодаря тому,
[01:10:11.540 --> 01:10:15.540]  что мы через элемент распределяем эти монетки и с ними работаем.
[01:10:15.540 --> 01:10:17.540]  Понятно?
[01:10:17.540 --> 01:10:20.540]  То есть вот мой мешочек, че хочу, то с ним и делаю.
[01:10:20.540 --> 01:10:21.540]  И вот от него отталкиваюсь.
[01:10:21.540 --> 01:10:24.540]  А здесь это именно и происходит.
[01:10:24.540 --> 01:10:30.540]  То есть очистка любого бита будет ноль, увеличение на единичку – 1.
[01:10:30.540 --> 01:10:32.540]  Вот.
[01:10:32.540 --> 01:10:37.540]  А поскольку каждая такая операция требует установки не более всего лишь одного бита,
[01:10:37.540 --> 01:10:40.540]  то есть одному инкременту мне достаточно дать 2 рубля.
[01:10:40.540 --> 01:10:42.540]  И все.
[01:10:42.540 --> 01:10:44.540]  У меня всего будет 2n рублей.
[01:10:44.540 --> 01:10:47.540]  Все, конец, у меня одна операция стоит 2.
[01:10:51.540 --> 01:10:54.540]  Смотрите, с самого начала у нас было ноль.
[01:10:54.540 --> 01:10:57.540]  Поэтому там и не было монеток.
[01:10:57.540 --> 01:11:01.540]  А как только появляется единица, там же был инкремент, который 2 давал.
[01:11:01.540 --> 01:11:03.540]  Вот оно тут и появилось.
[01:11:03.540 --> 01:11:04.540]  Понятно?
[01:11:04.540 --> 01:11:08.540]  То есть любой инкремент тратил вот эти две монетки.
[01:11:08.540 --> 01:11:11.540]  У нас всего инкрементов n, получается 2n.
[01:11:11.540 --> 01:11:16.540]  Заметьте, какой нетривиальный подход к банковскому методу.
[01:11:16.540 --> 01:11:20.540]  То есть со стейком на двух очередях все было как будто бы одинаково.
[01:11:20.540 --> 01:11:24.540]  Как будто это бесполезно, что метод усреднения, что метод банковский.
[01:11:24.540 --> 01:11:25.540]  Они одинаковы.
[01:11:25.540 --> 01:11:27.540]  Есть другой подход.
[01:11:27.540 --> 01:11:30.540]  Если у вас развита логика с точки зрения распределения монеток,
[01:11:30.540 --> 01:11:32.540]  можете делать так.
[01:11:32.540 --> 01:11:34.540]  Всегда. Пожалуйста.
[01:11:34.540 --> 01:11:35.540]  Окей?
[01:11:35.540 --> 01:11:36.540]  Да.
[01:11:39.540 --> 01:11:44.540]  Смотрите, каждому инкременту я даю 2 рубля.
[01:11:44.540 --> 01:11:46.540]  Да?
[01:11:46.540 --> 01:11:48.540]  Что может сделать инкремент?
[01:11:48.540 --> 01:11:53.540]  Он может взять и поставить куда-то единичку.
[01:11:53.540 --> 01:11:55.540]  Единичку он поставит всего один раз.
[01:11:55.540 --> 01:11:59.540]  Ноль на единицу поменяет в любом из мест, где есть.
[01:11:59.540 --> 01:12:03.540]  И он даст этой единичке монетку.
[01:12:03.540 --> 01:12:08.540]  А все остальное он будет, вот у всех единичек, которые будут меняться на ноль,
[01:12:08.540 --> 01:12:11.540]  он будет забирать эти монетки.
[01:12:11.540 --> 01:12:13.540]  Ага.
[01:12:13.540 --> 01:12:14.540]  Вот.
[01:12:14.540 --> 01:12:17.540]  К максимуму он сделает одну такую единичку.
[01:12:17.540 --> 01:12:20.540]  Вот этой единичке тоже там были монетки от предыдущих разов.
[01:12:20.540 --> 01:12:23.540]  Всего инкремента сколько?
[01:12:23.540 --> 01:12:25.540]  n.
[01:12:25.540 --> 01:12:27.540]  Получается 2n.
[01:12:28.540 --> 01:12:30.540]  Понятно?
[01:12:40.540 --> 01:12:42.540]  Сейчас, ноль.
[01:12:44.540 --> 01:12:45.540]  Да.
[01:12:46.540 --> 01:12:51.540]  Зачистку он берет от этих монетки.
[01:12:55.540 --> 01:12:59.540]  Ноль, ноль, ноль, ноль, ноль, один.
[01:13:00.540 --> 01:13:02.540]  Да.
[01:13:04.540 --> 01:13:08.540]  Чтобы вот здесь стал ноль, а тут единичка, и ты сюда монетку кладешь.
[01:13:08.540 --> 01:13:11.540]  Сейчас, единичку с монеткой.
[01:13:11.540 --> 01:13:14.540]  Так нет, инкримент тебе дает две монетки.
[01:13:14.540 --> 01:13:18.540]  Вот у тебя вот здесь плюс две монетки.
[01:13:18.540 --> 01:13:20.540]  Ага.
[01:13:20.540 --> 01:13:22.540]  А первое, что происходит?
[01:13:22.540 --> 01:13:27.540]  Вот эта монетка, которая была здесь, тратится на то, чтобы эта единица стала нулем.
[01:13:27.540 --> 01:13:29.540]  Это первое.
[01:13:29.540 --> 01:13:32.540]  Вторая монетка, вот которая здесь была первая монетка,
[01:13:32.540 --> 01:13:35.540]  она тратится сюда для того, чтобы стала единицей.
[01:13:35.540 --> 01:13:38.540]  Она тратится сюда для того, чтобы стала единицей.
[01:13:38.540 --> 01:13:42.540]  Ну и третья вот эта кусочка для того, чтобы ей выдать монетку.
[01:13:43.540 --> 01:13:45.540]  Еще вопросы?
[01:13:45.540 --> 01:13:47.540]  Попробуйте понять.
[01:13:47.540 --> 01:13:49.540]  Пожалуйста.
[01:13:49.540 --> 01:13:51.540]  Я вас прошу.
[01:13:51.540 --> 01:13:56.540]  А последнее, что есть здесь, это метод потенциалов.
[01:13:56.540 --> 01:14:00.540]  Метод потенциалов достаточно здесь интересный.
[01:14:00.540 --> 01:14:08.540]  Потенциалом здесь будет выступать число единиц, превращенных в нули при этой операции.
[01:14:15.540 --> 01:14:17.540]  Так, давай.
[01:14:23.540 --> 01:14:24.540]  Почему?
[01:14:24.540 --> 01:14:27.540]  Каждый инкримент максимум в одну единицу добавит.
[01:14:27.540 --> 01:14:30.540]  Максимум один ноль превратит в единицу.
[01:14:33.540 --> 01:14:35.540]  У тебя быть другого случая не может.
[01:14:35.540 --> 01:14:37.540]  Да.
[01:14:45.540 --> 01:14:51.540]  Ну то есть благодаря тому, что мы у единичек оставили монетки, мы можем забить на них.
[01:14:51.540 --> 01:14:53.540]  Но только лишь благодаря этому.
[01:14:53.540 --> 01:14:56.540]  Это важный момент, и важно это всегда понимать.
[01:14:58.540 --> 01:15:01.540]  Ну а с потенциалами все интересней, все проще.
[01:15:01.540 --> 01:15:03.540]  А у вас есть вот эта вот g it.
[01:15:03.540 --> 01:15:08.540]  g it это число единиц, превращенных в нули после этой операции.
[01:15:08.540 --> 01:15:11.540]  А потенциал это число единиц в записи.
[01:15:11.540 --> 01:15:15.540]  В начале потенциал ноль, у нас число ноль, потенцал ноль.
[01:15:15.540 --> 01:15:16.540]  Согласны?
[01:15:16.540 --> 01:15:17.540]  Вот.
[01:15:17.540 --> 01:15:22.260]  Мы с вами понимаем, что вот если у нас gt – это число
[01:15:22.260 --> 01:15:25.800]  единиц, превращенных в нули при ит-операции, то
[01:15:25.800 --> 01:15:30.660]  phi s и t, оно меньше либо равно, чем phi от s-1, минус g
[01:15:30.660 --> 01:15:31.660]  плюс 1.
[01:15:31.660 --> 01:15:34.820]  Ну, число единичек поменялось, вот, типа, вот так я могу
[01:15:34.820 --> 01:15:35.820]  ограничить.
[01:15:35.820 --> 01:15:36.820]  Согласны?
[01:15:36.820 --> 01:15:45.500]  Ну, смотрите, давайте еще раз попишу.
[01:15:45.500 --> 01:15:51.300]  Это последнее, с чем я вас сегодня мучаю, относительно
[01:15:51.300 --> 01:15:52.300]  теории.
[01:15:52.300 --> 01:15:55.900]  И в этом семестре последнее, что у вас будет теоретическое,
[01:15:55.900 --> 01:16:00.020]  это будет в самом конце.
[01:16:00.020 --> 01:16:01.020]  Баначева куча.
[01:16:01.020 --> 01:16:08.380]  Вот.
[01:16:08.380 --> 01:16:11.900]  Сейчас мы будем с вами заниматься с плей-деревом, потом динамикой.
[01:16:11.900 --> 01:16:13.660]  У нас будет такая больше практическая.
[01:16:13.660 --> 01:16:20.740]  Так вот, смотрите еще раз, phi s и t – это количество
[01:16:20.740 --> 01:16:21.740]  единичек.
[01:16:21.740 --> 01:16:27.980]  Количество единичек, да, которые, состояние с итом
[01:16:27.980 --> 01:16:28.980]  находится, да.
[01:16:28.980 --> 01:16:31.060]  То есть у меня состояние с итом, сколько там есть
[01:16:31.060 --> 01:16:32.060]  единичек.
[01:16:32.060 --> 01:16:39.360]  А g и t, а нам говорит это следующее, число единиц, превращенных
[01:16:39.360 --> 01:16:41.860]  в нули после ит-операции.
[01:16:41.860 --> 01:16:46.980]  То есть, грубо говоря, я пришел с s и t – первой операции
[01:16:46.980 --> 01:16:51.180]  в s и t, сколько единичек потерялось.
[01:16:51.180 --> 01:16:59.340]  Сколько единиц нить ушло.
[01:16:59.340 --> 01:17:01.700]  Зову это так.
[01:17:01.700 --> 01:17:02.700]  Понятно?
[01:17:02.700 --> 01:17:06.100]  Ну, типа это просто вот превращение, сколько мы
[01:17:06.100 --> 01:17:07.100]  потеряли.
[01:17:07.100 --> 01:17:11.860]  Логично, что разница этих потенциалов, ну вот сколько
[01:17:11.860 --> 01:17:15.380]  было там количество единиц, сколько было до этого, сколько
[01:17:15.380 --> 01:17:16.380]  стало.
[01:17:16.380 --> 01:17:17.380]  Оно, по сути, g и t.
[01:17:17.380 --> 01:17:20.620]  Плюс один, я могу сверху ограничить это все.
[01:17:20.620 --> 01:17:21.620]  Понятно?
[01:17:21.620 --> 01:17:26.340]  Ну то есть я могу сказать, что phi от s и t минус phi от
[01:17:26.340 --> 01:17:33.060]  s и минус первое меньше либо равно, чем g и плюс один.
[01:17:33.060 --> 01:17:35.100]  Специально ограничиваю так, чтобы оно было меньше
[01:17:35.100 --> 01:17:36.100]  либо равно.
[01:17:36.100 --> 01:17:43.620]  Мне нужно это будет дальше, вот дальше, вот там.
[01:17:43.620 --> 01:17:44.620]  Равно написать.
[01:17:44.620 --> 01:17:48.020]  Ты уверен, что ты сможешь равно написать?
[01:17:48.020 --> 01:17:49.020]  Не, не это.
[01:17:49.020 --> 01:17:50.020]  Не правда.
[01:17:50.020 --> 01:17:51.020]  Ну а третье.
[01:17:51.020 --> 01:17:52.020]  Давайте еще раз.
[01:17:52.020 --> 01:17:53.020]  Ноль, один, один, один.
[01:17:53.020 --> 01:17:54.020]  Плюс один.
[01:17:54.020 --> 01:17:55.020]  Один, ноль.
[01:17:55.020 --> 01:17:56.020]  Ноль, ноль.
[01:17:56.020 --> 01:17:57.020]  У меня g и t – три.
[01:17:57.020 --> 01:17:58.020]  Правда?
[01:17:58.940 --> 01:18:03.940]  Весь у меня коллекция единичка – три, здесь один.
[01:18:03.940 --> 01:18:12.940]  А, ой, я это… А, нет, все, все.
[01:18:12.940 --> 01:18:17.940]  В смысле единичку, g и t плюс один.
[01:18:17.940 --> 01:18:18.940]  Или где единичка?
[01:18:18.940 --> 01:18:19.940]  Вот эту.
[01:18:19.940 --> 01:18:24.940]  Эта единичка, она могла быть отсюда, ну вот единичка
[01:18:25.860 --> 01:18:28.860]  это возникает вот от того, что здесь был ноль, стало
[01:18:28.860 --> 01:18:30.860]  единица, а могло быть не быть такого.
[01:18:30.860 --> 01:18:33.860]  Плюс один, плюс-минус один, грубо говоря.
[01:18:33.860 --> 01:18:35.860]  Либо ее не было, либо она есть.
[01:18:44.860 --> 01:18:47.860]  Это сколько единицу шло, мы не считаем, сколько
[01:18:47.860 --> 01:18:48.860]  единиц пришло.
[01:18:55.860 --> 01:19:02.860]  С нулевой они содержат единицу, у вас x равно нулю.
[01:19:02.860 --> 01:19:05.860]  У вас x равен нулю.
[01:19:05.860 --> 01:19:08.860]  Это первое, что я сказал, что мы это предполагаем.
[01:19:08.860 --> 01:19:11.860]  Последнее, давайте я сейчас кратко расскажу, что здесь
[01:19:11.860 --> 01:19:13.860]  есть, и вы можете быть свободны.
[01:19:13.860 --> 01:19:16.860]  Прошу прощения за такую немножко тигомотную, может
[01:19:16.860 --> 01:19:20.860]  быть, лекцию, больше связанную с такими выкладками математическими.
[01:19:20.860 --> 01:19:23.860]  Но поверьте, следующая лекция – это выстрель.
[01:19:24.780 --> 01:19:29.780]  Так вот, когда мы с вами это все сделаем, дальше мы
[01:19:29.780 --> 01:19:32.780]  можем оценить ТИТ, и мы можем сказать, что реальное
[01:19:32.780 --> 01:19:37.780]  время работы, оно меньше либо равно, чем ЖИТ плюс
[01:19:37.780 --> 01:19:38.780]  один.
[01:19:38.780 --> 01:19:40.780]  Потому что мы меняем вот эти единички и максимум
[01:19:40.780 --> 01:19:42.780]  еще добавляем еще одну единичку.
[01:19:42.780 --> 01:19:43.780]  Согласны?
[01:19:43.780 --> 01:19:44.780]  Вот.
[01:19:44.780 --> 01:19:49.780]  И вот это подставляя сюда, учитывая с разностью потенциалов
[01:19:50.700 --> 01:19:54.700]  и так далее, мы с вами получим, что у нас ТИТ равно двум.
[01:19:54.700 --> 01:19:57.700]  ТИТ со звездочками аморцизационно.
[01:19:57.700 --> 01:19:58.700]  Понятно?
[01:20:00.700 --> 01:20:02.700]  Меньше либо равен, чем два.
[01:20:06.700 --> 01:20:07.700]  Не больше, чем два, да.
[01:20:07.700 --> 01:20:08.700]  Не больше, чем два.
[01:20:08.700 --> 01:20:10.700]  И это нам хватает.
[01:20:10.700 --> 01:20:13.700]  Нам два хватает, значит это всегда заод единички.
[01:20:13.700 --> 01:20:14.700]  Понятно?
[01:20:14.700 --> 01:20:17.700]  Все, на этом, в принципе, сегодня все.
[01:20:17.700 --> 01:20:19.700]  Хорошего вам вечера.
[01:20:19.780 --> 01:20:21.700]  Спасибо.
