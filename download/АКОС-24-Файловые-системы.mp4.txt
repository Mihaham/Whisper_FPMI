[00:00.000 --> 00:15.000]  Тема сегодняшнего занятия это файловые системы, которые могут быть реализованы как модуль ядра, так и в польском пространстве.
[00:15.000 --> 00:27.000]  Давайте вспомним, что такое ядро. Ядро это такая программка, самая обычная программка, которая загружается бутлодером.
[00:27.000 --> 00:36.000]  Бутлодер передает ей управление. При этом процессор находится в привилегированном режиме.
[00:36.000 --> 00:42.000]  Можно вытворять все что угодно. Это вы все знаете с прошлого семестра.
[00:42.000 --> 00:50.000]  Ядра можно классифицировать по тому, насколько они могут дробиться на разные части.
[00:50.000 --> 01:04.000]  Классические монолитные ядра это такие ядра, которые занимают непрерывное пространство в памяти и реализуют практически всю свою функциональность.
[01:04.000 --> 01:11.000]  Работает естественно все в адресном пространстве ядра с повышенными привилегиями процесса.
[01:11.000 --> 01:19.000]  Бывает противоположная ситуация. Это микроядра, когда ядро это какая-то очень маленькая программа.
[01:19.000 --> 01:24.000]  Единственная задача которой это координация между собой различных подсистем.
[01:24.000 --> 01:30.000]  Разные подсистемы в свою очередь работают в польском пространстве. Это надежнее.
[01:30.000 --> 01:36.000]  Если у вас что-то сломается, то можно будет перезапустить. Все ядро при этом у вас не сломается.
[01:37.000 --> 01:43.000]  Более современный подход это все-таки использовать что-то гибридное.
[01:43.000 --> 01:47.000]  В чем недостаток микроядерной архитектуры?
[01:47.000 --> 01:52.000]  У вас очень большой оверхед на взаимодействии между собой отдельных подсистем ядра.
[01:52.000 --> 01:56.000]  Это естественно приводит к снижению производительности.
[01:56.000 --> 02:04.000]  Поэтому в большинстве современных систем Linux, MacOS, VDA все ядра это так называемые гибридные ядра.
[02:04.000 --> 02:10.000]  Есть основная часть программы, которая запускается всегда работать в адресном пространстве процесса.
[02:10.000 --> 02:18.000]  Она расширяется с помощью загружаемых модулей, которые в том числе могут быть выгружены, если они не используются.
[02:18.000 --> 02:24.000]  Такие модули называются модуль ядра. В Windows еще называются драйверы.
[02:26.000 --> 02:31.000]  О том, где находится ядро, что он из себя представляет.
[02:31.000 --> 02:36.000]  В любой Linux-системе есть в корне каталог BOOT.
[02:36.000 --> 02:40.000]  Что в этом каталоге интересного, полезного содержится?
[02:40.000 --> 02:46.000]  Давайте посмотрим, что тут интересного у нас есть.
[02:46.000 --> 02:50.000]  Синий цвет ужасный.
[02:50.000 --> 02:55.000]  Ладно, тогда просто ls.
[02:55.000 --> 03:01.000]  Что у нас есть? Во-первых, у вас в системе может быть несколько ядер.
[03:01.000 --> 03:05.000]  Совершенно не обязательно все ядра у вас используются.
[03:05.000 --> 03:13.000]  Обычно загружается какое-то одно ядро с помощью команды uname-a либо uname-r.
[03:13.000 --> 03:19.000]  Можно узнать точную версию, какое ядро сейчас в данный момент запущено.
[03:19.000 --> 03:24.000]  С каждым ядром у нас связаны некоторые файлы.
[03:24.000 --> 03:30.000]  Во-первых, файл под названием vmlinux-version,
[03:30.000 --> 03:33.000]  который получается с помощью uname-r.
[03:33.000 --> 03:35.000]  Что это такое?
[03:35.000 --> 03:38.000]  Почему linux, а не linux?
[03:38.000 --> 03:42.000]  Казалось бы, система linux называется в названии буква z конце.
[03:42.000 --> 03:47.000]  Буква z конце означает, что файл зажат с помощью zlib-компрессии
[03:47.000 --> 03:51.000]  просто для того, чтобы быстрее загружался буклудр.
[03:51.000 --> 03:57.000]  Загрузчик загружает наш файл и распаковывает его уже в память.
[03:57.000 --> 04:01.000]  Что из себя представляет этот файл vmlinux?
[04:01.000 --> 04:04.000]  Это самый обычный исполняемый файл.
[04:04.000 --> 04:07.000]  Как вы думаете, в каком формате?
[04:07.000 --> 04:14.000]  Elf, exe, что-то бинарное, просто две структуры.
[04:14.000 --> 04:19.000]  Логично предположить, что это Elf-файл, как и принято в Unix-системах.
[04:19.000 --> 04:21.000]  Но на самом деле нет.
[04:21.000 --> 04:29.000]  В большинстве новых Unix-систем это файл, который начинается со строчек m, z.
[04:29.000 --> 04:33.000]  Встречали такое в бинарных файлах?
[04:33.000 --> 04:40.000]  Это признак того, что файл является обычным portable-exe-table файлом
[04:40.000 --> 04:42.000]  от компании Microsoft.
[04:42.000 --> 04:44.000]  Такой формат.
[04:44.000 --> 04:46.000]  Удивительно, да?
[04:46.000 --> 04:48.000]  Почему так сделано?
[04:48.000 --> 04:53.000]  Потому что в современных системах используется загрузчик EFI,
[04:53.000 --> 05:07.000]  Extensible Farmware Interface.
[05:07.000 --> 05:09.000]  В чем особенность загрузчика?
[05:09.000 --> 05:15.000]  В том, что он позволяет некоторые свои части хранить не на диске,
[05:15.000 --> 05:20.000]  а в железе, то есть на замену классическому биосу.
[05:20.000 --> 05:27.000]  При разработке этого стандарта какое-то участие принимала компания Microsoft.
[05:27.000 --> 05:35.000]  Было стандартизировано, что исполняемый модуль, который может запускать загрузчик EFI,
[05:35.000 --> 05:42.000]  это исполняемые файлы, которые понимаются системой Windows.
[05:42.000 --> 05:47.000]  На самом деле, для загрузчика, например, Grab это не имеет никакого значения,
[05:47.000 --> 05:53.000]  потому что при загрузке загружается некоторый файл бинарный,
[05:53.000 --> 05:55.000]  размещается где-то в памяти,
[05:55.000 --> 06:01.000]  затем ищется некоторая магическая последовательность в стиле файла.
[06:01.000 --> 06:06.000]  Это последовательность, сразу после которой находится точка входа.
[06:06.000 --> 06:09.000]  То есть никакие заголовки и ядра нам совершенно не интересны.
[06:09.000 --> 06:13.000]  Поэтому не важно Elf-файл либо PartTable, Executate.
[06:13.000 --> 06:15.000]  Что еще тут интересного есть?
[06:15.000 --> 06:18.000]  Есть файл под названием config.
[06:18.000 --> 06:21.000]  Есть еще файлы без номеров версии.
[06:21.000 --> 06:26.000]  Это просто символические ссылки на текущую используемую версию.
[06:27.000 --> 06:34.000]  Итак, config – это текстовый файл огромный.
[06:34.000 --> 06:40.000]  Фактически то, с какими опциями ядро было скомпилировано.
[06:40.000 --> 06:43.000]  Что еще интересного?
[06:43.000 --> 06:49.000]  Файл initrd – это бинарный файл, поэтому отображать его не буду в терминале.
[06:49.000 --> 06:53.000]  Это начальный образ системы.
[06:53.000 --> 06:57.000]  То есть когда у вас запускается ядро, ему нужна некоторая файловая система,
[06:57.000 --> 06:59.000]  чтобы забудь страйпить.
[06:59.000 --> 07:04.000]  Какие-то самые базовые модули ядра, возможно конфиги.
[07:04.000 --> 07:08.000]  И образ такой файловой системы хранится в файле initrd.img.
[07:08.000 --> 07:15.000]  Он является корнем файловой системы до того, как ядро не найдет все диски
[07:15.000 --> 07:21.000]  и не примет решения о том, какая файловая система у нас потом станет корнем.
[07:21.000 --> 07:27.000]  Еще есть файл system.map – это обычный текстовый файл.
[07:27.000 --> 07:31.000]  В разных дистрибутивах, опять же, может быть, разная реализация.
[07:31.000 --> 07:37.000]  В случае с debian, просто отсылка, что можно поставить дополнительный пакет
[07:37.000 --> 07:42.000]  размером 700 мегабайт, в котором будет требована информация.
[07:42.000 --> 07:49.000]  System map – это по сути отображение таблицы символов ядра.
[07:49.000 --> 07:53.000]  В ядре есть какие-то функции, в том числе публично доступные.
[07:53.000 --> 07:57.000]  У публично доступных функций есть определенные адреса.
[07:57.000 --> 08:01.000]  И информация об этом хранится в текстом файле system.map.
[08:01.000 --> 08:04.000]  Для чего он нужен? Обычно только для дебага
[08:04.000 --> 08:08.000]  либо для детального отображения в лог-файлах.
[08:08.000 --> 08:15.000]  Есть еще подкаталог EFI и Grab. Они относятся к загрузчикам.
[08:16.000 --> 08:22.000]  Помимо самого ядра есть еще отдельные модули.
[08:22.000 --> 08:25.000]  От модулей это уже ELF-файлы.
[08:25.000 --> 08:31.000]  Обычные библиотечки, ну, точнее, почти обычные библиотечки, немножко отличаются.
[08:31.000 --> 08:35.000]  Которые обычно находятся в каталогах slashlib-modules.
[08:35.000 --> 08:40.000]  Там есть куча подкаталогов, то есть все модули ядра, они имеют какую-то иерархию, структуру,
[08:40.000 --> 08:43.000]  разложенные по разным подсистемам.
[08:43.000 --> 08:49.000]  И вот эти модули ядра загружаются уже после того, как система загружена.
[08:49.000 --> 08:53.000]  И что это за модули, когда они загружаются?
[08:53.000 --> 08:59.000]  Они могут быть загружены либо вручную, либо самим ядром
[08:59.000 --> 09:04.000]  после выполнения операции опроса оборудования.
[09:04.000 --> 09:11.000]  То есть у нас есть какой-то дистрибутив, есть какая-то система,
[09:11.000 --> 09:15.000]  которая может быть установлена на самом разном железе.
[09:15.000 --> 09:20.000]  Неважно какая у вас видеокарта, неважно какой у вас чипсет.
[09:20.000 --> 09:26.000]  Если он позволяет запустить Linux, то при необходимости у вас могут для разных компонентов
[09:26.000 --> 09:30.000]  загружаться отдельные модули.
[09:30.000 --> 09:33.000]  И это обычно происходит при загрузке системы.
[09:33.000 --> 09:39.000]  Но в том числе у вас какие-то модули системы могут быть загружены вручную.
[09:39.000 --> 09:43.000]  Например, модули, которые никак не связаны с железом.
[09:43.000 --> 09:48.000]  В частности, у вас могут быть какие-то дополнительные файловые системы
[09:48.000 --> 09:52.000]  или какие-то дополнительные модули безопасности.
[09:52.000 --> 09:56.000]  При этом модулей могут быть какие-то зависимости.
[09:56.000 --> 09:59.000]  Давайте, например, посмотрим.
[09:59.000 --> 10:02.000]  Смотреть можно все командой по названию lsmod.
[10:02.000 --> 10:05.000]  Права рута для этого не требуется.
[10:05.000 --> 10:08.000]  Что интересно, он отображает.
[10:08.000 --> 10:12.000]  Во-первых, список всех загруженных модулей.
[10:12.000 --> 10:16.000]  У каждого модуля может быть какой-то размер.
[10:16.000 --> 10:22.000]  Usage – это количество использования модулей какими-то другими.
[10:22.000 --> 10:26.000]  И дальше причисляются, какие модули используют что-то одно.
[10:26.000 --> 10:31.000]  Например, есть модуль с большим количеством зависимости под названием snd.
[10:31.000 --> 10:35.000]  Это базовая поддержка звука вообще в принципе.
[10:35.000 --> 10:40.000]  От него зависят модули snd, hd, codec, cd, hd, intel.
[10:40.000 --> 10:47.000]  Это подсистема, которая относится к стандарту intel и hd high definition audio.
[10:47.000 --> 10:56.000]  Практически большинство современных звуковых карт работают через codec intel high definition.
[10:56.000 --> 11:00.000]  Есть какие-то файловые системы, например, x4,
[11:00.000 --> 11:04.000]  которые в свою очередь зависят от каких-то других модулей,
[11:04.000 --> 11:08.000]  например, вычисления контроля не суммы CRC16.
[11:08.000 --> 11:14.000]  Можно с помощью команды insmod – не очень хорошо – modprobe
[11:14.000 --> 11:18.000]  загрузить еще какой-нибудь модуль,
[11:18.000 --> 11:23.000]  например, поддержку файлосистемы btrfs.
[11:23.000 --> 11:29.000]  modprobe не найден, на самом деле не найден, потому что он находится в каталоге sbin
[11:29.000 --> 11:32.000]  и требует права рута.
[11:42.000 --> 11:45.000]  Что произошло, я не нажал моду «минус»,
[11:45.000 --> 11:49.000]  поэтому переменная паса у меня не поменялась.
[11:50.000 --> 11:53.000]  Теперь появилась btrfs.
[11:53.000 --> 11:58.000]  Так, загружена файлосистема btrfs теперь.
[11:58.000 --> 12:04.000]  Можно вгребнуть, где он находится.
[12:04.000 --> 12:07.000]  Вот, модуль действительно загружен.
[12:07.000 --> 12:15.000]  Если он нам не нужен, то мы можем сделать операцию rmmod,
[12:15.000 --> 12:21.000]  которая выгружает определенный модуль,
[12:21.000 --> 12:26.000]  но, кстати, совершенно не обязательно rmmod может какой-то модуль выгрузить.
[12:26.000 --> 12:29.000]  Например, что хорошего или плохого произойдет,
[12:29.000 --> 12:32.000]  если я попробую выгрузить модуль x4,
[12:32.000 --> 12:38.000]  который является файлосистемой в данном случае моей машины для корневой файлосистемы.
[12:38.000 --> 12:41.000]  Получаем ошибку.
[12:41.000 --> 12:46.000]  Модуль x4 у нас используется, ничего хорошего здесь не произойдет.
[12:46.000 --> 12:55.000]  Точнее, есть опция «минус f», которая заставляет
[12:55.000 --> 12:58.000]  все-таки принудительно выгрузить какой-то модуль.
[12:58.000 --> 13:02.000]  Если я наберу rmmod –f x4,
[13:02.000 --> 13:04.000]  но мне придется перезагружать систему,
[13:04.000 --> 13:08.000]  она станет, скажем так, не очень корректно работающей.
[13:08.000 --> 13:12.000]  И даже в Help написано, что это опасно.
[13:15.000 --> 13:17.000]  Можно сделать свои модули.
[13:17.000 --> 13:18.000]  Что такое свой модуль?
[13:18.000 --> 13:21.000]  Это просто обычный KO-файл,
[13:21.000 --> 13:25.000]  который получается в компиляции из каких-то исходников.
[13:25.000 --> 13:29.000]  Исходники можно писать обычно на языке C,
[13:29.000 --> 13:33.000]  хотя сейчас можно уже и на Rust писать,
[13:33.000 --> 13:36.000]  хотя это страшный язык.
[13:36.000 --> 13:38.000]  Что такое модуль-ядра?
[13:38.000 --> 13:42.000]  Это модуль, который реализует минимум две функции.
[13:42.000 --> 13:45.000]  Одна из них называется init-модуль,
[13:45.000 --> 13:48.000]  выполняется при его загрузке.
[13:48.000 --> 13:52.000]  И clean-модуль, но, естественно, это при выгрузке модул.
[13:52.000 --> 13:57.000]  Давайте сделаем простой модуль-ядра и его загрузим.
[13:57.000 --> 14:05.000]  Итак, самый простой модуль-ядра выглядит в следующем образом.
[14:05.000 --> 14:07.000]  У нас есть две функции.
[14:07.000 --> 14:09.000]  Одна init, другая clean-up,
[14:09.000 --> 14:13.000]  которые могут что-то делать, например, что-то выводить.
[14:13.000 --> 14:17.000]  Обратите внимание, никакого принфа, никакого путса,
[14:17.000 --> 14:19.000]  никакой работы с файлами.
[14:19.000 --> 14:24.000]  Для модули-ядра про стандартную IC-библиотеку можно забыть в принципе.
[14:24.000 --> 14:25.000]  Ее нет.
[14:25.000 --> 14:28.000]  И вообще говоря, ядро не обязано зависеть ни от каких библиотек.
[14:28.000 --> 14:31.000]  Поэтому используется только внутренний API,
[14:31.000 --> 14:34.000]  внутренние функции ядра.
[14:35.000 --> 14:39.000]  Для компиляции этого безобразия я сделал отдельный подкаталог,
[14:39.000 --> 14:47.000]  в котором все те же самые файлы являются просто символическими ссылками на уровень выше,
[14:47.000 --> 14:51.000]  потому что при сборке сейчас будет генерироваться огромное количество бусера.
[14:51.000 --> 14:52.000]  А как это все собрать?
[14:52.000 --> 14:54.000]  Собирается нетривиальным образом.
[14:54.000 --> 15:00.000]  А именно, для сборки модуля-ядра нам требуются исходники-ядра
[15:00.000 --> 15:03.000]  либо даже не обязательно исходники.
[15:03.000 --> 15:06.000]  Так называемый пакет для разработки ядра,
[15:06.000 --> 15:09.000]  заголовочные файлы плюс необходимый makefile.
[15:09.000 --> 15:13.000]  Если вы когда-нибудь вставили какие-нибудь праприетарные драйвера,
[15:13.000 --> 15:15.000]  например видеокарту Nvidia,
[15:15.000 --> 15:21.000]  либо если у вас система устанавливается в виртуалку, в виртуалбокс, либо параллелс,
[15:21.000 --> 15:26.000]  то скорее всего для установки вам требовались как раз заголовочные файлы ядра,
[15:26.000 --> 15:29.000]  которые находятся тоже в либ модуле,
[15:29.000 --> 15:33.000]  но содержат дополнительно makefile и заголовочные файлы.
[15:33.000 --> 15:40.000]  Поэтому команда make, которая выполняет инструкции из makefile
[15:40.000 --> 15:43.000]  где-то в потрохах ядра,
[15:43.000 --> 15:47.000]  может собрать дополнительные модули.
[15:47.000 --> 15:51.000]  Обратите внимание на огромное количество мусора,
[15:51.000 --> 15:53.000]  которое у нас теперь появилось.
[15:53.000 --> 15:56.000]  И вот файл, который называется hello.co,
[15:56.000 --> 16:00.000]  как раз является вновь созданным модулем.
[16:00.000 --> 16:06.000]  Напомню, что этот модуль должен нам просто говорить о том,
[16:06.000 --> 16:08.000]  что он загружен либо выгружен.
[16:08.000 --> 16:17.000]  Так, ладно, команда modprop нам ничего не найдет,
[16:17.000 --> 16:21.000]  потому что наш модуль не лежит где-то в стандартном месте,
[16:22.000 --> 16:29.000]  но мы можем и воспользоваться командой insmod,
[16:29.000 --> 16:34.000]  которая в отличие от modprop принимает имя файла, а не имя модуля.
[16:34.000 --> 16:38.000]  И если modprop загружает модули со всеми их зависимостими,
[16:38.000 --> 16:41.000]  то insmod выполняет только загрузку файла,
[16:41.000 --> 16:47.000]  либо ругается, если ваш модуль зависит еще от какого-то файла.
[16:51.000 --> 16:56.000]  Вот, insmod hello.co.
[16:56.000 --> 17:00.000]  А, я его уже загружал.
[17:09.000 --> 17:13.000]  Все, модуль загружен, он что-то при этом даже сделал.
[17:13.000 --> 17:16.000]  А как понять, что он что-то сделал?
[17:16.000 --> 17:19.000]  Куда у нас что-то вывелось?
[17:19.000 --> 17:22.000]  Вывелось в лог ядра.
[17:22.000 --> 17:25.000]  Замечательная команда поможет вам,
[17:25.000 --> 17:28.000]  если вы не понимаете, что с вашей системой происходит,
[17:28.000 --> 17:31.000]  называется debugging messages.
[17:35.000 --> 17:37.000]  Дебаггин messages тут говорит,
[17:37.000 --> 17:42.000]  что у меня огромное количество сетевого взаимодействия по сетевой плате.
[17:42.000 --> 17:45.000]  Firewall тут что-то вытворяет.
[17:45.000 --> 17:48.000]  Ну и самое главное в самом конце.
[17:48.000 --> 17:51.000]  Это предыдущие то, что я набрал remod,
[17:51.000 --> 17:54.000]  и insmod привел к тому, что вывела строчка,
[17:54.000 --> 17:57.000]  привет, нового модуля.
[17:57.000 --> 18:00.000]  Так, что еще принципиального есть в модулях?
[18:00.000 --> 18:04.000]  Обязательно внимание, что в тексте модуля есть какой-то macros модуль-лиценз.
[18:04.000 --> 18:07.000]  Там еще написано что-то про JTL.
[18:07.000 --> 18:10.000]  Давайте мы этот заголовок уберем.
[18:10.000 --> 18:12.000]  Что делает macros?
[18:12.000 --> 18:15.000]  Он просто создает новую секцию,
[18:15.000 --> 18:18.000]  переменную с текстом JPL.
[18:18.000 --> 18:21.000]  Давайте сделаем не JPL,
[18:21.000 --> 18:24.000]  а migrate to use only in Russia.
[18:34.000 --> 18:37.000]  Так, все. Никакие буржуи теперь не имеют права
[18:37.000 --> 18:40.000]  использовать мой великий модуль.
[18:40.000 --> 18:43.000]  Перекомпилируем.
[18:45.000 --> 18:48.000]  Ремод.
[18:48.000 --> 18:51.000]  Загружаем заново.
[18:51.000 --> 18:54.000]  Все хорошо, все замечательно.
[18:54.000 --> 18:57.000]  Модуль честно загрузился.
[18:57.000 --> 19:00.000]  Если он реализует функциональность,
[19:00.000 --> 19:03.000]  то эта функциональность становится доступной.
[19:03.000 --> 19:06.000]  Но при этом система считается компрометированной
[19:06.000 --> 19:09.000]  и ненадежной.
[19:09.000 --> 19:12.000]  Как об этом узнать?
[19:12.000 --> 19:15.000]  Как об этом узнать?
[19:15.000 --> 19:18.000]  Есть Proc sys kernel taint,
[19:24.000 --> 19:27.000]  который содержит какое-то число.
[19:27.000 --> 19:30.000]  Число представляет собой битовую маску,
[19:30.000 --> 19:33.000]  хоть отображается в дистичном виде,
[19:33.000 --> 19:36.000]  где каждый бит отвечает за причину того,
[19:36.000 --> 19:39.000]  почему наше ядро стало ненадежным,
[19:39.000 --> 19:42.000]  потенциально компрометированным.
[19:42.000 --> 19:45.000]  Проверяя значение этого файла,
[19:45.000 --> 19:48.000]  этот файл доступен на чтении,
[19:48.000 --> 19:51.000]  в том числе и обычному пользователю,
[19:51.000 --> 19:54.000]  не обязательно руту.
[19:54.000 --> 19:57.000]  Можно принять решение о том,
[19:57.000 --> 20:00.000]  можно ли запускать на данной машине,
[20:00.000 --> 20:03.000]  на этом конкретном ядре, что-то,
[20:03.000 --> 20:06.000]  что содержит, например, государственную тайну
[20:06.000 --> 20:09.000]  или какой-нибудь интеллект.
[20:09.000 --> 20:12.000]  В данном случае я бы не стал,
[20:12.000 --> 20:15.000]  потому что значение не ноль.
[20:15.000 --> 20:18.000]  И значит, что потенциально мое ядро
[20:18.000 --> 20:21.000]  может вытворять что-то плохое.
[20:21.000 --> 20:24.000]  Почему мое ядро может выполнить что-то плохое?
[20:24.000 --> 20:27.000]  Одна из причин связана с тем,
[20:27.000 --> 20:30.000]  что я загрузил какой-то странный модуль,
[20:30.000 --> 20:33.000]  лицензия которого не позволяет
[20:33.000 --> 20:36.000]  и причин. Могут быть самые разные причины.
[20:36.000 --> 20:39.000]  В частности, например,
[20:39.000 --> 20:42.000]  если мы модуль загрузили
[20:42.000 --> 20:45.000]  из какого-то непонятного источника,
[20:45.000 --> 20:48.000]  то есть в обычных линейных дистрибутивах
[20:48.000 --> 20:51.000]  есть стандартные каталоги,
[20:51.000 --> 20:54.000]  где у вас лежат все модуль.
[20:54.000 --> 20:57.000]  Если вы загружаете модуль
[20:57.000 --> 21:00.000]  вне дерева этого каталога,
[21:00.000 --> 21:03.000]  то, наверное, ему не стоит доверять.
[21:03.000 --> 21:06.000]  Кроме того, ядро может быть считаться скомпрометированным
[21:06.000 --> 21:09.000]  не только из-за какого-то модуля,
[21:09.000 --> 21:12.000]  но в том числе, если возникла какая-то ошибочная ситуация,
[21:12.000 --> 21:15.000]  в том числе из модуля ядра,
[21:15.000 --> 21:18.000]  который уходит в штатную поставку.
[21:18.000 --> 21:21.000]  Ядро при этом может не обязательно грохнуться,
[21:21.000 --> 21:24.000]  но если возник какой-то инцидент,
[21:24.000 --> 21:27.000]  то ядро, тем не менее, потенциально считается уже уязвимым.
[21:28.000 --> 21:31.000]  Опять же, операция форсирования выгрузки
[21:31.000 --> 21:34.000]  какого-то модуля,
[21:34.000 --> 21:37.000]  RMod с опцией "-f",
[21:37.000 --> 21:40.000]  даже если не приведет к падению вашей системы,
[21:40.000 --> 21:43.000]  все равно приводит ядро
[21:43.000 --> 21:46.000]  в какое-то не совсем корректное состояние
[21:46.000 --> 21:49.000]  и потенциально уязвимо.
[21:52.000 --> 21:55.000]  В модулях можно еще добавлять какие-то параметры
[21:55.000 --> 21:58.000]  для чего это бывает полезно.
[21:58.000 --> 22:01.000]  Бывает полезно, если вам нужно
[22:01.000 --> 22:04.000]  в зависимости от разного типа железа
[22:04.000 --> 22:07.000]  выполнять какую-то тонкую настройку.
[22:07.000 --> 22:10.000]  Обычно это используется, например,
[22:10.000 --> 22:13.000]  для модулей Wi-Fi,
[22:13.000 --> 22:16.000]  которые могут быть,
[22:16.000 --> 22:19.000]  может быть, один модуль
[22:19.000 --> 22:22.000]  на много разных сетевых плат
[22:22.000 --> 22:25.000]  с разными,
[22:25.000 --> 22:28.000]  с одинаковым семейством чипов
[22:28.000 --> 22:31.000]  одного производителя,
[22:31.000 --> 22:34.000]  но при этом отличаться
[22:34.000 --> 22:37.000]  каким-нибудь тонким настройкам, например, регион,
[22:37.000 --> 22:40.000]  в который эта Wi-Fi-плата используется,
[22:40.000 --> 22:43.000]  либо включить, выключить какие-то
[22:43.000 --> 22:46.000]  дополнительные опции, например, энергосбережение.
[22:46.000 --> 22:49.000]  В некоторых ноутбуках, если у вас Wi-Fi
[22:49.000 --> 22:52.000]  с этим настройками, Wi-Fi начинает работать.
[22:55.000 --> 22:58.000]  Ну и что делает какой-нибудь модуль,
[22:58.000 --> 23:01.000]  когда вы его загрузили?
[23:01.000 --> 23:04.000]  После того, как вы загрузили какой-то модуль,
[23:04.000 --> 23:07.000]  он реализует какие-то функции,
[23:07.000 --> 23:10.000]  и эти функции становятся доступны для использования
[23:10.000 --> 23:13.000]  либо другими модулями, либо напрямую.
[23:13.000 --> 23:16.000]  Но напрямую обычно для модуля это редко используется,
[23:16.000 --> 23:19.000]  а в большинстве модулей это реализовать
[23:19.000 --> 23:22.000]  какой-то программный интерфейс.
[23:22.000 --> 23:25.000]  Посмотреть на список всех
[23:25.000 --> 23:28.000]  доступных символов текущего ядра
[23:28.000 --> 23:31.000]  можно с помощью AllSims.
[23:31.000 --> 23:34.000]  Вот у нас огромное количество символов.
[23:34.000 --> 23:37.000]  Что здесь полезного есть?
[23:37.000 --> 23:40.000]  Ух, я давно не перезагружал систему,
[23:40.000 --> 23:43.000]  когда у нас была лекция по BPF?
[23:44.000 --> 23:47.000]  Да, в общем, с тех пор я компьютер не перезагружал,
[23:47.000 --> 23:50.000]  у меня до сих пор валяются какие-то родименты
[23:50.000 --> 23:53.000]  сгенерированных BPF программ.
[23:53.000 --> 23:56.000]  Что полезного здесь можно увидеть?
[23:56.000 --> 23:59.000]  Можно гребнуть что-то, что начинается
[23:59.000 --> 24:02.000]  с двух подчеркиваний имени и архитектуры.
[24:02.000 --> 24:05.000]  В данном случае это ARM64.
[24:08.000 --> 24:11.000]  Дальше префикс sys подчеркивания.
[24:13.000 --> 24:16.000]  Вот такие названия вам ни о чем не говорят.
[24:16.000 --> 24:19.000]  sys-accept, sys-list,
[24:19.000 --> 24:22.000]  sys-link, sys-encoder, sys-pipe.
[24:22.000 --> 24:25.000]  Это все реализации
[24:25.000 --> 24:28.000]  отдельных системных звуков.
[24:28.000 --> 24:31.000]  Причем в старых ядрах Linux
[24:31.000 --> 24:34.000]  они просто начинались с префикса sys подчеркивания.
[24:34.000 --> 24:37.000]  В более современных они еще имеют
[24:37.000 --> 24:40.000]  такое страшное название с префиксом
[24:40.000 --> 24:43.000]  в настоящем из названия архитектуры.
[24:43.000 --> 24:46.000]  Даже реализация системных вызовов
[24:46.000 --> 24:49.000]  это самые обычные функции.
[24:49.000 --> 24:52.000]  Если вы пишете модуль, который должен делать
[24:52.000 --> 24:55.000]  какие-то системные вызовы, то не обязательно
[24:55.000 --> 24:58.000]  выполнять инструкцию системных вызовов,
[24:58.000 --> 25:01.000]  можно просто дергать определенные инструкции.
[25:01.000 --> 25:04.000]  Здесь есть определенные тонкости, что разные
[25:04.000 --> 25:07.000]  системные вызовы могут подразумевать копирование
[25:07.000 --> 25:10.000]  поэтому из ядра такие функции
[25:10.000 --> 25:13.000]  все-таки опасны.
[25:16.000 --> 25:19.000]  Что вы можете использовать, если вдруг захочете
[25:19.000 --> 25:22.000]  написать свой модуль ядра?
[25:22.000 --> 25:25.000]  Забудьте опять же про стандартную сеть библиотеку.
[25:25.000 --> 25:28.000]  Есть API ядра,
[25:28.000 --> 25:31.000]  который имеет свойство
[25:31.000 --> 25:34.000]  периодически меняться, но плюс-минус
[25:35.000 --> 25:38.000]  Там есть самые стандартные наборы
[25:38.000 --> 25:41.000]  всех возможных функций,
[25:41.000 --> 25:44.000]  базовая операция над строками,
[25:44.000 --> 25:47.000]  всякие конвертации строк.
[25:47.000 --> 25:50.000]  Что касается памяти, то здесь надо понимать, что у ядра
[25:50.000 --> 25:53.000]  нет такого понятия как куча.
[25:53.000 --> 25:56.000]  У ядра есть только стэк,
[25:56.000 --> 25:59.000]  для каждого процесса тоже существует свой отдельный
[25:59.000 --> 26:02.000]  стэк в адресном пространстве ядра.
[26:02.000 --> 26:05.000]  Если вы хотите выделять какую-то память в физическую,
[26:05.000 --> 26:08.000]  то приходится использовать более низко уровень инструменты,
[26:08.000 --> 26:11.000]  которые называются K-malloc, K-free.
[26:11.000 --> 26:14.000]  Но это все-таки не куча в том понимании,
[26:14.000 --> 26:17.000]  как вы привыкли для стандартной сеть библиотеки.
[26:17.000 --> 26:20.000]  Когда вы работаете с памятью,
[26:20.000 --> 26:23.000]  то всегда надо помнить о том,
[26:23.000 --> 26:26.000]  что память у вас в общих случаях делится
[26:26.000 --> 26:29.000]  на два непресекающихся участка.
[26:29.000 --> 26:32.000]  Память у ядра с которой вы работаете напрямую,
[26:32.000 --> 26:35.000]  и память у пользователей,
[26:35.000 --> 26:38.000]  в которой ядро может залезть.
[26:38.000 --> 26:41.000]  Но делать надо это очень аккуратно.
[26:41.000 --> 26:44.000]  Системные вызовы.
[26:44.000 --> 26:47.000]  Это у нас какие-то функции.
[26:47.000 --> 26:50.000]  Этим функциям соответствуют
[26:50.000 --> 26:53.000]  определенные номера, которые вы вызываете
[26:53.000 --> 26:56.000]  через инструкцию C-center,
[26:56.000 --> 26:59.000]  либо инструкцию Syscall,
[26:59.000 --> 27:02.000]  либо если ARM SVC,
[27:02.000 --> 27:05.000]  что еще можно использовать?
[27:05.000 --> 27:08.000]  Под XSense можно использовать инструкцию INT,
[27:08.000 --> 27:11.000]  старую классическую.
[27:11.000 --> 27:14.000]  Что происходит, когда вы выполняете
[27:14.000 --> 27:17.000]  инструкцию процессора для выполнения системного вызова?
[27:17.000 --> 27:20.000]  Просматривается таблица функций,
[27:20.000 --> 27:23.000]  самая обычная таблица функций,
[27:23.000 --> 27:26.000]  где в таблице по номерам
[27:26.000 --> 27:29.000]  определенным индексом соответствуют
[27:29.000 --> 27:32.000]  указатели на нужные функции ядра,
[27:32.000 --> 27:35.000]  и вызываются дальше уже эти функции.
[27:35.000 --> 27:38.000]  Если у нас эта таблица как-то публично доступна,
[27:38.000 --> 27:41.000]  то какой-нибудь модуль может взять
[27:41.000 --> 27:44.000]  и что-нибудь перезаписать.
[27:44.000 --> 27:47.000]  Например, захотите сделать свою реализацию
[27:47.000 --> 27:50.000]  системного вызова, который открывает какой-нибудь файл.
[27:51.000 --> 27:54.000]  Эта нужная реализация вам может
[27:54.000 --> 27:57.000]  проверять, что файл является файлом с паролем,
[27:57.000 --> 28:00.000]  при необходимости может сливать еще куда-нибудь
[28:00.000 --> 28:03.000]  информацию.
[28:03.000 --> 28:06.000]  В общем, достаточно опасная возможность,
[28:06.000 --> 28:09.000]  если вы можете менять что-то в таблице символов.
[28:09.000 --> 28:12.000]  И в современных версиях ядра
[28:12.000 --> 28:15.000]  эту штуку можно отключить.
[28:15.000 --> 28:18.000]  То есть сделать так, чтобы таблица
[28:18.000 --> 28:21.000]  на нужных вызовах была недоступна в том числе
[28:21.000 --> 28:24.000]  из модуля ядра. В данном случае вы просто не сможете
[28:24.000 --> 28:27.000]  скомпилировать те модули ядра, которые
[28:27.000 --> 28:30.000]  полагаются на ее использование.
[28:30.000 --> 28:33.000]  Это обычно массив C-SkullTable.
[28:33.000 --> 28:36.000]  В современных версиях ядра Linux есть функция,
[28:36.000 --> 28:39.000]  которая ищет
[28:39.000 --> 28:42.000]  нужные функции по номерам.
[28:42.000 --> 28:45.000]  Называется keyAllSimsLookUpName.
[28:45.000 --> 28:48.000]  Вот в дебе они есть.
[28:48.000 --> 28:51.000]  На самом деле не в каждой
[28:51.000 --> 28:54.000]  бестрибутиве это может быть.
[28:54.000 --> 28:57.000]  Это опция компиляции ядра.
[28:57.000 --> 29:00.000]  В OpenSUSE такого вы точно не найдете.
[29:00.000 --> 29:03.000]  Там просто не пользуются такими штуками.
[29:03.000 --> 29:06.000]  Это просто повышение безопасности.
[29:06.000 --> 29:09.000]  Зачем вам нужно менять
[29:09.000 --> 29:12.000]  таблицу ядра?
[29:12.000 --> 29:15.000]  Зачем вам нужно
[29:15.000 --> 29:18.000]  подменять какие-то системные вызовы?
[29:18.000 --> 29:21.000]  Наверное, это опасно. Так делать нехорошо.
[29:24.000 --> 29:27.000]  Для чего нужны разные модули ядра?
[29:27.000 --> 29:30.000]  Во-первых, это могут быть
[29:30.000 --> 29:33.000]  драйверами, которые обслуживают
[29:33.000 --> 29:36.000]  конкретные устройства.
[29:36.000 --> 29:39.000]  В поставке ядра Linux есть модули,
[29:39.000 --> 29:42.000]  90% всего железа,
[29:42.000 --> 29:45.000]  в том числе такого железа,
[29:45.000 --> 29:48.000]  который вы уже никогда не найдете.
[29:48.000 --> 29:51.000]  Большая проблема в плане ядра Linux.
[29:51.000 --> 29:54.000]  Если нужно что-то кардионально
[29:54.000 --> 29:57.000]  менять в ядре, в базовой части,
[29:57.000 --> 30:00.000]  то очень часто всякие
[30:00.000 --> 30:03.000]  legacy модули
[30:03.000 --> 30:06.000]  это самое сложное, что приходится портировать.
[30:07.000 --> 30:10.000]  Хотя периодически проводится чистка.
[30:10.000 --> 30:13.000]  Кроме устройств, есть еще
[30:13.000 --> 30:16.000]  другие подсистемы, в частности,
[30:16.000 --> 30:19.000]  различные файловые системы.
[30:19.000 --> 30:22.000]  Файловые системы бывают разных типов,
[30:22.000 --> 30:25.000]  которые разрабатывались с прицелом под разные цели,
[30:25.000 --> 30:28.000]  под разные операционные системы.
[30:28.000 --> 30:31.000]  В Linux родной файловой системой
[30:31.000 --> 30:34.000]  является семейство X2, 3, 4 и так далее.
[30:34.000 --> 30:37.000]  X2, X3, X4 это просто разные версии
[30:37.000 --> 30:40.000]  одной и той же файловой системы.
[30:40.000 --> 30:43.000]  Более современные модули, например,
[30:43.000 --> 30:46.000]  X4, они поддерживают обратную совместимость
[30:46.000 --> 30:49.000]  с более ранними.
[30:49.000 --> 30:52.000]  Поскольку эта файловая система является родной для Linux,
[30:52.000 --> 30:55.000]  то это единственное исключение, что не является модулем.
[30:55.000 --> 30:58.000]  X4 обычно вкомпилирован
[30:58.000 --> 31:01.000]  прямо в само ядро системы.
[31:01.000 --> 31:04.000]  Когда вы загружаете ядро,
[31:04.000 --> 31:07.000]  скармливаете ему начальный образ,
[31:07.000 --> 31:10.000]  начальный образ тоже находится
[31:10.000 --> 31:13.000]  это просто файл X4,
[31:13.000 --> 31:16.000]  но только загруженная загрузчиком.
[31:16.000 --> 31:19.000]  При этом вы можете дополнительно подгружать
[31:19.000 --> 31:22.000]  еще какие-то файловые системы,
[31:22.000 --> 31:25.000]  например, XFS, BTRFS, которые я напрямую
[31:25.000 --> 31:28.000]  с мощью Modprobe подгрузил.
[31:28.000 --> 31:31.000]  Бывают разные файловые системы.
[31:31.000 --> 31:34.000]  Во-первых, нам могут понадобиться разные файловые системы,
[31:34.000 --> 31:37.000]  если вы хотите получить
[31:37.000 --> 31:40.000]  какую-то дополнительную функциональность
[31:40.000 --> 31:43.000]  даже в рамках Linux-системы.
[31:43.000 --> 31:46.000]  Например, BTRFS в некоторых дистрибутивах
[31:46.000 --> 31:49.000]  ее включают по умолчанию, хотя
[31:49.000 --> 31:52.000]  она пока еще не считается достаточно стабильной,
[31:52.000 --> 31:55.000]  позволяет, например, делать версионирование.
[31:55.000 --> 31:58.000]  Система, которая изначально была разработана
[31:58.000 --> 32:01.000]  компанией Silicon Graphics еще в бородатые годы прошлого века,
[32:01.000 --> 32:04.000]  очень хорошо работала эффективно
[32:04.000 --> 32:07.000]  с файловыми большого размера.
[32:07.000 --> 32:10.000]  Затем последствия файловой системы были опубликованы
[32:10.000 --> 32:13.000]  под лицензию DGPL, поэтому включена в состав Linux.
[32:13.000 --> 32:16.000]  Тоже часто можно встретить ее и использовать.
[32:16.000 --> 32:19.000]  Ну и кроме родных для Unix-систем,
[32:19.000 --> 32:22.000]  которые поддерживают
[32:22.000 --> 32:25.000]  все необходимые атрибуты, то есть iNode,
[32:25.000 --> 32:28.000]  Unix атрибуты файлов,
[32:28.000 --> 32:31.000]  бывают еще неродные файловые системы,
[32:31.000 --> 32:34.000]  например, файловые системы,
[32:34.000 --> 32:37.000]  которые пришли к нам из системы Windows,
[32:37.000 --> 32:40.000]  для чего они могут быть полезны?
[32:40.000 --> 32:43.000]  Наверное, для того, чтобы можно было обращаться к другим разделам,
[32:43.000 --> 32:46.000]  если у вас параллельно стоит Windows и Linux на одной машине,
[32:46.000 --> 32:49.000]  либо если вы втыкаете флешку
[32:49.000 --> 32:52.000]  на машине, которая не предназначена для использования Linux.
[32:52.000 --> 32:55.000]  Для этого используются отдельные модули ядра,
[32:55.000 --> 32:58.000]  в частности, модуль для FAT,
[32:58.000 --> 33:01.000]  модуль для NTFS,
[33:01.000 --> 33:04.000]  который самый распространенный файл системы под Windows.
[33:04.000 --> 33:07.000]  На самом деле, то, что входит в поставку Linux,
[33:07.000 --> 33:10.000]  вот именно название NTFS, это на самом деле очень устаревший модуль,
[33:10.000 --> 33:13.000]  который позволяет монтировать файлы системы
[33:13.000 --> 33:16.000]  только на 4.
[33:16.000 --> 33:19.000]  Используется более современный модуль,
[33:19.000 --> 33:22.000]  который реализован немножко по-другому.
[33:22.000 --> 33:25.000]  В чем недостаток
[33:25.000 --> 33:28.000]  все-таки файловых систем,
[33:28.000 --> 33:31.000]  которые не являются родными для Linux?
[33:31.000 --> 33:34.000]  Вы можете потерять
[33:34.000 --> 33:37.000]  часть метаинформации.
[33:37.000 --> 33:40.000]  Например, если у вас файл система FAT,
[33:40.000 --> 33:43.000]  которая исходно была разработана для DOS,
[33:43.000 --> 33:46.000]  а потом адаптирована для Windows,
[33:46.000 --> 33:49.000]  там появилась поддержка для других имен.
[33:49.000 --> 33:52.000]  Казалось бы, файловая система и файловая система.
[33:52.000 --> 33:55.000]  Что в ней плохого?
[33:55.000 --> 33:58.000]  Плохого то, что там не сохраняются атрибуты файлов.
[33:58.000 --> 34:01.000]  То есть вы никогда не узнаете настоящие права
[34:01.000 --> 34:04.000]  чтения, запись, выполнения.
[34:04.000 --> 34:07.000]  И кроме того, там вы не сможете сохранить информацию
[34:07.000 --> 34:10.000]  о том, кто является владельцем файлов.
[34:10.000 --> 34:13.000]  Так и того, что файловая система не была предназначена для UNIX.
[34:13.000 --> 34:16.000]  Что?
[34:16.000 --> 34:19.000]  Про журнал.
[34:19.000 --> 34:22.000]  В NTFS есть журнал,
[34:22.000 --> 34:25.000]  но NTFS тоже не родная файловая система,
[34:25.000 --> 34:28.000]  хотя там есть такое понятие,
[34:28.000 --> 34:31.000]  как Access Control Rights в Windows,
[34:31.000 --> 34:34.000]  но это все-таки не UNIX-овые права,
[34:34.000 --> 34:37.000]  и информация про UNIX-овые атрибуты все-таки будет потеряна.
[34:37.000 --> 34:40.000]  Кроме файловых систем, которые предназначены
[34:40.000 --> 34:43.000]  для дисков, есть еще сетевые файловые системы.
[34:43.000 --> 34:46.000]  В ядре реализована только поддержка
[34:46.000 --> 34:49.000]  классической UNIX-овой файлы системы NFS,
[34:49.000 --> 34:52.000]  достаточно быстро работающей.
[34:52.000 --> 34:55.000]  Когда-то давно в состав ядра Linux еще входила
[34:55.000 --> 34:58.000]  поддержка сети Microsoft Windows,
[34:58.000 --> 35:01.000]  но уже это выпилено,
[35:01.000 --> 35:04.000]  видимо, по соображению безопасности.
[35:04.000 --> 35:07.000]  По крайней мере, в современных версиях ядра
[35:07.000 --> 35:10.000]  это трудно найти.
[35:10.000 --> 35:13.000]  И бывают еще виртуальные файловые системы,
[35:13.000 --> 35:16.000]  которые не связаны вообще ни с какими ресурсами
[35:16.000 --> 35:19.000]  и предназначены для того, чтобы создавать
[35:19.000 --> 35:22.000]  свою структуру по мере обращения
[35:22.000 --> 35:25.000]  из каких-то динамических данных.
[35:25.000 --> 35:28.000]  Например, файл-стем Procfs,
[35:28.000 --> 35:31.000]  который я вам много раз уже показывал,
[35:31.000 --> 35:34.000]  который содержит информацию о процессе.
[35:34.000 --> 35:37.000]  Или файл-стема tmp-afs,
[35:37.000 --> 35:40.000]  это просто хранилище в памяти,
[35:40.000 --> 35:43.000]  которое исчезает после того, как файл-стему
[35:43.000 --> 35:46.000]  отмонтируете, то есть какая-то помойка временных файлов.
[35:46.000 --> 35:49.000]  Еще есть интересная файл-стема,
[35:49.000 --> 35:52.000]  которая называется overlay-fs,
[35:52.000 --> 35:55.000]  которая позволяет создавать файловую систему
[35:55.000 --> 35:58.000]  из разных частей просто наложением одного
[35:58.000 --> 36:01.000]  Операция подключения какой-то файловой системы
[36:01.000 --> 36:04.000]  называется монтирование.
[36:04.000 --> 36:07.000]  Есть команда mount.
[36:07.000 --> 36:10.000]  Если запустить ее без параметров,
[36:10.000 --> 36:13.000]  в Linux вы получаете огромный список,
[36:13.000 --> 36:16.000]  где каждая строчка — это отдельная файл-стема.
[36:16.000 --> 36:19.000]  Если вы тоже самое запустите под BSD-систему
[36:19.000 --> 36:22.000]  или под Mac, этот список будет короче.
[36:22.000 --> 36:25.000]  Без параметров вы команду mount
[36:25.000 --> 36:28.000]  может вызвать в том числе из-под обычного пользы,
[36:28.000 --> 36:31.000]  не обязательно быть root,
[36:31.000 --> 36:34.000]  она отображает на отдельной строчке тип файловой системы,
[36:34.000 --> 36:37.000]  какой части нашей реальной виртуальной файловой системы.
[36:37.000 --> 36:40.000]  Например, в slash-sys подключена эта файловая система,
[36:40.000 --> 36:43.000]  и для некоторых файловых систем,
[36:43.000 --> 36:46.000]  которые связаны с диском,
[36:46.000 --> 36:49.000]  могут быть определены конкретные устройства.
[36:49.000 --> 36:52.000]  Конкретные устройства — это либо
[36:52.000 --> 36:55.000]  что-то в подкаталоге dev,
[36:55.000 --> 36:58.000]  либо уникальные идентификаторы,
[36:58.000 --> 37:01.000]  которые определяются на основании разбиения дисков.
[37:01.000 --> 37:04.000]  Ну и какие-то опции, с которыми файловая система подключена.
[37:04.000 --> 37:07.000]  Mount с параметрами позволяет
[37:07.000 --> 37:10.000]  подмонтировать новую операционную систему,
[37:10.000 --> 37:13.000]  новую файловую систему,
[37:13.000 --> 37:16.000]  но, естественно, для этого уже требуется
[37:16.000 --> 37:19.000]  либо повышение привилегий,
[37:19.000 --> 37:22.000]  если вы хотите, чтобы содержимый файловая система
[37:22.000 --> 37:25.000]  была доступна всем,
[37:25.000 --> 37:28.000]  либо использовать механизм Linux namespaces,
[37:28.000 --> 37:31.000]  предварительно сделать новый namespace
[37:31.000 --> 37:34.000]  для точек монтирования,
[37:34.000 --> 37:37.000]  и в данном случае у вас видимость файловой системы
[37:37.000 --> 37:40.000]  будет только для того процесса,
[37:40.000 --> 37:43.000]  который находится в этом пространстве,
[37:43.000 --> 37:46.000]  но и его дочерних процессов.
[37:46.000 --> 37:49.000]  По граммам монтирования
[37:49.000 --> 37:52.000]  у вас к файловой системе присваивается
[37:52.000 --> 37:55.000]  некоторое число 300-убитное,
[37:55.000 --> 37:58.000]  которое на самом деле стоит из двух частей.
[37:58.000 --> 38:01.000]  Major – это уникальный идентификатор
[38:01.000 --> 38:04.000]  вашей файловой системы,
[38:04.000 --> 38:07.000]  то есть это тип файловой системы,
[38:07.000 --> 38:10.000]  и Minor – это порядковый номер файловой системы,
[38:10.000 --> 38:13.000]  который у вас был подмонтирован.
[38:13.000 --> 38:16.000]  Помните, как однозначно определяется
[38:16.000 --> 38:19.000]  какой-то файл в нашей виртуальной файловой системе.
[38:19.000 --> 38:22.000]  Это пара чисел.
[38:22.000 --> 38:25.000]  Номер устройства,
[38:25.000 --> 38:28.000]  тот, который разбивается на две части,
[38:28.000 --> 38:31.000]  из 24-убит и 8-бит.
[38:31.000 --> 38:34.000]  Второе число – это порядковый номер файлов
[38:34.000 --> 38:37.000]  в пределах одной файловой системы.
[38:37.000 --> 38:40.000]  У вас может быть какой-то физический диск,
[38:40.000 --> 38:43.000]  это уникальная уникальная файловая система,
[38:43.000 --> 38:46.000]  что хранится в этой файловой системе.
[38:46.000 --> 38:49.000]  Там хранятся так называемые айноды,
[38:49.000 --> 38:52.000]  уникальные целые числа.
[38:52.000 --> 38:55.000]  Например, если у меня есть какой-то файл,
[38:55.000 --> 38:58.000]  этот айнод можно узнать в выводе команды start.
[38:58.000 --> 39:01.000]  Он является уникальным для каждого из файлов
[39:01.000 --> 39:04.000]  в пределах одной физической файловой системы.
[39:04.000 --> 39:07.000]  На него, естественно, может быть много ссылок.
[39:07.000 --> 39:10.000]  Символические ссылки – это просто новые.
[39:10.000 --> 39:13.000]  Это файлы специального типа,
[39:13.000 --> 39:16.000]  которые являются…
[39:16.000 --> 39:19.000]  В данном случае это символическая ссылка.
[39:19.000 --> 39:22.000]  Можно сделать еще
[39:22.000 --> 39:25.000]  жесткие ссылки.
[39:28.000 --> 39:31.000]  Теперь айнод у нас сохранился.
[39:31.000 --> 39:34.000]  Что?
[39:34.000 --> 39:37.000]  Тут разницы никакой.
[39:37.000 --> 39:40.000]  Hello2 тот же самый айнод имеет.
[39:40.000 --> 39:43.000]  Жесткие ссылки – это по сути файлы,
[39:43.000 --> 39:46.000]  которые имеют одинаковый айнод,
[39:46.000 --> 39:49.000]  то есть имеют одинаковые содержимые,
[39:49.000 --> 39:52.000]  одинаковые атрибуты, но просто дополнительное
[39:52.000 --> 39:55.000]  имя в каком-то из каталогов.
[39:55.000 --> 39:58.000]  Что будет, если я отключу этот диск
[39:58.000 --> 40:01.000]  в другой компьютер?
[40:01.000 --> 40:04.000]  Айнод у меня сохранится.
[40:04.000 --> 40:07.000]  Но может потом не совпадать
[40:07.000 --> 40:10.000]  вот это число, номер устройства.
[40:10.000 --> 40:13.000]  Почему? Потому что
[40:13.000 --> 40:16.000]  моя файловая система может быть
[40:16.000 --> 40:19.000]  подключена как минимум не первой.
[40:19.000 --> 40:22.000]  И вот пара чисел device и айнод
[40:22.000 --> 40:25.000]  достаточно, чтобы найти любой
[40:25.000 --> 40:28.000]  произвольный файл и не обязательно знать его.
[40:31.000 --> 40:34.000]  Так, ну и файлы систем OverlayFS.
[40:34.000 --> 40:37.000]  Что это такое?
[40:37.000 --> 40:40.000]  Это штука, которая состоит из
[40:40.000 --> 40:43.000]  частей, которая называется нижняя часть.
[40:43.000 --> 40:46.000]  Это одна либо несколько,
[40:46.000 --> 40:49.000]  один либо несколько каталогов,
[40:49.000 --> 40:52.000]  которые определяют нашу файлосистему,
[40:52.000 --> 40:55.000]  и при этом они не будут модифицированы.
[40:55.000 --> 40:58.000]  И так называемый верхний слой –
[40:58.000 --> 41:01.000]  это некоторый каталог,
[41:01.000 --> 41:04.000]  который будет сохранять изменения,
[41:04.000 --> 41:07.000]  которые вы внесли после изменения.
[41:07.000 --> 41:10.000]  Плюс есть еще понятие рабочего каталога.
[41:10.000 --> 41:13.000]  Это что-то временное, что используется
[41:13.000 --> 41:16.000]  потрохами OverlayFS.
[41:16.000 --> 41:19.000]  Тут проще показать на практике, зачем это
[41:19.000 --> 41:22.000]  бывает нужно и как это использовать.
[41:22.000 --> 41:25.000]  Так что словами рассказывать мне очень интересно.
[41:25.000 --> 41:28.000]  Это контейнер.
[41:31.000 --> 41:34.000]  И что в этом контейнере может быть?
[41:34.000 --> 41:37.000]  Во-первых, у вас контейнеров может быть много,
[41:37.000 --> 41:40.000]  и они могут наследовать одну и ту же систему.
[41:40.000 --> 41:43.000]  Так, слово Docker вам должно быть знакомым.
[41:43.000 --> 41:46.000]  Правильно? Что такое Docker?
[41:46.000 --> 41:49.000]  Стрессоконтейнеризация.
[41:49.000 --> 41:52.000]  Ладно, если вы писали Docker файлы,
[41:52.000 --> 41:55.000]  вы импортировали первые строчки Docker файла,
[41:55.000 --> 41:58.000]  писали, какую систему вы хотите наследовать.
[41:58.000 --> 42:01.000]  Давайте сделаем имитацию Docker контейнеров
[42:01.000 --> 42:04.000]  простой, не используя при этом Docker.
[42:04.000 --> 42:07.000]  Для начала нам что нужно?
[42:07.000 --> 42:10.000]  Нам нужен какой-то образ системы,
[42:10.000 --> 42:13.000]  какой-нибудь минималистичный.
[42:13.000 --> 42:16.000]  Как его получить?
[42:16.000 --> 42:19.000]  Самый простой способ – заходим на сайт
[42:19.000 --> 42:22.000]  скачиваем, распаковываем.
[42:22.000 --> 42:25.000]  Ну, не самый интересный.
[42:25.000 --> 42:28.000]  Можно еще сделать...
[42:33.000 --> 42:36.000]  Есть такая команда DebutStrap.
[42:36.000 --> 42:39.000]  Кстати, не обязательно слово Debian.
[42:39.000 --> 42:42.000]  Есть Ubuntu,
[42:42.000 --> 42:45.000]  и, кстати, в RPM-дистрибутивах тоже есть эта команда.
[42:45.000 --> 42:48.000]  Просто она умеет
[42:48.000 --> 42:51.000]  скачивать и распаковывать образы
[42:51.000 --> 42:54.000]  только для Debian-подобных систем.
[42:54.000 --> 42:57.000]  У Ubuntu либо SunDebian,
[42:57.000 --> 43:00.000]  либо еще какие-то директики.
[43:00.000 --> 43:03.000]  Единственное – недостаток от команды требует права root.
[43:03.000 --> 43:06.000]  Но это требуется один раз.
[43:06.000 --> 43:09.000]  Что?
[43:09.000 --> 43:12.000]  Почему ему требуется DebutStrap?
[43:12.000 --> 43:15.000]  Он создает правильные атрибуты файлов,
[43:16.000 --> 43:19.000]  которые в том числе
[43:19.000 --> 43:22.000]  принадлежат пользователю root.
[43:22.000 --> 43:25.000]  Потому что вы в теории можете...
[43:25.000 --> 43:28.000]  Там есть честная система,
[43:28.000 --> 43:31.000]  в которой вы можете сделать root
[43:31.000 --> 43:34.000]  без всяких...
[43:34.000 --> 43:37.000]  И там будут все те же самые права,
[43:37.000 --> 43:40.000]  тот же владелец root, а чтобы сделать владельцем
[43:40.000 --> 43:43.000]  пользователю root, нужно права root.
[43:43.000 --> 43:46.000]  Так позволяет делать образ AltLinux.
[43:46.000 --> 43:49.000]  Не AltLinux, а AlpineLinux.
[43:49.000 --> 43:52.000]  В AlpineLinux он все-таки достаточно ограниченный.
[43:52.000 --> 43:55.000]  Там достаточно урезная система.
[43:59.000 --> 44:02.000]  Как этой штукой пользоваться?
[44:06.000 --> 44:09.000]  Первый аргумент – это
[44:09.000 --> 44:12.000]  название дистрибутива. Второй – это
[44:12.000 --> 44:15.000]  целевой каталог, куда нужно сделать новый образ.
[44:15.000 --> 44:18.000]  Но еще желательно указывать зеркало,
[44:18.000 --> 44:21.000]  чтобы оно устанавливалось быстрее.
[44:27.000 --> 44:30.000]  FocalFos – последнее кодовое имя
[44:30.000 --> 44:33.000]  Ubuntu LTS 2004.
[44:33.000 --> 44:36.000]  А сейчас что там новое?
[44:36.000 --> 44:39.000]  Это которое недавно вышло, да?
[44:39.000 --> 44:42.000]  Не последнее, а предпоследнее.
[44:42.000 --> 44:45.000]  Каталог куда установить?
[44:45.000 --> 44:48.000]  Чтобы не тратить много времени на скачки,
[44:48.000 --> 44:51.000]  я это запускаю на удаленном сервере,
[44:51.000 --> 44:54.000]  который находится...
[44:54.000 --> 44:57.000]  Селедтел.ру
[44:57.000 --> 45:00.000]  Реклама не явная.
[45:06.000 --> 45:09.000]  Вот он достаточно быстро скачает все файлы,
[45:09.000 --> 45:12.000]  установит локальную систему в каталог.
[45:12.000 --> 45:15.000]  В этом каталоге будет отдельная система,
[45:15.000 --> 45:18.000]  но достаточно бесполезно.
[45:18.000 --> 45:21.000]  Точнее, ей пользоваться можно.
[45:21.000 --> 45:24.000]  Можно даже настроить APT,
[45:24.000 --> 45:27.000]  сделать чрут.
[45:27.000 --> 45:30.000]  Но зачем мы это делаем?
[45:30.000 --> 45:33.000]  Пока оно ставится, тут же рядом.
[45:33.000 --> 45:36.000]  Сделаем какое-нибудь приложение,
[45:36.000 --> 45:39.000]  которое может иметь под каталоги
[45:39.000 --> 45:42.000]  SRC с исходниками
[45:42.000 --> 45:45.000]  и стандартный по иерархии USR BIM.
[45:46.000 --> 45:49.000]  Приложение будет
[45:49.000 --> 45:52.000]  очень полезным.
[45:52.000 --> 45:55.000]  Называется Hello.
[45:55.000 --> 45:58.000]  И делать очень важную вещь.
[46:04.000 --> 46:07.000]  Что важное нужно сказать?
[46:07.000 --> 46:10.000]  Привет, мир!
[46:10.000 --> 46:13.000]  Кто сказал привет, мир?
[46:13.000 --> 46:16.000]  Кто сказал привет, мир?
[46:16.000 --> 46:19.000]  Компилируем поставку
[46:19.000 --> 46:22.000]  нашего великого приложения.
[46:22.000 --> 46:25.000]  Возможно, складываем какие-то ресурсы.
[46:31.000 --> 46:34.000]  Вот у нас есть какая-то программа.
[46:34.000 --> 46:37.000]  Если мы хотим эту программу запустить
[46:37.000 --> 46:40.000]  с помощью контейнера,
[46:40.000 --> 46:43.000]  запихать в какой-то образ,
[46:43.000 --> 46:46.000]  запаковать,
[46:46.000 --> 46:49.000]  и получаем что-то тяжелое.
[46:49.000 --> 46:52.000]  Если у нас много программ,
[46:52.000 --> 46:55.000]  которые наследуют один и тот же образ,
[46:55.000 --> 46:58.000]  что мы можем сделать?
[46:58.000 --> 47:01.000]  Что сделать?
[47:01.000 --> 47:04.000]  Один образ – куча программ,
[47:04.000 --> 47:07.000]  но не всегда это бывает осмысленно.
[47:07.000 --> 47:10.000]  Программа должна быть только программой
[47:10.000 --> 47:13.000]  и не лезть никуда лишним.
[47:13.000 --> 47:16.000]  Давайте сделаем контейнер.
[47:22.000 --> 47:25.000]  Иерархия каталогов USR BIM
[47:25.000 --> 47:28.000]  должна накладываться на базовую систему.
[47:28.000 --> 47:31.000]  И потом мы этот контейнер
[47:31.000 --> 47:34.000]  можем запускать
[47:34.000 --> 47:37.000]  после того, как мы завершили работу.
[47:37.000 --> 47:40.000]  Причем запустить мы можем в нескольких экземплярах.
[47:40.000 --> 47:43.000]  Логично, могут нескольких пользователей
[47:43.000 --> 47:46.000]  запустить несколько экземпляров
[47:46.000 --> 47:49.000]  из этого же контейнера.
[47:49.000 --> 47:52.000]  Естественно, они должны находиться
[47:52.000 --> 47:55.000]  в своем экземпляре и не мешать друг другу.
[47:55.000 --> 47:58.000]  Давайте законтейнеризируем запуск этой штуки.
[47:58.000 --> 48:01.000]  Что нам для этого понадобится?
[48:01.000 --> 48:04.000]  В приложении у нас могут быть
[48:04.000 --> 48:07.000]  какие-то данные, связанные с конкретным запуском.
[48:07.000 --> 48:10.000]  Пусть будут в каталоге дейта.
[48:10.000 --> 48:13.000]  Еще файлы стимуврилы FFS
[48:13.000 --> 48:16.000]  требует временный каталог
[48:16.000 --> 48:19.000]  для своих внутренних файлов.
[48:19.000 --> 48:22.000]  В результате мы получим
[48:22.000 --> 48:25.000]  новую корневую файловую систему
[48:25.000 --> 48:28.000]  наложением нашего базу.
[48:31.000 --> 48:34.000]  Поверх этого каталога есть
[48:34.000 --> 48:37.000]  каталог с реализацией нашего приложения.
[48:40.000 --> 48:43.000]  Теперь мы сделали новый каталог.
[48:43.000 --> 48:46.000]  Что мы теперь можем сделать?
[48:46.000 --> 48:49.000]  Мы теперь можем написать
[48:49.000 --> 48:52.000]  такую огромную команду.
[48:52.000 --> 48:55.000]  Команда будет длинная.
[48:55.000 --> 48:58.000]  Маунд, дальше минус T.
[48:59.000 --> 49:02.000]  По умолчанию
[49:02.000 --> 49:05.000]  нужно указывать.
[49:05.000 --> 49:08.000]  Маунд, если вы указываете
[49:08.000 --> 49:11.000]  только один параметр,
[49:11.000 --> 49:14.000]  то он смотрит файл ETC fstab
[49:14.000 --> 49:17.000]  и ищет соответствие ETC fstab.
[49:17.000 --> 49:20.000]  Можно указывать либо
[49:20.000 --> 49:23.000]  mountpoint либо конкретное устройство.
[49:23.000 --> 49:26.000]  Если указывать не меньше
[49:26.000 --> 49:29.000]  двух аргументов, то это будет новая
[49:29.000 --> 49:32.000]  точка монтировки.
[49:32.000 --> 49:35.000]  Опция минус T означает указать тип
[49:35.000 --> 49:38.000]  файловой системы.
[49:38.000 --> 49:41.000]  Маунд, минус T.
[49:41.000 --> 49:44.000]  Тип файл системы Overlay.
[49:44.000 --> 49:47.000]  Устройство, которое мы хотим
[49:47.000 --> 49:50.000]  подмонтировать.
[49:50.000 --> 49:53.000]  В данном случае оно совпадает с именем
[49:53.000 --> 49:56.000]  файловой системы.
[49:56.000 --> 49:59.000]  Дальше начинается интересное.
[49:59.000 --> 50:02.000]  Через опцию минус O
[50:02.000 --> 50:05.000]  можно указать дополнительные
[50:05.000 --> 50:08.000]  опции.
[50:08.000 --> 50:11.000]  Для файловой системы указывается,
[50:11.000 --> 50:14.000]  в какой кодировке работает,
[50:14.000 --> 50:17.000]  какие права по умолчанию,
[50:17.000 --> 50:20.000]  можно ли журналировать.
[50:20.000 --> 50:23.000]  Нижний уровень, второй каталог, верхний
[50:23.000 --> 50:26.000]  уровень и третий это каталог для временных
[50:26.000 --> 50:29.000]  файлов.
[50:29.000 --> 50:32.000]  LoverDir.
[50:32.000 --> 50:35.000]  Это базовая система.
[50:35.000 --> 50:38.000]  LoverDir может быть несколько разделят
[50:38.000 --> 50:41.000]  с темом двоеточия.
[50:41.000 --> 50:44.000]  Базовая система, поверх которой наложено приложение.
[50:44.000 --> 50:47.000]  UpperDir.
[50:47.000 --> 50:50.000]  Нашего контейнера, где будут храниться
[50:50.000 --> 50:53.000]  пользовательские данные.
[50:53.000 --> 50:56.000]  WorkDir.
[50:56.000 --> 50:59.000]  Это временный каталог.
[50:59.000 --> 51:02.000]  Там будет страшное содержимое.
[51:02.000 --> 51:05.000]  Обязательные параметры для mount.
[51:05.000 --> 51:08.000]  Это точка монтирования.
[51:08.000 --> 51:11.000]  Я его создал в каталоге.
[51:11.000 --> 51:14.000]  Получаем бабах.
[51:14.000 --> 51:17.000]  Только пользователь root имеет право
[51:17.000 --> 51:20.000]  что-то монтировать.
[51:20.000 --> 51:23.000]  Не очень хорошо,
[51:23.000 --> 51:26.000]  потому что вы же контейнеры,
[51:26.000 --> 51:29.000]  даже docker-контейнеры запускаете из-под обычного.
[51:29.000 --> 51:32.000]  Рута вам обычно не требуется.
[51:32.000 --> 51:35.000]  Даже группа docker не очень то обязательна.
[51:35.000 --> 51:38.000]  Docker просто
[51:38.000 --> 51:41.000]  проектировали как попало.
[51:41.000 --> 51:44.000]  Отдельная группа
[51:44.000 --> 51:47.000]  тоже не требуется.
[51:47.000 --> 51:50.000]  Я понимаю, почему docker требует отдельной группы.
[51:50.000 --> 51:53.000]  Там все группы требуют создательную запись.
[51:56.000 --> 51:59.000]  Мы можем либо ставить root,
[51:59.000 --> 52:02.000]  но это не очень хорошее решение.
[52:02.000 --> 52:05.000]  Зачем быть root, чтобы запустить контейнер,
[52:05.000 --> 52:08.000]  который может быть небезопасным.
[52:08.000 --> 52:11.000]  Нужно сделать систему так, чтобы она никому не мешала.
[52:11.000 --> 52:14.000]  И чтобы она никому не была доступна,
[52:14.000 --> 52:17.000]  кроме нашего конкретного процесса,
[52:17.000 --> 52:20.000]  его вечерних процессов.
[52:20.000 --> 52:23.000]  Как это сделать? Linux namespaces.
[52:23.000 --> 52:26.000]  Помните конец прошлого семестра?
[52:26.000 --> 52:29.000]  Команда unshare.
[52:29.000 --> 52:32.000]  Надо контрольную провести весь год.
[52:32.000 --> 52:35.000]  Не за этот семестр, не за этот год.
[52:35.000 --> 52:38.000]  Так.
[52:38.000 --> 52:41.000]  Что?
[52:44.000 --> 52:47.000]  Нет, это слишком халявно было.
[52:47.000 --> 52:50.000]  Unshare –rm.
[52:50.000 --> 52:53.000]  –r означает стать фейковым
[52:53.000 --> 52:56.000]  пользователем root.
[52:56.000 --> 52:59.000]  –m – отключить пространство
[52:59.000 --> 53:02.000]  mount.point.
[53:02.000 --> 53:05.000]  Помолчаю, unshare запускает bash.
[53:05.000 --> 53:08.000]  Обратите внимание, что имя пользователя
[53:08.000 --> 53:11.000]  меня поменялось, стало root.
[53:11.000 --> 53:14.000]  Я могу сделать какой-то файл.
[53:14.000 --> 53:17.000]  Он создался.
[53:20.000 --> 53:23.000]  В каталоге контейнер.
[53:23.000 --> 53:26.000]  А кто является его владельцем?
[53:26.000 --> 53:29.000]  Его владельцем является обычный пользователь,
[53:29.000 --> 53:32.000]  потому что когда вы делаете unshare
[53:32.000 --> 53:35.000]  пользователя root, то у вас просто
[53:35.000 --> 53:38.000]  происходит отображение с двиг
[53:38.000 --> 53:41.000]  user.id
[53:41.000 --> 53:44.000]  на определенный констант.
[53:44.000 --> 53:47.000]  И ноль отображается на файлы обычного пользователя.
[53:47.000 --> 53:50.000]  Теперь я вас проведу
[53:50.000 --> 53:53.000]  вот это вот безобразие.
[53:53.000 --> 53:56.000]  Вау.
[53:56.000 --> 53:59.000]  Вот оно подмонтировалось.
[53:59.000 --> 54:02.000]  Что у нас содержится в new root?
[54:02.000 --> 54:05.000]  У меня теперь содержится
[54:05.000 --> 54:08.000]  иерархия каталогов стандартной в Linux системы.
[54:08.000 --> 54:11.000]  А из другого процесса я уже не вижу
[54:11.000 --> 54:14.000]  этого содержения.
[54:14.000 --> 54:17.000]  Этот каталог остается пустым, почему?
[54:17.000 --> 54:20.000]  Потому что для того, чтобы подмонтировать
[54:20.000 --> 54:23.000]  файл системы, мне пришлось сделать новое изолированное
[54:23.000 --> 54:26.000]  изображение.
[54:26.000 --> 54:29.000]  Команда mount мне честно показывает, что в конце
[54:29.000 --> 54:32.000]  действительно подмонтирована эта файла система.
[54:32.000 --> 54:35.000]  Из другого процесса на той же машине mount
[54:35.000 --> 54:38.000]  при этом ничего не знает.
[54:38.000 --> 54:41.000]  Ну и теперь я могу
[54:41.000 --> 54:44.000]  сменить
[54:44.000 --> 54:47.000]  каталог.
[54:47.000 --> 54:50.000]  Я нахожусь в корне.
[54:50.000 --> 54:53.000]  Вот команда hello.
[54:53.000 --> 54:56.000]  Она работает.
[54:56.000 --> 54:59.000]  Никаких прав root здесь не потребовалось.
[54:59.000 --> 55:02.000]  Сейчас мы смоделировали некоторые контейнеры.
[55:02.000 --> 55:05.000]  Что у нас при этом болтается
[55:05.000 --> 55:08.000]  в new root?
[55:11.000 --> 55:14.000]  Вот у нас есть
[55:14.000 --> 55:17.000]  new root,
[55:17.000 --> 55:20.000]  есть еще каталог дейта,
[55:20.000 --> 55:23.000]  который является верхним слоем
[55:23.000 --> 55:26.000]  нашей объединенной файловой системы.
[55:26.000 --> 55:29.000]  Давайте создадим
[55:29.000 --> 55:32.000]  в корне файл hello.txt.
[55:35.000 --> 55:38.000]  Вот он есть.
[55:38.000 --> 55:41.000]  Что произойдет, когда я отмонтирую
[55:41.000 --> 55:44.000]  эту файловую систему или просто закрою эту вкладку,
[55:44.000 --> 55:47.000]  и потом воспроизведу это заново.
[55:47.000 --> 55:50.000]  У меня данные потеряются или не потеряются?
[55:50.000 --> 55:53.000]  Вот самый верхний каталог.
[55:53.000 --> 55:56.000]  Он нужен для того, чтобы сохранять изменения,
[55:56.000 --> 55:59.000]  которые получены в нашей объединенной файловой системе.
[55:59.000 --> 56:02.000]  Права на владельцам
[56:02.000 --> 56:05.000]  является пользователь sui-1000,
[56:05.000 --> 56:08.000]  тот самый пользователь, который изначально
[56:08.000 --> 56:11.000]  выполнил команду unsure.
[56:12.000 --> 56:15.000]  Если я что-нибудь натворю,
[56:15.000 --> 56:18.000]  я как бы пользователь root.
[56:18.000 --> 56:21.000]  Что будет, если я что-то натворю в системе?
[56:21.000 --> 56:24.000]  Например,
[56:24.000 --> 56:27.000]  удалю, что-нибудь ненужное есть.
[56:27.000 --> 56:30.000]  Перл мне нафиг не нужен.
[56:30.000 --> 56:33.000]  Вот, кстати, недостаток
[56:33.000 --> 56:36.000]  для bootstrap.
[56:36.000 --> 56:39.000]  Такого штуку не позволит сделать.
[56:39.000 --> 56:42.000]  Ладно, давайте что-нибудь другое сделаем.
[56:42.000 --> 56:45.000]  Здесь уит как раз владельцем
[56:45.000 --> 56:48.000]  является пользователем.
[56:48.000 --> 56:51.000]  Зато есть владелец
[56:51.000 --> 56:54.000]  на команду hello
[56:54.000 --> 56:57.000]  sr bin hello
[57:00.000 --> 57:03.000]  Вообще никак.
[57:03.000 --> 57:06.000]  В чем еще можно натворить?
[57:06.000 --> 57:09.000]  Удалить не смогу,
[57:09.000 --> 57:12.000]  зато я смогу модифицировать.
[57:12.000 --> 57:15.000]  Я не могу удалить,
[57:15.000 --> 57:18.000]  потому что в исходном файле
[57:18.000 --> 57:21.000]  каталог usr bin
[57:21.000 --> 57:24.000]  обладает правами только на чтении
[57:24.000 --> 57:27.000]  и владельцем его root.
[57:27.000 --> 57:30.000]  Нет, там просто уисходный.
[57:30.000 --> 57:33.000]  Нет, это фейковый root.
[57:34.000 --> 57:37.000]  Давайте
[57:37.000 --> 57:40.000]  смысл root
[57:40.000 --> 57:43.000]  то, что мы смогли сделать mount.
[57:43.000 --> 57:46.000]  Давайте сделаем непри... ой.
[57:49.000 --> 57:52.000]  Кнопочки вверх-вниз
[57:52.000 --> 57:55.000]  vi не работают.
[57:58.000 --> 58:01.000]  Это vi, это не vim.
[58:03.000 --> 58:06.000]  Да, vdkl, но в помощь.
[58:06.000 --> 58:09.000]  Главное, вручки не работают.
[58:09.000 --> 58:12.000]  Давайте мы вставим
[58:12.000 --> 58:15.000]  что-нибудь в место привет-мир.
[58:15.000 --> 58:18.000]  Напишем...
[58:18.000 --> 58:21.000]  Сделано просто пустым.
[58:21.000 --> 58:24.000]  Сойдет.
[58:24.000 --> 58:27.000]  Мы поменяли файл hello sr.
[58:27.000 --> 58:30.000]  Что у нас произошло
[58:30.000 --> 58:33.000]  перед исходным файлом hello sr,
[58:33.000 --> 58:36.000]  который находится, например,
[58:36.000 --> 58:39.000]  в нашем приложении.
[58:45.000 --> 58:48.000]  Нет, рестолировать можем.
[58:48.000 --> 58:51.000]  Смотрите, в исходном application
[58:51.000 --> 58:54.000]  ничего не поменялось.
[58:54.000 --> 58:57.000]  А где у нас сохранились изменения
[58:57.000 --> 59:00.000]  Все эти изменения
[59:00.000 --> 59:03.000]  попали...
[59:09.000 --> 59:12.000]  Сейчас покажу.
[59:12.000 --> 59:15.000]  Теперь заходим в наш контейнер
[59:15.000 --> 59:18.000]  new root.
[59:18.000 --> 59:21.000]  Тоже, как мы создаем новые файлы
[59:21.000 --> 59:24.000]  new root.
[59:24.000 --> 59:27.000]  Вот файл hello.txt, который мы создали.
[59:27.000 --> 59:30.000]  Точно так же мы можем
[59:30.000 --> 59:33.000]  инсталлировать что-то.
[59:33.000 --> 59:36.000]  Это верхний слой,
[59:36.000 --> 59:39.000]  он сохраняет все изменения.
[59:39.000 --> 59:42.000]  Если вы что-то вставите
[59:42.000 --> 59:45.000]  внутри вашего контейнера,
[59:45.000 --> 59:48.000]  то оно в каталоге с данными сохранится.
[59:48.000 --> 59:51.000]  А что мешает?
[59:51.000 --> 59:54.000]  У нас появился
[59:54.000 --> 59:57.000]  подкаталог src
[59:57.000 --> 01:00:00.000]  который содержит файл hello.txt
[01:00:00.000 --> 01:00:03.000]  и он содержит
[01:00:03.000 --> 01:00:06.000]  новое содержимое нашего файла.
[01:00:06.000 --> 01:00:09.000]  А если мы его вообще грохнем,
[01:00:09.000 --> 01:00:12.000]  что у нас произойдет?
[01:00:12.000 --> 01:00:15.000]  У нас появляется
[01:00:15.000 --> 01:00:18.000]  файл hello.txt
[01:00:19.000 --> 01:00:22.000]  который вы не можете посмотреть.
[01:00:22.000 --> 01:00:25.000]  Выдает какую-то странную ошибку.
[01:00:25.000 --> 01:00:28.000]  Это просто
[01:00:28.000 --> 01:00:31.000]  файл специального типа,
[01:00:31.000 --> 01:00:34.000]  который является признаком того,
[01:00:34.000 --> 01:00:37.000]  что данный файл был просто удален
[01:00:37.000 --> 01:00:40.000]  из исходной нежележащей
[01:00:40.000 --> 01:00:43.000]  файловой системы.
[01:00:43.000 --> 01:00:46.000]  То есть наложение потом повторное
[01:00:46.000 --> 01:00:49.000]  из изготовления файловой системы.
[01:00:49.000 --> 01:00:52.000]  Да и это поверх каких-то каталогов
[01:00:52.000 --> 01:00:55.000]  с нижней файловой системой,
[01:00:55.000 --> 01:00:58.000]  с базовой системой, плюс наш каталог.
[01:00:58.000 --> 01:01:01.000]  Опять нам вернет исходное состояние
[01:01:01.000 --> 01:01:04.000]  вот эту файловую систему, которую мы и получили.
[01:01:04.000 --> 01:01:07.000]  Докер через OverlayFS работает.
[01:01:07.000 --> 01:01:10.000]  Более того, OverlayFS появилась
[01:01:10.000 --> 01:01:13.000]  благодаря докеру,
[01:01:13.000 --> 01:01:16.000]  особенность файловой системы OverlayFS.
[01:01:16.000 --> 01:01:19.000]  Она реализована как модуль ядра.
[01:01:19.000 --> 01:01:22.000]  Точно так же, как все остальные файловые системы.
[01:01:22.000 --> 01:01:25.000]  На самом деле можно еще делать
[01:01:25.000 --> 01:01:28.000]  файловые системы не обязательно в ядре.
[01:01:28.000 --> 01:01:31.000]  Можно делать обычные программы, в том числе
[01:01:31.000 --> 01:01:34.000]  писать на питоне,
[01:01:34.000 --> 01:01:37.000]  которые будут реализовывать функциональность
[01:01:37.000 --> 01:01:40.000]  файловой системы и вытворять все, что угодно.
[01:01:41.000 --> 01:01:44.000]  Как это происходит?
[01:01:44.000 --> 01:01:47.000]  Есть подсистема Fuse,
[01:01:47.000 --> 01:01:50.000]  которая как File System, User Space,
[01:01:50.000 --> 01:01:53.000]  работает следующим образом.
[01:01:53.000 --> 01:01:56.000]  Есть модуль ядра, который называется тоже Fuse.
[01:01:56.000 --> 01:01:59.000]  Он предназначен для создания
[01:01:59.000 --> 01:02:02.000]  произвольных файловых систем.
[01:02:02.000 --> 01:02:05.000]  При загрузке модуля Fuse у вас появляется
[01:02:05.000 --> 01:02:08.000]  специальный символный файл
[01:02:08.000 --> 01:02:11.000]  FSDF slash Fuse,
[01:02:11.000 --> 01:02:14.000]  который вы можете открыть, получить файловый дискриптор
[01:02:14.000 --> 01:02:17.000]  и дальше с этим файловым дискриптором
[01:02:17.000 --> 01:02:20.000]  взаимодействовать как с обычным socket.
[01:02:20.000 --> 01:02:23.000]  Что при этом вы будете читать из socket?
[01:02:23.000 --> 01:02:26.000]  Вы при этом будете читать из socket какие-то команды,
[01:02:26.000 --> 01:02:29.000]  которые посылает вам ядро.
[01:02:29.000 --> 01:02:32.000]  А что за команда, которые ядро может вам посылать?
[01:02:32.000 --> 01:02:35.000]  Например, какой-то пользовательский процесс
[01:02:35.000 --> 01:02:38.000]  или файл, который находится в вашей файловой системе Fuse.
[01:02:38.000 --> 01:02:41.000]  В данном случае запрос будет
[01:02:41.000 --> 01:02:44.000]  переадресован как к кому-то процессу,
[01:02:44.000 --> 01:02:47.000]  который обслуживает данную точку монтировки.
[01:02:47.000 --> 01:02:50.000]  В ответ ваша программа
[01:02:50.000 --> 01:02:53.000]  должна отправить
[01:02:53.000 --> 01:02:56.000]  какое-то содержимое,
[01:02:56.000 --> 01:02:59.000]  либо содержимое файла, либо метаданные файлы,
[01:02:59.000 --> 01:03:02.000]  либо какую-то ошибку.
[01:03:05.000 --> 01:03:08.000]  Таким образом, вы можете реализовывать
[01:03:08.000 --> 01:03:11.000]  произвольные файловые системы,
[01:03:11.000 --> 01:03:14.000]  которые могут вытворять все, что угодно,
[01:03:14.000 --> 01:03:17.000]  поскольку обычные программы,
[01:03:17.000 --> 01:03:20.000]  которые могут использовать любые совершенно библиотеки,
[01:03:20.000 --> 01:03:23.000]  не запихивают все ядро.
[01:03:23.000 --> 01:03:26.000]  Задача ядра в данном случае
[01:03:26.000 --> 01:03:29.000]  это только перенаправлять какие-то запросы
[01:03:29.000 --> 01:03:32.000]  от других программ к вашей файловой системе.
[01:03:32.000 --> 01:03:35.000]  Как я сказал,
[01:03:35.000 --> 01:03:38.000]  эта штука может быть сделана
[01:03:38.000 --> 01:03:41.000]  не обязательно на си, не обязательно на плюсах,
[01:03:41.000 --> 01:03:44.000]  как вообще реализуется взаимодействие с Fuse.
[01:03:44.000 --> 01:03:47.000]  Есть библиотека LeapFuse,
[01:03:47.000 --> 01:03:50.000]  на семинарах 29-й группы у нас уже вчера был семинар.
[01:03:50.000 --> 01:03:53.000]  Вы это потрогали, другие группы еще успеете.
[01:03:53.000 --> 01:03:56.000]  Как раз будете делать реализацию своих файловых систем
[01:03:56.000 --> 01:03:59.000]  на базе Fuse.
[01:03:59.000 --> 01:04:02.000]  Нужно реализовать определенные функции,
[01:04:02.000 --> 01:04:05.000]  которые соответствуют отдельным функциям
[01:04:05.000 --> 01:04:08.000]  файловым системе.
[01:04:08.000 --> 01:04:11.000]  Аналог функции stat,
[01:04:11.000 --> 01:04:14.000]  аналог функции read, аналог функции open.
[01:04:14.000 --> 01:04:17.000]  По сути, не все из них являются сисковыми.
[01:04:17.000 --> 01:04:20.000]  ReadGear, например, это не сисковый.
[01:04:20.000 --> 01:04:23.000]  Реализовать функциональность того,
[01:04:23.000 --> 01:04:26.000]  что выполняется системными вызовами
[01:04:26.000 --> 01:04:29.000]  и дальше просто прослушивать какой-то socket
[01:04:29.000 --> 01:04:32.000]  при необходимости обрабатывать,
[01:04:32.000 --> 01:04:35.000]  вызывать нужные обработчики.
[01:04:35.000 --> 01:04:38.000]  Но эта часть реализована как раз в библиотеке LeapFuse,
[01:04:38.000 --> 01:04:41.000]  для которой есть оболочки, в том числе и на Python.
[01:04:41.000 --> 01:04:44.000]  Последняя демонстрашка на сегодня
[01:04:44.000 --> 01:04:47.000]  это
[01:04:50.000 --> 01:04:53.000]  программа на Python,
[01:04:53.000 --> 01:04:56.000]  которая реализует временную файловую систему
[01:04:56.000 --> 01:04:59.000]  в памяти.
[01:04:59.000 --> 01:05:02.000]  Пример не мой.
[01:05:02.000 --> 01:05:05.000]  Взят из списка экзамплов
[01:05:05.000 --> 01:05:08.000]  в библиотеке Fuse Python.
[01:05:08.000 --> 01:05:11.000]  На Python это делается
[01:05:11.000 --> 01:05:14.000]  в виде класса,
[01:05:14.000 --> 01:05:17.000]  в котором реализуются какие-то методы,
[01:05:17.000 --> 01:05:20.000]  очень сильно похожие
[01:05:20.000 --> 01:05:23.000]  на команды либо системные вызовы.
[01:05:23.000 --> 01:05:26.000]  Единственное отличие, вместо stat
[01:05:26.000 --> 01:05:29.000]  Fuse использует getUpper.
[01:05:29.000 --> 01:05:32.000]  Чаун, чмод,
[01:05:32.000 --> 01:05:35.000]  create, знакомые названия.
[01:05:35.000 --> 01:05:38.000]  mkdir,
[01:05:38.000 --> 01:05:41.000]  open, read, readdir.
[01:05:41.000 --> 01:05:44.000]  Примерно все то же самое.
[01:05:44.000 --> 01:05:47.000]  Реализуйте какую-то функциональность.
[01:05:47.000 --> 01:05:50.000]  Самая интересная функция main,
[01:05:50.000 --> 01:05:53.000]  просто вызываете что-то штатное.
[01:05:56.000 --> 01:05:59.000]  137 строк на Python,
[01:05:59.000 --> 01:06:02.000]  полноценная реализация временной файловой системы.
[01:06:02.000 --> 01:06:05.000]  На плюсах, кстати, не сильно.
[01:06:05.000 --> 01:06:08.000]  Больше, конечно, но не сильно.
[01:06:08.000 --> 01:06:11.000]  Запускаем
[01:06:11.000 --> 01:06:14.000]  все это безобразие.
[01:06:14.000 --> 01:06:17.000]  Обязательный аргумент
[01:06:17.000 --> 01:06:20.000]  точка монтирования.
[01:06:20.000 --> 01:06:23.000]  Там получаем какую-то ошибку,
[01:06:23.000 --> 01:06:26.000]  потому что сразу после монтирования
[01:06:26.000 --> 01:06:29.000]  какая-то зараза полезла.
[01:06:29.000 --> 01:06:32.000]  Подозреваю, что у меня там запущен десктоп с XFCE,
[01:06:32.000 --> 01:06:35.000]  полез по всяким нехорошим файлам.
[01:06:35.000 --> 01:06:38.000]  Тем не менее, оно работает.
[01:06:38.000 --> 01:06:41.000]  Что теперь я могу сделать?
[01:06:41.000 --> 01:06:44.000]  Нехорошо быть root.
[01:06:50.000 --> 01:06:53.000]  Зашли в mount.
[01:06:53.000 --> 01:06:56.000]  Создадим какой-нибудь файл.
[01:06:59.000 --> 01:07:02.000]  Можем очереду сделать,
[01:07:02.000 --> 01:07:05.000]  только как только я останулю этот процесс,
[01:07:05.000 --> 01:07:08.000]  то про все данные можно будет забыть.
[01:07:11.000 --> 01:07:14.000]  Вот создан какой-то файл.
[01:07:14.000 --> 01:07:17.000]  Он доступен.
[01:07:17.000 --> 01:07:20.000]  В логе пишется, что действительно был создан файл.
[01:07:20.000 --> 01:07:23.000]  Потом прочитали каталог.
[01:07:23.000 --> 01:07:26.000]  Затем еще раскрыли файл, прочитали.
[01:07:26.000 --> 01:07:29.000]  В общем, какие-то действия происходят.
[01:07:29.000 --> 01:07:32.000]  Я теперь нажимаю CTRL-C,
[01:07:32.000 --> 01:07:35.000]  останавливаю этот сервис.
[01:07:35.000 --> 01:07:38.000]  Какая-то ошибка.
[01:07:38.000 --> 01:07:41.000]  В общем, все.
[01:07:41.000 --> 01:07:44.000]  Файл системы у меня больше не доступны.
[01:07:53.000 --> 01:07:56.000]  В самом деле, она не сразу была полностью отмонтирована.
[01:07:56.000 --> 01:07:59.000]  Просто по той причине,
[01:07:59.000 --> 01:08:02.000]  что данный каталог
[01:08:02.000 --> 01:08:05.000]  был задействован как текущий,
[01:08:05.000 --> 01:08:08.000]  но отмонтирование произошло немножко позже,
[01:08:08.000 --> 01:08:11.000]  потому что нельзя
[01:08:11.000 --> 01:08:14.000]  полностью отмонтировать то,
[01:08:14.000 --> 01:08:17.000]  что используется.
[01:08:17.000 --> 01:08:20.000]  Теперь еще раз OS Mountain Point.
[01:08:20.000 --> 01:08:23.000]  Все пусто, потому что была временная файловая система.
[01:08:23.000 --> 01:08:26.000]  Поскольку это язык программирования Python,
[01:08:26.000 --> 01:08:29.000]  что вы можете вытворять?
[01:08:29.000 --> 01:08:32.000]  На Python вы можете вытворять очень много всего.
[01:08:32.000 --> 01:08:35.000]  Например, будет залазить в интернет,
[01:08:35.000 --> 01:08:38.000]  дергать какие-нибудь API,
[01:08:38.000 --> 01:08:41.000]  каких-нибудь сторонних сервисов.
[01:08:41.000 --> 01:08:44.000]  Так, например, может быть,
[01:08:44.000 --> 01:08:47.000]  файл системы, которая скачивает что-нибудь из YouTube,
[01:08:47.000 --> 01:08:50.000]  может сделать отображение почты.
[01:08:50.000 --> 01:08:53.000]  Возможности ограничивается только вашей фантазией.
[01:08:53.000 --> 01:08:56.000]  И что вообще сделано
[01:08:56.000 --> 01:08:59.000]  с использованием Fuse?
[01:08:59.000 --> 01:09:02.000]  Во-первых, доступ
[01:09:02.000 --> 01:09:05.000]  к сети Microsoft Windows.
[01:09:05.000 --> 01:09:08.000]  Windows использует свою сеть Microsoft Windows.
[01:09:08.000 --> 01:09:11.000]  Это не FTP, не NFS.
[01:09:11.000 --> 01:09:14.000]  Это протокол SMB.
[01:09:14.000 --> 01:09:17.000]  Когда-то в ядре Linux,
[01:09:17.000 --> 01:09:20.000]  может быть, сейчас в ядре есть,
[01:09:20.000 --> 01:09:23.000]  просто все дистрибутивы ее включают,
[01:09:23.000 --> 01:09:26.000]  была поддержка файла системы SMB.
[01:09:26.000 --> 01:09:29.000]  Из ядра в какой-то момент
[01:09:29.000 --> 01:09:32.000]  эту штуку выкинули,
[01:09:32.000 --> 01:09:35.000]  но есть возможность использовать
[01:09:35.000 --> 01:09:38.000]  функциональность SMB
[01:09:38.000 --> 01:09:41.000]  используя под систему Fuse,
[01:09:41.000 --> 01:09:44.000]  поскольку в данном случае,
[01:09:44.000 --> 01:09:47.000]  даже если что-то не очень корректно работающее у вас будет,
[01:09:47.000 --> 01:09:50.000]  то оно не скомпрометируется системе.
[01:09:50.000 --> 01:09:53.000]  Файл системы TFS.
[01:09:53.000 --> 01:09:56.000]  Есть два разных вера реализации
[01:09:56.000 --> 01:09:59.000]  этой файловой системы под Linux.
[01:09:59.000 --> 01:10:02.000]  Старый модуль NTFS, который содержится в ядре
[01:10:02.000 --> 01:10:05.000]  только для чтения,
[01:10:05.000 --> 01:10:08.000]  и NTFS 3G, который позволяет в том числе делать запись,
[01:10:08.000 --> 01:10:11.000]  но, опять же, он разрезан через Fuse.
[01:10:11.000 --> 01:10:14.000]  UnionFS похожий на overlayFS,
[01:10:14.000 --> 01:10:17.000]  но и самая распространенная штука
[01:10:17.000 --> 01:10:20.000]  на базе Fuse, файл системы SSHFS,
[01:10:20.000 --> 01:10:23.000]  который позволяет монтировать
[01:10:23.000 --> 01:10:26.000]  содержимые удаленные машины
[01:10:26.000 --> 01:10:29.000]  используя обычный протокол SSH.
[01:10:29.000 --> 01:10:32.000]  Как это вообще возможно сделать?
[01:10:32.000 --> 01:10:35.000]  Что вы можете сделать с помощью команды SSH?
[01:10:35.000 --> 01:10:38.000]  На удаленном сервере.
[01:10:38.000 --> 01:10:41.000]  Например, SSH localhost.
[01:10:41.000 --> 01:10:44.000]  Я просто лагонюсь.
[01:10:44.000 --> 01:10:47.000]  А еще SSH позволяет указать
[01:10:48.000 --> 01:10:51.000]  Можно ли мы создать какой-то файл
[01:10:51.000 --> 01:10:54.000]  используя команду SSH?
[01:10:54.000 --> 01:10:57.000]  Как это сделать?
[01:11:05.000 --> 01:11:08.000]  Поскольку я использую localhost,
[01:11:08.000 --> 01:11:11.000]  то файл действительно был создан.
[01:11:11.000 --> 01:11:14.000]  Как отправить содержимое?
[01:11:15.000 --> 01:11:18.000]  Файл на удаленном сервере.
[01:11:18.000 --> 01:11:21.000]  Вместо touch, наверное, можно записать.
[01:11:27.000 --> 01:11:30.000]  Романда cat.
[01:11:30.000 --> 01:11:33.000]  Конкатинация.
[01:11:33.000 --> 01:11:36.000]  По умолчанию наберет содержимое
[01:11:36.000 --> 01:11:39.000]  из стандартного потока вывода.
[01:11:39.000 --> 01:11:42.000]  Перенаправим вот так вот файл.
[01:11:43.000 --> 01:11:46.000]  Допустим, у меня есть содержимое
[01:11:46.000 --> 01:11:49.000]  питонского файла.
[01:11:49.000 --> 01:11:52.000]  Содержание этого питонского файла
[01:11:52.000 --> 01:11:55.000]  будет записано в New File Text.
[01:11:55.000 --> 01:11:58.000]  Как работает такая команда, понятно.
[01:11:58.000 --> 01:12:01.000]  На локальной машине я выполняю команду cat.
[01:12:01.000 --> 01:12:04.000]  Которая на стандартный поток вывода.
[01:12:04.000 --> 01:12:07.000]  Выводит содержимое файла по байтам.
[01:12:07.000 --> 01:12:10.000]  Затем это содержимое перенаправляется
[01:12:10.000 --> 01:12:13.000]  в команде ssh, которая на удаленном машине
[01:12:13.000 --> 01:12:16.000]  запускает команду cat,
[01:12:16.000 --> 01:12:19.000]  которая записывает что-то из стандартного
[01:12:19.000 --> 01:12:22.000]  потока ввода в какой-то файл.
[01:12:35.000 --> 01:12:38.000]  Что мы еще можем вытворять с помощью
[01:12:38.000 --> 01:12:41.000]  новой каталоги, изменить атрибуты,
[01:12:41.000 --> 01:12:44.000]  выполнять команду ls,
[01:12:44.000 --> 01:12:47.000]  удалять файлы, получать их содержимое.
[01:12:47.000 --> 01:12:50.000]  На самом деле достаточно всего лишь одного
[01:12:50.000 --> 01:12:53.000]  подключения к серверу,
[01:12:53.000 --> 01:12:56.000]  достаточно всего одного открытого порта по ssh.
[01:12:56.000 --> 01:12:59.000]  Достаточно безопасно, поскольку у нас
[01:12:59.000 --> 01:13:02.000]  шифрование здесь принудительно используется.
[01:13:02.000 --> 01:13:05.000]  Но набирать каждый раз такие команды
[01:13:05.000 --> 01:13:08.000]  наверное не очень удобно.
[01:13:08.000 --> 01:13:11.000]  Что можно сделать?
[01:13:11.000 --> 01:13:14.000]  Можно один раз подмонтировать файловую систему.
[01:13:14.000 --> 01:13:17.000]  Это делается с помощью sshfs,
[01:13:17.000 --> 01:13:20.000]  которая использует протокол ssh
[01:13:20.000 --> 01:13:23.000]  для подключения куда-либо
[01:13:23.000 --> 01:13:26.000]  и отображает содержимое удаленного сервера
[01:13:26.000 --> 01:13:29.000]  на локальной машине в каком-то из каталогов.
[01:13:29.000 --> 01:13:32.000]  На этом все.
[01:13:33.000 --> 01:13:36.000]  Парагон недавно сделал
[01:13:36.000 --> 01:13:39.000]  пенсорсную новую реализацию,
[01:13:39.000 --> 01:13:42.000]  и я подумал,
[01:13:42.000 --> 01:13:45.000]  что это один из вариантов.
[01:13:45.000 --> 01:13:48.000]  Есть ли у вас вопросы?
[01:13:52.000 --> 01:13:55.000]  Что используют?
[01:13:55.000 --> 01:13:58.000]  В Windows Subsystem for Linux
[01:13:58.000 --> 01:14:01.000]  там есть внутреннее хранилище
[01:14:01.000 --> 01:14:04.000]  в Windows, там просто образ.
[01:14:04.000 --> 01:14:07.000]  На счет 11 Windows не знаю,
[01:14:07.000 --> 01:14:10.000]  я ее не трогал.
[01:14:10.000 --> 01:14:13.000]  В 10 это был просто образ.
