[00:00.000 --> 00:12.400]  Сегодня у нас будет отвитвление от наших основных лекций про ядро. Сегодня я больше буду
[00:12.400 --> 00:23.000]  разговаривать про user space, а конкретно про то, как всякие аппаратные исключения, трапы и так
[00:23.000 --> 00:33.480]  далее обрабатываются не в пространстве ядра, а в пространстве пользователей. План такой, в
[00:33.480 --> 00:40.160]  основном я буду разговаривать сегодня про операционную систему Windows, в ней гораздо больше
[00:40.160 --> 00:52.280]  для этого инструментов и я просто про нее гораздо больше знаю, но про POSIX системы мы тоже затронем.
[00:52.280 --> 01:00.560]  И в конце еще поговорим про то, как можно обрабатывать, точнее не как можно, а про то,
[01:00.560 --> 01:07.520]  как устроен механизм исключений в тех языках, в которых он есть. То есть, наверное, в основном
[01:07.520 --> 01:22.200]  тут я буду говорить про C++, но Rust и, наверное, Go тоже во всех этих языках исключения устроены
[01:22.200 --> 01:32.400]  примерно одинаковым образом внутри. Немножко о сути вопроса. Те, кто пользовались Windows,
[01:32.400 --> 01:38.960]  наверное, видели вот такую картинку, такое диалоговое окно при запуске разных программ.
[01:38.960 --> 01:51.200]  Что происходит в программе, когда выскакивает такая ошибка? К ней приводит код примерно
[01:51.200 --> 02:00.960]  вот такого содержания, когда мы пытаемся разыменовать некорректный указатель. Здесь мы
[02:00.960 --> 02:05.760]  пытаемся разыменовать указатель очень маленькой величины, то есть он в первой страничке находится,
[02:05.760 --> 02:13.880]  которая, как правило, по-моему, во всех операционках современных никуда не отмаплена специально,
[02:13.880 --> 02:26.080]  чтобы ловить такие ошибки. И мы пытаемся прочитать значение по некорректному указателю. У нас
[02:26.080 --> 02:36.480]  происходит pageFold и программа завершается. В принципе, здесь не обязательно... Точно такая же ошибка
[02:36.480 --> 02:43.360]  будет выводиться, если мы обратились по правильному указателю, но с неправильным действием. То есть,
[02:43.360 --> 02:48.560]  если у нас, например, страничка только для чтения, а мы попытались сюда что-то записать,
[02:48.560 --> 02:59.320]  вот будет то же самое. Также к подобным ошибкам приводится исполнение привилегированной
[02:59.320 --> 03:08.160]  инструкции, например, in-out в user space или если мы попробуем таблицу гдт загрузить,
[03:08.160 --> 03:17.360]  тоже это будет исполнение привилегированной инструкции. Что еще? Сюда же можно отнести
[03:17.360 --> 03:30.920]  исполнение некорректной инструкции. Тоже выскакивает исключение. Соответственно,
[03:30.920 --> 03:41.720]  вот это вот то, что я в данной лекции называю аппаратными исключениями, через тот же механизм
[03:41.720 --> 03:50.600]  проходит. В принципе, почти все экзепшены, которые мы объявляли ранее в лабораторках,
[03:50.600 --> 04:00.560]  практически все проходят наверх в user space, если операционка это сделала. Есть некоторые
[04:00.560 --> 04:09.440]  исключения, которые обрабатываются особым образом, например, исключение fpu-unit и исключение
[04:09.440 --> 04:15.800]  sse. То есть они, как правило, в тихую там обрабатываются ядром, просто выставляется флаг,
[04:15.800 --> 04:21.400]  что произошло исключение. Если программа захотела его прочитать, она его может прочитать.
[04:21.400 --> 04:38.240]  Нет, почему?
[04:38.240 --> 04:58.800]  По этому адресу загружено, в окрестностях этого адреса загружен код с приложения. То есть здесь
[04:58.800 --> 05:04.600]  видно, что инструкция по этому адресу, то есть да, вот пользовательские адреса в Windows начинаются
[05:04.600 --> 05:19.160]  на 7f, ну точнее на 4.0 7f, и там ядерные адреса начинаются с 4f и так далее. Здесь вполне себе
[05:19.160 --> 05:21.880]  адрес инструкции это валидный.
[05:21.880 --> 05:41.920]  В Windows часть ядра замаплена в user space каждого приложения для того, чтобы оно могло к нему
[05:41.920 --> 06:06.360]  обращаться.
[06:06.920 --> 06:17.560]  Нет, конечно, там замаплена только определенная часть, которой нужно обращаться пользователям.
[06:17.560 --> 06:25.760]  Ну и в принципе, даже если не замаплена, все равно все ядро работает на верхней части
[06:25.760 --> 06:34.160]  адресов и приложениям туда ходить запрещено. Там так исторически устроено. То есть оно не
[06:34.160 --> 06:40.400]  обязательно может быть отмаплено, но вот эти вот верхние адреса, они для приложений недоступны.
[06:40.400 --> 06:53.040]  Там есть такая штука, что вот в 32-битном Windows раньше адресное пространство было поделен
[06:53.040 --> 07:01.280]  пополам, два гигабайта нижних для приложений, два гигабайта верхних для ядра. Виртуальное
[07:01.280 --> 07:11.520]  пространство поделено было. Потом чуть попозже, по-моему, в XP добавили специальный флаг при
[07:11.520 --> 07:18.200]  загрузке, чтобы для ядра выделить только верхний один гигабайт, а для приложений три, то есть чтобы
[07:18.200 --> 07:26.160]  они могли пользоваться по большим количествам памяти. Но это было вынесено во флаг, чтобы
[07:26.160 --> 07:33.520]  обратную совместимость не сломать. Когда появились 64-битные Windows и там все с этим стало
[07:33.520 --> 07:41.440]  чуть попроще, там адресное пространство большое, такой проблемы нет. Но поскольку там 32-битные
[07:41.440 --> 07:49.040]  приложения все равно тоже работают, вот в 64-битной Windows 32-битные приложения все запускаются как
[07:49.040 --> 08:04.880]  будто бы вот с этим флагом, называется slash3gb. Там, я сейчас так точно не помню, там по документации
[08:04.880 --> 08:11.320]  в Квинде было записано, что какими-то битами в указателе можно пользоваться произвольно. Туда
[08:11.320 --> 08:16.840]  можно свои данные записывать, потому что ядро их игнорирует. И вот эта штука, она ломалась,
[08:16.840 --> 08:25.120]  если расширить. По-моему два верхних бита, что ли, или как-то так. Нет, один получается бит,
[08:25.120 --> 08:30.420]  да. Если мы пополам поделили пространство, то один бит можно было использовать. Не знаю,
[08:30.420 --> 08:34.640]  насколько много программ реально это использовало, но вот такое было и,
[08:34.640 --> 08:47.600]  слава богу, сейчас уже это не совсем актуально. Теперь поговорим о том, как обрабатывать такие
[08:47.600 --> 08:55.240]  исключения. То есть в большинстве случаев программам это не требуется. То есть вот такая ситуация,
[08:55.240 --> 09:01.560]  она не должна происходить в нормальной программе, и это в принципе правильно, что операционка
[09:01.560 --> 09:07.400]  просто завершает процесс. Но операционные системы вообще предоставляют механизм для того,
[09:07.400 --> 09:25.240]  чтобы такие ошибки обрабатывать. Начнем с POSIX. В POSIX системах, в Linux, в Unix, во всех них есть
[09:25.240 --> 09:36.080]  специальный механизм, который называется сигналы. Его можно себе представить как обработку сигналов,
[09:36.080 --> 09:40.600]  в принципе можно себе представить как обработку прерываний. То есть у нас исполняется программа,
[09:40.600 --> 09:50.640]  ей можно отправить сигнал. Это может сделать либо ядро операционной системы, либо другие
[09:50.640 --> 09:56.440]  программы тоже могут посылать. Есть особенные сигналы, которые другие программы посылать не
[09:56.440 --> 10:10.480]  могут. В большинстве программ ничего дополнительно делать не нужно. На каждый сигнал есть свой
[10:10.480 --> 10:19.280]  обработчик по умолчанию, который в операционной системе в runtime крутится и исполняет эти сигналы.
[10:19.280 --> 10:27.520]  Но у программиста есть возможность обработку, этот обработчик переопределить. Для этого есть
[10:27.520 --> 10:41.280]  функция POSIX API SigAction. С помощью нее мы можем переопределить или задать обработку разных сигналов.
[10:41.280 --> 10:53.800]  В данном примере мы переопределяем обработку сигнала SigSig. Это тот сигнал, который по умолчанию,
[10:53.800 --> 11:07.200]  если ядро присылает его приложению, то приложение пишет в консоль SegmentationFault и завершается. Я
[11:07.200 --> 11:14.040]  где-то читал, что SegmentationFault это так называлась аппаратная ошибка на какой-то из родных
[11:14.040 --> 11:21.080]  платформ, на которых Unix разрабатывался. Сейчас слово Segmentation не имеет никакого отношения к тому,
[11:21.080 --> 11:30.880]  что за ошибка произошла. Так можно понять, что прилетел сигнал SigSig. Он может прилететь и если
[11:30.880 --> 11:38.160]  неправильное обращение к памяти, и если General Protection произошел, и там еще какие-то есть.
[11:38.160 --> 11:46.160]  Наверное все сейчас не назову. Еще раз?
[11:46.160 --> 12:08.720]  SigSig не уверен, что можно. Можно попробовать. У нас есть индивидуальное задание сделать в
[12:09.080 --> 12:27.760]  обработку сигналов. Это как такой канал IPC. Ядро знает, где у приложения находятся обработчики
[12:27.760 --> 12:35.360]  сигналов, и это все дело проходит через него. Мы отправляем сигнал, говорим, что его нужно отправить
[12:35.360 --> 12:47.600]  вот такому-то процессу. Оно проходит через сискол, и он уже там его отправляет дальше.
[12:47.600 --> 12:57.520]  Ну, значит, а мне некорректный в каком смысле?
[12:57.520 --> 13:17.240]  Я думаю, что там есть какие-то проверки по этому поводу. Я
[13:17.240 --> 13:26.000]  по поводу POSIX подробно не могу сказать. Наверняка на это есть куча статей. Я в основном про Windows.
[13:26.000 --> 13:42.760]  Что будет происходить здесь в процессе выполнения вот этого небольшого куска кода? Мы зарегистрировали
[13:42.760 --> 13:53.120]  обработчик сигналов. Дальше мы попробовали сделать некорректное обращение к памяти.
[13:53.120 --> 14:04.480]  На моменте, где мы вызываем функцию printf, исполнение программы прерывется,
[14:04.480 --> 14:13.920]  мы попадем в обработчик сигналов. Дальше мы можем что-то с этой ошибкой сделать, можем ничего не делать.
[14:13.920 --> 14:24.840]  В принципе, здесь не так много вещей, что мы можем с программой сделать, потому что, ну, даже если мы
[14:24.840 --> 14:32.560]  вернемся из обработчика сигналов так, чтобы программа не завершалась, все равно мы попадем
[14:32.560 --> 14:41.320]  обратно в то же самое место, и нам нужно будет как-то либо исправить этот указатель,
[14:41.320 --> 14:50.320]  либо пропустить инструкцию, которая к нему обращается. Это весьма нетривиально, и я бы сказал,
[14:50.320 --> 15:01.120]  что делать так плохо. Хотя для этого есть механизмы, о которых ближе к концу я расскажу.
[15:01.120 --> 15:18.360]  Теперь Windows. Здесь разработчики Windows пошли чуть дальше и сделали такой более общий
[15:18.360 --> 15:27.880]  механизм для обработки исключений. Он называется structured exception handling и позволяет с помощью вот
[15:27.880 --> 15:37.480]  такой вот конструкции, очень похожей на исключения в C++ сделать обработку, в том числе и аппаратных
[15:37.480 --> 15:44.160]  исключений. То есть что здесь происходит? Мы оборачиваем наш код, в котором, возможно, будет ошибка
[15:44.160 --> 16:00.120]  в блок try и делаем, и вот здесь вот будет записано обработчик этого исключения. Как будет происходить
[16:00.120 --> 16:11.040]  исполнение в данном случае? Мы входим в блок try, происходит исполнение, после этого мы попадаем в
[16:11.040 --> 16:23.040]  функцию filter. Задача этой функции, зная информацию об исключении, здесь во входные параметры будет
[16:23.040 --> 16:31.680]  подан код ошибки, всякие там разные данные, то есть если это access violation, то там будет сказано,
[16:31.680 --> 16:38.800]  там какой был адрес, какой тип доступа, там read-write-execute и так далее. Если это general
[16:38.800 --> 16:50.080]  protection, то там будут тоже какие-то подробности связаны с тем, где это произошло. Задача функции
[16:50.080 --> 16:57.720]  filter просто сказать, хотим мы обработать это исключение или нет. Дальше, если мы сказали,
[16:57.720 --> 17:07.880]  что хотим, мы попадаем в вот этот обработчик и программа продолжает работать дальше,
[17:07.880 --> 17:19.080]  ну то есть мы в блок try уже обратно не возвращаемся. Здесь пока понятно?
[17:28.320 --> 17:44.520]  Да, сейчас я про это скажу. Ну это тот же самый механизм. Ну да, тут по-разному, то есть в
[17:44.520 --> 17:50.520]  Microsoft Compiler это пишется вот так, для пользовательских приложений и для драйверов,
[17:50.520 --> 18:07.120]  по крайней мере в Microsoft Compiler текущем, возможно раньше там были. Да, как в плюсах, можно еще
[18:07.120 --> 18:22.240]  finally поставить. В блок finally мы как бы вернемся в любом случае. Эти блоки можно еще вкладывать друг
[18:22.240 --> 18:36.000]  друга. Теперь, как это все работает. В Windows есть две реализации механизма всех, они используются
[18:36.000 --> 18:43.680]  на разных платформах. Почему так произошло никто не знает, я не сумел найти в интернете. Я сначала
[18:43.680 --> 18:48.440]  думал, что первый механизм был просто придуман раньше, а потом был придуман второй, но судя по
[18:48.440 --> 18:57.840]  всему нет. Оба были придуманы в 91 году. Почему на x86 стали использовать один механизм, а на всех
[18:57.840 --> 19:03.320]  остальных платформах стали использовать другой, не знает даже человек, который в Microsoft
[19:03.320 --> 19:12.280]  Блоге об этом написал. Ну, по крайней мере он так говорит, что он не знает. Да, вот первый
[19:12.280 --> 19:20.400]  механизм, который из таких актуальных, точнее нет. Единственная платформа, на которую используется
[19:20.400 --> 19:30.520]  первый механизм, это 32-бит на x86. Это называется stack-based всех, то есть structured exception
[19:30.520 --> 19:39.080]  handling с использованием стека. И второй механизм называется table-based всех. Он используется на
[19:39.080 --> 19:47.800]  всех остальных платформах, там на 64-битном x86, на обоих армах и на всех исторических архитектурах
[19:47.800 --> 19:58.040]  других он тоже использовался. На мипсе, на PowerPC и на альфе. Я сейчас все это объясню.
[20:17.800 --> 20:26.800]  Ну, если именно про сигналы, то в POSIX они используются не только для обработки
[20:26.800 --> 20:35.200]  аппаратных исключений, но и для реализации, например, общения между программами. Например,
[20:35.200 --> 20:42.000]  можно, например, там есть как минимум два сигнала, это user1 и user2, на которых можно
[20:42.000 --> 20:49.760]  забиндить любые пользовательские действия. То есть удобно из одной программы, бывает,
[20:49.760 --> 20:54.080]  отправить сигнал в другую, для того чтобы что-то ей сообщить таким образом.
[20:54.080 --> 21:19.040]  А если речь идет именно об ошибках, то, ну как минимум, да, хорошо бы вывалиться в
[21:19.040 --> 21:28.280]  отладчик, например, в этот момент или хотя бы stack trace записать, то есть, но в Windows через
[21:28.280 --> 21:36.400]  этот механизм работают, я знаю точно, что некоторые программы пытаются как-то поправить
[21:36.400 --> 21:43.240]  исполнение программы, если вот что-то подобное возникает и не завершаются. Например, пытаются
[21:43.240 --> 21:56.440]  перезагрузить процесс, в котором это произошло. Ну да, то есть, в принципе,
[21:56.440 --> 22:03.440]  использования можно достаточно много всяких разных придумать, но в основном это обработка
[22:03.440 --> 22:16.480]  ошибок. Ну то есть, как правильно сказать, лагирование, да, для того чтобы потом было проще это все отлаживать.
[22:16.480 --> 22:30.120]  Так, два механизма есть, две реализации есть у всех. Сейчас говорим про ту, которая работает на
[22:30.120 --> 22:38.440]  stack, которая уже как бы legacy считается, но она все равно актуальна, потому что Windows это единственная,
[22:38.440 --> 22:44.520]  по-моему, оставшаяся операционка, в которой 32-битные приложения все еще активно используются,
[22:44.520 --> 22:51.960]  несмотря на то, что на 64 бита уже давно все перешли, и он там актуален, этот механизм.
[22:51.960 --> 22:59.920]  Да, потому что если поменять этот механизм, придется пересобирать
[22:59.920 --> 23:07.240]  все программы, и тогда теряется, собственно, идея обратной совместимости, можно что-то сразу на 64 бита пересобрать.
[23:07.240 --> 23:24.200]  Что происходит, когда мы исполняем программу, в которой есть вот этот блок try? Когда мы входим в него,
[23:24.200 --> 23:32.160]  компилятор кладет на stack специальную структуру, которая называется Exception Registration Record.
[23:32.160 --> 23:45.840]  Как он находит то место, куда ему нужно ее положить? Эти структуры должны
[23:45.840 --> 23:54.880]  формировать с собой список, и указатель на первую такую структуру хранится в структуре связанной
[23:54.880 --> 24:04.720]  с потоком, она называется thread environment block или tab. Там много есть всякой полезной информации,
[24:04.720 --> 24:12.080]  например, туда складывается контекст при переключении контекстов, и вот в том числе
[24:12.560 --> 24:23.040]  складываются указатели на Exception Registration Record. Что находится в этой структуре? Там находится
[24:23.040 --> 24:29.360]  указатель на следующую такую структуру, и там находится указатель на специальную функцию,
[24:29.360 --> 24:35.800]  которая называется Exact Handler. Что она делает, я скажу чуть попозже.
[24:35.800 --> 24:51.480]  Так, вот мы вошли в блок try, положили на stack эту структуру, дальше начинаем исполнять код,
[24:51.480 --> 24:58.920]  и когда мы доходим до обращения к неправильному указателю, у нас, естественно, сначала
[24:58.920 --> 25:07.480]  происходит PageFold в ядре. Ядро видит, что PageFold пришел из user space. Это значит,
[25:07.480 --> 25:23.600]  что нужно включать вот этот вот обработку, механизм обработки исключений. Он заходит вот
[25:23.600 --> 25:34.960]  в tab, начинает по порядку перебирать весь этот список, и как он устроен, то есть вложенные
[25:34.960 --> 25:47.800]  внутри себя блоки try, они будут в начало списка добавляться. То есть первым обработка
[25:47.800 --> 25:57.520]  придет в самый вложенный обработчик исключений. Что происходит при переборе? Ядро вызывает
[25:57.520 --> 26:09.400]  функцию Exact Handler. У нее в параметрах, ей передается достаточно много параметров,
[26:09.400 --> 26:17.200]  но там самое главное, это ExceptionRecord, в котором есть ExceptionCode, и еще всякая разная другая
[26:17.200 --> 26:24.800]  информация об исключении. Я там сейчас не буду вдаваться в подробности. Дальше в эту функцию
[26:25.120 --> 26:32.240]  еще попадает информация о том, в каком месте произошло, в каком фрейме произошло это исключение.
[26:32.240 --> 26:41.560]  Контекст, ну то есть контекст как при переключении процессов, то есть там все регистры находятся.
[26:41.560 --> 26:50.360]  И этот Exception Handler, он внутри должен вызвать функцию Filter, чтобы понять, обрабатываем мы
[26:50.360 --> 26:57.400]  исключение здесь или нет. Если мы не обрабатываем здесь исключение, то мы дальше перебираем по
[26:57.400 --> 27:05.000]  списку вот эти вот ExceptionRecord, до тех пор пока не дойдем до того, который все-таки это исключение
[27:05.000 --> 27:13.520]  обработает. Если мы дошли до последнего элемента, в котором все F записаны, то это
[27:13.520 --> 27:22.720]  дефолтный обработчик исключений, и ядро само там обработает его, то есть оно вот выведет то окошечко,
[27:22.720 --> 27:37.000]  которое на третьем слайде я показывал, и завершит программу. Ну естественно, что когда мы
[27:37.000 --> 27:42.360]  вошли в блок try, нам нужно положить структуру на стэка, когда мы из него вышли, нам нужно эту
[27:42.360 --> 27:51.480]  структуру со стэка снять. И в этом и заключается, на самом деле, главный недостаток этого механизма в
[27:51.480 --> 28:00.400]  том, что мы на стэк кладем вот эту структуру, в которой есть ссылка на функцию. И поскольку
[28:00.400 --> 28:09.400]  стэк у нас доступен для записи, то у нас появляется точка, в которой мы можем перезаписать вот эту
[28:09.400 --> 28:19.320]  функцию на что-то, что нам надо, и потом вызвать исключение, которое в принципе не так сложно
[28:19.320 --> 28:26.360]  вызвать. Там достаточно просто некорректную инструкцию исполнить, и вот, пожалуйста, даже не
[28:26.360 --> 28:36.560]  нужно там никаким адресам обращаться, ничего. Этим пользуются злоумышленники и писатели всякого
[28:36.560 --> 28:45.800]  вредоносного ПО. Этот механизм пытались патчить неоднократно, но принципиально вот эту вот
[28:45.800 --> 28:54.480]  проблему с тем, что стэк доступен для записи, без ломания обратной совместимости, исправить не
[28:54.480 --> 29:10.880]  получается. Это вот первый недостаток, связанный с безопасностью, и второй недостаток он связан с
[29:10.880 --> 29:20.040]  тем, что нужна поддержка в компиляторе. То есть здесь вот внутри под этим словом try находится
[29:20.040 --> 29:28.280]  код, который кладет эту структуру на стэк, потом ее нужно снять со стэка. В принципе в проекте ReactOS
[29:28.280 --> 29:39.800]  у нас получилось на Define захачить эту логику, но там мне удалось побороть одну проблему. Это что
[29:39.800 --> 29:53.480]  вот здесь должен быть компиляторный барьер. Да, чтобы компилятор случайно не перемешал,
[29:53.480 --> 30:09.440]  ну чтобы он не вывел инструкцию за блок try. Там все равно есть с этим проблемы, то есть мы можем
[30:09.440 --> 30:19.440]  побороть перепорядочивание того, что внутри try с инструкциями внутри блока try, но, например,
[30:19.440 --> 30:24.920]  если мы обращаемся к каким-то внешним переменным, то там возникают проблемы, они могут быть
[30:24.920 --> 30:38.760]  соптимизированы. Там нормально, эту штуку на Define сделать не получилось. В кланге есть pull
[30:38.760 --> 30:49.680]  request на поддержку вот этого механизма. Там он поддерживается в принципе всех. Ну барьеры понятно там есть,
[30:49.680 --> 31:02.240]  но он пока висит, непонятно что с ним там будет. Требуется поддержка от компилятора, долгое время
[31:02.240 --> 31:12.240]  это все поддерживало стоковым свц. В гцц, где-то в версии 4.8, если я не ошибаюсь, появилась поддержка
[31:12.240 --> 31:24.040]  try-except механизма для 64 битных приложений. И в кланге есть и то и то, но там тоже называется это,
[31:24.040 --> 31:32.160]  что нет поддержки асинхронного всех. По сути это значит, что может произойти перепорядочивание.
[31:32.160 --> 31:45.080]  Они это сделали как-то средствами компилятора, я так досконально не смотрел. Мы проверяли,
[31:45.080 --> 31:51.400]  оно в больших частах случаев работает, но иногда возникает какие-то вещи, и мы смотрим
[31:51.400 --> 32:00.200]  ассемблерный код. Видно, что либо там какой-то барьер не поставлен, либо они переупорядочили
[32:00.200 --> 32:07.920]  инструкции куда-то не туда. Я думал как-нибудь заняться, разобраться в чем там дело. Может быть
[32:07.920 --> 32:16.920]  попробовать написать в рассылку, чтобы они там как-то побыстрее принимали этот патч в кланг,
[32:16.920 --> 32:25.600]  но пока до этого не дошел. Еще один недостаток данного механизма это в том,
[32:25.600 --> 32:32.760]  что у нас есть определенный оверхед даже если исключения не произошло. То есть нам в любом
[32:32.760 --> 32:38.000]  случае нужно выполнить код для того, чтобы положить структуру на стэк и для того,
[32:38.000 --> 32:49.080]  чтобы ее снять, даже если исключения не было. Это в зависимости от того, как Krontime сделал.
[32:49.080 --> 33:02.840]  Это структура связанная с потоком. TreadEnvironmentBlack. Она в ядре хранится,
[33:02.840 --> 33:20.240]  то есть у нас все потоки, ну она хранится в ядре и она отмаплена в сам поток. Ну в принципе да,
[33:20.240 --> 33:27.680]  то есть например еще в этой структуре хранится ссылка на область TreadLocalStorage,
[33:27.680 --> 33:41.880]  то есть данных локальных ток для данного потока. Во втором механизме попытались исправить
[33:41.880 --> 33:50.000]  большинство проблем, которых есть в первом и все-таки из-за этого мне кажется, что скорее всего
[33:50.000 --> 34:05.560]  он был сделан позже, просто нам никто не признается. В table-based exception handling больше
[34:05.560 --> 34:17.960]  не используются операции со стэком и вместо этого информация о том, о вот этих блоках try и accept
[34:17.960 --> 34:25.160]  хранится в специальной секции исполняемого файла. То есть вы наверное знаете, что в Windows
[34:25.160 --> 34:34.880]  используются PE файлы вместо ELF формата и там есть специальная секция, в которой хранится
[34:34.880 --> 34:43.720]  информация о блоках исключений. Я здесь привел пример. Основная там структура называется
[34:43.720 --> 34:49.880]  runtime function. Честно говоря, мне не до конца понятно, почему она называется именно так. Там
[34:49.880 --> 35:01.800]  находится адрес начала блока try, конец этого блока и структура unwindata, я ее не стал здесь
[35:01.800 --> 35:10.200]  на слайде приводить, она достаточно большая. Там по сути находится вся информация, которая нужна
[35:10.200 --> 35:20.920]  вот это вот. То есть там находится ссылка на вот эту функцию accept handler, там находится ссылка на
[35:20.920 --> 35:28.840]  блок finally, если он есть. Там еще есть некоторая информация, которая требуется для обработки
[35:28.840 --> 35:38.360]  исключений и она генерируется компилятором, точнее даже не компилятором, а линковщиком скорее,
[35:38.360 --> 35:53.000]  в процессе генерируемого исполняемого файла. И такой способ избавляет от двух проблем. То есть
[35:53.000 --> 36:05.360]  в первую очередь у нас здесь нет overhead, когда исключения не произошло и все проблемы с
[36:05.360 --> 36:11.560]  безопасностью, которые были со стеком, они здесь тоже уходят, потому что эта секция pdata, она
[36:11.560 --> 36:19.880]  маппится всегда как read-only. То есть когда мы уже загрузили программу, то поменять его нельзя.
[36:19.880 --> 36:34.880]  Как происходит исполнение в случае table-based всех? То есть когда мы входим в блок try, ничего компилятор
[36:34.880 --> 36:42.800]  не делает, то есть вся информация уже записана. Блок accept, он хоть и пишется здесь формально,
[36:42.800 --> 36:49.120]  по факту он находится там где-то в другом месте в программе. Что происходит, когда происходит
[36:49.120 --> 36:55.600]  исключение? Гидро начинает проходить по вот этой вот таблице, которая в pdata находится,
[36:55.600 --> 37:09.520]  находит по очереди все обработчики исключений и точно также их вызывает. Здесь наверное вот
[37:09.520 --> 37:19.160]  один есть минус по сравнению с способом со стеком. Все-таки для того, чтобы перебрать табличку,
[37:19.160 --> 37:25.760]  нужно чуть больше ресурсов, чем для того чтобы пройтись по списку, но разница там не такая
[37:25.760 --> 37:45.400]  большая и она нивелируется гораздо лучше безопасностью. Еще я хотел сказать такую вещь,
[37:45.400 --> 37:55.840]  что хотя этот механизм всех в Windows используется не только в user space, но и в kernel space тоже.
[37:55.840 --> 38:03.440]  Несмотря на то, что это такой момент не особо распространенный, как правило исключения всегда
[38:03.440 --> 38:10.440]  запрещены в ядре, но вот в Windows решили пойти другим путем. Там с помощью этого механизма
[38:10.440 --> 38:18.440]  проверяют в первую очередь валидность указателей, которые пришли из user space. То есть когда нам
[38:18.440 --> 38:25.800]  нужно использовать, когда мы в syscall хотим использовать указатель из user space, мы его никак
[38:25.800 --> 38:33.000]  не проверяем, а просто код который его использует оборачивается вот в этот блок try и вот таким
[38:33.000 --> 38:42.240]  образом обработка исключений происходит, я бы сказал, более красиво что ли с точки зрения программиста.
[38:42.240 --> 39:05.880]  Для этого он там и есть, то есть если мы оборачиваем, если там как происходит,
[39:05.880 --> 39:16.440]  мы оборачиваем этот указатель в блок try, доступ к нему, и дальше делаем все как обычно. И тогда,
[39:16.440 --> 39:22.440]  если у нас это исключение где-то там в обработке page fault возникло, то мы его в exept и обработаем.
[39:22.440 --> 39:32.720]  Нам прислали плохой указатель. Все, возвращаемся с syscall, что вы нам что-то не то прислали. Если бы
[39:33.080 --> 39:38.640]  такого механизма не было, нам бы пришлось иметь отдельную функцию, которую можно вызвать перед
[39:38.640 --> 39:47.200]  этим. По сути мы бы как бы два раза вызывали бы проверку. Одну руками, а вторая бы вызвалась
[39:47.200 --> 40:03.640]  в обработке page fault. В Windows вот сделали таким образом. Еще один есть механизм в Windows для
[40:03.640 --> 40:15.440]  обработки исключений. В какой-то момент, перед разработкой Windows XP очевидно, в Microsoft решили,
[40:15.440 --> 40:21.320]  что механизм всех он недостаточно гибкий, он не позволяет делать некоторые вещи. Например,
[40:21.320 --> 40:30.720]  если у нас в программе есть супер крутой, супер умный обработчик исключений, он там умеет
[40:30.720 --> 40:42.040]  из любой ситуации выходить, но какой-то из библиотек... и этим обработчиком обернута вся
[40:42.040 --> 40:59.000]  программа. Вся программа засунута в блок try. Нет, нужно в мейне можно его написать, чтобы весь
[40:59.000 --> 41:09.480]  остальной код вызывался оттуда. Представим, что у нас есть один большой обработчик, который умеет
[41:09.480 --> 41:18.280]  все. И где-то там в библиотеке, которую мы используем, тоже есть обработчик всех, но программист
[41:18.280 --> 41:26.440]  поленился и решил, что если есть ошибка, мы просто завершаемся. И тогда, поскольку обработчик,
[41:26.440 --> 41:36.040]  который находится в библиотеке, он вложен относительно нашего общего, до него исполнение
[41:36.040 --> 42:00.160]  просто не дойдет. Секил его нельзя переопределить.
[42:00.160 --> 42:24.560]  В сектерме так можно, потому что для этого как раз и нужен секил, потому что если мы вызвали сектерм,
[42:24.560 --> 42:36.080]  программа все не завершается. Значит, она там либо зависла, либо решила, что нужно пропустить
[42:36.080 --> 42:40.960]  этот сигнал. И тогда есть секил, который уже нельзя переопределить, и там, безусловно,
[42:40.960 --> 42:52.600]  приложение будет завершаться. Я сейчас расскажу про еще один механизм, который,
[42:52.600 --> 43:07.360]  которым можно выйти из обработчика сигналов куда-то еще. Так, начиная с Windows XP, в Microsoft
[43:07.360 --> 43:16.440]  придумали такую вещь, как Vector Exception Handling. Это как раз больше похоже на сигналы в POSIX.
[43:16.440 --> 43:29.640]  Как это устроено? Этот механизм обрабатывает все исключения, которые происходят в процессе.
[43:29.640 --> 43:39.400]  То есть сначала они попадают в этот обработчик, а потом всех, или наоборот. Я точно не помню.
[43:39.400 --> 43:46.480]  Да, иначе бы смысла в этом не было. Сначала обработка исключений попадает вот в этот механизм,
[43:46.480 --> 43:53.760]  а потом уже всех. Как он работает? Здесь уже не нужна никакая поддержка со стороны компилятора,
[43:53.760 --> 44:00.880]  просто если мы хотим повесить обработчик такого исключения, мы вызываем функцию Add Vector
[44:00.880 --> 44:25.240]  Exception Handler и говорим, что вот это исключение мы хотим обрабатывать. Там есть Call First и,
[44:25.240 --> 44:48.000]  по-моему, типа Default или что-то такое, который его добавит в конец. Да, можно сколько угодно добавить.
[44:48.000 --> 45:02.840]  Там то значение, которое возвращает эта функция, там по нему можно будет потом удалить именно тот обработчик,
[45:02.840 --> 45:12.160]  который нужен. Да, то есть можно добавить сколько угодно обработчиков одного и того же исключения,
[45:12.360 --> 45:19.640]  например, если мы хотим в библиотеке его обработать и в нашей программе, то можно добавить их два. Они
[45:19.640 --> 45:26.600]  будут вызываться по очереди. Собственно отсюда и название Vector Exception Handling, потому что вот они,
[45:26.600 --> 45:46.720]  как бы, мы там проходимся по вектору и вызываем все зарегистрированные обработчики. Ну вот такой
[45:46.720 --> 46:07.480]  механизм, потому что там список может быть и пустой, и не пустой.
[46:17.320 --> 46:24.240]  Тогда получится, что мы можем два раза вызвать обработчик. Один раз мы его вызовем, а второй раз
[46:24.240 --> 46:31.400]  мы его вызовем. Если хочется, чтобы после этого обработчика в случае неудачи вызвался еще вот такой
[46:31.400 --> 46:36.120]  и вот такой, например, то эти два обработчика можно вызвать не подвязывать, а вызвать вручную в конце.
[46:36.120 --> 46:44.760]  А Vector, чтобы можно было не делать ничего вручного, никаких предложений о том, что дальше будет?
[46:44.760 --> 46:59.240]  Да, можно повесить обработчик на все функции. В смысле на все экзепшн и один,
[46:59.240 --> 47:15.400]  который будет там уже дальше сам разруливать. Вроде здесь все. В общем, если зарегистрированы
[47:15.400 --> 47:21.440]  вот эти векторные обработчики, то сначала вызываются они, а потом в дело вступает механизм всех.
[47:21.440 --> 47:35.760]  Теперь немножко про программные исключения. В Windows механизм всех можно использовать и
[47:35.760 --> 47:45.600]  могут использовать и сами программы. Есть функция RaiseException, которая работает таким образом,
[47:45.600 --> 48:00.880]  что мы попадаем в блок экзепт. В POSIX сигналы могут отправлять другие программы, причем можно как
[48:00.880 --> 48:06.800]  самому себе сигнал отправить, так и из другой программы и даже пользователю доступнуть,
[48:07.240 --> 48:17.200]  для того чтобы их отправлять. Также языки, в которых есть встроенная поддержка исключений,
[48:17.200 --> 48:25.400]  могут использовать механизм. Ну, механизм сигналов, наверное, нет, а вот механизм всех используется для
[48:25.400 --> 48:32.320]  того, чтобы в рентах библиотеки реализовать поддержку исключений. То есть, например,
[48:32.320 --> 48:41.280]  в Microsoft библиотеке внутри в качестве бэкэнда для плюсовых исключений используется всех. Тут даже
[48:41.280 --> 48:49.440]  есть одна такая дополнительная возможность, это позволяет в плюсовых обработчиках обрабатывать
[48:49.440 --> 49:11.680]  аппаратные исключения тоже. Ну да, либо по двайнам. В линуксе у KCC по крайней мере
[49:11.680 --> 49:17.680]  runtime используется так называемый frame-based exception handling. Это механизм,
[49:17.680 --> 49:23.340]  очень похожий на table-based всех. То есть, там тоже есть специальная область в эльфнике,
[49:23.340 --> 49:34.440]  в котором записаны блоки try и обработчики исключений для них. И когда происходит исключение runtime,
[49:34.440 --> 49:43.080]  он туда лезет, смотрит, где находится обработчик и туда передает управление. Да,
[49:43.080 --> 49:49.320]  тут там система не участвует. В принципе, KCC же не поддерживает всех на Windows. На Windows
[49:49.320 --> 50:06.400]  он там тот же самый механизм используется, как в Linux. Да, exception нельзя другому процессу послать.
[50:06.400 --> 50:24.480]  Да, для взаимодействия между приложениями и процессами в Windows можно либо общую память
[50:24.480 --> 50:35.160]  использовать, либо оконные сообщения. Но это тоже целый механизм в Windows. Оконные сообщения из
[50:35.160 --> 50:43.400]  Windows. То есть, там любой процесс, даже если у него нет окна, оно не показывается, может создать
[50:43.400 --> 50:52.840]  объект окно, который будет принимать эти сообщения. В mPaint, если окна непосредственно нет,
[50:52.840 --> 51:01.640]  посылать смысла нет, он просто пропустится. Да, там есть зарезервированные значения для
[51:01.640 --> 51:11.440]  пользователей, для программистов, которые можно использовать как хочешь. И еще один есть
[51:11.440 --> 51:20.840]  механизм для обработки исключений. Обычно его реализуют runtime библиотеки, когда ничего другого
[51:20.840 --> 51:32.360]  реализовать нельзя. Это использование функций setJump и longJump из C. Эти две функции позволяют
[51:32.360 --> 51:42.760]  сделать глобальный go-to. Когда мы сначала вызываем setJump, он сохраняет определенный контекст,
[51:42.760 --> 51:48.120]  и потом мы этот контекст можем передать в longJump из любого другого места программы, и мы
[51:48.120 --> 51:56.680]  переместимся туда, где мы вызвали setJump. И вот тут как раз вот этот, точнее не конкретно этот,
[51:56.680 --> 52:03.360]  а подобный этому механизм можно использовать для того, чтобы из сигналов по сексовых перемещаться
[52:03.360 --> 52:10.520]  в какую-то другую область программы. Только для этого там есть специальные функции, они называются setSigJump
[52:10.520 --> 52:20.640]  и SigLongJump или longSigJump, не помню точно. В общем специальные версии этих функций для сигналов,
[52:20.640 --> 52:28.160]  потому что в по сексе по стандарту небезопасно вызывать setJump и longJump из обработчик сигналов.
[52:28.160 --> 52:37.520]  У меня сегодня все.
