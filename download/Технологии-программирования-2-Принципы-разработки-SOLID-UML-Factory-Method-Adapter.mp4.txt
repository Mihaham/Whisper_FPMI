[00:00.000 --> 00:08.000]  Всем доброго вечера! Мы с вами продолжаем курс лекций по технологиям программирования.
[00:08.000 --> 00:15.000]  Сегодня у нас будет первая более конструктивная лекция, нежели чем подная.
[00:15.000 --> 00:22.000]  У меня есть два организационных объявления, которые необходимо запомнить.
[00:22.000 --> 00:27.000]  Кто еще не зарегистрировался в систему?
[00:27.000 --> 00:32.000]  Надо зайти в наш замечательный чат, заполнить форму.
[00:32.000 --> 00:36.000]  Там придут два логина.
[00:36.000 --> 00:41.000]  Первый логин – это замечательный сайт, который называется Ahcheck.
[00:41.000 --> 00:44.000]  Будьте здоровы!
[00:44.000 --> 00:48.000]  Надо будет его переименовать на AppShift.
[00:48.000 --> 00:51.000]  Или логотипом его сделать, мне нравится.
[00:51.000 --> 00:55.000]  Второй – это NakedLab, через который будут сдаваться домашние задания.
[00:55.000 --> 00:58.000]  Сразу скажу.
[00:58.000 --> 01:01.000]  Ищите, если что, в папке spam.
[01:01.000 --> 01:08.000]  Если у кого-то права сюда не придут, но вы уверены, что заполняли форму,
[01:08.000 --> 01:10.000]  можете использовать следующую вещь.
[01:10.000 --> 01:13.000]  Там есть формочка «Восстановить пароль».
[01:13.000 --> 01:18.000]  По почте можно восстановить пароль и узнать свой логин.
[01:19.000 --> 01:23.000]  Придут креды для восстановления всего.
[01:23.000 --> 01:26.000]  И второе – у нас будет первое техническое задание.
[01:26.000 --> 01:29.000]  На самом деле оно будет нулевое тестовое.
[01:29.000 --> 01:32.000]  Мы его подготовим к концу недели.
[01:32.000 --> 01:35.000]  Там нужна на сайте одна техническая вещь.
[01:35.000 --> 01:38.000]  Вы должны узнать, кто у вас будет проверять задание.
[01:38.000 --> 01:43.000]  Это пока что в системе есть, но она на фронт-энде еще не реализована.
[01:44.000 --> 01:48.000]  Так, есть вопросы по организации?
[01:48.000 --> 01:51.000]  Какие-нибудь?
[01:51.000 --> 01:54.000]  Тишина.
[01:54.000 --> 01:57.000]  Паника, давайте вспоминать, что мы узнали с вами в прошлый раз.
[02:03.000 --> 02:06.000]  Я что-то ничего не слышал.
[02:06.000 --> 02:09.000]  Что такое?
[02:10.000 --> 02:15.000]  На самом деле мы с вами не говорили про то, что такое паттерн и атипаттерн,
[02:15.000 --> 02:18.000]  потому что мы будем сегодня про это говорить.
[02:18.000 --> 02:21.000]  Да, хорошо.
[02:21.000 --> 02:24.000]  Что мы узнали про проектирование?
[02:31.000 --> 02:34.000]  Что?
[02:34.000 --> 02:37.000]  Да, мы узнали с вами, что такое закон Диметры.
[02:37.000 --> 02:41.000]  Мы с вами поняли, что такое каплинг и что такое кахежим,
[02:41.000 --> 02:44.000]  и какие связи именно есть между ними.
[02:44.000 --> 02:47.000]  И поняли, какие могут быть наметки на то,
[02:47.000 --> 02:50.000]  что наша архитектура хорошая или не очень.
[02:50.000 --> 02:53.000]  Вот эти аспекты мы с вами посмотрели,
[02:53.000 --> 02:56.000]  но вообще, как некоторые люди выразились, была вода.
[02:56.000 --> 02:59.000]  Сегодня будет воды меньше,
[02:59.000 --> 03:02.000]  и мы с вами начнем разговаривать про технические вещи.
[03:02.000 --> 03:05.000]  Значит, мы с вами узнали про критерии хорошей архитектуры
[03:05.000 --> 03:08.000]  и с вами заботили за закон Диметры.
[03:08.000 --> 03:11.000]  Значит, план на сегодняшнее занятие
[03:11.000 --> 03:14.000]  это разобрать вот эти все аббревиатуры.
[03:14.000 --> 03:18.000]  Вот. Плюс еще узнать, какие существуют паттерны и атипаттерны.
[03:18.000 --> 03:21.000]  Начнем мы с вами тоже про них говорить
[03:21.000 --> 03:24.000]  и посмотрим про хорошие и плохие примеры.
[03:24.000 --> 03:27.000]  Так, значит, смотрите. Поехали.
[03:27.000 --> 03:30.000]  Солид. Это, по-хорошему говоря,
[03:30.000 --> 03:33.000]  такая надстройка над ООП,
[03:33.000 --> 03:36.000]  которая позволяет, так или иначе,
[03:36.000 --> 03:39.000]  сохранять хорошую архитектуру.
[03:39.000 --> 03:42.000]  То есть, если мы будем
[03:42.000 --> 03:45.000]  использовать эти принципы,
[03:45.000 --> 03:48.000]  то мы с вами обезопасим себя
[03:48.000 --> 03:51.000]  от выстрелов в ногу при дальнейшем рефакторинге
[03:51.000 --> 03:54.000]  либо при дальнейшем расширяемости архитектуры.
[03:54.000 --> 03:57.000]  Мы же хотим с вами, чтобы у нас архитектура была расширяемой
[03:57.000 --> 04:00.000]  по количеству кода и всякого такого кода.
[04:01.000 --> 04:04.000]  Смотрите. Солид это на самом деле
[04:04.000 --> 04:07.000]  пять букв. Это абревиатура.
[04:07.000 --> 04:10.000]  Она включает в себя пять принципов.
[04:10.000 --> 04:13.000]  Давайте перечислять их. Первый принцип
[04:13.000 --> 04:16.000]  это сингл респонсибилити принцип.
[04:23.000 --> 04:26.000]  Нет, не получится.
[04:26.000 --> 04:29.000]  Это последний уровень.
[04:29.000 --> 04:32.000]  Сингл респонсибилити принцип.
[04:32.000 --> 04:35.000]  Давайте подумаем.
[04:35.000 --> 04:38.000]  Есть ли наметки на то, что это такое?
[04:45.000 --> 04:48.000]  Приблизительно так.
[04:48.000 --> 04:51.000]  Второй принцип.
[04:51.000 --> 04:54.000]  Open-closed принцип.
[04:54.000 --> 04:57.000]  Что-то открыто, что-то закрыто.
[04:57.000 --> 05:00.000]  Тоже разберем.
[05:00.000 --> 05:03.000]  Третье это принцип замены Лисков.
[05:03.000 --> 05:06.000]  Это Барбара Лисков.
[05:06.000 --> 05:09.000]  Пожалуйста, не склоняйте эту фамилию.
[05:09.000 --> 05:12.000]  Напоминаю правила русского языка.
[05:12.000 --> 05:15.000]  Иностранные фамилии женского рода не склоняются.
[05:15.000 --> 05:18.000]  Это женщина.
[05:18.000 --> 05:21.000]  Четвертое это интерфейс segregation principle.
[05:21.000 --> 05:24.000]  Принцип разделения интерфейсов.
[05:24.000 --> 05:27.000]  Это dependency inversion.
[05:27.000 --> 05:30.000]  Принцип обращения зависимости.
[05:30.000 --> 05:33.000]  Сегодня мы эти пять штук разберем.
[05:33.000 --> 05:36.000]  Я нашел статью на хабре,
[05:36.000 --> 05:39.000]  на которой это все пояснено в виде картиночек.
[05:39.000 --> 05:42.000]  Поэтому мы с вами будем смотреть на картиночки.
[05:42.000 --> 05:45.000]  Мне кажется, это будет более интуитивно.
[05:45.000 --> 05:48.000]  Некоторые паттерны мы с вами разберем.
[05:48.000 --> 05:51.000]  У нас будут примеры паттернов,
[05:51.000 --> 05:54.000]  у которых есть те или иные принципы.
[05:54.000 --> 05:57.000]  Что, поехали?
[05:57.000 --> 06:00.000]  Первый принцип, который у нас есть,
[06:00.000 --> 06:03.000]  это single responsibility principle.
[06:03.000 --> 06:06.000]  В нем суть состоит в следующем.
[06:06.000 --> 06:09.000]  Один класс играет всегда одну роль.
[06:09.000 --> 06:12.000]  Тут есть картинка с роботом,
[06:12.000 --> 06:15.000]  которая говорит, я повар, садовник, маляр и водитель.
[06:15.000 --> 06:18.000]  Справа у нас этот замечательный робот,
[06:18.000 --> 06:21.000]  который представляет собой класс разбин на четыре роли.
[06:21.000 --> 06:24.000]  Он повар, я садовник, я маляр, я водитель.
[06:24.000 --> 06:27.000]  Наверное, вы сталкивались с мемом
[06:27.000 --> 06:30.000]  под названием тыж-программист.
[06:30.000 --> 06:33.000]  Да, ну вот.
[06:33.000 --> 06:36.000]  Да, в общем, тыж-программист
[06:36.000 --> 06:39.000]  нарушает принципы единой ответственности.
[06:39.000 --> 06:42.000]  Вы сами понимаете, хотя по факту наш курс
[06:42.000 --> 06:45.000]  предназначен для того, чтобы вы научились
[06:45.000 --> 06:48.000]  использовать этот принцип в самом себе.
[06:48.000 --> 06:51.000]  Чтобы мы выполняли разные ответственности.
[06:51.000 --> 06:54.000]  Смотрите.
[06:54.000 --> 06:57.000]  У этого принципа всегда есть разные примеры.
[06:57.000 --> 07:00.000]  Значит, он называет, один класс играет одну роль,
[07:00.000 --> 07:03.000]  один класс выполняет одну функцию.
[07:03.000 --> 07:06.000]  Но если мы будем переводить это
[07:06.000 --> 07:09.000]  с точки зрения классического ВВТ,
[07:09.000 --> 07:12.000]  то один класс выполняет одну функцию.
[07:12.000 --> 07:15.000]  У каждого класса должен быть один метод.
[07:15.000 --> 07:18.000]  Да, но это неправда.
[07:18.000 --> 07:21.000]  Функцию с точки зрения того,
[07:21.000 --> 07:24.000]  что он именно должен делать.
[07:24.000 --> 07:27.000]  Смотрите, давайте подумаем.
[07:27.000 --> 07:30.000]  Вот у нас был cohesion и coupling,
[07:30.000 --> 07:33.000]  что позволяет осуществить
[07:33.000 --> 07:36.000]  single responsibility principle.
[07:36.000 --> 07:39.000]  Да, это по факту пример high cohesion.
[07:39.000 --> 07:42.000]  Потому что у нас есть четыре отдельных класса,
[07:42.000 --> 07:45.000]  по факту четыре отдельных роли,
[07:45.000 --> 07:48.000]  которые могут быть между собой не связаны.
[07:48.000 --> 07:51.000]  Да?
[07:51.000 --> 07:54.000]  Я не знаю, если вы представите это все дело как граф,
[07:54.000 --> 07:57.000]  то есть у нас есть
[07:57.000 --> 08:00.000]  граф на четырех вершинах,
[08:00.000 --> 08:03.000]  у нас с вами есть связи между объектами.
[08:03.000 --> 08:06.000]  Каждый из этих связей
[08:06.000 --> 08:09.000]  выполняет какую-то сущность,
[08:09.000 --> 08:12.000]  тут сущности, тут сущности,
[08:12.000 --> 08:15.000]  а здесь связи какие-то слабые.
[08:15.000 --> 08:18.000]  Да, то нелогично, чтобы эти все сущности попадали в один класс.
[08:18.000 --> 08:21.000]  Вот.
[08:21.000 --> 08:24.000]  И мы как раз в следующий раз будем с вами говорить
[08:24.000 --> 08:27.000]  про UML диаграммы,
[08:27.000 --> 08:30.000]  и при помощи UML диаграмм это можно будет легко отследить.
[08:30.000 --> 08:33.000]  Так, вопросы по вот этому принципу?
[08:34.000 --> 08:37.000]  Опять же, можете придумать...
[08:37.000 --> 08:40.000]  Тут нельзя сказать, что есть хороший пример,
[08:40.000 --> 08:43.000]  можно придумать антипример.
[08:43.000 --> 08:46.000]  Помните в прошлый раз пример с университетом?
[08:46.000 --> 08:49.000]  У нас был большой университет,
[08:49.000 --> 08:52.000]  который выполнял много всего.
[08:52.000 --> 08:55.000]  Да, вот это антипример,
[08:55.000 --> 08:58.000]  Single Responsibility Principle.
[08:58.000 --> 09:01.000]  Да, да, все, но много и долго.
[09:01.000 --> 09:04.000]  Буква B бюрократия, как говорится.
[09:04.000 --> 09:07.000]  Так.
[09:07.000 --> 09:10.000]  Значит, второй пример,
[09:10.000 --> 09:13.000]  второй принцип, это Open-Close-принцип.
[09:13.000 --> 09:16.000]  Значит, в чем он говорит?
[09:16.000 --> 09:19.000]  Он говорит, что класс должен быть открыт для расширения,
[09:19.000 --> 09:22.000]  но закрыт для модификации.
[09:22.000 --> 09:25.000]  По факту, если мы с вами будем переводить на русский язык,
[09:25.000 --> 09:28.000]  это означает следующее, что если вы написали какой-то класс,
[09:28.000 --> 09:31.000]  если вы хотите поменять какую-то функциональность,
[09:31.000 --> 09:34.000]  пожалуйста, не меняйте в нем код.
[09:34.000 --> 09:37.000]  Старайтесь сделать свою архитектуру так,
[09:37.000 --> 09:40.000]  чтобы можно было отнаследоваться от этого класса
[09:40.000 --> 09:43.000]  для того, чтобы реализовать новый функционал.
[09:43.000 --> 09:46.000]  Все понимают, что такое наследование?
[09:46.000 --> 09:49.000]  Или есть те, кто не знает, что такое наследование?
[09:49.000 --> 09:52.000]  Ну...
[09:52.000 --> 09:55.000]  Ну, хорошо.
[09:55.000 --> 09:58.000]  Смотрите, робот такой, что...
[09:58.000 --> 10:01.000]  Ну, пример робота на картинке, что мы с вами видим.
[10:01.000 --> 10:04.000]  Робот умел резать что-то.
[10:04.000 --> 10:07.000]  Мы представим себе...
[10:07.000 --> 10:10.000]  Хлеб он резать умел.
[10:10.000 --> 10:13.000]  Значит, для того, чтобы он научился красть,
[10:13.000 --> 10:16.000]  его нужно отправить на техобслуживание,
[10:16.000 --> 10:19.000]  по факту изменить код, для того, чтобы он научился красть.
[10:19.000 --> 10:22.000]  А теперь представьте себе, что у нас был робот версии X,
[10:22.000 --> 10:25.000]  и мы с вами делаем версию X плюс 1,
[10:25.000 --> 10:28.000]  у которой просто, помимо текущего функционала,
[10:28.000 --> 10:31.000]  добавляется еще один функционал.
[10:31.000 --> 10:34.000]  То есть мы с вами расширили функционал,
[10:34.000 --> 10:37.000]  и этот робот теперь умеет еще и красить.
[10:37.000 --> 10:40.000]  Примеры опять же мы с вами увидим.
[10:40.000 --> 10:43.000]  Они достаточно элегантные,
[10:43.000 --> 10:46.000]  поэтому тоже немножечко забежим вперед.
[10:46.000 --> 10:49.000]  В будущем посмотрим примером.
[10:49.000 --> 10:52.000]  Понятен ли этот принцип?
[10:52.000 --> 10:55.000]  Если вы хотите в классе что-то поменять в коде,
[10:55.000 --> 10:58.000]  подумайте, а может вам нужно сделать наследника,
[10:58.000 --> 11:01.000]  который меняет этот функционал.
[11:10.000 --> 11:13.000]  Не совсем.
[11:13.000 --> 11:16.000]  Эти принципы сильно похожи,
[11:16.000 --> 11:19.000]  а функциональность с точки зрения определенного человека.
[11:19.000 --> 11:22.000]  Допустим, у нас был человек,
[11:22.000 --> 11:25.000]  который выполнял роль X,
[11:25.000 --> 11:28.000]  допустим, замерял температуру,
[11:28.000 --> 11:31.000]  но в принципе он может еще и повысить температуру
[11:31.000 --> 11:34.000]  какого-то объекта.
[11:34.000 --> 11:37.000]  У него цель работа с объектом, который
[11:37.000 --> 11:40.000]  по факту связан с температурой.
[11:40.000 --> 11:43.000]  Он работает в одной области, это замечательно.
[11:43.000 --> 11:46.000]  Да, резать и красть это все-таки разные домена.
[11:46.000 --> 11:49.000]  Это хорошее замечание.
[11:49.000 --> 11:52.000]  Возможно, что если у нас есть базовые функции,
[11:52.000 --> 11:55.000]  нам надо наплодить, допустим, пример,
[11:55.000 --> 11:58.000]  несколько локализаций сделать.
[11:58.000 --> 12:01.000]  Локализация – это перевод на другие языки.
[12:01.000 --> 12:04.000]  То мы в принципе с вами можем подготовить некоторые шаблоны,
[12:04.000 --> 12:07.000]  а потом сделать наследники,
[12:07.000 --> 12:10.000]  где в каждом из шаблонов реализовать определенный язык.
[12:10.000 --> 12:13.000]  На русский язык, на французский, на английский, на китайский и так далее.
[12:13.000 --> 12:16.000]  Нет.
[12:16.000 --> 12:19.000]  Делать отдельных наследников.
[12:19.000 --> 12:22.000]  Так.
[12:22.000 --> 12:25.000]  По этой штуке понятно?
[12:25.000 --> 12:28.000]  Угу.
[12:28.000 --> 12:31.000]  Хорошо.
[12:31.000 --> 12:34.000]  Следующий паттер.
[12:34.000 --> 12:37.000]  Следующий принцип замены барбаралисков.
[12:37.000 --> 12:40.000]  Причем он заключается.
[12:40.000 --> 12:43.000]  Представим себе, что у нас есть класс B,
[12:43.000 --> 12:46.000]  который наследуется от класса A.
[12:46.000 --> 12:49.000]  Говорим следующее.
[12:49.000 --> 12:52.000]  Если мы хотим заменить A на B,
[12:52.000 --> 12:55.000]  то он не сломает логику функционала.
[12:55.000 --> 12:58.000]  То есть это принцип замены типов.
[12:58.000 --> 13:01.000]  Представим себе вот такую картинку.
[13:01.000 --> 13:04.000]  Представим себе, что у нас есть Бористо,
[13:04.000 --> 13:07.000]  который называется поколением.
[13:07.000 --> 13:10.000]  И отец говорит,
[13:10.000 --> 13:13.000]  сделаем кофе.
[13:13.000 --> 13:16.000]  Тот говорит, давайте, я делал своих, мне сын сделает.
[13:16.000 --> 13:19.000]  А сын не понимает, как делать кофе.
[13:19.000 --> 13:22.000]  То есть он начинает делать какие-то действия,
[13:22.000 --> 13:25.000]  и оказывается, что эти действия не делают кофе.
[13:25.000 --> 13:28.000]  Такое может быть.
[13:28.000 --> 13:31.000]  Что-то перепуталось.
[13:31.000 --> 13:34.000]  Я вычитал интересный пример.
[13:34.000 --> 13:37.000]  Интересное следующее.
[13:37.000 --> 13:40.000]  Знаете утки? Животные такие есть.
[13:40.000 --> 13:43.000]  А теперь представьте, утка квакает,
[13:43.000 --> 13:46.000]  утка крякает, утка летает.
[13:46.000 --> 13:49.000]  Кажется, что это утка.
[13:49.000 --> 13:52.000]  Но прикол в том,
[13:52.000 --> 13:55.000]  что утки есть замечательный наследник.
[13:55.000 --> 13:58.000]  Если...
[13:58.000 --> 14:01.000]  Дак.
[14:01.000 --> 14:04.000]  А это наследник класса.
[14:04.000 --> 14:07.000]  А у нее может быть следующий.
[14:07.000 --> 14:10.000]  Класс.
[14:10.000 --> 14:13.000]  Давайте я назову фейк дак.
[14:13.000 --> 14:16.000]  Знаете, есть такие газетные утки.
[14:16.000 --> 14:19.000]  Образно.
[14:19.000 --> 14:22.000]  Это же утка.
[14:22.000 --> 14:25.000]  Только проблема в том, что она кричит,
[14:25.000 --> 14:28.000]  квакает фейковыми новостями,
[14:28.000 --> 14:31.000]  летит там, не знаю, по телеге какой-нибудь,
[14:31.000 --> 14:34.000]  либо еще по другим мессенджерам.
[14:34.000 --> 14:37.000]  А плавать я не знаю. Она не умеет.
[14:37.000 --> 14:40.000]  Да, мы пишем, утка, пожалуйста, прилетит туда-то,
[14:40.000 --> 14:43.000]  прокрякает вот, а потом отплыви обратно.
[14:43.000 --> 14:46.000]  Значит, фейк распространяется, да.
[14:46.000 --> 14:49.000]  То есть, фейк куда-то летит, фейк распространяется,
[14:49.000 --> 14:52.000]  а уплыть он никуда не может. Просто некуда.
[14:52.000 --> 14:55.000]  А утка там на батарейках, которые...
[14:55.000 --> 14:58.000]  То есть, мы ее зарядить забыли, и все, у нее энергия закончилась.
[14:58.000 --> 15:01.000]  Вот такой принцип.
[15:04.000 --> 15:07.000]  То есть, и на этом основаны всякие интерфейсные штуки.
[15:07.000 --> 15:10.000]  То есть, если у нас есть интерфейс...
[15:10.000 --> 15:13.000]  Я сейчас, кстати, проговорю про то, что такое интерфейс.
[15:13.000 --> 15:16.000]  Представьте, у нас есть...
[15:16.000 --> 15:19.000]  Ну, давайте сейчас пока подоверим абстрактный класс.
[15:19.000 --> 15:22.000]  А потом, если у нас с вами нарушается принцип Барбары Лисков,
[15:22.000 --> 15:25.000]  то, скорее всего, у нас где-нибудь возникнет следующая вещь.
[15:25.000 --> 15:28.000]  Ив с костылем, либо у нас пойдет какой-нибудь динамик каст.
[15:28.000 --> 15:31.000]  Да? Чем плох динамик каст?
[15:31.000 --> 15:34.000]  Ладно, долгий.
[15:34.000 --> 15:37.000]  Но вам придется именно писать косты для определенного подкласса.
[15:37.000 --> 15:40.000]  Да, это не очень хорошо.
[15:40.000 --> 15:43.000]  Да, это не очень хорошо.
[15:43.000 --> 15:46.000]  Да, это не очень хорошо.
[15:46.000 --> 15:49.000]  Вот, это как выявить нарушение принципа Барбары Лисков.
[15:49.000 --> 15:52.000]  Это значит, что нам надо архитектуру менять нашего приложения.
[15:52.000 --> 15:55.000]  А если у нас...
[15:55.000 --> 15:58.000]  Ага.
[15:58.000 --> 16:01.000]  Да, да, это принцип нарушения Барбары Лисков, это классический пример.
[16:01.000 --> 16:04.000]  Нарушение принципа, и это надо как-то обрабатывать в отдельном случае.
[16:04.000 --> 16:09.000]  То есть, опять же говорю, надо стараться предотвратить нарушения принципа Барбары Лисков.
[16:09.000 --> 16:12.000]  Если у нас есть допустимый каст,
[16:12.000 --> 16:24.580]  то мы можем shelf-
[16:24.580 --> 16:29.380]  то есть опять же говорю, что надо стараться придерживать всех этих
[16:29.380 --> 16:36.100]  концепций, но не стараться при этом им идти как по догмю.
[16:37.420 --> 16:45.460]  Пример эллипса и пример окружности. У нас есть эллипс, у нас есть окружность, да?
[16:45.460 --> 16:51.940]  Окружность это частный случай эллипса, но если мы заменим окружность на эллипс,
[16:51.940 --> 16:58.020]  то у нас скорее всего всякий функционал просто поломается, потому что у эллипса что там есть?
[16:58.020 --> 17:04.020]  Ну периметр, стяжение, большая и малая полуосикс, энтриситет и ежесними понятия.
[17:04.020 --> 17:10.300]  Да и более того, я вот в одном проекте нахожусь, в котором вы не поверите,
[17:10.300 --> 17:16.220]  функциональность там, грубо говоря, космические объекты, есть орбиты,
[17:16.300 --> 17:23.060]  есть круговые орбиты, есть эллиптические орбиты. И там чуть-чуть поменять круг на эллипс,
[17:23.060 --> 17:28.540]  чуть-чуть, там, энцентриситет чуть поменять, там вообще траектория объекта сильно меняется,
[17:28.540 --> 17:32.900]  то есть это там баг критический, то есть нужно работать либо в режиме связанных с эллипсом,
[17:32.900 --> 17:40.940]  либо в примере связанном с кругом. Вот, это косяк, который надо уметь обрабатывать.
[17:40.940 --> 17:48.860]  Так, хорошо, понятен принцип Лисков?
[17:48.860 --> 18:06.460]  Так, хорошо, вопрос. По логике да, но надо делать это грамотно. Возможно, что это нужно делать...
[18:06.460 --> 18:15.380]  Да, возможно, это нужно через какие-то интерфейсы делать отдельно. Я сейчас как раз буду говорить про то,
[18:15.380 --> 18:21.020]  что такое интерфейс. Ну, это хороший вопрос, подумать как. Значит, смотрите. Наверное,
[18:21.020 --> 18:29.180]  вы все сталкивались с ключевым понятием абстрактный класс, да? Насколько я понимаю,
[18:29.180 --> 18:33.700]  группа 211 должна была столкнуться с понятием интерфейса, поскольку у них была джава.
[18:33.700 --> 18:43.820]  Да? Вопрос остальные, вы знаете, что такое интерфейс или мне рассказать лучше? Да, это на самом деле
[18:43.820 --> 18:50.700]  интерфейс. Вот смотрите, абстрактный класс это по факту шаблон, в котором некоторые методы могут
[18:50.700 --> 18:58.420]  быть не реализованы. Да, по факту. А интерфейс это немножко другая вещь. Это вещь, которая говорит о том,
[18:58.420 --> 19:07.580]  какие роли должны быть присущи данному объекту. Роли. В них нету реализации этих ролей. То есть по
[19:07.580 --> 19:17.060]  факту интерфейс это сущность, у которой прописаны методы. Они являются публичными. Никакой из методов
[19:17.060 --> 19:29.420]  не реализован. И в большей части случаев у нее нету никаких полей. Там будет еще слайд посвящен этому.
[19:29.420 --> 19:40.980]  Сущностно отличается. То есть по факту абстрактный класс это какой-то тимплейт для того, чтобы от него
[19:40.980 --> 19:50.260]  дальше наследовался класс. А интерфейс это больше ролевая вещь. То есть вот примеру. Такой абстрактный
[19:50.260 --> 20:01.700]  класс. Студент это абстрактный класс. А обучающийся это больше про интерфейс. Потому что у обучающегося есть
[20:01.700 --> 20:13.900]  роль какая? Учиться. При этом он может обучаться где? Он может обучаться в УЗе. Он может обучаться,
[20:13.900 --> 20:19.980]  я не знаю, на ютубе на курсах. Может обучаться в школе. Может обучаться еще на курсах профессиональной
[20:19.980 --> 20:30.060]  переподготовки. И вот в джаве особенность в том, что она не шена замечательной вещью. А именно множественного
[20:30.060 --> 20:40.140]  наследования. В джаве нет множественного наследования. Живите теперь с этим. Вот. А чем он заменяется?
[20:40.140 --> 20:48.540]  Он заменяется принципом разделения интерфейсов. Значит смотрите. Суть в чем? Суть этого принципа
[20:48.540 --> 20:53.740]  заключается в следующем. Что не надо ставить клиента в зависимости от методов, которые он не
[20:53.740 --> 21:00.260]  использует. То есть старайтесь сделать так, чтобы если у вас есть какой-то объект, какой-то экземпляр
[21:00.260 --> 21:07.980]  класса, какой-то класс, а если у вас нету каких-то ролей, которые он не должен исполнять, выкидывайте
[21:07.980 --> 21:16.260]  их. То есть по идее, я не знаю, пример там зарядник, зарядка. Там написано на самом деле, если внимательно
[21:16.260 --> 21:23.740]  посмотреть презентацию, что он там должен делать. Он выполняет три роли. Вот почему бы эти три роли не
[21:23.740 --> 21:32.020]  разбить на три отдельных интерфейса? И тогда мы сможем сказать, что наш объект будет реализовывать
[21:32.020 --> 21:42.220]  те или иные интерфейсы. Да, тут еще сущность в том, что эта вещь не говорит, мы не наследуем интерфейс,
[21:42.220 --> 21:49.980]  мы реализуем интерфейс. То есть функция Implements. И классический пример, который здесь можно привести,
[21:49.980 --> 21:56.140]  это Java. Собственно про нее мы и говорили. Здесь нет множества наследований, здесь есть наследование
[21:56.140 --> 22:02.860]  определенного класса и, возможно, имплементация некоторых интерфейсов. Значит, те люди, которые
[22:02.860 --> 22:07.700]  внезапно, может быть, в какой-то момент времени читали про Hadoop, это система обработки больших
[22:07.700 --> 22:16.500]  данных. Знают, что есть там замечательный класс под названием IntWritable. И смотрите, какие интерфейсы
[22:16.500 --> 22:24.340]  он реализует. Он реализует интересный интерфейс для того, чтобы в нем было работа. Инты, какие роли есть у
[22:24.340 --> 22:35.940]  Инта? Мы должны сравнивать. Логично? Значит, intWritable должен реализовывать тип comparable. У comparable
[22:35.940 --> 22:42.860]  есть функция compare. Значит, если это у нас writable, это значит, что он должен записывать какие-то данные,
[22:42.860 --> 22:50.500]  поэтому мы имплементируем интерфейс под названием writable. И третий концепт. Возможно, что нам нужно
[22:50.500 --> 22:56.220]  сравнивать эти значения как строки. И тогда мы должны реализовать интерфейс под названием
[22:56.220 --> 23:05.700]  writable comparable. То есть мы с вами наш класс разбили на набор интерфейсов. Вот. И пример такой. Давайте
[23:05.700 --> 23:13.220]  подумаем. Если нам нужен будет только int comparable, то что мы с вами сделаем? Какие нам интерфейсы
[23:13.220 --> 23:27.540]  понадобятся? Из этих трех? Ну, наверное, тот просто comparable. Если нам, допустим, нужен будет какой-нибудь
[23:27.540 --> 23:34.300]  float writable, либо string writable, ну, наверное, там надо подумать, какие интерфейсы нам понадобятся,
[23:34.300 --> 23:41.020]  но в целом суть должна быть такой, что мы просто берем и раскладываем все на максимальное количество
[23:41.020 --> 23:56.900]  интерфейс. Как вы думаете, в чем проблема? Ну, у нас может быть каша из интерфейсов. Огромная. Ну,
[23:56.900 --> 24:09.500]  долго работать это понятно. Ну, классический stack trace на тысячу вызов. Ну, да, в общем,
[24:09.500 --> 24:16.260]  громоздкость кода. Поэтому, на самом деле, я сразу скажу, что про solid надо думать практически в последний
[24:16.260 --> 24:31.820]  момент. Так, понятен ли пример интерфейс segregation principle? Вот какое-то оживление. Что, двигаемся к
[24:31.820 --> 24:43.020]  последнему? Принцип обращения зависимостей. Значит, суть в чем? Тут он сложный. Давайте проговорим
[24:43.020 --> 24:48.740]  сначала. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. То есть, если у нас x
[24:48.740 --> 24:56.100]  зависит от y, то они не должны между собой зависеть именно как один использует напрямую второй. Второй
[24:56.100 --> 25:00.860]  модули должны всегда зависеть от некоторых абстракций. Ну, по факту, от некоторых интерфейсов либо
[25:00.860 --> 25:08.900]  абстрактных классов. Третье, абстракции не должны зависеть от деталей реализации. И четвертое,
[25:08.900 --> 25:15.220]  детали должны зависеть от абстракций. Это самый сложный принцип, поэтому я подготовил к нему примеров.
[25:15.220 --> 25:24.340]  Смотрите, тут замечательный робот, который хочет порезать пиццу. Ровно вот так делать не надо. То
[25:24.340 --> 25:37.340]  есть, не надо к руке присобачивать резолку для пиццы. Почему? Да, она зачастую не нужна. Возможно,
[25:37.340 --> 25:44.060]  надо резать чем-то другим. Тогда, смотрите, что мы делаем. Видели, наверное, протезы заменяемые есть.
[25:44.060 --> 25:49.580]  Мы берем, делаем отверстия для протезы, которые обладают тем или иным интерфейсом. Ну, по факту,
[25:49.580 --> 25:55.700]  для того, чтобы засунуть этот. Ну, представьте, что у нас робот-киборг, которому надо заменить руку.
[25:55.700 --> 26:01.540]  Он берет. Мы готовим отверстия по специальному протоколу. Это протокол, по факту, это интерфейс.
[26:01.540 --> 26:09.180]  И мы подключаемся к определенному интерфейсу. То есть, готовим специально втулки, точнее,
[26:09.180 --> 26:14.700]  определенные резолки. Возможно, что там теннисный мячик, теннисная ракетка будет,
[26:14.700 --> 26:21.180]  которая будет играть в теннис, либо еще что-то. И мы заменяем это все дело на вот такой вот интерфейс.
[26:21.180 --> 26:30.780]  Да, я не знаю, видно тут под мупой этот есть втулка, в которую мы вставляем. То есть, у нас получается
[26:30.780 --> 26:38.780]  легко заменяемость в данном случае. И давайте еще один пример. Вот представьте себе, что у нас
[26:38.780 --> 26:45.660]  есть вот такой вот дерево узлов модулей. Опять же картинка сетасхабра. У нас есть А, дальше у нас
[26:45.660 --> 26:52.620]  идут классы ВС. И, допустим, у нас есть какая-то коровая модель ядра. То есть, у нас есть функция Е,
[26:52.620 --> 27:01.620]  которую вызывают как В, так и С. И проблема в том, что, представьте себе, что нам надо в С изменить
[27:01.620 --> 27:15.100]  функционал Е. Тогда что произойдет, если мы в С попробуем изменить функционал Е? Да, у нас В может
[27:15.100 --> 27:20.940]  сломаться. То есть, у нас В не может работать над Е. Первый вариант, который может быть сделан,
[27:20.940 --> 27:26.900]  это давайте мы создадим типа абстрактный класс, а дальше Е отнаследуем от абстрактного класса,
[27:26.900 --> 27:31.540]  чтобы связать В и С. Но тогда с этим может быть проблема, что когда мы в следующий раз начнем
[27:31.540 --> 27:39.460]  с этим работать, мы не сможем понять, кто главный, С или В. Поэтому делается следующее. Смотрите,
[27:39.460 --> 27:45.340]  мы по факту берем и разворачиваем зависимости. Видите dependency and virtue. То есть, у нас стрелочки
[27:45.340 --> 27:51.020]  идут теперь не в одну сторону, сверху вниз, а есть стрелочка снизу вверх. То есть, мы говорим,
[27:51.020 --> 27:56.540]  для В какой интерфейс нам нужен для того, чтобы работал В, и какой интерфейс нам нужен для того,
[27:56.540 --> 28:03.900]  чтобы работал С. А потом Е по факту будет имплементировать эти интерфейсы. То есть,
[28:03.900 --> 28:12.500]  чтобы и тем, и тем угодить. Таким образом, у нас нижний уровень не зависит от верхней детали.
[28:12.500 --> 28:21.700]  Смотрите, абстракции не зависят от детали, детали не зависят от модулей высшего уровня,
[28:21.700 --> 28:31.580]  а они все взаимодействуют при помощи некоторых абстракций. Красота? Ну да, по крайней мере,
[28:31.580 --> 28:40.180]  жить можно. Вот, в общем, пять принципов у нас есть. Кто-нибудь вспомнит какие? Поехали.
[28:40.180 --> 28:54.260]  Single responsibility. Каждый класс собирает одну роль. Open class. Класс закрыт для модификации,
[28:54.260 --> 29:08.020]  открыт для расширения. L. Это по факту подмена типов не меняет логики. А И? Interface segregation.
[29:08.020 --> 29:12.140]  Стараемся развивать максимально все на интерфейсе, если что, выкидываем имплементацию интерфейса.
[29:12.140 --> 29:24.140]  Independence-inversion. Вопросы по солиду? Да, в данном случае, да.
[29:24.140 --> 29:49.380]  Какой из них? Да. Ну, то есть, следует ставить за клиент зависимости от методов, которые он не использует.
[29:49.380 --> 29:54.540]  Лучше это делать через интерфейс, чтобы, если что, выкинуть имплементацию интерфейса.
[29:54.540 --> 30:04.620]  Да, если что, презентацию уже на Google Drive должно быть. Может смотреть. Что, движемся дальше?
[30:04.620 --> 30:26.620]  Я гни. Расшифровка этой аббревиатуры. Знаете какая? You ain't wanna need it. Вам этого не надо.
[30:26.620 --> 30:41.940]  Смотрите, из такой вещи, представьте себе, мы хотим, опять же, мы с вами про фиксики говорили.
[30:41.940 --> 30:49.340]  Мы с вами говорим про фиксики. Мы с вами компания по созданию фиксиков. Ну, образы по фиксикам.
[30:50.340 --> 31:02.340]  Ну, и давайте вы сейчас кто-нибудь начнет перечислять функционал. Давайте. Что мы должны сделать в этом?
[31:02.340 --> 31:10.340]  Ну вот, представим себе, что у нас сегодня очень все активны и предложили 150 идей.
[31:10.340 --> 31:17.340]  Датчик движения, голосовой ассистент, виртуальная реальность, что-то еще.
[31:17.340 --> 31:22.340]  Мета-вселенная, про которую мы тоже с вами говорили, фиксика-вселенная.
[31:22.340 --> 31:31.340]  Это называется брейн-шторм. Ну, образно говоря, когда мы все выкидываем идеи, мы все их записываем на доску.
[31:31.340 --> 31:36.340]  А дальше нам нужно отсечь лишнее, то, чего нам не надо.
[31:36.340 --> 31:42.340]  На самом деле, если говорить про составление технической документации или технических требований,
[31:42.340 --> 31:48.340]  есть такое, я не помню сейчас, как называется, продукт-реквайерменс, специальный документ, требование к продукту.
[31:48.340 --> 31:53.340]  Этот документ нужен для того, чтобы, если ваш мой дядя-начальник пришел и сказал,
[31:53.340 --> 32:02.340]  я хочу, чтобы у меня пони радугой, единороги радугой кое-что делали, чтобы сказать,
[32:02.340 --> 32:07.340]  так, чувак, у нас в требованиях документов прописано, что мы этого не делаем.
[32:07.340 --> 32:11.340]  Да, то есть мы делаем в защиту от того, что человек хочет нам направить.
[32:11.340 --> 32:16.340]  Реально, такие кейсы бывают. Не зачастую вам придется их делать позавчера.
[32:16.340 --> 32:19.340]  Надо было сделать их позавчера.
[32:19.340 --> 32:26.340]  Типичный кейс. То есть нам не нужно делать лишних вещей, по факту.
[32:27.340 --> 32:32.340]  Ладно, смотрите, предположим себе, что мы выкинули лишние идеи.
[32:32.340 --> 32:37.340]  То есть не городите, грубо говоря, о лишних сущностях, называется.
[32:37.340 --> 32:40.340]  Ладно, мы оставили некоторый функционал.
[32:40.340 --> 32:44.340]  И дальше мы встречаемся с и понятием под названием кейс.
[32:46.340 --> 32:48.340]  Это не поцелуй, если что.
[32:49.340 --> 32:53.340]  Это называется stupid-simple-stupid.
[32:56.340 --> 33:02.340]  Картинка, которую я нашел, кто-нибудь сможет дать афоризм к этой картинке?
[33:07.340 --> 33:12.340]  Ну, типа того. Нет, скорее всего, Гарри Поттер вторая часть это антитеза к тому,
[33:12.340 --> 33:15.340]  потому что они опоздали на поезд.
[33:15.340 --> 33:19.340]  А здесь товарищи решили побежать впереди провоза.
[33:19.340 --> 33:23.340]  То есть начали городить лишние сущности, лишние абстракции.
[33:23.340 --> 33:27.340]  Вот мы с вами тут про солид послушали. Начали городить солид.
[33:27.340 --> 33:30.340]  Не подумав об этом.
[33:30.340 --> 33:36.340]  Получается проблема состоит в том, что надо стараться делать какие-то вещи
[33:36.340 --> 33:38.340]  достаточно простым способом.
[33:38.340 --> 33:41.340]  Для того, чтобы, допустим, мы смогли зарелизить с вами первую версию.
[33:41.340 --> 33:47.340]  И ко мне в прошлый раз подходили и говорили про вопрос,
[33:47.340 --> 33:49.340]  а что же касается тех долга?
[33:49.340 --> 33:54.340]  Да, ну, проблема в том, что это увеличивает технический долг,
[33:54.340 --> 33:55.340]  который мы должны с вами сделать.
[33:55.340 --> 34:00.340]  Но надо не забывать, что после киса идет на самом деле еще следующая абстракция,
[34:00.340 --> 34:02.340]  следующий концепт.
[34:04.340 --> 34:08.340]  То есть стараемся первую версию реализовать достаточно просто.
[34:09.340 --> 34:12.340]  Вот, иначе можно закопаться потом.
[34:12.340 --> 34:15.340]  Так, поняли вот эту вот вещь?
[34:15.340 --> 34:16.340]  Вот.
[34:16.340 --> 34:18.340]  Драй.
[34:21.340 --> 34:23.340]  Следующим идет драй.
[34:23.340 --> 34:25.340]  И это расшифровывается следующим образом.
[34:25.340 --> 34:27.340]  To not repeat yourself.
[34:30.340 --> 34:34.340]  Ну, по факту это бас, но заметьте, в каком моменте она у нас с вами возникает.
[34:34.340 --> 34:38.340]  Она возникает после того, как у нас уже прошел simple stupid.
[34:38.340 --> 34:42.340]  Ну, тут виден бард, который пишет 500 раз одно и то же слово.
[34:42.340 --> 34:44.340]  Вот, так делает.
[34:54.340 --> 34:56.340]  Да, есть такое.
[34:56.340 --> 35:00.340]  Вот, смотрите, значит, вот это замечательный бард, который 500 раз рисует.
[35:00.340 --> 35:05.340]  И на самом деле тут я почитал некоторые холиваронных обряд, пока готовился к ленте.
[35:05.340 --> 35:08.340]  И они говорят следующее, что драй это на самом деле не база.
[35:08.340 --> 35:12.340]  То есть помните, мы рассматривали всякие каплинги в прошлый раз.
[35:12.340 --> 35:16.340]  Вот драй говорит про то, что не надо делать контент каплинга.
[35:16.340 --> 35:19.340]  То есть прямо копировать вот именно все.
[35:19.340 --> 35:21.340]  Что-то в определенном контексте, возможно, да.
[35:21.340 --> 35:24.340]  Потому что, ну, по факту пока мы будем привязываться к интерфейсам,
[35:24.340 --> 35:28.340]  да, вот это все мы нарушим принцип keep it simple stupid.
[35:29.340 --> 35:31.340]  Вот, то есть тут надо искать компромисс.
[35:31.340 --> 35:36.340]  И в кисе вот проблема в том, что, допустим, у нас была проблема в том,
[35:36.340 --> 35:40.340]  что мы продолбали один из важных релизов в декабре месяце в компании.
[35:40.340 --> 35:44.340]  Вот, в связи с тем, что мы решили наградить всяких сложных сущностей,
[35:44.340 --> 35:48.340]  а потом у нас просто воспроизводимость не появилась и все.
[35:49.340 --> 35:51.340]  Ну, это было связано с машинным обучением.
[35:51.340 --> 35:55.340]  Так, теперь что касается картинки.
[35:55.340 --> 35:57.340]  Мне она очень понравилась.
[35:57.340 --> 36:01.340]  Она говорит про то, в какой стадии их надо исполнять желательно.
[36:01.340 --> 36:06.340]  То есть сначала нужно выкинуть лишнее, потом сделать это максимально просто,
[36:06.340 --> 36:09.340]  а потом только уже сгруппировать и не повторять лишнее.
[36:11.340 --> 36:14.340]  Вот, мне вот эта понравилась картинка.
[36:14.340 --> 36:18.340]  Значит, что-то я хотел рассказать еще.
[36:18.340 --> 36:21.340]  Сейчас дайте-ка я вспомню по этой части.
[36:22.340 --> 36:25.340]  Да, да, да, сейчас.
[36:28.340 --> 36:30.340]  Блин, забыл, черт.
[36:30.340 --> 36:33.340]  Ну ладно, если что, я вспомню, тогда покажу.
[36:34.340 --> 36:35.340]  Так, ага.
[36:35.340 --> 36:39.340]  Ну, здесь логически мы можем сделать перерыв, тем более у нас там 38 минут прошло.
[36:39.340 --> 36:41.340]  Давайте тогда отдохнем минут пять.
[36:41.340 --> 36:44.340]  Может быть, я вспомню, что я хотел рассказать.
[36:44.340 --> 36:46.340]  А?
[36:46.340 --> 36:48.340]  Что?
[36:48.340 --> 36:50.340]  Нет, не про ВЭД.
[36:50.340 --> 36:52.340]  ВЭД это, если что, аббревиатура.
[36:52.340 --> 36:54.340]  Right everything twice.
[36:54.340 --> 36:56.340]  Все, отдыхаем пять минут.
[36:56.340 --> 36:58.340]  Так, давайте продолжать.
[36:58.340 --> 37:00.340]  Значит, смотрите.
[37:00.340 --> 37:05.340]  У этого принципа появилось достаточно большое количество вопросов.
[37:05.340 --> 37:08.340]  Значит, вы не поверите.
[37:08.340 --> 37:13.340]  Ну, давайте я немножко разрекламирую яблочную продукцию.
[37:13.340 --> 37:15.340]  Хотя этого особо не хочу делать.
[37:15.340 --> 37:21.340]  Вот как раз в яблочной продукции максимально реализован пример dependency inversion.
[37:21.340 --> 37:23.340]  Почему?
[37:23.340 --> 37:27.340]  Потому что если внимательно посмотреть на эту замечательную конструкцию,
[37:27.340 --> 37:30.340]  то мы с вами здесь видим на самом деле...
[37:30.340 --> 37:32.340]  Ну, я вижу тут три разъема.
[37:32.340 --> 37:34.340]  Я не знаю, у кого как.
[37:34.340 --> 37:36.340]  И причем один из разъемов Type-C USB,
[37:36.340 --> 37:39.340]  от которого мы можем заряжать ноутбук,
[37:39.340 --> 37:43.340]  можем выводить информацию на экран, если другой конец шнура хороший.
[37:44.340 --> 37:46.340]  И третье, что мы с вами можем делать.
[37:46.340 --> 37:49.340]  Ну, вот я, допустим, проектор подключил через отдельную блокстанцию.
[37:49.340 --> 37:51.340]  Правда, смотрите, проблема в чем этой штуке.
[37:51.340 --> 37:55.340]  Что приходится по факту использовать дополнительные классы.
[37:55.340 --> 37:57.340]  Дополнительные обертки.
[37:57.340 --> 38:02.340]  Да, да, с этим проблема есть.
[38:02.340 --> 38:05.340]  То есть мы понимаем с вами недостаток этого подхода.
[38:05.340 --> 38:07.340]  Вот.
[38:07.340 --> 38:09.340]  И появлялись вопросы про интерфейсы.
[38:09.340 --> 38:11.340]  Ну, мы, я думаю, тоже сейчас разберем.
[38:11.340 --> 38:13.340]  Значит, смотрите.
[38:13.340 --> 38:15.340]  На самом деле мы с вами уже увидели,
[38:15.340 --> 38:19.340]  что какие-то штуки у нас с вами уже были видны.
[38:19.340 --> 38:22.340]  Точнее, этот.
[38:22.340 --> 38:26.340]  Какими-то мы уже диаграммками пользовались,
[38:26.340 --> 38:28.340]  поэтому пора ввести понятие UML.
[38:28.340 --> 38:32.340]  Значит, UML расшифровывается как Unified Modulated Mail Language.
[38:32.340 --> 38:36.340]  То есть это язык универсального моделирования объектов.
[38:36.340 --> 38:39.340]  Знаете, как раз, если отматываться в истории,
[38:40.340 --> 38:42.340]  люди фанатели от того,
[38:42.340 --> 38:44.340]  а давайте мы придумаем искусственный интеллект.
[38:44.340 --> 38:48.340]  Не знаю, будем все максимально унифицировать.
[38:48.340 --> 38:50.340]  То есть придумаем сильный искусственный интеллект.
[38:50.340 --> 38:53.340]  Придумаем так, чтобы код не мы писали,
[38:53.340 --> 38:55.340]  а мы рисовали какие-то диаграммки,
[38:55.340 --> 38:57.340]  а это дальше воплощался в код,
[38:57.340 --> 38:59.340]  в некоторых местах сейчас стерилизованы.
[38:59.340 --> 39:01.340]  Хотя это...
[39:01.340 --> 39:03.340]  Я не знаю, наматлог будут доказывать или нет,
[39:03.340 --> 39:05.340]  что это сложно сделать.
[39:05.340 --> 39:06.340]  Вот.
[39:06.340 --> 39:08.340]  Но, в общем, люди старались делать,
[39:08.340 --> 39:10.340]  и мы придумали язык UML.
[39:10.340 --> 39:12.340]  В принципе, для наших целей
[39:12.340 --> 39:14.340]  он нужен для того, чтобы мы с вами друг друга понимали.
[39:14.340 --> 39:16.340]  Потому что здесь, допустим,
[39:16.340 --> 39:18.340]  есть одни люди, которые пишут на Python,
[39:18.340 --> 39:20.340]  другие на плюсах, третий на JavaScript,
[39:20.340 --> 39:22.340]  четвертый, я не знаю, еще на каком-нибудь там
[39:22.340 --> 39:24.340]  еще каком-нибудь ОПшном языке,
[39:24.340 --> 39:26.340]  и нам надо их всех скастовать.
[39:26.340 --> 39:28.340]  И дальше, возможно, объяснить бизнесу.
[39:28.340 --> 39:31.340]  То есть нам же нужно найти с вами инвесторов,
[39:31.340 --> 39:34.340]  которые проинвестируют нам фиксиков, да?
[39:34.340 --> 39:37.340]  Как объяснить им, что это важно?
[39:37.340 --> 39:39.340]  Вот. Ну, надо тоже рисовать диаграммы.
[39:39.340 --> 39:41.340]  И вот, мы сегодня рассмотрим первый тип диаграмм,
[39:41.340 --> 39:44.340]  который связан именно с диаграммами классов.
[39:44.340 --> 39:47.340]  Значит, да, поэтому будем вводить обозначения,
[39:47.340 --> 39:49.340]  они будут полезны и на семинарах,
[39:49.340 --> 39:52.340]  когда мы будем с вами рассматривать разные паттерны и антипаттерны.
[39:52.340 --> 39:55.340]  Значит, знакомьтесь, класс.
[39:56.340 --> 39:59.340]  Здесь, на самом деле, все в нем подписано.
[40:00.340 --> 40:03.340]  Значит, вот этот вот квадратик — это класс.
[40:03.340 --> 40:05.340]  Замечательно, да?
[40:05.340 --> 40:08.340]  Что мы с вами с ним видим?
[40:08.340 --> 40:11.340]  Сверху мы что с вами видим у этого класса?
[40:12.340 --> 40:14.340]  Поля, да.
[40:14.340 --> 40:16.340]  А снизу?
[40:18.340 --> 40:20.340]  Методы.
[40:20.340 --> 40:22.340]  Да, поля и методы.
[40:22.340 --> 40:24.340]  При этом, смотрите, что означают...
[40:24.340 --> 40:27.340]  У каждого класса есть некоторые модификаторы доступа.
[40:30.340 --> 40:33.340]  Как обозначаются у нас приватные поля и методы?
[40:34.340 --> 40:36.340]  Минусиком.
[40:36.340 --> 40:38.340]  Публичные поля?
[40:38.340 --> 40:40.340]  Плюсиком.
[40:40.340 --> 40:43.340]  То есть, если метод у нас публичный, то это плюсик.
[40:43.340 --> 40:46.340]  Если у нас метод или поле приватный, это минусик.
[40:48.340 --> 40:51.340]  Так, что тут еще есть? Интересно.
[40:51.340 --> 40:54.340]  А протект как изначается? Плюс-минус?
[40:54.340 --> 40:58.340]  Да, мне Иван пинал за то, что я должен был это нарисовать,
[40:58.340 --> 41:00.340]  и не нарисовал.
[41:00.340 --> 41:02.340]  Решетка.
[41:03.340 --> 41:05.340]  Протект.
[41:11.340 --> 41:14.340]  Если, значит, те, кто понимают джава,
[41:14.340 --> 41:17.340]  если здесь будет ничего,
[41:17.340 --> 41:20.340]  я напишу это как пустое множество,
[41:20.340 --> 41:24.340]  то это специальный модификатор доступа, который есть в джаве package-private.
[41:28.340 --> 41:31.340]  На джаве рассказывали, что бывают такие?
[41:32.340 --> 41:34.340]  Лично.
[41:34.340 --> 41:39.340]  То есть, это приватные пределы под дерево, так сказать.
[41:39.340 --> 41:42.340]  Так, и есть еще подчеркивание.
[41:42.340 --> 41:46.340]  Видите, функция метод, который подчеркивает.
[41:46.340 --> 41:49.340]  Это статические методы, так обозначается.
[41:49.340 --> 41:52.340]  Вопрос. Что такое статический метод?
[41:54.340 --> 41:59.340]  Да, который может быть вызван без создания гиперакласса.
[42:00.340 --> 42:02.340]  Так.
[42:02.340 --> 42:04.340]  На этом слайде понятно все?
[42:04.340 --> 42:08.340]  То есть, у нас есть класс, у нас есть поля, у нас есть методы.
[42:08.340 --> 42:10.340]  У нас с вами есть, что еще?
[42:10.340 --> 42:12.340]  Модификаторы доступа.
[42:12.340 --> 42:17.340]  Да, и, собственно, конструктор класса обозначается просто как обычно.
[42:17.340 --> 42:21.340]  То есть, название этого класса,
[42:21.340 --> 42:24.340]  если у нас название метода совпадает с названием этого класса,
[42:24.340 --> 42:26.340]  то это конструктор.
[42:26.340 --> 42:30.340]  Это еще бывает, приписывают, типа, у нас есть класса,
[42:31.340 --> 42:34.340]  и пишут вот такую вот вещь.
[42:34.340 --> 42:36.340]  Конструктор пишут.
[42:37.340 --> 42:40.340]  Можно в некоторых версиях этой нотации встретить.
[42:40.340 --> 42:44.340]  Ну, то есть, угловые скобки двойные и конструктор.
[42:45.340 --> 42:47.340]  Так, с классом разобрались.
[42:47.340 --> 42:49.340]  Да?
[42:49.340 --> 42:52.340]  Так, ой, чуть поехал, блин.
[42:52.340 --> 42:54.340]  Эй, блин.
[42:55.340 --> 42:57.340]  Так.
[42:57.340 --> 42:59.340]  Рубрика фиксов в прямом эфире.
[42:59.340 --> 43:01.340]  Так, так.
[43:01.340 --> 43:03.340]  Поправили.
[43:03.340 --> 43:06.340]  Значит, как могут классы между собой взаимодействовать?
[43:06.340 --> 43:08.340]  У нас есть два класса.
[43:08.340 --> 43:10.340]  У нас с вами есть пример.
[43:10.340 --> 43:12.340]  Колесо и машина.
[43:14.340 --> 43:16.340]  Смотрите, что у нас написано.
[43:16.340 --> 43:18.340]  По факту, эту диаграмму можно читать так.
[43:18.340 --> 43:22.340]  У колеса, ой, наоборот, у машины, сколько колес?
[43:23.340 --> 43:24.340]  Четыре.
[43:24.340 --> 43:26.340]  Как мы это с вами поняли?
[43:31.340 --> 43:33.340]  Не, у диаграммы есть.
[43:33.340 --> 43:38.340]  То есть, смотрите, в диаграмме всегда есть количество объектов на связи.
[43:38.340 --> 43:40.340]  То есть, смотрите, машина одна.
[43:40.340 --> 43:43.340]  На одну машину, здесь, если мне указано, указаться один,
[43:43.340 --> 43:45.340]  приходят четыре колеса.
[43:47.340 --> 43:49.340]  Ага.
[43:49.340 --> 43:50.340]  Вот.
[43:50.340 --> 43:53.340]  А при этом, смотрите, можно писать разные вещи.
[43:53.340 --> 43:55.340]  Можно писать звездочка.
[43:55.340 --> 43:58.340]  Так, товарищи, кто знает, что такое звездочка?
[44:02.340 --> 44:04.340]  Какой пример у вас был до этого?
[44:05.340 --> 44:06.340]  Матлог.
[44:06.340 --> 44:08.340]  Что на матлоге звездочка обозначает?
[44:08.340 --> 44:10.340]  Итерация к линии, да.
[44:10.340 --> 44:14.340]  Это значит, что этот объект может повторяться любое число раз.
[44:14.340 --> 44:16.340]  От нуля до бесконечности.
[44:20.340 --> 44:21.340]  Вот так вот.
[44:21.340 --> 44:23.340]  Можно обозначать вот так вот.
[44:23.340 --> 44:24.340]  Одна звездочка.
[44:24.340 --> 44:26.340]  Это значит, хотя бы один объект.
[44:29.340 --> 44:31.340]  Можно обозначать так.
[44:31.340 --> 44:33.340]  Хотя лучше обозначать вот так вот.
[44:34.340 --> 44:36.340]  Это пример не очень хороший.
[44:36.340 --> 44:39.340]  Сколько пальцев на руке может быть?
[44:41.340 --> 44:43.340]  При некотором сущении обстоятельств.
[44:44.340 --> 44:45.340]  Так.
[44:48.340 --> 44:50.340]  Не, я про вот это вот.
[44:53.340 --> 44:54.340]  Вот.
[44:54.340 --> 44:56.340]  Причем в меньшую сторону это зачетует производственные травмы.
[44:56.340 --> 44:57.340]  Вот.
[44:57.340 --> 44:58.340]  А теперь смотрите.
[44:58.340 --> 45:01.340]  Значит, два класса могут объединяться просто стрелочкой.
[45:01.340 --> 45:03.340]  Это значит, что они как-то связаны.
[45:03.340 --> 45:09.340]  А бывает такая штука, что мы рисуем это все дело либо с вот таким ромбиком.
[45:10.340 --> 45:12.340]  Либо с таким ромбиком.
[45:12.340 --> 45:14.340]  Не спрашивайте, почему это придумали.
[45:15.340 --> 45:16.340]  Вот.
[45:16.340 --> 45:18.340]  Но это показывается на самом деле следующее.
[45:19.340 --> 45:27.340]  Если мы с вами рисуем, это означает, что объект A содержит в себе объект B.
[45:28.340 --> 45:31.340]  То есть B является частью объекта A.
[45:32.340 --> 45:35.340]  То есть колесо является составной частью машины.
[45:36.340 --> 45:42.340]  Если у нас нарисован закрашенный ромбик, это означает интересную вещь.
[45:42.340 --> 45:48.340]  Это означает, что если один из объектов убрать, то второй не поедет.
[45:49.340 --> 45:51.340]  Как известно, машина без колес не поедет.
[45:53.340 --> 45:55.340]  Я не знаю.
[45:57.340 --> 46:00.340]  Ну, без всех-то вряд ли поедет.
[46:00.340 --> 46:05.340]  Это означает, что это незаменимая часть.
[46:06.340 --> 46:08.340]  Значит, агрегация.
[46:08.340 --> 46:13.340]  Это класс состоит из студентов, но при этом студенты могут быть в других классах.
[46:14.340 --> 46:16.340]  И могут быть вообще без группы.
[46:18.340 --> 46:20.340]  Вот. Изображается без ромба.
[46:20.340 --> 46:23.340]  И теперь смотрите еще раз про интерфейс.
[46:23.340 --> 46:26.340]  Спрашивали все на перерыве, поэтому тут веселая готовка.
[46:26.340 --> 46:27.340]  Интерфейс.
[46:27.340 --> 46:28.340]  Он делает следующее.
[46:28.340 --> 46:29.340]  Он исполняет роли.
[46:29.340 --> 46:33.340]  У него есть только методы, и они являются публичными.
[46:34.340 --> 46:38.340]  И у него не может быть никаких полей и реализаций.
[46:38.340 --> 46:44.340]  Если есть поля или реализация некоторых методов, то это автоматом абстрактный класс.
[46:44.340 --> 46:47.340]  То есть это уже объект сущностный, а не ролевой.
[46:49.340 --> 46:51.340]  Как обозначаются интерфейсы?
[46:51.340 --> 46:54.340]  Интерфейсы обозначаются квадратными скобками.
[46:55.340 --> 46:56.340]  Интерфейс.
[46:56.340 --> 46:57.340]  Ой, угловыми.
[46:58.340 --> 46:59.340]  Интерфейс.
[47:03.340 --> 47:04.340]  Тут эта фигура.
[47:04.340 --> 47:08.340]  И видно, что у него есть только роль вычислить площадь.
[47:11.340 --> 47:16.340]  При этом реализация интерфейсов выполняется следующим образом.
[47:17.340 --> 47:18.340]  Вот так вот.
[47:18.340 --> 47:19.340]  И стрелочка.
[47:20.340 --> 47:21.340]  Вот такая стрелочка.
[47:22.340 --> 47:23.340]  Пунктирная.
[47:23.340 --> 47:25.340]  Это называется имплементация интерфейса.
[47:25.340 --> 47:26.340]  Имплементация интерфейса.
[47:26.340 --> 47:32.340]  Если у нас есть имплементация интерфейсов, то мы должны предоставить реализацию для всех ролей, которые были описаны в интерфейсе.
[47:35.340 --> 47:37.340]  Так, стало ли понятней про интерфейс?
[47:42.340 --> 47:43.340]  Чего?
[47:45.340 --> 47:46.340]  Не-не-не.
[47:49.340 --> 47:50.340]  Никогда.
[47:50.340 --> 47:54.340]  Но если мы наследуем интерфейс, то мы должны реализовать все его роли.
[47:56.340 --> 47:57.340]  Вот.
[47:57.340 --> 48:02.340]  Если вы хотите реализовать, допустим, не все его роли, это значит, что надо разбить интерфейс на несколько интерфейс.
[48:05.340 --> 48:07.340]  Так, вопросы по интерфейсу.
[48:15.340 --> 48:16.340]  А?
[48:16.340 --> 48:17.340]  А?
[48:17.340 --> 48:18.340]  А?
[48:20.340 --> 48:21.340]  Да, можно.
[48:23.340 --> 48:29.340]  Но при этом абстрактный класс отнаследоваться от интерфейса в принципе может, а вот наоборот не может.
[48:30.340 --> 48:33.340]  То есть интерфейс отнаследоваться от абстрактного класса не может.
[48:35.340 --> 48:37.340]  Вот, тонкая разница, ее придется почувствовать.
[48:38.340 --> 48:39.340]  Значит, смотрите.
[48:39.340 --> 48:40.340]  Ой, кажется, шокальная картинка.
[48:41.340 --> 48:44.340]  Значит, абстрактный класс.
[48:45.340 --> 48:46.340]  Как обозначается?
[48:46.340 --> 48:49.340]  Значит, на самом деле здесь тонкая-тонкая разница.
[48:51.340 --> 48:55.340]  В UML'е предполагается, что если класс абстрактный, то его название написано курсивом.
[48:57.340 --> 48:58.340]  Да.
[48:59.340 --> 49:00.340]  Вот такая аннотация.
[49:02.340 --> 49:03.340]  Да.
[49:03.340 --> 49:06.340]  Не, ну можно писать в квадратных скопах абстрактный класс.
[49:08.340 --> 49:09.340]  Вот.
[49:09.340 --> 49:12.340]  Анаследование рисуется другой стрелочкой.
[49:13.340 --> 49:14.340]  Вот это наследование.
[49:16.340 --> 49:18.340]  Вот это реализация интерфейса.
[49:22.340 --> 49:23.340]  Ага.
[49:24.340 --> 49:25.340]  А что такое загнутый угол?
[49:26.340 --> 49:28.340]  А, загнутый угол — это комментарий.
[49:32.340 --> 49:37.340]  Ну, обычно в них могут писать реализацию функций, которые там, которые есть у данного.
[49:39.340 --> 49:40.340]  То есть здесь пример такой.
[49:41.340 --> 49:45.340]  У нас есть животное, которое может перемещаться в точку x, y.
[49:46.340 --> 49:49.340]  А у млекопитающего — это перебежать ножками.
[49:50.340 --> 49:51.340]  Вот.
[49:52.340 --> 49:55.340]  А дальше у млекопитающих есть два наследника.
[49:56.340 --> 49:57.340]  Это кот и пёс.
[49:58.340 --> 49:59.340]  Вот.
[49:59.340 --> 50:01.340]  Один говорит мяу, второй говорит гав.
[50:02.340 --> 50:07.340]  Если у нас тут произойдёт множество наследований, ну смотрите мультик от компании Nickelodeon.
[50:10.340 --> 50:11.340]  Вот.
[50:11.340 --> 50:13.340]  Так, понятно, что, как наследование рисовать?
[50:16.340 --> 50:17.340]  Кто?
[50:18.340 --> 50:20.340]  Да, животное здесь абстрактный класс.
[50:21.340 --> 50:25.340]  Млекопитающие здесь тоже абстрактный класс, потому что у нас нет реализации сей.
[50:26.340 --> 50:29.340]  А вот уже кот и пёс — это уже не абстрактный класс.
[50:30.340 --> 50:31.340]  Вот.
[50:32.340 --> 50:33.340]  Вот.
[50:33.340 --> 50:38.340]  Плохо, надо было сказать, надо было написать чирик в качестве реализации функции сей.
[50:39.340 --> 50:40.340]  Да, это косяк.
[50:41.340 --> 50:42.340]  Так.
[50:42.340 --> 50:43.340]  Вот, замечательно.
[50:44.340 --> 50:48.340]  И смотрите, теперь мы с вами сфотографировали, как мы делаем сей.
[50:49.340 --> 50:50.340]  Вот.
[50:51.340 --> 50:52.340]  Вот.
[50:53.340 --> 50:54.340]  Вот.
[50:55.340 --> 50:56.340]  Вот.
[50:57.340 --> 50:58.340]  Вот.
[50:59.340 --> 51:00.340]  Вот.
[51:01.340 --> 51:06.340]  И смотрите, теперь мы с вами наконец-таки, наконец-таки готовы познакомиться с паттернами.
[51:07.340 --> 51:11.340]  Потому что для того, чтобы реализовывать паттерны, надо рисовать диаграммы классов.
[51:12.340 --> 51:17.340]  Ну а значит, смотрите, сразу скажу, что некоторые достаточно популярные паттерны, которые у нас будут возникать по ходу дела.
[51:18.340 --> 51:19.340]  Мы будем разбирать на лекциях.
[51:20.340 --> 51:23.340]  Но и на семинарах, некоторые семинары будут посвящены разбору остальных паттернов.
[51:24.340 --> 51:25.340]  Их очень много.
[51:26.340 --> 51:27.340]  Первые паттерны.
[51:27.340 --> 51:28.340]  Первые паттерны.
[51:29.340 --> 51:31.340]  Значит, во-первых, надо понимать, что такое паттерн проектирования.
[51:32.340 --> 51:36.340]  Это какие-то кейсы, которые помогают решать определенную задачу.
[51:37.340 --> 51:43.340]  Типичные косяки, лайфайки, которые помогают решать ту или иную вещь.
[51:44.340 --> 51:46.340]  Вот смотрите, у вас есть интеграл наберущийся, пример.
[51:47.340 --> 51:48.340]  Как его можно попробовать взять?
[51:51.340 --> 51:54.340]  Можно в тупую посчитать, можно посчитать по частям.
[51:55.340 --> 51:56.340]  Что там еще есть?
[51:57.340 --> 51:58.340]  Замена переменных.
[51:59.340 --> 52:00.340]  Замена переменных.
[52:01.340 --> 52:03.340]  Переход к какому-нибудь там неопределенному, несобственному интегралу.
[52:04.340 --> 52:05.340]  Кажется, этого еще не проходили?
[52:06.340 --> 52:07.340]  Проходили.
[52:08.340 --> 52:09.340]  Да ладно, уже были несобственные интегралы?
[52:10.340 --> 52:11.340]  Да.
[52:12.340 --> 52:13.340]  Понятно.
[52:14.340 --> 52:15.340]  Хорошо.
[52:16.340 --> 52:17.340]  Ну, вот видите, есть куча способов.
[52:18.340 --> 52:19.340]  И здесь тоже такие же способы для проектирования.
[52:20.340 --> 52:24.340]  Первая книжка, которая их упоминает, это Банда 4.
[52:25.340 --> 52:26.340]  Возможно, вы слышали.
[52:27.340 --> 52:30.340]  Именно они ввели концепцию паттернов проектированных.
[52:31.340 --> 52:32.340]  Нижка 90-х годов, советую почитать.
[52:33.340 --> 52:35.340]  Значит, у паттернов всегда есть имя.
[52:36.340 --> 52:38.340]  То есть, вы приходите на собес, вас начинают гонять по паттернам.
[52:39.340 --> 52:41.340]  Вам говорят, что такого паттерна легковес.
[52:42.340 --> 52:45.340]  Ну и сразу все понимают, о чем говорят.
[52:46.340 --> 52:49.340]  У каждого паттерна есть задача, которую он решает.
[52:50.340 --> 52:54.340]  У этой задачи есть типичные решения, которые предоставляются паттернам.
[52:54.340 --> 52:57.340]  И в конце концов мы получаем какие-то дополнительные результаты.
[52:58.340 --> 52:59.340]  Какие-то плюсы, какие-то минусы.
[53:00.340 --> 53:04.340]  Не поверите, бывают паттерны, которые приводят к большей части минусов, чем плюсов.
[53:05.340 --> 53:07.340]  И, наверное, вы даже с ними сталкивались.
[53:08.340 --> 53:15.340]  Нет, это паттерны, которые, если не грамотно перевести, они приведут к образованию анти-паттернов.
[53:16.340 --> 53:17.340]  Вот так вот.
[53:18.340 --> 53:21.340]  Значит, паттерны бывают трех типов.
[53:21.340 --> 53:25.340]  Первые паттерны – это порождающие паттерны, которые отвечают за создание каких-то объектов.
[53:26.340 --> 53:31.340]  Вторые паттерны – это структурные паттерны, которые обеспечивают грамотную связь между объектами.
[53:32.340 --> 53:37.340]  И третьи паттерны – это поведенческие паттерны, которые обеспечивают взаимодействие между объектами.
[53:38.340 --> 53:43.340]  Поскольку здесь физика, эпсилон, наверное, мне не надо приводить абстракции, связанные с физикой.
[53:44.340 --> 53:45.340]  Или привести.
[53:46.340 --> 53:47.340]  Давайте попробуем.
[53:48.340 --> 53:49.340]  Хорошо.
[53:49.340 --> 53:57.340]  Смотрите, порождающие паттерны по факту это не что иное, как создание разных материальных точек с разными описанными свойствами.
[53:58.340 --> 54:03.340]  Структурные паттерны, как вы думаете, к какому разделу физики относятся?
[54:06.340 --> 54:08.340]  Ну, подраздел механики какой?
[54:11.340 --> 54:12.340]  Статика.
[54:15.340 --> 54:17.340]  То есть, как связываются объекты?
[54:17.340 --> 54:19.340]  И поведенческие, как вы думаете?
[54:20.340 --> 54:21.340]  Движание.
[54:21.340 --> 54:22.340]  Движание, динамика, конечно же.
[54:23.340 --> 54:24.340]  Вот.
[54:24.340 --> 54:25.340]  Вот такие абстракции.
[54:26.340 --> 54:27.340]  Значит, смотрите.
[54:28.340 --> 54:35.340]  Первый пример, мы сегодня будем рассматривать примеры паттернов в связи с реализацией принципов Солид.
[54:37.340 --> 54:43.340]  Первый пример Солида – это, ой, первый пример Open-Close-Principle – это пример Factory-Principle.
[54:43.340 --> 54:48.340]  Значит, представьте себе, что мы с вами начали это, фиксиков воспроизвели.
[54:49.340 --> 54:52.340]  Да, то есть написали функцию для создания фиксиков.
[54:53.340 --> 54:54.340]  Написали, написали фиксиков.
[54:55.340 --> 54:56.340]  Такие это.
[54:57.340 --> 55:00.340]  Наш проект начал окупаться.
[55:01.340 --> 55:02.340]  Мы начали прийти в успех.
[55:02.340 --> 55:04.340]  Кто к нам придет дальше?
[55:07.340 --> 55:08.340]  Ну, допустим.
[55:09.340 --> 55:10.340]  Нам придут…
[55:10.340 --> 55:11.340]  Правообладательные.
[55:12.340 --> 55:17.340]  Нет, мы договоримся, да, договоримся, да?
[55:18.340 --> 55:20.340]  К нам придут эти…
[55:22.340 --> 55:25.340]  Нет, нам придут, мы ско…
[55:26.340 --> 55:27.340]  Нас просят, вы родились.
[55:27.340 --> 55:28.340]  Мы скажем, мы родились.
[55:29.340 --> 55:32.340]  Ну, говорят, ну, тогда давайте нам лучше поедем, да.
[55:32.340 --> 55:39.100]  нас просят вы родились мы скажем мы родились ну и говорит ну тогда давайте нам лунтиков запилите
[55:39.100 --> 55:42.020]  так вопрос как производить лунтиков
[55:42.020 --> 55:48.220]  control c control v это про другой паттерн
[55:48.220 --> 55:56.580]  ну во первых неплохо было бы понять что общего между фиксиками и лунтиками
[55:56.580 --> 56:07.900]  они видимо могут ну да они воверх мультипликационные персонажи да они каким-то образом перемещаются
[56:07.900 --> 56:19.780]  кажется одинаковым это тоже вот начинаем надо с вами найти что-то общий между фиксиками и
[56:19.780 --> 56:28.020]  лунтиками какой-то общий функционал и дальше смотрите это первый паттерн который у нас
[56:28.020 --> 56:33.900]  встречается этот паттерн называется фабричный метод в чем его суть это порождающий паттерн
[56:33.900 --> 56:42.540]  проектирования который определяет общий интерфейс создания объектов и позволяет изменить его
[56:42.540 --> 56:50.900]  поведение в некотором подклассе вопрос я не помню сейчас ага понял картинка 25 кадр вы
[56:50.900 --> 57:01.460]  ничего не заметили вопрос как сделать так чтобы не сломать ничего не смотрите у нас есть open
[57:01.460 --> 57:12.580]  close принципа расширить что расширить смотрите мы должны создать фиксиков должны создать лунтиков
[57:21.380 --> 57:28.740]  ну смотрите представим себе что фиксиков и лунтиков на заводах производят но это мультипликаторы
[57:29.220 --> 57:32.180]  это значит что нам надо с мультипликаторами сделать
[57:32.180 --> 57:44.020]  производить найти какой-то общий архитектурный стиль между между фиксиками лунтиками да и
[57:44.020 --> 57:51.260]  засунуть его в отдельную в отдельный фабричный метод смотрите вот такая вот диаграмма получается
[57:51.260 --> 57:59.260]  у нас с вами сверху это наши мультипликационные ребята которые выполняют некоторые действия
[57:59.260 --> 58:05.060]  они умеют ходить там говорить замечательные фразы и дальше у нас есть реализация интерфейсов
[58:05.060 --> 58:11.060]  продукт у нас есть конкретный продукт а есть конкретный подруг б которые наследует реализуют
[58:11.060 --> 58:18.780]  эти два интерфейса слева у нас допустим фиксики справа у нас лунтики да а снизу у нас мультипликатор
[58:18.780 --> 58:23.620]  класс под названием мультипликатор который производит фиксиков и лунтиков единственное что
[58:23.620 --> 58:32.740]  у них есть это метод фабричный метод который является абстрактным методом это значит что мы
[58:32.740 --> 58:41.020]  берем реализуем мультипликаторов идем такие на сайт хахару пишем хахару значит покансия
[58:41.020 --> 58:48.620]  требуется мультипликатор обязанности тун тудун тудун тудун да но будет рисовать мультиков потом
[58:48.620 --> 58:54.580]  мы идем на хахару пишем другую вакансию он будет выполнять тоже самое но только теперь будет
[58:54.580 --> 59:00.860]  рисовать фиксиков и по факту в фабричной методе происходит следующее мы по факту вызываем
[59:00.860 --> 59:08.140]  конструктор класса который нам необходим как это выглядит реализация в реализации это выглядит
[59:08.140 --> 59:18.020]  следующим образом мы с вами по факту берем по мультипликаторам ну представьте себе и при этом
[59:18.020 --> 59:23.780]  каждый знает какую задачу он делает это идеальный мир идеально мультипликационная фирма мы берем
[59:23.780 --> 59:34.220]  такие так ребят заказ нам нужно сделать новую новую порцию этого шматя мерча для этих ребят такие
[59:34.220 --> 59:40.900]  так ладно и каждый поскольку по факту они выглядят все приблизительно одинаково но каждый знает
[59:40.900 --> 59:47.060]  что он должен делать ну и по факту представить себе мы создали 50 с вами мультипликаторов фиксиков
[59:47.060 --> 59:55.220]  50 мультипликаторов этих лунтиков да и по факту мы говорим ста сделай это все дело а достаточно
[59:55.220 --> 01:00:02.220]  одного фора сделать пожалуйста создайте нам мерч ну и каждый делает свой мерч и у нас
[01:00:02.220 --> 01:00:07.860]  получается 50 мерчей фиксиков 50 мерчей лунтиков и потом мы можем их надеть на лунтиков
[01:00:07.860 --> 01:00:19.380]  ну это недостаток так или иначе всех патронов проектирования да но патроны проектирования
[01:00:19.380 --> 01:00:33.620]  они преимущественно нужны для оп так понятен понятна ли вот эта диаграмма вопрос как сделать
[01:00:33.620 --> 01:00:48.700]  на луне как начать платить на луне да нам нужно добавить наследника для для нашего мультипликационного
[01:00:48.700 --> 01:00:58.380]  персонажа и создать наследник мультипликатора не знаете от класса мультипликатор а то есть на каждую
[01:00:58.380 --> 01:01:06.380]  пару объект на каждый объект мы создаем пару объектов его создателя вот такой вот а вот
[01:01:06.380 --> 01:01:11.340]  такой вот патрон недостатков его заключается в том что у нас появляется много классов плюсы
[01:01:11.340 --> 01:01:23.580]  мы скрываем реализацию о создании определенного объекта так вопросы значит сразу сделайте
[01:01:23.780 --> 01:01:29.940]  на семинаре вы будете рассматривать патрон под названием абстрактная фабрика не путать с
[01:01:29.940 --> 01:01:40.500]  фабричным методом это по факту картинка для 1d можно ее в 2d перевратить вот так движемся
[01:01:40.500 --> 01:01:52.460]  к следующему паттерну а вопрос почему он почему здесь исполняется open close principle да
[01:01:52.460 --> 01:02:02.100]  да не меняем код абстрактного класса мы меняем код интерфейсов да но при этом если нам
[01:02:02.100 --> 01:02:08.340]  нужно создать новый тип персонажа мы просто расширяем текущий класс с одной стороны
[01:02:08.340 --> 01:02:16.460]  импренутируем интерфейс со второй стороны расширяем класс так переходим к следующему
[01:02:16.460 --> 01:02:26.100]  паттерну да значит второй паттерн который вообще практически мастер так ли начало
[01:02:26.100 --> 01:02:32.940]  придется работать с ним это паттер под названием адаптер и по факту он используется в dependency
[01:02:33.940 --> 01:02:41.980]  идея следующая представьте себе что мы хотим сделать что-то несовместимое между собой
[01:02:41.980 --> 01:02:49.900]  пример пример такой это портирование игр представьте себе вот мы пишем с вами игру да
[01:02:49.900 --> 01:02:59.380]  мы с вами играть эти игроделы и мы написали с вами игрушку эксклюзивно для playstation как любят
[01:02:59.380 --> 01:03:11.260]  там все делать да в чем прикол playstation да там есть своя система ачевок есть свой
[01:03:11.260 --> 01:03:18.740]  я смотрите если мы с вами нарушим dependency inversion мы просто берем и берем привязываемся к этим
[01:03:18.740 --> 01:03:24.180]  функциям прям напрямую вызываем если мы с вами попробуем придумать dependency inversion как
[01:03:24.180 --> 01:03:28.820]  реализовать мы с вами получим паттерн адаптер потому что мы с вами по факту сделал смотрите
[01:03:28.820 --> 01:03:37.220]  иногда еще этот паттерн называется классы под названием раппер как раппер переводится английского
[01:03:37.220 --> 01:03:45.940]  обертка то есть мы с вами пытаемся делать обертку вот ну вот пример цель этого паттерна
[01:03:45.940 --> 01:03:50.140]  заключается в том чтобы трансформировать объект одного вида таким образом чтобы он был
[01:03:50.140 --> 01:03:57.060]  понятен некоторому другому интерфейсу картинку вы сейчас увидите что она похожа примеры это
[01:03:57.060 --> 01:04:02.900]  преобразователь из одного формата в другой чтобы читалось все в другом формате грубо говоря
[01:04:02.900 --> 01:04:11.420]  калибр я не знаю но на каком-нибудь сайте госуслуг требуют картинки такого-то определенного формата
[01:04:11.420 --> 01:04:17.700]  а вы берете такие закидывайте в конвертатор он там преобразует любой другой формат и работа с
[01:04:17.700 --> 01:04:23.540]  ним нормально дальше если вы хотите работать базами данных вы должны вообще обеспечить работу
[01:04:23.540 --> 01:04:30.180]  с любой базой данных с любым хранилищем данных не только с и текущим возможно что вам надо
[01:04:30.180 --> 01:04:36.260]  мигрировать данные из одной системы в другую то есть смотрите пример вот уже ли вы я не знаю
[01:04:36.260 --> 01:04:46.420]  кто-нибудь по типам пользовался да отлично вот spotify прикрыли да согласен я с этим согласен
[01:04:46.420 --> 01:04:53.340]  вот и замечательный сервис под названием века придумал сервис трансфера данных то есть они
[01:04:53.340 --> 01:05:01.500]  преобразуют этот формат к своему формату и загружает его себе какой пример реализация на самом
[01:05:01.500 --> 01:05:09.260]  деле достаточно простая да тут немножко другое нотация видите зелененькая штучечка с этой
[01:05:09.260 --> 01:05:23.220]  штука как вы думаете что это такое нотации емл да зелененькая это интерфейс смотрите как это
[01:05:23.220 --> 01:05:29.460]  распознать видите стрелочка которая вниз идет это реализация интерфейса то есть смотрите
[01:05:29.460 --> 01:05:39.500]  клиент общается всегда с интерфейсом а дальше мы с вами пишем специальный адаптер который
[01:05:39.500 --> 01:05:44.780]  помогает работать с нашим сервисом то есть грубо говоря вы представьте себе что это система
[01:05:44.780 --> 01:05:52.740]  ачивок в PlayStation Store мы вызываем хук сделаем отправь пожалуйста ачивку и реализуем интерфейс
[01:05:52.740 --> 01:05:57.900]  в качестве класса под названием отправка ачивки PlayStation Plus если мы с вами захотим
[01:05:57.900 --> 01:06:04.860]  портироваться в Steam что нам надо будет сделать для этой штуки просто написать свой адаптер и
[01:06:04.860 --> 01:06:19.140]  все а адаптер вызовет интерфейс для функцию для выгрузки ачивок в Steam гениально да смотрите
[01:06:19.140 --> 01:06:30.660]  где мы эту картинку с вами уже видели сегодня так напоминаю да смотрите у нас была такая такая
[01:06:30.660 --> 01:06:42.020]  штука такая штука а сделали такая штука такая штука такая штука так что там было да
[01:06:49.140 --> 01:06:52.700]  что похоже
[01:06:59.860 --> 01:07:08.580]  да тут две штуки добавил в нее вот такая полезная вещь значит смотрите достоинство недостатки значит
[01:07:08.580 --> 01:07:14.340]  сокрытие детали преобразования интерфейс то есть для нас выглядит это как единое целое то есть
[01:07:14.340 --> 01:07:19.980]  отправили ачивку ачивка отправляется ну и по факту это часть реализации депенденции
[01:07:19.980 --> 01:07:26.500]  при этом и недостаток в том что на каждый чих нужно писать свой конвертатор но представьте
[01:07:26.500 --> 01:07:32.460]  себе следующее такая задача будет те кто будут реализовывать командные проекты вам придется
[01:07:32.460 --> 01:07:37.660]  реализовать все в нескольких интерфейсах типов внешних интерфейсах графический интерфейс там
[01:07:37.660 --> 01:07:43.500]  текстов и так далее и по факту мы от вас будем требовать так чтобы вы так или иначе использовали
[01:07:43.500 --> 01:07:49.380]  адаптер почему потому что будет сетап допустим если вы что-то неграмотно напишите мы с вами попросим
[01:07:49.380 --> 01:07:55.900]  а сможете ли вы за несколько часов перепилить это все с одного интерфейса на другой если вы
[01:07:55.900 --> 01:08:06.660]  сказали да вы молодцы да проверять буду но сделать архитектуры такой чтобы реально можно было
[01:08:06.660 --> 01:08:13.780]  отцепить одну прицепить второе вот такой пример так понятен ли адаптер
[01:08:13.780 --> 01:08:21.380]  давайте я поскольку мы чуть позже начали я сейчас еще один тезис расскажу
[01:08:21.380 --> 01:08:36.300]  смотрите есть паттерны соответственно должны быть анти паттерны логично
[01:08:36.300 --> 01:08:43.220]  один из анти паттерн мы с вами уже разобрали на прошлой лекции и он нарушает принцип
[01:08:43.220 --> 01:08:55.420]  single responsibility он называется если переводить на русский бог объект готов и у этого анти
[01:08:55.420 --> 01:09:01.780]  паттерна заключается в том что мы все пытаемся делать в одном объекте в итоге у нас есть он
[01:09:01.780 --> 01:09:08.220]  гад называется готов обычно значит если вы начнете писать какой-нибудь проект на
[01:09:08.220 --> 01:09:15.700]  типичном графическом интерфейсе тот же самый кути либо такая интер вы начнете писать это все
[01:09:15.700 --> 01:09:20.900]  в классе под названием мэйн виндал и вот у вас мэйн виндал получается огромным по факту будет
[01:09:20.900 --> 01:09:28.700]  являться готов от этого лучше отклоняться при этом некоторые другие паттерны которые мы с вами
[01:09:28.700 --> 01:09:38.820]  использовать у них есть недостаток того что они очень легко могут превратиться в готовых если
[01:09:38.820 --> 01:09:48.580]  не неправильно чихнуть так сказать вот это анти паттерн а вопрос кто-нибудь так вопрос про
[01:09:48.580 --> 01:09:58.540]  готовчик понятна в чем его суть вопрос на засыпку давайте разберем еще один паттер попытайтесь
[01:09:58.540 --> 01:10:03.580]  угадать его название с учетом того что мы с вами уже сегодня разобрали
[01:10:09.300 --> 01:10:14.140]  да
[01:10:19.460 --> 01:10:23.860]  да у нас есть способ узнать чем мы с вами разобрали сегодня
[01:10:29.500 --> 01:10:30.300]  а что это
[01:10:33.860 --> 01:10:47.340]  не смотрите что такое абстрактная фабричный метод и адаптер это это паттерн да да да вопрос
[01:10:47.340 --> 01:10:56.540]  какой еще из методов мы сегодня разобрали принципов я больше даже больше сказал мы с
[01:10:56.540 --> 01:11:02.780]  вами сегодня разобрали вот эту вот замечательную историю вот это
[01:11:02.780 --> 01:11:17.740]  кипит симпл стипет у нас есть кипит симпл стипет и он стоит перед драй и он стоит перед солидом
[01:11:17.740 --> 01:11:28.580]  вопрос давайте попытаемся это все совместить у нас есть кис у нас есть паттерны какой анти паттерн
[01:11:29.180 --> 01:11:40.940]  бинго анти паттерн использует паттерны везде и везде везде и всюду
[01:11:40.940 --> 01:11:52.020]  паттерны не панацея от всех болезней вот это суть этого анти паттерн и получается что анти паттерн
[01:11:52.620 --> 01:12:01.180]  надеется на паттерны вся и всюду нарушает принцип кис а понятен этот тезис
[01:12:01.180 --> 01:12:13.860]  чрезмерное употребление паттернов да ну я не точное название привел возможно что мы сможем там
[01:12:13.860 --> 01:12:20.180]  если поищу информацию в интернете я скажу как этот паттерн точно называется в итоге что мы
[01:12:20.180 --> 01:12:27.940]  сегодня с вами разобрали по факту мы с вами сегодня разобрали основные принципы это солид это
[01:12:27.940 --> 01:12:33.380]  я гни после него идет кис после него идет драй и рассмотрели первые реализации в виде паттернов и
[01:12:33.380 --> 01:12:41.740]  анти паттернов значит следующих сериях мы с вами начнем про мл я вспомнил картинку сейчас покажу
[01:12:41.740 --> 01:12:53.420]  и про методология разработки по я вспомнил сейчас я попытаюсь ее найти если подождете минутку
[01:12:58.540 --> 01:13:06.300]  по почему кипит simple stupid это работает есть замечательная вот такая картинка не знаю видно
[01:13:06.300 --> 01:13:14.420]  или нет это немножко что методология разработки значит смотрите верхняя модель это так называем
[01:13:14.420 --> 01:13:21.820]  водопадная забегая на будущий а нижняя это радостный человечек везде катается на всем вопрос
[01:13:21.820 --> 01:13:35.380]  где у нас нарушается кипит simple stupid сверху видите у нас нарушение идет киса вам нужна штука
[01:13:35.380 --> 01:13:43.260]  которая людям должна помогать ездить да нам не нужна большая машина вот и получается так что
[01:13:43.260 --> 01:13:47.340]  маленькие проекты вот бегают маленькими интеракциями для того чтобы всегда поставлять
[01:13:47.340 --> 01:13:54.380]  заказ но мы про это как раз будем говорить про мы в теме про методология разработки по так
[01:13:54.380 --> 01:13:55.860]  на этом все давайте вопроса
